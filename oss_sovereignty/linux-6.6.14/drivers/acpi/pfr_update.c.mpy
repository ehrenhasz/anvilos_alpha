{
  "module_name": "pfr_update.c",
  "hash_id": "bbb2a4be11334bf7028bfd24e1871adb44a44a26904762242b57532f4086fedf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pfr_update.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/efi.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/uuid.h>\n\n#include <uapi/linux/pfrut.h>\n\n#define PFRU_FUNC_STANDARD_QUERY\t0\n#define PFRU_FUNC_QUERY_UPDATE_CAP\t1\n#define PFRU_FUNC_QUERY_BUF\t\t2\n#define PFRU_FUNC_START\t\t3\n\n#define PFRU_CODE_INJECT_TYPE\t1\n#define PFRU_DRIVER_UPDATE_TYPE\t2\n\n#define PFRU_REVID_1\t\t1\n#define PFRU_REVID_2\t\t2\n#define PFRU_DEFAULT_REV_ID\tPFRU_REVID_1\n\nenum cap_index {\n\tCAP_STATUS_IDX = 0,\n\tCAP_UPDATE_IDX = 1,\n\tCAP_CODE_TYPE_IDX = 2,\n\tCAP_FW_VER_IDX = 3,\n\tCAP_CODE_RT_VER_IDX = 4,\n\tCAP_DRV_TYPE_IDX = 5,\n\tCAP_DRV_RT_VER_IDX = 6,\n\tCAP_DRV_SVN_IDX = 7,\n\tCAP_PLAT_ID_IDX = 8,\n\tCAP_OEM_ID_IDX = 9,\n\tCAP_OEM_INFO_IDX = 10,\n\tCAP_NR_IDX\n};\n\nenum buf_index {\n\tBUF_STATUS_IDX = 0,\n\tBUF_EXT_STATUS_IDX = 1,\n\tBUF_ADDR_LOW_IDX = 2,\n\tBUF_ADDR_HI_IDX = 3,\n\tBUF_SIZE_IDX = 4,\n\tBUF_NR_IDX\n};\n\nenum update_index {\n\tUPDATE_STATUS_IDX = 0,\n\tUPDATE_EXT_STATUS_IDX = 1,\n\tUPDATE_AUTH_TIME_LOW_IDX = 2,\n\tUPDATE_AUTH_TIME_HI_IDX = 3,\n\tUPDATE_EXEC_TIME_LOW_IDX = 4,\n\tUPDATE_EXEC_TIME_HI_IDX = 5,\n\tUPDATE_NR_IDX\n};\n\nenum pfru_start_action {\n\tSTART_STAGE = 0,\n\tSTART_ACTIVATE = 1,\n\tSTART_STAGE_ACTIVATE = 2,\n};\n\nstruct pfru_device {\n\tu32 rev_id, index;\n\tstruct device *parent_dev;\n\tstruct miscdevice miscdev;\n};\n\nstatic DEFINE_IDA(pfru_ida);\n\n \nstatic const guid_t pfru_guid =\n\tGUID_INIT(0xECF9533B, 0x4A3C, 0x4E89, 0x93, 0x9E, 0xC7, 0x71,\n\t\t  0x12, 0x60, 0x1C, 0x6D);\n\n \nstatic const guid_t pfru_code_inj_guid =\n\tGUID_INIT(0xB2F84B79, 0x7B6E, 0x4E45, 0x88, 0x5F, 0x3F, 0xB9,\n\t\t  0xBB, 0x18, 0x54, 0x02);\n\n \nstatic const guid_t pfru_drv_update_guid =\n\tGUID_INIT(0x4569DD8C, 0x75F1, 0x429A, 0xA3, 0xD6, 0x24, 0xDE,\n\t\t  0x80, 0x97, 0xA0, 0xDF);\n\nstatic inline int pfru_valid_revid(u32 id)\n{\n\treturn id == PFRU_REVID_1 || id == PFRU_REVID_2;\n}\n\nstatic inline struct pfru_device *to_pfru_dev(struct file *file)\n{\n\treturn container_of(file->private_data, struct pfru_device, miscdev);\n}\n\nstatic int query_capability(struct pfru_update_cap_info *cap_hdr,\n\t\t\t    struct pfru_device *pfru_dev)\n{\n\tacpi_handle handle = ACPI_HANDLE(pfru_dev->parent_dev);\n\tunion acpi_object *out_obj;\n\tint ret = -EINVAL;\n\n\tout_obj = acpi_evaluate_dsm_typed(handle, &pfru_guid,\n\t\t\t\t\t  pfru_dev->rev_id,\n\t\t\t\t\t  PFRU_FUNC_QUERY_UPDATE_CAP,\n\t\t\t\t\t  NULL, ACPI_TYPE_PACKAGE);\n\tif (!out_obj)\n\t\treturn ret;\n\n\tif (out_obj->package.count < CAP_NR_IDX ||\n\t    out_obj->package.elements[CAP_STATUS_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[CAP_UPDATE_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[CAP_CODE_TYPE_IDX].type != ACPI_TYPE_BUFFER ||\n\t    out_obj->package.elements[CAP_FW_VER_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[CAP_CODE_RT_VER_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[CAP_DRV_TYPE_IDX].type != ACPI_TYPE_BUFFER ||\n\t    out_obj->package.elements[CAP_DRV_RT_VER_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[CAP_DRV_SVN_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[CAP_PLAT_ID_IDX].type != ACPI_TYPE_BUFFER ||\n\t    out_obj->package.elements[CAP_OEM_ID_IDX].type != ACPI_TYPE_BUFFER ||\n\t    out_obj->package.elements[CAP_OEM_INFO_IDX].type != ACPI_TYPE_BUFFER)\n\t\tgoto free_acpi_buffer;\n\n\tcap_hdr->status = out_obj->package.elements[CAP_STATUS_IDX].integer.value;\n\tif (cap_hdr->status != DSM_SUCCEED) {\n\t\tret = -EBUSY;\n\t\tdev_dbg(pfru_dev->parent_dev, \"Error Status:%d\\n\", cap_hdr->status);\n\t\tgoto free_acpi_buffer;\n\t}\n\n\tcap_hdr->update_cap = out_obj->package.elements[CAP_UPDATE_IDX].integer.value;\n\tmemcpy(&cap_hdr->code_type,\n\t       out_obj->package.elements[CAP_CODE_TYPE_IDX].buffer.pointer,\n\t       out_obj->package.elements[CAP_CODE_TYPE_IDX].buffer.length);\n\tcap_hdr->fw_version =\n\t\tout_obj->package.elements[CAP_FW_VER_IDX].integer.value;\n\tcap_hdr->code_rt_version =\n\t\tout_obj->package.elements[CAP_CODE_RT_VER_IDX].integer.value;\n\tmemcpy(&cap_hdr->drv_type,\n\t       out_obj->package.elements[CAP_DRV_TYPE_IDX].buffer.pointer,\n\t       out_obj->package.elements[CAP_DRV_TYPE_IDX].buffer.length);\n\tcap_hdr->drv_rt_version =\n\t\tout_obj->package.elements[CAP_DRV_RT_VER_IDX].integer.value;\n\tcap_hdr->drv_svn =\n\t\tout_obj->package.elements[CAP_DRV_SVN_IDX].integer.value;\n\tmemcpy(&cap_hdr->platform_id,\n\t       out_obj->package.elements[CAP_PLAT_ID_IDX].buffer.pointer,\n\t       out_obj->package.elements[CAP_PLAT_ID_IDX].buffer.length);\n\tmemcpy(&cap_hdr->oem_id,\n\t       out_obj->package.elements[CAP_OEM_ID_IDX].buffer.pointer,\n\t       out_obj->package.elements[CAP_OEM_ID_IDX].buffer.length);\n\tcap_hdr->oem_info_len =\n\t\tout_obj->package.elements[CAP_OEM_INFO_IDX].buffer.length;\n\n\tret = 0;\n\nfree_acpi_buffer:\n\tACPI_FREE(out_obj);\n\n\treturn ret;\n}\n\nstatic int query_buffer(struct pfru_com_buf_info *info,\n\t\t\tstruct pfru_device *pfru_dev)\n{\n\tacpi_handle handle = ACPI_HANDLE(pfru_dev->parent_dev);\n\tunion acpi_object *out_obj;\n\tint ret = -EINVAL;\n\n\tout_obj = acpi_evaluate_dsm_typed(handle, &pfru_guid,\n\t\t\t\t\t  pfru_dev->rev_id, PFRU_FUNC_QUERY_BUF,\n\t\t\t\t\t  NULL, ACPI_TYPE_PACKAGE);\n\tif (!out_obj)\n\t\treturn ret;\n\n\tif (out_obj->package.count < BUF_NR_IDX ||\n\t    out_obj->package.elements[BUF_STATUS_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[BUF_EXT_STATUS_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[BUF_ADDR_LOW_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[BUF_ADDR_HI_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[BUF_SIZE_IDX].type != ACPI_TYPE_INTEGER)\n\t\tgoto free_acpi_buffer;\n\n\tinfo->status = out_obj->package.elements[BUF_STATUS_IDX].integer.value;\n\tinfo->ext_status =\n\t\tout_obj->package.elements[BUF_EXT_STATUS_IDX].integer.value;\n\tif (info->status != DSM_SUCCEED) {\n\t\tret = -EBUSY;\n\t\tdev_dbg(pfru_dev->parent_dev, \"Error Status:%d\\n\", info->status);\n\t\tdev_dbg(pfru_dev->parent_dev, \"Error Extended Status:%d\\n\", info->ext_status);\n\n\t\tgoto free_acpi_buffer;\n\t}\n\n\tinfo->addr_lo =\n\t\tout_obj->package.elements[BUF_ADDR_LOW_IDX].integer.value;\n\tinfo->addr_hi =\n\t\tout_obj->package.elements[BUF_ADDR_HI_IDX].integer.value;\n\tinfo->buf_size = out_obj->package.elements[BUF_SIZE_IDX].integer.value;\n\n\tret = 0;\n\nfree_acpi_buffer:\n\tACPI_FREE(out_obj);\n\n\treturn ret;\n}\n\nstatic int get_image_type(const struct efi_manage_capsule_image_header *img_hdr,\n\t\t\t  struct pfru_device *pfru_dev)\n{\n\tconst efi_guid_t *image_type_id = &img_hdr->image_type_id;\n\n\t \n\tif (guid_equal(image_type_id, &pfru_code_inj_guid))\n\t\treturn PFRU_CODE_INJECT_TYPE;\n\n\tif (guid_equal(image_type_id, &pfru_drv_update_guid))\n\t\treturn PFRU_DRIVER_UPDATE_TYPE;\n\n\treturn -EINVAL;\n}\n\nstatic int adjust_efi_size(const struct efi_manage_capsule_image_header *img_hdr,\n\t\t\t   int size)\n{\n\t \n\tsize += sizeof(struct efi_manage_capsule_image_header);\n\tswitch (img_hdr->ver) {\n\tcase 1:\n\t\treturn size - 2 * sizeof(u64);\n\n\tcase 2:\n\t\treturn size - sizeof(u64);\n\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool applicable_image(const void *data, struct pfru_update_cap_info *cap,\n\t\t\t     struct pfru_device *pfru_dev)\n{\n\tstruct pfru_payload_hdr *payload_hdr;\n\tconst efi_capsule_header_t *cap_hdr = data;\n\tconst struct efi_manage_capsule_header *m_hdr;\n\tconst struct efi_manage_capsule_image_header *m_img_hdr;\n\tconst struct efi_image_auth *auth;\n\tint type, size;\n\n\t \n\tsize = cap_hdr->headersize;\n\tm_hdr = data + size;\n\t \n\tsize += offsetof(struct efi_manage_capsule_header, offset_list) +\n\t\t(m_hdr->emb_drv_cnt + m_hdr->payload_cnt) * sizeof(u64);\n\tm_img_hdr = data + size;\n\n\ttype = get_image_type(m_img_hdr, pfru_dev);\n\tif (type < 0)\n\t\treturn false;\n\n\tsize = adjust_efi_size(m_img_hdr, size);\n\tif (size < 0)\n\t\treturn false;\n\n\tauth = data + size;\n\tsize += sizeof(u64) + auth->auth_info.hdr.len;\n\tpayload_hdr = (struct pfru_payload_hdr *)(data + size);\n\n\t \n\tif (type == PFRU_CODE_INJECT_TYPE)\n\t\treturn payload_hdr->rt_ver >= cap->code_rt_version;\n\n\treturn payload_hdr->rt_ver >= cap->drv_rt_version;\n}\n\nstatic void print_update_debug_info(struct pfru_updated_result *result,\n\t\t\t\t    struct pfru_device *pfru_dev)\n{\n\tdev_dbg(pfru_dev->parent_dev, \"Update result:\\n\");\n\tdev_dbg(pfru_dev->parent_dev, \"Authentication Time Low:%lld\\n\",\n\t\tresult->low_auth_time);\n\tdev_dbg(pfru_dev->parent_dev, \"Authentication Time High:%lld\\n\",\n\t\tresult->high_auth_time);\n\tdev_dbg(pfru_dev->parent_dev, \"Execution Time Low:%lld\\n\",\n\t\tresult->low_exec_time);\n\tdev_dbg(pfru_dev->parent_dev, \"Execution Time High:%lld\\n\",\n\t\tresult->high_exec_time);\n}\n\nstatic int start_update(int action, struct pfru_device *pfru_dev)\n{\n\tunion acpi_object *out_obj, in_obj, in_buf;\n\tstruct pfru_updated_result update_result;\n\tacpi_handle handle;\n\tint ret = -EINVAL;\n\n\tmemset(&in_obj, 0, sizeof(in_obj));\n\tmemset(&in_buf, 0, sizeof(in_buf));\n\tin_obj.type = ACPI_TYPE_PACKAGE;\n\tin_obj.package.count = 1;\n\tin_obj.package.elements = &in_buf;\n\tin_buf.type = ACPI_TYPE_INTEGER;\n\tin_buf.integer.value = action;\n\n\thandle = ACPI_HANDLE(pfru_dev->parent_dev);\n\tout_obj = acpi_evaluate_dsm_typed(handle, &pfru_guid,\n\t\t\t\t\t  pfru_dev->rev_id, PFRU_FUNC_START,\n\t\t\t\t\t  &in_obj, ACPI_TYPE_PACKAGE);\n\tif (!out_obj)\n\t\treturn ret;\n\n\tif (out_obj->package.count < UPDATE_NR_IDX ||\n\t    out_obj->package.elements[UPDATE_STATUS_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[UPDATE_EXT_STATUS_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[UPDATE_AUTH_TIME_LOW_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[UPDATE_AUTH_TIME_HI_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[UPDATE_EXEC_TIME_LOW_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[UPDATE_EXEC_TIME_HI_IDX].type != ACPI_TYPE_INTEGER)\n\t\tgoto free_acpi_buffer;\n\n\tupdate_result.status =\n\t\tout_obj->package.elements[UPDATE_STATUS_IDX].integer.value;\n\tupdate_result.ext_status =\n\t\tout_obj->package.elements[UPDATE_EXT_STATUS_IDX].integer.value;\n\n\tif (update_result.status != DSM_SUCCEED) {\n\t\tret = -EBUSY;\n\t\tdev_dbg(pfru_dev->parent_dev, \"Error Status:%d\\n\", update_result.status);\n\t\tdev_dbg(pfru_dev->parent_dev, \"Error Extended Status:%d\\n\",\n\t\t\tupdate_result.ext_status);\n\n\t\tgoto free_acpi_buffer;\n\t}\n\n\tupdate_result.low_auth_time =\n\t\tout_obj->package.elements[UPDATE_AUTH_TIME_LOW_IDX].integer.value;\n\tupdate_result.high_auth_time =\n\t\tout_obj->package.elements[UPDATE_AUTH_TIME_HI_IDX].integer.value;\n\tupdate_result.low_exec_time =\n\t\tout_obj->package.elements[UPDATE_EXEC_TIME_LOW_IDX].integer.value;\n\tupdate_result.high_exec_time =\n\t\tout_obj->package.elements[UPDATE_EXEC_TIME_HI_IDX].integer.value;\n\n\tprint_update_debug_info(&update_result, pfru_dev);\n\tret = 0;\n\nfree_acpi_buffer:\n\tACPI_FREE(out_obj);\n\n\treturn ret;\n}\n\nstatic long pfru_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pfru_update_cap_info cap_hdr;\n\tstruct pfru_device *pfru_dev = to_pfru_dev(file);\n\tvoid __user *p = (void __user *)arg;\n\tu32 rev;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase PFRU_IOC_QUERY_CAP:\n\t\tret = query_capability(&cap_hdr, pfru_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(p, &cap_hdr, sizeof(cap_hdr)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n\tcase PFRU_IOC_SET_REV:\n\t\tif (copy_from_user(&rev, p, sizeof(rev)))\n\t\t\treturn -EFAULT;\n\n\t\tif (!pfru_valid_revid(rev))\n\t\t\treturn -EINVAL;\n\n\t\tpfru_dev->rev_id = rev;\n\n\t\treturn 0;\n\n\tcase PFRU_IOC_STAGE:\n\t\treturn start_update(START_STAGE, pfru_dev);\n\n\tcase PFRU_IOC_ACTIVATE:\n\t\treturn start_update(START_ACTIVATE, pfru_dev);\n\n\tcase PFRU_IOC_STAGE_ACTIVATE:\n\t\treturn start_update(START_STAGE_ACTIVATE, pfru_dev);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic ssize_t pfru_write(struct file *file, const char __user *buf,\n\t\t\t  size_t len, loff_t *ppos)\n{\n\tstruct pfru_device *pfru_dev = to_pfru_dev(file);\n\tstruct pfru_update_cap_info cap;\n\tstruct pfru_com_buf_info buf_info;\n\tphys_addr_t phy_addr;\n\tstruct iov_iter iter;\n\tstruct iovec iov;\n\tchar *buf_ptr;\n\tint ret;\n\n\tret = query_buffer(&buf_info, pfru_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (len > buf_info.buf_size)\n\t\treturn -EINVAL;\n\n\tiov.iov_base = (void __user *)buf;\n\tiov.iov_len = len;\n\tiov_iter_init(&iter, ITER_SOURCE, &iov, 1, len);\n\n\t \n\tphy_addr = (phys_addr_t)((buf_info.addr_hi << 32) | buf_info.addr_lo);\n\tbuf_ptr = memremap(phy_addr, buf_info.buf_size, MEMREMAP_WB);\n\tif (!buf_ptr)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(buf_ptr, len, &iter)) {\n\t\tret = -EINVAL;\n\t\tgoto unmap;\n\t}\n\n\t \n\tret = query_capability(&cap, pfru_dev);\n\tif (ret)\n\t\tgoto unmap;\n\n\tif (!applicable_image(buf_ptr, &cap, pfru_dev))\n\t\tret = -EINVAL;\n\nunmap:\n\tmemunmap(buf_ptr);\n\n\treturn ret ?: len;\n}\n\nstatic const struct file_operations acpi_pfru_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= pfru_write,\n\t.unlocked_ioctl = pfru_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int acpi_pfru_remove(struct platform_device *pdev)\n{\n\tstruct pfru_device *pfru_dev = platform_get_drvdata(pdev);\n\n\tmisc_deregister(&pfru_dev->miscdev);\n\n\treturn 0;\n}\n\nstatic void pfru_put_idx(void *data)\n{\n\tstruct pfru_device *pfru_dev = data;\n\n\tida_free(&pfru_ida, pfru_dev->index);\n}\n\nstatic int acpi_pfru_probe(struct platform_device *pdev)\n{\n\tacpi_handle handle = ACPI_HANDLE(&pdev->dev);\n\tstruct pfru_device *pfru_dev;\n\tint ret;\n\n\tif (!acpi_has_method(handle, \"_DSM\")) {\n\t\tdev_dbg(&pdev->dev, \"Missing _DSM\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpfru_dev = devm_kzalloc(&pdev->dev, sizeof(*pfru_dev), GFP_KERNEL);\n\tif (!pfru_dev)\n\t\treturn -ENOMEM;\n\n\tret = ida_alloc(&pfru_ida, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpfru_dev->index = ret;\n\tret = devm_add_action_or_reset(&pdev->dev, pfru_put_idx, pfru_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpfru_dev->rev_id = PFRU_DEFAULT_REV_ID;\n\tpfru_dev->parent_dev = &pdev->dev;\n\n\tpfru_dev->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tpfru_dev->miscdev.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\"pfru%d\", pfru_dev->index);\n\tif (!pfru_dev->miscdev.name)\n\t\treturn -ENOMEM;\n\n\tpfru_dev->miscdev.nodename = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t    \"acpi_pfr_update%d\", pfru_dev->index);\n\tif (!pfru_dev->miscdev.nodename)\n\t\treturn -ENOMEM;\n\n\tpfru_dev->miscdev.fops = &acpi_pfru_fops;\n\tpfru_dev->miscdev.parent = &pdev->dev;\n\n\tret = misc_register(&pfru_dev->miscdev);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, pfru_dev);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id acpi_pfru_ids[] = {\n\t{\"INTC1080\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, acpi_pfru_ids);\n\nstatic struct platform_driver acpi_pfru_driver = {\n\t.driver = {\n\t\t.name = \"pfr_update\",\n\t\t.acpi_match_table = acpi_pfru_ids,\n\t},\n\t.probe = acpi_pfru_probe,\n\t.remove = acpi_pfru_remove,\n};\nmodule_platform_driver(acpi_pfru_driver);\n\nMODULE_DESCRIPTION(\"Platform Firmware Runtime Update device driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}