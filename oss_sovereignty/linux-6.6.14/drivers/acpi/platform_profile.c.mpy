{
  "module_name": "platform_profile.c",
  "hash_id": "cb91ada66b381c425296505eaa8d1bf1a05f69db5c5e088bac98207392ade57e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/platform_profile.c",
  "human_readable_source": "\n\n \n\n#include <linux/acpi.h>\n#include <linux/bits.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/platform_profile.h>\n#include <linux/sysfs.h>\n\nstatic struct platform_profile_handler *cur_profile;\nstatic DEFINE_MUTEX(profile_lock);\n\nstatic const char * const profile_names[] = {\n\t[PLATFORM_PROFILE_LOW_POWER] = \"low-power\",\n\t[PLATFORM_PROFILE_COOL] = \"cool\",\n\t[PLATFORM_PROFILE_QUIET] = \"quiet\",\n\t[PLATFORM_PROFILE_BALANCED] = \"balanced\",\n\t[PLATFORM_PROFILE_BALANCED_PERFORMANCE] = \"balanced-performance\",\n\t[PLATFORM_PROFILE_PERFORMANCE] = \"performance\",\n};\nstatic_assert(ARRAY_SIZE(profile_names) == PLATFORM_PROFILE_LAST);\n\nstatic ssize_t platform_profile_choices_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint len = 0;\n\tint err, i;\n\n\terr = mutex_lock_interruptible(&profile_lock);\n\tif (err)\n\t\treturn err;\n\n\tif (!cur_profile) {\n\t\tmutex_unlock(&profile_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tfor_each_set_bit(i, cur_profile->choices, PLATFORM_PROFILE_LAST) {\n\t\tif (len == 0)\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s\", profile_names[i]);\n\t\telse\n\t\t\tlen += sysfs_emit_at(buf, len, \" %s\", profile_names[i]);\n\t}\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\tmutex_unlock(&profile_lock);\n\treturn len;\n}\n\nstatic ssize_t platform_profile_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tenum platform_profile_option profile = PLATFORM_PROFILE_BALANCED;\n\tint err;\n\n\terr = mutex_lock_interruptible(&profile_lock);\n\tif (err)\n\t\treturn err;\n\n\tif (!cur_profile) {\n\t\tmutex_unlock(&profile_lock);\n\t\treturn -ENODEV;\n\t}\n\n\terr = cur_profile->profile_get(cur_profile, &profile);\n\tmutex_unlock(&profile_lock);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (WARN_ON((profile < 0) || (profile >= ARRAY_SIZE(profile_names))))\n\t\treturn -EIO;\n\n\treturn sysfs_emit(buf, \"%s\\n\", profile_names[profile]);\n}\n\nstatic ssize_t platform_profile_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tint err, i;\n\n\terr = mutex_lock_interruptible(&profile_lock);\n\tif (err)\n\t\treturn err;\n\n\tif (!cur_profile) {\n\t\tmutex_unlock(&profile_lock);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\ti = sysfs_match_string(profile_names, buf);\n\tif (i < 0) {\n\t\tmutex_unlock(&profile_lock);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!test_bit(i, cur_profile->choices)) {\n\t\tmutex_unlock(&profile_lock);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = cur_profile->profile_set(cur_profile, i);\n\tif (!err)\n\t\tsysfs_notify(acpi_kobj, NULL, \"platform_profile\");\n\n\tmutex_unlock(&profile_lock);\n\tif (err)\n\t\treturn err;\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RO(platform_profile_choices);\nstatic DEVICE_ATTR_RW(platform_profile);\n\nstatic struct attribute *platform_profile_attrs[] = {\n\t&dev_attr_platform_profile_choices.attr,\n\t&dev_attr_platform_profile.attr,\n\tNULL\n};\n\nstatic const struct attribute_group platform_profile_group = {\n\t.attrs = platform_profile_attrs\n};\n\nvoid platform_profile_notify(void)\n{\n\tif (!cur_profile)\n\t\treturn;\n\tsysfs_notify(acpi_kobj, NULL, \"platform_profile\");\n}\nEXPORT_SYMBOL_GPL(platform_profile_notify);\n\nint platform_profile_register(struct platform_profile_handler *pprof)\n{\n\tint err;\n\n\tmutex_lock(&profile_lock);\n\t \n\tif (cur_profile) {\n\t\tmutex_unlock(&profile_lock);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\tif (!pprof || bitmap_empty(pprof->choices, PLATFORM_PROFILE_LAST) ||\n\t\t!pprof->profile_set || !pprof->profile_get) {\n\t\tmutex_unlock(&profile_lock);\n\t\treturn -EINVAL;\n\t}\n\n\terr = sysfs_create_group(acpi_kobj, &platform_profile_group);\n\tif (err) {\n\t\tmutex_unlock(&profile_lock);\n\t\treturn err;\n\t}\n\n\tcur_profile = pprof;\n\tmutex_unlock(&profile_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(platform_profile_register);\n\nint platform_profile_remove(void)\n{\n\tsysfs_remove_group(acpi_kobj, &platform_profile_group);\n\n\tmutex_lock(&profile_lock);\n\tcur_profile = NULL;\n\tmutex_unlock(&profile_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(platform_profile_remove);\n\nMODULE_AUTHOR(\"Mark Pearson <markpearson@lenovo.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}