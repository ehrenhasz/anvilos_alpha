{
  "module_name": "acpi_lpat.c",
  "hash_id": "4b7dbc2cb2f93f6c26803ad2202774bf793de9dc394a3ac3410c01f98babe30e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_lpat.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/acpi.h>\n#include <acpi/acpi_lpat.h>\n\n \nint acpi_lpat_raw_to_temp(struct acpi_lpat_conversion_table *lpat_table,\n\t\t\t  int raw)\n{\n\tint i, delta_temp, delta_raw, temp;\n\tstruct acpi_lpat *lpat = lpat_table->lpat;\n\n\tfor (i = 0; i < lpat_table->lpat_count - 1; i++) {\n\t\tif ((raw >= lpat[i].raw && raw <= lpat[i+1].raw) ||\n\t\t    (raw <= lpat[i].raw && raw >= lpat[i+1].raw))\n\t\t\tbreak;\n\t}\n\n\tif (i == lpat_table->lpat_count - 1)\n\t\treturn -ENOENT;\n\n\tdelta_temp = lpat[i+1].temp - lpat[i].temp;\n\tdelta_raw = lpat[i+1].raw - lpat[i].raw;\n\ttemp = lpat[i].temp + (raw - lpat[i].raw) * delta_temp / delta_raw;\n\n\treturn temp;\n}\nEXPORT_SYMBOL_GPL(acpi_lpat_raw_to_temp);\n\n \nint acpi_lpat_temp_to_raw(struct acpi_lpat_conversion_table *lpat_table,\n\t\t\t  int temp)\n{\n\tint i, delta_temp, delta_raw, raw;\n\tstruct acpi_lpat *lpat = lpat_table->lpat;\n\n\tfor (i = 0; i < lpat_table->lpat_count - 1; i++) {\n\t\tif (temp >= lpat[i].temp && temp <= lpat[i+1].temp)\n\t\t\tbreak;\n\t}\n\n\tif (i ==  lpat_table->lpat_count - 1)\n\t\treturn -ENOENT;\n\n\tdelta_temp = lpat[i+1].temp - lpat[i].temp;\n\tdelta_raw = lpat[i+1].raw - lpat[i].raw;\n\traw = lpat[i].raw + (temp - lpat[i].temp) * delta_raw / delta_temp;\n\n\treturn raw;\n}\nEXPORT_SYMBOL_GPL(acpi_lpat_temp_to_raw);\n\n \nstruct acpi_lpat_conversion_table *acpi_lpat_get_conversion_table(acpi_handle\n\t\t\t\t\t\t\t\t  handle)\n{\n\tstruct acpi_lpat_conversion_table *lpat_table = NULL;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj_p, *obj_e;\n\tint *lpat, i;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(handle, \"LPAT\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn NULL;\n\n\tobj_p = (union acpi_object *)buffer.pointer;\n\tif (!obj_p || (obj_p->type != ACPI_TYPE_PACKAGE) ||\n\t    (obj_p->package.count % 2) || (obj_p->package.count < 4))\n\t\tgoto out;\n\n\tlpat = kcalloc(obj_p->package.count, sizeof(int), GFP_KERNEL);\n\tif (!lpat)\n\t\tgoto out;\n\n\tfor (i = 0; i < obj_p->package.count; i++) {\n\t\tobj_e = &obj_p->package.elements[i];\n\t\tif (obj_e->type != ACPI_TYPE_INTEGER) {\n\t\t\tkfree(lpat);\n\t\t\tgoto out;\n\t\t}\n\t\tlpat[i] = (s64)obj_e->integer.value;\n\t}\n\n\tlpat_table = kzalloc(sizeof(*lpat_table), GFP_KERNEL);\n\tif (!lpat_table) {\n\t\tkfree(lpat);\n\t\tgoto out;\n\t}\n\n\tlpat_table->lpat = (struct acpi_lpat *)lpat;\n\tlpat_table->lpat_count = obj_p->package.count / 2;\n\nout:\n\tkfree(buffer.pointer);\n\treturn lpat_table;\n}\nEXPORT_SYMBOL_GPL(acpi_lpat_get_conversion_table);\n\n \nvoid acpi_lpat_free_conversion_table(struct acpi_lpat_conversion_table\n\t\t\t\t     *lpat_table)\n{\n\tif (lpat_table) {\n\t\tkfree(lpat_table->lpat);\n\t\tkfree(lpat_table);\n\t}\n}\nEXPORT_SYMBOL_GPL(acpi_lpat_free_conversion_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}