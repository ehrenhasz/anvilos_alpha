{
  "module_name": "ioapic.c",
  "hash_id": "c1ae8e339475246cf6adfffb1f5bb10f8c3e102ed2795c1c7798fedfecb11c7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/ioapic.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"ACPI: IOAPIC: \" fmt\n\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <acpi/acpi.h>\n#include \"internal.h\"\n\nstruct acpi_pci_ioapic {\n\tacpi_handle\troot_handle;\n\tacpi_handle\thandle;\n\tu32\t\tgsi_base;\n\tstruct resource\tres;\n\tstruct pci_dev\t*pdev;\n\tstruct list_head list;\n};\n\nstatic LIST_HEAD(ioapic_list);\nstatic DEFINE_MUTEX(ioapic_list_lock);\n\nstatic acpi_status setup_res(struct acpi_resource *acpi_res, void *data)\n{\n\tstruct resource *res = data;\n\tstruct resource_win win;\n\n\t \n\tmemset(&win, 0, sizeof(win));\n\n\tres->flags = 0;\n\tif (acpi_dev_filter_resource_type(acpi_res, IORESOURCE_MEM))\n\t\treturn AE_OK;\n\n\tif (!acpi_dev_resource_memory(acpi_res, res)) {\n\t\tif (acpi_dev_resource_address_space(acpi_res, &win) ||\n\t\t    acpi_dev_resource_ext_address_space(acpi_res, &win))\n\t\t\t*res = win.res;\n\t}\n\tif ((res->flags & IORESOURCE_PREFETCH) ||\n\t    (res->flags & IORESOURCE_DISABLED))\n\t\tres->flags = 0;\n\n\treturn AE_CTRL_TERMINATE;\n}\n\nstatic bool acpi_is_ioapic(acpi_handle handle, char **type)\n{\n\tacpi_status status;\n\tstruct acpi_device_info *info;\n\tchar *hid = NULL;\n\tbool match = false;\n\n\tif (!acpi_has_method(handle, \"_GSB\"))\n\t\treturn false;\n\n\tstatus = acpi_get_object_info(handle, &info);\n\tif (ACPI_SUCCESS(status)) {\n\t\tif (info->valid & ACPI_VALID_HID)\n\t\t\thid = info->hardware_id.string;\n\t\tif (hid) {\n\t\t\tif (strcmp(hid, \"ACPI0009\") == 0) {\n\t\t\t\t*type = \"IOxAPIC\";\n\t\t\t\tmatch = true;\n\t\t\t} else if (strcmp(hid, \"ACPI000A\") == 0) {\n\t\t\t\t*type = \"IOAPIC\";\n\t\t\t\tmatch = true;\n\t\t\t}\n\t\t}\n\t\tkfree(info);\n\t}\n\n\treturn match;\n}\n\nstatic acpi_status handle_ioapic_add(acpi_handle handle, u32 lvl,\n\t\t\t\t     void *context, void **rv)\n{\n\tacpi_status status;\n\tunsigned long long gsi_base;\n\tstruct acpi_pci_ioapic *ioapic;\n\tstruct pci_dev *dev = NULL;\n\tstruct resource *res = NULL, *pci_res = NULL, *crs_res;\n\tchar *type = NULL;\n\n\tif (!acpi_is_ioapic(handle, &type))\n\t\treturn AE_OK;\n\n\tmutex_lock(&ioapic_list_lock);\n\tlist_for_each_entry(ioapic, &ioapic_list, list)\n\t\tif (ioapic->handle == handle) {\n\t\t\tmutex_unlock(&ioapic_list_lock);\n\t\t\treturn AE_OK;\n\t\t}\n\n\tstatus = acpi_evaluate_integer(handle, \"_GSB\", NULL, &gsi_base);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_warn(handle, \"failed to evaluate _GSB method\\n\");\n\t\tgoto exit;\n\t}\n\n\tioapic = kzalloc(sizeof(*ioapic), GFP_KERNEL);\n\tif (!ioapic) {\n\t\tpr_err(\"cannot allocate memory for new IOAPIC\\n\");\n\t\tgoto exit;\n\t} else {\n\t\tioapic->root_handle = (acpi_handle)context;\n\t\tioapic->handle = handle;\n\t\tioapic->gsi_base = (u32)gsi_base;\n\t\tINIT_LIST_HEAD(&ioapic->list);\n\t}\n\n\tif (acpi_ioapic_registered(handle, (u32)gsi_base))\n\t\tgoto done;\n\n\tdev = acpi_get_pci_dev(handle);\n\tif (dev && pci_resource_len(dev, 0)) {\n\t\tif (pci_enable_device(dev) < 0)\n\t\t\tgoto exit_put;\n\t\tpci_set_master(dev);\n\t\tif (pci_request_region(dev, 0, type))\n\t\t\tgoto exit_disable;\n\t\tpci_res = &dev->resource[0];\n\t\tioapic->pdev = dev;\n\t} else {\n\t\tpci_dev_put(dev);\n\t\tdev = NULL;\n\t}\n\n\tcrs_res = &ioapic->res;\n\tacpi_walk_resources(handle, METHOD_NAME__CRS, setup_res, crs_res);\n\tcrs_res->name = type;\n\tcrs_res->flags |= IORESOURCE_BUSY;\n\tif (crs_res->flags == 0) {\n\t\tacpi_handle_warn(handle, \"failed to get resource\\n\");\n\t\tgoto exit_release;\n\t} else if (insert_resource(&iomem_resource, crs_res)) {\n\t\tacpi_handle_warn(handle, \"failed to insert resource\\n\");\n\t\tgoto exit_release;\n\t}\n\n\t \n\tres = pci_res;\n\tif (!res || !res->flags)\n\t\tres = crs_res;\n\n\tif (acpi_register_ioapic(handle, res->start, (u32)gsi_base)) {\n\t\tacpi_handle_warn(handle, \"failed to register IOAPIC\\n\");\n\t\tgoto exit_release;\n\t}\ndone:\n\tlist_add(&ioapic->list, &ioapic_list);\n\tmutex_unlock(&ioapic_list_lock);\n\n\tif (dev)\n\t\tdev_info(&dev->dev, \"%s at %pR, GSI %u\\n\",\n\t\t\t type, res, (u32)gsi_base);\n\telse\n\t\tacpi_handle_info(handle, \"%s at %pR, GSI %u\\n\",\n\t\t\t\t type, res, (u32)gsi_base);\n\n\treturn AE_OK;\n\nexit_release:\n\tif (dev)\n\t\tpci_release_region(dev, 0);\n\tif (ioapic->res.flags && ioapic->res.parent)\n\t\trelease_resource(&ioapic->res);\nexit_disable:\n\tif (dev)\n\t\tpci_disable_device(dev);\nexit_put:\n\tpci_dev_put(dev);\n\tkfree(ioapic);\nexit:\n\tmutex_unlock(&ioapic_list_lock);\n\t*(acpi_status *)rv = AE_ERROR;\n\treturn AE_OK;\n}\n\nint acpi_ioapic_add(acpi_handle root_handle)\n{\n\tacpi_status status, retval = AE_OK;\n\n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE, root_handle,\n\t\t\t\t     UINT_MAX, handle_ioapic_add, NULL,\n\t\t\t\t     root_handle, (void **)&retval);\n\n\treturn ACPI_SUCCESS(status) && ACPI_SUCCESS(retval) ? 0 : -ENODEV;\n}\n\nvoid pci_ioapic_remove(struct acpi_pci_root *root)\n{\n\tstruct acpi_pci_ioapic *ioapic, *tmp;\n\n\tmutex_lock(&ioapic_list_lock);\n\tlist_for_each_entry_safe(ioapic, tmp, &ioapic_list, list) {\n\t\tif (root->device->handle != ioapic->root_handle)\n\t\t\tcontinue;\n\t\tif (ioapic->pdev) {\n\t\t\tpci_release_region(ioapic->pdev, 0);\n\t\t\tpci_disable_device(ioapic->pdev);\n\t\t\tpci_dev_put(ioapic->pdev);\n\t\t}\n\t}\n\tmutex_unlock(&ioapic_list_lock);\n}\n\nint acpi_ioapic_remove(struct acpi_pci_root *root)\n{\n\tint retval = 0;\n\tstruct acpi_pci_ioapic *ioapic, *tmp;\n\n\tmutex_lock(&ioapic_list_lock);\n\tlist_for_each_entry_safe(ioapic, tmp, &ioapic_list, list) {\n\t\tif (root->device->handle != ioapic->root_handle)\n\t\t\tcontinue;\n\t\tif (acpi_unregister_ioapic(ioapic->handle, ioapic->gsi_base))\n\t\t\tretval = -EBUSY;\n\t\tif (ioapic->res.flags && ioapic->res.parent)\n\t\t\trelease_resource(&ioapic->res);\n\t\tlist_del(&ioapic->list);\n\t\tkfree(ioapic);\n\t}\n\tmutex_unlock(&ioapic_list_lock);\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}