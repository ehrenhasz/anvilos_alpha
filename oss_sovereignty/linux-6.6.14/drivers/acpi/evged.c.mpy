{
  "module_name": "evged.c",
  "hash_id": "e4c5b26277abd371a09823d18d90864901967a9d5883a2197b850ab94e008d1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/evged.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n\n#define MODULE_NAME\t\"acpi-ged\"\n\nstruct acpi_ged_device {\n\tstruct device *dev;\n\tstruct list_head event_list;\n};\n\nstruct acpi_ged_event {\n\tstruct list_head node;\n\tstruct device *dev;\n\tunsigned int gsi;\n\tunsigned int irq;\n\tacpi_handle handle;\n};\n\nstatic irqreturn_t acpi_ged_irq_handler(int irq, void *data)\n{\n\tstruct acpi_ged_event *event = data;\n\tacpi_status acpi_ret;\n\n\tacpi_ret = acpi_execute_simple_method(event->handle, NULL, event->gsi);\n\tif (ACPI_FAILURE(acpi_ret))\n\t\tdev_err_once(event->dev, \"IRQ method execution failed\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic acpi_status acpi_ged_request_interrupt(struct acpi_resource *ares,\n\t\t\t\t\t      void *context)\n{\n\tstruct acpi_ged_event *event;\n\tunsigned int irq;\n\tunsigned int gsi;\n\tunsigned int irqflags = IRQF_ONESHOT;\n\tstruct acpi_ged_device *geddev = context;\n\tstruct device *dev = geddev->dev;\n\tacpi_handle handle = ACPI_HANDLE(dev);\n\tacpi_handle evt_handle;\n\tstruct resource r;\n\tstruct acpi_resource_irq *p = &ares->data.irq;\n\tstruct acpi_resource_extended_irq *pext = &ares->data.extended_irq;\n\tchar ev_name[5];\n\tu8 trigger;\n\n\tif (ares->type == ACPI_RESOURCE_TYPE_END_TAG)\n\t\treturn AE_OK;\n\n\tif (!acpi_dev_resource_interrupt(ares, 0, &r)) {\n\t\tdev_err(dev, \"unable to parse IRQ resource\\n\");\n\t\treturn AE_ERROR;\n\t}\n\tif (ares->type == ACPI_RESOURCE_TYPE_IRQ) {\n\t\tgsi = p->interrupts[0];\n\t\ttrigger = p->triggering;\n\t} else {\n\t\tgsi = pext->interrupts[0];\n\t\ttrigger = pext->triggering;\n\t}\n\n\tirq = r.start;\n\n\tswitch (gsi) {\n\tcase 0 ... 255:\n\t\tsprintf(ev_name, \"_%c%02X\",\n\t\t\ttrigger == ACPI_EDGE_SENSITIVE ? 'E' : 'L', gsi);\n\n\t\tif (ACPI_SUCCESS(acpi_get_handle(handle, ev_name, &evt_handle)))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tif (ACPI_SUCCESS(acpi_get_handle(handle, \"_EVT\", &evt_handle)))\n\t\t\tbreak;\n\n\t\tdev_err(dev, \"cannot locate _EVT method\\n\");\n\t\treturn AE_ERROR;\n\t}\n\n\tevent = devm_kzalloc(dev, sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\treturn AE_ERROR;\n\n\tevent->gsi = gsi;\n\tevent->dev = dev;\n\tevent->irq = irq;\n\tevent->handle = evt_handle;\n\n\tif (r.flags & IORESOURCE_IRQ_SHAREABLE)\n\t\tirqflags |= IRQF_SHARED;\n\n\tif (request_threaded_irq(irq, NULL, acpi_ged_irq_handler,\n\t\t\t\t irqflags, \"ACPI:Ged\", event)) {\n\t\tdev_err(dev, \"failed to setup event handler for irq %u\\n\", irq);\n\t\treturn AE_ERROR;\n\t}\n\n\tdev_dbg(dev, \"GED listening GSI %u @ IRQ %u\\n\", gsi, irq);\n\tlist_add_tail(&event->node, &geddev->event_list);\n\treturn AE_OK;\n}\n\nstatic int ged_probe(struct platform_device *pdev)\n{\n\tstruct acpi_ged_device *geddev;\n\tacpi_status acpi_ret;\n\n\tgeddev = devm_kzalloc(&pdev->dev, sizeof(*geddev), GFP_KERNEL);\n\tif (!geddev)\n\t\treturn -ENOMEM;\n\n\tgeddev->dev = &pdev->dev;\n\tINIT_LIST_HEAD(&geddev->event_list);\n\tacpi_ret = acpi_walk_resources(ACPI_HANDLE(&pdev->dev), \"_CRS\",\n\t\t\t\t       acpi_ged_request_interrupt, geddev);\n\tif (ACPI_FAILURE(acpi_ret)) {\n\t\tdev_err(&pdev->dev, \"unable to parse the _CRS record\\n\");\n\t\treturn -EINVAL;\n\t}\n\tplatform_set_drvdata(pdev, geddev);\n\n\treturn 0;\n}\n\nstatic void ged_shutdown(struct platform_device *pdev)\n{\n\tstruct acpi_ged_device *geddev = platform_get_drvdata(pdev);\n\tstruct acpi_ged_event *event, *next;\n\n\tlist_for_each_entry_safe(event, next, &geddev->event_list, node) {\n\t\tfree_irq(event->irq, event);\n\t\tlist_del(&event->node);\n\t\tdev_dbg(geddev->dev, \"GED releasing GSI %u @ IRQ %u\\n\",\n\t\t\t event->gsi, event->irq);\n\t}\n}\n\nstatic int ged_remove(struct platform_device *pdev)\n{\n\tged_shutdown(pdev);\n\treturn 0;\n}\n\nstatic const struct acpi_device_id ged_acpi_ids[] = {\n\t{\"ACPI0013\"},\n\t{},\n};\n\nstatic struct platform_driver ged_driver = {\n\t.probe = ged_probe,\n\t.remove = ged_remove,\n\t.shutdown = ged_shutdown,\n\t.driver = {\n\t\t.name = MODULE_NAME,\n\t\t.acpi_match_table = ACPI_PTR(ged_acpi_ids),\n\t},\n};\nbuiltin_platform_driver(ged_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}