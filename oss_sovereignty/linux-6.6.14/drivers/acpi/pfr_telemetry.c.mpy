{
  "module_name": "pfr_telemetry.c",
  "hash_id": "527768e594e34ab5002988181e99cfa60ea9a6178f46db0fed470c62200ab17d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pfr_telemetry.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/uuid.h>\n\n#include <uapi/linux/pfrut.h>\n\n#define PFRT_LOG_EXEC_IDX\t0\n#define PFRT_LOG_HISTORY_IDX\t1\n\n#define PFRT_LOG_ERR\t\t0\n#define PFRT_LOG_WARN\t1\n#define PFRT_LOG_INFO\t2\n#define PFRT_LOG_VERB\t4\n\n#define PFRT_FUNC_SET_LEV\t\t1\n#define PFRT_FUNC_GET_LEV\t\t2\n#define PFRT_FUNC_GET_DATA\t\t3\n\n#define PFRT_REVID_1\t\t1\n#define PFRT_REVID_2\t\t2\n#define PFRT_DEFAULT_REV_ID\tPFRT_REVID_1\n\nenum log_index {\n\tLOG_STATUS_IDX = 0,\n\tLOG_EXT_STATUS_IDX = 1,\n\tLOG_MAX_SZ_IDX = 2,\n\tLOG_CHUNK1_LO_IDX = 3,\n\tLOG_CHUNK1_HI_IDX = 4,\n\tLOG_CHUNK1_SZ_IDX = 5,\n\tLOG_CHUNK2_LO_IDX = 6,\n\tLOG_CHUNK2_HI_IDX = 7,\n\tLOG_CHUNK2_SZ_IDX = 8,\n\tLOG_ROLLOVER_CNT_IDX = 9,\n\tLOG_RESET_CNT_IDX = 10,\n\tLOG_NR_IDX\n};\n\nstruct pfrt_log_device {\n\tint index;\n\tstruct pfrt_log_info info;\n\tstruct device *parent_dev;\n\tstruct miscdevice miscdev;\n};\n\n \nstatic const guid_t pfrt_log_guid =\n\tGUID_INIT(0x75191659, 0x8178, 0x4D9D, 0xB8, 0x8F, 0xAC, 0x5E,\n\t\t  0x5E, 0x93, 0xE8, 0xBF);\n\nstatic DEFINE_IDA(pfrt_log_ida);\n\nstatic inline struct pfrt_log_device *to_pfrt_log_dev(struct file *file)\n{\n\treturn container_of(file->private_data, struct pfrt_log_device, miscdev);\n}\n\nstatic int get_pfrt_log_data_info(struct pfrt_log_data_info *data_info,\n\t\t\t\t  struct pfrt_log_device *pfrt_log_dev)\n{\n\tacpi_handle handle = ACPI_HANDLE(pfrt_log_dev->parent_dev);\n\tunion acpi_object *out_obj, in_obj, in_buf;\n\tint ret = -EBUSY;\n\n\tmemset(data_info, 0, sizeof(*data_info));\n\tmemset(&in_obj, 0, sizeof(in_obj));\n\tmemset(&in_buf, 0, sizeof(in_buf));\n\tin_obj.type = ACPI_TYPE_PACKAGE;\n\tin_obj.package.count = 1;\n\tin_obj.package.elements = &in_buf;\n\tin_buf.type = ACPI_TYPE_INTEGER;\n\tin_buf.integer.value = pfrt_log_dev->info.log_type;\n\n\tout_obj = acpi_evaluate_dsm_typed(handle, &pfrt_log_guid,\n\t\t\t\t\t  pfrt_log_dev->info.log_revid, PFRT_FUNC_GET_DATA,\n\t\t\t\t\t  &in_obj, ACPI_TYPE_PACKAGE);\n\tif (!out_obj)\n\t\treturn -EINVAL;\n\n\tif (out_obj->package.count < LOG_NR_IDX ||\n\t    out_obj->package.elements[LOG_STATUS_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_EXT_STATUS_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_MAX_SZ_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_CHUNK1_LO_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_CHUNK1_HI_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_CHUNK1_SZ_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_CHUNK2_LO_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_CHUNK2_HI_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_CHUNK2_SZ_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_ROLLOVER_CNT_IDX].type != ACPI_TYPE_INTEGER ||\n\t    out_obj->package.elements[LOG_RESET_CNT_IDX].type != ACPI_TYPE_INTEGER)\n\t\tgoto free_acpi_buffer;\n\n\tdata_info->status = out_obj->package.elements[LOG_STATUS_IDX].integer.value;\n\tdata_info->ext_status =\n\t\tout_obj->package.elements[LOG_EXT_STATUS_IDX].integer.value;\n\tif (data_info->status != DSM_SUCCEED) {\n\t\tdev_dbg(pfrt_log_dev->parent_dev, \"Error Status:%d\\n\", data_info->status);\n\t\tdev_dbg(pfrt_log_dev->parent_dev, \"Error Extend Status:%d\\n\",\n\t\t\tdata_info->ext_status);\n\t\tgoto free_acpi_buffer;\n\t}\n\n\tdata_info->max_data_size =\n\t\tout_obj->package.elements[LOG_MAX_SZ_IDX].integer.value;\n\tdata_info->chunk1_addr_lo =\n\t\tout_obj->package.elements[LOG_CHUNK1_LO_IDX].integer.value;\n\tdata_info->chunk1_addr_hi =\n\t\tout_obj->package.elements[LOG_CHUNK1_HI_IDX].integer.value;\n\tdata_info->chunk1_size =\n\t\tout_obj->package.elements[LOG_CHUNK1_SZ_IDX].integer.value;\n\tdata_info->chunk2_addr_lo =\n\t\tout_obj->package.elements[LOG_CHUNK2_LO_IDX].integer.value;\n\tdata_info->chunk2_addr_hi =\n\t\tout_obj->package.elements[LOG_CHUNK2_HI_IDX].integer.value;\n\tdata_info->chunk2_size =\n\t\tout_obj->package.elements[LOG_CHUNK2_SZ_IDX].integer.value;\n\tdata_info->rollover_cnt =\n\t\tout_obj->package.elements[LOG_ROLLOVER_CNT_IDX].integer.value;\n\tdata_info->reset_cnt =\n\t\tout_obj->package.elements[LOG_RESET_CNT_IDX].integer.value;\n\n\tret = 0;\n\nfree_acpi_buffer:\n\tACPI_FREE(out_obj);\n\n\treturn ret;\n}\n\nstatic int set_pfrt_log_level(int level, struct pfrt_log_device *pfrt_log_dev)\n{\n\tacpi_handle handle = ACPI_HANDLE(pfrt_log_dev->parent_dev);\n\tunion acpi_object *out_obj, *obj, in_obj, in_buf;\n\tenum pfru_dsm_status status, ext_status;\n\tint ret = 0;\n\n\tmemset(&in_obj, 0, sizeof(in_obj));\n\tmemset(&in_buf, 0, sizeof(in_buf));\n\tin_obj.type = ACPI_TYPE_PACKAGE;\n\tin_obj.package.count = 1;\n\tin_obj.package.elements = &in_buf;\n\tin_buf.type = ACPI_TYPE_INTEGER;\n\tin_buf.integer.value = level;\n\n\tout_obj = acpi_evaluate_dsm_typed(handle, &pfrt_log_guid,\n\t\t\t\t\t  pfrt_log_dev->info.log_revid, PFRT_FUNC_SET_LEV,\n\t\t\t\t\t  &in_obj, ACPI_TYPE_PACKAGE);\n\tif (!out_obj)\n\t\treturn -EINVAL;\n\n\tobj = &out_obj->package.elements[0];\n\tstatus = obj->integer.value;\n\tif (status != DSM_SUCCEED) {\n\t\tobj = &out_obj->package.elements[1];\n\t\text_status = obj->integer.value;\n\t\tdev_dbg(pfrt_log_dev->parent_dev, \"Error Status:%d\\n\", status);\n\t\tdev_dbg(pfrt_log_dev->parent_dev, \"Error Extend Status:%d\\n\", ext_status);\n\t\tret = -EBUSY;\n\t}\n\n\tACPI_FREE(out_obj);\n\n\treturn ret;\n}\n\nstatic int get_pfrt_log_level(struct pfrt_log_device *pfrt_log_dev)\n{\n\tacpi_handle handle = ACPI_HANDLE(pfrt_log_dev->parent_dev);\n\tunion acpi_object *out_obj, *obj;\n\tenum pfru_dsm_status status, ext_status;\n\tint ret = -EBUSY;\n\n\tout_obj = acpi_evaluate_dsm_typed(handle, &pfrt_log_guid,\n\t\t\t\t\t  pfrt_log_dev->info.log_revid, PFRT_FUNC_GET_LEV,\n\t\t\t\t\t  NULL, ACPI_TYPE_PACKAGE);\n\tif (!out_obj)\n\t\treturn -EINVAL;\n\n\tobj = &out_obj->package.elements[0];\n\tif (obj->type != ACPI_TYPE_INTEGER)\n\t\tgoto free_acpi_buffer;\n\n\tstatus = obj->integer.value;\n\tif (status != DSM_SUCCEED) {\n\t\tobj = &out_obj->package.elements[1];\n\t\text_status = obj->integer.value;\n\t\tdev_dbg(pfrt_log_dev->parent_dev, \"Error Status:%d\\n\", status);\n\t\tdev_dbg(pfrt_log_dev->parent_dev, \"Error Extend Status:%d\\n\", ext_status);\n\t\tgoto free_acpi_buffer;\n\t}\n\n\tobj = &out_obj->package.elements[2];\n\tif (obj->type != ACPI_TYPE_INTEGER)\n\t\tgoto free_acpi_buffer;\n\n\tret = obj->integer.value;\n\nfree_acpi_buffer:\n\tACPI_FREE(out_obj);\n\n\treturn ret;\n}\n\nstatic int valid_log_level(u32 level)\n{\n\treturn level == PFRT_LOG_ERR || level == PFRT_LOG_WARN ||\n\t       level == PFRT_LOG_INFO || level == PFRT_LOG_VERB;\n}\n\nstatic int valid_log_type(u32 type)\n{\n\treturn type == PFRT_LOG_EXEC_IDX || type == PFRT_LOG_HISTORY_IDX;\n}\n\nstatic inline int valid_log_revid(u32 id)\n{\n\treturn id == PFRT_REVID_1 || id == PFRT_REVID_2;\n}\n\nstatic long pfrt_log_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pfrt_log_device *pfrt_log_dev = to_pfrt_log_dev(file);\n\tstruct pfrt_log_data_info data_info;\n\tstruct pfrt_log_info info;\n\tvoid __user *p;\n\tint ret = 0;\n\n\tp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase PFRT_LOG_IOC_SET_INFO:\n\t\tif (copy_from_user(&info, p, sizeof(info)))\n\t\t\treturn -EFAULT;\n\n\t\tif (valid_log_revid(info.log_revid))\n\t\t\tpfrt_log_dev->info.log_revid = info.log_revid;\n\n\t\tif (valid_log_level(info.log_level)) {\n\t\t\tret = set_pfrt_log_level(info.log_level, pfrt_log_dev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tpfrt_log_dev->info.log_level = info.log_level;\n\t\t}\n\n\t\tif (valid_log_type(info.log_type))\n\t\t\tpfrt_log_dev->info.log_type = info.log_type;\n\n\t\treturn 0;\n\n\tcase PFRT_LOG_IOC_GET_INFO:\n\t\tinfo.log_level = get_pfrt_log_level(pfrt_log_dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tinfo.log_type = pfrt_log_dev->info.log_type;\n\t\tinfo.log_revid = pfrt_log_dev->info.log_revid;\n\t\tif (copy_to_user(p, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n\tcase PFRT_LOG_IOC_GET_DATA_INFO:\n\t\tret = get_pfrt_log_data_info(&data_info, pfrt_log_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user(p, &data_info, sizeof(struct pfrt_log_data_info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic int\npfrt_log_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct pfrt_log_device *pfrt_log_dev;\n\tstruct pfrt_log_data_info info;\n\tunsigned long psize, vsize;\n\tphys_addr_t base_addr;\n\tint ret;\n\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EROFS;\n\n\t \n\tvm_flags_clear(vma, VM_MAYWRITE);\n\n\tpfrt_log_dev = to_pfrt_log_dev(file);\n\n\tret = get_pfrt_log_data_info(&info, pfrt_log_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tbase_addr = (phys_addr_t)((info.chunk2_addr_hi << 32) | info.chunk2_addr_lo);\n\t \n\tif (!base_addr)\n\t\treturn -ENODEV;\n\n\tpsize = info.max_data_size;\n\t \n\tif (!PAGE_ALIGNED(base_addr) || !PAGE_ALIGNED(psize))\n\t\treturn -ENODEV;\n\n\tvsize = vma->vm_end - vma->vm_start;\n\tif (vsize > psize)\n\t\treturn -EINVAL;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tif (io_remap_pfn_range(vma, vma->vm_start, PFN_DOWN(base_addr),\n\t\t\t       vsize, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic const struct file_operations acpi_pfrt_log_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.mmap\t\t= pfrt_log_mmap,\n\t.unlocked_ioctl = pfrt_log_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int acpi_pfrt_log_remove(struct platform_device *pdev)\n{\n\tstruct pfrt_log_device *pfrt_log_dev = platform_get_drvdata(pdev);\n\n\tmisc_deregister(&pfrt_log_dev->miscdev);\n\n\treturn 0;\n}\n\nstatic void pfrt_log_put_idx(void *data)\n{\n\tstruct pfrt_log_device *pfrt_log_dev = data;\n\n\tida_free(&pfrt_log_ida, pfrt_log_dev->index);\n}\n\nstatic int acpi_pfrt_log_probe(struct platform_device *pdev)\n{\n\tacpi_handle handle = ACPI_HANDLE(&pdev->dev);\n\tstruct pfrt_log_device *pfrt_log_dev;\n\tint ret;\n\n\tif (!acpi_has_method(handle, \"_DSM\")) {\n\t\tdev_dbg(&pdev->dev, \"Missing _DSM\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpfrt_log_dev = devm_kzalloc(&pdev->dev, sizeof(*pfrt_log_dev), GFP_KERNEL);\n\tif (!pfrt_log_dev)\n\t\treturn -ENOMEM;\n\n\tret = ida_alloc(&pfrt_log_ida, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpfrt_log_dev->index = ret;\n\tret = devm_add_action_or_reset(&pdev->dev, pfrt_log_put_idx, pfrt_log_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpfrt_log_dev->info.log_revid = PFRT_DEFAULT_REV_ID;\n\tpfrt_log_dev->parent_dev = &pdev->dev;\n\n\tpfrt_log_dev->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tpfrt_log_dev->miscdev.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t    \"pfrt%d\",\n\t\t\t\t\t\t    pfrt_log_dev->index);\n\tif (!pfrt_log_dev->miscdev.name)\n\t\treturn -ENOMEM;\n\n\tpfrt_log_dev->miscdev.nodename = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t\t\"acpi_pfr_telemetry%d\",\n\t\t\t\t\t\t\tpfrt_log_dev->index);\n\tif (!pfrt_log_dev->miscdev.nodename)\n\t\treturn -ENOMEM;\n\n\tpfrt_log_dev->miscdev.fops = &acpi_pfrt_log_fops;\n\tpfrt_log_dev->miscdev.parent = &pdev->dev;\n\n\tret = misc_register(&pfrt_log_dev->miscdev);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, pfrt_log_dev);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id acpi_pfrt_log_ids[] = {\n\t{\"INTC1081\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, acpi_pfrt_log_ids);\n\nstatic struct platform_driver acpi_pfrt_log_driver = {\n\t.driver = {\n\t\t.name = \"pfr_telemetry\",\n\t\t.acpi_match_table = acpi_pfrt_log_ids,\n\t},\n\t.probe = acpi_pfrt_log_probe,\n\t.remove = acpi_pfrt_log_remove,\n};\nmodule_platform_driver(acpi_pfrt_log_driver);\n\nMODULE_DESCRIPTION(\"Platform Firmware Runtime Update Telemetry driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}