{
  "module_name": "srat.c",
  "hash_id": "bb731197dc847295002198cc21702a21631a31819e6590614e41465c02dd1051",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/numa/srat.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h>\n#include <linux/numa.h>\n#include <linux/nodemask.h>\n#include <linux/topology.h>\n\nstatic nodemask_t nodes_found_map = NODE_MASK_NONE;\n\n \nstatic int pxm_to_node_map[MAX_PXM_DOMAINS]\n\t\t\t= { [0 ... MAX_PXM_DOMAINS - 1] = NUMA_NO_NODE };\nstatic int node_to_pxm_map[MAX_NUMNODES]\n\t\t\t= { [0 ... MAX_NUMNODES - 1] = PXM_INVAL };\n\nunsigned char acpi_srat_revision __initdata;\nstatic int acpi_numa __initdata;\n\nvoid __init disable_srat(void)\n{\n\tacpi_numa = -1;\n}\n\nint pxm_to_node(int pxm)\n{\n\tif (pxm < 0 || pxm >= MAX_PXM_DOMAINS || numa_off)\n\t\treturn NUMA_NO_NODE;\n\treturn pxm_to_node_map[pxm];\n}\nEXPORT_SYMBOL(pxm_to_node);\n\nint node_to_pxm(int node)\n{\n\tif (node < 0)\n\t\treturn PXM_INVAL;\n\treturn node_to_pxm_map[node];\n}\n\nstatic void __acpi_map_pxm_to_node(int pxm, int node)\n{\n\tif (pxm_to_node_map[pxm] == NUMA_NO_NODE || node < pxm_to_node_map[pxm])\n\t\tpxm_to_node_map[pxm] = node;\n\tif (node_to_pxm_map[node] == PXM_INVAL || pxm < node_to_pxm_map[node])\n\t\tnode_to_pxm_map[node] = pxm;\n}\n\nint acpi_map_pxm_to_node(int pxm)\n{\n\tint node;\n\n\tif (pxm < 0 || pxm >= MAX_PXM_DOMAINS || numa_off)\n\t\treturn NUMA_NO_NODE;\n\n\tnode = pxm_to_node_map[pxm];\n\n\tif (node == NUMA_NO_NODE) {\n\t\tif (nodes_weight(nodes_found_map) >= MAX_NUMNODES)\n\t\t\treturn NUMA_NO_NODE;\n\t\tnode = first_unset_node(nodes_found_map);\n\t\t__acpi_map_pxm_to_node(pxm, node);\n\t\tnode_set(node, nodes_found_map);\n\t}\n\n\treturn node;\n}\nEXPORT_SYMBOL(acpi_map_pxm_to_node);\n\nstatic void __init\nacpi_table_print_srat_entry(struct acpi_subtable_header *header)\n{\n\tswitch (header->type) {\n\tcase ACPI_SRAT_TYPE_CPU_AFFINITY:\n\t\t{\n\t\t\tstruct acpi_srat_cpu_affinity *p =\n\t\t\t    (struct acpi_srat_cpu_affinity *)header;\n\t\t\tpr_debug(\"SRAT Processor (id[0x%02x] eid[0x%02x]) in proximity domain %d %s\\n\",\n\t\t\t\t p->apic_id, p->local_sapic_eid,\n\t\t\t\t p->proximity_domain_lo,\n\t\t\t\t (p->flags & ACPI_SRAT_CPU_ENABLED) ?\n\t\t\t\t \"enabled\" : \"disabled\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_SRAT_TYPE_MEMORY_AFFINITY:\n\t\t{\n\t\t\tstruct acpi_srat_mem_affinity *p =\n\t\t\t    (struct acpi_srat_mem_affinity *)header;\n\t\t\tpr_debug(\"SRAT Memory (0x%llx length 0x%llx) in proximity domain %d %s%s%s\\n\",\n\t\t\t\t (unsigned long long)p->base_address,\n\t\t\t\t (unsigned long long)p->length,\n\t\t\t\t p->proximity_domain,\n\t\t\t\t (p->flags & ACPI_SRAT_MEM_ENABLED) ?\n\t\t\t\t \"enabled\" : \"disabled\",\n\t\t\t\t (p->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) ?\n\t\t\t\t \" hot-pluggable\" : \"\",\n\t\t\t\t (p->flags & ACPI_SRAT_MEM_NON_VOLATILE) ?\n\t\t\t\t \" non-volatile\" : \"\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY:\n\t\t{\n\t\t\tstruct acpi_srat_x2apic_cpu_affinity *p =\n\t\t\t    (struct acpi_srat_x2apic_cpu_affinity *)header;\n\t\t\tpr_debug(\"SRAT Processor (x2apicid[0x%08x]) in proximity domain %d %s\\n\",\n\t\t\t\t p->apic_id,\n\t\t\t\t p->proximity_domain,\n\t\t\t\t (p->flags & ACPI_SRAT_CPU_ENABLED) ?\n\t\t\t\t \"enabled\" : \"disabled\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_SRAT_TYPE_GICC_AFFINITY:\n\t\t{\n\t\t\tstruct acpi_srat_gicc_affinity *p =\n\t\t\t    (struct acpi_srat_gicc_affinity *)header;\n\t\t\tpr_debug(\"SRAT Processor (acpi id[0x%04x]) in proximity domain %d %s\\n\",\n\t\t\t\t p->acpi_processor_uid,\n\t\t\t\t p->proximity_domain,\n\t\t\t\t (p->flags & ACPI_SRAT_GICC_ENABLED) ?\n\t\t\t\t \"enabled\" : \"disabled\");\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_SRAT_TYPE_GENERIC_AFFINITY:\n\t{\n\t\tstruct acpi_srat_generic_affinity *p =\n\t\t\t(struct acpi_srat_generic_affinity *)header;\n\n\t\tif (p->device_handle_type == 0) {\n\t\t\t \n\t\t\tpr_debug(\"SRAT Generic Initiator(Seg:%u BDF:%u) in proximity domain %d %s\\n\",\n\t\t\t\t *(u16 *)(&p->device_handle[0]),\n\t\t\t\t *(u16 *)(&p->device_handle[2]),\n\t\t\t\t p->proximity_domain,\n\t\t\t\t (p->flags & ACPI_SRAT_GENERIC_AFFINITY_ENABLED) ?\n\t\t\t\t\"enabled\" : \"disabled\");\n\t\t} else {\n\t\t\t \n\t\t\tpr_debug(\"SRAT Generic Initiator(HID=%.8s UID=%.4s) in proximity domain %d %s\\n\",\n\t\t\t\t(char *)(&p->device_handle[0]),\n\t\t\t\t(char *)(&p->device_handle[8]),\n\t\t\t\tp->proximity_domain,\n\t\t\t\t(p->flags & ACPI_SRAT_GENERIC_AFFINITY_ENABLED) ?\n\t\t\t\t\"enabled\" : \"disabled\");\n\t\t}\n\t}\n\tbreak;\n\tdefault:\n\t\tpr_warn(\"Found unsupported SRAT entry (type = 0x%x)\\n\",\n\t\t\theader->type);\n\t\tbreak;\n\t}\n}\n\n \nstatic int __init slit_valid(struct acpi_table_slit *slit)\n{\n\tint i, j;\n\tint d = slit->locality_count;\n\tfor (i = 0; i < d; i++) {\n\t\tfor (j = 0; j < d; j++)  {\n\t\t\tu8 val = slit->entry[d*i + j];\n\t\t\tif (i == j) {\n\t\t\t\tif (val != LOCAL_DISTANCE)\n\t\t\t\t\treturn 0;\n\t\t\t} else if (val <= LOCAL_DISTANCE)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid __init bad_srat(void)\n{\n\tpr_err(\"SRAT: SRAT not used.\\n\");\n\tdisable_srat();\n}\n\nint __init srat_disabled(void)\n{\n\treturn acpi_numa < 0;\n}\n\n#if defined(CONFIG_X86) || defined(CONFIG_ARM64) || defined(CONFIG_LOONGARCH)\n \nvoid __init acpi_numa_slit_init(struct acpi_table_slit *slit)\n{\n\tint i, j;\n\n\tfor (i = 0; i < slit->locality_count; i++) {\n\t\tconst int from_node = pxm_to_node(i);\n\n\t\tif (from_node == NUMA_NO_NODE)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < slit->locality_count; j++) {\n\t\t\tconst int to_node = pxm_to_node(j);\n\n\t\t\tif (to_node == NUMA_NO_NODE)\n\t\t\t\tcontinue;\n\n\t\t\tnuma_set_distance(from_node, to_node,\n\t\t\t\tslit->entry[slit->locality_count * i + j]);\n\t\t}\n\t}\n}\n\n \nint __init\nacpi_numa_memory_affinity_init(struct acpi_srat_mem_affinity *ma)\n{\n\tu64 start, end;\n\tu32 hotpluggable;\n\tint node, pxm;\n\n\tif (srat_disabled())\n\t\tgoto out_err;\n\tif (ma->header.length < sizeof(struct acpi_srat_mem_affinity)) {\n\t\tpr_err(\"SRAT: Unexpected header length: %d\\n\",\n\t\t       ma->header.length);\n\t\tgoto out_err_bad_srat;\n\t}\n\tif ((ma->flags & ACPI_SRAT_MEM_ENABLED) == 0)\n\t\tgoto out_err;\n\thotpluggable = IS_ENABLED(CONFIG_MEMORY_HOTPLUG) &&\n\t\t(ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE);\n\n\tstart = ma->base_address;\n\tend = start + ma->length;\n\tpxm = ma->proximity_domain;\n\tif (acpi_srat_revision <= 1)\n\t\tpxm &= 0xff;\n\n\tnode = acpi_map_pxm_to_node(pxm);\n\tif (node == NUMA_NO_NODE) {\n\t\tpr_err(\"SRAT: Too many proximity domains.\\n\");\n\t\tgoto out_err_bad_srat;\n\t}\n\n\tif (numa_add_memblk(node, start, end) < 0) {\n\t\tpr_err(\"SRAT: Failed to add memblk to node %u [mem %#010Lx-%#010Lx]\\n\",\n\t\t       node, (unsigned long long) start,\n\t\t       (unsigned long long) end - 1);\n\t\tgoto out_err_bad_srat;\n\t}\n\n\tnode_set(node, numa_nodes_parsed);\n\n\tpr_info(\"SRAT: Node %u PXM %u [mem %#010Lx-%#010Lx]%s%s\\n\",\n\t\tnode, pxm,\n\t\t(unsigned long long) start, (unsigned long long) end - 1,\n\t\thotpluggable ? \" hotplug\" : \"\",\n\t\tma->flags & ACPI_SRAT_MEM_NON_VOLATILE ? \" non-volatile\" : \"\");\n\n\t \n\tif (hotpluggable && memblock_mark_hotplug(start, ma->length))\n\t\tpr_warn(\"SRAT: Failed to mark hotplug range [mem %#010Lx-%#010Lx] in memblock\\n\",\n\t\t\t(unsigned long long)start, (unsigned long long)end - 1);\n\n\tmax_possible_pfn = max(max_possible_pfn, PFN_UP(end - 1));\n\n\treturn 0;\nout_err_bad_srat:\n\tbad_srat();\nout_err:\n\treturn -EINVAL;\n}\n\nstatic int __init acpi_parse_cfmws(union acpi_subtable_headers *header,\n\t\t\t\t   void *arg, const unsigned long table_end)\n{\n\tstruct acpi_cedt_cfmws *cfmws;\n\tint *fake_pxm = arg;\n\tu64 start, end;\n\tint node;\n\n\tcfmws = (struct acpi_cedt_cfmws *)header;\n\tstart = cfmws->base_hpa;\n\tend = cfmws->base_hpa + cfmws->window_size;\n\n\t \n\tif (!numa_fill_memblks(start, end))\n\t\treturn 0;\n\n\t \n\tnode = acpi_map_pxm_to_node(*fake_pxm);\n\n\tif (node == NUMA_NO_NODE) {\n\t\tpr_err(\"ACPI NUMA: Too many proximity domains while processing CFMWS.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (numa_add_memblk(node, start, end) < 0) {\n\t\t \n\t\tpr_warn(\"ACPI NUMA: Failed to add memblk for CFMWS node %d [mem %#llx-%#llx]\\n\",\n\t\t\tnode, start, end);\n\t}\n\tnode_set(node, numa_nodes_parsed);\n\n\t \n\t(*fake_pxm)++;\n\treturn 0;\n}\n#else\nstatic int __init acpi_parse_cfmws(union acpi_subtable_headers *header,\n\t\t\t\t   void *arg, const unsigned long table_end)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int __init acpi_parse_slit(struct acpi_table_header *table)\n{\n\tstruct acpi_table_slit *slit = (struct acpi_table_slit *)table;\n\n\tif (!slit_valid(slit)) {\n\t\tpr_info(\"SLIT table looks invalid. Not used.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tacpi_numa_slit_init(slit);\n\n\treturn 0;\n}\n\nvoid __init __weak\nacpi_numa_x2apic_affinity_init(struct acpi_srat_x2apic_cpu_affinity *pa)\n{\n\tpr_warn(\"Found unsupported x2apic [0x%08x] SRAT entry\\n\", pa->apic_id);\n}\n\nstatic int __init\nacpi_parse_x2apic_affinity(union acpi_subtable_headers *header,\n\t\t\t   const unsigned long end)\n{\n\tstruct acpi_srat_x2apic_cpu_affinity *processor_affinity;\n\n\tprocessor_affinity = (struct acpi_srat_x2apic_cpu_affinity *)header;\n\n\tacpi_table_print_srat_entry(&header->common);\n\n\t \n\tacpi_numa_x2apic_affinity_init(processor_affinity);\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_processor_affinity(union acpi_subtable_headers *header,\n\t\t\t      const unsigned long end)\n{\n\tstruct acpi_srat_cpu_affinity *processor_affinity;\n\n\tprocessor_affinity = (struct acpi_srat_cpu_affinity *)header;\n\n\tacpi_table_print_srat_entry(&header->common);\n\n\t \n\tacpi_numa_processor_affinity_init(processor_affinity);\n\n\treturn 0;\n}\n\nstatic int __init\nacpi_parse_gicc_affinity(union acpi_subtable_headers *header,\n\t\t\t const unsigned long end)\n{\n\tstruct acpi_srat_gicc_affinity *processor_affinity;\n\n\tprocessor_affinity = (struct acpi_srat_gicc_affinity *)header;\n\n\tacpi_table_print_srat_entry(&header->common);\n\n\t \n\tacpi_numa_gicc_affinity_init(processor_affinity);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_X86) || defined(CONFIG_ARM64)\nstatic int __init\nacpi_parse_gi_affinity(union acpi_subtable_headers *header,\n\t\t       const unsigned long end)\n{\n\tstruct acpi_srat_generic_affinity *gi_affinity;\n\tint node;\n\n\tgi_affinity = (struct acpi_srat_generic_affinity *)header;\n\tif (!gi_affinity)\n\t\treturn -EINVAL;\n\tacpi_table_print_srat_entry(&header->common);\n\n\tif (!(gi_affinity->flags & ACPI_SRAT_GENERIC_AFFINITY_ENABLED))\n\t\treturn -EINVAL;\n\n\tnode = acpi_map_pxm_to_node(gi_affinity->proximity_domain);\n\tif (node == NUMA_NO_NODE || node >= MAX_NUMNODES) {\n\t\tpr_err(\"SRAT: Too many proximity domains.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tnode_set(node, numa_nodes_parsed);\n\tnode_set_state(node, N_GENERIC_INITIATOR);\n\n\treturn 0;\n}\n#else\nstatic int __init\nacpi_parse_gi_affinity(union acpi_subtable_headers *header,\n\t\t       const unsigned long end)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int __initdata parsed_numa_memblks;\n\nstatic int __init\nacpi_parse_memory_affinity(union acpi_subtable_headers * header,\n\t\t\t   const unsigned long end)\n{\n\tstruct acpi_srat_mem_affinity *memory_affinity;\n\n\tmemory_affinity = (struct acpi_srat_mem_affinity *)header;\n\n\tacpi_table_print_srat_entry(&header->common);\n\n\t \n\tif (!acpi_numa_memory_affinity_init(memory_affinity))\n\t\tparsed_numa_memblks++;\n\treturn 0;\n}\n\nstatic int __init acpi_parse_srat(struct acpi_table_header *table)\n{\n\tstruct acpi_table_srat *srat = (struct acpi_table_srat *)table;\n\n\tacpi_srat_revision = srat->header.revision;\n\n\t \n\n\treturn 0;\n}\n\nstatic int __init\nacpi_table_parse_srat(enum acpi_srat_type id,\n\t\t      acpi_tbl_entry_handler handler, unsigned int max_entries)\n{\n\treturn acpi_table_parse_entries(ACPI_SIG_SRAT,\n\t\t\t\t\t    sizeof(struct acpi_table_srat), id,\n\t\t\t\t\t    handler, max_entries);\n}\n\nint __init acpi_numa_init(void)\n{\n\tint i, fake_pxm, cnt = 0;\n\n\tif (acpi_disabled)\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\tif (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {\n\t\tstruct acpi_subtable_proc srat_proc[4];\n\n\t\tmemset(srat_proc, 0, sizeof(srat_proc));\n\t\tsrat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;\n\t\tsrat_proc[0].handler = acpi_parse_processor_affinity;\n\t\tsrat_proc[1].id = ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY;\n\t\tsrat_proc[1].handler = acpi_parse_x2apic_affinity;\n\t\tsrat_proc[2].id = ACPI_SRAT_TYPE_GICC_AFFINITY;\n\t\tsrat_proc[2].handler = acpi_parse_gicc_affinity;\n\t\tsrat_proc[3].id = ACPI_SRAT_TYPE_GENERIC_AFFINITY;\n\t\tsrat_proc[3].handler = acpi_parse_gi_affinity;\n\n\t\tacpi_table_parse_entries_array(ACPI_SIG_SRAT,\n\t\t\t\t\tsizeof(struct acpi_table_srat),\n\t\t\t\t\tsrat_proc, ARRAY_SIZE(srat_proc), 0);\n\n\t\tcnt = acpi_table_parse_srat(ACPI_SRAT_TYPE_MEMORY_AFFINITY,\n\t\t\t\t\t    acpi_parse_memory_affinity, 0);\n\t}\n\n\t \n\tacpi_table_parse(ACPI_SIG_SLIT, acpi_parse_slit);\n\n\t \n\n\t \n\tfor (i = 0, fake_pxm = -1; i < MAX_NUMNODES - 1; i++) {\n\t\tif (node_to_pxm_map[i] > fake_pxm)\n\t\t\tfake_pxm = node_to_pxm_map[i];\n\t}\n\tfake_pxm++;\n\tacpi_table_parse_cedt(ACPI_CEDT_TYPE_CFMWS, acpi_parse_cfmws,\n\t\t\t      &fake_pxm);\n\n\tif (cnt < 0)\n\t\treturn cnt;\n\telse if (!parsed_numa_memblks)\n\t\treturn -ENOENT;\n\treturn 0;\n}\n\nstatic int acpi_get_pxm(acpi_handle h)\n{\n\tunsigned long long pxm;\n\tacpi_status status;\n\tacpi_handle handle;\n\tacpi_handle phandle = h;\n\n\tdo {\n\t\thandle = phandle;\n\t\tstatus = acpi_evaluate_integer(handle, \"_PXM\", NULL, &pxm);\n\t\tif (ACPI_SUCCESS(status))\n\t\t\treturn pxm;\n\t\tstatus = acpi_get_parent(handle, &phandle);\n\t} while (ACPI_SUCCESS(status));\n\treturn -1;\n}\n\nint acpi_get_node(acpi_handle handle)\n{\n\tint pxm;\n\n\tpxm = acpi_get_pxm(handle);\n\n\treturn pxm_to_node(pxm);\n}\nEXPORT_SYMBOL(acpi_get_node);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}