{
  "module_name": "sysfs.c",
  "hash_id": "3193666ce27bb4ea60297f96615a23a1f2ce7190d06ea01f722eaffbeed703b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/sysfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/moduleparam.h>\n\n#include \"internal.h\"\n\n#ifdef CONFIG_ACPI_DEBUG\n \n\nstruct acpi_dlayer {\n\tconst char *name;\n\tunsigned long value;\n};\nstruct acpi_dlevel {\n\tconst char *name;\n\tunsigned long value;\n};\n#define ACPI_DEBUG_INIT(v)\t{ .name = #v, .value = v }\n\nstatic const struct acpi_dlayer acpi_debug_layers[] = {\n\tACPI_DEBUG_INIT(ACPI_UTILITIES),\n\tACPI_DEBUG_INIT(ACPI_HARDWARE),\n\tACPI_DEBUG_INIT(ACPI_EVENTS),\n\tACPI_DEBUG_INIT(ACPI_TABLES),\n\tACPI_DEBUG_INIT(ACPI_NAMESPACE),\n\tACPI_DEBUG_INIT(ACPI_PARSER),\n\tACPI_DEBUG_INIT(ACPI_DISPATCHER),\n\tACPI_DEBUG_INIT(ACPI_EXECUTER),\n\tACPI_DEBUG_INIT(ACPI_RESOURCES),\n\tACPI_DEBUG_INIT(ACPI_CA_DEBUGGER),\n\tACPI_DEBUG_INIT(ACPI_OS_SERVICES),\n\tACPI_DEBUG_INIT(ACPI_CA_DISASSEMBLER),\n\tACPI_DEBUG_INIT(ACPI_COMPILER),\n\tACPI_DEBUG_INIT(ACPI_TOOLS),\n};\n\nstatic const struct acpi_dlevel acpi_debug_levels[] = {\n\tACPI_DEBUG_INIT(ACPI_LV_INIT),\n\tACPI_DEBUG_INIT(ACPI_LV_DEBUG_OBJECT),\n\tACPI_DEBUG_INIT(ACPI_LV_INFO),\n\tACPI_DEBUG_INIT(ACPI_LV_REPAIR),\n\tACPI_DEBUG_INIT(ACPI_LV_TRACE_POINT),\n\n\tACPI_DEBUG_INIT(ACPI_LV_INIT_NAMES),\n\tACPI_DEBUG_INIT(ACPI_LV_PARSE),\n\tACPI_DEBUG_INIT(ACPI_LV_LOAD),\n\tACPI_DEBUG_INIT(ACPI_LV_DISPATCH),\n\tACPI_DEBUG_INIT(ACPI_LV_EXEC),\n\tACPI_DEBUG_INIT(ACPI_LV_NAMES),\n\tACPI_DEBUG_INIT(ACPI_LV_OPREGION),\n\tACPI_DEBUG_INIT(ACPI_LV_BFIELD),\n\tACPI_DEBUG_INIT(ACPI_LV_TABLES),\n\tACPI_DEBUG_INIT(ACPI_LV_VALUES),\n\tACPI_DEBUG_INIT(ACPI_LV_OBJECTS),\n\tACPI_DEBUG_INIT(ACPI_LV_RESOURCES),\n\tACPI_DEBUG_INIT(ACPI_LV_USER_REQUESTS),\n\tACPI_DEBUG_INIT(ACPI_LV_PACKAGE),\n\n\tACPI_DEBUG_INIT(ACPI_LV_ALLOCATIONS),\n\tACPI_DEBUG_INIT(ACPI_LV_FUNCTIONS),\n\tACPI_DEBUG_INIT(ACPI_LV_OPTIMIZATIONS),\n\n\tACPI_DEBUG_INIT(ACPI_LV_MUTEX),\n\tACPI_DEBUG_INIT(ACPI_LV_THREADS),\n\tACPI_DEBUG_INIT(ACPI_LV_IO),\n\tACPI_DEBUG_INIT(ACPI_LV_INTERRUPTS),\n\n\tACPI_DEBUG_INIT(ACPI_LV_AML_DISASSEMBLE),\n\tACPI_DEBUG_INIT(ACPI_LV_VERBOSE_INFO),\n\tACPI_DEBUG_INIT(ACPI_LV_FULL_TABLES),\n\tACPI_DEBUG_INIT(ACPI_LV_EVENTS),\n};\n\nstatic int param_get_debug_layer(char *buffer, const struct kernel_param *kp)\n{\n\tint result = 0;\n\tint i;\n\n\tresult = sprintf(buffer, \"%-25s\\tHex        SET\\n\", \"Description\");\n\n\tfor (i = 0; i < ARRAY_SIZE(acpi_debug_layers); i++) {\n\t\tresult += sprintf(buffer + result, \"%-25s\\t0x%08lX [%c]\\n\",\n\t\t\t\t  acpi_debug_layers[i].name,\n\t\t\t\t  acpi_debug_layers[i].value,\n\t\t\t\t  (acpi_dbg_layer & acpi_debug_layers[i].value)\n\t\t\t\t  ? '*' : ' ');\n\t}\n\tresult +=\n\t    sprintf(buffer + result, \"%-25s\\t0x%08X [%c]\\n\", \"ACPI_ALL_DRIVERS\",\n\t\t    ACPI_ALL_DRIVERS,\n\t\t    (acpi_dbg_layer & ACPI_ALL_DRIVERS) ==\n\t\t    ACPI_ALL_DRIVERS ? '*' : (acpi_dbg_layer & ACPI_ALL_DRIVERS)\n\t\t    == 0 ? ' ' : '-');\n\tresult +=\n\t    sprintf(buffer + result,\n\t\t    \"--\\ndebug_layer = 0x%08X ( * = enabled)\\n\",\n\t\t    acpi_dbg_layer);\n\n\treturn result;\n}\n\nstatic int param_get_debug_level(char *buffer, const struct kernel_param *kp)\n{\n\tint result = 0;\n\tint i;\n\n\tresult = sprintf(buffer, \"%-25s\\tHex        SET\\n\", \"Description\");\n\n\tfor (i = 0; i < ARRAY_SIZE(acpi_debug_levels); i++) {\n\t\tresult += sprintf(buffer + result, \"%-25s\\t0x%08lX [%c]\\n\",\n\t\t\t\t  acpi_debug_levels[i].name,\n\t\t\t\t  acpi_debug_levels[i].value,\n\t\t\t\t  (acpi_dbg_level & acpi_debug_levels[i].value)\n\t\t\t\t  ? '*' : ' ');\n\t}\n\tresult +=\n\t    sprintf(buffer + result, \"--\\ndebug_level = 0x%08X (* = enabled)\\n\",\n\t\t    acpi_dbg_level);\n\n\treturn result;\n}\n\nstatic const struct kernel_param_ops param_ops_debug_layer = {\n\t.set = param_set_uint,\n\t.get = param_get_debug_layer,\n};\n\nstatic const struct kernel_param_ops param_ops_debug_level = {\n\t.set = param_set_uint,\n\t.get = param_get_debug_level,\n};\n\nmodule_param_cb(debug_layer, &param_ops_debug_layer, &acpi_dbg_layer, 0644);\nmodule_param_cb(debug_level, &param_ops_debug_level, &acpi_dbg_level, 0644);\n\nstatic char trace_method_name[1024];\n\nstatic int param_set_trace_method_name(const char *val,\n\t\t\t\t       const struct kernel_param *kp)\n{\n\tu32 saved_flags = 0;\n\tbool is_abs_path = true;\n\n\tif (*val != '\\\\')\n\t\tis_abs_path = false;\n\n\tif ((is_abs_path && strlen(val) > 1023) ||\n\t    (!is_abs_path && strlen(val) > 1022)) {\n\t\tpr_err(\"%s: string parameter too long\\n\", kp->name);\n\t\treturn -ENOSPC;\n\t}\n\n\t \n\tsaved_flags = acpi_gbl_trace_flags;\n\t(void)acpi_debug_trace(NULL,\n\t\t\t       acpi_gbl_trace_dbg_level,\n\t\t\t       acpi_gbl_trace_dbg_layer,\n\t\t\t       0);\n\n\t \n\tif (is_abs_path)\n\t\tstrcpy(trace_method_name, val);\n\telse {\n\t\ttrace_method_name[0] = '\\\\';\n\t\tstrcpy(trace_method_name+1, val);\n\t}\n\n\t \n\t(void)acpi_debug_trace(trace_method_name,\n\t\t\t       acpi_gbl_trace_dbg_level,\n\t\t\t       acpi_gbl_trace_dbg_layer,\n\t\t\t       saved_flags);\n\n\treturn 0;\n}\n\nstatic int param_get_trace_method_name(char *buffer, const struct kernel_param *kp)\n{\n\treturn sysfs_emit(buffer, \"%s\\n\", acpi_gbl_trace_method_name);\n}\n\nstatic const struct kernel_param_ops param_ops_trace_method = {\n\t.set = param_set_trace_method_name,\n\t.get = param_get_trace_method_name,\n};\n\nstatic const struct kernel_param_ops param_ops_trace_attrib = {\n\t.set = param_set_uint,\n\t.get = param_get_uint,\n};\n\nmodule_param_cb(trace_method_name, &param_ops_trace_method, &trace_method_name, 0644);\nmodule_param_cb(trace_debug_layer, &param_ops_trace_attrib, &acpi_gbl_trace_dbg_layer, 0644);\nmodule_param_cb(trace_debug_level, &param_ops_trace_attrib, &acpi_gbl_trace_dbg_level, 0644);\n\nstatic int param_set_trace_state(const char *val,\n\t\t\t\t const struct kernel_param *kp)\n{\n\tacpi_status status;\n\tconst char *method = trace_method_name;\n\tu32 flags = 0;\n\n \n#define acpi_compare_param(val, key)\t\\\n\tstrncmp((val), (key), sizeof(key) - 1)\n\n\tif (!acpi_compare_param(val, \"enable\")) {\n\t\tmethod = NULL;\n\t\tflags = ACPI_TRACE_ENABLED;\n\t} else if (!acpi_compare_param(val, \"disable\"))\n\t\tmethod = NULL;\n\telse if (!acpi_compare_param(val, \"method-once\"))\n\t\tflags = ACPI_TRACE_ENABLED | ACPI_TRACE_ONESHOT;\n\telse if (!acpi_compare_param(val, \"method\"))\n\t\tflags = ACPI_TRACE_ENABLED;\n\telse if (!acpi_compare_param(val, \"opcode-once\"))\n\t\tflags = ACPI_TRACE_ENABLED | ACPI_TRACE_ONESHOT | ACPI_TRACE_OPCODE;\n\telse if (!acpi_compare_param(val, \"opcode\"))\n\t\tflags = ACPI_TRACE_ENABLED | ACPI_TRACE_OPCODE;\n\telse\n\t\treturn -EINVAL;\n\n\tstatus = acpi_debug_trace(method,\n\t\t\t\t  acpi_gbl_trace_dbg_level,\n\t\t\t\t  acpi_gbl_trace_dbg_layer,\n\t\t\t\t  flags);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int param_get_trace_state(char *buffer, const struct kernel_param *kp)\n{\n\tif (!(acpi_gbl_trace_flags & ACPI_TRACE_ENABLED))\n\t\treturn sprintf(buffer, \"disable\\n\");\n\tif (!acpi_gbl_trace_method_name)\n\t\treturn sprintf(buffer, \"enable\\n\");\n\tif (acpi_gbl_trace_flags & ACPI_TRACE_ONESHOT)\n\t\treturn sprintf(buffer, \"method-once\\n\");\n\telse\n\t\treturn sprintf(buffer, \"method\\n\");\n}\n\nmodule_param_call(trace_state, param_set_trace_state, param_get_trace_state,\n\t\t  NULL, 0644);\n#endif  \n\n\n \n\nmodule_param_named(aml_debug_output, acpi_gbl_enable_aml_debug_object,\n\t\t   byte, 0644);\nMODULE_PARM_DESC(aml_debug_output,\n\t\t \"To enable/disable the ACPI Debug Object output.\");\n\n \nstatic int param_get_acpica_version(char *buffer,\n\t\t\t\t    const struct kernel_param *kp)\n{\n\tint result;\n\n\tresult = sprintf(buffer, \"%x\\n\", ACPI_CA_VERSION);\n\n\treturn result;\n}\n\nmodule_param_call(acpica_version, NULL, param_get_acpica_version, NULL, 0444);\n\n \n\nstatic LIST_HEAD(acpi_table_attr_list);\nstatic struct kobject *tables_kobj;\nstatic struct kobject *tables_data_kobj;\nstatic struct kobject *dynamic_tables_kobj;\nstatic struct kobject *hotplug_kobj;\n\n#define ACPI_MAX_TABLE_INSTANCES\t999\n#define ACPI_INST_SIZE\t\t\t4  \n\nstruct acpi_table_attr {\n\tstruct bin_attribute attr;\n\tchar name[ACPI_NAMESEG_SIZE];\n\tint instance;\n\tchar filename[ACPI_NAMESEG_SIZE+ACPI_INST_SIZE];\n\tstruct list_head node;\n};\n\nstruct acpi_data_attr {\n\tstruct bin_attribute attr;\n\tu64\taddr;\n};\n\nstatic ssize_t acpi_table_show(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr, char *buf,\n\t\t\t       loff_t offset, size_t count)\n{\n\tstruct acpi_table_attr *table_attr =\n\t    container_of(bin_attr, struct acpi_table_attr, attr);\n\tstruct acpi_table_header *table_header = NULL;\n\tacpi_status status;\n\tssize_t rc;\n\n\tstatus = acpi_get_table(table_attr->name, table_attr->instance,\n\t\t\t\t&table_header);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\trc = memory_read_from_buffer(buf, count, &offset, table_header,\n\t\t\ttable_header->length);\n\tacpi_put_table(table_header);\n\treturn rc;\n}\n\nstatic int acpi_table_attr_init(struct kobject *tables_obj,\n\t\t\t\tstruct acpi_table_attr *table_attr,\n\t\t\t\tstruct acpi_table_header *table_header)\n{\n\tstruct acpi_table_header *header = NULL;\n\tstruct acpi_table_attr *attr = NULL;\n\tchar instance_str[ACPI_INST_SIZE];\n\n\tsysfs_attr_init(&table_attr->attr.attr);\n\tACPI_COPY_NAMESEG(table_attr->name, table_header->signature);\n\n\tlist_for_each_entry(attr, &acpi_table_attr_list, node) {\n\t\tif (ACPI_COMPARE_NAMESEG(table_attr->name, attr->name))\n\t\t\tif (table_attr->instance < attr->instance)\n\t\t\t\ttable_attr->instance = attr->instance;\n\t}\n\ttable_attr->instance++;\n\tif (table_attr->instance > ACPI_MAX_TABLE_INSTANCES) {\n\t\tpr_warn(\"%4.4s: too many table instances\\n\", table_attr->name);\n\t\treturn -ERANGE;\n\t}\n\n\tACPI_COPY_NAMESEG(table_attr->filename, table_header->signature);\n\ttable_attr->filename[ACPI_NAMESEG_SIZE] = '\\0';\n\tif (table_attr->instance > 1 || (table_attr->instance == 1 &&\n\t\t\t\t\t !acpi_get_table\n\t\t\t\t\t (table_header->signature, 2, &header))) {\n\t\tsnprintf(instance_str, sizeof(instance_str), \"%u\",\n\t\t\t table_attr->instance);\n\t\tstrcat(table_attr->filename, instance_str);\n\t}\n\n\ttable_attr->attr.size = table_header->length;\n\ttable_attr->attr.read = acpi_table_show;\n\ttable_attr->attr.attr.name = table_attr->filename;\n\ttable_attr->attr.attr.mode = 0400;\n\n\treturn sysfs_create_bin_file(tables_obj, &table_attr->attr);\n}\n\nacpi_status acpi_sysfs_table_handler(u32 event, void *table, void *context)\n{\n\tstruct acpi_table_attr *table_attr;\n\n\tswitch (event) {\n\tcase ACPI_TABLE_EVENT_INSTALL:\n\t\ttable_attr = kzalloc(sizeof(*table_attr), GFP_KERNEL);\n\t\tif (!table_attr)\n\t\t\treturn AE_NO_MEMORY;\n\n\t\tif (acpi_table_attr_init(dynamic_tables_kobj,\n\t\t\t\t\t table_attr, table)) {\n\t\t\tkfree(table_attr);\n\t\t\treturn AE_ERROR;\n\t\t}\n\t\tlist_add_tail(&table_attr->node, &acpi_table_attr_list);\n\t\tbreak;\n\tcase ACPI_TABLE_EVENT_LOAD:\n\tcase ACPI_TABLE_EVENT_UNLOAD:\n\tcase ACPI_TABLE_EVENT_UNINSTALL:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\treturn AE_OK;\n}\n\nstatic ssize_t acpi_data_show(struct file *filp, struct kobject *kobj,\n\t\t\t      struct bin_attribute *bin_attr, char *buf,\n\t\t\t      loff_t offset, size_t count)\n{\n\tstruct acpi_data_attr *data_attr;\n\tvoid __iomem *base;\n\tssize_t size;\n\n\tdata_attr = container_of(bin_attr, struct acpi_data_attr, attr);\n\tsize = data_attr->attr.size;\n\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\n\tif (offset >= size)\n\t\treturn 0;\n\n\tif (count > size - offset)\n\t\tcount = size - offset;\n\n\tbase = acpi_os_map_iomem(data_attr->addr, size);\n\tif (!base)\n\t\treturn -ENOMEM;\n\n\tmemcpy_fromio(buf, base + offset, count);\n\n\tacpi_os_unmap_iomem(base, size);\n\n\treturn count;\n}\n\nstatic int acpi_bert_data_init(void *th, struct acpi_data_attr *data_attr)\n{\n\tstruct acpi_table_bert *bert = th;\n\n\tif (bert->header.length < sizeof(struct acpi_table_bert) ||\n\t    bert->region_length < sizeof(struct acpi_hest_generic_status)) {\n\t\tkfree(data_attr);\n\t\treturn -EINVAL;\n\t}\n\tdata_attr->addr = bert->address;\n\tdata_attr->attr.size = bert->region_length;\n\tdata_attr->attr.attr.name = \"BERT\";\n\n\treturn sysfs_create_bin_file(tables_data_kobj, &data_attr->attr);\n}\n\nstatic int acpi_ccel_data_init(void *th, struct acpi_data_attr *data_attr)\n{\n\tstruct acpi_table_ccel *ccel = th;\n\n\tif (ccel->header.length < sizeof(struct acpi_table_ccel) ||\n\t    !ccel->log_area_start_address || !ccel->log_area_minimum_length) {\n\t\tkfree(data_attr);\n\t\treturn -EINVAL;\n\t}\n\tdata_attr->addr = ccel->log_area_start_address;\n\tdata_attr->attr.size = ccel->log_area_minimum_length;\n\tdata_attr->attr.attr.name = \"CCEL\";\n\n\treturn sysfs_create_bin_file(tables_data_kobj, &data_attr->attr);\n}\n\nstatic struct acpi_data_obj {\n\tchar *name;\n\tint (*fn)(void *, struct acpi_data_attr *);\n} acpi_data_objs[] = {\n\t{ ACPI_SIG_BERT, acpi_bert_data_init },\n\t{ ACPI_SIG_CCEL, acpi_ccel_data_init },\n};\n\n#define NUM_ACPI_DATA_OBJS ARRAY_SIZE(acpi_data_objs)\n\nstatic int acpi_table_data_init(struct acpi_table_header *th)\n{\n\tstruct acpi_data_attr *data_attr;\n\tint i;\n\n\tfor (i = 0; i < NUM_ACPI_DATA_OBJS; i++) {\n\t\tif (ACPI_COMPARE_NAMESEG(th->signature, acpi_data_objs[i].name)) {\n\t\t\tdata_attr = kzalloc(sizeof(*data_attr), GFP_KERNEL);\n\t\t\tif (!data_attr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsysfs_attr_init(&data_attr->attr.attr);\n\t\t\tdata_attr->attr.read = acpi_data_show;\n\t\t\tdata_attr->attr.attr.mode = 0400;\n\t\t\treturn acpi_data_objs[i].fn(th, data_attr);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int acpi_tables_sysfs_init(void)\n{\n\tstruct acpi_table_attr *table_attr;\n\tstruct acpi_table_header *table_header = NULL;\n\tint table_index;\n\tacpi_status status;\n\tint ret;\n\n\ttables_kobj = kobject_create_and_add(\"tables\", acpi_kobj);\n\tif (!tables_kobj)\n\t\tgoto err;\n\n\ttables_data_kobj = kobject_create_and_add(\"data\", tables_kobj);\n\tif (!tables_data_kobj)\n\t\tgoto err_tables_data;\n\n\tdynamic_tables_kobj = kobject_create_and_add(\"dynamic\", tables_kobj);\n\tif (!dynamic_tables_kobj)\n\t\tgoto err_dynamic_tables;\n\n\tfor (table_index = 0;; table_index++) {\n\t\tstatus = acpi_get_table_by_index(table_index, &table_header);\n\n\t\tif (status == AE_BAD_PARAMETER)\n\t\t\tbreak;\n\n\t\tif (ACPI_FAILURE(status))\n\t\t\tcontinue;\n\n\t\ttable_attr = kzalloc(sizeof(*table_attr), GFP_KERNEL);\n\t\tif (!table_attr)\n\t\t\treturn -ENOMEM;\n\n\t\tret = acpi_table_attr_init(tables_kobj,\n\t\t\t\t\t   table_attr, table_header);\n\t\tif (ret) {\n\t\t\tkfree(table_attr);\n\t\t\treturn ret;\n\t\t}\n\t\tlist_add_tail(&table_attr->node, &acpi_table_attr_list);\n\t\tacpi_table_data_init(table_header);\n\t}\n\n\tkobject_uevent(tables_kobj, KOBJ_ADD);\n\tkobject_uevent(tables_data_kobj, KOBJ_ADD);\n\tkobject_uevent(dynamic_tables_kobj, KOBJ_ADD);\n\n\treturn 0;\nerr_dynamic_tables:\n\tkobject_put(tables_data_kobj);\nerr_tables_data:\n\tkobject_put(tables_kobj);\nerr:\n\treturn -ENOMEM;\n}\n\n \n\nu32 acpi_irq_handled;\nu32 acpi_irq_not_handled;\n\n#define COUNT_GPE 0\n#define COUNT_SCI 1\t\t \n#define COUNT_SCI_NOT 2\t\t \n#define COUNT_ERROR 3\t\t \n#define NUM_COUNTERS_EXTRA 4\n\nstruct event_counter {\n\tu32 count;\n\tu32 flags;\n};\n\nstatic struct event_counter *all_counters;\nstatic u32 num_gpes;\nstatic u32 num_counters;\nstatic struct attribute **all_attrs;\nstatic u32 acpi_gpe_count;\n\nstatic struct attribute_group interrupt_stats_attr_group = {\n\t.name = \"interrupts\",\n};\n\nstatic struct kobj_attribute *counter_attrs;\n\nstatic void delete_gpe_attr_array(void)\n{\n\tstruct event_counter *tmp = all_counters;\n\n\tall_counters = NULL;\n\tkfree(tmp);\n\n\tif (counter_attrs) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num_gpes; i++)\n\t\t\tkfree(counter_attrs[i].attr.name);\n\n\t\tkfree(counter_attrs);\n\t}\n\tkfree(all_attrs);\n}\n\nstatic void gpe_count(u32 gpe_number)\n{\n\tacpi_gpe_count++;\n\n\tif (!all_counters)\n\t\treturn;\n\n\tif (gpe_number < num_gpes)\n\t\tall_counters[gpe_number].count++;\n\telse\n\t\tall_counters[num_gpes + ACPI_NUM_FIXED_EVENTS +\n\t\t\t     COUNT_ERROR].count++;\n}\n\nstatic void fixed_event_count(u32 event_number)\n{\n\tif (!all_counters)\n\t\treturn;\n\n\tif (event_number < ACPI_NUM_FIXED_EVENTS)\n\t\tall_counters[num_gpes + event_number].count++;\n\telse\n\t\tall_counters[num_gpes + ACPI_NUM_FIXED_EVENTS +\n\t\t\t     COUNT_ERROR].count++;\n}\n\nstatic void acpi_global_event_handler(u32 event_type, acpi_handle device,\n\tu32 event_number, void *context)\n{\n\tif (event_type == ACPI_EVENT_TYPE_GPE) {\n\t\tgpe_count(event_number);\n\t\tpr_debug(\"GPE event 0x%02x\\n\", event_number);\n\t} else if (event_type == ACPI_EVENT_TYPE_FIXED) {\n\t\tfixed_event_count(event_number);\n\t\tpr_debug(\"Fixed event 0x%02x\\n\", event_number);\n\t} else {\n\t\tpr_debug(\"Other event 0x%02x\\n\", event_number);\n\t}\n}\n\nstatic int get_status(u32 index, acpi_event_status *ret,\n\t\t      acpi_handle *handle)\n{\n\tacpi_status status;\n\n\tif (index >= num_gpes + ACPI_NUM_FIXED_EVENTS)\n\t\treturn -EINVAL;\n\n\tif (index < num_gpes) {\n\t\tstatus = acpi_get_gpe_device(index, handle);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_warn(\"Invalid GPE 0x%x\", index);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tstatus = acpi_get_gpe_status(*handle, index, ret);\n\t} else {\n\t\tstatus = acpi_get_event_status(index - num_gpes, ret);\n\t}\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic ssize_t counter_show(struct kobject *kobj,\n\t\t\t    struct kobj_attribute *attr, char *buf)\n{\n\tint index = attr - counter_attrs;\n\tint size;\n\tacpi_handle handle;\n\tacpi_event_status status;\n\tint result = 0;\n\n\tall_counters[num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI].count =\n\t    acpi_irq_handled;\n\tall_counters[num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI_NOT].count =\n\t    acpi_irq_not_handled;\n\tall_counters[num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_GPE].count =\n\t    acpi_gpe_count;\n\tsize = sprintf(buf, \"%8u\", all_counters[index].count);\n\n\t \n\tif (index >= num_gpes + ACPI_NUM_FIXED_EVENTS)\n\t\tgoto end;\n\n\tresult = get_status(index, &status, &handle);\n\tif (result)\n\t\tgoto end;\n\n\tif (status & ACPI_EVENT_FLAG_ENABLE_SET)\n\t\tsize += sprintf(buf + size, \"  EN\");\n\telse\n\t\tsize += sprintf(buf + size, \"    \");\n\tif (status & ACPI_EVENT_FLAG_STATUS_SET)\n\t\tsize += sprintf(buf + size, \" STS\");\n\telse\n\t\tsize += sprintf(buf + size, \"    \");\n\n\tif (!(status & ACPI_EVENT_FLAG_HAS_HANDLER))\n\t\tsize += sprintf(buf + size, \" invalid     \");\n\telse if (status & ACPI_EVENT_FLAG_ENABLED)\n\t\tsize += sprintf(buf + size, \" enabled     \");\n\telse if (status & ACPI_EVENT_FLAG_WAKE_ENABLED)\n\t\tsize += sprintf(buf + size, \" wake_enabled\");\n\telse\n\t\tsize += sprintf(buf + size, \" disabled    \");\n\tif (status & ACPI_EVENT_FLAG_MASKED)\n\t\tsize += sprintf(buf + size, \" masked  \");\n\telse\n\t\tsize += sprintf(buf + size, \" unmasked\");\n\nend:\n\tsize += sprintf(buf + size, \"\\n\");\n\treturn result ? result : size;\n}\n\n \nstatic ssize_t counter_set(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr, const char *buf,\n\t\t\t   size_t size)\n{\n\tint index = attr - counter_attrs;\n\tacpi_event_status status;\n\tacpi_handle handle;\n\tint result = 0;\n\tunsigned long tmp;\n\n\tif (index == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI) {\n\t\tint i;\n\t\tfor (i = 0; i < num_counters; ++i)\n\t\t\tall_counters[i].count = 0;\n\t\tacpi_gpe_count = 0;\n\t\tacpi_irq_handled = 0;\n\t\tacpi_irq_not_handled = 0;\n\t\tgoto end;\n\t}\n\n\t \n\tresult = get_status(index, &status, &handle);\n\tif (result)\n\t\tgoto end;\n\n\tif (!(status & ACPI_EVENT_FLAG_HAS_HANDLER)) {\n\t\tpr_warn(\"Can not change Invalid GPE/Fixed Event status\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (index < num_gpes) {\n\t\tif (!strcmp(buf, \"disable\\n\") &&\n\t\t    (status & ACPI_EVENT_FLAG_ENABLED))\n\t\t\tresult = acpi_disable_gpe(handle, index);\n\t\telse if (!strcmp(buf, \"enable\\n\") &&\n\t\t\t !(status & ACPI_EVENT_FLAG_ENABLED))\n\t\t\tresult = acpi_enable_gpe(handle, index);\n\t\telse if (!strcmp(buf, \"clear\\n\") &&\n\t\t\t (status & ACPI_EVENT_FLAG_STATUS_SET))\n\t\t\tresult = acpi_clear_gpe(handle, index);\n\t\telse if (!strcmp(buf, \"mask\\n\"))\n\t\t\tresult = acpi_mask_gpe(handle, index, TRUE);\n\t\telse if (!strcmp(buf, \"unmask\\n\"))\n\t\t\tresult = acpi_mask_gpe(handle, index, FALSE);\n\t\telse if (!kstrtoul(buf, 0, &tmp))\n\t\t\tall_counters[index].count = tmp;\n\t\telse\n\t\t\tresult = -EINVAL;\n\t} else if (index < num_gpes + ACPI_NUM_FIXED_EVENTS) {\n\t\tint event = index - num_gpes;\n\t\tif (!strcmp(buf, \"disable\\n\") &&\n\t\t    (status & ACPI_EVENT_FLAG_ENABLE_SET))\n\t\t\tresult = acpi_disable_event(event, ACPI_NOT_ISR);\n\t\telse if (!strcmp(buf, \"enable\\n\") &&\n\t\t\t !(status & ACPI_EVENT_FLAG_ENABLE_SET))\n\t\t\tresult = acpi_enable_event(event, ACPI_NOT_ISR);\n\t\telse if (!strcmp(buf, \"clear\\n\") &&\n\t\t\t (status & ACPI_EVENT_FLAG_STATUS_SET))\n\t\t\tresult = acpi_clear_event(event);\n\t\telse if (!kstrtoul(buf, 0, &tmp))\n\t\t\tall_counters[index].count = tmp;\n\t\telse\n\t\t\tresult = -EINVAL;\n\t} else\n\t\tall_counters[index].count = strtoul(buf, NULL, 0);\n\n\tif (ACPI_FAILURE(result))\n\t\tresult = -EINVAL;\nend:\n\treturn result ? result : size;\n}\n\n \n#define ACPI_MASKABLE_GPE_MAX\t0x100\nstatic DECLARE_BITMAP(acpi_masked_gpes_map, ACPI_MASKABLE_GPE_MAX) __initdata;\n\nstatic int __init acpi_gpe_set_masked_gpes(char *val)\n{\n\tint ret;\n\tu8 gpe;\n\n\tret = kstrtou8(val, 0, &gpe);\n\tif (ret) {\n\t\tret = bitmap_parselist(val, acpi_masked_gpes_map, ACPI_MASKABLE_GPE_MAX);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\tset_bit(gpe, acpi_masked_gpes_map);\n\n\treturn 1;\n}\n__setup(\"acpi_mask_gpe=\", acpi_gpe_set_masked_gpes);\n\nvoid __init acpi_gpe_apply_masked_gpes(void)\n{\n\tacpi_handle handle;\n\tacpi_status status;\n\tu16 gpe;\n\n\tfor_each_set_bit(gpe, acpi_masked_gpes_map, ACPI_MASKABLE_GPE_MAX) {\n\t\tstatus = acpi_get_gpe_device(gpe, &handle);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tpr_info(\"Masking GPE 0x%x.\\n\", gpe);\n\t\t\t(void)acpi_mask_gpe(handle, gpe, TRUE);\n\t\t}\n\t}\n}\n\nvoid acpi_irq_stats_init(void)\n{\n\tacpi_status status;\n\tint i;\n\n\tif (all_counters)\n\t\treturn;\n\n\tnum_gpes = acpi_current_gpe_count;\n\tnum_counters = num_gpes + ACPI_NUM_FIXED_EVENTS + NUM_COUNTERS_EXTRA;\n\n\tall_attrs = kcalloc(num_counters + 1, sizeof(*all_attrs), GFP_KERNEL);\n\tif (all_attrs == NULL)\n\t\treturn;\n\n\tall_counters = kcalloc(num_counters, sizeof(*all_counters), GFP_KERNEL);\n\tif (all_counters == NULL)\n\t\tgoto fail;\n\n\tstatus = acpi_install_global_event_handler(acpi_global_event_handler, NULL);\n\tif (ACPI_FAILURE(status))\n\t\tgoto fail;\n\n\tcounter_attrs = kcalloc(num_counters, sizeof(*counter_attrs), GFP_KERNEL);\n\tif (counter_attrs == NULL)\n\t\tgoto fail;\n\n\tfor (i = 0; i < num_counters; ++i) {\n\t\tchar buffer[12];\n\t\tchar *name;\n\n\t\tif (i < num_gpes)\n\t\t\tsprintf(buffer, \"gpe%02X\", i);\n\t\telse if (i == num_gpes + ACPI_EVENT_PMTIMER)\n\t\t\tsprintf(buffer, \"ff_pmtimer\");\n\t\telse if (i == num_gpes + ACPI_EVENT_GLOBAL)\n\t\t\tsprintf(buffer, \"ff_gbl_lock\");\n\t\telse if (i == num_gpes + ACPI_EVENT_POWER_BUTTON)\n\t\t\tsprintf(buffer, \"ff_pwr_btn\");\n\t\telse if (i == num_gpes + ACPI_EVENT_SLEEP_BUTTON)\n\t\t\tsprintf(buffer, \"ff_slp_btn\");\n\t\telse if (i == num_gpes + ACPI_EVENT_RTC)\n\t\t\tsprintf(buffer, \"ff_rt_clk\");\n\t\telse if (i == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_GPE)\n\t\t\tsprintf(buffer, \"gpe_all\");\n\t\telse if (i == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI)\n\t\t\tsprintf(buffer, \"sci\");\n\t\telse if (i == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_SCI_NOT)\n\t\t\tsprintf(buffer, \"sci_not\");\n\t\telse if (i == num_gpes + ACPI_NUM_FIXED_EVENTS + COUNT_ERROR)\n\t\t\tsprintf(buffer, \"error\");\n\t\telse\n\t\t\tsprintf(buffer, \"bug%02X\", i);\n\n\t\tname = kstrdup(buffer, GFP_KERNEL);\n\t\tif (name == NULL)\n\t\t\tgoto fail;\n\n\t\tsysfs_attr_init(&counter_attrs[i].attr);\n\t\tcounter_attrs[i].attr.name = name;\n\t\tcounter_attrs[i].attr.mode = 0644;\n\t\tcounter_attrs[i].show = counter_show;\n\t\tcounter_attrs[i].store = counter_set;\n\n\t\tall_attrs[i] = &counter_attrs[i].attr;\n\t}\n\n\tinterrupt_stats_attr_group.attrs = all_attrs;\n\tif (!sysfs_create_group(acpi_kobj, &interrupt_stats_attr_group))\n\t\treturn;\n\nfail:\n\tdelete_gpe_attr_array();\n}\n\nstatic void __exit interrupt_stats_exit(void)\n{\n\tsysfs_remove_group(acpi_kobj, &interrupt_stats_attr_group);\n\n\tdelete_gpe_attr_array();\n}\n\nstatic ssize_t pm_profile_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", acpi_gbl_FADT.preferred_profile);\n}\n\nstatic const struct kobj_attribute pm_profile_attr = __ATTR_RO(pm_profile);\n\nstatic ssize_t enabled_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\n{\n\tstruct acpi_hotplug_profile *hotplug = to_acpi_hotplug_profile(kobj);\n\n\treturn sprintf(buf, \"%d\\n\", hotplug->enabled);\n}\n\nstatic ssize_t enabled_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tstruct acpi_hotplug_profile *hotplug = to_acpi_hotplug_profile(kobj);\n\tunsigned int val;\n\n\tif (kstrtouint(buf, 10, &val) || val > 1)\n\t\treturn -EINVAL;\n\n\tacpi_scan_hotplug_enabled(hotplug, val);\n\treturn size;\n}\n\nstatic struct kobj_attribute hotplug_enabled_attr = __ATTR_RW(enabled);\n\nstatic struct attribute *hotplug_profile_attrs[] = {\n\t&hotplug_enabled_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(hotplug_profile);\n\nstatic const struct kobj_type acpi_hotplug_profile_ktype = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.default_groups = hotplug_profile_groups,\n};\n\nvoid acpi_sysfs_add_hotplug_profile(struct acpi_hotplug_profile *hotplug,\n\t\t\t\t    const char *name)\n{\n\tint error;\n\n\tif (!hotplug_kobj)\n\t\tgoto err_out;\n\n\terror = kobject_init_and_add(&hotplug->kobj,\n\t\t&acpi_hotplug_profile_ktype, hotplug_kobj, \"%s\", name);\n\tif (error) {\n\t\tkobject_put(&hotplug->kobj);\n\t\tgoto err_out;\n\t}\n\n\tkobject_uevent(&hotplug->kobj, KOBJ_ADD);\n\treturn;\n\n err_out:\n\tpr_err(\"Unable to add hotplug profile '%s'\\n\", name);\n}\n\nstatic ssize_t force_remove_show(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", 0);\n}\n\nstatic ssize_t force_remove_store(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tbool val;\n\tint ret;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val) {\n\t\tpr_err(\"Enabling force_remove is not supported anymore. Please report to linux-acpi@vger.kernel.org if you depend on this functionality\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn size;\n}\n\nstatic const struct kobj_attribute force_remove_attr = __ATTR_RW(force_remove);\n\nint __init acpi_sysfs_init(void)\n{\n\tint result;\n\n\tresult = acpi_tables_sysfs_init();\n\tif (result)\n\t\treturn result;\n\n\thotplug_kobj = kobject_create_and_add(\"hotplug\", acpi_kobj);\n\tif (!hotplug_kobj)\n\t\treturn -ENOMEM;\n\n\tresult = sysfs_create_file(hotplug_kobj, &force_remove_attr.attr);\n\tif (result)\n\t\treturn result;\n\n\tresult = sysfs_create_file(acpi_kobj, &pm_profile_attr.attr);\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}