{
  "module_name": "property.c",
  "hash_id": "b51a1b5370ec3393073e1fa141bcce5e1b446772050863bf3dd37a204a19ff46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/property.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/export.h>\n\n#include \"internal.h\"\n\nstatic int acpi_data_get_property_array(const struct acpi_device_data *data,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tacpi_object_type type,\n\t\t\t\t\tconst union acpi_object **obj);\n\n \nstatic const guid_t prp_guids[] = {\n\t \n\tGUID_INIT(0xdaffd814, 0x6eba, 0x4d8c,\n\t\t  0x8a, 0x91, 0xbc, 0x9b, 0xbf, 0x4a, 0xa3, 0x01),\n\t \n\tGUID_INIT(0x6211e2c0, 0x58a3, 0x4af3,\n\t\t  0x90, 0xe1, 0x92, 0x7a, 0x4e, 0x0c, 0x55, 0xa4),\n\t \n\tGUID_INIT(0xefcc06cc, 0x73ac, 0x4bc3,\n\t\t  0xbf, 0xf0, 0x76, 0x14, 0x38, 0x07, 0xc3, 0x89),\n\t \n\tGUID_INIT(0xc44d002f, 0x69f9, 0x4e7d,\n\t\t  0xa9, 0x04, 0xa7, 0xba, 0xab, 0xdf, 0x43, 0xf7),\n\t \n\tGUID_INIT(0x6c501103, 0xc189, 0x4296,\n\t\t  0xba, 0x72, 0x9b, 0xf5, 0xa2, 0x6e, 0xbe, 0x5d),\n\t \n\tGUID_INIT(0x5025030f, 0x842f, 0x4ab4,\n\t\t  0xa5, 0x61, 0x99, 0xa5, 0x18, 0x97, 0x62, 0xd0),\n};\n\n \nstatic const guid_t ads_guid =\n\tGUID_INIT(0xdbb8e3e6, 0x5886, 0x4ba6,\n\t\t  0x87, 0x95, 0x13, 0x19, 0xf5, 0x2a, 0x96, 0x6b);\n\nstatic const guid_t buffer_prop_guid =\n\tGUID_INIT(0xedb12dd0, 0x363d, 0x4085,\n\t\t  0xa3, 0xd2, 0x49, 0x52, 0x2c, 0xa1, 0x60, 0xc4);\n\nstatic bool acpi_enumerate_nondev_subnodes(acpi_handle scope,\n\t\t\t\t\t   union acpi_object *desc,\n\t\t\t\t\t   struct acpi_device_data *data,\n\t\t\t\t\t   struct fwnode_handle *parent);\nstatic bool acpi_extract_properties(acpi_handle handle,\n\t\t\t\t    union acpi_object *desc,\n\t\t\t\t    struct acpi_device_data *data);\n\nstatic bool acpi_nondev_subnode_extract(union acpi_object *desc,\n\t\t\t\t\tacpi_handle handle,\n\t\t\t\t\tconst union acpi_object *link,\n\t\t\t\t\tstruct list_head *list,\n\t\t\t\t\tstruct fwnode_handle *parent)\n{\n\tstruct acpi_data_node *dn;\n\tbool result;\n\n\tdn = kzalloc(sizeof(*dn), GFP_KERNEL);\n\tif (!dn)\n\t\treturn false;\n\n\tdn->name = link->package.elements[0].string.pointer;\n\tfwnode_init(&dn->fwnode, &acpi_data_fwnode_ops);\n\tdn->parent = parent;\n\tINIT_LIST_HEAD(&dn->data.properties);\n\tINIT_LIST_HEAD(&dn->data.subnodes);\n\n\tresult = acpi_extract_properties(handle, desc, &dn->data);\n\n\tif (handle) {\n\t\tacpi_handle scope;\n\t\tacpi_status status;\n\n\t\t \n\t\tstatus = acpi_get_parent(handle, &scope);\n\t\tif (ACPI_SUCCESS(status)\n\t\t    && acpi_enumerate_nondev_subnodes(scope, desc, &dn->data,\n\t\t\t\t\t\t      &dn->fwnode))\n\t\t\tresult = true;\n\t} else if (acpi_enumerate_nondev_subnodes(NULL, desc, &dn->data,\n\t\t\t\t\t\t  &dn->fwnode)) {\n\t\tresult = true;\n\t}\n\n\tif (result) {\n\t\tdn->handle = handle;\n\t\tdn->data.pointer = desc;\n\t\tlist_add_tail(&dn->sibling, list);\n\t\treturn true;\n\t}\n\n\tkfree(dn);\n\tacpi_handle_debug(handle, \"Invalid properties/subnodes data, skipping\\n\");\n\treturn false;\n}\n\nstatic bool acpi_nondev_subnode_data_ok(acpi_handle handle,\n\t\t\t\t\tconst union acpi_object *link,\n\t\t\t\t\tstruct list_head *list,\n\t\t\t\t\tstruct fwnode_handle *parent)\n{\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object_typed(handle, NULL, NULL, &buf,\n\t\t\t\t\t    ACPI_TYPE_PACKAGE);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tif (acpi_nondev_subnode_extract(buf.pointer, handle, link, list,\n\t\t\t\t\tparent))\n\t\treturn true;\n\n\tACPI_FREE(buf.pointer);\n\treturn false;\n}\n\nstatic bool acpi_nondev_subnode_ok(acpi_handle scope,\n\t\t\t\t   const union acpi_object *link,\n\t\t\t\t   struct list_head *list,\n\t\t\t\t   struct fwnode_handle *parent)\n{\n\tacpi_handle handle;\n\tacpi_status status;\n\n\tif (!scope)\n\t\treturn false;\n\n\tstatus = acpi_get_handle(scope, link->package.elements[1].string.pointer,\n\t\t\t\t &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\treturn acpi_nondev_subnode_data_ok(handle, link, list, parent);\n}\n\nstatic bool acpi_add_nondev_subnodes(acpi_handle scope,\n\t\t\t\t     union acpi_object *links,\n\t\t\t\t     struct list_head *list,\n\t\t\t\t     struct fwnode_handle *parent)\n{\n\tbool ret = false;\n\tint i;\n\n\tfor (i = 0; i < links->package.count; i++) {\n\t\tunion acpi_object *link, *desc;\n\t\tacpi_handle handle;\n\t\tbool result;\n\n\t\tlink = &links->package.elements[i];\n\t\t \n\t\tif (link->package.count != 2)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (link->package.elements[0].type != ACPI_TYPE_STRING)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (link->package.elements[1].type) {\n\t\tcase ACPI_TYPE_STRING:\n\t\t\tresult = acpi_nondev_subnode_ok(scope, link, list,\n\t\t\t\t\t\t\t parent);\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t\thandle = link->package.elements[1].reference.handle;\n\t\t\tresult = acpi_nondev_subnode_data_ok(handle, link, list,\n\t\t\t\t\t\t\t     parent);\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_PACKAGE:\n\t\t\tdesc = &link->package.elements[1];\n\t\t\tresult = acpi_nondev_subnode_extract(desc, NULL, link,\n\t\t\t\t\t\t\t     list, parent);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = false;\n\t\t\tbreak;\n\t\t}\n\t\tret = ret || result;\n\t}\n\n\treturn ret;\n}\n\nstatic bool acpi_enumerate_nondev_subnodes(acpi_handle scope,\n\t\t\t\t\t   union acpi_object *desc,\n\t\t\t\t\t   struct acpi_device_data *data,\n\t\t\t\t\t   struct fwnode_handle *parent)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < desc->package.count; i += 2) {\n\t\tconst union acpi_object *guid;\n\t\tunion acpi_object *links;\n\n\t\tguid = &desc->package.elements[i];\n\t\tlinks = &desc->package.elements[i + 1];\n\n\t\t \n\t\tif (guid->type != ACPI_TYPE_BUFFER ||\n\t\t    guid->buffer.length != 16 ||\n\t\t    links->type != ACPI_TYPE_PACKAGE)\n\t\t\tbreak;\n\n\t\tif (!guid_equal((guid_t *)guid->buffer.pointer, &ads_guid))\n\t\t\tcontinue;\n\n\t\treturn acpi_add_nondev_subnodes(scope, links, &data->subnodes,\n\t\t\t\t\t\tparent);\n\t}\n\n\treturn false;\n}\n\nstatic bool acpi_property_value_ok(const union acpi_object *value)\n{\n\tint j;\n\n\t \n\tswitch (value->type) {\n\tcase ACPI_TYPE_INTEGER:\n\tcase ACPI_TYPE_STRING:\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\treturn true;\n\n\tcase ACPI_TYPE_PACKAGE:\n\t\tfor (j = 0; j < value->package.count; j++)\n\t\t\tswitch (value->package.elements[j].type) {\n\t\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tcase ACPI_TYPE_STRING:\n\t\t\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool acpi_properties_format_valid(const union acpi_object *properties)\n{\n\tint i;\n\n\tfor (i = 0; i < properties->package.count; i++) {\n\t\tconst union acpi_object *property;\n\n\t\tproperty = &properties->package.elements[i];\n\t\t \n\t\tif (property->package.count != 2\n\t\t    || property->package.elements[0].type != ACPI_TYPE_STRING\n\t\t    || !acpi_property_value_ok(&property->package.elements[1]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void acpi_init_of_compatible(struct acpi_device *adev)\n{\n\tconst union acpi_object *of_compatible;\n\tint ret;\n\n\tret = acpi_data_get_property_array(&adev->data, \"compatible\",\n\t\t\t\t\t   ACPI_TYPE_STRING, &of_compatible);\n\tif (ret) {\n\t\tret = acpi_dev_get_property(adev, \"compatible\",\n\t\t\t\t\t    ACPI_TYPE_STRING, &of_compatible);\n\t\tif (ret) {\n\t\t\tstruct acpi_device *parent;\n\n\t\t\tparent = acpi_dev_parent(adev);\n\t\t\tif (parent && parent->flags.of_compatible_ok)\n\t\t\t\tgoto out;\n\n\t\t\treturn;\n\t\t}\n\t}\n\tadev->data.of_compatible = of_compatible;\n\n out:\n\tadev->flags.of_compatible_ok = 1;\n}\n\nstatic bool acpi_is_property_guid(const guid_t *guid)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(prp_guids); i++) {\n\t\tif (guid_equal(guid, &prp_guids[i]))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstruct acpi_device_properties *\nacpi_data_add_props(struct acpi_device_data *data, const guid_t *guid,\n\t\t    union acpi_object *properties)\n{\n\tstruct acpi_device_properties *props;\n\n\tprops = kzalloc(sizeof(*props), GFP_KERNEL);\n\tif (props) {\n\t\tINIT_LIST_HEAD(&props->list);\n\t\tprops->guid = guid;\n\t\tprops->properties = properties;\n\t\tlist_add_tail(&props->list, &data->properties);\n\t}\n\n\treturn props;\n}\n\nstatic void acpi_nondev_subnode_tag(acpi_handle handle, void *context)\n{\n}\n\nstatic void acpi_untie_nondev_subnodes(struct acpi_device_data *data)\n{\n\tstruct acpi_data_node *dn;\n\n\tlist_for_each_entry(dn, &data->subnodes, sibling) {\n\t\tacpi_detach_data(dn->handle, acpi_nondev_subnode_tag);\n\n\t\tacpi_untie_nondev_subnodes(&dn->data);\n\t}\n}\n\nstatic bool acpi_tie_nondev_subnodes(struct acpi_device_data *data)\n{\n\tstruct acpi_data_node *dn;\n\n\tlist_for_each_entry(dn, &data->subnodes, sibling) {\n\t\tacpi_status status;\n\t\tbool ret;\n\n\t\tstatus = acpi_attach_data(dn->handle, acpi_nondev_subnode_tag, dn);\n\t\tif (ACPI_FAILURE(status) && status != AE_ALREADY_EXISTS) {\n\t\t\tacpi_handle_err(dn->handle, \"Can't tag data node\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tret = acpi_tie_nondev_subnodes(&dn->data);\n\t\tif (!ret)\n\t\t\treturn ret;\n\t}\n\n\treturn true;\n}\n\nstatic void acpi_data_add_buffer_props(acpi_handle handle,\n\t\t\t\t       struct acpi_device_data *data,\n\t\t\t\t       union acpi_object *properties)\n{\n\tstruct acpi_device_properties *props;\n\tunion acpi_object *package;\n\tsize_t alloc_size;\n\tunsigned int i;\n\tu32 *count;\n\n\tif (check_mul_overflow((size_t)properties->package.count,\n\t\t\t       sizeof(*package) + sizeof(void *),\n\t\t\t       &alloc_size) ||\n\t    check_add_overflow(sizeof(*props) + sizeof(*package), alloc_size,\n\t\t\t       &alloc_size)) {\n\t\tacpi_handle_warn(handle,\n\t\t\t\t \"can't allocate memory for %u buffer props\",\n\t\t\t\t properties->package.count);\n\t\treturn;\n\t}\n\n\tprops = kvzalloc(alloc_size, GFP_KERNEL);\n\tif (!props)\n\t\treturn;\n\n\tprops->guid = &buffer_prop_guid;\n\tprops->bufs = (void *)(props + 1);\n\tprops->properties = (void *)(props->bufs + properties->package.count);\n\n\t \n\tpackage = props->properties;\n\tpackage->type = ACPI_TYPE_PACKAGE;\n\tpackage->package.elements = package + 1;\n\tcount = &package->package.count;\n\t*count = 0;\n\n\t \n\tpackage++;\n\n\tfor (i = 0; i < properties->package.count; i++) {\n\t\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\n\t\tunion acpi_object *property = &properties->package.elements[i];\n\t\tunion acpi_object *prop, *obj, *buf_obj;\n\t\tacpi_status status;\n\n\t\tif (property->type != ACPI_TYPE_PACKAGE ||\n\t\t    property->package.count != 2) {\n\t\t\tacpi_handle_warn(handle,\n\t\t\t\t\t \"buffer property %u has %u entries\\n\",\n\t\t\t\t\t i, property->package.count);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprop = &property->package.elements[0];\n\t\tobj = &property->package.elements[1];\n\n\t\tif (prop->type != ACPI_TYPE_STRING ||\n\t\t    obj->type != ACPI_TYPE_STRING) {\n\t\t\tacpi_handle_warn(handle,\n\t\t\t\t\t \"wrong object types %u and %u\\n\",\n\t\t\t\t\t prop->type, obj->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = acpi_evaluate_object_typed(handle, obj->string.pointer,\n\t\t\t\t\t\t    NULL, &buf,\n\t\t\t\t\t\t    ACPI_TYPE_BUFFER);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tacpi_handle_warn(handle,\n\t\t\t\t\t \"can't evaluate \\\"%*pE\\\" as buffer\\n\",\n\t\t\t\t\t obj->string.length,\n\t\t\t\t\t obj->string.pointer);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpackage->type = ACPI_TYPE_PACKAGE;\n\t\tpackage->package.elements = prop;\n\t\tpackage->package.count = 2;\n\n\t\tbuf_obj = buf.pointer;\n\n\t\t \n\t\tobj->type = ACPI_TYPE_BUFFER;\n\t\tobj->buffer.length = buf_obj->buffer.length;\n\t\tobj->buffer.pointer = buf_obj->buffer.pointer;\n\n\t\tprops->bufs[i] = buf.pointer;\n\t\tpackage++;\n\t\t(*count)++;\n\t}\n\n\tif (*count)\n\t\tlist_add(&props->list, &data->properties);\n\telse\n\t\tkvfree(props);\n}\n\nstatic bool acpi_extract_properties(acpi_handle scope, union acpi_object *desc,\n\t\t\t\t    struct acpi_device_data *data)\n{\n\tint i;\n\n\tif (desc->package.count % 2)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < desc->package.count; i += 2) {\n\t\tconst union acpi_object *guid;\n\t\tunion acpi_object *properties;\n\n\t\tguid = &desc->package.elements[i];\n\t\tproperties = &desc->package.elements[i + 1];\n\n\t\t \n\t\tif (guid->type != ACPI_TYPE_BUFFER ||\n\t\t    guid->buffer.length != 16 ||\n\t\t    properties->type != ACPI_TYPE_PACKAGE)\n\t\t\tbreak;\n\n\t\tif (guid_equal((guid_t *)guid->buffer.pointer,\n\t\t\t       &buffer_prop_guid)) {\n\t\t\tacpi_data_add_buffer_props(scope, data, properties);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!acpi_is_property_guid((guid_t *)guid->buffer.pointer))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!acpi_properties_format_valid(properties))\n\t\t\tcontinue;\n\n\t\tacpi_data_add_props(data, (const guid_t *)guid->buffer.pointer,\n\t\t\t\t    properties);\n\t}\n\n\treturn !list_empty(&data->properties);\n}\n\nvoid acpi_init_properties(struct acpi_device *adev)\n{\n\tstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\n\tstruct acpi_hardware_id *hwid;\n\tacpi_status status;\n\tbool acpi_of = false;\n\n\tINIT_LIST_HEAD(&adev->data.properties);\n\tINIT_LIST_HEAD(&adev->data.subnodes);\n\n\tif (!adev->handle)\n\t\treturn;\n\n\t \n\tlist_for_each_entry(hwid, &adev->pnp.ids, list) {\n\t\tif (!strcmp(hwid->id, ACPI_DT_NAMESPACE_HID)) {\n\t\t\tacpi_of = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstatus = acpi_evaluate_object_typed(adev->handle, \"_DSD\", NULL, &buf,\n\t\t\t\t\t    ACPI_TYPE_PACKAGE);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out;\n\n\tif (acpi_extract_properties(adev->handle, buf.pointer, &adev->data)) {\n\t\tadev->data.pointer = buf.pointer;\n\t\tif (acpi_of)\n\t\t\tacpi_init_of_compatible(adev);\n\t}\n\tif (acpi_enumerate_nondev_subnodes(adev->handle, buf.pointer,\n\t\t\t\t\t&adev->data, acpi_fwnode_handle(adev)))\n\t\tadev->data.pointer = buf.pointer;\n\n\tif (!adev->data.pointer) {\n\t\tacpi_handle_debug(adev->handle, \"Invalid _DSD data, skipping\\n\");\n\t\tACPI_FREE(buf.pointer);\n\t} else {\n\t\tif (!acpi_tie_nondev_subnodes(&adev->data))\n\t\t\tacpi_untie_nondev_subnodes(&adev->data);\n\t}\n\n out:\n\tif (acpi_of && !adev->flags.of_compatible_ok)\n\t\tacpi_handle_info(adev->handle,\n\t\t\t ACPI_DT_NAMESPACE_HID \" requires 'compatible' property\\n\");\n\n\tif (!adev->data.pointer)\n\t\tacpi_extract_apple_properties(adev);\n}\n\nstatic void acpi_free_device_properties(struct list_head *list)\n{\n\tstruct acpi_device_properties *props, *tmp;\n\n\tlist_for_each_entry_safe(props, tmp, list, list) {\n\t\tu32 i;\n\n\t\tlist_del(&props->list);\n\t\t \n\t\tif (props->bufs)\n\t\t\tfor (i = 0; i < props->properties->package.count; i++)\n\t\t\t\tACPI_FREE(props->bufs[i]);\n\t\tkvfree(props);\n\t}\n}\n\nstatic void acpi_destroy_nondev_subnodes(struct list_head *list)\n{\n\tstruct acpi_data_node *dn, *next;\n\n\tif (list_empty(list))\n\t\treturn;\n\n\tlist_for_each_entry_safe_reverse(dn, next, list, sibling) {\n\t\tacpi_destroy_nondev_subnodes(&dn->data.subnodes);\n\t\twait_for_completion(&dn->kobj_done);\n\t\tlist_del(&dn->sibling);\n\t\tACPI_FREE((void *)dn->data.pointer);\n\t\tacpi_free_device_properties(&dn->data.properties);\n\t\tkfree(dn);\n\t}\n}\n\nvoid acpi_free_properties(struct acpi_device *adev)\n{\n\tacpi_untie_nondev_subnodes(&adev->data);\n\tacpi_destroy_nondev_subnodes(&adev->data.subnodes);\n\tACPI_FREE((void *)adev->data.pointer);\n\tadev->data.of_compatible = NULL;\n\tadev->data.pointer = NULL;\n\tacpi_free_device_properties(&adev->data.properties);\n}\n\n \nstatic int acpi_data_get_property(const struct acpi_device_data *data,\n\t\t\t\t  const char *name, acpi_object_type type,\n\t\t\t\t  const union acpi_object **obj)\n{\n\tconst struct acpi_device_properties *props;\n\n\tif (!data || !name)\n\t\treturn -EINVAL;\n\n\tif (!data->pointer || list_empty(&data->properties))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(props, &data->properties, list) {\n\t\tconst union acpi_object *properties;\n\t\tunsigned int i;\n\n\t\tproperties = props->properties;\n\t\tfor (i = 0; i < properties->package.count; i++) {\n\t\t\tconst union acpi_object *propname, *propvalue;\n\t\t\tconst union acpi_object *property;\n\n\t\t\tproperty = &properties->package.elements[i];\n\n\t\t\tpropname = &property->package.elements[0];\n\t\t\tpropvalue = &property->package.elements[1];\n\n\t\t\tif (!strcmp(name, propname->string.pointer)) {\n\t\t\t\tif (type != ACPI_TYPE_ANY &&\n\t\t\t\t    propvalue->type != type)\n\t\t\t\t\treturn -EPROTO;\n\t\t\t\tif (obj)\n\t\t\t\t\t*obj = propvalue;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \nint acpi_dev_get_property(const struct acpi_device *adev, const char *name,\n\t\t\t  acpi_object_type type, const union acpi_object **obj)\n{\n\treturn adev ? acpi_data_get_property(&adev->data, name, type, obj) : -EINVAL;\n}\nEXPORT_SYMBOL_GPL(acpi_dev_get_property);\n\nstatic const struct acpi_device_data *\nacpi_device_data_of_node(const struct fwnode_handle *fwnode)\n{\n\tif (is_acpi_device_node(fwnode)) {\n\t\tconst struct acpi_device *adev = to_acpi_device_node(fwnode);\n\t\treturn &adev->data;\n\t}\n\tif (is_acpi_data_node(fwnode)) {\n\t\tconst struct acpi_data_node *dn = to_acpi_data_node(fwnode);\n\t\treturn &dn->data;\n\t}\n\treturn NULL;\n}\n\n \nint acpi_node_prop_get(const struct fwnode_handle *fwnode,\n\t\t       const char *propname, void **valptr)\n{\n\treturn acpi_data_get_property(acpi_device_data_of_node(fwnode),\n\t\t\t\t      propname, ACPI_TYPE_ANY,\n\t\t\t\t      (const union acpi_object **)valptr);\n}\n\n \nstatic int acpi_data_get_property_array(const struct acpi_device_data *data,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tacpi_object_type type,\n\t\t\t\t\tconst union acpi_object **obj)\n{\n\tconst union acpi_object *prop;\n\tint ret, i;\n\n\tret = acpi_data_get_property(data, name, ACPI_TYPE_PACKAGE, &prop);\n\tif (ret)\n\t\treturn ret;\n\n\tif (type != ACPI_TYPE_ANY) {\n\t\t \n\t\tfor (i = 0; i < prop->package.count; i++)\n\t\t\tif (prop->package.elements[i].type != type)\n\t\t\t\treturn -EPROTO;\n\t}\n\tif (obj)\n\t\t*obj = prop;\n\n\treturn 0;\n}\n\nstatic struct fwnode_handle *\nacpi_fwnode_get_named_child_node(const struct fwnode_handle *fwnode,\n\t\t\t\t const char *childname)\n{\n\tstruct fwnode_handle *child;\n\n\tfwnode_for_each_child_node(fwnode, child) {\n\t\tif (is_acpi_data_node(child)) {\n\t\t\tif (acpi_data_node_match(child, childname))\n\t\t\t\treturn child;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncmp(acpi_device_bid(to_acpi_device_node(child)),\n\t\t\t     childname, ACPI_NAMESEG_SIZE))\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}\n\nstatic int acpi_get_ref_args(struct fwnode_reference_args *args,\n\t\t\t     struct fwnode_handle *ref_fwnode,\n\t\t\t     const union acpi_object **element,\n\t\t\t     const union acpi_object *end, size_t num_args)\n{\n\tu32 nargs = 0, i;\n\n\t \n\tfor (; *element < end && (*element)->type == ACPI_TYPE_STRING;\n\t     (*element)++) {\n\t\tconst char *child_name = (*element)->string.pointer;\n\n\t\tref_fwnode = acpi_fwnode_get_named_child_node(ref_fwnode, child_name);\n\t\tif (!ref_fwnode)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; (*element) + i < end && i < num_args; i++) {\n\t\tacpi_object_type type = (*element)[i].type;\n\n\t\tif (type == ACPI_TYPE_LOCAL_REFERENCE)\n\t\t\tbreak;\n\n\t\tif (type == ACPI_TYPE_INTEGER)\n\t\t\tnargs++;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (nargs > NR_FWNODE_REFERENCE_ARGS)\n\t\treturn -EINVAL;\n\n\tif (args) {\n\t\targs->fwnode = ref_fwnode;\n\t\targs->nargs = nargs;\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\targs->args[i] = (*element)[i].integer.value;\n\t}\n\n\t(*element) += nargs;\n\n\treturn 0;\n}\n\n \nint __acpi_node_get_property_reference(const struct fwnode_handle *fwnode,\n\tconst char *propname, size_t index, size_t num_args,\n\tstruct fwnode_reference_args *args)\n{\n\tconst union acpi_object *element, *end;\n\tconst union acpi_object *obj;\n\tconst struct acpi_device_data *data;\n\tstruct acpi_device *device;\n\tint ret, idx = 0;\n\n\tdata = acpi_device_data_of_node(fwnode);\n\tif (!data)\n\t\treturn -ENOENT;\n\n\tret = acpi_data_get_property(data, propname, ACPI_TYPE_ANY, &obj);\n\tif (ret)\n\t\treturn ret == -EINVAL ? -ENOENT : -EINVAL;\n\n\tswitch (obj->type) {\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t \n\t\tif (index)\n\t\t\treturn -ENOENT;\n\n\t\tdevice = acpi_fetch_acpi_dev(obj->reference.handle);\n\t\tif (!device)\n\t\t\treturn -EINVAL;\n\n\t\tif (!args)\n\t\t\treturn 0;\n\n\t\targs->fwnode = acpi_fwnode_handle(device);\n\t\targs->nargs = 0;\n\t\treturn 0;\n\tcase ACPI_TYPE_PACKAGE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (index >= obj->package.count)\n\t\treturn -ENOENT;\n\n\telement = obj->package.elements;\n\tend = element + obj->package.count;\n\n\twhile (element < end) {\n\t\tswitch (element->type) {\n\t\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\t\t\tdevice = acpi_fetch_acpi_dev(element->reference.handle);\n\t\t\tif (!device)\n\t\t\t\treturn -EINVAL;\n\n\t\t\telement++;\n\n\t\t\tret = acpi_get_ref_args(idx == index ? args : NULL,\n\t\t\t\t\t\tacpi_fwnode_handle(device),\n\t\t\t\t\t\t&element, end, num_args);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (idx == index)\n\t\t\t\treturn 0;\n\n\t\t\tbreak;\n\t\tcase ACPI_TYPE_INTEGER:\n\t\t\tif (idx == index)\n\t\t\t\treturn -ENOENT;\n\t\t\telement++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(__acpi_node_get_property_reference);\n\nstatic int acpi_data_prop_read_single(const struct acpi_device_data *data,\n\t\t\t\t      const char *propname,\n\t\t\t\t      enum dev_prop_type proptype, void *val)\n{\n\tconst union acpi_object *obj;\n\tint ret = 0;\n\n\tif (proptype >= DEV_PROP_U8 && proptype <= DEV_PROP_U64)\n\t\tret = acpi_data_get_property(data, propname, ACPI_TYPE_INTEGER, &obj);\n\telse if (proptype == DEV_PROP_STRING)\n\t\tret = acpi_data_get_property(data, propname, ACPI_TYPE_STRING, &obj);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (proptype) {\n\tcase DEV_PROP_U8:\n\t\tif (obj->integer.value > U8_MAX)\n\t\t\treturn -EOVERFLOW;\n\t\tif (val)\n\t\t\t*(u8 *)val = obj->integer.value;\n\t\tbreak;\n\tcase DEV_PROP_U16:\n\t\tif (obj->integer.value > U16_MAX)\n\t\t\treturn -EOVERFLOW;\n\t\tif (val)\n\t\t\t*(u16 *)val = obj->integer.value;\n\t\tbreak;\n\tcase DEV_PROP_U32:\n\t\tif (obj->integer.value > U32_MAX)\n\t\t\treturn -EOVERFLOW;\n\t\tif (val)\n\t\t\t*(u32 *)val = obj->integer.value;\n\t\tbreak;\n\tcase DEV_PROP_U64:\n\t\tif (val)\n\t\t\t*(u64 *)val = obj->integer.value;\n\t\tbreak;\n\tcase DEV_PROP_STRING:\n\t\tif (val)\n\t\t\t*(char **)val = obj->string.pointer;\n\t\treturn 1;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn val ? 0 : 1;\n}\n\n#define acpi_copy_property_array_uint(items, val, nval)\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\ttypeof(items) __items = items;\t\t\t\t\\\n\t\ttypeof(val) __val = val;\t\t\t\t\\\n\t\ttypeof(nval) __nval = nval;\t\t\t\t\\\n\t\tsize_t i;\t\t\t\t\t\t\\\n\t\tint ret = 0;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < __nval; i++) {\t\t\t\t\\\n\t\t\tif (__items->type == ACPI_TYPE_BUFFER) {\t\\\n\t\t\t\t__val[i] = __items->buffer.pointer[i];\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tif (__items[i].type != ACPI_TYPE_INTEGER) {\t\\\n\t\t\t\tret = -EPROTO;\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\tif (__items[i].integer.value > _Generic(__val,\t\\\n\t\t\t\t\t\t\t\tu8 *: U8_MAX, \\\n\t\t\t\t\t\t\t\tu16 *: U16_MAX, \\\n\t\t\t\t\t\t\t\tu32 *: U32_MAX, \\\n\t\t\t\t\t\t\t\tu64 *: U64_MAX)) { \\\n\t\t\t\tret = -EOVERFLOW;\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t\t__val[i] = __items[i].integer.value;\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tret;\t\t\t\t\t\t\t\\\n\t})\n\nstatic int acpi_copy_property_array_string(const union acpi_object *items,\n\t\t\t\t\t   char **val, size_t nval)\n{\n\tint i;\n\n\tfor (i = 0; i < nval; i++) {\n\t\tif (items[i].type != ACPI_TYPE_STRING)\n\t\t\treturn -EPROTO;\n\n\t\tval[i] = items[i].string.pointer;\n\t}\n\treturn nval;\n}\n\nstatic int acpi_data_prop_read(const struct acpi_device_data *data,\n\t\t\t       const char *propname,\n\t\t\t       enum dev_prop_type proptype,\n\t\t\t       void *val, size_t nval)\n{\n\tconst union acpi_object *obj;\n\tconst union acpi_object *items;\n\tint ret;\n\n\tif (nval == 1 || !val) {\n\t\tret = acpi_data_prop_read_single(data, propname, proptype, val);\n\t\t \n\t\tif (ret >= 0 || ret == -EOVERFLOW)\n\t\t\treturn ret;\n\n\t\t \n\t}\n\n\tret = acpi_data_get_property_array(data, propname, ACPI_TYPE_ANY, &obj);\n\tif (ret && proptype >= DEV_PROP_U8 && proptype <= DEV_PROP_U64)\n\t\tret = acpi_data_get_property(data, propname, ACPI_TYPE_BUFFER,\n\t\t\t\t\t     &obj);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!val) {\n\t\tif (obj->type == ACPI_TYPE_BUFFER)\n\t\t\treturn obj->buffer.length;\n\n\t\treturn obj->package.count;\n\t}\n\n\tswitch (proptype) {\n\tcase DEV_PROP_STRING:\n\t\tbreak;\n\tdefault:\n\t\tif (obj->type == ACPI_TYPE_BUFFER) {\n\t\t\tif (nval > obj->buffer.length)\n\t\t\t\treturn -EOVERFLOW;\n\t\t} else {\n\t\t\tif (nval > obj->package.count)\n\t\t\t\treturn -EOVERFLOW;\n\t\t}\n\t\tbreak;\n\t}\n\tif (nval == 0)\n\t\treturn -EINVAL;\n\n\tif (obj->type == ACPI_TYPE_BUFFER) {\n\t\tif (proptype != DEV_PROP_U8)\n\t\t\treturn -EPROTO;\n\t\titems = obj;\n\t} else {\n\t\titems = obj->package.elements;\n\t}\n\n\tswitch (proptype) {\n\tcase DEV_PROP_U8:\n\t\tret = acpi_copy_property_array_uint(items, (u8 *)val, nval);\n\t\tbreak;\n\tcase DEV_PROP_U16:\n\t\tret = acpi_copy_property_array_uint(items, (u16 *)val, nval);\n\t\tbreak;\n\tcase DEV_PROP_U32:\n\t\tret = acpi_copy_property_array_uint(items, (u32 *)val, nval);\n\t\tbreak;\n\tcase DEV_PROP_U64:\n\t\tret = acpi_copy_property_array_uint(items, (u64 *)val, nval);\n\t\tbreak;\n\tcase DEV_PROP_STRING:\n\t\tret = acpi_copy_property_array_string(\n\t\t\titems, (char **)val,\n\t\t\tmin_t(u32, nval, obj->package.count));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int acpi_node_prop_read(const struct fwnode_handle *fwnode,\n\t\t\t       const char *propname, enum dev_prop_type proptype,\n\t\t\t       void *val, size_t nval)\n{\n\treturn acpi_data_prop_read(acpi_device_data_of_node(fwnode),\n\t\t\t\t   propname, proptype, val, nval);\n}\n\nstatic int stop_on_next(struct acpi_device *adev, void *data)\n{\n\tstruct acpi_device **ret_p = data;\n\n\tif (!*ret_p) {\n\t\t*ret_p = adev;\n\t\treturn 1;\n\t}\n\n\t \n\tif (*ret_p == adev)\n\t\t*ret_p = NULL;\n\n\treturn 0;\n}\n\n \nstruct fwnode_handle *acpi_get_next_subnode(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    struct fwnode_handle *child)\n{\n\tstruct acpi_device *adev = to_acpi_device_node(fwnode);\n\n\tif ((!child || is_acpi_device_node(child)) && adev) {\n\t\tstruct acpi_device *child_adev = to_acpi_device_node(child);\n\n\t\tacpi_dev_for_each_child(adev, stop_on_next, &child_adev);\n\t\tif (child_adev)\n\t\t\treturn acpi_fwnode_handle(child_adev);\n\n\t\tchild = NULL;\n\t}\n\n\tif (!child || is_acpi_data_node(child)) {\n\t\tconst struct acpi_data_node *data = to_acpi_data_node(fwnode);\n\t\tconst struct list_head *head;\n\t\tstruct list_head *next;\n\t\tstruct acpi_data_node *dn;\n\n\t\t \n\t\tadev = to_acpi_device_node(fwnode);\n\t\tif (adev)\n\t\t\thead = &adev->data.subnodes;\n\t\telse if (data)\n\t\t\thead = &data->data.subnodes;\n\t\telse\n\t\t\treturn NULL;\n\n\t\tif (list_empty(head))\n\t\t\treturn NULL;\n\n\t\tif (child) {\n\t\t\tdn = to_acpi_data_node(child);\n\t\t\tnext = dn->sibling.next;\n\t\t\tif (next == head)\n\t\t\t\treturn NULL;\n\n\t\t\tdn = list_entry(next, struct acpi_data_node, sibling);\n\t\t} else {\n\t\t\tdn = list_first_entry(head, struct acpi_data_node, sibling);\n\t\t}\n\t\treturn &dn->fwnode;\n\t}\n\treturn NULL;\n}\n\n \nstatic struct fwnode_handle *\nacpi_node_get_parent(const struct fwnode_handle *fwnode)\n{\n\tif (is_acpi_data_node(fwnode)) {\n\t\t \n\t\treturn to_acpi_data_node(fwnode)->parent;\n\t}\n\tif (is_acpi_device_node(fwnode)) {\n\t\tstruct acpi_device *parent;\n\n\t\tparent = acpi_dev_parent(to_acpi_device_node(fwnode));\n\t\tif (parent)\n\t\t\treturn acpi_fwnode_handle(parent);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool is_acpi_graph_node(struct fwnode_handle *fwnode,\n\t\t\t       const char *str)\n{\n\tunsigned int len = strlen(str);\n\tconst char *name;\n\n\tif (!len || !is_acpi_data_node(fwnode))\n\t\treturn false;\n\n\tname = to_acpi_data_node(fwnode)->name;\n\n\treturn (fwnode_property_present(fwnode, \"reg\") &&\n\t\t!strncmp(name, str, len) && name[len] == '@') ||\n\t\tfwnode_property_present(fwnode, str);\n}\n\n \nstatic struct fwnode_handle *acpi_graph_get_next_endpoint(\n\tconst struct fwnode_handle *fwnode, struct fwnode_handle *prev)\n{\n\tstruct fwnode_handle *port = NULL;\n\tstruct fwnode_handle *endpoint;\n\n\tif (!prev) {\n\t\tdo {\n\t\t\tport = fwnode_get_next_child_node(fwnode, port);\n\t\t\t \n\t\t\tif (is_acpi_graph_node(port, \"port\"))\n\t\t\t\tbreak;\n\t\t} while (port);\n\t} else {\n\t\tport = fwnode_get_parent(prev);\n\t}\n\n\tif (!port)\n\t\treturn NULL;\n\n\tendpoint = fwnode_get_next_child_node(port, prev);\n\twhile (!endpoint) {\n\t\tport = fwnode_get_next_child_node(fwnode, port);\n\t\tif (!port)\n\t\t\tbreak;\n\t\tif (is_acpi_graph_node(port, \"port\"))\n\t\t\tendpoint = fwnode_get_next_child_node(port, NULL);\n\t}\n\n\t \n\tif (!is_acpi_graph_node(endpoint, \"endpoint\"))\n\t\treturn NULL;\n\n\treturn endpoint;\n}\n\n \nstatic struct fwnode_handle *acpi_graph_get_child_prop_value(\n\tconst struct fwnode_handle *fwnode, const char *prop_name,\n\tunsigned int val)\n{\n\tstruct fwnode_handle *child;\n\n\tfwnode_for_each_child_node(fwnode, child) {\n\t\tu32 nr;\n\n\t\tif (fwnode_property_read_u32(child, prop_name, &nr))\n\t\t\tcontinue;\n\n\t\tif (val == nr)\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}\n\n\n \nstatic struct fwnode_handle *\nacpi_graph_get_remote_endpoint(const struct fwnode_handle *__fwnode)\n{\n\tstruct fwnode_handle *fwnode;\n\tunsigned int port_nr, endpoint_nr;\n\tstruct fwnode_reference_args args;\n\tint ret;\n\n\tmemset(&args, 0, sizeof(args));\n\tret = acpi_node_get_property_reference(__fwnode, \"remote-endpoint\", 0,\n\t\t\t\t\t       &args);\n\tif (ret)\n\t\treturn NULL;\n\n\t \n\tif (!is_acpi_device_node(args.fwnode))\n\t\treturn args.nargs ? NULL : args.fwnode;\n\n\t \n\tif (args.nargs != 2)\n\t\treturn NULL;\n\n\tfwnode = args.fwnode;\n\tport_nr = args.args[0];\n\tendpoint_nr = args.args[1];\n\n\tfwnode = acpi_graph_get_child_prop_value(fwnode, \"port\", port_nr);\n\n\treturn acpi_graph_get_child_prop_value(fwnode, \"endpoint\", endpoint_nr);\n}\n\nstatic bool acpi_fwnode_device_is_available(const struct fwnode_handle *fwnode)\n{\n\tif (!is_acpi_device_node(fwnode))\n\t\treturn false;\n\n\treturn acpi_device_is_present(to_acpi_device_node(fwnode));\n}\n\nstatic const void *\nacpi_fwnode_device_get_match_data(const struct fwnode_handle *fwnode,\n\t\t\t\t  const struct device *dev)\n{\n\treturn acpi_device_get_match_data(dev);\n}\n\nstatic bool acpi_fwnode_device_dma_supported(const struct fwnode_handle *fwnode)\n{\n\treturn acpi_dma_supported(to_acpi_device_node(fwnode));\n}\n\nstatic enum dev_dma_attr\nacpi_fwnode_device_get_dma_attr(const struct fwnode_handle *fwnode)\n{\n\treturn acpi_get_dma_attr(to_acpi_device_node(fwnode));\n}\n\nstatic bool acpi_fwnode_property_present(const struct fwnode_handle *fwnode,\n\t\t\t\t\t const char *propname)\n{\n\treturn !acpi_node_prop_get(fwnode, propname, NULL);\n}\n\nstatic int\nacpi_fwnode_property_read_int_array(const struct fwnode_handle *fwnode,\n\t\t\t\t    const char *propname,\n\t\t\t\t    unsigned int elem_size, void *val,\n\t\t\t\t    size_t nval)\n{\n\tenum dev_prop_type type;\n\n\tswitch (elem_size) {\n\tcase sizeof(u8):\n\t\ttype = DEV_PROP_U8;\n\t\tbreak;\n\tcase sizeof(u16):\n\t\ttype = DEV_PROP_U16;\n\t\tbreak;\n\tcase sizeof(u32):\n\t\ttype = DEV_PROP_U32;\n\t\tbreak;\n\tcase sizeof(u64):\n\t\ttype = DEV_PROP_U64;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn acpi_node_prop_read(fwnode, propname, type, val, nval);\n}\n\nstatic int\nacpi_fwnode_property_read_string_array(const struct fwnode_handle *fwnode,\n\t\t\t\t       const char *propname, const char **val,\n\t\t\t\t       size_t nval)\n{\n\treturn acpi_node_prop_read(fwnode, propname, DEV_PROP_STRING,\n\t\t\t\t   val, nval);\n}\n\nstatic int\nacpi_fwnode_get_reference_args(const struct fwnode_handle *fwnode,\n\t\t\t       const char *prop, const char *nargs_prop,\n\t\t\t       unsigned int args_count, unsigned int index,\n\t\t\t       struct fwnode_reference_args *args)\n{\n\treturn __acpi_node_get_property_reference(fwnode, prop, index,\n\t\t\t\t\t\t  args_count, args);\n}\n\nstatic const char *acpi_fwnode_get_name(const struct fwnode_handle *fwnode)\n{\n\tconst struct acpi_device *adev;\n\tstruct fwnode_handle *parent;\n\n\t \n\tparent = fwnode_get_parent(fwnode);\n\tif (!parent)\n\t\treturn \"\\\\\";\n\n\tfwnode_handle_put(parent);\n\n\tif (is_acpi_data_node(fwnode)) {\n\t\tconst struct acpi_data_node *dn = to_acpi_data_node(fwnode);\n\n\t\treturn dn->name;\n\t}\n\n\tadev = to_acpi_device_node(fwnode);\n\tif (WARN_ON(!adev))\n\t\treturn NULL;\n\n\treturn acpi_device_bid(adev);\n}\n\nstatic const char *\nacpi_fwnode_get_name_prefix(const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *parent;\n\n\t \n\tparent = fwnode_get_parent(fwnode);\n\tif (!parent)\n\t\treturn \"\";\n\n\t \n\tparent = fwnode_get_next_parent(parent);\n\tif (!parent)\n\t\treturn \"\";\n\n\tfwnode_handle_put(parent);\n\n\t \n\treturn \".\";\n}\n\nstatic struct fwnode_handle *\nacpi_fwnode_get_parent(struct fwnode_handle *fwnode)\n{\n\treturn acpi_node_get_parent(fwnode);\n}\n\nstatic int acpi_fwnode_graph_parse_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    struct fwnode_endpoint *endpoint)\n{\n\tstruct fwnode_handle *port_fwnode = fwnode_get_parent(fwnode);\n\n\tendpoint->local_fwnode = fwnode;\n\n\tif (fwnode_property_read_u32(port_fwnode, \"reg\", &endpoint->port))\n\t\tfwnode_property_read_u32(port_fwnode, \"port\", &endpoint->port);\n\tif (fwnode_property_read_u32(fwnode, \"reg\", &endpoint->id))\n\t\tfwnode_property_read_u32(fwnode, \"endpoint\", &endpoint->id);\n\n\treturn 0;\n}\n\nstatic int acpi_fwnode_irq_get(const struct fwnode_handle *fwnode,\n\t\t\t       unsigned int index)\n{\n\tstruct resource res;\n\tint ret;\n\n\tret = acpi_irq_get(ACPI_HANDLE_FWNODE(fwnode), index, &res);\n\tif (ret)\n\t\treturn ret;\n\n\treturn res.start;\n}\n\n#define DECLARE_ACPI_FWNODE_OPS(ops) \\\n\tconst struct fwnode_operations ops = {\t\t\t\t\\\n\t\t.device_is_available = acpi_fwnode_device_is_available, \\\n\t\t.device_get_match_data = acpi_fwnode_device_get_match_data, \\\n\t\t.device_dma_supported =\t\t\t\t\\\n\t\t\tacpi_fwnode_device_dma_supported,\t\t\\\n\t\t.device_get_dma_attr = acpi_fwnode_device_get_dma_attr,\t\\\n\t\t.property_present = acpi_fwnode_property_present,\t\\\n\t\t.property_read_int_array =\t\t\t\t\\\n\t\t\tacpi_fwnode_property_read_int_array,\t\t\\\n\t\t.property_read_string_array =\t\t\t\t\\\n\t\t\tacpi_fwnode_property_read_string_array,\t\t\\\n\t\t.get_parent = acpi_node_get_parent,\t\t\t\\\n\t\t.get_next_child_node = acpi_get_next_subnode,\t\t\\\n\t\t.get_named_child_node = acpi_fwnode_get_named_child_node, \\\n\t\t.get_name = acpi_fwnode_get_name,\t\t\t\\\n\t\t.get_name_prefix = acpi_fwnode_get_name_prefix,\t\t\\\n\t\t.get_reference_args = acpi_fwnode_get_reference_args,\t\\\n\t\t.graph_get_next_endpoint =\t\t\t\t\\\n\t\t\tacpi_graph_get_next_endpoint,\t\t\t\\\n\t\t.graph_get_remote_endpoint =\t\t\t\t\\\n\t\t\tacpi_graph_get_remote_endpoint,\t\t\t\\\n\t\t.graph_get_port_parent = acpi_fwnode_get_parent,\t\\\n\t\t.graph_parse_endpoint = acpi_fwnode_graph_parse_endpoint, \\\n\t\t.irq_get = acpi_fwnode_irq_get,\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\tEXPORT_SYMBOL_GPL(ops)\n\nDECLARE_ACPI_FWNODE_OPS(acpi_device_fwnode_ops);\nDECLARE_ACPI_FWNODE_OPS(acpi_data_fwnode_ops);\nconst struct fwnode_operations acpi_static_fwnode_ops;\n\nbool is_acpi_device_node(const struct fwnode_handle *fwnode)\n{\n\treturn !IS_ERR_OR_NULL(fwnode) &&\n\t\tfwnode->ops == &acpi_device_fwnode_ops;\n}\nEXPORT_SYMBOL(is_acpi_device_node);\n\nbool is_acpi_data_node(const struct fwnode_handle *fwnode)\n{\n\treturn !IS_ERR_OR_NULL(fwnode) && fwnode->ops == &acpi_data_fwnode_ops;\n}\nEXPORT_SYMBOL(is_acpi_data_node);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}