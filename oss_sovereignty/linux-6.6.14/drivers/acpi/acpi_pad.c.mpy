{
  "module_name": "acpi_pad.c",
  "hash_id": "a2655d14ccd169fc04d7a061a9cdd52c1f9183d763bf87e18ee8d7ba6920b918",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_pad.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/cpumask.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/kthread.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/perf_event.h>\n#include <asm/mwait.h>\n#include <xen/xen.h>\n\n#define ACPI_PROCESSOR_AGGREGATOR_CLASS\t\"acpi_pad\"\n#define ACPI_PROCESSOR_AGGREGATOR_DEVICE_NAME \"Processor Aggregator\"\n#define ACPI_PROCESSOR_AGGREGATOR_NOTIFY 0x80\nstatic DEFINE_MUTEX(isolated_cpus_lock);\nstatic DEFINE_MUTEX(round_robin_lock);\n\nstatic unsigned long power_saving_mwait_eax;\n\nstatic unsigned char tsc_detected_unstable;\nstatic unsigned char tsc_marked_unstable;\n\nstatic void power_saving_mwait_init(void)\n{\n\tunsigned int eax, ebx, ecx, edx;\n\tunsigned int highest_cstate = 0;\n\tunsigned int highest_subcstate = 0;\n\tint i;\n\n\tif (!boot_cpu_has(X86_FEATURE_MWAIT))\n\t\treturn;\n\tif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\n\t\treturn;\n\n\tcpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &edx);\n\n\tif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\n\t    !(ecx & CPUID5_ECX_INTERRUPT_BREAK))\n\t\treturn;\n\n\tedx >>= MWAIT_SUBSTATE_SIZE;\n\tfor (i = 0; i < 7 && edx; i++, edx >>= MWAIT_SUBSTATE_SIZE) {\n\t\tif (edx & MWAIT_SUBSTATE_MASK) {\n\t\t\thighest_cstate = i;\n\t\t\thighest_subcstate = edx & MWAIT_SUBSTATE_MASK;\n\t\t}\n\t}\n\tpower_saving_mwait_eax = (highest_cstate << MWAIT_SUBSTATE_SIZE) |\n\t\t(highest_subcstate - 1);\n\n#if defined(CONFIG_X86)\n\tswitch (boot_cpu_data.x86_vendor) {\n\tcase X86_VENDOR_HYGON:\n\tcase X86_VENDOR_AMD:\n\tcase X86_VENDOR_INTEL:\n\tcase X86_VENDOR_ZHAOXIN:\n\tcase X86_VENDOR_CENTAUR:\n\t\t \n\t\tif (!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))\n\t\t\ttsc_detected_unstable = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\ttsc_detected_unstable = 1;\n\t}\n#endif\n}\n\nstatic unsigned long cpu_weight[NR_CPUS];\nstatic int tsk_in_cpu[NR_CPUS] = {[0 ... NR_CPUS-1] = -1};\nstatic DECLARE_BITMAP(pad_busy_cpus_bits, NR_CPUS);\nstatic void round_robin_cpu(unsigned int tsk_index)\n{\n\tstruct cpumask *pad_busy_cpus = to_cpumask(pad_busy_cpus_bits);\n\tcpumask_var_t tmp;\n\tint cpu;\n\tunsigned long min_weight = -1;\n\tunsigned long preferred_cpu;\n\n\tif (!alloc_cpumask_var(&tmp, GFP_KERNEL))\n\t\treturn;\n\n\tmutex_lock(&round_robin_lock);\n\tcpumask_clear(tmp);\n\tfor_each_cpu(cpu, pad_busy_cpus)\n\t\tcpumask_or(tmp, tmp, topology_sibling_cpumask(cpu));\n\tcpumask_andnot(tmp, cpu_online_mask, tmp);\n\t \n\tif (cpumask_empty(tmp))\n\t\tcpumask_andnot(tmp, cpu_online_mask, pad_busy_cpus);\n\tif (cpumask_empty(tmp)) {\n\t\tmutex_unlock(&round_robin_lock);\n\t\tfree_cpumask_var(tmp);\n\t\treturn;\n\t}\n\tfor_each_cpu(cpu, tmp) {\n\t\tif (cpu_weight[cpu] < min_weight) {\n\t\t\tmin_weight = cpu_weight[cpu];\n\t\t\tpreferred_cpu = cpu;\n\t\t}\n\t}\n\n\tif (tsk_in_cpu[tsk_index] != -1)\n\t\tcpumask_clear_cpu(tsk_in_cpu[tsk_index], pad_busy_cpus);\n\ttsk_in_cpu[tsk_index] = preferred_cpu;\n\tcpumask_set_cpu(preferred_cpu, pad_busy_cpus);\n\tcpu_weight[preferred_cpu]++;\n\tmutex_unlock(&round_robin_lock);\n\n\tset_cpus_allowed_ptr(current, cpumask_of(preferred_cpu));\n\n\tfree_cpumask_var(tmp);\n}\n\nstatic void exit_round_robin(unsigned int tsk_index)\n{\n\tstruct cpumask *pad_busy_cpus = to_cpumask(pad_busy_cpus_bits);\n\n\tcpumask_clear_cpu(tsk_in_cpu[tsk_index], pad_busy_cpus);\n\ttsk_in_cpu[tsk_index] = -1;\n}\n\nstatic unsigned int idle_pct = 5;  \nstatic unsigned int round_robin_time = 1;  \nstatic int power_saving_thread(void *data)\n{\n\tint do_sleep;\n\tunsigned int tsk_index = (unsigned long)data;\n\tu64 last_jiffies = 0;\n\n\tsched_set_fifo_low(current);\n\n\twhile (!kthread_should_stop()) {\n\t\tunsigned long expire_time;\n\n\t\t \n\t\texpire_time = last_jiffies + round_robin_time * HZ;\n\t\tif (time_before(expire_time, jiffies)) {\n\t\t\tlast_jiffies = jiffies;\n\t\t\tround_robin_cpu(tsk_index);\n\t\t}\n\n\t\tdo_sleep = 0;\n\n\t\texpire_time = jiffies + HZ * (100 - idle_pct) / 100;\n\n\t\twhile (!need_resched()) {\n\t\t\tif (tsc_detected_unstable && !tsc_marked_unstable) {\n\t\t\t\t \n\t\t\t\tmark_tsc_unstable(\"TSC halts in idle\");\n\t\t\t\ttsc_marked_unstable = 1;\n\t\t\t}\n\t\t\tlocal_irq_disable();\n\n\t\t\tperf_lopwr_cb(true);\n\n\t\t\ttick_broadcast_enable();\n\t\t\ttick_broadcast_enter();\n\t\t\tstop_critical_timings();\n\n\t\t\tmwait_idle_with_hints(power_saving_mwait_eax, 1);\n\n\t\t\tstart_critical_timings();\n\t\t\ttick_broadcast_exit();\n\n\t\t\tperf_lopwr_cb(false);\n\n\t\t\tlocal_irq_enable();\n\n\t\t\tif (time_before(expire_time, jiffies)) {\n\t\t\t\tdo_sleep = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (unlikely(do_sleep))\n\t\t\tschedule_timeout_killable(HZ * idle_pct / 100);\n\n\t\t \n\t\tif (unlikely(need_resched()))\n\t\t\tschedule();\n\t}\n\n\texit_round_robin(tsk_index);\n\treturn 0;\n}\n\nstatic struct task_struct *ps_tsks[NR_CPUS];\nstatic unsigned int ps_tsk_num;\nstatic int create_power_saving_task(void)\n{\n\tint rc;\n\n\tps_tsks[ps_tsk_num] = kthread_run(power_saving_thread,\n\t\t(void *)(unsigned long)ps_tsk_num,\n\t\t\"acpi_pad/%d\", ps_tsk_num);\n\n\tif (IS_ERR(ps_tsks[ps_tsk_num])) {\n\t\trc = PTR_ERR(ps_tsks[ps_tsk_num]);\n\t\tps_tsks[ps_tsk_num] = NULL;\n\t} else {\n\t\trc = 0;\n\t\tps_tsk_num++;\n\t}\n\n\treturn rc;\n}\n\nstatic void destroy_power_saving_task(void)\n{\n\tif (ps_tsk_num > 0) {\n\t\tps_tsk_num--;\n\t\tkthread_stop(ps_tsks[ps_tsk_num]);\n\t\tps_tsks[ps_tsk_num] = NULL;\n\t}\n}\n\nstatic void set_power_saving_task_num(unsigned int num)\n{\n\tif (num > ps_tsk_num) {\n\t\twhile (ps_tsk_num < num) {\n\t\t\tif (create_power_saving_task())\n\t\t\t\treturn;\n\t\t}\n\t} else if (num < ps_tsk_num) {\n\t\twhile (ps_tsk_num > num)\n\t\t\tdestroy_power_saving_task();\n\t}\n}\n\nstatic void acpi_pad_idle_cpus(unsigned int num_cpus)\n{\n\tcpus_read_lock();\n\n\tnum_cpus = min_t(unsigned int, num_cpus, num_online_cpus());\n\tset_power_saving_task_num(num_cpus);\n\n\tcpus_read_unlock();\n}\n\nstatic uint32_t acpi_pad_idle_cpus_num(void)\n{\n\treturn ps_tsk_num;\n}\n\nstatic ssize_t rrtime_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long num;\n\n\tif (kstrtoul(buf, 0, &num))\n\t\treturn -EINVAL;\n\tif (num < 1 || num >= 100)\n\t\treturn -EINVAL;\n\tmutex_lock(&isolated_cpus_lock);\n\tround_robin_time = num;\n\tmutex_unlock(&isolated_cpus_lock);\n\treturn count;\n}\n\nstatic ssize_t rrtime_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", round_robin_time);\n}\nstatic DEVICE_ATTR_RW(rrtime);\n\nstatic ssize_t idlepct_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long num;\n\n\tif (kstrtoul(buf, 0, &num))\n\t\treturn -EINVAL;\n\tif (num < 1 || num >= 100)\n\t\treturn -EINVAL;\n\tmutex_lock(&isolated_cpus_lock);\n\tidle_pct = num;\n\tmutex_unlock(&isolated_cpus_lock);\n\treturn count;\n}\n\nstatic ssize_t idlepct_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", idle_pct);\n}\nstatic DEVICE_ATTR_RW(idlepct);\n\nstatic ssize_t idlecpus_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long num;\n\n\tif (kstrtoul(buf, 0, &num))\n\t\treturn -EINVAL;\n\tmutex_lock(&isolated_cpus_lock);\n\tacpi_pad_idle_cpus(num);\n\tmutex_unlock(&isolated_cpus_lock);\n\treturn count;\n}\n\nstatic ssize_t idlecpus_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn cpumap_print_to_pagebuf(false, buf,\n\t\t\t\t       to_cpumask(pad_busy_cpus_bits));\n}\n\nstatic DEVICE_ATTR_RW(idlecpus);\n\nstatic int acpi_pad_add_sysfs(struct acpi_device *device)\n{\n\tint result;\n\n\tresult = device_create_file(&device->dev, &dev_attr_idlecpus);\n\tif (result)\n\t\treturn -ENODEV;\n\tresult = device_create_file(&device->dev, &dev_attr_idlepct);\n\tif (result) {\n\t\tdevice_remove_file(&device->dev, &dev_attr_idlecpus);\n\t\treturn -ENODEV;\n\t}\n\tresult = device_create_file(&device->dev, &dev_attr_rrtime);\n\tif (result) {\n\t\tdevice_remove_file(&device->dev, &dev_attr_idlecpus);\n\t\tdevice_remove_file(&device->dev, &dev_attr_idlepct);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic void acpi_pad_remove_sysfs(struct acpi_device *device)\n{\n\tdevice_remove_file(&device->dev, &dev_attr_idlecpus);\n\tdevice_remove_file(&device->dev, &dev_attr_idlepct);\n\tdevice_remove_file(&device->dev, &dev_attr_rrtime);\n}\n\n \nstatic int acpi_pad_pur(acpi_handle handle)\n{\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *package;\n\tint num = -1;\n\n\tif (ACPI_FAILURE(acpi_evaluate_object(handle, \"_PUR\", NULL, &buffer)))\n\t\treturn num;\n\n\tif (!buffer.length || !buffer.pointer)\n\t\treturn num;\n\n\tpackage = buffer.pointer;\n\n\tif (package->type == ACPI_TYPE_PACKAGE &&\n\t\tpackage->package.count == 2 &&\n\t\tpackage->package.elements[0].integer.value == 1)  \n\n\t\tnum = package->package.elements[1].integer.value;\n\n\tkfree(buffer.pointer);\n\treturn num;\n}\n\nstatic void acpi_pad_handle_notify(acpi_handle handle)\n{\n\tint num_cpus;\n\tuint32_t idle_cpus;\n\tstruct acpi_buffer param = {\n\t\t.length = 4,\n\t\t.pointer = (void *)&idle_cpus,\n\t};\n\n\tmutex_lock(&isolated_cpus_lock);\n\tnum_cpus = acpi_pad_pur(handle);\n\tif (num_cpus < 0) {\n\t\tmutex_unlock(&isolated_cpus_lock);\n\t\treturn;\n\t}\n\tacpi_pad_idle_cpus(num_cpus);\n\tidle_cpus = acpi_pad_idle_cpus_num();\n\tacpi_evaluate_ost(handle, ACPI_PROCESSOR_AGGREGATOR_NOTIFY, 0, &param);\n\tmutex_unlock(&isolated_cpus_lock);\n}\n\nstatic void acpi_pad_notify(acpi_handle handle, u32 event,\n\tvoid *data)\n{\n\tstruct acpi_device *device = data;\n\n\tswitch (event) {\n\tcase ACPI_PROCESSOR_AGGREGATOR_NOTIFY:\n\t\tacpi_pad_handle_notify(handle);\n\t\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\tdev_name(&device->dev), event, 0);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unsupported event [0x%x]\\n\", event);\n\t\tbreak;\n\t}\n}\n\nstatic int acpi_pad_add(struct acpi_device *device)\n{\n\tacpi_status status;\n\n\tstrcpy(acpi_device_name(device), ACPI_PROCESSOR_AGGREGATOR_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_PROCESSOR_AGGREGATOR_CLASS);\n\n\tif (acpi_pad_add_sysfs(device))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_install_notify_handler(device->handle,\n\t\tACPI_DEVICE_NOTIFY, acpi_pad_notify, device);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_pad_remove_sysfs(device);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void acpi_pad_remove(struct acpi_device *device)\n{\n\tmutex_lock(&isolated_cpus_lock);\n\tacpi_pad_idle_cpus(0);\n\tmutex_unlock(&isolated_cpus_lock);\n\n\tacpi_remove_notify_handler(device->handle,\n\t\tACPI_DEVICE_NOTIFY, acpi_pad_notify);\n\tacpi_pad_remove_sysfs(device);\n}\n\nstatic const struct acpi_device_id pad_device_ids[] = {\n\t{\"ACPI000C\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, pad_device_ids);\n\nstatic struct acpi_driver acpi_pad_driver = {\n\t.name = \"processor_aggregator\",\n\t.class = ACPI_PROCESSOR_AGGREGATOR_CLASS,\n\t.ids = pad_device_ids,\n\t.ops = {\n\t\t.add = acpi_pad_add,\n\t\t.remove = acpi_pad_remove,\n\t},\n};\n\nstatic int __init acpi_pad_init(void)\n{\n\t \n\tif (xen_initial_domain())\n\t\treturn -ENODEV;\n\n\tpower_saving_mwait_init();\n\tif (power_saving_mwait_eax == 0)\n\t\treturn -EINVAL;\n\n\treturn acpi_bus_register_driver(&acpi_pad_driver);\n}\n\nstatic void __exit acpi_pad_exit(void)\n{\n\tacpi_bus_unregister_driver(&acpi_pad_driver);\n}\n\nmodule_init(acpi_pad_init);\nmodule_exit(acpi_pad_exit);\nMODULE_AUTHOR(\"Shaohua Li<shaohua.li@intel.com>\");\nMODULE_DESCRIPTION(\"ACPI Processor Aggregator Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}