{
  "module_name": "acpi_video.c",
  "hash_id": "f86c2a385f5eb24429a4bdb9539ab324bc43bff99ac48bd26eb0b15015310e93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_video.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: video: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/input.h>\n#include <linux/backlight.h>\n#include <linux/thermal.h>\n#include <linux/sort.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/slab.h>\n#include <linux/dmi.h>\n#include <linux/suspend.h>\n#include <linux/acpi.h>\n#include <acpi/video.h>\n#include <linux/uaccess.h>\n\n#define ACPI_VIDEO_BUS_NAME\t\t\"Video Bus\"\n#define ACPI_VIDEO_DEVICE_NAME\t\t\"Video Device\"\n\n#define MAX_NAME_LEN\t20\n\nMODULE_AUTHOR(\"Bruno Ducrot\");\nMODULE_DESCRIPTION(\"ACPI Video Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool brightness_switch_enabled = true;\nmodule_param(brightness_switch_enabled, bool, 0644);\n\n \nstatic bool allow_duplicates;\nmodule_param(allow_duplicates, bool, 0644);\n\n#define REPORT_OUTPUT_KEY_EVENTS\t\t0x01\n#define REPORT_BRIGHTNESS_KEY_EVENTS\t\t0x02\nstatic int report_key_events = -1;\nmodule_param(report_key_events, int, 0644);\nMODULE_PARM_DESC(report_key_events,\n\t\"0: none, 1: output changes, 2: brightness changes, 3: all\");\n\nstatic int hw_changes_brightness = -1;\nmodule_param(hw_changes_brightness, int, 0644);\nMODULE_PARM_DESC(hw_changes_brightness,\n\t\"Set this to 1 on buggy hw which changes the brightness itself when \"\n\t\"a hotkey is pressed: -1: auto, 0: normal 1: hw-changes-brightness\");\n\n \nstatic bool device_id_scheme = false;\nmodule_param(device_id_scheme, bool, 0444);\n\nstatic int only_lcd = -1;\nmodule_param(only_lcd, int, 0444);\n\nstatic bool may_report_brightness_keys;\nstatic int register_count;\nstatic DEFINE_MUTEX(register_count_mutex);\nstatic DEFINE_MUTEX(video_list_lock);\nstatic LIST_HEAD(video_bus_head);\nstatic int acpi_video_bus_add(struct acpi_device *device);\nstatic void acpi_video_bus_remove(struct acpi_device *device);\nstatic void acpi_video_bus_notify(acpi_handle handle, u32 event, void *data);\n\n \nenum acpi_video_level_idx {\n\tACPI_VIDEO_AC_LEVEL,\t\t \n\tACPI_VIDEO_BATTERY_LEVEL,\t \n\tACPI_VIDEO_FIRST_LEVEL,\t\t \n};\n\nstatic const struct acpi_device_id video_device_ids[] = {\n\t{ACPI_VIDEO_HID, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, video_device_ids);\n\nstatic struct acpi_driver acpi_video_bus = {\n\t.name = \"video\",\n\t.class = ACPI_VIDEO_CLASS,\n\t.ids = video_device_ids,\n\t.ops = {\n\t\t.add = acpi_video_bus_add,\n\t\t.remove = acpi_video_bus_remove,\n\t\t},\n};\n\nstruct acpi_video_bus_flags {\n\tu8 multihead:1;\t\t \n\tu8 rom:1;\t\t \n\tu8 post:1;\t\t \n\tu8 reserved:5;\n};\n\nstruct acpi_video_bus_cap {\n\tu8 _DOS:1;\t\t \n\tu8 _DOD:1;\t\t \n\tu8 _ROM:1;\t\t \n\tu8 _GPD:1;\t\t \n\tu8 _SPD:1;\t\t \n\tu8 _VPO:1;\t\t \n\tu8 reserved:2;\n};\n\nstruct acpi_video_device_attrib {\n\tu32 display_index:4;\t \n\tu32 display_port_attachment:4;\t \n\tu32 display_type:4;\t \n\tu32 vendor_specific:4;\t \n\tu32 bios_can_detect:1;\t \n\tu32 depend_on_vga:1;\t \n\tu32 pipe_id:3;\t\t \n\tu32 reserved:10;\t \n\n\t \n\tu32 device_id_scheme:1;\n};\n\nstruct acpi_video_enumerated_device {\n\tunion {\n\t\tu32 int_val;\n\t\tstruct acpi_video_device_attrib attrib;\n\t} value;\n\tstruct acpi_video_device *bind_info;\n};\n\nstruct acpi_video_bus {\n\tstruct acpi_device *device;\n\tbool backlight_registered;\n\tu8 dos_setting;\n\tstruct acpi_video_enumerated_device *attached_array;\n\tu8 attached_count;\n\tu8 child_count;\n\tstruct acpi_video_bus_cap cap;\n\tstruct acpi_video_bus_flags flags;\n\tstruct list_head video_device_list;\n\tstruct mutex device_list_lock;\t \n\tstruct list_head entry;\n\tstruct input_dev *input;\n\tchar phys[32];\t \n\tstruct notifier_block pm_nb;\n};\n\nstruct acpi_video_device_flags {\n\tu8 crt:1;\n\tu8 lcd:1;\n\tu8 tvout:1;\n\tu8 dvi:1;\n\tu8 bios:1;\n\tu8 unknown:1;\n\tu8 notify:1;\n\tu8 reserved:1;\n};\n\nstruct acpi_video_device_cap {\n\tu8 _ADR:1;\t\t \n\tu8 _BCL:1;\t\t \n\tu8 _BCM:1;\t\t \n\tu8 _BQC:1;\t\t \n\tu8 _BCQ:1;\t\t \n\tu8 _DDC:1;\t\t \n};\n\nstruct acpi_video_device {\n\tunsigned long device_id;\n\tstruct acpi_video_device_flags flags;\n\tstruct acpi_video_device_cap cap;\n\tstruct list_head entry;\n\tstruct delayed_work switch_brightness_work;\n\tint switch_brightness_event;\n\tstruct acpi_video_bus *video;\n\tstruct acpi_device *dev;\n\tstruct acpi_video_device_brightness *brightness;\n\tstruct backlight_device *backlight;\n\tstruct thermal_cooling_device *cooling_dev;\n};\n\nstatic void acpi_video_device_notify(acpi_handle handle, u32 event, void *data);\nstatic void acpi_video_device_rebind(struct acpi_video_bus *video);\nstatic void acpi_video_device_bind(struct acpi_video_bus *video,\n\t\t\t\t   struct acpi_video_device *device);\nstatic int acpi_video_device_enumerate(struct acpi_video_bus *video);\nstatic int acpi_video_device_lcd_set_level(struct acpi_video_device *device,\n\t\t\tint level);\nstatic int acpi_video_device_lcd_get_level_current(\n\t\t\tstruct acpi_video_device *device,\n\t\t\tunsigned long long *level, bool raw);\nstatic int acpi_video_get_next_level(struct acpi_video_device *device,\n\t\t\t\t     u32 level_current, u32 event);\nstatic void acpi_video_switch_brightness(struct work_struct *work);\n\n \nstatic int acpi_video_get_brightness(struct backlight_device *bd)\n{\n\tunsigned long long cur_level;\n\tint i;\n\tstruct acpi_video_device *vd = bl_get_data(bd);\n\n\tif (acpi_video_device_lcd_get_level_current(vd, &cur_level, false))\n\t\treturn -EINVAL;\n\tfor (i = ACPI_VIDEO_FIRST_LEVEL; i < vd->brightness->count; i++) {\n\t\tif (vd->brightness->levels[i] == cur_level)\n\t\t\treturn i - ACPI_VIDEO_FIRST_LEVEL;\n\t}\n\treturn 0;\n}\n\nstatic int acpi_video_set_brightness(struct backlight_device *bd)\n{\n\tint request_level = bd->props.brightness + ACPI_VIDEO_FIRST_LEVEL;\n\tstruct acpi_video_device *vd = bl_get_data(bd);\n\n\tcancel_delayed_work(&vd->switch_brightness_work);\n\treturn acpi_video_device_lcd_set_level(vd,\n\t\t\t\tvd->brightness->levels[request_level]);\n}\n\nstatic const struct backlight_ops acpi_backlight_ops = {\n\t.get_brightness = acpi_video_get_brightness,\n\t.update_status  = acpi_video_set_brightness,\n};\n\n \nstatic int video_get_max_state(struct thermal_cooling_device *cooling_dev,\n\t\t\t       unsigned long *state)\n{\n\tstruct acpi_video_device *video = cooling_dev->devdata;\n\n\t*state = video->brightness->count - ACPI_VIDEO_FIRST_LEVEL - 1;\n\treturn 0;\n}\n\nstatic int video_get_cur_state(struct thermal_cooling_device *cooling_dev,\n\t\t\t       unsigned long *state)\n{\n\tstruct acpi_video_device *video = cooling_dev->devdata;\n\tunsigned long long level;\n\tint offset;\n\n\tif (acpi_video_device_lcd_get_level_current(video, &level, false))\n\t\treturn -EINVAL;\n\tfor (offset = ACPI_VIDEO_FIRST_LEVEL; offset < video->brightness->count;\n\t     offset++)\n\t\tif (level == video->brightness->levels[offset]) {\n\t\t\t*state = video->brightness->count - offset - 1;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nvideo_set_cur_state(struct thermal_cooling_device *cooling_dev, unsigned long state)\n{\n\tstruct acpi_video_device *video = cooling_dev->devdata;\n\tint level;\n\n\tif (state >= video->brightness->count - ACPI_VIDEO_FIRST_LEVEL)\n\t\treturn -EINVAL;\n\n\tstate = video->brightness->count - state;\n\tlevel = video->brightness->levels[state - 1];\n\treturn acpi_video_device_lcd_set_level(video, level);\n}\n\nstatic const struct thermal_cooling_device_ops video_cooling_ops = {\n\t.get_max_state = video_get_max_state,\n\t.get_cur_state = video_get_cur_state,\n\t.set_cur_state = video_set_cur_state,\n};\n\n \n\nstatic int\nacpi_video_device_lcd_query_levels(acpi_handle handle,\n\t\t\t\t   union acpi_object **levels)\n{\n\tint status;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\n\n\t*levels = NULL;\n\n\tstatus = acpi_evaluate_object(handle, \"_BCL\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn status;\n\tobj = (union acpi_object *)buffer.pointer;\n\tif (!obj || (obj->type != ACPI_TYPE_PACKAGE)) {\n\t\tacpi_handle_info(handle, \"Invalid _BCL data\\n\");\n\t\tstatus = -EFAULT;\n\t\tgoto err;\n\t}\n\n\t*levels = obj;\n\n\treturn 0;\n\nerr:\n\tkfree(buffer.pointer);\n\n\treturn status;\n}\n\nstatic int\nacpi_video_device_lcd_set_level(struct acpi_video_device *device, int level)\n{\n\tint status;\n\tint state;\n\n\tstatus = acpi_execute_simple_method(device->dev->handle,\n\t\t\t\t\t    \"_BCM\", level);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_info(device->dev->handle, \"_BCM evaluation failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdevice->brightness->curr = level;\n\tfor (state = ACPI_VIDEO_FIRST_LEVEL; state < device->brightness->count;\n\t     state++)\n\t\tif (level == device->brightness->levels[state]) {\n\t\t\tif (device->backlight)\n\t\t\t\tdevice->backlight->props.brightness =\n\t\t\t\t\tstate - ACPI_VIDEO_FIRST_LEVEL;\n\t\t\treturn 0;\n\t\t}\n\n\tacpi_handle_info(device->dev->handle, \"Current brightness invalid\\n\");\n\treturn -EINVAL;\n}\n\n \n\nstatic int bqc_offset_aml_bug_workaround;\nstatic int video_set_bqc_offset(const struct dmi_system_id *d)\n{\n\tbqc_offset_aml_bug_workaround = 9;\n\treturn 0;\n}\n\nstatic int video_set_device_id_scheme(const struct dmi_system_id *d)\n{\n\tdevice_id_scheme = true;\n\treturn 0;\n}\n\nstatic int video_enable_only_lcd(const struct dmi_system_id *d)\n{\n\tonly_lcd = true;\n\treturn 0;\n}\n\nstatic int video_set_report_key_events(const struct dmi_system_id *id)\n{\n\tif (report_key_events == -1)\n\t\treport_key_events = (uintptr_t)id->driver_data;\n\treturn 0;\n}\n\nstatic int video_hw_changes_brightness(\n\tconst struct dmi_system_id *d)\n{\n\tif (hw_changes_brightness == -1)\n\t\thw_changes_brightness = 1;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id video_dmi_table[] = {\n\t \n\t{\n\t .callback = video_set_bqc_offset,\n\t .ident = \"Acer Aspire 5720\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Acer\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5720\"),\n\t\t},\n\t},\n\t{\n\t .callback = video_set_bqc_offset,\n\t .ident = \"Acer Aspire 5710Z\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Acer\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5710Z\"),\n\t\t},\n\t},\n\t{\n\t .callback = video_set_bqc_offset,\n\t .ident = \"eMachines E510\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"EMACHINES\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"eMachines E510\"),\n\t\t},\n\t},\n\t{\n\t .callback = video_set_bqc_offset,\n\t .ident = \"Acer Aspire 5315\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Acer\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 5315\"),\n\t\t},\n\t},\n\t{\n\t .callback = video_set_bqc_offset,\n\t .ident = \"Acer Aspire 7720\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Acer\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire 7720\"),\n\t\t},\n\t},\n\n\t \n\t{\n\t  \n\t .callback = video_set_device_id_scheme,\n\t .ident = \"ESPRIMO Mobile M9410\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ESPRIMO Mobile M9410\"),\n\t\t},\n\t},\n\t \n\t{\n\t  \n\t .callback = video_enable_only_lcd,\n\t .ident = \"ESPRIMO Mobile M9410\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"FUJITSU SIEMENS\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ESPRIMO Mobile M9410\"),\n\t\t},\n\t},\n\t \n\t{\n\t .callback = video_set_report_key_events,\n\t .driver_data = (void *)((uintptr_t)REPORT_OUTPUT_KEY_EVENTS),\n\t .ident = \"Dell Vostro V131\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro V131\"),\n\t\t},\n\t},\n\t{\n\t .callback = video_set_report_key_events,\n\t .driver_data = (void *)((uintptr_t)REPORT_BRIGHTNESS_KEY_EVENTS),\n\t .ident = \"Dell Vostro 3350\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro 3350\"),\n\t\t},\n\t},\n\t \n\t{\n\t  \n\t .callback = video_hw_changes_brightness,\n\t .ident = \"Packard Bell EasyNote MZ35\",\n\t .matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Packard Bell\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"EasyNote MZ35\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic unsigned long long\nacpi_video_bqc_value_to_level(struct acpi_video_device *device,\n\t\t\t      unsigned long long bqc_value)\n{\n\tunsigned long long level;\n\n\tif (device->brightness->flags._BQC_use_index) {\n\t\t \n\t\tif (device->brightness->flags._BCL_reversed)\n\t\t\tbqc_value = device->brightness->count -\n\t\t\t\tACPI_VIDEO_FIRST_LEVEL - 1 - bqc_value;\n\n\t\tlevel = device->brightness->levels[bqc_value +\n\t\t\t\t\t\t   ACPI_VIDEO_FIRST_LEVEL];\n\t} else {\n\t\tlevel = bqc_value;\n\t}\n\n\tlevel += bqc_offset_aml_bug_workaround;\n\n\treturn level;\n}\n\nstatic int\nacpi_video_device_lcd_get_level_current(struct acpi_video_device *device,\n\t\t\t\t\tunsigned long long *level, bool raw)\n{\n\tacpi_status status = AE_OK;\n\tint i;\n\n\tif (device->cap._BQC || device->cap._BCQ) {\n\t\tchar *buf = device->cap._BQC ? \"_BQC\" : \"_BCQ\";\n\n\t\tstatus = acpi_evaluate_integer(device->dev->handle, buf,\n\t\t\t\t\t\tNULL, level);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tif (raw) {\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*level = acpi_video_bqc_value_to_level(device, *level);\n\n\t\t\tfor (i = ACPI_VIDEO_FIRST_LEVEL;\n\t\t\t     i < device->brightness->count; i++)\n\t\t\t\tif (device->brightness->levels[i] == *level) {\n\t\t\t\t\tdevice->brightness->curr = *level;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t \n\t\t\tacpi_handle_info(device->dev->handle,\n\t\t\t\t\t \"%s returned an invalid level\", buf);\n\t\t\tdevice->cap._BQC = device->cap._BCQ = 0;\n\t\t} else {\n\t\t\t \n\t\t\tacpi_handle_info(device->dev->handle,\n\t\t\t\t\t \"%s evaluation failed\", buf);\n\t\t\tdevice->cap._BQC = device->cap._BCQ = 0;\n\t\t}\n\t}\n\n\t*level = device->brightness->curr;\n\treturn 0;\n}\n\nstatic int\nacpi_video_device_EDID(struct acpi_video_device *device,\n\t\t       union acpi_object **edid, ssize_t length)\n{\n\tint status;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tunion acpi_object arg0 = { ACPI_TYPE_INTEGER };\n\tstruct acpi_object_list args = { 1, &arg0 };\n\n\n\t*edid = NULL;\n\n\tif (!device)\n\t\treturn -ENODEV;\n\tif (length == 128)\n\t\targ0.integer.value = 1;\n\telse if (length == 256)\n\t\targ0.integer.value = 2;\n\telse\n\t\treturn -EINVAL;\n\n\tstatus = acpi_evaluate_object(device->dev->handle, \"_DDC\", &args, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tobj = buffer.pointer;\n\n\tif (obj && obj->type == ACPI_TYPE_BUFFER)\n\t\t*edid = obj;\n\telse {\n\t\tacpi_handle_info(device->dev->handle, \"Invalid _DDC data\\n\");\n\t\tstatus = -EFAULT;\n\t\tkfree(obj);\n\t}\n\n\treturn status;\n}\n\n \n\n \n\nstatic int\nacpi_video_bus_DOS(struct acpi_video_bus *video, int bios_flag, int lcd_flag)\n{\n\tacpi_status status;\n\n\tif (!video->cap._DOS)\n\t\treturn 0;\n\n\tif (bios_flag < 0 || bios_flag > 3 || lcd_flag < 0 || lcd_flag > 1)\n\t\treturn -EINVAL;\n\tvideo->dos_setting = (lcd_flag << 2) | bios_flag;\n\tstatus = acpi_execute_simple_method(video->device->handle, \"_DOS\",\n\t\t\t\t\t    (lcd_flag << 2) | bios_flag);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \n\nstatic int\nacpi_video_cmp_level(const void *a, const void *b)\n{\n\treturn *(int *)a - *(int *)b;\n}\n\n \nstatic int acpi_video_bqc_quirk(struct acpi_video_device *device,\n\t\t\t\tint max_level, int current_level)\n{\n\tstruct acpi_video_device_brightness *br = device->brightness;\n\tint result;\n\tunsigned long long level;\n\tint test_level;\n\n\t \n\tif (bqc_offset_aml_bug_workaround)\n\t\treturn 0;\n\n\t \n\ttest_level = current_level == max_level\n\t\t? br->levels[ACPI_VIDEO_FIRST_LEVEL + 1]\n\t\t: max_level;\n\n\tresult = acpi_video_device_lcd_set_level(device, test_level);\n\tif (result)\n\t\treturn result;\n\n\tresult = acpi_video_device_lcd_get_level_current(device, &level, true);\n\tif (result)\n\t\treturn result;\n\n\tif (level != test_level) {\n\t\t \n\t\tif (level < br->count) {\n\t\t\tif (br->flags._BCL_reversed)\n\t\t\t\tlevel = br->count - ACPI_VIDEO_FIRST_LEVEL - 1 - level;\n\t\t\tif (br->levels[level + ACPI_VIDEO_FIRST_LEVEL] == test_level)\n\t\t\t\tbr->flags._BQC_use_index = 1;\n\t\t}\n\n\t\tif (!br->flags._BQC_use_index)\n\t\t\tdevice->cap._BQC = device->cap._BCQ = 0;\n\t}\n\n\treturn 0;\n}\n\nint acpi_video_get_levels(struct acpi_device *device,\n\t\t\t  struct acpi_video_device_brightness **dev_br,\n\t\t\t  int *pmax_level)\n{\n\tunion acpi_object *obj = NULL;\n\tint i, max_level = 0, count = 0, level_ac_battery = 0;\n\tunion acpi_object *o;\n\tstruct acpi_video_device_brightness *br = NULL;\n\tint result = 0;\n\tu32 value;\n\n\tif (ACPI_FAILURE(acpi_video_device_lcd_query_levels(device->handle, &obj))) {\n\t\tacpi_handle_debug(device->handle,\n\t\t\t\t  \"Could not query available LCD brightness level\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (obj->package.count < ACPI_VIDEO_FIRST_LEVEL) {\n\t\tresult = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbr = kzalloc(sizeof(*br), GFP_KERNEL);\n\tif (!br) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tbr->levels = kmalloc_array(obj->package.count + ACPI_VIDEO_FIRST_LEVEL,\n\t\t\t\t   sizeof(*br->levels),\n\t\t\t\t   GFP_KERNEL);\n\tif (!br->levels) {\n\t\tresult = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tfor (i = 0; i < obj->package.count; i++) {\n\t\to = (union acpi_object *)&obj->package.elements[i];\n\t\tif (o->type != ACPI_TYPE_INTEGER) {\n\t\t\tacpi_handle_info(device->handle, \"Invalid data\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = (u32) o->integer.value;\n\t\t \n\t\tif (count > ACPI_VIDEO_FIRST_LEVEL\n\t\t    && br->levels[count - 1] == value)\n\t\t\tcontinue;\n\n\t\tbr->levels[count] = value;\n\n\t\tif (br->levels[count] > max_level)\n\t\t\tmax_level = br->levels[count];\n\t\tcount++;\n\t}\n\n\t \n\tfor (i = ACPI_VIDEO_FIRST_LEVEL; i < count; i++) {\n\t\tif (br->levels[i] == br->levels[ACPI_VIDEO_AC_LEVEL])\n\t\t\tlevel_ac_battery++;\n\t\tif (br->levels[i] == br->levels[ACPI_VIDEO_BATTERY_LEVEL])\n\t\t\tlevel_ac_battery++;\n\t}\n\n\tif (level_ac_battery < ACPI_VIDEO_FIRST_LEVEL) {\n\t\tlevel_ac_battery = ACPI_VIDEO_FIRST_LEVEL - level_ac_battery;\n\t\tbr->flags._BCL_no_ac_battery_levels = 1;\n\t\tfor (i = (count - 1 + level_ac_battery);\n\t\t     i >= ACPI_VIDEO_FIRST_LEVEL; i--)\n\t\t\tbr->levels[i] = br->levels[i - level_ac_battery];\n\t\tcount += level_ac_battery;\n\t} else if (level_ac_battery > ACPI_VIDEO_FIRST_LEVEL)\n\t\tacpi_handle_info(device->handle,\n\t\t\t\t \"Too many duplicates in _BCL package\");\n\n\t \n\tif (max_level == br->levels[ACPI_VIDEO_FIRST_LEVEL]) {\n\t\tbr->flags._BCL_reversed = 1;\n\t\tsort(&br->levels[ACPI_VIDEO_FIRST_LEVEL],\n\t\t     count - ACPI_VIDEO_FIRST_LEVEL,\n\t\t     sizeof(br->levels[ACPI_VIDEO_FIRST_LEVEL]),\n\t\t     acpi_video_cmp_level, NULL);\n\t} else if (max_level != br->levels[count - 1])\n\t\tacpi_handle_info(device->handle,\n\t\t\t\t \"Found unordered _BCL package\");\n\n\tbr->count = count;\n\t*dev_br = br;\n\tif (pmax_level)\n\t\t*pmax_level = max_level;\n\nout:\n\tkfree(obj);\n\treturn result;\nout_free:\n\tkfree(br);\n\tgoto out;\n}\nEXPORT_SYMBOL(acpi_video_get_levels);\n\n \n\nstatic int\nacpi_video_init_brightness(struct acpi_video_device *device)\n{\n\tint i, max_level = 0;\n\tunsigned long long level, level_old;\n\tstruct acpi_video_device_brightness *br = NULL;\n\tint result;\n\n\tresult = acpi_video_get_levels(device->dev, &br, &max_level);\n\tif (result)\n\t\treturn result;\n\tdevice->brightness = br;\n\n\t \n\tbr->curr = level = max_level;\n\n\tif (!device->cap._BQC)\n\t\tgoto set_level;\n\n\tresult = acpi_video_device_lcd_get_level_current(device,\n\t\t\t\t\t\t\t &level_old, true);\n\tif (result)\n\t\tgoto out_free_levels;\n\n\tresult = acpi_video_bqc_quirk(device, max_level, level_old);\n\tif (result)\n\t\tgoto out_free_levels;\n\t \n\tif (!device->cap._BQC)\n\t\tgoto set_level;\n\n\tlevel = acpi_video_bqc_value_to_level(device, level_old);\n\t \n\tfor (i = ACPI_VIDEO_FIRST_LEVEL; i < br->count; i++)\n\t\tif (level == br->levels[i])\n\t\t\tbreak;\n\tif (i == br->count || !level)\n\t\tlevel = max_level;\n\nset_level:\n\tresult = acpi_video_device_lcd_set_level(device, level);\n\tif (result)\n\t\tgoto out_free_levels;\n\n\tacpi_handle_debug(device->dev->handle, \"found %d brightness levels\\n\",\n\t\t\t  br->count - ACPI_VIDEO_FIRST_LEVEL);\n\n\treturn 0;\n\nout_free_levels:\n\tkfree(br->levels);\n\tkfree(br);\n\tdevice->brightness = NULL;\n\treturn result;\n}\n\n \n\nstatic void acpi_video_device_find_cap(struct acpi_video_device *device)\n{\n\tif (acpi_has_method(device->dev->handle, \"_ADR\"))\n\t\tdevice->cap._ADR = 1;\n\tif (acpi_has_method(device->dev->handle, \"_BCL\"))\n\t\tdevice->cap._BCL = 1;\n\tif (acpi_has_method(device->dev->handle, \"_BCM\"))\n\t\tdevice->cap._BCM = 1;\n\tif (acpi_has_method(device->dev->handle, \"_BQC\")) {\n\t\tdevice->cap._BQC = 1;\n\t} else if (acpi_has_method(device->dev->handle, \"_BCQ\")) {\n\t\tacpi_handle_info(device->dev->handle,\n\t\t\t\t \"_BCQ is used instead of _BQC\\n\");\n\t\tdevice->cap._BCQ = 1;\n\t}\n\n\tif (acpi_has_method(device->dev->handle, \"_DDC\"))\n\t\tdevice->cap._DDC = 1;\n}\n\n \n\nstatic void acpi_video_bus_find_cap(struct acpi_video_bus *video)\n{\n\tif (acpi_has_method(video->device->handle, \"_DOS\"))\n\t\tvideo->cap._DOS = 1;\n\tif (acpi_has_method(video->device->handle, \"_DOD\"))\n\t\tvideo->cap._DOD = 1;\n\tif (acpi_has_method(video->device->handle, \"_ROM\"))\n\t\tvideo->cap._ROM = 1;\n\tif (acpi_has_method(video->device->handle, \"_GPD\"))\n\t\tvideo->cap._GPD = 1;\n\tif (acpi_has_method(video->device->handle, \"_SPD\"))\n\t\tvideo->cap._SPD = 1;\n\tif (acpi_has_method(video->device->handle, \"_VPO\"))\n\t\tvideo->cap._VPO = 1;\n}\n\n \n\nstatic int acpi_video_bus_check(struct acpi_video_bus *video)\n{\n\tacpi_status status = -ENOENT;\n\tstruct pci_dev *dev;\n\n\tif (!video)\n\t\treturn -EINVAL;\n\n\tdev = acpi_get_pci_dev(video->device->handle);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tpci_dev_put(dev);\n\n\t \n\n\t \n\tif (video->cap._DOS || video->cap._DOD) {\n\t\tif (!video->cap._DOS) {\n\t\t\tpr_info(FW_BUG \"ACPI(%s) defines _DOD but not _DOS\\n\",\n\t\t\t\tacpi_device_bid(video->device));\n\t\t}\n\t\tvideo->flags.multihead = 1;\n\t\tstatus = 0;\n\t}\n\n\t \n\tif (video->cap._ROM) {\n\t\tvideo->flags.rom = 1;\n\t\tstatus = 0;\n\t}\n\n\t \n\tif (video->cap._GPD && video->cap._SPD && video->cap._VPO) {\n\t\tvideo->flags.post = 1;\n\t\tstatus = 0;\n\t}\n\n\treturn status;\n}\n\n \n\n \nstatic struct acpi_video_device_attrib *\nacpi_video_get_device_attr(struct acpi_video_bus *video, unsigned long device_id)\n{\n\tstruct acpi_video_enumerated_device *ids;\n\tint i;\n\n\tfor (i = 0; i < video->attached_count; i++) {\n\t\tids = &video->attached_array[i];\n\t\tif ((ids->value.int_val & 0xffff) == device_id)\n\t\t\treturn &ids->value.attrib;\n\t}\n\n\treturn NULL;\n}\n\nstatic int\nacpi_video_get_device_type(struct acpi_video_bus *video,\n\t\t\t   unsigned long device_id)\n{\n\tstruct acpi_video_enumerated_device *ids;\n\tint i;\n\n\tfor (i = 0; i < video->attached_count; i++) {\n\t\tids = &video->attached_array[i];\n\t\tif ((ids->value.int_val & 0xffff) == device_id)\n\t\t\treturn ids->value.int_val;\n\t}\n\n\treturn 0;\n}\n\nstatic int acpi_video_bus_get_one_device(struct acpi_device *device, void *arg)\n{\n\tstruct acpi_video_bus *video = arg;\n\tstruct acpi_video_device_attrib *attribute;\n\tstruct acpi_video_device *data;\n\tunsigned long long device_id;\n\tacpi_status status;\n\tint device_type;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"_ADR\", NULL, &device_id);\n\t \n\tif (ACPI_FAILURE(status))\n\t\tgoto exit;\n\n\tdata = kzalloc(sizeof(struct acpi_video_device), GFP_KERNEL);\n\tif (!data) {\n\t\tdev_dbg(&device->dev, \"Cannot attach\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstrcpy(acpi_device_name(device), ACPI_VIDEO_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_VIDEO_CLASS);\n\n\tdata->device_id = device_id;\n\tdata->video = video;\n\tdata->dev = device;\n\tINIT_DELAYED_WORK(&data->switch_brightness_work,\n\t\t\t  acpi_video_switch_brightness);\n\n\tattribute = acpi_video_get_device_attr(video, device_id);\n\n\tif (attribute && (attribute->device_id_scheme || device_id_scheme)) {\n\t\tswitch (attribute->display_type) {\n\t\tcase ACPI_VIDEO_DISPLAY_CRT:\n\t\t\tdata->flags.crt = 1;\n\t\t\tbreak;\n\t\tcase ACPI_VIDEO_DISPLAY_TV:\n\t\t\tdata->flags.tvout = 1;\n\t\t\tbreak;\n\t\tcase ACPI_VIDEO_DISPLAY_DVI:\n\t\t\tdata->flags.dvi = 1;\n\t\t\tbreak;\n\t\tcase ACPI_VIDEO_DISPLAY_LCD:\n\t\t\tdata->flags.lcd = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata->flags.unknown = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (attribute->bios_can_detect)\n\t\t\tdata->flags.bios = 1;\n\t} else {\n\t\t \n\t\tdevice_type = acpi_video_get_device_type(video, device_id);\n\t\t \n\t\tswitch (device_type & 0xffe2ffff) {\n\t\tcase ACPI_VIDEO_DISPLAY_LEGACY_MONITOR:\n\t\t\tdata->flags.crt = 1;\n\t\t\tbreak;\n\t\tcase ACPI_VIDEO_DISPLAY_LEGACY_PANEL:\n\t\t\tdata->flags.lcd = 1;\n\t\t\tbreak;\n\t\tcase ACPI_VIDEO_DISPLAY_LEGACY_TV:\n\t\t\tdata->flags.tvout = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata->flags.unknown = 1;\n\t\t}\n\t}\n\n\tacpi_video_device_bind(video, data);\n\tacpi_video_device_find_cap(data);\n\n\tif (data->cap._BCM && data->cap._BCL)\n\t\tmay_report_brightness_keys = true;\n\n\tmutex_lock(&video->device_list_lock);\n\tlist_add_tail(&data->entry, &video->video_device_list);\n\tmutex_unlock(&video->device_list_lock);\n\nexit:\n\tvideo->child_count++;\n\treturn 0;\n}\n\n \n\nstatic void acpi_video_device_rebind(struct acpi_video_bus *video)\n{\n\tstruct acpi_video_device *dev;\n\n\tmutex_lock(&video->device_list_lock);\n\n\tlist_for_each_entry(dev, &video->video_device_list, entry)\n\t\tacpi_video_device_bind(video, dev);\n\n\tmutex_unlock(&video->device_list_lock);\n}\n\n \n\nstatic void\nacpi_video_device_bind(struct acpi_video_bus *video,\n\t\t       struct acpi_video_device *device)\n{\n\tstruct acpi_video_enumerated_device *ids;\n\tint i;\n\n\tfor (i = 0; i < video->attached_count; i++) {\n\t\tids = &video->attached_array[i];\n\t\tif (device->device_id == (ids->value.int_val & 0xffff)) {\n\t\t\tids->bind_info = device;\n\t\t\tacpi_handle_debug(video->device->handle, \"%s: %d\\n\",\n\t\t\t\t\t  __func__, i);\n\t\t}\n\t}\n}\n\nstatic bool acpi_video_device_in_dod(struct acpi_video_device *device)\n{\n\tstruct acpi_video_bus *video = device->video;\n\tint i;\n\n\t \n\tif (!video->attached_count || video->child_count > 8)\n\t\treturn true;\n\n\tfor (i = 0; i < video->attached_count; i++) {\n\t\tif ((video->attached_array[i].value.int_val & 0xfff) ==\n\t\t    (device->device_id & 0xfff))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \n\nstatic int acpi_video_device_enumerate(struct acpi_video_bus *video)\n{\n\tint status;\n\tint count;\n\tint i;\n\tstruct acpi_video_enumerated_device *active_list;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *dod = NULL;\n\tunion acpi_object *obj;\n\n\tif (!video->cap._DOD)\n\t\treturn AE_NOT_EXIST;\n\n\tstatus = acpi_evaluate_object(video->device->handle, \"_DOD\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_info(video->device->handle,\n\t\t\t\t \"_DOD evaluation failed: %s\\n\",\n\t\t\t\t acpi_format_exception(status));\n\t\treturn status;\n\t}\n\n\tdod = buffer.pointer;\n\tif (!dod || (dod->type != ACPI_TYPE_PACKAGE)) {\n\t\tacpi_handle_info(video->device->handle, \"Invalid _DOD data\\n\");\n\t\tstatus = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tacpi_handle_debug(video->device->handle, \"Found %d video heads in _DOD\\n\",\n\t\t\t  dod->package.count);\n\n\tactive_list = kcalloc(1 + dod->package.count,\n\t\t\t      sizeof(struct acpi_video_enumerated_device),\n\t\t\t      GFP_KERNEL);\n\tif (!active_list) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcount = 0;\n\tfor (i = 0; i < dod->package.count; i++) {\n\t\tobj = &dod->package.elements[i];\n\n\t\tif (obj->type != ACPI_TYPE_INTEGER) {\n\t\t\tacpi_handle_info(video->device->handle,\n\t\t\t\t\t \"Invalid _DOD data in element %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tactive_list[count].value.int_val = obj->integer.value;\n\t\tactive_list[count].bind_info = NULL;\n\n\t\tacpi_handle_debug(video->device->handle,\n\t\t\t\t  \"_DOD element[%d] = %d\\n\", i,\n\t\t\t\t  (int)obj->integer.value);\n\n\t\tcount++;\n\t}\n\n\tkfree(video->attached_array);\n\n\tvideo->attached_array = active_list;\n\tvideo->attached_count = count;\n\nout:\n\tkfree(buffer.pointer);\n\treturn status;\n}\n\nstatic int\nacpi_video_get_next_level(struct acpi_video_device *device,\n\t\t\t  u32 level_current, u32 event)\n{\n\tint min, max, min_above, max_below, i, l, delta = 255;\n\tmax = max_below = 0;\n\tmin = min_above = 255;\n\t \n\tfor (i = ACPI_VIDEO_FIRST_LEVEL; i < device->brightness->count; i++) {\n\t\tl = device->brightness->levels[i];\n\t\tif (abs(l - level_current) < abs(delta)) {\n\t\t\tdelta = l - level_current;\n\t\t\tif (!delta)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tlevel_current += delta;\n\tfor (i = ACPI_VIDEO_FIRST_LEVEL; i < device->brightness->count; i++) {\n\t\tl = device->brightness->levels[i];\n\t\tif (l < min)\n\t\t\tmin = l;\n\t\tif (l > max)\n\t\t\tmax = l;\n\t\tif (l < min_above && l > level_current)\n\t\t\tmin_above = l;\n\t\tif (l > max_below && l < level_current)\n\t\t\tmax_below = l;\n\t}\n\n\tswitch (event) {\n\tcase ACPI_VIDEO_NOTIFY_CYCLE_BRIGHTNESS:\n\t\treturn (level_current < max) ? min_above : min;\n\tcase ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS:\n\t\treturn (level_current < max) ? min_above : max;\n\tcase ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS:\n\t\treturn (level_current > min) ? max_below : min;\n\tcase ACPI_VIDEO_NOTIFY_ZERO_BRIGHTNESS:\n\tcase ACPI_VIDEO_NOTIFY_DISPLAY_OFF:\n\t\treturn 0;\n\tdefault:\n\t\treturn level_current;\n\t}\n}\n\nstatic void\nacpi_video_switch_brightness(struct work_struct *work)\n{\n\tstruct acpi_video_device *device = container_of(to_delayed_work(work),\n\t\t\t     struct acpi_video_device, switch_brightness_work);\n\tunsigned long long level_current, level_next;\n\tint event = device->switch_brightness_event;\n\tint result = -EINVAL;\n\n\t \n\tif (!device->backlight)\n\t\treturn;\n\n\tif (!device->brightness)\n\t\tgoto out;\n\n\tresult = acpi_video_device_lcd_get_level_current(device,\n\t\t\t\t\t\t\t &level_current,\n\t\t\t\t\t\t\t false);\n\tif (result)\n\t\tgoto out;\n\n\tlevel_next = acpi_video_get_next_level(device, level_current, event);\n\n\tresult = acpi_video_device_lcd_set_level(device, level_next);\n\n\tif (!result)\n\t\tbacklight_force_update(device->backlight,\n\t\t\t\t       BACKLIGHT_UPDATE_HOTKEY);\n\nout:\n\tif (result)\n\t\tacpi_handle_info(device->dev->handle,\n\t\t\t\t \"Failed to switch brightness\\n\");\n}\n\nint acpi_video_get_edid(struct acpi_device *device, int type, int device_id,\n\t\t\tvoid **edid)\n{\n\tstruct acpi_video_bus *video;\n\tstruct acpi_video_device *video_device;\n\tunion acpi_object *buffer = NULL;\n\tacpi_status status;\n\tint i, length;\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn -EINVAL;\n\n\tvideo = acpi_driver_data(device);\n\n\tfor (i = 0; i < video->attached_count; i++) {\n\t\tvideo_device = video->attached_array[i].bind_info;\n\t\tlength = 256;\n\n\t\tif (!video_device)\n\t\t\tcontinue;\n\n\t\tif (!video_device->cap._DDC)\n\t\t\tcontinue;\n\n\t\tif (type) {\n\t\t\tswitch (type) {\n\t\t\tcase ACPI_VIDEO_DISPLAY_CRT:\n\t\t\t\tif (!video_device->flags.crt)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_VIDEO_DISPLAY_TV:\n\t\t\t\tif (!video_device->flags.tvout)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_VIDEO_DISPLAY_DVI:\n\t\t\t\tif (!video_device->flags.dvi)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_VIDEO_DISPLAY_LCD:\n\t\t\t\tif (!video_device->flags.lcd)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (video_device->device_id != device_id) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = acpi_video_device_EDID(video_device, &buffer, length);\n\n\t\tif (ACPI_FAILURE(status) || !buffer ||\n\t\t    buffer->type != ACPI_TYPE_BUFFER) {\n\t\t\tlength = 128;\n\t\t\tstatus = acpi_video_device_EDID(video_device, &buffer,\n\t\t\t\t\t\t\tlength);\n\t\t\tif (ACPI_FAILURE(status) || !buffer ||\n\t\t\t    buffer->type != ACPI_TYPE_BUFFER) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t*edid = buffer->buffer.pointer;\n\t\treturn length;\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(acpi_video_get_edid);\n\nstatic int\nacpi_video_bus_get_devices(struct acpi_video_bus *video,\n\t\t\t   struct acpi_device *device)\n{\n\t \n\tacpi_video_device_enumerate(video);\n\n\treturn acpi_dev_for_each_child(device, acpi_video_bus_get_one_device, video);\n}\n\n \n\n \nstatic int acpi_video_bus_start_devices(struct acpi_video_bus *video)\n{\n\treturn acpi_video_bus_DOS(video, 0,\n\t\t\t\t  acpi_osi_is_win8() ? 1 : 0);\n}\n\nstatic int acpi_video_bus_stop_devices(struct acpi_video_bus *video)\n{\n\treturn acpi_video_bus_DOS(video, 0,\n\t\t\t\t  acpi_osi_is_win8() ? 0 : 1);\n}\n\nstatic void acpi_video_bus_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_device *device = data;\n\tstruct acpi_video_bus *video = acpi_driver_data(device);\n\tstruct input_dev *input;\n\tint keycode = 0;\n\n\tif (!video || !video->input)\n\t\treturn;\n\n\tinput = video->input;\n\n\tswitch (event) {\n\tcase ACPI_VIDEO_NOTIFY_SWITCH:\t \n\t\tkeycode = KEY_SWITCHVIDEOMODE;\n\t\tbreak;\n\n\tcase ACPI_VIDEO_NOTIFY_PROBE:\t \n\t\tacpi_video_device_enumerate(video);\n\t\tacpi_video_device_rebind(video);\n\t\tkeycode = KEY_SWITCHVIDEOMODE;\n\t\tbreak;\n\n\tcase ACPI_VIDEO_NOTIFY_CYCLE:\t \n\t\tkeycode = KEY_SWITCHVIDEOMODE;\n\t\tbreak;\n\tcase ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:\t \n\t\tkeycode = KEY_VIDEO_NEXT;\n\t\tbreak;\n\tcase ACPI_VIDEO_NOTIFY_PREV_OUTPUT:\t \n\t\tkeycode = KEY_VIDEO_PREV;\n\t\tbreak;\n\n\tdefault:\n\t\tacpi_handle_debug(device->handle, \"Unsupported event [0x%x]\\n\",\n\t\t\t\t  event);\n\t\tbreak;\n\t}\n\n\tif (acpi_notifier_call_chain(device, event, 0))\n\t\t \n\t\tkeycode = 0;\n\n\tif (keycode && (report_key_events & REPORT_OUTPUT_KEY_EVENTS)) {\n\t\tinput_report_key(input, keycode, 1);\n\t\tinput_sync(input);\n\t\tinput_report_key(input, keycode, 0);\n\t\tinput_sync(input);\n\t}\n}\n\nstatic void brightness_switch_event(struct acpi_video_device *video_device,\n\t\t\t\t    u32 event)\n{\n\tif (!brightness_switch_enabled)\n\t\treturn;\n\n\tvideo_device->switch_brightness_event = event;\n\tschedule_delayed_work(&video_device->switch_brightness_work, HZ / 10);\n}\n\nstatic void acpi_video_device_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_video_device *video_device = data;\n\tstruct acpi_device *device = NULL;\n\tstruct acpi_video_bus *bus;\n\tstruct input_dev *input;\n\tint keycode = 0;\n\n\tif (!video_device)\n\t\treturn;\n\n\tdevice = video_device->dev;\n\tbus = video_device->video;\n\tinput = bus->input;\n\n\tif (hw_changes_brightness > 0) {\n\t\tif (video_device->backlight)\n\t\t\tbacklight_force_update(video_device->backlight,\n\t\t\t\t\t       BACKLIGHT_UPDATE_HOTKEY);\n\t\tacpi_notifier_call_chain(device, event, 0);\n\t\treturn;\n\t}\n\n\tswitch (event) {\n\tcase ACPI_VIDEO_NOTIFY_CYCLE_BRIGHTNESS:\t \n\t\tbrightness_switch_event(video_device, event);\n\t\tkeycode = KEY_BRIGHTNESS_CYCLE;\n\t\tbreak;\n\tcase ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS:\t \n\t\tbrightness_switch_event(video_device, event);\n\t\tkeycode = KEY_BRIGHTNESSUP;\n\t\tbreak;\n\tcase ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS:\t \n\t\tbrightness_switch_event(video_device, event);\n\t\tkeycode = KEY_BRIGHTNESSDOWN;\n\t\tbreak;\n\tcase ACPI_VIDEO_NOTIFY_ZERO_BRIGHTNESS:\t \n\t\tbrightness_switch_event(video_device, event);\n\t\tkeycode = KEY_BRIGHTNESS_ZERO;\n\t\tbreak;\n\tcase ACPI_VIDEO_NOTIFY_DISPLAY_OFF:\t \n\t\tbrightness_switch_event(video_device, event);\n\t\tkeycode = KEY_DISPLAY_OFF;\n\t\tbreak;\n\tdefault:\n\t\tacpi_handle_debug(handle, \"Unsupported event [0x%x]\\n\", event);\n\t\tbreak;\n\t}\n\n\tif (keycode)\n\t\tmay_report_brightness_keys = true;\n\n\tacpi_notifier_call_chain(device, event, 0);\n\n\tif (keycode && (report_key_events & REPORT_BRIGHTNESS_KEY_EVENTS)) {\n\t\tinput_report_key(input, keycode, 1);\n\t\tinput_sync(input);\n\t\tinput_report_key(input, keycode, 0);\n\t\tinput_sync(input);\n\t}\n}\n\nstatic int acpi_video_resume(struct notifier_block *nb,\n\t\t\t\tunsigned long val, void *ign)\n{\n\tstruct acpi_video_bus *video;\n\tstruct acpi_video_device *video_device;\n\tint i;\n\n\tswitch (val) {\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_RESTORE:\n\t\tvideo = container_of(nb, struct acpi_video_bus, pm_nb);\n\n\t\tdev_info(&video->device->dev, \"Restoring backlight state\\n\");\n\n\t\tfor (i = 0; i < video->attached_count; i++) {\n\t\t\tvideo_device = video->attached_array[i].bind_info;\n\t\t\tif (video_device && video_device->brightness)\n\t\t\t\tacpi_video_device_lcd_set_level(video_device,\n\t\t\t\t\t\tvideo_device->brightness->curr);\n\t\t}\n\n\t\treturn NOTIFY_OK;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic acpi_status\nacpi_video_bus_match(acpi_handle handle, u32 level, void *context,\n\t\t\tvoid **return_value)\n{\n\tstruct acpi_device *device = context;\n\tstruct acpi_device *sibling;\n\n\tif (handle == device->handle)\n\t\treturn AE_CTRL_TERMINATE;\n\n\tsibling = acpi_fetch_acpi_dev(handle);\n\tif (!sibling)\n\t\treturn AE_OK;\n\n\tif (!strcmp(acpi_device_name(sibling), ACPI_VIDEO_BUS_NAME))\n\t\t\treturn AE_ALREADY_EXISTS;\n\n\treturn AE_OK;\n}\n\nstatic void acpi_video_dev_register_backlight(struct acpi_video_device *device)\n{\n\tstruct backlight_properties props;\n\tstruct pci_dev *pdev;\n\tacpi_handle acpi_parent;\n\tstruct device *parent = NULL;\n\tint result;\n\tstatic int count;\n\tchar *name;\n\n\tresult = acpi_video_init_brightness(device);\n\tif (result)\n\t\treturn;\n\n\tname = kasprintf(GFP_KERNEL, \"acpi_video%d\", count);\n\tif (!name)\n\t\treturn;\n\tcount++;\n\n\tif (ACPI_SUCCESS(acpi_get_parent(device->dev->handle, &acpi_parent))) {\n\t\tpdev = acpi_get_pci_dev(acpi_parent);\n\t\tif (pdev) {\n\t\t\tparent = &pdev->dev;\n\t\t\tpci_dev_put(pdev);\n\t\t}\n\t}\n\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_FIRMWARE;\n\tprops.max_brightness =\n\t\tdevice->brightness->count - ACPI_VIDEO_FIRST_LEVEL - 1;\n\tdevice->backlight = backlight_device_register(name,\n\t\t\t\t\t\t      parent,\n\t\t\t\t\t\t      device,\n\t\t\t\t\t\t      &acpi_backlight_ops,\n\t\t\t\t\t\t      &props);\n\tkfree(name);\n\tif (IS_ERR(device->backlight)) {\n\t\tdevice->backlight = NULL;\n\t\treturn;\n\t}\n\n\t \n\tdevice->backlight->props.brightness =\n\t\t\tacpi_video_get_brightness(device->backlight);\n\n\tdevice->cooling_dev = thermal_cooling_device_register(\"LCD\", device,\n\t\t\t\t\t\t\t      &video_cooling_ops);\n\tif (IS_ERR(device->cooling_dev)) {\n\t\t \n\t\tdevice->cooling_dev = NULL;\n\t\treturn;\n\t}\n\n\tdev_info(&device->dev->dev, \"registered as cooling_device%d\\n\",\n\t\t device->cooling_dev->id);\n\tresult = sysfs_create_link(&device->dev->dev.kobj,\n\t\t\t&device->cooling_dev->device.kobj,\n\t\t\t\"thermal_cooling\");\n\tif (result)\n\t\tpr_info(\"sysfs link creation failed\\n\");\n\n\tresult = sysfs_create_link(&device->cooling_dev->device.kobj,\n\t\t\t&device->dev->dev.kobj, \"device\");\n\tif (result)\n\t\tpr_info(\"Reverse sysfs link creation failed\\n\");\n}\n\nstatic void acpi_video_run_bcl_for_osi(struct acpi_video_bus *video)\n{\n\tstruct acpi_video_device *dev;\n\tunion acpi_object *levels;\n\n\tmutex_lock(&video->device_list_lock);\n\tlist_for_each_entry(dev, &video->video_device_list, entry) {\n\t\tif (!acpi_video_device_lcd_query_levels(dev->dev->handle, &levels))\n\t\t\tkfree(levels);\n\t}\n\tmutex_unlock(&video->device_list_lock);\n}\n\nstatic bool acpi_video_should_register_backlight(struct acpi_video_device *dev)\n{\n\t \n\tif (!acpi_video_device_in_dod(dev)) {\n\t\tdev_dbg(&dev->dev->dev, \"not in _DOD list, ignore\\n\");\n\t\treturn false;\n\t}\n\n\tif (only_lcd)\n\t\treturn dev->flags.lcd;\n\treturn true;\n}\n\nstatic int acpi_video_bus_register_backlight(struct acpi_video_bus *video)\n{\n\tstruct acpi_video_device *dev;\n\n\tif (video->backlight_registered)\n\t\treturn 0;\n\n\tif (acpi_video_get_backlight_type() != acpi_backlight_video)\n\t\treturn 0;\n\n\tmutex_lock(&video->device_list_lock);\n\tlist_for_each_entry(dev, &video->video_device_list, entry) {\n\t\tif (acpi_video_should_register_backlight(dev))\n\t\t\tacpi_video_dev_register_backlight(dev);\n\t}\n\tmutex_unlock(&video->device_list_lock);\n\n\tvideo->backlight_registered = true;\n\n\tvideo->pm_nb.notifier_call = acpi_video_resume;\n\tvideo->pm_nb.priority = 0;\n\treturn register_pm_notifier(&video->pm_nb);\n}\n\nstatic void acpi_video_dev_unregister_backlight(struct acpi_video_device *device)\n{\n\tif (device->backlight) {\n\t\tbacklight_device_unregister(device->backlight);\n\t\tdevice->backlight = NULL;\n\t}\n\tif (device->brightness) {\n\t\tkfree(device->brightness->levels);\n\t\tkfree(device->brightness);\n\t\tdevice->brightness = NULL;\n\t}\n\tif (device->cooling_dev) {\n\t\tsysfs_remove_link(&device->dev->dev.kobj, \"thermal_cooling\");\n\t\tsysfs_remove_link(&device->cooling_dev->device.kobj, \"device\");\n\t\tthermal_cooling_device_unregister(device->cooling_dev);\n\t\tdevice->cooling_dev = NULL;\n\t}\n}\n\nstatic int acpi_video_bus_unregister_backlight(struct acpi_video_bus *video)\n{\n\tstruct acpi_video_device *dev;\n\tint error;\n\n\tif (!video->backlight_registered)\n\t\treturn 0;\n\n\terror = unregister_pm_notifier(&video->pm_nb);\n\n\tmutex_lock(&video->device_list_lock);\n\tlist_for_each_entry(dev, &video->video_device_list, entry)\n\t\tacpi_video_dev_unregister_backlight(dev);\n\tmutex_unlock(&video->device_list_lock);\n\n\tvideo->backlight_registered = false;\n\n\treturn error;\n}\n\nstatic void acpi_video_dev_add_notify_handler(struct acpi_video_device *device)\n{\n\tacpi_status status;\n\tstruct acpi_device *adev = device->dev;\n\n\tstatus = acpi_install_notify_handler(adev->handle, ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t     acpi_video_device_notify, device);\n\tif (ACPI_FAILURE(status))\n\t\tdev_err(&adev->dev, \"Error installing notify handler\\n\");\n\telse\n\t\tdevice->flags.notify = 1;\n}\n\nstatic int acpi_video_bus_add_notify_handler(struct acpi_video_bus *video)\n{\n\tstruct input_dev *input;\n\tstruct acpi_video_device *dev;\n\tint error;\n\n\tvideo->input = input = input_allocate_device();\n\tif (!input) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = acpi_video_bus_start_devices(video);\n\tif (error)\n\t\tgoto err_free_input;\n\n\tsnprintf(video->phys, sizeof(video->phys),\n\t\t\t\"%s/video/input0\", acpi_device_hid(video->device));\n\n\tinput->name = acpi_device_name(video->device);\n\tinput->phys = video->phys;\n\tinput->id.bustype = BUS_HOST;\n\tinput->id.product = 0x06;\n\tinput->dev.parent = &video->device->dev;\n\tinput->evbit[0] = BIT(EV_KEY);\n\tset_bit(KEY_SWITCHVIDEOMODE, input->keybit);\n\tset_bit(KEY_VIDEO_NEXT, input->keybit);\n\tset_bit(KEY_VIDEO_PREV, input->keybit);\n\tset_bit(KEY_BRIGHTNESS_CYCLE, input->keybit);\n\tset_bit(KEY_BRIGHTNESSUP, input->keybit);\n\tset_bit(KEY_BRIGHTNESSDOWN, input->keybit);\n\tset_bit(KEY_BRIGHTNESS_ZERO, input->keybit);\n\tset_bit(KEY_DISPLAY_OFF, input->keybit);\n\n\terror = input_register_device(input);\n\tif (error)\n\t\tgoto err_stop_dev;\n\n\tmutex_lock(&video->device_list_lock);\n\tlist_for_each_entry(dev, &video->video_device_list, entry)\n\t\tacpi_video_dev_add_notify_handler(dev);\n\tmutex_unlock(&video->device_list_lock);\n\n\treturn 0;\n\nerr_stop_dev:\n\tacpi_video_bus_stop_devices(video);\nerr_free_input:\n\tinput_free_device(input);\n\tvideo->input = NULL;\nout:\n\treturn error;\n}\n\nstatic void acpi_video_dev_remove_notify_handler(struct acpi_video_device *dev)\n{\n\tif (dev->flags.notify) {\n\t\tacpi_remove_notify_handler(dev->dev->handle, ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t   acpi_video_device_notify);\n\t\tdev->flags.notify = 0;\n\t}\n}\n\nstatic void acpi_video_bus_remove_notify_handler(struct acpi_video_bus *video)\n{\n\tstruct acpi_video_device *dev;\n\n\tmutex_lock(&video->device_list_lock);\n\tlist_for_each_entry(dev, &video->video_device_list, entry)\n\t\tacpi_video_dev_remove_notify_handler(dev);\n\tmutex_unlock(&video->device_list_lock);\n\n\tacpi_video_bus_stop_devices(video);\n\tinput_unregister_device(video->input);\n\tvideo->input = NULL;\n}\n\nstatic int acpi_video_bus_put_devices(struct acpi_video_bus *video)\n{\n\tstruct acpi_video_device *dev, *next;\n\n\tmutex_lock(&video->device_list_lock);\n\tlist_for_each_entry_safe(dev, next, &video->video_device_list, entry) {\n\t\tlist_del(&dev->entry);\n\t\tkfree(dev);\n\t}\n\tmutex_unlock(&video->device_list_lock);\n\n\treturn 0;\n}\n\nstatic int instance;\n\nstatic int acpi_video_bus_add(struct acpi_device *device)\n{\n\tstruct acpi_video_bus *video;\n\tbool auto_detect;\n\tint error;\n\tacpi_status status;\n\n\tstatus = acpi_walk_namespace(ACPI_TYPE_DEVICE,\n\t\t\t\tacpi_dev_parent(device)->handle, 1,\n\t\t\t\tacpi_video_bus_match, NULL,\n\t\t\t\tdevice, NULL);\n\tif (status == AE_ALREADY_EXISTS) {\n\t\tpr_info(FW_BUG\n\t\t\t\"Duplicate ACPI video bus devices for the\"\n\t\t\t\" same VGA controller, please try module \"\n\t\t\t\"parameter \\\"video.allow_duplicates=1\\\"\"\n\t\t\t\"if the current driver doesn't work.\\n\");\n\t\tif (!allow_duplicates)\n\t\t\treturn -ENODEV;\n\t}\n\n\tvideo = kzalloc(sizeof(struct acpi_video_bus), GFP_KERNEL);\n\tif (!video)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!strcmp(device->pnp.bus_id, \"VID\")) {\n\t\tif (instance)\n\t\t\tdevice->pnp.bus_id[3] = '0' + instance;\n\t\tinstance++;\n\t}\n\t \n\tif (!strcmp(device->pnp.bus_id, \"VGA\")) {\n\t\tif (instance)\n\t\t\tdevice->pnp.bus_id[3] = '0' + instance;\n\t\tinstance++;\n\t}\n\n\tvideo->device = device;\n\tstrcpy(acpi_device_name(device), ACPI_VIDEO_BUS_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_VIDEO_CLASS);\n\tdevice->driver_data = video;\n\n\tacpi_video_bus_find_cap(video);\n\terror = acpi_video_bus_check(video);\n\tif (error)\n\t\tgoto err_free_video;\n\n\tmutex_init(&video->device_list_lock);\n\tINIT_LIST_HEAD(&video->video_device_list);\n\n\terror = acpi_video_bus_get_devices(video, device);\n\tif (error)\n\t\tgoto err_put_video;\n\n\t \n\tacpi_device_fix_up_power_children(device);\n\n\tpr_info(\"%s [%s] (multi-head: %s  rom: %s  post: %s)\\n\",\n\t       ACPI_VIDEO_DEVICE_NAME, acpi_device_bid(device),\n\t       video->flags.multihead ? \"yes\" : \"no\",\n\t       video->flags.rom ? \"yes\" : \"no\",\n\t       video->flags.post ? \"yes\" : \"no\");\n\tmutex_lock(&video_list_lock);\n\tlist_add_tail(&video->entry, &video_bus_head);\n\tmutex_unlock(&video_list_lock);\n\n\t \n\tacpi_video_run_bcl_for_osi(video);\n\tif (__acpi_video_get_backlight_type(false, &auto_detect) == acpi_backlight_video &&\n\t    !auto_detect)\n\t\tacpi_video_bus_register_backlight(video);\n\n\terror = acpi_video_bus_add_notify_handler(video);\n\tif (error)\n\t\tgoto err_del;\n\n\terror = acpi_dev_install_notify_handler(device, ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t\tacpi_video_bus_notify);\n\tif (error)\n\t\tgoto err_remove;\n\n\treturn 0;\n\nerr_remove:\n\tacpi_video_bus_remove_notify_handler(video);\nerr_del:\n\tmutex_lock(&video_list_lock);\n\tlist_del(&video->entry);\n\tmutex_unlock(&video_list_lock);\n\tacpi_video_bus_unregister_backlight(video);\nerr_put_video:\n\tacpi_video_bus_put_devices(video);\n\tkfree(video->attached_array);\nerr_free_video:\n\tkfree(video);\n\tdevice->driver_data = NULL;\n\n\treturn error;\n}\n\nstatic void acpi_video_bus_remove(struct acpi_device *device)\n{\n\tstruct acpi_video_bus *video = NULL;\n\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn;\n\n\tvideo = acpi_driver_data(device);\n\n\tacpi_dev_remove_notify_handler(device, ACPI_DEVICE_NOTIFY,\n\t\t\t\t       acpi_video_bus_notify);\n\n\tmutex_lock(&video_list_lock);\n\tlist_del(&video->entry);\n\tmutex_unlock(&video_list_lock);\n\n\tacpi_video_bus_remove_notify_handler(video);\n\tacpi_video_bus_unregister_backlight(video);\n\tacpi_video_bus_put_devices(video);\n\n\tkfree(video->attached_array);\n\tkfree(video);\n}\n\nstatic int __init is_i740(struct pci_dev *dev)\n{\n\tif (dev->device == 0x00D1)\n\t\treturn 1;\n\tif (dev->device == 0x7000)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int __init intel_opregion_present(void)\n{\n\tint opregion = 0;\n\tstruct pci_dev *dev = NULL;\n\tu32 address;\n\n\tfor_each_pci_dev(dev) {\n\t\tif ((dev->class >> 8) != PCI_CLASS_DISPLAY_VGA)\n\t\t\tcontinue;\n\t\tif (dev->vendor != PCI_VENDOR_ID_INTEL)\n\t\t\tcontinue;\n\t\t \n\t\tif (is_i740(dev))\n\t\t\tcontinue;\n\t\tpci_read_config_dword(dev, 0xfc, &address);\n\t\tif (!address)\n\t\t\tcontinue;\n\t\topregion = 1;\n\t}\n\treturn opregion;\n}\n\n \nstatic bool dmi_is_desktop(void)\n{\n\tconst char *chassis_type;\n\tunsigned long type;\n\n\tchassis_type = dmi_get_system_info(DMI_CHASSIS_TYPE);\n\tif (!chassis_type)\n\t\treturn false;\n\n\tif (kstrtoul(chassis_type, 10, &type) != 0)\n\t\treturn false;\n\n\tswitch (type) {\n\tcase 0x03:  \n\tcase 0x04:  \n\tcase 0x05:  \n\tcase 0x06:  \n\tcase 0x07:  \n\tcase 0x10:  \n\tcase 0x11:  \n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool should_check_lcd_flag(void)\n{\n\tif (!acpi_osi_is_win8())\n\t\treturn false;\n\n\tif (dmi_is_desktop())\n\t\treturn true;\n\n\tif (acpi_reduced_hardware())\n\t\treturn true;\n\n\treturn false;\n}\n\nint acpi_video_register(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&register_count_mutex);\n\tif (register_count) {\n\t\t \n\t\tgoto leave;\n\t}\n\n\tif (only_lcd == -1)\n\t\tonly_lcd = should_check_lcd_flag();\n\n\tdmi_check_system(video_dmi_table);\n\n\tret = acpi_bus_register_driver(&acpi_video_bus);\n\tif (ret)\n\t\tgoto leave;\n\n\t \n\tregister_count = 1;\n\nleave:\n\tmutex_unlock(&register_count_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(acpi_video_register);\n\nvoid acpi_video_unregister(void)\n{\n\tmutex_lock(&register_count_mutex);\n\tif (register_count) {\n\t\tacpi_bus_unregister_driver(&acpi_video_bus);\n\t\tregister_count = 0;\n\t\tmay_report_brightness_keys = false;\n\t}\n\tmutex_unlock(&register_count_mutex);\n}\nEXPORT_SYMBOL(acpi_video_unregister);\n\nvoid acpi_video_register_backlight(void)\n{\n\tstruct acpi_video_bus *video;\n\n\tmutex_lock(&video_list_lock);\n\tlist_for_each_entry(video, &video_bus_head, entry)\n\t\tacpi_video_bus_register_backlight(video);\n\tmutex_unlock(&video_list_lock);\n}\nEXPORT_SYMBOL(acpi_video_register_backlight);\n\nbool acpi_video_handles_brightness_key_presses(void)\n{\n\treturn may_report_brightness_keys &&\n\t       (report_key_events & REPORT_BRIGHTNESS_KEY_EVENTS);\n}\nEXPORT_SYMBOL(acpi_video_handles_brightness_key_presses);\n\n \n\nstatic int __init acpi_video_init(void)\n{\n\t \n\tif (acpi_disabled)\n\t\treturn 0;\n\n\tif (intel_opregion_present())\n\t\treturn 0;\n\n\treturn acpi_video_register();\n}\n\nstatic void __exit acpi_video_exit(void)\n{\n\tacpi_video_unregister();\n}\n\nmodule_init(acpi_video_init);\nmodule_exit(acpi_video_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}