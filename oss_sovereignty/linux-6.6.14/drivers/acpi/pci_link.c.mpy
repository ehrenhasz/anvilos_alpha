{
  "module_name": "pci_link.c",
  "hash_id": "fc81f731af18f9c0ee65d10355c6743ab4d15efbb5c193352ecf9ab1a725bbc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pci_link.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: PCI: \" fmt\n\n#include <linux/syscore_ops.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/pm.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/irq.h>\n\n#include \"internal.h\"\n\n#define ACPI_PCI_LINK_CLASS\t\t\"pci_irq_routing\"\n#define ACPI_PCI_LINK_DEVICE_NAME\t\"PCI Interrupt Link\"\n#define ACPI_PCI_LINK_MAX_POSSIBLE\t16\n\nstatic int acpi_pci_link_add(struct acpi_device *device,\n\t\t\t     const struct acpi_device_id *not_used);\nstatic void acpi_pci_link_remove(struct acpi_device *device);\n\nstatic const struct acpi_device_id link_device_ids[] = {\n\t{\"PNP0C0F\", 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_scan_handler pci_link_handler = {\n\t.ids = link_device_ids,\n\t.attach = acpi_pci_link_add,\n\t.detach = acpi_pci_link_remove,\n};\n\n \nstruct acpi_pci_link_irq {\n\tu32 active;\t\t \n\tu8 triggering;\t\t \n\tu8 polarity;\t\t \n\tu8 resource_type;\n\tu8 possible_count;\n\tu32 possible[ACPI_PCI_LINK_MAX_POSSIBLE];\n\tu8 initialized:1;\n\tu8 reserved:7;\n};\n\nstruct acpi_pci_link {\n\tstruct list_head\t\tlist;\n\tstruct acpi_device\t\t*device;\n\tstruct acpi_pci_link_irq\tirq;\n\tint\t\t\t\trefcnt;\n};\n\nstatic LIST_HEAD(acpi_link_list);\nstatic DEFINE_MUTEX(acpi_link_lock);\nstatic int sci_irq = -1, sci_penalty;\n\n \n\n \nstatic acpi_status acpi_pci_link_check_possible(struct acpi_resource *resource,\n\t\t\t\t\t\tvoid *context)\n{\n\tstruct acpi_pci_link *link = context;\n\tacpi_handle handle = link->device->handle;\n\tu32 i;\n\n\tswitch (resource->type) {\n\tcase ACPI_RESOURCE_TYPE_START_DEPENDENT:\n\tcase ACPI_RESOURCE_TYPE_END_TAG:\n\t\treturn AE_OK;\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\t{\n\t\t\tstruct acpi_resource_irq *p = &resource->data.irq;\n\t\t\tif (!p->interrupt_count) {\n\t\t\t\tacpi_handle_debug(handle,\n\t\t\t\t\t\t  \"Blank _PRS IRQ resource\\n\");\n\t\t\t\treturn AE_OK;\n\t\t\t}\n\t\t\tfor (i = 0;\n\t\t\t     (i < p->interrupt_count\n\t\t\t      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {\n\t\t\t\tif (!p->interrupts[i]) {\n\t\t\t\t\tacpi_handle_debug(handle,\n\t\t\t\t\t\t\t  \"Invalid _PRS IRQ %d\\n\",\n\t\t\t\t\t\t\t  p->interrupts[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlink->irq.possible[i] = p->interrupts[i];\n\t\t\t\tlink->irq.possible_count++;\n\t\t\t}\n\t\t\tlink->irq.triggering = p->triggering;\n\t\t\tlink->irq.polarity = p->polarity;\n\t\t\tlink->irq.resource_type = ACPI_RESOURCE_TYPE_IRQ;\n\t\t\tbreak;\n\t\t}\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\t{\n\t\t\tstruct acpi_resource_extended_irq *p =\n\t\t\t    &resource->data.extended_irq;\n\t\t\tif (!p->interrupt_count) {\n\t\t\t\tacpi_handle_debug(handle,\n\t\t\t\t\t\t  \"Blank _PRS EXT IRQ resource\\n\");\n\t\t\t\treturn AE_OK;\n\t\t\t}\n\t\t\tfor (i = 0;\n\t\t\t     (i < p->interrupt_count\n\t\t\t      && i < ACPI_PCI_LINK_MAX_POSSIBLE); i++) {\n\t\t\t\tif (!p->interrupts[i]) {\n\t\t\t\t\tacpi_handle_debug(handle,\n\t\t\t\t\t\t\t  \"Invalid _PRS IRQ %d\\n\",\n\t\t\t\t\t\t\t  p->interrupts[i]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlink->irq.possible[i] = p->interrupts[i];\n\t\t\t\tlink->irq.possible_count++;\n\t\t\t}\n\t\t\tlink->irq.triggering = p->triggering;\n\t\t\tlink->irq.polarity = p->polarity;\n\t\t\tlink->irq.resource_type = ACPI_RESOURCE_TYPE_EXTENDED_IRQ;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tacpi_handle_debug(handle, \"_PRS resource type 0x%x is not IRQ\\n\",\n\t\t\t\t  resource->type);\n\t\treturn AE_OK;\n\t}\n\n\treturn AE_CTRL_TERMINATE;\n}\n\nstatic int acpi_pci_link_get_possible(struct acpi_pci_link *link)\n{\n\tacpi_handle handle = link->device->handle;\n\tacpi_status status;\n\n\tstatus = acpi_walk_resources(handle, METHOD_NAME__PRS,\n\t\t\t\t     acpi_pci_link_check_possible, link);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_debug(handle, \"_PRS not present or invalid\");\n\t\treturn 0;\n\t}\n\n\tacpi_handle_debug(handle, \"Found %d possible IRQs\\n\",\n\t\t\t  link->irq.possible_count);\n\n\treturn 0;\n}\n\nstatic acpi_status acpi_pci_link_check_current(struct acpi_resource *resource,\n\t\t\t\t\t       void *context)\n{\n\tint *irq = context;\n\n\tswitch (resource->type) {\n\tcase ACPI_RESOURCE_TYPE_START_DEPENDENT:\n\tcase ACPI_RESOURCE_TYPE_END_TAG:\n\t\treturn AE_OK;\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\t{\n\t\t\tstruct acpi_resource_irq *p = &resource->data.irq;\n\t\t\tif (!p->interrupt_count) {\n\t\t\t\t \n\t\t\t\tpr_debug(\"Blank _CRS IRQ resource\\n\");\n\t\t\t\treturn AE_OK;\n\t\t\t}\n\t\t\t*irq = p->interrupts[0];\n\t\t\tbreak;\n\t\t}\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\t{\n\t\t\tstruct acpi_resource_extended_irq *p =\n\t\t\t    &resource->data.extended_irq;\n\t\t\tif (!p->interrupt_count) {\n\t\t\t\t \n\t\t\t\tpr_debug(\"Blank _CRS EXT IRQ resource\\n\");\n\t\t\t\treturn AE_OK;\n\t\t\t}\n\t\t\t*irq = p->interrupts[0];\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"_CRS resource type 0x%x is not IRQ\\n\",\n\t\t\t resource->type);\n\t\treturn AE_OK;\n\t}\n\n\treturn AE_CTRL_TERMINATE;\n}\n\n \nstatic int acpi_pci_link_get_current(struct acpi_pci_link *link)\n{\n\tacpi_handle handle = link->device->handle;\n\tacpi_status status;\n\tint result = 0;\n\tint irq = 0;\n\n\tlink->irq.active = 0;\n\n\t \n\tif (acpi_strict) {\n\t\t \n\t\tresult = acpi_bus_get_status(link->device);\n\t\tif (result) {\n\t\t\tacpi_handle_err(handle, \"Unable to read status\\n\");\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (!link->device->status.enabled) {\n\t\t\tacpi_handle_debug(handle, \"Link disabled\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\n\tstatus = acpi_walk_resources(handle, METHOD_NAME__CRS,\n\t\t\t\t     acpi_pci_link_check_current, &irq);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(handle, \"_CRS\", status);\n\t\tresult = -ENODEV;\n\t\tgoto end;\n\t}\n\n\tif (acpi_strict && !irq) {\n\t\tacpi_handle_err(handle, \"_CRS returned 0\\n\");\n\t\tresult = -ENODEV;\n\t}\n\n\tlink->irq.active = irq;\n\n\tacpi_handle_debug(handle, \"Link at IRQ %d \\n\", link->irq.active);\n\n      end:\n\treturn result;\n}\n\nstatic int acpi_pci_link_set(struct acpi_pci_link *link, int irq)\n{\n\tstruct {\n\t\tstruct acpi_resource res;\n\t\tstruct acpi_resource end;\n\t} *resource;\n\tstruct acpi_buffer buffer = { 0, NULL };\n\tacpi_handle handle = link->device->handle;\n\tacpi_status status;\n\tint result;\n\n\tif (!irq)\n\t\treturn -EINVAL;\n\n\tresource = kzalloc(sizeof(*resource) + 1, irqs_disabled() ? GFP_ATOMIC: GFP_KERNEL);\n\tif (!resource)\n\t\treturn -ENOMEM;\n\n\tbuffer.length = sizeof(*resource) + 1;\n\tbuffer.pointer = resource;\n\n\tswitch (link->irq.resource_type) {\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\tresource->res.type = ACPI_RESOURCE_TYPE_IRQ;\n\t\tresource->res.length = sizeof(struct acpi_resource);\n\t\tresource->res.data.irq.triggering = link->irq.triggering;\n\t\tresource->res.data.irq.polarity =\n\t\t    link->irq.polarity;\n\t\tif (link->irq.triggering == ACPI_EDGE_SENSITIVE)\n\t\t\tresource->res.data.irq.shareable =\n\t\t\t    ACPI_EXCLUSIVE;\n\t\telse\n\t\t\tresource->res.data.irq.shareable = ACPI_SHARED;\n\t\tresource->res.data.irq.interrupt_count = 1;\n\t\tresource->res.data.irq.interrupts[0] = irq;\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\tresource->res.type = ACPI_RESOURCE_TYPE_EXTENDED_IRQ;\n\t\tresource->res.length = sizeof(struct acpi_resource);\n\t\tresource->res.data.extended_irq.producer_consumer =\n\t\t    ACPI_CONSUMER;\n\t\tresource->res.data.extended_irq.triggering =\n\t\t    link->irq.triggering;\n\t\tresource->res.data.extended_irq.polarity =\n\t\t    link->irq.polarity;\n\t\tif (link->irq.triggering == ACPI_EDGE_SENSITIVE)\n\t\t\tresource->res.data.extended_irq.shareable =\n\t\t\t    ACPI_EXCLUSIVE;\n\t\telse\n\t\t\tresource->res.data.extended_irq.shareable = ACPI_SHARED;\n\t\tresource->res.data.extended_irq.interrupt_count = 1;\n\t\tresource->res.data.extended_irq.interrupts[0] = irq;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tacpi_handle_err(handle, \"Invalid resource type %d\\n\",\n\t\t\t\tlink->irq.resource_type);\n\t\tresult = -EINVAL;\n\t\tgoto end;\n\n\t}\n\tresource->end.type = ACPI_RESOURCE_TYPE_END_TAG;\n\tresource->end.length = sizeof(struct acpi_resource);\n\n\t \n\tstatus = acpi_set_current_resources(link->device->handle, &buffer);\n\n\t \n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_evaluation_failure_warn(handle, \"_SRS\", status);\n\t\tresult = -ENODEV;\n\t\tgoto end;\n\t}\n\n\t \n\tresult = acpi_bus_get_status(link->device);\n\tif (result) {\n\t\tacpi_handle_err(handle, \"Unable to read status\\n\");\n\t\tgoto end;\n\t}\n\tif (!link->device->status.enabled)\n\t\tacpi_handle_warn(handle, \"Disabled and referenced, BIOS bug\\n\");\n\n\t \n\tresult = acpi_pci_link_get_current(link);\n\tif (result) {\n\t\tgoto end;\n\t}\n\n\t \n\tif (link->irq.active != irq) {\n\t\t \n\t\tacpi_handle_warn(handle, \"BIOS reported IRQ %d, using IRQ %d\\n\",\n\t\t\t\t link->irq.active, irq);\n\t\tlink->irq.active = irq;\n\t}\n\n\tacpi_handle_debug(handle, \"Set IRQ %d\\n\", link->irq.active);\n\n      end:\n\tkfree(resource);\n\treturn result;\n}\n\n \n\n \n\n#define ACPI_MAX_ISA_IRQS\t16\n\n#define PIRQ_PENALTY_PCI_POSSIBLE\t(16*16)\n#define PIRQ_PENALTY_PCI_USING\t\t(16*16*16)\n#define PIRQ_PENALTY_ISA_TYPICAL\t(16*16*16*16)\n#define PIRQ_PENALTY_ISA_USED\t\t(16*16*16*16*16)\n#define PIRQ_PENALTY_ISA_ALWAYS\t\t(16*16*16*16*16*16)\n\nstatic int acpi_isa_irq_penalty[ACPI_MAX_ISA_IRQS] = {\n\tPIRQ_PENALTY_ISA_ALWAYS,\t \n\tPIRQ_PENALTY_ISA_ALWAYS,\t \n\tPIRQ_PENALTY_ISA_ALWAYS,\t \n\tPIRQ_PENALTY_ISA_TYPICAL,\t \n\tPIRQ_PENALTY_ISA_TYPICAL,\t \n\tPIRQ_PENALTY_ISA_TYPICAL,\t \n\tPIRQ_PENALTY_ISA_TYPICAL,\t \n\tPIRQ_PENALTY_ISA_TYPICAL,\t \n\tPIRQ_PENALTY_ISA_TYPICAL,\t \n\t0,\t\t\t\t \n\t0,\t\t\t\t \n\t0,\t\t\t\t \n\tPIRQ_PENALTY_ISA_USED,\t\t \n\tPIRQ_PENALTY_ISA_USED,\t\t \n\tPIRQ_PENALTY_ISA_USED,\t\t \n\tPIRQ_PENALTY_ISA_USED,\t\t \n\t \n};\n\nstatic int acpi_irq_pci_sharing_penalty(int irq)\n{\n\tstruct acpi_pci_link *link;\n\tint penalty = 0;\n\tint i;\n\n\tlist_for_each_entry(link, &acpi_link_list, list) {\n\t\t \n\t\tif (link->irq.active && link->irq.active == irq)\n\t\t\tpenalty += PIRQ_PENALTY_PCI_USING;\n\n\t\t \n\t\tfor (i = 0; i < link->irq.possible_count; i++)\n\t\t\tif (link->irq.possible[i] == irq)\n\t\t\t\tpenalty += PIRQ_PENALTY_PCI_POSSIBLE /\n\t\t\t\t\tlink->irq.possible_count;\n\t}\n\n\treturn penalty;\n}\n\nstatic int acpi_irq_get_penalty(int irq)\n{\n\tint penalty = 0;\n\n\tif (irq == sci_irq)\n\t\tpenalty += sci_penalty;\n\n\tif (irq < ACPI_MAX_ISA_IRQS)\n\t\treturn penalty + acpi_isa_irq_penalty[irq];\n\n\treturn penalty + acpi_irq_pci_sharing_penalty(irq);\n}\n\nint __init acpi_irq_penalty_init(void)\n{\n\tstruct acpi_pci_link *link;\n\tint i;\n\n\t \n\tlist_for_each_entry(link, &acpi_link_list, list) {\n\n\t\t \n\t\tif (link->irq.possible_count) {\n\t\t\tint penalty =\n\t\t\t    PIRQ_PENALTY_PCI_POSSIBLE /\n\t\t\t    link->irq.possible_count;\n\n\t\t\tfor (i = 0; i < link->irq.possible_count; i++) {\n\t\t\t\tif (link->irq.possible[i] < ACPI_MAX_ISA_IRQS)\n\t\t\t\t\tacpi_isa_irq_penalty[link->irq.\n\t\t\t\t\t\t\t possible[i]] +=\n\t\t\t\t\t    penalty;\n\t\t\t}\n\n\t\t} else if (link->irq.active &&\n\t\t\t\t(link->irq.active < ACPI_MAX_ISA_IRQS)) {\n\t\t\tacpi_isa_irq_penalty[link->irq.active] +=\n\t\t\t    PIRQ_PENALTY_PCI_POSSIBLE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int acpi_irq_balance = -1;\t \n\nstatic int acpi_pci_link_allocate(struct acpi_pci_link *link)\n{\n\tacpi_handle handle = link->device->handle;\n\tint irq;\n\tint i;\n\n\tif (link->irq.initialized) {\n\t\tif (link->refcnt == 0)\n\t\t\t \n\t\t\tacpi_pci_link_set(link, link->irq.active);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < link->irq.possible_count; ++i) {\n\t\tif (link->irq.active == link->irq.possible[i])\n\t\t\tbreak;\n\t}\n\t \n\tif (i == link->irq.possible_count) {\n\t\tif (acpi_strict)\n\t\t\tacpi_handle_warn(handle, \"_CRS %d not found in _PRS\\n\",\n\t\t\t\t\t link->irq.active);\n\t\tlink->irq.active = 0;\n\t}\n\n\t \n\tif (link->irq.active)\n\t\tirq = link->irq.active;\n\telse\n\t\tirq = link->irq.possible[link->irq.possible_count - 1];\n\n\tif (acpi_irq_balance || !link->irq.active) {\n\t\t \n\t\tfor (i = (link->irq.possible_count - 1); i >= 0; i--) {\n\t\t\tif (acpi_irq_get_penalty(irq) >\n\t\t\t    acpi_irq_get_penalty(link->irq.possible[i]))\n\t\t\t\tirq = link->irq.possible[i];\n\t\t}\n\t}\n\tif (acpi_irq_get_penalty(irq) >= PIRQ_PENALTY_ISA_ALWAYS) {\n\t\tacpi_handle_err(handle,\n\t\t\t\t\"No IRQ available. Try pci=noacpi or acpi=off\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (acpi_pci_link_set(link, irq)) {\n\t\tacpi_handle_err(handle,\n\t\t\t\t\"Unable to set IRQ. Try pci=noacpi or acpi=off\\n\");\n\t\treturn -ENODEV;\n\t} else {\n\t\tif (link->irq.active < ACPI_MAX_ISA_IRQS)\n\t\t\tacpi_isa_irq_penalty[link->irq.active] +=\n\t\t\t\tPIRQ_PENALTY_PCI_USING;\n\n\t\tacpi_handle_info(handle, \"Enabled at IRQ %d\\n\",\n\t\t\t\t link->irq.active);\n\t}\n\n\tlink->irq.initialized = 1;\n\treturn 0;\n}\n\n \nint acpi_pci_link_allocate_irq(acpi_handle handle, int index, int *triggering,\n\t\t\t       int *polarity, char **name)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\tstruct acpi_pci_link *link;\n\n\tif (!device) {\n\t\tacpi_handle_err(handle, \"Invalid link device\\n\");\n\t\treturn -1;\n\t}\n\n\tlink = acpi_driver_data(device);\n\tif (!link) {\n\t\tacpi_handle_err(handle, \"Invalid link context\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tif (index) {\n\t\tacpi_handle_err(handle, \"Invalid index %d\\n\", index);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&acpi_link_lock);\n\tif (acpi_pci_link_allocate(link)) {\n\t\tmutex_unlock(&acpi_link_lock);\n\t\treturn -1;\n\t}\n\n\tif (!link->irq.active) {\n\t\tmutex_unlock(&acpi_link_lock);\n\t\tacpi_handle_err(handle, \"Link active IRQ is 0!\\n\");\n\t\treturn -1;\n\t}\n\tlink->refcnt++;\n\tmutex_unlock(&acpi_link_lock);\n\n\tif (triggering)\n\t\t*triggering = link->irq.triggering;\n\tif (polarity)\n\t\t*polarity = link->irq.polarity;\n\tif (name)\n\t\t*name = acpi_device_bid(link->device);\n\tacpi_handle_debug(handle, \"Link is referenced\\n\");\n\treturn link->irq.active;\n}\n\n \nint acpi_pci_link_free_irq(acpi_handle handle)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\tstruct acpi_pci_link *link;\n\n\tif (!device) {\n\t\tacpi_handle_err(handle, \"Invalid link device\\n\");\n\t\treturn -1;\n\t}\n\n\tlink = acpi_driver_data(device);\n\tif (!link) {\n\t\tacpi_handle_err(handle, \"Invalid link context\\n\");\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&acpi_link_lock);\n\tif (!link->irq.initialized) {\n\t\tmutex_unlock(&acpi_link_lock);\n\t\tacpi_handle_err(handle, \"Link isn't initialized\\n\");\n\t\treturn -1;\n\t}\n#ifdef\tFUTURE_USE\n\t \n\tlink->refcnt--;\n#endif\n\tacpi_handle_debug(handle, \"Link is dereferenced\\n\");\n\n\tif (link->refcnt == 0)\n\t\tacpi_evaluate_object(link->device->handle, \"_DIS\", NULL, NULL);\n\n\tmutex_unlock(&acpi_link_lock);\n\treturn link->irq.active;\n}\n\n \n\nstatic int acpi_pci_link_add(struct acpi_device *device,\n\t\t\t     const struct acpi_device_id *not_used)\n{\n\tacpi_handle handle = device->handle;\n\tstruct acpi_pci_link *link;\n\tint result;\n\tint i;\n\n\tlink = kzalloc(sizeof(struct acpi_pci_link), GFP_KERNEL);\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tlink->device = device;\n\tstrcpy(acpi_device_name(device), ACPI_PCI_LINK_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_PCI_LINK_CLASS);\n\tdevice->driver_data = link;\n\n\tmutex_lock(&acpi_link_lock);\n\tresult = acpi_pci_link_get_possible(link);\n\tif (result)\n\t\tgoto end;\n\n\t \n\tacpi_pci_link_get_current(link);\n\n\tpr_info(\"Interrupt link %s configured for IRQ %d\\n\",\n\t\tacpi_device_bid(device), link->irq.active);\n\n\tfor (i = 0; i < link->irq.possible_count; i++) {\n\t\tif (link->irq.active != link->irq.possible[i])\n\t\t\tacpi_handle_debug(handle, \"Possible IRQ %d\\n\",\n\t\t\t\t\t  link->irq.possible[i]);\n\t}\n\n\tif (!link->device->status.enabled)\n\t\tpr_info(\"Interrupt link %s disabled\\n\", acpi_device_bid(device));\n\n\tlist_add_tail(&link->list, &acpi_link_list);\n\n      end:\n\t \n\tacpi_evaluate_object(handle, \"_DIS\", NULL, NULL);\n\tmutex_unlock(&acpi_link_lock);\n\n\tif (result)\n\t\tkfree(link);\n\n\treturn result < 0 ? result : 1;\n}\n\nstatic int acpi_pci_link_resume(struct acpi_pci_link *link)\n{\n\tif (link->refcnt && link->irq.active && link->irq.initialized)\n\t\treturn (acpi_pci_link_set(link, link->irq.active));\n\n\treturn 0;\n}\n\nstatic void irqrouter_resume(void)\n{\n\tstruct acpi_pci_link *link;\n\n\tlist_for_each_entry(link, &acpi_link_list, list) {\n\t\tacpi_pci_link_resume(link);\n\t}\n}\n\nstatic void acpi_pci_link_remove(struct acpi_device *device)\n{\n\tstruct acpi_pci_link *link;\n\n\tlink = acpi_driver_data(device);\n\n\tmutex_lock(&acpi_link_lock);\n\tlist_del(&link->list);\n\tmutex_unlock(&acpi_link_lock);\n\n\tkfree(link);\n}\n\n \nstatic int __init acpi_irq_penalty_update(char *str, int used)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tint retval;\n\t\tint irq;\n\t\tint new_penalty;\n\n\t\tretval = get_option(&str, &irq);\n\n\t\tif (!retval)\n\t\t\tbreak;\t \n\n\t\t \n\t\tif ((irq < 0) || (irq >= ACPI_MAX_ISA_IRQS))\n\t\t\tcontinue;\n\n\t\tif (used)\n\t\t\tnew_penalty = acpi_isa_irq_penalty[irq] +\n\t\t\t\t\tPIRQ_PENALTY_ISA_USED;\n\t\telse\n\t\t\tnew_penalty = 0;\n\n\t\tacpi_isa_irq_penalty[irq] = new_penalty;\n\t\tif (retval != 2)\t \n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n\n \nvoid acpi_penalize_isa_irq(int irq, int active)\n{\n\tif ((irq >= 0) && (irq < ARRAY_SIZE(acpi_isa_irq_penalty)))\n\t\tacpi_isa_irq_penalty[irq] +=\n\t\t  (active ? PIRQ_PENALTY_ISA_USED : PIRQ_PENALTY_PCI_USING);\n}\n\nbool acpi_isa_irq_available(int irq)\n{\n\treturn irq >= 0 && (irq >= ARRAY_SIZE(acpi_isa_irq_penalty) ||\n\t\t    acpi_irq_get_penalty(irq) < PIRQ_PENALTY_ISA_ALWAYS);\n}\n\nvoid acpi_penalize_sci_irq(int irq, int trigger, int polarity)\n{\n\tsci_irq = irq;\n\n\tif (trigger == ACPI_MADT_TRIGGER_LEVEL &&\n\t    polarity == ACPI_MADT_POLARITY_ACTIVE_LOW)\n\t\tsci_penalty = PIRQ_PENALTY_PCI_USING;\n\telse\n\t\tsci_penalty = PIRQ_PENALTY_ISA_ALWAYS;\n}\n\n \nstatic int __init acpi_irq_isa(char *str)\n{\n\treturn acpi_irq_penalty_update(str, 1);\n}\n\n__setup(\"acpi_irq_isa=\", acpi_irq_isa);\n\n \nstatic int __init acpi_irq_pci(char *str)\n{\n\treturn acpi_irq_penalty_update(str, 0);\n}\n\n__setup(\"acpi_irq_pci=\", acpi_irq_pci);\n\nstatic int __init acpi_irq_nobalance_set(char *str)\n{\n\tacpi_irq_balance = 0;\n\treturn 1;\n}\n\n__setup(\"acpi_irq_nobalance\", acpi_irq_nobalance_set);\n\nstatic int __init acpi_irq_balance_set(char *str)\n{\n\tacpi_irq_balance = 1;\n\treturn 1;\n}\n\n__setup(\"acpi_irq_balance\", acpi_irq_balance_set);\n\nstatic struct syscore_ops irqrouter_syscore_ops = {\n\t.resume = irqrouter_resume,\n};\n\nvoid __init acpi_pci_link_init(void)\n{\n\tif (acpi_noirq)\n\t\treturn;\n\n\tif (acpi_irq_balance == -1) {\n\t\t \n\t\tif (acpi_irq_model == ACPI_IRQ_MODEL_IOAPIC)\n\t\t\tacpi_irq_balance = 1;\n\t\telse\n\t\t\tacpi_irq_balance = 0;\n\t}\n\tregister_syscore_ops(&irqrouter_syscore_ops);\n\tacpi_scan_add_handler(&pci_link_handler);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}