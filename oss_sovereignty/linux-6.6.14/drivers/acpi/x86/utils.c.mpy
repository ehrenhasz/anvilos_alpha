{
  "module_name": "utils.c",
  "hash_id": "584937db27834cab30779540c50b6297fd5980b95a0bd1a1f42e6dfa01d88a14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/x86/utils.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/platform_device.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include \"../internal.h\"\n\n \nstruct override_status_id {\n\tstruct acpi_device_id hid[2];\n\tstruct x86_cpu_id cpu_ids[2];\n\tstruct dmi_system_id dmi_ids[2];  \n\tconst char *uid;\n\tconst char *path;\n\tunsigned long long status;\n};\n\n#define ENTRY(status, hid, uid, path, cpu_model, dmi...) {\t\t\\\n\t{ { hid, }, {} },\t\t\t\t\t\t\\\n\t{ X86_MATCH_INTEL_FAM6_MODEL(cpu_model, NULL), {} },\t\t\\\n\t{ { .matches = dmi }, {} },\t\t\t\t\t\\\n\tuid,\t\t\t\t\t\t\t\t\\\n\tpath,\t\t\t\t\t\t\t\t\\\n\tstatus,\t\t\t\t\t\t\t\t\\\n}\n\n#define PRESENT_ENTRY_HID(hid, uid, cpu_model, dmi...) \\\n\tENTRY(ACPI_STA_DEFAULT, hid, uid, NULL, cpu_model, dmi)\n\n#define NOT_PRESENT_ENTRY_HID(hid, uid, cpu_model, dmi...) \\\n\tENTRY(0, hid, uid, NULL, cpu_model, dmi)\n\n#define PRESENT_ENTRY_PATH(path, cpu_model, dmi...) \\\n\tENTRY(ACPI_STA_DEFAULT, \"\", NULL, path, cpu_model, dmi)\n\n#define NOT_PRESENT_ENTRY_PATH(path, cpu_model, dmi...) \\\n\tENTRY(0, \"\", NULL, path, cpu_model, dmi)\n\nstatic const struct override_status_id override_status_ids[] = {\n\t \n\tPRESENT_ENTRY_HID(\"80860F09\", \"1\", ATOM_SILVERMONT, {}),\n\tPRESENT_ENTRY_HID(\"80862288\", \"1\", ATOM_AIRMONT, {}),\n\n\t \n\tPRESENT_ENTRY_HID(\"80862289\", \"2\", ATOM_AIRMONT, {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Xiaomi Inc\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Mipad2\"),\n\t      }),\n\n\t \n\tPRESENT_ENTRY_HID(\"INT0002\", \"1\", ATOM_AIRMONT, {}),\n\t \n\tPRESENT_ENTRY_HID(\"SYNA7500\", \"1\", HASWELL_L, {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Venue 11 Pro 7130\"),\n\t      }),\n\tPRESENT_ENTRY_HID(\"SYNA7500\", \"1\", HASWELL_L, {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Venue 11 Pro 7139\"),\n\t      }),\n\n\t \n\tPRESENT_ENTRY_HID(\"KIOX000A\", \"1\", ATOM_AIRMONT, {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"Default string\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Default string\"),\n\t\tDMI_MATCH(DMI_BIOS_DATE, \"02/21/2017\")\n\t      }),\n\tPRESENT_ENTRY_HID(\"KIOX000A\", \"1\", ATOM_AIRMONT, {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"Default string\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Default string\"),\n\t\tDMI_MATCH(DMI_BIOS_DATE, \"03/20/2017\")\n\t      }),\n\tPRESENT_ENTRY_HID(\"KIOX000A\", \"1\", ATOM_AIRMONT, {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"Default string\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Default string\"),\n\t\tDMI_MATCH(DMI_BIOS_DATE, \"05/25/2017\")\n\t      }),\n\n\t \n\tNOT_PRESENT_ENTRY_PATH(\"\\\\_SB_.PCI0.SDHB.BRC1\", ATOM_AIRMONT, {\n\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Default string\"),\n\t\tDMI_EXACT_MATCH(DMI_BOARD_SERIAL, \"Default string\"),\n\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"Default string\"),\n\t      }),\n\n\t \n\tNOT_PRESENT_ENTRY_HID(\"MAGN0001\", \"1\", ATOM_SILVERMONT, {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"YOGATablet2\"),\n\t      }),\n};\n\nbool acpi_device_override_status(struct acpi_device *adev, unsigned long long *status)\n{\n\tbool ret = false;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(override_status_ids); i++) {\n\t\tif (!x86_match_cpu(override_status_ids[i].cpu_ids))\n\t\t\tcontinue;\n\n\t\tif (override_status_ids[i].dmi_ids[0].matches[0].slot &&\n\t\t    !dmi_check_system(override_status_ids[i].dmi_ids))\n\t\t\tcontinue;\n\n\t\tif (override_status_ids[i].path) {\n\t\t\tstruct acpi_buffer path = { ACPI_ALLOCATE_BUFFER, NULL };\n\t\t\tbool match;\n\n\t\t\tif (acpi_get_name(adev->handle, ACPI_FULL_PATHNAME, &path))\n\t\t\t\tcontinue;\n\n\t\t\tmatch = strcmp((char *)path.pointer, override_status_ids[i].path) == 0;\n\t\t\tkfree(path.pointer);\n\n\t\t\tif (!match)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (acpi_match_device_ids(adev, override_status_ids[i].hid))\n\t\t\t\tcontinue;\n\n\t\t\tif (!adev->pnp.unique_id ||\n\t\t\t    strcmp(adev->pnp.unique_id, override_status_ids[i].uid))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t*status = override_status_ids[i].status;\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic const struct x86_cpu_id storage_d3_cpu_ids[] = {\n\tX86_MATCH_VENDOR_FAM_MODEL(AMD, 23, 24, NULL),   \n\tX86_MATCH_VENDOR_FAM_MODEL(AMD, 23, 96, NULL),\t \n\tX86_MATCH_VENDOR_FAM_MODEL(AMD, 23, 104, NULL),\t \n\tX86_MATCH_VENDOR_FAM_MODEL(AMD, 25, 80, NULL),\t \n\t{}\n};\n\nbool force_storage_d3(void)\n{\n\treturn x86_match_cpu(storage_d3_cpu_ids);\n}\n\n \n#define ACPI_QUIRK_SKIP_I2C_CLIENTS\t\t\t\tBIT(0)\n#define ACPI_QUIRK_UART1_SKIP\t\t\t\t\tBIT(1)\n#define ACPI_QUIRK_UART1_TTY_UART2_SKIP\t\t\t\tBIT(2)\n#define ACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY\t\t\tBIT(3)\n#define ACPI_QUIRK_USE_ACPI_AC_AND_BATTERY\t\t\tBIT(4)\n#define ACPI_QUIRK_SKIP_GPIO_EVENT_HANDLERS\t\t\tBIT(5)\n\nstatic const struct dmi_system_id acpi_quirk_skip_dmi_ids[] = {\n\t \n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"EF20EA\"),\n\t\t},\n\t\t.driver_data = (void *)ACPI_QUIRK_USE_ACPI_AC_AND_BATTERY\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"80XF\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Lenovo MIIX 320-10ICR\"),\n\t\t},\n\t\t.driver_data = (void *)ACPI_QUIRK_USE_ACPI_AC_AND_BATTERY\n\t},\n\n\t \n#if IS_ENABLED(CONFIG_X86_ANDROID_TABLETS)\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Insyde\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VESPA2\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY |\n\t\t\t\t\tACPI_QUIRK_SKIP_GPIO_EVENT_HANDLERS),\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"ME176C\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_UART1_TTY_UART2_SKIP |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY |\n\t\t\t\t\tACPI_QUIRK_SKIP_GPIO_EVENT_HANDLERS),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"CHERRYVIEW D1 PLATFORM\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_VERSION, \"YETI-11\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_UART1_SKIP |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY |\n\t\t\t\t\tACPI_QUIRK_SKIP_GPIO_EVENT_HANDLERS),\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TF103C\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY |\n\t\t\t\t\tACPI_QUIRK_SKIP_GPIO_EVENT_HANDLERS),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corp.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VALLEYVIEW C0 PLATFORM\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"BYT-T FFD8\"),\n\t\t\t \n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"BLADE_21\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CHERRYVIEW D1 PLATFORM\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Blade3-10A-001\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Aptio CRB\"),\n\t\t\t \n\t\t\tDMI_MATCH(DMI_BIOS_DATE, \"10/22/2015\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Insyde\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"M890BAP\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY |\n\t\t\t\t\tACPI_QUIRK_SKIP_GPIO_EVENT_HANDLERS),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Insyde\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CherryTrail\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"M882\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Aptio CRB\"),\n\t\t\t \n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"ZY-8-BI-PX4S70VTR400-X423B-005-D\"),\n\t\t},\n\t\t.driver_data = (void *)(ACPI_QUIRK_SKIP_I2C_CLIENTS |\n\t\t\t\t\tACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY),\n\t},\n#endif\n\t{}\n};\n\n#if IS_ENABLED(CONFIG_X86_ANDROID_TABLETS)\nstatic const struct acpi_device_id i2c_acpi_known_good_ids[] = {\n\t{ \"10EC5640\", 0 },  \n\t{ \"10EC5651\", 0 },  \n\t{ \"INT33F4\", 0 },   \n\t{ \"INT33FD\", 0 },   \n\t{ \"INT34D3\", 0 },   \n\t{ \"NPCE69A\", 0 },   \n\t{}\n};\n\nbool acpi_quirk_skip_i2c_client_enumeration(struct acpi_device *adev)\n{\n\tconst struct dmi_system_id *dmi_id;\n\tlong quirks;\n\n\tdmi_id = dmi_first_match(acpi_quirk_skip_dmi_ids);\n\tif (!dmi_id)\n\t\treturn false;\n\n\tquirks = (unsigned long)dmi_id->driver_data;\n\tif (!(quirks & ACPI_QUIRK_SKIP_I2C_CLIENTS))\n\t\treturn false;\n\n\treturn acpi_match_device_ids(adev, i2c_acpi_known_good_ids);\n}\nEXPORT_SYMBOL_GPL(acpi_quirk_skip_i2c_client_enumeration);\n\nint acpi_quirk_skip_serdev_enumeration(struct device *controller_parent, bool *skip)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(controller_parent);\n\tconst struct dmi_system_id *dmi_id;\n\tlong quirks = 0;\n\tu64 uid;\n\tint ret;\n\n\t*skip = false;\n\n\tret = acpi_dev_uid_to_integer(adev, &uid);\n\tif (ret)\n\t\treturn 0;\n\n\t \n\tif (!dev_is_platform(controller_parent))\n\t\treturn 0;\n\n\tdmi_id = dmi_first_match(acpi_quirk_skip_dmi_ids);\n\tif (dmi_id)\n\t\tquirks = (unsigned long)dmi_id->driver_data;\n\n\tif ((quirks & ACPI_QUIRK_UART1_SKIP) && uid == 1)\n\t\t*skip = true;\n\n\tif (quirks & ACPI_QUIRK_UART1_TTY_UART2_SKIP) {\n\t\tif (uid == 1)\n\t\t\treturn -ENODEV;  \n\n\t\tif (uid == 2)\n\t\t\t*skip = true;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_quirk_skip_serdev_enumeration);\n\nbool acpi_quirk_skip_gpio_event_handlers(void)\n{\n\tconst struct dmi_system_id *dmi_id;\n\tlong quirks;\n\n\tdmi_id = dmi_first_match(acpi_quirk_skip_dmi_ids);\n\tif (!dmi_id)\n\t\treturn false;\n\n\tquirks = (unsigned long)dmi_id->driver_data;\n\treturn (quirks & ACPI_QUIRK_SKIP_GPIO_EVENT_HANDLERS);\n}\nEXPORT_SYMBOL_GPL(acpi_quirk_skip_gpio_event_handlers);\n#endif\n\n \nstatic const struct {\n\tconst char *hid;\n\tint hrv;\n} acpi_skip_ac_and_battery_pmic_ids[] = {\n\t{ \"INT33F4\", -1 },  \n\t{ \"INT34D3\",  3 },  \n};\n\nbool acpi_quirk_skip_acpi_ac_and_battery(void)\n{\n\tconst struct dmi_system_id *dmi_id;\n\tlong quirks = 0;\n\tint i;\n\n\tdmi_id = dmi_first_match(acpi_quirk_skip_dmi_ids);\n\tif (dmi_id)\n\t\tquirks = (unsigned long)dmi_id->driver_data;\n\n\tif (quirks & ACPI_QUIRK_SKIP_ACPI_AC_AND_BATTERY)\n\t\treturn true;\n\n\tif (quirks & ACPI_QUIRK_USE_ACPI_AC_AND_BATTERY)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(acpi_skip_ac_and_battery_pmic_ids); i++) {\n\t\tif (acpi_dev_present(acpi_skip_ac_and_battery_pmic_ids[i].hid, \"1\",\n\t\t\t\t     acpi_skip_ac_and_battery_pmic_ids[i].hrv)) {\n\t\t\tpr_info_once(\"found native %s PMIC, skipping ACPI AC and battery devices\\n\",\n\t\t\t\t     acpi_skip_ac_and_battery_pmic_ids[i].hid);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(acpi_quirk_skip_acpi_ac_and_battery);\n\n \nstatic int __init acpi_proc_quirk_set_no_mwait(const struct dmi_system_id *id)\n{\n\tpr_notice(\"%s detected - disabling mwait for CPU C-states\\n\",\n\t\t  id->ident);\n\tboot_option_idle_override = IDLE_NOMWAIT;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id acpi_proc_quirk_mwait_dmi_table[] __initconst = {\n\t{\n\t\t.callback = acpi_proc_quirk_set_no_mwait,\n\t\t.ident = \"Extensa 5220\",\n\t\t.matches =  {\n\t\t\tDMI_MATCH(DMI_BIOS_VENDOR, \"Phoenix Technologies LTD\"),\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"0100\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Columbia\"),\n\t\t},\n\t\t.driver_data = NULL,\n\t},\n\t{}\n};\n\nvoid __init acpi_proc_quirk_mwait_check(void)\n{\n\t \n\tdmi_check_system(acpi_proc_quirk_mwait_dmi_table);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}