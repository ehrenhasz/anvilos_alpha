{
  "module_name": "apple.c",
  "hash_id": "77934a920e5fb2f4a839f264bb62ba23a475f6e0d1c346696760b76d8d3818b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/x86/apple.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/platform_data/x86/apple.h>\n#include <linux/uuid.h>\n#include \"../internal.h\"\n\n \nstatic const guid_t apple_prp_guid =\n\tGUID_INIT(0xa0b5b7c6, 0x1318, 0x441c,\n\t\t  0xb0, 0xc9, 0xfe, 0x69, 0x5e, 0xaf, 0x94, 0x9b);\n\n \nvoid acpi_extract_apple_properties(struct acpi_device *adev)\n{\n\tunsigned int i, j = 0, newsize = 0, numprops, numvalid;\n\tunion acpi_object *props, *newprops;\n\tunsigned long *valid = NULL;\n\tvoid *free_space;\n\n\tif (!x86_apple_machine)\n\t\treturn;\n\n\tprops = acpi_evaluate_dsm_typed(adev->handle, &apple_prp_guid, 1, 0,\n\t\t\t\t\tNULL, ACPI_TYPE_BUFFER);\n\tif (!props)\n\t\treturn;\n\n\tif (!props->buffer.length)\n\t\tgoto out_free;\n\n\tif (props->buffer.pointer[0] != 3) {\n\t\tacpi_handle_info(adev->handle, FW_INFO\n\t\t\t\t \"unsupported properties version %*ph\\n\",\n\t\t\t\t props->buffer.length, props->buffer.pointer);\n\t\tgoto out_free;\n\t}\n\n\tACPI_FREE(props);\n\tprops = acpi_evaluate_dsm_typed(adev->handle, &apple_prp_guid, 1, 1,\n\t\t\t\t\tNULL, ACPI_TYPE_PACKAGE);\n\tif (!props)\n\t\treturn;\n\n\tnumprops = props->package.count / 2;\n\tif (!numprops)\n\t\tgoto out_free;\n\n\tvalid = bitmap_zalloc(numprops, GFP_KERNEL);\n\tif (!valid)\n\t\tgoto out_free;\n\n\t \n\tfor (i = 0; i < numprops; i++) {\n\t\tunion acpi_object *key = &props->package.elements[i * 2];\n\t\tunion acpi_object *val = &props->package.elements[i * 2 + 1];\n\n\t\tif ( key->type != ACPI_TYPE_STRING ||\n\t\t    (val->type != ACPI_TYPE_INTEGER &&\n\t\t     val->type != ACPI_TYPE_BUFFER &&\n\t\t     val->type != ACPI_TYPE_STRING))\n\t\t\tcontinue;  \n\n\t\t__set_bit(i, valid);\n\t\tnewsize += key->string.length + 1;\n\t\tif ( val->type == ACPI_TYPE_BUFFER)\n\t\t\tnewsize += val->buffer.length;\n\t\telse if (val->type == ACPI_TYPE_STRING)\n\t\t\tnewsize += val->string.length + 1;\n\t}\n\n\tnumvalid = bitmap_weight(valid, numprops);\n\tif (numprops > numvalid)\n\t\tacpi_handle_info(adev->handle, FW_INFO\n\t\t\t\t \"skipped %u properties: wrong type\\n\",\n\t\t\t\t numprops - numvalid);\n\tif (numvalid == 0)\n\t\tgoto out_free;\n\n\t \n\tnewsize\t+= (1 + 3 * numvalid) * sizeof(union acpi_object);\n\tnewprops = ACPI_ALLOCATE_ZEROED(newsize);\n\tif (!newprops)\n\t\tgoto out_free;\n\n\t \n\tnewprops->type = ACPI_TYPE_PACKAGE;\n\tnewprops->package.count = numvalid;\n\tnewprops->package.elements = &newprops[1];\n\tfree_space = &newprops[1 + 3 * numvalid];\n\n\tfor_each_set_bit(i, valid, numprops) {\n\t\tunion acpi_object *key = &props->package.elements[i * 2];\n\t\tunion acpi_object *val = &props->package.elements[i * 2 + 1];\n\t\tunsigned int k = 1 + numvalid + j * 2;  \n\t\tunsigned int v = k + 1;\n\n\t\tnewprops[1 + j].type = ACPI_TYPE_PACKAGE;\n\t\tnewprops[1 + j].package.count = 2;\n\t\tnewprops[1 + j].package.elements = &newprops[k];\n\n\t\tnewprops[k].type = ACPI_TYPE_STRING;\n\t\tnewprops[k].string.length = key->string.length;\n\t\tnewprops[k].string.pointer = free_space;\n\t\tmemcpy(free_space, key->string.pointer, key->string.length);\n\t\tfree_space += key->string.length + 1;\n\n\t\tnewprops[v].type = val->type;\n\t\tif (val->type == ACPI_TYPE_INTEGER) {\n\t\t\tnewprops[v].integer.value = val->integer.value;\n\t\t} else if (val->type == ACPI_TYPE_STRING) {\n\t\t\tnewprops[v].string.length = val->string.length;\n\t\t\tnewprops[v].string.pointer = free_space;\n\t\t\tmemcpy(free_space, val->string.pointer,\n\t\t\t       val->string.length);\n\t\t\tfree_space += val->string.length + 1;\n\t\t} else {\n\t\t\tnewprops[v].buffer.length = val->buffer.length;\n\t\t\tnewprops[v].buffer.pointer = free_space;\n\t\t\tmemcpy(free_space, val->buffer.pointer,\n\t\t\t       val->buffer.length);\n\t\t\tfree_space += val->buffer.length;\n\t\t}\n\t\tj++;  \n\t}\n\tWARN_ON(free_space != (void *)newprops + newsize);\n\n\tadev->data.pointer = newprops;\n\tacpi_data_add_props(&adev->data, &apple_prp_guid, newprops);\n\nout_free:\n\tACPI_FREE(props);\n\tbitmap_free(valid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}