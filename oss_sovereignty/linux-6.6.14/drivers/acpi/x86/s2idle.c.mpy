{
  "module_name": "s2idle.c",
  "hash_id": "ea915f54c56a67a7d6ffeeeb4f3c371c06f3ead52f8439b650d25426ab839bc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/x86/s2idle.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/dmi.h>\n#include <linux/suspend.h>\n\n#include \"../sleep.h\"\n\n#ifdef CONFIG_SUSPEND\n\nstatic bool sleep_no_lps0 __read_mostly;\nmodule_param(sleep_no_lps0, bool, 0644);\nMODULE_PARM_DESC(sleep_no_lps0, \"Do not use the special LPS0 device interface\");\n\nstatic const struct acpi_device_id lps0_device_ids[] = {\n\t{\"PNP0D80\", },\n\t{\"\", },\n};\n\n \n#define ACPI_LPS0_DSM_UUID_MICROSOFT      \"11e00d56-ce64-47ce-837b-1f898f9aa461\"\n\n#define ACPI_LPS0_DSM_UUID\t\"c4eb40a0-6cd2-11e2-bcfd-0800200c9a66\"\n\n#define ACPI_LPS0_GET_DEVICE_CONSTRAINTS\t1\n#define ACPI_LPS0_SCREEN_OFF\t3\n#define ACPI_LPS0_SCREEN_ON\t4\n#define ACPI_LPS0_ENTRY\t\t5\n#define ACPI_LPS0_EXIT\t\t6\n#define ACPI_LPS0_MS_ENTRY      7\n#define ACPI_LPS0_MS_EXIT       8\n\n \n#define ACPI_LPS0_DSM_UUID_AMD      \"e3f32452-febc-43ce-9039-932122d37721\"\n#define ACPI_LPS0_ENTRY_AMD         2\n#define ACPI_LPS0_EXIT_AMD          3\n#define ACPI_LPS0_SCREEN_OFF_AMD    4\n#define ACPI_LPS0_SCREEN_ON_AMD     5\n\nstatic acpi_handle lps0_device_handle;\nstatic guid_t lps0_dsm_guid;\nstatic int lps0_dsm_func_mask;\n\nstatic guid_t lps0_dsm_guid_microsoft;\nstatic int lps0_dsm_func_mask_microsoft;\nstatic int lps0_dsm_state;\n\n \nstruct lpi_device_info {\n\tchar *name;\n\tint enabled;\n\tunion acpi_object *package;\n};\n\n \nstruct lpi_device_constraint {\n\tint uid;\n\tint min_dstate;\n\tint function_states;\n};\n\nstruct lpi_constraints {\n\tacpi_handle handle;\n\tint min_dstate;\n};\n\n \nstruct lpi_device_constraint_amd {\n\tchar *name;\n\tint enabled;\n\tint function_states;\n\tint min_dstate;\n};\n\nstatic LIST_HEAD(lps0_s2idle_devops_head);\n\nstatic struct lpi_constraints *lpi_constraints_table;\nstatic int lpi_constraints_table_size;\nstatic int rev_id;\n\n#define for_each_lpi_constraint(entry)\t\t\t\t\t\t\\\n\tfor (int i = 0;\t\t\t\t\t\t\t\t\\\n\t     entry = &lpi_constraints_table[i], i < lpi_constraints_table_size;\t\\\n\t     i++)\n\nstatic void lpi_device_get_constraints_amd(void)\n{\n\tunion acpi_object *out_obj;\n\tint i, j, k;\n\n\tout_obj = acpi_evaluate_dsm_typed(lps0_device_handle, &lps0_dsm_guid,\n\t\t\t\t\t  rev_id, ACPI_LPS0_GET_DEVICE_CONSTRAINTS,\n\t\t\t\t\t  NULL, ACPI_TYPE_PACKAGE);\n\n\tacpi_handle_debug(lps0_device_handle, \"_DSM function 1 eval %s\\n\",\n\t\t\t  out_obj ? \"successful\" : \"failed\");\n\n\tif (!out_obj)\n\t\treturn;\n\n\tfor (i = 0; i < out_obj->package.count; i++) {\n\t\tunion acpi_object *package = &out_obj->package.elements[i];\n\n\t\tif (package->type == ACPI_TYPE_PACKAGE) {\n\t\t\tif (lpi_constraints_table) {\n\t\t\t\tacpi_handle_err(lps0_device_handle,\n\t\t\t\t\t\t\"Duplicate constraints list\\n\");\n\t\t\t\tgoto free_acpi_buffer;\n\t\t\t}\n\n\t\t\tlpi_constraints_table = kcalloc(package->package.count,\n\t\t\t\t\t\t\tsizeof(*lpi_constraints_table),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\t\t\tif (!lpi_constraints_table)\n\t\t\t\tgoto free_acpi_buffer;\n\n\t\t\tacpi_handle_debug(lps0_device_handle,\n\t\t\t\t\t  \"LPI: constraints list begin:\\n\");\n\n\t\t\tfor (j = 0; j < package->package.count; j++) {\n\t\t\t\tunion acpi_object *info_obj = &package->package.elements[j];\n\t\t\t\tstruct lpi_device_constraint_amd dev_info = {};\n\t\t\t\tstruct lpi_constraints *list;\n\t\t\t\tacpi_status status;\n\n\t\t\t\tlist = &lpi_constraints_table[lpi_constraints_table_size];\n\n\t\t\t\tfor (k = 0; k < info_obj->package.count; k++) {\n\t\t\t\t\tunion acpi_object *obj = &info_obj->package.elements[k];\n\n\t\t\t\t\tswitch (k) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tdev_info.enabled = obj->integer.value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tdev_info.name = obj->string.pointer;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tdev_info.function_states = obj->integer.value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tdev_info.min_dstate = obj->integer.value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tacpi_handle_debug(lps0_device_handle,\n\t\t\t\t\t\t  \"Name:%s, Enabled: %d, States: %d, MinDstate: %d\\n\",\n\t\t\t\t\t\t  dev_info.name,\n\t\t\t\t\t\t  dev_info.enabled,\n\t\t\t\t\t\t  dev_info.function_states,\n\t\t\t\t\t\t  dev_info.min_dstate);\n\n\t\t\t\tif (!dev_info.enabled || !dev_info.name ||\n\t\t\t\t    !dev_info.min_dstate)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tstatus = acpi_get_handle(NULL, dev_info.name, &list->handle);\n\t\t\t\tif (ACPI_FAILURE(status))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlist->min_dstate = dev_info.min_dstate;\n\n\t\t\t\tlpi_constraints_table_size++;\n\t\t\t}\n\t\t}\n\t}\n\n\tacpi_handle_debug(lps0_device_handle, \"LPI: constraints list end\\n\");\n\nfree_acpi_buffer:\n\tACPI_FREE(out_obj);\n}\n\nstatic void lpi_device_get_constraints(void)\n{\n\tunion acpi_object *out_obj;\n\tint i;\n\n\tout_obj = acpi_evaluate_dsm_typed(lps0_device_handle, &lps0_dsm_guid,\n\t\t\t\t\t  1, ACPI_LPS0_GET_DEVICE_CONSTRAINTS,\n\t\t\t\t\t  NULL, ACPI_TYPE_PACKAGE);\n\n\tacpi_handle_debug(lps0_device_handle, \"_DSM function 1 eval %s\\n\",\n\t\t\t  out_obj ? \"successful\" : \"failed\");\n\n\tif (!out_obj)\n\t\treturn;\n\n\tlpi_constraints_table = kcalloc(out_obj->package.count,\n\t\t\t\t\tsizeof(*lpi_constraints_table),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!lpi_constraints_table)\n\t\tgoto free_acpi_buffer;\n\n\tacpi_handle_debug(lps0_device_handle, \"LPI: constraints list begin:\\n\");\n\n\tfor (i = 0; i < out_obj->package.count; i++) {\n\t\tstruct lpi_constraints *constraint;\n\t\tacpi_status status;\n\t\tunion acpi_object *package = &out_obj->package.elements[i];\n\t\tstruct lpi_device_info info = { };\n\t\tint package_count = 0, j;\n\n\t\tif (!package)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < package->package.count; j++) {\n\t\t\tunion acpi_object *element =\n\t\t\t\t\t&(package->package.elements[j]);\n\n\t\t\tswitch (element->type) {\n\t\t\tcase ACPI_TYPE_INTEGER:\n\t\t\t\tinfo.enabled = element->integer.value;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_TYPE_STRING:\n\t\t\t\tinfo.name = element->string.pointer;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_TYPE_PACKAGE:\n\t\t\t\tpackage_count = element->package.count;\n\t\t\t\tinfo.package = element->package.elements;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!info.enabled || !info.package || !info.name)\n\t\t\tcontinue;\n\n\t\tconstraint = &lpi_constraints_table[lpi_constraints_table_size];\n\n\t\tstatus = acpi_get_handle(NULL, info.name, &constraint->handle);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tcontinue;\n\n\t\tacpi_handle_debug(lps0_device_handle,\n\t\t\t\t  \"index:%d Name:%s\\n\", i, info.name);\n\n\t\tconstraint->min_dstate = -1;\n\n\t\tfor (j = 0; j < package_count; j++) {\n\t\t\tunion acpi_object *info_obj = &info.package[j];\n\t\t\tunion acpi_object *cnstr_pkg;\n\t\t\tunion acpi_object *obj;\n\t\t\tstruct lpi_device_constraint dev_info;\n\n\t\t\tswitch (info_obj->type) {\n\t\t\tcase ACPI_TYPE_INTEGER:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase ACPI_TYPE_PACKAGE:\n\t\t\t\tif (info_obj->package.count < 2)\n\t\t\t\t\tbreak;\n\n\t\t\t\tcnstr_pkg = info_obj->package.elements;\n\t\t\t\tobj = &cnstr_pkg[0];\n\t\t\t\tdev_info.uid = obj->integer.value;\n\t\t\t\tobj = &cnstr_pkg[1];\n\t\t\t\tdev_info.min_dstate = obj->integer.value;\n\n\t\t\t\tacpi_handle_debug(lps0_device_handle,\n\t\t\t\t\t\"uid:%d min_dstate:%s\\n\",\n\t\t\t\t\tdev_info.uid,\n\t\t\t\t\tacpi_power_state_string(dev_info.min_dstate));\n\n\t\t\t\tconstraint->min_dstate = dev_info.min_dstate;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (constraint->min_dstate < 0) {\n\t\t\tacpi_handle_debug(lps0_device_handle,\n\t\t\t\t\t  \"Incomplete constraint defined\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tlpi_constraints_table_size++;\n\t}\n\n\tacpi_handle_debug(lps0_device_handle, \"LPI: constraints list end\\n\");\n\nfree_acpi_buffer:\n\tACPI_FREE(out_obj);\n}\n\n \nint acpi_get_lps0_constraint(struct acpi_device *adev)\n{\n\tstruct lpi_constraints *entry;\n\n\tfor_each_lpi_constraint(entry) {\n\t\tif (adev->handle == entry->handle)\n\t\t\treturn entry->min_dstate;\n\t}\n\n\treturn ACPI_STATE_UNKNOWN;\n}\n\nstatic void lpi_check_constraints(void)\n{\n\tstruct lpi_constraints *entry;\n\n\tfor_each_lpi_constraint(entry) {\n\t\tstruct acpi_device *adev = acpi_fetch_acpi_dev(entry->handle);\n\n\t\tif (!adev)\n\t\t\tcontinue;\n\n\t\tacpi_handle_debug(entry->handle,\n\t\t\t\"LPI: required min power state:%s current power state:%s\\n\",\n\t\t\tacpi_power_state_string(entry->min_dstate),\n\t\t\tacpi_power_state_string(adev->power.state));\n\n\t\tif (!adev->flags.power_manageable) {\n\t\t\tacpi_handle_info(entry->handle, \"LPI: Device not power manageable\\n\");\n\t\t\tentry->handle = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (adev->power.state < entry->min_dstate)\n\t\t\tacpi_handle_info(entry->handle,\n\t\t\t\t\"LPI: Constraint not met; min power state:%s current power state:%s\\n\",\n\t\t\t\tacpi_power_state_string(entry->min_dstate),\n\t\t\t\tacpi_power_state_string(adev->power.state));\n\t}\n}\n\nstatic bool acpi_s2idle_vendor_amd(void)\n{\n\treturn boot_cpu_data.x86_vendor == X86_VENDOR_AMD;\n}\n\nstatic const char *acpi_sleep_dsm_state_to_str(unsigned int state)\n{\n\tif (lps0_dsm_func_mask_microsoft || !acpi_s2idle_vendor_amd()) {\n\t\tswitch (state) {\n\t\tcase ACPI_LPS0_SCREEN_OFF:\n\t\t\treturn \"screen off\";\n\t\tcase ACPI_LPS0_SCREEN_ON:\n\t\t\treturn \"screen on\";\n\t\tcase ACPI_LPS0_ENTRY:\n\t\t\treturn \"lps0 entry\";\n\t\tcase ACPI_LPS0_EXIT:\n\t\t\treturn \"lps0 exit\";\n\t\tcase ACPI_LPS0_MS_ENTRY:\n\t\t\treturn \"lps0 ms entry\";\n\t\tcase ACPI_LPS0_MS_EXIT:\n\t\t\treturn \"lps0 ms exit\";\n\t\t}\n\t} else {\n\t\tswitch (state) {\n\t\tcase ACPI_LPS0_SCREEN_ON_AMD:\n\t\t\treturn \"screen on\";\n\t\tcase ACPI_LPS0_SCREEN_OFF_AMD:\n\t\t\treturn \"screen off\";\n\t\tcase ACPI_LPS0_ENTRY_AMD:\n\t\t\treturn \"lps0 entry\";\n\t\tcase ACPI_LPS0_EXIT_AMD:\n\t\t\treturn \"lps0 exit\";\n\t\t}\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic void acpi_sleep_run_lps0_dsm(unsigned int func, unsigned int func_mask, guid_t dsm_guid)\n{\n\tunion acpi_object *out_obj;\n\n\tif (!(func_mask & (1 << func)))\n\t\treturn;\n\n\tout_obj = acpi_evaluate_dsm(lps0_device_handle, &dsm_guid,\n\t\t\t\t\trev_id, func, NULL);\n\tACPI_FREE(out_obj);\n\n\tlps0_dsm_state = func;\n\tif (pm_debug_messages_on) {\n\t\tacpi_handle_info(lps0_device_handle,\n\t\t\t\t\"%s transitioned to state %s\\n\",\n\t\t\t\t out_obj ? \"Successfully\" : \"Failed to\",\n\t\t\t\t acpi_sleep_dsm_state_to_str(lps0_dsm_state));\n\t}\n}\n\n\nstatic int validate_dsm(acpi_handle handle, const char *uuid, int rev, guid_t *dsm_guid)\n{\n\tunion acpi_object *obj;\n\tint ret = -EINVAL;\n\n\tguid_parse(uuid, dsm_guid);\n\tobj = acpi_evaluate_dsm(handle, dsm_guid, rev, 0, NULL);\n\n\t \n\tif (!obj || obj->type != ACPI_TYPE_BUFFER || obj->buffer.length == 0 ||\n\t    obj->buffer.length > sizeof(u32)) {\n\t\tacpi_handle_debug(handle,\n\t\t\t\t\"_DSM UUID %s rev %d function 0 evaluation failed\\n\", uuid, rev);\n\t\tgoto out;\n\t}\n\n\tret = *(int *)obj->buffer.pointer;\n\tacpi_handle_debug(handle, \"_DSM UUID %s rev %d function mask: 0x%x\\n\", uuid, rev, ret);\n\nout:\n\tACPI_FREE(obj);\n\treturn ret;\n}\n\nstruct amd_lps0_hid_device_data {\n\tconst bool check_off_by_one;\n};\n\nstatic const struct amd_lps0_hid_device_data amd_picasso = {\n\t.check_off_by_one = true,\n};\n\nstatic const struct amd_lps0_hid_device_data amd_cezanne = {\n\t.check_off_by_one = false,\n};\n\nstatic const struct acpi_device_id amd_hid_ids[] = {\n\t{\"AMD0004\",\t(kernel_ulong_t)&amd_picasso,\t},\n\t{\"AMD0005\",\t(kernel_ulong_t)&amd_picasso,\t},\n\t{\"AMDI0005\",\t(kernel_ulong_t)&amd_picasso,\t},\n\t{\"AMDI0006\",\t(kernel_ulong_t)&amd_cezanne,\t},\n\t{}\n};\n\nstatic int lps0_device_attach(struct acpi_device *adev,\n\t\t\t      const struct acpi_device_id *not_used)\n{\n\tif (lps0_device_handle)\n\t\treturn 0;\n\n\tlps0_dsm_func_mask_microsoft = validate_dsm(adev->handle,\n\t\t\t\t\t\t    ACPI_LPS0_DSM_UUID_MICROSOFT, 0,\n\t\t\t\t\t\t    &lps0_dsm_guid_microsoft);\n\tif (acpi_s2idle_vendor_amd()) {\n\t\tstatic const struct acpi_device_id *dev_id;\n\t\tconst struct amd_lps0_hid_device_data *data;\n\n\t\tfor (dev_id = &amd_hid_ids[0]; dev_id->id[0]; dev_id++)\n\t\t\tif (acpi_dev_hid_uid_match(adev, dev_id->id, NULL))\n\t\t\t\tbreak;\n\t\tif (dev_id->id[0])\n\t\t\tdata = (const struct amd_lps0_hid_device_data *) dev_id->driver_data;\n\t\telse\n\t\t\tdata = &amd_cezanne;\n\t\tlps0_dsm_func_mask = validate_dsm(adev->handle,\n\t\t\t\t\tACPI_LPS0_DSM_UUID_AMD, rev_id, &lps0_dsm_guid);\n\t\tif (lps0_dsm_func_mask > 0x3 && data->check_off_by_one) {\n\t\t\tlps0_dsm_func_mask = (lps0_dsm_func_mask << 1) | 0x1;\n\t\t\tacpi_handle_debug(adev->handle, \"_DSM UUID %s: Adjusted function mask: 0x%x\\n\",\n\t\t\t\t\t  ACPI_LPS0_DSM_UUID_AMD, lps0_dsm_func_mask);\n\t\t} else if (lps0_dsm_func_mask_microsoft > 0 && rev_id) {\n\t\t\tlps0_dsm_func_mask_microsoft = -EINVAL;\n\t\t\tacpi_handle_debug(adev->handle, \"_DSM Using AMD method\\n\");\n\t\t}\n\t} else {\n\t\trev_id = 1;\n\t\tlps0_dsm_func_mask = validate_dsm(adev->handle,\n\t\t\t\t\tACPI_LPS0_DSM_UUID, rev_id, &lps0_dsm_guid);\n\t\tlps0_dsm_func_mask_microsoft = -EINVAL;\n\t}\n\n\tif (lps0_dsm_func_mask < 0 && lps0_dsm_func_mask_microsoft < 0)\n\t\treturn 0; \n\n\tlps0_device_handle = adev->handle;\n\n\tif (acpi_s2idle_vendor_amd())\n\t\tlpi_device_get_constraints_amd();\n\telse\n\t\tlpi_device_get_constraints();\n\n\t \n\tif ((acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0) &&\n\t    mem_sleep_default > PM_SUSPEND_MEM && !acpi_sleep_default_s3) {\n\t\tmem_sleep_current = PM_SUSPEND_TO_IDLE;\n\t\tpr_info(\"Low-power S0 idle used by default for system suspend\\n\");\n\t}\n\n\t \n\tacpi_ec_mark_gpe_for_wake();\n\n\treturn 0;\n}\n\nstatic struct acpi_scan_handler lps0_handler = {\n\t.ids = lps0_device_ids,\n\t.attach = lps0_device_attach,\n};\n\nint acpi_s2idle_prepare_late(void)\n{\n\tstruct acpi_s2idle_dev_ops *handler;\n\n\tif (!lps0_device_handle || sleep_no_lps0)\n\t\treturn 0;\n\n\tif (pm_debug_messages_on)\n\t\tlpi_check_constraints();\n\n\t \n\tif (lps0_dsm_func_mask > 0)\n\t\tacpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?\n\t\t\t\t\tACPI_LPS0_SCREEN_OFF_AMD :\n\t\t\t\t\tACPI_LPS0_SCREEN_OFF,\n\t\t\t\t\tlps0_dsm_func_mask, lps0_dsm_guid);\n\n\tif (lps0_dsm_func_mask_microsoft > 0)\n\t\tacpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_OFF,\n\t\t\t\tlps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);\n\n\t \n\tif (lps0_dsm_func_mask > 0)\n\t\tacpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?\n\t\t\t\t\tACPI_LPS0_ENTRY_AMD :\n\t\t\t\t\tACPI_LPS0_ENTRY,\n\t\t\t\t\tlps0_dsm_func_mask, lps0_dsm_guid);\n\tif (lps0_dsm_func_mask_microsoft > 0) {\n\t\t \n\t\tacpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_ENTRY,\n\t\t\t\tlps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);\n\t\tacpi_sleep_run_lps0_dsm(ACPI_LPS0_ENTRY,\n\t\t\t\tlps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);\n\t}\n\n\tlist_for_each_entry(handler, &lps0_s2idle_devops_head, list_node) {\n\t\tif (handler->prepare)\n\t\t\thandler->prepare();\n\t}\n\n\treturn 0;\n}\n\nvoid acpi_s2idle_check(void)\n{\n\tstruct acpi_s2idle_dev_ops *handler;\n\n\tif (!lps0_device_handle || sleep_no_lps0)\n\t\treturn;\n\n\tlist_for_each_entry(handler, &lps0_s2idle_devops_head, list_node) {\n\t\tif (handler->check)\n\t\t\thandler->check();\n\t}\n}\n\nvoid acpi_s2idle_restore_early(void)\n{\n\tstruct acpi_s2idle_dev_ops *handler;\n\n\tif (!lps0_device_handle || sleep_no_lps0)\n\t\treturn;\n\n\tlist_for_each_entry(handler, &lps0_s2idle_devops_head, list_node)\n\t\tif (handler->restore)\n\t\t\thandler->restore();\n\n\t \n\tif (lps0_dsm_func_mask > 0)\n\t\tacpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?\n\t\t\t\t\tACPI_LPS0_EXIT_AMD :\n\t\t\t\t\tACPI_LPS0_EXIT,\n\t\t\t\t\tlps0_dsm_func_mask, lps0_dsm_guid);\n\tif (lps0_dsm_func_mask_microsoft > 0)\n\t\tacpi_sleep_run_lps0_dsm(ACPI_LPS0_EXIT,\n\t\t\t\tlps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);\n\n\t \n\tif (lps0_dsm_func_mask_microsoft > 0)\n\t\tacpi_sleep_run_lps0_dsm(ACPI_LPS0_MS_EXIT,\n\t\t\t\tlps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);\n\n\t \n\tif (lps0_dsm_func_mask_microsoft > 0)\n\t\tacpi_sleep_run_lps0_dsm(ACPI_LPS0_SCREEN_ON,\n\t\t\t\tlps0_dsm_func_mask_microsoft, lps0_dsm_guid_microsoft);\n\tif (lps0_dsm_func_mask > 0)\n\t\tacpi_sleep_run_lps0_dsm(acpi_s2idle_vendor_amd() ?\n\t\t\t\t\tACPI_LPS0_SCREEN_ON_AMD :\n\t\t\t\t\tACPI_LPS0_SCREEN_ON,\n\t\t\t\t\tlps0_dsm_func_mask, lps0_dsm_guid);\n}\n\nstatic const struct platform_s2idle_ops acpi_s2idle_ops_lps0 = {\n\t.begin = acpi_s2idle_begin,\n\t.prepare = acpi_s2idle_prepare,\n\t.prepare_late = acpi_s2idle_prepare_late,\n\t.check = acpi_s2idle_check,\n\t.wake = acpi_s2idle_wake,\n\t.restore_early = acpi_s2idle_restore_early,\n\t.restore = acpi_s2idle_restore,\n\t.end = acpi_s2idle_end,\n};\n\nvoid __init acpi_s2idle_setup(void)\n{\n\tacpi_scan_add_handler(&lps0_handler);\n\ts2idle_set_ops(&acpi_s2idle_ops_lps0);\n}\n\nint acpi_register_lps0_dev(struct acpi_s2idle_dev_ops *arg)\n{\n\tunsigned int sleep_flags;\n\n\tif (!lps0_device_handle || sleep_no_lps0)\n\t\treturn -ENODEV;\n\n\tsleep_flags = lock_system_sleep();\n\tlist_add(&arg->list_node, &lps0_s2idle_devops_head);\n\tunlock_system_sleep(sleep_flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_register_lps0_dev);\n\nvoid acpi_unregister_lps0_dev(struct acpi_s2idle_dev_ops *arg)\n{\n\tunsigned int sleep_flags;\n\n\tif (!lps0_device_handle || sleep_no_lps0)\n\t\treturn;\n\n\tsleep_flags = lock_system_sleep();\n\tlist_del(&arg->list_node);\n\tunlock_system_sleep(sleep_flags);\n}\nEXPORT_SYMBOL_GPL(acpi_unregister_lps0_dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}