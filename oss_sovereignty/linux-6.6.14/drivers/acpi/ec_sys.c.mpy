{
  "module_name": "ec_sys.c",
  "hash_id": "738b78c62f47d4e7db86e50928f7811f3db99ae776240ddec52a3f4697d0449d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/ec_sys.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\nMODULE_AUTHOR(\"Thomas Renninger <trenn@suse.de>\");\nMODULE_DESCRIPTION(\"ACPI EC sysfs access driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool write_support;\nmodule_param_hw(write_support, bool, other, 0644);\nMODULE_PARM_DESC(write_support, \"Dangerous, reboot and removal of battery may \"\n\t\t \"be needed.\");\n\n#define EC_SPACE_SIZE 256\n\nstatic struct dentry *acpi_ec_debugfs_dir;\n\nstatic ssize_t acpi_ec_read_io(struct file *f, char __user *buf,\n\t\t\t       size_t count, loff_t *off)\n{\n\t \n\tunsigned int size = EC_SPACE_SIZE;\n\tloff_t init_off = *off;\n\tint err = 0;\n\n\tif (*off >= size)\n\t\treturn 0;\n\tif (*off + count >= size) {\n\t\tsize -= *off;\n\t\tcount = size;\n\t} else\n\t\tsize = count;\n\n\twhile (size) {\n\t\tu8 byte_read;\n\t\terr = ec_read(*off, &byte_read);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (put_user(byte_read, buf + *off - init_off)) {\n\t\t\tif (*off - init_off)\n\t\t\t\treturn *off - init_off;  \n\t\t\treturn -EFAULT;\n\t\t}\n\t\t*off += 1;\n\t\tsize--;\n\t}\n\treturn count;\n}\n\nstatic ssize_t acpi_ec_write_io(struct file *f, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *off)\n{\n\t \n\n\tunsigned int size = count;\n\tloff_t init_off = *off;\n\tint err = 0;\n\n\tif (!write_support)\n\t\treturn -EINVAL;\n\n\tif (*off >= EC_SPACE_SIZE)\n\t\treturn 0;\n\tif (*off + count >= EC_SPACE_SIZE) {\n\t\tsize = EC_SPACE_SIZE - *off;\n\t\tcount = size;\n\t}\n\n\twhile (size) {\n\t\tu8 byte_write;\n\t\tif (get_user(byte_write, buf + *off - init_off)) {\n\t\t\tif (*off - init_off)\n\t\t\t\treturn *off - init_off;  \n\t\t\treturn -EFAULT;\n\t\t}\n\t\terr = ec_write(*off, byte_write);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*off += 1;\n\t\tsize--;\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations acpi_ec_io_ops = {\n\t.owner = THIS_MODULE,\n\t.open  = simple_open,\n\t.read  = acpi_ec_read_io,\n\t.write = acpi_ec_write_io,\n\t.llseek = default_llseek,\n};\n\nstatic void acpi_ec_add_debugfs(struct acpi_ec *ec, unsigned int ec_device_count)\n{\n\tstruct dentry *dev_dir;\n\tchar name[64];\n\tumode_t mode = 0400;\n\n\tif (ec_device_count == 0)\n\t\tacpi_ec_debugfs_dir = debugfs_create_dir(\"ec\", NULL);\n\n\tsprintf(name, \"ec%u\", ec_device_count);\n\tdev_dir = debugfs_create_dir(name, acpi_ec_debugfs_dir);\n\n\tdebugfs_create_x32(\"gpe\", 0444, dev_dir, &first_ec->gpe);\n\tdebugfs_create_bool(\"use_global_lock\", 0444, dev_dir,\n\t\t\t    &first_ec->global_lock);\n\n\tif (write_support)\n\t\tmode = 0600;\n\tdebugfs_create_file(\"io\", mode, dev_dir, ec, &acpi_ec_io_ops);\n}\n\nstatic int __init acpi_ec_sys_init(void)\n{\n\tif (first_ec)\n\t\tacpi_ec_add_debugfs(first_ec, 0);\n\treturn 0;\n}\n\nstatic void __exit acpi_ec_sys_exit(void)\n{\n\tdebugfs_remove_recursive(acpi_ec_debugfs_dir);\n}\n\nmodule_init(acpi_ec_sys_init);\nmodule_exit(acpi_ec_sys_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}