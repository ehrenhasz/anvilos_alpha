{
  "module_name": "apei-base.c",
  "hash_id": "f7ccbb65ab98188ed784480d244c3e5be3bab70ba33a391d08f6ab6340f40771",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/apei/apei-base.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/kref.h>\n#include <linux/interrupt.h>\n#include <linux/debugfs.h>\n#include <acpi/apei.h>\n#include <asm/unaligned.h>\n\n#include \"apei-internal.h\"\n\n#define APEI_PFX \"APEI: \"\n\n \n\n#define APEI_EXEC_PRESERVE_REGISTER\t0x1\n\nvoid apei_exec_ctx_init(struct apei_exec_context *ctx,\n\t\t\tstruct apei_exec_ins_type *ins_table,\n\t\t\tu32 instructions,\n\t\t\tstruct acpi_whea_header *action_table,\n\t\t\tu32 entries)\n{\n\tctx->ins_table = ins_table;\n\tctx->instructions = instructions;\n\tctx->action_table = action_table;\n\tctx->entries = entries;\n}\nEXPORT_SYMBOL_GPL(apei_exec_ctx_init);\n\nint __apei_exec_read_register(struct acpi_whea_header *entry, u64 *val)\n{\n\tint rc;\n\n\trc = apei_read(val, &entry->register_region);\n\tif (rc)\n\t\treturn rc;\n\t*val >>= entry->register_region.bit_offset;\n\t*val &= entry->mask;\n\n\treturn 0;\n}\n\nint apei_exec_read_register(struct apei_exec_context *ctx,\n\t\t\t    struct acpi_whea_header *entry)\n{\n\tint rc;\n\tu64 val = 0;\n\n\trc = __apei_exec_read_register(entry, &val);\n\tif (rc)\n\t\treturn rc;\n\tctx->value = val;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apei_exec_read_register);\n\nint apei_exec_read_register_value(struct apei_exec_context *ctx,\n\t\t\t\t  struct acpi_whea_header *entry)\n{\n\tint rc;\n\n\trc = apei_exec_read_register(ctx, entry);\n\tif (rc)\n\t\treturn rc;\n\tctx->value = (ctx->value == entry->value);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apei_exec_read_register_value);\n\nint __apei_exec_write_register(struct acpi_whea_header *entry, u64 val)\n{\n\tint rc;\n\n\tval &= entry->mask;\n\tval <<= entry->register_region.bit_offset;\n\tif (entry->flags & APEI_EXEC_PRESERVE_REGISTER) {\n\t\tu64 valr = 0;\n\t\trc = apei_read(&valr, &entry->register_region);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tvalr &= ~(entry->mask << entry->register_region.bit_offset);\n\t\tval |= valr;\n\t}\n\trc = apei_write(val, &entry->register_region);\n\n\treturn rc;\n}\n\nint apei_exec_write_register(struct apei_exec_context *ctx,\n\t\t\t     struct acpi_whea_header *entry)\n{\n\treturn __apei_exec_write_register(entry, ctx->value);\n}\nEXPORT_SYMBOL_GPL(apei_exec_write_register);\n\nint apei_exec_write_register_value(struct apei_exec_context *ctx,\n\t\t\t\t   struct acpi_whea_header *entry)\n{\n\tctx->value = entry->value;\n\n\treturn apei_exec_write_register(ctx, entry);\n}\nEXPORT_SYMBOL_GPL(apei_exec_write_register_value);\n\nint apei_exec_noop(struct apei_exec_context *ctx,\n\t\t   struct acpi_whea_header *entry)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apei_exec_noop);\n\n \nint __apei_exec_run(struct apei_exec_context *ctx, u8 action,\n\t\t    bool optional)\n{\n\tint rc = -ENOENT;\n\tu32 i, ip;\n\tstruct acpi_whea_header *entry;\n\tapei_exec_ins_func_t run;\n\n\tctx->ip = 0;\n\n\t \nrewind:\n\tip = 0;\n\tfor (i = 0; i < ctx->entries; i++) {\n\t\tentry = &ctx->action_table[i];\n\t\tif (entry->action != action)\n\t\t\tcontinue;\n\t\tif (ip == ctx->ip) {\n\t\t\tif (entry->instruction >= ctx->instructions ||\n\t\t\t    !ctx->ins_table[entry->instruction].run) {\n\t\t\t\tpr_warn(FW_WARN APEI_PFX\n\t\t\t\t\t\"Invalid action table, unknown instruction type: %d\\n\",\n\t\t\t\t\tentry->instruction);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\trun = ctx->ins_table[entry->instruction].run;\n\t\t\trc = run(ctx, entry);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\telse if (rc != APEI_EXEC_SET_IP)\n\t\t\t\tctx->ip++;\n\t\t}\n\t\tip++;\n\t\tif (ctx->ip < ip)\n\t\t\tgoto rewind;\n\t}\n\n\treturn !optional && rc < 0 ? rc : 0;\n}\nEXPORT_SYMBOL_GPL(__apei_exec_run);\n\ntypedef int (*apei_exec_entry_func_t)(struct apei_exec_context *ctx,\n\t\t\t\t      struct acpi_whea_header *entry,\n\t\t\t\t      void *data);\n\nstatic int apei_exec_for_each_entry(struct apei_exec_context *ctx,\n\t\t\t\t    apei_exec_entry_func_t func,\n\t\t\t\t    void *data,\n\t\t\t\t    int *end)\n{\n\tu8 ins;\n\tint i, rc;\n\tstruct acpi_whea_header *entry;\n\tstruct apei_exec_ins_type *ins_table = ctx->ins_table;\n\n\tfor (i = 0; i < ctx->entries; i++) {\n\t\tentry = ctx->action_table + i;\n\t\tins = entry->instruction;\n\t\tif (end)\n\t\t\t*end = i;\n\t\tif (ins >= ctx->instructions || !ins_table[ins].run) {\n\t\t\tpr_warn(FW_WARN APEI_PFX\n\t\t\t\t\"Invalid action table, unknown instruction type: %d\\n\",\n\t\t\t\tins);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trc = func(ctx, entry, data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int pre_map_gar_callback(struct apei_exec_context *ctx,\n\t\t\t\tstruct acpi_whea_header *entry,\n\t\t\t\tvoid *data)\n{\n\tu8 ins = entry->instruction;\n\n\tif (ctx->ins_table[ins].flags & APEI_EXEC_INS_ACCESS_REGISTER)\n\t\treturn apei_map_generic_address(&entry->register_region);\n\n\treturn 0;\n}\n\n \nint apei_exec_pre_map_gars(struct apei_exec_context *ctx)\n{\n\tint rc, end;\n\n\trc = apei_exec_for_each_entry(ctx, pre_map_gar_callback,\n\t\t\t\t      NULL, &end);\n\tif (rc) {\n\t\tstruct apei_exec_context ctx_unmap;\n\t\tmemcpy(&ctx_unmap, ctx, sizeof(*ctx));\n\t\tctx_unmap.entries = end;\n\t\tapei_exec_post_unmap_gars(&ctx_unmap);\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(apei_exec_pre_map_gars);\n\nstatic int post_unmap_gar_callback(struct apei_exec_context *ctx,\n\t\t\t\t   struct acpi_whea_header *entry,\n\t\t\t\t   void *data)\n{\n\tu8 ins = entry->instruction;\n\n\tif (ctx->ins_table[ins].flags & APEI_EXEC_INS_ACCESS_REGISTER)\n\t\tapei_unmap_generic_address(&entry->register_region);\n\n\treturn 0;\n}\n\n \nint apei_exec_post_unmap_gars(struct apei_exec_context *ctx)\n{\n\treturn apei_exec_for_each_entry(ctx, post_unmap_gar_callback,\n\t\t\t\t\tNULL, NULL);\n}\nEXPORT_SYMBOL_GPL(apei_exec_post_unmap_gars);\n\n \nstruct apei_res {\n\tstruct list_head list;\n\tunsigned long start;\n\tunsigned long end;\n};\n\n \nstatic struct apei_resources apei_resources_all = {\n\t.iomem = LIST_HEAD_INIT(apei_resources_all.iomem),\n\t.ioport = LIST_HEAD_INIT(apei_resources_all.ioport),\n};\n\nstatic int apei_res_add(struct list_head *res_list,\n\t\t\tunsigned long start, unsigned long size)\n{\n\tstruct apei_res *res, *resn, *res_ins = NULL;\n\tunsigned long end = start + size;\n\n\tif (end <= start)\n\t\treturn 0;\nrepeat:\n\tlist_for_each_entry_safe(res, resn, res_list, list) {\n\t\tif (res->start > end || res->end < start)\n\t\t\tcontinue;\n\t\telse if (end <= res->end && start >= res->start) {\n\t\t\tkfree(res_ins);\n\t\t\treturn 0;\n\t\t}\n\t\tlist_del(&res->list);\n\t\tres->start = start = min(res->start, start);\n\t\tres->end = end = max(res->end, end);\n\t\tkfree(res_ins);\n\t\tres_ins = res;\n\t\tgoto repeat;\n\t}\n\n\tif (res_ins)\n\t\tlist_add(&res_ins->list, res_list);\n\telse {\n\t\tres_ins = kmalloc(sizeof(*res_ins), GFP_KERNEL);\n\t\tif (!res_ins)\n\t\t\treturn -ENOMEM;\n\t\tres_ins->start = start;\n\t\tres_ins->end = end;\n\t\tlist_add(&res_ins->list, res_list);\n\t}\n\n\treturn 0;\n}\n\nstatic int apei_res_sub(struct list_head *res_list1,\n\t\t\tstruct list_head *res_list2)\n{\n\tstruct apei_res *res1, *resn1, *res2, *res;\n\tres1 = list_entry(res_list1->next, struct apei_res, list);\n\tresn1 = list_entry(res1->list.next, struct apei_res, list);\n\twhile (&res1->list != res_list1) {\n\t\tlist_for_each_entry(res2, res_list2, list) {\n\t\t\tif (res1->start >= res2->end ||\n\t\t\t    res1->end <= res2->start)\n\t\t\t\tcontinue;\n\t\t\telse if (res1->end <= res2->end &&\n\t\t\t\t res1->start >= res2->start) {\n\t\t\t\tlist_del(&res1->list);\n\t\t\t\tkfree(res1);\n\t\t\t\tbreak;\n\t\t\t} else if (res1->end > res2->end &&\n\t\t\t\t   res1->start < res2->start) {\n\t\t\t\tres = kmalloc(sizeof(*res), GFP_KERNEL);\n\t\t\t\tif (!res)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\tres->start = res2->end;\n\t\t\t\tres->end = res1->end;\n\t\t\t\tres1->end = res2->start;\n\t\t\t\tlist_add(&res->list, &res1->list);\n\t\t\t\tresn1 = res;\n\t\t\t} else {\n\t\t\t\tif (res1->start < res2->start)\n\t\t\t\t\tres1->end = res2->start;\n\t\t\t\telse\n\t\t\t\t\tres1->start = res2->end;\n\t\t\t}\n\t\t}\n\t\tres1 = resn1;\n\t\tresn1 = list_entry(resn1->list.next, struct apei_res, list);\n\t}\n\n\treturn 0;\n}\n\nstatic void apei_res_clean(struct list_head *res_list)\n{\n\tstruct apei_res *res, *resn;\n\n\tlist_for_each_entry_safe(res, resn, res_list, list) {\n\t\tlist_del(&res->list);\n\t\tkfree(res);\n\t}\n}\n\nvoid apei_resources_fini(struct apei_resources *resources)\n{\n\tapei_res_clean(&resources->iomem);\n\tapei_res_clean(&resources->ioport);\n}\nEXPORT_SYMBOL_GPL(apei_resources_fini);\n\nstatic int apei_resources_merge(struct apei_resources *resources1,\n\t\t\t\tstruct apei_resources *resources2)\n{\n\tint rc;\n\tstruct apei_res *res;\n\n\tlist_for_each_entry(res, &resources2->iomem, list) {\n\t\trc = apei_res_add(&resources1->iomem, res->start,\n\t\t\t\t  res->end - res->start);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tlist_for_each_entry(res, &resources2->ioport, list) {\n\t\trc = apei_res_add(&resources1->ioport, res->start,\n\t\t\t\t  res->end - res->start);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nint apei_resources_add(struct apei_resources *resources,\n\t\t       unsigned long start, unsigned long size,\n\t\t       bool iomem)\n{\n\tif (iomem)\n\t\treturn apei_res_add(&resources->iomem, start, size);\n\telse\n\t\treturn apei_res_add(&resources->ioport, start, size);\n}\nEXPORT_SYMBOL_GPL(apei_resources_add);\n\n \nint apei_resources_sub(struct apei_resources *resources1,\n\t\t       struct apei_resources *resources2)\n{\n\tint rc;\n\n\trc = apei_res_sub(&resources1->iomem, &resources2->iomem);\n\tif (rc)\n\t\treturn rc;\n\treturn apei_res_sub(&resources1->ioport, &resources2->ioport);\n}\nEXPORT_SYMBOL_GPL(apei_resources_sub);\n\nstatic int apei_get_res_callback(__u64 start, __u64 size, void *data)\n{\n\tstruct apei_resources *resources = data;\n\treturn apei_res_add(&resources->iomem, start, size);\n}\n\nstatic int apei_get_nvs_resources(struct apei_resources *resources)\n{\n\treturn acpi_nvs_for_each_region(apei_get_res_callback, resources);\n}\n\nint (*arch_apei_filter_addr)(int (*func)(__u64 start, __u64 size,\n\t\t\t\t     void *data), void *data);\nstatic int apei_get_arch_resources(struct apei_resources *resources)\n\n{\n\treturn arch_apei_filter_addr(apei_get_res_callback, resources);\n}\n\n \nint apei_resources_request(struct apei_resources *resources,\n\t\t\t   const char *desc)\n{\n\tstruct apei_res *res, *res_bak = NULL;\n\tstruct resource *r;\n\tstruct apei_resources nvs_resources, arch_res;\n\tint rc;\n\n\trc = apei_resources_sub(resources, &apei_resources_all);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tapei_resources_init(&nvs_resources);\n\trc = apei_get_nvs_resources(&nvs_resources);\n\tif (rc)\n\t\tgoto nvs_res_fini;\n\trc = apei_resources_sub(resources, &nvs_resources);\n\tif (rc)\n\t\tgoto nvs_res_fini;\n\n\tif (arch_apei_filter_addr) {\n\t\tapei_resources_init(&arch_res);\n\t\trc = apei_get_arch_resources(&arch_res);\n\t\tif (rc)\n\t\t\tgoto arch_res_fini;\n\t\trc = apei_resources_sub(resources, &arch_res);\n\t\tif (rc)\n\t\t\tgoto arch_res_fini;\n\t}\n\n\trc = -EINVAL;\n\tlist_for_each_entry(res, &resources->iomem, list) {\n\t\tr = request_mem_region(res->start, res->end - res->start,\n\t\t\t\t       desc);\n\t\tif (!r) {\n\t\t\tpr_err(APEI_PFX\n\t\t\"Can not request [mem %#010llx-%#010llx] for %s registers\\n\",\n\t\t\t       (unsigned long long)res->start,\n\t\t\t       (unsigned long long)res->end - 1, desc);\n\t\t\tres_bak = res;\n\t\t\tgoto err_unmap_iomem;\n\t\t}\n\t}\n\n\tlist_for_each_entry(res, &resources->ioport, list) {\n\t\tr = request_region(res->start, res->end - res->start, desc);\n\t\tif (!r) {\n\t\t\tpr_err(APEI_PFX\n\t\t\"Can not request [io  %#06llx-%#06llx] for %s registers\\n\",\n\t\t\t       (unsigned long long)res->start,\n\t\t\t       (unsigned long long)res->end - 1, desc);\n\t\t\tres_bak = res;\n\t\t\tgoto err_unmap_ioport;\n\t\t}\n\t}\n\n\trc = apei_resources_merge(&apei_resources_all, resources);\n\tif (rc) {\n\t\tpr_err(APEI_PFX \"Fail to merge resources!\\n\");\n\t\tgoto err_unmap_ioport;\n\t}\n\n\tgoto arch_res_fini;\n\nerr_unmap_ioport:\n\tlist_for_each_entry(res, &resources->ioport, list) {\n\t\tif (res == res_bak)\n\t\t\tbreak;\n\t\trelease_region(res->start, res->end - res->start);\n\t}\n\tres_bak = NULL;\nerr_unmap_iomem:\n\tlist_for_each_entry(res, &resources->iomem, list) {\n\t\tif (res == res_bak)\n\t\t\tbreak;\n\t\trelease_mem_region(res->start, res->end - res->start);\n\t}\narch_res_fini:\n\tif (arch_apei_filter_addr)\n\t\tapei_resources_fini(&arch_res);\nnvs_res_fini:\n\tapei_resources_fini(&nvs_resources);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(apei_resources_request);\n\nvoid apei_resources_release(struct apei_resources *resources)\n{\n\tint rc;\n\tstruct apei_res *res;\n\n\tlist_for_each_entry(res, &resources->iomem, list)\n\t\trelease_mem_region(res->start, res->end - res->start);\n\tlist_for_each_entry(res, &resources->ioport, list)\n\t\trelease_region(res->start, res->end - res->start);\n\n\trc = apei_resources_sub(&apei_resources_all, resources);\n\tif (rc)\n\t\tpr_err(APEI_PFX \"Fail to sub resources!\\n\");\n}\nEXPORT_SYMBOL_GPL(apei_resources_release);\n\nstatic int apei_check_gar(struct acpi_generic_address *reg, u64 *paddr,\n\t\t\t\tu32 *access_bit_width)\n{\n\tu32 bit_width, bit_offset, access_size_code, space_id;\n\n\tbit_width = reg->bit_width;\n\tbit_offset = reg->bit_offset;\n\taccess_size_code = reg->access_width;\n\tspace_id = reg->space_id;\n\t*paddr = get_unaligned(&reg->address);\n\tif (!*paddr) {\n\t\tpr_warn(FW_BUG APEI_PFX\n\t\t\t\"Invalid physical address in GAR [0x%llx/%u/%u/%u/%u]\\n\",\n\t\t\t*paddr, bit_width, bit_offset, access_size_code,\n\t\t\tspace_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (access_size_code < 1 || access_size_code > 4) {\n\t\tpr_warn(FW_BUG APEI_PFX\n\t\t\t\"Invalid access size code in GAR [0x%llx/%u/%u/%u/%u]\\n\",\n\t\t\t*paddr, bit_width, bit_offset, access_size_code,\n\t\t\tspace_id);\n\t\treturn -EINVAL;\n\t}\n\t*access_bit_width = 1UL << (access_size_code + 2);\n\n\t \n\tif (bit_width == 32 && bit_offset == 0 && (*paddr & 0x03) == 0 &&\n\t    *access_bit_width < 32)\n\t\t*access_bit_width = 32;\n\telse if (bit_width == 64 && bit_offset == 0 && (*paddr & 0x07) == 0 &&\n\t    *access_bit_width < 64)\n\t\t*access_bit_width = 64;\n\n\tif ((bit_width + bit_offset) > *access_bit_width) {\n\t\tpr_warn(FW_BUG APEI_PFX\n\t\t\t\"Invalid bit width + offset in GAR [0x%llx/%u/%u/%u/%u]\\n\",\n\t\t\t*paddr, bit_width, bit_offset, access_size_code,\n\t\t\tspace_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY &&\n\t    space_id != ACPI_ADR_SPACE_SYSTEM_IO) {\n\t\tpr_warn(FW_BUG APEI_PFX\n\t\t\t\"Invalid address space type in GAR [0x%llx/%u/%u/%u/%u]\\n\",\n\t\t\t*paddr, bit_width, bit_offset, access_size_code,\n\t\t\tspace_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint apei_map_generic_address(struct acpi_generic_address *reg)\n{\n\tint rc;\n\tu32 access_bit_width;\n\tu64 address;\n\n\trc = apei_check_gar(reg, &address, &access_bit_width);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (reg->space_id == ACPI_ADR_SPACE_SYSTEM_IO)\n\t\treturn 0;\n\n\tif (!acpi_os_map_generic_address(reg))\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apei_map_generic_address);\n\n \nint apei_read(u64 *val, struct acpi_generic_address *reg)\n{\n\tint rc;\n\tu32 access_bit_width;\n\tu64 address;\n\tacpi_status status;\n\n\trc = apei_check_gar(reg, &address, &access_bit_width);\n\tif (rc)\n\t\treturn rc;\n\n\t*val = 0;\n\tswitch(reg->space_id) {\n\tcase ACPI_ADR_SPACE_SYSTEM_MEMORY:\n\t\tstatus = acpi_os_read_memory((acpi_physical_address) address,\n\t\t\t\t\t       val, access_bit_width);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase ACPI_ADR_SPACE_SYSTEM_IO:\n\t\tstatus = acpi_os_read_port(address, (u32 *)val,\n\t\t\t\t\t   access_bit_width);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apei_read);\n\n \nint apei_write(u64 val, struct acpi_generic_address *reg)\n{\n\tint rc;\n\tu32 access_bit_width;\n\tu64 address;\n\tacpi_status status;\n\n\trc = apei_check_gar(reg, &address, &access_bit_width);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (reg->space_id) {\n\tcase ACPI_ADR_SPACE_SYSTEM_MEMORY:\n\t\tstatus = acpi_os_write_memory((acpi_physical_address) address,\n\t\t\t\t\t\tval, access_bit_width);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tcase ACPI_ADR_SPACE_SYSTEM_IO:\n\t\tstatus = acpi_os_write_port(address, val, access_bit_width);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -EIO;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(apei_write);\n\nstatic int collect_res_callback(struct apei_exec_context *ctx,\n\t\t\t\tstruct acpi_whea_header *entry,\n\t\t\t\tvoid *data)\n{\n\tstruct apei_resources *resources = data;\n\tstruct acpi_generic_address *reg = &entry->register_region;\n\tu8 ins = entry->instruction;\n\tu32 access_bit_width;\n\tu64 paddr;\n\tint rc;\n\n\tif (!(ctx->ins_table[ins].flags & APEI_EXEC_INS_ACCESS_REGISTER))\n\t\treturn 0;\n\n\trc = apei_check_gar(reg, &paddr, &access_bit_width);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (reg->space_id) {\n\tcase ACPI_ADR_SPACE_SYSTEM_MEMORY:\n\t\treturn apei_res_add(&resources->iomem, paddr,\n\t\t\t\t    access_bit_width / 8);\n\tcase ACPI_ADR_SPACE_SYSTEM_IO:\n\t\treturn apei_res_add(&resources->ioport, paddr,\n\t\t\t\t    access_bit_width / 8);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nint apei_exec_collect_resources(struct apei_exec_context *ctx,\n\t\t\t\tstruct apei_resources *resources)\n{\n\treturn apei_exec_for_each_entry(ctx, collect_res_callback,\n\t\t\t\t\tresources, NULL);\n}\nEXPORT_SYMBOL_GPL(apei_exec_collect_resources);\n\nstruct dentry *apei_get_debugfs_dir(void)\n{\n\tstatic struct dentry *dapei;\n\n\tif (!dapei)\n\t\tdapei = debugfs_create_dir(\"apei\", NULL);\n\n\treturn dapei;\n}\nEXPORT_SYMBOL_GPL(apei_get_debugfs_dir);\n\nint __weak arch_apei_enable_cmcff(struct acpi_hest_header *hest_hdr,\n\t\t\t\t  void *data)\n{\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(arch_apei_enable_cmcff);\n\nvoid __weak arch_apei_report_mem_error(int sev,\n\t\t\t\t       struct cper_sec_mem_err *mem_err)\n{\n}\nEXPORT_SYMBOL_GPL(arch_apei_report_mem_error);\n\nint apei_osc_setup(void)\n{\n\tstatic u8 whea_uuid_str[] = \"ed855e0c-6c90-47bf-a62a-26de0fc5ad5c\";\n\tacpi_handle handle;\n\tu32 capbuf[3];\n\tstruct acpi_osc_context context = {\n\t\t.uuid_str\t= whea_uuid_str,\n\t\t.rev\t\t= 1,\n\t\t.cap.length\t= sizeof(capbuf),\n\t\t.cap.pointer\t= capbuf,\n\t};\n\n\tcapbuf[OSC_QUERY_DWORD] = OSC_QUERY_ENABLE;\n\tcapbuf[OSC_SUPPORT_DWORD] = 1;\n\tcapbuf[OSC_CONTROL_DWORD] = 0;\n\n\tif (ACPI_FAILURE(acpi_get_handle(NULL, \"\\\\_SB\", &handle))\n\t    || ACPI_FAILURE(acpi_run_osc(handle, &context)))\n\t\treturn -EIO;\n\telse {\n\t\tkfree(context.ret.pointer);\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(apei_osc_setup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}