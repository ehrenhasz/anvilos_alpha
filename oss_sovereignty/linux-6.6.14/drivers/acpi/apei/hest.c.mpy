{
  "module_name": "hest.c",
  "hash_id": "c2e56f4b9c15a48a245b7bc37bedfa46901756e3e8e1fc210dbb092548e23f97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/apei/hest.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/kdebug.h>\n#include <linux/highmem.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <acpi/apei.h>\n#include <acpi/ghes.h>\n\n#include \"apei-internal.h\"\n\n#define HEST_PFX \"HEST: \"\n\nint hest_disable;\nEXPORT_SYMBOL_GPL(hest_disable);\n\n \n\nstatic struct acpi_table_hest *__read_mostly hest_tab;\n\nstatic const int hest_esrc_len_tab[ACPI_HEST_TYPE_RESERVED] = {\n\t[ACPI_HEST_TYPE_IA32_CHECK] = -1,\t \n\t[ACPI_HEST_TYPE_IA32_CORRECTED_CHECK] = -1,\n\t[ACPI_HEST_TYPE_IA32_NMI] = sizeof(struct acpi_hest_ia_nmi),\n\t[ACPI_HEST_TYPE_AER_ROOT_PORT] = sizeof(struct acpi_hest_aer_root),\n\t[ACPI_HEST_TYPE_AER_ENDPOINT] = sizeof(struct acpi_hest_aer),\n\t[ACPI_HEST_TYPE_AER_BRIDGE] = sizeof(struct acpi_hest_aer_bridge),\n\t[ACPI_HEST_TYPE_GENERIC_ERROR] = sizeof(struct acpi_hest_generic),\n\t[ACPI_HEST_TYPE_GENERIC_ERROR_V2] = sizeof(struct acpi_hest_generic_v2),\n\t[ACPI_HEST_TYPE_IA32_DEFERRED_CHECK] = -1,\n};\n\nstatic inline bool is_generic_error(struct acpi_hest_header *hest_hdr)\n{\n\treturn hest_hdr->type == ACPI_HEST_TYPE_GENERIC_ERROR ||\n\t       hest_hdr->type == ACPI_HEST_TYPE_GENERIC_ERROR_V2;\n}\n\nstatic int hest_esrc_len(struct acpi_hest_header *hest_hdr)\n{\n\tu16 hest_type = hest_hdr->type;\n\tint len;\n\n\tif (hest_type >= ACPI_HEST_TYPE_RESERVED)\n\t\treturn 0;\n\n\tlen = hest_esrc_len_tab[hest_type];\n\n\tif (hest_type == ACPI_HEST_TYPE_IA32_CORRECTED_CHECK) {\n\t\tstruct acpi_hest_ia_corrected *cmc;\n\t\tcmc = (struct acpi_hest_ia_corrected *)hest_hdr;\n\t\tlen = sizeof(*cmc) + cmc->num_hardware_banks *\n\t\t\tsizeof(struct acpi_hest_ia_error_bank);\n\t} else if (hest_type == ACPI_HEST_TYPE_IA32_CHECK) {\n\t\tstruct acpi_hest_ia_machine_check *mc;\n\t\tmc = (struct acpi_hest_ia_machine_check *)hest_hdr;\n\t\tlen = sizeof(*mc) + mc->num_hardware_banks *\n\t\t\tsizeof(struct acpi_hest_ia_error_bank);\n\t} else if (hest_type == ACPI_HEST_TYPE_IA32_DEFERRED_CHECK) {\n\t\tstruct acpi_hest_ia_deferred_check *mc;\n\t\tmc = (struct acpi_hest_ia_deferred_check *)hest_hdr;\n\t\tlen = sizeof(*mc) + mc->num_hardware_banks *\n\t\t\tsizeof(struct acpi_hest_ia_error_bank);\n\t}\n\tBUG_ON(len == -1);\n\n\treturn len;\n};\n\ntypedef int (*apei_hest_func_t)(struct acpi_hest_header *hest_hdr, void *data);\n\nstatic int apei_hest_parse(apei_hest_func_t func, void *data)\n{\n\tstruct acpi_hest_header *hest_hdr;\n\tint i, rc, len;\n\n\tif (hest_disable || !hest_tab)\n\t\treturn -EINVAL;\n\n\thest_hdr = (struct acpi_hest_header *)(hest_tab + 1);\n\tfor (i = 0; i < hest_tab->error_source_count; i++) {\n\t\tlen = hest_esrc_len(hest_hdr);\n\t\tif (!len) {\n\t\t\tpr_warn(FW_WARN HEST_PFX\n\t\t\t\t\"Unknown or unused hardware error source \"\n\t\t\t\t\"type: %d for hardware error source: %d.\\n\",\n\t\t\t\thest_hdr->type, hest_hdr->source_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((void *)hest_hdr + len >\n\t\t    (void *)hest_tab + hest_tab->header.length) {\n\t\t\tpr_warn(FW_BUG HEST_PFX\n\t\t\"Table contents overflow for hardware error source: %d.\\n\",\n\t\t\t\thest_hdr->source_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trc = func(hest_hdr, data);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\thest_hdr = (void *)hest_hdr + len;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __init hest_parse_cmc(struct acpi_hest_header *hest_hdr, void *data)\n{\n\tif (hest_hdr->type != ACPI_HEST_TYPE_IA32_CORRECTED_CHECK)\n\t\treturn 0;\n\n\tif (!acpi_disable_cmcff)\n\t\treturn !arch_apei_enable_cmcff(hest_hdr, data);\n\n\treturn 0;\n}\n\nstruct ghes_arr {\n\tstruct platform_device **ghes_devs;\n\tunsigned int count;\n};\n\nstatic int __init hest_parse_ghes_count(struct acpi_hest_header *hest_hdr, void *data)\n{\n\tint *count = data;\n\n\tif (is_generic_error(hest_hdr))\n\t\t(*count)++;\n\treturn 0;\n}\n\nstatic int __init hest_parse_ghes(struct acpi_hest_header *hest_hdr, void *data)\n{\n\tstruct platform_device *ghes_dev;\n\tstruct ghes_arr *ghes_arr = data;\n\tint rc, i;\n\n\tif (!is_generic_error(hest_hdr))\n\t\treturn 0;\n\n\tif (!((struct acpi_hest_generic *)hest_hdr)->enabled)\n\t\treturn 0;\n\tfor (i = 0; i < ghes_arr->count; i++) {\n\t\tstruct acpi_hest_header *hdr;\n\t\tghes_dev = ghes_arr->ghes_devs[i];\n\t\thdr = *(struct acpi_hest_header **)ghes_dev->dev.platform_data;\n\t\tif (hdr->source_id == hest_hdr->source_id) {\n\t\t\tpr_warn(FW_WARN HEST_PFX \"Duplicated hardware error source ID: %d.\\n\",\n\t\t\t\thdr->source_id);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tghes_dev = platform_device_alloc(\"GHES\", hest_hdr->source_id);\n\tif (!ghes_dev)\n\t\treturn -ENOMEM;\n\n\trc = platform_device_add_data(ghes_dev, &hest_hdr, sizeof(void *));\n\tif (rc)\n\t\tgoto err;\n\n\trc = platform_device_add(ghes_dev);\n\tif (rc)\n\t\tgoto err;\n\tghes_arr->ghes_devs[ghes_arr->count++] = ghes_dev;\n\n\treturn 0;\nerr:\n\tplatform_device_put(ghes_dev);\n\treturn rc;\n}\n\nstatic int __init hest_ghes_dev_register(unsigned int ghes_count)\n{\n\tint rc, i;\n\tstruct ghes_arr ghes_arr;\n\n\tghes_arr.count = 0;\n\tghes_arr.ghes_devs = kmalloc_array(ghes_count, sizeof(void *),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ghes_arr.ghes_devs)\n\t\treturn -ENOMEM;\n\n\trc = apei_hest_parse(hest_parse_ghes, &ghes_arr);\n\tif (rc)\n\t\tgoto err;\n\n\trc = ghes_estatus_pool_init(ghes_count);\n\tif (rc)\n\t\tgoto err;\n\nout:\n\tkfree(ghes_arr.ghes_devs);\n\treturn rc;\nerr:\n\tfor (i = 0; i < ghes_arr.count; i++)\n\t\tplatform_device_unregister(ghes_arr.ghes_devs[i]);\n\tgoto out;\n}\n\nstatic int __init setup_hest_disable(char *str)\n{\n\thest_disable = HEST_DISABLED;\n\treturn 1;\n}\n\n__setup(\"hest_disable\", setup_hest_disable);\n\nvoid __init acpi_hest_init(void)\n{\n\tacpi_status status;\n\tint rc;\n\tunsigned int ghes_count = 0;\n\n\tif (hest_disable) {\n\t\tpr_info(HEST_PFX \"Table parsing disabled.\\n\");\n\t\treturn;\n\t}\n\n\tstatus = acpi_get_table(ACPI_SIG_HEST, 0,\n\t\t\t\t(struct acpi_table_header **)&hest_tab);\n\tif (status == AE_NOT_FOUND) {\n\t\thest_disable = HEST_NOT_FOUND;\n\t\treturn;\n\t} else if (ACPI_FAILURE(status)) {\n\t\tconst char *msg = acpi_format_exception(status);\n\t\tpr_err(HEST_PFX \"Failed to get table, %s\\n\", msg);\n\t\thest_disable = HEST_DISABLED;\n\t\treturn;\n\t}\n\n\trc = apei_hest_parse(hest_parse_cmc, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\tif (!ghes_disable) {\n\t\trc = apei_hest_parse(hest_parse_ghes_count, &ghes_count);\n\t\tif (rc)\n\t\t\tgoto err;\n\n\t\tif (ghes_count)\n\t\t\trc = hest_ghes_dev_register(ghes_count);\n\t\tif (rc)\n\t\t\tgoto err;\n\t}\n\n\tpr_info(HEST_PFX \"Table parsing has been initialized.\\n\");\n\treturn;\nerr:\n\thest_disable = HEST_DISABLED;\n\tacpi_put_table((struct acpi_table_header *)hest_tab);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}