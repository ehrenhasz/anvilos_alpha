{
  "module_name": "erst-dbg.c",
  "hash_id": "5ccf3101a3a745d6f06f2b00d9c021f935db69e45c426b38e07cf7aed94b0e72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/apei/erst-dbg.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <acpi/apei.h>\n#include <linux/miscdevice.h>\n\n#include \"apei-internal.h\"\n\n#define ERST_DBG_PFX\t\t\t\"ERST DBG: \"\n\n#define ERST_DBG_RECORD_LEN_MAX\t\t0x4000\n\nstatic void *erst_dbg_buf;\nstatic unsigned int erst_dbg_buf_len;\n\n \nstatic DEFINE_MUTEX(erst_dbg_mutex);\n\nstatic int erst_dbg_open(struct inode *inode, struct file *file)\n{\n\tint rc, *pos;\n\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\tpos = (int *)&file->private_data;\n\n\trc = erst_get_record_id_begin(pos);\n\tif (rc)\n\t\treturn rc;\n\n\treturn nonseekable_open(inode, file);\n}\n\nstatic int erst_dbg_release(struct inode *inode, struct file *file)\n{\n\terst_get_record_id_end();\n\n\treturn 0;\n}\n\nstatic long erst_dbg_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tint rc;\n\tu64 record_id;\n\tu32 record_count;\n\n\tswitch (cmd) {\n\tcase APEI_ERST_CLEAR_RECORD:\n\t\trc = copy_from_user(&record_id, (void __user *)arg,\n\t\t\t\t    sizeof(record_id));\n\t\tif (rc)\n\t\t\treturn -EFAULT;\n\t\treturn erst_clear(record_id);\n\tcase APEI_ERST_GET_RECORD_COUNT:\n\t\trc = erst_get_record_count();\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trecord_count = rc;\n\t\trc = put_user(record_count, (u32 __user *)arg);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\nstatic ssize_t erst_dbg_read(struct file *filp, char __user *ubuf,\n\t\t\t     size_t usize, loff_t *off)\n{\n\tint rc, *pos;\n\tssize_t len = 0;\n\tu64 id;\n\n\tif (*off)\n\t\treturn -EINVAL;\n\n\tif (mutex_lock_interruptible(&erst_dbg_mutex) != 0)\n\t\treturn -EINTR;\n\n\tpos = (int *)&filp->private_data;\n\nretry_next:\n\trc = erst_get_record_id_next(pos, &id);\n\tif (rc)\n\t\tgoto out;\n\t \n\tif (id == APEI_ERST_INVALID_RECORD_ID) {\n\t\t \n\t\tlen = 0;\n\n\t\tgoto out;\n\t}\nretry:\n\trc = len = erst_read_record(id, erst_dbg_buf, erst_dbg_buf_len,\n\t\t\terst_dbg_buf_len, NULL);\n\t \n\tif (rc == -ENOENT)\n\t\tgoto retry_next;\n\tif (rc < 0)\n\t\tgoto out;\n\tif (len > ERST_DBG_RECORD_LEN_MAX) {\n\t\tpr_warn(ERST_DBG_PFX\n\t\t\t\"Record (ID: 0x%llx) length is too long: %zd\\n\", id, len);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (len > erst_dbg_buf_len) {\n\t\tvoid *p;\n\t\trc = -ENOMEM;\n\t\tp = kmalloc(len, GFP_KERNEL);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\tkfree(erst_dbg_buf);\n\t\terst_dbg_buf = p;\n\t\terst_dbg_buf_len = len;\n\t\tgoto retry;\n\t}\n\n\trc = -EINVAL;\n\tif (len > usize)\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (copy_to_user(ubuf, erst_dbg_buf, len))\n\t\tgoto out;\n\trc = 0;\nout:\n\tmutex_unlock(&erst_dbg_mutex);\n\treturn rc ? rc : len;\n}\n\nstatic ssize_t erst_dbg_write(struct file *filp, const char __user *ubuf,\n\t\t\t      size_t usize, loff_t *off)\n{\n\tint rc;\n\tstruct cper_record_header *rcd;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (usize > ERST_DBG_RECORD_LEN_MAX) {\n\t\tpr_err(ERST_DBG_PFX \"Too long record to be written\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mutex_lock_interruptible(&erst_dbg_mutex))\n\t\treturn -EINTR;\n\tif (usize > erst_dbg_buf_len) {\n\t\tvoid *p;\n\t\trc = -ENOMEM;\n\t\tp = kmalloc(usize, GFP_KERNEL);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\tkfree(erst_dbg_buf);\n\t\terst_dbg_buf = p;\n\t\terst_dbg_buf_len = usize;\n\t}\n\trc = copy_from_user(erst_dbg_buf, ubuf, usize);\n\tif (rc) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\trcd = erst_dbg_buf;\n\trc = -EINVAL;\n\tif (rcd->record_length != usize)\n\t\tgoto out;\n\n\trc = erst_write(erst_dbg_buf);\n\nout:\n\tmutex_unlock(&erst_dbg_mutex);\n\treturn rc < 0 ? rc : usize;\n}\n\nstatic const struct file_operations erst_dbg_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= erst_dbg_open,\n\t.release\t= erst_dbg_release,\n\t.read\t\t= erst_dbg_read,\n\t.write\t\t= erst_dbg_write,\n\t.unlocked_ioctl\t= erst_dbg_ioctl,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice erst_dbg_dev = {\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.name\t= \"erst_dbg\",\n\t.fops\t= &erst_dbg_ops,\n};\n\nstatic __init int erst_dbg_init(void)\n{\n\tif (erst_disable) {\n\t\tpr_info(ERST_DBG_PFX \"ERST support is disabled.\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn misc_register(&erst_dbg_dev);\n}\n\nstatic __exit void erst_dbg_exit(void)\n{\n\tmisc_deregister(&erst_dbg_dev);\n\tkfree(erst_dbg_buf);\n}\n\nmodule_init(erst_dbg_init);\nmodule_exit(erst_dbg_exit);\n\nMODULE_AUTHOR(\"Huang Ying\");\nMODULE_DESCRIPTION(\"APEI Error Record Serialization Table debug support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}