{
  "module_name": "erst.c",
  "hash_id": "6330adf75f86c0efbb6aa3908020f7797c0ddf1dd7cbe1a573f2882dd4043497",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/apei/erst.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/acpi.h>\n#include <linux/uaccess.h>\n#include <linux/cper.h>\n#include <linux/nmi.h>\n#include <linux/hardirq.h>\n#include <linux/pstore.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>  \n#include <acpi/apei.h>\n\n#include \"apei-internal.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"ERST: \" fmt\n\n \n#define ERST_STATUS_SUCCESS\t\t\t0x0\n#define ERST_STATUS_NOT_ENOUGH_SPACE\t\t0x1\n#define ERST_STATUS_HARDWARE_NOT_AVAILABLE\t0x2\n#define ERST_STATUS_FAILED\t\t\t0x3\n#define ERST_STATUS_RECORD_STORE_EMPTY\t\t0x4\n#define ERST_STATUS_RECORD_NOT_FOUND\t\t0x5\n\n#define ERST_TAB_ENTRY(tab)\t\t\t\t\t\t\\\n\t((struct acpi_whea_header *)((char *)(tab) +\t\t\t\\\n\t\t\t\t     sizeof(struct acpi_table_erst)))\n\n#define SPIN_UNIT\t\t100\t\t\t \n \n#define FIRMWARE_TIMEOUT\t(1 * NSEC_PER_MSEC)\n#define FIRMWARE_MAX_STALL\t50\t\t\t \n\nint erst_disable;\nEXPORT_SYMBOL_GPL(erst_disable);\n\nstatic struct acpi_table_erst *erst_tab;\n\n \n#define ERST_RANGE_RESERVED\t0x0001\n#define ERST_RANGE_NVRAM\t0x0002\n#define ERST_RANGE_SLOW\t\t0x0004\n\n \nstatic struct erst_erange {\n\tu64 base;\n\tu64 size;\n\tvoid __iomem *vaddr;\n\tu32 attr;\n} erst_erange;\n\n \nstatic DEFINE_RAW_SPINLOCK(erst_lock);\n\nstatic inline int erst_errno(int command_status)\n{\n\tswitch (command_status) {\n\tcase ERST_STATUS_SUCCESS:\n\t\treturn 0;\n\tcase ERST_STATUS_HARDWARE_NOT_AVAILABLE:\n\t\treturn -ENODEV;\n\tcase ERST_STATUS_NOT_ENOUGH_SPACE:\n\t\treturn -ENOSPC;\n\tcase ERST_STATUS_RECORD_STORE_EMPTY:\n\tcase ERST_STATUS_RECORD_NOT_FOUND:\n\t\treturn -ENOENT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int erst_timedout(u64 *t, u64 spin_unit)\n{\n\tif ((s64)*t < spin_unit) {\n\t\tpr_warn(FW_WARN \"Firmware does not respond in time.\\n\");\n\t\treturn 1;\n\t}\n\t*t -= spin_unit;\n\tndelay(spin_unit);\n\ttouch_nmi_watchdog();\n\treturn 0;\n}\n\nstatic int erst_exec_load_var1(struct apei_exec_context *ctx,\n\t\t\t       struct acpi_whea_header *entry)\n{\n\treturn __apei_exec_read_register(entry, &ctx->var1);\n}\n\nstatic int erst_exec_load_var2(struct apei_exec_context *ctx,\n\t\t\t       struct acpi_whea_header *entry)\n{\n\treturn __apei_exec_read_register(entry, &ctx->var2);\n}\n\nstatic int erst_exec_store_var1(struct apei_exec_context *ctx,\n\t\t\t\tstruct acpi_whea_header *entry)\n{\n\treturn __apei_exec_write_register(entry, ctx->var1);\n}\n\nstatic int erst_exec_add(struct apei_exec_context *ctx,\n\t\t\t struct acpi_whea_header *entry)\n{\n\tctx->var1 += ctx->var2;\n\treturn 0;\n}\n\nstatic int erst_exec_subtract(struct apei_exec_context *ctx,\n\t\t\t      struct acpi_whea_header *entry)\n{\n\tctx->var1 -= ctx->var2;\n\treturn 0;\n}\n\nstatic int erst_exec_add_value(struct apei_exec_context *ctx,\n\t\t\t       struct acpi_whea_header *entry)\n{\n\tint rc;\n\tu64 val;\n\n\trc = __apei_exec_read_register(entry, &val);\n\tif (rc)\n\t\treturn rc;\n\tval += ctx->value;\n\trc = __apei_exec_write_register(entry, val);\n\treturn rc;\n}\n\nstatic int erst_exec_subtract_value(struct apei_exec_context *ctx,\n\t\t\t\t    struct acpi_whea_header *entry)\n{\n\tint rc;\n\tu64 val;\n\n\trc = __apei_exec_read_register(entry, &val);\n\tif (rc)\n\t\treturn rc;\n\tval -= ctx->value;\n\trc = __apei_exec_write_register(entry, val);\n\treturn rc;\n}\n\nstatic int erst_exec_stall(struct apei_exec_context *ctx,\n\t\t\t   struct acpi_whea_header *entry)\n{\n\tu64 stall_time;\n\n\tif (ctx->value > FIRMWARE_MAX_STALL) {\n\t\tif (!in_nmi())\n\t\t\tpr_warn(FW_WARN\n\t\t\t\"Too long stall time for stall instruction: 0x%llx.\\n\",\n\t\t\t\t   ctx->value);\n\t\tstall_time = FIRMWARE_MAX_STALL;\n\t} else\n\t\tstall_time = ctx->value;\n\tudelay(stall_time);\n\treturn 0;\n}\n\nstatic int erst_exec_stall_while_true(struct apei_exec_context *ctx,\n\t\t\t\t      struct acpi_whea_header *entry)\n{\n\tint rc;\n\tu64 val;\n\tu64 timeout = FIRMWARE_TIMEOUT;\n\tu64 stall_time;\n\n\tif (ctx->var1 > FIRMWARE_MAX_STALL) {\n\t\tif (!in_nmi())\n\t\t\tpr_warn(FW_WARN\n\t\t\"Too long stall time for stall while true instruction: 0x%llx.\\n\",\n\t\t\t\t   ctx->var1);\n\t\tstall_time = FIRMWARE_MAX_STALL;\n\t} else\n\t\tstall_time = ctx->var1;\n\n\tfor (;;) {\n\t\trc = __apei_exec_read_register(entry, &val);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (val != ctx->value)\n\t\t\tbreak;\n\t\tif (erst_timedout(&timeout, stall_time * NSEC_PER_USEC))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int erst_exec_skip_next_instruction_if_true(\n\tstruct apei_exec_context *ctx,\n\tstruct acpi_whea_header *entry)\n{\n\tint rc;\n\tu64 val;\n\n\trc = __apei_exec_read_register(entry, &val);\n\tif (rc)\n\t\treturn rc;\n\tif (val == ctx->value) {\n\t\tctx->ip += 2;\n\t\treturn APEI_EXEC_SET_IP;\n\t}\n\n\treturn 0;\n}\n\nstatic int erst_exec_goto(struct apei_exec_context *ctx,\n\t\t\t  struct acpi_whea_header *entry)\n{\n\tctx->ip = ctx->value;\n\treturn APEI_EXEC_SET_IP;\n}\n\nstatic int erst_exec_set_src_address_base(struct apei_exec_context *ctx,\n\t\t\t\t\t  struct acpi_whea_header *entry)\n{\n\treturn __apei_exec_read_register(entry, &ctx->src_base);\n}\n\nstatic int erst_exec_set_dst_address_base(struct apei_exec_context *ctx,\n\t\t\t\t\t  struct acpi_whea_header *entry)\n{\n\treturn __apei_exec_read_register(entry, &ctx->dst_base);\n}\n\nstatic int erst_exec_move_data(struct apei_exec_context *ctx,\n\t\t\t       struct acpi_whea_header *entry)\n{\n\tint rc;\n\tu64 offset;\n\tvoid *src, *dst;\n\n\t \n\tif (in_interrupt()) {\n\t\tpr_warn(\"MOVE_DATA can not be used in interrupt context.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\trc = __apei_exec_read_register(entry, &offset);\n\tif (rc)\n\t\treturn rc;\n\n\tsrc = ioremap(ctx->src_base + offset, ctx->var2);\n\tif (!src)\n\t\treturn -ENOMEM;\n\tdst = ioremap(ctx->dst_base + offset, ctx->var2);\n\tif (!dst) {\n\t\tiounmap(src);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemmove(dst, src, ctx->var2);\n\n\tiounmap(src);\n\tiounmap(dst);\n\n\treturn 0;\n}\n\nstatic struct apei_exec_ins_type erst_ins_type[] = {\n\t[ACPI_ERST_READ_REGISTER] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = apei_exec_read_register,\n\t},\n\t[ACPI_ERST_READ_REGISTER_VALUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = apei_exec_read_register_value,\n\t},\n\t[ACPI_ERST_WRITE_REGISTER] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = apei_exec_write_register,\n\t},\n\t[ACPI_ERST_WRITE_REGISTER_VALUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = apei_exec_write_register_value,\n\t},\n\t[ACPI_ERST_NOOP] = {\n\t\t.flags = 0,\n\t\t.run = apei_exec_noop,\n\t},\n\t[ACPI_ERST_LOAD_VAR1] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_load_var1,\n\t},\n\t[ACPI_ERST_LOAD_VAR2] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_load_var2,\n\t},\n\t[ACPI_ERST_STORE_VAR1] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_store_var1,\n\t},\n\t[ACPI_ERST_ADD] = {\n\t\t.flags = 0,\n\t\t.run = erst_exec_add,\n\t},\n\t[ACPI_ERST_SUBTRACT] = {\n\t\t.flags = 0,\n\t\t.run = erst_exec_subtract,\n\t},\n\t[ACPI_ERST_ADD_VALUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_add_value,\n\t},\n\t[ACPI_ERST_SUBTRACT_VALUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_subtract_value,\n\t},\n\t[ACPI_ERST_STALL] = {\n\t\t.flags = 0,\n\t\t.run = erst_exec_stall,\n\t},\n\t[ACPI_ERST_STALL_WHILE_TRUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_stall_while_true,\n\t},\n\t[ACPI_ERST_SKIP_NEXT_IF_TRUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_skip_next_instruction_if_true,\n\t},\n\t[ACPI_ERST_GOTO] = {\n\t\t.flags = 0,\n\t\t.run = erst_exec_goto,\n\t},\n\t[ACPI_ERST_SET_SRC_ADDRESS_BASE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_set_src_address_base,\n\t},\n\t[ACPI_ERST_SET_DST_ADDRESS_BASE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_set_dst_address_base,\n\t},\n\t[ACPI_ERST_MOVE_DATA] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run = erst_exec_move_data,\n\t},\n};\n\nstatic inline void erst_exec_ctx_init(struct apei_exec_context *ctx)\n{\n\tapei_exec_ctx_init(ctx, erst_ins_type, ARRAY_SIZE(erst_ins_type),\n\t\t\t   ERST_TAB_ENTRY(erst_tab), erst_tab->entries);\n}\n\nstatic int erst_get_erange(struct erst_erange *range)\n{\n\tstruct apei_exec_context ctx;\n\tint rc;\n\n\terst_exec_ctx_init(&ctx);\n\trc = apei_exec_run(&ctx, ACPI_ERST_GET_ERROR_RANGE);\n\tif (rc)\n\t\treturn rc;\n\trange->base = apei_exec_ctx_get_output(&ctx);\n\trc = apei_exec_run(&ctx, ACPI_ERST_GET_ERROR_LENGTH);\n\tif (rc)\n\t\treturn rc;\n\trange->size = apei_exec_ctx_get_output(&ctx);\n\trc = apei_exec_run(&ctx, ACPI_ERST_GET_ERROR_ATTRIBUTES);\n\tif (rc)\n\t\treturn rc;\n\trange->attr = apei_exec_ctx_get_output(&ctx);\n\n\treturn 0;\n}\n\nstatic ssize_t __erst_get_record_count(void)\n{\n\tstruct apei_exec_context ctx;\n\tint rc;\n\n\terst_exec_ctx_init(&ctx);\n\trc = apei_exec_run(&ctx, ACPI_ERST_GET_RECORD_COUNT);\n\tif (rc)\n\t\treturn rc;\n\treturn apei_exec_ctx_get_output(&ctx);\n}\n\nssize_t erst_get_record_count(void)\n{\n\tssize_t count;\n\tunsigned long flags;\n\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\traw_spin_lock_irqsave(&erst_lock, flags);\n\tcount = __erst_get_record_count();\n\traw_spin_unlock_irqrestore(&erst_lock, flags);\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(erst_get_record_count);\n\n#define ERST_RECORD_ID_CACHE_SIZE_MIN\t16\n#define ERST_RECORD_ID_CACHE_SIZE_MAX\t1024\n\nstruct erst_record_id_cache {\n\tstruct mutex lock;\n\tu64 *entries;\n\tint len;\n\tint size;\n\tint refcount;\n};\n\nstatic struct erst_record_id_cache erst_record_id_cache = {\n\t.lock = __MUTEX_INITIALIZER(erst_record_id_cache.lock),\n\t.refcount = 0,\n};\n\nstatic int __erst_get_next_record_id(u64 *record_id)\n{\n\tstruct apei_exec_context ctx;\n\tint rc;\n\n\terst_exec_ctx_init(&ctx);\n\trc = apei_exec_run(&ctx, ACPI_ERST_GET_RECORD_ID);\n\tif (rc)\n\t\treturn rc;\n\t*record_id = apei_exec_ctx_get_output(&ctx);\n\n\treturn 0;\n}\n\nint erst_get_record_id_begin(int *pos)\n{\n\tint rc;\n\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\trc = mutex_lock_interruptible(&erst_record_id_cache.lock);\n\tif (rc)\n\t\treturn rc;\n\terst_record_id_cache.refcount++;\n\tmutex_unlock(&erst_record_id_cache.lock);\n\n\t*pos = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(erst_get_record_id_begin);\n\n \nstatic int __erst_record_id_cache_add_one(void)\n{\n\tu64 id, prev_id, first_id;\n\tint i, rc;\n\tu64 *entries;\n\tunsigned long flags;\n\n\tid = prev_id = first_id = APEI_ERST_INVALID_RECORD_ID;\nretry:\n\traw_spin_lock_irqsave(&erst_lock, flags);\n\trc = __erst_get_next_record_id(&id);\n\traw_spin_unlock_irqrestore(&erst_lock, flags);\n\tif (rc == -ENOENT)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\tif (id == APEI_ERST_INVALID_RECORD_ID)\n\t\treturn 0;\n\t \n\tif (id == prev_id || id == first_id)\n\t\treturn 0;\n\tif (first_id == APEI_ERST_INVALID_RECORD_ID)\n\t\tfirst_id = id;\n\tprev_id = id;\n\n\tentries = erst_record_id_cache.entries;\n\tfor (i = 0; i < erst_record_id_cache.len; i++) {\n\t\tif (entries[i] == id)\n\t\t\tbreak;\n\t}\n\t \n\tif (i < erst_record_id_cache.len)\n\t\tgoto retry;\n\tif (erst_record_id_cache.len >= erst_record_id_cache.size) {\n\t\tint new_size;\n\t\tu64 *new_entries;\n\n\t\tnew_size = erst_record_id_cache.size * 2;\n\t\tnew_size = clamp_val(new_size, ERST_RECORD_ID_CACHE_SIZE_MIN,\n\t\t\t\t     ERST_RECORD_ID_CACHE_SIZE_MAX);\n\t\tif (new_size <= erst_record_id_cache.size) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tpr_warn(FW_WARN \"too many record IDs!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tnew_entries = kvmalloc_array(new_size, sizeof(entries[0]),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!new_entries)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(new_entries, entries,\n\t\t       erst_record_id_cache.len * sizeof(entries[0]));\n\t\tkvfree(entries);\n\t\terst_record_id_cache.entries = entries = new_entries;\n\t\terst_record_id_cache.size = new_size;\n\t}\n\tentries[i] = id;\n\terst_record_id_cache.len++;\n\n\treturn 1;\n}\n\n \nint erst_get_record_id_next(int *pos, u64 *record_id)\n{\n\tint rc = 0;\n\tu64 *entries;\n\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\t \n\tBUG_ON(!erst_record_id_cache.refcount);\n\tBUG_ON(*pos < 0 || *pos > erst_record_id_cache.len);\n\n\tmutex_lock(&erst_record_id_cache.lock);\n\tentries = erst_record_id_cache.entries;\n\tfor (; *pos < erst_record_id_cache.len; (*pos)++)\n\t\tif (entries[*pos] != APEI_ERST_INVALID_RECORD_ID)\n\t\t\tbreak;\n\t \n\tif (*pos < erst_record_id_cache.len) {\n\t\t*record_id = entries[*pos];\n\t\t(*pos)++;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\trc = __erst_record_id_cache_add_one();\n\tif (rc < 0)\n\t\tgoto out_unlock;\n\t \n\tif (rc == 1) {\n\t\t*record_id = erst_record_id_cache.entries[*pos];\n\t\t(*pos)++;\n\t\trc = 0;\n\t} else {\n\t\t*pos = -1;\n\t\t*record_id = APEI_ERST_INVALID_RECORD_ID;\n\t}\nout_unlock:\n\tmutex_unlock(&erst_record_id_cache.lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(erst_get_record_id_next);\n\n \nstatic void __erst_record_id_cache_compact(void)\n{\n\tint i, wpos = 0;\n\tu64 *entries;\n\n\tif (erst_record_id_cache.refcount)\n\t\treturn;\n\n\tentries = erst_record_id_cache.entries;\n\tfor (i = 0; i < erst_record_id_cache.len; i++) {\n\t\tif (entries[i] == APEI_ERST_INVALID_RECORD_ID)\n\t\t\tcontinue;\n\t\tif (wpos != i)\n\t\t\tentries[wpos] = entries[i];\n\t\twpos++;\n\t}\n\terst_record_id_cache.len = wpos;\n}\n\nvoid erst_get_record_id_end(void)\n{\n\t \n\tBUG_ON(erst_disable);\n\n\tmutex_lock(&erst_record_id_cache.lock);\n\terst_record_id_cache.refcount--;\n\tBUG_ON(erst_record_id_cache.refcount < 0);\n\t__erst_record_id_cache_compact();\n\tmutex_unlock(&erst_record_id_cache.lock);\n}\nEXPORT_SYMBOL_GPL(erst_get_record_id_end);\n\nstatic int __erst_write_to_storage(u64 offset)\n{\n\tstruct apei_exec_context ctx;\n\tu64 timeout = FIRMWARE_TIMEOUT;\n\tu64 val;\n\tint rc;\n\n\terst_exec_ctx_init(&ctx);\n\trc = apei_exec_run_optional(&ctx, ACPI_ERST_BEGIN_WRITE);\n\tif (rc)\n\t\treturn rc;\n\tapei_exec_ctx_set_input(&ctx, offset);\n\trc = apei_exec_run(&ctx, ACPI_ERST_SET_RECORD_OFFSET);\n\tif (rc)\n\t\treturn rc;\n\trc = apei_exec_run(&ctx, ACPI_ERST_EXECUTE_OPERATION);\n\tif (rc)\n\t\treturn rc;\n\tfor (;;) {\n\t\trc = apei_exec_run(&ctx, ACPI_ERST_CHECK_BUSY_STATUS);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tval = apei_exec_ctx_get_output(&ctx);\n\t\tif (!val)\n\t\t\tbreak;\n\t\tif (erst_timedout(&timeout, SPIN_UNIT))\n\t\t\treturn -EIO;\n\t}\n\trc = apei_exec_run(&ctx, ACPI_ERST_GET_COMMAND_STATUS);\n\tif (rc)\n\t\treturn rc;\n\tval = apei_exec_ctx_get_output(&ctx);\n\trc = apei_exec_run_optional(&ctx, ACPI_ERST_END);\n\tif (rc)\n\t\treturn rc;\n\n\treturn erst_errno(val);\n}\n\nstatic int __erst_read_from_storage(u64 record_id, u64 offset)\n{\n\tstruct apei_exec_context ctx;\n\tu64 timeout = FIRMWARE_TIMEOUT;\n\tu64 val;\n\tint rc;\n\n\terst_exec_ctx_init(&ctx);\n\trc = apei_exec_run_optional(&ctx, ACPI_ERST_BEGIN_READ);\n\tif (rc)\n\t\treturn rc;\n\tapei_exec_ctx_set_input(&ctx, offset);\n\trc = apei_exec_run(&ctx, ACPI_ERST_SET_RECORD_OFFSET);\n\tif (rc)\n\t\treturn rc;\n\tapei_exec_ctx_set_input(&ctx, record_id);\n\trc = apei_exec_run(&ctx, ACPI_ERST_SET_RECORD_ID);\n\tif (rc)\n\t\treturn rc;\n\trc = apei_exec_run(&ctx, ACPI_ERST_EXECUTE_OPERATION);\n\tif (rc)\n\t\treturn rc;\n\tfor (;;) {\n\t\trc = apei_exec_run(&ctx, ACPI_ERST_CHECK_BUSY_STATUS);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tval = apei_exec_ctx_get_output(&ctx);\n\t\tif (!val)\n\t\t\tbreak;\n\t\tif (erst_timedout(&timeout, SPIN_UNIT))\n\t\t\treturn -EIO;\n\t}\n\trc = apei_exec_run(&ctx, ACPI_ERST_GET_COMMAND_STATUS);\n\tif (rc)\n\t\treturn rc;\n\tval = apei_exec_ctx_get_output(&ctx);\n\trc = apei_exec_run_optional(&ctx, ACPI_ERST_END);\n\tif (rc)\n\t\treturn rc;\n\n\treturn erst_errno(val);\n}\n\nstatic int __erst_clear_from_storage(u64 record_id)\n{\n\tstruct apei_exec_context ctx;\n\tu64 timeout = FIRMWARE_TIMEOUT;\n\tu64 val;\n\tint rc;\n\n\terst_exec_ctx_init(&ctx);\n\trc = apei_exec_run_optional(&ctx, ACPI_ERST_BEGIN_CLEAR);\n\tif (rc)\n\t\treturn rc;\n\tapei_exec_ctx_set_input(&ctx, record_id);\n\trc = apei_exec_run(&ctx, ACPI_ERST_SET_RECORD_ID);\n\tif (rc)\n\t\treturn rc;\n\trc = apei_exec_run(&ctx, ACPI_ERST_EXECUTE_OPERATION);\n\tif (rc)\n\t\treturn rc;\n\tfor (;;) {\n\t\trc = apei_exec_run(&ctx, ACPI_ERST_CHECK_BUSY_STATUS);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tval = apei_exec_ctx_get_output(&ctx);\n\t\tif (!val)\n\t\t\tbreak;\n\t\tif (erst_timedout(&timeout, SPIN_UNIT))\n\t\t\treturn -EIO;\n\t}\n\trc = apei_exec_run(&ctx, ACPI_ERST_GET_COMMAND_STATUS);\n\tif (rc)\n\t\treturn rc;\n\tval = apei_exec_ctx_get_output(&ctx);\n\trc = apei_exec_run_optional(&ctx, ACPI_ERST_END);\n\tif (rc)\n\t\treturn rc;\n\n\treturn erst_errno(val);\n}\n\n \nstatic void pr_unimpl_nvram(void)\n{\n\tif (printk_ratelimit())\n\t\tpr_warn(\"NVRAM ERST Log Address Range not implemented yet.\\n\");\n}\n\nstatic int __erst_write_to_nvram(const struct cper_record_header *record)\n{\n\t \n\treturn -ENOSYS;\n}\n\nstatic int __erst_read_to_erange_from_nvram(u64 record_id, u64 *offset)\n{\n\tpr_unimpl_nvram();\n\treturn -ENOSYS;\n}\n\nstatic int __erst_clear_from_nvram(u64 record_id)\n{\n\tpr_unimpl_nvram();\n\treturn -ENOSYS;\n}\n\nint erst_write(const struct cper_record_header *record)\n{\n\tint rc;\n\tunsigned long flags;\n\tstruct cper_record_header *rcd_erange;\n\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\tif (memcmp(record->signature, CPER_SIG_RECORD, CPER_SIG_SIZE))\n\t\treturn -EINVAL;\n\n\tif (erst_erange.attr & ERST_RANGE_NVRAM) {\n\t\tif (!raw_spin_trylock_irqsave(&erst_lock, flags))\n\t\t\treturn -EBUSY;\n\t\trc = __erst_write_to_nvram(record);\n\t\traw_spin_unlock_irqrestore(&erst_lock, flags);\n\t\treturn rc;\n\t}\n\n\tif (record->record_length > erst_erange.size)\n\t\treturn -EINVAL;\n\n\tif (!raw_spin_trylock_irqsave(&erst_lock, flags))\n\t\treturn -EBUSY;\n\tmemcpy(erst_erange.vaddr, record, record->record_length);\n\trcd_erange = erst_erange.vaddr;\n\t \n\tmemcpy(&rcd_erange->persistence_information, \"ER\", 2);\n\n\trc = __erst_write_to_storage(0);\n\traw_spin_unlock_irqrestore(&erst_lock, flags);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(erst_write);\n\nstatic int __erst_read_to_erange(u64 record_id, u64 *offset)\n{\n\tint rc;\n\n\tif (erst_erange.attr & ERST_RANGE_NVRAM)\n\t\treturn __erst_read_to_erange_from_nvram(\n\t\t\trecord_id, offset);\n\n\trc = __erst_read_from_storage(record_id, 0);\n\tif (rc)\n\t\treturn rc;\n\t*offset = 0;\n\n\treturn 0;\n}\n\nstatic ssize_t __erst_read(u64 record_id, struct cper_record_header *record,\n\t\t\t   size_t buflen)\n{\n\tint rc;\n\tu64 offset, len = 0;\n\tstruct cper_record_header *rcd_tmp;\n\n\trc = __erst_read_to_erange(record_id, &offset);\n\tif (rc)\n\t\treturn rc;\n\trcd_tmp = erst_erange.vaddr + offset;\n\tlen = rcd_tmp->record_length;\n\tif (len <= buflen)\n\t\tmemcpy(record, rcd_tmp, len);\n\n\treturn len;\n}\n\n \nssize_t erst_read(u64 record_id, struct cper_record_header *record,\n\t\t  size_t buflen)\n{\n\tssize_t len;\n\tunsigned long flags;\n\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\traw_spin_lock_irqsave(&erst_lock, flags);\n\tlen = __erst_read(record_id, record, buflen);\n\traw_spin_unlock_irqrestore(&erst_lock, flags);\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(erst_read);\n\nstatic void erst_clear_cache(u64 record_id)\n{\n\tint i;\n\tu64 *entries;\n\n\tmutex_lock(&erst_record_id_cache.lock);\n\n\tentries = erst_record_id_cache.entries;\n\tfor (i = 0; i < erst_record_id_cache.len; i++) {\n\t\tif (entries[i] == record_id)\n\t\t\tentries[i] = APEI_ERST_INVALID_RECORD_ID;\n\t}\n\t__erst_record_id_cache_compact();\n\n\tmutex_unlock(&erst_record_id_cache.lock);\n}\n\nssize_t erst_read_record(u64 record_id, struct cper_record_header *record,\n\t\tsize_t buflen, size_t recordlen, const guid_t *creatorid)\n{\n\tssize_t len;\n\n\t \n\tif (creatorid == NULL) {\n\t\tlen = erst_read(record_id, record, buflen);\n\t\tif (len == -ENOENT)\n\t\t\terst_clear_cache(record_id);\n\n\t\treturn len;\n\t}\n\n\tlen = erst_read(record_id, record, buflen);\n\t \n\tif (len == -ENOENT) {\n\t\terst_clear_cache(record_id);\n\t\tgoto out;\n\t}\n\n\tif (len < 0)\n\t\tgoto out;\n\n\t \n\tif (len < recordlen) {\n\t\tlen = -EIO;\n\t\terst_clear_cache(record_id);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!guid_equal(&record->creator_id, creatorid))\n\t\tlen = -ENOENT;\n\nout:\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(erst_read_record);\n\nint erst_clear(u64 record_id)\n{\n\tint rc, i;\n\tunsigned long flags;\n\tu64 *entries;\n\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\trc = mutex_lock_interruptible(&erst_record_id_cache.lock);\n\tif (rc)\n\t\treturn rc;\n\traw_spin_lock_irqsave(&erst_lock, flags);\n\tif (erst_erange.attr & ERST_RANGE_NVRAM)\n\t\trc = __erst_clear_from_nvram(record_id);\n\telse\n\t\trc = __erst_clear_from_storage(record_id);\n\traw_spin_unlock_irqrestore(&erst_lock, flags);\n\tif (rc)\n\t\tgoto out;\n\tentries = erst_record_id_cache.entries;\n\tfor (i = 0; i < erst_record_id_cache.len; i++) {\n\t\tif (entries[i] == record_id)\n\t\t\tentries[i] = APEI_ERST_INVALID_RECORD_ID;\n\t}\n\t__erst_record_id_cache_compact();\nout:\n\tmutex_unlock(&erst_record_id_cache.lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(erst_clear);\n\nstatic int __init setup_erst_disable(char *str)\n{\n\terst_disable = 1;\n\treturn 1;\n}\n\n__setup(\"erst_disable\", setup_erst_disable);\n\nstatic int erst_check_table(struct acpi_table_erst *erst_tab)\n{\n\tif ((erst_tab->header_length !=\n\t     (sizeof(struct acpi_table_erst) - sizeof(erst_tab->header)))\n\t    && (erst_tab->header_length != sizeof(struct acpi_table_erst)))\n\t\treturn -EINVAL;\n\tif (erst_tab->header.length < sizeof(struct acpi_table_erst))\n\t\treturn -EINVAL;\n\tif (erst_tab->entries !=\n\t    (erst_tab->header.length - sizeof(struct acpi_table_erst)) /\n\t    sizeof(struct acpi_erst_entry))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int erst_open_pstore(struct pstore_info *psi);\nstatic int erst_close_pstore(struct pstore_info *psi);\nstatic ssize_t erst_reader(struct pstore_record *record);\nstatic int erst_writer(struct pstore_record *record);\nstatic int erst_clearer(struct pstore_record *record);\n\nstatic struct pstore_info erst_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"erst\",\n\t.flags\t\t= PSTORE_FLAGS_DMESG,\n\t.open\t\t= erst_open_pstore,\n\t.close\t\t= erst_close_pstore,\n\t.read\t\t= erst_reader,\n\t.write\t\t= erst_writer,\n\t.erase\t\t= erst_clearer\n};\n\n#define CPER_CREATOR_PSTORE\t\t\t\t\t\t\\\n\tGUID_INIT(0x75a574e3, 0x5052, 0x4b29, 0x8a, 0x8e, 0xbe, 0x2c,\t\\\n\t\t  0x64, 0x90, 0xb8, 0x9d)\n#define CPER_SECTION_TYPE_DMESG\t\t\t\t\t\t\\\n\tGUID_INIT(0xc197e04e, 0xd545, 0x4a70, 0x9c, 0x17, 0xa5, 0x54,\t\\\n\t\t  0x94, 0x19, 0xeb, 0x12)\n#define CPER_SECTION_TYPE_DMESG_Z\t\t\t\t\t\\\n\tGUID_INIT(0x4f118707, 0x04dd, 0x4055, 0xb5, 0xdd, 0x95, 0x6d,\t\\\n\t\t  0x34, 0xdd, 0xfa, 0xc6)\n#define CPER_SECTION_TYPE_MCE\t\t\t\t\t\t\\\n\tGUID_INIT(0xfe08ffbe, 0x95e4, 0x4be7, 0xbc, 0x73, 0x40, 0x96,\t\\\n\t\t  0x04, 0x4a, 0x38, 0xfc)\n\nstruct cper_pstore_record {\n\tstruct cper_record_header hdr;\n\tstruct cper_section_descriptor sec_hdr;\n\tchar data[];\n} __packed;\n\nstatic int reader_pos;\n\nstatic int erst_open_pstore(struct pstore_info *psi)\n{\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\treturn erst_get_record_id_begin(&reader_pos);\n}\n\nstatic int erst_close_pstore(struct pstore_info *psi)\n{\n\terst_get_record_id_end();\n\n\treturn 0;\n}\n\nstatic ssize_t erst_reader(struct pstore_record *record)\n{\n\tint rc;\n\tssize_t len = 0;\n\tu64 record_id;\n\tstruct cper_pstore_record *rcd;\n\tsize_t rcd_len = sizeof(*rcd) + erst_info.bufsize;\n\n\tif (erst_disable)\n\t\treturn -ENODEV;\n\n\trcd = kmalloc(rcd_len, GFP_KERNEL);\n\tif (!rcd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\nskip:\n\trc = erst_get_record_id_next(&reader_pos, &record_id);\n\tif (rc)\n\t\tgoto out;\n\n\t \n\tif (record_id == APEI_ERST_INVALID_RECORD_ID) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = erst_read_record(record_id, &rcd->hdr, rcd_len, sizeof(*rcd),\n\t\t\t&CPER_CREATOR_PSTORE);\n\t \n\tif (len == -ENOENT)\n\t\tgoto skip;\n\telse if (len < 0)\n\t\tgoto out;\n\n\trecord->buf = kmalloc(len, GFP_KERNEL);\n\tif (record->buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(record->buf, rcd->data, len - sizeof(*rcd));\n\trecord->id = record_id;\n\trecord->compressed = false;\n\trecord->ecc_notice_size = 0;\n\tif (guid_equal(&rcd->sec_hdr.section_type, &CPER_SECTION_TYPE_DMESG_Z)) {\n\t\trecord->type = PSTORE_TYPE_DMESG;\n\t\trecord->compressed = true;\n\t} else if (guid_equal(&rcd->sec_hdr.section_type, &CPER_SECTION_TYPE_DMESG))\n\t\trecord->type = PSTORE_TYPE_DMESG;\n\telse if (guid_equal(&rcd->sec_hdr.section_type, &CPER_SECTION_TYPE_MCE))\n\t\trecord->type = PSTORE_TYPE_MCE;\n\telse\n\t\trecord->type = PSTORE_TYPE_MAX;\n\n\tif (rcd->hdr.validation_bits & CPER_VALID_TIMESTAMP)\n\t\trecord->time.tv_sec = rcd->hdr.timestamp;\n\telse\n\t\trecord->time.tv_sec = 0;\n\trecord->time.tv_nsec = 0;\n\nout:\n\tkfree(rcd);\n\treturn (rc < 0) ? rc : (len - sizeof(*rcd));\n}\n\nstatic int erst_writer(struct pstore_record *record)\n{\n\tstruct cper_pstore_record *rcd = (struct cper_pstore_record *)\n\t\t\t\t\t(erst_info.buf - sizeof(*rcd));\n\tint ret;\n\n\tmemset(rcd, 0, sizeof(*rcd));\n\tmemcpy(rcd->hdr.signature, CPER_SIG_RECORD, CPER_SIG_SIZE);\n\trcd->hdr.revision = CPER_RECORD_REV;\n\trcd->hdr.signature_end = CPER_SIG_END;\n\trcd->hdr.section_count = 1;\n\trcd->hdr.error_severity = CPER_SEV_FATAL;\n\t \n\trcd->hdr.validation_bits = CPER_VALID_TIMESTAMP;\n\trcd->hdr.timestamp = ktime_get_real_seconds();\n\trcd->hdr.record_length = sizeof(*rcd) + record->size;\n\trcd->hdr.creator_id = CPER_CREATOR_PSTORE;\n\trcd->hdr.notification_type = CPER_NOTIFY_MCE;\n\trcd->hdr.record_id = cper_next_record_id();\n\trcd->hdr.flags = CPER_HW_ERROR_FLAGS_PREVERR;\n\n\trcd->sec_hdr.section_offset = sizeof(*rcd);\n\trcd->sec_hdr.section_length = record->size;\n\trcd->sec_hdr.revision = CPER_SEC_REV;\n\t \n\trcd->sec_hdr.validation_bits = 0;\n\trcd->sec_hdr.flags = CPER_SEC_PRIMARY;\n\tswitch (record->type) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tif (record->compressed)\n\t\t\trcd->sec_hdr.section_type = CPER_SECTION_TYPE_DMESG_Z;\n\t\telse\n\t\t\trcd->sec_hdr.section_type = CPER_SECTION_TYPE_DMESG;\n\t\tbreak;\n\tcase PSTORE_TYPE_MCE:\n\t\trcd->sec_hdr.section_type = CPER_SECTION_TYPE_MCE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trcd->sec_hdr.section_severity = CPER_SEV_FATAL;\n\n\tret = erst_write(&rcd->hdr);\n\trecord->id = rcd->hdr.record_id;\n\n\treturn ret;\n}\n\nstatic int erst_clearer(struct pstore_record *record)\n{\n\treturn erst_clear(record->id);\n}\n\nstatic int __init erst_init(void)\n{\n\tint rc = 0;\n\tacpi_status status;\n\tstruct apei_exec_context ctx;\n\tstruct apei_resources erst_resources;\n\tstruct resource *r;\n\tchar *buf;\n\n\tif (acpi_disabled)\n\t\tgoto err;\n\n\tif (erst_disable) {\n\t\tpr_info(\n\t\"Error Record Serialization Table (ERST) support is disabled.\\n\");\n\t\tgoto err;\n\t}\n\n\tstatus = acpi_get_table(ACPI_SIG_ERST, 0,\n\t\t\t\t(struct acpi_table_header **)&erst_tab);\n\tif (status == AE_NOT_FOUND)\n\t\tgoto err;\n\telse if (ACPI_FAILURE(status)) {\n\t\tconst char *msg = acpi_format_exception(status);\n\t\tpr_err(\"Failed to get table, %s\\n\", msg);\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\trc = erst_check_table(erst_tab);\n\tif (rc) {\n\t\tpr_err(FW_BUG \"ERST table is invalid.\\n\");\n\t\tgoto err_put_erst_tab;\n\t}\n\n\tapei_resources_init(&erst_resources);\n\terst_exec_ctx_init(&ctx);\n\trc = apei_exec_collect_resources(&ctx, &erst_resources);\n\tif (rc)\n\t\tgoto err_fini;\n\trc = apei_resources_request(&erst_resources, \"APEI ERST\");\n\tif (rc)\n\t\tgoto err_fini;\n\trc = apei_exec_pre_map_gars(&ctx);\n\tif (rc)\n\t\tgoto err_release;\n\trc = erst_get_erange(&erst_erange);\n\tif (rc) {\n\t\tif (rc == -ENODEV)\n\t\t\tpr_info(\n\t\"The corresponding hardware device or firmware implementation \"\n\t\"is not available.\\n\");\n\t\telse\n\t\t\tpr_err(\"Failed to get Error Log Address Range.\\n\");\n\t\tgoto err_unmap_reg;\n\t}\n\n\tr = request_mem_region(erst_erange.base, erst_erange.size, \"APEI ERST\");\n\tif (!r) {\n\t\tpr_err(\"Can not request [mem %#010llx-%#010llx] for ERST.\\n\",\n\t\t       (unsigned long long)erst_erange.base,\n\t\t       (unsigned long long)erst_erange.base + erst_erange.size - 1);\n\t\trc = -EIO;\n\t\tgoto err_unmap_reg;\n\t}\n\trc = -ENOMEM;\n\terst_erange.vaddr = ioremap_cache(erst_erange.base,\n\t\t\t\t\t  erst_erange.size);\n\tif (!erst_erange.vaddr)\n\t\tgoto err_release_erange;\n\n\tpr_info(\n\t\"Error Record Serialization Table (ERST) support is initialized.\\n\");\n\n\tbuf = kmalloc(erst_erange.size, GFP_KERNEL);\n\tif (buf) {\n\t\terst_info.buf = buf + sizeof(struct cper_pstore_record);\n\t\terst_info.bufsize = erst_erange.size -\n\t\t\t\t    sizeof(struct cper_pstore_record);\n\t\trc = pstore_register(&erst_info);\n\t\tif (rc) {\n\t\t\tif (rc != -EPERM)\n\t\t\t\tpr_info(\n\t\t\t\t\"Could not register with persistent store.\\n\");\n\t\t\terst_info.buf = NULL;\n\t\t\terst_info.bufsize = 0;\n\t\t\tkfree(buf);\n\t\t}\n\t} else\n\t\tpr_err(\n\t\t\"Failed to allocate %lld bytes for persistent store error log.\\n\",\n\t\terst_erange.size);\n\n\t \n\tapei_resources_fini(&erst_resources);\n\n\treturn 0;\n\nerr_release_erange:\n\trelease_mem_region(erst_erange.base, erst_erange.size);\nerr_unmap_reg:\n\tapei_exec_post_unmap_gars(&ctx);\nerr_release:\n\tapei_resources_release(&erst_resources);\nerr_fini:\n\tapei_resources_fini(&erst_resources);\nerr_put_erst_tab:\n\tacpi_put_table((struct acpi_table_header *)erst_tab);\nerr:\n\terst_disable = 1;\n\treturn rc;\n}\n\ndevice_initcall(erst_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}