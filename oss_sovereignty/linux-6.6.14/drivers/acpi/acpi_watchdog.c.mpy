{
  "module_name": "acpi_watchdog.c",
  "hash_id": "b9f0f37e69de097ed473431ef04079f4b0c17364a9c152e0b201cbbdb14c4e77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_watchdog.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: watchdog: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n\n#include \"internal.h\"\n\n#ifdef CONFIG_RTC_MC146818_LIB\n#include <linux/mc146818rtc.h>\n\n \nstatic bool acpi_watchdog_uses_rtc(const struct acpi_table_wdat *wdat)\n{\n\tconst struct acpi_wdat_entry *entries;\n\tint i;\n\n\tentries = (struct acpi_wdat_entry *)(wdat + 1);\n\tfor (i = 0; i < wdat->entries; i++) {\n\t\tconst struct acpi_generic_address *gas;\n\n\t\tgas = &entries[i].register_region;\n\t\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\n\t\t\tswitch (gas->address) {\n\t\t\tcase RTC_PORT(0):\n\t\t\tcase RTC_PORT(1):\n\t\t\tcase RTC_PORT(2):\n\t\t\tcase RTC_PORT(3):\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n#else\nstatic bool acpi_watchdog_uses_rtc(const struct acpi_table_wdat *wdat)\n{\n\treturn false;\n}\n#endif\n\nstatic bool acpi_no_watchdog;\n\nstatic const struct acpi_table_wdat *acpi_watchdog_get_wdat(void)\n{\n\tconst struct acpi_table_wdat *wdat = NULL;\n\tacpi_status status;\n\n\tif (acpi_disabled || acpi_no_watchdog)\n\t\treturn NULL;\n\n\tstatus = acpi_get_table(ACPI_SIG_WDAT, 0,\n\t\t\t\t(struct acpi_table_header **)&wdat);\n\tif (ACPI_FAILURE(status)) {\n\t\t \n\t\treturn NULL;\n\t}\n\n\tif (acpi_watchdog_uses_rtc(wdat)) {\n\t\tacpi_put_table((struct acpi_table_header *)wdat);\n\t\tpr_info(\"Skipping WDAT on this system because it uses RTC SRAM\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn wdat;\n}\n\n \nbool acpi_has_watchdog(void)\n{\n\treturn !!acpi_watchdog_get_wdat();\n}\nEXPORT_SYMBOL_GPL(acpi_has_watchdog);\n\n \nstatic int __init disable_acpi_watchdog(char *str)\n{\n\tacpi_no_watchdog = true;\n\treturn 1;\n}\n__setup(\"acpi_no_watchdog\", disable_acpi_watchdog);\n\nvoid __init acpi_watchdog_init(void)\n{\n\tconst struct acpi_wdat_entry *entries;\n\tconst struct acpi_table_wdat *wdat;\n\tstruct list_head resource_list;\n\tstruct resource_entry *rentry;\n\tstruct platform_device *pdev;\n\tstruct resource *resources;\n\tsize_t nresources = 0;\n\tint i;\n\n\twdat = acpi_watchdog_get_wdat();\n\tif (!wdat) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (!(wdat->flags & ACPI_WDAT_ENABLED))\n\t\tgoto fail_put_wdat;\n\n\t \n\tif (wdat->pci_segment != 0xff || wdat->pci_bus != 0xff ||\n\t    wdat->pci_device != 0xff || wdat->pci_function != 0xff)\n\t\tgoto fail_put_wdat;\n\n\tINIT_LIST_HEAD(&resource_list);\n\n\tentries = (struct acpi_wdat_entry *)(wdat + 1);\n\tfor (i = 0; i < wdat->entries; i++) {\n\t\tconst struct acpi_generic_address *gas;\n\t\tstruct resource_entry *rentry;\n\t\tstruct resource res = {};\n\t\tbool found;\n\n\t\tgas = &entries[i].register_region;\n\n\t\tres.start = gas->address;\n\t\tres.end = res.start + ACPI_ACCESS_BYTE_WIDTH(gas->access_width) - 1;\n\t\tif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n\t\t\tres.flags = IORESOURCE_MEM;\n\t\t} else if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO) {\n\t\t\tres.flags = IORESOURCE_IO;\n\t\t} else {\n\t\t\tpr_warn(\"Unsupported address space: %u\\n\",\n\t\t\t\tgas->space_id);\n\t\t\tgoto fail_free_resource_list;\n\t\t}\n\n\t\tfound = false;\n\t\tresource_list_for_each_entry(rentry, &resource_list) {\n\t\t\tif (rentry->res->flags == res.flags &&\n\t\t\t    resource_union(rentry->res, &res, rentry->res)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\trentry = resource_list_create_entry(NULL, 0);\n\t\t\tif (!rentry)\n\t\t\t\tgoto fail_free_resource_list;\n\n\t\t\t*rentry->res = res;\n\t\t\tresource_list_add_tail(rentry, &resource_list);\n\t\t\tnresources++;\n\t\t}\n\t}\n\n\tresources = kcalloc(nresources, sizeof(*resources), GFP_KERNEL);\n\tif (!resources)\n\t\tgoto fail_free_resource_list;\n\n\ti = 0;\n\tresource_list_for_each_entry(rentry, &resource_list)\n\t\tresources[i++] = *rentry->res;\n\n\tpdev = platform_device_register_simple(\"wdat_wdt\", PLATFORM_DEVID_NONE,\n\t\t\t\t\t       resources, nresources);\n\tif (IS_ERR(pdev))\n\t\tpr_err(\"Device creation failed: %ld\\n\", PTR_ERR(pdev));\n\n\tkfree(resources);\n\nfail_free_resource_list:\n\tresource_list_free(&resource_list);\nfail_put_wdat:\n\tacpi_put_table((struct acpi_table_header *)wdat);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}