{
  "module_name": "power.c",
  "hash_id": "cb5ef6971ca81f28425e9ca3fe9fbca712b7d1c3d1b9a66233ca159c1142eabc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/power.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"ACPI: PM: \" fmt\n\n#include <linux/dmi.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/sysfs.h>\n#include <linux/acpi.h>\n#include \"sleep.h\"\n#include \"internal.h\"\n\n#define ACPI_POWER_CLASS\t\t\"power_resource\"\n#define ACPI_POWER_DEVICE_NAME\t\t\"Power Resource\"\n#define ACPI_POWER_RESOURCE_STATE_OFF\t0x00\n#define ACPI_POWER_RESOURCE_STATE_ON\t0x01\n#define ACPI_POWER_RESOURCE_STATE_UNKNOWN 0xFF\n\nstruct acpi_power_dependent_device {\n\tstruct device *dev;\n\tstruct list_head node;\n};\n\nstruct acpi_power_resource {\n\tstruct acpi_device device;\n\tstruct list_head list_node;\n\tu32 system_level;\n\tu32 order;\n\tunsigned int ref_count;\n\tu8 state;\n\tstruct mutex resource_lock;\n\tstruct list_head dependents;\n};\n\nstruct acpi_power_resource_entry {\n\tstruct list_head node;\n\tstruct acpi_power_resource *resource;\n};\n\nstatic LIST_HEAD(acpi_power_resource_list);\nstatic DEFINE_MUTEX(power_resource_list_lock);\n\n \n\nstatic inline const char *resource_dev_name(struct acpi_power_resource *pr)\n{\n\treturn dev_name(&pr->device.dev);\n}\n\nstatic inline\nstruct acpi_power_resource *to_power_resource(struct acpi_device *device)\n{\n\treturn container_of(device, struct acpi_power_resource, device);\n}\n\nstatic struct acpi_power_resource *acpi_power_get_context(acpi_handle handle)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\n\tif (!device)\n\t\treturn NULL;\n\n\treturn to_power_resource(device);\n}\n\nstatic int acpi_power_resources_list_add(acpi_handle handle,\n\t\t\t\t\t struct list_head *list)\n{\n\tstruct acpi_power_resource *resource = acpi_power_get_context(handle);\n\tstruct acpi_power_resource_entry *entry;\n\n\tif (!resource || !list)\n\t\treturn -EINVAL;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->resource = resource;\n\tif (!list_empty(list)) {\n\t\tstruct acpi_power_resource_entry *e;\n\n\t\tlist_for_each_entry(e, list, node)\n\t\t\tif (e->resource->order > resource->order) {\n\t\t\t\tlist_add_tail(&entry->node, &e->node);\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n\tlist_add_tail(&entry->node, list);\n\treturn 0;\n}\n\nvoid acpi_power_resources_list_free(struct list_head *list)\n{\n\tstruct acpi_power_resource_entry *entry, *e;\n\n\tlist_for_each_entry_safe(entry, e, list, node) {\n\t\tlist_del(&entry->node);\n\t\tkfree(entry);\n\t}\n}\n\nstatic bool acpi_power_resource_is_dup(union acpi_object *package,\n\t\t\t\t       unsigned int start, unsigned int i)\n{\n\tacpi_handle rhandle, dup;\n\tunsigned int j;\n\n\t \n\trhandle = package->package.elements[i].reference.handle;\n\tfor (j = start; j < i; j++) {\n\t\tdup = package->package.elements[j].reference.handle;\n\t\tif (dup == rhandle)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint acpi_extract_power_resources(union acpi_object *package, unsigned int start,\n\t\t\t\t struct list_head *list)\n{\n\tunsigned int i;\n\tint err = 0;\n\n\tfor (i = start; i < package->package.count; i++) {\n\t\tunion acpi_object *element = &package->package.elements[i];\n\t\tstruct acpi_device *rdev;\n\t\tacpi_handle rhandle;\n\n\t\tif (element->type != ACPI_TYPE_LOCAL_REFERENCE) {\n\t\t\terr = -ENODATA;\n\t\t\tbreak;\n\t\t}\n\t\trhandle = element->reference.handle;\n\t\tif (!rhandle) {\n\t\t\terr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (acpi_power_resource_is_dup(package, start, i))\n\t\t\tcontinue;\n\n\t\trdev = acpi_add_power_resource(rhandle);\n\t\tif (!rdev) {\n\t\t\terr = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\terr = acpi_power_resources_list_add(rhandle, list);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (err)\n\t\tacpi_power_resources_list_free(list);\n\n\treturn err;\n}\n\nstatic int __get_state(acpi_handle handle, u8 *state)\n{\n\tacpi_status status = AE_OK;\n\tunsigned long long sta = 0;\n\tu8 cur_state;\n\n\tstatus = acpi_evaluate_integer(handle, \"_STA\", NULL, &sta);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tcur_state = sta & ACPI_POWER_RESOURCE_STATE_ON;\n\n\tacpi_handle_debug(handle, \"Power resource is %s\\n\",\n\t\t\t  cur_state ? \"on\" : \"off\");\n\n\t*state = cur_state;\n\treturn 0;\n}\n\nstatic int acpi_power_get_state(struct acpi_power_resource *resource, u8 *state)\n{\n\tif (resource->state == ACPI_POWER_RESOURCE_STATE_UNKNOWN) {\n\t\tint ret;\n\n\t\tret = __get_state(resource->device.handle, &resource->state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*state = resource->state;\n\treturn 0;\n}\n\nstatic int acpi_power_get_list_state(struct list_head *list, u8 *state)\n{\n\tstruct acpi_power_resource_entry *entry;\n\tu8 cur_state = ACPI_POWER_RESOURCE_STATE_OFF;\n\n\tif (!list || !state)\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_entry(entry, list, node) {\n\t\tstruct acpi_power_resource *resource = entry->resource;\n\t\tint result;\n\n\t\tmutex_lock(&resource->resource_lock);\n\t\tresult = acpi_power_get_state(resource, &cur_state);\n\t\tmutex_unlock(&resource->resource_lock);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tif (cur_state != ACPI_POWER_RESOURCE_STATE_ON)\n\t\t\tbreak;\n\t}\n\n\tpr_debug(\"Power resource list is %s\\n\", cur_state ? \"on\" : \"off\");\n\n\t*state = cur_state;\n\treturn 0;\n}\n\nstatic int\nacpi_power_resource_add_dependent(struct acpi_power_resource *resource,\n\t\t\t\t  struct device *dev)\n{\n\tstruct acpi_power_dependent_device *dep;\n\tint ret = 0;\n\n\tmutex_lock(&resource->resource_lock);\n\tlist_for_each_entry(dep, &resource->dependents, node) {\n\t\t \n\t\tif (dep->dev == dev)\n\t\t\tgoto unlock;\n\t}\n\n\tdep = kzalloc(sizeof(*dep), GFP_KERNEL);\n\tif (!dep) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tdep->dev = dev;\n\tlist_add_tail(&dep->node, &resource->dependents);\n\tdev_dbg(dev, \"added power dependency to [%s]\\n\",\n\t\tresource_dev_name(resource));\n\nunlock:\n\tmutex_unlock(&resource->resource_lock);\n\treturn ret;\n}\n\nstatic void\nacpi_power_resource_remove_dependent(struct acpi_power_resource *resource,\n\t\t\t\t     struct device *dev)\n{\n\tstruct acpi_power_dependent_device *dep;\n\n\tmutex_lock(&resource->resource_lock);\n\tlist_for_each_entry(dep, &resource->dependents, node) {\n\t\tif (dep->dev == dev) {\n\t\t\tlist_del(&dep->node);\n\t\t\tkfree(dep);\n\t\t\tdev_dbg(dev, \"removed power dependency to [%s]\\n\",\n\t\t\t\tresource_dev_name(resource));\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&resource->resource_lock);\n}\n\n \nint acpi_device_power_add_dependent(struct acpi_device *adev,\n\t\t\t\t    struct device *dev)\n{\n\tstruct acpi_power_resource_entry *entry;\n\tstruct list_head *resources;\n\tint ret;\n\n\tif (!adev->flags.power_manageable)\n\t\treturn 0;\n\n\tresources = &adev->power.states[ACPI_STATE_D0].resources;\n\tlist_for_each_entry(entry, resources, node) {\n\t\tret = acpi_power_resource_add_dependent(entry->resource, dev);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tlist_for_each_entry(entry, resources, node)\n\t\tacpi_power_resource_remove_dependent(entry->resource, dev);\n\n\treturn ret;\n}\n\n \nvoid acpi_device_power_remove_dependent(struct acpi_device *adev,\n\t\t\t\t\tstruct device *dev)\n{\n\tstruct acpi_power_resource_entry *entry;\n\tstruct list_head *resources;\n\n\tif (!adev->flags.power_manageable)\n\t\treturn;\n\n\tresources = &adev->power.states[ACPI_STATE_D0].resources;\n\tlist_for_each_entry_reverse(entry, resources, node)\n\t\tacpi_power_resource_remove_dependent(entry->resource, dev);\n}\n\nstatic int __acpi_power_on(struct acpi_power_resource *resource)\n{\n\tacpi_handle handle = resource->device.handle;\n\tstruct acpi_power_dependent_device *dep;\n\tacpi_status status = AE_OK;\n\n\tstatus = acpi_evaluate_object(handle, \"_ON\", NULL, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tresource->state = ACPI_POWER_RESOURCE_STATE_UNKNOWN;\n\t\treturn -ENODEV;\n\t}\n\n\tresource->state = ACPI_POWER_RESOURCE_STATE_ON;\n\n\tacpi_handle_debug(handle, \"Power resource turned on\\n\");\n\n\t \n\tif (list_empty(&resource->dependents) ||\n\t    list_is_singular(&resource->dependents))\n\t\treturn 0;\n\n\tlist_for_each_entry(dep, &resource->dependents, node) {\n\t\tdev_dbg(dep->dev, \"runtime resuming because [%s] turned on\\n\",\n\t\t\tresource_dev_name(resource));\n\t\tpm_request_resume(dep->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int acpi_power_on_unlocked(struct acpi_power_resource *resource)\n{\n\tint result = 0;\n\n\tif (resource->ref_count++) {\n\t\tacpi_handle_debug(resource->device.handle,\n\t\t\t\t  \"Power resource already on\\n\");\n\t} else {\n\t\tresult = __acpi_power_on(resource);\n\t\tif (result)\n\t\t\tresource->ref_count--;\n\t}\n\treturn result;\n}\n\nstatic int acpi_power_on(struct acpi_power_resource *resource)\n{\n\tint result;\n\n\tmutex_lock(&resource->resource_lock);\n\tresult = acpi_power_on_unlocked(resource);\n\tmutex_unlock(&resource->resource_lock);\n\treturn result;\n}\n\nstatic int __acpi_power_off(struct acpi_power_resource *resource)\n{\n\tacpi_handle handle = resource->device.handle;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_object(handle, \"_OFF\", NULL, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tresource->state = ACPI_POWER_RESOURCE_STATE_UNKNOWN;\n\t\treturn -ENODEV;\n\t}\n\n\tresource->state = ACPI_POWER_RESOURCE_STATE_OFF;\n\n\tacpi_handle_debug(handle, \"Power resource turned off\\n\");\n\n\treturn 0;\n}\n\nstatic int acpi_power_off_unlocked(struct acpi_power_resource *resource)\n{\n\tint result = 0;\n\n\tif (!resource->ref_count) {\n\t\tacpi_handle_debug(resource->device.handle,\n\t\t\t\t  \"Power resource already off\\n\");\n\t\treturn 0;\n\t}\n\n\tif (--resource->ref_count) {\n\t\tacpi_handle_debug(resource->device.handle,\n\t\t\t\t  \"Power resource still in use\\n\");\n\t} else {\n\t\tresult = __acpi_power_off(resource);\n\t\tif (result)\n\t\t\tresource->ref_count++;\n\t}\n\treturn result;\n}\n\nstatic int acpi_power_off(struct acpi_power_resource *resource)\n{\n\tint result;\n\n\tmutex_lock(&resource->resource_lock);\n\tresult = acpi_power_off_unlocked(resource);\n\tmutex_unlock(&resource->resource_lock);\n\treturn result;\n}\n\nstatic int acpi_power_off_list(struct list_head *list)\n{\n\tstruct acpi_power_resource_entry *entry;\n\tint result = 0;\n\n\tlist_for_each_entry_reverse(entry, list, node) {\n\t\tresult = acpi_power_off(entry->resource);\n\t\tif (result)\n\t\t\tgoto err;\n\t}\n\treturn 0;\n\n err:\n\tlist_for_each_entry_continue(entry, list, node)\n\t\tacpi_power_on(entry->resource);\n\n\treturn result;\n}\n\nstatic int acpi_power_on_list(struct list_head *list)\n{\n\tstruct acpi_power_resource_entry *entry;\n\tint result = 0;\n\n\tlist_for_each_entry(entry, list, node) {\n\t\tresult = acpi_power_on(entry->resource);\n\t\tif (result)\n\t\t\tgoto err;\n\t}\n\treturn 0;\n\n err:\n\tlist_for_each_entry_continue_reverse(entry, list, node)\n\t\tacpi_power_off(entry->resource);\n\n\treturn result;\n}\n\nstatic struct attribute *attrs[] = {\n\tNULL,\n};\n\nstatic const struct attribute_group attr_groups[] = {\n\t[ACPI_STATE_D0] = {\n\t\t.name = \"power_resources_D0\",\n\t\t.attrs = attrs,\n\t},\n\t[ACPI_STATE_D1] = {\n\t\t.name = \"power_resources_D1\",\n\t\t.attrs = attrs,\n\t},\n\t[ACPI_STATE_D2] = {\n\t\t.name = \"power_resources_D2\",\n\t\t.attrs = attrs,\n\t},\n\t[ACPI_STATE_D3_HOT] = {\n\t\t.name = \"power_resources_D3hot\",\n\t\t.attrs = attrs,\n\t},\n};\n\nstatic const struct attribute_group wakeup_attr_group = {\n\t.name = \"power_resources_wakeup\",\n\t.attrs = attrs,\n};\n\nstatic void acpi_power_hide_list(struct acpi_device *adev,\n\t\t\t\t struct list_head *resources,\n\t\t\t\t const struct attribute_group *attr_group)\n{\n\tstruct acpi_power_resource_entry *entry;\n\n\tif (list_empty(resources))\n\t\treturn;\n\n\tlist_for_each_entry_reverse(entry, resources, node) {\n\t\tstruct acpi_device *res_dev = &entry->resource->device;\n\n\t\tsysfs_remove_link_from_group(&adev->dev.kobj,\n\t\t\t\t\t     attr_group->name,\n\t\t\t\t\t     dev_name(&res_dev->dev));\n\t}\n\tsysfs_remove_group(&adev->dev.kobj, attr_group);\n}\n\nstatic void acpi_power_expose_list(struct acpi_device *adev,\n\t\t\t\t   struct list_head *resources,\n\t\t\t\t   const struct attribute_group *attr_group)\n{\n\tstruct acpi_power_resource_entry *entry;\n\tint ret;\n\n\tif (list_empty(resources))\n\t\treturn;\n\n\tret = sysfs_create_group(&adev->dev.kobj, attr_group);\n\tif (ret)\n\t\treturn;\n\n\tlist_for_each_entry(entry, resources, node) {\n\t\tstruct acpi_device *res_dev = &entry->resource->device;\n\n\t\tret = sysfs_add_link_to_group(&adev->dev.kobj,\n\t\t\t\t\t      attr_group->name,\n\t\t\t\t\t      &res_dev->dev.kobj,\n\t\t\t\t\t      dev_name(&res_dev->dev));\n\t\tif (ret) {\n\t\t\tacpi_power_hide_list(adev, resources, attr_group);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void acpi_power_expose_hide(struct acpi_device *adev,\n\t\t\t\t   struct list_head *resources,\n\t\t\t\t   const struct attribute_group *attr_group,\n\t\t\t\t   bool expose)\n{\n\tif (expose)\n\t\tacpi_power_expose_list(adev, resources, attr_group);\n\telse\n\t\tacpi_power_hide_list(adev, resources, attr_group);\n}\n\nvoid acpi_power_add_remove_device(struct acpi_device *adev, bool add)\n{\n\tint state;\n\n\tif (adev->wakeup.flags.valid)\n\t\tacpi_power_expose_hide(adev, &adev->wakeup.resources,\n\t\t\t\t       &wakeup_attr_group, add);\n\n\tif (!adev->power.flags.power_resources)\n\t\treturn;\n\n\tfor (state = ACPI_STATE_D0; state <= ACPI_STATE_D3_HOT; state++)\n\t\tacpi_power_expose_hide(adev,\n\t\t\t\t       &adev->power.states[state].resources,\n\t\t\t\t       &attr_groups[state], add);\n}\n\nint acpi_power_wakeup_list_init(struct list_head *list, int *system_level_p)\n{\n\tstruct acpi_power_resource_entry *entry;\n\tint system_level = 5;\n\n\tlist_for_each_entry(entry, list, node) {\n\t\tstruct acpi_power_resource *resource = entry->resource;\n\t\tu8 state;\n\n\t\tmutex_lock(&resource->resource_lock);\n\n\t\t \n\t\tif (!resource->ref_count &&\n\t\t    !acpi_power_get_state(resource, &state) &&\n\t\t    state == ACPI_POWER_RESOURCE_STATE_ON)\n\t\t\t__acpi_power_off(resource);\n\n\t\tif (system_level > resource->system_level)\n\t\t\tsystem_level = resource->system_level;\n\n\t\tmutex_unlock(&resource->resource_lock);\n\t}\n\t*system_level_p = system_level;\n\treturn 0;\n}\n\n \n\n \nint acpi_device_sleep_wake(struct acpi_device *dev,\n\t\t\t   int enable, int sleep_state, int dev_state)\n{\n\tunion acpi_object in_arg[3];\n\tstruct acpi_object_list arg_list = { 3, in_arg };\n\tacpi_status status = AE_OK;\n\n\t \n\tin_arg[0].type = ACPI_TYPE_INTEGER;\n\tin_arg[0].integer.value = enable;\n\tin_arg[1].type = ACPI_TYPE_INTEGER;\n\tin_arg[1].integer.value = sleep_state;\n\tin_arg[2].type = ACPI_TYPE_INTEGER;\n\tin_arg[2].integer.value = dev_state;\n\tstatus = acpi_evaluate_object(dev->handle, \"_DSW\", &arg_list, NULL);\n\tif (ACPI_SUCCESS(status)) {\n\t\treturn 0;\n\t} else if (status != AE_NOT_FOUND) {\n\t\tacpi_handle_info(dev->handle, \"_DSW execution failed\\n\");\n\t\tdev->wakeup.flags.valid = 0;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tstatus = acpi_execute_simple_method(dev->handle, \"_PSW\", enable);\n\tif (ACPI_FAILURE(status) && (status != AE_NOT_FOUND)) {\n\t\tacpi_handle_info(dev->handle, \"_PSW execution failed\\n\");\n\t\tdev->wakeup.flags.valid = 0;\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nint acpi_enable_wakeup_device_power(struct acpi_device *dev, int sleep_state)\n{\n\tint err = 0;\n\n\tif (!dev || !dev->wakeup.flags.valid)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&acpi_device_lock);\n\n\tdev_dbg(&dev->dev, \"Enabling wakeup power (count %d)\\n\",\n\t\tdev->wakeup.prepare_count);\n\n\tif (dev->wakeup.prepare_count++)\n\t\tgoto out;\n\n\terr = acpi_power_on_list(&dev->wakeup.resources);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"Cannot turn on wakeup power resources\\n\");\n\t\tdev->wakeup.flags.valid = 0;\n\t\tgoto out;\n\t}\n\n\t \n\terr = acpi_device_sleep_wake(dev, 1, sleep_state, 3);\n\tif (err) {\n\t\tacpi_power_off_list(&dev->wakeup.resources);\n\t\tdev->wakeup.prepare_count = 0;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&dev->dev, \"Wakeup power enabled\\n\");\n\n out:\n\tmutex_unlock(&acpi_device_lock);\n\treturn err;\n}\n\n \nint acpi_disable_wakeup_device_power(struct acpi_device *dev)\n{\n\tstruct acpi_power_resource_entry *entry;\n\tint err = 0;\n\n\tif (!dev || !dev->wakeup.flags.valid)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&acpi_device_lock);\n\n\tdev_dbg(&dev->dev, \"Disabling wakeup power (count %d)\\n\",\n\t\tdev->wakeup.prepare_count);\n\n\t \n\tif (dev->wakeup.prepare_count <= 0)\n\t\tgoto out;\n\n\tif (--dev->wakeup.prepare_count > 0)\n\t\tgoto out;\n\n\terr = acpi_device_sleep_wake(dev, 0, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tlist_for_each_entry(entry, &dev->wakeup.resources, node) {\n\t\tint ret;\n\n\t\tret = acpi_power_off(entry->resource);\n\t\tif (ret && !err)\n\t\t\terr = ret;\n\t}\n\tif (err) {\n\t\tdev_err(&dev->dev, \"Cannot turn off wakeup power resources\\n\");\n\t\tdev->wakeup.flags.valid = 0;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&dev->dev, \"Wakeup power disabled\\n\");\n\n out:\n\tmutex_unlock(&acpi_device_lock);\n\treturn err;\n}\n\nint acpi_power_get_inferred_state(struct acpi_device *device, int *state)\n{\n\tu8 list_state = ACPI_POWER_RESOURCE_STATE_OFF;\n\tint result = 0;\n\tint i = 0;\n\n\tif (!device || !state)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = ACPI_STATE_D0; i <= ACPI_STATE_D3_HOT; i++) {\n\t\tstruct list_head *list = &device->power.states[i].resources;\n\n\t\tif (list_empty(list))\n\t\t\tcontinue;\n\n\t\tresult = acpi_power_get_list_state(list, &list_state);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tif (list_state == ACPI_POWER_RESOURCE_STATE_ON) {\n\t\t\t*state = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*state = device->power.states[ACPI_STATE_D3_COLD].flags.valid ?\n\t\tACPI_STATE_D3_COLD : ACPI_STATE_D3_HOT;\n\treturn 0;\n}\n\nint acpi_power_on_resources(struct acpi_device *device, int state)\n{\n\tif (!device || state < ACPI_STATE_D0 || state > ACPI_STATE_D3_HOT)\n\t\treturn -EINVAL;\n\n\treturn acpi_power_on_list(&device->power.states[state].resources);\n}\n\nint acpi_power_transition(struct acpi_device *device, int state)\n{\n\tint result = 0;\n\n\tif (!device || (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))\n\t\treturn -EINVAL;\n\n\tif (device->power.state == state || !device->flags.power_manageable)\n\t\treturn 0;\n\n\tif ((device->power.state < ACPI_STATE_D0)\n\t    || (device->power.state > ACPI_STATE_D3_COLD))\n\t\treturn -ENODEV;\n\n\t \n\tif (state < ACPI_STATE_D3_COLD)\n\t\tresult = acpi_power_on_list(\n\t\t\t&device->power.states[state].resources);\n\n\tif (!result && device->power.state < ACPI_STATE_D3_COLD)\n\t\tacpi_power_off_list(\n\t\t\t&device->power.states[device->power.state].resources);\n\n\t \n\tdevice->power.state = result ? ACPI_STATE_UNKNOWN : state;\n\n\treturn result;\n}\n\nstatic void acpi_release_power_resource(struct device *dev)\n{\n\tstruct acpi_device *device = to_acpi_device(dev);\n\tstruct acpi_power_resource *resource;\n\n\tresource = container_of(device, struct acpi_power_resource, device);\n\n\tmutex_lock(&power_resource_list_lock);\n\tlist_del(&resource->list_node);\n\tmutex_unlock(&power_resource_list_lock);\n\n\tacpi_free_pnp_ids(&device->pnp);\n\tkfree(resource);\n}\n\nstatic ssize_t resource_in_use_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct acpi_power_resource *resource;\n\n\tresource = to_power_resource(to_acpi_device(dev));\n\treturn sprintf(buf, \"%u\\n\", !!resource->ref_count);\n}\nstatic DEVICE_ATTR_RO(resource_in_use);\n\nstatic void acpi_power_sysfs_remove(struct acpi_device *device)\n{\n\tdevice_remove_file(&device->dev, &dev_attr_resource_in_use);\n}\n\nstatic void acpi_power_add_resource_to_list(struct acpi_power_resource *resource)\n{\n\tmutex_lock(&power_resource_list_lock);\n\n\tif (!list_empty(&acpi_power_resource_list)) {\n\t\tstruct acpi_power_resource *r;\n\n\t\tlist_for_each_entry(r, &acpi_power_resource_list, list_node)\n\t\t\tif (r->order > resource->order) {\n\t\t\t\tlist_add_tail(&resource->list_node, &r->list_node);\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\tlist_add_tail(&resource->list_node, &acpi_power_resource_list);\n\n out:\n\tmutex_unlock(&power_resource_list_lock);\n}\n\nstruct acpi_device *acpi_add_power_resource(acpi_handle handle)\n{\n\tstruct acpi_device *device = acpi_fetch_acpi_dev(handle);\n\tstruct acpi_power_resource *resource;\n\tunion acpi_object acpi_object;\n\tstruct acpi_buffer buffer = { sizeof(acpi_object), &acpi_object };\n\tacpi_status status;\n\tu8 state_dummy;\n\tint result;\n\n\tif (device)\n\t\treturn device;\n\n\tresource = kzalloc(sizeof(*resource), GFP_KERNEL);\n\tif (!resource)\n\t\treturn NULL;\n\n\tdevice = &resource->device;\n\tacpi_init_device_object(device, handle, ACPI_BUS_TYPE_POWER,\n\t\t\t\tacpi_release_power_resource);\n\tmutex_init(&resource->resource_lock);\n\tINIT_LIST_HEAD(&resource->list_node);\n\tINIT_LIST_HEAD(&resource->dependents);\n\tstrcpy(acpi_device_name(device), ACPI_POWER_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_POWER_CLASS);\n\tdevice->power.state = ACPI_STATE_UNKNOWN;\n\tdevice->flags.match_driver = true;\n\n\t \n\tstatus = acpi_evaluate_object(handle, NULL, NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\tgoto err;\n\n\tresource->system_level = acpi_object.power_resource.system_level;\n\tresource->order = acpi_object.power_resource.resource_order;\n\tresource->state = ACPI_POWER_RESOURCE_STATE_UNKNOWN;\n\n\t \n\tif (acpi_power_get_state(resource, &state_dummy))\n\t\t__acpi_power_on(resource);\n\n\tacpi_handle_info(handle, \"New power resource\\n\");\n\n\tresult = acpi_tie_acpi_dev(device);\n\tif (result)\n\t\tgoto err;\n\n\tresult = acpi_device_add(device);\n\tif (result)\n\t\tgoto err;\n\n\tif (!device_create_file(&device->dev, &dev_attr_resource_in_use))\n\t\tdevice->remove = acpi_power_sysfs_remove;\n\n\tacpi_power_add_resource_to_list(resource);\n\tacpi_device_add_finalize(device);\n\treturn device;\n\n err:\n\tacpi_release_power_resource(&device->dev);\n\treturn NULL;\n}\n\n#ifdef CONFIG_ACPI_SLEEP\nvoid acpi_resume_power_resources(void)\n{\n\tstruct acpi_power_resource *resource;\n\n\tmutex_lock(&power_resource_list_lock);\n\n\tlist_for_each_entry(resource, &acpi_power_resource_list, list_node) {\n\t\tint result;\n\t\tu8 state;\n\n\t\tmutex_lock(&resource->resource_lock);\n\n\t\tresource->state = ACPI_POWER_RESOURCE_STATE_UNKNOWN;\n\t\tresult = acpi_power_get_state(resource, &state);\n\t\tif (result) {\n\t\t\tmutex_unlock(&resource->resource_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (state == ACPI_POWER_RESOURCE_STATE_OFF\n\t\t    && resource->ref_count) {\n\t\t\tacpi_handle_debug(resource->device.handle, \"Turning ON\\n\");\n\t\t\t__acpi_power_on(resource);\n\t\t}\n\n\t\tmutex_unlock(&resource->resource_lock);\n\t}\n\n\tmutex_unlock(&power_resource_list_lock);\n}\n#endif\n\nstatic const struct dmi_system_id dmi_leave_unused_power_resources_on[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"SATELLITE Click Mini L9W-B\"),\n\t\t},\n\t},\n\t{}\n};\n\n \nvoid acpi_turn_off_unused_power_resources(void)\n{\n\tstruct acpi_power_resource *resource;\n\n\tif (dmi_check_system(dmi_leave_unused_power_resources_on))\n\t\treturn;\n\n\tmutex_lock(&power_resource_list_lock);\n\n\tlist_for_each_entry_reverse(resource, &acpi_power_resource_list, list_node) {\n\t\tmutex_lock(&resource->resource_lock);\n\n\t\tif (!resource->ref_count &&\n\t\t    resource->state == ACPI_POWER_RESOURCE_STATE_ON) {\n\t\t\tacpi_handle_debug(resource->device.handle, \"Turning OFF\\n\");\n\t\t\t__acpi_power_off(resource);\n\t\t}\n\n\t\tmutex_unlock(&resource->resource_lock);\n\t}\n\n\tmutex_unlock(&power_resource_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}