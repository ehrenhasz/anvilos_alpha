{
  "module_name": "ac.c",
  "hash_id": "44c2ca9706bcbc5585dab62c42272b407c9fe06ff596d00dc8d1cbe9e0eb8bf7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/ac.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: AC: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/dmi.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/acpi.h>\n#include <acpi/battery.h>\n\n#define ACPI_AC_CLASS\t\t\t\"ac_adapter\"\n#define ACPI_AC_DEVICE_NAME\t\t\"AC Adapter\"\n#define ACPI_AC_FILE_STATE\t\t\"state\"\n#define ACPI_AC_NOTIFY_STATUS\t\t0x80\n#define ACPI_AC_STATUS_OFFLINE\t\t0x00\n#define ACPI_AC_STATUS_ONLINE\t\t0x01\n#define ACPI_AC_STATUS_UNKNOWN\t\t0xFF\n\nMODULE_AUTHOR(\"Paul Diefenbaugh\");\nMODULE_DESCRIPTION(\"ACPI AC Adapter Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int acpi_ac_add(struct acpi_device *device);\nstatic void acpi_ac_remove(struct acpi_device *device);\nstatic void acpi_ac_notify(acpi_handle handle, u32 event, void *data);\n\nstatic const struct acpi_device_id ac_device_ids[] = {\n\t{\"ACPI0003\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, ac_device_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_ac_resume(struct device *dev);\n#endif\nstatic SIMPLE_DEV_PM_OPS(acpi_ac_pm, NULL, acpi_ac_resume);\n\nstatic int ac_sleep_before_get_state_ms;\nstatic int ac_only;\n\nstatic struct acpi_driver acpi_ac_driver = {\n\t.name = \"ac\",\n\t.class = ACPI_AC_CLASS,\n\t.ids = ac_device_ids,\n\t.ops = {\n\t\t.add = acpi_ac_add,\n\t\t.remove = acpi_ac_remove,\n\t\t},\n\t.drv.pm = &acpi_ac_pm,\n};\n\nstruct acpi_ac {\n\tstruct power_supply *charger;\n\tstruct power_supply_desc charger_desc;\n\tstruct acpi_device *device;\n\tunsigned long long state;\n\tstruct notifier_block battery_nb;\n};\n\n#define to_acpi_ac(x) power_supply_get_drvdata(x)\n\n \nstatic int acpi_ac_get_state(struct acpi_ac *ac)\n{\n\tacpi_status status = AE_OK;\n\n\tif (!ac)\n\t\treturn -EINVAL;\n\n\tif (ac_only) {\n\t\tac->state = 1;\n\t\treturn 0;\n\t}\n\n\tstatus = acpi_evaluate_integer(ac->device->handle, \"_PSR\", NULL,\n\t\t\t\t       &ac->state);\n\tif (ACPI_FAILURE(status)) {\n\t\tacpi_handle_info(ac->device->handle,\n\t\t\t\t\"Error reading AC Adapter state: %s\\n\",\n\t\t\t\tacpi_format_exception(status));\n\t\tac->state = ACPI_AC_STATUS_UNKNOWN;\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int get_ac_property(struct power_supply *psy,\n\t\t\t   enum power_supply_property psp,\n\t\t\t   union power_supply_propval *val)\n{\n\tstruct acpi_ac *ac = to_acpi_ac(psy);\n\n\tif (!ac)\n\t\treturn -ENODEV;\n\n\tif (acpi_ac_get_state(ac))\n\t\treturn -ENODEV;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = ac->state;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic enum power_supply_property ac_props[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\n \nstatic void acpi_ac_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_device *device = data;\n\tstruct acpi_ac *ac = acpi_driver_data(device);\n\n\tif (!ac)\n\t\treturn;\n\n\tswitch (event) {\n\tdefault:\n\t\tacpi_handle_debug(device->handle, \"Unsupported event [0x%x]\\n\",\n\t\t\t\t  event);\n\t\tfallthrough;\n\tcase ACPI_AC_NOTIFY_STATUS:\n\tcase ACPI_NOTIFY_BUS_CHECK:\n\tcase ACPI_NOTIFY_DEVICE_CHECK:\n\t\t \n\t\tif (ac_sleep_before_get_state_ms > 0)\n\t\t\tmsleep(ac_sleep_before_get_state_ms);\n\n\t\tacpi_ac_get_state(ac);\n\t\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\t\t\t\t  dev_name(&device->dev), event,\n\t\t\t\t\t\t  (u32) ac->state);\n\t\tacpi_notifier_call_chain(device, event, (u32) ac->state);\n\t\tkobject_uevent(&ac->charger->dev.kobj, KOBJ_CHANGE);\n\t}\n}\n\nstatic int acpi_ac_battery_notify(struct notifier_block *nb,\n\t\t\t\t  unsigned long action, void *data)\n{\n\tstruct acpi_ac *ac = container_of(nb, struct acpi_ac, battery_nb);\n\tstruct acpi_bus_event *event = (struct acpi_bus_event *)data;\n\n\t \n\tif (strcmp(event->device_class, ACPI_BATTERY_CLASS) == 0 &&\n\t    event->type == ACPI_BATTERY_NOTIFY_STATUS)\n\t\tacpi_ac_get_state(ac);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int __init thinkpad_e530_quirk(const struct dmi_system_id *d)\n{\n\tac_sleep_before_get_state_ms = 1000;\n\treturn 0;\n}\n\nstatic int __init ac_only_quirk(const struct dmi_system_id *d)\n{\n\tac_only = 1;\n\treturn 0;\n}\n\n \nstatic const struct dmi_system_id ac_dmi_table[]  __initconst = {\n\t{\n\t\t \n\t\t.callback = ac_only_quirk,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"GK45\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.callback = thinkpad_e530_quirk,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"32597CG\"),\n\t\t},\n\t},\n\t{},\n};\n\nstatic int acpi_ac_add(struct acpi_device *device)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tint result = 0;\n\tstruct acpi_ac *ac = NULL;\n\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tac = kzalloc(sizeof(struct acpi_ac), GFP_KERNEL);\n\tif (!ac)\n\t\treturn -ENOMEM;\n\n\tac->device = device;\n\tstrcpy(acpi_device_name(device), ACPI_AC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_AC_CLASS);\n\tdevice->driver_data = ac;\n\n\tresult = acpi_ac_get_state(ac);\n\tif (result)\n\t\tgoto err_release_ac;\n\n\tpsy_cfg.drv_data = ac;\n\n\tac->charger_desc.name = acpi_device_bid(device);\n\tac->charger_desc.type = POWER_SUPPLY_TYPE_MAINS;\n\tac->charger_desc.properties = ac_props;\n\tac->charger_desc.num_properties = ARRAY_SIZE(ac_props);\n\tac->charger_desc.get_property = get_ac_property;\n\tac->charger = power_supply_register(&ac->device->dev,\n\t\t\t\t\t    &ac->charger_desc, &psy_cfg);\n\tif (IS_ERR(ac->charger)) {\n\t\tresult = PTR_ERR(ac->charger);\n\t\tgoto err_release_ac;\n\t}\n\n\tpr_info(\"%s [%s] (%s)\\n\", acpi_device_name(device),\n\t\tacpi_device_bid(device), ac->state ? \"on-line\" : \"off-line\");\n\n\tac->battery_nb.notifier_call = acpi_ac_battery_notify;\n\tregister_acpi_notifier(&ac->battery_nb);\n\n\tresult = acpi_dev_install_notify_handler(device, ACPI_ALL_NOTIFY,\n\t\t\t\t\t\t acpi_ac_notify);\n\tif (result)\n\t\tgoto err_unregister;\n\n\treturn 0;\n\nerr_unregister:\n\tpower_supply_unregister(ac->charger);\n\tunregister_acpi_notifier(&ac->battery_nb);\nerr_release_ac:\n\tkfree(ac);\n\n\treturn result;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int acpi_ac_resume(struct device *dev)\n{\n\tstruct acpi_ac *ac;\n\tunsigned int old_state;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tac = acpi_driver_data(to_acpi_device(dev));\n\tif (!ac)\n\t\treturn -EINVAL;\n\n\told_state = ac->state;\n\tif (acpi_ac_get_state(ac))\n\t\treturn 0;\n\tif (old_state != ac->state)\n\t\tkobject_uevent(&ac->charger->dev.kobj, KOBJ_CHANGE);\n\n\treturn 0;\n}\n#else\n#define acpi_ac_resume NULL\n#endif\n\nstatic void acpi_ac_remove(struct acpi_device *device)\n{\n\tstruct acpi_ac *ac = NULL;\n\n\tif (!device || !acpi_driver_data(device))\n\t\treturn;\n\n\tac = acpi_driver_data(device);\n\n\tacpi_dev_remove_notify_handler(device, ACPI_ALL_NOTIFY,\n\t\t\t\t       acpi_ac_notify);\n\tpower_supply_unregister(ac->charger);\n\tunregister_acpi_notifier(&ac->battery_nb);\n\n\tkfree(ac);\n}\n\nstatic int __init acpi_ac_init(void)\n{\n\tint result;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tif (acpi_quirk_skip_acpi_ac_and_battery())\n\t\treturn -ENODEV;\n\n\tdmi_check_system(ac_dmi_table);\n\n\tresult = acpi_bus_register_driver(&acpi_ac_driver);\n\tif (result < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void __exit acpi_ac_exit(void)\n{\n\tacpi_bus_unregister_driver(&acpi_ac_driver);\n}\nmodule_init(acpi_ac_init);\nmodule_exit(acpi_ac_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}