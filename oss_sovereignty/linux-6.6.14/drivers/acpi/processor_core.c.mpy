{
  "module_name": "processor_core.c",
  "hash_id": "7b2ac6ca5d2eb78b6a4b284fccf576e43ff0b25da1a5686c03e1a01ebfaaa909",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/processor_core.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n\nstatic struct acpi_table_madt *get_madt_table(void)\n{\n\tstatic struct acpi_table_madt *madt;\n\tstatic int read_madt;\n\n\tif (!read_madt) {\n\t\tif (ACPI_FAILURE(acpi_get_table(ACPI_SIG_MADT, 0,\n\t\t\t\t\t(struct acpi_table_header **)&madt)))\n\t\t\tmadt = NULL;\n\t\tread_madt++;\n\t}\n\n\treturn madt;\n}\n\nstatic int map_lapic_id(struct acpi_subtable_header *entry,\n\t\t u32 acpi_id, phys_cpuid_t *apic_id)\n{\n\tstruct acpi_madt_local_apic *lapic =\n\t\tcontainer_of(entry, struct acpi_madt_local_apic, header);\n\n\tif (!(lapic->lapic_flags & ACPI_MADT_ENABLED))\n\t\treturn -ENODEV;\n\n\tif (lapic->processor_id != acpi_id)\n\t\treturn -EINVAL;\n\n\t*apic_id = lapic->id;\n\treturn 0;\n}\n\nstatic int map_x2apic_id(struct acpi_subtable_header *entry,\n\t\tint device_declaration, u32 acpi_id, phys_cpuid_t *apic_id)\n{\n\tstruct acpi_madt_local_x2apic *apic =\n\t\tcontainer_of(entry, struct acpi_madt_local_x2apic, header);\n\n\tif (!(apic->lapic_flags & ACPI_MADT_ENABLED))\n\t\treturn -ENODEV;\n\n\tif (device_declaration && (apic->uid == acpi_id)) {\n\t\t*apic_id = apic->local_apic_id;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int map_lsapic_id(struct acpi_subtable_header *entry,\n\t\tint device_declaration, u32 acpi_id, phys_cpuid_t *apic_id)\n{\n\tstruct acpi_madt_local_sapic *lsapic =\n\t\tcontainer_of(entry, struct acpi_madt_local_sapic, header);\n\n\tif (!(lsapic->lapic_flags & ACPI_MADT_ENABLED))\n\t\treturn -ENODEV;\n\n\tif (device_declaration) {\n\t\tif ((entry->length < 16) || (lsapic->uid != acpi_id))\n\t\t\treturn -EINVAL;\n\t} else if (lsapic->processor_id != acpi_id)\n\t\treturn -EINVAL;\n\n\t*apic_id = (lsapic->id << 8) | lsapic->eid;\n\treturn 0;\n}\n\n \nstatic int map_gicc_mpidr(struct acpi_subtable_header *entry,\n\t\tint device_declaration, u32 acpi_id, phys_cpuid_t *mpidr)\n{\n\tstruct acpi_madt_generic_interrupt *gicc =\n\t    container_of(entry, struct acpi_madt_generic_interrupt, header);\n\n\tif (!(gicc->flags & ACPI_MADT_ENABLED))\n\t\treturn -ENODEV;\n\n\t \n\tif (device_declaration && (gicc->uid == acpi_id)) {\n\t\t*mpidr = gicc->arm_mpidr;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int map_rintc_hartid(struct acpi_subtable_header *entry,\n\t\t\t    int device_declaration, u32 acpi_id,\n\t\t\t    phys_cpuid_t *hartid)\n{\n\tstruct acpi_madt_rintc *rintc =\n\t    container_of(entry, struct acpi_madt_rintc, header);\n\n\tif (!(rintc->flags & ACPI_MADT_ENABLED))\n\t\treturn -ENODEV;\n\n\t \n\tif (device_declaration && rintc->uid == acpi_id) {\n\t\t*hartid = rintc->hart_id;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int map_core_pic_id(struct acpi_subtable_header *entry,\n\t\tint device_declaration, u32 acpi_id, phys_cpuid_t *phys_id)\n{\n\tstruct acpi_madt_core_pic *core_pic =\n\t\tcontainer_of(entry, struct acpi_madt_core_pic, header);\n\n\tif (!(core_pic->flags & ACPI_MADT_ENABLED))\n\t\treturn -ENODEV;\n\n\t \n\tif (device_declaration && (core_pic->processor_id == acpi_id)) {\n\t\t*phys_id = core_pic->core_id;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic phys_cpuid_t map_madt_entry(struct acpi_table_madt *madt,\n\t\t\t\t   int type, u32 acpi_id)\n{\n\tunsigned long madt_end, entry;\n\tphys_cpuid_t phys_id = PHYS_CPUID_INVALID;\t \n\n\tif (!madt)\n\t\treturn phys_id;\n\n\tentry = (unsigned long)madt;\n\tmadt_end = entry + madt->header.length;\n\n\t \n\n\tentry += sizeof(struct acpi_table_madt);\n\twhile (entry + sizeof(struct acpi_subtable_header) < madt_end) {\n\t\tstruct acpi_subtable_header *header =\n\t\t\t(struct acpi_subtable_header *)entry;\n\t\tif (header->type == ACPI_MADT_TYPE_LOCAL_APIC) {\n\t\t\tif (!map_lapic_id(header, acpi_id, &phys_id))\n\t\t\t\tbreak;\n\t\t} else if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC) {\n\t\t\tif (!map_x2apic_id(header, type, acpi_id, &phys_id))\n\t\t\t\tbreak;\n\t\t} else if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC) {\n\t\t\tif (!map_lsapic_id(header, type, acpi_id, &phys_id))\n\t\t\t\tbreak;\n\t\t} else if (header->type == ACPI_MADT_TYPE_GENERIC_INTERRUPT) {\n\t\t\tif (!map_gicc_mpidr(header, type, acpi_id, &phys_id))\n\t\t\t\tbreak;\n\t\t} else if (header->type == ACPI_MADT_TYPE_RINTC) {\n\t\t\tif (!map_rintc_hartid(header, type, acpi_id, &phys_id))\n\t\t\t\tbreak;\n\t\t} else if (header->type == ACPI_MADT_TYPE_CORE_PIC) {\n\t\t\tif (!map_core_pic_id(header, type, acpi_id, &phys_id))\n\t\t\t\tbreak;\n\t\t}\n\t\tentry += header->length;\n\t}\n\treturn phys_id;\n}\n\nphys_cpuid_t __init acpi_map_madt_entry(u32 acpi_id)\n{\n\tstruct acpi_table_madt *madt = NULL;\n\tphys_cpuid_t rv;\n\n\tacpi_get_table(ACPI_SIG_MADT, 0,\n\t\t       (struct acpi_table_header **)&madt);\n\tif (!madt)\n\t\treturn PHYS_CPUID_INVALID;\n\n\trv = map_madt_entry(madt, 1, acpi_id);\n\n\tacpi_put_table((struct acpi_table_header *)madt);\n\n\treturn rv;\n}\n\nstatic phys_cpuid_t map_mat_entry(acpi_handle handle, int type, u32 acpi_id)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tstruct acpi_subtable_header *header;\n\tphys_cpuid_t phys_id = PHYS_CPUID_INVALID;\n\n\tif (ACPI_FAILURE(acpi_evaluate_object(handle, \"_MAT\", NULL, &buffer)))\n\t\tgoto exit;\n\n\tif (!buffer.length || !buffer.pointer)\n\t\tgoto exit;\n\n\tobj = buffer.pointer;\n\tif (obj->type != ACPI_TYPE_BUFFER ||\n\t    obj->buffer.length < sizeof(struct acpi_subtable_header)) {\n\t\tgoto exit;\n\t}\n\n\theader = (struct acpi_subtable_header *)obj->buffer.pointer;\n\tif (header->type == ACPI_MADT_TYPE_LOCAL_APIC)\n\t\tmap_lapic_id(header, acpi_id, &phys_id);\n\telse if (header->type == ACPI_MADT_TYPE_LOCAL_SAPIC)\n\t\tmap_lsapic_id(header, type, acpi_id, &phys_id);\n\telse if (header->type == ACPI_MADT_TYPE_LOCAL_X2APIC)\n\t\tmap_x2apic_id(header, type, acpi_id, &phys_id);\n\telse if (header->type == ACPI_MADT_TYPE_GENERIC_INTERRUPT)\n\t\tmap_gicc_mpidr(header, type, acpi_id, &phys_id);\n\telse if (header->type == ACPI_MADT_TYPE_CORE_PIC)\n\t\tmap_core_pic_id(header, type, acpi_id, &phys_id);\n\nexit:\n\tkfree(buffer.pointer);\n\treturn phys_id;\n}\n\nphys_cpuid_t acpi_get_phys_id(acpi_handle handle, int type, u32 acpi_id)\n{\n\tphys_cpuid_t phys_id;\n\n\tphys_id = map_mat_entry(handle, type, acpi_id);\n\tif (invalid_phys_cpuid(phys_id))\n\t\tphys_id = map_madt_entry(get_madt_table(), type, acpi_id);\n\n\treturn phys_id;\n}\nEXPORT_SYMBOL_GPL(acpi_get_phys_id);\n\nint acpi_map_cpuid(phys_cpuid_t phys_id, u32 acpi_id)\n{\n#ifdef CONFIG_SMP\n\tint i;\n#endif\n\n\tif (invalid_phys_cpuid(phys_id)) {\n\t\t \n\t\tif (nr_cpu_ids <= 1 && acpi_id == 0)\n\t\t\treturn acpi_id;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_SMP\n\tfor_each_possible_cpu(i) {\n\t\tif (cpu_physical_id(i) == phys_id)\n\t\t\treturn i;\n\t}\n#else\n\t \n\tif (phys_id == 0)\n\t\treturn phys_id;\n#endif\n\treturn -ENODEV;\n}\n\nint acpi_get_cpuid(acpi_handle handle, int type, u32 acpi_id)\n{\n\tphys_cpuid_t phys_id;\n\n\tphys_id = acpi_get_phys_id(handle, type, acpi_id);\n\n\treturn acpi_map_cpuid(phys_id, acpi_id);\n}\nEXPORT_SYMBOL_GPL(acpi_get_cpuid);\n\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\nstatic int get_ioapic_id(struct acpi_subtable_header *entry, u32 gsi_base,\n\t\t\t u64 *phys_addr, int *ioapic_id)\n{\n\tstruct acpi_madt_io_apic *ioapic = (struct acpi_madt_io_apic *)entry;\n\n\tif (ioapic->global_irq_base != gsi_base)\n\t\treturn 0;\n\n\t*phys_addr = ioapic->address;\n\t*ioapic_id = ioapic->id;\n\treturn 1;\n}\n\nstatic int parse_madt_ioapic_entry(u32 gsi_base, u64 *phys_addr)\n{\n\tstruct acpi_subtable_header *hdr;\n\tunsigned long madt_end, entry;\n\tstruct acpi_table_madt *madt;\n\tint apic_id = -1;\n\n\tmadt = get_madt_table();\n\tif (!madt)\n\t\treturn apic_id;\n\n\tentry = (unsigned long)madt;\n\tmadt_end = entry + madt->header.length;\n\n\t \n\tentry += sizeof(struct acpi_table_madt);\n\twhile (entry + sizeof(struct acpi_subtable_header) < madt_end) {\n\t\thdr = (struct acpi_subtable_header *)entry;\n\t\tif (hdr->type == ACPI_MADT_TYPE_IO_APIC &&\n\t\t    get_ioapic_id(hdr, gsi_base, phys_addr, &apic_id))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry += hdr->length;\n\t}\n\n\treturn apic_id;\n}\n\nstatic int parse_mat_ioapic_entry(acpi_handle handle, u32 gsi_base,\n\t\t\t\t  u64 *phys_addr)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tstruct acpi_subtable_header *header;\n\tunion acpi_object *obj;\n\tint apic_id = -1;\n\n\tif (ACPI_FAILURE(acpi_evaluate_object(handle, \"_MAT\", NULL, &buffer)))\n\t\tgoto exit;\n\n\tif (!buffer.length || !buffer.pointer)\n\t\tgoto exit;\n\n\tobj = buffer.pointer;\n\tif (obj->type != ACPI_TYPE_BUFFER ||\n\t    obj->buffer.length < sizeof(struct acpi_subtable_header))\n\t\tgoto exit;\n\n\theader = (struct acpi_subtable_header *)obj->buffer.pointer;\n\tif (header->type == ACPI_MADT_TYPE_IO_APIC)\n\t\tget_ioapic_id(header, gsi_base, phys_addr, &apic_id);\n\nexit:\n\tkfree(buffer.pointer);\n\treturn apic_id;\n}\n\n \nint acpi_get_ioapic_id(acpi_handle handle, u32 gsi_base, u64 *phys_addr)\n{\n\tint apic_id;\n\n\tapic_id = parse_mat_ioapic_entry(handle, gsi_base, phys_addr);\n\tif (apic_id == -1)\n\t\tapic_id = parse_madt_ioapic_entry(gsi_base, phys_addr);\n\n\treturn apic_id;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}