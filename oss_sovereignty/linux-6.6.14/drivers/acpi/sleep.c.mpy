{
  "module_name": "sleep.c",
  "hash_id": "36f317a25c0918f12c35ef85c5ff570408750272be153291ebc66be981c74c42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/sleep.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: PM: \" fmt\n\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/dmi.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/syscore_ops.h>\n#include <asm/io.h>\n#include <trace/events/power.h>\n\n#include \"internal.h\"\n#include \"sleep.h\"\n\n \nbool acpi_no_s5;\nstatic u8 sleep_states[ACPI_S_STATE_COUNT];\n\nstatic void acpi_sleep_tts_switch(u32 acpi_state)\n{\n\tacpi_status status;\n\n\tstatus = acpi_execute_simple_method(NULL, \"\\\\_TTS\", acpi_state);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\t \n\t\tpr_notice(\"Failure in evaluating _TTS object\\n\");\n\t}\n}\n\nstatic int tts_notify_reboot(struct notifier_block *this,\n\t\t\tunsigned long code, void *x)\n{\n\tacpi_sleep_tts_switch(ACPI_STATE_S5);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block tts_notifier = {\n\t.notifier_call\t= tts_notify_reboot,\n\t.next\t\t= NULL,\n\t.priority\t= 0,\n};\n\n#ifndef acpi_skip_set_wakeup_address\n#define acpi_skip_set_wakeup_address() false\n#endif\n\nstatic int acpi_sleep_prepare(u32 acpi_state)\n{\n#ifdef CONFIG_ACPI_SLEEP\n\tunsigned long acpi_wakeup_address;\n\n\t \n\tif (acpi_state == ACPI_STATE_S3 && !acpi_skip_set_wakeup_address()) {\n\t\tacpi_wakeup_address = acpi_get_wakeup_address();\n\t\tif (!acpi_wakeup_address)\n\t\t\treturn -EFAULT;\n\t\tacpi_set_waking_vector(acpi_wakeup_address);\n\n\t}\n#endif\n\tpr_info(\"Preparing to enter system sleep state S%d\\n\", acpi_state);\n\tacpi_enable_wakeup_devices(acpi_state);\n\tacpi_enter_sleep_state_prep(acpi_state);\n\treturn 0;\n}\n\nbool acpi_sleep_state_supported(u8 sleep_state)\n{\n\tacpi_status status;\n\tu8 type_a, type_b;\n\n\tstatus = acpi_get_sleep_type_data(sleep_state, &type_a, &type_b);\n\treturn ACPI_SUCCESS(status) && (!acpi_gbl_reduced_hardware\n\t\t|| (acpi_gbl_FADT.sleep_control.address\n\t\t\t&& acpi_gbl_FADT.sleep_status.address));\n}\n\n#ifdef CONFIG_ACPI_SLEEP\nstatic u32 acpi_target_sleep_state = ACPI_STATE_S0;\n\nu32 acpi_target_system_state(void)\n{\n\treturn acpi_target_sleep_state;\n}\nEXPORT_SYMBOL_GPL(acpi_target_system_state);\n\nstatic bool pwr_btn_event_pending;\n\n \nstatic bool nvs_nosave;\n\nvoid __init acpi_nvs_nosave(void)\n{\n\tnvs_nosave = true;\n}\n\n \nstatic bool nvs_nosave_s3;\n\nvoid __init acpi_nvs_nosave_s3(void)\n{\n\tnvs_nosave_s3 = true;\n}\n\nstatic int __init init_nvs_save_s3(const struct dmi_system_id *d)\n{\n\tnvs_nosave_s3 = false;\n\treturn 0;\n}\n\n \nstatic bool old_suspend_ordering;\n\nvoid __init acpi_old_suspend_ordering(void)\n{\n\told_suspend_ordering = true;\n}\n\nstatic int __init init_old_suspend_ordering(const struct dmi_system_id *d)\n{\n\tacpi_old_suspend_ordering();\n\treturn 0;\n}\n\nstatic int __init init_nvs_nosave(const struct dmi_system_id *d)\n{\n\tacpi_nvs_nosave();\n\treturn 0;\n}\n\nbool acpi_sleep_default_s3;\n\nstatic int __init init_default_s3(const struct dmi_system_id *d)\n{\n\tacpi_sleep_default_s3 = true;\n\treturn 0;\n}\n\nstatic const struct dmi_system_id acpisleep_dmi_table[] __initconst = {\n\t{\n\t.callback = init_old_suspend_ordering,\n\t.ident = \"Abit KN9 (nForce4 variant)\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"http://www.abit.com.tw/\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"KN9 Series(NF-CK804)\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_old_suspend_ordering,\n\t.ident = \"HP xw4600 Workstation\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Hewlett-Packard\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"HP xw4600 Workstation\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_old_suspend_ordering,\n\t.ident = \"Asus Pundit P1-AH2 (M2N8L motherboard)\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTek Computer INC.\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"M2N8L\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_old_suspend_ordering,\n\t.ident = \"Panasonic CF51-2L\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR,\n\t\t\t\t\"Matsushita Electric Industrial Co.,Ltd.\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"CF51-2L\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VGN-FW41E_H\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-FW41E_H\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VGN-FW21E\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-FW21E\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VGN-FW21M\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-FW21M\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VPCEB17FX\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VPCEB17FX\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VGN-SR11M\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-SR11M\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Everex StepNote Series\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Everex Systems, Inc.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Everex StepNote Series\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VPCEB1Z1E\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VPCEB1Z1E\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VGN-NW130D\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-NW130D\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VPCCW29FX\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VPCCW29FX\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Averatec AV1020-ED2\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"AVERATEC\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"1000 Series\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_old_suspend_ordering,\n\t.ident = \"Asus A8N-SLI DELUXE\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"A8N-SLI DELUXE\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_old_suspend_ordering,\n\t.ident = \"Asus A8N-SLI Premium\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"ASUSTeK Computer INC.\"),\n\t\tDMI_MATCH(DMI_BOARD_NAME, \"A8N-SLI Premium\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VGN-SR26GN_P\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-SR26GN_P\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VPCEB1S1E\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VPCEB1S1E\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Sony Vaio VGN-FW520F\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-FW520F\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Asus K54C\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"K54C\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_nosave,\n\t.ident = \"Asus K54HR\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK Computer Inc.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"K54HR\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_save_s3,\n\t.ident = \"Asus 1025C\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"1025C\"),\n\t\t},\n\t},\n\t \n\t{\n\t.callback = init_nvs_save_s3,\n\t.ident = \"Lenovo G50-45\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"80E3\"),\n\t\t},\n\t},\n\t{\n\t.callback = init_nvs_save_s3,\n\t.ident = \"Lenovo G40-45\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"80E1\"),\n\t\t},\n\t},\n\t \n\t{\n\t.callback = init_default_s3,\n\t.ident = \"ThinkPad X1 Tablet(2016)\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"20GGA00L00\"),\n\t\t},\n\t},\n\t \n\t{\n\t.callback = init_default_s3,\n\t.ident = \"ASUS B1400CEAE\",\n\t.matches = {\n\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ASUS EXPERTBOOK B1400CEAE\"),\n\t\t},\n\t},\n\t{},\n};\n\nstatic bool ignore_blacklist;\n\nvoid __init acpi_sleep_no_blacklist(void)\n{\n\tignore_blacklist = true;\n}\n\nstatic void __init acpi_sleep_dmi_check(void)\n{\n\tif (ignore_blacklist)\n\t\treturn;\n\n\tif (dmi_get_bios_year() >= 2012)\n\t\tacpi_nvs_nosave_s3();\n\n\tdmi_check_system(acpisleep_dmi_table);\n}\n\n \nstatic int acpi_pm_freeze(void)\n{\n\tacpi_disable_all_gpes();\n\tacpi_os_wait_events_complete();\n\tacpi_ec_block_transactions();\n\treturn 0;\n}\n\n \nstatic int acpi_pm_pre_suspend(void)\n{\n\tacpi_pm_freeze();\n\treturn suspend_nvs_save();\n}\n\n \nstatic int __acpi_pm_prepare(void)\n{\n\tint error = acpi_sleep_prepare(acpi_target_sleep_state);\n\tif (error)\n\t\tacpi_target_sleep_state = ACPI_STATE_S0;\n\n\treturn error;\n}\n\n \nstatic int acpi_pm_prepare(void)\n{\n\tint error = __acpi_pm_prepare();\n\tif (!error)\n\t\terror = acpi_pm_pre_suspend();\n\n\treturn error;\n}\n\n \nstatic void acpi_pm_finish(void)\n{\n\tstruct acpi_device *pwr_btn_adev;\n\tu32 acpi_state = acpi_target_sleep_state;\n\n\tacpi_ec_unblock_transactions();\n\tsuspend_nvs_free();\n\n\tif (acpi_state == ACPI_STATE_S0)\n\t\treturn;\n\n\tpr_info(\"Waking up from system sleep state S%d\\n\", acpi_state);\n\tacpi_disable_wakeup_devices(acpi_state);\n\tacpi_leave_sleep_state(acpi_state);\n\n\t \n\tacpi_set_waking_vector(0);\n\n\tacpi_target_sleep_state = ACPI_STATE_S0;\n\n\tacpi_resume_power_resources();\n\n\t \n\tif (!pwr_btn_event_pending)\n\t\treturn;\n\n\tpwr_btn_event_pending = false;\n\tpwr_btn_adev = acpi_dev_get_first_match_dev(ACPI_BUTTON_HID_POWERF,\n\t\t\t\t\t\t    NULL, -1);\n\tif (pwr_btn_adev) {\n\t\tpm_wakeup_event(&pwr_btn_adev->dev, 0);\n\t\tacpi_dev_put(pwr_btn_adev);\n\t}\n}\n\n \nstatic void acpi_pm_start(u32 acpi_state)\n{\n\tacpi_target_sleep_state = acpi_state;\n\tacpi_sleep_tts_switch(acpi_target_sleep_state);\n\tacpi_scan_lock_acquire();\n}\n\n \nstatic void acpi_pm_end(void)\n{\n\tacpi_turn_off_unused_power_resources();\n\tacpi_scan_lock_release();\n\t \n\tacpi_target_sleep_state = ACPI_STATE_S0;\n\tacpi_sleep_tts_switch(acpi_target_sleep_state);\n}\n#else  \n#define sleep_no_lps0\t(1)\n#define acpi_target_sleep_state\tACPI_STATE_S0\n#define acpi_sleep_default_s3\t(1)\nstatic inline void acpi_sleep_dmi_check(void) {}\n#endif  \n\n#ifdef CONFIG_SUSPEND\nstatic u32 acpi_suspend_states[] = {\n\t[PM_SUSPEND_ON] = ACPI_STATE_S0,\n\t[PM_SUSPEND_STANDBY] = ACPI_STATE_S1,\n\t[PM_SUSPEND_MEM] = ACPI_STATE_S3,\n\t[PM_SUSPEND_MAX] = ACPI_STATE_S5\n};\n\n \nstatic int acpi_suspend_begin(suspend_state_t pm_state)\n{\n\tu32 acpi_state = acpi_suspend_states[pm_state];\n\tint error;\n\n\terror = (nvs_nosave || nvs_nosave_s3) ? 0 : suspend_nvs_alloc();\n\tif (error)\n\t\treturn error;\n\n\tif (!sleep_states[acpi_state]) {\n\t\tpr_err(\"ACPI does not support sleep state S%u\\n\", acpi_state);\n\t\treturn -ENOSYS;\n\t}\n\tif (acpi_state > ACPI_STATE_S1)\n\t\tpm_set_suspend_via_firmware();\n\n\tacpi_pm_start(acpi_state);\n\treturn 0;\n}\n\n \nstatic int acpi_suspend_enter(suspend_state_t pm_state)\n{\n\tacpi_status status = AE_OK;\n\tu32 acpi_state = acpi_target_sleep_state;\n\tint error;\n\n\ttrace_suspend_resume(TPS(\"acpi_suspend\"), acpi_state, true);\n\tswitch (acpi_state) {\n\tcase ACPI_STATE_S1:\n\t\tbarrier();\n\t\tstatus = acpi_enter_sleep_state(acpi_state);\n\t\tbreak;\n\n\tcase ACPI_STATE_S3:\n\t\tif (!acpi_suspend_lowlevel)\n\t\t\treturn -ENOSYS;\n\t\terror = acpi_suspend_lowlevel();\n\t\tif (error)\n\t\t\treturn error;\n\t\tpr_info(\"Low-level resume complete\\n\");\n\t\tpm_set_resume_via_firmware();\n\t\tbreak;\n\t}\n\ttrace_suspend_resume(TPS(\"acpi_suspend\"), acpi_state, false);\n\n\t \n\tacpi_write_bit_register(ACPI_BITREG_SCI_ENABLE, 1);\n\n\t \n\tacpi_leave_sleep_state_prep(acpi_state);\n\n\t \n\tif (ACPI_SUCCESS(status) && (acpi_state == ACPI_STATE_S3)) {\n\t\tacpi_event_status pwr_btn_status = ACPI_EVENT_FLAG_DISABLED;\n\n\t\tacpi_get_event_status(ACPI_EVENT_POWER_BUTTON, &pwr_btn_status);\n\n\t\tif (pwr_btn_status & ACPI_EVENT_FLAG_STATUS_SET) {\n\t\t\tacpi_clear_event(ACPI_EVENT_POWER_BUTTON);\n\t\t\t \n\t\t\tpwr_btn_event_pending = true;\n\t\t}\n\t}\n\n\t \n\tacpi_hw_disable_all_gpes();\n\t \n\tacpi_ec_unblock_transactions();\n\n\tsuspend_nvs_restore();\n\n\treturn ACPI_SUCCESS(status) ? 0 : -EFAULT;\n}\n\nstatic int acpi_suspend_state_valid(suspend_state_t pm_state)\n{\n\tu32 acpi_state;\n\n\tswitch (pm_state) {\n\tcase PM_SUSPEND_ON:\n\tcase PM_SUSPEND_STANDBY:\n\tcase PM_SUSPEND_MEM:\n\t\tacpi_state = acpi_suspend_states[pm_state];\n\n\t\treturn sleep_states[acpi_state];\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct platform_suspend_ops acpi_suspend_ops = {\n\t.valid = acpi_suspend_state_valid,\n\t.begin = acpi_suspend_begin,\n\t.prepare_late = acpi_pm_prepare,\n\t.enter = acpi_suspend_enter,\n\t.wake = acpi_pm_finish,\n\t.end = acpi_pm_end,\n};\n\n \nstatic int acpi_suspend_begin_old(suspend_state_t pm_state)\n{\n\tint error = acpi_suspend_begin(pm_state);\n\tif (!error)\n\t\terror = __acpi_pm_prepare();\n\n\treturn error;\n}\n\n \nstatic const struct platform_suspend_ops acpi_suspend_ops_old = {\n\t.valid = acpi_suspend_state_valid,\n\t.begin = acpi_suspend_begin_old,\n\t.prepare_late = acpi_pm_pre_suspend,\n\t.enter = acpi_suspend_enter,\n\t.wake = acpi_pm_finish,\n\t.end = acpi_pm_end,\n\t.recover = acpi_pm_finish,\n};\n\nstatic bool s2idle_wakeup;\n\nint acpi_s2idle_begin(void)\n{\n\tacpi_scan_lock_acquire();\n\treturn 0;\n}\n\nint acpi_s2idle_prepare(void)\n{\n\tif (acpi_sci_irq_valid()) {\n\t\tint error;\n\n\t\terror = enable_irq_wake(acpi_sci_irq);\n\t\tif (error)\n\t\t\tpr_warn(\"Warning: Failed to enable wakeup from IRQ %d: %d\\n\",\n\t\t\t\tacpi_sci_irq, error);\n\n\t\tacpi_ec_set_gpe_wake_mask(ACPI_GPE_ENABLE);\n\t}\n\n\tacpi_enable_wakeup_devices(ACPI_STATE_S0);\n\n\t \n\tacpi_enable_all_wakeup_gpes();\n\tacpi_os_wait_events_complete();\n\n\ts2idle_wakeup = true;\n\treturn 0;\n}\n\nbool acpi_s2idle_wake(void)\n{\n\tif (!acpi_sci_irq_valid())\n\t\treturn pm_wakeup_pending();\n\n\twhile (pm_wakeup_pending()) {\n\t\t \n\t\tif (irqd_is_wakeup_armed(irq_get_irq_data(acpi_sci_irq))) {\n\t\t\tpm_pr_dbg(\"Wakeup unrelated to ACPI SCI\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tif (acpi_any_fixed_event_status_set()) {\n\t\t\tpm_pr_dbg(\"ACPI fixed event wakeup\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tif (acpi_check_wakeup_handlers()) {\n\t\t\tpm_pr_dbg(\"ACPI custom handler wakeup\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tif (acpi_ec_dispatch_gpe()) {\n\t\t\tpm_pr_dbg(\"ACPI non-EC GPE wakeup\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t\tacpi_os_wait_events_complete();\n\n\t\t \n\t\tif (pm_wakeup_pending()) {\n\t\t\tpm_pr_dbg(\"Wakeup after ACPI Notify sync\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t\tpm_pr_dbg(\"Rearming ACPI SCI for wakeup\\n\");\n\n\t\tpm_wakeup_clear(acpi_sci_irq);\n\t\trearm_wake_irq(acpi_sci_irq);\n\t}\n\n\treturn false;\n}\n\nvoid acpi_s2idle_restore(void)\n{\n\t \n\tacpi_os_wait_events_complete();  \n\tacpi_ec_flush_work();  \n\tacpi_os_wait_events_complete();  \n\n\ts2idle_wakeup = false;\n\n\tacpi_enable_all_runtime_gpes();\n\n\tacpi_disable_wakeup_devices(ACPI_STATE_S0);\n\n\tif (acpi_sci_irq_valid()) {\n\t\tacpi_ec_set_gpe_wake_mask(ACPI_GPE_DISABLE);\n\t\tdisable_irq_wake(acpi_sci_irq);\n\t}\n}\n\nvoid acpi_s2idle_end(void)\n{\n\tacpi_scan_lock_release();\n}\n\nstatic const struct platform_s2idle_ops acpi_s2idle_ops = {\n\t.begin = acpi_s2idle_begin,\n\t.prepare = acpi_s2idle_prepare,\n\t.wake = acpi_s2idle_wake,\n\t.restore = acpi_s2idle_restore,\n\t.end = acpi_s2idle_end,\n};\n\nvoid __weak acpi_s2idle_setup(void)\n{\n\tif (acpi_gbl_FADT.flags & ACPI_FADT_LOW_POWER_S0)\n\t\tpr_info(\"Efficient low-power S0 idle declared\\n\");\n\n\ts2idle_set_ops(&acpi_s2idle_ops);\n}\n\nstatic void __init acpi_sleep_suspend_setup(void)\n{\n\tbool suspend_ops_needed = false;\n\tint i;\n\n\tfor (i = ACPI_STATE_S1; i < ACPI_STATE_S4; i++)\n\t\tif (acpi_sleep_state_supported(i)) {\n\t\t\tsleep_states[i] = 1;\n\t\t\tsuspend_ops_needed = true;\n\t\t}\n\n\tif (suspend_ops_needed)\n\t\tsuspend_set_ops(old_suspend_ordering ?\n\t\t\t\t&acpi_suspend_ops_old : &acpi_suspend_ops);\n\n\tacpi_s2idle_setup();\n}\n\n#else  \n#define s2idle_wakeup\t\t(false)\nstatic inline void acpi_sleep_suspend_setup(void) {}\n#endif  \n\nbool acpi_s2idle_wakeup(void)\n{\n\treturn s2idle_wakeup;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic u32 saved_bm_rld;\n\nstatic int  acpi_save_bm_rld(void)\n{\n\tacpi_read_bit_register(ACPI_BITREG_BUS_MASTER_RLD, &saved_bm_rld);\n\treturn 0;\n}\n\nstatic void  acpi_restore_bm_rld(void)\n{\n\tu32 resumed_bm_rld = 0;\n\n\tacpi_read_bit_register(ACPI_BITREG_BUS_MASTER_RLD, &resumed_bm_rld);\n\tif (resumed_bm_rld == saved_bm_rld)\n\t\treturn;\n\n\tacpi_write_bit_register(ACPI_BITREG_BUS_MASTER_RLD, saved_bm_rld);\n}\n\nstatic struct syscore_ops acpi_sleep_syscore_ops = {\n\t.suspend = acpi_save_bm_rld,\n\t.resume = acpi_restore_bm_rld,\n};\n\nstatic void acpi_sleep_syscore_init(void)\n{\n\tregister_syscore_ops(&acpi_sleep_syscore_ops);\n}\n#else\nstatic inline void acpi_sleep_syscore_init(void) {}\n#endif  \n\n#ifdef CONFIG_HIBERNATION\nstatic unsigned long s4_hardware_signature;\nstatic struct acpi_table_facs *facs;\nint acpi_check_s4_hw_signature = -1;  \n\nstatic int acpi_hibernation_begin(pm_message_t stage)\n{\n\tif (!nvs_nosave) {\n\t\tint error = suspend_nvs_alloc();\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (stage.event == PM_EVENT_HIBERNATE)\n\t\tpm_set_suspend_via_firmware();\n\n\tacpi_pm_start(ACPI_STATE_S4);\n\treturn 0;\n}\n\nstatic int acpi_hibernation_enter(void)\n{\n\tacpi_status status = AE_OK;\n\n\t \n\tstatus = acpi_enter_sleep_state(ACPI_STATE_S4);\n\t \n\tacpi_leave_sleep_state_prep(ACPI_STATE_S4);\n\n\treturn ACPI_SUCCESS(status) ? 0 : -EFAULT;\n}\n\nstatic void acpi_hibernation_leave(void)\n{\n\tpm_set_resume_via_firmware();\n\t \n\tacpi_enable();\n\t \n\tacpi_leave_sleep_state_prep(ACPI_STATE_S4);\n\t \n\tif (facs && s4_hardware_signature != facs->hardware_signature)\n\t\tpr_crit(\"Hardware changed while hibernated, success doubtful!\\n\");\n\t \n\tsuspend_nvs_restore();\n\t \n\tacpi_ec_unblock_transactions();\n}\n\nstatic void acpi_pm_thaw(void)\n{\n\tacpi_ec_unblock_transactions();\n\tacpi_enable_all_runtime_gpes();\n}\n\nstatic const struct platform_hibernation_ops acpi_hibernation_ops = {\n\t.begin = acpi_hibernation_begin,\n\t.end = acpi_pm_end,\n\t.pre_snapshot = acpi_pm_prepare,\n\t.finish = acpi_pm_finish,\n\t.prepare = acpi_pm_prepare,\n\t.enter = acpi_hibernation_enter,\n\t.leave = acpi_hibernation_leave,\n\t.pre_restore = acpi_pm_freeze,\n\t.restore_cleanup = acpi_pm_thaw,\n};\n\n \nstatic int acpi_hibernation_begin_old(pm_message_t stage)\n{\n\tint error;\n\t \n\tacpi_sleep_tts_switch(ACPI_STATE_S4);\n\n\terror = acpi_sleep_prepare(ACPI_STATE_S4);\n\tif (error)\n\t\treturn error;\n\n\tif (!nvs_nosave) {\n\t\terror = suspend_nvs_alloc();\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (stage.event == PM_EVENT_HIBERNATE)\n\t\tpm_set_suspend_via_firmware();\n\n\tacpi_target_sleep_state = ACPI_STATE_S4;\n\tacpi_scan_lock_acquire();\n\treturn 0;\n}\n\n \nstatic const struct platform_hibernation_ops acpi_hibernation_ops_old = {\n\t.begin = acpi_hibernation_begin_old,\n\t.end = acpi_pm_end,\n\t.pre_snapshot = acpi_pm_pre_suspend,\n\t.prepare = acpi_pm_freeze,\n\t.finish = acpi_pm_finish,\n\t.enter = acpi_hibernation_enter,\n\t.leave = acpi_hibernation_leave,\n\t.pre_restore = acpi_pm_freeze,\n\t.restore_cleanup = acpi_pm_thaw,\n\t.recover = acpi_pm_finish,\n};\n\nstatic void acpi_sleep_hibernate_setup(void)\n{\n\tif (!acpi_sleep_state_supported(ACPI_STATE_S4))\n\t\treturn;\n\n\thibernation_set_ops(old_suspend_ordering ?\n\t\t\t&acpi_hibernation_ops_old : &acpi_hibernation_ops);\n\tsleep_states[ACPI_STATE_S4] = 1;\n\tif (!acpi_check_s4_hw_signature)\n\t\treturn;\n\n\tacpi_get_table(ACPI_SIG_FACS, 1, (struct acpi_table_header **)&facs);\n\tif (facs) {\n\t\t \n\t\ts4_hardware_signature = facs->hardware_signature;\n\n\t\tif (acpi_check_s4_hw_signature > 0) {\n\t\t\t \n\t\t\tswsusp_hardware_signature = facs->hardware_signature;\n\t\t}\n\t}\n}\n#else  \nstatic inline void acpi_sleep_hibernate_setup(void) {}\n#endif  \n\nstatic int acpi_power_off_prepare(struct sys_off_data *data)\n{\n\t \n\tacpi_sleep_prepare(ACPI_STATE_S5);\n\tacpi_disable_all_gpes();\n\tacpi_os_wait_events_complete();\n\treturn NOTIFY_DONE;\n}\n\nstatic int acpi_power_off(struct sys_off_data *data)\n{\n\t \n\tpr_debug(\"%s called\\n\", __func__);\n\tlocal_irq_disable();\n\tacpi_enter_sleep_state(ACPI_STATE_S5);\n\treturn NOTIFY_DONE;\n}\n\nint __init acpi_sleep_init(void)\n{\n\tchar supported[ACPI_S_STATE_COUNT * 3 + 1];\n\tchar *pos = supported;\n\tint i;\n\n\tacpi_sleep_dmi_check();\n\n\tsleep_states[ACPI_STATE_S0] = 1;\n\n\tacpi_sleep_syscore_init();\n\tacpi_sleep_suspend_setup();\n\tacpi_sleep_hibernate_setup();\n\n\tif (acpi_sleep_state_supported(ACPI_STATE_S5)) {\n\t\tsleep_states[ACPI_STATE_S5] = 1;\n\n\t\tregister_sys_off_handler(SYS_OFF_MODE_POWER_OFF_PREPARE,\n\t\t\t\t\t SYS_OFF_PRIO_FIRMWARE,\n\t\t\t\t\t acpi_power_off_prepare, NULL);\n\n\t\tregister_sys_off_handler(SYS_OFF_MODE_POWER_OFF,\n\t\t\t\t\t SYS_OFF_PRIO_FIRMWARE,\n\t\t\t\t\t acpi_power_off, NULL);\n\n\t\t \n\t\tregister_sys_off_handler(SYS_OFF_MODE_RESTART_PREPARE,\n\t\t\t\t\t SYS_OFF_PRIO_FIRMWARE,\n\t\t\t\t\t acpi_power_off_prepare, NULL);\n\t} else {\n\t\tacpi_no_s5 = true;\n\t}\n\n\tsupported[0] = 0;\n\tfor (i = 0; i < ACPI_S_STATE_COUNT; i++) {\n\t\tif (sleep_states[i])\n\t\t\tpos += sprintf(pos, \" S%d\", i);\n\t}\n\tpr_info(\"(supports%s)\\n\", supported);\n\n\t \n\tregister_reboot_notifier(&tts_notifier);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}