{
  "module_name": "wakeup.c",
  "hash_id": "c99f532ad1bf2fe09a9ff41a238d7c5904ca47dfe5d5a17457a1d40e87de9f92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/wakeup.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#include \"internal.h\"\n#include \"sleep.h\"\n\nstruct acpi_wakeup_handler {\n\tstruct list_head list_node;\n\tbool (*wakeup)(void *context);\n\tvoid *context;\n};\n\nstatic LIST_HEAD(acpi_wakeup_handler_head);\nstatic DEFINE_MUTEX(acpi_wakeup_handler_mutex);\n\n \n\n \nvoid acpi_enable_wakeup_devices(u8 sleep_state)\n{\n\tstruct acpi_device *dev, *tmp;\n\n\tlist_for_each_entry_safe(dev, tmp, &acpi_wakeup_device_list,\n\t\t\t\t wakeup_list) {\n\t\tif (!dev->wakeup.flags.valid\n\t\t    || sleep_state > (u32) dev->wakeup.sleep_state\n\t\t    || !(device_may_wakeup(&dev->dev)\n\t\t\t || dev->wakeup.prepare_count))\n\t\t\tcontinue;\n\n\t\tif (device_may_wakeup(&dev->dev))\n\t\t\tacpi_enable_wakeup_device_power(dev, sleep_state);\n\n\t\t \n\t\tacpi_set_gpe_wake_mask(dev->wakeup.gpe_device, dev->wakeup.gpe_number,\n\t\t\t\tACPI_GPE_ENABLE);\n\t}\n}\n\n \nvoid acpi_disable_wakeup_devices(u8 sleep_state)\n{\n\tstruct acpi_device *dev, *tmp;\n\n\tlist_for_each_entry_safe(dev, tmp, &acpi_wakeup_device_list,\n\t\t\t\t wakeup_list) {\n\t\tif (!dev->wakeup.flags.valid\n\t\t    || sleep_state > (u32) dev->wakeup.sleep_state\n\t\t    || !(device_may_wakeup(&dev->dev)\n\t\t\t || dev->wakeup.prepare_count))\n\t\t\tcontinue;\n\n\t\tacpi_set_gpe_wake_mask(dev->wakeup.gpe_device, dev->wakeup.gpe_number,\n\t\t\t\tACPI_GPE_DISABLE);\n\n\t\tif (device_may_wakeup(&dev->dev))\n\t\t\tacpi_disable_wakeup_device_power(dev);\n\t}\n}\n\nint __init acpi_wakeup_device_init(void)\n{\n\tstruct acpi_device *dev, *tmp;\n\n\tmutex_lock(&acpi_device_lock);\n\tlist_for_each_entry_safe(dev, tmp, &acpi_wakeup_device_list,\n\t\t\t\t wakeup_list) {\n\t\tif (device_can_wakeup(&dev->dev)) {\n\t\t\t \n\t\t\tacpi_enable_gpe(dev->wakeup.gpe_device,\n\t\t\t\t\tdev->wakeup.gpe_number);\n\t\t\tdevice_set_wakeup_enable(&dev->dev, true);\n\t\t}\n\t}\n\tmutex_unlock(&acpi_device_lock);\n\treturn 0;\n}\n\n \nint acpi_register_wakeup_handler(int wake_irq, bool (*wakeup)(void *context),\n\t\t\t\t void *context)\n{\n\tstruct acpi_wakeup_handler *handler;\n\n\t \n\tif (!acpi_sci_irq_valid() || wake_irq != acpi_sci_irq)\n\t\treturn 0;\n\n\thandler = kmalloc(sizeof(*handler), GFP_KERNEL);\n\tif (!handler)\n\t\treturn -ENOMEM;\n\n\thandler->wakeup = wakeup;\n\thandler->context = context;\n\n\tmutex_lock(&acpi_wakeup_handler_mutex);\n\tlist_add(&handler->list_node, &acpi_wakeup_handler_head);\n\tmutex_unlock(&acpi_wakeup_handler_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(acpi_register_wakeup_handler);\n\n \nvoid acpi_unregister_wakeup_handler(bool (*wakeup)(void *context),\n\t\t\t\t    void *context)\n{\n\tstruct acpi_wakeup_handler *handler;\n\n\tmutex_lock(&acpi_wakeup_handler_mutex);\n\tlist_for_each_entry(handler, &acpi_wakeup_handler_head, list_node) {\n\t\tif (handler->wakeup == wakeup && handler->context == context) {\n\t\t\tlist_del(&handler->list_node);\n\t\t\tkfree(handler);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&acpi_wakeup_handler_mutex);\n}\nEXPORT_SYMBOL_GPL(acpi_unregister_wakeup_handler);\n\nbool acpi_check_wakeup_handlers(void)\n{\n\tstruct acpi_wakeup_handler *handler;\n\n\t \n\tlist_for_each_entry(handler, &acpi_wakeup_handler_head, list_node) {\n\t\tif (handler->wakeup(handler->context))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}