{
  "module_name": "intel_pmic_bxtwc.c",
  "hash_id": "a956b3e4be6308a9960ac71bcc510516804df48e5939a4726690695bea249f1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pmic/intel_pmic_bxtwc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/acpi.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n#include \"intel_pmic.h\"\n\n#define WHISKEY_COVE_ALRT_HIGH_BIT_MASK 0x0F\n#define WHISKEY_COVE_ADC_HIGH_BIT(x)\t(((x & 0x0F) << 8))\n#define WHISKEY_COVE_ADC_CURSRC(x)\t(((x & 0xF0) >> 4))\n#define VR_MODE_DISABLED        0\n#define VR_MODE_AUTO            BIT(0)\n#define VR_MODE_NORMAL          BIT(1)\n#define VR_MODE_SWITCH          BIT(2)\n#define VR_MODE_ECO             (BIT(0)|BIT(1))\n#define VSWITCH2_OUTPUT         BIT(5)\n#define VSWITCH1_OUTPUT         BIT(4)\n#define VUSBPHY_CHARGE          BIT(1)\n\nstatic struct pmic_table power_table[] = {\n\t{\n\t\t.address = 0x0,\n\t\t.reg = 0x63,\n\t\t.bit = VR_MODE_AUTO,\n\t},  \n\t{\n\t\t.address = 0x04,\n\t\t.reg = 0x65,\n\t\t.bit = VR_MODE_AUTO,\n\t},  \n\t{\n\t\t.address = 0x08,\n\t\t.reg = 0x67,\n\t\t.bit = VR_MODE_AUTO,\n\t},  \n\t{\n\t\t.address = 0x0c,\n\t\t.reg = 0x6d,\n\t\t.bit = VR_MODE_AUTO,\n\t},  \n\t{\n\t\t.address = 0x10,\n\t\t.reg = 0x6f,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x14,\n\t\t.reg = 0x70,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x18,\n\t\t.reg = 0x71,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x1c,\n\t\t.reg = 0x72,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x20,\n\t\t.reg = 0x73,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x24,\n\t\t.reg = 0x74,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x28,\n\t\t.reg = 0x75,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x2c,\n\t\t.reg = 0x76,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x30,\n\t\t.reg = 0x77,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x34,\n\t\t.reg = 0x78,\n\t\t.bit = VSWITCH2_OUTPUT,\n\t},  \n\t{\n\t\t.address = 0x38,\n\t\t.reg = 0x78,\n\t\t.bit = VSWITCH1_OUTPUT,\n\t},  \n\t{\n\t\t.address = 0x3c,\n\t\t.reg = 0x78,\n\t\t.bit = VUSBPHY_CHARGE,\n\t},  \n\t{\n\t\t.address = 0x40,\n\t\t.reg = 0x7b,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x44,\n\t\t.reg = 0xA0,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x48,\n\t\t.reg = 0xA1,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x4c,\n\t\t.reg = 0xA2,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x50,\n\t\t.reg = 0xA3,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x54,\n\t\t.reg = 0xA4,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x58,\n\t\t.reg = 0xA5,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x5c,\n\t\t.reg = 0xA6,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x60,\n\t\t.reg = 0xA7,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x64,\n\t\t.reg = 0xA8,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x68,\n\t\t.reg = 0xA9,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x6c,\n\t\t.reg = 0xAA,\n\t\t.bit = VR_MODE_NORMAL,\n\t},  \n\t{\n\t\t.address = 0x70,\n\t\t.reg = 0x36,\n\t\t.bit = BIT(2),\n\t},  \n\t{\n\t\t.address = 0x74,\n\t\t.reg = 0x36,\n\t\t.bit = BIT(0),\n\t}  \n};\n\nstatic struct pmic_table thermal_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = 0x4F39\n\t},\n\t{\n\t\t.address = 0x04,\n\t\t.reg = 0x4F24\n\t},\n\t{\n\t\t.address = 0x08,\n\t\t.reg = 0x4F26\n\t},\n\t{\n\t\t.address = 0x0c,\n\t\t.reg = 0x4F3B\n\t},\n\t{\n\t\t.address = 0x10,\n\t\t.reg = 0x4F28\n\t},\n\t{\n\t\t.address = 0x14,\n\t\t.reg = 0x4F2A\n\t},\n\t{\n\t\t.address = 0x18,\n\t\t.reg = 0x4F3D\n\t},\n\t{\n\t\t.address = 0x1c,\n\t\t.reg = 0x4F2C\n\t},\n\t{\n\t\t.address = 0x20,\n\t\t.reg = 0x4F2E\n\t},\n\t{\n\t\t.address = 0x24,\n\t\t.reg = 0x4F3F\n\t},\n\t{\n\t\t.address = 0x28,\n\t\t.reg = 0x4F30\n\t},\n\t{\n\t\t.address = 0x30,\n\t\t.reg = 0x4F41\n\t},\n\t{\n\t\t.address = 0x34,\n\t\t.reg = 0x4F32\n\t},\n\t{\n\t\t.address = 0x3c,\n\t\t.reg = 0x4F43\n\t},\n\t{\n\t\t.address = 0x40,\n\t\t.reg = 0x4F34\n\t},\n\t{\n\t\t.address = 0x48,\n\t\t.reg = 0x4F6A,\n\t\t.bit = 0,\n\t},\n\t{\n\t\t.address = 0x4C,\n\t\t.reg = 0x4F6A,\n\t\t.bit = 1\n\t},\n\t{\n\t\t.address = 0x50,\n\t\t.reg = 0x4F6A,\n\t\t.bit = 2\n\t},\n\t{\n\t\t.address = 0x54,\n\t\t.reg = 0x4F6A,\n\t\t.bit = 4\n\t},\n\t{\n\t\t.address = 0x58,\n\t\t.reg = 0x4F6A,\n\t\t.bit = 5\n\t},\n\t{\n\t\t.address = 0x5C,\n\t\t.reg = 0x4F6A,\n\t\t.bit = 3\n\t},\n};\n\nstatic int intel_bxtwc_pmic_get_power(struct regmap *regmap, int reg,\n\t\tint bit, u64 *value)\n{\n\tint data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\t*value = (data & bit) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int intel_bxtwc_pmic_update_power(struct regmap *regmap, int reg,\n\t\tint bit, bool on)\n{\n\tu8 val, mask = bit;\n\n\tif (on)\n\t\tval = 0xFF;\n\telse\n\t\tval = 0x0;\n\n\treturn regmap_update_bits(regmap, reg, mask, val);\n}\n\nstatic int intel_bxtwc_pmic_get_raw_temp(struct regmap *regmap, int reg)\n{\n\tunsigned int val, adc_val, reg_val;\n\tu8 temp_l, temp_h, cursrc;\n\tunsigned long rlsb;\n\tstatic const unsigned long rlsb_array[] = {\n\t\t0, 260420, 130210, 65100, 32550, 16280,\n\t\t8140, 4070, 2030, 0, 260420, 130210 };\n\n\tif (regmap_read(regmap, reg, &val))\n\t\treturn -EIO;\n\ttemp_l = (u8) val;\n\n\tif (regmap_read(regmap, (reg - 1), &val))\n\t\treturn -EIO;\n\ttemp_h = (u8) val;\n\n\treg_val = temp_l | WHISKEY_COVE_ADC_HIGH_BIT(temp_h);\n\tcursrc = WHISKEY_COVE_ADC_CURSRC(temp_h);\n\trlsb = rlsb_array[cursrc];\n\tadc_val = reg_val * rlsb / 1000;\n\n\treturn adc_val;\n}\n\nstatic int\nintel_bxtwc_pmic_update_aux(struct regmap *regmap, int reg, int raw)\n{\n\tu32 bsr_num;\n\tu16 resi_val, count = 0, thrsh = 0;\n\tu8 alrt_h, alrt_l, cursel = 0;\n\n\tbsr_num = raw;\n\tbsr_num /= (1 << 5);\n\n\tcount = fls(bsr_num) - 1;\n\n\tcursel = clamp_t(s8, (count - 7), 0, 7);\n\tthrsh = raw / (1 << (4 + cursel));\n\n\tresi_val = (cursel << 9) | thrsh;\n\talrt_h = (resi_val >> 8) & WHISKEY_COVE_ALRT_HIGH_BIT_MASK;\n\tif (regmap_update_bits(regmap,\n\t\t\t\treg - 1,\n\t\t\t\tWHISKEY_COVE_ALRT_HIGH_BIT_MASK,\n\t\t\t\talrt_h))\n\t\treturn -EIO;\n\n\talrt_l = (u8)resi_val;\n\treturn regmap_write(regmap, reg, alrt_l);\n}\n\nstatic int\nintel_bxtwc_pmic_get_policy(struct regmap *regmap, int reg, int bit, u64 *value)\n{\n\tu8 mask = BIT(bit);\n\tunsigned int val;\n\n\tif (regmap_read(regmap, reg, &val))\n\t\treturn -EIO;\n\n\t*value = (val & mask) >> bit;\n\treturn 0;\n}\n\nstatic int\nintel_bxtwc_pmic_update_policy(struct regmap *regmap,\n\t\t\t\tint reg, int bit, int enable)\n{\n\tu8 mask = BIT(bit), val = enable << bit;\n\n\treturn regmap_update_bits(regmap, reg, mask, val);\n}\n\nstatic const struct intel_pmic_opregion_data intel_bxtwc_pmic_opregion_data = {\n\t.get_power      = intel_bxtwc_pmic_get_power,\n\t.update_power   = intel_bxtwc_pmic_update_power,\n\t.get_raw_temp   = intel_bxtwc_pmic_get_raw_temp,\n\t.update_aux     = intel_bxtwc_pmic_update_aux,\n\t.get_policy     = intel_bxtwc_pmic_get_policy,\n\t.update_policy  = intel_bxtwc_pmic_update_policy,\n\t.lpat_raw_to_temp = acpi_lpat_raw_to_temp,\n\t.power_table      = power_table,\n\t.power_table_count = ARRAY_SIZE(power_table),\n\t.thermal_table     = thermal_table,\n\t.thermal_table_count = ARRAY_SIZE(thermal_table),\n};\n\nstatic int intel_bxtwc_pmic_opregion_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\n\treturn intel_pmic_install_opregion_handler(&pdev->dev,\n\t\t\tACPI_HANDLE(pdev->dev.parent),\n\t\t\tpmic->regmap,\n\t\t\t&intel_bxtwc_pmic_opregion_data);\n}\n\nstatic const struct platform_device_id bxt_wc_opregion_id_table[] = {\n\t{ .name = \"bxt_wcove_region\" },\n\t{},\n};\n\nstatic struct platform_driver intel_bxtwc_pmic_opregion_driver = {\n\t.probe = intel_bxtwc_pmic_opregion_probe,\n\t.driver = {\n\t\t.name = \"bxt_whiskey_cove_pmic\",\n\t},\n\t.id_table = bxt_wc_opregion_id_table,\n};\nbuiltin_platform_driver(intel_bxtwc_pmic_opregion_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}