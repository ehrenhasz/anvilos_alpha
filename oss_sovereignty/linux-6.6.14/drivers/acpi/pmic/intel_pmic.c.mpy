{
  "module_name": "intel_pmic.c",
  "hash_id": "0dbce5342ad91043a8d99e2e1b25472558793bcf7e3031262c7f6d3c9a1c2753",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pmic/intel_pmic.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/acpi.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/regmap.h>\n#include <acpi/acpi_lpat.h>\n#include \"intel_pmic.h\"\n\n#define PMIC_POWER_OPREGION_ID\t\t0x8d\n#define PMIC_THERMAL_OPREGION_ID\t0x8c\n#define PMIC_REGS_OPREGION_ID\t\t0x8f\n\nstruct intel_pmic_regs_handler_ctx {\n\tunsigned int val;\n\tu16 addr;\n};\n\nstruct intel_pmic_opregion {\n\tstruct mutex lock;\n\tstruct acpi_lpat_conversion_table *lpat_table;\n\tstruct regmap *regmap;\n\tconst struct intel_pmic_opregion_data *data;\n\tstruct intel_pmic_regs_handler_ctx ctx;\n};\n\nstatic struct intel_pmic_opregion *intel_pmic_opregion;\n\nstatic int pmic_get_reg_bit(int address, struct pmic_table *table,\n\t\t\t    int count, int *reg, int *bit)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (table[i].address == address) {\n\t\t\t*reg = table[i].reg;\n\t\t\tif (bit)\n\t\t\t\t*bit = table[i].bit;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nstatic acpi_status intel_pmic_power_handler(u32 function,\n\t\tacpi_physical_address address, u32 bits, u64 *value64,\n\t\tvoid *handler_context, void *region_context)\n{\n\tstruct intel_pmic_opregion *opregion = region_context;\n\tstruct regmap *regmap = opregion->regmap;\n\tconst struct intel_pmic_opregion_data *d = opregion->data;\n\tint reg, bit, result;\n\n\tif (bits != 32 || !value64)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (function == ACPI_WRITE && !(*value64 == 0 || *value64 == 1))\n\t\treturn AE_BAD_PARAMETER;\n\n\tresult = pmic_get_reg_bit(address, d->power_table,\n\t\t\t\t  d->power_table_count, &reg, &bit);\n\tif (result == -ENOENT)\n\t\treturn AE_BAD_PARAMETER;\n\n\tmutex_lock(&opregion->lock);\n\n\tresult = function == ACPI_READ ?\n\t\td->get_power(regmap, reg, bit, value64) :\n\t\td->update_power(regmap, reg, bit, *value64 == 1);\n\n\tmutex_unlock(&opregion->lock);\n\n\treturn result ? AE_ERROR : AE_OK;\n}\n\nstatic int pmic_read_temp(struct intel_pmic_opregion *opregion,\n\t\t\t  int reg, u64 *value)\n{\n\tint raw_temp, temp;\n\n\tif (!opregion->data->get_raw_temp)\n\t\treturn -ENXIO;\n\n\traw_temp = opregion->data->get_raw_temp(opregion->regmap, reg);\n\tif (raw_temp < 0)\n\t\treturn raw_temp;\n\n\tif (!opregion->lpat_table) {\n\t\t*value = raw_temp;\n\t\treturn 0;\n\t}\n\n\ttemp = opregion->data->lpat_raw_to_temp(opregion->lpat_table, raw_temp);\n\tif (temp < 0)\n\t\treturn temp;\n\n\t*value = temp;\n\treturn 0;\n}\n\nstatic int pmic_thermal_temp(struct intel_pmic_opregion *opregion, int reg,\n\t\t\t     u32 function, u64 *value)\n{\n\treturn function == ACPI_READ ?\n\t\tpmic_read_temp(opregion, reg, value) : -EINVAL;\n}\n\nstatic int pmic_thermal_aux(struct intel_pmic_opregion *opregion, int reg,\n\t\t\t    u32 function, u64 *value)\n{\n\tint raw_temp;\n\n\tif (function == ACPI_READ)\n\t\treturn pmic_read_temp(opregion, reg, value);\n\n\tif (!opregion->data->update_aux)\n\t\treturn -ENXIO;\n\n\tif (opregion->lpat_table) {\n\t\traw_temp = acpi_lpat_temp_to_raw(opregion->lpat_table, *value);\n\t\tif (raw_temp < 0)\n\t\t\treturn raw_temp;\n\t} else {\n\t\traw_temp = *value;\n\t}\n\n\treturn opregion->data->update_aux(opregion->regmap, reg, raw_temp);\n}\n\nstatic int pmic_thermal_pen(struct intel_pmic_opregion *opregion, int reg,\n\t\t\t    int bit, u32 function, u64 *value)\n{\n\tconst struct intel_pmic_opregion_data *d = opregion->data;\n\tstruct regmap *regmap = opregion->regmap;\n\n\tif (!d->get_policy || !d->update_policy)\n\t\treturn -ENXIO;\n\n\tif (function == ACPI_READ)\n\t\treturn d->get_policy(regmap, reg, bit, value);\n\n\tif (*value != 0 && *value != 1)\n\t\treturn -EINVAL;\n\n\treturn d->update_policy(regmap, reg, bit, *value);\n}\n\nstatic bool pmic_thermal_is_temp(int address)\n{\n\treturn (address <= 0x3c) && !(address % 12);\n}\n\nstatic bool pmic_thermal_is_aux(int address)\n{\n\treturn (address >= 4 && address <= 0x40 && !((address - 4) % 12)) ||\n\t       (address >= 8 && address <= 0x44 && !((address - 8) % 12));\n}\n\nstatic bool pmic_thermal_is_pen(int address)\n{\n\treturn address >= 0x48 && address <= 0x5c;\n}\n\nstatic acpi_status intel_pmic_thermal_handler(u32 function,\n\t\tacpi_physical_address address, u32 bits, u64 *value64,\n\t\tvoid *handler_context, void *region_context)\n{\n\tstruct intel_pmic_opregion *opregion = region_context;\n\tconst struct intel_pmic_opregion_data *d = opregion->data;\n\tint reg, bit, result;\n\n\tif (bits != 32 || !value64)\n\t\treturn AE_BAD_PARAMETER;\n\n\tresult = pmic_get_reg_bit(address, d->thermal_table,\n\t\t\t\t  d->thermal_table_count, &reg, &bit);\n\tif (result == -ENOENT)\n\t\treturn AE_BAD_PARAMETER;\n\n\tmutex_lock(&opregion->lock);\n\n\tif (pmic_thermal_is_temp(address))\n\t\tresult = pmic_thermal_temp(opregion, reg, function, value64);\n\telse if (pmic_thermal_is_aux(address))\n\t\tresult = pmic_thermal_aux(opregion, reg, function, value64);\n\telse if (pmic_thermal_is_pen(address))\n\t\tresult = pmic_thermal_pen(opregion, reg, bit,\n\t\t\t\t\t\tfunction, value64);\n\telse\n\t\tresult = -EINVAL;\n\n\tmutex_unlock(&opregion->lock);\n\n\tif (result < 0) {\n\t\tif (result == -EINVAL)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\telse\n\t\t\treturn AE_ERROR;\n\t}\n\n\treturn AE_OK;\n}\n\nstatic acpi_status intel_pmic_regs_handler(u32 function,\n\t\tacpi_physical_address address, u32 bits, u64 *value64,\n\t\tvoid *handler_context, void *region_context)\n{\n\tstruct intel_pmic_opregion *opregion = region_context;\n\tint result = -EINVAL;\n\n\tif (function == ACPI_WRITE) {\n\t\tswitch (address) {\n\t\tcase 0:\n\t\t\treturn AE_OK;\n\t\tcase 1:\n\t\t\topregion->ctx.addr |= (*value64 & 0xff) << 8;\n\t\t\treturn AE_OK;\n\t\tcase 2:\n\t\t\topregion->ctx.addr |= *value64 & 0xff;\n\t\t\treturn AE_OK;\n\t\tcase 3:\n\t\t\topregion->ctx.val = *value64 & 0xff;\n\t\t\treturn AE_OK;\n\t\tcase 4:\n\t\t\tif (*value64) {\n\t\t\t\tresult = regmap_write(opregion->regmap, opregion->ctx.addr,\n\t\t\t\t\t\t      opregion->ctx.val);\n\t\t\t} else {\n\t\t\t\tresult = regmap_read(opregion->regmap, opregion->ctx.addr,\n\t\t\t\t\t\t     &opregion->ctx.val);\n\t\t\t}\n\t\t\topregion->ctx.addr = 0;\n\t\t}\n\t}\n\n\tif (function == ACPI_READ && address == 3) {\n\t\t*value64 = opregion->ctx.val;\n\t\treturn AE_OK;\n\t}\n\n\tif (result < 0) {\n\t\tif (result == -EINVAL)\n\t\t\treturn AE_BAD_PARAMETER;\n\t\telse\n\t\t\treturn AE_ERROR;\n\t}\n\n\treturn AE_OK;\n}\n\nint intel_pmic_install_opregion_handler(struct device *dev, acpi_handle handle,\n\t\t\t\t\tstruct regmap *regmap,\n\t\t\t\t\tconst struct intel_pmic_opregion_data *d)\n{\n\tacpi_status status = AE_OK;\n\tstruct intel_pmic_opregion *opregion;\n\tint ret;\n\n\tif (!dev || !regmap || !d)\n\t\treturn -EINVAL;\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\topregion = devm_kzalloc(dev, sizeof(*opregion), GFP_KERNEL);\n\tif (!opregion)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&opregion->lock);\n\topregion->regmap = regmap;\n\topregion->lpat_table = acpi_lpat_get_conversion_table(handle);\n\n\tif (d->power_table_count)\n\t\tstatus = acpi_install_address_space_handler(handle,\n\t\t\t\t\t\t    PMIC_POWER_OPREGION_ID,\n\t\t\t\t\t\t    intel_pmic_power_handler,\n\t\t\t\t\t\t    NULL, opregion);\n\tif (ACPI_FAILURE(status)) {\n\t\tret = -ENODEV;\n\t\tgoto out_error;\n\t}\n\n\tif (d->thermal_table_count)\n\t\tstatus = acpi_install_address_space_handler(handle,\n\t\t\t\t\t\t    PMIC_THERMAL_OPREGION_ID,\n\t\t\t\t\t\t    intel_pmic_thermal_handler,\n\t\t\t\t\t\t    NULL, opregion);\n\tif (ACPI_FAILURE(status)) {\n\t\tret = -ENODEV;\n\t\tgoto out_remove_power_handler;\n\t}\n\n\tstatus = acpi_install_address_space_handler(handle,\n\t\t\tPMIC_REGS_OPREGION_ID, intel_pmic_regs_handler, NULL,\n\t\t\topregion);\n\tif (ACPI_FAILURE(status)) {\n\t\tret = -ENODEV;\n\t\tgoto out_remove_thermal_handler;\n\t}\n\n\topregion->data = d;\n\tintel_pmic_opregion = opregion;\n\treturn 0;\n\nout_remove_thermal_handler:\n\tif (d->thermal_table_count)\n\t\tacpi_remove_address_space_handler(handle,\n\t\t\t\t\t\t  PMIC_THERMAL_OPREGION_ID,\n\t\t\t\t\t\t  intel_pmic_thermal_handler);\n\nout_remove_power_handler:\n\tif (d->power_table_count)\n\t\tacpi_remove_address_space_handler(handle,\n\t\t\t\t\t\t  PMIC_POWER_OPREGION_ID,\n\t\t\t\t\t\t  intel_pmic_power_handler);\n\nout_error:\n\tacpi_lpat_free_conversion_table(opregion->lpat_table);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(intel_pmic_install_opregion_handler);\n\n \nint intel_soc_pmic_exec_mipi_pmic_seq_element(u16 i2c_address, u32 reg_address,\n\t\t\t\t\t      u32 value, u32 mask)\n{\n\tconst struct intel_pmic_opregion_data *d;\n\tint ret;\n\n\tif (!intel_pmic_opregion) {\n\t\tpr_warn(\"%s: No PMIC registered\\n\", __func__);\n\t\treturn -ENXIO;\n\t}\n\n\td = intel_pmic_opregion->data;\n\n\tmutex_lock(&intel_pmic_opregion->lock);\n\n\tif (d->exec_mipi_pmic_seq_element) {\n\t\tret = d->exec_mipi_pmic_seq_element(intel_pmic_opregion->regmap,\n\t\t\t\t\t\t    i2c_address, reg_address,\n\t\t\t\t\t\t    value, mask);\n\t} else if (d->pmic_i2c_address) {\n\t\tif (i2c_address == d->pmic_i2c_address) {\n\t\t\tret = regmap_update_bits(intel_pmic_opregion->regmap,\n\t\t\t\t\t\t reg_address, mask, value);\n\t\t} else {\n\t\t\tpr_err(\"%s: Unexpected i2c-addr: 0x%02x (reg-addr 0x%x value 0x%x mask 0x%x)\\n\",\n\t\t\t       __func__, i2c_address, reg_address, value, mask);\n\t\t\tret = -ENXIO;\n\t\t}\n\t} else {\n\t\tpr_warn(\"%s: Not implemented\\n\", __func__);\n\t\tpr_warn(\"%s: i2c-addr: 0x%x reg-addr 0x%x value 0x%x mask 0x%x\\n\",\n\t\t\t__func__, i2c_address, reg_address, value, mask);\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\tmutex_unlock(&intel_pmic_opregion->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(intel_soc_pmic_exec_mipi_pmic_seq_element);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}