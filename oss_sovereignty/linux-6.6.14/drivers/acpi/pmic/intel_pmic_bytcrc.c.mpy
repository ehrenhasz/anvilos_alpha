{
  "module_name": "intel_pmic_bytcrc.c",
  "hash_id": "a8991a646dc4a026c9694617462709f34fbf3aa7a28fb8b166157078c410f7c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pmic/intel_pmic_bytcrc.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include \"intel_pmic.h\"\n\n#define PWR_SOURCE_SELECT\tBIT(1)\n\n#define PMIC_A0LOCK_REG\t\t0xc5\n\nstatic struct pmic_table power_table[] = {\n \n\t{\n\t\t.address = 0x04,\n\t\t.reg = 0x63,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x08,\n\t\t.reg = 0x62,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x0c,\n\t\t.reg = 0x64,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x10,\n\t\t.reg = 0x6a,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x14,\n\t\t.reg = 0x6b,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x18,\n\t\t.reg = 0x6c,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x1c,\n\t\t.reg = 0x6d,\n\t\t.bit = 0x00,\n\t},  \n \n\t{\n\t\t.address = 0x24,\n\t\t.reg = 0x66,\n\t\t.bit = 0x00,\n\t},  \n \n\t{\n\t\t.address = 0x2c,\n\t\t.reg = 0x69,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x30,\n\t\t.reg = 0x68,\n\t\t.bit = 0x00,\n\t},  \n \n\t{\n\t\t.address = 0x44,\n\t\t.reg = 0x5c,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x48,\n\t\t.reg = 0x5d,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x4c,\n\t\t.reg = 0x5b,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x50,\n\t\t.reg = 0x61,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x54,\n\t\t.reg = 0x60,\n\t\t.bit = 0x00,\n\t},  \n \n\t{\n\t\t.address = 0x5c,\n\t\t.reg = 0x56,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x60,\n\t\t.reg = 0x57,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x64,\n\t\t.reg = 0x59,\n\t\t.bit = 0x00,\n\t},  \n};\n\nstatic struct pmic_table thermal_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = 0x75\n\t},\n\t{\n\t\t.address = 0x04,\n\t\t.reg = 0x95\n\t},\n\t{\n\t\t.address = 0x08,\n\t\t.reg = 0x97\n\t},\n\t{\n\t\t.address = 0x0c,\n\t\t.reg = 0x77\n\t},\n\t{\n\t\t.address = 0x10,\n\t\t.reg = 0x9a\n\t},\n\t{\n\t\t.address = 0x14,\n\t\t.reg = 0x9c\n\t},\n\t{\n\t\t.address = 0x18,\n\t\t.reg = 0x79\n\t},\n\t{\n\t\t.address = 0x1c,\n\t\t.reg = 0x9f\n\t},\n\t{\n\t\t.address = 0x20,\n\t\t.reg = 0xa1\n\t},\n\t{\n\t\t.address = 0x48,\n\t\t.reg = 0x94\n\t},\n\t{\n\t\t.address = 0x4c,\n\t\t.reg = 0x99\n\t},\n\t{\n\t\t.address = 0x50,\n\t\t.reg = 0x9e\n\t},\n};\n\nstatic int intel_crc_pmic_get_power(struct regmap *regmap, int reg,\n\t\t\t\t    int bit, u64 *value)\n{\n\tint data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\t*value = (data & PWR_SOURCE_SELECT) && (data & BIT(bit)) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int intel_crc_pmic_update_power(struct regmap *regmap, int reg,\n\t\t\t\t       int bit, bool on)\n{\n\tint data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\tif (on) {\n\t\tdata |= PWR_SOURCE_SELECT | BIT(bit);\n\t} else {\n\t\tdata &= ~BIT(bit);\n\t\tdata |= PWR_SOURCE_SELECT;\n\t}\n\n\tif (regmap_write(regmap, reg, data))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int intel_crc_pmic_get_raw_temp(struct regmap *regmap, int reg)\n{\n\tint temp_l, temp_h;\n\n\t \n\tif (regmap_read(regmap, reg, &temp_l) ||\n\t    regmap_read(regmap, reg - 1, &temp_h))\n\t\treturn -EIO;\n\n\treturn temp_l | (temp_h & 0x3) << 8;\n}\n\nstatic int intel_crc_pmic_update_aux(struct regmap *regmap, int reg, int raw)\n{\n\treturn regmap_write(regmap, reg, raw) ||\n\t\tregmap_update_bits(regmap, reg - 1, 0x3, raw >> 8) ? -EIO : 0;\n}\n\nstatic int intel_crc_pmic_get_policy(struct regmap *regmap,\n\t\t\t\t\tint reg, int bit, u64 *value)\n{\n\tint pen;\n\n\tif (regmap_read(regmap, reg, &pen))\n\t\treturn -EIO;\n\t*value = pen >> 7;\n\treturn 0;\n}\n\nstatic int intel_crc_pmic_update_policy(struct regmap *regmap,\n\t\t\t\t\tint reg, int bit, int enable)\n{\n\tint alert0;\n\n\t \n\tif (regmap_read(regmap, PMIC_A0LOCK_REG, &alert0))\n\t\treturn -EIO;\n\n\tif (regmap_update_bits(regmap, PMIC_A0LOCK_REG, 0x01, 0))\n\t\treturn -EIO;\n\n\tif (regmap_update_bits(regmap, reg, 0x80, enable << 7))\n\t\treturn -EIO;\n\n\t \n\tif (regmap_write(regmap, PMIC_A0LOCK_REG, alert0))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic const struct intel_pmic_opregion_data intel_crc_pmic_opregion_data = {\n\t.get_power\t= intel_crc_pmic_get_power,\n\t.update_power\t= intel_crc_pmic_update_power,\n\t.get_raw_temp\t= intel_crc_pmic_get_raw_temp,\n\t.update_aux\t= intel_crc_pmic_update_aux,\n\t.get_policy\t= intel_crc_pmic_get_policy,\n\t.update_policy\t= intel_crc_pmic_update_policy,\n\t.lpat_raw_to_temp = acpi_lpat_raw_to_temp,\n\t.power_table\t= power_table,\n\t.power_table_count= ARRAY_SIZE(power_table),\n\t.thermal_table\t= thermal_table,\n\t.thermal_table_count = ARRAY_SIZE(thermal_table),\n\t.pmic_i2c_address = 0x6e,\n};\n\nstatic int intel_crc_pmic_opregion_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\treturn intel_pmic_install_opregion_handler(&pdev->dev,\n\t\t\tACPI_HANDLE(pdev->dev.parent), pmic->regmap,\n\t\t\t&intel_crc_pmic_opregion_data);\n}\n\nstatic struct platform_driver intel_crc_pmic_opregion_driver = {\n\t.probe = intel_crc_pmic_opregion_probe,\n\t.driver = {\n\t\t.name = \"byt_crystal_cove_pmic\",\n\t},\n};\nbuiltin_platform_driver(intel_crc_pmic_opregion_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}