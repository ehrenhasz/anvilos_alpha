{
  "module_name": "tps68470_pmic.c",
  "hash_id": "dcf09f09ab07ea1118facb7687c7068b121ca0262cb28717571f38e8e6001f3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pmic/tps68470_pmic.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/mfd/tps68470.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\nstruct tps68470_pmic_table {\n\tu32 address;\t\t \n\tu32 reg;\t\t \n\tu32 bitmask;\t\t \n};\n\n#define TI_PMIC_POWER_OPREGION_ID\t\t0xB0\n#define TI_PMIC_VR_VAL_OPREGION_ID\t\t0xB1\n#define TI_PMIC_CLOCK_OPREGION_ID\t\t0xB2\n#define TI_PMIC_CLKFREQ_OPREGION_ID\t\t0xB3\n\nstruct tps68470_pmic_opregion {\n\tstruct mutex lock;\n\tstruct regmap *regmap;\n};\n\n#define S_IO_I2C_EN\t(BIT(0) | BIT(1))\n\nstatic const struct tps68470_pmic_table power_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = TPS68470_REG_S_I2C_CTL,\n\t\t.bitmask = S_IO_I2C_EN,\n\t\t \n\t},\n\t{\n\t\t.address = 0x04,\n\t\t.reg = TPS68470_REG_VCMCTL,\n\t\t.bitmask = BIT(0),\n\t\t \n\t},\n\t{\n\t\t.address = 0x08,\n\t\t.reg = TPS68470_REG_VAUX1CTL,\n\t\t.bitmask = BIT(0),\n\t\t \n\t},\n\t{\n\t\t.address = 0x0C,\n\t\t.reg = TPS68470_REG_VAUX2CTL,\n\t\t.bitmask = BIT(0),\n\t\t \n\t},\n\t{\n\t\t.address = 0x10,\n\t\t.reg = TPS68470_REG_VACTL,\n\t\t.bitmask = BIT(0),\n\t\t \n\t},\n\t{\n\t\t.address = 0x14,\n\t\t.reg = TPS68470_REG_VDCTL,\n\t\t.bitmask = BIT(0),\n\t\t \n\t},\n};\n\n \nstatic const struct tps68470_pmic_table vr_val_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = TPS68470_REG_VSIOVAL,\n\t\t.bitmask = TPS68470_VSIOVAL_IOVOLT_MASK,\n\t\t \n\t},\n\t{\n\t\t.address = 0x04,\n\t\t.reg = TPS68470_REG_VIOVAL,\n\t\t.bitmask = TPS68470_VIOVAL_IOVOLT_MASK,\n\t\t \n\t},\n\t{\n\t\t.address = 0x08,\n\t\t.reg = TPS68470_REG_VCMVAL,\n\t\t.bitmask = TPS68470_VCMVAL_VCVOLT_MASK,\n\t\t \n\t},\n\t{\n\t\t.address = 0x0C,\n\t\t.reg = TPS68470_REG_VAUX1VAL,\n\t\t.bitmask = TPS68470_VAUX1VAL_AUX1VOLT_MASK,\n\t\t \n\t},\n\t{\n\t\t.address = 0x10,\n\t\t.reg = TPS68470_REG_VAUX2VAL,\n\t\t.bitmask = TPS68470_VAUX2VAL_AUX2VOLT_MASK,\n\t\t \n\t},\n\t{\n\t\t.address = 0x14,\n\t\t.reg = TPS68470_REG_VAVAL,\n\t\t.bitmask = TPS68470_VAVAL_AVOLT_MASK,\n\t\t \n\t},\n\t{\n\t\t.address = 0x18,\n\t\t.reg = TPS68470_REG_VDVAL,\n\t\t.bitmask = TPS68470_VDVAL_DVOLT_MASK,\n\t\t \n\t},\n};\n\n \nstatic const struct tps68470_pmic_table clk_freq_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = TPS68470_REG_POSTDIV2,\n\t\t.bitmask = BIT(0) | BIT(1),\n\t\t \n\t},\n\t{\n\t\t.address = 0x04,\n\t\t.reg = TPS68470_REG_BOOSTDIV,\n\t\t.bitmask = 0x1F,\n\t\t \n\t},\n\t{\n\t\t.address = 0x08,\n\t\t.reg = TPS68470_REG_BUCKDIV,\n\t\t.bitmask = 0x0F,\n\t\t \n\t},\n\t{\n\t\t.address = 0x0C,\n\t\t.reg = TPS68470_REG_PLLSWR,\n\t\t.bitmask = 0x13,\n\t\t \n\t},\n\t{\n\t\t.address = 0x10,\n\t\t.reg = TPS68470_REG_XTALDIV,\n\t\t.bitmask = 0xFF,\n\t\t \n\t},\n\t{\n\t\t.address = 0x14,\n\t\t.reg = TPS68470_REG_PLLDIV,\n\t\t.bitmask = 0xFF,\n\t\t \n\t},\n\t{\n\t\t.address = 0x18,\n\t\t.reg = TPS68470_REG_POSTDIV,\n\t\t.bitmask = 0x83,\n\t\t \n\t},\n};\n\n \nstatic const struct tps68470_pmic_table clk_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = TPS68470_REG_PLLCTL,\n\t\t.bitmask = 0xF5,\n\t\t \n\t},\n\t{\n\t\t.address = 0x04,\n\t\t.reg = TPS68470_REG_PLLCTL2,\n\t\t.bitmask = BIT(0),\n\t\t \n\t},\n\t{\n\t\t.address = 0x08,\n\t\t.reg = TPS68470_REG_CLKCFG1,\n\t\t.bitmask = TPS68470_CLKCFG1_MODE_A_MASK |\n\t\t\tTPS68470_CLKCFG1_MODE_B_MASK,\n\t\t \n\t},\n\t{\n\t\t.address = 0x0C,\n\t\t.reg = TPS68470_REG_CLKCFG2,\n\t\t.bitmask = TPS68470_CLKCFG1_MODE_A_MASK |\n\t\t\tTPS68470_CLKCFG1_MODE_B_MASK,\n\t\t \n\t},\n};\n\nstatic int pmic_get_reg_bit(u64 address,\n\t\t\t    const struct tps68470_pmic_table *table,\n\t\t\t    const unsigned int table_size, int *reg,\n\t\t\t    int *bitmask)\n{\n\tu64 i;\n\n\ti = address / 4;\n\tif (i >= table_size)\n\t\treturn -ENOENT;\n\n\tif (!reg || !bitmask)\n\t\treturn -EINVAL;\n\n\t*reg = table[i].reg;\n\t*bitmask = table[i].bitmask;\n\n\treturn 0;\n}\n\nstatic int tps68470_pmic_get_power(struct regmap *regmap, int reg,\n\t\t\t\t       int bitmask, u64 *value)\n{\n\tunsigned int data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\t*value = (data & bitmask) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int tps68470_pmic_get_vr_val(struct regmap *regmap, int reg,\n\t\t\t\t       int bitmask, u64 *value)\n{\n\tunsigned int data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\t*value = data & bitmask;\n\treturn 0;\n}\n\nstatic int tps68470_pmic_get_clk(struct regmap *regmap, int reg,\n\t\t\t\t       int bitmask, u64 *value)\n{\n\tunsigned int data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\t*value = (data & bitmask) ? 1 : 0;\n\treturn 0;\n}\n\nstatic int tps68470_pmic_get_clk_freq(struct regmap *regmap, int reg,\n\t\t\t\t       int bitmask, u64 *value)\n{\n\tunsigned int data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\t*value = data & bitmask;\n\treturn 0;\n}\n\nstatic int ti_tps68470_regmap_update_bits(struct regmap *regmap, int reg,\n\t\t\t\t\tint bitmask, u64 value)\n{\n\treturn regmap_update_bits(regmap, reg, bitmask, value);\n}\n\nstatic acpi_status tps68470_pmic_common_handler(u32 function,\n\t\t\t\t\t  acpi_physical_address address,\n\t\t\t\t\t  u32 bits, u64 *value,\n\t\t\t\t\t  void *region_context,\n\t\t\t\t\t  int (*get)(struct regmap *,\n\t\t\t\t\t\t     int, int, u64 *),\n\t\t\t\t\t  int (*update)(struct regmap *,\n\t\t\t\t\t\t\tint, int, u64),\n\t\t\t\t\t  const struct tps68470_pmic_table *tbl,\n\t\t\t\t\t  unsigned int tbl_size)\n{\n\tstruct tps68470_pmic_opregion *opregion = region_context;\n\tstruct regmap *regmap = opregion->regmap;\n\tint reg, ret, bitmask;\n\n\tif (bits != 32)\n\t\treturn AE_BAD_PARAMETER;\n\n\tret = pmic_get_reg_bit(address, tbl, tbl_size, &reg, &bitmask);\n\tif (ret < 0)\n\t\treturn AE_BAD_PARAMETER;\n\n\tif (function == ACPI_WRITE && *value > bitmask)\n\t\treturn AE_BAD_PARAMETER;\n\n\tmutex_lock(&opregion->lock);\n\n\tret = (function == ACPI_READ) ?\n\t\tget(regmap, reg, bitmask, value) :\n\t\tupdate(regmap, reg, bitmask, *value);\n\n\tmutex_unlock(&opregion->lock);\n\n\treturn ret ? AE_ERROR : AE_OK;\n}\n\nstatic acpi_status tps68470_pmic_cfreq_handler(u32 function,\n\t\t\t\t\t    acpi_physical_address address,\n\t\t\t\t\t    u32 bits, u64 *value,\n\t\t\t\t\t    void *handler_context,\n\t\t\t\t\t    void *region_context)\n{\n\treturn tps68470_pmic_common_handler(function, address, bits, value,\n\t\t\t\tregion_context,\n\t\t\t\ttps68470_pmic_get_clk_freq,\n\t\t\t\tti_tps68470_regmap_update_bits,\n\t\t\t\tclk_freq_table,\n\t\t\t\tARRAY_SIZE(clk_freq_table));\n}\n\nstatic acpi_status tps68470_pmic_clk_handler(u32 function,\n\t\t\t\t       acpi_physical_address address, u32 bits,\n\t\t\t\t       u64 *value, void *handler_context,\n\t\t\t\t       void *region_context)\n{\n\treturn tps68470_pmic_common_handler(function, address, bits, value,\n\t\t\t\tregion_context,\n\t\t\t\ttps68470_pmic_get_clk,\n\t\t\t\tti_tps68470_regmap_update_bits,\n\t\t\t\tclk_table,\n\t\t\t\tARRAY_SIZE(clk_table));\n}\n\nstatic acpi_status tps68470_pmic_vrval_handler(u32 function,\n\t\t\t\t\t  acpi_physical_address address,\n\t\t\t\t\t  u32 bits, u64 *value,\n\t\t\t\t\t  void *handler_context,\n\t\t\t\t\t  void *region_context)\n{\n\treturn tps68470_pmic_common_handler(function, address, bits, value,\n\t\t\t\tregion_context,\n\t\t\t\ttps68470_pmic_get_vr_val,\n\t\t\t\tti_tps68470_regmap_update_bits,\n\t\t\t\tvr_val_table,\n\t\t\t\tARRAY_SIZE(vr_val_table));\n}\n\nstatic acpi_status tps68470_pmic_pwr_handler(u32 function,\n\t\t\t\t\t acpi_physical_address address,\n\t\t\t\t\t u32 bits, u64 *value,\n\t\t\t\t\t void *handler_context,\n\t\t\t\t\t void *region_context)\n{\n\tif (bits != 32)\n\t\treturn AE_BAD_PARAMETER;\n\n\t \n\tif (function == ACPI_WRITE &&\n\t    !(*value == 0 || *value == 1 || *value == 3)) {\n\t\treturn AE_BAD_PARAMETER;\n\t}\n\n\treturn tps68470_pmic_common_handler(function, address, bits, value,\n\t\t\t\tregion_context,\n\t\t\t\ttps68470_pmic_get_power,\n\t\t\t\tti_tps68470_regmap_update_bits,\n\t\t\t\tpower_table,\n\t\t\t\tARRAY_SIZE(power_table));\n}\n\nstatic int tps68470_pmic_opregion_probe(struct platform_device *pdev)\n{\n\tstruct regmap *tps68470_regmap = dev_get_drvdata(pdev->dev.parent);\n\tacpi_handle handle = ACPI_HANDLE(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct tps68470_pmic_opregion *opregion;\n\tacpi_status status;\n\n\tif (!dev || !tps68470_regmap) {\n\t\tdev_warn(dev, \"dev or regmap is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!handle) {\n\t\tdev_warn(dev, \"acpi handle is NULL\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\topregion = devm_kzalloc(dev, sizeof(*opregion), GFP_KERNEL);\n\tif (!opregion)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&opregion->lock);\n\topregion->regmap = tps68470_regmap;\n\n\tstatus = acpi_install_address_space_handler(handle,\n\t\t\t\t\t\t    TI_PMIC_POWER_OPREGION_ID,\n\t\t\t\t\t\t    tps68470_pmic_pwr_handler,\n\t\t\t\t\t\t    NULL, opregion);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out_mutex_destroy;\n\n\tstatus = acpi_install_address_space_handler(handle,\n\t\t\t\t\t\t    TI_PMIC_VR_VAL_OPREGION_ID,\n\t\t\t\t\t\t    tps68470_pmic_vrval_handler,\n\t\t\t\t\t\t    NULL, opregion);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out_remove_power_handler;\n\n\tstatus = acpi_install_address_space_handler(handle,\n\t\t\t\t\t\t    TI_PMIC_CLOCK_OPREGION_ID,\n\t\t\t\t\t\t    tps68470_pmic_clk_handler,\n\t\t\t\t\t\t    NULL, opregion);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out_remove_vr_val_handler;\n\n\tstatus = acpi_install_address_space_handler(handle,\n\t\t\t\t\t\t    TI_PMIC_CLKFREQ_OPREGION_ID,\n\t\t\t\t\t\t    tps68470_pmic_cfreq_handler,\n\t\t\t\t\t\t    NULL, opregion);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out_remove_clk_handler;\n\n\treturn 0;\n\nout_remove_clk_handler:\n\tacpi_remove_address_space_handler(handle, TI_PMIC_CLOCK_OPREGION_ID,\n\t\t\t\t\t  tps68470_pmic_clk_handler);\nout_remove_vr_val_handler:\n\tacpi_remove_address_space_handler(handle, TI_PMIC_VR_VAL_OPREGION_ID,\n\t\t\t\t\t  tps68470_pmic_vrval_handler);\nout_remove_power_handler:\n\tacpi_remove_address_space_handler(handle, TI_PMIC_POWER_OPREGION_ID,\n\t\t\t\t\t  tps68470_pmic_pwr_handler);\nout_mutex_destroy:\n\tmutex_destroy(&opregion->lock);\n\treturn -ENODEV;\n}\n\nstatic struct platform_driver tps68470_pmic_opregion_driver = {\n\t.probe = tps68470_pmic_opregion_probe,\n\t.driver = {\n\t\t.name = \"tps68470_pmic_opregion\",\n\t},\n};\n\nbuiltin_platform_driver(tps68470_pmic_opregion_driver)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}