{
  "module_name": "intel_pmic_xpower.c",
  "hash_id": "3453315201fc393b1fdbb970fe42b832b5e6bf5aa4de2cff779e263b064f7124",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pmic/intel_pmic_xpower.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n#include <asm/iosf_mbi.h>\n#include \"intel_pmic.h\"\n\n#define XPOWER_GPADC_LOW\t0x5b\n#define XPOWER_GPI1_CTRL\t0x92\n\n#define GPI1_LDO_MASK\t\tGENMASK(2, 0)\n#define GPI1_LDO_ON\t\t(3 << 0)\n#define GPI1_LDO_OFF\t\t(4 << 0)\n\n#define AXP288_ADC_TS_CURRENT_ON_OFF_MASK\t\tGENMASK(1, 0)\n#define AXP288_ADC_TS_CURRENT_OFF\t\t\t(0 << 0)\n#define AXP288_ADC_TS_CURRENT_ON_WHEN_CHARGING\t\t(1 << 0)\n#define AXP288_ADC_TS_CURRENT_ON_ONDEMAND\t\t(2 << 0)\n#define AXP288_ADC_TS_CURRENT_ON\t\t\t(3 << 0)\n\nstatic struct pmic_table power_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = 0x13,\n\t\t.bit = 0x05,\n\t},  \n\t{\n\t\t.address = 0x04,\n\t\t.reg = 0x13,\n\t\t.bit = 0x06,\n\t},  \n\t{\n\t\t.address = 0x08,\n\t\t.reg = 0x13,\n\t\t.bit = 0x07,\n\t},  \n\t{\n\t\t.address = 0x0c,\n\t\t.reg = 0x12,\n\t\t.bit = 0x03,\n\t},  \n\t{\n\t\t.address = 0x10,\n\t\t.reg = 0x12,\n\t\t.bit = 0x04,\n\t},  \n\t{\n\t\t.address = 0x14,\n\t\t.reg = 0x12,\n\t\t.bit = 0x05,\n\t},  \n\t{\n\t\t.address = 0x18,\n\t\t.reg = 0x12,\n\t\t.bit = 0x06,\n\t},  \n\t{\n\t\t.address = 0x1c,\n\t\t.reg = 0x12,\n\t\t.bit = 0x00,\n\t},  \n\t{\n\t\t.address = 0x20,\n\t\t.reg = 0x12,\n\t\t.bit = 0x01,\n\t},  \n\t{\n\t\t.address = 0x24,\n\t\t.reg = 0x12,\n\t\t.bit = 0x02,\n\t},  \n\t{\n\t\t.address = 0x28,\n\t\t.reg = 0x13,\n\t\t.bit = 0x02,\n\t},  \n\t{\n\t\t.address = 0x2c,\n\t\t.reg = 0x13,\n\t\t.bit = 0x03,\n\t},  \n\t{\n\t\t.address = 0x30,\n\t\t.reg = 0x13,\n\t\t.bit = 0x04,\n\t},  \n\t{\n\t\t.address = 0x34,\n\t\t.reg = 0x10,\n\t\t.bit = 0x03,\n\t},  \n\t{\n\t\t.address = 0x38,\n\t\t.reg = 0x10,\n\t\t.bit = 0x06,\n\t},  \n\t{\n\t\t.address = 0x3c,\n\t\t.reg = 0x10,\n\t\t.bit = 0x05,\n\t},  \n\t{\n\t\t.address = 0x40,\n\t\t.reg = 0x10,\n\t\t.bit = 0x04,\n\t},  \n\t{\n\t\t.address = 0x44,\n\t\t.reg = 0x10,\n\t\t.bit = 0x01,\n\t},  \n\t{\n\t\t.address = 0x48,\n\t\t.reg = 0x10,\n\t\t.bit = 0x00\n\t},  \n\t{\n\t\t.address = 0x4c,\n\t\t.reg = 0x92,\n\t},  \n};\n\n \nstatic struct pmic_table thermal_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = XPOWER_GPADC_LOW\n\t},\n\t{\n\t\t.address = 0x0c,\n\t\t.reg = XPOWER_GPADC_LOW\n\t},\n\t{\n\t\t.address = 0x18,\n\t\t.reg = XPOWER_GPADC_LOW\n\t},\n\t{\n\t\t.address = 0x24,\n\t\t.reg = XPOWER_GPADC_LOW\n\t},\n\t{\n\t\t.address = 0x30,\n\t\t.reg = XPOWER_GPADC_LOW\n\t},\n\t{\n\t\t.address = 0x3c,\n\t\t.reg = XPOWER_GPADC_LOW\n\t},\n};\n\nstatic int intel_xpower_pmic_get_power(struct regmap *regmap, int reg,\n\t\t\t\t       int bit, u64 *value)\n{\n\tint data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\t \n\tif (reg == XPOWER_GPI1_CTRL)\n\t\t*value = ((data & GPI1_LDO_MASK) == GPI1_LDO_ON);\n\telse\n\t\t*value = (data & BIT(bit)) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int intel_xpower_pmic_update_power(struct regmap *regmap, int reg,\n\t\t\t\t\t  int bit, bool on)\n{\n\tint data, ret;\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (reg == XPOWER_GPI1_CTRL) {\n\t\tret = regmap_update_bits(regmap, reg, GPI1_LDO_MASK,\n\t\t\t\t\t on ? GPI1_LDO_ON : GPI1_LDO_OFF);\n\t\tgoto out;\n\t}\n\n\tif (regmap_read(regmap, reg, &data)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (on)\n\t\tdata |= BIT(bit);\n\telse\n\t\tdata &= ~BIT(bit);\n\n\tif (regmap_write(regmap, reg, data))\n\t\tret = -EIO;\nout:\n\tiosf_mbi_unblock_punit_i2c_access();\n\n\treturn ret;\n}\n\n \nstatic int intel_xpower_pmic_get_raw_temp(struct regmap *regmap, int reg)\n{\n\tint ret, adc_ts_pin_ctrl;\n\tu8 buf[2];\n\n\t \n\tret = regmap_read(regmap, AXP288_ADC_TS_PIN_CTRL, &adc_ts_pin_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adc_ts_pin_ctrl & AXP288_ADC_TS_CURRENT_ON_OFF_MASK) {\n\t\t \n\t\tret = regmap_update_bits(regmap, AXP288_ADC_TS_PIN_CTRL,\n\t\t\t\t\t AXP288_ADC_TS_CURRENT_ON_OFF_MASK,\n\t\t\t\t\t AXP288_ADC_TS_CURRENT_ON_ONDEMAND);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tusleep_range(6000, 10000);\n\t}\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(regmap, AXP288_GP_ADC_H, buf, 2);\n\tif (ret == 0)\n\t\tret = (buf[0] << 4) + ((buf[1] >> 4) & 0x0f);\n\n\tif (adc_ts_pin_ctrl & AXP288_ADC_TS_CURRENT_ON_OFF_MASK) {\n\t\tregmap_update_bits(regmap, AXP288_ADC_TS_PIN_CTRL,\n\t\t\t\t   AXP288_ADC_TS_CURRENT_ON_OFF_MASK,\n\t\t\t\t   AXP288_ADC_TS_CURRENT_ON);\n\t}\n\n\tiosf_mbi_unblock_punit_i2c_access();\n\n\treturn ret;\n}\n\nstatic int intel_xpower_exec_mipi_pmic_seq_element(struct regmap *regmap,\n\t\t\t\t\t\t   u16 i2c_address, u32 reg_address,\n\t\t\t\t\t\t   u32 value, u32 mask)\n{\n\tint ret;\n\n\tif (i2c_address != 0x34) {\n\t\tpr_err(\"%s: Unexpected i2c-addr: 0x%02x (reg-addr 0x%x value 0x%x mask 0x%x)\\n\",\n\t\t       __func__, i2c_address, reg_address, value, mask);\n\t\treturn -ENXIO;\n\t}\n\n\tret = iosf_mbi_block_punit_i2c_access();\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, reg_address, mask, value);\n\n\tiosf_mbi_unblock_punit_i2c_access();\n\n\treturn ret;\n}\n\nstatic int intel_xpower_lpat_raw_to_temp(struct acpi_lpat_conversion_table *lpat_table,\n\t\t\t\t\t int raw)\n{\n\tstruct acpi_lpat first = lpat_table->lpat[0];\n\tstruct acpi_lpat last = lpat_table->lpat[lpat_table->lpat_count - 1];\n\n\t \n\tif (first.raw < last.raw)\n\t\traw = clamp(raw, first.raw, last.raw);\n\telse\n\t\traw = clamp(raw, last.raw, first.raw);\n\n\treturn acpi_lpat_raw_to_temp(lpat_table, raw);\n}\n\nstatic const struct intel_pmic_opregion_data intel_xpower_pmic_opregion_data = {\n\t.get_power = intel_xpower_pmic_get_power,\n\t.update_power = intel_xpower_pmic_update_power,\n\t.get_raw_temp = intel_xpower_pmic_get_raw_temp,\n\t.exec_mipi_pmic_seq_element = intel_xpower_exec_mipi_pmic_seq_element,\n\t.lpat_raw_to_temp = intel_xpower_lpat_raw_to_temp,\n\t.power_table = power_table,\n\t.power_table_count = ARRAY_SIZE(power_table),\n\t.thermal_table = thermal_table,\n\t.thermal_table_count = ARRAY_SIZE(thermal_table),\n\t.pmic_i2c_address = 0x34,\n};\n\nstatic acpi_status intel_xpower_pmic_gpio_handler(u32 function,\n\t\tacpi_physical_address address, u32 bit_width, u64 *value,\n\t\tvoid *handler_context, void *region_context)\n{\n\treturn AE_OK;\n}\n\nstatic int intel_xpower_pmic_opregion_probe(struct platform_device *pdev)\n{\n\tstruct device *parent = pdev->dev.parent;\n\tstruct axp20x_dev *axp20x = dev_get_drvdata(parent);\n\tacpi_status status;\n\tint result;\n\n\tstatus = acpi_install_address_space_handler(ACPI_HANDLE(parent),\n\t\t\tACPI_ADR_SPACE_GPIO, intel_xpower_pmic_gpio_handler,\n\t\t\tNULL, NULL);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tresult = intel_pmic_install_opregion_handler(&pdev->dev,\n\t\t\t\t\tACPI_HANDLE(parent), axp20x->regmap,\n\t\t\t\t\t&intel_xpower_pmic_opregion_data);\n\tif (result)\n\t\tacpi_remove_address_space_handler(ACPI_HANDLE(parent),\n\t\t\t\t\t\t  ACPI_ADR_SPACE_GPIO,\n\t\t\t\t\t\t  intel_xpower_pmic_gpio_handler);\n\n\treturn result;\n}\n\nstatic struct platform_driver intel_xpower_pmic_opregion_driver = {\n\t.probe = intel_xpower_pmic_opregion_probe,\n\t.driver = {\n\t\t.name = \"axp288_pmic_acpi\",\n\t},\n};\nbuiltin_platform_driver(intel_xpower_pmic_opregion_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}