{
  "module_name": "intel_pmic_chtdc_ti.c",
  "hash_id": "e2986807989aadee89d0fa60ed4b85a44ae82324edf50d82c3857ed48d81f525",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/pmic/intel_pmic_chtdc_ti.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/platform_device.h>\n#include \"intel_pmic.h\"\n\n \n#define CHTDC_TI_VBAT\t\t0x54\n#define CHTDC_TI_DIETEMP\t0x56\n#define CHTDC_TI_BPTHERM\t0x58\n#define CHTDC_TI_GPADC\t\t0x5a\n\nstatic struct pmic_table chtdc_ti_power_table[] = {\n\t{ .address = 0x00, .reg = 0x41 },  \n\t{ .address = 0x04, .reg = 0x42 },  \n\t{ .address = 0x08, .reg = 0x43 },  \n\t{ .address = 0x0c, .reg = 0x45 },  \n\t{ .address = 0x10, .reg = 0x46 },  \n\t{ .address = 0x14, .reg = 0x47 },  \n\t{ .address = 0x18, .reg = 0x48 },  \n\t{ .address = 0x1c, .reg = 0x49 },  \n\t{ .address = 0x20, .reg = 0x4a },  \n\t{ .address = 0x24, .reg = 0x4b },  \n\t{ .address = 0x28, .reg = 0x4c },  \n\t{ .address = 0x2c, .reg = 0x4d },  \n\t{ .address = 0x30, .reg = 0x4e },  \n};\n\nstatic struct pmic_table chtdc_ti_thermal_table[] = {\n\t{\n\t\t.address = 0x00,\n\t\t.reg = CHTDC_TI_GPADC\n\t},\n\t{\n\t\t.address = 0x0c,\n\t\t.reg = CHTDC_TI_GPADC\n\t},\n\t \n\t{\n\t\t.address = 0x18,\n\t\t.reg = CHTDC_TI_GPADC\n\t},\n\t \n\t{\n\t\t.address = 0x24,\n\t\t.reg = CHTDC_TI_BPTHERM\n\t},\n\t{\n\t\t.address = 0x30,\n\t\t.reg = CHTDC_TI_GPADC\n\t},\n\t \n\t{\n\t\t.address = 0x3c,\n\t\t.reg = CHTDC_TI_DIETEMP\n\t},\n};\n\nstatic int chtdc_ti_pmic_get_power(struct regmap *regmap, int reg, int bit,\n\t\t\t\t   u64 *value)\n{\n\tint data;\n\n\tif (regmap_read(regmap, reg, &data))\n\t\treturn -EIO;\n\n\t*value = data & 1;\n\treturn 0;\n}\n\nstatic int chtdc_ti_pmic_update_power(struct regmap *regmap, int reg, int bit,\n\t\t\t\t      bool on)\n{\n\treturn regmap_update_bits(regmap, reg, 1, on);\n}\n\nstatic int chtdc_ti_pmic_get_raw_temp(struct regmap *regmap, int reg)\n{\n\tu8 buf[2];\n\n\tif (regmap_bulk_read(regmap, reg, buf, 2))\n\t\treturn -EIO;\n\n\t \n\treturn ((buf[0] & 0x03) << 8) | buf[1];\n}\n\nstatic const struct intel_pmic_opregion_data chtdc_ti_pmic_opregion_data = {\n\t.get_power = chtdc_ti_pmic_get_power,\n\t.update_power = chtdc_ti_pmic_update_power,\n\t.get_raw_temp = chtdc_ti_pmic_get_raw_temp,\n\t.lpat_raw_to_temp = acpi_lpat_raw_to_temp,\n\t.power_table = chtdc_ti_power_table,\n\t.power_table_count = ARRAY_SIZE(chtdc_ti_power_table),\n\t.thermal_table = chtdc_ti_thermal_table,\n\t.thermal_table_count = ARRAY_SIZE(chtdc_ti_thermal_table),\n\t.pmic_i2c_address = 0x5e,\n};\n\nstatic int chtdc_ti_pmic_opregion_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\tint err;\n\n\terr = intel_pmic_install_opregion_handler(&pdev->dev,\n\t\t\tACPI_HANDLE(pdev->dev.parent), pmic->regmap,\n\t\t\t&chtdc_ti_pmic_opregion_data);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tacpi_dev_clear_dependencies(ACPI_COMPANION(pdev->dev.parent));\n\treturn 0;\n}\n\nstatic const struct platform_device_id chtdc_ti_pmic_opregion_id_table[] = {\n\t{ .name = \"chtdc_ti_region\" },\n\t{},\n};\n\nstatic struct platform_driver chtdc_ti_pmic_opregion_driver = {\n\t.probe = chtdc_ti_pmic_opregion_probe,\n\t.driver = {\n\t\t.name = \"cht_dollar_cove_ti_pmic\",\n\t},\n\t.id_table = chtdc_ti_pmic_opregion_id_table,\n};\nbuiltin_platform_driver(chtdc_ti_pmic_opregion_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}