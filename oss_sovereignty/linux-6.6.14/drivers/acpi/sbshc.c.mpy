{
  "module_name": "sbshc.c",
  "hash_id": "eafeb2ae65d2a9e9d6e52d252ce954fee02362c53f3a63d9c3ad49107b4af958",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/sbshc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ACPI: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include \"sbshc.h\"\n\n#define ACPI_SMB_HC_CLASS\t\"smbus_host_ctl\"\n#define ACPI_SMB_HC_DEVICE_NAME\t\"ACPI SMBus HC\"\n\nstruct acpi_smb_hc {\n\tstruct acpi_ec *ec;\n\tstruct mutex lock;\n\twait_queue_head_t wait;\n\tu8 offset;\n\tu8 query_bit;\n\tsmbus_alarm_callback callback;\n\tvoid *context;\n\tbool done;\n};\n\nstatic int acpi_smbus_hc_add(struct acpi_device *device);\nstatic void acpi_smbus_hc_remove(struct acpi_device *device);\n\nstatic const struct acpi_device_id sbs_device_ids[] = {\n\t{\"ACPI0001\", 0},\n\t{\"ACPI0005\", 0},\n\t{\"\", 0},\n};\n\nMODULE_DEVICE_TABLE(acpi, sbs_device_ids);\n\nstatic struct acpi_driver acpi_smb_hc_driver = {\n\t.name = \"smbus_hc\",\n\t.class = ACPI_SMB_HC_CLASS,\n\t.ids = sbs_device_ids,\n\t.ops = {\n\t\t.add = acpi_smbus_hc_add,\n\t\t.remove = acpi_smbus_hc_remove,\n\t\t},\n};\n\nunion acpi_smb_status {\n\tu8 raw;\n\tstruct {\n\t\tu8 status:5;\n\t\tu8 reserved:1;\n\t\tu8 alarm:1;\n\t\tu8 done:1;\n\t} fields;\n};\n\nenum acpi_smb_status_codes {\n\tSMBUS_OK = 0,\n\tSMBUS_UNKNOWN_FAILURE = 0x07,\n\tSMBUS_DEVICE_ADDRESS_NACK = 0x10,\n\tSMBUS_DEVICE_ERROR = 0x11,\n\tSMBUS_DEVICE_COMMAND_ACCESS_DENIED = 0x12,\n\tSMBUS_UNKNOWN_ERROR = 0x13,\n\tSMBUS_DEVICE_ACCESS_DENIED = 0x17,\n\tSMBUS_TIMEOUT = 0x18,\n\tSMBUS_HOST_UNSUPPORTED_PROTOCOL = 0x19,\n\tSMBUS_BUSY = 0x1a,\n\tSMBUS_PEC_ERROR = 0x1f,\n};\n\nenum acpi_smb_offset {\n\tACPI_SMB_PROTOCOL = 0,\t \n\tACPI_SMB_STATUS = 1,\t \n\tACPI_SMB_ADDRESS = 2,\t \n\tACPI_SMB_COMMAND = 3,\t \n\tACPI_SMB_DATA = 4,\t \n\tACPI_SMB_BLOCK_COUNT = 0x24,\t \n\tACPI_SMB_ALARM_ADDRESS = 0x25,\t \n\tACPI_SMB_ALARM_DATA = 0x26,\t \n};\n\nstatic inline int smb_hc_read(struct acpi_smb_hc *hc, u8 address, u8 *data)\n{\n\treturn ec_read(hc->offset + address, data);\n}\n\nstatic inline int smb_hc_write(struct acpi_smb_hc *hc, u8 address, u8 data)\n{\n\treturn ec_write(hc->offset + address, data);\n}\n\nstatic int wait_transaction_complete(struct acpi_smb_hc *hc, int timeout)\n{\n\tif (wait_event_timeout(hc->wait, hc->done, msecs_to_jiffies(timeout)))\n\t\treturn 0;\n\treturn -ETIME;\n}\n\nstatic int acpi_smbus_transaction(struct acpi_smb_hc *hc, u8 protocol,\n\t\t\t\t  u8 address, u8 command, u8 *data, u8 length)\n{\n\tint ret = -EFAULT, i;\n\tu8 temp, sz = 0;\n\n\tif (!hc) {\n\t\tpr_err(\"host controller is not configured\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&hc->lock);\n\thc->done = false;\n\tif (smb_hc_read(hc, ACPI_SMB_PROTOCOL, &temp))\n\t\tgoto end;\n\tif (temp) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\tsmb_hc_write(hc, ACPI_SMB_COMMAND, command);\n\tif (!(protocol & 0x01)) {\n\t\tsmb_hc_write(hc, ACPI_SMB_BLOCK_COUNT, length);\n\t\tfor (i = 0; i < length; ++i)\n\t\t\tsmb_hc_write(hc, ACPI_SMB_DATA + i, data[i]);\n\t}\n\tsmb_hc_write(hc, ACPI_SMB_ADDRESS, address << 1);\n\tsmb_hc_write(hc, ACPI_SMB_PROTOCOL, protocol);\n\t \n\tret = wait_transaction_complete(hc, 1000);\n\tif (ret || !(protocol & 0x01))\n\t\tgoto end;\n\tswitch (protocol) {\n\tcase SMBUS_RECEIVE_BYTE:\n\tcase SMBUS_READ_BYTE:\n\t\tsz = 1;\n\t\tbreak;\n\tcase SMBUS_READ_WORD:\n\t\tsz = 2;\n\t\tbreak;\n\tcase SMBUS_READ_BLOCK:\n\t\tif (smb_hc_read(hc, ACPI_SMB_BLOCK_COUNT, &sz)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto end;\n\t\t}\n\t\tsz &= 0x1f;\n\t\tbreak;\n\t}\n\tfor (i = 0; i < sz; ++i)\n\t\tsmb_hc_read(hc, ACPI_SMB_DATA + i, &data[i]);\n      end:\n\tmutex_unlock(&hc->lock);\n\treturn ret;\n}\n\nint acpi_smbus_read(struct acpi_smb_hc *hc, u8 protocol, u8 address,\n\t\t    u8 command, u8 *data)\n{\n\treturn acpi_smbus_transaction(hc, protocol, address, command, data, 0);\n}\n\nEXPORT_SYMBOL_GPL(acpi_smbus_read);\n\nint acpi_smbus_write(struct acpi_smb_hc *hc, u8 protocol, u8 address,\n\t\t     u8 command, u8 *data, u8 length)\n{\n\treturn acpi_smbus_transaction(hc, protocol, address, command, data, length);\n}\n\nEXPORT_SYMBOL_GPL(acpi_smbus_write);\n\nint acpi_smbus_register_callback(struct acpi_smb_hc *hc,\n\t\t\t\t smbus_alarm_callback callback, void *context)\n{\n\tmutex_lock(&hc->lock);\n\thc->callback = callback;\n\thc->context = context;\n\tmutex_unlock(&hc->lock);\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(acpi_smbus_register_callback);\n\nint acpi_smbus_unregister_callback(struct acpi_smb_hc *hc)\n{\n\tmutex_lock(&hc->lock);\n\thc->callback = NULL;\n\thc->context = NULL;\n\tmutex_unlock(&hc->lock);\n\tacpi_os_wait_events_complete();\n\treturn 0;\n}\n\nEXPORT_SYMBOL_GPL(acpi_smbus_unregister_callback);\n\nstatic inline void acpi_smbus_callback(void *context)\n{\n\tstruct acpi_smb_hc *hc = context;\n\tif (hc->callback)\n\t\thc->callback(hc->context);\n}\n\nstatic int smbus_alarm(void *context)\n{\n\tstruct acpi_smb_hc *hc = context;\n\tunion acpi_smb_status status;\n\tu8 address;\n\tif (smb_hc_read(hc, ACPI_SMB_STATUS, &status.raw))\n\t\treturn 0;\n\t \n\tif (status.fields.done && status.fields.status == SMBUS_OK) {\n\t\thc->done = true;\n\t\twake_up(&hc->wait);\n\t}\n\tif (!status.fields.alarm)\n\t\treturn 0;\n\tmutex_lock(&hc->lock);\n\tsmb_hc_read(hc, ACPI_SMB_ALARM_ADDRESS, &address);\n\tstatus.fields.alarm = 0;\n\tsmb_hc_write(hc, ACPI_SMB_STATUS, status.raw);\n\t \n\tswitch (address >> 1) {\n\t\tcase ACPI_SBS_CHARGER:\n\t\tcase ACPI_SBS_MANAGER:\n\t\tcase ACPI_SBS_BATTERY:\n\t\t\tacpi_os_execute(OSL_NOTIFY_HANDLER,\n\t\t\t\t\tacpi_smbus_callback, hc);\n\t}\n\tmutex_unlock(&hc->lock);\n\treturn 0;\n}\n\ntypedef int (*acpi_ec_query_func) (void *data);\n\nextern int acpi_ec_add_query_handler(struct acpi_ec *ec, u8 query_bit,\n\t\t\t      acpi_handle handle, acpi_ec_query_func func,\n\t\t\t      void *data);\n\nstatic int acpi_smbus_hc_add(struct acpi_device *device)\n{\n\tint status;\n\tunsigned long long val;\n\tstruct acpi_smb_hc *hc;\n\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"_EC\", NULL, &val);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_err(\"error obtaining _EC.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tstrcpy(acpi_device_name(device), ACPI_SMB_HC_DEVICE_NAME);\n\tstrcpy(acpi_device_class(device), ACPI_SMB_HC_CLASS);\n\n\thc = kzalloc(sizeof(struct acpi_smb_hc), GFP_KERNEL);\n\tif (!hc)\n\t\treturn -ENOMEM;\n\tmutex_init(&hc->lock);\n\tinit_waitqueue_head(&hc->wait);\n\n\thc->ec = acpi_driver_data(acpi_dev_parent(device));\n\thc->offset = (val >> 8) & 0xff;\n\thc->query_bit = val & 0xff;\n\tdevice->driver_data = hc;\n\n\tacpi_ec_add_query_handler(hc->ec, hc->query_bit, NULL, smbus_alarm, hc);\n\tdev_info(&device->dev, \"SBS HC: offset = 0x%0x, query_bit = 0x%0x\\n\",\n\t\t hc->offset, hc->query_bit);\n\n\treturn 0;\n}\n\nextern void acpi_ec_remove_query_handler(struct acpi_ec *ec, u8 query_bit);\n\nstatic void acpi_smbus_hc_remove(struct acpi_device *device)\n{\n\tstruct acpi_smb_hc *hc;\n\n\tif (!device)\n\t\treturn;\n\n\thc = acpi_driver_data(device);\n\tacpi_ec_remove_query_handler(hc->ec, hc->query_bit);\n\tacpi_os_wait_events_complete();\n\tkfree(hc);\n\tdevice->driver_data = NULL;\n}\n\nmodule_acpi_driver(acpi_smb_hc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alexey Starikovskiy\");\nMODULE_DESCRIPTION(\"ACPI SMBus HC driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}