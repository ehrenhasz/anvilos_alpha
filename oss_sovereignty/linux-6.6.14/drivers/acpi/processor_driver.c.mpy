{
  "module_name": "processor_driver.c",
  "hash_id": "1e9b1ff379fb0a7915e9d62caf6142ec56b382478631723dd8ba877c8382d62f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/processor_driver.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n\n#include <acpi/processor.h>\n\n#include \"internal.h\"\n\n#define ACPI_PROCESSOR_NOTIFY_PERFORMANCE 0x80\n#define ACPI_PROCESSOR_NOTIFY_POWER\t0x81\n#define ACPI_PROCESSOR_NOTIFY_THROTTLING\t0x82\n\nMODULE_AUTHOR(\"Paul Diefenbaugh\");\nMODULE_DESCRIPTION(\"ACPI Processor Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int acpi_processor_start(struct device *dev);\nstatic int acpi_processor_stop(struct device *dev);\n\nstatic const struct acpi_device_id processor_device_ids[] = {\n\t{ACPI_PROCESSOR_OBJECT_HID, 0},\n\t{ACPI_PROCESSOR_DEVICE_HID, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, processor_device_ids);\n\nstatic struct device_driver acpi_processor_driver = {\n\t.name = \"processor\",\n\t.bus = &cpu_subsys,\n\t.acpi_match_table = processor_device_ids,\n\t.probe = acpi_processor_start,\n\t.remove = acpi_processor_stop,\n};\n\nstatic void acpi_processor_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct acpi_device *device = data;\n\tstruct acpi_processor *pr;\n\tint saved;\n\n\tif (device->handle != handle)\n\t\treturn;\n\n\tpr = acpi_driver_data(device);\n\tif (!pr)\n\t\treturn;\n\n\tswitch (event) {\n\tcase ACPI_PROCESSOR_NOTIFY_PERFORMANCE:\n\t\tsaved = pr->performance_platform_limit;\n\t\tacpi_processor_ppc_has_changed(pr, 1);\n\t\tif (saved == pr->performance_platform_limit)\n\t\t\tbreak;\n\t\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\t\t\t\t  dev_name(&device->dev), event,\n\t\t\t\t\t\t  pr->performance_platform_limit);\n\t\tbreak;\n\tcase ACPI_PROCESSOR_NOTIFY_POWER:\n\t\tacpi_processor_power_state_has_changed(pr);\n\t\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\t\t\t\t  dev_name(&device->dev), event, 0);\n\t\tbreak;\n\tcase ACPI_PROCESSOR_NOTIFY_THROTTLING:\n\t\tacpi_processor_tstate_has_changed(pr);\n\t\tacpi_bus_generate_netlink_event(device->pnp.device_class,\n\t\t\t\t\t\t  dev_name(&device->dev), event, 0);\n\t\tbreak;\n\tdefault:\n\t\tacpi_handle_debug(handle, \"Unsupported event [0x%x]\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn;\n}\n\nstatic int __acpi_processor_start(struct acpi_device *device);\n\nstatic int acpi_soft_cpu_online(unsigned int cpu)\n{\n\tstruct acpi_processor *pr = per_cpu(processors, cpu);\n\tstruct acpi_device *device;\n\n\tif (!pr)\n\t\treturn 0;\n\n\tdevice = acpi_fetch_acpi_dev(pr->handle);\n\tif (!device)\n\t\treturn 0;\n\n\t \n\tif (pr->flags.need_hotplug_init) {\n\t\tint ret;\n\n\t\tpr_info(\"Will online and init hotplugged CPU: %d\\n\",\n\t\t\tpr->id);\n\t\tpr->flags.need_hotplug_init = 0;\n\t\tret = __acpi_processor_start(device);\n\t\tWARN(ret, \"Failed to start CPU: %d\\n\", pr->id);\n\t} else {\n\t\t \n\t\tacpi_processor_ppc_has_changed(pr, 0);\n\t\tacpi_processor_hotplug(pr);\n\t\tacpi_processor_reevaluate_tstate(pr, false);\n\t\tacpi_processor_tstate_has_changed(pr);\n\t}\n\treturn 0;\n}\n\nstatic int acpi_soft_cpu_dead(unsigned int cpu)\n{\n\tstruct acpi_processor *pr = per_cpu(processors, cpu);\n\n\tif (!pr || !acpi_fetch_acpi_dev(pr->handle))\n\t\treturn 0;\n\n\tacpi_processor_reevaluate_tstate(pr, true);\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI_CPU_FREQ_PSS\nstatic void acpi_pss_perf_init(struct acpi_processor *pr)\n{\n\tacpi_processor_ppc_has_changed(pr, 0);\n\n\tacpi_processor_get_throttling_info(pr);\n\n\tif (pr->flags.throttling)\n\t\tpr->flags.limit = 1;\n}\n#else\nstatic inline void acpi_pss_perf_init(struct acpi_processor *pr) {}\n#endif  \n\nstatic int __acpi_processor_start(struct acpi_device *device)\n{\n\tstruct acpi_processor *pr = acpi_driver_data(device);\n\tacpi_status status;\n\tint result = 0;\n\n\tif (!pr)\n\t\treturn -ENODEV;\n\n\tif (pr->flags.need_hotplug_init)\n\t\treturn 0;\n\n\tresult = acpi_cppc_processor_probe(pr);\n\tif (result && !IS_ENABLED(CONFIG_ACPI_CPU_FREQ_PSS))\n\t\tdev_dbg(&device->dev, \"CPPC data invalid or not present\\n\");\n\n\tif (!cpuidle_get_driver() || cpuidle_get_driver() == &acpi_idle_driver)\n\t\tacpi_processor_power_init(pr);\n\n\tacpi_pss_perf_init(pr);\n\n\tresult = acpi_processor_thermal_init(pr, device);\n\tif (result)\n\t\tgoto err_power_exit;\n\n\tstatus = acpi_install_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t     acpi_processor_notify, device);\n\tif (ACPI_SUCCESS(status))\n\t\treturn 0;\n\n\tresult = -ENODEV;\n\tacpi_processor_thermal_exit(pr, device);\n\nerr_power_exit:\n\tacpi_processor_power_exit(pr);\n\treturn result;\n}\n\nstatic int acpi_processor_start(struct device *dev)\n{\n\tstruct acpi_device *device = ACPI_COMPANION(dev);\n\tint ret;\n\n\tif (!device)\n\t\treturn -ENODEV;\n\n\t \n\tcpu_hotplug_disable();\n\tret = __acpi_processor_start(device);\n\tcpu_hotplug_enable();\n\treturn ret;\n}\n\nstatic int acpi_processor_stop(struct device *dev)\n{\n\tstruct acpi_device *device = ACPI_COMPANION(dev);\n\tstruct acpi_processor *pr;\n\n\tif (!device)\n\t\treturn 0;\n\n\tacpi_remove_notify_handler(device->handle, ACPI_DEVICE_NOTIFY,\n\t\t\t\t   acpi_processor_notify);\n\n\tpr = acpi_driver_data(device);\n\tif (!pr)\n\t\treturn 0;\n\tacpi_processor_power_exit(pr);\n\n\tacpi_cppc_processor_exit(pr);\n\n\tacpi_processor_thermal_exit(pr, device);\n\n\treturn 0;\n}\n\nbool acpi_processor_cpufreq_init;\n\nstatic int acpi_processor_notifier(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *data)\n{\n\tstruct cpufreq_policy *policy = data;\n\n\tif (event == CPUFREQ_CREATE_POLICY) {\n\t\tacpi_thermal_cpufreq_init(policy);\n\t\tacpi_processor_ppc_init(policy);\n\t} else if (event == CPUFREQ_REMOVE_POLICY) {\n\t\tacpi_processor_ppc_exit(policy);\n\t\tacpi_thermal_cpufreq_exit(policy);\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block acpi_processor_notifier_block = {\n\t.notifier_call = acpi_processor_notifier,\n};\n\n \nstatic enum cpuhp_state hp_online;\nstatic int __init acpi_processor_driver_init(void)\n{\n\tint result = 0;\n\n\tif (acpi_disabled)\n\t\treturn 0;\n\n\tif (!cpufreq_register_notifier(&acpi_processor_notifier_block,\n\t\t\t\t       CPUFREQ_POLICY_NOTIFIER)) {\n\t\tacpi_processor_cpufreq_init = true;\n\t\tacpi_processor_ignore_ppc_init();\n\t}\n\n\tresult = driver_register(&acpi_processor_driver);\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t   \"acpi/cpu-drv:online\",\n\t\t\t\t\t   acpi_soft_cpu_online, NULL);\n\tif (result < 0)\n\t\tgoto err;\n\thp_online = result;\n\tcpuhp_setup_state_nocalls(CPUHP_ACPI_CPUDRV_DEAD, \"acpi/cpu-drv:dead\",\n\t\t\t\t  NULL, acpi_soft_cpu_dead);\n\n\tacpi_processor_throttling_init();\n\treturn 0;\nerr:\n\tdriver_unregister(&acpi_processor_driver);\n\treturn result;\n}\n\nstatic void __exit acpi_processor_driver_exit(void)\n{\n\tif (acpi_disabled)\n\t\treturn;\n\n\tif (acpi_processor_cpufreq_init) {\n\t\tcpufreq_unregister_notifier(&acpi_processor_notifier_block,\n\t\t\t\t\t    CPUFREQ_POLICY_NOTIFIER);\n\t\tacpi_processor_cpufreq_init = false;\n\t}\n\n\tcpuhp_remove_state_nocalls(hp_online);\n\tcpuhp_remove_state_nocalls(CPUHP_ACPI_CPUDRV_DEAD);\n\tdriver_unregister(&acpi_processor_driver);\n}\n\nmodule_init(acpi_processor_driver_init);\nmodule_exit(acpi_processor_driver_exit);\n\nMODULE_ALIAS(\"processor\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}