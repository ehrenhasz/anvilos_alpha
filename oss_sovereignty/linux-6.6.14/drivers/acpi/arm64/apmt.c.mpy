{
  "module_name": "apmt.c",
  "hash_id": "3036decd1f47118722aecd4b26f6d2b383913f2299106e2d855653642f7df264",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/arm64/apmt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"ACPI: APMT: \" fmt\n\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include \"init.h\"\n\n#define DEV_NAME \"arm-cs-arch-pmu\"\n\n \n#define DEV_MAX_RESOURCE_COUNT 3\n\n \nstatic struct acpi_table_header *apmt_table;\n\nstatic int __init apmt_init_resources(struct resource *res,\n\t\t\t\t      struct acpi_apmt_node *node)\n{\n\tint irq, trigger;\n\tint num_res = 0;\n\n\tres[num_res].start = node->base_address0;\n\tres[num_res].end = node->base_address0 + SZ_4K - 1;\n\tres[num_res].flags = IORESOURCE_MEM;\n\n\tnum_res++;\n\n\tif (node->flags & ACPI_APMT_FLAGS_DUAL_PAGE) {\n\t\tres[num_res].start = node->base_address1;\n\t\tres[num_res].end = node->base_address1 + SZ_4K - 1;\n\t\tres[num_res].flags = IORESOURCE_MEM;\n\n\t\tnum_res++;\n\t}\n\n\tif (node->ovflw_irq != 0) {\n\t\ttrigger = (node->ovflw_irq_flags & ACPI_APMT_OVFLW_IRQ_FLAGS_MODE);\n\t\ttrigger = (trigger == ACPI_APMT_OVFLW_IRQ_FLAGS_MODE_LEVEL) ?\n\t\t\tACPI_LEVEL_SENSITIVE : ACPI_EDGE_SENSITIVE;\n\t\tirq = acpi_register_gsi(NULL, node->ovflw_irq, trigger,\n\t\t\t\t\t\tACPI_ACTIVE_HIGH);\n\n\t\tif (irq <= 0) {\n\t\t\tpr_warn(\"APMT could not register gsi hwirq %d\\n\", irq);\n\t\t\treturn num_res;\n\t\t}\n\n\t\tres[num_res].start = irq;\n\t\tres[num_res].end = irq;\n\t\tres[num_res].flags = IORESOURCE_IRQ;\n\n\t\tnum_res++;\n\t}\n\n\treturn num_res;\n}\n\n \nstatic int __init apmt_add_platform_device(struct acpi_apmt_node *node,\n\t\t\t\t\t   struct fwnode_handle *fwnode)\n{\n\tstruct platform_device *pdev;\n\tint ret, count;\n\tstruct resource res[DEV_MAX_RESOURCE_COUNT];\n\n\tpdev = platform_device_alloc(DEV_NAME, PLATFORM_DEVID_AUTO);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tmemset(res, 0, sizeof(res));\n\n\tcount = apmt_init_resources(res, node);\n\n\tret = platform_device_add_resources(pdev, res, count);\n\tif (ret)\n\t\tgoto dev_put;\n\n\t \n\tret = platform_device_add_data(pdev, &node, sizeof(node));\n\tif (ret)\n\t\tgoto dev_put;\n\n\tpdev->dev.fwnode = fwnode;\n\n\tret = platform_device_add(pdev);\n\n\tif (ret)\n\t\tgoto dev_put;\n\n\treturn 0;\n\ndev_put:\n\tplatform_device_put(pdev);\n\n\treturn ret;\n}\n\nstatic int __init apmt_init_platform_devices(void)\n{\n\tstruct acpi_apmt_node *apmt_node;\n\tstruct acpi_table_apmt *apmt;\n\tstruct fwnode_handle *fwnode;\n\tu64 offset, end;\n\tint ret;\n\n\t \n\tapmt = (struct acpi_table_apmt *)apmt_table;\n\toffset = sizeof(*apmt);\n\tend = apmt->header.length;\n\n\twhile (offset < end) {\n\t\tapmt_node = ACPI_ADD_PTR(struct acpi_apmt_node, apmt,\n\t\t\t\t offset);\n\n\t\tfwnode = acpi_alloc_fwnode_static();\n\t\tif (!fwnode)\n\t\t\treturn -ENOMEM;\n\n\t\tret = apmt_add_platform_device(apmt_node, fwnode);\n\t\tif (ret) {\n\t\t\tacpi_free_fwnode_static(fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\toffset += apmt_node->length;\n\t}\n\n\treturn 0;\n}\n\nvoid __init acpi_apmt_init(void)\n{\n\tacpi_status status;\n\tint ret;\n\n\t \n\tstatus = acpi_get_table(ACPI_SIG_APMT, 0, &apmt_table);\n\n\tif (ACPI_FAILURE(status)) {\n\t\tif (status != AE_NOT_FOUND) {\n\t\t\tconst char *msg = acpi_format_exception(status);\n\n\t\t\tpr_err(\"Failed to get APMT table, %s\\n\", msg);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tret = apmt_init_platform_devices();\n\tif (ret) {\n\t\tpr_err(\"Failed to initialize APMT platform devices, ret: %d\\n\", ret);\n\t\tacpi_put_table(apmt_table);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}