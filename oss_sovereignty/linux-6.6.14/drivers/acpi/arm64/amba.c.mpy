{
  "module_name": "amba.c",
  "hash_id": "66e2cc0f219e50ffd473c232dbf468249a88b3059640a82877783aae325d76b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/arm64/amba.c",
  "human_readable_source": "\n\n \n\n#include <linux/acpi.h>\n#include <linux/amba/bus.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"init.h\"\n\nstatic const struct acpi_device_id amba_id_list[] = {\n\t{\"ARMH0061\", 0},  \n\t{\"ARMH0330\", 0},  \n\t{\"ARMHC501\", 0},  \n\t{\"ARMHC502\", 0},  \n\t{\"ARMHC503\", 0},  \n\t{\"ARMHC979\", 0},  \n\t{\"ARMHC97C\", 0},  \n\t{\"ARMHC98D\", 0},  \n\t{\"ARMHC9CA\", 0},  \n\t{\"ARMHC9FF\", 0},  \n\t{\"\", 0},\n};\n\nstatic void amba_register_dummy_clk(void)\n{\n\tstatic struct clk *amba_dummy_clk;\n\n\t \n\tif (amba_dummy_clk)\n\t\treturn;\n\n\tamba_dummy_clk = clk_register_fixed_rate(NULL, \"apb_pclk\", NULL, 0, 0);\n\tclk_register_clkdev(amba_dummy_clk, \"apb_pclk\", NULL);\n}\n\nstatic int amba_handler_attach(struct acpi_device *adev,\n\t\t\t\tconst struct acpi_device_id *id)\n{\n\tstruct acpi_device *parent = acpi_dev_parent(adev);\n\tstruct amba_device *dev;\n\tstruct resource_entry *rentry;\n\tstruct list_head resource_list;\n\tbool address_found = false;\n\tint irq_no = 0;\n\tint ret;\n\n\t \n\tif (adev->physical_node_count)\n\t\treturn 0;\n\n\tdev = amba_device_alloc(dev_name(&adev->dev), 0, 0);\n\tif (!dev) {\n\t\tdev_err(&adev->dev, \"%s(): amba_device_alloc() failed\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto err_free;\n\n\tlist_for_each_entry(rentry, &resource_list, node) {\n\t\tswitch (resource_type(rentry->res)) {\n\t\tcase IORESOURCE_MEM:\n\t\t\tif (!address_found) {\n\t\t\t\tdev->res = *rentry->res;\n\t\t\t\tdev->res.name = dev_name(&dev->dev);\n\t\t\t\taddress_found = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IORESOURCE_IRQ:\n\t\t\tif (irq_no < AMBA_NR_IRQS)\n\t\t\t\tdev->irq[irq_no++] = rentry->res->start;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&adev->dev, \"Invalid resource\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\t \n\tif (parent)\n\t\tdev->dev.parent = acpi_get_first_physical_node(parent);\n\n\tACPI_COMPANION_SET(&dev->dev, adev);\n\n\tret = amba_device_add(dev, &iomem_resource);\n\tif (ret) {\n\t\tdev_err(&adev->dev, \"%s(): amba_device_add() failed (%d)\\n\",\n\t\t       __func__, ret);\n\t\tgoto err_free;\n\t}\n\n\treturn 1;\n\nerr_free:\n\tamba_device_put(dev);\n\treturn ret;\n}\n\nstatic struct acpi_scan_handler amba_handler = {\n\t.ids = amba_id_list,\n\t.attach = amba_handler_attach,\n};\n\nvoid __init acpi_amba_init(void)\n{\n\tamba_register_dummy_clk();\n\tacpi_scan_add_handler(&amba_handler);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}