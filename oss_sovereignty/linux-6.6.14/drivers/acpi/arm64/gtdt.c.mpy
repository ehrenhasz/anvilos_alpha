{
  "module_name": "gtdt.c",
  "hash_id": "48f617ae6a593f0a7e434f9d82fe62552bc4cef5a7cd72de11da0cc78a0a72d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/arm64/gtdt.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n\n#include <clocksource/arm_arch_timer.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"ACPI GTDT: \" fmt\n\n \nstruct acpi_gtdt_descriptor {\n\tstruct acpi_table_gtdt *gtdt;\n\tvoid *gtdt_end;\n\tvoid *platform_timer;\n};\n\nstatic struct acpi_gtdt_descriptor acpi_gtdt_desc __initdata;\n\nstatic inline __init void *next_platform_timer(void *platform_timer)\n{\n\tstruct acpi_gtdt_header *gh = platform_timer;\n\n\tplatform_timer += gh->length;\n\tif (platform_timer < acpi_gtdt_desc.gtdt_end)\n\t\treturn platform_timer;\n\n\treturn NULL;\n}\n\n#define for_each_platform_timer(_g)\t\t\t\t\\\n\tfor (_g = acpi_gtdt_desc.platform_timer; _g;\t\\\n\t     _g = next_platform_timer(_g))\n\nstatic inline bool is_timer_block(void *platform_timer)\n{\n\tstruct acpi_gtdt_header *gh = platform_timer;\n\n\treturn gh->type == ACPI_GTDT_TYPE_TIMER_BLOCK;\n}\n\nstatic inline bool is_non_secure_watchdog(void *platform_timer)\n{\n\tstruct acpi_gtdt_header *gh = platform_timer;\n\tstruct acpi_gtdt_watchdog *wd = platform_timer;\n\n\tif (gh->type != ACPI_GTDT_TYPE_WATCHDOG)\n\t\treturn false;\n\n\treturn !(wd->timer_flags & ACPI_GTDT_WATCHDOG_SECURE);\n}\n\nstatic int __init map_gt_gsi(u32 interrupt, u32 flags)\n{\n\tint trigger, polarity;\n\n\ttrigger = (flags & ACPI_GTDT_INTERRUPT_MODE) ? ACPI_EDGE_SENSITIVE\n\t\t\t: ACPI_LEVEL_SENSITIVE;\n\n\tpolarity = (flags & ACPI_GTDT_INTERRUPT_POLARITY) ? ACPI_ACTIVE_LOW\n\t\t\t: ACPI_ACTIVE_HIGH;\n\n\treturn acpi_register_gsi(NULL, interrupt, trigger, polarity);\n}\n\n \nint __init acpi_gtdt_map_ppi(int type)\n{\n\tstruct acpi_table_gtdt *gtdt = acpi_gtdt_desc.gtdt;\n\n\tswitch (type) {\n\tcase ARCH_TIMER_PHYS_NONSECURE_PPI:\n\t\treturn map_gt_gsi(gtdt->non_secure_el1_interrupt,\n\t\t\t\t  gtdt->non_secure_el1_flags);\n\tcase ARCH_TIMER_VIRT_PPI:\n\t\treturn map_gt_gsi(gtdt->virtual_timer_interrupt,\n\t\t\t\t  gtdt->virtual_timer_flags);\n\n\tcase ARCH_TIMER_HYP_PPI:\n\t\treturn map_gt_gsi(gtdt->non_secure_el2_interrupt,\n\t\t\t\t  gtdt->non_secure_el2_flags);\n\tdefault:\n\t\tpr_err(\"Failed to map timer interrupt: invalid type.\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nbool __init acpi_gtdt_c3stop(int type)\n{\n\tstruct acpi_table_gtdt *gtdt = acpi_gtdt_desc.gtdt;\n\n\tswitch (type) {\n\tcase ARCH_TIMER_PHYS_NONSECURE_PPI:\n\t\treturn !(gtdt->non_secure_el1_flags & ACPI_GTDT_ALWAYS_ON);\n\n\tcase ARCH_TIMER_VIRT_PPI:\n\t\treturn !(gtdt->virtual_timer_flags & ACPI_GTDT_ALWAYS_ON);\n\n\tcase ARCH_TIMER_HYP_PPI:\n\t\treturn !(gtdt->non_secure_el2_flags & ACPI_GTDT_ALWAYS_ON);\n\n\tdefault:\n\t\tpr_err(\"Failed to get c3stop info: invalid type.\\n\");\n\t}\n\n\treturn false;\n}\n\n \nint __init acpi_gtdt_init(struct acpi_table_header *table,\n\t\t\t  int *platform_timer_count)\n{\n\tvoid *platform_timer;\n\tstruct acpi_table_gtdt *gtdt;\n\n\tgtdt = container_of(table, struct acpi_table_gtdt, header);\n\tacpi_gtdt_desc.gtdt = gtdt;\n\tacpi_gtdt_desc.gtdt_end = (void *)table + table->length;\n\tacpi_gtdt_desc.platform_timer = NULL;\n\tif (platform_timer_count)\n\t\t*platform_timer_count = 0;\n\n\tif (table->revision < 2) {\n\t\tpr_warn(\"Revision:%d doesn't support Platform Timers.\\n\",\n\t\t\ttable->revision);\n\t\treturn 0;\n\t}\n\n\tif (!gtdt->platform_timer_count) {\n\t\tpr_debug(\"No Platform Timer.\\n\");\n\t\treturn 0;\n\t}\n\n\tplatform_timer = (void *)gtdt + gtdt->platform_timer_offset;\n\tif (platform_timer < (void *)table + sizeof(struct acpi_table_gtdt)) {\n\t\tpr_err(FW_BUG \"invalid timer data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tacpi_gtdt_desc.platform_timer = platform_timer;\n\tif (platform_timer_count)\n\t\t*platform_timer_count = gtdt->platform_timer_count;\n\n\treturn 0;\n}\n\nstatic int __init gtdt_parse_timer_block(struct acpi_gtdt_timer_block *block,\n\t\t\t\t\t struct arch_timer_mem *timer_mem)\n{\n\tint i;\n\tstruct arch_timer_mem_frame *frame;\n\tstruct acpi_gtdt_timer_entry *gtdt_frame;\n\n\tif (!block->timer_count) {\n\t\tpr_err(FW_BUG \"GT block present, but frame count is zero.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (block->timer_count > ARCH_TIMER_MEM_MAX_FRAMES) {\n\t\tpr_err(FW_BUG \"GT block lists %d frames, ACPI spec only allows 8\\n\",\n\t\t       block->timer_count);\n\t\treturn -EINVAL;\n\t}\n\n\ttimer_mem->cntctlbase = (phys_addr_t)block->block_address;\n\t \n\ttimer_mem->size = SZ_4K;\n\n\tgtdt_frame = (void *)block + block->timer_offset;\n\tif (gtdt_frame + block->timer_count != (void *)block + block->header.length)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < block->timer_count; i++, gtdt_frame++) {\n\t\tif (gtdt_frame->common_flags & ACPI_GTDT_GT_IS_SECURE_TIMER)\n\t\t\tcontinue;\n\t\tif (gtdt_frame->frame_number >= ARCH_TIMER_MEM_MAX_FRAMES ||\n\t\t    !gtdt_frame->base_address || !gtdt_frame->timer_interrupt)\n\t\t\tgoto error;\n\n\t\tframe = &timer_mem->frame[gtdt_frame->frame_number];\n\n\t\t \n\t\tif (frame->valid)\n\t\t\tgoto error;\n\n\t\tframe->phys_irq = map_gt_gsi(gtdt_frame->timer_interrupt,\n\t\t\t\t\t     gtdt_frame->timer_flags);\n\t\tif (frame->phys_irq <= 0) {\n\t\t\tpr_warn(\"failed to map physical timer irq in frame %d.\\n\",\n\t\t\t\tgtdt_frame->frame_number);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (gtdt_frame->virtual_timer_interrupt) {\n\t\t\tframe->virt_irq =\n\t\t\t\tmap_gt_gsi(gtdt_frame->virtual_timer_interrupt,\n\t\t\t\t\t   gtdt_frame->virtual_timer_flags);\n\t\t\tif (frame->virt_irq <= 0) {\n\t\t\t\tpr_warn(\"failed to map virtual timer irq in frame %d.\\n\",\n\t\t\t\t\tgtdt_frame->frame_number);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tpr_debug(\"virtual timer in frame %d not implemented.\\n\",\n\t\t\t\t gtdt_frame->frame_number);\n\t\t}\n\n\t\tframe->cntbase = gtdt_frame->base_address;\n\t\t \n\t\tframe->size = SZ_4K;\n\t\tframe->valid = true;\n\t}\n\n\treturn 0;\n\nerror:\n\tdo {\n\t\tif (gtdt_frame->common_flags & ACPI_GTDT_GT_IS_SECURE_TIMER ||\n\t\t    gtdt_frame->frame_number >= ARCH_TIMER_MEM_MAX_FRAMES)\n\t\t\tcontinue;\n\n\t\tframe = &timer_mem->frame[gtdt_frame->frame_number];\n\n\t\tif (frame->phys_irq > 0)\n\t\t\tacpi_unregister_gsi(gtdt_frame->timer_interrupt);\n\t\tframe->phys_irq = 0;\n\n\t\tif (frame->virt_irq > 0)\n\t\t\tacpi_unregister_gsi(gtdt_frame->virtual_timer_interrupt);\n\t\tframe->virt_irq = 0;\n\t} while (i-- >= 0 && gtdt_frame--);\n\n\treturn -EINVAL;\n}\n\n \nint __init acpi_arch_timer_mem_init(struct arch_timer_mem *timer_mem,\n\t\t\t\t    int *timer_count)\n{\n\tint ret;\n\tvoid *platform_timer;\n\n\t*timer_count = 0;\n\tfor_each_platform_timer(platform_timer) {\n\t\tif (is_timer_block(platform_timer)) {\n\t\t\tret = gtdt_parse_timer_block(platform_timer, timer_mem);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\ttimer_mem++;\n\t\t\t(*timer_count)++;\n\t\t}\n\t}\n\n\tif (*timer_count)\n\t\tpr_info(\"found %d memory-mapped timer block(s).\\n\",\n\t\t\t*timer_count);\n\n\treturn 0;\n}\n\n \nstatic int __init gtdt_import_sbsa_gwdt(struct acpi_gtdt_watchdog *wd,\n\t\t\t\t\tint index)\n{\n\tstruct platform_device *pdev;\n\tint irq;\n\n\t \n\tstruct resource res[] = {\n\t\tDEFINE_RES_MEM(wd->control_frame_address, SZ_4K),\n\t\tDEFINE_RES_MEM(wd->refresh_frame_address, SZ_4K),\n\t\t{},\n\t};\n\tint nr_res = ARRAY_SIZE(res);\n\n\tpr_debug(\"found a Watchdog (0x%llx/0x%llx gsi:%u flags:0x%x).\\n\",\n\t\t wd->refresh_frame_address, wd->control_frame_address,\n\t\t wd->timer_interrupt, wd->timer_flags);\n\n\tif (!(wd->refresh_frame_address && wd->control_frame_address)) {\n\t\tpr_err(FW_BUG \"failed to get the Watchdog base address.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = map_gt_gsi(wd->timer_interrupt, wd->timer_flags);\n\tres[2] = (struct resource)DEFINE_RES_IRQ(irq);\n\tif (irq <= 0) {\n\t\tpr_warn(\"failed to map the Watchdog interrupt.\\n\");\n\t\tnr_res--;\n\t}\n\n\t \n\tpdev = platform_device_register_simple(\"sbsa-gwdt\", index, res, nr_res);\n\tif (IS_ERR(pdev)) {\n\t\tif (irq > 0)\n\t\t\tacpi_unregister_gsi(wd->timer_interrupt);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init gtdt_sbsa_gwdt_init(void)\n{\n\tvoid *platform_timer;\n\tstruct acpi_table_header *table;\n\tint ret, timer_count, gwdt_count = 0;\n\n\tif (acpi_disabled)\n\t\treturn 0;\n\n\tif (ACPI_FAILURE(acpi_get_table(ACPI_SIG_GTDT, 0, &table)))\n\t\treturn -EINVAL;\n\n\t \n\tret = acpi_gtdt_init(table, &timer_count);\n\tif (ret || !timer_count)\n\t\tgoto out_put_gtdt;\n\n\tfor_each_platform_timer(platform_timer) {\n\t\tif (is_non_secure_watchdog(platform_timer)) {\n\t\t\tret = gtdt_import_sbsa_gwdt(platform_timer, gwdt_count);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tgwdt_count++;\n\t\t}\n\t}\n\n\tif (gwdt_count)\n\t\tpr_info(\"found %d SBSA generic Watchdog(s).\\n\", gwdt_count);\n\nout_put_gtdt:\n\tacpi_put_table(table);\n\treturn ret;\n}\n\ndevice_initcall(gtdt_sbsa_gwdt_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}