{
  "module_name": "acpi_dbg.c",
  "hash_id": "00556cd5f3aaecd586ccb9825a7f4978dfc3d3ffc4337db0259517d1274cf5ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_dbg.c",
  "human_readable_source": "\n \n\n \n#define pr_fmt(fmt) \"ACPI: AML: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/debugfs.h>\n#include <linux/circ_buf.h>\n#include <linux/acpi.h>\n#include \"internal.h\"\n\n#define ACPI_AML_BUF_ALIGN\t(sizeof (acpi_size))\n#define ACPI_AML_BUF_SIZE\tPAGE_SIZE\n\n#define circ_count(circ) \\\n\t(CIRC_CNT((circ)->head, (circ)->tail, ACPI_AML_BUF_SIZE))\n#define circ_count_to_end(circ) \\\n\t(CIRC_CNT_TO_END((circ)->head, (circ)->tail, ACPI_AML_BUF_SIZE))\n#define circ_space(circ) \\\n\t(CIRC_SPACE((circ)->head, (circ)->tail, ACPI_AML_BUF_SIZE))\n#define circ_space_to_end(circ) \\\n\t(CIRC_SPACE_TO_END((circ)->head, (circ)->tail, ACPI_AML_BUF_SIZE))\n\n#define ACPI_AML_OPENED\t\t0x0001\n#define ACPI_AML_CLOSED\t\t0x0002\n#define ACPI_AML_IN_USER\t0x0004  \n#define ACPI_AML_IN_KERN\t0x0008  \n#define ACPI_AML_OUT_USER\t0x0010  \n#define ACPI_AML_OUT_KERN\t0x0020  \n#define ACPI_AML_USER\t\t(ACPI_AML_IN_USER | ACPI_AML_OUT_USER)\n#define ACPI_AML_KERN\t\t(ACPI_AML_IN_KERN | ACPI_AML_OUT_KERN)\n#define ACPI_AML_BUSY\t\t(ACPI_AML_USER | ACPI_AML_KERN)\n#define ACPI_AML_OPEN\t\t(ACPI_AML_OPENED | ACPI_AML_CLOSED)\n\nstruct acpi_aml_io {\n\twait_queue_head_t wait;\n\tunsigned long flags;\n\tunsigned long users;\n\tstruct mutex lock;\n\tstruct task_struct *thread;\n\tchar out_buf[ACPI_AML_BUF_SIZE] __aligned(ACPI_AML_BUF_ALIGN);\n\tstruct circ_buf out_crc;\n\tchar in_buf[ACPI_AML_BUF_SIZE] __aligned(ACPI_AML_BUF_ALIGN);\n\tstruct circ_buf in_crc;\n\tacpi_osd_exec_callback function;\n\tvoid *context;\n\tunsigned long usages;\n};\n\nstatic struct acpi_aml_io acpi_aml_io;\nstatic bool acpi_aml_initialized;\nstatic struct file *acpi_aml_active_reader;\nstatic struct dentry *acpi_aml_dentry;\n\nstatic inline bool __acpi_aml_running(void)\n{\n\treturn acpi_aml_io.thread ? true : false;\n}\n\nstatic inline bool __acpi_aml_access_ok(unsigned long flag)\n{\n\t \n\tif (!(acpi_aml_io.flags & ACPI_AML_OPENED) ||\n\t    (acpi_aml_io.flags & ACPI_AML_CLOSED) ||\n\t    !__acpi_aml_running())\n\t\treturn false;\n\tif ((flag & ACPI_AML_KERN) &&\n\t    current != acpi_aml_io.thread)\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline bool __acpi_aml_readable(struct circ_buf *circ, unsigned long flag)\n{\n\t \n\tif (!(acpi_aml_io.flags & flag) && circ_count(circ))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool __acpi_aml_writable(struct circ_buf *circ, unsigned long flag)\n{\n\t \n\tif (!(acpi_aml_io.flags & flag) && circ_space(circ))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool __acpi_aml_busy(void)\n{\n\tif (acpi_aml_io.flags & ACPI_AML_BUSY)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool __acpi_aml_used(void)\n{\n\treturn acpi_aml_io.usages ? true : false;\n}\n\nstatic inline bool acpi_aml_running(void)\n{\n\tbool ret;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tret = __acpi_aml_running();\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic bool acpi_aml_busy(void)\n{\n\tbool ret;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tret = __acpi_aml_busy();\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic bool acpi_aml_used(void)\n{\n\tbool ret;\n\n\t \n\tmutex_lock(&acpi_aml_io.lock);\n\tret = __acpi_aml_used();\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic bool acpi_aml_kern_readable(void)\n{\n\tbool ret;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tret = !__acpi_aml_access_ok(ACPI_AML_IN_KERN) ||\n\t      __acpi_aml_readable(&acpi_aml_io.in_crc, ACPI_AML_IN_KERN);\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic bool acpi_aml_kern_writable(void)\n{\n\tbool ret;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tret = !__acpi_aml_access_ok(ACPI_AML_OUT_KERN) ||\n\t      __acpi_aml_writable(&acpi_aml_io.out_crc, ACPI_AML_OUT_KERN);\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic bool acpi_aml_user_readable(void)\n{\n\tbool ret;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tret = !__acpi_aml_access_ok(ACPI_AML_OUT_USER) ||\n\t      __acpi_aml_readable(&acpi_aml_io.out_crc, ACPI_AML_OUT_USER);\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic bool acpi_aml_user_writable(void)\n{\n\tbool ret;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tret = !__acpi_aml_access_ok(ACPI_AML_IN_USER) ||\n\t      __acpi_aml_writable(&acpi_aml_io.in_crc, ACPI_AML_IN_USER);\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic int acpi_aml_lock_write(struct circ_buf *circ, unsigned long flag)\n{\n\tint ret = 0;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tif (!__acpi_aml_access_ok(flag)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (!__acpi_aml_writable(circ, flag)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tacpi_aml_io.flags |= flag;\nout:\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic int acpi_aml_lock_read(struct circ_buf *circ, unsigned long flag)\n{\n\tint ret = 0;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tif (!__acpi_aml_access_ok(flag)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (!__acpi_aml_readable(circ, flag)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\tacpi_aml_io.flags |= flag;\nout:\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn ret;\n}\n\nstatic void acpi_aml_unlock_fifo(unsigned long flag, bool wakeup)\n{\n\tmutex_lock(&acpi_aml_io.lock);\n\tacpi_aml_io.flags &= ~flag;\n\tif (wakeup)\n\t\twake_up_interruptible(&acpi_aml_io.wait);\n\tmutex_unlock(&acpi_aml_io.lock);\n}\n\nstatic int acpi_aml_write_kern(const char *buf, int len)\n{\n\tint ret;\n\tstruct circ_buf *crc = &acpi_aml_io.out_crc;\n\tint n;\n\tchar *p;\n\n\tret = acpi_aml_lock_write(crc, ACPI_AML_OUT_KERN);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tsmp_mb();\n\tp = &crc->buf[crc->head];\n\tn = min(len, circ_space_to_end(crc));\n\tmemcpy(p, buf, n);\n\t \n\tsmp_wmb();\n\tcrc->head = (crc->head + n) & (ACPI_AML_BUF_SIZE - 1);\n\tacpi_aml_unlock_fifo(ACPI_AML_OUT_KERN, true);\n\treturn n;\n}\n\nstatic int acpi_aml_readb_kern(void)\n{\n\tint ret;\n\tstruct circ_buf *crc = &acpi_aml_io.in_crc;\n\tchar *p;\n\n\tret = acpi_aml_lock_read(crc, ACPI_AML_IN_KERN);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tsmp_rmb();\n\tp = &crc->buf[crc->tail];\n\tret = (int)*p;\n\t \n\tsmp_mb();\n\tcrc->tail = (crc->tail + 1) & (ACPI_AML_BUF_SIZE - 1);\n\tacpi_aml_unlock_fifo(ACPI_AML_IN_KERN, true);\n\treturn ret;\n}\n\n \nstatic ssize_t acpi_aml_write_log(const char *msg)\n{\n\tint ret = 0;\n\tint count = 0, size = 0;\n\n\tif (!acpi_aml_initialized)\n\t\treturn -ENODEV;\n\tif (msg)\n\t\tcount = strlen(msg);\n\twhile (count > 0) {\nagain:\n\t\tret = acpi_aml_write_kern(msg + size, count);\n\t\tif (ret == -EAGAIN) {\n\t\t\tret = wait_event_interruptible(acpi_aml_io.wait,\n\t\t\t\tacpi_aml_kern_writable());\n\t\t\t \n\t\t\tif (ret == 0)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tsize += ret;\n\t\tcount -= ret;\n\t}\n\treturn size > 0 ? size : ret;\n}\n\n \nstatic ssize_t acpi_aml_read_cmd(char *msg, size_t count)\n{\n\tint ret = 0;\n\tint size = 0;\n\n\t \n\tBUG_ON(!acpi_aml_initialized);\n\twhile (count > 0) {\nagain:\n\t\t \n\t\tret = acpi_aml_readb_kern();\n\t\tif (ret == -EAGAIN) {\n\t\t\tret = wait_event_interruptible(acpi_aml_io.wait,\n\t\t\t\tacpi_aml_kern_readable());\n\t\t\t \n\t\t\tif (ret == 0)\n\t\t\t\tgoto again;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\t*(msg + size) = (char)ret;\n\t\tsize++;\n\t\tcount--;\n\t\tif (ret == '\\n') {\n\t\t\t \n\t\t\t*(msg + size - 1) = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size > 0 ? size : ret;\n}\n\nstatic int acpi_aml_thread(void *unused)\n{\n\tacpi_osd_exec_callback function = NULL;\n\tvoid *context;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tif (acpi_aml_io.function) {\n\t\tacpi_aml_io.usages++;\n\t\tfunction = acpi_aml_io.function;\n\t\tcontext = acpi_aml_io.context;\n\t}\n\tmutex_unlock(&acpi_aml_io.lock);\n\n\tif (function)\n\t\tfunction(context);\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tacpi_aml_io.usages--;\n\tif (!__acpi_aml_used()) {\n\t\tacpi_aml_io.thread = NULL;\n\t\twake_up(&acpi_aml_io.wait);\n\t}\n\tmutex_unlock(&acpi_aml_io.lock);\n\n\treturn 0;\n}\n\n \nstatic int acpi_aml_create_thread(acpi_osd_exec_callback function, void *context)\n{\n\tstruct task_struct *t;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tacpi_aml_io.function = function;\n\tacpi_aml_io.context = context;\n\tmutex_unlock(&acpi_aml_io.lock);\n\n\tt = kthread_create(acpi_aml_thread, NULL, \"aml\");\n\tif (IS_ERR(t)) {\n\t\tpr_err(\"Failed to create AML debugger thread.\\n\");\n\t\treturn PTR_ERR(t);\n\t}\n\n\tmutex_lock(&acpi_aml_io.lock);\n\tacpi_aml_io.thread = t;\n\tacpi_set_debugger_thread_id((acpi_thread_id)(unsigned long)t);\n\twake_up_process(t);\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn 0;\n}\n\nstatic int acpi_aml_wait_command_ready(bool single_step,\n\t\t\t\t       char *buffer, size_t length)\n{\n\tacpi_status status;\n\n\tif (single_step)\n\t\tacpi_os_printf(\"\\n%1c \", ACPI_DEBUGGER_EXECUTE_PROMPT);\n\telse\n\t\tacpi_os_printf(\"\\n%1c \", ACPI_DEBUGGER_COMMAND_PROMPT);\n\n\tstatus = acpi_os_get_line(buffer, length, NULL);\n\tif (ACPI_FAILURE(status))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int acpi_aml_notify_command_complete(void)\n{\n\treturn 0;\n}\n\nstatic int acpi_aml_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\tacpi_status status;\n\n\tmutex_lock(&acpi_aml_io.lock);\n\t \n\tif (acpi_aml_io.flags & ACPI_AML_CLOSED) {\n\t\tret = -EBUSY;\n\t\tgoto err_lock;\n\t}\n\tif ((file->f_flags & O_ACCMODE) != O_WRONLY) {\n\t\t \n\t\tif (acpi_aml_active_reader) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_lock;\n\t\t} else {\n\t\t\tpr_debug(\"Opening debugger reader.\\n\");\n\t\t\tacpi_aml_active_reader = file;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!(acpi_aml_io.flags & ACPI_AML_OPENED)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_lock;\n\t\t}\n\t}\n\tif (acpi_aml_active_reader == file) {\n\t\tpr_debug(\"Opening debugger interface.\\n\");\n\t\tmutex_unlock(&acpi_aml_io.lock);\n\n\t\tpr_debug(\"Initializing debugger thread.\\n\");\n\t\tstatus = acpi_initialize_debugger();\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tpr_err(\"Failed to initialize debugger.\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_exit;\n\t\t}\n\t\tpr_debug(\"Debugger thread initialized.\\n\");\n\n\t\tmutex_lock(&acpi_aml_io.lock);\n\t\tacpi_aml_io.flags |= ACPI_AML_OPENED;\n\t\tacpi_aml_io.out_crc.head = acpi_aml_io.out_crc.tail = 0;\n\t\tacpi_aml_io.in_crc.head = acpi_aml_io.in_crc.tail = 0;\n\t\tpr_debug(\"Debugger interface opened.\\n\");\n\t}\n\tacpi_aml_io.users++;\nerr_lock:\n\tif (ret < 0) {\n\t\tif (acpi_aml_active_reader == file)\n\t\t\tacpi_aml_active_reader = NULL;\n\t}\n\tmutex_unlock(&acpi_aml_io.lock);\nerr_exit:\n\treturn ret;\n}\n\nstatic int acpi_aml_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&acpi_aml_io.lock);\n\tacpi_aml_io.users--;\n\tif (file == acpi_aml_active_reader) {\n\t\tpr_debug(\"Closing debugger reader.\\n\");\n\t\tacpi_aml_active_reader = NULL;\n\n\t\tpr_debug(\"Closing debugger interface.\\n\");\n\t\tacpi_aml_io.flags |= ACPI_AML_CLOSED;\n\n\t\t \n\t\twake_up_interruptible(&acpi_aml_io.wait);\n\t\tmutex_unlock(&acpi_aml_io.lock);\n\t\t \n\t\twait_event(acpi_aml_io.wait, !acpi_aml_busy());\n\n\t\t \n\t\tpr_debug(\"Terminating debugger thread.\\n\");\n\t\tacpi_terminate_debugger();\n\t\twait_event(acpi_aml_io.wait, !acpi_aml_used());\n\t\tpr_debug(\"Debugger thread terminated.\\n\");\n\n\t\tmutex_lock(&acpi_aml_io.lock);\n\t\tacpi_aml_io.flags &= ~ACPI_AML_OPENED;\n\t}\n\tif (acpi_aml_io.users == 0) {\n\t\tpr_debug(\"Debugger interface closed.\\n\");\n\t\tacpi_aml_io.flags &= ~ACPI_AML_CLOSED;\n\t}\n\tmutex_unlock(&acpi_aml_io.lock);\n\treturn 0;\n}\n\nstatic int acpi_aml_read_user(char __user *buf, int len)\n{\n\tint ret;\n\tstruct circ_buf *crc = &acpi_aml_io.out_crc;\n\tint n;\n\tchar *p;\n\n\tret = acpi_aml_lock_read(crc, ACPI_AML_OUT_USER);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tsmp_rmb();\n\tp = &crc->buf[crc->tail];\n\tn = min(len, circ_count_to_end(crc));\n\tif (copy_to_user(buf, p, n)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\t \n\tsmp_mb();\n\tcrc->tail = (crc->tail + n) & (ACPI_AML_BUF_SIZE - 1);\n\tret = n;\nout:\n\tacpi_aml_unlock_fifo(ACPI_AML_OUT_USER, ret >= 0);\n\treturn ret;\n}\n\nstatic ssize_t acpi_aml_read(struct file *file, char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tint ret = 0;\n\tint size = 0;\n\n\tif (!count)\n\t\treturn 0;\n\tif (!access_ok(buf, count))\n\t\treturn -EFAULT;\n\n\twhile (count > 0) {\nagain:\n\t\tret = acpi_aml_read_user(buf + size, count);\n\t\tif (ret == -EAGAIN) {\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tret = wait_event_interruptible(acpi_aml_io.wait,\n\t\t\t\t\tacpi_aml_user_readable());\n\t\t\t\t \n\t\t\t\tif (ret == 0)\n\t\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tif (!acpi_aml_running())\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret) {\n\t\t\tsize += ret;\n\t\t\tcount -= ret;\n\t\t\t*ppos += ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn size > 0 ? size : ret;\n}\n\nstatic int acpi_aml_write_user(const char __user *buf, int len)\n{\n\tint ret;\n\tstruct circ_buf *crc = &acpi_aml_io.in_crc;\n\tint n;\n\tchar *p;\n\n\tret = acpi_aml_lock_write(crc, ACPI_AML_IN_USER);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tsmp_mb();\n\tp = &crc->buf[crc->head];\n\tn = min(len, circ_space_to_end(crc));\n\tif (copy_from_user(p, buf, n)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\t \n\tsmp_wmb();\n\tcrc->head = (crc->head + n) & (ACPI_AML_BUF_SIZE - 1);\n\tret = n;\nout:\n\tacpi_aml_unlock_fifo(ACPI_AML_IN_USER, ret >= 0);\n\treturn n;\n}\n\nstatic ssize_t acpi_aml_write(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tint ret = 0;\n\tint size = 0;\n\n\tif (!count)\n\t\treturn 0;\n\tif (!access_ok(buf, count))\n\t\treturn -EFAULT;\n\n\twhile (count > 0) {\nagain:\n\t\tret = acpi_aml_write_user(buf + size, count);\n\t\tif (ret == -EAGAIN) {\n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tret = wait_event_interruptible(acpi_aml_io.wait,\n\t\t\t\t\tacpi_aml_user_writable());\n\t\t\t\t \n\t\t\t\tif (ret == 0)\n\t\t\t\t\tgoto again;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tif (!acpi_aml_running())\n\t\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret) {\n\t\t\tsize += ret;\n\t\t\tcount -= ret;\n\t\t\t*ppos += ret;\n\t\t}\n\t}\n\treturn size > 0 ? size : ret;\n}\n\nstatic __poll_t acpi_aml_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t masks = 0;\n\n\tpoll_wait(file, &acpi_aml_io.wait, wait);\n\tif (acpi_aml_user_readable())\n\t\tmasks |= EPOLLIN | EPOLLRDNORM;\n\tif (acpi_aml_user_writable())\n\t\tmasks |= EPOLLOUT | EPOLLWRNORM;\n\n\treturn masks;\n}\n\nstatic const struct file_operations acpi_aml_operations = {\n\t.read\t\t= acpi_aml_read,\n\t.write\t\t= acpi_aml_write,\n\t.poll\t\t= acpi_aml_poll,\n\t.open\t\t= acpi_aml_open,\n\t.release\t= acpi_aml_release,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct acpi_debugger_ops acpi_aml_debugger = {\n\t.create_thread\t\t = acpi_aml_create_thread,\n\t.read_cmd\t\t = acpi_aml_read_cmd,\n\t.write_log\t\t = acpi_aml_write_log,\n\t.wait_command_ready\t = acpi_aml_wait_command_ready,\n\t.notify_command_complete = acpi_aml_notify_command_complete,\n};\n\nstatic int __init acpi_aml_init(void)\n{\n\tint ret;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_init(&acpi_aml_io.lock);\n\tinit_waitqueue_head(&acpi_aml_io.wait);\n\tacpi_aml_io.out_crc.buf = acpi_aml_io.out_buf;\n\tacpi_aml_io.in_crc.buf = acpi_aml_io.in_buf;\n\n\tacpi_aml_dentry = debugfs_create_file(\"acpidbg\",\n\t\t\t\t\t      S_IFREG | S_IRUGO | S_IWUSR,\n\t\t\t\t\t      acpi_debugfs_dir, NULL,\n\t\t\t\t\t      &acpi_aml_operations);\n\n\tret = acpi_register_debugger(THIS_MODULE, &acpi_aml_debugger);\n\tif (ret) {\n\t\tdebugfs_remove(acpi_aml_dentry);\n\t\tacpi_aml_dentry = NULL;\n\t\treturn ret;\n\t}\n\n\tacpi_aml_initialized = true;\n\treturn 0;\n}\n\nstatic void __exit acpi_aml_exit(void)\n{\n\tif (acpi_aml_initialized) {\n\t\tacpi_unregister_debugger(&acpi_aml_debugger);\n\t\tdebugfs_remove(acpi_aml_dentry);\n\t\tacpi_aml_dentry = NULL;\n\t\tacpi_aml_initialized = false;\n\t}\n}\n\nmodule_init(acpi_aml_init);\nmodule_exit(acpi_aml_exit);\n\nMODULE_AUTHOR(\"Lv Zheng\");\nMODULE_DESCRIPTION(\"ACPI debugger userspace IO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}