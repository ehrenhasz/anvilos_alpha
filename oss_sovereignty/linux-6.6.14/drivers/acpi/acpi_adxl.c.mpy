{
  "module_name": "acpi_adxl.c",
  "hash_id": "9f2ea2cd5946d8fa722a1dda5250530ec631ef67d49097b37e0d68ad67d556ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/acpi_adxl.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/adxl.h>\n\n#define ADXL_REVISION\t\t\t0x1\n#define ADXL_IDX_GET_ADDR_PARAMS\t0x1\n#define ADXL_IDX_FORWARD_TRANSLATE\t0x2\n#define ACPI_ADXL_PATH\t\t\t\"\\\\_SB.ADXL\"\n\n \n#define ADXL_MAX_COMPONENTS\t\t500\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"ADXL: \" fmt\n\nstatic acpi_handle handle;\nstatic union acpi_object *params;\nstatic const guid_t adxl_guid =\n\tGUID_INIT(0xAA3C050A, 0x7EA4, 0x4C1F,\n\t\t  0xAF, 0xDA, 0x12, 0x67, 0xDF, 0xD3, 0xD4, 0x8D);\n\nstatic int adxl_count;\nstatic char **adxl_component_names;\n\nstatic union acpi_object *adxl_dsm(int cmd, union acpi_object argv[])\n{\n\tunion acpi_object *obj, *o;\n\n\tobj = acpi_evaluate_dsm_typed(handle, &adxl_guid, ADXL_REVISION,\n\t\t\t\t      cmd, argv, ACPI_TYPE_PACKAGE);\n\tif (!obj) {\n\t\tpr_info(\"DSM call failed for cmd=%d\\n\", cmd);\n\t\treturn NULL;\n\t}\n\n\tif (obj->package.count != 2) {\n\t\tpr_info(\"Bad pkg count %d\\n\", obj->package.count);\n\t\tgoto err;\n\t}\n\n\to = obj->package.elements;\n\tif (o->type != ACPI_TYPE_INTEGER) {\n\t\tpr_info(\"Bad 1st element type %d\\n\", o->type);\n\t\tgoto err;\n\t}\n\tif (o->integer.value) {\n\t\tpr_info(\"Bad ret val %llu\\n\", o->integer.value);\n\t\tgoto err;\n\t}\n\n\to = obj->package.elements + 1;\n\tif (o->type != ACPI_TYPE_PACKAGE) {\n\t\tpr_info(\"Bad 2nd element type %d\\n\", o->type);\n\t\tgoto err;\n\t}\n\treturn obj;\n\nerr:\n\tACPI_FREE(obj);\n\treturn NULL;\n}\n\n \nconst char * const *adxl_get_component_names(void)\n{\n\treturn (const char * const *)adxl_component_names;\n}\nEXPORT_SYMBOL_GPL(adxl_get_component_names);\n\n \nint adxl_decode(u64 addr, u64 component_values[])\n{\n\tunion acpi_object argv4[2], *results, *r;\n\tint i, cnt;\n\n\tif (!adxl_component_names)\n\t\treturn -EOPNOTSUPP;\n\n\targv4[0].type = ACPI_TYPE_PACKAGE;\n\targv4[0].package.count = 1;\n\targv4[0].package.elements = &argv4[1];\n\targv4[1].integer.type = ACPI_TYPE_INTEGER;\n\targv4[1].integer.value = addr;\n\n\tresults = adxl_dsm(ADXL_IDX_FORWARD_TRANSLATE, argv4);\n\tif (!results)\n\t\treturn -EINVAL;\n\n\tr = results->package.elements + 1;\n\tcnt = r->package.count;\n\tif (cnt != adxl_count) {\n\t\tACPI_FREE(results);\n\t\treturn -EINVAL;\n\t}\n\tr = r->package.elements;\n\n\tfor (i = 0; i < cnt; i++)\n\t\tcomponent_values[i] = r[i].integer.value;\n\n\tACPI_FREE(results);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(adxl_decode);\n\nstatic int __init adxl_init(void)\n{\n\tchar *path = ACPI_ADXL_PATH;\n\tunion acpi_object *p;\n\tacpi_status status;\n\tint i;\n\n\tstatus = acpi_get_handle(NULL, path, &handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_debug(\"No ACPI handle for path %s\\n\", path);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_has_method(handle, \"_DSM\")) {\n\t\tpr_info(\"No DSM method\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_check_dsm(handle, &adxl_guid, ADXL_REVISION,\n\t\t\t    ADXL_IDX_GET_ADDR_PARAMS |\n\t\t\t    ADXL_IDX_FORWARD_TRANSLATE)) {\n\t\tpr_info(\"DSM method does not support forward translate\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tparams = adxl_dsm(ADXL_IDX_GET_ADDR_PARAMS, NULL);\n\tif (!params) {\n\t\tpr_info(\"Failed to get component names\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tp = params->package.elements + 1;\n\tadxl_count = p->package.count;\n\tif (adxl_count > ADXL_MAX_COMPONENTS) {\n\t\tpr_info(\"Insane number of address component names %d\\n\", adxl_count);\n\t\tACPI_FREE(params);\n\t\treturn -ENODEV;\n\t}\n\tp = p->package.elements;\n\n\t \n\tadxl_component_names = kcalloc(adxl_count + 1, sizeof(char *), GFP_KERNEL);\n\tif (!adxl_component_names) {\n\t\tACPI_FREE(params);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < adxl_count; i++)\n\t\tadxl_component_names[i] = p[i].string.pointer;\n\n\treturn 0;\n}\nsubsys_initcall(adxl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}