{
  "module_name": "nfit.h",
  "hash_id": "a159267efe52b14e89ca78ba93c426693b0cb62e38e527fdbaff4b140112ef59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/nfit/nfit.h",
  "human_readable_source": " \n \n#ifndef __NFIT_H__\n#define __NFIT_H__\n#include <linux/workqueue.h>\n#include <linux/libnvdimm.h>\n#include <linux/ndctl.h>\n#include <linux/types.h>\n#include <linux/acpi.h>\n#include <acpi/acuuid.h>\n\n \n#define UUID_NFIT_BUS \"2f10e7a4-9e91-11e4-89d3-123b93f75cba\"\n\n \nenum nvdimm_family_cmds {\n\tNVDIMM_INTEL_LATCH_SHUTDOWN = 10,\n\tNVDIMM_INTEL_GET_MODES = 11,\n\tNVDIMM_INTEL_GET_FWINFO = 12,\n\tNVDIMM_INTEL_START_FWUPDATE = 13,\n\tNVDIMM_INTEL_SEND_FWUPDATE = 14,\n\tNVDIMM_INTEL_FINISH_FWUPDATE = 15,\n\tNVDIMM_INTEL_QUERY_FWUPDATE = 16,\n\tNVDIMM_INTEL_SET_THRESHOLD = 17,\n\tNVDIMM_INTEL_INJECT_ERROR = 18,\n\tNVDIMM_INTEL_GET_SECURITY_STATE = 19,\n\tNVDIMM_INTEL_SET_PASSPHRASE = 20,\n\tNVDIMM_INTEL_DISABLE_PASSPHRASE = 21,\n\tNVDIMM_INTEL_UNLOCK_UNIT = 22,\n\tNVDIMM_INTEL_FREEZE_LOCK = 23,\n\tNVDIMM_INTEL_SECURE_ERASE = 24,\n\tNVDIMM_INTEL_OVERWRITE = 25,\n\tNVDIMM_INTEL_QUERY_OVERWRITE = 26,\n\tNVDIMM_INTEL_SET_MASTER_PASSPHRASE = 27,\n\tNVDIMM_INTEL_MASTER_SECURE_ERASE = 28,\n\tNVDIMM_INTEL_FW_ACTIVATE_DIMMINFO = 29,\n\tNVDIMM_INTEL_FW_ACTIVATE_ARM = 30,\n};\n\nenum nvdimm_bus_family_cmds {\n\tNVDIMM_BUS_INTEL_FW_ACTIVATE_BUSINFO = 1,\n\tNVDIMM_BUS_INTEL_FW_ACTIVATE = 2,\n};\n\n#define NVDIMM_INTEL_SECURITY_CMDMASK \\\n(1 << NVDIMM_INTEL_GET_SECURITY_STATE | 1 << NVDIMM_INTEL_SET_PASSPHRASE \\\n| 1 << NVDIMM_INTEL_DISABLE_PASSPHRASE | 1 << NVDIMM_INTEL_UNLOCK_UNIT \\\n| 1 << NVDIMM_INTEL_FREEZE_LOCK | 1 << NVDIMM_INTEL_SECURE_ERASE \\\n| 1 << NVDIMM_INTEL_OVERWRITE | 1 << NVDIMM_INTEL_QUERY_OVERWRITE \\\n| 1 << NVDIMM_INTEL_SET_MASTER_PASSPHRASE \\\n| 1 << NVDIMM_INTEL_MASTER_SECURE_ERASE)\n\n#define NVDIMM_INTEL_FW_ACTIVATE_CMDMASK \\\n(1 << NVDIMM_INTEL_FW_ACTIVATE_DIMMINFO | 1 << NVDIMM_INTEL_FW_ACTIVATE_ARM)\n\n#define NVDIMM_BUS_INTEL_FW_ACTIVATE_CMDMASK \\\n(1 << NVDIMM_BUS_INTEL_FW_ACTIVATE_BUSINFO | 1 << NVDIMM_BUS_INTEL_FW_ACTIVATE)\n\n#define NVDIMM_INTEL_CMDMASK \\\n(NVDIMM_STANDARD_CMDMASK | 1 << NVDIMM_INTEL_GET_MODES \\\n | 1 << NVDIMM_INTEL_GET_FWINFO | 1 << NVDIMM_INTEL_START_FWUPDATE \\\n | 1 << NVDIMM_INTEL_SEND_FWUPDATE | 1 << NVDIMM_INTEL_FINISH_FWUPDATE \\\n | 1 << NVDIMM_INTEL_QUERY_FWUPDATE | 1 << NVDIMM_INTEL_SET_THRESHOLD \\\n | 1 << NVDIMM_INTEL_INJECT_ERROR | 1 << NVDIMM_INTEL_LATCH_SHUTDOWN \\\n | NVDIMM_INTEL_SECURITY_CMDMASK | NVDIMM_INTEL_FW_ACTIVATE_CMDMASK)\n\n#define NVDIMM_INTEL_DENY_CMDMASK \\\n(NVDIMM_INTEL_SECURITY_CMDMASK | NVDIMM_INTEL_FW_ACTIVATE_CMDMASK)\n\nenum nfit_uuids {\n\t \n\tNFIT_DEV_DIMM = NVDIMM_FAMILY_INTEL,\n\tNFIT_DEV_DIMM_N_HPE1 = NVDIMM_FAMILY_HPE1,\n\tNFIT_DEV_DIMM_N_HPE2 = NVDIMM_FAMILY_HPE2,\n\tNFIT_DEV_DIMM_N_MSFT = NVDIMM_FAMILY_MSFT,\n\tNFIT_DEV_DIMM_N_HYPERV = NVDIMM_FAMILY_HYPERV,\n\t \n\tNFIT_BUS_INTEL = NVDIMM_FAMILY_MAX + NVDIMM_BUS_FAMILY_INTEL,\n\tNFIT_SPA_VOLATILE,\n\tNFIT_SPA_PM,\n\tNFIT_SPA_DCR,\n\tNFIT_SPA_BDW,\n\tNFIT_SPA_VDISK,\n\tNFIT_SPA_VCD,\n\tNFIT_SPA_PDISK,\n\tNFIT_SPA_PCD,\n\tNFIT_DEV_BUS,\n\tNFIT_UUID_MAX,\n};\n\n \n#define NFIT_FIC_BYTE cpu_to_le16(0x101)  \n#define NFIT_FIC_BLK cpu_to_le16(0x201)  \n#define NFIT_FIC_BYTEN cpu_to_le16(0x301)  \n\nenum {\n\tNFIT_BLK_READ_FLUSH = 1,\n\tNFIT_BLK_DCR_LATCH = 2,\n\tNFIT_ARS_STATUS_DONE = 0,\n\tNFIT_ARS_STATUS_BUSY = 1 << 16,\n\tNFIT_ARS_STATUS_NONE = 2 << 16,\n\tNFIT_ARS_STATUS_INTR = 3 << 16,\n\tNFIT_ARS_START_BUSY = 6,\n\tNFIT_ARS_CAP_NONE = 1,\n\tNFIT_ARS_F_OVERFLOW = 1,\n\tNFIT_ARS_TIMEOUT = 90,\n};\n\nenum nfit_root_notifiers {\n\tNFIT_NOTIFY_UPDATE = 0x80,\n\tNFIT_NOTIFY_UC_MEMORY_ERROR = 0x81,\n};\n\nenum nfit_dimm_notifiers {\n\tNFIT_NOTIFY_DIMM_HEALTH = 0x81,\n};\n\nenum nfit_ars_state {\n\tARS_REQ_SHORT,\n\tARS_REQ_LONG,\n\tARS_FAILED,\n};\n\nstruct nfit_spa {\n\tstruct list_head list;\n\tstruct nd_region *nd_region;\n\tunsigned long ars_state;\n\tu32 clear_err_unit;\n\tu32 max_ars;\n\tstruct acpi_nfit_system_address spa[];\n};\n\nstruct nfit_dcr {\n\tstruct list_head list;\n\tstruct acpi_nfit_control_region dcr[];\n};\n\nstruct nfit_bdw {\n\tstruct list_head list;\n\tstruct acpi_nfit_data_region bdw[];\n};\n\nstruct nfit_idt {\n\tstruct list_head list;\n\tstruct acpi_nfit_interleave idt[];\n};\n\nstruct nfit_flush {\n\tstruct list_head list;\n\tstruct acpi_nfit_flush_address flush[];\n};\n\nstruct nfit_memdev {\n\tstruct list_head list;\n\tstruct acpi_nfit_memory_map memdev[];\n};\n\nenum nfit_mem_flags {\n\tNFIT_MEM_LSR,\n\tNFIT_MEM_LSW,\n\tNFIT_MEM_DIRTY,\n\tNFIT_MEM_DIRTY_COUNT,\n};\n\n#define NFIT_DIMM_ID_LEN\t22\n\n \nstruct nfit_mem {\n\tstruct nvdimm *nvdimm;\n\tstruct acpi_nfit_memory_map *memdev_dcr;\n\tstruct acpi_nfit_memory_map *memdev_pmem;\n\tstruct acpi_nfit_control_region *dcr;\n\tstruct acpi_nfit_system_address *spa_dcr;\n\tstruct acpi_nfit_interleave *idt_dcr;\n\tstruct kernfs_node *flags_attr;\n\tstruct nfit_flush *nfit_flush;\n\tstruct list_head list;\n\tstruct acpi_device *adev;\n\tstruct acpi_nfit_desc *acpi_desc;\n\tenum nvdimm_fwa_state fwa_state;\n\tenum nvdimm_fwa_result fwa_result;\n\tint fwa_count;\n\tchar id[NFIT_DIMM_ID_LEN+1];\n\tstruct resource *flush_wpq;\n\tunsigned long dsm_mask;\n\tunsigned long flags;\n\tu32 dirty_shutdown;\n\tint family;\n};\n\nenum scrub_flags {\n\tARS_BUSY,\n\tARS_CANCEL,\n\tARS_VALID,\n\tARS_POLL,\n};\n\nstruct acpi_nfit_desc {\n\tstruct nvdimm_bus_descriptor nd_desc;\n\tstruct acpi_table_header acpi_header;\n\tstruct mutex init_mutex;\n\tstruct list_head memdevs;\n\tstruct list_head flushes;\n\tstruct list_head dimms;\n\tstruct list_head spas;\n\tstruct list_head dcrs;\n\tstruct list_head bdws;\n\tstruct list_head idts;\n\tstruct nvdimm_bus *nvdimm_bus;\n\tstruct device *dev;\n\tstruct nd_cmd_ars_status *ars_status;\n\tstruct nfit_spa *scrub_spa;\n\tstruct delayed_work dwork;\n\tstruct list_head list;\n\tstruct kernfs_node *scrub_count_state;\n\tunsigned int max_ars;\n\tunsigned int scrub_count;\n\tunsigned int scrub_mode;\n\tunsigned long scrub_flags;\n\tunsigned long dimm_cmd_force_en;\n\tunsigned long bus_cmd_force_en;\n\tunsigned long bus_dsm_mask;\n\tunsigned long family_dsm_mask[NVDIMM_BUS_FAMILY_MAX + 1];\n\tunsigned int platform_cap;\n\tunsigned int scrub_tmo;\n\tenum nvdimm_fwa_state fwa_state;\n\tenum nvdimm_fwa_capability fwa_cap;\n\tint fwa_count;\n\tbool fwa_noidle;\n\tbool fwa_nosuspend;\n};\n\nenum scrub_mode {\n\tHW_ERROR_SCRUB_OFF,\n\tHW_ERROR_SCRUB_ON,\n};\n\nenum nd_blk_mmio_selector {\n\tBDW,\n\tDCR,\n};\n\nstruct nd_blk_addr {\n\tunion {\n\t\tvoid __iomem *base;\n\t\tvoid *aperture;\n\t};\n};\n\nstruct nfit_blk {\n\tstruct nfit_blk_mmio {\n\t\tstruct nd_blk_addr addr;\n\t\tu64 size;\n\t\tu64 base_offset;\n\t\tu32 line_size;\n\t\tu32 num_lines;\n\t\tu32 table_size;\n\t\tstruct acpi_nfit_interleave *idt;\n\t\tstruct acpi_nfit_system_address *spa;\n\t} mmio[2];\n\tstruct nd_region *nd_region;\n\tu64 bdw_offset;  \n\tu64 stat_offset;\n\tu64 cmd_offset;\n\tu32 dimm_flags;\n};\n\nextern struct list_head acpi_descs;\nextern struct mutex acpi_desc_lock;\nint acpi_nfit_ars_rescan(struct acpi_nfit_desc *acpi_desc,\n\t\tenum nfit_ars_state req_type);\n\n#ifdef CONFIG_X86_MCE\nvoid nfit_mce_register(void);\nvoid nfit_mce_unregister(void);\n#else\nstatic inline void nfit_mce_register(void)\n{\n}\nstatic inline void nfit_mce_unregister(void)\n{\n}\n#endif\n\nint nfit_spa_type(struct acpi_nfit_system_address *spa);\n\nstatic inline struct acpi_nfit_memory_map *__to_nfit_memdev(\n\t\tstruct nfit_mem *nfit_mem)\n{\n\tif (nfit_mem->memdev_dcr)\n\t\treturn nfit_mem->memdev_dcr;\n\treturn nfit_mem->memdev_pmem;\n}\n\nstatic inline struct acpi_nfit_desc *to_acpi_desc(\n\t\tstruct nvdimm_bus_descriptor *nd_desc)\n{\n\treturn container_of(nd_desc, struct acpi_nfit_desc, nd_desc);\n}\n\nconst guid_t *to_nfit_uuid(enum nfit_uuids id);\nint acpi_nfit_init(struct acpi_nfit_desc *acpi_desc, void *nfit, acpi_size sz);\nvoid acpi_nfit_shutdown(void *data);\nvoid __acpi_nfit_notify(struct device *dev, acpi_handle handle, u32 event);\nvoid __acpi_nvdimm_notify(struct device *dev, u32 event);\nint acpi_nfit_ctl(struct nvdimm_bus_descriptor *nd_desc, struct nvdimm *nvdimm,\n\t\tunsigned int cmd, void *buf, unsigned int buf_len, int *cmd_rc);\nvoid acpi_nfit_desc_init(struct acpi_nfit_desc *acpi_desc, struct device *dev);\nbool intel_fwa_supported(struct nvdimm_bus *nvdimm_bus);\nextern struct device_attribute dev_attr_firmware_activate_noidle;\nvoid nfit_intel_shutdown_status(struct nfit_mem *nfit_mem);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}