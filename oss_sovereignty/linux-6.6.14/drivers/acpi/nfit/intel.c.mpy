{
  "module_name": "intel.c",
  "hash_id": "2dfee5a0b633f9c6607c80c5ca557b2c171c8b69a45ad460753cff2a2d2d7e12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/acpi/nfit/intel.c",
  "human_readable_source": "\n \n#include <linux/libnvdimm.h>\n#include <linux/ndctl.h>\n#include <linux/acpi.h>\n#include <linux/memregion.h>\n#include <asm/smp.h>\n#include \"intel.h\"\n#include \"nfit.h\"\n\nstatic ssize_t firmware_activate_noidle_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\tstruct nvdimm_bus_descriptor *nd_desc = to_nd_desc(nvdimm_bus);\n\tstruct acpi_nfit_desc *acpi_desc = to_acpi_desc(nd_desc);\n\n\treturn sprintf(buf, \"%s\\n\", acpi_desc->fwa_noidle ? \"Y\" : \"N\");\n}\n\nstatic ssize_t firmware_activate_noidle_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t size)\n{\n\tstruct nvdimm_bus *nvdimm_bus = to_nvdimm_bus(dev);\n\tstruct nvdimm_bus_descriptor *nd_desc = to_nd_desc(nvdimm_bus);\n\tstruct acpi_nfit_desc *acpi_desc = to_acpi_desc(nd_desc);\n\tssize_t rc;\n\tbool val;\n\n\trc = kstrtobool(buf, &val);\n\tif (rc)\n\t\treturn rc;\n\tif (val != acpi_desc->fwa_noidle)\n\t\tacpi_desc->fwa_cap = NVDIMM_FWA_CAP_INVALID;\n\tacpi_desc->fwa_noidle = val;\n\treturn size;\n}\nDEVICE_ATTR_RW(firmware_activate_noidle);\n\nbool intel_fwa_supported(struct nvdimm_bus *nvdimm_bus)\n{\n\tstruct nvdimm_bus_descriptor *nd_desc = to_nd_desc(nvdimm_bus);\n\tstruct acpi_nfit_desc *acpi_desc = to_acpi_desc(nd_desc);\n\tunsigned long *mask;\n\n\tif (!test_bit(NVDIMM_BUS_FAMILY_INTEL, &nd_desc->bus_family_mask))\n\t\treturn false;\n\n\tmask = &acpi_desc->family_dsm_mask[NVDIMM_BUS_FAMILY_INTEL];\n\treturn *mask == NVDIMM_BUS_INTEL_FW_ACTIVATE_CMDMASK;\n}\n\nstatic unsigned long intel_security_flags(struct nvdimm *nvdimm,\n\t\tenum nvdimm_passphrase_type ptype)\n{\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tunsigned long security_flags = 0;\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_get_security_state cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_INTEL_GET_SECURITY_STATE,\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_out =\n\t\t\t\tsizeof(struct nd_intel_get_security_state),\n\t\t\t.nd_fw_size =\n\t\t\t\tsizeof(struct nd_intel_get_security_state),\n\t\t},\n\t};\n\tint rc;\n\n\tif (!test_bit(NVDIMM_INTEL_GET_SECURITY_STATE, &nfit_mem->dsm_mask))\n\t\treturn 0;\n\n\t \n\tif (nvdimm_in_overwrite(nvdimm) && ptype == NVDIMM_USER)\n\t\treturn BIT(NVDIMM_SECURITY_OVERWRITE);\n\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\tif (rc < 0 || nd_cmd.cmd.status) {\n\t\tpr_err(\"%s: security state retrieval failed (%d:%#x)\\n\",\n\t\t\t\tnvdimm_name(nvdimm), rc, nd_cmd.cmd.status);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ptype == NVDIMM_MASTER) {\n\t\tif (nd_cmd.cmd.extended_state & ND_INTEL_SEC_ESTATE_ENABLED)\n\t\t\tset_bit(NVDIMM_SECURITY_UNLOCKED, &security_flags);\n\t\telse\n\t\t\tset_bit(NVDIMM_SECURITY_DISABLED, &security_flags);\n\t\tif (nd_cmd.cmd.extended_state & ND_INTEL_SEC_ESTATE_PLIMIT)\n\t\t\tset_bit(NVDIMM_SECURITY_FROZEN, &security_flags);\n\t\treturn security_flags;\n\t}\n\n\tif (nd_cmd.cmd.state & ND_INTEL_SEC_STATE_UNSUPPORTED)\n\t\treturn 0;\n\n\tif (nd_cmd.cmd.state & ND_INTEL_SEC_STATE_ENABLED) {\n\t\tif (nd_cmd.cmd.state & ND_INTEL_SEC_STATE_FROZEN ||\n\t\t    nd_cmd.cmd.state & ND_INTEL_SEC_STATE_PLIMIT)\n\t\t\tset_bit(NVDIMM_SECURITY_FROZEN, &security_flags);\n\n\t\tif (nd_cmd.cmd.state & ND_INTEL_SEC_STATE_LOCKED)\n\t\t\tset_bit(NVDIMM_SECURITY_LOCKED, &security_flags);\n\t\telse\n\t\t\tset_bit(NVDIMM_SECURITY_UNLOCKED, &security_flags);\n\t} else\n\t\tset_bit(NVDIMM_SECURITY_DISABLED, &security_flags);\n\n\treturn security_flags;\n}\n\nstatic int intel_security_freeze(struct nvdimm *nvdimm)\n{\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_freeze_lock cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_INTEL_FREEZE_LOCK,\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_out = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_fw_size = ND_INTEL_STATUS_SIZE,\n\t\t},\n\t};\n\tint rc;\n\n\tif (!test_bit(NVDIMM_INTEL_FREEZE_LOCK, &nfit_mem->dsm_mask))\n\t\treturn -ENOTTY;\n\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (nd_cmd.cmd.status)\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic int intel_security_change_key(struct nvdimm *nvdimm,\n\t\tconst struct nvdimm_key_data *old_data,\n\t\tconst struct nvdimm_key_data *new_data,\n\t\tenum nvdimm_passphrase_type ptype)\n{\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tunsigned int cmd = ptype == NVDIMM_MASTER ?\n\t\tNVDIMM_INTEL_SET_MASTER_PASSPHRASE :\n\t\tNVDIMM_INTEL_SET_PASSPHRASE;\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_set_passphrase cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_in = ND_INTEL_PASSPHRASE_SIZE * 2,\n\t\t\t.nd_size_out = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_fw_size = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_command = cmd,\n\t\t},\n\t};\n\tint rc;\n\n\tif (!test_bit(cmd, &nfit_mem->dsm_mask))\n\t\treturn -ENOTTY;\n\n\tmemcpy(nd_cmd.cmd.old_pass, old_data->data,\n\t\t\tsizeof(nd_cmd.cmd.old_pass));\n\tmemcpy(nd_cmd.cmd.new_pass, new_data->data,\n\t\t\tsizeof(nd_cmd.cmd.new_pass));\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (nd_cmd.cmd.status) {\n\tcase 0:\n\t\treturn 0;\n\tcase ND_INTEL_STATUS_INVALID_PASS:\n\t\treturn -EINVAL;\n\tcase ND_INTEL_STATUS_NOT_SUPPORTED:\n\t\treturn -EOPNOTSUPP;\n\tcase ND_INTEL_STATUS_INVALID_STATE:\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic int __maybe_unused intel_security_unlock(struct nvdimm *nvdimm,\n\t\tconst struct nvdimm_key_data *key_data)\n{\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_unlock_unit cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_INTEL_UNLOCK_UNIT,\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_in = ND_INTEL_PASSPHRASE_SIZE,\n\t\t\t.nd_size_out = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_fw_size = ND_INTEL_STATUS_SIZE,\n\t\t},\n\t};\n\tint rc;\n\n\tif (!test_bit(NVDIMM_INTEL_UNLOCK_UNIT, &nfit_mem->dsm_mask))\n\t\treturn -ENOTTY;\n\n\tmemcpy(nd_cmd.cmd.passphrase, key_data->data,\n\t\t\tsizeof(nd_cmd.cmd.passphrase));\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\tswitch (nd_cmd.cmd.status) {\n\tcase 0:\n\t\tbreak;\n\tcase ND_INTEL_STATUS_INVALID_PASS:\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_security_disable(struct nvdimm *nvdimm,\n\t\tconst struct nvdimm_key_data *key_data)\n{\n\tint rc;\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_disable_passphrase cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_INTEL_DISABLE_PASSPHRASE,\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_in = ND_INTEL_PASSPHRASE_SIZE,\n\t\t\t.nd_size_out = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_fw_size = ND_INTEL_STATUS_SIZE,\n\t\t},\n\t};\n\n\tif (!test_bit(NVDIMM_INTEL_DISABLE_PASSPHRASE, &nfit_mem->dsm_mask))\n\t\treturn -ENOTTY;\n\n\tmemcpy(nd_cmd.cmd.passphrase, key_data->data,\n\t\t\tsizeof(nd_cmd.cmd.passphrase));\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (nd_cmd.cmd.status) {\n\tcase 0:\n\t\tbreak;\n\tcase ND_INTEL_STATUS_INVALID_PASS:\n\t\treturn -EINVAL;\n\tcase ND_INTEL_STATUS_INVALID_STATE:\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_security_erase(struct nvdimm *nvdimm,\n\t\tconst struct nvdimm_key_data *key,\n\t\tenum nvdimm_passphrase_type ptype)\n{\n\tint rc;\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tunsigned int cmd = ptype == NVDIMM_MASTER ?\n\t\tNVDIMM_INTEL_MASTER_SECURE_ERASE : NVDIMM_INTEL_SECURE_ERASE;\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_secure_erase cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_in = ND_INTEL_PASSPHRASE_SIZE,\n\t\t\t.nd_size_out = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_fw_size = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_command = cmd,\n\t\t},\n\t};\n\n\tif (!test_bit(cmd, &nfit_mem->dsm_mask))\n\t\treturn -ENOTTY;\n\n\tmemcpy(nd_cmd.cmd.passphrase, key->data,\n\t\t\tsizeof(nd_cmd.cmd.passphrase));\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (nd_cmd.cmd.status) {\n\tcase 0:\n\t\tbreak;\n\tcase ND_INTEL_STATUS_NOT_SUPPORTED:\n\t\treturn -EOPNOTSUPP;\n\tcase ND_INTEL_STATUS_INVALID_PASS:\n\t\treturn -EINVAL;\n\tcase ND_INTEL_STATUS_INVALID_STATE:\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_security_query_overwrite(struct nvdimm *nvdimm)\n{\n\tint rc;\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_query_overwrite cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_INTEL_QUERY_OVERWRITE,\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_out = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_fw_size = ND_INTEL_STATUS_SIZE,\n\t\t},\n\t};\n\n\tif (!test_bit(NVDIMM_INTEL_QUERY_OVERWRITE, &nfit_mem->dsm_mask))\n\t\treturn -ENOTTY;\n\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (nd_cmd.cmd.status) {\n\tcase 0:\n\t\tbreak;\n\tcase ND_INTEL_STATUS_OQUERY_INPROGRESS:\n\t\treturn -EBUSY;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_security_overwrite(struct nvdimm *nvdimm,\n\t\tconst struct nvdimm_key_data *nkey)\n{\n\tint rc;\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_overwrite cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_INTEL_OVERWRITE,\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_in = ND_INTEL_PASSPHRASE_SIZE,\n\t\t\t.nd_size_out = ND_INTEL_STATUS_SIZE,\n\t\t\t.nd_fw_size = ND_INTEL_STATUS_SIZE,\n\t\t},\n\t};\n\n\tif (!test_bit(NVDIMM_INTEL_OVERWRITE, &nfit_mem->dsm_mask))\n\t\treturn -ENOTTY;\n\n\tmemcpy(nd_cmd.cmd.passphrase, nkey->data,\n\t\t\tsizeof(nd_cmd.cmd.passphrase));\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (nd_cmd.cmd.status) {\n\tcase 0:\n\t\treturn 0;\n\tcase ND_INTEL_STATUS_OVERWRITE_UNSUPPORTED:\n\t\treturn -ENOTSUPP;\n\tcase ND_INTEL_STATUS_INVALID_PASS:\n\t\treturn -EINVAL;\n\tcase ND_INTEL_STATUS_INVALID_STATE:\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n}\n\nstatic const struct nvdimm_security_ops __intel_security_ops = {\n\t.get_flags = intel_security_flags,\n\t.freeze = intel_security_freeze,\n\t.change_key = intel_security_change_key,\n\t.disable = intel_security_disable,\n#ifdef CONFIG_X86\n\t.unlock = intel_security_unlock,\n\t.erase = intel_security_erase,\n\t.overwrite = intel_security_overwrite,\n\t.query_overwrite = intel_security_query_overwrite,\n#endif\n};\n\nconst struct nvdimm_security_ops *intel_security_ops = &__intel_security_ops;\n\nstatic int intel_bus_fwa_businfo(struct nvdimm_bus_descriptor *nd_desc,\n\t\tstruct nd_intel_bus_fw_activate_businfo *info)\n{\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_bus_fw_activate_businfo cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_BUS_INTEL_FW_ACTIVATE_BUSINFO,\n\t\t\t.nd_family = NVDIMM_BUS_FAMILY_INTEL,\n\t\t\t.nd_size_out =\n\t\t\t\tsizeof(struct nd_intel_bus_fw_activate_businfo),\n\t\t\t.nd_fw_size =\n\t\t\t\tsizeof(struct nd_intel_bus_fw_activate_businfo),\n\t\t},\n\t};\n\tint rc;\n\n\trc = nd_desc->ndctl(nd_desc, NULL, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd),\n\t\t\tNULL);\n\t*info = nd_cmd.cmd;\n\treturn rc;\n}\n\n \nstatic enum nvdimm_fwa_state intel_bus_fwa_state(\n\t\tstruct nvdimm_bus_descriptor *nd_desc)\n{\n\tstruct acpi_nfit_desc *acpi_desc = to_acpi_desc(nd_desc);\n\tstruct nd_intel_bus_fw_activate_businfo info;\n\tstruct device *dev = acpi_desc->dev;\n\tenum nvdimm_fwa_state state;\n\tint rc;\n\n\t \n\tswitch (acpi_desc->fwa_state) {\n\tcase NVDIMM_FWA_INVALID:\n\tcase NVDIMM_FWA_BUSY:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (acpi_desc->fwa_cap == NVDIMM_FWA_CAP_INVALID)\n\t\t\tbreak;\n\t\treturn acpi_desc->fwa_state;\n\t}\n\n\t \n\trc = intel_bus_fwa_businfo(nd_desc, &info);\n\tif (rc)\n\t\treturn NVDIMM_FWA_INVALID;\n\n\tswitch (info.state) {\n\tcase ND_INTEL_FWA_IDLE:\n\t\tstate = NVDIMM_FWA_IDLE;\n\t\tbreak;\n\tcase ND_INTEL_FWA_BUSY:\n\t\tstate = NVDIMM_FWA_BUSY;\n\t\tbreak;\n\tcase ND_INTEL_FWA_ARMED:\n\t\tif (info.activate_tmo > info.max_quiesce_tmo)\n\t\t\tstate = NVDIMM_FWA_ARM_OVERFLOW;\n\t\telse\n\t\t\tstate = NVDIMM_FWA_ARMED;\n\t\tbreak;\n\tdefault:\n\t\tdev_err_once(dev, \"invalid firmware activate state %d\\n\",\n\t\t\t\tinfo.state);\n\t\treturn NVDIMM_FWA_INVALID;\n\t}\n\n\t \n\tif (acpi_desc->fwa_cap == NVDIMM_FWA_CAP_INVALID) {\n\t\tif (info.capability & ND_INTEL_BUS_FWA_CAP_FWQUIESCE)\n\t\t\tacpi_desc->fwa_cap = NVDIMM_FWA_CAP_QUIESCE;\n\t\telse if (info.capability & ND_INTEL_BUS_FWA_CAP_OSQUIESCE) {\n\t\t\t \n\t\t\tacpi_desc->fwa_cap = NVDIMM_FWA_CAP_LIVE;\n\t\t} else\n\t\t\tacpi_desc->fwa_cap = NVDIMM_FWA_CAP_NONE;\n\t}\n\n\tacpi_desc->fwa_state = state;\n\n\treturn state;\n}\n\nstatic enum nvdimm_fwa_capability intel_bus_fwa_capability(\n\t\tstruct nvdimm_bus_descriptor *nd_desc)\n{\n\tstruct acpi_nfit_desc *acpi_desc = to_acpi_desc(nd_desc);\n\n\tif (acpi_desc->fwa_cap > NVDIMM_FWA_CAP_INVALID)\n\t\treturn acpi_desc->fwa_cap;\n\n\tif (intel_bus_fwa_state(nd_desc) > NVDIMM_FWA_INVALID)\n\t\treturn acpi_desc->fwa_cap;\n\n\treturn NVDIMM_FWA_CAP_INVALID;\n}\n\nstatic int intel_bus_fwa_activate(struct nvdimm_bus_descriptor *nd_desc)\n{\n\tstruct acpi_nfit_desc *acpi_desc = to_acpi_desc(nd_desc);\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_bus_fw_activate cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_BUS_INTEL_FW_ACTIVATE,\n\t\t\t.nd_family = NVDIMM_BUS_FAMILY_INTEL,\n\t\t\t.nd_size_in = sizeof(nd_cmd.cmd.iodev_state),\n\t\t\t.nd_size_out =\n\t\t\t\tsizeof(struct nd_intel_bus_fw_activate),\n\t\t\t.nd_fw_size =\n\t\t\t\tsizeof(struct nd_intel_bus_fw_activate),\n\t\t},\n\t\t \n\t\t.cmd = {\n\t\t\t.iodev_state = acpi_desc->fwa_noidle\n\t\t\t\t? ND_INTEL_BUS_FWA_IODEV_OS_IDLE\n\t\t\t\t: ND_INTEL_BUS_FWA_IODEV_FORCE_IDLE,\n\t\t},\n\t};\n\tint rc;\n\n\tswitch (intel_bus_fwa_state(nd_desc)) {\n\tcase NVDIMM_FWA_ARMED:\n\tcase NVDIMM_FWA_ARM_OVERFLOW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\trc = nd_desc->ndctl(nd_desc, NULL, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd),\n\t\t\tNULL);\n\n\t \n\tacpi_desc->fwa_state = NVDIMM_FWA_INVALID;\n\tacpi_desc->fwa_count++;\n\n\tdev_dbg(acpi_desc->dev, \"result: %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic const struct nvdimm_bus_fw_ops __intel_bus_fw_ops = {\n\t.activate_state = intel_bus_fwa_state,\n\t.capability = intel_bus_fwa_capability,\n\t.activate = intel_bus_fwa_activate,\n};\n\nconst struct nvdimm_bus_fw_ops *intel_bus_fw_ops = &__intel_bus_fw_ops;\n\nstatic int intel_fwa_dimminfo(struct nvdimm *nvdimm,\n\t\tstruct nd_intel_fw_activate_dimminfo *info)\n{\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_fw_activate_dimminfo cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_INTEL_FW_ACTIVATE_DIMMINFO,\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_out =\n\t\t\t\tsizeof(struct nd_intel_fw_activate_dimminfo),\n\t\t\t.nd_fw_size =\n\t\t\t\tsizeof(struct nd_intel_fw_activate_dimminfo),\n\t\t},\n\t};\n\tint rc;\n\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\t*info = nd_cmd.cmd;\n\treturn rc;\n}\n\nstatic enum nvdimm_fwa_state intel_fwa_state(struct nvdimm *nvdimm)\n{\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tstruct acpi_nfit_desc *acpi_desc = nfit_mem->acpi_desc;\n\tstruct nd_intel_fw_activate_dimminfo info;\n\tint rc;\n\n\t \n\tswitch (nfit_mem->fwa_state) {\n\tcase NVDIMM_FWA_INVALID:\n\tcase NVDIMM_FWA_BUSY:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (nfit_mem->fwa_count == acpi_desc->fwa_count)\n\t\t\treturn nfit_mem->fwa_state;\n\t}\n\n\trc = intel_fwa_dimminfo(nvdimm, &info);\n\tif (rc)\n\t\treturn NVDIMM_FWA_INVALID;\n\n\tswitch (info.state) {\n\tcase ND_INTEL_FWA_IDLE:\n\t\tnfit_mem->fwa_state = NVDIMM_FWA_IDLE;\n\t\tbreak;\n\tcase ND_INTEL_FWA_BUSY:\n\t\tnfit_mem->fwa_state = NVDIMM_FWA_BUSY;\n\t\tbreak;\n\tcase ND_INTEL_FWA_ARMED:\n\t\tnfit_mem->fwa_state = NVDIMM_FWA_ARMED;\n\t\tbreak;\n\tdefault:\n\t\tnfit_mem->fwa_state = NVDIMM_FWA_INVALID;\n\t\tbreak;\n\t}\n\n\tswitch (info.result) {\n\tcase ND_INTEL_DIMM_FWA_NONE:\n\t\tnfit_mem->fwa_result = NVDIMM_FWA_RESULT_NONE;\n\t\tbreak;\n\tcase ND_INTEL_DIMM_FWA_SUCCESS:\n\t\tnfit_mem->fwa_result = NVDIMM_FWA_RESULT_SUCCESS;\n\t\tbreak;\n\tcase ND_INTEL_DIMM_FWA_NOTSTAGED:\n\t\tnfit_mem->fwa_result = NVDIMM_FWA_RESULT_NOTSTAGED;\n\t\tbreak;\n\tcase ND_INTEL_DIMM_FWA_NEEDRESET:\n\t\tnfit_mem->fwa_result = NVDIMM_FWA_RESULT_NEEDRESET;\n\t\tbreak;\n\tcase ND_INTEL_DIMM_FWA_MEDIAFAILED:\n\tcase ND_INTEL_DIMM_FWA_ABORT:\n\tcase ND_INTEL_DIMM_FWA_NOTSUPP:\n\tcase ND_INTEL_DIMM_FWA_ERROR:\n\tdefault:\n\t\tnfit_mem->fwa_result = NVDIMM_FWA_RESULT_FAIL;\n\t\tbreak;\n\t}\n\n\tnfit_mem->fwa_count = acpi_desc->fwa_count;\n\n\treturn nfit_mem->fwa_state;\n}\n\nstatic enum nvdimm_fwa_result intel_fwa_result(struct nvdimm *nvdimm)\n{\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tstruct acpi_nfit_desc *acpi_desc = nfit_mem->acpi_desc;\n\n\tif (nfit_mem->fwa_count == acpi_desc->fwa_count\n\t\t\t&& nfit_mem->fwa_result > NVDIMM_FWA_RESULT_INVALID)\n\t\treturn nfit_mem->fwa_result;\n\n\tif (intel_fwa_state(nvdimm) > NVDIMM_FWA_INVALID)\n\t\treturn nfit_mem->fwa_result;\n\n\treturn NVDIMM_FWA_RESULT_INVALID;\n}\n\nstatic int intel_fwa_arm(struct nvdimm *nvdimm, enum nvdimm_fwa_trigger arm)\n{\n\tstruct nfit_mem *nfit_mem = nvdimm_provider_data(nvdimm);\n\tstruct acpi_nfit_desc *acpi_desc = nfit_mem->acpi_desc;\n\tstruct {\n\t\tstruct nd_cmd_pkg pkg;\n\t\tstruct nd_intel_fw_activate_arm cmd;\n\t} nd_cmd = {\n\t\t.pkg = {\n\t\t\t.nd_command = NVDIMM_INTEL_FW_ACTIVATE_ARM,\n\t\t\t.nd_family = NVDIMM_FAMILY_INTEL,\n\t\t\t.nd_size_in = sizeof(nd_cmd.cmd.activate_arm),\n\t\t\t.nd_size_out =\n\t\t\t\tsizeof(struct nd_intel_fw_activate_arm),\n\t\t\t.nd_fw_size =\n\t\t\t\tsizeof(struct nd_intel_fw_activate_arm),\n\t\t},\n\t\t.cmd = {\n\t\t\t.activate_arm = arm == NVDIMM_FWA_ARM\n\t\t\t\t? ND_INTEL_DIMM_FWA_ARM\n\t\t\t\t: ND_INTEL_DIMM_FWA_DISARM,\n\t\t},\n\t};\n\tint rc;\n\n\tswitch (intel_fwa_state(nvdimm)) {\n\tcase NVDIMM_FWA_INVALID:\n\t\treturn -ENXIO;\n\tcase NVDIMM_FWA_BUSY:\n\t\treturn -EBUSY;\n\tcase NVDIMM_FWA_IDLE:\n\t\tif (arm == NVDIMM_FWA_DISARM)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NVDIMM_FWA_ARMED:\n\t\tif (arm == NVDIMM_FWA_ARM)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tacpi_desc->fwa_state = NVDIMM_FWA_INVALID;\n\tnfit_mem->fwa_state = NVDIMM_FWA_INVALID;\n\n\trc = nvdimm_ctl(nvdimm, ND_CMD_CALL, &nd_cmd, sizeof(nd_cmd), NULL);\n\n\tdev_dbg(acpi_desc->dev, \"%s result: %d\\n\", arm == NVDIMM_FWA_ARM\n\t\t\t? \"arm\" : \"disarm\", rc);\n\treturn rc;\n}\n\nstatic const struct nvdimm_fw_ops __intel_fw_ops = {\n\t.activate_state = intel_fwa_state,\n\t.activate_result = intel_fwa_result,\n\t.arm = intel_fwa_arm,\n};\n\nconst struct nvdimm_fw_ops *intel_fw_ops = &__intel_fw_ops;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}