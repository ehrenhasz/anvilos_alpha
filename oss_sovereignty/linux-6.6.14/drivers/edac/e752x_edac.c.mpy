{
  "module_name": "e752x_edac.c",
  "hash_id": "1fd780538553d523b2d6ddf9fb3b7a5f9340cf4bd7ff6573e0248783c23a8df5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/e752x_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\"e752x_edac\"\n\nstatic int report_non_memory_errors;\nstatic int force_function_unhide;\nstatic int sysbus_parity = -1;\n\nstatic struct edac_pci_ctl_info *e752x_pci;\n\n#define e752x_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"e752x\", fmt, ##arg)\n\n#define e752x_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"e752x\", fmt, ##arg)\n\n#ifndef PCI_DEVICE_ID_INTEL_7520_0\n#define PCI_DEVICE_ID_INTEL_7520_0      0x3590\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7520_1_ERR\n#define PCI_DEVICE_ID_INTEL_7520_1_ERR  0x3591\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7525_0\n#define PCI_DEVICE_ID_INTEL_7525_0      0x359E\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7525_1_ERR\n#define PCI_DEVICE_ID_INTEL_7525_1_ERR  0x3593\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7320_0\n#define PCI_DEVICE_ID_INTEL_7320_0\t0x3592\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7320_1_ERR\n#define PCI_DEVICE_ID_INTEL_7320_1_ERR\t0x3593\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_3100_0\n#define PCI_DEVICE_ID_INTEL_3100_0\t0x35B0\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_3100_1_ERR\n#define PCI_DEVICE_ID_INTEL_3100_1_ERR\t0x35B1\n#endif\t\t\t\t \n\n#define E752X_NR_CSROWS\t\t8\t \n\n \n#define E752X_MCHSCRB\t\t0x52\t \n\t\t\t\t\t \n#define E752X_DRB\t\t0x60\t \n#define E752X_DRA\t\t0x70\t \n\t\t\t\t\t \n#define E752X_DRC\t\t0x7C\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define E752X_DRM\t\t0x80\t \n#define E752X_DDRCSR\t\t0x9A\t \n\t\t\t\t\t \n#define E752X_TOLM\t\t0xC4\t \n#define E752X_REMAPBASE\t\t0xC6\t \n#define E752X_REMAPLIMIT\t0xC8\t \n#define E752X_REMAPOFFSET\t0xCA\t \n\n \n#define E752X_FERR_GLOBAL\t0x40\t \n#define E752X_NERR_GLOBAL\t0x44\t \n#define E752X_HI_FERR\t\t0x50\t \n#define E752X_HI_NERR\t\t0x52\t \n#define E752X_HI_ERRMASK\t0x54\t \n#define E752X_HI_SMICMD\t\t0x5A\t \n#define E752X_SYSBUS_FERR\t0x60\t \n#define E752X_SYSBUS_NERR\t0x62\t \n#define E752X_SYSBUS_ERRMASK\t0x64\t \n#define E752X_SYSBUS_SMICMD\t0x6A\t \n#define E752X_BUF_FERR\t\t0x70\t \n#define E752X_BUF_NERR\t\t0x72\t \n#define E752X_BUF_ERRMASK\t0x74\t \n#define E752X_BUF_SMICMD\t0x7A\t \n#define E752X_DRAM_FERR\t\t0x80\t \n#define E752X_DRAM_NERR\t\t0x82\t \n#define E752X_DRAM_ERRMASK\t0x84\t \n#define E752X_DRAM_SMICMD\t0x8A\t \n#define E752X_DRAM_RETR_ADD\t0xAC\t \n#define E752X_DRAM_SEC1_ADD\t0xA0\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define E752X_DRAM_SEC2_ADD\t0xC8\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define E752X_DRAM_DED_ADD\t0xA4\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define E752X_DRAM_SCRB_ADD\t0xA8\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define E752X_DRAM_SEC1_SYNDROME 0xC4\t \n\t\t\t\t\t \n#define E752X_DRAM_SEC2_SYNDROME 0xC6\t \n\t\t\t\t\t \n#define E752X_DEVPRES1\t\t0xF4\t \n\n \n#define I3100_NSI_FERR\t\t0x48\t \n#define I3100_NSI_NERR\t\t0x4C\t \n#define I3100_NSI_SMICMD\t0x54\t \n#define I3100_NSI_EMASK\t\t0x90\t \n\n \n#define ICH5R_PCI_STAT\t\t0x06\t \n#define ICH5R_PCI_2ND_STAT\t0x1E\t \n#define ICH5R_PCI_BRIDGE_CTL\t0x3E\t \n\nenum e752x_chips {\n\tE7520 = 0,\n\tE7525 = 1,\n\tE7320 = 2,\n\tI3100 = 3\n};\n\n \n\nstruct e752x_pvt {\n\tstruct pci_dev *dev_d0f0;\n\tstruct pci_dev *dev_d0f1;\n\tu32 tolm;\n\tu32 remapbase;\n\tu32 remaplimit;\n\tint mc_symmetric;\n\tu8 map[8];\n\tint map_type;\n\tconst struct e752x_dev_info *dev_info;\n};\n\nstruct e752x_dev_info {\n\tu16 err_dev;\n\tu16 ctl_dev;\n\tconst char *ctl_name;\n};\n\nstruct e752x_error_info {\n\tu32 ferr_global;\n\tu32 nerr_global;\n\tu32 nsi_ferr;\t \n\tu32 nsi_nerr;\t \n\tu8 hi_ferr;\t \n\tu8 hi_nerr;\t \n\tu16 sysbus_ferr;\n\tu16 sysbus_nerr;\n\tu8 buf_ferr;\n\tu8 buf_nerr;\n\tu16 dram_ferr;\n\tu16 dram_nerr;\n\tu32 dram_sec1_add;\n\tu32 dram_sec2_add;\n\tu16 dram_sec1_syndrome;\n\tu16 dram_sec2_syndrome;\n\tu32 dram_ded_add;\n\tu32 dram_scrb_add;\n\tu32 dram_retr_add;\n};\n\nstatic const struct e752x_dev_info e752x_devs[] = {\n\t[E7520] = {\n\t\t.err_dev = PCI_DEVICE_ID_INTEL_7520_1_ERR,\n\t\t.ctl_dev = PCI_DEVICE_ID_INTEL_7520_0,\n\t\t.ctl_name = \"E7520\"},\n\t[E7525] = {\n\t\t.err_dev = PCI_DEVICE_ID_INTEL_7525_1_ERR,\n\t\t.ctl_dev = PCI_DEVICE_ID_INTEL_7525_0,\n\t\t.ctl_name = \"E7525\"},\n\t[E7320] = {\n\t\t.err_dev = PCI_DEVICE_ID_INTEL_7320_1_ERR,\n\t\t.ctl_dev = PCI_DEVICE_ID_INTEL_7320_0,\n\t\t.ctl_name = \"E7320\"},\n\t[I3100] = {\n\t\t.err_dev = PCI_DEVICE_ID_INTEL_3100_1_ERR,\n\t\t.ctl_dev = PCI_DEVICE_ID_INTEL_3100_0,\n\t\t.ctl_name = \"3100\"},\n};\n\n \n\n#define SDRATE_EOT 0xFFFFFFFF\n\nstruct scrubrate {\n\tu32 bandwidth;\t \n\tu16 scrubval;\t \n};\n\n \nstatic const struct scrubrate scrubrates_e752x[] = {\n\t{0,\t\t0x00},\t \n\t{500000,\t0x02},\t \n\t{SDRATE_EOT,\t0x00}\t \n};\n\n \nstatic const struct scrubrate scrubrates_i3100[] = {\n\t{0,\t\t0x00},\t \n\t{500000,\t0x0a},\t \n\t{62500000,\t0x06},\t \n\t{SDRATE_EOT,\t0x00}\t \n};\n\nstatic unsigned long ctl_page_to_phys(struct mem_ctl_info *mci,\n\t\t\t\tunsigned long page)\n{\n\tu32 remap;\n\tstruct e752x_pvt *pvt = (struct e752x_pvt *)mci->pvt_info;\n\n\tedac_dbg(3, \"\\n\");\n\n\tif (page < pvt->tolm)\n\t\treturn page;\n\n\tif ((page >= 0x100000) && (page < pvt->remapbase))\n\t\treturn page;\n\n\tremap = (page - pvt->tolm) + pvt->remapbase;\n\n\tif (remap < pvt->remaplimit)\n\t\treturn remap;\n\n\te752x_printk(KERN_ERR, \"Invalid page %lx - out of range\\n\", page);\n\treturn pvt->tolm - 1;\n}\n\nstatic void do_process_ce(struct mem_ctl_info *mci, u16 error_one,\n\t\t\tu32 sec1_add, u16 sec1_syndrome)\n{\n\tu32 page;\n\tint row;\n\tint channel;\n\tint i;\n\tstruct e752x_pvt *pvt = (struct e752x_pvt *)mci->pvt_info;\n\n\tedac_dbg(3, \"\\n\");\n\n\t \n\tpage = sec1_add >> (PAGE_SHIFT - 4);\n\n\t \n\tif (pvt->mc_symmetric) {\n\t\t \n\t\trow = ((page >> 1) & 3);\n\t\te752x_printk(KERN_WARNING,\n\t\t\t\"Test row %d Table %d %d %d %d %d %d %d %d\\n\", row,\n\t\t\tpvt->map[0], pvt->map[1], pvt->map[2], pvt->map[3],\n\t\t\tpvt->map[4], pvt->map[5], pvt->map[6],\n\t\t\tpvt->map[7]);\n\n\t\t \n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (pvt->map[i] == row)\n\t\t\t\tbreak;\n\t\t}\n\n\t\te752x_printk(KERN_WARNING, \"Test computed row %d\\n\", i);\n\n\t\tif (i < 8)\n\t\t\trow = i;\n\t\telse\n\t\t\te752x_mc_printk(mci, KERN_WARNING,\n\t\t\t\t\t\"row %d not found in remap table\\n\",\n\t\t\t\t\trow);\n\t} else\n\t\trow = edac_mc_find_csrow_by_page(mci, page);\n\n\t \n\tchannel = !(error_one & 1);\n\n\t \n\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t     page, offset_in_page(sec1_add << 4), sec1_syndrome,\n\t\t\t     row, channel, -1,\n\t\t\t     \"e752x CE\", \"\");\n}\n\nstatic inline void process_ce(struct mem_ctl_info *mci, u16 error_one,\n\t\t\tu32 sec1_add, u16 sec1_syndrome, int *error_found,\n\t\t\tint handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\tdo_process_ce(mci, error_one, sec1_add, sec1_syndrome);\n}\n\nstatic void do_process_ue(struct mem_ctl_info *mci, u16 error_one,\n\t\t\tu32 ded_add, u32 scrb_add)\n{\n\tu32 error_2b, block_page;\n\tint row;\n\tstruct e752x_pvt *pvt = (struct e752x_pvt *)mci->pvt_info;\n\n\tedac_dbg(3, \"\\n\");\n\n\tif (error_one & 0x0202) {\n\t\terror_2b = ded_add;\n\n\t\t \n\t\tblock_page = error_2b >> (PAGE_SHIFT - 4);\n\n\t\trow = pvt->mc_symmetric ?\n\t\t \n\t\t\t((block_page >> 1) & 3) :\n\t\t\tedac_mc_find_csrow_by_page(mci, block_page);\n\n\t\t \n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\tblock_page,\n\t\t\t\t\toffset_in_page(error_2b << 4), 0,\n\t\t\t\t\t row, -1, -1,\n\t\t\t\t\t\"e752x UE from Read\", \"\");\n\n\t}\n\tif (error_one & 0x0404) {\n\t\terror_2b = scrb_add;\n\n\t\t \n\t\tblock_page = error_2b >> (PAGE_SHIFT - 4);\n\n\t\trow = pvt->mc_symmetric ?\n\t\t \n\t\t\t((block_page >> 1) & 3) :\n\t\t\tedac_mc_find_csrow_by_page(mci, block_page);\n\n\t\t \n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\tblock_page,\n\t\t\t\t\toffset_in_page(error_2b << 4), 0,\n\t\t\t\t\trow, -1, -1,\n\t\t\t\t\t\"e752x UE from Scruber\", \"\");\n\t}\n}\n\nstatic inline void process_ue(struct mem_ctl_info *mci, u16 error_one,\n\t\t\tu32 ded_add, u32 scrb_add, int *error_found,\n\t\t\tint handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\tdo_process_ue(mci, error_one, ded_add, scrb_add);\n}\n\nstatic inline void process_ue_no_info_wr(struct mem_ctl_info *mci,\n\t\t\t\t\t int *error_found, int handle_error)\n{\n\t*error_found = 1;\n\n\tif (!handle_error)\n\t\treturn;\n\n\tedac_dbg(3, \"\\n\");\n\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t     -1, -1, -1,\n\t\t\t     \"e752x UE log memory write\", \"\");\n}\n\nstatic void do_process_ded_retry(struct mem_ctl_info *mci, u16 error,\n\t\t\t\t u32 retry_add)\n{\n\tu32 error_1b, page;\n\tint row;\n\tstruct e752x_pvt *pvt = (struct e752x_pvt *)mci->pvt_info;\n\n\terror_1b = retry_add;\n\tpage = error_1b >> (PAGE_SHIFT - 4);   \n\n\t \n\trow = pvt->mc_symmetric ? ((page >> 1) & 3) :\n\t\tedac_mc_find_csrow_by_page(mci, page);\n\n\te752x_mc_printk(mci, KERN_WARNING,\n\t\t\t\"CE page 0x%lx, row %d : Memory read retry\\n\",\n\t\t\t(long unsigned int)page, row);\n}\n\nstatic inline void process_ded_retry(struct mem_ctl_info *mci, u16 error,\n\t\t\t\tu32 retry_add, int *error_found,\n\t\t\t\tint handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\tdo_process_ded_retry(mci, error, retry_add);\n}\n\nstatic inline void process_threshold_ce(struct mem_ctl_info *mci, u16 error,\n\t\t\t\t\tint *error_found, int handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\te752x_mc_printk(mci, KERN_WARNING, \"Memory threshold CE\\n\");\n}\n\nstatic char *global_message[11] = {\n\t\"PCI Express C1\",\n\t\"PCI Express C\",\n\t\"PCI Express B1\",\n\t\"PCI Express B\",\n\t\"PCI Express A1\",\n\t\"PCI Express A\",\n\t\"DMA Controller\",\n\t\"HUB or NS Interface\",\n\t\"System Bus\",\n\t\"DRAM Controller\",   \n\t\"Internal Buffer\"\n};\n\n#define DRAM_ENTRY\t9\n\nstatic char *fatal_message[2] = { \"Non-Fatal \", \"Fatal \" };\n\nstatic void do_global_error(int fatal, u32 errors)\n{\n\tint i;\n\n\tfor (i = 0; i < 11; i++) {\n\t\tif (errors & (1 << i)) {\n\t\t\t \n\t\t\tif ((i == DRAM_ENTRY) || report_non_memory_errors)\n\t\t\t\te752x_printk(KERN_WARNING, \"%sError %s\\n\",\n\t\t\t\t\tfatal_message[fatal],\n\t\t\t\t\tglobal_message[i]);\n\t\t}\n\t}\n}\n\nstatic inline void global_error(int fatal, u32 errors, int *error_found,\n\t\t\t\tint handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\tdo_global_error(fatal, errors);\n}\n\nstatic char *hub_message[7] = {\n\t\"HI Address or Command Parity\", \"HI Illegal Access\",\n\t\"HI Internal Parity\", \"Out of Range Access\",\n\t\"HI Data Parity\", \"Enhanced Config Access\",\n\t\"Hub Interface Target Abort\"\n};\n\nstatic void do_hub_error(int fatal, u8 errors)\n{\n\tint i;\n\n\tfor (i = 0; i < 7; i++) {\n\t\tif (errors & (1 << i))\n\t\t\te752x_printk(KERN_WARNING, \"%sError %s\\n\",\n\t\t\t\tfatal_message[fatal], hub_message[i]);\n\t}\n}\n\nstatic inline void hub_error(int fatal, u8 errors, int *error_found,\n\t\t\tint handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\tdo_hub_error(fatal, errors);\n}\n\n#define NSI_FATAL_MASK\t\t0x0c080081\n#define NSI_NON_FATAL_MASK\t0x23a0ba64\n#define NSI_ERR_MASK\t\t(NSI_FATAL_MASK | NSI_NON_FATAL_MASK)\n\nstatic char *nsi_message[30] = {\n\t\"NSI Link Down\",\t \n\t\"\",\t\t\t\t\t\t \n\t\"NSI Parity Error\",\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"Correctable Error Message\",\t\t\t \n\t\"Non-Fatal Error Message\",\t\t\t \n\t\"Fatal Error Message\",\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"Receiver Error\",\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"Bad TLP\",\t\t\t\t\t \n\t\"Bad DLLP\",\t\t\t\t\t \n\t\"REPLAY_NUM Rollover\",\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"Replay Timer Timeout\",\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"Data Link Protocol Error\",\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"Poisoned TLP\",\t\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"Completion Timeout\",\t\t\t\t \n\t\"Completer Abort\",\t\t\t\t \n\t\"Unexpected Completion\",\t\t\t \n\t\"Receiver Overflow\",\t\t\t\t \n\t\"Malformed TLP\",\t\t\t\t \n\t\"\",\t\t\t\t\t\t \n\t\"Unsupported Request\"\t\t\t\t \n};\n\nstatic void do_nsi_error(int fatal, u32 errors)\n{\n\tint i;\n\n\tfor (i = 0; i < 30; i++) {\n\t\tif (errors & (1 << i))\n\t\t\tprintk(KERN_WARNING \"%sError %s\\n\",\n\t\t\t       fatal_message[fatal], nsi_message[i]);\n\t}\n}\n\nstatic inline void nsi_error(int fatal, u32 errors, int *error_found,\n\t\tint handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\tdo_nsi_error(fatal, errors);\n}\n\nstatic char *membuf_message[4] = {\n\t\"Internal PMWB to DRAM parity\",\n\t\"Internal PMWB to System Bus Parity\",\n\t\"Internal System Bus or IO to PMWB Parity\",\n\t\"Internal DRAM to PMWB Parity\"\n};\n\nstatic void do_membuf_error(u8 errors)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (errors & (1 << i))\n\t\t\te752x_printk(KERN_WARNING, \"Non-Fatal Error %s\\n\",\n\t\t\t\tmembuf_message[i]);\n\t}\n}\n\nstatic inline void membuf_error(u8 errors, int *error_found, int handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\tdo_membuf_error(errors);\n}\n\nstatic char *sysbus_message[10] = {\n\t\"Addr or Request Parity\",\n\t\"Data Strobe Glitch\",\n\t\"Addr Strobe Glitch\",\n\t\"Data Parity\",\n\t\"Addr Above TOM\",\n\t\"Non DRAM Lock Error\",\n\t\"MCERR\", \"BINIT\",\n\t\"Memory Parity\",\n\t\"IO Subsystem Parity\"\n};\n\nstatic void do_sysbus_error(int fatal, u32 errors)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tif (errors & (1 << i))\n\t\t\te752x_printk(KERN_WARNING, \"%sError System Bus %s\\n\",\n\t\t\t\tfatal_message[fatal], sysbus_message[i]);\n\t}\n}\n\nstatic inline void sysbus_error(int fatal, u32 errors, int *error_found,\n\t\t\t\tint handle_error)\n{\n\t*error_found = 1;\n\n\tif (handle_error)\n\t\tdo_sysbus_error(fatal, errors);\n}\n\nstatic void e752x_check_hub_interface(struct e752x_error_info *info,\n\t\t\t\tint *error_found, int handle_error)\n{\n\tu8 stat8;\n\n\t\n\n\tstat8 = info->hi_ferr;\n\n\tif (stat8 & 0x7f) {\t \n\t\tstat8 &= 0x7f;\n\n\t\tif (stat8 & 0x2b)\n\t\t\thub_error(1, stat8 & 0x2b, error_found, handle_error);\n\n\t\tif (stat8 & 0x54)\n\t\t\thub_error(0, stat8 & 0x54, error_found, handle_error);\n\t}\n\t\n\n\tstat8 = info->hi_nerr;\n\n\tif (stat8 & 0x7f) {\t \n\t\tstat8 &= 0x7f;\n\n\t\tif (stat8 & 0x2b)\n\t\t\thub_error(1, stat8 & 0x2b, error_found, handle_error);\n\n\t\tif (stat8 & 0x54)\n\t\t\thub_error(0, stat8 & 0x54, error_found, handle_error);\n\t}\n}\n\nstatic void e752x_check_ns_interface(struct e752x_error_info *info,\n\t\t\t\tint *error_found, int handle_error)\n{\n\tu32 stat32;\n\n\tstat32 = info->nsi_ferr;\n\tif (stat32 & NSI_ERR_MASK) {  \n\t\tif (stat32 & NSI_FATAL_MASK)\t \n\t\t\tnsi_error(1, stat32 & NSI_FATAL_MASK, error_found,\n\t\t\t\t  handle_error);\n\t\tif (stat32 & NSI_NON_FATAL_MASK)  \n\t\t\tnsi_error(0, stat32 & NSI_NON_FATAL_MASK, error_found,\n\t\t\t\t  handle_error);\n\t}\n\tstat32 = info->nsi_nerr;\n\tif (stat32 & NSI_ERR_MASK) {\n\t\tif (stat32 & NSI_FATAL_MASK)\n\t\t\tnsi_error(1, stat32 & NSI_FATAL_MASK, error_found,\n\t\t\t\t  handle_error);\n\t\tif (stat32 & NSI_NON_FATAL_MASK)\n\t\t\tnsi_error(0, stat32 & NSI_NON_FATAL_MASK, error_found,\n\t\t\t\t  handle_error);\n\t}\n}\n\nstatic void e752x_check_sysbus(struct e752x_error_info *info,\n\t\t\tint *error_found, int handle_error)\n{\n\tu32 stat32, error32;\n\n\t\n\tstat32 = info->sysbus_ferr + (info->sysbus_nerr << 16);\n\n\tif (stat32 == 0)\n\t\treturn;\t\t \n\n\terror32 = (stat32 >> 16) & 0x3ff;\n\tstat32 = stat32 & 0x3ff;\n\n\tif (stat32 & 0x087)\n\t\tsysbus_error(1, stat32 & 0x087, error_found, handle_error);\n\n\tif (stat32 & 0x378)\n\t\tsysbus_error(0, stat32 & 0x378, error_found, handle_error);\n\n\tif (error32 & 0x087)\n\t\tsysbus_error(1, error32 & 0x087, error_found, handle_error);\n\n\tif (error32 & 0x378)\n\t\tsysbus_error(0, error32 & 0x378, error_found, handle_error);\n}\n\nstatic void e752x_check_membuf(struct e752x_error_info *info,\n\t\t\tint *error_found, int handle_error)\n{\n\tu8 stat8;\n\n\tstat8 = info->buf_ferr;\n\n\tif (stat8 & 0x0f) {\t \n\t\tstat8 &= 0x0f;\n\t\tmembuf_error(stat8, error_found, handle_error);\n\t}\n\n\tstat8 = info->buf_nerr;\n\n\tif (stat8 & 0x0f) {\t \n\t\tstat8 &= 0x0f;\n\t\tmembuf_error(stat8, error_found, handle_error);\n\t}\n}\n\nstatic void e752x_check_dram(struct mem_ctl_info *mci,\n\t\t\tstruct e752x_error_info *info, int *error_found,\n\t\t\tint handle_error)\n{\n\tu16 error_one, error_next;\n\n\terror_one = info->dram_ferr;\n\terror_next = info->dram_nerr;\n\n\t \n\tif (error_one & 0x0101)\t \n\t\tprocess_ce(mci, error_one, info->dram_sec1_add,\n\t\t\tinfo->dram_sec1_syndrome, error_found, handle_error);\n\n\tif (error_next & 0x0101)\t \n\t\tprocess_ce(mci, error_next, info->dram_sec2_add,\n\t\t\tinfo->dram_sec2_syndrome, error_found, handle_error);\n\n\tif (error_one & 0x4040)\n\t\tprocess_ue_no_info_wr(mci, error_found, handle_error);\n\n\tif (error_next & 0x4040)\n\t\tprocess_ue_no_info_wr(mci, error_found, handle_error);\n\n\tif (error_one & 0x2020)\n\t\tprocess_ded_retry(mci, error_one, info->dram_retr_add,\n\t\t\t\terror_found, handle_error);\n\n\tif (error_next & 0x2020)\n\t\tprocess_ded_retry(mci, error_next, info->dram_retr_add,\n\t\t\t\terror_found, handle_error);\n\n\tif (error_one & 0x0808)\n\t\tprocess_threshold_ce(mci, error_one, error_found, handle_error);\n\n\tif (error_next & 0x0808)\n\t\tprocess_threshold_ce(mci, error_next, error_found,\n\t\t\t\thandle_error);\n\n\tif (error_one & 0x0606)\n\t\tprocess_ue(mci, error_one, info->dram_ded_add,\n\t\t\tinfo->dram_scrb_add, error_found, handle_error);\n\n\tif (error_next & 0x0606)\n\t\tprocess_ue(mci, error_next, info->dram_ded_add,\n\t\t\tinfo->dram_scrb_add, error_found, handle_error);\n}\n\nstatic void e752x_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\t struct e752x_error_info *info)\n{\n\tstruct pci_dev *dev;\n\tstruct e752x_pvt *pvt;\n\n\tmemset(info, 0, sizeof(*info));\n\tpvt = (struct e752x_pvt *)mci->pvt_info;\n\tdev = pvt->dev_d0f1;\n\tpci_read_config_dword(dev, E752X_FERR_GLOBAL, &info->ferr_global);\n\n\tif (info->ferr_global) {\n\t\tif (pvt->dev_info->err_dev == PCI_DEVICE_ID_INTEL_3100_1_ERR) {\n\t\t\tpci_read_config_dword(dev, I3100_NSI_FERR,\n\t\t\t\t\t     &info->nsi_ferr);\n\t\t\tinfo->hi_ferr = 0;\n\t\t} else {\n\t\t\tpci_read_config_byte(dev, E752X_HI_FERR,\n\t\t\t\t\t     &info->hi_ferr);\n\t\t\tinfo->nsi_ferr = 0;\n\t\t}\n\t\tpci_read_config_word(dev, E752X_SYSBUS_FERR,\n\t\t\t\t&info->sysbus_ferr);\n\t\tpci_read_config_byte(dev, E752X_BUF_FERR, &info->buf_ferr);\n\t\tpci_read_config_word(dev, E752X_DRAM_FERR, &info->dram_ferr);\n\t\tpci_read_config_dword(dev, E752X_DRAM_SEC1_ADD,\n\t\t\t\t&info->dram_sec1_add);\n\t\tpci_read_config_word(dev, E752X_DRAM_SEC1_SYNDROME,\n\t\t\t\t&info->dram_sec1_syndrome);\n\t\tpci_read_config_dword(dev, E752X_DRAM_DED_ADD,\n\t\t\t\t&info->dram_ded_add);\n\t\tpci_read_config_dword(dev, E752X_DRAM_SCRB_ADD,\n\t\t\t\t&info->dram_scrb_add);\n\t\tpci_read_config_dword(dev, E752X_DRAM_RETR_ADD,\n\t\t\t\t&info->dram_retr_add);\n\n\t\t \n\t\tif (info->hi_ferr & 0x7f)\n\t\t\tpci_write_config_byte(dev, E752X_HI_FERR,\n\t\t\t\t\tinfo->hi_ferr);\n\n\t\tif (info->nsi_ferr & NSI_ERR_MASK)\n\t\t\tpci_write_config_dword(dev, I3100_NSI_FERR,\n\t\t\t\t\tinfo->nsi_ferr);\n\n\t\tif (info->sysbus_ferr)\n\t\t\tpci_write_config_word(dev, E752X_SYSBUS_FERR,\n\t\t\t\t\tinfo->sysbus_ferr);\n\n\t\tif (info->buf_ferr & 0x0f)\n\t\t\tpci_write_config_byte(dev, E752X_BUF_FERR,\n\t\t\t\t\tinfo->buf_ferr);\n\n\t\tif (info->dram_ferr)\n\t\t\tpci_write_bits16(pvt->dev_d0f1, E752X_DRAM_FERR,\n\t\t\t\t\t info->dram_ferr, info->dram_ferr);\n\n\t\tpci_write_config_dword(dev, E752X_FERR_GLOBAL,\n\t\t\t\tinfo->ferr_global);\n\t}\n\n\tpci_read_config_dword(dev, E752X_NERR_GLOBAL, &info->nerr_global);\n\n\tif (info->nerr_global) {\n\t\tif (pvt->dev_info->err_dev == PCI_DEVICE_ID_INTEL_3100_1_ERR) {\n\t\t\tpci_read_config_dword(dev, I3100_NSI_NERR,\n\t\t\t\t\t     &info->nsi_nerr);\n\t\t\tinfo->hi_nerr = 0;\n\t\t} else {\n\t\t\tpci_read_config_byte(dev, E752X_HI_NERR,\n\t\t\t\t\t     &info->hi_nerr);\n\t\t\tinfo->nsi_nerr = 0;\n\t\t}\n\t\tpci_read_config_word(dev, E752X_SYSBUS_NERR,\n\t\t\t\t&info->sysbus_nerr);\n\t\tpci_read_config_byte(dev, E752X_BUF_NERR, &info->buf_nerr);\n\t\tpci_read_config_word(dev, E752X_DRAM_NERR, &info->dram_nerr);\n\t\tpci_read_config_dword(dev, E752X_DRAM_SEC2_ADD,\n\t\t\t\t&info->dram_sec2_add);\n\t\tpci_read_config_word(dev, E752X_DRAM_SEC2_SYNDROME,\n\t\t\t\t&info->dram_sec2_syndrome);\n\n\t\tif (info->hi_nerr & 0x7f)\n\t\t\tpci_write_config_byte(dev, E752X_HI_NERR,\n\t\t\t\t\tinfo->hi_nerr);\n\n\t\tif (info->nsi_nerr & NSI_ERR_MASK)\n\t\t\tpci_write_config_dword(dev, I3100_NSI_NERR,\n\t\t\t\t\tinfo->nsi_nerr);\n\n\t\tif (info->sysbus_nerr)\n\t\t\tpci_write_config_word(dev, E752X_SYSBUS_NERR,\n\t\t\t\t\tinfo->sysbus_nerr);\n\n\t\tif (info->buf_nerr & 0x0f)\n\t\t\tpci_write_config_byte(dev, E752X_BUF_NERR,\n\t\t\t\t\tinfo->buf_nerr);\n\n\t\tif (info->dram_nerr)\n\t\t\tpci_write_bits16(pvt->dev_d0f1, E752X_DRAM_NERR,\n\t\t\t\t\t info->dram_nerr, info->dram_nerr);\n\n\t\tpci_write_config_dword(dev, E752X_NERR_GLOBAL,\n\t\t\t\tinfo->nerr_global);\n\t}\n}\n\nstatic int e752x_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct e752x_error_info *info,\n\t\t\t\tint handle_errors)\n{\n\tu32 error32, stat32;\n\tint error_found;\n\n\terror_found = 0;\n\terror32 = (info->ferr_global >> 18) & 0x3ff;\n\tstat32 = (info->ferr_global >> 4) & 0x7ff;\n\n\tif (error32)\n\t\tglobal_error(1, error32, &error_found, handle_errors);\n\n\tif (stat32)\n\t\tglobal_error(0, stat32, &error_found, handle_errors);\n\n\terror32 = (info->nerr_global >> 18) & 0x3ff;\n\tstat32 = (info->nerr_global >> 4) & 0x7ff;\n\n\tif (error32)\n\t\tglobal_error(1, error32, &error_found, handle_errors);\n\n\tif (stat32)\n\t\tglobal_error(0, stat32, &error_found, handle_errors);\n\n\te752x_check_hub_interface(info, &error_found, handle_errors);\n\te752x_check_ns_interface(info, &error_found, handle_errors);\n\te752x_check_sysbus(info, &error_found, handle_errors);\n\te752x_check_membuf(info, &error_found, handle_errors);\n\te752x_check_dram(mci, info, &error_found, handle_errors);\n\treturn error_found;\n}\n\nstatic void e752x_check(struct mem_ctl_info *mci)\n{\n\tstruct e752x_error_info info;\n\n\te752x_get_error_info(mci, &info);\n\te752x_process_error_info(mci, &info, 1);\n}\n\n \nstatic int set_sdram_scrub_rate(struct mem_ctl_info *mci, u32 new_bw)\n{\n\tconst struct scrubrate *scrubrates;\n\tstruct e752x_pvt *pvt = (struct e752x_pvt *) mci->pvt_info;\n\tstruct pci_dev *pdev = pvt->dev_d0f0;\n\tint i;\n\n\tif (pvt->dev_info->ctl_dev == PCI_DEVICE_ID_INTEL_3100_0)\n\t\tscrubrates = scrubrates_i3100;\n\telse\n\t\tscrubrates = scrubrates_e752x;\n\n\t \n\tfor (i = 0; scrubrates[i].bandwidth != SDRATE_EOT; i++)\n\t\tif (scrubrates[i].bandwidth >= new_bw)\n\t\t\tbreak;\n\n\tif (scrubrates[i].bandwidth == SDRATE_EOT)\n\t\treturn -1;\n\n\tpci_write_config_word(pdev, E752X_MCHSCRB, scrubrates[i].scrubval);\n\n\treturn scrubrates[i].bandwidth;\n}\n\n \nstatic int get_sdram_scrub_rate(struct mem_ctl_info *mci)\n{\n\tconst struct scrubrate *scrubrates;\n\tstruct e752x_pvt *pvt = (struct e752x_pvt *) mci->pvt_info;\n\tstruct pci_dev *pdev = pvt->dev_d0f0;\n\tu16 scrubval;\n\tint i;\n\n\tif (pvt->dev_info->ctl_dev == PCI_DEVICE_ID_INTEL_3100_0)\n\t\tscrubrates = scrubrates_i3100;\n\telse\n\t\tscrubrates = scrubrates_e752x;\n\n\t \n\tpci_read_config_word(pdev, E752X_MCHSCRB, &scrubval);\n\tscrubval = scrubval & 0x0f;\n\n\tfor (i = 0; scrubrates[i].bandwidth != SDRATE_EOT; i++)\n\t\tif (scrubrates[i].scrubval == scrubval)\n\t\t\tbreak;\n\n\tif (scrubrates[i].bandwidth == SDRATE_EOT) {\n\t\te752x_printk(KERN_WARNING,\n\t\t\t\"Invalid sdram scrub control value: 0x%x\\n\", scrubval);\n\t\treturn -1;\n\t}\n\treturn scrubrates[i].bandwidth;\n\n}\n\n \nstatic inline int dual_channel_active(u16 ddrcsr)\n{\n\treturn (((ddrcsr >> 12) & 3) == 3);\n}\n\n \nstatic inline int remap_csrow_index(struct mem_ctl_info *mci, int index)\n{\n\tstruct e752x_pvt *pvt = mci->pvt_info;\n\n\tif (!pvt->map_type)\n\t\treturn (7 - index);\n\n\treturn (index);\n}\n\nstatic void e752x_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\n\t\t\tu16 ddrcsr)\n{\n\tstruct csrow_info *csrow;\n\tenum edac_type edac_mode;\n\tunsigned long last_cumul_size;\n\tint index, mem_dev, drc_chan;\n\tint drc_drbg;\t\t \n\tint drc_ddim;\t\t \n\tu8 value;\n\tu32 dra, drc, cumul_size, i, nr_pages;\n\n\tdra = 0;\n\tfor (index = 0; index < 4; index++) {\n\t\tu8 dra_reg;\n\t\tpci_read_config_byte(pdev, E752X_DRA + index, &dra_reg);\n\t\tdra |= dra_reg << (index * 8);\n\t}\n\tpci_read_config_dword(pdev, E752X_DRC, &drc);\n\tdrc_chan = dual_channel_active(ddrcsr) ? 1 : 0;\n\tdrc_drbg = drc_chan + 1;\t \n\tdrc_ddim = (drc >> 20) & 0x3;\n\n\t \n\tfor (last_cumul_size = index = 0; index < mci->nr_csrows; index++) {\n\t\t \n\t\tmem_dev = (dra >> (index * 4 + 2)) & 0x3;\n\t\tcsrow = mci->csrows[remap_csrow_index(mci, index)];\n\n\t\tmem_dev = (mem_dev == 2);\n\t\tpci_read_config_byte(pdev, E752X_DRB + index, &value);\n\t\t \n\t\tcumul_size = value << (25 + drc_drbg - PAGE_SHIFT);\n\t\tedac_dbg(3, \"(%d) cumul_size 0x%x\\n\", index, cumul_size);\n\t\tif (cumul_size == last_cumul_size)\n\t\t\tcontinue;\t \n\n\t\tcsrow->first_page = last_cumul_size;\n\t\tcsrow->last_page = cumul_size - 1;\n\t\tnr_pages = cumul_size - last_cumul_size;\n\t\tlast_cumul_size = cumul_size;\n\n\t\t \n\t\tif (drc_ddim) {\n\t\t\tif (drc_chan && mem_dev) {\n\t\t\t\tedac_mode = EDAC_S4ECD4ED;\n\t\t\t\tmci->edac_cap |= EDAC_FLAG_S4ECD4ED;\n\t\t\t} else {\n\t\t\t\tedac_mode = EDAC_SECDED;\n\t\t\t\tmci->edac_cap |= EDAC_FLAG_SECDED;\n\t\t\t}\n\t\t} else\n\t\t\tedac_mode = EDAC_NONE;\n\t\tfor (i = 0; i < csrow->nr_channels; i++) {\n\t\t\tstruct dimm_info *dimm = csrow->channels[i]->dimm;\n\n\t\t\tedac_dbg(3, \"Initializing rank at (%i,%i)\\n\", index, i);\n\t\t\tdimm->nr_pages = nr_pages / csrow->nr_channels;\n\t\t\tdimm->grain = 1 << 12;\t \n\t\t\tdimm->mtype = MEM_RDDR;\t \n\t\t\tdimm->dtype = mem_dev ? DEV_X4 : DEV_X8;\n\t\t\tdimm->edac_mode = edac_mode;\n\t\t}\n\t}\n}\n\nstatic void e752x_init_mem_map_table(struct pci_dev *pdev,\n\t\t\t\tstruct e752x_pvt *pvt)\n{\n\tint index;\n\tu8 value, last, row;\n\n\tlast = 0;\n\trow = 0;\n\n\tfor (index = 0; index < 8; index += 2) {\n\t\tpci_read_config_byte(pdev, E752X_DRB + index, &value);\n\t\t \n\t\tif (value == last) {\n\t\t\t \n\t\t\tpvt->map[index] = 0xff;\n\t\t\tpvt->map[index + 1] = 0xff;\n\t\t} else {\t \n\t\t\tpvt->map[index] = row;\n\t\t\trow++;\n\t\t\tlast = value;\n\t\t\t \n\t\t\tpci_read_config_byte(pdev, E752X_DRB + index + 1,\n\t\t\t\t\t&value);\n\n\t\t\t \n\t\t\t \n\t\t\tpvt->map[index + 1] = (value == last) ? 0xff :\trow;\n\t\t\trow++;\n\t\t\tlast = value;\n\t\t}\n\t}\n}\n\n \nstatic int e752x_get_devs(struct pci_dev *pdev, int dev_idx,\n\t\t\tstruct e752x_pvt *pvt)\n{\n\tpvt->dev_d0f1 = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\tpvt->dev_info->err_dev, NULL);\n\n\tif (pvt->dev_d0f1 == NULL) {\n\t\tpvt->dev_d0f1 = pci_scan_single_device(pdev->bus,\n\t\t\t\t\t\t\tPCI_DEVFN(0, 1));\n\t\tpci_dev_get(pvt->dev_d0f1);\n\t}\n\n\tif (pvt->dev_d0f1 == NULL) {\n\t\te752x_printk(KERN_ERR, \"error reporting device not found:\"\n\t\t\t\"vendor %x device 0x%x (broken BIOS?)\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL, e752x_devs[dev_idx].err_dev);\n\t\treturn 1;\n\t}\n\n\tpvt->dev_d0f0 = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\te752x_devs[dev_idx].ctl_dev,\n\t\t\t\tNULL);\n\n\tif (pvt->dev_d0f0 == NULL)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tpci_dev_put(pvt->dev_d0f1);\n\treturn 1;\n}\n\n \nstatic void e752x_init_sysbus_parity_mask(struct e752x_pvt *pvt)\n{\n\tchar *cpu_id = cpu_data(0).x86_model_id;\n\tstruct pci_dev *dev = pvt->dev_d0f1;\n\tint enable = 1;\n\n\t \n\tif (sysbus_parity != -1) {\n\t\tenable = sysbus_parity;\n\t} else if (cpu_id[0] && !strstr(cpu_id, \"Xeon\")) {\n\t\te752x_printk(KERN_INFO, \"System Bus Parity not \"\n\t\t\t     \"supported by CPU, disabling\\n\");\n\t\tenable = 0;\n\t}\n\n\tif (enable)\n\t\tpci_write_config_word(dev, E752X_SYSBUS_ERRMASK, 0x0000);\n\telse\n\t\tpci_write_config_word(dev, E752X_SYSBUS_ERRMASK, 0x0309);\n}\n\nstatic void e752x_init_error_reporting_regs(struct e752x_pvt *pvt)\n{\n\tstruct pci_dev *dev;\n\n\tdev = pvt->dev_d0f1;\n\t \n\tif (pvt->dev_info->err_dev == PCI_DEVICE_ID_INTEL_3100_1_ERR) {\n\t\tpci_write_config_dword(dev, I3100_NSI_EMASK, 0);\n\t\tpci_write_config_dword(dev, I3100_NSI_SMICMD, 0);\n\t} else {\n\t\tpci_write_config_byte(dev, E752X_HI_ERRMASK, 0x00);\n\t\tpci_write_config_byte(dev, E752X_HI_SMICMD, 0x00);\n\t}\n\n\te752x_init_sysbus_parity_mask(pvt);\n\n\tpci_write_config_word(dev, E752X_SYSBUS_SMICMD, 0x00);\n\tpci_write_config_byte(dev, E752X_BUF_ERRMASK, 0x00);\n\tpci_write_config_byte(dev, E752X_BUF_SMICMD, 0x00);\n\tpci_write_config_byte(dev, E752X_DRAM_ERRMASK, 0x00);\n\tpci_write_config_byte(dev, E752X_DRAM_SMICMD, 0x00);\n}\n\nstatic int e752x_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tu16 pci_data;\n\tu8 stat8;\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tstruct e752x_pvt *pvt;\n\tu16 ddrcsr;\n\tint drc_chan;\t\t \n\tstruct e752x_error_info discard;\n\n\tedac_dbg(0, \"mci\\n\");\n\tedac_dbg(0, \"Starting Probe1\\n\");\n\n\t \n\tpci_read_config_byte(pdev, E752X_DEVPRES1, &stat8);\n\tif (!force_function_unhide && !(stat8 & (1 << 5))) {\n\t\tprintk(KERN_INFO \"Contact your BIOS vendor to see if the \"\n\t\t\t\"E752x error registers can be safely un-hidden\\n\");\n\t\treturn -ENODEV;\n\t}\n\tstat8 |= (1 << 5);\n\tpci_write_config_byte(pdev, E752X_DEVPRES1, stat8);\n\n\tpci_read_config_word(pdev, E752X_DDRCSR, &ddrcsr);\n\t \n\t \n\tdrc_chan = dual_channel_active(ddrcsr);\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = E752X_NR_CSROWS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = drc_chan + 1;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(3, \"init mci\\n\");\n\tmci->mtype_cap = MEM_FLAG_RDDR;\n\t \n\tmci->edac_ctl_cap = (dev_idx == I3100) ? EDAC_FLAG_SECDED :\n\t\t(EDAC_FLAG_NONE | EDAC_FLAG_SECDED | EDAC_FLAG_S4ECD4ED);\n\t \n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->pdev = &pdev->dev;\n\n\tedac_dbg(3, \"init pvt\\n\");\n\tpvt = (struct e752x_pvt *)mci->pvt_info;\n\tpvt->dev_info = &e752x_devs[dev_idx];\n\tpvt->mc_symmetric = ((ddrcsr & 0x10) != 0);\n\n\tif (e752x_get_devs(pdev, dev_idx, pvt)) {\n\t\tedac_mc_free(mci);\n\t\treturn -ENODEV;\n\t}\n\n\tedac_dbg(3, \"more mci init\\n\");\n\tmci->ctl_name = pvt->dev_info->ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = e752x_check;\n\tmci->ctl_page_to_phys = ctl_page_to_phys;\n\tmci->set_sdram_scrub_rate = set_sdram_scrub_rate;\n\tmci->get_sdram_scrub_rate = get_sdram_scrub_rate;\n\n\t \n\tpci_read_config_byte(pdev, E752X_DRM, &stat8);\n\tpvt->map_type = ((stat8 & 0x0f) > ((stat8 >> 4) & 0x0f));\n\n\te752x_init_csrows(mci, pdev, ddrcsr);\n\te752x_init_mem_map_table(pdev, pvt);\n\n\tif (dev_idx == I3100)\n\t\tmci->edac_cap = EDAC_FLAG_SECDED;  \n\telse\n\t\tmci->edac_cap |= EDAC_FLAG_NONE;\n\tedac_dbg(3, \"tolm, remapbase, remaplimit\\n\");\n\n\t \n\tpci_read_config_word(pdev, E752X_TOLM, &pci_data);\n\tpvt->tolm = ((u32) pci_data) << 4;\n\tpci_read_config_word(pdev, E752X_REMAPBASE, &pci_data);\n\tpvt->remapbase = ((u32) pci_data) << 14;\n\tpci_read_config_word(pdev, E752X_REMAPLIMIT, &pci_data);\n\tpvt->remaplimit = ((u32) pci_data) << 14;\n\te752x_printk(KERN_INFO,\n\t\t\t\"tolm = %x, remapbase = %x, remaplimit = %x\\n\",\n\t\t\tpvt->tolm, pvt->remapbase, pvt->remaplimit);\n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"failed edac_mc_add_mc()\\n\");\n\t\tgoto fail;\n\t}\n\n\te752x_init_error_reporting_regs(pvt);\n\te752x_get_error_info(mci, &discard);\t \n\n\t \n\te752x_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!e752x_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\", __func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\t \n\tedac_dbg(3, \"success\\n\");\n\treturn 0;\n\nfail:\n\tpci_dev_put(pvt->dev_d0f0);\n\tpci_dev_put(pvt->dev_d0f1);\n\tedac_mc_free(mci);\n\n\treturn -ENODEV;\n}\n\n \nstatic int e752x_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tif (pci_enable_device(pdev) < 0)\n\t\treturn -EIO;\n\n\treturn e752x_probe1(pdev, ent->driver_data);\n}\n\nstatic void e752x_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct e752x_pvt *pvt;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (e752x_pci)\n\t\tedac_pci_release_generic_ctl(e752x_pci);\n\n\tif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\n\t\treturn;\n\n\tpvt = (struct e752x_pvt *)mci->pvt_info;\n\tpci_dev_put(pvt->dev_d0f0);\n\tpci_dev_put(pvt->dev_d0f1);\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id e752x_pci_tbl[] = {\n\t{\n\t PCI_VEND_DEV(INTEL, 7520_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t E7520},\n\t{\n\t PCI_VEND_DEV(INTEL, 7525_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t E7525},\n\t{\n\t PCI_VEND_DEV(INTEL, 7320_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t E7320},\n\t{\n\t PCI_VEND_DEV(INTEL, 3100_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t I3100},\n\t{\n\t 0,\n\t }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, e752x_pci_tbl);\n\nstatic struct pci_driver e752x_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = e752x_init_one,\n\t.remove = e752x_remove_one,\n\t.id_table = e752x_pci_tbl,\n};\n\nstatic int __init e752x_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(3, \"\\n\");\n\n\t \n\topstate_init();\n\n\tpci_rc = pci_register_driver(&e752x_driver);\n\treturn (pci_rc < 0) ? pci_rc : 0;\n}\n\nstatic void __exit e752x_exit(void)\n{\n\tedac_dbg(3, \"\\n\");\n\tpci_unregister_driver(&e752x_driver);\n}\n\nmodule_init(e752x_init);\nmodule_exit(e752x_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Linux Networx (http://lnxi.com) Tom Zimmerman\");\nMODULE_DESCRIPTION(\"MC support for Intel e752x/3100 memory controllers\");\n\nmodule_param(force_function_unhide, int, 0444);\nMODULE_PARM_DESC(force_function_unhide, \"if BIOS sets Dev0:Fun1 up as hidden:\"\n\t\t \" 1=force unhide and hope BIOS doesn't fight driver for \"\n\t\t\"Dev0:Fun1 access\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n\nmodule_param(sysbus_parity, int, 0444);\nMODULE_PARM_DESC(sysbus_parity, \"0=disable system bus parity checking,\"\n\t\t\" 1=enable system bus parity checking, default=auto-detect\");\nmodule_param(report_non_memory_errors, int, 0644);\nMODULE_PARM_DESC(report_non_memory_errors, \"0=disable non-memory error \"\n\t\t\"reporting, 1=enable non-memory error reporting\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}