{
  "module_name": "octeon_edac-pc.c",
  "hash_id": "e7c31e5e9e7bd540e0a24ae9c69ee0a221bd5cea395879421dbadb1bd91bc2f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/octeon_edac-pc.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/edac.h>\n\n#include \"edac_module.h\"\n\n#include <asm/octeon/cvmx.h>\n#include <asm/mipsregs.h>\n\nextern int register_co_cache_error_notifier(struct notifier_block *nb);\nextern int unregister_co_cache_error_notifier(struct notifier_block *nb);\n\nextern unsigned long long cache_err_dcache[NR_CPUS];\n\nstruct co_cache_error {\n\tstruct notifier_block notifier;\n\tstruct edac_device_ctl_info *ed;\n};\n\n \nstatic int  co_cache_error_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct co_cache_error *p = container_of(this, struct co_cache_error,\n\t\t\t\t\t\tnotifier);\n\n\tunsigned int core = cvmx_get_core_num();\n\tunsigned int cpu = smp_processor_id();\n\tu64 icache_err = read_octeon_c0_icacheerr();\n\tu64 dcache_err;\n\n\tif (event) {\n\t\tdcache_err = cache_err_dcache[core];\n\t\tcache_err_dcache[core] = 0;\n\t} else {\n\t\tdcache_err = read_octeon_c0_dcacheerr();\n\t}\n\n\tif (icache_err & 1) {\n\t\tedac_device_printk(p->ed, KERN_ERR,\n\t\t\t\t   \"CacheErr (Icache):%llx, core %d/cpu %d, cp0_errorepc == %lx\\n\",\n\t\t\t\t   (unsigned long long)icache_err, core, cpu,\n\t\t\t\t   read_c0_errorepc());\n\t\twrite_octeon_c0_icacheerr(0);\n\t\tedac_device_handle_ce(p->ed, cpu, 1, \"icache\");\n\t}\n\tif (dcache_err & 1) {\n\t\tedac_device_printk(p->ed, KERN_ERR,\n\t\t\t\t   \"CacheErr (Dcache):%llx, core %d/cpu %d, cp0_errorepc == %lx\\n\",\n\t\t\t\t   (unsigned long long)dcache_err, core, cpu,\n\t\t\t\t   read_c0_errorepc());\n\t\tif (event)\n\t\t\tedac_device_handle_ue(p->ed, cpu, 0, \"dcache\");\n\t\telse\n\t\t\tedac_device_handle_ce(p->ed, cpu, 0, \"dcache\");\n\n\t\t \n\t\tif (OCTEON_IS_OCTEON2())\n\t\t\twrite_octeon_c0_dcacheerr(1);\n\t\telse\n\t\t\twrite_octeon_c0_dcacheerr(0);\n\t}\n\n\treturn NOTIFY_STOP;\n}\n\nstatic int co_cache_error_probe(struct platform_device *pdev)\n{\n\tstruct co_cache_error *p = devm_kzalloc(&pdev->dev, sizeof(*p),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->notifier.notifier_call = co_cache_error_event;\n\tplatform_set_drvdata(pdev, p);\n\n\tp->ed = edac_device_alloc_ctl_info(0, \"cpu\", num_possible_cpus(),\n\t\t\t\t\t   \"cache\", 2, 0, NULL, 0,\n\t\t\t\t\t   edac_device_alloc_index());\n\tif (!p->ed)\n\t\tgoto err;\n\n\tp->ed->dev = &pdev->dev;\n\n\tp->ed->dev_name = dev_name(&pdev->dev);\n\n\tp->ed->mod_name = \"octeon-cpu\";\n\tp->ed->ctl_name = \"cache\";\n\n\tif (edac_device_add_device(p->ed)) {\n\t\tpr_err(\"%s: edac_device_add_device() failed\\n\", __func__);\n\t\tgoto err1;\n\t}\n\n\tregister_co_cache_error_notifier(&p->notifier);\n\n\treturn 0;\n\nerr1:\n\tedac_device_free_ctl_info(p->ed);\nerr:\n\treturn -ENXIO;\n}\n\nstatic int co_cache_error_remove(struct platform_device *pdev)\n{\n\tstruct co_cache_error *p = platform_get_drvdata(pdev);\n\n\tunregister_co_cache_error_notifier(&p->notifier);\n\tedac_device_del_device(&pdev->dev);\n\tedac_device_free_ctl_info(p->ed);\n\treturn 0;\n}\n\nstatic struct platform_driver co_cache_error_driver = {\n\t.probe = co_cache_error_probe,\n\t.remove = co_cache_error_remove,\n\t.driver = {\n\t\t   .name = \"octeon_pc_edac\",\n\t}\n};\nmodule_platform_driver(co_cache_error_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ralf Baechle <ralf@linux-mips.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}