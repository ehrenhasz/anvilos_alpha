{
  "module_name": "zynqmp_edac.c",
  "hash_id": "30caa3a147295bb5c26c553cababeb96c94041c8034d128bbc6c6e85d1625afc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/zynqmp_edac.c",
  "human_readable_source": "\n \n\n#include <linux/edac.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n#include \"edac_module.h\"\n\n#define ZYNQMP_OCM_EDAC_MSG_SIZE\t256\n\n#define ZYNQMP_OCM_EDAC_STRING\t\"zynqmp_ocm\"\n\n \n#define ERR_CTRL_OFST\t\t0x0\n#define OCM_ISR_OFST\t\t0x04\n#define OCM_IMR_OFST\t\t0x08\n#define OCM_IEN_OFST\t\t0x0C\n#define OCM_IDS_OFST\t\t0x10\n\n \n#define ECC_CTRL_OFST\t\t0x14\n\n \n#define CE_FFA_OFST\t\t0x1C\n#define CE_FFD0_OFST\t\t0x20\n#define CE_FFD1_OFST\t\t0x24\n#define CE_FFD2_OFST\t\t0x28\n#define CE_FFD3_OFST\t\t0x2C\n#define CE_FFE_OFST\t\t0x30\n\n \n#define UE_FFA_OFST\t\t0x34\n#define UE_FFD0_OFST\t\t0x38\n#define UE_FFD1_OFST\t\t0x3C\n#define UE_FFD2_OFST\t\t0x40\n#define UE_FFD3_OFST\t\t0x44\n#define UE_FFE_OFST\t\t0x48\n\n \n#define ECC_CTRL_CLR_CE_ERR\t0x40\n#define ECC_CTRL_CLR_UE_ERR\t0x80\n\n \n#define OCM_FID0_OFST\t\t0x4C\n#define OCM_FID1_OFST\t\t0x50\n#define OCM_FID2_OFST\t\t0x54\n#define OCM_FID3_OFST\t\t0x58\n#define OCM_FIC_OFST\t\t0x74\n\n#define UE_MAX_BITPOS_LOWER\t31\n#define UE_MIN_BITPOS_UPPER\t32\n#define UE_MAX_BITPOS_UPPER\t63\n\n \n#define OCM_CEINTR_MASK\t\tBIT(6)\n#define OCM_UEINTR_MASK\t\tBIT(7)\n#define OCM_ECC_ENABLE_MASK\tBIT(0)\n\n#define OCM_FICOUNT_MASK\tGENMASK(23, 0)\n#define OCM_NUM_UE_BITPOS\t2\n#define OCM_BASEVAL\t\t0xFFFC0000\n#define EDAC_DEVICE\t\t\"ZynqMP-OCM\"\n\n \nstruct ecc_error_info {\n\tu32 addr;\n\tu32 fault_lo;\n\tu32 fault_hi;\n};\n\n \nstruct ecc_status {\n\tu32 ce_cnt;\n\tu32 ue_cnt;\n\tstruct ecc_error_info ceinfo;\n\tstruct ecc_error_info ueinfo;\n};\n\n \nstruct edac_priv {\n\tvoid __iomem *baseaddr;\n\tchar message[ZYNQMP_OCM_EDAC_MSG_SIZE];\n\tstruct ecc_status stat;\n\tu32 ce_cnt;\n\tu32 ue_cnt;\n#ifdef CONFIG_EDAC_DEBUG\n\tstruct dentry *debugfs_dir;\n\tu8 ce_bitpos;\n\tu8 ue_bitpos[OCM_NUM_UE_BITPOS];\n\tu32 fault_injection_cnt;\n#endif\n};\n\n \nstatic void get_error_info(void __iomem *base, struct ecc_status *p, int mask)\n{\n\tif (mask & OCM_CEINTR_MASK) {\n\t\tp->ce_cnt++;\n\t\tp->ceinfo.fault_lo = readl(base + CE_FFD0_OFST);\n\t\tp->ceinfo.fault_hi = readl(base + CE_FFD1_OFST);\n\t\tp->ceinfo.addr = (OCM_BASEVAL | readl(base + CE_FFA_OFST));\n\t\twritel(ECC_CTRL_CLR_CE_ERR, base + OCM_ISR_OFST);\n\t} else if (mask & OCM_UEINTR_MASK) {\n\t\tp->ue_cnt++;\n\t\tp->ueinfo.fault_lo = readl(base + UE_FFD0_OFST);\n\t\tp->ueinfo.fault_hi = readl(base + UE_FFD1_OFST);\n\t\tp->ueinfo.addr = (OCM_BASEVAL | readl(base + UE_FFA_OFST));\n\t\twritel(ECC_CTRL_CLR_UE_ERR, base + OCM_ISR_OFST);\n\t}\n}\n\n \nstatic void handle_error(struct edac_device_ctl_info *dci, struct ecc_status *p)\n{\n\tstruct edac_priv *priv = dci->pvt_info;\n\tstruct ecc_error_info *pinf;\n\n\tif (p->ce_cnt) {\n\t\tpinf = &p->ceinfo;\n\t\tsnprintf(priv->message, ZYNQMP_OCM_EDAC_MSG_SIZE,\n\t\t\t \"\\nOCM ECC error type :%s\\nAddr: [0x%x]\\nFault Data[0x%08x%08x]\",\n\t\t\t \"CE\", pinf->addr, pinf->fault_hi, pinf->fault_lo);\n\t\tedac_device_handle_ce(dci, 0, 0, priv->message);\n\t}\n\n\tif (p->ue_cnt) {\n\t\tpinf = &p->ueinfo;\n\t\tsnprintf(priv->message, ZYNQMP_OCM_EDAC_MSG_SIZE,\n\t\t\t \"\\nOCM ECC error type :%s\\nAddr: [0x%x]\\nFault Data[0x%08x%08x]\",\n\t\t\t \"UE\", pinf->addr, pinf->fault_hi, pinf->fault_lo);\n\t\tedac_device_handle_ue(dci, 0, 0, priv->message);\n\t}\n\n\tmemset(p, 0, sizeof(*p));\n}\n\n \nstatic irqreturn_t intr_handler(int irq, void *dev_id)\n{\n\tstruct edac_device_ctl_info *dci = dev_id;\n\tstruct edac_priv *priv = dci->pvt_info;\n\tint regval;\n\n\tregval = readl(priv->baseaddr + OCM_ISR_OFST);\n\tif (!(regval & (OCM_CEINTR_MASK | OCM_UEINTR_MASK))) {\n\t\tWARN_ONCE(1, \"Unhandled IRQ%d, ISR: 0x%x\", irq, regval);\n\t\treturn IRQ_NONE;\n\t}\n\n\tget_error_info(priv->baseaddr, &priv->stat, regval);\n\n\tpriv->ce_cnt += priv->stat.ce_cnt;\n\tpriv->ue_cnt += priv->stat.ue_cnt;\n\thandle_error(dci, &priv->stat);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic bool get_eccstate(void __iomem *base)\n{\n\treturn readl(base + ECC_CTRL_OFST) & OCM_ECC_ENABLE_MASK;\n}\n\n#ifdef CONFIG_EDAC_DEBUG\n \nstatic void write_fault_count(struct edac_priv *priv)\n{\n\tu32 ficount = priv->fault_injection_cnt;\n\n\tif (ficount & ~OCM_FICOUNT_MASK) {\n\t\tficount &= OCM_FICOUNT_MASK;\n\t\tedac_printk(KERN_INFO, EDAC_DEVICE,\n\t\t\t    \"Fault injection count value truncated to %d\\n\", ficount);\n\t}\n\n\twritel(ficount, priv->baseaddr + OCM_FIC_OFST);\n}\n\n \nstatic ssize_t inject_ce_write(struct file *file, const char __user *data,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dev = file->private_data;\n\tstruct edac_priv *priv = edac_dev->pvt_info;\n\tint ret;\n\n\tif (!data)\n\t\treturn -EFAULT;\n\n\tret = kstrtou8_from_user(data, count, 0, &priv->ce_bitpos);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->ce_bitpos > UE_MAX_BITPOS_UPPER)\n\t\treturn -EINVAL;\n\n\tif (priv->ce_bitpos <= UE_MAX_BITPOS_LOWER) {\n\t\twritel(BIT(priv->ce_bitpos), priv->baseaddr + OCM_FID0_OFST);\n\t\twritel(0, priv->baseaddr + OCM_FID1_OFST);\n\t} else {\n\t\twritel(BIT(priv->ce_bitpos - UE_MIN_BITPOS_UPPER),\n\t\t       priv->baseaddr + OCM_FID1_OFST);\n\t\twritel(0, priv->baseaddr + OCM_FID0_OFST);\n\t}\n\n\twrite_fault_count(priv);\n\n\treturn count;\n}\n\nstatic const struct file_operations inject_ce_fops = {\n\t.open = simple_open,\n\t.write = inject_ce_write,\n\t.llseek = generic_file_llseek,\n};\n\n \nstatic ssize_t inject_ue_write(struct file *file, const char __user *data,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dev = file->private_data;\n\tstruct edac_priv *priv = edac_dev->pvt_info;\n\tchar buf[6], *pbuf, *token[2];\n\tu64 ue_bitpos;\n\tint i, ret;\n\tu8 len;\n\n\tif (!data)\n\t\treturn -EFAULT;\n\n\tlen = min_t(size_t, count, sizeof(buf));\n\tif (copy_from_user(buf, data, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tpbuf = &buf[0];\n\tfor (i = 0; i < OCM_NUM_UE_BITPOS; i++)\n\t\ttoken[i] = strsep(&pbuf, \",\");\n\n\tret = kstrtou8(token[0], 0, &priv->ue_bitpos[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kstrtou8(token[1], 0, &priv->ue_bitpos[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->ue_bitpos[0] > UE_MAX_BITPOS_UPPER ||\n\t    priv->ue_bitpos[1] > UE_MAX_BITPOS_UPPER)\n\t\treturn -EINVAL;\n\n\tif (priv->ue_bitpos[0] == priv->ue_bitpos[1]) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"Bit positions should not be equal\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tue_bitpos = BIT(priv->ue_bitpos[0]) | BIT(priv->ue_bitpos[1]);\n\n\twritel((u32)ue_bitpos, priv->baseaddr + OCM_FID0_OFST);\n\twritel((u32)(ue_bitpos >> 32), priv->baseaddr + OCM_FID1_OFST);\n\n\twrite_fault_count(priv);\n\n\treturn count;\n}\n\nstatic const struct file_operations inject_ue_fops = {\n\t.open = simple_open,\n\t.write = inject_ue_write,\n\t.llseek = generic_file_llseek,\n};\n\nstatic void setup_debugfs(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct edac_priv *priv = edac_dev->pvt_info;\n\n\tpriv->debugfs_dir = edac_debugfs_create_dir(\"ocm\");\n\tif (!priv->debugfs_dir)\n\t\treturn;\n\n\tedac_debugfs_create_x32(\"inject_fault_count\", 0644, priv->debugfs_dir,\n\t\t\t\t&priv->fault_injection_cnt);\n\tedac_debugfs_create_file(\"inject_ue_bitpos\", 0644, priv->debugfs_dir,\n\t\t\t\t edac_dev, &inject_ue_fops);\n\tedac_debugfs_create_file(\"inject_ce_bitpos\", 0644, priv->debugfs_dir,\n\t\t\t\t edac_dev, &inject_ce_fops);\n}\n#endif\n\nstatic int edac_probe(struct platform_device *pdev)\n{\n\tstruct edac_device_ctl_info *dci;\n\tstruct edac_priv *priv;\n\tvoid __iomem *baseaddr;\n\tstruct resource *res;\n\tint irq, ret;\n\n\tbaseaddr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(baseaddr))\n\t\treturn PTR_ERR(baseaddr);\n\n\tif (!get_eccstate(baseaddr)) {\n\t\tedac_printk(KERN_INFO, EDAC_DEVICE, \"ECC not enabled\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tdci = edac_device_alloc_ctl_info(sizeof(*priv), ZYNQMP_OCM_EDAC_STRING,\n\t\t\t\t\t 1, ZYNQMP_OCM_EDAC_STRING, 1, 0, NULL, 0,\n\t\t\t\t\t edac_device_alloc_index());\n\tif (!dci)\n\t\treturn -ENOMEM;\n\n\tpriv = dci->pvt_info;\n\tplatform_set_drvdata(pdev, dci);\n\tdci->dev = &pdev->dev;\n\tpriv->baseaddr = baseaddr;\n\tdci->mod_name = pdev->dev.driver->name;\n\tdci->ctl_name = ZYNQMP_OCM_EDAC_STRING;\n\tdci->dev_name = dev_name(&pdev->dev);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto free_dev_ctl;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, intr_handler, 0,\n\t\t\t       dev_name(&pdev->dev), dci);\n\tif (ret) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"Failed to request Irq\\n\");\n\t\tgoto free_dev_ctl;\n\t}\n\n\t \n\twritel((OCM_CEINTR_MASK | OCM_UEINTR_MASK), priv->baseaddr + OCM_IEN_OFST);\n\n#ifdef CONFIG_EDAC_DEBUG\n\tsetup_debugfs(dci);\n#endif\n\n\tret = edac_device_add_device(dci);\n\tif (ret)\n\t\tgoto free_dev_ctl;\n\n\treturn 0;\n\nfree_dev_ctl:\n\tedac_device_free_ctl_info(dci);\n\n\treturn ret;\n}\n\nstatic int edac_remove(struct platform_device *pdev)\n{\n\tstruct edac_device_ctl_info *dci = platform_get_drvdata(pdev);\n\tstruct edac_priv *priv = dci->pvt_info;\n\n\t \n\twritel((OCM_CEINTR_MASK | OCM_UEINTR_MASK), priv->baseaddr + OCM_IDS_OFST);\n\n#ifdef CONFIG_EDAC_DEBUG\n\tdebugfs_remove_recursive(priv->debugfs_dir);\n#endif\n\n\tedac_device_del_device(&pdev->dev);\n\tedac_device_free_ctl_info(dci);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id zynqmp_ocm_edac_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-ocmc-1.0\"},\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, zynqmp_ocm_edac_match);\n\nstatic struct platform_driver zynqmp_ocm_edac_driver = {\n\t.driver = {\n\t\t   .name = \"zynqmp-ocm-edac\",\n\t\t   .of_match_table = zynqmp_ocm_edac_match,\n\t\t   },\n\t.probe = edac_probe,\n\t.remove = edac_remove,\n};\n\nmodule_platform_driver(zynqmp_ocm_edac_driver);\n\nMODULE_AUTHOR(\"Advanced Micro Devices, Inc\");\nMODULE_DESCRIPTION(\"Xilinx ZynqMP OCM ECC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}