{
  "module_name": "dmc520_edac.c",
  "hash_id": "b66e7a1a9703da5096470f6365ef8219cc57a7e0411166f81f815b4fa7b55a54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/dmc520_edac.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/edac.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include \"edac_mc.h\"\n\n \n#define REG_OFFSET_FEATURE_CONFIG\t\t\t0x130\n#define REG_OFFSET_ECC_ERRC_COUNT_31_00\t\t0x158\n#define REG_OFFSET_ECC_ERRC_COUNT_63_32\t\t0x15C\n#define REG_OFFSET_ECC_ERRD_COUNT_31_00\t\t0x160\n#define REG_OFFSET_ECC_ERRD_COUNT_63_32\t\t0x164\n#define REG_OFFSET_INTERRUPT_CONTROL\t\t\t0x500\n#define REG_OFFSET_INTERRUPT_CLR\t\t\t0x508\n#define REG_OFFSET_INTERRUPT_STATUS\t\t\t0x510\n#define REG_OFFSET_DRAM_ECC_ERRC_INT_INFO_31_00\t0x528\n#define REG_OFFSET_DRAM_ECC_ERRC_INT_INFO_63_32\t0x52C\n#define REG_OFFSET_DRAM_ECC_ERRD_INT_INFO_31_00\t0x530\n#define REG_OFFSET_DRAM_ECC_ERRD_INT_INFO_63_32\t0x534\n#define REG_OFFSET_ADDRESS_CONTROL_NOW\t\t\t0x1010\n#define REG_OFFSET_MEMORY_TYPE_NOW\t\t\t0x1128\n#define REG_OFFSET_SCRUB_CONTROL0_NOW\t\t\t0x1170\n#define REG_OFFSET_FORMAT_CONTROL\t\t\t0x18\n\n \n#define RAM_ECC_INT_CE_BIT\t\t\tBIT(0)\n#define RAM_ECC_INT_UE_BIT\t\t\tBIT(1)\n#define DRAM_ECC_INT_CE_BIT\t\t\tBIT(2)\n#define DRAM_ECC_INT_UE_BIT\t\t\tBIT(3)\n#define FAILED_ACCESS_INT_BIT\t\t\tBIT(4)\n#define FAILED_PROG_INT_BIT\t\t\tBIT(5)\n#define LINK_ERR_INT_BIT\t\t\tBIT(6)\n#define TEMPERATURE_EVENT_INT_BIT\t\tBIT(7)\n#define ARCH_FSM_INT_BIT\t\t\tBIT(8)\n#define PHY_REQUEST_INT_BIT\t\t\tBIT(9)\n#define MEMORY_WIDTH_MASK\t\t\tGENMASK(1, 0)\n#define SCRUB_TRIGGER0_NEXT_MASK\t\tGENMASK(1, 0)\n#define REG_FIELD_DRAM_ECC_ENABLED\t\tGENMASK(1, 0)\n#define REG_FIELD_MEMORY_TYPE\t\t\tGENMASK(2, 0)\n#define REG_FIELD_DEVICE_WIDTH\t\t\tGENMASK(9, 8)\n#define REG_FIELD_ADDRESS_CONTROL_COL\t\tGENMASK(2,  0)\n#define REG_FIELD_ADDRESS_CONTROL_ROW\t\tGENMASK(10, 8)\n#define REG_FIELD_ADDRESS_CONTROL_BANK\t\tGENMASK(18, 16)\n#define REG_FIELD_ADDRESS_CONTROL_RANK\t\tGENMASK(25, 24)\n#define REG_FIELD_ERR_INFO_LOW_VALID\t\tBIT(0)\n#define REG_FIELD_ERR_INFO_LOW_COL\t\tGENMASK(10, 1)\n#define REG_FIELD_ERR_INFO_LOW_ROW\t\tGENMASK(28, 11)\n#define REG_FIELD_ERR_INFO_LOW_RANK\t\tGENMASK(31, 29)\n#define REG_FIELD_ERR_INFO_HIGH_BANK\t\tGENMASK(3, 0)\n#define REG_FIELD_ERR_INFO_HIGH_VALID\t\tBIT(31)\n\n#define DRAM_ADDRESS_CONTROL_MIN_COL_BITS\t8\n#define DRAM_ADDRESS_CONTROL_MIN_ROW_BITS\t11\n\n#define DMC520_SCRUB_TRIGGER_ERR_DETECT\t2\n#define DMC520_SCRUB_TRIGGER_IDLE\t\t3\n\n \n \n#define DMC520_MSG_BUF_SIZE\t\t\t40\n#define EDAC_MOD_NAME\t\t\t\t\"dmc520-edac\"\n#define EDAC_CTL_NAME\t\t\t\t\"dmc520\"\n\n \nenum dmc520_mem_width {\n\tMEM_WIDTH_X32 = 2,\n\tMEM_WIDTH_X64 = 3\n};\n\n \nenum dmc520_mem_type {\n\tMEM_TYPE_DDR3 = 1,\n\tMEM_TYPE_DDR4 = 2\n};\n\n \nenum dmc520_dev_width {\n\tDEV_WIDTH_X4 = 0,\n\tDEV_WIDTH_X8 = 1,\n\tDEV_WIDTH_X16 = 2\n};\n\nstruct ecc_error_info {\n\tu32 col;\n\tu32 row;\n\tu32 bank;\n\tu32 rank;\n};\n\n \nstruct dmc520_irq_config {\n\tchar *name;\n\tint mask;\n};\n\n \nstatic struct dmc520_irq_config dmc520_irq_configs[] = {\n\t{\n\t\t.name = \"ram_ecc_errc\",\n\t\t.mask = RAM_ECC_INT_CE_BIT\n\t},\n\t{\n\t\t.name = \"ram_ecc_errd\",\n\t\t.mask = RAM_ECC_INT_UE_BIT\n\t},\n\t{\n\t\t.name = \"dram_ecc_errc\",\n\t\t.mask = DRAM_ECC_INT_CE_BIT\n\t},\n\t{\n\t\t.name = \"dram_ecc_errd\",\n\t\t.mask = DRAM_ECC_INT_UE_BIT\n\t},\n\t{\n\t\t.name = \"failed_access\",\n\t\t.mask = FAILED_ACCESS_INT_BIT\n\t},\n\t{\n\t\t.name = \"failed_prog\",\n\t\t.mask = FAILED_PROG_INT_BIT\n\t},\n\t{\n\t\t.name = \"link_err\",\n\t\t.mask = LINK_ERR_INT_BIT\n\t},\n\t{\n\t\t.name = \"temperature_event\",\n\t\t.mask = TEMPERATURE_EVENT_INT_BIT\n\t},\n\t{\n\t\t.name = \"arch_fsm\",\n\t\t.mask = ARCH_FSM_INT_BIT\n\t},\n\t{\n\t\t.name = \"phy_request\",\n\t\t.mask = PHY_REQUEST_INT_BIT\n\t}\n};\n\n#define NUMBER_OF_IRQS\t\t\t\tARRAY_SIZE(dmc520_irq_configs)\n\n \nstruct dmc520_edac {\n\tvoid __iomem *reg_base;\n\tspinlock_t error_lock;\n\tu32 mem_width_in_bytes;\n\tint irqs[NUMBER_OF_IRQS];\n\tint masks[NUMBER_OF_IRQS];\n};\n\nstatic int dmc520_mc_idx;\n\nstatic u32 dmc520_read_reg(struct dmc520_edac *pvt, u32 offset)\n{\n\treturn readl(pvt->reg_base + offset);\n}\n\nstatic void dmc520_write_reg(struct dmc520_edac *pvt, u32 val, u32 offset)\n{\n\twritel(val, pvt->reg_base + offset);\n}\n\nstatic u32 dmc520_calc_dram_ecc_error(u32 value)\n{\n\tu32 total = 0;\n\n\t \n\twhile (value > 0) {\n\t\ttotal += (value & 0xFF);\n\t\tvalue >>= 8;\n\t}\n\treturn total;\n}\n\nstatic u32 dmc520_get_dram_ecc_error_count(struct dmc520_edac *pvt,\n\t\t\t\t\t    bool is_ce)\n{\n\tu32 reg_offset_low, reg_offset_high;\n\tu32 err_low, err_high;\n\tu32 err_count;\n\n\treg_offset_low = is_ce ? REG_OFFSET_ECC_ERRC_COUNT_31_00 :\n\t\t\t\t REG_OFFSET_ECC_ERRD_COUNT_31_00;\n\treg_offset_high = is_ce ? REG_OFFSET_ECC_ERRC_COUNT_63_32 :\n\t\t\t\t  REG_OFFSET_ECC_ERRD_COUNT_63_32;\n\n\terr_low = dmc520_read_reg(pvt, reg_offset_low);\n\terr_high = dmc520_read_reg(pvt, reg_offset_high);\n\t \n\tdmc520_write_reg(pvt, 0, reg_offset_low);\n\tdmc520_write_reg(pvt, 0, reg_offset_high);\n\n\terr_count = dmc520_calc_dram_ecc_error(err_low) +\n\t\t   dmc520_calc_dram_ecc_error(err_high);\n\n\treturn err_count;\n}\n\nstatic void dmc520_get_dram_ecc_error_info(struct dmc520_edac *pvt,\n\t\t\t\t\t    bool is_ce,\n\t\t\t\t\t    struct ecc_error_info *info)\n{\n\tu32 reg_offset_low, reg_offset_high;\n\tu32 reg_val_low, reg_val_high;\n\tbool valid;\n\n\treg_offset_low = is_ce ? REG_OFFSET_DRAM_ECC_ERRC_INT_INFO_31_00 :\n\t\t\t\t REG_OFFSET_DRAM_ECC_ERRD_INT_INFO_31_00;\n\treg_offset_high = is_ce ? REG_OFFSET_DRAM_ECC_ERRC_INT_INFO_63_32 :\n\t\t\t\t  REG_OFFSET_DRAM_ECC_ERRD_INT_INFO_63_32;\n\n\treg_val_low = dmc520_read_reg(pvt, reg_offset_low);\n\treg_val_high = dmc520_read_reg(pvt, reg_offset_high);\n\n\tvalid = (FIELD_GET(REG_FIELD_ERR_INFO_LOW_VALID, reg_val_low) != 0) &&\n\t\t(FIELD_GET(REG_FIELD_ERR_INFO_HIGH_VALID, reg_val_high) != 0);\n\n\tif (valid) {\n\t\tinfo->col = FIELD_GET(REG_FIELD_ERR_INFO_LOW_COL, reg_val_low);\n\t\tinfo->row = FIELD_GET(REG_FIELD_ERR_INFO_LOW_ROW, reg_val_low);\n\t\tinfo->rank = FIELD_GET(REG_FIELD_ERR_INFO_LOW_RANK, reg_val_low);\n\t\tinfo->bank = FIELD_GET(REG_FIELD_ERR_INFO_HIGH_BANK, reg_val_high);\n\t} else {\n\t\tmemset(info, 0, sizeof(*info));\n\t}\n}\n\nstatic bool dmc520_is_ecc_enabled(void __iomem *reg_base)\n{\n\tu32 reg_val = readl(reg_base + REG_OFFSET_FEATURE_CONFIG);\n\n\treturn FIELD_GET(REG_FIELD_DRAM_ECC_ENABLED, reg_val);\n}\n\nstatic enum scrub_type dmc520_get_scrub_type(struct dmc520_edac *pvt)\n{\n\tenum scrub_type type = SCRUB_NONE;\n\tu32 reg_val, scrub_cfg;\n\n\treg_val = dmc520_read_reg(pvt, REG_OFFSET_SCRUB_CONTROL0_NOW);\n\tscrub_cfg = FIELD_GET(SCRUB_TRIGGER0_NEXT_MASK, reg_val);\n\n\tif (scrub_cfg == DMC520_SCRUB_TRIGGER_ERR_DETECT ||\n\t    scrub_cfg == DMC520_SCRUB_TRIGGER_IDLE)\n\t\ttype = SCRUB_HW_PROG;\n\n\treturn type;\n}\n\n \nstatic u32 dmc520_get_memory_width(struct dmc520_edac *pvt)\n{\n\tenum dmc520_mem_width mem_width_field;\n\tu32 mem_width_in_bytes = 0;\n\tu32 reg_val;\n\n\treg_val = dmc520_read_reg(pvt, REG_OFFSET_FORMAT_CONTROL);\n\tmem_width_field = FIELD_GET(MEMORY_WIDTH_MASK, reg_val);\n\n\tif (mem_width_field == MEM_WIDTH_X32)\n\t\tmem_width_in_bytes = 4;\n\telse if (mem_width_field == MEM_WIDTH_X64)\n\t\tmem_width_in_bytes = 8;\n\treturn mem_width_in_bytes;\n}\n\nstatic enum mem_type dmc520_get_mtype(struct dmc520_edac *pvt)\n{\n\tenum mem_type mt = MEM_UNKNOWN;\n\tenum dmc520_mem_type type;\n\tu32 reg_val;\n\n\treg_val = dmc520_read_reg(pvt, REG_OFFSET_MEMORY_TYPE_NOW);\n\ttype = FIELD_GET(REG_FIELD_MEMORY_TYPE, reg_val);\n\n\tswitch (type) {\n\tcase MEM_TYPE_DDR3:\n\t\tmt = MEM_DDR3;\n\t\tbreak;\n\n\tcase MEM_TYPE_DDR4:\n\t\tmt = MEM_DDR4;\n\t\tbreak;\n\t}\n\n\treturn mt;\n}\n\nstatic enum dev_type dmc520_get_dtype(struct dmc520_edac *pvt)\n{\n\tenum dmc520_dev_width device_width;\n\tenum dev_type dt = DEV_UNKNOWN;\n\tu32 reg_val;\n\n\treg_val = dmc520_read_reg(pvt, REG_OFFSET_MEMORY_TYPE_NOW);\n\tdevice_width = FIELD_GET(REG_FIELD_DEVICE_WIDTH, reg_val);\n\n\tswitch (device_width) {\n\tcase DEV_WIDTH_X4:\n\t\tdt = DEV_X4;\n\t\tbreak;\n\n\tcase DEV_WIDTH_X8:\n\t\tdt = DEV_X8;\n\t\tbreak;\n\n\tcase DEV_WIDTH_X16:\n\t\tdt = DEV_X16;\n\t\tbreak;\n\t}\n\n\treturn dt;\n}\n\nstatic u32 dmc520_get_rank_count(void __iomem *reg_base)\n{\n\tu32 reg_val, rank_bits;\n\n\treg_val = readl(reg_base + REG_OFFSET_ADDRESS_CONTROL_NOW);\n\trank_bits = FIELD_GET(REG_FIELD_ADDRESS_CONTROL_RANK, reg_val);\n\n\treturn BIT(rank_bits);\n}\n\nstatic u64 dmc520_get_rank_size(struct dmc520_edac *pvt)\n{\n\tu32 reg_val, col_bits, row_bits, bank_bits;\n\n\treg_val = dmc520_read_reg(pvt, REG_OFFSET_ADDRESS_CONTROL_NOW);\n\n\tcol_bits = FIELD_GET(REG_FIELD_ADDRESS_CONTROL_COL, reg_val) +\n\t\t   DRAM_ADDRESS_CONTROL_MIN_COL_BITS;\n\trow_bits = FIELD_GET(REG_FIELD_ADDRESS_CONTROL_ROW, reg_val) +\n\t\t   DRAM_ADDRESS_CONTROL_MIN_ROW_BITS;\n\tbank_bits = FIELD_GET(REG_FIELD_ADDRESS_CONTROL_BANK, reg_val);\n\n\treturn (u64)pvt->mem_width_in_bytes << (col_bits + row_bits + bank_bits);\n}\n\nstatic void dmc520_handle_dram_ecc_errors(struct mem_ctl_info *mci,\n\t\t\t\t\t   bool is_ce)\n{\n\tstruct dmc520_edac *pvt = mci->pvt_info;\n\tchar message[DMC520_MSG_BUF_SIZE];\n\tstruct ecc_error_info info;\n\tu32 cnt;\n\n\tdmc520_get_dram_ecc_error_info(pvt, is_ce, &info);\n\n\tcnt = dmc520_get_dram_ecc_error_count(pvt, is_ce);\n\tif (!cnt)\n\t\treturn;\n\n\tsnprintf(message, ARRAY_SIZE(message),\n\t\t \"rank:%d bank:%d row:%d col:%d\",\n\t\t info.rank, info.bank,\n\t\t info.row, info.col);\n\n\tspin_lock(&pvt->error_lock);\n\tedac_mc_handle_error((is_ce ? HW_EVENT_ERR_CORRECTED :\n\t\t\t     HW_EVENT_ERR_UNCORRECTED),\n\t\t\t     mci, cnt, 0, 0, 0, info.rank, -1, -1,\n\t\t\t     message, \"\");\n\tspin_unlock(&pvt->error_lock);\n}\n\nstatic irqreturn_t dmc520_edac_dram_ecc_isr(int irq, struct mem_ctl_info *mci,\n\t\t\t\t\t     bool is_ce)\n{\n\tstruct dmc520_edac *pvt = mci->pvt_info;\n\tu32 i_mask;\n\n\ti_mask = is_ce ? DRAM_ECC_INT_CE_BIT : DRAM_ECC_INT_UE_BIT;\n\n\tdmc520_handle_dram_ecc_errors(mci, is_ce);\n\n\tdmc520_write_reg(pvt, i_mask, REG_OFFSET_INTERRUPT_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dmc520_edac_dram_all_isr(int irq, struct mem_ctl_info *mci,\n\t\t\t\t\t     u32 irq_mask)\n{\n\tstruct dmc520_edac *pvt = mci->pvt_info;\n\tirqreturn_t irq_ret = IRQ_NONE;\n\tu32 status;\n\n\tstatus = dmc520_read_reg(pvt, REG_OFFSET_INTERRUPT_STATUS);\n\n\tif ((irq_mask & DRAM_ECC_INT_CE_BIT) &&\n\t\t(status & DRAM_ECC_INT_CE_BIT))\n\t\tirq_ret = dmc520_edac_dram_ecc_isr(irq, mci, true);\n\n\tif ((irq_mask & DRAM_ECC_INT_UE_BIT) &&\n\t\t(status & DRAM_ECC_INT_UE_BIT))\n\t\tirq_ret = dmc520_edac_dram_ecc_isr(irq, mci, false);\n\n\treturn irq_ret;\n}\n\nstatic irqreturn_t dmc520_isr(int irq, void *data)\n{\n\tstruct mem_ctl_info *mci = data;\n\tstruct dmc520_edac *pvt = mci->pvt_info;\n\tu32 mask = 0;\n\tint idx;\n\n\tfor (idx = 0; idx < NUMBER_OF_IRQS; idx++) {\n\t\tif (pvt->irqs[idx] == irq) {\n\t\t\tmask = pvt->masks[idx];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dmc520_edac_dram_all_isr(irq, mci, mask);\n}\n\nstatic void dmc520_init_csrow(struct mem_ctl_info *mci)\n{\n\tstruct dmc520_edac *pvt = mci->pvt_info;\n\tstruct csrow_info *csi;\n\tstruct dimm_info *dimm;\n\tu32 pages_per_rank;\n\tenum dev_type dt;\n\tenum mem_type mt;\n\tint row, ch;\n\tu64 rs;\n\n\tdt = dmc520_get_dtype(pvt);\n\tmt = dmc520_get_mtype(pvt);\n\trs = dmc520_get_rank_size(pvt);\n\tpages_per_rank = rs >> PAGE_SHIFT;\n\n\tfor (row = 0; row < mci->nr_csrows; row++) {\n\t\tcsi = mci->csrows[row];\n\n\t\tfor (ch = 0; ch < csi->nr_channels; ch++) {\n\t\t\tdimm\t\t= csi->channels[ch]->dimm;\n\t\t\tdimm->grain\t= pvt->mem_width_in_bytes;\n\t\t\tdimm->dtype\t= dt;\n\t\t\tdimm->mtype\t= mt;\n\t\t\tdimm->edac_mode\t= EDAC_SECDED;\n\t\t\tdimm->nr_pages\t= pages_per_rank / csi->nr_channels;\n\t\t}\n\t}\n}\n\nstatic int dmc520_edac_probe(struct platform_device *pdev)\n{\n\tbool registered[NUMBER_OF_IRQS] = { false };\n\tint irqs[NUMBER_OF_IRQS] = { -ENXIO };\n\tint masks[NUMBER_OF_IRQS] = { 0 };\n\tstruct edac_mc_layer layers[1];\n\tstruct dmc520_edac *pvt = NULL;\n\tstruct mem_ctl_info *mci;\n\tvoid __iomem *reg_base;\n\tu32 irq_mask_all = 0;\n\tstruct resource *res;\n\tstruct device *dev;\n\tint ret, idx, irq;\n\tu32 reg_val;\n\n\t \n\tdev = &pdev->dev;\n\n\tfor (idx = 0; idx < NUMBER_OF_IRQS; idx++) {\n\t\tirq = platform_get_irq_byname_optional(pdev, dmc520_irq_configs[idx].name);\n\t\tirqs[idx] = irq;\n\t\tmasks[idx] = dmc520_irq_configs[idx].mask;\n\t\tif (irq >= 0) {\n\t\t\tirq_mask_all |= dmc520_irq_configs[idx].mask;\n\t\t\tedac_dbg(0, \"Discovered %s, irq: %d.\\n\", dmc520_irq_configs[idx].name, irq);\n\t\t}\n\t}\n\n\tif (!irq_mask_all) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_NAME,\n\t\t\t    \"At least one valid interrupt line is expected.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\treg_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\n\tif (!dmc520_is_ecc_enabled(reg_base))\n\t\treturn -ENXIO;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = dmc520_get_rank_count(reg_base);\n\tlayers[0].is_virt_csrow = true;\n\n\tmci = edac_mc_alloc(dmc520_mc_idx++, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (!mci) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_NAME,\n\t\t\t    \"Failed to allocate memory for mc instance\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tpvt = mci->pvt_info;\n\n\tpvt->reg_base = reg_base;\n\tspin_lock_init(&pvt->error_lock);\n\tmemcpy(pvt->irqs, irqs, sizeof(irqs));\n\tmemcpy(pvt->masks, masks, sizeof(masks));\n\n\tplatform_set_drvdata(pdev, mci);\n\n\tmci->pdev = dev;\n\tmci->mtype_cap\t\t= MEM_FLAG_DDR3 | MEM_FLAG_DDR4;\n\tmci->edac_ctl_cap\t= EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap\t\t= EDAC_FLAG_SECDED;\n\tmci->scrub_cap\t\t= SCRUB_FLAG_HW_SRC;\n\tmci->scrub_mode\t\t= dmc520_get_scrub_type(pvt);\n\tmci->ctl_name\t\t= EDAC_CTL_NAME;\n\tmci->dev_name\t\t= dev_name(mci->pdev);\n\tmci->mod_name\t\t= EDAC_MOD_NAME;\n\n\tedac_op_state = EDAC_OPSTATE_INT;\n\n\tpvt->mem_width_in_bytes = dmc520_get_memory_width(pvt);\n\n\tdmc520_init_csrow(mci);\n\n\t \n\treg_val = dmc520_read_reg(pvt, REG_OFFSET_INTERRUPT_CONTROL);\n\tdmc520_write_reg(pvt, reg_val & (~irq_mask_all),\n\t\t\t REG_OFFSET_INTERRUPT_CONTROL);\n\tdmc520_write_reg(pvt, irq_mask_all, REG_OFFSET_INTERRUPT_CLR);\n\n\tfor (idx = 0; idx < NUMBER_OF_IRQS; idx++) {\n\t\tirq = irqs[idx];\n\t\tif (irq >= 0) {\n\t\t\tret = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t\t       dmc520_isr, IRQF_SHARED,\n\t\t\t\t\t       dev_name(&pdev->dev), mci);\n\t\t\tif (ret < 0) {\n\t\t\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t\t\t    \"Failed to request irq %d\\n\", irq);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tregistered[idx] = true;\n\t\t}\n\t}\n\n\t \n\tif (irq_mask_all & DRAM_ECC_INT_CE_BIT)\n\t\tdmc520_get_dram_ecc_error_count(pvt, true);\n\n\tif (irq_mask_all & DRAM_ECC_INT_UE_BIT)\n\t\tdmc520_get_dram_ecc_error_count(pvt, false);\n\n\tret = edac_mc_add_mc(mci);\n\tif (ret) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_NAME,\n\t\t\t    \"Failed to register with EDAC core\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tdmc520_write_reg(pvt, reg_val | irq_mask_all,\n\t\t\t REG_OFFSET_INTERRUPT_CONTROL);\n\n\treturn 0;\n\nerr:\n\tfor (idx = 0; idx < NUMBER_OF_IRQS; idx++) {\n\t\tif (registered[idx])\n\t\t\tdevm_free_irq(&pdev->dev, pvt->irqs[idx], mci);\n\t}\n\tif (mci)\n\t\tedac_mc_free(mci);\n\n\treturn ret;\n}\n\nstatic int dmc520_edac_remove(struct platform_device *pdev)\n{\n\tu32 reg_val, idx, irq_mask_all = 0;\n\tstruct mem_ctl_info *mci;\n\tstruct dmc520_edac *pvt;\n\n\tmci = platform_get_drvdata(pdev);\n\tpvt = mci->pvt_info;\n\n\t \n\treg_val = dmc520_read_reg(pvt, REG_OFFSET_INTERRUPT_CONTROL);\n\tdmc520_write_reg(pvt, reg_val & (~irq_mask_all),\n\t\t\t REG_OFFSET_INTERRUPT_CONTROL);\n\n\t \n\tfor (idx = 0; idx < NUMBER_OF_IRQS; idx++) {\n\t\tif (pvt->irqs[idx] >= 0) {\n\t\t\tirq_mask_all |= pvt->masks[idx];\n\t\t\tdevm_free_irq(&pdev->dev, pvt->irqs[idx], mci);\n\t\t}\n\t}\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id dmc520_edac_driver_id[] = {\n\t{ .compatible = \"arm,dmc-520\", },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, dmc520_edac_driver_id);\n\nstatic struct platform_driver dmc520_edac_driver = {\n\t.driver = {\n\t\t.name = \"dmc520\",\n\t\t.of_match_table = dmc520_edac_driver_id,\n\t},\n\n\t.probe = dmc520_edac_probe,\n\t.remove = dmc520_edac_remove\n};\n\nmodule_platform_driver(dmc520_edac_driver);\n\nMODULE_AUTHOR(\"Rui Zhao <ruizhao@microsoft.com>\");\nMODULE_AUTHOR(\"Lei Wang <lewan@microsoft.com>\");\nMODULE_AUTHOR(\"Shiping Ji <shji@microsoft.com>\");\nMODULE_DESCRIPTION(\"DMC-520 ECC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}