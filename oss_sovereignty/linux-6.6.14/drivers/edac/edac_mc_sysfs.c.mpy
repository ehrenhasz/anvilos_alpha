{
  "module_name": "edac_mc_sysfs.c",
  "hash_id": "ba38321c3062a8ad79216d81a6be4d3f1648391f64a775a357a33994b390e56d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_mc_sysfs.c",
  "human_readable_source": " \n\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/edac.h>\n#include <linux/bug.h>\n#include <linux/pm_runtime.h>\n#include <linux/uaccess.h>\n\n#include \"edac_mc.h\"\n#include \"edac_module.h\"\n\n \nstatic int edac_mc_log_ue = 1;\nstatic int edac_mc_log_ce = 1;\nstatic int edac_mc_panic_on_ue;\nstatic unsigned int edac_mc_poll_msec = 1000;\n\n \nint edac_mc_get_log_ue(void)\n{\n\treturn edac_mc_log_ue;\n}\n\nint edac_mc_get_log_ce(void)\n{\n\treturn edac_mc_log_ce;\n}\n\nint edac_mc_get_panic_on_ue(void)\n{\n\treturn edac_mc_panic_on_ue;\n}\n\n \nunsigned int edac_mc_get_poll_msec(void)\n{\n\treturn edac_mc_poll_msec;\n}\n\nstatic int edac_set_poll_msec(const char *val, const struct kernel_param *kp)\n{\n\tunsigned int i;\n\tint ret;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tret = kstrtouint(val, 0, &i);\n\tif (ret)\n\t\treturn ret;\n\n\tif (i < 1000)\n\t\treturn -EINVAL;\n\n\t*((unsigned int *)kp->arg) = i;\n\n\t \n\tedac_mc_reset_delay_period(i);\n\n\treturn 0;\n}\n\n \nmodule_param(edac_mc_panic_on_ue, int, 0644);\nMODULE_PARM_DESC(edac_mc_panic_on_ue, \"Panic on uncorrected error: 0=off 1=on\");\nmodule_param(edac_mc_log_ue, int, 0644);\nMODULE_PARM_DESC(edac_mc_log_ue,\n\t\t \"Log uncorrectable error to console: 0=off 1=on\");\nmodule_param(edac_mc_log_ce, int, 0644);\nMODULE_PARM_DESC(edac_mc_log_ce,\n\t\t \"Log correctable error to console: 0=off 1=on\");\nmodule_param_call(edac_mc_poll_msec, edac_set_poll_msec, param_get_uint,\n\t\t  &edac_mc_poll_msec, 0644);\nMODULE_PARM_DESC(edac_mc_poll_msec, \"Polling period in milliseconds\");\n\nstatic struct device *mci_pdev;\n\n \nstatic const char * const dev_types[] = {\n\t[DEV_UNKNOWN] = \"Unknown\",\n\t[DEV_X1] = \"x1\",\n\t[DEV_X2] = \"x2\",\n\t[DEV_X4] = \"x4\",\n\t[DEV_X8] = \"x8\",\n\t[DEV_X16] = \"x16\",\n\t[DEV_X32] = \"x32\",\n\t[DEV_X64] = \"x64\"\n};\n\nstatic const char * const edac_caps[] = {\n\t[EDAC_UNKNOWN] = \"Unknown\",\n\t[EDAC_NONE] = \"None\",\n\t[EDAC_RESERVED] = \"Reserved\",\n\t[EDAC_PARITY] = \"PARITY\",\n\t[EDAC_EC] = \"EC\",\n\t[EDAC_SECDED] = \"SECDED\",\n\t[EDAC_S2ECD2ED] = \"S2ECD2ED\",\n\t[EDAC_S4ECD4ED] = \"S4ECD4ED\",\n\t[EDAC_S8ECD8ED] = \"S8ECD8ED\",\n\t[EDAC_S16ECD16ED] = \"S16ECD16ED\"\n};\n\n#ifdef CONFIG_EDAC_LEGACY_SYSFS\n \n\n#define to_csrow(k) container_of(k, struct csrow_info, dev)\n\n \n#define DEVICE_ATTR_LEGACY(_name, _mode, _show, _store) \\\n\tstatic struct device_attribute dev_attr_legacy_##_name = __ATTR(_name, _mode, _show, _store)\n\nstruct dev_ch_attribute {\n\tstruct device_attribute attr;\n\tunsigned int channel;\n};\n\n#define DEVICE_CHANNEL(_name, _mode, _show, _store, _var) \\\n\tstatic struct dev_ch_attribute dev_attr_legacy_##_name = \\\n\t\t{ __ATTR(_name, _mode, _show, _store), (_var) }\n\n#define to_channel(k) (container_of(k, struct dev_ch_attribute, attr)->channel)\n\n \nstatic ssize_t csrow_ue_count_show(struct device *dev,\n\t\t\t\t   struct device_attribute *mattr, char *data)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\n\treturn sprintf(data, \"%u\\n\", csrow->ue_count);\n}\n\nstatic ssize_t csrow_ce_count_show(struct device *dev,\n\t\t\t\t   struct device_attribute *mattr, char *data)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\n\treturn sprintf(data, \"%u\\n\", csrow->ce_count);\n}\n\nstatic ssize_t csrow_size_show(struct device *dev,\n\t\t\t       struct device_attribute *mattr, char *data)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\tint i;\n\tu32 nr_pages = 0;\n\n\tfor (i = 0; i < csrow->nr_channels; i++)\n\t\tnr_pages += csrow->channels[i]->dimm->nr_pages;\n\treturn sprintf(data, \"%u\\n\", PAGES_TO_MiB(nr_pages));\n}\n\nstatic ssize_t csrow_mem_type_show(struct device *dev,\n\t\t\t\t   struct device_attribute *mattr, char *data)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\n\treturn sprintf(data, \"%s\\n\", edac_mem_types[csrow->channels[0]->dimm->mtype]);\n}\n\nstatic ssize_t csrow_dev_type_show(struct device *dev,\n\t\t\t\t   struct device_attribute *mattr, char *data)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\n\treturn sprintf(data, \"%s\\n\", dev_types[csrow->channels[0]->dimm->dtype]);\n}\n\nstatic ssize_t csrow_edac_mode_show(struct device *dev,\n\t\t\t\t    struct device_attribute *mattr,\n\t\t\t\t    char *data)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\n\treturn sprintf(data, \"%s\\n\", edac_caps[csrow->channels[0]->dimm->edac_mode]);\n}\n\n \nstatic ssize_t channel_dimm_label_show(struct device *dev,\n\t\t\t\t       struct device_attribute *mattr,\n\t\t\t\t       char *data)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\tunsigned int chan = to_channel(mattr);\n\tstruct rank_info *rank = csrow->channels[chan];\n\n\t \n\tif (!rank->dimm->label[0])\n\t\treturn 0;\n\n\treturn snprintf(data, sizeof(rank->dimm->label) + 1, \"%s\\n\",\n\t\t\trank->dimm->label);\n}\n\nstatic ssize_t channel_dimm_label_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *mattr,\n\t\t\t\t\tconst char *data, size_t count)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\tunsigned int chan = to_channel(mattr);\n\tstruct rank_info *rank = csrow->channels[chan];\n\tsize_t copy_count = count;\n\n\tif (count == 0)\n\t\treturn -EINVAL;\n\n\tif (data[count - 1] == '\\0' || data[count - 1] == '\\n')\n\t\tcopy_count -= 1;\n\n\tif (copy_count == 0 || copy_count >= sizeof(rank->dimm->label))\n\t\treturn -EINVAL;\n\n\tstrncpy(rank->dimm->label, data, copy_count);\n\trank->dimm->label[copy_count] = '\\0';\n\n\treturn count;\n}\n\n \nstatic ssize_t channel_ce_count_show(struct device *dev,\n\t\t\t\t     struct device_attribute *mattr, char *data)\n{\n\tstruct csrow_info *csrow = to_csrow(dev);\n\tunsigned int chan = to_channel(mattr);\n\tstruct rank_info *rank = csrow->channels[chan];\n\n\treturn sprintf(data, \"%u\\n\", rank->ce_count);\n}\n\n \nDEVICE_ATTR_LEGACY(size_mb, S_IRUGO, csrow_size_show, NULL);\nDEVICE_ATTR_LEGACY(dev_type, S_IRUGO, csrow_dev_type_show, NULL);\nDEVICE_ATTR_LEGACY(mem_type, S_IRUGO, csrow_mem_type_show, NULL);\nDEVICE_ATTR_LEGACY(edac_mode, S_IRUGO, csrow_edac_mode_show, NULL);\nDEVICE_ATTR_LEGACY(ue_count, S_IRUGO, csrow_ue_count_show, NULL);\nDEVICE_ATTR_LEGACY(ce_count, S_IRUGO, csrow_ce_count_show, NULL);\n\n \nstatic struct attribute *csrow_attrs[] = {\n\t&dev_attr_legacy_dev_type.attr,\n\t&dev_attr_legacy_mem_type.attr,\n\t&dev_attr_legacy_edac_mode.attr,\n\t&dev_attr_legacy_size_mb.attr,\n\t&dev_attr_legacy_ue_count.attr,\n\t&dev_attr_legacy_ce_count.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group csrow_attr_grp = {\n\t.attrs\t= csrow_attrs,\n};\n\nstatic const struct attribute_group *csrow_attr_groups[] = {\n\t&csrow_attr_grp,\n\tNULL\n};\n\nstatic const struct device_type csrow_attr_type = {\n\t.groups\t\t= csrow_attr_groups,\n};\n\n \nDEVICE_CHANNEL(ch0_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 0);\nDEVICE_CHANNEL(ch1_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 1);\nDEVICE_CHANNEL(ch2_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 2);\nDEVICE_CHANNEL(ch3_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 3);\nDEVICE_CHANNEL(ch4_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 4);\nDEVICE_CHANNEL(ch5_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 5);\nDEVICE_CHANNEL(ch6_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 6);\nDEVICE_CHANNEL(ch7_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 7);\nDEVICE_CHANNEL(ch8_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 8);\nDEVICE_CHANNEL(ch9_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 9);\nDEVICE_CHANNEL(ch10_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 10);\nDEVICE_CHANNEL(ch11_dimm_label, S_IRUGO | S_IWUSR,\n\tchannel_dimm_label_show, channel_dimm_label_store, 11);\n\n \nstatic struct attribute *dynamic_csrow_dimm_attr[] = {\n\t&dev_attr_legacy_ch0_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch1_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch2_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch3_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch4_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch5_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch6_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch7_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch8_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch9_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch10_dimm_label.attr.attr,\n\t&dev_attr_legacy_ch11_dimm_label.attr.attr,\n\tNULL\n};\n\n \nDEVICE_CHANNEL(ch0_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 0);\nDEVICE_CHANNEL(ch1_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 1);\nDEVICE_CHANNEL(ch2_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 2);\nDEVICE_CHANNEL(ch3_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 3);\nDEVICE_CHANNEL(ch4_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 4);\nDEVICE_CHANNEL(ch5_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 5);\nDEVICE_CHANNEL(ch6_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 6);\nDEVICE_CHANNEL(ch7_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 7);\nDEVICE_CHANNEL(ch8_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 8);\nDEVICE_CHANNEL(ch9_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 9);\nDEVICE_CHANNEL(ch10_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 10);\nDEVICE_CHANNEL(ch11_ce_count, S_IRUGO,\n\t\t   channel_ce_count_show, NULL, 11);\n\n \nstatic struct attribute *dynamic_csrow_ce_count_attr[] = {\n\t&dev_attr_legacy_ch0_ce_count.attr.attr,\n\t&dev_attr_legacy_ch1_ce_count.attr.attr,\n\t&dev_attr_legacy_ch2_ce_count.attr.attr,\n\t&dev_attr_legacy_ch3_ce_count.attr.attr,\n\t&dev_attr_legacy_ch4_ce_count.attr.attr,\n\t&dev_attr_legacy_ch5_ce_count.attr.attr,\n\t&dev_attr_legacy_ch6_ce_count.attr.attr,\n\t&dev_attr_legacy_ch7_ce_count.attr.attr,\n\t&dev_attr_legacy_ch8_ce_count.attr.attr,\n\t&dev_attr_legacy_ch9_ce_count.attr.attr,\n\t&dev_attr_legacy_ch10_ce_count.attr.attr,\n\t&dev_attr_legacy_ch11_ce_count.attr.attr,\n\tNULL\n};\n\nstatic umode_t csrow_dev_is_visible(struct kobject *kobj,\n\t\t\t\t    struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct csrow_info *csrow = container_of(dev, struct csrow_info, dev);\n\n\tif (idx >= csrow->nr_channels)\n\t\treturn 0;\n\n\tif (idx >= ARRAY_SIZE(dynamic_csrow_ce_count_attr) - 1) {\n\t\tWARN_ONCE(1, \"idx: %d\\n\", idx);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!csrow->channels[idx]->dimm->nr_pages)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\n\nstatic const struct attribute_group csrow_dev_dimm_group = {\n\t.attrs = dynamic_csrow_dimm_attr,\n\t.is_visible = csrow_dev_is_visible,\n};\n\nstatic const struct attribute_group csrow_dev_ce_count_group = {\n\t.attrs = dynamic_csrow_ce_count_attr,\n\t.is_visible = csrow_dev_is_visible,\n};\n\nstatic const struct attribute_group *csrow_dev_groups[] = {\n\t&csrow_dev_dimm_group,\n\t&csrow_dev_ce_count_group,\n\tNULL\n};\n\nstatic void csrow_release(struct device *dev)\n{\n\t \n}\n\nstatic inline int nr_pages_per_csrow(struct csrow_info *csrow)\n{\n\tint chan, nr_pages = 0;\n\n\tfor (chan = 0; chan < csrow->nr_channels; chan++)\n\t\tnr_pages += csrow->channels[chan]->dimm->nr_pages;\n\n\treturn nr_pages;\n}\n\n \nstatic int edac_create_csrow_object(struct mem_ctl_info *mci,\n\t\t\t\t    struct csrow_info *csrow, int index)\n{\n\tint err;\n\n\tcsrow->dev.type = &csrow_attr_type;\n\tcsrow->dev.groups = csrow_dev_groups;\n\tcsrow->dev.release = csrow_release;\n\tdevice_initialize(&csrow->dev);\n\tcsrow->dev.parent = &mci->dev;\n\tcsrow->mci = mci;\n\tdev_set_name(&csrow->dev, \"csrow%d\", index);\n\tdev_set_drvdata(&csrow->dev, csrow);\n\n\terr = device_add(&csrow->dev);\n\tif (err) {\n\t\tedac_dbg(1, \"failure: create device %s\\n\", dev_name(&csrow->dev));\n\t\tput_device(&csrow->dev);\n\t\treturn err;\n\t}\n\n\tedac_dbg(0, \"device %s created\\n\", dev_name(&csrow->dev));\n\n\treturn 0;\n}\n\n \nstatic int edac_create_csrow_objects(struct mem_ctl_info *mci)\n{\n\tint err, i;\n\tstruct csrow_info *csrow;\n\n\tfor (i = 0; i < mci->nr_csrows; i++) {\n\t\tcsrow = mci->csrows[i];\n\t\tif (!nr_pages_per_csrow(csrow))\n\t\t\tcontinue;\n\t\terr = edac_create_csrow_object(mci, mci->csrows[i], i);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tfor (--i; i >= 0; i--) {\n\t\tif (device_is_registered(&mci->csrows[i]->dev))\n\t\t\tdevice_unregister(&mci->csrows[i]->dev);\n\t}\n\n\treturn err;\n}\n\nstatic void edac_delete_csrow_objects(struct mem_ctl_info *mci)\n{\n\tint i;\n\n\tfor (i = 0; i < mci->nr_csrows; i++) {\n\t\tif (device_is_registered(&mci->csrows[i]->dev))\n\t\t\tdevice_unregister(&mci->csrows[i]->dev);\n\t}\n}\n\n#endif\n\n \n\n#define to_dimm(k) container_of(k, struct dimm_info, dev)\n\n \nstatic ssize_t dimmdev_location_show(struct device *dev,\n\t\t\t\t     struct device_attribute *mattr, char *data)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\tssize_t count;\n\n\tcount = edac_dimm_info_location(dimm, data, PAGE_SIZE);\n\tcount += scnprintf(data + count, PAGE_SIZE - count, \"\\n\");\n\n\treturn count;\n}\n\nstatic ssize_t dimmdev_label_show(struct device *dev,\n\t\t\t\t  struct device_attribute *mattr, char *data)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\n\t \n\tif (!dimm->label[0])\n\t\treturn 0;\n\n\treturn snprintf(data, sizeof(dimm->label) + 1, \"%s\\n\", dimm->label);\n}\n\nstatic ssize_t dimmdev_label_store(struct device *dev,\n\t\t\t\t   struct device_attribute *mattr,\n\t\t\t\t   const char *data,\n\t\t\t\t   size_t count)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\tsize_t copy_count = count;\n\n\tif (count == 0)\n\t\treturn -EINVAL;\n\n\tif (data[count - 1] == '\\0' || data[count - 1] == '\\n')\n\t\tcopy_count -= 1;\n\n\tif (copy_count == 0 || copy_count >= sizeof(dimm->label))\n\t\treturn -EINVAL;\n\n\tstrncpy(dimm->label, data, copy_count);\n\tdimm->label[copy_count] = '\\0';\n\n\treturn count;\n}\n\nstatic ssize_t dimmdev_size_show(struct device *dev,\n\t\t\t\t struct device_attribute *mattr, char *data)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\n\treturn sprintf(data, \"%u\\n\", PAGES_TO_MiB(dimm->nr_pages));\n}\n\nstatic ssize_t dimmdev_mem_type_show(struct device *dev,\n\t\t\t\t     struct device_attribute *mattr, char *data)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\n\treturn sprintf(data, \"%s\\n\", edac_mem_types[dimm->mtype]);\n}\n\nstatic ssize_t dimmdev_dev_type_show(struct device *dev,\n\t\t\t\t     struct device_attribute *mattr, char *data)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\n\treturn sprintf(data, \"%s\\n\", dev_types[dimm->dtype]);\n}\n\nstatic ssize_t dimmdev_edac_mode_show(struct device *dev,\n\t\t\t\t      struct device_attribute *mattr,\n\t\t\t\t      char *data)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\n\treturn sprintf(data, \"%s\\n\", edac_caps[dimm->edac_mode]);\n}\n\nstatic ssize_t dimmdev_ce_count_show(struct device *dev,\n\t\t\t\t      struct device_attribute *mattr,\n\t\t\t\t      char *data)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\n\treturn sprintf(data, \"%u\\n\", dimm->ce_count);\n}\n\nstatic ssize_t dimmdev_ue_count_show(struct device *dev,\n\t\t\t\t      struct device_attribute *mattr,\n\t\t\t\t      char *data)\n{\n\tstruct dimm_info *dimm = to_dimm(dev);\n\n\treturn sprintf(data, \"%u\\n\", dimm->ue_count);\n}\n\n \nstatic DEVICE_ATTR(dimm_label, S_IRUGO | S_IWUSR,\n\t\t   dimmdev_label_show, dimmdev_label_store);\nstatic DEVICE_ATTR(dimm_location, S_IRUGO, dimmdev_location_show, NULL);\nstatic DEVICE_ATTR(size, S_IRUGO, dimmdev_size_show, NULL);\nstatic DEVICE_ATTR(dimm_mem_type, S_IRUGO, dimmdev_mem_type_show, NULL);\nstatic DEVICE_ATTR(dimm_dev_type, S_IRUGO, dimmdev_dev_type_show, NULL);\nstatic DEVICE_ATTR(dimm_edac_mode, S_IRUGO, dimmdev_edac_mode_show, NULL);\nstatic DEVICE_ATTR(dimm_ce_count, S_IRUGO, dimmdev_ce_count_show, NULL);\nstatic DEVICE_ATTR(dimm_ue_count, S_IRUGO, dimmdev_ue_count_show, NULL);\n\n \nstatic struct attribute *dimm_attrs[] = {\n\t&dev_attr_dimm_label.attr,\n\t&dev_attr_dimm_location.attr,\n\t&dev_attr_size.attr,\n\t&dev_attr_dimm_mem_type.attr,\n\t&dev_attr_dimm_dev_type.attr,\n\t&dev_attr_dimm_edac_mode.attr,\n\t&dev_attr_dimm_ce_count.attr,\n\t&dev_attr_dimm_ue_count.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group dimm_attr_grp = {\n\t.attrs\t= dimm_attrs,\n};\n\nstatic const struct attribute_group *dimm_attr_groups[] = {\n\t&dimm_attr_grp,\n\tNULL\n};\n\nstatic const struct device_type dimm_attr_type = {\n\t.groups\t\t= dimm_attr_groups,\n};\n\nstatic void dimm_release(struct device *dev)\n{\n\t \n}\n\n \nstatic int edac_create_dimm_object(struct mem_ctl_info *mci,\n\t\t\t\t   struct dimm_info *dimm)\n{\n\tint err;\n\tdimm->mci = mci;\n\n\tdimm->dev.type = &dimm_attr_type;\n\tdimm->dev.release = dimm_release;\n\tdevice_initialize(&dimm->dev);\n\n\tdimm->dev.parent = &mci->dev;\n\tif (mci->csbased)\n\t\tdev_set_name(&dimm->dev, \"rank%d\", dimm->idx);\n\telse\n\t\tdev_set_name(&dimm->dev, \"dimm%d\", dimm->idx);\n\tdev_set_drvdata(&dimm->dev, dimm);\n\tpm_runtime_forbid(&mci->dev);\n\n\terr = device_add(&dimm->dev);\n\tif (err) {\n\t\tedac_dbg(1, \"failure: create device %s\\n\", dev_name(&dimm->dev));\n\t\tput_device(&dimm->dev);\n\t\treturn err;\n\t}\n\n\tif (IS_ENABLED(CONFIG_EDAC_DEBUG)) {\n\t\tchar location[80];\n\n\t\tedac_dimm_info_location(dimm, location, sizeof(location));\n\t\tedac_dbg(0, \"device %s created at location %s\\n\",\n\t\t\tdev_name(&dimm->dev), location);\n\t}\n\n\treturn 0;\n}\n\n \n\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\n\nstatic ssize_t mci_reset_counters_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *mattr,\n\t\t\t\t\tconst char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct dimm_info *dimm;\n\tint row, chan;\n\n\tmci->ue_mc = 0;\n\tmci->ce_mc = 0;\n\tmci->ue_noinfo_count = 0;\n\tmci->ce_noinfo_count = 0;\n\n\tfor (row = 0; row < mci->nr_csrows; row++) {\n\t\tstruct csrow_info *ri = mci->csrows[row];\n\n\t\tri->ue_count = 0;\n\t\tri->ce_count = 0;\n\n\t\tfor (chan = 0; chan < ri->nr_channels; chan++)\n\t\t\tri->channels[chan]->ce_count = 0;\n\t}\n\n\tmci_for_each_dimm(mci, dimm) {\n\t\tdimm->ue_count = 0;\n\t\tdimm->ce_count = 0;\n\t}\n\n\tmci->start_time = jiffies;\n\treturn count;\n}\n\n \nstatic ssize_t mci_sdram_scrub_rate_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *mattr,\n\t\t\t\t\t  const char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tunsigned long bandwidth = 0;\n\tint new_bw = 0;\n\n\tif (kstrtoul(data, 10, &bandwidth) < 0)\n\t\treturn -EINVAL;\n\n\tnew_bw = mci->set_sdram_scrub_rate(mci, bandwidth);\n\tif (new_bw < 0) {\n\t\tedac_printk(KERN_WARNING, EDAC_MC,\n\t\t\t    \"Error setting scrub rate to: %lu\\n\", bandwidth);\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\n \nstatic ssize_t mci_sdram_scrub_rate_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *mattr,\n\t\t\t\t\t char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tint bandwidth = 0;\n\n\tbandwidth = mci->get_sdram_scrub_rate(mci);\n\tif (bandwidth < 0) {\n\t\tedac_printk(KERN_DEBUG, EDAC_MC, \"Error reading scrub rate\\n\");\n\t\treturn bandwidth;\n\t}\n\n\treturn sprintf(data, \"%d\\n\", bandwidth);\n}\n\n \nstatic ssize_t mci_ue_count_show(struct device *dev,\n\t\t\t\t struct device_attribute *mattr,\n\t\t\t\t char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\n\treturn sprintf(data, \"%u\\n\", mci->ue_mc);\n}\n\nstatic ssize_t mci_ce_count_show(struct device *dev,\n\t\t\t\t struct device_attribute *mattr,\n\t\t\t\t char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\n\treturn sprintf(data, \"%u\\n\", mci->ce_mc);\n}\n\nstatic ssize_t mci_ce_noinfo_show(struct device *dev,\n\t\t\t\t  struct device_attribute *mattr,\n\t\t\t\t  char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\n\treturn sprintf(data, \"%u\\n\", mci->ce_noinfo_count);\n}\n\nstatic ssize_t mci_ue_noinfo_show(struct device *dev,\n\t\t\t\t  struct device_attribute *mattr,\n\t\t\t\t  char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\n\treturn sprintf(data, \"%u\\n\", mci->ue_noinfo_count);\n}\n\nstatic ssize_t mci_seconds_show(struct device *dev,\n\t\t\t\tstruct device_attribute *mattr,\n\t\t\t\tchar *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\n\treturn sprintf(data, \"%ld\\n\", (jiffies - mci->start_time) / HZ);\n}\n\nstatic ssize_t mci_ctl_name_show(struct device *dev,\n\t\t\t\t struct device_attribute *mattr,\n\t\t\t\t char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\n\treturn sprintf(data, \"%s\\n\", mci->ctl_name);\n}\n\nstatic ssize_t mci_size_mb_show(struct device *dev,\n\t\t\t\tstruct device_attribute *mattr,\n\t\t\t\tchar *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tint total_pages = 0, csrow_idx, j;\n\n\tfor (csrow_idx = 0; csrow_idx < mci->nr_csrows; csrow_idx++) {\n\t\tstruct csrow_info *csrow = mci->csrows[csrow_idx];\n\n\t\tfor (j = 0; j < csrow->nr_channels; j++) {\n\t\t\tstruct dimm_info *dimm = csrow->channels[j]->dimm;\n\n\t\t\ttotal_pages += dimm->nr_pages;\n\t\t}\n\t}\n\n\treturn sprintf(data, \"%u\\n\", PAGES_TO_MiB(total_pages));\n}\n\nstatic ssize_t mci_max_location_show(struct device *dev,\n\t\t\t\t     struct device_attribute *mattr,\n\t\t\t\t     char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tint len = PAGE_SIZE;\n\tchar *p = data;\n\tint i, n;\n\n\tfor (i = 0; i < mci->n_layers; i++) {\n\t\tn = scnprintf(p, len, \"%s %d \",\n\t\t\t      edac_layer_name[mci->layers[i].type],\n\t\t\t      mci->layers[i].size - 1);\n\t\tlen -= n;\n\t\tif (len <= 0)\n\t\t\tgoto out;\n\n\t\tp += n;\n\t}\n\n\tp += scnprintf(p, len, \"\\n\");\nout:\n\treturn p - data;\n}\n\n \nstatic DEVICE_ATTR(reset_counters, S_IWUSR, NULL, mci_reset_counters_store);\n\n \nstatic DEVICE_ATTR(mc_name, S_IRUGO, mci_ctl_name_show, NULL);\nstatic DEVICE_ATTR(size_mb, S_IRUGO, mci_size_mb_show, NULL);\nstatic DEVICE_ATTR(seconds_since_reset, S_IRUGO, mci_seconds_show, NULL);\nstatic DEVICE_ATTR(ue_noinfo_count, S_IRUGO, mci_ue_noinfo_show, NULL);\nstatic DEVICE_ATTR(ce_noinfo_count, S_IRUGO, mci_ce_noinfo_show, NULL);\nstatic DEVICE_ATTR(ue_count, S_IRUGO, mci_ue_count_show, NULL);\nstatic DEVICE_ATTR(ce_count, S_IRUGO, mci_ce_count_show, NULL);\nstatic DEVICE_ATTR(max_location, S_IRUGO, mci_max_location_show, NULL);\n\n \nstatic DEVICE_ATTR(sdram_scrub_rate, 0, mci_sdram_scrub_rate_show,\n\t    mci_sdram_scrub_rate_store);  \n\nstatic struct attribute *mci_attrs[] = {\n\t&dev_attr_reset_counters.attr,\n\t&dev_attr_mc_name.attr,\n\t&dev_attr_size_mb.attr,\n\t&dev_attr_seconds_since_reset.attr,\n\t&dev_attr_ue_noinfo_count.attr,\n\t&dev_attr_ce_noinfo_count.attr,\n\t&dev_attr_ue_count.attr,\n\t&dev_attr_ce_count.attr,\n\t&dev_attr_max_location.attr,\n\t&dev_attr_sdram_scrub_rate.attr,\n\tNULL\n};\n\nstatic umode_t mci_attr_is_visible(struct kobject *kobj,\n\t\t\t\t   struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tumode_t mode = 0;\n\n\tif (attr != &dev_attr_sdram_scrub_rate.attr)\n\t\treturn attr->mode;\n\tif (mci->get_sdram_scrub_rate)\n\t\tmode |= S_IRUGO;\n\tif (mci->set_sdram_scrub_rate)\n\t\tmode |= S_IWUSR;\n\treturn mode;\n}\n\nstatic const struct attribute_group mci_attr_grp = {\n\t.attrs\t= mci_attrs,\n\t.is_visible = mci_attr_is_visible,\n};\n\nstatic const struct attribute_group *mci_attr_groups[] = {\n\t&mci_attr_grp,\n\tNULL\n};\n\nstatic const struct device_type mci_attr_type = {\n\t.groups\t\t= mci_attr_groups,\n};\n\n \nint edac_create_sysfs_mci_device(struct mem_ctl_info *mci,\n\t\t\t\t const struct attribute_group **groups)\n{\n\tstruct dimm_info *dimm;\n\tint err;\n\n\t \n\tmci->dev.type = &mci_attr_type;\n\tmci->dev.parent = mci_pdev;\n\tmci->dev.groups = groups;\n\tdev_set_name(&mci->dev, \"mc%d\", mci->mc_idx);\n\tdev_set_drvdata(&mci->dev, mci);\n\tpm_runtime_forbid(&mci->dev);\n\n\terr = device_add(&mci->dev);\n\tif (err < 0) {\n\t\tedac_dbg(1, \"failure: create device %s\\n\", dev_name(&mci->dev));\n\t\t \n\t\treturn err;\n\t}\n\n\tedac_dbg(0, \"device %s created\\n\", dev_name(&mci->dev));\n\n\t \n\tmci_for_each_dimm(mci, dimm) {\n\t\t \n\t\tif (!dimm->nr_pages)\n\t\t\tcontinue;\n\n\t\terr = edac_create_dimm_object(mci, dimm);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n#ifdef CONFIG_EDAC_LEGACY_SYSFS\n\terr = edac_create_csrow_objects(mci);\n\tif (err < 0)\n\t\tgoto fail;\n#endif\n\n\tedac_create_debugfs_nodes(mci);\n\treturn 0;\n\nfail:\n\tedac_remove_sysfs_mci_device(mci);\n\n\treturn err;\n}\n\n \nvoid edac_remove_sysfs_mci_device(struct mem_ctl_info *mci)\n{\n\tstruct dimm_info *dimm;\n\n\tif (!device_is_registered(&mci->dev))\n\t\treturn;\n\n\tedac_dbg(0, \"\\n\");\n\n#ifdef CONFIG_EDAC_DEBUG\n\tedac_debugfs_remove_recursive(mci->debugfs);\n#endif\n#ifdef CONFIG_EDAC_LEGACY_SYSFS\n\tedac_delete_csrow_objects(mci);\n#endif\n\n\tmci_for_each_dimm(mci, dimm) {\n\t\tif (!device_is_registered(&dimm->dev))\n\t\t\tcontinue;\n\t\tedac_dbg(1, \"unregistering device %s\\n\", dev_name(&dimm->dev));\n\t\tdevice_unregister(&dimm->dev);\n\t}\n\n\t \n\tdevice_del(&mci->dev);\n}\n\nstatic void mc_attr_release(struct device *dev)\n{\n\t \n\tedac_dbg(1, \"device %s released\\n\", dev_name(dev));\n\tkfree(dev);\n}\n\n \nint __init edac_mc_sysfs_init(void)\n{\n\tint err;\n\n\tmci_pdev = kzalloc(sizeof(*mci_pdev), GFP_KERNEL);\n\tif (!mci_pdev)\n\t\treturn -ENOMEM;\n\n\tmci_pdev->bus = edac_get_sysfs_subsys();\n\tmci_pdev->release = mc_attr_release;\n\tmci_pdev->init_name = \"mc\";\n\n\terr = device_register(mci_pdev);\n\tif (err < 0) {\n\t\tedac_dbg(1, \"failure: create device %s\\n\", dev_name(mci_pdev));\n\t\tput_device(mci_pdev);\n\t\treturn err;\n\t}\n\n\tedac_dbg(0, \"device %s created\\n\", dev_name(mci_pdev));\n\n\treturn 0;\n}\n\nvoid edac_mc_sysfs_exit(void)\n{\n\tdevice_unregister(mci_pdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}