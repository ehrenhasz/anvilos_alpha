{
  "module_name": "pasemi_edac.c",
  "hash_id": "f5226af47a03f5b25285d7f233de760492f095ee2967a5400fc7e00c7cfe1719",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/pasemi_edac.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define MODULE_NAME \"pasemi_edac\"\n\n#define MCCFG_MCEN\t\t\t\t0x300\n#define   MCCFG_MCEN_MMC_EN\t\t\t0x00000001\n#define MCCFG_ERRCOR\t\t\t\t0x388\n#define   MCCFG_ERRCOR_RNK_FAIL_DET_EN\t\t0x00000100\n#define   MCCFG_ERRCOR_ECC_GEN_EN\t\t0x00000010\n#define   MCCFG_ERRCOR_ECC_CRR_EN\t\t0x00000001\n#define MCCFG_SCRUB\t\t\t\t0x384\n#define   MCCFG_SCRUB_RGLR_SCRB_EN\t\t0x00000001\n#define MCDEBUG_ERRCTL1\t\t\t\t0x728\n#define   MCDEBUG_ERRCTL1_RFL_LOG_EN\t\t0x00080000\n#define   MCDEBUG_ERRCTL1_MBE_LOG_EN\t\t0x00040000\n#define   MCDEBUG_ERRCTL1_SBE_LOG_EN\t\t0x00020000\n#define MCDEBUG_ERRSTA\t\t\t\t0x730\n#define   MCDEBUG_ERRSTA_RFL_STATUS\t\t0x00000004\n#define   MCDEBUG_ERRSTA_MBE_STATUS\t\t0x00000002\n#define   MCDEBUG_ERRSTA_SBE_STATUS\t\t0x00000001\n#define MCDEBUG_ERRCNT1\t\t\t\t0x734\n#define   MCDEBUG_ERRCNT1_SBE_CNT_OVRFLO\t0x00000080\n#define MCDEBUG_ERRLOG1A\t\t\t0x738\n#define   MCDEBUG_ERRLOG1A_MERR_TYPE_M\t\t0x30000000\n#define   MCDEBUG_ERRLOG1A_MERR_TYPE_NONE\t0x00000000\n#define   MCDEBUG_ERRLOG1A_MERR_TYPE_SBE\t0x10000000\n#define   MCDEBUG_ERRLOG1A_MERR_TYPE_MBE\t0x20000000\n#define   MCDEBUG_ERRLOG1A_MERR_TYPE_RFL\t0x30000000\n#define   MCDEBUG_ERRLOG1A_MERR_BA_M\t\t0x00700000\n#define   MCDEBUG_ERRLOG1A_MERR_BA_S\t\t20\n#define   MCDEBUG_ERRLOG1A_MERR_CS_M\t\t0x00070000\n#define   MCDEBUG_ERRLOG1A_MERR_CS_S\t\t16\n#define   MCDEBUG_ERRLOG1A_SYNDROME_M\t\t0x0000ffff\n#define MCDRAM_RANKCFG\t\t\t\t0x114\n#define   MCDRAM_RANKCFG_EN\t\t\t0x00000001\n#define   MCDRAM_RANKCFG_TYPE_SIZE_M\t\t0x000001c0\n#define   MCDRAM_RANKCFG_TYPE_SIZE_S\t\t6\n\n#define PASEMI_EDAC_NR_CSROWS\t\t\t8\n#define PASEMI_EDAC_NR_CHANS\t\t\t1\n#define PASEMI_EDAC_ERROR_GRAIN\t\t\t64\n\nstatic int last_page_in_mmc;\nstatic int system_mmc_id;\n\n\nstatic u32 pasemi_edac_get_error_info(struct mem_ctl_info *mci)\n{\n\tstruct pci_dev *pdev = to_pci_dev(mci->pdev);\n\tu32 tmp;\n\n\tpci_read_config_dword(pdev, MCDEBUG_ERRSTA,\n\t\t\t      &tmp);\n\n\ttmp &= (MCDEBUG_ERRSTA_RFL_STATUS | MCDEBUG_ERRSTA_MBE_STATUS\n\t\t| MCDEBUG_ERRSTA_SBE_STATUS);\n\n\tif (tmp) {\n\t\tif (tmp & MCDEBUG_ERRSTA_SBE_STATUS)\n\t\t\tpci_write_config_dword(pdev, MCDEBUG_ERRCNT1,\n\t\t\t\t\t       MCDEBUG_ERRCNT1_SBE_CNT_OVRFLO);\n\t\tpci_write_config_dword(pdev, MCDEBUG_ERRSTA, tmp);\n\t}\n\n\treturn tmp;\n}\n\nstatic void pasemi_edac_process_error_info(struct mem_ctl_info *mci, u32 errsta)\n{\n\tstruct pci_dev *pdev = to_pci_dev(mci->pdev);\n\tu32 errlog1a;\n\tu32 cs;\n\n\tif (!errsta)\n\t\treturn;\n\n\tpci_read_config_dword(pdev, MCDEBUG_ERRLOG1A, &errlog1a);\n\n\tcs = (errlog1a & MCDEBUG_ERRLOG1A_MERR_CS_M) >>\n\t\tMCDEBUG_ERRLOG1A_MERR_CS_S;\n\n\t \n\tif (errsta & (MCDEBUG_ERRSTA_MBE_STATUS |\n\t\t      MCDEBUG_ERRSTA_RFL_STATUS)) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     mci->csrows[cs]->first_page, 0, 0,\n\t\t\t\t     cs, 0, -1, mci->ctl_name, \"\");\n\t}\n\n\t \n\tif (errsta & MCDEBUG_ERRSTA_SBE_STATUS)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t     mci->csrows[cs]->first_page, 0, 0,\n\t\t\t\t     cs, 0, -1, mci->ctl_name, \"\");\n}\n\nstatic void pasemi_edac_check(struct mem_ctl_info *mci)\n{\n\tu32 errsta;\n\n\terrsta = pasemi_edac_get_error_info(mci);\n\tif (errsta)\n\t\tpasemi_edac_process_error_info(mci, errsta);\n}\n\nstatic int pasemi_edac_init_csrows(struct mem_ctl_info *mci,\n\t\t\t\t   struct pci_dev *pdev,\n\t\t\t\t   enum edac_type edac_mode)\n{\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\tu32 rankcfg;\n\tint index;\n\n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\tcsrow = mci->csrows[index];\n\t\tdimm = csrow->channels[0]->dimm;\n\n\t\tpci_read_config_dword(pdev,\n\t\t\t\t      MCDRAM_RANKCFG + (index * 12),\n\t\t\t\t      &rankcfg);\n\n\t\tif (!(rankcfg & MCDRAM_RANKCFG_EN))\n\t\t\tcontinue;\n\n\t\tswitch ((rankcfg & MCDRAM_RANKCFG_TYPE_SIZE_M) >>\n\t\t\tMCDRAM_RANKCFG_TYPE_SIZE_S) {\n\t\tcase 0:\n\t\t\tdimm->nr_pages = 128 << (20 - PAGE_SHIFT);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdimm->nr_pages = 256 << (20 - PAGE_SHIFT);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tdimm->nr_pages = 512 << (20 - PAGE_SHIFT);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdimm->nr_pages = 1024 << (20 - PAGE_SHIFT);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdimm->nr_pages = 2048 << (20 - PAGE_SHIFT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tedac_mc_printk(mci, KERN_ERR,\n\t\t\t\t\"Unrecognized Rank Config. rankcfg=%u\\n\",\n\t\t\t\trankcfg);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcsrow->first_page = last_page_in_mmc;\n\t\tcsrow->last_page = csrow->first_page + dimm->nr_pages - 1;\n\t\tlast_page_in_mmc += dimm->nr_pages;\n\t\tcsrow->page_mask = 0;\n\t\tdimm->grain = PASEMI_EDAC_ERROR_GRAIN;\n\t\tdimm->mtype = MEM_DDR;\n\t\tdimm->dtype = DEV_UNKNOWN;\n\t\tdimm->edac_mode = edac_mode;\n\t}\n\treturn 0;\n}\n\nstatic int pasemi_edac_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct mem_ctl_info *mci = NULL;\n\tstruct edac_mc_layer layers[2];\n\tu32 errctl1, errcor, scrub, mcen;\n\n\tpci_read_config_dword(pdev, MCCFG_MCEN, &mcen);\n\tif (!(mcen & MCCFG_MCEN_MMC_EN))\n\t\treturn -ENODEV;\n\n\t \n\n\tpci_read_config_dword(pdev, MCDEBUG_ERRCTL1, &errctl1);\n\terrctl1 |= MCDEBUG_ERRCTL1_SBE_LOG_EN |\n\t\tMCDEBUG_ERRCTL1_MBE_LOG_EN |\n\t\tMCDEBUG_ERRCTL1_RFL_LOG_EN;\n\tpci_write_config_dword(pdev, MCDEBUG_ERRCTL1, errctl1);\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = PASEMI_EDAC_NR_CSROWS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = PASEMI_EDAC_NR_CHANS;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(system_mmc_id++, ARRAY_SIZE(layers), layers,\n\t\t\t    0);\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tpci_read_config_dword(pdev, MCCFG_ERRCOR, &errcor);\n\terrcor |= MCCFG_ERRCOR_RNK_FAIL_DET_EN |\n\t\tMCCFG_ERRCOR_ECC_GEN_EN |\n\t\tMCCFG_ERRCOR_ECC_CRR_EN;\n\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_DDR | MEM_FLAG_RDDR;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\n\tmci->edac_cap = (errcor & MCCFG_ERRCOR_ECC_GEN_EN) ?\n\t\t((errcor & MCCFG_ERRCOR_ECC_CRR_EN) ?\n\t\t (EDAC_FLAG_EC | EDAC_FLAG_SECDED) : EDAC_FLAG_EC) :\n\t\tEDAC_FLAG_NONE;\n\tmci->mod_name = MODULE_NAME;\n\tmci->dev_name = pci_name(pdev);\n\tmci->ctl_name = \"pasemi,pwrficient-mc\";\n\tmci->edac_check = pasemi_edac_check;\n\tmci->ctl_page_to_phys = NULL;\n\tpci_read_config_dword(pdev, MCCFG_SCRUB, &scrub);\n\tmci->scrub_cap = SCRUB_FLAG_HW_PROG | SCRUB_FLAG_HW_SRC;\n\tmci->scrub_mode =\n\t\t((errcor & MCCFG_ERRCOR_ECC_CRR_EN) ? SCRUB_FLAG_HW_SRC : 0) |\n\t\t((scrub & MCCFG_SCRUB_RGLR_SCRB_EN) ? SCRUB_FLAG_HW_PROG : 0);\n\n\tif (pasemi_edac_init_csrows(mci, pdev,\n\t\t\t\t    (mci->edac_cap & EDAC_FLAG_SECDED) ?\n\t\t\t\t    EDAC_SECDED :\n\t\t\t\t    ((mci->edac_cap & EDAC_FLAG_EC) ?\n\t\t\t\t     EDAC_EC : EDAC_NONE)))\n\t\tgoto fail;\n\n\t \n\tpasemi_edac_get_error_info(mci);\n\n\tif (edac_mc_add_mc(mci))\n\t\tgoto fail;\n\n\t \n\treturn 0;\n\nfail:\n\tedac_mc_free(mci);\n\treturn -ENODEV;\n}\n\nstatic void pasemi_edac_remove(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci = edac_mc_del_mc(&pdev->dev);\n\n\tif (!mci)\n\t\treturn;\n\n\tedac_mc_free(mci);\n}\n\n\nstatic const struct pci_device_id pasemi_edac_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_PASEMI, 0xa00a) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, pasemi_edac_pci_tbl);\n\nstatic struct pci_driver pasemi_edac_driver = {\n\t.name = MODULE_NAME,\n\t.probe = pasemi_edac_probe,\n\t.remove = pasemi_edac_remove,\n\t.id_table = pasemi_edac_pci_tbl,\n};\n\nstatic int __init pasemi_edac_init(void)\n{\n        \n       opstate_init();\n\n\treturn pci_register_driver(&pasemi_edac_driver);\n}\n\nstatic void __exit pasemi_edac_exit(void)\n{\n\tpci_unregister_driver(&pasemi_edac_driver);\n}\n\nmodule_init(pasemi_edac_init);\nmodule_exit(pasemi_edac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Egor Martovetsky <egor@pasemi.com>\");\nMODULE_DESCRIPTION(\"MC support for PA Semi PWRficient memory controller\");\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}