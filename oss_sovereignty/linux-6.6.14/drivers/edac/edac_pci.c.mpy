{
  "module_name": "edac_pci.c",
  "hash_id": "ba692535a698c83a1172507eff0ab8388b3007531955f7f494ef1c5649bfb6bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_pci.c",
  "human_readable_source": "\n \n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/ctype.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/timer.h>\n\n#include \"edac_pci.h\"\n#include \"edac_module.h\"\n\nstatic DEFINE_MUTEX(edac_pci_ctls_mutex);\nstatic LIST_HEAD(edac_pci_list);\nstatic atomic_t pci_indexes = ATOMIC_INIT(0);\n\nstruct edac_pci_ctl_info *edac_pci_alloc_ctl_info(unsigned int sz_pvt,\n\t\t\t\t\t\t  const char *edac_pci_name)\n{\n\tstruct edac_pci_ctl_info *pci;\n\n\tedac_dbg(1, \"\\n\");\n\n\tpci = kzalloc(sizeof(struct edac_pci_ctl_info), GFP_KERNEL);\n\tif (!pci)\n\t\treturn NULL;\n\n\tif (sz_pvt) {\n\t\tpci->pvt_info = kzalloc(sz_pvt, GFP_KERNEL);\n\t\tif (!pci->pvt_info)\n\t\t\tgoto free;\n\t}\n\n\tpci->op_state = OP_ALLOC;\n\n\tsnprintf(pci->name, strlen(edac_pci_name) + 1, \"%s\", edac_pci_name);\n\n\treturn pci;\n\nfree:\n\tkfree(pci);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(edac_pci_alloc_ctl_info);\n\nvoid edac_pci_free_ctl_info(struct edac_pci_ctl_info *pci)\n{\n\tedac_dbg(1, \"\\n\");\n\n\tedac_pci_remove_sysfs(pci);\n}\nEXPORT_SYMBOL_GPL(edac_pci_free_ctl_info);\n\n \nstatic struct edac_pci_ctl_info *find_edac_pci_by_dev(struct device *dev)\n{\n\tstruct edac_pci_ctl_info *pci;\n\tstruct list_head *item;\n\n\tedac_dbg(1, \"\\n\");\n\n\tlist_for_each(item, &edac_pci_list) {\n\t\tpci = list_entry(item, struct edac_pci_ctl_info, link);\n\n\t\tif (pci->dev == dev)\n\t\t\treturn pci;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int add_edac_pci_to_global_list(struct edac_pci_ctl_info *pci)\n{\n\tstruct list_head *item, *insert_before;\n\tstruct edac_pci_ctl_info *rover;\n\n\tedac_dbg(1, \"\\n\");\n\n\tinsert_before = &edac_pci_list;\n\n\t \n\trover = find_edac_pci_by_dev(pci->dev);\n\tif (unlikely(rover != NULL))\n\t\tgoto fail0;\n\n\t \n\tlist_for_each(item, &edac_pci_list) {\n\t\trover = list_entry(item, struct edac_pci_ctl_info, link);\n\n\t\tif (rover->pci_idx >= pci->pci_idx) {\n\t\t\tif (unlikely(rover->pci_idx == pci->pci_idx))\n\t\t\t\tgoto fail1;\n\n\t\t\tinsert_before = item;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_add_tail_rcu(&pci->link, insert_before);\n\treturn 0;\n\nfail0:\n\tedac_printk(KERN_WARNING, EDAC_PCI,\n\t\t\"%s (%s) %s %s already assigned %d\\n\",\n\t\tdev_name(rover->dev), edac_dev_name(rover),\n\t\trover->mod_name, rover->ctl_name, rover->pci_idx);\n\treturn 1;\n\nfail1:\n\tedac_printk(KERN_WARNING, EDAC_PCI,\n\t\t\"but in low-level driver: attempt to assign\\n\"\n\t\t\"\\tduplicate pci_idx %d in %s()\\n\", rover->pci_idx,\n\t\t__func__);\n\treturn 1;\n}\n\n \nstatic void del_edac_pci_from_global_list(struct edac_pci_ctl_info *pci)\n{\n\tlist_del_rcu(&pci->link);\n\n\t \n\tsynchronize_rcu();\n\tINIT_LIST_HEAD(&pci->link);\n}\n\n \nstatic void edac_pci_workq_function(struct work_struct *work_req)\n{\n\tstruct delayed_work *d_work = to_delayed_work(work_req);\n\tstruct edac_pci_ctl_info *pci = to_edac_pci_ctl_work(d_work);\n\tint msec;\n\tunsigned long delay;\n\n\tedac_dbg(3, \"checking\\n\");\n\n\tmutex_lock(&edac_pci_ctls_mutex);\n\n\tif (pci->op_state != OP_RUNNING_POLL) {\n\t\tmutex_unlock(&edac_pci_ctls_mutex);\n\t\treturn;\n\t}\n\n\tif (edac_pci_get_check_errors())\n\t\tpci->edac_check(pci);\n\n\t \n\tmsec = edac_pci_get_poll_msec();\n\tif (msec == 1000)\n\t\tdelay = round_jiffies_relative(msecs_to_jiffies(msec));\n\telse\n\t\tdelay = msecs_to_jiffies(msec);\n\n\tedac_queue_work(&pci->work, delay);\n\n\tmutex_unlock(&edac_pci_ctls_mutex);\n}\n\nint edac_pci_alloc_index(void)\n{\n\treturn atomic_inc_return(&pci_indexes) - 1;\n}\nEXPORT_SYMBOL_GPL(edac_pci_alloc_index);\n\nint edac_pci_add_device(struct edac_pci_ctl_info *pci, int edac_idx)\n{\n\tedac_dbg(0, \"\\n\");\n\n\tpci->pci_idx = edac_idx;\n\tpci->start_time = jiffies;\n\n\tmutex_lock(&edac_pci_ctls_mutex);\n\n\tif (add_edac_pci_to_global_list(pci))\n\t\tgoto fail0;\n\n\tif (edac_pci_create_sysfs(pci)) {\n\t\tedac_pci_printk(pci, KERN_WARNING,\n\t\t\t\t\"failed to create sysfs pci\\n\");\n\t\tgoto fail1;\n\t}\n\n\tif (pci->edac_check) {\n\t\tpci->op_state = OP_RUNNING_POLL;\n\n\t\tINIT_DELAYED_WORK(&pci->work, edac_pci_workq_function);\n\t\tedac_queue_work(&pci->work, msecs_to_jiffies(edac_pci_get_poll_msec()));\n\n\t} else {\n\t\tpci->op_state = OP_RUNNING_INTERRUPT;\n\t}\n\n\tedac_pci_printk(pci, KERN_INFO,\n\t\t\"Giving out device to module %s controller %s: DEV %s (%s)\\n\",\n\t\tpci->mod_name, pci->ctl_name, pci->dev_name,\n\t\tedac_op_state_to_string(pci->op_state));\n\n\tmutex_unlock(&edac_pci_ctls_mutex);\n\treturn 0;\n\n\t \nfail1:\n\tdel_edac_pci_from_global_list(pci);\nfail0:\n\tmutex_unlock(&edac_pci_ctls_mutex);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(edac_pci_add_device);\n\nstruct edac_pci_ctl_info *edac_pci_del_device(struct device *dev)\n{\n\tstruct edac_pci_ctl_info *pci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tmutex_lock(&edac_pci_ctls_mutex);\n\n\t \n\tpci = find_edac_pci_by_dev(dev);\n\tif (pci  == NULL) {\n\t\tmutex_unlock(&edac_pci_ctls_mutex);\n\t\treturn NULL;\n\t}\n\n\tpci->op_state = OP_OFFLINE;\n\n\tdel_edac_pci_from_global_list(pci);\n\n\tmutex_unlock(&edac_pci_ctls_mutex);\n\n\tif (pci->edac_check)\n\t\tedac_stop_work(&pci->work);\n\n\tedac_printk(KERN_INFO, EDAC_PCI,\n\t\t\"Removed device %d for %s %s: DEV %s\\n\",\n\t\tpci->pci_idx, pci->mod_name, pci->ctl_name, edac_dev_name(pci));\n\n\treturn pci;\n}\nEXPORT_SYMBOL_GPL(edac_pci_del_device);\n\n \nstatic void edac_pci_generic_check(struct edac_pci_ctl_info *pci)\n{\n\tedac_dbg(4, \"\\n\");\n\tedac_pci_do_parity_check();\n}\n\n \nstatic int edac_pci_idx;\n#define EDAC_PCI_GENCTL_NAME\t\"EDAC PCI controller\"\n\nstruct edac_pci_gen_data {\n\tint edac_idx;\n};\n\nstruct edac_pci_ctl_info *edac_pci_create_generic_ctl(struct device *dev,\n\t\t\t\t\t\tconst char *mod_name)\n{\n\tstruct edac_pci_ctl_info *pci;\n\tstruct edac_pci_gen_data *pdata;\n\n\tpci = edac_pci_alloc_ctl_info(sizeof(*pdata), EDAC_PCI_GENCTL_NAME);\n\tif (!pci)\n\t\treturn NULL;\n\n\tpdata = pci->pvt_info;\n\tpci->dev = dev;\n\tdev_set_drvdata(pci->dev, pci);\n\tpci->dev_name = pci_name(to_pci_dev(dev));\n\n\tpci->mod_name = mod_name;\n\tpci->ctl_name = EDAC_PCI_GENCTL_NAME;\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tpci->edac_check = edac_pci_generic_check;\n\n\tpdata->edac_idx = edac_pci_idx++;\n\n\tif (edac_pci_add_device(pci, pdata->edac_idx) > 0) {\n\t\tedac_dbg(3, \"failed edac_pci_add_device()\\n\");\n\t\tedac_pci_free_ctl_info(pci);\n\t\treturn NULL;\n\t}\n\n\treturn pci;\n}\nEXPORT_SYMBOL_GPL(edac_pci_create_generic_ctl);\n\nvoid edac_pci_release_generic_ctl(struct edac_pci_ctl_info *pci)\n{\n\tedac_dbg(0, \"pci mod=%s\\n\", pci->mod_name);\n\n\tedac_pci_del_device(pci->dev);\n\tedac_pci_free_ctl_info(pci);\n}\nEXPORT_SYMBOL_GPL(edac_pci_release_generic_ctl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}