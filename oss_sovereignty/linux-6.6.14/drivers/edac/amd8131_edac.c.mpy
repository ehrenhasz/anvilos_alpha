{
  "module_name": "amd8131_edac.c",
  "hash_id": "2ad49d8633479221ea49b173aba997f6c37d60cd43f47c18f05900a4727c6eba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/amd8131_edac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/edac.h>\n#include <linux/pci_ids.h>\n\n#include \"edac_module.h\"\n#include \"amd8131_edac.h\"\n\n#define AMD8131_EDAC_REVISION\t\" Ver: 1.0.0\"\n#define AMD8131_EDAC_MOD_STR\t\"amd8131_edac\"\n\n \nstatic void edac_pci_read_dword(struct pci_dev *dev, int reg, u32 *val32)\n{\n\tint ret;\n\n\tret = pci_read_config_dword(dev, reg, val32);\n\tif (ret != 0)\n\t\tprintk(KERN_ERR AMD8131_EDAC_MOD_STR\n\t\t\t\" PCI Access Read Error at 0x%x\\n\", reg);\n}\n\nstatic void edac_pci_write_dword(struct pci_dev *dev, int reg, u32 val32)\n{\n\tint ret;\n\n\tret = pci_write_config_dword(dev, reg, val32);\n\tif (ret != 0)\n\t\tprintk(KERN_ERR AMD8131_EDAC_MOD_STR\n\t\t\t\" PCI Access Write Error at 0x%x\\n\", reg);\n}\n\n \nstatic struct amd8131_dev_info amd8131_devices[] = {\n\t{\n\t.inst = NORTH_A,\n\t.devfn = DEVFN_PCIX_BRIDGE_NORTH_A,\n\t.ctl_name = \"AMD8131_PCIX_NORTH_A\",\n\t},\n\t{\n\t.inst = NORTH_B,\n\t.devfn = DEVFN_PCIX_BRIDGE_NORTH_B,\n\t.ctl_name = \"AMD8131_PCIX_NORTH_B\",\n\t},\n\t{\n\t.inst = SOUTH_A,\n\t.devfn = DEVFN_PCIX_BRIDGE_SOUTH_A,\n\t.ctl_name = \"AMD8131_PCIX_SOUTH_A\",\n\t},\n\t{\n\t.inst = SOUTH_B,\n\t.devfn = DEVFN_PCIX_BRIDGE_SOUTH_B,\n\t.ctl_name = \"AMD8131_PCIX_SOUTH_B\",\n\t},\n\t{.inst = NO_BRIDGE,},\n};\n\nstatic void amd8131_pcix_init(struct amd8131_dev_info *dev_info)\n{\n\tu32 val32;\n\tstruct pci_dev *dev = dev_info->dev;\n\n\t \n\tedac_pci_read_dword(dev, REG_MEM_LIM, &val32);\n\tif (val32 & MEM_LIMIT_MASK)\n\t\tedac_pci_write_dword(dev, REG_MEM_LIM, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_INT_CTLR, &val32);\n\tif (val32 & INT_CTLR_DTS)\n\t\tedac_pci_write_dword(dev, REG_INT_CTLR, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_LNK_CTRL_A, &val32);\n\tif (val32 & LNK_CTRL_CRCERR_A)\n\t\tedac_pci_write_dword(dev, REG_LNK_CTRL_A, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_LNK_CTRL_B, &val32);\n\tif (val32 & LNK_CTRL_CRCERR_B)\n\t\tedac_pci_write_dword(dev, REG_LNK_CTRL_B, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_INT_CTLR, &val32);\n\tval32 |= INT_CTLR_PERR | INT_CTLR_SERR | INT_CTLR_DTSE;\n\tedac_pci_write_dword(dev, REG_INT_CTLR, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_STS_CMD, &val32);\n\tval32 |= STS_CMD_SERREN;\n\tedac_pci_write_dword(dev, REG_STS_CMD, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_LNK_CTRL_A, &val32);\n\tval32 |= LNK_CTRL_CRCFEN;\n\tedac_pci_write_dword(dev, REG_LNK_CTRL_A, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_LNK_CTRL_B, &val32);\n\tval32 |= LNK_CTRL_CRCFEN;\n\tedac_pci_write_dword(dev, REG_LNK_CTRL_B, val32);\n}\n\nstatic void amd8131_pcix_exit(struct amd8131_dev_info *dev_info)\n{\n\tu32 val32;\n\tstruct pci_dev *dev = dev_info->dev;\n\n\t \n\tedac_pci_read_dword(dev, REG_INT_CTLR, &val32);\n\tval32 &= ~(INT_CTLR_PERR | INT_CTLR_SERR | INT_CTLR_DTSE);\n\tedac_pci_write_dword(dev, REG_INT_CTLR, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_STS_CMD, &val32);\n\tval32 &= ~STS_CMD_SERREN;\n\tedac_pci_write_dword(dev, REG_STS_CMD, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_LNK_CTRL_A, &val32);\n\tval32 &= ~LNK_CTRL_CRCFEN;\n\tedac_pci_write_dword(dev, REG_LNK_CTRL_A, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_LNK_CTRL_B, &val32);\n\tval32 &= ~LNK_CTRL_CRCFEN;\n\tedac_pci_write_dword(dev, REG_LNK_CTRL_B, val32);\n}\n\nstatic void amd8131_pcix_check(struct edac_pci_ctl_info *edac_dev)\n{\n\tstruct amd8131_dev_info *dev_info = edac_dev->pvt_info;\n\tstruct pci_dev *dev = dev_info->dev;\n\tu32 val32;\n\n\t \n\tedac_pci_read_dword(dev, REG_MEM_LIM, &val32);\n\tif (val32 & MEM_LIMIT_MASK) {\n\t\tprintk(KERN_INFO \"Error(s) in mem limit register \"\n\t\t\t\"on %s bridge\\n\", dev_info->ctl_name);\n\t\tprintk(KERN_INFO \"DPE: %d, RSE: %d, RMA: %d\\n\"\n\t\t\t\"RTA: %d, STA: %d, MDPE: %d\\n\",\n\t\t\tval32 & MEM_LIMIT_DPE,\n\t\t\tval32 & MEM_LIMIT_RSE,\n\t\t\tval32 & MEM_LIMIT_RMA,\n\t\t\tval32 & MEM_LIMIT_RTA,\n\t\t\tval32 & MEM_LIMIT_STA,\n\t\t\tval32 & MEM_LIMIT_MDPE);\n\n\t\tval32 |= MEM_LIMIT_MASK;\n\t\tedac_pci_write_dword(dev, REG_MEM_LIM, val32);\n\n\t\tedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\n\t}\n\n\t \n\tedac_pci_read_dword(dev, REG_INT_CTLR, &val32);\n\tif (val32 & INT_CTLR_DTS) {\n\t\tprintk(KERN_INFO \"Error(s) in interrupt and control register \"\n\t\t\t\"on %s bridge\\n\", dev_info->ctl_name);\n\t\tprintk(KERN_INFO \"DTS: %d\\n\", val32 & INT_CTLR_DTS);\n\n\t\tval32 |= INT_CTLR_DTS;\n\t\tedac_pci_write_dword(dev, REG_INT_CTLR, val32);\n\n\t\tedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\n\t}\n\n\t \n\tedac_pci_read_dword(dev, REG_LNK_CTRL_A, &val32);\n\tif (val32 & LNK_CTRL_CRCERR_A) {\n\t\tprintk(KERN_INFO \"Error(s) in link conf and control register \"\n\t\t\t\"on %s bridge\\n\", dev_info->ctl_name);\n\t\tprintk(KERN_INFO \"CRCERR: %d\\n\", val32 & LNK_CTRL_CRCERR_A);\n\n\t\tval32 |= LNK_CTRL_CRCERR_A;\n\t\tedac_pci_write_dword(dev, REG_LNK_CTRL_A, val32);\n\n\t\tedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\n\t}\n\n\t \n\tedac_pci_read_dword(dev, REG_LNK_CTRL_B, &val32);\n\tif (val32 & LNK_CTRL_CRCERR_B) {\n\t\tprintk(KERN_INFO \"Error(s) in link conf and control register \"\n\t\t\t\"on %s bridge\\n\", dev_info->ctl_name);\n\t\tprintk(KERN_INFO \"CRCERR: %d\\n\", val32 & LNK_CTRL_CRCERR_B);\n\n\t\tval32 |= LNK_CTRL_CRCERR_B;\n\t\tedac_pci_write_dword(dev, REG_LNK_CTRL_B, val32);\n\n\t\tedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\n\t}\n}\n\nstatic struct amd8131_info amd8131_chipset = {\n\t.err_dev = PCI_DEVICE_ID_AMD_8131_APIC,\n\t.devices = amd8131_devices,\n\t.init = amd8131_pcix_init,\n\t.exit = amd8131_pcix_exit,\n\t.check = amd8131_pcix_check,\n};\n\n \nstatic int amd8131_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct amd8131_dev_info *dev_info;\n\n\tfor (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE;\n\t\tdev_info++)\n\t\tif (dev_info->devfn == dev->devfn)\n\t\t\tbreak;\n\n\tif (dev_info->inst == NO_BRIDGE)  \n\t\treturn -ENODEV;\n\n\t \n\tdev_info->dev = pci_dev_get(dev);\n\n\tif (pci_enable_device(dev_info->dev)) {\n\t\tpci_dev_put(dev_info->dev);\n\t\tprintk(KERN_ERR \"failed to enable:\"\n\t\t\t\"vendor %x, device %x, devfn %x, name %s\\n\",\n\t\t\tPCI_VENDOR_ID_AMD, amd8131_chipset.err_dev,\n\t\t\tdev_info->devfn, dev_info->ctl_name);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev_info->edac_idx = edac_pci_alloc_index();\n\tdev_info->edac_dev = edac_pci_alloc_ctl_info(0, dev_info->ctl_name);\n\tif (!dev_info->edac_dev)\n\t\treturn -ENOMEM;\n\n\tdev_info->edac_dev->pvt_info = dev_info;\n\tdev_info->edac_dev->dev = &dev_info->dev->dev;\n\tdev_info->edac_dev->mod_name = AMD8131_EDAC_MOD_STR;\n\tdev_info->edac_dev->ctl_name = dev_info->ctl_name;\n\tdev_info->edac_dev->dev_name = dev_name(&dev_info->dev->dev);\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tdev_info->edac_dev->edac_check = amd8131_chipset.check;\n\n\tif (amd8131_chipset.init)\n\t\tamd8131_chipset.init(dev_info);\n\n\tif (edac_pci_add_device(dev_info->edac_dev, dev_info->edac_idx) > 0) {\n\t\tprintk(KERN_ERR \"failed edac_pci_add_device() for %s\\n\",\n\t\t\tdev_info->ctl_name);\n\t\tedac_pci_free_ctl_info(dev_info->edac_dev);\n\t\treturn -ENODEV;\n\t}\n\n\tprintk(KERN_INFO \"added one device on AMD8131 \"\n\t\t\"vendor %x, device %x, devfn %x, name %s\\n\",\n\t\tPCI_VENDOR_ID_AMD, amd8131_chipset.err_dev,\n\t\tdev_info->devfn, dev_info->ctl_name);\n\n\treturn 0;\n}\n\nstatic void amd8131_remove(struct pci_dev *dev)\n{\n\tstruct amd8131_dev_info *dev_info;\n\n\tfor (dev_info = amd8131_chipset.devices; dev_info->inst != NO_BRIDGE;\n\t\tdev_info++)\n\t\tif (dev_info->devfn == dev->devfn)\n\t\t\tbreak;\n\n\tif (dev_info->inst == NO_BRIDGE)  \n\t\treturn;\n\n\tif (dev_info->edac_dev) {\n\t\tedac_pci_del_device(dev_info->edac_dev->dev);\n\t\tedac_pci_free_ctl_info(dev_info->edac_dev);\n\t}\n\n\tif (amd8131_chipset.exit)\n\t\tamd8131_chipset.exit(dev_info);\n\n\tpci_dev_put(dev_info->dev);\n}\n\nstatic const struct pci_device_id amd8131_edac_pci_tbl[] = {\n\t{\n\tPCI_VEND_DEV(AMD, 8131_BRIDGE),\n\t.subvendor = PCI_ANY_ID,\n\t.subdevice = PCI_ANY_ID,\n\t.class = 0,\n\t.class_mask = 0,\n\t.driver_data = 0,\n\t},\n\t{\n\t0,\n\t}\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, amd8131_edac_pci_tbl);\n\nstatic struct pci_driver amd8131_edac_driver = {\n\t.name = AMD8131_EDAC_MOD_STR,\n\t.probe = amd8131_probe,\n\t.remove = amd8131_remove,\n\t.id_table = amd8131_edac_pci_tbl,\n};\n\nstatic int __init amd8131_edac_init(void)\n{\n\tprintk(KERN_INFO \"AMD8131 EDAC driver \" AMD8131_EDAC_REVISION \"\\n\");\n\tprintk(KERN_INFO \"\\t(c) 2008 Wind River Systems, Inc.\\n\");\n\n\t \n\tedac_op_state = EDAC_OPSTATE_POLL;\n\n\treturn pci_register_driver(&amd8131_edac_driver);\n}\n\nstatic void __exit amd8131_edac_exit(void)\n{\n\tpci_unregister_driver(&amd8131_edac_driver);\n}\n\nmodule_init(amd8131_edac_init);\nmodule_exit(amd8131_edac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cao Qingtao <qingtao.cao@windriver.com>\");\nMODULE_DESCRIPTION(\"AMD8131 HyperTransport PCI-X Tunnel EDAC kernel module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}