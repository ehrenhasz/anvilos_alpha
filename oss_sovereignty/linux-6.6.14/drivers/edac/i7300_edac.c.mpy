{
  "module_name": "i7300_edac.c",
  "hash_id": "ff566cf13ea297cf4e6fc58cfb963c6ffcafc38dcd253ad0a47553b0b12a421c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i7300_edac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/slab.h>\n#include <linux/edac.h>\n#include <linux/mmzone.h>\n\n#include \"edac_module.h\"\n\n \n#define I7300_REVISION    \" Ver: 1.0.0\"\n\n#define EDAC_MOD_STR      \"i7300_edac\"\n\n#define i7300_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"i7300\", fmt, ##arg)\n\n#define i7300_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"i7300\", fmt, ##arg)\n\n \n\n \n\n \n#define MAX_SLOTS\t\t8\n#define MAX_BRANCHES\t\t2\n#define MAX_CH_PER_BRANCH\t2\n#define MAX_CHANNELS\t\t(MAX_CH_PER_BRANCH * MAX_BRANCHES)\n#define MAX_MIR\t\t\t3\n\n#define to_channel(ch, branch)\t((((branch)) << 1) | (ch))\n\n#define to_csrow(slot, ch, branch)\t\t\t\t\t\\\n\t\t(to_channel(ch, branch) | ((slot) << 2))\n\n \nstruct i7300_dev_info {\n\tconst char *ctl_name;\t \n\tu16 fsb_mapping_errors;\t \n};\n\n \nstatic const struct i7300_dev_info i7300_devs[] = {\n\t{\n\t\t.ctl_name = \"I7300\",\n\t\t.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,\n\t},\n};\n\nstruct i7300_dimm_info {\n\tint megabytes;\t\t \n};\n\n \nstruct i7300_pvt {\n\tstruct pci_dev *pci_dev_16_0_fsb_ctlr;\t\t \n\tstruct pci_dev *pci_dev_16_1_fsb_addr_map;\t \n\tstruct pci_dev *pci_dev_16_2_fsb_err_regs;\t \n\tstruct pci_dev *pci_dev_2x_0_fbd_branch[MAX_BRANCHES];\t \n\n\tu16 tolm;\t\t\t\t \n\tu64 ambase;\t\t\t\t \n\n\tu32 mc_settings;\t\t\t \n\tu32 mc_settings_a;\n\n\tu16 mir[MAX_MIR];\t\t\t \n\n\tu16 mtr[MAX_SLOTS][MAX_BRANCHES];\t \n\tu16 ambpresent[MAX_CHANNELS];\t\t \n\n\t \n\tstruct i7300_dimm_info dimm_info[MAX_SLOTS][MAX_CHANNELS];\n\n\t \n\tchar *tmp_prt_buffer;\n};\n\n \nstatic struct edac_pci_ctl_info *i7300_pci;\n\n \n\n \n\n\t \n#define AMBASE\t\t\t0x48  \n#define MAXCH\t\t\t0x56  \n#define MAXDIMMPERCH\t\t0x57  \n\n\t \n#define MC_SETTINGS\t\t0x40\n  #define IS_MIRRORED(mc)\t\t((mc) & (1 << 16))\n  #define IS_ECC_ENABLED(mc)\t\t((mc) & (1 << 5))\n  #define IS_RETRY_ENABLED(mc)\t\t((mc) & (1 << 31))\n  #define IS_SCRBALGO_ENHANCED(mc)\t((mc) & (1 << 8))\n\n#define MC_SETTINGS_A\t\t0x58\n  #define IS_SINGLE_MODE(mca)\t\t((mca) & (1 << 14))\n\n#define TOLM\t\t\t0x6C\n\n#define MIR0\t\t\t0x80\n#define MIR1\t\t\t0x84\n#define MIR2\t\t\t0x88\n\n \n#define AMBPRESENT_0\t0x64\n#define AMBPRESENT_1\t0x66\n\nstatic const u16 mtr_regs[MAX_SLOTS] = {\n\t0x80, 0x84, 0x88, 0x8c,\n\t0x82, 0x86, 0x8a, 0x8e\n};\n\n \n#define MTR_DIMMS_PRESENT(mtr)\t\t((mtr) & (1 << 8))\n#define MTR_DIMMS_ETHROTTLE(mtr)\t((mtr) & (1 << 7))\n#define MTR_DRAM_WIDTH(mtr)\t\t(((mtr) & (1 << 6)) ? 8 : 4)\n#define MTR_DRAM_BANKS(mtr)\t\t(((mtr) & (1 << 5)) ? 8 : 4)\n#define MTR_DIMM_RANKS(mtr)\t\t(((mtr) & (1 << 4)) ? 1 : 0)\n#define MTR_DIMM_ROWS(mtr)\t\t(((mtr) >> 2) & 0x3)\n#define MTR_DRAM_BANKS_ADDR_BITS\t2\n#define MTR_DIMM_ROWS_ADDR_BITS(mtr)\t(MTR_DIMM_ROWS(mtr) + 13)\n#define MTR_DIMM_COLS(mtr)\t\t((mtr) & 0x3)\n#define MTR_DIMM_COLS_ADDR_BITS(mtr)\t(MTR_DIMM_COLS(mtr) + 10)\n\n \n\n \n#define FERR_FAT_FBD\t0x98\nstatic const char *ferr_fat_fbd_name[] = {\n\t[22] = \"Non-Redundant Fast Reset Timeout\",\n\t[2]  = \">Tmid Thermal event with intelligent throttling disabled\",\n\t[1]  = \"Memory or FBD configuration CRC read error\",\n\t[0]  = \"Memory Write error on non-redundant retry or \"\n\t       \"FBD configuration Write error on retry\",\n};\n#define GET_FBD_FAT_IDX(fbderr)\t(((fbderr) >> 28) & 3)\n#define FERR_FAT_FBD_ERR_MASK ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 22))\n\n#define FERR_NF_FBD\t0xa0\nstatic const char *ferr_nf_fbd_name[] = {\n\t[24] = \"DIMM-Spare Copy Completed\",\n\t[23] = \"DIMM-Spare Copy Initiated\",\n\t[22] = \"Redundant Fast Reset Timeout\",\n\t[21] = \"Memory Write error on redundant retry\",\n\t[18] = \"SPD protocol Error\",\n\t[17] = \"FBD Northbound parity error on FBD Sync Status\",\n\t[16] = \"Correctable Patrol Data ECC\",\n\t[15] = \"Correctable Resilver- or Spare-Copy Data ECC\",\n\t[14] = \"Correctable Mirrored Demand Data ECC\",\n\t[13] = \"Correctable Non-Mirrored Demand Data ECC\",\n\t[11] = \"Memory or FBD configuration CRC read error\",\n\t[10] = \"FBD Configuration Write error on first attempt\",\n\t[9]  = \"Memory Write error on first attempt\",\n\t[8]  = \"Non-Aliased Uncorrectable Patrol Data ECC\",\n\t[7]  = \"Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC\",\n\t[6]  = \"Non-Aliased Uncorrectable Mirrored Demand Data ECC\",\n\t[5]  = \"Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC\",\n\t[4]  = \"Aliased Uncorrectable Patrol Data ECC\",\n\t[3]  = \"Aliased Uncorrectable Resilver- or Spare-Copy Data ECC\",\n\t[2]  = \"Aliased Uncorrectable Mirrored Demand Data ECC\",\n\t[1]  = \"Aliased Uncorrectable Non-Mirrored Demand Data ECC\",\n\t[0]  = \"Uncorrectable Data ECC on Replay\",\n};\n#define GET_FBD_NF_IDX(fbderr)\t(((fbderr) >> 28) & 3)\n#define FERR_NF_FBD_ERR_MASK ((1 << 24) | (1 << 23) | (1 << 22) | (1 << 21) |\\\n\t\t\t      (1 << 18) | (1 << 17) | (1 << 16) | (1 << 15) |\\\n\t\t\t      (1 << 14) | (1 << 13) | (1 << 11) | (1 << 10) |\\\n\t\t\t      (1 << 9)  | (1 << 8)  | (1 << 7)  | (1 << 6)  |\\\n\t\t\t      (1 << 5)  | (1 << 4)  | (1 << 3)  | (1 << 2)  |\\\n\t\t\t      (1 << 1)  | (1 << 0))\n\n#define EMASK_FBD\t0xa8\n#define EMASK_FBD_ERR_MASK ((1 << 27) | (1 << 26) | (1 << 25) | (1 << 24) |\\\n\t\t\t    (1 << 22) | (1 << 21) | (1 << 20) | (1 << 19) |\\\n\t\t\t    (1 << 18) | (1 << 17) | (1 << 16) | (1 << 14) |\\\n\t\t\t    (1 << 13) | (1 << 12) | (1 << 11) | (1 << 10) |\\\n\t\t\t    (1 << 9)  | (1 << 8)  | (1 << 7)  | (1 << 6)  |\\\n\t\t\t    (1 << 5)  | (1 << 4)  | (1 << 3)  | (1 << 2)  |\\\n\t\t\t    (1 << 1)  | (1 << 0))\n\n \n\n#define FERR_GLOBAL_HI\t0x48\nstatic const char *ferr_global_hi_name[] = {\n\t[3] = \"FSB 3 Fatal Error\",\n\t[2] = \"FSB 2 Fatal Error\",\n\t[1] = \"FSB 1 Fatal Error\",\n\t[0] = \"FSB 0 Fatal Error\",\n};\n#define ferr_global_hi_is_fatal(errno)\t1\n\n#define FERR_GLOBAL_LO\t0x40\nstatic const char *ferr_global_lo_name[] = {\n\t[31] = \"Internal MCH Fatal Error\",\n\t[30] = \"Intel QuickData Technology Device Fatal Error\",\n\t[29] = \"FSB1 Fatal Error\",\n\t[28] = \"FSB0 Fatal Error\",\n\t[27] = \"FBD Channel 3 Fatal Error\",\n\t[26] = \"FBD Channel 2 Fatal Error\",\n\t[25] = \"FBD Channel 1 Fatal Error\",\n\t[24] = \"FBD Channel 0 Fatal Error\",\n\t[23] = \"PCI Express Device 7Fatal Error\",\n\t[22] = \"PCI Express Device 6 Fatal Error\",\n\t[21] = \"PCI Express Device 5 Fatal Error\",\n\t[20] = \"PCI Express Device 4 Fatal Error\",\n\t[19] = \"PCI Express Device 3 Fatal Error\",\n\t[18] = \"PCI Express Device 2 Fatal Error\",\n\t[17] = \"PCI Express Device 1 Fatal Error\",\n\t[16] = \"ESI Fatal Error\",\n\t[15] = \"Internal MCH Non-Fatal Error\",\n\t[14] = \"Intel QuickData Technology Device Non Fatal Error\",\n\t[13] = \"FSB1 Non-Fatal Error\",\n\t[12] = \"FSB 0 Non-Fatal Error\",\n\t[11] = \"FBD Channel 3 Non-Fatal Error\",\n\t[10] = \"FBD Channel 2 Non-Fatal Error\",\n\t[9]  = \"FBD Channel 1 Non-Fatal Error\",\n\t[8]  = \"FBD Channel 0 Non-Fatal Error\",\n\t[7]  = \"PCI Express Device 7 Non-Fatal Error\",\n\t[6]  = \"PCI Express Device 6 Non-Fatal Error\",\n\t[5]  = \"PCI Express Device 5 Non-Fatal Error\",\n\t[4]  = \"PCI Express Device 4 Non-Fatal Error\",\n\t[3]  = \"PCI Express Device 3 Non-Fatal Error\",\n\t[2]  = \"PCI Express Device 2 Non-Fatal Error\",\n\t[1]  = \"PCI Express Device 1 Non-Fatal Error\",\n\t[0]  = \"ESI Non-Fatal Error\",\n};\n#define ferr_global_lo_is_fatal(errno)\t((errno < 16) ? 0 : 1)\n\n#define NRECMEMA\t0xbe\n  #define NRECMEMA_BANK(v)\t(((v) >> 12) & 7)\n  #define NRECMEMA_RANK(v)\t(((v) >> 8) & 15)\n\n#define NRECMEMB\t0xc0\n  #define NRECMEMB_IS_WR(v)\t((v) & (1 << 31))\n  #define NRECMEMB_CAS(v)\t(((v) >> 16) & 0x1fff)\n  #define NRECMEMB_RAS(v)\t((v) & 0xffff)\n\n#define REDMEMA\t\t0xdc\n\n#define REDMEMB\t\t0x7c\n\n#define RECMEMA\t\t0xe0\n  #define RECMEMA_BANK(v)\t(((v) >> 12) & 7)\n  #define RECMEMA_RANK(v)\t(((v) >> 8) & 15)\n\n#define RECMEMB\t\t0xe4\n  #define RECMEMB_IS_WR(v)\t((v) & (1 << 31))\n  #define RECMEMB_CAS(v)\t(((v) >> 16) & 0x1fff)\n  #define RECMEMB_RAS(v)\t((v) & 0xffff)\n\n \n\n \nstatic const char *get_err_from_table(const char *table[], int size, int pos)\n{\n\tif (unlikely(pos >= size))\n\t\treturn \"Reserved\";\n\n\tif (unlikely(!table[pos]))\n\t\treturn \"Reserved\";\n\n\treturn table[pos];\n}\n\n#define GET_ERR_FROM_TABLE(table, pos)\t\t\t\t\\\n\tget_err_from_table(table, ARRAY_SIZE(table), pos)\n\n \nstatic void i7300_process_error_global(struct mem_ctl_info *mci)\n{\n\tstruct i7300_pvt *pvt;\n\tu32 errnum, error_reg;\n\tunsigned long errors;\n\tconst char *specific;\n\tbool is_fatal;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\n\t\t\t      FERR_GLOBAL_HI, &error_reg);\n\tif (unlikely(error_reg)) {\n\t\terrors = error_reg;\n\t\terrnum = find_first_bit(&errors,\n\t\t\t\t\tARRAY_SIZE(ferr_global_hi_name));\n\t\tspecific = GET_ERR_FROM_TABLE(ferr_global_hi_name, errnum);\n\t\tis_fatal = ferr_global_hi_is_fatal(errnum);\n\n\t\t \n\t\tpci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\n\t\t\t\t       FERR_GLOBAL_HI, error_reg);\n\n\t\tgoto error_global;\n\t}\n\n\tpci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\n\t\t\t      FERR_GLOBAL_LO, &error_reg);\n\tif (unlikely(error_reg)) {\n\t\terrors = error_reg;\n\t\terrnum = find_first_bit(&errors,\n\t\t\t\t\tARRAY_SIZE(ferr_global_lo_name));\n\t\tspecific = GET_ERR_FROM_TABLE(ferr_global_lo_name, errnum);\n\t\tis_fatal = ferr_global_lo_is_fatal(errnum);\n\n\t\t \n\t\tpci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\n\t\t\t\t       FERR_GLOBAL_LO, error_reg);\n\n\t\tgoto error_global;\n\t}\n\treturn;\n\nerror_global:\n\ti7300_mc_printk(mci, KERN_EMERG, \"%s misc error: %s\\n\",\n\t\t\tis_fatal ? \"Fatal\" : \"NOT fatal\", specific);\n}\n\n \nstatic void i7300_process_fbd_error(struct mem_ctl_info *mci)\n{\n\tstruct i7300_pvt *pvt;\n\tu32 errnum, value, error_reg;\n\tu16 val16;\n\tunsigned branch, channel, bank, rank, cas, ras;\n\tu32 syndrome;\n\n\tunsigned long errors;\n\tconst char *specific;\n\tbool is_wr;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t      FERR_FAT_FBD, &error_reg);\n\tif (unlikely(error_reg & FERR_FAT_FBD_ERR_MASK)) {\n\t\terrors = error_reg & FERR_FAT_FBD_ERR_MASK ;\n\t\terrnum = find_first_bit(&errors,\n\t\t\t\t\tARRAY_SIZE(ferr_fat_fbd_name));\n\t\tspecific = GET_ERR_FROM_TABLE(ferr_fat_fbd_name, errnum);\n\t\tbranch = (GET_FBD_FAT_IDX(error_reg) == 2) ? 1 : 0;\n\n\t\tpci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t\t     NRECMEMA, &val16);\n\t\tbank = NRECMEMA_BANK(val16);\n\t\trank = NRECMEMA_RANK(val16);\n\n\t\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t\tNRECMEMB, &value);\n\t\tis_wr = NRECMEMB_IS_WR(value);\n\t\tcas = NRECMEMB_CAS(value);\n\t\tras = NRECMEMB_RAS(value);\n\n\t\t \n\t\tpci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t\tFERR_FAT_FBD, error_reg);\n\n\t\tsnprintf(pvt->tmp_prt_buffer, PAGE_SIZE,\n\t\t\t \"Bank=%d RAS=%d CAS=%d Err=0x%lx (%s))\",\n\t\t\t bank, ras, cas, errors, specific);\n\n\t\tedac_mc_handle_error(HW_EVENT_ERR_FATAL, mci, 1, 0, 0, 0,\n\t\t\t\t     branch, -1, rank,\n\t\t\t\t     is_wr ? \"Write error\" : \"Read error\",\n\t\t\t\t     pvt->tmp_prt_buffer);\n\n\t}\n\n\t \n\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t      FERR_NF_FBD, &error_reg);\n\tif (unlikely(error_reg & FERR_NF_FBD_ERR_MASK)) {\n\t\terrors = error_reg & FERR_NF_FBD_ERR_MASK;\n\t\terrnum = find_first_bit(&errors,\n\t\t\t\t\tARRAY_SIZE(ferr_nf_fbd_name));\n\t\tspecific = GET_ERR_FROM_TABLE(ferr_nf_fbd_name, errnum);\n\t\tbranch = (GET_FBD_NF_IDX(error_reg) == 2) ? 1 : 0;\n\n\t\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\tREDMEMA, &syndrome);\n\n\t\tpci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t\t     RECMEMA, &val16);\n\t\tbank = RECMEMA_BANK(val16);\n\t\trank = RECMEMA_RANK(val16);\n\n\t\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t\tRECMEMB, &value);\n\t\tis_wr = RECMEMB_IS_WR(value);\n\t\tcas = RECMEMB_CAS(value);\n\t\tras = RECMEMB_RAS(value);\n\n\t\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t\t     REDMEMB, &value);\n\t\tchannel = (branch << 1);\n\n\t\t \n\t\tchannel += !!(value & BIT(17));\n\n\t\t \n\t\tpci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t\tFERR_NF_FBD, error_reg);\n\n\t\t \n\t\tsnprintf(pvt->tmp_prt_buffer, PAGE_SIZE,\n\t\t\t \"DRAM-Bank=%d RAS=%d CAS=%d, Err=0x%lx (%s))\",\n\t\t\t bank, ras, cas, errors, specific);\n\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0,\n\t\t\t\t     syndrome,\n\t\t\t\t     branch >> 1, channel % 2, rank,\n\t\t\t\t     is_wr ? \"Write error\" : \"Read error\",\n\t\t\t\t     pvt->tmp_prt_buffer);\n\t}\n\treturn;\n}\n\n \nstatic void i7300_check_error(struct mem_ctl_info *mci)\n{\n\ti7300_process_error_global(mci);\n\ti7300_process_fbd_error(mci);\n};\n\n \nstatic void i7300_clear_error(struct mem_ctl_info *mci)\n{\n\tstruct i7300_pvt *pvt = mci->pvt_info;\n\tu32 value;\n\t \n\n\t \n\tpci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\n\t\t\t      FERR_GLOBAL_HI, &value);\n\tpci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\n\t\t\t      FERR_GLOBAL_HI, value);\n\n\tpci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\n\t\t\t      FERR_GLOBAL_LO, &value);\n\tpci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\n\t\t\t      FERR_GLOBAL_LO, value);\n\n\t \n\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t      FERR_FAT_FBD, &value);\n\tpci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t      FERR_FAT_FBD, value);\n\n\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t      FERR_NF_FBD, &value);\n\tpci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t      FERR_NF_FBD, value);\n}\n\n \nstatic void i7300_enable_error_reporting(struct mem_ctl_info *mci)\n{\n\tstruct i7300_pvt *pvt = mci->pvt_info;\n\tu32 fbd_error_mask;\n\n\t \n\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t      EMASK_FBD, &fbd_error_mask);\n\n\t \n\tfbd_error_mask &= ~(EMASK_FBD_ERR_MASK);\n\n\tpci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\n\t\t\t       EMASK_FBD, fbd_error_mask);\n}\n\n \n\n \nstatic int decode_mtr(struct i7300_pvt *pvt,\n\t\t      int slot, int ch, int branch,\n\t\t      struct i7300_dimm_info *dinfo,\n\t\t      struct dimm_info *dimm)\n{\n\tint mtr, ans, addrBits, channel;\n\n\tchannel = to_channel(ch, branch);\n\n\tmtr = pvt->mtr[slot][branch];\n\tans = MTR_DIMMS_PRESENT(mtr) ? 1 : 0;\n\n\tedac_dbg(2, \"\\tMTR%d CH%d: DIMMs are %sPresent (mtr)\\n\",\n\t\t slot, channel, ans ? \"\" : \"NOT \");\n\n\t \n\tif (!ans)\n\t\treturn 0;\n\n\t \n\taddrBits = MTR_DRAM_BANKS_ADDR_BITS;\n\t \n\taddrBits += MTR_DIMM_ROWS_ADDR_BITS(mtr);\n\t \n\taddrBits += MTR_DIMM_COLS_ADDR_BITS(mtr);\n\t \n\taddrBits += MTR_DIMM_RANKS(mtr);\n\n\taddrBits += 6;\t \n\taddrBits -= 20;\t \n\taddrBits -= 3;\t \n\n\tdinfo->megabytes = 1 << addrBits;\n\n\tedac_dbg(2, \"\\t\\tWIDTH: x%d\\n\", MTR_DRAM_WIDTH(mtr));\n\n\tedac_dbg(2, \"\\t\\tELECTRICAL THROTTLING is %s\\n\",\n\t\t MTR_DIMMS_ETHROTTLE(mtr) ? \"enabled\" : \"disabled\");\n\n\tedac_dbg(2, \"\\t\\tNUMBANK: %d bank(s)\\n\", MTR_DRAM_BANKS(mtr));\n\tedac_dbg(2, \"\\t\\tNUMRANK: %s\\n\",\n\t\t MTR_DIMM_RANKS(mtr) ? \"double\" : \"single\");\n\tedac_dbg(2, \"\\t\\tNUMROW: %s\\n\",\n\t\t MTR_DIMM_ROWS(mtr) == 0 ? \"8,192 - 13 rows\" :\n\t\t MTR_DIMM_ROWS(mtr) == 1 ? \"16,384 - 14 rows\" :\n\t\t MTR_DIMM_ROWS(mtr) == 2 ? \"32,768 - 15 rows\" :\n\t\t \"65,536 - 16 rows\");\n\tedac_dbg(2, \"\\t\\tNUMCOL: %s\\n\",\n\t\t MTR_DIMM_COLS(mtr) == 0 ? \"1,024 - 10 columns\" :\n\t\t MTR_DIMM_COLS(mtr) == 1 ? \"2,048 - 11 columns\" :\n\t\t MTR_DIMM_COLS(mtr) == 2 ? \"4,096 - 12 columns\" :\n\t\t \"reserved\");\n\tedac_dbg(2, \"\\t\\tSIZE: %d MB\\n\", dinfo->megabytes);\n\n\t \n\n\tdimm->nr_pages = MiB_TO_PAGES(dinfo->megabytes);\n\tdimm->grain = 8;\n\tdimm->mtype = MEM_FB_DDR2;\n\tif (IS_SINGLE_MODE(pvt->mc_settings_a)) {\n\t\tdimm->edac_mode = EDAC_SECDED;\n\t\tedac_dbg(2, \"\\t\\tECC code is 8-byte-over-32-byte SECDED+ code\\n\");\n\t} else {\n\t\tedac_dbg(2, \"\\t\\tECC code is on Lockstep mode\\n\");\n\t\tif (MTR_DRAM_WIDTH(mtr) == 8)\n\t\t\tdimm->edac_mode = EDAC_S8ECD8ED;\n\t\telse\n\t\t\tdimm->edac_mode = EDAC_S4ECD4ED;\n\t}\n\n\t \n\tif (MTR_DRAM_WIDTH(mtr) == 8) {\n\t\tedac_dbg(2, \"\\t\\tScrub algorithm for x8 is on %s mode\\n\",\n\t\t\t IS_SCRBALGO_ENHANCED(pvt->mc_settings) ?\n\t\t\t \"enhanced\" : \"normal\");\n\n\t\tdimm->dtype = DEV_X8;\n\t} else\n\t\tdimm->dtype = DEV_X4;\n\n\treturn mtr;\n}\n\n \nstatic void print_dimm_size(struct i7300_pvt *pvt)\n{\n#ifdef CONFIG_EDAC_DEBUG\n\tstruct i7300_dimm_info *dinfo;\n\tchar *p;\n\tint space, n;\n\tint channel, slot;\n\n\tspace = PAGE_SIZE;\n\tp = pvt->tmp_prt_buffer;\n\n\tn = snprintf(p, space, \"              \");\n\tp += n;\n\tspace -= n;\n\tfor (channel = 0; channel < MAX_CHANNELS; channel++) {\n\t\tn = snprintf(p, space, \"channel %d | \", channel);\n\t\tp += n;\n\t\tspace -= n;\n\t}\n\tedac_dbg(2, \"%s\\n\", pvt->tmp_prt_buffer);\n\tp = pvt->tmp_prt_buffer;\n\tspace = PAGE_SIZE;\n\tn = snprintf(p, space, \"-------------------------------\"\n\t\t\t       \"------------------------------\");\n\tp += n;\n\tspace -= n;\n\tedac_dbg(2, \"%s\\n\", pvt->tmp_prt_buffer);\n\tp = pvt->tmp_prt_buffer;\n\tspace = PAGE_SIZE;\n\n\tfor (slot = 0; slot < MAX_SLOTS; slot++) {\n\t\tn = snprintf(p, space, \"csrow/SLOT %d  \", slot);\n\t\tp += n;\n\t\tspace -= n;\n\n\t\tfor (channel = 0; channel < MAX_CHANNELS; channel++) {\n\t\t\tdinfo = &pvt->dimm_info[slot][channel];\n\t\t\tn = snprintf(p, space, \"%4d MB   | \", dinfo->megabytes);\n\t\t\tp += n;\n\t\t\tspace -= n;\n\t\t}\n\n\t\tedac_dbg(2, \"%s\\n\", pvt->tmp_prt_buffer);\n\t\tp = pvt->tmp_prt_buffer;\n\t\tspace = PAGE_SIZE;\n\t}\n\n\tn = snprintf(p, space, \"-------------------------------\"\n\t\t\t       \"------------------------------\");\n\tp += n;\n\tspace -= n;\n\tedac_dbg(2, \"%s\\n\", pvt->tmp_prt_buffer);\n\tp = pvt->tmp_prt_buffer;\n\tspace = PAGE_SIZE;\n#endif\n}\n\n \nstatic int i7300_init_csrows(struct mem_ctl_info *mci)\n{\n\tstruct i7300_pvt *pvt;\n\tstruct i7300_dimm_info *dinfo;\n\tint rc = -ENODEV;\n\tint mtr;\n\tint ch, branch, slot, channel, max_channel, max_branch;\n\tstruct dimm_info *dimm;\n\n\tpvt = mci->pvt_info;\n\n\tedac_dbg(2, \"Memory Technology Registers:\\n\");\n\n\tif (IS_SINGLE_MODE(pvt->mc_settings_a)) {\n\t\tmax_branch = 1;\n\t\tmax_channel = 1;\n\t} else {\n\t\tmax_branch = MAX_BRANCHES;\n\t\tmax_channel = MAX_CH_PER_BRANCH;\n\t}\n\n\t \n\tfor (branch = 0; branch < max_branch; branch++) {\n\t\t \n\t\tchannel = to_channel(0, branch);\n\t\tpci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\n\t\t\t\t     AMBPRESENT_0,\n\t\t\t\t&pvt->ambpresent[channel]);\n\t\tedac_dbg(2, \"\\t\\tAMB-present CH%d = 0x%x:\\n\",\n\t\t\t channel, pvt->ambpresent[channel]);\n\n\t\tif (max_channel == 1)\n\t\t\tcontinue;\n\n\t\tchannel = to_channel(1, branch);\n\t\tpci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\n\t\t\t\t     AMBPRESENT_1,\n\t\t\t\t&pvt->ambpresent[channel]);\n\t\tedac_dbg(2, \"\\t\\tAMB-present CH%d = 0x%x:\\n\",\n\t\t\t channel, pvt->ambpresent[channel]);\n\t}\n\n\t \n\tfor (slot = 0; slot < MAX_SLOTS; slot++) {\n\t\tint where = mtr_regs[slot];\n\t\tfor (branch = 0; branch < max_branch; branch++) {\n\t\t\tpci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\n\t\t\t\t\twhere,\n\t\t\t\t\t&pvt->mtr[slot][branch]);\n\t\t\tfor (ch = 0; ch < max_channel; ch++) {\n\t\t\t\tint channel = to_channel(ch, branch);\n\n\t\t\t\tdimm = edac_get_dimm(mci, branch, ch, slot);\n\n\t\t\t\tdinfo = &pvt->dimm_info[slot][channel];\n\n\t\t\t\tmtr = decode_mtr(pvt, slot, ch, branch,\n\t\t\t\t\t\t dinfo, dimm);\n\n\t\t\t\t \n\t\t\t\tif (!MTR_DIMMS_PRESENT(mtr))\n\t\t\t\t\tcontinue;\n\n\t\t\t\trc = 0;\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nstatic void decode_mir(int mir_no, u16 mir[MAX_MIR])\n{\n\tif (mir[mir_no] & 3)\n\t\tedac_dbg(2, \"MIR%d: limit= 0x%x Branch(es) that participate: %s %s\\n\",\n\t\t\t mir_no,\n\t\t\t (mir[mir_no] >> 4) & 0xfff,\n\t\t\t (mir[mir_no] & 1) ? \"B0\" : \"\",\n\t\t\t (mir[mir_no] & 2) ? \"B1\" : \"\");\n}\n\n \nstatic int i7300_get_mc_regs(struct mem_ctl_info *mci)\n{\n\tstruct i7300_pvt *pvt;\n\tu32 actual_tolm;\n\tint i, rc;\n\n\tpvt = mci->pvt_info;\n\n\tpci_read_config_dword(pvt->pci_dev_16_0_fsb_ctlr, AMBASE,\n\t\t\t(u32 *) &pvt->ambase);\n\n\tedac_dbg(2, \"AMBASE= 0x%lx\\n\", (long unsigned int)pvt->ambase);\n\n\t \n\tpci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, TOLM, &pvt->tolm);\n\tpvt->tolm >>= 12;\n\tedac_dbg(2, \"TOLM (number of 256M regions) =%u (0x%x)\\n\",\n\t\t pvt->tolm, pvt->tolm);\n\n\tactual_tolm = (u32) ((1000l * pvt->tolm) >> (30 - 28));\n\tedac_dbg(2, \"Actual TOLM byte addr=%u.%03u GB (0x%x)\\n\",\n\t\t actual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);\n\n\t \n\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS,\n\t\t\t     &pvt->mc_settings);\n\tpci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS_A,\n\t\t\t     &pvt->mc_settings_a);\n\n\tif (IS_SINGLE_MODE(pvt->mc_settings_a))\n\t\tedac_dbg(0, \"Memory controller operating on single mode\\n\");\n\telse\n\t\tedac_dbg(0, \"Memory controller operating on %smirrored mode\\n\",\n\t\t\t IS_MIRRORED(pvt->mc_settings) ? \"\" : \"non-\");\n\n\tedac_dbg(0, \"Error detection is %s\\n\",\n\t\t IS_ECC_ENABLED(pvt->mc_settings) ? \"enabled\" : \"disabled\");\n\tedac_dbg(0, \"Retry is %s\\n\",\n\t\t IS_RETRY_ENABLED(pvt->mc_settings) ? \"enabled\" : \"disabled\");\n\n\t \n\tpci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR0,\n\t\t\t     &pvt->mir[0]);\n\tpci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR1,\n\t\t\t     &pvt->mir[1]);\n\tpci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR2,\n\t\t\t     &pvt->mir[2]);\n\n\t \n\tfor (i = 0; i < MAX_MIR; i++)\n\t\tdecode_mir(i, pvt->mir);\n\n\trc = i7300_init_csrows(mci);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tprint_dimm_size(pvt);\n\n\treturn 0;\n}\n\n \n\n \nstatic void i7300_put_devices(struct mem_ctl_info *mci)\n{\n\tstruct i7300_pvt *pvt;\n\tint branch;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tfor (branch = 0; branch < MAX_CH_PER_BRANCH; branch++)\n\t\tpci_dev_put(pvt->pci_dev_2x_0_fbd_branch[branch]);\n\tpci_dev_put(pvt->pci_dev_16_2_fsb_err_regs);\n\tpci_dev_put(pvt->pci_dev_16_1_fsb_addr_map);\n}\n\n \nstatic int i7300_get_devices(struct mem_ctl_info *mci)\n{\n\tstruct i7300_pvt *pvt;\n\tstruct pci_dev *pdev;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpdev = NULL;\n\twhile ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t      PCI_DEVICE_ID_INTEL_I7300_MCH_ERR,\n\t\t\t\t      pdev))) {\n\t\t \n\t\tswitch (PCI_FUNC(pdev->devfn)) {\n\t\tcase 1:\n\t\t\tif (!pvt->pci_dev_16_1_fsb_addr_map)\n\t\t\t\tpvt->pci_dev_16_1_fsb_addr_map =\n\t\t\t\t\t\t\tpci_dev_get(pdev);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!pvt->pci_dev_16_2_fsb_err_regs)\n\t\t\t\tpvt->pci_dev_16_2_fsb_err_regs =\n\t\t\t\t\t\t\tpci_dev_get(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pvt->pci_dev_16_1_fsb_addr_map ||\n\t    !pvt->pci_dev_16_2_fsb_err_regs) {\n\t\t \n\t\ti7300_printk(KERN_ERR,\n\t\t\t\"'system address,Process Bus' device not found:\"\n\t\t\t\"vendor 0x%x device 0x%x ERR funcs (broken BIOS?)\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_I7300_MCH_ERR);\n\t\tgoto error;\n\t}\n\n\tedac_dbg(1, \"System Address, processor bus- PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->pci_dev_16_0_fsb_ctlr),\n\t\t pvt->pci_dev_16_0_fsb_ctlr->vendor,\n\t\t pvt->pci_dev_16_0_fsb_ctlr->device);\n\tedac_dbg(1, \"Branchmap, control and errors - PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->pci_dev_16_1_fsb_addr_map),\n\t\t pvt->pci_dev_16_1_fsb_addr_map->vendor,\n\t\t pvt->pci_dev_16_1_fsb_addr_map->device);\n\tedac_dbg(1, \"FSB Error Regs - PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->pci_dev_16_2_fsb_err_regs),\n\t\t pvt->pci_dev_16_2_fsb_err_regs->vendor,\n\t\t pvt->pci_dev_16_2_fsb_err_regs->device);\n\n\tpvt->pci_dev_2x_0_fbd_branch[0] = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t\t    PCI_DEVICE_ID_INTEL_I7300_MCH_FB0,\n\t\t\t\t\t    NULL);\n\tif (!pvt->pci_dev_2x_0_fbd_branch[0]) {\n\t\ti7300_printk(KERN_ERR,\n\t\t\t\"MC: 'BRANCH 0' device not found:\"\n\t\t\t\"vendor 0x%x device 0x%x Func 0 (broken BIOS?)\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_FB0);\n\t\tgoto error;\n\t}\n\n\tpvt->pci_dev_2x_0_fbd_branch[1] = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t\t    PCI_DEVICE_ID_INTEL_I7300_MCH_FB1,\n\t\t\t\t\t    NULL);\n\tif (!pvt->pci_dev_2x_0_fbd_branch[1]) {\n\t\ti7300_printk(KERN_ERR,\n\t\t\t\"MC: 'BRANCH 1' device not found:\"\n\t\t\t\"vendor 0x%x device 0x%x Func 0 \"\n\t\t\t\"(broken BIOS?)\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_I7300_MCH_FB1);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\ti7300_put_devices(mci);\n\treturn -ENODEV;\n}\n\n \nstatic int i7300_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[3];\n\tstruct i7300_pvt *pvt;\n\tint rc;\n\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc == -EIO)\n\t\treturn rc;\n\n\tedac_dbg(0, \"MC: pdev bus %u dev=0x%x fn=0x%x\\n\",\n\t\t pdev->bus->number,\n\t\t PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\n\n\t \n\tif (PCI_FUNC(pdev->devfn) != 0)\n\t\treturn -ENODEV;\n\n\t \n\tlayers[0].type = EDAC_MC_LAYER_BRANCH;\n\tlayers[0].size = MAX_BRANCHES;\n\tlayers[0].is_virt_csrow = false;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = MAX_CH_PER_BRANCH;\n\tlayers[1].is_virt_csrow = true;\n\tlayers[2].type = EDAC_MC_LAYER_SLOT;\n\tlayers[2].size = MAX_SLOTS;\n\tlayers[2].is_virt_csrow = true;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(0, \"MC: mci = %p\\n\", mci);\n\n\tmci->pdev = &pdev->dev;\t \n\n\tpvt = mci->pvt_info;\n\tpvt->pci_dev_16_0_fsb_ctlr = pdev;\t \n\n\tpvt->tmp_prt_buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!pvt->tmp_prt_buffer) {\n\t\tedac_mc_free(mci);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (i7300_get_devices(mci))\n\t\tgoto fail0;\n\n\tmci->mc_idx = 0;\n\tmci->mtype_cap = MEM_FLAG_FB_DDR2;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE;\n\tmci->edac_cap = EDAC_FLAG_NONE;\n\tmci->mod_name = \"i7300_edac.c\";\n\tmci->ctl_name = i7300_devs[0].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->ctl_page_to_phys = NULL;\n\n\t \n\tmci->edac_check = i7300_check_error;\n\n\t \n\tif (i7300_get_mc_regs(mci)) {\n\t\tedac_dbg(0, \"MC: Setting mci->edac_cap to EDAC_FLAG_NONE because i7300_init_csrows() returned nonzero value\\n\");\n\t\tmci->edac_cap = EDAC_FLAG_NONE;\t \n\t} else {\n\t\tedac_dbg(1, \"MC: Enable error reporting now\\n\");\n\t\ti7300_enable_error_reporting(mci);\n\t}\n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(0, \"MC: failed edac_mc_add_mc()\\n\");\n\t\t \n\t\tgoto fail1;\n\t}\n\n\ti7300_clear_error(mci);\n\n\t \n\ti7300_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!i7300_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\treturn 0;\n\n\t \nfail1:\n\n\ti7300_put_devices(mci);\n\nfail0:\n\tkfree(pvt->tmp_prt_buffer);\n\tedac_mc_free(mci);\n\treturn -ENODEV;\n}\n\n \nstatic void i7300_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\tchar *tmp;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (i7300_pci)\n\t\tedac_pci_release_generic_ctl(i7300_pci);\n\n\tmci = edac_mc_del_mc(&pdev->dev);\n\tif (!mci)\n\t\treturn;\n\n\ttmp = ((struct i7300_pvt *)mci->pvt_info)->tmp_prt_buffer;\n\n\t \n\ti7300_put_devices(mci);\n\n\tkfree(tmp);\n\tedac_mc_free(mci);\n}\n\n \nstatic const struct pci_device_id i7300_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_ERR)},\n\t{0,}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, i7300_pci_tbl);\n\n \nstatic struct pci_driver i7300_driver = {\n\t.name = \"i7300_edac\",\n\t.probe = i7300_init_one,\n\t.remove = i7300_remove_one,\n\t.id_table = i7300_pci_tbl,\n};\n\n \nstatic int __init i7300_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(2, \"\\n\");\n\n\t \n\topstate_init();\n\n\tpci_rc = pci_register_driver(&i7300_driver);\n\n\treturn (pci_rc < 0) ? pci_rc : 0;\n}\n\n \nstatic void __exit i7300_exit(void)\n{\n\tedac_dbg(2, \"\\n\");\n\tpci_unregister_driver(&i7300_driver);\n}\n\nmodule_init(i7300_init);\nmodule_exit(i7300_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_AUTHOR(\"Red Hat Inc. (https://www.redhat.com)\");\nMODULE_DESCRIPTION(\"MC Driver for Intel I7300 memory controllers - \"\n\t\t   I7300_REVISION);\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}