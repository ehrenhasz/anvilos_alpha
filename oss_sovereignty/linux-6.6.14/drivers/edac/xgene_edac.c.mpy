{
  "module_name": "xgene_edac.c",
  "hash_id": "858132a2b1196f5bdc00bff1ea6f0578fefe8c4c61621348335bf27fe3b8237f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/xgene_edac.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/edac.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\t\t\"xgene_edac\"\n\n \n#define PCPHPERRINTSTS\t\t\t0x0000\n#define PCPHPERRINTMSK\t\t\t0x0004\n#define  MCU_CTL_ERR_MASK\t\tBIT(12)\n#define  IOB_PA_ERR_MASK\t\tBIT(11)\n#define  IOB_BA_ERR_MASK\t\tBIT(10)\n#define  IOB_XGIC_ERR_MASK\t\tBIT(9)\n#define  IOB_RB_ERR_MASK\t\tBIT(8)\n#define  L3C_UNCORR_ERR_MASK\t\tBIT(5)\n#define  MCU_UNCORR_ERR_MASK\t\tBIT(4)\n#define  PMD3_MERR_MASK\t\t\tBIT(3)\n#define  PMD2_MERR_MASK\t\t\tBIT(2)\n#define  PMD1_MERR_MASK\t\t\tBIT(1)\n#define  PMD0_MERR_MASK\t\t\tBIT(0)\n#define PCPLPERRINTSTS\t\t\t0x0008\n#define PCPLPERRINTMSK\t\t\t0x000C\n#define  CSW_SWITCH_TRACE_ERR_MASK\tBIT(2)\n#define  L3C_CORR_ERR_MASK\t\tBIT(1)\n#define  MCU_CORR_ERR_MASK\t\tBIT(0)\n#define MEMERRINTSTS\t\t\t0x0010\n#define MEMERRINTMSK\t\t\t0x0014\n\nstruct xgene_edac {\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*csw_map;\n\tstruct regmap\t\t*mcba_map;\n\tstruct regmap\t\t*mcbb_map;\n\tstruct regmap\t\t*efuse_map;\n\tstruct regmap\t\t*rb_map;\n\tvoid __iomem\t\t*pcp_csr;\n\tspinlock_t\t\tlock;\n\tstruct dentry           *dfs;\n\n\tstruct list_head\tmcus;\n\tstruct list_head\tpmds;\n\tstruct list_head\tl3s;\n\tstruct list_head\tsocs;\n\n\tstruct mutex\t\tmc_lock;\n\tint\t\t\tmc_active_mask;\n\tint\t\t\tmc_registered_mask;\n};\n\nstatic void xgene_edac_pcp_rd(struct xgene_edac *edac, u32 reg, u32 *val)\n{\n\t*val = readl(edac->pcp_csr + reg);\n}\n\nstatic void xgene_edac_pcp_clrbits(struct xgene_edac *edac, u32 reg,\n\t\t\t\t   u32 bits_mask)\n{\n\tu32 val;\n\n\tspin_lock(&edac->lock);\n\tval = readl(edac->pcp_csr + reg);\n\tval &= ~bits_mask;\n\twritel(val, edac->pcp_csr + reg);\n\tspin_unlock(&edac->lock);\n}\n\nstatic void xgene_edac_pcp_setbits(struct xgene_edac *edac, u32 reg,\n\t\t\t\t   u32 bits_mask)\n{\n\tu32 val;\n\n\tspin_lock(&edac->lock);\n\tval = readl(edac->pcp_csr + reg);\n\tval |= bits_mask;\n\twritel(val, edac->pcp_csr + reg);\n\tspin_unlock(&edac->lock);\n}\n\n \n#define MCU_MAX_RANK\t\t\t8\n#define MCU_RANK_STRIDE\t\t\t0x40\n\n#define MCUGECR\t\t\t\t0x0110\n#define  MCU_GECR_DEMANDUCINTREN_MASK\tBIT(0)\n#define  MCU_GECR_BACKUCINTREN_MASK\tBIT(1)\n#define  MCU_GECR_CINTREN_MASK\t\tBIT(2)\n#define  MUC_GECR_MCUADDRERREN_MASK\tBIT(9)\n#define MCUGESR\t\t\t\t0x0114\n#define  MCU_GESR_ADDRNOMATCH_ERR_MASK\tBIT(7)\n#define  MCU_GESR_ADDRMULTIMATCH_ERR_MASK\tBIT(6)\n#define  MCU_GESR_PHYP_ERR_MASK\t\tBIT(3)\n#define MCUESRR0\t\t\t0x0314\n#define  MCU_ESRR_MULTUCERR_MASK\tBIT(3)\n#define  MCU_ESRR_BACKUCERR_MASK\tBIT(2)\n#define  MCU_ESRR_DEMANDUCERR_MASK\tBIT(1)\n#define  MCU_ESRR_CERR_MASK\t\tBIT(0)\n#define MCUESRRA0\t\t\t0x0318\n#define MCUEBLRR0\t\t\t0x031c\n#define  MCU_EBLRR_ERRBANK_RD(src)\t(((src) & 0x00000007) >> 0)\n#define MCUERCRR0\t\t\t0x0320\n#define  MCU_ERCRR_ERRROW_RD(src)\t(((src) & 0xFFFF0000) >> 16)\n#define  MCU_ERCRR_ERRCOL_RD(src)\t((src) & 0x00000FFF)\n#define MCUSBECNT0\t\t\t0x0324\n#define MCU_SBECNT_COUNT(src)\t\t((src) & 0xFFFF)\n\n#define CSW_CSWCR\t\t\t0x0000\n#define  CSW_CSWCR_DUALMCB_MASK\t\tBIT(0)\n\n#define MCBADDRMR\t\t\t0x0000\n#define  MCBADDRMR_MCU_INTLV_MODE_MASK\tBIT(3)\n#define  MCBADDRMR_DUALMCU_MODE_MASK\tBIT(2)\n#define  MCBADDRMR_MCB_INTLV_MODE_MASK\tBIT(1)\n#define  MCBADDRMR_ADDRESS_MODE_MASK\tBIT(0)\n\nstruct xgene_edac_mc_ctx {\n\tstruct list_head\tnext;\n\tchar\t\t\t*name;\n\tstruct mem_ctl_info\t*mci;\n\tstruct xgene_edac\t*edac;\n\tvoid __iomem\t\t*mcu_csr;\n\tu32\t\t\tmcu_id;\n};\n\nstatic ssize_t xgene_edac_mc_err_inject_write(struct file *file,\n\t\t\t\t\t      const char __user *data,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct mem_ctl_info *mci = file->private_data;\n\tstruct xgene_edac_mc_ctx *ctx = mci->pvt_info;\n\tint i;\n\n\tfor (i = 0; i < MCU_MAX_RANK; i++) {\n\t\twritel(MCU_ESRR_MULTUCERR_MASK | MCU_ESRR_BACKUCERR_MASK |\n\t\t       MCU_ESRR_DEMANDUCERR_MASK | MCU_ESRR_CERR_MASK,\n\t\t       ctx->mcu_csr + MCUESRRA0 + i * MCU_RANK_STRIDE);\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations xgene_edac_mc_debug_inject_fops = {\n\t.open = simple_open,\n\t.write = xgene_edac_mc_err_inject_write,\n\t.llseek = generic_file_llseek,\n};\n\nstatic void xgene_edac_mc_create_debugfs_node(struct mem_ctl_info *mci)\n{\n\tif (!IS_ENABLED(CONFIG_EDAC_DEBUG))\n\t\treturn;\n\n\tif (!mci->debugfs)\n\t\treturn;\n\n\tedac_debugfs_create_file(\"inject_ctrl\", S_IWUSR, mci->debugfs, mci,\n\t\t\t\t &xgene_edac_mc_debug_inject_fops);\n}\n\nstatic void xgene_edac_mc_check(struct mem_ctl_info *mci)\n{\n\tstruct xgene_edac_mc_ctx *ctx = mci->pvt_info;\n\tunsigned int pcp_hp_stat;\n\tunsigned int pcp_lp_stat;\n\tu32 reg;\n\tu32 rank;\n\tu32 bank;\n\tu32 count;\n\tu32 col_row;\n\n\txgene_edac_pcp_rd(ctx->edac, PCPHPERRINTSTS, &pcp_hp_stat);\n\txgene_edac_pcp_rd(ctx->edac, PCPLPERRINTSTS, &pcp_lp_stat);\n\tif (!((MCU_UNCORR_ERR_MASK & pcp_hp_stat) ||\n\t      (MCU_CTL_ERR_MASK & pcp_hp_stat) ||\n\t      (MCU_CORR_ERR_MASK & pcp_lp_stat)))\n\t\treturn;\n\n\tfor (rank = 0; rank < MCU_MAX_RANK; rank++) {\n\t\treg = readl(ctx->mcu_csr + MCUESRR0 + rank * MCU_RANK_STRIDE);\n\n\t\t \n\t\tif (reg & (MCU_ESRR_DEMANDUCERR_MASK |\n\t\t\t   MCU_ESRR_BACKUCERR_MASK)) {\n\t\t\t \n\t\t\tedac_mc_chipset_printk(mci, KERN_ERR, \"X-Gene\",\n\t\t\t\t\"MCU uncorrectable error at rank %d\\n\", rank);\n\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci,\n\t\t\t\t1, 0, 0, 0, 0, 0, -1, mci->ctl_name, \"\");\n\t\t}\n\n\t\t \n\t\tif (reg & MCU_ESRR_CERR_MASK) {\n\t\t\tbank = readl(ctx->mcu_csr + MCUEBLRR0 +\n\t\t\t\t     rank * MCU_RANK_STRIDE);\n\t\t\tcol_row = readl(ctx->mcu_csr + MCUERCRR0 +\n\t\t\t\t\trank * MCU_RANK_STRIDE);\n\t\t\tcount = readl(ctx->mcu_csr + MCUSBECNT0 +\n\t\t\t\t      rank * MCU_RANK_STRIDE);\n\t\t\tedac_mc_chipset_printk(mci, KERN_WARNING, \"X-Gene\",\n\t\t\t\t\"MCU correctable error at rank %d bank %d column %d row %d count %d\\n\",\n\t\t\t\trank, MCU_EBLRR_ERRBANK_RD(bank),\n\t\t\t\tMCU_ERCRR_ERRCOL_RD(col_row),\n\t\t\t\tMCU_ERCRR_ERRROW_RD(col_row),\n\t\t\t\tMCU_SBECNT_COUNT(count));\n\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci,\n\t\t\t\t1, 0, 0, 0, 0, 0, -1, mci->ctl_name, \"\");\n\t\t}\n\n\t\t \n\t\twritel(0x0, ctx->mcu_csr + MCUEBLRR0 + rank * MCU_RANK_STRIDE);\n\t\twritel(0x0, ctx->mcu_csr + MCUERCRR0 + rank * MCU_RANK_STRIDE);\n\t\twritel(0x0, ctx->mcu_csr + MCUSBECNT0 +\n\t\t       rank * MCU_RANK_STRIDE);\n\t\twritel(reg, ctx->mcu_csr + MCUESRR0 + rank * MCU_RANK_STRIDE);\n\t}\n\n\t \n\treg = readl(ctx->mcu_csr + MCUGESR);\n\tif (reg) {\n\t\tif (reg & MCU_GESR_ADDRNOMATCH_ERR_MASK)\n\t\t\tedac_mc_chipset_printk(mci, KERN_WARNING, \"X-Gene\",\n\t\t\t\t\"MCU address miss-match error\\n\");\n\t\tif (reg & MCU_GESR_ADDRMULTIMATCH_ERR_MASK)\n\t\t\tedac_mc_chipset_printk(mci, KERN_WARNING, \"X-Gene\",\n\t\t\t\t\"MCU address multi-match error\\n\");\n\n\t\twritel(reg, ctx->mcu_csr + MCUGESR);\n\t}\n}\n\nstatic void xgene_edac_mc_irq_ctl(struct mem_ctl_info *mci, bool enable)\n{\n\tstruct xgene_edac_mc_ctx *ctx = mci->pvt_info;\n\tunsigned int val;\n\n\tif (edac_op_state != EDAC_OPSTATE_INT)\n\t\treturn;\n\n\tmutex_lock(&ctx->edac->mc_lock);\n\n\t \n\tif (enable) {\n\t\t \n\t\tctx->edac->mc_registered_mask |= 1 << ctx->mcu_id;\n\n\t\t \n\t\tif (ctx->edac->mc_registered_mask ==\n\t\t    ctx->edac->mc_active_mask) {\n\t\t\t \n\t\t\txgene_edac_pcp_clrbits(ctx->edac, PCPHPERRINTMSK,\n\t\t\t\t\t       MCU_UNCORR_ERR_MASK |\n\t\t\t\t\t       MCU_CTL_ERR_MASK);\n\t\t\txgene_edac_pcp_clrbits(ctx->edac, PCPLPERRINTMSK,\n\t\t\t\t\t       MCU_CORR_ERR_MASK);\n\t\t}\n\n\t\t \n\t\tval = readl(ctx->mcu_csr + MCUGECR);\n\t\tval |= MCU_GECR_DEMANDUCINTREN_MASK |\n\t\t       MCU_GECR_BACKUCINTREN_MASK |\n\t\t       MCU_GECR_CINTREN_MASK |\n\t\t       MUC_GECR_MCUADDRERREN_MASK;\n\t\twritel(val, ctx->mcu_csr + MCUGECR);\n\t} else {\n\t\t \n\t\tval = readl(ctx->mcu_csr + MCUGECR);\n\t\tval &= ~(MCU_GECR_DEMANDUCINTREN_MASK |\n\t\t\t MCU_GECR_BACKUCINTREN_MASK |\n\t\t\t MCU_GECR_CINTREN_MASK |\n\t\t\t MUC_GECR_MCUADDRERREN_MASK);\n\t\twritel(val, ctx->mcu_csr + MCUGECR);\n\n\t\t \n\t\txgene_edac_pcp_setbits(ctx->edac, PCPHPERRINTMSK,\n\t\t\t\t       MCU_UNCORR_ERR_MASK | MCU_CTL_ERR_MASK);\n\t\txgene_edac_pcp_setbits(ctx->edac, PCPLPERRINTMSK,\n\t\t\t\t       MCU_CORR_ERR_MASK);\n\n\t\t \n\t\tctx->edac->mc_registered_mask &= ~(1 << ctx->mcu_id);\n\t}\n\n\tmutex_unlock(&ctx->edac->mc_lock);\n}\n\nstatic int xgene_edac_mc_is_active(struct xgene_edac_mc_ctx *ctx, int mc_idx)\n{\n\tunsigned int reg;\n\tu32 mcu_mask;\n\n\tif (regmap_read(ctx->edac->csw_map, CSW_CSWCR, &reg))\n\t\treturn 0;\n\n\tif (reg & CSW_CSWCR_DUALMCB_MASK) {\n\t\t \n\t\tif (regmap_read(ctx->edac->mcbb_map, MCBADDRMR, &reg))\n\t\t\treturn 0;\n\t\tmcu_mask = (reg & MCBADDRMR_DUALMCU_MODE_MASK) ? 0xF : 0x5;\n\t} else {\n\t\t \n\t\tif (regmap_read(ctx->edac->mcba_map, MCBADDRMR, &reg))\n\t\t\treturn 0;\n\t\tmcu_mask = (reg & MCBADDRMR_DUALMCU_MODE_MASK) ? 0x3 : 0x1;\n\t}\n\n\t \n\tif (!ctx->edac->mc_active_mask)\n\t\tctx->edac->mc_active_mask = mcu_mask;\n\n\treturn (mcu_mask & (1 << mc_idx)) ? 1 : 0;\n}\n\nstatic int xgene_edac_mc_add(struct xgene_edac *edac, struct device_node *np)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tstruct xgene_edac_mc_ctx tmp_ctx;\n\tstruct xgene_edac_mc_ctx *ctx;\n\tstruct resource res;\n\tint rc;\n\n\tmemset(&tmp_ctx, 0, sizeof(tmp_ctx));\n\ttmp_ctx.edac = edac;\n\n\tif (!devres_open_group(edac->dev, xgene_edac_mc_add, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\trc = of_address_to_resource(np, 0, &res);\n\tif (rc < 0) {\n\t\tdev_err(edac->dev, \"no MCU resource address\\n\");\n\t\tgoto err_group;\n\t}\n\ttmp_ctx.mcu_csr = devm_ioremap_resource(edac->dev, &res);\n\tif (IS_ERR(tmp_ctx.mcu_csr)) {\n\t\tdev_err(edac->dev, \"unable to map MCU resource\\n\");\n\t\trc = PTR_ERR(tmp_ctx.mcu_csr);\n\t\tgoto err_group;\n\t}\n\n\t \n\tif (of_property_read_u32(np, \"memory-controller\", &tmp_ctx.mcu_id)) {\n\t\tdev_err(edac->dev, \"no memory-controller property\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_group;\n\t}\n\tif (!xgene_edac_mc_is_active(&tmp_ctx, tmp_ctx.mcu_id)) {\n\t\trc = -ENODEV;\n\t\tgoto err_group;\n\t}\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = 4;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = 2;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(tmp_ctx.mcu_id, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(*ctx));\n\tif (!mci) {\n\t\trc = -ENOMEM;\n\t\tgoto err_group;\n\t}\n\n\tctx = mci->pvt_info;\n\t*ctx = tmp_ctx;\t\t \n\tctx->name = \"xgene_edac_mc_err\";\n\tctx->mci = mci;\n\tmci->pdev = &mci->dev;\n\tmci->ctl_name = ctx->name;\n\tmci->dev_name = ctx->name;\n\n\tmci->mtype_cap = MEM_FLAG_RDDR | MEM_FLAG_RDDR2 | MEM_FLAG_RDDR3 |\n\t\t\t MEM_FLAG_DDR | MEM_FLAG_DDR2 | MEM_FLAG_DDR3;\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_page_to_phys = NULL;\n\tmci->scrub_cap = SCRUB_FLAG_HW_SRC;\n\tmci->scrub_mode = SCRUB_HW_SRC;\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tmci->edac_check = xgene_edac_mc_check;\n\n\tif (edac_mc_add_mc(mci)) {\n\t\tdev_err(edac->dev, \"edac_mc_add_mc failed\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\txgene_edac_mc_create_debugfs_node(mci);\n\n\tlist_add(&ctx->next, &edac->mcus);\n\n\txgene_edac_mc_irq_ctl(mci, true);\n\n\tdevres_remove_group(edac->dev, xgene_edac_mc_add);\n\n\tdev_info(edac->dev, \"X-Gene EDAC MC registered\\n\");\n\treturn 0;\n\nerr_free:\n\tedac_mc_free(mci);\nerr_group:\n\tdevres_release_group(edac->dev, xgene_edac_mc_add);\n\treturn rc;\n}\n\nstatic int xgene_edac_mc_remove(struct xgene_edac_mc_ctx *mcu)\n{\n\txgene_edac_mc_irq_ctl(mcu->mci, false);\n\tedac_mc_del_mc(&mcu->mci->dev);\n\tedac_mc_free(mcu->mci);\n\treturn 0;\n}\n\n \n#define MAX_CPU_PER_PMD\t\t\t\t2\n#define CPU_CSR_STRIDE\t\t\t\t0x00100000\n#define CPU_L2C_PAGE\t\t\t\t0x000D0000\n#define CPU_MEMERR_L2C_PAGE\t\t\t0x000E0000\n#define CPU_MEMERR_CPU_PAGE\t\t\t0x000F0000\n\n#define MEMERR_CPU_ICFECR_PAGE_OFFSET\t\t0x0000\n#define MEMERR_CPU_ICFESR_PAGE_OFFSET\t\t0x0004\n#define  MEMERR_CPU_ICFESR_ERRWAY_RD(src)\t(((src) & 0xFF000000) >> 24)\n#define  MEMERR_CPU_ICFESR_ERRINDEX_RD(src)\t(((src) & 0x003F0000) >> 16)\n#define  MEMERR_CPU_ICFESR_ERRINFO_RD(src)\t(((src) & 0x0000FF00) >> 8)\n#define  MEMERR_CPU_ICFESR_ERRTYPE_RD(src)\t(((src) & 0x00000070) >> 4)\n#define  MEMERR_CPU_ICFESR_MULTCERR_MASK\tBIT(2)\n#define  MEMERR_CPU_ICFESR_CERR_MASK\t\tBIT(0)\n#define MEMERR_CPU_LSUESR_PAGE_OFFSET\t\t0x000c\n#define  MEMERR_CPU_LSUESR_ERRWAY_RD(src)\t(((src) & 0xFF000000) >> 24)\n#define  MEMERR_CPU_LSUESR_ERRINDEX_RD(src)\t(((src) & 0x003F0000) >> 16)\n#define  MEMERR_CPU_LSUESR_ERRINFO_RD(src)\t(((src) & 0x0000FF00) >> 8)\n#define  MEMERR_CPU_LSUESR_ERRTYPE_RD(src)\t(((src) & 0x00000070) >> 4)\n#define  MEMERR_CPU_LSUESR_MULTCERR_MASK\tBIT(2)\n#define  MEMERR_CPU_LSUESR_CERR_MASK\t\tBIT(0)\n#define MEMERR_CPU_LSUECR_PAGE_OFFSET\t\t0x0008\n#define MEMERR_CPU_MMUECR_PAGE_OFFSET\t\t0x0010\n#define MEMERR_CPU_MMUESR_PAGE_OFFSET\t\t0x0014\n#define  MEMERR_CPU_MMUESR_ERRWAY_RD(src)\t(((src) & 0xFF000000) >> 24)\n#define  MEMERR_CPU_MMUESR_ERRINDEX_RD(src)\t(((src) & 0x007F0000) >> 16)\n#define  MEMERR_CPU_MMUESR_ERRINFO_RD(src)\t(((src) & 0x0000FF00) >> 8)\n#define  MEMERR_CPU_MMUESR_ERRREQSTR_LSU_MASK\tBIT(7)\n#define  MEMERR_CPU_MMUESR_ERRTYPE_RD(src)\t(((src) & 0x00000070) >> 4)\n#define  MEMERR_CPU_MMUESR_MULTCERR_MASK\tBIT(2)\n#define  MEMERR_CPU_MMUESR_CERR_MASK\t\tBIT(0)\n#define MEMERR_CPU_ICFESRA_PAGE_OFFSET\t\t0x0804\n#define MEMERR_CPU_LSUESRA_PAGE_OFFSET\t\t0x080c\n#define MEMERR_CPU_MMUESRA_PAGE_OFFSET\t\t0x0814\n\n#define MEMERR_L2C_L2ECR_PAGE_OFFSET\t\t0x0000\n#define MEMERR_L2C_L2ESR_PAGE_OFFSET\t\t0x0004\n#define  MEMERR_L2C_L2ESR_ERRSYN_RD(src)\t(((src) & 0xFF000000) >> 24)\n#define  MEMERR_L2C_L2ESR_ERRWAY_RD(src)\t(((src) & 0x00FC0000) >> 18)\n#define  MEMERR_L2C_L2ESR_ERRCPU_RD(src)\t(((src) & 0x00020000) >> 17)\n#define  MEMERR_L2C_L2ESR_ERRGROUP_RD(src)\t(((src) & 0x0000E000) >> 13)\n#define  MEMERR_L2C_L2ESR_ERRACTION_RD(src)\t(((src) & 0x00001C00) >> 10)\n#define  MEMERR_L2C_L2ESR_ERRTYPE_RD(src)\t(((src) & 0x00000300) >> 8)\n#define  MEMERR_L2C_L2ESR_MULTUCERR_MASK\tBIT(3)\n#define  MEMERR_L2C_L2ESR_MULTICERR_MASK\tBIT(2)\n#define  MEMERR_L2C_L2ESR_UCERR_MASK\t\tBIT(1)\n#define  MEMERR_L2C_L2ESR_ERR_MASK\t\tBIT(0)\n#define MEMERR_L2C_L2EALR_PAGE_OFFSET\t\t0x0008\n#define CPUX_L2C_L2RTOCR_PAGE_OFFSET\t\t0x0010\n#define MEMERR_L2C_L2EAHR_PAGE_OFFSET\t\t0x000c\n#define CPUX_L2C_L2RTOSR_PAGE_OFFSET\t\t0x0014\n#define  MEMERR_L2C_L2RTOSR_MULTERR_MASK\tBIT(1)\n#define  MEMERR_L2C_L2RTOSR_ERR_MASK\t\tBIT(0)\n#define CPUX_L2C_L2RTOALR_PAGE_OFFSET\t\t0x0018\n#define CPUX_L2C_L2RTOAHR_PAGE_OFFSET\t\t0x001c\n#define MEMERR_L2C_L2ESRA_PAGE_OFFSET\t\t0x0804\n\n \nstruct xgene_edac_pmd_ctx {\n\tstruct list_head\tnext;\n\tstruct device\t\tddev;\n\tchar\t\t\t*name;\n\tstruct xgene_edac\t*edac;\n\tstruct edac_device_ctl_info *edac_dev;\n\tvoid __iomem\t\t*pmd_csr;\n\tu32\t\t\tpmd;\n\tint\t\t\tversion;\n};\n\nstatic void xgene_edac_pmd_l1_check(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t    int cpu_idx)\n{\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tvoid __iomem *pg_f;\n\tu32 val;\n\n\tpg_f = ctx->pmd_csr + cpu_idx * CPU_CSR_STRIDE + CPU_MEMERR_CPU_PAGE;\n\n\tval = readl(pg_f + MEMERR_CPU_ICFESR_PAGE_OFFSET);\n\tif (!val)\n\t\tgoto chk_lsu;\n\tdev_err(edac_dev->dev,\n\t\t\"CPU%d L1 memory error ICF 0x%08X Way 0x%02X Index 0x%02X Info 0x%02X\\n\",\n\t\tctx->pmd * MAX_CPU_PER_PMD + cpu_idx, val,\n\t\tMEMERR_CPU_ICFESR_ERRWAY_RD(val),\n\t\tMEMERR_CPU_ICFESR_ERRINDEX_RD(val),\n\t\tMEMERR_CPU_ICFESR_ERRINFO_RD(val));\n\tif (val & MEMERR_CPU_ICFESR_CERR_MASK)\n\t\tdev_err(edac_dev->dev, \"One or more correctable error\\n\");\n\tif (val & MEMERR_CPU_ICFESR_MULTCERR_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple correctable error\\n\");\n\tswitch (MEMERR_CPU_ICFESR_ERRTYPE_RD(val)) {\n\tcase 1:\n\t\tdev_err(edac_dev->dev, \"L1 TLB multiple hit\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tdev_err(edac_dev->dev, \"Way select multiple hit\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tdev_err(edac_dev->dev, \"Physical tag parity error\\n\");\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tdev_err(edac_dev->dev, \"L1 data parity error\\n\");\n\t\tbreak;\n\tcase 6:\n\t\tdev_err(edac_dev->dev, \"L1 pre-decode parity error\\n\");\n\t\tbreak;\n\t}\n\n\t \n\twritel(val, pg_f + MEMERR_CPU_ICFESR_PAGE_OFFSET);\n\n\tif (val & (MEMERR_CPU_ICFESR_CERR_MASK |\n\t\t   MEMERR_CPU_ICFESR_MULTCERR_MASK))\n\t\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n\nchk_lsu:\n\tval = readl(pg_f + MEMERR_CPU_LSUESR_PAGE_OFFSET);\n\tif (!val)\n\t\tgoto chk_mmu;\n\tdev_err(edac_dev->dev,\n\t\t\"CPU%d memory error LSU 0x%08X Way 0x%02X Index 0x%02X Info 0x%02X\\n\",\n\t\tctx->pmd * MAX_CPU_PER_PMD + cpu_idx, val,\n\t\tMEMERR_CPU_LSUESR_ERRWAY_RD(val),\n\t\tMEMERR_CPU_LSUESR_ERRINDEX_RD(val),\n\t\tMEMERR_CPU_LSUESR_ERRINFO_RD(val));\n\tif (val & MEMERR_CPU_LSUESR_CERR_MASK)\n\t\tdev_err(edac_dev->dev, \"One or more correctable error\\n\");\n\tif (val & MEMERR_CPU_LSUESR_MULTCERR_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple correctable error\\n\");\n\tswitch (MEMERR_CPU_LSUESR_ERRTYPE_RD(val)) {\n\tcase 0:\n\t\tdev_err(edac_dev->dev, \"Load tag error\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tdev_err(edac_dev->dev, \"Load data error\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tdev_err(edac_dev->dev, \"WSL multihit error\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tdev_err(edac_dev->dev, \"Store tag error\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"DTB multihit from load pipeline error\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"DTB multihit from store pipeline error\\n\");\n\t\tbreak;\n\t}\n\n\t \n\twritel(val, pg_f + MEMERR_CPU_LSUESR_PAGE_OFFSET);\n\n\tif (val & (MEMERR_CPU_LSUESR_CERR_MASK |\n\t\t   MEMERR_CPU_LSUESR_MULTCERR_MASK))\n\t\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n\nchk_mmu:\n\tval = readl(pg_f + MEMERR_CPU_MMUESR_PAGE_OFFSET);\n\tif (!val)\n\t\treturn;\n\tdev_err(edac_dev->dev,\n\t\t\"CPU%d memory error MMU 0x%08X Way 0x%02X Index 0x%02X Info 0x%02X %s\\n\",\n\t\tctx->pmd * MAX_CPU_PER_PMD + cpu_idx, val,\n\t\tMEMERR_CPU_MMUESR_ERRWAY_RD(val),\n\t\tMEMERR_CPU_MMUESR_ERRINDEX_RD(val),\n\t\tMEMERR_CPU_MMUESR_ERRINFO_RD(val),\n\t\tval & MEMERR_CPU_MMUESR_ERRREQSTR_LSU_MASK ? \"LSU\" : \"ICF\");\n\tif (val & MEMERR_CPU_MMUESR_CERR_MASK)\n\t\tdev_err(edac_dev->dev, \"One or more correctable error\\n\");\n\tif (val & MEMERR_CPU_MMUESR_MULTCERR_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple correctable error\\n\");\n\tswitch (MEMERR_CPU_MMUESR_ERRTYPE_RD(val)) {\n\tcase 0:\n\t\tdev_err(edac_dev->dev, \"Stage 1 UTB hit error\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tdev_err(edac_dev->dev, \"Stage 1 UTB miss error\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tdev_err(edac_dev->dev, \"Stage 1 UTB allocate error\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tdev_err(edac_dev->dev, \"TMO operation single bank error\\n\");\n\t\tbreak;\n\tcase 4:\n\t\tdev_err(edac_dev->dev, \"Stage 2 UTB error\\n\");\n\t\tbreak;\n\tcase 5:\n\t\tdev_err(edac_dev->dev, \"Stage 2 UTB miss error\\n\");\n\t\tbreak;\n\tcase 6:\n\t\tdev_err(edac_dev->dev, \"Stage 2 UTB allocate error\\n\");\n\t\tbreak;\n\tcase 7:\n\t\tdev_err(edac_dev->dev, \"TMO operation multiple bank error\\n\");\n\t\tbreak;\n\t}\n\n\t \n\twritel(val, pg_f + MEMERR_CPU_MMUESR_PAGE_OFFSET);\n\n\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n}\n\nstatic void xgene_edac_pmd_l2_check(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tvoid __iomem *pg_d;\n\tvoid __iomem *pg_e;\n\tu32 val_hi;\n\tu32 val_lo;\n\tu32 val;\n\n\t \n\tpg_e = ctx->pmd_csr + CPU_MEMERR_L2C_PAGE;\n\tval = readl(pg_e + MEMERR_L2C_L2ESR_PAGE_OFFSET);\n\tif (!val)\n\t\tgoto chk_l2c;\n\tval_lo = readl(pg_e + MEMERR_L2C_L2EALR_PAGE_OFFSET);\n\tval_hi = readl(pg_e + MEMERR_L2C_L2EAHR_PAGE_OFFSET);\n\tdev_err(edac_dev->dev,\n\t\t\"PMD%d memory error L2C L2ESR 0x%08X @ 0x%08X.%08X\\n\",\n\t\tctx->pmd, val, val_hi, val_lo);\n\tdev_err(edac_dev->dev,\n\t\t\"ErrSyndrome 0x%02X ErrWay 0x%02X ErrCpu %d ErrGroup 0x%02X ErrAction 0x%02X\\n\",\n\t\tMEMERR_L2C_L2ESR_ERRSYN_RD(val),\n\t\tMEMERR_L2C_L2ESR_ERRWAY_RD(val),\n\t\tMEMERR_L2C_L2ESR_ERRCPU_RD(val),\n\t\tMEMERR_L2C_L2ESR_ERRGROUP_RD(val),\n\t\tMEMERR_L2C_L2ESR_ERRACTION_RD(val));\n\n\tif (val & MEMERR_L2C_L2ESR_ERR_MASK)\n\t\tdev_err(edac_dev->dev, \"One or more correctable error\\n\");\n\tif (val & MEMERR_L2C_L2ESR_MULTICERR_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple correctable error\\n\");\n\tif (val & MEMERR_L2C_L2ESR_UCERR_MASK)\n\t\tdev_err(edac_dev->dev, \"One or more uncorrectable error\\n\");\n\tif (val & MEMERR_L2C_L2ESR_MULTUCERR_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple uncorrectable error\\n\");\n\n\tswitch (MEMERR_L2C_L2ESR_ERRTYPE_RD(val)) {\n\tcase 0:\n\t\tdev_err(edac_dev->dev, \"Outbound SDB parity error\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tdev_err(edac_dev->dev, \"Inbound SDB parity error\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tdev_err(edac_dev->dev, \"Tag ECC error\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tdev_err(edac_dev->dev, \"Data ECC error\\n\");\n\t\tbreak;\n\t}\n\n\t \n\twritel(val, pg_e + MEMERR_L2C_L2ESR_PAGE_OFFSET);\n\n\tif (val & (MEMERR_L2C_L2ESR_ERR_MASK |\n\t\t   MEMERR_L2C_L2ESR_MULTICERR_MASK))\n\t\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n\tif (val & (MEMERR_L2C_L2ESR_UCERR_MASK |\n\t\t   MEMERR_L2C_L2ESR_MULTUCERR_MASK))\n\t\tedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\n\nchk_l2c:\n\t \n\tpg_d = ctx->pmd_csr + CPU_L2C_PAGE;\n\tval = readl(pg_d + CPUX_L2C_L2RTOSR_PAGE_OFFSET);\n\tif (val) {\n\t\tval_lo = readl(pg_d + CPUX_L2C_L2RTOALR_PAGE_OFFSET);\n\t\tval_hi = readl(pg_d + CPUX_L2C_L2RTOAHR_PAGE_OFFSET);\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"PMD%d L2C error L2C RTOSR 0x%08X @ 0x%08X.%08X\\n\",\n\t\t\tctx->pmd, val, val_hi, val_lo);\n\t\twritel(val, pg_d + CPUX_L2C_L2RTOSR_PAGE_OFFSET);\n\t}\n}\n\nstatic void xgene_edac_pmd_check(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tunsigned int pcp_hp_stat;\n\tint i;\n\n\txgene_edac_pcp_rd(ctx->edac, PCPHPERRINTSTS, &pcp_hp_stat);\n\tif (!((PMD0_MERR_MASK << ctx->pmd) & pcp_hp_stat))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < MAX_CPU_PER_PMD; i++)\n\t\txgene_edac_pmd_l1_check(edac_dev, i);\n\n\t \n\txgene_edac_pmd_l2_check(edac_dev);\n}\n\nstatic void xgene_edac_pmd_cpu_hw_cfg(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t      int cpu)\n{\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tvoid __iomem *pg_f = ctx->pmd_csr + cpu * CPU_CSR_STRIDE +\n\t\t\t     CPU_MEMERR_CPU_PAGE;\n\n\t \n\twritel(0x00000301, pg_f + MEMERR_CPU_ICFECR_PAGE_OFFSET);\n\twritel(0x00000301, pg_f + MEMERR_CPU_LSUECR_PAGE_OFFSET);\n\twritel(0x00000101, pg_f + MEMERR_CPU_MMUECR_PAGE_OFFSET);\n}\n\nstatic void xgene_edac_pmd_hw_cfg(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tvoid __iomem *pg_d = ctx->pmd_csr + CPU_L2C_PAGE;\n\tvoid __iomem *pg_e = ctx->pmd_csr + CPU_MEMERR_L2C_PAGE;\n\n\t \n\twritel(0x00000703, pg_e + MEMERR_L2C_L2ECR_PAGE_OFFSET);\n\t \n\tif (ctx->version > 1)\n\t\twritel(0x00000119, pg_d + CPUX_L2C_L2RTOCR_PAGE_OFFSET);\n}\n\nstatic void xgene_edac_pmd_hw_ctl(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t  bool enable)\n{\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tint i;\n\n\t \n\tif (edac_dev->op_state == OP_RUNNING_INTERRUPT) {\n\t\tif (enable)\n\t\t\txgene_edac_pcp_clrbits(ctx->edac, PCPHPERRINTMSK,\n\t\t\t\t\t       PMD0_MERR_MASK << ctx->pmd);\n\t\telse\n\t\t\txgene_edac_pcp_setbits(ctx->edac, PCPHPERRINTMSK,\n\t\t\t\t\t       PMD0_MERR_MASK << ctx->pmd);\n\t}\n\n\tif (enable) {\n\t\txgene_edac_pmd_hw_cfg(edac_dev);\n\n\t\t \n\t\tfor (i = 0; i < MAX_CPU_PER_PMD; i++)\n\t\t\txgene_edac_pmd_cpu_hw_cfg(edac_dev, i);\n\t}\n}\n\nstatic ssize_t xgene_edac_pmd_l1_inject_ctrl_write(struct file *file,\n\t\t\t\t\t\t   const char __user *data,\n\t\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dev = file->private_data;\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tvoid __iomem *cpux_pg_f;\n\tint i;\n\n\tfor (i = 0; i < MAX_CPU_PER_PMD; i++) {\n\t\tcpux_pg_f = ctx->pmd_csr + i * CPU_CSR_STRIDE +\n\t\t\t    CPU_MEMERR_CPU_PAGE;\n\n\t\twritel(MEMERR_CPU_ICFESR_MULTCERR_MASK |\n\t\t       MEMERR_CPU_ICFESR_CERR_MASK,\n\t\t       cpux_pg_f + MEMERR_CPU_ICFESRA_PAGE_OFFSET);\n\t\twritel(MEMERR_CPU_LSUESR_MULTCERR_MASK |\n\t\t       MEMERR_CPU_LSUESR_CERR_MASK,\n\t\t       cpux_pg_f + MEMERR_CPU_LSUESRA_PAGE_OFFSET);\n\t\twritel(MEMERR_CPU_MMUESR_MULTCERR_MASK |\n\t\t       MEMERR_CPU_MMUESR_CERR_MASK,\n\t\t       cpux_pg_f + MEMERR_CPU_MMUESRA_PAGE_OFFSET);\n\t}\n\treturn count;\n}\n\nstatic ssize_t xgene_edac_pmd_l2_inject_ctrl_write(struct file *file,\n\t\t\t\t\t\t   const char __user *data,\n\t\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dev = file->private_data;\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tvoid __iomem *pg_e = ctx->pmd_csr + CPU_MEMERR_L2C_PAGE;\n\n\twritel(MEMERR_L2C_L2ESR_MULTUCERR_MASK |\n\t       MEMERR_L2C_L2ESR_MULTICERR_MASK |\n\t       MEMERR_L2C_L2ESR_UCERR_MASK |\n\t       MEMERR_L2C_L2ESR_ERR_MASK,\n\t       pg_e + MEMERR_L2C_L2ESRA_PAGE_OFFSET);\n\treturn count;\n}\n\nstatic const struct file_operations xgene_edac_pmd_debug_inject_fops[] = {\n\t{\n\t.open = simple_open,\n\t.write = xgene_edac_pmd_l1_inject_ctrl_write,\n\t.llseek = generic_file_llseek, },\n\t{\n\t.open = simple_open,\n\t.write = xgene_edac_pmd_l2_inject_ctrl_write,\n\t.llseek = generic_file_llseek, },\n\t{ }\n};\n\nstatic void\nxgene_edac_pmd_create_debugfs_nodes(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\n\tstruct dentry *dbgfs_dir;\n\tchar name[10];\n\n\tif (!IS_ENABLED(CONFIG_EDAC_DEBUG) || !ctx->edac->dfs)\n\t\treturn;\n\n\tsnprintf(name, sizeof(name), \"PMD%d\", ctx->pmd);\n\tdbgfs_dir = edac_debugfs_create_dir_at(name, ctx->edac->dfs);\n\tif (!dbgfs_dir)\n\t\treturn;\n\n\tedac_debugfs_create_file(\"l1_inject_ctrl\", S_IWUSR, dbgfs_dir, edac_dev,\n\t\t\t\t &xgene_edac_pmd_debug_inject_fops[0]);\n\tedac_debugfs_create_file(\"l2_inject_ctrl\", S_IWUSR, dbgfs_dir, edac_dev,\n\t\t\t\t &xgene_edac_pmd_debug_inject_fops[1]);\n}\n\nstatic int xgene_edac_pmd_available(u32 efuse, int pmd)\n{\n\treturn (efuse & (1 << pmd)) ? 0 : 1;\n}\n\nstatic int xgene_edac_pmd_add(struct xgene_edac *edac, struct device_node *np,\n\t\t\t      int version)\n{\n\tstruct edac_device_ctl_info *edac_dev;\n\tstruct xgene_edac_pmd_ctx *ctx;\n\tstruct resource res;\n\tchar edac_name[10];\n\tu32 pmd;\n\tint rc;\n\tu32 val;\n\n\tif (!devres_open_group(edac->dev, xgene_edac_pmd_add, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t \n\tif (of_property_read_u32(np, \"pmd-controller\", &pmd)) {\n\t\tdev_err(edac->dev, \"no pmd-controller property\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_group;\n\t}\n\trc = regmap_read(edac->efuse_map, 0, &val);\n\tif (rc)\n\t\tgoto err_group;\n\tif (!xgene_edac_pmd_available(val, pmd)) {\n\t\trc = -ENODEV;\n\t\tgoto err_group;\n\t}\n\n\tsnprintf(edac_name, sizeof(edac_name), \"l2c%d\", pmd);\n\tedac_dev = edac_device_alloc_ctl_info(sizeof(*ctx),\n\t\t\t\t\t      edac_name, 1, \"l2c\", 1, 2, NULL,\n\t\t\t\t\t      0, edac_device_alloc_index());\n\tif (!edac_dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_group;\n\t}\n\n\tctx = edac_dev->pvt_info;\n\tctx->name = \"xgene_pmd_err\";\n\tctx->pmd = pmd;\n\tctx->edac = edac;\n\tctx->edac_dev = edac_dev;\n\tctx->ddev = *edac->dev;\n\tctx->version = version;\n\tedac_dev->dev = &ctx->ddev;\n\tedac_dev->ctl_name = ctx->name;\n\tedac_dev->dev_name = ctx->name;\n\tedac_dev->mod_name = EDAC_MOD_STR;\n\n\trc = of_address_to_resource(np, 0, &res);\n\tif (rc < 0) {\n\t\tdev_err(edac->dev, \"no PMD resource address\\n\");\n\t\tgoto err_free;\n\t}\n\tctx->pmd_csr = devm_ioremap_resource(edac->dev, &res);\n\tif (IS_ERR(ctx->pmd_csr)) {\n\t\tdev_err(edac->dev,\n\t\t\t\"devm_ioremap_resource failed for PMD resource address\\n\");\n\t\trc = PTR_ERR(ctx->pmd_csr);\n\t\tgoto err_free;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tedac_dev->edac_check = xgene_edac_pmd_check;\n\n\txgene_edac_pmd_create_debugfs_nodes(edac_dev);\n\n\trc = edac_device_add_device(edac_dev);\n\tif (rc > 0) {\n\t\tdev_err(edac->dev, \"edac_device_add_device failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_INT)\n\t\tedac_dev->op_state = OP_RUNNING_INTERRUPT;\n\n\tlist_add(&ctx->next, &edac->pmds);\n\n\txgene_edac_pmd_hw_ctl(edac_dev, 1);\n\n\tdevres_remove_group(edac->dev, xgene_edac_pmd_add);\n\n\tdev_info(edac->dev, \"X-Gene EDAC PMD%d registered\\n\", ctx->pmd);\n\treturn 0;\n\nerr_free:\n\tedac_device_free_ctl_info(edac_dev);\nerr_group:\n\tdevres_release_group(edac->dev, xgene_edac_pmd_add);\n\treturn rc;\n}\n\nstatic int xgene_edac_pmd_remove(struct xgene_edac_pmd_ctx *pmd)\n{\n\tstruct edac_device_ctl_info *edac_dev = pmd->edac_dev;\n\n\txgene_edac_pmd_hw_ctl(edac_dev, 0);\n\tedac_device_del_device(edac_dev->dev);\n\tedac_device_free_ctl_info(edac_dev);\n\treturn 0;\n}\n\n \n#define L3C_ESR\t\t\t\t(0x0A * 4)\n#define  L3C_ESR_DATATAG_MASK\t\tBIT(9)\n#define  L3C_ESR_MULTIHIT_MASK\t\tBIT(8)\n#define  L3C_ESR_UCEVICT_MASK\t\tBIT(6)\n#define  L3C_ESR_MULTIUCERR_MASK\tBIT(5)\n#define  L3C_ESR_MULTICERR_MASK\t\tBIT(4)\n#define  L3C_ESR_UCERR_MASK\t\tBIT(3)\n#define  L3C_ESR_CERR_MASK\t\tBIT(2)\n#define  L3C_ESR_UCERRINTR_MASK\t\tBIT(1)\n#define  L3C_ESR_CERRINTR_MASK\t\tBIT(0)\n#define L3C_ECR\t\t\t\t(0x0B * 4)\n#define  L3C_ECR_UCINTREN\t\tBIT(3)\n#define  L3C_ECR_CINTREN\t\tBIT(2)\n#define  L3C_UCERREN\t\t\tBIT(1)\n#define  L3C_CERREN\t\t\tBIT(0)\n#define L3C_ELR\t\t\t\t(0x0C * 4)\n#define  L3C_ELR_ERRSYN(src)\t\t((src & 0xFF800000) >> 23)\n#define  L3C_ELR_ERRWAY(src)\t\t((src & 0x007E0000) >> 17)\n#define  L3C_ELR_AGENTID(src)\t\t((src & 0x0001E000) >> 13)\n#define  L3C_ELR_ERRGRP(src)\t\t((src & 0x00000F00) >> 8)\n#define  L3C_ELR_OPTYPE(src)\t\t((src & 0x000000F0) >> 4)\n#define  L3C_ELR_PADDRHIGH(src)\t\t(src & 0x0000000F)\n#define L3C_AELR\t\t\t(0x0D * 4)\n#define L3C_BELR\t\t\t(0x0E * 4)\n#define  L3C_BELR_BANK(src)\t\t(src & 0x0000000F)\n\nstruct xgene_edac_dev_ctx {\n\tstruct list_head\tnext;\n\tstruct device\t\tddev;\n\tchar\t\t\t*name;\n\tstruct xgene_edac\t*edac;\n\tstruct edac_device_ctl_info *edac_dev;\n\tint\t\t\tedac_idx;\n\tvoid __iomem\t\t*dev_csr;\n\tint\t\t\tversion;\n};\n\n \nstatic bool xgene_edac_l3_promote_to_uc_err(u32 l3cesr, u32 l3celr)\n{\n\tif (l3cesr & L3C_ESR_DATATAG_MASK) {\n\t\tswitch (L3C_ELR_ERRSYN(l3celr)) {\n\t\tcase 0x13C:\n\t\tcase 0x0B4:\n\t\tcase 0x007:\n\t\tcase 0x00D:\n\t\tcase 0x00E:\n\t\tcase 0x019:\n\t\tcase 0x01A:\n\t\tcase 0x01C:\n\t\tcase 0x04E:\n\t\tcase 0x041:\n\t\t\treturn true;\n\t\t}\n\t} else if (L3C_ELR_ERRWAY(l3celr) == 9)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void xgene_edac_l3_check(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\tu32 l3cesr;\n\tu32 l3celr;\n\tu32 l3caelr;\n\tu32 l3cbelr;\n\n\tl3cesr = readl(ctx->dev_csr + L3C_ESR);\n\tif (!(l3cesr & (L3C_ESR_UCERR_MASK | L3C_ESR_CERR_MASK)))\n\t\treturn;\n\n\tif (l3cesr & L3C_ESR_UCERR_MASK)\n\t\tdev_err(edac_dev->dev, \"L3C uncorrectable error\\n\");\n\tif (l3cesr & L3C_ESR_CERR_MASK)\n\t\tdev_warn(edac_dev->dev, \"L3C correctable error\\n\");\n\n\tl3celr = readl(ctx->dev_csr + L3C_ELR);\n\tl3caelr = readl(ctx->dev_csr + L3C_AELR);\n\tl3cbelr = readl(ctx->dev_csr + L3C_BELR);\n\tif (l3cesr & L3C_ESR_MULTIHIT_MASK)\n\t\tdev_err(edac_dev->dev, \"L3C multiple hit error\\n\");\n\tif (l3cesr & L3C_ESR_UCEVICT_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"L3C dropped eviction of line with error\\n\");\n\tif (l3cesr & L3C_ESR_MULTIUCERR_MASK)\n\t\tdev_err(edac_dev->dev, \"L3C multiple uncorrectable error\\n\");\n\tif (l3cesr & L3C_ESR_DATATAG_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"L3C data error syndrome 0x%X group 0x%X\\n\",\n\t\t\tL3C_ELR_ERRSYN(l3celr), L3C_ELR_ERRGRP(l3celr));\n\telse\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"L3C tag error syndrome 0x%X Way of Tag 0x%X Agent ID 0x%X Operation type 0x%X\\n\",\n\t\t\tL3C_ELR_ERRSYN(l3celr), L3C_ELR_ERRWAY(l3celr),\n\t\t\tL3C_ELR_AGENTID(l3celr), L3C_ELR_OPTYPE(l3celr));\n\t \n\tdev_err(edac_dev->dev, \"L3C error address 0x%08X.%08X bank %d\\n\",\n\t\tL3C_ELR_PADDRHIGH(l3celr) << 6 | (l3caelr >> 26),\n\t\t(l3caelr & 0x3FFFFFFF) << 6, L3C_BELR_BANK(l3cbelr));\n\tdev_err(edac_dev->dev,\n\t\t\"L3C error status register value 0x%X\\n\", l3cesr);\n\n\t \n\twritel(0, ctx->dev_csr + L3C_ESR);\n\n\tif (ctx->version <= 1 &&\n\t    xgene_edac_l3_promote_to_uc_err(l3cesr, l3celr)) {\n\t\tedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\n\t\treturn;\n\t}\n\tif (l3cesr & L3C_ESR_CERR_MASK)\n\t\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n\tif (l3cesr & L3C_ESR_UCERR_MASK)\n\t\tedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\n}\n\nstatic void xgene_edac_l3_hw_init(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t  bool enable)\n{\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\tu32 val;\n\n\tval = readl(ctx->dev_csr + L3C_ECR);\n\tval |= L3C_UCERREN | L3C_CERREN;\n\t \n\tif (edac_dev->op_state == OP_RUNNING_INTERRUPT) {\n\t\tif (enable)\n\t\t\tval |= L3C_ECR_UCINTREN | L3C_ECR_CINTREN;\n\t\telse\n\t\t\tval &= ~(L3C_ECR_UCINTREN | L3C_ECR_CINTREN);\n\t}\n\twritel(val, ctx->dev_csr + L3C_ECR);\n\n\tif (edac_dev->op_state == OP_RUNNING_INTERRUPT) {\n\t\t \n\t\tif (enable) {\n\t\t\txgene_edac_pcp_clrbits(ctx->edac, PCPHPERRINTMSK,\n\t\t\t\t\t       L3C_UNCORR_ERR_MASK);\n\t\t\txgene_edac_pcp_clrbits(ctx->edac, PCPLPERRINTMSK,\n\t\t\t\t\t       L3C_CORR_ERR_MASK);\n\t\t} else {\n\t\t\txgene_edac_pcp_setbits(ctx->edac, PCPHPERRINTMSK,\n\t\t\t\t\t       L3C_UNCORR_ERR_MASK);\n\t\t\txgene_edac_pcp_setbits(ctx->edac, PCPLPERRINTMSK,\n\t\t\t\t\t       L3C_CORR_ERR_MASK);\n\t\t}\n\t}\n}\n\nstatic ssize_t xgene_edac_l3_inject_ctrl_write(struct file *file,\n\t\t\t\t\t       const char __user *data,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dev = file->private_data;\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\n\t \n\twritel(0xFFFFFFFF, ctx->dev_csr + L3C_ESR);\n\treturn count;\n}\n\nstatic const struct file_operations xgene_edac_l3_debug_inject_fops = {\n\t.open = simple_open,\n\t.write = xgene_edac_l3_inject_ctrl_write,\n\t.llseek = generic_file_llseek\n};\n\nstatic void\nxgene_edac_l3_create_debugfs_nodes(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\tstruct dentry *dbgfs_dir;\n\tchar name[10];\n\n\tif (!IS_ENABLED(CONFIG_EDAC_DEBUG) || !ctx->edac->dfs)\n\t\treturn;\n\n\tsnprintf(name, sizeof(name), \"l3c%d\", ctx->edac_idx);\n\tdbgfs_dir = edac_debugfs_create_dir_at(name, ctx->edac->dfs);\n\tif (!dbgfs_dir)\n\t\treturn;\n\n\tdebugfs_create_file(\"l3_inject_ctrl\", S_IWUSR, dbgfs_dir, edac_dev,\n\t\t\t    &xgene_edac_l3_debug_inject_fops);\n}\n\nstatic int xgene_edac_l3_add(struct xgene_edac *edac, struct device_node *np,\n\t\t\t     int version)\n{\n\tstruct edac_device_ctl_info *edac_dev;\n\tstruct xgene_edac_dev_ctx *ctx;\n\tstruct resource res;\n\tvoid __iomem *dev_csr;\n\tint edac_idx;\n\tint rc = 0;\n\n\tif (!devres_open_group(edac->dev, xgene_edac_l3_add, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\trc = of_address_to_resource(np, 0, &res);\n\tif (rc < 0) {\n\t\tdev_err(edac->dev, \"no L3 resource address\\n\");\n\t\tgoto err_release_group;\n\t}\n\tdev_csr = devm_ioremap_resource(edac->dev, &res);\n\tif (IS_ERR(dev_csr)) {\n\t\tdev_err(edac->dev,\n\t\t\t\"devm_ioremap_resource failed for L3 resource address\\n\");\n\t\trc = PTR_ERR(dev_csr);\n\t\tgoto err_release_group;\n\t}\n\n\tedac_idx = edac_device_alloc_index();\n\tedac_dev = edac_device_alloc_ctl_info(sizeof(*ctx),\n\t\t\t\t\t      \"l3c\", 1, \"l3c\", 1, 0, NULL, 0,\n\t\t\t\t\t      edac_idx);\n\tif (!edac_dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_release_group;\n\t}\n\n\tctx = edac_dev->pvt_info;\n\tctx->dev_csr = dev_csr;\n\tctx->name = \"xgene_l3_err\";\n\tctx->edac_idx = edac_idx;\n\tctx->edac = edac;\n\tctx->edac_dev = edac_dev;\n\tctx->ddev = *edac->dev;\n\tctx->version = version;\n\tedac_dev->dev = &ctx->ddev;\n\tedac_dev->ctl_name = ctx->name;\n\tedac_dev->dev_name = ctx->name;\n\tedac_dev->mod_name = EDAC_MOD_STR;\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tedac_dev->edac_check = xgene_edac_l3_check;\n\n\txgene_edac_l3_create_debugfs_nodes(edac_dev);\n\n\trc = edac_device_add_device(edac_dev);\n\tif (rc > 0) {\n\t\tdev_err(edac->dev, \"failed edac_device_add_device()\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_ctl_free;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_INT)\n\t\tedac_dev->op_state = OP_RUNNING_INTERRUPT;\n\n\tlist_add(&ctx->next, &edac->l3s);\n\n\txgene_edac_l3_hw_init(edac_dev, 1);\n\n\tdevres_remove_group(edac->dev, xgene_edac_l3_add);\n\n\tdev_info(edac->dev, \"X-Gene EDAC L3 registered\\n\");\n\treturn 0;\n\nerr_ctl_free:\n\tedac_device_free_ctl_info(edac_dev);\nerr_release_group:\n\tdevres_release_group(edac->dev, xgene_edac_l3_add);\n\treturn rc;\n}\n\nstatic int xgene_edac_l3_remove(struct xgene_edac_dev_ctx *l3)\n{\n\tstruct edac_device_ctl_info *edac_dev = l3->edac_dev;\n\n\txgene_edac_l3_hw_init(edac_dev, 0);\n\tedac_device_del_device(l3->edac->dev);\n\tedac_device_free_ctl_info(edac_dev);\n\treturn 0;\n}\n\n \n#define IOBAXIS0TRANSERRINTSTS\t\t0x0000\n#define  IOBAXIS0_M_ILLEGAL_ACCESS_MASK\tBIT(1)\n#define  IOBAXIS0_ILLEGAL_ACCESS_MASK\tBIT(0)\n#define IOBAXIS0TRANSERRINTMSK\t\t0x0004\n#define IOBAXIS0TRANSERRREQINFOL\t0x0008\n#define IOBAXIS0TRANSERRREQINFOH\t0x000c\n#define  REQTYPE_RD(src)\t\t(((src) & BIT(0)))\n#define  ERRADDRH_RD(src)\t\t(((src) & 0xffc00000) >> 22)\n#define IOBAXIS1TRANSERRINTSTS\t\t0x0010\n#define IOBAXIS1TRANSERRINTMSK\t\t0x0014\n#define IOBAXIS1TRANSERRREQINFOL\t0x0018\n#define IOBAXIS1TRANSERRREQINFOH\t0x001c\n#define IOBPATRANSERRINTSTS\t\t0x0020\n#define  IOBPA_M_REQIDRAM_CORRUPT_MASK\tBIT(7)\n#define  IOBPA_REQIDRAM_CORRUPT_MASK\tBIT(6)\n#define  IOBPA_M_TRANS_CORRUPT_MASK\tBIT(5)\n#define  IOBPA_TRANS_CORRUPT_MASK\tBIT(4)\n#define  IOBPA_M_WDATA_CORRUPT_MASK\tBIT(3)\n#define  IOBPA_WDATA_CORRUPT_MASK\tBIT(2)\n#define  IOBPA_M_RDATA_CORRUPT_MASK\tBIT(1)\n#define  IOBPA_RDATA_CORRUPT_MASK\tBIT(0)\n#define IOBBATRANSERRINTSTS\t\t0x0030\n#define  M_ILLEGAL_ACCESS_MASK\t\tBIT(15)\n#define  ILLEGAL_ACCESS_MASK\t\tBIT(14)\n#define  M_WIDRAM_CORRUPT_MASK\t\tBIT(13)\n#define  WIDRAM_CORRUPT_MASK\t\tBIT(12)\n#define  M_RIDRAM_CORRUPT_MASK\t\tBIT(11)\n#define  RIDRAM_CORRUPT_MASK\t\tBIT(10)\n#define  M_TRANS_CORRUPT_MASK\t\tBIT(9)\n#define  TRANS_CORRUPT_MASK\t\tBIT(8)\n#define  M_WDATA_CORRUPT_MASK\t\tBIT(7)\n#define  WDATA_CORRUPT_MASK\t\tBIT(6)\n#define  M_RBM_POISONED_REQ_MASK\tBIT(5)\n#define  RBM_POISONED_REQ_MASK\t\tBIT(4)\n#define  M_XGIC_POISONED_REQ_MASK\tBIT(3)\n#define  XGIC_POISONED_REQ_MASK\t\tBIT(2)\n#define  M_WRERR_RESP_MASK\t\tBIT(1)\n#define  WRERR_RESP_MASK\t\tBIT(0)\n#define IOBBATRANSERRREQINFOL\t\t0x0038\n#define IOBBATRANSERRREQINFOH\t\t0x003c\n#define  REQTYPE_F2_RD(src)\t\t((src) & BIT(0))\n#define  ERRADDRH_F2_RD(src)\t\t(((src) & 0xffc00000) >> 22)\n#define IOBBATRANSERRCSWREQID\t\t0x0040\n#define XGICTRANSERRINTSTS\t\t0x0050\n#define  M_WR_ACCESS_ERR_MASK\t\tBIT(3)\n#define  WR_ACCESS_ERR_MASK\t\tBIT(2)\n#define  M_RD_ACCESS_ERR_MASK\t\tBIT(1)\n#define  RD_ACCESS_ERR_MASK\t\tBIT(0)\n#define XGICTRANSERRINTMSK\t\t0x0054\n#define XGICTRANSERRREQINFO\t\t0x0058\n#define  REQTYPE_MASK\t\t\tBIT(26)\n#define  ERRADDR_RD(src)\t\t((src) & 0x03ffffff)\n#define GLBL_ERR_STS\t\t\t0x0800\n#define  MDED_ERR_MASK\t\t\tBIT(3)\n#define  DED_ERR_MASK\t\t\tBIT(2)\n#define  MSEC_ERR_MASK\t\t\tBIT(1)\n#define  SEC_ERR_MASK\t\t\tBIT(0)\n#define GLBL_SEC_ERRL\t\t\t0x0810\n#define GLBL_SEC_ERRH\t\t\t0x0818\n#define GLBL_MSEC_ERRL\t\t\t0x0820\n#define GLBL_MSEC_ERRH\t\t\t0x0828\n#define GLBL_DED_ERRL\t\t\t0x0830\n#define GLBL_DED_ERRLMASK\t\t0x0834\n#define GLBL_DED_ERRH\t\t\t0x0838\n#define GLBL_DED_ERRHMASK\t\t0x083c\n#define GLBL_MDED_ERRL\t\t\t0x0840\n#define GLBL_MDED_ERRLMASK\t\t0x0844\n#define GLBL_MDED_ERRH\t\t\t0x0848\n#define GLBL_MDED_ERRHMASK\t\t0x084c\n\n \n#define RBCSR\t\t\t\t0x0000\n#define STICKYERR_MASK\t\t\tBIT(0)\n#define RBEIR\t\t\t\t0x0008\n#define AGENT_OFFLINE_ERR_MASK\t\tBIT(30)\n#define UNIMPL_RBPAGE_ERR_MASK\t\tBIT(29)\n#define WORD_ALIGNED_ERR_MASK\t\tBIT(28)\n#define PAGE_ACCESS_ERR_MASK\t\tBIT(27)\n#define WRITE_ACCESS_MASK\t\tBIT(26)\n\nstatic const char * const soc_mem_err_v1[] = {\n\t\"10GbE0\",\n\t\"10GbE1\",\n\t\"Security\",\n\t\"SATA45\",\n\t\"SATA23/ETH23\",\n\t\"SATA01/ETH01\",\n\t\"USB1\",\n\t\"USB0\",\n\t\"QML\",\n\t\"QM0\",\n\t\"QM1 (XGbE01)\",\n\t\"PCIE4\",\n\t\"PCIE3\",\n\t\"PCIE2\",\n\t\"PCIE1\",\n\t\"PCIE0\",\n\t\"CTX Manager\",\n\t\"OCM\",\n\t\"1GbE\",\n\t\"CLE\",\n\t\"AHBC\",\n\t\"PktDMA\",\n\t\"GFC\",\n\t\"MSLIM\",\n\t\"10GbE2\",\n\t\"10GbE3\",\n\t\"QM2 (XGbE23)\",\n\t\"IOB\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n\t\"unknown\",\n};\n\nstatic void xgene_edac_iob_gic_report(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\tu32 err_addr_lo;\n\tu32 err_addr_hi;\n\tu32 reg;\n\tu32 info;\n\n\t \n\treg = readl(ctx->dev_csr + XGICTRANSERRINTSTS);\n\tif (!reg)\n\t\tgoto chk_iob_err;\n\tdev_err(edac_dev->dev, \"XGIC transaction error\\n\");\n\tif (reg & RD_ACCESS_ERR_MASK)\n\t\tdev_err(edac_dev->dev, \"XGIC read size error\\n\");\n\tif (reg & M_RD_ACCESS_ERR_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple XGIC read size error\\n\");\n\tif (reg & WR_ACCESS_ERR_MASK)\n\t\tdev_err(edac_dev->dev, \"XGIC write size error\\n\");\n\tif (reg & M_WR_ACCESS_ERR_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple XGIC write size error\\n\");\n\tinfo = readl(ctx->dev_csr + XGICTRANSERRREQINFO);\n\tdev_err(edac_dev->dev, \"XGIC %s access @ 0x%08X (0x%08X)\\n\",\n\t\tinfo & REQTYPE_MASK ? \"read\" : \"write\", ERRADDR_RD(info),\n\t\tinfo);\n\twritel(reg, ctx->dev_csr + XGICTRANSERRINTSTS);\n\nchk_iob_err:\n\t \n\treg = readl(ctx->dev_csr + GLBL_ERR_STS);\n\tif (!reg)\n\t\treturn;\n\tif (reg & SEC_ERR_MASK) {\n\t\terr_addr_lo = readl(ctx->dev_csr + GLBL_SEC_ERRL);\n\t\terr_addr_hi = readl(ctx->dev_csr + GLBL_SEC_ERRH);\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"IOB single-bit correctable memory at 0x%08X.%08X error\\n\",\n\t\t\terr_addr_lo, err_addr_hi);\n\t\twritel(err_addr_lo, ctx->dev_csr + GLBL_SEC_ERRL);\n\t\twritel(err_addr_hi, ctx->dev_csr + GLBL_SEC_ERRH);\n\t}\n\tif (reg & MSEC_ERR_MASK) {\n\t\terr_addr_lo = readl(ctx->dev_csr + GLBL_MSEC_ERRL);\n\t\terr_addr_hi = readl(ctx->dev_csr + GLBL_MSEC_ERRH);\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"IOB multiple single-bit correctable memory at 0x%08X.%08X error\\n\",\n\t\t\terr_addr_lo, err_addr_hi);\n\t\twritel(err_addr_lo, ctx->dev_csr + GLBL_MSEC_ERRL);\n\t\twritel(err_addr_hi, ctx->dev_csr + GLBL_MSEC_ERRH);\n\t}\n\tif (reg & (SEC_ERR_MASK | MSEC_ERR_MASK))\n\t\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n\n\tif (reg & DED_ERR_MASK) {\n\t\terr_addr_lo = readl(ctx->dev_csr + GLBL_DED_ERRL);\n\t\terr_addr_hi = readl(ctx->dev_csr + GLBL_DED_ERRH);\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"IOB double-bit uncorrectable memory at 0x%08X.%08X error\\n\",\n\t\t\terr_addr_lo, err_addr_hi);\n\t\twritel(err_addr_lo, ctx->dev_csr + GLBL_DED_ERRL);\n\t\twritel(err_addr_hi, ctx->dev_csr + GLBL_DED_ERRH);\n\t}\n\tif (reg & MDED_ERR_MASK) {\n\t\terr_addr_lo = readl(ctx->dev_csr + GLBL_MDED_ERRL);\n\t\terr_addr_hi = readl(ctx->dev_csr + GLBL_MDED_ERRH);\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB double-bit uncorrectable memory at 0x%08X.%08X error\\n\",\n\t\t\terr_addr_lo, err_addr_hi);\n\t\twritel(err_addr_lo, ctx->dev_csr + GLBL_MDED_ERRL);\n\t\twritel(err_addr_hi, ctx->dev_csr + GLBL_MDED_ERRH);\n\t}\n\tif (reg & (DED_ERR_MASK | MDED_ERR_MASK))\n\t\tedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\n}\n\nstatic void xgene_edac_rb_report(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\tu32 err_addr_lo;\n\tu32 err_addr_hi;\n\tu32 reg;\n\n\t \n\tif (!ctx->edac->rb_map)\n\t\tgoto rb_skip;\n\n\t \n\tif (regmap_read(ctx->edac->rb_map, RBCSR, &reg))\n\t\treturn;\n\tif (reg & STICKYERR_MASK) {\n\t\tbool write;\n\n\t\tdev_err(edac_dev->dev, \"IOB bus access error(s)\\n\");\n\t\tif (regmap_read(ctx->edac->rb_map, RBEIR, &reg))\n\t\t\treturn;\n\t\twrite = reg & WRITE_ACCESS_MASK ? 1 : 0;\n\t\tif (reg & AGENT_OFFLINE_ERR_MASK)\n\t\t\tdev_err(edac_dev->dev,\n\t\t\t\t\"IOB bus %s access to offline agent error\\n\",\n\t\t\t\twrite ? \"write\" : \"read\");\n\t\tif (reg & UNIMPL_RBPAGE_ERR_MASK)\n\t\t\tdev_err(edac_dev->dev,\n\t\t\t\t\"IOB bus %s access to unimplemented page error\\n\",\n\t\t\t\twrite ? \"write\" : \"read\");\n\t\tif (reg & WORD_ALIGNED_ERR_MASK)\n\t\t\tdev_err(edac_dev->dev,\n\t\t\t\t\"IOB bus %s word aligned access error\\n\",\n\t\t\t\twrite ? \"write\" : \"read\");\n\t\tif (reg & PAGE_ACCESS_ERR_MASK)\n\t\t\tdev_err(edac_dev->dev,\n\t\t\t\t\"IOB bus %s to page out of range access error\\n\",\n\t\t\t\twrite ? \"write\" : \"read\");\n\t\tif (regmap_write(ctx->edac->rb_map, RBEIR, 0))\n\t\t\treturn;\n\t\tif (regmap_write(ctx->edac->rb_map, RBCSR, 0))\n\t\t\treturn;\n\t}\nrb_skip:\n\n\t \n\treg = readl(ctx->dev_csr + IOBBATRANSERRINTSTS);\n\tif (!reg)\n\t\treturn;\n\n\tdev_err(edac_dev->dev, \"IOB bridge agent (BA) transaction error\\n\");\n\tif (reg & WRERR_RESP_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB BA write response error\\n\");\n\tif (reg & M_WRERR_RESP_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB BA write response error\\n\");\n\tif (reg & XGIC_POISONED_REQ_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB BA XGIC poisoned write error\\n\");\n\tif (reg & M_XGIC_POISONED_REQ_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB BA XGIC poisoned write error\\n\");\n\tif (reg & RBM_POISONED_REQ_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB BA RBM poisoned write error\\n\");\n\tif (reg & M_RBM_POISONED_REQ_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB BA RBM poisoned write error\\n\");\n\tif (reg & WDATA_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB BA write error\\n\");\n\tif (reg & M_WDATA_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple IOB BA write error\\n\");\n\tif (reg & TRANS_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB BA transaction error\\n\");\n\tif (reg & M_TRANS_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple IOB BA transaction error\\n\");\n\tif (reg & RIDRAM_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"IOB BA RDIDRAM read transaction ID error\\n\");\n\tif (reg & M_RIDRAM_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB BA RDIDRAM read transaction ID error\\n\");\n\tif (reg & WIDRAM_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"IOB BA RDIDRAM write transaction ID error\\n\");\n\tif (reg & M_WIDRAM_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB BA RDIDRAM write transaction ID error\\n\");\n\tif (reg & ILLEGAL_ACCESS_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"IOB BA XGIC/RB illegal access error\\n\");\n\tif (reg & M_ILLEGAL_ACCESS_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB BA XGIC/RB illegal access error\\n\");\n\n\terr_addr_lo = readl(ctx->dev_csr + IOBBATRANSERRREQINFOL);\n\terr_addr_hi = readl(ctx->dev_csr + IOBBATRANSERRREQINFOH);\n\tdev_err(edac_dev->dev, \"IOB BA %s access at 0x%02X.%08X (0x%08X)\\n\",\n\t\tREQTYPE_F2_RD(err_addr_hi) ? \"read\" : \"write\",\n\t\tERRADDRH_F2_RD(err_addr_hi), err_addr_lo, err_addr_hi);\n\tif (reg & WRERR_RESP_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB BA requestor ID 0x%08X\\n\",\n\t\t\treadl(ctx->dev_csr + IOBBATRANSERRCSWREQID));\n\twritel(reg, ctx->dev_csr + IOBBATRANSERRINTSTS);\n}\n\nstatic void xgene_edac_pa_report(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\tu32 err_addr_lo;\n\tu32 err_addr_hi;\n\tu32 reg;\n\n\t \n\treg = readl(ctx->dev_csr + IOBPATRANSERRINTSTS);\n\tif (!reg)\n\t\tgoto chk_iob_axi0;\n\tdev_err(edac_dev->dev, \"IOB processing agent (PA) transaction error\\n\");\n\tif (reg & IOBPA_RDATA_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB PA read data RAM error\\n\");\n\tif (reg & IOBPA_M_RDATA_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB PA read data RAM error\\n\");\n\tif (reg & IOBPA_WDATA_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB PA write data RAM error\\n\");\n\tif (reg & IOBPA_M_WDATA_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB PA write data RAM error\\n\");\n\tif (reg & IOBPA_TRANS_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB PA transaction error\\n\");\n\tif (reg & IOBPA_M_TRANS_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"Multiple IOB PA transaction error\\n\");\n\tif (reg & IOBPA_REQIDRAM_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev, \"IOB PA transaction ID RAM error\\n\");\n\tif (reg & IOBPA_M_REQIDRAM_CORRUPT_MASK)\n\t\tdev_err(edac_dev->dev,\n\t\t\t\"Multiple IOB PA transaction ID RAM error\\n\");\n\twritel(reg, ctx->dev_csr + IOBPATRANSERRINTSTS);\n\nchk_iob_axi0:\n\t \n\treg = readl(ctx->dev_csr + IOBAXIS0TRANSERRINTSTS);\n\tif (!reg)\n\t\tgoto chk_iob_axi1;\n\terr_addr_lo = readl(ctx->dev_csr + IOBAXIS0TRANSERRREQINFOL);\n\terr_addr_hi = readl(ctx->dev_csr + IOBAXIS0TRANSERRREQINFOH);\n\tdev_err(edac_dev->dev,\n\t\t\"%sAXI slave 0 illegal %s access @ 0x%02X.%08X (0x%08X)\\n\",\n\t\treg & IOBAXIS0_M_ILLEGAL_ACCESS_MASK ? \"Multiple \" : \"\",\n\t\tREQTYPE_RD(err_addr_hi) ? \"read\" : \"write\",\n\t\tERRADDRH_RD(err_addr_hi), err_addr_lo, err_addr_hi);\n\twritel(reg, ctx->dev_csr + IOBAXIS0TRANSERRINTSTS);\n\nchk_iob_axi1:\n\t \n\treg = readl(ctx->dev_csr + IOBAXIS1TRANSERRINTSTS);\n\tif (!reg)\n\t\treturn;\n\terr_addr_lo = readl(ctx->dev_csr + IOBAXIS1TRANSERRREQINFOL);\n\terr_addr_hi = readl(ctx->dev_csr + IOBAXIS1TRANSERRREQINFOH);\n\tdev_err(edac_dev->dev,\n\t\t\"%sAXI slave 1 illegal %s access @ 0x%02X.%08X (0x%08X)\\n\",\n\t\treg & IOBAXIS0_M_ILLEGAL_ACCESS_MASK ? \"Multiple \" : \"\",\n\t\tREQTYPE_RD(err_addr_hi) ? \"read\" : \"write\",\n\t\tERRADDRH_RD(err_addr_hi), err_addr_lo, err_addr_hi);\n\twritel(reg, ctx->dev_csr + IOBAXIS1TRANSERRINTSTS);\n}\n\nstatic void xgene_edac_soc_check(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\tconst char * const *soc_mem_err = NULL;\n\tu32 pcp_hp_stat;\n\tu32 pcp_lp_stat;\n\tu32 reg;\n\tint i;\n\n\txgene_edac_pcp_rd(ctx->edac, PCPHPERRINTSTS, &pcp_hp_stat);\n\txgene_edac_pcp_rd(ctx->edac, PCPLPERRINTSTS, &pcp_lp_stat);\n\txgene_edac_pcp_rd(ctx->edac, MEMERRINTSTS, &reg);\n\tif (!((pcp_hp_stat & (IOB_PA_ERR_MASK | IOB_BA_ERR_MASK |\n\t\t\t      IOB_XGIC_ERR_MASK | IOB_RB_ERR_MASK)) ||\n\t      (pcp_lp_stat & CSW_SWITCH_TRACE_ERR_MASK) || reg))\n\t\treturn;\n\n\tif (pcp_hp_stat & IOB_XGIC_ERR_MASK)\n\t\txgene_edac_iob_gic_report(edac_dev);\n\n\tif (pcp_hp_stat & (IOB_RB_ERR_MASK | IOB_BA_ERR_MASK))\n\t\txgene_edac_rb_report(edac_dev);\n\n\tif (pcp_hp_stat & IOB_PA_ERR_MASK)\n\t\txgene_edac_pa_report(edac_dev);\n\n\tif (pcp_lp_stat & CSW_SWITCH_TRACE_ERR_MASK) {\n\t\tdev_info(edac_dev->dev,\n\t\t\t \"CSW switch trace correctable memory parity error\\n\");\n\t\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n\t}\n\n\tif (!reg)\n\t\treturn;\n\tif (ctx->version == 1)\n\t\tsoc_mem_err = soc_mem_err_v1;\n\tif (!soc_mem_err) {\n\t\tdev_err(edac_dev->dev, \"SoC memory parity error 0x%08X\\n\",\n\t\t\treg);\n\t\tedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\n\t\treturn;\n\t}\n\tfor (i = 0; i < 31; i++) {\n\t\tif (reg & (1 << i)) {\n\t\t\tdev_err(edac_dev->dev, \"%s memory parity error\\n\",\n\t\t\t\tsoc_mem_err[i]);\n\t\t\tedac_device_handle_ue(edac_dev, 0, 0,\n\t\t\t\t\t      edac_dev->ctl_name);\n\t\t}\n\t}\n}\n\nstatic void xgene_edac_soc_hw_init(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t   bool enable)\n{\n\tstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\n\n\t \n\tif (edac_dev->op_state == OP_RUNNING_INTERRUPT) {\n\t\tif (enable) {\n\t\t\txgene_edac_pcp_clrbits(ctx->edac, PCPHPERRINTMSK,\n\t\t\t\t\t       IOB_PA_ERR_MASK |\n\t\t\t\t\t       IOB_BA_ERR_MASK |\n\t\t\t\t\t       IOB_XGIC_ERR_MASK |\n\t\t\t\t\t       IOB_RB_ERR_MASK);\n\t\t\txgene_edac_pcp_clrbits(ctx->edac, PCPLPERRINTMSK,\n\t\t\t\t\t       CSW_SWITCH_TRACE_ERR_MASK);\n\t\t} else {\n\t\t\txgene_edac_pcp_setbits(ctx->edac, PCPHPERRINTMSK,\n\t\t\t\t\t       IOB_PA_ERR_MASK |\n\t\t\t\t\t       IOB_BA_ERR_MASK |\n\t\t\t\t\t       IOB_XGIC_ERR_MASK |\n\t\t\t\t\t       IOB_RB_ERR_MASK);\n\t\t\txgene_edac_pcp_setbits(ctx->edac, PCPLPERRINTMSK,\n\t\t\t\t\t       CSW_SWITCH_TRACE_ERR_MASK);\n\t\t}\n\n\t\twritel(enable ? 0x0 : 0xFFFFFFFF,\n\t\t       ctx->dev_csr + IOBAXIS0TRANSERRINTMSK);\n\t\twritel(enable ? 0x0 : 0xFFFFFFFF,\n\t\t       ctx->dev_csr + IOBAXIS1TRANSERRINTMSK);\n\t\twritel(enable ? 0x0 : 0xFFFFFFFF,\n\t\t       ctx->dev_csr + XGICTRANSERRINTMSK);\n\n\t\txgene_edac_pcp_setbits(ctx->edac, MEMERRINTMSK,\n\t\t\t\t       enable ? 0x0 : 0xFFFFFFFF);\n\t}\n}\n\nstatic int xgene_edac_soc_add(struct xgene_edac *edac, struct device_node *np,\n\t\t\t      int version)\n{\n\tstruct edac_device_ctl_info *edac_dev;\n\tstruct xgene_edac_dev_ctx *ctx;\n\tvoid __iomem *dev_csr;\n\tstruct resource res;\n\tint edac_idx;\n\tint rc;\n\n\tif (!devres_open_group(edac->dev, xgene_edac_soc_add, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\trc = of_address_to_resource(np, 0, &res);\n\tif (rc < 0) {\n\t\tdev_err(edac->dev, \"no SoC resource address\\n\");\n\t\tgoto err_release_group;\n\t}\n\tdev_csr = devm_ioremap_resource(edac->dev, &res);\n\tif (IS_ERR(dev_csr)) {\n\t\tdev_err(edac->dev,\n\t\t\t\"devm_ioremap_resource failed for soc resource address\\n\");\n\t\trc = PTR_ERR(dev_csr);\n\t\tgoto err_release_group;\n\t}\n\n\tedac_idx = edac_device_alloc_index();\n\tedac_dev = edac_device_alloc_ctl_info(sizeof(*ctx),\n\t\t\t\t\t      \"SOC\", 1, \"SOC\", 1, 2, NULL, 0,\n\t\t\t\t\t      edac_idx);\n\tif (!edac_dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_release_group;\n\t}\n\n\tctx = edac_dev->pvt_info;\n\tctx->dev_csr = dev_csr;\n\tctx->name = \"xgene_soc_err\";\n\tctx->edac_idx = edac_idx;\n\tctx->edac = edac;\n\tctx->edac_dev = edac_dev;\n\tctx->ddev = *edac->dev;\n\tctx->version = version;\n\tedac_dev->dev = &ctx->ddev;\n\tedac_dev->ctl_name = ctx->name;\n\tedac_dev->dev_name = ctx->name;\n\tedac_dev->mod_name = EDAC_MOD_STR;\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tedac_dev->edac_check = xgene_edac_soc_check;\n\n\trc = edac_device_add_device(edac_dev);\n\tif (rc > 0) {\n\t\tdev_err(edac->dev, \"failed edac_device_add_device()\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_ctl_free;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_INT)\n\t\tedac_dev->op_state = OP_RUNNING_INTERRUPT;\n\n\tlist_add(&ctx->next, &edac->socs);\n\n\txgene_edac_soc_hw_init(edac_dev, 1);\n\n\tdevres_remove_group(edac->dev, xgene_edac_soc_add);\n\n\tdev_info(edac->dev, \"X-Gene EDAC SoC registered\\n\");\n\n\treturn 0;\n\nerr_ctl_free:\n\tedac_device_free_ctl_info(edac_dev);\nerr_release_group:\n\tdevres_release_group(edac->dev, xgene_edac_soc_add);\n\treturn rc;\n}\n\nstatic int xgene_edac_soc_remove(struct xgene_edac_dev_ctx *soc)\n{\n\tstruct edac_device_ctl_info *edac_dev = soc->edac_dev;\n\n\txgene_edac_soc_hw_init(edac_dev, 0);\n\tedac_device_del_device(soc->edac->dev);\n\tedac_device_free_ctl_info(edac_dev);\n\treturn 0;\n}\n\nstatic irqreturn_t xgene_edac_isr(int irq, void *dev_id)\n{\n\tstruct xgene_edac *ctx = dev_id;\n\tstruct xgene_edac_pmd_ctx *pmd;\n\tstruct xgene_edac_dev_ctx *node;\n\tunsigned int pcp_hp_stat;\n\tunsigned int pcp_lp_stat;\n\n\txgene_edac_pcp_rd(ctx, PCPHPERRINTSTS, &pcp_hp_stat);\n\txgene_edac_pcp_rd(ctx, PCPLPERRINTSTS, &pcp_lp_stat);\n\tif ((MCU_UNCORR_ERR_MASK & pcp_hp_stat) ||\n\t    (MCU_CTL_ERR_MASK & pcp_hp_stat) ||\n\t    (MCU_CORR_ERR_MASK & pcp_lp_stat)) {\n\t\tstruct xgene_edac_mc_ctx *mcu;\n\n\t\tlist_for_each_entry(mcu, &ctx->mcus, next)\n\t\t\txgene_edac_mc_check(mcu->mci);\n\t}\n\n\tlist_for_each_entry(pmd, &ctx->pmds, next) {\n\t\tif ((PMD0_MERR_MASK << pmd->pmd) & pcp_hp_stat)\n\t\t\txgene_edac_pmd_check(pmd->edac_dev);\n\t}\n\n\tlist_for_each_entry(node, &ctx->l3s, next)\n\t\txgene_edac_l3_check(node->edac_dev);\n\n\tlist_for_each_entry(node, &ctx->socs, next)\n\t\txgene_edac_soc_check(node->edac_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xgene_edac_probe(struct platform_device *pdev)\n{\n\tstruct xgene_edac *edac;\n\tstruct device_node *child;\n\tstruct resource *res;\n\tint rc;\n\n\tedac = devm_kzalloc(&pdev->dev, sizeof(*edac), GFP_KERNEL);\n\tif (!edac)\n\t\treturn -ENOMEM;\n\n\tedac->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, edac);\n\tINIT_LIST_HEAD(&edac->mcus);\n\tINIT_LIST_HEAD(&edac->pmds);\n\tINIT_LIST_HEAD(&edac->l3s);\n\tINIT_LIST_HEAD(&edac->socs);\n\tspin_lock_init(&edac->lock);\n\tmutex_init(&edac->mc_lock);\n\n\tedac->csw_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t\"regmap-csw\");\n\tif (IS_ERR(edac->csw_map)) {\n\t\tdev_err(edac->dev, \"unable to get syscon regmap csw\\n\");\n\t\trc = PTR_ERR(edac->csw_map);\n\t\tgoto out_err;\n\t}\n\n\tedac->mcba_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t \"regmap-mcba\");\n\tif (IS_ERR(edac->mcba_map)) {\n\t\tdev_err(edac->dev, \"unable to get syscon regmap mcba\\n\");\n\t\trc = PTR_ERR(edac->mcba_map);\n\t\tgoto out_err;\n\t}\n\n\tedac->mcbb_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t \"regmap-mcbb\");\n\tif (IS_ERR(edac->mcbb_map)) {\n\t\tdev_err(edac->dev, \"unable to get syscon regmap mcbb\\n\");\n\t\trc = PTR_ERR(edac->mcbb_map);\n\t\tgoto out_err;\n\t}\n\tedac->efuse_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\t  \"regmap-efuse\");\n\tif (IS_ERR(edac->efuse_map)) {\n\t\tdev_err(edac->dev, \"unable to get syscon regmap efuse\\n\");\n\t\trc = PTR_ERR(edac->efuse_map);\n\t\tgoto out_err;\n\t}\n\n\t \n\tedac->rb_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t       \"regmap-rb\");\n\tif (IS_ERR(edac->rb_map)) {\n\t\tdev_warn(edac->dev, \"missing syscon regmap rb\\n\");\n\t\tedac->rb_map = NULL;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tedac->pcp_csr = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(edac->pcp_csr)) {\n\t\tdev_err(&pdev->dev, \"no PCP resource address\\n\");\n\t\trc = PTR_ERR(edac->pcp_csr);\n\t\tgoto out_err;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_INT) {\n\t\tint irq;\n\t\tint i;\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tirq = platform_get_irq_optional(pdev, i);\n\t\t\tif (irq < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"No IRQ resource\\n\");\n\t\t\t\trc = irq;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\trc = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t\t      xgene_edac_isr, IRQF_SHARED,\n\t\t\t\t\t      dev_name(&pdev->dev), edac);\n\t\t\tif (rc) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Could not request IRQ %d\\n\", irq);\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\t}\n\n\tedac->dfs = edac_debugfs_create_dir(pdev->dev.kobj.name);\n\n\tfor_each_child_of_node(pdev->dev.of_node, child) {\n\t\tif (!of_device_is_available(child))\n\t\t\tcontinue;\n\t\tif (of_device_is_compatible(child, \"apm,xgene-edac-mc\"))\n\t\t\txgene_edac_mc_add(edac, child);\n\t\tif (of_device_is_compatible(child, \"apm,xgene-edac-pmd\"))\n\t\t\txgene_edac_pmd_add(edac, child, 1);\n\t\tif (of_device_is_compatible(child, \"apm,xgene-edac-pmd-v2\"))\n\t\t\txgene_edac_pmd_add(edac, child, 2);\n\t\tif (of_device_is_compatible(child, \"apm,xgene-edac-l3\"))\n\t\t\txgene_edac_l3_add(edac, child, 1);\n\t\tif (of_device_is_compatible(child, \"apm,xgene-edac-l3-v2\"))\n\t\t\txgene_edac_l3_add(edac, child, 2);\n\t\tif (of_device_is_compatible(child, \"apm,xgene-edac-soc\"))\n\t\t\txgene_edac_soc_add(edac, child, 0);\n\t\tif (of_device_is_compatible(child, \"apm,xgene-edac-soc-v1\"))\n\t\t\txgene_edac_soc_add(edac, child, 1);\n\t}\n\n\treturn 0;\n\nout_err:\n\treturn rc;\n}\n\nstatic int xgene_edac_remove(struct platform_device *pdev)\n{\n\tstruct xgene_edac *edac = dev_get_drvdata(&pdev->dev);\n\tstruct xgene_edac_mc_ctx *mcu;\n\tstruct xgene_edac_mc_ctx *temp_mcu;\n\tstruct xgene_edac_pmd_ctx *pmd;\n\tstruct xgene_edac_pmd_ctx *temp_pmd;\n\tstruct xgene_edac_dev_ctx *node;\n\tstruct xgene_edac_dev_ctx *temp_node;\n\n\tlist_for_each_entry_safe(mcu, temp_mcu, &edac->mcus, next)\n\t\txgene_edac_mc_remove(mcu);\n\n\tlist_for_each_entry_safe(pmd, temp_pmd, &edac->pmds, next)\n\t\txgene_edac_pmd_remove(pmd);\n\n\tlist_for_each_entry_safe(node, temp_node, &edac->l3s, next)\n\t\txgene_edac_l3_remove(node);\n\n\tlist_for_each_entry_safe(node, temp_node, &edac->socs, next)\n\t\txgene_edac_soc_remove(node);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xgene_edac_of_match[] = {\n\t{ .compatible = \"apm,xgene-edac\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xgene_edac_of_match);\n\nstatic struct platform_driver xgene_edac_driver = {\n\t.probe = xgene_edac_probe,\n\t.remove = xgene_edac_remove,\n\t.driver = {\n\t\t.name = \"xgene-edac\",\n\t\t.of_match_table = xgene_edac_of_match,\n\t},\n};\n\nstatic int __init xgene_edac_init(void)\n{\n\tint rc;\n\n\tif (ghes_get_devices())\n\t\treturn -EBUSY;\n\n\t \n\tswitch (edac_op_state) {\n\tcase EDAC_OPSTATE_POLL:\n\tcase EDAC_OPSTATE_INT:\n\t\tbreak;\n\tdefault:\n\t\tedac_op_state = EDAC_OPSTATE_INT;\n\t\tbreak;\n\t}\n\n\trc = platform_driver_register(&xgene_edac_driver);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_STR,\n\t\t\t    \"EDAC fails to register\\n\");\n\t\tgoto reg_failed;\n\t}\n\n\treturn 0;\n\nreg_failed:\n\treturn rc;\n}\nmodule_init(xgene_edac_init);\n\nstatic void __exit xgene_edac_exit(void)\n{\n\tplatform_driver_unregister(&xgene_edac_driver);\n}\nmodule_exit(xgene_edac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Feng Kan <fkan@apm.com>\");\nMODULE_DESCRIPTION(\"APM X-Gene EDAC driver\");\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state,\n\t\t \"EDAC error reporting state: 0=Poll, 2=Interrupt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}