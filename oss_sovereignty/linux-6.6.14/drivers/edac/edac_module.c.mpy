{
  "module_name": "edac_module.c",
  "hash_id": "5f39dd24b7be90571851f1f0824585944deb669658a1fb74b5021d5533fe5eb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_module.c",
  "human_readable_source": " \n#include <linux/edac.h>\n\n#include \"edac_mc.h\"\n#include \"edac_module.h\"\n\n#define EDAC_VERSION \"Ver: 3.0.0\"\n\n#ifdef CONFIG_EDAC_DEBUG\n\nstatic int edac_set_debug_level(const char *buf,\n\t\t\t\tconst struct kernel_param *kp)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 4)\n\t\treturn -EINVAL;\n\n\treturn param_set_int(buf, kp);\n}\n\n \nint edac_debug_level = 2;\nEXPORT_SYMBOL_GPL(edac_debug_level);\n\nmodule_param_call(edac_debug_level, edac_set_debug_level, param_get_int,\n\t\t  &edac_debug_level, 0644);\nMODULE_PARM_DESC(edac_debug_level, \"EDAC debug level: [0-4], default: 2\");\n#endif\n\n \nchar *edac_op_state_to_string(int opstate)\n{\n\tif (opstate == OP_RUNNING_POLL)\n\t\treturn \"POLLED\";\n\telse if (opstate == OP_RUNNING_INTERRUPT)\n\t\treturn \"INTERRUPT\";\n\telse if (opstate == OP_RUNNING_POLL_INTR)\n\t\treturn \"POLL-INTR\";\n\telse if (opstate == OP_ALLOC)\n\t\treturn \"ALLOC\";\n\telse if (opstate == OP_OFFLINE)\n\t\treturn \"OFFLINE\";\n\n\treturn \"UNKNOWN\";\n}\n\n \nstatic struct bus_type edac_subsys = {\n\t.name = \"edac\",\n\t.dev_name = \"edac\",\n};\n\nstatic int edac_subsys_init(void)\n{\n\tint err;\n\n\t \n\terr = subsys_system_register(&edac_subsys, NULL);\n\tif (err)\n\t\tprintk(KERN_ERR \"Error registering toplevel EDAC sysfs dir\\n\");\n\n\treturn err;\n}\n\nstatic void edac_subsys_exit(void)\n{\n\tbus_unregister(&edac_subsys);\n}\n\n \nstruct bus_type *edac_get_sysfs_subsys(void)\n{\n\treturn &edac_subsys;\n}\nEXPORT_SYMBOL_GPL(edac_get_sysfs_subsys);\n \nstatic int __init edac_init(void)\n{\n\tint err = 0;\n\n\tedac_printk(KERN_INFO, EDAC_MC, EDAC_VERSION \"\\n\");\n\n\terr = edac_subsys_init();\n\tif (err)\n\t\treturn err;\n\n\t \n\tedac_pci_clear_parity_errors();\n\n\terr = edac_mc_sysfs_init();\n\tif (err)\n\t\tgoto err_sysfs;\n\n\tedac_debugfs_init();\n\n\terr = edac_workqueue_setup();\n\tif (err) {\n\t\tedac_printk(KERN_ERR, EDAC_MC, \"Failure initializing workqueue\\n\");\n\t\tgoto err_wq;\n\t}\n\n\treturn 0;\n\nerr_wq:\n\tedac_debugfs_exit();\n\tedac_mc_sysfs_exit();\n\nerr_sysfs:\n\tedac_subsys_exit();\n\n\treturn err;\n}\n\n \nstatic void __exit edac_exit(void)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tedac_workqueue_teardown();\n\tedac_mc_sysfs_exit();\n\tedac_debugfs_exit();\n\tedac_subsys_exit();\n}\n\n \nsubsys_initcall(edac_init);\nmodule_exit(edac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Doug Thompson www.softwarebitmaker.com, et al\");\nMODULE_DESCRIPTION(\"Core library routines for EDAC reporting\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}