{
  "module_name": "r82600_edac.c",
  "hash_id": "c80e051974651c1e53571d05666ba6a571020b5d9d05ac4fcddc5108eecaa6e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/r82600_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\"r82600_edac\"\n\n#define r82600_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"r82600\", fmt, ##arg)\n\n#define r82600_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"r82600\", fmt, ##arg)\n\n \n\n#define R82600_NR_CSROWS 4\n#define R82600_NR_CHANS  1\n#define R82600_NR_DIMMS  4\n\n#define R82600_BRIDGE_ID  0x8200\n\n \n#define R82600_DRAMC\t0x57\t \n\n#define R82600_SDRAMC\t0x76\t \n\n#define R82600_EAP\t0x80\t \n\n#define R82600_DRBA\t0x60\t \n\nstruct r82600_error_info {\n\tu32 eapr;\n};\n\nstatic bool disable_hardware_scrub;\n\nstatic struct edac_pci_ctl_info *r82600_pci;\n\nstatic void r82600_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct r82600_error_info *info)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(mci->pdev);\n\tpci_read_config_dword(pdev, R82600_EAP, &info->eapr);\n\n\tif (info->eapr & BIT(0))\n\t\t \n\t\tpci_write_bits32(pdev, R82600_EAP,\n\t\t\t\t ((u32) BIT(0) & (u32) BIT(1)),\n\t\t\t\t ((u32) BIT(0) & (u32) BIT(1)));\n\n\tif (info->eapr & BIT(1))\n\t\t \n\t\tpci_write_bits32(pdev, R82600_EAP,\n\t\t\t\t ((u32) BIT(0) & (u32) BIT(1)),\n\t\t\t\t ((u32) BIT(0) & (u32) BIT(1)));\n}\n\nstatic int r82600_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct r82600_error_info *info,\n\t\t\t\tint handle_errors)\n{\n\tint error_found;\n\tu32 eapaddr, page;\n\tu32 syndrome;\n\n\terror_found = 0;\n\n\t \n\teapaddr = ((info->eapr >> 12) & 0x7FFF) << 13;\n\t \n\tsyndrome = (info->eapr >> 4) & 0xFF;\n\n\t \n\tpage = eapaddr >> PAGE_SHIFT;\n\n\tif (info->eapr & BIT(0)) {\t \n\t\terror_found = 1;\n\n\t\tif (handle_errors)\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t\t     page, 0, syndrome,\n\t\t\t\t\t     edac_mc_find_csrow_by_page(mci, page),\n\t\t\t\t\t     0, -1,\n\t\t\t\t\t     mci->ctl_name, \"\");\n\t}\n\n\tif (info->eapr & BIT(1)) {\t \n\t\terror_found = 1;\n\n\t\tif (handle_errors)\n\t\t\t \n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\t     page, 0, 0,\n\t\t\t\t\t     edac_mc_find_csrow_by_page(mci, page),\n\t\t\t\t\t     0, -1,\n\t\t\t\t\t     mci->ctl_name, \"\");\n\t}\n\n\treturn error_found;\n}\n\nstatic void r82600_check(struct mem_ctl_info *mci)\n{\n\tstruct r82600_error_info info;\n\n\tr82600_get_error_info(mci, &info);\n\tr82600_process_error_info(mci, &info, 1);\n}\n\nstatic inline int ecc_enabled(u8 dramcr)\n{\n\treturn dramcr & BIT(5);\n}\n\nstatic void r82600_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\n\t\t\tu8 dramcr)\n{\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\tint index;\n\tu8 drbar;\t\t \n\tu32 row_high_limit, row_high_limit_last;\n\tu32 reg_sdram, ecc_on, row_base;\n\n\tecc_on = ecc_enabled(dramcr);\n\treg_sdram = dramcr & BIT(4);\n\trow_high_limit_last = 0;\n\n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\tcsrow = mci->csrows[index];\n\t\tdimm = csrow->channels[0]->dimm;\n\n\t\t \n\t\tpci_read_config_byte(pdev, R82600_DRBA + index, &drbar);\n\n\t\tedac_dbg(1, \"Row=%d DRBA = %#0x\\n\", index, drbar);\n\n\t\trow_high_limit = ((u32) drbar << 24);\n \n\n\t\tedac_dbg(1, \"Row=%d, Boundary Address=%#0x, Last = %#0x\\n\",\n\t\t\t index, row_high_limit, row_high_limit_last);\n\n\t\t \n\t\tif (row_high_limit == row_high_limit_last)\n\t\t\tcontinue;\n\n\t\trow_base = row_high_limit_last;\n\n\t\tcsrow->first_page = row_base >> PAGE_SHIFT;\n\t\tcsrow->last_page = (row_high_limit >> PAGE_SHIFT) - 1;\n\n\t\tdimm->nr_pages = csrow->last_page - csrow->first_page + 1;\n\t\t \n\t\tdimm->grain = 1 << 14;\n\t\tdimm->mtype = reg_sdram ? MEM_RDDR : MEM_DDR;\n\t\t \n\t\tdimm->dtype = DEV_UNKNOWN;\n\n\t\t \n\t\tdimm->edac_mode = ecc_on ? EDAC_SECDED : EDAC_NONE;\n\t\trow_high_limit_last = row_high_limit;\n\t}\n}\n\nstatic int r82600_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tu8 dramcr;\n\tu32 eapr;\n\tu32 scrub_disabled;\n\tu32 sdram_refresh_rate;\n\tstruct r82600_error_info discard;\n\n\tedac_dbg(0, \"\\n\");\n\tpci_read_config_byte(pdev, R82600_DRAMC, &dramcr);\n\tpci_read_config_dword(pdev, R82600_EAP, &eapr);\n\tscrub_disabled = eapr & BIT(31);\n\tsdram_refresh_rate = dramcr & (BIT(0) | BIT(1));\n\tedac_dbg(2, \"sdram refresh rate = %#0x\\n\", sdram_refresh_rate);\n\tedac_dbg(2, \"DRAMC register = %#0x\\n\", dramcr);\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = R82600_NR_CSROWS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = R82600_NR_CHANS;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(0, \"mci = %p\\n\", mci);\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_RDDR | MEM_FLAG_DDR;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\n\t \n\n\t \n\tmci->edac_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\n\n\tif (ecc_enabled(dramcr)) {\n\t\tif (scrub_disabled)\n\t\t\tedac_dbg(3, \"mci = %p - Scrubbing disabled! EAP: %#0x\\n\",\n\t\t\t\t mci, eapr);\n\t} else\n\t\tmci->edac_cap = EDAC_FLAG_NONE;\n\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = \"R82600\";\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = r82600_check;\n\tmci->ctl_page_to_phys = NULL;\n\tr82600_init_csrows(mci, pdev, dramcr);\n\tr82600_get_error_info(mci, &discard);\t \n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"failed edac_mc_add_mc()\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\n\tif (disable_hardware_scrub) {\n\t\tedac_dbg(3, \"Disabling Hardware Scrub (scrub on error)\\n\");\n\t\tpci_write_bits32(pdev, R82600_EAP, BIT(31), BIT(31));\n\t}\n\n\t \n\tr82600_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!r82600_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\tedac_dbg(3, \"success\\n\");\n\treturn 0;\n\nfail:\n\tedac_mc_free(mci);\n\treturn -ENODEV;\n}\n\n \nstatic int r82600_init_one(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\treturn r82600_probe1(pdev, ent->driver_data);\n}\n\nstatic void r82600_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (r82600_pci)\n\t\tedac_pci_release_generic_ctl(r82600_pci);\n\n\tif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\n\t\treturn;\n\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id r82600_pci_tbl[] = {\n\t{\n\t PCI_DEVICE(PCI_VENDOR_ID_RADISYS, R82600_BRIDGE_ID)\n\t },\n\t{\n\t 0,\n\t }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, r82600_pci_tbl);\n\nstatic struct pci_driver r82600_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = r82600_init_one,\n\t.remove = r82600_remove_one,\n\t.id_table = r82600_pci_tbl,\n};\n\nstatic int __init r82600_init(void)\n{\n        \n       opstate_init();\n\n\treturn pci_register_driver(&r82600_driver);\n}\n\nstatic void __exit r82600_exit(void)\n{\n\tpci_unregister_driver(&r82600_driver);\n}\n\nmodule_init(r82600_init);\nmodule_exit(r82600_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tim Small <tim@buttersideup.com> - WPAD Ltd. on behalf of EADS Astrium\");\nMODULE_DESCRIPTION(\"MC support for Radisys 82600 memory controllers\");\n\nmodule_param(disable_hardware_scrub, bool, 0644);\nMODULE_PARM_DESC(disable_hardware_scrub,\n\t\t \"If set, disable the chipset's automatic scrub for CEs\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}