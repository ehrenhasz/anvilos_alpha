{
  "module_name": "edac_device.c",
  "hash_id": "592efc273ab38969c9e75dba964461db0630879280697d849157718943469ce3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_device.c",
  "human_readable_source": "\n \n\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/ctype.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/timer.h>\n\n#include \"edac_device.h\"\n#include \"edac_module.h\"\n\n \nstatic DEFINE_MUTEX(device_ctls_mutex);\nstatic LIST_HEAD(edac_device_list);\n\n \n#define DEFAULT_POLL_INTERVAL 1000\n\n#ifdef CONFIG_EDAC_DEBUG\nstatic void edac_device_dump_device(struct edac_device_ctl_info *edac_dev)\n{\n\tedac_dbg(3, \"\\tedac_dev = %p dev_idx=%d\\n\",\n\t\t edac_dev, edac_dev->dev_idx);\n\tedac_dbg(4, \"\\tedac_dev->edac_check = %p\\n\", edac_dev->edac_check);\n\tedac_dbg(3, \"\\tdev = %p\\n\", edac_dev->dev);\n\tedac_dbg(3, \"\\tmod_name:ctl_name = %s:%s\\n\",\n\t\t edac_dev->mod_name, edac_dev->ctl_name);\n\tedac_dbg(3, \"\\tpvt_info = %p\\n\\n\", edac_dev->pvt_info);\n}\n#endif\t\t\t\t \n\n \nstruct edac_device_ctl_info *\nedac_device_alloc_ctl_info(unsigned pvt_sz, char *dev_name, unsigned nr_instances,\n\t\t\t   char *blk_name, unsigned nr_blocks, unsigned off_val,\n\t\t\t   struct edac_dev_sysfs_block_attribute *attrib_spec,\n\t\t\t   unsigned nr_attrib, int device_index)\n{\n\tstruct edac_dev_sysfs_block_attribute *dev_attrib, *attrib_p, *attrib;\n\tstruct edac_device_block *dev_blk, *blk_p, *blk;\n\tstruct edac_device_instance *dev_inst, *inst;\n\tstruct edac_device_ctl_info *dev_ctl;\n\tunsigned instance, block, attr;\n\tvoid *pvt;\n\tint err;\n\n\tedac_dbg(4, \"instances=%d blocks=%d\\n\", nr_instances, nr_blocks);\n\n\tdev_ctl = kzalloc(sizeof(struct edac_device_ctl_info), GFP_KERNEL);\n\tif (!dev_ctl)\n\t\treturn NULL;\n\n\tdev_inst = kcalloc(nr_instances, sizeof(struct edac_device_instance), GFP_KERNEL);\n\tif (!dev_inst)\n\t\tgoto free;\n\n\tdev_ctl->instances = dev_inst;\n\n\tdev_blk = kcalloc(nr_instances * nr_blocks, sizeof(struct edac_device_block), GFP_KERNEL);\n\tif (!dev_blk)\n\t\tgoto free;\n\n\tdev_ctl->blocks = dev_blk;\n\n\tif (nr_attrib) {\n\t\tdev_attrib = kcalloc(nr_attrib, sizeof(struct edac_dev_sysfs_block_attribute),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!dev_attrib)\n\t\t\tgoto free;\n\n\t\tdev_ctl->attribs = dev_attrib;\n\t}\n\n\tif (pvt_sz) {\n\t\tpvt = kzalloc(pvt_sz, GFP_KERNEL);\n\t\tif (!pvt)\n\t\t\tgoto free;\n\n\t\tdev_ctl->pvt_info = pvt;\n\t}\n\n\tdev_ctl->dev_idx\t= device_index;\n\tdev_ctl->nr_instances\t= nr_instances;\n\n\t \n\tdev_ctl->log_ce = 1;\n\tdev_ctl->log_ue = 1;\n\n\t \n\tsnprintf(dev_ctl->name, sizeof(dev_ctl->name),\"%s\", dev_name);\n\n\t \n\tfor (instance = 0; instance < nr_instances; instance++) {\n\t\tinst = &dev_inst[instance];\n\t\tinst->ctl = dev_ctl;\n\t\tinst->nr_blocks = nr_blocks;\n\t\tblk_p = &dev_blk[instance * nr_blocks];\n\t\tinst->blocks = blk_p;\n\n\t\t \n\t\tsnprintf(inst->name, sizeof(inst->name), \"%s%u\", dev_name, instance);\n\n\t\t \n\t\tfor (block = 0; block < nr_blocks; block++) {\n\t\t\tblk = &blk_p[block];\n\t\t\tblk->instance = inst;\n\t\t\tsnprintf(blk->name, sizeof(blk->name),\n\t\t\t\t \"%s%d\", blk_name, block + off_val);\n\n\t\t\tedac_dbg(4, \"instance=%d inst_p=%p block=#%d block_p=%p name='%s'\\n\",\n\t\t\t\t instance, inst, block, blk, blk->name);\n\n\t\t\t \n\t\t\tif ((nr_attrib == 0) || (attrib_spec == NULL))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tblk->nr_attribs = nr_attrib;\n\t\t\tattrib_p = &dev_attrib[block*nr_instances*nr_attrib];\n\t\t\tblk->block_attributes = attrib_p;\n\n\t\t\tedac_dbg(4, \"THIS BLOCK_ATTRIB=%p\\n\",\n\t\t\t\t blk->block_attributes);\n\n\t\t\t \n\t\t\tfor (attr = 0; attr < nr_attrib; attr++) {\n\t\t\t\tattrib = &attrib_p[attr];\n\n\t\t\t\t \n\t\t\t\tattrib->attr = attrib_spec[attr].attr;\n\t\t\t\tattrib->show = attrib_spec[attr].show;\n\t\t\t\tattrib->store = attrib_spec[attr].store;\n\n\t\t\t\tattrib->block = blk;\t \n\n\t\t\t\tedac_dbg(4, \"alloc-attrib=%p attrib_name='%s' attrib-spec=%p spec-name=%s\\n\",\n\t\t\t\t\t attrib, attrib->attr.name,\n\t\t\t\t\t &attrib_spec[attr],\n\t\t\t\t\t attrib_spec[attr].attr.name\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdev_ctl->op_state = OP_ALLOC;\n\n\t \n\terr = edac_device_register_sysfs_main_kobj(dev_ctl);\n\tif (err)\n\t\tgoto free;\n\n\t \n\n\treturn dev_ctl;\n\nfree:\n\t__edac_device_free_ctl_info(dev_ctl);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(edac_device_alloc_ctl_info);\n\nvoid edac_device_free_ctl_info(struct edac_device_ctl_info *ctl_info)\n{\n\tedac_device_unregister_sysfs_main_kobj(ctl_info);\n}\nEXPORT_SYMBOL_GPL(edac_device_free_ctl_info);\n\n \nstatic struct edac_device_ctl_info *find_edac_device_by_dev(struct device *dev)\n{\n\tstruct edac_device_ctl_info *edac_dev;\n\tstruct list_head *item;\n\n\tedac_dbg(0, \"\\n\");\n\n\tlist_for_each(item, &edac_device_list) {\n\t\tedac_dev = list_entry(item, struct edac_device_ctl_info, link);\n\n\t\tif (edac_dev->dev == dev)\n\t\t\treturn edac_dev;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int add_edac_dev_to_global_list(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct list_head *item, *insert_before;\n\tstruct edac_device_ctl_info *rover;\n\n\tinsert_before = &edac_device_list;\n\n\t \n\trover = find_edac_device_by_dev(edac_dev->dev);\n\tif (unlikely(rover != NULL))\n\t\tgoto fail0;\n\n\t \n\tlist_for_each(item, &edac_device_list) {\n\t\trover = list_entry(item, struct edac_device_ctl_info, link);\n\n\t\tif (rover->dev_idx >= edac_dev->dev_idx) {\n\t\t\tif (unlikely(rover->dev_idx == edac_dev->dev_idx))\n\t\t\t\tgoto fail1;\n\n\t\t\tinsert_before = item;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_add_tail_rcu(&edac_dev->link, insert_before);\n\treturn 0;\n\nfail0:\n\tedac_printk(KERN_WARNING, EDAC_MC,\n\t\t\t\"%s (%s) %s %s already assigned %d\\n\",\n\t\t\tdev_name(rover->dev), edac_dev_name(rover),\n\t\t\trover->mod_name, rover->ctl_name, rover->dev_idx);\n\treturn 1;\n\nfail1:\n\tedac_printk(KERN_WARNING, EDAC_MC,\n\t\t\t\"bug in low-level driver: attempt to assign\\n\"\n\t\t\t\"    duplicate dev_idx %d in %s()\\n\", rover->dev_idx,\n\t\t\t__func__);\n\treturn 1;\n}\n\n \nstatic void del_edac_device_from_global_list(struct edac_device_ctl_info\n\t\t\t\t\t\t*edac_device)\n{\n\tlist_del_rcu(&edac_device->link);\n\n\t \n\tsynchronize_rcu();\n\tINIT_LIST_HEAD(&edac_device->link);\n}\n\n \nstatic void edac_device_workq_function(struct work_struct *work_req)\n{\n\tstruct delayed_work *d_work = to_delayed_work(work_req);\n\tstruct edac_device_ctl_info *edac_dev = to_edac_device_ctl_work(d_work);\n\n\tmutex_lock(&device_ctls_mutex);\n\n\t \n\tif (edac_dev->op_state == OP_OFFLINE) {\n\t\tmutex_unlock(&device_ctls_mutex);\n\t\treturn;\n\t}\n\n\t \n\tif ((edac_dev->op_state == OP_RUNNING_POLL) &&\n\t\t(edac_dev->edac_check != NULL)) {\n\t\t\tedac_dev->edac_check(edac_dev);\n\t}\n\n\tmutex_unlock(&device_ctls_mutex);\n\n\t \n\tif (edac_dev->poll_msec == DEFAULT_POLL_INTERVAL)\n\t\tedac_queue_work(&edac_dev->work, round_jiffies_relative(edac_dev->delay));\n\telse\n\t\tedac_queue_work(&edac_dev->work, edac_dev->delay);\n}\n\n \nstatic void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t    unsigned msec)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tedac_dev->poll_msec = msec;\n\tedac_dev->delay = msecs_to_jiffies(msec);\n\n\tINIT_DELAYED_WORK(&edac_dev->work, edac_device_workq_function);\n\n\t \n\tif (edac_dev->poll_msec == DEFAULT_POLL_INTERVAL)\n\t\tedac_queue_work(&edac_dev->work, round_jiffies_relative(edac_dev->delay));\n\telse\n\t\tedac_queue_work(&edac_dev->work, edac_dev->delay);\n}\n\n \nstatic void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)\n{\n\tif (!edac_dev->edac_check)\n\t\treturn;\n\n\tedac_dev->op_state = OP_OFFLINE;\n\n\tedac_stop_work(&edac_dev->work);\n}\n\n \nvoid edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t    unsigned long msec)\n{\n\tedac_dev->poll_msec = msec;\n\tedac_dev->delay\t    = msecs_to_jiffies(msec);\n\n\t \n\tif (edac_dev->poll_msec == DEFAULT_POLL_INTERVAL)\n\t\tedac_mod_work(&edac_dev->work, round_jiffies_relative(edac_dev->delay));\n\telse\n\t\tedac_mod_work(&edac_dev->work, edac_dev->delay);\n}\n\nint edac_device_alloc_index(void)\n{\n\tstatic atomic_t device_indexes = ATOMIC_INIT(0);\n\n\treturn atomic_inc_return(&device_indexes) - 1;\n}\nEXPORT_SYMBOL_GPL(edac_device_alloc_index);\n\nint edac_device_add_device(struct edac_device_ctl_info *edac_dev)\n{\n\tedac_dbg(0, \"\\n\");\n\n#ifdef CONFIG_EDAC_DEBUG\n\tif (edac_debug_level >= 3)\n\t\tedac_device_dump_device(edac_dev);\n#endif\n\tmutex_lock(&device_ctls_mutex);\n\n\tif (add_edac_dev_to_global_list(edac_dev))\n\t\tgoto fail0;\n\n\t \n\tedac_dev->start_time = jiffies;\n\n\t \n\tif (edac_device_create_sysfs(edac_dev)) {\n\t\tedac_device_printk(edac_dev, KERN_WARNING,\n\t\t\t\t\t\"failed to create sysfs device\\n\");\n\t\tgoto fail1;\n\t}\n\n\t \n\tif (edac_dev->edac_check != NULL) {\n\t\t \n\t\tedac_dev->op_state = OP_RUNNING_POLL;\n\n\t\tedac_device_workq_setup(edac_dev, edac_dev->poll_msec ?: DEFAULT_POLL_INTERVAL);\n\t} else {\n\t\tedac_dev->op_state = OP_RUNNING_INTERRUPT;\n\t}\n\n\t \n\tedac_device_printk(edac_dev, KERN_INFO,\n\t\t\"Giving out device to module %s controller %s: DEV %s (%s)\\n\",\n\t\tedac_dev->mod_name, edac_dev->ctl_name, edac_dev->dev_name,\n\t\tedac_op_state_to_string(edac_dev->op_state));\n\n\tmutex_unlock(&device_ctls_mutex);\n\treturn 0;\n\nfail1:\n\t \n\tdel_edac_device_from_global_list(edac_dev);\n\nfail0:\n\tmutex_unlock(&device_ctls_mutex);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(edac_device_add_device);\n\nstruct edac_device_ctl_info *edac_device_del_device(struct device *dev)\n{\n\tstruct edac_device_ctl_info *edac_dev;\n\n\tedac_dbg(0, \"\\n\");\n\n\tmutex_lock(&device_ctls_mutex);\n\n\t \n\tedac_dev = find_edac_device_by_dev(dev);\n\tif (edac_dev == NULL) {\n\t\tmutex_unlock(&device_ctls_mutex);\n\t\treturn NULL;\n\t}\n\n\t \n\tedac_dev->op_state = OP_OFFLINE;\n\n\t \n\tdel_edac_device_from_global_list(edac_dev);\n\n\tmutex_unlock(&device_ctls_mutex);\n\n\t \n\tedac_device_workq_teardown(edac_dev);\n\n\t \n\tedac_device_remove_sysfs(edac_dev);\n\n\tedac_printk(KERN_INFO, EDAC_MC,\n\t\t\"Removed device %d for %s %s: DEV %s\\n\",\n\t\tedac_dev->dev_idx,\n\t\tedac_dev->mod_name, edac_dev->ctl_name, edac_dev_name(edac_dev));\n\n\treturn edac_dev;\n}\nEXPORT_SYMBOL_GPL(edac_device_del_device);\n\nstatic inline int edac_device_get_log_ce(struct edac_device_ctl_info *edac_dev)\n{\n\treturn edac_dev->log_ce;\n}\n\nstatic inline int edac_device_get_log_ue(struct edac_device_ctl_info *edac_dev)\n{\n\treturn edac_dev->log_ue;\n}\n\nstatic inline int edac_device_get_panic_on_ue(struct edac_device_ctl_info\n\t\t\t\t\t*edac_dev)\n{\n\treturn edac_dev->panic_on_ue;\n}\n\nvoid edac_device_handle_ce_count(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t unsigned int count, int inst_nr, int block_nr,\n\t\t\t\t const char *msg)\n{\n\tstruct edac_device_instance *instance;\n\tstruct edac_device_block *block = NULL;\n\n\tif (!count)\n\t\treturn;\n\n\tif ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {\n\t\tedac_device_printk(edac_dev, KERN_ERR,\n\t\t\t\t\"INTERNAL ERROR: 'instance' out of range \"\n\t\t\t\t\"(%d >= %d)\\n\", inst_nr,\n\t\t\t\tedac_dev->nr_instances);\n\t\treturn;\n\t}\n\n\tinstance = edac_dev->instances + inst_nr;\n\n\tif ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {\n\t\tedac_device_printk(edac_dev, KERN_ERR,\n\t\t\t\t\"INTERNAL ERROR: instance %d 'block' \"\n\t\t\t\t\"out of range (%d >= %d)\\n\",\n\t\t\t\tinst_nr, block_nr,\n\t\t\t\tinstance->nr_blocks);\n\t\treturn;\n\t}\n\n\tif (instance->nr_blocks > 0) {\n\t\tblock = instance->blocks + block_nr;\n\t\tblock->counters.ce_count += count;\n\t}\n\n\t \n\tinstance->counters.ce_count += count;\n\tedac_dev->counters.ce_count += count;\n\n\tif (edac_device_get_log_ce(edac_dev))\n\t\tedac_device_printk(edac_dev, KERN_WARNING,\n\t\t\t\t   \"CE: %s instance: %s block: %s count: %d '%s'\\n\",\n\t\t\t\t   edac_dev->ctl_name, instance->name,\n\t\t\t\t   block ? block->name : \"N/A\", count, msg);\n}\nEXPORT_SYMBOL_GPL(edac_device_handle_ce_count);\n\nvoid edac_device_handle_ue_count(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t unsigned int count, int inst_nr, int block_nr,\n\t\t\t\t const char *msg)\n{\n\tstruct edac_device_instance *instance;\n\tstruct edac_device_block *block = NULL;\n\n\tif (!count)\n\t\treturn;\n\n\tif ((inst_nr >= edac_dev->nr_instances) || (inst_nr < 0)) {\n\t\tedac_device_printk(edac_dev, KERN_ERR,\n\t\t\t\t\"INTERNAL ERROR: 'instance' out of range \"\n\t\t\t\t\"(%d >= %d)\\n\", inst_nr,\n\t\t\t\tedac_dev->nr_instances);\n\t\treturn;\n\t}\n\n\tinstance = edac_dev->instances + inst_nr;\n\n\tif ((block_nr >= instance->nr_blocks) || (block_nr < 0)) {\n\t\tedac_device_printk(edac_dev, KERN_ERR,\n\t\t\t\t\"INTERNAL ERROR: instance %d 'block' \"\n\t\t\t\t\"out of range (%d >= %d)\\n\",\n\t\t\t\tinst_nr, block_nr,\n\t\t\t\tinstance->nr_blocks);\n\t\treturn;\n\t}\n\n\tif (instance->nr_blocks > 0) {\n\t\tblock = instance->blocks + block_nr;\n\t\tblock->counters.ue_count += count;\n\t}\n\n\t \n\tinstance->counters.ue_count += count;\n\tedac_dev->counters.ue_count += count;\n\n\tif (edac_device_get_log_ue(edac_dev))\n\t\tedac_device_printk(edac_dev, KERN_EMERG,\n\t\t\t\t   \"UE: %s instance: %s block: %s count: %d '%s'\\n\",\n\t\t\t\t   edac_dev->ctl_name, instance->name,\n\t\t\t\t   block ? block->name : \"N/A\", count, msg);\n\n\tif (edac_device_get_panic_on_ue(edac_dev))\n\t\tpanic(\"EDAC %s: UE instance: %s block %s count: %d '%s'\\n\",\n\t\t      edac_dev->ctl_name, instance->name,\n\t\t      block ? block->name : \"N/A\", count, msg);\n}\nEXPORT_SYMBOL_GPL(edac_device_handle_ue_count);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}