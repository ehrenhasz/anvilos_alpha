{
  "module_name": "pnd2_edac.c",
  "hash_id": "a5c432efc78ddc2537d8a90b6da43bfc1f28bdfac1d610b835962f175d2ecd8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/pnd2_edac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/edac.h>\n#include <linux/mmzone.h>\n#include <linux/smp.h>\n#include <linux/bitmap.h>\n#include <linux/math64.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_data/x86/p2sb.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/processor.h>\n#include <asm/mce.h>\n\n#include \"edac_mc.h\"\n#include \"edac_module.h\"\n#include \"pnd2_edac.h\"\n\n#define EDAC_MOD_STR\t\t\"pnd2_edac\"\n\n#define APL_NUM_CHANNELS\t4\n#define DNV_NUM_CHANNELS\t2\n#define DNV_MAX_DIMMS\t\t2  \n\nenum type {\n\tAPL,\n\tDNV,  \n};\n\nstruct dram_addr {\n\tint chan;\n\tint dimm;\n\tint rank;\n\tint bank;\n\tint row;\n\tint col;\n};\n\nstruct pnd2_pvt {\n\tint dimm_geom[APL_NUM_CHANNELS];\n\tu64 tolm, tohm;\n};\n\n \nstatic struct region {\n\tu64\tbase;\n\tu64\tlimit;\n\tu8\tenabled;\n} mot, as0, as1, as2;\n\nstatic struct dunit_ops {\n\tchar *name;\n\tenum type type;\n\tint pmiaddr_shift;\n\tint pmiidx_shift;\n\tint channels;\n\tint dimms_per_channel;\n\tint (*rd_reg)(int port, int off, int op, void *data, size_t sz, char *name);\n\tint (*get_registers)(void);\n\tint (*check_ecc)(void);\n\tvoid (*mk_region)(char *name, struct region *rp, void *asym);\n\tvoid (*get_dimm_config)(struct mem_ctl_info *mci);\n\tint (*pmi2mem)(struct mem_ctl_info *mci, u64 pmiaddr, u32 pmiidx,\n\t\t\t\t   struct dram_addr *daddr, char *msg);\n} *ops;\n\nstatic struct mem_ctl_info *pnd2_mci;\n\n#define PND2_MSG_SIZE\t256\n\n \n#define pnd2_printk(level, fmt, arg...)\t\t\t\\\n\tedac_printk(level, \"pnd2\", fmt, ##arg)\n\n#define pnd2_mc_printk(mci, level, fmt, arg...)\t\\\n\tedac_mc_chipset_printk(mci, level, \"pnd2\", fmt, ##arg)\n\n#define MOT_CHAN_INTLV_BIT_1SLC_2CH 12\n#define MOT_CHAN_INTLV_BIT_2SLC_2CH 13\n#define SELECTOR_DISABLED (-1)\n#define _4GB (1ul << 32)\n\n#define PMI_ADDRESS_WIDTH\t31\n#define PND_MAX_PHYS_BIT\t39\n\n#define APL_ASYMSHIFT\t\t28\n#define DNV_ASYMSHIFT\t\t31\n#define CH_HASH_MASK_LSB\t6\n#define SLICE_HASH_MASK_LSB\t6\n#define MOT_SLC_INTLV_BIT\t12\n#define LOG2_PMI_ADDR_GRANULARITY\t5\n#define MOT_SHIFT\t24\n\n#define GET_BITFIELD(v, lo, hi)\t(((v) & GENMASK_ULL(hi, lo)) >> (lo))\n#define U64_LSHIFT(val, s)\t((u64)(val) << (s))\n\n \nstatic struct pci_bus\t*p2sb_bus;\n#define P2SB_DEVFN\tPCI_DEVFN(0xd, 0)\n#define P2SB_ADDR_OFF\t0xd0\n#define P2SB_DATA_OFF\t0xd4\n#define P2SB_STAT_OFF\t0xd8\n#define P2SB_ROUT_OFF\t0xda\n#define P2SB_EADD_OFF\t0xdc\n#define P2SB_HIDE_OFF\t0xe1\n\n#define P2SB_BUSY\t1\n\n#define P2SB_READ(size, off, ptr) \\\n\tpci_bus_read_config_##size(p2sb_bus, P2SB_DEVFN, off, ptr)\n#define P2SB_WRITE(size, off, val) \\\n\tpci_bus_write_config_##size(p2sb_bus, P2SB_DEVFN, off, val)\n\nstatic bool p2sb_is_busy(u16 *status)\n{\n\tP2SB_READ(word, P2SB_STAT_OFF, status);\n\n\treturn !!(*status & P2SB_BUSY);\n}\n\nstatic int _apl_rd_reg(int port, int off, int op, u32 *data)\n{\n\tint retries = 0xff, ret;\n\tu16 status;\n\tu8 hidden;\n\n\t \n\tP2SB_READ(byte, P2SB_HIDE_OFF, &hidden);\n\tif (hidden)\n\t\tP2SB_WRITE(byte, P2SB_HIDE_OFF, 0);\n\n\tif (p2sb_is_busy(&status)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tP2SB_WRITE(dword, P2SB_ADDR_OFF, (port << 24) | off);\n\tP2SB_WRITE(dword, P2SB_DATA_OFF, 0);\n\tP2SB_WRITE(dword, P2SB_EADD_OFF, 0);\n\tP2SB_WRITE(word, P2SB_ROUT_OFF, 0);\n\tP2SB_WRITE(word, P2SB_STAT_OFF, (op << 8) | P2SB_BUSY);\n\n\twhile (p2sb_is_busy(&status)) {\n\t\tif (retries-- == 0) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tP2SB_READ(dword, P2SB_DATA_OFF, data);\n\tret = (status >> 1) & 0x3;\nout:\n\t \n\tif (hidden)\n\t\tP2SB_WRITE(byte, P2SB_HIDE_OFF, hidden);\n\n\treturn ret;\n}\n\nstatic int apl_rd_reg(int port, int off, int op, void *data, size_t sz, char *name)\n{\n\tint ret = 0;\n\n\tedac_dbg(2, \"Read %s port=%x off=%x op=%x\\n\", name, port, off, op);\n\tswitch (sz) {\n\tcase 8:\n\t\tret = _apl_rd_reg(port, off + 4, op, (u32 *)(data + 4));\n\t\tfallthrough;\n\tcase 4:\n\t\tret |= _apl_rd_reg(port, off, op, (u32 *)data);\n\t\tpnd2_printk(KERN_DEBUG, \"%s=%x%08x ret=%d\\n\", name,\n\t\t\t\t\tsz == 8 ? *((u32 *)(data + 4)) : 0, *((u32 *)data), ret);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u64 get_mem_ctrl_hub_base_addr(void)\n{\n\tstruct b_cr_mchbar_lo_pci lo;\n\tstruct b_cr_mchbar_hi_pci hi;\n\tstruct pci_dev *pdev;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x1980, NULL);\n\tif (pdev) {\n\t\tpci_read_config_dword(pdev, 0x48, (u32 *)&lo);\n\t\tpci_read_config_dword(pdev, 0x4c, (u32 *)&hi);\n\t\tpci_dev_put(pdev);\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (!lo.enable) {\n\t\tedac_dbg(2, \"MMIO via memory controller hub base address is disabled!\\n\");\n\t\treturn 0;\n\t}\n\n\treturn U64_LSHIFT(hi.base, 32) | U64_LSHIFT(lo.base, 15);\n}\n\n#define DNV_MCHBAR_SIZE  0x8000\n#define DNV_SB_PORT_SIZE 0x10000\nstatic int dnv_rd_reg(int port, int off, int op, void *data, size_t sz, char *name)\n{\n\tstruct pci_dev *pdev;\n\tvoid __iomem *base;\n\tstruct resource r;\n\tint ret;\n\n\tif (op == 4) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, 0x1980, NULL);\n\t\tif (!pdev)\n\t\t\treturn -ENODEV;\n\n\t\tpci_read_config_dword(pdev, off, data);\n\t\tpci_dev_put(pdev);\n\t} else {\n\t\t \n\t\tif (op == 0 && port == 0x4c) {\n\t\t\tmemset(&r, 0, sizeof(r));\n\n\t\t\tr.start = get_mem_ctrl_hub_base_addr();\n\t\t\tif (!r.start)\n\t\t\t\treturn -ENODEV;\n\t\t\tr.end = r.start + DNV_MCHBAR_SIZE - 1;\n\t\t} else {\n\t\t\t \n\t\t\tret = p2sb_bar(NULL, 0, &r);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tr.start += (port << 16);\n\t\t\tr.end = r.start + DNV_SB_PORT_SIZE - 1;\n\t\t}\n\n\t\tbase = ioremap(r.start, resource_size(&r));\n\t\tif (!base)\n\t\t\treturn -ENODEV;\n\n\t\tif (sz == 8)\n\t\t\t*(u64 *)data = readq(base + off);\n\t\telse\n\t\t\t*(u32 *)data = readl(base + off);\n\n\t\tiounmap(base);\n\t}\n\n\tedac_dbg(2, \"Read %s=%.8x_%.8x\\n\", name,\n\t\t\t(sz == 8) ? *(u32 *)(data + 4) : 0, *(u32 *)data);\n\n\treturn 0;\n}\n\n#define RD_REGP(regp, regname, port)\t\\\n\tops->rd_reg(port,\t\t\t\t\t\\\n\t\tregname##_offset,\t\t\t\t\\\n\t\tregname##_r_opcode,\t\t\t\t\\\n\t\tregp, sizeof(struct regname),\t\\\n\t\t#regname)\n\n#define RD_REG(regp, regname)\t\t\t\\\n\tops->rd_reg(regname ## _port,\t\t\\\n\t\tregname##_offset,\t\t\t\t\\\n\t\tregname##_r_opcode,\t\t\t\t\\\n\t\tregp, sizeof(struct regname),\t\\\n\t\t#regname)\n\nstatic u64 top_lm, top_hm;\nstatic bool two_slices;\nstatic bool two_channels;  \n\nstatic u8 sym_chan_mask;\nstatic u8 asym_chan_mask;\nstatic u8 chan_mask;\n\nstatic int slice_selector = -1;\nstatic int chan_selector = -1;\nstatic u64 slice_hash_mask;\nstatic u64 chan_hash_mask;\n\nstatic void mk_region(char *name, struct region *rp, u64 base, u64 limit)\n{\n\trp->enabled = 1;\n\trp->base = base;\n\trp->limit = limit;\n\tedac_dbg(2, \"Region:%s [%llx, %llx]\\n\", name, base, limit);\n}\n\nstatic void mk_region_mask(char *name, struct region *rp, u64 base, u64 mask)\n{\n\tif (mask == 0) {\n\t\tpr_info(FW_BUG \"MOT mask cannot be zero\\n\");\n\t\treturn;\n\t}\n\tif (mask != GENMASK_ULL(PND_MAX_PHYS_BIT, __ffs(mask))) {\n\t\tpr_info(FW_BUG \"MOT mask not power of two\\n\");\n\t\treturn;\n\t}\n\tif (base & ~mask) {\n\t\tpr_info(FW_BUG \"MOT region base/mask alignment error\\n\");\n\t\treturn;\n\t}\n\trp->base = base;\n\trp->limit = (base | ~mask) & GENMASK_ULL(PND_MAX_PHYS_BIT, 0);\n\trp->enabled = 1;\n\tedac_dbg(2, \"Region:%s [%llx, %llx]\\n\", name, base, rp->limit);\n}\n\nstatic bool in_region(struct region *rp, u64 addr)\n{\n\tif (!rp->enabled)\n\t\treturn false;\n\n\treturn rp->base <= addr && addr <= rp->limit;\n}\n\nstatic int gen_sym_mask(struct b_cr_slice_channel_hash *p)\n{\n\tint mask = 0;\n\n\tif (!p->slice_0_mem_disabled)\n\t\tmask |= p->sym_slice0_channel_enabled;\n\n\tif (!p->slice_1_disabled)\n\t\tmask |= p->sym_slice1_channel_enabled << 2;\n\n\tif (p->ch_1_disabled || p->enable_pmi_dual_data_mode)\n\t\tmask &= 0x5;\n\n\treturn mask;\n}\n\nstatic int gen_asym_mask(struct b_cr_slice_channel_hash *p,\n\t\t\t struct b_cr_asym_mem_region0_mchbar *as0,\n\t\t\t struct b_cr_asym_mem_region1_mchbar *as1,\n\t\t\t struct b_cr_asym_2way_mem_region_mchbar *as2way)\n{\n\tconst int intlv[] = { 0x5, 0xA, 0x3, 0xC };\n\tint mask = 0;\n\n\tif (as2way->asym_2way_interleave_enable)\n\t\tmask = intlv[as2way->asym_2way_intlv_mode];\n\tif (as0->slice0_asym_enable)\n\t\tmask |= (1 << as0->slice0_asym_channel_select);\n\tif (as1->slice1_asym_enable)\n\t\tmask |= (4 << as1->slice1_asym_channel_select);\n\tif (p->slice_0_mem_disabled)\n\t\tmask &= 0xc;\n\tif (p->slice_1_disabled)\n\t\tmask &= 0x3;\n\tif (p->ch_1_disabled || p->enable_pmi_dual_data_mode)\n\t\tmask &= 0x5;\n\n\treturn mask;\n}\n\nstatic struct b_cr_tolud_pci tolud;\nstatic struct b_cr_touud_lo_pci touud_lo;\nstatic struct b_cr_touud_hi_pci touud_hi;\nstatic struct b_cr_asym_mem_region0_mchbar asym0;\nstatic struct b_cr_asym_mem_region1_mchbar asym1;\nstatic struct b_cr_asym_2way_mem_region_mchbar asym_2way;\nstatic struct b_cr_mot_out_base_mchbar mot_base;\nstatic struct b_cr_mot_out_mask_mchbar mot_mask;\nstatic struct b_cr_slice_channel_hash chash;\n\n \n \nstatic const int apl_dports[APL_NUM_CHANNELS] = { 0x18, 0x10, 0x11, 0x19 };\nstatic struct d_cr_drp0 drp0[APL_NUM_CHANNELS];\n\n \nstatic const int dnv_dports[DNV_NUM_CHANNELS] = { 0x10, 0x12 };\nstatic struct d_cr_dsch dsch;\nstatic struct d_cr_ecc_ctrl ecc_ctrl[DNV_NUM_CHANNELS];\nstatic struct d_cr_drp drp[DNV_NUM_CHANNELS];\nstatic struct d_cr_dmap dmap[DNV_NUM_CHANNELS];\nstatic struct d_cr_dmap1 dmap1[DNV_NUM_CHANNELS];\nstatic struct d_cr_dmap2 dmap2[DNV_NUM_CHANNELS];\nstatic struct d_cr_dmap3 dmap3[DNV_NUM_CHANNELS];\nstatic struct d_cr_dmap4 dmap4[DNV_NUM_CHANNELS];\nstatic struct d_cr_dmap5 dmap5[DNV_NUM_CHANNELS];\n\nstatic void apl_mk_region(char *name, struct region *rp, void *asym)\n{\n\tstruct b_cr_asym_mem_region0_mchbar *a = asym;\n\n\tmk_region(name, rp,\n\t\t\t  U64_LSHIFT(a->slice0_asym_base, APL_ASYMSHIFT),\n\t\t\t  U64_LSHIFT(a->slice0_asym_limit, APL_ASYMSHIFT) +\n\t\t\t  GENMASK_ULL(APL_ASYMSHIFT - 1, 0));\n}\n\nstatic void dnv_mk_region(char *name, struct region *rp, void *asym)\n{\n\tstruct b_cr_asym_mem_region_denverton *a = asym;\n\n\tmk_region(name, rp,\n\t\t\t  U64_LSHIFT(a->slice_asym_base, DNV_ASYMSHIFT),\n\t\t\t  U64_LSHIFT(a->slice_asym_limit, DNV_ASYMSHIFT) +\n\t\t\t  GENMASK_ULL(DNV_ASYMSHIFT - 1, 0));\n}\n\nstatic int apl_get_registers(void)\n{\n\tint ret = -ENODEV;\n\tint i;\n\n\tif (RD_REG(&asym_2way, b_cr_asym_2way_mem_region_mchbar))\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0; i < APL_NUM_CHANNELS; i++)\n\t\tif (!RD_REGP(&drp0[i], d_cr_drp0, apl_dports[i]))\n\t\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int dnv_get_registers(void)\n{\n\tint i;\n\n\tif (RD_REG(&dsch, d_cr_dsch))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < DNV_NUM_CHANNELS; i++)\n\t\tif (RD_REGP(&ecc_ctrl[i], d_cr_ecc_ctrl, dnv_dports[i]) ||\n\t\t\tRD_REGP(&drp[i], d_cr_drp, dnv_dports[i]) ||\n\t\t\tRD_REGP(&dmap[i], d_cr_dmap, dnv_dports[i]) ||\n\t\t\tRD_REGP(&dmap1[i], d_cr_dmap1, dnv_dports[i]) ||\n\t\t\tRD_REGP(&dmap2[i], d_cr_dmap2, dnv_dports[i]) ||\n\t\t\tRD_REGP(&dmap3[i], d_cr_dmap3, dnv_dports[i]) ||\n\t\t\tRD_REGP(&dmap4[i], d_cr_dmap4, dnv_dports[i]) ||\n\t\t\tRD_REGP(&dmap5[i], d_cr_dmap5, dnv_dports[i]))\n\t\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic int get_registers(void)\n{\n\tconst int intlv[] = { 10, 11, 12, 12 };\n\n\tif (RD_REG(&tolud, b_cr_tolud_pci) ||\n\t\tRD_REG(&touud_lo, b_cr_touud_lo_pci) ||\n\t\tRD_REG(&touud_hi, b_cr_touud_hi_pci) ||\n\t\tRD_REG(&asym0, b_cr_asym_mem_region0_mchbar) ||\n\t\tRD_REG(&asym1, b_cr_asym_mem_region1_mchbar) ||\n\t\tRD_REG(&mot_base, b_cr_mot_out_base_mchbar) ||\n\t\tRD_REG(&mot_mask, b_cr_mot_out_mask_mchbar) ||\n\t\tRD_REG(&chash, b_cr_slice_channel_hash))\n\t\treturn -ENODEV;\n\n\tif (ops->get_registers())\n\t\treturn -ENODEV;\n\n\tif (ops->type == DNV) {\n\t\t \n\t\tasym0.slice0_asym_channel_select = 0;\n\t\tasym1.slice1_asym_channel_select = 0;\n\t\t \n\t\tchash.sym_slice0_channel_enabled = 0x1;\n\t\tchash.sym_slice1_channel_enabled = 0x1;\n\t}\n\n\tif (asym0.slice0_asym_enable)\n\t\tops->mk_region(\"as0\", &as0, &asym0);\n\n\tif (asym1.slice1_asym_enable)\n\t\tops->mk_region(\"as1\", &as1, &asym1);\n\n\tif (asym_2way.asym_2way_interleave_enable) {\n\t\tmk_region(\"as2way\", &as2,\n\t\t\t\t  U64_LSHIFT(asym_2way.asym_2way_base, APL_ASYMSHIFT),\n\t\t\t\t  U64_LSHIFT(asym_2way.asym_2way_limit, APL_ASYMSHIFT) +\n\t\t\t\t  GENMASK_ULL(APL_ASYMSHIFT - 1, 0));\n\t}\n\n\tif (mot_base.imr_en) {\n\t\tmk_region_mask(\"mot\", &mot,\n\t\t\t\t\t   U64_LSHIFT(mot_base.mot_out_base, MOT_SHIFT),\n\t\t\t\t\t   U64_LSHIFT(mot_mask.mot_out_mask, MOT_SHIFT));\n\t}\n\n\ttop_lm = U64_LSHIFT(tolud.tolud, 20);\n\ttop_hm = U64_LSHIFT(touud_hi.touud, 32) | U64_LSHIFT(touud_lo.touud, 20);\n\n\ttwo_slices = !chash.slice_1_disabled &&\n\t\t\t\t !chash.slice_0_mem_disabled &&\n\t\t\t\t (chash.sym_slice0_channel_enabled != 0) &&\n\t\t\t\t (chash.sym_slice1_channel_enabled != 0);\n\ttwo_channels = !chash.ch_1_disabled &&\n\t\t\t\t !chash.enable_pmi_dual_data_mode &&\n\t\t\t\t ((chash.sym_slice0_channel_enabled == 3) ||\n\t\t\t\t (chash.sym_slice1_channel_enabled == 3));\n\n\tsym_chan_mask = gen_sym_mask(&chash);\n\tasym_chan_mask = gen_asym_mask(&chash, &asym0, &asym1, &asym_2way);\n\tchan_mask = sym_chan_mask | asym_chan_mask;\n\n\tif (two_slices && !two_channels) {\n\t\tif (chash.hvm_mode)\n\t\t\tslice_selector = 29;\n\t\telse\n\t\t\tslice_selector = intlv[chash.interleave_mode];\n\t} else if (!two_slices && two_channels) {\n\t\tif (chash.hvm_mode)\n\t\t\tchan_selector = 29;\n\t\telse\n\t\t\tchan_selector = intlv[chash.interleave_mode];\n\t} else if (two_slices && two_channels) {\n\t\tif (chash.hvm_mode) {\n\t\t\tslice_selector = 29;\n\t\t\tchan_selector = 30;\n\t\t} else {\n\t\t\tslice_selector = intlv[chash.interleave_mode];\n\t\t\tchan_selector = intlv[chash.interleave_mode] + 1;\n\t\t}\n\t}\n\n\tif (two_slices) {\n\t\tif (!chash.hvm_mode)\n\t\t\tslice_hash_mask = chash.slice_hash_mask << SLICE_HASH_MASK_LSB;\n\t\tif (!two_channels)\n\t\t\tslice_hash_mask |= BIT_ULL(slice_selector);\n\t}\n\n\tif (two_channels) {\n\t\tif (!chash.hvm_mode)\n\t\t\tchan_hash_mask = chash.ch_hash_mask << CH_HASH_MASK_LSB;\n\t\tif (!two_slices)\n\t\t\tchan_hash_mask |= BIT_ULL(chan_selector);\n\t}\n\n\treturn 0;\n}\n\n \nstatic u64 remove_mmio_gap(u64 sys)\n{\n\treturn (sys < _4GB) ? sys : sys - (_4GB - top_lm);\n}\n\n \nstatic void remove_addr_bit(u64 *addr, int bitidx)\n{\n\tu64\tmask;\n\n\tif (bitidx == -1)\n\t\treturn;\n\n\tmask = (1ull << bitidx) - 1;\n\t*addr = ((*addr >> 1) & ~mask) | (*addr & mask);\n}\n\n \nstatic int hash_by_mask(u64 addr, u64 mask)\n{\n\tu64 result = addr & mask;\n\n\tresult = (result >> 32) ^ result;\n\tresult = (result >> 16) ^ result;\n\tresult = (result >> 8) ^ result;\n\tresult = (result >> 4) ^ result;\n\tresult = (result >> 2) ^ result;\n\tresult = (result >> 1) ^ result;\n\n\treturn (int)result & 1;\n}\n\n \nstatic int sys2pmi(const u64 addr, u32 *pmiidx, u64 *pmiaddr, char *msg)\n{\n\tu64 contig_addr, contig_base, contig_offset, contig_base_adj;\n\tint mot_intlv_bit = two_slices ? MOT_CHAN_INTLV_BIT_2SLC_2CH :\n\t\t\t\t\t\tMOT_CHAN_INTLV_BIT_1SLC_2CH;\n\tint slice_intlv_bit_rm = SELECTOR_DISABLED;\n\tint chan_intlv_bit_rm = SELECTOR_DISABLED;\n\t \n\tbool mot_hit = in_region(&mot, addr);\n\t \n\tint sym_channels = hweight8(sym_chan_mask);\n\n\t \n\tint sym_chan_shift = sym_channels >> 1;\n\n\t \n\tif (addr >= (1ul << PND_MAX_PHYS_BIT) ||\n\t   (addr >= top_lm && addr < _4GB) || addr >= top_hm) {\n\t\tsnprintf(msg, PND2_MSG_SIZE, \"Error address 0x%llx is not DRAM\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcontig_addr = remove_mmio_gap(addr);\n\n\tif (in_region(&as0, addr)) {\n\t\t*pmiidx = asym0.slice0_asym_channel_select;\n\n\t\tcontig_base = remove_mmio_gap(as0.base);\n\t\tcontig_offset = contig_addr - contig_base;\n\t\tcontig_base_adj = (contig_base >> sym_chan_shift) *\n\t\t\t\t\t\t  ((chash.sym_slice0_channel_enabled >> (*pmiidx & 1)) & 1);\n\t\tcontig_addr = contig_offset + ((sym_channels > 0) ? contig_base_adj : 0ull);\n\t} else if (in_region(&as1, addr)) {\n\t\t*pmiidx = 2u + asym1.slice1_asym_channel_select;\n\n\t\tcontig_base = remove_mmio_gap(as1.base);\n\t\tcontig_offset = contig_addr - contig_base;\n\t\tcontig_base_adj = (contig_base >> sym_chan_shift) *\n\t\t\t\t\t\t  ((chash.sym_slice1_channel_enabled >> (*pmiidx & 1)) & 1);\n\t\tcontig_addr = contig_offset + ((sym_channels > 0) ? contig_base_adj : 0ull);\n\t} else if (in_region(&as2, addr) && (asym_2way.asym_2way_intlv_mode == 0x3ul)) {\n\t\tbool channel1;\n\n\t\tmot_intlv_bit = MOT_CHAN_INTLV_BIT_1SLC_2CH;\n\t\t*pmiidx = (asym_2way.asym_2way_intlv_mode & 1) << 1;\n\t\tchannel1 = mot_hit ? ((bool)((addr >> mot_intlv_bit) & 1)) :\n\t\t\thash_by_mask(contig_addr, chan_hash_mask);\n\t\t*pmiidx |= (u32)channel1;\n\n\t\tcontig_base = remove_mmio_gap(as2.base);\n\t\tchan_intlv_bit_rm = mot_hit ? mot_intlv_bit : chan_selector;\n\t\tcontig_offset = contig_addr - contig_base;\n\t\tremove_addr_bit(&contig_offset, chan_intlv_bit_rm);\n\t\tcontig_addr = (contig_base >> sym_chan_shift) + contig_offset;\n\t} else {\n\t\t \n\t\t*pmiidx = 0u;\n\n\t\tif (two_slices) {\n\t\t\tbool slice1;\n\n\t\t\tif (mot_hit) {\n\t\t\t\tslice_intlv_bit_rm = MOT_SLC_INTLV_BIT;\n\t\t\t\tslice1 = (addr >> MOT_SLC_INTLV_BIT) & 1;\n\t\t\t} else {\n\t\t\t\tslice_intlv_bit_rm = slice_selector;\n\t\t\t\tslice1 = hash_by_mask(addr, slice_hash_mask);\n\t\t\t}\n\n\t\t\t*pmiidx = (u32)slice1 << 1;\n\t\t}\n\n\t\tif (two_channels) {\n\t\t\tbool channel1;\n\n\t\t\tmot_intlv_bit = two_slices ? MOT_CHAN_INTLV_BIT_2SLC_2CH :\n\t\t\t\t\t\t\tMOT_CHAN_INTLV_BIT_1SLC_2CH;\n\n\t\t\tif (mot_hit) {\n\t\t\t\tchan_intlv_bit_rm = mot_intlv_bit;\n\t\t\t\tchannel1 = (addr >> mot_intlv_bit) & 1;\n\t\t\t} else {\n\t\t\t\tchan_intlv_bit_rm = chan_selector;\n\t\t\t\tchannel1 = hash_by_mask(contig_addr, chan_hash_mask);\n\t\t\t}\n\n\t\t\t*pmiidx |= (u32)channel1;\n\t\t}\n\t}\n\n\t \n\tremove_addr_bit(&contig_addr, chan_intlv_bit_rm);\n\t \n\tremove_addr_bit(&contig_addr, slice_intlv_bit_rm);\n\t*pmiaddr = contig_addr;\n\n\treturn 0;\n}\n\n \n#define C(n) (0x10 | (n))\t \n#define B(n) (0x20 | (n))\t \n#define R(n) (0x40 | (n))\t \n#define RS   (0x80)\t\t\t \n\n \n#define AMAP_1KB\t0\n#define AMAP_2KB\t1\n#define AMAP_4KB\t2\n#define AMAP_RSVD\t3\n\n \n#define DEN_4Gb\t\t0\n#define DEN_8Gb\t\t2\n\n \n#define X8\t\t0\n#define X16\t\t1\n\nstatic struct dimm_geometry {\n\tu8\taddrdec;\n\tu8\tdden;\n\tu8\tdwid;\n\tu8\trowbits, colbits;\n\tu16\tbits[PMI_ADDRESS_WIDTH];\n} dimms[] = {\n\t{\n\t\t.addrdec = AMAP_1KB, .dden = DEN_4Gb, .dwid = X16,\n\t\t.rowbits = 15, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  B(0),  B(1),  B(2),  R(0),\n\t\t\tR(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),  R(8),  R(9),\n\t\t\tR(10), C(7),  C(8),  C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\t0,     0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_1KB, .dden = DEN_4Gb, .dwid = X8,\n\t\t.rowbits = 16, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  B(0),  B(1),  B(2),  R(0),\n\t\t\tR(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),  R(8),  R(9),\n\t\t\tR(10), C(7),  C(8),  C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\tR(15), 0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_1KB, .dden = DEN_8Gb, .dwid = X16,\n\t\t.rowbits = 16, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  B(0),  B(1),  B(2),  R(0),\n\t\t\tR(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),  R(8),  R(9),\n\t\t\tR(10), C(7),  C(8),  C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\tR(15), 0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_1KB, .dden = DEN_8Gb, .dwid = X8,\n\t\t.rowbits = 16, .colbits = 11,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  B(0),  B(1),  B(2),  R(0),\n\t\t\tR(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),  R(8),  R(9),\n\t\t\tR(10), C(7),  C(8),  C(9),  R(11), RS,    C(11), R(12), R(13),\n\t\t\tR(14), R(15), 0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_2KB, .dden = DEN_4Gb, .dwid = X16,\n\t\t.rowbits = 15, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  C(7),  B(0),  B(1),  B(2),\n\t\t\tR(0),  R(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),  R(8),\n\t\t\tR(9),  R(10), C(8),  C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\t0,     0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_2KB, .dden = DEN_4Gb, .dwid = X8,\n\t\t.rowbits = 16, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  C(7),  B(0),  B(1),  B(2),\n\t\t\tR(0),  R(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),  R(8),\n\t\t\tR(9),  R(10), C(8),  C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\tR(15), 0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_2KB, .dden = DEN_8Gb, .dwid = X16,\n\t\t.rowbits = 16, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  C(7),  B(0),  B(1),  B(2),\n\t\t\tR(0),  R(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),  R(8),\n\t\t\tR(9),  R(10), C(8),  C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\tR(15), 0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_2KB, .dden = DEN_8Gb, .dwid = X8,\n\t\t.rowbits = 16, .colbits = 11,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  C(7),  B(0),  B(1),  B(2),\n\t\t\tR(0),  R(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),  R(8),\n\t\t\tR(9),  R(10), C(8),  C(9),  R(11), RS,    C(11), R(12), R(13),\n\t\t\tR(14), R(15), 0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_4KB, .dden = DEN_4Gb, .dwid = X16,\n\t\t.rowbits = 15, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  C(7),  C(8),  B(0),  B(1),\n\t\t\tB(2),  R(0),  R(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),\n\t\t\tR(8),  R(9),  R(10), C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\t0,     0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_4KB, .dden = DEN_4Gb, .dwid = X8,\n\t\t.rowbits = 16, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  C(7),  C(8),  B(0),  B(1),\n\t\t\tB(2),  R(0),  R(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),\n\t\t\tR(8),  R(9),  R(10), C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\tR(15), 0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_4KB, .dden = DEN_8Gb, .dwid = X16,\n\t\t.rowbits = 16, .colbits = 10,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  C(7),  C(8),  B(0),  B(1),\n\t\t\tB(2),  R(0),  R(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),\n\t\t\tR(8),  R(9),  R(10), C(9),  R(11), RS,    R(12), R(13), R(14),\n\t\t\tR(15), 0,     0,     0\n\t\t}\n\t},\n\t{\n\t\t.addrdec = AMAP_4KB, .dden = DEN_8Gb, .dwid = X8,\n\t\t.rowbits = 16, .colbits = 11,\n\t\t.bits = {\n\t\t\tC(2),  C(3),  C(4),  C(5),  C(6),  C(7),  C(8),  B(0),  B(1),\n\t\t\tB(2),  R(0),  R(1),  R(2),  R(3),  R(4),  R(5),  R(6),  R(7),\n\t\t\tR(8),  R(9),  R(10), C(9),  R(11), RS,    C(11), R(12), R(13),\n\t\t\tR(14), R(15), 0,     0\n\t\t}\n\t}\n};\n\nstatic int bank_hash(u64 pmiaddr, int idx, int shft)\n{\n\tint bhash = 0;\n\n\tswitch (idx) {\n\tcase 0:\n\t\tbhash ^= ((pmiaddr >> (12 + shft)) ^ (pmiaddr >> (9 + shft))) & 1;\n\t\tbreak;\n\tcase 1:\n\t\tbhash ^= (((pmiaddr >> (10 + shft)) ^ (pmiaddr >> (8 + shft))) & 1) << 1;\n\t\tbhash ^= ((pmiaddr >> 22) & 1) << 1;\n\t\tbreak;\n\tcase 2:\n\t\tbhash ^= (((pmiaddr >> (13 + shft)) ^ (pmiaddr >> (11 + shft))) & 1) << 2;\n\t\tbreak;\n\t}\n\n\treturn bhash;\n}\n\nstatic int rank_hash(u64 pmiaddr)\n{\n\treturn ((pmiaddr >> 16) ^ (pmiaddr >> 10)) & 1;\n}\n\n \nstatic int apl_pmi2mem(struct mem_ctl_info *mci, u64 pmiaddr, u32 pmiidx,\n\t\t       struct dram_addr *daddr, char *msg)\n{\n\tstruct d_cr_drp0 *cr_drp0 = &drp0[pmiidx];\n\tstruct pnd2_pvt *pvt = mci->pvt_info;\n\tint g = pvt->dimm_geom[pmiidx];\n\tstruct dimm_geometry *d = &dimms[g];\n\tint column = 0, bank = 0, row = 0, rank = 0;\n\tint i, idx, type, skiprs = 0;\n\n\tfor (i = 0; i < PMI_ADDRESS_WIDTH; i++) {\n\t\tint\tbit = (pmiaddr >> i) & 1;\n\n\t\tif (i + skiprs >= PMI_ADDRESS_WIDTH) {\n\t\t\tsnprintf(msg, PND2_MSG_SIZE, \"Bad dimm_geometry[] table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttype = d->bits[i + skiprs] & ~0xf;\n\t\tidx = d->bits[i + skiprs] & 0xf;\n\n\t\t \n\t\tif (type == RS && (cr_drp0->rken0 + cr_drp0->rken1) == 1) {\n\t\t\tskiprs = 1;\n\t\t\ttype = d->bits[i + skiprs] & ~0xf;\n\t\t\tidx = d->bits[i + skiprs] & 0xf;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase C(0):\n\t\t\tcolumn |= (bit << idx);\n\t\t\tbreak;\n\t\tcase B(0):\n\t\t\tbank |= (bit << idx);\n\t\t\tif (cr_drp0->bahen)\n\t\t\t\tbank ^= bank_hash(pmiaddr, idx, d->addrdec);\n\t\t\tbreak;\n\t\tcase R(0):\n\t\t\trow |= (bit << idx);\n\t\t\tbreak;\n\t\tcase RS:\n\t\t\trank = bit;\n\t\t\tif (cr_drp0->rsien)\n\t\t\t\trank ^= rank_hash(pmiaddr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bit) {\n\t\t\t\tsnprintf(msg, PND2_MSG_SIZE, \"Bad translation\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tdaddr->col = column;\n\tdaddr->bank = bank;\n\tdaddr->row = row;\n\tdaddr->rank = rank;\n\tdaddr->dimm = 0;\n\n\treturn 0;\n}\n\n \n#define dnv_get_bit(pmi, in, out) ((int)(((pmi) >> (in)) & 1u) << (out))\n\nstatic int dnv_pmi2mem(struct mem_ctl_info *mci, u64 pmiaddr, u32 pmiidx,\n\t\t\t\t\t   struct dram_addr *daddr, char *msg)\n{\n\t \n\tdaddr->rank = dnv_get_bit(pmiaddr, dmap[pmiidx].rs0 + 13, 0);\n\t \n\tdaddr->rank |= dnv_get_bit(pmiaddr, dmap[pmiidx].rs1 + 13, 1);\n\n\t \n\tdaddr->dimm = (daddr->rank >= 2) ^ drp[pmiidx].dimmflip;\n\n\tdaddr->bank = dnv_get_bit(pmiaddr, dmap[pmiidx].ba0 + 6, 0);\n\tdaddr->bank |= dnv_get_bit(pmiaddr, dmap[pmiidx].ba1 + 6, 1);\n\tdaddr->bank |= dnv_get_bit(pmiaddr, dmap[pmiidx].bg0 + 6, 2);\n\tif (dsch.ddr4en)\n\t\tdaddr->bank |= dnv_get_bit(pmiaddr, dmap[pmiidx].bg1 + 6, 3);\n\tif (dmap1[pmiidx].bxor) {\n\t\tif (dsch.ddr4en) {\n\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap3[pmiidx].row6 + 6, 0);\n\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap3[pmiidx].row7 + 6, 1);\n\t\t\tif (dsch.chan_width == 0)\n\t\t\t\t \n\t\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca3 + 6, 2);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca4 + 6, 2);\n\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap2[pmiidx].row2 + 6, 3);\n\t\t} else {\n\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap2[pmiidx].row2 + 6, 0);\n\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap3[pmiidx].row6 + 6, 1);\n\t\t\tif (dsch.chan_width == 0)\n\t\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca3 + 6, 2);\n\t\t\telse\n\t\t\t\tdaddr->bank ^= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca4 + 6, 2);\n\t\t}\n\t}\n\n\tdaddr->row = dnv_get_bit(pmiaddr, dmap2[pmiidx].row0 + 6, 0);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap2[pmiidx].row1 + 6, 1);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap2[pmiidx].row2 + 6, 2);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap2[pmiidx].row3 + 6, 3);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap2[pmiidx].row4 + 6, 4);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap2[pmiidx].row5 + 6, 5);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap3[pmiidx].row6 + 6, 6);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap3[pmiidx].row7 + 6, 7);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap3[pmiidx].row8 + 6, 8);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap3[pmiidx].row9 + 6, 9);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap3[pmiidx].row10 + 6, 10);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap3[pmiidx].row11 + 6, 11);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap4[pmiidx].row12 + 6, 12);\n\tdaddr->row |= dnv_get_bit(pmiaddr, dmap4[pmiidx].row13 + 6, 13);\n\tif (dmap4[pmiidx].row14 != 31)\n\t\tdaddr->row |= dnv_get_bit(pmiaddr, dmap4[pmiidx].row14 + 6, 14);\n\tif (dmap4[pmiidx].row15 != 31)\n\t\tdaddr->row |= dnv_get_bit(pmiaddr, dmap4[pmiidx].row15 + 6, 15);\n\tif (dmap4[pmiidx].row16 != 31)\n\t\tdaddr->row |= dnv_get_bit(pmiaddr, dmap4[pmiidx].row16 + 6, 16);\n\tif (dmap4[pmiidx].row17 != 31)\n\t\tdaddr->row |= dnv_get_bit(pmiaddr, dmap4[pmiidx].row17 + 6, 17);\n\n\tdaddr->col = dnv_get_bit(pmiaddr, dmap5[pmiidx].ca3 + 6, 3);\n\tdaddr->col |= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca4 + 6, 4);\n\tdaddr->col |= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca5 + 6, 5);\n\tdaddr->col |= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca6 + 6, 6);\n\tdaddr->col |= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca7 + 6, 7);\n\tdaddr->col |= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca8 + 6, 8);\n\tdaddr->col |= dnv_get_bit(pmiaddr, dmap5[pmiidx].ca9 + 6, 9);\n\tif (!dsch.ddr4en && dmap1[pmiidx].ca11 != 0x3f)\n\t\tdaddr->col |= dnv_get_bit(pmiaddr, dmap1[pmiidx].ca11 + 13, 11);\n\n\treturn 0;\n}\n\nstatic int check_channel(int ch)\n{\n\tif (drp0[ch].dramtype != 0) {\n\t\tpnd2_printk(KERN_INFO, \"Unsupported DIMM in channel %d\\n\", ch);\n\t\treturn 1;\n\t} else if (drp0[ch].eccen == 0) {\n\t\tpnd2_printk(KERN_INFO, \"ECC disabled on channel %d\\n\", ch);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int apl_check_ecc_active(void)\n{\n\tint\ti, ret = 0;\n\n\t \n\tfor (i = 0; i < APL_NUM_CHANNELS; i++)\n\t\tif (chan_mask & BIT(i))\n\t\t\tret += check_channel(i);\n\treturn ret ? -EINVAL : 0;\n}\n\n#define DIMMS_PRESENT(d) ((d)->rken0 + (d)->rken1 + (d)->rken2 + (d)->rken3)\n\nstatic int check_unit(int ch)\n{\n\tstruct d_cr_drp *d = &drp[ch];\n\n\tif (DIMMS_PRESENT(d) && !ecc_ctrl[ch].eccen) {\n\t\tpnd2_printk(KERN_INFO, \"ECC disabled on channel %d\\n\", ch);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int dnv_check_ecc_active(void)\n{\n\tint\ti, ret = 0;\n\n\tfor (i = 0; i < DNV_NUM_CHANNELS; i++)\n\t\tret += check_unit(i);\n\treturn ret ? -EINVAL : 0;\n}\n\nstatic int get_memory_error_data(struct mem_ctl_info *mci, u64 addr,\n\t\t\t\t\t\t\t\t struct dram_addr *daddr, char *msg)\n{\n\tu64\tpmiaddr;\n\tu32\tpmiidx;\n\tint\tret;\n\n\tret = sys2pmi(addr, &pmiidx, &pmiaddr, msg);\n\tif (ret)\n\t\treturn ret;\n\n\tpmiaddr >>= ops->pmiaddr_shift;\n\t \n\tpmiidx >>= ops->pmiidx_shift;\n\tdaddr->chan = pmiidx;\n\n\tret = ops->pmi2mem(mci, pmiaddr, pmiidx, daddr, msg);\n\tif (ret)\n\t\treturn ret;\n\n\tedac_dbg(0, \"SysAddr=%llx PmiAddr=%llx Channel=%d DIMM=%d Rank=%d Bank=%d Row=%d Column=%d\\n\",\n\t\t\t addr, pmiaddr, daddr->chan, daddr->dimm, daddr->rank, daddr->bank, daddr->row, daddr->col);\n\n\treturn 0;\n}\n\nstatic void pnd2_mce_output_error(struct mem_ctl_info *mci, const struct mce *m,\n\t\t\t\t  struct dram_addr *daddr)\n{\n\tenum hw_event_mc_err_type tp_event;\n\tchar *optype, msg[PND2_MSG_SIZE];\n\tbool ripv = m->mcgstatus & MCG_STATUS_RIPV;\n\tbool overflow = m->status & MCI_STATUS_OVER;\n\tbool uc_err = m->status & MCI_STATUS_UC;\n\tbool recov = m->status & MCI_STATUS_S;\n\tu32 core_err_cnt = GET_BITFIELD(m->status, 38, 52);\n\tu32 mscod = GET_BITFIELD(m->status, 16, 31);\n\tu32 errcode = GET_BITFIELD(m->status, 0, 15);\n\tu32 optypenum = GET_BITFIELD(m->status, 4, 6);\n\tint rc;\n\n\ttp_event = uc_err ? (ripv ? HW_EVENT_ERR_UNCORRECTED : HW_EVENT_ERR_FATAL) :\n\t\t\t\t\t\t HW_EVENT_ERR_CORRECTED;\n\n\t \n\tif (!((errcode & 0xef80) == 0x80)) {\n\t\toptype = \"Can't parse: it is not a mem\";\n\t} else {\n\t\tswitch (optypenum) {\n\t\tcase 0:\n\t\t\toptype = \"generic undef request error\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\toptype = \"memory read error\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\toptype = \"memory write error\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\toptype = \"addr/cmd error\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\toptype = \"memory scrubbing error\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toptype = \"reserved\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!(m->status & MCI_STATUS_ADDRV))\n\t\treturn;\n\n\trc = get_memory_error_data(mci, m->addr, daddr, msg);\n\tif (rc)\n\t\tgoto address_error;\n\n\tsnprintf(msg, sizeof(msg),\n\t\t \"%s%s err_code:%04x:%04x channel:%d DIMM:%d rank:%d row:%d bank:%d col:%d\",\n\t\t overflow ? \" OVERFLOW\" : \"\", (uc_err && recov) ? \" recoverable\" : \"\", mscod,\n\t\t errcode, daddr->chan, daddr->dimm, daddr->rank, daddr->row, daddr->bank, daddr->col);\n\n\tedac_dbg(0, \"%s\\n\", msg);\n\n\t \n\tedac_mc_handle_error(tp_event, mci, core_err_cnt, m->addr >> PAGE_SHIFT,\n\t\t\t\t\t\t m->addr & ~PAGE_MASK, 0, daddr->chan, daddr->dimm, -1, optype, msg);\n\n\treturn;\n\naddress_error:\n\tedac_mc_handle_error(tp_event, mci, core_err_cnt, 0, 0, 0, -1, -1, -1, msg, \"\");\n}\n\nstatic void apl_get_dimm_config(struct mem_ctl_info *mci)\n{\n\tstruct pnd2_pvt\t*pvt = mci->pvt_info;\n\tstruct dimm_info *dimm;\n\tstruct d_cr_drp0 *d;\n\tu64\tcapacity;\n\tint\ti, g;\n\n\tfor (i = 0; i < APL_NUM_CHANNELS; i++) {\n\t\tif (!(chan_mask & BIT(i)))\n\t\t\tcontinue;\n\n\t\tdimm = edac_get_dimm(mci, i, 0, 0);\n\t\tif (!dimm) {\n\t\t\tedac_dbg(0, \"No allocated DIMM for channel %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\td = &drp0[i];\n\t\tfor (g = 0; g < ARRAY_SIZE(dimms); g++)\n\t\t\tif (dimms[g].addrdec == d->addrdec &&\n\t\t\t    dimms[g].dden == d->dden &&\n\t\t\t    dimms[g].dwid == d->dwid)\n\t\t\t\tbreak;\n\n\t\tif (g == ARRAY_SIZE(dimms)) {\n\t\t\tedac_dbg(0, \"Channel %d: unrecognized DIMM\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpvt->dimm_geom[i] = g;\n\t\tcapacity = (d->rken0 + d->rken1) * 8 * (1ul << dimms[g].rowbits) *\n\t\t\t\t   (1ul << dimms[g].colbits);\n\t\tedac_dbg(0, \"Channel %d: %lld MByte DIMM\\n\", i, capacity >> (20 - 3));\n\t\tdimm->nr_pages = MiB_TO_PAGES(capacity >> (20 - 3));\n\t\tdimm->grain = 32;\n\t\tdimm->dtype = (d->dwid == 0) ? DEV_X8 : DEV_X16;\n\t\tdimm->mtype = MEM_DDR3;\n\t\tdimm->edac_mode = EDAC_SECDED;\n\t\tsnprintf(dimm->label, sizeof(dimm->label), \"Slice#%d_Chan#%d\", i / 2, i % 2);\n\t}\n}\n\nstatic const int dnv_dtypes[] = {\n\tDEV_X8, DEV_X4, DEV_X16, DEV_UNKNOWN\n};\n\nstatic void dnv_get_dimm_config(struct mem_ctl_info *mci)\n{\n\tint\ti, j, ranks_of_dimm[DNV_MAX_DIMMS], banks, rowbits, colbits, memtype;\n\tstruct dimm_info *dimm;\n\tstruct d_cr_drp *d;\n\tu64\tcapacity;\n\n\tif (dsch.ddr4en) {\n\t\tmemtype = MEM_DDR4;\n\t\tbanks = 16;\n\t\tcolbits = 10;\n\t} else {\n\t\tmemtype = MEM_DDR3;\n\t\tbanks = 8;\n\t}\n\n\tfor (i = 0; i < DNV_NUM_CHANNELS; i++) {\n\t\tif (dmap4[i].row14 == 31)\n\t\t\trowbits = 14;\n\t\telse if (dmap4[i].row15 == 31)\n\t\t\trowbits = 15;\n\t\telse if (dmap4[i].row16 == 31)\n\t\t\trowbits = 16;\n\t\telse if (dmap4[i].row17 == 31)\n\t\t\trowbits = 17;\n\t\telse\n\t\t\trowbits = 18;\n\n\t\tif (memtype == MEM_DDR3) {\n\t\t\tif (dmap1[i].ca11 != 0x3f)\n\t\t\t\tcolbits = 12;\n\t\t\telse\n\t\t\t\tcolbits = 10;\n\t\t}\n\n\t\td = &drp[i];\n\t\t \n\t\tranks_of_dimm[0] = d->rken0 + d->rken1;\n\t\t \n\t\tranks_of_dimm[1] = d->rken2 + d->rken3;\n\n\t\tfor (j = 0; j < DNV_MAX_DIMMS; j++) {\n\t\t\tif (!ranks_of_dimm[j])\n\t\t\t\tcontinue;\n\n\t\t\tdimm = edac_get_dimm(mci, i, j, 0);\n\t\t\tif (!dimm) {\n\t\t\t\tedac_dbg(0, \"No allocated DIMM for channel %d DIMM %d\\n\", i, j);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcapacity = ranks_of_dimm[j] * banks * (1ul << rowbits) * (1ul << colbits);\n\t\t\tedac_dbg(0, \"Channel %d DIMM %d: %lld MByte DIMM\\n\", i, j, capacity >> (20 - 3));\n\t\t\tdimm->nr_pages = MiB_TO_PAGES(capacity >> (20 - 3));\n\t\t\tdimm->grain = 32;\n\t\t\tdimm->dtype = dnv_dtypes[j ? d->dimmdwid0 : d->dimmdwid1];\n\t\t\tdimm->mtype = memtype;\n\t\t\tdimm->edac_mode = EDAC_SECDED;\n\t\t\tsnprintf(dimm->label, sizeof(dimm->label), \"Chan#%d_DIMM#%d\", i, j);\n\t\t}\n\t}\n}\n\nstatic int pnd2_register_mci(struct mem_ctl_info **ppmci)\n{\n\tstruct edac_mc_layer layers[2];\n\tstruct mem_ctl_info *mci;\n\tstruct pnd2_pvt *pvt;\n\tint rc;\n\n\trc = ops->check_ecc();\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tlayers[0].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[0].size = ops->channels;\n\tlayers[0].is_virt_csrow = false;\n\tlayers[1].type = EDAC_MC_LAYER_SLOT;\n\tlayers[1].size = ops->dimms_per_channel;\n\tlayers[1].is_virt_csrow = true;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tpvt = mci->pvt_info;\n\tmemset(pvt, 0, sizeof(*pvt));\n\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->dev_name = ops->name;\n\tmci->ctl_name = \"Pondicherry2\";\n\n\t \n\tops->get_dimm_config(mci);\n\n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(0, \"MC: failed edac_mc_add_mc()\\n\");\n\t\tedac_mc_free(mci);\n\t\treturn -EINVAL;\n\t}\n\n\t*ppmci = mci;\n\n\treturn 0;\n}\n\nstatic void pnd2_unregister_mci(struct mem_ctl_info *mci)\n{\n\tif (unlikely(!mci || !mci->pvt_info)) {\n\t\tpnd2_printk(KERN_ERR, \"Couldn't find mci handler\\n\");\n\t\treturn;\n\t}\n\n\t \n\tedac_mc_del_mc(NULL);\n\tedac_dbg(1, \"%s: free mci struct\\n\", mci->ctl_name);\n\tedac_mc_free(mci);\n}\n\n \nstatic int pnd2_mce_check_error(struct notifier_block *nb, unsigned long val, void *data)\n{\n\tstruct mce *mce = (struct mce *)data;\n\tstruct mem_ctl_info *mci;\n\tstruct dram_addr daddr;\n\tchar *type;\n\n\tmci = pnd2_mci;\n\tif (!mci || (mce->kflags & MCE_HANDLED_CEC))\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif ((mce->status & 0xefff) >> 7 != 1)\n\t\treturn NOTIFY_DONE;\n\n\tif (mce->mcgstatus & MCG_STATUS_MCIP)\n\t\ttype = \"Exception\";\n\telse\n\t\ttype = \"Event\";\n\n\tpnd2_mc_printk(mci, KERN_INFO, \"HANDLING MCE MEMORY ERROR\\n\");\n\tpnd2_mc_printk(mci, KERN_INFO, \"CPU %u: Machine Check %s: %llx Bank %u: %llx\\n\",\n\t\t\t\t   mce->extcpu, type, mce->mcgstatus, mce->bank, mce->status);\n\tpnd2_mc_printk(mci, KERN_INFO, \"TSC %llx \", mce->tsc);\n\tpnd2_mc_printk(mci, KERN_INFO, \"ADDR %llx \", mce->addr);\n\tpnd2_mc_printk(mci, KERN_INFO, \"MISC %llx \", mce->misc);\n\tpnd2_mc_printk(mci, KERN_INFO, \"PROCESSOR %u:%x TIME %llu SOCKET %u APIC %x\\n\",\n\t\t\t\t   mce->cpuvendor, mce->cpuid, mce->time, mce->socketid, mce->apicid);\n\n\tpnd2_mce_output_error(mci, mce, &daddr);\n\n\t \n\tmce->kflags |= MCE_HANDLED_EDAC;\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block pnd2_mce_dec = {\n\t.notifier_call\t= pnd2_mce_check_error,\n\t.priority\t= MCE_PRIO_EDAC,\n};\n\n#ifdef CONFIG_EDAC_DEBUG\n \nstatic u64 pnd2_fake_addr;\n#define PND2_BLOB_SIZE 1024\nstatic char pnd2_result[PND2_BLOB_SIZE];\nstatic struct dentry *pnd2_test;\nstatic struct debugfs_blob_wrapper pnd2_blob = {\n\t.data = pnd2_result,\n\t.size = 0\n};\n\nstatic int debugfs_u64_set(void *data, u64 val)\n{\n\tstruct dram_addr daddr;\n\tstruct mce m;\n\n\t*(u64 *)data = val;\n\tm.mcgstatus = 0;\n\t \n\tm.status = MCI_STATUS_ADDRV + 0x9f;\n\tm.addr = val;\n\tpnd2_mce_output_error(pnd2_mci, &m, &daddr);\n\tsnprintf(pnd2_blob.data, PND2_BLOB_SIZE,\n\t\t\t \"SysAddr=%llx Channel=%d DIMM=%d Rank=%d Bank=%d Row=%d Column=%d\\n\",\n\t\t\t m.addr, daddr.chan, daddr.dimm, daddr.rank, daddr.bank, daddr.row, daddr.col);\n\tpnd2_blob.size = strlen(pnd2_blob.data);\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(fops_u64_wo, NULL, debugfs_u64_set, \"%llu\\n\");\n\nstatic void setup_pnd2_debug(void)\n{\n\tpnd2_test = edac_debugfs_create_dir(\"pnd2_test\");\n\tedac_debugfs_create_file(\"pnd2_debug_addr\", 0200, pnd2_test,\n\t\t\t\t\t\t\t &pnd2_fake_addr, &fops_u64_wo);\n\tdebugfs_create_blob(\"pnd2_debug_results\", 0400, pnd2_test, &pnd2_blob);\n}\n\nstatic void teardown_pnd2_debug(void)\n{\n\tdebugfs_remove_recursive(pnd2_test);\n}\n#else\nstatic void setup_pnd2_debug(void)\t{}\nstatic void teardown_pnd2_debug(void)\t{}\n#endif  \n\n\nstatic int pnd2_probe(void)\n{\n\tint rc;\n\n\tedac_dbg(2, \"\\n\");\n\trc = get_registers();\n\tif (rc)\n\t\treturn rc;\n\n\treturn pnd2_register_mci(&pnd2_mci);\n}\n\nstatic void pnd2_remove(void)\n{\n\tedac_dbg(0, \"\\n\");\n\tpnd2_unregister_mci(pnd2_mci);\n}\n\nstatic struct dunit_ops apl_ops = {\n\t\t.name\t\t\t= \"pnd2/apl\",\n\t\t.type\t\t\t= APL,\n\t\t.pmiaddr_shift\t\t= LOG2_PMI_ADDR_GRANULARITY,\n\t\t.pmiidx_shift\t\t= 0,\n\t\t.channels\t\t= APL_NUM_CHANNELS,\n\t\t.dimms_per_channel\t= 1,\n\t\t.rd_reg\t\t\t= apl_rd_reg,\n\t\t.get_registers\t\t= apl_get_registers,\n\t\t.check_ecc\t\t= apl_check_ecc_active,\n\t\t.mk_region\t\t= apl_mk_region,\n\t\t.get_dimm_config\t= apl_get_dimm_config,\n\t\t.pmi2mem\t\t= apl_pmi2mem,\n};\n\nstatic struct dunit_ops dnv_ops = {\n\t\t.name\t\t\t= \"pnd2/dnv\",\n\t\t.type\t\t\t= DNV,\n\t\t.pmiaddr_shift\t\t= 0,\n\t\t.pmiidx_shift\t\t= 1,\n\t\t.channels\t\t= DNV_NUM_CHANNELS,\n\t\t.dimms_per_channel\t= 2,\n\t\t.rd_reg\t\t\t= dnv_rd_reg,\n\t\t.get_registers\t\t= dnv_get_registers,\n\t\t.check_ecc\t\t= dnv_check_ecc_active,\n\t\t.mk_region\t\t= dnv_mk_region,\n\t\t.get_dimm_config\t= dnv_get_dimm_config,\n\t\t.pmi2mem\t\t= dnv_pmi2mem,\n};\n\nstatic const struct x86_cpu_id pnd2_cpuids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT,\t&apl_ops),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_D,\t&dnv_ops),\n\t{ }\n};\nMODULE_DEVICE_TABLE(x86cpu, pnd2_cpuids);\n\nstatic int __init pnd2_init(void)\n{\n\tconst struct x86_cpu_id *id;\n\tconst char *owner;\n\tint rc;\n\n\tedac_dbg(2, \"\\n\");\n\n\tif (ghes_get_devices())\n\t\treturn -EBUSY;\n\n\towner = edac_get_owner();\n\tif (owner && strncmp(owner, EDAC_MOD_STR, sizeof(EDAC_MOD_STR)))\n\t\treturn -EBUSY;\n\n\tif (cpu_feature_enabled(X86_FEATURE_HYPERVISOR))\n\t\treturn -ENODEV;\n\n\tid = x86_match_cpu(pnd2_cpuids);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tops = (struct dunit_ops *)id->driver_data;\n\n\tif (ops->type == APL) {\n\t\tp2sb_bus = pci_find_bus(0, 0);\n\t\tif (!p2sb_bus)\n\t\t\treturn -ENODEV;\n\t}\n\n\t \n\topstate_init();\n\n\trc = pnd2_probe();\n\tif (rc < 0) {\n\t\tpnd2_printk(KERN_ERR, \"Failed to register device with error %d.\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (!pnd2_mci)\n\t\treturn -ENODEV;\n\n\tmce_register_decode_chain(&pnd2_mce_dec);\n\tsetup_pnd2_debug();\n\n\treturn 0;\n}\n\nstatic void __exit pnd2_exit(void)\n{\n\tedac_dbg(2, \"\\n\");\n\tteardown_pnd2_debug();\n\tmce_unregister_decode_chain(&pnd2_mce_dec);\n\tpnd2_remove();\n}\n\nmodule_init(pnd2_init);\nmodule_exit(pnd2_exit);\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Tony Luck\");\nMODULE_DESCRIPTION(\"MC Driver for Intel SoC using Pondicherry memory controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}