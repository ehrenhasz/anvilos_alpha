{
  "module_name": "altera_edac.c",
  "hash_id": "6de325ad70c55d6ae2b84132a261e5a0585ea413a5bb9eed6c37d45b8c50c39a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/altera_edac.c",
  "human_readable_source": "\n \n\n#include <asm/cacheflush.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/edac.h>\n#include <linux/firmware/intel/stratix10-smc.h>\n#include <linux/genalloc.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/kernel.h>\n#include <linux/mfd/altera-sysmgr.h>\n#include <linux/mfd/syscon.h>\n#include <linux/notifier.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/panic_notifier.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n\n#include \"altera_edac.h\"\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\t\"altera_edac\"\n#define EDAC_DEVICE\t\t\"Altera\"\n\n#ifdef CONFIG_EDAC_ALTERA_SDRAM\nstatic const struct altr_sdram_prv_data c5_data = {\n\t.ecc_ctrl_offset    = CV_CTLCFG_OFST,\n\t.ecc_ctl_en_mask    = CV_CTLCFG_ECC_AUTO_EN,\n\t.ecc_stat_offset    = CV_DRAMSTS_OFST,\n\t.ecc_stat_ce_mask   = CV_DRAMSTS_SBEERR,\n\t.ecc_stat_ue_mask   = CV_DRAMSTS_DBEERR,\n\t.ecc_saddr_offset   = CV_ERRADDR_OFST,\n\t.ecc_daddr_offset   = CV_ERRADDR_OFST,\n\t.ecc_cecnt_offset   = CV_SBECOUNT_OFST,\n\t.ecc_uecnt_offset   = CV_DBECOUNT_OFST,\n\t.ecc_irq_en_offset  = CV_DRAMINTR_OFST,\n\t.ecc_irq_en_mask    = CV_DRAMINTR_INTREN,\n\t.ecc_irq_clr_offset = CV_DRAMINTR_OFST,\n\t.ecc_irq_clr_mask   = (CV_DRAMINTR_INTRCLR | CV_DRAMINTR_INTREN),\n\t.ecc_cnt_rst_offset = CV_DRAMINTR_OFST,\n\t.ecc_cnt_rst_mask   = CV_DRAMINTR_INTRCLR,\n\t.ce_ue_trgr_offset  = CV_CTLCFG_OFST,\n\t.ce_set_mask        = CV_CTLCFG_GEN_SB_ERR,\n\t.ue_set_mask        = CV_CTLCFG_GEN_DB_ERR,\n};\n\nstatic const struct altr_sdram_prv_data a10_data = {\n\t.ecc_ctrl_offset    = A10_ECCCTRL1_OFST,\n\t.ecc_ctl_en_mask    = A10_ECCCTRL1_ECC_EN,\n\t.ecc_stat_offset    = A10_INTSTAT_OFST,\n\t.ecc_stat_ce_mask   = A10_INTSTAT_SBEERR,\n\t.ecc_stat_ue_mask   = A10_INTSTAT_DBEERR,\n\t.ecc_saddr_offset   = A10_SERRADDR_OFST,\n\t.ecc_daddr_offset   = A10_DERRADDR_OFST,\n\t.ecc_irq_en_offset  = A10_ERRINTEN_OFST,\n\t.ecc_irq_en_mask    = A10_ECC_IRQ_EN_MASK,\n\t.ecc_irq_clr_offset = A10_INTSTAT_OFST,\n\t.ecc_irq_clr_mask   = (A10_INTSTAT_SBEERR | A10_INTSTAT_DBEERR),\n\t.ecc_cnt_rst_offset = A10_ECCCTRL1_OFST,\n\t.ecc_cnt_rst_mask   = A10_ECC_CNT_RESET_MASK,\n\t.ce_ue_trgr_offset  = A10_DIAGINTTEST_OFST,\n\t.ce_set_mask        = A10_DIAGINT_TSERRA_MASK,\n\t.ue_set_mask        = A10_DIAGINT_TDERRA_MASK,\n};\n\n \n\n \n\nstatic irqreturn_t altr_sdram_mc_err_handler(int irq, void *dev_id)\n{\n\tstruct mem_ctl_info *mci = dev_id;\n\tstruct altr_sdram_mc_data *drvdata = mci->pvt_info;\n\tconst struct altr_sdram_prv_data *priv = drvdata->data;\n\tu32 status, err_count = 1, err_addr;\n\n\tregmap_read(drvdata->mc_vbase, priv->ecc_stat_offset, &status);\n\n\tif (status & priv->ecc_stat_ue_mask) {\n\t\tregmap_read(drvdata->mc_vbase, priv->ecc_daddr_offset,\n\t\t\t    &err_addr);\n\t\tif (priv->ecc_uecnt_offset)\n\t\t\tregmap_read(drvdata->mc_vbase, priv->ecc_uecnt_offset,\n\t\t\t\t    &err_count);\n\t\tpanic(\"\\nEDAC: [%d Uncorrectable errors @ 0x%08X]\\n\",\n\t\t      err_count, err_addr);\n\t}\n\tif (status & priv->ecc_stat_ce_mask) {\n\t\tregmap_read(drvdata->mc_vbase, priv->ecc_saddr_offset,\n\t\t\t    &err_addr);\n\t\tif (priv->ecc_uecnt_offset)\n\t\t\tregmap_read(drvdata->mc_vbase,  priv->ecc_cecnt_offset,\n\t\t\t\t    &err_count);\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, err_count,\n\t\t\t\t     err_addr >> PAGE_SHIFT,\n\t\t\t\t     err_addr & ~PAGE_MASK, 0,\n\t\t\t\t     0, 0, -1, mci->ctl_name, \"\");\n\t\t \n\t\tregmap_write(drvdata->mc_vbase,\tpriv->ecc_irq_clr_offset,\n\t\t\t     priv->ecc_irq_clr_mask);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic ssize_t altr_sdr_mc_err_inject_write(struct file *file,\n\t\t\t\t\t    const char __user *data,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct mem_ctl_info *mci = file->private_data;\n\tstruct altr_sdram_mc_data *drvdata = mci->pvt_info;\n\tconst struct altr_sdram_prv_data *priv = drvdata->data;\n\tu32 *ptemp;\n\tdma_addr_t dma_handle;\n\tu32 reg, read_reg;\n\n\tptemp = dma_alloc_coherent(mci->pdev, 16, &dma_handle, GFP_KERNEL);\n\tif (!ptemp) {\n\t\tdma_free_coherent(mci->pdev, 16, ptemp, dma_handle);\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Inject: Buffer Allocation error\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tregmap_read(drvdata->mc_vbase, priv->ce_ue_trgr_offset,\n\t\t    &read_reg);\n\tread_reg &= ~(priv->ce_set_mask | priv->ue_set_mask);\n\n\t \n\tif (count == 3) {\n\t\tedac_printk(KERN_ALERT, EDAC_MC,\n\t\t\t    \"Inject Double bit error\\n\");\n\t\tlocal_irq_disable();\n\t\tregmap_write(drvdata->mc_vbase, priv->ce_ue_trgr_offset,\n\t\t\t     (read_reg | priv->ue_set_mask));\n\t\tlocal_irq_enable();\n\t} else {\n\t\tedac_printk(KERN_ALERT, EDAC_MC,\n\t\t\t    \"Inject Single bit error\\n\");\n\t\tlocal_irq_disable();\n\t\tregmap_write(drvdata->mc_vbase,\tpriv->ce_ue_trgr_offset,\n\t\t\t     (read_reg | priv->ce_set_mask));\n\t\tlocal_irq_enable();\n\t}\n\n\tptemp[0] = 0x5A5A5A5A;\n\tptemp[1] = 0xA5A5A5A5;\n\n\t \n\tregmap_write(drvdata->mc_vbase,\tpriv->ce_ue_trgr_offset, read_reg);\n\t \n\twmb();\n\n\t \n\treg = READ_ONCE(ptemp[0]);\n\tread_reg = READ_ONCE(ptemp[1]);\n\t \n\trmb();\n\n\tedac_printk(KERN_ALERT, EDAC_MC, \"Read Data [0x%X, 0x%X]\\n\",\n\t\t    reg, read_reg);\n\n\tdma_free_coherent(mci->pdev, 16, ptemp, dma_handle);\n\n\treturn count;\n}\n\nstatic const struct file_operations altr_sdr_mc_debug_inject_fops = {\n\t.open = simple_open,\n\t.write = altr_sdr_mc_err_inject_write,\n\t.llseek = generic_file_llseek,\n};\n\nstatic void altr_sdr_mc_create_debugfs_nodes(struct mem_ctl_info *mci)\n{\n\tif (!IS_ENABLED(CONFIG_EDAC_DEBUG))\n\t\treturn;\n\n\tif (!mci->debugfs)\n\t\treturn;\n\n\tedac_debugfs_create_file(\"altr_trigger\", S_IWUSR, mci->debugfs, mci,\n\t\t\t\t &altr_sdr_mc_debug_inject_fops);\n}\n\n \nstatic unsigned long get_total_mem(void)\n{\n\tstruct device_node *np = NULL;\n\tstruct resource res;\n\tint ret;\n\tunsigned long total_mem = 0;\n\n\tfor_each_node_by_type(np, \"memory\") {\n\t\tret = of_address_to_resource(np, 0, &res);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\ttotal_mem += resource_size(&res);\n\t}\n\tedac_dbg(0, \"total_mem 0x%lx\\n\", total_mem);\n\treturn total_mem;\n}\n\nstatic const struct of_device_id altr_sdram_ctrl_of_match[] = {\n\t{ .compatible = \"altr,sdram-edac\", .data = &c5_data},\n\t{ .compatible = \"altr,sdram-edac-a10\", .data = &a10_data},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altr_sdram_ctrl_of_match);\n\nstatic int a10_init(struct regmap *mc_vbase)\n{\n\tif (regmap_update_bits(mc_vbase, A10_INTMODE_OFST,\n\t\t\t       A10_INTMODE_SB_INT, A10_INTMODE_SB_INT)) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Error setting SB IRQ mode\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (regmap_write(mc_vbase, A10_SERRCNTREG_OFST, 1)) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Error setting trigger count\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int a10_unmask_irq(struct platform_device *pdev, u32 mask)\n{\n\tvoid __iomem  *sm_base;\n\tint  ret = 0;\n\n\tif (!request_mem_region(A10_SYMAN_INTMASK_CLR, sizeof(u32),\n\t\t\t\tdev_name(&pdev->dev))) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Unable to request mem region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tsm_base = ioremap(A10_SYMAN_INTMASK_CLR, sizeof(u32));\n\tif (!sm_base) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Unable to ioremap device\\n\");\n\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tiowrite32(mask, sm_base);\n\n\tiounmap(sm_base);\n\nrelease:\n\trelease_mem_region(A10_SYMAN_INTMASK_CLR, sizeof(u32));\n\n\treturn ret;\n}\n\nstatic int altr_sdram_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *id;\n\tstruct edac_mc_layer layers[2];\n\tstruct mem_ctl_info *mci;\n\tstruct altr_sdram_mc_data *drvdata;\n\tconst struct altr_sdram_prv_data *priv;\n\tstruct regmap *mc_vbase;\n\tstruct dimm_info *dimm;\n\tu32 read_reg;\n\tint irq, irq2, res = 0;\n\tunsigned long mem_size, irqflags = 0;\n\n\tid = of_match_device(altr_sdram_ctrl_of_match, &pdev->dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\t \n\tmc_vbase = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t   \"altr,sdr-syscon\");\n\tif (IS_ERR(mc_vbase)) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"regmap for altr,sdr-syscon lookup failed.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpriv = of_match_node(altr_sdram_ctrl_of_match,\n\t\t\t     pdev->dev.of_node)->data;\n\n\t \n\tif (regmap_read(mc_vbase, priv->ecc_ctrl_offset, &read_reg) ||\n\t    ((read_reg & priv->ecc_ctl_en_mask) != priv->ecc_ctl_en_mask)) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"No ECC/ECC disabled [0x%08X]\\n\", read_reg);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmem_size = get_total_mem();\n\tif (!mem_size) {\n\t\tedac_printk(KERN_ERR, EDAC_MC, \"Unable to calculate memory size\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (regmap_update_bits(mc_vbase, priv->ecc_irq_en_offset,\n\t\t\t       priv->ecc_irq_en_mask, 0)) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Error disabling SDRAM ECC IRQ\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (regmap_update_bits(mc_vbase, priv->ecc_cnt_rst_offset,\n\t\t\t       priv->ecc_cnt_rst_mask,\n\t\t\t       priv->ecc_cnt_rst_mask)) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Error clearing SDRAM ECC count\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (regmap_update_bits(mc_vbase, priv->ecc_cnt_rst_offset,\n\t\t\t       priv->ecc_cnt_rst_mask, 0)) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Error clearing SDRAM ECC count\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"No irq %d in DT\\n\", irq);\n\t\treturn irq;\n\t}\n\n\t \n\tirq2 = platform_get_irq(pdev, 1);\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = 1;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = 1;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct altr_sdram_mc_data));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tmci->pdev = &pdev->dev;\n\tdrvdata = mci->pvt_info;\n\tdrvdata->mc_vbase = mc_vbase;\n\tdrvdata->data = priv;\n\tplatform_set_drvdata(pdev, mci);\n\n\tif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Unable to get managed device resource\\n\");\n\t\tres = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tmci->mtype_cap = MEM_FLAG_DDR3;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = dev_name(&pdev->dev);\n\tmci->scrub_mode = SCRUB_SW_SRC;\n\tmci->dev_name = dev_name(&pdev->dev);\n\n\tdimm = *mci->dimms;\n\tdimm->nr_pages = ((mem_size - 1) >> PAGE_SHIFT) + 1;\n\tdimm->grain = 8;\n\tdimm->dtype = DEV_X8;\n\tdimm->mtype = MEM_DDR3;\n\tdimm->edac_mode = EDAC_SECDED;\n\n\tres = edac_mc_add_mc(mci);\n\tif (res < 0)\n\t\tgoto err;\n\n\t \n\tif (of_machine_is_compatible(\"altr,socfpga-arria10\")) {\n\t\t \n\t\tres = a10_init(mc_vbase);\n\t\tif (res < 0)\n\t\t\tgoto err2;\n\n\t\tres = devm_request_irq(&pdev->dev, irq2,\n\t\t\t\t       altr_sdram_mc_err_handler,\n\t\t\t\t       IRQF_SHARED, dev_name(&pdev->dev), mci);\n\t\tif (res < 0) {\n\t\t\tedac_mc_printk(mci, KERN_ERR,\n\t\t\t\t       \"Unable to request irq %d\\n\", irq2);\n\t\t\tres = -ENODEV;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tres = a10_unmask_irq(pdev, A10_DDR0_IRQ_MASK);\n\t\tif (res < 0)\n\t\t\tgoto err2;\n\n\t\tirqflags = IRQF_SHARED;\n\t}\n\n\tres = devm_request_irq(&pdev->dev, irq, altr_sdram_mc_err_handler,\n\t\t\t       irqflags, dev_name(&pdev->dev), mci);\n\tif (res < 0) {\n\t\tedac_mc_printk(mci, KERN_ERR,\n\t\t\t       \"Unable to request irq %d\\n\", irq);\n\t\tres = -ENODEV;\n\t\tgoto err2;\n\t}\n\n\t \n\tif (regmap_update_bits(drvdata->mc_vbase, priv->ecc_irq_en_offset,\n\t\t\t       priv->ecc_irq_en_mask, priv->ecc_irq_en_mask)) {\n\t\tedac_mc_printk(mci, KERN_ERR,\n\t\t\t       \"Error enabling SDRAM ECC IRQ\\n\");\n\t\tres = -ENODEV;\n\t\tgoto err2;\n\t}\n\n\taltr_sdr_mc_create_debugfs_nodes(mci);\n\n\tdevres_close_group(&pdev->dev, NULL);\n\n\treturn 0;\n\nerr2:\n\tedac_mc_del_mc(&pdev->dev);\nerr:\n\tdevres_release_group(&pdev->dev, NULL);\nfree:\n\tedac_mc_free(mci);\n\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t    \"EDAC Probe Failed; Error %d\\n\", res);\n\n\treturn res;\n}\n\nstatic int altr_sdram_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\n \n#ifdef CONFIG_PM\nstatic int altr_sdram_prepare(struct device *dev)\n{\n\tpr_err(\"Suspend not allowed when EDAC is enabled.\\n\");\n\n\treturn -EPERM;\n}\n\nstatic const struct dev_pm_ops altr_sdram_pm_ops = {\n\t.prepare = altr_sdram_prepare,\n};\n#endif\n\nstatic struct platform_driver altr_sdram_edac_driver = {\n\t.probe = altr_sdram_probe,\n\t.remove = altr_sdram_remove,\n\t.driver = {\n\t\t.name = \"altr_sdram_edac\",\n#ifdef CONFIG_PM\n\t\t.pm = &altr_sdram_pm_ops,\n#endif\n\t\t.of_match_table = altr_sdram_ctrl_of_match,\n\t},\n};\n\nmodule_platform_driver(altr_sdram_edac_driver);\n\n#endif\t \n\n \n\nstatic const struct of_device_id altr_edac_device_of_match[];\n\nstatic const struct of_device_id altr_edac_of_match[] = {\n\t{ .compatible = \"altr,socfpga-ecc-manager\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altr_edac_of_match);\n\nstatic int altr_edac_probe(struct platform_device *pdev)\n{\n\tof_platform_populate(pdev->dev.of_node, altr_edac_device_of_match,\n\t\t\t     NULL, &pdev->dev);\n\treturn 0;\n}\n\nstatic struct platform_driver altr_edac_driver = {\n\t.probe =  altr_edac_probe,\n\t.driver = {\n\t\t.name = \"socfpga_ecc_manager\",\n\t\t.of_match_table = altr_edac_of_match,\n\t},\n};\nmodule_platform_driver(altr_edac_driver);\n\n \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_OCRAM\nstatic const struct edac_device_prv_data ocramecc_data;\n#endif\n#ifdef CONFIG_EDAC_ALTERA_L2C\nstatic const struct edac_device_prv_data l2ecc_data;\n#endif\n#ifdef CONFIG_EDAC_ALTERA_OCRAM\nstatic const struct edac_device_prv_data a10_ocramecc_data;\n#endif\n#ifdef CONFIG_EDAC_ALTERA_L2C\nstatic const struct edac_device_prv_data a10_l2ecc_data;\n#endif\n\nstatic irqreturn_t altr_edac_device_handler(int irq, void *dev_id)\n{\n\tirqreturn_t ret_value = IRQ_NONE;\n\tstruct edac_device_ctl_info *dci = dev_id;\n\tstruct altr_edac_device_dev *drvdata = dci->pvt_info;\n\tconst struct edac_device_prv_data *priv = drvdata->data;\n\n\tif (irq == drvdata->sb_irq) {\n\t\tif (priv->ce_clear_mask)\n\t\t\twritel(priv->ce_clear_mask, drvdata->base);\n\t\tedac_device_handle_ce(dci, 0, 0, drvdata->edac_dev_name);\n\t\tret_value = IRQ_HANDLED;\n\t} else if (irq == drvdata->db_irq) {\n\t\tif (priv->ue_clear_mask)\n\t\t\twritel(priv->ue_clear_mask, drvdata->base);\n\t\tedac_device_handle_ue(dci, 0, 0, drvdata->edac_dev_name);\n\t\tpanic(\"\\nEDAC:ECC_DEVICE[Uncorrectable errors]\\n\");\n\t\tret_value = IRQ_HANDLED;\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\treturn ret_value;\n}\n\nstatic ssize_t __maybe_unused\naltr_edac_device_trig(struct file *file, const char __user *user_buf,\n\t\t      size_t count, loff_t *ppos)\n\n{\n\tu32 *ptemp, i, error_mask;\n\tint result = 0;\n\tu8 trig_type;\n\tunsigned long flags;\n\tstruct edac_device_ctl_info *edac_dci = file->private_data;\n\tstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\n\tconst struct edac_device_prv_data *priv = drvdata->data;\n\tvoid *generic_ptr = edac_dci->dev;\n\n\tif (!user_buf || get_user(trig_type, user_buf))\n\t\treturn -EFAULT;\n\n\tif (!priv->alloc_mem)\n\t\treturn -ENOMEM;\n\n\t \n\tptemp = priv->alloc_mem(priv->trig_alloc_sz, &generic_ptr);\n\tif (!ptemp) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"Inject: Buffer Allocation error\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (trig_type == ALTR_UE_TRIGGER_CHAR)\n\t\terror_mask = priv->ue_set_mask;\n\telse\n\t\terror_mask = priv->ce_set_mask;\n\n\tedac_printk(KERN_ALERT, EDAC_DEVICE,\n\t\t    \"Trigger Error Mask (0x%X)\\n\", error_mask);\n\n\tlocal_irq_save(flags);\n\t \n\tfor (i = 0; i < (priv->trig_alloc_sz / sizeof(*ptemp)); i++) {\n\t\t \n\t\trmb();\n\t\tif (READ_ONCE(ptemp[i]))\n\t\t\tresult = -1;\n\t\t \n\t\twritel(error_mask, (drvdata->base + priv->set_err_ofst));\n\t\twritel(priv->ecc_enable_mask, (drvdata->base +\n\t\t\t\t\t       priv->set_err_ofst));\n\t\tptemp[i] = i;\n\t}\n\t \n\twmb();\n\tlocal_irq_restore(flags);\n\n\tif (result)\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"Mem Not Cleared\\n\");\n\n\t \n\tfor (i = 0; i < ALTR_TRIGGER_READ_WRD_CNT; i++)\n\t\tif (READ_ONCE(ptemp[i]) != i)\n\t\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t\t    \"Read doesn't match written data\\n\");\n\n\tif (priv->free_mem)\n\t\tpriv->free_mem(ptemp, priv->trig_alloc_sz, generic_ptr);\n\n\treturn count;\n}\n\nstatic const struct file_operations altr_edac_device_inject_fops __maybe_unused = {\n\t.open = simple_open,\n\t.write = altr_edac_device_trig,\n\t.llseek = generic_file_llseek,\n};\n\nstatic ssize_t __maybe_unused\naltr_edac_a10_device_trig(struct file *file, const char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos);\n\nstatic const struct file_operations altr_edac_a10_device_inject_fops __maybe_unused = {\n\t.open = simple_open,\n\t.write = altr_edac_a10_device_trig,\n\t.llseek = generic_file_llseek,\n};\n\nstatic ssize_t __maybe_unused\naltr_edac_a10_device_trig2(struct file *file, const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos);\n\nstatic const struct file_operations altr_edac_a10_device_inject2_fops __maybe_unused = {\n\t.open = simple_open,\n\t.write = altr_edac_a10_device_trig2,\n\t.llseek = generic_file_llseek,\n};\n\nstatic void altr_create_edacdev_dbgfs(struct edac_device_ctl_info *edac_dci,\n\t\t\t\t      const struct edac_device_prv_data *priv)\n{\n\tstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\n\n\tif (!IS_ENABLED(CONFIG_EDAC_DEBUG))\n\t\treturn;\n\n\tdrvdata->debugfs_dir = edac_debugfs_create_dir(drvdata->edac_dev_name);\n\tif (!drvdata->debugfs_dir)\n\t\treturn;\n\n\tif (!edac_debugfs_create_file(\"altr_trigger\", S_IWUSR,\n\t\t\t\t      drvdata->debugfs_dir, edac_dci,\n\t\t\t\t      priv->inject_fops))\n\t\tdebugfs_remove_recursive(drvdata->debugfs_dir);\n}\n\nstatic const struct of_device_id altr_edac_device_of_match[] = {\n#ifdef CONFIG_EDAC_ALTERA_L2C\n\t{ .compatible = \"altr,socfpga-l2-ecc\", .data = &l2ecc_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_OCRAM\n\t{ .compatible = \"altr,socfpga-ocram-ecc\", .data = &ocramecc_data },\n#endif\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altr_edac_device_of_match);\n\n \nstatic int altr_edac_device_probe(struct platform_device *pdev)\n{\n\tstruct edac_device_ctl_info *dci;\n\tstruct altr_edac_device_dev *drvdata;\n\tstruct resource *r;\n\tint res = 0;\n\tstruct device_node *np = pdev->dev.of_node;\n\tchar *ecc_name = (char *)np->name;\n\tstatic int dev_instance;\n\n\tif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"Unable to open devm\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"Unable to get mem resource\\n\");\n\t\tres = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (!devm_request_mem_region(&pdev->dev, r->start, resource_size(r),\n\t\t\t\t     dev_name(&pdev->dev))) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"%s:Error requesting mem region\\n\", ecc_name);\n\t\tres = -EBUSY;\n\t\tgoto fail;\n\t}\n\n\tdci = edac_device_alloc_ctl_info(sizeof(*drvdata), ecc_name,\n\t\t\t\t\t 1, ecc_name, 1, 0, NULL, 0,\n\t\t\t\t\t dev_instance++);\n\n\tif (!dci) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"%s: Unable to allocate EDAC device\\n\", ecc_name);\n\t\tres = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tdrvdata = dci->pvt_info;\n\tdci->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, dci);\n\tdrvdata->edac_dev_name = ecc_name;\n\n\tdrvdata->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!drvdata->base) {\n\t\tres = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\t \n\tdrvdata->data = of_match_node(altr_edac_device_of_match, np)->data;\n\n\t \n\tif (drvdata->data->setup) {\n\t\tres = drvdata->data->setup(drvdata);\n\t\tif (res)\n\t\t\tgoto fail1;\n\t}\n\n\tdrvdata->sb_irq = platform_get_irq(pdev, 0);\n\tres = devm_request_irq(&pdev->dev, drvdata->sb_irq,\n\t\t\t       altr_edac_device_handler,\n\t\t\t       0, dev_name(&pdev->dev), dci);\n\tif (res)\n\t\tgoto fail1;\n\n\tdrvdata->db_irq = platform_get_irq(pdev, 1);\n\tres = devm_request_irq(&pdev->dev, drvdata->db_irq,\n\t\t\t       altr_edac_device_handler,\n\t\t\t       0, dev_name(&pdev->dev), dci);\n\tif (res)\n\t\tgoto fail1;\n\n\tdci->mod_name = \"Altera ECC Manager\";\n\tdci->dev_name = drvdata->edac_dev_name;\n\n\tres = edac_device_add_device(dci);\n\tif (res)\n\t\tgoto fail1;\n\n\taltr_create_edacdev_dbgfs(dci, drvdata->data);\n\n\tdevres_close_group(&pdev->dev, NULL);\n\n\treturn 0;\n\nfail1:\n\tedac_device_free_ctl_info(dci);\nfail:\n\tdevres_release_group(&pdev->dev, NULL);\n\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t    \"%s:Error setting up EDAC device: %d\\n\", ecc_name, res);\n\n\treturn res;\n}\n\nstatic int altr_edac_device_remove(struct platform_device *pdev)\n{\n\tstruct edac_device_ctl_info *dci = platform_get_drvdata(pdev);\n\tstruct altr_edac_device_dev *drvdata = dci->pvt_info;\n\n\tdebugfs_remove_recursive(drvdata->debugfs_dir);\n\tedac_device_del_device(&pdev->dev);\n\tedac_device_free_ctl_info(dci);\n\n\treturn 0;\n}\n\nstatic struct platform_driver altr_edac_device_driver = {\n\t.probe =  altr_edac_device_probe,\n\t.remove = altr_edac_device_remove,\n\t.driver = {\n\t\t.name = \"altr_edac_device\",\n\t\t.of_match_table = altr_edac_device_of_match,\n\t},\n};\nmodule_platform_driver(altr_edac_device_driver);\n\n \n\n \nstatic int __maybe_unused\naltr_check_ecc_deps(struct altr_edac_device_dev *device)\n{\n\tvoid __iomem  *base = device->base;\n\tconst struct edac_device_prv_data *prv = device->data;\n\n\tif (readl(base + prv->ecc_en_ofst) & prv->ecc_enable_mask)\n\t\treturn 0;\n\n\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t    \"%s: No ECC present or ECC disabled.\\n\",\n\t\t    device->edac_dev_name);\n\treturn -ENODEV;\n}\n\nstatic irqreturn_t __maybe_unused altr_edac_a10_ecc_irq(int irq, void *dev_id)\n{\n\tstruct altr_edac_device_dev *dci = dev_id;\n\tvoid __iomem  *base = dci->base;\n\n\tif (irq == dci->sb_irq) {\n\t\twritel(ALTR_A10_ECC_SERRPENA,\n\t\t       base + ALTR_A10_ECC_INTSTAT_OFST);\n\t\tedac_device_handle_ce(dci->edac_dev, 0, 0, dci->edac_dev_name);\n\n\t\treturn IRQ_HANDLED;\n\t} else if (irq == dci->db_irq) {\n\t\twritel(ALTR_A10_ECC_DERRPENA,\n\t\t       base + ALTR_A10_ECC_INTSTAT_OFST);\n\t\tedac_device_handle_ue(dci->edac_dev, 0, 0, dci->edac_dev_name);\n\t\tif (dci->data->panic)\n\t\t\tpanic(\"\\nEDAC:ECC_DEVICE[Uncorrectable errors]\\n\");\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tWARN_ON(1);\n\n\treturn IRQ_NONE;\n}\n\n \n\nstatic inline int a10_get_irq_mask(struct device_node *np)\n{\n\tint irq;\n\tconst u32 *handle = of_get_property(np, \"interrupts\", NULL);\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\tirq = be32_to_cpup(handle);\n\treturn irq;\n}\n\nstatic inline void ecc_set_bits(u32 bit_mask, void __iomem *ioaddr)\n{\n\tu32 value = readl(ioaddr);\n\n\tvalue |= bit_mask;\n\twritel(value, ioaddr);\n}\n\nstatic inline void ecc_clear_bits(u32 bit_mask, void __iomem *ioaddr)\n{\n\tu32 value = readl(ioaddr);\n\n\tvalue &= ~bit_mask;\n\twritel(value, ioaddr);\n}\n\nstatic inline int ecc_test_bits(u32 bit_mask, void __iomem *ioaddr)\n{\n\tu32 value = readl(ioaddr);\n\n\treturn (value & bit_mask) ? 1 : 0;\n}\n\n \nstatic int __maybe_unused altr_init_memory_port(void __iomem *ioaddr, int port)\n{\n\tint limit = ALTR_A10_ECC_INIT_WATCHDOG_10US;\n\tu32 init_mask, stat_mask, clear_mask;\n\tint ret = 0;\n\n\tif (port) {\n\t\tinit_mask = ALTR_A10_ECC_INITB;\n\t\tstat_mask = ALTR_A10_ECC_INITCOMPLETEB;\n\t\tclear_mask = ALTR_A10_ECC_ERRPENB_MASK;\n\t} else {\n\t\tinit_mask = ALTR_A10_ECC_INITA;\n\t\tstat_mask = ALTR_A10_ECC_INITCOMPLETEA;\n\t\tclear_mask = ALTR_A10_ECC_ERRPENA_MASK;\n\t}\n\n\tecc_set_bits(init_mask, (ioaddr + ALTR_A10_ECC_CTRL_OFST));\n\twhile (limit--) {\n\t\tif (ecc_test_bits(stat_mask,\n\t\t\t\t  (ioaddr + ALTR_A10_ECC_INITSTAT_OFST)))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (limit < 0)\n\t\tret = -EBUSY;\n\n\t \n\twritel(clear_mask, (ioaddr + ALTR_A10_ECC_INTSTAT_OFST));\n\n\treturn ret;\n}\n\nstatic __init int __maybe_unused\naltr_init_a10_ecc_block(struct device_node *np, u32 irq_mask,\n\t\t\tu32 ecc_ctrl_en_mask, bool dual_port)\n{\n\tint ret = 0;\n\tvoid __iomem *ecc_block_base;\n\tstruct regmap *ecc_mgr_map;\n\tchar *ecc_name;\n\tstruct device_node *np_eccmgr;\n\n\tecc_name = (char *)np->name;\n\n\t \n\tnp_eccmgr = of_get_parent(np);\n\n\tecc_mgr_map =\n\t\taltr_sysmgr_regmap_lookup_by_phandle(np_eccmgr,\n\t\t\t\t\t\t     \"altr,sysmgr-syscon\");\n\n\tof_node_put(np_eccmgr);\n\tif (IS_ERR(ecc_mgr_map)) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"Unable to get syscon altr,sysmgr-syscon\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tecc_block_base = of_iomap(np, 0);\n\tif (!ecc_block_base) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"Unable to map %s ECC block\\n\", ecc_name);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tregmap_write(ecc_mgr_map, A10_SYSMGR_ECC_INTMASK_SET_OFST, irq_mask);\n\twritel(ALTR_A10_ECC_SERRINTEN,\n\t       (ecc_block_base + ALTR_A10_ECC_ERRINTENR_OFST));\n\tecc_clear_bits(ecc_ctrl_en_mask,\n\t\t       (ecc_block_base + ALTR_A10_ECC_CTRL_OFST));\n\t \n\twmb();\n\t \n\tret = altr_init_memory_port(ecc_block_base, 0);\n\tif (ret) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"ECC: cannot init %s PORTA memory\\n\", ecc_name);\n\t\tgoto out;\n\t}\n\n\tif (dual_port) {\n\t\tret = altr_init_memory_port(ecc_block_base, 1);\n\t\tif (ret) {\n\t\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t\t    \"ECC: cannot init %s PORTB memory\\n\",\n\t\t\t\t    ecc_name);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tregmap_write(ecc_mgr_map, ALTR_A10_ECC_INTMODE_OFST,\n\t\t     ALTR_A10_ECC_INTMODE);\n\t \n\tecc_set_bits(ecc_ctrl_en_mask, (ecc_block_base +\n\t\t\t\t\tALTR_A10_ECC_CTRL_OFST));\n\twritel(ALTR_A10_ECC_SERRINTEN,\n\t       (ecc_block_base + ALTR_A10_ECC_ERRINTENS_OFST));\n\tregmap_write(ecc_mgr_map, A10_SYSMGR_ECC_INTMASK_CLR_OFST, irq_mask);\n\t \n\twmb();\nout:\n\tiounmap(ecc_block_base);\n\treturn ret;\n}\n\nstatic int validate_parent_available(struct device_node *np);\nstatic const struct of_device_id altr_edac_a10_device_of_match[];\nstatic int __init __maybe_unused altr_init_a10_ecc_device_type(char *compat)\n{\n\tint irq;\n\tstruct device_node *child, *np;\n\n\tnp = of_find_compatible_node(NULL, NULL,\n\t\t\t\t     \"altr,socfpga-a10-ecc-manager\");\n\tif (!np) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"ECC Manager not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor_each_child_of_node(np, child) {\n\t\tconst struct of_device_id *pdev_id;\n\t\tconst struct edac_device_prv_data *prv;\n\n\t\tif (!of_device_is_available(child))\n\t\t\tcontinue;\n\t\tif (!of_device_is_compatible(child, compat))\n\t\t\tcontinue;\n\n\t\tif (validate_parent_available(child))\n\t\t\tcontinue;\n\n\t\tirq = a10_get_irq_mask(child);\n\t\tif (irq < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tpdev_id = of_match_node(altr_edac_a10_device_of_match, child);\n\t\tif (IS_ERR_OR_NULL(pdev_id))\n\t\t\tcontinue;\n\n\t\t \n\t\tprv = pdev_id->data;\n\t\tif (!prv)\n\t\t\tcontinue;\n\n\t\taltr_init_a10_ecc_block(child, BIT(irq),\n\t\t\t\t\tprv->ecc_enable_mask, 0);\n\t}\n\n\tof_node_put(np);\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_EDAC_ALTERA_SDRAM\n\n \nstatic int altr_s10_sdram_check_ecc_deps(struct altr_edac_device_dev *device)\n{\n\tconst struct edac_device_prv_data *prv = device->data;\n\tunsigned long sdram_ecc_addr;\n\tstruct arm_smccc_res result;\n\tstruct device_node *np;\n\tphys_addr_t sdram_addr;\n\tu32 read_reg;\n\tint ret;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"altr,sdr-ctl\");\n\tif (!np)\n\t\tgoto sdram_err;\n\n\tsdram_addr = of_translate_address(np, of_get_address(np, 0,\n\t\t\t\t\t\t\t     NULL, NULL));\n\tof_node_put(np);\n\tsdram_ecc_addr = (unsigned long)sdram_addr + prv->ecc_en_ofst;\n\tarm_smccc_smc(INTEL_SIP_SMC_REG_READ, sdram_ecc_addr,\n\t\t      0, 0, 0, 0, 0, 0, &result);\n\tread_reg = (unsigned int)result.a1;\n\tret = (int)result.a0;\n\tif (!ret && (read_reg & prv->ecc_enable_mask))\n\t\treturn 0;\n\nsdram_err:\n\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t    \"%s: No ECC present or ECC disabled.\\n\",\n\t\t    device->edac_dev_name);\n\treturn -ENODEV;\n}\n\nstatic const struct edac_device_prv_data s10_sdramecc_data = {\n\t.setup = altr_s10_sdram_check_ecc_deps,\n\t.ce_clear_mask = ALTR_S10_ECC_SERRPENA,\n\t.ue_clear_mask = ALTR_S10_ECC_DERRPENA,\n\t.ecc_enable_mask = ALTR_S10_ECC_EN,\n\t.ecc_en_ofst = ALTR_S10_ECC_CTRL_SDRAM_OFST,\n\t.ce_set_mask = ALTR_S10_ECC_TSERRA,\n\t.ue_set_mask = ALTR_S10_ECC_TDERRA,\n\t.set_err_ofst = ALTR_S10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq,\n\t.inject_fops = &altr_edac_a10_device_inject_fops,\n};\n#endif  \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_OCRAM\n\nstatic void *ocram_alloc_mem(size_t size, void **other)\n{\n\tstruct device_node *np;\n\tstruct gen_pool *gp;\n\tvoid *sram_addr;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"altr,socfpga-ocram-ecc\");\n\tif (!np)\n\t\treturn NULL;\n\n\tgp = of_gen_pool_get(np, \"iram\", 0);\n\tof_node_put(np);\n\tif (!gp)\n\t\treturn NULL;\n\n\tsram_addr = (void *)gen_pool_alloc(gp, size);\n\tif (!sram_addr)\n\t\treturn NULL;\n\n\tmemset(sram_addr, 0, size);\n\t \n\twmb();\n\n\t \n\t*other = gp;\n\n\treturn sram_addr;\n}\n\nstatic void ocram_free_mem(void *p, size_t size, void *other)\n{\n\tgen_pool_free((struct gen_pool *)other, (unsigned long)p, size);\n}\n\nstatic const struct edac_device_prv_data ocramecc_data = {\n\t.setup = altr_check_ecc_deps,\n\t.ce_clear_mask = (ALTR_OCR_ECC_EN | ALTR_OCR_ECC_SERR),\n\t.ue_clear_mask = (ALTR_OCR_ECC_EN | ALTR_OCR_ECC_DERR),\n\t.alloc_mem = ocram_alloc_mem,\n\t.free_mem = ocram_free_mem,\n\t.ecc_enable_mask = ALTR_OCR_ECC_EN,\n\t.ecc_en_ofst = ALTR_OCR_ECC_REG_OFFSET,\n\t.ce_set_mask = (ALTR_OCR_ECC_EN | ALTR_OCR_ECC_INJS),\n\t.ue_set_mask = (ALTR_OCR_ECC_EN | ALTR_OCR_ECC_INJD),\n\t.set_err_ofst = ALTR_OCR_ECC_REG_OFFSET,\n\t.trig_alloc_sz = ALTR_TRIG_OCRAM_BYTE_SIZE,\n\t.inject_fops = &altr_edac_device_inject_fops,\n};\n\nstatic int __maybe_unused\naltr_check_ocram_deps_init(struct altr_edac_device_dev *device)\n{\n\tvoid __iomem  *base = device->base;\n\tint ret;\n\n\tret = altr_check_ecc_deps(device);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!ecc_test_bits(ALTR_A10_ECC_INITCOMPLETEA,\n\t\t\t   (base + ALTR_A10_ECC_INITSTAT_OFST)))\n\t\treturn -ENODEV;\n\n\t \n\twritel(ALTR_A10_ECC_SERRINTEN, (base + ALTR_A10_ECC_ERRINTENS_OFST));\n\t \n\twmb();\n\n\treturn 0;\n}\n\nstatic const struct edac_device_prv_data a10_ocramecc_data = {\n\t.setup = altr_check_ocram_deps_init,\n\t.ce_clear_mask = ALTR_A10_ECC_SERRPENA,\n\t.ue_clear_mask = ALTR_A10_ECC_DERRPENA,\n\t.irq_status_mask = A10_SYSMGR_ECC_INTSTAT_OCRAM,\n\t.ecc_enable_mask = ALTR_A10_OCRAM_ECC_EN_CTL,\n\t.ecc_en_ofst = ALTR_A10_ECC_CTRL_OFST,\n\t.ce_set_mask = ALTR_A10_ECC_TSERRA,\n\t.ue_set_mask = ALTR_A10_ECC_TDERRA,\n\t.set_err_ofst = ALTR_A10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq,\n\t.inject_fops = &altr_edac_a10_device_inject2_fops,\n\t \n\t.panic = true,\n};\n\n#endif\t \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_L2C\n\nstatic void *l2_alloc_mem(size_t size, void **other)\n{\n\tstruct device *dev = *other;\n\tvoid *ptemp = devm_kzalloc(dev, size, GFP_KERNEL);\n\n\tif (!ptemp)\n\t\treturn NULL;\n\n\t \n\twmb();\n\n\t \n\tflush_cache_all();\n\n\treturn ptemp;\n}\n\nstatic void l2_free_mem(void *p, size_t size, void *other)\n{\n\tstruct device *dev = other;\n\n\tif (dev && p)\n\t\tdevm_kfree(dev, p);\n}\n\n \nstatic int altr_l2_check_deps(struct altr_edac_device_dev *device)\n{\n\tvoid __iomem *base = device->base;\n\tconst struct edac_device_prv_data *prv = device->data;\n\n\tif ((readl(base) & prv->ecc_enable_mask) ==\n\t     prv->ecc_enable_mask)\n\t\treturn 0;\n\n\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t    \"L2: No ECC present, or ECC disabled\\n\");\n\treturn -ENODEV;\n}\n\nstatic irqreturn_t altr_edac_a10_l2_irq(int irq, void *dev_id)\n{\n\tstruct altr_edac_device_dev *dci = dev_id;\n\n\tif (irq == dci->sb_irq) {\n\t\tregmap_write(dci->edac->ecc_mgr_map,\n\t\t\t     A10_SYSGMR_MPU_CLEAR_L2_ECC_OFST,\n\t\t\t     A10_SYSGMR_MPU_CLEAR_L2_ECC_SB);\n\t\tedac_device_handle_ce(dci->edac_dev, 0, 0, dci->edac_dev_name);\n\n\t\treturn IRQ_HANDLED;\n\t} else if (irq == dci->db_irq) {\n\t\tregmap_write(dci->edac->ecc_mgr_map,\n\t\t\t     A10_SYSGMR_MPU_CLEAR_L2_ECC_OFST,\n\t\t\t     A10_SYSGMR_MPU_CLEAR_L2_ECC_MB);\n\t\tedac_device_handle_ue(dci->edac_dev, 0, 0, dci->edac_dev_name);\n\t\tpanic(\"\\nEDAC:ECC_DEVICE[Uncorrectable errors]\\n\");\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tWARN_ON(1);\n\n\treturn IRQ_NONE;\n}\n\nstatic const struct edac_device_prv_data l2ecc_data = {\n\t.setup = altr_l2_check_deps,\n\t.ce_clear_mask = 0,\n\t.ue_clear_mask = 0,\n\t.alloc_mem = l2_alloc_mem,\n\t.free_mem = l2_free_mem,\n\t.ecc_enable_mask = ALTR_L2_ECC_EN,\n\t.ce_set_mask = (ALTR_L2_ECC_EN | ALTR_L2_ECC_INJS),\n\t.ue_set_mask = (ALTR_L2_ECC_EN | ALTR_L2_ECC_INJD),\n\t.set_err_ofst = ALTR_L2_ECC_REG_OFFSET,\n\t.trig_alloc_sz = ALTR_TRIG_L2C_BYTE_SIZE,\n\t.inject_fops = &altr_edac_device_inject_fops,\n};\n\nstatic const struct edac_device_prv_data a10_l2ecc_data = {\n\t.setup = altr_l2_check_deps,\n\t.ce_clear_mask = ALTR_A10_L2_ECC_SERR_CLR,\n\t.ue_clear_mask = ALTR_A10_L2_ECC_MERR_CLR,\n\t.irq_status_mask = A10_SYSMGR_ECC_INTSTAT_L2,\n\t.alloc_mem = l2_alloc_mem,\n\t.free_mem = l2_free_mem,\n\t.ecc_enable_mask = ALTR_A10_L2_ECC_EN_CTL,\n\t.ce_set_mask = ALTR_A10_L2_ECC_CE_INJ_MASK,\n\t.ue_set_mask = ALTR_A10_L2_ECC_UE_INJ_MASK,\n\t.set_err_ofst = ALTR_A10_L2_ECC_INJ_OFST,\n\t.ecc_irq_handler = altr_edac_a10_l2_irq,\n\t.trig_alloc_sz = ALTR_TRIG_L2C_BYTE_SIZE,\n\t.inject_fops = &altr_edac_device_inject_fops,\n};\n\n#endif\t \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_ETHERNET\n\nstatic int __init socfpga_init_ethernet_ecc(struct altr_edac_device_dev *dev)\n{\n\tint ret;\n\n\tret = altr_init_a10_ecc_device_type(\"altr,socfpga-eth-mac-ecc\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn altr_check_ecc_deps(dev);\n}\n\nstatic const struct edac_device_prv_data a10_enetecc_data = {\n\t.setup = socfpga_init_ethernet_ecc,\n\t.ce_clear_mask = ALTR_A10_ECC_SERRPENA,\n\t.ue_clear_mask = ALTR_A10_ECC_DERRPENA,\n\t.ecc_enable_mask = ALTR_A10_COMMON_ECC_EN_CTL,\n\t.ecc_en_ofst = ALTR_A10_ECC_CTRL_OFST,\n\t.ce_set_mask = ALTR_A10_ECC_TSERRA,\n\t.ue_set_mask = ALTR_A10_ECC_TDERRA,\n\t.set_err_ofst = ALTR_A10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq,\n\t.inject_fops = &altr_edac_a10_device_inject2_fops,\n};\n\n#endif\t \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_NAND\n\nstatic int __init socfpga_init_nand_ecc(struct altr_edac_device_dev *device)\n{\n\tint ret;\n\n\tret = altr_init_a10_ecc_device_type(\"altr,socfpga-nand-ecc\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn altr_check_ecc_deps(device);\n}\n\nstatic const struct edac_device_prv_data a10_nandecc_data = {\n\t.setup = socfpga_init_nand_ecc,\n\t.ce_clear_mask = ALTR_A10_ECC_SERRPENA,\n\t.ue_clear_mask = ALTR_A10_ECC_DERRPENA,\n\t.ecc_enable_mask = ALTR_A10_COMMON_ECC_EN_CTL,\n\t.ecc_en_ofst = ALTR_A10_ECC_CTRL_OFST,\n\t.ce_set_mask = ALTR_A10_ECC_TSERRA,\n\t.ue_set_mask = ALTR_A10_ECC_TDERRA,\n\t.set_err_ofst = ALTR_A10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq,\n\t.inject_fops = &altr_edac_a10_device_inject_fops,\n};\n\n#endif\t \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_DMA\n\nstatic int __init socfpga_init_dma_ecc(struct altr_edac_device_dev *device)\n{\n\tint ret;\n\n\tret = altr_init_a10_ecc_device_type(\"altr,socfpga-dma-ecc\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn altr_check_ecc_deps(device);\n}\n\nstatic const struct edac_device_prv_data a10_dmaecc_data = {\n\t.setup = socfpga_init_dma_ecc,\n\t.ce_clear_mask = ALTR_A10_ECC_SERRPENA,\n\t.ue_clear_mask = ALTR_A10_ECC_DERRPENA,\n\t.ecc_enable_mask = ALTR_A10_COMMON_ECC_EN_CTL,\n\t.ecc_en_ofst = ALTR_A10_ECC_CTRL_OFST,\n\t.ce_set_mask = ALTR_A10_ECC_TSERRA,\n\t.ue_set_mask = ALTR_A10_ECC_TDERRA,\n\t.set_err_ofst = ALTR_A10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq,\n\t.inject_fops = &altr_edac_a10_device_inject_fops,\n};\n\n#endif\t \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_USB\n\nstatic int __init socfpga_init_usb_ecc(struct altr_edac_device_dev *device)\n{\n\tint ret;\n\n\tret = altr_init_a10_ecc_device_type(\"altr,socfpga-usb-ecc\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn altr_check_ecc_deps(device);\n}\n\nstatic const struct edac_device_prv_data a10_usbecc_data = {\n\t.setup = socfpga_init_usb_ecc,\n\t.ce_clear_mask = ALTR_A10_ECC_SERRPENA,\n\t.ue_clear_mask = ALTR_A10_ECC_DERRPENA,\n\t.ecc_enable_mask = ALTR_A10_COMMON_ECC_EN_CTL,\n\t.ecc_en_ofst = ALTR_A10_ECC_CTRL_OFST,\n\t.ce_set_mask = ALTR_A10_ECC_TSERRA,\n\t.ue_set_mask = ALTR_A10_ECC_TDERRA,\n\t.set_err_ofst = ALTR_A10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq,\n\t.inject_fops = &altr_edac_a10_device_inject2_fops,\n};\n\n#endif\t \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_QSPI\n\nstatic int __init socfpga_init_qspi_ecc(struct altr_edac_device_dev *device)\n{\n\tint ret;\n\n\tret = altr_init_a10_ecc_device_type(\"altr,socfpga-qspi-ecc\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn altr_check_ecc_deps(device);\n}\n\nstatic const struct edac_device_prv_data a10_qspiecc_data = {\n\t.setup = socfpga_init_qspi_ecc,\n\t.ce_clear_mask = ALTR_A10_ECC_SERRPENA,\n\t.ue_clear_mask = ALTR_A10_ECC_DERRPENA,\n\t.ecc_enable_mask = ALTR_A10_COMMON_ECC_EN_CTL,\n\t.ecc_en_ofst = ALTR_A10_ECC_CTRL_OFST,\n\t.ce_set_mask = ALTR_A10_ECC_TSERRA,\n\t.ue_set_mask = ALTR_A10_ECC_TDERRA,\n\t.set_err_ofst = ALTR_A10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq,\n\t.inject_fops = &altr_edac_a10_device_inject_fops,\n};\n\n#endif\t \n\n \n\n#ifdef CONFIG_EDAC_ALTERA_SDMMC\n\nstatic const struct edac_device_prv_data a10_sdmmceccb_data;\nstatic int altr_portb_setup(struct altr_edac_device_dev *device)\n{\n\tstruct edac_device_ctl_info *dci;\n\tstruct altr_edac_device_dev *altdev;\n\tchar *ecc_name = \"sdmmcb-ecc\";\n\tint edac_idx, rc;\n\tstruct device_node *np;\n\tconst struct edac_device_prv_data *prv = &a10_sdmmceccb_data;\n\n\trc = altr_check_ecc_deps(device);\n\tif (rc)\n\t\treturn rc;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"altr,socfpga-sdmmc-ecc\");\n\tif (!np) {\n\t\tedac_printk(KERN_WARNING, EDAC_DEVICE, \"SDMMC node not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tedac_idx = edac_device_alloc_index();\n\tdci = edac_device_alloc_ctl_info(sizeof(*altdev), ecc_name, 1,\n\t\t\t\t\t ecc_name, 1, 0, NULL, 0, edac_idx);\n\tif (!dci) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"%s: Unable to allocate PortB EDAC device\\n\",\n\t\t\t    ecc_name);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\taltdev = dci->pvt_info;\n\t*altdev = *device;\n\n\tif (!devres_open_group(&altdev->ddev, altr_portb_setup, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\t \n\taltdev->edac_dev_name = ecc_name;\n\taltdev->edac_idx = edac_idx;\n\taltdev->edac_dev = dci;\n\taltdev->data = prv;\n\tdci->dev = &altdev->ddev;\n\tdci->ctl_name = \"Altera ECC Manager\";\n\tdci->mod_name = ecc_name;\n\tdci->dev_name = ecc_name;\n\n\t \n#ifdef CONFIG_64BIT\n\taltdev->sb_irq = irq_of_parse_and_map(np, 1);\n#else\n\taltdev->sb_irq = irq_of_parse_and_map(np, 2);\n#endif\n\tif (!altdev->sb_irq) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"Error PortB SBIRQ alloc\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_release_group_1;\n\t}\n\trc = devm_request_irq(&altdev->ddev, altdev->sb_irq,\n\t\t\t      prv->ecc_irq_handler,\n\t\t\t      IRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t      ecc_name, altdev);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"PortB SBERR IRQ error\\n\");\n\t\tgoto err_release_group_1;\n\t}\n\n#ifdef CONFIG_64BIT\n\t \n\trc = of_property_read_u32_index(np, \"interrupts\", 1, &altdev->db_irq);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"Error PortB DBIRQ alloc\\n\");\n\t\tgoto err_release_group_1;\n\t}\n#else\n\taltdev->db_irq = irq_of_parse_and_map(np, 3);\n\tif (!altdev->db_irq) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"Error PortB DBIRQ alloc\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_release_group_1;\n\t}\n\trc = devm_request_irq(&altdev->ddev, altdev->db_irq,\n\t\t\t      prv->ecc_irq_handler,\n\t\t\t      IRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t      ecc_name, altdev);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"PortB DBERR IRQ error\\n\");\n\t\tgoto err_release_group_1;\n\t}\n#endif\n\n\trc = edac_device_add_device(dci);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"edac_device_add_device portB failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_release_group_1;\n\t}\n\taltr_create_edacdev_dbgfs(dci, prv);\n\n\tlist_add(&altdev->next, &altdev->edac->a10_ecc_devices);\n\n\tdevres_remove_group(&altdev->ddev, altr_portb_setup);\n\n\treturn 0;\n\nerr_release_group_1:\n\tedac_device_free_ctl_info(dci);\n\tdevres_release_group(&altdev->ddev, altr_portb_setup);\n\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t    \"%s:Error setting up EDAC device: %d\\n\", ecc_name, rc);\n\treturn rc;\n}\n\nstatic int __init socfpga_init_sdmmc_ecc(struct altr_edac_device_dev *device)\n{\n\tint rc = -ENODEV;\n\tstruct device_node *child;\n\n\tchild = of_find_compatible_node(NULL, NULL, \"altr,socfpga-sdmmc-ecc\");\n\tif (!child)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(child))\n\t\tgoto exit;\n\n\tif (validate_parent_available(child))\n\t\tgoto exit;\n\n\t \n\trc = altr_init_a10_ecc_block(child, ALTR_A10_SDMMC_IRQ_MASK,\n\t\t\t\t     a10_sdmmceccb_data.ecc_enable_mask, 1);\n\tif (rc)\n\t\tgoto exit;\n\n\t \n\treturn altr_portb_setup(device);\n\nexit:\n\tof_node_put(child);\n\treturn rc;\n}\n\nstatic irqreturn_t altr_edac_a10_ecc_irq_portb(int irq, void *dev_id)\n{\n\tstruct altr_edac_device_dev *ad = dev_id;\n\tvoid __iomem  *base = ad->base;\n\tconst struct edac_device_prv_data *priv = ad->data;\n\n\tif (irq == ad->sb_irq) {\n\t\twritel(priv->ce_clear_mask,\n\t\t       base + ALTR_A10_ECC_INTSTAT_OFST);\n\t\tedac_device_handle_ce(ad->edac_dev, 0, 0, ad->edac_dev_name);\n\t\treturn IRQ_HANDLED;\n\t} else if (irq == ad->db_irq) {\n\t\twritel(priv->ue_clear_mask,\n\t\t       base + ALTR_A10_ECC_INTSTAT_OFST);\n\t\tedac_device_handle_ue(ad->edac_dev, 0, 0, ad->edac_dev_name);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tWARN_ONCE(1, \"Unhandled IRQ%d on Port B.\", irq);\n\n\treturn IRQ_NONE;\n}\n\nstatic const struct edac_device_prv_data a10_sdmmcecca_data = {\n\t.setup = socfpga_init_sdmmc_ecc,\n\t.ce_clear_mask = ALTR_A10_ECC_SERRPENA,\n\t.ue_clear_mask = ALTR_A10_ECC_DERRPENA,\n\t.ecc_enable_mask = ALTR_A10_COMMON_ECC_EN_CTL,\n\t.ecc_en_ofst = ALTR_A10_ECC_CTRL_OFST,\n\t.ce_set_mask = ALTR_A10_ECC_SERRPENA,\n\t.ue_set_mask = ALTR_A10_ECC_DERRPENA,\n\t.set_err_ofst = ALTR_A10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq,\n\t.inject_fops = &altr_edac_a10_device_inject_fops,\n};\n\nstatic const struct edac_device_prv_data a10_sdmmceccb_data = {\n\t.setup = socfpga_init_sdmmc_ecc,\n\t.ce_clear_mask = ALTR_A10_ECC_SERRPENB,\n\t.ue_clear_mask = ALTR_A10_ECC_DERRPENB,\n\t.ecc_enable_mask = ALTR_A10_COMMON_ECC_EN_CTL,\n\t.ecc_en_ofst = ALTR_A10_ECC_CTRL_OFST,\n\t.ce_set_mask = ALTR_A10_ECC_TSERRB,\n\t.ue_set_mask = ALTR_A10_ECC_TDERRB,\n\t.set_err_ofst = ALTR_A10_ECC_INTTEST_OFST,\n\t.ecc_irq_handler = altr_edac_a10_ecc_irq_portb,\n\t.inject_fops = &altr_edac_a10_device_inject_fops,\n};\n\n#endif\t \n\n \nstatic const struct of_device_id altr_edac_a10_device_of_match[] = {\n#ifdef CONFIG_EDAC_ALTERA_L2C\n\t{ .compatible = \"altr,socfpga-a10-l2-ecc\", .data = &a10_l2ecc_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_OCRAM\n\t{ .compatible = \"altr,socfpga-a10-ocram-ecc\",\n\t  .data = &a10_ocramecc_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_ETHERNET\n\t{ .compatible = \"altr,socfpga-eth-mac-ecc\",\n\t  .data = &a10_enetecc_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_NAND\n\t{ .compatible = \"altr,socfpga-nand-ecc\", .data = &a10_nandecc_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_DMA\n\t{ .compatible = \"altr,socfpga-dma-ecc\", .data = &a10_dmaecc_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_USB\n\t{ .compatible = \"altr,socfpga-usb-ecc\", .data = &a10_usbecc_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_QSPI\n\t{ .compatible = \"altr,socfpga-qspi-ecc\", .data = &a10_qspiecc_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_SDMMC\n\t{ .compatible = \"altr,socfpga-sdmmc-ecc\", .data = &a10_sdmmcecca_data },\n#endif\n#ifdef CONFIG_EDAC_ALTERA_SDRAM\n\t{ .compatible = \"altr,sdram-edac-s10\", .data = &s10_sdramecc_data },\n#endif\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altr_edac_a10_device_of_match);\n\n \n\nstatic ssize_t __maybe_unused\naltr_edac_a10_device_trig(struct file *file, const char __user *user_buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dci = file->private_data;\n\tstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\n\tconst struct edac_device_prv_data *priv = drvdata->data;\n\tvoid __iomem *set_addr = (drvdata->base + priv->set_err_ofst);\n\tunsigned long flags;\n\tu8 trig_type;\n\n\tif (!user_buf || get_user(trig_type, user_buf))\n\t\treturn -EFAULT;\n\n\tlocal_irq_save(flags);\n\tif (trig_type == ALTR_UE_TRIGGER_CHAR)\n\t\twritel(priv->ue_set_mask, set_addr);\n\telse\n\t\twritel(priv->ce_set_mask, set_addr);\n\n\t \n\twmb();\n\tlocal_irq_restore(flags);\n\n\treturn count;\n}\n\n \nstatic ssize_t __maybe_unused\naltr_edac_a10_device_trig2(struct file *file, const char __user *user_buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct edac_device_ctl_info *edac_dci = file->private_data;\n\tstruct altr_edac_device_dev *drvdata = edac_dci->pvt_info;\n\tconst struct edac_device_prv_data *priv = drvdata->data;\n\tvoid __iomem *set_addr = (drvdata->base + priv->set_err_ofst);\n\tunsigned long flags;\n\tu8 trig_type;\n\n\tif (!user_buf || get_user(trig_type, user_buf))\n\t\treturn -EFAULT;\n\n\tlocal_irq_save(flags);\n\tif (trig_type == ALTR_UE_TRIGGER_CHAR) {\n\t\twritel(priv->ue_set_mask, set_addr);\n\t} else {\n\t\t \n\t\twritel(ECC_WORD_WRITE, drvdata->base + ECC_BLK_DBYTECTRL_OFST);\n\t\t \n\t\twritel(0, drvdata->base + ECC_BLK_ADDRESS_OFST);\n\t\t \n\t\twritel(ECC_READ_EDOVR, drvdata->base + ECC_BLK_ACCCTRL_OFST);\n\t\t \n\t\twritel(ECC_XACT_KICK, drvdata->base + ECC_BLK_STARTACC_OFST);\n\t\t \n\t\twritel(readl(drvdata->base + ECC_BLK_RDATA0_OFST) ^ 0x1,\n\t\t       drvdata->base + ECC_BLK_WDATA0_OFST);\n\t\twritel(readl(drvdata->base + ECC_BLK_RDATA1_OFST),\n\t\t       drvdata->base + ECC_BLK_WDATA1_OFST);\n\t\twritel(readl(drvdata->base + ECC_BLK_RDATA2_OFST),\n\t\t       drvdata->base + ECC_BLK_WDATA2_OFST);\n\t\twritel(readl(drvdata->base + ECC_BLK_RDATA3_OFST),\n\t\t       drvdata->base + ECC_BLK_WDATA3_OFST);\n\n\t\t \n\t\twritel(readl(drvdata->base + ECC_BLK_RECC0_OFST),\n\t\t       drvdata->base + ECC_BLK_WECC0_OFST);\n\t\twritel(readl(drvdata->base + ECC_BLK_RECC1_OFST),\n\t\t       drvdata->base + ECC_BLK_WECC1_OFST);\n\t\t \n\t\twritel(ECC_WRITE_EDOVR, drvdata->base + ECC_BLK_ACCCTRL_OFST);\n\t\t \n\t\twritel(ECC_XACT_KICK, drvdata->base + ECC_BLK_STARTACC_OFST);\n\t\t \n\t\twritel(ECC_READ_EDOVR, drvdata->base + ECC_BLK_ACCCTRL_OFST);\n\t\t \n\t\twritel(ECC_XACT_KICK, drvdata->base + ECC_BLK_STARTACC_OFST);\n\t}\n\n\t \n\twmb();\n\tlocal_irq_restore(flags);\n\n\treturn count;\n}\n\nstatic void altr_edac_a10_irq_handler(struct irq_desc *desc)\n{\n\tint dberr, bit, sm_offset, irq_status;\n\tstruct altr_arria10_edac *edac = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint irq = irq_desc_get_irq(desc);\n\tunsigned long bits;\n\n\tdberr = (irq == edac->db_irq) ? 1 : 0;\n\tsm_offset = dberr ? A10_SYSMGR_ECC_INTSTAT_DERR_OFST :\n\t\t\t    A10_SYSMGR_ECC_INTSTAT_SERR_OFST;\n\n\tchained_irq_enter(chip, desc);\n\n\tregmap_read(edac->ecc_mgr_map, sm_offset, &irq_status);\n\n\tbits = irq_status;\n\tfor_each_set_bit(bit, &bits, 32)\n\t\tgeneric_handle_domain_irq(edac->domain, dberr * 32 + bit);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int validate_parent_available(struct device_node *np)\n{\n\tstruct device_node *parent;\n\tint ret = 0;\n\n\t \n\tif (of_device_is_compatible(np, \"altr,sdram-edac-s10\"))\n\t\treturn 0;\n\n\t \n\tparent = of_parse_phandle(np, \"altr,ecc-parent\", 0);\n\tif (parent && !of_device_is_available(parent))\n\t\tret = -ENODEV;\n\n\tof_node_put(parent);\n\treturn ret;\n}\n\nstatic int get_s10_sdram_edac_resource(struct device_node *np,\n\t\t\t\t       struct resource *res)\n{\n\tstruct device_node *parent;\n\tint ret;\n\n\tparent = of_parse_phandle(np, \"altr,sdr-syscon\", 0);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\tret = of_address_to_resource(parent, 0, res);\n\tof_node_put(parent);\n\n\treturn ret;\n}\n\nstatic int altr_edac_a10_device_add(struct altr_arria10_edac *edac,\n\t\t\t\t    struct device_node *np)\n{\n\tstruct edac_device_ctl_info *dci;\n\tstruct altr_edac_device_dev *altdev;\n\tchar *ecc_name = (char *)np->name;\n\tstruct resource res;\n\tint edac_idx;\n\tint rc = 0;\n\tconst struct edac_device_prv_data *prv;\n\t \n\tconst struct of_device_id *pdev_id =\n\t\tof_match_node(altr_edac_a10_device_of_match, np);\n\tif (IS_ERR_OR_NULL(pdev_id))\n\t\treturn -ENODEV;\n\n\t \n\tprv = pdev_id->data;\n\tif (IS_ERR_OR_NULL(prv))\n\t\treturn -ENODEV;\n\n\tif (validate_parent_available(np))\n\t\treturn -ENODEV;\n\n\tif (!devres_open_group(edac->dev, altr_edac_a10_device_add, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (of_device_is_compatible(np, \"altr,sdram-edac-s10\"))\n\t\trc = get_s10_sdram_edac_resource(np, &res);\n\telse\n\t\trc = of_address_to_resource(np, 0, &res);\n\n\tif (rc < 0) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"%s: no resource address\\n\", ecc_name);\n\t\tgoto err_release_group;\n\t}\n\n\tedac_idx = edac_device_alloc_index();\n\tdci = edac_device_alloc_ctl_info(sizeof(*altdev), ecc_name,\n\t\t\t\t\t 1, ecc_name, 1, 0, NULL, 0,\n\t\t\t\t\t edac_idx);\n\n\tif (!dci) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"%s: Unable to allocate EDAC device\\n\", ecc_name);\n\t\trc = -ENOMEM;\n\t\tgoto err_release_group;\n\t}\n\n\taltdev = dci->pvt_info;\n\tdci->dev = edac->dev;\n\taltdev->edac_dev_name = ecc_name;\n\taltdev->edac_idx = edac_idx;\n\taltdev->edac = edac;\n\taltdev->edac_dev = dci;\n\taltdev->data = prv;\n\taltdev->ddev = *edac->dev;\n\tdci->dev = &altdev->ddev;\n\tdci->ctl_name = \"Altera ECC Manager\";\n\tdci->mod_name = ecc_name;\n\tdci->dev_name = ecc_name;\n\n\taltdev->base = devm_ioremap_resource(edac->dev, &res);\n\tif (IS_ERR(altdev->base)) {\n\t\trc = PTR_ERR(altdev->base);\n\t\tgoto err_release_group1;\n\t}\n\n\t \n\tif (altdev->data->setup) {\n\t\trc = altdev->data->setup(altdev);\n\t\tif (rc)\n\t\t\tgoto err_release_group1;\n\t}\n\n\taltdev->sb_irq = irq_of_parse_and_map(np, 0);\n\tif (!altdev->sb_irq) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"Error allocating SBIRQ\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_release_group1;\n\t}\n\trc = devm_request_irq(edac->dev, altdev->sb_irq, prv->ecc_irq_handler,\n\t\t\t      IRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t      ecc_name, altdev);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"No SBERR IRQ resource\\n\");\n\t\tgoto err_release_group1;\n\t}\n\n#ifdef CONFIG_64BIT\n\t \n\trc = of_property_read_u32_index(np, \"interrupts\", 0, &altdev->db_irq);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"Unable to parse DB IRQ index\\n\");\n\t\tgoto err_release_group1;\n\t}\n#else\n\taltdev->db_irq = irq_of_parse_and_map(np, 1);\n\tif (!altdev->db_irq) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"Error allocating DBIRQ\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_release_group1;\n\t}\n\trc = devm_request_irq(edac->dev, altdev->db_irq, prv->ecc_irq_handler,\n\t\t\t      IRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t      ecc_name, altdev);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE, \"No DBERR IRQ resource\\n\");\n\t\tgoto err_release_group1;\n\t}\n#endif\n\n\trc = edac_device_add_device(dci);\n\tif (rc) {\n\t\tdev_err(edac->dev, \"edac_device_add_device failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_release_group1;\n\t}\n\n\taltr_create_edacdev_dbgfs(dci, prv);\n\n\tlist_add(&altdev->next, &edac->a10_ecc_devices);\n\n\tdevres_remove_group(edac->dev, altr_edac_a10_device_add);\n\n\treturn 0;\n\nerr_release_group1:\n\tedac_device_free_ctl_info(dci);\nerr_release_group:\n\tdevres_release_group(edac->dev, NULL);\n\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t    \"%s:Error setting up EDAC device: %d\\n\", ecc_name, rc);\n\n\treturn rc;\n}\n\nstatic void a10_eccmgr_irq_mask(struct irq_data *d)\n{\n\tstruct altr_arria10_edac *edac = irq_data_get_irq_chip_data(d);\n\n\tregmap_write(edac->ecc_mgr_map,\tA10_SYSMGR_ECC_INTMASK_SET_OFST,\n\t\t     BIT(d->hwirq));\n}\n\nstatic void a10_eccmgr_irq_unmask(struct irq_data *d)\n{\n\tstruct altr_arria10_edac *edac = irq_data_get_irq_chip_data(d);\n\n\tregmap_write(edac->ecc_mgr_map,\tA10_SYSMGR_ECC_INTMASK_CLR_OFST,\n\t\t     BIT(d->hwirq));\n}\n\nstatic int a10_eccmgr_irqdomain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\t    irq_hw_number_t hwirq)\n{\n\tstruct altr_arria10_edac *edac = d->host_data;\n\n\tirq_set_chip_and_handler(irq, &edac->irq_chip, handle_simple_irq);\n\tirq_set_chip_data(irq, edac);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops a10_eccmgr_ic_ops = {\n\t.map = a10_eccmgr_irqdomain_map,\n\t.xlate = irq_domain_xlate_twocell,\n};\n\n \n#define to_a10edac(p, m) container_of(p, struct altr_arria10_edac, m)\n\n#ifdef CONFIG_64BIT\n \nextern int panic_timeout;\n\n \nstatic int s10_edac_dberr_handler(struct notifier_block *this,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct altr_arria10_edac *edac = to_a10edac(this, panic_notifier);\n\tint err_addr, dberror;\n\n\tregmap_read(edac->ecc_mgr_map, S10_SYSMGR_ECC_INTSTAT_DERR_OFST,\n\t\t    &dberror);\n\tregmap_write(edac->ecc_mgr_map, S10_SYSMGR_UE_VAL_OFST, dberror);\n\tif (dberror & S10_DBE_IRQ_MASK) {\n\t\tstruct list_head *position;\n\t\tstruct altr_edac_device_dev *ed;\n\t\tstruct arm_smccc_res result;\n\n\t\t \n\t\tlist_for_each(position, &edac->a10_ecc_devices) {\n\t\t\ted = list_entry(position, struct altr_edac_device_dev,\n\t\t\t\t\tnext);\n\t\t\tif (!(BIT(ed->db_irq) & dberror))\n\t\t\t\tcontinue;\n\n\t\t\twritel(ALTR_A10_ECC_DERRPENA,\n\t\t\t       ed->base + ALTR_A10_ECC_INTSTAT_OFST);\n\t\t\terr_addr = readl(ed->base + ALTR_S10_DERR_ADDRA_OFST);\n\t\t\tregmap_write(edac->ecc_mgr_map,\n\t\t\t\t     S10_SYSMGR_UE_ADDR_OFST, err_addr);\n\t\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t\t    \"EDAC: [Fatal DBE on %s @ 0x%08X]\\n\",\n\t\t\t\t    ed->edac_dev_name, err_addr);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tpanic_timeout = 1;\n\t\tarm_smccc_smc(INTEL_SIP_SMC_ECC_DBE, dberror, 0, 0, 0, 0,\n\t\t\t      0, 0, &result);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n#endif\n\n \nstatic int altr_edac_a10_probe(struct platform_device *pdev)\n{\n\tstruct altr_arria10_edac *edac;\n\tstruct device_node *child;\n\n\tedac = devm_kzalloc(&pdev->dev, sizeof(*edac), GFP_KERNEL);\n\tif (!edac)\n\t\treturn -ENOMEM;\n\n\tedac->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, edac);\n\tINIT_LIST_HEAD(&edac->a10_ecc_devices);\n\n\tedac->ecc_mgr_map =\n\t\taltr_sysmgr_regmap_lookup_by_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t     \"altr,sysmgr-syscon\");\n\n\tif (IS_ERR(edac->ecc_mgr_map)) {\n\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t    \"Unable to get syscon altr,sysmgr-syscon\\n\");\n\t\treturn PTR_ERR(edac->ecc_mgr_map);\n\t}\n\n\tedac->irq_chip.name = pdev->dev.of_node->name;\n\tedac->irq_chip.irq_mask = a10_eccmgr_irq_mask;\n\tedac->irq_chip.irq_unmask = a10_eccmgr_irq_unmask;\n\tedac->domain = irq_domain_add_linear(pdev->dev.of_node, 64,\n\t\t\t\t\t     &a10_eccmgr_ic_ops, edac);\n\tif (!edac->domain) {\n\t\tdev_err(&pdev->dev, \"Error adding IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tedac->sb_irq = platform_get_irq(pdev, 0);\n\tif (edac->sb_irq < 0)\n\t\treturn edac->sb_irq;\n\n\tirq_set_chained_handler_and_data(edac->sb_irq,\n\t\t\t\t\t altr_edac_a10_irq_handler,\n\t\t\t\t\t edac);\n\n#ifdef CONFIG_64BIT\n\t{\n\t\tint dberror, err_addr;\n\n\t\tedac->panic_notifier.notifier_call = s10_edac_dberr_handler;\n\t\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t\t       &edac->panic_notifier);\n\n\t\t \n\t\tregmap_read(edac->ecc_mgr_map, S10_SYSMGR_UE_VAL_OFST,\n\t\t\t    &dberror);\n\t\tif (dberror) {\n\t\t\tregmap_read(edac->ecc_mgr_map, S10_SYSMGR_UE_ADDR_OFST,\n\t\t\t\t    &err_addr);\n\t\t\tedac_printk(KERN_ERR, EDAC_DEVICE,\n\t\t\t\t    \"Previous Boot UE detected[0x%X] @ 0x%X\\n\",\n\t\t\t\t    dberror, err_addr);\n\t\t\t \n\t\t\tregmap_write(edac->ecc_mgr_map,\n\t\t\t\t     S10_SYSMGR_UE_VAL_OFST, 0);\n\t\t\tregmap_write(edac->ecc_mgr_map,\n\t\t\t\t     S10_SYSMGR_UE_ADDR_OFST, 0);\n\t\t}\n\t}\n#else\n\tedac->db_irq = platform_get_irq(pdev, 1);\n\tif (edac->db_irq < 0)\n\t\treturn edac->db_irq;\n\n\tirq_set_chained_handler_and_data(edac->db_irq,\n\t\t\t\t\t altr_edac_a10_irq_handler, edac);\n#endif\n\n\tfor_each_child_of_node(pdev->dev.of_node, child) {\n\t\tif (!of_device_is_available(child))\n\t\t\tcontinue;\n\n\t\tif (of_match_node(altr_edac_a10_device_of_match, child))\n\t\t\taltr_edac_a10_device_add(edac, child);\n\n#ifdef CONFIG_EDAC_ALTERA_SDRAM\n\t\telse if (of_device_is_compatible(child, \"altr,sdram-edac-a10\"))\n\t\t\tof_platform_populate(pdev->dev.of_node,\n\t\t\t\t\t     altr_sdram_ctrl_of_match,\n\t\t\t\t\t     NULL, &pdev->dev);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id altr_edac_a10_of_match[] = {\n\t{ .compatible = \"altr,socfpga-a10-ecc-manager\" },\n\t{ .compatible = \"altr,socfpga-s10-ecc-manager\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altr_edac_a10_of_match);\n\nstatic struct platform_driver altr_edac_a10_driver = {\n\t.probe =  altr_edac_a10_probe,\n\t.driver = {\n\t\t.name = \"socfpga_a10_ecc_manager\",\n\t\t.of_match_table = altr_edac_a10_of_match,\n\t},\n};\nmodule_platform_driver(altr_edac_a10_driver);\n\nMODULE_AUTHOR(\"Thor Thayer\");\nMODULE_DESCRIPTION(\"EDAC Driver for Altera Memories\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}