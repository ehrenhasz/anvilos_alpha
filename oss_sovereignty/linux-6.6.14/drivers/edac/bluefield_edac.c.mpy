{
  "module_name": "bluefield_edac.c",
  "hash_id": "ef7c8514b9f4149c6accaf7e46fec61ec36a8e160887aad15a076a889972a13c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/bluefield_edac.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/arm-smccc.h>\n#include <linux/bitfield.h>\n#include <linux/edac.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include \"edac_module.h\"\n\n#define DRIVER_NAME\t\t\"bluefield-edac\"\n\n \n\n#define MLXBF_ECC_CNT 0x340\n#define MLXBF_ECC_CNT__SERR_CNT GENMASK(15, 0)\n#define MLXBF_ECC_CNT__DERR_CNT GENMASK(31, 16)\n\n#define MLXBF_ECC_ERR 0x348\n#define MLXBF_ECC_ERR__SECC BIT(0)\n#define MLXBF_ECC_ERR__DECC BIT(16)\n\n#define MLXBF_ECC_LATCH_SEL 0x354\n#define MLXBF_ECC_LATCH_SEL__START BIT(24)\n\n#define MLXBF_ERR_ADDR_0 0x358\n\n#define MLXBF_ERR_ADDR_1 0x37c\n\n#define MLXBF_SYNDROM 0x35c\n#define MLXBF_SYNDROM__DERR BIT(0)\n#define MLXBF_SYNDROM__SERR BIT(1)\n#define MLXBF_SYNDROM__SYN GENMASK(25, 16)\n\n#define MLXBF_ADD_INFO 0x364\n#define MLXBF_ADD_INFO__ERR_PRANK GENMASK(9, 8)\n\n#define MLXBF_EDAC_MAX_DIMM_PER_MC\t2\n#define MLXBF_EDAC_ERROR_GRAIN\t\t8\n\n \n#define MLNX_SIP_GET_DIMM_INFO\t\t0x82000008\n\n \n#define MLXBF_DIMM_INFO__SIZE_GB GENMASK_ULL(15, 0)\n#define MLXBF_DIMM_INFO__IS_RDIMM BIT(16)\n#define MLXBF_DIMM_INFO__IS_LRDIMM BIT(17)\n#define MLXBF_DIMM_INFO__IS_NVDIMM BIT(18)\n#define MLXBF_DIMM_INFO__RANKS GENMASK_ULL(23, 21)\n#define MLXBF_DIMM_INFO__PACKAGE_X GENMASK_ULL(31, 24)\n\nstruct bluefield_edac_priv {\n\tint dimm_ranks[MLXBF_EDAC_MAX_DIMM_PER_MC];\n\tvoid __iomem *emi_base;\n\tint dimm_per_mc;\n};\n\nstatic u64 smc_call1(u64 smc_op, u64 smc_arg)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(smc_op, smc_arg, 0, 0, 0, 0, 0, 0, &res);\n\n\treturn res.a0;\n}\n\n \nstatic void bluefield_gather_report_ecc(struct mem_ctl_info *mci,\n\t\t\t\t\tint error_cnt,\n\t\t\t\t\tint is_single_ecc)\n{\n\tstruct bluefield_edac_priv *priv = mci->pvt_info;\n\tu32 dram_additional_info, err_prank, edea0, edea1;\n\tu32 ecc_latch_select, dram_syndrom, serr, derr, syndrom;\n\tenum hw_event_mc_err_type ecc_type;\n\tu64 ecc_dimm_addr;\n\tint ecc_dimm;\n\n\tecc_type = is_single_ecc ? HW_EVENT_ERR_CORRECTED :\n\t\t\t\t   HW_EVENT_ERR_UNCORRECTED;\n\n\t \n\tecc_latch_select = MLXBF_ECC_LATCH_SEL__START;\n\twritel(ecc_latch_select, priv->emi_base + MLXBF_ECC_LATCH_SEL);\n\n\t \n\tdram_syndrom = readl(priv->emi_base + MLXBF_SYNDROM);\n\tserr = FIELD_GET(MLXBF_SYNDROM__SERR, dram_syndrom);\n\tderr = FIELD_GET(MLXBF_SYNDROM__DERR, dram_syndrom);\n\tsyndrom = FIELD_GET(MLXBF_SYNDROM__SYN, dram_syndrom);\n\n\tif ((is_single_ecc && !serr) || (!is_single_ecc && !derr)) {\n\t\tedac_mc_handle_error(ecc_type, mci, error_cnt, 0, 0, 0,\n\t\t\t\t     0, 0, -1, mci->ctl_name, \"\");\n\t\treturn;\n\t}\n\n\tdram_additional_info = readl(priv->emi_base + MLXBF_ADD_INFO);\n\terr_prank = FIELD_GET(MLXBF_ADD_INFO__ERR_PRANK, dram_additional_info);\n\n\tecc_dimm = (err_prank >= 2 && priv->dimm_ranks[0] <= 2) ? 1 : 0;\n\n\tedea0 = readl(priv->emi_base + MLXBF_ERR_ADDR_0);\n\tedea1 = readl(priv->emi_base + MLXBF_ERR_ADDR_1);\n\n\tecc_dimm_addr = ((u64)edea1 << 32) | edea0;\n\n\tedac_mc_handle_error(ecc_type, mci, error_cnt,\n\t\t\t     PFN_DOWN(ecc_dimm_addr),\n\t\t\t     offset_in_page(ecc_dimm_addr),\n\t\t\t     syndrom, ecc_dimm, 0, 0, mci->ctl_name, \"\");\n}\n\nstatic void bluefield_edac_check(struct mem_ctl_info *mci)\n{\n\tstruct bluefield_edac_priv *priv = mci->pvt_info;\n\tu32 ecc_count, single_error_count, double_error_count, ecc_error = 0;\n\n\t \n\tif (mci->edac_cap == EDAC_FLAG_NONE)\n\t\treturn;\n\n\tecc_count = readl(priv->emi_base + MLXBF_ECC_CNT);\n\tsingle_error_count = FIELD_GET(MLXBF_ECC_CNT__SERR_CNT, ecc_count);\n\tdouble_error_count = FIELD_GET(MLXBF_ECC_CNT__DERR_CNT, ecc_count);\n\n\tif (single_error_count) {\n\t\tecc_error |= MLXBF_ECC_ERR__SECC;\n\n\t\tbluefield_gather_report_ecc(mci, single_error_count, 1);\n\t}\n\n\tif (double_error_count) {\n\t\tecc_error |= MLXBF_ECC_ERR__DECC;\n\n\t\tbluefield_gather_report_ecc(mci, double_error_count, 0);\n\t}\n\n\t \n\tif (ecc_count)\n\t\twritel(ecc_error, priv->emi_base + MLXBF_ECC_ERR);\n}\n\n \nstatic void bluefield_edac_init_dimms(struct mem_ctl_info *mci)\n{\n\tstruct bluefield_edac_priv *priv = mci->pvt_info;\n\tint mem_ctrl_idx = mci->mc_idx;\n\tstruct dimm_info *dimm;\n\tu64 smc_info, smc_arg;\n\tint is_empty = 1, i;\n\n\tfor (i = 0; i < priv->dimm_per_mc; i++) {\n\t\tdimm = mci->dimms[i];\n\n\t\tsmc_arg = mem_ctrl_idx << 16 | i;\n\t\tsmc_info = smc_call1(MLNX_SIP_GET_DIMM_INFO, smc_arg);\n\n\t\tif (!FIELD_GET(MLXBF_DIMM_INFO__SIZE_GB, smc_info)) {\n\t\t\tdimm->mtype = MEM_EMPTY;\n\t\t\tcontinue;\n\t\t}\n\n\t\tis_empty = 0;\n\n\t\tdimm->edac_mode = EDAC_SECDED;\n\n\t\tif (FIELD_GET(MLXBF_DIMM_INFO__IS_NVDIMM, smc_info))\n\t\t\tdimm->mtype = MEM_NVDIMM;\n\t\telse if (FIELD_GET(MLXBF_DIMM_INFO__IS_LRDIMM, smc_info))\n\t\t\tdimm->mtype = MEM_LRDDR4;\n\t\telse if (FIELD_GET(MLXBF_DIMM_INFO__IS_RDIMM, smc_info))\n\t\t\tdimm->mtype = MEM_RDDR4;\n\t\telse\n\t\t\tdimm->mtype = MEM_DDR4;\n\n\t\tdimm->nr_pages =\n\t\t\tFIELD_GET(MLXBF_DIMM_INFO__SIZE_GB, smc_info) *\n\t\t\t(SZ_1G / PAGE_SIZE);\n\t\tdimm->grain = MLXBF_EDAC_ERROR_GRAIN;\n\n\t\t \n\t\tswitch (FIELD_GET(MLXBF_DIMM_INFO__PACKAGE_X, smc_info)) {\n\t\tcase 4:\n\t\t\tdimm->dtype = DEV_X4;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdimm->dtype = DEV_X8;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tdimm->dtype = DEV_X16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdimm->dtype = DEV_UNKNOWN;\n\t\t}\n\n\t\tpriv->dimm_ranks[i] =\n\t\t\tFIELD_GET(MLXBF_DIMM_INFO__RANKS, smc_info);\n\t}\n\n\tif (is_empty)\n\t\tmci->edac_cap = EDAC_FLAG_NONE;\n\telse\n\t\tmci->edac_cap = EDAC_FLAG_SECDED;\n}\n\nstatic int bluefield_edac_mc_probe(struct platform_device *pdev)\n{\n\tstruct bluefield_edac_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct edac_mc_layer layers[1];\n\tstruct mem_ctl_info *mci;\n\tstruct resource *emi_res;\n\tunsigned int mc_idx, dimm_count;\n\tint rc, ret;\n\n\t \n\tif (device_property_read_u32(dev, \"mss_number\", &mc_idx)) {\n\t\tdev_warn(dev, \"bf_edac: MSS number unknown\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (device_property_read_u32(dev, \"dimm_per_mc\", &dimm_count)) {\n\t\tdev_warn(dev, \"bf_edac: DIMMs per MC unknown\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dimm_count > MLXBF_EDAC_MAX_DIMM_PER_MC) {\n\t\tdev_warn(dev, \"bf_edac: DIMMs per MC not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\temi_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!emi_res)\n\t\treturn -EINVAL;\n\n\tlayers[0].type = EDAC_MC_LAYER_SLOT;\n\tlayers[0].size = dimm_count;\n\tlayers[0].is_virt_csrow = true;\n\n\tmci = edac_mc_alloc(mc_idx, ARRAY_SIZE(layers), layers, sizeof(*priv));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tpriv = mci->pvt_info;\n\n\tpriv->dimm_per_mc = dimm_count;\n\tpriv->emi_base = devm_ioremap_resource(dev, emi_res);\n\tif (IS_ERR(priv->emi_base)) {\n\t\tdev_err(dev, \"failed to map EMI IO resource\\n\");\n\t\tret = PTR_ERR(priv->emi_base);\n\t\tgoto err;\n\t}\n\n\tmci->pdev = dev;\n\tmci->mtype_cap = MEM_FLAG_DDR4 | MEM_FLAG_RDDR4 |\n\t\t\t MEM_FLAG_LRDDR4 | MEM_FLAG_NVDIMM;\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\n\tmci->mod_name = DRIVER_NAME;\n\tmci->ctl_name = \"BlueField_Memory_Controller\";\n\tmci->dev_name = dev_name(dev);\n\tmci->edac_check = bluefield_edac_check;\n\n\t \n\tbluefield_edac_init_dimms(mci);\n\n\tplatform_set_drvdata(pdev, mci);\n\n\t \n\trc = edac_mc_add_mc(mci);\n\tif (rc) {\n\t\tdev_err(dev, \"failed to register with EDAC core\\n\");\n\t\tret = rc;\n\t\tgoto err;\n\t}\n\n\t \n\tedac_op_state = EDAC_OPSTATE_POLL;\n\n\treturn 0;\n\nerr:\n\tedac_mc_free(mci);\n\n\treturn ret;\n\n}\n\nstatic int bluefield_edac_mc_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id bluefield_mc_acpi_ids[] = {\n\t{\"MLNXBF08\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, bluefield_mc_acpi_ids);\n\nstatic struct platform_driver bluefield_edac_mc_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.acpi_match_table = bluefield_mc_acpi_ids,\n\t},\n\t.probe = bluefield_edac_mc_probe,\n\t.remove = bluefield_edac_mc_remove,\n};\n\nmodule_platform_driver(bluefield_edac_mc_driver);\n\nMODULE_DESCRIPTION(\"Mellanox BlueField memory edac driver\");\nMODULE_AUTHOR(\"Mellanox Technologies\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}