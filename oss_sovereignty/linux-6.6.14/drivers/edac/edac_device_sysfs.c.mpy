{
  "module_name": "edac_device_sysfs.c",
  "hash_id": "3edca42b97efe35e4d72bce0a2ddec3697fcbf460b23ce9931a1e6eb66d7242f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_device_sysfs.c",
  "human_readable_source": " \n\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/edac.h>\n\n#include \"edac_device.h\"\n#include \"edac_module.h\"\n\n#define EDAC_DEVICE_SYMLINK\t\"device\"\n\n#define to_edacdev(k) container_of(k, struct edac_device_ctl_info, kobj)\n#define to_edacdev_attr(a) container_of(a, struct edacdev_attribute, attr)\n\n\n \n\n \nstatic ssize_t edac_device_ctl_log_ue_show(struct edac_device_ctl_info\n\t\t\t\t\t*ctl_info, char *data)\n{\n\treturn sprintf(data, \"%u\\n\", ctl_info->log_ue);\n}\n\nstatic ssize_t edac_device_ctl_log_ue_store(struct edac_device_ctl_info\n\t\t\t\t\t*ctl_info, const char *data,\n\t\t\t\t\tsize_t count)\n{\n\t \n\tctl_info->log_ue = (simple_strtoul(data, NULL, 0) != 0);\n\n\treturn count;\n}\n\n \nstatic ssize_t edac_device_ctl_log_ce_show(struct edac_device_ctl_info\n\t\t\t\t\t*ctl_info, char *data)\n{\n\treturn sprintf(data, \"%u\\n\", ctl_info->log_ce);\n}\n\nstatic ssize_t edac_device_ctl_log_ce_store(struct edac_device_ctl_info\n\t\t\t\t\t*ctl_info, const char *data,\n\t\t\t\t\tsize_t count)\n{\n\t \n\tctl_info->log_ce = (simple_strtoul(data, NULL, 0) != 0);\n\n\treturn count;\n}\n\n \nstatic ssize_t edac_device_ctl_panic_on_ue_show(struct edac_device_ctl_info\n\t\t\t\t\t\t*ctl_info, char *data)\n{\n\treturn sprintf(data, \"%u\\n\", ctl_info->panic_on_ue);\n}\n\nstatic ssize_t edac_device_ctl_panic_on_ue_store(struct edac_device_ctl_info\n\t\t\t\t\t\t *ctl_info, const char *data,\n\t\t\t\t\t\t size_t count)\n{\n\t \n\tctl_info->panic_on_ue = (simple_strtoul(data, NULL, 0) != 0);\n\n\treturn count;\n}\n\n \nstatic ssize_t edac_device_ctl_poll_msec_show(struct edac_device_ctl_info\n\t\t\t\t\t*ctl_info, char *data)\n{\n\treturn sprintf(data, \"%u\\n\", ctl_info->poll_msec);\n}\n\nstatic ssize_t edac_device_ctl_poll_msec_store(struct edac_device_ctl_info\n\t\t\t\t\t*ctl_info, const char *data,\n\t\t\t\t\tsize_t count)\n{\n\tunsigned long value;\n\n\t \n\tvalue = simple_strtoul(data, NULL, 0);\n\tedac_device_reset_delay_period(ctl_info, value);\n\n\treturn count;\n}\n\n \nstruct ctl_info_attribute {\n\tstruct attribute attr;\n\tssize_t(*show) (struct edac_device_ctl_info *, char *);\n\tssize_t(*store) (struct edac_device_ctl_info *, const char *, size_t);\n};\n\n#define to_ctl_info(k) container_of(k, struct edac_device_ctl_info, kobj)\n#define to_ctl_info_attr(a) container_of(a,struct ctl_info_attribute,attr)\n\n \nstatic ssize_t edac_dev_ctl_info_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buffer)\n{\n\tstruct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);\n\tstruct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);\n\n\tif (ctl_info_attr->show)\n\t\treturn ctl_info_attr->show(edac_dev, buffer);\n\treturn -EIO;\n}\n\n \nstatic ssize_t edac_dev_ctl_info_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buffer, size_t count)\n{\n\tstruct edac_device_ctl_info *edac_dev = to_ctl_info(kobj);\n\tstruct ctl_info_attribute *ctl_info_attr = to_ctl_info_attr(attr);\n\n\tif (ctl_info_attr->store)\n\t\treturn ctl_info_attr->store(edac_dev, buffer, count);\n\treturn -EIO;\n}\n\n \nstatic const struct sysfs_ops device_ctl_info_ops = {\n\t.show = edac_dev_ctl_info_show,\n\t.store = edac_dev_ctl_info_store\n};\n\n#define CTL_INFO_ATTR(_name,_mode,_show,_store)        \\\nstatic struct ctl_info_attribute attr_ctl_info_##_name = {      \\\n\t.attr = {.name = __stringify(_name), .mode = _mode },   \\\n\t.show   = _show,                                        \\\n\t.store  = _store,                                       \\\n};\n\n \nCTL_INFO_ATTR(log_ue, S_IRUGO | S_IWUSR,\n\tedac_device_ctl_log_ue_show, edac_device_ctl_log_ue_store);\nCTL_INFO_ATTR(log_ce, S_IRUGO | S_IWUSR,\n\tedac_device_ctl_log_ce_show, edac_device_ctl_log_ce_store);\nCTL_INFO_ATTR(panic_on_ue, S_IRUGO | S_IWUSR,\n\tedac_device_ctl_panic_on_ue_show,\n\tedac_device_ctl_panic_on_ue_store);\nCTL_INFO_ATTR(poll_msec, S_IRUGO | S_IWUSR,\n\tedac_device_ctl_poll_msec_show, edac_device_ctl_poll_msec_store);\n\n \nstatic struct attribute *device_ctrl_attrs[] = {\n\t&attr_ctl_info_panic_on_ue.attr,\n\t&attr_ctl_info_log_ue.attr,\n\t&attr_ctl_info_log_ce.attr,\n\t&attr_ctl_info_poll_msec.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(device_ctrl);\n\n \nstatic void edac_device_ctrl_master_release(struct kobject *kobj)\n{\n\tstruct edac_device_ctl_info *edac_dev = to_edacdev(kobj);\n\n\tedac_dbg(4, \"control index=%d\\n\", edac_dev->dev_idx);\n\n\t \n\tmodule_put(edac_dev->owner);\n\n\t__edac_device_free_ctl_info(edac_dev);\n}\n\n \nstatic struct kobj_type ktype_device_ctrl = {\n\t.release = edac_device_ctrl_master_release,\n\t.sysfs_ops = &device_ctl_info_ops,\n\t.default_groups = device_ctrl_groups,\n};\n\n \nint edac_device_register_sysfs_main_kobj(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct device *dev_root;\n\tstruct bus_type *edac_subsys;\n\tint err = -ENODEV;\n\n\tedac_dbg(1, \"\\n\");\n\n\t \n\tedac_subsys = edac_get_sysfs_subsys();\n\n\t \n\tedac_dev->edac_subsys = edac_subsys;\n\n\t \n\tmemset(&edac_dev->kobj, 0, sizeof(struct kobject));\n\n\t \n\tedac_dev->owner = THIS_MODULE;\n\n\tif (!try_module_get(edac_dev->owner))\n\t\tgoto err_out;\n\n\t \n\tdev_root = bus_get_dev_root(edac_subsys);\n\tif (dev_root) {\n\t\terr = kobject_init_and_add(&edac_dev->kobj, &ktype_device_ctrl,\n\t\t\t\t\t   &dev_root->kobj, \"%s\", edac_dev->name);\n\t\tput_device(dev_root);\n\t}\n\tif (err) {\n\t\tedac_dbg(1, \"Failed to register '.../edac/%s'\\n\",\n\t\t\t edac_dev->name);\n\t\tgoto err_kobj_reg;\n\t}\n\tkobject_uevent(&edac_dev->kobj, KOBJ_ADD);\n\n\t \n\n\tedac_dbg(4, \"Registered '.../edac/%s' kobject\\n\", edac_dev->name);\n\n\treturn 0;\n\n\t \nerr_kobj_reg:\n\tkobject_put(&edac_dev->kobj);\n\tmodule_put(edac_dev->owner);\n\nerr_out:\n\treturn err;\n}\n\n \nvoid edac_device_unregister_sysfs_main_kobj(struct edac_device_ctl_info *dev)\n{\n\tedac_dbg(0, \"\\n\");\n\tedac_dbg(4, \"name of kobject is: %s\\n\", kobject_name(&dev->kobj));\n\n\t \n\tkobject_put(&dev->kobj);\n}\n\n \n\n \nstatic ssize_t instance_ue_count_show(struct edac_device_instance *instance,\n\t\t\t\tchar *data)\n{\n\treturn sprintf(data, \"%u\\n\", instance->counters.ue_count);\n}\n\nstatic ssize_t instance_ce_count_show(struct edac_device_instance *instance,\n\t\t\t\tchar *data)\n{\n\treturn sprintf(data, \"%u\\n\", instance->counters.ce_count);\n}\n\n#define to_instance(k) container_of(k, struct edac_device_instance, kobj)\n#define to_instance_attr(a) container_of(a,struct instance_attribute,attr)\n\n \nstatic void edac_device_ctrl_instance_release(struct kobject *kobj)\n{\n\tstruct edac_device_instance *instance;\n\n\tedac_dbg(1, \"\\n\");\n\n\t \n\tinstance = to_instance(kobj);\n\tkobject_put(&instance->ctl->kobj);\n}\n\n \nstruct instance_attribute {\n\tstruct attribute attr;\n\tssize_t(*show) (struct edac_device_instance *, char *);\n\tssize_t(*store) (struct edac_device_instance *, const char *, size_t);\n};\n\n \nstatic ssize_t edac_dev_instance_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buffer)\n{\n\tstruct edac_device_instance *instance = to_instance(kobj);\n\tstruct instance_attribute *instance_attr = to_instance_attr(attr);\n\n\tif (instance_attr->show)\n\t\treturn instance_attr->show(instance, buffer);\n\treturn -EIO;\n}\n\n \nstatic ssize_t edac_dev_instance_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buffer, size_t count)\n{\n\tstruct edac_device_instance *instance = to_instance(kobj);\n\tstruct instance_attribute *instance_attr = to_instance_attr(attr);\n\n\tif (instance_attr->store)\n\t\treturn instance_attr->store(instance, buffer, count);\n\treturn -EIO;\n}\n\n \nstatic const struct sysfs_ops device_instance_ops = {\n\t.show = edac_dev_instance_show,\n\t.store = edac_dev_instance_store\n};\n\n#define INSTANCE_ATTR(_name,_mode,_show,_store)        \\\nstatic struct instance_attribute attr_instance_##_name = {      \\\n\t.attr = {.name = __stringify(_name), .mode = _mode },   \\\n\t.show   = _show,                                        \\\n\t.store  = _store,                                       \\\n};\n\n \nINSTANCE_ATTR(ce_count, S_IRUGO, instance_ce_count_show, NULL);\nINSTANCE_ATTR(ue_count, S_IRUGO, instance_ue_count_show, NULL);\n\n \nstatic struct attribute *device_instance_attrs[] = {\n\t&attr_instance_ce_count.attr,\n\t&attr_instance_ue_count.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(device_instance);\n\n \nstatic struct kobj_type ktype_instance_ctrl = {\n\t.release = edac_device_ctrl_instance_release,\n\t.sysfs_ops = &device_instance_ops,\n\t.default_groups = device_instance_groups,\n};\n\n \n\n#define to_block(k) container_of(k, struct edac_device_block, kobj)\n#define to_block_attr(a) \\\n\tcontainer_of(a, struct edac_dev_sysfs_block_attribute, attr)\n\n \nstatic ssize_t block_ue_count_show(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, char *data)\n{\n\tstruct edac_device_block *block = to_block(kobj);\n\n\treturn sprintf(data, \"%u\\n\", block->counters.ue_count);\n}\n\nstatic ssize_t block_ce_count_show(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, char *data)\n{\n\tstruct edac_device_block *block = to_block(kobj);\n\n\treturn sprintf(data, \"%u\\n\", block->counters.ce_count);\n}\n\n \nstatic void edac_device_ctrl_block_release(struct kobject *kobj)\n{\n\tstruct edac_device_block *block;\n\n\tedac_dbg(1, \"\\n\");\n\n\t \n\tblock = to_block(kobj);\n\n\t \n\tkobject_put(&block->instance->ctl->kobj);\n}\n\n\n \nstatic ssize_t edac_dev_block_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buffer)\n{\n\tstruct edac_dev_sysfs_block_attribute *block_attr =\n\t\t\t\t\t\tto_block_attr(attr);\n\n\tif (block_attr->show)\n\t\treturn block_attr->show(kobj, attr, buffer);\n\treturn -EIO;\n}\n\n \nstatic ssize_t edac_dev_block_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buffer, size_t count)\n{\n\tstruct edac_dev_sysfs_block_attribute *block_attr;\n\n\tblock_attr = to_block_attr(attr);\n\n\tif (block_attr->store)\n\t\treturn block_attr->store(kobj, attr, buffer, count);\n\treturn -EIO;\n}\n\n \nstatic const struct sysfs_ops device_block_ops = {\n\t.show = edac_dev_block_show,\n\t.store = edac_dev_block_store\n};\n\n#define BLOCK_ATTR(_name,_mode,_show,_store)        \\\nstatic struct edac_dev_sysfs_block_attribute attr_block_##_name = {\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },   \\\n\t.show   = _show,                                        \\\n\t.store  = _store,                                       \\\n};\n\nBLOCK_ATTR(ce_count, S_IRUGO, block_ce_count_show, NULL);\nBLOCK_ATTR(ue_count, S_IRUGO, block_ue_count_show, NULL);\n\n \nstatic struct attribute *device_block_attrs[] = {\n\t&attr_block_ce_count.attr,\n\t&attr_block_ue_count.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(device_block);\n\n \nstatic struct kobj_type ktype_block_ctrl = {\n\t.release = edac_device_ctrl_block_release,\n\t.sysfs_ops = &device_block_ops,\n\t.default_groups = device_block_groups,\n};\n\n \n\n \nstatic int edac_device_create_block(struct edac_device_ctl_info *edac_dev,\n\t\t\t\tstruct edac_device_instance *instance,\n\t\t\t\tstruct edac_device_block *block)\n{\n\tint i;\n\tint err;\n\tstruct edac_dev_sysfs_block_attribute *sysfs_attrib;\n\tstruct kobject *main_kobj;\n\n\tedac_dbg(4, \"Instance '%s' inst_p=%p  block '%s'  block_p=%p\\n\",\n\t\t instance->name, instance, block->name, block);\n\tedac_dbg(4, \"block kobj=%p  block kobj->parent=%p\\n\",\n\t\t &block->kobj, &block->kobj.parent);\n\n\t \n\tmemset(&block->kobj, 0, sizeof(struct kobject));\n\n\t \n\tmain_kobj = kobject_get(&edac_dev->kobj);\n\tif (!main_kobj) {\n\t\terr = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\terr = kobject_init_and_add(&block->kobj, &ktype_block_ctrl,\n\t\t\t\t   &instance->kobj,\n\t\t\t\t   \"%s\", block->name);\n\tif (err) {\n\t\tedac_dbg(1, \"Failed to register instance '%s'\\n\", block->name);\n\t\tkobject_put(main_kobj);\n\t\terr = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\tsysfs_attrib = block->block_attributes;\n\tif (sysfs_attrib && block->nr_attribs) {\n\t\tfor (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {\n\n\t\t\tedac_dbg(4, \"creating block attrib='%s' attrib->%p to kobj=%p\\n\",\n\t\t\t\t sysfs_attrib->attr.name,\n\t\t\t\t sysfs_attrib, &block->kobj);\n\n\t\t\t \n\t\t\terr = sysfs_create_file(&block->kobj,\n\t\t\t\t&sysfs_attrib->attr);\n\t\t\tif (err)\n\t\t\t\tgoto err_on_attrib;\n\t\t}\n\t}\n\tkobject_uevent(&block->kobj, KOBJ_ADD);\n\n\treturn 0;\n\n\t \nerr_on_attrib:\n\tkobject_put(&block->kobj);\n\nerr_out:\n\treturn err;\n}\n\n \nstatic void edac_device_delete_block(struct edac_device_ctl_info *edac_dev,\n\t\t\t\tstruct edac_device_block *block)\n{\n\tstruct edac_dev_sysfs_block_attribute *sysfs_attrib;\n\tint i;\n\n\t \n\tsysfs_attrib = block->block_attributes;\n\tif (sysfs_attrib && block->nr_attribs) {\n\t\tfor (i = 0; i < block->nr_attribs; i++, sysfs_attrib++) {\n\n\t\t\t \n\t\t\tsysfs_remove_file(&block->kobj,\n\t\t\t\t(struct attribute *) sysfs_attrib);\n\t\t}\n\t}\n\n\t \n\tkobject_put(&block->kobj);\n}\n\n \n\n \nstatic int edac_device_create_instance(struct edac_device_ctl_info *edac_dev,\n\t\t\t\tint idx)\n{\n\tint i, j;\n\tint err;\n\tstruct edac_device_instance *instance;\n\tstruct kobject *main_kobj;\n\n\tinstance = &edac_dev->instances[idx];\n\n\t \n\tmemset(&instance->kobj, 0, sizeof(struct kobject));\n\n\tinstance->ctl = edac_dev;\n\n\t \n\tmain_kobj = kobject_get(&edac_dev->kobj);\n\tif (!main_kobj) {\n\t\terr = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\t \n\terr = kobject_init_and_add(&instance->kobj, &ktype_instance_ctrl,\n\t\t\t\t   &edac_dev->kobj, \"%s\", instance->name);\n\tif (err != 0) {\n\t\tedac_dbg(2, \"Failed to register instance '%s'\\n\",\n\t\t\t instance->name);\n\t\tkobject_put(main_kobj);\n\t\tgoto err_out;\n\t}\n\n\tedac_dbg(4, \"now register '%d' blocks for instance %d\\n\",\n\t\t instance->nr_blocks, idx);\n\n\t \n\tfor (i = 0; i < instance->nr_blocks; i++) {\n\t\terr = edac_device_create_block(edac_dev, instance,\n\t\t\t\t\t\t&instance->blocks[i]);\n\t\tif (err) {\n\t\t\t \n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tedac_device_delete_block(edac_dev,\n\t\t\t\t\t\t\t&instance->blocks[j]);\n\t\t\tgoto err_release_instance_kobj;\n\t\t}\n\t}\n\tkobject_uevent(&instance->kobj, KOBJ_ADD);\n\n\tedac_dbg(4, \"Registered instance %d '%s' kobject\\n\",\n\t\t idx, instance->name);\n\n\treturn 0;\n\n\t \nerr_release_instance_kobj:\n\tkobject_put(&instance->kobj);\n\nerr_out:\n\treturn err;\n}\n\n \nstatic void edac_device_delete_instance(struct edac_device_ctl_info *edac_dev,\n\t\t\t\t\tint idx)\n{\n\tstruct edac_device_instance *instance;\n\tint i;\n\n\tinstance = &edac_dev->instances[idx];\n\n\t \n\tfor (i = 0; i < instance->nr_blocks; i++)\n\t\tedac_device_delete_block(edac_dev, &instance->blocks[i]);\n\n\t \n\tkobject_put(&instance->kobj);\n}\n\n \nstatic int edac_device_create_instances(struct edac_device_ctl_info *edac_dev)\n{\n\tint i, j;\n\tint err;\n\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tfor (i = 0; i < edac_dev->nr_instances; i++) {\n\t\terr = edac_device_create_instance(edac_dev, i);\n\t\tif (err) {\n\t\t\t \n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tedac_device_delete_instance(edac_dev, j);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void edac_device_delete_instances(struct edac_device_ctl_info *edac_dev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < edac_dev->nr_instances; i++)\n\t\tedac_device_delete_instance(edac_dev, i);\n}\n\n \n\n \nstatic int edac_device_add_main_sysfs_attributes(\n\t\t\tstruct edac_device_ctl_info *edac_dev)\n{\n\tstruct edac_dev_sysfs_attribute *sysfs_attrib;\n\tint err = 0;\n\n\tsysfs_attrib = edac_dev->sysfs_attributes;\n\tif (sysfs_attrib) {\n\t\t \n\t\twhile (sysfs_attrib->attr.name != NULL) {\n\t\t\terr = sysfs_create_file(&edac_dev->kobj,\n\t\t\t\t(struct attribute*) sysfs_attrib);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\tsysfs_attrib++;\n\t\t}\n\t}\n\nerr_out:\n\treturn err;\n}\n\n \nstatic void edac_device_remove_main_sysfs_attributes(\n\t\t\tstruct edac_device_ctl_info *edac_dev)\n{\n\tstruct edac_dev_sysfs_attribute *sysfs_attrib;\n\n\t \n\tsysfs_attrib = edac_dev->sysfs_attributes;\n\tif (sysfs_attrib) {\n\t\twhile (sysfs_attrib->attr.name != NULL) {\n\t\t\tsysfs_remove_file(&edac_dev->kobj,\n\t\t\t\t\t(struct attribute *) sysfs_attrib);\n\t\t\tsysfs_attrib++;\n\t\t}\n\t}\n}\n\n \nint edac_device_create_sysfs(struct edac_device_ctl_info *edac_dev)\n{\n\tint err;\n\tstruct kobject *edac_kobj = &edac_dev->kobj;\n\n\tedac_dbg(0, \"idx=%d\\n\", edac_dev->dev_idx);\n\n\t \n\terr = edac_device_add_main_sysfs_attributes(edac_dev);\n\tif (err) {\n\t\tedac_dbg(0, \"failed to add sysfs attribs\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\terr = sysfs_create_link(edac_kobj,\n\t\t\t\t&edac_dev->dev->kobj, EDAC_DEVICE_SYMLINK);\n\tif (err) {\n\t\tedac_dbg(0, \"sysfs_create_link() returned err= %d\\n\", err);\n\t\tgoto err_remove_main_attribs;\n\t}\n\n\t \n\terr = edac_device_create_instances(edac_dev);\n\tif (err) {\n\t\tedac_dbg(0, \"edac_device_create_instances() returned err= %d\\n\",\n\t\t\t err);\n\t\tgoto err_remove_link;\n\t}\n\n\n\tedac_dbg(4, \"create-instances done, idx=%d\\n\", edac_dev->dev_idx);\n\n\treturn 0;\n\n\t \nerr_remove_link:\n\t \n\tsysfs_remove_link(&edac_dev->kobj, EDAC_DEVICE_SYMLINK);\n\nerr_remove_main_attribs:\n\tedac_device_remove_main_sysfs_attributes(edac_dev);\n\nerr_out:\n\treturn err;\n}\n\n \nvoid edac_device_remove_sysfs(struct edac_device_ctl_info *edac_dev)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tedac_device_remove_main_sysfs_attributes(edac_dev);\n\n\t \n\tsysfs_remove_link(&edac_dev->kobj, EDAC_DEVICE_SYMLINK);\n\n\t \n\tedac_device_delete_instances(edac_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}