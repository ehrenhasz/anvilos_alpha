{
  "module_name": "al_mc_edac.c",
  "hash_id": "09ac741ef0923148073800cf2fd578e374820d4a20bf09903e515f283dbe0f50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/al_mc_edac.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/edac.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include \"edac_module.h\"\n\n \n#define AL_MC_ECC_CFG\t\t0x70\n#define AL_MC_ECC_CLEAR\t\t0x7c\n#define AL_MC_ECC_ERR_COUNT\t0x80\n#define AL_MC_ECC_CE_ADDR0\t0x84\n#define AL_MC_ECC_CE_ADDR1\t0x88\n#define AL_MC_ECC_UE_ADDR0\t0xa4\n#define AL_MC_ECC_UE_ADDR1\t0xa8\n#define AL_MC_ECC_CE_SYND0\t0x8c\n#define AL_MC_ECC_CE_SYND1\t0x90\n#define AL_MC_ECC_CE_SYND2\t0x94\n#define AL_MC_ECC_UE_SYND0\t0xac\n#define AL_MC_ECC_UE_SYND1\t0xb0\n#define AL_MC_ECC_UE_SYND2\t0xb4\n\n \n#define AL_MC_ECC_CFG_SCRUB_DISABLED\tBIT(4)\n\n#define AL_MC_ECC_CLEAR_UE_COUNT\tBIT(3)\n#define AL_MC_ECC_CLEAR_CE_COUNT\tBIT(2)\n#define AL_MC_ECC_CLEAR_UE_ERR\t\tBIT(1)\n#define AL_MC_ECC_CLEAR_CE_ERR\t\tBIT(0)\n\n#define AL_MC_ECC_ERR_COUNT_UE\t\tGENMASK(31, 16)\n#define AL_MC_ECC_ERR_COUNT_CE\t\tGENMASK(15, 0)\n\n#define AL_MC_ECC_CE_ADDR0_RANK\t\tGENMASK(25, 24)\n#define AL_MC_ECC_CE_ADDR0_ROW\t\tGENMASK(17, 0)\n\n#define AL_MC_ECC_CE_ADDR1_BG\t\tGENMASK(25, 24)\n#define AL_MC_ECC_CE_ADDR1_BANK\t\tGENMASK(18, 16)\n#define AL_MC_ECC_CE_ADDR1_COLUMN\tGENMASK(11, 0)\n\n#define AL_MC_ECC_UE_ADDR0_RANK\t\tGENMASK(25, 24)\n#define AL_MC_ECC_UE_ADDR0_ROW\t\tGENMASK(17, 0)\n\n#define AL_MC_ECC_UE_ADDR1_BG\t\tGENMASK(25, 24)\n#define AL_MC_ECC_UE_ADDR1_BANK\t\tGENMASK(18, 16)\n#define AL_MC_ECC_UE_ADDR1_COLUMN\tGENMASK(11, 0)\n\n#define DRV_NAME \"al_mc_edac\"\n#define AL_MC_EDAC_MSG_MAX 256\n\nstruct al_mc_edac {\n\tvoid __iomem *mmio_base;\n\tspinlock_t lock;\n\tint irq_ce;\n\tint irq_ue;\n};\n\nstatic void prepare_msg(char *message, size_t buffer_size,\n\t\t\tenum hw_event_mc_err_type type,\n\t\t\tu8 rank, u32 row, u8 bg, u8 bank, u16 column,\n\t\t\tu32 syn0, u32 syn1, u32 syn2)\n{\n\tsnprintf(message, buffer_size,\n\t\t \"%s rank=0x%x row=0x%x bg=0x%x bank=0x%x col=0x%x syn0: 0x%x syn1: 0x%x syn2: 0x%x\",\n\t\t type == HW_EVENT_ERR_UNCORRECTED ? \"UE\" : \"CE\",\n\t\t rank, row, bg, bank, column, syn0, syn1, syn2);\n}\n\nstatic int handle_ce(struct mem_ctl_info *mci)\n{\n\tu32 eccerrcnt, ecccaddr0, ecccaddr1, ecccsyn0, ecccsyn1, ecccsyn2, row;\n\tstruct al_mc_edac *al_mc = mci->pvt_info;\n\tchar msg[AL_MC_EDAC_MSG_MAX];\n\tu16 ce_count, column;\n\tunsigned long flags;\n\tu8 rank, bg, bank;\n\n\teccerrcnt = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_ERR_COUNT);\n\tce_count = FIELD_GET(AL_MC_ECC_ERR_COUNT_CE, eccerrcnt);\n\tif (!ce_count)\n\t\treturn 0;\n\n\tecccaddr0 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_CE_ADDR0);\n\tecccaddr1 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_CE_ADDR1);\n\tecccsyn0 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_CE_SYND0);\n\tecccsyn1 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_CE_SYND1);\n\tecccsyn2 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_CE_SYND2);\n\n\twritel_relaxed(AL_MC_ECC_CLEAR_CE_COUNT | AL_MC_ECC_CLEAR_CE_ERR,\n\t\t       al_mc->mmio_base + AL_MC_ECC_CLEAR);\n\n\tdev_dbg(mci->pdev, \"eccuaddr0=0x%08x eccuaddr1=0x%08x\\n\",\n\t\tecccaddr0, ecccaddr1);\n\n\trank = FIELD_GET(AL_MC_ECC_CE_ADDR0_RANK, ecccaddr0);\n\trow = FIELD_GET(AL_MC_ECC_CE_ADDR0_ROW, ecccaddr0);\n\n\tbg = FIELD_GET(AL_MC_ECC_CE_ADDR1_BG, ecccaddr1);\n\tbank = FIELD_GET(AL_MC_ECC_CE_ADDR1_BANK, ecccaddr1);\n\tcolumn = FIELD_GET(AL_MC_ECC_CE_ADDR1_COLUMN, ecccaddr1);\n\n\tprepare_msg(msg, sizeof(msg), HW_EVENT_ERR_CORRECTED,\n\t\t    rank, row, bg, bank, column,\n\t\t    ecccsyn0, ecccsyn1, ecccsyn2);\n\n\tspin_lock_irqsave(&al_mc->lock, flags);\n\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci,\n\t\t\t     ce_count, 0, 0, 0, 0, 0, -1, mci->ctl_name, msg);\n\tspin_unlock_irqrestore(&al_mc->lock, flags);\n\n\treturn ce_count;\n}\n\nstatic int handle_ue(struct mem_ctl_info *mci)\n{\n\tu32 eccerrcnt, eccuaddr0, eccuaddr1, eccusyn0, eccusyn1, eccusyn2, row;\n\tstruct al_mc_edac *al_mc = mci->pvt_info;\n\tchar msg[AL_MC_EDAC_MSG_MAX];\n\tu16 ue_count, column;\n\tunsigned long flags;\n\tu8 rank, bg, bank;\n\n\teccerrcnt = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_ERR_COUNT);\n\tue_count = FIELD_GET(AL_MC_ECC_ERR_COUNT_UE, eccerrcnt);\n\tif (!ue_count)\n\t\treturn 0;\n\n\teccuaddr0 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_UE_ADDR0);\n\teccuaddr1 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_UE_ADDR1);\n\teccusyn0 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_UE_SYND0);\n\teccusyn1 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_UE_SYND1);\n\teccusyn2 = readl_relaxed(al_mc->mmio_base + AL_MC_ECC_UE_SYND2);\n\n\twritel_relaxed(AL_MC_ECC_CLEAR_UE_COUNT | AL_MC_ECC_CLEAR_UE_ERR,\n\t\t       al_mc->mmio_base + AL_MC_ECC_CLEAR);\n\n\tdev_dbg(mci->pdev, \"eccuaddr0=0x%08x eccuaddr1=0x%08x\\n\",\n\t\teccuaddr0, eccuaddr1);\n\n\trank = FIELD_GET(AL_MC_ECC_UE_ADDR0_RANK, eccuaddr0);\n\trow = FIELD_GET(AL_MC_ECC_UE_ADDR0_ROW, eccuaddr0);\n\n\tbg = FIELD_GET(AL_MC_ECC_UE_ADDR1_BG, eccuaddr1);\n\tbank = FIELD_GET(AL_MC_ECC_UE_ADDR1_BANK, eccuaddr1);\n\tcolumn = FIELD_GET(AL_MC_ECC_UE_ADDR1_COLUMN, eccuaddr1);\n\n\tprepare_msg(msg, sizeof(msg), HW_EVENT_ERR_UNCORRECTED,\n\t\t    rank, row, bg, bank, column,\n\t\t    eccusyn0, eccusyn1, eccusyn2);\n\n\tspin_lock_irqsave(&al_mc->lock, flags);\n\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci,\n\t\t\t     ue_count, 0, 0, 0, 0, 0, -1, mci->ctl_name, msg);\n\tspin_unlock_irqrestore(&al_mc->lock, flags);\n\n\treturn ue_count;\n}\n\nstatic void al_mc_edac_check(struct mem_ctl_info *mci)\n{\n\tstruct al_mc_edac *al_mc = mci->pvt_info;\n\n\tif (al_mc->irq_ue <= 0)\n\t\thandle_ue(mci);\n\n\tif (al_mc->irq_ce <= 0)\n\t\thandle_ce(mci);\n}\n\nstatic irqreturn_t al_mc_edac_irq_handler_ue(int irq, void *info)\n{\n\tstruct platform_device *pdev = info;\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\tif (handle_ue(mci))\n\t\treturn IRQ_HANDLED;\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t al_mc_edac_irq_handler_ce(int irq, void *info)\n{\n\tstruct platform_device *pdev = info;\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\tif (handle_ce(mci))\n\t\treturn IRQ_HANDLED;\n\treturn IRQ_NONE;\n}\n\nstatic enum scrub_type get_scrub_mode(void __iomem *mmio_base)\n{\n\tu32 ecccfg0;\n\n\tecccfg0 = readl(mmio_base + AL_MC_ECC_CFG);\n\n\tif (FIELD_GET(AL_MC_ECC_CFG_SCRUB_DISABLED, ecccfg0))\n\t\treturn SCRUB_NONE;\n\telse\n\t\treturn SCRUB_HW_SRC;\n}\n\nstatic void devm_al_mc_edac_free(void *data)\n{\n\tedac_mc_free(data);\n}\n\nstatic void devm_al_mc_edac_del(void *data)\n{\n\tedac_mc_del_mc(data);\n}\n\nstatic int al_mc_edac_probe(struct platform_device *pdev)\n{\n\tstruct edac_mc_layer layers[1];\n\tstruct mem_ctl_info *mci;\n\tstruct al_mc_edac *al_mc;\n\tvoid __iomem *mmio_base;\n\tstruct dimm_info *dimm;\n\tint ret;\n\n\tmmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mmio_base)) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap memory (%ld)\\n\",\n\t\t\tPTR_ERR(mmio_base));\n\t\treturn PTR_ERR(mmio_base);\n\t}\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = 1;\n\tlayers[0].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct al_mc_edac));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tret = devm_add_action_or_reset(&pdev->dev, devm_al_mc_edac_free, mci);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, mci);\n\tal_mc = mci->pvt_info;\n\n\tal_mc->mmio_base = mmio_base;\n\n\tal_mc->irq_ue = of_irq_get_byname(pdev->dev.of_node, \"ue\");\n\tif (al_mc->irq_ue <= 0)\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"no IRQ defined for UE - falling back to polling\\n\");\n\n\tal_mc->irq_ce = of_irq_get_byname(pdev->dev.of_node, \"ce\");\n\tif (al_mc->irq_ce <= 0)\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"no IRQ defined for CE - falling back to polling\\n\");\n\n\t \n\tif (al_mc->irq_ue <= 0 || al_mc->irq_ce <= 0) {\n\t\tedac_op_state = EDAC_OPSTATE_POLL;\n\t\tmci->edac_check = al_mc_edac_check;\n\t} else {\n\t\tedac_op_state = EDAC_OPSTATE_INT;\n\t}\n\n\tspin_lock_init(&al_mc->lock);\n\n\tmci->mtype_cap = MEM_FLAG_DDR3 | MEM_FLAG_DDR4;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = DRV_NAME;\n\tmci->ctl_name = \"al_mc\";\n\tmci->pdev = &pdev->dev;\n\tmci->scrub_mode = get_scrub_mode(mmio_base);\n\n\tdimm = *mci->dimms;\n\tdimm->grain = 1;\n\n\tret = edac_mc_add_mc(mci);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"fail to add memory controller device (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&pdev->dev, devm_al_mc_edac_del, &pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (al_mc->irq_ue > 0) {\n\t\tret = devm_request_irq(&pdev->dev,\n\t\t\t\t       al_mc->irq_ue,\n\t\t\t\t       al_mc_edac_irq_handler_ue,\n\t\t\t\t       IRQF_SHARED,\n\t\t\t\t       pdev->name,\n\t\t\t\t       pdev);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to request UE IRQ %d (%d)\\n\",\n\t\t\t\tal_mc->irq_ue, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (al_mc->irq_ce > 0) {\n\t\tret = devm_request_irq(&pdev->dev,\n\t\t\t\t       al_mc->irq_ce,\n\t\t\t\t       al_mc_edac_irq_handler_ce,\n\t\t\t\t       IRQF_SHARED,\n\t\t\t\t       pdev->name,\n\t\t\t\t       pdev);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to request CE IRQ %d (%d)\\n\",\n\t\t\t\tal_mc->irq_ce, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id al_mc_edac_of_match[] = {\n\t{ .compatible = \"amazon,al-mc-edac\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, al_mc_edac_of_match);\n\nstatic struct platform_driver al_mc_edac_driver = {\n\t.probe = al_mc_edac_probe,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = al_mc_edac_of_match,\n\t},\n};\n\nmodule_platform_driver(al_mc_edac_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Talel Shenhar\");\nMODULE_DESCRIPTION(\"Amazon's Annapurna Lab's Memory Controller EDAC Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}