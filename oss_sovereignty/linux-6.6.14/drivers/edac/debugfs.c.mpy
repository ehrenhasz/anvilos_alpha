{
  "module_name": "debugfs.c",
  "hash_id": "0c411db2ac2f69d68fc87d3bc3b7bc7e6b5e6161ab6c6badc0aac3ac5b305b57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/debugfs.c",
  "human_readable_source": "\n#include \"edac_module.h\"\n\nstatic struct dentry *edac_debugfs;\n\nstatic ssize_t edac_fake_inject_write(struct file *file,\n\t\t\t\t      const char __user *data,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct device *dev = file->private_data;\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstatic enum hw_event_mc_err_type type;\n\tu16 errcount = mci->fake_inject_count;\n\n\tif (!errcount)\n\t\terrcount = 1;\n\n\ttype = mci->fake_inject_ue ? HW_EVENT_ERR_UNCORRECTED\n\t\t\t\t   : HW_EVENT_ERR_CORRECTED;\n\n\tprintk(KERN_DEBUG\n\t       \"Generating %d %s fake error%s to %d.%d.%d to test core handling. NOTE: this won't test the driver-specific decoding logic.\\n\",\n\t\terrcount,\n\t\t(type == HW_EVENT_ERR_UNCORRECTED) ? \"UE\" : \"CE\",\n\t\terrcount > 1 ? \"s\" : \"\",\n\t\tmci->fake_inject_layer[0],\n\t\tmci->fake_inject_layer[1],\n\t\tmci->fake_inject_layer[2]\n\t       );\n\tedac_mc_handle_error(type, mci, errcount, 0, 0, 0,\n\t\t\t     mci->fake_inject_layer[0],\n\t\t\t     mci->fake_inject_layer[1],\n\t\t\t     mci->fake_inject_layer[2],\n\t\t\t     \"FAKE ERROR\", \"for EDAC testing only\");\n\n\treturn count;\n}\n\nstatic const struct file_operations debug_fake_inject_fops = {\n\t.open = simple_open,\n\t.write = edac_fake_inject_write,\n\t.llseek = generic_file_llseek,\n};\n\nvoid __init edac_debugfs_init(void)\n{\n\tedac_debugfs = debugfs_create_dir(\"edac\", NULL);\n}\n\nvoid edac_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(edac_debugfs);\n}\n\nvoid edac_create_debugfs_nodes(struct mem_ctl_info *mci)\n{\n\tstruct dentry *parent;\n\tchar name[80];\n\tint i;\n\n\tparent = debugfs_create_dir(mci->dev.kobj.name, edac_debugfs);\n\n\tfor (i = 0; i < mci->n_layers; i++) {\n\t\tsprintf(name, \"fake_inject_%s\",\n\t\t\t     edac_layer_name[mci->layers[i].type]);\n\t\tdebugfs_create_u8(name, S_IRUGO | S_IWUSR, parent,\n\t\t\t\t  &mci->fake_inject_layer[i]);\n\t}\n\n\tdebugfs_create_bool(\"fake_inject_ue\", S_IRUGO | S_IWUSR, parent,\n\t\t\t    &mci->fake_inject_ue);\n\n\tdebugfs_create_u16(\"fake_inject_count\", S_IRUGO | S_IWUSR, parent,\n\t\t\t   &mci->fake_inject_count);\n\n\tdebugfs_create_file(\"fake_inject\", S_IWUSR, parent, &mci->dev,\n\t\t\t    &debug_fake_inject_fops);\n\n\tmci->debugfs = parent;\n}\n\n \nstruct dentry *edac_debugfs_create_dir(const char *dirname)\n{\n\tif (!edac_debugfs)\n\t\treturn NULL;\n\n\treturn debugfs_create_dir(dirname, edac_debugfs);\n}\nEXPORT_SYMBOL_GPL(edac_debugfs_create_dir);\n\n \nstruct dentry *\nedac_debugfs_create_dir_at(const char *dirname, struct dentry *parent)\n{\n\treturn debugfs_create_dir(dirname, parent);\n}\nEXPORT_SYMBOL_GPL(edac_debugfs_create_dir_at);\n\n \nstruct dentry *\nedac_debugfs_create_file(const char *name, umode_t mode, struct dentry *parent,\n\t\t\t void *data, const struct file_operations *fops)\n{\n\tif (!parent)\n\t\tparent = edac_debugfs;\n\n\treturn debugfs_create_file(name, mode, parent, data, fops);\n}\nEXPORT_SYMBOL_GPL(edac_debugfs_create_file);\n\n \nvoid edac_debugfs_create_x8(const char *name, umode_t mode,\n\t\t\t    struct dentry *parent, u8 *value)\n{\n\tif (!parent)\n\t\tparent = edac_debugfs;\n\n\tdebugfs_create_x8(name, mode, parent, value);\n}\nEXPORT_SYMBOL_GPL(edac_debugfs_create_x8);\n\n \nvoid edac_debugfs_create_x16(const char *name, umode_t mode,\n\t\t\t     struct dentry *parent, u16 *value)\n{\n\tif (!parent)\n\t\tparent = edac_debugfs;\n\n\tdebugfs_create_x16(name, mode, parent, value);\n}\nEXPORT_SYMBOL_GPL(edac_debugfs_create_x16);\n\n \nvoid edac_debugfs_create_x32(const char *name, umode_t mode,\n\t\t\t     struct dentry *parent, u32 *value)\n{\n\tif (!parent)\n\t\tparent = edac_debugfs;\n\n\tdebugfs_create_x32(name, mode, parent, value);\n}\nEXPORT_SYMBOL_GPL(edac_debugfs_create_x32);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}