{
  "module_name": "i5000_edac.c",
  "hash_id": "448809278ebc444b2969fa283d823bef731b743e004046a7e69e423eb59cdd6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i5000_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/slab.h>\n#include <linux/edac.h>\n#include <asm/mmzone.h>\n\n#include \"edac_module.h\"\n\n \n#define I5000_REVISION    \" Ver: 2.0.12\"\n#define EDAC_MOD_STR      \"i5000_edac\"\n\n#define i5000_printk(level, fmt, arg...) \\\n        edac_printk(level, \"i5000\", fmt, ##arg)\n\n#define i5000_mc_printk(mci, level, fmt, arg...) \\\n        edac_mc_chipset_printk(mci, level, \"i5000\", fmt, ##arg)\n\n#ifndef PCI_DEVICE_ID_INTEL_FBD_0\n#define PCI_DEVICE_ID_INTEL_FBD_0\t0x25F5\n#endif\n#ifndef PCI_DEVICE_ID_INTEL_FBD_1\n#define PCI_DEVICE_ID_INTEL_FBD_1\t0x25F6\n#endif\n\n \n#define\tPCI_DEVICE_ID_INTEL_I5000_DEV16\t0x25F0\n\n \n\n \n#define\t\tAMBASE\t\t\t0x48\n#define\t\tMAXCH\t\t\t0x56\n#define\t\tMAXDIMMPERCH\t\t0x57\n#define\t\tTOLM\t\t\t0x6C\n#define\t\tREDMEMB\t\t\t0x7C\n#define\t\t\tRED_ECC_LOCATOR(x)\t((x) & 0x3FFFF)\n#define\t\t\tREC_ECC_LOCATOR_EVEN(x)\t((x) & 0x001FF)\n#define\t\t\tREC_ECC_LOCATOR_ODD(x)\t((x) & 0x3FE00)\n#define\t\tMIR0\t\t\t0x80\n#define\t\tMIR1\t\t\t0x84\n#define\t\tMIR2\t\t\t0x88\n#define\t\tAMIR0\t\t\t0x8C\n#define\t\tAMIR1\t\t\t0x90\n#define\t\tAMIR2\t\t\t0x94\n\n#define\t\tFERR_FAT_FBD\t\t0x98\n#define\t\tNERR_FAT_FBD\t\t0x9C\n#define\t\t\tEXTRACT_FBDCHAN_INDX(x)\t(((x)>>28) & 0x3)\n#define\t\t\tFERR_FAT_FBDCHAN 0x30000000\n#define\t\t\tFERR_FAT_M3ERR\t0x00000004\n#define\t\t\tFERR_FAT_M2ERR\t0x00000002\n#define\t\t\tFERR_FAT_M1ERR\t0x00000001\n#define\t\t\tFERR_FAT_MASK\t(FERR_FAT_M1ERR | \\\n\t\t\t\t\t\tFERR_FAT_M2ERR | \\\n\t\t\t\t\t\tFERR_FAT_M3ERR)\n\n#define\t\tFERR_NF_FBD\t\t0xA0\n\n \n#define\t\t\tFERR_NF_M28ERR\t0x01000000\n#define\t\t\tFERR_NF_M27ERR\t0x00800000\n#define\t\t\tFERR_NF_M26ERR\t0x00400000\n#define\t\t\tFERR_NF_M25ERR\t0x00200000\n#define\t\t\tFERR_NF_M24ERR\t0x00100000\n#define\t\t\tFERR_NF_M23ERR\t0x00080000\n#define\t\t\tFERR_NF_M22ERR\t0x00040000\n#define\t\t\tFERR_NF_M21ERR\t0x00020000\n\n \n#define\t\t\tFERR_NF_M20ERR\t0x00010000\n#define\t\t\tFERR_NF_M19ERR\t0x00008000\n#define\t\t\tFERR_NF_M18ERR\t0x00004000\n#define\t\t\tFERR_NF_M17ERR\t0x00002000\n\n \n#define\t\t\tFERR_NF_M16ERR\t0x00001000\n#define\t\t\tFERR_NF_M15ERR\t0x00000800\n#define\t\t\tFERR_NF_M14ERR\t0x00000400\n#define\t\t\tFERR_NF_M13ERR\t0x00000200\n\n \n#define\t\t\tFERR_NF_M12ERR\t0x00000100\n#define\t\t\tFERR_NF_M11ERR\t0x00000080\n#define\t\t\tFERR_NF_M10ERR\t0x00000040\n#define\t\t\tFERR_NF_M9ERR\t0x00000020\n#define\t\t\tFERR_NF_M8ERR\t0x00000010\n#define\t\t\tFERR_NF_M7ERR\t0x00000008\n#define\t\t\tFERR_NF_M6ERR\t0x00000004\n#define\t\t\tFERR_NF_M5ERR\t0x00000002\n#define\t\t\tFERR_NF_M4ERR\t0x00000001\n\n#define\t\t\tFERR_NF_UNCORRECTABLE\t(FERR_NF_M12ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M11ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M10ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M9ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M8ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M7ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M6ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M5ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M4ERR)\n#define\t\t\tFERR_NF_CORRECTABLE\t(FERR_NF_M20ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M19ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M18ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M17ERR)\n#define\t\t\tFERR_NF_DIMM_SPARE\t(FERR_NF_M27ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M28ERR)\n#define\t\t\tFERR_NF_THERMAL\t\t(FERR_NF_M26ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M25ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M24ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M23ERR)\n#define\t\t\tFERR_NF_SPD_PROTOCOL\t(FERR_NF_M22ERR)\n#define\t\t\tFERR_NF_NORTH_CRC\t(FERR_NF_M21ERR)\n#define\t\t\tFERR_NF_NON_RETRY\t(FERR_NF_M13ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M14ERR | \\\n\t\t\t\t\t\t\tFERR_NF_M15ERR)\n\n#define\t\tNERR_NF_FBD\t\t0xA4\n#define\t\t\tFERR_NF_MASK\t\t(FERR_NF_UNCORRECTABLE | \\\n\t\t\t\t\t\t\tFERR_NF_CORRECTABLE | \\\n\t\t\t\t\t\t\tFERR_NF_DIMM_SPARE | \\\n\t\t\t\t\t\t\tFERR_NF_THERMAL | \\\n\t\t\t\t\t\t\tFERR_NF_SPD_PROTOCOL | \\\n\t\t\t\t\t\t\tFERR_NF_NORTH_CRC | \\\n\t\t\t\t\t\t\tFERR_NF_NON_RETRY)\n\n#define\t\tEMASK_FBD\t\t0xA8\n#define\t\t\tEMASK_FBD_M28ERR\t0x08000000\n#define\t\t\tEMASK_FBD_M27ERR\t0x04000000\n#define\t\t\tEMASK_FBD_M26ERR\t0x02000000\n#define\t\t\tEMASK_FBD_M25ERR\t0x01000000\n#define\t\t\tEMASK_FBD_M24ERR\t0x00800000\n#define\t\t\tEMASK_FBD_M23ERR\t0x00400000\n#define\t\t\tEMASK_FBD_M22ERR\t0x00200000\n#define\t\t\tEMASK_FBD_M21ERR\t0x00100000\n#define\t\t\tEMASK_FBD_M20ERR\t0x00080000\n#define\t\t\tEMASK_FBD_M19ERR\t0x00040000\n#define\t\t\tEMASK_FBD_M18ERR\t0x00020000\n#define\t\t\tEMASK_FBD_M17ERR\t0x00010000\n\n#define\t\t\tEMASK_FBD_M15ERR\t0x00004000\n#define\t\t\tEMASK_FBD_M14ERR\t0x00002000\n#define\t\t\tEMASK_FBD_M13ERR\t0x00001000\n#define\t\t\tEMASK_FBD_M12ERR\t0x00000800\n#define\t\t\tEMASK_FBD_M11ERR\t0x00000400\n#define\t\t\tEMASK_FBD_M10ERR\t0x00000200\n#define\t\t\tEMASK_FBD_M9ERR\t\t0x00000100\n#define\t\t\tEMASK_FBD_M8ERR\t\t0x00000080\n#define\t\t\tEMASK_FBD_M7ERR\t\t0x00000040\n#define\t\t\tEMASK_FBD_M6ERR\t\t0x00000020\n#define\t\t\tEMASK_FBD_M5ERR\t\t0x00000010\n#define\t\t\tEMASK_FBD_M4ERR\t\t0x00000008\n#define\t\t\tEMASK_FBD_M3ERR\t\t0x00000004\n#define\t\t\tEMASK_FBD_M2ERR\t\t0x00000002\n#define\t\t\tEMASK_FBD_M1ERR\t\t0x00000001\n\n#define\t\t\tENABLE_EMASK_FBD_FATAL_ERRORS\t(EMASK_FBD_M1ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M2ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M3ERR)\n\n#define \t\tENABLE_EMASK_FBD_UNCORRECTABLE\t(EMASK_FBD_M4ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M5ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M6ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M7ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M8ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M9ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M10ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M11ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M12ERR)\n#define \t\tENABLE_EMASK_FBD_CORRECTABLE\t(EMASK_FBD_M17ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M18ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M19ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M20ERR)\n#define\t\t\tENABLE_EMASK_FBD_DIMM_SPARE\t(EMASK_FBD_M27ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M28ERR)\n#define\t\t\tENABLE_EMASK_FBD_THERMALS\t(EMASK_FBD_M26ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M25ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M24ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M23ERR)\n#define\t\t\tENABLE_EMASK_FBD_SPD_PROTOCOL\t(EMASK_FBD_M22ERR)\n#define\t\t\tENABLE_EMASK_FBD_NORTH_CRC\t(EMASK_FBD_M21ERR)\n#define\t\t\tENABLE_EMASK_FBD_NON_RETRY\t(EMASK_FBD_M15ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M14ERR | \\\n\t\t\t\t\t\t\tEMASK_FBD_M13ERR)\n\n#define\t\tENABLE_EMASK_ALL\t(ENABLE_EMASK_FBD_NON_RETRY | \\\n\t\t\t\t\tENABLE_EMASK_FBD_NORTH_CRC | \\\n\t\t\t\t\tENABLE_EMASK_FBD_SPD_PROTOCOL | \\\n\t\t\t\t\tENABLE_EMASK_FBD_THERMALS | \\\n\t\t\t\t\tENABLE_EMASK_FBD_DIMM_SPARE | \\\n\t\t\t\t\tENABLE_EMASK_FBD_FATAL_ERRORS | \\\n\t\t\t\t\tENABLE_EMASK_FBD_CORRECTABLE | \\\n\t\t\t\t\tENABLE_EMASK_FBD_UNCORRECTABLE)\n\n#define\t\tERR0_FBD\t\t0xAC\n#define\t\tERR1_FBD\t\t0xB0\n#define\t\tERR2_FBD\t\t0xB4\n#define\t\tMCERR_FBD\t\t0xB8\n#define\t\tNRECMEMA\t\t0xBE\n#define\t\t\tNREC_BANK(x)\t\t(((x)>>12) & 0x7)\n#define\t\t\tNREC_RDWR(x)\t\t(((x)>>11) & 1)\n#define\t\t\tNREC_RANK(x)\t\t(((x)>>8) & 0x7)\n#define\t\tNRECMEMB\t\t0xC0\n#define\t\t\tNREC_CAS(x)\t\t(((x)>>16) & 0xFFF)\n#define\t\t\tNREC_RAS(x)\t\t((x) & 0x7FFF)\n#define\t\tNRECFGLOG\t\t0xC4\n#define\t\tNREEECFBDA\t\t0xC8\n#define\t\tNREEECFBDB\t\t0xCC\n#define\t\tNREEECFBDC\t\t0xD0\n#define\t\tNREEECFBDD\t\t0xD4\n#define\t\tNREEECFBDE\t\t0xD8\n#define\t\tREDMEMA\t\t\t0xDC\n#define\t\tRECMEMA\t\t\t0xE2\n#define\t\t\tREC_BANK(x)\t\t(((x)>>12) & 0x7)\n#define\t\t\tREC_RDWR(x)\t\t(((x)>>11) & 1)\n#define\t\t\tREC_RANK(x)\t\t(((x)>>8) & 0x7)\n#define\t\tRECMEMB\t\t\t0xE4\n#define\t\t\tREC_CAS(x)\t\t(((x)>>16) & 0xFFFFFF)\n#define\t\t\tREC_RAS(x)\t\t((x) & 0x7FFF)\n#define\t\tRECFGLOG\t\t0xE8\n#define\t\tRECFBDA\t\t\t0xEC\n#define\t\tRECFBDB\t\t\t0xF0\n#define\t\tRECFBDC\t\t\t0xF4\n#define\t\tRECFBDD\t\t\t0xF8\n#define\t\tRECFBDE\t\t\t0xFC\n\n \n\n \n#define PCI_DEVICE_ID_I5000_BRANCH_0\t0x25F5\n#define PCI_DEVICE_ID_I5000_BRANCH_1\t0x25F6\n\n#define AMB_PRESENT_0\t0x64\n#define AMB_PRESENT_1\t0x66\n#define MTR0\t\t0x80\n#define MTR1\t\t0x84\n#define MTR2\t\t0x88\n#define MTR3\t\t0x8C\n\n#define NUM_MTRS\t\t4\n#define CHANNELS_PER_BRANCH\t2\n#define MAX_BRANCHES\t\t2\n\n \n#define MTR_DIMMS_PRESENT(mtr)\t\t((mtr) & (0x1 << 8))\n#define MTR_DRAM_WIDTH(mtr)\t\t((((mtr) >> 6) & 0x1) ? 8 : 4)\n#define MTR_DRAM_BANKS(mtr)\t\t((((mtr) >> 5) & 0x1) ? 8 : 4)\n#define MTR_DRAM_BANKS_ADDR_BITS(mtr)\t((MTR_DRAM_BANKS(mtr) == 8) ? 3 : 2)\n#define MTR_DIMM_RANK(mtr)\t\t(((mtr) >> 4) & 0x1)\n#define MTR_DIMM_RANK_ADDR_BITS(mtr)\t(MTR_DIMM_RANK(mtr) ? 2 : 1)\n#define MTR_DIMM_ROWS(mtr)\t\t(((mtr) >> 2) & 0x3)\n#define MTR_DIMM_ROWS_ADDR_BITS(mtr)\t(MTR_DIMM_ROWS(mtr) + 13)\n#define MTR_DIMM_COLS(mtr)\t\t((mtr) & 0x3)\n#define MTR_DIMM_COLS_ADDR_BITS(mtr)\t(MTR_DIMM_COLS(mtr) + 10)\n\n \nstatic int misc_messages;\n\n \nenum i5000_chips {\n\tI5000P = 0,\n\tI5000V = 1,\t\t \n\tI5000X = 2\t\t \n};\n\n \nstruct i5000_dev_info {\n\tconst char *ctl_name;\t \n\tu16 fsb_mapping_errors;\t \n};\n\n \nstatic const struct i5000_dev_info i5000_devs[] = {\n\t[I5000P] = {\n\t\t.ctl_name = \"I5000\",\n\t\t.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_I5000_DEV16,\n\t},\n};\n\nstruct i5000_dimm_info {\n\tint megabytes;\t\t \n\tint dual_rank;\n};\n\n#define\tMAX_CHANNELS\t6\t \n#define MAX_CSROWS\t(8*2)\t \n\n \nstruct i5000_pvt {\n\tstruct pci_dev *system_address;\t \n\tstruct pci_dev *branchmap_werrors;\t \n\tstruct pci_dev *fsb_error_regs;\t \n\tstruct pci_dev *branch_0;\t \n\tstruct pci_dev *branch_1;\t \n\n\tu16 tolm;\t\t \n\tunion {\n\t\tu64 ambase;\t\t \n\t\tstruct {\n\t\t\tu32 ambase_bottom;\n\t\t\tu32 ambase_top;\n\t\t} u __packed;\n\t};\n\n\tu16 mir0, mir1, mir2;\n\n\tu16 b0_mtr[NUM_MTRS];\t \n\tu16 b0_ambpresent0;\t \n\tu16 b0_ambpresent1;\t \n\n\tu16 b1_mtr[NUM_MTRS];\t \n\tu16 b1_ambpresent0;\t \n\tu16 b1_ambpresent1;\t \n\n\t \n\tstruct i5000_dimm_info dimm_info[MAX_CSROWS][MAX_CHANNELS];\n\n\t \n\tint maxch;\t\t \n\tint maxdimmperch;\t \n};\n\n \nstruct i5000_error_info {\n\n\t \n\tu32 ferr_fat_fbd;\t \n\tu32 nerr_fat_fbd;\t \n\tu32 ferr_nf_fbd;\t \n\tu32 nerr_nf_fbd;\t \n\n\t \n\tu32 redmemb;\t\t \n\tu16 recmema;\t\t \n\tu32 recmemb;\t\t \n\n\t \n\tu16 nrecmema;\t\t \n\tu32 nrecmemb;\t\t \n\n};\n\nstatic struct edac_pci_ctl_info *i5000_pci;\n\n \nstatic void i5000_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\t struct i5000_error_info *info)\n{\n\tstruct i5000_pvt *pvt;\n\tu32 value;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpci_read_config_dword(pvt->branchmap_werrors, FERR_FAT_FBD, &value);\n\n\t \n\tvalue &= (FERR_FAT_FBDCHAN | FERR_FAT_MASK);\n\n\t \n\t \n\tif (value & FERR_FAT_MASK) {\n\t\tinfo->ferr_fat_fbd = value;\n\n\t\t \n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tNERR_FAT_FBD, &info->nerr_fat_fbd);\n\t\tpci_read_config_word(pvt->branchmap_werrors,\n\t\t\t\tNRECMEMA, &info->nrecmema);\n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tNRECMEMB, &info->nrecmemb);\n\n\t\t \n\t\tpci_write_config_dword(pvt->branchmap_werrors,\n\t\t\t\tFERR_FAT_FBD, value);\n\t} else {\n\t\tinfo->ferr_fat_fbd = 0;\n\t\tinfo->nerr_fat_fbd = 0;\n\t\tinfo->nrecmema = 0;\n\t\tinfo->nrecmemb = 0;\n\t}\n\n\t \n\tpci_read_config_dword(pvt->branchmap_werrors, FERR_NF_FBD, &value);\n\n\t \n\tif (value & FERR_NF_MASK) {\n\t\tinfo->ferr_nf_fbd = value;\n\n\t\t \n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tNERR_NF_FBD, &info->nerr_nf_fbd);\n\t\tpci_read_config_word(pvt->branchmap_werrors,\n\t\t\t\tRECMEMA, &info->recmema);\n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tRECMEMB, &info->recmemb);\n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tREDMEMB, &info->redmemb);\n\n\t\t \n\t\tpci_write_config_dword(pvt->branchmap_werrors,\n\t\t\t\tFERR_NF_FBD, value);\n\t} else {\n\t\tinfo->ferr_nf_fbd = 0;\n\t\tinfo->nerr_nf_fbd = 0;\n\t\tinfo->recmema = 0;\n\t\tinfo->recmemb = 0;\n\t\tinfo->redmemb = 0;\n\t}\n}\n\n \nstatic void i5000_process_fatal_error_info(struct mem_ctl_info *mci,\n\t\t\t\t\tstruct i5000_error_info *info,\n\t\t\t\t\tint handle_errors)\n{\n\tchar msg[EDAC_MC_LABEL_LEN + 1 + 160];\n\tchar *specific = NULL;\n\tu32 allErrors;\n\tint channel;\n\tint bank;\n\tint rank;\n\tint rdwr;\n\tint ras, cas;\n\n\t \n\tallErrors = (info->ferr_fat_fbd & FERR_FAT_MASK);\n\tif (!allErrors)\n\t\treturn;\t\t \n\n\tchannel = EXTRACT_FBDCHAN_INDX(info->ferr_fat_fbd);\n\n\t \n\tbank = NREC_BANK(info->nrecmema);\n\trank = NREC_RANK(info->nrecmema);\n\trdwr = NREC_RDWR(info->nrecmema);\n\tras = NREC_RAS(info->nrecmemb);\n\tcas = NREC_CAS(info->nrecmemb);\n\n\tedac_dbg(0, \"\\t\\tCSROW= %d  Channel= %d (DRAM Bank= %d rdwr= %s ras= %d cas= %d)\\n\",\n\t\t rank, channel, bank,\n\t\t rdwr ? \"Write\" : \"Read\", ras, cas);\n\n\t \n\tswitch (allErrors) {\n\tcase FERR_FAT_M1ERR:\n\t\tspecific = \"Alert on non-redundant retry or fast \"\n\t\t\t\t\"reset timeout\";\n\t\tbreak;\n\tcase FERR_FAT_M2ERR:\n\t\tspecific = \"Northbound CRC error on non-redundant \"\n\t\t\t\t\"retry\";\n\t\tbreak;\n\tcase FERR_FAT_M3ERR:\n\t\t{\n\t\tstatic int done;\n\n\t\t \n\t\tif (done)\n\t\t\treturn;\n\t\tdone++;\n\n\t\tspecific = \">Tmid Thermal event with intelligent \"\n\t\t\t   \"throttling disabled\";\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tsnprintf(msg, sizeof(msg),\n\t\t \"Bank=%d RAS=%d CAS=%d FATAL Err=0x%x (%s)\",\n\t\t bank, ras, cas, allErrors, specific);\n\n\t \n\tedac_mc_handle_error(HW_EVENT_ERR_FATAL, mci, 1, 0, 0, 0,\n\t\t\t     channel >> 1, channel & 1, rank,\n\t\t\t     rdwr ? \"Write error\" : \"Read error\",\n\t\t\t     msg);\n}\n\n \nstatic void i5000_process_nonfatal_error_info(struct mem_ctl_info *mci,\n\t\t\t\t\tstruct i5000_error_info *info,\n\t\t\t\t\tint handle_errors)\n{\n\tchar msg[EDAC_MC_LABEL_LEN + 1 + 170];\n\tchar *specific = NULL;\n\tu32 allErrors;\n\tu32 ue_errors;\n\tu32 ce_errors;\n\tu32 misc_errors;\n\tint branch;\n\tint channel;\n\tint bank;\n\tint rank;\n\tint rdwr;\n\tint ras, cas;\n\n\t \n\tallErrors = (info->ferr_nf_fbd & FERR_NF_MASK);\n\tif (!allErrors)\n\t\treturn;\t\t \n\n\t \n\tue_errors = allErrors & FERR_NF_UNCORRECTABLE;\n\tif (ue_errors) {\n\t\tedac_dbg(0, \"\\tUncorrected bits= 0x%x\\n\", ue_errors);\n\n\t\tbranch = EXTRACT_FBDCHAN_INDX(info->ferr_nf_fbd);\n\n\t\t \n\t\tchannel = branch & 2;\n\n\t\tbank = NREC_BANK(info->nrecmema);\n\t\trank = NREC_RANK(info->nrecmema);\n\t\trdwr = NREC_RDWR(info->nrecmema);\n\t\tras = NREC_RAS(info->nrecmemb);\n\t\tcas = NREC_CAS(info->nrecmemb);\n\n\t\tedac_dbg(0, \"\\t\\tCSROW= %d  Channels= %d,%d  (Branch= %d DRAM Bank= %d rdwr= %s ras= %d cas= %d)\\n\",\n\t\t\t rank, channel, channel + 1, branch >> 1, bank,\n\t\t\t rdwr ? \"Write\" : \"Read\", ras, cas);\n\n\t\tswitch (ue_errors) {\n\t\tcase FERR_NF_M12ERR:\n\t\t\tspecific = \"Non-Aliased Uncorrectable Patrol Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M11ERR:\n\t\t\tspecific = \"Non-Aliased Uncorrectable Spare-Copy \"\n\t\t\t\t\t\"Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M10ERR:\n\t\t\tspecific = \"Non-Aliased Uncorrectable Mirrored Demand \"\n\t\t\t\t\t\"Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M9ERR:\n\t\t\tspecific = \"Non-Aliased Uncorrectable Non-Mirrored \"\n\t\t\t\t\t\"Demand Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M8ERR:\n\t\t\tspecific = \"Aliased Uncorrectable Patrol Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M7ERR:\n\t\t\tspecific = \"Aliased Uncorrectable Spare-Copy Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M6ERR:\n\t\t\tspecific = \"Aliased Uncorrectable Mirrored Demand \"\n\t\t\t\t\t\"Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M5ERR:\n\t\t\tspecific = \"Aliased Uncorrectable Non-Mirrored Demand \"\n\t\t\t\t\t\"Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M4ERR:\n\t\t\tspecific = \"Uncorrectable Data ECC on Replay\";\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"Rank=%d Bank=%d RAS=%d CAS=%d, UE Err=0x%x (%s)\",\n\t\t\t rank, bank, ras, cas, ue_errors, specific);\n\n\t\t \n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\tchannel >> 1, -1, rank,\n\t\t\t\trdwr ? \"Write error\" : \"Read error\",\n\t\t\t\tmsg);\n\t}\n\n\t \n\tce_errors = allErrors & FERR_NF_CORRECTABLE;\n\tif (ce_errors) {\n\t\tedac_dbg(0, \"\\tCorrected bits= 0x%x\\n\", ce_errors);\n\n\t\tbranch = EXTRACT_FBDCHAN_INDX(info->ferr_nf_fbd);\n\n\t\tchannel = 0;\n\t\tif (REC_ECC_LOCATOR_ODD(info->redmemb))\n\t\t\tchannel = 1;\n\n\t\t \n\t\tchannel += branch;\n\n\t\tbank = REC_BANK(info->recmema);\n\t\trank = REC_RANK(info->recmema);\n\t\trdwr = REC_RDWR(info->recmema);\n\t\tras = REC_RAS(info->recmemb);\n\t\tcas = REC_CAS(info->recmemb);\n\n\t\tedac_dbg(0, \"\\t\\tCSROW= %d Channel= %d  (Branch %d DRAM Bank= %d rdwr= %s ras= %d cas= %d)\\n\",\n\t\t\t rank, channel, branch >> 1, bank,\n\t\t\t rdwr ? \"Write\" : \"Read\", ras, cas);\n\n\t\tswitch (ce_errors) {\n\t\tcase FERR_NF_M17ERR:\n\t\t\tspecific = \"Correctable Non-Mirrored Demand Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M18ERR:\n\t\t\tspecific = \"Correctable Mirrored Demand Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M19ERR:\n\t\t\tspecific = \"Correctable Spare-Copy Data ECC\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M20ERR:\n\t\t\tspecific = \"Correctable Patrol Data ECC\";\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"Rank=%d Bank=%d RDWR=%s RAS=%d \"\n\t\t\t \"CAS=%d, CE Err=0x%x (%s))\", branch >> 1, bank,\n\t\t\t rdwr ? \"Write\" : \"Read\", ras, cas, ce_errors,\n\t\t\t specific);\n\n\t\t \n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\tchannel >> 1, channel % 2, rank,\n\t\t\t\trdwr ? \"Write error\" : \"Read error\",\n\t\t\t\tmsg);\n\t}\n\n\tif (!misc_messages)\n\t\treturn;\n\n\tmisc_errors = allErrors & (FERR_NF_NON_RETRY | FERR_NF_NORTH_CRC |\n\t\t\t\t   FERR_NF_SPD_PROTOCOL | FERR_NF_DIMM_SPARE);\n\tif (misc_errors) {\n\t\tswitch (misc_errors) {\n\t\tcase FERR_NF_M13ERR:\n\t\t\tspecific = \"Non-Retry or Redundant Retry FBD Memory \"\n\t\t\t\t\t\"Alert or Redundant Fast Reset Timeout\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M14ERR:\n\t\t\tspecific = \"Non-Retry or Redundant Retry FBD \"\n\t\t\t\t\t\"Configuration Alert\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M15ERR:\n\t\t\tspecific = \"Non-Retry or Redundant Retry FBD \"\n\t\t\t\t\t\"Northbound CRC error on read data\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M21ERR:\n\t\t\tspecific = \"FBD Northbound CRC error on \"\n\t\t\t\t\t\"FBD Sync Status\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M22ERR:\n\t\t\tspecific = \"SPD protocol error\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M27ERR:\n\t\t\tspecific = \"DIMM-spare copy started\";\n\t\t\tbreak;\n\t\tcase FERR_NF_M28ERR:\n\t\t\tspecific = \"DIMM-spare copy completed\";\n\t\t\tbreak;\n\t\t}\n\t\tbranch = EXTRACT_FBDCHAN_INDX(info->ferr_nf_fbd);\n\n\t\t \n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"Err=%#x (%s)\", misc_errors, specific);\n\n\t\t \n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\tbranch >> 1, -1, -1,\n\t\t\t\t\"Misc error\", msg);\n\t}\n}\n\n \nstatic void i5000_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct i5000_error_info *info,\n\t\t\t\tint handle_errors)\n{\n\t \n\ti5000_process_fatal_error_info(mci, info, handle_errors);\n\n\t \n\ti5000_process_nonfatal_error_info(mci, info, handle_errors);\n}\n\n \nstatic void i5000_clear_error(struct mem_ctl_info *mci)\n{\n\tstruct i5000_error_info info;\n\n\ti5000_get_error_info(mci, &info);\n}\n\n \nstatic void i5000_check_error(struct mem_ctl_info *mci)\n{\n\tstruct i5000_error_info info;\n\n\ti5000_get_error_info(mci, &info);\n\ti5000_process_error_info(mci, &info, 1);\n}\n\n \nstatic int i5000_get_devices(struct mem_ctl_info *mci, int dev_idx)\n{\n\t\n\tstruct i5000_pvt *pvt;\n\tstruct pci_dev *pdev;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpdev = NULL;\n\twhile (1) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_INTEL_I5000_DEV16, pdev);\n\n\t\t \n\t\tif (pdev == NULL) {\n\t\t\ti5000_printk(KERN_ERR,\n\t\t\t\t\"'system address,Process Bus' \"\n\t\t\t\t\"device not found:\"\n\t\t\t\t\"vendor 0x%x device 0x%x FUNC 1 \"\n\t\t\t\t\"(broken BIOS?)\\n\",\n\t\t\t\tPCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_INTEL_I5000_DEV16);\n\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (PCI_FUNC(pdev->devfn) == 1)\n\t\t\tbreak;\n\t}\n\n\tpvt->branchmap_werrors = pdev;\n\n\t \n\tpdev = NULL;\n\twhile (1) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_INTEL_I5000_DEV16, pdev);\n\n\t\tif (pdev == NULL) {\n\t\t\ti5000_printk(KERN_ERR,\n\t\t\t\t\"MC: 'branchmap,control,errors' \"\n\t\t\t\t\"device not found:\"\n\t\t\t\t\"vendor 0x%x device 0x%x Func 2 \"\n\t\t\t\t\"(broken BIOS?)\\n\",\n\t\t\t\tPCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_INTEL_I5000_DEV16);\n\n\t\t\tpci_dev_put(pvt->branchmap_werrors);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tif (PCI_FUNC(pdev->devfn) == 2)\n\t\t\tbreak;\n\t}\n\n\tpvt->fsb_error_regs = pdev;\n\n\tedac_dbg(1, \"System Address, processor bus- PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->system_address),\n\t\t pvt->system_address->vendor, pvt->system_address->device);\n\tedac_dbg(1, \"Branchmap, control and errors - PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->branchmap_werrors),\n\t\t pvt->branchmap_werrors->vendor,\n\t\t pvt->branchmap_werrors->device);\n\tedac_dbg(1, \"FSB Error Regs - PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->fsb_error_regs),\n\t\t pvt->fsb_error_regs->vendor, pvt->fsb_error_regs->device);\n\n\tpdev = NULL;\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_I5000_BRANCH_0, pdev);\n\n\tif (pdev == NULL) {\n\t\ti5000_printk(KERN_ERR,\n\t\t\t\"MC: 'BRANCH 0' device not found:\"\n\t\t\t\"vendor 0x%x device 0x%x Func 0 (broken BIOS?)\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_I5000_BRANCH_0);\n\n\t\tpci_dev_put(pvt->branchmap_werrors);\n\t\tpci_dev_put(pvt->fsb_error_regs);\n\t\treturn 1;\n\t}\n\n\tpvt->branch_0 = pdev;\n\n\t \n\tif (pvt->maxch >= CHANNELS_PER_BRANCH) {\n\t\tpdev = NULL;\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_I5000_BRANCH_1, pdev);\n\n\t\tif (pdev == NULL) {\n\t\t\ti5000_printk(KERN_ERR,\n\t\t\t\t\"MC: 'BRANCH 1' device not found:\"\n\t\t\t\t\"vendor 0x%x device 0x%x Func 0 \"\n\t\t\t\t\"(broken BIOS?)\\n\",\n\t\t\t\tPCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_I5000_BRANCH_1);\n\n\t\t\tpci_dev_put(pvt->branchmap_werrors);\n\t\t\tpci_dev_put(pvt->fsb_error_regs);\n\t\t\tpci_dev_put(pvt->branch_0);\n\t\t\treturn 1;\n\t\t}\n\n\t\tpvt->branch_1 = pdev;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void i5000_put_devices(struct mem_ctl_info *mci)\n{\n\tstruct i5000_pvt *pvt;\n\n\tpvt = mci->pvt_info;\n\n\tpci_dev_put(pvt->branchmap_werrors);\t \n\tpci_dev_put(pvt->fsb_error_regs);\t \n\tpci_dev_put(pvt->branch_0);\t \n\n\t \n\tif (pvt->maxch >= CHANNELS_PER_BRANCH)\n\t\tpci_dev_put(pvt->branch_1);\t \n}\n\n \nstatic int determine_amb_present_reg(struct i5000_pvt *pvt, int channel)\n{\n\tint amb_present;\n\n\tif (channel < CHANNELS_PER_BRANCH) {\n\t\tif (channel & 0x1)\n\t\t\tamb_present = pvt->b0_ambpresent1;\n\t\telse\n\t\t\tamb_present = pvt->b0_ambpresent0;\n\t} else {\n\t\tif (channel & 0x1)\n\t\t\tamb_present = pvt->b1_ambpresent1;\n\t\telse\n\t\t\tamb_present = pvt->b1_ambpresent0;\n\t}\n\n\treturn amb_present;\n}\n\n \nstatic int determine_mtr(struct i5000_pvt *pvt, int slot, int channel)\n{\n\tint mtr;\n\n\tif (channel < CHANNELS_PER_BRANCH)\n\t\tmtr = pvt->b0_mtr[slot];\n\telse\n\t\tmtr = pvt->b1_mtr[slot];\n\n\treturn mtr;\n}\n\n \nstatic void decode_mtr(int slot_row, u16 mtr)\n{\n\tint ans;\n\n\tans = MTR_DIMMS_PRESENT(mtr);\n\n\tedac_dbg(2, \"\\tMTR%d=0x%x:  DIMMs are %sPresent\\n\",\n\t\t slot_row, mtr, ans ? \"\" : \"NOT \");\n\tif (!ans)\n\t\treturn;\n\n\tedac_dbg(2, \"\\t\\tWIDTH: x%d\\n\", MTR_DRAM_WIDTH(mtr));\n\tedac_dbg(2, \"\\t\\tNUMBANK: %d bank(s)\\n\", MTR_DRAM_BANKS(mtr));\n\tedac_dbg(2, \"\\t\\tNUMRANK: %s\\n\",\n\t\t MTR_DIMM_RANK(mtr) ? \"double\" : \"single\");\n\tedac_dbg(2, \"\\t\\tNUMROW: %s\\n\",\n\t\t MTR_DIMM_ROWS(mtr) == 0 ? \"8,192 - 13 rows\" :\n\t\t MTR_DIMM_ROWS(mtr) == 1 ? \"16,384 - 14 rows\" :\n\t\t MTR_DIMM_ROWS(mtr) == 2 ? \"32,768 - 15 rows\" :\n\t\t \"reserved\");\n\tedac_dbg(2, \"\\t\\tNUMCOL: %s\\n\",\n\t\t MTR_DIMM_COLS(mtr) == 0 ? \"1,024 - 10 columns\" :\n\t\t MTR_DIMM_COLS(mtr) == 1 ? \"2,048 - 11 columns\" :\n\t\t MTR_DIMM_COLS(mtr) == 2 ? \"4,096 - 12 columns\" :\n\t\t \"reserved\");\n}\n\nstatic void handle_channel(struct i5000_pvt *pvt, int slot, int channel,\n\t\t\tstruct i5000_dimm_info *dinfo)\n{\n\tint mtr;\n\tint amb_present_reg;\n\tint addrBits;\n\n\tmtr = determine_mtr(pvt, slot, channel);\n\tif (MTR_DIMMS_PRESENT(mtr)) {\n\t\tamb_present_reg = determine_amb_present_reg(pvt, channel);\n\n\t\t \n\t\tif (amb_present_reg) {\n\t\t\tdinfo->dual_rank = MTR_DIMM_RANK(mtr);\n\n\t\t\t \n\t\t\taddrBits = MTR_DRAM_BANKS_ADDR_BITS(mtr);\n\t\t\t \n\t\t\taddrBits += MTR_DIMM_ROWS_ADDR_BITS(mtr);\n\t\t\t \n\t\t\taddrBits += MTR_DIMM_COLS_ADDR_BITS(mtr);\n\n\t\t\t \n\t\t\tif (dinfo->dual_rank)\n\t\t\t\taddrBits++;\n\n\t\t\taddrBits += 6;\t \n\t\t\taddrBits -= 20;\t \n\t\t\taddrBits -= 3;\t \n\n\t\t\tdinfo->megabytes = 1 << addrBits;\n\t\t}\n\t}\n}\n\n \nstatic void calculate_dimm_size(struct i5000_pvt *pvt)\n{\n\tstruct i5000_dimm_info *dinfo;\n\tint slot, channel, branch;\n\tchar *p, *mem_buffer;\n\tint space, n;\n\n\t \n\tspace = PAGE_SIZE;\n\tmem_buffer = p = kmalloc(space, GFP_KERNEL);\n\tif (p == NULL) {\n\t\ti5000_printk(KERN_ERR, \"MC: %s:%s() kmalloc() failed\\n\",\n\t\t\t__FILE__, __func__);\n\t\treturn;\n\t}\n\n\t \n\tfor (slot = pvt->maxdimmperch - 1; slot >= 0; slot--) {\n\n\t\t \n\t\tif (slot & 0x1) {\n\t\t\tn = snprintf(p, space, \"--------------------------\"\n\t\t\t\t\"--------------------------------\");\n\t\t\tp += n;\n\t\t\tspace -= n;\n\t\t\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\t\t\tp = mem_buffer;\n\t\t\tspace = PAGE_SIZE;\n\t\t}\n\t\tn = snprintf(p, space, \"slot %2d    \", slot);\n\t\tp += n;\n\t\tspace -= n;\n\n\t\tfor (channel = 0; channel < pvt->maxch; channel++) {\n\t\t\tdinfo = &pvt->dimm_info[slot][channel];\n\t\t\thandle_channel(pvt, slot, channel, dinfo);\n\t\t\tif (dinfo->megabytes)\n\t\t\t\tn = snprintf(p, space, \"%4d MB %dR| \",\n\t\t\t\t\t     dinfo->megabytes, dinfo->dual_rank + 1);\n\t\t\telse\n\t\t\t\tn = snprintf(p, space, \"%4d MB   | \", 0);\n\t\t\tp += n;\n\t\t\tspace -= n;\n\t\t}\n\t\tp += n;\n\t\tspace -= n;\n\t\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\t\tp = mem_buffer;\n\t\tspace = PAGE_SIZE;\n\t}\n\n\t \n\tn = snprintf(p, space, \"--------------------------\"\n\t\t\"--------------------------------\");\n\tp += n;\n\tspace -= n;\n\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\tp = mem_buffer;\n\tspace = PAGE_SIZE;\n\n\t \n\tn = snprintf(p, space, \"           \");\n\tp += n;\n\tspace -= n;\n\tfor (channel = 0; channel < pvt->maxch; channel++) {\n\t\tn = snprintf(p, space, \"channel %d | \", channel);\n\t\tp += n;\n\t\tspace -= n;\n\t}\n\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\tp = mem_buffer;\n\tspace = PAGE_SIZE;\n\n\tn = snprintf(p, space, \"           \");\n\tp += n;\n\tfor (branch = 0; branch < MAX_BRANCHES; branch++) {\n\t\tn = snprintf(p, space, \"       branch %d       | \", branch);\n\t\tp += n;\n\t\tspace -= n;\n\t}\n\n\t \n\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\tkfree(mem_buffer);\n}\n\n \nstatic void i5000_get_mc_regs(struct mem_ctl_info *mci)\n{\n\tstruct i5000_pvt *pvt;\n\tu32 actual_tolm;\n\tu16 limit;\n\tint slot_row;\n\tint way0, way1;\n\n\tpvt = mci->pvt_info;\n\n\tpci_read_config_dword(pvt->system_address, AMBASE,\n\t\t\t&pvt->u.ambase_bottom);\n\tpci_read_config_dword(pvt->system_address, AMBASE + sizeof(u32),\n\t\t\t&pvt->u.ambase_top);\n\n\tedac_dbg(2, \"AMBASE= 0x%lx  MAXCH= %d  MAX-DIMM-Per-CH= %d\\n\",\n\t\t (long unsigned int)pvt->ambase, pvt->maxch, pvt->maxdimmperch);\n\n\t \n\tpci_read_config_word(pvt->branchmap_werrors, TOLM, &pvt->tolm);\n\tpvt->tolm >>= 12;\n\tedac_dbg(2, \"TOLM (number of 256M regions) =%u (0x%x)\\n\",\n\t\t pvt->tolm, pvt->tolm);\n\n\tactual_tolm = pvt->tolm << 28;\n\tedac_dbg(2, \"Actual TOLM byte addr=%u (0x%x)\\n\",\n\t\t actual_tolm, actual_tolm);\n\n\tpci_read_config_word(pvt->branchmap_werrors, MIR0, &pvt->mir0);\n\tpci_read_config_word(pvt->branchmap_werrors, MIR1, &pvt->mir1);\n\tpci_read_config_word(pvt->branchmap_werrors, MIR2, &pvt->mir2);\n\n\t \n\tlimit = (pvt->mir0 >> 4) & 0x0FFF;\n\tway0 = pvt->mir0 & 0x1;\n\tway1 = pvt->mir0 & 0x2;\n\tedac_dbg(2, \"MIR0: limit= 0x%x  WAY1= %u  WAY0= %x\\n\",\n\t\t limit, way1, way0);\n\tlimit = (pvt->mir1 >> 4) & 0x0FFF;\n\tway0 = pvt->mir1 & 0x1;\n\tway1 = pvt->mir1 & 0x2;\n\tedac_dbg(2, \"MIR1: limit= 0x%x  WAY1= %u  WAY0= %x\\n\",\n\t\t limit, way1, way0);\n\tlimit = (pvt->mir2 >> 4) & 0x0FFF;\n\tway0 = pvt->mir2 & 0x1;\n\tway1 = pvt->mir2 & 0x2;\n\tedac_dbg(2, \"MIR2: limit= 0x%x  WAY1= %u  WAY0= %x\\n\",\n\t\t limit, way1, way0);\n\n\t \n\tfor (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {\n\t\tint where = MTR0 + (slot_row * sizeof(u32));\n\n\t\tpci_read_config_word(pvt->branch_0, where,\n\t\t\t\t&pvt->b0_mtr[slot_row]);\n\n\t\tedac_dbg(2, \"MTR%d where=0x%x B0 value=0x%x\\n\",\n\t\t\t slot_row, where, pvt->b0_mtr[slot_row]);\n\n\t\tif (pvt->maxch >= CHANNELS_PER_BRANCH) {\n\t\t\tpci_read_config_word(pvt->branch_1, where,\n\t\t\t\t\t&pvt->b1_mtr[slot_row]);\n\t\t\tedac_dbg(2, \"MTR%d where=0x%x B1 value=0x%x\\n\",\n\t\t\t\t slot_row, where, pvt->b1_mtr[slot_row]);\n\t\t} else {\n\t\t\tpvt->b1_mtr[slot_row] = 0;\n\t\t}\n\t}\n\n\t \n\tedac_dbg(2, \"Memory Technology Registers:\\n\");\n\tedac_dbg(2, \"   Branch 0:\\n\");\n\tfor (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {\n\t\tdecode_mtr(slot_row, pvt->b0_mtr[slot_row]);\n\t}\n\tpci_read_config_word(pvt->branch_0, AMB_PRESENT_0,\n\t\t\t&pvt->b0_ambpresent0);\n\tedac_dbg(2, \"\\t\\tAMB-Branch 0-present0 0x%x:\\n\", pvt->b0_ambpresent0);\n\tpci_read_config_word(pvt->branch_0, AMB_PRESENT_1,\n\t\t\t&pvt->b0_ambpresent1);\n\tedac_dbg(2, \"\\t\\tAMB-Branch 0-present1 0x%x:\\n\", pvt->b0_ambpresent1);\n\n\t \n\tif (pvt->maxch < CHANNELS_PER_BRANCH) {\n\t\tpvt->b1_ambpresent0 = 0;\n\t\tpvt->b1_ambpresent1 = 0;\n\t} else {\n\t\t \n\t\tedac_dbg(2, \"   Branch 1:\\n\");\n\t\tfor (slot_row = 0; slot_row < NUM_MTRS; slot_row++) {\n\t\t\tdecode_mtr(slot_row, pvt->b1_mtr[slot_row]);\n\t\t}\n\t\tpci_read_config_word(pvt->branch_1, AMB_PRESENT_0,\n\t\t\t\t&pvt->b1_ambpresent0);\n\t\tedac_dbg(2, \"\\t\\tAMB-Branch 1-present0 0x%x:\\n\",\n\t\t\t pvt->b1_ambpresent0);\n\t\tpci_read_config_word(pvt->branch_1, AMB_PRESENT_1,\n\t\t\t\t&pvt->b1_ambpresent1);\n\t\tedac_dbg(2, \"\\t\\tAMB-Branch 1-present1 0x%x:\\n\",\n\t\t\t pvt->b1_ambpresent1);\n\t}\n\n\t \n\tcalculate_dimm_size(pvt);\n}\n\n \nstatic int i5000_init_csrows(struct mem_ctl_info *mci)\n{\n\tstruct i5000_pvt *pvt;\n\tstruct dimm_info *dimm;\n\tint empty;\n\tint max_csrows;\n\tint mtr;\n\tint csrow_megs;\n\tint channel;\n\tint slot;\n\n\tpvt = mci->pvt_info;\n\tmax_csrows = pvt->maxdimmperch * 2;\n\n\tempty = 1;\t\t \n\n\t \n\tfor (slot = 0; slot < max_csrows; slot++) {\n\t\tfor (channel = 0; channel < pvt->maxch; channel++) {\n\n\t\t\tmtr = determine_mtr(pvt, slot, channel);\n\n\t\t\tif (!MTR_DIMMS_PRESENT(mtr))\n\t\t\t\tcontinue;\n\n\t\t\tdimm = edac_get_dimm(mci, channel / MAX_BRANCHES,\n\t\t\t\t\t     channel % MAX_BRANCHES, slot);\n\n\t\t\tcsrow_megs = pvt->dimm_info[slot][channel].megabytes;\n\t\t\tdimm->grain = 8;\n\n\t\t\t \n\t\t\tdimm->mtype = MEM_FB_DDR2;\n\n\t\t\t \n\t\t\tif (MTR_DRAM_WIDTH(mtr) == 8)\n\t\t\t\tdimm->dtype = DEV_X8;\n\t\t\telse\n\t\t\t\tdimm->dtype = DEV_X4;\n\n\t\t\tdimm->edac_mode = EDAC_S8ECD8ED;\n\t\t\tdimm->nr_pages = csrow_megs << 8;\n\t\t}\n\n\t\tempty = 0;\n\t}\n\n\treturn empty;\n}\n\n \nstatic void i5000_enable_error_reporting(struct mem_ctl_info *mci)\n{\n\tstruct i5000_pvt *pvt;\n\tu32 fbd_error_mask;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpci_read_config_dword(pvt->branchmap_werrors, EMASK_FBD,\n\t\t\t&fbd_error_mask);\n\n\t \n\tfbd_error_mask &= ~(ENABLE_EMASK_ALL);\n\n\tpci_write_config_dword(pvt->branchmap_werrors, EMASK_FBD,\n\t\t\tfbd_error_mask);\n}\n\n \nstatic void i5000_get_dimm_and_channel_counts(struct pci_dev *pdev,\n\t\t\t\t\tint *num_dimms_per_channel,\n\t\t\t\t\tint *num_channels)\n{\n\tu8 value;\n\n\t \n\tpci_read_config_byte(pdev, MAXDIMMPERCH, &value);\n\t*num_dimms_per_channel = (int)value;\n\n\tpci_read_config_byte(pdev, MAXCH, &value);\n\t*num_channels = (int)value;\n}\n\n \nstatic int i5000_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[3];\n\tstruct i5000_pvt *pvt;\n\tint num_channels;\n\tint num_dimms_per_channel;\n\n\tedac_dbg(0, \"MC: pdev bus %u dev=0x%x fn=0x%x\\n\",\n\t\t pdev->bus->number,\n\t\t PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\n\n\t \n\tif (PCI_FUNC(pdev->devfn) != 0)\n\t\treturn -ENODEV;\n\n\t \n\ti5000_get_dimm_and_channel_counts(pdev, &num_dimms_per_channel,\n\t\t\t\t\t&num_channels);\n\n\tedac_dbg(0, \"MC: Number of Branches=2 Channels= %d  DIMMS= %d\\n\",\n\t\t num_channels, num_dimms_per_channel);\n\n\t \n\n\tlayers[0].type = EDAC_MC_LAYER_BRANCH;\n\tlayers[0].size = MAX_BRANCHES;\n\tlayers[0].is_virt_csrow = false;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = num_channels / MAX_BRANCHES;\n\tlayers[1].is_virt_csrow = false;\n\tlayers[2].type = EDAC_MC_LAYER_SLOT;\n\tlayers[2].size = num_dimms_per_channel;\n\tlayers[2].is_virt_csrow = true;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(0, \"MC: mci = %p\\n\", mci);\n\n\tmci->pdev = &pdev->dev;\t \n\n\tpvt = mci->pvt_info;\n\tpvt->system_address = pdev;\t \n\tpvt->maxch = num_channels;\n\tpvt->maxdimmperch = num_dimms_per_channel;\n\n\t \n\tif (i5000_get_devices(mci, dev_idx))\n\t\tgoto fail0;\n\n\t \n\ti5000_get_mc_regs(mci);\t \n\n\tmci->mc_idx = 0;\n\tmci->mtype_cap = MEM_FLAG_FB_DDR2;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE;\n\tmci->edac_cap = EDAC_FLAG_NONE;\n\tmci->mod_name = \"i5000_edac.c\";\n\tmci->ctl_name = i5000_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->ctl_page_to_phys = NULL;\n\n\t \n\tmci->edac_check = i5000_check_error;\n\n\t \n\tif (i5000_init_csrows(mci)) {\n\t\tedac_dbg(0, \"MC: Setting mci->edac_cap to EDAC_FLAG_NONE because i5000_init_csrows() returned nonzero value\\n\");\n\t\tmci->edac_cap = EDAC_FLAG_NONE;\t \n\t} else {\n\t\tedac_dbg(1, \"MC: Enable error reporting now\\n\");\n\t\ti5000_enable_error_reporting(mci);\n\t}\n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(0, \"MC: failed edac_mc_add_mc()\\n\");\n\t\t \n\t\tgoto fail1;\n\t}\n\n\ti5000_clear_error(mci);\n\n\t \n\ti5000_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!i5000_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\treturn 0;\n\n\t \nfail1:\n\n\ti5000_put_devices(mci);\n\nfail0:\n\tedac_mc_free(mci);\n\treturn -ENODEV;\n}\n\n \nstatic int i5000_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint rc;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn i5000_probe1(pdev, id->driver_data);\n}\n\n \nstatic void i5000_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (i5000_pci)\n\t\tedac_pci_release_generic_ctl(i5000_pci);\n\n\tif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\n\t\treturn;\n\n\t \n\ti5000_put_devices(mci);\n\tedac_mc_free(mci);\n}\n\n \nstatic const struct pci_device_id i5000_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I5000_DEV16),\n\t .driver_data = I5000P},\n\n\t{0,}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, i5000_pci_tbl);\n\n \nstatic struct pci_driver i5000_driver = {\n\t.name = KBUILD_BASENAME,\n\t.probe = i5000_init_one,\n\t.remove = i5000_remove_one,\n\t.id_table = i5000_pci_tbl,\n};\n\n \nstatic int __init i5000_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(2, \"MC:\\n\");\n\n\t \n\topstate_init();\n\n\tpci_rc = pci_register_driver(&i5000_driver);\n\n\treturn (pci_rc < 0) ? pci_rc : 0;\n}\n\n \nstatic void __exit i5000_exit(void)\n{\n\tedac_dbg(2, \"MC:\\n\");\n\tpci_unregister_driver(&i5000_driver);\n}\n\nmodule_init(i5000_init);\nmodule_exit(i5000_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Linux Networx (http://lnxi.com) Doug Thompson <norsk5@xmission.com>\");\nMODULE_DESCRIPTION(\"MC Driver for Intel I5000 memory controllers - \" I5000_REVISION);\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\nmodule_param(misc_messages, int, 0444);\nMODULE_PARM_DESC(misc_messages, \"Log miscellaneous non fatal messages\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}