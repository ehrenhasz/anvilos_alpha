{
  "module_name": "thunderx_edac.c",
  "hash_id": "269d05f287d0f08b429bdeb1222daf7ea3bb301ff42511413e6e34faca610629",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/thunderx_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/edac.h>\n#include <linux/interrupt.h>\n#include <linux/string.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/sizes.h>\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/circ_buf.h>\n\n#include <asm/page.h>\n\n#include \"edac_module.h\"\n\n#define phys_to_pfn(phys)\t(PFN_DOWN(phys))\n\n#define THUNDERX_NODE\t\tGENMASK(45, 44)\n\nenum {\n\tERR_CORRECTED\t= 1,\n\tERR_UNCORRECTED\t= 2,\n\tERR_UNKNOWN\t= 3,\n};\n\n#define MAX_SYNDROME_REGS 4\n\nstruct error_syndrome {\n\tu64 reg[MAX_SYNDROME_REGS];\n};\n\nstruct error_descr {\n\tint\ttype;\n\tu64\tmask;\n\tchar\t*descr;\n};\n\nstatic void decode_register(char *str, size_t size,\n\t\t\t   const struct error_descr *descr,\n\t\t\t   const uint64_t reg)\n{\n\tint ret = 0;\n\n\twhile (descr->type && descr->mask && descr->descr) {\n\t\tif (reg & descr->mask) {\n\t\t\tret = snprintf(str, size, \"\\n\\t%s, %s\",\n\t\t\t\t       descr->type == ERR_CORRECTED ?\n\t\t\t\t\t \"Corrected\" : \"Uncorrected\",\n\t\t\t\t       descr->descr);\n\t\t\tstr += ret;\n\t\t\tsize -= ret;\n\t\t}\n\t\tdescr++;\n\t}\n}\n\nstatic unsigned long get_bits(unsigned long data, int pos, int width)\n{\n\treturn (data >> pos) & ((1 << width) - 1);\n}\n\n#define L2C_CTL\t\t\t0x87E080800000\n#define L2C_CTL_DISIDXALIAS\tBIT(0)\n\n#define PCI_DEVICE_ID_THUNDER_LMC 0xa022\n\n#define LMC_FADR\t\t0x20\n#define LMC_FADR_FDIMM(x)\t((x >> 37) & 0x1)\n#define LMC_FADR_FBUNK(x)\t((x >> 36) & 0x1)\n#define LMC_FADR_FBANK(x)\t((x >> 32) & 0xf)\n#define LMC_FADR_FROW(x)\t((x >> 14) & 0xffff)\n#define LMC_FADR_FCOL(x)\t((x >> 0) & 0x1fff)\n\n#define LMC_NXM_FADR\t\t0x28\n#define LMC_ECC_SYND\t\t0x38\n\n#define LMC_ECC_PARITY_TEST\t0x108\n\n#define LMC_INT_W1S\t\t0x150\n\n#define LMC_INT_ENA_W1C\t\t0x158\n#define LMC_INT_ENA_W1S\t\t0x160\n\n#define LMC_CONFIG\t\t0x188\n\n#define LMC_CONFIG_BG2\t\tBIT(62)\n#define LMC_CONFIG_RANK_ENA\tBIT(42)\n#define LMC_CONFIG_PBANK_LSB(x)\t(((x) >> 5) & 0xF)\n#define LMC_CONFIG_ROW_LSB(x)\t(((x) >> 2) & 0x7)\n\n#define LMC_CONTROL\t\t0x190\n#define LMC_CONTROL_XOR_BANK\tBIT(16)\n\n#define LMC_INT\t\t\t0x1F0\n\n#define LMC_INT_DDR_ERR\t\tBIT(11)\n#define LMC_INT_DED_ERR\t\t(0xFUL << 5)\n#define LMC_INT_SEC_ERR         (0xFUL << 1)\n#define LMC_INT_NXM_WR_MASK\tBIT(0)\n\n#define LMC_DDR_PLL_CTL\t\t0x258\n#define LMC_DDR_PLL_CTL_DDR4\tBIT(29)\n\n#define LMC_FADR_SCRAMBLED\t0x330\n\n#define LMC_INT_UE              (LMC_INT_DDR_ERR | LMC_INT_DED_ERR | \\\n\t\t\t\t LMC_INT_NXM_WR_MASK)\n\n#define LMC_INT_CE\t\t(LMC_INT_SEC_ERR)\n\nstatic const struct error_descr lmc_errors[] = {\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = LMC_INT_SEC_ERR,\n\t\t.descr = \"Single-bit ECC error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = LMC_INT_DDR_ERR,\n\t\t.descr = \"DDR chip error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = LMC_INT_DED_ERR,\n\t\t.descr = \"Double-bit ECC error\",\n\t},\n\t{\n\t\t.type = ERR_UNCORRECTED,\n\t\t.mask = LMC_INT_NXM_WR_MASK,\n\t\t.descr = \"Non-existent memory write\",\n\t},\n\t{0, 0, NULL},\n};\n\n#define LMC_INT_EN_DDR_ERROR_ALERT_ENA\tBIT(5)\n#define LMC_INT_EN_DLCRAM_DED_ERR\tBIT(4)\n#define LMC_INT_EN_DLCRAM_SEC_ERR\tBIT(3)\n#define LMC_INT_INTR_DED_ENA\t\tBIT(2)\n#define LMC_INT_INTR_SEC_ENA\t\tBIT(1)\n#define LMC_INT_INTR_NXM_WR_ENA\t\tBIT(0)\n\n#define LMC_INT_ENA_ALL\t\t\tGENMASK(5, 0)\n\n#define LMC_DDR_PLL_CTL\t\t0x258\n#define LMC_DDR_PLL_CTL_DDR4\tBIT(29)\n\n#define LMC_CONTROL\t\t0x190\n#define LMC_CONTROL_RDIMM\tBIT(0)\n\n#define LMC_SCRAM_FADR\t\t0x330\n\n#define LMC_CHAR_MASK0\t\t0x228\n#define LMC_CHAR_MASK2\t\t0x238\n\n#define RING_ENTRIES\t8\n\nstruct debugfs_entry {\n\tconst char *name;\n\tumode_t mode;\n\tconst struct file_operations fops;\n};\n\nstruct lmc_err_ctx {\n\tu64 reg_int;\n\tu64 reg_fadr;\n\tu64 reg_nxm_fadr;\n\tu64 reg_scram_fadr;\n\tu64 reg_ecc_synd;\n};\n\nstruct thunderx_lmc {\n\tvoid __iomem *regs;\n\tstruct pci_dev *pdev;\n\tstruct msix_entry msix_ent;\n\n\tatomic_t ecc_int;\n\n\tu64 mask0;\n\tu64 mask2;\n\tu64 parity_test;\n\tu64 node;\n\n\tint xbits;\n\tint bank_width;\n\tint pbank_lsb;\n\tint dimm_lsb;\n\tint rank_lsb;\n\tint bank_lsb;\n\tint row_lsb;\n\tint col_hi_lsb;\n\n\tint xor_bank;\n\tint l2c_alias;\n\n\tstruct page *mem;\n\n\tstruct lmc_err_ctx err_ctx[RING_ENTRIES];\n\tunsigned long ring_head;\n\tunsigned long ring_tail;\n};\n\n#define ring_pos(pos, size) ((pos) & (size - 1))\n\n#define DEBUGFS_STRUCT(_name, _mode, _write, _read)\t\t\t    \\\nstatic struct debugfs_entry debugfs_##_name = {\t\t\t\t    \\\n\t.name = __stringify(_name),\t\t\t\t\t    \\\n\t.mode = VERIFY_OCTAL_PERMISSIONS(_mode),\t\t\t    \\\n\t.fops = {\t\t\t\t\t\t\t    \\\n\t\t.open = simple_open,\t\t\t\t\t    \\\n\t\t.write = _write,\t\t\t\t\t    \\\n\t\t.read  = _read,\t\t\t\t\t\t    \\\n\t\t.llseek = generic_file_llseek,\t\t\t\t    \\\n\t},\t\t\t\t\t\t\t\t    \\\n}\n\n#define DEBUGFS_FIELD_ATTR(_type, _field)\t\t\t\t    \\\nstatic ssize_t thunderx_##_type##_##_field##_read(struct file *file,\t    \\\n\t\t\t\t\t    char __user *data,\t\t    \\\n\t\t\t\t\t    size_t count, loff_t *ppos)\t    \\\n{\t\t\t\t\t\t\t\t\t    \\\n\tstruct thunderx_##_type *pdata = file->private_data;\t\t    \\\n\tchar buf[20];\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\n\tsnprintf(buf, count, \"0x%016llx\", pdata->_field);\t\t    \\\n\treturn simple_read_from_buffer(data, count, ppos,\t\t    \\\n\t\t\t\t       buf, sizeof(buf));\t\t    \\\n}\t\t\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\nstatic ssize_t thunderx_##_type##_##_field##_write(struct file *file,\t    \\\n\t\t\t\t\t     const char __user *data,\t    \\\n\t\t\t\t\t     size_t count, loff_t *ppos)    \\\n{\t\t\t\t\t\t\t\t\t    \\\n\tstruct thunderx_##_type *pdata = file->private_data;\t\t    \\\n\tint res;\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\n\tres = kstrtoull_from_user(data, count, 0, &pdata->_field);\t    \\\n\t\t\t\t\t\t\t\t\t    \\\n\treturn res ? res : count;\t\t\t\t\t    \\\n}\t\t\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\nDEBUGFS_STRUCT(_field, 0600,\t\t\t\t\t\t    \\\n\t\t   thunderx_##_type##_##_field##_write,\t\t\t    \\\n\t\t   thunderx_##_type##_##_field##_read)\t\t\t    \\\n\n#define DEBUGFS_REG_ATTR(_type, _name, _reg)\t\t\t\t    \\\nstatic ssize_t thunderx_##_type##_##_name##_read(struct file *file,\t    \\\n\t\t\t\t\t   char __user *data,\t\t    \\\n\t\t\t\t\t   size_t count, loff_t *ppos)      \\\n{\t\t\t\t\t\t\t\t\t    \\\n\tstruct thunderx_##_type *pdata = file->private_data;\t\t    \\\n\tchar buf[20];\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\n\tsprintf(buf, \"0x%016llx\", readq(pdata->regs + _reg));\t\t    \\\n\treturn simple_read_from_buffer(data, count, ppos,\t\t    \\\n\t\t\t\t       buf, sizeof(buf));\t\t    \\\n}\t\t\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\nstatic ssize_t thunderx_##_type##_##_name##_write(struct file *file,\t    \\\n\t\t\t\t\t    const char __user *data,\t    \\\n\t\t\t\t\t    size_t count, loff_t *ppos)     \\\n{\t\t\t\t\t\t\t\t\t    \\\n\tstruct thunderx_##_type *pdata = file->private_data;\t\t    \\\n\tu64 val;\t\t\t\t\t\t\t    \\\n\tint res;\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\n\tres = kstrtoull_from_user(data, count, 0, &val);\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\n\tif (!res) {\t\t\t\t\t\t\t    \\\n\t\twriteq(val, pdata->regs + _reg);\t\t\t    \\\n\t\tres = count;\t\t\t\t\t\t    \\\n\t}\t\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\n\treturn res;\t\t\t\t\t\t\t    \\\n}\t\t\t\t\t\t\t\t\t    \\\n\t\t\t\t\t\t\t\t\t    \\\nDEBUGFS_STRUCT(_name, 0600,\t\t\t\t\t\t    \\\n\t       thunderx_##_type##_##_name##_write,\t\t\t    \\\n\t       thunderx_##_type##_##_name##_read)\n\n#define LMC_DEBUGFS_ENT(_field)\tDEBUGFS_FIELD_ATTR(lmc, _field)\n\n \nstatic ssize_t thunderx_lmc_inject_int_write(struct file *file,\n\t\t\t\t\t     const char __user *data,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct thunderx_lmc *lmc = file->private_data;\n\tu64 val;\n\tint res;\n\n\tres = kstrtoull_from_user(data, count, 0, &val);\n\n\tif (!res) {\n\t\t \n\t\twriteq(val, lmc->regs + LMC_INT_W1S);\n\t\tres = count;\n\t}\n\n\treturn res;\n}\n\nstatic ssize_t thunderx_lmc_int_read(struct file *file,\n\t\t\t\t     char __user *data,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct thunderx_lmc *lmc = file->private_data;\n\tchar buf[20];\n\tu64 lmc_int = readq(lmc->regs + LMC_INT);\n\n\tsnprintf(buf, sizeof(buf), \"0x%016llx\", lmc_int);\n\treturn simple_read_from_buffer(data, count, ppos, buf, sizeof(buf));\n}\n\n#define TEST_PATTERN 0xa5\n\nstatic int inject_ecc_fn(void *arg)\n{\n\tstruct thunderx_lmc *lmc = arg;\n\tuintptr_t addr, phys;\n\tunsigned int cline_size = cache_line_size();\n\tconst unsigned int lines = PAGE_SIZE / cline_size;\n\tunsigned int i, cl_idx;\n\n\taddr = (uintptr_t)page_address(lmc->mem);\n\tphys = (uintptr_t)page_to_phys(lmc->mem);\n\n\tcl_idx = (phys & 0x7f) >> 4;\n\tlmc->parity_test &= ~(7ULL << 8);\n\tlmc->parity_test |= (cl_idx << 8);\n\n\twriteq(lmc->mask0, lmc->regs + LMC_CHAR_MASK0);\n\twriteq(lmc->mask2, lmc->regs + LMC_CHAR_MASK2);\n\twriteq(lmc->parity_test, lmc->regs + LMC_ECC_PARITY_TEST);\n\n\treadq(lmc->regs + LMC_CHAR_MASK0);\n\treadq(lmc->regs + LMC_CHAR_MASK2);\n\treadq(lmc->regs + LMC_ECC_PARITY_TEST);\n\n\tfor (i = 0; i < lines; i++) {\n\t\tmemset((void *)addr, TEST_PATTERN, cline_size);\n\t\tbarrier();\n\n\t\t \n\t\tasm volatile(\"dc civac, %0\\n\"\n\t\t\t     \"dsb sy\\n\"\n\t\t\t     : : \"r\"(addr + i * cline_size));\n\t}\n\n\tfor (i = 0; i < lines; i++) {\n\t\t \n\t\t__asm__ volatile(\"sys #0,c11,C1,#2, %0\\n\"\n\t\t\t\t : : \"r\"(phys + i * cline_size));\n\t}\n\n\tfor (i = 0; i < lines; i++) {\n\t\t \n\t\t__asm__ volatile(\"sys #0,c11,C1,#1, %0\"\n\t\t\t\t : : \"r\"(phys + i * cline_size));\n\t}\n\n\tfor (i = 0; i < lines; i++) {\n\t\t \n\t\tasm volatile(\"dc ivac, %0\\n\"\n\t\t\t     \"dsb sy\\n\"\n\t\t\t     : : \"r\"(addr + i * cline_size));\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t thunderx_lmc_inject_ecc_write(struct file *file,\n\t\t\t\t\t     const char __user *data,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct thunderx_lmc *lmc = file->private_data;\n\tunsigned int cline_size = cache_line_size();\n\tu8 *tmp;\n\tvoid __iomem *addr;\n\tunsigned int offs, timeout = 100000;\n\n\tatomic_set(&lmc->ecc_int, 0);\n\n\tlmc->mem = alloc_pages_node(lmc->node, GFP_KERNEL, 0);\n\tif (!lmc->mem)\n\t\treturn -ENOMEM;\n\n\ttmp = kmalloc(cline_size, GFP_KERNEL);\n\tif (!tmp) {\n\t\t__free_pages(lmc->mem, 0);\n\t\treturn -ENOMEM;\n\t}\n\n\taddr = page_address(lmc->mem);\n\n\twhile (!atomic_read(&lmc->ecc_int) && timeout--) {\n\t\tstop_machine(inject_ecc_fn, lmc, NULL);\n\n\t\tfor (offs = 0; offs < PAGE_SIZE; offs += cline_size) {\n\t\t\t \n\t\t\tmemcpy(tmp, addr + offs, cline_size);\n\t\t\tasm volatile(\"dsb ld\\n\");\n\t\t}\n\t}\n\n\tkfree(tmp);\n\t__free_pages(lmc->mem, 0);\n\n\treturn count;\n}\n\nLMC_DEBUGFS_ENT(mask0);\nLMC_DEBUGFS_ENT(mask2);\nLMC_DEBUGFS_ENT(parity_test);\n\nDEBUGFS_STRUCT(inject_int, 0200, thunderx_lmc_inject_int_write, NULL);\nDEBUGFS_STRUCT(inject_ecc, 0200, thunderx_lmc_inject_ecc_write, NULL);\nDEBUGFS_STRUCT(int_w1c, 0400, NULL, thunderx_lmc_int_read);\n\nstatic struct debugfs_entry *lmc_dfs_ents[] = {\n\t&debugfs_mask0,\n\t&debugfs_mask2,\n\t&debugfs_parity_test,\n\t&debugfs_inject_ecc,\n\t&debugfs_inject_int,\n\t&debugfs_int_w1c,\n};\n\nstatic int thunderx_create_debugfs_nodes(struct dentry *parent,\n\t\t\t\t\t  struct debugfs_entry *attrs[],\n\t\t\t\t\t  void *data,\n\t\t\t\t\t  size_t num)\n{\n\tint i;\n\tstruct dentry *ent;\n\n\tif (!IS_ENABLED(CONFIG_EDAC_DEBUG))\n\t\treturn 0;\n\n\tif (!parent)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < num; i++) {\n\t\tent = edac_debugfs_create_file(attrs[i]->name, attrs[i]->mode,\n\t\t\t\t\t       parent, data, &attrs[i]->fops);\n\n\t\tif (IS_ERR(ent))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic phys_addr_t thunderx_faddr_to_phys(u64 faddr, struct thunderx_lmc *lmc)\n{\n\tphys_addr_t addr = 0;\n\tint bank, xbits;\n\n\taddr |= lmc->node << 40;\n\taddr |= LMC_FADR_FDIMM(faddr) << lmc->dimm_lsb;\n\taddr |= LMC_FADR_FBUNK(faddr) << lmc->rank_lsb;\n\taddr |= LMC_FADR_FROW(faddr) << lmc->row_lsb;\n\taddr |= (LMC_FADR_FCOL(faddr) >> 4) << lmc->col_hi_lsb;\n\n\tbank = LMC_FADR_FBANK(faddr) << lmc->bank_lsb;\n\n\tif (lmc->xor_bank)\n\t\tbank ^= get_bits(addr, 12 + lmc->xbits, lmc->bank_width);\n\n\taddr |= bank << lmc->bank_lsb;\n\n\txbits = PCI_FUNC(lmc->pdev->devfn);\n\n\tif (lmc->l2c_alias)\n\t\txbits ^= get_bits(addr, 20, lmc->xbits) ^\n\t\t\t get_bits(addr, 12, lmc->xbits);\n\n\taddr |= xbits << 7;\n\n\treturn addr;\n}\n\nstatic unsigned int thunderx_get_num_lmcs(unsigned int node)\n{\n\tunsigned int number = 0;\n\tstruct pci_dev *pdev = NULL;\n\n\tdo {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t\t      PCI_DEVICE_ID_THUNDER_LMC,\n\t\t\t\t      pdev);\n\t\tif (pdev) {\n#ifdef CONFIG_NUMA\n\t\t\tif (pdev->dev.numa_node == node)\n\t\t\t\tnumber++;\n#else\n\t\t\tnumber++;\n#endif\n\t\t}\n\t} while (pdev);\n\n\treturn number;\n}\n\n#define LMC_MESSAGE_SIZE\t120\n#define LMC_OTHER_SIZE\t\t(50 * ARRAY_SIZE(lmc_errors))\n\nstatic irqreturn_t thunderx_lmc_err_isr(int irq, void *dev_id)\n{\n\tstruct mem_ctl_info *mci = dev_id;\n\tstruct thunderx_lmc *lmc = mci->pvt_info;\n\n\tunsigned long head = ring_pos(lmc->ring_head, ARRAY_SIZE(lmc->err_ctx));\n\tstruct lmc_err_ctx *ctx = &lmc->err_ctx[head];\n\n\twriteq(0, lmc->regs + LMC_CHAR_MASK0);\n\twriteq(0, lmc->regs + LMC_CHAR_MASK2);\n\twriteq(0x2, lmc->regs + LMC_ECC_PARITY_TEST);\n\n\tctx->reg_int = readq(lmc->regs + LMC_INT);\n\tctx->reg_fadr = readq(lmc->regs + LMC_FADR);\n\tctx->reg_nxm_fadr = readq(lmc->regs + LMC_NXM_FADR);\n\tctx->reg_scram_fadr = readq(lmc->regs + LMC_SCRAM_FADR);\n\tctx->reg_ecc_synd = readq(lmc->regs + LMC_ECC_SYND);\n\n\tlmc->ring_head++;\n\n\tatomic_set(&lmc->ecc_int, 1);\n\n\t \n\twriteq(ctx->reg_int, lmc->regs + LMC_INT);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t thunderx_lmc_threaded_isr(int irq, void *dev_id)\n{\n\tstruct mem_ctl_info *mci = dev_id;\n\tstruct thunderx_lmc *lmc = mci->pvt_info;\n\tphys_addr_t phys_addr;\n\n\tunsigned long tail;\n\tstruct lmc_err_ctx *ctx;\n\n\tirqreturn_t ret = IRQ_NONE;\n\n\tchar *msg;\n\tchar *other;\n\n\tmsg = kmalloc(LMC_MESSAGE_SIZE, GFP_KERNEL);\n\tother =  kmalloc(LMC_OTHER_SIZE, GFP_KERNEL);\n\n\tif (!msg || !other)\n\t\tgoto err_free;\n\n\twhile (CIRC_CNT(lmc->ring_head, lmc->ring_tail,\n\t\tARRAY_SIZE(lmc->err_ctx))) {\n\t\ttail = ring_pos(lmc->ring_tail, ARRAY_SIZE(lmc->err_ctx));\n\n\t\tctx = &lmc->err_ctx[tail];\n\n\t\tdev_dbg(&lmc->pdev->dev, \"LMC_INT: %016llx\\n\",\n\t\t\tctx->reg_int);\n\t\tdev_dbg(&lmc->pdev->dev, \"LMC_FADR: %016llx\\n\",\n\t\t\tctx->reg_fadr);\n\t\tdev_dbg(&lmc->pdev->dev, \"LMC_NXM_FADR: %016llx\\n\",\n\t\t\tctx->reg_nxm_fadr);\n\t\tdev_dbg(&lmc->pdev->dev, \"LMC_SCRAM_FADR: %016llx\\n\",\n\t\t\tctx->reg_scram_fadr);\n\t\tdev_dbg(&lmc->pdev->dev, \"LMC_ECC_SYND: %016llx\\n\",\n\t\t\tctx->reg_ecc_synd);\n\n\t\tsnprintf(msg, LMC_MESSAGE_SIZE,\n\t\t\t \"DIMM %lld rank %lld bank %lld row %lld col %lld\",\n\t\t\t LMC_FADR_FDIMM(ctx->reg_scram_fadr),\n\t\t\t LMC_FADR_FBUNK(ctx->reg_scram_fadr),\n\t\t\t LMC_FADR_FBANK(ctx->reg_scram_fadr),\n\t\t\t LMC_FADR_FROW(ctx->reg_scram_fadr),\n\t\t\t LMC_FADR_FCOL(ctx->reg_scram_fadr));\n\n\t\tdecode_register(other, LMC_OTHER_SIZE, lmc_errors,\n\t\t\t\tctx->reg_int);\n\n\t\tphys_addr = thunderx_faddr_to_phys(ctx->reg_fadr, lmc);\n\n\t\tif (ctx->reg_int & LMC_INT_UE)\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\t     phys_to_pfn(phys_addr),\n\t\t\t\t\t     offset_in_page(phys_addr),\n\t\t\t\t\t     0, -1, -1, -1, msg, other);\n\t\telse if (ctx->reg_int & LMC_INT_CE)\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t\t     phys_to_pfn(phys_addr),\n\t\t\t\t\t     offset_in_page(phys_addr),\n\t\t\t\t\t     0, -1, -1, -1, msg, other);\n\n\t\tlmc->ring_tail++;\n\t}\n\n\tret = IRQ_HANDLED;\n\nerr_free:\n\tkfree(msg);\n\tkfree(other);\n\n\treturn ret;\n}\n\nstatic const struct pci_device_id thunderx_lmc_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_LMC) },\n\t{ 0, },\n};\n\nstatic inline int pci_dev_to_mc_idx(struct pci_dev *pdev)\n{\n\tint node = dev_to_node(&pdev->dev);\n\tint ret = PCI_FUNC(pdev->devfn);\n\n\tret += max(node, 0) << 3;\n\n\treturn ret;\n}\n\nstatic int thunderx_lmc_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\tstruct thunderx_lmc *lmc;\n\tstruct edac_mc_layer layer;\n\tstruct mem_ctl_info *mci;\n\tu64 lmc_control, lmc_ddr_pll_ctl, lmc_config;\n\tint ret;\n\tu64 lmc_int;\n\tvoid *l2c_ioaddr;\n\n\tlayer.type = EDAC_MC_LAYER_SLOT;\n\tlayer.size = 2;\n\tlayer.is_virt_csrow = false;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, BIT(0), \"thunderx_lmc\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot map PCI resources: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmci = edac_mc_alloc(pci_dev_to_mc_idx(pdev), 1, &layer,\n\t\t\t    sizeof(struct thunderx_lmc));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tmci->pdev = &pdev->dev;\n\tlmc = mci->pvt_info;\n\n\tpci_set_drvdata(pdev, mci);\n\n\tlmc->regs = pcim_iomap_table(pdev)[0];\n\n\tlmc_control = readq(lmc->regs + LMC_CONTROL);\n\tlmc_ddr_pll_ctl = readq(lmc->regs + LMC_DDR_PLL_CTL);\n\tlmc_config = readq(lmc->regs + LMC_CONFIG);\n\n\tif (lmc_control & LMC_CONTROL_RDIMM) {\n\t\tmci->mtype_cap = FIELD_GET(LMC_DDR_PLL_CTL_DDR4,\n\t\t\t\t\t   lmc_ddr_pll_ctl) ?\n\t\t\t\tMEM_RDDR4 : MEM_RDDR3;\n\t} else {\n\t\tmci->mtype_cap = FIELD_GET(LMC_DDR_PLL_CTL_DDR4,\n\t\t\t\t\t   lmc_ddr_pll_ctl) ?\n\t\t\t\tMEM_DDR4 : MEM_DDR3;\n\t}\n\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\n\tmci->mod_name = \"thunderx-lmc\";\n\tmci->ctl_name = \"thunderx-lmc\";\n\tmci->dev_name = dev_name(&pdev->dev);\n\tmci->scrub_mode = SCRUB_NONE;\n\n\tlmc->pdev = pdev;\n\tlmc->msix_ent.entry = 0;\n\n\tlmc->ring_head = 0;\n\tlmc->ring_tail = 0;\n\n\tret = pci_enable_msix_exact(pdev, &lmc->msix_ent, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot enable interrupt: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, lmc->msix_ent.vector,\n\t\t\t\t\tthunderx_lmc_err_isr,\n\t\t\t\t\tthunderx_lmc_threaded_isr, 0,\n\t\t\t\t\t\"[EDAC] ThunderX LMC\", mci);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot set ISR: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tlmc->node = FIELD_GET(THUNDERX_NODE, pci_resource_start(pdev, 0));\n\n\tlmc->xbits = thunderx_get_num_lmcs(lmc->node) >> 1;\n\tlmc->bank_width = (FIELD_GET(LMC_DDR_PLL_CTL_DDR4, lmc_ddr_pll_ctl) &&\n\t\t\t   FIELD_GET(LMC_CONFIG_BG2, lmc_config)) ? 4 : 3;\n\n\tlmc->pbank_lsb = (lmc_config >> 5) & 0xf;\n\tlmc->dimm_lsb  = 28 + lmc->pbank_lsb + lmc->xbits;\n\tlmc->rank_lsb = lmc->dimm_lsb;\n\tlmc->rank_lsb -= FIELD_GET(LMC_CONFIG_RANK_ENA, lmc_config) ? 1 : 0;\n\tlmc->bank_lsb = 7 + lmc->xbits;\n\tlmc->row_lsb = 14 + LMC_CONFIG_ROW_LSB(lmc_config) + lmc->xbits;\n\n\tlmc->col_hi_lsb = lmc->bank_lsb + lmc->bank_width;\n\n\tlmc->xor_bank = lmc_control & LMC_CONTROL_XOR_BANK;\n\n\tl2c_ioaddr = ioremap(L2C_CTL | FIELD_PREP(THUNDERX_NODE, lmc->node), PAGE_SIZE);\n\tif (!l2c_ioaddr) {\n\t\tdev_err(&pdev->dev, \"Cannot map L2C_CTL\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tlmc->l2c_alias = !(readq(l2c_ioaddr) & L2C_CTL_DISIDXALIAS);\n\n\tiounmap(l2c_ioaddr);\n\n\tret = edac_mc_add_mc(mci);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot add the MC: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tlmc_int = readq(lmc->regs + LMC_INT);\n\twriteq(lmc_int, lmc->regs + LMC_INT);\n\n\twriteq(LMC_INT_ENA_ALL, lmc->regs + LMC_INT_ENA_W1S);\n\n\tif (IS_ENABLED(CONFIG_EDAC_DEBUG)) {\n\t\tret = thunderx_create_debugfs_nodes(mci->debugfs,\n\t\t\t\t\t\t    lmc_dfs_ents,\n\t\t\t\t\t\t    lmc,\n\t\t\t\t\t\t    ARRAY_SIZE(lmc_dfs_ents));\n\n\t\tif (ret != ARRAY_SIZE(lmc_dfs_ents)) {\n\t\t\tdev_warn(&pdev->dev, \"Error creating debugfs entries: %d%s\\n\",\n\t\t\t\t ret, ret >= 0 ? \" created\" : \"\");\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free:\n\tpci_set_drvdata(pdev, NULL);\n\tedac_mc_free(mci);\n\n\treturn ret;\n}\n\nstatic void thunderx_lmc_remove(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci = pci_get_drvdata(pdev);\n\tstruct thunderx_lmc *lmc = mci->pvt_info;\n\n\twriteq(LMC_INT_ENA_ALL, lmc->regs + LMC_INT_ENA_W1C);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n}\n\nMODULE_DEVICE_TABLE(pci, thunderx_lmc_pci_tbl);\n\nstatic struct pci_driver thunderx_lmc_driver = {\n\t.name     = \"thunderx_lmc_edac\",\n\t.probe    = thunderx_lmc_probe,\n\t.remove   = thunderx_lmc_remove,\n\t.id_table = thunderx_lmc_pci_tbl,\n};\n\n \n\n#define PCI_DEVICE_ID_THUNDER_OCX 0xa013\n\n#define OCX_LINK_INTS\t\t3\n#define OCX_INTS\t\t(OCX_LINK_INTS + 1)\n#define OCX_RX_LANES\t\t24\n#define OCX_RX_LANE_STATS\t15\n\n#define OCX_COM_INT\t\t0x100\n#define OCX_COM_INT_W1S\t\t0x108\n#define OCX_COM_INT_ENA_W1S\t0x110\n#define OCX_COM_INT_ENA_W1C\t0x118\n\n#define OCX_COM_IO_BADID\t\tBIT(54)\n#define OCX_COM_MEM_BADID\t\tBIT(53)\n#define OCX_COM_COPR_BADID\t\tBIT(52)\n#define OCX_COM_WIN_REQ_BADID\t\tBIT(51)\n#define OCX_COM_WIN_REQ_TOUT\t\tBIT(50)\n#define OCX_COM_RX_LANE\t\t\tGENMASK(23, 0)\n\n#define OCX_COM_INT_CE\t\t\t(OCX_COM_IO_BADID      | \\\n\t\t\t\t\t OCX_COM_MEM_BADID     | \\\n\t\t\t\t\t OCX_COM_COPR_BADID    | \\\n\t\t\t\t\t OCX_COM_WIN_REQ_BADID | \\\n\t\t\t\t\t OCX_COM_WIN_REQ_TOUT)\n\nstatic const struct error_descr ocx_com_errors[] = {\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_IO_BADID,\n\t\t.descr = \"Invalid IO transaction node ID\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_MEM_BADID,\n\t\t.descr = \"Invalid memory transaction node ID\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_COPR_BADID,\n\t\t.descr = \"Invalid coprocessor transaction node ID\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_WIN_REQ_BADID,\n\t\t.descr = \"Invalid SLI transaction node ID\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_WIN_REQ_TOUT,\n\t\t.descr = \"Window/core request timeout\",\n\t},\n\t{0, 0, NULL},\n};\n\n#define OCX_COM_LINKX_INT(x)\t\t(0x120 + (x) * 8)\n#define OCX_COM_LINKX_INT_W1S(x)\t(0x140 + (x) * 8)\n#define OCX_COM_LINKX_INT_ENA_W1S(x)\t(0x160 + (x) * 8)\n#define OCX_COM_LINKX_INT_ENA_W1C(x)\t(0x180 + (x) * 8)\n\n#define OCX_COM_LINK_BAD_WORD\t\t\tBIT(13)\n#define OCX_COM_LINK_ALIGN_FAIL\t\t\tBIT(12)\n#define OCX_COM_LINK_ALIGN_DONE\t\t\tBIT(11)\n#define OCX_COM_LINK_UP\t\t\t\tBIT(10)\n#define OCX_COM_LINK_STOP\t\t\tBIT(9)\n#define OCX_COM_LINK_BLK_ERR\t\t\tBIT(8)\n#define OCX_COM_LINK_REINIT\t\t\tBIT(7)\n#define OCX_COM_LINK_LNK_DATA\t\t\tBIT(6)\n#define OCX_COM_LINK_RXFIFO_DBE\t\t\tBIT(5)\n#define OCX_COM_LINK_RXFIFO_SBE\t\t\tBIT(4)\n#define OCX_COM_LINK_TXFIFO_DBE\t\t\tBIT(3)\n#define OCX_COM_LINK_TXFIFO_SBE\t\t\tBIT(2)\n#define OCX_COM_LINK_REPLAY_DBE\t\t\tBIT(1)\n#define OCX_COM_LINK_REPLAY_SBE\t\t\tBIT(0)\n\nstatic const struct error_descr ocx_com_link_errors[] = {\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_LINK_REPLAY_SBE,\n\t\t.descr = \"Replay buffer single-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_LINK_TXFIFO_SBE,\n\t\t.descr = \"TX FIFO single-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_LINK_RXFIFO_SBE,\n\t\t.descr = \"RX FIFO single-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_LINK_BLK_ERR,\n\t\t.descr = \"Block code error\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_LINK_ALIGN_FAIL,\n\t\t.descr = \"Link alignment failure\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_COM_LINK_BAD_WORD,\n\t\t.descr = \"Bad code word\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = OCX_COM_LINK_REPLAY_DBE,\n\t\t.descr = \"Replay buffer double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = OCX_COM_LINK_TXFIFO_DBE,\n\t\t.descr = \"TX FIFO double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = OCX_COM_LINK_RXFIFO_DBE,\n\t\t.descr = \"RX FIFO double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = OCX_COM_LINK_STOP,\n\t\t.descr = \"Link stopped\",\n\t},\n\t{0, 0, NULL},\n};\n\n#define OCX_COM_LINK_INT_UE       (OCX_COM_LINK_REPLAY_DBE | \\\n\t\t\t\t   OCX_COM_LINK_TXFIFO_DBE | \\\n\t\t\t\t   OCX_COM_LINK_RXFIFO_DBE | \\\n\t\t\t\t   OCX_COM_LINK_STOP)\n\n#define OCX_COM_LINK_INT_CE       (OCX_COM_LINK_REPLAY_SBE | \\\n\t\t\t\t   OCX_COM_LINK_TXFIFO_SBE | \\\n\t\t\t\t   OCX_COM_LINK_RXFIFO_SBE | \\\n\t\t\t\t   OCX_COM_LINK_BLK_ERR    | \\\n\t\t\t\t   OCX_COM_LINK_ALIGN_FAIL | \\\n\t\t\t\t   OCX_COM_LINK_BAD_WORD)\n\n#define OCX_LNE_INT(x)\t\t\t(0x8018 + (x) * 0x100)\n#define OCX_LNE_INT_EN(x)\t\t(0x8020 + (x) * 0x100)\n#define OCX_LNE_BAD_CNT(x)\t\t(0x8028 + (x) * 0x100)\n#define OCX_LNE_CFG(x)\t\t\t(0x8000 + (x) * 0x100)\n#define OCX_LNE_STAT(x, y)\t\t(0x8040 + (x) * 0x100 + (y) * 8)\n\n#define OCX_LNE_CFG_RX_BDRY_LOCK_DIS\t\tBIT(8)\n#define OCX_LNE_CFG_RX_STAT_WRAP_DIS\t\tBIT(2)\n#define OCX_LNE_CFG_RX_STAT_RDCLR\t\tBIT(1)\n#define OCX_LNE_CFG_RX_STAT_ENA\t\t\tBIT(0)\n\n\n#define OCX_LANE_BAD_64B67B\t\t\tBIT(8)\n#define OCX_LANE_DSKEW_FIFO_OVFL\t\tBIT(5)\n#define OCX_LANE_SCRM_SYNC_LOSS\t\t\tBIT(4)\n#define OCX_LANE_UKWN_CNTL_WORD\t\t\tBIT(3)\n#define OCX_LANE_CRC32_ERR\t\t\tBIT(2)\n#define OCX_LANE_BDRY_SYNC_LOSS\t\t\tBIT(1)\n#define OCX_LANE_SERDES_LOCK_LOSS\t\tBIT(0)\n\n#define OCX_COM_LANE_INT_UE       (0)\n#define OCX_COM_LANE_INT_CE       (OCX_LANE_SERDES_LOCK_LOSS | \\\n\t\t\t\t   OCX_LANE_BDRY_SYNC_LOSS   | \\\n\t\t\t\t   OCX_LANE_CRC32_ERR        | \\\n\t\t\t\t   OCX_LANE_UKWN_CNTL_WORD   | \\\n\t\t\t\t   OCX_LANE_SCRM_SYNC_LOSS   | \\\n\t\t\t\t   OCX_LANE_DSKEW_FIFO_OVFL  | \\\n\t\t\t\t   OCX_LANE_BAD_64B67B)\n\nstatic const struct error_descr ocx_lane_errors[] = {\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_LANE_SERDES_LOCK_LOSS,\n\t\t.descr = \"RX SerDes lock lost\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_LANE_BDRY_SYNC_LOSS,\n\t\t.descr = \"RX word boundary lost\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_LANE_CRC32_ERR,\n\t\t.descr = \"CRC32 error\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_LANE_UKWN_CNTL_WORD,\n\t\t.descr = \"Unknown control word\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_LANE_SCRM_SYNC_LOSS,\n\t\t.descr = \"Scrambler synchronization lost\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_LANE_DSKEW_FIFO_OVFL,\n\t\t.descr = \"RX deskew FIFO overflow\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = OCX_LANE_BAD_64B67B,\n\t\t.descr = \"Bad 64B/67B codeword\",\n\t},\n\t{0, 0, NULL},\n};\n\n#define OCX_LNE_INT_ENA_ALL\t\t(GENMASK(9, 8) | GENMASK(6, 0))\n#define OCX_COM_INT_ENA_ALL\t\t(GENMASK(54, 50) | GENMASK(23, 0))\n#define OCX_COM_LINKX_INT_ENA_ALL\t(GENMASK(13, 12) | \\\n\t\t\t\t\t GENMASK(9, 7) | GENMASK(5, 0))\n\n#define OCX_TLKX_ECC_CTL(x)\t\t(0x10018 + (x) * 0x2000)\n#define OCX_RLKX_ECC_CTL(x)\t\t(0x18018 + (x) * 0x2000)\n\nstruct ocx_com_err_ctx {\n\tu64 reg_com_int;\n\tu64 reg_lane_int[OCX_RX_LANES];\n\tu64 reg_lane_stat11[OCX_RX_LANES];\n};\n\nstruct ocx_link_err_ctx {\n\tu64 reg_com_link_int;\n\tint link;\n};\n\nstruct thunderx_ocx {\n\tvoid __iomem *regs;\n\tint com_link;\n\tstruct pci_dev *pdev;\n\tstruct edac_device_ctl_info *edac_dev;\n\n\tstruct dentry *debugfs;\n\tstruct msix_entry msix_ent[OCX_INTS];\n\n\tstruct ocx_com_err_ctx com_err_ctx[RING_ENTRIES];\n\tstruct ocx_link_err_ctx link_err_ctx[RING_ENTRIES];\n\n\tunsigned long com_ring_head;\n\tunsigned long com_ring_tail;\n\n\tunsigned long link_ring_head;\n\tunsigned long link_ring_tail;\n};\n\n#define OCX_MESSAGE_SIZE\tSZ_1K\n#define OCX_OTHER_SIZE\t\t(50 * ARRAY_SIZE(ocx_com_link_errors))\n\n \nstatic irqreturn_t thunderx_ocx_com_isr(int irq, void *irq_id)\n{\n\tstruct msix_entry *msix = irq_id;\n\tstruct thunderx_ocx *ocx = container_of(msix, struct thunderx_ocx,\n\t\t\t\t\t\tmsix_ent[msix->entry]);\n\n\tint lane;\n\tunsigned long head = ring_pos(ocx->com_ring_head,\n\t\t\t\t      ARRAY_SIZE(ocx->com_err_ctx));\n\tstruct ocx_com_err_ctx *ctx = &ocx->com_err_ctx[head];\n\n\tctx->reg_com_int = readq(ocx->regs + OCX_COM_INT);\n\n\tfor (lane = 0; lane < OCX_RX_LANES; lane++) {\n\t\tctx->reg_lane_int[lane] =\n\t\t\treadq(ocx->regs + OCX_LNE_INT(lane));\n\t\tctx->reg_lane_stat11[lane] =\n\t\t\treadq(ocx->regs + OCX_LNE_STAT(lane, 11));\n\n\t\twriteq(ctx->reg_lane_int[lane], ocx->regs + OCX_LNE_INT(lane));\n\t}\n\n\twriteq(ctx->reg_com_int, ocx->regs + OCX_COM_INT);\n\n\tocx->com_ring_head++;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t thunderx_ocx_com_threaded_isr(int irq, void *irq_id)\n{\n\tstruct msix_entry *msix = irq_id;\n\tstruct thunderx_ocx *ocx = container_of(msix, struct thunderx_ocx,\n\t\t\t\t\t\tmsix_ent[msix->entry]);\n\n\tirqreturn_t ret = IRQ_NONE;\n\n\tunsigned long tail;\n\tstruct ocx_com_err_ctx *ctx;\n\tint lane;\n\tchar *msg;\n\tchar *other;\n\n\tmsg = kmalloc(OCX_MESSAGE_SIZE, GFP_KERNEL);\n\tother = kmalloc(OCX_OTHER_SIZE, GFP_KERNEL);\n\n\tif (!msg || !other)\n\t\tgoto err_free;\n\n\twhile (CIRC_CNT(ocx->com_ring_head, ocx->com_ring_tail,\n\t\t\tARRAY_SIZE(ocx->com_err_ctx))) {\n\t\ttail = ring_pos(ocx->com_ring_tail,\n\t\t\t\tARRAY_SIZE(ocx->com_err_ctx));\n\t\tctx = &ocx->com_err_ctx[tail];\n\n\t\tsnprintf(msg, OCX_MESSAGE_SIZE, \"%s: OCX_COM_INT: %016llx\",\n\t\t\tocx->edac_dev->ctl_name, ctx->reg_com_int);\n\n\t\tdecode_register(other, OCX_OTHER_SIZE,\n\t\t\t\tocx_com_errors, ctx->reg_com_int);\n\n\t\tstrlcat(msg, other, OCX_MESSAGE_SIZE);\n\n\t\tfor (lane = 0; lane < OCX_RX_LANES; lane++)\n\t\t\tif (ctx->reg_com_int & BIT(lane)) {\n\t\t\t\tsnprintf(other, OCX_OTHER_SIZE,\n\t\t\t\t\t \"\\n\\tOCX_LNE_INT[%02d]: %016llx OCX_LNE_STAT11[%02d]: %016llx\",\n\t\t\t\t\t lane, ctx->reg_lane_int[lane],\n\t\t\t\t\t lane, ctx->reg_lane_stat11[lane]);\n\n\t\t\t\tstrlcat(msg, other, OCX_MESSAGE_SIZE);\n\n\t\t\t\tdecode_register(other, OCX_OTHER_SIZE,\n\t\t\t\t\t\tocx_lane_errors,\n\t\t\t\t\t\tctx->reg_lane_int[lane]);\n\t\t\t\tstrlcat(msg, other, OCX_MESSAGE_SIZE);\n\t\t\t}\n\n\t\tif (ctx->reg_com_int & OCX_COM_INT_CE)\n\t\t\tedac_device_handle_ce(ocx->edac_dev, 0, 0, msg);\n\n\t\tocx->com_ring_tail++;\n\t}\n\n\tret = IRQ_HANDLED;\n\nerr_free:\n\tkfree(other);\n\tkfree(msg);\n\n\treturn ret;\n}\n\nstatic irqreturn_t thunderx_ocx_lnk_isr(int irq, void *irq_id)\n{\n\tstruct msix_entry *msix = irq_id;\n\tstruct thunderx_ocx *ocx = container_of(msix, struct thunderx_ocx,\n\t\t\t\t\t\tmsix_ent[msix->entry]);\n\tunsigned long head = ring_pos(ocx->link_ring_head,\n\t\t\t\t      ARRAY_SIZE(ocx->link_err_ctx));\n\tstruct ocx_link_err_ctx *ctx = &ocx->link_err_ctx[head];\n\n\tctx->link = msix->entry;\n\tctx->reg_com_link_int = readq(ocx->regs + OCX_COM_LINKX_INT(ctx->link));\n\n\twriteq(ctx->reg_com_link_int, ocx->regs + OCX_COM_LINKX_INT(ctx->link));\n\n\tocx->link_ring_head++;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t thunderx_ocx_lnk_threaded_isr(int irq, void *irq_id)\n{\n\tstruct msix_entry *msix = irq_id;\n\tstruct thunderx_ocx *ocx = container_of(msix, struct thunderx_ocx,\n\t\t\t\t\t\tmsix_ent[msix->entry]);\n\tirqreturn_t ret = IRQ_NONE;\n\tunsigned long tail;\n\tstruct ocx_link_err_ctx *ctx;\n\n\tchar *msg;\n\tchar *other;\n\n\tmsg = kmalloc(OCX_MESSAGE_SIZE, GFP_KERNEL);\n\tother = kmalloc(OCX_OTHER_SIZE, GFP_KERNEL);\n\n\tif (!msg || !other)\n\t\tgoto err_free;\n\n\twhile (CIRC_CNT(ocx->link_ring_head, ocx->link_ring_tail,\n\t\t\tARRAY_SIZE(ocx->link_err_ctx))) {\n\t\ttail = ring_pos(ocx->link_ring_head,\n\t\t\t\tARRAY_SIZE(ocx->link_err_ctx));\n\n\t\tctx = &ocx->link_err_ctx[tail];\n\n\t\tsnprintf(msg, OCX_MESSAGE_SIZE,\n\t\t\t \"%s: OCX_COM_LINK_INT[%d]: %016llx\",\n\t\t\t ocx->edac_dev->ctl_name,\n\t\t\t ctx->link, ctx->reg_com_link_int);\n\n\t\tdecode_register(other, OCX_OTHER_SIZE,\n\t\t\t\tocx_com_link_errors, ctx->reg_com_link_int);\n\n\t\tstrlcat(msg, other, OCX_MESSAGE_SIZE);\n\n\t\tif (ctx->reg_com_link_int & OCX_COM_LINK_INT_UE)\n\t\t\tedac_device_handle_ue(ocx->edac_dev, 0, 0, msg);\n\t\telse if (ctx->reg_com_link_int & OCX_COM_LINK_INT_CE)\n\t\t\tedac_device_handle_ce(ocx->edac_dev, 0, 0, msg);\n\n\t\tocx->link_ring_tail++;\n\t}\n\n\tret = IRQ_HANDLED;\nerr_free:\n\tkfree(other);\n\tkfree(msg);\n\n\treturn ret;\n}\n\n#define OCX_DEBUGFS_ATTR(_name, _reg)\tDEBUGFS_REG_ATTR(ocx, _name, _reg)\n\nOCX_DEBUGFS_ATTR(tlk0_ecc_ctl, OCX_TLKX_ECC_CTL(0));\nOCX_DEBUGFS_ATTR(tlk1_ecc_ctl, OCX_TLKX_ECC_CTL(1));\nOCX_DEBUGFS_ATTR(tlk2_ecc_ctl, OCX_TLKX_ECC_CTL(2));\n\nOCX_DEBUGFS_ATTR(rlk0_ecc_ctl, OCX_RLKX_ECC_CTL(0));\nOCX_DEBUGFS_ATTR(rlk1_ecc_ctl, OCX_RLKX_ECC_CTL(1));\nOCX_DEBUGFS_ATTR(rlk2_ecc_ctl, OCX_RLKX_ECC_CTL(2));\n\nOCX_DEBUGFS_ATTR(com_link0_int, OCX_COM_LINKX_INT_W1S(0));\nOCX_DEBUGFS_ATTR(com_link1_int, OCX_COM_LINKX_INT_W1S(1));\nOCX_DEBUGFS_ATTR(com_link2_int, OCX_COM_LINKX_INT_W1S(2));\n\nOCX_DEBUGFS_ATTR(lne00_badcnt, OCX_LNE_BAD_CNT(0));\nOCX_DEBUGFS_ATTR(lne01_badcnt, OCX_LNE_BAD_CNT(1));\nOCX_DEBUGFS_ATTR(lne02_badcnt, OCX_LNE_BAD_CNT(2));\nOCX_DEBUGFS_ATTR(lne03_badcnt, OCX_LNE_BAD_CNT(3));\nOCX_DEBUGFS_ATTR(lne04_badcnt, OCX_LNE_BAD_CNT(4));\nOCX_DEBUGFS_ATTR(lne05_badcnt, OCX_LNE_BAD_CNT(5));\nOCX_DEBUGFS_ATTR(lne06_badcnt, OCX_LNE_BAD_CNT(6));\nOCX_DEBUGFS_ATTR(lne07_badcnt, OCX_LNE_BAD_CNT(7));\n\nOCX_DEBUGFS_ATTR(lne08_badcnt, OCX_LNE_BAD_CNT(8));\nOCX_DEBUGFS_ATTR(lne09_badcnt, OCX_LNE_BAD_CNT(9));\nOCX_DEBUGFS_ATTR(lne10_badcnt, OCX_LNE_BAD_CNT(10));\nOCX_DEBUGFS_ATTR(lne11_badcnt, OCX_LNE_BAD_CNT(11));\nOCX_DEBUGFS_ATTR(lne12_badcnt, OCX_LNE_BAD_CNT(12));\nOCX_DEBUGFS_ATTR(lne13_badcnt, OCX_LNE_BAD_CNT(13));\nOCX_DEBUGFS_ATTR(lne14_badcnt, OCX_LNE_BAD_CNT(14));\nOCX_DEBUGFS_ATTR(lne15_badcnt, OCX_LNE_BAD_CNT(15));\n\nOCX_DEBUGFS_ATTR(lne16_badcnt, OCX_LNE_BAD_CNT(16));\nOCX_DEBUGFS_ATTR(lne17_badcnt, OCX_LNE_BAD_CNT(17));\nOCX_DEBUGFS_ATTR(lne18_badcnt, OCX_LNE_BAD_CNT(18));\nOCX_DEBUGFS_ATTR(lne19_badcnt, OCX_LNE_BAD_CNT(19));\nOCX_DEBUGFS_ATTR(lne20_badcnt, OCX_LNE_BAD_CNT(20));\nOCX_DEBUGFS_ATTR(lne21_badcnt, OCX_LNE_BAD_CNT(21));\nOCX_DEBUGFS_ATTR(lne22_badcnt, OCX_LNE_BAD_CNT(22));\nOCX_DEBUGFS_ATTR(lne23_badcnt, OCX_LNE_BAD_CNT(23));\n\nOCX_DEBUGFS_ATTR(com_int, OCX_COM_INT_W1S);\n\nstatic struct debugfs_entry *ocx_dfs_ents[] = {\n\t&debugfs_tlk0_ecc_ctl,\n\t&debugfs_tlk1_ecc_ctl,\n\t&debugfs_tlk2_ecc_ctl,\n\n\t&debugfs_rlk0_ecc_ctl,\n\t&debugfs_rlk1_ecc_ctl,\n\t&debugfs_rlk2_ecc_ctl,\n\n\t&debugfs_com_link0_int,\n\t&debugfs_com_link1_int,\n\t&debugfs_com_link2_int,\n\n\t&debugfs_lne00_badcnt,\n\t&debugfs_lne01_badcnt,\n\t&debugfs_lne02_badcnt,\n\t&debugfs_lne03_badcnt,\n\t&debugfs_lne04_badcnt,\n\t&debugfs_lne05_badcnt,\n\t&debugfs_lne06_badcnt,\n\t&debugfs_lne07_badcnt,\n\t&debugfs_lne08_badcnt,\n\t&debugfs_lne09_badcnt,\n\t&debugfs_lne10_badcnt,\n\t&debugfs_lne11_badcnt,\n\t&debugfs_lne12_badcnt,\n\t&debugfs_lne13_badcnt,\n\t&debugfs_lne14_badcnt,\n\t&debugfs_lne15_badcnt,\n\t&debugfs_lne16_badcnt,\n\t&debugfs_lne17_badcnt,\n\t&debugfs_lne18_badcnt,\n\t&debugfs_lne19_badcnt,\n\t&debugfs_lne20_badcnt,\n\t&debugfs_lne21_badcnt,\n\t&debugfs_lne22_badcnt,\n\t&debugfs_lne23_badcnt,\n\n\t&debugfs_com_int,\n};\n\nstatic const struct pci_device_id thunderx_ocx_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_OCX) },\n\t{ 0, },\n};\n\nstatic void thunderx_ocx_clearstats(struct thunderx_ocx *ocx)\n{\n\tint lane, stat, cfg;\n\n\tfor (lane = 0; lane < OCX_RX_LANES; lane++) {\n\t\tcfg = readq(ocx->regs + OCX_LNE_CFG(lane));\n\t\tcfg |= OCX_LNE_CFG_RX_STAT_RDCLR;\n\t\tcfg &= ~OCX_LNE_CFG_RX_STAT_ENA;\n\t\twriteq(cfg, ocx->regs + OCX_LNE_CFG(lane));\n\n\t\tfor (stat = 0; stat < OCX_RX_LANE_STATS; stat++)\n\t\t\treadq(ocx->regs + OCX_LNE_STAT(lane, stat));\n\t}\n}\n\nstatic int thunderx_ocx_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tstruct thunderx_ocx *ocx;\n\tstruct edac_device_ctl_info *edac_dev;\n\tchar name[32];\n\tint idx;\n\tint i;\n\tint ret;\n\tu64 reg;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, BIT(0), \"thunderx_ocx\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot map PCI resources: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tidx = edac_device_alloc_index();\n\tsnprintf(name, sizeof(name), \"OCX%d\", idx);\n\tedac_dev = edac_device_alloc_ctl_info(sizeof(struct thunderx_ocx),\n\t\t\t\t\t      name, 1, \"CCPI\", 1,\n\t\t\t\t\t      0, NULL, 0, idx);\n\tif (!edac_dev) {\n\t\tdev_err(&pdev->dev, \"Cannot allocate EDAC device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tocx = edac_dev->pvt_info;\n\tocx->edac_dev = edac_dev;\n\tocx->com_ring_head = 0;\n\tocx->com_ring_tail = 0;\n\tocx->link_ring_head = 0;\n\tocx->link_ring_tail = 0;\n\n\tocx->regs = pcim_iomap_table(pdev)[0];\n\tif (!ocx->regs) {\n\t\tdev_err(&pdev->dev, \"Cannot map PCI resources\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tocx->pdev = pdev;\n\n\tfor (i = 0; i < OCX_INTS; i++) {\n\t\tocx->msix_ent[i].entry = i;\n\t\tocx->msix_ent[i].vector = 0;\n\t}\n\n\tret = pci_enable_msix_exact(pdev, ocx->msix_ent, OCX_INTS);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot enable interrupt: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tfor (i = 0; i < OCX_INTS; i++) {\n\t\tret = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\t\t\tocx->msix_ent[i].vector,\n\t\t\t\t\t\t(i == 3) ?\n\t\t\t\t\t\t thunderx_ocx_com_isr :\n\t\t\t\t\t\t thunderx_ocx_lnk_isr,\n\t\t\t\t\t\t(i == 3) ?\n\t\t\t\t\t\t thunderx_ocx_com_threaded_isr :\n\t\t\t\t\t\t thunderx_ocx_lnk_threaded_isr,\n\t\t\t\t\t\t0, \"[EDAC] ThunderX OCX\",\n\t\t\t\t\t\t&ocx->msix_ent[i]);\n\t\tif (ret)\n\t\t\tgoto err_free;\n\t}\n\n\tedac_dev->dev = &pdev->dev;\n\tedac_dev->dev_name = dev_name(&pdev->dev);\n\tedac_dev->mod_name = \"thunderx-ocx\";\n\tedac_dev->ctl_name = \"thunderx-ocx\";\n\n\tret = edac_device_add_device(edac_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot add EDAC device: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tif (IS_ENABLED(CONFIG_EDAC_DEBUG)) {\n\t\tocx->debugfs = edac_debugfs_create_dir(pdev->dev.kobj.name);\n\n\t\tret = thunderx_create_debugfs_nodes(ocx->debugfs,\n\t\t\t\t\t\t    ocx_dfs_ents,\n\t\t\t\t\t\t    ocx,\n\t\t\t\t\t\t    ARRAY_SIZE(ocx_dfs_ents));\n\t\tif (ret != ARRAY_SIZE(ocx_dfs_ents)) {\n\t\t\tdev_warn(&pdev->dev, \"Error creating debugfs entries: %d%s\\n\",\n\t\t\t\t ret, ret >= 0 ? \" created\" : \"\");\n\t\t}\n\t}\n\n\tpci_set_drvdata(pdev, edac_dev);\n\n\tthunderx_ocx_clearstats(ocx);\n\n\tfor (i = 0; i < OCX_RX_LANES; i++) {\n\t\twriteq(OCX_LNE_INT_ENA_ALL,\n\t\t       ocx->regs + OCX_LNE_INT_EN(i));\n\n\t\treg = readq(ocx->regs + OCX_LNE_INT(i));\n\t\twriteq(reg, ocx->regs + OCX_LNE_INT(i));\n\n\t}\n\n\tfor (i = 0; i < OCX_LINK_INTS; i++) {\n\t\treg = readq(ocx->regs + OCX_COM_LINKX_INT(i));\n\t\twriteq(reg, ocx->regs + OCX_COM_LINKX_INT(i));\n\n\t\twriteq(OCX_COM_LINKX_INT_ENA_ALL,\n\t\t       ocx->regs + OCX_COM_LINKX_INT_ENA_W1S(i));\n\t}\n\n\treg = readq(ocx->regs + OCX_COM_INT);\n\twriteq(reg, ocx->regs + OCX_COM_INT);\n\n\twriteq(OCX_COM_INT_ENA_ALL, ocx->regs + OCX_COM_INT_ENA_W1S);\n\n\treturn 0;\nerr_free:\n\tedac_device_free_ctl_info(edac_dev);\n\n\treturn ret;\n}\n\nstatic void thunderx_ocx_remove(struct pci_dev *pdev)\n{\n\tstruct edac_device_ctl_info *edac_dev = pci_get_drvdata(pdev);\n\tstruct thunderx_ocx *ocx = edac_dev->pvt_info;\n\tint i;\n\n\twriteq(OCX_COM_INT_ENA_ALL, ocx->regs + OCX_COM_INT_ENA_W1C);\n\n\tfor (i = 0; i < OCX_INTS; i++) {\n\t\twriteq(OCX_COM_LINKX_INT_ENA_ALL,\n\t\t       ocx->regs + OCX_COM_LINKX_INT_ENA_W1C(i));\n\t}\n\n\tedac_debugfs_remove_recursive(ocx->debugfs);\n\n\tedac_device_del_device(&pdev->dev);\n\tedac_device_free_ctl_info(edac_dev);\n}\n\nMODULE_DEVICE_TABLE(pci, thunderx_ocx_pci_tbl);\n\nstatic struct pci_driver thunderx_ocx_driver = {\n\t.name     = \"thunderx_ocx_edac\",\n\t.probe    = thunderx_ocx_probe,\n\t.remove   = thunderx_ocx_remove,\n\t.id_table = thunderx_ocx_pci_tbl,\n};\n\n \n\n#define PCI_DEVICE_ID_THUNDER_L2C_TAD 0xa02e\n#define PCI_DEVICE_ID_THUNDER_L2C_CBC 0xa02f\n#define PCI_DEVICE_ID_THUNDER_L2C_MCI 0xa030\n\n#define L2C_TAD_INT_W1C\t\t0x40000\n#define L2C_TAD_INT_W1S\t\t0x40008\n\n#define L2C_TAD_INT_ENA_W1C\t0x40020\n#define L2C_TAD_INT_ENA_W1S\t0x40028\n\n\n#define L2C_TAD_INT_L2DDBE\t BIT(1)\n#define L2C_TAD_INT_SBFSBE\t BIT(2)\n#define L2C_TAD_INT_SBFDBE\t BIT(3)\n#define L2C_TAD_INT_FBFSBE\t BIT(4)\n#define L2C_TAD_INT_FBFDBE\t BIT(5)\n#define L2C_TAD_INT_TAGDBE\t BIT(9)\n#define L2C_TAD_INT_RDDISLMC\t BIT(15)\n#define L2C_TAD_INT_WRDISLMC\t BIT(16)\n#define L2C_TAD_INT_LFBTO\t BIT(17)\n#define L2C_TAD_INT_GSYNCTO\t BIT(18)\n#define L2C_TAD_INT_RTGSBE\t BIT(32)\n#define L2C_TAD_INT_RTGDBE\t BIT(33)\n#define L2C_TAD_INT_RDDISOCI\t BIT(34)\n#define L2C_TAD_INT_WRDISOCI\t BIT(35)\n\n#define L2C_TAD_INT_ECC\t\t(L2C_TAD_INT_L2DDBE | \\\n\t\t\t\t L2C_TAD_INT_SBFSBE | L2C_TAD_INT_SBFDBE | \\\n\t\t\t\t L2C_TAD_INT_FBFSBE | L2C_TAD_INT_FBFDBE)\n\n#define L2C_TAD_INT_CE          (L2C_TAD_INT_SBFSBE | \\\n\t\t\t\t L2C_TAD_INT_FBFSBE)\n\n#define L2C_TAD_INT_UE          (L2C_TAD_INT_L2DDBE | \\\n\t\t\t\t L2C_TAD_INT_SBFDBE | \\\n\t\t\t\t L2C_TAD_INT_FBFDBE | \\\n\t\t\t\t L2C_TAD_INT_TAGDBE | \\\n\t\t\t\t L2C_TAD_INT_RTGDBE | \\\n\t\t\t\t L2C_TAD_INT_WRDISOCI | \\\n\t\t\t\t L2C_TAD_INT_RDDISOCI | \\\n\t\t\t\t L2C_TAD_INT_WRDISLMC | \\\n\t\t\t\t L2C_TAD_INT_RDDISLMC | \\\n\t\t\t\t L2C_TAD_INT_LFBTO    | \\\n\t\t\t\t L2C_TAD_INT_GSYNCTO)\n\nstatic const struct error_descr l2_tad_errors[] = {\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = L2C_TAD_INT_SBFSBE,\n\t\t.descr = \"SBF single-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = L2C_TAD_INT_FBFSBE,\n\t\t.descr = \"FBF single-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_L2DDBE,\n\t\t.descr = \"L2D double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_SBFDBE,\n\t\t.descr = \"SBF double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_FBFDBE,\n\t\t.descr = \"FBF double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_TAGDBE,\n\t\t.descr = \"TAG double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_RTGDBE,\n\t\t.descr = \"RTG double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_WRDISOCI,\n\t\t.descr = \"Write to a disabled CCPI\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_RDDISOCI,\n\t\t.descr = \"Read from a disabled CCPI\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_WRDISLMC,\n\t\t.descr = \"Write to a disabled LMC\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_RDDISLMC,\n\t\t.descr = \"Read from a disabled LMC\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_LFBTO,\n\t\t.descr = \"LFB entry timeout\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_TAD_INT_GSYNCTO,\n\t\t.descr = \"Global sync CCPI timeout\",\n\t},\n\t{0, 0, NULL},\n};\n\n#define L2C_TAD_INT_TAG\t\t(L2C_TAD_INT_TAGDBE)\n\n#define L2C_TAD_INT_RTG\t\t(L2C_TAD_INT_RTGDBE)\n\n#define L2C_TAD_INT_DISLMC\t(L2C_TAD_INT_WRDISLMC | L2C_TAD_INT_RDDISLMC)\n\n#define L2C_TAD_INT_DISOCI\t(L2C_TAD_INT_WRDISOCI | L2C_TAD_INT_RDDISOCI)\n\n#define L2C_TAD_INT_ENA_ALL\t(L2C_TAD_INT_ECC | L2C_TAD_INT_TAG | \\\n\t\t\t\t L2C_TAD_INT_RTG | \\\n\t\t\t\t L2C_TAD_INT_DISLMC | L2C_TAD_INT_DISOCI | \\\n\t\t\t\t L2C_TAD_INT_LFBTO)\n\n#define L2C_TAD_TIMETWO\t\t0x50000\n#define L2C_TAD_TIMEOUT\t\t0x50100\n#define L2C_TAD_ERR\t\t0x60000\n#define L2C_TAD_TQD_ERR\t\t0x60100\n#define L2C_TAD_TTG_ERR\t\t0x60200\n\n\n#define L2C_CBC_INT_W1C\t\t0x60000\n\n#define L2C_CBC_INT_RSDSBE\t BIT(0)\n#define L2C_CBC_INT_RSDDBE\t BIT(1)\n\n#define L2C_CBC_INT_RSD\t\t (L2C_CBC_INT_RSDSBE | L2C_CBC_INT_RSDDBE)\n\n#define L2C_CBC_INT_MIBSBE\t BIT(4)\n#define L2C_CBC_INT_MIBDBE\t BIT(5)\n\n#define L2C_CBC_INT_MIB\t\t (L2C_CBC_INT_MIBSBE | L2C_CBC_INT_MIBDBE)\n\n#define L2C_CBC_INT_IORDDISOCI\t BIT(6)\n#define L2C_CBC_INT_IOWRDISOCI\t BIT(7)\n\n#define L2C_CBC_INT_IODISOCI\t (L2C_CBC_INT_IORDDISOCI | \\\n\t\t\t\t  L2C_CBC_INT_IOWRDISOCI)\n\n#define L2C_CBC_INT_CE\t\t (L2C_CBC_INT_RSDSBE | L2C_CBC_INT_MIBSBE)\n#define L2C_CBC_INT_UE\t\t (L2C_CBC_INT_RSDDBE | L2C_CBC_INT_MIBDBE)\n\n\nstatic const struct error_descr l2_cbc_errors[] = {\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = L2C_CBC_INT_RSDSBE,\n\t\t.descr = \"RSD single-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = L2C_CBC_INT_MIBSBE,\n\t\t.descr = \"MIB single-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_CBC_INT_RSDDBE,\n\t\t.descr = \"RSD double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_CBC_INT_MIBDBE,\n\t\t.descr = \"MIB double-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_CBC_INT_IORDDISOCI,\n\t\t.descr = \"Read from a disabled CCPI\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_CBC_INT_IOWRDISOCI,\n\t\t.descr = \"Write to a disabled CCPI\",\n\t},\n\t{0, 0, NULL},\n};\n\n#define L2C_CBC_INT_W1S\t\t0x60008\n#define L2C_CBC_INT_ENA_W1C\t0x60020\n\n#define L2C_CBC_INT_ENA_ALL\t (L2C_CBC_INT_RSD | L2C_CBC_INT_MIB | \\\n\t\t\t\t  L2C_CBC_INT_IODISOCI)\n\n#define L2C_CBC_INT_ENA_W1S\t0x60028\n\n#define L2C_CBC_IODISOCIERR\t0x80008\n#define L2C_CBC_IOCERR\t\t0x80010\n#define L2C_CBC_RSDERR\t\t0x80018\n#define L2C_CBC_MIBERR\t\t0x80020\n\n\n#define L2C_MCI_INT_W1C\t\t0x0\n\n#define L2C_MCI_INT_VBFSBE\t BIT(0)\n#define L2C_MCI_INT_VBFDBE\t BIT(1)\n\nstatic const struct error_descr l2_mci_errors[] = {\n\t{\n\t\t.type  = ERR_CORRECTED,\n\t\t.mask  = L2C_MCI_INT_VBFSBE,\n\t\t.descr = \"VBF single-bit error\",\n\t},\n\t{\n\t\t.type  = ERR_UNCORRECTED,\n\t\t.mask  = L2C_MCI_INT_VBFDBE,\n\t\t.descr = \"VBF double-bit error\",\n\t},\n\t{0, 0, NULL},\n};\n\n#define L2C_MCI_INT_W1S\t\t0x8\n#define L2C_MCI_INT_ENA_W1C\t0x20\n\n#define L2C_MCI_INT_ENA_ALL\t (L2C_MCI_INT_VBFSBE | L2C_MCI_INT_VBFDBE)\n\n#define L2C_MCI_INT_ENA_W1S\t0x28\n\n#define L2C_MCI_ERR\t\t0x10000\n\n#define L2C_MESSAGE_SIZE\tSZ_1K\n#define L2C_OTHER_SIZE\t\t(50 * ARRAY_SIZE(l2_tad_errors))\n\nstruct l2c_err_ctx {\n\tchar *reg_ext_name;\n\tu64  reg_int;\n\tu64  reg_ext;\n};\n\nstruct thunderx_l2c {\n\tvoid __iomem *regs;\n\tstruct pci_dev *pdev;\n\tstruct edac_device_ctl_info *edac_dev;\n\n\tstruct dentry *debugfs;\n\n\tint index;\n\n\tstruct msix_entry msix_ent;\n\n\tstruct l2c_err_ctx err_ctx[RING_ENTRIES];\n\tunsigned long ring_head;\n\tunsigned long ring_tail;\n};\n\nstatic irqreturn_t thunderx_l2c_tad_isr(int irq, void *irq_id)\n{\n\tstruct msix_entry *msix = irq_id;\n\tstruct thunderx_l2c *tad = container_of(msix, struct thunderx_l2c,\n\t\t\t\t\t\tmsix_ent);\n\n\tunsigned long head = ring_pos(tad->ring_head, ARRAY_SIZE(tad->err_ctx));\n\tstruct l2c_err_ctx *ctx = &tad->err_ctx[head];\n\n\tctx->reg_int = readq(tad->regs + L2C_TAD_INT_W1C);\n\n\tif (ctx->reg_int & L2C_TAD_INT_ECC) {\n\t\tctx->reg_ext_name = \"TQD_ERR\";\n\t\tctx->reg_ext = readq(tad->regs + L2C_TAD_TQD_ERR);\n\t} else if (ctx->reg_int & L2C_TAD_INT_TAG) {\n\t\tctx->reg_ext_name = \"TTG_ERR\";\n\t\tctx->reg_ext = readq(tad->regs + L2C_TAD_TTG_ERR);\n\t} else if (ctx->reg_int & L2C_TAD_INT_LFBTO) {\n\t\tctx->reg_ext_name = \"TIMEOUT\";\n\t\tctx->reg_ext = readq(tad->regs + L2C_TAD_TIMEOUT);\n\t} else if (ctx->reg_int & L2C_TAD_INT_DISOCI) {\n\t\tctx->reg_ext_name = \"ERR\";\n\t\tctx->reg_ext = readq(tad->regs + L2C_TAD_ERR);\n\t}\n\n\twriteq(ctx->reg_int, tad->regs + L2C_TAD_INT_W1C);\n\n\ttad->ring_head++;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t thunderx_l2c_cbc_isr(int irq, void *irq_id)\n{\n\tstruct msix_entry *msix = irq_id;\n\tstruct thunderx_l2c *cbc = container_of(msix, struct thunderx_l2c,\n\t\t\t\t\t\tmsix_ent);\n\n\tunsigned long head = ring_pos(cbc->ring_head, ARRAY_SIZE(cbc->err_ctx));\n\tstruct l2c_err_ctx *ctx = &cbc->err_ctx[head];\n\n\tctx->reg_int = readq(cbc->regs + L2C_CBC_INT_W1C);\n\n\tif (ctx->reg_int & L2C_CBC_INT_RSD) {\n\t\tctx->reg_ext_name = \"RSDERR\";\n\t\tctx->reg_ext = readq(cbc->regs + L2C_CBC_RSDERR);\n\t} else if (ctx->reg_int & L2C_CBC_INT_MIB) {\n\t\tctx->reg_ext_name = \"MIBERR\";\n\t\tctx->reg_ext = readq(cbc->regs + L2C_CBC_MIBERR);\n\t} else if (ctx->reg_int & L2C_CBC_INT_IODISOCI) {\n\t\tctx->reg_ext_name = \"IODISOCIERR\";\n\t\tctx->reg_ext = readq(cbc->regs + L2C_CBC_IODISOCIERR);\n\t}\n\n\twriteq(ctx->reg_int, cbc->regs + L2C_CBC_INT_W1C);\n\n\tcbc->ring_head++;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t thunderx_l2c_mci_isr(int irq, void *irq_id)\n{\n\tstruct msix_entry *msix = irq_id;\n\tstruct thunderx_l2c *mci = container_of(msix, struct thunderx_l2c,\n\t\t\t\t\t\tmsix_ent);\n\n\tunsigned long head = ring_pos(mci->ring_head, ARRAY_SIZE(mci->err_ctx));\n\tstruct l2c_err_ctx *ctx = &mci->err_ctx[head];\n\n\tctx->reg_int = readq(mci->regs + L2C_MCI_INT_W1C);\n\tctx->reg_ext = readq(mci->regs + L2C_MCI_ERR);\n\n\twriteq(ctx->reg_int, mci->regs + L2C_MCI_INT_W1C);\n\n\tctx->reg_ext_name = \"ERR\";\n\n\tmci->ring_head++;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t thunderx_l2c_threaded_isr(int irq, void *irq_id)\n{\n\tstruct msix_entry *msix = irq_id;\n\tstruct thunderx_l2c *l2c = container_of(msix, struct thunderx_l2c,\n\t\t\t\t\t\tmsix_ent);\n\n\tunsigned long tail = ring_pos(l2c->ring_tail, ARRAY_SIZE(l2c->err_ctx));\n\tstruct l2c_err_ctx *ctx = &l2c->err_ctx[tail];\n\tirqreturn_t ret = IRQ_NONE;\n\n\tu64 mask_ue, mask_ce;\n\tconst struct error_descr *l2_errors;\n\tchar *reg_int_name;\n\n\tchar *msg;\n\tchar *other;\n\n\tmsg = kmalloc(OCX_MESSAGE_SIZE, GFP_KERNEL);\n\tother = kmalloc(OCX_OTHER_SIZE, GFP_KERNEL);\n\n\tif (!msg || !other)\n\t\tgoto err_free;\n\n\tswitch (l2c->pdev->device) {\n\tcase PCI_DEVICE_ID_THUNDER_L2C_TAD:\n\t\treg_int_name = \"L2C_TAD_INT\";\n\t\tmask_ue = L2C_TAD_INT_UE;\n\t\tmask_ce = L2C_TAD_INT_CE;\n\t\tl2_errors = l2_tad_errors;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_THUNDER_L2C_CBC:\n\t\treg_int_name = \"L2C_CBC_INT\";\n\t\tmask_ue = L2C_CBC_INT_UE;\n\t\tmask_ce = L2C_CBC_INT_CE;\n\t\tl2_errors = l2_cbc_errors;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_THUNDER_L2C_MCI:\n\t\treg_int_name = \"L2C_MCI_INT\";\n\t\tmask_ue = L2C_MCI_INT_VBFDBE;\n\t\tmask_ce = L2C_MCI_INT_VBFSBE;\n\t\tl2_errors = l2_mci_errors;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&l2c->pdev->dev, \"Unsupported device: %04x\\n\",\n\t\t\tl2c->pdev->device);\n\t\tgoto err_free;\n\t}\n\n\twhile (CIRC_CNT(l2c->ring_head, l2c->ring_tail,\n\t\t\tARRAY_SIZE(l2c->err_ctx))) {\n\t\tsnprintf(msg, L2C_MESSAGE_SIZE,\n\t\t\t \"%s: %s: %016llx, %s: %016llx\",\n\t\t\t l2c->edac_dev->ctl_name, reg_int_name, ctx->reg_int,\n\t\t\t ctx->reg_ext_name, ctx->reg_ext);\n\n\t\tdecode_register(other, L2C_OTHER_SIZE, l2_errors, ctx->reg_int);\n\n\t\tstrlcat(msg, other, L2C_MESSAGE_SIZE);\n\n\t\tif (ctx->reg_int & mask_ue)\n\t\t\tedac_device_handle_ue(l2c->edac_dev, 0, 0, msg);\n\t\telse if (ctx->reg_int & mask_ce)\n\t\t\tedac_device_handle_ce(l2c->edac_dev, 0, 0, msg);\n\n\t\tl2c->ring_tail++;\n\t}\n\n\tret = IRQ_HANDLED;\n\nerr_free:\n\tkfree(other);\n\tkfree(msg);\n\n\treturn ret;\n}\n\n#define L2C_DEBUGFS_ATTR(_name, _reg)\tDEBUGFS_REG_ATTR(l2c, _name, _reg)\n\nL2C_DEBUGFS_ATTR(tad_int, L2C_TAD_INT_W1S);\n\nstatic struct debugfs_entry *l2c_tad_dfs_ents[] = {\n\t&debugfs_tad_int,\n};\n\nL2C_DEBUGFS_ATTR(cbc_int, L2C_CBC_INT_W1S);\n\nstatic struct debugfs_entry *l2c_cbc_dfs_ents[] = {\n\t&debugfs_cbc_int,\n};\n\nL2C_DEBUGFS_ATTR(mci_int, L2C_MCI_INT_W1S);\n\nstatic struct debugfs_entry *l2c_mci_dfs_ents[] = {\n\t&debugfs_mci_int,\n};\n\nstatic const struct pci_device_id thunderx_l2c_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_L2C_TAD), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_L2C_CBC), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_L2C_MCI), },\n\t{ 0, },\n};\n\nstatic int thunderx_l2c_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *id)\n{\n\tstruct thunderx_l2c *l2c;\n\tstruct edac_device_ctl_info *edac_dev;\n\tstruct debugfs_entry **l2c_devattr;\n\tsize_t dfs_entries;\n\tirqreturn_t (*thunderx_l2c_isr)(int, void *) = NULL;\n\tchar name[32];\n\tconst char *fmt;\n\tu64 reg_en_offs, reg_en_mask;\n\tint idx;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, BIT(0), \"thunderx_l2c\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot map PCI resources: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_THUNDER_L2C_TAD:\n\t\tthunderx_l2c_isr = thunderx_l2c_tad_isr;\n\t\tl2c_devattr = l2c_tad_dfs_ents;\n\t\tdfs_entries = ARRAY_SIZE(l2c_tad_dfs_ents);\n\t\tfmt = \"L2C-TAD%d\";\n\t\treg_en_offs = L2C_TAD_INT_ENA_W1S;\n\t\treg_en_mask = L2C_TAD_INT_ENA_ALL;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_THUNDER_L2C_CBC:\n\t\tthunderx_l2c_isr = thunderx_l2c_cbc_isr;\n\t\tl2c_devattr = l2c_cbc_dfs_ents;\n\t\tdfs_entries = ARRAY_SIZE(l2c_cbc_dfs_ents);\n\t\tfmt = \"L2C-CBC%d\";\n\t\treg_en_offs = L2C_CBC_INT_ENA_W1S;\n\t\treg_en_mask = L2C_CBC_INT_ENA_ALL;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_THUNDER_L2C_MCI:\n\t\tthunderx_l2c_isr = thunderx_l2c_mci_isr;\n\t\tl2c_devattr = l2c_mci_dfs_ents;\n\t\tdfs_entries = ARRAY_SIZE(l2c_mci_dfs_ents);\n\t\tfmt = \"L2C-MCI%d\";\n\t\treg_en_offs = L2C_MCI_INT_ENA_W1S;\n\t\treg_en_mask = L2C_MCI_INT_ENA_ALL;\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tdev_err(&pdev->dev, \"Unsupported PCI device: %04x\\n\",\n\t\t\tpdev->device);\n\t\treturn -EINVAL;\n\t}\n\n\tidx = edac_device_alloc_index();\n\tsnprintf(name, sizeof(name), fmt, idx);\n\n\tedac_dev = edac_device_alloc_ctl_info(sizeof(struct thunderx_l2c),\n\t\t\t\t\t      name, 1, \"L2C\", 1, 0,\n\t\t\t\t\t      NULL, 0, idx);\n\tif (!edac_dev) {\n\t\tdev_err(&pdev->dev, \"Cannot allocate EDAC device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tl2c = edac_dev->pvt_info;\n\tl2c->edac_dev = edac_dev;\n\n\tl2c->regs = pcim_iomap_table(pdev)[0];\n\tif (!l2c->regs) {\n\t\tdev_err(&pdev->dev, \"Cannot map PCI resources\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tl2c->pdev = pdev;\n\n\tl2c->ring_head = 0;\n\tl2c->ring_tail = 0;\n\n\tl2c->msix_ent.entry = 0;\n\tl2c->msix_ent.vector = 0;\n\n\tret = pci_enable_msix_exact(pdev, &l2c->msix_ent, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot enable interrupt: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, l2c->msix_ent.vector,\n\t\t\t\t\tthunderx_l2c_isr,\n\t\t\t\t\tthunderx_l2c_threaded_isr,\n\t\t\t\t\t0, \"[EDAC] ThunderX L2C\",\n\t\t\t\t\t&l2c->msix_ent);\n\tif (ret)\n\t\tgoto err_free;\n\n\tedac_dev->dev = &pdev->dev;\n\tedac_dev->dev_name = dev_name(&pdev->dev);\n\tedac_dev->mod_name = \"thunderx-l2c\";\n\tedac_dev->ctl_name = \"thunderx-l2c\";\n\n\tret = edac_device_add_device(edac_dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot add EDAC device: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tif (IS_ENABLED(CONFIG_EDAC_DEBUG)) {\n\t\tl2c->debugfs = edac_debugfs_create_dir(pdev->dev.kobj.name);\n\n\t\tret = thunderx_create_debugfs_nodes(l2c->debugfs, l2c_devattr,\n\t\t\t\t\t      l2c, dfs_entries);\n\n\t\tif (ret != dfs_entries) {\n\t\t\tdev_warn(&pdev->dev, \"Error creating debugfs entries: %d%s\\n\",\n\t\t\t\t ret, ret >= 0 ? \" created\" : \"\");\n\t\t}\n\t}\n\n\tpci_set_drvdata(pdev, edac_dev);\n\n\twriteq(reg_en_mask, l2c->regs + reg_en_offs);\n\n\treturn 0;\n\nerr_free:\n\tedac_device_free_ctl_info(edac_dev);\n\n\treturn ret;\n}\n\nstatic void thunderx_l2c_remove(struct pci_dev *pdev)\n{\n\tstruct edac_device_ctl_info *edac_dev = pci_get_drvdata(pdev);\n\tstruct thunderx_l2c *l2c = edac_dev->pvt_info;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_THUNDER_L2C_TAD:\n\t\twriteq(L2C_TAD_INT_ENA_ALL, l2c->regs + L2C_TAD_INT_ENA_W1C);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_THUNDER_L2C_CBC:\n\t\twriteq(L2C_CBC_INT_ENA_ALL, l2c->regs + L2C_CBC_INT_ENA_W1C);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_THUNDER_L2C_MCI:\n\t\twriteq(L2C_MCI_INT_ENA_ALL, l2c->regs + L2C_MCI_INT_ENA_W1C);\n\t\tbreak;\n\t}\n\n\tedac_debugfs_remove_recursive(l2c->debugfs);\n\n\tedac_device_del_device(&pdev->dev);\n\tedac_device_free_ctl_info(edac_dev);\n}\n\nMODULE_DEVICE_TABLE(pci, thunderx_l2c_pci_tbl);\n\nstatic struct pci_driver thunderx_l2c_driver = {\n\t.name     = \"thunderx_l2c_edac\",\n\t.probe    = thunderx_l2c_probe,\n\t.remove   = thunderx_l2c_remove,\n\t.id_table = thunderx_l2c_pci_tbl,\n};\n\nstatic int __init thunderx_edac_init(void)\n{\n\tint rc = 0;\n\n\tif (ghes_get_devices())\n\t\treturn -EBUSY;\n\n\trc = pci_register_driver(&thunderx_lmc_driver);\n\tif (rc)\n\t\treturn rc;\n\n\trc = pci_register_driver(&thunderx_ocx_driver);\n\tif (rc)\n\t\tgoto err_lmc;\n\n\trc = pci_register_driver(&thunderx_l2c_driver);\n\tif (rc)\n\t\tgoto err_ocx;\n\n\treturn rc;\nerr_ocx:\n\tpci_unregister_driver(&thunderx_ocx_driver);\nerr_lmc:\n\tpci_unregister_driver(&thunderx_lmc_driver);\n\n\treturn rc;\n}\n\nstatic void __exit thunderx_edac_exit(void)\n{\n\tpci_unregister_driver(&thunderx_l2c_driver);\n\tpci_unregister_driver(&thunderx_ocx_driver);\n\tpci_unregister_driver(&thunderx_lmc_driver);\n\n}\n\nmodule_init(thunderx_edac_init);\nmodule_exit(thunderx_edac_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Cavium, Inc.\");\nMODULE_DESCRIPTION(\"EDAC Driver for Cavium ThunderX\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}