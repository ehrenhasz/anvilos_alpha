{
  "module_name": "npcm_edac.c",
  "hash_id": "861bcb4854def0a65de6fc19a30522fc966e123556ce2a2dd7897acbe98adb1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/npcm_edac.c",
  "human_readable_source": "\n\n\n#include <linux/debugfs.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_NAME\t\t\t\"npcm-edac\"\n#define EDAC_MSG_SIZE\t\t\t256\n\n \n#define NPCM7XX_CHIP\t\t\tBIT(0)\n#define NPCM8XX_CHIP\t\t\tBIT(1)\n\n \n#define UE_SYNDROME\t\t\t0x03\n\n \n#define ERROR_TYPE_CORRECTABLE\t\t0\n#define ERROR_TYPE_UNCORRECTABLE\t1\n#define ERROR_LOCATION_DATA\t\t0\n#define ERROR_LOCATION_CHECKCODE\t1\n#define ERROR_BIT_DATA_MAX\t\t63\n#define ERROR_BIT_CHECKCODE_MAX\t\t7\n\nstatic char data_synd[] = {\n\t0xf4, 0xf1, 0xec, 0xea, 0xe9, 0xe6, 0xe5, 0xe3,\n\t0xdc, 0xda, 0xd9, 0xd6, 0xd5, 0xd3, 0xce, 0xcb,\n\t0xb5, 0xb0, 0xad, 0xab, 0xa8, 0xa7, 0xa4, 0xa2,\n\t0x9d, 0x9b, 0x98, 0x97, 0x94, 0x92, 0x8f, 0x8a,\n\t0x75, 0x70, 0x6d, 0x6b, 0x68, 0x67, 0x64, 0x62,\n\t0x5e, 0x5b, 0x58, 0x57, 0x54, 0x52, 0x4f, 0x4a,\n\t0x34, 0x31, 0x2c, 0x2a, 0x29, 0x26, 0x25, 0x23,\n\t0x1c, 0x1a, 0x19, 0x16, 0x15, 0x13, 0x0e, 0x0b\n};\n\nstatic struct regmap *npcm_regmap;\n\nstruct npcm_platform_data {\n\t \n\tint chip;\n\n\t \n\tu32 ctl_ecc_en;\n\tu32 ctl_int_status;\n\tu32 ctl_int_ack;\n\tu32 ctl_int_mask_master;\n\tu32 ctl_int_mask_ecc;\n\tu32 ctl_ce_addr_l;\n\tu32 ctl_ce_addr_h;\n\tu32 ctl_ce_data_l;\n\tu32 ctl_ce_data_h;\n\tu32 ctl_ce_synd;\n\tu32 ctl_ue_addr_l;\n\tu32 ctl_ue_addr_h;\n\tu32 ctl_ue_data_l;\n\tu32 ctl_ue_data_h;\n\tu32 ctl_ue_synd;\n\tu32 ctl_source_id;\n\tu32 ctl_controller_busy;\n\tu32 ctl_xor_check_bits;\n\n\t \n\tu32 ecc_en_mask;\n\tu32 int_status_ce_mask;\n\tu32 int_status_ue_mask;\n\tu32 int_ack_ce_mask;\n\tu32 int_ack_ue_mask;\n\tu32 int_mask_master_non_ecc_mask;\n\tu32 int_mask_master_global_mask;\n\tu32 int_mask_ecc_non_event_mask;\n\tu32 ce_addr_h_mask;\n\tu32 ce_synd_mask;\n\tu32 ce_synd_shift;\n\tu32 ue_addr_h_mask;\n\tu32 ue_synd_mask;\n\tu32 ue_synd_shift;\n\tu32 source_id_ce_mask;\n\tu32 source_id_ce_shift;\n\tu32 source_id_ue_mask;\n\tu32 source_id_ue_shift;\n\tu32 controller_busy_mask;\n\tu32 xor_check_bits_mask;\n\tu32 xor_check_bits_shift;\n\tu32 writeback_en_mask;\n\tu32 fwc_mask;\n};\n\nstruct priv_data {\n\tvoid __iomem *reg;\n\tchar message[EDAC_MSG_SIZE];\n\tconst struct npcm_platform_data *pdata;\n\n\t \n\tstruct dentry *debugfs;\n\tu8 error_type;\n\tu8 location;\n\tu8 bit;\n};\n\nstatic void handle_ce(struct mem_ctl_info *mci)\n{\n\tstruct priv_data *priv = mci->pvt_info;\n\tconst struct npcm_platform_data *pdata;\n\tu32 val_h = 0, val_l, id, synd;\n\tu64 addr = 0, data = 0;\n\n\tpdata = priv->pdata;\n\tregmap_read(npcm_regmap, pdata->ctl_ce_addr_l, &val_l);\n\tif (pdata->chip == NPCM8XX_CHIP) {\n\t\tregmap_read(npcm_regmap, pdata->ctl_ce_addr_h, &val_h);\n\t\tval_h &= pdata->ce_addr_h_mask;\n\t}\n\taddr = ((addr | val_h) << 32) | val_l;\n\n\tregmap_read(npcm_regmap, pdata->ctl_ce_data_l, &val_l);\n\tif (pdata->chip == NPCM8XX_CHIP)\n\t\tregmap_read(npcm_regmap, pdata->ctl_ce_data_h, &val_h);\n\tdata = ((data | val_h) << 32) | val_l;\n\n\tregmap_read(npcm_regmap, pdata->ctl_source_id, &id);\n\tid = (id & pdata->source_id_ce_mask) >> pdata->source_id_ce_shift;\n\n\tregmap_read(npcm_regmap, pdata->ctl_ce_synd, &synd);\n\tsynd = (synd & pdata->ce_synd_mask) >> pdata->ce_synd_shift;\n\n\tsnprintf(priv->message, EDAC_MSG_SIZE,\n\t\t \"addr = 0x%llx, data = 0x%llx, id = 0x%x\", addr, data, id);\n\n\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, addr >> PAGE_SHIFT,\n\t\t\t     addr & ~PAGE_MASK, synd, 0, 0, -1, priv->message, \"\");\n}\n\nstatic void handle_ue(struct mem_ctl_info *mci)\n{\n\tstruct priv_data *priv = mci->pvt_info;\n\tconst struct npcm_platform_data *pdata;\n\tu32 val_h = 0, val_l, id, synd;\n\tu64 addr = 0, data = 0;\n\n\tpdata = priv->pdata;\n\tregmap_read(npcm_regmap, pdata->ctl_ue_addr_l, &val_l);\n\tif (pdata->chip == NPCM8XX_CHIP) {\n\t\tregmap_read(npcm_regmap, pdata->ctl_ue_addr_h, &val_h);\n\t\tval_h &= pdata->ue_addr_h_mask;\n\t}\n\taddr = ((addr | val_h) << 32) | val_l;\n\n\tregmap_read(npcm_regmap, pdata->ctl_ue_data_l, &val_l);\n\tif (pdata->chip == NPCM8XX_CHIP)\n\t\tregmap_read(npcm_regmap, pdata->ctl_ue_data_h, &val_h);\n\tdata = ((data | val_h) << 32) | val_l;\n\n\tregmap_read(npcm_regmap, pdata->ctl_source_id, &id);\n\tid = (id & pdata->source_id_ue_mask) >> pdata->source_id_ue_shift;\n\n\tregmap_read(npcm_regmap, pdata->ctl_ue_synd, &synd);\n\tsynd = (synd & pdata->ue_synd_mask) >> pdata->ue_synd_shift;\n\n\tsnprintf(priv->message, EDAC_MSG_SIZE,\n\t\t \"addr = 0x%llx, data = 0x%llx, id = 0x%x\", addr, data, id);\n\n\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, addr >> PAGE_SHIFT,\n\t\t\t     addr & ~PAGE_MASK, synd, 0, 0, -1, priv->message, \"\");\n}\n\nstatic irqreturn_t edac_ecc_isr(int irq, void *dev_id)\n{\n\tconst struct npcm_platform_data *pdata;\n\tstruct mem_ctl_info *mci = dev_id;\n\tu32 status;\n\n\tpdata = ((struct priv_data *)mci->pvt_info)->pdata;\n\tregmap_read(npcm_regmap, pdata->ctl_int_status, &status);\n\tif (status & pdata->int_status_ce_mask) {\n\t\thandle_ce(mci);\n\n\t\t \n\t\tregmap_write(npcm_regmap, pdata->ctl_int_ack,\n\t\t\t     pdata->int_ack_ce_mask);\n\t\treturn IRQ_HANDLED;\n\t} else if (status & pdata->int_status_ue_mask) {\n\t\thandle_ue(mci);\n\n\t\t \n\t\tregmap_write(npcm_regmap, pdata->ctl_int_ack,\n\t\t\t     pdata->int_ack_ue_mask);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tWARN_ON_ONCE(1);\n\treturn IRQ_NONE;\n}\n\nstatic ssize_t force_ecc_error(struct file *file, const char __user *data,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct device *dev = file->private_data;\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct priv_data *priv = mci->pvt_info;\n\tconst struct npcm_platform_data *pdata;\n\tu32 val, syndrome;\n\tint ret;\n\n\tpdata = priv->pdata;\n\tedac_printk(KERN_INFO, EDAC_MOD_NAME,\n\t\t    \"force an ECC error, type = %d, location = %d, bit = %d\\n\",\n\t\t    priv->error_type, priv->location, priv->bit);\n\n\t \n\tret = regmap_read_poll_timeout(npcm_regmap, pdata->ctl_controller_busy,\n\t\t\t\t       val, !(val & pdata->controller_busy_mask),\n\t\t\t\t       1000, 10000);\n\tif (ret) {\n\t\tedac_printk(KERN_INFO, EDAC_MOD_NAME,\n\t\t\t    \"wait pending writes timeout\\n\");\n\t\treturn count;\n\t}\n\n\tregmap_read(npcm_regmap, pdata->ctl_xor_check_bits, &val);\n\tval &= ~pdata->xor_check_bits_mask;\n\n\t \n\tif (priv->error_type == ERROR_TYPE_CORRECTABLE) {\n\t\tif (priv->location == ERROR_LOCATION_DATA &&\n\t\t    priv->bit > ERROR_BIT_DATA_MAX) {\n\t\t\tedac_printk(KERN_INFO, EDAC_MOD_NAME,\n\t\t\t\t    \"data bit should not exceed %d (%d)\\n\",\n\t\t\t\t    ERROR_BIT_DATA_MAX, priv->bit);\n\t\t\treturn count;\n\t\t}\n\n\t\tif (priv->location == ERROR_LOCATION_CHECKCODE &&\n\t\t    priv->bit > ERROR_BIT_CHECKCODE_MAX) {\n\t\t\tedac_printk(KERN_INFO, EDAC_MOD_NAME,\n\t\t\t\t    \"checkcode bit should not exceed %d (%d)\\n\",\n\t\t\t\t    ERROR_BIT_CHECKCODE_MAX, priv->bit);\n\t\t\treturn count;\n\t\t}\n\n\t\tsyndrome = priv->location ? 1 << priv->bit\n\t\t\t\t\t  : data_synd[priv->bit];\n\n\t\tregmap_write(npcm_regmap, pdata->ctl_xor_check_bits,\n\t\t\t     val | (syndrome << pdata->xor_check_bits_shift) |\n\t\t\t     pdata->writeback_en_mask);\n\t} else if (priv->error_type == ERROR_TYPE_UNCORRECTABLE) {\n\t\tregmap_write(npcm_regmap, pdata->ctl_xor_check_bits,\n\t\t\t     val | (UE_SYNDROME << pdata->xor_check_bits_shift));\n\t}\n\n\t \n\tregmap_update_bits(npcm_regmap, pdata->ctl_xor_check_bits,\n\t\t\t   pdata->fwc_mask, pdata->fwc_mask);\n\n\treturn count;\n}\n\nstatic const struct file_operations force_ecc_error_fops = {\n\t.open = simple_open,\n\t.write = force_ecc_error,\n\t.llseek = generic_file_llseek,\n};\n\n \nstatic void setup_debugfs(struct mem_ctl_info *mci)\n{\n\tstruct priv_data *priv = mci->pvt_info;\n\n\tpriv->debugfs = edac_debugfs_create_dir(mci->mod_name);\n\tif (!priv->debugfs)\n\t\treturn;\n\n\tedac_debugfs_create_x8(\"error_type\", 0644, priv->debugfs, &priv->error_type);\n\tedac_debugfs_create_x8(\"location\", 0644, priv->debugfs, &priv->location);\n\tedac_debugfs_create_x8(\"bit\", 0644, priv->debugfs, &priv->bit);\n\tedac_debugfs_create_file(\"force_ecc_error\", 0200, priv->debugfs,\n\t\t\t\t &mci->dev, &force_ecc_error_fops);\n}\n\nstatic int setup_irq(struct mem_ctl_info *mci, struct platform_device *pdev)\n{\n\tconst struct npcm_platform_data *pdata;\n\tint ret, irq;\n\n\tpdata = ((struct priv_data *)mci->pvt_info)->pdata;\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_NAME, \"IRQ not defined in DTS\\n\");\n\t\treturn irq;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, edac_ecc_isr, 0,\n\t\t\t       dev_name(&pdev->dev), mci);\n\tif (ret < 0) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_NAME, \"failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_write(npcm_regmap, pdata->ctl_int_mask_master,\n\t\t     pdata->int_mask_master_non_ecc_mask);\n\n\tif (pdata->chip == NPCM8XX_CHIP)\n\t\tregmap_write(npcm_regmap, pdata->ctl_int_mask_ecc,\n\t\t\t     pdata->int_mask_ecc_non_event_mask);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config npcm_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.val_bits\t= 32,\n};\n\nstatic int edac_probe(struct platform_device *pdev)\n{\n\tconst struct npcm_platform_data *pdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct edac_mc_layer layers[1];\n\tstruct mem_ctl_info *mci;\n\tstruct priv_data *priv;\n\tvoid __iomem *reg;\n\tu32 val;\n\tint rc;\n\n\treg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tnpcm_regmap = devm_regmap_init_mmio(dev, reg, &npcm_regmap_cfg);\n\tif (IS_ERR(npcm_regmap))\n\t\treturn PTR_ERR(npcm_regmap);\n\n\tpdata = of_device_get_match_data(dev);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\t \n\tregmap_read(npcm_regmap, pdata->ctl_ecc_en, &val);\n\tif (!(val & pdata->ecc_en_mask)) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_NAME, \"ECC is not enabled\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tedac_op_state = EDAC_OPSTATE_INT;\n\n\tlayers[0].type = EDAC_MC_LAYER_ALL_MEM;\n\tlayers[0].size = 1;\n\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct priv_data));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tmci->pdev = &pdev->dev;\n\tpriv = mci->pvt_info;\n\tpriv->reg = reg;\n\tpriv->pdata = pdata;\n\tplatform_set_drvdata(pdev, mci);\n\n\tmci->mtype_cap = MEM_FLAG_DDR4;\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->scrub_cap = SCRUB_FLAG_HW_SRC;\n\tmci->scrub_mode = SCRUB_HW_SRC;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->ctl_name = \"npcm_ddr_controller\";\n\tmci->dev_name = dev_name(&pdev->dev);\n\tmci->mod_name = EDAC_MOD_NAME;\n\tmci->ctl_page_to_phys = NULL;\n\n\trc = setup_irq(mci, pdev);\n\tif (rc)\n\t\tgoto free_edac_mc;\n\n\trc = edac_mc_add_mc(mci);\n\tif (rc)\n\t\tgoto free_edac_mc;\n\n\tif (IS_ENABLED(CONFIG_EDAC_DEBUG) && pdata->chip == NPCM8XX_CHIP)\n\t\tsetup_debugfs(mci);\n\n\treturn rc;\n\nfree_edac_mc:\n\tedac_mc_free(mci);\n\treturn rc;\n}\n\nstatic int edac_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\tstruct priv_data *priv = mci->pvt_info;\n\tconst struct npcm_platform_data *pdata;\n\n\tpdata = priv->pdata;\n\tif (IS_ENABLED(CONFIG_EDAC_DEBUG) && pdata->chip == NPCM8XX_CHIP)\n\t\tedac_debugfs_remove_recursive(priv->debugfs);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\n\tregmap_write(npcm_regmap, pdata->ctl_int_mask_master,\n\t\t     pdata->int_mask_master_global_mask);\n\tregmap_update_bits(npcm_regmap, pdata->ctl_ecc_en, pdata->ecc_en_mask, 0);\n\n\treturn 0;\n}\n\nstatic const struct npcm_platform_data npcm750_edac = {\n\t.chip\t\t\t\t= NPCM7XX_CHIP,\n\n\t \n\t.ctl_ecc_en\t\t\t= 0x174,\n\t.ctl_int_status\t\t\t= 0x1d0,\n\t.ctl_int_ack\t\t\t= 0x1d4,\n\t.ctl_int_mask_master\t\t= 0x1d8,\n\t.ctl_ce_addr_l\t\t\t= 0x188,\n\t.ctl_ce_data_l\t\t\t= 0x190,\n\t.ctl_ce_synd\t\t\t= 0x18c,\n\t.ctl_ue_addr_l\t\t\t= 0x17c,\n\t.ctl_ue_data_l\t\t\t= 0x184,\n\t.ctl_ue_synd\t\t\t= 0x180,\n\t.ctl_source_id\t\t\t= 0x194,\n\n\t \n\t.ecc_en_mask\t\t\t= BIT(24),\n\t.int_status_ce_mask\t\t= GENMASK(4, 3),\n\t.int_status_ue_mask\t\t= GENMASK(6, 5),\n\t.int_ack_ce_mask\t\t= GENMASK(4, 3),\n\t.int_ack_ue_mask\t\t= GENMASK(6, 5),\n\t.int_mask_master_non_ecc_mask\t= GENMASK(30, 7) | GENMASK(2, 0),\n\t.int_mask_master_global_mask\t= BIT(31),\n\t.ce_synd_mask\t\t\t= GENMASK(6, 0),\n\t.ce_synd_shift\t\t\t= 0,\n\t.ue_synd_mask\t\t\t= GENMASK(6, 0),\n\t.ue_synd_shift\t\t\t= 0,\n\t.source_id_ce_mask\t\t= GENMASK(29, 16),\n\t.source_id_ce_shift\t\t= 16,\n\t.source_id_ue_mask\t\t= GENMASK(13, 0),\n\t.source_id_ue_shift\t\t= 0,\n};\n\nstatic const struct npcm_platform_data npcm845_edac = {\n\t.chip =\t\t\t\tNPCM8XX_CHIP,\n\n\t \n\t.ctl_ecc_en\t\t\t= 0x16c,\n\t.ctl_int_status\t\t\t= 0x228,\n\t.ctl_int_ack\t\t\t= 0x244,\n\t.ctl_int_mask_master\t\t= 0x220,\n\t.ctl_int_mask_ecc\t\t= 0x260,\n\t.ctl_ce_addr_l\t\t\t= 0x18c,\n\t.ctl_ce_addr_h\t\t\t= 0x190,\n\t.ctl_ce_data_l\t\t\t= 0x194,\n\t.ctl_ce_data_h\t\t\t= 0x198,\n\t.ctl_ce_synd\t\t\t= 0x190,\n\t.ctl_ue_addr_l\t\t\t= 0x17c,\n\t.ctl_ue_addr_h\t\t\t= 0x180,\n\t.ctl_ue_data_l\t\t\t= 0x184,\n\t.ctl_ue_data_h\t\t\t= 0x188,\n\t.ctl_ue_synd\t\t\t= 0x180,\n\t.ctl_source_id\t\t\t= 0x19c,\n\t.ctl_controller_busy\t\t= 0x20c,\n\t.ctl_xor_check_bits\t\t= 0x174,\n\n\t \n\t.ecc_en_mask\t\t\t= GENMASK(17, 16),\n\t.int_status_ce_mask\t\t= GENMASK(1, 0),\n\t.int_status_ue_mask\t\t= GENMASK(3, 2),\n\t.int_ack_ce_mask\t\t= GENMASK(1, 0),\n\t.int_ack_ue_mask\t\t= GENMASK(3, 2),\n\t.int_mask_master_non_ecc_mask\t= GENMASK(30, 3) | GENMASK(1, 0),\n\t.int_mask_master_global_mask\t= BIT(31),\n\t.int_mask_ecc_non_event_mask\t= GENMASK(8, 4),\n\t.ce_addr_h_mask\t\t\t= GENMASK(1, 0),\n\t.ce_synd_mask\t\t\t= GENMASK(15, 8),\n\t.ce_synd_shift\t\t\t= 8,\n\t.ue_addr_h_mask\t\t\t= GENMASK(1, 0),\n\t.ue_synd_mask\t\t\t= GENMASK(15, 8),\n\t.ue_synd_shift\t\t\t= 8,\n\t.source_id_ce_mask\t\t= GENMASK(29, 16),\n\t.source_id_ce_shift\t\t= 16,\n\t.source_id_ue_mask\t\t= GENMASK(13, 0),\n\t.source_id_ue_shift\t\t= 0,\n\t.controller_busy_mask\t\t= BIT(0),\n\t.xor_check_bits_mask\t\t= GENMASK(23, 16),\n\t.xor_check_bits_shift\t\t= 16,\n\t.writeback_en_mask\t\t= BIT(24),\n\t.fwc_mask\t\t\t= BIT(8),\n};\n\nstatic const struct of_device_id npcm_edac_of_match[] = {\n\t{\n\t\t.compatible = \"nuvoton,npcm750-memory-controller\",\n\t\t.data = &npcm750_edac\n\t},\n\t{\n\t\t.compatible = \"nuvoton,npcm845-memory-controller\",\n\t\t.data = &npcm845_edac\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, npcm_edac_of_match);\n\nstatic struct platform_driver npcm_edac_driver = {\n\t.driver = {\n\t\t.name = \"npcm-edac\",\n\t\t.of_match_table = npcm_edac_of_match,\n\t},\n\t.probe = edac_probe,\n\t.remove = edac_remove,\n};\n\nmodule_platform_driver(npcm_edac_driver);\n\nMODULE_AUTHOR(\"Medad CChien <medadyoung@gmail.com>\");\nMODULE_AUTHOR(\"Marvin Lin <kflin@nuvoton.com>\");\nMODULE_DESCRIPTION(\"Nuvoton NPCM EDAC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}