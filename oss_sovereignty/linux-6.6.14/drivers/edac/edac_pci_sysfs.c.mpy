{
  "module_name": "edac_pci_sysfs.c",
  "hash_id": "a37194063f41964b75ff8ed51f19580fb57ff54d3361f8193e64343475040a0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_pci_sysfs.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/edac.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n\n#include \"edac_pci.h\"\n#include \"edac_module.h\"\n\n#define EDAC_PCI_SYMLINK\t\"device\"\n\n \nstatic int check_pci_errors;\t\t \nstatic int edac_pci_panic_on_pe;\t \nstatic int edac_pci_log_pe = 1;\t\t \nstatic int edac_pci_log_npe = 1;\t \nstatic int edac_pci_poll_msec = 1000;\t \n\nstatic atomic_t pci_parity_count = ATOMIC_INIT(0);\nstatic atomic_t pci_nonparity_count = ATOMIC_INIT(0);\n\nstatic struct kobject *edac_pci_top_main_kobj;\nstatic atomic_t edac_pci_sysfs_refcount = ATOMIC_INIT(0);\n\n \nint edac_pci_get_check_errors(void)\n{\n\treturn check_pci_errors;\n}\n\nstatic int edac_pci_get_log_pe(void)\n{\n\treturn edac_pci_log_pe;\n}\n\nstatic int edac_pci_get_log_npe(void)\n{\n\treturn edac_pci_log_npe;\n}\n\nstatic int edac_pci_get_panic_on_pe(void)\n{\n\treturn edac_pci_panic_on_pe;\n}\n\nint edac_pci_get_poll_msec(void)\n{\n\treturn edac_pci_poll_msec;\n}\n\n \nstatic ssize_t instance_pe_count_show(struct edac_pci_ctl_info *pci, char *data)\n{\n\treturn sprintf(data, \"%u\\n\", atomic_read(&pci->counters.pe_count));\n}\n\nstatic ssize_t instance_npe_count_show(struct edac_pci_ctl_info *pci,\n\t\t\t\tchar *data)\n{\n\treturn sprintf(data, \"%u\\n\", atomic_read(&pci->counters.npe_count));\n}\n\n#define to_instance(k) container_of(k, struct edac_pci_ctl_info, kobj)\n#define to_instance_attr(a) container_of(a, struct instance_attribute, attr)\n\n \nstatic void edac_pci_instance_release(struct kobject *kobj)\n{\n\tstruct edac_pci_ctl_info *pci;\n\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tpci = to_instance(kobj);\n\n\t \n\tkobject_put(edac_pci_top_main_kobj);\n\n\tkfree(pci);\t \n}\n\n \nstruct instance_attribute {\n\tstruct attribute attr;\n\tssize_t(*show) (struct edac_pci_ctl_info *, char *);\n\tssize_t(*store) (struct edac_pci_ctl_info *, const char *, size_t);\n};\n\n \nstatic ssize_t edac_pci_instance_show(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, char *buffer)\n{\n\tstruct edac_pci_ctl_info *pci = to_instance(kobj);\n\tstruct instance_attribute *instance_attr = to_instance_attr(attr);\n\n\tif (instance_attr->show)\n\t\treturn instance_attr->show(pci, buffer);\n\treturn -EIO;\n}\n\n \nstatic ssize_t edac_pci_instance_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr,\n\t\t\t\tconst char *buffer, size_t count)\n{\n\tstruct edac_pci_ctl_info *pci = to_instance(kobj);\n\tstruct instance_attribute *instance_attr = to_instance_attr(attr);\n\n\tif (instance_attr->store)\n\t\treturn instance_attr->store(pci, buffer, count);\n\treturn -EIO;\n}\n\n \nstatic const struct sysfs_ops pci_instance_ops = {\n\t.show = edac_pci_instance_show,\n\t.store = edac_pci_instance_store\n};\n\n#define INSTANCE_ATTR(_name, _mode, _show, _store)\t\\\nstatic struct instance_attribute attr_instance_##_name = {\t\\\n\t.attr\t= {.name = __stringify(_name), .mode = _mode },\t\\\n\t.show\t= _show,\t\t\t\t\t\\\n\t.store\t= _store,\t\t\t\t\t\\\n};\n\nINSTANCE_ATTR(pe_count, S_IRUGO, instance_pe_count_show, NULL);\nINSTANCE_ATTR(npe_count, S_IRUGO, instance_npe_count_show, NULL);\n\n \nstatic struct attribute *pci_instance_attrs[] = {\n\t&attr_instance_pe_count.attr,\n\t&attr_instance_npe_count.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(pci_instance);\n\n \nstatic struct kobj_type ktype_pci_instance = {\n\t.release = edac_pci_instance_release,\n\t.sysfs_ops = &pci_instance_ops,\n\t.default_groups = pci_instance_groups,\n};\n\n \nstatic int edac_pci_create_instance_kobj(struct edac_pci_ctl_info *pci, int idx)\n{\n\tstruct kobject *main_kobj;\n\tint err;\n\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tmain_kobj = kobject_get(edac_pci_top_main_kobj);\n\tif (!main_kobj) {\n\t\terr = -ENODEV;\n\t\tgoto error_out;\n\t}\n\n\t \n\terr = kobject_init_and_add(&pci->kobj, &ktype_pci_instance,\n\t\t\t\t   edac_pci_top_main_kobj, \"pci%d\", idx);\n\tif (err != 0) {\n\t\tedac_dbg(2, \"failed to register instance pci%d\\n\", idx);\n\t\tkobject_put(edac_pci_top_main_kobj);\n\t\tgoto error_out;\n\t}\n\n\tkobject_uevent(&pci->kobj, KOBJ_ADD);\n\tedac_dbg(1, \"Register instance 'pci%d' kobject\\n\", idx);\n\n\treturn 0;\n\n\t \nerror_out:\n\treturn err;\n}\n\n \nstatic void edac_pci_unregister_sysfs_instance_kobj(\n\t\t\tstruct edac_pci_ctl_info *pci)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tkobject_put(&pci->kobj);\n}\n\n \n#define to_edacpci(k) container_of(k, struct edac_pci_ctl_info, kobj)\n#define to_edacpci_attr(a) container_of(a, struct edac_pci_attr, attr)\n\n \nstatic ssize_t edac_pci_int_show(void *ptr, char *buffer)\n{\n\tint *value = ptr;\n\treturn sprintf(buffer, \"%d\\n\", *value);\n}\n\nstatic ssize_t edac_pci_int_store(void *ptr, const char *buffer, size_t count)\n{\n\tint *value = ptr;\n\n\tif (isdigit(*buffer))\n\t\t*value = simple_strtoul(buffer, NULL, 0);\n\n\treturn count;\n}\n\nstruct edac_pci_dev_attribute {\n\tstruct attribute attr;\n\tvoid *value;\n\t ssize_t(*show) (void *, char *);\n\t ssize_t(*store) (void *, const char *, size_t);\n};\n\n \nstatic ssize_t edac_pci_dev_show(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t char *buffer)\n{\n\tstruct edac_pci_dev_attribute *edac_pci_dev;\n\tedac_pci_dev = (struct edac_pci_dev_attribute *)attr;\n\n\tif (edac_pci_dev->show)\n\t\treturn edac_pci_dev->show(edac_pci_dev->value, buffer);\n\treturn -EIO;\n}\n\nstatic ssize_t edac_pci_dev_store(struct kobject *kobj,\n\t\t\t\tstruct attribute *attr, const char *buffer,\n\t\t\t\tsize_t count)\n{\n\tstruct edac_pci_dev_attribute *edac_pci_dev;\n\tedac_pci_dev = (struct edac_pci_dev_attribute *)attr;\n\n\tif (edac_pci_dev->store)\n\t\treturn edac_pci_dev->store(edac_pci_dev->value, buffer, count);\n\treturn -EIO;\n}\n\nstatic const struct sysfs_ops edac_pci_sysfs_ops = {\n\t.show = edac_pci_dev_show,\n\t.store = edac_pci_dev_store\n};\n\n#define EDAC_PCI_ATTR(_name,_mode,_show,_store)\t\t\t\\\nstatic struct edac_pci_dev_attribute edac_pci_attr_##_name = {\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\\\n\t.value  = &_name,\t\t\t\t\t\\\n\t.show   = _show,\t\t\t\t\t\\\n\t.store  = _store,\t\t\t\t\t\\\n};\n\n#define EDAC_PCI_STRING_ATTR(_name,_data,_mode,_show,_store)\t\\\nstatic struct edac_pci_dev_attribute edac_pci_attr_##_name = {\t\t\\\n\t.attr = {.name = __stringify(_name), .mode = _mode },\t\\\n\t.value  = _data,\t\t\t\t\t\\\n\t.show   = _show,\t\t\t\t\t\\\n\t.store  = _store,\t\t\t\t\t\\\n};\n\n \nEDAC_PCI_ATTR(check_pci_errors, S_IRUGO | S_IWUSR, edac_pci_int_show,\n\tedac_pci_int_store);\nEDAC_PCI_ATTR(edac_pci_log_pe, S_IRUGO | S_IWUSR, edac_pci_int_show,\n\tedac_pci_int_store);\nEDAC_PCI_ATTR(edac_pci_log_npe, S_IRUGO | S_IWUSR, edac_pci_int_show,\n\tedac_pci_int_store);\nEDAC_PCI_ATTR(edac_pci_panic_on_pe, S_IRUGO | S_IWUSR, edac_pci_int_show,\n\tedac_pci_int_store);\nEDAC_PCI_ATTR(pci_parity_count, S_IRUGO, edac_pci_int_show, NULL);\nEDAC_PCI_ATTR(pci_nonparity_count, S_IRUGO, edac_pci_int_show, NULL);\n\n \nstatic struct attribute *edac_pci_attrs[] = {\n\t&edac_pci_attr_check_pci_errors.attr,\n\t&edac_pci_attr_edac_pci_log_pe.attr,\n\t&edac_pci_attr_edac_pci_log_npe.attr,\n\t&edac_pci_attr_edac_pci_panic_on_pe.attr,\n\t&edac_pci_attr_pci_parity_count.attr,\n\t&edac_pci_attr_pci_nonparity_count.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(edac_pci);\n\n \nstatic void edac_pci_release_main_kobj(struct kobject *kobj)\n{\n\tedac_dbg(0, \"here to module_put(THIS_MODULE)\\n\");\n\n\tkfree(kobj);\n\n\t \n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic struct kobj_type ktype_edac_pci_main_kobj = {\n\t.release = edac_pci_release_main_kobj,\n\t.sysfs_ops = &edac_pci_sysfs_ops,\n\t.default_groups = edac_pci_groups,\n};\n\n \nstatic int edac_pci_main_kobj_setup(void)\n{\n\tint err = -ENODEV;\n\tstruct bus_type *edac_subsys;\n\tstruct device *dev_root;\n\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tif (atomic_inc_return(&edac_pci_sysfs_refcount) != 1)\n\t\treturn 0;\n\n\t \n\tedac_subsys = edac_get_sysfs_subsys();\n\n\t \n\tif (!try_module_get(THIS_MODULE)) {\n\t\tedac_dbg(1, \"try_module_get() failed\\n\");\n\t\tgoto decrement_count_fail;\n\t}\n\n\tedac_pci_top_main_kobj = kzalloc(sizeof(struct kobject), GFP_KERNEL);\n\tif (!edac_pci_top_main_kobj) {\n\t\tedac_dbg(1, \"Failed to allocate\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto kzalloc_fail;\n\t}\n\n\t \n\tdev_root = bus_get_dev_root(edac_subsys);\n\tif (dev_root) {\n\t\terr = kobject_init_and_add(edac_pci_top_main_kobj,\n\t\t\t\t\t   &ktype_edac_pci_main_kobj,\n\t\t\t\t\t   &dev_root->kobj, \"pci\");\n\t\tput_device(dev_root);\n\t}\n\tif (err) {\n\t\tedac_dbg(1, \"Failed to register '.../edac/pci'\\n\");\n\t\tgoto kobject_init_and_add_fail;\n\t}\n\n\t \n\tkobject_uevent(edac_pci_top_main_kobj, KOBJ_ADD);\n\tedac_dbg(1, \"Registered '.../edac/pci' kobject\\n\");\n\n\treturn 0;\n\n\t \nkobject_init_and_add_fail:\n\tkobject_put(edac_pci_top_main_kobj);\n\nkzalloc_fail:\n\tmodule_put(THIS_MODULE);\n\ndecrement_count_fail:\n\t \n\tatomic_dec(&edac_pci_sysfs_refcount);\n\n\treturn err;\n}\n\n \nstatic void edac_pci_main_kobj_teardown(void)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\tif (atomic_dec_return(&edac_pci_sysfs_refcount) == 0) {\n\t\tedac_dbg(0, \"called kobject_put on main kobj\\n\");\n\t\tkobject_put(edac_pci_top_main_kobj);\n\t}\n}\n\nint edac_pci_create_sysfs(struct edac_pci_ctl_info *pci)\n{\n\tint err;\n\tstruct kobject *edac_kobj = &pci->kobj;\n\n\tedac_dbg(0, \"idx=%d\\n\", pci->pci_idx);\n\n\t \n\terr = edac_pci_main_kobj_setup();\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = edac_pci_create_instance_kobj(pci, pci->pci_idx);\n\tif (err)\n\t\tgoto unregister_cleanup;\n\n\terr = sysfs_create_link(edac_kobj, &pci->dev->kobj, EDAC_PCI_SYMLINK);\n\tif (err) {\n\t\tedac_dbg(0, \"sysfs_create_link() returned err= %d\\n\", err);\n\t\tgoto symlink_fail;\n\t}\n\n\treturn 0;\n\n\t \nsymlink_fail:\n\tedac_pci_unregister_sysfs_instance_kobj(pci);\n\nunregister_cleanup:\n\tedac_pci_main_kobj_teardown();\n\n\treturn err;\n}\n\nvoid edac_pci_remove_sysfs(struct edac_pci_ctl_info *pci)\n{\n\tedac_dbg(0, \"index=%d\\n\", pci->pci_idx);\n\n\t \n\tsysfs_remove_link(&pci->kobj, EDAC_PCI_SYMLINK);\n\n\t \n\tedac_pci_unregister_sysfs_instance_kobj(pci);\n\n\t \n\tedac_dbg(0, \"calling edac_pci_main_kobj_teardown()\\n\");\n\tedac_pci_main_kobj_teardown();\n}\n\n \nstatic u16 get_pci_parity_status(struct pci_dev *dev, int secondary)\n{\n\tint where;\n\tu16 status;\n\n\twhere = secondary ? PCI_SEC_STATUS : PCI_STATUS;\n\tpci_read_config_word(dev, where, &status);\n\n\t \n\n\tif (status == 0xFFFF) {\n\t\tu32 sanity;\n\n\t\tpci_read_config_dword(dev, 0, &sanity);\n\n\t\tif (sanity == 0xFFFFFFFF)\n\t\t\treturn 0;\n\t}\n\n\tstatus &= PCI_STATUS_DETECTED_PARITY | PCI_STATUS_SIG_SYSTEM_ERROR |\n\t\tPCI_STATUS_PARITY;\n\n\tif (status)\n\t\t \n\t\tpci_write_config_word(dev, where, status);\n\n\treturn status;\n}\n\n\n \nstatic void edac_pci_dev_parity_clear(struct pci_dev *dev)\n{\n\tu8 header_type;\n\n\tget_pci_parity_status(dev, 0);\n\n\t \n\tpci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\n\n\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE)\n\t\tget_pci_parity_status(dev, 1);\n}\n\n \nstatic void edac_pci_dev_parity_test(struct pci_dev *dev)\n{\n\tunsigned long flags;\n\tu16 status;\n\tu8 header_type;\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tstatus = get_pci_parity_status(dev, 0);\n\n\t \n\tpci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\n\n\tlocal_irq_restore(flags);\n\n\tedac_dbg(4, \"PCI STATUS= 0x%04x %s\\n\", status, dev_name(&dev->dev));\n\n\t \n\tif (status && !dev->broken_parity_status) {\n\t\tif (status & (PCI_STATUS_SIG_SYSTEM_ERROR)) {\n\t\t\tedac_printk(KERN_CRIT, EDAC_PCI,\n\t\t\t\t\"Signaled System Error on %s\\n\",\n\t\t\t\tpci_name(dev));\n\t\t\tatomic_inc(&pci_nonparity_count);\n\t\t}\n\n\t\tif (status & (PCI_STATUS_PARITY)) {\n\t\t\tedac_printk(KERN_CRIT, EDAC_PCI,\n\t\t\t\t\"Master Data Parity Error on %s\\n\",\n\t\t\t\tpci_name(dev));\n\n\t\t\tatomic_inc(&pci_parity_count);\n\t\t}\n\n\t\tif (status & (PCI_STATUS_DETECTED_PARITY)) {\n\t\t\tedac_printk(KERN_CRIT, EDAC_PCI,\n\t\t\t\t\"Detected Parity Error on %s\\n\",\n\t\t\t\tpci_name(dev));\n\n\t\t\tatomic_inc(&pci_parity_count);\n\t\t}\n\t}\n\n\n\tedac_dbg(4, \"PCI HEADER TYPE= 0x%02x %s\\n\",\n\t\t header_type, dev_name(&dev->dev));\n\n\tif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\n\t\t \n\t\tstatus = get_pci_parity_status(dev, 1);\n\n\t\tedac_dbg(4, \"PCI SEC_STATUS= 0x%04x %s\\n\",\n\t\t\t status, dev_name(&dev->dev));\n\n\t\t \n\t\tif (status && !dev->broken_parity_status) {\n\t\t\tif (status & (PCI_STATUS_SIG_SYSTEM_ERROR)) {\n\t\t\t\tedac_printk(KERN_CRIT, EDAC_PCI, \"Bridge \"\n\t\t\t\t\t\"Signaled System Error on %s\\n\",\n\t\t\t\t\tpci_name(dev));\n\t\t\t\tatomic_inc(&pci_nonparity_count);\n\t\t\t}\n\n\t\t\tif (status & (PCI_STATUS_PARITY)) {\n\t\t\t\tedac_printk(KERN_CRIT, EDAC_PCI, \"Bridge \"\n\t\t\t\t\t\"Master Data Parity Error on \"\n\t\t\t\t\t\"%s\\n\", pci_name(dev));\n\n\t\t\t\tatomic_inc(&pci_parity_count);\n\t\t\t}\n\n\t\t\tif (status & (PCI_STATUS_DETECTED_PARITY)) {\n\t\t\t\tedac_printk(KERN_CRIT, EDAC_PCI, \"Bridge \"\n\t\t\t\t\t\"Detected Parity Error on %s\\n\",\n\t\t\t\t\tpci_name(dev));\n\n\t\t\t\tatomic_inc(&pci_parity_count);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \ntypedef void (*pci_parity_check_fn_t) (struct pci_dev *dev);\n\n \nstatic inline void edac_pci_dev_parity_iterator(pci_parity_check_fn_t fn)\n{\n\tstruct pci_dev *dev = NULL;\n\n\tfor_each_pci_dev(dev)\n\t\tfn(dev);\n}\n\n \nvoid edac_pci_do_parity_check(void)\n{\n\tint before_count;\n\n\tedac_dbg(3, \"\\n\");\n\n\t \n\tif (!check_pci_errors)\n\t\treturn;\n\n\tbefore_count = atomic_read(&pci_parity_count);\n\n\t \n\tedac_pci_dev_parity_iterator(edac_pci_dev_parity_test);\n\n\t \n\tif (edac_pci_get_panic_on_pe()) {\n\t\t \n\t\tif (before_count != atomic_read(&pci_parity_count))\n\t\t\tpanic(\"EDAC: PCI Parity Error\");\n\t}\n}\n\n \nvoid edac_pci_clear_parity_errors(void)\n{\n\t \n\tedac_pci_dev_parity_iterator(edac_pci_dev_parity_clear);\n}\n\n \nvoid edac_pci_handle_pe(struct edac_pci_ctl_info *pci, const char *msg)\n{\n\n\t \n\tatomic_inc(&pci->counters.pe_count);\n\n\tif (edac_pci_get_log_pe())\n\t\tedac_pci_printk(pci, KERN_WARNING,\n\t\t\t\t\"Parity Error ctl: %s %d: %s\\n\",\n\t\t\t\tpci->ctl_name, pci->pci_idx, msg);\n\n\t \n\tedac_pci_do_parity_check();\n}\nEXPORT_SYMBOL_GPL(edac_pci_handle_pe);\n\n\n \nvoid edac_pci_handle_npe(struct edac_pci_ctl_info *pci, const char *msg)\n{\n\n\t \n\tatomic_inc(&pci->counters.npe_count);\n\n\tif (edac_pci_get_log_npe())\n\t\tedac_pci_printk(pci, KERN_WARNING,\n\t\t\t\t\"Non-Parity Error ctl: %s %d: %s\\n\",\n\t\t\t\tpci->ctl_name, pci->pci_idx, msg);\n\n\t \n\tedac_pci_do_parity_check();\n}\nEXPORT_SYMBOL_GPL(edac_pci_handle_npe);\n\n \nmodule_param(check_pci_errors, int, 0644);\nMODULE_PARM_DESC(check_pci_errors,\n\t\t \"Check for PCI bus parity errors: 0=off 1=on\");\nmodule_param(edac_pci_panic_on_pe, int, 0644);\nMODULE_PARM_DESC(edac_pci_panic_on_pe,\n\t\t \"Panic on PCI Bus Parity error: 0=off 1=on\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}