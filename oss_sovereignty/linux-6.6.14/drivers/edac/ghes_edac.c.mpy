{
  "module_name": "ghes_edac.c",
  "hash_id": "5fead822400443da1f02aa6106fa6d5ec5105c2fd876cd8d7842d8b734a2b9f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/ghes_edac.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <acpi/ghes.h>\n#include <linux/edac.h>\n#include <linux/dmi.h>\n#include \"edac_module.h\"\n#include <ras/ras_event.h>\n#include <linux/notifier.h>\n\n#define OTHER_DETAIL_LEN\t400\n\nstruct ghes_pvt {\n\tstruct mem_ctl_info *mci;\n\n\t \n\tchar other_detail[OTHER_DETAIL_LEN];\n\tchar msg[80];\n};\n\nstatic refcount_t ghes_refcount = REFCOUNT_INIT(0);\n\n \nstatic struct ghes_pvt *ghes_pvt;\n\n \nstatic struct ghes_hw_desc {\n\tint num_dimms;\n\tstruct dimm_info *dimms;\n} ghes_hw;\n\n \nstatic DEFINE_MUTEX(ghes_reg_mutex);\n\n \nstatic DEFINE_SPINLOCK(ghes_lock);\n\nstatic bool system_scanned;\n\nstatic struct list_head *ghes_devs;\n\n \nstruct memdev_dmi_entry {\n\tu8 type;\n\tu8 length;\n\tu16 handle;\n\tu16 phys_mem_array_handle;\n\tu16 mem_err_info_handle;\n\tu16 total_width;\n\tu16 data_width;\n\tu16 size;\n\tu8 form_factor;\n\tu8 device_set;\n\tu8 device_locator;\n\tu8 bank_locator;\n\tu8 memory_type;\n\tu16 type_detail;\n\tu16 speed;\n\tu8 manufacturer;\n\tu8 serial_number;\n\tu8 asset_tag;\n\tu8 part_number;\n\tu8 attributes;\n\tu32 extended_size;\n\tu16 conf_mem_clk_speed;\n} __attribute__((__packed__));\n\nstatic struct dimm_info *find_dimm_by_handle(struct mem_ctl_info *mci, u16 handle)\n{\n\tstruct dimm_info *dimm;\n\n\tmci_for_each_dimm(mci, dimm) {\n\t\tif (dimm->smbios_handle == handle)\n\t\t\treturn dimm;\n\t}\n\n\treturn NULL;\n}\n\nstatic void dimm_setup_label(struct dimm_info *dimm, u16 handle)\n{\n\tconst char *bank = NULL, *device = NULL;\n\n\tdmi_memdev_name(handle, &bank, &device);\n\n\t \n\tsnprintf(dimm->label, sizeof(dimm->label), \"%s%s%s\",\n\t\t (bank && *bank) ? bank : \"\",\n\t\t (bank && *bank && device && *device) ? \" \" : \"\",\n\t\t (device && *device) ? device : \"\");\n}\n\nstatic void assign_dmi_dimm_info(struct dimm_info *dimm, struct memdev_dmi_entry *entry)\n{\n\tu16 rdr_mask = BIT(7) | BIT(13);\n\n\tif (entry->size == 0xffff) {\n\t\tpr_info(\"Can't get DIMM%i size\\n\", dimm->idx);\n\t\tdimm->nr_pages = MiB_TO_PAGES(32); \n\t} else if (entry->size == 0x7fff) {\n\t\tdimm->nr_pages = MiB_TO_PAGES(entry->extended_size);\n\t} else {\n\t\tif (entry->size & BIT(15))\n\t\t\tdimm->nr_pages = MiB_TO_PAGES((entry->size & 0x7fff) << 10);\n\t\telse\n\t\t\tdimm->nr_pages = MiB_TO_PAGES(entry->size);\n\t}\n\n\tswitch (entry->memory_type) {\n\tcase 0x12:\n\t\tif (entry->type_detail & BIT(13))\n\t\t\tdimm->mtype = MEM_RDDR;\n\t\telse\n\t\t\tdimm->mtype = MEM_DDR;\n\t\tbreak;\n\tcase 0x13:\n\t\tif (entry->type_detail & BIT(13))\n\t\t\tdimm->mtype = MEM_RDDR2;\n\t\telse\n\t\t\tdimm->mtype = MEM_DDR2;\n\t\tbreak;\n\tcase 0x14:\n\t\tdimm->mtype = MEM_FB_DDR2;\n\t\tbreak;\n\tcase 0x18:\n\t\tif (entry->type_detail & BIT(12))\n\t\t\tdimm->mtype = MEM_NVDIMM;\n\t\telse if (entry->type_detail & BIT(13))\n\t\t\tdimm->mtype = MEM_RDDR3;\n\t\telse\n\t\t\tdimm->mtype = MEM_DDR3;\n\t\tbreak;\n\tcase 0x1a:\n\t\tif (entry->type_detail & BIT(12))\n\t\t\tdimm->mtype = MEM_NVDIMM;\n\t\telse if (entry->type_detail & BIT(13))\n\t\t\tdimm->mtype = MEM_RDDR4;\n\t\telse\n\t\t\tdimm->mtype = MEM_DDR4;\n\t\tbreak;\n\tdefault:\n\t\tif (entry->type_detail & BIT(6))\n\t\t\tdimm->mtype = MEM_RMBS;\n\t\telse if ((entry->type_detail & rdr_mask) == rdr_mask)\n\t\t\tdimm->mtype = MEM_RDR;\n\t\telse if (entry->type_detail & BIT(7))\n\t\t\tdimm->mtype = MEM_SDR;\n\t\telse if (entry->type_detail & BIT(9))\n\t\t\tdimm->mtype = MEM_EDO;\n\t\telse\n\t\t\tdimm->mtype = MEM_UNKNOWN;\n\t}\n\n\t \n\tif (entry->total_width == entry->data_width)\n\t\tdimm->edac_mode = EDAC_NONE;\n\telse\n\t\tdimm->edac_mode = EDAC_SECDED;\n\n\tdimm->dtype = DEV_UNKNOWN;\n\tdimm->grain = 128;\t\t \n\n\tdimm_setup_label(dimm, entry->handle);\n\n\tif (dimm->nr_pages) {\n\t\tedac_dbg(1, \"DIMM%i: %s size = %d MB%s\\n\",\n\t\t\tdimm->idx, edac_mem_types[dimm->mtype],\n\t\t\tPAGES_TO_MiB(dimm->nr_pages),\n\t\t\t(dimm->edac_mode != EDAC_NONE) ? \"(ECC)\" : \"\");\n\t\tedac_dbg(2, \"\\ttype %d, detail 0x%02x, width %d(total %d)\\n\",\n\t\t\tentry->memory_type, entry->type_detail,\n\t\t\tentry->total_width, entry->data_width);\n\t}\n\n\tdimm->smbios_handle = entry->handle;\n}\n\nstatic void enumerate_dimms(const struct dmi_header *dh, void *arg)\n{\n\tstruct memdev_dmi_entry *entry = (struct memdev_dmi_entry *)dh;\n\tstruct ghes_hw_desc *hw = (struct ghes_hw_desc *)arg;\n\tstruct dimm_info *d;\n\n\tif (dh->type != DMI_ENTRY_MEM_DEVICE)\n\t\treturn;\n\n\t \n\tif (!hw->num_dimms || !(hw->num_dimms % 16)) {\n\t\tstruct dimm_info *new;\n\n\t\tnew = krealloc_array(hw->dimms, hw->num_dimms + 16,\n\t\t\t\t     sizeof(struct dimm_info), GFP_KERNEL);\n\t\tif (!new) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn;\n\t\t}\n\n\t\thw->dimms = new;\n\t}\n\n\td = &hw->dimms[hw->num_dimms];\n\td->idx = hw->num_dimms;\n\n\tassign_dmi_dimm_info(d, entry);\n\n\thw->num_dimms++;\n}\n\nstatic void ghes_scan_system(void)\n{\n\tif (system_scanned)\n\t\treturn;\n\n\tdmi_walk(enumerate_dimms, &ghes_hw);\n\n\tsystem_scanned = true;\n}\n\nstatic int print_mem_error_other_detail(const struct cper_sec_mem_err *mem, char *msg,\n\t\t\t\t\tconst char *location, unsigned int len)\n{\n\tu32 n;\n\n\tif (!msg)\n\t\treturn 0;\n\n\tn = 0;\n\tlen -= 1;\n\n\tn += scnprintf(msg + n, len - n, \"APEI location: %s \", location);\n\n\tif (!(mem->validation_bits & CPER_MEM_VALID_ERROR_STATUS))\n\t\tgoto out;\n\n\tn += scnprintf(msg + n, len - n, \"status(0x%016llx): \", mem->error_status);\n\tn += scnprintf(msg + n, len - n, \"%s \", cper_mem_err_status_str(mem->error_status));\n\nout:\n\tmsg[n] = '\\0';\n\n\treturn n;\n}\n\nstatic int ghes_edac_report_mem_error(struct notifier_block *nb,\n\t\t\t\t      unsigned long val, void *data)\n{\n\tstruct cper_sec_mem_err *mem_err = (struct cper_sec_mem_err *)data;\n\tstruct cper_mem_err_compact cmem;\n\tstruct edac_raw_error_desc *e;\n\tstruct mem_ctl_info *mci;\n\tunsigned long sev = val;\n\tstruct ghes_pvt *pvt;\n\tunsigned long flags;\n\tchar *p;\n\n\t \n\tif (WARN_ON_ONCE(in_nmi()))\n\t\treturn NOTIFY_OK;\n\n\tspin_lock_irqsave(&ghes_lock, flags);\n\n\tpvt = ghes_pvt;\n\tif (!pvt)\n\t\tgoto unlock;\n\n\tmci = pvt->mci;\n\te = &mci->error_desc;\n\n\t \n\tmemset(e, 0, sizeof (*e));\n\te->error_count = 1;\n\te->grain = 1;\n\te->msg = pvt->msg;\n\te->other_detail = pvt->other_detail;\n\te->top_layer = -1;\n\te->mid_layer = -1;\n\te->low_layer = -1;\n\t*pvt->other_detail = '\\0';\n\t*pvt->msg = '\\0';\n\n\tswitch (sev) {\n\tcase GHES_SEV_CORRECTED:\n\t\te->type = HW_EVENT_ERR_CORRECTED;\n\t\tbreak;\n\tcase GHES_SEV_RECOVERABLE:\n\t\te->type = HW_EVENT_ERR_UNCORRECTED;\n\t\tbreak;\n\tcase GHES_SEV_PANIC:\n\t\te->type = HW_EVENT_ERR_FATAL;\n\t\tbreak;\n\tdefault:\n\tcase GHES_SEV_NO:\n\t\te->type = HW_EVENT_ERR_INFO;\n\t}\n\n\tedac_dbg(1, \"error validation_bits: 0x%08llx\\n\",\n\t\t (long long)mem_err->validation_bits);\n\n\t \n\tif (mem_err->validation_bits & CPER_MEM_VALID_ERROR_TYPE) {\n\t\tu8 etype = mem_err->error_type;\n\n\t\tp = pvt->msg;\n\t\tp += snprintf(p, sizeof(pvt->msg), \"%s\", cper_mem_err_type_str(etype));\n\t} else {\n\t\tstrcpy(pvt->msg, \"unknown error\");\n\t}\n\n\t \n\tif (mem_err->validation_bits & CPER_MEM_VALID_PA) {\n\t\te->page_frame_number = PHYS_PFN(mem_err->physical_addr);\n\t\te->offset_in_page = offset_in_page(mem_err->physical_addr);\n\t}\n\n\t \n\tif (mem_err->validation_bits & CPER_MEM_VALID_PA_MASK)\n\t\te->grain = ~mem_err->physical_addr_mask + 1;\n\n\t \n\tp = e->location;\n\tcper_mem_err_pack(mem_err, &cmem);\n\tp += cper_mem_err_location(&cmem, p);\n\n\tif (mem_err->validation_bits & CPER_MEM_VALID_MODULE_HANDLE) {\n\t\tstruct dimm_info *dimm;\n\n\t\tp += cper_dimm_err_location(&cmem, p);\n\t\tdimm = find_dimm_by_handle(mci, mem_err->mem_dev_handle);\n\t\tif (dimm) {\n\t\t\te->top_layer = dimm->idx;\n\t\t\tstrcpy(e->label, dimm->label);\n\t\t}\n\t}\n\tif (p > e->location)\n\t\t*(p - 1) = '\\0';\n\n\tif (!*e->label)\n\t\tstrcpy(e->label, \"unknown memory\");\n\n\t \n\tp = pvt->other_detail;\n\tp += print_mem_error_other_detail(mem_err, p, e->location, OTHER_DETAIL_LEN);\n\tif (p > pvt->other_detail)\n\t\t*(p - 1) = '\\0';\n\n\tedac_raw_mc_handle_error(e);\n\nunlock:\n\tspin_unlock_irqrestore(&ghes_lock, flags);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block ghes_edac_mem_err_nb = {\n\t.notifier_call\t= ghes_edac_report_mem_error,\n\t.priority\t= 0,\n};\n\nstatic int ghes_edac_register(struct device *dev)\n{\n\tbool fake = false;\n\tstruct mem_ctl_info *mci;\n\tstruct ghes_pvt *pvt;\n\tstruct edac_mc_layer layers[1];\n\tunsigned long flags;\n\tint rc = 0;\n\n\t \n\tmutex_lock(&ghes_reg_mutex);\n\n\t \n\tif (refcount_inc_not_zero(&ghes_refcount))\n\t\tgoto unlock;\n\n\tghes_scan_system();\n\n\t \n\tif (!ghes_hw.num_dimms) {\n\t\tfake = true;\n\t\tghes_hw.num_dimms = 1;\n\t}\n\n\tlayers[0].type = EDAC_MC_LAYER_ALL_MEM;\n\tlayers[0].size = ghes_hw.num_dimms;\n\tlayers[0].is_virt_csrow = true;\n\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(struct ghes_pvt));\n\tif (!mci) {\n\t\tpr_info(\"Can't allocate memory for EDAC data\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tpvt\t\t= mci->pvt_info;\n\tpvt->mci\t= mci;\n\n\tmci->pdev = dev;\n\tmci->mtype_cap = MEM_FLAG_EMPTY;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE;\n\tmci->edac_cap = EDAC_FLAG_NONE;\n\tmci->mod_name = \"ghes_edac.c\";\n\tmci->ctl_name = \"ghes_edac\";\n\tmci->dev_name = \"ghes\";\n\n\tif (fake) {\n\t\tpr_info(\"This system has a very crappy BIOS: It doesn't even list the DIMMS.\\n\");\n\t\tpr_info(\"Its SMBIOS info is wrong. It is doubtful that the error report would\\n\");\n\t\tpr_info(\"work on such system. Use this driver with caution\\n\");\n\t}\n\n\tpr_info(\"This system has %d DIMM sockets.\\n\", ghes_hw.num_dimms);\n\n\tif (!fake) {\n\t\tstruct dimm_info *src, *dst;\n\t\tint i = 0;\n\n\t\tmci_for_each_dimm(mci, dst) {\n\t\t\tsrc = &ghes_hw.dimms[i];\n\n\t\t\tdst->idx\t   = src->idx;\n\t\t\tdst->smbios_handle = src->smbios_handle;\n\t\t\tdst->nr_pages\t   = src->nr_pages;\n\t\t\tdst->mtype\t   = src->mtype;\n\t\t\tdst->edac_mode\t   = src->edac_mode;\n\t\t\tdst->dtype\t   = src->dtype;\n\t\t\tdst->grain\t   = src->grain;\n\n\t\t\t \n\t\t\tif (strlen(src->label))\n\t\t\t\tmemcpy(dst->label, src->label, sizeof(src->label));\n\n\t\t\ti++;\n\t\t}\n\n\t} else {\n\t\tstruct dimm_info *dimm = edac_get_dimm(mci, 0, 0, 0);\n\n\t\tdimm->nr_pages = 1;\n\t\tdimm->grain = 128;\n\t\tdimm->mtype = MEM_UNKNOWN;\n\t\tdimm->dtype = DEV_UNKNOWN;\n\t\tdimm->edac_mode = EDAC_SECDED;\n\t}\n\n\trc = edac_mc_add_mc(mci);\n\tif (rc < 0) {\n\t\tpr_info(\"Can't register with the EDAC core\\n\");\n\t\tedac_mc_free(mci);\n\t\trc = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tspin_lock_irqsave(&ghes_lock, flags);\n\tghes_pvt = pvt;\n\tspin_unlock_irqrestore(&ghes_lock, flags);\n\n\tghes_register_report_chain(&ghes_edac_mem_err_nb);\n\n\t \n\trefcount_set(&ghes_refcount, 1);\n\nunlock:\n\n\t \n\tkfree(ghes_hw.dimms);\n\tghes_hw.dimms = NULL;\n\n\tmutex_unlock(&ghes_reg_mutex);\n\n\treturn rc;\n}\n\nstatic void ghes_edac_unregister(struct ghes *ghes)\n{\n\tstruct mem_ctl_info *mci;\n\tunsigned long flags;\n\n\tmutex_lock(&ghes_reg_mutex);\n\n\tsystem_scanned = false;\n\tmemset(&ghes_hw, 0, sizeof(struct ghes_hw_desc));\n\n\tif (!refcount_dec_and_test(&ghes_refcount))\n\t\tgoto unlock;\n\n\t \n\tspin_lock_irqsave(&ghes_lock, flags);\n\tmci = ghes_pvt ? ghes_pvt->mci : NULL;\n\tghes_pvt = NULL;\n\tspin_unlock_irqrestore(&ghes_lock, flags);\n\n\tif (!mci)\n\t\tgoto unlock;\n\n\tmci = edac_mc_del_mc(mci->pdev);\n\tif (mci)\n\t\tedac_mc_free(mci);\n\n\tghes_unregister_report_chain(&ghes_edac_mem_err_nb);\n\nunlock:\n\tmutex_unlock(&ghes_reg_mutex);\n}\n\nstatic int __init ghes_edac_init(void)\n{\n\tstruct ghes *g, *g_tmp;\n\n\tghes_devs = ghes_get_devices();\n\tif (!ghes_devs)\n\t\treturn -ENODEV;\n\n\tif (list_empty(ghes_devs)) {\n\t\tpr_info(\"GHES probing device list is empty\");\n\t\treturn -ENODEV;\n\t}\n\n\tlist_for_each_entry_safe(g, g_tmp, ghes_devs, elist) {\n\t\tghes_edac_register(g->dev);\n\t}\n\n\treturn 0;\n}\nmodule_init(ghes_edac_init);\n\nstatic void __exit ghes_edac_exit(void)\n{\n\tstruct ghes *g, *g_tmp;\n\n\tlist_for_each_entry_safe(g, g_tmp, ghes_devs, elist) {\n\t\tghes_edac_unregister(g);\n\t}\n}\nmodule_exit(ghes_edac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Output ACPI APEI/GHES BIOS detected errors via EDAC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}