{
  "module_name": "i82875p_edac.c",
  "hash_id": "2754f595668bd94da837fe5941be2380c18a4c5142a1fe1b4116fbce70085c09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i82875p_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\t\"i82875p_edac\"\n\n#define i82875p_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"i82875p\", fmt, ##arg)\n\n#define i82875p_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"i82875p\", fmt, ##arg)\n\n#ifndef PCI_DEVICE_ID_INTEL_82875_0\n#define PCI_DEVICE_ID_INTEL_82875_0\t0x2578\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_82875_6\n#define PCI_DEVICE_ID_INTEL_82875_6\t0x257e\n#endif\t\t\t\t \n\n \n#define I82875P_NR_DIMMS\t\t8\n#define I82875P_NR_CSROWS(nr_chans)\t(I82875P_NR_DIMMS / (nr_chans))\n\n \n#define I82875P_EAP\t\t0x58\t \n\n#define I82875P_DERRSYN\t\t0x5c\t \n\n#define I82875P_DES\t\t0x5d\t \n\n#define I82875P_ERRSTS\t\t0xc8\t \n\n#define I82875P_ERRCMD\t\t0xca\t \n\n \n#define I82875P_PCICMD6\t\t0x04\t \n\n#define I82875P_BAR6\t\t0x10\t \n\n \n\n#define I82875P_DRB_SHIFT 26\t \n#define I82875P_DRB\t\t0x00\t \n\n#define I82875P_DRA\t\t0x10\t \n\n#define I82875P_DRC\t\t0x68\t \n\nenum i82875p_chips {\n\tI82875P = 0,\n};\n\nstruct i82875p_pvt {\n\tstruct pci_dev *ovrfl_pdev;\n\tvoid __iomem *ovrfl_window;\n};\n\nstruct i82875p_dev_info {\n\tconst char *ctl_name;\n};\n\nstruct i82875p_error_info {\n\tu16 errsts;\n\tu32 eap;\n\tu8 des;\n\tu8 derrsyn;\n\tu16 errsts2;\n};\n\nstatic const struct i82875p_dev_info i82875p_devs[] = {\n\t[I82875P] = {\n\t\t.ctl_name = \"i82875p\"},\n};\n\nstatic struct pci_dev *mci_pdev;\t \n\nstatic struct edac_pci_ctl_info *i82875p_pci;\n\nstatic void i82875p_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct i82875p_error_info *info)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(mci->pdev);\n\n\t \n\tpci_read_config_word(pdev, I82875P_ERRSTS, &info->errsts);\n\n\tif (!(info->errsts & 0x0081))\n\t\treturn;\n\n\tpci_read_config_dword(pdev, I82875P_EAP, &info->eap);\n\tpci_read_config_byte(pdev, I82875P_DES, &info->des);\n\tpci_read_config_byte(pdev, I82875P_DERRSYN, &info->derrsyn);\n\tpci_read_config_word(pdev, I82875P_ERRSTS, &info->errsts2);\n\n\t \n\tif ((info->errsts ^ info->errsts2) & 0x0081) {\n\t\tpci_read_config_dword(pdev, I82875P_EAP, &info->eap);\n\t\tpci_read_config_byte(pdev, I82875P_DES, &info->des);\n\t\tpci_read_config_byte(pdev, I82875P_DERRSYN, &info->derrsyn);\n\t}\n\n\tpci_write_bits16(pdev, I82875P_ERRSTS, 0x0081, 0x0081);\n}\n\nstatic int i82875p_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct i82875p_error_info *info,\n\t\t\t\tint handle_errors)\n{\n\tint row, multi_chan;\n\n\tmulti_chan = mci->csrows[0]->nr_channels - 1;\n\n\tif (!(info->errsts & 0x0081))\n\t\treturn 0;\n\n\tif (!handle_errors)\n\t\treturn 1;\n\n\tif ((info->errsts ^ info->errsts2) & 0x0081) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1,\n\t\t\t\t     \"UE overwrote CE\", \"\");\n\t\tinfo->errsts = info->errsts2;\n\t}\n\n\tinfo->eap >>= PAGE_SHIFT;\n\trow = edac_mc_find_csrow_by_page(mci, info->eap);\n\n\tif (info->errsts & 0x0080)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     info->eap, 0, 0,\n\t\t\t\t     row, -1, -1,\n\t\t\t\t     \"i82875p UE\", \"\");\n\telse\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t     info->eap, 0, info->derrsyn,\n\t\t\t\t     row, multi_chan ? (info->des & 0x1) : 0,\n\t\t\t\t     -1, \"i82875p CE\", \"\");\n\n\treturn 1;\n}\n\nstatic void i82875p_check(struct mem_ctl_info *mci)\n{\n\tstruct i82875p_error_info info;\n\n\ti82875p_get_error_info(mci, &info);\n\ti82875p_process_error_info(mci, &info, 1);\n}\n\n \nstatic int i82875p_setup_overfl_dev(struct pci_dev *pdev,\n\t\t\t\tstruct pci_dev **ovrfl_pdev,\n\t\t\t\tvoid __iomem **ovrfl_window)\n{\n\tstruct pci_dev *dev;\n\tvoid __iomem *window;\n\n\t*ovrfl_pdev = NULL;\n\t*ovrfl_window = NULL;\n\tdev = pci_get_device(PCI_VEND_DEV(INTEL, 82875_6), NULL);\n\n\tif (dev == NULL) {\n\t\t \n\t\tpci_write_bits8(pdev, 0xf4, 0x2, 0x2);\n\t\tdev = pci_scan_single_device(pdev->bus, PCI_DEVFN(6, 0));\n\n\t\tif (dev == NULL)\n\t\t\treturn 1;\n\n\t\tpci_bus_assign_resources(dev->bus);\n\t\tpci_bus_add_device(dev);\n\t}\n\n\t*ovrfl_pdev = dev;\n\n\tif (pci_enable_device(dev)) {\n\t\ti82875p_printk(KERN_ERR, \"%s(): Failed to enable overflow \"\n\t\t\t\"device\\n\", __func__);\n\t\treturn 1;\n\t}\n\n\tif (pci_request_regions(dev, pci_name(dev))) {\n#ifdef CORRECT_BIOS\n\t\tgoto fail0;\n#endif\n\t}\n\n\t \n\twindow = pci_ioremap_bar(dev, 0);\n\tif (window == NULL) {\n\t\ti82875p_printk(KERN_ERR, \"%s(): Failed to ioremap bar6\\n\",\n\t\t\t__func__);\n\t\tgoto fail1;\n\t}\n\n\t*ovrfl_window = window;\n\treturn 0;\n\nfail1:\n\tpci_release_regions(dev);\n\n#ifdef CORRECT_BIOS\nfail0:\n\tpci_disable_device(dev);\n#endif\n\t \n\treturn 1;\n}\n\n \nstatic inline int dual_channel_active(u32 drc)\n{\n\treturn (drc >> 21) & 0x1;\n}\n\nstatic void i82875p_init_csrows(struct mem_ctl_info *mci,\n\t\t\t\tstruct pci_dev *pdev,\n\t\t\t\tvoid __iomem * ovrfl_window, u32 drc)\n{\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\tunsigned nr_chans = dual_channel_active(drc) + 1;\n\tunsigned long last_cumul_size;\n\tu8 value;\n\tu32 drc_ddim;\t\t \n\tu32 cumul_size, nr_pages;\n\tint index, j;\n\n\tdrc_ddim = (drc >> 18) & 0x1;\n\tlast_cumul_size = 0;\n\n\t \n\n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\tcsrow = mci->csrows[index];\n\n\t\tvalue = readb(ovrfl_window + I82875P_DRB + index);\n\t\tcumul_size = value << (I82875P_DRB_SHIFT - PAGE_SHIFT);\n\t\tedac_dbg(3, \"(%d) cumul_size 0x%x\\n\", index, cumul_size);\n\t\tif (cumul_size == last_cumul_size)\n\t\t\tcontinue;\t \n\n\t\tcsrow->first_page = last_cumul_size;\n\t\tcsrow->last_page = cumul_size - 1;\n\t\tnr_pages = cumul_size - last_cumul_size;\n\t\tlast_cumul_size = cumul_size;\n\n\t\tfor (j = 0; j < nr_chans; j++) {\n\t\t\tdimm = csrow->channels[j]->dimm;\n\n\t\t\tdimm->nr_pages = nr_pages / nr_chans;\n\t\t\tdimm->grain = 1 << 12;\t \n\t\t\tdimm->mtype = MEM_DDR;\n\t\t\tdimm->dtype = DEV_UNKNOWN;\n\t\t\tdimm->edac_mode = drc_ddim ? EDAC_SECDED : EDAC_NONE;\n\t\t}\n\t}\n}\n\nstatic int i82875p_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tint rc = -ENODEV;\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tstruct i82875p_pvt *pvt;\n\tstruct pci_dev *ovrfl_pdev;\n\tvoid __iomem *ovrfl_window;\n\tu32 drc;\n\tu32 nr_chans;\n\tstruct i82875p_error_info discard;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (i82875p_setup_overfl_dev(pdev, &ovrfl_pdev, &ovrfl_window))\n\t\treturn -ENODEV;\n\tdrc = readl(ovrfl_window + I82875P_DRC);\n\tnr_chans = dual_channel_active(drc) + 1;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = I82875P_NR_CSROWS(nr_chans);\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = nr_chans;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (!mci) {\n\t\trc = -ENOMEM;\n\t\tgoto fail0;\n\t}\n\n\tedac_dbg(3, \"init mci\\n\");\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_DDR;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_UNKNOWN;\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = i82875p_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = i82875p_check;\n\tmci->ctl_page_to_phys = NULL;\n\tedac_dbg(3, \"init pvt\\n\");\n\tpvt = (struct i82875p_pvt *)mci->pvt_info;\n\tpvt->ovrfl_pdev = ovrfl_pdev;\n\tpvt->ovrfl_window = ovrfl_window;\n\ti82875p_init_csrows(mci, pdev, ovrfl_window, drc);\n\ti82875p_get_error_info(mci, &discard);\t \n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"failed edac_mc_add_mc()\\n\");\n\t\tgoto fail1;\n\t}\n\n\t \n\ti82875p_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!i82875p_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\t \n\tedac_dbg(3, \"success\\n\");\n\treturn 0;\n\nfail1:\n\tedac_mc_free(mci);\n\nfail0:\n\tiounmap(ovrfl_window);\n\tpci_release_regions(ovrfl_pdev);\n\n\tpci_disable_device(ovrfl_pdev);\n\t \n\treturn rc;\n}\n\n \nstatic int i82875p_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tint rc;\n\n\tedac_dbg(0, \"\\n\");\n\ti82875p_printk(KERN_INFO, \"i82875p init one\\n\");\n\n\tif (pci_enable_device(pdev) < 0)\n\t\treturn -EIO;\n\n\trc = i82875p_probe1(pdev, ent->driver_data);\n\n\tif (mci_pdev == NULL)\n\t\tmci_pdev = pci_dev_get(pdev);\n\n\treturn rc;\n}\n\nstatic void i82875p_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct i82875p_pvt *pvt = NULL;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (i82875p_pci)\n\t\tedac_pci_release_generic_ctl(i82875p_pci);\n\n\tif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\n\t\treturn;\n\n\tpvt = (struct i82875p_pvt *)mci->pvt_info;\n\n\tif (pvt->ovrfl_window)\n\t\tiounmap(pvt->ovrfl_window);\n\n\tif (pvt->ovrfl_pdev) {\n#ifdef CORRECT_BIOS\n\t\tpci_release_regions(pvt->ovrfl_pdev);\n#endif\t\t\t\t \n\t\tpci_disable_device(pvt->ovrfl_pdev);\n\t\tpci_dev_put(pvt->ovrfl_pdev);\n\t}\n\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id i82875p_pci_tbl[] = {\n\t{\n\t PCI_VEND_DEV(INTEL, 82875_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t I82875P},\n\t{\n\t 0,\n\t }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, i82875p_pci_tbl);\n\nstatic struct pci_driver i82875p_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = i82875p_init_one,\n\t.remove = i82875p_remove_one,\n\t.id_table = i82875p_pci_tbl,\n};\n\nstatic int __init i82875p_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(3, \"\\n\");\n\n        \n       opstate_init();\n\n\tpci_rc = pci_register_driver(&i82875p_driver);\n\n\tif (pci_rc < 0)\n\t\tgoto fail0;\n\n\tif (mci_pdev == NULL) {\n\t\tmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t\tPCI_DEVICE_ID_INTEL_82875_0, NULL);\n\n\t\tif (!mci_pdev) {\n\t\t\tedac_dbg(0, \"875p pci_get_device fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tpci_rc = i82875p_init_one(mci_pdev, i82875p_pci_tbl);\n\n\t\tif (pci_rc < 0) {\n\t\t\tedac_dbg(0, \"875p init fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail1:\n\tpci_unregister_driver(&i82875p_driver);\n\nfail0:\n\tpci_dev_put(mci_pdev);\n\treturn pci_rc;\n}\n\nstatic void __exit i82875p_exit(void)\n{\n\tedac_dbg(3, \"\\n\");\n\n\ti82875p_remove_one(mci_pdev);\n\tpci_dev_put(mci_pdev);\n\n\tpci_unregister_driver(&i82875p_driver);\n\n}\n\nmodule_init(i82875p_init);\nmodule_exit(i82875p_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Linux Networx (http://lnxi.com) Thayne Harbaugh\");\nMODULE_DESCRIPTION(\"MC support for Intel 82875 memory hub controllers\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}