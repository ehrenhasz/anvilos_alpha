{
  "module_name": "i10nm_base.c",
  "hash_id": "4be6188db2225b769f719cdf09afd2b8700469911c5d781563f81d9935d0204c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i10nm_base.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/mce.h>\n#include \"edac_module.h\"\n#include \"skx_common.h\"\n\n#define I10NM_REVISION\t\"v0.0.6\"\n#define EDAC_MOD_STR\t\"i10nm_edac\"\n\n \n#define i10nm_printk(level, fmt, arg...)\t\\\n\tedac_printk(level, \"i10nm\", fmt, ##arg)\n\n#define I10NM_GET_SCK_BAR(d, reg)\t\\\n\tpci_read_config_dword((d)->uracu, 0xd0, &(reg))\n#define I10NM_GET_IMC_BAR(d, i, reg)\t\t\\\n\tpci_read_config_dword((d)->uracu,\t\\\n\t(res_cfg->type == GNR ? 0xd4 : 0xd8) + (i) * 4, &(reg))\n#define I10NM_GET_SAD(d, offset, i, reg)\\\n\tpci_read_config_dword((d)->sad_all, (offset) + (i) * \\\n\t(res_cfg->type == GNR ? 12 : 8), &(reg))\n#define I10NM_GET_HBM_IMC_BAR(d, reg)\t\\\n\tpci_read_config_dword((d)->uracu, 0xd4, &(reg))\n#define I10NM_GET_CAPID3_CFG(d, reg)\t\\\n\tpci_read_config_dword((d)->pcu_cr3,\t\\\n\tres_cfg->type == GNR ? 0x290 : 0x90, &(reg))\n#define I10NM_GET_CAPID5_CFG(d, reg)\t\\\n\tpci_read_config_dword((d)->pcu_cr3,\t\\\n\tres_cfg->type == GNR ? 0x298 : 0x98, &(reg))\n#define I10NM_GET_DIMMMTR(m, i, j)\t\\\n\treadl((m)->mbase + ((m)->hbm_mc ? 0x80c :\t\\\n\t(res_cfg->type == GNR ? 0xc0c : 0x2080c)) +\t\\\n\t(i) * (m)->chan_mmio_sz + (j) * 4)\n#define I10NM_GET_MCDDRTCFG(m, i)\t\\\n\treadl((m)->mbase + ((m)->hbm_mc ? 0x970 : 0x20970) + \\\n\t(i) * (m)->chan_mmio_sz)\n#define I10NM_GET_MCMTR(m, i)\t\t\\\n\treadl((m)->mbase + ((m)->hbm_mc ? 0xef8 :\t\\\n\t(res_cfg->type == GNR ? 0xaf8 : 0x20ef8)) +\t\\\n\t(i) * (m)->chan_mmio_sz)\n#define I10NM_GET_AMAP(m, i)\t\t\\\n\treadl((m)->mbase + ((m)->hbm_mc ? 0x814 :\t\\\n\t(res_cfg->type == GNR ? 0xc14 : 0x20814)) +\t\\\n\t(i) * (m)->chan_mmio_sz)\n#define I10NM_GET_REG32(m, i, offset)\t\\\n\treadl((m)->mbase + (i) * (m)->chan_mmio_sz + (offset))\n#define I10NM_GET_REG64(m, i, offset)\t\\\n\treadq((m)->mbase + (i) * (m)->chan_mmio_sz + (offset))\n#define I10NM_SET_REG32(m, i, offset, v)\t\\\n\twritel(v, (m)->mbase + (i) * (m)->chan_mmio_sz + (offset))\n\n#define I10NM_GET_SCK_MMIO_BASE(reg)\t(GET_BITFIELD(reg, 0, 28) << 23)\n#define I10NM_GET_IMC_MMIO_OFFSET(reg)\t(GET_BITFIELD(reg, 0, 10) << 12)\n#define I10NM_GET_IMC_MMIO_SIZE(reg)\t((GET_BITFIELD(reg, 13, 23) - \\\n\t\t\t\t\t GET_BITFIELD(reg, 0, 10) + 1) << 12)\n#define I10NM_GET_HBM_IMC_MMIO_OFFSET(reg)\t\\\n\t((GET_BITFIELD(reg, 0, 10) << 12) + 0x140000)\n\n#define I10NM_GNR_IMC_MMIO_OFFSET\t0x24c000\n#define I10NM_GNR_IMC_MMIO_SIZE\t\t0x4000\n#define I10NM_HBM_IMC_MMIO_SIZE\t\t0x9000\n#define I10NM_DDR_IMC_CH_CNT(reg)\tGET_BITFIELD(reg, 21, 24)\n#define I10NM_IS_HBM_PRESENT(reg)\tGET_BITFIELD(reg, 27, 30)\n#define I10NM_IS_HBM_IMC(reg)\t\tGET_BITFIELD(reg, 29, 29)\n\n#define I10NM_MAX_SAD\t\t\t16\n#define I10NM_SAD_ENABLE(reg)\t\tGET_BITFIELD(reg, 0, 0)\n#define I10NM_SAD_NM_CACHEABLE(reg)\tGET_BITFIELD(reg, 5, 5)\n\n#define RETRY_RD_ERR_LOG_UC\t\tBIT(1)\n#define RETRY_RD_ERR_LOG_NOOVER\t\tBIT(14)\n#define RETRY_RD_ERR_LOG_EN\t\tBIT(15)\n#define RETRY_RD_ERR_LOG_NOOVER_UC\t(BIT(14) | BIT(1))\n#define RETRY_RD_ERR_LOG_OVER_UC_V\t(BIT(2) | BIT(1) | BIT(0))\n\nstatic struct list_head *i10nm_edac_list;\n\nstatic struct res_config *res_cfg;\nstatic int retry_rd_err_log;\nstatic int decoding_via_mca;\nstatic bool mem_cfg_2lm;\n\nstatic u32 offsets_scrub_icx[]  = {0x22c60, 0x22c54, 0x22c5c, 0x22c58, 0x22c28, 0x20ed8};\nstatic u32 offsets_scrub_spr[]  = {0x22c60, 0x22c54, 0x22f08, 0x22c58, 0x22c28, 0x20ed8};\nstatic u32 offsets_scrub_spr_hbm0[]  = {0x2860, 0x2854, 0x2b08, 0x2858, 0x2828, 0x0ed8};\nstatic u32 offsets_scrub_spr_hbm1[]  = {0x2c60, 0x2c54, 0x2f08, 0x2c58, 0x2c28, 0x0fa8};\nstatic u32 offsets_demand_icx[] = {0x22e54, 0x22e60, 0x22e64, 0x22e58, 0x22e5c, 0x20ee0};\nstatic u32 offsets_demand_spr[] = {0x22e54, 0x22e60, 0x22f10, 0x22e58, 0x22e5c, 0x20ee0};\nstatic u32 offsets_demand2_spr[] = {0x22c70, 0x22d80, 0x22f18, 0x22d58, 0x22c64, 0x20f10};\nstatic u32 offsets_demand_spr_hbm0[] = {0x2a54, 0x2a60, 0x2b10, 0x2a58, 0x2a5c, 0x0ee0};\nstatic u32 offsets_demand_spr_hbm1[] = {0x2e54, 0x2e60, 0x2f10, 0x2e58, 0x2e5c, 0x0fb0};\n\nstatic void __enable_retry_rd_err_log(struct skx_imc *imc, int chan, bool enable,\n\t\t\t\t      u32 *offsets_scrub, u32 *offsets_demand,\n\t\t\t\t      u32 *offsets_demand2)\n{\n\tu32 s, d, d2;\n\n\ts = I10NM_GET_REG32(imc, chan, offsets_scrub[0]);\n\td = I10NM_GET_REG32(imc, chan, offsets_demand[0]);\n\tif (offsets_demand2)\n\t\td2 = I10NM_GET_REG32(imc, chan, offsets_demand2[0]);\n\n\tif (enable) {\n\t\t \n\t\timc->chan[chan].retry_rd_err_log_s = s;\n\t\timc->chan[chan].retry_rd_err_log_d = d;\n\t\tif (offsets_demand2)\n\t\t\timc->chan[chan].retry_rd_err_log_d2 = d2;\n\n\t\ts &= ~RETRY_RD_ERR_LOG_NOOVER_UC;\n\t\ts |=  RETRY_RD_ERR_LOG_EN;\n\t\td &= ~RETRY_RD_ERR_LOG_NOOVER_UC;\n\t\td |=  RETRY_RD_ERR_LOG_EN;\n\n\t\tif (offsets_demand2) {\n\t\t\td2 &= ~RETRY_RD_ERR_LOG_UC;\n\t\t\td2 |=  RETRY_RD_ERR_LOG_NOOVER;\n\t\t\td2 |=  RETRY_RD_ERR_LOG_EN;\n\t\t}\n\t} else {\n\t\t \n\t\tif (imc->chan[chan].retry_rd_err_log_s & RETRY_RD_ERR_LOG_UC)\n\t\t\ts |=  RETRY_RD_ERR_LOG_UC;\n\t\tif (imc->chan[chan].retry_rd_err_log_s & RETRY_RD_ERR_LOG_NOOVER)\n\t\t\ts |=  RETRY_RD_ERR_LOG_NOOVER;\n\t\tif (!(imc->chan[chan].retry_rd_err_log_s & RETRY_RD_ERR_LOG_EN))\n\t\t\ts &= ~RETRY_RD_ERR_LOG_EN;\n\t\tif (imc->chan[chan].retry_rd_err_log_d & RETRY_RD_ERR_LOG_UC)\n\t\t\td |=  RETRY_RD_ERR_LOG_UC;\n\t\tif (imc->chan[chan].retry_rd_err_log_d & RETRY_RD_ERR_LOG_NOOVER)\n\t\t\td |=  RETRY_RD_ERR_LOG_NOOVER;\n\t\tif (!(imc->chan[chan].retry_rd_err_log_d & RETRY_RD_ERR_LOG_EN))\n\t\t\td &= ~RETRY_RD_ERR_LOG_EN;\n\n\t\tif (offsets_demand2) {\n\t\t\tif (imc->chan[chan].retry_rd_err_log_d2 & RETRY_RD_ERR_LOG_UC)\n\t\t\t\td2 |=  RETRY_RD_ERR_LOG_UC;\n\t\t\tif (!(imc->chan[chan].retry_rd_err_log_d2 & RETRY_RD_ERR_LOG_NOOVER))\n\t\t\t\td2 &=  ~RETRY_RD_ERR_LOG_NOOVER;\n\t\t\tif (!(imc->chan[chan].retry_rd_err_log_d2 & RETRY_RD_ERR_LOG_EN))\n\t\t\t\td2 &= ~RETRY_RD_ERR_LOG_EN;\n\t\t}\n\t}\n\n\tI10NM_SET_REG32(imc, chan, offsets_scrub[0], s);\n\tI10NM_SET_REG32(imc, chan, offsets_demand[0], d);\n\tif (offsets_demand2)\n\t\tI10NM_SET_REG32(imc, chan, offsets_demand2[0], d2);\n}\n\nstatic void enable_retry_rd_err_log(bool enable)\n{\n\tint i, j, imc_num, chan_num;\n\tstruct skx_imc *imc;\n\tstruct skx_dev *d;\n\n\tedac_dbg(2, \"\\n\");\n\n\tlist_for_each_entry(d, i10nm_edac_list, list) {\n\t\timc_num  = res_cfg->ddr_imc_num;\n\t\tchan_num = res_cfg->ddr_chan_num;\n\n\t\tfor (i = 0; i < imc_num; i++) {\n\t\t\timc = &d->imc[i];\n\t\t\tif (!imc->mbase)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < chan_num; j++)\n\t\t\t\t__enable_retry_rd_err_log(imc, j, enable,\n\t\t\t\t\t\t\t  res_cfg->offsets_scrub,\n\t\t\t\t\t\t\t  res_cfg->offsets_demand,\n\t\t\t\t\t\t\t  res_cfg->offsets_demand2);\n\t\t}\n\n\t\timc_num += res_cfg->hbm_imc_num;\n\t\tchan_num = res_cfg->hbm_chan_num;\n\n\t\tfor (; i < imc_num; i++) {\n\t\t\timc = &d->imc[i];\n\t\t\tif (!imc->mbase || !imc->hbm_mc)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < chan_num; j++) {\n\t\t\t\t__enable_retry_rd_err_log(imc, j, enable,\n\t\t\t\t\t\t\t  res_cfg->offsets_scrub_hbm0,\n\t\t\t\t\t\t\t  res_cfg->offsets_demand_hbm0,\n\t\t\t\t\t\t\t  NULL);\n\t\t\t\t__enable_retry_rd_err_log(imc, j, enable,\n\t\t\t\t\t\t\t  res_cfg->offsets_scrub_hbm1,\n\t\t\t\t\t\t\t  res_cfg->offsets_demand_hbm1,\n\t\t\t\t\t\t\t  NULL);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void show_retry_rd_err_log(struct decoded_addr *res, char *msg,\n\t\t\t\t  int len, bool scrub_err)\n{\n\tstruct skx_imc *imc = &res->dev->imc[res->imc];\n\tu32 log0, log1, log2, log3, log4;\n\tu32 corr0, corr1, corr2, corr3;\n\tu32 lxg0, lxg1, lxg3, lxg4;\n\tu32 *xffsets = NULL;\n\tu64 log2a, log5;\n\tu64 lxg2a, lxg5;\n\tu32 *offsets;\n\tint n, pch;\n\n\tif (!imc->mbase)\n\t\treturn;\n\n\tif (imc->hbm_mc) {\n\t\tpch = res->cs & 1;\n\n\t\tif (pch)\n\t\t\toffsets = scrub_err ? res_cfg->offsets_scrub_hbm1 :\n\t\t\t\t\t      res_cfg->offsets_demand_hbm1;\n\t\telse\n\t\t\toffsets = scrub_err ? res_cfg->offsets_scrub_hbm0 :\n\t\t\t\t\t      res_cfg->offsets_demand_hbm0;\n\t} else {\n\t\tif (scrub_err) {\n\t\t\toffsets = res_cfg->offsets_scrub;\n\t\t} else {\n\t\t\toffsets = res_cfg->offsets_demand;\n\t\t\txffsets = res_cfg->offsets_demand2;\n\t\t}\n\t}\n\n\tlog0 = I10NM_GET_REG32(imc, res->channel, offsets[0]);\n\tlog1 = I10NM_GET_REG32(imc, res->channel, offsets[1]);\n\tlog3 = I10NM_GET_REG32(imc, res->channel, offsets[3]);\n\tlog4 = I10NM_GET_REG32(imc, res->channel, offsets[4]);\n\tlog5 = I10NM_GET_REG64(imc, res->channel, offsets[5]);\n\n\tif (xffsets) {\n\t\tlxg0 = I10NM_GET_REG32(imc, res->channel, xffsets[0]);\n\t\tlxg1 = I10NM_GET_REG32(imc, res->channel, xffsets[1]);\n\t\tlxg3 = I10NM_GET_REG32(imc, res->channel, xffsets[3]);\n\t\tlxg4 = I10NM_GET_REG32(imc, res->channel, xffsets[4]);\n\t\tlxg5 = I10NM_GET_REG64(imc, res->channel, xffsets[5]);\n\t}\n\n\tif (res_cfg->type == SPR) {\n\t\tlog2a = I10NM_GET_REG64(imc, res->channel, offsets[2]);\n\t\tn = snprintf(msg, len, \" retry_rd_err_log[%.8x %.8x %.16llx %.8x %.8x %.16llx\",\n\t\t\t     log0, log1, log2a, log3, log4, log5);\n\n\t\tif (len - n > 0) {\n\t\t\tif (xffsets) {\n\t\t\t\tlxg2a = I10NM_GET_REG64(imc, res->channel, xffsets[2]);\n\t\t\t\tn += snprintf(msg + n, len - n, \" %.8x %.8x %.16llx %.8x %.8x %.16llx]\",\n\t\t\t\t\t     lxg0, lxg1, lxg2a, lxg3, lxg4, lxg5);\n\t\t\t} else {\n\t\t\t\tn += snprintf(msg + n, len - n, \"]\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlog2 = I10NM_GET_REG32(imc, res->channel, offsets[2]);\n\t\tn = snprintf(msg, len, \" retry_rd_err_log[%.8x %.8x %.8x %.8x %.8x %.16llx]\",\n\t\t\t     log0, log1, log2, log3, log4, log5);\n\t}\n\n\tif (imc->hbm_mc) {\n\t\tif (pch) {\n\t\t\tcorr0 = I10NM_GET_REG32(imc, res->channel, 0x2c18);\n\t\t\tcorr1 = I10NM_GET_REG32(imc, res->channel, 0x2c1c);\n\t\t\tcorr2 = I10NM_GET_REG32(imc, res->channel, 0x2c20);\n\t\t\tcorr3 = I10NM_GET_REG32(imc, res->channel, 0x2c24);\n\t\t} else {\n\t\t\tcorr0 = I10NM_GET_REG32(imc, res->channel, 0x2818);\n\t\t\tcorr1 = I10NM_GET_REG32(imc, res->channel, 0x281c);\n\t\t\tcorr2 = I10NM_GET_REG32(imc, res->channel, 0x2820);\n\t\t\tcorr3 = I10NM_GET_REG32(imc, res->channel, 0x2824);\n\t\t}\n\t} else {\n\t\tcorr0 = I10NM_GET_REG32(imc, res->channel, 0x22c18);\n\t\tcorr1 = I10NM_GET_REG32(imc, res->channel, 0x22c1c);\n\t\tcorr2 = I10NM_GET_REG32(imc, res->channel, 0x22c20);\n\t\tcorr3 = I10NM_GET_REG32(imc, res->channel, 0x22c24);\n\t}\n\n\tif (len - n > 0)\n\t\tsnprintf(msg + n, len - n,\n\t\t\t \" correrrcnt[%.4x %.4x %.4x %.4x %.4x %.4x %.4x %.4x]\",\n\t\t\t corr0 & 0xffff, corr0 >> 16,\n\t\t\t corr1 & 0xffff, corr1 >> 16,\n\t\t\t corr2 & 0xffff, corr2 >> 16,\n\t\t\t corr3 & 0xffff, corr3 >> 16);\n\n\t \n\tif (retry_rd_err_log == 2) {\n\t\tif (log0 & RETRY_RD_ERR_LOG_OVER_UC_V) {\n\t\t\tlog0 &= ~RETRY_RD_ERR_LOG_OVER_UC_V;\n\t\t\tI10NM_SET_REG32(imc, res->channel, offsets[0], log0);\n\t\t}\n\n\t\tif (xffsets && (lxg0 & RETRY_RD_ERR_LOG_OVER_UC_V)) {\n\t\t\tlxg0 &= ~RETRY_RD_ERR_LOG_OVER_UC_V;\n\t\t\tI10NM_SET_REG32(imc, res->channel, xffsets[0], lxg0);\n\t\t}\n\t}\n}\n\nstatic struct pci_dev *pci_get_dev_wrapper(int dom, unsigned int bus,\n\t\t\t\t\t   unsigned int dev, unsigned int fun)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = pci_get_domain_bus_and_slot(dom, bus, PCI_DEVFN(dev, fun));\n\tif (!pdev) {\n\t\tedac_dbg(2, \"No device %02x:%02x.%x\\n\",\n\t\t\t bus, dev, fun);\n\t\treturn NULL;\n\t}\n\n\tif (unlikely(pci_enable_device(pdev) < 0)) {\n\t\tedac_dbg(2, \"Failed to enable device %02x:%02x.%x\\n\",\n\t\t\t bus, dev, fun);\n\t\tpci_dev_put(pdev);\n\t\treturn NULL;\n\t}\n\n\treturn pdev;\n}\n\n \nstatic int i10nm_get_imc_num(struct res_config *cfg)\n{\n\tint n, imc_num, chan_num = 0;\n\tstruct skx_dev *d;\n\tu32 reg;\n\n\tlist_for_each_entry(d, i10nm_edac_list, list) {\n\t\td->pcu_cr3 = pci_get_dev_wrapper(d->seg, d->bus[res_cfg->pcu_cr3_bdf.bus],\n\t\t\t\t\t\t res_cfg->pcu_cr3_bdf.dev,\n\t\t\t\t\t\t res_cfg->pcu_cr3_bdf.fun);\n\t\tif (!d->pcu_cr3)\n\t\t\tcontinue;\n\n\t\tif (I10NM_GET_CAPID5_CFG(d, reg))\n\t\t\tcontinue;\n\n\t\tn = I10NM_DDR_IMC_CH_CNT(reg);\n\n\t\tif (!chan_num) {\n\t\t\tchan_num = n;\n\t\t\tedac_dbg(2, \"Get DDR CH number: %d\\n\", chan_num);\n\t\t} else if (chan_num != n) {\n\t\t\ti10nm_printk(KERN_NOTICE, \"Get DDR CH numbers: %d, %d\\n\", chan_num, n);\n\t\t}\n\t}\n\n\tswitch (cfg->type) {\n\tcase GNR:\n\t\t \n\t\timc_num = chan_num;\n\n\t\tif (!imc_num) {\n\t\t\ti10nm_printk(KERN_ERR, \"Invalid DDR MC number\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (imc_num > I10NM_NUM_DDR_IMC) {\n\t\t\ti10nm_printk(KERN_ERR, \"Need to make I10NM_NUM_DDR_IMC >= %d\\n\", imc_num);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cfg->ddr_imc_num != imc_num) {\n\t\t\t \n\t\t\tcfg->ddr_imc_num = imc_num;\n\t\t\tedac_dbg(2, \"Set DDR MC number: %d\", imc_num);\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n}\n\nstatic bool i10nm_check_2lm(struct res_config *cfg)\n{\n\tstruct skx_dev *d;\n\tu32 reg;\n\tint i;\n\n\tlist_for_each_entry(d, i10nm_edac_list, list) {\n\t\td->sad_all = pci_get_dev_wrapper(d->seg, d->bus[res_cfg->sad_all_bdf.bus],\n\t\t\t\t\t\t res_cfg->sad_all_bdf.dev,\n\t\t\t\t\t\t res_cfg->sad_all_bdf.fun);\n\t\tif (!d->sad_all)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < I10NM_MAX_SAD; i++) {\n\t\t\tI10NM_GET_SAD(d, cfg->sad_all_offset, i, reg);\n\t\t\tif (I10NM_SAD_ENABLE(reg) && I10NM_SAD_NM_CACHEABLE(reg)) {\n\t\t\t\tedac_dbg(2, \"2-level memory configuration.\\n\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic bool i10nm_mscod_is_ddrt(u32 mscod)\n{\n\tswitch (res_cfg->type) {\n\tcase I10NM:\n\t\tswitch (mscod) {\n\t\tcase 0x0106: case 0x0107:\n\t\tcase 0x0800: case 0x0804:\n\t\tcase 0x0806 ... 0x0808:\n\t\tcase 0x080a ... 0x080e:\n\t\tcase 0x0810: case 0x0811:\n\t\tcase 0x0816: case 0x081e:\n\t\tcase 0x081f:\n\t\t\treturn true;\n\t\t}\n\n\t\tbreak;\n\tcase SPR:\n\t\tswitch (mscod) {\n\t\tcase 0x0800: case 0x0804:\n\t\tcase 0x0806 ... 0x0808:\n\t\tcase 0x080a ... 0x080e:\n\t\tcase 0x0810: case 0x0811:\n\t\tcase 0x0816: case 0x081e:\n\t\tcase 0x081f:\n\t\t\treturn true;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic bool i10nm_mc_decode_available(struct mce *mce)\n{\n#define ICX_IMCx_CHy\t\t0x06666000\n\tu8 bank;\n\n\tif (!decoding_via_mca || mem_cfg_2lm)\n\t\treturn false;\n\n\tif ((mce->status & (MCI_STATUS_MISCV | MCI_STATUS_ADDRV))\n\t\t\t!= (MCI_STATUS_MISCV | MCI_STATUS_ADDRV))\n\t\treturn false;\n\n\tbank = mce->bank;\n\n\tswitch (res_cfg->type) {\n\tcase I10NM:\n\t\t \n\t\tif (!(ICX_IMCx_CHy & (1 << bank)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase SPR:\n\t\tif (bank < 13 || bank > 20)\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\t \n\tif (MCI_MISC_ECC_MODE(mce->misc) == MCI_MISC_ECC_DDRT)\n\t\treturn false;\n\n\tif (i10nm_mscod_is_ddrt(MCI_STATUS_MSCOD(mce->status)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool i10nm_mc_decode(struct decoded_addr *res)\n{\n\tstruct mce *m = res->mce;\n\tstruct skx_dev *d;\n\tu8 bank;\n\n\tif (!i10nm_mc_decode_available(m))\n\t\treturn false;\n\n\tlist_for_each_entry(d, i10nm_edac_list, list) {\n\t\tif (d->imc[0].src_id == m->socketid) {\n\t\t\tres->socket = m->socketid;\n\t\t\tres->dev = d;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (res_cfg->type) {\n\tcase I10NM:\n\t\tbank              = m->bank - 13;\n\t\tres->imc          = bank / 4;\n\t\tres->channel      = bank % 2;\n\t\tres->column       = GET_BITFIELD(m->misc, 9, 18) << 2;\n\t\tres->row          = GET_BITFIELD(m->misc, 19, 39);\n\t\tres->bank_group   = GET_BITFIELD(m->misc, 40, 41);\n\t\tres->bank_address = GET_BITFIELD(m->misc, 42, 43);\n\t\tres->bank_group  |= GET_BITFIELD(m->misc, 44, 44) << 2;\n\t\tres->rank         = GET_BITFIELD(m->misc, 56, 58);\n\t\tres->dimm         = res->rank >> 2;\n\t\tres->rank         = res->rank % 4;\n\t\tbreak;\n\tcase SPR:\n\t\tbank              = m->bank - 13;\n\t\tres->imc          = bank / 2;\n\t\tres->channel      = bank % 2;\n\t\tres->column       = GET_BITFIELD(m->misc, 9, 18) << 2;\n\t\tres->row          = GET_BITFIELD(m->misc, 19, 36);\n\t\tres->bank_group   = GET_BITFIELD(m->misc, 37, 38);\n\t\tres->bank_address = GET_BITFIELD(m->misc, 39, 40);\n\t\tres->bank_group  |= GET_BITFIELD(m->misc, 41, 41) << 2;\n\t\tres->rank         = GET_BITFIELD(m->misc, 57, 57);\n\t\tres->dimm         = GET_BITFIELD(m->misc, 58, 58);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (!res->dev) {\n\t\tskx_printk(KERN_ERR, \"No device for src_id %d imc %d\\n\",\n\t\t\t   m->socketid, res->imc);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic struct pci_dev *get_gnr_mdev(struct skx_dev *d, int logical_idx, int *physical_idx)\n{\n#define GNR_MAX_IMC_PCI_CNT\t28\n\n\tstruct pci_dev *mdev;\n\tint i, logical = 0;\n\n\t \n\tfor (i = 0; i < GNR_MAX_IMC_PCI_CNT; i++) {\n\t\tmdev = pci_get_dev_wrapper(d->seg,\n\t\t\t\t\t   d->bus[res_cfg->ddr_mdev_bdf.bus],\n\t\t\t\t\t   res_cfg->ddr_mdev_bdf.dev + i / 7,\n\t\t\t\t\t   res_cfg->ddr_mdev_bdf.fun + i % 7);\n\n\t\tif (mdev) {\n\t\t\tif (logical == logical_idx) {\n\t\t\t\t*physical_idx = i;\n\t\t\t\treturn mdev;\n\t\t\t}\n\n\t\t\tpci_dev_put(mdev);\n\t\t\tlogical++;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct pci_dev *get_ddr_munit(struct skx_dev *d, int i, u32 *offset, unsigned long *size)\n{\n\tstruct pci_dev *mdev;\n\tint physical_idx;\n\tu32 reg;\n\n\tswitch (res_cfg->type) {\n\tcase GNR:\n\t\tif (I10NM_GET_IMC_BAR(d, 0, reg)) {\n\t\t\ti10nm_printk(KERN_ERR, \"Failed to get mc0 bar\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmdev = get_gnr_mdev(d, i, &physical_idx);\n\t\tif (!mdev)\n\t\t\treturn NULL;\n\n\t\t*offset = I10NM_GET_IMC_MMIO_OFFSET(reg) +\n\t\t\t  I10NM_GNR_IMC_MMIO_OFFSET +\n\t\t\t  physical_idx * I10NM_GNR_IMC_MMIO_SIZE;\n\t\t*size   = I10NM_GNR_IMC_MMIO_SIZE;\n\n\t\tbreak;\n\tdefault:\n\t\tif (I10NM_GET_IMC_BAR(d, i, reg)) {\n\t\t\ti10nm_printk(KERN_ERR, \"Failed to get mc%d bar\\n\", i);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmdev = pci_get_dev_wrapper(d->seg,\n\t\t\t\t\t   d->bus[res_cfg->ddr_mdev_bdf.bus],\n\t\t\t\t\t   res_cfg->ddr_mdev_bdf.dev + i,\n\t\t\t\t\t   res_cfg->ddr_mdev_bdf.fun);\n\t\tif (!mdev)\n\t\t\treturn NULL;\n\n\t\t*offset  = I10NM_GET_IMC_MMIO_OFFSET(reg);\n\t\t*size    = I10NM_GET_IMC_MMIO_SIZE(reg);\n\t}\n\n\treturn mdev;\n}\n\n \nstatic bool i10nm_imc_absent(struct skx_imc *imc)\n{\n\tu32 mcmtr;\n\tint i;\n\n\tswitch (res_cfg->type) {\n\tcase SPR:\n\t\tfor (i = 0; i < res_cfg->ddr_chan_num; i++) {\n\t\t\tmcmtr = I10NM_GET_MCMTR(imc, i);\n\t\t\tedac_dbg(1, \"ch%d mcmtr reg %x\\n\", i, mcmtr);\n\t\t\tif (mcmtr != ~0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int i10nm_get_ddr_munits(void)\n{\n\tstruct pci_dev *mdev;\n\tvoid __iomem *mbase;\n\tunsigned long size;\n\tstruct skx_dev *d;\n\tint i, lmc, j = 0;\n\tu32 reg, off;\n\tu64 base;\n\n\tlist_for_each_entry(d, i10nm_edac_list, list) {\n\t\td->util_all = pci_get_dev_wrapper(d->seg, d->bus[res_cfg->util_all_bdf.bus],\n\t\t\t\t\t\t  res_cfg->util_all_bdf.dev,\n\t\t\t\t\t\t  res_cfg->util_all_bdf.fun);\n\t\tif (!d->util_all)\n\t\t\treturn -ENODEV;\n\n\t\td->uracu = pci_get_dev_wrapper(d->seg, d->bus[res_cfg->uracu_bdf.bus],\n\t\t\t\t\t       res_cfg->uracu_bdf.dev,\n\t\t\t\t\t       res_cfg->uracu_bdf.fun);\n\t\tif (!d->uracu)\n\t\t\treturn -ENODEV;\n\n\t\tif (I10NM_GET_SCK_BAR(d, reg)) {\n\t\t\ti10nm_printk(KERN_ERR, \"Failed to socket bar\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tbase = I10NM_GET_SCK_MMIO_BASE(reg);\n\t\tedac_dbg(2, \"socket%d mmio base 0x%llx (reg 0x%x)\\n\",\n\t\t\t j++, base, reg);\n\n\t\tfor (lmc = 0, i = 0; i < res_cfg->ddr_imc_num; i++) {\n\t\t\tmdev = get_ddr_munit(d, i, &off, &size);\n\n\t\t\tif (i == 0 && !mdev) {\n\t\t\t\ti10nm_printk(KERN_ERR, \"No IMC found\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tif (!mdev)\n\t\t\t\tcontinue;\n\n\t\t\tedac_dbg(2, \"mc%d mmio base 0x%llx size 0x%lx (reg 0x%x)\\n\",\n\t\t\t\t i, base + off, size, reg);\n\n\t\t\tmbase = ioremap(base + off, size);\n\t\t\tif (!mbase) {\n\t\t\t\ti10nm_printk(KERN_ERR, \"Failed to ioremap 0x%llx\\n\",\n\t\t\t\t\t     base + off);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\td->imc[lmc].mbase = mbase;\n\t\t\tif (i10nm_imc_absent(&d->imc[lmc])) {\n\t\t\t\tpci_dev_put(mdev);\n\t\t\t\tiounmap(mbase);\n\t\t\t\td->imc[lmc].mbase = NULL;\n\t\t\t\tedac_dbg(2, \"Skip absent mc%d\\n\", i);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\td->imc[lmc].mdev = mdev;\n\t\t\t\tlmc++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool i10nm_check_hbm_imc(struct skx_dev *d)\n{\n\tu32 reg;\n\n\tif (I10NM_GET_CAPID3_CFG(d, reg)) {\n\t\ti10nm_printk(KERN_ERR, \"Failed to get capid3_cfg\\n\");\n\t\treturn false;\n\t}\n\n\treturn I10NM_IS_HBM_PRESENT(reg) != 0;\n}\n\nstatic int i10nm_get_hbm_munits(void)\n{\n\tstruct pci_dev *mdev;\n\tvoid __iomem *mbase;\n\tu32 reg, off, mcmtr;\n\tstruct skx_dev *d;\n\tint i, lmc;\n\tu64 base;\n\n\tlist_for_each_entry(d, i10nm_edac_list, list) {\n\t\tif (!d->pcu_cr3)\n\t\t\treturn -ENODEV;\n\n\t\tif (!i10nm_check_hbm_imc(d)) {\n\t\t\ti10nm_printk(KERN_DEBUG, \"No hbm memory\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (I10NM_GET_SCK_BAR(d, reg)) {\n\t\t\ti10nm_printk(KERN_ERR, \"Failed to get socket bar\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbase = I10NM_GET_SCK_MMIO_BASE(reg);\n\n\t\tif (I10NM_GET_HBM_IMC_BAR(d, reg)) {\n\t\t\ti10nm_printk(KERN_ERR, \"Failed to get hbm mc bar\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbase += I10NM_GET_HBM_IMC_MMIO_OFFSET(reg);\n\n\t\tlmc = res_cfg->ddr_imc_num;\n\n\t\tfor (i = 0; i < res_cfg->hbm_imc_num; i++) {\n\t\t\tmdev = pci_get_dev_wrapper(d->seg, d->bus[res_cfg->hbm_mdev_bdf.bus],\n\t\t\t\t\t\t   res_cfg->hbm_mdev_bdf.dev + i / 4,\n\t\t\t\t\t\t   res_cfg->hbm_mdev_bdf.fun + i % 4);\n\n\t\t\tif (i == 0 && !mdev) {\n\t\t\t\ti10nm_printk(KERN_ERR, \"No hbm mc found\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tif (!mdev)\n\t\t\t\tcontinue;\n\n\t\t\td->imc[lmc].mdev = mdev;\n\t\t\toff = i * I10NM_HBM_IMC_MMIO_SIZE;\n\n\t\t\tedac_dbg(2, \"hbm mc%d mmio base 0x%llx size 0x%x\\n\",\n\t\t\t\t lmc, base + off, I10NM_HBM_IMC_MMIO_SIZE);\n\n\t\t\tmbase = ioremap(base + off, I10NM_HBM_IMC_MMIO_SIZE);\n\t\t\tif (!mbase) {\n\t\t\t\tpci_dev_put(d->imc[lmc].mdev);\n\t\t\t\td->imc[lmc].mdev = NULL;\n\n\t\t\t\ti10nm_printk(KERN_ERR, \"Failed to ioremap for hbm mc 0x%llx\\n\",\n\t\t\t\t\t     base + off);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\td->imc[lmc].mbase = mbase;\n\t\t\td->imc[lmc].hbm_mc = true;\n\n\t\t\tmcmtr = I10NM_GET_MCMTR(&d->imc[lmc], 0);\n\t\t\tif (!I10NM_IS_HBM_IMC(mcmtr)) {\n\t\t\t\tiounmap(d->imc[lmc].mbase);\n\t\t\t\td->imc[lmc].mbase = NULL;\n\t\t\t\td->imc[lmc].hbm_mc = false;\n\t\t\t\tpci_dev_put(d->imc[lmc].mdev);\n\t\t\t\td->imc[lmc].mdev = NULL;\n\n\t\t\t\ti10nm_printk(KERN_ERR, \"This isn't an hbm mc!\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tlmc++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct res_config i10nm_cfg0 = {\n\t.type\t\t\t= I10NM,\n\t.decs_did\t\t= 0x3452,\n\t.busno_cfg_offset\t= 0xcc,\n\t.ddr_imc_num\t\t= 4,\n\t.ddr_chan_num\t\t= 2,\n\t.ddr_dimm_num\t\t= 2,\n\t.ddr_chan_mmio_sz\t= 0x4000,\n\t.sad_all_bdf\t\t= {1, 29, 0},\n\t.pcu_cr3_bdf\t\t= {1, 30, 3},\n\t.util_all_bdf\t\t= {1, 29, 1},\n\t.uracu_bdf\t\t= {0, 0, 1},\n\t.ddr_mdev_bdf\t\t= {0, 12, 0},\n\t.hbm_mdev_bdf\t\t= {0, 12, 1},\n\t.sad_all_offset\t\t= 0x108,\n\t.offsets_scrub\t\t= offsets_scrub_icx,\n\t.offsets_demand\t\t= offsets_demand_icx,\n};\n\nstatic struct res_config i10nm_cfg1 = {\n\t.type\t\t\t= I10NM,\n\t.decs_did\t\t= 0x3452,\n\t.busno_cfg_offset\t= 0xd0,\n\t.ddr_imc_num\t\t= 4,\n\t.ddr_chan_num\t\t= 2,\n\t.ddr_dimm_num\t\t= 2,\n\t.ddr_chan_mmio_sz\t= 0x4000,\n\t.sad_all_bdf\t\t= {1, 29, 0},\n\t.pcu_cr3_bdf\t\t= {1, 30, 3},\n\t.util_all_bdf\t\t= {1, 29, 1},\n\t.uracu_bdf\t\t= {0, 0, 1},\n\t.ddr_mdev_bdf\t\t= {0, 12, 0},\n\t.hbm_mdev_bdf\t\t= {0, 12, 1},\n\t.sad_all_offset\t\t= 0x108,\n\t.offsets_scrub\t\t= offsets_scrub_icx,\n\t.offsets_demand\t\t= offsets_demand_icx,\n};\n\nstatic struct res_config spr_cfg = {\n\t.type\t\t\t= SPR,\n\t.decs_did\t\t= 0x3252,\n\t.busno_cfg_offset\t= 0xd0,\n\t.ddr_imc_num\t\t= 4,\n\t.ddr_chan_num\t\t= 2,\n\t.ddr_dimm_num\t\t= 2,\n\t.hbm_imc_num\t\t= 16,\n\t.hbm_chan_num\t\t= 2,\n\t.hbm_dimm_num\t\t= 1,\n\t.ddr_chan_mmio_sz\t= 0x8000,\n\t.hbm_chan_mmio_sz\t= 0x4000,\n\t.support_ddr5\t\t= true,\n\t.sad_all_bdf\t\t= {1, 10, 0},\n\t.pcu_cr3_bdf\t\t= {1, 30, 3},\n\t.util_all_bdf\t\t= {1, 29, 1},\n\t.uracu_bdf\t\t= {0, 0, 1},\n\t.ddr_mdev_bdf\t\t= {0, 12, 0},\n\t.hbm_mdev_bdf\t\t= {0, 12, 1},\n\t.sad_all_offset\t\t= 0x300,\n\t.offsets_scrub\t\t= offsets_scrub_spr,\n\t.offsets_scrub_hbm0\t= offsets_scrub_spr_hbm0,\n\t.offsets_scrub_hbm1\t= offsets_scrub_spr_hbm1,\n\t.offsets_demand\t\t= offsets_demand_spr,\n\t.offsets_demand2\t= offsets_demand2_spr,\n\t.offsets_demand_hbm0\t= offsets_demand_spr_hbm0,\n\t.offsets_demand_hbm1\t= offsets_demand_spr_hbm1,\n};\n\nstatic struct res_config gnr_cfg = {\n\t.type\t\t\t= GNR,\n\t.decs_did\t\t= 0x3252,\n\t.busno_cfg_offset\t= 0xd0,\n\t.ddr_imc_num\t\t= 12,\n\t.ddr_chan_num\t\t= 1,\n\t.ddr_dimm_num\t\t= 2,\n\t.ddr_chan_mmio_sz\t= 0x4000,\n\t.support_ddr5\t\t= true,\n\t.sad_all_bdf\t\t= {0, 13, 0},\n\t.pcu_cr3_bdf\t\t= {0, 5, 0},\n\t.util_all_bdf\t\t= {0, 13, 1},\n\t.uracu_bdf\t\t= {0, 0, 1},\n\t.ddr_mdev_bdf\t\t= {0, 5, 1},\n\t.sad_all_offset\t\t= 0x300,\n};\n\nstatic const struct x86_cpu_id i10nm_cpuids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ATOM_TREMONT_D,\tX86_STEPPINGS(0x0, 0x3), &i10nm_cfg0),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ATOM_TREMONT_D,\tX86_STEPPINGS(0x4, 0xf), &i10nm_cfg1),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ICELAKE_X,\t\tX86_STEPPINGS(0x0, 0x3), &i10nm_cfg0),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ICELAKE_X,\t\tX86_STEPPINGS(0x4, 0xf), &i10nm_cfg1),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ICELAKE_D,\t\tX86_STEPPINGS(0x0, 0xf), &i10nm_cfg1),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(SAPPHIRERAPIDS_X,\tX86_STEPPINGS(0x0, 0xf), &spr_cfg),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(EMERALDRAPIDS_X,\tX86_STEPPINGS(0x0, 0xf), &spr_cfg),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(GRANITERAPIDS_X,\tX86_STEPPINGS(0x0, 0xf), &gnr_cfg),\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(ATOM_CRESTMONT_X,\tX86_STEPPINGS(0x0, 0xf), &gnr_cfg),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, i10nm_cpuids);\n\nstatic bool i10nm_check_ecc(struct skx_imc *imc, int chan)\n{\n\tu32 mcmtr;\n\n\tmcmtr = I10NM_GET_MCMTR(imc, chan);\n\tedac_dbg(1, \"ch%d mcmtr reg %x\\n\", chan, mcmtr);\n\n\treturn !!GET_BITFIELD(mcmtr, 2, 2);\n}\n\nstatic int i10nm_get_dimm_config(struct mem_ctl_info *mci,\n\t\t\t\t struct res_config *cfg)\n{\n\tstruct skx_pvt *pvt = mci->pvt_info;\n\tstruct skx_imc *imc = pvt->imc;\n\tu32 mtr, amap, mcddrtcfg = 0;\n\tstruct dimm_info *dimm;\n\tint i, j, ndimms;\n\n\tfor (i = 0; i < imc->num_channels; i++) {\n\t\tif (!imc->mbase)\n\t\t\tcontinue;\n\n\t\tndimms = 0;\n\t\tamap = I10NM_GET_AMAP(imc, i);\n\n\t\tif (res_cfg->type != GNR)\n\t\t\tmcddrtcfg = I10NM_GET_MCDDRTCFG(imc, i);\n\n\t\tfor (j = 0; j < imc->num_dimms; j++) {\n\t\t\tdimm = edac_get_dimm(mci, i, j, 0);\n\t\t\tmtr = I10NM_GET_DIMMMTR(imc, i, j);\n\t\t\tedac_dbg(1, \"dimmmtr 0x%x mcddrtcfg 0x%x (mc%d ch%d dimm%d)\\n\",\n\t\t\t\t mtr, mcddrtcfg, imc->mc, i, j);\n\n\t\t\tif (IS_DIMM_PRESENT(mtr))\n\t\t\t\tndimms += skx_get_dimm_info(mtr, 0, amap, dimm,\n\t\t\t\t\t\t\t    imc, i, j, cfg);\n\t\t\telse if (IS_NVDIMM_PRESENT(mcddrtcfg, j))\n\t\t\t\tndimms += skx_get_nvdimm_info(dimm, imc, i, j,\n\t\t\t\t\t\t\t      EDAC_MOD_STR);\n\t\t}\n\t\tif (ndimms && !i10nm_check_ecc(imc, i)) {\n\t\t\ti10nm_printk(KERN_ERR, \"ECC is disabled on imc %d channel %d\\n\",\n\t\t\t\t     imc->mc, i);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block i10nm_mce_dec = {\n\t.notifier_call\t= skx_mce_check_error,\n\t.priority\t= MCE_PRIO_EDAC,\n};\n\n#ifdef CONFIG_EDAC_DEBUG\n \nstatic struct dentry *i10nm_test;\n\nstatic int debugfs_u64_set(void *data, u64 val)\n{\n\tstruct mce m;\n\n\tpr_warn_once(\"Fake error to 0x%llx injected via debugfs\\n\", val);\n\n\tmemset(&m, 0, sizeof(m));\n\t \n\tm.status = MCI_STATUS_ADDRV + 0x90;\n\t \n\tm.status |= BIT_ULL(MCI_STATUS_CEC_SHIFT);\n\tm.addr = val;\n\tskx_mce_check_error(NULL, 0, &m);\n\n\treturn 0;\n}\nDEFINE_SIMPLE_ATTRIBUTE(fops_u64_wo, NULL, debugfs_u64_set, \"%llu\\n\");\n\nstatic void setup_i10nm_debug(void)\n{\n\ti10nm_test = edac_debugfs_create_dir(\"i10nm_test\");\n\tif (!i10nm_test)\n\t\treturn;\n\n\tif (!edac_debugfs_create_file(\"addr\", 0200, i10nm_test,\n\t\t\t\t      NULL, &fops_u64_wo)) {\n\t\tdebugfs_remove(i10nm_test);\n\t\ti10nm_test = NULL;\n\t}\n}\n\nstatic void teardown_i10nm_debug(void)\n{\n\tdebugfs_remove_recursive(i10nm_test);\n}\n#else\nstatic inline void setup_i10nm_debug(void) {}\nstatic inline void teardown_i10nm_debug(void) {}\n#endif  \n\nstatic int __init i10nm_init(void)\n{\n\tu8 mc = 0, src_id = 0, node_id = 0;\n\tconst struct x86_cpu_id *id;\n\tstruct res_config *cfg;\n\tconst char *owner;\n\tstruct skx_dev *d;\n\tint rc, i, off[3] = {0xd0, 0xc8, 0xcc};\n\tu64 tolm, tohm;\n\tint imc_num;\n\n\tedac_dbg(2, \"\\n\");\n\n\tif (ghes_get_devices())\n\t\treturn -EBUSY;\n\n\towner = edac_get_owner();\n\tif (owner && strncmp(owner, EDAC_MOD_STR, sizeof(EDAC_MOD_STR)))\n\t\treturn -EBUSY;\n\n\tif (cpu_feature_enabled(X86_FEATURE_HYPERVISOR))\n\t\treturn -ENODEV;\n\n\tid = x86_match_cpu(i10nm_cpuids);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tcfg = (struct res_config *)id->driver_data;\n\tres_cfg = cfg;\n\n\trc = skx_get_hi_lo(0x09a2, off, &tolm, &tohm);\n\tif (rc)\n\t\treturn rc;\n\n\trc = skx_get_all_bus_mappings(cfg, &i10nm_edac_list);\n\tif (rc < 0)\n\t\tgoto fail;\n\tif (rc == 0) {\n\t\ti10nm_printk(KERN_ERR, \"No memory controllers found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = i10nm_get_imc_num(cfg);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\tmem_cfg_2lm = i10nm_check_2lm(cfg);\n\tskx_set_mem_cfg(mem_cfg_2lm);\n\n\trc = i10nm_get_ddr_munits();\n\n\tif (i10nm_get_hbm_munits() && rc)\n\t\tgoto fail;\n\n\timc_num = res_cfg->ddr_imc_num + res_cfg->hbm_imc_num;\n\n\tlist_for_each_entry(d, i10nm_edac_list, list) {\n\t\trc = skx_get_src_id(d, 0xf8, &src_id);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\n\t\trc = skx_get_node_id(d, &node_id);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\n\t\tedac_dbg(2, \"src_id = %d node_id = %d\\n\", src_id, node_id);\n\t\tfor (i = 0; i < imc_num; i++) {\n\t\t\tif (!d->imc[i].mdev)\n\t\t\t\tcontinue;\n\n\t\t\td->imc[i].mc  = mc++;\n\t\t\td->imc[i].lmc = i;\n\t\t\td->imc[i].src_id  = src_id;\n\t\t\td->imc[i].node_id = node_id;\n\t\t\tif (d->imc[i].hbm_mc) {\n\t\t\t\td->imc[i].chan_mmio_sz = cfg->hbm_chan_mmio_sz;\n\t\t\t\td->imc[i].num_channels = cfg->hbm_chan_num;\n\t\t\t\td->imc[i].num_dimms    = cfg->hbm_dimm_num;\n\t\t\t} else {\n\t\t\t\td->imc[i].chan_mmio_sz = cfg->ddr_chan_mmio_sz;\n\t\t\t\td->imc[i].num_channels = cfg->ddr_chan_num;\n\t\t\t\td->imc[i].num_dimms    = cfg->ddr_dimm_num;\n\t\t\t}\n\n\t\t\trc = skx_register_mci(&d->imc[i], d->imc[i].mdev,\n\t\t\t\t\t      \"Intel_10nm Socket\", EDAC_MOD_STR,\n\t\t\t\t\t      i10nm_get_dimm_config, cfg);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\trc = skx_adxl_get();\n\tif (rc)\n\t\tgoto fail;\n\n\topstate_init();\n\tmce_register_decode_chain(&i10nm_mce_dec);\n\tsetup_i10nm_debug();\n\n\tif (retry_rd_err_log && res_cfg->offsets_scrub && res_cfg->offsets_demand) {\n\t\tskx_set_decode(i10nm_mc_decode, show_retry_rd_err_log);\n\t\tif (retry_rd_err_log == 2)\n\t\t\tenable_retry_rd_err_log(true);\n\t} else {\n\t\tskx_set_decode(i10nm_mc_decode, NULL);\n\t}\n\n\ti10nm_printk(KERN_INFO, \"%s\\n\", I10NM_REVISION);\n\n\treturn 0;\nfail:\n\tskx_remove();\n\treturn rc;\n}\n\nstatic void __exit i10nm_exit(void)\n{\n\tedac_dbg(2, \"\\n\");\n\n\tif (retry_rd_err_log && res_cfg->offsets_scrub && res_cfg->offsets_demand) {\n\t\tskx_set_decode(NULL, NULL);\n\t\tif (retry_rd_err_log == 2)\n\t\t\tenable_retry_rd_err_log(false);\n\t}\n\n\tteardown_i10nm_debug();\n\tmce_unregister_decode_chain(&i10nm_mce_dec);\n\tskx_adxl_put();\n\tskx_remove();\n}\n\nmodule_init(i10nm_init);\nmodule_exit(i10nm_exit);\n\nstatic int set_decoding_via_mca(const char *buf, const struct kernel_param *kp)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\n\tif (ret || val > 1)\n\t\treturn -EINVAL;\n\n\tif (val && mem_cfg_2lm) {\n\t\ti10nm_printk(KERN_NOTICE, \"Decoding errors via MCA banks for 2LM isn't supported yet\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = param_set_int(buf, kp);\n\n\treturn ret;\n}\n\nstatic const struct kernel_param_ops decoding_via_mca_param_ops = {\n\t.set = set_decoding_via_mca,\n\t.get = param_get_int,\n};\n\nmodule_param_cb(decoding_via_mca, &decoding_via_mca_param_ops, &decoding_via_mca, 0644);\nMODULE_PARM_DESC(decoding_via_mca, \"decoding_via_mca: 0=off(default), 1=enable\");\n\nmodule_param(retry_rd_err_log, int, 0444);\nMODULE_PARM_DESC(retry_rd_err_log, \"retry_rd_err_log: 0=off(default), 1=bios(Linux doesn't reset any control bits, but just reports values.), 2=linux(Linux tries to take control and resets mode bits, clear valid/UC bits after reading.)\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MC Driver for Intel 10nm server processors\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}