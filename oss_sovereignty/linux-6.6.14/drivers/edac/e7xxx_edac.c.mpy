{
  "module_name": "e7xxx_edac.c",
  "hash_id": "495d9a2f6b575a6a2857d36c402e63dc45aa3dccce364c435846ba1490b4eb01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/e7xxx_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define\tEDAC_MOD_STR\t\"e7xxx_edac\"\n\n#define e7xxx_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"e7xxx\", fmt, ##arg)\n\n#define e7xxx_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"e7xxx\", fmt, ##arg)\n\n#ifndef PCI_DEVICE_ID_INTEL_7205_0\n#define PCI_DEVICE_ID_INTEL_7205_0\t0x255d\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7205_1_ERR\n#define PCI_DEVICE_ID_INTEL_7205_1_ERR\t0x2551\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7500_0\n#define PCI_DEVICE_ID_INTEL_7500_0\t0x2540\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7500_1_ERR\n#define PCI_DEVICE_ID_INTEL_7500_1_ERR\t0x2541\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7501_0\n#define PCI_DEVICE_ID_INTEL_7501_0\t0x254c\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7501_1_ERR\n#define PCI_DEVICE_ID_INTEL_7501_1_ERR\t0x2541\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7505_0\n#define PCI_DEVICE_ID_INTEL_7505_0\t0x2550\n#endif\t\t\t\t \n\n#ifndef PCI_DEVICE_ID_INTEL_7505_1_ERR\n#define PCI_DEVICE_ID_INTEL_7505_1_ERR\t0x2551\n#endif\t\t\t\t \n\n#define E7XXX_NR_CSROWS\t\t8\t \n#define E7XXX_NR_DIMMS\t\t8\t \n\n \n#define E7XXX_DRB\t\t0x60\t \n#define E7XXX_DRA\t\t0x70\t \n\t\t\t\t\t \n#define E7XXX_DRC\t\t0x7C\t \n\t\t\t\t\t \n#define E7XXX_TOLM\t\t0xC4\t \n#define E7XXX_REMAPBASE\t\t0xC6\t \n#define E7XXX_REMAPLIMIT\t0xC8\t \n\n \n#define E7XXX_DRAM_FERR\t\t0x80\t \n#define E7XXX_DRAM_NERR\t\t0x82\t \n#define E7XXX_DRAM_CELOG_ADD\t0xA0\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define E7XXX_DRAM_UELOG_ADD\t0xB0\t \n\t\t\t\t\t \n\t\t\t\t\t \n#define E7XXX_DRAM_CELOG_SYNDROME 0xD0\t \n\t\t\t\t\t \n\nenum e7xxx_chips {\n\tE7500 = 0,\n\tE7501,\n\tE7505,\n\tE7205,\n};\n\nstruct e7xxx_pvt {\n\tstruct pci_dev *bridge_ck;\n\tu32 tolm;\n\tu32 remapbase;\n\tu32 remaplimit;\n\tconst struct e7xxx_dev_info *dev_info;\n};\n\nstruct e7xxx_dev_info {\n\tu16 err_dev;\n\tconst char *ctl_name;\n};\n\nstruct e7xxx_error_info {\n\tu8 dram_ferr;\n\tu8 dram_nerr;\n\tu32 dram_celog_add;\n\tu16 dram_celog_syndrome;\n\tu32 dram_uelog_add;\n};\n\nstatic struct edac_pci_ctl_info *e7xxx_pci;\n\nstatic const struct e7xxx_dev_info e7xxx_devs[] = {\n\t[E7500] = {\n\t\t.err_dev = PCI_DEVICE_ID_INTEL_7500_1_ERR,\n\t\t.ctl_name = \"E7500\"},\n\t[E7501] = {\n\t\t.err_dev = PCI_DEVICE_ID_INTEL_7501_1_ERR,\n\t\t.ctl_name = \"E7501\"},\n\t[E7505] = {\n\t\t.err_dev = PCI_DEVICE_ID_INTEL_7505_1_ERR,\n\t\t.ctl_name = \"E7505\"},\n\t[E7205] = {\n\t\t.err_dev = PCI_DEVICE_ID_INTEL_7205_1_ERR,\n\t\t.ctl_name = \"E7205\"},\n};\n\n \nstatic inline int e7xxx_find_channel(u16 syndrome)\n{\n\tedac_dbg(3, \"\\n\");\n\n\tif ((syndrome & 0xff00) == 0)\n\t\treturn 0;\n\n\tif ((syndrome & 0x00ff) == 0)\n\t\treturn 1;\n\n\tif ((syndrome & 0xf000) == 0 || (syndrome & 0x0f00) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic unsigned long ctl_page_to_phys(struct mem_ctl_info *mci,\n\t\t\t\tunsigned long page)\n{\n\tu32 remap;\n\tstruct e7xxx_pvt *pvt = (struct e7xxx_pvt *)mci->pvt_info;\n\n\tedac_dbg(3, \"\\n\");\n\n\tif ((page < pvt->tolm) ||\n\t\t((page >= 0x100000) && (page < pvt->remapbase)))\n\t\treturn page;\n\n\tremap = (page - pvt->tolm) + pvt->remapbase;\n\n\tif (remap < pvt->remaplimit)\n\t\treturn remap;\n\n\te7xxx_printk(KERN_ERR, \"Invalid page %lx - out of range\\n\", page);\n\treturn pvt->tolm - 1;\n}\n\nstatic void process_ce(struct mem_ctl_info *mci, struct e7xxx_error_info *info)\n{\n\tu32 error_1b, page;\n\tu16 syndrome;\n\tint row;\n\tint channel;\n\n\tedac_dbg(3, \"\\n\");\n\t \n\terror_1b = info->dram_celog_add;\n\t \n\tpage = error_1b >> 6;\t \n\t \n\tsyndrome = info->dram_celog_syndrome;\n\t \n\trow = edac_mc_find_csrow_by_page(mci, page);\n\t \n\tchannel = e7xxx_find_channel(syndrome);\n\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, page, 0, syndrome,\n\t\t\t     row, channel, -1, \"e7xxx CE\", \"\");\n}\n\nstatic void process_ce_no_info(struct mem_ctl_info *mci)\n{\n\tedac_dbg(3, \"\\n\");\n\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0, -1, -1, -1,\n\t\t\t     \"e7xxx CE log register overflow\", \"\");\n}\n\nstatic void process_ue(struct mem_ctl_info *mci, struct e7xxx_error_info *info)\n{\n\tu32 error_2b, block_page;\n\tint row;\n\n\tedac_dbg(3, \"\\n\");\n\t \n\terror_2b = info->dram_uelog_add;\n\t \n\tblock_page = error_2b >> 6;\t \n\trow = edac_mc_find_csrow_by_page(mci, block_page);\n\n\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, block_page, 0, 0,\n\t\t\t     row, -1, -1, \"e7xxx UE\", \"\");\n}\n\nstatic void process_ue_no_info(struct mem_ctl_info *mci)\n{\n\tedac_dbg(3, \"\\n\");\n\n\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0, -1, -1, -1,\n\t\t\t     \"e7xxx UE log register overflow\", \"\");\n}\n\nstatic void e7xxx_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\t struct e7xxx_error_info *info)\n{\n\tstruct e7xxx_pvt *pvt;\n\n\tpvt = (struct e7xxx_pvt *)mci->pvt_info;\n\tpci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_FERR, &info->dram_ferr);\n\tpci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_NERR, &info->dram_nerr);\n\n\tif ((info->dram_ferr & 1) || (info->dram_nerr & 1)) {\n\t\tpci_read_config_dword(pvt->bridge_ck, E7XXX_DRAM_CELOG_ADD,\n\t\t\t\t&info->dram_celog_add);\n\t\tpci_read_config_word(pvt->bridge_ck,\n\t\t\t\tE7XXX_DRAM_CELOG_SYNDROME,\n\t\t\t\t&info->dram_celog_syndrome);\n\t}\n\n\tif ((info->dram_ferr & 2) || (info->dram_nerr & 2))\n\t\tpci_read_config_dword(pvt->bridge_ck, E7XXX_DRAM_UELOG_ADD,\n\t\t\t\t&info->dram_uelog_add);\n\n\tif (info->dram_ferr & 3)\n\t\tpci_write_bits8(pvt->bridge_ck, E7XXX_DRAM_FERR, 0x03, 0x03);\n\n\tif (info->dram_nerr & 3)\n\t\tpci_write_bits8(pvt->bridge_ck, E7XXX_DRAM_NERR, 0x03, 0x03);\n}\n\nstatic int e7xxx_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct e7xxx_error_info *info,\n\t\t\t\tint handle_errors)\n{\n\tint error_found;\n\n\terror_found = 0;\n\n\t \n\tif (info->dram_ferr & 1) {\t \n\t\terror_found = 1;\n\n\t\tif (handle_errors)\n\t\t\tprocess_ce(mci, info);\n\t}\n\n\tif (info->dram_ferr & 2) {\t \n\t\terror_found = 1;\n\n\t\tif (handle_errors)\n\t\t\tprocess_ue(mci, info);\n\t}\n\n\tif (info->dram_nerr & 1) {\t \n\t\terror_found = 1;\n\n\t\tif (handle_errors) {\n\t\t\tif (info->dram_ferr & 1)\n\t\t\t\tprocess_ce_no_info(mci);\n\t\t\telse\n\t\t\t\tprocess_ce(mci, info);\n\t\t}\n\t}\n\n\tif (info->dram_nerr & 2) {\t \n\t\terror_found = 1;\n\n\t\tif (handle_errors) {\n\t\t\tif (info->dram_ferr & 2)\n\t\t\t\tprocess_ue_no_info(mci);\n\t\t\telse\n\t\t\t\tprocess_ue(mci, info);\n\t\t}\n\t}\n\n\treturn error_found;\n}\n\nstatic void e7xxx_check(struct mem_ctl_info *mci)\n{\n\tstruct e7xxx_error_info info;\n\n\te7xxx_get_error_info(mci, &info);\n\te7xxx_process_error_info(mci, &info, 1);\n}\n\n \nstatic inline int dual_channel_active(u32 drc, int dev_idx)\n{\n\treturn (dev_idx == E7501) ? ((drc >> 22) & 0x1) : 1;\n}\n\n \nstatic inline int drb_granularity(u32 drc, int dev_idx)\n{\n\t \n\treturn (dev_idx == E7501) ? ((drc >> 18) & 0x3) : 1;\n}\n\nstatic void e7xxx_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\n\t\t\tint dev_idx, u32 drc)\n{\n\tunsigned long last_cumul_size;\n\tint index, j;\n\tu8 value;\n\tu32 dra, cumul_size, nr_pages;\n\tint drc_chan, drc_drbg, drc_ddim, mem_dev;\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\tenum edac_type edac_mode;\n\n\tpci_read_config_dword(pdev, E7XXX_DRA, &dra);\n\tdrc_chan = dual_channel_active(drc, dev_idx);\n\tdrc_drbg = drb_granularity(drc, dev_idx);\n\tdrc_ddim = (drc >> 20) & 0x3;\n\tlast_cumul_size = 0;\n\n\t \n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\t \n\t\tmem_dev = (dra >> (index * 4 + 3)) & 0x1;\n\t\tcsrow = mci->csrows[index];\n\n\t\tpci_read_config_byte(pdev, E7XXX_DRB + index, &value);\n\t\t \n\t\tcumul_size = value << (25 + drc_drbg - PAGE_SHIFT);\n\t\tedac_dbg(3, \"(%d) cumul_size 0x%x\\n\", index, cumul_size);\n\t\tif (cumul_size == last_cumul_size)\n\t\t\tcontinue;\t \n\n\t\tcsrow->first_page = last_cumul_size;\n\t\tcsrow->last_page = cumul_size - 1;\n\t\tnr_pages = cumul_size - last_cumul_size;\n\t\tlast_cumul_size = cumul_size;\n\n\t\t \n\t\tif (drc_ddim) {\n\t\t\tif (drc_chan && mem_dev) {\n\t\t\t\tedac_mode = EDAC_S4ECD4ED;\n\t\t\t\tmci->edac_cap |= EDAC_FLAG_S4ECD4ED;\n\t\t\t} else {\n\t\t\t\tedac_mode = EDAC_SECDED;\n\t\t\t\tmci->edac_cap |= EDAC_FLAG_SECDED;\n\t\t\t}\n\t\t} else\n\t\t\tedac_mode = EDAC_NONE;\n\n\t\tfor (j = 0; j < drc_chan + 1; j++) {\n\t\t\tdimm = csrow->channels[j]->dimm;\n\n\t\t\tdimm->nr_pages = nr_pages / (drc_chan + 1);\n\t\t\tdimm->grain = 1 << 12;\t \n\t\t\tdimm->mtype = MEM_RDDR;\t \n\t\t\tdimm->dtype = mem_dev ? DEV_X4 : DEV_X8;\n\t\t\tdimm->edac_mode = edac_mode;\n\t\t}\n\t}\n}\n\nstatic int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tu16 pci_data;\n\tstruct mem_ctl_info *mci = NULL;\n\tstruct edac_mc_layer layers[2];\n\tstruct e7xxx_pvt *pvt = NULL;\n\tu32 drc;\n\tint drc_chan;\n\tstruct e7xxx_error_info discard;\n\n\tedac_dbg(0, \"mci\\n\");\n\n\tpci_read_config_dword(pdev, E7XXX_DRC, &drc);\n\n\tdrc_chan = dual_channel_active(drc, dev_idx);\n\t \n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = E7XXX_NR_CSROWS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = drc_chan + 1;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(3, \"init mci\\n\");\n\tmci->mtype_cap = MEM_FLAG_RDDR;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED |\n\t\tEDAC_FLAG_S4ECD4ED;\n\t \n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->pdev = &pdev->dev;\n\tedac_dbg(3, \"init pvt\\n\");\n\tpvt = (struct e7xxx_pvt *)mci->pvt_info;\n\tpvt->dev_info = &e7xxx_devs[dev_idx];\n\tpvt->bridge_ck = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t\tpvt->dev_info->err_dev, pvt->bridge_ck);\n\n\tif (!pvt->bridge_ck) {\n\t\te7xxx_printk(KERN_ERR, \"error reporting device not found:\"\n\t\t\t\"vendor %x device 0x%x (broken BIOS?)\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL, e7xxx_devs[dev_idx].err_dev);\n\t\tgoto fail0;\n\t}\n\n\tedac_dbg(3, \"more mci init\\n\");\n\tmci->ctl_name = pvt->dev_info->ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = e7xxx_check;\n\tmci->ctl_page_to_phys = ctl_page_to_phys;\n\te7xxx_init_csrows(mci, pdev, dev_idx, drc);\n\tmci->edac_cap |= EDAC_FLAG_NONE;\n\tedac_dbg(3, \"tolm, remapbase, remaplimit\\n\");\n\t \n\tpci_read_config_word(pdev, E7XXX_TOLM, &pci_data);\n\tpvt->tolm = ((u32) pci_data) << 4;\n\tpci_read_config_word(pdev, E7XXX_REMAPBASE, &pci_data);\n\tpvt->remapbase = ((u32) pci_data) << 14;\n\tpci_read_config_word(pdev, E7XXX_REMAPLIMIT, &pci_data);\n\tpvt->remaplimit = ((u32) pci_data) << 14;\n\te7xxx_printk(KERN_INFO,\n\t\t\"tolm = %x, remapbase = %x, remaplimit = %x\\n\", pvt->tolm,\n\t\tpvt->remapbase, pvt->remaplimit);\n\n\t \n\te7xxx_get_error_info(mci, &discard);\n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"failed edac_mc_add_mc()\\n\");\n\t\tgoto fail1;\n\t}\n\n\t \n\te7xxx_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!e7xxx_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\t \n\tedac_dbg(3, \"success\\n\");\n\treturn 0;\n\nfail1:\n\tpci_dev_put(pvt->bridge_ck);\n\nfail0:\n\tedac_mc_free(mci);\n\n\treturn -ENODEV;\n}\n\n \nstatic int e7xxx_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\treturn pci_enable_device(pdev) ?\n\t\t-EIO : e7xxx_probe1(pdev, ent->driver_data);\n}\n\nstatic void e7xxx_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct e7xxx_pvt *pvt;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (e7xxx_pci)\n\t\tedac_pci_release_generic_ctl(e7xxx_pci);\n\n\tif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\n\t\treturn;\n\n\tpvt = (struct e7xxx_pvt *)mci->pvt_info;\n\tpci_dev_put(pvt->bridge_ck);\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id e7xxx_pci_tbl[] = {\n\t{\n\t PCI_VEND_DEV(INTEL, 7205_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t E7205},\n\t{\n\t PCI_VEND_DEV(INTEL, 7500_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t E7500},\n\t{\n\t PCI_VEND_DEV(INTEL, 7501_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t E7501},\n\t{\n\t PCI_VEND_DEV(INTEL, 7505_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t E7505},\n\t{\n\t 0,\n\t }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, e7xxx_pci_tbl);\n\nstatic struct pci_driver e7xxx_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = e7xxx_init_one,\n\t.remove = e7xxx_remove_one,\n\t.id_table = e7xxx_pci_tbl,\n};\n\nstatic int __init e7xxx_init(void)\n{\n        \n       opstate_init();\n\n\treturn pci_register_driver(&e7xxx_driver);\n}\n\nstatic void __exit e7xxx_exit(void)\n{\n\tpci_unregister_driver(&e7xxx_driver);\n}\n\nmodule_init(e7xxx_init);\nmodule_exit(e7xxx_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Linux Networx (http://lnxi.com) Thayne Harbaugh et al\");\nMODULE_DESCRIPTION(\"MC support for Intel e7xxx memory controllers\");\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}