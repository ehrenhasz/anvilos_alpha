{
  "module_name": "octeon_edac-lmc.c",
  "hash_id": "c595816fea6683e60ff0d2e00b9ab0b5e09618deb3b1b99146789531ce18036e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/octeon_edac-lmc.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/edac.h>\n#include <linux/ctype.h>\n\n#include <asm/octeon/octeon.h>\n#include <asm/octeon/cvmx-lmcx-defs.h>\n\n#include \"edac_module.h\"\n\n#define OCTEON_MAX_MC 4\n\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\n\nstruct octeon_lmc_pvt {\n\tunsigned long inject;\n\tunsigned long error_type;\n\tunsigned long dimm;\n\tunsigned long rank;\n\tunsigned long bank;\n\tunsigned long row;\n\tunsigned long col;\n};\n\nstatic void octeon_lmc_edac_poll(struct mem_ctl_info *mci)\n{\n\tunion cvmx_lmcx_mem_cfg0 cfg0;\n\tbool do_clear = false;\n\tchar msg[64];\n\n\tcfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mci->mc_idx));\n\tif (cfg0.s.sec_err || cfg0.s.ded_err) {\n\t\tunion cvmx_lmcx_fadr fadr;\n\t\tfadr.u64 = cvmx_read_csr(CVMX_LMCX_FADR(mci->mc_idx));\n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"DIMM %d rank %d bank %d row %d col %d\",\n\t\t\t fadr.cn30xx.fdimm, fadr.cn30xx.fbunk,\n\t\t\t fadr.cn30xx.fbank, fadr.cn30xx.frow, fadr.cn30xx.fcol);\n\t}\n\n\tif (cfg0.s.sec_err) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1, msg, \"\");\n\t\tcfg0.s.sec_err = -1;\t \n\t\tdo_clear = true;\n\t}\n\n\tif (cfg0.s.ded_err) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1, msg, \"\");\n\t\tcfg0.s.ded_err = -1;\t \n\t\tdo_clear = true;\n\t}\n\tif (do_clear)\n\t\tcvmx_write_csr(CVMX_LMCX_MEM_CFG0(mci->mc_idx), cfg0.u64);\n}\n\nstatic void octeon_lmc_edac_poll_o2(struct mem_ctl_info *mci)\n{\n\tstruct octeon_lmc_pvt *pvt = mci->pvt_info;\n\tunion cvmx_lmcx_int int_reg;\n\tbool do_clear = false;\n\tchar msg[64];\n\n\tif (!pvt->inject)\n\t\tint_reg.u64 = cvmx_read_csr(CVMX_LMCX_INT(mci->mc_idx));\n\telse {\n\t\tint_reg.u64 = 0;\n\t\tif (pvt->error_type == 1)\n\t\t\tint_reg.s.sec_err = 1;\n\t\tif (pvt->error_type == 2)\n\t\t\tint_reg.s.ded_err = 1;\n\t}\n\n\tif (int_reg.s.sec_err || int_reg.s.ded_err) {\n\t\tunion cvmx_lmcx_fadr fadr;\n\t\tif (likely(!pvt->inject))\n\t\t\tfadr.u64 = cvmx_read_csr(CVMX_LMCX_FADR(mci->mc_idx));\n\t\telse {\n\t\t\tfadr.cn61xx.fdimm = pvt->dimm;\n\t\t\tfadr.cn61xx.fbunk = pvt->rank;\n\t\t\tfadr.cn61xx.fbank = pvt->bank;\n\t\t\tfadr.cn61xx.frow = pvt->row;\n\t\t\tfadr.cn61xx.fcol = pvt->col;\n\t\t}\n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"DIMM %d rank %d bank %d row %d col %d\",\n\t\t\t fadr.cn61xx.fdimm, fadr.cn61xx.fbunk,\n\t\t\t fadr.cn61xx.fbank, fadr.cn61xx.frow, fadr.cn61xx.fcol);\n\t}\n\n\tif (int_reg.s.sec_err) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1, msg, \"\");\n\t\tint_reg.s.sec_err = -1;\t \n\t\tdo_clear = true;\n\t}\n\n\tif (int_reg.s.ded_err) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1, msg, \"\");\n\t\tint_reg.s.ded_err = -1;\t \n\t\tdo_clear = true;\n\t}\n\n\tif (do_clear) {\n\t\tif (likely(!pvt->inject))\n\t\t\tcvmx_write_csr(CVMX_LMCX_INT(mci->mc_idx), int_reg.u64);\n\t\telse\n\t\t\tpvt->inject = 0;\n\t}\n}\n\n \n\n \n#define TEMPLATE_SHOW(reg)\t\t\t\t\t\t\\\nstatic ssize_t octeon_mc_inject_##reg##_show(struct device *dev,\t\\\n\t\t\t       struct device_attribute *attr,\t\t\\\n\t\t\t       char *data)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct mem_ctl_info *mci = to_mci(dev);\t\t\t\t\\\n\tstruct octeon_lmc_pvt *pvt = mci->pvt_info;\t\t\t\\\n\treturn sprintf(data, \"%016llu\\n\", (u64)pvt->reg);\t\t\\\n}\n\n#define TEMPLATE_STORE(reg)\t\t\t\t\t\t\\\nstatic ssize_t octeon_mc_inject_##reg##_store(struct device *dev,\t\\\n\t\t\t       struct device_attribute *attr,\t\t\\\n\t\t\t       const char *data, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct mem_ctl_info *mci = to_mci(dev);\t\t\t\t\\\n\tstruct octeon_lmc_pvt *pvt = mci->pvt_info;\t\t\t\\\n\tif (isdigit(*data)) {\t\t\t\t\t\t\\\n\t\tif (!kstrtoul(data, 0, &pvt->reg))\t\t\t\\\n\t\t\treturn count;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nTEMPLATE_SHOW(inject);\nTEMPLATE_STORE(inject);\nTEMPLATE_SHOW(dimm);\nTEMPLATE_STORE(dimm);\nTEMPLATE_SHOW(bank);\nTEMPLATE_STORE(bank);\nTEMPLATE_SHOW(rank);\nTEMPLATE_STORE(rank);\nTEMPLATE_SHOW(row);\nTEMPLATE_STORE(row);\nTEMPLATE_SHOW(col);\nTEMPLATE_STORE(col);\n\nstatic ssize_t octeon_mc_inject_error_type_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *data,\n\t\t\t\t\t  size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct octeon_lmc_pvt *pvt = mci->pvt_info;\n\n\tif (!strncmp(data, \"single\", 6))\n\t\tpvt->error_type = 1;\n\telse if (!strncmp(data, \"double\", 6))\n\t\tpvt->error_type = 2;\n\n\treturn count;\n}\n\nstatic ssize_t octeon_mc_inject_error_type_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct octeon_lmc_pvt *pvt = mci->pvt_info;\n\tif (pvt->error_type == 1)\n\t\treturn sprintf(data, \"single\");\n\telse if (pvt->error_type == 2)\n\t\treturn sprintf(data, \"double\");\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR(inject, S_IRUGO | S_IWUSR,\n\t\t   octeon_mc_inject_inject_show, octeon_mc_inject_inject_store);\nstatic DEVICE_ATTR(error_type, S_IRUGO | S_IWUSR,\n\t\t   octeon_mc_inject_error_type_show, octeon_mc_inject_error_type_store);\nstatic DEVICE_ATTR(dimm, S_IRUGO | S_IWUSR,\n\t\t   octeon_mc_inject_dimm_show, octeon_mc_inject_dimm_store);\nstatic DEVICE_ATTR(rank, S_IRUGO | S_IWUSR,\n\t\t   octeon_mc_inject_rank_show, octeon_mc_inject_rank_store);\nstatic DEVICE_ATTR(bank, S_IRUGO | S_IWUSR,\n\t\t   octeon_mc_inject_bank_show, octeon_mc_inject_bank_store);\nstatic DEVICE_ATTR(row, S_IRUGO | S_IWUSR,\n\t\t   octeon_mc_inject_row_show, octeon_mc_inject_row_store);\nstatic DEVICE_ATTR(col, S_IRUGO | S_IWUSR,\n\t\t   octeon_mc_inject_col_show, octeon_mc_inject_col_store);\n\nstatic struct attribute *octeon_dev_attrs[] = {\n\t&dev_attr_inject.attr,\n\t&dev_attr_error_type.attr,\n\t&dev_attr_dimm.attr,\n\t&dev_attr_rank.attr,\n\t&dev_attr_bank.attr,\n\t&dev_attr_row.attr,\n\t&dev_attr_col.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(octeon_dev);\n\nstatic int octeon_lmc_edac_probe(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[1];\n\tint mc = pdev->id;\n\n\topstate_init();\n\n\tlayers[0].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[0].size = 1;\n\tlayers[0].is_virt_csrow = false;\n\n\tif (OCTEON_IS_OCTEON1PLUS()) {\n\t\tunion cvmx_lmcx_mem_cfg0 cfg0;\n\n\t\tcfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(0));\n\t\tif (!cfg0.s.ecc_ena) {\n\t\t\tdev_info(&pdev->dev, \"Disabled (ECC not enabled)\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tmci = edac_mc_alloc(mc, ARRAY_SIZE(layers), layers, sizeof(struct octeon_lmc_pvt));\n\t\tif (!mci)\n\t\t\treturn -ENXIO;\n\n\t\tmci->pdev = &pdev->dev;\n\t\tmci->dev_name = dev_name(&pdev->dev);\n\n\t\tmci->mod_name = \"octeon-lmc\";\n\t\tmci->ctl_name = \"octeon-lmc-err\";\n\t\tmci->edac_check = octeon_lmc_edac_poll;\n\n\t\tif (edac_mc_add_mc_with_groups(mci, octeon_dev_groups)) {\n\t\t\tdev_err(&pdev->dev, \"edac_mc_add_mc() failed\\n\");\n\t\t\tedac_mc_free(mci);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tcfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mc));\n\t\tcfg0.s.intr_ded_ena = 0;\t \n\t\tcfg0.s.intr_sec_ena = 0;\n\t\tcvmx_write_csr(CVMX_LMCX_MEM_CFG0(mc), cfg0.u64);\n\t} else {\n\t\t \n\t\tunion cvmx_lmcx_int_en en;\n\t\tunion cvmx_lmcx_config config;\n\n\t\tconfig.u64 = cvmx_read_csr(CVMX_LMCX_CONFIG(0));\n\t\tif (!config.s.ecc_ena) {\n\t\t\tdev_info(&pdev->dev, \"Disabled (ECC not enabled)\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tmci = edac_mc_alloc(mc, ARRAY_SIZE(layers), layers, sizeof(struct octeon_lmc_pvt));\n\t\tif (!mci)\n\t\t\treturn -ENXIO;\n\n\t\tmci->pdev = &pdev->dev;\n\t\tmci->dev_name = dev_name(&pdev->dev);\n\n\t\tmci->mod_name = \"octeon-lmc\";\n\t\tmci->ctl_name = \"co_lmc_err\";\n\t\tmci->edac_check = octeon_lmc_edac_poll_o2;\n\n\t\tif (edac_mc_add_mc_with_groups(mci, octeon_dev_groups)) {\n\t\t\tdev_err(&pdev->dev, \"edac_mc_add_mc() failed\\n\");\n\t\t\tedac_mc_free(mci);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\ten.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mc));\n\t\ten.s.intr_ded_ena = 0;\t \n\t\ten.s.intr_sec_ena = 0;\n\t\tcvmx_write_csr(CVMX_LMCX_MEM_CFG0(mc), en.u64);\n\t}\n\tplatform_set_drvdata(pdev, mci);\n\n\treturn 0;\n}\n\nstatic int octeon_lmc_edac_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\treturn 0;\n}\n\nstatic struct platform_driver octeon_lmc_edac_driver = {\n\t.probe = octeon_lmc_edac_probe,\n\t.remove = octeon_lmc_edac_remove,\n\t.driver = {\n\t\t   .name = \"octeon_lmc_edac\",\n\t}\n};\nmodule_platform_driver(octeon_lmc_edac_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ralf Baechle <ralf@linux-mips.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}