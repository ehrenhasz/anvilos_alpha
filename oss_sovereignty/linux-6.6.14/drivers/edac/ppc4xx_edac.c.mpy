{
  "module_name": "ppc4xx_edac.c",
  "hash_id": "66116f3fb757105f7ed368509a7c234231eee68dcacb58a1b818cba26157371b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/ppc4xx_edac.c",
  "human_readable_source": "\n \n\n#include <linux/edac.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/types.h>\n\n#include <asm/dcr.h>\n\n#include \"edac_module.h\"\n#include \"ppc4xx_edac.h\"\n\n \n\n \n\n#define EDAC_OPSTATE_INT_STR\t\t\"interrupt\"\n#define EDAC_OPSTATE_POLL_STR\t\t\"polled\"\n#define EDAC_OPSTATE_UNKNOWN_STR\t\"unknown\"\n\n#define PPC4XX_EDAC_MODULE_NAME\t\t\"ppc4xx_edac\"\n#define PPC4XX_EDAC_MODULE_REVISION\t\"v1.0.0\"\n\n#define PPC4XX_EDAC_MESSAGE_SIZE\t256\n\n \n#define ppc4xx_edac_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"PPC4xx MC\", fmt, ##arg)\n\n \n#define ppc4xx_edac_mc_printk(level, mci, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"PPC4xx\", fmt, ##arg)\n\n \n#define SDRAM_MBCF_SZ_MiB_MIN\t\t4\n#define SDRAM_MBCF_SZ_TO_MiB(n)\t\t(SDRAM_MBCF_SZ_MiB_MIN \\\n\t\t\t\t\t << (SDRAM_MBCF_SZ_DECODE(n)))\n#define SDRAM_MBCF_SZ_TO_PAGES(n)\t(SDRAM_MBCF_SZ_MiB_MIN \\\n\t\t\t\t\t << (20 - PAGE_SHIFT + \\\n\t\t\t\t\t     SDRAM_MBCF_SZ_DECODE(n)))\n\n \n#define SDRAM_DCR_RESOURCE_LEN\t\t2\n#define SDRAM_DCR_ADDR_OFFSET\t\t0\n#define SDRAM_DCR_DATA_OFFSET\t\t1\n\n \n#define INTMAP_ECCDED_INDEX\t\t0\t \n#define INTMAP_ECCSEC_INDEX\t\t1\t \n\n \n\n \nstruct ppc4xx_edac_pdata {\n\tdcr_host_t dcr_host;\t \n\tstruct {\n\t\tint sec;\t \n\t\tint ded;\t \n\t} irqs;\n};\n\n \nstruct ppc4xx_ecc_status {\n\tu32 ecces;\n\tu32 besr;\n\tu32 bearh;\n\tu32 bearl;\n\tu32 wmirq;\n};\n\n \n\n \nstatic const struct of_device_id ppc4xx_edac_match[] = {\n\t{\n\t\t.compatible\t= \"ibm,sdram-4xx-ddr2\"\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ppc4xx_edac_match);\n\n \nstatic const unsigned ppc4xx_edac_nr_csrows = 2;\nstatic const unsigned ppc4xx_edac_nr_chans = 1;\n\n \nstatic const char * const ppc4xx_plb_masters[9] = {\n\t[SDRAM_PLB_M0ID_ICU]\t= \"ICU\",\n\t[SDRAM_PLB_M0ID_PCIE0]\t= \"PCI-E 0\",\n\t[SDRAM_PLB_M0ID_PCIE1]\t= \"PCI-E 1\",\n\t[SDRAM_PLB_M0ID_DMA]\t= \"DMA\",\n\t[SDRAM_PLB_M0ID_DCU]\t= \"DCU\",\n\t[SDRAM_PLB_M0ID_OPB]\t= \"OPB\",\n\t[SDRAM_PLB_M0ID_MAL]\t= \"MAL\",\n\t[SDRAM_PLB_M0ID_SEC]\t= \"SEC\",\n\t[SDRAM_PLB_M0ID_AHB]\t= \"AHB\"\n};\n\n \nstatic inline u32\nmfsdram(const dcr_host_t *dcr_host, unsigned int idcr_n)\n{\n\treturn __mfdcri(dcr_host->base + SDRAM_DCR_ADDR_OFFSET,\n\t\t\tdcr_host->base + SDRAM_DCR_DATA_OFFSET,\n\t\t\tidcr_n);\n}\n\n \nstatic inline void\nmtsdram(const dcr_host_t *dcr_host, unsigned int idcr_n, u32 value)\n{\n\treturn __mtdcri(dcr_host->base + SDRAM_DCR_ADDR_OFFSET,\n\t\t\tdcr_host->base + SDRAM_DCR_DATA_OFFSET,\n\t\t\tidcr_n,\n\t\t\tvalue);\n}\n\n \nstatic bool\nppc4xx_edac_check_bank_error(const struct ppc4xx_ecc_status *status,\n\t\t\t     unsigned int bank)\n{\n\tswitch (bank) {\n\tcase 0:\n\t\treturn status->ecces & SDRAM_ECCES_BK0ER;\n\tcase 1:\n\t\treturn status->ecces & SDRAM_ECCES_BK1ER;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int\nppc4xx_edac_generate_bank_message(const struct mem_ctl_info *mci,\n\t\t\t\t  const struct ppc4xx_ecc_status *status,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t size)\n{\n\tint n, total = 0;\n\tunsigned int row, rows;\n\n\tn = snprintf(buffer, size, \"%s: Banks: \", mci->dev_name);\n\n\tif (n < 0 || n >= size)\n\t\tgoto fail;\n\n\tbuffer += n;\n\tsize -= n;\n\ttotal += n;\n\n\tfor (rows = 0, row = 0; row < mci->nr_csrows; row++) {\n\t\tif (ppc4xx_edac_check_bank_error(status, row)) {\n\t\t\tn = snprintf(buffer, size, \"%s%u\",\n\t\t\t\t\t(rows++ ? \", \" : \"\"), row);\n\n\t\t\tif (n < 0 || n >= size)\n\t\t\t\tgoto fail;\n\n\t\t\tbuffer += n;\n\t\t\tsize -= n;\n\t\t\ttotal += n;\n\t\t}\n\t}\n\n\tn = snprintf(buffer, size, \"%s; \", rows ? \"\" : \"None\");\n\n\tif (n < 0 || n >= size)\n\t\tgoto fail;\n\n\tbuffer += n;\n\tsize -= n;\n\ttotal += n;\n\n fail:\n\treturn total;\n}\n\n \nstatic int\nppc4xx_edac_generate_checkbit_message(const struct mem_ctl_info *mci,\n\t\t\t\t      const struct ppc4xx_ecc_status *status,\n\t\t\t\t      char *buffer,\n\t\t\t\t      size_t size)\n{\n\tconst struct ppc4xx_edac_pdata *pdata = mci->pvt_info;\n\tconst char *ckber = NULL;\n\n\tswitch (status->ecces & SDRAM_ECCES_CKBER_MASK) {\n\tcase SDRAM_ECCES_CKBER_NONE:\n\t\tckber = \"None\";\n\t\tbreak;\n\tcase SDRAM_ECCES_CKBER_32_ECC_0_3:\n\t\tckber = \"ECC0:3\";\n\t\tbreak;\n\tcase SDRAM_ECCES_CKBER_32_ECC_4_8:\n\t\tswitch (mfsdram(&pdata->dcr_host, SDRAM_MCOPT1) &\n\t\t\tSDRAM_MCOPT1_WDTH_MASK) {\n\t\tcase SDRAM_MCOPT1_WDTH_16:\n\t\t\tckber = \"ECC0:3\";\n\t\t\tbreak;\n\t\tcase SDRAM_MCOPT1_WDTH_32:\n\t\t\tckber = \"ECC4:8\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tckber = \"Unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SDRAM_ECCES_CKBER_32_ECC_0_8:\n\t\tckber = \"ECC0:8\";\n\t\tbreak;\n\tdefault:\n\t\tckber = \"Unknown\";\n\t\tbreak;\n\t}\n\n\treturn snprintf(buffer, size, \"Checkbit Error: %s\", ckber);\n}\n\n \nstatic int\nppc4xx_edac_generate_lane_message(const struct mem_ctl_info *mci,\n\t\t\t\t  const struct ppc4xx_ecc_status *status,\n\t\t\t\t  char *buffer,\n\t\t\t\t  size_t size)\n{\n\tint n, total = 0;\n\tunsigned int lane, lanes;\n\tconst unsigned int first_lane = 0;\n\tconst unsigned int lane_count = 16;\n\n\tn = snprintf(buffer, size, \"; Byte Lane Errors: \");\n\n\tif (n < 0 || n >= size)\n\t\tgoto fail;\n\n\tbuffer += n;\n\tsize -= n;\n\ttotal += n;\n\n\tfor (lanes = 0, lane = first_lane; lane < lane_count; lane++) {\n\t\tif ((status->ecces & SDRAM_ECCES_BNCE_ENCODE(lane)) != 0) {\n\t\t\tn = snprintf(buffer, size,\n\t\t\t\t     \"%s%u\",\n\t\t\t\t     (lanes++ ? \", \" : \"\"), lane);\n\n\t\t\tif (n < 0 || n >= size)\n\t\t\t\tgoto fail;\n\n\t\t\tbuffer += n;\n\t\t\tsize -= n;\n\t\t\ttotal += n;\n\t\t}\n\t}\n\n\tn = snprintf(buffer, size, \"%s; \", lanes ? \"\" : \"None\");\n\n\tif (n < 0 || n >= size)\n\t\tgoto fail;\n\n\tbuffer += n;\n\tsize -= n;\n\ttotal += n;\n\n fail:\n\treturn total;\n}\n\n \nstatic int\nppc4xx_edac_generate_ecc_message(const struct mem_ctl_info *mci,\n\t\t\t\t const struct ppc4xx_ecc_status *status,\n\t\t\t\t char *buffer,\n\t\t\t\t size_t size)\n{\n\tint n, total = 0;\n\n\tn = ppc4xx_edac_generate_bank_message(mci, status, buffer, size);\n\n\tif (n < 0 || n >= size)\n\t\tgoto fail;\n\n\tbuffer += n;\n\tsize -= n;\n\ttotal += n;\n\n\tn = ppc4xx_edac_generate_checkbit_message(mci, status, buffer, size);\n\n\tif (n < 0 || n >= size)\n\t\tgoto fail;\n\n\tbuffer += n;\n\tsize -= n;\n\ttotal += n;\n\n\tn = ppc4xx_edac_generate_lane_message(mci, status, buffer, size);\n\n\tif (n < 0 || n >= size)\n\t\tgoto fail;\n\n\tbuffer += n;\n\tsize -= n;\n\ttotal += n;\n\n fail:\n\treturn total;\n}\n\n \nstatic int\nppc4xx_edac_generate_plb_message(const struct mem_ctl_info *mci,\n\t\t\t\t const struct ppc4xx_ecc_status *status,\n\t\t\t\t char *buffer,\n\t\t\t\t size_t size)\n{\n\tunsigned int master;\n\tbool read;\n\n\tif ((status->besr & SDRAM_BESR_MASK) == 0)\n\t\treturn 0;\n\n\tif ((status->besr & SDRAM_BESR_M0ET_MASK) == SDRAM_BESR_M0ET_NONE)\n\t\treturn 0;\n\n\tread = ((status->besr & SDRAM_BESR_M0RW_MASK) == SDRAM_BESR_M0RW_READ);\n\n\tmaster = SDRAM_BESR_M0ID_DECODE(status->besr);\n\n\treturn snprintf(buffer, size,\n\t\t\t\"%s error w/ PLB master %u \\\"%s\\\"; \",\n\t\t\t(read ? \"Read\" : \"Write\"),\n\t\t\tmaster,\n\t\t\t(((master >= SDRAM_PLB_M0ID_FIRST) &&\n\t\t\t  (master <= SDRAM_PLB_M0ID_LAST)) ?\n\t\t\t ppc4xx_plb_masters[master] : \"UNKNOWN\"));\n}\n\n \nstatic void\nppc4xx_edac_generate_message(const struct mem_ctl_info *mci,\n\t\t\t     const struct ppc4xx_ecc_status *status,\n\t\t\t     char *buffer,\n\t\t\t     size_t size)\n{\n\tint n;\n\n\tif (buffer == NULL || size == 0)\n\t\treturn;\n\n\tn = ppc4xx_edac_generate_ecc_message(mci, status, buffer, size);\n\n\tif (n < 0 || n >= size)\n\t\treturn;\n\n\tbuffer += n;\n\tsize -= n;\n\n\tppc4xx_edac_generate_plb_message(mci, status, buffer, size);\n}\n\n#ifdef DEBUG\n \nstatic void\nppc4xx_ecc_dump_status(const struct mem_ctl_info *mci,\n\t\t       const struct ppc4xx_ecc_status *status)\n{\n\tchar message[PPC4XX_EDAC_MESSAGE_SIZE];\n\n\tppc4xx_edac_generate_message(mci, status, message, sizeof(message));\n\n\tppc4xx_edac_mc_printk(KERN_INFO, mci,\n\t\t\t      \"\\n\"\n\t\t\t      \"\\tECCES: 0x%08x\\n\"\n\t\t\t      \"\\tWMIRQ: 0x%08x\\n\"\n\t\t\t      \"\\tBESR:  0x%08x\\n\"\n\t\t\t      \"\\tBEAR:  0x%08x%08x\\n\"\n\t\t\t      \"\\t%s\\n\",\n\t\t\t      status->ecces,\n\t\t\t      status->wmirq,\n\t\t\t      status->besr,\n\t\t\t      status->bearh,\n\t\t\t      status->bearl,\n\t\t\t      message);\n}\n#endif  \n\n \nstatic void\nppc4xx_ecc_get_status(const struct mem_ctl_info *mci,\n\t\t      struct ppc4xx_ecc_status *status)\n{\n\tconst struct ppc4xx_edac_pdata *pdata = mci->pvt_info;\n\tconst dcr_host_t *dcr_host = &pdata->dcr_host;\n\n\tstatus->ecces = mfsdram(dcr_host, SDRAM_ECCES) & SDRAM_ECCES_MASK;\n\tstatus->wmirq = mfsdram(dcr_host, SDRAM_WMIRQ) & SDRAM_WMIRQ_MASK;\n\tstatus->besr  = mfsdram(dcr_host, SDRAM_BESR)  & SDRAM_BESR_MASK;\n\tstatus->bearl = mfsdram(dcr_host, SDRAM_BEARL);\n\tstatus->bearh = mfsdram(dcr_host, SDRAM_BEARH);\n}\n\n \nstatic void\nppc4xx_ecc_clear_status(const struct mem_ctl_info *mci,\n\t\t\tconst struct ppc4xx_ecc_status *status)\n{\n\tconst struct ppc4xx_edac_pdata *pdata = mci->pvt_info;\n\tconst dcr_host_t *dcr_host = &pdata->dcr_host;\n\n\tmtsdram(dcr_host, SDRAM_ECCES,\tstatus->ecces & SDRAM_ECCES_MASK);\n\tmtsdram(dcr_host, SDRAM_WMIRQ,\tstatus->wmirq & SDRAM_WMIRQ_MASK);\n\tmtsdram(dcr_host, SDRAM_BESR,\tstatus->besr & SDRAM_BESR_MASK);\n\tmtsdram(dcr_host, SDRAM_BEARL,\t0);\n\tmtsdram(dcr_host, SDRAM_BEARH,\t0);\n}\n\n \nstatic void\nppc4xx_edac_handle_ce(struct mem_ctl_info *mci,\n\t\t      const struct ppc4xx_ecc_status *status)\n{\n\tint row;\n\tchar message[PPC4XX_EDAC_MESSAGE_SIZE];\n\n\tppc4xx_edac_generate_message(mci, status, message, sizeof(message));\n\n\tfor (row = 0; row < mci->nr_csrows; row++)\n\t\tif (ppc4xx_edac_check_bank_error(status, row))\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t\t     0, 0, 0,\n\t\t\t\t\t     row, 0, -1,\n\t\t\t\t\t     message, \"\");\n}\n\n \nstatic void\nppc4xx_edac_handle_ue(struct mem_ctl_info *mci,\n\t\t      const struct ppc4xx_ecc_status *status)\n{\n\tconst u64 bear = ((u64)status->bearh << 32 | status->bearl);\n\tconst unsigned long page = bear >> PAGE_SHIFT;\n\tconst unsigned long offset = bear & ~PAGE_MASK;\n\tint row;\n\tchar message[PPC4XX_EDAC_MESSAGE_SIZE];\n\n\tppc4xx_edac_generate_message(mci, status, message, sizeof(message));\n\n\tfor (row = 0; row < mci->nr_csrows; row++)\n\t\tif (ppc4xx_edac_check_bank_error(status, row))\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\t     page, offset, 0,\n\t\t\t\t\t     row, 0, -1,\n\t\t\t\t\t     message, \"\");\n}\n\n \nstatic void\nppc4xx_edac_check(struct mem_ctl_info *mci)\n{\n#ifdef DEBUG\n\tstatic unsigned int count;\n#endif\n\tstruct ppc4xx_ecc_status status;\n\n\tppc4xx_ecc_get_status(mci, &status);\n\n#ifdef DEBUG\n\tif (count++ % 30 == 0)\n\t\tppc4xx_ecc_dump_status(mci, &status);\n#endif\n\n\tif (status.ecces & SDRAM_ECCES_UE)\n\t\tppc4xx_edac_handle_ue(mci, &status);\n\n\tif (status.ecces & SDRAM_ECCES_CE)\n\t\tppc4xx_edac_handle_ce(mci, &status);\n\n\tppc4xx_ecc_clear_status(mci, &status);\n}\n\n \nstatic irqreturn_t\nppc4xx_edac_isr(int irq, void *dev_id)\n{\n\tstruct mem_ctl_info *mci = dev_id;\n\n\tppc4xx_edac_check(mci);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic enum dev_type ppc4xx_edac_get_dtype(u32 mcopt1)\n{\n\tswitch (mcopt1 & SDRAM_MCOPT1_WDTH_MASK) {\n\tcase SDRAM_MCOPT1_WDTH_16:\n\t\treturn DEV_X2;\n\tcase SDRAM_MCOPT1_WDTH_32:\n\t\treturn DEV_X4;\n\tdefault:\n\t\treturn DEV_UNKNOWN;\n\t}\n}\n\n \nstatic enum mem_type ppc4xx_edac_get_mtype(u32 mcopt1)\n{\n\tbool rden = ((mcopt1 & SDRAM_MCOPT1_RDEN_MASK) == SDRAM_MCOPT1_RDEN);\n\n\tswitch (mcopt1 & SDRAM_MCOPT1_DDR_TYPE_MASK) {\n\tcase SDRAM_MCOPT1_DDR2_TYPE:\n\t\treturn rden ? MEM_RDDR2 : MEM_DDR2;\n\tcase SDRAM_MCOPT1_DDR1_TYPE:\n\t\treturn rden ? MEM_RDDR : MEM_DDR;\n\tdefault:\n\t\treturn MEM_UNKNOWN;\n\t}\n}\n\n \nstatic int ppc4xx_edac_init_csrows(struct mem_ctl_info *mci, u32 mcopt1)\n{\n\tconst struct ppc4xx_edac_pdata *pdata = mci->pvt_info;\n\tint status = 0;\n\tenum mem_type mtype;\n\tenum dev_type dtype;\n\tenum edac_type edac_mode;\n\tint row, j;\n\tu32 mbxcf, size, nr_pages;\n\n\t \n\n\tmtype = ppc4xx_edac_get_mtype(mcopt1);\n\tdtype = ppc4xx_edac_get_dtype(mcopt1);\n\n\t \n\n\tif (mci->edac_cap & EDAC_FLAG_SECDED)\n\t\tedac_mode = EDAC_SECDED;\n\telse if (mci->edac_cap & EDAC_FLAG_EC)\n\t\tedac_mode = EDAC_EC;\n\telse\n\t\tedac_mode = EDAC_NONE;\n\n\t \n\n\tfor (row = 0; row < mci->nr_csrows; row++) {\n\t\tstruct csrow_info *csi = mci->csrows[row];\n\n\t\t \n\n\t\tmbxcf = mfsdram(&pdata->dcr_host, SDRAM_MBXCF(row));\n\n\t\tif ((mbxcf & SDRAM_MBCF_BE_MASK) != SDRAM_MBCF_BE_ENABLE)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tsize = mbxcf & SDRAM_MBCF_SZ_MASK;\n\n\t\tswitch (size) {\n\t\tcase SDRAM_MBCF_SZ_4MB:\n\t\tcase SDRAM_MBCF_SZ_8MB:\n\t\tcase SDRAM_MBCF_SZ_16MB:\n\t\tcase SDRAM_MBCF_SZ_32MB:\n\t\tcase SDRAM_MBCF_SZ_64MB:\n\t\tcase SDRAM_MBCF_SZ_128MB:\n\t\tcase SDRAM_MBCF_SZ_256MB:\n\t\tcase SDRAM_MBCF_SZ_512MB:\n\t\tcase SDRAM_MBCF_SZ_1GB:\n\t\tcase SDRAM_MBCF_SZ_2GB:\n\t\tcase SDRAM_MBCF_SZ_4GB:\n\t\tcase SDRAM_MBCF_SZ_8GB:\n\t\t\tnr_pages = SDRAM_MBCF_SZ_TO_PAGES(size);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tppc4xx_edac_mc_printk(KERN_ERR, mci,\n\t\t\t\t\t      \"Unrecognized memory bank %d \"\n\t\t\t\t\t      \"size 0x%08x\\n\",\n\t\t\t\t\t      row, SDRAM_MBCF_SZ_DECODE(size));\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < csi->nr_channels; j++) {\n\t\t\tstruct dimm_info *dimm = csi->channels[j]->dimm;\n\n\t\t\tdimm->nr_pages  = nr_pages / csi->nr_channels;\n\t\t\tdimm->grain\t= 1;\n\n\t\t\tdimm->mtype\t= mtype;\n\t\t\tdimm->dtype\t= dtype;\n\n\t\t\tdimm->edac_mode\t= edac_mode;\n\t\t}\n\t}\n\n done:\n\treturn status;\n}\n\n \nstatic int ppc4xx_edac_mc_init(struct mem_ctl_info *mci,\n\t\t\t       struct platform_device *op,\n\t\t\t       const dcr_host_t *dcr_host, u32 mcopt1)\n{\n\tint status = 0;\n\tconst u32 memcheck = (mcopt1 & SDRAM_MCOPT1_MCHK_MASK);\n\tstruct ppc4xx_edac_pdata *pdata = NULL;\n\tconst struct device_node *np = op->dev.of_node;\n\n\tif (of_match_device(ppc4xx_edac_match, &op->dev) == NULL)\n\t\treturn -EINVAL;\n\n\t \n\n\tmci->pdev\t\t= &op->dev;\n\n\tdev_set_drvdata(mci->pdev, mci);\n\n\tpdata\t\t\t= mci->pvt_info;\n\n\tpdata->dcr_host\t\t= *dcr_host;\n\n\t \n\n\tmci->mtype_cap\t\t= (MEM_FLAG_DDR | MEM_FLAG_RDDR |\n\t\t\t\t   MEM_FLAG_DDR2 | MEM_FLAG_RDDR2);\n\n\tmci->edac_ctl_cap\t= (EDAC_FLAG_NONE |\n\t\t\t\t   EDAC_FLAG_EC |\n\t\t\t\t   EDAC_FLAG_SECDED);\n\n\tmci->scrub_cap\t\t= SCRUB_NONE;\n\tmci->scrub_mode\t\t= SCRUB_NONE;\n\n\t \n\n\tswitch (memcheck) {\n\tcase SDRAM_MCOPT1_MCHK_CHK:\n\t\tmci->edac_cap\t= EDAC_FLAG_EC;\n\t\tbreak;\n\tcase SDRAM_MCOPT1_MCHK_CHK_REP:\n\t\tmci->edac_cap\t= (EDAC_FLAG_EC | EDAC_FLAG_SECDED);\n\t\tmci->scrub_mode\t= SCRUB_SW_SRC;\n\t\tbreak;\n\tdefault:\n\t\tmci->edac_cap\t= EDAC_FLAG_NONE;\n\t\tbreak;\n\t}\n\n\t \n\n\tmci->mod_name\t\t= PPC4XX_EDAC_MODULE_NAME;\n\tmci->ctl_name\t\t= ppc4xx_edac_match->compatible;\n\tmci->dev_name\t\t= np->full_name;\n\n\t \n\n\tmci->edac_check\t\t= ppc4xx_edac_check;\n\tmci->ctl_page_to_phys\t= NULL;\n\n\t \n\n\tstatus = ppc4xx_edac_init_csrows(mci, mcopt1);\n\n\tif (status)\n\t\tppc4xx_edac_mc_printk(KERN_ERR, mci,\n\t\t\t\t      \"Failed to initialize rows!\\n\");\n\n\treturn status;\n}\n\n \nstatic int ppc4xx_edac_register_irq(struct platform_device *op,\n\t\t\t\t    struct mem_ctl_info *mci)\n{\n\tint status = 0;\n\tint ded_irq, sec_irq;\n\tstruct ppc4xx_edac_pdata *pdata = mci->pvt_info;\n\tstruct device_node *np = op->dev.of_node;\n\n\tded_irq = irq_of_parse_and_map(np, INTMAP_ECCDED_INDEX);\n\tsec_irq = irq_of_parse_and_map(np, INTMAP_ECCSEC_INDEX);\n\n\tif (!ded_irq || !sec_irq) {\n\t\tppc4xx_edac_mc_printk(KERN_ERR, mci,\n\t\t\t\t      \"Unable to map interrupts.\\n\");\n\t\tstatus = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tstatus = request_irq(ded_irq,\n\t\t\t     ppc4xx_edac_isr,\n\t\t\t     0,\n\t\t\t     \"[EDAC] MC ECCDED\",\n\t\t\t     mci);\n\n\tif (status < 0) {\n\t\tppc4xx_edac_mc_printk(KERN_ERR, mci,\n\t\t\t\t      \"Unable to request irq %d for ECC DED\",\n\t\t\t\t      ded_irq);\n\t\tstatus = -ENODEV;\n\t\tgoto fail1;\n\t}\n\n\tstatus = request_irq(sec_irq,\n\t\t\t     ppc4xx_edac_isr,\n\t\t\t     0,\n\t\t\t     \"[EDAC] MC ECCSEC\",\n\t\t\t     mci);\n\n\tif (status < 0) {\n\t\tppc4xx_edac_mc_printk(KERN_ERR, mci,\n\t\t\t\t      \"Unable to request irq %d for ECC SEC\",\n\t\t\t\t      sec_irq);\n\t\tstatus = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\tppc4xx_edac_mc_printk(KERN_INFO, mci, \"ECCDED irq is %d\\n\", ded_irq);\n\tppc4xx_edac_mc_printk(KERN_INFO, mci, \"ECCSEC irq is %d\\n\", sec_irq);\n\n\tpdata->irqs.ded = ded_irq;\n\tpdata->irqs.sec = sec_irq;\n\n\treturn 0;\n\n fail2:\n\tfree_irq(sec_irq, mci);\n\n fail1:\n\tfree_irq(ded_irq, mci);\n\n fail:\n\treturn status;\n}\n\n \nstatic int ppc4xx_edac_map_dcrs(const struct device_node *np,\n\t\t\t\tdcr_host_t *dcr_host)\n{\n\tunsigned int dcr_base, dcr_len;\n\n\tif (np == NULL || dcr_host == NULL)\n\t\treturn -EINVAL;\n\n\t \n\n\tdcr_base = dcr_resource_start(np, 0);\n\tdcr_len = dcr_resource_len(np, 0);\n\n\tif (dcr_base == 0 || dcr_len == 0) {\n\t\tppc4xx_edac_printk(KERN_ERR,\n\t\t\t\t   \"Failed to obtain DCR property.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dcr_len != SDRAM_DCR_RESOURCE_LEN) {\n\t\tppc4xx_edac_printk(KERN_ERR,\n\t\t\t\t   \"Unexpected DCR length %d, expected %d.\\n\",\n\t\t\t\t   dcr_len, SDRAM_DCR_RESOURCE_LEN);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\t*dcr_host = dcr_map(np, dcr_base, dcr_len);\n\n\tif (!DCR_MAP_OK(*dcr_host)) {\n\t\tppc4xx_edac_printk(KERN_INFO, \"Failed to map DCRs.\\n\");\n\t\t    return -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ppc4xx_edac_probe(struct platform_device *op)\n{\n\tint status = 0;\n\tu32 mcopt1, memcheck;\n\tdcr_host_t dcr_host;\n\tconst struct device_node *np = op->dev.of_node;\n\tstruct mem_ctl_info *mci = NULL;\n\tstruct edac_mc_layer layers[2];\n\tstatic int ppc4xx_edac_instance;\n\n\t \n\n\tif (!of_device_is_compatible(np, \"ibm,sdram-405ex\") &&\n\t    !of_device_is_compatible(np, \"ibm,sdram-405exr\")) {\n\t\tppc4xx_edac_printk(KERN_NOTICE,\n\t\t\t\t   \"Only the PPC405EX[r] is supported.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tstatus = ppc4xx_edac_map_dcrs(np, &dcr_host);\n\n\tif (status)\n\t\treturn status;\n\n\t \n\n\tmcopt1 = mfsdram(&dcr_host, SDRAM_MCOPT1);\n\tmemcheck = (mcopt1 & SDRAM_MCOPT1_MCHK_MASK);\n\n\tif (memcheck == SDRAM_MCOPT1_MCHK_NON) {\n\t\tppc4xx_edac_printk(KERN_INFO, \"%pOF: No ECC memory detected or \"\n\t\t\t\t   \"ECC is disabled.\\n\", np);\n\t\tstatus = -ENODEV;\n\t\tgoto done;\n\t}\n\n\t \n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = ppc4xx_edac_nr_csrows;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = ppc4xx_edac_nr_chans;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(ppc4xx_edac_instance, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct ppc4xx_edac_pdata));\n\tif (mci == NULL) {\n\t\tppc4xx_edac_printk(KERN_ERR, \"%pOF: \"\n\t\t\t\t   \"Failed to allocate EDAC MC instance!\\n\",\n\t\t\t\t   np);\n\t\tstatus = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tstatus = ppc4xx_edac_mc_init(mci, op, &dcr_host, mcopt1);\n\n\tif (status) {\n\t\tppc4xx_edac_mc_printk(KERN_ERR, mci,\n\t\t\t\t      \"Failed to initialize instance!\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\n\tif (edac_mc_add_mc(mci)) {\n\t\tppc4xx_edac_mc_printk(KERN_ERR, mci,\n\t\t\t\t      \"Failed to add instance!\\n\");\n\t\tstatus = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_INT) {\n\t\tstatus = ppc4xx_edac_register_irq(op, mci);\n\n\t\tif (status)\n\t\t\tgoto fail1;\n\t}\n\n\tppc4xx_edac_instance++;\n\n\treturn 0;\n\n fail1:\n\tedac_mc_del_mc(mci->pdev);\n\n fail:\n\tedac_mc_free(mci);\n\n done:\n\treturn status;\n}\n\n \nstatic int\nppc4xx_edac_remove(struct platform_device *op)\n{\n\tstruct mem_ctl_info *mci = dev_get_drvdata(&op->dev);\n\tstruct ppc4xx_edac_pdata *pdata = mci->pvt_info;\n\n\tif (edac_op_state == EDAC_OPSTATE_INT) {\n\t\tfree_irq(pdata->irqs.sec, mci);\n\t\tfree_irq(pdata->irqs.ded, mci);\n\t}\n\n\tdcr_unmap(pdata->dcr_host, SDRAM_DCR_RESOURCE_LEN);\n\n\tedac_mc_del_mc(mci->pdev);\n\tedac_mc_free(mci);\n\n\treturn 0;\n}\n\n \nstatic inline void __init\nppc4xx_edac_opstate_init(void)\n{\n\tswitch (edac_op_state) {\n\tcase EDAC_OPSTATE_POLL:\n\tcase EDAC_OPSTATE_INT:\n\t\tbreak;\n\tdefault:\n\t\tedac_op_state = EDAC_OPSTATE_INT;\n\t\tbreak;\n\t}\n\n\tppc4xx_edac_printk(KERN_INFO, \"Reporting type: %s\\n\",\n\t\t\t   ((edac_op_state == EDAC_OPSTATE_POLL) ?\n\t\t\t    EDAC_OPSTATE_POLL_STR :\n\t\t\t    ((edac_op_state == EDAC_OPSTATE_INT) ?\n\t\t\t     EDAC_OPSTATE_INT_STR :\n\t\t\t     EDAC_OPSTATE_UNKNOWN_STR)));\n}\n\nstatic struct platform_driver ppc4xx_edac_driver = {\n\t.probe\t\t\t= ppc4xx_edac_probe,\n\t.remove\t\t\t= ppc4xx_edac_remove,\n\t.driver = {\n\t\t.name = PPC4XX_EDAC_MODULE_NAME,\n\t\t.of_match_table = ppc4xx_edac_match,\n\t},\n};\n\n \nstatic int __init\nppc4xx_edac_init(void)\n{\n\tppc4xx_edac_printk(KERN_INFO, PPC4XX_EDAC_MODULE_REVISION \"\\n\");\n\n\tppc4xx_edac_opstate_init();\n\n\treturn platform_driver_register(&ppc4xx_edac_driver);\n}\n\n \nstatic void __exit\nppc4xx_edac_exit(void)\n{\n\tplatform_driver_unregister(&ppc4xx_edac_driver);\n}\n\nmodule_init(ppc4xx_edac_init);\nmodule_exit(ppc4xx_edac_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Grant Erickson <gerickson@nuovations.com>\");\nMODULE_DESCRIPTION(\"EDAC MC Driver for the PPC4xx IBM DDR2 Memory Controller\");\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting State: \"\n\t\t \"0=\" EDAC_OPSTATE_POLL_STR \", 2=\" EDAC_OPSTATE_INT_STR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}