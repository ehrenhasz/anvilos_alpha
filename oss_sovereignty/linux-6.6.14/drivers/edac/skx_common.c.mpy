{
  "module_name": "skx_common.c",
  "hash_id": "92662ade89ea5e8bde985e4379bfcb69c1ee946605f75fbe48974de3335f799d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/skx_common.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/adxl.h>\n#include <acpi/nfit.h>\n#include <asm/mce.h>\n#include \"edac_module.h\"\n#include \"skx_common.h\"\n\nstatic const char * const component_names[] = {\n\t[INDEX_SOCKET]\t\t= \"ProcessorSocketId\",\n\t[INDEX_MEMCTRL]\t\t= \"MemoryControllerId\",\n\t[INDEX_CHANNEL]\t\t= \"ChannelId\",\n\t[INDEX_DIMM]\t\t= \"DimmSlotId\",\n\t[INDEX_CS]\t\t= \"ChipSelect\",\n\t[INDEX_NM_MEMCTRL]\t= \"NmMemoryControllerId\",\n\t[INDEX_NM_CHANNEL]\t= \"NmChannelId\",\n\t[INDEX_NM_DIMM]\t\t= \"NmDimmSlotId\",\n\t[INDEX_NM_CS]\t\t= \"NmChipSelect\",\n};\n\nstatic int component_indices[ARRAY_SIZE(component_names)];\nstatic int adxl_component_count;\nstatic const char * const *adxl_component_names;\nstatic u64 *adxl_values;\nstatic char *adxl_msg;\nstatic unsigned long adxl_nm_bitmap;\n\nstatic char skx_msg[MSG_SIZE];\nstatic skx_decode_f driver_decode;\nstatic skx_show_retry_log_f skx_show_retry_rd_err_log;\nstatic u64 skx_tolm, skx_tohm;\nstatic LIST_HEAD(dev_edac_list);\nstatic bool skx_mem_cfg_2lm;\n\nint __init skx_adxl_get(void)\n{\n\tconst char * const *names;\n\tint i, j;\n\n\tnames = adxl_get_component_names();\n\tif (!names) {\n\t\tskx_printk(KERN_NOTICE, \"No firmware support for address translation.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < INDEX_MAX; i++) {\n\t\tfor (j = 0; names[j]; j++) {\n\t\t\tif (!strcmp(component_names[i], names[j])) {\n\t\t\t\tcomponent_indices[i] = j;\n\n\t\t\t\tif (i >= INDEX_NM_FIRST)\n\t\t\t\t\tadxl_nm_bitmap |= 1 << i;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!names[j] && i < INDEX_NM_FIRST)\n\t\t\tgoto err;\n\t}\n\n\tif (skx_mem_cfg_2lm) {\n\t\tif (!adxl_nm_bitmap)\n\t\t\tskx_printk(KERN_NOTICE, \"Not enough ADXL components for 2-level memory.\\n\");\n\t\telse\n\t\t\tedac_dbg(2, \"adxl_nm_bitmap: 0x%lx\\n\", adxl_nm_bitmap);\n\t}\n\n\tadxl_component_names = names;\n\twhile (*names++)\n\t\tadxl_component_count++;\n\n\tadxl_values = kcalloc(adxl_component_count, sizeof(*adxl_values),\n\t\t\t      GFP_KERNEL);\n\tif (!adxl_values) {\n\t\tadxl_component_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tadxl_msg = kzalloc(MSG_SIZE, GFP_KERNEL);\n\tif (!adxl_msg) {\n\t\tadxl_component_count = 0;\n\t\tkfree(adxl_values);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\nerr:\n\tskx_printk(KERN_ERR, \"'%s' is not matched from DSM parameters: \",\n\t\t   component_names[i]);\n\tfor (j = 0; names[j]; j++)\n\t\tskx_printk(KERN_CONT, \"%s \", names[j]);\n\tskx_printk(KERN_CONT, \"\\n\");\n\n\treturn -ENODEV;\n}\n\nvoid __exit skx_adxl_put(void)\n{\n\tkfree(adxl_values);\n\tkfree(adxl_msg);\n}\n\nstatic bool skx_adxl_decode(struct decoded_addr *res, bool error_in_1st_level_mem)\n{\n\tstruct skx_dev *d;\n\tint i, len = 0;\n\n\tif (res->addr >= skx_tohm || (res->addr >= skx_tolm &&\n\t\t\t\t      res->addr < BIT_ULL(32))) {\n\t\tedac_dbg(0, \"Address 0x%llx out of range\\n\", res->addr);\n\t\treturn false;\n\t}\n\n\tif (adxl_decode(res->addr, adxl_values)) {\n\t\tedac_dbg(0, \"Failed to decode 0x%llx\\n\", res->addr);\n\t\treturn false;\n\t}\n\n\tres->socket  = (int)adxl_values[component_indices[INDEX_SOCKET]];\n\tif (error_in_1st_level_mem) {\n\t\tres->imc     = (adxl_nm_bitmap & BIT_NM_MEMCTRL) ?\n\t\t\t       (int)adxl_values[component_indices[INDEX_NM_MEMCTRL]] : -1;\n\t\tres->channel = (adxl_nm_bitmap & BIT_NM_CHANNEL) ?\n\t\t\t       (int)adxl_values[component_indices[INDEX_NM_CHANNEL]] : -1;\n\t\tres->dimm    = (adxl_nm_bitmap & BIT_NM_DIMM) ?\n\t\t\t       (int)adxl_values[component_indices[INDEX_NM_DIMM]] : -1;\n\t\tres->cs      = (adxl_nm_bitmap & BIT_NM_CS) ?\n\t\t\t       (int)adxl_values[component_indices[INDEX_NM_CS]] : -1;\n\t} else {\n\t\tres->imc     = (int)adxl_values[component_indices[INDEX_MEMCTRL]];\n\t\tres->channel = (int)adxl_values[component_indices[INDEX_CHANNEL]];\n\t\tres->dimm    = (int)adxl_values[component_indices[INDEX_DIMM]];\n\t\tres->cs      = (int)adxl_values[component_indices[INDEX_CS]];\n\t}\n\n\tif (res->imc > NUM_IMC - 1 || res->imc < 0) {\n\t\tskx_printk(KERN_ERR, \"Bad imc %d\\n\", res->imc);\n\t\treturn false;\n\t}\n\n\tlist_for_each_entry(d, &dev_edac_list, list) {\n\t\tif (d->imc[0].src_id == res->socket) {\n\t\t\tres->dev = d;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!res->dev) {\n\t\tskx_printk(KERN_ERR, \"No device for src_id %d imc %d\\n\",\n\t\t\t   res->socket, res->imc);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < adxl_component_count; i++) {\n\t\tif (adxl_values[i] == ~0x0ull)\n\t\t\tcontinue;\n\n\t\tlen += snprintf(adxl_msg + len, MSG_SIZE - len, \" %s:0x%llx\",\n\t\t\t\tadxl_component_names[i], adxl_values[i]);\n\t\tif (MSG_SIZE - len <= 0)\n\t\t\tbreak;\n\t}\n\n\tres->decoded_by_adxl = true;\n\n\treturn true;\n}\n\nvoid skx_set_mem_cfg(bool mem_cfg_2lm)\n{\n\tskx_mem_cfg_2lm = mem_cfg_2lm;\n}\n\nvoid skx_set_decode(skx_decode_f decode, skx_show_retry_log_f show_retry_log)\n{\n\tdriver_decode = decode;\n\tskx_show_retry_rd_err_log = show_retry_log;\n}\n\nint skx_get_src_id(struct skx_dev *d, int off, u8 *id)\n{\n\tu32 reg;\n\n\tif (pci_read_config_dword(d->util_all, off, &reg)) {\n\t\tskx_printk(KERN_ERR, \"Failed to read src id\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t*id = GET_BITFIELD(reg, 12, 14);\n\treturn 0;\n}\n\nint skx_get_node_id(struct skx_dev *d, u8 *id)\n{\n\tu32 reg;\n\n\tif (pci_read_config_dword(d->util_all, 0xf4, &reg)) {\n\t\tskx_printk(KERN_ERR, \"Failed to read node id\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t*id = GET_BITFIELD(reg, 0, 2);\n\treturn 0;\n}\n\nstatic int get_width(u32 mtr)\n{\n\tswitch (GET_BITFIELD(mtr, 8, 9)) {\n\tcase 0:\n\t\treturn DEV_X4;\n\tcase 1:\n\t\treturn DEV_X8;\n\tcase 2:\n\t\treturn DEV_X16;\n\t}\n\treturn DEV_UNKNOWN;\n}\n\n \nint skx_get_all_bus_mappings(struct res_config *cfg, struct list_head **list)\n{\n\tstruct pci_dev *pdev, *prev;\n\tstruct skx_dev *d;\n\tu32 reg;\n\tint ndev = 0;\n\n\tprev = NULL;\n\tfor (;;) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, cfg->decs_did, prev);\n\t\tif (!pdev)\n\t\t\tbreak;\n\t\tndev++;\n\t\td = kzalloc(sizeof(*d), GFP_KERNEL);\n\t\tif (!d) {\n\t\t\tpci_dev_put(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (pci_read_config_dword(pdev, cfg->busno_cfg_offset, &reg)) {\n\t\t\tkfree(d);\n\t\t\tpci_dev_put(pdev);\n\t\t\tskx_printk(KERN_ERR, \"Failed to read bus idx\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\td->bus[0] = GET_BITFIELD(reg, 0, 7);\n\t\td->bus[1] = GET_BITFIELD(reg, 8, 15);\n\t\tif (cfg->type == SKX) {\n\t\t\td->seg = pci_domain_nr(pdev->bus);\n\t\t\td->bus[2] = GET_BITFIELD(reg, 16, 23);\n\t\t\td->bus[3] = GET_BITFIELD(reg, 24, 31);\n\t\t} else {\n\t\t\td->seg = GET_BITFIELD(reg, 16, 23);\n\t\t}\n\n\t\tedac_dbg(2, \"busses: 0x%x, 0x%x, 0x%x, 0x%x\\n\",\n\t\t\t d->bus[0], d->bus[1], d->bus[2], d->bus[3]);\n\t\tlist_add_tail(&d->list, &dev_edac_list);\n\t\tprev = pdev;\n\t}\n\n\tif (list)\n\t\t*list = &dev_edac_list;\n\treturn ndev;\n}\n\nint skx_get_hi_lo(unsigned int did, int off[], u64 *tolm, u64 *tohm)\n{\n\tstruct pci_dev *pdev;\n\tu32 reg;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, did, NULL);\n\tif (!pdev) {\n\t\tedac_dbg(2, \"Can't get tolm/tohm\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (pci_read_config_dword(pdev, off[0], &reg)) {\n\t\tskx_printk(KERN_ERR, \"Failed to read tolm\\n\");\n\t\tgoto fail;\n\t}\n\tskx_tolm = reg;\n\n\tif (pci_read_config_dword(pdev, off[1], &reg)) {\n\t\tskx_printk(KERN_ERR, \"Failed to read lower tohm\\n\");\n\t\tgoto fail;\n\t}\n\tskx_tohm = reg;\n\n\tif (pci_read_config_dword(pdev, off[2], &reg)) {\n\t\tskx_printk(KERN_ERR, \"Failed to read upper tohm\\n\");\n\t\tgoto fail;\n\t}\n\tskx_tohm |= (u64)reg << 32;\n\n\tpci_dev_put(pdev);\n\t*tolm = skx_tolm;\n\t*tohm = skx_tohm;\n\tedac_dbg(2, \"tolm = 0x%llx tohm = 0x%llx\\n\", skx_tolm, skx_tohm);\n\treturn 0;\nfail:\n\tpci_dev_put(pdev);\n\treturn -ENODEV;\n}\n\nstatic int skx_get_dimm_attr(u32 reg, int lobit, int hibit, int add,\n\t\t\t     int minval, int maxval, const char *name)\n{\n\tu32 val = GET_BITFIELD(reg, lobit, hibit);\n\n\tif (val < minval || val > maxval) {\n\t\tedac_dbg(2, \"bad %s = %d (raw=0x%x)\\n\", name, val, reg);\n\t\treturn -EINVAL;\n\t}\n\treturn val + add;\n}\n\n#define numrank(reg)\tskx_get_dimm_attr(reg, 12, 13, 0, 0, 2, \"ranks\")\n#define numrow(reg)\tskx_get_dimm_attr(reg, 2, 4, 12, 1, 6, \"rows\")\n#define numcol(reg)\tskx_get_dimm_attr(reg, 0, 1, 10, 0, 2, \"cols\")\n\nint skx_get_dimm_info(u32 mtr, u32 mcmtr, u32 amap, struct dimm_info *dimm,\n\t\t      struct skx_imc *imc, int chan, int dimmno,\n\t\t      struct res_config *cfg)\n{\n\tint  banks, ranks, rows, cols, npages;\n\tenum mem_type mtype;\n\tu64 size;\n\n\tranks = numrank(mtr);\n\trows = numrow(mtr);\n\tcols = imc->hbm_mc ? 6 : numcol(mtr);\n\n\tif (imc->hbm_mc) {\n\t\tbanks = 32;\n\t\tmtype = MEM_HBM2;\n\t} else if (cfg->support_ddr5 && (amap & 0x8)) {\n\t\tbanks = 32;\n\t\tmtype = MEM_DDR5;\n\t} else {\n\t\tbanks = 16;\n\t\tmtype = MEM_DDR4;\n\t}\n\n\t \n\tsize = ((1ull << (rows + cols + ranks)) * banks) >> (20 - 3);\n\tnpages = MiB_TO_PAGES(size);\n\n\tedac_dbg(0, \"mc#%d: channel %d, dimm %d, %lld MiB (%d pages) bank: %d, rank: %d, row: 0x%x, col: 0x%x\\n\",\n\t\t imc->mc, chan, dimmno, size, npages,\n\t\t banks, 1 << ranks, rows, cols);\n\n\timc->chan[chan].dimms[dimmno].close_pg = GET_BITFIELD(mcmtr, 0, 0);\n\timc->chan[chan].dimms[dimmno].bank_xor_enable = GET_BITFIELD(mcmtr, 9, 9);\n\timc->chan[chan].dimms[dimmno].fine_grain_bank = GET_BITFIELD(amap, 0, 0);\n\timc->chan[chan].dimms[dimmno].rowbits = rows;\n\timc->chan[chan].dimms[dimmno].colbits = cols;\n\n\tdimm->nr_pages = npages;\n\tdimm->grain = 32;\n\tdimm->dtype = get_width(mtr);\n\tdimm->mtype = mtype;\n\tdimm->edac_mode = EDAC_SECDED;  \n\n\tif (imc->hbm_mc)\n\t\tsnprintf(dimm->label, sizeof(dimm->label), \"CPU_SrcID#%u_HBMC#%u_Chan#%u\",\n\t\t\t imc->src_id, imc->lmc, chan);\n\telse\n\t\tsnprintf(dimm->label, sizeof(dimm->label), \"CPU_SrcID#%u_MC#%u_Chan#%u_DIMM#%u\",\n\t\t\t imc->src_id, imc->lmc, chan, dimmno);\n\n\treturn 1;\n}\n\nint skx_get_nvdimm_info(struct dimm_info *dimm, struct skx_imc *imc,\n\t\t\tint chan, int dimmno, const char *mod_str)\n{\n\tint smbios_handle;\n\tu32 dev_handle;\n\tu16 flags;\n\tu64 size = 0;\n\n\tdev_handle = ACPI_NFIT_BUILD_DEVICE_HANDLE(dimmno, chan, imc->lmc,\n\t\t\t\t\t\t   imc->src_id, 0);\n\n\tsmbios_handle = nfit_get_smbios_id(dev_handle, &flags);\n\tif (smbios_handle == -EOPNOTSUPP) {\n\t\tpr_warn_once(\"%s: Can't find size of NVDIMM. Try enabling CONFIG_ACPI_NFIT\\n\", mod_str);\n\t\tgoto unknown_size;\n\t}\n\n\tif (smbios_handle < 0) {\n\t\tskx_printk(KERN_ERR, \"Can't find handle for NVDIMM ADR=0x%x\\n\", dev_handle);\n\t\tgoto unknown_size;\n\t}\n\n\tif (flags & ACPI_NFIT_MEM_MAP_FAILED) {\n\t\tskx_printk(KERN_ERR, \"NVDIMM ADR=0x%x is not mapped\\n\", dev_handle);\n\t\tgoto unknown_size;\n\t}\n\n\tsize = dmi_memdev_size(smbios_handle);\n\tif (size == ~0ull)\n\t\tskx_printk(KERN_ERR, \"Can't find size for NVDIMM ADR=0x%x/SMBIOS=0x%x\\n\",\n\t\t\t   dev_handle, smbios_handle);\n\nunknown_size:\n\tdimm->nr_pages = size >> PAGE_SHIFT;\n\tdimm->grain = 32;\n\tdimm->dtype = DEV_UNKNOWN;\n\tdimm->mtype = MEM_NVDIMM;\n\tdimm->edac_mode = EDAC_SECDED;  \n\n\tedac_dbg(0, \"mc#%d: channel %d, dimm %d, %llu MiB (%u pages)\\n\",\n\t\t imc->mc, chan, dimmno, size >> 20, dimm->nr_pages);\n\n\tsnprintf(dimm->label, sizeof(dimm->label), \"CPU_SrcID#%u_MC#%u_Chan#%u_DIMM#%u\",\n\t\t imc->src_id, imc->lmc, chan, dimmno);\n\n\treturn (size == 0 || size == ~0ull) ? 0 : 1;\n}\n\nint skx_register_mci(struct skx_imc *imc, struct pci_dev *pdev,\n\t\t     const char *ctl_name, const char *mod_str,\n\t\t     get_dimm_config_f get_dimm_config,\n\t\t     struct res_config *cfg)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tstruct skx_pvt *pvt;\n\tint rc;\n\n\t \n\tlayers[0].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[0].size = NUM_CHANNELS;\n\tlayers[0].is_virt_csrow = false;\n\tlayers[1].type = EDAC_MC_LAYER_SLOT;\n\tlayers[1].size = NUM_DIMMS;\n\tlayers[1].is_virt_csrow = true;\n\tmci = edac_mc_alloc(imc->mc, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct skx_pvt));\n\n\tif (unlikely(!mci))\n\t\treturn -ENOMEM;\n\n\tedac_dbg(0, \"MC#%d: mci = %p\\n\", imc->mc, mci);\n\n\t \n\timc->mci = mci;\n\tpvt = mci->pvt_info;\n\tpvt->imc = imc;\n\n\tmci->ctl_name = kasprintf(GFP_KERNEL, \"%s#%d IMC#%d\", ctl_name,\n\t\t\t\t  imc->node_id, imc->lmc);\n\tif (!mci->ctl_name) {\n\t\trc = -ENOMEM;\n\t\tgoto fail0;\n\t}\n\n\tmci->mtype_cap = MEM_FLAG_DDR4 | MEM_FLAG_NVDIMM;\n\tif (cfg->support_ddr5)\n\t\tmci->mtype_cap |= MEM_FLAG_DDR5;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE;\n\tmci->edac_cap = EDAC_FLAG_NONE;\n\tmci->mod_name = mod_str;\n\tmci->dev_name = pci_name(pdev);\n\tmci->ctl_page_to_phys = NULL;\n\n\trc = get_dimm_config(mci, cfg);\n\tif (rc < 0)\n\t\tgoto fail;\n\n\t \n\tmci->pdev = &pdev->dev;\n\n\t \n\tif (unlikely(edac_mc_add_mc(mci))) {\n\t\tedac_dbg(0, \"MC: failed edac_mc_add_mc()\\n\");\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tkfree(mci->ctl_name);\nfail0:\n\tedac_mc_free(mci);\n\timc->mci = NULL;\n\treturn rc;\n}\n\nstatic void skx_unregister_mci(struct skx_imc *imc)\n{\n\tstruct mem_ctl_info *mci = imc->mci;\n\n\tif (!mci)\n\t\treturn;\n\n\tedac_dbg(0, \"MC%d: mci = %p\\n\", imc->mc, mci);\n\n\t \n\tedac_mc_del_mc(mci->pdev);\n\n\tedac_dbg(1, \"%s: free mci struct\\n\", mci->ctl_name);\n\tkfree(mci->ctl_name);\n\tedac_mc_free(mci);\n}\n\nstatic void skx_mce_output_error(struct mem_ctl_info *mci,\n\t\t\t\t const struct mce *m,\n\t\t\t\t struct decoded_addr *res)\n{\n\tenum hw_event_mc_err_type tp_event;\n\tchar *optype;\n\tbool ripv = GET_BITFIELD(m->mcgstatus, 0, 0);\n\tbool overflow = GET_BITFIELD(m->status, 62, 62);\n\tbool uncorrected_error = GET_BITFIELD(m->status, 61, 61);\n\tbool scrub_err = false;\n\tbool recoverable;\n\tint len;\n\tu32 core_err_cnt = GET_BITFIELD(m->status, 38, 52);\n\tu32 mscod = GET_BITFIELD(m->status, 16, 31);\n\tu32 errcode = GET_BITFIELD(m->status, 0, 15);\n\tu32 optypenum = GET_BITFIELD(m->status, 4, 6);\n\n\trecoverable = GET_BITFIELD(m->status, 56, 56);\n\n\tif (uncorrected_error) {\n\t\tcore_err_cnt = 1;\n\t\tif (ripv) {\n\t\t\ttp_event = HW_EVENT_ERR_UNCORRECTED;\n\t\t} else {\n\t\t\ttp_event = HW_EVENT_ERR_FATAL;\n\t\t}\n\t} else {\n\t\ttp_event = HW_EVENT_ERR_CORRECTED;\n\t}\n\n\tswitch (optypenum) {\n\tcase 0:\n\t\toptype = \"generic undef request error\";\n\t\tbreak;\n\tcase 1:\n\t\toptype = \"memory read error\";\n\t\tbreak;\n\tcase 2:\n\t\toptype = \"memory write error\";\n\t\tbreak;\n\tcase 3:\n\t\toptype = \"addr/cmd error\";\n\t\tbreak;\n\tcase 4:\n\t\toptype = \"memory scrubbing error\";\n\t\tscrub_err = true;\n\t\tbreak;\n\tdefault:\n\t\toptype = \"reserved\";\n\t\tbreak;\n\t}\n\n\tif (res->decoded_by_adxl) {\n\t\tlen = snprintf(skx_msg, MSG_SIZE, \"%s%s err_code:0x%04x:0x%04x %s\",\n\t\t\t overflow ? \" OVERFLOW\" : \"\",\n\t\t\t (uncorrected_error && recoverable) ? \" recoverable\" : \"\",\n\t\t\t mscod, errcode, adxl_msg);\n\t} else {\n\t\tlen = snprintf(skx_msg, MSG_SIZE,\n\t\t\t \"%s%s err_code:0x%04x:0x%04x ProcessorSocketId:0x%x MemoryControllerId:0x%x PhysicalRankId:0x%x Row:0x%x Column:0x%x Bank:0x%x BankGroup:0x%x\",\n\t\t\t overflow ? \" OVERFLOW\" : \"\",\n\t\t\t (uncorrected_error && recoverable) ? \" recoverable\" : \"\",\n\t\t\t mscod, errcode,\n\t\t\t res->socket, res->imc, res->rank,\n\t\t\t res->row, res->column, res->bank_address, res->bank_group);\n\t}\n\n\tif (skx_show_retry_rd_err_log)\n\t\tskx_show_retry_rd_err_log(res, skx_msg + len, MSG_SIZE - len, scrub_err);\n\n\tedac_dbg(0, \"%s\\n\", skx_msg);\n\n\t \n\tedac_mc_handle_error(tp_event, mci, core_err_cnt,\n\t\t\t     m->addr >> PAGE_SHIFT, m->addr & ~PAGE_MASK, 0,\n\t\t\t     res->channel, res->dimm, -1,\n\t\t\t     optype, skx_msg);\n}\n\nstatic bool skx_error_in_1st_level_mem(const struct mce *m)\n{\n\tu32 errcode;\n\n\tif (!skx_mem_cfg_2lm)\n\t\treturn false;\n\n\terrcode = GET_BITFIELD(m->status, 0, 15) & MCACOD_MEM_ERR_MASK;\n\n\treturn errcode == MCACOD_EXT_MEM_ERR;\n}\n\nstatic bool skx_error_in_mem(const struct mce *m)\n{\n\tu32 errcode;\n\n\terrcode = GET_BITFIELD(m->status, 0, 15) & MCACOD_MEM_ERR_MASK;\n\n\treturn (errcode == MCACOD_MEM_CTL_ERR || errcode == MCACOD_EXT_MEM_ERR);\n}\n\nint skx_mce_check_error(struct notifier_block *nb, unsigned long val,\n\t\t\tvoid *data)\n{\n\tstruct mce *mce = (struct mce *)data;\n\tstruct decoded_addr res;\n\tstruct mem_ctl_info *mci;\n\tchar *type;\n\n\tif (mce->kflags & MCE_HANDLED_CEC)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (!skx_error_in_mem(mce) || !(mce->status & MCI_STATUS_ADDRV))\n\t\treturn NOTIFY_DONE;\n\n\tmemset(&res, 0, sizeof(res));\n\tres.mce  = mce;\n\tres.addr = mce->addr & MCI_ADDR_PHYSADDR;\n\n\t \n\tif (!(driver_decode && driver_decode(&res))) {\n\t\t \n\t\tif (!(adxl_component_count && skx_adxl_decode(&res, skx_error_in_1st_level_mem(mce))))\n\t\t\treturn NOTIFY_DONE;\n\t}\n\n\tmci = res.dev->imc[res.imc].mci;\n\n\tif (!mci)\n\t\treturn NOTIFY_DONE;\n\n\tif (mce->mcgstatus & MCG_STATUS_MCIP)\n\t\ttype = \"Exception\";\n\telse\n\t\ttype = \"Event\";\n\n\tskx_mc_printk(mci, KERN_DEBUG, \"HANDLING MCE MEMORY ERROR\\n\");\n\n\tskx_mc_printk(mci, KERN_DEBUG, \"CPU %d: Machine Check %s: 0x%llx \"\n\t\t\t   \"Bank %d: 0x%llx\\n\", mce->extcpu, type,\n\t\t\t   mce->mcgstatus, mce->bank, mce->status);\n\tskx_mc_printk(mci, KERN_DEBUG, \"TSC 0x%llx \", mce->tsc);\n\tskx_mc_printk(mci, KERN_DEBUG, \"ADDR 0x%llx \", mce->addr);\n\tskx_mc_printk(mci, KERN_DEBUG, \"MISC 0x%llx \", mce->misc);\n\n\tskx_mc_printk(mci, KERN_DEBUG, \"PROCESSOR %u:0x%x TIME %llu SOCKET \"\n\t\t\t   \"%u APIC 0x%x\\n\", mce->cpuvendor, mce->cpuid,\n\t\t\t   mce->time, mce->socketid, mce->apicid);\n\n\tskx_mce_output_error(mci, mce, &res);\n\n\tmce->kflags |= MCE_HANDLED_EDAC;\n\treturn NOTIFY_DONE;\n}\n\nvoid skx_remove(void)\n{\n\tint i, j;\n\tstruct skx_dev *d, *tmp;\n\n\tedac_dbg(0, \"\\n\");\n\n\tlist_for_each_entry_safe(d, tmp, &dev_edac_list, list) {\n\t\tlist_del(&d->list);\n\t\tfor (i = 0; i < NUM_IMC; i++) {\n\t\t\tif (d->imc[i].mci)\n\t\t\t\tskx_unregister_mci(&d->imc[i]);\n\n\t\t\tif (d->imc[i].mdev)\n\t\t\t\tpci_dev_put(d->imc[i].mdev);\n\n\t\t\tif (d->imc[i].mbase)\n\t\t\t\tiounmap(d->imc[i].mbase);\n\n\t\t\tfor (j = 0; j < NUM_CHANNELS; j++) {\n\t\t\t\tif (d->imc[i].chan[j].cdev)\n\t\t\t\t\tpci_dev_put(d->imc[i].chan[j].cdev);\n\t\t\t}\n\t\t}\n\t\tif (d->util_all)\n\t\t\tpci_dev_put(d->util_all);\n\t\tif (d->pcu_cr3)\n\t\t\tpci_dev_put(d->pcu_cr3);\n\t\tif (d->sad_all)\n\t\t\tpci_dev_put(d->sad_all);\n\t\tif (d->uracu)\n\t\t\tpci_dev_put(d->uracu);\n\n\t\tkfree(d);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}