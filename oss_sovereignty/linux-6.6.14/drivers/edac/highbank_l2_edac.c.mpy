{
  "module_name": "highbank_l2_edac.c",
  "hash_id": "26bef89ea72e10f13dd5e15ab439637144feeefe1c4023e1ca20467d4a269a57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/highbank_l2_edac.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/edac.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n\n#include \"edac_module.h\"\n\n#define SR_CLR_SB_ECC_INTR\t0x0\n#define SR_CLR_DB_ECC_INTR\t0x4\n\nstruct hb_l2_drvdata {\n\tvoid __iomem *base;\n\tint sb_irq;\n\tint db_irq;\n};\n\nstatic irqreturn_t highbank_l2_err_handler(int irq, void *dev_id)\n{\n\tstruct edac_device_ctl_info *dci = dev_id;\n\tstruct hb_l2_drvdata *drvdata = dci->pvt_info;\n\n\tif (irq == drvdata->sb_irq) {\n\t\twritel(1, drvdata->base + SR_CLR_SB_ECC_INTR);\n\t\tedac_device_handle_ce(dci, 0, 0, dci->ctl_name);\n\t}\n\tif (irq == drvdata->db_irq) {\n\t\twritel(1, drvdata->base + SR_CLR_DB_ECC_INTR);\n\t\tedac_device_handle_ue(dci, 0, 0, dci->ctl_name);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id hb_l2_err_of_match[] = {\n\t{ .compatible = \"calxeda,hb-sregs-l2-ecc\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hb_l2_err_of_match);\n\nstatic int highbank_l2_err_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *id;\n\tstruct edac_device_ctl_info *dci;\n\tstruct hb_l2_drvdata *drvdata;\n\tstruct resource *r;\n\tint res = 0;\n\n\tdci = edac_device_alloc_ctl_info(sizeof(*drvdata), \"cpu\",\n\t\t1, \"L\", 1, 2, NULL, 0, 0);\n\tif (!dci)\n\t\treturn -ENOMEM;\n\n\tdrvdata = dci->pvt_info;\n\tdci->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, dci);\n\n\tif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"Unable to get mem resource\\n\");\n\t\tres = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif (!devm_request_mem_region(&pdev->dev, r->start,\n\t\t\t\t     resource_size(r), dev_name(&pdev->dev))) {\n\t\tdev_err(&pdev->dev, \"Error while requesting mem region\\n\");\n\t\tres = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tdrvdata->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!drvdata->base) {\n\t\tdev_err(&pdev->dev, \"Unable to map regs\\n\");\n\t\tres = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tid = of_match_device(hb_l2_err_of_match, &pdev->dev);\n\tdci->mod_name = pdev->dev.driver->name;\n\tdci->ctl_name = id ? id->compatible : \"unknown\";\n\tdci->dev_name = dev_name(&pdev->dev);\n\n\tif (edac_device_add_device(dci))\n\t\tgoto err;\n\n\tdrvdata->db_irq = platform_get_irq(pdev, 0);\n\tres = devm_request_irq(&pdev->dev, drvdata->db_irq,\n\t\t\t       highbank_l2_err_handler,\n\t\t\t       0, dev_name(&pdev->dev), dci);\n\tif (res < 0)\n\t\tgoto err2;\n\n\tdrvdata->sb_irq = platform_get_irq(pdev, 1);\n\tres = devm_request_irq(&pdev->dev, drvdata->sb_irq,\n\t\t\t       highbank_l2_err_handler,\n\t\t\t       0, dev_name(&pdev->dev), dci);\n\tif (res < 0)\n\t\tgoto err2;\n\n\tdevres_close_group(&pdev->dev, NULL);\n\treturn 0;\nerr2:\n\tedac_device_del_device(&pdev->dev);\nerr:\n\tdevres_release_group(&pdev->dev, NULL);\n\tedac_device_free_ctl_info(dci);\n\treturn res;\n}\n\nstatic int highbank_l2_err_remove(struct platform_device *pdev)\n{\n\tstruct edac_device_ctl_info *dci = platform_get_drvdata(pdev);\n\n\tedac_device_del_device(&pdev->dev);\n\tedac_device_free_ctl_info(dci);\n\treturn 0;\n}\n\nstatic struct platform_driver highbank_l2_edac_driver = {\n\t.probe = highbank_l2_err_probe,\n\t.remove = highbank_l2_err_remove,\n\t.driver = {\n\t\t.name = \"hb_l2_edac\",\n\t\t.of_match_table = hb_l2_err_of_match,\n\t},\n};\n\nmodule_platform_driver(highbank_l2_edac_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Calxeda, Inc.\");\nMODULE_DESCRIPTION(\"EDAC Driver for Calxeda Highbank L2 Cache\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}