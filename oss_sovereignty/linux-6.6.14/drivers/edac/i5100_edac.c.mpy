{
  "module_name": "i5100_edac.c",
  "hash_id": "b0bd4c77763c6d647f5a1b359f59535207393b4c2a20e41ed80f40e0f7edc049",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i5100_edac.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include <linux/delay.h>\n#include <linux/mmzone.h>\n#include <linux/debugfs.h>\n\n#include \"edac_module.h\"\n\n \n\n \n#define I5100_MC\t\t0x40\t \n#define \tI5100_MC_SCRBEN_MASK\t(1 << 7)\n#define \tI5100_MC_SCRBDONE_MASK\t(1 << 4)\n#define I5100_MS\t\t0x44\t \n#define I5100_SPDDATA\t\t0x48\t \n#define I5100_SPDCMD\t\t0x4c\t \n#define I5100_TOLM\t\t0x6c\t \n#define I5100_MIR0\t\t0x80\t \n#define I5100_MIR1\t\t0x84\t \n#define I5100_AMIR_0\t\t0x8c\t \n#define I5100_AMIR_1\t\t0x90\t \n#define I5100_FERR_NF_MEM\t0xa0\t \n#define\t\tI5100_FERR_NF_MEM_M16ERR_MASK\t(1 << 16)\n#define\t\tI5100_FERR_NF_MEM_M15ERR_MASK\t(1 << 15)\n#define\t\tI5100_FERR_NF_MEM_M14ERR_MASK\t(1 << 14)\n#define\t\tI5100_FERR_NF_MEM_M12ERR_MASK\t(1 << 12)\n#define\t\tI5100_FERR_NF_MEM_M11ERR_MASK\t(1 << 11)\n#define\t\tI5100_FERR_NF_MEM_M10ERR_MASK\t(1 << 10)\n#define\t\tI5100_FERR_NF_MEM_M6ERR_MASK\t(1 << 6)\n#define\t\tI5100_FERR_NF_MEM_M5ERR_MASK\t(1 << 5)\n#define\t\tI5100_FERR_NF_MEM_M4ERR_MASK\t(1 << 4)\n#define\t\tI5100_FERR_NF_MEM_M1ERR_MASK\t(1 << 1)\n#define\t\tI5100_FERR_NF_MEM_ANY_MASK\t\\\n\t\t\t(I5100_FERR_NF_MEM_M16ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M15ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M14ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M12ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M11ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M10ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M6ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M5ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M4ERR_MASK | \\\n\t\t\tI5100_FERR_NF_MEM_M1ERR_MASK)\n#define\tI5100_NERR_NF_MEM\t0xa4\t \n#define I5100_EMASK_MEM\t\t0xa8\t \n#define I5100_MEM0EINJMSK0\t0x200\t \n#define I5100_MEM1EINJMSK0\t0x208\t \n#define\t\tI5100_MEMXEINJMSK0_EINJEN\t(1 << 27)\n#define I5100_MEM0EINJMSK1\t0x204\t \n#define I5100_MEM1EINJMSK1\t0x206\t \n\n \n#define I5100_DINJ0 0x9a\n\n \n#define I5100_MTR_0\t0x154\t \n#define I5100_DMIR\t0x15c\t \n#define\tI5100_VALIDLOG\t0x18c\t \n#define\tI5100_NRECMEMA\t0x190\t \n#define\tI5100_NRECMEMB\t0x194\t \n#define\tI5100_REDMEMA\t0x198\t \n#define\tI5100_REDMEMB\t0x19c\t \n#define\tI5100_RECMEMA\t0x1a0\t \n#define\tI5100_RECMEMB\t0x1a4\t \n#define I5100_MTR_4\t0x1b0\t \n\n \n\nstatic inline u32 i5100_mc_scrben(u32 mc)\n{\n\treturn mc >> 7 & 1;\n}\n\nstatic inline u32 i5100_mc_errdeten(u32 mc)\n{\n\treturn mc >> 5 & 1;\n}\n\nstatic inline u32 i5100_mc_scrbdone(u32 mc)\n{\n\treturn mc >> 4 & 1;\n}\n\nstatic inline u16 i5100_spddata_rdo(u16 a)\n{\n\treturn a >> 15 & 1;\n}\n\nstatic inline u16 i5100_spddata_sbe(u16 a)\n{\n\treturn a >> 13 & 1;\n}\n\nstatic inline u16 i5100_spddata_busy(u16 a)\n{\n\treturn a >> 12 & 1;\n}\n\nstatic inline u16 i5100_spddata_data(u16 a)\n{\n\treturn a & ((1 << 8) - 1);\n}\n\nstatic inline u32 i5100_spdcmd_create(u32 dti, u32 ckovrd, u32 sa, u32 ba,\n\t\t\t\t      u32 data, u32 cmd)\n{\n\treturn\t((dti & ((1 << 4) - 1))  << 28) |\n\t\t((ckovrd & 1)            << 27) |\n\t\t((sa & ((1 << 3) - 1))   << 24) |\n\t\t((ba & ((1 << 8) - 1))   << 16) |\n\t\t((data & ((1 << 8) - 1)) <<  8) |\n\t\t(cmd & 1);\n}\n\nstatic inline u16 i5100_tolm_tolm(u16 a)\n{\n\treturn a >> 12 & ((1 << 4) - 1);\n}\n\nstatic inline u16 i5100_mir_limit(u16 a)\n{\n\treturn a >> 4 & ((1 << 12) - 1);\n}\n\nstatic inline u16 i5100_mir_way1(u16 a)\n{\n\treturn a >> 1 & 1;\n}\n\nstatic inline u16 i5100_mir_way0(u16 a)\n{\n\treturn a & 1;\n}\n\nstatic inline u32 i5100_ferr_nf_mem_chan_indx(u32 a)\n{\n\treturn a >> 28 & 1;\n}\n\nstatic inline u32 i5100_ferr_nf_mem_any(u32 a)\n{\n\treturn a & I5100_FERR_NF_MEM_ANY_MASK;\n}\n\nstatic inline u32 i5100_nerr_nf_mem_any(u32 a)\n{\n\treturn i5100_ferr_nf_mem_any(a);\n}\n\nstatic inline u32 i5100_dmir_limit(u32 a)\n{\n\treturn a >> 16 & ((1 << 11) - 1);\n}\n\nstatic inline u32 i5100_dmir_rank(u32 a, u32 i)\n{\n\treturn a >> (4 * i) & ((1 << 2) - 1);\n}\n\nstatic inline u16 i5100_mtr_present(u16 a)\n{\n\treturn a >> 10 & 1;\n}\n\nstatic inline u16 i5100_mtr_ethrottle(u16 a)\n{\n\treturn a >> 9 & 1;\n}\n\nstatic inline u16 i5100_mtr_width(u16 a)\n{\n\treturn a >> 8 & 1;\n}\n\nstatic inline u16 i5100_mtr_numbank(u16 a)\n{\n\treturn a >> 6 & 1;\n}\n\nstatic inline u16 i5100_mtr_numrow(u16 a)\n{\n\treturn a >> 2 & ((1 << 2) - 1);\n}\n\nstatic inline u16 i5100_mtr_numcol(u16 a)\n{\n\treturn a & ((1 << 2) - 1);\n}\n\n\nstatic inline u32 i5100_validlog_redmemvalid(u32 a)\n{\n\treturn a >> 2 & 1;\n}\n\nstatic inline u32 i5100_validlog_recmemvalid(u32 a)\n{\n\treturn a >> 1 & 1;\n}\n\nstatic inline u32 i5100_validlog_nrecmemvalid(u32 a)\n{\n\treturn a & 1;\n}\n\nstatic inline u32 i5100_nrecmema_merr(u32 a)\n{\n\treturn a >> 15 & ((1 << 5) - 1);\n}\n\nstatic inline u32 i5100_nrecmema_bank(u32 a)\n{\n\treturn a >> 12 & ((1 << 3) - 1);\n}\n\nstatic inline u32 i5100_nrecmema_rank(u32 a)\n{\n\treturn a >>  8 & ((1 << 3) - 1);\n}\n\nstatic inline u32 i5100_nrecmemb_cas(u32 a)\n{\n\treturn a >> 16 & ((1 << 13) - 1);\n}\n\nstatic inline u32 i5100_nrecmemb_ras(u32 a)\n{\n\treturn a & ((1 << 16) - 1);\n}\n\nstatic inline u32 i5100_recmema_merr(u32 a)\n{\n\treturn i5100_nrecmema_merr(a);\n}\n\nstatic inline u32 i5100_recmema_bank(u32 a)\n{\n\treturn i5100_nrecmema_bank(a);\n}\n\nstatic inline u32 i5100_recmema_rank(u32 a)\n{\n\treturn i5100_nrecmema_rank(a);\n}\n\nstatic inline u32 i5100_recmemb_cas(u32 a)\n{\n\treturn i5100_nrecmemb_cas(a);\n}\n\nstatic inline u32 i5100_recmemb_ras(u32 a)\n{\n\treturn i5100_nrecmemb_ras(a);\n}\n\n \n#define I5100_MAX_RANKS_PER_CHAN\t6\n#define I5100_CHANNELS\t\t\t    2\n#define I5100_MAX_RANKS_PER_DIMM\t4\n#define I5100_DIMM_ADDR_LINES\t\t(6 - 3)\t \n#define I5100_MAX_DIMM_SLOTS_PER_CHAN\t4\n#define I5100_MAX_RANK_INTERLEAVE\t4\n#define I5100_MAX_DMIRS\t\t\t5\n#define I5100_SCRUB_REFRESH_RATE\t(5 * 60 * HZ)\n\nstruct i5100_priv {\n\t \n\tint dimm_numrank[I5100_CHANNELS][I5100_MAX_DIMM_SLOTS_PER_CHAN];\n\n\t \n\tint dimm_csmap[I5100_MAX_DIMM_SLOTS_PER_CHAN][I5100_MAX_RANKS_PER_DIMM];\n\n\t \n\tstruct {\n\t\tu64\t limit;\n\t\tunsigned way[2];\n\t} mir[I5100_CHANNELS];\n\n\t \n\tunsigned amir[I5100_CHANNELS];\n\n\t \n\tstruct {\n\t\tunsigned rank[I5100_MAX_RANK_INTERLEAVE];\n\t\tu64\t limit;\n\t} dmir[I5100_CHANNELS][I5100_MAX_DMIRS];\n\n\t \n\tstruct {\n\t\tunsigned present;\t \n\t\tunsigned ethrottle;\t \n\t\tunsigned width;\t\t \n\t\tunsigned numbank;\t \n\t\tunsigned numrow;\t \n\t\tunsigned numcol;\t \n\t} mtr[I5100_CHANNELS][I5100_MAX_RANKS_PER_CHAN];\n\n\tu64 tolm;\t\t \n\tunsigned ranksperchan;\t \n\n\tstruct pci_dev *mc;\t \n\tstruct pci_dev *einj;\t \n\tstruct pci_dev *ch0mm;\t \n\tstruct pci_dev *ch1mm;\t \n\n\tstruct delayed_work i5100_scrubbing;\n\tint scrub_enable;\n\n\t \n\tu8 inject_channel;\n\tu8 inject_hlinesel;\n\tu8 inject_deviceptr1;\n\tu8 inject_deviceptr2;\n\tu16 inject_eccmask1;\n\tu16 inject_eccmask2;\n\n\tstruct dentry *debugfs;\n};\n\nstatic struct dentry *i5100_debugfs;\n\n \nstatic int i5100_rank_to_slot(const struct mem_ctl_info *mci,\n\t\t\t      int chan, int rank)\n{\n\tconst struct i5100_priv *priv = mci->pvt_info;\n\tint i;\n\n\tfor (i = 0; i < I5100_MAX_DIMM_SLOTS_PER_CHAN; i++) {\n\t\tint j;\n\t\tconst int numrank = priv->dimm_numrank[chan][i];\n\n\t\tfor (j = 0; j < numrank; j++)\n\t\t\tif (priv->dimm_csmap[i][j] == rank)\n\t\t\t\treturn i * 2 + chan;\n\t}\n\n\treturn -1;\n}\n\nstatic const char *i5100_err_msg(unsigned err)\n{\n\tstatic const char *merrs[] = {\n\t\t\"unknown\",  \n\t\t\"uncorrectable data ECC on replay\",  \n\t\t\"unknown\",  \n\t\t\"unknown\",  \n\t\t\"aliased uncorrectable demand data ECC\",  \n\t\t\"aliased uncorrectable spare-copy data ECC\",  \n\t\t\"aliased uncorrectable patrol data ECC\",  \n\t\t\"unknown\",  \n\t\t\"unknown\",  \n\t\t\"unknown\",  \n\t\t\"non-aliased uncorrectable demand data ECC\",  \n\t\t\"non-aliased uncorrectable spare-copy data ECC\",  \n\t\t\"non-aliased uncorrectable patrol data ECC\",  \n\t\t\"unknown\",  \n\t\t\"correctable demand data ECC\",  \n\t\t\"correctable spare-copy data ECC\",  \n\t\t\"correctable patrol data ECC\",  \n\t\t\"unknown\",  \n\t\t\"SPD protocol error\",  \n\t\t\"unknown\",  \n\t\t\"spare copy initiated\",  \n\t\t\"spare copy completed\",  \n\t};\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(merrs); i++)\n\t\tif (1 << i & err)\n\t\t\treturn merrs[i];\n\n\treturn \"none\";\n}\n\n \nstatic unsigned int i5100_csrow_to_rank(const struct mem_ctl_info *mci,\n\t\t\t\t\tunsigned int csrow)\n{\n\tconst struct i5100_priv *priv = mci->pvt_info;\n\n\treturn csrow % priv->ranksperchan;\n}\n\n \nstatic unsigned int i5100_csrow_to_chan(const struct mem_ctl_info *mci,\n\t\t\t\t\tunsigned int csrow)\n{\n\tconst struct i5100_priv *priv = mci->pvt_info;\n\n\treturn csrow / priv->ranksperchan;\n}\n\nstatic void i5100_handle_ce(struct mem_ctl_info *mci,\n\t\t\t    int chan,\n\t\t\t    unsigned bank,\n\t\t\t    unsigned rank,\n\t\t\t    unsigned long syndrome,\n\t\t\t    unsigned cas,\n\t\t\t    unsigned ras,\n\t\t\t    const char *msg)\n{\n\tchar detail[80];\n\n\t \n\tsnprintf(detail, sizeof(detail),\n\t\t \"bank %u, cas %u, ras %u\\n\",\n\t\t bank, cas, ras);\n\n\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t     0, 0, syndrome,\n\t\t\t     chan, rank, -1,\n\t\t\t     msg, detail);\n}\n\nstatic void i5100_handle_ue(struct mem_ctl_info *mci,\n\t\t\t    int chan,\n\t\t\t    unsigned bank,\n\t\t\t    unsigned rank,\n\t\t\t    unsigned long syndrome,\n\t\t\t    unsigned cas,\n\t\t\t    unsigned ras,\n\t\t\t    const char *msg)\n{\n\tchar detail[80];\n\n\t \n\tsnprintf(detail, sizeof(detail),\n\t\t \"bank %u, cas %u, ras %u\\n\",\n\t\t bank, cas, ras);\n\n\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t     0, 0, syndrome,\n\t\t\t     chan, rank, -1,\n\t\t\t     msg, detail);\n}\n\nstatic void i5100_read_log(struct mem_ctl_info *mci, int chan,\n\t\t\t   u32 ferr, u32 nerr)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tstruct pci_dev *pdev = (chan) ? priv->ch1mm : priv->ch0mm;\n\tu32 dw;\n\tu32 dw2;\n\tunsigned syndrome = 0;\n\tunsigned merr;\n\tunsigned bank;\n\tunsigned rank;\n\tunsigned cas;\n\tunsigned ras;\n\n\tpci_read_config_dword(pdev, I5100_VALIDLOG, &dw);\n\n\tif (i5100_validlog_redmemvalid(dw)) {\n\t\tpci_read_config_dword(pdev, I5100_REDMEMA, &dw2);\n\t\tsyndrome = dw2;\n\t\tpci_read_config_dword(pdev, I5100_REDMEMB, &dw2);\n\t}\n\n\tif (i5100_validlog_recmemvalid(dw)) {\n\t\tconst char *msg;\n\n\t\tpci_read_config_dword(pdev, I5100_RECMEMA, &dw2);\n\t\tmerr = i5100_recmema_merr(dw2);\n\t\tbank = i5100_recmema_bank(dw2);\n\t\trank = i5100_recmema_rank(dw2);\n\n\t\tpci_read_config_dword(pdev, I5100_RECMEMB, &dw2);\n\t\tcas = i5100_recmemb_cas(dw2);\n\t\tras = i5100_recmemb_ras(dw2);\n\n\t\t \n\t\tif (!merr)\n\t\t\tmsg = i5100_err_msg(ferr);\n\t\telse\n\t\t\tmsg = i5100_err_msg(nerr);\n\n\t\ti5100_handle_ce(mci, chan, bank, rank, syndrome, cas, ras, msg);\n\t}\n\n\tif (i5100_validlog_nrecmemvalid(dw)) {\n\t\tconst char *msg;\n\n\t\tpci_read_config_dword(pdev, I5100_NRECMEMA, &dw2);\n\t\tmerr = i5100_nrecmema_merr(dw2);\n\t\tbank = i5100_nrecmema_bank(dw2);\n\t\trank = i5100_nrecmema_rank(dw2);\n\n\t\tpci_read_config_dword(pdev, I5100_NRECMEMB, &dw2);\n\t\tcas = i5100_nrecmemb_cas(dw2);\n\t\tras = i5100_nrecmemb_ras(dw2);\n\n\t\t \n\t\tif (!merr)\n\t\t\tmsg = i5100_err_msg(ferr);\n\t\telse\n\t\t\tmsg = i5100_err_msg(nerr);\n\n\t\ti5100_handle_ue(mci, chan, bank, rank, syndrome, cas, ras, msg);\n\t}\n\n\tpci_write_config_dword(pdev, I5100_VALIDLOG, dw);\n}\n\nstatic void i5100_check_error(struct mem_ctl_info *mci)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tu32 dw, dw2;\n\n\tpci_read_config_dword(priv->mc, I5100_FERR_NF_MEM, &dw);\n\tif (i5100_ferr_nf_mem_any(dw)) {\n\n\t\tpci_read_config_dword(priv->mc, I5100_NERR_NF_MEM, &dw2);\n\n\t\ti5100_read_log(mci, i5100_ferr_nf_mem_chan_indx(dw),\n\t\t\t       i5100_ferr_nf_mem_any(dw),\n\t\t\t       i5100_nerr_nf_mem_any(dw2));\n\n\t\tpci_write_config_dword(priv->mc, I5100_NERR_NF_MEM, dw2);\n\t}\n\tpci_write_config_dword(priv->mc, I5100_FERR_NF_MEM, dw);\n}\n\n \n\nstatic void i5100_refresh_scrubbing(struct work_struct *work)\n{\n\tstruct delayed_work *i5100_scrubbing = to_delayed_work(work);\n\tstruct i5100_priv *priv = container_of(i5100_scrubbing,\n\t\t\t\t\t       struct i5100_priv,\n\t\t\t\t\t       i5100_scrubbing);\n\tu32 dw;\n\n\tpci_read_config_dword(priv->mc, I5100_MC, &dw);\n\n\tif (priv->scrub_enable) {\n\n\t\tpci_read_config_dword(priv->mc, I5100_MC, &dw);\n\n\t\tif (i5100_mc_scrbdone(dw)) {\n\t\t\tdw |= I5100_MC_SCRBEN_MASK;\n\t\t\tpci_write_config_dword(priv->mc, I5100_MC, dw);\n\t\t\tpci_read_config_dword(priv->mc, I5100_MC, &dw);\n\t\t}\n\n\t\tschedule_delayed_work(&(priv->i5100_scrubbing),\n\t\t\t\t      I5100_SCRUB_REFRESH_RATE);\n\t}\n}\n \nstatic int i5100_set_scrub_rate(struct mem_ctl_info *mci, u32 bandwidth)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tu32 dw;\n\n\tpci_read_config_dword(priv->mc, I5100_MC, &dw);\n\tif (bandwidth) {\n\t\tpriv->scrub_enable = 1;\n\t\tdw |= I5100_MC_SCRBEN_MASK;\n\t\tschedule_delayed_work(&(priv->i5100_scrubbing),\n\t\t\t\t      I5100_SCRUB_REFRESH_RATE);\n\t} else {\n\t\tpriv->scrub_enable = 0;\n\t\tdw &= ~I5100_MC_SCRBEN_MASK;\n\t\tcancel_delayed_work(&(priv->i5100_scrubbing));\n\t}\n\tpci_write_config_dword(priv->mc, I5100_MC, dw);\n\n\tpci_read_config_dword(priv->mc, I5100_MC, &dw);\n\n\tbandwidth = 5900000 * i5100_mc_scrben(dw);\n\n\treturn bandwidth;\n}\n\nstatic int i5100_get_scrub_rate(struct mem_ctl_info *mci)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tu32 dw;\n\n\tpci_read_config_dword(priv->mc, I5100_MC, &dw);\n\n\treturn 5900000 * i5100_mc_scrben(dw);\n}\n\nstatic struct pci_dev *pci_get_device_func(unsigned vendor,\n\t\t\t\t\t   unsigned device,\n\t\t\t\t\t   unsigned func)\n{\n\tstruct pci_dev *ret = NULL;\n\n\twhile (1) {\n\t\tret = pci_get_device(vendor, device, ret);\n\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tif (PCI_FUNC(ret->devfn) == func)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned long i5100_npages(struct mem_ctl_info *mci, unsigned int csrow)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tconst unsigned int chan_rank = i5100_csrow_to_rank(mci, csrow);\n\tconst unsigned int chan = i5100_csrow_to_chan(mci, csrow);\n\tunsigned addr_lines;\n\n\t \n\tif (!priv->mtr[chan][chan_rank].present)\n\t\treturn 0ULL;\n\n\taddr_lines =\n\t\tI5100_DIMM_ADDR_LINES +\n\t\tpriv->mtr[chan][chan_rank].numcol +\n\t\tpriv->mtr[chan][chan_rank].numrow +\n\t\tpriv->mtr[chan][chan_rank].numbank;\n\n\treturn (unsigned long)\n\t\t((unsigned long long) (1ULL << addr_lines) / PAGE_SIZE);\n}\n\nstatic void i5100_init_mtr(struct mem_ctl_info *mci)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tstruct pci_dev *mms[2] = { priv->ch0mm, priv->ch1mm };\n\tint i;\n\n\tfor (i = 0; i < I5100_CHANNELS; i++) {\n\t\tint j;\n\t\tstruct pci_dev *pdev = mms[i];\n\n\t\tfor (j = 0; j < I5100_MAX_RANKS_PER_CHAN; j++) {\n\t\t\tconst unsigned addr =\n\t\t\t\t(j < 4) ? I5100_MTR_0 + j * 2 :\n\t\t\t\t\t  I5100_MTR_4 + (j - 4) * 2;\n\t\t\tu16 w;\n\n\t\t\tpci_read_config_word(pdev, addr, &w);\n\n\t\t\tpriv->mtr[i][j].present = i5100_mtr_present(w);\n\t\t\tpriv->mtr[i][j].ethrottle = i5100_mtr_ethrottle(w);\n\t\t\tpriv->mtr[i][j].width = 4 + 4 * i5100_mtr_width(w);\n\t\t\tpriv->mtr[i][j].numbank = 2 + i5100_mtr_numbank(w);\n\t\t\tpriv->mtr[i][j].numrow = 13 + i5100_mtr_numrow(w);\n\t\t\tpriv->mtr[i][j].numcol = 10 + i5100_mtr_numcol(w);\n\t\t}\n\t}\n}\n\n \nstatic int i5100_read_spd_byte(const struct mem_ctl_info *mci,\n\t\t\t       u8 ch, u8 slot, u8 addr, u8 *byte)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tu16 w;\n\n\tpci_read_config_word(priv->mc, I5100_SPDDATA, &w);\n\tif (i5100_spddata_busy(w))\n\t\treturn -1;\n\n\tpci_write_config_dword(priv->mc, I5100_SPDCMD,\n\t\t\t       i5100_spdcmd_create(0xa, 1, ch * 4 + slot, addr,\n\t\t\t\t\t\t   0, 0));\n\n\t \n\tudelay(100);\n\twhile (1) {\n\t\tpci_read_config_word(priv->mc, I5100_SPDDATA, &w);\n\t\tif (!i5100_spddata_busy(w))\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\tif (!i5100_spddata_rdo(w) || i5100_spddata_sbe(w))\n\t\treturn -1;\n\n\t*byte = i5100_spddata_data(w);\n\n\treturn 0;\n}\n\n \nstatic void i5100_init_dimm_csmap(struct mem_ctl_info *mci)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tint i;\n\n\tfor (i = 0; i < I5100_MAX_DIMM_SLOTS_PER_CHAN; i++) {\n\t\tint j;\n\n\t\tfor (j = 0; j < I5100_MAX_RANKS_PER_DIMM; j++)\n\t\t\tpriv->dimm_csmap[i][j] = -1;  \n\t}\n\n\t \n\tif (priv->ranksperchan == 4) {\n\t\tpriv->dimm_csmap[0][0] = 0;\n\t\tpriv->dimm_csmap[0][1] = 3;\n\t\tpriv->dimm_csmap[1][0] = 1;\n\t\tpriv->dimm_csmap[1][1] = 2;\n\t\tpriv->dimm_csmap[2][0] = 2;\n\t\tpriv->dimm_csmap[3][0] = 3;\n\t} else {\n\t\tpriv->dimm_csmap[0][0] = 0;\n\t\tpriv->dimm_csmap[0][1] = 1;\n\t\tpriv->dimm_csmap[1][0] = 2;\n\t\tpriv->dimm_csmap[1][1] = 3;\n\t\tpriv->dimm_csmap[2][0] = 4;\n\t\tpriv->dimm_csmap[2][1] = 5;\n\t}\n}\n\nstatic void i5100_init_dimm_layout(struct pci_dev *pdev,\n\t\t\t\t   struct mem_ctl_info *mci)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tint i;\n\n\tfor (i = 0; i < I5100_CHANNELS; i++) {\n\t\tint j;\n\n\t\tfor (j = 0; j < I5100_MAX_DIMM_SLOTS_PER_CHAN; j++) {\n\t\t\tu8 rank;\n\n\t\t\tif (i5100_read_spd_byte(mci, i, j, 5, &rank) < 0)\n\t\t\t\tpriv->dimm_numrank[i][j] = 0;\n\t\t\telse\n\t\t\t\tpriv->dimm_numrank[i][j] = (rank & 3) + 1;\n\t\t}\n\t}\n\n\ti5100_init_dimm_csmap(mci);\n}\n\nstatic void i5100_init_interleaving(struct pci_dev *pdev,\n\t\t\t\t    struct mem_ctl_info *mci)\n{\n\tu16 w;\n\tu32 dw;\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tstruct pci_dev *mms[2] = { priv->ch0mm, priv->ch1mm };\n\tint i;\n\n\tpci_read_config_word(pdev, I5100_TOLM, &w);\n\tpriv->tolm = (u64) i5100_tolm_tolm(w) * 256 * 1024 * 1024;\n\n\tpci_read_config_word(pdev, I5100_MIR0, &w);\n\tpriv->mir[0].limit = (u64) i5100_mir_limit(w) << 28;\n\tpriv->mir[0].way[1] = i5100_mir_way1(w);\n\tpriv->mir[0].way[0] = i5100_mir_way0(w);\n\n\tpci_read_config_word(pdev, I5100_MIR1, &w);\n\tpriv->mir[1].limit = (u64) i5100_mir_limit(w) << 28;\n\tpriv->mir[1].way[1] = i5100_mir_way1(w);\n\tpriv->mir[1].way[0] = i5100_mir_way0(w);\n\n\tpci_read_config_word(pdev, I5100_AMIR_0, &w);\n\tpriv->amir[0] = w;\n\tpci_read_config_word(pdev, I5100_AMIR_1, &w);\n\tpriv->amir[1] = w;\n\n\tfor (i = 0; i < I5100_CHANNELS; i++) {\n\t\tint j;\n\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tint k;\n\n\t\t\tpci_read_config_dword(mms[i], I5100_DMIR + j * 4, &dw);\n\n\t\t\tpriv->dmir[i][j].limit =\n\t\t\t\t(u64) i5100_dmir_limit(dw) << 28;\n\t\t\tfor (k = 0; k < I5100_MAX_RANKS_PER_DIMM; k++)\n\t\t\t\tpriv->dmir[i][j].rank[k] =\n\t\t\t\t\ti5100_dmir_rank(dw, k);\n\t\t}\n\t}\n\n\ti5100_init_mtr(mci);\n}\n\nstatic void i5100_init_csrows(struct mem_ctl_info *mci)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tstruct dimm_info *dimm;\n\n\tmci_for_each_dimm(mci, dimm) {\n\t\tconst unsigned long npages = i5100_npages(mci, dimm->idx);\n\t\tconst unsigned int chan = i5100_csrow_to_chan(mci, dimm->idx);\n\t\tconst unsigned int rank = i5100_csrow_to_rank(mci, dimm->idx);\n\n\t\tif (!npages)\n\t\t\tcontinue;\n\n\t\tdimm->nr_pages = npages;\n\t\tdimm->grain = 32;\n\t\tdimm->dtype = (priv->mtr[chan][rank].width == 4) ?\n\t\t\t\tDEV_X4 : DEV_X8;\n\t\tdimm->mtype = MEM_RDDR2;\n\t\tdimm->edac_mode = EDAC_SECDED;\n\t\tsnprintf(dimm->label, sizeof(dimm->label), \"DIMM%u\",\n\t\t\t i5100_rank_to_slot(mci, chan, rank));\n\n\t\tedac_dbg(2, \"dimm channel %d, rank %d, size %ld\\n\",\n\t\t\t chan, rank, (long)PAGES_TO_MiB(npages));\n\t}\n}\n\n \n\nstatic void i5100_do_inject(struct mem_ctl_info *mci)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\tu32 mask0;\n\tu16 mask1;\n\n\t \n\tmask0 = ((priv->inject_hlinesel & 0x3) << 28) |\n\t\tI5100_MEMXEINJMSK0_EINJEN |\n\t\t((priv->inject_eccmask1 & 0xffff) << 10) |\n\t\t((priv->inject_deviceptr2 & 0x1f) << 5) |\n\t\t(priv->inject_deviceptr1 & 0x1f);\n\n\t \n\tmask1 = priv->inject_eccmask2;\n\n\tif (priv->inject_channel == 0) {\n\t\tpci_write_config_dword(priv->mc, I5100_MEM0EINJMSK0, mask0);\n\t\tpci_write_config_word(priv->mc, I5100_MEM0EINJMSK1, mask1);\n\t} else {\n\t\tpci_write_config_dword(priv->mc, I5100_MEM1EINJMSK0, mask0);\n\t\tpci_write_config_word(priv->mc, I5100_MEM1EINJMSK1, mask1);\n\t}\n\n\t \n\tpci_write_config_byte(priv->einj, I5100_DINJ0, 0xaa);\n\tpci_write_config_byte(priv->einj, I5100_DINJ0, 0xab);\n}\n\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\nstatic ssize_t inject_enable_write(struct file *file, const char __user *data,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct device *dev = file->private_data;\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\n\ti5100_do_inject(mci);\n\n\treturn count;\n}\n\nstatic const struct file_operations i5100_inject_enable_fops = {\n\t.open = simple_open,\n\t.write = inject_enable_write,\n\t.llseek = generic_file_llseek,\n};\n\nstatic int i5100_setup_debugfs(struct mem_ctl_info *mci)\n{\n\tstruct i5100_priv *priv = mci->pvt_info;\n\n\tif (!i5100_debugfs)\n\t\treturn -ENODEV;\n\n\tpriv->debugfs = edac_debugfs_create_dir_at(mci->bus->name, i5100_debugfs);\n\n\tif (!priv->debugfs)\n\t\treturn -ENOMEM;\n\n\tedac_debugfs_create_x8(\"inject_channel\", S_IRUGO | S_IWUSR, priv->debugfs,\n\t\t\t\t&priv->inject_channel);\n\tedac_debugfs_create_x8(\"inject_hlinesel\", S_IRUGO | S_IWUSR, priv->debugfs,\n\t\t\t\t&priv->inject_hlinesel);\n\tedac_debugfs_create_x8(\"inject_deviceptr1\", S_IRUGO | S_IWUSR, priv->debugfs,\n\t\t\t\t&priv->inject_deviceptr1);\n\tedac_debugfs_create_x8(\"inject_deviceptr2\", S_IRUGO | S_IWUSR, priv->debugfs,\n\t\t\t\t&priv->inject_deviceptr2);\n\tedac_debugfs_create_x16(\"inject_eccmask1\", S_IRUGO | S_IWUSR, priv->debugfs,\n\t\t\t\t&priv->inject_eccmask1);\n\tedac_debugfs_create_x16(\"inject_eccmask2\", S_IRUGO | S_IWUSR, priv->debugfs,\n\t\t\t\t&priv->inject_eccmask2);\n\tedac_debugfs_create_file(\"inject_enable\", S_IWUSR, priv->debugfs,\n\t\t\t\t&mci->dev, &i5100_inject_enable_fops);\n\n\treturn 0;\n\n}\n\nstatic int i5100_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint rc;\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tstruct i5100_priv *priv;\n\tstruct pci_dev *ch0mm, *ch1mm, *einj;\n\tint ret = 0;\n\tu32 dw;\n\tint ranksperch;\n\n\tif (PCI_FUNC(pdev->devfn) != 1)\n\t\treturn -ENODEV;\n\n\trc = pci_enable_device(pdev);\n\tif (rc < 0) {\n\t\tret = rc;\n\t\tgoto bail;\n\t}\n\n\t \n\tpci_read_config_dword(pdev, I5100_MC, &dw);\n\tif (!i5100_mc_errdeten(dw)) {\n\t\tprintk(KERN_INFO \"i5100_edac: ECC not enabled.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto bail_pdev;\n\t}\n\n\t \n\tpci_read_config_dword(pdev, I5100_MS, &dw);\n\tranksperch = !!(dw & (1 << 8)) * 2 + 4;\n\n\t \n\tpci_read_config_dword(pdev, I5100_EMASK_MEM, &dw);\n\tdw &= ~I5100_FERR_NF_MEM_ANY_MASK;\n\tpci_write_config_dword(pdev, I5100_EMASK_MEM, dw);\n\n\t \n\tch0mm = pci_get_device_func(PCI_VENDOR_ID_INTEL,\n\t\t\t\t    PCI_DEVICE_ID_INTEL_5100_21, 0);\n\tif (!ch0mm) {\n\t\tret = -ENODEV;\n\t\tgoto bail_pdev;\n\t}\n\n\trc = pci_enable_device(ch0mm);\n\tif (rc < 0) {\n\t\tret = rc;\n\t\tgoto bail_ch0;\n\t}\n\n\t \n\tch1mm = pci_get_device_func(PCI_VENDOR_ID_INTEL,\n\t\t\t\t    PCI_DEVICE_ID_INTEL_5100_22, 0);\n\tif (!ch1mm) {\n\t\tret = -ENODEV;\n\t\tgoto bail_disable_ch0;\n\t}\n\n\trc = pci_enable_device(ch1mm);\n\tif (rc < 0) {\n\t\tret = rc;\n\t\tgoto bail_ch1;\n\t}\n\n\tlayers[0].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[0].size = 2;\n\tlayers[0].is_virt_csrow = false;\n\tlayers[1].type = EDAC_MC_LAYER_SLOT;\n\tlayers[1].size = ranksperch;\n\tlayers[1].is_virt_csrow = true;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(*priv));\n\tif (!mci) {\n\t\tret = -ENOMEM;\n\t\tgoto bail_disable_ch1;\n\t}\n\n\n\t \n\teinj = pci_get_device_func(PCI_VENDOR_ID_INTEL,\n\t\t\t\t    PCI_DEVICE_ID_INTEL_5100_19, 0);\n\tif (!einj) {\n\t\tret = -ENODEV;\n\t\tgoto bail_mc_free;\n\t}\n\n\trc = pci_enable_device(einj);\n\tif (rc < 0) {\n\t\tret = rc;\n\t\tgoto bail_einj;\n\t}\n\n\tmci->pdev = &pdev->dev;\n\n\tpriv = mci->pvt_info;\n\tpriv->ranksperchan = ranksperch;\n\tpriv->mc = pdev;\n\tpriv->ch0mm = ch0mm;\n\tpriv->ch1mm = ch1mm;\n\tpriv->einj = einj;\n\n\tINIT_DELAYED_WORK(&(priv->i5100_scrubbing), i5100_refresh_scrubbing);\n\n\t \n\tpci_read_config_dword(pdev, I5100_MC, &dw);\n\tif (i5100_mc_scrben(dw)) {\n\t\tpriv->scrub_enable = 1;\n\t\tschedule_delayed_work(&(priv->i5100_scrubbing),\n\t\t\t\t      I5100_SCRUB_REFRESH_RATE);\n\t}\n\n\ti5100_init_dimm_layout(pdev, mci);\n\ti5100_init_interleaving(pdev, mci);\n\n\tmci->mtype_cap = MEM_FLAG_FB_DDR2;\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = \"i5100_edac.c\";\n\tmci->ctl_name = \"i5100\";\n\tmci->dev_name = pci_name(pdev);\n\tmci->ctl_page_to_phys = NULL;\n\n\tmci->edac_check = i5100_check_error;\n\tmci->set_sdram_scrub_rate = i5100_set_scrub_rate;\n\tmci->get_sdram_scrub_rate = i5100_get_scrub_rate;\n\n\tpriv->inject_channel = 0;\n\tpriv->inject_hlinesel = 0;\n\tpriv->inject_deviceptr1 = 0;\n\tpriv->inject_deviceptr2 = 0;\n\tpriv->inject_eccmask1 = 0;\n\tpriv->inject_eccmask2 = 0;\n\n\ti5100_init_csrows(mci);\n\n\t \n\tswitch (edac_op_state) {\n\tcase EDAC_OPSTATE_POLL:\n\tcase EDAC_OPSTATE_NMI:\n\t\tbreak;\n\tdefault:\n\t\tedac_op_state = EDAC_OPSTATE_POLL;\n\t\tbreak;\n\t}\n\n\tif (edac_mc_add_mc(mci)) {\n\t\tret = -ENODEV;\n\t\tgoto bail_scrub;\n\t}\n\n\ti5100_setup_debugfs(mci);\n\n\treturn ret;\n\nbail_scrub:\n\tpriv->scrub_enable = 0;\n\tcancel_delayed_work_sync(&(priv->i5100_scrubbing));\n\tpci_disable_device(einj);\n\nbail_einj:\n\tpci_dev_put(einj);\n\nbail_mc_free:\n\tedac_mc_free(mci);\n\nbail_disable_ch1:\n\tpci_disable_device(ch1mm);\n\nbail_ch1:\n\tpci_dev_put(ch1mm);\n\nbail_disable_ch0:\n\tpci_disable_device(ch0mm);\n\nbail_ch0:\n\tpci_dev_put(ch0mm);\n\nbail_pdev:\n\tpci_disable_device(pdev);\n\nbail:\n\treturn ret;\n}\n\nstatic void i5100_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct i5100_priv *priv;\n\n\tmci = edac_mc_del_mc(&pdev->dev);\n\n\tif (!mci)\n\t\treturn;\n\n\tpriv = mci->pvt_info;\n\n\tedac_debugfs_remove_recursive(priv->debugfs);\n\n\tpriv->scrub_enable = 0;\n\tcancel_delayed_work_sync(&(priv->i5100_scrubbing));\n\n\tpci_disable_device(pdev);\n\tpci_disable_device(priv->ch0mm);\n\tpci_disable_device(priv->ch1mm);\n\tpci_disable_device(priv->einj);\n\tpci_dev_put(priv->ch0mm);\n\tpci_dev_put(priv->ch1mm);\n\tpci_dev_put(priv->einj);\n\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id i5100_pci_tbl[] = {\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_5100_16) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, i5100_pci_tbl);\n\nstatic struct pci_driver i5100_driver = {\n\t.name = KBUILD_BASENAME,\n\t.probe = i5100_init_one,\n\t.remove = i5100_remove_one,\n\t.id_table = i5100_pci_tbl,\n};\n\nstatic int __init i5100_init(void)\n{\n\tint pci_rc;\n\n\ti5100_debugfs = edac_debugfs_create_dir_at(\"i5100_edac\", NULL);\n\n\tpci_rc = pci_register_driver(&i5100_driver);\n\treturn (pci_rc < 0) ? pci_rc : 0;\n}\n\nstatic void __exit i5100_exit(void)\n{\n\tedac_debugfs_remove(i5100_debugfs);\n\n\tpci_unregister_driver(&i5100_driver);\n}\n\nmodule_init(i5100_init);\nmodule_exit(i5100_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arthur Jones <ajones@riverbed.com>\");\nMODULE_DESCRIPTION(\"MC Driver for Intel I5100 memory controllers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}