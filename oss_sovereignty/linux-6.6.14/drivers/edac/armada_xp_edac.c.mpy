{
  "module_name": "armada_xp_edac.c",
  "hash_id": "dffde124bd94d7ad3c3c472a4bcb6d6d989a611b8c0c1d9e9f0afab983ec6641",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/armada_xp_edac.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/edac.h>\n#include <linux/of_platform.h>\n\n#include <asm/hardware/cache-l2x0.h>\n#include <asm/hardware/cache-aurora-l2.h>\n\n#include \"edac_mc.h\"\n#include \"edac_device.h\"\n#include \"edac_module.h\"\n\n \n\n#define SDRAM_NUM_CS 4\n\n#define SDRAM_CONFIG_REG        0x0\n#define SDRAM_CONFIG_ECC_MASK         BIT(18)\n#define SDRAM_CONFIG_REGISTERED_MASK  BIT(17)\n#define SDRAM_CONFIG_BUS_WIDTH_MASK   BIT(15)\n\n#define SDRAM_ADDR_CTRL_REG     0x10\n#define SDRAM_ADDR_CTRL_SIZE_HIGH_OFFSET(cs) (20+cs)\n#define SDRAM_ADDR_CTRL_SIZE_HIGH_MASK(cs)   (0x1 << SDRAM_ADDR_CTRL_SIZE_HIGH_OFFSET(cs))\n#define SDRAM_ADDR_CTRL_ADDR_SEL_MASK(cs)    BIT(16+cs)\n#define SDRAM_ADDR_CTRL_SIZE_LOW_OFFSET(cs)  (cs*4+2)\n#define SDRAM_ADDR_CTRL_SIZE_LOW_MASK(cs)    (0x3 << SDRAM_ADDR_CTRL_SIZE_LOW_OFFSET(cs))\n#define SDRAM_ADDR_CTRL_STRUCT_OFFSET(cs)    (cs*4)\n#define SDRAM_ADDR_CTRL_STRUCT_MASK(cs)      (0x3 << SDRAM_ADDR_CTRL_STRUCT_OFFSET(cs))\n\n#define SDRAM_ERR_DATA_H_REG    0x40\n#define SDRAM_ERR_DATA_L_REG    0x44\n\n#define SDRAM_ERR_RECV_ECC_REG  0x48\n#define SDRAM_ERR_RECV_ECC_VALUE_MASK 0xff\n\n#define SDRAM_ERR_CALC_ECC_REG  0x4c\n#define SDRAM_ERR_CALC_ECC_ROW_OFFSET 8\n#define SDRAM_ERR_CALC_ECC_ROW_MASK   (0xffff << SDRAM_ERR_CALC_ECC_ROW_OFFSET)\n#define SDRAM_ERR_CALC_ECC_VALUE_MASK 0xff\n\n#define SDRAM_ERR_ADDR_REG      0x50\n#define SDRAM_ERR_ADDR_BANK_OFFSET    23\n#define SDRAM_ERR_ADDR_BANK_MASK      (0x7 << SDRAM_ERR_ADDR_BANK_OFFSET)\n#define SDRAM_ERR_ADDR_COL_OFFSET     8\n#define SDRAM_ERR_ADDR_COL_MASK       (0x7fff << SDRAM_ERR_ADDR_COL_OFFSET)\n#define SDRAM_ERR_ADDR_CS_OFFSET      1\n#define SDRAM_ERR_ADDR_CS_MASK        (0x3 << SDRAM_ERR_ADDR_CS_OFFSET)\n#define SDRAM_ERR_ADDR_TYPE_MASK      BIT(0)\n\n#define SDRAM_ERR_CTRL_REG      0x54\n#define SDRAM_ERR_CTRL_THR_OFFSET     16\n#define SDRAM_ERR_CTRL_THR_MASK       (0xff << SDRAM_ERR_CTRL_THR_OFFSET)\n#define SDRAM_ERR_CTRL_PROP_MASK      BIT(9)\n\n#define SDRAM_ERR_SBE_COUNT_REG 0x58\n#define SDRAM_ERR_DBE_COUNT_REG 0x5c\n\n#define SDRAM_ERR_CAUSE_ERR_REG 0xd0\n#define SDRAM_ERR_CAUSE_MSG_REG 0xd8\n#define SDRAM_ERR_CAUSE_DBE_MASK      BIT(1)\n#define SDRAM_ERR_CAUSE_SBE_MASK      BIT(0)\n\n#define SDRAM_RANK_CTRL_REG 0x1e0\n#define SDRAM_RANK_CTRL_EXIST_MASK(cs) BIT(cs)\n\nstruct axp_mc_drvdata {\n\tvoid __iomem *base;\n\t \n\tunsigned int width;\n\t \n\tbool cs_addr_sel[SDRAM_NUM_CS];\n\n\tchar msg[128];\n};\n\n \nstatic uint32_t axp_mc_calc_address(struct axp_mc_drvdata *drvdata,\n\t\t\t\t    uint8_t cs, uint8_t bank, uint16_t row,\n\t\t\t\t    uint16_t col)\n{\n\tif (drvdata->width == 8) {\n\t\t \n\t\tif (drvdata->cs_addr_sel[cs])\n\t\t\t \n\t\t\treturn (((row & 0xfff8) << 16) |\n\t\t\t\t((bank & 0x7) << 16) |\n\t\t\t\t((row & 0x7) << 13) |\n\t\t\t\t((col & 0x3ff) << 3));\n\t\telse\n\t\t\treturn (((row & 0xffff << 16) |\n\t\t\t\t ((bank & 0x7) << 13) |\n\t\t\t\t ((col & 0x3ff)) << 3));\n\t} else if (drvdata->width == 4) {\n\t\t \n\t\tif (drvdata->cs_addr_sel[cs])\n\t\t\t \n\t\t\treturn (((row & 0xfff0) << 15) |\n\t\t\t\t((bank & 0x7) << 16) |\n\t\t\t\t((row & 0xf) << 12) |\n\t\t\t\t((col & 0x3ff) << 2));\n\t\telse\n\t\t\treturn (((row & 0xffff << 15) |\n\t\t\t\t ((bank & 0x7) << 12) |\n\t\t\t\t ((col & 0x3ff)) << 2));\n\t} else {\n\t\t \n\t\tif (drvdata->cs_addr_sel[cs])\n\t\t\t \n\t\t\treturn (((row & 0xffe0) << 14) |\n\t\t\t\t((bank & 0x7) << 16) |\n\t\t\t\t((row & 0x1f) << 11) |\n\t\t\t\t((col & 0x3ff) << 1));\n\t\telse\n\t\t\treturn (((row & 0xffff << 14) |\n\t\t\t\t ((bank & 0x7) << 11) |\n\t\t\t\t ((col & 0x3ff)) << 1));\n\t}\n}\n\nstatic void axp_mc_check(struct mem_ctl_info *mci)\n{\n\tstruct axp_mc_drvdata *drvdata = mci->pvt_info;\n\tuint32_t data_h, data_l, recv_ecc, calc_ecc, addr;\n\tuint32_t cnt_sbe, cnt_dbe, cause_err, cause_msg;\n\tuint32_t row_val, col_val, bank_val, addr_val;\n\tuint8_t syndrome_val, cs_val;\n\tchar *msg = drvdata->msg;\n\n\tdata_h    = readl(drvdata->base + SDRAM_ERR_DATA_H_REG);\n\tdata_l    = readl(drvdata->base + SDRAM_ERR_DATA_L_REG);\n\trecv_ecc  = readl(drvdata->base + SDRAM_ERR_RECV_ECC_REG);\n\tcalc_ecc  = readl(drvdata->base + SDRAM_ERR_CALC_ECC_REG);\n\taddr      = readl(drvdata->base + SDRAM_ERR_ADDR_REG);\n\tcnt_sbe   = readl(drvdata->base + SDRAM_ERR_SBE_COUNT_REG);\n\tcnt_dbe   = readl(drvdata->base + SDRAM_ERR_DBE_COUNT_REG);\n\tcause_err = readl(drvdata->base + SDRAM_ERR_CAUSE_ERR_REG);\n\tcause_msg = readl(drvdata->base + SDRAM_ERR_CAUSE_MSG_REG);\n\n\t \n\twritel(~(SDRAM_ERR_CAUSE_DBE_MASK | SDRAM_ERR_CAUSE_SBE_MASK),\n\t       drvdata->base + SDRAM_ERR_CAUSE_ERR_REG);\n\twritel(~(SDRAM_ERR_CAUSE_DBE_MASK | SDRAM_ERR_CAUSE_SBE_MASK),\n\t       drvdata->base + SDRAM_ERR_CAUSE_MSG_REG);\n\n\t \n\tif (cnt_sbe)\n\t\twritel(0, drvdata->base + SDRAM_ERR_SBE_COUNT_REG);\n\tif (cnt_dbe)\n\t\twritel(0, drvdata->base + SDRAM_ERR_DBE_COUNT_REG);\n\n\tif (!cnt_sbe && !cnt_dbe)\n\t\treturn;\n\n\tif (!(addr & SDRAM_ERR_ADDR_TYPE_MASK)) {\n\t\tif (cnt_sbe)\n\t\t\tcnt_sbe--;\n\t\telse\n\t\t\tdev_warn(mci->pdev, \"inconsistent SBE count detected\\n\");\n\t} else {\n\t\tif (cnt_dbe)\n\t\t\tcnt_dbe--;\n\t\telse\n\t\t\tdev_warn(mci->pdev, \"inconsistent DBE count detected\\n\");\n\t}\n\n\t \n\tif (cnt_sbe)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci,\n\t\t\t\t     cnt_sbe,  \n\t\t\t\t     0, 0, 0,  \n\t\t\t\t     -1, -1, -1,  \n\t\t\t\t     mci->ctl_name,\n\t\t\t\t     \"details unavailable (multiple errors)\");\n\tif (cnt_dbe)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci,\n\t\t\t\t     cnt_dbe,  \n\t\t\t\t     0, 0, 0,  \n\t\t\t\t     -1, -1, -1,  \n\t\t\t\t     mci->ctl_name,\n\t\t\t\t     \"details unavailable (multiple errors)\");\n\n\t \n\tcs_val   = (addr & SDRAM_ERR_ADDR_CS_MASK) >> SDRAM_ERR_ADDR_CS_OFFSET;\n\tbank_val = (addr & SDRAM_ERR_ADDR_BANK_MASK) >> SDRAM_ERR_ADDR_BANK_OFFSET;\n\trow_val  = (calc_ecc & SDRAM_ERR_CALC_ECC_ROW_MASK) >> SDRAM_ERR_CALC_ECC_ROW_OFFSET;\n\tcol_val  = (addr & SDRAM_ERR_ADDR_COL_MASK) >> SDRAM_ERR_ADDR_COL_OFFSET;\n\tsyndrome_val = (recv_ecc ^ calc_ecc) & 0xff;\n\taddr_val = axp_mc_calc_address(drvdata, cs_val, bank_val, row_val,\n\t\t\t\t       col_val);\n\tmsg += sprintf(msg, \"row=0x%04x \", row_val);  \n\tmsg += sprintf(msg, \"bank=0x%x \", bank_val);  \n\tmsg += sprintf(msg, \"col=0x%04x \", col_val);  \n\tmsg += sprintf(msg, \"cs=%d\", cs_val);\t      \n\n\tif (!(addr & SDRAM_ERR_ADDR_TYPE_MASK)) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci,\n\t\t\t\t     1,\t \n\t\t\t\t     addr_val >> PAGE_SHIFT,\n\t\t\t\t     addr_val & ~PAGE_MASK,\n\t\t\t\t     syndrome_val,\n\t\t\t\t     cs_val, -1, -1,  \n\t\t\t\t     mci->ctl_name, drvdata->msg);\n\t} else {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci,\n\t\t\t\t     1,\t \n\t\t\t\t     addr_val >> PAGE_SHIFT,\n\t\t\t\t     addr_val & ~PAGE_MASK,\n\t\t\t\t     syndrome_val,\n\t\t\t\t     cs_val, -1, -1,  \n\t\t\t\t     mci->ctl_name, drvdata->msg);\n\t}\n}\n\nstatic void axp_mc_read_config(struct mem_ctl_info *mci)\n{\n\tstruct axp_mc_drvdata *drvdata = mci->pvt_info;\n\tuint32_t config, addr_ctrl, rank_ctrl;\n\tunsigned int i, cs_struct, cs_size;\n\tstruct dimm_info *dimm;\n\n\tconfig = readl(drvdata->base + SDRAM_CONFIG_REG);\n\tif (config & SDRAM_CONFIG_BUS_WIDTH_MASK)\n\t\t \n\t\tdrvdata->width = 8;\n\telse\n\t\t \n\t\tdrvdata->width = 4;\n\n\taddr_ctrl = readl(drvdata->base + SDRAM_ADDR_CTRL_REG);\n\trank_ctrl = readl(drvdata->base + SDRAM_RANK_CTRL_REG);\n\tfor (i = 0; i < SDRAM_NUM_CS; i++) {\n\t\tdimm = mci->dimms[i];\n\n\t\tif (!(rank_ctrl & SDRAM_RANK_CTRL_EXIST_MASK(i)))\n\t\t\tcontinue;\n\n\t\tdrvdata->cs_addr_sel[i] =\n\t\t\t!!(addr_ctrl & SDRAM_ADDR_CTRL_ADDR_SEL_MASK(i));\n\n\t\tcs_struct = (addr_ctrl & SDRAM_ADDR_CTRL_STRUCT_MASK(i)) >> SDRAM_ADDR_CTRL_STRUCT_OFFSET(i);\n\t\tcs_size   = ((addr_ctrl & SDRAM_ADDR_CTRL_SIZE_HIGH_MASK(i)) >> (SDRAM_ADDR_CTRL_SIZE_HIGH_OFFSET(i) - 2) |\n\t\t\t    ((addr_ctrl & SDRAM_ADDR_CTRL_SIZE_LOW_MASK(i)) >> SDRAM_ADDR_CTRL_SIZE_LOW_OFFSET(i)));\n\n\t\tswitch (cs_size) {\n\t\tcase 0:  \n\t\t\tdimm->nr_pages = 524288;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tdimm->nr_pages = 65536;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tdimm->nr_pages = 131072;\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tdimm->nr_pages = 262144;\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\tdimm->nr_pages = 1048576;\n\t\t\tbreak;\n\t\tcase 5:  \n\t\t\tdimm->nr_pages = 2097152;\n\t\t\tbreak;\n\t\t}\n\t\tdimm->grain = 8;\n\t\tdimm->dtype = cs_struct ? DEV_X16 : DEV_X8;\n\t\tdimm->mtype = (config & SDRAM_CONFIG_REGISTERED_MASK) ?\n\t\t\tMEM_RDDR3 : MEM_DDR3;\n\t\tdimm->edac_mode = EDAC_SECDED;\n\t}\n}\n\nstatic const struct of_device_id axp_mc_of_match[] = {\n\t{.compatible = \"marvell,armada-xp-sdram-controller\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, axp_mc_of_match);\n\nstatic int axp_mc_probe(struct platform_device *pdev)\n{\n\tstruct axp_mc_drvdata *drvdata;\n\tstruct edac_mc_layer layers[1];\n\tconst struct of_device_id *id;\n\tstruct mem_ctl_info *mci;\n\tvoid __iomem *base;\n\tuint32_t config;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tdev_err(&pdev->dev, \"Unable to map regs\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\n\tconfig = readl(base + SDRAM_CONFIG_REG);\n\tif (!(config & SDRAM_CONFIG_ECC_MASK)) {\n\t\tdev_warn(&pdev->dev, \"SDRAM ECC is not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = SDRAM_NUM_CS;\n\tlayers[0].is_virt_csrow = true;\n\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*drvdata));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tdrvdata = mci->pvt_info;\n\tdrvdata->base = base;\n\tmci->pdev = &pdev->dev;\n\tplatform_set_drvdata(pdev, mci);\n\n\tid = of_match_device(axp_mc_of_match, &pdev->dev);\n\tmci->edac_check = axp_mc_check;\n\tmci->mtype_cap = MEM_FLAG_DDR3;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = pdev->dev.driver->name;\n\tmci->ctl_name = id ? id->compatible : \"unknown\";\n\tmci->dev_name = dev_name(&pdev->dev);\n\tmci->scrub_mode = SCRUB_NONE;\n\n\taxp_mc_read_config(mci);\n\n\t \n\tif (of_machine_is_compatible(\"marvell,armada380\") ||\n\t    of_machine_is_compatible(\"marvell,armadaxp-98dx3236\"))\n\t\tdrvdata->width /= 2;\n\n\t \n\t \n\twritel(1 << SDRAM_ERR_CTRL_THR_OFFSET, drvdata->base + SDRAM_ERR_CTRL_REG);\n\n\t \n\twritel(~(SDRAM_ERR_CAUSE_DBE_MASK | SDRAM_ERR_CAUSE_SBE_MASK), drvdata->base + SDRAM_ERR_CAUSE_ERR_REG);\n\twritel(~(SDRAM_ERR_CAUSE_DBE_MASK | SDRAM_ERR_CAUSE_SBE_MASK), drvdata->base + SDRAM_ERR_CAUSE_MSG_REG);\n\n\t \n\twritel(0, drvdata->base + SDRAM_ERR_SBE_COUNT_REG);\n\twritel(0, drvdata->base + SDRAM_ERR_DBE_COUNT_REG);\n\n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_mc_free(mci);\n\t\treturn -EINVAL;\n\t}\n\tedac_op_state = EDAC_OPSTATE_POLL;\n\n\treturn 0;\n}\n\nstatic int axp_mc_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic struct platform_driver axp_mc_driver = {\n\t.probe = axp_mc_probe,\n\t.remove = axp_mc_remove,\n\t.driver = {\n\t\t.name = \"armada_xp_mc_edac\",\n\t\t.of_match_table = of_match_ptr(axp_mc_of_match),\n\t},\n};\n\n \n\nstruct aurora_l2_drvdata {\n\tvoid __iomem *base;\n\n\tchar msg[128];\n\n\t \n\tuint32_t inject_addr;\n\tuint32_t inject_mask;\n\tuint8_t inject_ctl;\n\n\tstruct dentry *debugfs;\n};\n\n#ifdef CONFIG_EDAC_DEBUG\nstatic void aurora_l2_inject(struct aurora_l2_drvdata *drvdata)\n{\n\tdrvdata->inject_addr &= AURORA_ERR_INJECT_CTL_ADDR_MASK;\n\tdrvdata->inject_ctl &= AURORA_ERR_INJECT_CTL_EN_MASK;\n\twritel(0, drvdata->base + AURORA_ERR_INJECT_CTL_REG);\n\twritel(drvdata->inject_mask, drvdata->base + AURORA_ERR_INJECT_MASK_REG);\n\twritel(drvdata->inject_addr | drvdata->inject_ctl, drvdata->base + AURORA_ERR_INJECT_CTL_REG);\n}\n#endif\n\nstatic void aurora_l2_check(struct edac_device_ctl_info *dci)\n{\n\tstruct aurora_l2_drvdata *drvdata = dci->pvt_info;\n\tuint32_t cnt, src, txn, err, attr_cap, addr_cap, way_cap;\n\tunsigned int cnt_ce, cnt_ue;\n\tchar *msg = drvdata->msg;\n\tsize_t size = sizeof(drvdata->msg);\n\tsize_t len = 0;\n\n\tcnt = readl(drvdata->base + AURORA_ERR_CNT_REG);\n\tattr_cap = readl(drvdata->base + AURORA_ERR_ATTR_CAP_REG);\n\taddr_cap = readl(drvdata->base + AURORA_ERR_ADDR_CAP_REG);\n\tway_cap = readl(drvdata->base + AURORA_ERR_WAY_CAP_REG);\n\n\tcnt_ce = (cnt & AURORA_ERR_CNT_CE_MASK) >> AURORA_ERR_CNT_CE_OFFSET;\n\tcnt_ue = (cnt & AURORA_ERR_CNT_UE_MASK) >> AURORA_ERR_CNT_UE_OFFSET;\n\t \n\tif (cnt_ce || cnt_ue)\n\t\twritel(AURORA_ERR_CNT_CLR, drvdata->base + AURORA_ERR_CNT_REG);\n\n\tif (!(attr_cap & AURORA_ERR_ATTR_CAP_VALID))\n\t\tgoto clear_remaining;\n\n\tsrc = (attr_cap & AURORA_ERR_ATTR_SRC_MSK) >> AURORA_ERR_ATTR_SRC_OFF;\n\tif (src <= 3)\n\t\tlen += scnprintf(msg+len, size-len, \"src=CPU%d \", src);\n\telse\n\t\tlen += scnprintf(msg+len, size-len, \"src=IO \");\n\n\ttxn =  (attr_cap & AURORA_ERR_ATTR_TXN_MSK) >> AURORA_ERR_ATTR_TXN_OFF;\n\tswitch (txn) {\n\tcase 0:\n\t\tlen += scnprintf(msg+len, size-len, \"txn=Data-Read \");\n\t\tbreak;\n\tcase 1:\n\t\tlen += scnprintf(msg+len, size-len, \"txn=Isn-Read \");\n\t\tbreak;\n\tcase 2:\n\t\tlen += scnprintf(msg+len, size-len, \"txn=Clean-Flush \");\n\t\tbreak;\n\tcase 3:\n\t\tlen += scnprintf(msg+len, size-len, \"txn=Eviction \");\n\t\tbreak;\n\tcase 4:\n\t\tlen += scnprintf(msg+len, size-len,\n\t\t\t\t\"txn=Read-Modify-Write \");\n\t\tbreak;\n\t}\n\n\terr = (attr_cap & AURORA_ERR_ATTR_ERR_MSK) >> AURORA_ERR_ATTR_ERR_OFF;\n\tswitch (err) {\n\tcase 0:\n\t\tlen += scnprintf(msg+len, size-len, \"err=CorrECC \");\n\t\tbreak;\n\tcase 1:\n\t\tlen += scnprintf(msg+len, size-len, \"err=UnCorrECC \");\n\t\tbreak;\n\tcase 2:\n\t\tlen += scnprintf(msg+len, size-len, \"err=TagParity \");\n\t\tbreak;\n\t}\n\n\tlen += scnprintf(msg+len, size-len, \"addr=0x%x \", addr_cap & AURORA_ERR_ADDR_CAP_ADDR_MASK);\n\tlen += scnprintf(msg+len, size-len, \"index=0x%x \", (way_cap & AURORA_ERR_WAY_IDX_MSK) >> AURORA_ERR_WAY_IDX_OFF);\n\tlen += scnprintf(msg+len, size-len, \"way=0x%x\", (way_cap & AURORA_ERR_WAY_CAP_WAY_MASK) >> AURORA_ERR_WAY_CAP_WAY_OFFSET);\n\n\t \n\twritel(AURORA_ERR_ATTR_CAP_VALID, drvdata->base + AURORA_ERR_ATTR_CAP_REG);\n\tif (err) {\n\t\t \n\t\tif (cnt_ue)\n\t\t\tcnt_ue--;\n\t\tedac_device_handle_ue(dci, 0, 0, drvdata->msg);\n\t} else {\n\t\tif (cnt_ce)\n\t\t\tcnt_ce--;\n\t\tedac_device_handle_ce(dci, 0, 0, drvdata->msg);\n\t}\n\nclear_remaining:\n\t \n\twhile (cnt_ue--)\n\t\tedac_device_handle_ue(dci, 0, 0, \"details unavailable (multiple errors)\");\n\twhile (cnt_ce--)\n\t\tedac_device_handle_ue(dci, 0, 0, \"details unavailable (multiple errors)\");\n}\n\nstatic void aurora_l2_poll(struct edac_device_ctl_info *dci)\n{\n#ifdef CONFIG_EDAC_DEBUG\n\tstruct aurora_l2_drvdata *drvdata = dci->pvt_info;\n#endif\n\n\taurora_l2_check(dci);\n#ifdef CONFIG_EDAC_DEBUG\n\taurora_l2_inject(drvdata);\n#endif\n}\n\nstatic const struct of_device_id aurora_l2_of_match[] = {\n\t{.compatible = \"marvell,aurora-system-cache\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, aurora_l2_of_match);\n\nstatic int aurora_l2_probe(struct platform_device *pdev)\n{\n\tstruct aurora_l2_drvdata *drvdata;\n\tstruct edac_device_ctl_info *dci;\n\tconst struct of_device_id *id;\n\tuint32_t l2x0_aux_ctrl;\n\tvoid __iomem *base;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tdev_err(&pdev->dev, \"Unable to map regs\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\n\tl2x0_aux_ctrl = readl(base + L2X0_AUX_CTRL);\n\tif (!(l2x0_aux_ctrl & AURORA_ACR_PARITY_EN))\n\t\tdev_warn(&pdev->dev, \"tag parity is not enabled\\n\");\n\tif (!(l2x0_aux_ctrl & AURORA_ACR_ECC_EN))\n\t\tdev_warn(&pdev->dev, \"data ECC is not enabled\\n\");\n\n\tdci = edac_device_alloc_ctl_info(sizeof(*drvdata),\n\t\t\t\t\t \"cpu\", 1, \"L\", 1, 2, NULL, 0, 0);\n\tif (!dci)\n\t\treturn -ENOMEM;\n\n\tdrvdata = dci->pvt_info;\n\tdrvdata->base = base;\n\tdci->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, dci);\n\n\tid = of_match_device(aurora_l2_of_match, &pdev->dev);\n\tdci->edac_check = aurora_l2_poll;\n\tdci->mod_name = pdev->dev.driver->name;\n\tdci->ctl_name = id ? id->compatible : \"unknown\";\n\tdci->dev_name = dev_name(&pdev->dev);\n\n\t \n\twritel(AURORA_ERR_CNT_CLR, drvdata->base + AURORA_ERR_CNT_REG);\n\twritel(AURORA_ERR_ATTR_CAP_VALID, drvdata->base + AURORA_ERR_ATTR_CAP_REG);\n\n\tif (edac_device_add_device(dci)) {\n\t\tedac_device_free_ctl_info(dci);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_EDAC_DEBUG\n\tdrvdata->debugfs = edac_debugfs_create_dir(dev_name(&pdev->dev));\n\tif (drvdata->debugfs) {\n\t\tedac_debugfs_create_x32(\"inject_addr\", 0644,\n\t\t\t\t\tdrvdata->debugfs,\n\t\t\t\t\t&drvdata->inject_addr);\n\t\tedac_debugfs_create_x32(\"inject_mask\", 0644,\n\t\t\t\t\tdrvdata->debugfs,\n\t\t\t\t\t&drvdata->inject_mask);\n\t\tedac_debugfs_create_x8(\"inject_ctl\", 0644,\n\t\t\t\t       drvdata->debugfs, &drvdata->inject_ctl);\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int aurora_l2_remove(struct platform_device *pdev)\n{\n\tstruct edac_device_ctl_info *dci = platform_get_drvdata(pdev);\n#ifdef CONFIG_EDAC_DEBUG\n\tstruct aurora_l2_drvdata *drvdata = dci->pvt_info;\n\n\tedac_debugfs_remove_recursive(drvdata->debugfs);\n#endif\n\tedac_device_del_device(&pdev->dev);\n\tedac_device_free_ctl_info(dci);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic struct platform_driver aurora_l2_driver = {\n\t.probe = aurora_l2_probe,\n\t.remove = aurora_l2_remove,\n\t.driver = {\n\t\t.name = \"aurora_l2_edac\",\n\t\t.of_match_table = of_match_ptr(aurora_l2_of_match),\n\t},\n};\n\n \n\nstatic struct platform_driver * const drivers[] = {\n\t&axp_mc_driver,\n\t&aurora_l2_driver,\n};\n\nstatic int __init armada_xp_edac_init(void)\n{\n\tint res;\n\n\tif (ghes_get_devices())\n\t\treturn -EBUSY;\n\n\t \n\tedac_op_state = EDAC_OPSTATE_POLL;\n\n\tres = platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n\tif (res)\n\t\tpr_warn(\"Armada XP EDAC drivers fail to register\\n\");\n\n\treturn 0;\n}\nmodule_init(armada_xp_edac_init);\n\nstatic void __exit armada_xp_edac_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\nmodule_exit(armada_xp_edac_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Pengutronix\");\nMODULE_DESCRIPTION(\"EDAC Drivers for Marvell Armada XP SDRAM and L2 Cache Controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}