{
  "module_name": "edac_mc.h",
  "hash_id": "9083a6f039d86ea29e5541aa2fc12bcf6f4fab3d62740ad6b80b97b1339fa3d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_mc.h",
  "human_readable_source": " \n\n#ifndef _EDAC_MC_H_\n#define _EDAC_MC_H_\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/smp.h>\n#include <linux/pci.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/rcupdate.h>\n#include <linux/completion.h>\n#include <linux/kobject.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n#include <linux/edac.h>\n\n#if PAGE_SHIFT < 20\n#define PAGES_TO_MiB(pages)\t((pages) >> (20 - PAGE_SHIFT))\n#define MiB_TO_PAGES(mb)\t((mb) << (20 - PAGE_SHIFT))\n#else\t\t\t\t \n#define PAGES_TO_MiB(pages)\t((pages) << (PAGE_SHIFT - 20))\n#define MiB_TO_PAGES(mb)\t((mb) >> (PAGE_SHIFT - 20))\n#endif\n\n#define edac_printk(level, prefix, fmt, arg...) \\\n\tprintk(level \"EDAC \" prefix \": \" fmt, ##arg)\n\n#define edac_mc_printk(mci, level, fmt, arg...) \\\n\tprintk(level \"EDAC MC%d: \" fmt, mci->mc_idx, ##arg)\n\n#define edac_mc_chipset_printk(mci, level, prefix, fmt, arg...) \\\n\tprintk(level \"EDAC \" prefix \" MC%d: \" fmt, mci->mc_idx, ##arg)\n\n#define edac_device_printk(ctl, level, fmt, arg...) \\\n\tprintk(level \"EDAC DEVICE%d: \" fmt, ctl->dev_idx, ##arg)\n\n#define edac_pci_printk(ctl, level, fmt, arg...) \\\n\tprintk(level \"EDAC PCI%d: \" fmt, ctl->pci_idx, ##arg)\n\n \n#define EDAC_MC \"MC\"\n#define EDAC_PCI \"PCI\"\n#define EDAC_DEBUG \"DEBUG\"\n\nextern const char * const edac_mem_types[];\n\n#ifdef CONFIG_EDAC_DEBUG\nextern int edac_debug_level;\n\n#define edac_dbg(level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (level <= edac_debug_level)\t\t\t\t\t\\\n\t\tedac_printk(KERN_DEBUG, EDAC_DEBUG,\t\t\t\\\n\t\t\t    \"%s: \" fmt, __func__, ##__VA_ARGS__);\t\\\n} while (0)\n\n#else\t\t\t\t \n\n#define edac_dbg(level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\tedac_printk(KERN_DEBUG, EDAC_DEBUG,\t\t\t\\\n\t\t\t    \"%s: \" fmt, __func__, ##__VA_ARGS__);\t\\\n} while (0)\n\n#endif\t\t\t\t \n\n#define PCI_VEND_DEV(vend, dev) PCI_VENDOR_ID_ ## vend, \\\n\tPCI_DEVICE_ID_ ## vend ## _ ## dev\n\n#define edac_dev_name(dev) (dev)->dev_name\n\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\n\n \nstruct mem_ctl_info *edac_mc_alloc(unsigned int mc_num,\n\t\t\t\t   unsigned int n_layers,\n\t\t\t\t   struct edac_mc_layer *layers,\n\t\t\t\t   unsigned int sz_pvt);\n\n \nextern const char *edac_get_owner(void);\n\n \nextern int edac_mc_add_mc_with_groups(struct mem_ctl_info *mci,\n\t\t\t\t      const struct attribute_group **groups);\n#define edac_mc_add_mc(mci)\tedac_mc_add_mc_with_groups(mci, NULL)\n\n \nextern void edac_mc_free(struct mem_ctl_info *mci);\n\n \nextern bool edac_has_mcs(void);\n\n \nextern struct mem_ctl_info *edac_mc_find(int idx);\n\n \nextern struct mem_ctl_info *find_mci_by_dev(struct device *dev);\n\n \nextern struct mem_ctl_info *edac_mc_del_mc(struct device *dev);\n\n \nextern int edac_mc_find_csrow_by_page(struct mem_ctl_info *mci,\n\t\t\t\t      unsigned long page);\n\n \nvoid edac_raw_mc_handle_error(struct edac_raw_error_desc *e);\n\n \nvoid edac_mc_handle_error(const enum hw_event_mc_err_type type,\n\t\t\t  struct mem_ctl_info *mci,\n\t\t\t  const u16 error_count,\n\t\t\t  const unsigned long page_frame_number,\n\t\t\t  const unsigned long offset_in_page,\n\t\t\t  const unsigned long syndrome,\n\t\t\t  const int top_layer,\n\t\t\t  const int mid_layer,\n\t\t\t  const int low_layer,\n\t\t\t  const char *msg,\n\t\t\t  const char *other_detail);\n\n \nextern char *edac_op_state_to_string(int op_state);\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}