{
  "module_name": "i82443bxgx_edac.c",
  "hash_id": "a60c90cde0c450f9e8a0c5cb19fd6d376e6eb75c97c7be09fa8c878803fbf2dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i82443bxgx_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n\n\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR    \"i82443bxgx_edac\"\n\n \n\n \n\n \n\n#define I82443BXGX_NR_CSROWS 8\n#define I82443BXGX_NR_CHANS  1\n#define I82443BXGX_NR_DIMMS  4\n\n \n#define I82443BXGX_NBXCFG 0x50\t \n#define I82443BXGX_NBXCFG_OFFSET_NON_ECCROW 24\t \n#define I82443BXGX_NBXCFG_OFFSET_DRAM_FREQ 12\t \n\n#define I82443BXGX_NBXCFG_OFFSET_DRAM_INTEGRITY 7\t \n#define I82443BXGX_NBXCFG_INTEGRITY_NONE   0x0\t \n#define I82443BXGX_NBXCFG_INTEGRITY_EC     0x1\t \n#define I82443BXGX_NBXCFG_INTEGRITY_ECC    0x2\t \n#define I82443BXGX_NBXCFG_INTEGRITY_SCRUB  0x3\t \n\n#define I82443BXGX_NBXCFG_OFFSET_ECC_DIAG_ENABLE  6\n\n \n#define I82443BXGX_EAP   0x80\t \n#define I82443BXGX_EAP_OFFSET_EAP  12\t \n#define I82443BXGX_EAP_OFFSET_MBE  BIT(1)\t \n#define I82443BXGX_EAP_OFFSET_SBE  BIT(0)\t \n\n#define I82443BXGX_ERRCMD  0x90\t \n#define I82443BXGX_ERRCMD_OFFSET_SERR_ON_MBE BIT(1)\t \n#define I82443BXGX_ERRCMD_OFFSET_SERR_ON_SBE BIT(0)\t \n\n#define I82443BXGX_ERRSTS  0x91\t \n#define I82443BXGX_ERRSTS_OFFSET_MBFRE 5\t \n#define I82443BXGX_ERRSTS_OFFSET_MEF   BIT(4)\t \n#define I82443BXGX_ERRSTS_OFFSET_SBFRE 1\t \n#define I82443BXGX_ERRSTS_OFFSET_SEF   BIT(0)\t \n\n#define I82443BXGX_DRAMC 0x57\t \n#define I82443BXGX_DRAMC_OFFSET_DT 3\t \n#define I82443BXGX_DRAMC_DRAM_IS_EDO 0\t \n#define I82443BXGX_DRAMC_DRAM_IS_SDRAM 1\t \n#define I82443BXGX_DRAMC_DRAM_IS_RSDRAM 2\t \n\n#define I82443BXGX_DRB 0x60\t \n\n \n\nstruct i82443bxgx_edacmc_error_info {\n\tu32 eap;\n};\n\nstatic struct edac_pci_ctl_info *i82443bxgx_pci;\n\nstatic struct pci_dev *mci_pdev;\t \n\nstatic int i82443bxgx_registered = 1;\n\nstatic void i82443bxgx_edacmc_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct i82443bxgx_edacmc_error_info\n\t\t\t\t*info)\n{\n\tstruct pci_dev *pdev;\n\tpdev = to_pci_dev(mci->pdev);\n\tpci_read_config_dword(pdev, I82443BXGX_EAP, &info->eap);\n\tif (info->eap & I82443BXGX_EAP_OFFSET_SBE)\n\t\t \n\t\tpci_write_bits32(pdev, I82443BXGX_EAP,\n\t\t\t\t I82443BXGX_EAP_OFFSET_SBE,\n\t\t\t\t I82443BXGX_EAP_OFFSET_SBE);\n\n\tif (info->eap & I82443BXGX_EAP_OFFSET_MBE)\n\t\t \n\t\tpci_write_bits32(pdev, I82443BXGX_EAP,\n\t\t\t\t I82443BXGX_EAP_OFFSET_MBE,\n\t\t\t\t I82443BXGX_EAP_OFFSET_MBE);\n}\n\nstatic int i82443bxgx_edacmc_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\t\t\tstruct\n\t\t\t\t\t\ti82443bxgx_edacmc_error_info\n\t\t\t\t\t\t*info, int handle_errors)\n{\n\tint error_found = 0;\n\tu32 eapaddr, page, pageoffset;\n\n\t \n\teapaddr = (info->eap & 0xfffff000);\n\tpage = eapaddr >> PAGE_SHIFT;\n\tpageoffset = eapaddr - (page << PAGE_SHIFT);\n\n\tif (info->eap & I82443BXGX_EAP_OFFSET_SBE) {\n\t\terror_found = 1;\n\t\tif (handle_errors)\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t\t     page, pageoffset, 0,\n\t\t\t\t\t     edac_mc_find_csrow_by_page(mci, page),\n\t\t\t\t\t     0, -1, mci->ctl_name, \"\");\n\t}\n\n\tif (info->eap & I82443BXGX_EAP_OFFSET_MBE) {\n\t\terror_found = 1;\n\t\tif (handle_errors)\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\t     page, pageoffset, 0,\n\t\t\t\t\t     edac_mc_find_csrow_by_page(mci, page),\n\t\t\t\t\t     0, -1, mci->ctl_name, \"\");\n\t}\n\n\treturn error_found;\n}\n\nstatic void i82443bxgx_edacmc_check(struct mem_ctl_info *mci)\n{\n\tstruct i82443bxgx_edacmc_error_info info;\n\n\ti82443bxgx_edacmc_get_error_info(mci, &info);\n\ti82443bxgx_edacmc_process_error_info(mci, &info, 1);\n}\n\nstatic void i82443bxgx_init_csrows(struct mem_ctl_info *mci,\n\t\t\t\tstruct pci_dev *pdev,\n\t\t\t\tenum edac_type edac_mode,\n\t\t\t\tenum mem_type mtype)\n{\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\tint index;\n\tu8 drbar, dramc;\n\tu32 row_base, row_high_limit, row_high_limit_last;\n\n\tpci_read_config_byte(pdev, I82443BXGX_DRAMC, &dramc);\n\trow_high_limit_last = 0;\n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\tcsrow = mci->csrows[index];\n\t\tdimm = csrow->channels[0]->dimm;\n\n\t\tpci_read_config_byte(pdev, I82443BXGX_DRB + index, &drbar);\n\t\tedac_dbg(1, \"MC%d: Row=%d DRB = %#0x\\n\",\n\t\t\t mci->mc_idx, index, drbar);\n\t\trow_high_limit = ((u32) drbar << 23);\n\t\t \n\t\tedac_dbg(1, \"MC%d: Row=%d, Boundary Address=%#0x, Last = %#0x\\n\",\n\t\t\t mci->mc_idx, index, row_high_limit,\n\t\t\t row_high_limit_last);\n\n\t\t \n\t\tif (row_high_limit_last && !row_high_limit)\n\t\t\trow_high_limit = 1UL << 31;\n\n\t\t \n\t\tif (row_high_limit == row_high_limit_last)\n\t\t\tcontinue;\n\t\trow_base = row_high_limit_last;\n\t\tcsrow->first_page = row_base >> PAGE_SHIFT;\n\t\tcsrow->last_page = (row_high_limit >> PAGE_SHIFT) - 1;\n\t\tdimm->nr_pages = csrow->last_page - csrow->first_page + 1;\n\t\t \n\t\tdimm->grain = 1 << 12;\n\t\tdimm->mtype = mtype;\n\t\t \n\t\tdimm->dtype = DEV_UNKNOWN;\n\t\t \n\t\tdimm->edac_mode = edac_mode;\n\t\trow_high_limit_last = row_high_limit;\n\t}\n}\n\nstatic int i82443bxgx_edacmc_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tu8 dramc;\n\tu32 nbxcfg, ecc_mode;\n\tenum mem_type mtype;\n\tenum edac_type edac_mode;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\t \n\tif (pci_read_config_dword(pdev, I82443BXGX_NBXCFG, &nbxcfg))\n\t\treturn -EIO;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = I82443BXGX_NR_CSROWS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = I82443BXGX_NR_CHANS;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(0, \"MC: mci = %p\\n\", mci);\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_EDO | MEM_FLAG_SDR | MEM_FLAG_RDR;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\n\tpci_read_config_byte(pdev, I82443BXGX_DRAMC, &dramc);\n\tswitch ((dramc >> I82443BXGX_DRAMC_OFFSET_DT) & (BIT(0) | BIT(1))) {\n\tcase I82443BXGX_DRAMC_DRAM_IS_EDO:\n\t\tmtype = MEM_EDO;\n\t\tbreak;\n\tcase I82443BXGX_DRAMC_DRAM_IS_SDRAM:\n\t\tmtype = MEM_SDR;\n\t\tbreak;\n\tcase I82443BXGX_DRAMC_DRAM_IS_RSDRAM:\n\t\tmtype = MEM_RDR;\n\t\tbreak;\n\tdefault:\n\t\tedac_dbg(0, \"Unknown/reserved DRAM type value in DRAMC register!\\n\");\n\t\tmtype = -MEM_UNKNOWN;\n\t}\n\n\tif ((mtype == MEM_SDR) || (mtype == MEM_RDR))\n\t\tmci->edac_cap = mci->edac_ctl_cap;\n\telse\n\t\tmci->edac_cap = EDAC_FLAG_NONE;\n\n\tmci->scrub_cap = SCRUB_FLAG_HW_SRC;\n\tpci_read_config_dword(pdev, I82443BXGX_NBXCFG, &nbxcfg);\n\tecc_mode = ((nbxcfg >> I82443BXGX_NBXCFG_OFFSET_DRAM_INTEGRITY) &\n\t\t(BIT(0) | BIT(1)));\n\n\tmci->scrub_mode = (ecc_mode == I82443BXGX_NBXCFG_INTEGRITY_SCRUB)\n\t\t? SCRUB_HW_SRC : SCRUB_NONE;\n\n\tswitch (ecc_mode) {\n\tcase I82443BXGX_NBXCFG_INTEGRITY_NONE:\n\t\tedac_mode = EDAC_NONE;\n\t\tbreak;\n\tcase I82443BXGX_NBXCFG_INTEGRITY_EC:\n\t\tedac_mode = EDAC_EC;\n\t\tbreak;\n\tcase I82443BXGX_NBXCFG_INTEGRITY_ECC:\n\tcase I82443BXGX_NBXCFG_INTEGRITY_SCRUB:\n\t\tedac_mode = EDAC_SECDED;\n\t\tbreak;\n\tdefault:\n\t\tedac_dbg(0, \"Unknown/reserved ECC state in NBXCFG register!\\n\");\n\t\tedac_mode = EDAC_UNKNOWN;\n\t\tbreak;\n\t}\n\n\ti82443bxgx_init_csrows(mci, pdev, edac_mode, mtype);\n\n\t \n\tpci_write_bits32(pdev, I82443BXGX_EAP,\n\t\t\t(I82443BXGX_EAP_OFFSET_SBE |\n\t\t\t\tI82443BXGX_EAP_OFFSET_MBE),\n\t\t\t(I82443BXGX_EAP_OFFSET_SBE |\n\t\t\t\tI82443BXGX_EAP_OFFSET_MBE));\n\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = \"I82443BXGX\";\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = i82443bxgx_edacmc_check;\n\tmci->ctl_page_to_phys = NULL;\n\n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"failed edac_mc_add_mc()\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\ti82443bxgx_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!i82443bxgx_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\tedac_dbg(3, \"MC: success\\n\");\n\treturn 0;\n\nfail:\n\tedac_mc_free(mci);\n\treturn -ENODEV;\n}\n\n \nstatic int i82443bxgx_edacmc_init_one(struct pci_dev *pdev,\n\t\t\t\t      const struct pci_device_id *ent)\n{\n\tint rc;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\t \n\trc = i82443bxgx_edacmc_probe1(pdev, ent->driver_data);\n\n\tif (mci_pdev == NULL)\n\t\tmci_pdev = pci_dev_get(pdev);\n\n\treturn rc;\n}\n\nstatic void i82443bxgx_edacmc_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (i82443bxgx_pci)\n\t\tedac_pci_release_generic_ctl(i82443bxgx_pci);\n\n\tif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\n\t\treturn;\n\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id i82443bxgx_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443BX_0)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443BX_2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_0)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82443GX_2)},\n\t{0,}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, i82443bxgx_pci_tbl);\n\nstatic struct pci_driver i82443bxgx_edacmc_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = i82443bxgx_edacmc_init_one,\n\t.remove = i82443bxgx_edacmc_remove_one,\n\t.id_table = i82443bxgx_pci_tbl,\n};\n\nstatic int __init i82443bxgx_edacmc_init(void)\n{\n\tint pci_rc;\n        \n       opstate_init();\n\n\tpci_rc = pci_register_driver(&i82443bxgx_edacmc_driver);\n\tif (pci_rc < 0)\n\t\tgoto fail0;\n\n\tif (mci_pdev == NULL) {\n\t\tconst struct pci_device_id *id = &i82443bxgx_pci_tbl[0];\n\t\tint i = 0;\n\t\ti82443bxgx_registered = 0;\n\n\t\twhile (mci_pdev == NULL && id->vendor != 0) {\n\t\t\tmci_pdev = pci_get_device(id->vendor,\n\t\t\t\t\tid->device, NULL);\n\t\t\ti++;\n\t\t\tid = &i82443bxgx_pci_tbl[i];\n\t\t}\n\t\tif (!mci_pdev) {\n\t\t\tedac_dbg(0, \"i82443bxgx pci_get_device fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tpci_rc = i82443bxgx_edacmc_init_one(mci_pdev, i82443bxgx_pci_tbl);\n\n\t\tif (pci_rc < 0) {\n\t\t\tedac_dbg(0, \"i82443bxgx init fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail1:\n\tpci_unregister_driver(&i82443bxgx_edacmc_driver);\n\nfail0:\n\tpci_dev_put(mci_pdev);\n\treturn pci_rc;\n}\n\nstatic void __exit i82443bxgx_edacmc_exit(void)\n{\n\tpci_unregister_driver(&i82443bxgx_edacmc_driver);\n\n\tif (!i82443bxgx_registered)\n\t\ti82443bxgx_edacmc_remove_one(mci_pdev);\n\n\tpci_dev_put(mci_pdev);\n}\n\nmodule_init(i82443bxgx_edacmc_init);\nmodule_exit(i82443bxgx_edacmc_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tim Small <tim@buttersideup.com> - WPAD\");\nMODULE_DESCRIPTION(\"EDAC MC support for Intel 82443BX/GX memory controllers\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}