{
  "module_name": "i3200_edac.c",
  "hash_id": "080aa4aa53565455d4daf01d08f019fbbd7c207f052a61837ad12673c4d1b369",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i3200_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include <linux/io.h>\n#include \"edac_module.h\"\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n#define EDAC_MOD_STR        \"i3200_edac\"\n\n#define PCI_DEVICE_ID_INTEL_3200_HB    0x29f0\n\n#define I3200_DIMMS\t\t4\n#define I3200_RANKS\t\t8\n#define I3200_RANKS_PER_CHANNEL\t4\n#define I3200_CHANNELS\t\t2\n\n \n\n#define I3200_MCHBAR_LOW\t0x48\t \n#define I3200_MCHBAR_HIGH\t0x4c\n#define I3200_MCHBAR_MASK\t0xfffffc000ULL\t \n#define I3200_MMR_WINDOW_SIZE\t16384\n\n#define I3200_TOM\t\t0xa0\t \n#define I3200_TOM_MASK\t\t0x3ff\t \n#define I3200_TOM_SHIFT\t\t26\t \n\n#define I3200_ERRSTS\t\t0xc8\t \n#define I3200_ERRSTS_UE\t\t0x0002\n#define I3200_ERRSTS_CE\t\t0x0001\n#define I3200_ERRSTS_BITS\t(I3200_ERRSTS_UE | I3200_ERRSTS_CE)\n\n\n \n\n#define I3200_C0DRB\t0x200\t \n#define I3200_C1DRB\t0x600\t \n#define I3200_DRB_MASK\t0x3ff\t \n#define I3200_DRB_SHIFT\t26\t \n\n#define I3200_C0ECCERRLOG\t0x280\t \n#define I3200_C1ECCERRLOG\t\t0x680\t \n#define I3200_ECCERRLOG_CE\t\t0x1\n#define I3200_ECCERRLOG_UE\t\t0x2\n#define I3200_ECCERRLOG_RANK_BITS\t0x18000000\n#define I3200_ECCERRLOG_RANK_SHIFT\t27\n#define I3200_ECCERRLOG_SYNDROME_BITS\t0xff0000\n#define I3200_ECCERRLOG_SYNDROME_SHIFT\t16\n#define I3200_CAPID0\t\t\t0xe0\t \n\nstruct i3200_priv {\n\tvoid __iomem *window;\n};\n\nstatic int nr_channels;\n\nstatic int how_many_channels(struct pci_dev *pdev)\n{\n\tint n_channels;\n\n\tunsigned char capid0_8b;  \n\n\tpci_read_config_byte(pdev, I3200_CAPID0 + 8, &capid0_8b);\n\n\tif (capid0_8b & 0x20) {  \n\t\tedac_dbg(0, \"In single channel mode\\n\");\n\t\tn_channels = 1;\n\t} else {\n\t\tedac_dbg(0, \"In dual channel mode\\n\");\n\t\tn_channels = 2;\n\t}\n\n\tif (capid0_8b & 0x10)  \n\t\tedac_dbg(0, \"2 DIMMS per channel disabled\\n\");\n\telse\n\t\tedac_dbg(0, \"2 DIMMS per channel enabled\\n\");\n\n\treturn n_channels;\n}\n\nstatic unsigned long eccerrlog_syndrome(u64 log)\n{\n\treturn (log & I3200_ECCERRLOG_SYNDROME_BITS) >>\n\t\tI3200_ECCERRLOG_SYNDROME_SHIFT;\n}\n\nstatic int eccerrlog_row(int channel, u64 log)\n{\n\tu64 rank = ((log & I3200_ECCERRLOG_RANK_BITS) >>\n\t\tI3200_ECCERRLOG_RANK_SHIFT);\n\treturn rank | (channel * I3200_RANKS_PER_CHANNEL);\n}\n\nenum i3200_chips {\n\tI3200 = 0,\n};\n\nstruct i3200_dev_info {\n\tconst char *ctl_name;\n};\n\nstruct i3200_error_info {\n\tu16 errsts;\n\tu16 errsts2;\n\tu64 eccerrlog[I3200_CHANNELS];\n};\n\nstatic const struct i3200_dev_info i3200_devs[] = {\n\t[I3200] = {\n\t\t.ctl_name = \"i3200\"\n\t},\n};\n\nstatic struct pci_dev *mci_pdev;\nstatic int i3200_registered = 1;\n\n\nstatic void i3200_clear_error_info(struct mem_ctl_info *mci)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(mci->pdev);\n\n\t \n\tpci_write_bits16(pdev, I3200_ERRSTS, I3200_ERRSTS_BITS,\n\t\tI3200_ERRSTS_BITS);\n}\n\nstatic void i3200_get_and_clear_error_info(struct mem_ctl_info *mci,\n\t\tstruct i3200_error_info *info)\n{\n\tstruct pci_dev *pdev;\n\tstruct i3200_priv *priv = mci->pvt_info;\n\tvoid __iomem *window = priv->window;\n\n\tpdev = to_pci_dev(mci->pdev);\n\n\t \n\tpci_read_config_word(pdev, I3200_ERRSTS, &info->errsts);\n\tif (!(info->errsts & I3200_ERRSTS_BITS))\n\t\treturn;\n\n\tinfo->eccerrlog[0] = readq(window + I3200_C0ECCERRLOG);\n\tif (nr_channels == 2)\n\t\tinfo->eccerrlog[1] = readq(window + I3200_C1ECCERRLOG);\n\n\tpci_read_config_word(pdev, I3200_ERRSTS, &info->errsts2);\n\n\t \n\tif ((info->errsts ^ info->errsts2) & I3200_ERRSTS_BITS) {\n\t\tinfo->eccerrlog[0] = readq(window + I3200_C0ECCERRLOG);\n\t\tif (nr_channels == 2)\n\t\t\tinfo->eccerrlog[1] = readq(window + I3200_C1ECCERRLOG);\n\t}\n\n\ti3200_clear_error_info(mci);\n}\n\nstatic void i3200_process_error_info(struct mem_ctl_info *mci,\n\t\tstruct i3200_error_info *info)\n{\n\tint channel;\n\tu64 log;\n\n\tif (!(info->errsts & I3200_ERRSTS_BITS))\n\t\treturn;\n\n\tif ((info->errsts ^ info->errsts2) & I3200_ERRSTS_BITS) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1, \"UE overwrote CE\", \"\");\n\t\tinfo->errsts = info->errsts2;\n\t}\n\n\tfor (channel = 0; channel < nr_channels; channel++) {\n\t\tlog = info->eccerrlog[channel];\n\t\tif (log & I3200_ECCERRLOG_UE) {\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\t     0, 0, 0,\n\t\t\t\t\t     eccerrlog_row(channel, log),\n\t\t\t\t\t     -1, -1,\n\t\t\t\t\t     \"i3000 UE\", \"\");\n\t\t} else if (log & I3200_ECCERRLOG_CE) {\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t\t     0, 0, eccerrlog_syndrome(log),\n\t\t\t\t\t     eccerrlog_row(channel, log),\n\t\t\t\t\t     -1, -1,\n\t\t\t\t\t     \"i3000 CE\", \"\");\n\t\t}\n\t}\n}\n\nstatic void i3200_check(struct mem_ctl_info *mci)\n{\n\tstruct i3200_error_info info;\n\n\ti3200_get_and_clear_error_info(mci, &info);\n\ti3200_process_error_info(mci, &info);\n}\n\nstatic void __iomem *i3200_map_mchbar(struct pci_dev *pdev)\n{\n\tunion {\n\t\tu64 mchbar;\n\t\tstruct {\n\t\t\tu32 mchbar_low;\n\t\t\tu32 mchbar_high;\n\t\t};\n\t} u;\n\tvoid __iomem *window;\n\n\tpci_read_config_dword(pdev, I3200_MCHBAR_LOW, &u.mchbar_low);\n\tpci_read_config_dword(pdev, I3200_MCHBAR_HIGH, &u.mchbar_high);\n\tu.mchbar &= I3200_MCHBAR_MASK;\n\n\tif (u.mchbar != (resource_size_t)u.mchbar) {\n\t\tprintk(KERN_ERR\n\t\t\t\"i3200: mmio space beyond accessible range (0x%llx)\\n\",\n\t\t\t(unsigned long long)u.mchbar);\n\t\treturn NULL;\n\t}\n\n\twindow = ioremap(u.mchbar, I3200_MMR_WINDOW_SIZE);\n\tif (!window)\n\t\tprintk(KERN_ERR \"i3200: cannot map mmio space at 0x%llx\\n\",\n\t\t\t(unsigned long long)u.mchbar);\n\n\treturn window;\n}\n\n\nstatic void i3200_get_drbs(void __iomem *window,\n\tu16 drbs[I3200_CHANNELS][I3200_RANKS_PER_CHANNEL])\n{\n\tint i;\n\n\tfor (i = 0; i < I3200_RANKS_PER_CHANNEL; i++) {\n\t\tdrbs[0][i] = readw(window + I3200_C0DRB + 2*i) & I3200_DRB_MASK;\n\t\tdrbs[1][i] = readw(window + I3200_C1DRB + 2*i) & I3200_DRB_MASK;\n\n\t\tedac_dbg(0, \"drb[0][%d] = %d, drb[1][%d] = %d\\n\", i, drbs[0][i], i, drbs[1][i]);\n\t}\n}\n\nstatic bool i3200_is_stacked(struct pci_dev *pdev,\n\tu16 drbs[I3200_CHANNELS][I3200_RANKS_PER_CHANNEL])\n{\n\tu16 tom;\n\n\tpci_read_config_word(pdev, I3200_TOM, &tom);\n\ttom &= I3200_TOM_MASK;\n\n\treturn drbs[I3200_CHANNELS - 1][I3200_RANKS_PER_CHANNEL - 1] == tom;\n}\n\nstatic unsigned long drb_to_nr_pages(\n\tu16 drbs[I3200_CHANNELS][I3200_RANKS_PER_CHANNEL], bool stacked,\n\tint channel, int rank)\n{\n\tint n;\n\n\tn = drbs[channel][rank];\n\tif (!n)\n\t\treturn 0;\n\n\tif (rank > 0)\n\t\tn -= drbs[channel][rank - 1];\n\tif (stacked && (channel == 1) &&\n\tdrbs[channel][rank] == drbs[channel][I3200_RANKS_PER_CHANNEL - 1])\n\t\tn -= drbs[0][I3200_RANKS_PER_CHANNEL - 1];\n\n\tn <<= (I3200_DRB_SHIFT - PAGE_SHIFT);\n\treturn n;\n}\n\nstatic int i3200_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tint rc;\n\tint i, j;\n\tstruct mem_ctl_info *mci = NULL;\n\tstruct edac_mc_layer layers[2];\n\tu16 drbs[I3200_CHANNELS][I3200_RANKS_PER_CHANNEL];\n\tbool stacked;\n\tvoid __iomem *window;\n\tstruct i3200_priv *priv;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\twindow = i3200_map_mchbar(pdev);\n\tif (!window)\n\t\treturn -ENODEV;\n\n\ti3200_get_drbs(window, drbs);\n\tnr_channels = how_many_channels(pdev);\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = I3200_DIMMS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = nr_channels;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct i3200_priv));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(3, \"MC: init mci\\n\");\n\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_DDR2;\n\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = i3200_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = i3200_check;\n\tmci->ctl_page_to_phys = NULL;\n\tpriv = mci->pvt_info;\n\tpriv->window = window;\n\n\tstacked = i3200_is_stacked(pdev, drbs);\n\n\t \n\tfor (i = 0; i < I3200_DIMMS; i++) {\n\t\tunsigned long nr_pages;\n\n\t\tfor (j = 0; j < nr_channels; j++) {\n\t\t\tstruct dimm_info *dimm = edac_get_dimm(mci, i, j, 0);\n\n\t\t\tnr_pages = drb_to_nr_pages(drbs, stacked, j, i);\n\t\t\tif (nr_pages == 0)\n\t\t\t\tcontinue;\n\n\t\t\tedac_dbg(0, \"csrow %d, channel %d%s, size = %ld MiB\\n\", i, j,\n\t\t\t\t stacked ? \" (stacked)\" : \"\", PAGES_TO_MiB(nr_pages));\n\n\t\t\tdimm->nr_pages = nr_pages;\n\t\t\tdimm->grain = nr_pages << PAGE_SHIFT;\n\t\t\tdimm->mtype = MEM_DDR2;\n\t\t\tdimm->dtype = DEV_UNKNOWN;\n\t\t\tdimm->edac_mode = EDAC_UNKNOWN;\n\t\t}\n\t}\n\n\ti3200_clear_error_info(mci);\n\n\trc = -ENODEV;\n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"MC: failed edac_mc_add_mc()\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tedac_dbg(3, \"MC: success\\n\");\n\treturn 0;\n\nfail:\n\tiounmap(window);\n\tif (mci)\n\t\tedac_mc_free(mci);\n\n\treturn rc;\n}\n\nstatic int i3200_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint rc;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\tif (pci_enable_device(pdev) < 0)\n\t\treturn -EIO;\n\n\trc = i3200_probe1(pdev, ent->driver_data);\n\tif (!mci_pdev)\n\t\tmci_pdev = pci_dev_get(pdev);\n\n\treturn rc;\n}\n\nstatic void i3200_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct i3200_priv *priv;\n\n\tedac_dbg(0, \"\\n\");\n\n\tmci = edac_mc_del_mc(&pdev->dev);\n\tif (!mci)\n\t\treturn;\n\n\tpriv = mci->pvt_info;\n\tiounmap(priv->window);\n\n\tedac_mc_free(mci);\n\n\tpci_disable_device(pdev);\n}\n\nstatic const struct pci_device_id i3200_pci_tbl[] = {\n\t{\n\t\tPCI_VEND_DEV(INTEL, 3200_HB), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\tI3200},\n\t{\n\t\t0,\n\t}             \n};\n\nMODULE_DEVICE_TABLE(pci, i3200_pci_tbl);\n\nstatic struct pci_driver i3200_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = i3200_init_one,\n\t.remove = i3200_remove_one,\n\t.id_table = i3200_pci_tbl,\n};\n\nstatic int __init i3200_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(3, \"MC:\\n\");\n\n\t \n\topstate_init();\n\n\tpci_rc = pci_register_driver(&i3200_driver);\n\tif (pci_rc < 0)\n\t\tgoto fail0;\n\n\tif (!mci_pdev) {\n\t\ti3200_registered = 0;\n\t\tmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_INTEL_3200_HB, NULL);\n\t\tif (!mci_pdev) {\n\t\t\tedac_dbg(0, \"i3200 pci_get_device fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tpci_rc = i3200_init_one(mci_pdev, i3200_pci_tbl);\n\t\tif (pci_rc < 0) {\n\t\t\tedac_dbg(0, \"i3200 init fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail1:\n\tpci_unregister_driver(&i3200_driver);\n\nfail0:\n\tpci_dev_put(mci_pdev);\n\n\treturn pci_rc;\n}\n\nstatic void __exit i3200_exit(void)\n{\n\tedac_dbg(3, \"MC:\\n\");\n\n\tpci_unregister_driver(&i3200_driver);\n\tif (!i3200_registered) {\n\t\ti3200_remove_one(mci_pdev);\n\t\tpci_dev_put(mci_pdev);\n\t}\n}\n\nmodule_init(i3200_init);\nmodule_exit(i3200_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Akamai Technologies, Inc.\");\nMODULE_DESCRIPTION(\"MC support for Intel 3200 memory hub controllers\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}