{
  "module_name": "i82975x_edac.c",
  "hash_id": "6c27a01d2562442077acc10d145a6926356e23bc5513e36dcbce4ee5c04eb4a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i82975x_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\t\"i82975x_edac\"\n\n#define i82975x_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"i82975x\", fmt, ##arg)\n\n#define i82975x_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"i82975x\", fmt, ##arg)\n\n#ifndef PCI_DEVICE_ID_INTEL_82975_0\n#define PCI_DEVICE_ID_INTEL_82975_0\t0x277c\n#endif\t\t\t\t \n\n#define I82975X_NR_DIMMS\t\t8\n#define I82975X_NR_CSROWS(nr_chans)\t(I82975X_NR_DIMMS / (nr_chans))\n\n \n#define I82975X_EAP\t\t0x58\t \n\n#define I82975X_DERRSYN\t\t0x5c\t \n\n#define I82975X_DES\t\t0x5d\t \n\n#define I82975X_ERRSTS\t\t0xc8\t \n\n \n#define I82975X_ERRCMD\t\t0xca\t \n\n#define I82975X_SMICMD\t\t0xcc\t \n\n#define I82975X_SCICMD\t\t0xce\t \n\n#define I82975X_XEAP\t0xfc\t \n\n#define I82975X_MCHBAR\t\t0x44\t \n\n \n \n\n#define I82975X_DRB_SHIFT 25\t \n\n#define I82975X_DRB\t\t0x100\t \n#define I82975X_DRB_CH0R0\t\t0x100\n#define I82975X_DRB_CH0R1\t\t0x101\n#define I82975X_DRB_CH0R2\t\t0x102\n#define I82975X_DRB_CH0R3\t\t0x103\n#define I82975X_DRB_CH1R0\t\t0x180\n#define I82975X_DRB_CH1R1\t\t0x181\n#define I82975X_DRB_CH1R2\t\t0x182\n#define I82975X_DRB_CH1R3\t\t0x183\n\n\n#define I82975X_DRA\t\t0x108\t \n#define I82975X_DRA_CH0R01\t\t0x108\n#define I82975X_DRA_CH0R23\t\t0x109\n#define I82975X_DRA_CH1R01\t\t0x188\n#define I82975X_DRA_CH1R23\t\t0x189\n\n\n#define I82975X_BNKARC\t0x10e  \n#define I82975X_C0BNKARC\t0x10e\n#define I82975X_C1BNKARC\t0x18e\n\n\n\n#define I82975X_DRC\t\t0x120  \n#define I82975X_DRC_CH0M0\t\t0x120\n#define I82975X_DRC_CH1M0\t\t0x1A0\n\n\n#define I82975X_DRC_M1\t0x124  \n\n#define I82975X_DRC_CH0M1\t\t0x124\n#define I82975X_DRC_CH1M1\t\t0x1A4\n\nenum i82975x_chips {\n\tI82975X = 0,\n};\n\nstruct i82975x_pvt {\n\tvoid __iomem *mch_window;\n};\n\nstruct i82975x_dev_info {\n\tconst char *ctl_name;\n};\n\nstruct i82975x_error_info {\n\tu16 errsts;\n\tu32 eap;\n\tu8 des;\n\tu8 derrsyn;\n\tu16 errsts2;\n\tu8 chan;\t\t \n\tu8 xeap;\t\t \n};\n\nstatic const struct i82975x_dev_info i82975x_devs[] = {\n\t[I82975X] = {\n\t\t.ctl_name = \"i82975x\"\n\t},\n};\n\nstatic struct pci_dev *mci_pdev;\t \n\nstatic int i82975x_registered = 1;\n\nstatic void i82975x_get_error_info(struct mem_ctl_info *mci,\n\t\tstruct i82975x_error_info *info)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(mci->pdev);\n\n\t \n\tpci_read_config_word(pdev, I82975X_ERRSTS, &info->errsts);\n\tpci_read_config_dword(pdev, I82975X_EAP, &info->eap);\n\tpci_read_config_byte(pdev, I82975X_XEAP, &info->xeap);\n\tpci_read_config_byte(pdev, I82975X_DES, &info->des);\n\tpci_read_config_byte(pdev, I82975X_DERRSYN, &info->derrsyn);\n\tpci_read_config_word(pdev, I82975X_ERRSTS, &info->errsts2);\n\n\tpci_write_bits16(pdev, I82975X_ERRSTS, 0x0003, 0x0003);\n\n\t \n\tif (!(info->errsts2 & 0x0003))\n\t\treturn;\n\n\tif ((info->errsts ^ info->errsts2) & 0x0003) {\n\t\tpci_read_config_dword(pdev, I82975X_EAP, &info->eap);\n\t\tpci_read_config_byte(pdev, I82975X_XEAP, &info->xeap);\n\t\tpci_read_config_byte(pdev, I82975X_DES, &info->des);\n\t\tpci_read_config_byte(pdev, I82975X_DERRSYN,\n\t\t\t\t&info->derrsyn);\n\t}\n}\n\nstatic int i82975x_process_error_info(struct mem_ctl_info *mci,\n\t\tstruct i82975x_error_info *info, int handle_errors)\n{\n\tint row, chan;\n\tunsigned long offst, page;\n\n\tif (!(info->errsts2 & 0x0003))\n\t\treturn 0;\n\n\tif (!handle_errors)\n\t\treturn 1;\n\n\tif ((info->errsts ^ info->errsts2) & 0x0003) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1, \"UE overwrote CE\", \"\");\n\t\tinfo->errsts = info->errsts2;\n\t}\n\n\tpage = (unsigned long) info->eap;\n\tpage >>= 1;\n\tif (info->xeap & 1)\n\t\tpage |= 0x80000000;\n\tpage >>= (PAGE_SHIFT - 1);\n\trow = edac_mc_find_csrow_by_page(mci, page);\n\n\tif (row == -1)\t{\n\t\ti82975x_mc_printk(mci, KERN_ERR, \"error processing EAP:\\n\"\n\t\t\t\"\\tXEAP=%u\\n\"\n\t\t\t\"\\t EAP=0x%08x\\n\"\n\t\t\t\"\\tPAGE=0x%08x\\n\",\n\t\t\t(info->xeap & 1) ? 1 : 0, info->eap, (unsigned int) page);\n\t\treturn 0;\n\t}\n\tchan = (mci->csrows[row]->nr_channels == 1) ? 0 : info->eap & 1;\n\toffst = info->eap\n\t\t\t& ((1 << PAGE_SHIFT) -\n\t\t\t   (1 << mci->csrows[row]->channels[chan]->dimm->grain));\n\n\tif (info->errsts & 0x0002)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     page, offst, 0,\n\t\t\t\t     row, -1, -1,\n\t\t\t\t     \"i82975x UE\", \"\");\n\telse\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t     page, offst, info->derrsyn,\n\t\t\t\t     row, chan ? chan : 0, -1,\n\t\t\t\t     \"i82975x CE\", \"\");\n\n\treturn 1;\n}\n\nstatic void i82975x_check(struct mem_ctl_info *mci)\n{\n\tstruct i82975x_error_info info;\n\n\ti82975x_get_error_info(mci, &info);\n\ti82975x_process_error_info(mci, &info, 1);\n}\n\n \nstatic int dual_channel_active(void __iomem *mch_window)\n{\n\t \n\tu8\tdrb[4][2];\n\tint\trow;\n\tint    dualch;\n\n\tfor (dualch = 1, row = 0; dualch && (row < 4); row++) {\n\t\tdrb[row][0] = readb(mch_window + I82975X_DRB + row);\n\t\tdrb[row][1] = readb(mch_window + I82975X_DRB + row + 0x80);\n\t\tdualch = dualch && (drb[row][0] == drb[row][1]);\n\t}\n\treturn dualch;\n}\n\nstatic void i82975x_init_csrows(struct mem_ctl_info *mci,\n\t\tstruct pci_dev *pdev, void __iomem *mch_window)\n{\n\tstruct csrow_info *csrow;\n\tunsigned long last_cumul_size;\n\tu8 value;\n\tu32 cumul_size, nr_pages;\n\tint index, chan;\n\tstruct dimm_info *dimm;\n\n\tlast_cumul_size = 0;\n\n\t \n\n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\tcsrow = mci->csrows[index];\n\n\t\tvalue = readb(mch_window + I82975X_DRB + index +\n\t\t\t\t\t((index >= 4) ? 0x80 : 0));\n\t\tcumul_size = value;\n\t\tcumul_size <<= (I82975X_DRB_SHIFT - PAGE_SHIFT);\n\t\t \n\t\tif (csrow->nr_channels > 1)\n\t\t\tcumul_size <<= 1;\n\t\tedac_dbg(3, \"(%d) cumul_size 0x%x\\n\", index, cumul_size);\n\n\t\tnr_pages = cumul_size - last_cumul_size;\n\t\tif (!nr_pages)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (chan = 0; chan < csrow->nr_channels; chan++) {\n\t\t\tdimm = mci->csrows[index]->channels[chan]->dimm;\n\n\t\t\tdimm->nr_pages = nr_pages / csrow->nr_channels;\n\n\t\t\tsnprintf(csrow->channels[chan]->dimm->label, EDAC_MC_LABEL_LEN, \"DIMM %c%d\",\n\t\t\t\t (chan == 0) ? 'A' : 'B',\n\t\t\t\t index);\n\t\t\tdimm->grain = 1 << 7;\t \n\n\t\t\t \n\t\t\tdimm->dtype = DEV_X8;\n\n\t\t\tdimm->mtype = MEM_DDR2;  \n\t\t\tdimm->edac_mode = EDAC_SECDED;  \n\t\t}\n\n\t\tcsrow->first_page = last_cumul_size;\n\t\tcsrow->last_page = cumul_size - 1;\n\t\tlast_cumul_size = cumul_size;\n\t}\n}\n\n \n\n#ifdef i82975x_DEBUG_IOMEM\nstatic void i82975x_print_dram_timings(void __iomem *mch_window)\n{\n\t \n\tstatic const int caslats[4] = { 5, 4, 3, 6 };\n\tu32\tdtreg[2];\n\n\tdtreg[0] = readl(mch_window + 0x114);\n\tdtreg[1] = readl(mch_window + 0x194);\n\ti82975x_printk(KERN_INFO, \"DRAM Timings :     Ch0    Ch1\\n\"\n\t\t\"                RAS Active Min = %d     %d\\n\"\n\t\t\"                CAS latency    =  %d      %d\\n\"\n\t\t\"                RAS to CAS     =  %d      %d\\n\"\n\t\t\"                RAS precharge  =  %d      %d\\n\",\n\t\t(dtreg[0] >> 19 ) & 0x0f,\n\t\t\t(dtreg[1] >> 19) & 0x0f,\n\t\tcaslats[(dtreg[0] >> 8) & 0x03],\n\t\t\tcaslats[(dtreg[1] >> 8) & 0x03],\n\t\t((dtreg[0] >> 4) & 0x07) + 2,\n\t\t\t((dtreg[1] >> 4) & 0x07) + 2,\n\t\t(dtreg[0] & 0x07) + 2,\n\t\t\t(dtreg[1] & 0x07) + 2\n\t);\n\n}\n#endif\n\nstatic int i82975x_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tint rc = -ENODEV;\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tstruct i82975x_pvt *pvt;\n\tvoid __iomem *mch_window;\n\tu32 mchbar;\n\tu32 drc[2];\n\tstruct i82975x_error_info discard;\n\tint\tchans;\n#ifdef i82975x_DEBUG_IOMEM\n\tu8 c0drb[4];\n\tu8 c1drb[4];\n#endif\n\n\tedac_dbg(0, \"\\n\");\n\n\tpci_read_config_dword(pdev, I82975X_MCHBAR, &mchbar);\n\tif (!(mchbar & 1)) {\n\t\tedac_dbg(3, \"failed, MCHBAR disabled!\\n\");\n\t\tgoto fail0;\n\t}\n\tmchbar &= 0xffffc000;\t \n\tmch_window = ioremap(mchbar, 0x1000);\n\tif (!mch_window) {\n\t\tedac_dbg(3, \"error ioremapping MCHBAR!\\n\");\n\t\tgoto fail0;\n\t}\n\n#ifdef i82975x_DEBUG_IOMEM\n\ti82975x_printk(KERN_INFO, \"MCHBAR real = %0x, remapped = %p\\n\",\n\t\t\t\t\tmchbar, mch_window);\n\n\tc0drb[0] = readb(mch_window + I82975X_DRB_CH0R0);\n\tc0drb[1] = readb(mch_window + I82975X_DRB_CH0R1);\n\tc0drb[2] = readb(mch_window + I82975X_DRB_CH0R2);\n\tc0drb[3] = readb(mch_window + I82975X_DRB_CH0R3);\n\tc1drb[0] = readb(mch_window + I82975X_DRB_CH1R0);\n\tc1drb[1] = readb(mch_window + I82975X_DRB_CH1R1);\n\tc1drb[2] = readb(mch_window + I82975X_DRB_CH1R2);\n\tc1drb[3] = readb(mch_window + I82975X_DRB_CH1R3);\n\ti82975x_printk(KERN_INFO, \"DRBCH0R0 = 0x%02x\\n\", c0drb[0]);\n\ti82975x_printk(KERN_INFO, \"DRBCH0R1 = 0x%02x\\n\", c0drb[1]);\n\ti82975x_printk(KERN_INFO, \"DRBCH0R2 = 0x%02x\\n\", c0drb[2]);\n\ti82975x_printk(KERN_INFO, \"DRBCH0R3 = 0x%02x\\n\", c0drb[3]);\n\ti82975x_printk(KERN_INFO, \"DRBCH1R0 = 0x%02x\\n\", c1drb[0]);\n\ti82975x_printk(KERN_INFO, \"DRBCH1R1 = 0x%02x\\n\", c1drb[1]);\n\ti82975x_printk(KERN_INFO, \"DRBCH1R2 = 0x%02x\\n\", c1drb[2]);\n\ti82975x_printk(KERN_INFO, \"DRBCH1R3 = 0x%02x\\n\", c1drb[3]);\n#endif\n\n\tdrc[0] = readl(mch_window + I82975X_DRC_CH0M0);\n\tdrc[1] = readl(mch_window + I82975X_DRC_CH1M0);\n#ifdef i82975x_DEBUG_IOMEM\n\ti82975x_printk(KERN_INFO, \"DRC_CH0 = %0x, %s\\n\", drc[0],\n\t\t\t((drc[0] >> 21) & 3) == 1 ?\n\t\t\t\t\"ECC enabled\" : \"ECC disabled\");\n\ti82975x_printk(KERN_INFO, \"DRC_CH1 = %0x, %s\\n\", drc[1],\n\t\t\t((drc[1] >> 21) & 3) == 1 ?\n\t\t\t\t\"ECC enabled\" : \"ECC disabled\");\n\n\ti82975x_printk(KERN_INFO, \"C0 BNKARC = %0x\\n\",\n\t\treadw(mch_window + I82975X_C0BNKARC));\n\ti82975x_printk(KERN_INFO, \"C1 BNKARC = %0x\\n\",\n\t\treadw(mch_window + I82975X_C1BNKARC));\n\ti82975x_print_dram_timings(mch_window);\n\tgoto fail1;\n#endif\n\tif (!(((drc[0] >> 21) & 3) == 1 || ((drc[1] >> 21) & 3) == 1)) {\n\t\ti82975x_printk(KERN_INFO, \"ECC disabled on both channels.\\n\");\n\t\tgoto fail1;\n\t}\n\n\tchans = dual_channel_active(mch_window) + 1;\n\n\t \n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = I82975X_NR_DIMMS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = I82975X_NR_CSROWS(chans);\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (!mci) {\n\t\trc = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tedac_dbg(3, \"init mci\\n\");\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_DDR2;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = i82975x_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = i82975x_check;\n\tmci->ctl_page_to_phys = NULL;\n\tedac_dbg(3, \"init pvt\\n\");\n\tpvt = (struct i82975x_pvt *) mci->pvt_info;\n\tpvt->mch_window = mch_window;\n\ti82975x_init_csrows(mci, pdev, mch_window);\n\tmci->scrub_mode = SCRUB_HW_SRC;\n\ti82975x_get_error_info(mci, &discard);   \n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"failed edac_mc_add_mc()\\n\");\n\t\tgoto fail2;\n\t}\n\n\t \n\tedac_dbg(3, \"success\\n\");\n\treturn 0;\n\nfail2:\n\tedac_mc_free(mci);\n\nfail1:\n\tiounmap(mch_window);\nfail0:\n\treturn rc;\n}\n\n \nstatic int i82975x_init_one(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tint rc;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (pci_enable_device(pdev) < 0)\n\t\treturn -EIO;\n\n\trc = i82975x_probe1(pdev, ent->driver_data);\n\n\tif (mci_pdev == NULL)\n\t\tmci_pdev = pci_dev_get(pdev);\n\n\treturn rc;\n}\n\nstatic void i82975x_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct i82975x_pvt *pvt;\n\n\tedac_dbg(0, \"\\n\");\n\n\tmci = edac_mc_del_mc(&pdev->dev);\n\tif (mci  == NULL)\n\t\treturn;\n\n\tpvt = mci->pvt_info;\n\tif (pvt->mch_window)\n\t\tiounmap( pvt->mch_window );\n\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id i82975x_pci_tbl[] = {\n\t{\n\t\tPCI_VEND_DEV(INTEL, 82975_0), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\tI82975X\n\t},\n\t{\n\t\t0,\n\t}\t \n};\n\nMODULE_DEVICE_TABLE(pci, i82975x_pci_tbl);\n\nstatic struct pci_driver i82975x_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = i82975x_init_one,\n\t.remove = i82975x_remove_one,\n\t.id_table = i82975x_pci_tbl,\n};\n\nstatic int __init i82975x_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(3, \"\\n\");\n\n\t \n\topstate_init();\n\n\tpci_rc = pci_register_driver(&i82975x_driver);\n\tif (pci_rc < 0)\n\t\tgoto fail0;\n\n\tif (mci_pdev == NULL) {\n\t\tmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_INTEL_82975_0, NULL);\n\n\t\tif (!mci_pdev) {\n\t\t\tedac_dbg(0, \"i82975x pci_get_device fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tpci_rc = i82975x_init_one(mci_pdev, i82975x_pci_tbl);\n\n\t\tif (pci_rc < 0) {\n\t\t\tedac_dbg(0, \"i82975x init fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail1:\n\tpci_unregister_driver(&i82975x_driver);\n\nfail0:\n\tpci_dev_put(mci_pdev);\n\treturn pci_rc;\n}\n\nstatic void __exit i82975x_exit(void)\n{\n\tedac_dbg(3, \"\\n\");\n\n\tpci_unregister_driver(&i82975x_driver);\n\n\tif (!i82975x_registered) {\n\t\ti82975x_remove_one(mci_pdev);\n\t\tpci_dev_put(mci_pdev);\n\t}\n}\n\nmodule_init(i82975x_init);\nmodule_exit(i82975x_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Arvind R. <arvino55@gmail.com>\");\nMODULE_DESCRIPTION(\"MC support for Intel 82975 memory hub controllers\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}