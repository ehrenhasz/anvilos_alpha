{
  "module_name": "cpc925_edac.c",
  "hash_id": "0a738a6b4871a093a5d0bbcd17c319c702024e34b9fb0201f978c8628e91b655",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/cpc925_edac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/edac.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/gfp.h>\n\n#include \"edac_module.h\"\n\n#define CPC925_EDAC_REVISION\t\" Ver: 1.0.0\"\n#define CPC925_EDAC_MOD_STR\t\"cpc925_edac\"\n\n#define cpc925_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"CPC925\", fmt, ##arg)\n\n#define cpc925_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"CPC925\", fmt, ##arg)\n\n \n#define CPC925_BITS_PER_REG\t32\n#define CPC925_BIT(nr)\t\t(1UL << (CPC925_BITS_PER_REG - 1 - nr))\n\n \n#define CPC925_CPU_ERR_DEV\t\"cpu\"\n#define CPC925_HT_LINK_DEV\t\"htlink\"\n\n \n#define CPC925_REF_FREQ\t\t0xFA69\n#define CPC925_SCRUB_BLOCK_SIZE 64\t \n#define CPC925_NR_CSROWS\t8\n\n \n\n \n \n#define REG_APIMASK_OFFSET\t0x30070\nenum apimask_bits {\n\tAPIMASK_DART\t= CPC925_BIT(0),  \n\tAPIMASK_ADI0\t= CPC925_BIT(1),  \n\tAPIMASK_ADI1\t= CPC925_BIT(2),  \n\tAPIMASK_STAT\t= CPC925_BIT(3),  \n\tAPIMASK_DERR\t= CPC925_BIT(4),  \n\tAPIMASK_ADRS0\t= CPC925_BIT(5),  \n\tAPIMASK_ADRS1\t= CPC925_BIT(6),  \n\t\t\t\t\t  \n\tAPIMASK_ECC_UE_H = CPC925_BIT(8),  \n\tAPIMASK_ECC_CE_H = CPC925_BIT(9),  \n\tAPIMASK_ECC_UE_L = CPC925_BIT(10),  \n\tAPIMASK_ECC_CE_L = CPC925_BIT(11),  \n\n\tCPU_MASK_ENABLE = (APIMASK_DART | APIMASK_ADI0 | APIMASK_ADI1 |\n\t\t\t   APIMASK_STAT | APIMASK_DERR | APIMASK_ADRS0 |\n\t\t\t   APIMASK_ADRS1),\n\tECC_MASK_ENABLE = (APIMASK_ECC_UE_H | APIMASK_ECC_CE_H |\n\t\t\t   APIMASK_ECC_UE_L | APIMASK_ECC_CE_L),\n};\n#define APIMASK_ADI(n)\t\tCPC925_BIT(((n)+1))\n\n \n#define REG_APIEXCP_OFFSET\t0x30060\nenum apiexcp_bits {\n\tAPIEXCP_DART\t= CPC925_BIT(0),  \n\tAPIEXCP_ADI0\t= CPC925_BIT(1),  \n\tAPIEXCP_ADI1\t= CPC925_BIT(2),  \n\tAPIEXCP_STAT\t= CPC925_BIT(3),  \n\tAPIEXCP_DERR\t= CPC925_BIT(4),  \n\tAPIEXCP_ADRS0\t= CPC925_BIT(5),  \n\tAPIEXCP_ADRS1\t= CPC925_BIT(6),  \n\t\t\t\t\t  \n\tAPIEXCP_ECC_UE_H = CPC925_BIT(8),  \n\tAPIEXCP_ECC_CE_H = CPC925_BIT(9),  \n\tAPIEXCP_ECC_UE_L = CPC925_BIT(10),  \n\tAPIEXCP_ECC_CE_L = CPC925_BIT(11),  \n\n\tCPU_EXCP_DETECTED = (APIEXCP_DART | APIEXCP_ADI0 | APIEXCP_ADI1 |\n\t\t\t     APIEXCP_STAT | APIEXCP_DERR | APIEXCP_ADRS0 |\n\t\t\t     APIEXCP_ADRS1),\n\tUECC_EXCP_DETECTED = (APIEXCP_ECC_UE_H | APIEXCP_ECC_UE_L),\n\tCECC_EXCP_DETECTED = (APIEXCP_ECC_CE_H | APIEXCP_ECC_CE_L),\n\tECC_EXCP_DETECTED = (UECC_EXCP_DETECTED | CECC_EXCP_DETECTED),\n};\n\n \n#define REG_MBCR_OFFSET\t\t0x2190\n#define MBCR_64BITCFG_SHIFT\t23\n#define MBCR_64BITCFG_MASK\t(1UL << MBCR_64BITCFG_SHIFT)\n#define MBCR_64BITBUS_SHIFT\t22\n#define MBCR_64BITBUS_MASK\t(1UL << MBCR_64BITBUS_SHIFT)\n\n \n#define REG_MBMR_OFFSET\t\t0x21C0\n#define MBMR_MODE_MAX_VALUE\t0xF\n#define MBMR_MODE_SHIFT\t\t25\n#define MBMR_MODE_MASK\t\t(MBMR_MODE_MAX_VALUE << MBMR_MODE_SHIFT)\n#define MBMR_BBA_SHIFT\t\t24\n#define MBMR_BBA_MASK\t\t(1UL << MBMR_BBA_SHIFT)\n\n \n#define REG_MBBAR_OFFSET\t0x21D0\n#define MBBAR_BBA_MAX_VALUE\t0xFF\n#define MBBAR_BBA_SHIFT\t\t24\n#define MBBAR_BBA_MASK\t\t(MBBAR_BBA_MAX_VALUE << MBBAR_BBA_SHIFT)\n\n \n#define REG_MSCR_OFFSET\t\t0x2400\n#define MSCR_SCRUB_MOD_MASK\t0xC0000000  \n#define MSCR_BACKGR_SCRUB\t0x40000000  \n#define MSCR_SI_SHIFT\t\t16 \t \n#define MSCR_SI_MAX_VALUE\t0xFF\n#define MSCR_SI_MASK\t\t(MSCR_SI_MAX_VALUE << MSCR_SI_SHIFT)\n\n \n#define REG_MSRSR_OFFSET\t0x2410\n\n \n#define REG_MSRER_OFFSET\t0x2420\n\n \n#define REG_MSPR_OFFSET\t\t0x2430\n\n \n#define REG_MCCR_OFFSET\t\t0x2440\nenum mccr_bits {\n\tMCCR_ECC_EN\t= CPC925_BIT(0),  \n};\n\n \n#define REG_MCRER_OFFSET\t0x2450\n\n \n#define REG_MEAR_OFFSET\t\t0x2460\n#define MEAR_BCNT_MAX_VALUE\t0x3\n#define MEAR_BCNT_SHIFT\t\t30\n#define MEAR_BCNT_MASK\t\t(MEAR_BCNT_MAX_VALUE << MEAR_BCNT_SHIFT)\n#define MEAR_RANK_MAX_VALUE\t0x7\n#define MEAR_RANK_SHIFT\t\t27\n#define MEAR_RANK_MASK\t\t(MEAR_RANK_MAX_VALUE << MEAR_RANK_SHIFT)\n#define MEAR_COL_MAX_VALUE\t0x7FF\n#define MEAR_COL_SHIFT\t\t16\n#define MEAR_COL_MASK\t\t(MEAR_COL_MAX_VALUE << MEAR_COL_SHIFT)\n#define MEAR_BANK_MAX_VALUE\t0x3\n#define MEAR_BANK_SHIFT\t\t14\n#define MEAR_BANK_MASK\t\t(MEAR_BANK_MAX_VALUE << MEAR_BANK_SHIFT)\n#define MEAR_ROW_MASK\t\t0x00003FFF\n\n \n#define REG_MESR_OFFSET\t\t0x2470\n#define MESR_ECC_SYN_H_MASK\t0xFF00\n#define MESR_ECC_SYN_L_MASK\t0x00FF\n\n \n#define REG_MMCR_OFFSET\t\t0x2500\nenum mmcr_bits {\n\tMMCR_REG_DIMM_MODE = CPC925_BIT(3),\n};\n\n \n \n#define REG_ERRCTRL_OFFSET\t0x70140\nenum errctrl_bits {\t\t\t  \n\tERRCTRL_SERR_NF\t= CPC925_BIT(0),  \n\tERRCTRL_CRC_NF\t= CPC925_BIT(1),  \n\tERRCTRL_RSP_NF\t= CPC925_BIT(2),  \n\tERRCTRL_EOC_NF\t= CPC925_BIT(3),  \n\tERRCTRL_OVF_NF\t= CPC925_BIT(4),  \n\tERRCTRL_PROT_NF\t= CPC925_BIT(5),  \n\n\tERRCTRL_RSP_ERR\t= CPC925_BIT(6),  \n\tERRCTRL_CHN_FAL = CPC925_BIT(7),  \n\n\tHT_ERRCTRL_ENABLE = (ERRCTRL_SERR_NF | ERRCTRL_CRC_NF |\n\t\t\t     ERRCTRL_RSP_NF | ERRCTRL_EOC_NF |\n\t\t\t     ERRCTRL_OVF_NF | ERRCTRL_PROT_NF),\n\tHT_ERRCTRL_DETECTED = (ERRCTRL_RSP_ERR | ERRCTRL_CHN_FAL),\n};\n\n \n#define REG_LINKCTRL_OFFSET\t0x70110\nenum linkctrl_bits {\n\tLINKCTRL_CRC_ERR\t= (CPC925_BIT(22) | CPC925_BIT(23)),\n\tLINKCTRL_LINK_FAIL\t= CPC925_BIT(27),\n\n\tHT_LINKCTRL_DETECTED\t= (LINKCTRL_CRC_ERR | LINKCTRL_LINK_FAIL),\n};\n\n \n#define REG_LINKERR_OFFSET\t0x70120\nenum linkerr_bits {\n\tLINKERR_EOC_ERR\t\t= CPC925_BIT(17),  \n\tLINKERR_OVF_ERR\t\t= CPC925_BIT(18),  \n\tLINKERR_PROT_ERR\t= CPC925_BIT(19),  \n\n\tHT_LINKERR_DETECTED\t= (LINKERR_EOC_ERR | LINKERR_OVF_ERR |\n\t\t\t\t   LINKERR_PROT_ERR),\n};\n\n \n#define REG_BRGCTRL_OFFSET\t0x70300\nenum brgctrl_bits {\n\tBRGCTRL_DETSERR = CPC925_BIT(0),  \n\tBRGCTRL_SECBUSRESET = CPC925_BIT(9),  \n};\n\n \nstruct cpc925_mc_pdata {\n\tvoid __iomem *vbase;\n\tunsigned long total_mem;\n\tconst char *name;\n\tint edac_idx;\n};\n\n \nstruct cpc925_dev_info {\n\tvoid __iomem *vbase;\n\tstruct platform_device *pdev;\n\tchar *ctl_name;\n\tint edac_idx;\n\tstruct edac_device_ctl_info *edac_dev;\n\tvoid (*init)(struct cpc925_dev_info *dev_info);\n\tvoid (*exit)(struct cpc925_dev_info *dev_info);\n\tvoid (*check)(struct edac_device_ctl_info *edac_dev);\n};\n\n \nstatic void get_total_mem(struct cpc925_mc_pdata *pdata)\n{\n\tstruct device_node *np = NULL;\n\tconst unsigned int *reg, *reg_end;\n\tint len, sw, aw;\n\tunsigned long start, size;\n\n\tnp = of_find_node_by_type(NULL, \"memory\");\n\tif (!np)\n\t\treturn;\n\n\taw = of_n_addr_cells(np);\n\tsw = of_n_size_cells(np);\n\treg = (const unsigned int *)of_get_property(np, \"reg\", &len);\n\treg_end = reg + len/4;\n\n\tpdata->total_mem = 0;\n\tdo {\n\t\tstart = of_read_number(reg, aw);\n\t\treg += aw;\n\t\tsize = of_read_number(reg, sw);\n\t\treg += sw;\n\t\tedac_dbg(1, \"start 0x%lx, size 0x%lx\\n\", start, size);\n\t\tpdata->total_mem += size;\n\t} while (reg < reg_end);\n\n\tof_node_put(np);\n\tedac_dbg(0, \"total_mem 0x%lx\\n\", pdata->total_mem);\n}\n\nstatic void cpc925_init_csrows(struct mem_ctl_info *mci)\n{\n\tstruct cpc925_mc_pdata *pdata = mci->pvt_info;\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\tenum dev_type dtype;\n\tint index, j;\n\tu32 mbmr, mbbar, bba, grain;\n\tunsigned long row_size, nr_pages, last_nr_pages = 0;\n\n\tget_total_mem(pdata);\n\n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\tmbmr = __raw_readl(pdata->vbase + REG_MBMR_OFFSET +\n\t\t\t\t   0x20 * index);\n\t\tmbbar = __raw_readl(pdata->vbase + REG_MBBAR_OFFSET +\n\t\t\t\t   0x20 + index);\n\t\tbba = (((mbmr & MBMR_BBA_MASK) >> MBMR_BBA_SHIFT) << 8) |\n\t\t       ((mbbar & MBBAR_BBA_MASK) >> MBBAR_BBA_SHIFT);\n\n\t\tif (bba == 0)\n\t\t\tcontinue;  \n\n\t\tcsrow = mci->csrows[index];\n\n\t\trow_size = bba * (1UL << 28);\t \n\t\tcsrow->first_page = last_nr_pages;\n\t\tnr_pages = row_size >> PAGE_SHIFT;\n\t\tcsrow->last_page = csrow->first_page + nr_pages - 1;\n\t\tlast_nr_pages = csrow->last_page + 1;\n\n\t\tswitch (csrow->nr_channels) {\n\t\tcase 1:  \n\t\t\tgrain = 32;  \n\t\t\tbreak;\n\t\tcase 2:  \n\t\tdefault:\n\t\t\tgrain = 64;  \n\t\t\tbreak;\n\t\t}\n\t\tswitch ((mbmr & MBMR_MODE_MASK) >> MBMR_MODE_SHIFT) {\n\t\tcase 6:  \n\t\tcase 5:\t \n\t\tcase 8:  \n\t\t\tdtype = DEV_X16;\n\t\t\tbreak;\n\t\tcase 7:  \n\t\tcase 9:  \n\t\t\tdtype = DEV_X8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdtype = DEV_UNKNOWN;\n\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < csrow->nr_channels; j++) {\n\t\t\tdimm = csrow->channels[j]->dimm;\n\t\t\tdimm->nr_pages = nr_pages / csrow->nr_channels;\n\t\t\tdimm->mtype = MEM_RDDR;\n\t\t\tdimm->edac_mode = EDAC_SECDED;\n\t\t\tdimm->grain = grain;\n\t\t\tdimm->dtype = dtype;\n\t\t}\n\t}\n}\n\n \nstatic void cpc925_mc_init(struct mem_ctl_info *mci)\n{\n\tstruct cpc925_mc_pdata *pdata = mci->pvt_info;\n\tu32 apimask;\n\tu32 mccr;\n\n\t \n\tapimask = __raw_readl(pdata->vbase + REG_APIMASK_OFFSET);\n\tif ((apimask & ECC_MASK_ENABLE) == 0) {\n\t\tapimask |= ECC_MASK_ENABLE;\n\t\t__raw_writel(apimask, pdata->vbase + REG_APIMASK_OFFSET);\n\t}\n\n\t \n\tmccr = __raw_readl(pdata->vbase + REG_MCCR_OFFSET);\n\tif ((mccr & MCCR_ECC_EN) == 0) {\n\t\tmccr |= MCCR_ECC_EN;\n\t\t__raw_writel(mccr, pdata->vbase + REG_MCCR_OFFSET);\n\t}\n}\n\n \nstatic void cpc925_mc_exit(struct mem_ctl_info *mci)\n{\n\t \n\n\treturn;\n}\n\n \nstatic void cpc925_mc_get_pfn(struct mem_ctl_info *mci, u32 mear,\n\t\tunsigned long *pfn, unsigned long *offset, int *csrow)\n{\n\tu32 bcnt, rank, col, bank, row;\n\tu32 c;\n\tunsigned long pa;\n\tint i;\n\n\tbcnt = (mear & MEAR_BCNT_MASK) >> MEAR_BCNT_SHIFT;\n\trank = (mear & MEAR_RANK_MASK) >> MEAR_RANK_SHIFT;\n\tcol = (mear & MEAR_COL_MASK) >> MEAR_COL_SHIFT;\n\tbank = (mear & MEAR_BANK_MASK) >> MEAR_BANK_SHIFT;\n\trow = mear & MEAR_ROW_MASK;\n\n\t*csrow = rank;\n\n#ifdef CONFIG_EDAC_DEBUG\n\tif (mci->csrows[rank]->first_page == 0) {\n\t\tcpc925_mc_printk(mci, KERN_ERR, \"ECC occurs in a \"\n\t\t\t\"non-populated csrow, broken hardware?\\n\");\n\t\treturn;\n\t}\n#endif\n\n\t \n\tpa = mci->csrows[rank]->first_page << PAGE_SHIFT;\n\n\t \n\tcol += bcnt;\n\tfor (i = 0; i < 11; i++) {\n\t\tc = col & 0x1;\n\t\tcol >>= 1;\n\t\tpa |= c << (14 - i);\n\t}\n\n\t \n\tpa |= bank << 19;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tc = row & 0x1;\n\t\trow >>= 1;\n\t\tpa |= c << (26 - i);\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tc = row & 0x1;\n\t\trow >>= 1;\n\t\tpa |= c << (21 + i);\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tc = row & 0x1;\n\t\trow >>= 1;\n\t\tpa |= c << (18 - i);\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tc = row & 0x1;\n\t\trow >>= 1;\n\t\tpa |= c << (29 - i);\n\t}\n\n\t*offset = pa & (PAGE_SIZE - 1);\n\t*pfn = pa >> PAGE_SHIFT;\n\n\tedac_dbg(0, \"ECC physical address 0x%lx\\n\", pa);\n}\n\nstatic int cpc925_mc_find_channel(struct mem_ctl_info *mci, u16 syndrome)\n{\n\tif ((syndrome & MESR_ECC_SYN_H_MASK) == 0)\n\t\treturn 0;\n\n\tif ((syndrome & MESR_ECC_SYN_L_MASK) == 0)\n\t\treturn 1;\n\n\tcpc925_mc_printk(mci, KERN_INFO, \"Unexpected syndrome value: 0x%x\\n\",\n\t\t\t syndrome);\n\treturn 1;\n}\n\n \nstatic void cpc925_mc_check(struct mem_ctl_info *mci)\n{\n\tstruct cpc925_mc_pdata *pdata = mci->pvt_info;\n\tu32 apiexcp;\n\tu32 mear;\n\tu32 mesr;\n\tu16 syndrome;\n\tunsigned long pfn = 0, offset = 0;\n\tint csrow = 0, channel = 0;\n\n\t \n\tapiexcp = __raw_readl(pdata->vbase + REG_APIEXCP_OFFSET);\n\tif ((apiexcp & ECC_EXCP_DETECTED) == 0)\n\t\treturn;\n\n\tmesr = __raw_readl(pdata->vbase + REG_MESR_OFFSET);\n\tsyndrome = mesr | (MESR_ECC_SYN_H_MASK | MESR_ECC_SYN_L_MASK);\n\n\tmear = __raw_readl(pdata->vbase + REG_MEAR_OFFSET);\n\n\t \n\tcpc925_mc_get_pfn(mci, mear, &pfn, &offset, &csrow);\n\n\tif (apiexcp & CECC_EXCP_DETECTED) {\n\t\tcpc925_mc_printk(mci, KERN_INFO, \"DRAM CECC Fault\\n\");\n\t\tchannel = cpc925_mc_find_channel(mci, syndrome);\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t     pfn, offset, syndrome,\n\t\t\t\t     csrow, channel, -1,\n\t\t\t\t     mci->ctl_name, \"\");\n\t}\n\n\tif (apiexcp & UECC_EXCP_DETECTED) {\n\t\tcpc925_mc_printk(mci, KERN_INFO, \"DRAM UECC Fault\\n\");\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     pfn, offset, 0,\n\t\t\t\t     csrow, -1, -1,\n\t\t\t\t     mci->ctl_name, \"\");\n\t}\n\n\tcpc925_mc_printk(mci, KERN_INFO, \"Dump registers:\\n\");\n\tcpc925_mc_printk(mci, KERN_INFO, \"APIMASK\t\t0x%08x\\n\",\n\t\t__raw_readl(pdata->vbase + REG_APIMASK_OFFSET));\n\tcpc925_mc_printk(mci, KERN_INFO, \"APIEXCP\t\t0x%08x\\n\",\n\t\tapiexcp);\n\tcpc925_mc_printk(mci, KERN_INFO, \"Mem Scrub Ctrl\t0x%08x\\n\",\n\t\t__raw_readl(pdata->vbase + REG_MSCR_OFFSET));\n\tcpc925_mc_printk(mci, KERN_INFO, \"Mem Scrub Rge Start\t0x%08x\\n\",\n\t\t__raw_readl(pdata->vbase + REG_MSRSR_OFFSET));\n\tcpc925_mc_printk(mci, KERN_INFO, \"Mem Scrub Rge End\t0x%08x\\n\",\n\t\t__raw_readl(pdata->vbase + REG_MSRER_OFFSET));\n\tcpc925_mc_printk(mci, KERN_INFO, \"Mem Scrub Pattern\t0x%08x\\n\",\n\t\t__raw_readl(pdata->vbase + REG_MSPR_OFFSET));\n\tcpc925_mc_printk(mci, KERN_INFO, \"Mem Chk Ctrl\t\t0x%08x\\n\",\n\t\t__raw_readl(pdata->vbase + REG_MCCR_OFFSET));\n\tcpc925_mc_printk(mci, KERN_INFO, \"Mem Chk Rge End\t0x%08x\\n\",\n\t\t__raw_readl(pdata->vbase + REG_MCRER_OFFSET));\n\tcpc925_mc_printk(mci, KERN_INFO, \"Mem Err Address\t0x%08x\\n\",\n\t\tmesr);\n\tcpc925_mc_printk(mci, KERN_INFO, \"Mem Err Syndrome\t0x%08x\\n\",\n\t\tsyndrome);\n}\n\n \nstatic u32 cpc925_cpu_mask_disabled(void)\n{\n\tstruct device_node *cpunode;\n\tstatic u32 mask = 0;\n\n\t \n\tif (mask != 0)\n\t\treturn mask;\n\n\tmask = APIMASK_ADI0 | APIMASK_ADI1;\n\n\tfor_each_of_cpu_node(cpunode) {\n\t\tconst u32 *reg = of_get_property(cpunode, \"reg\", NULL);\n\t\tif (reg == NULL || *reg > 2) {\n\t\t\tcpc925_printk(KERN_ERR, \"Bad reg value at %pOF\\n\", cpunode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmask &= ~APIMASK_ADI(*reg);\n\t}\n\n\tif (mask != (APIMASK_ADI0 | APIMASK_ADI1)) {\n\t\t \n\t\tcpc925_printk(KERN_WARNING,\n\t\t\t\t\"Assuming PI id is equal to CPU MPIC id!\\n\");\n\t}\n\n\treturn mask;\n}\n\n \nstatic void cpc925_cpu_init(struct cpc925_dev_info *dev_info)\n{\n\tu32 apimask;\n\tu32 cpumask;\n\n\tapimask = __raw_readl(dev_info->vbase + REG_APIMASK_OFFSET);\n\n\tcpumask = cpc925_cpu_mask_disabled();\n\tif (apimask & cpumask) {\n\t\tcpc925_printk(KERN_WARNING, \"CPU(s) not present, \"\n\t\t\t\t\"but enabled in APIMASK, disabling\\n\");\n\t\tapimask &= ~cpumask;\n\t}\n\n\tif ((apimask & CPU_MASK_ENABLE) == 0)\n\t\tapimask |= CPU_MASK_ENABLE;\n\n\t__raw_writel(apimask, dev_info->vbase + REG_APIMASK_OFFSET);\n}\n\n \nstatic void cpc925_cpu_exit(struct cpc925_dev_info *dev_info)\n{\n\t \n\n\treturn;\n}\n\n \nstatic void cpc925_cpu_check(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct cpc925_dev_info *dev_info = edac_dev->pvt_info;\n\tu32 apiexcp;\n\tu32 apimask;\n\n\t \n\tapiexcp = __raw_readl(dev_info->vbase + REG_APIEXCP_OFFSET);\n\tif ((apiexcp & CPU_EXCP_DETECTED) == 0)\n\t\treturn;\n\n\tif ((apiexcp & ~cpc925_cpu_mask_disabled()) == 0)\n\t\treturn;\n\n\tapimask = __raw_readl(dev_info->vbase + REG_APIMASK_OFFSET);\n\tcpc925_printk(KERN_INFO, \"Processor Interface Fault\\n\"\n\t\t\t\t \"Processor Interface register dump:\\n\");\n\tcpc925_printk(KERN_INFO, \"APIMASK\t\t0x%08x\\n\", apimask);\n\tcpc925_printk(KERN_INFO, \"APIEXCP\t\t0x%08x\\n\", apiexcp);\n\n\tedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\n}\n\n \n \nstatic void cpc925_htlink_init(struct cpc925_dev_info *dev_info)\n{\n\tu32 ht_errctrl;\n\n\tht_errctrl = __raw_readl(dev_info->vbase + REG_ERRCTRL_OFFSET);\n\tif ((ht_errctrl & HT_ERRCTRL_ENABLE) == 0) {\n\t\tht_errctrl |= HT_ERRCTRL_ENABLE;\n\t\t__raw_writel(ht_errctrl, dev_info->vbase + REG_ERRCTRL_OFFSET);\n\t}\n}\n\n \nstatic void cpc925_htlink_exit(struct cpc925_dev_info *dev_info)\n{\n\tu32 ht_errctrl;\n\n\tht_errctrl = __raw_readl(dev_info->vbase + REG_ERRCTRL_OFFSET);\n\tht_errctrl &= ~HT_ERRCTRL_ENABLE;\n\t__raw_writel(ht_errctrl, dev_info->vbase + REG_ERRCTRL_OFFSET);\n}\n\n \nstatic void cpc925_htlink_check(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct cpc925_dev_info *dev_info = edac_dev->pvt_info;\n\tu32 brgctrl = __raw_readl(dev_info->vbase + REG_BRGCTRL_OFFSET);\n\tu32 linkctrl = __raw_readl(dev_info->vbase + REG_LINKCTRL_OFFSET);\n\tu32 errctrl = __raw_readl(dev_info->vbase + REG_ERRCTRL_OFFSET);\n\tu32 linkerr = __raw_readl(dev_info->vbase + REG_LINKERR_OFFSET);\n\n\tif (!((brgctrl & BRGCTRL_DETSERR) ||\n\t      (linkctrl & HT_LINKCTRL_DETECTED) ||\n\t      (errctrl & HT_ERRCTRL_DETECTED) ||\n\t      (linkerr & HT_LINKERR_DETECTED)))\n\t\treturn;\n\n\tcpc925_printk(KERN_INFO, \"HT Link Fault\\n\"\n\t\t\t\t \"HT register dump:\\n\");\n\tcpc925_printk(KERN_INFO, \"Bridge Ctrl\t\t\t0x%08x\\n\",\n\t\t      brgctrl);\n\tcpc925_printk(KERN_INFO, \"Link Config Ctrl\t\t0x%08x\\n\",\n\t\t      linkctrl);\n\tcpc925_printk(KERN_INFO, \"Error Enum and Ctrl\t\t0x%08x\\n\",\n\t\t      errctrl);\n\tcpc925_printk(KERN_INFO, \"Link Error\t\t\t0x%08x\\n\",\n\t\t      linkerr);\n\n\t \n\tif (brgctrl & BRGCTRL_DETSERR)\n\t\t__raw_writel(BRGCTRL_DETSERR,\n\t\t\t\tdev_info->vbase + REG_BRGCTRL_OFFSET);\n\n\tif (linkctrl & HT_LINKCTRL_DETECTED)\n\t\t__raw_writel(HT_LINKCTRL_DETECTED,\n\t\t\t\tdev_info->vbase + REG_LINKCTRL_OFFSET);\n\n\t \n\tif (errctrl & ERRCTRL_CHN_FAL)\n\t\t__raw_writel(BRGCTRL_SECBUSRESET,\n\t\t\t\tdev_info->vbase + REG_BRGCTRL_OFFSET);\n\n\tif (errctrl & ERRCTRL_RSP_ERR)\n\t\t__raw_writel(ERRCTRL_RSP_ERR,\n\t\t\t\tdev_info->vbase + REG_ERRCTRL_OFFSET);\n\n\tif (linkerr & HT_LINKERR_DETECTED)\n\t\t__raw_writel(HT_LINKERR_DETECTED,\n\t\t\t\tdev_info->vbase + REG_LINKERR_OFFSET);\n\n\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n}\n\nstatic struct cpc925_dev_info cpc925_devs[] = {\n\t{\n\t.ctl_name = CPC925_CPU_ERR_DEV,\n\t.init = cpc925_cpu_init,\n\t.exit = cpc925_cpu_exit,\n\t.check = cpc925_cpu_check,\n\t},\n\t{\n\t.ctl_name = CPC925_HT_LINK_DEV,\n\t.init = cpc925_htlink_init,\n\t.exit = cpc925_htlink_exit,\n\t.check = cpc925_htlink_check,\n\t},\n\t{ }\n};\n\n \nstatic void cpc925_add_edac_devices(void __iomem *vbase)\n{\n\tstruct cpc925_dev_info *dev_info;\n\n\tif (!vbase) {\n\t\tcpc925_printk(KERN_ERR, \"MMIO not established yet\\n\");\n\t\treturn;\n\t}\n\n\tfor (dev_info = &cpc925_devs[0]; dev_info->init; dev_info++) {\n\t\tdev_info->vbase = vbase;\n\t\tdev_info->pdev = platform_device_register_simple(\n\t\t\t\t\tdev_info->ctl_name, 0, NULL, 0);\n\t\tif (IS_ERR(dev_info->pdev)) {\n\t\t\tcpc925_printk(KERN_ERR,\n\t\t\t\t\"Can't register platform device for %s\\n\",\n\t\t\t\tdev_info->ctl_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdev_info->edac_idx = edac_device_alloc_index();\n\t\tdev_info->edac_dev =\n\t\t\tedac_device_alloc_ctl_info(0, dev_info->ctl_name,\n\t\t\t\t1, NULL, 0, 0, NULL, 0, dev_info->edac_idx);\n\t\tif (!dev_info->edac_dev) {\n\t\t\tcpc925_printk(KERN_ERR, \"No memory for edac device\\n\");\n\t\t\tgoto err1;\n\t\t}\n\n\t\tdev_info->edac_dev->pvt_info = dev_info;\n\t\tdev_info->edac_dev->dev = &dev_info->pdev->dev;\n\t\tdev_info->edac_dev->ctl_name = dev_info->ctl_name;\n\t\tdev_info->edac_dev->mod_name = CPC925_EDAC_MOD_STR;\n\t\tdev_info->edac_dev->dev_name = dev_name(&dev_info->pdev->dev);\n\n\t\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\t\tdev_info->edac_dev->edac_check = dev_info->check;\n\n\t\tif (dev_info->init)\n\t\t\tdev_info->init(dev_info);\n\n\t\tif (edac_device_add_device(dev_info->edac_dev) > 0) {\n\t\t\tcpc925_printk(KERN_ERR,\n\t\t\t\t\"Unable to add edac device for %s\\n\",\n\t\t\t\tdev_info->ctl_name);\n\t\t\tgoto err2;\n\t\t}\n\n\t\tedac_dbg(0, \"Successfully added edac device for %s\\n\",\n\t\t\t dev_info->ctl_name);\n\n\t\tcontinue;\n\nerr2:\n\t\tif (dev_info->exit)\n\t\t\tdev_info->exit(dev_info);\n\t\tedac_device_free_ctl_info(dev_info->edac_dev);\nerr1:\n\t\tplatform_device_unregister(dev_info->pdev);\n\t}\n}\n\n \nstatic void cpc925_del_edac_devices(void)\n{\n\tstruct cpc925_dev_info *dev_info;\n\n\tfor (dev_info = &cpc925_devs[0]; dev_info->init; dev_info++) {\n\t\tif (dev_info->edac_dev) {\n\t\t\tedac_device_del_device(dev_info->edac_dev->dev);\n\t\t\tedac_device_free_ctl_info(dev_info->edac_dev);\n\t\t\tplatform_device_unregister(dev_info->pdev);\n\t\t}\n\n\t\tif (dev_info->exit)\n\t\t\tdev_info->exit(dev_info);\n\n\t\tedac_dbg(0, \"Successfully deleted edac device for %s\\n\",\n\t\t\t dev_info->ctl_name);\n\t}\n}\n\n \nstatic int cpc925_get_sdram_scrub_rate(struct mem_ctl_info *mci)\n{\n\tstruct cpc925_mc_pdata *pdata = mci->pvt_info;\n\tint bw;\n\tu32 mscr;\n\tu8 si;\n\n\tmscr = __raw_readl(pdata->vbase + REG_MSCR_OFFSET);\n\tsi = (mscr & MSCR_SI_MASK) >> MSCR_SI_SHIFT;\n\n\tedac_dbg(0, \"Mem Scrub Ctrl Register 0x%x\\n\", mscr);\n\n\tif (((mscr & MSCR_SCRUB_MOD_MASK) != MSCR_BACKGR_SCRUB) ||\n\t    (si == 0)) {\n\t\tcpc925_mc_printk(mci, KERN_INFO, \"Scrub mode not enabled\\n\");\n\t\tbw = 0;\n\t} else\n\t\tbw = CPC925_SCRUB_BLOCK_SIZE * 0xFA67 / si;\n\n\treturn bw;\n}\n\n \nstatic int cpc925_mc_get_channels(void __iomem *vbase)\n{\n\tint dual = 0;\n\tu32 mbcr;\n\n\tmbcr = __raw_readl(vbase + REG_MBCR_OFFSET);\n\n\t \n\tif (((mbcr & MBCR_64BITCFG_MASK) == 0) &&\n\t    ((mbcr & MBCR_64BITBUS_MASK) == 0))\n\t\tdual = 1;\n\n\tedac_dbg(0, \"%s channel\\n\", (dual > 0) ? \"Dual\" : \"Single\");\n\n\treturn dual;\n}\n\nstatic int cpc925_probe(struct platform_device *pdev)\n{\n\tstatic int edac_mc_idx;\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tvoid __iomem *vbase;\n\tstruct cpc925_mc_pdata *pdata;\n\tstruct resource *r;\n\tint res = 0, nr_channels;\n\n\tedac_dbg(0, \"%s platform device found!\\n\", pdev->name);\n\n\tif (!devres_open_group(&pdev->dev, cpc925_probe, GFP_KERNEL)) {\n\t\tres = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tcpc925_printk(KERN_ERR, \"Unable to get resource\\n\");\n\t\tres = -ENOENT;\n\t\tgoto err1;\n\t}\n\n\tif (!devm_request_mem_region(&pdev->dev,\n\t\t\t\t     r->start,\n\t\t\t\t     resource_size(r),\n\t\t\t\t     pdev->name)) {\n\t\tcpc925_printk(KERN_ERR, \"Unable to request mem region\\n\");\n\t\tres = -EBUSY;\n\t\tgoto err1;\n\t}\n\n\tvbase = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!vbase) {\n\t\tcpc925_printk(KERN_ERR, \"Unable to ioremap device\\n\");\n\t\tres = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tnr_channels = cpc925_mc_get_channels(vbase) + 1;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = CPC925_NR_CSROWS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = nr_channels;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(edac_mc_idx, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct cpc925_mc_pdata));\n\tif (!mci) {\n\t\tcpc925_printk(KERN_ERR, \"No memory for mem_ctl_info\\n\");\n\t\tres = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tpdata = mci->pvt_info;\n\tpdata->vbase = vbase;\n\tpdata->edac_idx = edac_mc_idx++;\n\tpdata->name = pdev->name;\n\n\tmci->pdev = &pdev->dev;\n\tplatform_set_drvdata(pdev, mci);\n\tmci->dev_name = dev_name(&pdev->dev);\n\tmci->mtype_cap = MEM_FLAG_RDDR | MEM_FLAG_DDR;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = CPC925_EDAC_MOD_STR;\n\tmci->ctl_name = pdev->name;\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tmci->edac_check = cpc925_mc_check;\n\n\tmci->ctl_page_to_phys = NULL;\n\tmci->scrub_mode = SCRUB_SW_SRC;\n\tmci->set_sdram_scrub_rate = NULL;\n\tmci->get_sdram_scrub_rate = cpc925_get_sdram_scrub_rate;\n\n\tcpc925_init_csrows(mci);\n\n\t \n\tcpc925_mc_init(mci);\n\n\tif (edac_mc_add_mc(mci) > 0) {\n\t\tcpc925_mc_printk(mci, KERN_ERR, \"Failed edac_mc_add_mc()\\n\");\n\t\tgoto err3;\n\t}\n\n\tcpc925_add_edac_devices(vbase);\n\n\t \n\tedac_dbg(0, \"success\\n\");\n\n\tres = 0;\n\tgoto out;\n\nerr3:\n\tcpc925_mc_exit(mci);\n\tedac_mc_free(mci);\nerr2:\n\tdevm_release_mem_region(&pdev->dev, r->start, resource_size(r));\nerr1:\n\tdevres_release_group(&pdev->dev, cpc925_probe);\nout:\n\treturn res;\n}\n\nstatic int cpc925_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\t \n\tcpc925_del_edac_devices();\n\tcpc925_mc_exit(mci);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\n\treturn 0;\n}\n\nstatic struct platform_driver cpc925_edac_driver = {\n\t.probe = cpc925_probe,\n\t.remove = cpc925_remove,\n\t.driver = {\n\t\t   .name = \"cpc925_edac\",\n\t}\n};\n\nstatic int __init cpc925_edac_init(void)\n{\n\tint ret = 0;\n\n\tprintk(KERN_INFO \"IBM CPC925 EDAC driver \" CPC925_EDAC_REVISION \"\\n\");\n\tprintk(KERN_INFO \"\\t(c) 2008 Wind River Systems, Inc\\n\");\n\n\t \n\tedac_op_state = EDAC_OPSTATE_POLL;\n\n\tret = platform_driver_register(&cpc925_edac_driver);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"Failed to register %s\\n\",\n\t\t\tCPC925_EDAC_MOD_STR);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit cpc925_edac_exit(void)\n{\n\tplatform_driver_unregister(&cpc925_edac_driver);\n}\n\nmodule_init(cpc925_edac_init);\nmodule_exit(cpc925_edac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cao Qingtao <qingtao.cao@windriver.com>\");\nMODULE_DESCRIPTION(\"IBM CPC925 Bridge and MC EDAC kernel module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}