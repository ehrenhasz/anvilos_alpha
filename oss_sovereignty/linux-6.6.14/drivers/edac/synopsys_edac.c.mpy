{
  "module_name": "synopsys_edac.c",
  "hash_id": "b6f9fab9ac6cb0ec256930e9164975d343756d8a5a2d7f2cdb3ffd0471d72a38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/synopsys_edac.c",
  "human_readable_source": "\n \n\n#include <linux/edac.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n\n#include \"edac_module.h\"\n\n \n#define SYNPS_EDAC_NR_CSROWS\t\t1\n\n \n#define SYNPS_EDAC_NR_CHANS\t\t1\n\n \n#define SYNPS_EDAC_ERR_GRAIN\t\t1\n\n#define SYNPS_EDAC_MSG_SIZE\t\t256\n\n#define SYNPS_EDAC_MOD_STRING\t\t\"synps_edac\"\n#define SYNPS_EDAC_MOD_VER\t\t\"1\"\n\n \n#define CTRL_OFST\t\t\t0x0\n#define T_ZQ_OFST\t\t\t0xA4\n\n \n#define ECC_CTRL_OFST\t\t\t0xC4\n \n#define CE_LOG_OFST\t\t\t0xC8\n \n#define CE_ADDR_OFST\t\t\t0xCC\n \n#define CE_DATA_31_0_OFST\t\t0xD0\n\n \n#define UE_LOG_OFST\t\t\t0xDC\n#define UE_ADDR_OFST\t\t\t0xE0\n#define UE_DATA_31_0_OFST\t\t0xE4\n\n#define STAT_OFST\t\t\t0xF0\n#define SCRUB_OFST\t\t\t0xF4\n\n \n#define CTRL_BW_MASK\t\t\t0xC\n#define CTRL_BW_SHIFT\t\t\t2\n\n#define DDRCTL_WDTH_16\t\t\t1\n#define DDRCTL_WDTH_32\t\t\t0\n\n \n#define T_ZQ_DDRMODE_MASK\t\t0x2\n\n \n#define ECC_CTRL_CLR_CE_ERR\t\t0x2\n#define ECC_CTRL_CLR_UE_ERR\t\t0x1\n\n \n#define LOG_VALID\t\t\t0x1\n#define CE_LOG_BITPOS_MASK\t\t0xFE\n#define CE_LOG_BITPOS_SHIFT\t\t1\n\n \n#define ADDR_COL_MASK\t\t\t0xFFF\n#define ADDR_ROW_MASK\t\t\t0xFFFF000\n#define ADDR_ROW_SHIFT\t\t\t12\n#define ADDR_BANK_MASK\t\t\t0x70000000\n#define ADDR_BANK_SHIFT\t\t\t28\n\n \n#define STAT_UECNT_MASK\t\t\t0xFF\n#define STAT_CECNT_MASK\t\t\t0xFF00\n#define STAT_CECNT_SHIFT\t\t8\n\n \n#define SCRUB_MODE_MASK\t\t\t0x7\n#define SCRUB_MODE_SECDED\t\t0x4\n\n \n#define DDR_ECC_INTR_SUPPORT\t\tBIT(0)\n#define DDR_ECC_DATA_POISON_SUPPORT\tBIT(1)\n#define DDR_ECC_INTR_SELF_CLEAR\t\tBIT(2)\n\n \n \n#define ECC_CFG0_OFST\t\t\t0x70\n#define ECC_CFG1_OFST\t\t\t0x74\n\n \n#define ECC_STAT_OFST\t\t\t0x78\n\n \n#define ECC_CLR_OFST\t\t\t0x7C\n\n \n#define ECC_ERRCNT_OFST\t\t\t0x80\n\n \n#define ECC_CEADDR0_OFST\t\t0x84\n#define ECC_CEADDR1_OFST\t\t0x88\n\n \n#define ECC_CSYND0_OFST\t\t\t0x8C\n#define ECC_CSYND1_OFST\t\t\t0x90\n#define ECC_CSYND2_OFST\t\t\t0x94\n\n \n#define ECC_BITMASK0_OFST\t\t0x98\n#define ECC_BITMASK1_OFST\t\t0x9C\n#define ECC_BITMASK2_OFST\t\t0xA0\n\n \n#define ECC_UEADDR0_OFST\t\t0xA4\n#define ECC_UEADDR1_OFST\t\t0xA8\n\n \n#define ECC_UESYND0_OFST\t\t0xAC\n#define ECC_UESYND1_OFST\t\t0xB0\n#define ECC_UESYND2_OFST\t\t0xB4\n\n \n#define ECC_POISON0_OFST\t\t0xB8\n#define ECC_POISON1_OFST\t\t0xBC\n\n#define ECC_ADDRMAP0_OFFSET\t\t0x200\n\n \n#define ECC_CTRL_BUSWIDTH_MASK\t\t0x3000\n#define ECC_CTRL_BUSWIDTH_SHIFT\t\t12\n#define ECC_CTRL_CLR_CE_ERRCNT\t\tBIT(2)\n#define ECC_CTRL_CLR_UE_ERRCNT\t\tBIT(3)\n\n \n#define DDRCTL_EWDTH_16\t\t\t2\n#define DDRCTL_EWDTH_32\t\t\t1\n#define DDRCTL_EWDTH_64\t\t\t0\n\n \n#define ECC_STAT_UECNT_MASK\t\t0xF0000\n#define ECC_STAT_UECNT_SHIFT\t\t16\n#define ECC_STAT_CECNT_MASK\t\t0xF00\n#define ECC_STAT_CECNT_SHIFT\t\t8\n#define ECC_STAT_BITNUM_MASK\t\t0x7F\n\n \n#define ECC_ERRCNT_UECNT_MASK\t\t0xFFFF0000\n#define ECC_ERRCNT_UECNT_SHIFT\t\t16\n#define ECC_ERRCNT_CECNT_MASK\t\t0xFFFF\n\n \n#define DDR_QOS_IRQ_STAT_OFST\t\t0x20200\n#define DDR_QOSUE_MASK\t\t\t0x4\n#define\tDDR_QOSCE_MASK\t\t\t0x2\n#define\tECC_CE_UE_INTR_MASK\t\t0x6\n#define DDR_QOS_IRQ_EN_OFST\t\t0x20208\n#define DDR_QOS_IRQ_DB_OFST\t\t0x2020C\n\n \n#define DDR_UE_MASK\t\t\tBIT(9)\n#define DDR_CE_MASK\t\t\tBIT(8)\n\n \n#define ECC_CEADDR0_RW_MASK\t\t0x3FFFF\n#define ECC_CEADDR0_RNK_MASK\t\tBIT(24)\n#define ECC_CEADDR1_BNKGRP_MASK\t\t0x3000000\n#define ECC_CEADDR1_BNKNR_MASK\t\t0x70000\n#define ECC_CEADDR1_BLKNR_MASK\t\t0xFFF\n#define ECC_CEADDR1_BNKGRP_SHIFT\t24\n#define ECC_CEADDR1_BNKNR_SHIFT\t\t16\n\n \n#define ECC_POISON0_RANK_SHIFT\t\t24\n#define ECC_POISON0_RANK_MASK\t\tBIT(24)\n#define ECC_POISON0_COLUMN_SHIFT\t0\n#define ECC_POISON0_COLUMN_MASK\t\t0xFFF\n#define ECC_POISON1_BG_SHIFT\t\t28\n#define ECC_POISON1_BG_MASK\t\t0x30000000\n#define ECC_POISON1_BANKNR_SHIFT\t24\n#define ECC_POISON1_BANKNR_MASK\t\t0x7000000\n#define ECC_POISON1_ROW_SHIFT\t\t0\n#define ECC_POISON1_ROW_MASK\t\t0x3FFFF\n\n \n#define MEM_TYPE_DDR3\t\t\t0x1\n#define MEM_TYPE_LPDDR3\t\t\t0x8\n#define MEM_TYPE_DDR2\t\t\t0x4\n#define MEM_TYPE_DDR4\t\t\t0x10\n#define MEM_TYPE_LPDDR4\t\t\t0x20\n\n \n#define DDRC_SWCTL\t\t\t0x320\n\n \n#define ECC_CEPOISON_MASK\t\t0x3\n#define ECC_UEPOISON_MASK\t\t0x1\n\n \n#define DDRC_MSTR_CFG_MASK\t\t0xC0000000\n#define DDRC_MSTR_CFG_SHIFT\t\t30\n#define DDRC_MSTR_CFG_X4_MASK\t\t0x0\n#define DDRC_MSTR_CFG_X8_MASK\t\t0x1\n#define DDRC_MSTR_CFG_X16_MASK\t\t0x2\n#define DDRC_MSTR_CFG_X32_MASK\t\t0x3\n\n#define DDR_MAX_ROW_SHIFT\t\t18\n#define DDR_MAX_COL_SHIFT\t\t14\n#define DDR_MAX_BANK_SHIFT\t\t3\n#define DDR_MAX_BANKGRP_SHIFT\t\t2\n\n#define ROW_MAX_VAL_MASK\t\t0xF\n#define COL_MAX_VAL_MASK\t\t0xF\n#define BANK_MAX_VAL_MASK\t\t0x1F\n#define BANKGRP_MAX_VAL_MASK\t\t0x1F\n#define RANK_MAX_VAL_MASK\t\t0x1F\n\n#define ROW_B0_BASE\t\t\t6\n#define ROW_B1_BASE\t\t\t7\n#define ROW_B2_BASE\t\t\t8\n#define ROW_B3_BASE\t\t\t9\n#define ROW_B4_BASE\t\t\t10\n#define ROW_B5_BASE\t\t\t11\n#define ROW_B6_BASE\t\t\t12\n#define ROW_B7_BASE\t\t\t13\n#define ROW_B8_BASE\t\t\t14\n#define ROW_B9_BASE\t\t\t15\n#define ROW_B10_BASE\t\t\t16\n#define ROW_B11_BASE\t\t\t17\n#define ROW_B12_BASE\t\t\t18\n#define ROW_B13_BASE\t\t\t19\n#define ROW_B14_BASE\t\t\t20\n#define ROW_B15_BASE\t\t\t21\n#define ROW_B16_BASE\t\t\t22\n#define ROW_B17_BASE\t\t\t23\n\n#define COL_B2_BASE\t\t\t2\n#define COL_B3_BASE\t\t\t3\n#define COL_B4_BASE\t\t\t4\n#define COL_B5_BASE\t\t\t5\n#define COL_B6_BASE\t\t\t6\n#define COL_B7_BASE\t\t\t7\n#define COL_B8_BASE\t\t\t8\n#define COL_B9_BASE\t\t\t9\n#define COL_B10_BASE\t\t\t10\n#define COL_B11_BASE\t\t\t11\n#define COL_B12_BASE\t\t\t12\n#define COL_B13_BASE\t\t\t13\n\n#define BANK_B0_BASE\t\t\t2\n#define BANK_B1_BASE\t\t\t3\n#define BANK_B2_BASE\t\t\t4\n\n#define BANKGRP_B0_BASE\t\t\t2\n#define BANKGRP_B1_BASE\t\t\t3\n\n#define RANK_B0_BASE\t\t\t6\n\n \nstruct ecc_error_info {\n\tu32 row;\n\tu32 col;\n\tu32 bank;\n\tu32 bitpos;\n\tu32 data;\n\tu32 bankgrpnr;\n\tu32 blknr;\n};\n\n \nstruct synps_ecc_status {\n\tu32 ce_cnt;\n\tu32 ue_cnt;\n\tstruct ecc_error_info ceinfo;\n\tstruct ecc_error_info ueinfo;\n};\n\n \nstruct synps_edac_priv {\n\tvoid __iomem *baseaddr;\n\tchar message[SYNPS_EDAC_MSG_SIZE];\n\tstruct synps_ecc_status stat;\n\tconst struct synps_platform_data *p_data;\n\tu32 ce_cnt;\n\tu32 ue_cnt;\n#ifdef CONFIG_EDAC_DEBUG\n\tulong poison_addr;\n\tu32 row_shift[18];\n\tu32 col_shift[14];\n\tu32 bank_shift[3];\n\tu32 bankgrp_shift[2];\n\tu32 rank_shift[1];\n#endif\n};\n\n \nstruct synps_platform_data {\n\tint (*get_error_info)(struct synps_edac_priv *priv);\n\tenum mem_type (*get_mtype)(const void __iomem *base);\n\tenum dev_type (*get_dtype)(const void __iomem *base);\n\tbool (*get_ecc_state)(void __iomem *base);\n\tint quirks;\n};\n\n \nstatic int zynq_get_error_info(struct synps_edac_priv *priv)\n{\n\tstruct synps_ecc_status *p;\n\tu32 regval, clearval = 0;\n\tvoid __iomem *base;\n\n\tbase = priv->baseaddr;\n\tp = &priv->stat;\n\n\tregval = readl(base + STAT_OFST);\n\tif (!regval)\n\t\treturn 1;\n\n\tp->ce_cnt = (regval & STAT_CECNT_MASK) >> STAT_CECNT_SHIFT;\n\tp->ue_cnt = regval & STAT_UECNT_MASK;\n\n\tregval = readl(base + CE_LOG_OFST);\n\tif (!(p->ce_cnt && (regval & LOG_VALID)))\n\t\tgoto ue_err;\n\n\tp->ceinfo.bitpos = (regval & CE_LOG_BITPOS_MASK) >> CE_LOG_BITPOS_SHIFT;\n\tregval = readl(base + CE_ADDR_OFST);\n\tp->ceinfo.row = (regval & ADDR_ROW_MASK) >> ADDR_ROW_SHIFT;\n\tp->ceinfo.col = regval & ADDR_COL_MASK;\n\tp->ceinfo.bank = (regval & ADDR_BANK_MASK) >> ADDR_BANK_SHIFT;\n\tp->ceinfo.data = readl(base + CE_DATA_31_0_OFST);\n\tedac_dbg(3, \"CE bit position: %d data: %d\\n\", p->ceinfo.bitpos,\n\t\t p->ceinfo.data);\n\tclearval = ECC_CTRL_CLR_CE_ERR;\n\nue_err:\n\tregval = readl(base + UE_LOG_OFST);\n\tif (!(p->ue_cnt && (regval & LOG_VALID)))\n\t\tgoto out;\n\n\tregval = readl(base + UE_ADDR_OFST);\n\tp->ueinfo.row = (regval & ADDR_ROW_MASK) >> ADDR_ROW_SHIFT;\n\tp->ueinfo.col = regval & ADDR_COL_MASK;\n\tp->ueinfo.bank = (regval & ADDR_BANK_MASK) >> ADDR_BANK_SHIFT;\n\tp->ueinfo.data = readl(base + UE_DATA_31_0_OFST);\n\tclearval |= ECC_CTRL_CLR_UE_ERR;\n\nout:\n\twritel(clearval, base + ECC_CTRL_OFST);\n\twritel(0x0, base + ECC_CTRL_OFST);\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_get_error_info(struct synps_edac_priv *priv)\n{\n\tstruct synps_ecc_status *p;\n\tu32 regval, clearval = 0;\n\tvoid __iomem *base;\n\n\tbase = priv->baseaddr;\n\tp = &priv->stat;\n\n\tregval = readl(base + ECC_ERRCNT_OFST);\n\tp->ce_cnt = regval & ECC_ERRCNT_CECNT_MASK;\n\tp->ue_cnt = (regval & ECC_ERRCNT_UECNT_MASK) >> ECC_ERRCNT_UECNT_SHIFT;\n\tif (!p->ce_cnt)\n\t\tgoto ue_err;\n\n\tregval = readl(base + ECC_STAT_OFST);\n\tif (!regval)\n\t\treturn 1;\n\n\tp->ceinfo.bitpos = (regval & ECC_STAT_BITNUM_MASK);\n\n\tregval = readl(base + ECC_CEADDR0_OFST);\n\tp->ceinfo.row = (regval & ECC_CEADDR0_RW_MASK);\n\tregval = readl(base + ECC_CEADDR1_OFST);\n\tp->ceinfo.bank = (regval & ECC_CEADDR1_BNKNR_MASK) >>\n\t\t\t\t\tECC_CEADDR1_BNKNR_SHIFT;\n\tp->ceinfo.bankgrpnr = (regval &\tECC_CEADDR1_BNKGRP_MASK) >>\n\t\t\t\t\tECC_CEADDR1_BNKGRP_SHIFT;\n\tp->ceinfo.blknr = (regval & ECC_CEADDR1_BLKNR_MASK);\n\tp->ceinfo.data = readl(base + ECC_CSYND0_OFST);\n\tedac_dbg(2, \"ECCCSYN0: 0x%08X ECCCSYN1: 0x%08X ECCCSYN2: 0x%08X\\n\",\n\t\t readl(base + ECC_CSYND0_OFST), readl(base + ECC_CSYND1_OFST),\n\t\t readl(base + ECC_CSYND2_OFST));\nue_err:\n\tif (!p->ue_cnt)\n\t\tgoto out;\n\n\tregval = readl(base + ECC_UEADDR0_OFST);\n\tp->ueinfo.row = (regval & ECC_CEADDR0_RW_MASK);\n\tregval = readl(base + ECC_UEADDR1_OFST);\n\tp->ueinfo.bankgrpnr = (regval & ECC_CEADDR1_BNKGRP_MASK) >>\n\t\t\t\t\tECC_CEADDR1_BNKGRP_SHIFT;\n\tp->ueinfo.bank = (regval & ECC_CEADDR1_BNKNR_MASK) >>\n\t\t\t\t\tECC_CEADDR1_BNKNR_SHIFT;\n\tp->ueinfo.blknr = (regval & ECC_CEADDR1_BLKNR_MASK);\n\tp->ueinfo.data = readl(base + ECC_UESYND0_OFST);\nout:\n\tclearval = ECC_CTRL_CLR_CE_ERR | ECC_CTRL_CLR_CE_ERRCNT;\n\tclearval |= ECC_CTRL_CLR_UE_ERR | ECC_CTRL_CLR_UE_ERRCNT;\n\twritel(clearval, base + ECC_CLR_OFST);\n\twritel(0x0, base + ECC_CLR_OFST);\n\n\treturn 0;\n}\n\n \nstatic void handle_error(struct mem_ctl_info *mci, struct synps_ecc_status *p)\n{\n\tstruct synps_edac_priv *priv = mci->pvt_info;\n\tstruct ecc_error_info *pinf;\n\n\tif (p->ce_cnt) {\n\t\tpinf = &p->ceinfo;\n\t\tif (priv->p_data->quirks & DDR_ECC_INTR_SUPPORT) {\n\t\t\tsnprintf(priv->message, SYNPS_EDAC_MSG_SIZE,\n\t\t\t\t \"DDR ECC error type:%s Row %d Bank %d BankGroup Number %d Block Number %d Bit Position: %d Data: 0x%08x\",\n\t\t\t\t \"CE\", pinf->row, pinf->bank,\n\t\t\t\t pinf->bankgrpnr, pinf->blknr,\n\t\t\t\t pinf->bitpos, pinf->data);\n\t\t} else {\n\t\t\tsnprintf(priv->message, SYNPS_EDAC_MSG_SIZE,\n\t\t\t\t \"DDR ECC error type:%s Row %d Bank %d Col %d Bit Position: %d Data: 0x%08x\",\n\t\t\t\t \"CE\", pinf->row, pinf->bank, pinf->col,\n\t\t\t\t pinf->bitpos, pinf->data);\n\t\t}\n\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci,\n\t\t\t\t     p->ce_cnt, 0, 0, 0, 0, 0, -1,\n\t\t\t\t     priv->message, \"\");\n\t}\n\n\tif (p->ue_cnt) {\n\t\tpinf = &p->ueinfo;\n\t\tif (priv->p_data->quirks & DDR_ECC_INTR_SUPPORT) {\n\t\t\tsnprintf(priv->message, SYNPS_EDAC_MSG_SIZE,\n\t\t\t\t \"DDR ECC error type :%s Row %d Bank %d BankGroup Number %d Block Number %d\",\n\t\t\t\t \"UE\", pinf->row, pinf->bank,\n\t\t\t\t pinf->bankgrpnr, pinf->blknr);\n\t\t} else {\n\t\t\tsnprintf(priv->message, SYNPS_EDAC_MSG_SIZE,\n\t\t\t\t \"DDR ECC error type :%s Row %d Bank %d Col %d \",\n\t\t\t\t \"UE\", pinf->row, pinf->bank, pinf->col);\n\t\t}\n\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci,\n\t\t\t\t     p->ue_cnt, 0, 0, 0, 0, 0, -1,\n\t\t\t\t     priv->message, \"\");\n\t}\n\n\tmemset(p, 0, sizeof(*p));\n}\n\nstatic void enable_intr(struct synps_edac_priv *priv)\n{\n\t \n\tif (priv->p_data->quirks & DDR_ECC_INTR_SELF_CLEAR)\n\t\twritel(DDR_UE_MASK | DDR_CE_MASK,\n\t\t       priv->baseaddr + ECC_CLR_OFST);\n\telse\n\t\twritel(DDR_QOSUE_MASK | DDR_QOSCE_MASK,\n\t\t       priv->baseaddr + DDR_QOS_IRQ_EN_OFST);\n\n}\n\nstatic void disable_intr(struct synps_edac_priv *priv)\n{\n\t \n\tif (priv->p_data->quirks & DDR_ECC_INTR_SELF_CLEAR)\n\t\twritel(0x0, priv->baseaddr + ECC_CLR_OFST);\n\telse\n\t\twritel(DDR_QOSUE_MASK | DDR_QOSCE_MASK,\n\t\t       priv->baseaddr + DDR_QOS_IRQ_DB_OFST);\n}\n\n \nstatic irqreturn_t intr_handler(int irq, void *dev_id)\n{\n\tconst struct synps_platform_data *p_data;\n\tstruct mem_ctl_info *mci = dev_id;\n\tstruct synps_edac_priv *priv;\n\tint status, regval;\n\n\tpriv = mci->pvt_info;\n\tp_data = priv->p_data;\n\n\t \n\tif (!(priv->p_data->quirks & DDR_ECC_INTR_SELF_CLEAR)) {\n\t\tregval = readl(priv->baseaddr + DDR_QOS_IRQ_STAT_OFST);\n\t\tregval &= (DDR_QOSCE_MASK | DDR_QOSUE_MASK);\n\t\tif (!(regval & ECC_CE_UE_INTR_MASK))\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tstatus = p_data->get_error_info(priv);\n\tif (status)\n\t\treturn IRQ_NONE;\n\n\tpriv->ce_cnt += priv->stat.ce_cnt;\n\tpriv->ue_cnt += priv->stat.ue_cnt;\n\thandle_error(mci, &priv->stat);\n\n\tedac_dbg(3, \"Total error count CE %d UE %d\\n\",\n\t\t priv->ce_cnt, priv->ue_cnt);\n\t \n\tif (!(priv->p_data->quirks & DDR_ECC_INTR_SELF_CLEAR))\n\t\twritel(regval, priv->baseaddr + DDR_QOS_IRQ_STAT_OFST);\n\telse\n\t\tenable_intr(priv);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void check_errors(struct mem_ctl_info *mci)\n{\n\tconst struct synps_platform_data *p_data;\n\tstruct synps_edac_priv *priv;\n\tint status;\n\n\tpriv = mci->pvt_info;\n\tp_data = priv->p_data;\n\n\tstatus = p_data->get_error_info(priv);\n\tif (status)\n\t\treturn;\n\n\tpriv->ce_cnt += priv->stat.ce_cnt;\n\tpriv->ue_cnt += priv->stat.ue_cnt;\n\thandle_error(mci, &priv->stat);\n\n\tedac_dbg(3, \"Total error count CE %d UE %d\\n\",\n\t\t priv->ce_cnt, priv->ue_cnt);\n}\n\n \nstatic enum dev_type zynq_get_dtype(const void __iomem *base)\n{\n\tenum dev_type dt;\n\tu32 width;\n\n\twidth = readl(base + CTRL_OFST);\n\twidth = (width & CTRL_BW_MASK) >> CTRL_BW_SHIFT;\n\n\tswitch (width) {\n\tcase DDRCTL_WDTH_16:\n\t\tdt = DEV_X2;\n\t\tbreak;\n\tcase DDRCTL_WDTH_32:\n\t\tdt = DEV_X4;\n\t\tbreak;\n\tdefault:\n\t\tdt = DEV_UNKNOWN;\n\t}\n\n\treturn dt;\n}\n\n \nstatic enum dev_type zynqmp_get_dtype(const void __iomem *base)\n{\n\tenum dev_type dt;\n\tu32 width;\n\n\twidth = readl(base + CTRL_OFST);\n\twidth = (width & ECC_CTRL_BUSWIDTH_MASK) >> ECC_CTRL_BUSWIDTH_SHIFT;\n\tswitch (width) {\n\tcase DDRCTL_EWDTH_16:\n\t\tdt = DEV_X2;\n\t\tbreak;\n\tcase DDRCTL_EWDTH_32:\n\t\tdt = DEV_X4;\n\t\tbreak;\n\tcase DDRCTL_EWDTH_64:\n\t\tdt = DEV_X8;\n\t\tbreak;\n\tdefault:\n\t\tdt = DEV_UNKNOWN;\n\t}\n\n\treturn dt;\n}\n\n \nstatic bool zynq_get_ecc_state(void __iomem *base)\n{\n\tenum dev_type dt;\n\tu32 ecctype;\n\n\tdt = zynq_get_dtype(base);\n\tif (dt == DEV_UNKNOWN)\n\t\treturn false;\n\n\tecctype = readl(base + SCRUB_OFST) & SCRUB_MODE_MASK;\n\tif ((ecctype == SCRUB_MODE_SECDED) && (dt == DEV_X2))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool zynqmp_get_ecc_state(void __iomem *base)\n{\n\tenum dev_type dt;\n\tu32 ecctype;\n\n\tdt = zynqmp_get_dtype(base);\n\tif (dt == DEV_UNKNOWN)\n\t\treturn false;\n\n\tecctype = readl(base + ECC_CFG0_OFST) & SCRUB_MODE_MASK;\n\tif ((ecctype == SCRUB_MODE_SECDED) &&\n\t    ((dt == DEV_X2) || (dt == DEV_X4) || (dt == DEV_X8)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic u32 get_memsize(void)\n{\n\tstruct sysinfo inf;\n\n\tsi_meminfo(&inf);\n\n\treturn inf.totalram * inf.mem_unit;\n}\n\n \nstatic enum mem_type zynq_get_mtype(const void __iomem *base)\n{\n\tenum mem_type mt;\n\tu32 memtype;\n\n\tmemtype = readl(base + T_ZQ_OFST);\n\n\tif (memtype & T_ZQ_DDRMODE_MASK)\n\t\tmt = MEM_DDR3;\n\telse\n\t\tmt = MEM_DDR2;\n\n\treturn mt;\n}\n\n \nstatic enum mem_type zynqmp_get_mtype(const void __iomem *base)\n{\n\tenum mem_type mt;\n\tu32 memtype;\n\n\tmemtype = readl(base + CTRL_OFST);\n\n\tif ((memtype & MEM_TYPE_DDR3) || (memtype & MEM_TYPE_LPDDR3))\n\t\tmt = MEM_DDR3;\n\telse if (memtype & MEM_TYPE_DDR2)\n\t\tmt = MEM_RDDR2;\n\telse if ((memtype & MEM_TYPE_LPDDR4) || (memtype & MEM_TYPE_DDR4))\n\t\tmt = MEM_DDR4;\n\telse\n\t\tmt = MEM_EMPTY;\n\n\treturn mt;\n}\n\n \nstatic void init_csrows(struct mem_ctl_info *mci)\n{\n\tstruct synps_edac_priv *priv = mci->pvt_info;\n\tconst struct synps_platform_data *p_data;\n\tstruct csrow_info *csi;\n\tstruct dimm_info *dimm;\n\tu32 size, row;\n\tint j;\n\n\tp_data = priv->p_data;\n\n\tfor (row = 0; row < mci->nr_csrows; row++) {\n\t\tcsi = mci->csrows[row];\n\t\tsize = get_memsize();\n\n\t\tfor (j = 0; j < csi->nr_channels; j++) {\n\t\t\tdimm\t\t= csi->channels[j]->dimm;\n\t\t\tdimm->edac_mode\t= EDAC_SECDED;\n\t\t\tdimm->mtype\t= p_data->get_mtype(priv->baseaddr);\n\t\t\tdimm->nr_pages\t= (size >> PAGE_SHIFT) / csi->nr_channels;\n\t\t\tdimm->grain\t= SYNPS_EDAC_ERR_GRAIN;\n\t\t\tdimm->dtype\t= p_data->get_dtype(priv->baseaddr);\n\t\t}\n\t}\n}\n\n \nstatic void mc_init(struct mem_ctl_info *mci, struct platform_device *pdev)\n{\n\tstruct synps_edac_priv *priv;\n\n\tmci->pdev = &pdev->dev;\n\tpriv = mci->pvt_info;\n\tplatform_set_drvdata(pdev, mci);\n\n\t \n\tmci->mtype_cap = MEM_FLAG_DDR3 | MEM_FLAG_DDR2;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->scrub_cap = SCRUB_HW_SRC;\n\tmci->scrub_mode = SCRUB_NONE;\n\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->ctl_name = \"synps_ddr_controller\";\n\tmci->dev_name = SYNPS_EDAC_MOD_STRING;\n\tmci->mod_name = SYNPS_EDAC_MOD_VER;\n\n\tif (priv->p_data->quirks & DDR_ECC_INTR_SUPPORT) {\n\t\tedac_op_state = EDAC_OPSTATE_INT;\n\t} else {\n\t\tedac_op_state = EDAC_OPSTATE_POLL;\n\t\tmci->edac_check = check_errors;\n\t}\n\n\tmci->ctl_page_to_phys = NULL;\n\n\tinit_csrows(mci);\n}\n\nstatic int setup_irq(struct mem_ctl_info *mci,\n\t\t     struct platform_device *pdev)\n{\n\tstruct synps_edac_priv *priv = mci->pvt_info;\n\tint ret, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"No IRQ %d in DT\\n\", irq);\n\t\treturn irq;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, irq, intr_handler,\n\t\t\t       0, dev_name(&pdev->dev), mci);\n\tif (ret < 0) {\n\t\tedac_printk(KERN_ERR, EDAC_MC, \"Failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tenable_intr(priv);\n\n\treturn 0;\n}\n\nstatic const struct synps_platform_data zynq_edac_def = {\n\t.get_error_info\t= zynq_get_error_info,\n\t.get_mtype\t= zynq_get_mtype,\n\t.get_dtype\t= zynq_get_dtype,\n\t.get_ecc_state\t= zynq_get_ecc_state,\n\t.quirks\t\t= 0,\n};\n\nstatic const struct synps_platform_data zynqmp_edac_def = {\n\t.get_error_info\t= zynqmp_get_error_info,\n\t.get_mtype\t= zynqmp_get_mtype,\n\t.get_dtype\t= zynqmp_get_dtype,\n\t.get_ecc_state\t= zynqmp_get_ecc_state,\n\t.quirks         = (DDR_ECC_INTR_SUPPORT\n#ifdef CONFIG_EDAC_DEBUG\n\t\t\t  | DDR_ECC_DATA_POISON_SUPPORT\n#endif\n\t\t\t  ),\n};\n\nstatic const struct synps_platform_data synopsys_edac_def = {\n\t.get_error_info\t= zynqmp_get_error_info,\n\t.get_mtype\t= zynqmp_get_mtype,\n\t.get_dtype\t= zynqmp_get_dtype,\n\t.get_ecc_state\t= zynqmp_get_ecc_state,\n\t.quirks         = (DDR_ECC_INTR_SUPPORT | DDR_ECC_INTR_SELF_CLEAR\n#ifdef CONFIG_EDAC_DEBUG\n\t\t\t  | DDR_ECC_DATA_POISON_SUPPORT\n#endif\n\t\t\t  ),\n};\n\n\nstatic const struct of_device_id synps_edac_match[] = {\n\t{\n\t\t.compatible = \"xlnx,zynq-ddrc-a05\",\n\t\t.data = (void *)&zynq_edac_def\n\t},\n\t{\n\t\t.compatible = \"xlnx,zynqmp-ddrc-2.40a\",\n\t\t.data = (void *)&zynqmp_edac_def\n\t},\n\t{\n\t\t.compatible = \"snps,ddrc-3.80a\",\n\t\t.data = (void *)&synopsys_edac_def\n\t},\n\t{\n\t\t \n\t}\n};\n\nMODULE_DEVICE_TABLE(of, synps_edac_match);\n\n#ifdef CONFIG_EDAC_DEBUG\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\n\n \nstatic void ddr_poison_setup(struct synps_edac_priv *priv)\n{\n\tint col = 0, row = 0, bank = 0, bankgrp = 0, rank = 0, regval;\n\tint index;\n\tulong hif_addr = 0;\n\n\thif_addr = priv->poison_addr >> 3;\n\n\tfor (index = 0; index < DDR_MAX_ROW_SHIFT; index++) {\n\t\tif (priv->row_shift[index])\n\t\t\trow |= (((hif_addr >> priv->row_shift[index]) &\n\t\t\t\t\t\tBIT(0)) << index);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tfor (index = 0; index < DDR_MAX_COL_SHIFT; index++) {\n\t\tif (priv->col_shift[index] || index < 3)\n\t\t\tcol |= (((hif_addr >> priv->col_shift[index]) &\n\t\t\t\t\t\tBIT(0)) << index);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tfor (index = 0; index < DDR_MAX_BANK_SHIFT; index++) {\n\t\tif (priv->bank_shift[index])\n\t\t\tbank |= (((hif_addr >> priv->bank_shift[index]) &\n\t\t\t\t\t\tBIT(0)) << index);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tfor (index = 0; index < DDR_MAX_BANKGRP_SHIFT; index++) {\n\t\tif (priv->bankgrp_shift[index])\n\t\t\tbankgrp |= (((hif_addr >> priv->bankgrp_shift[index])\n\t\t\t\t\t\t& BIT(0)) << index);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (priv->rank_shift[0])\n\t\trank = (hif_addr >> priv->rank_shift[0]) & BIT(0);\n\n\tregval = (rank << ECC_POISON0_RANK_SHIFT) & ECC_POISON0_RANK_MASK;\n\tregval |= (col << ECC_POISON0_COLUMN_SHIFT) & ECC_POISON0_COLUMN_MASK;\n\twritel(regval, priv->baseaddr + ECC_POISON0_OFST);\n\n\tregval = (bankgrp << ECC_POISON1_BG_SHIFT) & ECC_POISON1_BG_MASK;\n\tregval |= (bank << ECC_POISON1_BANKNR_SHIFT) & ECC_POISON1_BANKNR_MASK;\n\tregval |= (row << ECC_POISON1_ROW_SHIFT) & ECC_POISON1_ROW_MASK;\n\twritel(regval, priv->baseaddr + ECC_POISON1_OFST);\n}\n\nstatic ssize_t inject_data_error_show(struct device *dev,\n\t\t\t\t      struct device_attribute *mattr,\n\t\t\t\t      char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct synps_edac_priv *priv = mci->pvt_info;\n\n\treturn sprintf(data, \"Poison0 Addr: 0x%08x\\n\\rPoison1 Addr: 0x%08x\\n\\r\"\n\t\t\t\"Error injection Address: 0x%lx\\n\\r\",\n\t\t\treadl(priv->baseaddr + ECC_POISON0_OFST),\n\t\t\treadl(priv->baseaddr + ECC_POISON1_OFST),\n\t\t\tpriv->poison_addr);\n}\n\nstatic ssize_t inject_data_error_store(struct device *dev,\n\t\t\t\t       struct device_attribute *mattr,\n\t\t\t\t       const char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct synps_edac_priv *priv = mci->pvt_info;\n\n\tif (kstrtoul(data, 0, &priv->poison_addr))\n\t\treturn -EINVAL;\n\n\tddr_poison_setup(priv);\n\n\treturn count;\n}\n\nstatic ssize_t inject_data_poison_show(struct device *dev,\n\t\t\t\t       struct device_attribute *mattr,\n\t\t\t\t       char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct synps_edac_priv *priv = mci->pvt_info;\n\n\treturn sprintf(data, \"Data Poisoning: %s\\n\\r\",\n\t\t\t(((readl(priv->baseaddr + ECC_CFG1_OFST)) & 0x3) == 0x3)\n\t\t\t? (\"Correctable Error\") : (\"UnCorrectable Error\"));\n}\n\nstatic ssize_t inject_data_poison_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *mattr,\n\t\t\t\t\tconst char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct synps_edac_priv *priv = mci->pvt_info;\n\n\twritel(0, priv->baseaddr + DDRC_SWCTL);\n\tif (strncmp(data, \"CE\", 2) == 0)\n\t\twritel(ECC_CEPOISON_MASK, priv->baseaddr + ECC_CFG1_OFST);\n\telse\n\t\twritel(ECC_UEPOISON_MASK, priv->baseaddr + ECC_CFG1_OFST);\n\twritel(1, priv->baseaddr + DDRC_SWCTL);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(inject_data_error);\nstatic DEVICE_ATTR_RW(inject_data_poison);\n\nstatic int edac_create_sysfs_attributes(struct mem_ctl_info *mci)\n{\n\tint rc;\n\n\trc = device_create_file(&mci->dev, &dev_attr_inject_data_error);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = device_create_file(&mci->dev, &dev_attr_inject_data_poison);\n\tif (rc < 0)\n\t\treturn rc;\n\treturn 0;\n}\n\nstatic void edac_remove_sysfs_attributes(struct mem_ctl_info *mci)\n{\n\tdevice_remove_file(&mci->dev, &dev_attr_inject_data_error);\n\tdevice_remove_file(&mci->dev, &dev_attr_inject_data_poison);\n}\n\nstatic void setup_row_address_map(struct synps_edac_priv *priv, u32 *addrmap)\n{\n\tu32 addrmap_row_b2_10;\n\tint index;\n\n\tpriv->row_shift[0] = (addrmap[5] & ROW_MAX_VAL_MASK) + ROW_B0_BASE;\n\tpriv->row_shift[1] = ((addrmap[5] >> 8) &\n\t\t\tROW_MAX_VAL_MASK) + ROW_B1_BASE;\n\n\taddrmap_row_b2_10 = (addrmap[5] >> 16) & ROW_MAX_VAL_MASK;\n\tif (addrmap_row_b2_10 != ROW_MAX_VAL_MASK) {\n\t\tfor (index = 2; index < 11; index++)\n\t\t\tpriv->row_shift[index] = addrmap_row_b2_10 +\n\t\t\t\tindex + ROW_B0_BASE;\n\n\t} else {\n\t\tpriv->row_shift[2] = (addrmap[9] &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B2_BASE;\n\t\tpriv->row_shift[3] = ((addrmap[9] >> 8) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B3_BASE;\n\t\tpriv->row_shift[4] = ((addrmap[9] >> 16) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B4_BASE;\n\t\tpriv->row_shift[5] = ((addrmap[9] >> 24) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B5_BASE;\n\t\tpriv->row_shift[6] = (addrmap[10] &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B6_BASE;\n\t\tpriv->row_shift[7] = ((addrmap[10] >> 8) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B7_BASE;\n\t\tpriv->row_shift[8] = ((addrmap[10] >> 16) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B8_BASE;\n\t\tpriv->row_shift[9] = ((addrmap[10] >> 24) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B9_BASE;\n\t\tpriv->row_shift[10] = (addrmap[11] &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B10_BASE;\n\t}\n\n\tpriv->row_shift[11] = (((addrmap[5] >> 24) & ROW_MAX_VAL_MASK) ==\n\t\t\t\tROW_MAX_VAL_MASK) ? 0 : (((addrmap[5] >> 24) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B11_BASE);\n\tpriv->row_shift[12] = ((addrmap[6] & ROW_MAX_VAL_MASK) ==\n\t\t\t\tROW_MAX_VAL_MASK) ? 0 : ((addrmap[6] &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B12_BASE);\n\tpriv->row_shift[13] = (((addrmap[6] >> 8) & ROW_MAX_VAL_MASK) ==\n\t\t\t\tROW_MAX_VAL_MASK) ? 0 : (((addrmap[6] >> 8) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B13_BASE);\n\tpriv->row_shift[14] = (((addrmap[6] >> 16) & ROW_MAX_VAL_MASK) ==\n\t\t\t\tROW_MAX_VAL_MASK) ? 0 : (((addrmap[6] >> 16) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B14_BASE);\n\tpriv->row_shift[15] = (((addrmap[6] >> 24) & ROW_MAX_VAL_MASK) ==\n\t\t\t\tROW_MAX_VAL_MASK) ? 0 : (((addrmap[6] >> 24) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B15_BASE);\n\tpriv->row_shift[16] = ((addrmap[7] & ROW_MAX_VAL_MASK) ==\n\t\t\t\tROW_MAX_VAL_MASK) ? 0 : ((addrmap[7] &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B16_BASE);\n\tpriv->row_shift[17] = (((addrmap[7] >> 8) & ROW_MAX_VAL_MASK) ==\n\t\t\t\tROW_MAX_VAL_MASK) ? 0 : (((addrmap[7] >> 8) &\n\t\t\t\tROW_MAX_VAL_MASK) + ROW_B17_BASE);\n}\n\nstatic void setup_column_address_map(struct synps_edac_priv *priv, u32 *addrmap)\n{\n\tu32 width, memtype;\n\tint index;\n\n\tmemtype = readl(priv->baseaddr + CTRL_OFST);\n\twidth = (memtype & ECC_CTRL_BUSWIDTH_MASK) >> ECC_CTRL_BUSWIDTH_SHIFT;\n\n\tpriv->col_shift[0] = 0;\n\tpriv->col_shift[1] = 1;\n\tpriv->col_shift[2] = (addrmap[2] & COL_MAX_VAL_MASK) + COL_B2_BASE;\n\tpriv->col_shift[3] = ((addrmap[2] >> 8) &\n\t\t\tCOL_MAX_VAL_MASK) + COL_B3_BASE;\n\tpriv->col_shift[4] = (((addrmap[2] >> 16) & COL_MAX_VAL_MASK) ==\n\t\t\tCOL_MAX_VAL_MASK) ? 0 : (((addrmap[2] >> 16) &\n\t\t\t\t\tCOL_MAX_VAL_MASK) + COL_B4_BASE);\n\tpriv->col_shift[5] = (((addrmap[2] >> 24) & COL_MAX_VAL_MASK) ==\n\t\t\tCOL_MAX_VAL_MASK) ? 0 : (((addrmap[2] >> 24) &\n\t\t\t\t\tCOL_MAX_VAL_MASK) + COL_B5_BASE);\n\tpriv->col_shift[6] = ((addrmap[3] & COL_MAX_VAL_MASK) ==\n\t\t\tCOL_MAX_VAL_MASK) ? 0 : ((addrmap[3] &\n\t\t\t\t\tCOL_MAX_VAL_MASK) + COL_B6_BASE);\n\tpriv->col_shift[7] = (((addrmap[3] >> 8) & COL_MAX_VAL_MASK) ==\n\t\t\tCOL_MAX_VAL_MASK) ? 0 : (((addrmap[3] >> 8) &\n\t\t\t\t\tCOL_MAX_VAL_MASK) + COL_B7_BASE);\n\tpriv->col_shift[8] = (((addrmap[3] >> 16) & COL_MAX_VAL_MASK) ==\n\t\t\tCOL_MAX_VAL_MASK) ? 0 : (((addrmap[3] >> 16) &\n\t\t\t\t\tCOL_MAX_VAL_MASK) + COL_B8_BASE);\n\tpriv->col_shift[9] = (((addrmap[3] >> 24) & COL_MAX_VAL_MASK) ==\n\t\t\tCOL_MAX_VAL_MASK) ? 0 : (((addrmap[3] >> 24) &\n\t\t\t\t\tCOL_MAX_VAL_MASK) + COL_B9_BASE);\n\tif (width == DDRCTL_EWDTH_64) {\n\t\tif (memtype & MEM_TYPE_LPDDR3) {\n\t\t\tpriv->col_shift[10] = ((addrmap[4] &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t((addrmap[4] & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B10_BASE);\n\t\t\tpriv->col_shift[11] = (((addrmap[4] >> 8) &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[4] >> 8) & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B11_BASE);\n\t\t} else {\n\t\t\tpriv->col_shift[11] = ((addrmap[4] &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t((addrmap[4] & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B10_BASE);\n\t\t\tpriv->col_shift[13] = (((addrmap[4] >> 8) &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[4] >> 8) & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B11_BASE);\n\t\t}\n\t} else if (width == DDRCTL_EWDTH_32) {\n\t\tif (memtype & MEM_TYPE_LPDDR3) {\n\t\t\tpriv->col_shift[10] = (((addrmap[3] >> 24) &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[3] >> 24) & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B9_BASE);\n\t\t\tpriv->col_shift[11] = ((addrmap[4] &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t((addrmap[4] & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B10_BASE);\n\t\t} else {\n\t\t\tpriv->col_shift[11] = (((addrmap[3] >> 24) &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[3] >> 24) & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B9_BASE);\n\t\t\tpriv->col_shift[13] = ((addrmap[4] &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t((addrmap[4] & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B10_BASE);\n\t\t}\n\t} else {\n\t\tif (memtype & MEM_TYPE_LPDDR3) {\n\t\t\tpriv->col_shift[10] = (((addrmap[3] >> 16) &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[3] >> 16) & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B8_BASE);\n\t\t\tpriv->col_shift[11] = (((addrmap[3] >> 24) &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[3] >> 24) & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B9_BASE);\n\t\t\tpriv->col_shift[13] = ((addrmap[4] &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t((addrmap[4] & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B10_BASE);\n\t\t} else {\n\t\t\tpriv->col_shift[11] = (((addrmap[3] >> 16) &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[3] >> 16) & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B8_BASE);\n\t\t\tpriv->col_shift[13] = (((addrmap[3] >> 24) &\n\t\t\t\tCOL_MAX_VAL_MASK) == COL_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[3] >> 24) & COL_MAX_VAL_MASK) +\n\t\t\t\t COL_B9_BASE);\n\t\t}\n\t}\n\n\tif (width) {\n\t\tfor (index = 9; index > width; index--) {\n\t\t\tpriv->col_shift[index] = priv->col_shift[index - width];\n\t\t\tpriv->col_shift[index - width] = 0;\n\t\t}\n\t}\n\n}\n\nstatic void setup_bank_address_map(struct synps_edac_priv *priv, u32 *addrmap)\n{\n\tpriv->bank_shift[0] = (addrmap[1] & BANK_MAX_VAL_MASK) + BANK_B0_BASE;\n\tpriv->bank_shift[1] = ((addrmap[1] >> 8) &\n\t\t\t\tBANK_MAX_VAL_MASK) + BANK_B1_BASE;\n\tpriv->bank_shift[2] = (((addrmap[1] >> 16) &\n\t\t\t\tBANK_MAX_VAL_MASK) == BANK_MAX_VAL_MASK) ? 0 :\n\t\t\t\t(((addrmap[1] >> 16) & BANK_MAX_VAL_MASK) +\n\t\t\t\t BANK_B2_BASE);\n\n}\n\nstatic void setup_bg_address_map(struct synps_edac_priv *priv, u32 *addrmap)\n{\n\tpriv->bankgrp_shift[0] = (addrmap[8] &\n\t\t\t\tBANKGRP_MAX_VAL_MASK) + BANKGRP_B0_BASE;\n\tpriv->bankgrp_shift[1] = (((addrmap[8] >> 8) & BANKGRP_MAX_VAL_MASK) ==\n\t\t\t\tBANKGRP_MAX_VAL_MASK) ? 0 : (((addrmap[8] >> 8)\n\t\t\t\t& BANKGRP_MAX_VAL_MASK) + BANKGRP_B1_BASE);\n\n}\n\nstatic void setup_rank_address_map(struct synps_edac_priv *priv, u32 *addrmap)\n{\n\tpriv->rank_shift[0] = ((addrmap[0] & RANK_MAX_VAL_MASK) ==\n\t\t\t\tRANK_MAX_VAL_MASK) ? 0 : ((addrmap[0] &\n\t\t\t\tRANK_MAX_VAL_MASK) + RANK_B0_BASE);\n}\n\n \nstatic void setup_address_map(struct synps_edac_priv *priv)\n{\n\tu32 addrmap[12];\n\tint index;\n\n\tfor (index = 0; index < 12; index++) {\n\t\tu32 addrmap_offset;\n\n\t\taddrmap_offset = ECC_ADDRMAP0_OFFSET + (index * 4);\n\t\taddrmap[index] = readl(priv->baseaddr + addrmap_offset);\n\t}\n\n\tsetup_row_address_map(priv, addrmap);\n\n\tsetup_column_address_map(priv, addrmap);\n\n\tsetup_bank_address_map(priv, addrmap);\n\n\tsetup_bg_address_map(priv, addrmap);\n\n\tsetup_rank_address_map(priv, addrmap);\n}\n#endif  \n\n \nstatic int mc_probe(struct platform_device *pdev)\n{\n\tconst struct synps_platform_data *p_data;\n\tstruct edac_mc_layer layers[2];\n\tstruct synps_edac_priv *priv;\n\tstruct mem_ctl_info *mci;\n\tvoid __iomem *baseaddr;\n\tstruct resource *res;\n\tint rc;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbaseaddr = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(baseaddr))\n\t\treturn PTR_ERR(baseaddr);\n\n\tp_data = of_device_get_match_data(&pdev->dev);\n\tif (!p_data)\n\t\treturn -ENODEV;\n\n\tif (!p_data->get_ecc_state(baseaddr)) {\n\t\tedac_printk(KERN_INFO, EDAC_MC, \"ECC not enabled\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = SYNPS_EDAC_NR_CSROWS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = SYNPS_EDAC_NR_CHANS;\n\tlayers[1].is_virt_csrow = false;\n\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct synps_edac_priv));\n\tif (!mci) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Failed memory allocation for mc instance\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = mci->pvt_info;\n\tpriv->baseaddr = baseaddr;\n\tpriv->p_data = p_data;\n\n\tmc_init(mci, pdev);\n\n\tif (priv->p_data->quirks & DDR_ECC_INTR_SUPPORT) {\n\t\trc = setup_irq(mci, pdev);\n\t\tif (rc)\n\t\t\tgoto free_edac_mc;\n\t}\n\n\trc = edac_mc_add_mc(mci);\n\tif (rc) {\n\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t    \"Failed to register with EDAC core\\n\");\n\t\tgoto free_edac_mc;\n\t}\n\n#ifdef CONFIG_EDAC_DEBUG\n\tif (priv->p_data->quirks & DDR_ECC_DATA_POISON_SUPPORT) {\n\t\trc = edac_create_sysfs_attributes(mci);\n\t\tif (rc) {\n\t\t\tedac_printk(KERN_ERR, EDAC_MC,\n\t\t\t\t\t\"Failed to create sysfs entries\\n\");\n\t\t\tgoto free_edac_mc;\n\t\t}\n\t}\n\n\tif (priv->p_data->quirks & DDR_ECC_INTR_SUPPORT)\n\t\tsetup_address_map(priv);\n#endif\n\n\t \n\tif (!(priv->p_data->quirks & DDR_ECC_INTR_SUPPORT))\n\t\twritel(0x0, baseaddr + ECC_CTRL_OFST);\n\n\treturn rc;\n\nfree_edac_mc:\n\tedac_mc_free(mci);\n\n\treturn rc;\n}\n\n \nstatic int mc_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\tstruct synps_edac_priv *priv = mci->pvt_info;\n\n\tif (priv->p_data->quirks & DDR_ECC_INTR_SUPPORT)\n\t\tdisable_intr(priv);\n\n#ifdef CONFIG_EDAC_DEBUG\n\tif (priv->p_data->quirks & DDR_ECC_DATA_POISON_SUPPORT)\n\t\tedac_remove_sysfs_attributes(mci);\n#endif\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\n\treturn 0;\n}\n\nstatic struct platform_driver synps_edac_mc_driver = {\n\t.driver = {\n\t\t   .name = \"synopsys-edac\",\n\t\t   .of_match_table = synps_edac_match,\n\t\t   },\n\t.probe = mc_probe,\n\t.remove = mc_remove,\n};\n\nmodule_platform_driver(synps_edac_mc_driver);\n\nMODULE_AUTHOR(\"Xilinx Inc\");\nMODULE_DESCRIPTION(\"Synopsys DDR ECC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}