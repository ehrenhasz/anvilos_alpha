{
  "module_name": "cell_edac.c",
  "hash_id": "de72a78fbc65fedfee18a402d1221dd7edbda7edd337c2c1099d08e3280ac0d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/cell_edac.c",
  "human_readable_source": " \n#undef DEBUG\n\n#include <linux/edac.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/stop_machine.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <asm/machdep.h>\n#include <asm/cell-regs.h>\n\n#include \"edac_module.h\"\n\nstruct cell_edac_priv\n{\n\tstruct cbe_mic_tm_regs __iomem\t*regs;\n\tint\t\t\t\tnode;\n\tint\t\t\t\tchanmask;\n#ifdef DEBUG\n\tu64\t\t\t\tprev_fir;\n#endif\n};\n\nstatic void cell_edac_count_ce(struct mem_ctl_info *mci, int chan, u64 ar)\n{\n\tstruct cell_edac_priv\t\t*priv = mci->pvt_info;\n\tstruct csrow_info\t\t*csrow = mci->csrows[0];\n\tunsigned long\t\t\taddress, pfn, offset, syndrome;\n\n\tdev_dbg(mci->pdev, \"ECC CE err on node %d, channel %d, ar = 0x%016llx\\n\",\n\t\tpriv->node, chan, ar);\n\n\t \n\taddress = (ar & 0xffffffffe0000000ul) >> 29;\n\tif (priv->chanmask == 0x3)\n\t\taddress = (address << 1) | chan;\n\tpfn = address >> PAGE_SHIFT;\n\toffset = address & ~PAGE_MASK;\n\tsyndrome = (ar & 0x000000001fe00000ul) >> 21;\n\n\t \n\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t     csrow->first_page + pfn, offset, syndrome,\n\t\t\t     0, chan, -1, \"\", \"\");\n}\n\nstatic void cell_edac_count_ue(struct mem_ctl_info *mci, int chan, u64 ar)\n{\n\tstruct cell_edac_priv\t\t*priv = mci->pvt_info;\n\tstruct csrow_info\t\t*csrow = mci->csrows[0];\n\tunsigned long\t\t\taddress, pfn, offset;\n\n\tdev_dbg(mci->pdev, \"ECC UE err on node %d, channel %d, ar = 0x%016llx\\n\",\n\t\tpriv->node, chan, ar);\n\n\t \n\taddress = (ar & 0xffffffffe0000000ul) >> 29;\n\tif (priv->chanmask == 0x3)\n\t\taddress = (address << 1) | chan;\n\tpfn = address >> PAGE_SHIFT;\n\toffset = address & ~PAGE_MASK;\n\n\t \n\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t     csrow->first_page + pfn, offset, 0,\n\t\t\t     0, chan, -1, \"\", \"\");\n}\n\nstatic void cell_edac_check(struct mem_ctl_info *mci)\n{\n\tstruct cell_edac_priv\t\t*priv = mci->pvt_info;\n\tu64\t\t\t\tfir, addreg, clear = 0;\n\n\tfir = in_be64(&priv->regs->mic_fir);\n#ifdef DEBUG\n\tif (fir != priv->prev_fir) {\n\t\tdev_dbg(mci->pdev, \"fir change : 0x%016lx\\n\", fir);\n\t\tpriv->prev_fir = fir;\n\t}\n#endif\n\tif ((priv->chanmask & 0x1) && (fir & CBE_MIC_FIR_ECC_SINGLE_0_ERR)) {\n\t\taddreg = in_be64(&priv->regs->mic_df_ecc_address_0);\n\t\tclear |= CBE_MIC_FIR_ECC_SINGLE_0_RESET;\n\t\tcell_edac_count_ce(mci, 0, addreg);\n\t}\n\tif ((priv->chanmask & 0x2) && (fir & CBE_MIC_FIR_ECC_SINGLE_1_ERR)) {\n\t\taddreg = in_be64(&priv->regs->mic_df_ecc_address_1);\n\t\tclear |= CBE_MIC_FIR_ECC_SINGLE_1_RESET;\n\t\tcell_edac_count_ce(mci, 1, addreg);\n\t}\n\tif ((priv->chanmask & 0x1) && (fir & CBE_MIC_FIR_ECC_MULTI_0_ERR)) {\n\t\taddreg = in_be64(&priv->regs->mic_df_ecc_address_0);\n\t\tclear |= CBE_MIC_FIR_ECC_MULTI_0_RESET;\n\t\tcell_edac_count_ue(mci, 0, addreg);\n\t}\n\tif ((priv->chanmask & 0x2) && (fir & CBE_MIC_FIR_ECC_MULTI_1_ERR)) {\n\t\taddreg = in_be64(&priv->regs->mic_df_ecc_address_1);\n\t\tclear |= CBE_MIC_FIR_ECC_MULTI_1_RESET;\n\t\tcell_edac_count_ue(mci, 1, addreg);\n\t}\n\n\t \n\tif (clear) {\n\t\tfir &= ~(CBE_MIC_FIR_ECC_ERR_MASK | CBE_MIC_FIR_ECC_SET_MASK);\n\t\tfir |= CBE_MIC_FIR_ECC_RESET_MASK;\n\t\tfir &= ~clear;\n\t\tout_be64(&priv->regs->mic_fir, fir);\n\t\t(void)in_be64(&priv->regs->mic_fir);\n\n\t\tmb();\t \n#ifdef DEBUG\n\t\tfir = in_be64(&priv->regs->mic_fir);\n\t\tdev_dbg(mci->pdev, \"fir clear  : 0x%016lx\\n\", fir);\n#endif\n\t}\n}\n\nstatic void cell_edac_init_csrows(struct mem_ctl_info *mci)\n{\n\tstruct csrow_info\t\t*csrow = mci->csrows[0];\n\tstruct dimm_info\t\t*dimm;\n\tstruct cell_edac_priv\t\t*priv = mci->pvt_info;\n\tstruct device_node\t\t*np;\n\tint\t\t\t\tj;\n\tu32\t\t\t\tnr_pages;\n\n\tfor_each_node_by_name(np, \"memory\") {\n\t\tstruct resource r;\n\n\t\t \n\t\tif (of_address_to_resource(np, 0, &r))\n\t\t\tcontinue;\n\t\tif (of_node_to_nid(np) != priv->node)\n\t\t\tcontinue;\n\t\tcsrow->first_page = r.start >> PAGE_SHIFT;\n\t\tnr_pages = resource_size(&r) >> PAGE_SHIFT;\n\t\tcsrow->last_page = csrow->first_page + nr_pages - 1;\n\n\t\tfor (j = 0; j < csrow->nr_channels; j++) {\n\t\t\tdimm = csrow->channels[j]->dimm;\n\t\t\tdimm->mtype = MEM_XDR;\n\t\t\tdimm->edac_mode = EDAC_SECDED;\n\t\t\tdimm->nr_pages = nr_pages / csrow->nr_channels;\n\t\t}\n\t\tdev_dbg(mci->pdev,\n\t\t\t\"Initialized on node %d, chanmask=0x%x,\"\n\t\t\t\" first_page=0x%lx, nr_pages=0x%x\\n\",\n\t\t\tpriv->node, priv->chanmask,\n\t\t\tcsrow->first_page, nr_pages);\n\t\tbreak;\n\t}\n\tof_node_put(np);\n}\n\nstatic int cell_edac_probe(struct platform_device *pdev)\n{\n\tstruct cbe_mic_tm_regs __iomem\t*regs;\n\tstruct mem_ctl_info\t\t*mci;\n\tstruct edac_mc_layer\t\tlayers[2];\n\tstruct cell_edac_priv\t\t*priv;\n\tu64\t\t\t\treg;\n\tint\t\t\t\trc, chanmask, num_chans;\n\n\tregs = cbe_get_cpu_mic_tm_regs(cbe_node_to_cpu(pdev->id));\n\tif (regs == NULL)\n\t\treturn -ENODEV;\n\n\tedac_op_state = EDAC_OPSTATE_POLL;\n\n\t \n\treg = in_be64(&regs->mic_mnt_cfg);\n\tdev_dbg(&pdev->dev, \"MIC_MNT_CFG = 0x%016llx\\n\", reg);\n\tchanmask = 0;\n\tif (reg & CBE_MIC_MNT_CFG_CHAN_0_POP)\n\t\tchanmask |= 0x1;\n\tif (reg & CBE_MIC_MNT_CFG_CHAN_1_POP)\n\t\tchanmask |= 0x2;\n\tif (chanmask == 0) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Yuck ! No channel populated ? Aborting !\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(&pdev->dev, \"Initial FIR = 0x%016llx\\n\",\n\t\tin_be64(&regs->mic_fir));\n\n\t \n\tnum_chans = chanmask == 3 ? 2 : 1;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = 1;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = num_chans;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(pdev->id, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct cell_edac_priv));\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\tpriv = mci->pvt_info;\n\tpriv->regs = regs;\n\tpriv->node = pdev->id;\n\tpriv->chanmask = chanmask;\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_XDR;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_EC | EDAC_FLAG_SECDED;\n\tmci->mod_name = \"cell_edac\";\n\tmci->ctl_name = \"MIC\";\n\tmci->dev_name = dev_name(&pdev->dev);\n\tmci->edac_check = cell_edac_check;\n\tcell_edac_init_csrows(mci);\n\n\t \n\trc = edac_mc_add_mc(mci);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to register with EDAC core\\n\");\n\t\tedac_mc_free(mci);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int cell_edac_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = edac_mc_del_mc(&pdev->dev);\n\tif (mci)\n\t\tedac_mc_free(mci);\n\treturn 0;\n}\n\nstatic struct platform_driver cell_edac_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"cbe-mic\",\n\t},\n\t.probe\t\t= cell_edac_probe,\n\t.remove\t\t= cell_edac_remove,\n};\n\nstatic int __init cell_edac_init(void)\n{\n\t \n\tBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\n\t\t\t      mic_df_ecc_address_0) != 0xf8);\n\tBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\n\t\t\t      mic_df_ecc_address_1) != 0x1b8);\n\tBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\n\t\t\t      mic_df_config) != 0x218);\n\tBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\n\t\t\t      mic_fir) != 0x230);\n\tBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\n\t\t\t      mic_mnt_cfg) != 0x210);\n\tBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\n\t\t\t      mic_exc) != 0x208);\n\n\treturn platform_driver_register(&cell_edac_driver);\n}\n\nstatic void __exit cell_edac_exit(void)\n{\n\tplatform_driver_unregister(&cell_edac_driver);\n}\n\nmodule_init(cell_edac_init);\nmodule_exit(cell_edac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_DESCRIPTION(\"ECC counting for Cell MIC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}