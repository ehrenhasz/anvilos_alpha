{
  "module_name": "i7core_edac.c",
  "hash_id": "f66a2acb9431ce56c39e3478cce93bad45ecab50827827c736502cf4e95c57dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i7core_edac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/edac.h>\n#include <linux/mmzone.h>\n#include <linux/smp.h>\n#include <asm/mce.h>\n#include <asm/processor.h>\n#include <asm/div64.h>\n\n#include \"edac_module.h\"\n\n \nstatic LIST_HEAD(i7core_edac_list);\nstatic DEFINE_MUTEX(i7core_edac_lock);\nstatic int probed;\n\nstatic int use_pci_fixup;\nmodule_param(use_pci_fixup, int, 0444);\nMODULE_PARM_DESC(use_pci_fixup, \"Enable PCI fixup to seek for hidden devices\");\n \n#define MAX_SOCKET_BUSES\t2\n\n\n \n#define I7CORE_REVISION    \" Ver: 1.0.0\"\n#define EDAC_MOD_STR      \"i7core_edac\"\n\n \n#define i7core_printk(level, fmt, arg...)\t\t\t\\\n\tedac_printk(level, \"i7core\", fmt, ##arg)\n\n#define i7core_mc_printk(mci, level, fmt, arg...)\t\t\\\n\tedac_mc_chipset_printk(mci, level, \"i7core\", fmt, ##arg)\n\n \n\n\t \n\n#define MC_CFG_CONTROL\t0x90\n  #define MC_CFG_UNLOCK\t\t0x02\n  #define MC_CFG_LOCK\t\t0x00\n\n\t \n\n#define MC_CONTROL\t0x48\n#define MC_STATUS\t0x4c\n#define MC_MAX_DOD\t0x64\n\n \n\n#define MC_TEST_ERR_RCV1\t0x60\n  #define DIMM2_COR_ERR(r)\t\t\t((r) & 0x7fff)\n\n#define MC_TEST_ERR_RCV0\t0x64\n  #define DIMM1_COR_ERR(r)\t\t\t(((r) >> 16) & 0x7fff)\n  #define DIMM0_COR_ERR(r)\t\t\t((r) & 0x7fff)\n\n \n#define MC_SSRCONTROL\t\t0x48\n  #define SSR_MODE_DISABLE\t0x00\n  #define SSR_MODE_ENABLE\t0x01\n  #define SSR_MODE_MASK\t\t0x03\n\n#define MC_SCRUB_CONTROL\t0x4c\n  #define STARTSCRUB\t\t(1 << 24)\n  #define SCRUBINTERVAL_MASK    0xffffff\n\n#define MC_COR_ECC_CNT_0\t0x80\n#define MC_COR_ECC_CNT_1\t0x84\n#define MC_COR_ECC_CNT_2\t0x88\n#define MC_COR_ECC_CNT_3\t0x8c\n#define MC_COR_ECC_CNT_4\t0x90\n#define MC_COR_ECC_CNT_5\t0x94\n\n#define DIMM_TOP_COR_ERR(r)\t\t\t(((r) >> 16) & 0x7fff)\n#define DIMM_BOT_COR_ERR(r)\t\t\t((r) & 0x7fff)\n\n\n\t \n\n#define MC_CHANNEL_DIMM_INIT_PARAMS 0x58\n  #define THREE_DIMMS_PRESENT\t\t(1 << 24)\n  #define SINGLE_QUAD_RANK_PRESENT\t(1 << 23)\n  #define QUAD_RANK_PRESENT\t\t(1 << 22)\n  #define REGISTERED_DIMM\t\t(1 << 15)\n\n#define MC_CHANNEL_MAPPER\t0x60\n  #define RDLCH(r, ch)\t\t((((r) >> (3 + (ch * 6))) & 0x07) - 1)\n  #define WRLCH(r, ch)\t\t((((r) >> (ch * 6)) & 0x07) - 1)\n\n#define MC_CHANNEL_RANK_PRESENT 0x7c\n  #define RANK_PRESENT_MASK\t\t0xffff\n\n#define MC_CHANNEL_ADDR_MATCH\t0xf0\n#define MC_CHANNEL_ERROR_MASK\t0xf8\n#define MC_CHANNEL_ERROR_INJECT\t0xfc\n  #define INJECT_ADDR_PARITY\t0x10\n  #define INJECT_ECC\t\t0x08\n  #define MASK_CACHELINE\t0x06\n  #define MASK_FULL_CACHELINE\t0x06\n  #define MASK_MSB32_CACHELINE\t0x04\n  #define MASK_LSB32_CACHELINE\t0x02\n  #define NO_MASK_CACHELINE\t0x00\n  #define REPEAT_EN\t\t0x01\n\n\t \n\n#define MC_DOD_CH_DIMM0\t\t0x48\n#define MC_DOD_CH_DIMM1\t\t0x4c\n#define MC_DOD_CH_DIMM2\t\t0x50\n  #define RANKOFFSET_MASK\t((1 << 12) | (1 << 11) | (1 << 10))\n  #define RANKOFFSET(x)\t\t((x & RANKOFFSET_MASK) >> 10)\n  #define DIMM_PRESENT_MASK\t(1 << 9)\n  #define DIMM_PRESENT(x)\t(((x) & DIMM_PRESENT_MASK) >> 9)\n  #define MC_DOD_NUMBANK_MASK\t\t((1 << 8) | (1 << 7))\n  #define MC_DOD_NUMBANK(x)\t\t(((x) & MC_DOD_NUMBANK_MASK) >> 7)\n  #define MC_DOD_NUMRANK_MASK\t\t((1 << 6) | (1 << 5))\n  #define MC_DOD_NUMRANK(x)\t\t(((x) & MC_DOD_NUMRANK_MASK) >> 5)\n  #define MC_DOD_NUMROW_MASK\t\t((1 << 4) | (1 << 3) | (1 << 2))\n  #define MC_DOD_NUMROW(x)\t\t(((x) & MC_DOD_NUMROW_MASK) >> 2)\n  #define MC_DOD_NUMCOL_MASK\t\t3\n  #define MC_DOD_NUMCOL(x)\t\t((x) & MC_DOD_NUMCOL_MASK)\n\n#define MC_RANK_PRESENT\t\t0x7c\n\n#define MC_SAG_CH_0\t0x80\n#define MC_SAG_CH_1\t0x84\n#define MC_SAG_CH_2\t0x88\n#define MC_SAG_CH_3\t0x8c\n#define MC_SAG_CH_4\t0x90\n#define MC_SAG_CH_5\t0x94\n#define MC_SAG_CH_6\t0x98\n#define MC_SAG_CH_7\t0x9c\n\n#define MC_RIR_LIMIT_CH_0\t0x40\n#define MC_RIR_LIMIT_CH_1\t0x44\n#define MC_RIR_LIMIT_CH_2\t0x48\n#define MC_RIR_LIMIT_CH_3\t0x4C\n#define MC_RIR_LIMIT_CH_4\t0x50\n#define MC_RIR_LIMIT_CH_5\t0x54\n#define MC_RIR_LIMIT_CH_6\t0x58\n#define MC_RIR_LIMIT_CH_7\t0x5C\n#define MC_RIR_LIMIT_MASK\t((1 << 10) - 1)\n\n#define MC_RIR_WAY_CH\t\t0x80\n  #define MC_RIR_WAY_OFFSET_MASK\t(((1 << 14) - 1) & ~0x7)\n  #define MC_RIR_WAY_RANK_MASK\t\t0x7\n\n \n\n#define NUM_CHANS 3\n#define MAX_DIMMS 3\t\t \n#define MAX_MCR_FUNC  4\n#define MAX_CHAN_FUNC 3\n\nstruct i7core_info {\n\tu32\tmc_control;\n\tu32\tmc_status;\n\tu32\tmax_dod;\n\tu32\tch_map;\n};\n\n\nstruct i7core_inject {\n\tint\tenable;\n\n\tu32\tsection;\n\tu32\ttype;\n\tu32\teccmask;\n\n\t \n\tint channel, dimm, rank, bank, page, col;\n};\n\nstruct i7core_channel {\n\tbool\t\tis_3dimms_present;\n\tbool\t\tis_single_4rank;\n\tbool\t\thas_4rank;\n\tu32\t\tdimms;\n};\n\nstruct pci_id_descr {\n\tint\t\t\tdev;\n\tint\t\t\tfunc;\n\tint \t\t\tdev_id;\n\tint\t\t\toptional;\n};\n\nstruct pci_id_table {\n\tconst struct pci_id_descr\t*descr;\n\tint\t\t\t\tn_devs;\n};\n\nstruct i7core_dev {\n\tstruct list_head\tlist;\n\tu8\t\t\tsocket;\n\tstruct pci_dev\t\t**pdev;\n\tint\t\t\tn_devs;\n\tstruct mem_ctl_info\t*mci;\n};\n\nstruct i7core_pvt {\n\tstruct device *addrmatch_dev, *chancounts_dev;\n\n\tstruct pci_dev\t*pci_noncore;\n\tstruct pci_dev\t*pci_mcr[MAX_MCR_FUNC + 1];\n\tstruct pci_dev\t*pci_ch[NUM_CHANS][MAX_CHAN_FUNC + 1];\n\n\tstruct i7core_dev *i7core_dev;\n\n\tstruct i7core_info\tinfo;\n\tstruct i7core_inject\tinject;\n\tstruct i7core_channel\tchannel[NUM_CHANS];\n\n\tint\t\tce_count_available;\n\n\t\t\t \n\tunsigned long\tudimm_ce_count[MAX_DIMMS];\n\tint\t\tudimm_last_ce_count[MAX_DIMMS];\n\t\t\t \n\tunsigned long\trdimm_ce_count[NUM_CHANS][MAX_DIMMS];\n\tint\t\trdimm_last_ce_count[NUM_CHANS][MAX_DIMMS];\n\n\tbool\t\tis_registered, enable_scrub;\n\n\t \n\tint\t\t\tdclk_freq;\n\n\t \n\tstruct edac_pci_ctl_info *i7core_pci;\n};\n\n#define PCI_DESCR(device, function, device_id)\t\\\n\t.dev = (device),\t\t\t\\\n\t.func = (function),\t\t\t\\\n\t.dev_id = (device_id)\n\nstatic const struct pci_id_descr pci_dev_descr_i7core_nehalem[] = {\n\t\t \n\t{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_I7_MCR)     },\n\t{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_I7_MC_TAD)  },\n\t\t\t \n\t{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_I7_MC_RAS), .optional = 1  },\n\t{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_I7_MC_TEST) },\n\n\t\t \n\t{ PCI_DESCR(4, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH0_CTRL) },\n\t{ PCI_DESCR(4, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH0_ADDR) },\n\t{ PCI_DESCR(4, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH0_RANK) },\n\t{ PCI_DESCR(4, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH0_TC)   },\n\n\t\t \n\t{ PCI_DESCR(5, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH1_CTRL) },\n\t{ PCI_DESCR(5, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH1_ADDR) },\n\t{ PCI_DESCR(5, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH1_RANK) },\n\t{ PCI_DESCR(5, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH1_TC)   },\n\n\t\t \n\t{ PCI_DESCR(6, 0, PCI_DEVICE_ID_INTEL_I7_MC_CH2_CTRL) },\n\t{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_I7_MC_CH2_ADDR) },\n\t{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_I7_MC_CH2_RANK) },\n\t{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_I7_MC_CH2_TC)   },\n\n\t\t \n\t \n\t{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_I7_NONCORE)  },\n\n};\n\nstatic const struct pci_id_descr pci_dev_descr_lynnfield[] = {\n\t{ PCI_DESCR( 3, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MCR)         },\n\t{ PCI_DESCR( 3, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TAD)      },\n\t{ PCI_DESCR( 3, 4, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TEST)     },\n\n\t{ PCI_DESCR( 4, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_CTRL) },\n\t{ PCI_DESCR( 4, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_ADDR) },\n\t{ PCI_DESCR( 4, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_RANK) },\n\t{ PCI_DESCR( 4, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_TC)   },\n\n\t{ PCI_DESCR( 5, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_CTRL) },\n\t{ PCI_DESCR( 5, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR) },\n\t{ PCI_DESCR( 5, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK) },\n\t{ PCI_DESCR( 5, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC)   },\n\n\t \n\t{ PCI_DESCR( 0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE)     },\n};\n\nstatic const struct pci_id_descr pci_dev_descr_i7core_westmere[] = {\n\t\t \n\t{ PCI_DESCR(3, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MCR_REV2)     },\n\t{ PCI_DESCR(3, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TAD_REV2)  },\n\t\t\t \n\t{ PCI_DESCR(3, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_RAS_REV2), .optional = 1  },\n\t{ PCI_DESCR(3, 4, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_TEST_REV2) },\n\n\t\t \n\t{ PCI_DESCR(4, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_CTRL_REV2) },\n\t{ PCI_DESCR(4, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_ADDR_REV2) },\n\t{ PCI_DESCR(4, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_RANK_REV2) },\n\t{ PCI_DESCR(4, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH0_TC_REV2)   },\n\n\t\t \n\t{ PCI_DESCR(5, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_CTRL_REV2) },\n\t{ PCI_DESCR(5, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_ADDR_REV2) },\n\t{ PCI_DESCR(5, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_RANK_REV2) },\n\t{ PCI_DESCR(5, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH1_TC_REV2)   },\n\n\t\t \n\t{ PCI_DESCR(6, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_CTRL_REV2) },\n\t{ PCI_DESCR(6, 1, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_ADDR_REV2) },\n\t{ PCI_DESCR(6, 2, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_RANK_REV2) },\n\t{ PCI_DESCR(6, 3, PCI_DEVICE_ID_INTEL_LYNNFIELD_MC_CH2_TC_REV2)   },\n\n\t\t \n\t{ PCI_DESCR(0, 0, PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2)  },\n\n};\n\n#define PCI_ID_TABLE_ENTRY(A) { .descr=A, .n_devs = ARRAY_SIZE(A) }\nstatic const struct pci_id_table pci_dev_table[] = {\n\tPCI_ID_TABLE_ENTRY(pci_dev_descr_i7core_nehalem),\n\tPCI_ID_TABLE_ENTRY(pci_dev_descr_lynnfield),\n\tPCI_ID_TABLE_ENTRY(pci_dev_descr_i7core_westmere),\n\t{0,}\t\t\t \n};\n\n \nstatic const struct pci_device_id i7core_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_X58_HUB_MGMT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_LYNNFIELD_QPI_LINK0)},\n\t{0,}\t\t\t \n};\n\n \n\n\t \n#define CH_ACTIVE(pvt, ch)\t((pvt)->info.mc_control & (1 << (8 + ch)))\n#define ECCx8(pvt)\t\t((pvt)->info.mc_control & (1 << 1))\n\n\t \n#define ECC_ENABLED(pvt)\t((pvt)->info.mc_status & (1 << 4))\n#define CH_DISABLED(pvt, ch)\t((pvt)->info.mc_status & (1 << ch))\n\n\t \nstatic inline int numdimms(u32 dimms)\n{\n\treturn (dimms & 0x3) + 1;\n}\n\nstatic inline int numrank(u32 rank)\n{\n\tstatic const int ranks[] = { 1, 2, 4, -EINVAL };\n\n\treturn ranks[rank & 0x3];\n}\n\nstatic inline int numbank(u32 bank)\n{\n\tstatic const int banks[] = { 4, 8, 16, -EINVAL };\n\n\treturn banks[bank & 0x3];\n}\n\nstatic inline int numrow(u32 row)\n{\n\tstatic const int rows[] = {\n\t\t1 << 12, 1 << 13, 1 << 14, 1 << 15,\n\t\t1 << 16, -EINVAL, -EINVAL, -EINVAL,\n\t};\n\n\treturn rows[row & 0x7];\n}\n\nstatic inline int numcol(u32 col)\n{\n\tstatic const int cols[] = {\n\t\t1 << 10, 1 << 11, 1 << 12, -EINVAL,\n\t};\n\treturn cols[col & 0x3];\n}\n\nstatic struct i7core_dev *get_i7core_dev(u8 socket)\n{\n\tstruct i7core_dev *i7core_dev;\n\n\tlist_for_each_entry(i7core_dev, &i7core_edac_list, list) {\n\t\tif (i7core_dev->socket == socket)\n\t\t\treturn i7core_dev;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct i7core_dev *alloc_i7core_dev(u8 socket,\n\t\t\t\t\t   const struct pci_id_table *table)\n{\n\tstruct i7core_dev *i7core_dev;\n\n\ti7core_dev = kzalloc(sizeof(*i7core_dev), GFP_KERNEL);\n\tif (!i7core_dev)\n\t\treturn NULL;\n\n\ti7core_dev->pdev = kcalloc(table->n_devs, sizeof(*i7core_dev->pdev),\n\t\t\t\t   GFP_KERNEL);\n\tif (!i7core_dev->pdev) {\n\t\tkfree(i7core_dev);\n\t\treturn NULL;\n\t}\n\n\ti7core_dev->socket = socket;\n\ti7core_dev->n_devs = table->n_devs;\n\tlist_add_tail(&i7core_dev->list, &i7core_edac_list);\n\n\treturn i7core_dev;\n}\n\nstatic void free_i7core_dev(struct i7core_dev *i7core_dev)\n{\n\tlist_del(&i7core_dev->list);\n\tkfree(i7core_dev->pdev);\n\tkfree(i7core_dev);\n}\n\n \n\nstatic int get_dimm_config(struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tstruct pci_dev *pdev;\n\tint i, j;\n\tenum edac_type mode;\n\tenum mem_type mtype;\n\tstruct dimm_info *dimm;\n\n\t \n\tpdev = pvt->pci_mcr[0];\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\t \n\tpci_read_config_dword(pdev, MC_CONTROL, &pvt->info.mc_control);\n\tpci_read_config_dword(pdev, MC_STATUS, &pvt->info.mc_status);\n\tpci_read_config_dword(pdev, MC_MAX_DOD, &pvt->info.max_dod);\n\tpci_read_config_dword(pdev, MC_CHANNEL_MAPPER, &pvt->info.ch_map);\n\n\tedac_dbg(0, \"QPI %d control=0x%08x status=0x%08x dod=0x%08x map=0x%08x\\n\",\n\t\t pvt->i7core_dev->socket, pvt->info.mc_control,\n\t\t pvt->info.mc_status, pvt->info.max_dod, pvt->info.ch_map);\n\n\tif (ECC_ENABLED(pvt)) {\n\t\tedac_dbg(0, \"ECC enabled with x%d SDCC\\n\", ECCx8(pvt) ? 8 : 4);\n\t\tif (ECCx8(pvt))\n\t\t\tmode = EDAC_S8ECD8ED;\n\t\telse\n\t\t\tmode = EDAC_S4ECD4ED;\n\t} else {\n\t\tedac_dbg(0, \"ECC disabled\\n\");\n\t\tmode = EDAC_NONE;\n\t}\n\n\t \n\tedac_dbg(0, \"DOD Max limits: DIMMS: %d, %d-ranked, %d-banked x%x x 0x%x\\n\",\n\t\t numdimms(pvt->info.max_dod),\n\t\t numrank(pvt->info.max_dod >> 2),\n\t\t numbank(pvt->info.max_dod >> 4),\n\t\t numrow(pvt->info.max_dod >> 6),\n\t\t numcol(pvt->info.max_dod >> 9));\n\n\tfor (i = 0; i < NUM_CHANS; i++) {\n\t\tu32 data, dimm_dod[3], value[8];\n\n\t\tif (!pvt->pci_ch[i][0])\n\t\t\tcontinue;\n\n\t\tif (!CH_ACTIVE(pvt, i)) {\n\t\t\tedac_dbg(0, \"Channel %i is not active\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tif (CH_DISABLED(pvt, i)) {\n\t\t\tedac_dbg(0, \"Channel %i is disabled\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpci_read_config_dword(pvt->pci_ch[i][0],\n\t\t\t\tMC_CHANNEL_DIMM_INIT_PARAMS, &data);\n\n\n\t\tif (data & THREE_DIMMS_PRESENT)\n\t\t\tpvt->channel[i].is_3dimms_present = true;\n\n\t\tif (data & SINGLE_QUAD_RANK_PRESENT)\n\t\t\tpvt->channel[i].is_single_4rank = true;\n\n\t\tif (data & QUAD_RANK_PRESENT)\n\t\t\tpvt->channel[i].has_4rank = true;\n\n\t\tif (data & REGISTERED_DIMM)\n\t\t\tmtype = MEM_RDDR3;\n\t\telse\n\t\t\tmtype = MEM_DDR3;\n\n\t\t \n\t\tpci_read_config_dword(pvt->pci_ch[i][1],\n\t\t\t\tMC_DOD_CH_DIMM0, &dimm_dod[0]);\n\t\tpci_read_config_dword(pvt->pci_ch[i][1],\n\t\t\t\tMC_DOD_CH_DIMM1, &dimm_dod[1]);\n\t\tpci_read_config_dword(pvt->pci_ch[i][1],\n\t\t\t\tMC_DOD_CH_DIMM2, &dimm_dod[2]);\n\n\t\tedac_dbg(0, \"Ch%d phy rd%d, wr%d (0x%08x): %s%s%s%cDIMMs\\n\",\n\t\t\t i,\n\t\t\t RDLCH(pvt->info.ch_map, i), WRLCH(pvt->info.ch_map, i),\n\t\t\t data,\n\t\t\t pvt->channel[i].is_3dimms_present ? \"3DIMMS \" : \"\",\n\t\t\t pvt->channel[i].is_3dimms_present ? \"SINGLE_4R \" : \"\",\n\t\t\t pvt->channel[i].has_4rank ? \"HAS_4R \" : \"\",\n\t\t\t (data & REGISTERED_DIMM) ? 'R' : 'U');\n\n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tu32 banks, ranks, rows, cols;\n\t\t\tu32 size, npages;\n\n\t\t\tif (!DIMM_PRESENT(dimm_dod[j]))\n\t\t\t\tcontinue;\n\n\t\t\tdimm = edac_get_dimm(mci, i, j, 0);\n\t\t\tbanks = numbank(MC_DOD_NUMBANK(dimm_dod[j]));\n\t\t\tranks = numrank(MC_DOD_NUMRANK(dimm_dod[j]));\n\t\t\trows = numrow(MC_DOD_NUMROW(dimm_dod[j]));\n\t\t\tcols = numcol(MC_DOD_NUMCOL(dimm_dod[j]));\n\n\t\t\t \n\t\t\tsize = (rows * cols * banks * ranks) >> (20 - 3);\n\n\t\t\tedac_dbg(0, \"\\tdimm %d %d MiB offset: %x, bank: %d, rank: %d, row: %#x, col: %#x\\n\",\n\t\t\t\t j, size,\n\t\t\t\t RANKOFFSET(dimm_dod[j]),\n\t\t\t\t banks, ranks, rows, cols);\n\n\t\t\tnpages = MiB_TO_PAGES(size);\n\n\t\t\tdimm->nr_pages = npages;\n\n\t\t\tswitch (banks) {\n\t\t\tcase 4:\n\t\t\t\tdimm->dtype = DEV_X4;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tdimm->dtype = DEV_X8;\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tdimm->dtype = DEV_X16;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdimm->dtype = DEV_UNKNOWN;\n\t\t\t}\n\n\t\t\tsnprintf(dimm->label, sizeof(dimm->label),\n\t\t\t\t \"CPU#%uChannel#%u_DIMM#%u\",\n\t\t\t\t pvt->i7core_dev->socket, i, j);\n\t\t\tdimm->grain = 8;\n\t\t\tdimm->edac_mode = mode;\n\t\t\tdimm->mtype = mtype;\n\t\t}\n\n\t\tpci_read_config_dword(pdev, MC_SAG_CH_0, &value[0]);\n\t\tpci_read_config_dword(pdev, MC_SAG_CH_1, &value[1]);\n\t\tpci_read_config_dword(pdev, MC_SAG_CH_2, &value[2]);\n\t\tpci_read_config_dword(pdev, MC_SAG_CH_3, &value[3]);\n\t\tpci_read_config_dword(pdev, MC_SAG_CH_4, &value[4]);\n\t\tpci_read_config_dword(pdev, MC_SAG_CH_5, &value[5]);\n\t\tpci_read_config_dword(pdev, MC_SAG_CH_6, &value[6]);\n\t\tpci_read_config_dword(pdev, MC_SAG_CH_7, &value[7]);\n\t\tedac_dbg(1, \"\\t[%i] DIVBY3\\tREMOVED\\tOFFSET\\n\", i);\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tedac_dbg(1, \"\\t\\t%#x\\t%#x\\t%#x\\n\",\n\t\t\t\t (value[j] >> 27) & 0x1,\n\t\t\t\t (value[j] >> 24) & 0x7,\n\t\t\t\t (value[j] & ((1 << 24) - 1)));\n\t}\n\n\treturn 0;\n}\n\n \n\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\n\n \nstatic int disable_inject(const struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\n\tpvt->inject.enable = 0;\n\n\tif (!pvt->pci_ch[pvt->inject.channel][0])\n\t\treturn -ENODEV;\n\n\tpci_write_config_dword(pvt->pci_ch[pvt->inject.channel][0],\n\t\t\t\tMC_CHANNEL_ERROR_INJECT, 0);\n\n\treturn 0;\n}\n\n \nstatic ssize_t i7core_inject_section_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *mattr,\n\t\t\t\t\t   const char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tunsigned long value;\n\tint rc;\n\n\tif (pvt->inject.enable)\n\t\tdisable_inject(mci);\n\n\trc = kstrtoul(data, 10, &value);\n\tif ((rc < 0) || (value > 3))\n\t\treturn -EIO;\n\n\tpvt->inject.section = (u32) value;\n\treturn count;\n}\n\nstatic ssize_t i7core_inject_section_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *mattr,\n\t\t\t\t\t  char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\treturn sprintf(data, \"0x%08x\\n\", pvt->inject.section);\n}\n\n \nstatic ssize_t i7core_inject_type_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *mattr,\n\t\t\t\t\tconst char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tunsigned long value;\n\tint rc;\n\n\tif (pvt->inject.enable)\n\t\tdisable_inject(mci);\n\n\trc = kstrtoul(data, 10, &value);\n\tif ((rc < 0) || (value > 7))\n\t\treturn -EIO;\n\n\tpvt->inject.type = (u32) value;\n\treturn count;\n}\n\nstatic ssize_t i7core_inject_type_show(struct device *dev,\n\t\t\t\t       struct device_attribute *mattr,\n\t\t\t\t       char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\n\treturn sprintf(data, \"0x%08x\\n\", pvt->inject.type);\n}\n\n \nstatic ssize_t i7core_inject_eccmask_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *mattr,\n\t\t\t\t\t   const char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tunsigned long value;\n\tint rc;\n\n\tif (pvt->inject.enable)\n\t\tdisable_inject(mci);\n\n\trc = kstrtoul(data, 10, &value);\n\tif (rc < 0)\n\t\treturn -EIO;\n\n\tpvt->inject.eccmask = (u32) value;\n\treturn count;\n}\n\nstatic ssize_t i7core_inject_eccmask_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *mattr,\n\t\t\t\t\t  char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\n\treturn sprintf(data, \"0x%08x\\n\", pvt->inject.eccmask);\n}\n\n \n\n#define DECLARE_ADDR_MATCH(param, limit)\t\t\t\\\nstatic ssize_t i7core_inject_store_##param(\t\t\t\\\n\tstruct device *dev,\t\t\t\t\t\\\n\tstruct device_attribute *mattr,\t\t\t\t\\\n\tconst char *data, size_t count)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct mem_ctl_info *mci = dev_get_drvdata(dev);\t\\\n\tstruct i7core_pvt *pvt;\t\t\t\t\t\\\n\tlong value;\t\t\t\t\t\t\\\n\tint rc;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tedac_dbg(1, \"\\n\");\t\t\t\t\t\\\n\tpvt = mci->pvt_info;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (pvt->inject.enable)\t\t\t\t\t\\\n\t\tdisable_inject(mci);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (!strcasecmp(data, \"any\") || !strcasecmp(data, \"any\\n\"))\\\n\t\tvalue = -1;\t\t\t\t\t\\\n\telse {\t\t\t\t\t\t\t\\\n\t\trc = kstrtoul(data, 10, &value);\t\t\\\n\t\tif ((rc < 0) || (value >= limit))\t\t\\\n\t\t\treturn -EIO;\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tpvt->inject.param = value;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nstatic ssize_t i7core_inject_show_##param(\t\t\t\\\n\tstruct device *dev,\t\t\t\t\t\\\n\tstruct device_attribute *mattr,\t\t\t\t\\\n\tchar *data)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct mem_ctl_info *mci = dev_get_drvdata(dev);\t\\\n\tstruct i7core_pvt *pvt;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tpvt = mci->pvt_info;\t\t\t\t\t\\\n\tedac_dbg(1, \"pvt=%p\\n\", pvt);\t\t\t\t\\\n\tif (pvt->inject.param < 0)\t\t\t\t\\\n\t\treturn sprintf(data, \"any\\n\");\t\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\treturn sprintf(data, \"%d\\n\", pvt->inject.param);\\\n}\n\n#define ATTR_ADDR_MATCH(param)\t\t\t\t\t\\\n\tstatic DEVICE_ATTR(param, S_IRUGO | S_IWUSR,\t\t\\\n\t\t    i7core_inject_show_##param,\t\t\t\\\n\t\t    i7core_inject_store_##param)\n\nDECLARE_ADDR_MATCH(channel, 3);\nDECLARE_ADDR_MATCH(dimm, 3);\nDECLARE_ADDR_MATCH(rank, 4);\nDECLARE_ADDR_MATCH(bank, 32);\nDECLARE_ADDR_MATCH(page, 0x10000);\nDECLARE_ADDR_MATCH(col, 0x4000);\n\nATTR_ADDR_MATCH(channel);\nATTR_ADDR_MATCH(dimm);\nATTR_ADDR_MATCH(rank);\nATTR_ADDR_MATCH(bank);\nATTR_ADDR_MATCH(page);\nATTR_ADDR_MATCH(col);\n\nstatic int write_and_test(struct pci_dev *dev, const int where, const u32 val)\n{\n\tu32 read;\n\tint count;\n\n\tedac_dbg(0, \"setting pci %02x:%02x.%x reg=%02x value=%08x\\n\",\n\t\t dev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),\n\t\t where, val);\n\n\tfor (count = 0; count < 10; count++) {\n\t\tif (count)\n\t\t\tmsleep(100);\n\t\tpci_write_config_dword(dev, where, val);\n\t\tpci_read_config_dword(dev, where, &read);\n\n\t\tif (read == val)\n\t\t\treturn 0;\n\t}\n\n\ti7core_printk(KERN_ERR, \"Error during set pci %02x:%02x.%x reg=%02x \"\n\t\t\"write=%08x. Read=%08x\\n\",\n\t\tdev->bus->number, PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn),\n\t\twhere, val, read);\n\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t i7core_inject_enable_store(struct device *dev,\n\t\t\t\t\t  struct device_attribute *mattr,\n\t\t\t\t\t  const char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tu32 injectmask;\n\tu64 mask = 0;\n\tint  rc;\n\tlong enable;\n\n\tif (!pvt->pci_ch[pvt->inject.channel][0])\n\t\treturn 0;\n\n\trc = kstrtoul(data, 10, &enable);\n\tif ((rc < 0))\n\t\treturn 0;\n\n\tif (enable) {\n\t\tpvt->inject.enable = 1;\n\t} else {\n\t\tdisable_inject(mci);\n\t\treturn count;\n\t}\n\n\t \n\tif (pvt->inject.dimm < 0)\n\t\tmask |= 1LL << 41;\n\telse {\n\t\tif (pvt->channel[pvt->inject.channel].dimms > 2)\n\t\t\tmask |= (pvt->inject.dimm & 0x3LL) << 35;\n\t\telse\n\t\t\tmask |= (pvt->inject.dimm & 0x1LL) << 36;\n\t}\n\n\t \n\tif (pvt->inject.rank < 0)\n\t\tmask |= 1LL << 40;\n\telse {\n\t\tif (pvt->channel[pvt->inject.channel].dimms > 2)\n\t\t\tmask |= (pvt->inject.rank & 0x1LL) << 34;\n\t\telse\n\t\t\tmask |= (pvt->inject.rank & 0x3LL) << 34;\n\t}\n\n\t \n\tif (pvt->inject.bank < 0)\n\t\tmask |= 1LL << 39;\n\telse\n\t\tmask |= (pvt->inject.bank & 0x15LL) << 30;\n\n\t \n\tif (pvt->inject.page < 0)\n\t\tmask |= 1LL << 38;\n\telse\n\t\tmask |= (pvt->inject.page & 0xffff) << 14;\n\n\t \n\tif (pvt->inject.col < 0)\n\t\tmask |= 1LL << 37;\n\telse\n\t\tmask |= (pvt->inject.col & 0x3fff);\n\n\t \n\n\tinjectmask = (pvt->inject.type & 1) |\n\t\t     (pvt->inject.section & 0x3) << 1 |\n\t\t     (pvt->inject.type & 0x6) << (3 - 1);\n\n\t \n\tpci_write_config_dword(pvt->pci_noncore,\n\t\t\t       MC_CFG_CONTROL, 0x2);\n\n\twrite_and_test(pvt->pci_ch[pvt->inject.channel][0],\n\t\t\t       MC_CHANNEL_ADDR_MATCH, mask);\n\twrite_and_test(pvt->pci_ch[pvt->inject.channel][0],\n\t\t\t       MC_CHANNEL_ADDR_MATCH + 4, mask >> 32L);\n\n\twrite_and_test(pvt->pci_ch[pvt->inject.channel][0],\n\t\t\t       MC_CHANNEL_ERROR_MASK, pvt->inject.eccmask);\n\n\twrite_and_test(pvt->pci_ch[pvt->inject.channel][0],\n\t\t\t       MC_CHANNEL_ERROR_INJECT, injectmask);\n\n\t \n\tpci_write_config_dword(pvt->pci_noncore,\n\t\t\t       MC_CFG_CONTROL, 8);\n\n\tedac_dbg(0, \"Error inject addr match 0x%016llx, ecc 0x%08x, inject 0x%08x\\n\",\n\t\t mask, pvt->inject.eccmask, injectmask);\n\n\n\treturn count;\n}\n\nstatic ssize_t i7core_inject_enable_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *mattr,\n\t\t\t\t\t char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tu32 injectmask;\n\n\tif (!pvt->pci_ch[pvt->inject.channel][0])\n\t\treturn 0;\n\n\tpci_read_config_dword(pvt->pci_ch[pvt->inject.channel][0],\n\t\t\t       MC_CHANNEL_ERROR_INJECT, &injectmask);\n\n\tedac_dbg(0, \"Inject error read: 0x%018x\\n\", injectmask);\n\n\tif (injectmask & 0x0c)\n\t\tpvt->inject.enable = 1;\n\n\treturn sprintf(data, \"%d\\n\", pvt->inject.enable);\n}\n\n#define DECLARE_COUNTER(param)\t\t\t\t\t\\\nstatic ssize_t i7core_show_counter_##param(\t\t\t\\\n\tstruct device *dev,\t\t\t\t\t\\\n\tstruct device_attribute *mattr,\t\t\t\t\\\n\tchar *data)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct mem_ctl_info *mci = dev_get_drvdata(dev);\t\\\n\tstruct i7core_pvt *pvt = mci->pvt_info;\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tedac_dbg(1, \"\\n\");\t\t\t\t\t\\\n\tif (!pvt->ce_count_available || (pvt->is_registered))\t\\\n\t\treturn sprintf(data, \"data unavailable\\n\");\t\\\n\treturn sprintf(data, \"%lu\\n\",\t\t\t\t\\\n\t\t\tpvt->udimm_ce_count[param]);\t\t\\\n}\n\n#define ATTR_COUNTER(param)\t\t\t\t\t\\\n\tstatic DEVICE_ATTR(udimm##param, S_IRUGO | S_IWUSR,\t\\\n\t\t    i7core_show_counter_##param,\t\t\\\n\t\t    NULL)\n\nDECLARE_COUNTER(0);\nDECLARE_COUNTER(1);\nDECLARE_COUNTER(2);\n\nATTR_COUNTER(0);\nATTR_COUNTER(1);\nATTR_COUNTER(2);\n\n \n\nstatic struct attribute *i7core_addrmatch_attrs[] = {\n\t&dev_attr_channel.attr,\n\t&dev_attr_dimm.attr,\n\t&dev_attr_rank.attr,\n\t&dev_attr_bank.attr,\n\t&dev_attr_page.attr,\n\t&dev_attr_col.attr,\n\tNULL\n};\n\nstatic const struct attribute_group addrmatch_grp = {\n\t.attrs\t= i7core_addrmatch_attrs,\n};\n\nstatic const struct attribute_group *addrmatch_groups[] = {\n\t&addrmatch_grp,\n\tNULL\n};\n\nstatic void addrmatch_release(struct device *device)\n{\n\tedac_dbg(1, \"Releasing device %s\\n\", dev_name(device));\n\tkfree(device);\n}\n\nstatic const struct device_type addrmatch_type = {\n\t.groups\t\t= addrmatch_groups,\n\t.release\t= addrmatch_release,\n};\n\n \n\nstatic struct attribute *i7core_udimm_counters_attrs[] = {\n\t&dev_attr_udimm0.attr,\n\t&dev_attr_udimm1.attr,\n\t&dev_attr_udimm2.attr,\n\tNULL\n};\n\nstatic const struct attribute_group all_channel_counts_grp = {\n\t.attrs\t= i7core_udimm_counters_attrs,\n};\n\nstatic const struct attribute_group *all_channel_counts_groups[] = {\n\t&all_channel_counts_grp,\n\tNULL\n};\n\nstatic void all_channel_counts_release(struct device *device)\n{\n\tedac_dbg(1, \"Releasing device %s\\n\", dev_name(device));\n\tkfree(device);\n}\n\nstatic const struct device_type all_channel_counts_type = {\n\t.groups\t\t= all_channel_counts_groups,\n\t.release\t= all_channel_counts_release,\n};\n\n \n\nstatic DEVICE_ATTR(inject_section, S_IRUGO | S_IWUSR,\n\t\t   i7core_inject_section_show, i7core_inject_section_store);\n\nstatic DEVICE_ATTR(inject_type, S_IRUGO | S_IWUSR,\n\t\t   i7core_inject_type_show, i7core_inject_type_store);\n\n\nstatic DEVICE_ATTR(inject_eccmask, S_IRUGO | S_IWUSR,\n\t\t   i7core_inject_eccmask_show, i7core_inject_eccmask_store);\n\nstatic DEVICE_ATTR(inject_enable, S_IRUGO | S_IWUSR,\n\t\t   i7core_inject_enable_show, i7core_inject_enable_store);\n\nstatic struct attribute *i7core_dev_attrs[] = {\n\t&dev_attr_inject_section.attr,\n\t&dev_attr_inject_type.attr,\n\t&dev_attr_inject_eccmask.attr,\n\t&dev_attr_inject_enable.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(i7core_dev);\n\nstatic int i7core_create_sysfs_devices(struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tint rc;\n\n\tpvt->addrmatch_dev = kzalloc(sizeof(*pvt->addrmatch_dev), GFP_KERNEL);\n\tif (!pvt->addrmatch_dev)\n\t\treturn -ENOMEM;\n\n\tpvt->addrmatch_dev->type = &addrmatch_type;\n\tpvt->addrmatch_dev->bus = mci->dev.bus;\n\tdevice_initialize(pvt->addrmatch_dev);\n\tpvt->addrmatch_dev->parent = &mci->dev;\n\tdev_set_name(pvt->addrmatch_dev, \"inject_addrmatch\");\n\tdev_set_drvdata(pvt->addrmatch_dev, mci);\n\n\tedac_dbg(1, \"creating %s\\n\", dev_name(pvt->addrmatch_dev));\n\n\trc = device_add(pvt->addrmatch_dev);\n\tif (rc < 0)\n\t\tgoto err_put_addrmatch;\n\n\tif (!pvt->is_registered) {\n\t\tpvt->chancounts_dev = kzalloc(sizeof(*pvt->chancounts_dev),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!pvt->chancounts_dev) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_del_addrmatch;\n\t\t}\n\n\t\tpvt->chancounts_dev->type = &all_channel_counts_type;\n\t\tpvt->chancounts_dev->bus = mci->dev.bus;\n\t\tdevice_initialize(pvt->chancounts_dev);\n\t\tpvt->chancounts_dev->parent = &mci->dev;\n\t\tdev_set_name(pvt->chancounts_dev, \"all_channel_counts\");\n\t\tdev_set_drvdata(pvt->chancounts_dev, mci);\n\n\t\tedac_dbg(1, \"creating %s\\n\", dev_name(pvt->chancounts_dev));\n\n\t\trc = device_add(pvt->chancounts_dev);\n\t\tif (rc < 0)\n\t\t\tgoto err_put_chancounts;\n\t}\n\treturn 0;\n\nerr_put_chancounts:\n\tput_device(pvt->chancounts_dev);\nerr_del_addrmatch:\n\tdevice_del(pvt->addrmatch_dev);\nerr_put_addrmatch:\n\tput_device(pvt->addrmatch_dev);\n\n\treturn rc;\n}\n\nstatic void i7core_delete_sysfs_devices(struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\n\tedac_dbg(1, \"\\n\");\n\n\tif (!pvt->is_registered) {\n\t\tdevice_del(pvt->chancounts_dev);\n\t\tput_device(pvt->chancounts_dev);\n\t}\n\tdevice_del(pvt->addrmatch_dev);\n\tput_device(pvt->addrmatch_dev);\n}\n\n \n\n \nstatic void i7core_put_devices(struct i7core_dev *i7core_dev)\n{\n\tint i;\n\n\tedac_dbg(0, \"\\n\");\n\tfor (i = 0; i < i7core_dev->n_devs; i++) {\n\t\tstruct pci_dev *pdev = i7core_dev->pdev[i];\n\t\tif (!pdev)\n\t\t\tcontinue;\n\t\tedac_dbg(0, \"Removing dev %02x:%02x.%d\\n\",\n\t\t\t pdev->bus->number,\n\t\t\t PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\n\t\tpci_dev_put(pdev);\n\t}\n}\n\nstatic void i7core_put_all_devices(void)\n{\n\tstruct i7core_dev *i7core_dev, *tmp;\n\n\tlist_for_each_entry_safe(i7core_dev, tmp, &i7core_edac_list, list) {\n\t\ti7core_put_devices(i7core_dev);\n\t\tfree_i7core_dev(i7core_dev);\n\t}\n}\n\nstatic void __init i7core_xeon_pci_fixup(const struct pci_id_table *table)\n{\n\tstruct pci_dev *pdev = NULL;\n\tint i;\n\n\t \n\twhile (table && table->descr) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, table->descr[0].dev_id, NULL);\n\t\tif (unlikely(!pdev)) {\n\t\t\tfor (i = 0; i < MAX_SOCKET_BUSES; i++)\n\t\t\t\tpcibios_scan_specific_bus(255-i);\n\t\t}\n\t\tpci_dev_put(pdev);\n\t\ttable++;\n\t}\n}\n\nstatic unsigned i7core_pci_lastbus(void)\n{\n\tint last_bus = 0, bus;\n\tstruct pci_bus *b = NULL;\n\n\twhile ((b = pci_find_next_bus(b)) != NULL) {\n\t\tbus = b->number;\n\t\tedac_dbg(0, \"Found bus %d\\n\", bus);\n\t\tif (bus > last_bus)\n\t\t\tlast_bus = bus;\n\t}\n\n\tedac_dbg(0, \"Last bus %d\\n\", last_bus);\n\n\treturn last_bus;\n}\n\n \nstatic int i7core_get_onedevice(struct pci_dev **prev,\n\t\t\t\tconst struct pci_id_table *table,\n\t\t\t\tconst unsigned devno,\n\t\t\t\tconst unsigned last_bus)\n{\n\tstruct i7core_dev *i7core_dev;\n\tconst struct pci_id_descr *dev_descr = &table->descr[devno];\n\n\tstruct pci_dev *pdev = NULL;\n\tu8 bus = 0;\n\tu8 socket = 0;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t      dev_descr->dev_id, *prev);\n\n\t \n\tif (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_I7_NONCORE && !pdev) {\n\t\tpci_dev_get(*prev);\t \n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t      PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT, *prev);\n\t}\n\n\tif (dev_descr->dev_id == PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE &&\n\t    !pdev) {\n\t\tpci_dev_get(*prev);\t \n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t      PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT,\n\t\t\t\t      *prev);\n\t}\n\n\tif (!pdev) {\n\t\tif (*prev) {\n\t\t\t*prev = pdev;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (dev_descr->optional)\n\t\t\treturn 0;\n\n\t\tif (devno == 0)\n\t\t\treturn -ENODEV;\n\n\t\ti7core_printk(KERN_INFO,\n\t\t\t\"Device not found: dev %02x.%d PCI ID %04x:%04x\\n\",\n\t\t\tdev_descr->dev, dev_descr->func,\n\t\t\tPCI_VENDOR_ID_INTEL, dev_descr->dev_id);\n\n\t\t \n\t\treturn -ENODEV;\n\t}\n\tbus = pdev->bus->number;\n\n\tsocket = last_bus - bus;\n\n\ti7core_dev = get_i7core_dev(socket);\n\tif (!i7core_dev) {\n\t\ti7core_dev = alloc_i7core_dev(socket, table);\n\t\tif (!i7core_dev) {\n\t\t\tpci_dev_put(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (i7core_dev->pdev[devno]) {\n\t\ti7core_printk(KERN_ERR,\n\t\t\t\"Duplicated device for \"\n\t\t\t\"dev %02x:%02x.%d PCI ID %04x:%04x\\n\",\n\t\t\tbus, dev_descr->dev, dev_descr->func,\n\t\t\tPCI_VENDOR_ID_INTEL, dev_descr->dev_id);\n\t\tpci_dev_put(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\ti7core_dev->pdev[devno] = pdev;\n\n\t \n\tif (unlikely(PCI_SLOT(pdev->devfn) != dev_descr->dev ||\n\t\t\tPCI_FUNC(pdev->devfn) != dev_descr->func)) {\n\t\ti7core_printk(KERN_ERR,\n\t\t\t\"Device PCI ID %04x:%04x \"\n\t\t\t\"has dev %02x:%02x.%d instead of dev %02x:%02x.%d\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL, dev_descr->dev_id,\n\t\t\tbus, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),\n\t\t\tbus, dev_descr->dev, dev_descr->func);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (unlikely(pci_enable_device(pdev) < 0)) {\n\t\ti7core_printk(KERN_ERR,\n\t\t\t\"Couldn't enable \"\n\t\t\t\"dev %02x:%02x.%d PCI ID %04x:%04x\\n\",\n\t\t\tbus, dev_descr->dev, dev_descr->func,\n\t\t\tPCI_VENDOR_ID_INTEL, dev_descr->dev_id);\n\t\treturn -ENODEV;\n\t}\n\n\tedac_dbg(0, \"Detected socket %d dev %02x:%02x.%d PCI ID %04x:%04x\\n\",\n\t\t socket, bus, dev_descr->dev,\n\t\t dev_descr->func,\n\t\t PCI_VENDOR_ID_INTEL, dev_descr->dev_id);\n\n\t \n\tpci_dev_get(pdev);\n\n\t*prev = pdev;\n\n\treturn 0;\n}\n\nstatic int i7core_get_all_devices(void)\n{\n\tint i, rc, last_bus;\n\tstruct pci_dev *pdev = NULL;\n\tconst struct pci_id_table *table = pci_dev_table;\n\n\tlast_bus = i7core_pci_lastbus();\n\n\twhile (table && table->descr) {\n\t\tfor (i = 0; i < table->n_devs; i++) {\n\t\t\tpdev = NULL;\n\t\t\tdo {\n\t\t\t\trc = i7core_get_onedevice(&pdev, table, i,\n\t\t\t\t\t\t\t  last_bus);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\ti = table->n_devs;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti7core_put_all_devices();\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\t}\n\t\t\t} while (pdev);\n\t\t}\n\t\ttable++;\n\t}\n\n\treturn 0;\n}\n\nstatic int mci_bind_devs(struct mem_ctl_info *mci,\n\t\t\t struct i7core_dev *i7core_dev)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tstruct pci_dev *pdev;\n\tint i, func, slot;\n\tchar *family;\n\n\tpvt->is_registered = false;\n\tpvt->enable_scrub  = false;\n\tfor (i = 0; i < i7core_dev->n_devs; i++) {\n\t\tpdev = i7core_dev->pdev[i];\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tfunc = PCI_FUNC(pdev->devfn);\n\t\tslot = PCI_SLOT(pdev->devfn);\n\t\tif (slot == 3) {\n\t\t\tif (unlikely(func > MAX_MCR_FUNC))\n\t\t\t\tgoto error;\n\t\t\tpvt->pci_mcr[func] = pdev;\n\t\t} else if (likely(slot >= 4 && slot < 4 + NUM_CHANS)) {\n\t\t\tif (unlikely(func > MAX_CHAN_FUNC))\n\t\t\t\tgoto error;\n\t\t\tpvt->pci_ch[slot - 4][func] = pdev;\n\t\t} else if (!slot && !func) {\n\t\t\tpvt->pci_noncore = pdev;\n\n\t\t\t \n\t\t\tswitch (pdev->device) {\n\t\t\tcase PCI_DEVICE_ID_INTEL_I7_NONCORE:\n\t\t\t\tfamily = \"Xeon 35xx/ i7core\";\n\t\t\t\tpvt->enable_scrub = false;\n\t\t\t\tbreak;\n\t\t\tcase PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_ALT:\n\t\t\t\tfamily = \"i7-800/i5-700\";\n\t\t\t\tpvt->enable_scrub = false;\n\t\t\t\tbreak;\n\t\t\tcase PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE:\n\t\t\t\tfamily = \"Xeon 34xx\";\n\t\t\t\tpvt->enable_scrub = false;\n\t\t\t\tbreak;\n\t\t\tcase PCI_DEVICE_ID_INTEL_I7_NONCORE_ALT:\n\t\t\t\tfamily = \"Xeon 55xx\";\n\t\t\t\tpvt->enable_scrub = true;\n\t\t\t\tbreak;\n\t\t\tcase PCI_DEVICE_ID_INTEL_LYNNFIELD_NONCORE_REV2:\n\t\t\t\tfamily = \"Xeon 56xx / i7-900\";\n\t\t\t\tpvt->enable_scrub = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfamily = \"unknown\";\n\t\t\t\tpvt->enable_scrub = false;\n\t\t\t}\n\t\t\tedac_dbg(0, \"Detected a processor type %s\\n\", family);\n\t\t} else\n\t\t\tgoto error;\n\n\t\tedac_dbg(0, \"Associated fn %d.%d, dev = %p, socket %d\\n\",\n\t\t\t PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn),\n\t\t\t pdev, i7core_dev->socket);\n\n\t\tif (PCI_SLOT(pdev->devfn) == 3 &&\n\t\t\tPCI_FUNC(pdev->devfn) == 2)\n\t\t\tpvt->is_registered = true;\n\t}\n\n\treturn 0;\n\nerror:\n\ti7core_printk(KERN_ERR, \"Device %d, function %d \"\n\t\t      \"is out of the expected range\\n\",\n\t\t      slot, func);\n\treturn -EINVAL;\n}\n\n \n\nstatic void i7core_rdimm_update_ce_count(struct mem_ctl_info *mci,\n\t\t\t\t\t const int chan,\n\t\t\t\t\t const int new0,\n\t\t\t\t\t const int new1,\n\t\t\t\t\t const int new2)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tint add0 = 0, add1 = 0, add2 = 0;\n\t \n\tif (pvt->ce_count_available) {\n\t\t \n\n\t\tadd2 = new2 - pvt->rdimm_last_ce_count[chan][2];\n\t\tadd1 = new1 - pvt->rdimm_last_ce_count[chan][1];\n\t\tadd0 = new0 - pvt->rdimm_last_ce_count[chan][0];\n\n\t\tif (add2 < 0)\n\t\t\tadd2 += 0x7fff;\n\t\tpvt->rdimm_ce_count[chan][2] += add2;\n\n\t\tif (add1 < 0)\n\t\t\tadd1 += 0x7fff;\n\t\tpvt->rdimm_ce_count[chan][1] += add1;\n\n\t\tif (add0 < 0)\n\t\t\tadd0 += 0x7fff;\n\t\tpvt->rdimm_ce_count[chan][0] += add0;\n\t} else\n\t\tpvt->ce_count_available = 1;\n\n\t \n\tpvt->rdimm_last_ce_count[chan][2] = new2;\n\tpvt->rdimm_last_ce_count[chan][1] = new1;\n\tpvt->rdimm_last_ce_count[chan][0] = new0;\n\n\t \n\tif (add0 != 0)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, add0,\n\t\t\t\t     0, 0, 0,\n\t\t\t\t     chan, 0, -1, \"error\", \"\");\n\tif (add1 != 0)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, add1,\n\t\t\t\t     0, 0, 0,\n\t\t\t\t     chan, 1, -1, \"error\", \"\");\n\tif (add2 != 0)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, add2,\n\t\t\t\t     0, 0, 0,\n\t\t\t\t     chan, 2, -1, \"error\", \"\");\n}\n\nstatic void i7core_rdimm_check_mc_ecc_err(struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tu32 rcv[3][2];\n\tint i, new0, new1, new2;\n\n\t \n\tpci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_0,\n\t\t\t\t\t\t\t\t&rcv[0][0]);\n\tpci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_1,\n\t\t\t\t\t\t\t\t&rcv[0][1]);\n\tpci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_2,\n\t\t\t\t\t\t\t\t&rcv[1][0]);\n\tpci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_3,\n\t\t\t\t\t\t\t\t&rcv[1][1]);\n\tpci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_4,\n\t\t\t\t\t\t\t\t&rcv[2][0]);\n\tpci_read_config_dword(pvt->pci_mcr[2], MC_COR_ECC_CNT_5,\n\t\t\t\t\t\t\t\t&rcv[2][1]);\n\tfor (i = 0 ; i < 3; i++) {\n\t\tedac_dbg(3, \"MC_COR_ECC_CNT%d = 0x%x; MC_COR_ECC_CNT%d = 0x%x\\n\",\n\t\t\t (i * 2), rcv[i][0], (i * 2) + 1, rcv[i][1]);\n\t\t \n\t\tif (pvt->channel[i].dimms > 2) {\n\t\t\tnew0 = DIMM_BOT_COR_ERR(rcv[i][0]);\n\t\t\tnew1 = DIMM_TOP_COR_ERR(rcv[i][0]);\n\t\t\tnew2 = DIMM_BOT_COR_ERR(rcv[i][1]);\n\t\t} else {\n\t\t\tnew0 = DIMM_TOP_COR_ERR(rcv[i][0]) +\n\t\t\t\t\tDIMM_BOT_COR_ERR(rcv[i][0]);\n\t\t\tnew1 = DIMM_TOP_COR_ERR(rcv[i][1]) +\n\t\t\t\t\tDIMM_BOT_COR_ERR(rcv[i][1]);\n\t\t\tnew2 = 0;\n\t\t}\n\n\t\ti7core_rdimm_update_ce_count(mci, i, new0, new1, new2);\n\t}\n}\n\n \nstatic void i7core_udimm_check_mc_ecc_err(struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tu32 rcv1, rcv0;\n\tint new0, new1, new2;\n\n\tif (!pvt->pci_mcr[4]) {\n\t\tedac_dbg(0, \"MCR registers not found\\n\");\n\t\treturn;\n\t}\n\n\t \n\tpci_read_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV1, &rcv1);\n\tpci_read_config_dword(pvt->pci_mcr[4], MC_TEST_ERR_RCV0, &rcv0);\n\n\t \n\tnew2 = DIMM2_COR_ERR(rcv1);\n\tnew1 = DIMM1_COR_ERR(rcv0);\n\tnew0 = DIMM0_COR_ERR(rcv0);\n\n\t \n\tif (pvt->ce_count_available) {\n\t\t \n\t\tint add0, add1, add2;\n\n\t\tadd2 = new2 - pvt->udimm_last_ce_count[2];\n\t\tadd1 = new1 - pvt->udimm_last_ce_count[1];\n\t\tadd0 = new0 - pvt->udimm_last_ce_count[0];\n\n\t\tif (add2 < 0)\n\t\t\tadd2 += 0x7fff;\n\t\tpvt->udimm_ce_count[2] += add2;\n\n\t\tif (add1 < 0)\n\t\t\tadd1 += 0x7fff;\n\t\tpvt->udimm_ce_count[1] += add1;\n\n\t\tif (add0 < 0)\n\t\t\tadd0 += 0x7fff;\n\t\tpvt->udimm_ce_count[0] += add0;\n\n\t\tif (add0 | add1 | add2)\n\t\t\ti7core_printk(KERN_ERR, \"New Corrected error(s): \"\n\t\t\t\t      \"dimm0: +%d, dimm1: +%d, dimm2 +%d\\n\",\n\t\t\t\t      add0, add1, add2);\n\t} else\n\t\tpvt->ce_count_available = 1;\n\n\t \n\tpvt->udimm_last_ce_count[2] = new2;\n\tpvt->udimm_last_ce_count[1] = new1;\n\tpvt->udimm_last_ce_count[0] = new0;\n}\n\n \nstatic void i7core_mce_output_error(struct mem_ctl_info *mci,\n\t\t\t\t    const struct mce *m)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tchar *optype, *err;\n\tenum hw_event_mc_err_type tp_event;\n\tunsigned long error = m->status & 0x1ff0000l;\n\tbool uncorrected_error = m->mcgstatus & 1ll << 61;\n\tbool ripv = m->mcgstatus & 1;\n\tu32 optypenum = (m->status >> 4) & 0x07;\n\tu32 core_err_cnt = (m->status >> 38) & 0x7fff;\n\tu32 dimm = (m->misc >> 16) & 0x3;\n\tu32 channel = (m->misc >> 18) & 0x3;\n\tu32 syndrome = m->misc >> 32;\n\tu32 errnum = find_first_bit(&error, 32);\n\n\tif (uncorrected_error) {\n\t\tcore_err_cnt = 1;\n\t\tif (ripv)\n\t\t\ttp_event = HW_EVENT_ERR_UNCORRECTED;\n\t\telse\n\t\t\ttp_event = HW_EVENT_ERR_FATAL;\n\t} else {\n\t\ttp_event = HW_EVENT_ERR_CORRECTED;\n\t}\n\n\tswitch (optypenum) {\n\tcase 0:\n\t\toptype = \"generic undef request\";\n\t\tbreak;\n\tcase 1:\n\t\toptype = \"read error\";\n\t\tbreak;\n\tcase 2:\n\t\toptype = \"write error\";\n\t\tbreak;\n\tcase 3:\n\t\toptype = \"addr/cmd error\";\n\t\tbreak;\n\tcase 4:\n\t\toptype = \"scrubbing error\";\n\t\tbreak;\n\tdefault:\n\t\toptype = \"reserved\";\n\t\tbreak;\n\t}\n\n\tswitch (errnum) {\n\tcase 16:\n\t\terr = \"read ECC error\";\n\t\tbreak;\n\tcase 17:\n\t\terr = \"RAS ECC error\";\n\t\tbreak;\n\tcase 18:\n\t\terr = \"write parity error\";\n\t\tbreak;\n\tcase 19:\n\t\terr = \"redundancy loss\";\n\t\tbreak;\n\tcase 20:\n\t\terr = \"reserved\";\n\t\tbreak;\n\tcase 21:\n\t\terr = \"memory range error\";\n\t\tbreak;\n\tcase 22:\n\t\terr = \"RTID out of range\";\n\t\tbreak;\n\tcase 23:\n\t\terr = \"address parity error\";\n\t\tbreak;\n\tcase 24:\n\t\terr = \"byte enable parity error\";\n\t\tbreak;\n\tdefault:\n\t\terr = \"unknown\";\n\t}\n\n\t \n\tif (uncorrected_error || !pvt->is_registered)\n\t\tedac_mc_handle_error(tp_event, mci, core_err_cnt,\n\t\t\t\t     m->addr >> PAGE_SHIFT,\n\t\t\t\t     m->addr & ~PAGE_MASK,\n\t\t\t\t     syndrome,\n\t\t\t\t     channel, dimm, -1,\n\t\t\t\t     err, optype);\n}\n\n \nstatic void i7core_check_error(struct mem_ctl_info *mci, struct mce *m)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\n\ti7core_mce_output_error(mci, m);\n\n\t \n\tif (!pvt->is_registered)\n\t\ti7core_udimm_check_mc_ecc_err(mci);\n\telse\n\t\ti7core_rdimm_check_mc_ecc_err(mci);\n}\n\n \nstatic int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,\n\t\t\t\t  void *data)\n{\n\tstruct mce *mce = (struct mce *)data;\n\tstruct i7core_dev *i7_dev;\n\tstruct mem_ctl_info *mci;\n\n\ti7_dev = get_i7core_dev(mce->socketid);\n\tif (!i7_dev || (mce->kflags & MCE_HANDLED_CEC))\n\t\treturn NOTIFY_DONE;\n\n\tmci = i7_dev->mci;\n\n\t \n\tif (((mce->status & 0xffff) >> 7) != 1)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif (mce->bank != 8)\n\t\treturn NOTIFY_DONE;\n\n\ti7core_check_error(mci, mce);\n\n\t \n\tmce->kflags |= MCE_HANDLED_EDAC;\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block i7_mce_dec = {\n\t.notifier_call\t= i7core_mce_check_error,\n\t.priority\t= MCE_PRIO_EDAC,\n};\n\nstruct memdev_dmi_entry {\n\tu8 type;\n\tu8 length;\n\tu16 handle;\n\tu16 phys_mem_array_handle;\n\tu16 mem_err_info_handle;\n\tu16 total_width;\n\tu16 data_width;\n\tu16 size;\n\tu8 form;\n\tu8 device_set;\n\tu8 device_locator;\n\tu8 bank_locator;\n\tu8 memory_type;\n\tu16 type_detail;\n\tu16 speed;\n\tu8 manufacturer;\n\tu8 serial_number;\n\tu8 asset_tag;\n\tu8 part_number;\n\tu8 attributes;\n\tu32 extended_size;\n\tu16 conf_mem_clk_speed;\n} __attribute__((__packed__));\n\n\n \nstatic void decode_dclk(const struct dmi_header *dh, void *_dclk_freq)\n{\n\tint *dclk_freq = _dclk_freq;\n\tu16 dmi_mem_clk_speed;\n\n\tif (*dclk_freq == -1)\n\t\treturn;\n\n\tif (dh->type == DMI_ENTRY_MEM_DEVICE) {\n\t\tstruct memdev_dmi_entry *memdev_dmi_entry =\n\t\t\t(struct memdev_dmi_entry *)dh;\n\t\tunsigned long conf_mem_clk_speed_offset =\n\t\t\t(unsigned long)&memdev_dmi_entry->conf_mem_clk_speed -\n\t\t\t(unsigned long)&memdev_dmi_entry->type;\n\t\tunsigned long speed_offset =\n\t\t\t(unsigned long)&memdev_dmi_entry->speed -\n\t\t\t(unsigned long)&memdev_dmi_entry->type;\n\n\t\t \n\t\tif (memdev_dmi_entry->size == 0)\n\t\t\treturn;\n\n\t\t \n\t\tif (memdev_dmi_entry->length > conf_mem_clk_speed_offset) {\n\t\t\tdmi_mem_clk_speed =\n\t\t\t\tmemdev_dmi_entry->conf_mem_clk_speed;\n\t\t} else if (memdev_dmi_entry->length > speed_offset) {\n\t\t\tdmi_mem_clk_speed = memdev_dmi_entry->speed;\n\t\t} else {\n\t\t\t*dclk_freq = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (*dclk_freq == 0) {\n\t\t\t \n\t\t\tif (dmi_mem_clk_speed > 0) {\n\t\t\t\t \n\t\t\t\t*dclk_freq = dmi_mem_clk_speed;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*dclk_freq = -1;\n\t\t\t}\n\t\t} else if (*dclk_freq > 0 &&\n\t\t\t   *dclk_freq != dmi_mem_clk_speed) {\n\t\t\t \n\t\t\t*dclk_freq = -1;\n\t\t}\n\t}\n}\n\n \n#define DEFAULT_DCLK_FREQ 800\n\nstatic int get_dclk_freq(void)\n{\n\tint dclk_freq = 0;\n\n\tdmi_walk(decode_dclk, (void *)&dclk_freq);\n\n\tif (dclk_freq < 1)\n\t\treturn DEFAULT_DCLK_FREQ;\n\n\treturn dclk_freq;\n}\n\n \nstatic int set_sdram_scrub_rate(struct mem_ctl_info *mci, u32 new_bw)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tstruct pci_dev *pdev;\n\tu32 dw_scrub;\n\tu32 dw_ssr;\n\n\t \n\tpdev = pvt->pci_mcr[2];\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tpci_read_config_dword(pdev, MC_SCRUB_CONTROL, &dw_scrub);\n\n\tif (new_bw == 0) {\n\t\t \n\t\tdw_scrub &= ~STARTSCRUB;\n\t\t \n\t\twrite_and_test(pdev, MC_SCRUB_CONTROL,\n\t\t\t       dw_scrub & ~SCRUBINTERVAL_MASK);\n\n\t\t \n\t\tpci_read_config_dword(pdev, MC_SSRCONTROL, &dw_ssr);\n\t\tdw_ssr &= ~SSR_MODE_MASK;\n\t\tdw_ssr |= SSR_MODE_DISABLE;\n\t} else {\n\t\tconst int cache_line_size = 64;\n\t\tconst u32 freq_dclk_mhz = pvt->dclk_freq;\n\t\tunsigned long long scrub_interval;\n\t\t \n\t\tscrub_interval = (unsigned long long)freq_dclk_mhz *\n\t\t\tcache_line_size * 1000000;\n\t\tdo_div(scrub_interval, new_bw);\n\n\t\tif (!scrub_interval || scrub_interval > SCRUBINTERVAL_MASK)\n\t\t\treturn -EINVAL;\n\n\t\tdw_scrub = SCRUBINTERVAL_MASK & scrub_interval;\n\n\t\t \n\t\tpci_write_config_dword(pdev, MC_SCRUB_CONTROL,\n\t\t\t\t       STARTSCRUB | dw_scrub);\n\n\t\t \n\t\tpci_read_config_dword(pdev, MC_SSRCONTROL, &dw_ssr);\n\t\tdw_ssr &= ~SSR_MODE_MASK;\n\t\tdw_ssr |= SSR_MODE_ENABLE;\n\t}\n\t \n\tpci_write_config_dword(pdev, MC_SSRCONTROL, dw_ssr);\n\n\treturn new_bw;\n}\n\n \nstatic int get_sdram_scrub_rate(struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tstruct pci_dev *pdev;\n\tconst u32 cache_line_size = 64;\n\tconst u32 freq_dclk_mhz = pvt->dclk_freq;\n\tunsigned long long scrub_rate;\n\tu32 scrubval;\n\n\t \n\tpdev = pvt->pci_mcr[2];\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\t \n\tpci_read_config_dword(pdev, MC_SCRUB_CONTROL, &scrubval);\n\n\t \n\tscrubval &=  SCRUBINTERVAL_MASK;\n\tif (!scrubval)\n\t\treturn 0;\n\n\t \n\tscrub_rate =  (unsigned long long)freq_dclk_mhz *\n\t\t1000000 * cache_line_size;\n\tdo_div(scrub_rate, scrubval);\n\treturn (int)scrub_rate;\n}\n\nstatic void enable_sdram_scrub_setting(struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tu32 pci_lock;\n\n\t \n\tpci_read_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, &pci_lock);\n\tpci_lock &= ~0x3;\n\tpci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL,\n\t\t\t       pci_lock | MC_CFG_UNLOCK);\n\n\tmci->set_sdram_scrub_rate = set_sdram_scrub_rate;\n\tmci->get_sdram_scrub_rate = get_sdram_scrub_rate;\n}\n\nstatic void disable_sdram_scrub_setting(struct mem_ctl_info *mci)\n{\n\tstruct i7core_pvt *pvt = mci->pvt_info;\n\tu32 pci_lock;\n\n\t \n\tpci_read_config_dword(pvt->pci_noncore, MC_CFG_CONTROL, &pci_lock);\n\tpci_lock &= ~0x3;\n\tpci_write_config_dword(pvt->pci_noncore, MC_CFG_CONTROL,\n\t\t\t       pci_lock | MC_CFG_LOCK);\n}\n\nstatic void i7core_pci_ctl_create(struct i7core_pvt *pvt)\n{\n\tpvt->i7core_pci = edac_pci_create_generic_ctl(\n\t\t\t\t\t\t&pvt->i7core_dev->pdev[0]->dev,\n\t\t\t\t\t\tEDAC_MOD_STR);\n\tif (unlikely(!pvt->i7core_pci))\n\t\ti7core_printk(KERN_WARNING,\n\t\t\t      \"Unable to setup PCI error report via EDAC\\n\");\n}\n\nstatic void i7core_pci_ctl_release(struct i7core_pvt *pvt)\n{\n\tif (likely(pvt->i7core_pci))\n\t\tedac_pci_release_generic_ctl(pvt->i7core_pci);\n\telse\n\t\ti7core_printk(KERN_ERR,\n\t\t\t\t\"Couldn't find mem_ctl_info for socket %d\\n\",\n\t\t\t\tpvt->i7core_dev->socket);\n\tpvt->i7core_pci = NULL;\n}\n\nstatic void i7core_unregister_mci(struct i7core_dev *i7core_dev)\n{\n\tstruct mem_ctl_info *mci = i7core_dev->mci;\n\tstruct i7core_pvt *pvt;\n\n\tif (unlikely(!mci || !mci->pvt_info)) {\n\t\tedac_dbg(0, \"MC: dev = %p\\n\", &i7core_dev->pdev[0]->dev);\n\n\t\ti7core_printk(KERN_ERR, \"Couldn't find mci handler\\n\");\n\t\treturn;\n\t}\n\n\tpvt = mci->pvt_info;\n\n\tedac_dbg(0, \"MC: mci = %p, dev = %p\\n\", mci, &i7core_dev->pdev[0]->dev);\n\n\t \n\tif (pvt->enable_scrub)\n\t\tdisable_sdram_scrub_setting(mci);\n\n\t \n\ti7core_pci_ctl_release(pvt);\n\n\t \n\ti7core_delete_sysfs_devices(mci);\n\tedac_mc_del_mc(mci->pdev);\n\n\tedac_dbg(1, \"%s: free mci struct\\n\", mci->ctl_name);\n\tkfree(mci->ctl_name);\n\tedac_mc_free(mci);\n\ti7core_dev->mci = NULL;\n}\n\nstatic int i7core_register_mci(struct i7core_dev *i7core_dev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct i7core_pvt *pvt;\n\tint rc;\n\tstruct edac_mc_layer layers[2];\n\n\t \n\n\tlayers[0].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[0].size = NUM_CHANS;\n\tlayers[0].is_virt_csrow = false;\n\tlayers[1].type = EDAC_MC_LAYER_SLOT;\n\tlayers[1].size = MAX_DIMMS;\n\tlayers[1].is_virt_csrow = true;\n\tmci = edac_mc_alloc(i7core_dev->socket, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(*pvt));\n\tif (unlikely(!mci))\n\t\treturn -ENOMEM;\n\n\tedac_dbg(0, \"MC: mci = %p, dev = %p\\n\", mci, &i7core_dev->pdev[0]->dev);\n\n\tpvt = mci->pvt_info;\n\tmemset(pvt, 0, sizeof(*pvt));\n\n\t \n\tpvt->i7core_dev = i7core_dev;\n\ti7core_dev->mci = mci;\n\n\t \n\tmci->mtype_cap = MEM_FLAG_DDR3;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE;\n\tmci->edac_cap = EDAC_FLAG_NONE;\n\tmci->mod_name = \"i7core_edac.c\";\n\n\tmci->ctl_name = kasprintf(GFP_KERNEL, \"i7 core #%d\", i7core_dev->socket);\n\tif (!mci->ctl_name) {\n\t\trc = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tmci->dev_name = pci_name(i7core_dev->pdev[0]);\n\tmci->ctl_page_to_phys = NULL;\n\n\t \n\trc = mci_bind_devs(mci, i7core_dev);\n\tif (unlikely(rc < 0))\n\t\tgoto fail0;\n\n\n\t \n\tget_dimm_config(mci);\n\t \n\tmci->pdev = &i7core_dev->pdev[0]->dev;\n\n\t \n\tif (pvt->enable_scrub)\n\t\tenable_sdram_scrub_setting(mci);\n\n\t \n\tif (unlikely(edac_mc_add_mc_with_groups(mci, i7core_dev_groups))) {\n\t\tedac_dbg(0, \"MC: failed edac_mc_add_mc()\\n\");\n\t\t \n\n\t\trc = -EINVAL;\n\t\tgoto fail0;\n\t}\n\tif (i7core_create_sysfs_devices(mci)) {\n\t\tedac_dbg(0, \"MC: failed to create sysfs nodes\\n\");\n\t\tedac_mc_del_mc(mci->pdev);\n\t\trc = -EINVAL;\n\t\tgoto fail0;\n\t}\n\n\t \n\tpvt->inject.channel = 0;\n\tpvt->inject.dimm = -1;\n\tpvt->inject.rank = -1;\n\tpvt->inject.bank = -1;\n\tpvt->inject.page = -1;\n\tpvt->inject.col = -1;\n\n\t \n\ti7core_pci_ctl_create(pvt);\n\n\t \n\tpvt->dclk_freq = get_dclk_freq();\n\n\treturn 0;\n\nfail0:\n\tkfree(mci->ctl_name);\n\nfail1:\n\tedac_mc_free(mci);\n\ti7core_dev->mci = NULL;\n\treturn rc;\n}\n\n \n\nstatic int i7core_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint rc, count = 0;\n\tstruct i7core_dev *i7core_dev;\n\n\t \n\tmutex_lock(&i7core_edac_lock);\n\n\t \n\tif (unlikely(probed >= 1)) {\n\t\tmutex_unlock(&i7core_edac_lock);\n\t\treturn -ENODEV;\n\t}\n\tprobed++;\n\n\trc = i7core_get_all_devices();\n\tif (unlikely(rc < 0))\n\t\tgoto fail0;\n\n\tlist_for_each_entry(i7core_dev, &i7core_edac_list, list) {\n\t\tcount++;\n\t\trc = i7core_register_mci(i7core_dev);\n\t\tif (unlikely(rc < 0))\n\t\t\tgoto fail1;\n\t}\n\n\t \n\tif (!count) {\n\t\trc = -ENODEV;\n\t\tgoto fail1;\n\t}\n\n\ti7core_printk(KERN_INFO,\n\t\t      \"Driver loaded, %d memory controller(s) found.\\n\",\n\t\t      count);\n\n\tmutex_unlock(&i7core_edac_lock);\n\treturn 0;\n\nfail1:\n\tlist_for_each_entry(i7core_dev, &i7core_edac_list, list)\n\t\ti7core_unregister_mci(i7core_dev);\n\n\ti7core_put_all_devices();\nfail0:\n\tmutex_unlock(&i7core_edac_lock);\n\treturn rc;\n}\n\n \nstatic void i7core_remove(struct pci_dev *pdev)\n{\n\tstruct i7core_dev *i7core_dev;\n\n\tedac_dbg(0, \"\\n\");\n\n\t \n\n\tmutex_lock(&i7core_edac_lock);\n\n\tif (unlikely(!probed)) {\n\t\tmutex_unlock(&i7core_edac_lock);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(i7core_dev, &i7core_edac_list, list)\n\t\ti7core_unregister_mci(i7core_dev);\n\n\t \n\ti7core_put_all_devices();\n\n\tprobed--;\n\n\tmutex_unlock(&i7core_edac_lock);\n}\n\nMODULE_DEVICE_TABLE(pci, i7core_pci_tbl);\n\n \nstatic struct pci_driver i7core_driver = {\n\t.name     = \"i7core_edac\",\n\t.probe    = i7core_probe,\n\t.remove   = i7core_remove,\n\t.id_table = i7core_pci_tbl,\n};\n\n \nstatic int __init i7core_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(2, \"\\n\");\n\n\t \n\topstate_init();\n\n\tif (use_pci_fixup)\n\t\ti7core_xeon_pci_fixup(pci_dev_table);\n\n\tpci_rc = pci_register_driver(&i7core_driver);\n\n\tif (pci_rc >= 0) {\n\t\tmce_register_decode_chain(&i7_mce_dec);\n\t\treturn 0;\n\t}\n\n\ti7core_printk(KERN_ERR, \"Failed to register device with error %d.\\n\",\n\t\t      pci_rc);\n\n\treturn pci_rc;\n}\n\n \nstatic void __exit i7core_exit(void)\n{\n\tedac_dbg(2, \"\\n\");\n\tpci_unregister_driver(&i7core_driver);\n\tmce_unregister_decode_chain(&i7_mce_dec);\n}\n\nmodule_init(i7core_init);\nmodule_exit(i7core_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_AUTHOR(\"Red Hat Inc. (https://www.redhat.com)\");\nMODULE_DESCRIPTION(\"MC Driver for Intel i7 Core memory controllers - \"\n\t\t   I7CORE_REVISION);\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}