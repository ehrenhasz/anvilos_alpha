{
  "module_name": "i3000_edac.c",
  "hash_id": "3c42119f3cea7a4a97f20acb10d6774e06a3ad38e4c25155a0d64ca7dcabcf08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i3000_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\t\"i3000_edac\"\n\n#define I3000_RANKS\t\t8\n#define I3000_RANKS_PER_CHANNEL\t4\n#define I3000_CHANNELS\t\t2\n\n \n\n#define I3000_MCHBAR\t\t0x44\t \n#define I3000_MCHBAR_MASK\t0xffffc000\n#define I3000_MMR_WINDOW_SIZE\t16384\n\n#define I3000_EDEAP\t0x70\t \n#define I3000_DEAP\t0x58\t \n#define I3000_DEAP_GRAIN \t\t(1 << 7)\n\n \n\nstatic inline unsigned long deap_pfn(u8 edeap, u32 deap)\n{\n\tdeap >>= PAGE_SHIFT;\n\tdeap |= (edeap & 1) << (32 - PAGE_SHIFT);\n\treturn deap;\n}\n\nstatic inline unsigned long deap_offset(u32 deap)\n{\n\treturn deap & ~(I3000_DEAP_GRAIN - 1) & ~PAGE_MASK;\n}\n\nstatic inline int deap_channel(u32 deap)\n{\n\treturn deap & 1;\n}\n\n#define I3000_DERRSYN\t0x5c\t \n\n#define I3000_ERRSTS\t0xc8\t \n#define I3000_ERRSTS_BITS\t0x0b03\t \n#define I3000_ERRSTS_UE\t\t0x0002\n#define I3000_ERRSTS_CE\t\t0x0001\n\n#define I3000_ERRCMD\t0xca\t \n\n \n\n#define I3000_DRB_SHIFT 25\t \n\n#define I3000_C0DRB\t0x100\t \n#define I3000_C1DRB\t0x180\t \n\n#define I3000_C0DRA\t0x108\t \n#define I3000_C1DRA\t0x188\t \n\nstatic inline unsigned char odd_rank_attrib(unsigned char dra)\n{\n\treturn (dra & 0x70) >> 4;\n}\n\nstatic inline unsigned char even_rank_attrib(unsigned char dra)\n{\n\treturn dra & 0x07;\n}\n\n#define I3000_C0DRC0\t0x120\t \n\n#define I3000_C0DRC1\t0x124\t \n\nenum i3000p_chips {\n\tI3000 = 0,\n};\n\nstruct i3000_dev_info {\n\tconst char *ctl_name;\n};\n\nstruct i3000_error_info {\n\tu16 errsts;\n\tu8 derrsyn;\n\tu8 edeap;\n\tu32 deap;\n\tu16 errsts2;\n};\n\nstatic const struct i3000_dev_info i3000_devs[] = {\n\t[I3000] = {\n\t\t.ctl_name = \"i3000\"},\n};\n\nstatic struct pci_dev *mci_pdev;\nstatic int i3000_registered = 1;\nstatic struct edac_pci_ctl_info *i3000_pci;\n\nstatic void i3000_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\t struct i3000_error_info *info)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(mci->pdev);\n\n\t \n\tpci_read_config_word(pdev, I3000_ERRSTS, &info->errsts);\n\tif (!(info->errsts & I3000_ERRSTS_BITS))\n\t\treturn;\n\tpci_read_config_byte(pdev, I3000_EDEAP, &info->edeap);\n\tpci_read_config_dword(pdev, I3000_DEAP, &info->deap);\n\tpci_read_config_byte(pdev, I3000_DERRSYN, &info->derrsyn);\n\tpci_read_config_word(pdev, I3000_ERRSTS, &info->errsts2);\n\n\t \n\tif ((info->errsts ^ info->errsts2) & I3000_ERRSTS_BITS) {\n\t\tpci_read_config_byte(pdev, I3000_EDEAP, &info->edeap);\n\t\tpci_read_config_dword(pdev, I3000_DEAP, &info->deap);\n\t\tpci_read_config_byte(pdev, I3000_DERRSYN, &info->derrsyn);\n\t}\n\n\t \n\tpci_write_bits16(pdev, I3000_ERRSTS, I3000_ERRSTS_BITS,\n\t\t\t I3000_ERRSTS_BITS);\n}\n\nstatic int i3000_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct i3000_error_info *info,\n\t\t\t\tint handle_errors)\n{\n\tint row, multi_chan, channel;\n\tunsigned long pfn, offset;\n\n\tmulti_chan = mci->csrows[0]->nr_channels - 1;\n\n\tif (!(info->errsts & I3000_ERRSTS_BITS))\n\t\treturn 0;\n\n\tif (!handle_errors)\n\t\treturn 1;\n\n\tif ((info->errsts ^ info->errsts2) & I3000_ERRSTS_BITS) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1,\n\t\t\t\t     \"UE overwrote CE\", \"\");\n\t\tinfo->errsts = info->errsts2;\n\t}\n\n\tpfn = deap_pfn(info->edeap, info->deap);\n\toffset = deap_offset(info->deap);\n\tchannel = deap_channel(info->deap);\n\n\trow = edac_mc_find_csrow_by_page(mci, pfn);\n\n\tif (info->errsts & I3000_ERRSTS_UE)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     pfn, offset, 0,\n\t\t\t\t     row, -1, -1,\n\t\t\t\t     \"i3000 UE\", \"\");\n\telse\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t     pfn, offset, info->derrsyn,\n\t\t\t\t     row, multi_chan ? channel : 0, -1,\n\t\t\t\t     \"i3000 CE\", \"\");\n\n\treturn 1;\n}\n\nstatic void i3000_check(struct mem_ctl_info *mci)\n{\n\tstruct i3000_error_info info;\n\n\ti3000_get_error_info(mci, &info);\n\ti3000_process_error_info(mci, &info, 1);\n}\n\nstatic int i3000_is_interleaved(const unsigned char *c0dra,\n\t\t\t\tconst unsigned char *c1dra,\n\t\t\t\tconst unsigned char *c0drb,\n\t\t\t\tconst unsigned char *c1drb)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < I3000_RANKS_PER_CHANNEL / 2; i++)\n\t\tif (odd_rank_attrib(c0dra[i]) != odd_rank_attrib(c1dra[i]) ||\n\t\t\teven_rank_attrib(c0dra[i]) !=\n\t\t\t\t\t\teven_rank_attrib(c1dra[i]))\n\t\t\treturn 0;\n\n\t \n\tfor (i = 0; i < I3000_RANKS_PER_CHANNEL; i++)\n\t\tif (c0drb[i] != c1drb[i])\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int i3000_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tint rc;\n\tint i, j;\n\tstruct mem_ctl_info *mci = NULL;\n\tstruct edac_mc_layer layers[2];\n\tunsigned long last_cumul_size, nr_pages;\n\tint interleaved, nr_channels;\n\tunsigned char dra[I3000_RANKS / 2], drb[I3000_RANKS];\n\tunsigned char *c0dra = dra, *c1dra = &dra[I3000_RANKS_PER_CHANNEL / 2];\n\tunsigned char *c0drb = drb, *c1drb = &drb[I3000_RANKS_PER_CHANNEL];\n\tunsigned long mchbar;\n\tvoid __iomem *window;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\tpci_read_config_dword(pdev, I3000_MCHBAR, (u32 *) & mchbar);\n\tmchbar &= I3000_MCHBAR_MASK;\n\twindow = ioremap(mchbar, I3000_MMR_WINDOW_SIZE);\n\tif (!window) {\n\t\tprintk(KERN_ERR \"i3000: cannot map mmio space at 0x%lx\\n\",\n\t\t\tmchbar);\n\t\treturn -ENODEV;\n\t}\n\n\tc0dra[0] = readb(window + I3000_C0DRA + 0);\t \n\tc0dra[1] = readb(window + I3000_C0DRA + 1);\t \n\tc1dra[0] = readb(window + I3000_C1DRA + 0);\t \n\tc1dra[1] = readb(window + I3000_C1DRA + 1);\t \n\n\tfor (i = 0; i < I3000_RANKS_PER_CHANNEL; i++) {\n\t\tc0drb[i] = readb(window + I3000_C0DRB + i);\n\t\tc1drb[i] = readb(window + I3000_C1DRB + i);\n\t}\n\n\tiounmap(window);\n\n\t \n\tinterleaved = i3000_is_interleaved(c0dra, c1dra, c0drb, c1drb);\n\tnr_channels = interleaved ? 2 : 1;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = I3000_RANKS / nr_channels;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = nr_channels;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(3, \"MC: init mci\\n\");\n\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_DDR2;\n\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = i3000_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = i3000_check;\n\tmci->ctl_page_to_phys = NULL;\n\n\t \n\tfor (last_cumul_size = i = 0; i < mci->nr_csrows; i++) {\n\t\tu8 value;\n\t\tu32 cumul_size;\n\t\tstruct csrow_info *csrow = mci->csrows[i];\n\n\t\tvalue = drb[i];\n\t\tcumul_size = value << (I3000_DRB_SHIFT - PAGE_SHIFT);\n\t\tif (interleaved)\n\t\t\tcumul_size <<= 1;\n\t\tedac_dbg(3, \"MC: (%d) cumul_size 0x%x\\n\", i, cumul_size);\n\t\tif (cumul_size == last_cumul_size)\n\t\t\tcontinue;\n\n\t\tcsrow->first_page = last_cumul_size;\n\t\tcsrow->last_page = cumul_size - 1;\n\t\tnr_pages = cumul_size - last_cumul_size;\n\t\tlast_cumul_size = cumul_size;\n\n\t\tfor (j = 0; j < nr_channels; j++) {\n\t\t\tstruct dimm_info *dimm = csrow->channels[j]->dimm;\n\n\t\t\tdimm->nr_pages = nr_pages / nr_channels;\n\t\t\tdimm->grain = I3000_DEAP_GRAIN;\n\t\t\tdimm->mtype = MEM_DDR2;\n\t\t\tdimm->dtype = DEV_UNKNOWN;\n\t\t\tdimm->edac_mode = EDAC_UNKNOWN;\n\t\t}\n\t}\n\n\t \n\tpci_write_bits16(pdev, I3000_ERRSTS, I3000_ERRSTS_BITS,\n\t\t\t I3000_ERRSTS_BITS);\n\n\trc = -ENODEV;\n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"MC: failed edac_mc_add_mc()\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\ti3000_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!i3000_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\t \n\tedac_dbg(3, \"MC: success\\n\");\n\treturn 0;\n\nfail:\n\tif (mci)\n\t\tedac_mc_free(mci);\n\n\treturn rc;\n}\n\n \nstatic int i3000_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint rc;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\tif (pci_enable_device(pdev) < 0)\n\t\treturn -EIO;\n\n\trc = i3000_probe1(pdev, ent->driver_data);\n\tif (!mci_pdev)\n\t\tmci_pdev = pci_dev_get(pdev);\n\n\treturn rc;\n}\n\nstatic void i3000_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (i3000_pci)\n\t\tedac_pci_release_generic_ctl(i3000_pci);\n\n\tmci = edac_mc_del_mc(&pdev->dev);\n\tif (!mci)\n\t\treturn;\n\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id i3000_pci_tbl[] = {\n\t{\n\t PCI_VEND_DEV(INTEL, 3000_HB), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t I3000},\n\t{\n\t 0,\n\t }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, i3000_pci_tbl);\n\nstatic struct pci_driver i3000_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = i3000_init_one,\n\t.remove = i3000_remove_one,\n\t.id_table = i3000_pci_tbl,\n};\n\nstatic int __init i3000_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(3, \"MC:\\n\");\n\n\t \n\topstate_init();\n\n\tpci_rc = pci_register_driver(&i3000_driver);\n\tif (pci_rc < 0)\n\t\tgoto fail0;\n\n\tif (!mci_pdev) {\n\t\ti3000_registered = 0;\n\t\tmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t\tPCI_DEVICE_ID_INTEL_3000_HB, NULL);\n\t\tif (!mci_pdev) {\n\t\t\tedac_dbg(0, \"i3000 pci_get_device fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tpci_rc = i3000_init_one(mci_pdev, i3000_pci_tbl);\n\t\tif (pci_rc < 0) {\n\t\t\tedac_dbg(0, \"i3000 init fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail1:\n\tpci_unregister_driver(&i3000_driver);\n\nfail0:\n\tpci_dev_put(mci_pdev);\n\n\treturn pci_rc;\n}\n\nstatic void __exit i3000_exit(void)\n{\n\tedac_dbg(3, \"MC:\\n\");\n\n\tpci_unregister_driver(&i3000_driver);\n\tif (!i3000_registered) {\n\t\ti3000_remove_one(mci_pdev);\n\t\tpci_dev_put(mci_pdev);\n\t}\n}\n\nmodule_init(i3000_init);\nmodule_exit(i3000_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Akamai Technologies Arthur Ulfeldt/Jason Uhlenkott\");\nMODULE_DESCRIPTION(\"MC support for Intel 3000 memory hub controllers\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}