{
  "module_name": "ti_edac.c",
  "hash_id": "f3beea21d1318424a23e12388e100126b761c5d6b3323c97258d0d811a4618c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/ti_edac.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/edac.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/module.h>\n\n#include \"edac_module.h\"\n\n \n#define EMIF_SDRAM_CONFIG\t\t0x008\n#define EMIF_IRQ_STATUS\t\t\t0x0ac\n#define EMIF_IRQ_ENABLE_SET\t\t0x0b4\n#define EMIF_ECC_CTRL\t\t\t0x110\n#define EMIF_1B_ECC_ERR_CNT\t\t0x130\n#define EMIF_1B_ECC_ERR_THRSH\t\t0x134\n#define EMIF_1B_ECC_ERR_ADDR_LOG\t0x13c\n#define EMIF_2B_ECC_ERR_ADDR_LOG\t0x140\n\n \n#define SDRAM_TYPE_SHIFT\t\t29\n#define SDRAM_TYPE_MASK\t\t\tGENMASK(31, 29)\n#define SDRAM_TYPE_DDR3\t\t\t(3 << SDRAM_TYPE_SHIFT)\n#define SDRAM_TYPE_DDR2\t\t\t(2 << SDRAM_TYPE_SHIFT)\n#define SDRAM_NARROW_MODE_MASK\t\tGENMASK(15, 14)\n#define SDRAM_K2_NARROW_MODE_SHIFT\t12\n#define SDRAM_K2_NARROW_MODE_MASK\tGENMASK(13, 12)\n#define SDRAM_ROWSIZE_SHIFT\t\t7\n#define SDRAM_ROWSIZE_MASK\t\tGENMASK(9, 7)\n#define SDRAM_IBANK_SHIFT\t\t4\n#define SDRAM_IBANK_MASK\t\tGENMASK(6, 4)\n#define SDRAM_K2_IBANK_SHIFT\t\t5\n#define SDRAM_K2_IBANK_MASK\t\tGENMASK(6, 5)\n#define SDRAM_K2_EBANK_SHIFT\t\t3\n#define SDRAM_K2_EBANK_MASK\t\tBIT(SDRAM_K2_EBANK_SHIFT)\n#define SDRAM_PAGESIZE_SHIFT\t\t0\n#define SDRAM_PAGESIZE_MASK\t\tGENMASK(2, 0)\n#define SDRAM_K2_PAGESIZE_SHIFT\t\t0\n#define SDRAM_K2_PAGESIZE_MASK\t\tGENMASK(1, 0)\n\n#define EMIF_1B_ECC_ERR_THRSH_SHIFT\t24\n\n \n#define EMIF_1B_ECC_ERR\t\t\tBIT(5)\n#define EMIF_2B_ECC_ERR\t\t\tBIT(4)\n#define EMIF_WR_ECC_ERR\t\t\tBIT(3)\n#define EMIF_SYS_ERR\t\t\tBIT(0)\n \n#define ECC_ENABLED\t\t\t(BIT(31) | BIT(28))\n\n#define EDAC_MOD_NAME\t\t\t\"ti-emif-edac\"\n\nenum {\n\tEMIF_TYPE_DRA7,\n\tEMIF_TYPE_K2\n};\n\nstruct ti_edac {\n\tvoid __iomem *reg;\n};\n\nstatic u32 ti_edac_readl(struct ti_edac *edac, u16 offset)\n{\n\treturn readl_relaxed(edac->reg + offset);\n}\n\nstatic void ti_edac_writel(struct ti_edac *edac, u32 val, u16 offset)\n{\n\twritel_relaxed(val, edac->reg + offset);\n}\n\nstatic irqreturn_t ti_edac_isr(int irq, void *data)\n{\n\tstruct mem_ctl_info *mci = data;\n\tstruct ti_edac *edac = mci->pvt_info;\n\tu32 irq_status;\n\tu32 err_addr;\n\tint err_count;\n\n\tirq_status = ti_edac_readl(edac, EMIF_IRQ_STATUS);\n\n\tif (irq_status & EMIF_1B_ECC_ERR) {\n\t\terr_addr = ti_edac_readl(edac, EMIF_1B_ECC_ERR_ADDR_LOG);\n\t\terr_count = ti_edac_readl(edac, EMIF_1B_ECC_ERR_CNT);\n\t\tti_edac_writel(edac, err_count, EMIF_1B_ECC_ERR_CNT);\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, err_count,\n\t\t\t\t     err_addr >> PAGE_SHIFT,\n\t\t\t\t     err_addr & ~PAGE_MASK, -1, 0, 0, 0,\n\t\t\t\t     mci->ctl_name, \"1B\");\n\t}\n\n\tif (irq_status & EMIF_2B_ECC_ERR) {\n\t\terr_addr = ti_edac_readl(edac, EMIF_2B_ECC_ERR_ADDR_LOG);\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     err_addr >> PAGE_SHIFT,\n\t\t\t\t     err_addr & ~PAGE_MASK, -1, 0, 0, 0,\n\t\t\t\t     mci->ctl_name, \"2B\");\n\t}\n\n\tif (irq_status & EMIF_WR_ECC_ERR)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     0, 0, -1, 0, 0, 0,\n\t\t\t\t     mci->ctl_name, \"WR\");\n\n\tti_edac_writel(edac, irq_status, EMIF_IRQ_STATUS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ti_edac_setup_dimm(struct mem_ctl_info *mci, u32 type)\n{\n\tstruct dimm_info *dimm;\n\tstruct ti_edac *edac = mci->pvt_info;\n\tint bits;\n\tu32 val;\n\tu32 memsize;\n\n\tdimm = edac_get_dimm(mci, 0, 0, 0);\n\n\tval = ti_edac_readl(edac, EMIF_SDRAM_CONFIG);\n\n\tif (type == EMIF_TYPE_DRA7) {\n\t\tbits = ((val & SDRAM_PAGESIZE_MASK) >> SDRAM_PAGESIZE_SHIFT) + 8;\n\t\tbits += ((val & SDRAM_ROWSIZE_MASK) >> SDRAM_ROWSIZE_SHIFT) + 9;\n\t\tbits += (val & SDRAM_IBANK_MASK) >> SDRAM_IBANK_SHIFT;\n\n\t\tif (val & SDRAM_NARROW_MODE_MASK) {\n\t\t\tbits++;\n\t\t\tdimm->dtype = DEV_X16;\n\t\t} else {\n\t\t\tbits += 2;\n\t\t\tdimm->dtype = DEV_X32;\n\t\t}\n\t} else {\n\t\tbits = 16;\n\t\tbits += ((val & SDRAM_K2_PAGESIZE_MASK) >>\n\t\t\tSDRAM_K2_PAGESIZE_SHIFT) + 8;\n\t\tbits += (val & SDRAM_K2_IBANK_MASK) >> SDRAM_K2_IBANK_SHIFT;\n\t\tbits += (val & SDRAM_K2_EBANK_MASK) >> SDRAM_K2_EBANK_SHIFT;\n\n\t\tval = (val & SDRAM_K2_NARROW_MODE_MASK) >>\n\t\t\tSDRAM_K2_NARROW_MODE_SHIFT;\n\t\tswitch (val) {\n\t\tcase 0:\n\t\t\tbits += 3;\n\t\t\tdimm->dtype = DEV_X64;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbits += 2;\n\t\t\tdimm->dtype = DEV_X32;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbits++;\n\t\t\tdimm->dtype = DEV_X16;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmemsize = 1 << bits;\n\n\tdimm->nr_pages = memsize >> PAGE_SHIFT;\n\tdimm->grain = 4;\n\tif ((val & SDRAM_TYPE_MASK) == SDRAM_TYPE_DDR2)\n\t\tdimm->mtype = MEM_DDR2;\n\telse\n\t\tdimm->mtype = MEM_DDR3;\n\n\tval = ti_edac_readl(edac, EMIF_ECC_CTRL);\n\tif (val & ECC_ENABLED)\n\t\tdimm->edac_mode = EDAC_SECDED;\n\telse\n\t\tdimm->edac_mode = EDAC_NONE;\n}\n\nstatic const struct of_device_id ti_edac_of_match[] = {\n\t{ .compatible = \"ti,emif-keystone\", .data = (void *)EMIF_TYPE_K2 },\n\t{ .compatible = \"ti,emif-dra7xx\", .data = (void *)EMIF_TYPE_DRA7 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ti_edac_of_match);\n\nstatic int _emif_get_id(struct device_node *node)\n{\n\tstruct device_node *np;\n\tconst __be32 *addrp;\n\tu32 addr, my_addr;\n\tint my_id = 0;\n\n\taddrp = of_get_address(node, 0, NULL, NULL);\n\tmy_addr = (u32)of_translate_address(node, addrp);\n\n\tfor_each_matching_node(np, ti_edac_of_match) {\n\t\tif (np == node)\n\t\t\tcontinue;\n\n\t\taddrp = of_get_address(np, 0, NULL, NULL);\n\t\taddr = (u32)of_translate_address(np, addrp);\n\n\t\tedac_printk(KERN_INFO, EDAC_MOD_NAME,\n\t\t\t    \"addr=%x, my_addr=%x\\n\",\n\t\t\t    addr, my_addr);\n\n\t\tif (addr < my_addr)\n\t\t\tmy_id++;\n\t}\n\n\treturn my_id;\n}\n\nstatic int ti_edac_probe(struct platform_device *pdev)\n{\n\tint error_irq = 0, ret = -ENODEV;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tvoid __iomem *reg;\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[1];\n\tconst struct of_device_id *id;\n\tstruct ti_edac *edac;\n\tint emif_id;\n\n\tid = of_match_device(ti_edac_of_match, &pdev->dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\treg = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tlayers[0].type = EDAC_MC_LAYER_ALL_MEM;\n\tlayers[0].size = 1;\n\n\t \n\temif_id = _emif_get_id(pdev->dev.of_node);\n\tif (emif_id < 0)\n\t\treturn -EINVAL;\n\n\tmci = edac_mc_alloc(emif_id, 1, layers, sizeof(*edac));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tmci->pdev = &pdev->dev;\n\tedac = mci->pvt_info;\n\tedac->reg = reg;\n\tplatform_set_drvdata(pdev, mci);\n\n\tmci->mtype_cap = MEM_FLAG_DDR3 | MEM_FLAG_DDR2;\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED | EDAC_FLAG_NONE;\n\tmci->mod_name = EDAC_MOD_NAME;\n\tmci->ctl_name = id->compatible;\n\tmci->dev_name = dev_name(&pdev->dev);\n\n\t \n\tti_edac_setup_dimm(mci, (u32)(id->data));\n\n\t \n\terror_irq = platform_get_irq(pdev, 0);\n\tif (error_irq < 0) {\n\t\tret = error_irq;\n\t\tgoto err;\n\t}\n\n\tret = devm_request_irq(dev, error_irq, ti_edac_isr, 0,\n\t\t\t       \"emif-edac-irq\", mci);\n\tif (ret) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_NAME,\n\t\t\t    \"request_irq fail for EMIF EDAC irq\\n\");\n\t\tgoto err;\n\t}\n\n\tret = edac_mc_add_mc(mci);\n\tif (ret) {\n\t\tedac_printk(KERN_ERR, EDAC_MOD_NAME,\n\t\t\t    \"Failed to register mci: %d.\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tti_edac_writel(edac, 1 << EMIF_1B_ECC_ERR_THRSH_SHIFT,\n\t\t       EMIF_1B_ECC_ERR_THRSH);\n\n\t \n\tti_edac_writel(edac,\n\t\t       EMIF_1B_ECC_ERR | EMIF_2B_ECC_ERR | EMIF_WR_ECC_ERR,\n\t\t       EMIF_IRQ_ENABLE_SET);\n\n\treturn 0;\n\nerr:\n\tedac_mc_free(mci);\n\treturn ret;\n}\n\nstatic int ti_edac_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ti_edac_driver = {\n\t.probe = ti_edac_probe,\n\t.remove = ti_edac_remove,\n\t.driver = {\n\t\t   .name = EDAC_MOD_NAME,\n\t\t   .of_match_table = ti_edac_of_match,\n\t},\n};\n\nmodule_platform_driver(ti_edac_driver);\n\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_DESCRIPTION(\"EDAC Driver for Texas Instruments DDR3 MC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}