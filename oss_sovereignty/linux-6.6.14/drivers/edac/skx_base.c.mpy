{
  "module_name": "skx_base.c",
  "hash_id": "762e39544153d85477cc62fe22951c1fb42284fcd8231f0d5141e02d4b22d738",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/skx_base.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/processor.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/mce.h>\n\n#include \"edac_module.h\"\n#include \"skx_common.h\"\n\n#define EDAC_MOD_STR    \"skx_edac\"\n\n \n#define skx_printk(level, fmt, arg...)\t\t\t\\\n\tedac_printk(level, \"skx\", fmt, ##arg)\n\n#define skx_mc_printk(mci, level, fmt, arg...)\t\t\\\n\tedac_mc_chipset_printk(mci, level, \"skx\", fmt, ##arg)\n\nstatic struct list_head *skx_edac_list;\n\nstatic u64 skx_tolm, skx_tohm;\nstatic int skx_num_sockets;\nstatic unsigned int nvdimm_count;\n\n#define\tMASK26\t0x3FFFFFF\t\t \n#define MASK29\t0x1FFFFFFF\t\t \n\nstatic struct skx_dev *get_skx_dev(struct pci_bus *bus, u8 idx)\n{\n\tstruct skx_dev *d;\n\n\tlist_for_each_entry(d, skx_edac_list, list) {\n\t\tif (d->seg == pci_domain_nr(bus) && d->bus[idx] == bus->number)\n\t\t\treturn d;\n\t}\n\n\treturn NULL;\n}\n\nenum munittype {\n\tCHAN0, CHAN1, CHAN2, SAD_ALL, UTIL_ALL, SAD,\n\tERRCHAN0, ERRCHAN1, ERRCHAN2,\n};\n\nstruct munit {\n\tu16\tdid;\n\tu16\tdevfn[SKX_NUM_IMC];\n\tu8\tbusidx;\n\tu8\tper_socket;\n\tenum munittype mtype;\n};\n\n \nstatic const struct munit skx_all_munits[] = {\n\t{ 0x2054, { }, 1, 1, SAD_ALL },\n\t{ 0x2055, { }, 1, 1, UTIL_ALL },\n\t{ 0x2040, { PCI_DEVFN(10, 0), PCI_DEVFN(12, 0) }, 2, 2, CHAN0 },\n\t{ 0x2044, { PCI_DEVFN(10, 4), PCI_DEVFN(12, 4) }, 2, 2, CHAN1 },\n\t{ 0x2048, { PCI_DEVFN(11, 0), PCI_DEVFN(13, 0) }, 2, 2, CHAN2 },\n\t{ 0x2043, { PCI_DEVFN(10, 3), PCI_DEVFN(12, 3) }, 2, 2, ERRCHAN0 },\n\t{ 0x2047, { PCI_DEVFN(10, 7), PCI_DEVFN(12, 7) }, 2, 2, ERRCHAN1 },\n\t{ 0x204b, { PCI_DEVFN(11, 3), PCI_DEVFN(13, 3) }, 2, 2, ERRCHAN2 },\n\t{ 0x208e, { }, 1, 0, SAD },\n\t{ }\n};\n\nstatic int get_all_munits(const struct munit *m)\n{\n\tstruct pci_dev *pdev, *prev;\n\tstruct skx_dev *d;\n\tu32 reg;\n\tint i = 0, ndev = 0;\n\n\tprev = NULL;\n\tfor (;;) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL, m->did, prev);\n\t\tif (!pdev)\n\t\t\tbreak;\n\t\tndev++;\n\t\tif (m->per_socket == SKX_NUM_IMC) {\n\t\t\tfor (i = 0; i < SKX_NUM_IMC; i++)\n\t\t\t\tif (m->devfn[i] == pdev->devfn)\n\t\t\t\t\tbreak;\n\t\t\tif (i == SKX_NUM_IMC)\n\t\t\t\tgoto fail;\n\t\t}\n\t\td = get_skx_dev(pdev->bus, m->busidx);\n\t\tif (!d)\n\t\t\tgoto fail;\n\n\t\t \n\t\tif (unlikely(pci_enable_device(pdev) < 0)) {\n\t\t\tskx_printk(KERN_ERR, \"Couldn't enable device %04x:%04x\\n\",\n\t\t\t\t   PCI_VENDOR_ID_INTEL, m->did);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tswitch (m->mtype) {\n\t\tcase CHAN0:\n\t\tcase CHAN1:\n\t\tcase CHAN2:\n\t\t\tpci_dev_get(pdev);\n\t\t\td->imc[i].chan[m->mtype].cdev = pdev;\n\t\t\tbreak;\n\t\tcase ERRCHAN0:\n\t\tcase ERRCHAN1:\n\t\tcase ERRCHAN2:\n\t\t\tpci_dev_get(pdev);\n\t\t\td->imc[i].chan[m->mtype - ERRCHAN0].edev = pdev;\n\t\t\tbreak;\n\t\tcase SAD_ALL:\n\t\t\tpci_dev_get(pdev);\n\t\t\td->sad_all = pdev;\n\t\t\tbreak;\n\t\tcase UTIL_ALL:\n\t\t\tpci_dev_get(pdev);\n\t\t\td->util_all = pdev;\n\t\t\tbreak;\n\t\tcase SAD:\n\t\t\t \n\t\t\tpci_read_config_dword(pdev, 0xB4, &reg);\n\t\t\tif (reg != 0) {\n\t\t\t\tif (d->mcroute == 0) {\n\t\t\t\t\td->mcroute = reg;\n\t\t\t\t} else if (d->mcroute != reg) {\n\t\t\t\t\tskx_printk(KERN_ERR, \"mcroute mismatch\\n\");\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tndev--;\n\t\t\tbreak;\n\t\t}\n\n\t\tprev = pdev;\n\t}\n\n\treturn ndev;\nfail:\n\tpci_dev_put(pdev);\n\treturn -ENODEV;\n}\n\nstatic struct res_config skx_cfg = {\n\t.type\t\t\t= SKX,\n\t.decs_did\t\t= 0x2016,\n\t.busno_cfg_offset\t= 0xcc,\n};\n\nstatic const struct x86_cpu_id skx_cpuids[] = {\n\tX86_MATCH_INTEL_FAM6_MODEL_STEPPINGS(SKYLAKE_X, X86_STEPPINGS(0x0, 0xf), &skx_cfg),\n\t{ }\n};\nMODULE_DEVICE_TABLE(x86cpu, skx_cpuids);\n\nstatic bool skx_check_ecc(u32 mcmtr)\n{\n\treturn !!GET_BITFIELD(mcmtr, 2, 2);\n}\n\nstatic int skx_get_dimm_config(struct mem_ctl_info *mci, struct res_config *cfg)\n{\n\tstruct skx_pvt *pvt = mci->pvt_info;\n\tu32 mtr, mcmtr, amap, mcddrtcfg;\n\tstruct skx_imc *imc = pvt->imc;\n\tstruct dimm_info *dimm;\n\tint i, j;\n\tint ndimms;\n\n\t \n\tpci_read_config_dword(imc->chan[0].cdev, 0x87c, &mcmtr);\n\n\tfor (i = 0; i < SKX_NUM_CHANNELS; i++) {\n\t\tndimms = 0;\n\t\tpci_read_config_dword(imc->chan[i].cdev, 0x8C, &amap);\n\t\tpci_read_config_dword(imc->chan[i].cdev, 0x400, &mcddrtcfg);\n\t\tfor (j = 0; j < SKX_NUM_DIMMS; j++) {\n\t\t\tdimm = edac_get_dimm(mci, i, j, 0);\n\t\t\tpci_read_config_dword(imc->chan[i].cdev,\n\t\t\t\t\t      0x80 + 4 * j, &mtr);\n\t\t\tif (IS_DIMM_PRESENT(mtr)) {\n\t\t\t\tndimms += skx_get_dimm_info(mtr, mcmtr, amap, dimm, imc, i, j, cfg);\n\t\t\t} else if (IS_NVDIMM_PRESENT(mcddrtcfg, j)) {\n\t\t\t\tndimms += skx_get_nvdimm_info(dimm, imc, i, j,\n\t\t\t\t\t\t\t      EDAC_MOD_STR);\n\t\t\t\tnvdimm_count++;\n\t\t\t}\n\t\t}\n\t\tif (ndimms && !skx_check_ecc(mcmtr)) {\n\t\t\tskx_printk(KERN_ERR, \"ECC is disabled on imc %d\\n\", imc->mc);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define\tSKX_MAX_SAD 24\n\n#define SKX_GET_SAD(d, i, reg)\t\\\n\tpci_read_config_dword((d)->sad_all, 0x60 + 8 * (i), &(reg))\n#define SKX_GET_ILV(d, i, reg)\t\\\n\tpci_read_config_dword((d)->sad_all, 0x64 + 8 * (i), &(reg))\n\n#define\tSKX_SAD_MOD3MODE(sad)\tGET_BITFIELD((sad), 30, 31)\n#define\tSKX_SAD_MOD3(sad)\tGET_BITFIELD((sad), 27, 27)\n#define SKX_SAD_LIMIT(sad)\t(((u64)GET_BITFIELD((sad), 7, 26) << 26) | MASK26)\n#define\tSKX_SAD_MOD3ASMOD2(sad)\tGET_BITFIELD((sad), 5, 6)\n#define\tSKX_SAD_ATTR(sad)\tGET_BITFIELD((sad), 3, 4)\n#define\tSKX_SAD_INTERLEAVE(sad)\tGET_BITFIELD((sad), 1, 2)\n#define SKX_SAD_ENABLE(sad)\tGET_BITFIELD((sad), 0, 0)\n\n#define SKX_ILV_REMOTE(tgt)\t(((tgt) & 8) == 0)\n#define SKX_ILV_TARGET(tgt)\t((tgt) & 7)\n\nstatic void skx_show_retry_rd_err_log(struct decoded_addr *res,\n\t\t\t\t      char *msg, int len,\n\t\t\t\t      bool scrub_err)\n{\n\tu32 log0, log1, log2, log3, log4;\n\tu32 corr0, corr1, corr2, corr3;\n\tstruct pci_dev *edev;\n\tint n;\n\n\tedev = res->dev->imc[res->imc].chan[res->channel].edev;\n\n\tpci_read_config_dword(edev, 0x154, &log0);\n\tpci_read_config_dword(edev, 0x148, &log1);\n\tpci_read_config_dword(edev, 0x150, &log2);\n\tpci_read_config_dword(edev, 0x15c, &log3);\n\tpci_read_config_dword(edev, 0x114, &log4);\n\n\tn = snprintf(msg, len, \" retry_rd_err_log[%.8x %.8x %.8x %.8x %.8x]\",\n\t\t     log0, log1, log2, log3, log4);\n\n\tpci_read_config_dword(edev, 0x104, &corr0);\n\tpci_read_config_dword(edev, 0x108, &corr1);\n\tpci_read_config_dword(edev, 0x10c, &corr2);\n\tpci_read_config_dword(edev, 0x110, &corr3);\n\n\tif (len - n > 0)\n\t\tsnprintf(msg + n, len - n,\n\t\t\t \" correrrcnt[%.4x %.4x %.4x %.4x %.4x %.4x %.4x %.4x]\",\n\t\t\t corr0 & 0xffff, corr0 >> 16,\n\t\t\t corr1 & 0xffff, corr1 >> 16,\n\t\t\t corr2 & 0xffff, corr2 >> 16,\n\t\t\t corr3 & 0xffff, corr3 >> 16);\n}\n\nstatic bool skx_sad_decode(struct decoded_addr *res)\n{\n\tstruct skx_dev *d = list_first_entry(skx_edac_list, typeof(*d), list);\n\tu64 addr = res->addr;\n\tint i, idx, tgt, lchan, shift;\n\tu32 sad, ilv;\n\tu64 limit, prev_limit;\n\tint remote = 0;\n\n\t \n\tif (addr >= skx_tohm || (addr >= skx_tolm && addr < BIT_ULL(32))) {\n\t\tedac_dbg(0, \"Address 0x%llx out of range\\n\", addr);\n\t\treturn false;\n\t}\n\nrestart:\n\tprev_limit = 0;\n\tfor (i = 0; i < SKX_MAX_SAD; i++) {\n\t\tSKX_GET_SAD(d, i, sad);\n\t\tlimit = SKX_SAD_LIMIT(sad);\n\t\tif (SKX_SAD_ENABLE(sad)) {\n\t\t\tif (addr >= prev_limit && addr <= limit)\n\t\t\t\tgoto sad_found;\n\t\t}\n\t\tprev_limit = limit + 1;\n\t}\n\tedac_dbg(0, \"No SAD entry for 0x%llx\\n\", addr);\n\treturn false;\n\nsad_found:\n\tSKX_GET_ILV(d, i, ilv);\n\n\tswitch (SKX_SAD_INTERLEAVE(sad)) {\n\tcase 0:\n\t\tidx = GET_BITFIELD(addr, 6, 8);\n\t\tbreak;\n\tcase 1:\n\t\tidx = GET_BITFIELD(addr, 8, 10);\n\t\tbreak;\n\tcase 2:\n\t\tidx = GET_BITFIELD(addr, 12, 14);\n\t\tbreak;\n\tcase 3:\n\t\tidx = GET_BITFIELD(addr, 30, 32);\n\t\tbreak;\n\t}\n\n\ttgt = GET_BITFIELD(ilv, 4 * idx, 4 * idx + 3);\n\n\t \n\tif (SKX_ILV_REMOTE(tgt)) {\n\t\tif (remote) {\n\t\t\tedac_dbg(0, \"Double remote!\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tremote = 1;\n\t\tlist_for_each_entry(d, skx_edac_list, list) {\n\t\t\tif (d->imc[0].src_id == SKX_ILV_TARGET(tgt))\n\t\t\t\tgoto restart;\n\t\t}\n\t\tedac_dbg(0, \"Can't find node %d\\n\", SKX_ILV_TARGET(tgt));\n\t\treturn false;\n\t}\n\n\tif (SKX_SAD_MOD3(sad) == 0) {\n\t\tlchan = SKX_ILV_TARGET(tgt);\n\t} else {\n\t\tswitch (SKX_SAD_MOD3MODE(sad)) {\n\t\tcase 0:\n\t\t\tshift = 6;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tshift = 8;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tshift = 12;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tedac_dbg(0, \"illegal mod3mode\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tswitch (SKX_SAD_MOD3ASMOD2(sad)) {\n\t\tcase 0:\n\t\t\tlchan = (addr >> shift) % 3;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tlchan = (addr >> shift) % 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlchan = (addr >> shift) % 2;\n\t\t\tlchan = (lchan << 1) | !lchan;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlchan = ((addr >> shift) % 2) << 1;\n\t\t\tbreak;\n\t\t}\n\t\tlchan = (lchan << 1) | (SKX_ILV_TARGET(tgt) & 1);\n\t}\n\n\tres->dev = d;\n\tres->socket = d->imc[0].src_id;\n\tres->imc = GET_BITFIELD(d->mcroute, lchan * 3, lchan * 3 + 2);\n\tres->channel = GET_BITFIELD(d->mcroute, lchan * 2 + 18, lchan * 2 + 19);\n\n\tedac_dbg(2, \"0x%llx: socket=%d imc=%d channel=%d\\n\",\n\t\t res->addr, res->socket, res->imc, res->channel);\n\treturn true;\n}\n\n#define\tSKX_MAX_TAD 8\n\n#define SKX_GET_TADBASE(d, mc, i, reg)\t\t\t\\\n\tpci_read_config_dword((d)->imc[mc].chan[0].cdev, 0x850 + 4 * (i), &(reg))\n#define SKX_GET_TADWAYNESS(d, mc, i, reg)\t\t\\\n\tpci_read_config_dword((d)->imc[mc].chan[0].cdev, 0x880 + 4 * (i), &(reg))\n#define SKX_GET_TADCHNILVOFFSET(d, mc, ch, i, reg)\t\\\n\tpci_read_config_dword((d)->imc[mc].chan[ch].cdev, 0x90 + 4 * (i), &(reg))\n\n#define\tSKX_TAD_BASE(b)\t\t((u64)GET_BITFIELD((b), 12, 31) << 26)\n#define SKX_TAD_SKT_GRAN(b)\tGET_BITFIELD((b), 4, 5)\n#define SKX_TAD_CHN_GRAN(b)\tGET_BITFIELD((b), 6, 7)\n#define\tSKX_TAD_LIMIT(b)\t(((u64)GET_BITFIELD((b), 12, 31) << 26) | MASK26)\n#define\tSKX_TAD_OFFSET(b)\t((u64)GET_BITFIELD((b), 4, 23) << 26)\n#define\tSKX_TAD_SKTWAYS(b)\t(1 << GET_BITFIELD((b), 10, 11))\n#define\tSKX_TAD_CHNWAYS(b)\t(GET_BITFIELD((b), 8, 9) + 1)\n\n \nstatic int skx_granularity[] = { 6, 8, 12, 30 };\n\nstatic u64 skx_do_interleave(u64 addr, int shift, int ways, u64 lowbits)\n{\n\taddr >>= shift;\n\taddr /= ways;\n\taddr <<= shift;\n\n\treturn addr | (lowbits & ((1ull << shift) - 1));\n}\n\nstatic bool skx_tad_decode(struct decoded_addr *res)\n{\n\tint i;\n\tu32 base, wayness, chnilvoffset;\n\tint skt_interleave_bit, chn_interleave_bit;\n\tu64 channel_addr;\n\n\tfor (i = 0; i < SKX_MAX_TAD; i++) {\n\t\tSKX_GET_TADBASE(res->dev, res->imc, i, base);\n\t\tSKX_GET_TADWAYNESS(res->dev, res->imc, i, wayness);\n\t\tif (SKX_TAD_BASE(base) <= res->addr && res->addr <= SKX_TAD_LIMIT(wayness))\n\t\t\tgoto tad_found;\n\t}\n\tedac_dbg(0, \"No TAD entry for 0x%llx\\n\", res->addr);\n\treturn false;\n\ntad_found:\n\tres->sktways = SKX_TAD_SKTWAYS(wayness);\n\tres->chanways = SKX_TAD_CHNWAYS(wayness);\n\tskt_interleave_bit = skx_granularity[SKX_TAD_SKT_GRAN(base)];\n\tchn_interleave_bit = skx_granularity[SKX_TAD_CHN_GRAN(base)];\n\n\tSKX_GET_TADCHNILVOFFSET(res->dev, res->imc, res->channel, i, chnilvoffset);\n\tchannel_addr = res->addr - SKX_TAD_OFFSET(chnilvoffset);\n\n\tif (res->chanways == 3 && skt_interleave_bit > chn_interleave_bit) {\n\t\t \n\t\tchannel_addr = skx_do_interleave(channel_addr, chn_interleave_bit,\n\t\t\t\t\t\t res->chanways, channel_addr);\n\t\tchannel_addr = skx_do_interleave(channel_addr, skt_interleave_bit,\n\t\t\t\t\t\t res->sktways, channel_addr);\n\t} else {\n\t\t \n\t\tchannel_addr = skx_do_interleave(channel_addr, skt_interleave_bit,\n\t\t\t\t\t\t res->sktways, res->addr);\n\t\tchannel_addr = skx_do_interleave(channel_addr, chn_interleave_bit,\n\t\t\t\t\t\t res->chanways, res->addr);\n\t}\n\n\tres->chan_addr = channel_addr;\n\n\tedac_dbg(2, \"0x%llx: chan_addr=0x%llx sktways=%d chanways=%d\\n\",\n\t\t res->addr, res->chan_addr, res->sktways, res->chanways);\n\treturn true;\n}\n\n#define SKX_MAX_RIR 4\n\n#define SKX_GET_RIRWAYNESS(d, mc, ch, i, reg)\t\t\\\n\tpci_read_config_dword((d)->imc[mc].chan[ch].cdev,\t\\\n\t\t\t      0x108 + 4 * (i), &(reg))\n#define SKX_GET_RIRILV(d, mc, ch, idx, i, reg)\t\t\\\n\tpci_read_config_dword((d)->imc[mc].chan[ch].cdev,\t\\\n\t\t\t      0x120 + 16 * (idx) + 4 * (i), &(reg))\n\n#define\tSKX_RIR_VALID(b) GET_BITFIELD((b), 31, 31)\n#define\tSKX_RIR_LIMIT(b) (((u64)GET_BITFIELD((b), 1, 11) << 29) | MASK29)\n#define\tSKX_RIR_WAYS(b) (1 << GET_BITFIELD((b), 28, 29))\n#define\tSKX_RIR_CHAN_RANK(b) GET_BITFIELD((b), 16, 19)\n#define\tSKX_RIR_OFFSET(b) ((u64)(GET_BITFIELD((b), 2, 15) << 26))\n\nstatic bool skx_rir_decode(struct decoded_addr *res)\n{\n\tint i, idx, chan_rank;\n\tint shift;\n\tu32 rirway, rirlv;\n\tu64 rank_addr, prev_limit = 0, limit;\n\n\tif (res->dev->imc[res->imc].chan[res->channel].dimms[0].close_pg)\n\t\tshift = 6;\n\telse\n\t\tshift = 13;\n\n\tfor (i = 0; i < SKX_MAX_RIR; i++) {\n\t\tSKX_GET_RIRWAYNESS(res->dev, res->imc, res->channel, i, rirway);\n\t\tlimit = SKX_RIR_LIMIT(rirway);\n\t\tif (SKX_RIR_VALID(rirway)) {\n\t\t\tif (prev_limit <= res->chan_addr &&\n\t\t\t    res->chan_addr <= limit)\n\t\t\t\tgoto rir_found;\n\t\t}\n\t\tprev_limit = limit;\n\t}\n\tedac_dbg(0, \"No RIR entry for 0x%llx\\n\", res->addr);\n\treturn false;\n\nrir_found:\n\trank_addr = res->chan_addr >> shift;\n\trank_addr /= SKX_RIR_WAYS(rirway);\n\trank_addr <<= shift;\n\trank_addr |= res->chan_addr & GENMASK_ULL(shift - 1, 0);\n\n\tres->rank_address = rank_addr;\n\tidx = (res->chan_addr >> shift) % SKX_RIR_WAYS(rirway);\n\n\tSKX_GET_RIRILV(res->dev, res->imc, res->channel, idx, i, rirlv);\n\tres->rank_address = rank_addr - SKX_RIR_OFFSET(rirlv);\n\tchan_rank = SKX_RIR_CHAN_RANK(rirlv);\n\tres->channel_rank = chan_rank;\n\tres->dimm = chan_rank / 4;\n\tres->rank = chan_rank % 4;\n\n\tedac_dbg(2, \"0x%llx: dimm=%d rank=%d chan_rank=%d rank_addr=0x%llx\\n\",\n\t\t res->addr, res->dimm, res->rank,\n\t\t res->channel_rank, res->rank_address);\n\treturn true;\n}\n\nstatic u8 skx_close_row[] = {\n\t15, 16, 17, 18, 20, 21, 22, 28, 10, 11, 12, 13, 29, 30, 31, 32, 33, 34\n};\n\nstatic u8 skx_close_column[] = {\n\t3, 4, 5, 14, 19, 23, 24, 25, 26, 27\n};\n\nstatic u8 skx_open_row[] = {\n\t14, 15, 16, 20, 28, 21, 22, 23, 24, 25, 26, 27, 29, 30, 31, 32, 33, 34\n};\n\nstatic u8 skx_open_column[] = {\n\t3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n};\n\nstatic u8 skx_open_fine_column[] = {\n\t3, 4, 5, 7, 8, 9, 10, 11, 12, 13\n};\n\nstatic int skx_bits(u64 addr, int nbits, u8 *bits)\n{\n\tint i, res = 0;\n\n\tfor (i = 0; i < nbits; i++)\n\t\tres |= ((addr >> bits[i]) & 1) << i;\n\treturn res;\n}\n\nstatic int skx_bank_bits(u64 addr, int b0, int b1, int do_xor, int x0, int x1)\n{\n\tint ret = GET_BITFIELD(addr, b0, b0) | (GET_BITFIELD(addr, b1, b1) << 1);\n\n\tif (do_xor)\n\t\tret ^= GET_BITFIELD(addr, x0, x0) | (GET_BITFIELD(addr, x1, x1) << 1);\n\n\treturn ret;\n}\n\nstatic bool skx_mad_decode(struct decoded_addr *r)\n{\n\tstruct skx_dimm *dimm = &r->dev->imc[r->imc].chan[r->channel].dimms[r->dimm];\n\tint bg0 = dimm->fine_grain_bank ? 6 : 13;\n\n\tif (dimm->close_pg) {\n\t\tr->row = skx_bits(r->rank_address, dimm->rowbits, skx_close_row);\n\t\tr->column = skx_bits(r->rank_address, dimm->colbits, skx_close_column);\n\t\tr->column |= 0x400;  \n\t\tr->bank_address = skx_bank_bits(r->rank_address, 8, 9, dimm->bank_xor_enable, 22, 28);\n\t\tr->bank_group = skx_bank_bits(r->rank_address, 6, 7, dimm->bank_xor_enable, 20, 21);\n\t} else {\n\t\tr->row = skx_bits(r->rank_address, dimm->rowbits, skx_open_row);\n\t\tif (dimm->fine_grain_bank)\n\t\t\tr->column = skx_bits(r->rank_address, dimm->colbits, skx_open_fine_column);\n\t\telse\n\t\t\tr->column = skx_bits(r->rank_address, dimm->colbits, skx_open_column);\n\t\tr->bank_address = skx_bank_bits(r->rank_address, 18, 19, dimm->bank_xor_enable, 22, 23);\n\t\tr->bank_group = skx_bank_bits(r->rank_address, bg0, 17, dimm->bank_xor_enable, 20, 21);\n\t}\n\tr->row &= (1u << dimm->rowbits) - 1;\n\n\tedac_dbg(2, \"0x%llx: row=0x%x col=0x%x bank_addr=%d bank_group=%d\\n\",\n\t\t r->addr, r->row, r->column, r->bank_address,\n\t\t r->bank_group);\n\treturn true;\n}\n\nstatic bool skx_decode(struct decoded_addr *res)\n{\n\treturn skx_sad_decode(res) && skx_tad_decode(res) &&\n\t\tskx_rir_decode(res) && skx_mad_decode(res);\n}\n\nstatic struct notifier_block skx_mce_dec = {\n\t.notifier_call\t= skx_mce_check_error,\n\t.priority\t= MCE_PRIO_EDAC,\n};\n\n#ifdef CONFIG_EDAC_DEBUG\n \nstatic struct dentry *skx_test;\n\nstatic int debugfs_u64_set(void *data, u64 val)\n{\n\tstruct mce m;\n\n\tpr_warn_once(\"Fake error to 0x%llx injected via debugfs\\n\", val);\n\n\tmemset(&m, 0, sizeof(m));\n\t \n\tm.status = MCI_STATUS_ADDRV + 0x90;\n\t \n\tm.status |= BIT_ULL(MCI_STATUS_CEC_SHIFT);\n\tm.addr = val;\n\tskx_mce_check_error(NULL, 0, &m);\n\n\treturn 0;\n}\nDEFINE_SIMPLE_ATTRIBUTE(fops_u64_wo, NULL, debugfs_u64_set, \"%llu\\n\");\n\nstatic void setup_skx_debug(void)\n{\n\tskx_test = edac_debugfs_create_dir(\"skx_test\");\n\tif (!skx_test)\n\t\treturn;\n\n\tif (!edac_debugfs_create_file(\"addr\", 0200, skx_test,\n\t\t\t\t      NULL, &fops_u64_wo)) {\n\t\tdebugfs_remove(skx_test);\n\t\tskx_test = NULL;\n\t}\n}\n\nstatic void teardown_skx_debug(void)\n{\n\tdebugfs_remove_recursive(skx_test);\n}\n#else\nstatic inline void setup_skx_debug(void) {}\nstatic inline void teardown_skx_debug(void) {}\n#endif  \n\n \nstatic int __init skx_init(void)\n{\n\tconst struct x86_cpu_id *id;\n\tstruct res_config *cfg;\n\tconst struct munit *m;\n\tconst char *owner;\n\tint rc = 0, i, off[3] = {0xd0, 0xd4, 0xd8};\n\tu8 mc = 0, src_id, node_id;\n\tstruct skx_dev *d;\n\n\tedac_dbg(2, \"\\n\");\n\n\tif (ghes_get_devices())\n\t\treturn -EBUSY;\n\n\towner = edac_get_owner();\n\tif (owner && strncmp(owner, EDAC_MOD_STR, sizeof(EDAC_MOD_STR)))\n\t\treturn -EBUSY;\n\n\tif (cpu_feature_enabled(X86_FEATURE_HYPERVISOR))\n\t\treturn -ENODEV;\n\n\tid = x86_match_cpu(skx_cpuids);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tcfg = (struct res_config *)id->driver_data;\n\n\trc = skx_get_hi_lo(0x2034, off, &skx_tolm, &skx_tohm);\n\tif (rc)\n\t\treturn rc;\n\n\trc = skx_get_all_bus_mappings(cfg, &skx_edac_list);\n\tif (rc < 0)\n\t\tgoto fail;\n\tif (rc == 0) {\n\t\tedac_dbg(2, \"No memory controllers found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tskx_num_sockets = rc;\n\n\tfor (m = skx_all_munits; m->did; m++) {\n\t\trc = get_all_munits(m);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\t\tif (rc != m->per_socket * skx_num_sockets) {\n\t\t\tedac_dbg(2, \"Expected %d, got %d of 0x%x\\n\",\n\t\t\t\t m->per_socket * skx_num_sockets, rc, m->did);\n\t\t\trc = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tlist_for_each_entry(d, skx_edac_list, list) {\n\t\trc = skx_get_src_id(d, 0xf0, &src_id);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\t\trc = skx_get_node_id(d, &node_id);\n\t\tif (rc < 0)\n\t\t\tgoto fail;\n\t\tedac_dbg(2, \"src_id=%d node_id=%d\\n\", src_id, node_id);\n\t\tfor (i = 0; i < SKX_NUM_IMC; i++) {\n\t\t\td->imc[i].mc = mc++;\n\t\t\td->imc[i].lmc = i;\n\t\t\td->imc[i].src_id = src_id;\n\t\t\td->imc[i].node_id = node_id;\n\t\t\trc = skx_register_mci(&d->imc[i], d->imc[i].chan[0].cdev,\n\t\t\t\t\t      \"Skylake Socket\", EDAC_MOD_STR,\n\t\t\t\t\t      skx_get_dimm_config, cfg);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tskx_set_decode(skx_decode, skx_show_retry_rd_err_log);\n\n\tif (nvdimm_count && skx_adxl_get() != -ENODEV) {\n\t\tskx_set_decode(NULL, skx_show_retry_rd_err_log);\n\t} else {\n\t\tif (nvdimm_count)\n\t\t\tskx_printk(KERN_NOTICE, \"Only decoding DDR4 address!\\n\");\n\t\tskx_set_decode(skx_decode, skx_show_retry_rd_err_log);\n\t}\n\n\t \n\topstate_init();\n\n\tsetup_skx_debug();\n\n\tmce_register_decode_chain(&skx_mce_dec);\n\n\treturn 0;\nfail:\n\tskx_remove();\n\treturn rc;\n}\n\nstatic void __exit skx_exit(void)\n{\n\tedac_dbg(2, \"\\n\");\n\tmce_unregister_decode_chain(&skx_mce_dec);\n\tteardown_skx_debug();\n\tif (nvdimm_count)\n\t\tskx_adxl_put();\n\tskx_remove();\n}\n\nmodule_init(skx_init);\nmodule_exit(skx_exit);\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Tony Luck\");\nMODULE_DESCRIPTION(\"MC Driver for Intel Skylake server processors\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}