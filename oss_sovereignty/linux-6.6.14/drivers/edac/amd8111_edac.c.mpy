{
  "module_name": "amd8111_edac.c",
  "hash_id": "80786e315dadab76fee662500e6d3a9eef7e973d38b5ed36027dcb17be38f465",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/amd8111_edac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/edac.h>\n#include <linux/pci_ids.h>\n#include <asm/io.h>\n\n#include \"edac_module.h\"\n#include \"amd8111_edac.h\"\n\n#define AMD8111_EDAC_REVISION\t\" Ver: 1.0.0\"\n#define AMD8111_EDAC_MOD_STR\t\"amd8111_edac\"\n\n#define PCI_DEVICE_ID_AMD_8111_PCI\t0x7460\n\nenum amd8111_edac_devs {\n\tLPC_BRIDGE = 0,\n};\n\nenum amd8111_edac_pcis {\n\tPCI_BRIDGE = 0,\n};\n\n \nstatic int edac_pci_read_dword(struct pci_dev *dev, int reg, u32 *val32)\n{\n\tint ret;\n\n\tret = pci_read_config_dword(dev, reg, val32);\n\tif (ret != 0)\n\t\tprintk(KERN_ERR AMD8111_EDAC_MOD_STR\n\t\t\t\" PCI Access Read Error at 0x%x\\n\", reg);\n\n\treturn ret;\n}\n\nstatic void edac_pci_read_byte(struct pci_dev *dev, int reg, u8 *val8)\n{\n\tint ret;\n\n\tret = pci_read_config_byte(dev, reg, val8);\n\tif (ret != 0)\n\t\tprintk(KERN_ERR AMD8111_EDAC_MOD_STR\n\t\t\t\" PCI Access Read Error at 0x%x\\n\", reg);\n}\n\nstatic void edac_pci_write_dword(struct pci_dev *dev, int reg, u32 val32)\n{\n\tint ret;\n\n\tret = pci_write_config_dword(dev, reg, val32);\n\tif (ret != 0)\n\t\tprintk(KERN_ERR AMD8111_EDAC_MOD_STR\n\t\t\t\" PCI Access Write Error at 0x%x\\n\", reg);\n}\n\nstatic void edac_pci_write_byte(struct pci_dev *dev, int reg, u8 val8)\n{\n\tint ret;\n\n\tret = pci_write_config_byte(dev, reg, val8);\n\tif (ret != 0)\n\t\tprintk(KERN_ERR AMD8111_EDAC_MOD_STR\n\t\t\t\" PCI Access Write Error at 0x%x\\n\", reg);\n}\n\n \nstatic void amd8111_pci_bridge_init(struct amd8111_pci_info *pci_info)\n{\n\tu32 val32;\n\tstruct pci_dev *dev = pci_info->dev;\n\n\t \n\n\t \n\tedac_pci_read_dword(dev, REG_PCI_STSCMD, &val32);\n\tif (val32 & PCI_STSCMD_CLEAR_MASK)\n\t\tedac_pci_write_dword(dev, REG_PCI_STSCMD, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_HT_LINK, &val32);\n\tif (val32 & HT_LINK_CLEAR_MASK)\n\t\tedac_pci_write_dword(dev, REG_HT_LINK, val32);\n\n\t \n\n\t \n\tedac_pci_read_dword(dev, REG_MEM_LIM, &val32);\n\tif (val32 & MEM_LIMIT_CLEAR_MASK)\n\t\tedac_pci_write_dword(dev, REG_MEM_LIM, val32);\n\n\t \n\tedac_pci_read_dword(dev, REG_PCI_INTBRG_CTRL, &val32);\n\tif (val32 & PCI_INTBRG_CTRL_CLEAR_MASK)\n\t\tedac_pci_write_dword(dev, REG_PCI_INTBRG_CTRL, val32);\n\n\t \n\tif (edac_op_state == EDAC_OPSTATE_POLL) {\n\t\t \n\t\tedac_pci_read_dword(dev, REG_PCI_STSCMD, &val32);\n\t\tval32 |= PCI_STSCMD_SERREN;\n\t\tedac_pci_write_dword(dev, REG_PCI_STSCMD, val32);\n\n\t\t \n\t\tedac_pci_read_dword(dev, REG_HT_LINK, &val32);\n\t\tval32 |= HT_LINK_CRCFEN;\n\t\tedac_pci_write_dword(dev, REG_HT_LINK, val32);\n\n\t\t \n\t\tedac_pci_read_dword(dev, REG_PCI_INTBRG_CTRL, &val32);\n\t\tval32 |= PCI_INTBRG_CTRL_POLL_MASK;\n\t\tedac_pci_write_dword(dev, REG_PCI_INTBRG_CTRL, val32);\n\t}\n}\n\nstatic void amd8111_pci_bridge_exit(struct amd8111_pci_info *pci_info)\n{\n\tu32 val32;\n\tstruct pci_dev *dev = pci_info->dev;\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL) {\n\t\t \n\t\tedac_pci_read_dword(dev, REG_PCI_STSCMD, &val32);\n\t\tval32 &= ~PCI_STSCMD_SERREN;\n\t\tedac_pci_write_dword(dev, REG_PCI_STSCMD, val32);\n\n\t\t \n\t\tedac_pci_read_dword(dev, REG_HT_LINK, &val32);\n\t\tval32 &= ~HT_LINK_CRCFEN;\n\t\tedac_pci_write_dword(dev, REG_HT_LINK, val32);\n\n\t\t \n\t\tedac_pci_read_dword(dev, REG_PCI_INTBRG_CTRL, &val32);\n\t\tval32 &= ~PCI_INTBRG_CTRL_POLL_MASK;\n\t\tedac_pci_write_dword(dev, REG_PCI_INTBRG_CTRL, val32);\n\t}\n}\n\nstatic void amd8111_pci_bridge_check(struct edac_pci_ctl_info *edac_dev)\n{\n\tstruct amd8111_pci_info *pci_info = edac_dev->pvt_info;\n\tstruct pci_dev *dev = pci_info->dev;\n\tu32 val32;\n\n\t \n\tedac_pci_read_dword(dev, REG_PCI_STSCMD, &val32);\n\tif (val32 & PCI_STSCMD_CLEAR_MASK) {\n\t\tprintk(KERN_INFO \"Error(s) in PCI bridge status and command\"\n\t\t\t\"register on device %s\\n\", pci_info->ctl_name);\n\t\tprintk(KERN_INFO \"SSE: %d, RMA: %d, RTA: %d\\n\",\n\t\t\t(val32 & PCI_STSCMD_SSE) != 0,\n\t\t\t(val32 & PCI_STSCMD_RMA) != 0,\n\t\t\t(val32 & PCI_STSCMD_RTA) != 0);\n\n\t\tval32 |= PCI_STSCMD_CLEAR_MASK;\n\t\tedac_pci_write_dword(dev, REG_PCI_STSCMD, val32);\n\n\t\tedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\n\t}\n\n\t \n\tedac_pci_read_dword(dev, REG_HT_LINK, &val32);\n\tif (val32 & HT_LINK_LKFAIL) {\n\t\tprintk(KERN_INFO \"Error(s) in hypertransport link control\"\n\t\t\t\"register on device %s\\n\", pci_info->ctl_name);\n\t\tprintk(KERN_INFO \"LKFAIL: %d\\n\",\n\t\t\t(val32 & HT_LINK_LKFAIL) != 0);\n\n\t\tval32 |= HT_LINK_LKFAIL;\n\t\tedac_pci_write_dword(dev, REG_HT_LINK, val32);\n\n\t\tedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\n\t}\n\n\t \n\tedac_pci_read_dword(dev, REG_PCI_INTBRG_CTRL, &val32);\n\tif (val32 & PCI_INTBRG_CTRL_DTSTAT) {\n\t\tprintk(KERN_INFO \"Error(s) in PCI interrupt and bridge control\"\n\t\t\t\"register on device %s\\n\", pci_info->ctl_name);\n\t\tprintk(KERN_INFO \"DTSTAT: %d\\n\",\n\t\t\t(val32 & PCI_INTBRG_CTRL_DTSTAT) != 0);\n\n\t\tval32 |= PCI_INTBRG_CTRL_DTSTAT;\n\t\tedac_pci_write_dword(dev, REG_PCI_INTBRG_CTRL, val32);\n\n\t\tedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\n\t}\n\n\t \n\tedac_pci_read_dword(dev, REG_MEM_LIM, &val32);\n\tif (val32 & MEM_LIMIT_CLEAR_MASK) {\n\t\tprintk(KERN_INFO\n\t\t\t\"Error(s) in mem limit register on %s device\\n\",\n\t\t\tpci_info->ctl_name);\n\t\tprintk(KERN_INFO \"DPE: %d, RSE: %d, RMA: %d\\n\"\n\t\t\t\"RTA: %d, STA: %d, MDPE: %d\\n\",\n\t\t\t(val32 & MEM_LIMIT_DPE)  != 0,\n\t\t\t(val32 & MEM_LIMIT_RSE)  != 0,\n\t\t\t(val32 & MEM_LIMIT_RMA)  != 0,\n\t\t\t(val32 & MEM_LIMIT_RTA)  != 0,\n\t\t\t(val32 & MEM_LIMIT_STA)  != 0,\n\t\t\t(val32 & MEM_LIMIT_MDPE) != 0);\n\n\t\tval32 |= MEM_LIMIT_CLEAR_MASK;\n\t\tedac_pci_write_dword(dev, REG_MEM_LIM, val32);\n\n\t\tedac_pci_handle_npe(edac_dev, edac_dev->ctl_name);\n\t}\n}\n\nstatic struct resource *legacy_io_res;\nstatic int at_compat_reg_broken;\n#define LEGACY_NR_PORTS\t1\n\n \nstatic void amd8111_lpc_bridge_init(struct amd8111_dev_info *dev_info)\n{\n\tu8 val8;\n\tstruct pci_dev *dev = dev_info->dev;\n\n\t \n\tlegacy_io_res = request_region(REG_AT_COMPAT, LEGACY_NR_PORTS,\n\t\t\t\t\tAMD8111_EDAC_MOD_STR);\n\tif (!legacy_io_res)\n\t\tprintk(KERN_INFO \"%s: failed to request legacy I/O region \"\n\t\t\t\"start %d, len %d\\n\", __func__,\n\t\t\tREG_AT_COMPAT, LEGACY_NR_PORTS);\n\telse {\n\t\tval8 = __do_inb(REG_AT_COMPAT);\n\t\tif (val8 == 0xff) {  \n\t\t\tprintk(KERN_INFO \"%s: port %d is buggy, not supported\"\n\t\t\t\t\" by hardware?\\n\", __func__, REG_AT_COMPAT);\n\t\t\tat_compat_reg_broken = 1;\n\t\t\trelease_region(REG_AT_COMPAT, LEGACY_NR_PORTS);\n\t\t\tlegacy_io_res = NULL;\n\t\t} else {\n\t\t\tu8 out8 = 0;\n\t\t\tif (val8 & AT_COMPAT_SERR)\n\t\t\t\tout8 = AT_COMPAT_CLRSERR;\n\t\t\tif (val8 & AT_COMPAT_IOCHK)\n\t\t\t\tout8 |= AT_COMPAT_CLRIOCHK;\n\t\t\tif (out8 > 0)\n\t\t\t\t__do_outb(out8, REG_AT_COMPAT);\n\t\t}\n\t}\n\n\t \n\tedac_pci_read_byte(dev, REG_IO_CTRL_1, &val8);\n\tif (val8 & IO_CTRL_1_CLEAR_MASK)\n\t\tedac_pci_write_byte(dev, REG_IO_CTRL_1, val8);\n}\n\nstatic void amd8111_lpc_bridge_exit(struct amd8111_dev_info *dev_info)\n{\n\tif (legacy_io_res)\n\t\trelease_region(REG_AT_COMPAT, LEGACY_NR_PORTS);\n}\n\nstatic void amd8111_lpc_bridge_check(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct amd8111_dev_info *dev_info = edac_dev->pvt_info;\n\tstruct pci_dev *dev = dev_info->dev;\n\tu8 val8;\n\n\tedac_pci_read_byte(dev, REG_IO_CTRL_1, &val8);\n\tif (val8 & IO_CTRL_1_CLEAR_MASK) {\n\t\tprintk(KERN_INFO\n\t\t\t\"Error(s) in IO control register on %s device\\n\",\n\t\t\tdev_info->ctl_name);\n\t\tprintk(KERN_INFO \"LPC ERR: %d, PW2LPC: %d\\n\",\n\t\t\t(val8 & IO_CTRL_1_LPC_ERR) != 0,\n\t\t\t(val8 & IO_CTRL_1_PW2LPC) != 0);\n\n\t\tval8 |= IO_CTRL_1_CLEAR_MASK;\n\t\tedac_pci_write_byte(dev, REG_IO_CTRL_1, val8);\n\n\t\tedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\n\t}\n\n\tif (at_compat_reg_broken == 0) {\n\t\tu8 out8 = 0;\n\t\tval8 = __do_inb(REG_AT_COMPAT);\n\t\tif (val8 & AT_COMPAT_SERR)\n\t\t\tout8 = AT_COMPAT_CLRSERR;\n\t\tif (val8 & AT_COMPAT_IOCHK)\n\t\t\tout8 |= AT_COMPAT_CLRIOCHK;\n\t\tif (out8 > 0) {\n\t\t\t__do_outb(out8, REG_AT_COMPAT);\n\t\t\tedac_device_handle_ue(edac_dev, 0, 0,\n\t\t\t\t\t\tedac_dev->ctl_name);\n\t\t}\n\t}\n}\n\n \nstatic struct amd8111_dev_info amd8111_devices[] = {\n\t[LPC_BRIDGE] = {\n\t\t.err_dev = PCI_DEVICE_ID_AMD_8111_LPC,\n\t\t.ctl_name = \"lpc\",\n\t\t.init = amd8111_lpc_bridge_init,\n\t\t.exit = amd8111_lpc_bridge_exit,\n\t\t.check = amd8111_lpc_bridge_check,\n\t},\n\t{0},\n};\n\n \nstatic struct amd8111_pci_info amd8111_pcis[] = {\n\t[PCI_BRIDGE] = {\n\t\t.err_dev = PCI_DEVICE_ID_AMD_8111_PCI,\n\t\t.ctl_name = \"AMD8111_PCI_Controller\",\n\t\t.init = amd8111_pci_bridge_init,\n\t\t.exit = amd8111_pci_bridge_exit,\n\t\t.check = amd8111_pci_bridge_check,\n\t},\n\t{0},\n};\n\nstatic int amd8111_dev_probe(struct pci_dev *dev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\tstruct amd8111_dev_info *dev_info = &amd8111_devices[id->driver_data];\n\tint ret = -ENODEV;\n\n\tdev_info->dev = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\t\tdev_info->err_dev, NULL);\n\n\tif (!dev_info->dev) {\n\t\tprintk(KERN_ERR \"EDAC device not found:\"\n\t\t\t\"vendor %x, device %x, name %s\\n\",\n\t\t\tPCI_VENDOR_ID_AMD, dev_info->err_dev,\n\t\t\tdev_info->ctl_name);\n\t\tgoto err;\n\t}\n\n\tif (pci_enable_device(dev_info->dev)) {\n\t\tprintk(KERN_ERR \"failed to enable:\"\n\t\t\t\"vendor %x, device %x, name %s\\n\",\n\t\t\tPCI_VENDOR_ID_AMD, dev_info->err_dev,\n\t\t\tdev_info->ctl_name);\n\t\tgoto err_dev_put;\n\t}\n\n\t \n\tdev_info->edac_idx = edac_device_alloc_index();\n\tdev_info->edac_dev =\n\t\tedac_device_alloc_ctl_info(0, dev_info->ctl_name, 1,\n\t\t\t\t\t   NULL, 0, 0,\n\t\t\t\t\t   NULL, 0, dev_info->edac_idx);\n\tif (!dev_info->edac_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dev_put;\n\t}\n\n\tdev_info->edac_dev->pvt_info = dev_info;\n\tdev_info->edac_dev->dev = &dev_info->dev->dev;\n\tdev_info->edac_dev->mod_name = AMD8111_EDAC_MOD_STR;\n\tdev_info->edac_dev->ctl_name = dev_info->ctl_name;\n\tdev_info->edac_dev->dev_name = dev_name(&dev_info->dev->dev);\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tdev_info->edac_dev->edac_check = dev_info->check;\n\n\tif (dev_info->init)\n\t\tdev_info->init(dev_info);\n\n\tif (edac_device_add_device(dev_info->edac_dev) > 0) {\n\t\tprintk(KERN_ERR \"failed to add edac_dev for %s\\n\",\n\t\t\tdev_info->ctl_name);\n\t\tgoto err_edac_free_ctl;\n\t}\n\n\tprintk(KERN_INFO \"added one edac_dev on AMD8111 \"\n\t\t\"vendor %x, device %x, name %s\\n\",\n\t\tPCI_VENDOR_ID_AMD, dev_info->err_dev,\n\t\tdev_info->ctl_name);\n\n\treturn 0;\n\nerr_edac_free_ctl:\n\tedac_device_free_ctl_info(dev_info->edac_dev);\nerr_dev_put:\n\tpci_dev_put(dev_info->dev);\nerr:\n\treturn ret;\n}\n\nstatic void amd8111_dev_remove(struct pci_dev *dev)\n{\n\tstruct amd8111_dev_info *dev_info;\n\n\tfor (dev_info = amd8111_devices; dev_info->err_dev; dev_info++)\n\t\tif (dev_info->dev->device == dev->device)\n\t\t\tbreak;\n\n\tif (!dev_info->err_dev)\t \n\t\treturn;\n\n\tif (dev_info->edac_dev) {\n\t\tedac_device_del_device(dev_info->edac_dev->dev);\n\t\tedac_device_free_ctl_info(dev_info->edac_dev);\n\t}\n\n\tif (dev_info->exit)\n\t\tdev_info->exit(dev_info);\n\n\tpci_dev_put(dev_info->dev);\n}\n\nstatic int amd8111_pci_probe(struct pci_dev *dev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\tstruct amd8111_pci_info *pci_info = &amd8111_pcis[id->driver_data];\n\tint ret = -ENODEV;\n\n\tpci_info->dev = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\t\tpci_info->err_dev, NULL);\n\n\tif (!pci_info->dev) {\n\t\tprintk(KERN_ERR \"EDAC device not found:\"\n\t\t\t\"vendor %x, device %x, name %s\\n\",\n\t\t\tPCI_VENDOR_ID_AMD, pci_info->err_dev,\n\t\t\tpci_info->ctl_name);\n\t\tgoto err;\n\t}\n\n\tif (pci_enable_device(pci_info->dev)) {\n\t\tprintk(KERN_ERR \"failed to enable:\"\n\t\t\t\"vendor %x, device %x, name %s\\n\",\n\t\t\tPCI_VENDOR_ID_AMD, pci_info->err_dev,\n\t\t\tpci_info->ctl_name);\n\t\tgoto err_dev_put;\n\t}\n\n\t \n\tpci_info->edac_idx = edac_pci_alloc_index();\n\tpci_info->edac_dev = edac_pci_alloc_ctl_info(0, pci_info->ctl_name);\n\tif (!pci_info->edac_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dev_put;\n\t}\n\n\tpci_info->edac_dev->pvt_info = pci_info;\n\tpci_info->edac_dev->dev = &pci_info->dev->dev;\n\tpci_info->edac_dev->mod_name = AMD8111_EDAC_MOD_STR;\n\tpci_info->edac_dev->ctl_name = pci_info->ctl_name;\n\tpci_info->edac_dev->dev_name = dev_name(&pci_info->dev->dev);\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tpci_info->edac_dev->edac_check = pci_info->check;\n\n\tif (pci_info->init)\n\t\tpci_info->init(pci_info);\n\n\tif (edac_pci_add_device(pci_info->edac_dev, pci_info->edac_idx) > 0) {\n\t\tprintk(KERN_ERR \"failed to add edac_pci for %s\\n\",\n\t\t\tpci_info->ctl_name);\n\t\tgoto err_edac_free_ctl;\n\t}\n\n\tprintk(KERN_INFO \"added one edac_pci on AMD8111 \"\n\t\t\"vendor %x, device %x, name %s\\n\",\n\t\tPCI_VENDOR_ID_AMD, pci_info->err_dev,\n\t\tpci_info->ctl_name);\n\n\treturn 0;\n\nerr_edac_free_ctl:\n\tedac_pci_free_ctl_info(pci_info->edac_dev);\nerr_dev_put:\n\tpci_dev_put(pci_info->dev);\nerr:\n\treturn ret;\n}\n\nstatic void amd8111_pci_remove(struct pci_dev *dev)\n{\n\tstruct amd8111_pci_info *pci_info;\n\n\tfor (pci_info = amd8111_pcis; pci_info->err_dev; pci_info++)\n\t\tif (pci_info->dev->device == dev->device)\n\t\t\tbreak;\n\n\tif (!pci_info->err_dev)\t \n\t\treturn;\n\n\tif (pci_info->edac_dev) {\n\t\tedac_pci_del_device(pci_info->edac_dev->dev);\n\t\tedac_pci_free_ctl_info(pci_info->edac_dev);\n\t}\n\n\tif (pci_info->exit)\n\t\tpci_info->exit(pci_info);\n\n\tpci_dev_put(pci_info->dev);\n}\n\n \nstatic const struct pci_device_id amd8111_edac_dev_tbl[] = {\n\t{\n\tPCI_VEND_DEV(AMD, 8111_LPC),\n\t.subvendor = PCI_ANY_ID,\n\t.subdevice = PCI_ANY_ID,\n\t.class = 0,\n\t.class_mask = 0,\n\t.driver_data = LPC_BRIDGE,\n\t},\n\t{\n\t0,\n\t}\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, amd8111_edac_dev_tbl);\n\nstatic struct pci_driver amd8111_edac_dev_driver = {\n\t.name = \"AMD8111_EDAC_DEV\",\n\t.probe = amd8111_dev_probe,\n\t.remove = amd8111_dev_remove,\n\t.id_table = amd8111_edac_dev_tbl,\n};\n\n \nstatic const struct pci_device_id amd8111_edac_pci_tbl[] = {\n\t{\n\tPCI_VEND_DEV(AMD, 8111_PCI),\n\t.subvendor = PCI_ANY_ID,\n\t.subdevice = PCI_ANY_ID,\n\t.class = 0,\n\t.class_mask = 0,\n\t.driver_data = PCI_BRIDGE,\n\t},\n\t{\n\t0,\n\t}\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, amd8111_edac_pci_tbl);\n\nstatic struct pci_driver amd8111_edac_pci_driver = {\n\t.name = \"AMD8111_EDAC_PCI\",\n\t.probe = amd8111_pci_probe,\n\t.remove = amd8111_pci_remove,\n\t.id_table = amd8111_edac_pci_tbl,\n};\n\nstatic int __init amd8111_edac_init(void)\n{\n\tint val;\n\n\tprintk(KERN_INFO \"AMD8111 EDAC driver \"\tAMD8111_EDAC_REVISION \"\\n\");\n\tprintk(KERN_INFO \"\\t(c) 2008 Wind River Systems, Inc.\\n\");\n\n\t \n\tedac_op_state = EDAC_OPSTATE_POLL;\n\n\tval = pci_register_driver(&amd8111_edac_dev_driver);\n\tval |= pci_register_driver(&amd8111_edac_pci_driver);\n\n\treturn val;\n}\n\nstatic void __exit amd8111_edac_exit(void)\n{\n\tpci_unregister_driver(&amd8111_edac_pci_driver);\n\tpci_unregister_driver(&amd8111_edac_dev_driver);\n}\n\n\nmodule_init(amd8111_edac_init);\nmodule_exit(amd8111_edac_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cao Qingtao <qingtao.cao@windriver.com>\");\nMODULE_DESCRIPTION(\"AMD8111 HyperTransport I/O Hub EDAC kernel module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}