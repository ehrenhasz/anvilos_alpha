{
  "module_name": "amd76x_edac.c",
  "hash_id": "ac62d16aa11a757a82d33e93d1e1eae9d873732feb833043a2e9941a62e43ffb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/amd76x_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\"amd76x_edac\"\n\n#define amd76x_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"amd76x\", fmt, ##arg)\n\n#define amd76x_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"amd76x\", fmt, ##arg)\n\n#define AMD76X_NR_CSROWS 8\n#define AMD76X_NR_DIMMS  4\n\n \n\n#define AMD76X_ECC_MODE_STATUS\t0x48\t \n\n#define AMD76X_DRAM_MODE_STATUS\t0x58\t \n\n#define AMD76X_MEM_BASE_ADDR\t0xC0\t \n\nstruct amd76x_error_info {\n\tu32 ecc_mode_status;\n};\n\nenum amd76x_chips {\n\tAMD761 = 0,\n\tAMD762\n};\n\nstruct amd76x_dev_info {\n\tconst char *ctl_name;\n};\n\nstatic const struct amd76x_dev_info amd76x_devs[] = {\n\t[AMD761] = {\n\t\t.ctl_name = \"AMD761\"},\n\t[AMD762] = {\n\t\t.ctl_name = \"AMD762\"},\n};\n\nstatic struct edac_pci_ctl_info *amd76x_pci;\n\n \nstatic void amd76x_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct amd76x_error_info *info)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(mci->pdev);\n\tpci_read_config_dword(pdev, AMD76X_ECC_MODE_STATUS,\n\t\t\t&info->ecc_mode_status);\n\n\tif (info->ecc_mode_status & BIT(8))\n\t\tpci_write_bits32(pdev, AMD76X_ECC_MODE_STATUS,\n\t\t\t\t (u32) BIT(8), (u32) BIT(8));\n\n\tif (info->ecc_mode_status & BIT(9))\n\t\tpci_write_bits32(pdev, AMD76X_ECC_MODE_STATUS,\n\t\t\t\t (u32) BIT(9), (u32) BIT(9));\n}\n\n \nstatic int amd76x_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct amd76x_error_info *info,\n\t\t\t\tint handle_errors)\n{\n\tint error_found;\n\tu32 row;\n\n\terror_found = 0;\n\n\t \n\tif (info->ecc_mode_status & BIT(8)) {\n\t\terror_found = 1;\n\n\t\tif (handle_errors) {\n\t\t\trow = (info->ecc_mode_status >> 4) & 0xf;\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\t     mci->csrows[row]->first_page, 0, 0,\n\t\t\t\t\t     row, 0, -1,\n\t\t\t\t\t     mci->ctl_name, \"\");\n\t\t}\n\t}\n\n\t \n\tif (info->ecc_mode_status & BIT(9)) {\n\t\terror_found = 1;\n\n\t\tif (handle_errors) {\n\t\t\trow = info->ecc_mode_status & 0xf;\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t\t     mci->csrows[row]->first_page, 0, 0,\n\t\t\t\t\t     row, 0, -1,\n\t\t\t\t\t     mci->ctl_name, \"\");\n\t\t}\n\t}\n\n\treturn error_found;\n}\n\n \nstatic void amd76x_check(struct mem_ctl_info *mci)\n{\n\tstruct amd76x_error_info info;\n\tamd76x_get_error_info(mci, &info);\n\tamd76x_process_error_info(mci, &info, 1);\n}\n\nstatic void amd76x_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\n\t\t\tenum edac_type edac_mode)\n{\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\tu32 mba, mba_base, mba_mask, dms;\n\tint index;\n\n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\tcsrow = mci->csrows[index];\n\t\tdimm = csrow->channels[0]->dimm;\n\n\t\t \n\t\tpci_read_config_dword(pdev,\n\t\t\t\tAMD76X_MEM_BASE_ADDR + (index * 4), &mba);\n\n\t\tif (!(mba & BIT(0)))\n\t\t\tcontinue;\n\n\t\tmba_base = mba & 0xff800000UL;\n\t\tmba_mask = ((mba & 0xff80) << 16) | 0x7fffffUL;\n\t\tpci_read_config_dword(pdev, AMD76X_DRAM_MODE_STATUS, &dms);\n\t\tcsrow->first_page = mba_base >> PAGE_SHIFT;\n\t\tdimm->nr_pages = (mba_mask + 1) >> PAGE_SHIFT;\n\t\tcsrow->last_page = csrow->first_page + dimm->nr_pages - 1;\n\t\tcsrow->page_mask = mba_mask >> PAGE_SHIFT;\n\t\tdimm->grain = dimm->nr_pages << PAGE_SHIFT;\n\t\tdimm->mtype = MEM_RDDR;\n\t\tdimm->dtype = ((dms >> index) & 0x1) ? DEV_X4 : DEV_UNKNOWN;\n\t\tdimm->edac_mode = edac_mode;\n\t}\n}\n\n \nstatic int amd76x_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tstatic const enum edac_type ems_modes[] = {\n\t\tEDAC_NONE,\n\t\tEDAC_EC,\n\t\tEDAC_SECDED,\n\t\tEDAC_SECDED\n\t};\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tu32 ems;\n\tu32 ems_mode;\n\tstruct amd76x_error_info discard;\n\n\tedac_dbg(0, \"\\n\");\n\tpci_read_config_dword(pdev, AMD76X_ECC_MODE_STATUS, &ems);\n\tems_mode = (ems >> 10) & 0x3;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = AMD76X_NR_CSROWS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = 1;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\n\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(0, \"mci = %p\\n\", mci);\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_RDDR;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\n\tmci->edac_cap = ems_mode ?\n\t\t(EDAC_FLAG_EC | EDAC_FLAG_SECDED) : EDAC_FLAG_NONE;\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = amd76x_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = amd76x_check;\n\tmci->ctl_page_to_phys = NULL;\n\n\tamd76x_init_csrows(mci, pdev, ems_modes[ems_mode]);\n\tamd76x_get_error_info(mci, &discard);\t \n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"failed edac_mc_add_mc()\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tamd76x_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!amd76x_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\t \n\tedac_dbg(3, \"success\\n\");\n\treturn 0;\n\nfail:\n\tedac_mc_free(mci);\n\treturn -ENODEV;\n}\n\n \nstatic int amd76x_init_one(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t \n\treturn amd76x_probe1(pdev, ent->driver_data);\n}\n\n \nstatic void amd76x_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (amd76x_pci)\n\t\tedac_pci_release_generic_ctl(amd76x_pci);\n\n\tif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\n\t\treturn;\n\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id amd76x_pci_tbl[] = {\n\t{\n\t PCI_VEND_DEV(AMD, FE_GATE_700C), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t AMD762},\n\t{\n\t PCI_VEND_DEV(AMD, FE_GATE_700E), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t AMD761},\n\t{\n\t 0,\n\t }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, amd76x_pci_tbl);\n\nstatic struct pci_driver amd76x_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = amd76x_init_one,\n\t.remove = amd76x_remove_one,\n\t.id_table = amd76x_pci_tbl,\n};\n\nstatic int __init amd76x_init(void)\n{\n        \n       opstate_init();\n\n\treturn pci_register_driver(&amd76x_driver);\n}\n\nstatic void __exit amd76x_exit(void)\n{\n\tpci_unregister_driver(&amd76x_driver);\n}\n\nmodule_init(amd76x_init);\nmodule_exit(amd76x_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Linux Networx (http://lnxi.com) Thayne Harbaugh\");\nMODULE_DESCRIPTION(\"MC support for AMD 76x memory controllers\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}