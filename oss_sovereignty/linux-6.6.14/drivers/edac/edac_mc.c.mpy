{
  "module_name": "edac_mc.c",
  "hash_id": "b74351669d3b080fc72e3d1d4a6ddfe24cc7fa86e614ce22aa48ac22e5e44ddf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_mc.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/smp.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/edac.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <asm/page.h>\n#include \"edac_mc.h\"\n#include \"edac_module.h\"\n#include <ras/ras_event.h>\n\n#ifdef CONFIG_EDAC_ATOMIC_SCRUB\n#include <asm/edac.h>\n#else\n#define edac_atomic_scrub(va, size) do { } while (0)\n#endif\n\nint edac_op_state = EDAC_OPSTATE_INVAL;\nEXPORT_SYMBOL_GPL(edac_op_state);\n\n \nstatic DEFINE_MUTEX(mem_ctls_mutex);\nstatic LIST_HEAD(mc_devices);\n\n \nstatic const char *edac_mc_owner;\n\nstatic struct mem_ctl_info *error_desc_to_mci(struct edac_raw_error_desc *e)\n{\n\treturn container_of(e, struct mem_ctl_info, error_desc);\n}\n\nunsigned int edac_dimm_info_location(struct dimm_info *dimm, char *buf,\n\t\t\t\t     unsigned int len)\n{\n\tstruct mem_ctl_info *mci = dimm->mci;\n\tint i, n, count = 0;\n\tchar *p = buf;\n\n\tfor (i = 0; i < mci->n_layers; i++) {\n\t\tn = scnprintf(p, len, \"%s %d \",\n\t\t\t      edac_layer_name[mci->layers[i].type],\n\t\t\t      dimm->location[i]);\n\t\tp += n;\n\t\tlen -= n;\n\t\tcount += n;\n\t}\n\n\treturn count;\n}\n\n#ifdef CONFIG_EDAC_DEBUG\n\nstatic void edac_mc_dump_channel(struct rank_info *chan)\n{\n\tedac_dbg(4, \"  channel->chan_idx = %d\\n\", chan->chan_idx);\n\tedac_dbg(4, \"    channel = %p\\n\", chan);\n\tedac_dbg(4, \"    channel->csrow = %p\\n\", chan->csrow);\n\tedac_dbg(4, \"    channel->dimm = %p\\n\", chan->dimm);\n}\n\nstatic void edac_mc_dump_dimm(struct dimm_info *dimm)\n{\n\tchar location[80];\n\n\tif (!dimm->nr_pages)\n\t\treturn;\n\n\tedac_dimm_info_location(dimm, location, sizeof(location));\n\n\tedac_dbg(4, \"%s%i: %smapped as virtual row %d, chan %d\\n\",\n\t\t dimm->mci->csbased ? \"rank\" : \"dimm\",\n\t\t dimm->idx, location, dimm->csrow, dimm->cschannel);\n\tedac_dbg(4, \"  dimm = %p\\n\", dimm);\n\tedac_dbg(4, \"  dimm->label = '%s'\\n\", dimm->label);\n\tedac_dbg(4, \"  dimm->nr_pages = 0x%x\\n\", dimm->nr_pages);\n\tedac_dbg(4, \"  dimm->grain = %d\\n\", dimm->grain);\n}\n\nstatic void edac_mc_dump_csrow(struct csrow_info *csrow)\n{\n\tedac_dbg(4, \"csrow->csrow_idx = %d\\n\", csrow->csrow_idx);\n\tedac_dbg(4, \"  csrow = %p\\n\", csrow);\n\tedac_dbg(4, \"  csrow->first_page = 0x%lx\\n\", csrow->first_page);\n\tedac_dbg(4, \"  csrow->last_page = 0x%lx\\n\", csrow->last_page);\n\tedac_dbg(4, \"  csrow->page_mask = 0x%lx\\n\", csrow->page_mask);\n\tedac_dbg(4, \"  csrow->nr_channels = %d\\n\", csrow->nr_channels);\n\tedac_dbg(4, \"  csrow->channels = %p\\n\", csrow->channels);\n\tedac_dbg(4, \"  csrow->mci = %p\\n\", csrow->mci);\n}\n\nstatic void edac_mc_dump_mci(struct mem_ctl_info *mci)\n{\n\tedac_dbg(3, \"\\tmci = %p\\n\", mci);\n\tedac_dbg(3, \"\\tmci->mtype_cap = %lx\\n\", mci->mtype_cap);\n\tedac_dbg(3, \"\\tmci->edac_ctl_cap = %lx\\n\", mci->edac_ctl_cap);\n\tedac_dbg(3, \"\\tmci->edac_cap = %lx\\n\", mci->edac_cap);\n\tedac_dbg(4, \"\\tmci->edac_check = %p\\n\", mci->edac_check);\n\tedac_dbg(3, \"\\tmci->nr_csrows = %d, csrows = %p\\n\",\n\t\t mci->nr_csrows, mci->csrows);\n\tedac_dbg(3, \"\\tmci->nr_dimms = %d, dimms = %p\\n\",\n\t\t mci->tot_dimms, mci->dimms);\n\tedac_dbg(3, \"\\tdev = %p\\n\", mci->pdev);\n\tedac_dbg(3, \"\\tmod_name:ctl_name = %s:%s\\n\",\n\t\t mci->mod_name, mci->ctl_name);\n\tedac_dbg(3, \"\\tpvt_info = %p\\n\\n\", mci->pvt_info);\n}\n\n#endif\t\t\t\t \n\nconst char * const edac_mem_types[] = {\n\t[MEM_EMPTY]\t= \"Empty\",\n\t[MEM_RESERVED]\t= \"Reserved\",\n\t[MEM_UNKNOWN]\t= \"Unknown\",\n\t[MEM_FPM]\t= \"FPM\",\n\t[MEM_EDO]\t= \"EDO\",\n\t[MEM_BEDO]\t= \"BEDO\",\n\t[MEM_SDR]\t= \"Unbuffered-SDR\",\n\t[MEM_RDR]\t= \"Registered-SDR\",\n\t[MEM_DDR]\t= \"Unbuffered-DDR\",\n\t[MEM_RDDR]\t= \"Registered-DDR\",\n\t[MEM_RMBS]\t= \"RMBS\",\n\t[MEM_DDR2]\t= \"Unbuffered-DDR2\",\n\t[MEM_FB_DDR2]\t= \"FullyBuffered-DDR2\",\n\t[MEM_RDDR2]\t= \"Registered-DDR2\",\n\t[MEM_XDR]\t= \"XDR\",\n\t[MEM_DDR3]\t= \"Unbuffered-DDR3\",\n\t[MEM_RDDR3]\t= \"Registered-DDR3\",\n\t[MEM_LRDDR3]\t= \"Load-Reduced-DDR3-RAM\",\n\t[MEM_LPDDR3]\t= \"Low-Power-DDR3-RAM\",\n\t[MEM_DDR4]\t= \"Unbuffered-DDR4\",\n\t[MEM_RDDR4]\t= \"Registered-DDR4\",\n\t[MEM_LPDDR4]\t= \"Low-Power-DDR4-RAM\",\n\t[MEM_LRDDR4]\t= \"Load-Reduced-DDR4-RAM\",\n\t[MEM_DDR5]\t= \"Unbuffered-DDR5\",\n\t[MEM_RDDR5]\t= \"Registered-DDR5\",\n\t[MEM_LRDDR5]\t= \"Load-Reduced-DDR5-RAM\",\n\t[MEM_NVDIMM]\t= \"Non-volatile-RAM\",\n\t[MEM_WIO2]\t= \"Wide-IO-2\",\n\t[MEM_HBM2]\t= \"High-bandwidth-memory-Gen2\",\n};\nEXPORT_SYMBOL_GPL(edac_mem_types);\n\nstatic void _edac_mc_free(struct mem_ctl_info *mci)\n{\n\tput_device(&mci->dev);\n}\n\nstatic void mci_release(struct device *dev)\n{\n\tstruct mem_ctl_info *mci = container_of(dev, struct mem_ctl_info, dev);\n\tstruct csrow_info *csr;\n\tint i, chn, row;\n\n\tif (mci->dimms) {\n\t\tfor (i = 0; i < mci->tot_dimms; i++)\n\t\t\tkfree(mci->dimms[i]);\n\t\tkfree(mci->dimms);\n\t}\n\n\tif (mci->csrows) {\n\t\tfor (row = 0; row < mci->nr_csrows; row++) {\n\t\t\tcsr = mci->csrows[row];\n\t\t\tif (!csr)\n\t\t\t\tcontinue;\n\n\t\t\tif (csr->channels) {\n\t\t\t\tfor (chn = 0; chn < mci->num_cschannel; chn++)\n\t\t\t\t\tkfree(csr->channels[chn]);\n\t\t\t\tkfree(csr->channels);\n\t\t\t}\n\t\t\tkfree(csr);\n\t\t}\n\t\tkfree(mci->csrows);\n\t}\n\tkfree(mci->pvt_info);\n\tkfree(mci->layers);\n\tkfree(mci);\n}\n\nstatic int edac_mc_alloc_csrows(struct mem_ctl_info *mci)\n{\n\tunsigned int tot_channels = mci->num_cschannel;\n\tunsigned int tot_csrows = mci->nr_csrows;\n\tunsigned int row, chn;\n\n\t \n\tmci->csrows = kcalloc(tot_csrows, sizeof(*mci->csrows), GFP_KERNEL);\n\tif (!mci->csrows)\n\t\treturn -ENOMEM;\n\n\tfor (row = 0; row < tot_csrows; row++) {\n\t\tstruct csrow_info *csr;\n\n\t\tcsr = kzalloc(sizeof(**mci->csrows), GFP_KERNEL);\n\t\tif (!csr)\n\t\t\treturn -ENOMEM;\n\n\t\tmci->csrows[row] = csr;\n\t\tcsr->csrow_idx = row;\n\t\tcsr->mci = mci;\n\t\tcsr->nr_channels = tot_channels;\n\t\tcsr->channels = kcalloc(tot_channels, sizeof(*csr->channels),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!csr->channels)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (chn = 0; chn < tot_channels; chn++) {\n\t\t\tstruct rank_info *chan;\n\n\t\t\tchan = kzalloc(sizeof(**csr->channels), GFP_KERNEL);\n\t\t\tif (!chan)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tcsr->channels[chn] = chan;\n\t\t\tchan->chan_idx = chn;\n\t\t\tchan->csrow = csr;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int edac_mc_alloc_dimms(struct mem_ctl_info *mci)\n{\n\tunsigned int pos[EDAC_MAX_LAYERS];\n\tunsigned int row, chn, idx;\n\tint layer;\n\tvoid *p;\n\n\t \n\tmci->dimms  = kcalloc(mci->tot_dimms, sizeof(*mci->dimms), GFP_KERNEL);\n\tif (!mci->dimms)\n\t\treturn -ENOMEM;\n\n\tmemset(&pos, 0, sizeof(pos));\n\trow = 0;\n\tchn = 0;\n\tfor (idx = 0; idx < mci->tot_dimms; idx++) {\n\t\tstruct dimm_info *dimm;\n\t\tstruct rank_info *chan;\n\t\tint n, len;\n\n\t\tchan = mci->csrows[row]->channels[chn];\n\n\t\tdimm = kzalloc(sizeof(**mci->dimms), GFP_KERNEL);\n\t\tif (!dimm)\n\t\t\treturn -ENOMEM;\n\t\tmci->dimms[idx] = dimm;\n\t\tdimm->mci = mci;\n\t\tdimm->idx = idx;\n\n\t\t \n\t\tlen = sizeof(dimm->label);\n\t\tp = dimm->label;\n\t\tn = scnprintf(p, len, \"mc#%u\", mci->mc_idx);\n\t\tp += n;\n\t\tlen -= n;\n\t\tfor (layer = 0; layer < mci->n_layers; layer++) {\n\t\t\tn = scnprintf(p, len, \"%s#%u\",\n\t\t\t\t      edac_layer_name[mci->layers[layer].type],\n\t\t\t\t      pos[layer]);\n\t\t\tp += n;\n\t\t\tlen -= n;\n\t\t\tdimm->location[layer] = pos[layer];\n\t\t}\n\n\t\t \n\t\tchan->dimm = dimm;\n\t\tdimm->csrow = row;\n\t\tdimm->cschannel = chn;\n\n\t\t \n\t\tif (mci->layers[0].is_virt_csrow) {\n\t\t\tchn++;\n\t\t\tif (chn == mci->num_cschannel) {\n\t\t\t\tchn = 0;\n\t\t\t\trow++;\n\t\t\t}\n\t\t} else {\n\t\t\trow++;\n\t\t\tif (row == mci->nr_csrows) {\n\t\t\t\trow = 0;\n\t\t\t\tchn++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (layer = mci->n_layers - 1; layer >= 0; layer--) {\n\t\t\tpos[layer]++;\n\t\t\tif (pos[layer] < mci->layers[layer].size)\n\t\t\t\tbreak;\n\t\t\tpos[layer] = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct mem_ctl_info *edac_mc_alloc(unsigned int mc_num,\n\t\t\t\t   unsigned int n_layers,\n\t\t\t\t   struct edac_mc_layer *layers,\n\t\t\t\t   unsigned int sz_pvt)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer *layer;\n\tunsigned int idx, tot_dimms = 1;\n\tunsigned int tot_csrows = 1, tot_channels = 1;\n\tbool per_rank = false;\n\n\tif (WARN_ON(n_layers > EDAC_MAX_LAYERS || n_layers == 0))\n\t\treturn NULL;\n\n\t \n\tfor (idx = 0; idx < n_layers; idx++) {\n\t\ttot_dimms *= layers[idx].size;\n\n\t\tif (layers[idx].is_virt_csrow)\n\t\t\ttot_csrows *= layers[idx].size;\n\t\telse\n\t\t\ttot_channels *= layers[idx].size;\n\n\t\tif (layers[idx].type == EDAC_MC_LAYER_CHIP_SELECT)\n\t\t\tper_rank = true;\n\t}\n\n\tmci = kzalloc(sizeof(struct mem_ctl_info), GFP_KERNEL);\n\tif (!mci)\n\t\treturn NULL;\n\n\tmci->layers = kcalloc(n_layers, sizeof(struct edac_mc_layer), GFP_KERNEL);\n\tif (!mci->layers)\n\t\tgoto error;\n\n\tmci->pvt_info = kzalloc(sz_pvt, GFP_KERNEL);\n\tif (!mci->pvt_info)\n\t\tgoto error;\n\n\tmci->dev.release = mci_release;\n\tdevice_initialize(&mci->dev);\n\n\t \n\tmci->mc_idx = mc_num;\n\tmci->tot_dimms = tot_dimms;\n\tmci->n_layers = n_layers;\n\tmemcpy(mci->layers, layers, sizeof(*layer) * n_layers);\n\tmci->nr_csrows = tot_csrows;\n\tmci->num_cschannel = tot_channels;\n\tmci->csbased = per_rank;\n\n\tif (edac_mc_alloc_csrows(mci))\n\t\tgoto error;\n\n\tif (edac_mc_alloc_dimms(mci))\n\t\tgoto error;\n\n\tmci->op_state = OP_ALLOC;\n\n\treturn mci;\n\nerror:\n\t_edac_mc_free(mci);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(edac_mc_alloc);\n\nvoid edac_mc_free(struct mem_ctl_info *mci)\n{\n\tedac_dbg(1, \"\\n\");\n\n\t_edac_mc_free(mci);\n}\nEXPORT_SYMBOL_GPL(edac_mc_free);\n\nbool edac_has_mcs(void)\n{\n\tbool ret;\n\n\tmutex_lock(&mem_ctls_mutex);\n\n\tret = list_empty(&mc_devices);\n\n\tmutex_unlock(&mem_ctls_mutex);\n\n\treturn !ret;\n}\nEXPORT_SYMBOL_GPL(edac_has_mcs);\n\n \nstatic struct mem_ctl_info *__find_mci_by_dev(struct device *dev)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct list_head *item;\n\n\tedac_dbg(3, \"\\n\");\n\n\tlist_for_each(item, &mc_devices) {\n\t\tmci = list_entry(item, struct mem_ctl_info, link);\n\n\t\tif (mci->pdev == dev)\n\t\t\treturn mci;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct mem_ctl_info *find_mci_by_dev(struct device *dev)\n{\n\tstruct mem_ctl_info *ret;\n\n\tmutex_lock(&mem_ctls_mutex);\n\tret = __find_mci_by_dev(dev);\n\tmutex_unlock(&mem_ctls_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(find_mci_by_dev);\n\n \nstatic void edac_mc_workq_function(struct work_struct *work_req)\n{\n\tstruct delayed_work *d_work = to_delayed_work(work_req);\n\tstruct mem_ctl_info *mci = to_edac_mem_ctl_work(d_work);\n\n\tmutex_lock(&mem_ctls_mutex);\n\n\tif (mci->op_state != OP_RUNNING_POLL) {\n\t\tmutex_unlock(&mem_ctls_mutex);\n\t\treturn;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tmci->edac_check(mci);\n\n\tmutex_unlock(&mem_ctls_mutex);\n\n\t \n\tedac_queue_work(&mci->work, msecs_to_jiffies(edac_mc_get_poll_msec()));\n}\n\n \nvoid edac_mc_reset_delay_period(unsigned long value)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct list_head *item;\n\n\tmutex_lock(&mem_ctls_mutex);\n\n\tlist_for_each(item, &mc_devices) {\n\t\tmci = list_entry(item, struct mem_ctl_info, link);\n\n\t\tif (mci->op_state == OP_RUNNING_POLL)\n\t\t\tedac_mod_work(&mci->work, value);\n\t}\n\tmutex_unlock(&mem_ctls_mutex);\n}\n\n\n\n \nstatic int add_mc_to_global_list(struct mem_ctl_info *mci)\n{\n\tstruct list_head *item, *insert_before;\n\tstruct mem_ctl_info *p;\n\n\tinsert_before = &mc_devices;\n\n\tp = __find_mci_by_dev(mci->pdev);\n\tif (unlikely(p != NULL))\n\t\tgoto fail0;\n\n\tlist_for_each(item, &mc_devices) {\n\t\tp = list_entry(item, struct mem_ctl_info, link);\n\n\t\tif (p->mc_idx >= mci->mc_idx) {\n\t\t\tif (unlikely(p->mc_idx == mci->mc_idx))\n\t\t\t\tgoto fail1;\n\n\t\t\tinsert_before = item;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_add_tail_rcu(&mci->link, insert_before);\n\treturn 0;\n\nfail0:\n\tedac_printk(KERN_WARNING, EDAC_MC,\n\t\t\"%s (%s) %s %s already assigned %d\\n\", dev_name(p->pdev),\n\t\tedac_dev_name(mci), p->mod_name, p->ctl_name, p->mc_idx);\n\treturn 1;\n\nfail1:\n\tedac_printk(KERN_WARNING, EDAC_MC,\n\t\t\"bug in low-level driver: attempt to assign\\n\"\n\t\t\"    duplicate mc_idx %d in %s()\\n\", p->mc_idx, __func__);\n\treturn 1;\n}\n\nstatic int del_mc_from_global_list(struct mem_ctl_info *mci)\n{\n\tlist_del_rcu(&mci->link);\n\n\t \n\tsynchronize_rcu();\n\tINIT_LIST_HEAD(&mci->link);\n\n\treturn list_empty(&mc_devices);\n}\n\nstruct mem_ctl_info *edac_mc_find(int idx)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct list_head *item;\n\n\tmutex_lock(&mem_ctls_mutex);\n\n\tlist_for_each(item, &mc_devices) {\n\t\tmci = list_entry(item, struct mem_ctl_info, link);\n\t\tif (mci->mc_idx == idx)\n\t\t\tgoto unlock;\n\t}\n\n\tmci = NULL;\nunlock:\n\tmutex_unlock(&mem_ctls_mutex);\n\treturn mci;\n}\nEXPORT_SYMBOL(edac_mc_find);\n\nconst char *edac_get_owner(void)\n{\n\treturn edac_mc_owner;\n}\nEXPORT_SYMBOL_GPL(edac_get_owner);\n\n \nint edac_mc_add_mc_with_groups(struct mem_ctl_info *mci,\n\t\t\t       const struct attribute_group **groups)\n{\n\tint ret = -EINVAL;\n\tedac_dbg(0, \"\\n\");\n\n#ifdef CONFIG_EDAC_DEBUG\n\tif (edac_debug_level >= 3)\n\t\tedac_mc_dump_mci(mci);\n\n\tif (edac_debug_level >= 4) {\n\t\tstruct dimm_info *dimm;\n\t\tint i;\n\n\t\tfor (i = 0; i < mci->nr_csrows; i++) {\n\t\t\tstruct csrow_info *csrow = mci->csrows[i];\n\t\t\tu32 nr_pages = 0;\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < csrow->nr_channels; j++)\n\t\t\t\tnr_pages += csrow->channels[j]->dimm->nr_pages;\n\t\t\tif (!nr_pages)\n\t\t\t\tcontinue;\n\t\t\tedac_mc_dump_csrow(csrow);\n\t\t\tfor (j = 0; j < csrow->nr_channels; j++)\n\t\t\t\tif (csrow->channels[j]->dimm->nr_pages)\n\t\t\t\t\tedac_mc_dump_channel(csrow->channels[j]);\n\t\t}\n\n\t\tmci_for_each_dimm(mci, dimm)\n\t\t\tedac_mc_dump_dimm(dimm);\n\t}\n#endif\n\tmutex_lock(&mem_ctls_mutex);\n\n\tif (edac_mc_owner && edac_mc_owner != mci->mod_name) {\n\t\tret = -EPERM;\n\t\tgoto fail0;\n\t}\n\n\tif (add_mc_to_global_list(mci))\n\t\tgoto fail0;\n\n\t \n\tmci->start_time = jiffies;\n\n\tmci->bus = edac_get_sysfs_subsys();\n\n\tif (edac_create_sysfs_mci_device(mci, groups)) {\n\t\tedac_mc_printk(mci, KERN_WARNING,\n\t\t\t\"failed to create sysfs device\\n\");\n\t\tgoto fail1;\n\t}\n\n\tif (mci->edac_check) {\n\t\tmci->op_state = OP_RUNNING_POLL;\n\n\t\tINIT_DELAYED_WORK(&mci->work, edac_mc_workq_function);\n\t\tedac_queue_work(&mci->work, msecs_to_jiffies(edac_mc_get_poll_msec()));\n\n\t} else {\n\t\tmci->op_state = OP_RUNNING_INTERRUPT;\n\t}\n\n\t \n\tedac_mc_printk(mci, KERN_INFO,\n\t\t\"Giving out device to module %s controller %s: DEV %s (%s)\\n\",\n\t\tmci->mod_name, mci->ctl_name, mci->dev_name,\n\t\tedac_op_state_to_string(mci->op_state));\n\n\tedac_mc_owner = mci->mod_name;\n\n\tmutex_unlock(&mem_ctls_mutex);\n\treturn 0;\n\nfail1:\n\tdel_mc_from_global_list(mci);\n\nfail0:\n\tmutex_unlock(&mem_ctls_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(edac_mc_add_mc_with_groups);\n\nstruct mem_ctl_info *edac_mc_del_mc(struct device *dev)\n{\n\tstruct mem_ctl_info *mci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tmutex_lock(&mem_ctls_mutex);\n\n\t \n\tmci = __find_mci_by_dev(dev);\n\tif (mci == NULL) {\n\t\tmutex_unlock(&mem_ctls_mutex);\n\t\treturn NULL;\n\t}\n\n\t \n\tmci->op_state = OP_OFFLINE;\n\n\tif (del_mc_from_global_list(mci))\n\t\tedac_mc_owner = NULL;\n\n\tmutex_unlock(&mem_ctls_mutex);\n\n\tif (mci->edac_check)\n\t\tedac_stop_work(&mci->work);\n\n\t \n\tedac_remove_sysfs_mci_device(mci);\n\n\tedac_printk(KERN_INFO, EDAC_MC,\n\t\t\"Removed device %d for %s %s: DEV %s\\n\", mci->mc_idx,\n\t\tmci->mod_name, mci->ctl_name, edac_dev_name(mci));\n\n\treturn mci;\n}\nEXPORT_SYMBOL_GPL(edac_mc_del_mc);\n\nstatic void edac_mc_scrub_block(unsigned long page, unsigned long offset,\n\t\t\t\tu32 size)\n{\n\tstruct page *pg;\n\tvoid *virt_addr;\n\tunsigned long flags = 0;\n\n\tedac_dbg(3, \"\\n\");\n\n\t \n\tif (!pfn_valid(page))\n\t\treturn;\n\n\t \n\tpg = pfn_to_page(page);\n\n\tif (PageHighMem(pg))\n\t\tlocal_irq_save(flags);\n\n\tvirt_addr = kmap_atomic(pg);\n\n\t \n\tedac_atomic_scrub(virt_addr + offset, size);\n\n\t \n\tkunmap_atomic(virt_addr);\n\n\tif (PageHighMem(pg))\n\t\tlocal_irq_restore(flags);\n}\n\n \nint edac_mc_find_csrow_by_page(struct mem_ctl_info *mci, unsigned long page)\n{\n\tstruct csrow_info **csrows = mci->csrows;\n\tint row, i, j, n;\n\n\tedac_dbg(1, \"MC%d: 0x%lx\\n\", mci->mc_idx, page);\n\trow = -1;\n\n\tfor (i = 0; i < mci->nr_csrows; i++) {\n\t\tstruct csrow_info *csrow = csrows[i];\n\t\tn = 0;\n\t\tfor (j = 0; j < csrow->nr_channels; j++) {\n\t\t\tstruct dimm_info *dimm = csrow->channels[j]->dimm;\n\t\t\tn += dimm->nr_pages;\n\t\t}\n\t\tif (n == 0)\n\t\t\tcontinue;\n\n\t\tedac_dbg(3, \"MC%d: first(0x%lx) page(0x%lx) last(0x%lx) mask(0x%lx)\\n\",\n\t\t\t mci->mc_idx,\n\t\t\t csrow->first_page, page, csrow->last_page,\n\t\t\t csrow->page_mask);\n\n\t\tif ((page >= csrow->first_page) &&\n\t\t    (page <= csrow->last_page) &&\n\t\t    ((page & csrow->page_mask) ==\n\t\t     (csrow->first_page & csrow->page_mask))) {\n\t\t\trow = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (row == -1)\n\t\tedac_mc_printk(mci, KERN_ERR,\n\t\t\t\"could not look up page error address %lx\\n\",\n\t\t\t(unsigned long)page);\n\n\treturn row;\n}\nEXPORT_SYMBOL_GPL(edac_mc_find_csrow_by_page);\n\nconst char *edac_layer_name[] = {\n\t[EDAC_MC_LAYER_BRANCH] = \"branch\",\n\t[EDAC_MC_LAYER_CHANNEL] = \"channel\",\n\t[EDAC_MC_LAYER_SLOT] = \"slot\",\n\t[EDAC_MC_LAYER_CHIP_SELECT] = \"csrow\",\n\t[EDAC_MC_LAYER_ALL_MEM] = \"memory\",\n};\nEXPORT_SYMBOL_GPL(edac_layer_name);\n\nstatic void edac_inc_ce_error(struct edac_raw_error_desc *e)\n{\n\tint pos[EDAC_MAX_LAYERS] = { e->top_layer, e->mid_layer, e->low_layer };\n\tstruct mem_ctl_info *mci = error_desc_to_mci(e);\n\tstruct dimm_info *dimm = edac_get_dimm(mci, pos[0], pos[1], pos[2]);\n\n\tmci->ce_mc += e->error_count;\n\n\tif (dimm)\n\t\tdimm->ce_count += e->error_count;\n\telse\n\t\tmci->ce_noinfo_count += e->error_count;\n}\n\nstatic void edac_inc_ue_error(struct edac_raw_error_desc *e)\n{\n\tint pos[EDAC_MAX_LAYERS] = { e->top_layer, e->mid_layer, e->low_layer };\n\tstruct mem_ctl_info *mci = error_desc_to_mci(e);\n\tstruct dimm_info *dimm = edac_get_dimm(mci, pos[0], pos[1], pos[2]);\n\n\tmci->ue_mc += e->error_count;\n\n\tif (dimm)\n\t\tdimm->ue_count += e->error_count;\n\telse\n\t\tmci->ue_noinfo_count += e->error_count;\n}\n\nstatic void edac_ce_error(struct edac_raw_error_desc *e)\n{\n\tstruct mem_ctl_info *mci = error_desc_to_mci(e);\n\tunsigned long remapped_page;\n\n\tif (edac_mc_get_log_ce()) {\n\t\tedac_mc_printk(mci, KERN_WARNING,\n\t\t\t\"%d CE %s%son %s (%s page:0x%lx offset:0x%lx grain:%ld syndrome:0x%lx%s%s)\\n\",\n\t\t\te->error_count, e->msg,\n\t\t\t*e->msg ? \" \" : \"\",\n\t\t\te->label, e->location, e->page_frame_number, e->offset_in_page,\n\t\t\te->grain, e->syndrome,\n\t\t\t*e->other_detail ? \" - \" : \"\",\n\t\t\te->other_detail);\n\t}\n\n\tedac_inc_ce_error(e);\n\n\tif (mci->scrub_mode == SCRUB_SW_SRC) {\n\t\t \n\t\tremapped_page = mci->ctl_page_to_phys ?\n\t\t\tmci->ctl_page_to_phys(mci, e->page_frame_number) :\n\t\t\te->page_frame_number;\n\n\t\tedac_mc_scrub_block(remapped_page, e->offset_in_page, e->grain);\n\t}\n}\n\nstatic void edac_ue_error(struct edac_raw_error_desc *e)\n{\n\tstruct mem_ctl_info *mci = error_desc_to_mci(e);\n\n\tif (edac_mc_get_log_ue()) {\n\t\tedac_mc_printk(mci, KERN_WARNING,\n\t\t\t\"%d UE %s%son %s (%s page:0x%lx offset:0x%lx grain:%ld%s%s)\\n\",\n\t\t\te->error_count, e->msg,\n\t\t\t*e->msg ? \" \" : \"\",\n\t\t\te->label, e->location, e->page_frame_number, e->offset_in_page,\n\t\t\te->grain,\n\t\t\t*e->other_detail ? \" - \" : \"\",\n\t\t\te->other_detail);\n\t}\n\n\tedac_inc_ue_error(e);\n\n\tif (edac_mc_get_panic_on_ue()) {\n\t\tpanic(\"UE %s%son %s (%s page:0x%lx offset:0x%lx grain:%ld%s%s)\\n\",\n\t\t\te->msg,\n\t\t\t*e->msg ? \" \" : \"\",\n\t\t\te->label, e->location, e->page_frame_number, e->offset_in_page,\n\t\t\te->grain,\n\t\t\t*e->other_detail ? \" - \" : \"\",\n\t\t\te->other_detail);\n\t}\n}\n\nstatic void edac_inc_csrow(struct edac_raw_error_desc *e, int row, int chan)\n{\n\tstruct mem_ctl_info *mci = error_desc_to_mci(e);\n\tenum hw_event_mc_err_type type = e->type;\n\tu16 count = e->error_count;\n\n\tif (row < 0)\n\t\treturn;\n\n\tedac_dbg(4, \"csrow/channel to increment: (%d,%d)\\n\", row, chan);\n\n\tif (type == HW_EVENT_ERR_CORRECTED) {\n\t\tmci->csrows[row]->ce_count += count;\n\t\tif (chan >= 0)\n\t\t\tmci->csrows[row]->channels[chan]->ce_count += count;\n\t} else {\n\t\tmci->csrows[row]->ue_count += count;\n\t}\n}\n\nvoid edac_raw_mc_handle_error(struct edac_raw_error_desc *e)\n{\n\tstruct mem_ctl_info *mci = error_desc_to_mci(e);\n\tu8 grain_bits;\n\n\t \n\tif (WARN_ON_ONCE(!e->grain))\n\t\te->grain = 1;\n\n\tgrain_bits = fls_long(e->grain - 1);\n\n\t \n\tif (IS_ENABLED(CONFIG_RAS))\n\t\ttrace_mc_event(e->type, e->msg, e->label, e->error_count,\n\t\t\t       mci->mc_idx, e->top_layer, e->mid_layer,\n\t\t\t       e->low_layer,\n\t\t\t       (e->page_frame_number << PAGE_SHIFT) | e->offset_in_page,\n\t\t\t       grain_bits, e->syndrome, e->other_detail);\n\n\tif (e->type == HW_EVENT_ERR_CORRECTED)\n\t\tedac_ce_error(e);\n\telse\n\t\tedac_ue_error(e);\n}\nEXPORT_SYMBOL_GPL(edac_raw_mc_handle_error);\n\nvoid edac_mc_handle_error(const enum hw_event_mc_err_type type,\n\t\t\t  struct mem_ctl_info *mci,\n\t\t\t  const u16 error_count,\n\t\t\t  const unsigned long page_frame_number,\n\t\t\t  const unsigned long offset_in_page,\n\t\t\t  const unsigned long syndrome,\n\t\t\t  const int top_layer,\n\t\t\t  const int mid_layer,\n\t\t\t  const int low_layer,\n\t\t\t  const char *msg,\n\t\t\t  const char *other_detail)\n{\n\tstruct dimm_info *dimm;\n\tchar *p, *end;\n\tint row = -1, chan = -1;\n\tint pos[EDAC_MAX_LAYERS] = { top_layer, mid_layer, low_layer };\n\tint i, n_labels = 0;\n\tstruct edac_raw_error_desc *e = &mci->error_desc;\n\tbool any_memory = true;\n\tconst char *prefix;\n\n\tedac_dbg(3, \"MC%d\\n\", mci->mc_idx);\n\n\t \n\tmemset(e, 0, sizeof (*e));\n\te->error_count = error_count;\n\te->type = type;\n\te->top_layer = top_layer;\n\te->mid_layer = mid_layer;\n\te->low_layer = low_layer;\n\te->page_frame_number = page_frame_number;\n\te->offset_in_page = offset_in_page;\n\te->syndrome = syndrome;\n\t \n\te->msg = msg ?: \"\";\n\te->other_detail = other_detail ?: \"\";\n\n\t \n\tfor (i = 0; i < mci->n_layers; i++) {\n\t\tif (pos[i] >= (int)mci->layers[i].size) {\n\n\t\t\tedac_mc_printk(mci, KERN_ERR,\n\t\t\t\t       \"INTERNAL ERROR: %s value is out of range (%d >= %d)\\n\",\n\t\t\t\t       edac_layer_name[mci->layers[i].type],\n\t\t\t\t       pos[i], mci->layers[i].size);\n\t\t\t \n\t\t\tpos[i] = -1;\n\t\t}\n\t\tif (pos[i] >= 0)\n\t\t\tany_memory = false;\n\t}\n\n\t \n\tp = e->label;\n\t*p = '\\0';\n\tend = p + sizeof(e->label);\n\tprefix = \"\";\n\n\tmci_for_each_dimm(mci, dimm) {\n\t\tif (top_layer >= 0 && top_layer != dimm->location[0])\n\t\t\tcontinue;\n\t\tif (mid_layer >= 0 && mid_layer != dimm->location[1])\n\t\t\tcontinue;\n\t\tif (low_layer >= 0 && low_layer != dimm->location[2])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dimm->grain > e->grain)\n\t\t\te->grain = dimm->grain;\n\n\t\t \n\t\tif (!dimm->nr_pages)\n\t\t\tcontinue;\n\n\t\tn_labels++;\n\t\tif (n_labels > EDAC_MAX_LABELS) {\n\t\t\tp = e->label;\n\t\t\t*p = '\\0';\n\t\t} else {\n\t\t\tp += scnprintf(p, end - p, \"%s%s\", prefix, dimm->label);\n\t\t\tprefix = OTHER_LABEL;\n\t\t}\n\n\t\t \n\t\tedac_dbg(4, \"%s csrows map: (%d,%d)\\n\",\n\t\t\tmci->csbased ? \"rank\" : \"dimm\",\n\t\t\tdimm->csrow, dimm->cschannel);\n\t\tif (row == -1)\n\t\t\trow = dimm->csrow;\n\t\telse if (row >= 0 && row != dimm->csrow)\n\t\t\trow = -2;\n\n\t\tif (chan == -1)\n\t\t\tchan = dimm->cschannel;\n\t\telse if (chan >= 0 && chan != dimm->cschannel)\n\t\t\tchan = -2;\n\t}\n\n\tif (any_memory)\n\t\tstrscpy(e->label, \"any memory\", sizeof(e->label));\n\telse if (!*e->label)\n\t\tstrscpy(e->label, \"unknown memory\", sizeof(e->label));\n\n\tedac_inc_csrow(e, row, chan);\n\n\t \n\tp = e->location;\n\tend = p + sizeof(e->location);\n\tprefix = \"\";\n\n\tfor (i = 0; i < mci->n_layers; i++) {\n\t\tif (pos[i] < 0)\n\t\t\tcontinue;\n\n\t\tp += scnprintf(p, end - p, \"%s%s:%d\", prefix,\n\t\t\t       edac_layer_name[mci->layers[i].type], pos[i]);\n\t\tprefix = \" \";\n\t}\n\n\tedac_raw_mc_handle_error(e);\n}\nEXPORT_SYMBOL_GPL(edac_mc_handle_error);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}