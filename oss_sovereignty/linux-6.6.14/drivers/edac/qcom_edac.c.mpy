{
  "module_name": "qcom_edac.c",
  "hash_id": "f662640314e5036172f12dcd06d768302330183be93aef7e23e67c94b04bd7bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/qcom_edac.c",
  "human_readable_source": "\n \n\n#include <linux/edac.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/soc/qcom/llcc-qcom.h>\n\n#include \"edac_mc.h\"\n#include \"edac_device.h\"\n\n#define EDAC_LLCC                       \"qcom_llcc\"\n\n#define LLCC_ERP_PANIC_ON_UE            1\n\n#define TRP_SYN_REG_CNT                 6\n#define DRP_SYN_REG_CNT                 8\n\n#define LLCC_LB_CNT_MASK                GENMASK(31, 28)\n#define LLCC_LB_CNT_SHIFT               28\n\n \n#define ECC_DB_ERR_COUNT_MASK           GENMASK(4, 0)\n#define ECC_DB_ERR_WAYS_MASK            GENMASK(31, 16)\n#define ECC_DB_ERR_WAYS_SHIFT           BIT(4)\n\n#define ECC_SB_ERR_COUNT_MASK           GENMASK(23, 16)\n#define ECC_SB_ERR_COUNT_SHIFT          BIT(4)\n#define ECC_SB_ERR_WAYS_MASK            GENMASK(15, 0)\n\n#define SB_ECC_ERROR                    BIT(0)\n#define DB_ECC_ERROR                    BIT(1)\n\n#define DRP_TRP_INT_CLEAR               GENMASK(1, 0)\n#define DRP_TRP_CNT_CLEAR               GENMASK(1, 0)\n\n#define SB_ERROR_THRESHOLD              0x1\n#define SB_ERROR_THRESHOLD_SHIFT        24\n#define SB_DB_TRP_INTERRUPT_ENABLE      0x3\n#define TRP0_INTERRUPT_ENABLE           0x1\n#define DRP0_INTERRUPT_ENABLE           BIT(6)\n#define SB_DB_DRP_INTERRUPT_ENABLE      0x3\n\n#define ECC_POLL_MSEC\t\t\t5000\n\nenum {\n\tLLCC_DRAM_CE = 0,\n\tLLCC_DRAM_UE,\n\tLLCC_TRAM_CE,\n\tLLCC_TRAM_UE,\n};\n\nstatic const struct llcc_edac_reg_data edac_reg_data[] = {\n\t[LLCC_DRAM_CE] = {\n\t\t.name = \"DRAM Single-bit\",\n\t\t.reg_cnt = DRP_SYN_REG_CNT,\n\t\t.count_mask = ECC_SB_ERR_COUNT_MASK,\n\t\t.ways_mask = ECC_SB_ERR_WAYS_MASK,\n\t\t.count_shift = ECC_SB_ERR_COUNT_SHIFT,\n\t},\n\t[LLCC_DRAM_UE] = {\n\t\t.name = \"DRAM Double-bit\",\n\t\t.reg_cnt = DRP_SYN_REG_CNT,\n\t\t.count_mask = ECC_DB_ERR_COUNT_MASK,\n\t\t.ways_mask = ECC_DB_ERR_WAYS_MASK,\n\t\t.ways_shift = ECC_DB_ERR_WAYS_SHIFT,\n\t},\n\t[LLCC_TRAM_CE] = {\n\t\t.name = \"TRAM Single-bit\",\n\t\t.reg_cnt = TRP_SYN_REG_CNT,\n\t\t.count_mask = ECC_SB_ERR_COUNT_MASK,\n\t\t.ways_mask = ECC_SB_ERR_WAYS_MASK,\n\t\t.count_shift = ECC_SB_ERR_COUNT_SHIFT,\n\t},\n\t[LLCC_TRAM_UE] = {\n\t\t.name = \"TRAM Double-bit\",\n\t\t.reg_cnt = TRP_SYN_REG_CNT,\n\t\t.count_mask = ECC_DB_ERR_COUNT_MASK,\n\t\t.ways_mask = ECC_DB_ERR_WAYS_MASK,\n\t\t.ways_shift = ECC_DB_ERR_WAYS_SHIFT,\n\t},\n};\n\nstatic int qcom_llcc_core_setup(struct llcc_drv_data *drv, struct regmap *llcc_bcast_regmap)\n{\n\tu32 sb_err_threshold;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(llcc_bcast_regmap, drv->edac_reg_offset->cmn_interrupt_2_enable,\n\t\t\t\t TRP0_INTERRUPT_ENABLE,\n\t\t\t\t TRP0_INTERRUPT_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(llcc_bcast_regmap, drv->edac_reg_offset->trp_interrupt_0_enable,\n\t\t\t\t SB_DB_TRP_INTERRUPT_ENABLE,\n\t\t\t\t SB_DB_TRP_INTERRUPT_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\tsb_err_threshold = (SB_ERROR_THRESHOLD << SB_ERROR_THRESHOLD_SHIFT);\n\tret = regmap_write(llcc_bcast_regmap, drv->edac_reg_offset->drp_ecc_error_cfg,\n\t\t\t   sb_err_threshold);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(llcc_bcast_regmap, drv->edac_reg_offset->cmn_interrupt_2_enable,\n\t\t\t\t DRP0_INTERRUPT_ENABLE,\n\t\t\t\t DRP0_INTERRUPT_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(llcc_bcast_regmap, drv->edac_reg_offset->drp_interrupt_enable,\n\t\t\t   SB_DB_DRP_INTERRUPT_ENABLE);\n\treturn ret;\n}\n\n \nstatic int\nqcom_llcc_clear_error_status(int err_type, struct llcc_drv_data *drv)\n{\n\tint ret;\n\n\tswitch (err_type) {\n\tcase LLCC_DRAM_CE:\n\tcase LLCC_DRAM_UE:\n\t\tret = regmap_write(drv->bcast_regmap,\n\t\t\t\t   drv->edac_reg_offset->drp_interrupt_clear,\n\t\t\t\t   DRP_TRP_INT_CLEAR);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(drv->bcast_regmap,\n\t\t\t\t   drv->edac_reg_offset->drp_ecc_error_cntr_clear,\n\t\t\t\t   DRP_TRP_CNT_CLEAR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase LLCC_TRAM_CE:\n\tcase LLCC_TRAM_UE:\n\t\tret = regmap_write(drv->bcast_regmap,\n\t\t\t\t   drv->edac_reg_offset->trp_interrupt_0_clear,\n\t\t\t\t   DRP_TRP_INT_CLEAR);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(drv->bcast_regmap,\n\t\t\t\t   drv->edac_reg_offset->trp_ecc_error_cntr_clear,\n\t\t\t\t   DRP_TRP_CNT_CLEAR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tedac_printk(KERN_CRIT, EDAC_LLCC, \"Unexpected error type: %d\\n\",\n\t\t\t    err_type);\n\t}\n\treturn ret;\n}\n\nstruct qcom_llcc_syn_regs {\n\tu32 synd_reg;\n\tu32 count_status_reg;\n\tu32 ways_status_reg;\n};\n\nstatic void get_reg_offsets(struct llcc_drv_data *drv, int err_type,\n\t\t\t    struct qcom_llcc_syn_regs *syn_regs)\n{\n\tconst struct llcc_edac_reg_offset *edac_reg_offset = drv->edac_reg_offset;\n\n\tswitch (err_type) {\n\tcase LLCC_DRAM_CE:\n\t\tsyn_regs->synd_reg = edac_reg_offset->drp_ecc_sb_err_syn0;\n\t\tsyn_regs->count_status_reg = edac_reg_offset->drp_ecc_error_status1;\n\t\tsyn_regs->ways_status_reg = edac_reg_offset->drp_ecc_error_status0;\n\t\tbreak;\n\tcase LLCC_DRAM_UE:\n\t\tsyn_regs->synd_reg = edac_reg_offset->drp_ecc_db_err_syn0;\n\t\tsyn_regs->count_status_reg = edac_reg_offset->drp_ecc_error_status1;\n\t\tsyn_regs->ways_status_reg = edac_reg_offset->drp_ecc_error_status0;\n\t\tbreak;\n\tcase LLCC_TRAM_CE:\n\t\tsyn_regs->synd_reg = edac_reg_offset->trp_ecc_sb_err_syn0;\n\t\tsyn_regs->count_status_reg = edac_reg_offset->trp_ecc_error_status1;\n\t\tsyn_regs->ways_status_reg = edac_reg_offset->trp_ecc_error_status0;\n\t\tbreak;\n\tcase LLCC_TRAM_UE:\n\t\tsyn_regs->synd_reg = edac_reg_offset->trp_ecc_db_err_syn0;\n\t\tsyn_regs->count_status_reg = edac_reg_offset->trp_ecc_error_status1;\n\t\tsyn_regs->ways_status_reg = edac_reg_offset->trp_ecc_error_status0;\n\t\tbreak;\n\t}\n}\n\n \nstatic int\ndump_syn_reg_values(struct llcc_drv_data *drv, u32 bank, int err_type)\n{\n\tstruct llcc_edac_reg_data reg_data = edac_reg_data[err_type];\n\tstruct qcom_llcc_syn_regs regs = { };\n\tint err_cnt, err_ways, ret, i;\n\tu32 synd_reg, synd_val;\n\n\tget_reg_offsets(drv, err_type, &regs);\n\n\tfor (i = 0; i < reg_data.reg_cnt; i++) {\n\t\tsynd_reg = regs.synd_reg + (i * 4);\n\t\tret = regmap_read(drv->regmaps[bank], synd_reg,\n\t\t\t\t  &synd_val);\n\t\tif (ret)\n\t\t\tgoto clear;\n\n\t\tedac_printk(KERN_CRIT, EDAC_LLCC, \"%s: ECC_SYN%d: 0x%8x\\n\",\n\t\t\t    reg_data.name, i, synd_val);\n\t}\n\n\tret = regmap_read(drv->regmaps[bank], regs.count_status_reg,\n\t\t\t  &err_cnt);\n\tif (ret)\n\t\tgoto clear;\n\n\terr_cnt &= reg_data.count_mask;\n\terr_cnt >>= reg_data.count_shift;\n\tedac_printk(KERN_CRIT, EDAC_LLCC, \"%s: Error count: 0x%4x\\n\",\n\t\t    reg_data.name, err_cnt);\n\n\tret = regmap_read(drv->regmaps[bank], regs.ways_status_reg,\n\t\t\t  &err_ways);\n\tif (ret)\n\t\tgoto clear;\n\n\terr_ways &= reg_data.ways_mask;\n\terr_ways >>= reg_data.ways_shift;\n\n\tedac_printk(KERN_CRIT, EDAC_LLCC, \"%s: Error ways: 0x%4x\\n\",\n\t\t    reg_data.name, err_ways);\n\nclear:\n\treturn qcom_llcc_clear_error_status(err_type, drv);\n}\n\nstatic int\ndump_syn_reg(struct edac_device_ctl_info *edev_ctl, int err_type, u32 bank)\n{\n\tstruct llcc_drv_data *drv = edev_ctl->dev->platform_data;\n\tint ret;\n\n\tret = dump_syn_reg_values(drv, bank, err_type);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (err_type) {\n\tcase LLCC_DRAM_CE:\n\t\tedac_device_handle_ce(edev_ctl, 0, bank,\n\t\t\t\t      \"LLCC Data RAM correctable Error\");\n\t\tbreak;\n\tcase LLCC_DRAM_UE:\n\t\tedac_device_handle_ue(edev_ctl, 0, bank,\n\t\t\t\t      \"LLCC Data RAM uncorrectable Error\");\n\t\tbreak;\n\tcase LLCC_TRAM_CE:\n\t\tedac_device_handle_ce(edev_ctl, 0, bank,\n\t\t\t\t      \"LLCC Tag RAM correctable Error\");\n\t\tbreak;\n\tcase LLCC_TRAM_UE:\n\t\tedac_device_handle_ue(edev_ctl, 0, bank,\n\t\t\t\t      \"LLCC Tag RAM uncorrectable Error\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tedac_printk(KERN_CRIT, EDAC_LLCC, \"Unexpected error type: %d\\n\",\n\t\t\t    err_type);\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t llcc_ecc_irq_handler(int irq, void *edev_ctl)\n{\n\tstruct edac_device_ctl_info *edac_dev_ctl = edev_ctl;\n\tstruct llcc_drv_data *drv = edac_dev_ctl->dev->platform_data;\n\tirqreturn_t irq_rc = IRQ_NONE;\n\tu32 drp_error, trp_error, i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < drv->num_banks; i++) {\n\t\tret = regmap_read(drv->regmaps[i], drv->edac_reg_offset->drp_interrupt_status,\n\t\t\t\t  &drp_error);\n\n\t\tif (!ret && (drp_error & SB_ECC_ERROR)) {\n\t\t\tedac_printk(KERN_CRIT, EDAC_LLCC,\n\t\t\t\t    \"Single Bit Error detected in Data RAM\\n\");\n\t\t\tret = dump_syn_reg(edev_ctl, LLCC_DRAM_CE, i);\n\t\t} else if (!ret && (drp_error & DB_ECC_ERROR)) {\n\t\t\tedac_printk(KERN_CRIT, EDAC_LLCC,\n\t\t\t\t    \"Double Bit Error detected in Data RAM\\n\");\n\t\t\tret = dump_syn_reg(edev_ctl, LLCC_DRAM_UE, i);\n\t\t}\n\t\tif (!ret)\n\t\t\tirq_rc = IRQ_HANDLED;\n\n\t\tret = regmap_read(drv->regmaps[i], drv->edac_reg_offset->trp_interrupt_0_status,\n\t\t\t\t  &trp_error);\n\n\t\tif (!ret && (trp_error & SB_ECC_ERROR)) {\n\t\t\tedac_printk(KERN_CRIT, EDAC_LLCC,\n\t\t\t\t    \"Single Bit Error detected in Tag RAM\\n\");\n\t\t\tret = dump_syn_reg(edev_ctl, LLCC_TRAM_CE, i);\n\t\t} else if (!ret && (trp_error & DB_ECC_ERROR)) {\n\t\t\tedac_printk(KERN_CRIT, EDAC_LLCC,\n\t\t\t\t    \"Double Bit Error detected in Tag RAM\\n\");\n\t\t\tret = dump_syn_reg(edev_ctl, LLCC_TRAM_UE, i);\n\t\t}\n\t\tif (!ret)\n\t\t\tirq_rc = IRQ_HANDLED;\n\t}\n\n\treturn irq_rc;\n}\n\nstatic void llcc_ecc_check(struct edac_device_ctl_info *edev_ctl)\n{\n\tllcc_ecc_irq_handler(0, edev_ctl);\n}\n\nstatic int qcom_llcc_edac_probe(struct platform_device *pdev)\n{\n\tstruct llcc_drv_data *llcc_driv_data = pdev->dev.platform_data;\n\tstruct edac_device_ctl_info *edev_ctl;\n\tstruct device *dev = &pdev->dev;\n\tint ecc_irq;\n\tint rc;\n\n\trc = qcom_llcc_core_setup(llcc_driv_data, llcc_driv_data->bcast_regmap);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tedev_ctl = edac_device_alloc_ctl_info(0, \"qcom-llcc\", 1, \"bank\",\n\t\t\t\t\t      llcc_driv_data->num_banks, 1,\n\t\t\t\t\t      NULL, 0,\n\t\t\t\t\t      edac_device_alloc_index());\n\n\tif (!edev_ctl)\n\t\treturn -ENOMEM;\n\n\tedev_ctl->dev = dev;\n\tedev_ctl->mod_name = dev_name(dev);\n\tedev_ctl->dev_name = dev_name(dev);\n\tedev_ctl->ctl_name = \"llcc\";\n\tedev_ctl->panic_on_ue = LLCC_ERP_PANIC_ON_UE;\n\n\t \n\tecc_irq = llcc_driv_data->ecc_irq;\n\tif (ecc_irq > 0) {\n\t\t \n\t\trc = devm_request_irq(dev, ecc_irq, llcc_ecc_irq_handler,\n\t\t\t      IRQF_TRIGGER_HIGH, \"llcc_ecc\", edev_ctl);\n\t\tif (!rc) {\n\t\t\tedac_op_state = EDAC_OPSTATE_INT;\n\t\t\tgoto irq_done;\n\t\t}\n\t}\n\n\t \n\tedev_ctl->poll_msec = ECC_POLL_MSEC;\n\tedev_ctl->edac_check = llcc_ecc_check;\n\tedac_op_state = EDAC_OPSTATE_POLL;\n\nirq_done:\n\trc = edac_device_add_device(edev_ctl);\n\tif (rc) {\n\t\tedac_device_free_ctl_info(edev_ctl);\n\t\treturn rc;\n\t}\n\n\tplatform_set_drvdata(pdev, edev_ctl);\n\n\treturn rc;\n}\n\nstatic int qcom_llcc_edac_remove(struct platform_device *pdev)\n{\n\tstruct edac_device_ctl_info *edev_ctl = dev_get_drvdata(&pdev->dev);\n\n\tedac_device_del_device(edev_ctl->dev);\n\tedac_device_free_ctl_info(edev_ctl);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id qcom_llcc_edac_id_table[] = {\n\t{ .name = \"qcom_llcc_edac\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, qcom_llcc_edac_id_table);\n\nstatic struct platform_driver qcom_llcc_edac_driver = {\n\t.probe = qcom_llcc_edac_probe,\n\t.remove = qcom_llcc_edac_remove,\n\t.driver = {\n\t\t.name = \"qcom_llcc_edac\",\n\t},\n\t.id_table = qcom_llcc_edac_id_table,\n};\nmodule_platform_driver(qcom_llcc_edac_driver);\n\nMODULE_DESCRIPTION(\"QCOM EDAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}