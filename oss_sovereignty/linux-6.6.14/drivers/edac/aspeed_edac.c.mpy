{
  "module_name": "aspeed_edac.c",
  "hash_id": "b4fdf90e4e823cbfb3145d4f94b4b8db6194125f0fc3b42658a2102a994a0157",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/aspeed_edac.c",
  "human_readable_source": "\n \n\n#include <linux/edac.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/stop_machine.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/regmap.h>\n#include \"edac_module.h\"\n\n\n#define DRV_NAME \"aspeed-edac\"\n\n\n#define ASPEED_MCR_PROT        0x00  \n#define ASPEED_MCR_CONF        0x04  \n#define ASPEED_MCR_INTR_CTRL   0x50  \n#define ASPEED_MCR_ADDR_UNREC  0x58  \n#define ASPEED_MCR_ADDR_REC    0x5c  \n#define ASPEED_MCR_LAST        ASPEED_MCR_ADDR_REC\n\n\n#define ASPEED_MCR_PROT_PASSWD\t            0xfc600309\n#define ASPEED_MCR_CONF_DRAM_TYPE               BIT(4)\n#define ASPEED_MCR_CONF_ECC                     BIT(7)\n#define ASPEED_MCR_INTR_CTRL_CLEAR             BIT(31)\n#define ASPEED_MCR_INTR_CTRL_CNT_REC   GENMASK(23, 16)\n#define ASPEED_MCR_INTR_CTRL_CNT_UNREC GENMASK(15, 12)\n#define ASPEED_MCR_INTR_CTRL_ENABLE  (BIT(0) | BIT(1))\n\n\nstatic struct regmap *aspeed_regmap;\n\n\nstatic int regmap_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tvoid __iomem *regs = (void __iomem *)context;\n\n\t \n\twritel(ASPEED_MCR_PROT_PASSWD, regs + ASPEED_MCR_PROT);\n\n\twritel(val, regs + reg);\n\n\t \n\twritel(~ASPEED_MCR_PROT_PASSWD, regs + ASPEED_MCR_PROT);\n\n\treturn 0;\n}\n\n\nstatic int regmap_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tvoid __iomem *regs = (void __iomem *)context;\n\n\t*val = readl(regs + reg);\n\n\treturn 0;\n}\n\nstatic bool regmap_is_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ASPEED_MCR_PROT:\n\tcase ASPEED_MCR_INTR_CTRL:\n\tcase ASPEED_MCR_ADDR_UNREC:\n\tcase ASPEED_MCR_ADDR_REC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n\nstatic const struct regmap_config aspeed_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = ASPEED_MCR_LAST,\n\t.reg_write = regmap_reg_write,\n\t.reg_read = regmap_reg_read,\n\t.volatile_reg = regmap_is_volatile,\n\t.fast_io = true,\n};\n\n\nstatic void count_rec(struct mem_ctl_info *mci, u8 rec_cnt, u32 rec_addr)\n{\n\tstruct csrow_info *csrow = mci->csrows[0];\n\tu32 page, offset, syndrome;\n\n\tif (!rec_cnt)\n\t\treturn;\n\n\t \n\t \n\tif (rec_cnt > 1) {\n\t\t \n\t\tpage = 0;\n\t\toffset = 0;\n\t\tsyndrome = 0;\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, rec_cnt-1,\n\t\t\t\t     page, offset, syndrome, 0, 0, -1,\n\t\t\t\t     \"address(es) not available\", \"\");\n\t}\n\n\t \n\t \n\tpage = rec_addr >> PAGE_SHIFT;\n\toffset = rec_addr & ~PAGE_MASK;\n\t \n\tsyndrome = 0;\n\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t     csrow->first_page + page, offset, syndrome,\n\t\t\t     0, 0, -1, \"\", \"\");\n}\n\n\nstatic void count_un_rec(struct mem_ctl_info *mci, u8 un_rec_cnt,\n\t\t\t u32 un_rec_addr)\n{\n\tstruct csrow_info *csrow = mci->csrows[0];\n\tu32 page, offset, syndrome;\n\n\tif (!un_rec_cnt)\n\t\treturn;\n\n\t \n\t \n\tpage = un_rec_addr >> PAGE_SHIFT;\n\toffset = un_rec_addr & ~PAGE_MASK;\n\t \n\tsyndrome = 0;\n\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t     csrow->first_page + page, offset, syndrome,\n\t\t\t     0, 0, -1, \"\", \"\");\n\n\t \n\t \n\tif (un_rec_cnt > 1) {\n\t\t \n\t\tpage = 0;\n\t\toffset = 0;\n\t\tsyndrome = 0;\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, un_rec_cnt-1,\n\t\t\t\t     page, offset, syndrome, 0, 0, -1,\n\t\t\t\t     \"address(es) not available\", \"\");\n\t}\n}\n\n\nstatic irqreturn_t mcr_isr(int irq, void *arg)\n{\n\tstruct mem_ctl_info *mci = arg;\n\tu32 rec_addr, un_rec_addr;\n\tu32 reg50, reg5c, reg58;\n\tu8  rec_cnt, un_rec_cnt;\n\n\tregmap_read(aspeed_regmap, ASPEED_MCR_INTR_CTRL, &reg50);\n\tdev_dbg(mci->pdev, \"received edac interrupt w/ mcr register 50: 0x%x\\n\",\n\t\treg50);\n\n\t \n\trec_cnt = (reg50 & ASPEED_MCR_INTR_CTRL_CNT_REC) >> 16;\n\tun_rec_cnt = (reg50 & ASPEED_MCR_INTR_CTRL_CNT_UNREC) >> 12;\n\n\tdev_dbg(mci->pdev, \"%d recoverable interrupts and %d unrecoverable interrupts\\n\",\n\t\trec_cnt, un_rec_cnt);\n\n\tregmap_read(aspeed_regmap, ASPEED_MCR_ADDR_UNREC, &reg58);\n\tun_rec_addr = reg58;\n\n\tregmap_read(aspeed_regmap, ASPEED_MCR_ADDR_REC, &reg5c);\n\trec_addr = reg5c;\n\n\t \n\tregmap_update_bits(aspeed_regmap, ASPEED_MCR_INTR_CTRL,\n\t\t\t   ASPEED_MCR_INTR_CTRL_CLEAR,\n\t\t\t   ASPEED_MCR_INTR_CTRL_CLEAR);\n\n\tregmap_update_bits(aspeed_regmap, ASPEED_MCR_INTR_CTRL,\n\t\t\t   ASPEED_MCR_INTR_CTRL_CLEAR, 0);\n\n\t \n\tcount_rec(mci, rec_cnt, rec_addr);\n\tcount_un_rec(mci, un_rec_cnt, un_rec_addr);\n\n\tif (!rec_cnt && !un_rec_cnt)\n\t\tdev_dbg(mci->pdev, \"received edac interrupt, but did not find any ECC counters\\n\");\n\n\tregmap_read(aspeed_regmap, ASPEED_MCR_INTR_CTRL, &reg50);\n\tdev_dbg(mci->pdev, \"edac interrupt handled. mcr reg 50 is now: 0x%x\\n\",\n\t\treg50);\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int config_irq(void *ctx, struct platform_device *pdev)\n{\n\tint irq;\n\tint rc;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tdev_dbg(&pdev->dev, \"got irq %d\\n\", irq);\n\tif (irq < 0)\n\t\treturn irq;\n\n\trc = devm_request_irq(&pdev->dev, irq, mcr_isr, IRQF_TRIGGER_HIGH,\n\t\t\t      DRV_NAME, ctx);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"unable to request irq %d\\n\", irq);\n\t\treturn rc;\n\t}\n\n\t \n\tregmap_update_bits(aspeed_regmap, ASPEED_MCR_INTR_CTRL,\n\t\t\t   ASPEED_MCR_INTR_CTRL_ENABLE,\n\t\t\t   ASPEED_MCR_INTR_CTRL_ENABLE);\n\n\treturn 0;\n}\n\n\nstatic int init_csrows(struct mem_ctl_info *mci)\n{\n\tstruct csrow_info *csrow = mci->csrows[0];\n\tu32 nr_pages, dram_type;\n\tstruct dimm_info *dimm;\n\tstruct device_node *np;\n\tstruct resource r;\n\tu32 reg04;\n\tint rc;\n\n\t \n\tnp = of_find_node_by_name(NULL, \"memory\");\n\tif (!np) {\n\t\tdev_err(mci->pdev, \"dt: missing /memory node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = of_address_to_resource(np, 0, &r);\n\n\tof_node_put(np);\n\n\tif (rc) {\n\t\tdev_err(mci->pdev, \"dt: failed requesting resource for /memory node\\n\");\n\t\treturn rc;\n\t}\n\n\tdev_dbg(mci->pdev, \"dt: /memory node resources: first page %pR, PAGE_SHIFT macro=0x%x\\n\",\n\t\t&r, PAGE_SHIFT);\n\n\tcsrow->first_page = r.start >> PAGE_SHIFT;\n\tnr_pages = resource_size(&r) >> PAGE_SHIFT;\n\tcsrow->last_page = csrow->first_page + nr_pages - 1;\n\n\tregmap_read(aspeed_regmap, ASPEED_MCR_CONF, &reg04);\n\tdram_type = (reg04 & ASPEED_MCR_CONF_DRAM_TYPE) ? MEM_DDR4 : MEM_DDR3;\n\n\tdimm = csrow->channels[0]->dimm;\n\tdimm->mtype = dram_type;\n\tdimm->edac_mode = EDAC_SECDED;\n\tdimm->nr_pages = nr_pages / csrow->nr_channels;\n\n\tdev_dbg(mci->pdev, \"initialized dimm with first_page=0x%lx and nr_pages=0x%x\\n\",\n\t\tcsrow->first_page, nr_pages);\n\n\treturn 0;\n}\n\n\nstatic int aspeed_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct edac_mc_layer layers[2];\n\tstruct mem_ctl_info *mci;\n\tvoid __iomem *regs;\n\tu32 reg04;\n\tint rc;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\taspeed_regmap = devm_regmap_init(dev, NULL, (__force void *)regs,\n\t\t\t\t\t &aspeed_regmap_config);\n\tif (IS_ERR(aspeed_regmap))\n\t\treturn PTR_ERR(aspeed_regmap);\n\n\t \n\tregmap_read(aspeed_regmap, ASPEED_MCR_CONF, &reg04);\n\tif (!(reg04 & ASPEED_MCR_CONF_ECC)) {\n\t\tdev_err(&pdev->dev, \"ECC mode is not configured in u-boot\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tedac_op_state = EDAC_OPSTATE_INT;\n\n\t \n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = 1;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = 1;\n\tlayers[1].is_virt_csrow = false;\n\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_DDR3 | MEM_FLAG_DDR4;\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->scrub_cap = SCRUB_FLAG_HW_SRC;\n\tmci->scrub_mode = SCRUB_HW_SRC;\n\tmci->mod_name = DRV_NAME;\n\tmci->ctl_name = \"MIC\";\n\tmci->dev_name = dev_name(&pdev->dev);\n\n\trc = init_csrows(mci);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to init csrows\\n\");\n\t\tgoto probe_exit02;\n\t}\n\n\tplatform_set_drvdata(pdev, mci);\n\n\t \n\trc = edac_mc_add_mc(mci);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed to register with EDAC core\\n\");\n\t\tgoto probe_exit02;\n\t}\n\n\t \n\trc = config_irq(mci, pdev);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"failed setting up irq\\n\");\n\t\tgoto probe_exit01;\n\t}\n\n\treturn 0;\n\nprobe_exit01:\n\tedac_mc_del_mc(&pdev->dev);\nprobe_exit02:\n\tedac_mc_free(mci);\n\treturn rc;\n}\n\n\nstatic int aspeed_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\n\t \n\tregmap_update_bits(aspeed_regmap, ASPEED_MCR_INTR_CTRL,\n\t\t\t   ASPEED_MCR_INTR_CTRL_ENABLE, 0);\n\n\t \n\tmci = edac_mc_del_mc(&pdev->dev);\n\tif (mci)\n\t\tedac_mc_free(mci);\n\n\treturn 0;\n}\n\n\nstatic const struct of_device_id aspeed_of_match[] = {\n\t{ .compatible = \"aspeed,ast2400-sdram-edac\" },\n\t{ .compatible = \"aspeed,ast2500-sdram-edac\" },\n\t{ .compatible = \"aspeed,ast2600-sdram-edac\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, aspeed_of_match);\n\nstatic struct platform_driver aspeed_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = aspeed_of_match\n\t},\n\t.probe\t\t= aspeed_probe,\n\t.remove\t\t= aspeed_remove\n};\nmodule_platform_driver(aspeed_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Stefan Schaeckeler <sschaeck@cisco.com>\");\nMODULE_DESCRIPTION(\"Aspeed BMC SoC EDAC driver\");\nMODULE_VERSION(\"1.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}