{
  "module_name": "i5400_edac.c",
  "hash_id": "6a3dabbe12263c531c9f6d2349a029970b67c7d71ad328323f810228b5c8efd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/i5400_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/slab.h>\n#include <linux/edac.h>\n#include <linux/mmzone.h>\n\n#include \"edac_module.h\"\n\n \n#define I5400_REVISION    \" Ver: 1.0.0\"\n\n#define EDAC_MOD_STR      \"i5400_edac\"\n\n#define i5400_printk(level, fmt, arg...) \\\n\tedac_printk(level, \"i5400\", fmt, ##arg)\n\n#define i5400_mc_printk(mci, level, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, level, \"i5400\", fmt, ##arg)\n\n \n#define MAX_BRANCHES\t\t2\n#define CHANNELS_PER_BRANCH\t2\n#define DIMMS_PER_CHANNEL\t4\n#define\tMAX_CHANNELS\t\t(MAX_BRANCHES * CHANNELS_PER_BRANCH)\n\n \n\n\t \n#define\t\tAMBASE\t\t\t0x48  \n#define\t\tMAXCH\t\t\t0x56  \n#define\t\tMAXDIMMPERCH\t\t0x57  \n\n\t \n#define\t\tTOLM\t\t\t0x6C\n#define\t\tREDMEMB\t\t\t0x7C\n#define\t\t\tREC_ECC_LOCATOR_ODD(x)\t((x) & 0x3fe00)  \n#define\t\tMIR0\t\t\t0x80\n#define\t\tMIR1\t\t\t0x84\n#define\t\tAMIR0\t\t\t0x8c\n#define\t\tAMIR1\t\t\t0x90\n\n\t \n#define\t\tFERR_FAT_FBD\t\t0x98\t \n#define\t\t\tFERR_FAT_FBDCHAN (3<<28)\t \n\n#define\t\tNERR_FAT_FBD\t\t0x9c\n#define\t\tFERR_NF_FBD\t\t0xa0\t \n\n\t \n#define\t\tNERR_NF_FBD\t\t0xa4\n\n\t \n#define\t\tEMASK_FBD\t\t0xa8\n\n#define\t\tERR0_FBD\t\t0xac\n#define\t\tERR1_FBD\t\t0xb0\n#define\t\tERR2_FBD\t\t0xb4\n#define\t\tMCERR_FBD\t\t0xb8\n\n\t \n\n \n\n\t \n#define AMBPRESENT_0\t0x64\n#define AMBPRESENT_1\t0x66\n#define MTR0\t\t0x80\n#define MTR1\t\t0x82\n#define MTR2\t\t0x84\n#define MTR3\t\t0x86\n\n\t \n#define NRECFGLOG\t\t0x74\n#define RECFGLOG\t\t0x78\n#define NRECMEMA\t\t0xbe\n#define NRECMEMB\t\t0xc0\n#define NRECFB_DIMMA\t\t0xc4\n#define NRECFB_DIMMB\t\t0xc8\n#define NRECFB_DIMMC\t\t0xcc\n#define NRECFB_DIMMD\t\t0xd0\n#define NRECFB_DIMME\t\t0xd4\n#define NRECFB_DIMMF\t\t0xd8\n#define REDMEMA\t\t\t0xdC\n#define RECMEMA\t\t\t0xf0\n#define RECMEMB\t\t\t0xf4\n#define RECFB_DIMMA\t\t0xf8\n#define RECFB_DIMMB\t\t0xec\n#define RECFB_DIMMC\t\t0xf0\n#define RECFB_DIMMD\t\t0xf4\n#define RECFB_DIMME\t\t0xf8\n#define RECFB_DIMMF\t\t0xfC\n\n \n\nenum error_mask {\n\tEMASK_M1  = 1<<0,   \n\tEMASK_M2  = 1<<1,   \n\tEMASK_M3  = 1<<2,   \n\tEMASK_M4  = 1<<3,   \n\tEMASK_M5  = 1<<4,   \n\tEMASK_M6  = 1<<5,   \n\tEMASK_M7  = 1<<6,   \n\tEMASK_M8  = 1<<7,   \n\tEMASK_M9  = 1<<8,   \n\tEMASK_M10 = 1<<9,   \n\tEMASK_M11 = 1<<10,  \n\tEMASK_M12 = 1<<11,  \n\tEMASK_M13 = 1<<12,  \n\tEMASK_M14 = 1<<13,  \n\tEMASK_M15 = 1<<14,  \n\tEMASK_M16 = 1<<15,  \n\tEMASK_M17 = 1<<16,  \n\tEMASK_M18 = 1<<17,  \n\tEMASK_M19 = 1<<18,  \n\tEMASK_M20 = 1<<19,  \n\tEMASK_M21 = 1<<20,  \n\tEMASK_M22 = 1<<21,  \n\tEMASK_M23 = 1<<22,  \n\tEMASK_M24 = 1<<23,  \n\tEMASK_M25 = 1<<24,  \n\tEMASK_M26 = 1<<25,  \n\tEMASK_M27 = 1<<26,  \n\tEMASK_M28 = 1<<27,  \n\tEMASK_M29 = 1<<28,  \n};\n\n \nstatic const char *error_name[] = {\n\t[0]  = \"Memory Write error on non-redundant retry\",\n\t[1]  = \"Memory or FB-DIMM configuration CRC read error\",\n\t \n\t[3]  = \"Uncorrectable Data ECC on Replay\",\n\t[4]  = \"Aliased Uncorrectable Non-Mirrored Demand Data ECC\",\n\t \n\t[6]  = \"Aliased Uncorrectable Resilver- or Spare-Copy Data ECC\",\n\t[7]  = \"Aliased Uncorrectable Patrol Data ECC\",\n\t[8]  = \"Non-Aliased Uncorrectable Non-Mirrored Demand Data ECC\",\n\t \n\t[10] = \"Non-Aliased Uncorrectable Resilver- or Spare-Copy Data ECC\",\n\t[11] = \"Non-Aliased Uncorrectable Patrol Data ECC\",\n\t[12] = \"Memory Write error on first attempt\",\n\t[13] = \"FB-DIMM Configuration Write error on first attempt\",\n\t[14] = \"Memory or FB-DIMM configuration CRC read error\",\n\t[15] = \"Channel Failed-Over Occurred\",\n\t[16] = \"Correctable Non-Mirrored Demand Data ECC\",\n\t \n\t[18] = \"Correctable Resilver- or Spare-Copy Data ECC\",\n\t[19] = \"Correctable Patrol Data ECC\",\n\t[20] = \"FB-DIMM Northbound parity error on FB-DIMM Sync Status\",\n\t[21] = \"SPD protocol Error\",\n\t[22] = \"Non-Redundant Fast Reset Timeout\",\n\t[23] = \"Refresh error\",\n\t[24] = \"Memory Write error on redundant retry\",\n\t[25] = \"Redundant Fast Reset Timeout\",\n\t[26] = \"Correctable Counter Threshold Exceeded\",\n\t[27] = \"DIMM-Spare Copy Completed\",\n\t[28] = \"DIMM-Isolation Completed\",\n};\n\n \n#define ERROR_FAT_MASK\t\t(EMASK_M1 | \\\n\t\t\t\t EMASK_M2 | \\\n\t\t\t\t EMASK_M23)\n\n \n#define ERROR_NF_CORRECTABLE\t(EMASK_M27 | \\\n\t\t\t\t EMASK_M20 | \\\n\t\t\t\t EMASK_M19 | \\\n\t\t\t\t EMASK_M18 | \\\n\t\t\t\t EMASK_M17 | \\\n\t\t\t\t EMASK_M16)\n#define ERROR_NF_DIMM_SPARE\t(EMASK_M29 | \\\n\t\t\t\t EMASK_M28)\n#define ERROR_NF_SPD_PROTOCOL\t(EMASK_M22)\n#define ERROR_NF_NORTH_CRC\t(EMASK_M21)\n\n \n#define ERROR_NF_RECOVERABLE\t(EMASK_M26 | \\\n\t\t\t\t EMASK_M25 | \\\n\t\t\t\t EMASK_M24 | \\\n\t\t\t\t EMASK_M15 | \\\n\t\t\t\t EMASK_M14 | \\\n\t\t\t\t EMASK_M13 | \\\n\t\t\t\t EMASK_M12 | \\\n\t\t\t\t EMASK_M11 | \\\n\t\t\t\t EMASK_M9  | \\\n\t\t\t\t EMASK_M8  | \\\n\t\t\t\t EMASK_M7  | \\\n\t\t\t\t EMASK_M5)\n\n \n#define ERROR_NF_UNCORRECTABLE\t(EMASK_M4)\n\n \n#define ERROR_NF_MASK\t\t(ERROR_NF_CORRECTABLE   | \\\n\t\t\t\t ERROR_NF_UNCORRECTABLE | \\\n\t\t\t\t ERROR_NF_RECOVERABLE   | \\\n\t\t\t\t ERROR_NF_DIMM_SPARE    | \\\n\t\t\t\t ERROR_NF_SPD_PROTOCOL  | \\\n\t\t\t\t ERROR_NF_NORTH_CRC)\n\n \n\n \n#define ENABLE_EMASK_ALL\t(ERROR_FAT_MASK | ERROR_NF_MASK)\n\n \n#define FERR_FAT_MASK ERROR_FAT_MASK\n\n \nstatic inline int to_nf_mask(unsigned int mask)\n{\n\treturn (mask & EMASK_M29) | (mask >> 3);\n};\n\nstatic inline int from_nf_ferr(unsigned int mask)\n{\n\treturn (mask & EMASK_M29) |\t\t \n\t       (mask & ((1 << 28) - 1) << 3);\t \n};\n\n#define FERR_NF_MASK\t\tto_nf_mask(ERROR_NF_MASK)\n#define FERR_NF_CORRECTABLE\tto_nf_mask(ERROR_NF_CORRECTABLE)\n#define FERR_NF_DIMM_SPARE\tto_nf_mask(ERROR_NF_DIMM_SPARE)\n#define FERR_NF_SPD_PROTOCOL\tto_nf_mask(ERROR_NF_SPD_PROTOCOL)\n#define FERR_NF_NORTH_CRC\tto_nf_mask(ERROR_NF_NORTH_CRC)\n#define FERR_NF_RECOVERABLE\tto_nf_mask(ERROR_NF_RECOVERABLE)\n#define FERR_NF_UNCORRECTABLE\tto_nf_mask(ERROR_NF_UNCORRECTABLE)\n\n \n#define MTR_DIMMS_PRESENT(mtr)\t\t((mtr) & (1 << 10))\n#define MTR_DIMMS_ETHROTTLE(mtr)\t((mtr) & (1 << 9))\n#define MTR_DRAM_WIDTH(mtr)\t\t(((mtr) & (1 << 8)) ? 8 : 4)\n#define MTR_DRAM_BANKS(mtr)\t\t(((mtr) & (1 << 6)) ? 8 : 4)\n#define MTR_DRAM_BANKS_ADDR_BITS(mtr)\t((MTR_DRAM_BANKS(mtr) == 8) ? 3 : 2)\n#define MTR_DIMM_RANK(mtr)\t\t(((mtr) >> 5) & 0x1)\n#define MTR_DIMM_RANK_ADDR_BITS(mtr)\t(MTR_DIMM_RANK(mtr) ? 2 : 1)\n#define MTR_DIMM_ROWS(mtr)\t\t(((mtr) >> 2) & 0x3)\n#define MTR_DIMM_ROWS_ADDR_BITS(mtr)\t(MTR_DIMM_ROWS(mtr) + 13)\n#define MTR_DIMM_COLS(mtr)\t\t((mtr) & 0x3)\n#define MTR_DIMM_COLS_ADDR_BITS(mtr)\t(MTR_DIMM_COLS(mtr) + 10)\n\n \nstatic inline int extract_fbdchan_indx(u32 x)\n{\n\treturn (x>>28) & 0x3;\n}\n\n \nstruct i5400_dev_info {\n\tconst char *ctl_name;\t \n\tu16 fsb_mapping_errors;\t \n};\n\n \nstatic const struct i5400_dev_info i5400_devs[] = {\n\t{\n\t\t.ctl_name = \"I5400\",\n\t\t.fsb_mapping_errors = PCI_DEVICE_ID_INTEL_5400_ERR,\n\t},\n};\n\nstruct i5400_dimm_info {\n\tint megabytes;\t\t \n};\n\n \nstruct i5400_pvt {\n\tstruct pci_dev *system_address;\t\t \n\tstruct pci_dev *branchmap_werrors;\t \n\tstruct pci_dev *fsb_error_regs;\t\t \n\tstruct pci_dev *branch_0;\t\t \n\tstruct pci_dev *branch_1;\t\t \n\n\tu16 tolm;\t\t\t\t \n\tunion {\n\t\tu64 ambase;\t\t\t\t \n\t\tstruct {\n\t\t\tu32 ambase_bottom;\n\t\t\tu32 ambase_top;\n\t\t} u __packed;\n\t};\n\n\tu16 mir0, mir1;\n\n\tu16 b0_mtr[DIMMS_PER_CHANNEL];\t \n\tu16 b0_ambpresent0;\t\t\t \n\tu16 b0_ambpresent1;\t\t\t \n\n\tu16 b1_mtr[DIMMS_PER_CHANNEL];\t \n\tu16 b1_ambpresent0;\t\t\t \n\tu16 b1_ambpresent1;\t\t\t \n\n\t \n\tstruct i5400_dimm_info dimm_info[DIMMS_PER_CHANNEL][MAX_CHANNELS];\n\n\t \n\tint maxch;\t\t\t\t \n\tint maxdimmperch;\t\t\t \n};\n\n \nstruct i5400_error_info {\n\t \n\tu32 ferr_fat_fbd;\t \n\tu32 nerr_fat_fbd;\t \n\tu32 ferr_nf_fbd;\t \n\tu32 nerr_nf_fbd;\t \n\n\t \n\tu32 redmemb;\t\t \n\tu16 recmema;\t\t \n\tu32 recmemb;\t\t \n\n\t \n\tu16 nrecmema;\t\t \n\tu32 nrecmemb;\t\t \n\n};\n\n \nstatic inline int nrec_bank(struct i5400_error_info *info)\n{\n\treturn ((info->nrecmema) >> 12) & 0x7;\n}\nstatic inline int nrec_rank(struct i5400_error_info *info)\n{\n\treturn ((info->nrecmema) >> 8) & 0xf;\n}\nstatic inline int nrec_buf_id(struct i5400_error_info *info)\n{\n\treturn ((info->nrecmema)) & 0xff;\n}\nstatic inline int nrec_rdwr(struct i5400_error_info *info)\n{\n\treturn (info->nrecmemb) >> 31;\n}\n \nstatic inline const char *rdwr_str(int rdwr)\n{\n\treturn rdwr ? \"Write\" : \"Read\";\n}\nstatic inline int nrec_cas(struct i5400_error_info *info)\n{\n\treturn ((info->nrecmemb) >> 16) & 0x1fff;\n}\nstatic inline int nrec_ras(struct i5400_error_info *info)\n{\n\treturn (info->nrecmemb) & 0xffff;\n}\nstatic inline int rec_bank(struct i5400_error_info *info)\n{\n\treturn ((info->recmema) >> 12) & 0x7;\n}\nstatic inline int rec_rank(struct i5400_error_info *info)\n{\n\treturn ((info->recmema) >> 8) & 0xf;\n}\nstatic inline int rec_rdwr(struct i5400_error_info *info)\n{\n\treturn (info->recmemb) >> 31;\n}\nstatic inline int rec_cas(struct i5400_error_info *info)\n{\n\treturn ((info->recmemb) >> 16) & 0x1fff;\n}\nstatic inline int rec_ras(struct i5400_error_info *info)\n{\n\treturn (info->recmemb) & 0xffff;\n}\n\nstatic struct edac_pci_ctl_info *i5400_pci;\n\n \nstatic void i5400_get_error_info(struct mem_ctl_info *mci,\n\t\t\t\t struct i5400_error_info *info)\n{\n\tstruct i5400_pvt *pvt;\n\tu32 value;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpci_read_config_dword(pvt->branchmap_werrors, FERR_FAT_FBD, &value);\n\n\t \n\tvalue &= (FERR_FAT_FBDCHAN | FERR_FAT_MASK);\n\n\t \n\tif (value & FERR_FAT_MASK) {\n\t\tinfo->ferr_fat_fbd = value;\n\n\t\t \n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tNERR_FAT_FBD, &info->nerr_fat_fbd);\n\t\tpci_read_config_word(pvt->branchmap_werrors,\n\t\t\t\tNRECMEMA, &info->nrecmema);\n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tNRECMEMB, &info->nrecmemb);\n\n\t\t \n\t\tpci_write_config_dword(pvt->branchmap_werrors,\n\t\t\t\tFERR_FAT_FBD, value);\n\t} else {\n\t\tinfo->ferr_fat_fbd = 0;\n\t\tinfo->nerr_fat_fbd = 0;\n\t\tinfo->nrecmema = 0;\n\t\tinfo->nrecmemb = 0;\n\t}\n\n\t \n\tpci_read_config_dword(pvt->branchmap_werrors, FERR_NF_FBD, &value);\n\n\t \n\tif (value & FERR_NF_MASK) {\n\t\tinfo->ferr_nf_fbd = value;\n\n\t\t \n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tNERR_NF_FBD, &info->nerr_nf_fbd);\n\t\tpci_read_config_word(pvt->branchmap_werrors,\n\t\t\t\tRECMEMA, &info->recmema);\n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tRECMEMB, &info->recmemb);\n\t\tpci_read_config_dword(pvt->branchmap_werrors,\n\t\t\t\tREDMEMB, &info->redmemb);\n\n\t\t \n\t\tpci_write_config_dword(pvt->branchmap_werrors,\n\t\t\t\tFERR_NF_FBD, value);\n\t} else {\n\t\tinfo->ferr_nf_fbd = 0;\n\t\tinfo->nerr_nf_fbd = 0;\n\t\tinfo->recmema = 0;\n\t\tinfo->recmemb = 0;\n\t\tinfo->redmemb = 0;\n\t}\n}\n\n \nstatic void i5400_proccess_non_recoverable_info(struct mem_ctl_info *mci,\n\t\t\t\t    struct i5400_error_info *info,\n\t\t\t\t    unsigned long allErrors)\n{\n\tchar msg[EDAC_MC_LABEL_LEN + 1 + 90 + 80];\n\tint branch;\n\tint channel;\n\tint bank;\n\tint buf_id;\n\tint rank;\n\tint rdwr;\n\tint ras, cas;\n\tint errnum;\n\tchar *type = NULL;\n\tenum hw_event_mc_err_type tp_event = HW_EVENT_ERR_UNCORRECTED;\n\n\tif (!allErrors)\n\t\treturn;\t\t \n\n\tif (allErrors &  ERROR_FAT_MASK) {\n\t\ttype = \"FATAL\";\n\t\ttp_event = HW_EVENT_ERR_FATAL;\n\t} else if (allErrors & FERR_NF_UNCORRECTABLE)\n\t\ttype = \"NON-FATAL uncorrected\";\n\telse\n\t\ttype = \"NON-FATAL recoverable\";\n\n\t \n\n\tbranch = extract_fbdchan_indx(info->ferr_fat_fbd);\n\tchannel = branch;\n\n\t \n\tbank = nrec_bank(info);\n\trank = nrec_rank(info);\n\tbuf_id = nrec_buf_id(info);\n\trdwr = nrec_rdwr(info);\n\tras = nrec_ras(info);\n\tcas = nrec_cas(info);\n\n\tedac_dbg(0, \"\\t\\t%s DIMM= %d  Channels= %d,%d  (Branch= %d DRAM Bank= %d Buffer ID = %d rdwr= %s ras= %d cas= %d)\\n\",\n\t\t type, rank, channel, channel + 1, branch >> 1, bank,\n\t\t buf_id, rdwr_str(rdwr), ras, cas);\n\n\t \n\terrnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));\n\n\t \n\tsnprintf(msg, sizeof(msg),\n\t\t \"Bank=%d Buffer ID = %d RAS=%d CAS=%d Err=0x%lx (%s)\",\n\t\t bank, buf_id, ras, cas, allErrors, error_name[errnum]);\n\n\tedac_mc_handle_error(tp_event, mci, 1, 0, 0, 0,\n\t\t\t     branch >> 1, -1, rank,\n\t\t\t     rdwr ? \"Write error\" : \"Read error\",\n\t\t\t     msg);\n}\n\n \nstatic void i5400_process_nonfatal_error_info(struct mem_ctl_info *mci,\n\t\t\t\t\tstruct i5400_error_info *info)\n{\n\tchar msg[EDAC_MC_LABEL_LEN + 1 + 90 + 80];\n\tunsigned long allErrors;\n\tint branch;\n\tint channel;\n\tint bank;\n\tint rank;\n\tint rdwr;\n\tint ras, cas;\n\tint errnum;\n\n\t \n\tallErrors = from_nf_ferr(info->ferr_nf_fbd & FERR_NF_MASK);\n\tif (!allErrors)\n\t\treturn;\t\t \n\n\t \n\n\tif (allErrors & (ERROR_NF_UNCORRECTABLE | ERROR_NF_RECOVERABLE)) {\n\t\ti5400_proccess_non_recoverable_info(mci, info, allErrors);\n\t\treturn;\n\t}\n\n\t \n\tif (allErrors & ERROR_NF_CORRECTABLE) {\n\t\tedac_dbg(0, \"\\tCorrected bits= 0x%lx\\n\", allErrors);\n\n\t\tbranch = extract_fbdchan_indx(info->ferr_nf_fbd);\n\n\t\tchannel = 0;\n\t\tif (REC_ECC_LOCATOR_ODD(info->redmemb))\n\t\t\tchannel = 1;\n\n\t\t \n\t\tchannel += branch;\n\n\t\tbank = rec_bank(info);\n\t\trank = rec_rank(info);\n\t\trdwr = rec_rdwr(info);\n\t\tras = rec_ras(info);\n\t\tcas = rec_cas(info);\n\n\t\t \n\t\terrnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));\n\n\t\tedac_dbg(0, \"\\t\\tDIMM= %d Channel= %d  (Branch %d DRAM Bank= %d rdwr= %s ras= %d cas= %d)\\n\",\n\t\t\t rank, channel, branch >> 1, bank,\n\t\t\t rdwr_str(rdwr), ras, cas);\n\n\t\t \n\t\tsnprintf(msg, sizeof(msg),\n\t\t\t \"Corrected error (Branch=%d DRAM-Bank=%d RDWR=%s \"\n\t\t\t \"RAS=%d CAS=%d, CE Err=0x%lx (%s))\",\n\t\t\t branch >> 1, bank, rdwr_str(rdwr), ras, cas,\n\t\t\t allErrors, error_name[errnum]);\n\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     branch >> 1, channel % 2, rank,\n\t\t\t\t     rdwr ? \"Write error\" : \"Read error\",\n\t\t\t\t     msg);\n\n\t\treturn;\n\t}\n\n\t \n\terrnum = find_first_bit(&allErrors, ARRAY_SIZE(error_name));\n\n\tbranch = extract_fbdchan_indx(info->ferr_nf_fbd);\n\n\ti5400_mc_printk(mci, KERN_EMERG,\n\t\t\t\"Non-Fatal misc error (Branch=%d Err=%#lx (%s))\",\n\t\t\tbranch >> 1, allErrors, error_name[errnum]);\n}\n\n \nstatic void i5400_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct i5400_error_info *info)\n{\tu32 allErrors;\n\n\t \n\tallErrors = (info->ferr_fat_fbd & FERR_FAT_MASK);\n\ti5400_proccess_non_recoverable_info(mci, info, allErrors);\n\n\t \n\ti5400_process_nonfatal_error_info(mci, info);\n}\n\n \nstatic void i5400_clear_error(struct mem_ctl_info *mci)\n{\n\tstruct i5400_error_info info;\n\n\ti5400_get_error_info(mci, &info);\n}\n\n \nstatic void i5400_check_error(struct mem_ctl_info *mci)\n{\n\tstruct i5400_error_info info;\n\n\ti5400_get_error_info(mci, &info);\n\ti5400_process_error_info(mci, &info);\n}\n\n \nstatic void i5400_put_devices(struct mem_ctl_info *mci)\n{\n\tstruct i5400_pvt *pvt;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpci_dev_put(pvt->branch_1);\n\tpci_dev_put(pvt->branch_0);\n\tpci_dev_put(pvt->fsb_error_regs);\n\tpci_dev_put(pvt->branchmap_werrors);\n}\n\n \nstatic int i5400_get_devices(struct mem_ctl_info *mci, int dev_idx)\n{\n\tstruct i5400_pvt *pvt;\n\tstruct pci_dev *pdev;\n\n\tpvt = mci->pvt_info;\n\tpvt->branchmap_werrors = NULL;\n\tpvt->fsb_error_regs = NULL;\n\tpvt->branch_0 = NULL;\n\tpvt->branch_1 = NULL;\n\n\t \n\tpdev = NULL;\n\twhile (1) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t      PCI_DEVICE_ID_INTEL_5400_ERR, pdev);\n\t\tif (!pdev) {\n\t\t\t \n\t\t\ti5400_printk(KERN_ERR,\n\t\t\t\t\"'system address,Process Bus' \"\n\t\t\t\t\"device not found:\"\n\t\t\t\t\"vendor 0x%x device 0x%x ERR func 1 \"\n\t\t\t\t\"(broken BIOS?)\\n\",\n\t\t\t\tPCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_INTEL_5400_ERR);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tif (PCI_FUNC(pdev->devfn) == 1)\n\t\t\tbreak;\n\t}\n\tpvt->branchmap_werrors = pdev;\n\n\tpdev = NULL;\n\twhile (1) {\n\t\tpdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t      PCI_DEVICE_ID_INTEL_5400_ERR, pdev);\n\t\tif (!pdev) {\n\t\t\t \n\t\t\ti5400_printk(KERN_ERR,\n\t\t\t\t\"'system address,Process Bus' \"\n\t\t\t\t\"device not found:\"\n\t\t\t\t\"vendor 0x%x device 0x%x ERR func 2 \"\n\t\t\t\t\"(broken BIOS?)\\n\",\n\t\t\t\tPCI_VENDOR_ID_INTEL,\n\t\t\t\tPCI_DEVICE_ID_INTEL_5400_ERR);\n\n\t\t\tpci_dev_put(pvt->branchmap_werrors);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tif (PCI_FUNC(pdev->devfn) == 2)\n\t\t\tbreak;\n\t}\n\tpvt->fsb_error_regs = pdev;\n\n\tedac_dbg(1, \"System Address, processor bus- PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->system_address),\n\t\t pvt->system_address->vendor, pvt->system_address->device);\n\tedac_dbg(1, \"Branchmap, control and errors - PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->branchmap_werrors),\n\t\t pvt->branchmap_werrors->vendor,\n\t\t pvt->branchmap_werrors->device);\n\tedac_dbg(1, \"FSB Error Regs - PCI Bus ID: %s  %x:%x\\n\",\n\t\t pci_name(pvt->fsb_error_regs),\n\t\t pvt->fsb_error_regs->vendor, pvt->fsb_error_regs->device);\n\n\tpvt->branch_0 = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t       PCI_DEVICE_ID_INTEL_5400_FBD0, NULL);\n\tif (!pvt->branch_0) {\n\t\ti5400_printk(KERN_ERR,\n\t\t\t\"MC: 'BRANCH 0' device not found:\"\n\t\t\t\"vendor 0x%x device 0x%x Func 0 (broken BIOS?)\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_5400_FBD0);\n\n\t\tpci_dev_put(pvt->fsb_error_regs);\n\t\tpci_dev_put(pvt->branchmap_werrors);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (pvt->maxch < CHANNELS_PER_BRANCH)\n\t\treturn 0;\n\n\tpvt->branch_1 = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t       PCI_DEVICE_ID_INTEL_5400_FBD1, NULL);\n\tif (!pvt->branch_1) {\n\t\ti5400_printk(KERN_ERR,\n\t\t\t\"MC: 'BRANCH 1' device not found:\"\n\t\t\t\"vendor 0x%x device 0x%x Func 0 \"\n\t\t\t\"(broken BIOS?)\\n\",\n\t\t\tPCI_VENDOR_ID_INTEL,\n\t\t\tPCI_DEVICE_ID_INTEL_5400_FBD1);\n\n\t\tpci_dev_put(pvt->branch_0);\n\t\tpci_dev_put(pvt->fsb_error_regs);\n\t\tpci_dev_put(pvt->branchmap_werrors);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int determine_amb_present_reg(struct i5400_pvt *pvt, int channel)\n{\n\tint amb_present;\n\n\tif (channel < CHANNELS_PER_BRANCH) {\n\t\tif (channel & 0x1)\n\t\t\tamb_present = pvt->b0_ambpresent1;\n\t\telse\n\t\t\tamb_present = pvt->b0_ambpresent0;\n\t} else {\n\t\tif (channel & 0x1)\n\t\t\tamb_present = pvt->b1_ambpresent1;\n\t\telse\n\t\t\tamb_present = pvt->b1_ambpresent0;\n\t}\n\n\treturn amb_present;\n}\n\n \nstatic int determine_mtr(struct i5400_pvt *pvt, int dimm, int channel)\n{\n\tint mtr;\n\tint n;\n\n\t \n\tn = dimm;\n\n\tif (n >= DIMMS_PER_CHANNEL) {\n\t\tedac_dbg(0, \"ERROR: trying to access an invalid dimm: %d\\n\",\n\t\t\t dimm);\n\t\treturn 0;\n\t}\n\n\tif (channel < CHANNELS_PER_BRANCH)\n\t\tmtr = pvt->b0_mtr[n];\n\telse\n\t\tmtr = pvt->b1_mtr[n];\n\n\treturn mtr;\n}\n\n \nstatic void decode_mtr(int slot_row, u16 mtr)\n{\n\tint ans;\n\n\tans = MTR_DIMMS_PRESENT(mtr);\n\n\tedac_dbg(2, \"\\tMTR%d=0x%x:  DIMMs are %sPresent\\n\",\n\t\t slot_row, mtr, ans ? \"\" : \"NOT \");\n\tif (!ans)\n\t\treturn;\n\n\tedac_dbg(2, \"\\t\\tWIDTH: x%d\\n\", MTR_DRAM_WIDTH(mtr));\n\n\tedac_dbg(2, \"\\t\\tELECTRICAL THROTTLING is %s\\n\",\n\t\t MTR_DIMMS_ETHROTTLE(mtr) ? \"enabled\" : \"disabled\");\n\n\tedac_dbg(2, \"\\t\\tNUMBANK: %d bank(s)\\n\", MTR_DRAM_BANKS(mtr));\n\tedac_dbg(2, \"\\t\\tNUMRANK: %s\\n\",\n\t\t MTR_DIMM_RANK(mtr) ? \"double\" : \"single\");\n\tedac_dbg(2, \"\\t\\tNUMROW: %s\\n\",\n\t\t MTR_DIMM_ROWS(mtr) == 0 ? \"8,192 - 13 rows\" :\n\t\t MTR_DIMM_ROWS(mtr) == 1 ? \"16,384 - 14 rows\" :\n\t\t MTR_DIMM_ROWS(mtr) == 2 ? \"32,768 - 15 rows\" :\n\t\t \"65,536 - 16 rows\");\n\tedac_dbg(2, \"\\t\\tNUMCOL: %s\\n\",\n\t\t MTR_DIMM_COLS(mtr) == 0 ? \"1,024 - 10 columns\" :\n\t\t MTR_DIMM_COLS(mtr) == 1 ? \"2,048 - 11 columns\" :\n\t\t MTR_DIMM_COLS(mtr) == 2 ? \"4,096 - 12 columns\" :\n\t\t \"reserved\");\n}\n\nstatic void handle_channel(struct i5400_pvt *pvt, int dimm, int channel,\n\t\t\tstruct i5400_dimm_info *dinfo)\n{\n\tint mtr;\n\tint amb_present_reg;\n\tint addrBits;\n\n\tmtr = determine_mtr(pvt, dimm, channel);\n\tif (MTR_DIMMS_PRESENT(mtr)) {\n\t\tamb_present_reg = determine_amb_present_reg(pvt, channel);\n\n\t\t \n\t\tif (amb_present_reg & (1 << dimm)) {\n\t\t\t \n\t\t\taddrBits = MTR_DRAM_BANKS_ADDR_BITS(mtr);\n\t\t\t \n\t\t\taddrBits += MTR_DIMM_ROWS_ADDR_BITS(mtr);\n\t\t\t \n\t\t\taddrBits += MTR_DIMM_COLS_ADDR_BITS(mtr);\n\t\t\t \n\t\t\taddrBits += MTR_DIMM_RANK(mtr);\n\n\t\t\taddrBits += 6;\t \n\t\t\taddrBits -= 20;\t \n\t\t\taddrBits -= 3;\t \n\n\t\t\tdinfo->megabytes = 1 << addrBits;\n\t\t}\n\t}\n}\n\n \nstatic void calculate_dimm_size(struct i5400_pvt *pvt)\n{\n\tstruct i5400_dimm_info *dinfo;\n\tint dimm, max_dimms;\n\tchar *p, *mem_buffer;\n\tint space, n;\n\tint channel, branch;\n\n\t \n\tspace = PAGE_SIZE;\n\tmem_buffer = p = kmalloc(space, GFP_KERNEL);\n\tif (p == NULL) {\n\t\ti5400_printk(KERN_ERR, \"MC: %s:%s() kmalloc() failed\\n\",\n\t\t\t__FILE__, __func__);\n\t\treturn;\n\t}\n\n\t \n\tmax_dimms = pvt->maxdimmperch;\n\tfor (dimm = max_dimms - 1; dimm >= 0; dimm--) {\n\n\t\t \n\t\tif (dimm & 0x1) {\n\t\t\tn = snprintf(p, space, \"---------------------------\"\n\t\t\t\t\t\"-------------------------------\");\n\t\t\tp += n;\n\t\t\tspace -= n;\n\t\t\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\t\t\tp = mem_buffer;\n\t\t\tspace = PAGE_SIZE;\n\t\t}\n\t\tn = snprintf(p, space, \"dimm %2d    \", dimm);\n\t\tp += n;\n\t\tspace -= n;\n\n\t\tfor (channel = 0; channel < pvt->maxch; channel++) {\n\t\t\tdinfo = &pvt->dimm_info[dimm][channel];\n\t\t\thandle_channel(pvt, dimm, channel, dinfo);\n\t\t\tn = snprintf(p, space, \"%4d MB   | \", dinfo->megabytes);\n\t\t\tp += n;\n\t\t\tspace -= n;\n\t\t}\n\t\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\t\tp = mem_buffer;\n\t\tspace = PAGE_SIZE;\n\t}\n\n\t \n\tn = snprintf(p, space, \"---------------------------\"\n\t\t\t\"-------------------------------\");\n\tp += n;\n\tspace -= n;\n\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\tp = mem_buffer;\n\tspace = PAGE_SIZE;\n\n\t \n\tn = snprintf(p, space, \"           \");\n\tp += n;\n\tspace -= n;\n\tfor (channel = 0; channel < pvt->maxch; channel++) {\n\t\tn = snprintf(p, space, \"channel %d | \", channel);\n\t\tp += n;\n\t\tspace -= n;\n\t}\n\n\tspace -= n;\n\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\tp = mem_buffer;\n\tspace = PAGE_SIZE;\n\n\tn = snprintf(p, space, \"           \");\n\tp += n;\n\tfor (branch = 0; branch < MAX_BRANCHES; branch++) {\n\t\tn = snprintf(p, space, \"       branch %d       | \", branch);\n\t\tp += n;\n\t\tspace -= n;\n\t}\n\n\t \n\tedac_dbg(2, \"%s\\n\", mem_buffer);\n\tkfree(mem_buffer);\n}\n\n \nstatic void i5400_get_mc_regs(struct mem_ctl_info *mci)\n{\n\tstruct i5400_pvt *pvt;\n\tu32 actual_tolm;\n\tu16 limit;\n\tint slot_row;\n\tint way0, way1;\n\n\tpvt = mci->pvt_info;\n\n\tpci_read_config_dword(pvt->system_address, AMBASE,\n\t\t\t&pvt->u.ambase_bottom);\n\tpci_read_config_dword(pvt->system_address, AMBASE + sizeof(u32),\n\t\t\t&pvt->u.ambase_top);\n\n\tedac_dbg(2, \"AMBASE= 0x%lx  MAXCH= %d  MAX-DIMM-Per-CH= %d\\n\",\n\t\t (long unsigned int)pvt->ambase, pvt->maxch, pvt->maxdimmperch);\n\n\t \n\tpci_read_config_word(pvt->branchmap_werrors, TOLM, &pvt->tolm);\n\tpvt->tolm >>= 12;\n\tedac_dbg(2, \"\\nTOLM (number of 256M regions) =%u (0x%x)\\n\",\n\t\t pvt->tolm, pvt->tolm);\n\n\tactual_tolm = (u32) ((1000l * pvt->tolm) >> (30 - 28));\n\tedac_dbg(2, \"Actual TOLM byte addr=%u.%03u GB (0x%x)\\n\",\n\t\t actual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);\n\n\tpci_read_config_word(pvt->branchmap_werrors, MIR0, &pvt->mir0);\n\tpci_read_config_word(pvt->branchmap_werrors, MIR1, &pvt->mir1);\n\n\t \n\tlimit = (pvt->mir0 >> 4) & 0x0fff;\n\tway0 = pvt->mir0 & 0x1;\n\tway1 = pvt->mir0 & 0x2;\n\tedac_dbg(2, \"MIR0: limit= 0x%x  WAY1= %u  WAY0= %x\\n\",\n\t\t limit, way1, way0);\n\tlimit = (pvt->mir1 >> 4) & 0xfff;\n\tway0 = pvt->mir1 & 0x1;\n\tway1 = pvt->mir1 & 0x2;\n\tedac_dbg(2, \"MIR1: limit= 0x%x  WAY1= %u  WAY0= %x\\n\",\n\t\t limit, way1, way0);\n\n\t \n\tfor (slot_row = 0; slot_row < DIMMS_PER_CHANNEL; slot_row++) {\n\t\tint where = MTR0 + (slot_row * sizeof(u16));\n\n\t\t \n\t\tpci_read_config_word(pvt->branch_0, where,\n\t\t\t\t&pvt->b0_mtr[slot_row]);\n\n\t\tedac_dbg(2, \"MTR%d where=0x%x B0 value=0x%x\\n\",\n\t\t\t slot_row, where, pvt->b0_mtr[slot_row]);\n\n\t\tif (pvt->maxch < CHANNELS_PER_BRANCH) {\n\t\t\tpvt->b1_mtr[slot_row] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpci_read_config_word(pvt->branch_1, where,\n\t\t\t\t&pvt->b1_mtr[slot_row]);\n\t\tedac_dbg(2, \"MTR%d where=0x%x B1 value=0x%x\\n\",\n\t\t\t slot_row, where, pvt->b1_mtr[slot_row]);\n\t}\n\n\t \n\tedac_dbg(2, \"Memory Technology Registers:\\n\");\n\tedac_dbg(2, \"   Branch 0:\\n\");\n\tfor (slot_row = 0; slot_row < DIMMS_PER_CHANNEL; slot_row++)\n\t\tdecode_mtr(slot_row, pvt->b0_mtr[slot_row]);\n\n\tpci_read_config_word(pvt->branch_0, AMBPRESENT_0,\n\t\t\t&pvt->b0_ambpresent0);\n\tedac_dbg(2, \"\\t\\tAMB-Branch 0-present0 0x%x:\\n\", pvt->b0_ambpresent0);\n\tpci_read_config_word(pvt->branch_0, AMBPRESENT_1,\n\t\t\t&pvt->b0_ambpresent1);\n\tedac_dbg(2, \"\\t\\tAMB-Branch 0-present1 0x%x:\\n\", pvt->b0_ambpresent1);\n\n\t \n\tif (pvt->maxch < CHANNELS_PER_BRANCH) {\n\t\tpvt->b1_ambpresent0 = 0;\n\t\tpvt->b1_ambpresent1 = 0;\n\t} else {\n\t\t \n\t\tedac_dbg(2, \"   Branch 1:\\n\");\n\t\tfor (slot_row = 0; slot_row < DIMMS_PER_CHANNEL; slot_row++)\n\t\t\tdecode_mtr(slot_row, pvt->b1_mtr[slot_row]);\n\n\t\tpci_read_config_word(pvt->branch_1, AMBPRESENT_0,\n\t\t\t\t&pvt->b1_ambpresent0);\n\t\tedac_dbg(2, \"\\t\\tAMB-Branch 1-present0 0x%x:\\n\",\n\t\t\t pvt->b1_ambpresent0);\n\t\tpci_read_config_word(pvt->branch_1, AMBPRESENT_1,\n\t\t\t\t&pvt->b1_ambpresent1);\n\t\tedac_dbg(2, \"\\t\\tAMB-Branch 1-present1 0x%x:\\n\",\n\t\t\t pvt->b1_ambpresent1);\n\t}\n\n\t \n\tcalculate_dimm_size(pvt);\n}\n\n \nstatic int i5400_init_dimms(struct mem_ctl_info *mci)\n{\n\tstruct i5400_pvt *pvt;\n\tstruct dimm_info *dimm;\n\tint ndimms;\n\tint mtr;\n\tint size_mb;\n\tint  channel, slot;\n\n\tpvt = mci->pvt_info;\n\n\tndimms = 0;\n\n\t \n\tfor (channel = 0; channel < mci->layers[0].size * mci->layers[1].size;\n\t     channel++) {\n\t\tfor (slot = 0; slot < mci->layers[2].size; slot++) {\n\t\t\tmtr = determine_mtr(pvt, slot, channel);\n\n\t\t\t \n\t\t\tif (!MTR_DIMMS_PRESENT(mtr))\n\t\t\t\tcontinue;\n\n\t\t\tdimm = edac_get_dimm(mci, channel / 2, channel % 2, slot);\n\n\t\t\tsize_mb =  pvt->dimm_info[slot][channel].megabytes;\n\n\t\t\tedac_dbg(2, \"dimm (branch %d channel %d slot %d): %d.%03d GB\\n\",\n\t\t\t\t channel / 2, channel % 2, slot,\n\t\t\t\t size_mb / 1000, size_mb % 1000);\n\n\t\t\tdimm->nr_pages = size_mb << 8;\n\t\t\tdimm->grain = 8;\n\t\t\tdimm->dtype = MTR_DRAM_WIDTH(mtr) == 8 ?\n\t\t\t\t      DEV_X8 : DEV_X4;\n\t\t\tdimm->mtype = MEM_FB_DDR2;\n\t\t\t \n\t\t\tdimm->edac_mode = MTR_DRAM_WIDTH(mtr) == 8 ?\n\t\t\t\t\t  EDAC_S8ECD8ED : EDAC_S4ECD4ED;\n\t\t\tndimms++;\n\t\t}\n\t}\n\n\t \n\tif (ndimms == 1)\n\t\tmci->dimms[0]->edac_mode = EDAC_SECDED;\n\n\treturn (ndimms == 0);\n}\n\n \nstatic void i5400_enable_error_reporting(struct mem_ctl_info *mci)\n{\n\tstruct i5400_pvt *pvt;\n\tu32 fbd_error_mask;\n\n\tpvt = mci->pvt_info;\n\n\t \n\tpci_read_config_dword(pvt->branchmap_werrors, EMASK_FBD,\n\t\t\t&fbd_error_mask);\n\n\t \n\tfbd_error_mask &= ~(ENABLE_EMASK_ALL);\n\n\tpci_write_config_dword(pvt->branchmap_werrors, EMASK_FBD,\n\t\t\tfbd_error_mask);\n}\n\n \nstatic int i5400_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct i5400_pvt *pvt;\n\tstruct edac_mc_layer layers[3];\n\n\tif (dev_idx >= ARRAY_SIZE(i5400_devs))\n\t\treturn -EINVAL;\n\n\tedac_dbg(0, \"MC: pdev bus %u dev=0x%x fn=0x%x\\n\",\n\t\t pdev->bus->number,\n\t\t PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\n\n\t \n\tif (PCI_FUNC(pdev->devfn) != 0)\n\t\treturn -ENODEV;\n\n\t \n\tlayers[0].type = EDAC_MC_LAYER_BRANCH;\n\tlayers[0].size = MAX_BRANCHES;\n\tlayers[0].is_virt_csrow = false;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = CHANNELS_PER_BRANCH;\n\tlayers[1].is_virt_csrow = false;\n\tlayers[2].type = EDAC_MC_LAYER_SLOT;\n\tlayers[2].size = DIMMS_PER_CHANNEL;\n\tlayers[2].is_virt_csrow = true;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\n\tif (mci == NULL)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(0, \"MC: mci = %p\\n\", mci);\n\n\tmci->pdev = &pdev->dev;\t \n\n\tpvt = mci->pvt_info;\n\tpvt->system_address = pdev;\t \n\tpvt->maxch = MAX_CHANNELS;\n\tpvt->maxdimmperch = DIMMS_PER_CHANNEL;\n\n\t \n\tif (i5400_get_devices(mci, dev_idx))\n\t\tgoto fail0;\n\n\t \n\ti5400_get_mc_regs(mci);\t \n\n\tmci->mc_idx = 0;\n\tmci->mtype_cap = MEM_FLAG_FB_DDR2;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE;\n\tmci->edac_cap = EDAC_FLAG_NONE;\n\tmci->mod_name = \"i5400_edac.c\";\n\tmci->ctl_name = i5400_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->ctl_page_to_phys = NULL;\n\n\t \n\tmci->edac_check = i5400_check_error;\n\n\t \n\tif (i5400_init_dimms(mci)) {\n\t\tedac_dbg(0, \"MC: Setting mci->edac_cap to EDAC_FLAG_NONE because i5400_init_dimms() returned nonzero value\\n\");\n\t\tmci->edac_cap = EDAC_FLAG_NONE;\t \n\t} else {\n\t\tedac_dbg(1, \"MC: Enable error reporting now\\n\");\n\t\ti5400_enable_error_reporting(mci);\n\t}\n\n\t \n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(0, \"MC: failed edac_mc_add_mc()\\n\");\n\t\t \n\t\tgoto fail1;\n\t}\n\n\ti5400_clear_error(mci);\n\n\t \n\ti5400_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\n\tif (!i5400_pci) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): Unable to create PCI control\\n\",\n\t\t\t__func__);\n\t\tprintk(KERN_WARNING\n\t\t\t\"%s(): PCI error report via EDAC not setup\\n\",\n\t\t\t__func__);\n\t}\n\n\treturn 0;\n\n\t \nfail1:\n\n\ti5400_put_devices(mci);\n\nfail0:\n\tedac_mc_free(mci);\n\treturn -ENODEV;\n}\n\n \nstatic int i5400_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint rc;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn i5400_probe1(pdev, id->driver_data);\n}\n\n \nstatic void i5400_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (i5400_pci)\n\t\tedac_pci_release_generic_ctl(i5400_pci);\n\n\tmci = edac_mc_del_mc(&pdev->dev);\n\tif (!mci)\n\t\treturn;\n\n\t \n\ti5400_put_devices(mci);\n\n\tpci_disable_device(pdev);\n\n\tedac_mc_free(mci);\n}\n\n \nstatic const struct pci_device_id i5400_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_5400_ERR)},\n\t{0,}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, i5400_pci_tbl);\n\n \nstatic struct pci_driver i5400_driver = {\n\t.name = \"i5400_edac\",\n\t.probe = i5400_init_one,\n\t.remove = i5400_remove_one,\n\t.id_table = i5400_pci_tbl,\n};\n\n \nstatic int __init i5400_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(2, \"MC:\\n\");\n\n\t \n\topstate_init();\n\n\tpci_rc = pci_register_driver(&i5400_driver);\n\n\treturn (pci_rc < 0) ? pci_rc : 0;\n}\n\n \nstatic void __exit i5400_exit(void)\n{\n\tedac_dbg(2, \"MC:\\n\");\n\tpci_unregister_driver(&i5400_driver);\n}\n\nmodule_init(i5400_init);\nmodule_exit(i5400_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ben Woodard <woodard@redhat.com>\");\nMODULE_AUTHOR(\"Mauro Carvalho Chehab\");\nMODULE_AUTHOR(\"Red Hat Inc. (https://www.redhat.com)\");\nMODULE_DESCRIPTION(\"MC Driver for Intel I5400 memory controllers - \"\n\t\t   I5400_REVISION);\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}