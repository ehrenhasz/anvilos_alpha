{
  "module_name": "amd64_edac.h",
  "hash_id": "26824bfd1de88da7d642df87020d8dba7b44a10672ecad00be1a49e0e94111fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/amd64_edac.h",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/slab.h>\n#include <linux/mmzone.h>\n#include <linux/edac.h>\n#include <linux/bitfield.h>\n#include <asm/cpu_device_id.h>\n#include <asm/msr.h>\n#include \"edac_module.h\"\n#include \"mce_amd.h\"\n\n#define amd64_info(fmt, arg...) \\\n\tedac_printk(KERN_INFO, \"amd64\", fmt, ##arg)\n\n#define amd64_warn(fmt, arg...) \\\n\tedac_printk(KERN_WARNING, \"amd64\", \"Warning: \" fmt, ##arg)\n\n#define amd64_err(fmt, arg...) \\\n\tedac_printk(KERN_ERR, \"amd64\", \"Error: \" fmt, ##arg)\n\n#define amd64_mc_warn(mci, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, KERN_WARNING, \"amd64\", fmt, ##arg)\n\n#define amd64_mc_err(mci, fmt, arg...) \\\n\tedac_mc_chipset_printk(mci, KERN_ERR, \"amd64\", fmt, ##arg)\n\n \n\n#define EDAC_MOD_STR\t\t\t\"amd64_edac\"\n\n \n#define K8_REV_D\t\t\t1\n#define K8_REV_E\t\t\t2\n#define K8_REV_F\t\t\t4\n\n \n#define NUM_CHIPSELECTS\t\t\t8\n#define DRAM_RANGES\t\t\t8\n#define NUM_CONTROLLERS\t\t\t12\n\n#define ON true\n#define OFF false\n\n \n#define PCI_DEVICE_ID_AMD_15H_NB_F1\t0x1601\n#define PCI_DEVICE_ID_AMD_15H_NB_F2\t0x1602\n#define PCI_DEVICE_ID_AMD_15H_M30H_NB_F1 0x141b\n#define PCI_DEVICE_ID_AMD_15H_M30H_NB_F2 0x141c\n#define PCI_DEVICE_ID_AMD_15H_M60H_NB_F1 0x1571\n#define PCI_DEVICE_ID_AMD_15H_M60H_NB_F2 0x1572\n#define PCI_DEVICE_ID_AMD_16H_NB_F1\t0x1531\n#define PCI_DEVICE_ID_AMD_16H_NB_F2\t0x1532\n#define PCI_DEVICE_ID_AMD_16H_M30H_NB_F1 0x1581\n#define PCI_DEVICE_ID_AMD_16H_M30H_NB_F2 0x1582\n\n \n#define DRAM_BASE_LO\t\t\t0x40\n#define DRAM_LIMIT_LO\t\t\t0x44\n\n \n#define DRAM_CONT_BASE\t\t\t0x200\n#define DRAM_CONT_LIMIT\t\t\t0x204\n\n \n#define DRAM_CONT_HIGH_OFF\t\t0x240\n\n#define dram_rw(pvt, i)\t\t\t((u8)(pvt->ranges[i].base.lo & 0x3))\n#define dram_intlv_sel(pvt, i)\t\t((u8)((pvt->ranges[i].lim.lo >> 8) & 0x7))\n#define dram_dst_node(pvt, i)\t\t((u8)(pvt->ranges[i].lim.lo & 0x7))\n\n#define DHAR\t\t\t\t0xf0\n#define dhar_mem_hoist_valid(pvt)\t((pvt)->dhar & BIT(1))\n#define dhar_base(pvt)\t\t\t((pvt)->dhar & 0xff000000)\n#define k8_dhar_offset(pvt)\t\t(((pvt)->dhar & 0x0000ff00) << 16)\n\n\t\t\t\t\t \n#define f10_dhar_offset(pvt)\t\t(((pvt)->dhar & 0x0000ff80) << 16)\n\n#define DCT_CFG_SEL\t\t\t0x10C\n\n#define DRAM_LOCAL_NODE_BASE\t\t0x120\n#define DRAM_LOCAL_NODE_LIM\t\t0x124\n\n#define DRAM_BASE_HI\t\t\t0x140\n#define DRAM_LIMIT_HI\t\t\t0x144\n\n\n \n#define DCSB0\t\t\t\t0x40\n#define DCSB1\t\t\t\t0x140\n#define DCSB_CS_ENABLE\t\t\tBIT(0)\n\n#define DCSM0\t\t\t\t0x60\n#define DCSM1\t\t\t\t0x160\n\n#define csrow_enabled(i, dct, pvt)\t((pvt)->csels[(dct)].csbases[(i)]     & DCSB_CS_ENABLE)\n#define csrow_sec_enabled(i, dct, pvt)\t((pvt)->csels[(dct)].csbases_sec[(i)] & DCSB_CS_ENABLE)\n\n#define DRAM_CONTROL\t\t\t0x78\n\n#define DBAM0\t\t\t\t0x80\n#define DBAM1\t\t\t\t0x180\n\n \n#define DBAM_DIMM(i, reg)\t\t((((reg) >> (4*(i)))) & 0xF)\n\n#define DBAM_MAX_VALUE\t\t\t11\n\n#define DCLR0\t\t\t\t0x90\n#define DCLR1\t\t\t\t0x190\n#define REVE_WIDTH_128\t\t\tBIT(16)\n#define WIDTH_128\t\t\tBIT(11)\n\n#define DCHR0\t\t\t\t0x94\n#define DCHR1\t\t\t\t0x194\n#define DDR3_MODE\t\t\tBIT(8)\n\n#define DCT_SEL_LO\t\t\t0x110\n#define dct_high_range_enabled(pvt)\t((pvt)->dct_sel_lo & BIT(0))\n#define dct_interleave_enabled(pvt)\t((pvt)->dct_sel_lo & BIT(2))\n\n#define dct_ganging_enabled(pvt)\t((boot_cpu_data.x86 == 0x10) && ((pvt)->dct_sel_lo & BIT(4)))\n\n#define dct_data_intlv_enabled(pvt)\t((pvt)->dct_sel_lo & BIT(5))\n#define dct_memory_cleared(pvt)\t\t((pvt)->dct_sel_lo & BIT(10))\n\n#define SWAP_INTLV_REG\t\t\t0x10c\n\n#define DCT_SEL_HI\t\t\t0x114\n\n#define F15H_M60H_SCRCTRL\t\t0x1C8\n\n \n#define NBCTL\t\t\t\t0x40\n\n#define NBCFG\t\t\t\t0x44\n#define NBCFG_CHIPKILL\t\t\tBIT(23)\n#define NBCFG_ECC_ENABLE\t\tBIT(22)\n\n \n#define F10_NBSL_EXT_ERR_ECC\t\t0x8\n#define NBSL_PP_OBS\t\t\t0x2\n\n#define SCRCTRL\t\t\t\t0x58\n\n#define F10_ONLINE_SPARE\t\t0xB0\n#define online_spare_swap_done(pvt, c)\t(((pvt)->online_spare >> (1 + 2 * (c))) & 0x1)\n#define online_spare_bad_dramcs(pvt, c)\t(((pvt)->online_spare >> (4 + 4 * (c))) & 0x7)\n\n#define F10_NB_ARRAY_ADDR\t\t0xB8\n#define F10_NB_ARRAY_DRAM\t\tBIT(31)\n\n \n#define SET_NB_ARRAY_ADDR(section)\t(((section) & 0x3) << 1)\n\n#define F10_NB_ARRAY_DATA\t\t0xBC\n#define F10_NB_ARR_ECC_WR_REQ\t\tBIT(17)\n#define SET_NB_DRAM_INJECTION_WRITE(inj)  \\\n\t\t\t\t\t(BIT(((inj.word) & 0xF) + 20) | \\\n\t\t\t\t\tF10_NB_ARR_ECC_WR_REQ | inj.bit_map)\n#define SET_NB_DRAM_INJECTION_READ(inj)  \\\n\t\t\t\t\t(BIT(((inj.word) & 0xF) + 20) | \\\n\t\t\t\t\tBIT(16) |  inj.bit_map)\n\n\n#define NBCAP\t\t\t\t0xE8\n#define NBCAP_CHIPKILL\t\t\tBIT(4)\n#define NBCAP_SECDED\t\t\tBIT(3)\n#define NBCAP_DCT_DUAL\t\t\tBIT(0)\n\n#define EXT_NB_MCA_CFG\t\t\t0x180\n\n \n#define MSR_MCGCTL_NBE\t\t\tBIT(4)\n\n \n\n \n#define DF_DHAR\t\t\t\t0x104\n\n \n#define UMCCH_BASE_ADDR\t\t\t0x0\n#define UMCCH_BASE_ADDR_SEC\t\t0x10\n#define UMCCH_ADDR_MASK\t\t\t0x20\n#define UMCCH_ADDR_MASK_SEC\t\t0x28\n#define UMCCH_ADDR_MASK_SEC_DDR5\t0x30\n#define UMCCH_ADDR_CFG\t\t\t0x30\n#define UMCCH_ADDR_CFG_DDR5\t\t0x40\n#define UMCCH_DIMM_CFG\t\t\t0x80\n#define UMCCH_DIMM_CFG_DDR5\t\t0x90\n#define UMCCH_UMC_CFG\t\t\t0x100\n#define UMCCH_SDP_CTRL\t\t\t0x104\n#define UMCCH_ECC_CTRL\t\t\t0x14C\n#define UMCCH_ECC_BAD_SYMBOL\t\t0xD90\n#define UMCCH_UMC_CAP\t\t\t0xDF0\n#define UMCCH_UMC_CAP_HI\t\t0xDF4\n\n \n#define UMC_ECC_CHIPKILL_CAP\t\tBIT(31)\n#define UMC_ECC_ENABLED\t\t\tBIT(30)\n\n#define UMC_SDP_INIT\t\t\tBIT(31)\n\n \nstruct error_injection {\n\tu32\t section;\n\tu32\t word;\n\tu32\t bit_map;\n};\n\n \nstruct reg_pair {\n\tu32 lo, hi;\n};\n\n \nstruct dram_range {\n\tstruct reg_pair base;\n\tstruct reg_pair lim;\n};\n\n \nstruct chip_select {\n\tu32 csbases[NUM_CHIPSELECTS];\n\tu32 csbases_sec[NUM_CHIPSELECTS];\n\tu8 b_cnt;\n\n\tu32 csmasks[NUM_CHIPSELECTS];\n\tu32 csmasks_sec[NUM_CHIPSELECTS];\n\tu8 m_cnt;\n};\n\nstruct amd64_umc {\n\tu32 dimm_cfg;\t\t \n\tu32 umc_cfg;\t\t \n\tu32 sdp_ctrl;\t\t \n\tu32 ecc_ctrl;\t\t \n\tu32 umc_cap_hi;\t\t \n\n\t \n\tenum mem_type dram_type;\n};\n\nstruct amd64_family_flags {\n\t \n\t__u64 zn_regs_v2\t: 1,\n\n\t      __reserved\t: 63;\n};\n\nstruct amd64_pvt {\n\tstruct low_ops *ops;\n\n\t \n\tstruct pci_dev *F1, *F2, *F3;\n\n\tu16 mc_node_id;\t\t \n\tu8 fam;\t\t\t \n\tu8 model;\t\t \n\tu8 stepping;\t\t \n\n\tint ext_model;\t\t \n\n\t \n\tu32 dclr0;\t\t \n\tu32 dclr1;\t\t \n\tu32 dchr0;\t\t \n\tu32 dchr1;\t\t \n\tu32 nbcap;\t\t \n\tu32 nbcfg;\t\t \n\tu32 ext_nbcfg;\t\t \n\tu32 dhar;\t\t \n\tu32 dbam0;\t\t \n\tu32 dbam1;\t\t \n\n\t \n\tstruct chip_select csels[NUM_CONTROLLERS];\n\n\t \n\tstruct dram_range ranges[DRAM_RANGES];\n\n\tu64 top_mem;\t\t \n\tu64 top_mem2;\t\t \n\n\tu32 dct_sel_lo;\t\t \n\tu32 dct_sel_hi;\t\t \n\tu32 online_spare;\t \n\n\t \n\tu8 ecc_sym_sz;\n\n\tconst char *ctl_name;\n\tu16 f1_id, f2_id;\n\t \n\tu8 max_mcs;\n\n\tstruct amd64_family_flags flags;\n\t \n\tstruct error_injection injection;\n\n\t \n\tenum mem_type dram_type;\n\n\tstruct amd64_umc *umc;\t \n};\n\nenum err_codes {\n\tDECODE_OK\t=  0,\n\tERR_NODE\t= -1,\n\tERR_CSROW\t= -2,\n\tERR_CHANNEL\t= -3,\n\tERR_SYND\t= -4,\n\tERR_NORM_ADDR\t= -5,\n};\n\nstruct err_info {\n\tint err_code;\n\tstruct mem_ctl_info *src_mci;\n\tint csrow;\n\tint channel;\n\tu16 syndrome;\n\tu32 page;\n\tu32 offset;\n};\n\nstatic inline u32 get_umc_base(u8 channel)\n{\n\t \n\treturn 0x50000 + (channel << 20);\n}\n\nstatic inline u64 get_dram_base(struct amd64_pvt *pvt, u8 i)\n{\n\tu64 addr = ((u64)pvt->ranges[i].base.lo & 0xffff0000) << 8;\n\n\tif (boot_cpu_data.x86 == 0xf)\n\t\treturn addr;\n\n\treturn (((u64)pvt->ranges[i].base.hi & 0x000000ff) << 40) | addr;\n}\n\nstatic inline u64 get_dram_limit(struct amd64_pvt *pvt, u8 i)\n{\n\tu64 lim = (((u64)pvt->ranges[i].lim.lo & 0xffff0000) << 8) | 0x00ffffff;\n\n\tif (boot_cpu_data.x86 == 0xf)\n\t\treturn lim;\n\n\treturn (((u64)pvt->ranges[i].lim.hi & 0x000000ff) << 40) | lim;\n}\n\nstatic inline u16 extract_syndrome(u64 status)\n{\n\treturn ((status >> 47) & 0xff) | ((status >> 16) & 0xff00);\n}\n\nstatic inline u8 dct_sel_interleave_addr(struct amd64_pvt *pvt)\n{\n\tif (pvt->fam == 0x15 && pvt->model >= 0x30)\n\t\treturn (((pvt->dct_sel_hi >> 9) & 0x1) << 2) |\n\t\t\t((pvt->dct_sel_lo >> 6) & 0x3);\n\n\treturn\t((pvt)->dct_sel_lo >> 6) & 0x3;\n}\n \nstruct ecc_settings {\n\tu32 old_nbctl;\n\tbool nbctl_valid;\n\n\tstruct flags {\n\t\tunsigned long nb_mce_enable:1;\n\t\tunsigned long nb_ecc_prev:1;\n\t} flags;\n};\n\n \nstruct low_ops {\n\tvoid (*map_sysaddr_to_csrow)(struct mem_ctl_info *mci, u64 sys_addr,\n\t\t\t\t     struct err_info *err);\n\tint  (*dbam_to_cs)(struct amd64_pvt *pvt, u8 dct,\n\t\t\t   unsigned int cs_mode, int cs_mask_nr);\n\tint (*hw_info_get)(struct amd64_pvt *pvt);\n\tbool (*ecc_enabled)(struct amd64_pvt *pvt);\n\tvoid (*setup_mci_misc_attrs)(struct mem_ctl_info *mci);\n\tvoid (*dump_misc_regs)(struct amd64_pvt *pvt);\n\tvoid (*get_err_info)(struct mce *m, struct err_info *err);\n};\n\nint __amd64_read_pci_cfg_dword(struct pci_dev *pdev, int offset,\n\t\t\t       u32 *val, const char *func);\nint __amd64_write_pci_cfg_dword(struct pci_dev *pdev, int offset,\n\t\t\t\tu32 val, const char *func);\n\n#define amd64_read_pci_cfg(pdev, offset, val)\t\\\n\t__amd64_read_pci_cfg_dword(pdev, offset, val, __func__)\n\n#define amd64_write_pci_cfg(pdev, offset, val)\t\\\n\t__amd64_write_pci_cfg_dword(pdev, offset, val, __func__)\n\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\n\n \nstatic inline void disable_caches(void *dummy)\n{\n\twrite_cr0(read_cr0() | X86_CR0_CD);\n\twbinvd();\n}\n\nstatic inline void enable_caches(void *dummy)\n{\n\twrite_cr0(read_cr0() & ~X86_CR0_CD);\n}\n\nstatic inline u8 dram_intlv_en(struct amd64_pvt *pvt, unsigned int i)\n{\n\tif (pvt->fam == 0x15 && pvt->model >= 0x30) {\n\t\tu32 tmp;\n\t\tamd64_read_pci_cfg(pvt->F1, DRAM_CONT_LIMIT, &tmp);\n\t\treturn (u8) tmp & 0xF;\n\t}\n\treturn (u8) (pvt->ranges[i].base.lo >> 8) & 0x7;\n}\n\nstatic inline u8 dhar_valid(struct amd64_pvt *pvt)\n{\n\tif (pvt->fam == 0x15 && pvt->model >= 0x30) {\n\t\tu32 tmp;\n\t\tamd64_read_pci_cfg(pvt->F1, DRAM_CONT_BASE, &tmp);\n\t\treturn (tmp >> 1) & BIT(0);\n\t}\n\treturn (pvt)->dhar & BIT(0);\n}\n\nstatic inline u32 dct_sel_baseaddr(struct amd64_pvt *pvt)\n{\n\tif (pvt->fam == 0x15 && pvt->model >= 0x30) {\n\t\tu32 tmp;\n\t\tamd64_read_pci_cfg(pvt->F1, DRAM_CONT_BASE, &tmp);\n\t\treturn (tmp >> 11) & 0x1FFF;\n\t}\n\treturn (pvt)->dct_sel_lo & 0xFFFFF800;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}