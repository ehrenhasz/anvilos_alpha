{
  "module_name": "mpc85xx_edac.c",
  "hash_id": "9c45b9dbecda22b05d584d382325c267746a89270b8b8145942ce537b4783938",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/mpc85xx_edac.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/edac.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/fsl/edac.h>\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include \"edac_module.h\"\n#include \"mpc85xx_edac.h\"\n#include \"fsl_ddr_edac.h\"\n\nstatic int edac_dev_idx;\n#ifdef CONFIG_PCI\nstatic int edac_pci_idx;\n#endif\n\n \n#ifdef CONFIG_PCI\nstatic u32 orig_pci_err_cap_dr;\nstatic u32 orig_pci_err_en;\n#endif\n\nstatic u32 orig_l2_err_disable;\n\n \n#ifdef CONFIG_PCI\n\nstatic void mpc85xx_pci_check(struct edac_pci_ctl_info *pci)\n{\n\tstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\n\tu32 err_detect;\n\n\terr_detect = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR);\n\n\t \n\tif (!(err_detect & ~(PCI_EDE_MULTI_ERR | PCI_EDE_MST_ABRT))) {\n\t\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, err_detect);\n\t\treturn;\n\t}\n\n\tpr_err(\"PCI error(s) detected\\n\");\n\tpr_err(\"PCI/X ERR_DR register: %#08x\\n\", err_detect);\n\n\tpr_err(\"PCI/X ERR_ATTRIB register: %#08x\\n\",\n\t       in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ATTRIB));\n\tpr_err(\"PCI/X ERR_ADDR register: %#08x\\n\",\n\t       in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR));\n\tpr_err(\"PCI/X ERR_EXT_ADDR register: %#08x\\n\",\n\t       in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EXT_ADDR));\n\tpr_err(\"PCI/X ERR_DL register: %#08x\\n\",\n\t       in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DL));\n\tpr_err(\"PCI/X ERR_DH register: %#08x\\n\",\n\t       in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DH));\n\n\t \n\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, err_detect);\n\n\tif (err_detect & PCI_EDE_PERR_MASK)\n\t\tedac_pci_handle_pe(pci, pci->ctl_name);\n\n\tif ((err_detect & ~PCI_EDE_MULTI_ERR) & ~PCI_EDE_PERR_MASK)\n\t\tedac_pci_handle_npe(pci, pci->ctl_name);\n}\n\nstatic void mpc85xx_pcie_check(struct edac_pci_ctl_info *pci)\n{\n\tstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\n\tu32 err_detect, err_cap_stat;\n\n\terr_detect = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR);\n\terr_cap_stat = in_be32(pdata->pci_vbase + MPC85XX_PCI_GAS_TIMR);\n\n\tpr_err(\"PCIe error(s) detected\\n\");\n\tpr_err(\"PCIe ERR_DR register: 0x%08x\\n\", err_detect);\n\tpr_err(\"PCIe ERR_CAP_STAT register: 0x%08x\\n\", err_cap_stat);\n\tpr_err(\"PCIe ERR_CAP_R0 register: 0x%08x\\n\",\n\t\t\tin_be32(pdata->pci_vbase + MPC85XX_PCIE_ERR_CAP_R0));\n\tpr_err(\"PCIe ERR_CAP_R1 register: 0x%08x\\n\",\n\t\t\tin_be32(pdata->pci_vbase + MPC85XX_PCIE_ERR_CAP_R1));\n\tpr_err(\"PCIe ERR_CAP_R2 register: 0x%08x\\n\",\n\t\t\tin_be32(pdata->pci_vbase + MPC85XX_PCIE_ERR_CAP_R2));\n\tpr_err(\"PCIe ERR_CAP_R3 register: 0x%08x\\n\",\n\t\t\tin_be32(pdata->pci_vbase + MPC85XX_PCIE_ERR_CAP_R3));\n\n\t \n\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, err_detect);\n\n\t \n\tout_be32(pdata->pci_vbase + MPC85XX_PCI_GAS_TIMR, err_cap_stat | 0x1);\n}\n\nstatic int mpc85xx_pcie_find_capability(struct device_node *np)\n{\n\tstruct pci_controller *hose;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\those = pci_find_hose_for_OF_device(np);\n\n\treturn early_find_capability(hose, 0, 0, PCI_CAP_ID_EXP);\n}\n\nstatic irqreturn_t mpc85xx_pci_isr(int irq, void *dev_id)\n{\n\tstruct edac_pci_ctl_info *pci = dev_id;\n\tstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\n\tu32 err_detect;\n\n\terr_detect = in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR);\n\n\tif (!err_detect)\n\t\treturn IRQ_NONE;\n\n\tif (pdata->is_pcie)\n\t\tmpc85xx_pcie_check(pci);\n\telse\n\t\tmpc85xx_pci_check(pci);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mpc85xx_pci_err_probe(struct platform_device *op)\n{\n\tstruct edac_pci_ctl_info *pci;\n\tstruct mpc85xx_pci_pdata *pdata;\n\tstruct mpc85xx_edac_pci_plat_data *plat_data;\n\tstruct device_node *of_node;\n\tstruct resource r;\n\tint res = 0;\n\n\tif (!devres_open_group(&op->dev, mpc85xx_pci_err_probe, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tpci = edac_pci_alloc_ctl_info(sizeof(*pdata), \"mpc85xx_pci_err\");\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (edac_op_state) {\n\tcase EDAC_OPSTATE_POLL:\n\tcase EDAC_OPSTATE_INT:\n\t\tbreak;\n\tdefault:\n\t\tedac_op_state = EDAC_OPSTATE_INT;\n\t\tbreak;\n\t}\n\n\tpdata = pci->pvt_info;\n\tpdata->name = \"mpc85xx_pci_err\";\n\n\tplat_data = op->dev.platform_data;\n\tif (!plat_data) {\n\t\tdev_err(&op->dev, \"no platform data\");\n\t\tres = -ENXIO;\n\t\tgoto err;\n\t}\n\tof_node = plat_data->of_node;\n\n\tif (mpc85xx_pcie_find_capability(of_node) > 0)\n\t\tpdata->is_pcie = true;\n\n\tdev_set_drvdata(&op->dev, pci);\n\tpci->dev = &op->dev;\n\tpci->mod_name = EDAC_MOD_STR;\n\tpci->ctl_name = pdata->name;\n\tpci->dev_name = dev_name(&op->dev);\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL) {\n\t\tif (pdata->is_pcie)\n\t\t\tpci->edac_check = mpc85xx_pcie_check;\n\t\telse\n\t\t\tpci->edac_check = mpc85xx_pci_check;\n\t}\n\n\tpdata->edac_idx = edac_pci_idx++;\n\n\tres = of_address_to_resource(of_node, 0, &r);\n\tif (res) {\n\t\tpr_err(\"%s: Unable to get resource for PCI err regs\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\t \n\tr.start += 0xe00;\n\n\tif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\n\t\t\t\t\tpdata->name)) {\n\t\tpr_err(\"%s: Error while requesting mem region\\n\", __func__);\n\t\tres = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tpdata->pci_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\n\tif (!pdata->pci_vbase) {\n\t\tpr_err(\"%s: Unable to setup PCI err regs\\n\", __func__);\n\t\tres = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tif (pdata->is_pcie) {\n\t\torig_pci_err_cap_dr =\n\t\t    in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR);\n\t\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR, ~0);\n\t\torig_pci_err_en =\n\t\t    in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN);\n\t\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, 0);\n\t} else {\n\t\torig_pci_err_cap_dr =\n\t\t    in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_CAP_DR);\n\n\t\t \n\t\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_CAP_DR, 0x40);\n\n\t\torig_pci_err_en =\n\t\t    in_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN);\n\n\t\t \n\t\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, ~0x40);\n\t}\n\n\t \n\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_DR, ~0);\n\n\t \n\tout_be32(pdata->pci_vbase + MPC85XX_PCI_GAS_TIMR, 0x1);\n\n\tif (edac_pci_add_device(pci, pdata->edac_idx) > 0) {\n\t\tedac_dbg(3, \"failed edac_pci_add_device()\\n\");\n\t\tgoto err;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_INT) {\n\t\tpdata->irq = irq_of_parse_and_map(of_node, 0);\n\t\tres = devm_request_irq(&op->dev, pdata->irq,\n\t\t\t\t       mpc85xx_pci_isr,\n\t\t\t\t       IRQF_SHARED,\n\t\t\t\t       \"[EDAC] PCI err\", pci);\n\t\tif (res < 0) {\n\t\t\tpr_err(\"%s: Unable to request irq %d for MPC85xx PCI err\\n\",\n\t\t\t\t__func__, pdata->irq);\n\t\t\tirq_dispose_mapping(pdata->irq);\n\t\t\tres = -ENODEV;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tpr_info(EDAC_MOD_STR \" acquired irq %d for PCI Err\\n\",\n\t\t       pdata->irq);\n\t}\n\n\tif (pdata->is_pcie) {\n\t\t \n\t\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, ~0\n\t\t\t & ~PEX_ERR_ICCAIE_EN_BIT);\n\t\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR, 0\n\t\t\t | PEX_ERR_ICCAD_DISR_BIT);\n\t}\n\n\tdevres_remove_group(&op->dev, mpc85xx_pci_err_probe);\n\tedac_dbg(3, \"success\\n\");\n\tpr_info(EDAC_MOD_STR \" PCI err registered\\n\");\n\n\treturn 0;\n\nerr2:\n\tedac_pci_del_device(&op->dev);\nerr:\n\tedac_pci_free_ctl_info(pci);\n\tdevres_release_group(&op->dev, mpc85xx_pci_err_probe);\n\treturn res;\n}\n\nstatic int mpc85xx_pci_err_remove(struct platform_device *op)\n{\n\tstruct edac_pci_ctl_info *pci = dev_get_drvdata(&op->dev);\n\tstruct mpc85xx_pci_pdata *pdata = pci->pvt_info;\n\n\tedac_dbg(0, \"\\n\");\n\n\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_ADDR, orig_pci_err_cap_dr);\n\tout_be32(pdata->pci_vbase + MPC85XX_PCI_ERR_EN, orig_pci_err_en);\n\n\tedac_pci_del_device(&op->dev);\n\tedac_pci_free_ctl_info(pci);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id mpc85xx_pci_err_match[] = {\n\t{\n\t\t.name = \"mpc85xx-pci-edac\"\n\t},\n\t{}\n};\n\nstatic struct platform_driver mpc85xx_pci_err_driver = {\n\t.probe = mpc85xx_pci_err_probe,\n\t.remove = mpc85xx_pci_err_remove,\n\t.id_table = mpc85xx_pci_err_match,\n\t.driver = {\n\t\t.name = \"mpc85xx_pci_err\",\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n#endif\t\t\t\t \n\n \n\n \n\nstatic ssize_t mpc85xx_l2_inject_data_hi_show(struct edac_device_ctl_info\n\t\t\t\t\t      *edac_dev, char *data)\n{\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\treturn sprintf(data, \"0x%08x\",\n\t\t       in_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJHI));\n}\n\nstatic ssize_t mpc85xx_l2_inject_data_lo_show(struct edac_device_ctl_info\n\t\t\t\t\t      *edac_dev, char *data)\n{\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\treturn sprintf(data, \"0x%08x\",\n\t\t       in_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJLO));\n}\n\nstatic ssize_t mpc85xx_l2_inject_ctrl_show(struct edac_device_ctl_info\n\t\t\t\t\t   *edac_dev, char *data)\n{\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\treturn sprintf(data, \"0x%08x\",\n\t\t       in_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJCTL));\n}\n\nstatic ssize_t mpc85xx_l2_inject_data_hi_store(struct edac_device_ctl_info\n\t\t\t\t\t       *edac_dev, const char *data,\n\t\t\t\t\t       size_t count)\n{\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\tif (isdigit(*data)) {\n\t\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJHI,\n\t\t\t simple_strtoul(data, NULL, 0));\n\t\treturn count;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t mpc85xx_l2_inject_data_lo_store(struct edac_device_ctl_info\n\t\t\t\t\t       *edac_dev, const char *data,\n\t\t\t\t\t       size_t count)\n{\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\tif (isdigit(*data)) {\n\t\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJLO,\n\t\t\t simple_strtoul(data, NULL, 0));\n\t\treturn count;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t mpc85xx_l2_inject_ctrl_store(struct edac_device_ctl_info\n\t\t\t\t\t    *edac_dev, const char *data,\n\t\t\t\t\t    size_t count)\n{\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\tif (isdigit(*data)) {\n\t\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINJCTL,\n\t\t\t simple_strtoul(data, NULL, 0));\n\t\treturn count;\n\t}\n\treturn 0;\n}\n\nstatic struct edac_dev_sysfs_attribute mpc85xx_l2_sysfs_attributes[] = {\n\t{\n\t .attr = {\n\t\t  .name = \"inject_data_hi\",\n\t\t  .mode = (S_IRUGO | S_IWUSR)\n\t\t  },\n\t .show = mpc85xx_l2_inject_data_hi_show,\n\t .store = mpc85xx_l2_inject_data_hi_store},\n\t{\n\t .attr = {\n\t\t  .name = \"inject_data_lo\",\n\t\t  .mode = (S_IRUGO | S_IWUSR)\n\t\t  },\n\t .show = mpc85xx_l2_inject_data_lo_show,\n\t .store = mpc85xx_l2_inject_data_lo_store},\n\t{\n\t .attr = {\n\t\t  .name = \"inject_ctrl\",\n\t\t  .mode = (S_IRUGO | S_IWUSR)\n\t\t  },\n\t .show = mpc85xx_l2_inject_ctrl_show,\n\t .store = mpc85xx_l2_inject_ctrl_store},\n\n\t \n\t{\n\t .attr = {.name = NULL}\n\t }\n};\n\nstatic void mpc85xx_set_l2_sysfs_attributes(struct edac_device_ctl_info\n\t\t\t\t\t    *edac_dev)\n{\n\tedac_dev->sysfs_attributes = mpc85xx_l2_sysfs_attributes;\n}\n\n \n\nstatic void mpc85xx_l2_check(struct edac_device_ctl_info *edac_dev)\n{\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\tu32 err_detect;\n\n\terr_detect = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET);\n\n\tif (!(err_detect & L2_EDE_MASK))\n\t\treturn;\n\n\tpr_err(\"ECC Error in CPU L2 cache\\n\");\n\tpr_err(\"L2 Error Detect Register: 0x%08x\\n\", err_detect);\n\tpr_err(\"L2 Error Capture Data High Register: 0x%08x\\n\",\n\t       in_be32(pdata->l2_vbase + MPC85XX_L2_CAPTDATAHI));\n\tpr_err(\"L2 Error Capture Data Lo Register: 0x%08x\\n\",\n\t       in_be32(pdata->l2_vbase + MPC85XX_L2_CAPTDATALO));\n\tpr_err(\"L2 Error Syndrome Register: 0x%08x\\n\",\n\t       in_be32(pdata->l2_vbase + MPC85XX_L2_CAPTECC));\n\tpr_err(\"L2 Error Attributes Capture Register: 0x%08x\\n\",\n\t       in_be32(pdata->l2_vbase + MPC85XX_L2_ERRATTR));\n\tpr_err(\"L2 Error Address Capture Register: 0x%08x\\n\",\n\t       in_be32(pdata->l2_vbase + MPC85XX_L2_ERRADDR));\n\n\t \n\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET, err_detect);\n\n\tif (err_detect & L2_EDE_CE_MASK)\n\t\tedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\n\n\tif (err_detect & L2_EDE_UE_MASK)\n\t\tedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\n}\n\nstatic irqreturn_t mpc85xx_l2_isr(int irq, void *dev_id)\n{\n\tstruct edac_device_ctl_info *edac_dev = dev_id;\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\tu32 err_detect;\n\n\terr_detect = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET);\n\n\tif (!(err_detect & L2_EDE_MASK))\n\t\treturn IRQ_NONE;\n\n\tmpc85xx_l2_check(edac_dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mpc85xx_l2_err_probe(struct platform_device *op)\n{\n\tstruct edac_device_ctl_info *edac_dev;\n\tstruct mpc85xx_l2_pdata *pdata;\n\tstruct resource r;\n\tint res;\n\n\tif (!devres_open_group(&op->dev, mpc85xx_l2_err_probe, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tedac_dev = edac_device_alloc_ctl_info(sizeof(*pdata),\n\t\t\t\t\t      \"cpu\", 1, \"L\", 1, 2, NULL, 0,\n\t\t\t\t\t      edac_dev_idx);\n\tif (!edac_dev) {\n\t\tdevres_release_group(&op->dev, mpc85xx_l2_err_probe);\n\t\treturn -ENOMEM;\n\t}\n\n\tpdata = edac_dev->pvt_info;\n\tpdata->name = \"mpc85xx_l2_err\";\n\tedac_dev->dev = &op->dev;\n\tdev_set_drvdata(edac_dev->dev, edac_dev);\n\tedac_dev->ctl_name = pdata->name;\n\tedac_dev->dev_name = pdata->name;\n\n\tres = of_address_to_resource(op->dev.of_node, 0, &r);\n\tif (res) {\n\t\tpr_err(\"%s: Unable to get resource for L2 err regs\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\t \n\tr.start += 0xe00;\n\n\tif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\n\t\t\t\t     pdata->name)) {\n\t\tpr_err(\"%s: Error while requesting mem region\\n\", __func__);\n\t\tres = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tpdata->l2_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\n\tif (!pdata->l2_vbase) {\n\t\tpr_err(\"%s: Unable to setup L2 err regs\\n\", __func__);\n\t\tres = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDET, ~0);\n\n\torig_l2_err_disable = in_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS);\n\n\t \n\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS, 0);\n\n\tedac_dev->mod_name = EDAC_MOD_STR;\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tedac_dev->edac_check = mpc85xx_l2_check;\n\n\tmpc85xx_set_l2_sysfs_attributes(edac_dev);\n\n\tpdata->edac_idx = edac_dev_idx++;\n\n\tif (edac_device_add_device(edac_dev) > 0) {\n\t\tedac_dbg(3, \"failed edac_device_add_device()\\n\");\n\t\tgoto err;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_INT) {\n\t\tpdata->irq = irq_of_parse_and_map(op->dev.of_node, 0);\n\t\tres = devm_request_irq(&op->dev, pdata->irq,\n\t\t\t\t       mpc85xx_l2_isr, IRQF_SHARED,\n\t\t\t\t       \"[EDAC] L2 err\", edac_dev);\n\t\tif (res < 0) {\n\t\t\tpr_err(\"%s: Unable to request irq %d for MPC85xx L2 err\\n\",\n\t\t\t\t__func__, pdata->irq);\n\t\t\tirq_dispose_mapping(pdata->irq);\n\t\t\tres = -ENODEV;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tpr_info(EDAC_MOD_STR \" acquired irq %d for L2 Err\\n\", pdata->irq);\n\n\t\tedac_dev->op_state = OP_RUNNING_INTERRUPT;\n\n\t\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINTEN, L2_EIE_MASK);\n\t}\n\n\tdevres_remove_group(&op->dev, mpc85xx_l2_err_probe);\n\n\tedac_dbg(3, \"success\\n\");\n\tpr_info(EDAC_MOD_STR \" L2 err registered\\n\");\n\n\treturn 0;\n\nerr2:\n\tedac_device_del_device(&op->dev);\nerr:\n\tdevres_release_group(&op->dev, mpc85xx_l2_err_probe);\n\tedac_device_free_ctl_info(edac_dev);\n\treturn res;\n}\n\nstatic int mpc85xx_l2_err_remove(struct platform_device *op)\n{\n\tstruct edac_device_ctl_info *edac_dev = dev_get_drvdata(&op->dev);\n\tstruct mpc85xx_l2_pdata *pdata = edac_dev->pvt_info;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (edac_op_state == EDAC_OPSTATE_INT) {\n\t\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRINTEN, 0);\n\t\tirq_dispose_mapping(pdata->irq);\n\t}\n\n\tout_be32(pdata->l2_vbase + MPC85XX_L2_ERRDIS, orig_l2_err_disable);\n\tedac_device_del_device(&op->dev);\n\tedac_device_free_ctl_info(edac_dev);\n\treturn 0;\n}\n\nstatic const struct of_device_id mpc85xx_l2_err_of_match[] = {\n\t{ .compatible = \"fsl,mpc8536-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8540-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8541-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8544-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8548-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8555-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8560-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8568-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8569-l2-cache-controller\", },\n\t{ .compatible = \"fsl,mpc8572-l2-cache-controller\", },\n\t{ .compatible = \"fsl,p1020-l2-cache-controller\", },\n\t{ .compatible = \"fsl,p1021-l2-cache-controller\", },\n\t{ .compatible = \"fsl,p2020-l2-cache-controller\", },\n\t{ .compatible = \"fsl,t2080-l2-cache-controller\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpc85xx_l2_err_of_match);\n\nstatic struct platform_driver mpc85xx_l2_err_driver = {\n\t.probe = mpc85xx_l2_err_probe,\n\t.remove = mpc85xx_l2_err_remove,\n\t.driver = {\n\t\t.name = \"mpc85xx_l2_err\",\n\t\t.of_match_table = mpc85xx_l2_err_of_match,\n\t},\n};\n\nstatic const struct of_device_id mpc85xx_mc_err_of_match[] = {\n\t{ .compatible = \"fsl,mpc8536-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8540-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8541-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8544-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8548-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8555-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8560-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8568-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8569-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8572-memory-controller\", },\n\t{ .compatible = \"fsl,mpc8349-memory-controller\", },\n\t{ .compatible = \"fsl,p1020-memory-controller\", },\n\t{ .compatible = \"fsl,p1021-memory-controller\", },\n\t{ .compatible = \"fsl,p2020-memory-controller\", },\n\t{ .compatible = \"fsl,qoriq-memory-controller\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpc85xx_mc_err_of_match);\n\nstatic struct platform_driver mpc85xx_mc_err_driver = {\n\t.probe = fsl_mc_err_probe,\n\t.remove = fsl_mc_err_remove,\n\t.driver = {\n\t\t.name = \"mpc85xx_mc_err\",\n\t\t.of_match_table = mpc85xx_mc_err_of_match,\n\t},\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&mpc85xx_mc_err_driver,\n\t&mpc85xx_l2_err_driver,\n#ifdef CONFIG_PCI\n\t&mpc85xx_pci_err_driver,\n#endif\n};\n\nstatic int __init mpc85xx_mc_init(void)\n{\n\tint res = 0;\n\tu32 __maybe_unused pvr = 0;\n\n\tpr_info(\"Freescale(R) MPC85xx EDAC driver, (C) 2006 Montavista Software\\n\");\n\n\t \n\tswitch (edac_op_state) {\n\tcase EDAC_OPSTATE_POLL:\n\tcase EDAC_OPSTATE_INT:\n\t\tbreak;\n\tdefault:\n\t\tedac_op_state = EDAC_OPSTATE_INT;\n\t\tbreak;\n\t}\n\n\tres = platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n\tif (res)\n\t\tpr_warn(EDAC_MOD_STR \"drivers fail to register\\n\");\n\n\treturn 0;\n}\n\nmodule_init(mpc85xx_mc_init);\n\nstatic void __exit mpc85xx_mc_exit(void)\n{\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n}\n\nmodule_exit(mpc85xx_mc_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Montavista Software, Inc.\");\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll, 2=Interrupt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}