{
  "module_name": "highbank_mc_edac.c",
  "hash_id": "3f1e08980663ec8bfb04ae08b566eb4a544db9e92c0477ab365da7de7adfba87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/highbank_mc_edac.c",
  "human_readable_source": "\n \n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/edac.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n\n#include \"edac_module.h\"\n\n \n\n#define HB_DDR_ECC_ERR_BASE\t\t0x128\n#define MW_DDR_ECC_ERR_BASE\t\t0x1b4\n\n#define HB_DDR_ECC_OPT\t\t\t0x00\n#define HB_DDR_ECC_U_ERR_ADDR\t\t0x08\n#define HB_DDR_ECC_U_ERR_STAT\t\t0x0c\n#define HB_DDR_ECC_U_ERR_DATAL\t\t0x10\n#define HB_DDR_ECC_U_ERR_DATAH\t\t0x14\n#define HB_DDR_ECC_C_ERR_ADDR\t\t0x18\n#define HB_DDR_ECC_C_ERR_STAT\t\t0x1c\n#define HB_DDR_ECC_C_ERR_DATAL\t\t0x20\n#define HB_DDR_ECC_C_ERR_DATAH\t\t0x24\n\n#define HB_DDR_ECC_OPT_MODE_MASK\t0x3\n#define HB_DDR_ECC_OPT_FWC\t\t0x100\n#define HB_DDR_ECC_OPT_XOR_SHIFT\t16\n\n \n\n#define HB_DDR_ECC_INT_BASE\t\t0x180\n#define MW_DDR_ECC_INT_BASE\t\t0x218\n\n#define HB_DDR_ECC_INT_STATUS\t\t0x00\n#define HB_DDR_ECC_INT_ACK\t\t0x04\n\n#define HB_DDR_ECC_INT_STAT_CE\t\t0x8\n#define HB_DDR_ECC_INT_STAT_DOUBLE_CE\t0x10\n#define HB_DDR_ECC_INT_STAT_UE\t\t0x20\n#define HB_DDR_ECC_INT_STAT_DOUBLE_UE\t0x40\n\nstruct hb_mc_drvdata {\n\tvoid __iomem *mc_err_base;\n\tvoid __iomem *mc_int_base;\n};\n\nstatic irqreturn_t highbank_mc_err_handler(int irq, void *dev_id)\n{\n\tstruct mem_ctl_info *mci = dev_id;\n\tstruct hb_mc_drvdata *drvdata = mci->pvt_info;\n\tu32 status, err_addr;\n\n\t \n\tstatus = readl(drvdata->mc_int_base + HB_DDR_ECC_INT_STATUS);\n\n\tif (status & HB_DDR_ECC_INT_STAT_UE) {\n\t\terr_addr = readl(drvdata->mc_err_base + HB_DDR_ECC_U_ERR_ADDR);\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     err_addr >> PAGE_SHIFT,\n\t\t\t\t     err_addr & ~PAGE_MASK, 0,\n\t\t\t\t     0, 0, -1,\n\t\t\t\t     mci->ctl_name, \"\");\n\t}\n\tif (status & HB_DDR_ECC_INT_STAT_CE) {\n\t\tu32 syndrome = readl(drvdata->mc_err_base + HB_DDR_ECC_C_ERR_STAT);\n\t\tsyndrome = (syndrome >> 8) & 0xff;\n\t\terr_addr = readl(drvdata->mc_err_base + HB_DDR_ECC_C_ERR_ADDR);\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t     err_addr >> PAGE_SHIFT,\n\t\t\t\t     err_addr & ~PAGE_MASK, syndrome,\n\t\t\t\t     0, 0, -1,\n\t\t\t\t     mci->ctl_name, \"\");\n\t}\n\n\t \n\twritel(status, drvdata->mc_int_base + HB_DDR_ECC_INT_ACK);\n\treturn IRQ_HANDLED;\n}\n\nstatic void highbank_mc_err_inject(struct mem_ctl_info *mci, u8 synd)\n{\n\tstruct hb_mc_drvdata *pdata = mci->pvt_info;\n\tu32 reg;\n\n\treg = readl(pdata->mc_err_base + HB_DDR_ECC_OPT);\n\treg &= HB_DDR_ECC_OPT_MODE_MASK;\n\treg |= (synd << HB_DDR_ECC_OPT_XOR_SHIFT) | HB_DDR_ECC_OPT_FWC;\n\twritel(reg, pdata->mc_err_base + HB_DDR_ECC_OPT);\n}\n\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\n\nstatic ssize_t highbank_mc_inject_ctrl(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tu8 synd;\n\n\tif (kstrtou8(buf, 16, &synd))\n\t\treturn -EINVAL;\n\n\thighbank_mc_err_inject(mci, synd);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(inject_ctrl, S_IWUSR, NULL, highbank_mc_inject_ctrl);\n\nstatic struct attribute *highbank_dev_attrs[] = {\n\t&dev_attr_inject_ctrl.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(highbank_dev);\n\nstruct hb_mc_settings {\n\tint\terr_offset;\n\tint\tint_offset;\n};\n\nstatic struct hb_mc_settings hb_settings = {\n\t.err_offset = HB_DDR_ECC_ERR_BASE,\n\t.int_offset = HB_DDR_ECC_INT_BASE,\n};\n\nstatic struct hb_mc_settings mw_settings = {\n\t.err_offset = MW_DDR_ECC_ERR_BASE,\n\t.int_offset = MW_DDR_ECC_INT_BASE,\n};\n\nstatic const struct of_device_id hb_ddr_ctrl_of_match[] = {\n\t{ .compatible = \"calxeda,hb-ddr-ctrl\",\t\t.data = &hb_settings },\n\t{ .compatible = \"calxeda,ecx-2000-ddr-ctrl\",\t.data = &mw_settings },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hb_ddr_ctrl_of_match);\n\nstatic int highbank_mc_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *id;\n\tconst struct hb_mc_settings *settings;\n\tstruct edac_mc_layer layers[2];\n\tstruct mem_ctl_info *mci;\n\tstruct hb_mc_drvdata *drvdata;\n\tstruct dimm_info *dimm;\n\tstruct resource *r;\n\tvoid __iomem *base;\n\tu32 control;\n\tint irq;\n\tint res = 0;\n\n\tid = of_match_device(hb_ddr_ctrl_of_match, &pdev->dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = 1;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = 1;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(struct hb_mc_drvdata));\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tmci->pdev = &pdev->dev;\n\tdrvdata = mci->pvt_info;\n\tplatform_set_drvdata(pdev, mci);\n\n\tif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\n\t\tres = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"Unable to get mem resource\\n\");\n\t\tres = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif (!devm_request_mem_region(&pdev->dev, r->start,\n\t\t\t\t     resource_size(r), dev_name(&pdev->dev))) {\n\t\tdev_err(&pdev->dev, \"Error while requesting mem region\\n\");\n\t\tres = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tbase = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!base) {\n\t\tdev_err(&pdev->dev, \"Unable to map regs\\n\");\n\t\tres = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tsettings = id->data;\n\tdrvdata->mc_err_base = base + settings->err_offset;\n\tdrvdata->mc_int_base = base + settings->int_offset;\n\n\tcontrol = readl(drvdata->mc_err_base + HB_DDR_ECC_OPT) & 0x3;\n\tif (!control || (control == 0x2)) {\n\t\tdev_err(&pdev->dev, \"No ECC present, or ECC disabled\\n\");\n\t\tres = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tmci->mtype_cap = MEM_FLAG_DDR3;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = pdev->dev.driver->name;\n\tmci->ctl_name = id->compatible;\n\tmci->dev_name = dev_name(&pdev->dev);\n\tmci->scrub_mode = SCRUB_SW_SRC;\n\n\t \n\tdimm = *mci->dimms;\n\tdimm->nr_pages = (~0UL >> PAGE_SHIFT) + 1;\n\tdimm->grain = 8;\n\tdimm->dtype = DEV_X8;\n\tdimm->mtype = MEM_DDR3;\n\tdimm->edac_mode = EDAC_SECDED;\n\n\tres = edac_mc_add_mc_with_groups(mci, highbank_dev_groups);\n\tif (res < 0)\n\t\tgoto err;\n\n\tirq = platform_get_irq(pdev, 0);\n\tres = devm_request_irq(&pdev->dev, irq, highbank_mc_err_handler,\n\t\t\t       0, dev_name(&pdev->dev), mci);\n\tif (res < 0) {\n\t\tdev_err(&pdev->dev, \"Unable to request irq %d\\n\", irq);\n\t\tgoto err2;\n\t}\n\n\tdevres_close_group(&pdev->dev, NULL);\n\treturn 0;\nerr2:\n\tedac_mc_del_mc(&pdev->dev);\nerr:\n\tdevres_release_group(&pdev->dev, NULL);\nfree:\n\tedac_mc_free(mci);\n\treturn res;\n}\n\nstatic int highbank_mc_remove(struct platform_device *pdev)\n{\n\tstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\n\n\tedac_mc_del_mc(&pdev->dev);\n\tedac_mc_free(mci);\n\treturn 0;\n}\n\nstatic struct platform_driver highbank_mc_edac_driver = {\n\t.probe = highbank_mc_probe,\n\t.remove = highbank_mc_remove,\n\t.driver = {\n\t\t.name = \"hb_mc_edac\",\n\t\t.of_match_table = hb_ddr_ctrl_of_match,\n\t},\n};\n\nmodule_platform_driver(highbank_mc_edac_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Calxeda, Inc.\");\nMODULE_DESCRIPTION(\"EDAC Driver for Calxeda Highbank\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}