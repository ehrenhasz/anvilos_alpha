{
  "module_name": "fsl_ddr_edac.c",
  "hash_id": "b44f35dcfb185eb945c804a0ae1aa1d41885732081fd149508567a046565c012",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/fsl_ddr_edac.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ctype.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/edac.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include \"edac_module.h\"\n#include \"fsl_ddr_edac.h\"\n\n#define EDAC_MOD_STR\t\"fsl_ddr_edac\"\n\nstatic int edac_mc_idx;\n\nstatic u32 orig_ddr_err_disable;\nstatic u32 orig_ddr_err_sbe;\nstatic bool little_endian;\n\nstatic inline u32 ddr_in32(void __iomem *addr)\n{\n\treturn little_endian ? ioread32(addr) : ioread32be(addr);\n}\n\nstatic inline void ddr_out32(void __iomem *addr, u32 value)\n{\n\tif (little_endian)\n\t\tiowrite32(value, addr);\n\telse\n\t\tiowrite32be(value, addr);\n}\n\n#ifdef CONFIG_EDAC_DEBUG\n \n\n#define to_mci(k) container_of(k, struct mem_ctl_info, dev)\n\nstatic ssize_t fsl_mc_inject_data_hi_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *mattr,\n\t\t\t\t\t  char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\treturn sprintf(data, \"0x%08x\",\n\t\t       ddr_in32(pdata->mc_vbase + FSL_MC_DATA_ERR_INJECT_HI));\n}\n\nstatic ssize_t fsl_mc_inject_data_lo_show(struct device *dev,\n\t\t\t\t\t  struct device_attribute *mattr,\n\t\t\t\t\t      char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\treturn sprintf(data, \"0x%08x\",\n\t\t       ddr_in32(pdata->mc_vbase + FSL_MC_DATA_ERR_INJECT_LO));\n}\n\nstatic ssize_t fsl_mc_inject_ctrl_show(struct device *dev,\n\t\t\t\t       struct device_attribute *mattr,\n\t\t\t\t\t   char *data)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\treturn sprintf(data, \"0x%08x\",\n\t\t       ddr_in32(pdata->mc_vbase + FSL_MC_ECC_ERR_INJECT));\n}\n\nstatic ssize_t fsl_mc_inject_data_hi_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *mattr,\n\t\t\t\t\t       const char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\tunsigned long val;\n\tint rc;\n\n\tif (isdigit(*data)) {\n\t\trc = kstrtoul(data, 0, &val);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tddr_out32(pdata->mc_vbase + FSL_MC_DATA_ERR_INJECT_HI, val);\n\t\treturn count;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t fsl_mc_inject_data_lo_store(struct device *dev,\n\t\t\t\t\t   struct device_attribute *mattr,\n\t\t\t\t\t       const char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\tunsigned long val;\n\tint rc;\n\n\tif (isdigit(*data)) {\n\t\trc = kstrtoul(data, 0, &val);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tddr_out32(pdata->mc_vbase + FSL_MC_DATA_ERR_INJECT_LO, val);\n\t\treturn count;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t fsl_mc_inject_ctrl_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *mattr,\n\t\t\t\t\t       const char *data, size_t count)\n{\n\tstruct mem_ctl_info *mci = to_mci(dev);\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\tunsigned long val;\n\tint rc;\n\n\tif (isdigit(*data)) {\n\t\trc = kstrtoul(data, 0, &val);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tddr_out32(pdata->mc_vbase + FSL_MC_ECC_ERR_INJECT, val);\n\t\treturn count;\n\t}\n\treturn 0;\n}\n\nstatic DEVICE_ATTR(inject_data_hi, S_IRUGO | S_IWUSR,\n\t\t   fsl_mc_inject_data_hi_show, fsl_mc_inject_data_hi_store);\nstatic DEVICE_ATTR(inject_data_lo, S_IRUGO | S_IWUSR,\n\t\t   fsl_mc_inject_data_lo_show, fsl_mc_inject_data_lo_store);\nstatic DEVICE_ATTR(inject_ctrl, S_IRUGO | S_IWUSR,\n\t\t   fsl_mc_inject_ctrl_show, fsl_mc_inject_ctrl_store);\n#endif  \n\nstatic struct attribute *fsl_ddr_dev_attrs[] = {\n#ifdef CONFIG_EDAC_DEBUG\n\t&dev_attr_inject_data_hi.attr,\n\t&dev_attr_inject_data_lo.attr,\n\t&dev_attr_inject_ctrl.attr,\n#endif\n\tNULL\n};\n\nATTRIBUTE_GROUPS(fsl_ddr_dev);\n\n \n\n \nstatic unsigned int ecc_table[16] = {\n\t \n\t \n\t0xf00fe11e, 0xc33c0ff7,\t \n\t0x00ff00ff, 0x00fff0ff,\n\t0x0f0f0f0f, 0x0f0fff00,\n\t0x11113333, 0x7777000f,\n\t0x22224444, 0x8888222f,\n\t0x44448888, 0xffff4441,\n\t0x8888ffff, 0x11118882,\n\t0xffff1111, 0x22221114,\t \n};\n\n \nstatic u8 calculate_ecc(u32 high, u32 low)\n{\n\tu32 mask_low;\n\tu32 mask_high;\n\tint bit_cnt;\n\tu8 ecc = 0;\n\tint i;\n\tint j;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tmask_high = ecc_table[i * 2];\n\t\tmask_low = ecc_table[i * 2 + 1];\n\t\tbit_cnt = 0;\n\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tif ((mask_high >> j) & 1)\n\t\t\t\tbit_cnt ^= (high >> j) & 1;\n\t\t\tif ((mask_low >> j) & 1)\n\t\t\t\tbit_cnt ^= (low >> j) & 1;\n\t\t}\n\n\t\tecc |= bit_cnt << i;\n\t}\n\n\treturn ecc;\n}\n\n \nstatic u8 syndrome_from_bit(unsigned int bit) {\n\tint i;\n\tu8 syndrome = 0;\n\n\t \n\tfor (i = bit < 32; i < 16; i += 2)\n\t\tsyndrome |= ((ecc_table[i] >> (bit % 32)) & 1) << (i / 2);\n\n\treturn syndrome;\n}\n\n \nstatic void sbe_ecc_decode(u32 cap_high, u32 cap_low, u32 cap_ecc,\n\t\t       int *bad_data_bit, int *bad_ecc_bit)\n{\n\tint i;\n\tu8 syndrome;\n\n\t*bad_data_bit = -1;\n\t*bad_ecc_bit = -1;\n\n\t \n\tsyndrome = calculate_ecc(cap_high, cap_low) ^ cap_ecc;\n\n\t \n\tfor (i = 0; i < 64; i++) {\n\t\tif (syndrome == syndrome_from_bit(i)) {\n\t\t\t*bad_data_bit = i;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif ((syndrome >> i) & 0x1) {\n\t\t\t*bad_ecc_bit = i;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#define make64(high, low) (((u64)(high) << 32) | (low))\n\nstatic void fsl_mc_check(struct mem_ctl_info *mci)\n{\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\tstruct csrow_info *csrow;\n\tu32 bus_width;\n\tu32 err_detect;\n\tu32 syndrome;\n\tu64 err_addr;\n\tu32 pfn;\n\tint row_index;\n\tu32 cap_high;\n\tu32 cap_low;\n\tint bad_data_bit;\n\tint bad_ecc_bit;\n\n\terr_detect = ddr_in32(pdata->mc_vbase + FSL_MC_ERR_DETECT);\n\tif (!err_detect)\n\t\treturn;\n\n\tfsl_mc_printk(mci, KERN_ERR, \"Err Detect Register: %#8.8x\\n\",\n\t\t      err_detect);\n\n\t \n\tif (!(err_detect & (DDR_EDE_SBE | DDR_EDE_MBE))) {\n\t\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_DETECT, err_detect);\n\t\treturn;\n\t}\n\n\tsyndrome = ddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_ECC);\n\n\t \n\tbus_width = (ddr_in32(pdata->mc_vbase + FSL_MC_DDR_SDRAM_CFG) &\n\t\t     DSC_DBW_MASK) ? 32 : 64;\n\tif (bus_width == 64)\n\t\tsyndrome &= 0xff;\n\telse\n\t\tsyndrome &= 0xffff;\n\n\terr_addr = make64(\n\t\tddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_EXT_ADDRESS),\n\t\tddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_ADDRESS));\n\tpfn = err_addr >> PAGE_SHIFT;\n\n\tfor (row_index = 0; row_index < mci->nr_csrows; row_index++) {\n\t\tcsrow = mci->csrows[row_index];\n\t\tif ((pfn >= csrow->first_page) && (pfn <= csrow->last_page))\n\t\t\tbreak;\n\t}\n\n\tcap_high = ddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_DATA_HI);\n\tcap_low = ddr_in32(pdata->mc_vbase + FSL_MC_CAPTURE_DATA_LO);\n\n\t \n\tif ((err_detect & DDR_EDE_SBE) && (bus_width == 64)) {\n\t\tsbe_ecc_decode(cap_high, cap_low, syndrome,\n\t\t\t\t&bad_data_bit, &bad_ecc_bit);\n\n\t\tif (bad_data_bit != -1)\n\t\t\tfsl_mc_printk(mci, KERN_ERR,\n\t\t\t\t\"Faulty Data bit: %d\\n\", bad_data_bit);\n\t\tif (bad_ecc_bit != -1)\n\t\t\tfsl_mc_printk(mci, KERN_ERR,\n\t\t\t\t\"Faulty ECC bit: %d\\n\", bad_ecc_bit);\n\n\t\tfsl_mc_printk(mci, KERN_ERR,\n\t\t\t\"Expected Data / ECC:\\t%#8.8x_%08x / %#2.2x\\n\",\n\t\t\tcap_high ^ (1 << (bad_data_bit - 32)),\n\t\t\tcap_low ^ (1 << bad_data_bit),\n\t\t\tsyndrome ^ (1 << bad_ecc_bit));\n\t}\n\n\tfsl_mc_printk(mci, KERN_ERR,\n\t\t\t\"Captured Data / ECC:\\t%#8.8x_%08x / %#2.2x\\n\",\n\t\t\tcap_high, cap_low, syndrome);\n\tfsl_mc_printk(mci, KERN_ERR, \"Err addr: %#8.8llx\\n\", err_addr);\n\tfsl_mc_printk(mci, KERN_ERR, \"PFN: %#8.8x\\n\", pfn);\n\n\t \n\tif (row_index == mci->nr_csrows)\n\t\tfsl_mc_printk(mci, KERN_ERR, \"PFN out of range!\\n\");\n\n\tif (err_detect & DDR_EDE_SBE)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t     pfn, err_addr & ~PAGE_MASK, syndrome,\n\t\t\t\t     row_index, 0, -1,\n\t\t\t\t     mci->ctl_name, \"\");\n\n\tif (err_detect & DDR_EDE_MBE)\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t     pfn, err_addr & ~PAGE_MASK, syndrome,\n\t\t\t\t     row_index, 0, -1,\n\t\t\t\t     mci->ctl_name, \"\");\n\n\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_DETECT, err_detect);\n}\n\nstatic irqreturn_t fsl_mc_isr(int irq, void *dev_id)\n{\n\tstruct mem_ctl_info *mci = dev_id;\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\tu32 err_detect;\n\n\terr_detect = ddr_in32(pdata->mc_vbase + FSL_MC_ERR_DETECT);\n\tif (!err_detect)\n\t\treturn IRQ_NONE;\n\n\tfsl_mc_check(mci);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void fsl_ddr_init_csrows(struct mem_ctl_info *mci)\n{\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\tstruct csrow_info *csrow;\n\tstruct dimm_info *dimm;\n\tu32 sdram_ctl;\n\tu32 sdtype;\n\tenum mem_type mtype;\n\tu32 cs_bnds;\n\tint index;\n\n\tsdram_ctl = ddr_in32(pdata->mc_vbase + FSL_MC_DDR_SDRAM_CFG);\n\n\tsdtype = sdram_ctl & DSC_SDTYPE_MASK;\n\tif (sdram_ctl & DSC_RD_EN) {\n\t\tswitch (sdtype) {\n\t\tcase 0x02000000:\n\t\t\tmtype = MEM_RDDR;\n\t\t\tbreak;\n\t\tcase 0x03000000:\n\t\t\tmtype = MEM_RDDR2;\n\t\t\tbreak;\n\t\tcase 0x07000000:\n\t\t\tmtype = MEM_RDDR3;\n\t\t\tbreak;\n\t\tcase 0x05000000:\n\t\t\tmtype = MEM_RDDR4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmtype = MEM_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (sdtype) {\n\t\tcase 0x02000000:\n\t\t\tmtype = MEM_DDR;\n\t\t\tbreak;\n\t\tcase 0x03000000:\n\t\t\tmtype = MEM_DDR2;\n\t\t\tbreak;\n\t\tcase 0x07000000:\n\t\t\tmtype = MEM_DDR3;\n\t\t\tbreak;\n\t\tcase 0x05000000:\n\t\t\tmtype = MEM_DDR4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmtype = MEM_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (index = 0; index < mci->nr_csrows; index++) {\n\t\tu32 start;\n\t\tu32 end;\n\n\t\tcsrow = mci->csrows[index];\n\t\tdimm = csrow->channels[0]->dimm;\n\n\t\tcs_bnds = ddr_in32(pdata->mc_vbase + FSL_MC_CS_BNDS_0 +\n\t\t\t\t   (index * FSL_MC_CS_BNDS_OFS));\n\n\t\tstart = (cs_bnds & 0xffff0000) >> 16;\n\t\tend   = (cs_bnds & 0x0000ffff);\n\n\t\tif (start == end)\n\t\t\tcontinue;\t \n\n\t\tstart <<= (24 - PAGE_SHIFT);\n\t\tend   <<= (24 - PAGE_SHIFT);\n\t\tend    |= (1 << (24 - PAGE_SHIFT)) - 1;\n\n\t\tcsrow->first_page = start;\n\t\tcsrow->last_page = end;\n\n\t\tdimm->nr_pages = end + 1 - start;\n\t\tdimm->grain = 8;\n\t\tdimm->mtype = mtype;\n\t\tdimm->dtype = DEV_UNKNOWN;\n\t\tif (sdram_ctl & DSC_X32_EN)\n\t\t\tdimm->dtype = DEV_X32;\n\t\tdimm->edac_mode = EDAC_SECDED;\n\t}\n}\n\nint fsl_mc_err_probe(struct platform_device *op)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct edac_mc_layer layers[2];\n\tstruct fsl_mc_pdata *pdata;\n\tstruct resource r;\n\tu32 sdram_ctl;\n\tint res;\n\n\tif (!devres_open_group(&op->dev, fsl_mc_err_probe, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = 4;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = 1;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(edac_mc_idx, ARRAY_SIZE(layers), layers,\n\t\t\t    sizeof(*pdata));\n\tif (!mci) {\n\t\tdevres_release_group(&op->dev, fsl_mc_err_probe);\n\t\treturn -ENOMEM;\n\t}\n\n\tpdata = mci->pvt_info;\n\tpdata->name = \"fsl_mc_err\";\n\tmci->pdev = &op->dev;\n\tpdata->edac_idx = edac_mc_idx++;\n\tdev_set_drvdata(mci->pdev, mci);\n\tmci->ctl_name = pdata->name;\n\tmci->dev_name = pdata->name;\n\n\t \n\tlittle_endian = of_property_read_bool(op->dev.of_node, \"little-endian\");\n\n\tres = of_address_to_resource(op->dev.of_node, 0, &r);\n\tif (res) {\n\t\tpr_err(\"%s: Unable to get resource for MC err regs\\n\",\n\t\t       __func__);\n\t\tgoto err;\n\t}\n\n\tif (!devm_request_mem_region(&op->dev, r.start, resource_size(&r),\n\t\t\t\t     pdata->name)) {\n\t\tpr_err(\"%s: Error while requesting mem region\\n\",\n\t\t       __func__);\n\t\tres = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tpdata->mc_vbase = devm_ioremap(&op->dev, r.start, resource_size(&r));\n\tif (!pdata->mc_vbase) {\n\t\tpr_err(\"%s: Unable to setup MC err regs\\n\", __func__);\n\t\tres = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tsdram_ctl = ddr_in32(pdata->mc_vbase + FSL_MC_DDR_SDRAM_CFG);\n\tif (!(sdram_ctl & DSC_ECC_EN)) {\n\t\t \n\t\tpr_warn(\"%s: No ECC DIMMs discovered\\n\", __func__);\n\t\tres = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tedac_dbg(3, \"init mci\\n\");\n\tmci->mtype_cap = MEM_FLAG_DDR | MEM_FLAG_RDDR |\n\t\t\t MEM_FLAG_DDR2 | MEM_FLAG_RDDR2 |\n\t\t\t MEM_FLAG_DDR3 | MEM_FLAG_RDDR3 |\n\t\t\t MEM_FLAG_DDR4 | MEM_FLAG_RDDR4;\n\tmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = EDAC_MOD_STR;\n\n\tif (edac_op_state == EDAC_OPSTATE_POLL)\n\t\tmci->edac_check = fsl_mc_check;\n\n\tmci->ctl_page_to_phys = NULL;\n\n\tmci->scrub_mode = SCRUB_SW_SRC;\n\n\tfsl_ddr_init_csrows(mci);\n\n\t \n\torig_ddr_err_disable = ddr_in32(pdata->mc_vbase + FSL_MC_ERR_DISABLE);\n\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_DISABLE, 0);\n\n\t \n\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_DETECT, ~0);\n\n\tres = edac_mc_add_mc_with_groups(mci, fsl_ddr_dev_groups);\n\tif (res) {\n\t\tedac_dbg(3, \"failed edac_mc_add_mc()\\n\");\n\t\tgoto err;\n\t}\n\n\tif (edac_op_state == EDAC_OPSTATE_INT) {\n\t\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_INT_EN,\n\t\t\t  DDR_EIE_MBEE | DDR_EIE_SBEE);\n\n\t\t \n\t\torig_ddr_err_sbe = ddr_in32(pdata->mc_vbase +\n\t\t\t\t\t    FSL_MC_ERR_SBE) & 0xff0000;\n\n\t\t \n\t\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_SBE, 0x10000);\n\n\t\t \n\t\tpdata->irq = platform_get_irq(op, 0);\n\t\tres = devm_request_irq(&op->dev, pdata->irq,\n\t\t\t\t       fsl_mc_isr,\n\t\t\t\t       IRQF_SHARED,\n\t\t\t\t       \"[EDAC] MC err\", mci);\n\t\tif (res < 0) {\n\t\t\tpr_err(\"%s: Unable to request irq %d for FSL DDR DRAM ERR\\n\",\n\t\t\t       __func__, pdata->irq);\n\t\t\tres = -ENODEV;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tpr_info(EDAC_MOD_STR \" acquired irq %d for MC\\n\",\n\t\t       pdata->irq);\n\t}\n\n\tdevres_remove_group(&op->dev, fsl_mc_err_probe);\n\tedac_dbg(3, \"success\\n\");\n\tpr_info(EDAC_MOD_STR \" MC err registered\\n\");\n\n\treturn 0;\n\nerr2:\n\tedac_mc_del_mc(&op->dev);\nerr:\n\tdevres_release_group(&op->dev, fsl_mc_err_probe);\n\tedac_mc_free(mci);\n\treturn res;\n}\n\nint fsl_mc_err_remove(struct platform_device *op)\n{\n\tstruct mem_ctl_info *mci = dev_get_drvdata(&op->dev);\n\tstruct fsl_mc_pdata *pdata = mci->pvt_info;\n\n\tedac_dbg(0, \"\\n\");\n\n\tif (edac_op_state == EDAC_OPSTATE_INT) {\n\t\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_INT_EN, 0);\n\t}\n\n\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_DISABLE,\n\t\t  orig_ddr_err_disable);\n\tddr_out32(pdata->mc_vbase + FSL_MC_ERR_SBE, orig_ddr_err_sbe);\n\n\tedac_mc_del_mc(&op->dev);\n\tedac_mc_free(mci);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}