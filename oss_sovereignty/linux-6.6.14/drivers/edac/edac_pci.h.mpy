{
  "module_name": "edac_pci.h",
  "hash_id": "ae5c2c74d17de5af38755e94c4245b6313265e9ee5b0b6f4f7760ae4c9e7d342",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/edac_pci.h",
  "human_readable_source": " \n\n#ifndef _EDAC_PCI_H_\n#define _EDAC_PCI_H_\n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/edac.h>\n#include <linux/kobject.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#ifdef CONFIG_PCI\n\nstruct edac_pci_counter {\n\tatomic_t pe_count;\n\tatomic_t npe_count;\n};\n\n \nstruct edac_pci_ctl_info {\n\t \n\tstruct list_head link;\n\n\tint pci_idx;\n\n\tstruct bus_type *edac_subsys;\t \n\n\t \n\tint op_state;\n\t \n\tstruct delayed_work work;\n\n\t \n\tvoid (*edac_check) (struct edac_pci_ctl_info * edac_dev);\n\n\tstruct device *dev;\t \n\n\tconst char *mod_name;\t \n\tconst char *ctl_name;\t \n\tconst char *dev_name;\t \n\n\tvoid *pvt_info;\t\t \n\n\tunsigned long start_time;\t \n\n\tstruct completion complete;\n\n\t \n\tchar name[EDAC_DEVICE_NAME_LEN + 1];\n\n\t \n\tstruct edac_pci_counter counters;\n\n\t \n\tstruct kobject kobj;\n};\n\n#define to_edac_pci_ctl_work(w) \\\n\t\tcontainer_of(w, struct edac_pci_ctl_info,work)\n\n \nstatic inline void pci_write_bits8(struct pci_dev *pdev, int offset, u8 value,\n\t\t\t\t   u8 mask)\n{\n\tif (mask != 0xff) {\n\t\tu8 buf;\n\n\t\tpci_read_config_byte(pdev, offset, &buf);\n\t\tvalue &= mask;\n\t\tbuf &= ~mask;\n\t\tvalue |= buf;\n\t}\n\n\tpci_write_config_byte(pdev, offset, value);\n}\n\n \nstatic inline void pci_write_bits16(struct pci_dev *pdev, int offset,\n\t\t\t\t    u16 value, u16 mask)\n{\n\tif (mask != 0xffff) {\n\t\tu16 buf;\n\n\t\tpci_read_config_word(pdev, offset, &buf);\n\t\tvalue &= mask;\n\t\tbuf &= ~mask;\n\t\tvalue |= buf;\n\t}\n\n\tpci_write_config_word(pdev, offset, value);\n}\n\n \nstatic inline void pci_write_bits32(struct pci_dev *pdev, int offset,\n\t\t\t\t    u32 value, u32 mask)\n{\n\tif (mask != 0xffffffff) {\n\t\tu32 buf;\n\n\t\tpci_read_config_dword(pdev, offset, &buf);\n\t\tvalue &= mask;\n\t\tbuf &= ~mask;\n\t\tvalue |= buf;\n\t}\n\n\tpci_write_config_dword(pdev, offset, value);\n}\n\n#endif\t\t\t\t \n\n \n\n \nextern struct edac_pci_ctl_info *edac_pci_alloc_ctl_info(unsigned int sz_pvt,\n\t\t\t\tconst char *edac_pci_name);\n\n \nextern void edac_pci_free_ctl_info(struct edac_pci_ctl_info *pci);\n\n \nextern int edac_pci_alloc_index(void);\n\n \nextern int edac_pci_add_device(struct edac_pci_ctl_info *pci, int edac_idx);\n\n \nextern struct edac_pci_ctl_info *edac_pci_del_device(struct device *dev);\n\n \nextern struct edac_pci_ctl_info *edac_pci_create_generic_ctl(\n\t\t\t\tstruct device *dev,\n\t\t\t\tconst char *mod_name);\n\n \nextern void edac_pci_release_generic_ctl(struct edac_pci_ctl_info *pci);\n\n \nextern int edac_pci_create_sysfs(struct edac_pci_ctl_info *pci);\n\n \nextern void edac_pci_remove_sysfs(struct edac_pci_ctl_info *pci);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}