{
  "module_name": "igen6_edac.c",
  "hash_id": "5c33f45ebb1aa39475efff5363df425b677ee0f0c56a4e843f9103da82ac4ed0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/igen6_edac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/irq_work.h>\n#include <linux/llist.h>\n#include <linux/genalloc.h>\n#include <linux/edac.h>\n#include <linux/bits.h>\n#include <linux/io.h>\n#include <asm/mach_traps.h>\n#include <asm/nmi.h>\n#include <asm/mce.h>\n\n#include \"edac_mc.h\"\n#include \"edac_module.h\"\n\n#define IGEN6_REVISION\t\"v2.5.1\"\n\n#define EDAC_MOD_STR\t\"igen6_edac\"\n#define IGEN6_NMI_NAME\t\"igen6_ibecc\"\n\n \n#define igen6_printk(level, fmt, arg...)\t\t\\\n\tedac_printk(level, \"igen6\", fmt, ##arg)\n\n#define igen6_mc_printk(mci, level, fmt, arg...)\t\\\n\tedac_mc_chipset_printk(mci, level, \"igen6\", fmt, ##arg)\n\n#define GET_BITFIELD(v, lo, hi) (((v) & GENMASK_ULL(hi, lo)) >> (lo))\n\n#define NUM_IMC\t\t\t\t2  \n#define NUM_CHANNELS\t\t\t2  \n#define NUM_DIMMS\t\t\t2  \n\n#define _4GB\t\t\t\tBIT_ULL(32)\n\n \n#define TOM_OFFSET\t\t\t0xa0\n \n#define TOLUD_OFFSET\t\t\t0xbc\n \n#define CAPID_C_OFFSET\t\t\t0xec\n#define CAPID_C_IBECC\t\t\tBIT(15)\n\n \n#define CAPID_E_OFFSET\t\t\t0xf0\n#define CAPID_E_IBECC\t\t\tBIT(12)\n\n \n#define ERRSTS_OFFSET\t\t\t0xc8\n#define ERRSTS_CE\t\t\tBIT_ULL(6)\n#define ERRSTS_UE\t\t\tBIT_ULL(7)\n\n \n#define ERRCMD_OFFSET\t\t\t0xca\n#define ERRCMD_CE\t\t\tBIT_ULL(6)\n#define ERRCMD_UE\t\t\tBIT_ULL(7)\n\n \n#define IBECC_BASE\t\t\t(res_cfg->ibecc_base)\n#define IBECC_ACTIVATE_OFFSET\t\tIBECC_BASE\n#define IBECC_ACTIVATE_EN\t\tBIT(0)\n\n \n#define ECC_ERROR_LOG_OFFSET\t\t(IBECC_BASE + res_cfg->ibecc_error_log_offset)\n#define ECC_ERROR_LOG_CE\t\tBIT_ULL(62)\n#define ECC_ERROR_LOG_UE\t\tBIT_ULL(63)\n#define ECC_ERROR_LOG_ADDR_SHIFT\t5\n#define ECC_ERROR_LOG_ADDR(v)\t\tGET_BITFIELD(v, 5, 38)\n#define ECC_ERROR_LOG_SYND(v)\t\tGET_BITFIELD(v, 46, 61)\n\n \n#define MCHBAR_OFFSET\t\t\t0x48\n#define MCHBAR_EN\t\t\tBIT_ULL(0)\n#define MCHBAR_BASE(v)\t\t\t(GET_BITFIELD(v, 16, 38) << 16)\n#define MCHBAR_SIZE\t\t\t0x10000\n\n \n#define IMC_BASE\t\t\t(res_cfg->imc_base)\n#define MAD_INTER_CHANNEL_OFFSET\tIMC_BASE\n#define MAD_INTER_CHANNEL_DDR_TYPE(v)\tGET_BITFIELD(v, 0, 2)\n#define MAD_INTER_CHANNEL_ECHM(v)\tGET_BITFIELD(v, 3, 3)\n#define MAD_INTER_CHANNEL_CH_L_MAP(v)\tGET_BITFIELD(v, 4, 4)\n#define MAD_INTER_CHANNEL_CH_S_SIZE(v)\t((u64)GET_BITFIELD(v, 12, 19) << 29)\n\n \n#define MAD_INTRA_CH0_OFFSET\t\t(IMC_BASE + 4)\n#define MAD_INTRA_CH_DIMM_L_MAP(v)\tGET_BITFIELD(v, 0, 0)\n\n \n#define MAD_DIMM_CH0_OFFSET\t\t(IMC_BASE + 0xc)\n#define MAD_DIMM_CH_DIMM_L_SIZE(v)\t((u64)GET_BITFIELD(v, 0, 6) << 29)\n#define MAD_DIMM_CH_DLW(v)\t\tGET_BITFIELD(v, 7, 8)\n#define MAD_DIMM_CH_DIMM_S_SIZE(v)\t((u64)GET_BITFIELD(v, 16, 22) << 29)\n#define MAD_DIMM_CH_DSW(v)\t\tGET_BITFIELD(v, 24, 25)\n\n \n#define MAD_MC_HASH_OFFSET\t\t(IMC_BASE + 0x1b8)\n#define MAC_MC_HASH_LSB(v)\t\tGET_BITFIELD(v, 1, 3)\n\n \n#define CHANNEL_HASH_OFFSET\t\t(IMC_BASE + 0x24)\n \n#define CHANNEL_EHASH_OFFSET\t\t(IMC_BASE + 0x28)\n#define CHANNEL_HASH_MASK(v)\t\t(GET_BITFIELD(v, 6, 19) << 6)\n#define CHANNEL_HASH_LSB_MASK_BIT(v)\tGET_BITFIELD(v, 24, 26)\n#define CHANNEL_HASH_MODE(v)\t\tGET_BITFIELD(v, 28, 28)\n\n \n#define MEM_SLICE_HASH_MASK(v)\t\t(GET_BITFIELD(v, 6, 19) << 6)\n#define MEM_SLICE_HASH_LSB_MASK_BIT(v)\tGET_BITFIELD(v, 24, 26)\n\nstatic struct res_config {\n\tbool machine_check;\n\tint num_imc;\n\tu32 imc_base;\n\tu32 cmf_base;\n\tu32 cmf_size;\n\tu32 ms_hash_offset;\n\tu32 ibecc_base;\n\tu32 ibecc_error_log_offset;\n\tbool (*ibecc_available)(struct pci_dev *pdev);\n\t \n\tu64 (*err_addr_to_sys_addr)(u64 eaddr, int mc);\n\t \n\tu64 (*err_addr_to_imc_addr)(u64 eaddr, int mc);\n} *res_cfg;\n\nstruct igen6_imc {\n\tint mc;\n\tstruct mem_ctl_info *mci;\n\tstruct pci_dev *pdev;\n\tstruct device dev;\n\tvoid __iomem *window;\n\tu64 size;\n\tu64 ch_s_size;\n\tint ch_l_map;\n\tu64 dimm_s_size[NUM_CHANNELS];\n\tu64 dimm_l_size[NUM_CHANNELS];\n\tint dimm_l_map[NUM_CHANNELS];\n};\n\nstatic struct igen6_pvt {\n\tstruct igen6_imc imc[NUM_IMC];\n\tu64 ms_hash;\n\tu64 ms_s_size;\n\tint ms_l_map;\n} *igen6_pvt;\n\n \nstatic u32 igen6_tolud;\n \nstatic u64 igen6_tom;\n\nstruct decoded_addr {\n\tint mc;\n\tu64 imc_addr;\n\tu64 sys_addr;\n\tint channel_idx;\n\tu64 channel_addr;\n\tint sub_channel_idx;\n\tu64 sub_channel_addr;\n};\n\nstruct ecclog_node {\n\tstruct llist_node llnode;\n\tint mc;\n\tu64 ecclog;\n};\n\n \n#define ECCLOG_POOL_SIZE\tPAGE_SIZE\nstatic LLIST_HEAD(ecclog_llist);\nstatic struct gen_pool *ecclog_pool;\nstatic char ecclog_buf[ECCLOG_POOL_SIZE];\nstatic struct irq_work ecclog_irq_work;\nstatic struct work_struct ecclog_work;\n\n \n#define DID_EHL_SKU5\t0x4514\n#define DID_EHL_SKU6\t0x4528\n#define DID_EHL_SKU7\t0x452a\n#define DID_EHL_SKU8\t0x4516\n#define DID_EHL_SKU9\t0x452c\n#define DID_EHL_SKU10\t0x452e\n#define DID_EHL_SKU11\t0x4532\n#define DID_EHL_SKU12\t0x4518\n#define DID_EHL_SKU13\t0x451a\n#define DID_EHL_SKU14\t0x4534\n#define DID_EHL_SKU15\t0x4536\n\n \n#define DID_ICL_SKU8\t0x4581\n#define DID_ICL_SKU10\t0x4585\n#define DID_ICL_SKU11\t0x4589\n#define DID_ICL_SKU12\t0x458d\n\n \n#define DID_TGL_SKU\t0x9a14\n\n \n#define DID_ADL_SKU1\t0x4601\n#define DID_ADL_SKU2\t0x4602\n#define DID_ADL_SKU3\t0x4621\n#define DID_ADL_SKU4\t0x4641\n\nstatic bool ehl_ibecc_available(struct pci_dev *pdev)\n{\n\tu32 v;\n\n\tif (pci_read_config_dword(pdev, CAPID_C_OFFSET, &v))\n\t\treturn false;\n\n\treturn !!(CAPID_C_IBECC & v);\n}\n\nstatic u64 ehl_err_addr_to_sys_addr(u64 eaddr, int mc)\n{\n\treturn eaddr;\n}\n\nstatic u64 ehl_err_addr_to_imc_addr(u64 eaddr, int mc)\n{\n\tif (eaddr < igen6_tolud)\n\t\treturn eaddr;\n\n\tif (igen6_tom <= _4GB)\n\t\treturn eaddr + igen6_tolud - _4GB;\n\n\tif (eaddr < _4GB)\n\t\treturn eaddr + igen6_tolud - igen6_tom;\n\n\treturn eaddr;\n}\n\nstatic bool icl_ibecc_available(struct pci_dev *pdev)\n{\n\tu32 v;\n\n\tif (pci_read_config_dword(pdev, CAPID_C_OFFSET, &v))\n\t\treturn false;\n\n\treturn !(CAPID_C_IBECC & v) &&\n\t\t(boot_cpu_data.x86_stepping >= 1);\n}\n\nstatic bool tgl_ibecc_available(struct pci_dev *pdev)\n{\n\tu32 v;\n\n\tif (pci_read_config_dword(pdev, CAPID_E_OFFSET, &v))\n\t\treturn false;\n\n\treturn !(CAPID_E_IBECC & v);\n}\n\nstatic u64 mem_addr_to_sys_addr(u64 maddr)\n{\n\tif (maddr < igen6_tolud)\n\t\treturn maddr;\n\n\tif (igen6_tom <= _4GB)\n\t\treturn maddr - igen6_tolud + _4GB;\n\n\tif (maddr < _4GB)\n\t\treturn maddr - igen6_tolud + igen6_tom;\n\n\treturn maddr;\n}\n\nstatic u64 mem_slice_hash(u64 addr, u64 mask, u64 hash_init, int intlv_bit)\n{\n\tu64 hash_addr = addr & mask, hash = hash_init;\n\tu64 intlv = (addr >> intlv_bit) & 1;\n\tint i;\n\n\tfor (i = 6; i < 20; i++)\n\t\thash ^= (hash_addr >> i) & 1;\n\n\treturn hash ^ intlv;\n}\n\nstatic u64 tgl_err_addr_to_mem_addr(u64 eaddr, int mc)\n{\n\tu64 maddr, hash, mask, ms_s_size;\n\tint intlv_bit;\n\tu32 ms_hash;\n\n\tms_s_size = igen6_pvt->ms_s_size;\n\tif (eaddr >= ms_s_size)\n\t\treturn eaddr + ms_s_size;\n\n\tms_hash = igen6_pvt->ms_hash;\n\n\tmask = MEM_SLICE_HASH_MASK(ms_hash);\n\tintlv_bit = MEM_SLICE_HASH_LSB_MASK_BIT(ms_hash) + 6;\n\n\tmaddr = GET_BITFIELD(eaddr, intlv_bit, 63) << (intlv_bit + 1) |\n\t\tGET_BITFIELD(eaddr, 0, intlv_bit - 1);\n\n\thash = mem_slice_hash(maddr, mask, mc, intlv_bit);\n\n\treturn maddr | (hash << intlv_bit);\n}\n\nstatic u64 tgl_err_addr_to_sys_addr(u64 eaddr, int mc)\n{\n\tu64 maddr = tgl_err_addr_to_mem_addr(eaddr, mc);\n\n\treturn mem_addr_to_sys_addr(maddr);\n}\n\nstatic u64 tgl_err_addr_to_imc_addr(u64 eaddr, int mc)\n{\n\treturn eaddr;\n}\n\nstatic u64 adl_err_addr_to_sys_addr(u64 eaddr, int mc)\n{\n\treturn mem_addr_to_sys_addr(eaddr);\n}\n\nstatic u64 adl_err_addr_to_imc_addr(u64 eaddr, int mc)\n{\n\tu64 imc_addr, ms_s_size = igen6_pvt->ms_s_size;\n\tstruct igen6_imc *imc = &igen6_pvt->imc[mc];\n\tint intlv_bit;\n\tu32 mc_hash;\n\n\tif (eaddr >= 2 * ms_s_size)\n\t\treturn eaddr - ms_s_size;\n\n\tmc_hash = readl(imc->window + MAD_MC_HASH_OFFSET);\n\n\tintlv_bit = MAC_MC_HASH_LSB(mc_hash) + 6;\n\n\timc_addr = GET_BITFIELD(eaddr, intlv_bit + 1, 63) << intlv_bit |\n\t\t   GET_BITFIELD(eaddr, 0, intlv_bit - 1);\n\n\treturn imc_addr;\n}\n\nstatic struct res_config ehl_cfg = {\n\t.num_imc\t\t= 1,\n\t.imc_base\t\t= 0x5000,\n\t.ibecc_base\t\t= 0xdc00,\n\t.ibecc_available\t= ehl_ibecc_available,\n\t.ibecc_error_log_offset\t= 0x170,\n\t.err_addr_to_sys_addr\t= ehl_err_addr_to_sys_addr,\n\t.err_addr_to_imc_addr\t= ehl_err_addr_to_imc_addr,\n};\n\nstatic struct res_config icl_cfg = {\n\t.num_imc\t\t= 1,\n\t.imc_base\t\t= 0x5000,\n\t.ibecc_base\t\t= 0xd800,\n\t.ibecc_error_log_offset\t= 0x170,\n\t.ibecc_available\t= icl_ibecc_available,\n\t.err_addr_to_sys_addr\t= ehl_err_addr_to_sys_addr,\n\t.err_addr_to_imc_addr\t= ehl_err_addr_to_imc_addr,\n};\n\nstatic struct res_config tgl_cfg = {\n\t.machine_check\t\t= true,\n\t.num_imc\t\t= 2,\n\t.imc_base\t\t= 0x5000,\n\t.cmf_base\t\t= 0x11000,\n\t.cmf_size\t\t= 0x800,\n\t.ms_hash_offset\t\t= 0xac,\n\t.ibecc_base\t\t= 0xd400,\n\t.ibecc_error_log_offset\t= 0x170,\n\t.ibecc_available\t= tgl_ibecc_available,\n\t.err_addr_to_sys_addr\t= tgl_err_addr_to_sys_addr,\n\t.err_addr_to_imc_addr\t= tgl_err_addr_to_imc_addr,\n};\n\nstatic struct res_config adl_cfg = {\n\t.machine_check\t\t= true,\n\t.num_imc\t\t= 2,\n\t.imc_base\t\t= 0xd800,\n\t.ibecc_base\t\t= 0xd400,\n\t.ibecc_error_log_offset\t= 0x68,\n\t.ibecc_available\t= tgl_ibecc_available,\n\t.err_addr_to_sys_addr\t= adl_err_addr_to_sys_addr,\n\t.err_addr_to_imc_addr\t= adl_err_addr_to_imc_addr,\n};\n\nstatic const struct pci_device_id igen6_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU5), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU6), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU7), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU8), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU9), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU10), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU11), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU12), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU13), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU14), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_EHL_SKU15), (kernel_ulong_t)&ehl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_ICL_SKU8), (kernel_ulong_t)&icl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_ICL_SKU10), (kernel_ulong_t)&icl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_ICL_SKU11), (kernel_ulong_t)&icl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_ICL_SKU12), (kernel_ulong_t)&icl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_TGL_SKU), (kernel_ulong_t)&tgl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_ADL_SKU1), (kernel_ulong_t)&adl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_ADL_SKU2), (kernel_ulong_t)&adl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_ADL_SKU3), (kernel_ulong_t)&adl_cfg },\n\t{ PCI_VDEVICE(INTEL, DID_ADL_SKU4), (kernel_ulong_t)&adl_cfg },\n\t{ },\n};\nMODULE_DEVICE_TABLE(pci, igen6_pci_tbl);\n\nstatic enum dev_type get_width(int dimm_l, u32 mad_dimm)\n{\n\tu32 w = dimm_l ? MAD_DIMM_CH_DLW(mad_dimm) :\n\t\t\t MAD_DIMM_CH_DSW(mad_dimm);\n\n\tswitch (w) {\n\tcase 0:\n\t\treturn DEV_X8;\n\tcase 1:\n\t\treturn DEV_X16;\n\tcase 2:\n\t\treturn DEV_X32;\n\tdefault:\n\t\treturn DEV_UNKNOWN;\n\t}\n}\n\nstatic enum mem_type get_memory_type(u32 mad_inter)\n{\n\tu32 t = MAD_INTER_CHANNEL_DDR_TYPE(mad_inter);\n\n\tswitch (t) {\n\tcase 0:\n\t\treturn MEM_DDR4;\n\tcase 1:\n\t\treturn MEM_DDR3;\n\tcase 2:\n\t\treturn MEM_LPDDR3;\n\tcase 3:\n\t\treturn MEM_LPDDR4;\n\tcase 4:\n\t\treturn MEM_WIO2;\n\tdefault:\n\t\treturn MEM_UNKNOWN;\n\t}\n}\n\nstatic int decode_chan_idx(u64 addr, u64 mask, int intlv_bit)\n{\n\tu64 hash_addr = addr & mask, hash = 0;\n\tu64 intlv = (addr >> intlv_bit) & 1;\n\tint i;\n\n\tfor (i = 6; i < 20; i++)\n\t\thash ^= (hash_addr >> i) & 1;\n\n\treturn (int)hash ^ intlv;\n}\n\nstatic u64 decode_channel_addr(u64 addr, int intlv_bit)\n{\n\tu64 channel_addr;\n\n\t \n\tchannel_addr  = GET_BITFIELD(addr, intlv_bit + 1, 63) << intlv_bit;\n\tchannel_addr |= GET_BITFIELD(addr, 0, intlv_bit - 1);\n\n\treturn channel_addr;\n}\n\nstatic void decode_addr(u64 addr, u32 hash, u64 s_size, int l_map,\n\t\t\tint *idx, u64 *sub_addr)\n{\n\tint intlv_bit = CHANNEL_HASH_LSB_MASK_BIT(hash) + 6;\n\n\tif (addr > 2 * s_size) {\n\t\t*sub_addr = addr - s_size;\n\t\t*idx = l_map;\n\t\treturn;\n\t}\n\n\tif (CHANNEL_HASH_MODE(hash)) {\n\t\t*sub_addr = decode_channel_addr(addr, intlv_bit);\n\t\t*idx = decode_chan_idx(addr, CHANNEL_HASH_MASK(hash), intlv_bit);\n\t} else {\n\t\t*sub_addr = decode_channel_addr(addr, 6);\n\t\t*idx = GET_BITFIELD(addr, 6, 6);\n\t}\n}\n\nstatic int igen6_decode(struct decoded_addr *res)\n{\n\tstruct igen6_imc *imc = &igen6_pvt->imc[res->mc];\n\tu64 addr = res->imc_addr, sub_addr, s_size;\n\tint idx, l_map;\n\tu32 hash;\n\n\tif (addr >= igen6_tom) {\n\t\tedac_dbg(0, \"Address 0x%llx out of range\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thash   = readl(imc->window + CHANNEL_HASH_OFFSET);\n\ts_size = imc->ch_s_size;\n\tl_map  = imc->ch_l_map;\n\tdecode_addr(addr, hash, s_size, l_map, &idx, &sub_addr);\n\tres->channel_idx  = idx;\n\tres->channel_addr = sub_addr;\n\n\t \n\thash   = readl(imc->window + CHANNEL_EHASH_OFFSET);\n\ts_size = imc->dimm_s_size[idx];\n\tl_map  = imc->dimm_l_map[idx];\n\tdecode_addr(res->channel_addr, hash, s_size, l_map, &idx, &sub_addr);\n\tres->sub_channel_idx  = idx;\n\tres->sub_channel_addr = sub_addr;\n\n\treturn 0;\n}\n\nstatic void igen6_output_error(struct decoded_addr *res,\n\t\t\t       struct mem_ctl_info *mci, u64 ecclog)\n{\n\tenum hw_event_mc_err_type type = ecclog & ECC_ERROR_LOG_UE ?\n\t\t\t\t\t HW_EVENT_ERR_UNCORRECTED :\n\t\t\t\t\t HW_EVENT_ERR_CORRECTED;\n\n\tedac_mc_handle_error(type, mci, 1,\n\t\t\t     res->sys_addr >> PAGE_SHIFT,\n\t\t\t     res->sys_addr & ~PAGE_MASK,\n\t\t\t     ECC_ERROR_LOG_SYND(ecclog),\n\t\t\t     res->channel_idx, res->sub_channel_idx,\n\t\t\t     -1, \"\", \"\");\n}\n\nstatic struct gen_pool *ecclog_gen_pool_create(void)\n{\n\tstruct gen_pool *pool;\n\n\tpool = gen_pool_create(ilog2(sizeof(struct ecclog_node)), -1);\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (gen_pool_add(pool, (unsigned long)ecclog_buf, ECCLOG_POOL_SIZE, -1)) {\n\t\tgen_pool_destroy(pool);\n\t\treturn NULL;\n\t}\n\n\treturn pool;\n}\n\nstatic int ecclog_gen_pool_add(int mc, u64 ecclog)\n{\n\tstruct ecclog_node *node;\n\n\tnode = (void *)gen_pool_alloc(ecclog_pool, sizeof(*node));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->mc = mc;\n\tnode->ecclog = ecclog;\n\tllist_add(&node->llnode, &ecclog_llist);\n\n\treturn 0;\n}\n\n \nstatic u64 ecclog_read_and_clear(struct igen6_imc *imc)\n{\n\tu64 ecclog = readq(imc->window + ECC_ERROR_LOG_OFFSET);\n\n\tif (ecclog & (ECC_ERROR_LOG_CE | ECC_ERROR_LOG_UE)) {\n\t\t \n\t\twriteq(ecclog, imc->window + ECC_ERROR_LOG_OFFSET);\n\t\treturn ecclog;\n\t}\n\n\treturn 0;\n}\n\nstatic void errsts_clear(struct igen6_imc *imc)\n{\n\tu16 errsts;\n\n\tif (pci_read_config_word(imc->pdev, ERRSTS_OFFSET, &errsts)) {\n\t\tigen6_printk(KERN_ERR, \"Failed to read ERRSTS\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (errsts & (ERRSTS_CE | ERRSTS_UE))\n\t\tpci_write_config_word(imc->pdev, ERRSTS_OFFSET, errsts);\n}\n\nstatic int errcmd_enable_error_reporting(bool enable)\n{\n\tstruct igen6_imc *imc = &igen6_pvt->imc[0];\n\tu16 errcmd;\n\tint rc;\n\n\trc = pci_read_config_word(imc->pdev, ERRCMD_OFFSET, &errcmd);\n\tif (rc)\n\t\treturn rc;\n\n\tif (enable)\n\t\terrcmd |= ERRCMD_CE | ERRSTS_UE;\n\telse\n\t\terrcmd &= ~(ERRCMD_CE | ERRSTS_UE);\n\n\trc = pci_write_config_word(imc->pdev, ERRCMD_OFFSET, errcmd);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int ecclog_handler(void)\n{\n\tstruct igen6_imc *imc;\n\tint i, n = 0;\n\tu64 ecclog;\n\n\tfor (i = 0; i < res_cfg->num_imc; i++) {\n\t\timc = &igen6_pvt->imc[i];\n\n\t\t \n\n\t\tecclog = ecclog_read_and_clear(imc);\n\t\tif (!ecclog)\n\t\t\tcontinue;\n\n\t\tif (!ecclog_gen_pool_add(i, ecclog))\n\t\t\tirq_work_queue(&ecclog_irq_work);\n\n\t\tn++;\n\t}\n\n\treturn n;\n}\n\nstatic void ecclog_work_cb(struct work_struct *work)\n{\n\tstruct ecclog_node *node, *tmp;\n\tstruct mem_ctl_info *mci;\n\tstruct llist_node *head;\n\tstruct decoded_addr res;\n\tu64 eaddr;\n\n\thead = llist_del_all(&ecclog_llist);\n\tif (!head)\n\t\treturn;\n\n\tllist_for_each_entry_safe(node, tmp, head, llnode) {\n\t\tmemset(&res, 0, sizeof(res));\n\t\teaddr = ECC_ERROR_LOG_ADDR(node->ecclog) <<\n\t\t\tECC_ERROR_LOG_ADDR_SHIFT;\n\t\tres.mc\t     = node->mc;\n\t\tres.sys_addr = res_cfg->err_addr_to_sys_addr(eaddr, res.mc);\n\t\tres.imc_addr = res_cfg->err_addr_to_imc_addr(eaddr, res.mc);\n\n\t\tmci = igen6_pvt->imc[res.mc].mci;\n\n\t\tedac_dbg(2, \"MC %d, ecclog = 0x%llx\\n\", node->mc, node->ecclog);\n\t\tigen6_mc_printk(mci, KERN_DEBUG, \"HANDLING IBECC MEMORY ERROR\\n\");\n\t\tigen6_mc_printk(mci, KERN_DEBUG, \"ADDR 0x%llx \", res.sys_addr);\n\n\t\tif (!igen6_decode(&res))\n\t\t\tigen6_output_error(&res, mci, node->ecclog);\n\n\t\tgen_pool_free(ecclog_pool, (unsigned long)node, sizeof(*node));\n\t}\n}\n\nstatic void ecclog_irq_work_cb(struct irq_work *irq_work)\n{\n\tint i;\n\n\tfor (i = 0; i < res_cfg->num_imc; i++)\n\t\terrsts_clear(&igen6_pvt->imc[i]);\n\n\tif (!llist_empty(&ecclog_llist))\n\t\tschedule_work(&ecclog_work);\n}\n\nstatic int ecclog_nmi_handler(unsigned int cmd, struct pt_regs *regs)\n{\n\tunsigned char reason;\n\n\tif (!ecclog_handler())\n\t\treturn NMI_DONE;\n\n\t \n\treason  = x86_platform.get_nmi_reason() & NMI_REASON_CLEAR_MASK;\n\treason |= NMI_REASON_CLEAR_SERR;\n\toutb(reason, NMI_REASON_PORT);\n\treason &= ~NMI_REASON_CLEAR_SERR;\n\toutb(reason, NMI_REASON_PORT);\n\n\treturn NMI_HANDLED;\n}\n\nstatic int ecclog_mce_handler(struct notifier_block *nb, unsigned long val,\n\t\t\t      void *data)\n{\n\tstruct mce *mce = (struct mce *)data;\n\tchar *type;\n\n\tif (mce->kflags & MCE_HANDLED_CEC)\n\t\treturn NOTIFY_DONE;\n\n\t \n\tif ((mce->status & 0xefff) >> 7 != 1)\n\t\treturn NOTIFY_DONE;\n\n\tif (mce->mcgstatus & MCG_STATUS_MCIP)\n\t\ttype = \"Exception\";\n\telse\n\t\ttype = \"Event\";\n\n\tedac_dbg(0, \"CPU %d: Machine Check %s: 0x%llx Bank %d: 0x%llx\\n\",\n\t\t mce->extcpu, type, mce->mcgstatus,\n\t\t mce->bank, mce->status);\n\tedac_dbg(0, \"TSC 0x%llx\\n\", mce->tsc);\n\tedac_dbg(0, \"ADDR 0x%llx\\n\", mce->addr);\n\tedac_dbg(0, \"MISC 0x%llx\\n\", mce->misc);\n\tedac_dbg(0, \"PROCESSOR %u:0x%x TIME %llu SOCKET %u APIC 0x%x\\n\",\n\t\t mce->cpuvendor, mce->cpuid, mce->time,\n\t\t mce->socketid, mce->apicid);\n\t \n\tif (!ecclog_handler())\n\t\treturn NOTIFY_DONE;\n\n\tmce->kflags |= MCE_HANDLED_EDAC;\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ecclog_mce_dec = {\n\t.notifier_call\t= ecclog_mce_handler,\n\t.priority\t= MCE_PRIO_EDAC,\n};\n\nstatic bool igen6_check_ecc(struct igen6_imc *imc)\n{\n\tu32 activate = readl(imc->window + IBECC_ACTIVATE_OFFSET);\n\n\treturn !!(activate & IBECC_ACTIVATE_EN);\n}\n\nstatic int igen6_get_dimm_config(struct mem_ctl_info *mci)\n{\n\tstruct igen6_imc *imc = mci->pvt_info;\n\tu32 mad_inter, mad_intra, mad_dimm;\n\tint i, j, ndimms, mc = imc->mc;\n\tstruct dimm_info *dimm;\n\tenum mem_type mtype;\n\tenum dev_type dtype;\n\tu64 dsize;\n\tbool ecc;\n\n\tedac_dbg(2, \"\\n\");\n\n\tmad_inter = readl(imc->window + MAD_INTER_CHANNEL_OFFSET);\n\tmtype = get_memory_type(mad_inter);\n\tecc = igen6_check_ecc(imc);\n\timc->ch_s_size = MAD_INTER_CHANNEL_CH_S_SIZE(mad_inter);\n\timc->ch_l_map  = MAD_INTER_CHANNEL_CH_L_MAP(mad_inter);\n\n\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\tmad_intra = readl(imc->window + MAD_INTRA_CH0_OFFSET + i * 4);\n\t\tmad_dimm  = readl(imc->window + MAD_DIMM_CH0_OFFSET + i * 4);\n\n\t\timc->dimm_l_size[i] = MAD_DIMM_CH_DIMM_L_SIZE(mad_dimm);\n\t\timc->dimm_s_size[i] = MAD_DIMM_CH_DIMM_S_SIZE(mad_dimm);\n\t\timc->dimm_l_map[i]  = MAD_INTRA_CH_DIMM_L_MAP(mad_intra);\n\t\timc->size += imc->dimm_s_size[i];\n\t\timc->size += imc->dimm_l_size[i];\n\t\tndimms = 0;\n\n\t\tfor (j = 0; j < NUM_DIMMS; j++) {\n\t\t\tdimm = edac_get_dimm(mci, i, j, 0);\n\n\t\t\tif (j ^ imc->dimm_l_map[i]) {\n\t\t\t\tdtype = get_width(0, mad_dimm);\n\t\t\t\tdsize = imc->dimm_s_size[i];\n\t\t\t} else {\n\t\t\t\tdtype = get_width(1, mad_dimm);\n\t\t\t\tdsize = imc->dimm_l_size[i];\n\t\t\t}\n\n\t\t\tif (!dsize)\n\t\t\t\tcontinue;\n\n\t\t\tdimm->grain = 64;\n\t\t\tdimm->mtype = mtype;\n\t\t\tdimm->dtype = dtype;\n\t\t\tdimm->nr_pages  = MiB_TO_PAGES(dsize >> 20);\n\t\t\tdimm->edac_mode = EDAC_SECDED;\n\t\t\tsnprintf(dimm->label, sizeof(dimm->label),\n\t\t\t\t \"MC#%d_Chan#%d_DIMM#%d\", mc, i, j);\n\t\t\tedac_dbg(0, \"MC %d, Channel %d, DIMM %d, Size %llu MiB (%u pages)\\n\",\n\t\t\t\t mc, i, j, dsize >> 20, dimm->nr_pages);\n\n\t\t\tndimms++;\n\t\t}\n\n\t\tif (ndimms && !ecc) {\n\t\t\tigen6_printk(KERN_ERR, \"MC%d In-Band ECC is disabled\\n\", mc);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tedac_dbg(0, \"MC %d, total size %llu MiB\\n\", mc, imc->size >> 20);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_EDAC_DEBUG\n \nstatic u64 igen6_touud;\n#define TOUUD_OFFSET\t0xa8\n\nstatic void igen6_reg_dump(struct igen6_imc *imc)\n{\n\tint i;\n\n\tedac_dbg(2, \"CHANNEL_HASH     : 0x%x\\n\",\n\t\t readl(imc->window + CHANNEL_HASH_OFFSET));\n\tedac_dbg(2, \"CHANNEL_EHASH    : 0x%x\\n\",\n\t\t readl(imc->window + CHANNEL_EHASH_OFFSET));\n\tedac_dbg(2, \"MAD_INTER_CHANNEL: 0x%x\\n\",\n\t\t readl(imc->window + MAD_INTER_CHANNEL_OFFSET));\n\tedac_dbg(2, \"ECC_ERROR_LOG    : 0x%llx\\n\",\n\t\t readq(imc->window + ECC_ERROR_LOG_OFFSET));\n\n\tfor (i = 0; i < NUM_CHANNELS; i++) {\n\t\tedac_dbg(2, \"MAD_INTRA_CH%d    : 0x%x\\n\", i,\n\t\t\t readl(imc->window + MAD_INTRA_CH0_OFFSET + i * 4));\n\t\tedac_dbg(2, \"MAD_DIMM_CH%d     : 0x%x\\n\", i,\n\t\t\t readl(imc->window + MAD_DIMM_CH0_OFFSET + i * 4));\n\t}\n\tedac_dbg(2, \"TOLUD            : 0x%x\", igen6_tolud);\n\tedac_dbg(2, \"TOUUD            : 0x%llx\", igen6_touud);\n\tedac_dbg(2, \"TOM              : 0x%llx\", igen6_tom);\n}\n\nstatic struct dentry *igen6_test;\n\nstatic int debugfs_u64_set(void *data, u64 val)\n{\n\tu64 ecclog;\n\n\tif ((val >= igen6_tolud && val < _4GB) || val >= igen6_touud) {\n\t\tedac_dbg(0, \"Address 0x%llx out of range\\n\", val);\n\t\treturn 0;\n\t}\n\n\tpr_warn_once(\"Fake error to 0x%llx injected via debugfs\\n\", val);\n\n\tval  >>= ECC_ERROR_LOG_ADDR_SHIFT;\n\tecclog = (val << ECC_ERROR_LOG_ADDR_SHIFT) | ECC_ERROR_LOG_CE;\n\n\tif (!ecclog_gen_pool_add(0, ecclog))\n\t\tirq_work_queue(&ecclog_irq_work);\n\n\treturn 0;\n}\nDEFINE_SIMPLE_ATTRIBUTE(fops_u64_wo, NULL, debugfs_u64_set, \"%llu\\n\");\n\nstatic void igen6_debug_setup(void)\n{\n\tigen6_test = edac_debugfs_create_dir(\"igen6_test\");\n\tif (!igen6_test)\n\t\treturn;\n\n\tif (!edac_debugfs_create_file(\"addr\", 0200, igen6_test,\n\t\t\t\t      NULL, &fops_u64_wo)) {\n\t\tdebugfs_remove(igen6_test);\n\t\tigen6_test = NULL;\n\t}\n}\n\nstatic void igen6_debug_teardown(void)\n{\n\tdebugfs_remove_recursive(igen6_test);\n}\n#else\nstatic void igen6_reg_dump(struct igen6_imc *imc) {}\nstatic void igen6_debug_setup(void) {}\nstatic void igen6_debug_teardown(void) {}\n#endif\n\nstatic int igen6_pci_setup(struct pci_dev *pdev, u64 *mchbar)\n{\n\tunion  {\n\t\tu64 v;\n\t\tstruct {\n\t\t\tu32 v_lo;\n\t\t\tu32 v_hi;\n\t\t};\n\t} u;\n\n\tedac_dbg(2, \"\\n\");\n\n\tif (!res_cfg->ibecc_available(pdev)) {\n\t\tedac_dbg(2, \"No In-Band ECC IP\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (pci_read_config_dword(pdev, TOLUD_OFFSET, &igen6_tolud)) {\n\t\tigen6_printk(KERN_ERR, \"Failed to read TOLUD\\n\");\n\t\tgoto fail;\n\t}\n\n\tigen6_tolud &= GENMASK(31, 20);\n\n\tif (pci_read_config_dword(pdev, TOM_OFFSET, &u.v_lo)) {\n\t\tigen6_printk(KERN_ERR, \"Failed to read lower TOM\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (pci_read_config_dword(pdev, TOM_OFFSET + 4, &u.v_hi)) {\n\t\tigen6_printk(KERN_ERR, \"Failed to read upper TOM\\n\");\n\t\tgoto fail;\n\t}\n\n\tigen6_tom = u.v & GENMASK_ULL(38, 20);\n\n\tif (pci_read_config_dword(pdev, MCHBAR_OFFSET, &u.v_lo)) {\n\t\tigen6_printk(KERN_ERR, \"Failed to read lower MCHBAR\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (pci_read_config_dword(pdev, MCHBAR_OFFSET + 4, &u.v_hi)) {\n\t\tigen6_printk(KERN_ERR, \"Failed to read upper MCHBAR\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (!(u.v & MCHBAR_EN)) {\n\t\tigen6_printk(KERN_ERR, \"MCHBAR is disabled\\n\");\n\t\tgoto fail;\n\t}\n\n\t*mchbar = MCHBAR_BASE(u.v);\n\n#ifdef CONFIG_EDAC_DEBUG\n\tif (pci_read_config_dword(pdev, TOUUD_OFFSET, &u.v_lo))\n\t\tedac_dbg(2, \"Failed to read lower TOUUD\\n\");\n\telse if (pci_read_config_dword(pdev, TOUUD_OFFSET + 4, &u.v_hi))\n\t\tedac_dbg(2, \"Failed to read upper TOUUD\\n\");\n\telse\n\t\tigen6_touud = u.v & GENMASK_ULL(38, 20);\n#endif\n\n\treturn 0;\nfail:\n\treturn -ENODEV;\n}\n\nstatic int igen6_register_mci(int mc, u64 mchbar, struct pci_dev *pdev)\n{\n\tstruct edac_mc_layer layers[2];\n\tstruct mem_ctl_info *mci;\n\tstruct igen6_imc *imc;\n\tvoid __iomem *window;\n\tint rc;\n\n\tedac_dbg(2, \"\\n\");\n\n\tmchbar += mc * MCHBAR_SIZE;\n\twindow = ioremap(mchbar, MCHBAR_SIZE);\n\tif (!window) {\n\t\tigen6_printk(KERN_ERR, \"Failed to ioremap 0x%llx\\n\", mchbar);\n\t\treturn -ENODEV;\n\t}\n\n\tlayers[0].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[0].size = NUM_CHANNELS;\n\tlayers[0].is_virt_csrow = false;\n\tlayers[1].type = EDAC_MC_LAYER_SLOT;\n\tlayers[1].size = NUM_DIMMS;\n\tlayers[1].is_virt_csrow = true;\n\n\tmci = edac_mc_alloc(mc, ARRAY_SIZE(layers), layers, 0);\n\tif (!mci) {\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tmci->ctl_name = kasprintf(GFP_KERNEL, \"Intel_client_SoC MC#%d\", mc);\n\tif (!mci->ctl_name) {\n\t\trc = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\tmci->mtype_cap = MEM_FLAG_LPDDR4 | MEM_FLAG_DDR4;\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->dev_name = pci_name(pdev);\n\tmci->pvt_info = &igen6_pvt->imc[mc];\n\n\timc = mci->pvt_info;\n\tdevice_initialize(&imc->dev);\n\t \n\tmci->pdev = mc ? &imc->dev : &pdev->dev;\n\timc->mc\t= mc;\n\timc->pdev = pdev;\n\timc->window = window;\n\n\tigen6_reg_dump(imc);\n\n\trc = igen6_get_dimm_config(mci);\n\tif (rc)\n\t\tgoto fail3;\n\n\trc = edac_mc_add_mc(mci);\n\tif (rc) {\n\t\tigen6_printk(KERN_ERR, \"Failed to register mci#%d\\n\", mc);\n\t\tgoto fail3;\n\t}\n\n\timc->mci = mci;\n\treturn 0;\nfail3:\n\tkfree(mci->ctl_name);\nfail2:\n\tedac_mc_free(mci);\nfail:\n\tiounmap(window);\n\treturn rc;\n}\n\nstatic void igen6_unregister_mcis(void)\n{\n\tstruct mem_ctl_info *mci;\n\tstruct igen6_imc *imc;\n\tint i;\n\n\tedac_dbg(2, \"\\n\");\n\n\tfor (i = 0; i < res_cfg->num_imc; i++) {\n\t\timc = &igen6_pvt->imc[i];\n\t\tmci = imc->mci;\n\t\tif (!mci)\n\t\t\tcontinue;\n\n\t\tedac_mc_del_mc(mci->pdev);\n\t\tkfree(mci->ctl_name);\n\t\tedac_mc_free(mci);\n\t\tiounmap(imc->window);\n\t}\n}\n\nstatic int igen6_mem_slice_setup(u64 mchbar)\n{\n\tstruct igen6_imc *imc = &igen6_pvt->imc[0];\n\tu64 base = mchbar + res_cfg->cmf_base;\n\tu32 offset = res_cfg->ms_hash_offset;\n\tu32 size = res_cfg->cmf_size;\n\tu64 ms_s_size, ms_hash;\n\tvoid __iomem *cmf;\n\tint ms_l_map;\n\n\tedac_dbg(2, \"\\n\");\n\n\tif (imc[0].size < imc[1].size) {\n\t\tms_s_size = imc[0].size;\n\t\tms_l_map  = 1;\n\t} else {\n\t\tms_s_size = imc[1].size;\n\t\tms_l_map  = 0;\n\t}\n\n\tigen6_pvt->ms_s_size = ms_s_size;\n\tigen6_pvt->ms_l_map  = ms_l_map;\n\n\tedac_dbg(0, \"ms_s_size: %llu MiB, ms_l_map %d\\n\",\n\t\t ms_s_size >> 20, ms_l_map);\n\n\tif (!size)\n\t\treturn 0;\n\n\tcmf = ioremap(base, size);\n\tif (!cmf) {\n\t\tigen6_printk(KERN_ERR, \"Failed to ioremap cmf 0x%llx\\n\", base);\n\t\treturn -ENODEV;\n\t}\n\n\tms_hash = readq(cmf + offset);\n\tigen6_pvt->ms_hash = ms_hash;\n\n\tedac_dbg(0, \"MEM_SLICE_HASH: 0x%llx\\n\", ms_hash);\n\n\tiounmap(cmf);\n\n\treturn 0;\n}\n\nstatic int register_err_handler(void)\n{\n\tint rc;\n\n\tif (res_cfg->machine_check) {\n\t\tmce_register_decode_chain(&ecclog_mce_dec);\n\t\treturn 0;\n\t}\n\n\trc = register_nmi_handler(NMI_SERR, ecclog_nmi_handler,\n\t\t\t\t  0, IGEN6_NMI_NAME);\n\tif (rc) {\n\t\tigen6_printk(KERN_ERR, \"Failed to register NMI handler\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void unregister_err_handler(void)\n{\n\tif (res_cfg->machine_check) {\n\t\tmce_unregister_decode_chain(&ecclog_mce_dec);\n\t\treturn;\n\t}\n\n\tunregister_nmi_handler(NMI_SERR, IGEN6_NMI_NAME);\n}\n\nstatic int igen6_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tu64 mchbar;\n\tint i, rc;\n\n\tedac_dbg(2, \"\\n\");\n\n\tigen6_pvt = kzalloc(sizeof(*igen6_pvt), GFP_KERNEL);\n\tif (!igen6_pvt)\n\t\treturn -ENOMEM;\n\n\tres_cfg = (struct res_config *)ent->driver_data;\n\n\trc = igen6_pci_setup(pdev, &mchbar);\n\tif (rc)\n\t\tgoto fail;\n\n\tfor (i = 0; i < res_cfg->num_imc; i++) {\n\t\trc = igen6_register_mci(i, mchbar, pdev);\n\t\tif (rc)\n\t\t\tgoto fail2;\n\t}\n\n\tif (res_cfg->num_imc > 1) {\n\t\trc = igen6_mem_slice_setup(mchbar);\n\t\tif (rc)\n\t\t\tgoto fail2;\n\t}\n\n\tecclog_pool = ecclog_gen_pool_create();\n\tif (!ecclog_pool) {\n\t\trc = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\tINIT_WORK(&ecclog_work, ecclog_work_cb);\n\tinit_irq_work(&ecclog_irq_work, ecclog_irq_work_cb);\n\n\trc = register_err_handler();\n\tif (rc)\n\t\tgoto fail3;\n\n\t \n\trc = errcmd_enable_error_reporting(true);\n\tif (rc) {\n\t\tigen6_printk(KERN_ERR, \"Failed to enable error reporting\\n\");\n\t\tgoto fail4;\n\t}\n\n\t \n\tecclog_handler();\n\n\tigen6_debug_setup();\n\treturn 0;\nfail4:\n\tunregister_nmi_handler(NMI_SERR, IGEN6_NMI_NAME);\nfail3:\n\tgen_pool_destroy(ecclog_pool);\nfail2:\n\tigen6_unregister_mcis();\nfail:\n\tkfree(igen6_pvt);\n\treturn rc;\n}\n\nstatic void igen6_remove(struct pci_dev *pdev)\n{\n\tedac_dbg(2, \"\\n\");\n\n\tigen6_debug_teardown();\n\terrcmd_enable_error_reporting(false);\n\tunregister_err_handler();\n\tirq_work_sync(&ecclog_irq_work);\n\tflush_work(&ecclog_work);\n\tgen_pool_destroy(ecclog_pool);\n\tigen6_unregister_mcis();\n\tkfree(igen6_pvt);\n}\n\nstatic struct pci_driver igen6_driver = {\n\t.name     = EDAC_MOD_STR,\n\t.probe    = igen6_probe,\n\t.remove   = igen6_remove,\n\t.id_table = igen6_pci_tbl,\n};\n\nstatic int __init igen6_init(void)\n{\n\tconst char *owner;\n\tint rc;\n\n\tedac_dbg(2, \"\\n\");\n\n\tif (ghes_get_devices())\n\t\treturn -EBUSY;\n\n\towner = edac_get_owner();\n\tif (owner && strncmp(owner, EDAC_MOD_STR, sizeof(EDAC_MOD_STR)))\n\t\treturn -EBUSY;\n\n\tedac_op_state = EDAC_OPSTATE_NMI;\n\n\trc = pci_register_driver(&igen6_driver);\n\tif (rc)\n\t\treturn rc;\n\n\tigen6_printk(KERN_INFO, \"%s\\n\", IGEN6_REVISION);\n\n\treturn 0;\n}\n\nstatic void __exit igen6_exit(void)\n{\n\tedac_dbg(2, \"\\n\");\n\n\tpci_unregister_driver(&igen6_driver);\n}\n\nmodule_init(igen6_init);\nmodule_exit(igen6_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Qiuxu Zhuo\");\nMODULE_DESCRIPTION(\"MC Driver for Intel client SoC using In-Band ECC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}