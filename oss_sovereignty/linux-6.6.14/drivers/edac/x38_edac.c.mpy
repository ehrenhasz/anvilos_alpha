{
  "module_name": "x38_edac.c",
  "hash_id": "aff47fee7b27bd1218542d2645cf538410efeb732a09f5658ee4179107bbd02a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/edac/x38_edac.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/edac.h>\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include \"edac_module.h\"\n\n#define EDAC_MOD_STR\t\t\"x38_edac\"\n\n#define PCI_DEVICE_ID_INTEL_X38_HB\t0x29e0\n\n#define X38_RANKS\t\t8\n#define X38_RANKS_PER_CHANNEL\t4\n#define X38_CHANNELS\t\t2\n\n \n\n#define X38_MCHBAR_LOW\t0x48\t \n#define X38_MCHBAR_HIGH\t0x4c\n#define X38_MCHBAR_MASK\t0xfffffc000ULL\t \n#define X38_MMR_WINDOW_SIZE\t16384\n\n#define X38_TOM\t0xa0\t \n#define X38_TOM_MASK\t0x3ff\t \n#define X38_TOM_SHIFT 26\t \n\n#define X38_ERRSTS\t0xc8\t \n#define X38_ERRSTS_UE\t\t0x0002\n#define X38_ERRSTS_CE\t\t0x0001\n#define X38_ERRSTS_BITS\t(X38_ERRSTS_UE | X38_ERRSTS_CE)\n\n\n \n\n#define X38_C0DRB\t0x200\t \n#define X38_C1DRB\t0x600\t \n#define X38_DRB_MASK\t0x3ff\t \n#define X38_DRB_SHIFT 26\t \n\n#define X38_C0ECCERRLOG 0x280\t \n#define X38_C1ECCERRLOG 0x680\t \n#define X38_ECCERRLOG_CE\t0x1\n#define X38_ECCERRLOG_UE\t0x2\n#define X38_ECCERRLOG_RANK_BITS\t0x18000000\n#define X38_ECCERRLOG_SYNDROME_BITS\t0xff0000\n\n#define X38_CAPID0 0xe0\t \n\nstatic int x38_channel_num;\n\nstatic int how_many_channel(struct pci_dev *pdev)\n{\n\tunsigned char capid0_8b;  \n\n\tpci_read_config_byte(pdev, X38_CAPID0 + 8, &capid0_8b);\n\tif (capid0_8b & 0x20) {\t \n\t\tedac_dbg(0, \"In single channel mode\\n\");\n\t\tx38_channel_num = 1;\n\t} else {\n\t\tedac_dbg(0, \"In dual channel mode\\n\");\n\t\tx38_channel_num = 2;\n\t}\n\n\treturn x38_channel_num;\n}\n\nstatic unsigned long eccerrlog_syndrome(u64 log)\n{\n\treturn (log & X38_ECCERRLOG_SYNDROME_BITS) >> 16;\n}\n\nstatic int eccerrlog_row(int channel, u64 log)\n{\n\treturn ((log & X38_ECCERRLOG_RANK_BITS) >> 27) |\n\t\t(channel * X38_RANKS_PER_CHANNEL);\n}\n\nenum x38_chips {\n\tX38 = 0,\n};\n\nstruct x38_dev_info {\n\tconst char *ctl_name;\n};\n\nstruct x38_error_info {\n\tu16 errsts;\n\tu16 errsts2;\n\tu64 eccerrlog[X38_CHANNELS];\n};\n\nstatic const struct x38_dev_info x38_devs[] = {\n\t[X38] = {\n\t\t.ctl_name = \"x38\"},\n};\n\nstatic struct pci_dev *mci_pdev;\nstatic int x38_registered = 1;\n\n\nstatic void x38_clear_error_info(struct mem_ctl_info *mci)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(mci->pdev);\n\n\t \n\tpci_write_bits16(pdev, X38_ERRSTS, X38_ERRSTS_BITS,\n\t\t\t X38_ERRSTS_BITS);\n}\n\nstatic void x38_get_and_clear_error_info(struct mem_ctl_info *mci,\n\t\t\t\t struct x38_error_info *info)\n{\n\tstruct pci_dev *pdev;\n\tvoid __iomem *window = mci->pvt_info;\n\n\tpdev = to_pci_dev(mci->pdev);\n\n\t \n\tpci_read_config_word(pdev, X38_ERRSTS, &info->errsts);\n\tif (!(info->errsts & X38_ERRSTS_BITS))\n\t\treturn;\n\n\tinfo->eccerrlog[0] = lo_hi_readq(window + X38_C0ECCERRLOG);\n\tif (x38_channel_num == 2)\n\t\tinfo->eccerrlog[1] = lo_hi_readq(window + X38_C1ECCERRLOG);\n\n\tpci_read_config_word(pdev, X38_ERRSTS, &info->errsts2);\n\n\t \n\tif ((info->errsts ^ info->errsts2) & X38_ERRSTS_BITS) {\n\t\tinfo->eccerrlog[0] = lo_hi_readq(window + X38_C0ECCERRLOG);\n\t\tif (x38_channel_num == 2)\n\t\t\tinfo->eccerrlog[1] =\n\t\t\t\tlo_hi_readq(window + X38_C1ECCERRLOG);\n\t}\n\n\tx38_clear_error_info(mci);\n}\n\nstatic void x38_process_error_info(struct mem_ctl_info *mci,\n\t\t\t\tstruct x38_error_info *info)\n{\n\tint channel;\n\tu64 log;\n\n\tif (!(info->errsts & X38_ERRSTS_BITS))\n\t\treturn;\n\n\tif ((info->errsts ^ info->errsts2) & X38_ERRSTS_BITS) {\n\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\n\t\t\t\t     -1, -1, -1,\n\t\t\t\t     \"UE overwrote CE\", \"\");\n\t\tinfo->errsts = info->errsts2;\n\t}\n\n\tfor (channel = 0; channel < x38_channel_num; channel++) {\n\t\tlog = info->eccerrlog[channel];\n\t\tif (log & X38_ECCERRLOG_UE) {\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\n\t\t\t\t\t     0, 0, 0,\n\t\t\t\t\t     eccerrlog_row(channel, log),\n\t\t\t\t\t     -1, -1,\n\t\t\t\t\t     \"x38 UE\", \"\");\n\t\t} else if (log & X38_ECCERRLOG_CE) {\n\t\t\tedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\n\t\t\t\t\t     0, 0, eccerrlog_syndrome(log),\n\t\t\t\t\t     eccerrlog_row(channel, log),\n\t\t\t\t\t     -1, -1,\n\t\t\t\t\t     \"x38 CE\", \"\");\n\t\t}\n\t}\n}\n\nstatic void x38_check(struct mem_ctl_info *mci)\n{\n\tstruct x38_error_info info;\n\n\tx38_get_and_clear_error_info(mci, &info);\n\tx38_process_error_info(mci, &info);\n}\n\nstatic void __iomem *x38_map_mchbar(struct pci_dev *pdev)\n{\n\tunion {\n\t\tu64 mchbar;\n\t\tstruct {\n\t\t\tu32 mchbar_low;\n\t\t\tu32 mchbar_high;\n\t\t};\n\t} u;\n\tvoid __iomem *window;\n\n\tpci_read_config_dword(pdev, X38_MCHBAR_LOW, &u.mchbar_low);\n\tpci_write_config_dword(pdev, X38_MCHBAR_LOW, u.mchbar_low | 0x1);\n\tpci_read_config_dword(pdev, X38_MCHBAR_HIGH, &u.mchbar_high);\n\tu.mchbar &= X38_MCHBAR_MASK;\n\n\tif (u.mchbar != (resource_size_t)u.mchbar) {\n\t\tprintk(KERN_ERR\n\t\t\t\"x38: mmio space beyond accessible range (0x%llx)\\n\",\n\t\t\t(unsigned long long)u.mchbar);\n\t\treturn NULL;\n\t}\n\n\twindow = ioremap(u.mchbar, X38_MMR_WINDOW_SIZE);\n\tif (!window)\n\t\tprintk(KERN_ERR \"x38: cannot map mmio space at 0x%llx\\n\",\n\t\t\t(unsigned long long)u.mchbar);\n\n\treturn window;\n}\n\n\nstatic void x38_get_drbs(void __iomem *window,\n\t\t\tu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL])\n{\n\tint i;\n\n\tfor (i = 0; i < X38_RANKS_PER_CHANNEL; i++) {\n\t\tdrbs[0][i] = readw(window + X38_C0DRB + 2*i) & X38_DRB_MASK;\n\t\tdrbs[1][i] = readw(window + X38_C1DRB + 2*i) & X38_DRB_MASK;\n\t}\n}\n\nstatic bool x38_is_stacked(struct pci_dev *pdev,\n\t\t\tu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL])\n{\n\tu16 tom;\n\n\tpci_read_config_word(pdev, X38_TOM, &tom);\n\ttom &= X38_TOM_MASK;\n\n\treturn drbs[X38_CHANNELS - 1][X38_RANKS_PER_CHANNEL - 1] == tom;\n}\n\nstatic unsigned long drb_to_nr_pages(\n\t\t\tu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL],\n\t\t\tbool stacked, int channel, int rank)\n{\n\tint n;\n\n\tn = drbs[channel][rank];\n\tif (rank > 0)\n\t\tn -= drbs[channel][rank - 1];\n\tif (stacked && (channel == 1) && drbs[channel][rank] ==\n\t\t\t\tdrbs[channel][X38_RANKS_PER_CHANNEL - 1]) {\n\t\tn -= drbs[0][X38_RANKS_PER_CHANNEL - 1];\n\t}\n\n\tn <<= (X38_DRB_SHIFT - PAGE_SHIFT);\n\treturn n;\n}\n\nstatic int x38_probe1(struct pci_dev *pdev, int dev_idx)\n{\n\tint rc;\n\tint i, j;\n\tstruct mem_ctl_info *mci = NULL;\n\tstruct edac_mc_layer layers[2];\n\tu16 drbs[X38_CHANNELS][X38_RANKS_PER_CHANNEL];\n\tbool stacked;\n\tvoid __iomem *window;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\twindow = x38_map_mchbar(pdev);\n\tif (!window)\n\t\treturn -ENODEV;\n\n\tx38_get_drbs(window, drbs);\n\n\thow_many_channel(pdev);\n\n\t \n\tlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\n\tlayers[0].size = X38_RANKS;\n\tlayers[0].is_virt_csrow = true;\n\tlayers[1].type = EDAC_MC_LAYER_CHANNEL;\n\tlayers[1].size = x38_channel_num;\n\tlayers[1].is_virt_csrow = false;\n\tmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, 0);\n\tif (!mci)\n\t\treturn -ENOMEM;\n\n\tedac_dbg(3, \"MC: init mci\\n\");\n\n\tmci->pdev = &pdev->dev;\n\tmci->mtype_cap = MEM_FLAG_DDR2;\n\n\tmci->edac_ctl_cap = EDAC_FLAG_SECDED;\n\tmci->edac_cap = EDAC_FLAG_SECDED;\n\n\tmci->mod_name = EDAC_MOD_STR;\n\tmci->ctl_name = x38_devs[dev_idx].ctl_name;\n\tmci->dev_name = pci_name(pdev);\n\tmci->edac_check = x38_check;\n\tmci->ctl_page_to_phys = NULL;\n\tmci->pvt_info = window;\n\n\tstacked = x38_is_stacked(pdev, drbs);\n\n\t \n\tfor (i = 0; i < mci->nr_csrows; i++) {\n\t\tunsigned long nr_pages;\n\t\tstruct csrow_info *csrow = mci->csrows[i];\n\n\t\tnr_pages = drb_to_nr_pages(drbs, stacked,\n\t\t\ti / X38_RANKS_PER_CHANNEL,\n\t\t\ti % X38_RANKS_PER_CHANNEL);\n\n\t\tif (nr_pages == 0)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < x38_channel_num; j++) {\n\t\t\tstruct dimm_info *dimm = csrow->channels[j]->dimm;\n\n\t\t\tdimm->nr_pages = nr_pages / x38_channel_num;\n\t\t\tdimm->grain = nr_pages << PAGE_SHIFT;\n\t\t\tdimm->mtype = MEM_DDR2;\n\t\t\tdimm->dtype = DEV_UNKNOWN;\n\t\t\tdimm->edac_mode = EDAC_UNKNOWN;\n\t\t}\n\t}\n\n\tx38_clear_error_info(mci);\n\n\trc = -ENODEV;\n\tif (edac_mc_add_mc(mci)) {\n\t\tedac_dbg(3, \"MC: failed edac_mc_add_mc()\\n\");\n\t\tgoto fail;\n\t}\n\n\t \n\tedac_dbg(3, \"MC: success\\n\");\n\treturn 0;\n\nfail:\n\tiounmap(window);\n\tif (mci)\n\t\tedac_mc_free(mci);\n\n\treturn rc;\n}\n\nstatic int x38_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint rc;\n\n\tedac_dbg(0, \"MC:\\n\");\n\n\tif (pci_enable_device(pdev) < 0)\n\t\treturn -EIO;\n\n\trc = x38_probe1(pdev, ent->driver_data);\n\tif (!mci_pdev)\n\t\tmci_pdev = pci_dev_get(pdev);\n\n\treturn rc;\n}\n\nstatic void x38_remove_one(struct pci_dev *pdev)\n{\n\tstruct mem_ctl_info *mci;\n\n\tedac_dbg(0, \"\\n\");\n\n\tmci = edac_mc_del_mc(&pdev->dev);\n\tif (!mci)\n\t\treturn;\n\n\tiounmap(mci->pvt_info);\n\n\tedac_mc_free(mci);\n}\n\nstatic const struct pci_device_id x38_pci_tbl[] = {\n\t{\n\t PCI_VEND_DEV(INTEL, X38_HB), PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t X38},\n\t{\n\t 0,\n\t }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, x38_pci_tbl);\n\nstatic struct pci_driver x38_driver = {\n\t.name = EDAC_MOD_STR,\n\t.probe = x38_init_one,\n\t.remove = x38_remove_one,\n\t.id_table = x38_pci_tbl,\n};\n\nstatic int __init x38_init(void)\n{\n\tint pci_rc;\n\n\tedac_dbg(3, \"MC:\\n\");\n\n\t \n\topstate_init();\n\n\tpci_rc = pci_register_driver(&x38_driver);\n\tif (pci_rc < 0)\n\t\tgoto fail0;\n\n\tif (!mci_pdev) {\n\t\tx38_registered = 0;\n\t\tmci_pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t\tPCI_DEVICE_ID_INTEL_X38_HB, NULL);\n\t\tif (!mci_pdev) {\n\t\t\tedac_dbg(0, \"x38 pci_get_device fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tpci_rc = x38_init_one(mci_pdev, x38_pci_tbl);\n\t\tif (pci_rc < 0) {\n\t\t\tedac_dbg(0, \"x38 init fail\\n\");\n\t\t\tpci_rc = -ENODEV;\n\t\t\tgoto fail1;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail1:\n\tpci_unregister_driver(&x38_driver);\n\nfail0:\n\tpci_dev_put(mci_pdev);\n\n\treturn pci_rc;\n}\n\nstatic void __exit x38_exit(void)\n{\n\tedac_dbg(3, \"MC:\\n\");\n\n\tpci_unregister_driver(&x38_driver);\n\tif (!x38_registered) {\n\t\tx38_remove_one(mci_pdev);\n\t\tpci_dev_put(mci_pdev);\n\t}\n}\n\nmodule_init(x38_init);\nmodule_exit(x38_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cluster Computing, Inc. Hitoshi Mitake\");\nMODULE_DESCRIPTION(\"MC support for Intel X38 memory hub controllers\");\n\nmodule_param(edac_op_state, int, 0444);\nMODULE_PARM_DESC(edac_op_state, \"EDAC Error Reporting state: 0=Poll,1=NMI\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}