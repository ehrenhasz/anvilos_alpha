{
  "module_name": "scsi_error.c",
  "hash_id": "dad802624a064fb04e9c191b57c05f79712e3208f2a2ee7dc9ef22e2056d9989",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_error.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/scsi_dh.h>\n#include <scsi/scsi_devinfo.h>\n#include <scsi/sg.h>\n\n#include \"scsi_priv.h\"\n#include \"scsi_logging.h\"\n#include \"scsi_transport_api.h\"\n\n#include <trace/events/scsi.h>\n\n#include <asm/unaligned.h>\n\n \n#define BUS_RESET_SETTLE_TIME   (10)\n#define HOST_RESET_SETTLE_TIME  (10)\n\nstatic int scsi_eh_try_stu(struct scsi_cmnd *scmd);\nstatic enum scsi_disposition scsi_try_to_abort_cmd(const struct scsi_host_template *,\n\t\t\t\t\t\t   struct scsi_cmnd *);\n\nvoid scsi_eh_wakeup(struct Scsi_Host *shost)\n{\n\tlockdep_assert_held(shost->host_lock);\n\n\tif (scsi_host_busy(shost) == shost->host_failed) {\n\t\ttrace_scsi_eh_wakeup(shost);\n\t\twake_up_process(shost->ehandler);\n\t\tSCSI_LOG_ERROR_RECOVERY(5, shost_printk(KERN_INFO, shost,\n\t\t\t\"Waking error handler thread\\n\"));\n\t}\n}\n\n \nvoid scsi_schedule_eh(struct Scsi_Host *shost)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\tif (scsi_host_set_state(shost, SHOST_RECOVERY) == 0 ||\n\t    scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY) == 0) {\n\t\tshost->host_eh_scheduled++;\n\t\tscsi_eh_wakeup(shost);\n\t}\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\nEXPORT_SYMBOL_GPL(scsi_schedule_eh);\n\nstatic int scsi_host_eh_past_deadline(struct Scsi_Host *shost)\n{\n\tif (!shost->last_reset || shost->eh_deadline == -1)\n\t\treturn 0;\n\n\t \n\tif (time_before(jiffies, shost->last_reset + shost->eh_deadline) &&\n\t    shost->eh_deadline > -1)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic bool scsi_cmd_retry_allowed(struct scsi_cmnd *cmd)\n{\n\tif (cmd->allowed == SCSI_CMD_RETRIES_NO_LIMIT)\n\t\treturn true;\n\n\treturn ++cmd->retries <= cmd->allowed;\n}\n\nstatic bool scsi_eh_should_retry_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct Scsi_Host *host = sdev->host;\n\n\tif (host->hostt->eh_should_retry_cmd)\n\t\treturn  host->hostt->eh_should_retry_cmd(cmd);\n\n\treturn true;\n}\n\n \nvoid\nscmd_eh_abort_handler(struct work_struct *work)\n{\n\tstruct scsi_cmnd *scmd =\n\t\tcontainer_of(work, struct scsi_cmnd, abort_work.work);\n\tstruct scsi_device *sdev = scmd->device;\n\tstruct Scsi_Host *shost = sdev->host;\n\tenum scsi_disposition rtn;\n\tunsigned long flags;\n\n\tif (scsi_host_eh_past_deadline(shost)) {\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t\t    \"eh timeout, not aborting\\n\"));\n\t\tgoto out;\n\t}\n\n\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t\t    \"aborting command\\n\"));\n\trtn = scsi_try_to_abort_cmd(shost->hostt, scmd);\n\tif (rtn != SUCCESS) {\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t\t    \"cmd abort %s\\n\",\n\t\t\t\t    (rtn == FAST_IO_FAIL) ?\n\t\t\t\t    \"not send\" : \"failed\"));\n\t\tgoto out;\n\t}\n\tset_host_byte(scmd, DID_TIME_OUT);\n\tif (scsi_host_eh_past_deadline(shost)) {\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t\t    \"eh timeout, not retrying \"\n\t\t\t\t    \"aborted command\\n\"));\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_del_init(&scmd->eh_entry);\n\n\t \n\tif (list_empty(&shost->eh_abort_list) &&\n\t    list_empty(&shost->eh_cmd_q))\n\t\tif (shost->eh_deadline != -1)\n\t\t\tshost->last_reset = 0;\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (!scsi_noretry_cmd(scmd) &&\n\t    scsi_cmd_retry_allowed(scmd) &&\n\t    scsi_eh_should_retry_cmd(scmd)) {\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tscmd_printk(KERN_WARNING, scmd,\n\t\t\t\t    \"retry aborted command\\n\"));\n\t\tscsi_queue_insert(scmd, SCSI_MLQUEUE_EH_RETRY);\n\t} else {\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tscmd_printk(KERN_WARNING, scmd,\n\t\t\t\t    \"finish aborted command\\n\"));\n\t\tscsi_finish_command(scmd);\n\t}\n\treturn;\n\nout:\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_del_init(&scmd->eh_entry);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tscsi_eh_scmd_add(scmd);\n}\n\n \nstatic int\nscsi_abort_command(struct scsi_cmnd *scmd)\n{\n\tstruct scsi_device *sdev = scmd->device;\n\tstruct Scsi_Host *shost = sdev->host;\n\tunsigned long flags;\n\n\tif (!shost->hostt->eh_abort_handler) {\n\t\t \n\t\treturn FAILED;\n\t}\n\n\tif (scmd->eh_eflags & SCSI_EH_ABORT_SCHEDULED) {\n\t\t \n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t\t    \"previous abort failed\\n\"));\n\t\tBUG_ON(delayed_work_pending(&scmd->abort_work));\n\t\treturn FAILED;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (shost->eh_deadline != -1 && !shost->last_reset)\n\t\tshost->last_reset = jiffies;\n\tBUG_ON(!list_empty(&scmd->eh_entry));\n\tlist_add_tail(&scmd->eh_entry, &shost->eh_abort_list);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tscmd->eh_eflags |= SCSI_EH_ABORT_SCHEDULED;\n\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\tscmd_printk(KERN_INFO, scmd, \"abort scheduled\\n\"));\n\tqueue_delayed_work(shost->tmf_work_q, &scmd->abort_work, HZ / 100);\n\treturn SUCCESS;\n}\n\n \nstatic void scsi_eh_reset(struct scsi_cmnd *scmd)\n{\n\tif (!blk_rq_is_passthrough(scsi_cmd_to_rq(scmd))) {\n\t\tstruct scsi_driver *sdrv = scsi_cmd_to_driver(scmd);\n\t\tif (sdrv->eh_reset)\n\t\t\tsdrv->eh_reset(scmd);\n\t}\n}\n\nstatic void scsi_eh_inc_host_failed(struct rcu_head *head)\n{\n\tstruct scsi_cmnd *scmd = container_of(head, typeof(*scmd), rcu);\n\tstruct Scsi_Host *shost = scmd->device->host;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tshost->host_failed++;\n\tscsi_eh_wakeup(shost);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n \nvoid scsi_eh_scmd_add(struct scsi_cmnd *scmd)\n{\n\tstruct Scsi_Host *shost = scmd->device->host;\n\tunsigned long flags;\n\tint ret;\n\n\tWARN_ON_ONCE(!shost->ehandler);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (scsi_host_set_state(shost, SHOST_RECOVERY)) {\n\t\tret = scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY);\n\t\tWARN_ON_ONCE(ret);\n\t}\n\tif (shost->eh_deadline != -1 && !shost->last_reset)\n\t\tshost->last_reset = jiffies;\n\n\tscsi_eh_reset(scmd);\n\tlist_add_tail(&scmd->eh_entry, &shost->eh_cmd_q);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t \n\tcall_rcu_hurry(&scmd->rcu, scsi_eh_inc_host_failed);\n}\n\n \nenum blk_eh_timer_return scsi_timeout(struct request *req)\n{\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(req);\n\tstruct Scsi_Host *host = scmd->device->host;\n\n\ttrace_scsi_dispatch_cmd_timeout(scmd);\n\tscsi_log_completion(scmd, TIMEOUT_ERROR);\n\n\tatomic_inc(&scmd->device->iotmo_cnt);\n\tif (host->eh_deadline != -1 && !host->last_reset)\n\t\thost->last_reset = jiffies;\n\n\tif (host->hostt->eh_timed_out) {\n\t\tswitch (host->hostt->eh_timed_out(scmd)) {\n\t\tcase SCSI_EH_DONE:\n\t\t\treturn BLK_EH_DONE;\n\t\tcase SCSI_EH_RESET_TIMER:\n\t\t\treturn BLK_EH_RESET_TIMER;\n\t\tcase SCSI_EH_NOT_HANDLED:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (test_and_set_bit(SCMD_STATE_COMPLETE, &scmd->state))\n\t\treturn BLK_EH_DONE;\n\tatomic_inc(&scmd->device->iodone_cnt);\n\tif (scsi_abort_command(scmd) != SUCCESS) {\n\t\tset_host_byte(scmd, DID_TIME_OUT);\n\t\tscsi_eh_scmd_add(scmd);\n\t}\n\n\treturn BLK_EH_DONE;\n}\n\n \nint scsi_block_when_processing_errors(struct scsi_device *sdev)\n{\n\tint online;\n\n\twait_event(sdev->host->host_wait, !scsi_host_in_recovery(sdev->host));\n\n\tonline = scsi_device_online(sdev);\n\n\treturn online;\n}\nEXPORT_SYMBOL(scsi_block_when_processing_errors);\n\n#ifdef CONFIG_SCSI_LOGGING\n \nstatic inline void scsi_eh_prt_fail_stats(struct Scsi_Host *shost,\n\t\t\t\t\t  struct list_head *work_q)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct scsi_device *sdev;\n\tint total_failures = 0;\n\tint cmd_failed = 0;\n\tint cmd_cancel = 0;\n\tint devices_failed = 0;\n\n\tshost_for_each_device(sdev, shost) {\n\t\tlist_for_each_entry(scmd, work_q, eh_entry) {\n\t\t\tif (scmd->device == sdev) {\n\t\t\t\t++total_failures;\n\t\t\t\tif (scmd->eh_eflags & SCSI_EH_ABORT_SCHEDULED)\n\t\t\t\t\t++cmd_cancel;\n\t\t\t\telse\n\t\t\t\t\t++cmd_failed;\n\t\t\t}\n\t\t}\n\n\t\tif (cmd_cancel || cmd_failed) {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t\t    \"%s: cmds failed: %d, cancel: %d\\n\",\n\t\t\t\t\t    __func__, cmd_failed,\n\t\t\t\t\t    cmd_cancel));\n\t\t\tcmd_cancel = 0;\n\t\t\tcmd_failed = 0;\n\t\t\t++devices_failed;\n\t\t}\n\t}\n\n\tSCSI_LOG_ERROR_RECOVERY(2, shost_printk(KERN_INFO, shost,\n\t\t\t\t   \"Total of %d commands on %d\"\n\t\t\t\t   \" devices require eh work\\n\",\n\t\t\t\t   total_failures, devices_failed));\n}\n#endif\n\n  \nstatic void scsi_report_lun_change(struct scsi_device *sdev)\n{\n\tsdev->sdev_target->expecting_lun_change = 1;\n}\n\n \nstatic void scsi_report_sense(struct scsi_device *sdev,\n\t\t\t      struct scsi_sense_hdr *sshdr)\n{\n\tenum scsi_device_event evt_type = SDEV_EVT_MAXBITS;\t \n\n\tif (sshdr->sense_key == UNIT_ATTENTION) {\n\t\tif (sshdr->asc == 0x3f && sshdr->ascq == 0x03) {\n\t\t\tevt_type = SDEV_EVT_INQUIRY_CHANGE_REPORTED;\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"Inquiry data has changed\");\n\t\t} else if (sshdr->asc == 0x3f && sshdr->ascq == 0x0e) {\n\t\t\tevt_type = SDEV_EVT_LUN_CHANGE_REPORTED;\n\t\t\tscsi_report_lun_change(sdev);\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"LUN assignments on this target have \"\n\t\t\t\t    \"changed. The Linux SCSI layer does not \"\n\t\t\t\t    \"automatically remap LUN assignments.\\n\");\n\t\t} else if (sshdr->asc == 0x3f)\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"Operating parameters on this target have \"\n\t\t\t\t    \"changed. The Linux SCSI layer does not \"\n\t\t\t\t    \"automatically adjust these parameters.\\n\");\n\n\t\tif (sshdr->asc == 0x38 && sshdr->ascq == 0x07) {\n\t\t\tevt_type = SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED;\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"Warning! Received an indication that the \"\n\t\t\t\t    \"LUN reached a thin provisioning soft \"\n\t\t\t\t    \"threshold.\\n\");\n\t\t}\n\n\t\tif (sshdr->asc == 0x29) {\n\t\t\tevt_type = SDEV_EVT_POWER_ON_RESET_OCCURRED;\n\t\t\t \n\t\t\tif (!sdev->silence_suspend)\n\t\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t\t    \"Power-on or device reset occurred\\n\");\n\t\t}\n\n\t\tif (sshdr->asc == 0x2a && sshdr->ascq == 0x01) {\n\t\t\tevt_type = SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED;\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"Mode parameters changed\");\n\t\t} else if (sshdr->asc == 0x2a && sshdr->ascq == 0x06) {\n\t\t\tevt_type = SDEV_EVT_ALUA_STATE_CHANGE_REPORTED;\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"Asymmetric access state changed\");\n\t\t} else if (sshdr->asc == 0x2a && sshdr->ascq == 0x09) {\n\t\t\tevt_type = SDEV_EVT_CAPACITY_CHANGE_REPORTED;\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"Capacity data has changed\");\n\t\t} else if (sshdr->asc == 0x2a)\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"Parameters changed\");\n\t}\n\n\tif (evt_type != SDEV_EVT_MAXBITS) {\n\t\tset_bit(evt_type, sdev->pending_events);\n\t\tschedule_work(&sdev->event_work);\n\t}\n}\n\nstatic inline void set_scsi_ml_byte(struct scsi_cmnd *cmd, u8 status)\n{\n\tcmd->result = (cmd->result & 0xffff00ff) | (status << 8);\n}\n\n \nenum scsi_disposition scsi_check_sense(struct scsi_cmnd *scmd)\n{\n\tstruct request *req = scsi_cmd_to_rq(scmd);\n\tstruct scsi_device *sdev = scmd->device;\n\tstruct scsi_sense_hdr sshdr;\n\n\tif (! scsi_command_normalize_sense(scmd, &sshdr))\n\t\treturn FAILED;\t \n\n\tscsi_report_sense(sdev, &sshdr);\n\n\tif (scsi_sense_is_deferred(&sshdr))\n\t\treturn NEEDS_RETRY;\n\n\tif (sdev->handler && sdev->handler->check_sense) {\n\t\tenum scsi_disposition rc;\n\n\t\trc = sdev->handler->check_sense(sdev, &sshdr);\n\t\tif (rc != SCSI_RETURN_NOT_HANDLED)\n\t\t\treturn rc;\n\t\t \n\t}\n\n\tif (scmd->cmnd[0] == TEST_UNIT_READY &&\n\t    scmd->submitter != SUBMITTED_BY_SCSI_ERROR_HANDLER)\n\t\t \n\t\treturn SUCCESS;\n\n\t \n\tif (sshdr.response_code == 0x70) {\n\t\t \n\t\tif (scmd->sense_buffer[2] & 0xe0)\n\t\t\treturn SUCCESS;\n\t} else {\n\t\t \n\t\tif ((sshdr.additional_length > 3) &&\n\t\t    (scmd->sense_buffer[8] == 0x4) &&\n\t\t    (scmd->sense_buffer[11] & 0xe0))\n\t\t\treturn SUCCESS;\n\t}\n\n\tswitch (sshdr.sense_key) {\n\tcase NO_SENSE:\n\t\treturn SUCCESS;\n\tcase RECOVERED_ERROR:\n\t\treturn   SUCCESS;\n\n\tcase ABORTED_COMMAND:\n\t\tif (sshdr.asc == 0x10)  \n\t\t\treturn SUCCESS;\n\n\t\t \n\t\tif (sshdr.asc == 0x2e &&\n\t\t    sshdr.ascq >= 0x01 && sshdr.ascq <= 0x03) {\n\t\t\tset_scsi_ml_byte(scmd, SCSIML_STAT_DL_TIMEOUT);\n\t\t\treq->cmd_flags |= REQ_FAILFAST_DEV;\n\t\t\treq->rq_flags |= RQF_QUIET;\n\t\t\treturn SUCCESS;\n\t\t}\n\n\t\tif (sshdr.asc == 0x44 && sdev->sdev_bflags & BLIST_RETRY_ITF)\n\t\t\treturn ADD_TO_MLQUEUE;\n\t\tif (sshdr.asc == 0xc1 && sshdr.ascq == 0x01 &&\n\t\t    sdev->sdev_bflags & BLIST_RETRY_ASC_C1)\n\t\t\treturn ADD_TO_MLQUEUE;\n\n\t\treturn NEEDS_RETRY;\n\tcase NOT_READY:\n\tcase UNIT_ATTENTION:\n\t\t \n\t\tif (scmd->device->expecting_cc_ua) {\n\t\t\t \n\t\t\tif (sshdr.asc != 0x28 || sshdr.ascq != 0x00) {\n\t\t\t\tscmd->device->expecting_cc_ua = 0;\n\t\t\t\treturn NEEDS_RETRY;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (scmd->device->sdev_target->expecting_lun_change &&\n\t\t    sshdr.asc == 0x3f && sshdr.ascq == 0x0e)\n\t\t\treturn NEEDS_RETRY;\n\t\t \n\t\tif ((sshdr.asc == 0x04) && (sshdr.ascq == 0x01))\n\t\t\treturn NEEDS_RETRY;\n\t\t \n\t\tif (scmd->device->allow_restart &&\n\t\t    (sshdr.asc == 0x04) && (sshdr.ascq == 0x02))\n\t\t\treturn FAILED;\n\t\t \n\t\treturn SUCCESS;\n\n\t\t \n\tcase DATA_PROTECT:\n\t\tif (sshdr.asc == 0x27 && sshdr.ascq == 0x07) {\n\t\t\t \n\t\t\tset_scsi_ml_byte(scmd, SCSIML_STAT_NOSPC);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tfallthrough;\n\tcase COPY_ABORTED:\n\tcase VOLUME_OVERFLOW:\n\tcase MISCOMPARE:\n\tcase BLANK_CHECK:\n\t\tset_scsi_ml_byte(scmd, SCSIML_STAT_TGT_FAILURE);\n\t\treturn SUCCESS;\n\n\tcase MEDIUM_ERROR:\n\t\tif (sshdr.asc == 0x11 ||  \n\t\t    sshdr.asc == 0x13 ||  \n\t\t    sshdr.asc == 0x14) {  \n\t\t\tset_scsi_ml_byte(scmd, SCSIML_STAT_MED_ERROR);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\treturn NEEDS_RETRY;\n\n\tcase HARDWARE_ERROR:\n\t\tif (scmd->device->retry_hwerror)\n\t\t\treturn ADD_TO_MLQUEUE;\n\t\telse\n\t\t\tset_scsi_ml_byte(scmd, SCSIML_STAT_TGT_FAILURE);\n\t\tfallthrough;\n\n\tcase ILLEGAL_REQUEST:\n\t\tif (sshdr.asc == 0x20 ||  \n\t\t    sshdr.asc == 0x21 ||  \n\t\t    sshdr.asc == 0x22 ||  \n\t\t    sshdr.asc == 0x24 ||  \n\t\t    sshdr.asc == 0x26 ||  \n\t\t    sshdr.asc == 0x27) {  \n\t\t\tset_scsi_ml_byte(scmd, SCSIML_STAT_TGT_FAILURE);\n\t\t}\n\t\treturn SUCCESS;\n\n\tcase COMPLETED:\n\t\tif (sshdr.asc == 0x55 && sshdr.ascq == 0x0a) {\n\t\t\tset_scsi_ml_byte(scmd, SCSIML_STAT_DL_TIMEOUT);\n\t\t\treq->cmd_flags |= REQ_FAILFAST_DEV;\n\t\t\treq->rq_flags |= RQF_QUIET;\n\t\t}\n\t\treturn SUCCESS;\n\n\tdefault:\n\t\treturn SUCCESS;\n\t}\n}\nEXPORT_SYMBOL_GPL(scsi_check_sense);\n\nstatic void scsi_handle_queue_ramp_up(struct scsi_device *sdev)\n{\n\tconst struct scsi_host_template *sht = sdev->host->hostt;\n\tstruct scsi_device *tmp_sdev;\n\n\tif (!sht->track_queue_depth ||\n\t    sdev->queue_depth >= sdev->max_queue_depth)\n\t\treturn;\n\n\tif (time_before(jiffies,\n\t    sdev->last_queue_ramp_up + sdev->queue_ramp_up_period))\n\t\treturn;\n\n\tif (time_before(jiffies,\n\t    sdev->last_queue_full_time + sdev->queue_ramp_up_period))\n\t\treturn;\n\n\t \n\tshost_for_each_device(tmp_sdev, sdev->host) {\n\t\tif (tmp_sdev->channel != sdev->channel ||\n\t\t    tmp_sdev->id != sdev->id ||\n\t\t    tmp_sdev->queue_depth == sdev->max_queue_depth)\n\t\t\tcontinue;\n\n\t\tscsi_change_queue_depth(tmp_sdev, tmp_sdev->queue_depth + 1);\n\t\tsdev->last_queue_ramp_up = jiffies;\n\t}\n}\n\nstatic void scsi_handle_queue_full(struct scsi_device *sdev)\n{\n\tconst struct scsi_host_template *sht = sdev->host->hostt;\n\tstruct scsi_device *tmp_sdev;\n\n\tif (!sht->track_queue_depth)\n\t\treturn;\n\n\tshost_for_each_device(tmp_sdev, sdev->host) {\n\t\tif (tmp_sdev->channel != sdev->channel ||\n\t\t    tmp_sdev->id != sdev->id)\n\t\t\tcontinue;\n\t\t \n\t\tscsi_track_queue_full(tmp_sdev, tmp_sdev->queue_depth - 1);\n\t}\n}\n\n \nstatic enum scsi_disposition scsi_eh_completed_normally(struct scsi_cmnd *scmd)\n{\n\t \n\tif (host_byte(scmd->result) == DID_RESET) {\n\t\t \n\t\treturn scsi_check_sense(scmd);\n\t}\n\tif (host_byte(scmd->result) != DID_OK)\n\t\treturn FAILED;\n\n\t \n\tswitch (get_status_byte(scmd)) {\n\tcase SAM_STAT_GOOD:\n\t\tscsi_handle_queue_ramp_up(scmd->device);\n\t\tif (scmd->sense_buffer && SCSI_SENSE_VALID(scmd))\n\t\t\t \n\t\t\tscsi_check_sense(scmd);\n\t\tfallthrough;\n\tcase SAM_STAT_COMMAND_TERMINATED:\n\t\treturn SUCCESS;\n\tcase SAM_STAT_CHECK_CONDITION:\n\t\treturn scsi_check_sense(scmd);\n\tcase SAM_STAT_CONDITION_MET:\n\tcase SAM_STAT_INTERMEDIATE:\n\tcase SAM_STAT_INTERMEDIATE_CONDITION_MET:\n\t\t \n\t\treturn SUCCESS;\n\tcase SAM_STAT_RESERVATION_CONFLICT:\n\t\tif (scmd->cmnd[0] == TEST_UNIT_READY)\n\t\t\t \n\t\t\treturn SUCCESS;\n\t\t \n\t\treturn FAILED;\n\tcase SAM_STAT_TASK_SET_FULL:\n\t\tscsi_handle_queue_full(scmd->device);\n\t\tfallthrough;\n\tcase SAM_STAT_BUSY:\n\t\treturn NEEDS_RETRY;\n\tdefault:\n\t\treturn FAILED;\n\t}\n\treturn FAILED;\n}\n\n \nvoid scsi_eh_done(struct scsi_cmnd *scmd)\n{\n\tstruct completion *eh_action;\n\n\tSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\n\t\t\t\"%s result: %x\\n\", __func__, scmd->result));\n\n\teh_action = scmd->device->host->eh_action;\n\tif (eh_action)\n\t\tcomplete(eh_action);\n}\n\n \nstatic enum scsi_disposition scsi_try_host_reset(struct scsi_cmnd *scmd)\n{\n\tunsigned long flags;\n\tenum scsi_disposition rtn;\n\tstruct Scsi_Host *host = scmd->device->host;\n\tconst struct scsi_host_template *hostt = host->hostt;\n\n\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\tshost_printk(KERN_INFO, host, \"Snd Host RST\\n\"));\n\n\tif (!hostt->eh_host_reset_handler)\n\t\treturn FAILED;\n\n\trtn = hostt->eh_host_reset_handler(scmd);\n\n\tif (rtn == SUCCESS) {\n\t\tif (!hostt->skip_settle_delay)\n\t\t\tssleep(HOST_RESET_SETTLE_TIME);\n\t\tspin_lock_irqsave(host->host_lock, flags);\n\t\tscsi_report_bus_reset(host, scmd_channel(scmd));\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t}\n\n\treturn rtn;\n}\n\n \nstatic enum scsi_disposition scsi_try_bus_reset(struct scsi_cmnd *scmd)\n{\n\tunsigned long flags;\n\tenum scsi_disposition rtn;\n\tstruct Scsi_Host *host = scmd->device->host;\n\tconst struct scsi_host_template *hostt = host->hostt;\n\n\tSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\n\t\t\"%s: Snd Bus RST\\n\", __func__));\n\n\tif (!hostt->eh_bus_reset_handler)\n\t\treturn FAILED;\n\n\trtn = hostt->eh_bus_reset_handler(scmd);\n\n\tif (rtn == SUCCESS) {\n\t\tif (!hostt->skip_settle_delay)\n\t\t\tssleep(BUS_RESET_SETTLE_TIME);\n\t\tspin_lock_irqsave(host->host_lock, flags);\n\t\tscsi_report_bus_reset(host, scmd_channel(scmd));\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t}\n\n\treturn rtn;\n}\n\nstatic void __scsi_report_device_reset(struct scsi_device *sdev, void *data)\n{\n\tsdev->was_reset = 1;\n\tsdev->expecting_cc_ua = 1;\n}\n\n \nstatic enum scsi_disposition scsi_try_target_reset(struct scsi_cmnd *scmd)\n{\n\tunsigned long flags;\n\tenum scsi_disposition rtn;\n\tstruct Scsi_Host *host = scmd->device->host;\n\tconst struct scsi_host_template *hostt = host->hostt;\n\n\tif (!hostt->eh_target_reset_handler)\n\t\treturn FAILED;\n\n\trtn = hostt->eh_target_reset_handler(scmd);\n\tif (rtn == SUCCESS) {\n\t\tspin_lock_irqsave(host->host_lock, flags);\n\t\t__starget_for_each_device(scsi_target(scmd->device), NULL,\n\t\t\t\t\t  __scsi_report_device_reset);\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t}\n\n\treturn rtn;\n}\n\n \nstatic enum scsi_disposition scsi_try_bus_device_reset(struct scsi_cmnd *scmd)\n{\n\tenum scsi_disposition rtn;\n\tconst struct scsi_host_template *hostt = scmd->device->host->hostt;\n\n\tif (!hostt->eh_device_reset_handler)\n\t\treturn FAILED;\n\n\trtn = hostt->eh_device_reset_handler(scmd);\n\tif (rtn == SUCCESS)\n\t\t__scsi_report_device_reset(scmd->device, NULL);\n\treturn rtn;\n}\n\n \nstatic enum scsi_disposition\nscsi_try_to_abort_cmd(const struct scsi_host_template *hostt, struct scsi_cmnd *scmd)\n{\n\tif (!hostt->eh_abort_handler)\n\t\treturn FAILED;\n\n\treturn hostt->eh_abort_handler(scmd);\n}\n\nstatic void scsi_abort_eh_cmnd(struct scsi_cmnd *scmd)\n{\n\tif (scsi_try_to_abort_cmd(scmd->device->host->hostt, scmd) != SUCCESS)\n\t\tif (scsi_try_bus_device_reset(scmd) != SUCCESS)\n\t\t\tif (scsi_try_target_reset(scmd) != SUCCESS)\n\t\t\t\tif (scsi_try_bus_reset(scmd) != SUCCESS)\n\t\t\t\t\tscsi_try_host_reset(scmd);\n}\n\n \nvoid scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,\n\t\t\tunsigned char *cmnd, int cmnd_size, unsigned sense_bytes)\n{\n\tstruct scsi_device *sdev = scmd->device;\n\n\t \n\tses->cmd_len = scmd->cmd_len;\n\tses->data_direction = scmd->sc_data_direction;\n\tses->sdb = scmd->sdb;\n\tses->result = scmd->result;\n\tses->resid_len = scmd->resid_len;\n\tses->underflow = scmd->underflow;\n\tses->prot_op = scmd->prot_op;\n\tses->eh_eflags = scmd->eh_eflags;\n\n\tscmd->prot_op = SCSI_PROT_NORMAL;\n\tscmd->eh_eflags = 0;\n\tmemcpy(ses->cmnd, scmd->cmnd, sizeof(ses->cmnd));\n\tmemset(scmd->cmnd, 0, sizeof(scmd->cmnd));\n\tmemset(&scmd->sdb, 0, sizeof(scmd->sdb));\n\tscmd->result = 0;\n\tscmd->resid_len = 0;\n\n\tif (sense_bytes) {\n\t\tscmd->sdb.length = min_t(unsigned, SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t sense_bytes);\n\t\tsg_init_one(&ses->sense_sgl, scmd->sense_buffer,\n\t\t\t    scmd->sdb.length);\n\t\tscmd->sdb.table.sgl = &ses->sense_sgl;\n\t\tscmd->sc_data_direction = DMA_FROM_DEVICE;\n\t\tscmd->sdb.table.nents = scmd->sdb.table.orig_nents = 1;\n\t\tscmd->cmnd[0] = REQUEST_SENSE;\n\t\tscmd->cmnd[4] = scmd->sdb.length;\n\t\tscmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);\n\t} else {\n\t\tscmd->sc_data_direction = DMA_NONE;\n\t\tif (cmnd) {\n\t\t\tBUG_ON(cmnd_size > sizeof(scmd->cmnd));\n\t\t\tmemcpy(scmd->cmnd, cmnd, cmnd_size);\n\t\t\tscmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);\n\t\t}\n\t}\n\n\tscmd->underflow = 0;\n\n\tif (sdev->scsi_level <= SCSI_2 && sdev->scsi_level != SCSI_UNKNOWN)\n\t\tscmd->cmnd[1] = (scmd->cmnd[1] & 0x1f) |\n\t\t\t(sdev->lun << 5 & 0xe0);\n\n\t \n\tmemset(scmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n}\nEXPORT_SYMBOL(scsi_eh_prep_cmnd);\n\n \nvoid scsi_eh_restore_cmnd(struct scsi_cmnd* scmd, struct scsi_eh_save *ses)\n{\n\t \n\tscmd->cmd_len = ses->cmd_len;\n\tmemcpy(scmd->cmnd, ses->cmnd, sizeof(ses->cmnd));\n\tscmd->sc_data_direction = ses->data_direction;\n\tscmd->sdb = ses->sdb;\n\tscmd->result = ses->result;\n\tscmd->resid_len = ses->resid_len;\n\tscmd->underflow = ses->underflow;\n\tscmd->prot_op = ses->prot_op;\n\tscmd->eh_eflags = ses->eh_eflags;\n}\nEXPORT_SYMBOL(scsi_eh_restore_cmnd);\n\n \nstatic enum scsi_disposition scsi_send_eh_cmnd(struct scsi_cmnd *scmd,\n\tunsigned char *cmnd, int cmnd_size, int timeout, unsigned sense_bytes)\n{\n\tstruct scsi_device *sdev = scmd->device;\n\tstruct Scsi_Host *shost = sdev->host;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tunsigned long timeleft = timeout, delay;\n\tstruct scsi_eh_save ses;\n\tconst unsigned long stall_for = msecs_to_jiffies(100);\n\tint rtn;\n\nretry:\n\tscsi_eh_prep_cmnd(scmd, &ses, cmnd, cmnd_size, sense_bytes);\n\tshost->eh_action = &done;\n\n\tscsi_log_send(scmd);\n\tscmd->submitter = SUBMITTED_BY_SCSI_ERROR_HANDLER;\n\tscmd->flags |= SCMD_LAST;\n\n\t \n\tmutex_lock(&sdev->state_mutex);\n\twhile (sdev->sdev_state == SDEV_BLOCK && timeleft > 0) {\n\t\tmutex_unlock(&sdev->state_mutex);\n\t\tSCSI_LOG_ERROR_RECOVERY(5, sdev_printk(KERN_DEBUG, sdev,\n\t\t\t\"%s: state %d <> %d\\n\", __func__, sdev->sdev_state,\n\t\t\tSDEV_BLOCK));\n\t\tdelay = min(timeleft, stall_for);\n\t\ttimeleft -= delay;\n\t\tmsleep(jiffies_to_msecs(delay));\n\t\tmutex_lock(&sdev->state_mutex);\n\t}\n\tif (sdev->sdev_state != SDEV_BLOCK)\n\t\trtn = shost->hostt->queuecommand(shost, scmd);\n\telse\n\t\trtn = FAILED;\n\tmutex_unlock(&sdev->state_mutex);\n\n\tif (rtn) {\n\t\tif (timeleft > stall_for) {\n\t\t\tscsi_eh_restore_cmnd(scmd, &ses);\n\n\t\t\ttimeleft -= stall_for;\n\t\t\tmsleep(jiffies_to_msecs(stall_for));\n\t\t\tgoto retry;\n\t\t}\n\t\t \n\t\ttimeleft = 0;\n\t\trtn = FAILED;\n\t} else {\n\t\ttimeleft = wait_for_completion_timeout(&done, timeout);\n\t\trtn = SUCCESS;\n\t}\n\n\tshost->eh_action = NULL;\n\n\tscsi_log_completion(scmd, rtn);\n\n\tSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\n\t\t\t\"%s timeleft: %ld\\n\",\n\t\t\t__func__, timeleft));\n\n\t \n\tif (timeleft) {\n\t\trtn = scsi_eh_completed_normally(scmd);\n\t\tSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\n\t\t\t\"%s: scsi_eh_completed_normally %x\\n\", __func__, rtn));\n\n\t\tswitch (rtn) {\n\t\tcase SUCCESS:\n\t\tcase NEEDS_RETRY:\n\t\tcase FAILED:\n\t\t\tbreak;\n\t\tcase ADD_TO_MLQUEUE:\n\t\t\trtn = NEEDS_RETRY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtn = FAILED;\n\t\t\tbreak;\n\t\t}\n\t} else if (rtn != FAILED) {\n\t\tscsi_abort_eh_cmnd(scmd);\n\t\trtn = FAILED;\n\t}\n\n\tscsi_eh_restore_cmnd(scmd, &ses);\n\n\treturn rtn;\n}\n\n \nstatic enum scsi_disposition scsi_request_sense(struct scsi_cmnd *scmd)\n{\n\treturn scsi_send_eh_cmnd(scmd, NULL, 0, scmd->device->eh_timeout, ~0);\n}\n\nstatic enum scsi_disposition\nscsi_eh_action(struct scsi_cmnd *scmd, enum scsi_disposition rtn)\n{\n\tif (!blk_rq_is_passthrough(scsi_cmd_to_rq(scmd))) {\n\t\tstruct scsi_driver *sdrv = scsi_cmd_to_driver(scmd);\n\t\tif (sdrv->eh_action)\n\t\t\trtn = sdrv->eh_action(scmd, rtn);\n\t}\n\treturn rtn;\n}\n\n \nvoid scsi_eh_finish_cmd(struct scsi_cmnd *scmd, struct list_head *done_q)\n{\n\tlist_move_tail(&scmd->eh_entry, done_q);\n}\nEXPORT_SYMBOL(scsi_eh_finish_cmd);\n\n \nint scsi_eh_get_sense(struct list_head *work_q,\n\t\t      struct list_head *done_q)\n{\n\tstruct scsi_cmnd *scmd, *next;\n\tstruct Scsi_Host *shost;\n\tenum scsi_disposition rtn;\n\n\t \n\tlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\n\t\tif ((scmd->eh_eflags & SCSI_EH_ABORT_SCHEDULED) ||\n\t\t    SCSI_SENSE_VALID(scmd))\n\t\t\tcontinue;\n\n\t\tshost = scmd->device->host;\n\t\tif (scsi_host_eh_past_deadline(shost)) {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t\t\t    \"%s: skip request sense, past eh deadline\\n\",\n\t\t\t\t\t     current->comm));\n\t\t\tbreak;\n\t\t}\n\t\tif (!scsi_status_is_check_condition(scmd->result))\n\t\t\t \n\t\t\tcontinue;\n\n\t\tSCSI_LOG_ERROR_RECOVERY(2, scmd_printk(KERN_INFO, scmd,\n\t\t\t\t\t\t  \"%s: requesting sense\\n\",\n\t\t\t\t\t\t  current->comm));\n\t\trtn = scsi_request_sense(scmd);\n\t\tif (rtn != SUCCESS)\n\t\t\tcontinue;\n\n\t\tSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\n\t\t\t\"sense requested, result %x\\n\", scmd->result));\n\t\tSCSI_LOG_ERROR_RECOVERY(3, scsi_print_sense(scmd));\n\n\t\trtn = scsi_decide_disposition(scmd);\n\n\t\t \n\t\tif (rtn == SUCCESS)\n\t\t\t \n\t\t\tif (scmd->allowed == SCSI_CMD_RETRIES_NO_LIMIT)\n\t\t\t\tscmd->retries = scmd->allowed = 1;\n\t\t\telse\n\t\t\t\tscmd->retries = scmd->allowed;\n\t\telse if (rtn != NEEDS_RETRY)\n\t\t\tcontinue;\n\n\t\tscsi_eh_finish_cmd(scmd, done_q);\n\t}\n\n\treturn list_empty(work_q);\n}\nEXPORT_SYMBOL_GPL(scsi_eh_get_sense);\n\n \nstatic int scsi_eh_tur(struct scsi_cmnd *scmd)\n{\n\tstatic unsigned char tur_command[6] = {TEST_UNIT_READY, 0, 0, 0, 0, 0};\n\tint retry_cnt = 1;\n\tenum scsi_disposition rtn;\n\nretry_tur:\n\trtn = scsi_send_eh_cmnd(scmd, tur_command, 6,\n\t\t\t\tscmd->device->eh_timeout, 0);\n\n\tSCSI_LOG_ERROR_RECOVERY(3, scmd_printk(KERN_INFO, scmd,\n\t\t\"%s return: %x\\n\", __func__, rtn));\n\n\tswitch (rtn) {\n\tcase NEEDS_RETRY:\n\t\tif (retry_cnt--)\n\t\t\tgoto retry_tur;\n\t\tfallthrough;\n\tcase SUCCESS:\n\t\treturn 0;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n \nstatic int scsi_eh_test_devices(struct list_head *cmd_list,\n\t\t\t\tstruct list_head *work_q,\n\t\t\t\tstruct list_head *done_q, int try_stu)\n{\n\tstruct scsi_cmnd *scmd, *next;\n\tstruct scsi_device *sdev;\n\tint finish_cmds;\n\n\twhile (!list_empty(cmd_list)) {\n\t\tscmd = list_entry(cmd_list->next, struct scsi_cmnd, eh_entry);\n\t\tsdev = scmd->device;\n\n\t\tif (!try_stu) {\n\t\t\tif (scsi_host_eh_past_deadline(sdev->host)) {\n\t\t\t\t \n\t\t\t\tlist_splice_init(cmd_list, work_q);\n\t\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t\t    \"%s: skip test device, past eh deadline\",\n\t\t\t\t\t\t    current->comm));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfinish_cmds = !scsi_device_online(scmd->device) ||\n\t\t\t(try_stu && !scsi_eh_try_stu(scmd) &&\n\t\t\t !scsi_eh_tur(scmd)) ||\n\t\t\t!scsi_eh_tur(scmd);\n\n\t\tlist_for_each_entry_safe(scmd, next, cmd_list, eh_entry)\n\t\t\tif (scmd->device == sdev) {\n\t\t\t\tif (finish_cmds &&\n\t\t\t\t    (try_stu ||\n\t\t\t\t     scsi_eh_action(scmd, SUCCESS) == SUCCESS))\n\t\t\t\t\tscsi_eh_finish_cmd(scmd, done_q);\n\t\t\t\telse\n\t\t\t\t\tlist_move_tail(&scmd->eh_entry, work_q);\n\t\t\t}\n\t}\n\treturn list_empty(work_q);\n}\n\n \nstatic int scsi_eh_try_stu(struct scsi_cmnd *scmd)\n{\n\tstatic unsigned char stu_command[6] = {START_STOP, 0, 0, 0, 1, 0};\n\n\tif (scmd->device->allow_restart) {\n\t\tint i;\n\t\tenum scsi_disposition rtn = NEEDS_RETRY;\n\n\t\tfor (i = 0; rtn == NEEDS_RETRY && i < 2; i++)\n\t\t\trtn = scsi_send_eh_cmnd(scmd, stu_command, 6,\n\t\t\t\t\t\tscmd->device->eh_timeout, 0);\n\n\t\tif (rtn == SUCCESS)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n  \nstatic int scsi_eh_stu(struct Scsi_Host *shost,\n\t\t\t      struct list_head *work_q,\n\t\t\t      struct list_head *done_q)\n{\n\tstruct scsi_cmnd *scmd, *stu_scmd, *next;\n\tstruct scsi_device *sdev;\n\n\tshost_for_each_device(sdev, shost) {\n\t\tif (scsi_host_eh_past_deadline(shost)) {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t    \"%s: skip START_UNIT, past eh deadline\\n\",\n\t\t\t\t\t    current->comm));\n\t\t\tscsi_device_put(sdev);\n\t\t\tbreak;\n\t\t}\n\t\tstu_scmd = NULL;\n\t\tlist_for_each_entry(scmd, work_q, eh_entry)\n\t\t\tif (scmd->device == sdev && SCSI_SENSE_VALID(scmd) &&\n\t\t\t    scsi_check_sense(scmd) == FAILED ) {\n\t\t\t\tstu_scmd = scmd;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!stu_scmd)\n\t\t\tcontinue;\n\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t     \"%s: Sending START_UNIT\\n\",\n\t\t\t\t    current->comm));\n\n\t\tif (!scsi_eh_try_stu(stu_scmd)) {\n\t\t\tif (!scsi_device_online(sdev) ||\n\t\t\t    !scsi_eh_tur(stu_scmd)) {\n\t\t\t\tlist_for_each_entry_safe(scmd, next,\n\t\t\t\t\t\t\t  work_q, eh_entry) {\n\t\t\t\t\tif (scmd->device == sdev &&\n\t\t\t\t\t    scsi_eh_action(scmd, SUCCESS) == SUCCESS)\n\t\t\t\t\t\tscsi_eh_finish_cmd(scmd, done_q);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t    \"%s: START_UNIT failed\\n\",\n\t\t\t\t\t    current->comm));\n\t\t}\n\t}\n\n\treturn list_empty(work_q);\n}\n\n\n \nstatic int scsi_eh_bus_device_reset(struct Scsi_Host *shost,\n\t\t\t\t    struct list_head *work_q,\n\t\t\t\t    struct list_head *done_q)\n{\n\tstruct scsi_cmnd *scmd, *bdr_scmd, *next;\n\tstruct scsi_device *sdev;\n\tenum scsi_disposition rtn;\n\n\tshost_for_each_device(sdev, shost) {\n\t\tif (scsi_host_eh_past_deadline(shost)) {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t    \"%s: skip BDR, past eh deadline\\n\",\n\t\t\t\t\t     current->comm));\n\t\t\tscsi_device_put(sdev);\n\t\t\tbreak;\n\t\t}\n\t\tbdr_scmd = NULL;\n\t\tlist_for_each_entry(scmd, work_q, eh_entry)\n\t\t\tif (scmd->device == sdev) {\n\t\t\t\tbdr_scmd = scmd;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!bdr_scmd)\n\t\t\tcontinue;\n\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t     \"%s: Sending BDR\\n\", current->comm));\n\t\trtn = scsi_try_bus_device_reset(bdr_scmd);\n\t\tif (rtn == SUCCESS || rtn == FAST_IO_FAIL) {\n\t\t\tif (!scsi_device_online(sdev) ||\n\t\t\t    rtn == FAST_IO_FAIL ||\n\t\t\t    !scsi_eh_tur(bdr_scmd)) {\n\t\t\t\tlist_for_each_entry_safe(scmd, next,\n\t\t\t\t\t\t\t work_q, eh_entry) {\n\t\t\t\t\tif (scmd->device == sdev &&\n\t\t\t\t\t    scsi_eh_action(scmd, rtn) != FAILED)\n\t\t\t\t\t\tscsi_eh_finish_cmd(scmd,\n\t\t\t\t\t\t\t\t   done_q);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t    \"%s: BDR failed\\n\", current->comm));\n\t\t}\n\t}\n\n\treturn list_empty(work_q);\n}\n\n \nstatic int scsi_eh_target_reset(struct Scsi_Host *shost,\n\t\t\t\tstruct list_head *work_q,\n\t\t\t\tstruct list_head *done_q)\n{\n\tLIST_HEAD(tmp_list);\n\tLIST_HEAD(check_list);\n\n\tlist_splice_init(work_q, &tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tstruct scsi_cmnd *next, *scmd;\n\t\tenum scsi_disposition rtn;\n\t\tunsigned int id;\n\n\t\tif (scsi_host_eh_past_deadline(shost)) {\n\t\t\t \n\t\t\tlist_splice_init(&check_list, work_q);\n\t\t\tlist_splice_init(&tmp_list, work_q);\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t\t    \"%s: Skip target reset, past eh deadline\\n\",\n\t\t\t\t\t     current->comm));\n\t\t\treturn list_empty(work_q);\n\t\t}\n\n\t\tscmd = list_entry(tmp_list.next, struct scsi_cmnd, eh_entry);\n\t\tid = scmd_id(scmd);\n\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t     \"%s: Sending target reset to target %d\\n\",\n\t\t\t\t     current->comm, id));\n\t\trtn = scsi_try_target_reset(scmd);\n\t\tif (rtn != SUCCESS && rtn != FAST_IO_FAIL)\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t\t     \"%s: Target reset failed\"\n\t\t\t\t\t     \" target: %d\\n\",\n\t\t\t\t\t     current->comm, id));\n\t\tlist_for_each_entry_safe(scmd, next, &tmp_list, eh_entry) {\n\t\t\tif (scmd_id(scmd) != id)\n\t\t\t\tcontinue;\n\n\t\t\tif (rtn == SUCCESS)\n\t\t\t\tlist_move_tail(&scmd->eh_entry, &check_list);\n\t\t\telse if (rtn == FAST_IO_FAIL)\n\t\t\t\tscsi_eh_finish_cmd(scmd, done_q);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tlist_move(&scmd->eh_entry, work_q);\n\t\t}\n\t}\n\n\treturn scsi_eh_test_devices(&check_list, work_q, done_q, 0);\n}\n\n \nstatic int scsi_eh_bus_reset(struct Scsi_Host *shost,\n\t\t\t     struct list_head *work_q,\n\t\t\t     struct list_head *done_q)\n{\n\tstruct scsi_cmnd *scmd, *chan_scmd, *next;\n\tLIST_HEAD(check_list);\n\tunsigned int channel;\n\tenum scsi_disposition rtn;\n\n\t \n\n\tfor (channel = 0; channel <= shost->max_channel; channel++) {\n\t\tif (scsi_host_eh_past_deadline(shost)) {\n\t\t\tlist_splice_init(&check_list, work_q);\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t\t    \"%s: skip BRST, past eh deadline\\n\",\n\t\t\t\t\t     current->comm));\n\t\t\treturn list_empty(work_q);\n\t\t}\n\n\t\tchan_scmd = NULL;\n\t\tlist_for_each_entry(scmd, work_q, eh_entry) {\n\t\t\tif (channel == scmd_channel(scmd)) {\n\t\t\t\tchan_scmd = scmd;\n\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t}\n\t\t}\n\n\t\tif (!chan_scmd)\n\t\t\tcontinue;\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t     \"%s: Sending BRST chan: %d\\n\",\n\t\t\t\t     current->comm, channel));\n\t\trtn = scsi_try_bus_reset(chan_scmd);\n\t\tif (rtn == SUCCESS || rtn == FAST_IO_FAIL) {\n\t\t\tlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\n\t\t\t\tif (channel == scmd_channel(scmd)) {\n\t\t\t\t\tif (rtn == FAST_IO_FAIL)\n\t\t\t\t\t\tscsi_eh_finish_cmd(scmd,\n\t\t\t\t\t\t\t\t   done_q);\n\t\t\t\t\telse\n\t\t\t\t\t\tlist_move_tail(&scmd->eh_entry,\n\t\t\t\t\t\t\t       &check_list);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t\t     \"%s: BRST failed chan: %d\\n\",\n\t\t\t\t\t     current->comm, channel));\n\t\t}\n\t}\n\treturn scsi_eh_test_devices(&check_list, work_q, done_q, 0);\n}\n\n \nstatic int scsi_eh_host_reset(struct Scsi_Host *shost,\n\t\t\t      struct list_head *work_q,\n\t\t\t      struct list_head *done_q)\n{\n\tstruct scsi_cmnd *scmd, *next;\n\tLIST_HEAD(check_list);\n\tenum scsi_disposition rtn;\n\n\tif (!list_empty(work_q)) {\n\t\tscmd = list_entry(work_q->next,\n\t\t\t\t  struct scsi_cmnd, eh_entry);\n\n\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t     \"%s: Sending HRST\\n\",\n\t\t\t\t     current->comm));\n\n\t\trtn = scsi_try_host_reset(scmd);\n\t\tif (rtn == SUCCESS) {\n\t\t\tlist_splice_init(work_q, &check_list);\n\t\t} else if (rtn == FAST_IO_FAIL) {\n\t\t\tlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\n\t\t\t\t\tscsi_eh_finish_cmd(scmd, done_q);\n\t\t\t}\n\t\t} else {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t\t     \"%s: HRST failed\\n\",\n\t\t\t\t\t     current->comm));\n\t\t}\n\t}\n\treturn scsi_eh_test_devices(&check_list, work_q, done_q, 1);\n}\n\n \nstatic void scsi_eh_offline_sdevs(struct list_head *work_q,\n\t\t\t\t  struct list_head *done_q)\n{\n\tstruct scsi_cmnd *scmd, *next;\n\tstruct scsi_device *sdev;\n\n\tlist_for_each_entry_safe(scmd, next, work_q, eh_entry) {\n\t\tsdev_printk(KERN_INFO, scmd->device, \"Device offlined - \"\n\t\t\t    \"not ready after error recovery\\n\");\n\t\tsdev = scmd->device;\n\n\t\tmutex_lock(&sdev->state_mutex);\n\t\tscsi_device_set_state(sdev, SDEV_OFFLINE);\n\t\tmutex_unlock(&sdev->state_mutex);\n\n\t\tscsi_eh_finish_cmd(scmd, done_q);\n\t}\n\treturn;\n}\n\n \nbool scsi_noretry_cmd(struct scsi_cmnd *scmd)\n{\n\tstruct request *req = scsi_cmd_to_rq(scmd);\n\n\tswitch (host_byte(scmd->result)) {\n\tcase DID_OK:\n\t\tbreak;\n\tcase DID_TIME_OUT:\n\t\tgoto check_type;\n\tcase DID_BUS_BUSY:\n\t\treturn !!(req->cmd_flags & REQ_FAILFAST_TRANSPORT);\n\tcase DID_PARITY:\n\t\treturn !!(req->cmd_flags & REQ_FAILFAST_DEV);\n\tcase DID_ERROR:\n\t\tif (get_status_byte(scmd) == SAM_STAT_RESERVATION_CONFLICT)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase DID_SOFT_ERROR:\n\t\treturn !!(req->cmd_flags & REQ_FAILFAST_DRIVER);\n\t}\n\n\t \n\tif (scsi_ml_byte(scmd->result) == SCSIML_STAT_DL_TIMEOUT)\n\t\treturn true;\n\n\tif (!scsi_status_is_check_condition(scmd->result))\n\t\treturn false;\n\ncheck_type:\n\t \n\tif (req->cmd_flags & REQ_FAILFAST_DEV || blk_rq_is_passthrough(req))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nenum scsi_disposition scsi_decide_disposition(struct scsi_cmnd *scmd)\n{\n\tenum scsi_disposition rtn;\n\n\t \n\tif (!scsi_device_online(scmd->device)) {\n\t\tSCSI_LOG_ERROR_RECOVERY(5, scmd_printk(KERN_INFO, scmd,\n\t\t\t\"%s: device offline - report as SUCCESS\\n\", __func__));\n\t\treturn SUCCESS;\n\t}\n\n\t \n\tswitch (host_byte(scmd->result)) {\n\tcase DID_PASSTHROUGH:\n\t\t \n\t\tscmd->result &= 0xff00ffff;\n\t\treturn SUCCESS;\n\tcase DID_OK:\n\t\t \n\t\tbreak;\n\tcase DID_ABORT:\n\t\tif (scmd->eh_eflags & SCSI_EH_ABORT_SCHEDULED) {\n\t\t\tset_host_byte(scmd, DID_TIME_OUT);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tfallthrough;\n\tcase DID_NO_CONNECT:\n\tcase DID_BAD_TARGET:\n\t\t \n\t\treturn SUCCESS;\n\tcase DID_SOFT_ERROR:\n\t\t \n\t\tgoto maybe_retry;\n\tcase DID_IMM_RETRY:\n\t\treturn NEEDS_RETRY;\n\n\tcase DID_REQUEUE:\n\t\treturn ADD_TO_MLQUEUE;\n\tcase DID_TRANSPORT_DISRUPTED:\n\t\t \n\t\tgoto maybe_retry;\n\tcase DID_TRANSPORT_FAILFAST:\n\t\t \n\t\treturn SUCCESS;\n\tcase DID_TRANSPORT_MARGINAL:\n\t\t \n\t\treturn SUCCESS;\n\tcase DID_ERROR:\n\t\tif (get_status_byte(scmd) == SAM_STAT_RESERVATION_CONFLICT)\n\t\t\t \n\t\t\tbreak;\n\t\tfallthrough;\n\tcase DID_BUS_BUSY:\n\tcase DID_PARITY:\n\t\tgoto maybe_retry;\n\tcase DID_TIME_OUT:\n\t\t \n\t\tif ((scmd->cmnd[0] == TEST_UNIT_READY ||\n\t\t     scmd->cmnd[0] == INQUIRY)) {\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\treturn FAILED;\n\t\t}\n\tcase DID_RESET:\n\t\treturn SUCCESS;\n\tdefault:\n\t\treturn FAILED;\n\t}\n\n\t \n\tswitch (get_status_byte(scmd)) {\n\tcase SAM_STAT_TASK_SET_FULL:\n\t\tscsi_handle_queue_full(scmd->device);\n\t\t \n\t\tfallthrough;\n\tcase SAM_STAT_BUSY:\n\t\t \n\t\treturn ADD_TO_MLQUEUE;\n\tcase SAM_STAT_GOOD:\n\t\tif (scmd->cmnd[0] == REPORT_LUNS)\n\t\t\tscmd->device->sdev_target->expecting_lun_change = 0;\n\t\tscsi_handle_queue_ramp_up(scmd->device);\n\t\tif (scmd->sense_buffer && SCSI_SENSE_VALID(scmd))\n\t\t\t \n\t\t\tscsi_check_sense(scmd);\n\t\tfallthrough;\n\tcase SAM_STAT_COMMAND_TERMINATED:\n\t\treturn SUCCESS;\n\tcase SAM_STAT_TASK_ABORTED:\n\t\tgoto maybe_retry;\n\tcase SAM_STAT_CHECK_CONDITION:\n\t\trtn = scsi_check_sense(scmd);\n\t\tif (rtn == NEEDS_RETRY)\n\t\t\tgoto maybe_retry;\n\t\t \n\t\treturn rtn;\n\tcase SAM_STAT_CONDITION_MET:\n\tcase SAM_STAT_INTERMEDIATE:\n\tcase SAM_STAT_INTERMEDIATE_CONDITION_MET:\n\tcase SAM_STAT_ACA_ACTIVE:\n\t\t \n\t\treturn SUCCESS;\n\n\tcase SAM_STAT_RESERVATION_CONFLICT:\n\t\tsdev_printk(KERN_INFO, scmd->device,\n\t\t\t    \"reservation conflict\\n\");\n\t\tset_scsi_ml_byte(scmd, SCSIML_STAT_RESV_CONFLICT);\n\t\treturn SUCCESS;  \n\t}\n\treturn FAILED;\n\nmaybe_retry:\n\n\t \n\tif (scsi_cmd_retry_allowed(scmd) && !scsi_noretry_cmd(scmd)) {\n\t\treturn NEEDS_RETRY;\n\t} else {\n\t\t \n\t\treturn SUCCESS;\n\t}\n}\n\nstatic enum rq_end_io_ret eh_lock_door_done(struct request *req,\n\t\t\t\t\t    blk_status_t status)\n{\n\tblk_mq_free_request(req);\n\treturn RQ_END_IO_NONE;\n}\n\n \nstatic void scsi_eh_lock_door(struct scsi_device *sdev)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct request *req;\n\n\treq = scsi_alloc_request(sdev->request_queue, REQ_OP_DRV_IN, 0);\n\tif (IS_ERR(req))\n\t\treturn;\n\tscmd = blk_mq_rq_to_pdu(req);\n\n\tscmd->cmnd[0] = ALLOW_MEDIUM_REMOVAL;\n\tscmd->cmnd[1] = 0;\n\tscmd->cmnd[2] = 0;\n\tscmd->cmnd[3] = 0;\n\tscmd->cmnd[4] = SCSI_REMOVAL_PREVENT;\n\tscmd->cmnd[5] = 0;\n\tscmd->cmd_len = COMMAND_SIZE(scmd->cmnd[0]);\n\tscmd->allowed = 5;\n\n\treq->rq_flags |= RQF_QUIET;\n\treq->timeout = 10 * HZ;\n\treq->end_io = eh_lock_door_done;\n\n\tblk_execute_rq_nowait(req, true);\n}\n\n \nstatic void scsi_restart_operations(struct Scsi_Host *shost)\n{\n\tstruct scsi_device *sdev;\n\tunsigned long flags;\n\n\t \n\tshost_for_each_device(sdev, shost) {\n\t\tif (scsi_device_online(sdev) && sdev->was_reset && sdev->locked) {\n\t\t\tscsi_eh_lock_door(sdev);\n\t\t\tsdev->was_reset = 0;\n\t\t}\n\t}\n\n\t \n\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\tshost_printk(KERN_INFO, shost, \"waking up host to restart\\n\"));\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (scsi_host_set_state(shost, SHOST_RUNNING))\n\t\tif (scsi_host_set_state(shost, SHOST_CANCEL))\n\t\t\tBUG_ON(scsi_host_set_state(shost, SHOST_DEL));\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\twake_up(&shost->host_wait);\n\n\t \n\tscsi_run_host_queues(shost);\n\n\t \n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (shost->host_eh_scheduled)\n\t\tif (scsi_host_set_state(shost, SHOST_RECOVERY))\n\t\t\tWARN_ON(scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY));\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n \nvoid scsi_eh_ready_devs(struct Scsi_Host *shost,\n\t\t\tstruct list_head *work_q,\n\t\t\tstruct list_head *done_q)\n{\n\tif (!scsi_eh_stu(shost, work_q, done_q))\n\t\tif (!scsi_eh_bus_device_reset(shost, work_q, done_q))\n\t\t\tif (!scsi_eh_target_reset(shost, work_q, done_q))\n\t\t\t\tif (!scsi_eh_bus_reset(shost, work_q, done_q))\n\t\t\t\t\tif (!scsi_eh_host_reset(shost, work_q, done_q))\n\t\t\t\t\t\tscsi_eh_offline_sdevs(work_q,\n\t\t\t\t\t\t\t\t      done_q);\n}\nEXPORT_SYMBOL_GPL(scsi_eh_ready_devs);\n\n \nvoid scsi_eh_flush_done_q(struct list_head *done_q)\n{\n\tstruct scsi_cmnd *scmd, *next;\n\n\tlist_for_each_entry_safe(scmd, next, done_q, eh_entry) {\n\t\tlist_del_init(&scmd->eh_entry);\n\t\tif (scsi_device_online(scmd->device) &&\n\t\t    !scsi_noretry_cmd(scmd) && scsi_cmd_retry_allowed(scmd) &&\n\t\t\tscsi_eh_should_retry_cmd(scmd)) {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t\t\t     \"%s: flush retry cmd\\n\",\n\t\t\t\t\t     current->comm));\n\t\t\t\tscsi_queue_insert(scmd, SCSI_MLQUEUE_EH_RETRY);\n\t\t} else {\n\t\t\t \n\t\t\tif (!scmd->result &&\n\t\t\t    !(scmd->flags & SCMD_FORCE_EH_SUCCESS))\n\t\t\t\tscmd->result |= (DID_TIME_OUT << 16);\n\t\t\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\t\t\tscmd_printk(KERN_INFO, scmd,\n\t\t\t\t\t     \"%s: flush finish cmd\\n\",\n\t\t\t\t\t     current->comm));\n\t\t\tscsi_finish_command(scmd);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(scsi_eh_flush_done_q);\n\n \nstatic void scsi_unjam_host(struct Scsi_Host *shost)\n{\n\tunsigned long flags;\n\tLIST_HEAD(eh_work_q);\n\tLIST_HEAD(eh_done_q);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_splice_init(&shost->eh_cmd_q, &eh_work_q);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tSCSI_LOG_ERROR_RECOVERY(1, scsi_eh_prt_fail_stats(shost, &eh_work_q));\n\n\tif (!scsi_eh_get_sense(&eh_work_q, &eh_done_q))\n\t\tscsi_eh_ready_devs(shost, &eh_work_q, &eh_done_q);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (shost->eh_deadline != -1)\n\t\tshost->last_reset = 0;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tscsi_eh_flush_done_q(&eh_done_q);\n}\n\n \nint scsi_error_handler(void *data)\n{\n\tstruct Scsi_Host *shost = data;\n\n\t \n\twhile (true) {\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tif ((shost->host_failed == 0 && shost->host_eh_scheduled == 0) ||\n\t\t    shost->host_failed != scsi_host_busy(shost)) {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(1,\n\t\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t\t     \"scsi_eh_%d: sleeping\\n\",\n\t\t\t\t\t     shost->host_no));\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\n\t\t__set_current_state(TASK_RUNNING);\n\t\tSCSI_LOG_ERROR_RECOVERY(1,\n\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t     \"scsi_eh_%d: waking up %d/%d/%d\\n\",\n\t\t\t\t     shost->host_no, shost->host_eh_scheduled,\n\t\t\t\t     shost->host_failed,\n\t\t\t\t     scsi_host_busy(shost)));\n\n\t\t \n\t\tif (!shost->eh_noresume && scsi_autopm_get_host(shost) != 0) {\n\t\t\tSCSI_LOG_ERROR_RECOVERY(1,\n\t\t\t\tshost_printk(KERN_ERR, shost,\n\t\t\t\t\t     \"scsi_eh_%d: unable to autoresume\\n\",\n\t\t\t\t\t     shost->host_no));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (shost->transportt->eh_strategy_handler)\n\t\t\tshost->transportt->eh_strategy_handler(shost);\n\t\telse\n\t\t\tscsi_unjam_host(shost);\n\n\t\t \n\t\tshost->host_failed = 0;\n\n\t\t \n\t\tscsi_restart_operations(shost);\n\t\tif (!shost->eh_noresume)\n\t\t\tscsi_autopm_put_host(shost);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tSCSI_LOG_ERROR_RECOVERY(1,\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"Error handler scsi_eh_%d exiting\\n\",\n\t\t\t     shost->host_no));\n\tshost->ehandler = NULL;\n\treturn 0;\n}\n\n \nvoid scsi_report_bus_reset(struct Scsi_Host *shost, int channel)\n{\n\tstruct scsi_device *sdev;\n\n\t__shost_for_each_device(sdev, shost) {\n\t\tif (channel == sdev_channel(sdev))\n\t\t\t__scsi_report_device_reset(sdev, NULL);\n\t}\n}\nEXPORT_SYMBOL(scsi_report_bus_reset);\n\n \nvoid scsi_report_device_reset(struct Scsi_Host *shost, int channel, int target)\n{\n\tstruct scsi_device *sdev;\n\n\t__shost_for_each_device(sdev, shost) {\n\t\tif (channel == sdev_channel(sdev) &&\n\t\t    target == sdev_id(sdev))\n\t\t\t__scsi_report_device_reset(sdev, NULL);\n\t}\n}\nEXPORT_SYMBOL(scsi_report_device_reset);\n\n \nint\nscsi_ioctl_reset(struct scsi_device *dev, int __user *arg)\n{\n\tstruct scsi_cmnd *scmd;\n\tstruct Scsi_Host *shost = dev->host;\n\tstruct request *rq;\n\tunsigned long flags;\n\tint error = 0, val;\n\tenum scsi_disposition rtn;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\treturn -EACCES;\n\n\terror = get_user(val, arg);\n\tif (error)\n\t\treturn error;\n\n\tif (scsi_autopm_get_host(shost) < 0)\n\t\treturn -EIO;\n\n\terror = -EIO;\n\trq = kzalloc(sizeof(struct request) + sizeof(struct scsi_cmnd) +\n\t\t\tshost->hostt->cmd_size, GFP_KERNEL);\n\tif (!rq)\n\t\tgoto out_put_autopm_host;\n\tblk_rq_init(NULL, rq);\n\n\tscmd = (struct scsi_cmnd *)(rq + 1);\n\tscsi_init_command(dev, scmd);\n\n\tscmd->submitter = SUBMITTED_BY_SCSI_RESET_IOCTL;\n\tscmd->flags |= SCMD_LAST;\n\tmemset(&scmd->sdb, 0, sizeof(scmd->sdb));\n\n\tscmd->cmd_len\t\t\t= 0;\n\n\tscmd->sc_data_direction\t\t= DMA_BIDIRECTIONAL;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tshost->tmf_in_progress = 1;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tswitch (val & ~SG_SCSI_RESET_NO_ESCALATE) {\n\tcase SG_SCSI_RESET_NOTHING:\n\t\trtn = SUCCESS;\n\t\tbreak;\n\tcase SG_SCSI_RESET_DEVICE:\n\t\trtn = scsi_try_bus_device_reset(scmd);\n\t\tif (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SG_SCSI_RESET_TARGET:\n\t\trtn = scsi_try_target_reset(scmd);\n\t\tif (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SG_SCSI_RESET_BUS:\n\t\trtn = scsi_try_bus_reset(scmd);\n\t\tif (rtn == SUCCESS || (val & SG_SCSI_RESET_NO_ESCALATE))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SG_SCSI_RESET_HOST:\n\t\trtn = scsi_try_host_reset(scmd);\n\t\tif (rtn == SUCCESS)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\trtn = FAILED;\n\t\tbreak;\n\t}\n\n\terror = (rtn == SUCCESS) ? 0 : -EIO;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tshost->tmf_in_progress = 0;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\t \n\tSCSI_LOG_ERROR_RECOVERY(3,\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"waking up host to restart after TMF\\n\"));\n\n\twake_up(&shost->host_wait);\n\tscsi_run_host_queues(shost);\n\n\tkfree(rq);\n\nout_put_autopm_host:\n\tscsi_autopm_put_host(shost);\n\treturn error;\n}\n\nbool scsi_command_normalize_sense(const struct scsi_cmnd *cmd,\n\t\t\t\t  struct scsi_sense_hdr *sshdr)\n{\n\treturn scsi_normalize_sense(cmd->sense_buffer,\n\t\t\tSCSI_SENSE_BUFFERSIZE, sshdr);\n}\nEXPORT_SYMBOL(scsi_command_normalize_sense);\n\n \nbool scsi_get_sense_info_fld(const u8 *sense_buffer, int sb_len,\n\t\t\t     u64 *info_out)\n{\n\tconst u8 * ucp;\n\n\tif (sb_len < 7)\n\t\treturn false;\n\tswitch (sense_buffer[0] & 0x7f) {\n\tcase 0x70:\n\tcase 0x71:\n\t\tif (sense_buffer[0] & 0x80) {\n\t\t\t*info_out = get_unaligned_be32(&sense_buffer[3]);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\tcase 0x72:\n\tcase 0x73:\n\t\tucp = scsi_sense_desc_find(sense_buffer, sb_len,\n\t\t\t\t\t   0  );\n\t\tif (ucp && (0xa == ucp[1])) {\n\t\t\t*info_out = get_unaligned_be64(&ucp[4]);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL(scsi_get_sense_info_fld);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}