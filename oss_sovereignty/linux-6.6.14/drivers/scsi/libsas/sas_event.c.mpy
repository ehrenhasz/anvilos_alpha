{
  "module_name": "sas_event.c",
  "hash_id": "9b37dcdcb1db7d73350a54c0846649bd83d3bc577e233e8ce17b19d1f72ad4c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_event.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <scsi/scsi_host.h>\n#include \"sas_internal.h\"\n\nbool sas_queue_work(struct sas_ha_struct *ha, struct sas_work *sw)\n{\n\tif (!test_bit(SAS_HA_REGISTERED, &ha->state))\n\t\treturn false;\n\n\tif (test_bit(SAS_HA_DRAINING, &ha->state)) {\n\t\t \n\t\tif (list_empty(&sw->drain_node))\n\t\t\tlist_add_tail(&sw->drain_node, &ha->defer_q);\n\t\treturn true;\n\t}\n\n\treturn queue_work(ha->event_q, &sw->work);\n}\n\nstatic bool sas_queue_event(int event, struct sas_work *work,\n\t\t\t    struct sas_ha_struct *ha)\n{\n\tunsigned long flags;\n\tbool rc;\n\n\tspin_lock_irqsave(&ha->lock, flags);\n\trc = sas_queue_work(ha, work);\n\tspin_unlock_irqrestore(&ha->lock, flags);\n\n\treturn rc;\n}\n\nvoid sas_queue_deferred_work(struct sas_ha_struct *ha)\n{\n\tstruct sas_work *sw, *_sw;\n\n\tspin_lock_irq(&ha->lock);\n\tlist_for_each_entry_safe(sw, _sw, &ha->defer_q, drain_node) {\n\t\tlist_del_init(&sw->drain_node);\n\n\t\tif (!sas_queue_work(ha, sw)) {\n\t\t\tpm_runtime_put(ha->dev);\n\t\t\tsas_free_event(to_asd_sas_event(&sw->work));\n\t\t}\n\t}\n\tspin_unlock_irq(&ha->lock);\n}\n\nvoid __sas_drain_work(struct sas_ha_struct *ha)\n{\n\tset_bit(SAS_HA_DRAINING, &ha->state);\n\t \n\tspin_lock_irq(&ha->lock);\n\tspin_unlock_irq(&ha->lock);\n\n\tdrain_workqueue(ha->event_q);\n\tdrain_workqueue(ha->disco_q);\n\n\tclear_bit(SAS_HA_DRAINING, &ha->state);\n\tsas_queue_deferred_work(ha);\n}\n\nint sas_drain_work(struct sas_ha_struct *ha)\n{\n\tint err;\n\n\terr = mutex_lock_interruptible(&ha->drain_mutex);\n\tif (err)\n\t\treturn err;\n\tif (test_bit(SAS_HA_REGISTERED, &ha->state))\n\t\t__sas_drain_work(ha);\n\tmutex_unlock(&ha->drain_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sas_drain_work);\n\nvoid sas_disable_revalidation(struct sas_ha_struct *ha)\n{\n\tmutex_lock(&ha->disco_mutex);\n\tset_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state);\n\tmutex_unlock(&ha->disco_mutex);\n}\n\nvoid sas_enable_revalidation(struct sas_ha_struct *ha)\n{\n\tint i;\n\n\tmutex_lock(&ha->disco_mutex);\n\tclear_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state);\n\tfor (i = 0; i < ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = ha->sas_port[i];\n\t\tconst int ev = DISCE_REVALIDATE_DOMAIN;\n\t\tstruct sas_discovery *d = &port->disc;\n\t\tstruct asd_sas_phy *sas_phy;\n\n\t\tif (!test_and_clear_bit(ev, &d->pending))\n\t\t\tcontinue;\n\n\t\tspin_lock(&port->phy_list_lock);\n\t\tif (list_empty(&port->phy_list)) {\n\t\t\tspin_unlock(&port->phy_list_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsas_phy = container_of(port->phy_list.next, struct asd_sas_phy,\n\t\t\t\tport_phy_el);\n\t\tspin_unlock(&port->phy_list_lock);\n\t\tsas_notify_port_event(sas_phy,\n\t\t\t\tPORTE_BROADCAST_RCVD, GFP_KERNEL);\n\t}\n\tmutex_unlock(&ha->disco_mutex);\n}\n\n\nstatic void sas_port_event_worker(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\tstruct sas_ha_struct *ha = phy->ha;\n\n\tsas_port_event_fns[ev->event](work);\n\tpm_runtime_put(ha->dev);\n\tsas_free_event(ev);\n}\n\nstatic void sas_phy_event_worker(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\tstruct sas_ha_struct *ha = phy->ha;\n\n\tsas_phy_event_fns[ev->event](work);\n\tpm_runtime_put(ha->dev);\n\tsas_free_event(ev);\n}\n\n \nstatic bool sas_defer_event(struct asd_sas_phy *phy, struct asd_sas_event *ev)\n{\n\tstruct sas_ha_struct *ha = phy->ha;\n\tunsigned long flags;\n\tbool deferred = false;\n\n\tspin_lock_irqsave(&ha->lock, flags);\n\tif (test_bit(SAS_HA_RESUMING, &ha->state) && !phy->suspended) {\n\t\tstruct sas_work *sw = &ev->work;\n\n\t\tlist_add_tail(&sw->drain_node, &ha->defer_q);\n\t\tdeferred = true;\n\t}\n\tspin_unlock_irqrestore(&ha->lock, flags);\n\treturn deferred;\n}\n\nvoid sas_notify_port_event(struct asd_sas_phy *phy, enum port_event event,\n\t\t\t   gfp_t gfp_flags)\n{\n\tstruct sas_ha_struct *ha = phy->ha;\n\tstruct asd_sas_event *ev;\n\n\tBUG_ON(event >= PORT_NUM_EVENTS);\n\n\tev = sas_alloc_event(phy, gfp_flags);\n\tif (!ev)\n\t\treturn;\n\n\t \n\tpm_runtime_get_noresume(ha->dev);\n\n\tINIT_SAS_EVENT(ev, sas_port_event_worker, phy, event);\n\n\tif (sas_defer_event(phy, ev))\n\t\treturn;\n\n\tif (!sas_queue_event(event, &ev->work, ha)) {\n\t\tpm_runtime_put(ha->dev);\n\t\tsas_free_event(ev);\n\t}\n}\nEXPORT_SYMBOL_GPL(sas_notify_port_event);\n\nvoid sas_notify_phy_event(struct asd_sas_phy *phy, enum phy_event event,\n\t\t\t  gfp_t gfp_flags)\n{\n\tstruct sas_ha_struct *ha = phy->ha;\n\tstruct asd_sas_event *ev;\n\n\tBUG_ON(event >= PHY_NUM_EVENTS);\n\n\tev = sas_alloc_event(phy, gfp_flags);\n\tif (!ev)\n\t\treturn;\n\n\t \n\tpm_runtime_get_noresume(ha->dev);\n\n\tINIT_SAS_EVENT(ev, sas_phy_event_worker, phy, event);\n\n\tif (sas_defer_event(phy, ev))\n\t\treturn;\n\n\tif (!sas_queue_event(event, &ev->work, ha)) {\n\t\tpm_runtime_put(ha->dev);\n\t\tsas_free_event(ev);\n\t}\n}\nEXPORT_SYMBOL_GPL(sas_notify_phy_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}