{
  "module_name": "sas_ata.c",
  "hash_id": "27d20eb52f84e533b0d3c1085374896e2f21e7b93c4b3f4ddb0144d328041b45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_ata.c",
  "human_readable_source": "\n \n\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/async.h>\n#include <linux/export.h>\n\n#include <scsi/sas_ata.h>\n#include \"sas_internal.h\"\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"scsi_sas_internal.h\"\n#include \"scsi_transport_api.h\"\n#include <scsi/scsi_eh.h>\n\nstatic enum ata_completion_errors sas_to_ata_err(struct task_status_struct *ts)\n{\n\t \n\n\t \n\tif (ts->resp == SAS_TASK_UNDELIVERED)\n\t\treturn AC_ERR_ATA_BUS;\n\n\t \n\t \n\tswitch (ts->stat) {\n\tcase SAS_DEV_NO_RESPONSE:\n\t\treturn AC_ERR_TIMEOUT;\n\tcase SAS_INTERRUPTED:\n\tcase SAS_PHY_DOWN:\n\tcase SAS_NAK_R_ERR:\n\t\treturn AC_ERR_ATA_BUS;\n\tcase SAS_DATA_UNDERRUN:\n\t\t \n\t\treturn 0;\n\tcase SAS_DATA_OVERRUN:\n\tcase SAS_QUEUE_FULL:\n\tcase SAS_DEVICE_UNKNOWN:\n\tcase SAS_OPEN_TO:\n\tcase SAS_OPEN_REJECT:\n\t\tpr_warn(\"%s: Saw error %d.  What to do?\\n\",\n\t\t\t__func__, ts->stat);\n\t\treturn AC_ERR_OTHER;\n\tcase SAM_STAT_CHECK_CONDITION:\n\tcase SAS_ABORTED_TASK:\n\t\treturn AC_ERR_DEV;\n\tcase SAS_PROTO_RESPONSE:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void sas_ata_task_done(struct sas_task *task)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct task_status_struct *stat = &task->task_status;\n\tstruct ata_task_resp *resp = (struct ata_task_resp *)stat->buf;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tenum ata_completion_errors ac;\n\tunsigned long flags;\n\tstruct ata_link *link;\n\tstruct ata_port *ap;\n\n\tspin_lock_irqsave(&dev->done_lock, flags);\n\tif (test_bit(SAS_HA_FROZEN, &sas_ha->state))\n\t\ttask = NULL;\n\telse if (qc && qc->scsicmd)\n\t\tASSIGN_SAS_TASK(qc->scsicmd, NULL);\n\tspin_unlock_irqrestore(&dev->done_lock, flags);\n\n\t \n\tif (unlikely(!task))\n\t\treturn;\n\n\tif (!qc)\n\t\tgoto qc_already_gone;\n\n\tap = qc->ap;\n\tlink = &ap->link;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\t \n\tif (unlikely(ata_port_is_frozen(ap))) {\n\t\tspin_unlock_irqrestore(ap->lock, flags);\n\t\tif (qc->scsicmd)\n\t\t\tgoto qc_already_gone;\n\t\telse {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (stat->stat == SAS_PROTO_RESPONSE ||\n\t    stat->stat == SAS_SAM_STAT_GOOD ||\n\t    (stat->stat == SAS_SAM_STAT_CHECK_CONDITION &&\n\t      dev->sata_dev.class == ATA_DEV_ATAPI)) {\n\t\tmemcpy(dev->sata_dev.fis, resp->ending_fis, ATA_RESP_FIS_SIZE);\n\n\t\tif (!link->sactive) {\n\t\t\tqc->err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\n\t\t} else {\n\t\t\tlink->eh_info.err_mask |= ac_err_mask(dev->sata_dev.fis[2]);\n\t\t\tif (unlikely(link->eh_info.err_mask))\n\t\t\t\tqc->flags |= ATA_QCFLAG_EH;\n\t\t}\n\t} else {\n\t\tac = sas_to_ata_err(stat);\n\t\tif (ac) {\n\t\t\tpr_warn(\"%s: SAS error 0x%x\\n\", __func__, stat->stat);\n\t\t\t \n\t\t\tif (!link->sactive) {\n\t\t\t\tqc->err_mask = ac;\n\t\t\t} else {\n\t\t\t\tlink->eh_info.err_mask |= AC_ERR_DEV;\n\t\t\t\tqc->flags |= ATA_QCFLAG_EH;\n\t\t\t}\n\n\t\t\tdev->sata_dev.fis[2] = ATA_ERR | ATA_DRDY;  \n\t\t\tdev->sata_dev.fis[3] = ATA_ABORTED;  \n\t\t}\n\t}\n\n\tqc->lldd_task = NULL;\n\tata_qc_complete(qc);\n\tspin_unlock_irqrestore(ap->lock, flags);\n\nqc_already_gone:\n\tsas_free_task(task);\n}\n\nstatic unsigned int sas_ata_qc_issue(struct ata_queued_cmd *qc)\n\t__must_hold(ap->lock)\n{\n\tstruct sas_task *task;\n\tstruct scatterlist *sg;\n\tint ret = AC_ERR_SYSTEM;\n\tunsigned int si, xfer = 0;\n\tstruct ata_port *ap = qc->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *host = sas_ha->shost;\n\tstruct sas_internal *i = to_sas_internal(host->transportt);\n\n\t \n\tspin_unlock(ap->lock);\n\n\t \n\tif (test_bit(SAS_DEV_GONE, &dev->state))\n\t\tgoto out;\n\n\ttask = sas_alloc_task(GFP_ATOMIC);\n\tif (!task)\n\t\tgoto out;\n\ttask->dev = dev;\n\ttask->task_proto = SAS_PROTOCOL_STP;\n\ttask->task_done = sas_ata_task_done;\n\n\t \n\tif (ata_is_ncq(qc->tf.protocol))\n\t\tqc->tf.nsect = 0;\n\n\tata_tf_to_fis(&qc->tf, qc->dev->link->pmp, 1, (u8 *)&task->ata_task.fis);\n\ttask->uldd_task = qc;\n\tif (ata_is_atapi(qc->tf.protocol)) {\n\t\tmemcpy(task->ata_task.atapi_packet, qc->cdb, qc->dev->cdb_len);\n\t\ttask->total_xfer_len = qc->nbytes;\n\t\ttask->num_scatter = qc->n_elem;\n\t\ttask->data_dir = qc->dma_dir;\n\t} else if (!ata_is_data(qc->tf.protocol)) {\n\t\ttask->data_dir = DMA_NONE;\n\t} else {\n\t\tfor_each_sg(qc->sg, sg, qc->n_elem, si)\n\t\t\txfer += sg_dma_len(sg);\n\n\t\ttask->total_xfer_len = xfer;\n\t\ttask->num_scatter = si;\n\t\ttask->data_dir = qc->dma_dir;\n\t}\n\ttask->scatter = qc->sg;\n\tqc->lldd_task = task;\n\n\ttask->ata_task.use_ncq = ata_is_ncq(qc->tf.protocol);\n\ttask->ata_task.dma_xfer = ata_is_dma(qc->tf.protocol);\n\n\tif (qc->flags & ATA_QCFLAG_RESULT_TF)\n\t\ttask->ata_task.return_fis_on_success = 1;\n\n\tif (qc->scsicmd)\n\t\tASSIGN_SAS_TASK(qc->scsicmd, task);\n\n\tret = i->dft->lldd_execute_task(task, GFP_ATOMIC);\n\tif (ret) {\n\t\tpr_debug(\"lldd_execute_task returned: %d\\n\", ret);\n\n\t\tif (qc->scsicmd)\n\t\t\tASSIGN_SAS_TASK(qc->scsicmd, NULL);\n\t\tsas_free_task(task);\n\t\tqc->lldd_task = NULL;\n\t\tret = AC_ERR_SYSTEM;\n\t}\n\n out:\n\tspin_lock(ap->lock);\n\treturn ret;\n}\n\nstatic void sas_ata_qc_fill_rtf(struct ata_queued_cmd *qc)\n{\n\tstruct domain_device *dev = qc->ap->private_data;\n\n\tata_tf_from_fis(dev->sata_dev.fis, &qc->result_tf);\n}\n\nstatic struct sas_internal *dev_to_sas_internal(struct domain_device *dev)\n{\n\treturn to_sas_internal(dev->port->ha->shost->transportt);\n}\n\nstatic int sas_get_ata_command_set(struct domain_device *dev)\n{\n\tstruct ata_taskfile tf;\n\n\tif (dev->dev_type == SAS_SATA_PENDING)\n\t\treturn ATA_DEV_UNKNOWN;\n\n\tata_tf_from_fis(dev->frame_rcvd, &tf);\n\n\treturn ata_dev_classify(&tf);\n}\n\nint sas_get_ata_info(struct domain_device *dev, struct ex_phy *phy)\n{\n\tif (phy->attached_tproto & SAS_PROTOCOL_STP)\n\t\tdev->tproto = phy->attached_tproto;\n\tif (phy->attached_sata_dev)\n\t\tdev->tproto |= SAS_SATA_DEV;\n\n\tif (phy->attached_dev_type == SAS_SATA_PENDING)\n\t\tdev->dev_type = SAS_SATA_PENDING;\n\telse {\n\t\tint res;\n\n\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tres = sas_get_report_phy_sata(dev->parent, phy->phy_id,\n\t\t\t\t\t      &dev->sata_dev.rps_resp);\n\t\tif (res) {\n\t\t\tpr_debug(\"report phy sata to %016llx:%02d returned 0x%x\\n\",\n\t\t\t\t SAS_ADDR(dev->parent->sas_addr),\n\t\t\t\t phy->phy_id, res);\n\t\t\treturn res;\n\t\t}\n\t\tmemcpy(dev->frame_rcvd, &dev->sata_dev.rps_resp.rps.fis,\n\t\t       sizeof(struct dev_to_host_fis));\n\t\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\t}\n\treturn 0;\n}\n\nstatic int sas_ata_clear_pending(struct domain_device *dev, struct ex_phy *phy)\n{\n\tint res;\n\n\t \n\tif (dev->dev_type != SAS_SATA_PENDING)\n\t\treturn 1;\n\n\t \n\tres = sas_get_ata_info(dev, phy);\n\tif (res)\n\t\treturn 0;  \n\telse\n\t\treturn 1;\n}\n\nint smp_ata_check_ready_type(struct ata_link *link)\n{\n\tstruct domain_device *dev = link->ap->private_data;\n\tstruct sas_phy *phy = sas_get_local_phy(dev);\n\tstruct domain_device *ex_dev = dev->parent;\n\tenum sas_device_type type = SAS_PHY_UNUSED;\n\tu8 sas_addr[SAS_ADDR_SIZE];\n\tint res;\n\n\tres = sas_get_phy_attached_dev(ex_dev, phy->number, sas_addr, &type);\n\tsas_put_local_phy(phy);\n\tif (res)\n\t\treturn res;\n\n\tswitch (type) {\n\tcase SAS_SATA_PENDING:\n\t\treturn 0;\n\tcase SAS_END_DEVICE:\n\t\treturn 1;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL_GPL(smp_ata_check_ready_type);\n\nstatic int smp_ata_check_ready(struct ata_link *link)\n{\n\tint res;\n\tstruct ata_port *ap = link->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct domain_device *ex_dev = dev->parent;\n\tstruct sas_phy *phy = sas_get_local_phy(dev);\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy->number];\n\n\tres = sas_ex_phy_discover(ex_dev, phy->number);\n\tsas_put_local_phy(phy);\n\n\t \n\tif (res == -ECOMM)\n\t\treturn res;\n\tif (res != SMP_RESP_FUNC_ACC)\n\t\treturn 0;\n\n\tswitch (ex_phy->attached_dev_type) {\n\tcase SAS_SATA_PENDING:\n\t\treturn 0;\n\tcase SAS_END_DEVICE:\n\t\tif (ex_phy->attached_sata_dev)\n\t\t\treturn sas_ata_clear_pending(dev, ex_phy);\n\t\tfallthrough;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic int local_ata_check_ready(struct ata_link *link)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\n\tif (i->dft->lldd_ata_check_ready)\n\t\treturn i->dft->lldd_ata_check_ready(dev);\n\telse {\n\t\t \n\t\treturn 1;\n\t}\n}\n\nstatic int sas_ata_printk(const char *level, const struct domain_device *ddev,\n\t\t\t  const char *fmt, ...)\n{\n\tstruct ata_port *ap = ddev->sata_dev.ap;\n\tstruct device *dev = &ddev->rphy->dev;\n\tstruct va_format vaf;\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tr = printk(\"%s\" SAS_FMT \"ata%u: %s: %pV\",\n\t\t   level, ap->print_id, dev_name(dev), &vaf);\n\n\tva_end(args);\n\n\treturn r;\n}\n\nstatic int sas_ata_wait_after_reset(struct domain_device *dev, unsigned long deadline)\n{\n\tstruct sata_device *sata_dev = &dev->sata_dev;\n\tint (*check_ready)(struct ata_link *link);\n\tstruct ata_port *ap = sata_dev->ap;\n\tstruct ata_link *link = &ap->link;\n\tstruct sas_phy *phy;\n\tint ret;\n\n\tphy = sas_get_local_phy(dev);\n\tif (scsi_is_sas_phy_local(phy))\n\t\tcheck_ready = local_ata_check_ready;\n\telse\n\t\tcheck_ready = smp_ata_check_ready;\n\tsas_put_local_phy(phy);\n\n\tret = ata_wait_after_reset(link, deadline, check_ready);\n\tif (ret && ret != -EAGAIN)\n\t\tsas_ata_printk(KERN_ERR, dev, \"reset failed (errno=%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int sas_ata_hard_reset(struct ata_link *link, unsigned int *class,\n\t\t\t      unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\tint ret;\n\n\tret = i->dft->lldd_I_T_nexus_reset(dev);\n\tif (ret == -ENODEV)\n\t\treturn ret;\n\n\tif (ret != TMF_RESP_FUNC_COMPLETE)\n\t\tsas_ata_printk(KERN_DEBUG, dev, \"Unable to reset ata device?\\n\");\n\n\tret = sas_ata_wait_after_reset(dev, deadline);\n\n\t*class = dev->sata_dev.class;\n\n\tap->cbl = ATA_CBL_SATA;\n\treturn ret;\n}\n\n \nstatic void sas_ata_internal_abort(struct sas_task *task)\n{\n\tstruct sas_internal *si = dev_to_sas_internal(task->dev);\n\tunsigned long flags;\n\tint res;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_ABORTED ||\n\t    task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tpr_debug(\"%s: Task %p already finished.\\n\", __func__, task);\n\t\tgoto out;\n\t}\n\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tres = si->dft->lldd_abort_task(task);\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE ||\n\t    res == TMF_RESP_FUNC_COMPLETE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tgoto out;\n\t}\n\n\t \n\tpr_warn(\"%s: Task %p leaked.\\n\", __func__, task);\n\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags &= ~SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\treturn;\n out:\n\tsas_free_task(task);\n}\n\nstatic void sas_ata_post_internal(struct ata_queued_cmd *qc)\n{\n\tif (qc->flags & ATA_QCFLAG_EH)\n\t\tqc->err_mask |= AC_ERR_OTHER;\n\n\tif (qc->err_mask) {\n\t\t \n\t\tstruct sas_task *task = qc->lldd_task;\n\n\t\tqc->lldd_task = NULL;\n\t\tif (!task)\n\t\t\treturn;\n\t\ttask->uldd_task = NULL;\n\t\tsas_ata_internal_abort(task);\n\t}\n}\n\n\nstatic void sas_ata_set_dmamode(struct ata_port *ap, struct ata_device *ata_dev)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_internal *i = dev_to_sas_internal(dev);\n\n\tif (i->dft->lldd_ata_set_dmamode)\n\t\ti->dft->lldd_ata_set_dmamode(dev);\n}\n\nstatic void sas_ata_sched_eh(struct ata_port *ap)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->lock, flags);\n\tif (!test_and_set_bit(SAS_DEV_EH_PENDING, &dev->state))\n\t\tha->eh_active++;\n\tata_std_sched_eh(ap);\n\tspin_unlock_irqrestore(&ha->lock, flags);\n}\n\nvoid sas_ata_end_eh(struct ata_port *ap)\n{\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->lock, flags);\n\tif (test_and_clear_bit(SAS_DEV_EH_PENDING, &dev->state))\n\t\tha->eh_active--;\n\tspin_unlock_irqrestore(&ha->lock, flags);\n}\n\nstatic int sas_ata_prereset(struct ata_link *link, unsigned long deadline)\n{\n\tstruct ata_port *ap = link->ap;\n\tstruct domain_device *dev = ap->private_data;\n\tstruct sas_phy *local_phy = sas_get_local_phy(dev);\n\tint res = 0;\n\n\tif (!local_phy->enabled || test_bit(SAS_DEV_GONE, &dev->state))\n\t\tres = -ENOENT;\n\tsas_put_local_phy(local_phy);\n\n\treturn res;\n}\n\nstatic struct ata_port_operations sas_sata_ops = {\n\t.prereset\t\t= sas_ata_prereset,\n\t.hardreset\t\t= sas_ata_hard_reset,\n\t.error_handler\t\t= ata_std_error_handler,\n\t.post_internal_cmd\t= sas_ata_post_internal,\n\t.qc_defer               = ata_std_qc_defer,\n\t.qc_prep\t\t= ata_noop_qc_prep,\n\t.qc_issue\t\t= sas_ata_qc_issue,\n\t.qc_fill_rtf\t\t= sas_ata_qc_fill_rtf,\n\t.set_dmamode\t\t= sas_ata_set_dmamode,\n\t.sched_eh\t\t= sas_ata_sched_eh,\n\t.end_eh\t\t\t= sas_ata_end_eh,\n};\n\nstatic struct ata_port_info sata_port_info = {\n\t.flags = ATA_FLAG_SATA | ATA_FLAG_PIO_DMA | ATA_FLAG_NCQ |\n\t\t ATA_FLAG_SAS_HOST | ATA_FLAG_FPDMA_AUX,\n\t.pio_mask = ATA_PIO4,\n\t.mwdma_mask = ATA_MWDMA2,\n\t.udma_mask = ATA_UDMA6,\n\t.port_ops = &sas_sata_ops\n};\n\nint sas_ata_init(struct domain_device *found_dev)\n{\n\tstruct sas_ha_struct *ha = found_dev->port->ha;\n\tstruct Scsi_Host *shost = ha->shost;\n\tstruct ata_host *ata_host;\n\tstruct ata_port *ap;\n\tint rc;\n\n\tata_host = kzalloc(sizeof(*ata_host), GFP_KERNEL);\n\tif (!ata_host)\t{\n\t\tpr_err(\"ata host alloc failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tata_host_init(ata_host, ha->dev, &sas_sata_ops);\n\n\tap = ata_sas_port_alloc(ata_host, &sata_port_info, shost);\n\tif (!ap) {\n\t\tpr_err(\"ata_sas_port_alloc failed.\\n\");\n\t\trc = -ENODEV;\n\t\tgoto free_host;\n\t}\n\n\tap->private_data = found_dev;\n\tap->cbl = ATA_CBL_SATA;\n\tap->scsi_host = shost;\n\n\trc = ata_sas_tport_add(ata_host->dev, ap);\n\tif (rc)\n\t\tgoto destroy_port;\n\n\tfound_dev->sata_dev.ata_host = ata_host;\n\tfound_dev->sata_dev.ap = ap;\n\n\treturn 0;\n\ndestroy_port:\n\tkfree(ap);\nfree_host:\n\tata_host_put(ata_host);\n\treturn rc;\n}\n\nvoid sas_ata_task_abort(struct sas_task *task)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tstruct completion *waiting;\n\n\t \n\tif (qc->scsicmd) {\n\t\tblk_abort_request(scsi_cmd_to_rq(qc->scsicmd));\n\t\treturn;\n\t}\n\n\t \n\tqc->flags &= ~ATA_QCFLAG_ACTIVE;\n\tqc->flags |= ATA_QCFLAG_EH;\n\tqc->err_mask |= AC_ERR_TIMEOUT;\n\twaiting = qc->private_data;\n\tcomplete(waiting);\n}\n\nvoid sas_probe_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tata_port_probe(dev->sata_dev.ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsas_ata_wait_eh(dev);\n\n\t\t \n\t\tif (!ata_dev_enabled(sas_to_ata_dev(dev)))\n\t\t\tsas_fail_probe(dev, __func__, -ENODEV);\n\t}\n\n}\n\nint sas_ata_add_dev(struct domain_device *parent, struct ex_phy *phy,\n\t\t    struct domain_device *child, int phy_id)\n{\n\tstruct sas_rphy *rphy;\n\tint ret;\n\n\tif (child->linkrate > parent->min_linkrate) {\n\t\tstruct sas_phy *cphy = child->phy;\n\t\tenum sas_linkrate min_prate = cphy->minimum_linkrate,\n\t\t\tparent_min_lrate = parent->min_linkrate,\n\t\t\tmin_linkrate = (min_prate > parent_min_lrate) ?\n\t\t\t\t\tparent_min_lrate : 0;\n\t\tstruct sas_phy_linkrates rates = {\n\t\t\t.maximum_linkrate = parent->min_linkrate,\n\t\t\t.minimum_linkrate = min_linkrate,\n\t\t};\n\n\t\tpr_notice(\"ex %016llx phy%02d SATA device linkrate > min pathway connection rate, attempting to lower device linkrate\\n\",\n\t\t\t  SAS_ADDR(child->sas_addr), phy_id);\n\t\tret = sas_smp_phy_control(parent, phy_id,\n\t\t\t\t\t  PHY_FUNC_LINK_RESET, &rates);\n\t\tif (ret) {\n\t\t\tpr_err(\"ex %016llx phy%02d SATA device could not set linkrate (%d)\\n\",\n\t\t\t       SAS_ADDR(child->sas_addr), phy_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tpr_notice(\"ex %016llx phy%02d SATA device set linkrate successfully\\n\",\n\t\t\t  SAS_ADDR(child->sas_addr), phy_id);\n\t\tchild->linkrate = child->min_linkrate;\n\t}\n\tret = sas_get_ata_info(child, phy);\n\tif (ret)\n\t\treturn ret;\n\n\tsas_init_dev(child);\n\tret = sas_ata_init(child);\n\tif (ret)\n\t\treturn ret;\n\n\trphy = sas_end_device_alloc(phy->port);\n\tif (!rphy)\n\t\treturn -ENOMEM;\n\n\trphy->identify.phy_identifier = phy_id;\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\n\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\tret = sas_discover_sata(child);\n\tif (ret) {\n\t\tpr_notice(\"sas_discover_sata() for device %16llx at %016llx:%02d returned 0x%x\\n\",\n\t\t\t  SAS_ADDR(child->sas_addr),\n\t\t\t  SAS_ADDR(parent->sas_addr), phy_id, ret);\n\t\tsas_rphy_free(child->rphy);\n\t\tlist_del(&child->disco_list_node);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void sas_ata_flush_pm_eh(struct asd_sas_port *port, const char *func)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe(dev, n, &port->dev_list, dev_list_node) {\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsas_ata_wait_eh(dev);\n\n\t\t \n\t\tif (ata_dev_disabled(sas_to_ata_dev(dev)))\n\t\t\tsas_fail_probe(dev, func, -ENODEV);\n\t}\n}\n\nvoid sas_suspend_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tstruct sata_device *sata;\n\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsata = &dev->sata_dev;\n\t\tif (sata->ap->pm_mesg.event == PM_EVENT_SUSPEND)\n\t\t\tcontinue;\n\n\t\tata_sas_port_suspend(sata->ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tsas_ata_flush_pm_eh(port, __func__);\n}\n\nvoid sas_resume_sata(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev;\n\n\tmutex_lock(&port->ha->disco_mutex);\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tstruct sata_device *sata;\n\n\t\tif (!dev_is_sata(dev))\n\t\t\tcontinue;\n\n\t\tsata = &dev->sata_dev;\n\t\tif (sata->ap->pm_mesg.event == PM_EVENT_ON)\n\t\t\tcontinue;\n\n\t\tata_sas_port_resume(sata->ap);\n\t}\n\tmutex_unlock(&port->ha->disco_mutex);\n\n\tsas_ata_flush_pm_eh(port, __func__);\n}\n\n \nint sas_discover_sata(struct domain_device *dev)\n{\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\n\treturn sas_notify_lldd_dev_found(dev);\n}\n\nstatic void async_sas_ata_eh(void *data, async_cookie_t cookie)\n{\n\tstruct domain_device *dev = data;\n\tstruct ata_port *ap = dev->sata_dev.ap;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\n\tsas_ata_printk(KERN_DEBUG, dev, \"dev error handler\\n\");\n\tata_scsi_port_error_handler(ha->shost, ap);\n\tsas_put_device(dev);\n}\n\nvoid sas_ata_strategy_handler(struct Scsi_Host *shost)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\tASYNC_DOMAIN_EXCLUSIVE(async);\n\tint i;\n\n\t \n\tsas_disable_revalidation(sas_ha);\n\n\tspin_lock_irq(&sas_ha->phy_port_lock);\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = sas_ha->sas_port[i];\n\t\tstruct domain_device *dev;\n\n\t\tspin_lock(&port->dev_list_lock);\n\t\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\t\tif (!dev_is_sata(dev))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tkref_get(&dev->kref);\n\n\t\t\tasync_schedule_domain(async_sas_ata_eh, dev, &async);\n\t\t}\n\t\tspin_unlock(&port->dev_list_lock);\n\t}\n\tspin_unlock_irq(&sas_ha->phy_port_lock);\n\n\tasync_synchronize_full_domain(&async);\n\n\tsas_enable_revalidation(sas_ha);\n}\n\nvoid sas_ata_eh(struct Scsi_Host *shost, struct list_head *work_q)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tstruct domain_device *eh_dev;\n\n\tdo {\n\t\tLIST_HEAD(sata_q);\n\t\teh_dev = NULL;\n\n\t\tlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\n\t\t\tstruct domain_device *ddev = cmd_to_domain_dev(cmd);\n\n\t\t\tif (!dev_is_sata(ddev) || TO_SAS_TASK(cmd))\n\t\t\t\tcontinue;\n\t\t\tif (eh_dev && eh_dev != ddev)\n\t\t\t\tcontinue;\n\t\t\teh_dev = ddev;\n\t\t\tlist_move(&cmd->eh_entry, &sata_q);\n\t\t}\n\n\t\tif (!list_empty(&sata_q)) {\n\t\t\tstruct ata_port *ap = eh_dev->sata_dev.ap;\n\n\t\t\tsas_ata_printk(KERN_DEBUG, eh_dev, \"cmd error handler\\n\");\n\t\t\tata_scsi_cmd_error_handler(shost, ap, &sata_q);\n\t\t\t \n\t\t\twhile (!list_empty(&sata_q))\n\t\t\t\tlist_del_init(sata_q.next);\n\t\t}\n\t} while (eh_dev);\n}\n\nvoid sas_ata_schedule_reset(struct domain_device *dev)\n{\n\tstruct ata_eh_info *ehi;\n\tstruct ata_port *ap;\n\tunsigned long flags;\n\n\tif (!dev_is_sata(dev))\n\t\treturn;\n\n\tap = dev->sata_dev.ap;\n\tehi = &ap->link.eh_info;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tehi->err_mask |= AC_ERR_TIMEOUT;\n\tehi->action |= ATA_EH_RESET;\n\tata_port_schedule_eh(ap);\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\nEXPORT_SYMBOL_GPL(sas_ata_schedule_reset);\n\nvoid sas_ata_wait_eh(struct domain_device *dev)\n{\n\tstruct ata_port *ap;\n\n\tif (!dev_is_sata(dev))\n\t\treturn;\n\n\tap = dev->sata_dev.ap;\n\tata_port_wait_eh(ap);\n}\n\nvoid sas_ata_device_link_abort(struct domain_device *device, bool force_reset)\n{\n\tstruct ata_port *ap = device->sata_dev.ap;\n\tstruct ata_link *link = &ap->link;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(ap->lock, flags);\n\tdevice->sata_dev.fis[2] = ATA_ERR | ATA_DRDY;  \n\tdevice->sata_dev.fis[3] = ATA_ABORTED;  \n\n\tlink->eh_info.err_mask |= AC_ERR_DEV;\n\tif (force_reset)\n\t\tlink->eh_info.action |= ATA_EH_RESET;\n\tata_link_abort(link);\n\tspin_unlock_irqrestore(ap->lock, flags);\n}\nEXPORT_SYMBOL_GPL(sas_ata_device_link_abort);\n\nint sas_execute_ata_cmd(struct domain_device *device, u8 *fis, int force_phy_id)\n{\n\tstruct sas_tmf_task tmf_task = {};\n\treturn sas_execute_tmf(device, fis, sizeof(struct host_to_dev_fis),\n\t\t\t       force_phy_id, &tmf_task);\n}\nEXPORT_SYMBOL_GPL(sas_execute_ata_cmd);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}