{
  "module_name": "sas_init.c",
  "hash_id": "19c995d0d93de08b5229f2f57a3b6ac140ce377a6587b129ec300c49ac19c0f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_init.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <scsi/sas_ata.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n\n#include \"sas_internal.h\"\n\n#include \"scsi_sas_internal.h\"\n\nstatic struct kmem_cache *sas_task_cache;\nstatic struct kmem_cache *sas_event_cache;\n\nstruct sas_task *sas_alloc_task(gfp_t flags)\n{\n\tstruct sas_task *task = kmem_cache_zalloc(sas_task_cache, flags);\n\n\tif (task) {\n\t\tspin_lock_init(&task->task_state_lock);\n\t\ttask->task_state_flags = SAS_TASK_STATE_PENDING;\n\t}\n\n\treturn task;\n}\n\nstruct sas_task *sas_alloc_slow_task(gfp_t flags)\n{\n\tstruct sas_task *task = sas_alloc_task(flags);\n\tstruct sas_task_slow *slow = kmalloc(sizeof(*slow), flags);\n\n\tif (!task || !slow) {\n\t\tif (task)\n\t\t\tkmem_cache_free(sas_task_cache, task);\n\t\tkfree(slow);\n\t\treturn NULL;\n\t}\n\n\ttask->slow_task = slow;\n\tslow->task = task;\n\ttimer_setup(&slow->timer, NULL, 0);\n\tinit_completion(&slow->completion);\n\n\treturn task;\n}\n\nvoid sas_free_task(struct sas_task *task)\n{\n\tif (task) {\n\t\tkfree(task->slow_task);\n\t\tkmem_cache_free(sas_task_cache, task);\n\t}\n}\n\n \nvoid sas_hash_addr(u8 *hashed, const u8 *sas_addr)\n{\n\tconst u32 poly = 0x00DB2777;\n\tu32 r = 0;\n\tint i;\n\n\tfor (i = 0; i < SAS_ADDR_SIZE; i++) {\n\t\tint b;\n\n\t\tfor (b = (SAS_ADDR_SIZE - 1); b >= 0; b--) {\n\t\t\tr <<= 1;\n\t\t\tif ((1 << b) & sas_addr[i]) {\n\t\t\t\tif (!(r & 0x01000000))\n\t\t\t\t\tr ^= poly;\n\t\t\t} else if (r & 0x01000000) {\n\t\t\t\tr ^= poly;\n\t\t\t}\n\t\t}\n\t}\n\n\thashed[0] = (r >> 16) & 0xFF;\n\thashed[1] = (r >> 8) & 0xFF;\n\thashed[2] = r & 0xFF;\n}\n\nint sas_register_ha(struct sas_ha_struct *sas_ha)\n{\n\tchar name[64];\n\tint error = 0;\n\n\tmutex_init(&sas_ha->disco_mutex);\n\tspin_lock_init(&sas_ha->phy_port_lock);\n\tsas_hash_addr(sas_ha->hashed_sas_addr, sas_ha->sas_addr);\n\n\tset_bit(SAS_HA_REGISTERED, &sas_ha->state);\n\tspin_lock_init(&sas_ha->lock);\n\tmutex_init(&sas_ha->drain_mutex);\n\tinit_waitqueue_head(&sas_ha->eh_wait_q);\n\tINIT_LIST_HEAD(&sas_ha->defer_q);\n\tINIT_LIST_HEAD(&sas_ha->eh_dev_q);\n\n\tsas_ha->event_thres = SAS_PHY_SHUTDOWN_THRES;\n\n\terror = sas_register_phys(sas_ha);\n\tif (error) {\n\t\tpr_notice(\"couldn't register sas phys:%d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = sas_register_ports(sas_ha);\n\tif (error) {\n\t\tpr_notice(\"couldn't register sas ports:%d\\n\", error);\n\t\tgoto Undo_phys;\n\t}\n\n\terror = -ENOMEM;\n\tsnprintf(name, sizeof(name), \"%s_event_q\", dev_name(sas_ha->dev));\n\tsas_ha->event_q = create_singlethread_workqueue(name);\n\tif (!sas_ha->event_q)\n\t\tgoto Undo_ports;\n\n\tsnprintf(name, sizeof(name), \"%s_disco_q\", dev_name(sas_ha->dev));\n\tsas_ha->disco_q = create_singlethread_workqueue(name);\n\tif (!sas_ha->disco_q)\n\t\tgoto Undo_event_q;\n\n\tINIT_LIST_HEAD(&sas_ha->eh_done_q);\n\tINIT_LIST_HEAD(&sas_ha->eh_ata_q);\n\n\treturn 0;\n\nUndo_event_q:\n\tdestroy_workqueue(sas_ha->event_q);\nUndo_ports:\n\tsas_unregister_ports(sas_ha);\nUndo_phys:\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(sas_register_ha);\n\nstatic void sas_disable_events(struct sas_ha_struct *sas_ha)\n{\n\t \n\tmutex_lock(&sas_ha->drain_mutex);\n\tspin_lock_irq(&sas_ha->lock);\n\tclear_bit(SAS_HA_REGISTERED, &sas_ha->state);\n\tspin_unlock_irq(&sas_ha->lock);\n\t__sas_drain_work(sas_ha);\n\tmutex_unlock(&sas_ha->drain_mutex);\n}\n\nint sas_unregister_ha(struct sas_ha_struct *sas_ha)\n{\n\tsas_disable_events(sas_ha);\n\tsas_unregister_ports(sas_ha);\n\n\t \n\tmutex_lock(&sas_ha->drain_mutex);\n\t__sas_drain_work(sas_ha);\n\tmutex_unlock(&sas_ha->drain_mutex);\n\n\tdestroy_workqueue(sas_ha->disco_q);\n\tdestroy_workqueue(sas_ha->event_q);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sas_unregister_ha);\n\nstatic int sas_get_linkerrors(struct sas_phy *phy)\n{\n\tif (scsi_is_sas_phy_local(phy)) {\n\t\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\t\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\t\tstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\n\t\tstruct sas_internal *i =\n\t\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\t\treturn i->dft->lldd_control_phy(asd_phy, PHY_FUNC_GET_EVENTS, NULL);\n\t}\n\n\treturn sas_smp_get_phy_events(phy);\n}\n\nint sas_try_ata_reset(struct asd_sas_phy *asd_phy)\n{\n\tstruct domain_device *dev = NULL;\n\n\t \n\tif (asd_phy->port)\n\t\tdev = asd_phy->port->port_dev;\n\n\t \n\tif (dev)\n\t\tdev = sas_find_dev_by_rphy(dev->rphy);\n\n\tif (dev && dev_is_sata(dev)) {\n\t\tsas_ata_schedule_reset(dev);\n\t\tsas_ata_wait_eh(dev);\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstatic int transport_sas_phy_reset(struct sas_phy *phy, int hard_reset)\n{\n\tenum phy_func reset_type;\n\n\tif (hard_reset)\n\t\treset_type = PHY_FUNC_HARD_RESET;\n\telse\n\t\treset_type = PHY_FUNC_LINK_RESET;\n\n\tif (scsi_is_sas_phy_local(phy)) {\n\t\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\t\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\t\tstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\n\t\tstruct sas_internal *i =\n\t\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\t\tif (!hard_reset && sas_try_ata_reset(asd_phy) == 0)\n\t\t\treturn 0;\n\t\treturn i->dft->lldd_control_phy(asd_phy, reset_type, NULL);\n\t} else {\n\t\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\t\tstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\n\t\tstruct domain_device *ata_dev = sas_ex_to_ata(ddev, phy->number);\n\n\t\tif (ata_dev && !hard_reset) {\n\t\t\tsas_ata_schedule_reset(ata_dev);\n\t\t\tsas_ata_wait_eh(ata_dev);\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn sas_smp_phy_control(ddev, phy->number, reset_type, NULL);\n\t}\n}\n\nint sas_phy_enable(struct sas_phy *phy, int enable)\n{\n\tint ret;\n\tenum phy_func cmd;\n\n\tif (enable)\n\t\tcmd = PHY_FUNC_LINK_RESET;\n\telse\n\t\tcmd = PHY_FUNC_DISABLE;\n\n\tif (scsi_is_sas_phy_local(phy)) {\n\t\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\t\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\t\tstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\n\t\tstruct sas_internal *i =\n\t\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\t\tif (enable)\n\t\t\tret = transport_sas_phy_reset(phy, 0);\n\t\telse\n\t\t\tret = i->dft->lldd_control_phy(asd_phy, cmd, NULL);\n\t} else {\n\t\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\t\tstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\n\n\t\tif (enable)\n\t\t\tret = transport_sas_phy_reset(phy, 0);\n\t\telse\n\t\t\tret = sas_smp_phy_control(ddev, phy->number, cmd, NULL);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sas_phy_enable);\n\nint sas_phy_reset(struct sas_phy *phy, int hard_reset)\n{\n\tint ret;\n\tenum phy_func reset_type;\n\n\tif (!phy->enabled)\n\t\treturn -ENODEV;\n\n\tif (hard_reset)\n\t\treset_type = PHY_FUNC_HARD_RESET;\n\telse\n\t\treset_type = PHY_FUNC_LINK_RESET;\n\n\tif (scsi_is_sas_phy_local(phy)) {\n\t\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\t\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\t\tstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\n\t\tstruct sas_internal *i =\n\t\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\t\tret = i->dft->lldd_control_phy(asd_phy, reset_type, NULL);\n\t} else {\n\t\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\t\tstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\n\t\tret = sas_smp_phy_control(ddev, phy->number, reset_type, NULL);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sas_phy_reset);\n\nint sas_set_phy_speed(struct sas_phy *phy,\n\t\t      struct sas_phy_linkrates *rates)\n{\n\tint ret;\n\n\tif ((rates->minimum_linkrate &&\n\t     rates->minimum_linkrate > phy->maximum_linkrate) ||\n\t    (rates->maximum_linkrate &&\n\t     rates->maximum_linkrate < phy->minimum_linkrate))\n\t\treturn -EINVAL;\n\n\tif (rates->minimum_linkrate &&\n\t    rates->minimum_linkrate < phy->minimum_linkrate_hw)\n\t\trates->minimum_linkrate = phy->minimum_linkrate_hw;\n\n\tif (rates->maximum_linkrate &&\n\t    rates->maximum_linkrate > phy->maximum_linkrate_hw)\n\t\trates->maximum_linkrate = phy->maximum_linkrate_hw;\n\n\tif (scsi_is_sas_phy_local(phy)) {\n\t\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\t\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\t\tstruct asd_sas_phy *asd_phy = sas_ha->sas_phy[phy->number];\n\t\tstruct sas_internal *i =\n\t\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\t\tret = i->dft->lldd_control_phy(asd_phy, PHY_FUNC_SET_LINK_RATE,\n\t\t\t\t\t       rates);\n\t} else {\n\t\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\t\tstruct domain_device *ddev = sas_find_dev_by_rphy(rphy);\n\t\tret = sas_smp_phy_control(ddev, phy->number,\n\t\t\t\t\t  PHY_FUNC_LINK_RESET, rates);\n\n\t}\n\n\treturn ret;\n}\n\nvoid sas_prep_resume_ha(struct sas_ha_struct *ha)\n{\n\tint i;\n\n\tset_bit(SAS_HA_REGISTERED, &ha->state);\n\tset_bit(SAS_HA_RESUMING, &ha->state);\n\n\t \n\tfor (i = 0; i < ha->num_phys; i++) {\n\t\tstruct asd_sas_phy *phy = ha->sas_phy[i];\n\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tphy->frame_rcvd_size = 0;\n\t}\n}\nEXPORT_SYMBOL(sas_prep_resume_ha);\n\nstatic int phys_suspended(struct sas_ha_struct *ha)\n{\n\tint i, rc = 0;\n\n\tfor (i = 0; i < ha->num_phys; i++) {\n\t\tstruct asd_sas_phy *phy = ha->sas_phy[i];\n\n\t\tif (phy->suspended)\n\t\t\trc++;\n\t}\n\n\treturn rc;\n}\n\nstatic void sas_resume_insert_broadcast_ha(struct sas_ha_struct *ha)\n{\n\tint i;\n\n\tfor (i = 0; i < ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = ha->sas_port[i];\n\t\tstruct domain_device *dev = port->port_dev;\n\n\t\tif (dev && dev_is_expander(dev->dev_type)) {\n\t\t\tstruct asd_sas_phy *first_phy;\n\n\t\t\tspin_lock(&port->phy_list_lock);\n\t\t\tfirst_phy = list_first_entry_or_null(\n\t\t\t\t&port->phy_list, struct asd_sas_phy,\n\t\t\t\tport_phy_el);\n\t\t\tspin_unlock(&port->phy_list_lock);\n\n\t\t\tif (first_phy)\n\t\t\t\tsas_notify_port_event(first_phy,\n\t\t\t\t\tPORTE_BROADCAST_RCVD, GFP_KERNEL);\n\t\t}\n\t}\n}\n\nstatic void _sas_resume_ha(struct sas_ha_struct *ha, bool drain)\n{\n\tconst unsigned long tmo = msecs_to_jiffies(25000);\n\tint i;\n\n\t \n\ti = phys_suspended(ha);\n\tif (i)\n\t\tdev_info(ha->dev, \"waiting up to 25 seconds for %d phy%s to resume\\n\",\n\t\t\t i, i > 1 ? \"s\" : \"\");\n\twait_event_timeout(ha->eh_wait_q, phys_suspended(ha) == 0, tmo);\n\tfor (i = 0; i < ha->num_phys; i++) {\n\t\tstruct asd_sas_phy *phy = ha->sas_phy[i];\n\n\t\tif (phy->suspended) {\n\t\t\tdev_warn(&phy->phy->dev, \"resume timeout\\n\");\n\t\t\tsas_notify_phy_event(phy, PHYE_RESUME_TIMEOUT,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t}\n\t}\n\n\t \n\tscsi_unblock_requests(ha->shost);\n\tif (drain)\n\t\tsas_drain_work(ha);\n\tclear_bit(SAS_HA_RESUMING, &ha->state);\n\n\tsas_queue_deferred_work(ha);\n\t \n\tsas_resume_insert_broadcast_ha(ha);\n}\n\nvoid sas_resume_ha(struct sas_ha_struct *ha)\n{\n\t_sas_resume_ha(ha, true);\n}\nEXPORT_SYMBOL(sas_resume_ha);\n\n \nvoid sas_resume_ha_no_sync(struct sas_ha_struct *ha)\n{\n\t_sas_resume_ha(ha, false);\n}\nEXPORT_SYMBOL(sas_resume_ha_no_sync);\n\nvoid sas_suspend_ha(struct sas_ha_struct *ha)\n{\n\tint i;\n\n\tsas_disable_events(ha);\n\tscsi_block_requests(ha->shost);\n\tfor (i = 0; i < ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = ha->sas_port[i];\n\n\t\tsas_discover_event(port, DISCE_SUSPEND);\n\t}\n\n\t \n\tmutex_lock(&ha->drain_mutex);\n\t__sas_drain_work(ha);\n\tmutex_unlock(&ha->drain_mutex);\n}\nEXPORT_SYMBOL(sas_suspend_ha);\n\nstatic void sas_phy_release(struct sas_phy *phy)\n{\n\tkfree(phy->hostdata);\n\tphy->hostdata = NULL;\n}\n\nstatic void phy_reset_work(struct work_struct *work)\n{\n\tstruct sas_phy_data *d = container_of(work, typeof(*d), reset_work.work);\n\n\td->reset_result = transport_sas_phy_reset(d->phy, d->hard_reset);\n}\n\nstatic void phy_enable_work(struct work_struct *work)\n{\n\tstruct sas_phy_data *d = container_of(work, typeof(*d), enable_work.work);\n\n\td->enable_result = sas_phy_enable(d->phy, d->enable);\n}\n\nstatic int sas_phy_setup(struct sas_phy *phy)\n{\n\tstruct sas_phy_data *d = kzalloc(sizeof(*d), GFP_KERNEL);\n\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&d->event_lock);\n\tINIT_SAS_WORK(&d->reset_work, phy_reset_work);\n\tINIT_SAS_WORK(&d->enable_work, phy_enable_work);\n\td->phy = phy;\n\tphy->hostdata = d;\n\n\treturn 0;\n}\n\nstatic int queue_phy_reset(struct sas_phy *phy, int hard_reset)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\tstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\n\tstruct sas_phy_data *d = phy->hostdata;\n\tint rc;\n\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tpm_runtime_get_sync(ha->dev);\n\t \n\tmutex_lock(&d->event_lock);\n\td->reset_result = 0;\n\td->hard_reset = hard_reset;\n\n\tspin_lock_irq(&ha->lock);\n\tsas_queue_work(ha, &d->reset_work);\n\tspin_unlock_irq(&ha->lock);\n\n\trc = sas_drain_work(ha);\n\tif (rc == 0)\n\t\trc = d->reset_result;\n\tmutex_unlock(&d->event_lock);\n\tpm_runtime_put_sync(ha->dev);\n\n\treturn rc;\n}\n\nstatic int queue_phy_enable(struct sas_phy *phy, int enable)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\n\tstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\n\tstruct sas_phy_data *d = phy->hostdata;\n\tint rc;\n\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tpm_runtime_get_sync(ha->dev);\n\t \n\tmutex_lock(&d->event_lock);\n\td->enable_result = 0;\n\td->enable = enable;\n\n\tspin_lock_irq(&ha->lock);\n\tsas_queue_work(ha, &d->enable_work);\n\tspin_unlock_irq(&ha->lock);\n\n\trc = sas_drain_work(ha);\n\tif (rc == 0)\n\t\trc = d->enable_result;\n\tmutex_unlock(&d->event_lock);\n\tpm_runtime_put_sync(ha->dev);\n\n\treturn rc;\n}\n\nstatic struct sas_function_template sft = {\n\t.phy_enable = queue_phy_enable,\n\t.phy_reset = queue_phy_reset,\n\t.phy_setup = sas_phy_setup,\n\t.phy_release = sas_phy_release,\n\t.set_phy_speed = sas_set_phy_speed,\n\t.get_linkerrors = sas_get_linkerrors,\n\t.smp_handler = sas_smp_handler,\n};\n\nstatic inline ssize_t phy_event_threshold_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", sha->event_thres);\n}\n\nstatic inline ssize_t phy_event_threshold_store(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\n\tsha->event_thres = simple_strtol(buf, NULL, 10);\n\n\t \n\tif (sha->event_thres < 32)\n\t\tsha->event_thres = 32;\n\n\treturn count;\n}\n\nDEVICE_ATTR(phy_event_threshold,\n\tS_IRUGO|S_IWUSR,\n\tphy_event_threshold_show,\n\tphy_event_threshold_store);\nEXPORT_SYMBOL_GPL(dev_attr_phy_event_threshold);\n\nstruct scsi_transport_template *\nsas_domain_attach_transport(struct sas_domain_function_template *dft)\n{\n\tstruct scsi_transport_template *stt = sas_attach_transport(&sft);\n\tstruct sas_internal *i;\n\n\tif (!stt)\n\t\treturn stt;\n\n\ti = to_sas_internal(stt);\n\ti->dft = dft;\n\tstt->create_work_queue = 1;\n\tstt->eh_strategy_handler = sas_scsi_recover_host;\n\n\treturn stt;\n}\nEXPORT_SYMBOL_GPL(sas_domain_attach_transport);\n\nstruct asd_sas_event *sas_alloc_event(struct asd_sas_phy *phy,\n\t\t\t\t      gfp_t gfp_flags)\n{\n\tstruct asd_sas_event *event;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\tevent = kmem_cache_zalloc(sas_event_cache, gfp_flags);\n\tif (!event)\n\t\treturn NULL;\n\n\tatomic_inc(&phy->event_nr);\n\n\tif (atomic_read(&phy->event_nr) > phy->ha->event_thres) {\n\t\tif (i->dft->lldd_control_phy) {\n\t\t\tif (cmpxchg(&phy->in_shutdown, 0, 1) == 0) {\n\t\t\t\tpr_notice(\"The phy%d bursting events, shut it down.\\n\",\n\t\t\t\t\t  phy->id);\n\t\t\t\tsas_notify_phy_event(phy, PHYE_SHUTDOWN,\n\t\t\t\t\t\t     gfp_flags);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ONCE(1, \"PHY control not supported.\\n\");\n\t\t\tkmem_cache_free(sas_event_cache, event);\n\t\t\tatomic_dec(&phy->event_nr);\n\t\t\tevent = NULL;\n\t\t}\n\t}\n\n\treturn event;\n}\n\nvoid sas_free_event(struct asd_sas_event *event)\n{\n\tstruct asd_sas_phy *phy = event->phy;\n\n\tkmem_cache_free(sas_event_cache, event);\n\tatomic_dec(&phy->event_nr);\n}\n\n \n\nstatic int __init sas_class_init(void)\n{\n\tsas_task_cache = KMEM_CACHE(sas_task, SLAB_HWCACHE_ALIGN);\n\tif (!sas_task_cache)\n\t\tgoto out;\n\n\tsas_event_cache = KMEM_CACHE(asd_sas_event, SLAB_HWCACHE_ALIGN);\n\tif (!sas_event_cache)\n\t\tgoto free_task_kmem;\n\n\treturn 0;\nfree_task_kmem:\n\tkmem_cache_destroy(sas_task_cache);\nout:\n\treturn -ENOMEM;\n}\n\nstatic void __exit sas_class_exit(void)\n{\n\tkmem_cache_destroy(sas_task_cache);\n\tkmem_cache_destroy(sas_event_cache);\n}\n\nMODULE_AUTHOR(\"Luben Tuikov <luben_tuikov@adaptec.com>\");\nMODULE_DESCRIPTION(\"SAS Transport Layer\");\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_init(sas_class_init);\nmodule_exit(sas_class_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}