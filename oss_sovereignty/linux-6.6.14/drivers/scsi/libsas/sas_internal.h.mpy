{
  "module_name": "sas_internal.h",
  "hash_id": "ae75144f384b0e25604b92482421b41b4ac0cc93b0f8e3e1da86ffbc46864a36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_internal.h",
  "human_readable_source": " \n \n\n#ifndef _SAS_INTERNAL_H_\n#define _SAS_INTERNAL_H_\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/libsas.h>\n#include <scsi/sas_ata.h>\n#include <linux/pm_runtime.h>\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#define SAS_FMT \"sas: \"\n\n#define pr_fmt(fmt) SAS_FMT fmt\n\n#define TO_SAS_TASK(_scsi_cmd)  ((void *)(_scsi_cmd)->host_scribble)\n#define ASSIGN_SAS_TASK(_sc, _t) do { (_sc)->host_scribble = (void *) _t; } while (0)\n\nstruct sas_phy_data {\n\t \n\tstruct sas_phy *phy;\n\tstruct mutex event_lock;\n\tint hard_reset;\n\tint reset_result;\n\tstruct sas_work reset_work;\n\tint enable;\n\tint enable_result;\n\tstruct sas_work enable_work;\n};\n\nvoid sas_scsi_recover_host(struct Scsi_Host *shost);\n\nint  sas_register_phys(struct sas_ha_struct *sas_ha);\n\nstruct asd_sas_event *sas_alloc_event(struct asd_sas_phy *phy, gfp_t gfp_flags);\nvoid sas_free_event(struct asd_sas_event *event);\n\nstruct sas_task *sas_alloc_task(gfp_t flags);\nstruct sas_task *sas_alloc_slow_task(gfp_t flags);\nvoid sas_free_task(struct sas_task *task);\n\nint  sas_register_ports(struct sas_ha_struct *sas_ha);\nvoid sas_unregister_ports(struct sas_ha_struct *sas_ha);\n\nvoid sas_disable_revalidation(struct sas_ha_struct *ha);\nvoid sas_enable_revalidation(struct sas_ha_struct *ha);\nvoid sas_queue_deferred_work(struct sas_ha_struct *ha);\nvoid __sas_drain_work(struct sas_ha_struct *ha);\n\nvoid sas_deform_port(struct asd_sas_phy *phy, int gone);\n\nvoid sas_porte_bytes_dmaed(struct work_struct *work);\nvoid sas_porte_broadcast_rcvd(struct work_struct *work);\nvoid sas_porte_link_reset_err(struct work_struct *work);\nvoid sas_porte_timer_event(struct work_struct *work);\nvoid sas_porte_hard_reset(struct work_struct *work);\nbool sas_queue_work(struct sas_ha_struct *ha, struct sas_work *sw);\n\nint sas_notify_lldd_dev_found(struct domain_device *);\nvoid sas_notify_lldd_dev_gone(struct domain_device *);\n\nvoid sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy);\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\n\t\t\tenum phy_func phy_func, struct sas_phy_linkrates *);\nint sas_smp_get_phy_events(struct sas_phy *phy);\n\nvoid sas_device_set_phy(struct domain_device *dev, struct sas_port *port);\nstruct domain_device *sas_find_dev_by_rphy(struct sas_rphy *rphy);\nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id);\nint sas_ex_phy_discover(struct domain_device *dev, int single);\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_rps_resp *rps_resp);\nint sas_get_phy_attached_dev(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, enum sas_device_type *type);\nint sas_try_ata_reset(struct asd_sas_phy *phy);\n\nvoid sas_free_device(struct kref *kref);\nvoid sas_destruct_devices(struct asd_sas_port *port);\n\nextern const work_func_t sas_phy_event_fns[PHY_NUM_EVENTS];\nextern const work_func_t sas_port_event_fns[PORT_NUM_EVENTS];\n\nvoid sas_task_internal_done(struct sas_task *task);\nvoid sas_task_internal_timedout(struct timer_list *t);\nint sas_execute_tmf(struct domain_device *device, void *parameter,\n\t\t    int para_len, int force_phy_id,\n\t\t    struct sas_tmf_task *tmf);\n\n#ifdef CONFIG_SCSI_SAS_HOST_SMP\nextern void sas_smp_host_handler(struct bsg_job *job, struct Scsi_Host *shost);\n#else\nstatic inline void sas_smp_host_handler(struct bsg_job *job,\n\t\tstruct Scsi_Host *shost)\n{\n\tshost_printk(KERN_ERR, shost,\n\t\t\"Cannot send SMP to a sas host (not enabled in CONFIG)\\n\");\n\tbsg_job_done(job, -EINVAL, 0);\n}\n#endif\n\nstatic inline bool sas_phy_match_dev_addr(struct domain_device *dev,\n\t\t\t\t\t struct ex_phy *phy)\n{\n\treturn SAS_ADDR(dev->sas_addr) == SAS_ADDR(phy->attached_sas_addr);\n}\n\nstatic inline bool sas_phy_match_port_addr(struct asd_sas_port *port,\n\t\t\t\t\t   struct ex_phy *phy)\n{\n\treturn SAS_ADDR(port->sas_addr) == SAS_ADDR(phy->attached_sas_addr);\n}\n\nstatic inline bool sas_phy_addr_match(struct ex_phy *p1, struct ex_phy *p2)\n{\n\treturn  SAS_ADDR(p1->attached_sas_addr) == SAS_ADDR(p2->attached_sas_addr);\n}\n\nstatic inline void sas_fail_probe(struct domain_device *dev, const char *func, int err)\n{\n\tpr_warn(\"%s: for %s device %016llx returned %d\\n\",\n\t\tfunc, dev->parent ? \"exp-attached\" :\n\t\t\"direct-attached\",\n\t\tSAS_ADDR(dev->sas_addr), err);\n\tsas_unregister_dev(dev->port, dev);\n}\n\nstatic inline void sas_fill_in_rphy(struct domain_device *dev,\n\t\t\t\t    struct sas_rphy *rphy)\n{\n\trphy->identify.sas_address = SAS_ADDR(dev->sas_addr);\n\trphy->identify.initiator_port_protocols = dev->iproto;\n\trphy->identify.target_port_protocols = dev->tproto;\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_DEV:\n\t\t \n\tcase SAS_END_DEVICE:\n\tcase SAS_SATA_PENDING:\n\t\trphy->identify.device_type = SAS_END_DEVICE;\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy->identify.device_type = SAS_EDGE_EXPANDER_DEVICE;\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy->identify.device_type = SAS_FANOUT_EXPANDER_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\trphy->identify.device_type = SAS_PHY_UNUSED;\n\t\tbreak;\n\t}\n}\n\nstatic inline void sas_phy_set_target(struct asd_sas_phy *p, struct domain_device *dev)\n{\n\tstruct sas_phy *phy = p->phy;\n\n\tif (dev) {\n\t\tif (dev_is_sata(dev))\n\t\t\tphy->identify.device_type = SAS_END_DEVICE;\n\t\telse\n\t\t\tphy->identify.device_type = dev->dev_type;\n\t\tphy->identify.target_port_protocols = dev->tproto;\n\t} else {\n\t\tphy->identify.device_type = SAS_PHY_UNUSED;\n\t\tphy->identify.target_port_protocols = 0;\n\t}\n}\n\nstatic inline void sas_add_parent_port(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\n\n\tif (!ex->parent_port) {\n\t\tex->parent_port = sas_port_alloc(&dev->rphy->dev, phy_id);\n\t\t \n\t\tBUG_ON(!ex->parent_port);\n\t\tBUG_ON(sas_port_add(ex->parent_port));\n\t\tsas_port_mark_backlink(ex->parent_port);\n\t}\n\tsas_port_add_phy(ex->parent_port, ex_phy->phy);\n}\n\nstatic inline struct domain_device *sas_alloc_device(void)\n{\n\tstruct domain_device *dev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\n\tif (dev) {\n\t\tINIT_LIST_HEAD(&dev->siblings);\n\t\tINIT_LIST_HEAD(&dev->dev_list_node);\n\t\tINIT_LIST_HEAD(&dev->disco_list_node);\n\t\tkref_init(&dev->kref);\n\t\tspin_lock_init(&dev->done_lock);\n\t}\n\treturn dev;\n}\n\nstatic inline void sas_put_device(struct domain_device *dev)\n{\n\tkref_put(&dev->kref, sas_free_device);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}