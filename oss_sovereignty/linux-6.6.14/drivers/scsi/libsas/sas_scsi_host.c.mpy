{
  "module_name": "sas_scsi_host.c",
  "hash_id": "7ab5c848807560a782e07008762b4a4c7b34312acac1be3e0b531dddce681027",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_scsi_host.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/firmware.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n\n#include \"sas_internal.h\"\n\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/sas_ata.h>\n#include \"scsi_sas_internal.h\"\n#include \"scsi_transport_api.h\"\n#include \"scsi_priv.h\"\n\n#include <linux/err.h>\n#include <linux/blkdev.h>\n#include <linux/freezer.h>\n#include <linux/gfp.h>\n#include <linux/scatterlist.h>\n#include <linux/libata.h>\n\n \nstatic void sas_end_task(struct scsi_cmnd *sc, struct sas_task *task)\n{\n\tstruct task_status_struct *ts = &task->task_status;\n\tenum scsi_host_status hs = DID_OK;\n\tenum exec_status stat = SAS_SAM_STAT_GOOD;\n\n\tif (ts->resp == SAS_TASK_UNDELIVERED) {\n\t\t \n\t\ths = DID_NO_CONNECT;\n\t} else {  \n\t\t \n\t\tswitch (ts->stat) {\n\t\tcase SAS_DEV_NO_RESPONSE:\n\t\tcase SAS_INTERRUPTED:\n\t\tcase SAS_PHY_DOWN:\n\t\tcase SAS_NAK_R_ERR:\n\t\tcase SAS_OPEN_TO:\n\t\t\ths = DID_NO_CONNECT;\n\t\t\tbreak;\n\t\tcase SAS_DATA_UNDERRUN:\n\t\t\tscsi_set_resid(sc, ts->residual);\n\t\t\tif (scsi_bufflen(sc) - scsi_get_resid(sc) < sc->underflow)\n\t\t\t\ths = DID_ERROR;\n\t\t\tbreak;\n\t\tcase SAS_DATA_OVERRUN:\n\t\t\ths = DID_ERROR;\n\t\t\tbreak;\n\t\tcase SAS_QUEUE_FULL:\n\t\t\ths = DID_SOFT_ERROR;  \n\t\t\tbreak;\n\t\tcase SAS_DEVICE_UNKNOWN:\n\t\t\ths = DID_BAD_TARGET;\n\t\t\tbreak;\n\t\tcase SAS_OPEN_REJECT:\n\t\t\tif (ts->open_rej_reason == SAS_OREJ_RSVD_RETRY)\n\t\t\t\ths = DID_SOFT_ERROR;  \n\t\t\telse\n\t\t\t\ths = DID_ERROR;\n\t\t\tbreak;\n\t\tcase SAS_PROTO_RESPONSE:\n\t\t\tpr_notice(\"LLDD:%s sent SAS_PROTO_RESP for an SSP task; please report this\\n\",\n\t\t\t\t  task->dev->port->ha->sas_ha_name);\n\t\t\tbreak;\n\t\tcase SAS_ABORTED_TASK:\n\t\t\ths = DID_ABORT;\n\t\t\tbreak;\n\t\tcase SAS_SAM_STAT_CHECK_CONDITION:\n\t\t\tmemcpy(sc->sense_buffer, ts->buf,\n\t\t\t       min(SCSI_SENSE_BUFFERSIZE, ts->buf_valid_size));\n\t\t\tstat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstat = ts->stat;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsc->result = (hs << 16) | stat;\n\tASSIGN_SAS_TASK(sc, NULL);\n\tsas_free_task(task);\n}\n\nstatic void sas_scsi_task_done(struct sas_task *task)\n{\n\tstruct scsi_cmnd *sc = task->uldd_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->done_lock, flags);\n\tif (test_bit(SAS_HA_FROZEN, &ha->state))\n\t\ttask = NULL;\n\telse\n\t\tASSIGN_SAS_TASK(sc, NULL);\n\tspin_unlock_irqrestore(&dev->done_lock, flags);\n\n\tif (unlikely(!task)) {\n\t\t \n\t\tpr_debug(\"task done but aborted\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(!sc)) {\n\t\tpr_debug(\"task_done called with non existing SCSI cmnd!\\n\");\n\t\tsas_free_task(task);\n\t\treturn;\n\t}\n\n\tsas_end_task(sc, task);\n\tscsi_done(sc);\n}\n\nstatic struct sas_task *sas_create_task(struct scsi_cmnd *cmd,\n\t\t\t\t\t       struct domain_device *dev,\n\t\t\t\t\t       gfp_t gfp_flags)\n{\n\tstruct sas_task *task = sas_alloc_task(gfp_flags);\n\tstruct scsi_lun lun;\n\n\tif (!task)\n\t\treturn NULL;\n\n\ttask->uldd_task = cmd;\n\tASSIGN_SAS_TASK(cmd, task);\n\n\ttask->dev = dev;\n\ttask->task_proto = task->dev->tproto;  \n\n\tint_to_scsilun(cmd->device->lun, &lun);\n\tmemcpy(task->ssp_task.LUN, &lun.scsi_lun, 8);\n\ttask->ssp_task.task_attr = TASK_ATTR_SIMPLE;\n\ttask->ssp_task.cmd = cmd;\n\n\ttask->scatter = scsi_sglist(cmd);\n\ttask->num_scatter = scsi_sg_count(cmd);\n\ttask->total_xfer_len = scsi_bufflen(cmd);\n\ttask->data_dir = cmd->sc_data_direction;\n\n\ttask->task_done = sas_scsi_task_done;\n\n\treturn task;\n}\n\nint sas_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\n{\n\tstruct sas_internal *i = to_sas_internal(host->transportt);\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_task *task;\n\tint res = 0;\n\n\t \n\tif (test_bit(SAS_DEV_GONE, &dev->state)) {\n\t\tcmd->result = DID_BAD_TARGET << 16;\n\t\tgoto out_done;\n\t}\n\n\tif (dev_is_sata(dev)) {\n\t\tspin_lock_irq(dev->sata_dev.ap->lock);\n\t\tres = ata_sas_queuecmd(cmd, dev->sata_dev.ap);\n\t\tspin_unlock_irq(dev->sata_dev.ap->lock);\n\t\treturn res;\n\t}\n\n\ttask = sas_create_task(cmd, dev, GFP_ATOMIC);\n\tif (!task)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tres = i->dft->lldd_execute_task(task, GFP_ATOMIC);\n\tif (res)\n\t\tgoto out_free_task;\n\treturn 0;\n\nout_free_task:\n\tpr_debug(\"lldd_execute_task returned: %d\\n\", res);\n\tASSIGN_SAS_TASK(cmd, NULL);\n\tsas_free_task(task);\n\tif (res == -SAS_QUEUE_FULL)\n\t\tcmd->result = DID_SOFT_ERROR << 16;  \n\telse\n\t\tcmd->result = DID_ERROR << 16;\nout_done:\n\tscsi_done(cmd);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sas_queuecommand);\n\nstatic void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\n\t \n\tsas_end_task(cmd, task);\n\n\tif (dev_is_sata(dev)) {\n\t\t \n\t\tlist_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);\n\t\treturn;\n\t}\n\n\t \n\tscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n}\n\nstatic void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_finish_cmd(cmd);\n\t}\n}\n\nstatic void sas_scsi_clear_queue_I_T(struct list_head *error_q,\n\t\t\t\t     struct domain_device *dev)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tstruct domain_device *x = cmd_to_domain_dev(cmd);\n\n\t\tif (x == dev)\n\t\t\tsas_eh_finish_cmd(cmd);\n\t}\n}\n\nstatic void sas_scsi_clear_queue_port(struct list_head *error_q,\n\t\t\t\t      struct asd_sas_port *port)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\t\tstruct asd_sas_port *x = dev->port;\n\n\t\tif (x == port)\n\t\t\tsas_eh_finish_cmd(cmd);\n\t}\n}\n\nenum task_disposition {\n\tTASK_IS_DONE,\n\tTASK_IS_ABORTED,\n\tTASK_IS_AT_LU,\n\tTASK_IS_NOT_AT_LU,\n\tTASK_ABORT_FAILED,\n};\n\nstatic enum task_disposition sas_scsi_find_task(struct sas_task *task)\n{\n\tunsigned long flags;\n\tint i, res;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(task->dev->port->ha->shost->transportt);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tpr_notice(\"%s: aborting task 0x%p\\n\", __func__, task);\n\t\tres = si->dft->lldd_abort_task(task);\n\n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\t\tpr_debug(\"%s: task 0x%p is done\\n\", __func__, task);\n\t\t\treturn TASK_IS_DONE;\n\t\t}\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\tif (res == TMF_RESP_FUNC_COMPLETE) {\n\t\t\tpr_notice(\"%s: task 0x%p is aborted\\n\",\n\t\t\t\t  __func__, task);\n\t\t\treturn TASK_IS_ABORTED;\n\t\t} else if (si->dft->lldd_query_task) {\n\t\t\tpr_notice(\"%s: querying task 0x%p\\n\", __func__, task);\n\t\t\tres = si->dft->lldd_query_task(task);\n\t\t\tswitch (res) {\n\t\t\tcase TMF_RESP_FUNC_SUCC:\n\t\t\t\tpr_notice(\"%s: task 0x%p at LU\\n\", __func__,\n\t\t\t\t\t  task);\n\t\t\t\treturn TASK_IS_AT_LU;\n\t\t\tcase TMF_RESP_FUNC_COMPLETE:\n\t\t\t\tpr_notice(\"%s: task 0x%p not at LU\\n\",\n\t\t\t\t\t  __func__, task);\n\t\t\t\treturn TASK_IS_NOT_AT_LU;\n\t\t\tcase TMF_RESP_FUNC_FAILED:\n\t\t\t\tpr_notice(\"%s: task 0x%p failed to abort\\n\",\n\t\t\t\t\t  __func__, task);\n\t\t\t\treturn TASK_ABORT_FAILED;\n\t\t\tdefault:\n\t\t\t\tpr_notice(\"%s: task 0x%p result code %d not handled\\n\",\n\t\t\t\t\t  __func__, task, res);\n\t\t\t}\n\t\t}\n\t}\n\treturn TASK_ABORT_FAILED;\n}\n\nstatic int sas_recover_lu(struct domain_device *dev, struct scsi_cmnd *cmd)\n{\n\tint res = TMF_RESP_FUNC_FAILED;\n\tstruct scsi_lun lun;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(dev->port->ha->shost->transportt);\n\n\tint_to_scsilun(cmd->device->lun, &lun);\n\n\tpr_notice(\"eh: device %016llx LUN 0x%llx has the task\\n\",\n\t\t  SAS_ADDR(dev->sas_addr),\n\t\t  cmd->device->lun);\n\n\tif (i->dft->lldd_abort_task_set)\n\t\tres = i->dft->lldd_abort_task_set(dev, lun.scsi_lun);\n\n\tif (res == TMF_RESP_FUNC_FAILED) {\n\t\tif (i->dft->lldd_clear_task_set)\n\t\t\tres = i->dft->lldd_clear_task_set(dev, lun.scsi_lun);\n\t}\n\n\tif (res == TMF_RESP_FUNC_FAILED) {\n\t\tif (i->dft->lldd_lu_reset)\n\t\t\tres = i->dft->lldd_lu_reset(dev, lun.scsi_lun);\n\t}\n\n\treturn res;\n}\n\nstatic int sas_recover_I_T(struct domain_device *dev)\n{\n\tint res = TMF_RESP_FUNC_FAILED;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(dev->port->ha->shost->transportt);\n\n\tpr_notice(\"I_T nexus reset for dev %016llx\\n\",\n\t\t  SAS_ADDR(dev->sas_addr));\n\n\tif (i->dft->lldd_I_T_nexus_reset)\n\t\tres = i->dft->lldd_I_T_nexus_reset(dev);\n\n\treturn res;\n}\n\n \nstruct sas_phy *sas_get_local_phy(struct domain_device *dev)\n{\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct sas_phy *phy;\n\tunsigned long flags;\n\n\t \n\tBUG_ON(!dev->phy);\n\n\tspin_lock_irqsave(&ha->phy_port_lock, flags);\n\tphy = dev->phy;\n\tget_device(&phy->dev);\n\tspin_unlock_irqrestore(&ha->phy_port_lock, flags);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(sas_get_local_phy);\n\nstatic int sas_queue_reset(struct domain_device *dev, int reset_type, u64 lun)\n{\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tint scheduled = 0, tries = 100;\n\n\t \n\tif (dev_is_sata(dev)) {\n\t\tsas_ata_schedule_reset(dev);\n\t\treturn SUCCESS;\n\t}\n\n\twhile (!scheduled && tries--) {\n\t\tspin_lock_irq(&ha->lock);\n\t\tif (!test_bit(SAS_DEV_EH_PENDING, &dev->state) &&\n\t\t    !test_bit(reset_type, &dev->state)) {\n\t\t\tscheduled = 1;\n\t\t\tha->eh_active++;\n\t\t\tlist_add_tail(&dev->ssp_dev.eh_list_node, &ha->eh_dev_q);\n\t\t\tset_bit(SAS_DEV_EH_PENDING, &dev->state);\n\t\t\tset_bit(reset_type, &dev->state);\n\t\t\tint_to_scsilun(lun, &dev->ssp_dev.reset_lun);\n\t\t\tscsi_schedule_eh(ha->shost);\n\t\t}\n\t\tspin_unlock_irq(&ha->lock);\n\n\t\tif (scheduled)\n\t\t\treturn SUCCESS;\n\t}\n\n\tpr_warn(\"%s reset of %s failed\\n\",\n\t\treset_type == SAS_DEV_LU_RESET ? \"LUN\" : \"Bus\",\n\t\tdev_name(&dev->rphy->dev));\n\n\treturn FAILED;\n}\n\nint sas_eh_abort_handler(struct scsi_cmnd *cmd)\n{\n\tint res = TMF_RESP_FUNC_FAILED;\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_internal *i = to_sas_internal(host->transportt);\n\tunsigned long flags;\n\n\tif (!i->dft->lldd_abort_task)\n\t\treturn FAILED;\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\t \n\tif (dev_is_sata(dev) && !host->host_eh_scheduled) {\n\t\tspin_unlock_irqrestore(host->host_lock, flags);\n\t\treturn FAILED;\n\t}\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\n\tif (task)\n\t\tres = i->dft->lldd_abort_task(task);\n\telse\n\t\tpr_notice(\"no task to abort\\n\");\n\tif (res == TMF_RESP_FUNC_SUCC || res == TMF_RESP_FUNC_COMPLETE)\n\t\treturn SUCCESS;\n\n\treturn FAILED;\n}\nEXPORT_SYMBOL_GPL(sas_eh_abort_handler);\n\n \nint sas_eh_device_reset_handler(struct scsi_cmnd *cmd)\n{\n\tint res;\n\tstruct scsi_lun lun;\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_internal *i = to_sas_internal(host->transportt);\n\n\tif (current != host->ehandler)\n\t\treturn sas_queue_reset(dev, SAS_DEV_LU_RESET, cmd->device->lun);\n\n\tint_to_scsilun(cmd->device->lun, &lun);\n\n\tif (!i->dft->lldd_lu_reset)\n\t\treturn FAILED;\n\n\tres = i->dft->lldd_lu_reset(dev, lun.scsi_lun);\n\tif (res == TMF_RESP_FUNC_SUCC || res == TMF_RESP_FUNC_COMPLETE)\n\t\treturn SUCCESS;\n\n\treturn FAILED;\n}\nEXPORT_SYMBOL_GPL(sas_eh_device_reset_handler);\n\nint sas_eh_target_reset_handler(struct scsi_cmnd *cmd)\n{\n\tint res;\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_internal *i = to_sas_internal(host->transportt);\n\n\tif (current != host->ehandler)\n\t\treturn sas_queue_reset(dev, SAS_DEV_RESET, 0);\n\n\tif (!i->dft->lldd_I_T_nexus_reset)\n\t\treturn FAILED;\n\n\tres = i->dft->lldd_I_T_nexus_reset(dev);\n\tif (res == TMF_RESP_FUNC_SUCC || res == TMF_RESP_FUNC_COMPLETE ||\n\t    res == -ENODEV)\n\t\treturn SUCCESS;\n\n\treturn FAILED;\n}\nEXPORT_SYMBOL_GPL(sas_eh_target_reset_handler);\n\n \nstatic int try_to_reset_cmd_device(struct scsi_cmnd *cmd)\n{\n\tint res;\n\tstruct Scsi_Host *shost = cmd->device->host;\n\n\tif (!shost->hostt->eh_device_reset_handler)\n\t\tgoto try_target_reset;\n\n\tres = shost->hostt->eh_device_reset_handler(cmd);\n\tif (res == SUCCESS)\n\t\treturn res;\n\ntry_target_reset:\n\tif (shost->hostt->eh_target_reset_handler)\n\t\treturn shost->hostt->eh_target_reset_handler(cmd);\n\n\treturn FAILED;\n}\n\nstatic void sas_eh_handle_sas_errors(struct Scsi_Host *shost, struct list_head *work_q)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tenum task_disposition res = TASK_IS_DONE;\n\tint tmf_resp, need_reset;\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\tunsigned long flags;\n\tstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\n\tLIST_HEAD(done);\n\n\t \n\tlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\n\t\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\t\tstruct sas_task *task;\n\n\t\tspin_lock_irqsave(&dev->done_lock, flags);\n\t\t \n\t\ttask = TO_SAS_TASK(cmd);\n\t\tspin_unlock_irqrestore(&dev->done_lock, flags);\n\n\t\tif (!task)\n\t\t\tlist_move_tail(&cmd->eh_entry, &done);\n\t}\n\n Again:\n\tlist_for_each_entry_safe(cmd, n, work_q, eh_entry) {\n\t\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\n\t\tlist_del_init(&cmd->eh_entry);\n\n\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\tneed_reset = task->task_state_flags & SAS_TASK_NEED_DEV_RESET;\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\t\tif (need_reset) {\n\t\t\tpr_notice(\"%s: task 0x%p requests reset\\n\",\n\t\t\t\t  __func__, task);\n\t\t\tgoto reset;\n\t\t}\n\n\t\tpr_debug(\"trying to find task 0x%p\\n\", task);\n\t\tres = sas_scsi_find_task(task);\n\n\t\tswitch (res) {\n\t\tcase TASK_IS_DONE:\n\t\t\tpr_notice(\"%s: task 0x%p is done\\n\", __func__,\n\t\t\t\t    task);\n\t\t\tsas_eh_finish_cmd(cmd);\n\t\t\tcontinue;\n\t\tcase TASK_IS_ABORTED:\n\t\t\tpr_notice(\"%s: task 0x%p is aborted\\n\",\n\t\t\t\t  __func__, task);\n\t\t\tsas_eh_finish_cmd(cmd);\n\t\t\tcontinue;\n\t\tcase TASK_IS_AT_LU:\n\t\t\tpr_info(\"task 0x%p is at LU: lu recover\\n\", task);\n reset:\n\t\t\ttmf_resp = sas_recover_lu(task->dev, cmd);\n\t\t\tif (tmf_resp == TMF_RESP_FUNC_COMPLETE) {\n\t\t\t\tpr_notice(\"dev %016llx LU 0x%llx is recovered\\n\",\n\t\t\t\t\t  SAS_ADDR(task->dev),\n\t\t\t\t\t  cmd->device->lun);\n\t\t\t\tsas_eh_finish_cmd(cmd);\n\t\t\t\tsas_scsi_clear_queue_lu(work_q, cmd);\n\t\t\t\tgoto Again;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase TASK_IS_NOT_AT_LU:\n\t\tcase TASK_ABORT_FAILED:\n\t\t\tpr_notice(\"task 0x%p is not at LU: I_T recover\\n\",\n\t\t\t\t  task);\n\t\t\ttmf_resp = sas_recover_I_T(task->dev);\n\t\t\tif (tmf_resp == TMF_RESP_FUNC_COMPLETE ||\n\t\t\t    tmf_resp == -ENODEV) {\n\t\t\t\tstruct domain_device *dev = task->dev;\n\t\t\t\tpr_notice(\"I_T %016llx recovered\\n\",\n\t\t\t\t\t  SAS_ADDR(task->dev->sas_addr));\n\t\t\t\tsas_eh_finish_cmd(cmd);\n\t\t\t\tsas_scsi_clear_queue_I_T(work_q, dev);\n\t\t\t\tgoto Again;\n\t\t\t}\n\t\t\t \n\t\t\ttry_to_reset_cmd_device(cmd);\n\t\t\tif (i->dft->lldd_clear_nexus_port) {\n\t\t\t\tstruct asd_sas_port *port = task->dev->port;\n\t\t\t\tpr_debug(\"clearing nexus for port:%d\\n\",\n\t\t\t\t\t  port->id);\n\t\t\t\tres = i->dft->lldd_clear_nexus_port(port);\n\t\t\t\tif (res == TMF_RESP_FUNC_COMPLETE) {\n\t\t\t\t\tpr_notice(\"clear nexus port:%d succeeded\\n\",\n\t\t\t\t\t\t  port->id);\n\t\t\t\t\tsas_eh_finish_cmd(cmd);\n\t\t\t\t\tsas_scsi_clear_queue_port(work_q,\n\t\t\t\t\t\t\t\t  port);\n\t\t\t\t\tgoto Again;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i->dft->lldd_clear_nexus_ha) {\n\t\t\t\tpr_debug(\"clear nexus ha\\n\");\n\t\t\t\tres = i->dft->lldd_clear_nexus_ha(ha);\n\t\t\t\tif (res == TMF_RESP_FUNC_COMPLETE) {\n\t\t\t\t\tpr_notice(\"clear nexus ha succeeded\\n\");\n\t\t\t\t\tsas_eh_finish_cmd(cmd);\n\t\t\t\t\tgoto clear_q;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tpr_err(\"error from device %016llx, LUN 0x%llx couldn't be recovered in any way\\n\",\n\t\t\t       SAS_ADDR(task->dev->sas_addr),\n\t\t\t       cmd->device->lun);\n\n\t\t\tsas_eh_finish_cmd(cmd);\n\t\t\tgoto clear_q;\n\t\t}\n\t}\n out:\n\tlist_splice_tail(&done, work_q);\n\tlist_splice_tail_init(&ha->eh_ata_q, work_q);\n\treturn;\n\n clear_q:\n\tpr_debug(\"--- Exit %s -- clear_q\\n\", __func__);\n\tlist_for_each_entry_safe(cmd, n, work_q, eh_entry)\n\t\tsas_eh_finish_cmd(cmd);\n\tgoto out;\n}\n\nstatic void sas_eh_handle_resets(struct Scsi_Host *shost)\n{\n\tstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\t \n\tspin_lock_irq(&ha->lock);\n\twhile (!list_empty(&ha->eh_dev_q)) {\n\t\tstruct domain_device *dev;\n\t\tstruct ssp_device *ssp;\n\n\t\tssp = list_entry(ha->eh_dev_q.next, typeof(*ssp), eh_list_node);\n\t\tlist_del_init(&ssp->eh_list_node);\n\t\tdev = container_of(ssp, typeof(*dev), ssp_dev);\n\t\tkref_get(&dev->kref);\n\t\tWARN_ONCE(dev_is_sata(dev), \"ssp reset to ata device?\\n\");\n\n\t\tspin_unlock_irq(&ha->lock);\n\n\t\tif (test_and_clear_bit(SAS_DEV_LU_RESET, &dev->state))\n\t\t\ti->dft->lldd_lu_reset(dev, ssp->reset_lun.scsi_lun);\n\n\t\tif (test_and_clear_bit(SAS_DEV_RESET, &dev->state))\n\t\t\ti->dft->lldd_I_T_nexus_reset(dev);\n\n\t\tsas_put_device(dev);\n\t\tspin_lock_irq(&ha->lock);\n\t\tclear_bit(SAS_DEV_EH_PENDING, &dev->state);\n\t\tha->eh_active--;\n\t}\n\tspin_unlock_irq(&ha->lock);\n}\n\n\nvoid sas_scsi_recover_host(struct Scsi_Host *shost)\n{\n\tstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\n\tLIST_HEAD(eh_work_q);\n\tint tries = 0;\n\tbool retry;\n\nretry:\n\ttries++;\n\tretry = true;\n\tspin_lock_irq(shost->host_lock);\n\tlist_splice_init(&shost->eh_cmd_q, &eh_work_q);\n\tspin_unlock_irq(shost->host_lock);\n\n\tpr_notice(\"Enter %s busy: %d failed: %d\\n\",\n\t\t  __func__, scsi_host_busy(shost), shost->host_failed);\n\t \n\tset_bit(SAS_HA_FROZEN, &ha->state);\n\tsas_eh_handle_sas_errors(shost, &eh_work_q);\n\tclear_bit(SAS_HA_FROZEN, &ha->state);\n\tif (list_empty(&eh_work_q))\n\t\tgoto out;\n\n\t \n\tsas_ata_eh(shost, &eh_work_q);\n\tif (!scsi_eh_get_sense(&eh_work_q, &ha->eh_done_q))\n\t\tscsi_eh_ready_devs(shost, &eh_work_q, &ha->eh_done_q);\n\nout:\n\tsas_eh_handle_resets(shost);\n\n\t \n\tsas_ata_strategy_handler(shost);\n\n\tscsi_eh_flush_done_q(&ha->eh_done_q);\n\n\t \n\tspin_lock_irq(&ha->lock);\n\tif (ha->eh_active == 0) {\n\t\tshost->host_eh_scheduled = 0;\n\t\tretry = false;\n\t}\n\tspin_unlock_irq(&ha->lock);\n\n\tif (retry)\n\t\tgoto retry;\n\n\tpr_notice(\"--- Exit %s: busy: %d failed: %d tries: %d\\n\",\n\t\t  __func__, scsi_host_busy(shost),\n\t\t  shost->host_failed, tries);\n}\n\nint sas_ioctl(struct scsi_device *sdev, unsigned int cmd, void __user *arg)\n{\n\tstruct domain_device *dev = sdev_to_domain_dev(sdev);\n\n\tif (dev_is_sata(dev))\n\t\treturn ata_sas_scsi_ioctl(dev->sata_dev.ap, sdev, cmd, arg);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(sas_ioctl);\n\nstruct domain_device *sas_find_dev_by_rphy(struct sas_rphy *rphy)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent);\n\tstruct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\n\tstruct domain_device *found_dev = NULL;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->phy_port_lock, flags);\n\tfor (i = 0; i < ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = ha->sas_port[i];\n\t\tstruct domain_device *dev;\n\n\t\tspin_lock(&port->dev_list_lock);\n\t\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\t\tif (rphy == dev->rphy) {\n\t\t\t\tfound_dev = dev;\n\t\t\t\tspin_unlock(&port->dev_list_lock);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&port->dev_list_lock);\n\t}\n found:\n\tspin_unlock_irqrestore(&ha->phy_port_lock, flags);\n\n\treturn found_dev;\n}\n\nint sas_target_alloc(struct scsi_target *starget)\n{\n\tstruct sas_rphy *rphy = dev_to_rphy(starget->dev.parent);\n\tstruct domain_device *found_dev = sas_find_dev_by_rphy(rphy);\n\n\tif (!found_dev)\n\t\treturn -ENODEV;\n\n\tkref_get(&found_dev->kref);\n\tstarget->hostdata = found_dev;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sas_target_alloc);\n\n#define SAS_DEF_QD 256\n\nint sas_slave_configure(struct scsi_device *scsi_dev)\n{\n\tstruct domain_device *dev = sdev_to_domain_dev(scsi_dev);\n\n\tBUG_ON(dev->rphy->identify.device_type != SAS_END_DEVICE);\n\n\tif (dev_is_sata(dev)) {\n\t\tata_sas_slave_configure(scsi_dev, dev->sata_dev.ap);\n\t\treturn 0;\n\t}\n\n\tsas_read_port_mode_page(scsi_dev);\n\n\tif (scsi_dev->tagged_supported) {\n\t\tscsi_change_queue_depth(scsi_dev, SAS_DEF_QD);\n\t} else {\n\t\tpr_notice(\"device %016llx, LUN 0x%llx doesn't support TCQ\\n\",\n\t\t\t  SAS_ADDR(dev->sas_addr), scsi_dev->lun);\n\t\tscsi_change_queue_depth(scsi_dev, 1);\n\t}\n\n\tscsi_dev->allow_restart = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sas_slave_configure);\n\nint sas_change_queue_depth(struct scsi_device *sdev, int depth)\n{\n\tstruct domain_device *dev = sdev_to_domain_dev(sdev);\n\n\tif (dev_is_sata(dev))\n\t\treturn ata_change_queue_depth(dev->sata_dev.ap, sdev, depth);\n\n\tif (!sdev->tagged_supported)\n\t\tdepth = 1;\n\treturn scsi_change_queue_depth(sdev, depth);\n}\nEXPORT_SYMBOL_GPL(sas_change_queue_depth);\n\nint sas_bios_param(struct scsi_device *scsi_dev,\n\t\t\t  struct block_device *bdev,\n\t\t\t  sector_t capacity, int *hsc)\n{\n\thsc[0] = 255;\n\thsc[1] = 63;\n\tsector_div(capacity, 255*63);\n\thsc[2] = capacity;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sas_bios_param);\n\nvoid sas_task_internal_done(struct sas_task *task)\n{\n\tdel_timer(&task->slow_task->timer);\n\tcomplete(&task->slow_task->completion);\n}\n\nvoid sas_task_internal_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tbool is_completed = true;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\t\tis_completed = false;\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tif (!is_completed)\n\t\tcomplete(&task->slow_task->completion);\n}\n\n#define TASK_TIMEOUT\t\t\t(20 * HZ)\n#define TASK_RETRY\t\t\t3\n\nstatic int sas_execute_internal_abort(struct domain_device *device,\n\t\t\t\t      enum sas_internal_abort type, u16 tag,\n\t\t\t\t      unsigned int qid, void *data)\n{\n\tstruct sas_ha_struct *ha = device->port->ha;\n\tstruct sas_internal *i = to_sas_internal(ha->shost->transportt);\n\tstruct sas_task *task = NULL;\n\tint res, retry;\n\n\tfor (retry = 0; retry < TASK_RETRY; retry++) {\n\t\ttask = sas_alloc_slow_task(GFP_KERNEL);\n\t\tif (!task)\n\t\t\treturn -ENOMEM;\n\n\t\ttask->dev = device;\n\t\ttask->task_proto = SAS_PROTOCOL_INTERNAL_ABORT;\n\t\ttask->task_done = sas_task_internal_done;\n\t\ttask->slow_task->timer.function = sas_task_internal_timedout;\n\t\ttask->slow_task->timer.expires = jiffies + TASK_TIMEOUT;\n\t\tadd_timer(&task->slow_task->timer);\n\n\t\ttask->abort_task.tag = tag;\n\t\ttask->abort_task.type = type;\n\t\ttask->abort_task.qid = qid;\n\n\t\tres = i->dft->lldd_execute_task(task, GFP_KERNEL);\n\t\tif (res) {\n\t\t\tdel_timer_sync(&task->slow_task->timer);\n\t\t\tpr_err(\"Executing internal abort failed %016llx (%d)\\n\",\n\t\t\t       SAS_ADDR(device->sas_addr), res);\n\t\t\tbreak;\n\t\t}\n\n\t\twait_for_completion(&task->slow_task->completion);\n\t\tres = TMF_RESP_FUNC_FAILED;\n\n\t\t \n\t\tif (task->task_state_flags & SAS_TASK_STATE_ABORTED) {\n\t\t\tbool quit = true;\n\n\t\t\tif (i->dft->lldd_abort_timeout)\n\t\t\t\tquit = i->dft->lldd_abort_timeout(task, data);\n\t\t\telse\n\t\t\t\tpr_err(\"Internal abort: timeout %016llx\\n\",\n\t\t\t\t       SAS_ADDR(device->sas_addr));\n\t\t\tres = -EIO;\n\t\t\tif (quit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t\ttask->task_status.stat == SAS_SAM_STAT_GOOD) {\n\t\t\tres = TMF_RESP_FUNC_COMPLETE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t\ttask->task_status.stat == TMF_RESP_FUNC_SUCC) {\n\t\t\tres = TMF_RESP_FUNC_SUCC;\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_err(\"Internal abort: task to dev %016llx response: 0x%x status 0x%x\\n\",\n\t\t       SAS_ADDR(device->sas_addr), task->task_status.resp,\n\t\t       task->task_status.stat);\n\t\tsas_free_task(task);\n\t\ttask = NULL;\n\t}\n\tBUG_ON(retry == TASK_RETRY && task != NULL);\n\tsas_free_task(task);\n\treturn res;\n}\n\nint sas_execute_internal_abort_single(struct domain_device *device, u16 tag,\n\t\t\t\t      unsigned int qid, void *data)\n{\n\treturn sas_execute_internal_abort(device, SAS_INTERNAL_ABORT_SINGLE,\n\t\t\t\t\t  tag, qid, data);\n}\nEXPORT_SYMBOL_GPL(sas_execute_internal_abort_single);\n\nint sas_execute_internal_abort_dev(struct domain_device *device,\n\t\t\t\t   unsigned int qid, void *data)\n{\n\treturn sas_execute_internal_abort(device, SAS_INTERNAL_ABORT_DEV,\n\t\t\t\t\t  SCSI_NO_TAG, qid, data);\n}\nEXPORT_SYMBOL_GPL(sas_execute_internal_abort_dev);\n\nint sas_execute_tmf(struct domain_device *device, void *parameter,\n\t\t    int para_len, int force_phy_id,\n\t\t    struct sas_tmf_task *tmf)\n{\n\tstruct sas_task *task;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(device->port->ha->shost->transportt);\n\tint res, retry;\n\n\tfor (retry = 0; retry < TASK_RETRY; retry++) {\n\t\ttask = sas_alloc_slow_task(GFP_KERNEL);\n\t\tif (!task)\n\t\t\treturn -ENOMEM;\n\n\t\ttask->dev = device;\n\t\ttask->task_proto = device->tproto;\n\n\t\tif (dev_is_sata(device)) {\n\t\t\ttask->ata_task.device_control_reg_update = 1;\n\t\t\tif (force_phy_id >= 0) {\n\t\t\t\ttask->ata_task.force_phy = true;\n\t\t\t\ttask->ata_task.force_phy_id = force_phy_id;\n\t\t\t}\n\t\t\tmemcpy(&task->ata_task.fis, parameter, para_len);\n\t\t} else {\n\t\t\tmemcpy(&task->ssp_task, parameter, para_len);\n\t\t}\n\n\t\ttask->task_done = sas_task_internal_done;\n\t\ttask->tmf = tmf;\n\n\t\ttask->slow_task->timer.function = sas_task_internal_timedout;\n\t\ttask->slow_task->timer.expires = jiffies + TASK_TIMEOUT;\n\t\tadd_timer(&task->slow_task->timer);\n\n\t\tres = i->dft->lldd_execute_task(task, GFP_KERNEL);\n\t\tif (res) {\n\t\t\tdel_timer_sync(&task->slow_task->timer);\n\t\t\tpr_err(\"executing TMF task failed %016llx (%d)\\n\",\n\t\t\t       SAS_ADDR(device->sas_addr), res);\n\t\t\tbreak;\n\t\t}\n\n\t\twait_for_completion(&task->slow_task->completion);\n\n\t\tif (i->dft->lldd_tmf_exec_complete)\n\t\t\ti->dft->lldd_tmf_exec_complete(device);\n\n\t\tres = TMF_RESP_FUNC_FAILED;\n\n\t\tif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\n\t\t\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\t\t\tpr_err(\"TMF task timeout for %016llx and not done\\n\",\n\t\t\t\t       SAS_ADDR(device->sas_addr));\n\t\t\t\tif (i->dft->lldd_tmf_aborted)\n\t\t\t\t\ti->dft->lldd_tmf_aborted(task);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpr_warn(\"TMF task timeout for %016llx and done\\n\",\n\t\t\t\tSAS_ADDR(device->sas_addr));\n\t\t}\n\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == TMF_RESP_FUNC_COMPLETE) {\n\t\t\tres = TMF_RESP_FUNC_COMPLETE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == TMF_RESP_FUNC_SUCC) {\n\t\t\tres = TMF_RESP_FUNC_SUCC;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_UNDERRUN) {\n\t\t\t \n\t\t\tpr_warn(\"TMF task to dev %016llx resp: 0x%x sts 0x%x underrun\\n\",\n\t\t\t\tSAS_ADDR(device->sas_addr),\n\t\t\t\ttask->task_status.resp,\n\t\t\t\ttask->task_status.stat);\n\t\t\tres = task->task_status.residual;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_OVERRUN) {\n\t\t\tpr_warn(\"TMF task blocked task error %016llx\\n\",\n\t\t\t\tSAS_ADDR(device->sas_addr));\n\t\t\tres = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_OPEN_REJECT) {\n\t\t\tpr_warn(\"TMF task open reject failed  %016llx\\n\",\n\t\t\t\tSAS_ADDR(device->sas_addr));\n\t\t\tres = -EIO;\n\t\t} else {\n\t\t\tpr_warn(\"TMF task to dev %016llx resp: 0x%x status 0x%x\\n\",\n\t\t\t\tSAS_ADDR(device->sas_addr),\n\t\t\t\ttask->task_status.resp,\n\t\t\t\ttask->task_status.stat);\n\t\t}\n\t\tsas_free_task(task);\n\t\ttask = NULL;\n\t}\n\n\tif (retry == TASK_RETRY)\n\t\tpr_warn(\"executing TMF for %016llx failed after %d attempts!\\n\",\n\t\t\tSAS_ADDR(device->sas_addr), TASK_RETRY);\n\tsas_free_task(task);\n\n\treturn res;\n}\n\nstatic int sas_execute_ssp_tmf(struct domain_device *device, u8 *lun,\n\t\t\t       struct sas_tmf_task *tmf)\n{\n\tstruct sas_ssp_task ssp_task;\n\n\tif (!(device->tproto & SAS_PROTOCOL_SSP))\n\t\treturn TMF_RESP_FUNC_ESUPP;\n\n\tmemcpy(ssp_task.LUN, lun, 8);\n\n\treturn sas_execute_tmf(device, &ssp_task, sizeof(ssp_task), -1, tmf);\n}\n\nint sas_abort_task_set(struct domain_device *dev, u8 *lun)\n{\n\tstruct sas_tmf_task tmf_task = {\n\t\t.tmf = TMF_ABORT_TASK_SET,\n\t};\n\n\treturn sas_execute_ssp_tmf(dev, lun, &tmf_task);\n}\nEXPORT_SYMBOL_GPL(sas_abort_task_set);\n\nint sas_clear_task_set(struct domain_device *dev, u8 *lun)\n{\n\tstruct sas_tmf_task tmf_task = {\n\t\t.tmf = TMF_CLEAR_TASK_SET,\n\t};\n\n\treturn sas_execute_ssp_tmf(dev, lun, &tmf_task);\n}\nEXPORT_SYMBOL_GPL(sas_clear_task_set);\n\nint sas_lu_reset(struct domain_device *dev, u8 *lun)\n{\n\tstruct sas_tmf_task tmf_task = {\n\t\t.tmf = TMF_LU_RESET,\n\t};\n\n\treturn sas_execute_ssp_tmf(dev, lun, &tmf_task);\n}\nEXPORT_SYMBOL_GPL(sas_lu_reset);\n\nint sas_query_task(struct sas_task *task, u16 tag)\n{\n\tstruct sas_tmf_task tmf_task = {\n\t\t.tmf = TMF_QUERY_TASK,\n\t\t.tag_of_task_to_be_managed = tag,\n\t};\n\tstruct scsi_cmnd *cmnd = task->uldd_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct scsi_lun lun;\n\n\tint_to_scsilun(cmnd->device->lun, &lun);\n\n\treturn sas_execute_ssp_tmf(dev, lun.scsi_lun, &tmf_task);\n}\nEXPORT_SYMBOL_GPL(sas_query_task);\n\nint sas_abort_task(struct sas_task *task, u16 tag)\n{\n\tstruct sas_tmf_task tmf_task = {\n\t\t.tmf = TMF_ABORT_TASK,\n\t\t.tag_of_task_to_be_managed = tag,\n\t};\n\tstruct scsi_cmnd *cmnd = task->uldd_task;\n\tstruct domain_device *dev = task->dev;\n\tstruct scsi_lun lun;\n\n\tint_to_scsilun(cmnd->device->lun, &lun);\n\n\treturn sas_execute_ssp_tmf(dev, lun.scsi_lun, &tmf_task);\n}\nEXPORT_SYMBOL_GPL(sas_abort_task);\n\n \nvoid sas_task_abort(struct sas_task *task)\n{\n\tstruct scsi_cmnd *sc = task->uldd_task;\n\n\t \n\tif (!sc) {\n\t\tstruct sas_task_slow *slow = task->slow_task;\n\n\t\tif (!slow)\n\t\t\treturn;\n\t\tif (!del_timer(&slow->timer))\n\t\t\treturn;\n\t\tslow->timer.function(&slow->timer);\n\t\treturn;\n\t}\n\n\tif (dev_is_sata(task->dev))\n\t\tsas_ata_task_abort(task);\n\telse\n\t\tblk_abort_request(scsi_cmd_to_rq(sc));\n}\nEXPORT_SYMBOL_GPL(sas_task_abort);\n\nint sas_slave_alloc(struct scsi_device *sdev)\n{\n\tif (dev_is_sata(sdev_to_domain_dev(sdev)) && sdev->lun)\n\t\treturn -ENXIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sas_slave_alloc);\n\nvoid sas_target_destroy(struct scsi_target *starget)\n{\n\tstruct domain_device *found_dev = starget->hostdata;\n\n\tif (!found_dev)\n\t\treturn;\n\n\tstarget->hostdata = NULL;\n\tsas_put_device(found_dev);\n}\nEXPORT_SYMBOL_GPL(sas_target_destroy);\n\n#define SAS_STRING_ADDR_SIZE\t16\n\nint sas_request_addr(struct Scsi_Host *shost, u8 *addr)\n{\n\tint res;\n\tconst struct firmware *fw;\n\n\tres = request_firmware(&fw, \"sas_addr\", &shost->shost_gendev);\n\tif (res)\n\t\treturn res;\n\n\tif (fw->size < SAS_STRING_ADDR_SIZE) {\n\t\tres = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tres = hex2bin(addr, fw->data, strnlen(fw->data, SAS_ADDR_SIZE * 2) / 2);\n\tif (res)\n\t\tgoto out;\n\nout:\n\trelease_firmware(fw);\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(sas_request_addr);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}