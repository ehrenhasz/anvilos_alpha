{
  "module_name": "sas_host_smp.c",
  "hash_id": "2cd2465e327e95cfc18edb43f77ade9cfcd9f4f8faabcd14ecac6dc0373fb314",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_host_smp.c",
  "human_readable_source": "\n \n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include \"sas_internal.h\"\n\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"scsi_sas_internal.h\"\n\nstatic void sas_host_smp_discover(struct sas_ha_struct *sas_ha, u8 *resp_data,\n\t\t\t\t  u8 phy_id)\n{\n\tstruct sas_phy *phy;\n\tstruct sas_rphy *rphy;\n\n\tif (phy_id >= sas_ha->num_phys) {\n\t\tresp_data[2] = SMP_RESP_NO_PHY;\n\t\treturn;\n\t}\n\tresp_data[2] = SMP_RESP_FUNC_ACC;\n\n\tphy = sas_ha->sas_phy[phy_id]->phy;\n\tresp_data[9] = phy_id;\n\tresp_data[13] = phy->negotiated_linkrate;\n\tmemcpy(resp_data + 16, sas_ha->sas_addr, SAS_ADDR_SIZE);\n\tmemcpy(resp_data + 24, sas_ha->sas_phy[phy_id]->attached_sas_addr,\n\t       SAS_ADDR_SIZE);\n\tresp_data[40] = (phy->minimum_linkrate << 4) |\n\t\tphy->minimum_linkrate_hw;\n\tresp_data[41] = (phy->maximum_linkrate << 4) |\n\t\tphy->maximum_linkrate_hw;\n\n\tif (!sas_ha->sas_phy[phy_id]->port ||\n\t    !sas_ha->sas_phy[phy_id]->port->port_dev)\n\t\treturn;\n\n\trphy = sas_ha->sas_phy[phy_id]->port->port_dev->rphy;\n\tresp_data[12] = rphy->identify.device_type << 4;\n\tresp_data[14] = rphy->identify.initiator_port_protocols;\n\tresp_data[15] = rphy->identify.target_port_protocols;\n}\n\n \nstatic u8 *to_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count, u8 *bit)\n{\n\tunsigned int reg;\n\tu8 byte;\n\n\t \n\tif (index == 0)\n\t\treturn NULL;\n\n\tindex--;  \n\tif (od < index * 32)\n\t\treturn NULL;\n\n\tod -= index * 32;\n\treg = od >> 5;\n\n\tif (reg >= count)\n\t\treturn NULL;\n\n\tod &= (1 << 5) - 1;\n\tbyte = 3 - (od >> 3);\n\t*bit = od & ((1 << 3) - 1);\n\n\treturn &data[reg * 4 + byte];\n}\n\nint try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count)\n{\n\tu8 *byte;\n\tu8 bit;\n\n\tbyte = to_sas_gpio_gp_bit(od, data, index, count, &bit);\n\tif (!byte)\n\t\treturn -1;\n\n\treturn (*byte >> bit) & 1;\n}\nEXPORT_SYMBOL(try_test_sas_gpio_gp_bit);\n\nstatic int sas_host_smp_write_gpio(struct sas_ha_struct *sas_ha, u8 *resp_data,\n\t\t\t\t   u8 reg_type, u8 reg_index, u8 reg_count,\n\t\t\t\t   u8 *req_data)\n{\n\tstruct sas_internal *i = to_sas_internal(sas_ha->shost->transportt);\n\tint written;\n\n\tif (i->dft->lldd_write_gpio == NULL) {\n\t\tresp_data[2] = SMP_RESP_FUNC_UNK;\n\t\treturn 0;\n\t}\n\n\twritten = i->dft->lldd_write_gpio(sas_ha, reg_type, reg_index,\n\t\t\t\t\t  reg_count, req_data);\n\n\tif (written < 0) {\n\t\tresp_data[2] = SMP_RESP_FUNC_FAILED;\n\t\twritten = 0;\n\t} else\n\t\tresp_data[2] = SMP_RESP_FUNC_ACC;\n\n\treturn written;\n}\n\nstatic void sas_report_phy_sata(struct sas_ha_struct *sas_ha, u8 *resp_data,\n\t\t\t\tu8 phy_id)\n{\n\tstruct sas_rphy *rphy;\n\tstruct dev_to_host_fis *fis;\n\tint i;\n\n\tif (phy_id >= sas_ha->num_phys) {\n\t\tresp_data[2] = SMP_RESP_NO_PHY;\n\t\treturn;\n\t}\n\n\tresp_data[2] = SMP_RESP_PHY_NO_SATA;\n\n\tif (!sas_ha->sas_phy[phy_id]->port)\n\t\treturn;\n\n\trphy = sas_ha->sas_phy[phy_id]->port->port_dev->rphy;\n\tfis = (struct dev_to_host_fis *)\n\t\tsas_ha->sas_phy[phy_id]->port->port_dev->frame_rcvd;\n\tif (rphy->identify.target_port_protocols != SAS_PROTOCOL_SATA)\n\t\treturn;\n\n\tresp_data[2] = SMP_RESP_FUNC_ACC;\n\tresp_data[9] = phy_id;\n\tmemcpy(resp_data + 16, sas_ha->sas_phy[phy_id]->attached_sas_addr,\n\t       SAS_ADDR_SIZE);\n\n\t \n\tif (fis->fis_type != 0x34)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < 20; i += 4) {\n\t\tu8 *dst = resp_data + 24 + i, *src =\n\t\t\t&sas_ha->sas_phy[phy_id]->port->port_dev->frame_rcvd[i];\n\t\tdst[0] = src[3];\n\t\tdst[1] = src[2];\n\t\tdst[2] = src[1];\n\t\tdst[3] = src[0];\n\t}\n}\n\nstatic void sas_phy_control(struct sas_ha_struct *sas_ha, u8 phy_id,\n\t\t\t    u8 phy_op, enum sas_linkrate min,\n\t\t\t    enum sas_linkrate max, u8 *resp_data)\n{\n\tstruct sas_internal *i =\n\t\tto_sas_internal(sas_ha->shost->transportt);\n\tstruct sas_phy_linkrates rates;\n\tstruct asd_sas_phy *asd_phy;\n\n\tif (phy_id >= sas_ha->num_phys) {\n\t\tresp_data[2] = SMP_RESP_NO_PHY;\n\t\treturn;\n\t}\n\n\tasd_phy = sas_ha->sas_phy[phy_id];\n\tswitch (phy_op) {\n\tcase PHY_FUNC_NOP:\n\tcase PHY_FUNC_LINK_RESET:\n\tcase PHY_FUNC_HARD_RESET:\n\tcase PHY_FUNC_DISABLE:\n\tcase PHY_FUNC_CLEAR_ERROR_LOG:\n\tcase PHY_FUNC_CLEAR_AFFIL:\n\tcase PHY_FUNC_TX_SATA_PS_SIGNAL:\n\t\tbreak;\n\n\tdefault:\n\t\tresp_data[2] = SMP_RESP_PHY_UNK_OP;\n\t\treturn;\n\t}\n\n\trates.minimum_linkrate = min;\n\trates.maximum_linkrate = max;\n\n\t \n\tif (phy_op == PHY_FUNC_LINK_RESET && sas_try_ata_reset(asd_phy) == 0) {\n\t\tresp_data[2] = SMP_RESP_FUNC_ACC;\n\t\treturn;\n\t}\n\n\tif (i->dft->lldd_control_phy(asd_phy, phy_op, &rates))\n\t\tresp_data[2] = SMP_RESP_FUNC_FAILED;\n\telse\n\t\tresp_data[2] = SMP_RESP_FUNC_ACC;\n}\n\nvoid sas_smp_host_handler(struct bsg_job *job, struct Scsi_Host *shost)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\n\tu8 *req_data, *resp_data;\n\tunsigned int reslen = 0;\n\tint error = -EINVAL;\n\n\t \n\tif (job->request_payload.payload_len < 8 ||\n\t    job->reply_payload.payload_len < 8)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\treq_data = kzalloc(job->request_payload.payload_len, GFP_KERNEL);\n\tif (!req_data)\n\t\tgoto out;\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt, req_data,\n\t\t\t  job->request_payload.payload_len);\n\n\t \n\tresp_data = kzalloc(max(job->reply_payload.payload_len, 128U),\n\t\t\tGFP_KERNEL);\n\tif (!resp_data)\n\t\tgoto out_free_req;\n\n\terror = -EINVAL;\n\tif (req_data[0] != SMP_REQUEST)\n\t\tgoto out_free_resp;\n\n\t \n\tresp_data[0] = SMP_RESPONSE;\n\tresp_data[1] = req_data[1];\n\tresp_data[2] = SMP_RESP_FUNC_UNK;\n\n\tswitch (req_data[1]) {\n\tcase SMP_REPORT_GENERAL:\n\t\tresp_data[2] = SMP_RESP_FUNC_ACC;\n\t\tresp_data[9] = sas_ha->num_phys;\n\t\treslen = 32;\n\t\tbreak;\n\n\tcase SMP_REPORT_MANUF_INFO:\n\t\tresp_data[2] = SMP_RESP_FUNC_ACC;\n\t\tmemcpy(resp_data + 12, shost->hostt->name,\n\t\t       SAS_EXPANDER_VENDOR_ID_LEN);\n\t\tmemcpy(resp_data + 20, \"libsas virt phy\",\n\t\t       SAS_EXPANDER_PRODUCT_ID_LEN);\n\t\treslen = 64;\n\t\tbreak;\n\n\tcase SMP_READ_GPIO_REG:\n\t\t \n\t\tbreak;\n\n\tcase SMP_DISCOVER:\n\t\tif (job->request_payload.payload_len < 16)\n\t\t\tgoto out_free_resp;\n\t\tsas_host_smp_discover(sas_ha, resp_data, req_data[9]);\n\t\treslen = 56;\n\t\tbreak;\n\n\tcase SMP_REPORT_PHY_ERR_LOG:\n\t\t \n\t\tbreak;\n\n\tcase SMP_REPORT_PHY_SATA:\n\t\tif (job->request_payload.payload_len < 16)\n\t\t\tgoto out_free_resp;\n\t\tsas_report_phy_sata(sas_ha, resp_data, req_data[9]);\n\t\treslen = 60;\n\t\tbreak;\n\n\tcase SMP_REPORT_ROUTE_INFO:\n\t\t \n\t\tbreak;\n\n\tcase SMP_WRITE_GPIO_REG: {\n\t\t \n\t\tconst int base_frame_size = 11;\n\t\tint to_write = req_data[4];\n\n\t\tif (job->request_payload.payload_len <\n\t\t\t\tbase_frame_size + to_write * 4) {\n\t\t\tresp_data[2] = SMP_RESP_INV_FRM_LEN;\n\t\t\tbreak;\n\t\t}\n\n\t\tto_write = sas_host_smp_write_gpio(sas_ha, resp_data, req_data[2],\n\t\t\t\t\t\t   req_data[3], to_write, &req_data[8]);\n\t\treslen = 8;\n\t\tbreak;\n\t}\n\n\tcase SMP_CONF_ROUTE_INFO:\n\t\t \n\t\tbreak;\n\n\tcase SMP_PHY_CONTROL:\n\t\tif (job->request_payload.payload_len < 44)\n\t\t\tgoto out_free_resp;\n\t\tsas_phy_control(sas_ha, req_data[9], req_data[10],\n\t\t\t\treq_data[32] >> 4, req_data[33] >> 4,\n\t\t\t\tresp_data);\n\t\treslen = 8;\n\t\tbreak;\n\n\tcase SMP_PHY_TEST_FUNCTION:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t    job->reply_payload.sg_cnt, resp_data,\n\t\t\t    job->reply_payload.payload_len);\n\n\terror = 0;\nout_free_resp:\n\tkfree(resp_data);\nout_free_req:\n\tkfree(req_data);\nout:\n\tbsg_job_done(job, error, reslen);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}