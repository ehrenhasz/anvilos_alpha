{
  "module_name": "sas_expander.c",
  "hash_id": "c9afb40bc16ad1fa1518b616308c05cb9a50f18b217bde8ffd00eb76457ca835",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_expander.c",
  "human_readable_source": "\n \n\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include \"sas_internal.h\"\n\n#include <scsi/sas_ata.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"scsi_sas_internal.h\"\n\nstatic int sas_discover_expander(struct domain_device *dev);\nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr);\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int include);\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr);\n\n \n\n \n#define SMP_TIMEOUT 10\n\nstatic int smp_execute_task_sg(struct domain_device *dev,\n\t\tstruct scatterlist *req, struct scatterlist *resp)\n{\n\tint res, retry;\n\tstruct sas_task *task = NULL;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(dev->port->ha->shost->transportt);\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\n\tpm_runtime_get_sync(ha->dev);\n\tmutex_lock(&dev->ex_dev.cmd_mutex);\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tif (test_bit(SAS_DEV_GONE, &dev->state)) {\n\t\t\tres = -ECOMM;\n\t\t\tbreak;\n\t\t}\n\n\t\ttask = sas_alloc_slow_task(GFP_KERNEL);\n\t\tif (!task) {\n\t\t\tres = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\ttask->dev = dev;\n\t\ttask->task_proto = dev->tproto;\n\t\ttask->smp_task.smp_req = *req;\n\t\ttask->smp_task.smp_resp = *resp;\n\n\t\ttask->task_done = sas_task_internal_done;\n\n\t\ttask->slow_task->timer.function = sas_task_internal_timedout;\n\t\ttask->slow_task->timer.expires = jiffies + SMP_TIMEOUT*HZ;\n\t\tadd_timer(&task->slow_task->timer);\n\n\t\tres = i->dft->lldd_execute_task(task, GFP_KERNEL);\n\n\t\tif (res) {\n\t\t\tdel_timer_sync(&task->slow_task->timer);\n\t\t\tpr_notice(\"executing SMP task failed:%d\\n\", res);\n\t\t\tbreak;\n\t\t}\n\n\t\twait_for_completion(&task->slow_task->completion);\n\t\tres = -ECOMM;\n\t\tif ((task->task_state_flags & SAS_TASK_STATE_ABORTED)) {\n\t\t\tpr_notice(\"smp task timed out or aborted\\n\");\n\t\t\ti->dft->lldd_abort_task(task);\n\t\t\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\t\t\tpr_notice(\"SMP task aborted and not done\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_SAM_STAT_GOOD) {\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_UNDERRUN) {\n\t\t\t \n\t\t\tres = task->task_status.residual;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_COMPLETE &&\n\t\t    task->task_status.stat == SAS_DATA_OVERRUN) {\n\t\t\tres = -EMSGSIZE;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->task_status.resp == SAS_TASK_UNDELIVERED &&\n\t\t    task->task_status.stat == SAS_DEVICE_UNKNOWN)\n\t\t\tbreak;\n\t\telse {\n\t\t\tpr_notice(\"%s: task to dev %016llx response: 0x%x status 0x%x\\n\",\n\t\t\t\t  __func__,\n\t\t\t\t  SAS_ADDR(dev->sas_addr),\n\t\t\t\t  task->task_status.resp,\n\t\t\t\t  task->task_status.stat);\n\t\t\tsas_free_task(task);\n\t\t\ttask = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&dev->ex_dev.cmd_mutex);\n\tpm_runtime_put_sync(ha->dev);\n\n\tBUG_ON(retry == 3 && task != NULL);\n\tsas_free_task(task);\n\treturn res;\n}\n\nstatic int smp_execute_task(struct domain_device *dev, void *req, int req_size,\n\t\t\t    void *resp, int resp_size)\n{\n\tstruct scatterlist req_sg;\n\tstruct scatterlist resp_sg;\n\n\tsg_init_one(&req_sg, req, req_size);\n\tsg_init_one(&resp_sg, resp, resp_size);\n\treturn smp_execute_task_sg(dev, &req_sg, &resp_sg);\n}\n\n \n\nstatic inline void *alloc_smp_req(int size)\n{\n\tu8 *p = kzalloc(size, GFP_KERNEL);\n\tif (p)\n\t\tp[0] = SMP_REQUEST;\n\treturn p;\n}\n\nstatic inline void *alloc_smp_resp(int size)\n{\n\treturn kzalloc(size, GFP_KERNEL);\n}\n\nstatic char sas_route_char(struct domain_device *dev, struct ex_phy *phy)\n{\n\tswitch (phy->routing_attr) {\n\tcase TABLE_ROUTING:\n\t\tif (dev->ex_dev.t2t_supp)\n\t\t\treturn 'U';\n\t\telse\n\t\t\treturn 'T';\n\tcase DIRECT_ROUTING:\n\t\treturn 'D';\n\tcase SUBTRACTIVE_ROUTING:\n\t\treturn 'S';\n\tdefault:\n\t\treturn '?';\n\t}\n}\n\nstatic enum sas_device_type to_dev_type(struct discover_resp *dr)\n{\n\t \n\tif (dr->attached_dev_type == SAS_PHY_UNUSED && dr->attached_sata_dev &&\n\t    dr->linkrate >= SAS_LINK_RATE_1_5_GBPS)\n\t\treturn SAS_SATA_PENDING;\n\telse\n\t\treturn dr->attached_dev_type;\n}\n\nstatic void sas_set_ex_phy(struct domain_device *dev, int phy_id,\n\t\t\t   struct smp_disc_resp *disc_resp)\n{\n\tenum sas_device_type dev_type;\n\tenum sas_linkrate linkrate;\n\tu8 sas_addr[SAS_ADDR_SIZE];\n\tstruct discover_resp *dr = &disc_resp->disc;\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tstruct sas_rphy *rphy = dev->rphy;\n\tbool new_phy = !phy->phy;\n\tchar *type;\n\n\tif (new_phy) {\n\t\tif (WARN_ON_ONCE(test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)))\n\t\t\treturn;\n\t\tphy->phy = sas_phy_alloc(&rphy->dev, phy_id);\n\n\t\t \n\t\tBUG_ON(!phy->phy);\n\t}\n\n\tswitch (disc_resp->result) {\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tbreak;\n\tdefault:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tbreak;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tphy->phy_state = PHY_EMPTY;  \n\t\tbreak;\n\t}\n\n\t \n\tdev_type = phy->attached_dev_type;\n\tlinkrate  = phy->linkrate;\n\tmemcpy(sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\n\t \n\tif (phy->phy_state == PHY_VACANT) {\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tphy->attached_dev_type = SAS_PHY_UNUSED;\n\t\tif (!test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\t\tphy->phy_id = phy_id;\n\t\t\tgoto skip;\n\t\t} else\n\t\t\tgoto out;\n\t}\n\n\tphy->attached_dev_type = to_dev_type(dr);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tgoto out;\n\tphy->phy_id = phy_id;\n\tphy->linkrate = dr->linkrate;\n\tphy->attached_sata_host = dr->attached_sata_host;\n\tphy->attached_sata_dev  = dr->attached_sata_dev;\n\tphy->attached_sata_ps   = dr->attached_sata_ps;\n\tphy->attached_iproto = dr->iproto << 1;\n\tphy->attached_tproto = dr->tproto << 1;\n\t \n\tif (phy->attached_dev_type == SAS_PHY_UNUSED ||\n\t    phy->linkrate < SAS_LINK_RATE_1_5_GBPS)\n\t\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\telse\n\t\tmemcpy(phy->attached_sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE);\n\tphy->attached_phy_id = dr->attached_phy_id;\n\tphy->phy_change_count = dr->change_count;\n\tphy->routing_attr = dr->routing_attr;\n\tphy->virtual = dr->virtual;\n\tphy->last_da_index = -1;\n\n\tphy->phy->identify.sas_address = SAS_ADDR(phy->attached_sas_addr);\n\tphy->phy->identify.device_type = dr->attached_dev_type;\n\tphy->phy->identify.initiator_port_protocols = phy->attached_iproto;\n\tphy->phy->identify.target_port_protocols = phy->attached_tproto;\n\tif (!phy->attached_tproto && dr->attached_sata_dev)\n\t\tphy->phy->identify.target_port_protocols = SAS_PROTOCOL_SATA;\n\tphy->phy->identify.phy_identifier = phy_id;\n\tphy->phy->minimum_linkrate_hw = dr->hmin_linkrate;\n\tphy->phy->maximum_linkrate_hw = dr->hmax_linkrate;\n\tphy->phy->minimum_linkrate = dr->pmin_linkrate;\n\tphy->phy->maximum_linkrate = dr->pmax_linkrate;\n\tphy->phy->negotiated_linkrate = phy->linkrate;\n\tphy->phy->enabled = (phy->linkrate != SAS_PHY_DISABLED);\n\n skip:\n\tif (new_phy)\n\t\tif (sas_phy_add(phy->phy)) {\n\t\t\tsas_phy_free(phy->phy);\n\t\t\treturn;\n\t\t}\n\n out:\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_SATA_PENDING:\n\t\ttype = \"stp pending\";\n\t\tbreak;\n\tcase SAS_PHY_UNUSED:\n\t\ttype = \"no device\";\n\t\tbreak;\n\tcase SAS_END_DEVICE:\n\t\tif (phy->attached_iproto) {\n\t\t\tif (phy->attached_tproto)\n\t\t\t\ttype = \"host+target\";\n\t\t\telse\n\t\t\t\ttype = \"host\";\n\t\t} else {\n\t\t\tif (dr->attached_sata_dev)\n\t\t\t\ttype = \"stp\";\n\t\t\telse\n\t\t\t\ttype = \"ssp\";\n\t\t}\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\ttype = \"smp\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\t \n\tif (new_phy || phy->attached_dev_type != dev_type ||\n\t    phy->linkrate != linkrate ||\n\t    SAS_ADDR(phy->attached_sas_addr) != SAS_ADDR(sas_addr))\n\t\t ;\n\telse\n\t\treturn;\n\n\t \n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state))\n\t\tset_bit(DISCE_REVALIDATE_DOMAIN, &dev->port->disc.pending);\n\n\tpr_debug(\"%sex %016llx phy%02d:%c:%X attached: %016llx (%s)\\n\",\n\t\t test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state) ? \"ata: \" : \"\",\n\t\t SAS_ADDR(dev->sas_addr), phy->phy_id,\n\t\t sas_route_char(dev, phy), phy->linkrate,\n\t\t SAS_ADDR(phy->attached_sas_addr), type);\n}\n\n \nstruct domain_device *sas_ex_to_ata(struct domain_device *ex_dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &ex_dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *dev;\n\tstruct sas_rphy *rphy;\n\n\tif (!ex_phy->port)\n\t\treturn NULL;\n\n\trphy = ex_phy->port->rphy;\n\tif (!rphy)\n\t\treturn NULL;\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\n\tif (dev && dev_is_sata(dev))\n\t\treturn dev;\n\n\treturn NULL;\n}\n\n#define DISCOVER_REQ_SIZE  16\n#define DISCOVER_RESP_SIZE sizeof(struct smp_disc_resp)\n\nstatic int sas_ex_phy_discover_helper(struct domain_device *dev, u8 *disc_req,\n\t\t\t\t      struct smp_disc_resp *disc_resp,\n\t\t\t\t      int single)\n{\n\tstruct discover_resp *dr = &disc_resp->disc;\n\tint res;\n\n\tdisc_req[9] = single;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\treturn res;\n\tif (memcmp(dev->sas_addr, dr->attached_sas_addr, SAS_ADDR_SIZE) == 0) {\n\t\tpr_notice(\"Found loopback topology, just ignore it!\\n\");\n\t\treturn 0;\n\t}\n\tsas_set_ex_phy(dev, single, disc_resp);\n\treturn 0;\n}\n\nint sas_ex_phy_discover(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint  res = 0;\n\tu8   *disc_req;\n\tstruct smp_disc_resp *disc_resp;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp) {\n\t\tkfree(disc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tdisc_req[1] = SMP_DISCOVER;\n\n\tif (0 <= single && single < ex->num_phys) {\n\t\tres = sas_ex_phy_discover_helper(dev, disc_req, disc_resp, single);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tres = sas_ex_phy_discover_helper(dev, disc_req,\n\t\t\t\t\t\t\t disc_resp, i);\n\t\t\tif (res)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\nout_err:\n\tkfree(disc_resp);\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_expander_discover(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res;\n\n\tex->ex_phy = kcalloc(ex->num_phys, sizeof(*ex->ex_phy), GFP_KERNEL);\n\tif (!ex->ex_phy)\n\t\treturn -ENOMEM;\n\n\tres = sas_ex_phy_discover(dev, -1);\n\tif (res)\n\t\tgoto out_err;\n\n\treturn 0;\n out_err:\n\tkfree(ex->ex_phy);\n\tex->ex_phy = NULL;\n\treturn res;\n}\n\n#define MAX_EXPANDER_PHYS 128\n\n#define RG_REQ_SIZE   8\n#define RG_RESP_SIZE  sizeof(struct smp_rg_resp)\n\nstatic int sas_ex_general(struct domain_device *dev)\n{\n\tu8 *rg_req;\n\tstruct smp_rg_resp *rg_resp;\n\tstruct report_general_resp *rg;\n\tint res;\n\tint i;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t\t       RG_RESP_SIZE);\n\n\t\tif (res) {\n\t\t\tpr_notice(\"RG to ex %016llx failed:0x%x\\n\",\n\t\t\t\t  SAS_ADDR(dev->sas_addr), res);\n\t\t\tgoto out;\n\t\t} else if (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\t\tpr_debug(\"RG:ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t\t SAS_ADDR(dev->sas_addr), rg_resp->result);\n\t\t\tres = rg_resp->result;\n\t\t\tgoto out;\n\t\t}\n\n\t\trg = &rg_resp->rg;\n\t\tdev->ex_dev.ex_change_count = be16_to_cpu(rg->change_count);\n\t\tdev->ex_dev.max_route_indexes = be16_to_cpu(rg->route_indexes);\n\t\tdev->ex_dev.num_phys = min(rg->num_phys, (u8)MAX_EXPANDER_PHYS);\n\t\tdev->ex_dev.t2t_supp = rg->t2t_supp;\n\t\tdev->ex_dev.conf_route_table = rg->conf_route_table;\n\t\tdev->ex_dev.configuring = rg->configuring;\n\t\tmemcpy(dev->ex_dev.enclosure_logical_id,\n\t\t       rg->enclosure_logical_id, 8);\n\n\t\tif (dev->ex_dev.configuring) {\n\t\t\tpr_debug(\"RG: ex %016llx self-configuring...\\n\",\n\t\t\t\t SAS_ADDR(dev->sas_addr));\n\t\t\tschedule_timeout_interruptible(5*HZ);\n\t\t} else\n\t\t\tbreak;\n\t}\nout:\n\tkfree(rg_req);\n\tkfree(rg_resp);\n\treturn res;\n}\n\nstatic void ex_assign_manuf_info(struct domain_device *dev, void\n\t\t\t\t\t*_mi_resp)\n{\n\tu8 *mi_resp = _mi_resp;\n\tstruct sas_rphy *rphy = dev->rphy;\n\tstruct sas_expander_device *edev = rphy_to_expander_device(rphy);\n\n\tmemcpy(edev->vendor_id, mi_resp + 12, SAS_EXPANDER_VENDOR_ID_LEN);\n\tmemcpy(edev->product_id, mi_resp + 20, SAS_EXPANDER_PRODUCT_ID_LEN);\n\tmemcpy(edev->product_rev, mi_resp + 36,\n\t       SAS_EXPANDER_PRODUCT_REV_LEN);\n\n\tif (mi_resp[8] & 1) {\n\t\tmemcpy(edev->component_vendor_id, mi_resp + 40,\n\t\t       SAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\n\t\tedev->component_id = mi_resp[48] << 8 | mi_resp[49];\n\t\tedev->component_revision_id = mi_resp[50];\n\t}\n}\n\n#define MI_REQ_SIZE   8\n#define MI_RESP_SIZE 64\n\nstatic int sas_ex_manuf_info(struct domain_device *dev)\n{\n\tu8 *mi_req;\n\tu8 *mi_resp;\n\tint res;\n\n\tmi_req = alloc_smp_req(MI_REQ_SIZE);\n\tif (!mi_req)\n\t\treturn -ENOMEM;\n\n\tmi_resp = alloc_smp_resp(MI_RESP_SIZE);\n\tif (!mi_resp) {\n\t\tkfree(mi_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tmi_req[1] = SMP_REPORT_MANUF_INFO;\n\n\tres = smp_execute_task(dev, mi_req, MI_REQ_SIZE, mi_resp, MI_RESP_SIZE);\n\tif (res) {\n\t\tpr_notice(\"MI: ex %016llx failed:0x%x\\n\",\n\t\t\t  SAS_ADDR(dev->sas_addr), res);\n\t\tgoto out;\n\t} else if (mi_resp[2] != SMP_RESP_FUNC_ACC) {\n\t\tpr_debug(\"MI ex %016llx returned SMP result:0x%x\\n\",\n\t\t\t SAS_ADDR(dev->sas_addr), mi_resp[2]);\n\t\tgoto out;\n\t}\n\n\tex_assign_manuf_info(dev, mi_resp);\nout:\n\tkfree(mi_req);\n\tkfree(mi_resp);\n\treturn res;\n}\n\n#define PC_REQ_SIZE  44\n#define PC_RESP_SIZE 8\n\nint sas_smp_phy_control(struct domain_device *dev, int phy_id,\n\t\t\tenum phy_func phy_func,\n\t\t\tstruct sas_phy_linkrates *rates)\n{\n\tu8 *pc_req;\n\tu8 *pc_resp;\n\tint res;\n\n\tpc_req = alloc_smp_req(PC_REQ_SIZE);\n\tif (!pc_req)\n\t\treturn -ENOMEM;\n\n\tpc_resp = alloc_smp_resp(PC_RESP_SIZE);\n\tif (!pc_resp) {\n\t\tkfree(pc_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tpc_req[1] = SMP_PHY_CONTROL;\n\tpc_req[9] = phy_id;\n\tpc_req[10] = phy_func;\n\tif (rates) {\n\t\tpc_req[32] = rates->minimum_linkrate << 4;\n\t\tpc_req[33] = rates->maximum_linkrate << 4;\n\t}\n\n\tres = smp_execute_task(dev, pc_req, PC_REQ_SIZE, pc_resp, PC_RESP_SIZE);\n\tif (res) {\n\t\tpr_err(\"ex %016llx phy%02d PHY control failed: %d\\n\",\n\t\t       SAS_ADDR(dev->sas_addr), phy_id, res);\n\t} else if (pc_resp[2] != SMP_RESP_FUNC_ACC) {\n\t\tpr_err(\"ex %016llx phy%02d PHY control failed: function result 0x%x\\n\",\n\t\t       SAS_ADDR(dev->sas_addr), phy_id, pc_resp[2]);\n\t\tres = pc_resp[2];\n\t}\n\tkfree(pc_resp);\n\tkfree(pc_req);\n\treturn res;\n}\n\nstatic void sas_ex_disable_phy(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\n\tsas_smp_phy_control(dev, phy_id, PHY_FUNC_DISABLE, NULL);\n\tphy->linkrate = SAS_PHY_DISABLED;\n}\n\nstatic void sas_ex_disable_port(struct domain_device *dev, u8 *sas_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (SAS_ADDR(phy->attached_sas_addr) == SAS_ADDR(sas_addr))\n\t\t\tsas_ex_disable_phy(dev, i);\n\t}\n}\n\nstatic int sas_dev_present_in_domain(struct asd_sas_port *port,\n\t\t\t\t\t    u8 *sas_addr)\n{\n\tstruct domain_device *dev;\n\n\tif (SAS_ADDR(port->sas_addr) == SAS_ADDR(sas_addr))\n\t\treturn 1;\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (SAS_ADDR(dev->sas_addr) == SAS_ADDR(sas_addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#define RPEL_REQ_SIZE\t16\n#define RPEL_RESP_SIZE\t32\nint sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t       resp, RPEL_RESP_SIZE);\n\n\tif (res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = get_unaligned_be32(&resp[12]);\n\tphy->running_disparity_error_count = get_unaligned_be32(&resp[16]);\n\tphy->loss_of_dword_sync_count = get_unaligned_be32(&resp[20]);\n\tphy->phy_reset_problem_count = get_unaligned_be32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}\n\n#ifdef CONFIG_SCSI_SAS_ATA\n\n#define RPS_REQ_SIZE  16\n#define RPS_RESP_SIZE sizeof(struct smp_rps_resp)\n\nint sas_get_report_phy_sata(struct domain_device *dev, int phy_id,\n\t\t\t    struct smp_rps_resp *rps_resp)\n{\n\tint res;\n\tu8 *rps_req = alloc_smp_req(RPS_REQ_SIZE);\n\tu8 *resp = (u8 *)rps_resp;\n\n\tif (!rps_req)\n\t\treturn -ENOMEM;\n\n\trps_req[1] = SMP_REPORT_PHY_SATA;\n\trps_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, rps_req, RPS_REQ_SIZE,\n\t\t\t       rps_resp, RPS_RESP_SIZE);\n\n\t \n\tif (!res && resp[27] == 0x34 && resp[24] != 0x34) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tint j = 24 + (i*4);\n\t\t\tu8 a, b;\n\t\t\ta = resp[j + 0];\n\t\t\tb = resp[j + 1];\n\t\t\tresp[j + 0] = resp[j + 3];\n\t\t\tresp[j + 1] = resp[j + 2];\n\t\t\tresp[j + 2] = b;\n\t\t\tresp[j + 3] = a;\n\t\t}\n\t}\n\n\tkfree(rps_req);\n\treturn res;\n}\n#endif\n\nstatic void sas_ex_get_linkrate(struct domain_device *parent,\n\t\t\t\t       struct domain_device *child,\n\t\t\t\t       struct ex_phy *parent_phy)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct sas_port *port;\n\tint i;\n\n\tchild->pathways = 0;\n\n\tport = parent_phy->port;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &parent_ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (sas_phy_match_dev_addr(child, phy)) {\n\t\t\tchild->min_linkrate = min(parent->min_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->max_linkrate = max(parent->max_linkrate,\n\t\t\t\t\t\t  phy->linkrate);\n\t\t\tchild->pathways++;\n\t\t\tsas_port_add_phy(port, phy->phy);\n\t\t}\n\t}\n\tchild->linkrate = min(parent_phy->linkrate, child->max_linkrate);\n\tchild->pathways = min(child->pathways, parent->pathways);\n}\n\nstatic int sas_ex_add_dev(struct domain_device *parent, struct ex_phy *phy,\n\t\t\t  struct domain_device *child, int phy_id)\n{\n\tstruct sas_rphy *rphy;\n\tint res;\n\n\tchild->dev_type = SAS_END_DEVICE;\n\trphy = sas_end_device_alloc(phy->port);\n\tif (!rphy)\n\t\treturn -ENOMEM;\n\n\tchild->tproto = phy->attached_tproto;\n\tsas_init_dev(child);\n\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\trphy->identify.phy_identifier = phy_id;\n\tsas_fill_in_rphy(child, rphy);\n\n\tlist_add_tail(&child->disco_list_node, &parent->port->disco_list);\n\n\tres = sas_notify_lldd_dev_found(child);\n\tif (res) {\n\t\tpr_notice(\"notify lldd for device %016llx at %016llx:%02d returned 0x%x\\n\",\n\t\t\t  SAS_ADDR(child->sas_addr),\n\t\t\t  SAS_ADDR(parent->sas_addr), phy_id, res);\n\t\tsas_rphy_free(child->rphy);\n\t\tlist_del(&child->disco_list_node);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic struct domain_device *sas_ex_discover_end_dev(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct expander_device *parent_ex = &parent->ex_dev;\n\tstruct ex_phy *phy = &parent_ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tint res;\n\n\tif (phy->attached_sata_host || phy->attached_sata_ps)\n\t\treturn NULL;\n\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port   = parent->port;\n\tchild->iproto = phy->attached_iproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tif (!phy->port) {\n\t\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t\tif (unlikely(!phy->port))\n\t\t\tgoto out_err;\n\t\tif (unlikely(sas_port_add(phy->port) != 0)) {\n\t\t\tsas_port_free(phy->port);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tsas_ex_get_linkrate(parent, child, phy);\n\tsas_device_set_phy(child, phy->port);\n\n\tif ((phy->attached_tproto & SAS_PROTOCOL_STP) || phy->attached_sata_dev) {\n\t\tres = sas_ata_add_dev(parent, phy, child, phy_id);\n\t} else if (phy->attached_tproto & SAS_PROTOCOL_SSP) {\n\t\tres = sas_ex_add_dev(parent, phy, child, phy_id);\n\t} else {\n\t\tpr_notice(\"target proto 0x%x at %016llx:0x%x not handled\\n\",\n\t\t\t  phy->attached_tproto, SAS_ADDR(parent->sas_addr),\n\t\t\t  phy_id);\n\t\tres = -ENODEV;\n\t}\n\n\tif (res)\n\t\tgoto out_free;\n\n\tlist_add_tail(&child->siblings, &parent_ex->children);\n\treturn child;\n\n out_free:\n\tsas_port_delete(phy->port);\n out_err:\n\tphy->port = NULL;\n\tsas_put_device(child);\n\treturn NULL;\n}\n\n \nstatic bool sas_ex_join_wide_port(struct domain_device *parent, int phy_id)\n{\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tint i;\n\n\tfor (i = 0; i < parent->ex_dev.num_phys; i++) {\n\t\tstruct ex_phy *ephy = &parent->ex_dev.ex_phy[i];\n\n\t\tif (ephy == phy)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(phy->attached_sas_addr, ephy->attached_sas_addr,\n\t\t\t    SAS_ADDR_SIZE) && ephy->port) {\n\t\t\tsas_port_add_phy(ephy->port, phy->phy);\n\t\t\tphy->port = ephy->port;\n\t\t\tphy->phy_state = PHY_DEVICE_DISCOVERED;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic struct domain_device *sas_ex_discover_expander(\n\tstruct domain_device *parent, int phy_id)\n{\n\tstruct sas_expander_device *parent_ex = rphy_to_expander_device(parent->rphy);\n\tstruct ex_phy *phy = &parent->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tstruct sas_rphy *rphy;\n\tstruct sas_expander_device *edev;\n\tstruct asd_sas_port *port;\n\tint res;\n\n\tif (phy->routing_attr == DIRECT_ROUTING) {\n\t\tpr_warn(\"ex %016llx:%02d:D <--> ex %016llx:0x%x is not allowed\\n\",\n\t\t\tSAS_ADDR(parent->sas_addr), phy_id,\n\t\t\tSAS_ADDR(phy->attached_sas_addr),\n\t\t\tphy->attached_phy_id);\n\t\treturn NULL;\n\t}\n\tchild = sas_alloc_device();\n\tif (!child)\n\t\treturn NULL;\n\n\tphy->port = sas_port_alloc(&parent->rphy->dev, phy_id);\n\t \n\tBUG_ON(sas_port_add(phy->port) != 0);\n\n\n\tswitch (phy->attached_dev_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(phy->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\trphy = NULL;\t \n\t\tBUG();\n\t}\n\tport = parent->port;\n\tchild->rphy = rphy;\n\tget_device(&rphy->dev);\n\tedev = rphy_to_expander_device(rphy);\n\tchild->dev_type = phy->attached_dev_type;\n\tkref_get(&parent->kref);\n\tchild->parent = parent;\n\tchild->port = port;\n\tchild->iproto = phy->attached_iproto;\n\tchild->tproto = phy->attached_tproto;\n\tmemcpy(child->sas_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_hash_addr(child->hashed_sas_addr, child->sas_addr);\n\tsas_ex_get_linkrate(parent, child, phy);\n\tedev->level = parent_ex->level + 1;\n\tparent->port->disc.max_level = max(parent->port->disc.max_level,\n\t\t\t\t\t   edev->level);\n\tsas_init_dev(child);\n\tsas_fill_in_rphy(child, rphy);\n\tsas_rphy_add(rphy);\n\n\tspin_lock_irq(&parent->port->dev_list_lock);\n\tlist_add_tail(&child->dev_list_node, &parent->port->dev_list);\n\tspin_unlock_irq(&parent->port->dev_list_lock);\n\n\tres = sas_discover_expander(child);\n\tif (res) {\n\t\tsas_rphy_delete(rphy);\n\t\tspin_lock_irq(&parent->port->dev_list_lock);\n\t\tlist_del(&child->dev_list_node);\n\t\tspin_unlock_irq(&parent->port->dev_list_lock);\n\t\tsas_put_device(child);\n\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t\treturn NULL;\n\t}\n\tlist_add_tail(&child->siblings, &parent->ex_dev.children);\n\treturn child;\n}\n\nstatic int sas_ex_discover_dev(struct domain_device *dev, int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *ex_phy = &ex->ex_phy[phy_id];\n\tstruct domain_device *child = NULL;\n\tint res = 0;\n\n\t \n\tif (ex_phy->linkrate == SAS_SATA_SPINUP_HOLD) {\n\t\tif (!sas_smp_phy_control(dev, phy_id, PHY_FUNC_LINK_RESET, NULL))\n\t\t\tres = sas_ex_phy_discover(dev, phy_id);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\t \n\tif (!dev->parent && sas_phy_match_port_addr(dev->port, ex_phy)) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\treturn 0;\n\t}\n\tif (dev->parent && sas_phy_match_dev_addr(dev->parent, ex_phy)) {\n\t\tsas_add_parent_port(dev, phy_id);\n\t\tif (ex_phy->routing_attr == TABLE_ROUTING)\n\t\t\tsas_configure_phy(dev, phy_id, dev->port->sas_addr, 1);\n\t\treturn 0;\n\t}\n\n\tif (sas_dev_present_in_domain(dev->port, ex_phy->attached_sas_addr))\n\t\tsas_ex_disable_port(dev, ex_phy->attached_sas_addr);\n\n\tif (ex_phy->attached_dev_type == SAS_PHY_UNUSED) {\n\t\tif (ex_phy->routing_attr == DIRECT_ROUTING) {\n\t\t\tmemset(ex_phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\t\tsas_configure_routing(dev, ex_phy->attached_sas_addr);\n\t\t}\n\t\treturn 0;\n\t} else if (ex_phy->linkrate == SAS_LINK_RATE_UNKNOWN)\n\t\treturn 0;\n\n\tif (ex_phy->attached_dev_type != SAS_END_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_FANOUT_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_EDGE_EXPANDER_DEVICE &&\n\t    ex_phy->attached_dev_type != SAS_SATA_PENDING) {\n\t\tpr_warn(\"unknown device type(0x%x) attached to ex %016llx phy%02d\\n\",\n\t\t\tex_phy->attached_dev_type,\n\t\t\tSAS_ADDR(dev->sas_addr),\n\t\t\tphy_id);\n\t\treturn 0;\n\t}\n\n\tres = sas_configure_routing(dev, ex_phy->attached_sas_addr);\n\tif (res) {\n\t\tpr_notice(\"configure routing for dev %016llx reported 0x%x. Forgotten\\n\",\n\t\t\t  SAS_ADDR(ex_phy->attached_sas_addr), res);\n\t\tsas_disable_routing(dev, ex_phy->attached_sas_addr);\n\t\treturn res;\n\t}\n\n\tif (sas_ex_join_wide_port(dev, phy_id)) {\n\t\tpr_debug(\"Attaching ex phy%02d to wide port %016llx\\n\",\n\t\t\t phy_id, SAS_ADDR(ex_phy->attached_sas_addr));\n\t\treturn res;\n\t}\n\n\tswitch (ex_phy->attached_dev_type) {\n\tcase SAS_END_DEVICE:\n\tcase SAS_SATA_PENDING:\n\t\tchild = sas_ex_discover_end_dev(dev, phy_id);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tif (SAS_ADDR(dev->port->disc.fanout_sas_addr)) {\n\t\t\tpr_debug(\"second fanout expander %016llx phy%02d attached to ex %016llx phy%02d\\n\",\n\t\t\t\t SAS_ADDR(ex_phy->attached_sas_addr),\n\t\t\t\t ex_phy->attached_phy_id,\n\t\t\t\t SAS_ADDR(dev->sas_addr),\n\t\t\t\t phy_id);\n\t\t\tsas_ex_disable_phy(dev, phy_id);\n\t\t\treturn res;\n\t\t} else\n\t\t\tmemcpy(dev->port->disc.fanout_sas_addr,\n\t\t\t       ex_phy->attached_sas_addr, SAS_ADDR_SIZE);\n\t\tfallthrough;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\tchild = sas_ex_discover_expander(dev, phy_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!child)\n\t\tpr_notice(\"ex %016llx phy%02d failed to discover\\n\",\n\t\t\t  SAS_ADDR(dev->sas_addr), phy_id);\n\treturn res;\n}\n\nstatic int sas_find_sub_addr(struct domain_device *dev, u8 *sub_addr)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (dev_is_expander(phy->attached_dev_type) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tmemcpy(sub_addr, phy->attached_sas_addr, SAS_ADDR_SIZE);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_check_level_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child;\n\tu8 sub_addr[SAS_ADDR_SIZE] = {0, };\n\n\tlist_for_each_entry(child, &ex->children, siblings) {\n\t\tif (!dev_is_expander(child->dev_type))\n\t\t\tcontinue;\n\t\tif (sub_addr[0] == 0) {\n\t\t\tsas_find_sub_addr(child, sub_addr);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tu8 s2[SAS_ADDR_SIZE];\n\n\t\t\tif (sas_find_sub_addr(child, s2) &&\n\t\t\t    (SAS_ADDR(sub_addr) != SAS_ADDR(s2))) {\n\n\t\t\t\tpr_notice(\"ex %016llx->%016llx-?->%016llx diverges from subtractive boundary %016llx\\n\",\n\t\t\t\t\t  SAS_ADDR(dev->sas_addr),\n\t\t\t\t\t  SAS_ADDR(child->sas_addr),\n\t\t\t\t\t  SAS_ADDR(s2),\n\t\t\t\t\t  SAS_ADDR(sub_addr));\n\n\t\t\t\tsas_ex_disable_port(child, s2);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nstatic int sas_ex_discover_devices(struct domain_device *dev, int single)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i = 0, end = ex->num_phys;\n\tint res = 0;\n\n\tif (0 <= single && single < end) {\n\t\ti = single;\n\t\tend = i+1;\n\t}\n\n\tfor ( ; i < end; i++) {\n\t\tstruct ex_phy *ex_phy = &ex->ex_phy[i];\n\n\t\tif (ex_phy->phy_state == PHY_VACANT ||\n\t\t    ex_phy->phy_state == PHY_NOT_PRESENT ||\n\t\t    ex_phy->phy_state == PHY_DEVICE_DISCOVERED)\n\t\t\tcontinue;\n\n\t\tswitch (ex_phy->linkrate) {\n\t\tcase SAS_PHY_DISABLED:\n\t\tcase SAS_PHY_RESET_PROBLEM:\n\t\tcase SAS_SATA_PORT_SELECTOR:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tres = sas_ex_discover_dev(dev, i);\n\t\t\tif (res)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!res)\n\t\tsas_check_level_subtractive_boundary(dev);\n\n\treturn res;\n}\n\nstatic int sas_check_ex_subtractive_boundary(struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint i;\n\tu8  *sub_sas_addr = NULL;\n\n\tif (dev->dev_type != SAS_EDGE_EXPANDER_DEVICE)\n\t\treturn 0;\n\n\tfor (i = 0; i < ex->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\tif (phy->phy_state == PHY_VACANT ||\n\t\t    phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (dev_is_expander(phy->attached_dev_type) &&\n\t\t    phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\n\t\t\tif (!sub_sas_addr)\n\t\t\t\tsub_sas_addr = &phy->attached_sas_addr[0];\n\t\t\telse if (SAS_ADDR(sub_sas_addr) !=\n\t\t\t\t SAS_ADDR(phy->attached_sas_addr)) {\n\n\t\t\t\tpr_notice(\"ex %016llx phy%02d diverges(%016llx) on subtractive boundary(%016llx). Disabled\\n\",\n\t\t\t\t\t  SAS_ADDR(dev->sas_addr), i,\n\t\t\t\t\t  SAS_ADDR(phy->attached_sas_addr),\n\t\t\t\t\t  SAS_ADDR(sub_sas_addr));\n\t\t\t\tsas_ex_disable_phy(dev, i);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void sas_print_parent_topology_bug(struct domain_device *child,\n\t\t\t\t\t\t struct ex_phy *parent_phy,\n\t\t\t\t\t\t struct ex_phy *child_phy)\n{\n\tstatic const char *ex_type[] = {\n\t\t[SAS_EDGE_EXPANDER_DEVICE] = \"edge\",\n\t\t[SAS_FANOUT_EXPANDER_DEVICE] = \"fanout\",\n\t};\n\tstruct domain_device *parent = child->parent;\n\n\tpr_notice(\"%s ex %016llx phy%02d <--> %s ex %016llx phy%02d has %c:%c routing link!\\n\",\n\t\t  ex_type[parent->dev_type],\n\t\t  SAS_ADDR(parent->sas_addr),\n\t\t  parent_phy->phy_id,\n\n\t\t  ex_type[child->dev_type],\n\t\t  SAS_ADDR(child->sas_addr),\n\t\t  child_phy->phy_id,\n\n\t\t  sas_route_char(parent, parent_phy),\n\t\t  sas_route_char(child, child_phy));\n}\n\nstatic bool sas_eeds_valid(struct domain_device *parent,\n\t\t\t   struct domain_device *child)\n{\n\tstruct sas_discovery *disc = &parent->port->disc;\n\n\treturn (SAS_ADDR(disc->eeds_a) == SAS_ADDR(parent->sas_addr) ||\n\t\tSAS_ADDR(disc->eeds_a) == SAS_ADDR(child->sas_addr)) &&\n\t       (SAS_ADDR(disc->eeds_b) == SAS_ADDR(parent->sas_addr) ||\n\t\tSAS_ADDR(disc->eeds_b) == SAS_ADDR(child->sas_addr));\n}\n\nstatic int sas_check_eeds(struct domain_device *child,\n\t\t\t  struct ex_phy *parent_phy,\n\t\t\t  struct ex_phy *child_phy)\n{\n\tint res = 0;\n\tstruct domain_device *parent = child->parent;\n\tstruct sas_discovery *disc = &parent->port->disc;\n\n\tif (SAS_ADDR(disc->fanout_sas_addr) != 0) {\n\t\tres = -ENODEV;\n\t\tpr_warn(\"edge ex %016llx phy S:%02d <--> edge ex %016llx phy S:%02d, while there is a fanout ex %016llx\\n\",\n\t\t\tSAS_ADDR(parent->sas_addr),\n\t\t\tparent_phy->phy_id,\n\t\t\tSAS_ADDR(child->sas_addr),\n\t\t\tchild_phy->phy_id,\n\t\t\tSAS_ADDR(disc->fanout_sas_addr));\n\t} else if (SAS_ADDR(disc->eeds_a) == 0) {\n\t\tmemcpy(disc->eeds_a, parent->sas_addr, SAS_ADDR_SIZE);\n\t\tmemcpy(disc->eeds_b, child->sas_addr, SAS_ADDR_SIZE);\n\t} else if (!sas_eeds_valid(parent, child)) {\n\t\tres = -ENODEV;\n\t\tpr_warn(\"edge ex %016llx phy%02d <--> edge ex %016llx phy%02d link forms a third EEDS!\\n\",\n\t\t\tSAS_ADDR(parent->sas_addr),\n\t\t\tparent_phy->phy_id,\n\t\t\tSAS_ADDR(child->sas_addr),\n\t\t\tchild_phy->phy_id);\n\t}\n\n\treturn res;\n}\n\nstatic int sas_check_edge_expander_topo(struct domain_device *child,\n\t\t\t\t\tstruct ex_phy *parent_phy)\n{\n\tstruct expander_device *child_ex = &child->ex_dev;\n\tstruct expander_device *parent_ex = &child->parent->ex_dev;\n\tstruct ex_phy *child_phy;\n\n\tchild_phy = &child_ex->ex_phy[parent_phy->attached_phy_id];\n\n\tif (child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\tif (parent_phy->routing_attr != SUBTRACTIVE_ROUTING ||\n\t\t    child_phy->routing_attr != TABLE_ROUTING)\n\t\t\tgoto error;\n\t} else if (parent_phy->routing_attr == SUBTRACTIVE_ROUTING) {\n\t\tif (child_phy->routing_attr == SUBTRACTIVE_ROUTING)\n\t\t\treturn sas_check_eeds(child, parent_phy, child_phy);\n\t\telse if (child_phy->routing_attr != TABLE_ROUTING)\n\t\t\tgoto error;\n\t} else if (parent_phy->routing_attr == TABLE_ROUTING) {\n\t\tif (child_phy->routing_attr != SUBTRACTIVE_ROUTING &&\n\t\t    (child_phy->routing_attr != TABLE_ROUTING ||\n\t\t     !child_ex->t2t_supp || !parent_ex->t2t_supp))\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\treturn -ENODEV;\n}\n\nstatic int sas_check_fanout_expander_topo(struct domain_device *child,\n\t\t\t\t\t  struct ex_phy *parent_phy)\n{\n\tstruct expander_device *child_ex = &child->ex_dev;\n\tstruct ex_phy *child_phy;\n\n\tchild_phy = &child_ex->ex_phy[parent_phy->attached_phy_id];\n\n\tif (parent_phy->routing_attr == TABLE_ROUTING &&\n\t    child_phy->routing_attr == SUBTRACTIVE_ROUTING)\n\t\treturn 0;\n\n\tsas_print_parent_topology_bug(child, parent_phy, child_phy);\n\n\treturn -ENODEV;\n}\n\nstatic int sas_check_parent_topology(struct domain_device *child)\n{\n\tstruct expander_device *parent_ex;\n\tint i;\n\tint res = 0;\n\n\tif (!child->parent)\n\t\treturn 0;\n\n\tif (!dev_is_expander(child->parent->dev_type))\n\t\treturn 0;\n\n\tparent_ex = &child->parent->ex_dev;\n\n\tfor (i = 0; i < parent_ex->num_phys; i++) {\n\t\tstruct ex_phy *parent_phy = &parent_ex->ex_phy[i];\n\n\t\tif (parent_phy->phy_state == PHY_VACANT ||\n\t\t    parent_phy->phy_state == PHY_NOT_PRESENT)\n\t\t\tcontinue;\n\n\t\tif (!sas_phy_match_dev_addr(child, parent_phy))\n\t\t\tcontinue;\n\n\t\tswitch (child->parent->dev_type) {\n\t\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\t\tif (sas_check_edge_expander_topo(child, parent_phy))\n\t\t\t\tres = -ENODEV;\n\t\t\tbreak;\n\t\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\t\tif (sas_check_fanout_expander_topo(child, parent_phy))\n\t\t\t\tres = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n#define RRI_REQ_SIZE  16\n#define RRI_RESP_SIZE 44\n\nstatic int sas_configure_present(struct domain_device *dev, int phy_id,\n\t\t\t\t u8 *sas_addr, int *index, int *present)\n{\n\tint i, res = 0;\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tu8 *rri_req;\n\tu8 *rri_resp;\n\n\t*present = 0;\n\t*index = 0;\n\n\trri_req = alloc_smp_req(RRI_REQ_SIZE);\n\tif (!rri_req)\n\t\treturn -ENOMEM;\n\n\trri_resp = alloc_smp_resp(RRI_RESP_SIZE);\n\tif (!rri_resp) {\n\t\tkfree(rri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trri_req[1] = SMP_REPORT_ROUTE_INFO;\n\trri_req[9] = phy_id;\n\n\tfor (i = 0; i < ex->max_route_indexes ; i++) {\n\t\t*(__be16 *)(rri_req+6) = cpu_to_be16(i);\n\t\tres = smp_execute_task(dev, rri_req, RRI_REQ_SIZE, rri_resp,\n\t\t\t\t       RRI_RESP_SIZE);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tres = rri_resp[2];\n\t\tif (res == SMP_RESP_NO_INDEX) {\n\t\t\tpr_warn(\"overflow of indexes: dev %016llx phy%02d index 0x%x\\n\",\n\t\t\t\tSAS_ADDR(dev->sas_addr), phy_id, i);\n\t\t\tgoto out;\n\t\t} else if (res != SMP_RESP_FUNC_ACC) {\n\t\t\tpr_notice(\"%s: dev %016llx phy%02d index 0x%x result 0x%x\\n\",\n\t\t\t\t  __func__, SAS_ADDR(dev->sas_addr), phy_id,\n\t\t\t\t  i, res);\n\t\t\tgoto out;\n\t\t}\n\t\tif (SAS_ADDR(sas_addr) != 0) {\n\t\t\tif (SAS_ADDR(rri_resp+16) == SAS_ADDR(sas_addr)) {\n\t\t\t\t*index = i;\n\t\t\t\tif ((rri_resp[12] & 0x80) == 0x80)\n\t\t\t\t\t*present = 0;\n\t\t\t\telse\n\t\t\t\t\t*present = 1;\n\t\t\t\tgoto out;\n\t\t\t} else if (SAS_ADDR(rri_resp+16) == 0) {\n\t\t\t\t*index = i;\n\t\t\t\t*present = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (SAS_ADDR(rri_resp+16) == 0 &&\n\t\t\t   phy->last_da_index < i) {\n\t\t\tphy->last_da_index = i;\n\t\t\t*index = i;\n\t\t\t*present = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tres = -1;\nout:\n\tkfree(rri_req);\n\tkfree(rri_resp);\n\treturn res;\n}\n\n#define CRI_REQ_SIZE  44\n#define CRI_RESP_SIZE  8\n\nstatic int sas_configure_set(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, int index, int include)\n{\n\tint res;\n\tu8 *cri_req;\n\tu8 *cri_resp;\n\n\tcri_req = alloc_smp_req(CRI_REQ_SIZE);\n\tif (!cri_req)\n\t\treturn -ENOMEM;\n\n\tcri_resp = alloc_smp_resp(CRI_RESP_SIZE);\n\tif (!cri_resp) {\n\t\tkfree(cri_req);\n\t\treturn -ENOMEM;\n\t}\n\n\tcri_req[1] = SMP_CONF_ROUTE_INFO;\n\t*(__be16 *)(cri_req+6) = cpu_to_be16(index);\n\tcri_req[9] = phy_id;\n\tif (SAS_ADDR(sas_addr) == 0 || !include)\n\t\tcri_req[12] |= 0x80;\n\tmemcpy(cri_req+16, sas_addr, SAS_ADDR_SIZE);\n\n\tres = smp_execute_task(dev, cri_req, CRI_REQ_SIZE, cri_resp,\n\t\t\t       CRI_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tres = cri_resp[2];\n\tif (res == SMP_RESP_NO_INDEX) {\n\t\tpr_warn(\"overflow of indexes: dev %016llx phy%02d index 0x%x\\n\",\n\t\t\tSAS_ADDR(dev->sas_addr), phy_id, index);\n\t}\nout:\n\tkfree(cri_req);\n\tkfree(cri_resp);\n\treturn res;\n}\n\nstatic int sas_configure_phy(struct domain_device *dev, int phy_id,\n\t\t\t\t    u8 *sas_addr, int include)\n{\n\tint index;\n\tint present;\n\tint res;\n\n\tres = sas_configure_present(dev, phy_id, sas_addr, &index, &present);\n\tif (res)\n\t\treturn res;\n\tif (include ^ present)\n\t\treturn sas_configure_set(dev, phy_id, sas_addr, index,\n\t\t\t\t\t include);\n\n\treturn res;\n}\n\n \nstatic int sas_configure_parent(struct domain_device *parent,\n\t\t\t\tstruct domain_device *child,\n\t\t\t\tu8 *sas_addr, int include)\n{\n\tstruct expander_device *ex_parent = &parent->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tif (parent->parent) {\n\t\tres = sas_configure_parent(parent->parent, parent, sas_addr,\n\t\t\t\t\t   include);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (ex_parent->conf_route_table == 0) {\n\t\tpr_debug(\"ex %016llx has self-configuring routing table\\n\",\n\t\t\t SAS_ADDR(parent->sas_addr));\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ex_parent->num_phys; i++) {\n\t\tstruct ex_phy *phy = &ex_parent->ex_phy[i];\n\n\t\tif ((phy->routing_attr == TABLE_ROUTING) &&\n\t\t    sas_phy_match_dev_addr(child, phy)) {\n\t\t\tres = sas_configure_phy(parent, i, sas_addr, include);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n \nstatic int sas_configure_routing(struct domain_device *dev, u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 1);\n\treturn 0;\n}\n\nstatic int sas_disable_routing(struct domain_device *dev,  u8 *sas_addr)\n{\n\tif (dev->parent)\n\t\treturn sas_configure_parent(dev->parent, dev, sas_addr, 0);\n\treturn 0;\n}\n\n \nstatic int sas_discover_expander(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\tres = sas_ex_general(dev);\n\tif (res)\n\t\tgoto out_err;\n\tres = sas_ex_manuf_info(dev);\n\tif (res)\n\t\tgoto out_err;\n\n\tres = sas_expander_discover(dev);\n\tif (res) {\n\t\tpr_warn(\"expander %016llx discovery failed(0x%x)\\n\",\n\t\t\tSAS_ADDR(dev->sas_addr), res);\n\t\tgoto out_err;\n\t}\n\n\tsas_check_ex_subtractive_boundary(dev);\n\tres = sas_check_parent_topology(dev);\n\tif (res)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\tsas_notify_lldd_dev_gone(dev);\n\treturn res;\n}\n\nstatic int sas_ex_level_discovery(struct asd_sas_port *port, const int level)\n{\n\tint res = 0;\n\tstruct domain_device *dev;\n\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tif (dev_is_expander(dev->dev_type)) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(dev->rphy);\n\n\t\t\tif (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(dev, -1);\n\t\t\telse if (level > 0)\n\t\t\t\tres = sas_ex_discover_devices(port->port_dev, -1);\n\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int sas_ex_bfs_disc(struct asd_sas_port *port)\n{\n\tint res;\n\tint level;\n\n\tdo {\n\t\tlevel = port->disc.max_level;\n\t\tres = sas_ex_level_discovery(port, level);\n\t\tmb();\n\t} while (level < port->disc.max_level);\n\n\treturn res;\n}\n\nint sas_discover_root_expander(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\n\tres = sas_rphy_add(dev->rphy);\n\tif (res)\n\t\tgoto out_err;\n\n\tex->level = dev->port->disc.max_level;  \n\tres = sas_discover_expander(dev);\n\tif (res)\n\t\tgoto out_err2;\n\n\tsas_ex_bfs_disc(dev->port);\n\n\treturn res;\n\nout_err2:\n\tsas_rphy_remove(dev->rphy);\nout_err:\n\treturn res;\n}\n\n \n\nstatic int sas_get_phy_discover(struct domain_device *dev,\n\t\t\t\tint phy_id, struct smp_disc_resp *disc_resp)\n{\n\tint res;\n\tu8 *disc_req;\n\n\tdisc_req = alloc_smp_req(DISCOVER_REQ_SIZE);\n\tif (!disc_req)\n\t\treturn -ENOMEM;\n\n\tdisc_req[1] = SMP_DISCOVER;\n\tdisc_req[9] = phy_id;\n\n\tres = smp_execute_task(dev, disc_req, DISCOVER_REQ_SIZE,\n\t\t\t       disc_resp, DISCOVER_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tif (disc_resp->result != SMP_RESP_FUNC_ACC)\n\t\tres = disc_resp->result;\nout:\n\tkfree(disc_req);\n\treturn res;\n}\n\nstatic int sas_get_phy_change_count(struct domain_device *dev,\n\t\t\t\t    int phy_id, int *pcc)\n{\n\tint res;\n\tstruct smp_disc_resp *disc_resp;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (!res)\n\t\t*pcc = disc_resp->disc.change_count;\n\n\tkfree(disc_resp);\n\treturn res;\n}\n\nint sas_get_phy_attached_dev(struct domain_device *dev, int phy_id,\n\t\t\t     u8 *sas_addr, enum sas_device_type *type)\n{\n\tint res;\n\tstruct smp_disc_resp *disc_resp;\n\n\tdisc_resp = alloc_smp_resp(DISCOVER_RESP_SIZE);\n\tif (!disc_resp)\n\t\treturn -ENOMEM;\n\n\tres = sas_get_phy_discover(dev, phy_id, disc_resp);\n\tif (res == 0) {\n\t\tmemcpy(sas_addr, disc_resp->disc.attached_sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\t*type = to_dev_type(&disc_resp->disc);\n\t\tif (*type == 0)\n\t\t\tmemset(sas_addr, 0, SAS_ADDR_SIZE);\n\t}\n\tkfree(disc_resp);\n\treturn res;\n}\n\nstatic int sas_find_bcast_phy(struct domain_device *dev, int *phy_id,\n\t\t\t      int from_phy, bool update)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint res = 0;\n\tint i;\n\n\tfor (i = from_phy; i < ex->num_phys; i++) {\n\t\tint phy_change_count = 0;\n\n\t\tres = sas_get_phy_change_count(dev, i, &phy_change_count);\n\t\tswitch (res) {\n\t\tcase SMP_RESP_PHY_VACANT:\n\t\tcase SMP_RESP_NO_PHY:\n\t\t\tcontinue;\n\t\tcase SMP_RESP_FUNC_ACC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn res;\n\t\t}\n\n\t\tif (phy_change_count != ex->ex_phy[i].phy_change_count) {\n\t\t\tif (update)\n\t\t\t\tex->ex_phy[i].phy_change_count =\n\t\t\t\t\tphy_change_count;\n\t\t\t*phy_id = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sas_get_ex_change_count(struct domain_device *dev, int *ecc)\n{\n\tint res;\n\tu8  *rg_req;\n\tstruct smp_rg_resp  *rg_resp;\n\n\trg_req = alloc_smp_req(RG_REQ_SIZE);\n\tif (!rg_req)\n\t\treturn -ENOMEM;\n\n\trg_resp = alloc_smp_resp(RG_RESP_SIZE);\n\tif (!rg_resp) {\n\t\tkfree(rg_req);\n\t\treturn -ENOMEM;\n\t}\n\n\trg_req[1] = SMP_REPORT_GENERAL;\n\n\tres = smp_execute_task(dev, rg_req, RG_REQ_SIZE, rg_resp,\n\t\t\t       RG_RESP_SIZE);\n\tif (res)\n\t\tgoto out;\n\tif (rg_resp->result != SMP_RESP_FUNC_ACC) {\n\t\tres = rg_resp->result;\n\t\tgoto out;\n\t}\n\n\t*ecc = be16_to_cpu(rg_resp->rg.change_count);\nout:\n\tkfree(rg_resp);\n\tkfree(rg_req);\n\treturn res;\n}\n \n\nstatic int sas_find_bcast_dev(struct domain_device *dev,\n\t\t\t      struct domain_device **src_dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tint ex_change_count = -1;\n\tint phy_id = -1;\n\tint res;\n\tstruct domain_device *ch;\n\n\tres = sas_get_ex_change_count(dev, &ex_change_count);\n\tif (res)\n\t\tgoto out;\n\tif (ex_change_count != -1 && ex_change_count != ex->ex_change_count) {\n\t\t \n\t\tres = sas_find_bcast_phy(dev, &phy_id, 0, false);\n\t\tif (phy_id != -1) {\n\t\t\t*src_dev = dev;\n\t\t\tex->ex_change_count = ex_change_count;\n\t\t\tpr_info(\"ex %016llx phy%02d change count has changed\\n\",\n\t\t\t\tSAS_ADDR(dev->sas_addr), phy_id);\n\t\t\treturn res;\n\t\t} else\n\t\t\tpr_info(\"ex %016llx phys DID NOT change\\n\",\n\t\t\t\tSAS_ADDR(dev->sas_addr));\n\t}\n\tlist_for_each_entry(ch, &ex->children, siblings) {\n\t\tif (dev_is_expander(ch->dev_type)) {\n\t\t\tres = sas_find_bcast_dev(ch, src_dev);\n\t\t\tif (*src_dev)\n\t\t\t\treturn res;\n\t\t}\n\t}\nout:\n\treturn res;\n}\n\nstatic void sas_unregister_ex_tree(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct domain_device *child, *n;\n\n\tlist_for_each_entry_safe(child, n, &ex->children, siblings) {\n\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\tif (dev_is_expander(child->dev_type))\n\t\t\tsas_unregister_ex_tree(port, child);\n\t\telse\n\t\t\tsas_unregister_dev(port, child);\n\t}\n\tsas_unregister_dev(port, dev);\n}\n\nstatic void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (sas_phy_match_dev_addr(child, phy)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (dev_is_expander(child->dev_type))\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tlist_add_tail(&phy->port->del_list,\n\t\t\t\t&parent->port->sas_port_del_list);\n\t\tphy->port = NULL;\n\t}\n}\n\nstatic int sas_discover_bfs_by_root_level(struct domain_device *root,\n\t\t\t\t\t  const int level)\n{\n\tstruct expander_device *ex_root = &root->ex_dev;\n\tstruct domain_device *child;\n\tint res = 0;\n\n\tlist_for_each_entry(child, &ex_root->children, siblings) {\n\t\tif (dev_is_expander(child->dev_type)) {\n\t\t\tstruct sas_expander_device *ex =\n\t\t\t\trphy_to_expander_device(child->rphy);\n\n\t\t\tif (level > ex->level)\n\t\t\t\tres = sas_discover_bfs_by_root_level(child,\n\t\t\t\t\t\t\t\t     level);\n\t\t\telse if (level == ex->level)\n\t\t\t\tres = sas_ex_discover_devices(child, -1);\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic int sas_discover_bfs_by_root(struct domain_device *dev)\n{\n\tint res;\n\tstruct sas_expander_device *ex = rphy_to_expander_device(dev->rphy);\n\tint level = ex->level+1;\n\n\tres = sas_ex_discover_devices(dev, -1);\n\tif (res)\n\t\tgoto out;\n\tdo {\n\t\tres = sas_discover_bfs_by_root_level(dev, level);\n\t\tmb();\n\t\tlevel += 1;\n\t} while (level <= dev->port->disc.max_level);\nout:\n\treturn res;\n}\n\nstatic int sas_discover_new(struct domain_device *dev, int phy_id)\n{\n\tstruct ex_phy *ex_phy = &dev->ex_dev.ex_phy[phy_id];\n\tstruct domain_device *child;\n\tint res;\n\n\tpr_debug(\"ex %016llx phy%02d new device attached\\n\",\n\t\t SAS_ADDR(dev->sas_addr), phy_id);\n\tres = sas_ex_phy_discover(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\n\tif (sas_ex_join_wide_port(dev, phy_id))\n\t\treturn 0;\n\n\tres = sas_ex_discover_devices(dev, phy_id);\n\tif (res)\n\t\treturn res;\n\tlist_for_each_entry(child, &dev->ex_dev.children, siblings) {\n\t\tif (sas_phy_match_dev_addr(child, ex_phy)) {\n\t\t\tif (dev_is_expander(child->dev_type))\n\t\t\t\tres = sas_discover_bfs_by_root(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nstatic bool dev_type_flutter(enum sas_device_type new, enum sas_device_type old)\n{\n\tif (old == new)\n\t\treturn true;\n\n\t \n\tif ((old == SAS_SATA_PENDING && new == SAS_END_DEVICE) ||\n\t    (old == SAS_END_DEVICE && new == SAS_SATA_PENDING))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int sas_rediscover_dev(struct domain_device *dev, int phy_id,\n\t\t\t      bool last, int sibling)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *phy = &ex->ex_phy[phy_id];\n\tenum sas_device_type type = SAS_PHY_UNUSED;\n\tu8 sas_addr[SAS_ADDR_SIZE];\n\tchar msg[80] = \"\";\n\tint res;\n\n\tif (!last)\n\t\tsprintf(msg, \", part of a wide port with phy%02d\", sibling);\n\n\tpr_debug(\"ex %016llx rediscovering phy%02d%s\\n\",\n\t\t SAS_ADDR(dev->sas_addr), phy_id, msg);\n\n\tmemset(sas_addr, 0, SAS_ADDR_SIZE);\n\tres = sas_get_phy_attached_dev(dev, phy_id, sas_addr, &type);\n\tswitch (res) {\n\tcase SMP_RESP_NO_PHY:\n\t\tphy->phy_state = PHY_NOT_PRESENT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_PHY_VACANT:\n\t\tphy->phy_state = PHY_VACANT;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\treturn res;\n\tcase SMP_RESP_FUNC_ACC:\n\t\tbreak;\n\tcase -ECOMM:\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\tif ((SAS_ADDR(sas_addr) == 0) || (res == -ECOMM)) {\n\t\tphy->phy_state = PHY_EMPTY;\n\t\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\t\t \n\t\tsas_ex_phy_discover(dev, phy_id);\n\t\treturn res;\n\t} else if (SAS_ADDR(sas_addr) == SAS_ADDR(phy->attached_sas_addr) &&\n\t\t   dev_type_flutter(type, phy->attached_dev_type)) {\n\t\tstruct domain_device *ata_dev = sas_ex_to_ata(dev, phy_id);\n\t\tchar *action = \"\";\n\n\t\tsas_ex_phy_discover(dev, phy_id);\n\n\t\tif (ata_dev && phy->attached_dev_type == SAS_SATA_PENDING)\n\t\t\taction = \", needs recovery\";\n\t\tpr_debug(\"ex %016llx phy%02d broadcast flutter%s\\n\",\n\t\t\t SAS_ADDR(dev->sas_addr), phy_id, action);\n\t\treturn res;\n\t}\n\n\t \n\tpr_info(\"ex %016llx phy%02d replace %016llx\\n\",\n\t\tSAS_ADDR(dev->sas_addr), phy_id,\n\t\tSAS_ADDR(phy->attached_sas_addr));\n\tsas_unregister_devs_sas_addr(dev, phy_id, last);\n\n\treturn sas_discover_new(dev, phy_id);\n}\n\n \nstatic int sas_rediscover(struct domain_device *dev, const int phy_id)\n{\n\tstruct expander_device *ex = &dev->ex_dev;\n\tstruct ex_phy *changed_phy = &ex->ex_phy[phy_id];\n\tint res = 0;\n\tint i;\n\tbool last = true;\t \n\n\tpr_debug(\"ex %016llx phy%02d originated BROADCAST(CHANGE)\\n\",\n\t\t SAS_ADDR(dev->sas_addr), phy_id);\n\n\tif (SAS_ADDR(changed_phy->attached_sas_addr) != 0) {\n\t\tfor (i = 0; i < ex->num_phys; i++) {\n\t\t\tstruct ex_phy *phy = &ex->ex_phy[i];\n\n\t\t\tif (i == phy_id)\n\t\t\t\tcontinue;\n\t\t\tif (sas_phy_addr_match(phy, changed_phy)) {\n\t\t\t\tlast = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = sas_rediscover_dev(dev, phy_id, last, i);\n\t} else\n\t\tres = sas_discover_new(dev, phy_id);\n\treturn res;\n}\n\n \nint sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\tif (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t}\n\treturn res;\n}\n\nint sas_find_attached_phy_id(struct expander_device *ex_dev,\n\t\t\t     struct domain_device *dev)\n{\n\tstruct ex_phy *phy;\n\tint phy_id;\n\n\tfor (phy_id = 0; phy_id < ex_dev->num_phys; phy_id++) {\n\t\tphy = &ex_dev->ex_phy[phy_id];\n\t\tif (sas_phy_match_dev_addr(dev, phy))\n\t\t\treturn phy_id;\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(sas_find_attached_phy_id);\n\nvoid sas_smp_handler(struct bsg_job *job, struct Scsi_Host *shost,\n\t\tstruct sas_rphy *rphy)\n{\n\tstruct domain_device *dev;\n\tunsigned int rcvlen = 0;\n\tint ret = -EINVAL;\n\n\t \n\tif (!rphy)\n\t\treturn sas_smp_host_handler(job, shost);\n\n\tswitch (rphy->identify.device_type) {\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: can we send a smp request to a device?\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\n\tdev = sas_find_dev_by_rphy(rphy);\n\tif (!dev) {\n\t\tpr_err(\"%s: fail to find a domain_device?\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tif (job->request_payload.sg_cnt > 1 ||\n\t    job->reply_payload.sg_cnt > 1) {\n\t\tpr_info(\"%s: multiple segments req %u, rsp %u\\n\",\n\t\t\t__func__, job->request_payload.payload_len,\n\t\t\tjob->reply_payload.payload_len);\n\t\tgoto out;\n\t}\n\n\tret = smp_execute_task_sg(dev, job->request_payload.sg_list,\n\t\t\tjob->reply_payload.sg_list);\n\tif (ret >= 0) {\n\t\t \n\t\trcvlen = job->reply_payload.payload_len - ret;\n\t\tret = 0;\n\t}\n\nout:\n\tbsg_job_done(job, ret, rcvlen);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}