{
  "module_name": "sas_discover.c",
  "hash_id": "4caffa4b09b7604202abe56c40053e379b9572150d0c350ce772aec9762d6f7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_discover.c",
  "human_readable_source": "\n \n\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_eh.h>\n#include \"sas_internal.h\"\n\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include <scsi/sas_ata.h>\n#include \"scsi_sas_internal.h\"\n\n \n\nvoid sas_init_dev(struct domain_device *dev)\n{\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\tINIT_LIST_HEAD(&dev->ssp_dev.eh_list_node);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\tINIT_LIST_HEAD(&dev->ex_dev.children);\n\t\tmutex_init(&dev->ex_dev.cmd_mutex);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n\n \nstatic int sas_get_port_device(struct asd_sas_port *port)\n{\n\tstruct asd_sas_phy *phy;\n\tstruct sas_rphy *rphy;\n\tstruct domain_device *dev;\n\tint rc = -ENODEV;\n\n\tdev = sas_alloc_device();\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tif (list_empty(&port->phy_list)) {\n\t\tspin_unlock_irq(&port->phy_list_lock);\n\t\tsas_put_device(dev);\n\t\treturn -ENODEV;\n\t}\n\tphy = container_of(port->phy_list.next, struct asd_sas_phy, port_phy_el);\n\tspin_lock(&phy->frame_rcvd_lock);\n\tmemcpy(dev->frame_rcvd, phy->frame_rcvd, min(sizeof(dev->frame_rcvd),\n\t\t\t\t\t     (size_t)phy->frame_rcvd_size));\n\tspin_unlock(&phy->frame_rcvd_lock);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\tif (dev->frame_rcvd[0] == 0x34 && port->oob_mode == SATA_OOB_MODE) {\n\t\tstruct dev_to_host_fis *fis =\n\t\t\t(struct dev_to_host_fis *) dev->frame_rcvd;\n\t\tif (fis->interrupt_reason == 1 && fis->lbal == 1 &&\n\t\t    fis->byte_count_low == 0x69 && fis->byte_count_high == 0x96\n\t\t    && (fis->device & ~0x10) == 0)\n\t\t\tdev->dev_type = SAS_SATA_PM;\n\t\telse\n\t\t\tdev->dev_type = SAS_SATA_DEV;\n\t\tdev->tproto = SAS_PROTOCOL_SATA;\n\t} else if (port->oob_mode == SAS_OOB_MODE) {\n\t\tstruct sas_identify_frame *id =\n\t\t\t(struct sas_identify_frame *) dev->frame_rcvd;\n\t\tdev->dev_type = id->dev_type;\n\t\tdev->iproto = id->initiator_bits;\n\t\tdev->tproto = id->target_bits;\n\t} else {\n\t\t \n\t\tsas_put_device(dev);\n\t\tpr_warn(\"Port %016llx is disconnected when discovering\\n\",\n\t\t\tSAS_ADDR(port->attached_sas_addr));\n\t\treturn -ENODEV;\n\t}\n\n\tsas_init_dev(dev);\n\n\tdev->port = port;\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_DEV:\n\t\trc = sas_ata_init(dev);\n\t\tif (rc) {\n\t\t\trphy = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase SAS_END_DEVICE:\n\t\trphy = sas_end_device_alloc(port->port);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_EDGE_EXPANDER_DEVICE);\n\t\tbreak;\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\trphy = sas_expander_alloc(port->port,\n\t\t\t\t\t  SAS_FANOUT_EXPANDER_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"ERROR: Unidentified device type %d\\n\", dev->dev_type);\n\t\trphy = NULL;\n\t\tbreak;\n\t}\n\n\tif (!rphy) {\n\t\tsas_put_device(dev);\n\t\treturn rc;\n\t}\n\n\trphy->identify.phy_identifier = phy->phy->identify.phy_identifier;\n\tmemcpy(dev->sas_addr, port->attached_sas_addr, SAS_ADDR_SIZE);\n\tsas_fill_in_rphy(dev, rphy);\n\tsas_hash_addr(dev->hashed_sas_addr, dev->sas_addr);\n\tport->port_dev = dev;\n\tdev->linkrate = port->linkrate;\n\tdev->min_linkrate = port->linkrate;\n\tdev->max_linkrate = port->linkrate;\n\tdev->pathways = port->num_phys;\n\tmemset(port->disc.fanout_sas_addr, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_a, 0, SAS_ADDR_SIZE);\n\tmemset(port->disc.eeds_b, 0, SAS_ADDR_SIZE);\n\tport->disc.max_level = 0;\n\tsas_device_set_phy(dev, port->port);\n\n\tdev->rphy = rphy;\n\tget_device(&dev->rphy->dev);\n\n\tif (dev_is_sata(dev) || dev->dev_type == SAS_END_DEVICE)\n\t\tlist_add_tail(&dev->disco_list_node, &port->disco_list);\n\telse {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tspin_lock_irq(&port->phy_list_lock);\n\tlist_for_each_entry(phy, &port->phy_list, port_phy_el)\n\t\tsas_phy_set_target(phy, dev);\n\tspin_unlock_irq(&port->phy_list_lock);\n\n\treturn 0;\n}\n\n \n\nint sas_notify_lldd_dev_found(struct domain_device *dev)\n{\n\tint res = 0;\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *shost = sas_ha->shost;\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\tif (!i->dft->lldd_dev_found)\n\t\treturn 0;\n\n\tres = i->dft->lldd_dev_found(dev);\n\tif (res) {\n\t\tpr_warn(\"driver on host %s cannot handle device %016llx, error:%d\\n\",\n\t\t\tdev_name(sas_ha->dev),\n\t\t\tSAS_ADDR(dev->sas_addr), res);\n\t\treturn res;\n\t}\n\tset_bit(SAS_DEV_FOUND, &dev->state);\n\tkref_get(&dev->kref);\n\treturn 0;\n}\n\n\nvoid sas_notify_lldd_dev_gone(struct domain_device *dev)\n{\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *shost = sas_ha->shost;\n\tstruct sas_internal *i = to_sas_internal(shost->transportt);\n\n\tif (!i->dft->lldd_dev_gone)\n\t\treturn;\n\n\tif (test_and_clear_bit(SAS_DEV_FOUND, &dev->state)) {\n\t\ti->dft->lldd_dev_gone(dev);\n\t\tsas_put_device(dev);\n\t}\n}\n\nstatic void sas_probe_devices(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\t \n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tsas_probe_sata(port);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}\n\nstatic void sas_suspend_devices(struct work_struct *work)\n{\n\tstruct asd_sas_phy *phy;\n\tstruct domain_device *dev;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct Scsi_Host *shost = port->ha->shost;\n\tstruct sas_internal *si = to_sas_internal(shost->transportt);\n\n\tclear_bit(DISCE_SUSPEND, &port->disc.pending);\n\n\tsas_suspend_sata(port);\n\n\t \n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node)\n\t\tsas_notify_lldd_dev_gone(dev);\n\n\t \n\tlist_for_each_entry(phy, &port->phy_list, port_phy_el) {\n\t\tif (si->dft->lldd_port_deformed)\n\t\t\tsi->dft->lldd_port_deformed(phy);\n\t\tphy->suspended = 1;\n\t\tport->suspended = 1;\n\t}\n}\n\nstatic void sas_resume_devices(struct work_struct *work)\n{\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_RESUME, &port->disc.pending);\n\n\tsas_resume_sata(port);\n}\n\n \nint sas_discover_end_dev(struct domain_device *dev)\n{\n\treturn sas_notify_lldd_dev_found(dev);\n}\n\n \n\nvoid sas_free_device(struct kref *kref)\n{\n\tstruct domain_device *dev = container_of(kref, typeof(*dev), kref);\n\n\tput_device(&dev->rphy->dev);\n\tdev->rphy = NULL;\n\n\tif (dev->parent)\n\t\tsas_put_device(dev->parent);\n\n\tsas_port_put_phy(dev->phy);\n\tdev->phy = NULL;\n\n\t \n\tif (dev_is_expander(dev->dev_type))\n\t\tkfree(dev->ex_dev.ex_phy);\n\n\tif (dev_is_sata(dev) && dev->sata_dev.ap) {\n\t\tata_sas_tport_delete(dev->sata_dev.ap);\n\t\tkfree(dev->sata_dev.ap);\n\t\tata_host_put(dev->sata_dev.ata_host);\n\t\tdev->sata_dev.ata_host = NULL;\n\t\tdev->sata_dev.ap = NULL;\n\t}\n\n\tkfree(dev);\n}\n\nstatic void sas_unregister_common_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct sas_ha_struct *ha = port->ha;\n\n\tsas_notify_lldd_dev_gone(dev);\n\tif (!dev->parent)\n\t\tdev->port->port_dev = NULL;\n\telse\n\t\tlist_del_init(&dev->siblings);\n\n\tspin_lock_irq(&port->dev_list_lock);\n\tlist_del_init(&dev->dev_list_node);\n\tif (dev_is_sata(dev))\n\t\tsas_ata_end_eh(dev->sata_dev.ap);\n\tspin_unlock_irq(&port->dev_list_lock);\n\n\tspin_lock_irq(&ha->lock);\n\tif (dev->dev_type == SAS_END_DEVICE &&\n\t    !list_empty(&dev->ssp_dev.eh_list_node)) {\n\t\tlist_del_init(&dev->ssp_dev.eh_list_node);\n\t\tha->eh_active--;\n\t}\n\tspin_unlock_irq(&ha->lock);\n\n\tsas_put_device(dev);\n}\n\nvoid sas_destruct_devices(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}\n\nstatic void sas_destruct_ports(struct asd_sas_port *port)\n{\n\tstruct sas_port *sas_port, *p;\n\n\tlist_for_each_entry_safe(sas_port, p, &port->sas_port_del_list, del_list) {\n\t\tlist_del_init(&sas_port->del_list);\n\t\tsas_port_delete(sas_port);\n\t}\n}\n\nstatic bool sas_abort_cmd(struct request *req, void *data)\n{\n\tstruct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);\n\tstruct domain_device *dev = data;\n\n\tif (dev == cmd_to_domain_dev(cmd))\n\t\tblk_abort_request(req);\n\treturn true;\n}\n\nstatic void sas_abort_device_scsi_cmds(struct domain_device *dev)\n{\n\tstruct sas_ha_struct *sas_ha = dev->port->ha;\n\tstruct Scsi_Host *shost = sas_ha->shost;\n\n\tif (dev_is_expander(dev->dev_type))\n\t\treturn;\n\n\t \n\tblk_mq_tagset_busy_iter(&shost->tag_set, sas_abort_cmd, dev);\n}\n\nvoid sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\t \n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tif (test_bit(SAS_DEV_GONE, &dev->state))\n\t\t\tsas_abort_device_scsi_cmds(dev);\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t}\n}\n\nvoid sas_unregister_domain_devices(struct asd_sas_port *port, int gone)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe_reverse(dev, n, &port->dev_list, dev_list_node) {\n\t\tif (gone)\n\t\t\tset_bit(SAS_DEV_GONE, &dev->state);\n\t\tsas_unregister_dev(port, dev);\n\t}\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node)\n\t\tsas_unregister_dev(port, dev);\n\n\tport->port->rphy = NULL;\n\n}\n\nvoid sas_device_set_phy(struct domain_device *dev, struct sas_port *port)\n{\n\tstruct sas_ha_struct *ha;\n\tstruct sas_phy *new_phy;\n\n\tif (!dev)\n\t\treturn;\n\n\tha = dev->port->ha;\n\tnew_phy = sas_port_get_phy(port);\n\n\t \n\tspin_lock_irq(&ha->phy_port_lock);\n\tif (new_phy) {\n\t\tsas_port_put_phy(dev->phy);\n\t\tdev->phy = new_phy;\n\t}\n\tspin_unlock_irq(&ha->phy_port_lock);\n}\n\n \n\n \nstatic void sas_discover_domain(struct work_struct *work)\n{\n\tstruct domain_device *dev;\n\tint error = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_DISCOVER_DOMAIN, &port->disc.pending);\n\n\tif (port->port_dev)\n\t\treturn;\n\n\terror = sas_get_port_device(port);\n\tif (error)\n\t\treturn;\n\tdev = port->port_dev;\n\n\tpr_debug(\"DOING DISCOVERY on port %d, pid:%d\\n\", port->id,\n\t\t task_pid_nr(current));\n\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\terror = sas_discover_end_dev(dev);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\terror = sas_discover_root_expander(dev);\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PM:\n\t\terror = sas_discover_sata(dev);\n\t\tbreak;\n\tdefault:\n\t\terror = -ENXIO;\n\t\tpr_err(\"unhandled device %d\\n\", dev->dev_type);\n\t\tbreak;\n\t}\n\n\tif (error) {\n\t\tsas_rphy_free(dev->rphy);\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_del_init(&dev->dev_list_node);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\n\t\tsas_put_device(dev);\n\t\tport->port_dev = NULL;\n\t}\n\n\tsas_probe_devices(port);\n\n\tpr_debug(\"DONE DISCOVERY on port %d, pid:%d, result:%d\\n\", port->id,\n\t\t task_pid_nr(current), error);\n}\n\nstatic void sas_revalidate_domain(struct work_struct *work)\n{\n\tint res = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct sas_ha_struct *ha = port->ha;\n\tstruct domain_device *ddev = port->port_dev;\n\n\t \n\tmutex_lock(&ha->disco_mutex);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\tpr_debug(\"REVALIDATION DEFERRED on port %d, pid:%d\\n\",\n\t\t\t port->id, task_pid_nr(current));\n\t\tgoto out;\n\t}\n\n\tclear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);\n\n\tpr_debug(\"REVALIDATING DOMAIN on port %d, pid:%d\\n\", port->id,\n\t\t task_pid_nr(current));\n\n\tif (ddev && dev_is_expander(ddev->dev_type))\n\t\tres = sas_ex_revalidate_domain(ddev);\n\n\tpr_debug(\"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\n\",\n\t\t port->id, task_pid_nr(current), res);\n out:\n\tmutex_unlock(&ha->disco_mutex);\n\n\tsas_destruct_devices(port);\n\tsas_destruct_ports(port);\n\tsas_probe_devices(port);\n}\n\n \n\nstatic void sas_chain_work(struct sas_ha_struct *ha, struct sas_work *sw)\n{\n\t \n\tqueue_work(ha->disco_q, &sw->work);\n}\n\nstatic void sas_chain_event(int event, unsigned long *pending,\n\t\t\t    struct sas_work *sw,\n\t\t\t    struct sas_ha_struct *ha)\n{\n\tif (!test_and_set_bit(event, pending)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ha->lock, flags);\n\t\tsas_chain_work(ha, sw);\n\t\tspin_unlock_irqrestore(&ha->lock, flags);\n\t}\n}\n\nvoid sas_discover_event(struct asd_sas_port *port, enum discover_event ev)\n{\n\tstruct sas_discovery *disc;\n\n\tif (!port)\n\t\treturn;\n\tdisc = &port->disc;\n\n\tBUG_ON(ev >= DISC_NUM_EVENTS);\n\n\tsas_chain_event(ev, &disc->pending, &disc->disc_work[ev].work, port->ha);\n}\n\n \nvoid sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t};\n\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}