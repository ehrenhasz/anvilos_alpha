{
  "module_name": "sas_port.c",
  "hash_id": "936ade7273e99fa40fc336168534b5e848b1a32af60d8b6e927713c89452a2c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_port.c",
  "human_readable_source": "\n \n\n#include \"sas_internal.h\"\n\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"scsi_sas_internal.h\"\n\nstatic bool phy_is_wideport_member(struct asd_sas_port *port, struct asd_sas_phy *phy)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\n\tif (memcmp(port->attached_sas_addr, phy->attached_sas_addr,\n\t\t   SAS_ADDR_SIZE) != 0 || (sas_ha->strict_wide_ports &&\n\t     memcmp(port->sas_addr, phy->sas_addr, SAS_ADDR_SIZE) != 0))\n\t\treturn false;\n\treturn true;\n}\n\nstatic void sas_resume_port(struct asd_sas_phy *phy)\n{\n\tstruct domain_device *dev, *n;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *si = to_sas_internal(sas_ha->shost->transportt);\n\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\n\tif (port->suspended)\n\t\tport->suspended = 0;\n\telse {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry_safe(dev, n, &port->dev_list, dev_list_node) {\n\t\tint i, rc;\n\n\t\trc = sas_notify_lldd_dev_found(dev);\n\t\tif (rc) {\n\t\t\tsas_unregister_dev(port, dev);\n\t\t\tsas_destruct_devices(port);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_is_expander(dev->dev_type)) {\n\t\t\tdev->ex_dev.ex_change_count = -1;\n\t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {\n\t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\n\n\t\t\t\tphy->phy_change_count = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tsas_discover_event(port, DISCE_RESUME);\n}\n\nstatic void sas_form_port_add_phy(struct asd_sas_port *port,\n\t\t\t\t  struct asd_sas_phy *phy, bool wideport)\n{\n\tlist_add_tail(&phy->port_phy_el, &port->phy_list);\n\tsas_phy_set_target(phy, port->port_dev);\n\tphy->port = port;\n\tport->num_phys++;\n\tport->phy_mask |= (1U << phy->id);\n\n\tif (wideport)\n\t\tpr_debug(\"phy%d matched wide port%d\\n\", phy->id,\n\t\t\t port->id);\n\telse\n\t\tmemcpy(port->sas_addr, phy->sas_addr, SAS_ADDR_SIZE);\n\n\tif (*(u64 *)port->attached_sas_addr == 0) {\n\t\tmemcpy(port->attached_sas_addr, phy->attached_sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tport->iproto = phy->iproto;\n\t\tport->tproto = phy->tproto;\n\t\tport->oob_mode = phy->oob_mode;\n\t\tport->linkrate = phy->linkrate;\n\t} else {\n\t\tport->linkrate = max(port->linkrate, phy->linkrate);\n\t}\n}\n\n \nstatic void sas_form_port(struct asd_sas_phy *phy)\n{\n\tint i;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct domain_device *port_dev = NULL;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->shost->transportt);\n\tunsigned long flags;\n\n\tif (port) {\n\t\tif (!phy_is_wideport_member(port, phy))\n\t\t\tsas_deform_port(phy, 0);\n\t\telse if (phy->suspended) {\n\t\t\tphy->suspended = 0;\n\t\t\tsas_resume_port(phy);\n\n\t\t\t \n\t\t\twake_up(&sas_ha->eh_wait_q);\n\t\t\treturn;\n\t\t} else {\n\t\t\tpr_info(\"%s: phy%d belongs to port%d already(%d)!\\n\",\n\t\t\t\t__func__, phy->id, phy->port->id,\n\t\t\t\tphy->port->num_phys);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tport = sas_ha->sas_port[i];\n\t\tspin_lock(&port->phy_list_lock);\n\t\tif (*(u64 *) port->sas_addr &&\n\t\t    phy_is_wideport_member(port, phy) && port->num_phys > 0) {\n\t\t\t \n\t\t\tport_dev = port->port_dev;\n\t\t\tsas_form_port_add_phy(port, phy, true);\n\t\t\tspin_unlock(&port->phy_list_lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&port->phy_list_lock);\n\t}\n\t \n\tif (i == sas_ha->num_phys) {\n\t\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\t\tport = sas_ha->sas_port[i];\n\t\t\tspin_lock(&port->phy_list_lock);\n\t\t\tif (*(u64 *)port->sas_addr == 0\n\t\t\t    && port->num_phys == 0) {\n\t\t\t\tport_dev = port->port_dev;\n\t\t\t\tsas_form_port_add_phy(port, phy, false);\n\t\t\t\tspin_unlock(&port->phy_list_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&port->phy_list_lock);\n\t\t}\n\n\t\tif (i >= sas_ha->num_phys) {\n\t\t\tpr_err(\"%s: couldn't find a free port, bug?\\n\",\n\t\t\t       __func__);\n\t\t\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\n\tif (!port->port) {\n\t\tport->port = sas_port_alloc(phy->phy->dev.parent, port->id);\n\t\tBUG_ON(!port->port);\n\t\tsas_port_add(port->port);\n\t}\n\tsas_port_add_phy(port->port, phy->phy);\n\n\tpr_debug(\"%s added to %s, phy_mask:0x%x (%016llx)\\n\",\n\t\t dev_name(&phy->phy->dev), dev_name(&port->port->dev),\n\t\t port->phy_mask,\n\t\t SAS_ADDR(port->attached_sas_addr));\n\n\tif (port_dev)\n\t\tport_dev->pathways = port->num_phys;\n\n\t \n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\n\tsas_discover_event(phy->port, DISCE_DISCOVER_DOMAIN);\n\t \n\tif (port_dev && dev_is_expander(port_dev->dev_type)) {\n\t\tstruct expander_device *ex_dev = &port_dev->ex_dev;\n\n\t\tex_dev->ex_change_count = -1;\n\t\tsas_discover_event(port, DISCE_REVALIDATE_DOMAIN);\n\t}\n\tflush_workqueue(sas_ha->disco_q);\n}\n\n \nvoid sas_deform_port(struct asd_sas_phy *phy, int gone)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->shost->transportt);\n\tstruct domain_device *dev;\n\tunsigned long flags;\n\n\tif (!port)\n\t\treturn;\t\t   \n\n\tdev = port->port_dev;\n\tif (dev)\n\t\tdev->pathways--;\n\n\tif (port->num_phys == 1) {\n\t\tsas_unregister_domain_devices(port, gone);\n\t\tsas_destruct_devices(port);\n\t\tsas_port_delete(port->port);\n\t\tport->port = NULL;\n\t} else {\n\t\tsas_port_delete_phy(port->port, phy->phy);\n\t\tsas_device_set_phy(dev, port->port);\n\t}\n\n\tif (si->dft->lldd_port_deformed)\n\t\tsi->dft->lldd_port_deformed(phy);\n\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tspin_lock(&port->phy_list_lock);\n\n\tlist_del_init(&phy->port_phy_el);\n\tsas_phy_set_target(phy, NULL);\n\tphy->port = NULL;\n\tport->num_phys--;\n\tport->phy_mask &= ~(1U << phy->id);\n\n\tif (port->num_phys == 0) {\n\t\tINIT_LIST_HEAD(&port->phy_list);\n\t\tmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tport->iproto = 0;\n\t\tport->tproto = 0;\n\t\tport->oob_mode = 0;\n\t\tport->phy_mask = 0;\n\t}\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\n\t \n\tif (port->port && dev && dev_is_expander(dev->dev_type)) {\n\t\tstruct expander_device *ex_dev = &dev->ex_dev;\n\n\t\tex_dev->ex_change_count = -1;\n\t\tsas_discover_event(port, DISCE_REVALIDATE_DOMAIN);\n\t}\n\tflush_workqueue(sas_ha->disco_q);\n\n\treturn;\n}\n\n \n\nvoid sas_porte_bytes_dmaed(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_form_port(phy);\n}\n\nvoid sas_porte_broadcast_rcvd(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\tunsigned long flags;\n\tu32 prim;\n\n\tspin_lock_irqsave(&phy->sas_prim_lock, flags);\n\tprim = phy->sas_prim;\n\tspin_unlock_irqrestore(&phy->sas_prim_lock, flags);\n\n\tpr_debug(\"broadcast received: %d\\n\", prim);\n\tsas_discover_event(phy->port, DISCE_REVALIDATE_DOMAIN);\n\n\tif (phy->port)\n\t\tflush_workqueue(phy->port->ha->disco_q);\n}\n\nvoid sas_porte_link_reset_err(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\nvoid sas_porte_timer_event(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\nvoid sas_porte_hard_reset(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tsas_deform_port(phy, 1);\n}\n\n \n\nstatic void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tINIT_LIST_HEAD(&port->sas_port_del_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\n\tspin_lock_init(&port->dev_list_lock);\n}\n\nint sas_register_ports(struct sas_ha_struct *sas_ha)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tstruct asd_sas_port *port = sas_ha->sas_port[i];\n\n\t\tsas_init_port(port, sas_ha, i);\n\t\tsas_init_disc(&port->disc, port);\n\t}\n\treturn 0;\n}\n\nvoid sas_unregister_ports(struct sas_ha_struct *sas_ha)\n{\n\tint i;\n\n\tfor (i = 0; i < sas_ha->num_phys; i++)\n\t\tif (sas_ha->sas_phy[i]->port)\n\t\t\tsas_deform_port(sas_ha->sas_phy[i], 0);\n\n}\n\nconst work_func_t sas_port_event_fns[PORT_NUM_EVENTS] = {\n\t[PORTE_BYTES_DMAED] = sas_porte_bytes_dmaed,\n\t[PORTE_BROADCAST_RCVD] = sas_porte_broadcast_rcvd,\n\t[PORTE_LINK_RESET_ERR] = sas_porte_link_reset_err,\n\t[PORTE_TIMER_EVENT] = sas_porte_timer_event,\n\t[PORTE_HARD_RESET] = sas_porte_hard_reset,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}