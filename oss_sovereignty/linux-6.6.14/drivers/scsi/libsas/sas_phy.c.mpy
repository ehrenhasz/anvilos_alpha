{
  "module_name": "sas_phy.c",
  "hash_id": "3e2942f8f236fe60f5d8e1386d992a2750eef794ab95f46e15ff0d12c4306c9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libsas/sas_phy.c",
  "human_readable_source": "\n \n\n#include \"sas_internal.h\"\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_sas.h>\n#include \"scsi_sas_internal.h\"\n\n \n\nstatic void sas_phye_loss_of_signal(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tphy->error = 0;\n\tsas_deform_port(phy, 1);\n}\n\nstatic void sas_phye_oob_done(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\tphy->error = 0;\n}\n\nstatic void sas_phye_oob_error(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\tsas_deform_port(phy, 1);\n\n\tif (!port && phy->enabled && i->dft->lldd_control_phy) {\n\t\tphy->error++;\n\t\tswitch (phy->error) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\ti->dft->lldd_control_phy(phy, PHY_FUNC_HARD_RESET,\n\t\t\t\t\t\t NULL);\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tphy->error = 0;\n\t\t\tphy->enabled = 0;\n\t\t\ti->dft->lldd_control_phy(phy, PHY_FUNC_DISABLE, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void sas_phye_spinup_hold(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\tphy->error = 0;\n\ti->dft->lldd_control_phy(phy, PHY_FUNC_RELEASE_SPINUP_HOLD, NULL);\n}\n\nstatic void sas_phye_resume_timeout(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\n\t \n\tif (!phy->suspended) {\n\t\tdev_info(&phy->phy->dev, \"resume timeout cancelled\\n\");\n\t\treturn;\n\t}\n\n\tphy->error = 0;\n\tphy->suspended = 0;\n\tsas_deform_port(phy, 1);\n}\n\n\nstatic void sas_phye_shutdown(struct work_struct *work)\n{\n\tstruct asd_sas_event *ev = to_asd_sas_event(work);\n\tstruct asd_sas_phy *phy = ev->phy;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *i =\n\t\tto_sas_internal(sas_ha->shost->transportt);\n\n\tif (phy->enabled) {\n\t\tint ret;\n\n\t\tphy->error = 0;\n\t\tphy->enabled = 0;\n\t\tret = i->dft->lldd_control_phy(phy, PHY_FUNC_DISABLE, NULL);\n\t\tif (ret)\n\t\t\tpr_notice(\"lldd disable phy%d returned %d\\n\", phy->id,\n\t\t\t\t  ret);\n\t} else\n\t\tpr_notice(\"phy%d is not enabled, cannot shutdown\\n\", phy->id);\n\tphy->in_shutdown = 0;\n}\n\n \n\nint sas_register_phys(struct sas_ha_struct *sas_ha)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < sas_ha->num_phys; i++) {\n\t\tstruct asd_sas_phy *phy = sas_ha->sas_phy[i];\n\n\t\tphy->error = 0;\n\t\tatomic_set(&phy->event_nr, 0);\n\t\tINIT_LIST_HEAD(&phy->port_phy_el);\n\n\t\tphy->port = NULL;\n\t\tphy->ha = sas_ha;\n\t\tspin_lock_init(&phy->frame_rcvd_lock);\n\t\tspin_lock_init(&phy->sas_prim_lock);\n\t\tphy->frame_rcvd_size = 0;\n\n\t\tphy->phy = sas_phy_alloc(&sas_ha->shost->shost_gendev, i);\n\t\tif (!phy->phy)\n\t\t\treturn -ENOMEM;\n\n\t\tphy->phy->identify.initiator_port_protocols =\n\t\t\tphy->iproto;\n\t\tphy->phy->identify.target_port_protocols = phy->tproto;\n\t\tphy->phy->identify.sas_address = SAS_ADDR(sas_ha->sas_addr);\n\t\tphy->phy->identify.phy_identifier = i;\n\t\tphy->phy->minimum_linkrate_hw = SAS_LINK_RATE_UNKNOWN;\n\t\tphy->phy->maximum_linkrate_hw = SAS_LINK_RATE_UNKNOWN;\n\t\tphy->phy->minimum_linkrate = SAS_LINK_RATE_UNKNOWN;\n\t\tphy->phy->maximum_linkrate = SAS_LINK_RATE_UNKNOWN;\n\t\tphy->phy->negotiated_linkrate = SAS_LINK_RATE_UNKNOWN;\n\n\t\tsas_phy_add(phy->phy);\n\t}\n\n\treturn 0;\n}\n\nconst work_func_t sas_phy_event_fns[PHY_NUM_EVENTS] = {\n\t[PHYE_LOSS_OF_SIGNAL] = sas_phye_loss_of_signal,\n\t[PHYE_OOB_DONE] = sas_phye_oob_done,\n\t[PHYE_OOB_ERROR] = sas_phye_oob_error,\n\t[PHYE_SPINUP_HOLD] = sas_phye_spinup_hold,\n\t[PHYE_RESUME_TIMEOUT] = sas_phye_resume_timeout,\n\t[PHYE_SHUTDOWN] = sas_phye_shutdown,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}