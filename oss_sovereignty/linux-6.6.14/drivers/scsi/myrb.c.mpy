{
  "module_name": "myrb.c",
  "hash_id": "f3e64976429c30aaf8f2c4029675557fafe2a8635c2171b3142446a03f7bda11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/myrb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/raid_class.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include \"myrb.h\"\n\nstatic struct raid_template *myrb_raid_template;\n\nstatic void myrb_monitor(struct work_struct *work);\nstatic inline void myrb_translate_devstate(void *DeviceState);\n\nstatic inline int myrb_logical_channel(struct Scsi_Host *shost)\n{\n\treturn shost->max_channel - 1;\n}\n\nstatic struct myrb_devstate_name_entry {\n\tenum myrb_devstate state;\n\tconst char *name;\n} myrb_devstate_name_list[] = {\n\t{ MYRB_DEVICE_DEAD, \"Dead\" },\n\t{ MYRB_DEVICE_WO, \"WriteOnly\" },\n\t{ MYRB_DEVICE_ONLINE, \"Online\" },\n\t{ MYRB_DEVICE_CRITICAL, \"Critical\" },\n\t{ MYRB_DEVICE_STANDBY, \"Standby\" },\n\t{ MYRB_DEVICE_OFFLINE, \"Offline\" },\n};\n\nstatic const char *myrb_devstate_name(enum myrb_devstate state)\n{\n\tstruct myrb_devstate_name_entry *entry = myrb_devstate_name_list;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(myrb_devstate_name_list); i++) {\n\t\tif (entry[i].state == state)\n\t\t\treturn entry[i].name;\n\t}\n\treturn \"Unknown\";\n}\n\nstatic struct myrb_raidlevel_name_entry {\n\tenum myrb_raidlevel level;\n\tconst char *name;\n} myrb_raidlevel_name_list[] = {\n\t{ MYRB_RAID_LEVEL0, \"RAID0\" },\n\t{ MYRB_RAID_LEVEL1, \"RAID1\" },\n\t{ MYRB_RAID_LEVEL3, \"RAID3\" },\n\t{ MYRB_RAID_LEVEL5, \"RAID5\" },\n\t{ MYRB_RAID_LEVEL6, \"RAID6\" },\n\t{ MYRB_RAID_JBOD, \"JBOD\" },\n};\n\nstatic const char *myrb_raidlevel_name(enum myrb_raidlevel level)\n{\n\tstruct myrb_raidlevel_name_entry *entry = myrb_raidlevel_name_list;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(myrb_raidlevel_name_list); i++) {\n\t\tif (entry[i].level == level)\n\t\t\treturn entry[i].name;\n\t}\n\treturn NULL;\n}\n\n \nstatic bool myrb_create_mempools(struct pci_dev *pdev, struct myrb_hba *cb)\n{\n\tsize_t elem_size, elem_align;\n\n\telem_align = sizeof(struct myrb_sge);\n\telem_size = cb->host->sg_tablesize * elem_align;\n\tcb->sg_pool = dma_pool_create(\"myrb_sg\", &pdev->dev,\n\t\t\t\t      elem_size, elem_align, 0);\n\tif (cb->sg_pool == NULL) {\n\t\tshost_printk(KERN_ERR, cb->host,\n\t\t\t     \"Failed to allocate SG pool\\n\");\n\t\treturn false;\n\t}\n\n\tcb->dcdb_pool = dma_pool_create(\"myrb_dcdb\", &pdev->dev,\n\t\t\t\t       sizeof(struct myrb_dcdb),\n\t\t\t\t       sizeof(unsigned int), 0);\n\tif (!cb->dcdb_pool) {\n\t\tdma_pool_destroy(cb->sg_pool);\n\t\tcb->sg_pool = NULL;\n\t\tshost_printk(KERN_ERR, cb->host,\n\t\t\t     \"Failed to allocate DCDB pool\\n\");\n\t\treturn false;\n\t}\n\n\tsnprintf(cb->work_q_name, sizeof(cb->work_q_name),\n\t\t \"myrb_wq_%d\", cb->host->host_no);\n\tcb->work_q = create_singlethread_workqueue(cb->work_q_name);\n\tif (!cb->work_q) {\n\t\tdma_pool_destroy(cb->dcdb_pool);\n\t\tcb->dcdb_pool = NULL;\n\t\tdma_pool_destroy(cb->sg_pool);\n\t\tcb->sg_pool = NULL;\n\t\tshost_printk(KERN_ERR, cb->host,\n\t\t\t     \"Failed to create workqueue\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tINIT_DELAYED_WORK(&cb->monitor_work, myrb_monitor);\n\tqueue_delayed_work(cb->work_q, &cb->monitor_work, 1);\n\n\treturn true;\n}\n\n \nstatic void myrb_destroy_mempools(struct myrb_hba *cb)\n{\n\tcancel_delayed_work_sync(&cb->monitor_work);\n\tdestroy_workqueue(cb->work_q);\n\n\tdma_pool_destroy(cb->sg_pool);\n\tdma_pool_destroy(cb->dcdb_pool);\n}\n\n \nstatic inline void myrb_reset_cmd(struct myrb_cmdblk *cmd_blk)\n{\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\n\tmemset(mbox, 0, sizeof(union myrb_cmd_mbox));\n\tcmd_blk->status = 0;\n}\n\n \nstatic void myrb_qcmd(struct myrb_hba *cb, struct myrb_cmdblk *cmd_blk)\n{\n\tvoid __iomem *base = cb->io_base;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunion myrb_cmd_mbox *next_mbox = cb->next_cmd_mbox;\n\n\tcb->write_cmd_mbox(next_mbox, mbox);\n\tif (cb->prev_cmd_mbox1->words[0] == 0 ||\n\t    cb->prev_cmd_mbox2->words[0] == 0)\n\t\tcb->get_cmd_mbox(base);\n\tcb->prev_cmd_mbox2 = cb->prev_cmd_mbox1;\n\tcb->prev_cmd_mbox1 = next_mbox;\n\tif (++next_mbox > cb->last_cmd_mbox)\n\t\tnext_mbox = cb->first_cmd_mbox;\n\tcb->next_cmd_mbox = next_mbox;\n}\n\n \nstatic unsigned short myrb_exec_cmd(struct myrb_hba *cb,\n\t\tstruct myrb_cmdblk *cmd_blk)\n{\n\tDECLARE_COMPLETION_ONSTACK(cmpl);\n\tunsigned long flags;\n\n\tcmd_blk->completion = &cmpl;\n\n\tspin_lock_irqsave(&cb->queue_lock, flags);\n\tcb->qcmd(cb, cmd_blk);\n\tspin_unlock_irqrestore(&cb->queue_lock, flags);\n\n\twait_for_completion(&cmpl);\n\treturn cmd_blk->status;\n}\n\n \nstatic unsigned short myrb_exec_type3(struct myrb_hba *cb,\n\t\tenum myrb_cmd_opcode op, dma_addr_t addr)\n{\n\tstruct myrb_cmdblk *cmd_blk = &cb->dcmd_blk;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunsigned short status;\n\n\tmutex_lock(&cb->dcmd_mutex);\n\tmyrb_reset_cmd(cmd_blk);\n\tmbox->type3.id = MYRB_DCMD_TAG;\n\tmbox->type3.opcode = op;\n\tmbox->type3.addr = addr;\n\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\tmutex_unlock(&cb->dcmd_mutex);\n\treturn status;\n}\n\n \nstatic unsigned short myrb_exec_type3D(struct myrb_hba *cb,\n\t\tenum myrb_cmd_opcode op, struct scsi_device *sdev,\n\t\tstruct myrb_pdev_state *pdev_info)\n{\n\tstruct myrb_cmdblk *cmd_blk = &cb->dcmd_blk;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunsigned short status;\n\tdma_addr_t pdev_info_addr;\n\n\tpdev_info_addr = dma_map_single(&cb->pdev->dev, pdev_info,\n\t\t\t\t\tsizeof(struct myrb_pdev_state),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\tif (dma_mapping_error(&cb->pdev->dev, pdev_info_addr))\n\t\treturn MYRB_STATUS_SUBSYS_FAILED;\n\n\tmutex_lock(&cb->dcmd_mutex);\n\tmyrb_reset_cmd(cmd_blk);\n\tmbox->type3D.id = MYRB_DCMD_TAG;\n\tmbox->type3D.opcode = op;\n\tmbox->type3D.channel = sdev->channel;\n\tmbox->type3D.target = sdev->id;\n\tmbox->type3D.addr = pdev_info_addr;\n\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\tmutex_unlock(&cb->dcmd_mutex);\n\tdma_unmap_single(&cb->pdev->dev, pdev_info_addr,\n\t\t\t sizeof(struct myrb_pdev_state), DMA_FROM_DEVICE);\n\tif (status == MYRB_STATUS_SUCCESS &&\n\t    mbox->type3D.opcode == MYRB_CMD_GET_DEVICE_STATE_OLD)\n\t\tmyrb_translate_devstate(pdev_info);\n\n\treturn status;\n}\n\nstatic char *myrb_event_msg[] = {\n\t\"killed because write recovery failed\",\n\t\"killed because of SCSI bus reset failure\",\n\t\"killed because of double check condition\",\n\t\"killed because it was removed\",\n\t\"killed because of gross error on SCSI chip\",\n\t\"killed because of bad tag returned from drive\",\n\t\"killed because of timeout on SCSI command\",\n\t\"killed because of reset SCSI command issued from system\",\n\t\"killed because busy or parity error count exceeded limit\",\n\t\"killed because of 'kill drive' command from system\",\n\t\"killed because of selection timeout\",\n\t\"killed due to SCSI phase sequence error\",\n\t\"killed due to unknown status\",\n};\n\n \nstatic void myrb_get_event(struct myrb_hba *cb, unsigned int event)\n{\n\tstruct myrb_cmdblk *cmd_blk = &cb->mcmd_blk;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tstruct myrb_log_entry *ev_buf;\n\tdma_addr_t ev_addr;\n\tunsigned short status;\n\n\tev_buf = dma_alloc_coherent(&cb->pdev->dev,\n\t\t\t\t    sizeof(struct myrb_log_entry),\n\t\t\t\t    &ev_addr, GFP_KERNEL);\n\tif (!ev_buf)\n\t\treturn;\n\n\tmyrb_reset_cmd(cmd_blk);\n\tmbox->type3E.id = MYRB_MCMD_TAG;\n\tmbox->type3E.opcode = MYRB_CMD_EVENT_LOG_OPERATION;\n\tmbox->type3E.optype = DAC960_V1_GetEventLogEntry;\n\tmbox->type3E.opqual = 1;\n\tmbox->type3E.ev_seq = event;\n\tmbox->type3E.addr = ev_addr;\n\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\tif (status != MYRB_STATUS_SUCCESS)\n\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t     \"Failed to get event log %d, status %04x\\n\",\n\t\t\t     event, status);\n\n\telse if (ev_buf->seq_num == event) {\n\t\tstruct scsi_sense_hdr sshdr;\n\n\t\tmemset(&sshdr, 0, sizeof(sshdr));\n\t\tscsi_normalize_sense(ev_buf->sense, 32, &sshdr);\n\n\t\tif (sshdr.sense_key == VENDOR_SPECIFIC &&\n\t\t    sshdr.asc == 0x80 &&\n\t\t    sshdr.ascq < ARRAY_SIZE(myrb_event_msg))\n\t\t\tshost_printk(KERN_CRIT, cb->host,\n\t\t\t\t     \"Physical drive %d:%d: %s\\n\",\n\t\t\t\t     ev_buf->channel, ev_buf->target,\n\t\t\t\t     myrb_event_msg[sshdr.ascq]);\n\t\telse\n\t\t\tshost_printk(KERN_CRIT, cb->host,\n\t\t\t\t     \"Physical drive %d:%d: Sense: %X/%02X/%02X\\n\",\n\t\t\t\t     ev_buf->channel, ev_buf->target,\n\t\t\t\t     sshdr.sense_key, sshdr.asc, sshdr.ascq);\n\t}\n\n\tdma_free_coherent(&cb->pdev->dev, sizeof(struct myrb_log_entry),\n\t\t\t  ev_buf, ev_addr);\n}\n\n \nstatic void myrb_get_errtable(struct myrb_hba *cb)\n{\n\tstruct myrb_cmdblk *cmd_blk = &cb->mcmd_blk;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunsigned short status;\n\tstruct myrb_error_entry old_table[MYRB_MAX_CHANNELS * MYRB_MAX_TARGETS];\n\n\tmemcpy(&old_table, cb->err_table, sizeof(old_table));\n\n\tmyrb_reset_cmd(cmd_blk);\n\tmbox->type3.id = MYRB_MCMD_TAG;\n\tmbox->type3.opcode = MYRB_CMD_GET_ERROR_TABLE;\n\tmbox->type3.addr = cb->err_table_addr;\n\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\tif (status == MYRB_STATUS_SUCCESS) {\n\t\tstruct myrb_error_entry *table = cb->err_table;\n\t\tstruct myrb_error_entry *new, *old;\n\t\tsize_t err_table_offset;\n\t\tstruct scsi_device *sdev;\n\n\t\tshost_for_each_device(sdev, cb->host) {\n\t\t\tif (sdev->channel >= myrb_logical_channel(cb->host))\n\t\t\t\tcontinue;\n\t\t\terr_table_offset = sdev->channel * MYRB_MAX_TARGETS\n\t\t\t\t+ sdev->id;\n\t\t\tnew = table + err_table_offset;\n\t\t\told = &old_table[err_table_offset];\n\t\t\tif (new->parity_err == old->parity_err &&\n\t\t\t    new->soft_err == old->soft_err &&\n\t\t\t    new->hard_err == old->hard_err &&\n\t\t\t    new->misc_err == old->misc_err)\n\t\t\t\tcontinue;\n\t\t\tsdev_printk(KERN_CRIT, sdev,\n\t\t\t\t    \"Errors: Parity = %d, Soft = %d, Hard = %d, Misc = %d\\n\",\n\t\t\t\t    new->parity_err, new->soft_err,\n\t\t\t\t    new->hard_err, new->misc_err);\n\t\t}\n\t}\n}\n\n \nstatic unsigned short myrb_get_ldev_info(struct myrb_hba *cb)\n{\n\tunsigned short status;\n\tint ldev_num, ldev_cnt = cb->enquiry->ldev_count;\n\tstruct Scsi_Host *shost = cb->host;\n\n\tstatus = myrb_exec_type3(cb, MYRB_CMD_GET_LDEV_INFO,\n\t\t\t\t cb->ldev_info_addr);\n\tif (status != MYRB_STATUS_SUCCESS)\n\t\treturn status;\n\n\tfor (ldev_num = 0; ldev_num < ldev_cnt; ldev_num++) {\n\t\tstruct myrb_ldev_info *old = NULL;\n\t\tstruct myrb_ldev_info *new = cb->ldev_info_buf + ldev_num;\n\t\tstruct scsi_device *sdev;\n\n\t\tsdev = scsi_device_lookup(shost, myrb_logical_channel(shost),\n\t\t\t\t\t  ldev_num, 0);\n\t\tif (!sdev) {\n\t\t\tif (new->state == MYRB_DEVICE_OFFLINE)\n\t\t\t\tcontinue;\n\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t     \"Adding Logical Drive %d in state %s\\n\",\n\t\t\t\t     ldev_num, myrb_devstate_name(new->state));\n\t\t\tscsi_add_device(shost, myrb_logical_channel(shost),\n\t\t\t\t\tldev_num, 0);\n\t\t\tcontinue;\n\t\t}\n\t\told = sdev->hostdata;\n\t\tif (new->state != old->state)\n\t\t\tshost_printk(KERN_INFO, shost,\n\t\t\t\t     \"Logical Drive %d is now %s\\n\",\n\t\t\t\t     ldev_num, myrb_devstate_name(new->state));\n\t\tif (new->wb_enabled != old->wb_enabled)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Logical Drive is now WRITE %s\\n\",\n\t\t\t\t    (new->wb_enabled ? \"BACK\" : \"THRU\"));\n\t\tmemcpy(old, new, sizeof(*new));\n\t\tscsi_device_put(sdev);\n\t}\n\treturn status;\n}\n\n \nstatic unsigned short myrb_get_rbld_progress(struct myrb_hba *cb,\n\t\tstruct myrb_rbld_progress *rbld)\n{\n\tstruct myrb_cmdblk *cmd_blk = &cb->mcmd_blk;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tstruct myrb_rbld_progress *rbld_buf;\n\tdma_addr_t rbld_addr;\n\tunsigned short status;\n\n\trbld_buf = dma_alloc_coherent(&cb->pdev->dev,\n\t\t\t\t      sizeof(struct myrb_rbld_progress),\n\t\t\t\t      &rbld_addr, GFP_KERNEL);\n\tif (!rbld_buf)\n\t\treturn MYRB_STATUS_RBLD_NOT_CHECKED;\n\n\tmyrb_reset_cmd(cmd_blk);\n\tmbox->type3.id = MYRB_MCMD_TAG;\n\tmbox->type3.opcode = MYRB_CMD_GET_REBUILD_PROGRESS;\n\tmbox->type3.addr = rbld_addr;\n\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\tif (rbld)\n\t\tmemcpy(rbld, rbld_buf, sizeof(struct myrb_rbld_progress));\n\tdma_free_coherent(&cb->pdev->dev, sizeof(struct myrb_rbld_progress),\n\t\t\t  rbld_buf, rbld_addr);\n\treturn status;\n}\n\n \nstatic void myrb_update_rbld_progress(struct myrb_hba *cb)\n{\n\tstruct myrb_rbld_progress rbld_buf;\n\tunsigned short status;\n\n\tstatus = myrb_get_rbld_progress(cb, &rbld_buf);\n\tif (status == MYRB_NO_STDBY_RBLD_OR_CHECK_IN_PROGRESS &&\n\t    cb->last_rbld_status == MYRB_STATUS_SUCCESS)\n\t\tstatus = MYRB_STATUS_RBLD_SUCCESS;\n\tif (status != MYRB_NO_STDBY_RBLD_OR_CHECK_IN_PROGRESS) {\n\t\tunsigned int blocks_done =\n\t\t\trbld_buf.ldev_size - rbld_buf.blocks_left;\n\t\tstruct scsi_device *sdev;\n\n\t\tsdev = scsi_device_lookup(cb->host,\n\t\t\t\t\t  myrb_logical_channel(cb->host),\n\t\t\t\t\t  rbld_buf.ldev_num, 0);\n\t\tif (!sdev)\n\t\t\treturn;\n\n\t\tswitch (status) {\n\t\tcase MYRB_STATUS_SUCCESS:\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Rebuild in Progress, %d%% completed\\n\",\n\t\t\t\t    (100 * (blocks_done >> 7))\n\t\t\t\t    / (rbld_buf.ldev_size >> 7));\n\t\t\tbreak;\n\t\tcase MYRB_STATUS_RBLD_FAILED_LDEV_FAILURE:\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Rebuild Failed due to Logical Drive Failure\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_STATUS_RBLD_FAILED_BADBLOCKS:\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Rebuild Failed due to Bad Blocks on Other Drives\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_STATUS_RBLD_FAILED_NEW_DRIVE_FAILED:\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Rebuild Failed due to Failure of Drive Being Rebuilt\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_STATUS_RBLD_SUCCESS:\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Rebuild Completed Successfully\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_STATUS_RBLD_SUCCESS_TERMINATED:\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t     \"Rebuild Successfully Terminated\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tscsi_device_put(sdev);\n\t}\n\tcb->last_rbld_status = status;\n}\n\n \nstatic void myrb_get_cc_progress(struct myrb_hba *cb)\n{\n\tstruct myrb_cmdblk *cmd_blk = &cb->mcmd_blk;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tstruct myrb_rbld_progress *rbld_buf;\n\tdma_addr_t rbld_addr;\n\tunsigned short status;\n\n\trbld_buf = dma_alloc_coherent(&cb->pdev->dev,\n\t\t\t\t      sizeof(struct myrb_rbld_progress),\n\t\t\t\t      &rbld_addr, GFP_KERNEL);\n\tif (!rbld_buf) {\n\t\tcb->need_cc_status = true;\n\t\treturn;\n\t}\n\tmyrb_reset_cmd(cmd_blk);\n\tmbox->type3.id = MYRB_MCMD_TAG;\n\tmbox->type3.opcode = MYRB_CMD_REBUILD_STAT;\n\tmbox->type3.addr = rbld_addr;\n\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\tif (status == MYRB_STATUS_SUCCESS) {\n\t\tunsigned int ldev_num = rbld_buf->ldev_num;\n\t\tunsigned int ldev_size = rbld_buf->ldev_size;\n\t\tunsigned int blocks_done =\n\t\t\tldev_size - rbld_buf->blocks_left;\n\t\tstruct scsi_device *sdev;\n\n\t\tsdev = scsi_device_lookup(cb->host,\n\t\t\t\t\t  myrb_logical_channel(cb->host),\n\t\t\t\t\t  ldev_num, 0);\n\t\tif (sdev) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Consistency Check in Progress: %d%% completed\\n\",\n\t\t\t\t    (100 * (blocks_done >> 7))\n\t\t\t\t    / (ldev_size >> 7));\n\t\t\tscsi_device_put(sdev);\n\t\t}\n\t}\n\tdma_free_coherent(&cb->pdev->dev, sizeof(struct myrb_rbld_progress),\n\t\t\t  rbld_buf, rbld_addr);\n}\n\n \nstatic void myrb_bgi_control(struct myrb_hba *cb)\n{\n\tstruct myrb_cmdblk *cmd_blk = &cb->mcmd_blk;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tstruct myrb_bgi_status *bgi, *last_bgi;\n\tdma_addr_t bgi_addr;\n\tstruct scsi_device *sdev = NULL;\n\tunsigned short status;\n\n\tbgi = dma_alloc_coherent(&cb->pdev->dev, sizeof(struct myrb_bgi_status),\n\t\t\t\t &bgi_addr, GFP_KERNEL);\n\tif (!bgi) {\n\t\tshost_printk(KERN_ERR, cb->host,\n\t\t\t     \"Failed to allocate bgi memory\\n\");\n\t\treturn;\n\t}\n\tmyrb_reset_cmd(cmd_blk);\n\tmbox->type3B.id = MYRB_DCMD_TAG;\n\tmbox->type3B.opcode = MYRB_CMD_BGI_CONTROL;\n\tmbox->type3B.optype = 0x20;\n\tmbox->type3B.addr = bgi_addr;\n\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\tlast_bgi = &cb->bgi_status;\n\tsdev = scsi_device_lookup(cb->host,\n\t\t\t\t  myrb_logical_channel(cb->host),\n\t\t\t\t  bgi->ldev_num, 0);\n\tswitch (status) {\n\tcase MYRB_STATUS_SUCCESS:\n\t\tswitch (bgi->status) {\n\t\tcase MYRB_BGI_INVALID:\n\t\t\tbreak;\n\t\tcase MYRB_BGI_STARTED:\n\t\t\tif (!sdev)\n\t\t\t\tbreak;\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Background Initialization Started\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_BGI_INPROGRESS:\n\t\t\tif (!sdev)\n\t\t\t\tbreak;\n\t\t\tif (bgi->blocks_done == last_bgi->blocks_done &&\n\t\t\t    bgi->ldev_num == last_bgi->ldev_num)\n\t\t\t\tbreak;\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t \"Background Initialization in Progress: %d%% completed\\n\",\n\t\t\t\t (100 * (bgi->blocks_done >> 7))\n\t\t\t\t / (bgi->ldev_size >> 7));\n\t\t\tbreak;\n\t\tcase MYRB_BGI_SUSPENDED:\n\t\t\tif (!sdev)\n\t\t\t\tbreak;\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Background Initialization Suspended\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_BGI_CANCELLED:\n\t\t\tif (!sdev)\n\t\t\t\tbreak;\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Background Initialization Cancelled\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(&cb->bgi_status, bgi, sizeof(struct myrb_bgi_status));\n\t\tbreak;\n\tcase MYRB_STATUS_BGI_SUCCESS:\n\t\tif (sdev && cb->bgi_status.status == MYRB_BGI_INPROGRESS)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Background Initialization Completed Successfully\\n\");\n\t\tcb->bgi_status.status = MYRB_BGI_INVALID;\n\t\tbreak;\n\tcase MYRB_STATUS_BGI_ABORTED:\n\t\tif (sdev && cb->bgi_status.status == MYRB_BGI_INPROGRESS)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Background Initialization Aborted\\n\");\n\t\tfallthrough;\n\tcase MYRB_STATUS_NO_BGI_INPROGRESS:\n\t\tcb->bgi_status.status = MYRB_BGI_INVALID;\n\t\tbreak;\n\t}\n\tif (sdev)\n\t\tscsi_device_put(sdev);\n\tdma_free_coherent(&cb->pdev->dev, sizeof(struct myrb_bgi_status),\n\t\t\t  bgi, bgi_addr);\n}\n\n \nstatic unsigned short myrb_hba_enquiry(struct myrb_hba *cb)\n{\n\tstruct myrb_enquiry old, *new;\n\tunsigned short status;\n\n\tmemcpy(&old, cb->enquiry, sizeof(struct myrb_enquiry));\n\n\tstatus = myrb_exec_type3(cb, MYRB_CMD_ENQUIRY, cb->enquiry_addr);\n\tif (status != MYRB_STATUS_SUCCESS)\n\t\treturn status;\n\n\tnew = cb->enquiry;\n\tif (new->ldev_count > old.ldev_count) {\n\t\tint ldev_num = old.ldev_count - 1;\n\n\t\twhile (++ldev_num < new->ldev_count)\n\t\t\tshost_printk(KERN_CRIT, cb->host,\n\t\t\t\t     \"Logical Drive %d Now Exists\\n\",\n\t\t\t\t     ldev_num);\n\t}\n\tif (new->ldev_count < old.ldev_count) {\n\t\tint ldev_num = new->ldev_count - 1;\n\n\t\twhile (++ldev_num < old.ldev_count)\n\t\t\tshost_printk(KERN_CRIT, cb->host,\n\t\t\t\t     \"Logical Drive %d No Longer Exists\\n\",\n\t\t\t\t     ldev_num);\n\t}\n\tif (new->status.deferred != old.status.deferred)\n\t\tshost_printk(KERN_CRIT, cb->host,\n\t\t\t     \"Deferred Write Error Flag is now %s\\n\",\n\t\t\t     (new->status.deferred ? \"TRUE\" : \"FALSE\"));\n\tif (new->ev_seq != old.ev_seq) {\n\t\tcb->new_ev_seq = new->ev_seq;\n\t\tcb->need_err_info = true;\n\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t     \"Event log %d/%d (%d/%d) available\\n\",\n\t\t\t     cb->old_ev_seq, cb->new_ev_seq,\n\t\t\t     old.ev_seq, new->ev_seq);\n\t}\n\tif ((new->ldev_critical > 0 &&\n\t     new->ldev_critical != old.ldev_critical) ||\n\t    (new->ldev_offline > 0 &&\n\t     new->ldev_offline != old.ldev_offline) ||\n\t    (new->ldev_count != old.ldev_count)) {\n\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t     \"Logical drive count changed (%d/%d/%d)\\n\",\n\t\t\t     new->ldev_critical,\n\t\t\t     new->ldev_offline,\n\t\t\t     new->ldev_count);\n\t\tcb->need_ldev_info = true;\n\t}\n\tif (new->pdev_dead > 0 ||\n\t    new->pdev_dead != old.pdev_dead ||\n\t    time_after_eq(jiffies, cb->secondary_monitor_time\n\t\t\t  + MYRB_SECONDARY_MONITOR_INTERVAL)) {\n\t\tcb->need_bgi_status = cb->bgi_status_supported;\n\t\tcb->secondary_monitor_time = jiffies;\n\t}\n\tif (new->rbld == MYRB_STDBY_RBLD_IN_PROGRESS ||\n\t    new->rbld == MYRB_BG_RBLD_IN_PROGRESS ||\n\t    old.rbld == MYRB_STDBY_RBLD_IN_PROGRESS ||\n\t    old.rbld == MYRB_BG_RBLD_IN_PROGRESS) {\n\t\tcb->need_rbld = true;\n\t\tcb->rbld_first = (new->ldev_critical < old.ldev_critical);\n\t}\n\tif (old.rbld == MYRB_BG_CHECK_IN_PROGRESS)\n\t\tswitch (new->rbld) {\n\t\tcase MYRB_NO_STDBY_RBLD_OR_CHECK_IN_PROGRESS:\n\t\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t\t     \"Consistency Check Completed Successfully\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_STDBY_RBLD_IN_PROGRESS:\n\t\tcase MYRB_BG_RBLD_IN_PROGRESS:\n\t\t\tbreak;\n\t\tcase MYRB_BG_CHECK_IN_PROGRESS:\n\t\t\tcb->need_cc_status = true;\n\t\t\tbreak;\n\t\tcase MYRB_STDBY_RBLD_COMPLETED_WITH_ERROR:\n\t\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t\t     \"Consistency Check Completed with Error\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_BG_RBLD_OR_CHECK_FAILED_DRIVE_FAILED:\n\t\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t\t     \"Consistency Check Failed - Physical Device Failed\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_BG_RBLD_OR_CHECK_FAILED_LDEV_FAILED:\n\t\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t\t     \"Consistency Check Failed - Logical Drive Failed\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_BG_RBLD_OR_CHECK_FAILED_OTHER:\n\t\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t\t     \"Consistency Check Failed - Other Causes\\n\");\n\t\t\tbreak;\n\t\tcase MYRB_BG_RBLD_OR_CHECK_SUCCESS_TERMINATED:\n\t\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t\t     \"Consistency Check Successfully Terminated\\n\");\n\t\t\tbreak;\n\t\t}\n\telse if (new->rbld == MYRB_BG_CHECK_IN_PROGRESS)\n\t\tcb->need_cc_status = true;\n\n\treturn MYRB_STATUS_SUCCESS;\n}\n\n \nstatic unsigned short myrb_set_pdev_state(struct myrb_hba *cb,\n\t\tstruct scsi_device *sdev, enum myrb_devstate state)\n{\n\tstruct myrb_cmdblk *cmd_blk = &cb->dcmd_blk;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tunsigned short status;\n\n\tmutex_lock(&cb->dcmd_mutex);\n\tmbox->type3D.opcode = MYRB_CMD_START_DEVICE;\n\tmbox->type3D.id = MYRB_DCMD_TAG;\n\tmbox->type3D.channel = sdev->channel;\n\tmbox->type3D.target = sdev->id;\n\tmbox->type3D.state = state & 0x1F;\n\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\tmutex_unlock(&cb->dcmd_mutex);\n\n\treturn status;\n}\n\n \nstatic bool myrb_enable_mmio(struct myrb_hba *cb, mbox_mmio_init_t mmio_init_fn)\n{\n\tvoid __iomem *base = cb->io_base;\n\tstruct pci_dev *pdev = cb->pdev;\n\tsize_t err_table_size;\n\tsize_t ldev_info_size;\n\tunion myrb_cmd_mbox *cmd_mbox_mem;\n\tstruct myrb_stat_mbox *stat_mbox_mem;\n\tunion myrb_cmd_mbox mbox;\n\tunsigned short status;\n\n\tmemset(&mbox, 0, sizeof(union myrb_cmd_mbox));\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tdev_err(&pdev->dev, \"DMA mask out of range\\n\");\n\t\treturn false;\n\t}\n\n\tcb->enquiry = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t sizeof(struct myrb_enquiry),\n\t\t\t\t\t &cb->enquiry_addr, GFP_KERNEL);\n\tif (!cb->enquiry)\n\t\treturn false;\n\n\terr_table_size = sizeof(struct myrb_error_entry) *\n\t\tMYRB_MAX_CHANNELS * MYRB_MAX_TARGETS;\n\tcb->err_table = dma_alloc_coherent(&pdev->dev, err_table_size,\n\t\t\t\t\t   &cb->err_table_addr, GFP_KERNEL);\n\tif (!cb->err_table)\n\t\treturn false;\n\n\tldev_info_size = sizeof(struct myrb_ldev_info) * MYRB_MAX_LDEVS;\n\tcb->ldev_info_buf = dma_alloc_coherent(&pdev->dev, ldev_info_size,\n\t\t\t\t\t       &cb->ldev_info_addr, GFP_KERNEL);\n\tif (!cb->ldev_info_buf)\n\t\treturn false;\n\n\t \n\tif (!mmio_init_fn)\n\t\treturn true;\n\n\t \n\tcb->cmd_mbox_size =  MYRB_CMD_MBOX_COUNT * sizeof(union myrb_cmd_mbox);\n\tcb->first_cmd_mbox = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\tcb->cmd_mbox_size,\n\t\t\t\t\t\t&cb->cmd_mbox_addr,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!cb->first_cmd_mbox)\n\t\treturn false;\n\n\tcmd_mbox_mem = cb->first_cmd_mbox;\n\tcmd_mbox_mem += MYRB_CMD_MBOX_COUNT - 1;\n\tcb->last_cmd_mbox = cmd_mbox_mem;\n\tcb->next_cmd_mbox = cb->first_cmd_mbox;\n\tcb->prev_cmd_mbox1 = cb->last_cmd_mbox;\n\tcb->prev_cmd_mbox2 = cb->last_cmd_mbox - 1;\n\n\t \n\tcb->stat_mbox_size = MYRB_STAT_MBOX_COUNT *\n\t    sizeof(struct myrb_stat_mbox);\n\tcb->first_stat_mbox = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t cb->stat_mbox_size,\n\t\t\t\t\t\t &cb->stat_mbox_addr,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!cb->first_stat_mbox)\n\t\treturn false;\n\n\tstat_mbox_mem = cb->first_stat_mbox;\n\tstat_mbox_mem += MYRB_STAT_MBOX_COUNT - 1;\n\tcb->last_stat_mbox = stat_mbox_mem;\n\tcb->next_stat_mbox = cb->first_stat_mbox;\n\n\t \n\tcb->dual_mode_interface = true;\n\tmbox.typeX.opcode = 0x2B;\n\tmbox.typeX.id = 0;\n\tmbox.typeX.opcode2 = 0x14;\n\tmbox.typeX.cmd_mbox_addr = cb->cmd_mbox_addr;\n\tmbox.typeX.stat_mbox_addr = cb->stat_mbox_addr;\n\n\tstatus = mmio_init_fn(pdev, base, &mbox);\n\tif (status != MYRB_STATUS_SUCCESS) {\n\t\tcb->dual_mode_interface = false;\n\t\tmbox.typeX.opcode2 = 0x10;\n\t\tstatus = mmio_init_fn(pdev, base, &mbox);\n\t\tif (status != MYRB_STATUS_SUCCESS) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to enable mailbox, statux %02X\\n\",\n\t\t\t\tstatus);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nstatic int myrb_get_hba_config(struct myrb_hba *cb)\n{\n\tstruct myrb_enquiry2 *enquiry2;\n\tdma_addr_t enquiry2_addr;\n\tstruct myrb_config2 *config2;\n\tdma_addr_t config2_addr;\n\tstruct Scsi_Host *shost = cb->host;\n\tstruct pci_dev *pdev = cb->pdev;\n\tint pchan_max = 0, pchan_cur = 0;\n\tunsigned short status;\n\tint ret = -ENODEV, memsize = 0;\n\n\tenquiry2 = dma_alloc_coherent(&pdev->dev, sizeof(struct myrb_enquiry2),\n\t\t\t\t      &enquiry2_addr, GFP_KERNEL);\n\tif (!enquiry2) {\n\t\tshost_printk(KERN_ERR, cb->host,\n\t\t\t     \"Failed to allocate V1 enquiry2 memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tconfig2 = dma_alloc_coherent(&pdev->dev, sizeof(struct myrb_config2),\n\t\t\t\t     &config2_addr, GFP_KERNEL);\n\tif (!config2) {\n\t\tshost_printk(KERN_ERR, cb->host,\n\t\t\t     \"Failed to allocate V1 config2 memory\\n\");\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct myrb_enquiry2),\n\t\t\t\t  enquiry2, enquiry2_addr);\n\t\treturn -ENOMEM;\n\t}\n\tmutex_lock(&cb->dma_mutex);\n\tstatus = myrb_hba_enquiry(cb);\n\tmutex_unlock(&cb->dma_mutex);\n\tif (status != MYRB_STATUS_SUCCESS) {\n\t\tshost_printk(KERN_WARNING, cb->host,\n\t\t\t     \"Failed it issue V1 Enquiry\\n\");\n\t\tgoto out_free;\n\t}\n\n\tstatus = myrb_exec_type3(cb, MYRB_CMD_ENQUIRY2, enquiry2_addr);\n\tif (status != MYRB_STATUS_SUCCESS) {\n\t\tshost_printk(KERN_WARNING, cb->host,\n\t\t\t     \"Failed to issue V1 Enquiry2\\n\");\n\t\tgoto out_free;\n\t}\n\n\tstatus = myrb_exec_type3(cb, MYRB_CMD_READ_CONFIG2, config2_addr);\n\tif (status != MYRB_STATUS_SUCCESS) {\n\t\tshost_printk(KERN_WARNING, cb->host,\n\t\t\t     \"Failed to issue ReadConfig2\\n\");\n\t\tgoto out_free;\n\t}\n\n\tstatus = myrb_get_ldev_info(cb);\n\tif (status != MYRB_STATUS_SUCCESS) {\n\t\tshost_printk(KERN_WARNING, cb->host,\n\t\t\t     \"Failed to get logical drive information\\n\");\n\t\tgoto out_free;\n\t}\n\n\t \n\tswitch (enquiry2->hw.sub_model) {\n\tcase DAC960_V1_P_PD_PU:\n\t\tif (enquiry2->scsi_cap.bus_speed == MYRB_SCSI_SPEED_ULTRA)\n\t\t\tstrcpy(cb->model_name, \"DAC960PU\");\n\t\telse\n\t\t\tstrcpy(cb->model_name, \"DAC960PD\");\n\t\tbreak;\n\tcase DAC960_V1_PL:\n\t\tstrcpy(cb->model_name, \"DAC960PL\");\n\t\tbreak;\n\tcase DAC960_V1_PG:\n\t\tstrcpy(cb->model_name, \"DAC960PG\");\n\t\tbreak;\n\tcase DAC960_V1_PJ:\n\t\tstrcpy(cb->model_name, \"DAC960PJ\");\n\t\tbreak;\n\tcase DAC960_V1_PR:\n\t\tstrcpy(cb->model_name, \"DAC960PR\");\n\t\tbreak;\n\tcase DAC960_V1_PT:\n\t\tstrcpy(cb->model_name, \"DAC960PT\");\n\t\tbreak;\n\tcase DAC960_V1_PTL0:\n\t\tstrcpy(cb->model_name, \"DAC960PTL0\");\n\t\tbreak;\n\tcase DAC960_V1_PRL:\n\t\tstrcpy(cb->model_name, \"DAC960PRL\");\n\t\tbreak;\n\tcase DAC960_V1_PTL1:\n\t\tstrcpy(cb->model_name, \"DAC960PTL1\");\n\t\tbreak;\n\tcase DAC960_V1_1164P:\n\t\tstrcpy(cb->model_name, \"eXtremeRAID 1100\");\n\t\tbreak;\n\tdefault:\n\t\tshost_printk(KERN_WARNING, cb->host,\n\t\t\t     \"Unknown Model %X\\n\",\n\t\t\t     enquiry2->hw.sub_model);\n\t\tgoto out;\n\t}\n\t \n#if defined(CONFIG_ALPHA)\n\t \n# define FIRMWARE_27X\t\"2.70\"\n#else\n# define FIRMWARE_27X\t\"2.73\"\n#endif\n\n\tif (enquiry2->fw.major_version == 0) {\n\t\tenquiry2->fw.major_version = cb->enquiry->fw_major_version;\n\t\tenquiry2->fw.minor_version = cb->enquiry->fw_minor_version;\n\t\tenquiry2->fw.firmware_type = '0';\n\t\tenquiry2->fw.turn_id = 0;\n\t}\n\tsnprintf(cb->fw_version, sizeof(cb->fw_version),\n\t\t\"%u.%02u-%c-%02u\",\n\t\tenquiry2->fw.major_version,\n\t\tenquiry2->fw.minor_version,\n\t\tenquiry2->fw.firmware_type,\n\t\tenquiry2->fw.turn_id);\n\tif (!((enquiry2->fw.major_version == 5 &&\n\t       enquiry2->fw.minor_version >= 6) ||\n\t      (enquiry2->fw.major_version == 4 &&\n\t       enquiry2->fw.minor_version >= 6) ||\n\t      (enquiry2->fw.major_version == 3 &&\n\t       enquiry2->fw.minor_version >= 51) ||\n\t      (enquiry2->fw.major_version == 2 &&\n\t       strcmp(cb->fw_version, FIRMWARE_27X) >= 0))) {\n\t\tshost_printk(KERN_WARNING, cb->host,\n\t\t\t\"Firmware Version '%s' unsupported\\n\",\n\t\t\tcb->fw_version);\n\t\tgoto out;\n\t}\n\t \n\tswitch (enquiry2->hw.model) {\n\tcase MYRB_5_CHANNEL_BOARD:\n\t\tpchan_max = 5;\n\t\tbreak;\n\tcase MYRB_3_CHANNEL_BOARD:\n\tcase MYRB_3_CHANNEL_ASIC_DAC:\n\t\tpchan_max = 3;\n\t\tbreak;\n\tcase MYRB_2_CHANNEL_BOARD:\n\t\tpchan_max = 2;\n\t\tbreak;\n\tdefault:\n\t\tpchan_max = enquiry2->cfg_chan;\n\t\tbreak;\n\t}\n\tpchan_cur = enquiry2->cur_chan;\n\tif (enquiry2->scsi_cap.bus_width == MYRB_WIDTH_WIDE_32BIT)\n\t\tcb->bus_width = 32;\n\telse if (enquiry2->scsi_cap.bus_width == MYRB_WIDTH_WIDE_16BIT)\n\t\tcb->bus_width = 16;\n\telse\n\t\tcb->bus_width = 8;\n\tcb->ldev_block_size = enquiry2->ldev_block_size;\n\tshost->max_channel = pchan_cur;\n\tshost->max_id = enquiry2->max_targets;\n\tmemsize = enquiry2->mem_size >> 20;\n\tcb->safte_enabled = (enquiry2->fault_mgmt == MYRB_FAULT_SAFTE);\n\t \n\tshost->can_queue = cb->enquiry->max_tcq;\n\tif (shost->can_queue < 3)\n\t\tshost->can_queue = enquiry2->max_cmds;\n\tif (shost->can_queue < 3)\n\t\t \n\t\tshost->can_queue = 1;\n\n\tif (shost->can_queue > MYRB_CMD_MBOX_COUNT - 2)\n\t\tshost->can_queue = MYRB_CMD_MBOX_COUNT - 2;\n\tshost->max_sectors = enquiry2->max_sectors;\n\tshost->sg_tablesize = enquiry2->max_sge;\n\tif (shost->sg_tablesize > MYRB_SCATTER_GATHER_LIMIT)\n\t\tshost->sg_tablesize = MYRB_SCATTER_GATHER_LIMIT;\n\t \n\tcb->stripe_size = config2->blocks_per_stripe * config2->block_factor\n\t\t>> (10 - MYRB_BLKSIZE_BITS);\n\tcb->segment_size = config2->blocks_per_cacheline * config2->block_factor\n\t\t>> (10 - MYRB_BLKSIZE_BITS);\n\t \n\tcb->ldev_geom_heads = 255;\n\tcb->ldev_geom_sectors = 63;\n\tif (config2->drive_geometry) {\n\t\tcb->ldev_geom_heads = 128;\n\t\tcb->ldev_geom_sectors = 32;\n\t}\n\n\t \n\tif ((cb->fw_version[0] == '4' &&\n\t     strcmp(cb->fw_version, \"4.08\") >= 0) ||\n\t    (cb->fw_version[0] == '5' &&\n\t     strcmp(cb->fw_version, \"5.08\") >= 0)) {\n\t\tcb->bgi_status_supported = true;\n\t\tmyrb_bgi_control(cb);\n\t}\n\tcb->last_rbld_status = MYRB_NO_STDBY_RBLD_OR_CHECK_IN_PROGRESS;\n\tret = 0;\n\nout:\n\tshost_printk(KERN_INFO, cb->host,\n\t\t\"Configuring %s PCI RAID Controller\\n\", cb->model_name);\n\tshost_printk(KERN_INFO, cb->host,\n\t\t\"  Firmware Version: %s, Memory Size: %dMB\\n\",\n\t\tcb->fw_version, memsize);\n\tif (cb->io_addr == 0)\n\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t\"  I/O Address: n/a, PCI Address: 0x%lX, IRQ Channel: %d\\n\",\n\t\t\t(unsigned long)cb->pci_addr, cb->irq);\n\telse\n\t\tshost_printk(KERN_INFO, cb->host,\n\t\t\t\"  I/O Address: 0x%lX, PCI Address: 0x%lX, IRQ Channel: %d\\n\",\n\t\t\t(unsigned long)cb->io_addr, (unsigned long)cb->pci_addr,\n\t\t\tcb->irq);\n\tshost_printk(KERN_INFO, cb->host,\n\t\t\"  Controller Queue Depth: %d, Maximum Blocks per Command: %d\\n\",\n\t\tcb->host->can_queue, cb->host->max_sectors);\n\tshost_printk(KERN_INFO, cb->host,\n\t\t     \"  Driver Queue Depth: %d, Scatter/Gather Limit: %d of %d Segments\\n\",\n\t\t     cb->host->can_queue, cb->host->sg_tablesize,\n\t\t     MYRB_SCATTER_GATHER_LIMIT);\n\tshost_printk(KERN_INFO, cb->host,\n\t\t     \"  Stripe Size: %dKB, Segment Size: %dKB, BIOS Geometry: %d/%d%s\\n\",\n\t\t     cb->stripe_size, cb->segment_size,\n\t\t     cb->ldev_geom_heads, cb->ldev_geom_sectors,\n\t\t     cb->safte_enabled ?\n\t\t     \"  SAF-TE Enclosure Management Enabled\" : \"\");\n\tshost_printk(KERN_INFO, cb->host,\n\t\t     \"  Physical: %d/%d channels %d/%d/%d devices\\n\",\n\t\t     pchan_cur, pchan_max, 0, cb->enquiry->pdev_dead,\n\t\t     cb->host->max_id);\n\n\tshost_printk(KERN_INFO, cb->host,\n\t\t     \"  Logical: 1/1 channels, %d/%d disks\\n\",\n\t\t     cb->enquiry->ldev_count, MYRB_MAX_LDEVS);\n\nout_free:\n\tdma_free_coherent(&pdev->dev, sizeof(struct myrb_enquiry2),\n\t\t\t  enquiry2, enquiry2_addr);\n\tdma_free_coherent(&pdev->dev, sizeof(struct myrb_config2),\n\t\t\t  config2, config2_addr);\n\n\treturn ret;\n}\n\n \nstatic void myrb_unmap(struct myrb_hba *cb)\n{\n\tif (cb->ldev_info_buf) {\n\t\tsize_t ldev_info_size = sizeof(struct myrb_ldev_info) *\n\t\t\tMYRB_MAX_LDEVS;\n\t\tdma_free_coherent(&cb->pdev->dev, ldev_info_size,\n\t\t\t\t  cb->ldev_info_buf, cb->ldev_info_addr);\n\t\tcb->ldev_info_buf = NULL;\n\t}\n\tif (cb->err_table) {\n\t\tsize_t err_table_size = sizeof(struct myrb_error_entry) *\n\t\t\tMYRB_MAX_CHANNELS * MYRB_MAX_TARGETS;\n\t\tdma_free_coherent(&cb->pdev->dev, err_table_size,\n\t\t\t\t  cb->err_table, cb->err_table_addr);\n\t\tcb->err_table = NULL;\n\t}\n\tif (cb->enquiry) {\n\t\tdma_free_coherent(&cb->pdev->dev, sizeof(struct myrb_enquiry),\n\t\t\t\t  cb->enquiry, cb->enquiry_addr);\n\t\tcb->enquiry = NULL;\n\t}\n\tif (cb->first_stat_mbox) {\n\t\tdma_free_coherent(&cb->pdev->dev, cb->stat_mbox_size,\n\t\t\t\t  cb->first_stat_mbox, cb->stat_mbox_addr);\n\t\tcb->first_stat_mbox = NULL;\n\t}\n\tif (cb->first_cmd_mbox) {\n\t\tdma_free_coherent(&cb->pdev->dev, cb->cmd_mbox_size,\n\t\t\t\t  cb->first_cmd_mbox, cb->cmd_mbox_addr);\n\t\tcb->first_cmd_mbox = NULL;\n\t}\n}\n\n \nstatic void myrb_cleanup(struct myrb_hba *cb)\n{\n\tstruct pci_dev *pdev = cb->pdev;\n\n\t \n\tmyrb_unmap(cb);\n\n\tif (cb->mmio_base) {\n\t\tif (cb->disable_intr)\n\t\t\tcb->disable_intr(cb->io_base);\n\t\tiounmap(cb->mmio_base);\n\t}\n\tif (cb->irq)\n\t\tfree_irq(cb->irq, cb);\n\tif (cb->io_addr)\n\t\trelease_region(cb->io_addr, 0x80);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_disable_device(pdev);\n\tscsi_host_put(cb->host);\n}\n\nstatic int myrb_host_reset(struct scsi_cmnd *scmd)\n{\n\tstruct Scsi_Host *shost = scmd->device->host;\n\tstruct myrb_hba *cb = shost_priv(shost);\n\n\tcb->reset(cb->io_base);\n\treturn SUCCESS;\n}\n\nstatic int myrb_pthru_queuecommand(struct Scsi_Host *shost,\n\t\tstruct scsi_cmnd *scmd)\n{\n\tstruct request *rq = scsi_cmd_to_rq(scmd);\n\tstruct myrb_hba *cb = shost_priv(shost);\n\tstruct myrb_cmdblk *cmd_blk = scsi_cmd_priv(scmd);\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tstruct myrb_dcdb *dcdb;\n\tdma_addr_t dcdb_addr;\n\tstruct scsi_device *sdev = scmd->device;\n\tstruct scatterlist *sgl;\n\tunsigned long flags;\n\tint nsge;\n\n\tmyrb_reset_cmd(cmd_blk);\n\tdcdb = dma_pool_alloc(cb->dcdb_pool, GFP_ATOMIC, &dcdb_addr);\n\tif (!dcdb)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tnsge = scsi_dma_map(scmd);\n\tif (nsge > 1) {\n\t\tdma_pool_free(cb->dcdb_pool, dcdb, dcdb_addr);\n\t\tscmd->result = (DID_ERROR << 16);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tmbox->type3.opcode = MYRB_CMD_DCDB;\n\tmbox->type3.id = rq->tag + 3;\n\tmbox->type3.addr = dcdb_addr;\n\tdcdb->channel = sdev->channel;\n\tdcdb->target = sdev->id;\n\tswitch (scmd->sc_data_direction) {\n\tcase DMA_NONE:\n\t\tdcdb->data_xfer = MYRB_DCDB_XFER_NONE;\n\t\tbreak;\n\tcase DMA_TO_DEVICE:\n\t\tdcdb->data_xfer = MYRB_DCDB_XFER_SYSTEM_TO_DEVICE;\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\tdcdb->data_xfer = MYRB_DCDB_XFER_DEVICE_TO_SYSTEM;\n\t\tbreak;\n\tdefault:\n\t\tdcdb->data_xfer = MYRB_DCDB_XFER_ILLEGAL;\n\t\tbreak;\n\t}\n\tdcdb->early_status = false;\n\tif (rq->timeout <= 10)\n\t\tdcdb->timeout = MYRB_DCDB_TMO_10_SECS;\n\telse if (rq->timeout <= 60)\n\t\tdcdb->timeout = MYRB_DCDB_TMO_60_SECS;\n\telse if (rq->timeout <= 600)\n\t\tdcdb->timeout = MYRB_DCDB_TMO_10_MINS;\n\telse\n\t\tdcdb->timeout = MYRB_DCDB_TMO_24_HRS;\n\tdcdb->no_autosense = false;\n\tdcdb->allow_disconnect = true;\n\tsgl = scsi_sglist(scmd);\n\tdcdb->dma_addr = sg_dma_address(sgl);\n\tif (sg_dma_len(sgl) > USHRT_MAX) {\n\t\tdcdb->xfer_len_lo = sg_dma_len(sgl) & 0xffff;\n\t\tdcdb->xfer_len_hi4 = sg_dma_len(sgl) >> 16;\n\t} else {\n\t\tdcdb->xfer_len_lo = sg_dma_len(sgl);\n\t\tdcdb->xfer_len_hi4 = 0;\n\t}\n\tdcdb->cdb_len = scmd->cmd_len;\n\tdcdb->sense_len = sizeof(dcdb->sense);\n\tmemcpy(&dcdb->cdb, scmd->cmnd, scmd->cmd_len);\n\n\tspin_lock_irqsave(&cb->queue_lock, flags);\n\tcb->qcmd(cb, cmd_blk);\n\tspin_unlock_irqrestore(&cb->queue_lock, flags);\n\treturn 0;\n}\n\nstatic void myrb_inquiry(struct myrb_hba *cb,\n\t\tstruct scsi_cmnd *scmd)\n{\n\tunsigned char inq[36] = {\n\t\t0x00, 0x00, 0x03, 0x02, 0x20, 0x00, 0x01, 0x00,\n\t\t0x4d, 0x59, 0x4c, 0x45, 0x58, 0x20, 0x20, 0x20,\n\t\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t\t0x20, 0x20, 0x20, 0x20,\n\t};\n\n\tif (cb->bus_width > 16)\n\t\tinq[7] |= 1 << 6;\n\tif (cb->bus_width > 8)\n\t\tinq[7] |= 1 << 5;\n\tmemcpy(&inq[16], cb->model_name, 16);\n\tmemcpy(&inq[32], cb->fw_version, 1);\n\tmemcpy(&inq[33], &cb->fw_version[2], 2);\n\tmemcpy(&inq[35], &cb->fw_version[7], 1);\n\n\tscsi_sg_copy_from_buffer(scmd, (void *)inq, 36);\n}\n\nstatic void\nmyrb_mode_sense(struct myrb_hba *cb, struct scsi_cmnd *scmd,\n\t\tstruct myrb_ldev_info *ldev_info)\n{\n\tunsigned char modes[32], *mode_pg;\n\tbool dbd;\n\tsize_t mode_len;\n\n\tdbd = (scmd->cmnd[1] & 0x08) == 0x08;\n\tif (dbd) {\n\t\tmode_len = 24;\n\t\tmode_pg = &modes[4];\n\t} else {\n\t\tmode_len = 32;\n\t\tmode_pg = &modes[12];\n\t}\n\tmemset(modes, 0, sizeof(modes));\n\tmodes[0] = mode_len - 1;\n\tif (!dbd) {\n\t\tunsigned char *block_desc = &modes[4];\n\n\t\tmodes[3] = 8;\n\t\tput_unaligned_be32(ldev_info->size, &block_desc[0]);\n\t\tput_unaligned_be32(cb->ldev_block_size, &block_desc[5]);\n\t}\n\tmode_pg[0] = 0x08;\n\tmode_pg[1] = 0x12;\n\tif (ldev_info->wb_enabled)\n\t\tmode_pg[2] |= 0x04;\n\tif (cb->segment_size) {\n\t\tmode_pg[2] |= 0x08;\n\t\tput_unaligned_be16(cb->segment_size, &mode_pg[14]);\n\t}\n\n\tscsi_sg_copy_from_buffer(scmd, modes, mode_len);\n}\n\nstatic void myrb_request_sense(struct myrb_hba *cb,\n\t\tstruct scsi_cmnd *scmd)\n{\n\tscsi_build_sense(scmd, 0, NO_SENSE, 0, 0);\n\tscsi_sg_copy_from_buffer(scmd, scmd->sense_buffer,\n\t\t\t\t SCSI_SENSE_BUFFERSIZE);\n}\n\nstatic void myrb_read_capacity(struct myrb_hba *cb, struct scsi_cmnd *scmd,\n\t\tstruct myrb_ldev_info *ldev_info)\n{\n\tunsigned char data[8];\n\n\tdev_dbg(&scmd->device->sdev_gendev,\n\t\t\"Capacity %u, blocksize %u\\n\",\n\t\tldev_info->size, cb->ldev_block_size);\n\tput_unaligned_be32(ldev_info->size - 1, &data[0]);\n\tput_unaligned_be32(cb->ldev_block_size, &data[4]);\n\tscsi_sg_copy_from_buffer(scmd, data, 8);\n}\n\nstatic int myrb_ldev_queuecommand(struct Scsi_Host *shost,\n\t\tstruct scsi_cmnd *scmd)\n{\n\tstruct myrb_hba *cb = shost_priv(shost);\n\tstruct myrb_cmdblk *cmd_blk = scsi_cmd_priv(scmd);\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tstruct myrb_ldev_info *ldev_info;\n\tstruct scsi_device *sdev = scmd->device;\n\tstruct scatterlist *sgl;\n\tunsigned long flags;\n\tu64 lba;\n\tu32 block_cnt;\n\tint nsge;\n\n\tldev_info = sdev->hostdata;\n\tif (ldev_info->state != MYRB_DEVICE_ONLINE &&\n\t    ldev_info->state != MYRB_DEVICE_WO) {\n\t\tdev_dbg(&shost->shost_gendev, \"ldev %u in state %x, skip\\n\",\n\t\t\tsdev->id, ldev_info ? ldev_info->state : 0xff);\n\t\tscmd->result = (DID_BAD_TARGET << 16);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\tswitch (scmd->cmnd[0]) {\n\tcase TEST_UNIT_READY:\n\t\tscmd->result = (DID_OK << 16);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\tcase INQUIRY:\n\t\tif (scmd->cmnd[1] & 1) {\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x24, 0);\n\t\t} else {\n\t\t\tmyrb_inquiry(cb, scmd);\n\t\t\tscmd->result = (DID_OK << 16);\n\t\t}\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\tcase SYNCHRONIZE_CACHE:\n\t\tscmd->result = (DID_OK << 16);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\tcase MODE_SENSE:\n\t\tif ((scmd->cmnd[2] & 0x3F) != 0x3F &&\n\t\t    (scmd->cmnd[2] & 0x3F) != 0x08) {\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x24, 0);\n\t\t} else {\n\t\t\tmyrb_mode_sense(cb, scmd, ldev_info);\n\t\t\tscmd->result = (DID_OK << 16);\n\t\t}\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\tcase READ_CAPACITY:\n\t\tif ((scmd->cmnd[1] & 1) ||\n\t\t    (scmd->cmnd[8] & 1)) {\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x24, 0);\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t\tlba = get_unaligned_be32(&scmd->cmnd[2]);\n\t\tif (lba) {\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x24, 0);\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t\tmyrb_read_capacity(cb, scmd, ldev_info);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\tcase REQUEST_SENSE:\n\t\tmyrb_request_sense(cb, scmd);\n\t\tscmd->result = (DID_OK << 16);\n\t\treturn 0;\n\tcase SEND_DIAGNOSTIC:\n\t\tif (scmd->cmnd[1] != 0x04) {\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x24, 0);\n\t\t} else {\n\t\t\t \n\t\t\tscmd->result = (DID_OK << 16);\n\t\t}\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\tcase READ_6:\n\t\tif (ldev_info->state == MYRB_DEVICE_WO) {\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, DATA_PROTECT, 0x21, 0x06);\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase WRITE_6:\n\t\tlba = (((scmd->cmnd[1] & 0x1F) << 16) |\n\t\t       (scmd->cmnd[2] << 8) |\n\t\t       scmd->cmnd[3]);\n\t\tblock_cnt = scmd->cmnd[4];\n\t\tbreak;\n\tcase READ_10:\n\t\tif (ldev_info->state == MYRB_DEVICE_WO) {\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, DATA_PROTECT, 0x21, 0x06);\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase WRITE_10:\n\tcase VERIFY:\t\t \n\tcase WRITE_VERIFY:\t \n\t\tlba = get_unaligned_be32(&scmd->cmnd[2]);\n\t\tblock_cnt = get_unaligned_be16(&scmd->cmnd[7]);\n\t\tbreak;\n\tcase READ_12:\n\t\tif (ldev_info->state == MYRB_DEVICE_WO) {\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, DATA_PROTECT, 0x21, 0x06);\n\t\t\tscsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase WRITE_12:\n\tcase VERIFY_12:  \n\tcase WRITE_VERIFY_12:\t \n\t\tlba = get_unaligned_be32(&scmd->cmnd[2]);\n\t\tblock_cnt = get_unaligned_be32(&scmd->cmnd[6]);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tscsi_build_sense(scmd, 0, ILLEGAL_REQUEST, 0x20, 0);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tmyrb_reset_cmd(cmd_blk);\n\tmbox->type5.id = scsi_cmd_to_rq(scmd)->tag + 3;\n\tif (scmd->sc_data_direction == DMA_NONE)\n\t\tgoto submit;\n\tnsge = scsi_dma_map(scmd);\n\tif (nsge == 1) {\n\t\tsgl = scsi_sglist(scmd);\n\t\tif (scmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\tmbox->type5.opcode = MYRB_CMD_READ;\n\t\telse\n\t\t\tmbox->type5.opcode = MYRB_CMD_WRITE;\n\n\t\tmbox->type5.ld.xfer_len = block_cnt;\n\t\tmbox->type5.ld.ldev_num = sdev->id;\n\t\tmbox->type5.lba = lba;\n\t\tmbox->type5.addr = (u32)sg_dma_address(sgl);\n\t} else {\n\t\tstruct myrb_sge *hw_sgl;\n\t\tdma_addr_t hw_sgl_addr;\n\t\tint i;\n\n\t\thw_sgl = dma_pool_alloc(cb->sg_pool, GFP_ATOMIC, &hw_sgl_addr);\n\t\tif (!hw_sgl)\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t\tcmd_blk->sgl = hw_sgl;\n\t\tcmd_blk->sgl_addr = hw_sgl_addr;\n\n\t\tif (scmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\tmbox->type5.opcode = MYRB_CMD_READ_SG;\n\t\telse\n\t\t\tmbox->type5.opcode = MYRB_CMD_WRITE_SG;\n\n\t\tmbox->type5.ld.xfer_len = block_cnt;\n\t\tmbox->type5.ld.ldev_num = sdev->id;\n\t\tmbox->type5.lba = lba;\n\t\tmbox->type5.addr = hw_sgl_addr;\n\t\tmbox->type5.sg_count = nsge;\n\n\t\tscsi_for_each_sg(scmd, sgl, nsge, i) {\n\t\t\thw_sgl->sge_addr = (u32)sg_dma_address(sgl);\n\t\t\thw_sgl->sge_count = (u32)sg_dma_len(sgl);\n\t\t\thw_sgl++;\n\t\t}\n\t}\nsubmit:\n\tspin_lock_irqsave(&cb->queue_lock, flags);\n\tcb->qcmd(cb, cmd_blk);\n\tspin_unlock_irqrestore(&cb->queue_lock, flags);\n\n\treturn 0;\n}\n\nstatic int myrb_queuecommand(struct Scsi_Host *shost,\n\t\tstruct scsi_cmnd *scmd)\n{\n\tstruct scsi_device *sdev = scmd->device;\n\n\tif (sdev->channel > myrb_logical_channel(shost)) {\n\t\tscmd->result = (DID_BAD_TARGET << 16);\n\t\tscsi_done(scmd);\n\t\treturn 0;\n\t}\n\tif (sdev->channel == myrb_logical_channel(shost))\n\t\treturn myrb_ldev_queuecommand(shost, scmd);\n\n\treturn myrb_pthru_queuecommand(shost, scmd);\n}\n\nstatic int myrb_ldev_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tstruct myrb_ldev_info *ldev_info;\n\tunsigned short ldev_num = sdev->id;\n\tenum raid_level level;\n\n\tldev_info = cb->ldev_info_buf + ldev_num;\n\tif (!ldev_info)\n\t\treturn -ENXIO;\n\n\tsdev->hostdata = kzalloc(sizeof(*ldev_info), GFP_KERNEL);\n\tif (!sdev->hostdata)\n\t\treturn -ENOMEM;\n\tdev_dbg(&sdev->sdev_gendev,\n\t\t\"slave alloc ldev %d state %x\\n\",\n\t\tldev_num, ldev_info->state);\n\tmemcpy(sdev->hostdata, ldev_info,\n\t       sizeof(*ldev_info));\n\tswitch (ldev_info->raid_level) {\n\tcase MYRB_RAID_LEVEL0:\n\t\tlevel = RAID_LEVEL_LINEAR;\n\t\tbreak;\n\tcase MYRB_RAID_LEVEL1:\n\t\tlevel = RAID_LEVEL_1;\n\t\tbreak;\n\tcase MYRB_RAID_LEVEL3:\n\t\tlevel = RAID_LEVEL_3;\n\t\tbreak;\n\tcase MYRB_RAID_LEVEL5:\n\t\tlevel = RAID_LEVEL_5;\n\t\tbreak;\n\tcase MYRB_RAID_LEVEL6:\n\t\tlevel = RAID_LEVEL_6;\n\t\tbreak;\n\tcase MYRB_RAID_JBOD:\n\t\tlevel = RAID_LEVEL_JBOD;\n\t\tbreak;\n\tdefault:\n\t\tlevel = RAID_LEVEL_UNKNOWN;\n\t\tbreak;\n\t}\n\traid_set_level(myrb_raid_template, &sdev->sdev_gendev, level);\n\treturn 0;\n}\n\nstatic int myrb_pdev_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tstruct myrb_pdev_state *pdev_info;\n\tunsigned short status;\n\n\tif (sdev->id > MYRB_MAX_TARGETS)\n\t\treturn -ENXIO;\n\n\tpdev_info = kzalloc(sizeof(*pdev_info), GFP_KERNEL);\n\tif (!pdev_info)\n\t\treturn -ENOMEM;\n\n\tstatus = myrb_exec_type3D(cb, MYRB_CMD_GET_DEVICE_STATE,\n\t\t\t\t  sdev, pdev_info);\n\tif (status != MYRB_STATUS_SUCCESS) {\n\t\tdev_dbg(&sdev->sdev_gendev,\n\t\t\t\"Failed to get device state, status %x\\n\",\n\t\t\tstatus);\n\t\tkfree(pdev_info);\n\t\treturn -ENXIO;\n\t}\n\tif (!pdev_info->present) {\n\t\tdev_dbg(&sdev->sdev_gendev,\n\t\t\t\"device not present, skip\\n\");\n\t\tkfree(pdev_info);\n\t\treturn -ENXIO;\n\t}\n\tdev_dbg(&sdev->sdev_gendev,\n\t\t\"slave alloc pdev %d:%d state %x\\n\",\n\t\tsdev->channel, sdev->id, pdev_info->state);\n\tsdev->hostdata = pdev_info;\n\n\treturn 0;\n}\n\nstatic int myrb_slave_alloc(struct scsi_device *sdev)\n{\n\tif (sdev->channel > myrb_logical_channel(sdev->host))\n\t\treturn -ENXIO;\n\n\tif (sdev->lun > 0)\n\t\treturn -ENXIO;\n\n\tif (sdev->channel == myrb_logical_channel(sdev->host))\n\t\treturn myrb_ldev_slave_alloc(sdev);\n\n\treturn myrb_pdev_slave_alloc(sdev);\n}\n\nstatic int myrb_slave_configure(struct scsi_device *sdev)\n{\n\tstruct myrb_ldev_info *ldev_info;\n\n\tif (sdev->channel > myrb_logical_channel(sdev->host))\n\t\treturn -ENXIO;\n\n\tif (sdev->channel < myrb_logical_channel(sdev->host)) {\n\t\tsdev->no_uld_attach = 1;\n\t\treturn 0;\n\t}\n\tif (sdev->lun != 0)\n\t\treturn -ENXIO;\n\n\tldev_info = sdev->hostdata;\n\tif (!ldev_info)\n\t\treturn -ENXIO;\n\tif (ldev_info->state != MYRB_DEVICE_ONLINE)\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Logical drive is %s\\n\",\n\t\t\t    myrb_devstate_name(ldev_info->state));\n\n\tsdev->tagged_supported = 1;\n\treturn 0;\n}\n\nstatic void myrb_slave_destroy(struct scsi_device *sdev)\n{\n\tkfree(sdev->hostdata);\n}\n\nstatic int myrb_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\tsector_t capacity, int geom[])\n{\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\n\tgeom[0] = cb->ldev_geom_heads;\n\tgeom[1] = cb->ldev_geom_sectors;\n\tgeom[2] = sector_div(capacity, geom[0] * geom[1]);\n\n\treturn 0;\n}\n\nstatic ssize_t raid_state_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tint ret;\n\n\tif (!sdev->hostdata)\n\t\treturn snprintf(buf, 16, \"Unknown\\n\");\n\n\tif (sdev->channel == myrb_logical_channel(sdev->host)) {\n\t\tstruct myrb_ldev_info *ldev_info = sdev->hostdata;\n\t\tconst char *name;\n\n\t\tname = myrb_devstate_name(ldev_info->state);\n\t\tif (name)\n\t\t\tret = snprintf(buf, 32, \"%s\\n\", name);\n\t\telse\n\t\t\tret = snprintf(buf, 32, \"Invalid (%02X)\\n\",\n\t\t\t\t       ldev_info->state);\n\t} else {\n\t\tstruct myrb_pdev_state *pdev_info = sdev->hostdata;\n\t\tunsigned short status;\n\t\tconst char *name;\n\n\t\tstatus = myrb_exec_type3D(cb, MYRB_CMD_GET_DEVICE_STATE,\n\t\t\t\t\t  sdev, pdev_info);\n\t\tif (status != MYRB_STATUS_SUCCESS)\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Failed to get device state, status %x\\n\",\n\t\t\t\t    status);\n\n\t\tif (!pdev_info->present)\n\t\t\tname = \"Removed\";\n\t\telse\n\t\t\tname = myrb_devstate_name(pdev_info->state);\n\t\tif (name)\n\t\t\tret = snprintf(buf, 32, \"%s\\n\", name);\n\t\telse\n\t\t\tret = snprintf(buf, 32, \"Invalid (%02X)\\n\",\n\t\t\t\t       pdev_info->state);\n\t}\n\treturn ret;\n}\n\nstatic ssize_t raid_state_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tstruct myrb_pdev_state *pdev_info;\n\tenum myrb_devstate new_state;\n\tunsigned short status;\n\n\tif (!strncmp(buf, \"kill\", 4) ||\n\t    !strncmp(buf, \"offline\", 7))\n\t\tnew_state = MYRB_DEVICE_DEAD;\n\telse if (!strncmp(buf, \"online\", 6))\n\t\tnew_state = MYRB_DEVICE_ONLINE;\n\telse if (!strncmp(buf, \"standby\", 7))\n\t\tnew_state = MYRB_DEVICE_STANDBY;\n\telse\n\t\treturn -EINVAL;\n\n\tpdev_info = sdev->hostdata;\n\tif (!pdev_info) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Failed - no physical device information\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (!pdev_info->present) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Failed - device not present\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tif (pdev_info->state == new_state)\n\t\treturn count;\n\n\tstatus = myrb_set_pdev_state(cb, sdev, new_state);\n\tswitch (status) {\n\tcase MYRB_STATUS_SUCCESS:\n\t\tbreak;\n\tcase MYRB_STATUS_START_DEVICE_FAILED:\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t     \"Failed - Unable to Start Device\\n\");\n\t\tcount = -EAGAIN;\n\t\tbreak;\n\tcase MYRB_STATUS_NO_DEVICE:\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Failed - No Device at Address\\n\");\n\t\tcount = -ENODEV;\n\t\tbreak;\n\tcase MYRB_STATUS_INVALID_CHANNEL_OR_TARGET:\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t \"Failed - Invalid Channel or Target or Modifier\\n\");\n\t\tcount = -EINVAL;\n\t\tbreak;\n\tcase MYRB_STATUS_CHANNEL_BUSY:\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t \"Failed - Channel Busy\\n\");\n\t\tcount = -EBUSY;\n\t\tbreak;\n\tdefault:\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t \"Failed - Unexpected Status %04X\\n\", status);\n\t\tcount = -EIO;\n\t\tbreak;\n\t}\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(raid_state);\n\nstatic ssize_t raid_level_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\tif (sdev->channel == myrb_logical_channel(sdev->host)) {\n\t\tstruct myrb_ldev_info *ldev_info = sdev->hostdata;\n\t\tconst char *name;\n\n\t\tif (!ldev_info)\n\t\t\treturn -ENXIO;\n\n\t\tname = myrb_raidlevel_name(ldev_info->raid_level);\n\t\tif (!name)\n\t\t\treturn snprintf(buf, 32, \"Invalid (%02X)\\n\",\n\t\t\t\t\tldev_info->state);\n\t\treturn snprintf(buf, 32, \"%s\\n\", name);\n\t}\n\treturn snprintf(buf, 32, \"Physical Drive\\n\");\n}\nstatic DEVICE_ATTR_RO(raid_level);\n\nstatic ssize_t rebuild_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tstruct myrb_rbld_progress rbld_buf;\n\tunsigned char status;\n\n\tif (sdev->channel < myrb_logical_channel(sdev->host))\n\t\treturn snprintf(buf, 32, \"physical device - not rebuilding\\n\");\n\n\tstatus = myrb_get_rbld_progress(cb, &rbld_buf);\n\n\tif (rbld_buf.ldev_num != sdev->id ||\n\t    status != MYRB_STATUS_SUCCESS)\n\t\treturn snprintf(buf, 32, \"not rebuilding\\n\");\n\n\treturn snprintf(buf, 32, \"rebuilding block %u of %u\\n\",\n\t\t\trbld_buf.ldev_size - rbld_buf.blocks_left,\n\t\t\trbld_buf.ldev_size);\n}\n\nstatic ssize_t rebuild_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tstruct myrb_cmdblk *cmd_blk;\n\tunion myrb_cmd_mbox *mbox;\n\tunsigned short status;\n\tint rc, start;\n\tconst char *msg;\n\n\trc = kstrtoint(buf, 0, &start);\n\tif (rc)\n\t\treturn rc;\n\n\tif (sdev->channel >= myrb_logical_channel(sdev->host))\n\t\treturn -ENXIO;\n\n\tstatus = myrb_get_rbld_progress(cb, NULL);\n\tif (start) {\n\t\tif (status == MYRB_STATUS_SUCCESS) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Rebuild Not Initiated; already in progress\\n\");\n\t\t\treturn -EALREADY;\n\t\t}\n\t\tmutex_lock(&cb->dcmd_mutex);\n\t\tcmd_blk = &cb->dcmd_blk;\n\t\tmyrb_reset_cmd(cmd_blk);\n\t\tmbox = &cmd_blk->mbox;\n\t\tmbox->type3D.opcode = MYRB_CMD_REBUILD_ASYNC;\n\t\tmbox->type3D.id = MYRB_DCMD_TAG;\n\t\tmbox->type3D.channel = sdev->channel;\n\t\tmbox->type3D.target = sdev->id;\n\t\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\t\tmutex_unlock(&cb->dcmd_mutex);\n\t} else {\n\t\tstruct pci_dev *pdev = cb->pdev;\n\t\tunsigned char *rate;\n\t\tdma_addr_t rate_addr;\n\n\t\tif (status != MYRB_STATUS_SUCCESS) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Rebuild Not Cancelled; not in progress\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\trate = dma_alloc_coherent(&pdev->dev, sizeof(char),\n\t\t\t\t\t  &rate_addr, GFP_KERNEL);\n\t\tif (rate == NULL) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Cancellation of Rebuild Failed - Out of Memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmutex_lock(&cb->dcmd_mutex);\n\t\tcmd_blk = &cb->dcmd_blk;\n\t\tmyrb_reset_cmd(cmd_blk);\n\t\tmbox = &cmd_blk->mbox;\n\t\tmbox->type3R.opcode = MYRB_CMD_REBUILD_CONTROL;\n\t\tmbox->type3R.id = MYRB_DCMD_TAG;\n\t\tmbox->type3R.rbld_rate = 0xFF;\n\t\tmbox->type3R.addr = rate_addr;\n\t\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\t\tdma_free_coherent(&pdev->dev, sizeof(char), rate, rate_addr);\n\t\tmutex_unlock(&cb->dcmd_mutex);\n\t}\n\tif (status == MYRB_STATUS_SUCCESS) {\n\t\tsdev_printk(KERN_INFO, sdev, \"Rebuild %s\\n\",\n\t\t\t    start ? \"Initiated\" : \"Cancelled\");\n\t\treturn count;\n\t}\n\tif (!start) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Rebuild Not Cancelled, status 0x%x\\n\",\n\t\t\t    status);\n\t\treturn -EIO;\n\t}\n\n\tswitch (status) {\n\tcase MYRB_STATUS_ATTEMPT_TO_RBLD_ONLINE_DRIVE:\n\t\tmsg = \"Attempt to Rebuild Online or Unresponsive Drive\";\n\t\tbreak;\n\tcase MYRB_STATUS_RBLD_NEW_DISK_FAILED:\n\t\tmsg = \"New Disk Failed During Rebuild\";\n\t\tbreak;\n\tcase MYRB_STATUS_INVALID_ADDRESS:\n\t\tmsg = \"Invalid Device Address\";\n\t\tbreak;\n\tcase MYRB_STATUS_RBLD_OR_CHECK_INPROGRESS:\n\t\tmsg = \"Already in Progress\";\n\t\tbreak;\n\tdefault:\n\t\tmsg = NULL;\n\t\tbreak;\n\t}\n\tif (msg)\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Rebuild Failed - %s\\n\", msg);\n\telse\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Rebuild Failed, status 0x%x\\n\", status);\n\n\treturn -EIO;\n}\nstatic DEVICE_ATTR_RW(rebuild);\n\nstatic ssize_t consistency_check_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tstruct myrb_rbld_progress rbld_buf;\n\tstruct myrb_cmdblk *cmd_blk;\n\tunion myrb_cmd_mbox *mbox;\n\tunsigned short ldev_num = 0xFFFF;\n\tunsigned short status;\n\tint rc, start;\n\tconst char *msg;\n\n\trc = kstrtoint(buf, 0, &start);\n\tif (rc)\n\t\treturn rc;\n\n\tif (sdev->channel < myrb_logical_channel(sdev->host))\n\t\treturn -ENXIO;\n\n\tstatus = myrb_get_rbld_progress(cb, &rbld_buf);\n\tif (start) {\n\t\tif (status == MYRB_STATUS_SUCCESS) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Check Consistency Not Initiated; already in progress\\n\");\n\t\t\treturn -EALREADY;\n\t\t}\n\t\tmutex_lock(&cb->dcmd_mutex);\n\t\tcmd_blk = &cb->dcmd_blk;\n\t\tmyrb_reset_cmd(cmd_blk);\n\t\tmbox = &cmd_blk->mbox;\n\t\tmbox->type3C.opcode = MYRB_CMD_CHECK_CONSISTENCY_ASYNC;\n\t\tmbox->type3C.id = MYRB_DCMD_TAG;\n\t\tmbox->type3C.ldev_num = sdev->id;\n\t\tmbox->type3C.auto_restore = true;\n\n\t\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\t\tmutex_unlock(&cb->dcmd_mutex);\n\t} else {\n\t\tstruct pci_dev *pdev = cb->pdev;\n\t\tunsigned char *rate;\n\t\tdma_addr_t rate_addr;\n\n\t\tif (ldev_num != sdev->id) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Check Consistency Not Cancelled; not in progress\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\trate = dma_alloc_coherent(&pdev->dev, sizeof(char),\n\t\t\t\t\t  &rate_addr, GFP_KERNEL);\n\t\tif (rate == NULL) {\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"Cancellation of Check Consistency Failed - Out of Memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmutex_lock(&cb->dcmd_mutex);\n\t\tcmd_blk = &cb->dcmd_blk;\n\t\tmyrb_reset_cmd(cmd_blk);\n\t\tmbox = &cmd_blk->mbox;\n\t\tmbox->type3R.opcode = MYRB_CMD_REBUILD_CONTROL;\n\t\tmbox->type3R.id = MYRB_DCMD_TAG;\n\t\tmbox->type3R.rbld_rate = 0xFF;\n\t\tmbox->type3R.addr = rate_addr;\n\t\tstatus = myrb_exec_cmd(cb, cmd_blk);\n\t\tdma_free_coherent(&pdev->dev, sizeof(char), rate, rate_addr);\n\t\tmutex_unlock(&cb->dcmd_mutex);\n\t}\n\tif (status == MYRB_STATUS_SUCCESS) {\n\t\tsdev_printk(KERN_INFO, sdev, \"Check Consistency %s\\n\",\n\t\t\t    start ? \"Initiated\" : \"Cancelled\");\n\t\treturn count;\n\t}\n\tif (!start) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Check Consistency Not Cancelled, status 0x%x\\n\",\n\t\t\t    status);\n\t\treturn -EIO;\n\t}\n\n\tswitch (status) {\n\tcase MYRB_STATUS_ATTEMPT_TO_RBLD_ONLINE_DRIVE:\n\t\tmsg = \"Dependent Physical Device is DEAD\";\n\t\tbreak;\n\tcase MYRB_STATUS_RBLD_NEW_DISK_FAILED:\n\t\tmsg = \"New Disk Failed During Rebuild\";\n\t\tbreak;\n\tcase MYRB_STATUS_INVALID_ADDRESS:\n\t\tmsg = \"Invalid or Nonredundant Logical Drive\";\n\t\tbreak;\n\tcase MYRB_STATUS_RBLD_OR_CHECK_INPROGRESS:\n\t\tmsg = \"Already in Progress\";\n\t\tbreak;\n\tdefault:\n\t\tmsg = NULL;\n\t\tbreak;\n\t}\n\tif (msg)\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Check Consistency Failed - %s\\n\", msg);\n\telse\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"Check Consistency Failed, status 0x%x\\n\", status);\n\n\treturn -EIO;\n}\n\nstatic ssize_t consistency_check_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn rebuild_show(dev, attr, buf);\n}\nstatic DEVICE_ATTR_RW(consistency_check);\n\nstatic ssize_t ctlr_num_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrb_hba *cb = shost_priv(shost);\n\n\treturn snprintf(buf, 20, \"%u\\n\", cb->ctlr_num);\n}\nstatic DEVICE_ATTR_RO(ctlr_num);\n\nstatic ssize_t firmware_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrb_hba *cb = shost_priv(shost);\n\n\treturn snprintf(buf, 16, \"%s\\n\", cb->fw_version);\n}\nstatic DEVICE_ATTR_RO(firmware);\n\nstatic ssize_t model_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrb_hba *cb = shost_priv(shost);\n\n\treturn snprintf(buf, 16, \"%s\\n\", cb->model_name);\n}\nstatic DEVICE_ATTR_RO(model);\n\nstatic ssize_t flush_cache_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct myrb_hba *cb = shost_priv(shost);\n\tunsigned short status;\n\n\tstatus = myrb_exec_type3(cb, MYRB_CMD_FLUSH, 0);\n\tif (status == MYRB_STATUS_SUCCESS) {\n\t\tshost_printk(KERN_INFO, shost,\n\t\t\t     \"Cache Flush Completed\\n\");\n\t\treturn count;\n\t}\n\tshost_printk(KERN_INFO, shost,\n\t\t     \"Cache Flush Failed, status %x\\n\", status);\n\treturn -EIO;\n}\nstatic DEVICE_ATTR_WO(flush_cache);\n\nstatic struct attribute *myrb_sdev_attrs[] = {\n\t&dev_attr_rebuild.attr,\n\t&dev_attr_consistency_check.attr,\n\t&dev_attr_raid_state.attr,\n\t&dev_attr_raid_level.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(myrb_sdev);\n\nstatic struct attribute *myrb_shost_attrs[] = {\n\t&dev_attr_ctlr_num.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_firmware.attr,\n\t&dev_attr_flush_cache.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(myrb_shost);\n\nstatic const struct scsi_host_template myrb_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"DAC960\",\n\t.proc_name\t\t= \"myrb\",\n\t.queuecommand\t\t= myrb_queuecommand,\n\t.eh_host_reset_handler\t= myrb_host_reset,\n\t.slave_alloc\t\t= myrb_slave_alloc,\n\t.slave_configure\t= myrb_slave_configure,\n\t.slave_destroy\t\t= myrb_slave_destroy,\n\t.bios_param\t\t= myrb_biosparam,\n\t.cmd_size\t\t= sizeof(struct myrb_cmdblk),\n\t.shost_groups\t\t= myrb_shost_groups,\n\t.sdev_groups\t\t= myrb_sdev_groups,\n\t.this_id\t\t= -1,\n};\n\n \nstatic int myrb_is_raid(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\treturn sdev->channel == myrb_logical_channel(sdev->host);\n}\n\n \nstatic void myrb_get_resync(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tstruct myrb_rbld_progress rbld_buf;\n\tunsigned int percent_complete = 0;\n\tunsigned short status;\n\tunsigned int ldev_size = 0, remaining = 0;\n\n\tif (sdev->channel < myrb_logical_channel(sdev->host))\n\t\treturn;\n\tstatus = myrb_get_rbld_progress(cb, &rbld_buf);\n\tif (status == MYRB_STATUS_SUCCESS) {\n\t\tif (rbld_buf.ldev_num == sdev->id) {\n\t\t\tldev_size = rbld_buf.ldev_size;\n\t\t\tremaining = rbld_buf.blocks_left;\n\t\t}\n\t}\n\tif (remaining && ldev_size)\n\t\tpercent_complete = (ldev_size - remaining) * 100 / ldev_size;\n\traid_set_resync(myrb_raid_template, dev, percent_complete);\n}\n\n \nstatic void myrb_get_state(struct device *dev)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct myrb_hba *cb = shost_priv(sdev->host);\n\tstruct myrb_ldev_info *ldev_info = sdev->hostdata;\n\tenum raid_state state = RAID_STATE_UNKNOWN;\n\tunsigned short status;\n\n\tif (sdev->channel < myrb_logical_channel(sdev->host) || !ldev_info)\n\t\tstate = RAID_STATE_UNKNOWN;\n\telse {\n\t\tstatus = myrb_get_rbld_progress(cb, NULL);\n\t\tif (status == MYRB_STATUS_SUCCESS)\n\t\t\tstate = RAID_STATE_RESYNCING;\n\t\telse {\n\t\t\tswitch (ldev_info->state) {\n\t\t\tcase MYRB_DEVICE_ONLINE:\n\t\t\t\tstate = RAID_STATE_ACTIVE;\n\t\t\t\tbreak;\n\t\t\tcase MYRB_DEVICE_WO:\n\t\t\tcase MYRB_DEVICE_CRITICAL:\n\t\t\t\tstate = RAID_STATE_DEGRADED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate = RAID_STATE_OFFLINE;\n\t\t\t}\n\t\t}\n\t}\n\traid_set_state(myrb_raid_template, dev, state);\n}\n\nstatic struct raid_function_template myrb_raid_functions = {\n\t.cookie\t\t= &myrb_template,\n\t.is_raid\t= myrb_is_raid,\n\t.get_resync\t= myrb_get_resync,\n\t.get_state\t= myrb_get_state,\n};\n\nstatic void myrb_handle_scsi(struct myrb_hba *cb, struct myrb_cmdblk *cmd_blk,\n\t\tstruct scsi_cmnd *scmd)\n{\n\tunsigned short status;\n\n\tif (!cmd_blk)\n\t\treturn;\n\n\tscsi_dma_unmap(scmd);\n\n\tif (cmd_blk->dcdb) {\n\t\tmemcpy(scmd->sense_buffer, &cmd_blk->dcdb->sense, 64);\n\t\tdma_pool_free(cb->dcdb_pool, cmd_blk->dcdb,\n\t\t\t      cmd_blk->dcdb_addr);\n\t\tcmd_blk->dcdb = NULL;\n\t}\n\tif (cmd_blk->sgl) {\n\t\tdma_pool_free(cb->sg_pool, cmd_blk->sgl, cmd_blk->sgl_addr);\n\t\tcmd_blk->sgl = NULL;\n\t\tcmd_blk->sgl_addr = 0;\n\t}\n\tstatus = cmd_blk->status;\n\tswitch (status) {\n\tcase MYRB_STATUS_SUCCESS:\n\tcase MYRB_STATUS_DEVICE_BUSY:\n\t\tscmd->result = (DID_OK << 16) | status;\n\t\tbreak;\n\tcase MYRB_STATUS_BAD_DATA:\n\t\tdev_dbg(&scmd->device->sdev_gendev,\n\t\t\t\"Bad Data Encountered\\n\");\n\t\tif (scmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, MEDIUM_ERROR, 0x11, 0);\n\t\telse\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, MEDIUM_ERROR, 0x0C, 0);\n\t\tbreak;\n\tcase MYRB_STATUS_IRRECOVERABLE_DATA_ERROR:\n\t\tscmd_printk(KERN_ERR, scmd, \"Irrecoverable Data Error\\n\");\n\t\tif (scmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, MEDIUM_ERROR, 0x11, 0x04);\n\t\telse\n\t\t\t \n\t\t\tscsi_build_sense(scmd, 0, MEDIUM_ERROR, 0x0C, 0x02);\n\t\tbreak;\n\tcase MYRB_STATUS_LDRV_NONEXISTENT_OR_OFFLINE:\n\t\tdev_dbg(&scmd->device->sdev_gendev,\n\t\t\t    \"Logical Drive Nonexistent or Offline\");\n\t\tscmd->result = (DID_BAD_TARGET << 16);\n\t\tbreak;\n\tcase MYRB_STATUS_ACCESS_BEYOND_END_OF_LDRV:\n\t\tdev_dbg(&scmd->device->sdev_gendev,\n\t\t\t    \"Attempt to Access Beyond End of Logical Drive\");\n\t\t \n\t\tscsi_build_sense(scmd, 0, NOT_READY, 0x21, 0);\n\t\tbreak;\n\tcase MYRB_STATUS_DEVICE_NONRESPONSIVE:\n\t\tdev_dbg(&scmd->device->sdev_gendev, \"Device nonresponsive\\n\");\n\t\tscmd->result = (DID_BAD_TARGET << 16);\n\t\tbreak;\n\tdefault:\n\t\tscmd_printk(KERN_ERR, scmd,\n\t\t\t    \"Unexpected Error Status %04X\", status);\n\t\tscmd->result = (DID_ERROR << 16);\n\t\tbreak;\n\t}\n\tscsi_done(scmd);\n}\n\nstatic void myrb_handle_cmdblk(struct myrb_hba *cb, struct myrb_cmdblk *cmd_blk)\n{\n\tif (!cmd_blk)\n\t\treturn;\n\n\tif (cmd_blk->completion) {\n\t\tcomplete(cmd_blk->completion);\n\t\tcmd_blk->completion = NULL;\n\t}\n}\n\nstatic void myrb_monitor(struct work_struct *work)\n{\n\tstruct myrb_hba *cb = container_of(work,\n\t\t\tstruct myrb_hba, monitor_work.work);\n\tstruct Scsi_Host *shost = cb->host;\n\tunsigned long interval = MYRB_PRIMARY_MONITOR_INTERVAL;\n\n\tdev_dbg(&shost->shost_gendev, \"monitor tick\\n\");\n\n\tif (cb->new_ev_seq > cb->old_ev_seq) {\n\t\tint event = cb->old_ev_seq;\n\n\t\tdev_dbg(&shost->shost_gendev,\n\t\t\t\"get event log no %d/%d\\n\",\n\t\t\tcb->new_ev_seq, event);\n\t\tmyrb_get_event(cb, event);\n\t\tcb->old_ev_seq = event + 1;\n\t\tinterval = 10;\n\t} else if (cb->need_err_info) {\n\t\tcb->need_err_info = false;\n\t\tdev_dbg(&shost->shost_gendev, \"get error table\\n\");\n\t\tmyrb_get_errtable(cb);\n\t\tinterval = 10;\n\t} else if (cb->need_rbld && cb->rbld_first) {\n\t\tcb->need_rbld = false;\n\t\tdev_dbg(&shost->shost_gendev,\n\t\t\t\"get rebuild progress\\n\");\n\t\tmyrb_update_rbld_progress(cb);\n\t\tinterval = 10;\n\t} else if (cb->need_ldev_info) {\n\t\tcb->need_ldev_info = false;\n\t\tdev_dbg(&shost->shost_gendev,\n\t\t\t\"get logical drive info\\n\");\n\t\tmyrb_get_ldev_info(cb);\n\t\tinterval = 10;\n\t} else if (cb->need_rbld) {\n\t\tcb->need_rbld = false;\n\t\tdev_dbg(&shost->shost_gendev,\n\t\t\t\"get rebuild progress\\n\");\n\t\tmyrb_update_rbld_progress(cb);\n\t\tinterval = 10;\n\t} else if (cb->need_cc_status) {\n\t\tcb->need_cc_status = false;\n\t\tdev_dbg(&shost->shost_gendev,\n\t\t\t\"get consistency check progress\\n\");\n\t\tmyrb_get_cc_progress(cb);\n\t\tinterval = 10;\n\t} else if (cb->need_bgi_status) {\n\t\tcb->need_bgi_status = false;\n\t\tdev_dbg(&shost->shost_gendev, \"get background init status\\n\");\n\t\tmyrb_bgi_control(cb);\n\t\tinterval = 10;\n\t} else {\n\t\tdev_dbg(&shost->shost_gendev, \"new enquiry\\n\");\n\t\tmutex_lock(&cb->dma_mutex);\n\t\tmyrb_hba_enquiry(cb);\n\t\tmutex_unlock(&cb->dma_mutex);\n\t\tif ((cb->new_ev_seq - cb->old_ev_seq > 0) ||\n\t\t    cb->need_err_info || cb->need_rbld ||\n\t\t    cb->need_ldev_info || cb->need_cc_status ||\n\t\t    cb->need_bgi_status) {\n\t\t\tdev_dbg(&shost->shost_gendev,\n\t\t\t\t\"reschedule monitor\\n\");\n\t\t\tinterval = 0;\n\t\t}\n\t}\n\tif (interval > 1)\n\t\tcb->primary_monitor_time = jiffies;\n\tqueue_delayed_work(cb->work_q, &cb->monitor_work, interval);\n}\n\n \nstatic bool myrb_err_status(struct myrb_hba *cb, unsigned char error,\n\t\tunsigned char parm0, unsigned char parm1)\n{\n\tstruct pci_dev *pdev = cb->pdev;\n\n\tswitch (error) {\n\tcase 0x00:\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Physical Device %d:%d Not Responding\\n\",\n\t\t\t parm1, parm0);\n\t\tbreak;\n\tcase 0x08:\n\t\tdev_notice(&pdev->dev, \"Spinning Up Drives\\n\");\n\t\tbreak;\n\tcase 0x30:\n\t\tdev_notice(&pdev->dev, \"Configuration Checksum Error\\n\");\n\t\tbreak;\n\tcase 0x60:\n\t\tdev_notice(&pdev->dev, \"Mirror Race Recovery Failed\\n\");\n\t\tbreak;\n\tcase 0x70:\n\t\tdev_notice(&pdev->dev, \"Mirror Race Recovery In Progress\\n\");\n\t\tbreak;\n\tcase 0x90:\n\t\tdev_notice(&pdev->dev, \"Physical Device %d:%d COD Mismatch\\n\",\n\t\t\t   parm1, parm0);\n\t\tbreak;\n\tcase 0xA0:\n\t\tdev_notice(&pdev->dev, \"Logical Drive Installation Aborted\\n\");\n\t\tbreak;\n\tcase 0xB0:\n\t\tdev_notice(&pdev->dev, \"Mirror Race On A Critical Logical Drive\\n\");\n\t\tbreak;\n\tcase 0xD0:\n\t\tdev_notice(&pdev->dev, \"New Controller Configuration Found\\n\");\n\t\tbreak;\n\tcase 0xF0:\n\t\tdev_err(&pdev->dev, \"Fatal Memory Parity Error\\n\");\n\t\treturn true;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown Initialization Error %02X\\n\",\n\t\t\terror);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \n\n \n\nstatic inline void DAC960_LA_hw_mbox_new_cmd(void __iomem *base)\n{\n\twriteb(DAC960_LA_IDB_HWMBOX_NEW_CMD, base + DAC960_LA_IDB_OFFSET);\n}\n\nstatic inline void DAC960_LA_ack_hw_mbox_status(void __iomem *base)\n{\n\twriteb(DAC960_LA_IDB_HWMBOX_ACK_STS, base + DAC960_LA_IDB_OFFSET);\n}\n\nstatic inline void DAC960_LA_reset_ctrl(void __iomem *base)\n{\n\twriteb(DAC960_LA_IDB_CTRL_RESET, base + DAC960_LA_IDB_OFFSET);\n}\n\nstatic inline void DAC960_LA_mem_mbox_new_cmd(void __iomem *base)\n{\n\twriteb(DAC960_LA_IDB_MMBOX_NEW_CMD, base + DAC960_LA_IDB_OFFSET);\n}\n\nstatic inline bool DAC960_LA_hw_mbox_is_full(void __iomem *base)\n{\n\tunsigned char idb = readb(base + DAC960_LA_IDB_OFFSET);\n\n\treturn !(idb & DAC960_LA_IDB_HWMBOX_EMPTY);\n}\n\nstatic inline bool DAC960_LA_init_in_progress(void __iomem *base)\n{\n\tunsigned char idb = readb(base + DAC960_LA_IDB_OFFSET);\n\n\treturn !(idb & DAC960_LA_IDB_INIT_DONE);\n}\n\nstatic inline void DAC960_LA_ack_hw_mbox_intr(void __iomem *base)\n{\n\twriteb(DAC960_LA_ODB_HWMBOX_ACK_IRQ, base + DAC960_LA_ODB_OFFSET);\n}\n\nstatic inline void DAC960_LA_ack_intr(void __iomem *base)\n{\n\twriteb(DAC960_LA_ODB_HWMBOX_ACK_IRQ | DAC960_LA_ODB_MMBOX_ACK_IRQ,\n\t       base + DAC960_LA_ODB_OFFSET);\n}\n\nstatic inline bool DAC960_LA_hw_mbox_status_available(void __iomem *base)\n{\n\tunsigned char odb = readb(base + DAC960_LA_ODB_OFFSET);\n\n\treturn odb & DAC960_LA_ODB_HWMBOX_STS_AVAIL;\n}\n\nstatic inline void DAC960_LA_enable_intr(void __iomem *base)\n{\n\tunsigned char odb = 0xFF;\n\n\todb &= ~DAC960_LA_IRQMASK_DISABLE_IRQ;\n\twriteb(odb, base + DAC960_LA_IRQMASK_OFFSET);\n}\n\nstatic inline void DAC960_LA_disable_intr(void __iomem *base)\n{\n\tunsigned char odb = 0xFF;\n\n\todb |= DAC960_LA_IRQMASK_DISABLE_IRQ;\n\twriteb(odb, base + DAC960_LA_IRQMASK_OFFSET);\n}\n\nstatic inline void DAC960_LA_write_cmd_mbox(union myrb_cmd_mbox *mem_mbox,\n\t\tunion myrb_cmd_mbox *mbox)\n{\n\tmem_mbox->words[1] = mbox->words[1];\n\tmem_mbox->words[2] = mbox->words[2];\n\tmem_mbox->words[3] = mbox->words[3];\n\t \n\twmb();\n\tmem_mbox->words[0] = mbox->words[0];\n\t \n\tmb();\n}\n\nstatic inline void DAC960_LA_write_hw_mbox(void __iomem *base,\n\t\tunion myrb_cmd_mbox *mbox)\n{\n\twritel(mbox->words[0], base + DAC960_LA_CMDOP_OFFSET);\n\twritel(mbox->words[1], base + DAC960_LA_MBOX4_OFFSET);\n\twritel(mbox->words[2], base + DAC960_LA_MBOX8_OFFSET);\n\twriteb(mbox->bytes[12], base + DAC960_LA_MBOX12_OFFSET);\n}\n\nstatic inline unsigned short DAC960_LA_read_status(void __iomem *base)\n{\n\treturn readw(base + DAC960_LA_STS_OFFSET);\n}\n\nstatic inline bool\nDAC960_LA_read_error_status(void __iomem *base, unsigned char *error,\n\t\tunsigned char *param0, unsigned char *param1)\n{\n\tunsigned char errsts = readb(base + DAC960_LA_ERRSTS_OFFSET);\n\n\tif (!(errsts & DAC960_LA_ERRSTS_PENDING))\n\t\treturn false;\n\terrsts &= ~DAC960_LA_ERRSTS_PENDING;\n\n\t*error = errsts;\n\t*param0 = readb(base + DAC960_LA_CMDOP_OFFSET);\n\t*param1 = readb(base + DAC960_LA_CMDID_OFFSET);\n\twriteb(0xFF, base + DAC960_LA_ERRSTS_OFFSET);\n\treturn true;\n}\n\nstatic inline unsigned short\nDAC960_LA_mbox_init(struct pci_dev *pdev, void __iomem *base,\n\t\tunion myrb_cmd_mbox *mbox)\n{\n\tunsigned short status;\n\tint timeout = 0;\n\n\twhile (timeout < MYRB_MAILBOX_TIMEOUT) {\n\t\tif (!DAC960_LA_hw_mbox_is_full(base))\n\t\t\tbreak;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (DAC960_LA_hw_mbox_is_full(base)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for empty mailbox\\n\");\n\t\treturn MYRB_STATUS_SUBSYS_TIMEOUT;\n\t}\n\tDAC960_LA_write_hw_mbox(base, mbox);\n\tDAC960_LA_hw_mbox_new_cmd(base);\n\ttimeout = 0;\n\twhile (timeout < MYRB_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_LA_hw_mbox_status_available(base))\n\t\t\tbreak;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (!DAC960_LA_hw_mbox_status_available(base)) {\n\t\tdev_err(&pdev->dev, \"Timeout waiting for mailbox status\\n\");\n\t\treturn MYRB_STATUS_SUBSYS_TIMEOUT;\n\t}\n\tstatus = DAC960_LA_read_status(base);\n\tDAC960_LA_ack_hw_mbox_intr(base);\n\tDAC960_LA_ack_hw_mbox_status(base);\n\n\treturn status;\n}\n\nstatic int DAC960_LA_hw_init(struct pci_dev *pdev,\n\t\tstruct myrb_hba *cb, void __iomem *base)\n{\n\tint timeout = 0;\n\tunsigned char error, parm0, parm1;\n\n\tDAC960_LA_disable_intr(base);\n\tDAC960_LA_ack_hw_mbox_status(base);\n\tudelay(1000);\n\twhile (DAC960_LA_init_in_progress(base) &&\n\t       timeout < MYRB_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_LA_read_error_status(base, &error,\n\t\t\t\t\t      &parm0, &parm1) &&\n\t\t    myrb_err_status(cb, error, parm0, parm1))\n\t\t\treturn -ENODEV;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (timeout == MYRB_MAILBOX_TIMEOUT) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for Controller Initialisation\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!myrb_enable_mmio(cb, DAC960_LA_mbox_init)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to Enable Memory Mailbox Interface\\n\");\n\t\tDAC960_LA_reset_ctrl(base);\n\t\treturn -ENODEV;\n\t}\n\tDAC960_LA_enable_intr(base);\n\tcb->qcmd = myrb_qcmd;\n\tcb->write_cmd_mbox = DAC960_LA_write_cmd_mbox;\n\tif (cb->dual_mode_interface)\n\t\tcb->get_cmd_mbox = DAC960_LA_mem_mbox_new_cmd;\n\telse\n\t\tcb->get_cmd_mbox = DAC960_LA_hw_mbox_new_cmd;\n\tcb->disable_intr = DAC960_LA_disable_intr;\n\tcb->reset = DAC960_LA_reset_ctrl;\n\n\treturn 0;\n}\n\nstatic irqreturn_t DAC960_LA_intr_handler(int irq, void *arg)\n{\n\tstruct myrb_hba *cb = arg;\n\tvoid __iomem *base = cb->io_base;\n\tstruct myrb_stat_mbox *next_stat_mbox;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cb->queue_lock, flags);\n\tDAC960_LA_ack_intr(base);\n\tnext_stat_mbox = cb->next_stat_mbox;\n\twhile (next_stat_mbox->valid) {\n\t\tunsigned char id = next_stat_mbox->id;\n\t\tstruct scsi_cmnd *scmd = NULL;\n\t\tstruct myrb_cmdblk *cmd_blk = NULL;\n\n\t\tif (id == MYRB_DCMD_TAG)\n\t\t\tcmd_blk = &cb->dcmd_blk;\n\t\telse if (id == MYRB_MCMD_TAG)\n\t\t\tcmd_blk = &cb->mcmd_blk;\n\t\telse {\n\t\t\tscmd = scsi_host_find_tag(cb->host, id - 3);\n\t\t\tif (scmd)\n\t\t\t\tcmd_blk = scsi_cmd_priv(scmd);\n\t\t}\n\t\tif (cmd_blk)\n\t\t\tcmd_blk->status = next_stat_mbox->status;\n\t\telse\n\t\t\tdev_err(&cb->pdev->dev,\n\t\t\t\t\"Unhandled command completion %d\\n\", id);\n\n\t\tmemset(next_stat_mbox, 0, sizeof(struct myrb_stat_mbox));\n\t\tif (++next_stat_mbox > cb->last_stat_mbox)\n\t\t\tnext_stat_mbox = cb->first_stat_mbox;\n\n\t\tif (cmd_blk) {\n\t\t\tif (id < 3)\n\t\t\t\tmyrb_handle_cmdblk(cb, cmd_blk);\n\t\t\telse\n\t\t\t\tmyrb_handle_scsi(cb, cmd_blk, scmd);\n\t\t}\n\t}\n\tcb->next_stat_mbox = next_stat_mbox;\n\tspin_unlock_irqrestore(&cb->queue_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct myrb_privdata DAC960_LA_privdata = {\n\t.hw_init =\tDAC960_LA_hw_init,\n\t.irq_handler =\tDAC960_LA_intr_handler,\n\t.mmio_size =\tDAC960_LA_mmio_size,\n};\n\n \nstatic inline void DAC960_PG_hw_mbox_new_cmd(void __iomem *base)\n{\n\twritel(DAC960_PG_IDB_HWMBOX_NEW_CMD, base + DAC960_PG_IDB_OFFSET);\n}\n\nstatic inline void DAC960_PG_ack_hw_mbox_status(void __iomem *base)\n{\n\twritel(DAC960_PG_IDB_HWMBOX_ACK_STS, base + DAC960_PG_IDB_OFFSET);\n}\n\nstatic inline void DAC960_PG_reset_ctrl(void __iomem *base)\n{\n\twritel(DAC960_PG_IDB_CTRL_RESET, base + DAC960_PG_IDB_OFFSET);\n}\n\nstatic inline void DAC960_PG_mem_mbox_new_cmd(void __iomem *base)\n{\n\twritel(DAC960_PG_IDB_MMBOX_NEW_CMD, base + DAC960_PG_IDB_OFFSET);\n}\n\nstatic inline bool DAC960_PG_hw_mbox_is_full(void __iomem *base)\n{\n\tunsigned char idb = readl(base + DAC960_PG_IDB_OFFSET);\n\n\treturn idb & DAC960_PG_IDB_HWMBOX_FULL;\n}\n\nstatic inline bool DAC960_PG_init_in_progress(void __iomem *base)\n{\n\tunsigned char idb = readl(base + DAC960_PG_IDB_OFFSET);\n\n\treturn idb & DAC960_PG_IDB_INIT_IN_PROGRESS;\n}\n\nstatic inline void DAC960_PG_ack_hw_mbox_intr(void __iomem *base)\n{\n\twritel(DAC960_PG_ODB_HWMBOX_ACK_IRQ, base + DAC960_PG_ODB_OFFSET);\n}\n\nstatic inline void DAC960_PG_ack_intr(void __iomem *base)\n{\n\twritel(DAC960_PG_ODB_HWMBOX_ACK_IRQ | DAC960_PG_ODB_MMBOX_ACK_IRQ,\n\t       base + DAC960_PG_ODB_OFFSET);\n}\n\nstatic inline bool DAC960_PG_hw_mbox_status_available(void __iomem *base)\n{\n\tunsigned char odb = readl(base + DAC960_PG_ODB_OFFSET);\n\n\treturn odb & DAC960_PG_ODB_HWMBOX_STS_AVAIL;\n}\n\nstatic inline void DAC960_PG_enable_intr(void __iomem *base)\n{\n\tunsigned int imask = (unsigned int)-1;\n\n\timask &= ~DAC960_PG_IRQMASK_DISABLE_IRQ;\n\twritel(imask, base + DAC960_PG_IRQMASK_OFFSET);\n}\n\nstatic inline void DAC960_PG_disable_intr(void __iomem *base)\n{\n\tunsigned int imask = (unsigned int)-1;\n\n\twritel(imask, base + DAC960_PG_IRQMASK_OFFSET);\n}\n\nstatic inline void DAC960_PG_write_cmd_mbox(union myrb_cmd_mbox *mem_mbox,\n\t\tunion myrb_cmd_mbox *mbox)\n{\n\tmem_mbox->words[1] = mbox->words[1];\n\tmem_mbox->words[2] = mbox->words[2];\n\tmem_mbox->words[3] = mbox->words[3];\n\t \n\twmb();\n\tmem_mbox->words[0] = mbox->words[0];\n\t \n\tmb();\n}\n\nstatic inline void DAC960_PG_write_hw_mbox(void __iomem *base,\n\t\tunion myrb_cmd_mbox *mbox)\n{\n\twritel(mbox->words[0], base + DAC960_PG_CMDOP_OFFSET);\n\twritel(mbox->words[1], base + DAC960_PG_MBOX4_OFFSET);\n\twritel(mbox->words[2], base + DAC960_PG_MBOX8_OFFSET);\n\twriteb(mbox->bytes[12], base + DAC960_PG_MBOX12_OFFSET);\n}\n\nstatic inline unsigned short\nDAC960_PG_read_status(void __iomem *base)\n{\n\treturn readw(base + DAC960_PG_STS_OFFSET);\n}\n\nstatic inline bool\nDAC960_PG_read_error_status(void __iomem *base, unsigned char *error,\n\t\tunsigned char *param0, unsigned char *param1)\n{\n\tunsigned char errsts = readb(base + DAC960_PG_ERRSTS_OFFSET);\n\n\tif (!(errsts & DAC960_PG_ERRSTS_PENDING))\n\t\treturn false;\n\terrsts &= ~DAC960_PG_ERRSTS_PENDING;\n\t*error = errsts;\n\t*param0 = readb(base + DAC960_PG_CMDOP_OFFSET);\n\t*param1 = readb(base + DAC960_PG_CMDID_OFFSET);\n\twriteb(0, base + DAC960_PG_ERRSTS_OFFSET);\n\treturn true;\n}\n\nstatic inline unsigned short\nDAC960_PG_mbox_init(struct pci_dev *pdev, void __iomem *base,\n\t\tunion myrb_cmd_mbox *mbox)\n{\n\tunsigned short status;\n\tint timeout = 0;\n\n\twhile (timeout < MYRB_MAILBOX_TIMEOUT) {\n\t\tif (!DAC960_PG_hw_mbox_is_full(base))\n\t\t\tbreak;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (DAC960_PG_hw_mbox_is_full(base)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for empty mailbox\\n\");\n\t\treturn MYRB_STATUS_SUBSYS_TIMEOUT;\n\t}\n\tDAC960_PG_write_hw_mbox(base, mbox);\n\tDAC960_PG_hw_mbox_new_cmd(base);\n\n\ttimeout = 0;\n\twhile (timeout < MYRB_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_PG_hw_mbox_status_available(base))\n\t\t\tbreak;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (!DAC960_PG_hw_mbox_status_available(base)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for mailbox status\\n\");\n\t\treturn MYRB_STATUS_SUBSYS_TIMEOUT;\n\t}\n\tstatus = DAC960_PG_read_status(base);\n\tDAC960_PG_ack_hw_mbox_intr(base);\n\tDAC960_PG_ack_hw_mbox_status(base);\n\n\treturn status;\n}\n\nstatic int DAC960_PG_hw_init(struct pci_dev *pdev,\n\t\tstruct myrb_hba *cb, void __iomem *base)\n{\n\tint timeout = 0;\n\tunsigned char error, parm0, parm1;\n\n\tDAC960_PG_disable_intr(base);\n\tDAC960_PG_ack_hw_mbox_status(base);\n\tudelay(1000);\n\twhile (DAC960_PG_init_in_progress(base) &&\n\t       timeout < MYRB_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_PG_read_error_status(base, &error,\n\t\t\t\t\t\t&parm0, &parm1) &&\n\t\t    myrb_err_status(cb, error, parm0, parm1))\n\t\t\treturn -EIO;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (timeout == MYRB_MAILBOX_TIMEOUT) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for Controller Initialisation\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!myrb_enable_mmio(cb, DAC960_PG_mbox_init)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to Enable Memory Mailbox Interface\\n\");\n\t\tDAC960_PG_reset_ctrl(base);\n\t\treturn -ENODEV;\n\t}\n\tDAC960_PG_enable_intr(base);\n\tcb->qcmd = myrb_qcmd;\n\tcb->write_cmd_mbox = DAC960_PG_write_cmd_mbox;\n\tif (cb->dual_mode_interface)\n\t\tcb->get_cmd_mbox = DAC960_PG_mem_mbox_new_cmd;\n\telse\n\t\tcb->get_cmd_mbox = DAC960_PG_hw_mbox_new_cmd;\n\tcb->disable_intr = DAC960_PG_disable_intr;\n\tcb->reset = DAC960_PG_reset_ctrl;\n\n\treturn 0;\n}\n\nstatic irqreturn_t DAC960_PG_intr_handler(int irq, void *arg)\n{\n\tstruct myrb_hba *cb = arg;\n\tvoid __iomem *base = cb->io_base;\n\tstruct myrb_stat_mbox *next_stat_mbox;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cb->queue_lock, flags);\n\tDAC960_PG_ack_intr(base);\n\tnext_stat_mbox = cb->next_stat_mbox;\n\twhile (next_stat_mbox->valid) {\n\t\tunsigned char id = next_stat_mbox->id;\n\t\tstruct scsi_cmnd *scmd = NULL;\n\t\tstruct myrb_cmdblk *cmd_blk = NULL;\n\n\t\tif (id == MYRB_DCMD_TAG)\n\t\t\tcmd_blk = &cb->dcmd_blk;\n\t\telse if (id == MYRB_MCMD_TAG)\n\t\t\tcmd_blk = &cb->mcmd_blk;\n\t\telse {\n\t\t\tscmd = scsi_host_find_tag(cb->host, id - 3);\n\t\t\tif (scmd)\n\t\t\t\tcmd_blk = scsi_cmd_priv(scmd);\n\t\t}\n\t\tif (cmd_blk)\n\t\t\tcmd_blk->status = next_stat_mbox->status;\n\t\telse\n\t\t\tdev_err(&cb->pdev->dev,\n\t\t\t\t\"Unhandled command completion %d\\n\", id);\n\n\t\tmemset(next_stat_mbox, 0, sizeof(struct myrb_stat_mbox));\n\t\tif (++next_stat_mbox > cb->last_stat_mbox)\n\t\t\tnext_stat_mbox = cb->first_stat_mbox;\n\n\t\tif (id < 3)\n\t\t\tmyrb_handle_cmdblk(cb, cmd_blk);\n\t\telse\n\t\t\tmyrb_handle_scsi(cb, cmd_blk, scmd);\n\t}\n\tcb->next_stat_mbox = next_stat_mbox;\n\tspin_unlock_irqrestore(&cb->queue_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct myrb_privdata DAC960_PG_privdata = {\n\t.hw_init =\tDAC960_PG_hw_init,\n\t.irq_handler =\tDAC960_PG_intr_handler,\n\t.mmio_size =\tDAC960_PG_mmio_size,\n};\n\n\n \n\nstatic inline void DAC960_PD_hw_mbox_new_cmd(void __iomem *base)\n{\n\twriteb(DAC960_PD_IDB_HWMBOX_NEW_CMD, base + DAC960_PD_IDB_OFFSET);\n}\n\nstatic inline void DAC960_PD_ack_hw_mbox_status(void __iomem *base)\n{\n\twriteb(DAC960_PD_IDB_HWMBOX_ACK_STS, base + DAC960_PD_IDB_OFFSET);\n}\n\nstatic inline void DAC960_PD_reset_ctrl(void __iomem *base)\n{\n\twriteb(DAC960_PD_IDB_CTRL_RESET, base + DAC960_PD_IDB_OFFSET);\n}\n\nstatic inline bool DAC960_PD_hw_mbox_is_full(void __iomem *base)\n{\n\tunsigned char idb = readb(base + DAC960_PD_IDB_OFFSET);\n\n\treturn idb & DAC960_PD_IDB_HWMBOX_FULL;\n}\n\nstatic inline bool DAC960_PD_init_in_progress(void __iomem *base)\n{\n\tunsigned char idb = readb(base + DAC960_PD_IDB_OFFSET);\n\n\treturn idb & DAC960_PD_IDB_INIT_IN_PROGRESS;\n}\n\nstatic inline void DAC960_PD_ack_intr(void __iomem *base)\n{\n\twriteb(DAC960_PD_ODB_HWMBOX_ACK_IRQ, base + DAC960_PD_ODB_OFFSET);\n}\n\nstatic inline bool DAC960_PD_hw_mbox_status_available(void __iomem *base)\n{\n\tunsigned char odb = readb(base + DAC960_PD_ODB_OFFSET);\n\n\treturn odb & DAC960_PD_ODB_HWMBOX_STS_AVAIL;\n}\n\nstatic inline void DAC960_PD_enable_intr(void __iomem *base)\n{\n\twriteb(DAC960_PD_IRQMASK_ENABLE_IRQ, base + DAC960_PD_IRQEN_OFFSET);\n}\n\nstatic inline void DAC960_PD_disable_intr(void __iomem *base)\n{\n\twriteb(0, base + DAC960_PD_IRQEN_OFFSET);\n}\n\nstatic inline void DAC960_PD_write_cmd_mbox(void __iomem *base,\n\t\tunion myrb_cmd_mbox *mbox)\n{\n\twritel(mbox->words[0], base + DAC960_PD_CMDOP_OFFSET);\n\twritel(mbox->words[1], base + DAC960_PD_MBOX4_OFFSET);\n\twritel(mbox->words[2], base + DAC960_PD_MBOX8_OFFSET);\n\twriteb(mbox->bytes[12], base + DAC960_PD_MBOX12_OFFSET);\n}\n\nstatic inline unsigned char\nDAC960_PD_read_status_cmd_ident(void __iomem *base)\n{\n\treturn readb(base + DAC960_PD_STSID_OFFSET);\n}\n\nstatic inline unsigned short\nDAC960_PD_read_status(void __iomem *base)\n{\n\treturn readw(base + DAC960_PD_STS_OFFSET);\n}\n\nstatic inline bool\nDAC960_PD_read_error_status(void __iomem *base, unsigned char *error,\n\t\tunsigned char *param0, unsigned char *param1)\n{\n\tunsigned char errsts = readb(base + DAC960_PD_ERRSTS_OFFSET);\n\n\tif (!(errsts & DAC960_PD_ERRSTS_PENDING))\n\t\treturn false;\n\terrsts &= ~DAC960_PD_ERRSTS_PENDING;\n\t*error = errsts;\n\t*param0 = readb(base + DAC960_PD_CMDOP_OFFSET);\n\t*param1 = readb(base + DAC960_PD_CMDID_OFFSET);\n\twriteb(0, base + DAC960_PD_ERRSTS_OFFSET);\n\treturn true;\n}\n\nstatic void DAC960_PD_qcmd(struct myrb_hba *cb, struct myrb_cmdblk *cmd_blk)\n{\n\tvoid __iomem *base = cb->io_base;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\n\twhile (DAC960_PD_hw_mbox_is_full(base))\n\t\tudelay(1);\n\tDAC960_PD_write_cmd_mbox(base, mbox);\n\tDAC960_PD_hw_mbox_new_cmd(base);\n}\n\nstatic int DAC960_PD_hw_init(struct pci_dev *pdev,\n\t\tstruct myrb_hba *cb, void __iomem *base)\n{\n\tint timeout = 0;\n\tunsigned char error, parm0, parm1;\n\n\tif (!request_region(cb->io_addr, 0x80, \"myrb\")) {\n\t\tdev_err(&pdev->dev, \"IO port 0x%lx busy\\n\",\n\t\t\t(unsigned long)cb->io_addr);\n\t\treturn -EBUSY;\n\t}\n\tDAC960_PD_disable_intr(base);\n\tDAC960_PD_ack_hw_mbox_status(base);\n\tudelay(1000);\n\twhile (DAC960_PD_init_in_progress(base) &&\n\t       timeout < MYRB_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_PD_read_error_status(base, &error,\n\t\t\t\t\t      &parm0, &parm1) &&\n\t\t    myrb_err_status(cb, error, parm0, parm1))\n\t\t\treturn -EIO;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (timeout == MYRB_MAILBOX_TIMEOUT) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for Controller Initialisation\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!myrb_enable_mmio(cb, NULL)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to Enable Memory Mailbox Interface\\n\");\n\t\tDAC960_PD_reset_ctrl(base);\n\t\treturn -ENODEV;\n\t}\n\tDAC960_PD_enable_intr(base);\n\tcb->qcmd = DAC960_PD_qcmd;\n\tcb->disable_intr = DAC960_PD_disable_intr;\n\tcb->reset = DAC960_PD_reset_ctrl;\n\n\treturn 0;\n}\n\nstatic irqreturn_t DAC960_PD_intr_handler(int irq, void *arg)\n{\n\tstruct myrb_hba *cb = arg;\n\tvoid __iomem *base = cb->io_base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cb->queue_lock, flags);\n\twhile (DAC960_PD_hw_mbox_status_available(base)) {\n\t\tunsigned char id = DAC960_PD_read_status_cmd_ident(base);\n\t\tstruct scsi_cmnd *scmd = NULL;\n\t\tstruct myrb_cmdblk *cmd_blk = NULL;\n\n\t\tif (id == MYRB_DCMD_TAG)\n\t\t\tcmd_blk = &cb->dcmd_blk;\n\t\telse if (id == MYRB_MCMD_TAG)\n\t\t\tcmd_blk = &cb->mcmd_blk;\n\t\telse {\n\t\t\tscmd = scsi_host_find_tag(cb->host, id - 3);\n\t\t\tif (scmd)\n\t\t\t\tcmd_blk = scsi_cmd_priv(scmd);\n\t\t}\n\t\tif (cmd_blk)\n\t\t\tcmd_blk->status = DAC960_PD_read_status(base);\n\t\telse\n\t\t\tdev_err(&cb->pdev->dev,\n\t\t\t\t\"Unhandled command completion %d\\n\", id);\n\n\t\tDAC960_PD_ack_intr(base);\n\t\tDAC960_PD_ack_hw_mbox_status(base);\n\n\t\tif (id < 3)\n\t\t\tmyrb_handle_cmdblk(cb, cmd_blk);\n\t\telse\n\t\t\tmyrb_handle_scsi(cb, cmd_blk, scmd);\n\t}\n\tspin_unlock_irqrestore(&cb->queue_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct myrb_privdata DAC960_PD_privdata = {\n\t.hw_init =\tDAC960_PD_hw_init,\n\t.irq_handler =\tDAC960_PD_intr_handler,\n\t.mmio_size =\tDAC960_PD_mmio_size,\n};\n\n\n \n\nstatic inline void myrb_translate_enquiry(void *enq)\n{\n\tmemcpy(enq + 132, enq + 36, 64);\n\tmemset(enq + 36, 0, 96);\n}\n\nstatic inline void myrb_translate_devstate(void *state)\n{\n\tmemcpy(state + 2, state + 3, 1);\n\tmemmove(state + 4, state + 5, 2);\n\tmemmove(state + 6, state + 8, 4);\n}\n\nstatic inline void myrb_translate_to_rw_command(struct myrb_cmdblk *cmd_blk)\n{\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tint ldev_num = mbox->type5.ld.ldev_num;\n\n\tmbox->bytes[3] &= 0x7;\n\tmbox->bytes[3] |= mbox->bytes[7] << 6;\n\tmbox->bytes[7] = ldev_num;\n}\n\nstatic inline void myrb_translate_from_rw_command(struct myrb_cmdblk *cmd_blk)\n{\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\tint ldev_num = mbox->bytes[7];\n\n\tmbox->bytes[7] = mbox->bytes[3] >> 6;\n\tmbox->bytes[3] &= 0x7;\n\tmbox->bytes[3] |= ldev_num << 3;\n}\n\nstatic void DAC960_P_qcmd(struct myrb_hba *cb, struct myrb_cmdblk *cmd_blk)\n{\n\tvoid __iomem *base = cb->io_base;\n\tunion myrb_cmd_mbox *mbox = &cmd_blk->mbox;\n\n\tswitch (mbox->common.opcode) {\n\tcase MYRB_CMD_ENQUIRY:\n\t\tmbox->common.opcode = MYRB_CMD_ENQUIRY_OLD;\n\t\tbreak;\n\tcase MYRB_CMD_GET_DEVICE_STATE:\n\t\tmbox->common.opcode = MYRB_CMD_GET_DEVICE_STATE_OLD;\n\t\tbreak;\n\tcase MYRB_CMD_READ:\n\t\tmbox->common.opcode = MYRB_CMD_READ_OLD;\n\t\tmyrb_translate_to_rw_command(cmd_blk);\n\t\tbreak;\n\tcase MYRB_CMD_WRITE:\n\t\tmbox->common.opcode = MYRB_CMD_WRITE_OLD;\n\t\tmyrb_translate_to_rw_command(cmd_blk);\n\t\tbreak;\n\tcase MYRB_CMD_READ_SG:\n\t\tmbox->common.opcode = MYRB_CMD_READ_SG_OLD;\n\t\tmyrb_translate_to_rw_command(cmd_blk);\n\t\tbreak;\n\tcase MYRB_CMD_WRITE_SG:\n\t\tmbox->common.opcode = MYRB_CMD_WRITE_SG_OLD;\n\t\tmyrb_translate_to_rw_command(cmd_blk);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\twhile (DAC960_PD_hw_mbox_is_full(base))\n\t\tudelay(1);\n\tDAC960_PD_write_cmd_mbox(base, mbox);\n\tDAC960_PD_hw_mbox_new_cmd(base);\n}\n\n\nstatic int DAC960_P_hw_init(struct pci_dev *pdev,\n\t\tstruct myrb_hba *cb, void __iomem *base)\n{\n\tint timeout = 0;\n\tunsigned char error, parm0, parm1;\n\n\tif (!request_region(cb->io_addr, 0x80, \"myrb\")) {\n\t\tdev_err(&pdev->dev, \"IO port 0x%lx busy\\n\",\n\t\t\t(unsigned long)cb->io_addr);\n\t\treturn -EBUSY;\n\t}\n\tDAC960_PD_disable_intr(base);\n\tDAC960_PD_ack_hw_mbox_status(base);\n\tudelay(1000);\n\twhile (DAC960_PD_init_in_progress(base) &&\n\t       timeout < MYRB_MAILBOX_TIMEOUT) {\n\t\tif (DAC960_PD_read_error_status(base, &error,\n\t\t\t\t\t\t&parm0, &parm1) &&\n\t\t    myrb_err_status(cb, error, parm0, parm1))\n\t\t\treturn -EAGAIN;\n\t\tudelay(10);\n\t\ttimeout++;\n\t}\n\tif (timeout == MYRB_MAILBOX_TIMEOUT) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Timeout waiting for Controller Initialisation\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\tif (!myrb_enable_mmio(cb, NULL)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to allocate DMA mapped memory\\n\");\n\t\tDAC960_PD_reset_ctrl(base);\n\t\treturn -ETIMEDOUT;\n\t}\n\tDAC960_PD_enable_intr(base);\n\tcb->qcmd = DAC960_P_qcmd;\n\tcb->disable_intr = DAC960_PD_disable_intr;\n\tcb->reset = DAC960_PD_reset_ctrl;\n\n\treturn 0;\n}\n\nstatic irqreturn_t DAC960_P_intr_handler(int irq, void *arg)\n{\n\tstruct myrb_hba *cb = arg;\n\tvoid __iomem *base = cb->io_base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cb->queue_lock, flags);\n\twhile (DAC960_PD_hw_mbox_status_available(base)) {\n\t\tunsigned char id = DAC960_PD_read_status_cmd_ident(base);\n\t\tstruct scsi_cmnd *scmd = NULL;\n\t\tstruct myrb_cmdblk *cmd_blk = NULL;\n\t\tunion myrb_cmd_mbox *mbox;\n\t\tenum myrb_cmd_opcode op;\n\n\n\t\tif (id == MYRB_DCMD_TAG)\n\t\t\tcmd_blk = &cb->dcmd_blk;\n\t\telse if (id == MYRB_MCMD_TAG)\n\t\t\tcmd_blk = &cb->mcmd_blk;\n\t\telse {\n\t\t\tscmd = scsi_host_find_tag(cb->host, id - 3);\n\t\t\tif (scmd)\n\t\t\t\tcmd_blk = scsi_cmd_priv(scmd);\n\t\t}\n\t\tif (cmd_blk)\n\t\t\tcmd_blk->status = DAC960_PD_read_status(base);\n\t\telse\n\t\t\tdev_err(&cb->pdev->dev,\n\t\t\t\t\"Unhandled command completion %d\\n\", id);\n\n\t\tDAC960_PD_ack_intr(base);\n\t\tDAC960_PD_ack_hw_mbox_status(base);\n\n\t\tif (!cmd_blk)\n\t\t\tcontinue;\n\n\t\tmbox = &cmd_blk->mbox;\n\t\top = mbox->common.opcode;\n\t\tswitch (op) {\n\t\tcase MYRB_CMD_ENQUIRY_OLD:\n\t\t\tmbox->common.opcode = MYRB_CMD_ENQUIRY;\n\t\t\tmyrb_translate_enquiry(cb->enquiry);\n\t\t\tbreak;\n\t\tcase MYRB_CMD_READ_OLD:\n\t\t\tmbox->common.opcode = MYRB_CMD_READ;\n\t\t\tmyrb_translate_from_rw_command(cmd_blk);\n\t\t\tbreak;\n\t\tcase MYRB_CMD_WRITE_OLD:\n\t\t\tmbox->common.opcode = MYRB_CMD_WRITE;\n\t\t\tmyrb_translate_from_rw_command(cmd_blk);\n\t\t\tbreak;\n\t\tcase MYRB_CMD_READ_SG_OLD:\n\t\t\tmbox->common.opcode = MYRB_CMD_READ_SG;\n\t\t\tmyrb_translate_from_rw_command(cmd_blk);\n\t\t\tbreak;\n\t\tcase MYRB_CMD_WRITE_SG_OLD:\n\t\t\tmbox->common.opcode = MYRB_CMD_WRITE_SG;\n\t\t\tmyrb_translate_from_rw_command(cmd_blk);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (id < 3)\n\t\t\tmyrb_handle_cmdblk(cb, cmd_blk);\n\t\telse\n\t\t\tmyrb_handle_scsi(cb, cmd_blk, scmd);\n\t}\n\tspin_unlock_irqrestore(&cb->queue_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic struct myrb_privdata DAC960_P_privdata = {\n\t.hw_init =\tDAC960_P_hw_init,\n\t.irq_handler =\tDAC960_P_intr_handler,\n\t.mmio_size =\tDAC960_PD_mmio_size,\n};\n\nstatic struct myrb_hba *myrb_detect(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *entry)\n{\n\tstruct myrb_privdata *privdata =\n\t\t(struct myrb_privdata *)entry->driver_data;\n\tirq_handler_t irq_handler = privdata->irq_handler;\n\tunsigned int mmio_size = privdata->mmio_size;\n\tstruct Scsi_Host *shost;\n\tstruct myrb_hba *cb = NULL;\n\n\tshost = scsi_host_alloc(&myrb_template, sizeof(struct myrb_hba));\n\tif (!shost) {\n\t\tdev_err(&pdev->dev, \"Unable to allocate Controller\\n\");\n\t\treturn NULL;\n\t}\n\tshost->max_cmd_len = 12;\n\tshost->max_lun = 256;\n\tcb = shost_priv(shost);\n\tmutex_init(&cb->dcmd_mutex);\n\tmutex_init(&cb->dma_mutex);\n\tcb->pdev = pdev;\n\tcb->host = shost;\n\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCI device\\n\");\n\t\tscsi_host_put(shost);\n\t\treturn NULL;\n\t}\n\n\tif (privdata->hw_init == DAC960_PD_hw_init ||\n\t    privdata->hw_init == DAC960_P_hw_init) {\n\t\tcb->io_addr = pci_resource_start(pdev, 0);\n\t\tcb->pci_addr = pci_resource_start(pdev, 1);\n\t} else\n\t\tcb->pci_addr = pci_resource_start(pdev, 0);\n\n\tpci_set_drvdata(pdev, cb);\n\tspin_lock_init(&cb->queue_lock);\n\tif (mmio_size < PAGE_SIZE)\n\t\tmmio_size = PAGE_SIZE;\n\tcb->mmio_base = ioremap(cb->pci_addr & PAGE_MASK, mmio_size);\n\tif (cb->mmio_base == NULL) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to map Controller Register Window\\n\");\n\t\tgoto failure;\n\t}\n\n\tcb->io_base = cb->mmio_base + (cb->pci_addr & ~PAGE_MASK);\n\tif (privdata->hw_init(pdev, cb, cb->io_base))\n\t\tgoto failure;\n\n\tif (request_irq(pdev->irq, irq_handler, IRQF_SHARED, \"myrb\", cb) < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to acquire IRQ Channel %d\\n\", pdev->irq);\n\t\tgoto failure;\n\t}\n\tcb->irq = pdev->irq;\n\treturn cb;\n\nfailure:\n\tdev_err(&pdev->dev,\n\t\t\"Failed to initialize Controller\\n\");\n\tmyrb_cleanup(cb);\n\treturn NULL;\n}\n\nstatic int myrb_probe(struct pci_dev *dev, const struct pci_device_id *entry)\n{\n\tstruct myrb_hba *cb;\n\tint ret;\n\n\tcb = myrb_detect(dev, entry);\n\tif (!cb)\n\t\treturn -ENODEV;\n\n\tret = myrb_get_hba_config(cb);\n\tif (ret < 0) {\n\t\tmyrb_cleanup(cb);\n\t\treturn ret;\n\t}\n\n\tif (!myrb_create_mempools(dev, cb)) {\n\t\tret = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tret = scsi_add_host(cb->host, &dev->dev);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"scsi_add_host failed with %d\\n\", ret);\n\t\tmyrb_destroy_mempools(cb);\n\t\tgoto failed;\n\t}\n\tscsi_scan_host(cb->host);\n\treturn 0;\nfailed:\n\tmyrb_cleanup(cb);\n\treturn ret;\n}\n\n\nstatic void myrb_remove(struct pci_dev *pdev)\n{\n\tstruct myrb_hba *cb = pci_get_drvdata(pdev);\n\n\tshost_printk(KERN_NOTICE, cb->host, \"Flushing Cache...\");\n\tmyrb_exec_type3(cb, MYRB_CMD_FLUSH, 0);\n\tmyrb_cleanup(cb);\n\tmyrb_destroy_mempools(cb);\n}\n\n\nstatic const struct pci_device_id myrb_id_table[] = {\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_DEC,\n\t\t\t       PCI_DEVICE_ID_DEC_21285,\n\t\t\t       PCI_VENDOR_ID_MYLEX,\n\t\t\t       PCI_DEVICE_ID_MYLEX_DAC960_LA),\n\t\t.driver_data\t= (unsigned long) &DAC960_LA_privdata,\n\t},\n\t{\n\t\tPCI_DEVICE_DATA(MYLEX, DAC960_PG, &DAC960_PG_privdata),\n\t},\n\t{\n\t\tPCI_DEVICE_DATA(MYLEX, DAC960_PD, &DAC960_PD_privdata),\n\t},\n\t{\n\t\tPCI_DEVICE_DATA(MYLEX, DAC960_P, &DAC960_P_privdata),\n\t},\n\t{0, },\n};\n\nMODULE_DEVICE_TABLE(pci, myrb_id_table);\n\nstatic struct pci_driver myrb_pci_driver = {\n\t.name\t\t= \"myrb\",\n\t.id_table\t= myrb_id_table,\n\t.probe\t\t= myrb_probe,\n\t.remove\t\t= myrb_remove,\n};\n\nstatic int __init myrb_init_module(void)\n{\n\tint ret;\n\n\tmyrb_raid_template = raid_class_attach(&myrb_raid_functions);\n\tif (!myrb_raid_template)\n\t\treturn -ENODEV;\n\n\tret = pci_register_driver(&myrb_pci_driver);\n\tif (ret)\n\t\traid_class_release(myrb_raid_template);\n\n\treturn ret;\n}\n\nstatic void __exit myrb_cleanup_module(void)\n{\n\tpci_unregister_driver(&myrb_pci_driver);\n\traid_class_release(myrb_raid_template);\n}\n\nmodule_init(myrb_init_module);\nmodule_exit(myrb_cleanup_module);\n\nMODULE_DESCRIPTION(\"Mylex DAC960/AcceleRAID/eXtremeRAID driver (Block interface)\");\nMODULE_AUTHOR(\"Hannes Reinecke <hare@suse.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}