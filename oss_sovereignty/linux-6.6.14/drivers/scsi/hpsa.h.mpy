{
  "module_name": "hpsa.h",
  "hash_id": "5e56821afca00b977fab51493d84e7ec9879ee57df9318e77cb52a3c564b47ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/hpsa.h",
  "human_readable_source": " \n#ifndef HPSA_H\n#define HPSA_H\n\n#include <scsi/scsicam.h>\n\n#define IO_OK\t\t0\n#define IO_ERROR\t1\n\nstruct ctlr_info;\n\nstruct access_method {\n\tvoid (*submit_command)(struct ctlr_info *h,\n\t\tstruct CommandList *c);\n\tvoid (*set_intr_mask)(struct ctlr_info *h, unsigned long val);\n\tbool (*intr_pending)(struct ctlr_info *h);\n\tunsigned long (*command_completed)(struct ctlr_info *h, u8 q);\n};\n\n \nstruct hpsa_sas_node {\n\tstruct device *parent_dev;\n\tstruct list_head port_list_head;\n};\n\nstruct hpsa_sas_port {\n\tstruct list_head port_list_entry;\n\tu64 sas_address;\n\tstruct sas_port *port;\n\tint next_phy_index;\n\tstruct list_head phy_list_head;\n\tstruct hpsa_sas_node *parent_node;\n\tstruct sas_rphy *rphy;\n};\n\nstruct hpsa_sas_phy {\n\tstruct list_head phy_list_entry;\n\tstruct sas_phy *phy;\n\tstruct hpsa_sas_port *parent_port;\n\tbool added_to_port;\n};\n\n#define EXTERNAL_QD 128\nstruct hpsa_scsi_dev_t {\n\tunsigned int devtype;\n\tint bus, target, lun;\t\t \n\tunsigned char scsi3addr[8];\t \n\tu8 physical_device : 1;\n\tu8 expose_device;\n\tu8 removed : 1;\t\t\t \n\tu8 was_removed : 1;\t\t \n#define RAID_CTLR_LUNID \"\\0\\0\\0\\0\\0\\0\\0\\0\"\n\tunsigned char device_id[16];     \n\tu64 sas_address;\n\tu64 eli;\t\t\t \n\tunsigned char vendor[8];         \n\tunsigned char model[16];         \n\tunsigned char rev;\t\t \n\tunsigned char raid_level;\t \n\tunsigned char volume_offline;\t \n\tu16 queue_depth;\t\t \n\tatomic_t commands_outstanding;\t \n\tatomic_t ioaccel_cmds_out;\t \n\tbool in_reset;\n\tu32 ioaccel_handle;\n\tu8 active_path_index;\n\tu8 path_map;\n\tu8 bay;\n\tu8 box[8];\n\tu16 phys_connector[8];\n\tint offload_config;\t\t \n\tint offload_enabled;\t\t \n\tint offload_to_be_enabled;\n\tint hba_ioaccel_enabled;\n\tint offload_to_mirror;\t\t \n\tstruct raid_map_data raid_map;\t \n\n\t \n\tstruct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];\n\tint nphysical_disks;\n\tint supports_aborts;\n\tstruct hpsa_sas_port *sas_port;\n\tint external;    \n};\n\nstruct reply_queue_buffer {\n\tu64 *head;\n\tsize_t size;\n\tu8 wraparound;\n\tu32 current_entry;\n\tdma_addr_t busaddr;\n};\n\n#pragma pack(1)\nstruct bmic_controller_parameters {\n\tu8   led_flags;\n\tu8   enable_command_list_verification;\n\tu8   backed_out_write_drives;\n\tu16  stripes_for_parity;\n\tu8   parity_distribution_mode_flags;\n\tu16  max_driver_requests;\n\tu16  elevator_trend_count;\n\tu8   disable_elevator;\n\tu8   force_scan_complete;\n\tu8   scsi_transfer_mode;\n\tu8   force_narrow;\n\tu8   rebuild_priority;\n\tu8   expand_priority;\n\tu8   host_sdb_asic_fix;\n\tu8   pdpi_burst_from_host_disabled;\n\tchar software_name[64];\n\tchar hardware_name[32];\n\tu8   bridge_revision;\n\tu8   snapshot_priority;\n\tu32  os_specific;\n\tu8   post_prompt_timeout;\n\tu8   automatic_drive_slamming;\n\tu8   reserved1;\n\tu8   nvram_flags;\n\tu8   cache_nvram_flags;\n\tu8   drive_config_flags;\n\tu16  reserved2;\n\tu8   temp_warning_level;\n\tu8   temp_shutdown_level;\n\tu8   temp_condition_reset;\n\tu8   max_coalesce_commands;\n\tu32  max_coalesce_delay;\n\tu8   orca_password[4];\n\tu8   access_id[16];\n\tu8   reserved[356];\n};\n#pragma pack()\n\nstruct ctlr_info {\n\tunsigned int *reply_map;\n\tint\tctlr;\n\tchar\tdevname[8];\n\tchar    *product_name;\n\tstruct pci_dev *pdev;\n\tu32\tboard_id;\n\tu64\tsas_address;\n\tvoid __iomem *vaddr;\n\tunsigned long paddr;\n\tint \tnr_cmds;  \n#define HPSA_CMDS_RESERVED_FOR_ABORTS 2\n#define HPSA_CMDS_RESERVED_FOR_DRIVER 1\n\tstruct CfgTable __iomem *cfgtable;\n\tint\tinterrupts_enabled;\n\tint \tmax_commands;\n\tint\tlast_collision_tag;  \n\tatomic_t commands_outstanding;\n#\tdefine PERF_MODE_INT\t0\n#\tdefine DOORBELL_INT\t1\n#\tdefine SIMPLE_MODE_INT\t2\n#\tdefine MEMQ_MODE_INT\t3\n\tunsigned int msix_vectors;\n\tint intr_mode;  \n\tstruct access_method access;\n\n\t \n\tunsigned int Qdepth;\n\tunsigned int maxSG;\n\tspinlock_t lock;\n\tint maxsgentries;\n\tu8 max_cmd_sg_entries;\n\tint chainsize;\n\tstruct SGDescriptor **cmd_sg_list;\n\tstruct ioaccel2_sg_element **ioaccel2_cmd_sg_list;\n\n\t \n\tstruct CommandList \t*cmd_pool;\n\tdma_addr_t\t\tcmd_pool_dhandle;\n\tstruct io_accel1_cmd\t*ioaccel_cmd_pool;\n\tdma_addr_t\t\tioaccel_cmd_pool_dhandle;\n\tstruct io_accel2_cmd\t*ioaccel2_cmd_pool;\n\tdma_addr_t\t\tioaccel2_cmd_pool_dhandle;\n\tstruct ErrorInfo \t*errinfo_pool;\n\tdma_addr_t\t\terrinfo_pool_dhandle;\n\tunsigned long  \t\t*cmd_pool_bits;\n\tint\t\t\tscan_finished;\n\tu8\t\t\tscan_waiting : 1;\n\tspinlock_t\t\tscan_lock;\n\twait_queue_head_t\tscan_wait_queue;\n\n\tstruct Scsi_Host *scsi_host;\n\tspinlock_t devlock;  \n\tint ndevices;  \n\tstruct hpsa_scsi_dev_t *dev[HPSA_MAX_DEVICES];\n\t \n\tu32 trans_support;\n\tu32 trans_offset;\n\tstruct TransTable_struct __iomem *transtable;\n\tunsigned long transMethod;\n\n\t \n#define HPSA_MAX_CONCURRENT_PASSTHRUS (10)\n\tatomic_t passthru_cmds_avail;\n\n\t \n\tsize_t reply_queue_size;\n\tstruct reply_queue_buffer reply_queue[MAX_REPLY_QUEUES];\n\tu8 nreply_queues;\n\tu32 *blockFetchTable;\n\tu32 *ioaccel1_blockFetchTable;\n\tu32 *ioaccel2_blockFetchTable;\n\tu32 __iomem *ioaccel2_bft2_regs;\n\tunsigned char *hba_inquiry_data;\n\tu32 driver_support;\n\tu32 fw_support;\n\tint ioaccel_support;\n\tint ioaccel_maxsg;\n\tu64 last_intr_timestamp;\n\tu32 last_heartbeat;\n\tu64 last_heartbeat_timestamp;\n\tu32 heartbeat_sample_interval;\n\tatomic_t firmware_flash_in_progress;\n\tu32 __percpu *lockup_detected;\n\tstruct delayed_work monitor_ctlr_work;\n\tstruct delayed_work rescan_ctlr_work;\n\tstruct delayed_work event_monitor_work;\n\tint remove_in_progress;\n\t \n\tu8 q[MAX_REPLY_QUEUES];\n\tchar intrname[MAX_REPLY_QUEUES][16];\t \n\tu32 TMFSupportFlags;  \n#define HPSATMF_BITS_SUPPORTED  (1 << 0)\n#define HPSATMF_PHYS_LUN_RESET  (1 << 1)\n#define HPSATMF_PHYS_NEX_RESET  (1 << 2)\n#define HPSATMF_PHYS_TASK_ABORT (1 << 3)\n#define HPSATMF_PHYS_TSET_ABORT (1 << 4)\n#define HPSATMF_PHYS_CLEAR_ACA  (1 << 5)\n#define HPSATMF_PHYS_CLEAR_TSET (1 << 6)\n#define HPSATMF_PHYS_QRY_TASK   (1 << 7)\n#define HPSATMF_PHYS_QRY_TSET   (1 << 8)\n#define HPSATMF_PHYS_QRY_ASYNC  (1 << 9)\n#define HPSATMF_IOACCEL_ENABLED (1 << 15)\n#define HPSATMF_MASK_SUPPORTED  (1 << 16)\n#define HPSATMF_LOG_LUN_RESET   (1 << 17)\n#define HPSATMF_LOG_NEX_RESET   (1 << 18)\n#define HPSATMF_LOG_TASK_ABORT  (1 << 19)\n#define HPSATMF_LOG_TSET_ABORT  (1 << 20)\n#define HPSATMF_LOG_CLEAR_ACA   (1 << 21)\n#define HPSATMF_LOG_CLEAR_TSET  (1 << 22)\n#define HPSATMF_LOG_QRY_TASK    (1 << 23)\n#define HPSATMF_LOG_QRY_TSET    (1 << 24)\n#define HPSATMF_LOG_QRY_ASYNC   (1 << 25)\n\tu32 events;\n#define CTLR_STATE_CHANGE_EVENT\t\t\t\t(1 << 0)\n#define CTLR_ENCLOSURE_HOT_PLUG_EVENT\t\t\t(1 << 1)\n#define CTLR_STATE_CHANGE_EVENT_PHYSICAL_DRV\t\t(1 << 4)\n#define CTLR_STATE_CHANGE_EVENT_LOGICAL_DRV\t\t(1 << 5)\n#define CTLR_STATE_CHANGE_EVENT_REDUNDANT_CNTRL\t\t(1 << 6)\n#define CTLR_STATE_CHANGE_EVENT_AIO_ENABLED_DISABLED\t(1 << 30)\n#define CTLR_STATE_CHANGE_EVENT_AIO_CONFIG_CHANGE\t(1 << 31)\n\n#define RESCAN_REQUIRED_EVENT_BITS \\\n\t\t(CTLR_ENCLOSURE_HOT_PLUG_EVENT | \\\n\t\tCTLR_STATE_CHANGE_EVENT_PHYSICAL_DRV | \\\n\t\tCTLR_STATE_CHANGE_EVENT_LOGICAL_DRV | \\\n\t\tCTLR_STATE_CHANGE_EVENT_AIO_ENABLED_DISABLED | \\\n\t\tCTLR_STATE_CHANGE_EVENT_AIO_CONFIG_CHANGE)\n\tspinlock_t offline_device_lock;\n\tstruct list_head offline_device_list;\n\tint\tacciopath_status;\n\tint\tdrv_req_rescan;\n\tint\traid_offload_debug;\n\tint     discovery_polling;\n\tint     legacy_board;\n\tstruct  ReportLUNdata *lastlogicals;\n\tint\tneeds_abort_tags_swizzled;\n\tstruct workqueue_struct *resubmit_wq;\n\tstruct workqueue_struct *rescan_ctlr_wq;\n\tstruct workqueue_struct *monitor_ctlr_wq;\n\tatomic_t abort_cmds_available;\n\twait_queue_head_t event_sync_wait_queue;\n\tstruct mutex reset_mutex;\n\tu8 reset_in_progress;\n\tstruct hpsa_sas_node *sas_host;\n\tspinlock_t reset_lock;\n};\n\nstruct offline_device_entry {\n\tunsigned char scsi3addr[8];\n\tstruct list_head offline_list;\n};\n\n#define HPSA_ABORT_MSG 0\n#define HPSA_DEVICE_RESET_MSG 1\n#define HPSA_RESET_TYPE_CONTROLLER 0x00\n#define HPSA_RESET_TYPE_BUS 0x01\n#define HPSA_RESET_TYPE_LUN 0x04\n#define HPSA_PHYS_TARGET_RESET 0x99  \n#define HPSA_MSG_SEND_RETRY_LIMIT 10\n#define HPSA_MSG_SEND_RETRY_INTERVAL_MSECS (10000)\n\n \n#define HPSA_MAX_POLL_TIME_SECS (20)\n\n \n#define HPSA_TUR_RETRY_LIMIT (20)\n#define HPSA_MAX_WAIT_INTERVAL_SECS (30)\n\n \n#define HPSA_BOARD_READY_WAIT_SECS (120)\n#define HPSA_BOARD_NOT_READY_WAIT_SECS (100)\n#define HPSA_BOARD_READY_POLL_INTERVAL_MSECS (100)\n#define HPSA_BOARD_READY_POLL_INTERVAL \\\n\t((HPSA_BOARD_READY_POLL_INTERVAL_MSECS * HZ) / 1000)\n#define HPSA_BOARD_READY_ITERATIONS \\\n\t((HPSA_BOARD_READY_WAIT_SECS * 1000) / \\\n\t\tHPSA_BOARD_READY_POLL_INTERVAL_MSECS)\n#define HPSA_BOARD_NOT_READY_ITERATIONS \\\n\t((HPSA_BOARD_NOT_READY_WAIT_SECS * 1000) / \\\n\t\tHPSA_BOARD_READY_POLL_INTERVAL_MSECS)\n#define HPSA_POST_RESET_PAUSE_MSECS (3000)\n#define HPSA_POST_RESET_NOOP_RETRIES (12)\n\n \n \n#define SA5_DOORBELL\t0x20\n#define SA5_REQUEST_PORT_OFFSET\t0x40\n#define SA5_REQUEST_PORT64_LO_OFFSET 0xC0\n#define SA5_REQUEST_PORT64_HI_OFFSET 0xC4\n#define SA5_REPLY_INTR_MASK_OFFSET\t0x34\n#define SA5_REPLY_PORT_OFFSET\t\t0x44\n#define SA5_INTR_STATUS\t\t0x30\n#define SA5_SCRATCHPAD_OFFSET\t0xB0\n\n#define SA5_CTCFG_OFFSET\t0xB4\n#define SA5_CTMEM_OFFSET\t0xB8\n\n#define SA5_INTR_OFF\t\t0x08\n#define SA5B_INTR_OFF\t\t0x04\n#define SA5_INTR_PENDING\t0x08\n#define SA5B_INTR_PENDING\t0x04\n#define FIFO_EMPTY\t\t0xffffffff\n#define HPSA_FIRMWARE_READY\t0xffff0000  \n\n#define HPSA_ERROR_BIT\t\t0x02\n\n \n#define SA5_PERF_INTR_PENDING   0x04\n#define SA5_PERF_INTR_OFF       0x05\n#define SA5_OUTDB_STATUS_PERF_BIT       0x01\n#define SA5_OUTDB_CLEAR_PERF_BIT        0x01\n#define SA5_OUTDB_CLEAR         0xA0\n#define SA5_OUTDB_CLEAR_PERF_BIT        0x01\n#define SA5_OUTDB_STATUS        0x9C\n\n\n#define HPSA_INTR_ON \t1\n#define HPSA_INTR_OFF\t0\n\n \n#define IOACCEL2_INBOUND_POSTQ_32\t0x48\n#define IOACCEL2_INBOUND_POSTQ_64_LOW\t0xd0\n#define IOACCEL2_INBOUND_POSTQ_64_HI\t0xd4\n\n#define HPSA_PHYSICAL_DEVICE_BUS\t0\n#define HPSA_RAID_VOLUME_BUS\t\t1\n#define HPSA_EXTERNAL_RAID_VOLUME_BUS\t2\n#define HPSA_HBA_BUS\t\t\t0\n#define HPSA_LEGACY_HBA_BUS\t\t3\n\n \nstatic void SA5_submit_command(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\twritel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);\n\t(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);\n}\n\nstatic void SA5_submit_command_no_read(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\twritel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);\n}\n\nstatic void SA5_submit_command_ioaccel2(struct ctlr_info *h,\n\tstruct CommandList *c)\n{\n\twritel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);\n}\n\n \nstatic void SA5_intr_mask(struct ctlr_info *h, unsigned long val)\n{\n\tif (val) {  \n\t\th->interrupts_enabled = 1;\n\t\twritel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t\t(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t} else {  \n\t\th->interrupts_enabled = 0;\n\t\twritel(SA5_INTR_OFF,\n\t\t\th->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t\t(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t}\n}\n\n \nstatic void SA5B_intr_mask(struct ctlr_info *h, unsigned long val)\n{\n\tif (val) {  \n\t\th->interrupts_enabled = 1;\n\t\twritel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t\t(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t} else {  \n\t\th->interrupts_enabled = 0;\n\t\twritel(SA5B_INTR_OFF,\n\t\t       h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t\t(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t}\n}\n\nstatic void SA5_performant_intr_mask(struct ctlr_info *h, unsigned long val)\n{\n\tif (val) {  \n\t\th->interrupts_enabled = 1;\n\t\twritel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t\t(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t} else {\n\t\th->interrupts_enabled = 0;\n\t\twritel(SA5_PERF_INTR_OFF,\n\t\t\th->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t\t(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);\n\t}\n}\n\nstatic unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)\n{\n\tstruct reply_queue_buffer *rq = &h->reply_queue[q];\n\tunsigned long register_value = FIFO_EMPTY;\n\n\t \n\tif (unlikely(!(h->pdev->msi_enabled || h->msix_vectors))) {\n\t\t \n\t\t(void) readl(h->vaddr + SA5_OUTDB_STATUS);\n\t\twritel(SA5_OUTDB_CLEAR_PERF_BIT, h->vaddr + SA5_OUTDB_CLEAR);\n\t\t \n\t\t(void) readl(h->vaddr + SA5_OUTDB_STATUS);\n\t}\n\n\tif ((((u32) rq->head[rq->current_entry]) & 1) == rq->wraparound) {\n\t\tregister_value = rq->head[rq->current_entry];\n\t\trq->current_entry++;\n\t\tatomic_dec(&h->commands_outstanding);\n\t} else {\n\t\tregister_value = FIFO_EMPTY;\n\t}\n\t \n\tif (rq->current_entry == h->max_commands) {\n\t\trq->current_entry = 0;\n\t\trq->wraparound ^= 1;\n\t}\n\treturn register_value;\n}\n\n \nstatic unsigned long SA5_completed(struct ctlr_info *h,\n\t__attribute__((unused)) u8 q)\n{\n\tunsigned long register_value\n\t\t= readl(h->vaddr + SA5_REPLY_PORT_OFFSET);\n\n\tif (register_value != FIFO_EMPTY)\n\t\tatomic_dec(&h->commands_outstanding);\n\n#ifdef HPSA_DEBUG\n\tif (register_value != FIFO_EMPTY)\n\t\tdev_dbg(&h->pdev->dev, \"Read %lx back from board\\n\",\n\t\t\tregister_value);\n\telse\n\t\tdev_dbg(&h->pdev->dev, \"FIFO Empty read\\n\");\n#endif\n\n\treturn register_value;\n}\n \nstatic bool SA5_intr_pending(struct ctlr_info *h)\n{\n\tunsigned long register_value  =\n\t\treadl(h->vaddr + SA5_INTR_STATUS);\n\treturn register_value & SA5_INTR_PENDING;\n}\n\nstatic bool SA5_performant_intr_pending(struct ctlr_info *h)\n{\n\tunsigned long register_value = readl(h->vaddr + SA5_INTR_STATUS);\n\n\tif (!register_value)\n\t\treturn false;\n\n\t \n\tregister_value = readl(h->vaddr + SA5_OUTDB_STATUS);\n\treturn register_value & SA5_OUTDB_STATUS_PERF_BIT;\n}\n\n#define SA5_IOACCEL_MODE1_INTR_STATUS_CMP_BIT    0x100\n\nstatic bool SA5_ioaccel_mode1_intr_pending(struct ctlr_info *h)\n{\n\tunsigned long register_value = readl(h->vaddr + SA5_INTR_STATUS);\n\n\treturn (register_value & SA5_IOACCEL_MODE1_INTR_STATUS_CMP_BIT) ?\n\t\ttrue : false;\n}\n\n \nstatic bool SA5B_intr_pending(struct ctlr_info *h)\n{\n\treturn readl(h->vaddr + SA5_INTR_STATUS) & SA5B_INTR_PENDING;\n}\n\n#define IOACCEL_MODE1_REPLY_QUEUE_INDEX  0x1A0\n#define IOACCEL_MODE1_PRODUCER_INDEX     0x1B8\n#define IOACCEL_MODE1_CONSUMER_INDEX     0x1BC\n#define IOACCEL_MODE1_REPLY_UNUSED       0xFFFFFFFFFFFFFFFFULL\n\nstatic unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h, u8 q)\n{\n\tu64 register_value;\n\tstruct reply_queue_buffer *rq = &h->reply_queue[q];\n\n\tBUG_ON(q >= h->nreply_queues);\n\n\tregister_value = rq->head[rq->current_entry];\n\tif (register_value != IOACCEL_MODE1_REPLY_UNUSED) {\n\t\trq->head[rq->current_entry] = IOACCEL_MODE1_REPLY_UNUSED;\n\t\tif (++rq->current_entry == rq->size)\n\t\t\trq->current_entry = 0;\n\t\t \n\t\twmb();\n\t\twritel((q << 24) | rq->current_entry, h->vaddr +\n\t\t\t\tIOACCEL_MODE1_CONSUMER_INDEX);\n\t\tatomic_dec(&h->commands_outstanding);\n\t}\n\treturn (unsigned long) register_value;\n}\n\nstatic struct access_method SA5_access = {\n\t.submit_command =\tSA5_submit_command,\n\t.set_intr_mask =\tSA5_intr_mask,\n\t.intr_pending =\t\tSA5_intr_pending,\n\t.command_completed =\tSA5_completed,\n};\n\n \nstatic struct access_method SA5A_access = {\n\t.submit_command =\tSA5_submit_command,\n\t.set_intr_mask =\tSA5_intr_mask,\n\t.intr_pending =\t\tSA5_intr_pending,\n\t.command_completed =\tSA5_completed,\n};\n\nstatic struct access_method SA5B_access = {\n\t.submit_command =\tSA5_submit_command,\n\t.set_intr_mask =\tSA5B_intr_mask,\n\t.intr_pending =\t\tSA5B_intr_pending,\n\t.command_completed =\tSA5_completed,\n};\n\nstatic struct access_method SA5_ioaccel_mode1_access = {\n\t.submit_command =\tSA5_submit_command,\n\t.set_intr_mask =\tSA5_performant_intr_mask,\n\t.intr_pending =\t\tSA5_ioaccel_mode1_intr_pending,\n\t.command_completed =\tSA5_ioaccel_mode1_completed,\n};\n\nstatic struct access_method SA5_ioaccel_mode2_access = {\n\t.submit_command =\tSA5_submit_command_ioaccel2,\n\t.set_intr_mask =\tSA5_performant_intr_mask,\n\t.intr_pending =\t\tSA5_performant_intr_pending,\n\t.command_completed =\tSA5_performant_completed,\n};\n\nstatic struct access_method SA5_performant_access = {\n\t.submit_command =\tSA5_submit_command,\n\t.set_intr_mask =\tSA5_performant_intr_mask,\n\t.intr_pending =\t\tSA5_performant_intr_pending,\n\t.command_completed =\tSA5_performant_completed,\n};\n\nstatic struct access_method SA5_performant_access_no_read = {\n\t.submit_command =\tSA5_submit_command_no_read,\n\t.set_intr_mask =\tSA5_performant_intr_mask,\n\t.intr_pending =\t\tSA5_performant_intr_pending,\n\t.command_completed =\tSA5_performant_completed,\n};\n\nstruct board_type {\n\tu32\tboard_id;\n\tchar\t*product_name;\n\tstruct access_method *access;\n};\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}