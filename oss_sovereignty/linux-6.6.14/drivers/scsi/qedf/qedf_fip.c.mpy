{
  "module_name": "qedf_fip.c",
  "hash_id": "f842bb486029521d8ce32eec752a5686e028ea76ab74473a438a4db2e4e97e26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedf/qedf_fip.c",
  "human_readable_source": "\n \n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include \"qedf.h\"\n\nextern const struct qed_fcoe_ops *qed_ops;\n \n\nvoid qedf_fcoe_send_vlan_req(struct qedf_ctx *qedf)\n{\n\tstruct sk_buff *skb;\n\tchar *eth_fr;\n\tstruct fip_vlan *vlan;\n#define MY_FIP_ALL_FCF_MACS        ((__u8[6]) { 1, 0x10, 0x18, 1, 0, 2 })\n\tstatic u8 my_fcoe_all_fcfs[ETH_ALEN] = MY_FIP_ALL_FCF_MACS;\n\tunsigned long flags = 0;\n\tint rc;\n\n\tskb = dev_alloc_skb(sizeof(struct fip_vlan));\n\tif (!skb) {\n\t\tQEDF_ERR(&qedf->dbg_ctx,\n\t\t\t \"Failed to allocate skb.\\n\");\n\t\treturn;\n\t}\n\n\teth_fr = (char *)skb->data;\n\tvlan = (struct fip_vlan *)eth_fr;\n\n\tmemset(vlan, 0, sizeof(*vlan));\n\tether_addr_copy(vlan->eth.h_source, qedf->mac);\n\tether_addr_copy(vlan->eth.h_dest, my_fcoe_all_fcfs);\n\tvlan->eth.h_proto = htons(ETH_P_FIP);\n\n\tvlan->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\n\tvlan->fip.fip_op = htons(FIP_OP_VLAN);\n\tvlan->fip.fip_subcode = FIP_SC_VL_REQ;\n\tvlan->fip.fip_dl_len = htons(sizeof(vlan->desc) / FIP_BPW);\n\n\tvlan->desc.mac.fd_desc.fip_dtype = FIP_DT_MAC;\n\tvlan->desc.mac.fd_desc.fip_dlen = sizeof(vlan->desc.mac) / FIP_BPW;\n\tether_addr_copy(vlan->desc.mac.fd_mac, qedf->mac);\n\n\tvlan->desc.wwnn.fd_desc.fip_dtype = FIP_DT_NAME;\n\tvlan->desc.wwnn.fd_desc.fip_dlen = sizeof(vlan->desc.wwnn) / FIP_BPW;\n\tput_unaligned_be64(qedf->lport->wwnn, &vlan->desc.wwnn.fd_wwn);\n\n\tskb_put(skb, sizeof(*vlan));\n\tskb->protocol = htons(ETH_P_FIP);\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC, \"Sending FIP VLAN \"\n\t\t   \"request.\");\n\n\tif (atomic_read(&qedf->link_state) != QEDF_LINK_UP) {\n\t\tQEDF_WARN(&(qedf->dbg_ctx), \"Cannot send vlan request \"\n\t\t    \"because link is not up.\\n\");\n\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tset_bit(QED_LL2_XMIT_FLAGS_FIP_DISCOVERY, &flags);\n\trc = qed_ops->ll2->start_xmit(qedf->cdev, skb, flags);\n\tif (rc) {\n\t\tQEDF_ERR(&qedf->dbg_ctx, \"start_xmit failed rc = %d.\\n\", rc);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n}\n\nstatic void qedf_fcoe_process_vlan_resp(struct qedf_ctx *qedf,\n\tstruct sk_buff *skb)\n{\n\tstruct fip_header *fiph;\n\tstruct fip_desc *desc;\n\tu16 vid = 0;\n\tssize_t rlen;\n\tsize_t dlen;\n\n\tfiph = (struct fip_header *)(((void *)skb->data) + 2 * ETH_ALEN + 2);\n\n\trlen = ntohs(fiph->fip_dl_len) * 4;\n\tdesc = (struct fip_desc *)(fiph + 1);\n\twhile (rlen > 0) {\n\t\tdlen = desc->fip_dlen * FIP_BPW;\n\t\tswitch (desc->fip_dtype) {\n\t\tcase FIP_DT_VLAN:\n\t\t\tvid = ntohs(((struct fip_vlan_desc *)desc)->fd_vlan);\n\t\t\tbreak;\n\t\t}\n\t\tdesc = (struct fip_desc *)((char *)desc + dlen);\n\t\trlen -= dlen;\n\t}\n\n\tif (atomic_read(&qedf->link_state) == QEDF_LINK_DOWN) {\n\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_DISC,\n\t\t\t  \"Dropping VLAN response as link is down.\\n\");\n\t\treturn;\n\t}\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC, \"VLAN response, \"\n\t\t   \"vid=0x%x.\\n\", vid);\n\n\tif (vid > 0 && qedf->vlan_id != vid) {\n\t\tqedf_set_vlan_id(qedf, vid);\n\n\t\t \n\t\tif (!completion_done(&qedf->fipvlan_compl))\n\t\t\tcomplete(&qedf->fipvlan_compl);\n\t}\n}\n\nvoid qedf_fip_send(struct fcoe_ctlr *fip, struct sk_buff *skb)\n{\n\tstruct qedf_ctx *qedf = container_of(fip, struct qedf_ctx, ctlr);\n\tstruct ethhdr *eth_hdr;\n\tstruct fip_header *fiph;\n\tu16 op, vlan_tci = 0;\n\tu8 sub;\n\tint rc = -1;\n\n\tif (!test_bit(QEDF_LL2_STARTED, &qedf->flags)) {\n\t\tQEDF_WARN(&(qedf->dbg_ctx), \"LL2 not started\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tfiph = (struct fip_header *) ((void *)skb->data + 2 * ETH_ALEN + 2);\n\teth_hdr = (struct ethhdr *)skb_mac_header(skb);\n\top = ntohs(fiph->fip_op);\n\tsub = fiph->fip_subcode;\n\n\t \n\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), qedf->vlan_id);\n\n\t \n\t__vlan_hwaccel_get_tag(skb, &vlan_tci);\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2, \"FIP frame send: \"\n\t    \"dest=%pM op=%x sub=%x vlan=%04x.\", eth_hdr->h_dest, op, sub,\n\t    vlan_tci);\n\tif (qedf_dump_frames)\n\t\tprint_hex_dump(KERN_WARNING, \"fip \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t    skb->data, skb->len, false);\n\n\trc = qed_ops->ll2->start_xmit(qedf->cdev, skb, 0);\n\tif (rc) {\n\t\tQEDF_ERR(&qedf->dbg_ctx, \"start_xmit failed rc = %d.\\n\", rc);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n}\n\nstatic u8 fcoe_all_enode[ETH_ALEN] = FIP_ALL_ENODE_MACS;\n\n \nvoid qedf_fip_recv(struct qedf_ctx *qedf, struct sk_buff *skb)\n{\n\tstruct ethhdr *eth_hdr;\n\tstruct fip_header *fiph;\n\tstruct fip_desc *desc;\n\tstruct fip_mac_desc *mp;\n\tstruct fip_wwn_desc *wp;\n\tstruct fip_vn_desc *vp;\n\tsize_t rlen, dlen;\n\tu16 op;\n\tu8 sub;\n\tbool fcf_valid = false;\n\t \n\tbool fabric_id_valid = true;\n\tbool fc_wwpn_valid = false;\n\tu64 switch_name;\n\tu16 vlan = 0;\n\n\teth_hdr = (struct ethhdr *)skb_mac_header(skb);\n\tfiph = (struct fip_header *) ((void *)skb->data + 2 * ETH_ALEN + 2);\n\top = ntohs(fiph->fip_op);\n\tsub = fiph->fip_subcode;\n\n\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_LL2,\n\t\t  \"FIP frame received: skb=%p fiph=%p source=%pM destn=%pM op=%x sub=%x vlan=%04x\",\n\t\t  skb, fiph, eth_hdr->h_source, eth_hdr->h_dest, op,\n\t\t  sub, vlan);\n\tif (qedf_dump_frames)\n\t\tprint_hex_dump(KERN_WARNING, \"fip \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t    skb->data, skb->len, false);\n\n\tif (!ether_addr_equal(eth_hdr->h_dest, qedf->mac) &&\n\t    !ether_addr_equal(eth_hdr->h_dest, fcoe_all_enode) &&\n\t\t!ether_addr_equal(eth_hdr->h_dest, qedf->data_src_addr)) {\n\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_LL2,\n\t\t\t  \"Dropping FIP type 0x%x pkt due to destination MAC mismatch dest_mac=%pM ctlr.dest_addr=%pM data_src_addr=%pM.\\n\",\n\t\t\t  op, eth_hdr->h_dest, qedf->mac,\n\t\t\t  qedf->data_src_addr);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (op == FIP_OP_VLAN && sub == FIP_SC_VL_NOTE) {\n\t\tqedf_fcoe_process_vlan_resp(qedf, skb);\n\t\tkfree_skb(skb);\n\t} else if (op == FIP_OP_CTRL && sub == FIP_SC_CLR_VLINK) {\n\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC, \"Clear virtual \"\n\t\t\t   \"link received.\\n\");\n\n\t\t \n\t\tif (qedf->ctlr.sel_fcf == NULL) {\n\t\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC,\n\t\t\t    \"Dropping CVL since FCF has not been selected \"\n\t\t\t    \"yet.\");\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\trlen = ntohs(fiph->fip_dl_len) * FIP_BPW;\n\t\tdesc = (struct fip_desc *)(fiph + 1);\n\t\twhile (rlen >= sizeof(*desc)) {\n\t\t\tdlen = desc->fip_dlen * FIP_BPW;\n\t\t\tswitch (desc->fip_dtype) {\n\t\t\tcase FIP_DT_MAC:\n\t\t\t\tmp = (struct fip_mac_desc *)desc;\n\t\t\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_DISC,\n\t\t\t\t\t  \"Switch fd_mac=%pM.\\n\", mp->fd_mac);\n\t\t\t\tif (ether_addr_equal(mp->fd_mac,\n\t\t\t\t    qedf->ctlr.sel_fcf->fcf_mac))\n\t\t\t\t\tfcf_valid = true;\n\t\t\t\tbreak;\n\t\t\tcase FIP_DT_NAME:\n\t\t\t\twp = (struct fip_wwn_desc *)desc;\n\t\t\t\tswitch_name = get_unaligned_be64(&wp->fd_wwn);\n\t\t\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_DISC,\n\t\t\t\t\t  \"Switch fd_wwn=%016llx fcf_switch_name=%016llx.\\n\",\n\t\t\t\t\t  switch_name,\n\t\t\t\t\t  qedf->ctlr.sel_fcf->switch_name);\n\t\t\t\tif (switch_name ==\n\t\t\t\t    qedf->ctlr.sel_fcf->switch_name)\n\t\t\t\t\tfc_wwpn_valid = true;\n\t\t\t\tbreak;\n\t\t\tcase FIP_DT_VN_ID:\n\t\t\t\tfabric_id_valid = false;\n\t\t\t\tvp = (struct fip_vn_desc *)desc;\n\n\t\t\t\tQEDF_ERR(&qedf->dbg_ctx,\n\t\t\t\t\t \"CVL vx_port fd_fc_id=0x%x fd_mac=%pM fd_wwpn=%016llx.\\n\",\n\t\t\t\t\t ntoh24(vp->fd_fc_id), vp->fd_mac,\n\t\t\t\t\t get_unaligned_be64(&vp->fd_wwpn));\n\t\t\t\t \n\t\t\t\tif ((get_unaligned_be64(&vp->fd_wwpn) ==\n\t\t\t\t\tqedf->wwpn) ||\n\t\t\t\t   (ntoh24(vp->fd_fc_id) ==\n\t\t\t\t\tqedf->lport->port_id) ||\n\t\t\t\t   (ether_addr_equal(vp->fd_mac,\n\t\t\t\t\tqedf->data_src_addr))) {\n\t\t\t\t\tfabric_id_valid = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdesc = (struct fip_desc *)((char *)desc + dlen);\n\t\t\trlen -= dlen;\n\t\t}\n\n\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_DISC,\n\t\t\t  \"fcf_valid=%d fabric_id_valid=%d fc_wwpn_valid=%d.\\n\",\n\t\t\t  fcf_valid, fabric_id_valid, fc_wwpn_valid);\n\t\tif (fcf_valid && fabric_id_valid && fc_wwpn_valid)\n\t\t\tqedf_ctx_soft_reset(qedf->lport);\n\t\tkfree_skb(skb);\n\t} else {\n\t\t \n\t\t__skb_pull(skb, ETH_HLEN);\n\t\tfcoe_ctlr_recv(&qedf->ctlr, skb);\n\t}\n}\n\nu8 *qedf_get_src_mac(struct fc_lport *lport)\n{\n\tstruct qedf_ctx *qedf = lport_priv(lport);\n\n\treturn qedf->data_src_addr;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}