{
  "module_name": "qedf_attr.c",
  "hash_id": "63cc126b48340ed3b28bfd46436e7fe6fa4c0a52dbf8aa9cee8a157471b88ee5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedf/qedf_attr.c",
  "human_readable_source": "\n \n#include \"qedf.h\"\n\ninline bool qedf_is_vport(struct qedf_ctx *qedf)\n{\n\treturn qedf->lport->vport != NULL;\n}\n\n \nstatic struct qedf_ctx *qedf_get_base_qedf(struct qedf_ctx *qedf)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_lport *base_lport;\n\n\tif (!(qedf_is_vport(qedf)))\n\t\treturn NULL;\n\n\tlport = qedf->lport;\n\tbase_lport = shost_priv(vport_to_shost(lport->vport));\n\treturn lport_priv(base_lport);\n}\n\nstatic ssize_t fcoe_mac_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct fc_lport *lport = shost_priv(class_to_shost(dev));\n\tu32 port_id;\n\tu8 lport_src_id[3];\n\tu8 fcoe_mac[6];\n\n\tport_id = fc_host_port_id(lport->host);\n\tlport_src_id[2] = (port_id & 0x000000FF);\n\tlport_src_id[1] = (port_id & 0x0000FF00) >> 8;\n\tlport_src_id[0] = (port_id & 0x00FF0000) >> 16;\n\tfc_fcoe_set_mac(fcoe_mac, lport_src_id);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%pM\\n\", fcoe_mac);\n}\n\nstatic ssize_t fka_period_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct fc_lport *lport = shost_priv(class_to_shost(dev));\n\tstruct qedf_ctx *qedf = lport_priv(lport);\n\tint fka_period = -1;\n\n\tif (qedf_is_vport(qedf))\n\t\tqedf = qedf_get_base_qedf(qedf);\n\n\tif (qedf->ctlr.sel_fcf)\n\t\tfka_period = qedf->ctlr.sel_fcf->fka_period;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", fka_period);\n}\n\nstatic DEVICE_ATTR_RO(fcoe_mac);\nstatic DEVICE_ATTR_RO(fka_period);\n\nstatic struct attribute *qedf_host_attrs[] = {\n\t&dev_attr_fcoe_mac.attr,\n\t&dev_attr_fka_period.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qedf_host_attr_group = {\n\t.attrs = qedf_host_attrs\n};\n\nconst struct attribute_group *qedf_host_groups[] = {\n\t&qedf_host_attr_group,\n\tNULL\n};\n\nextern const struct qed_fcoe_ops *qed_ops;\n\nvoid qedf_capture_grc_dump(struct qedf_ctx *qedf)\n{\n\tstruct qedf_ctx *base_qedf;\n\n\t \n\tif (qedf_is_vport(qedf))\n\t\tbase_qedf = qedf_get_base_qedf(qedf);\n\telse\n\t\tbase_qedf = qedf;\n\n\tif (test_bit(QEDF_GRCDUMP_CAPTURE, &base_qedf->flags)) {\n\t\tQEDF_INFO(&(base_qedf->dbg_ctx), QEDF_LOG_INFO,\n\t\t    \"GRC Dump already captured.\\n\");\n\t\treturn;\n\t}\n\n\n\tqedf_get_grc_dump(base_qedf->cdev, qed_ops->common,\n\t    &base_qedf->grcdump, &base_qedf->grcdump_size);\n\tQEDF_ERR(&(base_qedf->dbg_ctx), \"GRC Dump captured.\\n\");\n\tset_bit(QEDF_GRCDUMP_CAPTURE, &base_qedf->flags);\n\tqedf_uevent_emit(base_qedf->lport->host, QEDF_UEVENT_CODE_GRCDUMP,\n\t    NULL);\n}\n\nstatic ssize_t\nqedf_sysfs_read_grcdump(struct file *filep, struct kobject *kobj,\n\t\t\tstruct bin_attribute *ba, char *buf, loff_t off,\n\t\t\tsize_t count)\n{\n\tssize_t ret = 0;\n\tstruct fc_lport *lport = shost_priv(dev_to_shost(container_of(kobj,\n\t\t\t\t\t\t\tstruct device, kobj)));\n\tstruct qedf_ctx *qedf = lport_priv(lport);\n\n\tif (test_bit(QEDF_GRCDUMP_CAPTURE, &qedf->flags)) {\n\t\tret = memory_read_from_buffer(buf, count, &off,\n\t\t    qedf->grcdump, qedf->grcdump_size);\n\t} else {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"GRC Dump not captured!\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t\nqedf_sysfs_write_grcdump(struct file *filep, struct kobject *kobj,\n\t\t\tstruct bin_attribute *ba, char *buf, loff_t off,\n\t\t\tsize_t count)\n{\n\tstruct fc_lport *lport = NULL;\n\tstruct qedf_ctx *qedf = NULL;\n\tlong reading;\n\tint ret = 0;\n\n\tif (off != 0)\n\t\treturn ret;\n\n\n\tlport = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tqedf = lport_priv(lport);\n\n\tbuf[1] = 0;\n\tret = kstrtol(buf, 10, &reading);\n\tif (ret) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"Invalid input, err(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (reading) {\n\tcase 0:\n\t\tmemset(qedf->grcdump, 0, qedf->grcdump_size);\n\t\tclear_bit(QEDF_GRCDUMP_CAPTURE, &qedf->flags);\n\t\tbreak;\n\tcase 1:\n\t\tqedf_capture_grc_dump(qedf);\n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_grcdump_attr = {\n\t.attr = {\n\t\t.name = \"grcdump\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 0,\n\t.read = qedf_sysfs_read_grcdump,\n\t.write = qedf_sysfs_write_grcdump,\n};\n\nstatic struct sysfs_bin_attrs bin_file_entries[] = {\n\t{\"grcdump\", &sysfs_grcdump_attr},\n\t{NULL},\n};\n\nvoid qedf_create_sysfs_ctx_attr(struct qedf_ctx *qedf)\n{\n\tqedf_create_sysfs_attr(qedf->lport->host, bin_file_entries);\n}\n\nvoid qedf_remove_sysfs_ctx_attr(struct qedf_ctx *qedf)\n{\n\tqedf_remove_sysfs_attr(qedf->lport->host, bin_file_entries);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}