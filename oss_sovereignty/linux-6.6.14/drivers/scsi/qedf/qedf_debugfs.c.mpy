{
  "module_name": "qedf_debugfs.c",
  "hash_id": "a8e6bc8d612d45c0f21c36a526c5626b665713b5c4237cf1e0a6a794002e0b64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedf/qedf_debugfs.c",
  "human_readable_source": "\n \n#ifdef CONFIG_DEBUG_FS\n\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n\n#include \"qedf.h\"\n#include \"qedf_dbg.h\"\n\nstatic struct dentry *qedf_dbg_root;\n\n \nvoid\nqedf_dbg_host_init(struct qedf_dbg_ctx *qedf,\n\t\t    const struct qedf_debugfs_ops *dops,\n\t\t    const struct file_operations *fops)\n{\n\tchar host_dirname[32];\n\n\tQEDF_INFO(qedf, QEDF_LOG_DEBUGFS, \"Creating debugfs host node\\n\");\n\t \n\tsprintf(host_dirname, \"host%u\", qedf->host_no);\n\tqedf->bdf_dentry = debugfs_create_dir(host_dirname, qedf_dbg_root);\n\n\t \n\twhile (dops) {\n\t\tif (!(dops->name))\n\t\t\tbreak;\n\n\t\tdebugfs_create_file(dops->name, 0600, qedf->bdf_dentry, qedf,\n\t\t\t\t    fops);\n\t\tdops++;\n\t\tfops++;\n\t}\n}\n\n \nvoid\nqedf_dbg_host_exit(struct qedf_dbg_ctx *qedf_dbg)\n{\n\tQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, \"Destroying debugfs host \"\n\t\t   \"entry\\n\");\n\t \n\tdebugfs_remove_recursive(qedf_dbg->bdf_dentry);\n\tqedf_dbg->bdf_dentry = NULL;\n}\n\n \nvoid\nqedf_dbg_init(char *drv_name)\n{\n\tQEDF_INFO(NULL, QEDF_LOG_DEBUGFS, \"Creating debugfs root node\\n\");\n\n\t \n\tqedf_dbg_root = debugfs_create_dir(drv_name, NULL);\n}\n\n \nvoid\nqedf_dbg_exit(void)\n{\n\tQEDF_INFO(NULL, QEDF_LOG_DEBUGFS, \"Destroying debugfs root \"\n\t\t   \"entry\\n\");\n\n\t \n\tdebugfs_remove_recursive(qedf_dbg_root);\n\tqedf_dbg_root = NULL;\n}\n\nconst struct qedf_debugfs_ops qedf_debugfs_ops[] = {\n\t{ \"fp_int\", NULL },\n\t{ \"io_trace\", NULL },\n\t{ \"debug\", NULL },\n\t{ \"stop_io_on_error\", NULL},\n\t{ \"driver_stats\", NULL},\n\t{ \"clear_stats\", NULL},\n\t{ \"offload_stats\", NULL},\n\t \n\t{ NULL, NULL }\n};\n\nDECLARE_PER_CPU(struct qedf_percpu_iothread_s, qedf_percpu_iothreads);\n\nstatic ssize_t\nqedf_dbg_fp_int_cmd_read(struct file *filp, char __user *buffer, size_t count,\n\t\t\t loff_t *ppos)\n{\n\tssize_t ret;\n\tsize_t cnt = 0;\n\tchar *cbuf;\n\tint id;\n\tstruct qedf_fastpath *fp = NULL;\n\tstruct qedf_dbg_ctx *qedf_dbg =\n\t\t\t\t(struct qedf_dbg_ctx *)filp->private_data;\n\tstruct qedf_ctx *qedf = container_of(qedf_dbg,\n\t    struct qedf_ctx, dbg_ctx);\n\n\tQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, \"entered\\n\");\n\n\tcbuf = vmalloc(QEDF_DEBUGFS_LOG_LEN);\n\tif (!cbuf)\n\t\treturn 0;\n\n\tcnt += scnprintf(cbuf + cnt, QEDF_DEBUGFS_LOG_LEN - cnt, \"\\nFastpath I/O completions\\n\\n\");\n\n\tfor (id = 0; id < qedf->num_queues; id++) {\n\t\tfp = &(qedf->fp_array[id]);\n\t\tif (fp->sb_id == QEDF_SB_ID_NULL)\n\t\t\tcontinue;\n\t\tcnt += scnprintf(cbuf + cnt, QEDF_DEBUGFS_LOG_LEN - cnt,\n\t\t\t\t \"#%d: %lu\\n\", id, fp->completions);\n\t}\n\n\tret = simple_read_from_buffer(buffer, count, ppos, cbuf, cnt);\n\n\tvfree(cbuf);\n\n\treturn ret;\n}\n\nstatic ssize_t\nqedf_dbg_fp_int_cmd_write(struct file *filp, const char __user *buffer,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tif (!count || *ppos)\n\t\treturn 0;\n\n\treturn count;\n}\n\nstatic ssize_t\nqedf_dbg_debug_cmd_read(struct file *filp, char __user *buffer, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tint cnt;\n\tchar cbuf[32];\n\tstruct qedf_dbg_ctx *qedf_dbg =\n\t\t\t\t(struct qedf_dbg_ctx *)filp->private_data;\n\n\tQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, \"debug mask=0x%x\\n\", qedf_debug);\n\tcnt = scnprintf(cbuf, sizeof(cbuf), \"debug mask = 0x%x\\n\", qedf_debug);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, cbuf, cnt);\n}\n\nstatic ssize_t\nqedf_dbg_debug_cmd_write(struct file *filp, const char __user *buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tuint32_t val;\n\tvoid *kern_buf;\n\tint rval;\n\tstruct qedf_dbg_ctx *qedf_dbg =\n\t    (struct qedf_dbg_ctx *)filp->private_data;\n\n\tif (!count || *ppos)\n\t\treturn 0;\n\n\tkern_buf = memdup_user(buffer, count);\n\tif (IS_ERR(kern_buf))\n\t\treturn PTR_ERR(kern_buf);\n\n\trval = kstrtouint(kern_buf, 10, &val);\n\tkfree(kern_buf);\n\tif (rval)\n\t\treturn rval;\n\n\tif (val == 1)\n\t\tqedf_debug = QEDF_DEFAULT_LOG_MASK;\n\telse\n\t\tqedf_debug = val;\n\n\tQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, \"Setting debug=0x%x.\\n\", val);\n\treturn count;\n}\n\nstatic ssize_t\nqedf_dbg_stop_io_on_error_cmd_read(struct file *filp, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tint cnt;\n\tchar cbuf[7];\n\tstruct qedf_dbg_ctx *qedf_dbg =\n\t\t\t\t(struct qedf_dbg_ctx *)filp->private_data;\n\tstruct qedf_ctx *qedf = container_of(qedf_dbg,\n\t    struct qedf_ctx, dbg_ctx);\n\n\tQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, \"entered\\n\");\n\tcnt = scnprintf(cbuf, sizeof(cbuf), \"%s\\n\",\n\t    qedf->stop_io_on_error ? \"true\" : \"false\");\n\n\treturn simple_read_from_buffer(buffer, count, ppos, cbuf, cnt);\n}\n\nstatic ssize_t\nqedf_dbg_stop_io_on_error_cmd_write(struct file *filp,\n\t\t\t\t    const char __user *buffer, size_t count,\n\t\t\t\t    loff_t *ppos)\n{\n\tvoid *kern_buf;\n\tstruct qedf_dbg_ctx *qedf_dbg =\n\t\t\t\t(struct qedf_dbg_ctx *)filp->private_data;\n\tstruct qedf_ctx *qedf = container_of(qedf_dbg, struct qedf_ctx,\n\t    dbg_ctx);\n\n\tQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, \"entered\\n\");\n\n\tif (!count || *ppos)\n\t\treturn 0;\n\n\tkern_buf = memdup_user(buffer, 6);\n\tif (IS_ERR(kern_buf))\n\t\treturn PTR_ERR(kern_buf);\n\n\tif (strncmp(kern_buf, \"false\", 5) == 0)\n\t\tqedf->stop_io_on_error = false;\n\telse if (strncmp(kern_buf, \"true\", 4) == 0)\n\t\tqedf->stop_io_on_error = true;\n\telse if (strncmp(kern_buf, \"now\", 3) == 0)\n\t\t \n\t\tset_bit(QEDF_DBG_STOP_IO, &qedf->flags);\n\n\tkfree(kern_buf);\n\treturn count;\n}\n\nstatic int\nqedf_io_trace_show(struct seq_file *s, void *unused)\n{\n\tint i, idx = 0;\n\tstruct qedf_ctx *qedf = s->private;\n\tstruct qedf_dbg_ctx *qedf_dbg = &qedf->dbg_ctx;\n\tstruct qedf_io_log *io_log;\n\tunsigned long flags;\n\n\tif (!qedf_io_tracing) {\n\t\tseq_puts(s, \"I/O tracing not enabled.\\n\");\n\t\tgoto out;\n\t}\n\n\tQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, \"entered\\n\");\n\n\tspin_lock_irqsave(&qedf->io_trace_lock, flags);\n\tidx = qedf->io_trace_idx;\n\tfor (i = 0; i < QEDF_IO_TRACE_SIZE; i++) {\n\t\tio_log = &qedf->io_trace_buf[idx];\n\t\tseq_printf(s, \"%d:\", io_log->direction);\n\t\tseq_printf(s, \"0x%x:\", io_log->task_id);\n\t\tseq_printf(s, \"0x%06x:\", io_log->port_id);\n\t\tseq_printf(s, \"%d:\", io_log->lun);\n\t\tseq_printf(s, \"0x%02x:\", io_log->op);\n\t\tseq_printf(s, \"0x%02x%02x%02x%02x:\", io_log->lba[0],\n\t\t    io_log->lba[1], io_log->lba[2], io_log->lba[3]);\n\t\tseq_printf(s, \"%d:\", io_log->bufflen);\n\t\tseq_printf(s, \"%d:\", io_log->sg_count);\n\t\tseq_printf(s, \"0x%08x:\", io_log->result);\n\t\tseq_printf(s, \"%lu:\", io_log->jiffies);\n\t\tseq_printf(s, \"%d:\", io_log->refcount);\n\t\tseq_printf(s, \"%d:\", io_log->req_cpu);\n\t\tseq_printf(s, \"%d:\", io_log->int_cpu);\n\t\tseq_printf(s, \"%d:\", io_log->rsp_cpu);\n\t\tseq_printf(s, \"%d\\n\", io_log->sge_type);\n\n\t\tidx++;\n\t\tif (idx == QEDF_IO_TRACE_SIZE)\n\t\t\tidx = 0;\n\t}\n\tspin_unlock_irqrestore(&qedf->io_trace_lock, flags);\n\nout:\n\treturn 0;\n}\n\nstatic int\nqedf_dbg_io_trace_open(struct inode *inode, struct file *file)\n{\n\tstruct qedf_dbg_ctx *qedf_dbg = inode->i_private;\n\tstruct qedf_ctx *qedf = container_of(qedf_dbg,\n\t    struct qedf_ctx, dbg_ctx);\n\n\treturn single_open(file, qedf_io_trace_show, qedf);\n}\n\n \nstatic char *fip_state_names[] = {\n\t\"FIP_ST_DISABLED\",\n\t\"FIP_ST_LINK_WAIT\",\n\t\"FIP_ST_AUTO\",\n\t\"FIP_ST_NON_FIP\",\n\t\"FIP_ST_ENABLED\",\n\t\"FIP_ST_VNMP_START\",\n\t\"FIP_ST_VNMP_PROBE1\",\n\t\"FIP_ST_VNMP_PROBE2\",\n\t\"FIP_ST_VNMP_CLAIM\",\n\t\"FIP_ST_VNMP_UP\",\n};\n\n \nstatic char *fc_rport_state_names[] = {\n\t\"RPORT_ST_INIT\",\n\t\"RPORT_ST_FLOGI\",\n\t\"RPORT_ST_PLOGI_WAIT\",\n\t\"RPORT_ST_PLOGI\",\n\t\"RPORT_ST_PRLI\",\n\t\"RPORT_ST_RTV\",\n\t\"RPORT_ST_READY\",\n\t\"RPORT_ST_ADISC\",\n\t\"RPORT_ST_DELETE\",\n};\n\nstatic int\nqedf_driver_stats_show(struct seq_file *s, void *unused)\n{\n\tstruct qedf_ctx *qedf = s->private;\n\tstruct qedf_rport *fcport;\n\tstruct fc_rport_priv *rdata;\n\n\tseq_printf(s, \"Host WWNN/WWPN: %016llx/%016llx\\n\",\n\t\t   qedf->wwnn, qedf->wwpn);\n\tseq_printf(s, \"Host NPortID: %06x\\n\", qedf->lport->port_id);\n\tseq_printf(s, \"Link State: %s\\n\", atomic_read(&qedf->link_state) ?\n\t    \"Up\" : \"Down\");\n\tseq_printf(s, \"Logical Link State: %s\\n\", qedf->lport->link_up ?\n\t    \"Up\" : \"Down\");\n\tseq_printf(s, \"FIP state: %s\\n\", fip_state_names[qedf->ctlr.state]);\n\tseq_printf(s, \"FIP VLAN ID: %d\\n\", qedf->vlan_id & 0xfff);\n\tseq_printf(s, \"FIP 802.1Q Priority: %d\\n\", qedf->prio);\n\tif (qedf->ctlr.sel_fcf) {\n\t\tseq_printf(s, \"FCF WWPN: %016llx\\n\",\n\t\t\t   qedf->ctlr.sel_fcf->switch_name);\n\t\tseq_printf(s, \"FCF MAC: %pM\\n\", qedf->ctlr.sel_fcf->fcf_mac);\n\t} else {\n\t\tseq_puts(s, \"FCF not selected\\n\");\n\t}\n\n\tseq_puts(s, \"\\nSGE stats:\\n\\n\");\n\tseq_printf(s, \"cmg_mgr free io_reqs: %d\\n\",\n\t    atomic_read(&qedf->cmd_mgr->free_list_cnt));\n\tseq_printf(s, \"slow SGEs: %d\\n\", qedf->slow_sge_ios);\n\tseq_printf(s, \"fast SGEs: %d\\n\\n\", qedf->fast_sge_ios);\n\n\tseq_puts(s, \"Offloaded ports:\\n\\n\");\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(fcport, &qedf->fcports, peers) {\n\t\trdata = fcport->rdata;\n\t\tif (rdata == NULL)\n\t\t\tcontinue;\n\t\tseq_printf(s, \"%016llx/%016llx/%06x: state=%s, free_sqes=%d, num_active_ios=%d\\n\",\n\t\t\t   rdata->rport->node_name, rdata->rport->port_name,\n\t\t\t   rdata->ids.port_id,\n\t\t\t   fc_rport_state_names[rdata->rp_state],\n\t\t\t   atomic_read(&fcport->free_sqes),\n\t\t\t   atomic_read(&fcport->num_active_ios));\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int\nqedf_dbg_driver_stats_open(struct inode *inode, struct file *file)\n{\n\tstruct qedf_dbg_ctx *qedf_dbg = inode->i_private;\n\tstruct qedf_ctx *qedf = container_of(qedf_dbg,\n\t    struct qedf_ctx, dbg_ctx);\n\n\treturn single_open(file, qedf_driver_stats_show, qedf);\n}\n\nstatic ssize_t\nqedf_dbg_clear_stats_cmd_read(struct file *filp, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tint cnt = 0;\n\n\t \n\tcnt = min_t(int, count, cnt - *ppos);\n\t*ppos += cnt;\n\treturn cnt;\n}\n\nstatic ssize_t\nqedf_dbg_clear_stats_cmd_write(struct file *filp,\n\t\t\t\t    const char __user *buffer, size_t count,\n\t\t\t\t    loff_t *ppos)\n{\n\tstruct qedf_dbg_ctx *qedf_dbg =\n\t\t\t\t(struct qedf_dbg_ctx *)filp->private_data;\n\tstruct qedf_ctx *qedf = container_of(qedf_dbg, struct qedf_ctx,\n\t    dbg_ctx);\n\n\tQEDF_INFO(qedf_dbg, QEDF_LOG_DEBUGFS, \"Clearing stat counters.\\n\");\n\n\tif (!count || *ppos)\n\t\treturn 0;\n\n\t \n\tqedf->slow_sge_ios = 0;\n\tqedf->fast_sge_ios = 0;\n\n\treturn count;\n}\n\nstatic int\nqedf_offload_stats_show(struct seq_file *s, void *unused)\n{\n\tstruct qedf_ctx *qedf = s->private;\n\tstruct qed_fcoe_stats *fw_fcoe_stats;\n\n\tfw_fcoe_stats = kmalloc(sizeof(struct qed_fcoe_stats), GFP_KERNEL);\n\tif (!fw_fcoe_stats) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"Could not allocate memory for \"\n\t\t    \"fw_fcoe_stats.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tqed_ops->get_stats(qedf->cdev, fw_fcoe_stats);\n\n\tseq_printf(s, \"fcoe_rx_byte_cnt=%llu\\n\"\n\t    \"fcoe_rx_data_pkt_cnt=%llu\\n\"\n\t    \"fcoe_rx_xfer_pkt_cnt=%llu\\n\"\n\t    \"fcoe_rx_other_pkt_cnt=%llu\\n\"\n\t    \"fcoe_silent_drop_pkt_cmdq_full_cnt=%u\\n\"\n\t    \"fcoe_silent_drop_pkt_crc_error_cnt=%u\\n\"\n\t    \"fcoe_silent_drop_pkt_task_invalid_cnt=%u\\n\"\n\t    \"fcoe_silent_drop_total_pkt_cnt=%u\\n\"\n\t    \"fcoe_silent_drop_pkt_rq_full_cnt=%u\\n\"\n\t    \"fcoe_tx_byte_cnt=%llu\\n\"\n\t    \"fcoe_tx_data_pkt_cnt=%llu\\n\"\n\t    \"fcoe_tx_xfer_pkt_cnt=%llu\\n\"\n\t    \"fcoe_tx_other_pkt_cnt=%llu\\n\",\n\t    fw_fcoe_stats->fcoe_rx_byte_cnt,\n\t    fw_fcoe_stats->fcoe_rx_data_pkt_cnt,\n\t    fw_fcoe_stats->fcoe_rx_xfer_pkt_cnt,\n\t    fw_fcoe_stats->fcoe_rx_other_pkt_cnt,\n\t    fw_fcoe_stats->fcoe_silent_drop_pkt_cmdq_full_cnt,\n\t    fw_fcoe_stats->fcoe_silent_drop_pkt_crc_error_cnt,\n\t    fw_fcoe_stats->fcoe_silent_drop_pkt_task_invalid_cnt,\n\t    fw_fcoe_stats->fcoe_silent_drop_total_pkt_cnt,\n\t    fw_fcoe_stats->fcoe_silent_drop_pkt_rq_full_cnt,\n\t    fw_fcoe_stats->fcoe_tx_byte_cnt,\n\t    fw_fcoe_stats->fcoe_tx_data_pkt_cnt,\n\t    fw_fcoe_stats->fcoe_tx_xfer_pkt_cnt,\n\t    fw_fcoe_stats->fcoe_tx_other_pkt_cnt);\n\n\tkfree(fw_fcoe_stats);\nout:\n\treturn 0;\n}\n\nstatic int\nqedf_dbg_offload_stats_open(struct inode *inode, struct file *file)\n{\n\tstruct qedf_dbg_ctx *qedf_dbg = inode->i_private;\n\tstruct qedf_ctx *qedf = container_of(qedf_dbg,\n\t    struct qedf_ctx, dbg_ctx);\n\n\treturn single_open(file, qedf_offload_stats_show, qedf);\n}\n\nconst struct file_operations qedf_dbg_fops[] = {\n\tqedf_dbg_fileops(qedf, fp_int),\n\tqedf_dbg_fileops_seq(qedf, io_trace),\n\tqedf_dbg_fileops(qedf, debug),\n\tqedf_dbg_fileops(qedf, stop_io_on_error),\n\tqedf_dbg_fileops_seq(qedf, driver_stats),\n\tqedf_dbg_fileops(qedf, clear_stats),\n\tqedf_dbg_fileops_seq(qedf, offload_stats),\n\t \n\t{ },\n};\n\n#else  \nvoid qedf_dbg_host_init(struct qedf_dbg_ctx *);\nvoid qedf_dbg_host_exit(struct qedf_dbg_ctx *);\nvoid qedf_dbg_init(char *);\nvoid qedf_dbg_exit(void);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}