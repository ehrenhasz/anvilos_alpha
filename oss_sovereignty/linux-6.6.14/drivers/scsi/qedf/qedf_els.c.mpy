{
  "module_name": "qedf_els.c",
  "hash_id": "20ecd2a1595d66d17f28d441c807876e9abbfca5f4893445d0cf1c87d9e86c22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedf/qedf_els.c",
  "human_readable_source": "\n \n#include \"qedf.h\"\n\n \nstatic int qedf_initiate_els(struct qedf_rport *fcport, unsigned int op,\n\tvoid *data, uint32_t data_len,\n\tvoid (*cb_func)(struct qedf_els_cb_arg *cb_arg),\n\tstruct qedf_els_cb_arg *cb_arg, uint32_t timer_msec)\n{\n\tstruct qedf_ctx *qedf;\n\tstruct fc_lport *lport;\n\tstruct qedf_ioreq *els_req;\n\tstruct qedf_mp_req *mp_req;\n\tstruct fc_frame_header *fc_hdr;\n\tstruct fcoe_task_context *task;\n\tint rc = 0;\n\tuint32_t did, sid;\n\tuint16_t xid;\n\tstruct fcoe_wqe *sqe;\n\tunsigned long flags;\n\tu16 sqe_idx;\n\n\tif (!fcport) {\n\t\tQEDF_ERR(NULL, \"fcport is NULL\");\n\t\trc = -EINVAL;\n\t\tgoto els_err;\n\t}\n\n\tqedf = fcport->qedf;\n\tlport = qedf->lport;\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Sending ELS\\n\");\n\n\trc = fc_remote_port_chkready(fcport->rport);\n\tif (rc) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"els 0x%x: rport not ready\\n\", op);\n\t\trc = -EAGAIN;\n\t\tgoto els_err;\n\t}\n\tif (lport->state != LPORT_ST_READY || !(lport->link_up)) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"els 0x%x: link is not ready\\n\",\n\t\t\t  op);\n\t\trc = -EAGAIN;\n\t\tgoto els_err;\n\t}\n\n\tif (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"els 0x%x: fcport not ready\\n\", op);\n\t\trc = -EINVAL;\n\t\tgoto els_err;\n\t}\n\n\tels_req = qedf_alloc_cmd(fcport, QEDF_ELS);\n\tif (!els_req) {\n\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_ELS,\n\t\t\t  \"Failed to alloc ELS request 0x%x\\n\", op);\n\t\trc = -ENOMEM;\n\t\tgoto els_err;\n\t}\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"initiate_els els_req = \"\n\t\t   \"0x%p cb_arg = %p xid = %x\\n\", els_req, cb_arg,\n\t\t   els_req->xid);\n\tels_req->sc_cmd = NULL;\n\tels_req->cmd_type = QEDF_ELS;\n\tels_req->fcport = fcport;\n\tels_req->cb_func = cb_func;\n\tcb_arg->io_req = els_req;\n\tcb_arg->op = op;\n\tels_req->cb_arg = cb_arg;\n\tels_req->data_xfer_len = data_len;\n\n\t \n\tels_req->cpu = smp_processor_id();\n\n\tmp_req = (struct qedf_mp_req *)&(els_req->mp_req);\n\trc = qedf_init_mp_req(els_req);\n\tif (rc) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"ELS MP request init failed\\n\");\n\t\tkref_put(&els_req->refcount, qedf_release_cmd);\n\t\tgoto els_err;\n\t} else {\n\t\trc = 0;\n\t}\n\n\t \n\tif ((op >= ELS_LS_RJT) && (op <= ELS_AUTH_ELS)) {\n\t\tmemcpy(mp_req->req_buf, data, data_len);\n\t} else {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"Invalid ELS op 0x%x\\n\", op);\n\t\tels_req->cb_func = NULL;\n\t\tels_req->cb_arg = NULL;\n\t\tkref_put(&els_req->refcount, qedf_release_cmd);\n\t\trc = -EINVAL;\n\t}\n\n\tif (rc)\n\t\tgoto els_err;\n\n\t \n\tfc_hdr = &(mp_req->req_fc_hdr);\n\n\tdid = fcport->rdata->ids.port_id;\n\tsid = fcport->sid;\n\n\t__fc_fill_fc_hdr(fc_hdr, FC_RCTL_ELS_REQ, did, sid,\n\t\t\t   FC_TYPE_ELS, FC_FC_FIRST_SEQ | FC_FC_END_SEQ |\n\t\t\t   FC_FC_SEQ_INIT, 0);\n\n\t \n\txid = els_req->xid;\n\n\tspin_lock_irqsave(&fcport->rport_lock, flags);\n\n\tsqe_idx = qedf_get_sqe_idx(fcport);\n\tsqe = &fcport->sq[sqe_idx];\n\tmemset(sqe, 0, sizeof(struct fcoe_wqe));\n\n\t \n\ttask = qedf_get_task_mem(&qedf->tasks, xid);\n\tqedf_init_mp_task(els_req, task, sqe);\n\n\t \n\tif (timer_msec)\n\t\tqedf_cmd_timer_set(qedf, els_req, timer_msec);\n\n\t \n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Ringing doorbell for ELS \"\n\t\t   \"req\\n\");\n\tqedf_ring_doorbell(fcport);\n\tset_bit(QEDF_CMD_OUTSTANDING, &els_req->flags);\n\n\tspin_unlock_irqrestore(&fcport->rport_lock, flags);\nels_err:\n\treturn rc;\n}\n\nvoid qedf_process_els_compl(struct qedf_ctx *qedf, struct fcoe_cqe *cqe,\n\tstruct qedf_ioreq *els_req)\n{\n\tstruct fcoe_cqe_midpath_info *mp_info;\n\tstruct qedf_rport *fcport;\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Entered with xid = 0x%x\"\n\t\t   \" cmd_type = %d.\\n\", els_req->xid, els_req->cmd_type);\n\n\tif ((els_req->event == QEDF_IOREQ_EV_ELS_FLUSH)\n\t\t|| (els_req->event == QEDF_IOREQ_EV_CLEANUP_SUCCESS)\n\t\t|| (els_req->event == QEDF_IOREQ_EV_CLEANUP_FAILED)) {\n\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_IO,\n\t\t\t\"ELS completion xid=0x%x after flush event=0x%x\",\n\t\t\tels_req->xid, els_req->event);\n\t\treturn;\n\t}\n\n\tfcport = els_req->fcport;\n\n\t \n\tif (test_bit(QEDF_RPORT_IN_TARGET_RESET, &fcport->flags) ||\n\t\ttest_bit(QEDF_RPORT_IN_LUN_RESET, &fcport->flags)) {\n\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_IO,\n\t\t\t\"Dropping ELS completion xid=0x%x as fcport is flushing\",\n\t\t\tels_req->xid);\n\t\treturn;\n\t}\n\n\tclear_bit(QEDF_CMD_OUTSTANDING, &els_req->flags);\n\n\t \n\tcancel_delayed_work(&els_req->timeout_work);\n\n\t \n\tmp_info = &cqe->cqe_info.midpath_info;\n\tels_req->mp_req.resp_len = mp_info->data_placement_size;\n\n\t \n\tif ((els_req->cb_func) && (els_req->cb_arg)) {\n\t\tels_req->cb_func(els_req->cb_arg);\n\t\tels_req->cb_arg = NULL;\n\t}\n\n\tkref_put(&els_req->refcount, qedf_release_cmd);\n}\n\nstatic void qedf_rrq_compl(struct qedf_els_cb_arg *cb_arg)\n{\n\tstruct qedf_ioreq *orig_io_req;\n\tstruct qedf_ioreq *rrq_req;\n\tstruct qedf_ctx *qedf;\n\tint refcount;\n\n\trrq_req = cb_arg->io_req;\n\tqedf = rrq_req->fcport->qedf;\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Entered.\\n\");\n\n\torig_io_req = cb_arg->aborted_io_req;\n\n\tif (!orig_io_req) {\n\t\tQEDF_ERR(&qedf->dbg_ctx,\n\t\t\t \"Original io_req is NULL, rrq_req = %p.\\n\", rrq_req);\n\t\tgoto out_free;\n\t}\n\n\trefcount = kref_read(&orig_io_req->refcount);\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"rrq_compl: orig io = %p,\"\n\t\t   \" orig xid = 0x%x, rrq_xid = 0x%x, refcount=%d\\n\",\n\t\t   orig_io_req, orig_io_req->xid, rrq_req->xid, refcount);\n\n\t \n\tif (orig_io_req && refcount > 0)\n\t\tkref_put(&orig_io_req->refcount, qedf_release_cmd);\n\nout_free:\n\t \n\tif (rrq_req->event == QEDF_IOREQ_EV_ELS_TMO)\n\t\tkref_put(&rrq_req->refcount, qedf_release_cmd);\n\tkfree(cb_arg);\n}\n\n \nint qedf_send_rrq(struct qedf_ioreq *aborted_io_req)\n{\n\n\tstruct fc_els_rrq rrq;\n\tstruct qedf_rport *fcport;\n\tstruct fc_lport *lport;\n\tstruct qedf_els_cb_arg *cb_arg = NULL;\n\tstruct qedf_ctx *qedf;\n\tuint32_t sid;\n\tuint32_t r_a_tov;\n\tint rc;\n\tint refcount;\n\n\tif (!aborted_io_req) {\n\t\tQEDF_ERR(NULL, \"abort_io_req is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfcport = aborted_io_req->fcport;\n\n\tif (!fcport) {\n\t\trefcount = kref_read(&aborted_io_req->refcount);\n\t\tQEDF_ERR(NULL,\n\t\t\t \"RRQ work was queued prior to a flush xid=0x%x, refcount=%d.\\n\",\n\t\t\t aborted_io_req->xid, refcount);\n\t\tkref_put(&aborted_io_req->refcount, qedf_release_cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {\n\t\tQEDF_ERR(NULL, \"fcport is no longer offloaded.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fcport->qedf) {\n\t\tQEDF_ERR(NULL, \"fcport->qedf is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqedf = fcport->qedf;\n\n\t \n\trefcount = kref_read(&aborted_io_req->refcount);\n\tif (refcount != 1) {\n\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_ELS,\n\t\t\t  \"refcount for xid=%x io_req=%p refcount=%d is not 1.\\n\",\n\t\t\t  aborted_io_req->xid, aborted_io_req, refcount);\n\t\treturn -EINVAL;\n\t}\n\n\tlport = qedf->lport;\n\tsid = fcport->sid;\n\tr_a_tov = lport->r_a_tov;\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Sending RRQ orig \"\n\t\t   \"io = %p, orig_xid = 0x%x\\n\", aborted_io_req,\n\t\t   aborted_io_req->xid);\n\tmemset(&rrq, 0, sizeof(rrq));\n\n\tcb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\n\tif (!cb_arg) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"Unable to allocate cb_arg for \"\n\t\t\t  \"RRQ\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto rrq_err;\n\t}\n\n\tcb_arg->aborted_io_req = aborted_io_req;\n\n\trrq.rrq_cmd = ELS_RRQ;\n\thton24(rrq.rrq_s_id, sid);\n\trrq.rrq_ox_id = htons(aborted_io_req->xid);\n\trrq.rrq_rx_id =\n\t    htons(aborted_io_req->task->tstorm_st_context.read_write.rx_id);\n\n\trc = qedf_initiate_els(fcport, ELS_RRQ, &rrq, sizeof(rrq),\n\t    qedf_rrq_compl, cb_arg, r_a_tov);\n\nrrq_err:\n\tif (rc) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"RRQ failed - release orig io \"\n\t\t\t  \"req 0x%x\\n\", aborted_io_req->xid);\n\t\tkfree(cb_arg);\n\t\tkref_put(&aborted_io_req->refcount, qedf_release_cmd);\n\t}\n\treturn rc;\n}\n\nstatic void qedf_process_l2_frame_compl(struct qedf_rport *fcport,\n\t\t\t\t\tstruct fc_frame *fp,\n\t\t\t\t\tu16 l2_oxid)\n{\n\tstruct fc_lport *lport = fcport->qedf->lport;\n\tstruct fc_frame_header *fh;\n\tu32 crc;\n\n\tfh = (struct fc_frame_header *)fc_frame_header_get(fp);\n\n\t \n\tif (l2_oxid != FC_XID_UNKNOWN)\n\t\tfh->fh_ox_id = htons(l2_oxid);\n\n\t \n\tfh->fh_r_ctl = FC_RCTL_ELS_REP;\n\tfh->fh_type = FC_TYPE_ELS;\n\t \n\tfh->fh_f_ctl[0] = 0x98;\n\thton24(fh->fh_d_id, lport->port_id);\n\thton24(fh->fh_s_id, fcport->rdata->ids.port_id);\n\tfh->fh_rx_id = 0xffff;\n\n\t \n\tcrc = fcoe_fc_crc(fp);\n\tfc_frame_init(fp);\n\tfr_dev(fp) = lport;\n\tfr_sof(fp) = FC_SOF_I3;\n\tfr_eof(fp) = FC_EOF_T;\n\tfr_crc(fp) = cpu_to_le32(~crc);\n\n\t \n\tfc_exch_recv(lport, fp);\n}\n\n \nvoid qedf_restart_rport(struct qedf_rport *fcport)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_rport_priv *rdata;\n\tu32 port_id;\n\tunsigned long flags;\n\n\tif (!fcport) {\n\t\tQEDF_ERR(NULL, \"fcport is NULL.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&fcport->rport_lock, flags);\n\tif (test_bit(QEDF_RPORT_IN_RESET, &fcport->flags) ||\n\t    !test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags) ||\n\t    test_bit(QEDF_RPORT_UPLOADING_CONNECTION, &fcport->flags)) {\n\t\tQEDF_ERR(&(fcport->qedf->dbg_ctx), \"fcport %p already in reset or not offloaded.\\n\",\n\t\t    fcport);\n\t\tspin_unlock_irqrestore(&fcport->rport_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tset_bit(QEDF_RPORT_IN_RESET, &fcport->flags);\n\tspin_unlock_irqrestore(&fcport->rport_lock, flags);\n\n\trdata = fcport->rdata;\n\tif (rdata && !kref_get_unless_zero(&rdata->kref)) {\n\t\tfcport->rdata = NULL;\n\t\trdata = NULL;\n\t}\n\n\tif (rdata && rdata->rp_state == RPORT_ST_READY) {\n\t\tlport = fcport->qedf->lport;\n\t\tport_id = rdata->ids.port_id;\n\t\tQEDF_ERR(&(fcport->qedf->dbg_ctx),\n\t\t    \"LOGO port_id=%x.\\n\", port_id);\n\t\tfc_rport_logoff(rdata);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\tmutex_lock(&lport->disc.disc_mutex);\n\t\t \n\t\trdata = fc_rport_create(lport, port_id);\n\t\tmutex_unlock(&lport->disc.disc_mutex);\n\t\tif (rdata)\n\t\t\tfc_rport_login(rdata);\n\t\tfcport->rdata = rdata;\n\t}\n\tclear_bit(QEDF_RPORT_IN_RESET, &fcport->flags);\n}\n\nstatic void qedf_l2_els_compl(struct qedf_els_cb_arg *cb_arg)\n{\n\tstruct qedf_ioreq *els_req;\n\tstruct qedf_rport *fcport;\n\tstruct qedf_mp_req *mp_req;\n\tstruct fc_frame *fp;\n\tstruct fc_frame_header *fh, *mp_fc_hdr;\n\tvoid *resp_buf, *fc_payload;\n\tu32 resp_len;\n\tu16 l2_oxid;\n\n\tl2_oxid = cb_arg->l2_oxid;\n\tels_req = cb_arg->io_req;\n\n\tif (!els_req) {\n\t\tQEDF_ERR(NULL, \"els_req is NULL.\\n\");\n\t\tgoto free_arg;\n\t}\n\n\t \n\tif (els_req->event == QEDF_IOREQ_EV_ELS_FLUSH) {\n\t\tQEDF_ERR(NULL, \"els_req xid=0x%x event is flush.\\n\",\n\t\t\t els_req->xid);\n\t\tgoto free_arg;\n\t}\n\n\tfcport = els_req->fcport;\n\tmp_req = &(els_req->mp_req);\n\tmp_fc_hdr = &(mp_req->resp_fc_hdr);\n\tresp_len = mp_req->resp_len;\n\tresp_buf = mp_req->resp_buf;\n\n\t \n\tif (els_req->event == QEDF_IOREQ_EV_ELS_TMO) {\n\t\t \n\t\tif (cb_arg->op == ELS_ADISC)\n\t\t\tqedf_restart_rport(fcport);\n\t\treturn;\n\t}\n\n\tif (sizeof(struct fc_frame_header) + resp_len > QEDF_PAGE_SIZE) {\n\t\tQEDF_ERR(&(fcport->qedf->dbg_ctx), \"resp_len is \"\n\t\t   \"beyond page size.\\n\");\n\t\tgoto free_arg;\n\t}\n\n\tfp = fc_frame_alloc(fcport->qedf->lport, resp_len);\n\tif (!fp) {\n\t\tQEDF_ERR(&(fcport->qedf->dbg_ctx),\n\t\t    \"fc_frame_alloc failure.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tfh = (struct fc_frame_header *)fc_frame_header_get(fp);\n\tmemcpy(fh, mp_fc_hdr, sizeof(struct fc_frame_header));\n\n\t \n\tfc_payload = fc_frame_payload_get(fp, resp_len);\n\tmemcpy(fc_payload, resp_buf, resp_len);\n\n\tQEDF_INFO(&(fcport->qedf->dbg_ctx), QEDF_LOG_ELS,\n\t    \"Completing OX_ID 0x%x back to libfc.\\n\", l2_oxid);\n\tqedf_process_l2_frame_compl(fcport, fp, l2_oxid);\n\nfree_arg:\n\tkfree(cb_arg);\n}\n\nint qedf_send_adisc(struct qedf_rport *fcport, struct fc_frame *fp)\n{\n\tstruct fc_els_adisc *adisc;\n\tstruct fc_frame_header *fh;\n\tstruct fc_lport *lport = fcport->qedf->lport;\n\tstruct qedf_els_cb_arg *cb_arg = NULL;\n\tstruct qedf_ctx *qedf;\n\tuint32_t r_a_tov = lport->r_a_tov;\n\tint rc;\n\n\tqedf = fcport->qedf;\n\tfh = fc_frame_header_get(fp);\n\n\tcb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\n\tif (!cb_arg) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"Unable to allocate cb_arg for \"\n\t\t\t  \"ADISC\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto adisc_err;\n\t}\n\tcb_arg->l2_oxid = ntohs(fh->fh_ox_id);\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t    \"Sending ADISC ox_id=0x%x.\\n\", cb_arg->l2_oxid);\n\n\tadisc = fc_frame_payload_get(fp, sizeof(*adisc));\n\n\trc = qedf_initiate_els(fcport, ELS_ADISC, adisc, sizeof(*adisc),\n\t    qedf_l2_els_compl, cb_arg, r_a_tov);\n\nadisc_err:\n\tif (rc) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"ADISC failed.\\n\");\n\t\tkfree(cb_arg);\n\t}\n\treturn rc;\n}\n\nstatic void qedf_srr_compl(struct qedf_els_cb_arg *cb_arg)\n{\n\tstruct qedf_ioreq *orig_io_req;\n\tstruct qedf_ioreq *srr_req;\n\tstruct qedf_mp_req *mp_req;\n\tstruct fc_frame_header *mp_fc_hdr, *fh;\n\tstruct fc_frame *fp;\n\tvoid *resp_buf, *fc_payload;\n\tu32 resp_len;\n\tstruct fc_lport *lport;\n\tstruct qedf_ctx *qedf;\n\tint refcount;\n\tu8 opcode;\n\n\tsrr_req = cb_arg->io_req;\n\tqedf = srr_req->fcport->qedf;\n\tlport = qedf->lport;\n\n\torig_io_req = cb_arg->aborted_io_req;\n\n\tif (!orig_io_req) {\n\t\tQEDF_ERR(NULL, \"orig_io_req is NULL.\\n\");\n\t\tgoto out_free;\n\t}\n\n\tclear_bit(QEDF_CMD_SRR_SENT, &orig_io_req->flags);\n\n\tif (srr_req->event != QEDF_IOREQ_EV_ELS_TMO &&\n\t    srr_req->event != QEDF_IOREQ_EV_ELS_ERR_DETECT)\n\t\tcancel_delayed_work_sync(&orig_io_req->timeout_work);\n\n\trefcount = kref_read(&orig_io_req->refcount);\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Entered: orig_io=%p,\"\n\t\t   \" orig_io_xid=0x%x, rec_xid=0x%x, refcount=%d\\n\",\n\t\t   orig_io_req, orig_io_req->xid, srr_req->xid, refcount);\n\n\t \n\tif (srr_req->event == QEDF_IOREQ_EV_ELS_TMO) {\n\t\tQEDF_ERR(&qedf->dbg_ctx,\n\t\t\t \"ELS timeout rec_xid=0x%x.\\n\", srr_req->xid);\n\t\tgoto out_put;\n\t}\n\n\t \n\tmp_req = &(srr_req->mp_req);\n\tmp_fc_hdr = &(mp_req->resp_fc_hdr);\n\tresp_len = mp_req->resp_len;\n\tresp_buf = mp_req->resp_buf;\n\n\tfp = fc_frame_alloc(lport, resp_len);\n\tif (!fp) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx),\n\t\t    \"fc_frame_alloc failure.\\n\");\n\t\tgoto out_put;\n\t}\n\n\t \n\tfh = (struct fc_frame_header *)fc_frame_header_get(fp);\n\tmemcpy(fh, mp_fc_hdr, sizeof(struct fc_frame_header));\n\n\t \n\tfc_payload = fc_frame_payload_get(fp, resp_len);\n\tmemcpy(fc_payload, resp_buf, resp_len);\n\n\topcode = fc_frame_payload_op(fp);\n\tswitch (opcode) {\n\tcase ELS_LS_ACC:\n\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t    \"SRR success.\\n\");\n\t\tbreak;\n\tcase ELS_LS_RJT:\n\t\tQEDF_INFO(&qedf->dbg_ctx, QEDF_LOG_ELS,\n\t\t    \"SRR rejected.\\n\");\n\t\tqedf_initiate_abts(orig_io_req, true);\n\t\tbreak;\n\t}\n\n\tfc_frame_free(fp);\nout_put:\n\t \n\tkref_put(&orig_io_req->refcount, qedf_release_cmd);\nout_free:\n\tkfree(cb_arg);\n}\n\nstatic int qedf_send_srr(struct qedf_ioreq *orig_io_req, u32 offset, u8 r_ctl)\n{\n\tstruct fcp_srr srr;\n\tstruct qedf_ctx *qedf;\n\tstruct qedf_rport *fcport;\n\tstruct fc_lport *lport;\n\tstruct qedf_els_cb_arg *cb_arg = NULL;\n\tu32 r_a_tov;\n\tint rc;\n\n\tif (!orig_io_req) {\n\t\tQEDF_ERR(NULL, \"orig_io_req is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfcport = orig_io_req->fcport;\n\n\t \n\tif (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {\n\t\tQEDF_ERR(NULL, \"fcport is no longer offloaded.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fcport->qedf) {\n\t\tQEDF_ERR(NULL, \"fcport->qedf is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tkref_get(&orig_io_req->refcount);\n\n\tqedf = fcport->qedf;\n\tlport = qedf->lport;\n\tr_a_tov = lport->r_a_tov;\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Sending SRR orig_io=%p, \"\n\t\t   \"orig_xid=0x%x\\n\", orig_io_req, orig_io_req->xid);\n\tmemset(&srr, 0, sizeof(srr));\n\n\tcb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\n\tif (!cb_arg) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"Unable to allocate cb_arg for \"\n\t\t\t  \"SRR\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto srr_err;\n\t}\n\n\tcb_arg->aborted_io_req = orig_io_req;\n\n\tsrr.srr_op = ELS_SRR;\n\tsrr.srr_ox_id = htons(orig_io_req->xid);\n\tsrr.srr_rx_id = htons(orig_io_req->rx_id);\n\tsrr.srr_rel_off = htonl(offset);\n\tsrr.srr_r_ctl = r_ctl;\n\n\trc = qedf_initiate_els(fcport, ELS_SRR, &srr, sizeof(srr),\n\t    qedf_srr_compl, cb_arg, r_a_tov);\n\nsrr_err:\n\tif (rc) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"SRR failed - release orig_io_req\"\n\t\t\t  \"=0x%x\\n\", orig_io_req->xid);\n\t\tkfree(cb_arg);\n\t\t \n\t\tqedf_initiate_abts(orig_io_req, true);\n\t\tkref_put(&orig_io_req->refcount, qedf_release_cmd);\n\t} else\n\t\t \n\t\tset_bit(QEDF_CMD_SRR_SENT, &orig_io_req->flags);\n\n\treturn rc;\n}\n\nstatic void qedf_initiate_seq_cleanup(struct qedf_ioreq *orig_io_req,\n\tu32 offset, u8 r_ctl)\n{\n\tstruct qedf_rport *fcport;\n\tunsigned long flags;\n\tstruct qedf_els_cb_arg *cb_arg;\n\tstruct fcoe_wqe *sqe;\n\tu16 sqe_idx;\n\n\tfcport = orig_io_req->fcport;\n\n\tQEDF_INFO(&(fcport->qedf->dbg_ctx), QEDF_LOG_ELS,\n\t    \"Doing sequence cleanup for xid=0x%x offset=%u.\\n\",\n\t    orig_io_req->xid, offset);\n\n\tcb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\n\tif (!cb_arg) {\n\t\tQEDF_ERR(&(fcport->qedf->dbg_ctx), \"Unable to allocate cb_arg \"\n\t\t\t  \"for sequence cleanup\\n\");\n\t\treturn;\n\t}\n\n\t \n\tkref_get(&orig_io_req->refcount);\n\n\torig_io_req->cmd_type = QEDF_SEQ_CLEANUP;\n\tcb_arg->offset = offset;\n\tcb_arg->r_ctl = r_ctl;\n\torig_io_req->cb_arg = cb_arg;\n\n\tqedf_cmd_timer_set(fcport->qedf, orig_io_req,\n\t    QEDF_CLEANUP_TIMEOUT * HZ);\n\n\tspin_lock_irqsave(&fcport->rport_lock, flags);\n\n\tsqe_idx = qedf_get_sqe_idx(fcport);\n\tsqe = &fcport->sq[sqe_idx];\n\tmemset(sqe, 0, sizeof(struct fcoe_wqe));\n\torig_io_req->task_params->sqe = sqe;\n\n\tinit_initiator_sequence_recovery_fcoe_task(orig_io_req->task_params,\n\t\t\t\t\t\t   offset);\n\tqedf_ring_doorbell(fcport);\n\n\tspin_unlock_irqrestore(&fcport->rport_lock, flags);\n}\n\nvoid qedf_process_seq_cleanup_compl(struct qedf_ctx *qedf,\n\tstruct fcoe_cqe *cqe, struct qedf_ioreq *io_req)\n{\n\tint rc;\n\tstruct qedf_els_cb_arg *cb_arg;\n\n\tcb_arg = io_req->cb_arg;\n\n\t \n\tif (io_req->event == QEDF_IOREQ_EV_ELS_TMO || !cqe) {\n\t\tQEDF_ERR(&qedf->dbg_ctx,\n\t\t\t \"cqe is NULL or timeout event (0x%x)\", io_req->event);\n\t\tgoto free;\n\t}\n\n\t \n\tcancel_delayed_work_sync(&io_req->timeout_work);\n\n\trc = qedf_send_srr(io_req, cb_arg->offset, cb_arg->r_ctl);\n\tif (rc)\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"Unable to send SRR, I/O will \"\n\t\t    \"abort, xid=0x%x.\\n\", io_req->xid);\nfree:\n\tkfree(cb_arg);\n\tkref_put(&io_req->refcount, qedf_release_cmd);\n}\n\nstatic bool qedf_requeue_io_req(struct qedf_ioreq *orig_io_req)\n{\n\tstruct qedf_rport *fcport;\n\tstruct qedf_ioreq *new_io_req;\n\tunsigned long flags;\n\tbool rc = false;\n\n\tfcport = orig_io_req->fcport;\n\tif (!fcport) {\n\t\tQEDF_ERR(NULL, \"fcport is NULL.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!orig_io_req->sc_cmd) {\n\t\tQEDF_ERR(&(fcport->qedf->dbg_ctx), \"sc_cmd is NULL for \"\n\t\t    \"xid=0x%x.\\n\", orig_io_req->xid);\n\t\tgoto out;\n\t}\n\n\tnew_io_req = qedf_alloc_cmd(fcport, QEDF_SCSI_CMD);\n\tif (!new_io_req) {\n\t\tQEDF_ERR(&(fcport->qedf->dbg_ctx), \"Could not allocate new \"\n\t\t    \"io_req.\\n\");\n\t\tgoto out;\n\t}\n\n\tnew_io_req->sc_cmd = orig_io_req->sc_cmd;\n\n\t \n\torig_io_req->sc_cmd = NULL;\n\tkref_put(&orig_io_req->refcount, qedf_release_cmd);\n\n\tspin_lock_irqsave(&fcport->rport_lock, flags);\n\n\t \n\tif (qedf_post_io_req(fcport, new_io_req)) {\n\t\tQEDF_ERR(&(fcport->qedf->dbg_ctx), \"Unable to post io_req\\n\");\n\t\t \n\t\tatomic_inc(&fcport->free_sqes);\n\t} else {\n\t\tQEDF_INFO(&(fcport->qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t    \"Reissued SCSI command from  orig_xid=0x%x on \"\n\t\t    \"new_xid=0x%x.\\n\", orig_io_req->xid, new_io_req->xid);\n\t\t \n\t\tspin_unlock_irqrestore(&fcport->rport_lock, flags);\n\t\tqedf_initiate_abts(orig_io_req, false);\n\t\tgoto out;\n\t}\n\n\tspin_unlock_irqrestore(&fcport->rport_lock, flags);\nout:\n\treturn rc;\n}\n\n\nstatic void qedf_rec_compl(struct qedf_els_cb_arg *cb_arg)\n{\n\tstruct qedf_ioreq *orig_io_req;\n\tstruct qedf_ioreq *rec_req;\n\tstruct qedf_mp_req *mp_req;\n\tstruct fc_frame_header *mp_fc_hdr, *fh;\n\tstruct fc_frame *fp;\n\tvoid *resp_buf, *fc_payload;\n\tu32 resp_len;\n\tstruct fc_lport *lport;\n\tstruct qedf_ctx *qedf;\n\tint refcount;\n\tenum fc_rctl r_ctl;\n\tstruct fc_els_ls_rjt *rjt;\n\tstruct fc_els_rec_acc *acc;\n\tu8 opcode;\n\tu32 offset, e_stat;\n\tstruct scsi_cmnd *sc_cmd;\n\tbool srr_needed = false;\n\n\trec_req = cb_arg->io_req;\n\tqedf = rec_req->fcport->qedf;\n\tlport = qedf->lport;\n\n\torig_io_req = cb_arg->aborted_io_req;\n\n\tif (!orig_io_req) {\n\t\tQEDF_ERR(NULL, \"orig_io_req is NULL.\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (rec_req->event != QEDF_IOREQ_EV_ELS_TMO &&\n\t    rec_req->event != QEDF_IOREQ_EV_ELS_ERR_DETECT)\n\t\tcancel_delayed_work_sync(&orig_io_req->timeout_work);\n\n\trefcount = kref_read(&orig_io_req->refcount);\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Entered: orig_io=%p,\"\n\t\t   \" orig_io_xid=0x%x, rec_xid=0x%x, refcount=%d\\n\",\n\t\t   orig_io_req, orig_io_req->xid, rec_req->xid, refcount);\n\n\t \n\tif (rec_req->event == QEDF_IOREQ_EV_ELS_TMO) {\n\t\tQEDF_ERR(&qedf->dbg_ctx,\n\t\t\t \"Got TMO event, orig_io_req %p orig_io_xid=0x%x.\\n\",\n\t\t\t orig_io_req, orig_io_req->xid);\n\t\tgoto out_put;\n\t}\n\n\t \n\tmp_req = &(rec_req->mp_req);\n\tmp_fc_hdr = &(mp_req->resp_fc_hdr);\n\tresp_len = mp_req->resp_len;\n\tacc = resp_buf = mp_req->resp_buf;\n\n\tfp = fc_frame_alloc(lport, resp_len);\n\tif (!fp) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx),\n\t\t    \"fc_frame_alloc failure.\\n\");\n\t\tgoto out_put;\n\t}\n\n\t \n\tfh = (struct fc_frame_header *)fc_frame_header_get(fp);\n\tmemcpy(fh, mp_fc_hdr, sizeof(struct fc_frame_header));\n\n\t \n\tfc_payload = fc_frame_payload_get(fp, resp_len);\n\tmemcpy(fc_payload, resp_buf, resp_len);\n\n\topcode = fc_frame_payload_op(fp);\n\tif (opcode == ELS_LS_RJT) {\n\t\trjt = fc_frame_payload_get(fp, sizeof(*rjt));\n\t\tif (!rjt) {\n\t\t\tQEDF_ERR(&qedf->dbg_ctx, \"payload get failed\");\n\t\t\tgoto out_free_frame;\n\t\t}\n\n\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t    \"Received LS_RJT for REC: er_reason=0x%x, \"\n\t\t    \"er_explan=0x%x.\\n\", rjt->er_reason, rjt->er_explan);\n\t\t \n\t\tif ((rjt->er_reason == ELS_RJT_LOGIC ||\n\t\t    rjt->er_reason == ELS_RJT_UNAB) &&\n\t\t    rjt->er_explan == ELS_EXPL_OXID_RXID) {\n\t\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t\t    \"Handle CMD LOST case.\\n\");\n\t\t\tqedf_requeue_io_req(orig_io_req);\n\t\t}\n\t} else if (opcode == ELS_LS_ACC) {\n\t\toffset = ntohl(acc->reca_fc4value);\n\t\te_stat = ntohl(acc->reca_e_stat);\n\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t    \"Received LS_ACC for REC: offset=0x%x, e_stat=0x%x.\\n\",\n\t\t    offset, e_stat);\n\t\tif (e_stat & ESB_ST_SEQ_INIT)  {\n\t\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t\t    \"Target has the seq init\\n\");\n\t\t\tgoto out_free_frame;\n\t\t}\n\t\tsc_cmd = orig_io_req->sc_cmd;\n\t\tif (!sc_cmd) {\n\t\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t\t    \"sc_cmd is NULL for xid=0x%x.\\n\",\n\t\t\t    orig_io_req->xid);\n\t\t\tgoto out_free_frame;\n\t\t}\n\t\t \n\t\tif (sc_cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\t\tif (offset == orig_io_req->data_xfer_len) {\n\t\t\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t\t\t    \"WRITE - response lost.\\n\");\n\t\t\t\tr_ctl = FC_RCTL_DD_CMD_STATUS;\n\t\t\t\tsrr_needed = true;\n\t\t\t\toffset = 0;\n\t\t\t} else {\n\t\t\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t\t\t    \"WRITE - XFER_RDY/DATA lost.\\n\");\n\t\t\t\tr_ctl = FC_RCTL_DD_DATA_DESC;\n\t\t\t\t \n\t\t\t\toffset = orig_io_req->tx_buf_off;\n\t\t\t}\n\t\t \n\t\t} else {\n\t\t\tif (orig_io_req->rx_buf_off ==\n\t\t\t    orig_io_req->data_xfer_len) {\n\t\t\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t\t\t    \"READ - response lost.\\n\");\n\t\t\t\tsrr_needed = true;\n\t\t\t\tr_ctl = FC_RCTL_DD_CMD_STATUS;\n\t\t\t\toffset = 0;\n\t\t\t} else {\n\t\t\t\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS,\n\t\t\t\t    \"READ - DATA lost.\\n\");\n\t\t\t\t \n\t\t\t\toffset = 0;\n\t\t\t\tr_ctl = FC_RCTL_DD_SOL_DATA;\n\t\t\t}\n\t\t}\n\n\t\tif (srr_needed)\n\t\t\tqedf_send_srr(orig_io_req, offset, r_ctl);\n\t\telse\n\t\t\tqedf_initiate_seq_cleanup(orig_io_req, offset, r_ctl);\n\t}\n\nout_free_frame:\n\tfc_frame_free(fp);\nout_put:\n\t \n\tkref_put(&orig_io_req->refcount, qedf_release_cmd);\nout_free:\n\tkfree(cb_arg);\n}\n\n \nint qedf_send_rec(struct qedf_ioreq *orig_io_req)\n{\n\n\tstruct fc_els_rec rec;\n\tstruct qedf_rport *fcport;\n\tstruct fc_lport *lport;\n\tstruct qedf_els_cb_arg *cb_arg = NULL;\n\tstruct qedf_ctx *qedf;\n\tuint32_t sid;\n\tuint32_t r_a_tov;\n\tint rc;\n\n\tif (!orig_io_req) {\n\t\tQEDF_ERR(NULL, \"orig_io_req is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfcport = orig_io_req->fcport;\n\n\t \n\tif (!test_bit(QEDF_RPORT_SESSION_READY, &fcport->flags)) {\n\t\tQEDF_ERR(NULL, \"fcport is no longer offloaded.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fcport->qedf) {\n\t\tQEDF_ERR(NULL, \"fcport->qedf is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tkref_get(&orig_io_req->refcount);\n\n\tqedf = fcport->qedf;\n\tlport = qedf->lport;\n\tsid = fcport->sid;\n\tr_a_tov = lport->r_a_tov;\n\n\tmemset(&rec, 0, sizeof(rec));\n\n\tcb_arg = kzalloc(sizeof(struct qedf_els_cb_arg), GFP_NOIO);\n\tif (!cb_arg) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"Unable to allocate cb_arg for \"\n\t\t\t  \"REC\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto rec_err;\n\t}\n\n\tcb_arg->aborted_io_req = orig_io_req;\n\n\trec.rec_cmd = ELS_REC;\n\thton24(rec.rec_s_id, sid);\n\trec.rec_ox_id = htons(orig_io_req->xid);\n\trec.rec_rx_id =\n\t    htons(orig_io_req->task->tstorm_st_context.read_write.rx_id);\n\n\tQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_ELS, \"Sending REC orig_io=%p, \"\n\t   \"orig_xid=0x%x rx_id=0x%x\\n\", orig_io_req,\n\t   orig_io_req->xid, rec.rec_rx_id);\n\trc = qedf_initiate_els(fcport, ELS_REC, &rec, sizeof(rec),\n\t    qedf_rec_compl, cb_arg, r_a_tov);\n\nrec_err:\n\tif (rc) {\n\t\tQEDF_ERR(&(qedf->dbg_ctx), \"REC failed - release orig_io_req\"\n\t\t\t  \"=0x%x\\n\", orig_io_req->xid);\n\t\tkfree(cb_arg);\n\t\tkref_put(&orig_io_req->refcount, qedf_release_cmd);\n\t}\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}