{
  "module_name": "qedf_dbg.c",
  "hash_id": "3dcda806a5b693d1ec0b3553671eeaefabbb5119048c6644c1b55d6bc837e9e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedf/qedf_dbg.c",
  "human_readable_source": "\n \n#include \"qedf_dbg.h\"\n#include <linux/vmalloc.h>\n\nvoid\nqedf_dbg_err(struct qedf_dbg_ctx *qedf, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedf) && likely(qedf->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&(qedf->pdev->dev)),\n\t\t\tfunc, line, qedf->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\n\tva_end(va);\n}\n\nvoid\nqedf_dbg_warn(struct qedf_dbg_ctx *qedf, const char *func, u32 line,\n\t       const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedf_debug & QEDF_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedf) && likely(qedf->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&(qedf->pdev->dev)),\n\t\t\tfunc, line, qedf->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n\nvoid\nqedf_dbg_notice(struct qedf_dbg_ctx *qedf, const char *func, u32 line,\n\t\t const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedf_debug & QEDF_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedf) && likely(qedf->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&(qedf->pdev->dev)), func, line,\n\t\t\t  qedf->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n\nvoid\nqedf_dbg_info(struct qedf_dbg_ctx *qedf, const char *func, u32 line,\n\t       u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedf_debug & level))\n\t\tgoto ret;\n\n\tif (likely(qedf) && likely(qedf->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&(qedf->pdev->dev)),\n\t\t\tfunc, line, qedf->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}\n\nint\nqedf_alloc_grc_dump_buf(u8 **buf, uint32_t len)\n{\n\t\t*buf = vzalloc(len);\n\t\tif (!(*buf))\n\t\t\treturn -ENOMEM;\n\n\t\treturn 0;\n}\n\nvoid\nqedf_free_grc_dump_buf(uint8_t **buf)\n{\n\t\tvfree(*buf);\n\t\t*buf = NULL;\n}\n\nint\nqedf_get_grc_dump(struct qed_dev *cdev, const struct qed_common_ops *common,\n\t\t   u8 **buf, uint32_t *grcsize)\n{\n\tif (!*buf)\n\t\treturn -EINVAL;\n\n\treturn common->dbg_all_data(cdev, *buf);\n}\n\nvoid\nqedf_uevent_emit(struct Scsi_Host *shost, u32 code, char *msg)\n{\n\tchar event_string[40];\n\tchar *envp[] = {event_string, NULL};\n\n\tmemset(event_string, 0, sizeof(event_string));\n\tswitch (code) {\n\tcase QEDF_UEVENT_CODE_GRCDUMP:\n\t\tif (msg)\n\t\t\tstrscpy(event_string, msg, sizeof(event_string));\n\t\telse\n\t\t\tsprintf(event_string, \"GRCDUMP=%u\", shost->host_no);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tkobject_uevent_env(&shost->shost_gendev.kobj, KOBJ_CHANGE, envp);\n}\n\nint\nqedf_create_sysfs_attr(struct Scsi_Host *shost, struct sysfs_bin_attrs *iter)\n{\n\tint ret = 0;\n\n\tfor (; iter->name; iter++) {\n\t\tret = sysfs_create_bin_file(&shost->shost_gendev.kobj,\n\t\t\t\t\t    iter->attr);\n\t\tif (ret)\n\t\t\tpr_err(\"Unable to create sysfs %s attr, err(%d).\\n\",\n\t\t\t       iter->name, ret);\n\t}\n\treturn ret;\n}\n\nvoid\nqedf_remove_sysfs_attr(struct Scsi_Host *shost, struct sysfs_bin_attrs *iter)\n{\n\tfor (; iter->name; iter++)\n\t\tsysfs_remove_bin_file(&shost->shost_gendev.kobj, iter->attr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}