{
  "module_name": "aha152x.c",
  "hash_id": "0f8af37a8b65cc9be1d3b8441ec51b6c170763132a1a41ab8776dbd44da6cd1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aha152x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <asm/irq.h>\n#include <linux/io.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/wait.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/isapnp.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_spi.h>\n#include <scsi/scsicam.h>\n#include \"aha152x.h\"\n\nstatic LIST_HEAD(aha152x_host_list);\n\n\n \n\n \n#if defined(AHA152X_PCMCIA) || defined(MODULE)\n#if !defined(AUTOCONF)\n#define AUTOCONF\n#endif\n#endif\n\n#if !defined(AUTOCONF) && !defined(SETUP0)\n#error define AUTOCONF or SETUP0\n#endif\n\n#define\tDO_LOCK(flags)\t\tspin_lock_irqsave(&QLOCK,flags)\n#define\tDO_UNLOCK(flags)\tspin_unlock_irqrestore(&QLOCK,flags)\n\n#define LEAD\t\t\"(scsi%d:%d:%d) \"\n#define INFO_LEAD\tKERN_INFO\tLEAD\n#define CMDINFO(cmd) \\\n\t\t\t(cmd) ? ((cmd)->device->host->host_no) : -1, \\\n                        (cmd) ? ((cmd)->device->id & 0x0f) : -1, \\\n\t\t\t(cmd) ? ((u8)(cmd)->device->lun & 0x07) : -1\n\nstatic inline void\nCMD_INC_RESID(struct scsi_cmnd *cmd, int inc)\n{\n\tscsi_set_resid(cmd, scsi_get_resid(cmd) + inc);\n}\n\n#define DELAY_DEFAULT 1000\n\n#if defined(AHA152X_PCMCIA)\n#define IRQ_MIN 0\n#define IRQ_MAX 16\n#else\n#define IRQ_MIN 9\n#if defined(__PPC)\n#define IRQ_MAX (nr_irqs-1)\n#else\n#define IRQ_MAX 12\n#endif\n#endif\n\nenum {\n\tnot_issued\t= 0x0001,\t \n\tselecting\t= 0x0002,\t \n\tidentified\t= 0x0004,\t \n\tdisconnected\t= 0x0008,\t \n\tcompleted\t= 0x0010,\t \n\taborted\t\t= 0x0020,\t \n\tresetted\t= 0x0040,\t \n\tspiordy\t\t= 0x0080,\t \n\tsyncneg\t\t= 0x0100,\t \n\taborting\t= 0x0200,\t \n\tresetting\t= 0x0400,\t \n\tcheck_condition = 0x0800,\t \n};\n\nstruct aha152x_cmd_priv {\n\tchar *ptr;\n\tint this_residual;\n\tstruct scatterlist *buffer;\n\tint status;\n\tint message;\n\tint sent_command;\n\tint phase;\n};\n\nstatic struct aha152x_cmd_priv *aha152x_priv(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\nMODULE_AUTHOR(\"J\u00fcrgen Fischer\");\nMODULE_DESCRIPTION(AHA152X_REVID);\nMODULE_LICENSE(\"GPL\");\n\n#if !defined(AHA152X_PCMCIA)\n#if defined(MODULE)\nstatic int io[] = {0, 0};\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nMODULE_PARM_DESC(io,\"base io address of controller\");\n\nstatic int irq[] = {0, 0};\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nMODULE_PARM_DESC(irq,\"interrupt for controller\");\n\nstatic int scsiid[] = {7, 7};\nmodule_param_array(scsiid, int, NULL, 0);\nMODULE_PARM_DESC(scsiid,\"scsi id of controller\");\n\nstatic int reconnect[] = {1, 1};\nmodule_param_array(reconnect, int, NULL, 0);\nMODULE_PARM_DESC(reconnect,\"allow targets to disconnect\");\n\nstatic int parity[] = {1, 1};\nmodule_param_array(parity, int, NULL, 0);\nMODULE_PARM_DESC(parity,\"use scsi parity\");\n\nstatic int sync[] = {1, 1};\nmodule_param_array(sync, int, NULL, 0);\nMODULE_PARM_DESC(sync,\"use synchronous transfers\");\n\nstatic int delay[] = {DELAY_DEFAULT, DELAY_DEFAULT};\nmodule_param_array(delay, int, NULL, 0);\nMODULE_PARM_DESC(delay,\"scsi reset delay\");\n\nstatic int exttrans[] = {0, 0};\nmodule_param_array(exttrans, int, NULL, 0);\nMODULE_PARM_DESC(exttrans,\"use extended translation\");\n\nstatic int aha152x[] = {0, 11, 7, 1, 1, 0, DELAY_DEFAULT, 0};\nmodule_param_array(aha152x, int, NULL, 0);\nMODULE_PARM_DESC(aha152x, \"parameters for first controller\");\n\nstatic int aha152x1[] = {0, 11, 7, 1, 1, 0, DELAY_DEFAULT, 0};\nmodule_param_array(aha152x1, int, NULL, 0);\nMODULE_PARM_DESC(aha152x1, \"parameters for second controller\");\n#endif  \n\n#ifdef __ISAPNP__\nstatic struct isapnp_device_id id_table[] = {\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1502), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1505), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1510), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1515), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1520), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x2015), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1522), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x2215), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1530), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x3015), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1532), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x3215), 0 },\n\t{ ISAPNP_ANY_ID, ISAPNP_ANY_ID,\tISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x6360), 0 },\n\t{ ISAPNP_DEVICE_SINGLE_END, }\n};\nMODULE_DEVICE_TABLE(isapnp, id_table);\n#endif  \n\n#endif  \n\nstatic const struct scsi_host_template aha152x_driver_template;\n\n \nenum aha152x_state {\n\tidle=0,\n\tunknown,\n\tseldo,\n\tseldi,\n\tselto,\n\tbusfree,\n\tmsgo,\n\tcmd,\n\tmsgi,\n\tstatus,\n\tdatai,\n\tdatao,\n\tparerr,\n\trsti,\n\tmaxstate\n};\n\n \nstruct aha152x_hostdata {\n\tstruct scsi_cmnd *issue_SC;\n\t\t \n\n\tstruct scsi_cmnd *current_SC;\n\t\t \n\n\tstruct scsi_cmnd *disconnected_SC;\n\t\t \n\n\tstruct scsi_cmnd *done_SC;\n\t\t \n\n\tspinlock_t lock;\n\t\t \n\n#if defined(AHA152X_STAT)\n\tint\t      total_commands;\n\tint\t      disconnections;\n\tint\t      busfree_without_any_action;\n\tint\t      busfree_without_old_command;\n\tint\t      busfree_without_new_command;\n\tint\t      busfree_without_done_command;\n\tint\t      busfree_with_check_condition;\n\tint\t      count[maxstate];\n\tint\t      count_trans[maxstate];\n\tunsigned long time[maxstate];\n#endif\n\n\tint commands;\t\t \n\n\tint reconnect;\t\t \n\tint parity;\t\t \n\tint synchronous;\t \n\tint delay;\t\t \n\tint ext_trans;\t\t \n\n\tint swint;\t\t \n\tint service;\t\t \n\tint in_intr;\t\t \n\n\t \n\tenum aha152x_state state, prevstate, laststate;\n\n\tint target;\n\t\t \n\n\tunsigned char syncrate[8];\n\t\t \n\n\tunsigned char syncneg[8];\n\t\t \n\n\tint cmd_i;\n\t\t \n\n\tint msgi_len;\n\t\t \n\tunsigned char msgi[256];\n\t\t \n\n\tint msgo_i, msgo_len;\n\t\t \n\tunsigned char msgo[256];\n\t\t \n\n\tint data_len;\n\t\t \n\n\tunsigned long io_port0;\n\tunsigned long io_port1;\n\n#ifdef __ISAPNP__\n\tstruct pnp_dev *pnpdev;\n#endif\n\tstruct list_head host_list;\n};\n\n\n \nstruct aha152x_scdata {\n\tstruct scsi_cmnd *next;\t \n\tstruct completion *done; \n\tstruct scsi_eh_save ses;\n};\n\n \n\n#define HOSTDATA(shpnt)\t\t((struct aha152x_hostdata *) &shpnt->hostdata)\n\n#define HOSTNO\t\t\t((shpnt)->host_no)\n\n#define CURRENT_SC\t\t(HOSTDATA(shpnt)->current_SC)\n#define DONE_SC\t\t\t(HOSTDATA(shpnt)->done_SC)\n#define ISSUE_SC\t\t(HOSTDATA(shpnt)->issue_SC)\n#define DISCONNECTED_SC\t\t(HOSTDATA(shpnt)->disconnected_SC)\n#define QLOCK\t\t\t(HOSTDATA(shpnt)->lock)\n#define QLOCKER\t\t\t(HOSTDATA(shpnt)->locker)\n#define QLOCKERL\t\t(HOSTDATA(shpnt)->lockerl)\n\n#define STATE\t\t\t(HOSTDATA(shpnt)->state)\n#define PREVSTATE\t\t(HOSTDATA(shpnt)->prevstate)\n#define LASTSTATE\t\t(HOSTDATA(shpnt)->laststate)\n\n#define RECONN_TARGET\t\t(HOSTDATA(shpnt)->target)\n\n#define CMD_I\t\t\t(HOSTDATA(shpnt)->cmd_i)\n\n#define MSGO(i)\t\t\t(HOSTDATA(shpnt)->msgo[i])\n#define MSGO_I\t\t\t(HOSTDATA(shpnt)->msgo_i)\n#define MSGOLEN\t\t\t(HOSTDATA(shpnt)->msgo_len)\n#define ADDMSGO(x)\t\t(MSGOLEN<256 ? (void)(MSGO(MSGOLEN++)=x) : aha152x_error(shpnt,\"MSGO overflow\"))\n\n#define MSGI(i)\t\t\t(HOSTDATA(shpnt)->msgi[i])\n#define MSGILEN\t\t\t(HOSTDATA(shpnt)->msgi_len)\n#define ADDMSGI(x)\t\t(MSGILEN<256 ? (void)(MSGI(MSGILEN++)=x) : aha152x_error(shpnt,\"MSGI overflow\"))\n\n#define DATA_LEN\t\t(HOSTDATA(shpnt)->data_len)\n\n#define SYNCRATE\t\t(HOSTDATA(shpnt)->syncrate[CURRENT_SC->device->id])\n#define SYNCNEG\t\t\t(HOSTDATA(shpnt)->syncneg[CURRENT_SC->device->id])\n\n#define DELAY\t\t\t(HOSTDATA(shpnt)->delay)\n#define EXT_TRANS\t\t(HOSTDATA(shpnt)->ext_trans)\n#define TC1550\t\t\t(HOSTDATA(shpnt)->tc1550)\n#define RECONNECT\t\t(HOSTDATA(shpnt)->reconnect)\n#define PARITY\t\t\t(HOSTDATA(shpnt)->parity)\n#define SYNCHRONOUS\t\t(HOSTDATA(shpnt)->synchronous)\n\n#define HOSTIOPORT0\t\t(HOSTDATA(shpnt)->io_port0)\n#define HOSTIOPORT1\t\t(HOSTDATA(shpnt)->io_port1)\n\n#define SCDATA(SCpnt)\t\t((struct aha152x_scdata *) (SCpnt)->host_scribble)\n#define SCNEXT(SCpnt)\t\tSCDATA(SCpnt)->next\n#define SCSEM(SCpnt)\t\tSCDATA(SCpnt)->done\n\n#define SG_ADDRESS(buffer)\t((char *) sg_virt((buffer)))\n\n \nstatic void seldi_run(struct Scsi_Host *shpnt);\nstatic void seldo_run(struct Scsi_Host *shpnt);\nstatic void selto_run(struct Scsi_Host *shpnt);\nstatic void busfree_run(struct Scsi_Host *shpnt);\n\nstatic void msgo_init(struct Scsi_Host *shpnt);\nstatic void msgo_run(struct Scsi_Host *shpnt);\nstatic void msgo_end(struct Scsi_Host *shpnt);\n\nstatic void cmd_init(struct Scsi_Host *shpnt);\nstatic void cmd_run(struct Scsi_Host *shpnt);\nstatic void cmd_end(struct Scsi_Host *shpnt);\n\nstatic void datai_init(struct Scsi_Host *shpnt);\nstatic void datai_run(struct Scsi_Host *shpnt);\nstatic void datai_end(struct Scsi_Host *shpnt);\n\nstatic void datao_init(struct Scsi_Host *shpnt);\nstatic void datao_run(struct Scsi_Host *shpnt);\nstatic void datao_end(struct Scsi_Host *shpnt);\n\nstatic void status_run(struct Scsi_Host *shpnt);\n\nstatic void msgi_run(struct Scsi_Host *shpnt);\nstatic void msgi_end(struct Scsi_Host *shpnt);\n\nstatic void parerr_run(struct Scsi_Host *shpnt);\nstatic void rsti_run(struct Scsi_Host *shpnt);\n\nstatic void is_complete(struct Scsi_Host *shpnt);\n\n \nstatic struct {\n\tchar\t\t*name;\n\tvoid\t\t(*init)(struct Scsi_Host *);\n\tvoid\t\t(*run)(struct Scsi_Host *);\n\tvoid\t\t(*end)(struct Scsi_Host *);\n\tint\t\tspio;\n} states[] = {\n\t{ \"idle\",\tNULL,\t\tNULL,\t\tNULL,\t\t0},\n\t{ \"unknown\",\tNULL,\t\tNULL,\t\tNULL,\t\t0},\n\t{ \"seldo\",\tNULL,\t\tseldo_run,\tNULL,\t\t0},\n\t{ \"seldi\",\tNULL,\t\tseldi_run,\tNULL,\t\t0},\n\t{ \"selto\",\tNULL,\t\tselto_run,\tNULL,\t\t0},\n\t{ \"busfree\",\tNULL,\t\tbusfree_run,\tNULL,\t\t0},\n\t{ \"msgo\",\tmsgo_init,\tmsgo_run,\tmsgo_end,\t1},\n\t{ \"cmd\",\tcmd_init,\tcmd_run,\tcmd_end,\t1},\n\t{ \"msgi\",\tNULL,\t\tmsgi_run,\tmsgi_end,\t1},\n\t{ \"status\",\tNULL,\t\tstatus_run,\tNULL,\t\t1},\n\t{ \"datai\",\tdatai_init,\tdatai_run,\tdatai_end,\t0},\n\t{ \"datao\",\tdatao_init,\tdatao_run,\tdatao_end,\t0},\n\t{ \"parerr\",\tNULL,\t\tparerr_run,\tNULL,\t\t0},\n\t{ \"rsti\",\tNULL,\t\trsti_run,\tNULL,\t\t0},\n};\n\n \nstatic irqreturn_t intr(int irq, void *dev_id);\nstatic void reset_ports(struct Scsi_Host *shpnt);\nstatic void aha152x_error(struct Scsi_Host *shpnt, char *msg);\nstatic void done(struct Scsi_Host *shpnt, unsigned char status_byte,\n\t\t unsigned char host_byte);\n\n \nstatic void show_command(struct scsi_cmnd * ptr);\nstatic void show_queues(struct Scsi_Host *shpnt);\nstatic void disp_enintr(struct Scsi_Host *shpnt);\n\n\n \nstatic inline void append_SC(struct scsi_cmnd **SC, struct scsi_cmnd *new_SC)\n{\n\tstruct scsi_cmnd *end;\n\n\tSCNEXT(new_SC) = NULL;\n\tif (!*SC)\n\t\t*SC = new_SC;\n\telse {\n\t\tfor (end = *SC; SCNEXT(end); end = SCNEXT(end))\n\t\t\t;\n\t\tSCNEXT(end) = new_SC;\n\t}\n}\n\nstatic inline struct scsi_cmnd *remove_first_SC(struct scsi_cmnd ** SC)\n{\n\tstruct scsi_cmnd *ptr;\n\n\tptr = *SC;\n\tif (ptr) {\n\t\t*SC = SCNEXT(*SC);\n\t\tSCNEXT(ptr)=NULL;\n\t}\n\treturn ptr;\n}\n\nstatic inline struct scsi_cmnd *remove_lun_SC(struct scsi_cmnd ** SC,\n\t\t\t\t\t      int target, int lun)\n{\n\tstruct scsi_cmnd *ptr, *prev;\n\n\tfor (ptr = *SC, prev = NULL;\n\t     ptr && ((ptr->device->id != target) || (ptr->device->lun != lun));\n\t     prev = ptr, ptr = SCNEXT(ptr))\n\t     ;\n\n\tif (ptr) {\n\t\tif (prev)\n\t\t\tSCNEXT(prev) = SCNEXT(ptr);\n\t\telse\n\t\t\t*SC = SCNEXT(ptr);\n\n\t\tSCNEXT(ptr)=NULL;\n\t}\n\n\treturn ptr;\n}\n\nstatic inline struct scsi_cmnd *remove_SC(struct scsi_cmnd **SC,\n\t\t\t\t\t  struct scsi_cmnd *SCp)\n{\n\tstruct scsi_cmnd *ptr, *prev;\n\n\tfor (ptr = *SC, prev = NULL;\n\t     ptr && SCp!=ptr;\n\t     prev = ptr, ptr = SCNEXT(ptr))\n\t     ;\n\n\tif (ptr) {\n\t\tif (prev)\n\t\t\tSCNEXT(prev) = SCNEXT(ptr);\n\t\telse\n\t\t\t*SC = SCNEXT(ptr);\n\n\t\tSCNEXT(ptr)=NULL;\n\t}\n\n\treturn ptr;\n}\n\nstatic irqreturn_t swintr(int irqno, void *dev_id)\n{\n\tstruct Scsi_Host *shpnt = dev_id;\n\n\tHOSTDATA(shpnt)->swint++;\n\n\tSETPORT(DMACNTRL0, INTEN);\n\treturn IRQ_HANDLED;\n}\n\nstruct Scsi_Host *aha152x_probe_one(struct aha152x_setup *setup)\n{\n\tstruct Scsi_Host *shpnt;\n\n\tshpnt = scsi_host_alloc(&aha152x_driver_template, sizeof(struct aha152x_hostdata));\n\tif (!shpnt) {\n\t\tprintk(KERN_ERR \"aha152x: scsi_host_alloc failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(HOSTDATA(shpnt), 0, sizeof *HOSTDATA(shpnt));\n\tINIT_LIST_HEAD(&HOSTDATA(shpnt)->host_list);\n\n\t \n\tlist_add_tail(&HOSTDATA(shpnt)->host_list, &aha152x_host_list);\n\n\tshpnt->io_port   = setup->io_port;\n\tshpnt->n_io_port = IO_RANGE;\n\tshpnt->irq       = setup->irq;\n\n\tif (!setup->tc1550) {\n\t\tHOSTIOPORT0 = setup->io_port;\n\t\tHOSTIOPORT1 = setup->io_port;\n\t} else {\n\t\tHOSTIOPORT0 = setup->io_port+0x10;\n\t\tHOSTIOPORT1 = setup->io_port-0x10;\n\t}\n\n\tspin_lock_init(&QLOCK);\n\tRECONNECT   = setup->reconnect;\n\tSYNCHRONOUS = setup->synchronous;\n\tPARITY      = setup->parity;\n\tDELAY       = setup->delay;\n\tEXT_TRANS   = setup->ext_trans;\n\n\tSETPORT(SCSIID, setup->scsiid << 4);\n\tshpnt->this_id = setup->scsiid;\n\n\tif (setup->reconnect)\n\t\tshpnt->can_queue = AHA152X_MAXQUEUE;\n\n\t \n\tprintk(\"aha152x: resetting bus...\\n\");\n\tSETPORT(SCSISEQ, SCSIRSTO);\n\tmdelay(256);\n\tSETPORT(SCSISEQ, 0);\n\tmdelay(DELAY);\n\n\treset_ports(shpnt);\n\n\tprintk(KERN_INFO\n\t       \"aha152x%d%s: \"\n\t       \"vital data: rev=%x, \"\n\t       \"io=0x%03lx (0x%03lx/0x%03lx), \"\n\t       \"irq=%d, \"\n\t       \"scsiid=%d, \"\n\t       \"reconnect=%s, \"\n\t       \"parity=%s, \"\n\t       \"synchronous=%s, \"\n\t       \"delay=%d, \"\n\t       \"extended translation=%s\\n\",\n\t       shpnt->host_no, setup->tc1550 ? \" (tc1550 mode)\" : \"\",\n\t       GETPORT(REV) & 0x7,\n\t       shpnt->io_port, HOSTIOPORT0, HOSTIOPORT1,\n\t       shpnt->irq,\n\t       shpnt->this_id,\n\t       RECONNECT ? \"enabled\" : \"disabled\",\n\t       PARITY ? \"enabled\" : \"disabled\",\n\t       SYNCHRONOUS ? \"enabled\" : \"disabled\",\n\t       DELAY,\n\t       EXT_TRANS ? \"enabled\" : \"disabled\");\n\n\t \n\tSETPORT(SIMODE0, 0);\n\tSETPORT(SIMODE1, 0);\n\n\tif (request_irq(shpnt->irq, swintr, IRQF_SHARED, \"aha152x\", shpnt)) {\n\t\tprintk(KERN_ERR \"aha152x%d: irq %d busy.\\n\", shpnt->host_no, shpnt->irq);\n\t\tgoto out_host_put;\n\t}\n\n\tHOSTDATA(shpnt)->swint = 0;\n\n\tprintk(KERN_INFO \"aha152x%d: trying software interrupt, \", shpnt->host_no);\n\n\tmb();\n\tSETPORT(DMACNTRL0, SWINT|INTEN);\n\tmdelay(1000);\n\tfree_irq(shpnt->irq, shpnt);\n\n\tif (!HOSTDATA(shpnt)->swint) {\n\t\tif (TESTHI(DMASTAT, INTSTAT)) {\n\t\t\tprintk(\"lost.\\n\");\n\t\t} else {\n\t\t\tprintk(\"failed.\\n\");\n\t\t}\n\n\t\tSETPORT(DMACNTRL0, INTEN);\n\n\t\tprintk(KERN_ERR \"aha152x%d: irq %d possibly wrong.  \"\n\t\t\t\t\"Please verify.\\n\", shpnt->host_no, shpnt->irq);\n\t\tgoto out_host_put;\n\t}\n\tprintk(\"ok.\\n\");\n\n\n\t \n\tSETPORT(SSTAT0, 0x7f);\n\tSETPORT(SSTAT1, 0xef);\n\n\tif (request_irq(shpnt->irq, intr, IRQF_SHARED, \"aha152x\", shpnt)) {\n\t\tprintk(KERN_ERR \"aha152x%d: failed to reassign irq %d.\\n\", shpnt->host_no, shpnt->irq);\n\t\tgoto out_host_put;\n\t}\n\n\tif( scsi_add_host(shpnt, NULL) ) {\n\t\tfree_irq(shpnt->irq, shpnt);\n\t\tprintk(KERN_ERR \"aha152x%d: failed to add host.\\n\", shpnt->host_no);\n\t\tgoto out_host_put;\n\t}\n\n\tscsi_scan_host(shpnt);\n\n\treturn shpnt;\n\nout_host_put:\n\tlist_del(&HOSTDATA(shpnt)->host_list);\n\tscsi_host_put(shpnt);\n\n\treturn NULL;\n}\n\nvoid aha152x_release(struct Scsi_Host *shpnt)\n{\n\tif (!shpnt)\n\t\treturn;\n\n\tscsi_remove_host(shpnt);\n\tif (shpnt->irq)\n\t\tfree_irq(shpnt->irq, shpnt);\n\n#if !defined(AHA152X_PCMCIA)\n\tif (shpnt->io_port)\n\t\trelease_region(shpnt->io_port, IO_RANGE);\n#endif\n\n#ifdef __ISAPNP__\n\tif (HOSTDATA(shpnt)->pnpdev)\n\t\tpnp_device_detach(HOSTDATA(shpnt)->pnpdev);\n#endif\n\n\tlist_del(&HOSTDATA(shpnt)->host_list);\n\tscsi_host_put(shpnt);\n}\n\n\n \nstatic int setup_expected_interrupts(struct Scsi_Host *shpnt)\n{\n\tif(CURRENT_SC) {\n\t\tstruct aha152x_cmd_priv *acp = aha152x_priv(CURRENT_SC);\n\n\t\tacp->phase |= 1 << 16;\n\n\t\tif (acp->phase & selecting) {\n\t\t\tSETPORT(SSTAT1, SELTO);\n\t\t\tSETPORT(SIMODE0, ENSELDO | (DISCONNECTED_SC ? ENSELDI : 0));\n\t\t\tSETPORT(SIMODE1, ENSELTIMO);\n\t\t} else {\n\t\t\tSETPORT(SIMODE0, (acp->phase & spiordy) ? ENSPIORDY : 0);\n\t\t\tSETPORT(SIMODE1, ENPHASEMIS | ENSCSIRST | ENSCSIPERR | ENBUSFREE);\n\t\t}\n\t} else if(STATE==seldi) {\n\t\tSETPORT(SIMODE0, 0);\n\t\tSETPORT(SIMODE1, ENPHASEMIS | ENSCSIRST | ENSCSIPERR | ENBUSFREE);\n\t} else {\n\t\tSETPORT(SIMODE0, DISCONNECTED_SC ? ENSELDI : 0);\n\t\tSETPORT(SIMODE1, ENSCSIRST | ( (ISSUE_SC||DONE_SC) ? ENBUSFREE : 0));\n\t}\n\n\tif(!HOSTDATA(shpnt)->in_intr)\n\t\tSETBITS(DMACNTRL0, INTEN);\n\n\treturn TESTHI(DMASTAT, INTSTAT);\n}\n\n\n \nstatic int aha152x_internal_queue(struct scsi_cmnd *SCpnt,\n\t\t\t\t  struct completion *complete, int phase)\n{\n\tstruct aha152x_cmd_priv *acp = aha152x_priv(SCpnt);\n\tstruct Scsi_Host *shpnt = SCpnt->device->host;\n\tunsigned long flags;\n\n\tacp->phase        = not_issued | phase;\n\tacp->status       = 0x1;  \n\tacp->message      = 0;\n\tacp->sent_command = 0;\n\n\tif (acp->phase & (resetting | check_condition)) {\n\t\tif (!SCpnt->host_scribble || SCSEM(SCpnt) || SCNEXT(SCpnt)) {\n\t\t\tscmd_printk(KERN_ERR, SCpnt, \"cannot reuse command\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\t} else {\n\t\tSCpnt->host_scribble = kmalloc(sizeof(struct aha152x_scdata), GFP_ATOMIC);\n\t\tif(!SCpnt->host_scribble) {\n\t\t\tscmd_printk(KERN_ERR, SCpnt, \"allocation failed\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\t}\n\n\tSCNEXT(SCpnt)\t\t= NULL;\n\tSCSEM(SCpnt)\t\t= complete;\n\n\t \n\n\tif ((phase & resetting) || !scsi_sglist(SCpnt)) {\n\t\tacp->ptr           = NULL;\n\t\tacp->this_residual = 0;\n\t\tscsi_set_resid(SCpnt, 0);\n\t\tacp->buffer        = NULL;\n\t} else {\n\t\tscsi_set_resid(SCpnt, scsi_bufflen(SCpnt));\n\t\tacp->buffer        = scsi_sglist(SCpnt);\n\t\tacp->ptr           = SG_ADDRESS(acp->buffer);\n\t\tacp->this_residual = acp->buffer->length;\n\t}\n\n\tDO_LOCK(flags);\n\n#if defined(AHA152X_STAT)\n\tHOSTDATA(shpnt)->total_commands++;\n#endif\n\n\t \n\tHOSTDATA(shpnt)->commands++;\n\tif (HOSTDATA(shpnt)->commands==1)\n\t\tSETPORT(PORTA, 1);\n\n\tappend_SC(&ISSUE_SC, SCpnt);\n\n\tif(!HOSTDATA(shpnt)->in_intr)\n\t\tsetup_expected_interrupts(shpnt);\n\n\tDO_UNLOCK(flags);\n\n\treturn 0;\n}\n\n \nstatic int aha152x_queue_lck(struct scsi_cmnd *SCpnt)\n{\n\treturn aha152x_internal_queue(SCpnt, NULL, 0);\n}\n\nstatic DEF_SCSI_QCMD(aha152x_queue)\n\n\n \nstatic void reset_done(struct scsi_cmnd *SCpnt)\n{\n\tif(SCSEM(SCpnt)) {\n\t\tcomplete(SCSEM(SCpnt));\n\t} else {\n\t\tprintk(KERN_ERR \"aha152x: reset_done w/o completion\\n\");\n\t}\n}\n\nstatic void aha152x_scsi_done(struct scsi_cmnd *SCpnt)\n{\n\tif (aha152x_priv(SCpnt)->phase & resetting)\n\t\treset_done(SCpnt);\n\telse\n\t\tscsi_done(SCpnt);\n}\n\n \nstatic int aha152x_abort(struct scsi_cmnd *SCpnt)\n{\n\tstruct Scsi_Host *shpnt = SCpnt->device->host;\n\tstruct scsi_cmnd *ptr;\n\tunsigned long flags;\n\n\tDO_LOCK(flags);\n\n\tptr=remove_SC(&ISSUE_SC, SCpnt);\n\n\tif(ptr) {\n\t\tHOSTDATA(shpnt)->commands--;\n\t\tif (!HOSTDATA(shpnt)->commands)\n\t\t\tSETPORT(PORTA, 0);\n\t\tDO_UNLOCK(flags);\n\n\t\tkfree(SCpnt->host_scribble);\n\t\tSCpnt->host_scribble=NULL;\n\n\t\treturn SUCCESS;\n\t}\n\n\tDO_UNLOCK(flags);\n\n\t \n\n\tscmd_printk(KERN_ERR, SCpnt,\n\t\t    \"cannot abort running or disconnected command\\n\");\n\n\treturn FAILED;\n}\n\n \nstatic int aha152x_device_reset(struct scsi_cmnd * SCpnt)\n{\n\tstruct Scsi_Host *shpnt = SCpnt->device->host;\n\tDECLARE_COMPLETION(done);\n\tint ret, issued, disconnected;\n\tunsigned char old_cmd_len = SCpnt->cmd_len;\n\tunsigned long flags;\n\tunsigned long timeleft;\n\n\tif(CURRENT_SC==SCpnt) {\n\t\tscmd_printk(KERN_ERR, SCpnt, \"cannot reset current device\\n\");\n\t\treturn FAILED;\n\t}\n\n\tDO_LOCK(flags);\n\tissued       = remove_SC(&ISSUE_SC, SCpnt) == NULL;\n\tdisconnected = issued && remove_SC(&DISCONNECTED_SC, SCpnt);\n\tDO_UNLOCK(flags);\n\n\tSCpnt->cmd_len         = 0;\n\n\taha152x_internal_queue(SCpnt, &done, resetting);\n\n\ttimeleft = wait_for_completion_timeout(&done, 100*HZ);\n\tif (!timeleft) {\n\t\t \n\t\tDO_LOCK(flags);\n\t\tremove_SC(&ISSUE_SC, SCpnt);\n\t\tDO_UNLOCK(flags);\n\t}\n\n\tSCpnt->cmd_len         = old_cmd_len;\n\n\tDO_LOCK(flags);\n\n\tif (aha152x_priv(SCpnt)->phase & resetted) {\n\t\tHOSTDATA(shpnt)->commands--;\n\t\tif (!HOSTDATA(shpnt)->commands)\n\t\t\tSETPORT(PORTA, 0);\n\t\tkfree(SCpnt->host_scribble);\n\t\tSCpnt->host_scribble=NULL;\n\n\t\tret = SUCCESS;\n\t} else {\n\t\t \n\t\tif(!issued) {\n\t\t\tappend_SC(&ISSUE_SC, SCpnt);\n\t\t} else if(disconnected) {\n\t\t\tappend_SC(&DISCONNECTED_SC, SCpnt);\n\t\t}\n\n\t\tret = FAILED;\n\t}\n\n\tDO_UNLOCK(flags);\n\treturn ret;\n}\n\nstatic void free_hard_reset_SCs(struct Scsi_Host *shpnt,\n\t\t\t\tstruct scsi_cmnd **SCs)\n{\n\tstruct scsi_cmnd *ptr;\n\n\tptr=*SCs;\n\twhile(ptr) {\n\t\tstruct scsi_cmnd *next;\n\n\t\tif(SCDATA(ptr)) {\n\t\t\tnext = SCNEXT(ptr);\n\t\t} else {\n\t\t\tscmd_printk(KERN_DEBUG, ptr,\n\t\t\t\t    \"queue corrupted at %p\\n\", ptr);\n\t\t\tnext = NULL;\n\t\t}\n\n\t\tif (!ptr->device->soft_reset) {\n\t\t\tremove_SC(SCs, ptr);\n\t\t\tHOSTDATA(shpnt)->commands--;\n\t\t\tkfree(ptr->host_scribble);\n\t\t\tptr->host_scribble=NULL;\n\t\t}\n\n\t\tptr = next;\n\t}\n}\n\n \nstatic int aha152x_bus_reset_host(struct Scsi_Host *shpnt)\n{\n\tunsigned long flags;\n\n\tDO_LOCK(flags);\n\n\tfree_hard_reset_SCs(shpnt, &ISSUE_SC);\n\tfree_hard_reset_SCs(shpnt, &DISCONNECTED_SC);\n\n\tSETPORT(SCSISEQ, SCSIRSTO);\n\tmdelay(256);\n\tSETPORT(SCSISEQ, 0);\n\tmdelay(DELAY);\n\n\tsetup_expected_interrupts(shpnt);\n\tif(HOSTDATA(shpnt)->commands==0)\n\t\tSETPORT(PORTA, 0);\n\n\tDO_UNLOCK(flags);\n\n\treturn SUCCESS;\n}\n\n \nstatic int aha152x_bus_reset(struct scsi_cmnd *SCpnt)\n{\n\treturn aha152x_bus_reset_host(SCpnt->device->host);\n}\n\n \nstatic void reset_ports(struct Scsi_Host *shpnt)\n{\n\tunsigned long flags;\n\n\t \n\tSETPORT(DMACNTRL0, RSTFIFO);\n\n\tSETPORT(SCSISEQ, 0);\n\n\tSETPORT(SXFRCTL1, 0);\n\tSETPORT(SCSISIG, 0);\n\tSETRATE(0);\n\n\t \n\tSETPORT(SSTAT0, 0x7f);\n\tSETPORT(SSTAT1, 0xef);\n\n\tSETPORT(SSTAT4, SYNCERR | FWERR | FRERR);\n\n\tSETPORT(DMACNTRL0, 0);\n\tSETPORT(DMACNTRL1, 0);\n\n\tSETPORT(BRSTCNTRL, 0xf1);\n\n\t \n\tSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\n\tSETPORT(SXFRCTL0, CH1);\n\n\tDO_LOCK(flags);\n\tsetup_expected_interrupts(shpnt);\n\tDO_UNLOCK(flags);\n}\n\n \nint aha152x_host_reset_host(struct Scsi_Host *shpnt)\n{\n\taha152x_bus_reset_host(shpnt);\n\treset_ports(shpnt);\n\n\treturn SUCCESS;\n}\n\n \nstatic int aha152x_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\tsector_t capacity, int *info_array)\n{\n\tstruct Scsi_Host *shpnt = sdev->host;\n\n\t \n\tinfo_array[0] = 64;\n\tinfo_array[1] = 32;\n\tinfo_array[2] = (unsigned long)capacity / (64 * 32);\n\n\t \n\tif (info_array[2] >= 1024) {\n\t\tint info[3];\n\n\t\t \n\t\tif (scsicam_bios_param(bdev, capacity, info) < 0 ||\n\t\t    !((info[0] == 64 && info[1] == 32) || (info[0] == 255 && info[1] == 63))) {\n\t\t\tif (EXT_TRANS) {\n\t\t\t\tprintk(KERN_NOTICE\n\t\t\t\t       \"aha152x: unable to verify geometry for disk with >1GB.\\n\"\n\t\t\t\t       \"         using extended translation.\\n\");\n\t\t\t\tinfo_array[0] = 255;\n\t\t\t\tinfo_array[1] = 63;\n\t\t\t\tinfo_array[2] = (unsigned long)capacity / (255 * 63);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_NOTICE\n\t\t\t\t       \"aha152x: unable to verify geometry for disk with >1GB.\\n\"\n\t\t\t\t       \"         Using default translation. Please verify yourself.\\n\"\n\t\t\t\t       \"         Perhaps you need to enable extended translation in the driver.\\n\"\n\t\t\t\t       \"         See Documentation/scsi/aha152x.rst for details.\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tinfo_array[0] = info[0];\n\t\t\tinfo_array[1] = info[1];\n\t\t\tinfo_array[2] = info[2];\n\n\t\t\tif (info[0] == 255 && !EXT_TRANS) {\n\t\t\t\tprintk(KERN_NOTICE\n\t\t\t\t       \"aha152x: current partition table is using extended translation.\\n\"\n\t\t\t\t       \"         using it also, although it's not explicitly enabled.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void done(struct Scsi_Host *shpnt, unsigned char status_byte,\n\t\t unsigned char host_byte)\n{\n\tif (CURRENT_SC) {\n\t\tif(DONE_SC)\n\t\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t\t    \"there's already a completed command %p \"\n\t\t\t\t    \"- will cause abort\\n\", DONE_SC);\n\n\t\tDONE_SC = CURRENT_SC;\n\t\tCURRENT_SC = NULL;\n\t\tset_status_byte(DONE_SC, status_byte);\n\t\tset_host_byte(DONE_SC, host_byte);\n\t} else\n\t\tprintk(KERN_ERR \"aha152x: done() called outside of command\\n\");\n}\n\nstatic struct work_struct aha152x_tq;\n\n \nstatic void run(struct work_struct *work)\n{\n\tstruct aha152x_hostdata *hd;\n\n\tlist_for_each_entry(hd, &aha152x_host_list, host_list) {\n\t\tstruct Scsi_Host *shost = container_of((void *)hd, struct Scsi_Host, hostdata);\n\n\t\tis_complete(shost);\n\t}\n}\n\n \nstatic irqreturn_t intr(int irqno, void *dev_id)\n{\n\tstruct Scsi_Host *shpnt = dev_id;\n\tunsigned long flags;\n\tunsigned char rev, dmacntrl0;\n\n\t \n\trev = GETPORT(REV);\n\tdmacntrl0 = GETPORT(DMACNTRL0);\n\tif ((rev == 0xFF) && (dmacntrl0 == 0xFF))\n\t\treturn IRQ_NONE;\n\n\tif( TESTLO(DMASTAT, INTSTAT) )\n\t\treturn IRQ_NONE;\n\n\t \n\tCLRBITS(DMACNTRL0, INTEN);\n\n\tDO_LOCK(flags);\n\tif( HOSTDATA(shpnt)->service==0 ) {\n\t\tHOSTDATA(shpnt)->service=1;\n\n\t\t \n\t\tINIT_WORK(&aha152x_tq, run);\n\t\tschedule_work(&aha152x_tq);\n\t}\n\tDO_UNLOCK(flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void busfree_run(struct Scsi_Host *shpnt)\n{\n\tunsigned long flags;\n#if defined(AHA152X_STAT)\n\tint action=0;\n#endif\n\n\tSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\n\tSETPORT(SXFRCTL0, CH1);\n\n\tSETPORT(SSTAT1, CLRBUSFREE);\n\n\tif(CURRENT_SC) {\n\t\tstruct aha152x_cmd_priv *acp = aha152x_priv(CURRENT_SC);\n\n#if defined(AHA152X_STAT)\n\t\taction++;\n#endif\n\t\tacp->phase &= ~syncneg;\n\n\t\tif (acp->phase & completed) {\n\t\t\t \n\t\t\tdone(shpnt, acp->status, DID_OK);\n\n\t\t} else if (acp->phase & aborted) {\n\t\t\tdone(shpnt, acp->status, DID_ABORT);\n\n\t\t} else if (acp->phase & resetted) {\n\t\t\tdone(shpnt, acp->status, DID_RESET);\n\n\t\t} else if (acp->phase & disconnected) {\n\t\t\t \n#if defined(AHA152X_STAT)\n\t\t\tHOSTDATA(shpnt)->disconnections++;\n#endif\n\t\t\tappend_SC(&DISCONNECTED_SC, CURRENT_SC);\n\t\t\tacp->phase |= 1 << 16;\n\t\t\tCURRENT_SC = NULL;\n\n\t\t} else {\n\t\t\tdone(shpnt, SAM_STAT_GOOD, DID_ERROR);\n\t\t}\n#if defined(AHA152X_STAT)\n\t} else {\n\t\tHOSTDATA(shpnt)->busfree_without_old_command++;\n#endif\n\t}\n\n\tDO_LOCK(flags);\n\n\tif(DONE_SC) {\n#if defined(AHA152X_STAT)\n\t\taction++;\n#endif\n\n\t\tif (aha152x_priv(DONE_SC)->phase & check_condition) {\n\t\t\tstruct scsi_cmnd *cmd = HOSTDATA(shpnt)->done_SC;\n\t\t\tstruct aha152x_scdata *sc = SCDATA(cmd);\n\n\t\t\tscsi_eh_restore_cmnd(cmd, &sc->ses);\n\n\t\t\taha152x_priv(cmd)->status = SAM_STAT_CHECK_CONDITION;\n\n\t\t\tHOSTDATA(shpnt)->commands--;\n\t\t\tif (!HOSTDATA(shpnt)->commands)\n\t\t\t\tSETPORT(PORTA, 0);\t \n\t\t} else if (aha152x_priv(DONE_SC)->status == SAM_STAT_CHECK_CONDITION) {\n#if defined(AHA152X_STAT)\n\t\t\tHOSTDATA(shpnt)->busfree_with_check_condition++;\n#endif\n\n\t\t\tif (!(aha152x_priv(DONE_SC)->phase & not_issued)) {\n\t\t\t\tstruct aha152x_scdata *sc;\n\t\t\t\tstruct scsi_cmnd *ptr = DONE_SC;\n\t\t\t\tDONE_SC=NULL;\n\n\t\t\t\tsc = SCDATA(ptr);\n\t\t\t\t \n\t\t\t\tBUG_ON(!sc);\n\t\t\t\tscsi_eh_prep_cmnd(ptr, &sc->ses, NULL, 0, ~0);\n\n\t\t\t\tDO_UNLOCK(flags);\n\t\t\t\taha152x_internal_queue(ptr, NULL, check_condition);\n\t\t\t\tDO_LOCK(flags);\n\t\t\t}\n\t\t}\n\n\t\tif (DONE_SC) {\n\t\t\tstruct scsi_cmnd *ptr = DONE_SC;\n\t\t\tDONE_SC=NULL;\n\n\t\t\t \n\t\t\tHOSTDATA(shpnt)->commands--;\n\t\t\tif (!HOSTDATA(shpnt)->commands)\n\t\t\t\tSETPORT(PORTA, 0);\t \n\n\t\t\tif (!(aha152x_priv(ptr)->phase & resetting)) {\n\t\t\t\tkfree(ptr->host_scribble);\n\t\t\t\tptr->host_scribble=NULL;\n\t\t\t}\n\n\t\t\tDO_UNLOCK(flags);\n\t\t\taha152x_scsi_done(ptr);\n\t\t\tDO_LOCK(flags);\n\t\t}\n\n\t\tDONE_SC=NULL;\n#if defined(AHA152X_STAT)\n\t} else {\n\t\tHOSTDATA(shpnt)->busfree_without_done_command++;\n#endif\n\t}\n\n\tif(ISSUE_SC)\n\t\tCURRENT_SC = remove_first_SC(&ISSUE_SC);\n\n\tDO_UNLOCK(flags);\n\n\tif(CURRENT_SC) {\n\t\tstruct aha152x_cmd_priv *acp = aha152x_priv(CURRENT_SC);\n\n#if defined(AHA152X_STAT)\n\t\taction++;\n#endif\n\t\tacp->phase |= selecting;\n\n\t\t \n\t\tSETPORT(SSTAT1, SELTO);\n\n\t\tSETPORT(SCSIID, (shpnt->this_id << OID_) | CURRENT_SC->device->id);\n\t\tSETPORT(SXFRCTL1, (PARITY ? ENSPCHK : 0 ) | ENSTIMER);\n\t\tSETPORT(SCSISEQ, ENSELO | ENAUTOATNO | (DISCONNECTED_SC ? ENRESELI : 0));\n\t} else {\n#if defined(AHA152X_STAT)\n\t\tHOSTDATA(shpnt)->busfree_without_new_command++;\n#endif\n\t\tSETPORT(SCSISEQ, DISCONNECTED_SC ? ENRESELI : 0);\n\t}\n\n#if defined(AHA152X_STAT)\n\tif(!action)\n\t\tHOSTDATA(shpnt)->busfree_without_any_action++;\n#endif\n}\n\n \nstatic void seldo_run(struct Scsi_Host *shpnt)\n{\n\tstruct aha152x_cmd_priv *acp = aha152x_priv(CURRENT_SC);\n\n\tSETPORT(SCSISIG, 0);\n\tSETPORT(SSTAT1, CLRBUSFREE);\n\tSETPORT(SSTAT1, CLRPHASECHG);\n\n\tacp->phase &= ~(selecting | not_issued);\n\n\tSETPORT(SCSISEQ, 0);\n\n\tif (TESTLO(SSTAT0, SELDO)) {\n\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t    \"aha152x: passing bus free condition\\n\");\n\t\tdone(shpnt, SAM_STAT_GOOD, DID_NO_CONNECT);\n\t\treturn;\n\t}\n\n\tSETPORT(SSTAT0, CLRSELDO);\n\n\tADDMSGO(IDENTIFY(RECONNECT, CURRENT_SC->device->lun));\n\n\tif (acp->phase & aborting) {\n\t\tADDMSGO(ABORT);\n\t} else if (acp->phase & resetting) {\n\t\tADDMSGO(BUS_DEVICE_RESET);\n\t} else if (SYNCNEG==0 && SYNCHRONOUS) {\n\t\tacp->phase |= syncneg;\n\t\tMSGOLEN += spi_populate_sync_msg(&MSGO(MSGOLEN), 50, 8);\n\t\tSYNCNEG=1;\t\t \n\t}\n\n\tSETRATE(SYNCRATE);\n}\n\n \nstatic void selto_run(struct Scsi_Host *shpnt)\n{\n\tstruct aha152x_cmd_priv *acp;\n\n\tSETPORT(SCSISEQ, 0);\n\tSETPORT(SSTAT1, CLRSELTIMO);\n\n\tif (!CURRENT_SC)\n\t\treturn;\n\n\tacp = aha152x_priv(CURRENT_SC);\n\tacp->phase &= ~selecting;\n\n\tif (acp->phase & aborted)\n\t\tdone(shpnt, SAM_STAT_GOOD, DID_ABORT);\n\telse if (TESTLO(SSTAT0, SELINGO))\n\t\tdone(shpnt, SAM_STAT_GOOD, DID_BUS_BUSY);\n\telse\n\t\t \n\t\tdone(shpnt, SAM_STAT_GOOD, DID_NO_CONNECT);\n}\n\n \nstatic void seldi_run(struct Scsi_Host *shpnt)\n{\n\tint selid;\n\tint target;\n\tunsigned long flags;\n\n\tSETPORT(SCSISIG, 0);\n\tSETPORT(SSTAT0, CLRSELDI);\n\tSETPORT(SSTAT1, CLRBUSFREE);\n\tSETPORT(SSTAT1, CLRPHASECHG);\n\n\tif(CURRENT_SC) {\n\t\tstruct aha152x_cmd_priv *acp = aha152x_priv(CURRENT_SC);\n\n\t\tif (!(acp->phase & not_issued))\n\t\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t\t    \"command should not have been issued yet\\n\");\n\n\t\tDO_LOCK(flags);\n\t\tappend_SC(&ISSUE_SC, CURRENT_SC);\n\t\tDO_UNLOCK(flags);\n\n\t\tCURRENT_SC = NULL;\n\t}\n\n\tif (!DISCONNECTED_SC)\n\t\treturn;\n\n\tRECONN_TARGET=-1;\n\n\tselid = GETPORT(SELID) & ~(1 << shpnt->this_id);\n\n\tif (selid==0) {\n\t\tshost_printk(KERN_INFO, shpnt,\n\t\t\t     \"target id unknown (%02x)\\n\", selid);\n\t\treturn;\n\t}\n\n\tfor(target=7; !(selid & (1 << target)); target--)\n\t\t;\n\n\tif(selid & ~(1 << target)) {\n\t\tshost_printk(KERN_INFO, shpnt,\n\t\t\t     \"multiple targets reconnected (%02x)\\n\", selid);\n\t}\n\n\n\tSETPORT(SCSIID, (shpnt->this_id << OID_) | target);\n\tSETPORT(SCSISEQ, 0);\n\n\tSETRATE(HOSTDATA(shpnt)->syncrate[target]);\n\n\tRECONN_TARGET=target;\n}\n\n \nstatic void msgi_run(struct Scsi_Host *shpnt)\n{\n\tfor(;;) {\n\t\tstruct aha152x_cmd_priv *acp;\n\t\tint sstat1 = GETPORT(SSTAT1);\n\n\t\tif(sstat1 & (PHASECHG|PHASEMIS|BUSFREE) || !(sstat1 & REQINIT))\n\t\t\treturn;\n\n\t\tif (TESTLO(SSTAT0, SPIORDY))\n\t\t\treturn;\n\n\t\tADDMSGI(GETPORT(SCSIDAT));\n\n\t\tif(!CURRENT_SC) {\n\t\t\tif(LASTSTATE!=seldi) {\n\t\t\t\tshost_printk(KERN_ERR, shpnt,\n\t\t\t\t\t     \"message in w/o current command\"\n\t\t\t\t\t     \" not after reselection\\n\");\n\t\t\t}\n\n\t\t\t \n\t\t\tif(!(MSGI(0) & IDENTIFY_BASE)) {\n\t\t\t\tshost_printk(KERN_ERR, shpnt,\n\t\t\t\t\t     \"target didn't identify after reselection\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tCURRENT_SC = remove_lun_SC(&DISCONNECTED_SC, RECONN_TARGET, MSGI(0) & 0x3f);\n\n\t\t\tif (!CURRENT_SC) {\n\t\t\t\tshow_queues(shpnt);\n\t\t\t\tshost_printk(KERN_ERR, shpnt,\n\t\t\t\t\t     \"no disconnected command\"\n\t\t\t\t\t     \" for target %d/%d\\n\",\n\t\t\t\t\t     RECONN_TARGET, MSGI(0) & 0x3f);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tacp = aha152x_priv(CURRENT_SC);\n\t\t\tacp->message = MSGI(0);\n\t\t\tacp->phase &= ~disconnected;\n\n\t\t\tMSGILEN=0;\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tacp = aha152x_priv(CURRENT_SC);\n\t\tacp->message = MSGI(0);\n\n\t\tswitch (MSGI(0)) {\n\t\tcase DISCONNECT:\n\t\t\tif (!RECONNECT)\n\t\t\t\tscmd_printk(KERN_WARNING, CURRENT_SC,\n\t\t\t\t\t    \"target was not allowed to disconnect\\n\");\n\n\t\t\tacp->phase |= disconnected;\n\t\t\tbreak;\n\n\t\tcase COMMAND_COMPLETE:\n\t\t\tacp->phase |= completed;\n\t\t\tbreak;\n\n\t\tcase MESSAGE_REJECT:\n\t\t\tif (SYNCNEG==1) {\n\t\t\t\tscmd_printk(KERN_INFO, CURRENT_SC,\n\t\t\t\t\t    \"Synchronous Data Transfer Request\"\n\t\t\t\t\t    \" was rejected\\n\");\n\t\t\t\tSYNCNEG=2;\t \n\t\t\t} else\n\t\t\t\tscmd_printk(KERN_INFO, CURRENT_SC,\n\t\t\t\t\t    \"inbound message (MESSAGE REJECT)\\n\");\n\t\t\tbreak;\n\n\t\tcase SAVE_POINTERS:\n\t\t\tbreak;\n\n\t\tcase RESTORE_POINTERS:\n\t\t\tbreak;\n\n\t\tcase EXTENDED_MESSAGE:\n\t\t\tif(MSGILEN<2 || MSGILEN<MSGI(1)+2) {\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (MSGI(2)) {\n\t\t\tcase EXTENDED_SDTR:\n\t\t\t\t{\n\t\t\t\t\tlong ticks;\n\n\t\t\t\t\tif (MSGI(1) != 3) {\n\t\t\t\t\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t\t\t\t\t    \"SDTR message length!=3\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!HOSTDATA(shpnt)->synchronous)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tprintk(INFO_LEAD, CMDINFO(CURRENT_SC));\n\t\t\t\t\tspi_print_msg(&MSGI(0));\n\t\t\t\t\tprintk(\"\\n\");\n\n\t\t\t\t\tticks = (MSGI(3) * 4 + 49) / 50;\n\n\t\t\t\t\tif (syncneg) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (ticks > 9 || MSGI(4) < 1 || MSGI(4) > 8) {\n\t\t\t\t\t\t\tADDMSGO(MESSAGE_REJECT);\n\t\t\t\t\t\t\tscmd_printk(KERN_INFO,\n\t\t\t\t\t\t\t\t    CURRENT_SC,\n\t\t\t\t\t\t\t\t    \"received Synchronous Data Transfer Request invalid - rejected\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tSYNCRATE |= ((ticks - 2) << 4) + MSGI(4);\n\t\t\t\t\t} else if (ticks <= 9 && MSGI(4) >= 1) {\n\t\t\t\t\t\tADDMSGO(EXTENDED_MESSAGE);\n\t\t\t\t\t\tADDMSGO(3);\n\t\t\t\t\t\tADDMSGO(EXTENDED_SDTR);\n\t\t\t\t\t\tif (ticks < 4) {\n\t\t\t\t\t\t\tticks = 4;\n\t\t\t\t\t\t\tADDMSGO(50);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tADDMSGO(MSGI(3));\n\n\t\t\t\t\t\tif (MSGI(4) > 8)\n\t\t\t\t\t\t\tMSGI(4) = 8;\n\n\t\t\t\t\t\tADDMSGO(MSGI(4));\n\n\t\t\t\t\t\tSYNCRATE |= ((ticks - 2) << 4) + MSGI(4);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t \n\t\t\t\t\t\tscmd_printk(KERN_INFO,\n\t\t\t\t\t\t\t    CURRENT_SC,\n\t\t\t\t\t\t\t    \"Synchronous Data Transfer Request too slow - Rejecting\\n\");\n\t\t\t\t\t\tADDMSGO(MESSAGE_REJECT);\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tSYNCNEG=2;\n\t\t\t\t\tSETRATE(SYNCRATE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase BUS_DEVICE_RESET:\n\t\t\t\t{\n\t\t\t\t\tint i;\n\n\t\t\t\t\tfor(i=0; i<8; i++) {\n\t\t\t\t\t\tHOSTDATA(shpnt)->syncrate[i]=0;\n\t\t\t\t\t\tHOSTDATA(shpnt)->syncneg[i]=0;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EXTENDED_MODIFY_DATA_POINTER:\n\t\t\tcase EXTENDED_EXTENDED_IDENTIFY:\n\t\t\tcase EXTENDED_WDTR:\n\t\t\tdefault:\n\t\t\t\tADDMSGO(MESSAGE_REJECT);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tMSGILEN=0;\n\t}\n}\n\nstatic void msgi_end(struct Scsi_Host *shpnt)\n{\n\tif(MSGILEN>0)\n\t\tscmd_printk(KERN_WARNING, CURRENT_SC,\n\t\t\t    \"target left before message completed (%d)\\n\",\n\t\t\t    MSGILEN);\n\n\tif (MSGOLEN > 0 && !(GETPORT(SSTAT1) & BUSFREE))\n\t\tSETPORT(SCSISIG, P_MSGI | SIG_ATNO);\n}\n\n \nstatic void msgo_init(struct Scsi_Host *shpnt)\n{\n\tif(MSGOLEN==0) {\n\t\tif ((aha152x_priv(CURRENT_SC)->phase & syncneg) &&\n\t\t    SYNCNEG == 2 && SYNCRATE == 0) {\n\t\t\tADDMSGO(IDENTIFY(RECONNECT, CURRENT_SC->device->lun));\n\t\t} else {\n\t\t\tscmd_printk(KERN_INFO, CURRENT_SC,\n\t\t\t\t    \"unexpected MESSAGE OUT phase; rejecting\\n\");\n\t\t\tADDMSGO(MESSAGE_REJECT);\n\t\t}\n\t}\n\n}\n\n \nstatic void msgo_run(struct Scsi_Host *shpnt)\n{\n\tstruct aha152x_cmd_priv *acp = aha152x_priv(CURRENT_SC);\n\n\twhile(MSGO_I<MSGOLEN) {\n\t\tif (TESTLO(SSTAT0, SPIORDY))\n\t\t\treturn;\n\n\t\tif (MSGO_I==MSGOLEN-1) {\n\t\t\t \n\t\t\tSETPORT(SSTAT1, CLRATNO);\n\t\t}\n\n\n\t\tif (MSGO(MSGO_I) & IDENTIFY_BASE)\n\t\t\tacp->phase |= identified;\n\n\t\tif (MSGO(MSGO_I)==ABORT)\n\t\t\tacp->phase |= aborted;\n\n\t\tif (MSGO(MSGO_I)==BUS_DEVICE_RESET)\n\t\t\tacp->phase |= resetted;\n\n\t\tSETPORT(SCSIDAT, MSGO(MSGO_I++));\n\t}\n}\n\nstatic void msgo_end(struct Scsi_Host *shpnt)\n{\n\tif(MSGO_I<MSGOLEN) {\n\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t    \"message sent incompletely (%d/%d)\\n\",\n\t\t\t    MSGO_I, MSGOLEN);\n\t\tif(SYNCNEG==1) {\n\t\t\tscmd_printk(KERN_INFO, CURRENT_SC,\n\t\t\t\t    \"Synchronous Data Transfer Request was rejected\\n\");\n\t\t\tSYNCNEG=2;\n\t\t}\n\t}\n\n\tMSGO_I  = 0;\n\tMSGOLEN = 0;\n}\n\n \nstatic void cmd_init(struct Scsi_Host *shpnt)\n{\n\tif (aha152x_priv(CURRENT_SC)->sent_command) {\n\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t    \"command already sent\\n\");\n\t\tdone(shpnt, SAM_STAT_GOOD, DID_ERROR);\n\t\treturn;\n\t}\n\n\tCMD_I=0;\n}\n\n \nstatic void cmd_run(struct Scsi_Host *shpnt)\n{\n\twhile(CMD_I<CURRENT_SC->cmd_len) {\n\t\tif (TESTLO(SSTAT0, SPIORDY))\n\t\t\treturn;\n\n\t\tSETPORT(SCSIDAT, CURRENT_SC->cmnd[CMD_I++]);\n\t}\n}\n\nstatic void cmd_end(struct Scsi_Host *shpnt)\n{\n\tif(CMD_I<CURRENT_SC->cmd_len)\n\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t    \"command sent incompletely (%d/%d)\\n\",\n\t\t\t    CMD_I, CURRENT_SC->cmd_len);\n\telse\n\t\taha152x_priv(CURRENT_SC)->sent_command++;\n}\n\n \nstatic void status_run(struct Scsi_Host *shpnt)\n{\n\tif (TESTLO(SSTAT0, SPIORDY))\n\t\treturn;\n\n\taha152x_priv(CURRENT_SC)->status = GETPORT(SCSIDAT);\n\n}\n\n \nstatic void datai_init(struct Scsi_Host *shpnt)\n{\n\tSETPORT(DMACNTRL0, RSTFIFO);\n\tSETPORT(DMACNTRL0, RSTFIFO|ENDMA);\n\n\tSETPORT(SXFRCTL0, CH1|CLRSTCNT);\n\tSETPORT(SXFRCTL0, CH1|SCSIEN|DMAEN);\n\n\tSETPORT(SIMODE0, 0);\n\tSETPORT(SIMODE1, ENSCSIPERR | ENSCSIRST | ENPHASEMIS | ENBUSFREE);\n\n\tDATA_LEN=0;\n}\n\nstatic void datai_run(struct Scsi_Host *shpnt)\n{\n\tstruct aha152x_cmd_priv *acp;\n\tunsigned long the_time;\n\tint fifodata, data_count;\n\n\t \n\twhile(TESTLO(DMASTAT, INTSTAT) || TESTLO(DMASTAT, DFIFOEMP) || TESTLO(SSTAT2, SEMPTY)) {\n\t\t \n\t\tthe_time=jiffies + 100*HZ;\n\t\twhile(TESTLO(DMASTAT, DFIFOFULL|INTSTAT) && time_before(jiffies,the_time))\n\t\t\tbarrier();\n\n\t\tif(TESTLO(DMASTAT, DFIFOFULL|INTSTAT)) {\n\t\t\tscmd_printk(KERN_ERR, CURRENT_SC, \"datai timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif(TESTHI(DMASTAT, DFIFOFULL)) {\n\t\t\tfifodata = 128;\n\t\t} else {\n\t\t\tthe_time=jiffies + 100*HZ;\n\t\t\twhile(TESTLO(SSTAT2, SEMPTY) && time_before(jiffies,the_time))\n\t\t\t\tbarrier();\n\n\t\t\tif(TESTLO(SSTAT2, SEMPTY)) {\n\t\t\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t\t\t    \"datai sempty timeout\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfifodata = GETPORT(FIFOSTAT);\n\t\t}\n\n\t\tacp = aha152x_priv(CURRENT_SC);\n\t\tif (acp->this_residual > 0) {\n\t\t\twhile (fifodata > 0 && acp->this_residual > 0) {\n\t\t\t\tdata_count = fifodata > acp->this_residual ?\n\t\t\t\t\t\tacp->this_residual : fifodata;\n\t\t\t\tfifodata -= data_count;\n\n\t\t\t\tif (data_count & 1) {\n\t\t\t\t\tSETPORT(DMACNTRL0, ENDMA|_8BIT);\n\t\t\t\t\t*acp->ptr++ = GETPORT(DATAPORT);\n\t\t\t\t\tacp->this_residual--;\n\t\t\t\t\tDATA_LEN++;\n\t\t\t\t\tSETPORT(DMACNTRL0, ENDMA);\n\t\t\t\t}\n\n\t\t\t\tif (data_count > 1) {\n\t\t\t\t\tdata_count >>= 1;\n\t\t\t\t\tinsw(DATAPORT, acp->ptr, data_count);\n\t\t\t\t\tacp->ptr += 2 * data_count;\n\t\t\t\t\tacp->this_residual -= 2 * data_count;\n\t\t\t\t\tDATA_LEN += 2 * data_count;\n\t\t\t\t}\n\n\t\t\t\tif (acp->this_residual == 0 &&\n\t\t\t\t    !sg_is_last(acp->buffer)) {\n\t\t\t\t\t \n\t\t\t\t\tacp->buffer = sg_next(acp->buffer);\n\t\t\t\t\tacp->ptr = SG_ADDRESS(acp->buffer);\n\t\t\t\t\tacp->this_residual = acp->buffer->length;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (fifodata > 0) {\n\t\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t\t    \"no buffers left for %d(%d) bytes\"\n\t\t\t\t    \" (data overrun!?)\\n\",\n\t\t\t\t    fifodata, GETPORT(FIFOSTAT));\n\t\t\tSETPORT(DMACNTRL0, ENDMA|_8BIT);\n\t\t\twhile(fifodata>0) {\n\t\t\t\tGETPORT(DATAPORT);\n\t\t\t\tfifodata--;\n\t\t\t\tDATA_LEN++;\n\t\t\t}\n\t\t\tSETPORT(DMACNTRL0, ENDMA|_8BIT);\n\t\t}\n\t}\n\n\tif(TESTLO(DMASTAT, INTSTAT) ||\n\t   TESTLO(DMASTAT, DFIFOEMP) ||\n\t   TESTLO(SSTAT2, SEMPTY) ||\n\t   GETPORT(FIFOSTAT)>0) {\n\t\t \n\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t    \"fifos should be empty and phase should have changed\\n\");\n\t}\n\n\tif(DATA_LEN!=GETSTCNT()) {\n\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t    \"manual transfer count differs from automatic \"\n\t\t\t    \"(count=%d;stcnt=%d;diff=%d;fifostat=%d)\",\n\t\t\t    DATA_LEN, GETSTCNT(), GETSTCNT()-DATA_LEN,\n\t\t\t    GETPORT(FIFOSTAT));\n\t\tmdelay(10000);\n\t}\n}\n\nstatic void datai_end(struct Scsi_Host *shpnt)\n{\n\tCMD_INC_RESID(CURRENT_SC, -GETSTCNT());\n\n\tSETPORT(SXFRCTL0, CH1|CLRSTCNT);\n\tSETPORT(DMACNTRL0, 0);\n}\n\n \nstatic void datao_init(struct Scsi_Host *shpnt)\n{\n\tSETPORT(DMACNTRL0, WRITE_READ | RSTFIFO);\n\tSETPORT(DMACNTRL0, WRITE_READ | ENDMA);\n\n\tSETPORT(SXFRCTL0, CH1|CLRSTCNT);\n\tSETPORT(SXFRCTL0, CH1|SCSIEN|DMAEN);\n\n\tSETPORT(SIMODE0, 0);\n\tSETPORT(SIMODE1, ENSCSIPERR | ENSCSIRST | ENPHASEMIS | ENBUSFREE );\n\n\tDATA_LEN = scsi_get_resid(CURRENT_SC);\n}\n\nstatic void datao_run(struct Scsi_Host *shpnt)\n{\n\tstruct aha152x_cmd_priv *acp = aha152x_priv(CURRENT_SC);\n\tunsigned long the_time;\n\tint data_count;\n\n\t \n\twhile (TESTLO(DMASTAT, INTSTAT) && acp->this_residual > 0) {\n\t\tdata_count = 128;\n\t\tif (data_count > acp->this_residual)\n\t\t\tdata_count = acp->this_residual;\n\n\t\tif(TESTLO(DMASTAT, DFIFOEMP)) {\n\t\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t\t    \"datao fifo not empty (%d)\",\n\t\t\t\t    GETPORT(FIFOSTAT));\n\t\t\tbreak;\n\t\t}\n\n\t\tif(data_count & 1) {\n\t\t\tSETPORT(DMACNTRL0,WRITE_READ|ENDMA|_8BIT);\n\t\t\tSETPORT(DATAPORT, *acp->ptr++);\n\t\t\tacp->this_residual--;\n\t\t\tCMD_INC_RESID(CURRENT_SC, -1);\n\t\t\tSETPORT(DMACNTRL0,WRITE_READ|ENDMA);\n\t\t}\n\n\t\tif(data_count > 1) {\n\t\t\tdata_count >>= 1;\n\t\t\toutsw(DATAPORT, acp->ptr, data_count);\n\t\t\tacp->ptr += 2 * data_count;\n\t\t\tacp->this_residual -= 2 * data_count;\n\t\t\tCMD_INC_RESID(CURRENT_SC, -2 * data_count);\n\t\t}\n\n\t\tif (acp->this_residual == 0 && !sg_is_last(acp->buffer)) {\n\t\t\t \n\t\t\tacp->buffer = sg_next(acp->buffer);\n\t\t\tacp->ptr = SG_ADDRESS(acp->buffer);\n\t\t\tacp->this_residual = acp->buffer->length;\n\t\t}\n\n\t\tthe_time=jiffies + 100*HZ;\n\t\twhile(TESTLO(DMASTAT, DFIFOEMP|INTSTAT) && time_before(jiffies,the_time))\n\t\t\tbarrier();\n\n\t\tif(TESTLO(DMASTAT, DFIFOEMP|INTSTAT)) {\n\t\t\tscmd_printk(KERN_ERR, CURRENT_SC, \"dataout timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void datao_end(struct Scsi_Host *shpnt)\n{\n\tstruct aha152x_cmd_priv *acp = aha152x_priv(CURRENT_SC);\n\n\tif(TESTLO(DMASTAT, DFIFOEMP)) {\n\t\tu32 datao_cnt = GETSTCNT();\n\t\tint datao_out = DATA_LEN - scsi_get_resid(CURRENT_SC);\n\t\tint done;\n\t\tstruct scatterlist *sg = scsi_sglist(CURRENT_SC);\n\n\t\tCMD_INC_RESID(CURRENT_SC, datao_out - datao_cnt);\n\n\t\tdone = scsi_bufflen(CURRENT_SC) - scsi_get_resid(CURRENT_SC);\n\t\t \n\t\twhile (done > 0 && !sg_is_last(sg)) {\n\t\t\tif (done < sg->length)\n\t\t\t\tbreak;\n\t\t\tdone -= sg->length;\n\t\t\tsg = sg_next(sg);\n\t\t}\n\n\t\tacp->buffer = sg;\n\t\tacp->ptr = SG_ADDRESS(acp->buffer) + done;\n\t\tacp->this_residual = acp->buffer->length - done;\n\t}\n\n\tSETPORT(SXFRCTL0, CH1|CLRCH1|CLRSTCNT);\n\tSETPORT(SXFRCTL0, CH1);\n\n\tSETPORT(DMACNTRL0, 0);\n}\n\n \nstatic int update_state(struct Scsi_Host *shpnt)\n{\n\tint dataphase=0;\n\tunsigned int stat0 = GETPORT(SSTAT0);\n\tunsigned int stat1 = GETPORT(SSTAT1);\n\n\tPREVSTATE = STATE;\n\tSTATE=unknown;\n\n\tif(stat1 & SCSIRSTI) {\n\t\tSTATE=rsti;\n\t\tSETPORT(SCSISEQ,0);\n\t\tSETPORT(SSTAT1,SCSIRSTI);\n\t} else if (stat0 & SELDI && PREVSTATE == busfree) {\n\t\tSTATE=seldi;\n\t} else if (stat0 & SELDO && CURRENT_SC &&\n\t\t   (aha152x_priv(CURRENT_SC)->phase & selecting)) {\n\t\tSTATE=seldo;\n\t} else if(stat1 & SELTO) {\n\t\tSTATE=selto;\n\t} else if(stat1 & BUSFREE) {\n\t\tSTATE=busfree;\n\t\tSETPORT(SSTAT1,BUSFREE);\n\t} else if(stat1 & SCSIPERR) {\n\t\tSTATE=parerr;\n\t\tSETPORT(SSTAT1,SCSIPERR);\n\t} else if(stat1 & REQINIT) {\n\t\tswitch(GETPORT(SCSISIG) & P_MASK) {\n\t\tcase P_MSGI:\tSTATE=msgi;\tbreak;\n\t\tcase P_MSGO:\tSTATE=msgo;\tbreak;\n\t\tcase P_DATAO:\tSTATE=datao;\tbreak;\n\t\tcase P_DATAI:\tSTATE=datai;\tbreak;\n\t\tcase P_STATUS:\tSTATE=status;\tbreak;\n\t\tcase P_CMD:\tSTATE=cmd;\tbreak;\n\t\t}\n\t\tdataphase=1;\n\t}\n\n\tif((stat0 & SELDI) && STATE!=seldi && !dataphase) {\n\t\tscmd_printk(KERN_INFO, CURRENT_SC, \"reselection missed?\");\n\t}\n\n\tif(STATE!=PREVSTATE) {\n\t\tLASTSTATE=PREVSTATE;\n\t}\n\n\treturn dataphase;\n}\n\n \nstatic void parerr_run(struct Scsi_Host *shpnt)\n{\n\tscmd_printk(KERN_ERR, CURRENT_SC, \"parity error\\n\");\n\tdone(shpnt, SAM_STAT_GOOD, DID_PARITY);\n}\n\n \nstatic void rsti_run(struct Scsi_Host *shpnt)\n{\n\tstruct scsi_cmnd *ptr;\n\n\tshost_printk(KERN_NOTICE, shpnt, \"scsi reset in\\n\");\n\n\tptr=DISCONNECTED_SC;\n\twhile(ptr) {\n\t\tstruct scsi_cmnd *next = SCNEXT(ptr);\n\n\t\tif (!ptr->device->soft_reset) {\n\t\t\tremove_SC(&DISCONNECTED_SC, ptr);\n\n\t\t\tkfree(ptr->host_scribble);\n\t\t\tptr->host_scribble=NULL;\n\n\t\t\tset_host_byte(ptr, DID_RESET);\n\t\t\taha152x_scsi_done(ptr);\n\t\t}\n\n\t\tptr = next;\n\t}\n\n\tif(CURRENT_SC && !CURRENT_SC->device->soft_reset)\n\t\tdone(shpnt, SAM_STAT_GOOD, DID_RESET);\n}\n\n\n \nstatic void is_complete(struct Scsi_Host *shpnt)\n{\n\tint dataphase;\n\tunsigned long flags;\n\tint pending;\n\n\tif(!shpnt)\n\t\treturn;\n\n\tDO_LOCK(flags);\n\n\tif( HOSTDATA(shpnt)->service==0 )  {\n\t\tDO_UNLOCK(flags);\n\t\treturn;\n\t}\n\n\tHOSTDATA(shpnt)->service = 0;\n\n\tif(HOSTDATA(shpnt)->in_intr) {\n\t\tDO_UNLOCK(flags);\n\t\t \n\t\taha152x_error(shpnt, \"bottom-half already running!?\");\n\t}\n\tHOSTDATA(shpnt)->in_intr++;\n\n\t \n\tdo {\n\t\tunsigned long start = jiffies;\n\t\tDO_UNLOCK(flags);\n\n\t\tdataphase=update_state(shpnt);\n\n\t\t \n\t\tif(PREVSTATE!=STATE && states[PREVSTATE].end)\n\t\t\tstates[PREVSTATE].end(shpnt);\n\n\t\t \n\t\tif(states[PREVSTATE].spio && !states[STATE].spio) {\n\t\t\tSETPORT(SXFRCTL0, CH1);\n\t\t\tSETPORT(DMACNTRL0, 0);\n\t\t\tif(CURRENT_SC)\n\t\t\t\taha152x_priv(CURRENT_SC)->phase &= ~spiordy;\n\t\t}\n\n\t\t \n\t\tif(dataphase) {\n\t\t\tSETPORT(SSTAT0, REQINIT);\n\t\t\tSETPORT(SCSISIG, GETPORT(SCSISIG) & P_MASK);\n\t\t\tSETPORT(SSTAT1, PHASECHG);\n\t\t}\n\n\t\t \n\t\tif(!states[PREVSTATE].spio && states[STATE].spio) {\n\t\t\tSETPORT(DMACNTRL0, 0);\n\t\t\tSETPORT(SXFRCTL0, CH1|SPIOEN);\n\t\t\tif(CURRENT_SC)\n\t\t\t\taha152x_priv(CURRENT_SC)->phase |= spiordy;\n\t\t}\n\n\t\t \n\t\tif(PREVSTATE!=STATE && states[STATE].init)\n\t\t\tstates[STATE].init(shpnt);\n\n\t\t \n\t\tif(states[STATE].run)\n\t\t\tstates[STATE].run(shpnt);\n\t\telse\n\t\t\tscmd_printk(KERN_ERR, CURRENT_SC,\n\t\t\t\t    \"unexpected state (%x)\\n\", STATE);\n\n\t\t \n\t\tDO_LOCK(flags);\n\t\tpending=setup_expected_interrupts(shpnt);\n#if defined(AHA152X_STAT)\n\t\tHOSTDATA(shpnt)->count[STATE]++;\n\t\tif(PREVSTATE!=STATE)\n\t\t\tHOSTDATA(shpnt)->count_trans[STATE]++;\n\t\tHOSTDATA(shpnt)->time[STATE] += jiffies-start;\n#endif\n\n\t} while(pending);\n\n\t \n\tHOSTDATA(shpnt)->in_intr--;\n\tSETBITS(DMACNTRL0, INTEN);\n\tDO_UNLOCK(flags);\n}\n\n\n \nstatic void aha152x_error(struct Scsi_Host *shpnt, char *msg)\n{\n\tshost_printk(KERN_EMERG, shpnt, \"%s\\n\", msg);\n\tshow_queues(shpnt);\n\tpanic(\"aha152x panic\\n\");\n}\n\n \nstatic void disp_enintr(struct Scsi_Host *shpnt)\n{\n\tint s0, s1;\n\n\ts0 = GETPORT(SIMODE0);\n\ts1 = GETPORT(SIMODE1);\n\n\tshost_printk(KERN_DEBUG, shpnt,\n\t\t     \"enabled interrupts (%s%s%s%s%s%s%s%s%s%s%s%s%s%s)\\n\",\n\t\t     (s0 & ENSELDO) ? \"ENSELDO \" : \"\",\n\t\t     (s0 & ENSELDI) ? \"ENSELDI \" : \"\",\n\t\t     (s0 & ENSELINGO) ? \"ENSELINGO \" : \"\",\n\t\t     (s0 & ENSWRAP) ? \"ENSWRAP \" : \"\",\n\t\t     (s0 & ENSDONE) ? \"ENSDONE \" : \"\",\n\t\t     (s0 & ENSPIORDY) ? \"ENSPIORDY \" : \"\",\n\t\t     (s0 & ENDMADONE) ? \"ENDMADONE \" : \"\",\n\t\t     (s1 & ENSELTIMO) ? \"ENSELTIMO \" : \"\",\n\t\t     (s1 & ENATNTARG) ? \"ENATNTARG \" : \"\",\n\t\t     (s1 & ENPHASEMIS) ? \"ENPHASEMIS \" : \"\",\n\t\t     (s1 & ENBUSFREE) ? \"ENBUSFREE \" : \"\",\n\t\t     (s1 & ENSCSIPERR) ? \"ENSCSIPERR \" : \"\",\n\t\t     (s1 & ENPHASECHG) ? \"ENPHASECHG \" : \"\",\n\t\t     (s1 & ENREQINIT) ? \"ENREQINIT \" : \"\");\n}\n\n \nstatic void show_command(struct scsi_cmnd *ptr)\n{\n\tconst int phase = aha152x_priv(ptr)->phase;\n\n\tscsi_print_command(ptr);\n\tscmd_printk(KERN_DEBUG, ptr,\n\t\t    \"request_bufflen=%d; resid=%d; \"\n\t\t    \"phase |%s%s%s%s%s%s%s%s%s; next=0x%p\",\n\t\t    scsi_bufflen(ptr), scsi_get_resid(ptr),\n\t\t    phase & not_issued ? \"not issued|\" : \"\",\n\t\t    phase & selecting ? \"selecting|\" : \"\",\n\t\t    phase & identified ? \"identified|\" : \"\",\n\t\t    phase & disconnected ? \"disconnected|\" : \"\",\n\t\t    phase & completed ? \"completed|\" : \"\",\n\t\t    phase & spiordy ? \"spiordy|\" : \"\",\n\t\t    phase & syncneg ? \"syncneg|\" : \"\",\n\t\t    phase & aborted ? \"aborted|\" : \"\",\n\t\t    phase & resetted ? \"resetted|\" : \"\",\n\t\t    SCDATA(ptr) ? SCNEXT(ptr) : NULL);\n}\n\n \nstatic void show_queues(struct Scsi_Host *shpnt)\n{\n\tstruct scsi_cmnd *ptr;\n\tunsigned long flags;\n\n\tDO_LOCK(flags);\n\tprintk(KERN_DEBUG \"\\nqueue status:\\nissue_SC:\\n\");\n\tfor (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr))\n\t\tshow_command(ptr);\n\tDO_UNLOCK(flags);\n\n\tprintk(KERN_DEBUG \"current_SC:\\n\");\n\tif (CURRENT_SC)\n\t\tshow_command(CURRENT_SC);\n\telse\n\t\tprintk(KERN_DEBUG \"none\\n\");\n\n\tprintk(KERN_DEBUG \"disconnected_SC:\\n\");\n\tfor (ptr = DISCONNECTED_SC; ptr; ptr = SCDATA(ptr) ? SCNEXT(ptr) : NULL)\n\t\tshow_command(ptr);\n\n\tdisp_enintr(shpnt);\n}\n\nstatic void get_command(struct seq_file *m, struct scsi_cmnd * ptr)\n{\n\tstruct aha152x_cmd_priv *acp = aha152x_priv(ptr);\n\tconst int phase = acp->phase;\n\tint i;\n\n\tseq_printf(m, \"%p: target=%d; lun=%d; cmnd=( \",\n\t\tptr, ptr->device->id, (u8)ptr->device->lun);\n\n\tfor (i = 0; i < COMMAND_SIZE(ptr->cmnd[0]); i++)\n\t\tseq_printf(m, \"0x%02x \", ptr->cmnd[i]);\n\n\tseq_printf(m, \"); resid=%d; residual=%d; buffers=%d; phase |\",\n\t\tscsi_get_resid(ptr), acp->this_residual,\n\t\tsg_nents(acp->buffer) - 1);\n\n\tif (phase & not_issued)\n\t\tseq_puts(m, \"not issued|\");\n\tif (phase & selecting)\n\t\tseq_puts(m, \"selecting|\");\n\tif (phase & disconnected)\n\t\tseq_puts(m, \"disconnected|\");\n\tif (phase & aborted)\n\t\tseq_puts(m, \"aborted|\");\n\tif (phase & identified)\n\t\tseq_puts(m, \"identified|\");\n\tif (phase & completed)\n\t\tseq_puts(m, \"completed|\");\n\tif (phase & spiordy)\n\t\tseq_puts(m, \"spiordy|\");\n\tif (phase & syncneg)\n\t\tseq_puts(m, \"syncneg|\");\n\tseq_printf(m, \"; next=0x%p\\n\", SCNEXT(ptr));\n}\n\nstatic void get_ports(struct seq_file *m, struct Scsi_Host *shpnt)\n{\n\tint s;\n\n\tseq_printf(m, \"\\n%s: %s(%s) \", CURRENT_SC ? \"on bus\" : \"waiting\", states[STATE].name, states[PREVSTATE].name);\n\n\ts = GETPORT(SCSISEQ);\n\tseq_puts(m, \"SCSISEQ( \");\n\tif (s & TEMODEO)\n\t\tseq_puts(m, \"TARGET MODE \");\n\tif (s & ENSELO)\n\t\tseq_puts(m, \"SELO \");\n\tif (s & ENSELI)\n\t\tseq_puts(m, \"SELI \");\n\tif (s & ENRESELI)\n\t\tseq_puts(m, \"RESELI \");\n\tif (s & ENAUTOATNO)\n\t\tseq_puts(m, \"AUTOATNO \");\n\tif (s & ENAUTOATNI)\n\t\tseq_puts(m, \"AUTOATNI \");\n\tif (s & ENAUTOATNP)\n\t\tseq_puts(m, \"AUTOATNP \");\n\tif (s & SCSIRSTO)\n\t\tseq_puts(m, \"SCSIRSTO \");\n\tseq_puts(m, \");\");\n\n\tseq_puts(m, \" SCSISIG(\");\n\ts = GETPORT(SCSISIG);\n\tswitch (s & P_MASK) {\n\tcase P_DATAO:\n\t\tseq_puts(m, \"DATA OUT\");\n\t\tbreak;\n\tcase P_DATAI:\n\t\tseq_puts(m, \"DATA IN\");\n\t\tbreak;\n\tcase P_CMD:\n\t\tseq_puts(m, \"COMMAND\");\n\t\tbreak;\n\tcase P_STATUS:\n\t\tseq_puts(m, \"STATUS\");\n\t\tbreak;\n\tcase P_MSGO:\n\t\tseq_puts(m, \"MESSAGE OUT\");\n\t\tbreak;\n\tcase P_MSGI:\n\t\tseq_puts(m, \"MESSAGE IN\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(m, \"*invalid*\");\n\t\tbreak;\n\t}\n\n\tseq_puts(m, \"); \");\n\n\tseq_printf(m, \"INTSTAT (%s); \", TESTHI(DMASTAT, INTSTAT) ? \"hi\" : \"lo\");\n\n\tseq_puts(m, \"SSTAT( \");\n\ts = GETPORT(SSTAT0);\n\tif (s & TARGET)\n\t\tseq_puts(m, \"TARGET \");\n\tif (s & SELDO)\n\t\tseq_puts(m, \"SELDO \");\n\tif (s & SELDI)\n\t\tseq_puts(m, \"SELDI \");\n\tif (s & SELINGO)\n\t\tseq_puts(m, \"SELINGO \");\n\tif (s & SWRAP)\n\t\tseq_puts(m, \"SWRAP \");\n\tif (s & SDONE)\n\t\tseq_puts(m, \"SDONE \");\n\tif (s & SPIORDY)\n\t\tseq_puts(m, \"SPIORDY \");\n\tif (s & DMADONE)\n\t\tseq_puts(m, \"DMADONE \");\n\n\ts = GETPORT(SSTAT1);\n\tif (s & SELTO)\n\t\tseq_puts(m, \"SELTO \");\n\tif (s & ATNTARG)\n\t\tseq_puts(m, \"ATNTARG \");\n\tif (s & SCSIRSTI)\n\t\tseq_puts(m, \"SCSIRSTI \");\n\tif (s & PHASEMIS)\n\t\tseq_puts(m, \"PHASEMIS \");\n\tif (s & BUSFREE)\n\t\tseq_puts(m, \"BUSFREE \");\n\tif (s & SCSIPERR)\n\t\tseq_puts(m, \"SCSIPERR \");\n\tif (s & PHASECHG)\n\t\tseq_puts(m, \"PHASECHG \");\n\tif (s & REQINIT)\n\t\tseq_puts(m, \"REQINIT \");\n\tseq_puts(m, \"); \");\n\n\n\tseq_puts(m, \"SSTAT( \");\n\n\ts = GETPORT(SSTAT0) & GETPORT(SIMODE0);\n\n\tif (s & TARGET)\n\t\tseq_puts(m, \"TARGET \");\n\tif (s & SELDO)\n\t\tseq_puts(m, \"SELDO \");\n\tif (s & SELDI)\n\t\tseq_puts(m, \"SELDI \");\n\tif (s & SELINGO)\n\t\tseq_puts(m, \"SELINGO \");\n\tif (s & SWRAP)\n\t\tseq_puts(m, \"SWRAP \");\n\tif (s & SDONE)\n\t\tseq_puts(m, \"SDONE \");\n\tif (s & SPIORDY)\n\t\tseq_puts(m, \"SPIORDY \");\n\tif (s & DMADONE)\n\t\tseq_puts(m, \"DMADONE \");\n\n\ts = GETPORT(SSTAT1) & GETPORT(SIMODE1);\n\n\tif (s & SELTO)\n\t\tseq_puts(m, \"SELTO \");\n\tif (s & ATNTARG)\n\t\tseq_puts(m, \"ATNTARG \");\n\tif (s & SCSIRSTI)\n\t\tseq_puts(m, \"SCSIRSTI \");\n\tif (s & PHASEMIS)\n\t\tseq_puts(m, \"PHASEMIS \");\n\tif (s & BUSFREE)\n\t\tseq_puts(m, \"BUSFREE \");\n\tif (s & SCSIPERR)\n\t\tseq_puts(m, \"SCSIPERR \");\n\tif (s & PHASECHG)\n\t\tseq_puts(m, \"PHASECHG \");\n\tif (s & REQINIT)\n\t\tseq_puts(m, \"REQINIT \");\n\tseq_puts(m, \"); \");\n\n\tseq_puts(m, \"SXFRCTL0( \");\n\n\ts = GETPORT(SXFRCTL0);\n\tif (s & SCSIEN)\n\t\tseq_puts(m, \"SCSIEN \");\n\tif (s & DMAEN)\n\t\tseq_puts(m, \"DMAEN \");\n\tif (s & CH1)\n\t\tseq_puts(m, \"CH1 \");\n\tif (s & CLRSTCNT)\n\t\tseq_puts(m, \"CLRSTCNT \");\n\tif (s & SPIOEN)\n\t\tseq_puts(m, \"SPIOEN \");\n\tif (s & CLRCH1)\n\t\tseq_puts(m, \"CLRCH1 \");\n\tseq_puts(m, \"); \");\n\n\tseq_puts(m, \"SIGNAL( \");\n\n\ts = GETPORT(SCSISIG);\n\tif (s & SIG_ATNI)\n\t\tseq_puts(m, \"ATNI \");\n\tif (s & SIG_SELI)\n\t\tseq_puts(m, \"SELI \");\n\tif (s & SIG_BSYI)\n\t\tseq_puts(m, \"BSYI \");\n\tif (s & SIG_REQI)\n\t\tseq_puts(m, \"REQI \");\n\tif (s & SIG_ACKI)\n\t\tseq_puts(m, \"ACKI \");\n\tseq_puts(m, \"); \");\n\n\tseq_printf(m, \"SELID(%02x), \", GETPORT(SELID));\n\n\tseq_printf(m, \"STCNT(%d), \", GETSTCNT());\n\n\tseq_puts(m, \"SSTAT2( \");\n\n\ts = GETPORT(SSTAT2);\n\tif (s & SOFFSET)\n\t\tseq_puts(m, \"SOFFSET \");\n\tif (s & SEMPTY)\n\t\tseq_puts(m, \"SEMPTY \");\n\tif (s & SFULL)\n\t\tseq_puts(m, \"SFULL \");\n\tseq_printf(m, \"); SFCNT (%d); \", s & (SFULL | SFCNT));\n\n\ts = GETPORT(SSTAT3);\n\tseq_printf(m, \"SCSICNT (%d), OFFCNT(%d), \", (s & 0xf0) >> 4, s & 0x0f);\n\n\tseq_puts(m, \"SSTAT4( \");\n\ts = GETPORT(SSTAT4);\n\tif (s & SYNCERR)\n\t\tseq_puts(m, \"SYNCERR \");\n\tif (s & FWERR)\n\t\tseq_puts(m, \"FWERR \");\n\tif (s & FRERR)\n\t\tseq_puts(m, \"FRERR \");\n\tseq_puts(m, \"); \");\n\n\tseq_puts(m, \"DMACNTRL0( \");\n\ts = GETPORT(DMACNTRL0);\n\tseq_printf(m, \"%s \", s & _8BIT ? \"8BIT\" : \"16BIT\");\n\tseq_printf(m, \"%s \", s & DMA ? \"DMA\" : \"PIO\");\n\tseq_printf(m, \"%s \", s & WRITE_READ ? \"WRITE\" : \"READ\");\n\tif (s & ENDMA)\n\t\tseq_puts(m, \"ENDMA \");\n\tif (s & INTEN)\n\t\tseq_puts(m, \"INTEN \");\n\tif (s & RSTFIFO)\n\t\tseq_puts(m, \"RSTFIFO \");\n\tif (s & SWINT)\n\t\tseq_puts(m, \"SWINT \");\n\tseq_puts(m, \"); \");\n\n\tseq_puts(m, \"DMASTAT( \");\n\ts = GETPORT(DMASTAT);\n\tif (s & ATDONE)\n\t\tseq_puts(m, \"ATDONE \");\n\tif (s & WORDRDY)\n\t\tseq_puts(m, \"WORDRDY \");\n\tif (s & DFIFOFULL)\n\t\tseq_puts(m, \"DFIFOFULL \");\n\tif (s & DFIFOEMP)\n\t\tseq_puts(m, \"DFIFOEMP \");\n\tseq_puts(m, \")\\n\");\n\n\tseq_puts(m, \"enabled interrupts( \");\n\n\ts = GETPORT(SIMODE0);\n\tif (s & ENSELDO)\n\t\tseq_puts(m, \"ENSELDO \");\n\tif (s & ENSELDI)\n\t\tseq_puts(m, \"ENSELDI \");\n\tif (s & ENSELINGO)\n\t\tseq_puts(m, \"ENSELINGO \");\n\tif (s & ENSWRAP)\n\t\tseq_puts(m, \"ENSWRAP \");\n\tif (s & ENSDONE)\n\t\tseq_puts(m, \"ENSDONE \");\n\tif (s & ENSPIORDY)\n\t\tseq_puts(m, \"ENSPIORDY \");\n\tif (s & ENDMADONE)\n\t\tseq_puts(m, \"ENDMADONE \");\n\n\ts = GETPORT(SIMODE1);\n\tif (s & ENSELTIMO)\n\t\tseq_puts(m, \"ENSELTIMO \");\n\tif (s & ENATNTARG)\n\t\tseq_puts(m, \"ENATNTARG \");\n\tif (s & ENPHASEMIS)\n\t\tseq_puts(m, \"ENPHASEMIS \");\n\tif (s & ENBUSFREE)\n\t\tseq_puts(m, \"ENBUSFREE \");\n\tif (s & ENSCSIPERR)\n\t\tseq_puts(m, \"ENSCSIPERR \");\n\tif (s & ENPHASECHG)\n\t\tseq_puts(m, \"ENPHASECHG \");\n\tif (s & ENREQINIT)\n\t\tseq_puts(m, \"ENREQINIT \");\n\tseq_puts(m, \")\\n\");\n}\n\nstatic int aha152x_set_info(struct Scsi_Host *shpnt, char *buffer, int length)\n{\n\tif(!shpnt || !buffer || length<8 || strncmp(\"aha152x \", buffer, 8)!=0)\n\t\treturn -EINVAL;\n\n#if defined(AHA152X_STAT)\n\tif(length>13 && strncmp(\"reset\", buffer+8, 5)==0) {\n\t\tint i;\n\n\t\tHOSTDATA(shpnt)->total_commands=0;\n\t\tHOSTDATA(shpnt)->disconnections=0;\n\t\tHOSTDATA(shpnt)->busfree_without_any_action=0;\n\t\tHOSTDATA(shpnt)->busfree_without_old_command=0;\n\t\tHOSTDATA(shpnt)->busfree_without_new_command=0;\n\t\tHOSTDATA(shpnt)->busfree_without_done_command=0;\n\t\tHOSTDATA(shpnt)->busfree_with_check_condition=0;\n\t\tfor (i = idle; i<maxstate; i++) {\n\t\t\tHOSTDATA(shpnt)->count[i]=0;\n\t\t\tHOSTDATA(shpnt)->count_trans[i]=0;\n\t\t\tHOSTDATA(shpnt)->time[i]=0;\n\t\t}\n\n\t\tshost_printk(KERN_INFO, shpnt, \"aha152x: stats reset.\\n\");\n\n\t} else\n#endif\n\t{\n\t\treturn -EINVAL;\n\t}\n\n\n\treturn length;\n}\n\nstatic int aha152x_show_info(struct seq_file *m, struct Scsi_Host *shpnt)\n{\n\tint i;\n\tstruct scsi_cmnd *ptr;\n\tunsigned long flags;\n\n\tseq_puts(m, AHA152X_REVID \"\\n\");\n\n\tseq_printf(m, \"ioports 0x%04lx to 0x%04lx\\n\",\n\t\tshpnt->io_port, shpnt->io_port + shpnt->n_io_port - 1);\n\tseq_printf(m, \"interrupt 0x%02x\\n\", shpnt->irq);\n\tseq_printf(m, \"disconnection/reconnection %s\\n\",\n\t\tRECONNECT ? \"enabled\" : \"disabled\");\n\tseq_printf(m, \"parity checking %s\\n\",\n\t\tPARITY ? \"enabled\" : \"disabled\");\n\tseq_printf(m, \"synchronous transfers %s\\n\",\n\t\tSYNCHRONOUS ? \"enabled\" : \"disabled\");\n\tseq_printf(m, \"%d commands currently queued\\n\", HOSTDATA(shpnt)->commands);\n\n\tif(SYNCHRONOUS) {\n\t\tseq_puts(m, \"synchronously operating targets (tick=50 ns):\\n\");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (HOSTDATA(shpnt)->syncrate[i] & 0x7f)\n\t\t\t\tseq_printf(m, \"target %d: period %dT/%dns; req/ack offset %d\\n\",\n\t\t\t\t\ti,\n\t\t\t\t\t(((HOSTDATA(shpnt)->syncrate[i] & 0x70) >> 4) + 2),\n\t\t\t\t\t(((HOSTDATA(shpnt)->syncrate[i] & 0x70) >> 4) + 2) * 50,\n\t\t\t\t    HOSTDATA(shpnt)->syncrate[i] & 0x0f);\n\t}\n\tseq_puts(m, \"\\nqueue status:\\n\");\n\tDO_LOCK(flags);\n\tif (ISSUE_SC) {\n\t\tseq_puts(m, \"not yet issued commands:\\n\");\n\t\tfor (ptr = ISSUE_SC; ptr; ptr = SCNEXT(ptr))\n\t\t\tget_command(m, ptr);\n\t} else\n\t\tseq_puts(m, \"no not yet issued commands\\n\");\n\tDO_UNLOCK(flags);\n\n\tif (CURRENT_SC) {\n\t\tseq_puts(m, \"current command:\\n\");\n\t\tget_command(m, CURRENT_SC);\n\t} else\n\t\tseq_puts(m, \"no current command\\n\");\n\n\tif (DISCONNECTED_SC) {\n\t\tseq_puts(m, \"disconnected commands:\\n\");\n\t\tfor (ptr = DISCONNECTED_SC; ptr; ptr = SCNEXT(ptr))\n\t\t\tget_command(m, ptr);\n\t} else\n\t\tseq_puts(m, \"no disconnected commands\\n\");\n\n\tget_ports(m, shpnt);\n\n#if defined(AHA152X_STAT)\n\tseq_printf(m, \"statistics:\\n\"\n\t\t\"total commands:               %d\\n\"\n\t\t\"disconnections:               %d\\n\"\n\t\t\"busfree with check condition: %d\\n\"\n\t\t\"busfree without old command:  %d\\n\"\n\t\t\"busfree without new command:  %d\\n\"\n\t\t\"busfree without done command: %d\\n\"\n\t\t\"busfree without any action:   %d\\n\"\n\t\t\"state      \"\n\t\t\"transitions  \"\n\t\t\"count        \"\n\t\t\"time\\n\",\n\t\tHOSTDATA(shpnt)->total_commands,\n\t\tHOSTDATA(shpnt)->disconnections,\n\t\tHOSTDATA(shpnt)->busfree_with_check_condition,\n\t\tHOSTDATA(shpnt)->busfree_without_old_command,\n\t\tHOSTDATA(shpnt)->busfree_without_new_command,\n\t\tHOSTDATA(shpnt)->busfree_without_done_command,\n\t\tHOSTDATA(shpnt)->busfree_without_any_action);\n\tfor(i=0; i<maxstate; i++) {\n\t\tseq_printf(m, \"%-10s %-12d %-12d %-12ld\\n\",\n\t\t\tstates[i].name,\n\t\t\tHOSTDATA(shpnt)->count_trans[i],\n\t\t\tHOSTDATA(shpnt)->count[i],\n\t\t\tHOSTDATA(shpnt)->time[i]);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int aha152x_adjust_queue(struct scsi_device *device)\n{\n\tblk_queue_bounce_limit(device->request_queue, BLK_BOUNCE_HIGH);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template aha152x_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= AHA152X_REVID,\n\t.proc_name\t\t\t= \"aha152x\",\n\t.show_info\t\t\t= aha152x_show_info,\n\t.write_info\t\t\t= aha152x_set_info,\n\t.queuecommand\t\t\t= aha152x_queue,\n\t.eh_abort_handler\t\t= aha152x_abort,\n\t.eh_device_reset_handler\t= aha152x_device_reset,\n\t.eh_bus_reset_handler\t\t= aha152x_bus_reset,\n\t.bios_param\t\t\t= aha152x_biosparam,\n\t.can_queue\t\t\t= 1,\n\t.this_id\t\t\t= 7,\n\t.sg_tablesize\t\t\t= SG_ALL,\n\t.dma_boundary\t\t\t= PAGE_SIZE - 1,\n\t.slave_alloc\t\t\t= aha152x_adjust_queue,\n\t.cmd_size\t\t\t= sizeof(struct aha152x_cmd_priv),\n};\n\n#if !defined(AHA152X_PCMCIA)\nstatic int setup_count;\nstatic struct aha152x_setup setup[2];\n\n \nstatic unsigned short ports[] = { 0x340, 0x140 };\n\n#if !defined(SKIP_BIOSTEST)\n \nstatic unsigned int addresses[] =\n{\n\t0xdc000,\t\t \n\t0xc8000,\n\t0xcc000,\n\t0xd0000,\n\t0xd4000,\n\t0xd8000,\n\t0xe0000,\n\t0xeb800,\t\t \n\t0xf0000,\n};\n\n \nstatic struct signature {\n\tunsigned char *signature;\n\tint sig_offset;\n\tint sig_length;\n} signatures[] =\n{\n\t{ \"Adaptec AHA-1520 BIOS\",\t0x102e, 21 },\n\t\t \n\t{ \"Adaptec AHA-1520B\",\t\t0x000b, 17 },\n\t\t \n\t{ \"Adaptec AHA-1520B\",\t\t0x0026, 17 },\n\t\t \n\t{ \"Adaptec ASW-B626 BIOS\",\t0x1029, 21 },\n\t\t \n\t{ \"Adaptec BIOS: ASW-B626\",\t0x000f, 22 },\n\t\t \n\t{ \"Adaptec ASW-B626 S2\",\t0x2e6c, 19 },\n\t\t \n\t{ \"Adaptec BIOS:AIC-6360\",\t0x000c, 21 },\n\t\t \n\t{ \"ScsiPro SP-360 BIOS\",\t0x2873, 19 },\n\t\t \n\t{ \"GA-400 LOCAL BUS SCSI BIOS\", 0x102e, 26 },\n\t\t \n\t{ \"Adaptec BIOS:AVA-282X\",\t0x000c, 21 },\n\t\t \n\t{ \"Adaptec IBM Dock II SCSI\",   0x2edd, 24 },\n\t\t \n\t{ \"Adaptec BIOS:AHA-1532P\",     0x001c, 22 },\n\t\t \n\t{ \"DTC3520A Host Adapter BIOS\", 0x318a, 26 },\n\t\t \n};\n#endif  \n\n \nstatic int aha152x_porttest(int io_port)\n{\n\tint i;\n\n\tSETPORT(io_port + O_DMACNTRL1, 0);\t \n\tfor (i = 0; i < 16; i++)\n\t\tSETPORT(io_port + O_STACK, i);\n\n\tSETPORT(io_port + O_DMACNTRL1, 0);\t \n\tfor (i = 0; i < 16 && GETPORT(io_port + O_STACK) == i; i++)\n\t\t;\n\n\treturn (i == 16);\n}\n\nstatic int tc1550_porttest(int io_port)\n{\n\tint i;\n\n\tSETPORT(io_port + O_TC_DMACNTRL1, 0);\t \n\tfor (i = 0; i < 16; i++)\n\t\tSETPORT(io_port + O_STACK, i);\n\n\tSETPORT(io_port + O_TC_DMACNTRL1, 0);\t \n\tfor (i = 0; i < 16 && GETPORT(io_port + O_TC_STACK) == i; i++)\n\t\t;\n\n\treturn (i == 16);\n}\n\n\nstatic int checksetup(struct aha152x_setup *setup)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(ports) && (setup->io_port != ports[i]); i++)\n\t\t;\n\n\tif (i == ARRAY_SIZE(ports))\n\t\treturn 0;\n\n\tif (!request_region(setup->io_port, IO_RANGE, \"aha152x\")) {\n\t\tprintk(KERN_ERR \"aha152x: io port 0x%x busy.\\n\", setup->io_port);\n\t\treturn 0;\n\t}\n\n\tif( aha152x_porttest(setup->io_port) ) {\n\t\tsetup->tc1550=0;\n\t} else if( tc1550_porttest(setup->io_port) ) {\n\t\tsetup->tc1550=1;\n\t} else {\n\t\trelease_region(setup->io_port, IO_RANGE);\n\t\treturn 0;\n\t}\n\n\trelease_region(setup->io_port, IO_RANGE);\n\n\tif ((setup->irq < IRQ_MIN) || (setup->irq > IRQ_MAX))\n\t\treturn 0;\n\n\tif ((setup->scsiid < 0) || (setup->scsiid > 7))\n\t\treturn 0;\n\n\tif ((setup->reconnect < 0) || (setup->reconnect > 1))\n\t\treturn 0;\n\n\tif ((setup->parity < 0) || (setup->parity > 1))\n\t\treturn 0;\n\n\tif ((setup->synchronous < 0) || (setup->synchronous > 1))\n\t\treturn 0;\n\n\tif ((setup->ext_trans < 0) || (setup->ext_trans > 1))\n\t\treturn 0;\n\n\n\treturn 1;\n}\n\n\nstatic int __init aha152x_init(void)\n{\n\tint i, j, ok;\n#if defined(AUTOCONF)\n\taha152x_config conf;\n#endif\n#ifdef __ISAPNP__\n\tstruct pnp_dev *dev=NULL, *pnpdev[2] = {NULL, NULL};\n#endif\n\n\tif ( setup_count ) {\n\t\tprintk(KERN_INFO \"aha152x: processing commandline: \");\n\n\t\tfor (i = 0; i<setup_count; i++) {\n\t\t\tif (!checksetup(&setup[i])) {\n\t\t\t\tprintk(KERN_ERR \"\\naha152x: %s\\n\", setup[i].conf);\n\t\t\t\tprintk(KERN_ERR \"aha152x: invalid line\\n\");\n\t\t\t}\n\t\t}\n\t\tprintk(\"ok\\n\");\n\t}\n\n#if defined(SETUP0)\n\tif (setup_count < ARRAY_SIZE(setup)) {\n\t\tstruct aha152x_setup override = SETUP0;\n\n\t\tif (setup_count == 0 || (override.io_port != setup[0].io_port)) {\n\t\t\tif (!checksetup(&override)) {\n\t\t\t\tprintk(KERN_ERR \"\\naha152x: invalid override SETUP0={0x%x,%d,%d,%d,%d,%d,%d,%d}\\n\",\n\t\t\t\t       override.io_port,\n\t\t\t\t       override.irq,\n\t\t\t\t       override.scsiid,\n\t\t\t\t       override.reconnect,\n\t\t\t\t       override.parity,\n\t\t\t\t       override.synchronous,\n\t\t\t\t       override.delay,\n\t\t\t\t       override.ext_trans);\n\t\t\t} else\n\t\t\t\tsetup[setup_count++] = override;\n\t\t}\n\t}\n#endif\n\n#if defined(SETUP1)\n\tif (setup_count < ARRAY_SIZE(setup)) {\n\t\tstruct aha152x_setup override = SETUP1;\n\n\t\tif (setup_count == 0 || (override.io_port != setup[0].io_port)) {\n\t\t\tif (!checksetup(&override)) {\n\t\t\t\tprintk(KERN_ERR \"\\naha152x: invalid override SETUP1={0x%x,%d,%d,%d,%d,%d,%d,%d}\\n\",\n\t\t\t\t       override.io_port,\n\t\t\t\t       override.irq,\n\t\t\t\t       override.scsiid,\n\t\t\t\t       override.reconnect,\n\t\t\t\t       override.parity,\n\t\t\t\t       override.synchronous,\n\t\t\t\t       override.delay,\n\t\t\t\t       override.ext_trans);\n\t\t\t} else\n\t\t\t\tsetup[setup_count++] = override;\n\t\t}\n\t}\n#endif\n\n#if defined(MODULE)\n\tif (setup_count<ARRAY_SIZE(setup) && (aha152x[0]!=0 || io[0]!=0 || irq[0]!=0)) {\n\t\tif(aha152x[0]!=0) {\n\t\t\tsetup[setup_count].conf        = \"\";\n\t\t\tsetup[setup_count].io_port     = aha152x[0];\n\t\t\tsetup[setup_count].irq         = aha152x[1];\n\t\t\tsetup[setup_count].scsiid      = aha152x[2];\n\t\t\tsetup[setup_count].reconnect   = aha152x[3];\n\t\t\tsetup[setup_count].parity      = aha152x[4];\n\t\t\tsetup[setup_count].synchronous = aha152x[5];\n\t\t\tsetup[setup_count].delay       = aha152x[6];\n\t\t\tsetup[setup_count].ext_trans   = aha152x[7];\n\t\t} else if (io[0] != 0 || irq[0] != 0) {\n\t\t\tif(io[0]!=0)  setup[setup_count].io_port = io[0];\n\t\t\tif(irq[0]!=0) setup[setup_count].irq     = irq[0];\n\n\t\t\tsetup[setup_count].scsiid      = scsiid[0];\n\t\t\tsetup[setup_count].reconnect   = reconnect[0];\n\t\t\tsetup[setup_count].parity      = parity[0];\n\t\t\tsetup[setup_count].synchronous = sync[0];\n\t\t\tsetup[setup_count].delay       = delay[0];\n\t\t\tsetup[setup_count].ext_trans   = exttrans[0];\n\t\t}\n\n\t\tif (checksetup(&setup[setup_count]))\n\t\t\tsetup_count++;\n\t\telse\n\t\t\tprintk(KERN_ERR \"aha152x: invalid module params io=0x%x, irq=%d,scsiid=%d,reconnect=%d,parity=%d,sync=%d,delay=%d,exttrans=%d\\n\",\n\t\t\t       setup[setup_count].io_port,\n\t\t\t       setup[setup_count].irq,\n\t\t\t       setup[setup_count].scsiid,\n\t\t\t       setup[setup_count].reconnect,\n\t\t\t       setup[setup_count].parity,\n\t\t\t       setup[setup_count].synchronous,\n\t\t\t       setup[setup_count].delay,\n\t\t\t       setup[setup_count].ext_trans);\n\t}\n\n\tif (setup_count<ARRAY_SIZE(setup) && (aha152x1[0]!=0 || io[1]!=0 || irq[1]!=0)) {\n\t\tif(aha152x1[0]!=0) {\n\t\t\tsetup[setup_count].conf        = \"\";\n\t\t\tsetup[setup_count].io_port     = aha152x1[0];\n\t\t\tsetup[setup_count].irq         = aha152x1[1];\n\t\t\tsetup[setup_count].scsiid      = aha152x1[2];\n\t\t\tsetup[setup_count].reconnect   = aha152x1[3];\n\t\t\tsetup[setup_count].parity      = aha152x1[4];\n\t\t\tsetup[setup_count].synchronous = aha152x1[5];\n\t\t\tsetup[setup_count].delay       = aha152x1[6];\n\t\t\tsetup[setup_count].ext_trans   = aha152x1[7];\n\t\t} else if (io[1] != 0 || irq[1] != 0) {\n\t\t\tif(io[1]!=0)  setup[setup_count].io_port = io[1];\n\t\t\tif(irq[1]!=0) setup[setup_count].irq     = irq[1];\n\n\t\t\tsetup[setup_count].scsiid      = scsiid[1];\n\t\t\tsetup[setup_count].reconnect   = reconnect[1];\n\t\t\tsetup[setup_count].parity      = parity[1];\n\t\t\tsetup[setup_count].synchronous = sync[1];\n\t\t\tsetup[setup_count].delay       = delay[1];\n\t\t\tsetup[setup_count].ext_trans   = exttrans[1];\n\t\t}\n\t\tif (checksetup(&setup[setup_count]))\n\t\t\tsetup_count++;\n\t\telse\n\t\t\tprintk(KERN_ERR \"aha152x: invalid module params io=0x%x, irq=%d,scsiid=%d,reconnect=%d,parity=%d,sync=%d,delay=%d,exttrans=%d\\n\",\n\t\t\t       setup[setup_count].io_port,\n\t\t\t       setup[setup_count].irq,\n\t\t\t       setup[setup_count].scsiid,\n\t\t\t       setup[setup_count].reconnect,\n\t\t\t       setup[setup_count].parity,\n\t\t\t       setup[setup_count].synchronous,\n\t\t\t       setup[setup_count].delay,\n\t\t\t       setup[setup_count].ext_trans);\n\t}\n#endif\n\n#ifdef __ISAPNP__\n\tfor(i=0; setup_count<ARRAY_SIZE(setup) && id_table[i].vendor; i++) {\n\t\twhile ( setup_count<ARRAY_SIZE(setup) &&\n\t\t\t(dev=pnp_find_dev(NULL, id_table[i].vendor, id_table[i].function, dev)) ) {\n\t\t\tif (pnp_device_attach(dev) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (pnp_activate_dev(dev) < 0) {\n\t\t\t\tpnp_device_detach(dev);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!pnp_port_valid(dev, 0)) {\n\t\t\t\tpnp_device_detach(dev);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (setup_count==1 && pnp_port_start(dev, 0)==setup[0].io_port) {\n\t\t\t\tpnp_device_detach(dev);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsetup[setup_count].io_port     = pnp_port_start(dev, 0);\n\t\t\tsetup[setup_count].irq         = pnp_irq(dev, 0);\n\t\t\tsetup[setup_count].scsiid      = 7;\n\t\t\tsetup[setup_count].reconnect   = 1;\n\t\t\tsetup[setup_count].parity      = 1;\n\t\t\tsetup[setup_count].synchronous = 1;\n\t\t\tsetup[setup_count].delay       = DELAY_DEFAULT;\n\t\t\tsetup[setup_count].ext_trans   = 0;\n#if defined(__ISAPNP__)\n\t\t\tpnpdev[setup_count]            = dev;\n#endif\n\t\t\tprintk (KERN_INFO\n\t\t\t\t\"aha152x: found ISAPnP adapter at io=0x%03x, irq=%d\\n\",\n\t\t\t\tsetup[setup_count].io_port, setup[setup_count].irq);\n\t\t\tsetup_count++;\n\t\t}\n\t}\n#endif\n\n#if defined(AUTOCONF)\n\tif (setup_count<ARRAY_SIZE(setup)) {\n#if !defined(SKIP_BIOSTEST)\n\t\tok = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(addresses) && !ok; i++) {\n\t\t\tvoid __iomem *p = ioremap(addresses[i], 0x4000);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\t\t\tfor (j = 0; j<ARRAY_SIZE(signatures) && !ok; j++)\n\t\t\t\tok = check_signature(p + signatures[j].sig_offset,\n\t\t\t\t\t\t\t\tsignatures[j].signature, signatures[j].sig_length);\n\t\t\tiounmap(p);\n\t\t}\n\t\tif (!ok && setup_count == 0)\n\t\t\treturn -ENODEV;\n\n\t\tprintk(KERN_INFO \"aha152x: BIOS test: passed, \");\n#else\n\t\tprintk(KERN_INFO \"aha152x: \");\n#endif\t\t\t\t \n\n\t\tok = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(ports) && setup_count < 2; i++) {\n\t\t\tif ((setup_count == 1) && (setup[0].io_port == ports[i]))\n\t\t\t\tcontinue;\n\n\t\t\tif (!request_region(ports[i], IO_RANGE, \"aha152x\")) {\n\t\t\t\tprintk(KERN_ERR \"aha152x: io port 0x%x busy.\\n\", ports[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (aha152x_porttest(ports[i])) {\n\t\t\t\tsetup[setup_count].tc1550  = 0;\n\n\t\t\t\tconf.cf_port =\n\t\t\t\t    (GETPORT(ports[i] + O_PORTA) << 8) + GETPORT(ports[i] + O_PORTB);\n\t\t\t} else if (tc1550_porttest(ports[i])) {\n\t\t\t\tsetup[setup_count].tc1550  = 1;\n\n\t\t\t\tconf.cf_port =\n\t\t\t\t    (GETPORT(ports[i] + O_TC_PORTA) << 8) + GETPORT(ports[i] + O_TC_PORTB);\n\t\t\t} else {\n\t\t\t\trelease_region(ports[i], IO_RANGE);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trelease_region(ports[i], IO_RANGE);\n\n\t\t\tok++;\n\t\t\tsetup[setup_count].io_port = ports[i];\n\t\t\tsetup[setup_count].irq = IRQ_MIN + conf.cf_irq;\n\t\t\tsetup[setup_count].scsiid = conf.cf_id;\n\t\t\tsetup[setup_count].reconnect = conf.cf_tardisc;\n\t\t\tsetup[setup_count].parity = !conf.cf_parity;\n\t\t\tsetup[setup_count].synchronous = conf.cf_syncneg;\n\t\t\tsetup[setup_count].delay = DELAY_DEFAULT;\n\t\t\tsetup[setup_count].ext_trans = 0;\n\t\t\tsetup_count++;\n\n\t\t}\n\n\t\tif (ok)\n\t\t\tprintk(\"auto configuration: ok, \");\n\t}\n#endif\n\n\tprintk(\"%d controller(s) configured\\n\", setup_count);\n\n\tfor (i=0; i<setup_count; i++) {\n\t\tif ( request_region(setup[i].io_port, IO_RANGE, \"aha152x\") ) {\n\t\t\tstruct Scsi_Host *shpnt = aha152x_probe_one(&setup[i]);\n\n\t\t\tif( !shpnt ) {\n\t\t\t\trelease_region(setup[i].io_port, IO_RANGE);\n#if defined(__ISAPNP__)\n\t\t\t} else if( pnpdev[i] ) {\n\t\t\t\tHOSTDATA(shpnt)->pnpdev=pnpdev[i];\n\t\t\t\tpnpdev[i]=NULL;\n#endif\n\t\t\t}\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"aha152x: io port 0x%x busy.\\n\", setup[i].io_port);\n\t\t}\n\n#if defined(__ISAPNP__)\n\t\tif( pnpdev[i] )\n\t\t\tpnp_device_detach(pnpdev[i]);\n#endif\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit aha152x_exit(void)\n{\n\tstruct aha152x_hostdata *hd, *tmp;\n\n\tlist_for_each_entry_safe(hd, tmp, &aha152x_host_list, host_list) {\n\t\tstruct Scsi_Host *shost = container_of((void *)hd, struct Scsi_Host, hostdata);\n\n\t\taha152x_release(shost);\n\t}\n}\n\nmodule_init(aha152x_init);\nmodule_exit(aha152x_exit);\n\n#if !defined(MODULE)\nstatic int __init aha152x_setup(char *str)\n{\n\tint ints[10];\n\n\tget_options(str, ARRAY_SIZE(ints), ints);\n\n\tif(setup_count>=ARRAY_SIZE(setup)) {\n\t\tprintk(KERN_ERR \"aha152x: you can only configure up to two controllers\\n\");\n\t\treturn 1;\n\t}\n\n\tsetup[setup_count].conf        = str;\n\tsetup[setup_count].io_port     = ints[0] >= 1 ? ints[1] : 0x340;\n\tsetup[setup_count].irq         = ints[0] >= 2 ? ints[2] : 11;\n\tsetup[setup_count].scsiid      = ints[0] >= 3 ? ints[3] : 7;\n\tsetup[setup_count].reconnect   = ints[0] >= 4 ? ints[4] : 1;\n\tsetup[setup_count].parity      = ints[0] >= 5 ? ints[5] : 1;\n\tsetup[setup_count].synchronous = ints[0] >= 6 ? ints[6] : 1;\n\tsetup[setup_count].delay       = ints[0] >= 7 ? ints[7] : DELAY_DEFAULT;\n\tsetup[setup_count].ext_trans   = ints[0] >= 8 ? ints[8] : 0;\n\tif (ints[0] > 8)\n\t\tprintk(KERN_NOTICE \"aha152x: usage: aha152x=<IOBASE>[,<IRQ>[,<SCSI ID>\"\n\t\t       \"[,<RECONNECT>[,<PARITY>[,<SYNCHRONOUS>[,<DELAY>[,<EXT_TRANS>]]]]]]]\\n\");\n\telse\n\t\tsetup_count++;\n\n\treturn 1;\n}\n__setup(\"aha152x=\", aha152x_setup);\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}