{
  "module_name": "bfa_hw_ct.c",
  "hash_id": "8b8ead697e7ec680c8049017e6b5b6b146c7209d226710094cfc51f71eec4d2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfa_hw_ct.c",
  "human_readable_source": "\n \n\n#include \"bfad_drv.h\"\n#include \"bfa_modules.h\"\n#include \"bfi_reg.h\"\n\nBFA_TRC_FILE(HAL, IOCFC_CT);\n\n \nstatic void\nbfa_hwct_msix_dummy(struct bfa_s *bfa, int vec)\n{\n}\n\nvoid\nbfa_hwct_reginit(struct bfa_s *bfa)\n{\n\tstruct bfa_iocfc_regs_s\t*bfa_regs = &bfa->iocfc.bfa_regs;\n\tvoid __iomem *kva = bfa_ioc_bar0(&bfa->ioc);\n\tint\tfn = bfa_ioc_pcifn(&bfa->ioc);\n\n\tif (fn == 0) {\n\t\tbfa_regs->intr_status = (kva + HOSTFN0_INT_STATUS);\n\t\tbfa_regs->intr_mask   = (kva + HOSTFN0_INT_MSK);\n\t} else {\n\t\tbfa_regs->intr_status = (kva + HOSTFN1_INT_STATUS);\n\t\tbfa_regs->intr_mask   = (kva + HOSTFN1_INT_MSK);\n\t}\n}\n\nvoid\nbfa_hwct2_reginit(struct bfa_s *bfa)\n{\n\tstruct bfa_iocfc_regs_s *bfa_regs = &bfa->iocfc.bfa_regs;\n\tvoid __iomem\t*kva = bfa_ioc_bar0(&bfa->ioc);\n\n\tbfa_regs->intr_status = (kva + CT2_HOSTFN_INT_STATUS);\n\tbfa_regs->intr_mask   = (kva + CT2_HOSTFN_INTR_MASK);\n}\n\nvoid\nbfa_hwct_reqq_ack(struct bfa_s *bfa, int reqq)\n{\n\tu32\tr32;\n\n\tr32 = readl(bfa->iocfc.bfa_regs.cpe_q_ctrl[reqq]);\n\twritel(r32, bfa->iocfc.bfa_regs.cpe_q_ctrl[reqq]);\n}\n\n \nvoid\nbfa_hwct_rspq_ack(struct bfa_s *bfa, int rspq, u32 ci)\n{\n\tu32\tr32;\n\n\tr32 = readl(bfa->iocfc.bfa_regs.rme_q_ctrl[rspq]);\n\twritel(r32, bfa->iocfc.bfa_regs.rme_q_ctrl[rspq]);\n\n\tbfa_rspq_ci(bfa, rspq) = ci;\n\twritel(ci, bfa->iocfc.bfa_regs.rme_q_ci[rspq]);\n}\n\n \nvoid\nbfa_hwct2_rspq_ack(struct bfa_s *bfa, int rspq, u32 ci)\n{\n\tbfa_rspq_ci(bfa, rspq) = ci;\n\twritel(ci, bfa->iocfc.bfa_regs.rme_q_ci[rspq]);\n}\n\nvoid\nbfa_hwct_msix_getvecs(struct bfa_s *bfa, u32 *msix_vecs_bmap,\n\t\t u32 *num_vecs, u32 *max_vec_bit)\n{\n\t*msix_vecs_bmap = (1 << BFI_MSIX_CT_MAX) - 1;\n\t*max_vec_bit = (1 << (BFI_MSIX_CT_MAX - 1));\n\t*num_vecs = BFI_MSIX_CT_MAX;\n}\n\n \nvoid\nbfa_hwct_msix_init(struct bfa_s *bfa, int nvecs)\n{\n\tWARN_ON((nvecs != 1) && (nvecs != BFI_MSIX_CT_MAX));\n\tbfa_trc(bfa, nvecs);\n\n\tbfa->msix.nvecs = nvecs;\n\tbfa_hwct_msix_uninstall(bfa);\n}\n\nvoid\nbfa_hwct_msix_ctrl_install(struct bfa_s *bfa)\n{\n\tif (bfa->msix.nvecs == 0)\n\t\treturn;\n\n\tif (bfa->msix.nvecs == 1)\n\t\tbfa->msix.handler[BFI_MSIX_LPU_ERR_CT] = bfa_msix_all;\n\telse\n\t\tbfa->msix.handler[BFI_MSIX_LPU_ERR_CT] = bfa_msix_lpu_err;\n}\n\nvoid\nbfa_hwct_msix_queue_install(struct bfa_s *bfa)\n{\n\tint i;\n\n\tif (bfa->msix.nvecs == 0)\n\t\treturn;\n\n\tif (bfa->msix.nvecs == 1) {\n\t\tfor (i = BFI_MSIX_CPE_QMIN_CT; i < BFI_MSIX_CT_MAX; i++)\n\t\t\tbfa->msix.handler[i] = bfa_msix_all;\n\t\treturn;\n\t}\n\n\tfor (i = BFI_MSIX_CPE_QMIN_CT; i <= BFI_MSIX_CPE_QMAX_CT; i++)\n\t\tbfa->msix.handler[i] = bfa_msix_reqq;\n\n\tfor (i = BFI_MSIX_RME_QMIN_CT; i <= BFI_MSIX_RME_QMAX_CT; i++)\n\t\tbfa->msix.handler[i] = bfa_msix_rspq;\n}\n\nvoid\nbfa_hwct_msix_uninstall(struct bfa_s *bfa)\n{\n\tint i;\n\n\tfor (i = 0; i < BFI_MSIX_CT_MAX; i++)\n\t\tbfa->msix.handler[i] = bfa_hwct_msix_dummy;\n}\n\n \nvoid\nbfa_hwct_isr_mode_set(struct bfa_s *bfa, bfa_boolean_t msix)\n{\n\tbfa_trc(bfa, 0);\n\tbfa_ioc_isr_mode_set(&bfa->ioc, msix);\n}\n\nvoid\nbfa_hwct_msix_get_rme_range(struct bfa_s *bfa, u32 *start, u32 *end)\n{\n\t*start = BFI_MSIX_RME_QMIN_CT;\n\t*end = BFI_MSIX_RME_QMAX_CT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}