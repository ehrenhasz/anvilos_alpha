{
  "module_name": "bfad_im.h",
  "hash_id": "9f2d18a98b11f0c98f074fe77e7acc002dab62c7ae8dd104304d04d4a7032316",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfad_im.h",
  "human_readable_source": " \n \n\n#ifndef __BFAD_IM_H__\n#define __BFAD_IM_H__\n\n#include \"bfa_fcs.h\"\n\n#define FCPI_NAME \" fcpim\"\n\n#ifndef KOBJ_NAME_LEN\n#define KOBJ_NAME_LEN           20\n#endif\n\nbfa_status_t bfad_im_module_init(void);\nvoid bfad_im_module_exit(void);\nbfa_status_t bfad_im_probe(struct bfad_s *bfad);\nvoid bfad_im_probe_undo(struct bfad_s *bfad);\nbfa_status_t bfad_im_port_new(struct bfad_s *bfad, struct bfad_port_s *port);\nvoid bfad_im_port_delete(struct bfad_s *bfad, struct bfad_port_s *port);\nvoid bfad_im_port_clean(struct bfad_im_port_s *im_port);\nint  bfad_im_scsi_host_alloc(struct bfad_s *bfad,\n\t\tstruct bfad_im_port_s *im_port, struct device *dev);\nvoid bfad_im_scsi_host_free(struct bfad_s *bfad,\n\t\t\t\tstruct bfad_im_port_s *im_port);\nu32 bfad_im_supported_speeds(struct bfa_s *bfa);\n\n#define MAX_FCP_TARGET 1024\n#define MAX_FCP_LUN 16384\n#define BFAD_TARGET_RESET_TMO 60\n#define BFAD_LUN_RESET_TMO 60\n#define BFA_QUEUE_FULL_RAMP_UP_TIME 120\n\n \n#define IO_DONE_BIT\t\t\t0\n\n \nstruct bfad_cmd_priv {\n\tunsigned long status;\n\twait_queue_head_t *wq;\n};\n\nstatic inline struct bfad_cmd_priv *bfad_priv(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\nstruct bfad_itnim_data_s {\n\tstruct bfad_itnim_s *itnim;\n};\n\nstruct bfad_im_port_s {\n\tstruct bfad_s         *bfad;\n\tstruct bfad_port_s    *port;\n\tstruct work_struct port_delete_work;\n\tint             idr_id;\n\tu16        cur_scsi_id;\n\tu16\tflags;\n\tstruct list_head binding_list;\n\tstruct Scsi_Host *shost;\n\tstruct list_head itnim_mapped_list;\n\tstruct fc_vport *fc_vport;\n};\n\nstruct bfad_im_port_pointer {\n\tstruct bfad_im_port_s *p;\n};\n\nstatic inline struct bfad_im_port_s *bfad_get_im_port(struct Scsi_Host *host)\n{\n\tstruct bfad_im_port_pointer *im_portp = shost_priv(host);\n\treturn im_portp->p;\n}\n\nenum bfad_itnim_state {\n\tITNIM_STATE_NONE,\n\tITNIM_STATE_ONLINE,\n\tITNIM_STATE_OFFLINE_PENDING,\n\tITNIM_STATE_OFFLINE,\n\tITNIM_STATE_TIMEOUT,\n\tITNIM_STATE_FREE,\n};\n\n \nstruct bfad_itnim_s {\n\tstruct list_head list_entry;\n\tstruct bfa_fcs_itnim_s fcs_itnim;\n\tstruct work_struct itnim_work;\n\tu32        flags;\n\tenum bfad_itnim_state state;\n\tstruct bfad_im_s *im;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_rport_s *drv_rport;\n\tstruct fc_rport *fc_rport;\n\tstruct bfa_itnim_s *bfa_itnim;\n\tu16        scsi_tgt_id;\n\tu16\t   channel;\n\tu16        queue_work;\n\tunsigned long\tlast_ramp_up_time;\n\tunsigned long\tlast_queue_full_time;\n};\n\nenum bfad_binding_type {\n\tFCP_PWWN_BINDING = 0x1,\n\tFCP_NWWN_BINDING = 0x2,\n\tFCP_FCID_BINDING = 0x3,\n};\n\nstruct bfad_fcp_binding {\n\tstruct list_head list_entry;\n\tenum bfad_binding_type binding_type;\n\tu16        scsi_target_id;\n\tu32        fc_id;\n\twwn_t           nwwn;\n\twwn_t           pwwn;\n};\n\nstruct bfad_im_s {\n\tstruct bfad_s         *bfad;\n\tstruct workqueue_struct *drv_workq;\n\tchar            drv_workq_name[KOBJ_NAME_LEN];\n\tstruct work_struct\taen_im_notify_work;\n};\n\n#define bfad_get_aen_entry(_drv, _entry) do {\t\t\t\t\\\n\tunsigned long\t_flags;\t\t\t\t\t\t\\\n\tspin_lock_irqsave(&(_drv)->bfad_aen_spinlock, _flags);\t\t\\\n\tbfa_q_deq(&(_drv)->free_aen_q, &(_entry));\t\t\t\\\n\tif (_entry)\t\t\t\t\t\t\t\\\n\t\tlist_add_tail(&(_entry)->qe, &(_drv)->active_aen_q);\t\\\n\tspin_unlock_irqrestore(&(_drv)->bfad_aen_spinlock, _flags);\t\\\n} while (0)\n\n \nstatic inline void bfad_im_post_vendor_event(struct bfa_aen_entry_s *entry,\n\t\t\t\t\t     struct bfad_s *drv, int cnt,\n\t\t\t\t\t     enum bfa_aen_category cat,\n\t\t\t\t\t     int evt)\n{\n\tstruct timespec64 ts;\n\n\tktime_get_real_ts64(&ts);\n\t \n\tentry->aen_tv_sec = ts.tv_sec;\n\tentry->aen_tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\tentry->bfad_num = drv->inst_no;\n\tentry->seq_num = cnt;\n\tentry->aen_category = cat;\n\tentry->aen_type = evt;\n\tif (drv->bfad_flags & BFAD_FC4_PROBE_DONE)\n\t\tqueue_work(drv->im->drv_workq, &drv->im->aen_im_notify_work);\n}\n\nstruct Scsi_Host *bfad_scsi_host_alloc(struct bfad_im_port_s *im_port,\n\t\t\t\tstruct bfad_s *);\nbfa_status_t bfad_thread_workq(struct bfad_s *bfad);\nvoid bfad_destroy_workq(struct bfad_im_s *im);\nvoid bfad_fc_host_init(struct bfad_im_port_s *im_port);\nvoid bfad_scsi_host_free(struct bfad_s *bfad,\n\t\t\t\t struct bfad_im_port_s *im_port);\nvoid bfad_ramp_up_qdepth(struct bfad_itnim_s *itnim,\n\t\t\t\t struct scsi_device *sdev);\nvoid bfad_handle_qfull(struct bfad_itnim_s *itnim, struct scsi_device *sdev);\nstruct bfad_itnim_s *bfad_get_itnim(struct bfad_im_port_s *im_port, int id);\n\nextern struct scsi_host_template bfad_im_scsi_host_template;\nextern struct scsi_host_template bfad_im_vport_template;\nextern struct fc_function_template bfad_im_fc_function_template;\nextern struct fc_function_template bfad_im_vport_fc_function_template;\nextern struct scsi_transport_template *bfad_im_scsi_transport_template;\nextern struct scsi_transport_template *bfad_im_scsi_vport_transport_template;\n\nextern const struct attribute_group *bfad_im_host_groups[];\nextern const struct attribute_group *bfad_im_vport_groups[];\n\nirqreturn_t bfad_intx(int irq, void *dev_id);\n\nint bfad_im_bsg_request(struct bsg_job *job);\nint bfad_im_bsg_timeout(struct bsg_job *job);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}