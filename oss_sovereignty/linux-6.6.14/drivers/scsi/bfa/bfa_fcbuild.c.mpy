{
  "module_name": "bfa_fcbuild.c",
  "hash_id": "a9ba01e27a827bc004de53a69b8f0200fdf6d455dce1e785004fdf61eb4fd6ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfa_fcbuild.c",
  "human_readable_source": "\n \n \n\n#include \"bfad_drv.h\"\n#include \"bfa_fcbuild.h\"\n\n \nstatic void     fc_els_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id,\n\t\t\t\t __be16 ox_id);\nstatic void     fc_bls_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id,\n\t\t\t\t __be16 ox_id);\nstatic struct fchs_s fc_els_req_tmpl;\nstatic struct fchs_s fc_els_rsp_tmpl;\nstatic struct fchs_s fc_bls_req_tmpl;\nstatic struct fchs_s fc_bls_rsp_tmpl;\nstatic struct fc_ba_acc_s ba_acc_tmpl;\nstatic struct fc_logi_s plogi_tmpl;\nstatic struct fc_prli_s prli_tmpl;\nstatic struct fc_rrq_s rrq_tmpl;\nstatic struct fchs_s fcp_fchs_tmpl;\n\nvoid\nfcbuild_init(void)\n{\n\t \n\tfc_els_req_tmpl.routing = FC_RTG_EXT_LINK;\n\tfc_els_req_tmpl.cat_info = FC_CAT_LD_REQUEST;\n\tfc_els_req_tmpl.type = FC_TYPE_ELS;\n\tfc_els_req_tmpl.f_ctl =\n\t\tbfa_hton3b(FCTL_SEQ_INI | FCTL_FS_EXCH | FCTL_END_SEQ |\n\t\t\t      FCTL_SI_XFER);\n\tfc_els_req_tmpl.rx_id = FC_RXID_ANY;\n\n\t \n\tfc_els_rsp_tmpl.routing = FC_RTG_EXT_LINK;\n\tfc_els_rsp_tmpl.cat_info = FC_CAT_LD_REPLY;\n\tfc_els_rsp_tmpl.type = FC_TYPE_ELS;\n\tfc_els_rsp_tmpl.f_ctl =\n\t\tbfa_hton3b(FCTL_EC_RESP | FCTL_SEQ_INI | FCTL_LS_EXCH |\n\t\t\t      FCTL_END_SEQ | FCTL_SI_XFER);\n\tfc_els_rsp_tmpl.rx_id = FC_RXID_ANY;\n\n\t \n\tfc_bls_req_tmpl.routing = FC_RTG_BASIC_LINK;\n\tfc_bls_req_tmpl.type = FC_TYPE_BLS;\n\tfc_bls_req_tmpl.f_ctl = bfa_hton3b(FCTL_END_SEQ | FCTL_SI_XFER);\n\tfc_bls_req_tmpl.rx_id = FC_RXID_ANY;\n\n\t \n\tfc_bls_rsp_tmpl.routing = FC_RTG_BASIC_LINK;\n\tfc_bls_rsp_tmpl.cat_info = FC_CAT_BA_ACC;\n\tfc_bls_rsp_tmpl.type = FC_TYPE_BLS;\n\tfc_bls_rsp_tmpl.f_ctl =\n\t\tbfa_hton3b(FCTL_EC_RESP | FCTL_SEQ_INI | FCTL_LS_EXCH |\n\t\t\t      FCTL_END_SEQ | FCTL_SI_XFER);\n\tfc_bls_rsp_tmpl.rx_id = FC_RXID_ANY;\n\n\t \n\tba_acc_tmpl.seq_id_valid = 0;\n\tba_acc_tmpl.low_seq_cnt = 0;\n\tba_acc_tmpl.high_seq_cnt = 0xFFFF;\n\n\t \n\tplogi_tmpl.csp.verhi = FC_PH_VER_PH_3;\n\tplogi_tmpl.csp.verlo = FC_PH_VER_4_3;\n\tplogi_tmpl.csp.ciro = 0x1;\n\tplogi_tmpl.csp.cisc = 0x0;\n\tplogi_tmpl.csp.altbbcred = 0x0;\n\tplogi_tmpl.csp.conseq = cpu_to_be16(0x00FF);\n\tplogi_tmpl.csp.ro_bitmap = cpu_to_be16(0x0002);\n\tplogi_tmpl.csp.e_d_tov = cpu_to_be32(2000);\n\n\tplogi_tmpl.class3.class_valid = 1;\n\tplogi_tmpl.class3.sequential = 1;\n\tplogi_tmpl.class3.conseq = 0xFF;\n\tplogi_tmpl.class3.ospx = 1;\n\n\t \n\tprli_tmpl.command = FC_ELS_PRLI;\n\tprli_tmpl.pglen = 0x10;\n\tprli_tmpl.pagebytes = cpu_to_be16(0x0014);\n\tprli_tmpl.parampage.type = FC_TYPE_FCP;\n\tprli_tmpl.parampage.imagepair = 1;\n\tprli_tmpl.parampage.servparams.rxrdisab = 1;\n\n\t \n\trrq_tmpl.els_cmd.els_code = FC_ELS_RRQ;\n\n\t \n\tfcp_fchs_tmpl.routing = FC_RTG_FC4_DEV_DATA;\n\tfcp_fchs_tmpl.cat_info = FC_CAT_UNSOLICIT_CMD;\n\tfcp_fchs_tmpl.type = FC_TYPE_FCP;\n\tfcp_fchs_tmpl.f_ctl =\n\t\tbfa_hton3b(FCTL_FS_EXCH | FCTL_END_SEQ | FCTL_SI_XFER);\n\tfcp_fchs_tmpl.seq_id = 1;\n\tfcp_fchs_tmpl.rx_id = FC_RXID_ANY;\n}\n\nstatic void\nfc_gs_fchdr_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u32 ox_id)\n{\n\tmemset(fchs, 0, sizeof(struct fchs_s));\n\n\tfchs->routing = FC_RTG_FC4_DEV_DATA;\n\tfchs->cat_info = FC_CAT_UNSOLICIT_CTRL;\n\tfchs->type = FC_TYPE_SERVICES;\n\tfchs->f_ctl =\n\t\tbfa_hton3b(FCTL_SEQ_INI | FCTL_FS_EXCH | FCTL_END_SEQ |\n\t\t\t      FCTL_SI_XFER);\n\tfchs->rx_id = FC_RXID_ANY;\n\tfchs->d_id = (d_id);\n\tfchs->s_id = (s_id);\n\tfchs->ox_id = cpu_to_be16(ox_id);\n\n\t \n}\n\nstatic void\nfc_gsresp_fchdr_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id)\n{\n\tmemset(fchs, 0, sizeof(struct fchs_s));\n\n\tfchs->routing = FC_RTG_FC4_DEV_DATA;\n\tfchs->cat_info = FC_CAT_SOLICIT_CTRL;\n\tfchs->type = FC_TYPE_SERVICES;\n\tfchs->f_ctl =\n\t\tbfa_hton3b(FCTL_EC_RESP | FCTL_SEQ_INI | FCTL_LS_EXCH |\n\t\t\t   FCTL_END_SEQ | FCTL_SI_XFER);\n\tfchs->d_id = d_id;\n\tfchs->s_id = s_id;\n\tfchs->ox_id = ox_id;\n}\n\nvoid\nfc_els_req_build(struct fchs_s *fchs, u32 d_id, u32 s_id, __be16 ox_id)\n{\n\tmemcpy(fchs, &fc_els_req_tmpl, sizeof(struct fchs_s));\n\tfchs->d_id = (d_id);\n\tfchs->s_id = (s_id);\n\tfchs->ox_id = cpu_to_be16(ox_id);\n}\n\nstatic void\nfc_els_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id, __be16 ox_id)\n{\n\tmemcpy(fchs, &fc_els_rsp_tmpl, sizeof(struct fchs_s));\n\tfchs->d_id = d_id;\n\tfchs->s_id = s_id;\n\tfchs->ox_id = ox_id;\n}\n\nstatic void\nfc_bls_rsp_build(struct fchs_s *fchs, u32 d_id, u32 s_id, __be16 ox_id)\n{\n\tmemcpy(fchs, &fc_bls_rsp_tmpl, sizeof(struct fchs_s));\n\tfchs->d_id = d_id;\n\tfchs->s_id = s_id;\n\tfchs->ox_id = ox_id;\n}\n\nstatic          u16\nfc_plogi_x_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\n\t\t __be16 ox_id, wwn_t port_name, wwn_t node_name,\n\t\t u16 pdu_size, u16 bb_cr, u8 els_code)\n{\n\tstruct fc_logi_s *plogi = (struct fc_logi_s *) (pld);\n\n\tmemcpy(plogi, &plogi_tmpl, sizeof(struct fc_logi_s));\n\n\t \n\tif (!bb_cr)\n\t\tplogi->csp.altbbcred = 1;\n\n\tplogi->els_cmd.els_code = els_code;\n\tif (els_code == FC_ELS_PLOGI)\n\t\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\telse\n\t\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\n\tplogi->csp.rxsz = plogi->class3.rxsz = cpu_to_be16(pdu_size);\n\tplogi->csp.bbcred  = cpu_to_be16(bb_cr);\n\n\tmemcpy(&plogi->port_name, &port_name, sizeof(wwn_t));\n\tmemcpy(&plogi->node_name, &node_name, sizeof(wwn_t));\n\n\treturn sizeof(struct fc_logi_s);\n}\n\nu16\nfc_flogi_build(struct fchs_s *fchs, struct fc_logi_s *flogi, u32 s_id,\n\t\tu16 ox_id, wwn_t port_name, wwn_t node_name, u16 pdu_size,\n\t       u8 set_npiv, u8 set_auth, u16 local_bb_credits)\n{\n\tu32        d_id = bfa_hton3b(FC_FABRIC_PORT);\n\t__be32\t*vvl_info;\n\n\tmemcpy(flogi, &plogi_tmpl, sizeof(struct fc_logi_s));\n\n\tflogi->els_cmd.els_code = FC_ELS_FLOGI;\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\n\tflogi->csp.rxsz = flogi->class3.rxsz = cpu_to_be16(pdu_size);\n\tflogi->port_name = port_name;\n\tflogi->node_name = node_name;\n\n\t \n\tflogi->csp.ciro = set_npiv;\n\n\t \n\tflogi->csp.security = set_auth;\n\n\tflogi->csp.bbcred = cpu_to_be16(local_bb_credits);\n\n\t \n\tvvl_info = (u32 *)&flogi->vvl[0];\n\n\t \n\tflogi->csp.npiv_supp    = 1;  \n\tvvl_info[0]\t= cpu_to_be32(FLOGI_VVL_BRCD);\n\n\treturn sizeof(struct fc_logi_s);\n}\n\nu16\nfc_flogi_acc_build(struct fchs_s *fchs, struct fc_logi_s *flogi, u32 s_id,\n\t\t   __be16 ox_id, wwn_t port_name, wwn_t node_name,\n\t\t   u16 pdu_size, u16 local_bb_credits, u8 bb_scn)\n{\n\tu32        d_id = 0;\n\tu16\t   bbscn_rxsz = (bb_scn << 12) | pdu_size;\n\n\tmemcpy(flogi, &plogi_tmpl, sizeof(struct fc_logi_s));\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\n\tflogi->els_cmd.els_code = FC_ELS_ACC;\n\tflogi->class3.rxsz = cpu_to_be16(pdu_size);\n\tflogi->csp.rxsz  = cpu_to_be16(bbscn_rxsz);\t \n\tflogi->port_name = port_name;\n\tflogi->node_name = node_name;\n\n\tflogi->csp.bbcred = cpu_to_be16(local_bb_credits);\n\n\treturn sizeof(struct fc_logi_s);\n}\n\nu16\nfc_fdisc_build(struct fchs_s *fchs, struct fc_logi_s *flogi, u32 s_id,\n\t\tu16 ox_id, wwn_t port_name, wwn_t node_name, u16 pdu_size)\n{\n\tu32        d_id = bfa_hton3b(FC_FABRIC_PORT);\n\n\tmemcpy(flogi, &plogi_tmpl, sizeof(struct fc_logi_s));\n\n\tflogi->els_cmd.els_code = FC_ELS_FDISC;\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\n\tflogi->csp.rxsz = flogi->class3.rxsz = cpu_to_be16(pdu_size);\n\tflogi->port_name = port_name;\n\tflogi->node_name = node_name;\n\n\treturn sizeof(struct fc_logi_s);\n}\n\nu16\nfc_plogi_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\n\t       u16 ox_id, wwn_t port_name, wwn_t node_name,\n\t       u16 pdu_size, u16 bb_cr)\n{\n\treturn fc_plogi_x_build(fchs, pld, d_id, s_id, ox_id, port_name,\n\t\t\t\tnode_name, pdu_size, bb_cr, FC_ELS_PLOGI);\n}\n\nu16\nfc_plogi_acc_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\n\t\t   u16 ox_id, wwn_t port_name, wwn_t node_name,\n\t\t   u16 pdu_size, u16 bb_cr)\n{\n\treturn fc_plogi_x_build(fchs, pld, d_id, s_id, ox_id, port_name,\n\t\t\t\tnode_name, pdu_size, bb_cr, FC_ELS_ACC);\n}\n\nenum fc_parse_status\nfc_plogi_rsp_parse(struct fchs_s *fchs, int len, wwn_t port_name)\n{\n\tstruct fc_els_cmd_s *els_cmd = (struct fc_els_cmd_s *) (fchs + 1);\n\tstruct fc_logi_s *plogi;\n\tstruct fc_ls_rjt_s *ls_rjt;\n\n\tswitch (els_cmd->els_code) {\n\tcase FC_ELS_LS_RJT:\n\t\tls_rjt = (struct fc_ls_rjt_s *) (fchs + 1);\n\t\tif (ls_rjt->reason_code == FC_LS_RJT_RSN_LOGICAL_BUSY)\n\t\t\treturn FC_PARSE_BUSY;\n\t\telse\n\t\t\treturn FC_PARSE_FAILURE;\n\tcase FC_ELS_ACC:\n\t\tplogi = (struct fc_logi_s *) (fchs + 1);\n\t\tif (len < sizeof(struct fc_logi_s))\n\t\t\treturn FC_PARSE_FAILURE;\n\n\t\tif (!wwn_is_equal(plogi->port_name, port_name))\n\t\t\treturn FC_PARSE_FAILURE;\n\n\t\tif (!plogi->class3.class_valid)\n\t\t\treturn FC_PARSE_FAILURE;\n\n\t\tif (be16_to_cpu(plogi->class3.rxsz) < (FC_MIN_PDUSZ))\n\t\t\treturn FC_PARSE_FAILURE;\n\n\t\treturn FC_PARSE_OK;\n\tdefault:\n\t\treturn FC_PARSE_FAILURE;\n\t}\n}\n\nenum fc_parse_status\nfc_plogi_parse(struct fchs_s *fchs)\n{\n\tstruct fc_logi_s *plogi = (struct fc_logi_s *) (fchs + 1);\n\n\tif (plogi->class3.class_valid != 1)\n\t\treturn FC_PARSE_FAILURE;\n\n\tif ((be16_to_cpu(plogi->class3.rxsz) < FC_MIN_PDUSZ)\n\t    || (be16_to_cpu(plogi->class3.rxsz) > FC_MAX_PDUSZ)\n\t    || (plogi->class3.rxsz == 0))\n\t\treturn FC_PARSE_FAILURE;\n\n\treturn FC_PARSE_OK;\n}\n\nu16\nfc_prli_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\n\t      u16 ox_id)\n{\n\tstruct fc_prli_s *prli = (struct fc_prli_s *) (pld);\n\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\tmemcpy(prli, &prli_tmpl, sizeof(struct fc_prli_s));\n\n\tprli->command = FC_ELS_PRLI;\n\tprli->parampage.servparams.initiator     = 1;\n\tprli->parampage.servparams.retry         = 1;\n\tprli->parampage.servparams.rec_support   = 1;\n\tprli->parampage.servparams.task_retry_id = 0;\n\tprli->parampage.servparams.confirm       = 1;\n\n\treturn sizeof(struct fc_prli_s);\n}\n\nu16\nfc_prli_acc_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\n\t\t  __be16 ox_id, enum bfa_lport_role role)\n{\n\tstruct fc_prli_s *prli = (struct fc_prli_s *) (pld);\n\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\tmemcpy(prli, &prli_tmpl, sizeof(struct fc_prli_s));\n\n\tprli->command = FC_ELS_ACC;\n\n\tprli->parampage.servparams.initiator = 1;\n\n\tprli->parampage.rspcode = FC_PRLI_ACC_XQTD;\n\n\treturn sizeof(struct fc_prli_s);\n}\n\nenum fc_parse_status\nfc_prli_rsp_parse(struct fc_prli_s *prli, int len)\n{\n\tif (len < sizeof(struct fc_prli_s))\n\t\treturn FC_PARSE_FAILURE;\n\n\tif (prli->command != FC_ELS_ACC)\n\t\treturn FC_PARSE_FAILURE;\n\n\tif ((prli->parampage.rspcode != FC_PRLI_ACC_XQTD)\n\t    && (prli->parampage.rspcode != FC_PRLI_ACC_PREDEF_IMG))\n\t\treturn FC_PARSE_FAILURE;\n\n\tif (prli->parampage.servparams.target != 1)\n\t\treturn FC_PARSE_FAILURE;\n\n\treturn FC_PARSE_OK;\n}\n\nenum fc_parse_status\nfc_prli_parse(struct fc_prli_s *prli)\n{\n\tif (prli->parampage.type != FC_TYPE_FCP)\n\t\treturn FC_PARSE_FAILURE;\n\n\tif (!prli->parampage.imagepair)\n\t\treturn FC_PARSE_FAILURE;\n\n\tif (!prli->parampage.servparams.initiator)\n\t\treturn FC_PARSE_FAILURE;\n\n\treturn FC_PARSE_OK;\n}\n\nu16\nfc_logo_build(struct fchs_s *fchs, struct fc_logo_s *logo, u32 d_id, u32 s_id,\n\t      u16 ox_id, wwn_t port_name)\n{\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\n\tmemset(logo, '\\0', sizeof(struct fc_logo_s));\n\tlogo->els_cmd.els_code = FC_ELS_LOGO;\n\tlogo->nport_id = (s_id);\n\tlogo->orig_port_name = port_name;\n\n\treturn sizeof(struct fc_logo_s);\n}\n\nstatic u16\nfc_adisc_x_build(struct fchs_s *fchs, struct fc_adisc_s *adisc, u32 d_id,\n\t\t u32 s_id, __be16 ox_id, wwn_t port_name,\n\t\t wwn_t node_name, u8 els_code)\n{\n\tmemset(adisc, '\\0', sizeof(struct fc_adisc_s));\n\n\tadisc->els_cmd.els_code = els_code;\n\n\tif (els_code == FC_ELS_ADISC)\n\t\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\telse\n\t\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\n\tadisc->orig_HA = 0;\n\tadisc->orig_port_name = port_name;\n\tadisc->orig_node_name = node_name;\n\tadisc->nport_id = (s_id);\n\n\treturn sizeof(struct fc_adisc_s);\n}\n\nu16\nfc_adisc_build(struct fchs_s *fchs, struct fc_adisc_s *adisc, u32 d_id,\n\t\tu32 s_id, __be16 ox_id, wwn_t port_name, wwn_t node_name)\n{\n\treturn fc_adisc_x_build(fchs, adisc, d_id, s_id, ox_id, port_name,\n\t\t\t\tnode_name, FC_ELS_ADISC);\n}\n\nu16\nfc_adisc_acc_build(struct fchs_s *fchs, struct fc_adisc_s *adisc, u32 d_id,\n\t\t   u32 s_id, __be16 ox_id, wwn_t port_name,\n\t\t   wwn_t node_name)\n{\n\treturn fc_adisc_x_build(fchs, adisc, d_id, s_id, ox_id, port_name,\n\t\t\t\tnode_name, FC_ELS_ACC);\n}\n\nenum fc_parse_status\nfc_adisc_rsp_parse(struct fc_adisc_s *adisc, int len, wwn_t port_name,\n\t\t\t\t wwn_t node_name)\n{\n\n\tif (len < sizeof(struct fc_adisc_s))\n\t\treturn FC_PARSE_FAILURE;\n\n\tif (adisc->els_cmd.els_code != FC_ELS_ACC)\n\t\treturn FC_PARSE_FAILURE;\n\n\tif (!wwn_is_equal(adisc->orig_port_name, port_name))\n\t\treturn FC_PARSE_FAILURE;\n\n\treturn FC_PARSE_OK;\n}\n\nenum fc_parse_status\nfc_adisc_parse(struct fchs_s *fchs, void *pld, u32 host_dap, wwn_t node_name,\n\t       wwn_t port_name)\n{\n\tstruct fc_adisc_s *adisc = (struct fc_adisc_s *) pld;\n\n\tif (adisc->els_cmd.els_code != FC_ELS_ACC)\n\t\treturn FC_PARSE_FAILURE;\n\n\tif ((adisc->nport_id == (host_dap))\n\t    && wwn_is_equal(adisc->orig_port_name, port_name)\n\t    && wwn_is_equal(adisc->orig_node_name, node_name))\n\t\treturn FC_PARSE_OK;\n\n\treturn FC_PARSE_FAILURE;\n}\n\nenum fc_parse_status\nfc_pdisc_parse(struct fchs_s *fchs, wwn_t node_name, wwn_t port_name)\n{\n\tstruct fc_logi_s *pdisc = (struct fc_logi_s *) (fchs + 1);\n\n\tif (pdisc->class3.class_valid != 1)\n\t\treturn FC_PARSE_FAILURE;\n\n\tif ((be16_to_cpu(pdisc->class3.rxsz) <\n\t\t(FC_MIN_PDUSZ - sizeof(struct fchs_s)))\n\t    || (pdisc->class3.rxsz == 0))\n\t\treturn FC_PARSE_FAILURE;\n\n\tif (!wwn_is_equal(pdisc->port_name, port_name))\n\t\treturn FC_PARSE_FAILURE;\n\n\tif (!wwn_is_equal(pdisc->node_name, node_name))\n\t\treturn FC_PARSE_FAILURE;\n\n\treturn FC_PARSE_OK;\n}\n\nu16\nfc_abts_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id)\n{\n\tmemcpy(fchs, &fc_bls_req_tmpl, sizeof(struct fchs_s));\n\tfchs->cat_info = FC_CAT_ABTS;\n\tfchs->d_id = (d_id);\n\tfchs->s_id = (s_id);\n\tfchs->ox_id = cpu_to_be16(ox_id);\n\n\treturn sizeof(struct fchs_s);\n}\n\nenum fc_parse_status\nfc_abts_rsp_parse(struct fchs_s *fchs, int len)\n{\n\tif ((fchs->cat_info == FC_CAT_BA_ACC)\n\t    || (fchs->cat_info == FC_CAT_BA_RJT))\n\t\treturn FC_PARSE_OK;\n\n\treturn FC_PARSE_FAILURE;\n}\n\nu16\nfc_rrq_build(struct fchs_s *fchs, struct fc_rrq_s *rrq, u32 d_id, u32 s_id,\n\t     u16 ox_id, u16 rrq_oxid)\n{\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\n\t \n\tmemcpy(rrq, &rrq_tmpl, sizeof(struct fc_rrq_s));\n\trrq->s_id = (s_id);\n\trrq->ox_id = cpu_to_be16(rrq_oxid);\n\trrq->rx_id = FC_RXID_ANY;\n\n\treturn sizeof(struct fc_rrq_s);\n}\n\nu16\nfc_logo_acc_build(struct fchs_s *fchs, void *pld, u32 d_id, u32 s_id,\n\t\t  __be16 ox_id)\n{\n\tstruct fc_els_cmd_s *acc = pld;\n\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\n\tmemset(acc, 0, sizeof(struct fc_els_cmd_s));\n\tacc->els_code = FC_ELS_ACC;\n\n\treturn sizeof(struct fc_els_cmd_s);\n}\n\nu16\nfc_ls_rjt_build(struct fchs_s *fchs, struct fc_ls_rjt_s *ls_rjt, u32 d_id,\n\t\tu32 s_id, __be16 ox_id, u8 reason_code,\n\t\tu8 reason_code_expl)\n{\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\tmemset(ls_rjt, 0, sizeof(struct fc_ls_rjt_s));\n\n\tls_rjt->els_cmd.els_code = FC_ELS_LS_RJT;\n\tls_rjt->reason_code = reason_code;\n\tls_rjt->reason_code_expl = reason_code_expl;\n\tls_rjt->vendor_unique = 0x00;\n\n\treturn sizeof(struct fc_ls_rjt_s);\n}\n\nu16\nfc_ba_acc_build(struct fchs_s *fchs, struct fc_ba_acc_s *ba_acc, u32 d_id,\n\t\tu32 s_id, __be16 ox_id, u16 rx_id)\n{\n\tfc_bls_rsp_build(fchs, d_id, s_id, ox_id);\n\n\tmemcpy(ba_acc, &ba_acc_tmpl, sizeof(struct fc_ba_acc_s));\n\n\tfchs->rx_id = rx_id;\n\n\tba_acc->ox_id = fchs->ox_id;\n\tba_acc->rx_id = fchs->rx_id;\n\n\treturn sizeof(struct fc_ba_acc_s);\n}\n\nu16\nfc_ls_acc_build(struct fchs_s *fchs, struct fc_els_cmd_s *els_cmd, u32 d_id,\n\t\tu32 s_id, __be16 ox_id)\n{\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\tmemset(els_cmd, 0, sizeof(struct fc_els_cmd_s));\n\tels_cmd->els_code = FC_ELS_ACC;\n\n\treturn sizeof(struct fc_els_cmd_s);\n}\n\nint\nfc_logout_params_pages(struct fchs_s *fc_frame, u8 els_code)\n{\n\tint             num_pages = 0;\n\tstruct fc_prlo_s *prlo;\n\tstruct fc_tprlo_s *tprlo;\n\n\tif (els_code == FC_ELS_PRLO) {\n\t\tprlo = (struct fc_prlo_s *) (fc_frame + 1);\n\t\tnum_pages = (be16_to_cpu(prlo->payload_len) - 4) / 16;\n\t} else {\n\t\ttprlo = (struct fc_tprlo_s *) (fc_frame + 1);\n\t\tnum_pages = (be16_to_cpu(tprlo->payload_len) - 4) / 16;\n\t}\n\treturn num_pages;\n}\n\nu16\nfc_tprlo_acc_build(struct fchs_s *fchs, struct fc_tprlo_acc_s *tprlo_acc,\n\t\tu32 d_id, u32 s_id, __be16 ox_id, int num_pages)\n{\n\tint             page;\n\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\n\tmemset(tprlo_acc, 0, (num_pages * 16) + 4);\n\ttprlo_acc->command = FC_ELS_ACC;\n\n\ttprlo_acc->page_len = 0x10;\n\ttprlo_acc->payload_len = cpu_to_be16((num_pages * 16) + 4);\n\n\tfor (page = 0; page < num_pages; page++) {\n\t\ttprlo_acc->tprlo_acc_params[page].opa_valid = 0;\n\t\ttprlo_acc->tprlo_acc_params[page].rpa_valid = 0;\n\t\ttprlo_acc->tprlo_acc_params[page].fc4type_csp = FC_TYPE_FCP;\n\t\ttprlo_acc->tprlo_acc_params[page].orig_process_assc = 0;\n\t\ttprlo_acc->tprlo_acc_params[page].resp_process_assc = 0;\n\t}\n\treturn be16_to_cpu(tprlo_acc->payload_len);\n}\n\nu16\nfc_prlo_acc_build(struct fchs_s *fchs, struct fc_prlo_acc_s *prlo_acc, u32 d_id,\n\t\t  u32 s_id, __be16 ox_id, int num_pages)\n{\n\tint             page;\n\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\n\tmemset(prlo_acc, 0, (num_pages * 16) + 4);\n\tprlo_acc->command = FC_ELS_ACC;\n\tprlo_acc->page_len = 0x10;\n\tprlo_acc->payload_len = cpu_to_be16((num_pages * 16) + 4);\n\n\tfor (page = 0; page < num_pages; page++) {\n\t\tprlo_acc->prlo_acc_params[page].opa_valid = 0;\n\t\tprlo_acc->prlo_acc_params[page].rpa_valid = 0;\n\t\tprlo_acc->prlo_acc_params[page].fc4type_csp = FC_TYPE_FCP;\n\t\tprlo_acc->prlo_acc_params[page].orig_process_assc = 0;\n\t\tprlo_acc->prlo_acc_params[page].resp_process_assc = 0;\n\t}\n\n\treturn be16_to_cpu(prlo_acc->payload_len);\n}\n\nu16\nfc_rnid_build(struct fchs_s *fchs, struct fc_rnid_cmd_s *rnid, u32 d_id,\n\t\tu32 s_id, u16 ox_id, u32 data_format)\n{\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\n\tmemset(rnid, 0, sizeof(struct fc_rnid_cmd_s));\n\n\trnid->els_cmd.els_code = FC_ELS_RNID;\n\trnid->node_id_data_format = data_format;\n\n\treturn sizeof(struct fc_rnid_cmd_s);\n}\n\nu16\nfc_rnid_acc_build(struct fchs_s *fchs, struct fc_rnid_acc_s *rnid_acc, u32 d_id,\n\t\t  u32 s_id, __be16 ox_id, u32 data_format,\n\t\t  struct fc_rnid_common_id_data_s *common_id_data,\n\t\t  struct fc_rnid_general_topology_data_s *gen_topo_data)\n{\n\tmemset(rnid_acc, 0, sizeof(struct fc_rnid_acc_s));\n\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\n\trnid_acc->els_cmd.els_code = FC_ELS_ACC;\n\trnid_acc->node_id_data_format = data_format;\n\trnid_acc->common_id_data_length =\n\t\t\tsizeof(struct fc_rnid_common_id_data_s);\n\trnid_acc->common_id_data = *common_id_data;\n\n\tif (data_format == RNID_NODEID_DATA_FORMAT_DISCOVERY) {\n\t\trnid_acc->specific_id_data_length =\n\t\t\tsizeof(struct fc_rnid_general_topology_data_s);\n\t\trnid_acc->gen_topology_data = *gen_topo_data;\n\t\treturn sizeof(struct fc_rnid_acc_s);\n\t} else {\n\t\treturn sizeof(struct fc_rnid_acc_s) -\n\t\t\tsizeof(struct fc_rnid_general_topology_data_s);\n\t}\n\n}\n\nu16\nfc_rpsc_build(struct fchs_s *fchs, struct fc_rpsc_cmd_s *rpsc, u32 d_id,\n\t\tu32 s_id, u16 ox_id)\n{\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\n\tmemset(rpsc, 0, sizeof(struct fc_rpsc_cmd_s));\n\n\trpsc->els_cmd.els_code = FC_ELS_RPSC;\n\treturn sizeof(struct fc_rpsc_cmd_s);\n}\n\nu16\nfc_rpsc2_build(struct fchs_s *fchs, struct fc_rpsc2_cmd_s *rpsc2, u32 d_id,\n\t\tu32 s_id, u32 *pid_list, u16 npids)\n{\n\tu32 dctlr_id = FC_DOMAIN_CTRLR(bfa_hton3b(d_id));\n\tint i = 0;\n\n\tfc_els_req_build(fchs, bfa_hton3b(dctlr_id), s_id, 0);\n\n\tmemset(rpsc2, 0, sizeof(struct fc_rpsc2_cmd_s));\n\n\trpsc2->els_cmd.els_code = FC_ELS_RPSC;\n\trpsc2->token = cpu_to_be32(FC_BRCD_TOKEN);\n\trpsc2->num_pids  = cpu_to_be16(npids);\n\tfor (i = 0; i < npids; i++)\n\t\trpsc2->pid_list[i].pid = pid_list[i];\n\n\treturn sizeof(struct fc_rpsc2_cmd_s) + ((npids - 1) * (sizeof(u32)));\n}\n\nu16\nfc_rpsc_acc_build(struct fchs_s *fchs, struct fc_rpsc_acc_s *rpsc_acc,\n\t\tu32 d_id, u32 s_id, __be16 ox_id,\n\t\t  struct fc_rpsc_speed_info_s *oper_speed)\n{\n\tmemset(rpsc_acc, 0, sizeof(struct fc_rpsc_acc_s));\n\n\tfc_els_rsp_build(fchs, d_id, s_id, ox_id);\n\n\trpsc_acc->command = FC_ELS_ACC;\n\trpsc_acc->num_entries = cpu_to_be16(1);\n\n\trpsc_acc->speed_info[0].port_speed_cap =\n\t\tcpu_to_be16(oper_speed->port_speed_cap);\n\n\trpsc_acc->speed_info[0].port_op_speed =\n\t\tcpu_to_be16(oper_speed->port_op_speed);\n\n\treturn sizeof(struct fc_rpsc_acc_s);\n}\n\nu16\nfc_pdisc_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id,\n\t       wwn_t port_name, wwn_t node_name, u16 pdu_size)\n{\n\tstruct fc_logi_s *pdisc = (struct fc_logi_s *) (fchs + 1);\n\n\tmemcpy(pdisc, &plogi_tmpl, sizeof(struct fc_logi_s));\n\n\tpdisc->els_cmd.els_code = FC_ELS_PDISC;\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\n\tpdisc->csp.rxsz = pdisc->class3.rxsz = cpu_to_be16(pdu_size);\n\tpdisc->port_name = port_name;\n\tpdisc->node_name = node_name;\n\n\treturn sizeof(struct fc_logi_s);\n}\n\nu16\nfc_pdisc_rsp_parse(struct fchs_s *fchs, int len, wwn_t port_name)\n{\n\tstruct fc_logi_s *pdisc = (struct fc_logi_s *) (fchs + 1);\n\n\tif (len < sizeof(struct fc_logi_s))\n\t\treturn FC_PARSE_LEN_INVAL;\n\n\tif (pdisc->els_cmd.els_code != FC_ELS_ACC)\n\t\treturn FC_PARSE_ACC_INVAL;\n\n\tif (!wwn_is_equal(pdisc->port_name, port_name))\n\t\treturn FC_PARSE_PWWN_NOT_EQUAL;\n\n\tif (!pdisc->class3.class_valid)\n\t\treturn FC_PARSE_NWWN_NOT_EQUAL;\n\n\tif (be16_to_cpu(pdisc->class3.rxsz) < (FC_MIN_PDUSZ))\n\t\treturn FC_PARSE_RXSZ_INVAL;\n\n\treturn FC_PARSE_OK;\n}\n\nu16\nfc_prlo_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id,\n\t      int num_pages)\n{\n\tstruct fc_prlo_s *prlo = (struct fc_prlo_s *) (fchs + 1);\n\tint             page;\n\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\tmemset(prlo, 0, (num_pages * 16) + 4);\n\tprlo->command = FC_ELS_PRLO;\n\tprlo->page_len = 0x10;\n\tprlo->payload_len = cpu_to_be16((num_pages * 16) + 4);\n\n\tfor (page = 0; page < num_pages; page++) {\n\t\tprlo->prlo_params[page].type = FC_TYPE_FCP;\n\t\tprlo->prlo_params[page].opa_valid = 0;\n\t\tprlo->prlo_params[page].rpa_valid = 0;\n\t\tprlo->prlo_params[page].orig_process_assc = 0;\n\t\tprlo->prlo_params[page].resp_process_assc = 0;\n\t}\n\n\treturn be16_to_cpu(prlo->payload_len);\n}\n\nu16\nfc_tprlo_build(struct fchs_s *fchs, u32 d_id, u32 s_id, u16 ox_id,\n\t       int num_pages, enum fc_tprlo_type tprlo_type, u32 tpr_id)\n{\n\tstruct fc_tprlo_s *tprlo = (struct fc_tprlo_s *) (fchs + 1);\n\tint             page;\n\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\tmemset(tprlo, 0, (num_pages * 16) + 4);\n\ttprlo->command = FC_ELS_TPRLO;\n\ttprlo->page_len = 0x10;\n\ttprlo->payload_len = cpu_to_be16((num_pages * 16) + 4);\n\n\tfor (page = 0; page < num_pages; page++) {\n\t\ttprlo->tprlo_params[page].type = FC_TYPE_FCP;\n\t\ttprlo->tprlo_params[page].opa_valid = 0;\n\t\ttprlo->tprlo_params[page].rpa_valid = 0;\n\t\ttprlo->tprlo_params[page].orig_process_assc = 0;\n\t\ttprlo->tprlo_params[page].resp_process_assc = 0;\n\t\tif (tprlo_type == FC_GLOBAL_LOGO) {\n\t\t\ttprlo->tprlo_params[page].global_process_logout = 1;\n\t\t} else if (tprlo_type == FC_TPR_LOGO) {\n\t\t\ttprlo->tprlo_params[page].tpo_nport_valid = 1;\n\t\t\ttprlo->tprlo_params[page].tpo_nport_id = (tpr_id);\n\t\t}\n\t}\n\n\treturn be16_to_cpu(tprlo->payload_len);\n}\n\nu16\nfc_ba_rjt_build(struct fchs_s *fchs, u32 d_id, u32 s_id, __be16 ox_id,\n\t\tu32 reason_code, u32 reason_expl)\n{\n\tstruct fc_ba_rjt_s *ba_rjt = (struct fc_ba_rjt_s *) (fchs + 1);\n\n\tfc_bls_rsp_build(fchs, d_id, s_id, ox_id);\n\n\tfchs->cat_info = FC_CAT_BA_RJT;\n\tba_rjt->reason_code = reason_code;\n\tba_rjt->reason_expl = reason_expl;\n\treturn sizeof(struct fc_ba_rjt_s);\n}\n\nstatic void\nfc_gs_cthdr_build(struct ct_hdr_s *cthdr, u32 s_id, u16 cmd_code)\n{\n\tmemset(cthdr, 0, sizeof(struct ct_hdr_s));\n\tcthdr->rev_id = CT_GS3_REVISION;\n\tcthdr->gs_type = CT_GSTYPE_DIRSERVICE;\n\tcthdr->gs_sub_type = CT_GSSUBTYPE_NAMESERVER;\n\tcthdr->cmd_rsp_code = cpu_to_be16(cmd_code);\n}\n\nstatic void\nfc_gs_fdmi_cthdr_build(struct ct_hdr_s *cthdr, u32 s_id, u16 cmd_code)\n{\n\tmemset(cthdr, 0, sizeof(struct ct_hdr_s));\n\tcthdr->rev_id = CT_GS3_REVISION;\n\tcthdr->gs_type = CT_GSTYPE_MGMTSERVICE;\n\tcthdr->gs_sub_type = CT_GSSUBTYPE_HBA_MGMTSERVER;\n\tcthdr->cmd_rsp_code = cpu_to_be16(cmd_code);\n}\n\nstatic void\nfc_gs_ms_cthdr_build(struct ct_hdr_s *cthdr, u32 s_id, u16 cmd_code,\n\t\t\t\t\t u8 sub_type)\n{\n\tmemset(cthdr, 0, sizeof(struct ct_hdr_s));\n\tcthdr->rev_id = CT_GS3_REVISION;\n\tcthdr->gs_type = CT_GSTYPE_MGMTSERVICE;\n\tcthdr->gs_sub_type = sub_type;\n\tcthdr->cmd_rsp_code = cpu_to_be16(cmd_code);\n}\n\nu16\nfc_gidpn_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\n\t       wwn_t port_name)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_gidpn_req_s *gidpn = (struct fcgs_gidpn_req_s *)(cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_GID_PN);\n\n\tmemset(gidpn, 0, sizeof(struct fcgs_gidpn_req_s));\n\tgidpn->port_name = port_name;\n\treturn sizeof(struct fcgs_gidpn_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_gpnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\n\t       u32 port_id)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tfcgs_gpnid_req_t *gpnid = (fcgs_gpnid_req_t *) (cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_GPN_ID);\n\n\tmemset(gpnid, 0, sizeof(fcgs_gpnid_req_t));\n\tgpnid->dap = port_id;\n\treturn sizeof(fcgs_gpnid_req_t) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_gnnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\n\t       u32 port_id)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tfcgs_gnnid_req_t *gnnid = (fcgs_gnnid_req_t *) (cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_GNN_ID);\n\n\tmemset(gnnid, 0, sizeof(fcgs_gnnid_req_t));\n\tgnnid->dap = port_id;\n\treturn sizeof(fcgs_gnnid_req_t) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_ct_rsp_parse(struct ct_hdr_s *cthdr)\n{\n\tif (be16_to_cpu(cthdr->cmd_rsp_code) != CT_RSP_ACCEPT) {\n\t\tif (cthdr->reason_code == CT_RSN_LOGICAL_BUSY)\n\t\t\treturn FC_PARSE_BUSY;\n\t\telse\n\t\t\treturn FC_PARSE_FAILURE;\n\t}\n\n\treturn FC_PARSE_OK;\n}\n\nu16\nfc_gs_rjt_build(struct fchs_s *fchs,  struct ct_hdr_s *cthdr,\n\t\tu32 d_id, u32 s_id, u16 ox_id, u8 reason_code,\n\t\tu8 reason_code_expl)\n{\n\tfc_gsresp_fchdr_build(fchs, d_id, s_id, ox_id);\n\n\tcthdr->cmd_rsp_code = cpu_to_be16(CT_RSP_REJECT);\n\tcthdr->rev_id = CT_GS3_REVISION;\n\n\tcthdr->reason_code = reason_code;\n\tcthdr->exp_code    = reason_code_expl;\n\treturn sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_scr_build(struct fchs_s *fchs, struct fc_scr_s *scr,\n\t\tu8 set_br_reg, u32 s_id, u16 ox_id)\n{\n\tu32        d_id = bfa_hton3b(FC_FABRIC_CONTROLLER);\n\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\n\tmemset(scr, 0, sizeof(struct fc_scr_s));\n\tscr->command = FC_ELS_SCR;\n\tscr->reg_func = FC_SCR_REG_FUNC_FULL;\n\tif (set_br_reg)\n\t\tscr->vu_reg_func = FC_VU_SCR_REG_FUNC_FABRIC_NAME_CHANGE;\n\n\treturn sizeof(struct fc_scr_s);\n}\n\nu16\nfc_rscn_build(struct fchs_s *fchs, struct fc_rscn_pl_s *rscn,\n\t\tu32 s_id, u16 ox_id)\n{\n\tu32        d_id = bfa_hton3b(FC_FABRIC_CONTROLLER);\n\tu16        payldlen;\n\n\tfc_els_req_build(fchs, d_id, s_id, ox_id);\n\trscn->command = FC_ELS_RSCN;\n\trscn->pagelen = sizeof(rscn->event[0]);\n\n\tpayldlen = sizeof(u32) + rscn->pagelen;\n\trscn->payldlen = cpu_to_be16(payldlen);\n\n\trscn->event[0].format = FC_RSCN_FORMAT_PORTID;\n\trscn->event[0].portid = s_id;\n\n\treturn struct_size(rscn, event, 1);\n}\n\nu16\nfc_rftid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\n\t       enum bfa_lport_role roles)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rftid_req_s *rftid = (struct fcgs_rftid_req_s *)(cthdr + 1);\n\tu32        type_value, d_id = bfa_hton3b(FC_NAME_SERVER);\n\tu8         index;\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RFT_ID);\n\n\tmemset(rftid, 0, sizeof(struct fcgs_rftid_req_s));\n\n\trftid->dap = s_id;\n\n\t \n\tindex = FC_TYPE_FCP >> 5;\n\ttype_value = 1 << (FC_TYPE_FCP % 32);\n\trftid->fc4_type[index] = cpu_to_be32(type_value);\n\n\treturn sizeof(struct fcgs_rftid_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_rftid_build_sol(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\n\t\t   u8 *fc4_bitmap, u32 bitmap_size)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rftid_req_s *rftid = (struct fcgs_rftid_req_s *)(cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RFT_ID);\n\n\tmemset(rftid, 0, sizeof(struct fcgs_rftid_req_s));\n\n\trftid->dap = s_id;\n\tmemcpy((void *)rftid->fc4_type, (void *)fc4_bitmap,\n\t\t(bitmap_size < 32 ? bitmap_size : 32));\n\n\treturn sizeof(struct fcgs_rftid_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_rffid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\n\t       u8 fc4_type, u8 fc4_ftrs)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rffid_req_s *rffid = (struct fcgs_rffid_req_s *)(cthdr + 1);\n\tu32         d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RFF_ID);\n\n\tmemset(rffid, 0, sizeof(struct fcgs_rffid_req_s));\n\n\trffid->dap\t    = s_id;\n\trffid->fc4ftr_bits  = fc4_ftrs;\n\trffid->fc4_type\t    = fc4_type;\n\n\treturn sizeof(struct fcgs_rffid_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_rspnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u16 ox_id,\n\t\tu8 *name)\n{\n\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rspnid_req_s *rspnid =\n\t\t\t(struct fcgs_rspnid_req_s *)(cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, ox_id);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RSPN_ID);\n\n\tmemset(rspnid, 0, sizeof(struct fcgs_rspnid_req_s));\n\n\trspnid->dap = s_id;\n\tstrscpy(rspnid->spn, name, sizeof(rspnid->spn));\n\trspnid->spn_len = (u8) strlen(rspnid->spn);\n\n\treturn sizeof(struct fcgs_rspnid_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_rsnn_nn_build(struct fchs_s *fchs, void *pyld, u32 s_id,\n\t\t\twwn_t node_name, u8 *name)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rsnn_nn_req_s *rsnn_nn =\n\t\t(struct fcgs_rsnn_nn_req_s *) (cthdr + 1);\n\tu32\td_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RSNN_NN);\n\n\tmemset(rsnn_nn, 0, sizeof(struct fcgs_rsnn_nn_req_s));\n\n\trsnn_nn->node_name = node_name;\n\tstrscpy(rsnn_nn->snn, name, sizeof(rsnn_nn->snn));\n\trsnn_nn->snn_len = (u8) strlen(rsnn_nn->snn);\n\n\treturn sizeof(struct fcgs_rsnn_nn_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_gid_ft_build(struct fchs_s *fchs, void *pyld, u32 s_id, u8 fc4_type)\n{\n\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_gidft_req_s *gidft = (struct fcgs_gidft_req_s *)(cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\n\tfc_gs_cthdr_build(cthdr, s_id, GS_GID_FT);\n\n\tmemset(gidft, 0, sizeof(struct fcgs_gidft_req_s));\n\tgidft->fc4_type = fc4_type;\n\tgidft->domain_id = 0;\n\tgidft->area_id = 0;\n\n\treturn sizeof(struct fcgs_gidft_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_rpnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id,\n\t       wwn_t port_name)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rpnid_req_s *rpnid = (struct fcgs_rpnid_req_s *)(cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RPN_ID);\n\n\tmemset(rpnid, 0, sizeof(struct fcgs_rpnid_req_s));\n\trpnid->port_id = port_id;\n\trpnid->port_name = port_name;\n\n\treturn sizeof(struct fcgs_rpnid_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_rnnid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id,\n\t       wwn_t node_name)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rnnid_req_s *rnnid = (struct fcgs_rnnid_req_s *)(cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RNN_ID);\n\n\tmemset(rnnid, 0, sizeof(struct fcgs_rnnid_req_s));\n\trnnid->port_id = port_id;\n\trnnid->node_name = node_name;\n\n\treturn sizeof(struct fcgs_rnnid_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_rcsid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id,\n\t       u32 cos)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rcsid_req_s *rcsid =\n\t\t\t(struct fcgs_rcsid_req_s *) (cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RCS_ID);\n\n\tmemset(rcsid, 0, sizeof(struct fcgs_rcsid_req_s));\n\trcsid->port_id = port_id;\n\trcsid->cos = cos;\n\n\treturn sizeof(struct fcgs_rcsid_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_rptid_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id,\n\t       u8 port_type)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_rptid_req_s *rptid = (struct fcgs_rptid_req_s *)(cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_RPT_ID);\n\n\tmemset(rptid, 0, sizeof(struct fcgs_rptid_req_s));\n\trptid->port_id = port_id;\n\trptid->port_type = port_type;\n\n\treturn sizeof(struct fcgs_rptid_req_s) + sizeof(struct ct_hdr_s);\n}\n\nu16\nfc_ganxt_build(struct fchs_s *fchs, void *pyld, u32 s_id, u32 port_id)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tstruct fcgs_ganxt_req_s *ganxt = (struct fcgs_ganxt_req_s *)(cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_NAME_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_cthdr_build(cthdr, s_id, GS_GA_NXT);\n\n\tmemset(ganxt, 0, sizeof(struct fcgs_ganxt_req_s));\n\tganxt->port_id = port_id;\n\n\treturn sizeof(struct ct_hdr_s) + sizeof(struct fcgs_ganxt_req_s);\n}\n\n \nu16\nfc_fdmi_reqhdr_build(struct fchs_s *fchs, void *pyld, u32 s_id,\n\t\t     u16 cmd_code)\n{\n\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tu32        d_id = bfa_hton3b(FC_MGMT_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_fdmi_cthdr_build(cthdr, s_id, cmd_code);\n\n\treturn sizeof(struct ct_hdr_s);\n}\n\n \nvoid\nfc_get_fc4type_bitmask(u8 fc4_type, u8 *bit_mask)\n{\n\tu8         index;\n\t__be32       *ptr = (__be32 *) bit_mask;\n\tu32        type_value;\n\n\t \n\n\tindex = fc4_type >> 5;\n\ttype_value = 1 << (fc4_type % 32);\n\tptr[index] = cpu_to_be32(type_value);\n\n}\n\n \nu16\nfc_gmal_req_build(struct fchs_s *fchs, void *pyld, u32 s_id, wwn_t wwn)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tfcgs_gmal_req_t *gmal = (fcgs_gmal_req_t *) (cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_MGMT_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_ms_cthdr_build(cthdr, s_id, GS_FC_GMAL_CMD,\n\t\t\tCT_GSSUBTYPE_CFGSERVER);\n\n\tmemset(gmal, 0, sizeof(fcgs_gmal_req_t));\n\tgmal->wwn = wwn;\n\n\treturn sizeof(struct ct_hdr_s) + sizeof(fcgs_gmal_req_t);\n}\n\n \nu16\nfc_gfn_req_build(struct fchs_s *fchs, void *pyld, u32 s_id, wwn_t wwn)\n{\n\tstruct ct_hdr_s *cthdr = (struct ct_hdr_s *) pyld;\n\tfcgs_gfn_req_t *gfn = (fcgs_gfn_req_t *) (cthdr + 1);\n\tu32        d_id = bfa_hton3b(FC_MGMT_SERVER);\n\n\tfc_gs_fchdr_build(fchs, d_id, s_id, 0);\n\tfc_gs_ms_cthdr_build(cthdr, s_id, GS_FC_GFN_CMD,\n\t\t\tCT_GSSUBTYPE_CFGSERVER);\n\n\tmemset(gfn, 0, sizeof(fcgs_gfn_req_t));\n\tgfn->wwn = wwn;\n\n\treturn sizeof(struct ct_hdr_s) + sizeof(fcgs_gfn_req_t);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}