{
  "module_name": "bfa_fcs_lport.c",
  "hash_id": "4b32cbbeaf342201fdbe9ed019ae19cfff3aa0442471c79aa6daca17e2570e9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfa_fcs_lport.c",
  "human_readable_source": "\n \n\n#include \"bfad_drv.h\"\n#include \"bfad_im.h\"\n#include \"bfa_fcs.h\"\n#include \"bfa_fcbuild.h\"\n#include \"bfa_fc.h\"\n\nBFA_TRC_FILE(FCS, PORT);\n\n \nstatic const u8 loop_alpa_map[] = {\n\t0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x0F, 0x10,  \n\t0x17, 0x18, 0x1B, 0x1D, 0x1E, 0x1F, 0x23, 0x25,  \n\t0x26, 0x27, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E,  \n\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x39, 0x3A,  \n\n\t0x3C, 0x43, 0x45, 0x46, 0x47, 0x49, 0x4A, 0x4B,  \n\t0x4C, 0x4D, 0x4E, 0x51, 0x52, 0x53, 0x54, 0x55,  \n\t0x56, 0x59, 0x5A, 0x5C, 0x63, 0x65, 0x66, 0x67,  \n\t0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x71, 0x72,  \n\n\t0x73, 0x74, 0x75, 0x76, 0x79, 0x7A, 0x7C, 0x80,  \n\t0x81, 0x82, 0x84, 0x88, 0x8F, 0x90, 0x97, 0x98,  \n\t0x9B, 0x9D, 0x9E, 0x9F, 0xA3, 0xA5, 0xA6, 0xA7,  \n\t0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xB1, 0xB2,  \n\n\t0xB3, 0xB4, 0xB5, 0xB6, 0xB9, 0xBA, 0xBC, 0xC3,  \n\t0xC5, 0xC6, 0xC7, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD,  \n\t0xCE, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD9,  \n\t0xDA, 0xDC, 0xE0, 0xE1, 0xE2, 0xE4, 0xE8, 0xEF,  \n};\n\nstatic void     bfa_fcs_lport_send_ls_rjt(struct bfa_fcs_lport_s *port,\n\t\t\t\t\t struct fchs_s *rx_fchs, u8 reason_code,\n\t\t\t\t\t u8 reason_code_expl);\nstatic void     bfa_fcs_lport_plogi(struct bfa_fcs_lport_s *port,\n\t\t\tstruct fchs_s *rx_fchs, struct fc_logi_s *plogi);\nstatic void     bfa_fcs_lport_online_actions(struct bfa_fcs_lport_s *port);\nstatic void     bfa_fcs_lport_offline_actions(struct bfa_fcs_lport_s *port);\nstatic void     bfa_fcs_lport_unknown_init(struct bfa_fcs_lport_s *port);\nstatic void     bfa_fcs_lport_unknown_online(struct bfa_fcs_lport_s *port);\nstatic void     bfa_fcs_lport_unknown_offline(struct bfa_fcs_lport_s *port);\nstatic void     bfa_fcs_lport_deleted(struct bfa_fcs_lport_s *port);\nstatic void     bfa_fcs_lport_echo(struct bfa_fcs_lport_s *port,\n\t\t\tstruct fchs_s *rx_fchs,\n\t\t\tstruct fc_echo_s *echo, u16 len);\nstatic void     bfa_fcs_lport_rnid(struct bfa_fcs_lport_s *port,\n\t\t\tstruct fchs_s *rx_fchs,\n\t\t\tstruct fc_rnid_cmd_s *rnid, u16 len);\nstatic void     bfa_fs_port_get_gen_topo_data(struct bfa_fcs_lport_s *port,\n\t\t\tstruct fc_rnid_general_topology_data_s *gen_topo_data);\n\nstatic void\tbfa_fcs_lport_fab_init(struct bfa_fcs_lport_s *port);\nstatic void\tbfa_fcs_lport_fab_online(struct bfa_fcs_lport_s *port);\nstatic void\tbfa_fcs_lport_fab_offline(struct bfa_fcs_lport_s *port);\n\nstatic void\tbfa_fcs_lport_n2n_init(struct bfa_fcs_lport_s *port);\nstatic void\tbfa_fcs_lport_n2n_online(struct bfa_fcs_lport_s *port);\nstatic void\tbfa_fcs_lport_n2n_offline(struct bfa_fcs_lport_s *port);\n\nstatic void\tbfa_fcs_lport_loop_init(struct bfa_fcs_lport_s *port);\nstatic void\tbfa_fcs_lport_loop_online(struct bfa_fcs_lport_s *port);\nstatic void\tbfa_fcs_lport_loop_offline(struct bfa_fcs_lport_s *port);\n\nstatic struct {\n\tvoid\t\t(*init) (struct bfa_fcs_lport_s *port);\n\tvoid\t\t(*online) (struct bfa_fcs_lport_s *port);\n\tvoid\t\t(*offline) (struct bfa_fcs_lport_s *port);\n} __port_action[] = {\n\t[BFA_FCS_FABRIC_UNKNOWN] = {\n\t\t.init = bfa_fcs_lport_unknown_init,\n\t\t.online = bfa_fcs_lport_unknown_online,\n\t\t.offline = bfa_fcs_lport_unknown_offline\n\t},\n\t[BFA_FCS_FABRIC_SWITCHED] = {\n\t\t.init = bfa_fcs_lport_fab_init,\n\t\t.online = bfa_fcs_lport_fab_online,\n\t\t.offline = bfa_fcs_lport_fab_offline\n\t},\n\t[BFA_FCS_FABRIC_N2N] = {\n\t\t.init = bfa_fcs_lport_n2n_init,\n\t\t.online = bfa_fcs_lport_n2n_online,\n\t\t.offline = bfa_fcs_lport_n2n_offline\n\t},\n\t[BFA_FCS_FABRIC_LOOP] = {\n\t\t.init = bfa_fcs_lport_loop_init,\n\t\t.online = bfa_fcs_lport_loop_online,\n\t\t.offline = bfa_fcs_lport_loop_offline\n\t},\n};\n\n \n\nenum bfa_fcs_lport_event {\n\tBFA_FCS_PORT_SM_CREATE = 1,\n\tBFA_FCS_PORT_SM_ONLINE = 2,\n\tBFA_FCS_PORT_SM_OFFLINE = 3,\n\tBFA_FCS_PORT_SM_DELETE = 4,\n\tBFA_FCS_PORT_SM_DELRPORT = 5,\n\tBFA_FCS_PORT_SM_STOP = 6,\n};\n\nstatic void     bfa_fcs_lport_sm_uninit(struct bfa_fcs_lport_s *port,\n\t\t\t\t\tenum bfa_fcs_lport_event event);\nstatic void     bfa_fcs_lport_sm_init(struct bfa_fcs_lport_s *port,\n\t\t\t\t\tenum bfa_fcs_lport_event event);\nstatic void     bfa_fcs_lport_sm_online(struct bfa_fcs_lport_s *port,\n\t\t\t\t\tenum bfa_fcs_lport_event event);\nstatic void     bfa_fcs_lport_sm_offline(struct bfa_fcs_lport_s *port,\n\t\t\t\t\tenum bfa_fcs_lport_event event);\nstatic void     bfa_fcs_lport_sm_deleting(struct bfa_fcs_lport_s *port,\n\t\t\t\t\tenum bfa_fcs_lport_event event);\nstatic void\tbfa_fcs_lport_sm_stopping(struct bfa_fcs_lport_s *port,\n\t\t\t\t\tenum bfa_fcs_lport_event event);\n\nstatic void\nbfa_fcs_lport_sm_uninit(\n\tstruct bfa_fcs_lport_s *port,\n\tenum bfa_fcs_lport_event event)\n{\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase BFA_FCS_PORT_SM_CREATE:\n\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_init);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_sm_init(struct bfa_fcs_lport_s *port,\n\t\t\tenum bfa_fcs_lport_event event)\n{\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase BFA_FCS_PORT_SM_ONLINE:\n\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_online);\n\t\tbfa_fcs_lport_online_actions(port);\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_DELETE:\n\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_uninit);\n\t\tbfa_fcs_lport_deleted(port);\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_STOP:\n\t\t \n\t\tif (port->vport)\n\t\t\tbfa_fcs_vport_stop_comp(port->vport);\n\t\telse\n\t\t\tbfa_wc_down(&(port->fabric->stop_wc));\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_OFFLINE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_sm_online(\n\tstruct bfa_fcs_lport_s *port,\n\tenum bfa_fcs_lport_event event)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct list_head\t\t*qe, *qen;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase BFA_FCS_PORT_SM_OFFLINE:\n\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_offline);\n\t\tbfa_fcs_lport_offline_actions(port);\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_STOP:\n\t\t__port_action[port->fabric->fab_type].offline(port);\n\n\t\tif (port->num_rports == 0) {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_init);\n\t\t\t \n\t\t\tif (port->vport)\n\t\t\t\tbfa_fcs_vport_stop_comp(port->vport);\n\t\t\telse\n\t\t\t\tbfa_wc_down(&(port->fabric->stop_wc));\n\t\t} else {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_stopping);\n\t\t\tlist_for_each_safe(qe, qen, &port->rport_q) {\n\t\t\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\t\t\tbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_DELETE:\n\n\t\t__port_action[port->fabric->fab_type].offline(port);\n\n\t\tif (port->num_rports == 0) {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_uninit);\n\t\t\tbfa_fcs_lport_deleted(port);\n\t\t} else {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_deleting);\n\t\t\tlist_for_each_safe(qe, qen, &port->rport_q) {\n\t\t\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\t\t\tbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_DELRPORT:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_sm_offline(\n\tstruct bfa_fcs_lport_s *port,\n\tenum bfa_fcs_lport_event event)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct list_head\t\t*qe, *qen;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase BFA_FCS_PORT_SM_ONLINE:\n\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_online);\n\t\tbfa_fcs_lport_online_actions(port);\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_STOP:\n\t\tif (port->num_rports == 0) {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_init);\n\t\t\t \n\t\t\tif (port->vport)\n\t\t\t\tbfa_fcs_vport_stop_comp(port->vport);\n\t\t\telse\n\t\t\t\tbfa_wc_down(&(port->fabric->stop_wc));\n\t\t} else {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_stopping);\n\t\t\tlist_for_each_safe(qe, qen, &port->rport_q) {\n\t\t\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\t\t\tbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_DELETE:\n\t\tif (port->num_rports == 0) {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_uninit);\n\t\t\tbfa_fcs_lport_deleted(port);\n\t\t} else {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_deleting);\n\t\t\tlist_for_each_safe(qe, qen, &port->rport_q) {\n\t\t\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\t\t\tbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCS_PORT_SM_DELRPORT:\n\tcase BFA_FCS_PORT_SM_OFFLINE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_sm_stopping(struct bfa_fcs_lport_s *port,\n\t\t\t  enum bfa_fcs_lport_event event)\n{\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase BFA_FCS_PORT_SM_DELRPORT:\n\t\tif (port->num_rports == 0) {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_init);\n\t\t\t \n\t\t\tif (port->vport)\n\t\t\t\tbfa_fcs_vport_stop_comp(port->vport);\n\t\t\telse\n\t\t\t\tbfa_wc_down(&(port->fabric->stop_wc));\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_sm_deleting(\n\tstruct bfa_fcs_lport_s *port,\n\tenum bfa_fcs_lport_event event)\n{\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase BFA_FCS_PORT_SM_DELRPORT:\n\t\tif (port->num_rports == 0) {\n\t\t\tbfa_sm_set_state(port, bfa_fcs_lport_sm_uninit);\n\t\t\tbfa_fcs_lport_deleted(port);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\n \n\n \nstatic void\nbfa_fcs_lport_aen_post(struct bfa_fcs_lport_s *port,\n\t\t\tenum bfa_lport_aen_event event)\n{\n\tstruct bfad_s *bfad = (struct bfad_s *)port->fabric->fcs->bfad;\n\tstruct bfa_aen_entry_s  *aen_entry;\n\n\tbfad_get_aen_entry(bfad, aen_entry);\n\tif (!aen_entry)\n\t\treturn;\n\n\taen_entry->aen_data.lport.vf_id = port->fabric->vf_id;\n\taen_entry->aen_data.lport.roles = port->port_cfg.roles;\n\taen_entry->aen_data.lport.ppwwn = bfa_fcs_lport_get_pwwn(\n\t\t\t\t\tbfa_fcs_get_base_port(port->fcs));\n\taen_entry->aen_data.lport.lpwwn = bfa_fcs_lport_get_pwwn(port);\n\n\t \n\tbfad_im_post_vendor_event(aen_entry, bfad, ++port->fcs->fcs_aen_seq,\n\t\t\t\t  BFA_AEN_CAT_LPORT, event);\n}\n\n \nstatic void\nbfa_fcs_lport_send_ls_rjt(struct bfa_fcs_lport_s *port, struct fchs_s *rx_fchs,\n\t\t\t u8 reason_code, u8 reason_code_expl)\n{\n\tstruct fchs_s\tfchs;\n\tstruct bfa_fcxp_s *fcxp;\n\tstruct bfa_rport_s *bfa_rport = NULL;\n\tint\t\tlen;\n\n\tbfa_trc(port->fcs, rx_fchs->d_id);\n\tbfa_trc(port->fcs, rx_fchs->s_id);\n\n\tfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\n\tif (!fcxp)\n\t\treturn;\n\n\tlen = fc_ls_rjt_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t      rx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\n\t\t\t      rx_fchs->ox_id, reason_code, reason_code_expl);\n\n\tbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\n\t\t\t  BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\n\t\t\t  FC_MAX_PDUSZ, 0);\n}\n\n \nstatic void\nbfa_fcs_lport_send_fcgs_rjt(struct bfa_fcs_lport_s *port,\n\tstruct fchs_s *rx_fchs, u8 reason_code, u8 reason_code_expl)\n{\n\tstruct fchs_s   fchs;\n\tstruct bfa_fcxp_s *fcxp;\n\tstruct bfa_rport_s *bfa_rport = NULL;\n\tint             len;\n\tstruct ct_hdr_s *rx_cthdr = (struct ct_hdr_s *)(rx_fchs + 1);\n\tstruct ct_hdr_s *ct_hdr;\n\n\tbfa_trc(port->fcs, rx_fchs->d_id);\n\tbfa_trc(port->fcs, rx_fchs->s_id);\n\n\tfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\n\tif (!fcxp)\n\t\treturn;\n\n\tct_hdr = bfa_fcxp_get_reqbuf(fcxp);\n\tct_hdr->gs_type = rx_cthdr->gs_type;\n\tct_hdr->gs_sub_type = rx_cthdr->gs_sub_type;\n\n\tlen = fc_gs_rjt_build(&fchs, ct_hdr, rx_fchs->s_id,\n\t\t\tbfa_fcs_lport_get_fcid(port),\n\t\t\trx_fchs->ox_id, reason_code, reason_code_expl);\n\n\tbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\n\t\t\tBFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\n\t\t\tFC_MAX_PDUSZ, 0);\n}\n\n \nstatic void\nbfa_fcs_lport_plogi(struct bfa_fcs_lport_s *port,\n\t\tstruct fchs_s *rx_fchs, struct fc_logi_s *plogi)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\n\tbfa_trc(port->fcs, rx_fchs->d_id);\n\tbfa_trc(port->fcs, rx_fchs->s_id);\n\n\t \n\tif (__fcs_min_cfg(port->fcs)) {\n\t\tbfa_trc(port->fcs, rx_fchs->s_id);\n\t\treturn;\n\t}\n\n\tif (fc_plogi_parse(rx_fchs) != FC_PARSE_OK) {\n\t\tbfa_trc(port->fcs, rx_fchs->s_id);\n\t\t \n\t\tbfa_fcs_lport_send_ls_rjt(port, rx_fchs,\n\t\t\t\t\tFC_LS_RJT_RSN_PROTOCOL_ERROR,\n\t\t\t\t\tFC_LS_RJT_EXP_SPARMS_ERR_OPTIONS);\n\t\treturn;\n\t}\n\n\t \n\tif ((!bfa_fcs_fabric_is_switched(port->fabric)) &&\n\t\t(memcmp((void *)&bfa_fcs_lport_get_pwwn(port),\n\t\t\t   (void *)&plogi->port_name, sizeof(wwn_t)) < 0)) {\n\t\tif (BFA_FCS_PID_IS_WKA(rx_fchs->d_id)) {\n\t\t\t \n\t\t\tbfa_fcs_lport_send_ls_rjt(port, rx_fchs,\n\t\t\t\t\tFC_LS_RJT_RSN_PROTOCOL_ERROR,\n\t\t\t\t\tFC_LS_RJT_EXP_INVALID_NPORT_ID);\n\t\t\treturn;\n\t\t}\n\t\tport->pid  = rx_fchs->d_id;\n\t\tbfa_lps_set_n2n_pid(port->fabric->lps, rx_fchs->d_id);\n\t}\n\n\t \n\trport = bfa_fcs_lport_get_rport_by_pwwn(port, plogi->port_name);\n\tif (rport) {\n\t\t \n\t\tif ((!bfa_fcs_fabric_is_switched(port->fabric)) &&\n\t\t\t(memcmp((void *)&bfa_fcs_lport_get_pwwn(port),\n\t\t\t(void *)&plogi->port_name, sizeof(wwn_t)) < 0)) {\n\t\t\tport->pid  = rx_fchs->d_id;\n\t\t\tbfa_lps_set_n2n_pid(port->fabric->lps, rx_fchs->d_id);\n\t\t\trport->pid = rx_fchs->s_id;\n\t\t}\n\t\tbfa_fcs_rport_plogi(rport, rx_fchs, plogi);\n\t\treturn;\n\t}\n\n\t \n\trport = bfa_fcs_lport_get_rport_by_pid(port, rx_fchs->s_id);\n\tif (!rport) {\n\t\t \n\t\tbfa_fcs_rport_plogi_create(port, rx_fchs, plogi);\n\t\treturn;\n\t}\n\n\t \n\tif (rport->pwwn) {\n\t\t \n\t\tWARN_ON(rport->pwwn == plogi->port_name);\n\t\tbfa_sm_send_event(rport, RPSM_EVENT_LOGO_IMP);\n\n\t\t \n\t\tbfa_fcs_rport_plogi_create(port, rx_fchs, plogi);\n\t\treturn;\n\t}\n\n\t \n\tWARN_ON(rport->pwwn != WWN_NULL);\n\tbfa_fcs_rport_plogi(rport, rx_fchs, plogi);\n}\n\n \nstatic void\nbfa_fcs_lport_echo(struct bfa_fcs_lport_s *port, struct fchs_s *rx_fchs,\n\t\tstruct fc_echo_s *echo, u16 rx_len)\n{\n\tstruct fchs_s\t\tfchs;\n\tstruct bfa_fcxp_s\t*fcxp;\n\tstruct bfa_rport_s\t*bfa_rport = NULL;\n\tint\t\t\tlen, pyld_len;\n\n\tbfa_trc(port->fcs, rx_fchs->s_id);\n\tbfa_trc(port->fcs, rx_fchs->d_id);\n\n\tfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\n\tif (!fcxp)\n\t\treturn;\n\n\tlen = fc_ls_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t\trx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\n\t\t\t\trx_fchs->ox_id);\n\n\t \n\tpyld_len = rx_len - sizeof(struct fchs_s);\n\tbfa_trc(port->fcs, rx_len);\n\tbfa_trc(port->fcs, pyld_len);\n\n\tif (pyld_len > len)\n\t\tmemcpy(((u8 *) bfa_fcxp_get_reqbuf(fcxp)) +\n\t\t\tsizeof(struct fc_echo_s), (echo + 1),\n\t\t\t(pyld_len - sizeof(struct fc_echo_s)));\n\n\tbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\n\t\t\tBFA_FALSE, FC_CLASS_3, pyld_len, &fchs, NULL, NULL,\n\t\t\tFC_MAX_PDUSZ, 0);\n}\n\n \nstatic void\nbfa_fcs_lport_rnid(struct bfa_fcs_lport_s *port, struct fchs_s *rx_fchs,\n\t\tstruct fc_rnid_cmd_s *rnid, u16 rx_len)\n{\n\tstruct fc_rnid_common_id_data_s common_id_data;\n\tstruct fc_rnid_general_topology_data_s gen_topo_data;\n\tstruct fchs_s\tfchs;\n\tstruct bfa_fcxp_s *fcxp;\n\tstruct bfa_rport_s *bfa_rport = NULL;\n\tu16\tlen;\n\tu32\tdata_format;\n\n\tbfa_trc(port->fcs, rx_fchs->s_id);\n\tbfa_trc(port->fcs, rx_fchs->d_id);\n\tbfa_trc(port->fcs, rx_len);\n\n\tfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\n\tif (!fcxp)\n\t\treturn;\n\n\t \n\tbfa_trc(port->fcs, rnid->node_id_data_format);\n\tif (rnid->node_id_data_format == RNID_NODEID_DATA_FORMAT_DISCOVERY) {\n\t\tdata_format = RNID_NODEID_DATA_FORMAT_DISCOVERY;\n\t\t \n\t\tbfa_fs_port_get_gen_topo_data(port, &gen_topo_data);\n\t} else {\n\t\tdata_format = RNID_NODEID_DATA_FORMAT_COMMON;\n\t}\n\n\t \n\tcommon_id_data.port_name = bfa_fcs_lport_get_pwwn(port);\n\tcommon_id_data.node_name = bfa_fcs_lport_get_nwwn(port);\n\n\tlen = fc_rnid_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t\trx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\n\t\t\t\trx_fchs->ox_id, data_format, &common_id_data,\n\t\t\t\t&gen_topo_data);\n\n\tbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\n\t\t\tBFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\n\t\t\tFC_MAX_PDUSZ, 0);\n}\n\n \nstatic void\nbfa_fs_port_get_gen_topo_data(struct bfa_fcs_lport_s *port,\n\t\t\tstruct fc_rnid_general_topology_data_s *gen_topo_data)\n{\n\tmemset(gen_topo_data, 0,\n\t\t      sizeof(struct fc_rnid_general_topology_data_s));\n\n\tgen_topo_data->asso_type = cpu_to_be32(RNID_ASSOCIATED_TYPE_HOST);\n\tgen_topo_data->phy_port_num = 0;\t \n\tgen_topo_data->num_attached_nodes = cpu_to_be32(1);\n}\n\nstatic void\nbfa_fcs_lport_online_actions(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfad_s *bfad = (struct bfad_s *)port->fcs->bfad;\n\tchar\tlpwwn_buf[BFA_STRING_32];\n\n\tbfa_trc(port->fcs, port->fabric->oper_type);\n\n\t__port_action[port->fabric->fab_type].init(port);\n\t__port_action[port->fabric->fab_type].online(port);\n\n\twwn2str(lpwwn_buf, bfa_fcs_lport_get_pwwn(port));\n\tBFA_LOG(KERN_WARNING, bfad, bfa_log_level,\n\t\t\"Logical port online: WWN = %s Role = %s\\n\",\n\t\tlpwwn_buf, \"Initiator\");\n\tbfa_fcs_lport_aen_post(port, BFA_LPORT_AEN_ONLINE);\n\n\tbfad->bfad_flags |= BFAD_PORT_ONLINE;\n}\n\nstatic void\nbfa_fcs_lport_offline_actions(struct bfa_fcs_lport_s *port)\n{\n\tstruct list_head\t*qe, *qen;\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct bfad_s *bfad = (struct bfad_s *)port->fcs->bfad;\n\tchar    lpwwn_buf[BFA_STRING_32];\n\n\tbfa_trc(port->fcs, port->fabric->oper_type);\n\n\t__port_action[port->fabric->fab_type].offline(port);\n\n\twwn2str(lpwwn_buf, bfa_fcs_lport_get_pwwn(port));\n\tif (bfa_sm_cmp_state(port->fabric,\n\t\t\tbfa_fcs_fabric_sm_online) == BFA_TRUE) {\n\t\tBFA_LOG(KERN_WARNING, bfad, bfa_log_level,\n\t\t\"Logical port lost fabric connectivity: WWN = %s Role = %s\\n\",\n\t\tlpwwn_buf, \"Initiator\");\n\t\tbfa_fcs_lport_aen_post(port, BFA_LPORT_AEN_DISCONNECT);\n\t} else {\n\t\tBFA_LOG(KERN_WARNING, bfad, bfa_log_level,\n\t\t\"Logical port taken offline: WWN = %s Role = %s\\n\",\n\t\tlpwwn_buf, \"Initiator\");\n\t\tbfa_fcs_lport_aen_post(port, BFA_LPORT_AEN_OFFLINE);\n\t}\n\n\tlist_for_each_safe(qe, qen, &port->rport_q) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tbfa_sm_send_event(rport, RPSM_EVENT_LOGO_IMP);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_unknown_init(struct bfa_fcs_lport_s *port)\n{\n\tWARN_ON(1);\n}\n\nstatic void\nbfa_fcs_lport_unknown_online(struct bfa_fcs_lport_s *port)\n{\n\tWARN_ON(1);\n}\n\nstatic void\nbfa_fcs_lport_unknown_offline(struct bfa_fcs_lport_s *port)\n{\n\tWARN_ON(1);\n}\n\nstatic void\nbfa_fcs_lport_abts_acc(struct bfa_fcs_lport_s *port, struct fchs_s *rx_fchs)\n{\n\tstruct fchs_s fchs;\n\tstruct bfa_fcxp_s *fcxp;\n\tint\t\tlen;\n\n\tbfa_trc(port->fcs, rx_fchs->d_id);\n\tbfa_trc(port->fcs, rx_fchs->s_id);\n\n\tfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\n\tif (!fcxp)\n\t\treturn;\n\n\tlen = fc_ba_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\trx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\n\t\t\trx_fchs->ox_id, 0);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag,\n\t\t\t  BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\n\t\t\t  FC_MAX_PDUSZ, 0);\n}\nstatic void\nbfa_fcs_lport_deleted(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfad_s *bfad = (struct bfad_s *)port->fcs->bfad;\n\tchar    lpwwn_buf[BFA_STRING_32];\n\n\twwn2str(lpwwn_buf, bfa_fcs_lport_get_pwwn(port));\n\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\"Logical port deleted: WWN = %s Role = %s\\n\",\n\t\tlpwwn_buf, \"Initiator\");\n\tbfa_fcs_lport_aen_post(port, BFA_LPORT_AEN_DELETE);\n\n\t \n\tif (port->vport)\n\t\tbfa_fcs_vport_delete_comp(port->vport);\n\telse\n\t\tbfa_wc_down(&port->fabric->wc);\n}\n\n\n \nvoid\nbfa_fcs_lport_uf_recv(struct bfa_fcs_lport_s *lport,\n\t\t\tstruct fchs_s *fchs, u16 len)\n{\n\tu32\tpid = fchs->s_id;\n\tstruct bfa_fcs_rport_s *rport = NULL;\n\tstruct fc_els_cmd_s *els_cmd = (struct fc_els_cmd_s *) (fchs + 1);\n\n\tbfa_stats(lport, uf_recvs);\n\tbfa_trc(lport->fcs, fchs->type);\n\n\tif (!bfa_fcs_lport_is_online(lport)) {\n\t\t \n\t\tif ((fchs->type == FC_TYPE_ELS) &&\n\t\t\t(els_cmd->els_code == FC_ELS_PLOGI)) {\n\t\t\tbfa_fcs_lport_send_ls_rjt(lport, fchs,\n\t\t\t\tFC_LS_RJT_RSN_UNABLE_TO_PERF_CMD,\n\t\t\t\tFC_LS_RJT_EXP_NO_ADDL_INFO);\n\t\t\tbfa_stats(lport, plogi_rcvd);\n\t\t} else\n\t\t\tbfa_stats(lport, uf_recv_drops);\n\n\t\treturn;\n\t}\n\n\t \n\t \n\tif ((fchs->type == FC_TYPE_ELS) &&\n\t\t(els_cmd->els_code == FC_ELS_PLOGI)) {\n\t\tbfa_fcs_lport_plogi(lport, fchs, (struct fc_logi_s *) els_cmd);\n\t\treturn;\n\t}\n\n\t \n\tif ((fchs->type == FC_TYPE_ELS) && (els_cmd->els_code == FC_ELS_ECHO)) {\n\t\tbfa_fcs_lport_echo(lport, fchs,\n\t\t\t\t(struct fc_echo_s *)els_cmd, len);\n\t\treturn;\n\t}\n\n\t \n\tif ((fchs->type == FC_TYPE_ELS) && (els_cmd->els_code == FC_ELS_RNID)) {\n\t\tbfa_fcs_lport_rnid(lport, fchs,\n\t\t\t(struct fc_rnid_cmd_s *) els_cmd, len);\n\t\treturn;\n\t}\n\n\tif (fchs->type == FC_TYPE_BLS) {\n\t\tif ((fchs->routing == FC_RTG_BASIC_LINK) &&\n\t\t\t\t(fchs->cat_info == FC_CAT_ABTS))\n\t\t\tbfa_fcs_lport_abts_acc(lport, fchs);\n\t\treturn;\n\t}\n\n\tif (fchs->type == FC_TYPE_SERVICES) {\n\t\t \n\t\tbfa_fcs_lport_send_fcgs_rjt(lport, fchs, CT_RSN_NOT_SUPP,\n\t\t\t\tCT_NS_EXP_NOADDITIONAL);\n\t\treturn;\n\t}\n\n\t \n\trport = bfa_fcs_lport_get_rport_by_pid(lport, pid);\n\tif (rport) {\n\t\tbfa_trc(rport->fcs, fchs->s_id);\n\t\tbfa_trc(rport->fcs, fchs->d_id);\n\t\tbfa_trc(rport->fcs, fchs->type);\n\n\t\tbfa_fcs_rport_uf_recv(rport, fchs, len);\n\t\treturn;\n\t}\n\n\t \n\tif (fchs->type != FC_TYPE_ELS) {\n\t\tbfa_trc(lport->fcs, fchs->s_id);\n\t\tbfa_trc(lport->fcs, fchs->d_id);\n\t\t \n\t\tif (fchs->type != FC_TYPE_FC_FSS)\n\t\t\tbfa_sm_fault(lport->fcs, fchs->type);\n\t\treturn;\n\t}\n\n\tbfa_trc(lport->fcs, els_cmd->els_code);\n\tif (els_cmd->els_code == FC_ELS_RSCN) {\n\t\tbfa_fcs_lport_scn_process_rscn(lport, fchs, len);\n\t\treturn;\n\t}\n\n\tif (els_cmd->els_code == FC_ELS_LOGO) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (els_cmd->els_code == FC_ELS_PRLI) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tbfa_fcs_lport_send_ls_rjt(lport, fchs, FC_LS_RJT_RSN_CMD_NOT_SUPP,\n\t\t\t\t FC_LS_RJT_EXP_NO_ADDL_INFO);\n\n}\n\n \nstruct bfa_fcs_rport_s *\nbfa_fcs_lport_get_rport_by_pid(struct bfa_fcs_lport_s *port, u32 pid)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct list_head\t*qe;\n\n\tlist_for_each(qe, &port->rport_q) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tif (rport->pid == pid)\n\t\t\treturn rport;\n\t}\n\n\tbfa_trc(port->fcs, pid);\n\treturn NULL;\n}\n\n \nstruct bfa_fcs_rport_s *\nbfa_fcs_lport_get_rport_by_old_pid(struct bfa_fcs_lport_s *port, u32 pid)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct list_head\t*qe;\n\n\tlist_for_each(qe, &port->rport_q) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tif (rport->old_pid == pid)\n\t\t\treturn rport;\n\t}\n\n\tbfa_trc(port->fcs, pid);\n\treturn NULL;\n}\n\n \nstruct bfa_fcs_rport_s *\nbfa_fcs_lport_get_rport_by_pwwn(struct bfa_fcs_lport_s *port, wwn_t pwwn)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct list_head\t*qe;\n\n\tlist_for_each(qe, &port->rport_q) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tif (wwn_is_equal(rport->pwwn, pwwn))\n\t\t\treturn rport;\n\t}\n\n\tbfa_trc(port->fcs, pwwn);\n\treturn NULL;\n}\n\n \nstruct bfa_fcs_rport_s *\nbfa_fcs_lport_get_rport_by_nwwn(struct bfa_fcs_lport_s *port, wwn_t nwwn)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct list_head\t*qe;\n\n\tlist_for_each(qe, &port->rport_q) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tif (wwn_is_equal(rport->nwwn, nwwn))\n\t\t\treturn rport;\n\t}\n\n\tbfa_trc(port->fcs, nwwn);\n\treturn NULL;\n}\n\n \nstruct bfa_fcs_rport_s *\nbfa_fcs_lport_get_rport_by_qualifier(struct bfa_fcs_lport_s *port,\n\t\t\t\t     wwn_t pwwn, u32 pid)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct list_head\t*qe;\n\n\tlist_for_each(qe, &port->rport_q) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tif (wwn_is_equal(rport->pwwn, pwwn) && rport->pid == pid)\n\t\t\treturn rport;\n\t}\n\n\tbfa_trc(port->fcs, pwwn);\n\treturn NULL;\n}\n\n \nvoid\nbfa_fcs_lport_add_rport(\n\tstruct bfa_fcs_lport_s *port,\n\tstruct bfa_fcs_rport_s *rport)\n{\n\tlist_add_tail(&rport->qe, &port->rport_q);\n\tport->num_rports++;\n}\n\n \nvoid\nbfa_fcs_lport_del_rport(\n\tstruct bfa_fcs_lport_s *port,\n\tstruct bfa_fcs_rport_s *rport)\n{\n\tWARN_ON(!bfa_q_is_on_q(&port->rport_q, rport));\n\tlist_del(&rport->qe);\n\tport->num_rports--;\n\n\tbfa_sm_send_event(port, BFA_FCS_PORT_SM_DELRPORT);\n}\n\n \nvoid\nbfa_fcs_lport_online(struct bfa_fcs_lport_s *port)\n{\n\tbfa_sm_send_event(port, BFA_FCS_PORT_SM_ONLINE);\n}\n\n \nvoid\nbfa_fcs_lport_offline(struct bfa_fcs_lport_s *port)\n{\n\tbfa_sm_send_event(port, BFA_FCS_PORT_SM_OFFLINE);\n}\n\n \nvoid\nbfa_fcs_lport_stop(struct bfa_fcs_lport_s *port)\n{\n\tbfa_sm_send_event(port, BFA_FCS_PORT_SM_STOP);\n}\n\n \nvoid\nbfa_fcs_lport_delete(struct bfa_fcs_lport_s *port)\n{\n\tbfa_sm_send_event(port, BFA_FCS_PORT_SM_DELETE);\n}\n\n \nbfa_boolean_t\nbfa_fcs_lport_is_online(struct bfa_fcs_lport_s *port)\n{\n\treturn bfa_sm_cmp_state(port, bfa_fcs_lport_sm_online);\n}\n\n \nvoid\nbfa_fcs_lport_attach(struct bfa_fcs_lport_s *lport, struct bfa_fcs_s *fcs,\n\t\t   u16 vf_id, struct bfa_fcs_vport_s *vport)\n{\n\tlport->fcs = fcs;\n\tlport->fabric = bfa_fcs_vf_lookup(fcs, vf_id);\n\tlport->vport = vport;\n\tlport->lp_tag = (vport) ? vport->lps->bfa_tag :\n\t\t\t\t  lport->fabric->lps->bfa_tag;\n\n\tINIT_LIST_HEAD(&lport->rport_q);\n\tlport->num_rports = 0;\n}\n\n \n\nvoid\nbfa_fcs_lport_init(struct bfa_fcs_lport_s *lport,\n\tstruct bfa_lport_cfg_s *port_cfg)\n{\n\tstruct bfa_fcs_vport_s *vport = lport->vport;\n\tstruct bfad_s *bfad = (struct bfad_s *)lport->fcs->bfad;\n\tchar    lpwwn_buf[BFA_STRING_32];\n\n\tlport->port_cfg = *port_cfg;\n\n\tlport->bfad_port = bfa_fcb_lport_new(lport->fcs->bfad, lport,\n\t\t\t\t\tlport->port_cfg.roles,\n\t\t\t\t\tlport->fabric->vf_drv,\n\t\t\t\t\tvport ? vport->vport_drv : NULL);\n\n\twwn2str(lpwwn_buf, bfa_fcs_lport_get_pwwn(lport));\n\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\"New logical port created: WWN = %s Role = %s\\n\",\n\t\tlpwwn_buf, \"Initiator\");\n\tbfa_fcs_lport_aen_post(lport, BFA_LPORT_AEN_NEW);\n\n\tbfa_sm_set_state(lport, bfa_fcs_lport_sm_uninit);\n\tbfa_sm_send_event(lport, BFA_FCS_PORT_SM_CREATE);\n}\n\nvoid\nbfa_fcs_lport_set_symname(struct bfa_fcs_lport_s *port,\n\t\t\t\tchar *symname)\n{\n\tstrcpy(port->port_cfg.sym_name.symname, symname);\n\n\tif (bfa_sm_cmp_state(port, bfa_fcs_lport_sm_online))\n\t\tbfa_fcs_lport_ns_util_send_rspn_id(\n\t\t\tBFA_FCS_GET_NS_FROM_PORT(port), NULL);\n}\n\n \n\nvoid\nbfa_fcs_lport_get_attr(\n\tstruct bfa_fcs_lport_s *port,\n\tstruct bfa_lport_attr_s *port_attr)\n{\n\tif (bfa_sm_cmp_state(port, bfa_fcs_lport_sm_online))\n\t\tport_attr->pid = port->pid;\n\telse\n\t\tport_attr->pid = 0;\n\n\tport_attr->port_cfg = port->port_cfg;\n\n\tif (port->fabric) {\n\t\tport_attr->port_type = port->fabric->oper_type;\n\t\tport_attr->loopback = bfa_sm_cmp_state(port->fabric,\n\t\t\t\tbfa_fcs_fabric_sm_loopback);\n\t\tport_attr->authfail =\n\t\t\tbfa_sm_cmp_state(port->fabric,\n\t\t\t\tbfa_fcs_fabric_sm_auth_failed);\n\t\tport_attr->fabric_name  = bfa_fcs_lport_get_fabric_name(port);\n\t\tmemcpy(port_attr->fabric_ip_addr,\n\t\t\tbfa_fcs_lport_get_fabric_ipaddr(port),\n\t\t\tBFA_FCS_FABRIC_IPADDR_SZ);\n\n\t\tif (port->vport != NULL) {\n\t\t\tport_attr->port_type = BFA_PORT_TYPE_VPORT;\n\t\t\tport_attr->fpma_mac =\n\t\t\t\tport->vport->lps->lp_mac;\n\t\t} else {\n\t\t\tport_attr->fpma_mac =\n\t\t\t\tport->fabric->lps->lp_mac;\n\t\t}\n\t} else {\n\t\tport_attr->port_type = BFA_PORT_TYPE_UNKNOWN;\n\t\tport_attr->state = BFA_LPORT_UNINIT;\n\t}\n}\n\n \n\n \nstatic void\nbfa_fcs_lport_fab_init(struct bfa_fcs_lport_s *port)\n{\n\tbfa_fcs_lport_ns_init(port);\n\tbfa_fcs_lport_scn_init(port);\n\tbfa_fcs_lport_ms_init(port);\n}\n\n \nstatic void\nbfa_fcs_lport_fab_online(struct bfa_fcs_lport_s *port)\n{\n\tbfa_fcs_lport_ns_online(port);\n\tbfa_fcs_lport_fab_scn_online(port);\n}\n\n \nstatic void\nbfa_fcs_lport_fab_offline(struct bfa_fcs_lport_s *port)\n{\n\tbfa_fcs_lport_ns_offline(port);\n\tbfa_fcs_lport_scn_offline(port);\n\tbfa_fcs_lport_ms_offline(port);\n}\n\n \n\n \nstatic void\nbfa_fcs_lport_n2n_init(struct bfa_fcs_lport_s *port)\n{\n}\n\n \nstatic void\nbfa_fcs_lport_n2n_online(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_n2n_s *n2n_port = &port->port_topo.pn2n;\n\tstruct bfa_lport_cfg_s *pcfg = &port->port_cfg;\n\tstruct bfa_fcs_rport_s *rport;\n\n\tbfa_trc(port->fcs, pcfg->pwwn);\n\n\t \n\tif (memcmp\n\t    ((void *)&pcfg->pwwn, (void *)&n2n_port->rem_port_wwn,\n\t     sizeof(wwn_t)) > 0) {\n\t\tport->pid = N2N_LOCAL_PID;\n\t\tbfa_lps_set_n2n_pid(port->fabric->lps, N2N_LOCAL_PID);\n\t\t \n\t\trport = bfa_fcs_lport_get_rport_by_pwwn(port,\n\t\t\t\t\t\t\tn2n_port->rem_port_wwn);\n\t\tif (rport) {\n\t\t\tbfa_trc(port->fcs, rport->pid);\n\t\t\tbfa_trc(port->fcs, rport->pwwn);\n\t\t\trport->pid = N2N_REMOTE_PID;\n\t\t\tbfa_sm_send_event(rport, RPSM_EVENT_PLOGI_SEND);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (port->num_rports > 0) {\n\t\t\trport = bfa_fcs_lport_get_rport_by_pid(port, 0);\n\t\t\tWARN_ON(rport == NULL);\n\t\t\tif (rport) {\n\t\t\t\tbfa_trc(port->fcs, rport->pwwn);\n\t\t\t\tbfa_sm_send_event(rport, RPSM_EVENT_DELETE);\n\t\t\t}\n\t\t}\n\t\tbfa_fcs_rport_create(port, N2N_REMOTE_PID);\n\t}\n}\n\n \nstatic void\nbfa_fcs_lport_n2n_offline(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_n2n_s *n2n_port = &port->port_topo.pn2n;\n\n\tbfa_trc(port->fcs, port->pid);\n\tport->pid = 0;\n\tn2n_port->rem_port_wwn = 0;\n\tn2n_port->reply_oxid = 0;\n}\n\nstatic void\nbfa_fcport_get_loop_attr(struct bfa_fcs_lport_s *port)\n{\n\tint i = 0, j = 0, bit = 0, alpa_bit = 0;\n\tu8 k = 0;\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(port->fcs->bfa);\n\n\tport->port_topo.ploop.alpabm_valid = fcport->alpabm_valid;\n\tport->pid = fcport->myalpa;\n\tport->pid = bfa_hton3b(port->pid);\n\n\tfor (i = 0; i < (FC_ALPA_MAX / 8); i++) {\n\t\tfor (j = 0, alpa_bit = 0; j < 8; j++, alpa_bit++) {\n\t\t\tbfa_trc(port->fcs->bfa, fcport->alpabm.alpa_bm[i]);\n\t\t\tbit = (fcport->alpabm.alpa_bm[i] & (1 << (7 - j)));\n\t\t\tif (bit) {\n\t\t\t\tport->port_topo.ploop.alpa_pos_map[k] =\n\t\t\t\t\tloop_alpa_map[(i * 8) + alpa_bit];\n\t\t\t\tk++;\n\t\t\t\tbfa_trc(port->fcs->bfa, k);\n\t\t\t\tbfa_trc(port->fcs->bfa,\n\t\t\t\t\t port->port_topo.ploop.alpa_pos_map[k]);\n\t\t\t}\n\t\t}\n\t}\n\tport->port_topo.ploop.num_alpa = k;\n}\n\n \nstatic void\nbfa_fcs_lport_loop_init(struct bfa_fcs_lport_s *port)\n{\n}\n\n \nstatic void\nbfa_fcs_lport_loop_online(struct bfa_fcs_lport_s *port)\n{\n\tu8 num_alpa = 0, alpabm_valid = 0;\n\tstruct bfa_fcs_rport_s *rport;\n\tu8 *alpa_map = NULL;\n\tint i = 0;\n\tu32 pid;\n\n\tbfa_fcport_get_loop_attr(port);\n\n\tnum_alpa = port->port_topo.ploop.num_alpa;\n\talpabm_valid = port->port_topo.ploop.alpabm_valid;\n\talpa_map = port->port_topo.ploop.alpa_pos_map;\n\n\tbfa_trc(port->fcs->bfa, port->pid);\n\tbfa_trc(port->fcs->bfa, num_alpa);\n\tif (alpabm_valid == 1) {\n\t\tfor (i = 0; i < num_alpa; i++) {\n\t\t\tbfa_trc(port->fcs->bfa, alpa_map[i]);\n\t\t\tif (alpa_map[i] != bfa_hton3b(port->pid)) {\n\t\t\t\tpid = alpa_map[i];\n\t\t\t\tbfa_trc(port->fcs->bfa, pid);\n\t\t\t\trport = bfa_fcs_lport_get_rport_by_pid(port,\n\t\t\t\t\t\tbfa_hton3b(pid));\n\t\t\t\tif (!rport)\n\t\t\t\t\trport = bfa_fcs_rport_create(port,\n\t\t\t\t\t\tbfa_hton3b(pid));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < MAX_ALPA_COUNT; i++) {\n\t\t\tif (alpa_map[i] != port->pid) {\n\t\t\t\tpid = loop_alpa_map[i];\n\t\t\t\tbfa_trc(port->fcs->bfa, pid);\n\t\t\t\trport = bfa_fcs_lport_get_rport_by_pid(port,\n\t\t\t\t\t\tbfa_hton3b(pid));\n\t\t\t\tif (!rport)\n\t\t\t\t\trport = bfa_fcs_rport_create(port,\n\t\t\t\t\t\tbfa_hton3b(pid));\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\nbfa_fcs_lport_loop_offline(struct bfa_fcs_lport_s *port)\n{\n}\n\n#define BFA_FCS_FDMI_CMD_MAX_RETRIES 2\n\n \nstatic void     bfa_fcs_lport_fdmi_send_rhba(void *fdmi_cbarg,\n\t\t\t\t\t    struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_fdmi_send_rprt(void *fdmi_cbarg,\n\t\t\t\t\t    struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_fdmi_send_rpa(void *fdmi_cbarg,\n\t\t\t\t\t   struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_fdmi_rhba_response(void *fcsarg,\n\t\t\t\t\t\tstruct bfa_fcxp_s *fcxp,\n\t\t\t\t\t\tvoid *cbarg,\n\t\t\t\t\t\tbfa_status_t req_status,\n\t\t\t\t\t\tu32 rsp_len,\n\t\t\t\t\t\tu32 resid_len,\n\t\t\t\t\t\tstruct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_fdmi_rprt_response(void *fcsarg,\n\t\t\t\t\t\tstruct bfa_fcxp_s *fcxp,\n\t\t\t\t\t\tvoid *cbarg,\n\t\t\t\t\t\tbfa_status_t req_status,\n\t\t\t\t\t\tu32 rsp_len,\n\t\t\t\t\t\tu32 resid_len,\n\t\t\t\t\t\tstruct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_fdmi_rpa_response(void *fcsarg,\n\t\t\t\t\t       struct bfa_fcxp_s *fcxp,\n\t\t\t\t\t       void *cbarg,\n\t\t\t\t\t       bfa_status_t req_status,\n\t\t\t\t\t       u32 rsp_len,\n\t\t\t\t\t       u32 resid_len,\n\t\t\t\t\t       struct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_fdmi_timeout(void *arg);\nstatic int bfa_fcs_lport_fdmi_build_rhba_pyld(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t\t\t  u8 *pyld);\nstatic u16 bfa_fcs_lport_fdmi_build_rprt_pyld(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t\t\t  u8 *pyld);\nstatic u16 bfa_fcs_lport_fdmi_build_rpa_pyld(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t\t\t u8 *pyld);\nstatic u16 bfa_fcs_lport_fdmi_build_portattr_block(struct bfa_fcs_lport_fdmi_s *\n\t\t\t\t\t\t       fdmi, u8 *pyld);\nstatic void\tbfa_fcs_fdmi_get_hbaattr(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t struct bfa_fcs_fdmi_hba_attr_s *hba_attr);\nstatic void\tbfa_fcs_fdmi_get_portattr(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t  struct bfa_fcs_fdmi_port_attr_s *port_attr);\nu32\tbfa_fcs_fdmi_convert_speed(enum bfa_port_speed pport_speed);\n\n \n\n \nenum port_fdmi_event {\n\tFDMISM_EVENT_PORT_ONLINE = 1,\n\tFDMISM_EVENT_PORT_OFFLINE = 2,\n\tFDMISM_EVENT_RSP_OK = 4,\n\tFDMISM_EVENT_RSP_ERROR = 5,\n\tFDMISM_EVENT_TIMEOUT = 6,\n\tFDMISM_EVENT_RHBA_SENT = 7,\n\tFDMISM_EVENT_RPRT_SENT = 8,\n\tFDMISM_EVENT_RPA_SENT = 9,\n};\n\nstatic void     bfa_fcs_lport_fdmi_sm_offline(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t\t     enum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_sending_rhba(\n\t\t\t\tstruct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_rhba(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t\t  enum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_rhba_retry(\n\t\t\t\tstruct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_sending_rprt(\n\t\t\t\tstruct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_rprt(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t\t  enum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_rprt_retry(\n\t\t\t\tstruct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_sending_rpa(\n\t\t\t\tstruct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_rpa(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t\t enum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_rpa_retry(\n\t\t\t\tstruct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_online(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t\t    enum port_fdmi_event event);\nstatic void     bfa_fcs_lport_fdmi_sm_disabled(\n\t\t\t\tstruct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event);\n \nstatic void\nbfa_fcs_lport_fdmi_sm_offline(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t     enum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tfdmi->retry_cnt = 0;\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_PORT_ONLINE:\n\t\tif (port->vport) {\n\t\t\t \n\t\t\tbfa_sm_set_state(fdmi,\n\t\t\t\t\t bfa_fcs_lport_fdmi_sm_sending_rprt);\n\t\t\tbfa_fcs_lport_fdmi_send_rprt(fdmi, NULL);\n\t\t} else {\n\t\t\t \n\t\t\tbfa_sm_set_state(fdmi,\n\t\t\t\t\t bfa_fcs_lport_fdmi_sm_sending_rhba);\n\t\t\tbfa_fcs_lport_fdmi_send_rhba(fdmi, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_fdmi_sm_sending_rhba(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t  enum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_RHBA_SENT:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_rhba);\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),\n\t\t\t\t\t   &fdmi->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_fdmi_sm_rhba(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\tenum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_RSP_ERROR:\n\t\t \n\t\tif (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {\n\t\t\tbfa_sm_set_state(fdmi,\n\t\t\t\t\tbfa_fcs_lport_fdmi_sm_rhba_retry);\n\t\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),\n\t\t\t\t\t    &fdmi->timer,\n\t\t\t\t\t    bfa_fcs_lport_fdmi_timeout, fdmi,\n\t\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\t} else {\n\t\t\t \n\t\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\t}\n\t\tbreak;\n\n\tcase FDMISM_EVENT_RSP_OK:\n\t\t \n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_sending_rpa);\n\t\tfdmi->retry_cnt = 0;\n\t\tbfa_fcs_lport_fdmi_send_rpa(fdmi, NULL);\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_fcxp_discard(fdmi->fcxp);\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_fdmi_sm_rhba_retry(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_TIMEOUT:\n\t\t \n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_sending_rhba);\n\t\tbfa_fcs_lport_fdmi_send_rhba(fdmi, NULL);\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbfa_timer_stop(&fdmi->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_lport_fdmi_sm_sending_rprt(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t  enum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_RPRT_SENT:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_rprt);\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),\n\t\t\t\t\t   &fdmi->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_fdmi_sm_rprt(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\tenum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_RSP_ERROR:\n\t\t \n\t\tif (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {\n\t\t\tbfa_sm_set_state(fdmi,\n\t\t\t\t\tbfa_fcs_lport_fdmi_sm_rprt_retry);\n\t\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),\n\t\t\t\t\t    &fdmi->timer,\n\t\t\t\t\t    bfa_fcs_lport_fdmi_timeout, fdmi,\n\t\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\n\t\t} else {\n\t\t\t \n\t\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\t\tfdmi->retry_cnt = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FDMISM_EVENT_RSP_OK:\n\t\tfdmi->retry_cnt = 0;\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_online);\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_fcxp_discard(fdmi->fcxp);\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_fdmi_sm_rprt_retry(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_TIMEOUT:\n\t\t \n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_sending_rprt);\n\t\tbfa_fcs_lport_fdmi_send_rprt(fdmi, NULL);\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbfa_timer_stop(&fdmi->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_lport_fdmi_sm_sending_rpa(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t enum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_RPA_SENT:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_rpa);\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(port),\n\t\t\t\t\t   &fdmi->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_fdmi_sm_rpa(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\tenum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_RSP_ERROR:\n\t\t \n\t\tif (fdmi->retry_cnt++ < BFA_FCS_FDMI_CMD_MAX_RETRIES) {\n\t\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_rpa_retry);\n\t\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(port),\n\t\t\t\t\t    &fdmi->timer,\n\t\t\t\t\t    bfa_fcs_lport_fdmi_timeout, fdmi,\n\t\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\t} else {\n\t\t\t \n\t\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\t\tfdmi->retry_cnt = 0;\n\t\t}\n\t\tbreak;\n\n\tcase FDMISM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_online);\n\t\tfdmi->retry_cnt = 0;\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_fcxp_discard(fdmi->fcxp);\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_fdmi_sm_rpa_retry(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t       enum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_TIMEOUT:\n\t\t \n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_sending_rpa);\n\t\tbfa_fcs_lport_fdmi_send_rpa(fdmi, NULL);\n\t\tbreak;\n\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbfa_timer_stop(&fdmi->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_fdmi_sm_online(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\tenum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\tswitch (event) {\n\tcase FDMISM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n \nstatic void\nbfa_fcs_lport_fdmi_sm_disabled(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t     enum port_fdmi_event event)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\tbfa_trc(port->fcs, event);\n\n\t \n}\n\n \nstatic void\nbfa_fcs_lport_fdmi_send_rhba(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi = fdmi_cbarg;\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct fchs_s fchs;\n\tint             len, attr_len;\n\tstruct bfa_fcxp_s *fcxp;\n\tu8        *pyld;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_fdmi_send_rhba, fdmi, BFA_TRUE);\n\t\treturn;\n\t}\n\tfdmi->fcxp = fcxp;\n\n\tpyld = bfa_fcxp_get_reqbuf(fcxp);\n\tmemset(pyld, 0, FC_MAX_PDUSZ);\n\n\tlen = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_lport_get_fcid(port),\n\t\t\t\t   FDMI_RHBA);\n\n\tattr_len =\n\t\tbfa_fcs_lport_fdmi_build_rhba_pyld(fdmi,\n\t\t\t\t\t  (u8 *) ((struct ct_hdr_s *) pyld\n\t\t\t\t\t\t       + 1));\n\tif (attr_len < 0)\n\t\treturn;\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, (len + attr_len), &fchs,\n\t\t\t  bfa_fcs_lport_fdmi_rhba_response, (void *)fdmi,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RHBA_SENT);\n}\n\nstatic int\nbfa_fcs_lport_fdmi_build_rhba_pyld(struct bfa_fcs_lport_fdmi_s *fdmi, u8 *pyld)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct bfa_fcs_fdmi_hba_attr_s *fcs_hba_attr;\n\tstruct fdmi_rhba_s *rhba = (struct fdmi_rhba_s *) pyld;\n\tstruct fdmi_attr_s *attr;\n\tint        len;\n\tu8        *curr_ptr;\n\tu16\ttemplen, count;\n\n\tfcs_hba_attr = kzalloc(sizeof(*fcs_hba_attr), GFP_KERNEL);\n\tif (!fcs_hba_attr)\n\t\treturn -ENOMEM;\n\n\t \n\tbfa_fcs_fdmi_get_hbaattr(fdmi, fcs_hba_attr);\n\n\trhba->hba_id = bfa_fcs_lport_get_pwwn(port);\n\trhba->port_list.num_ports = cpu_to_be32(1);\n\trhba->port_list.port_entry = bfa_fcs_lport_get_pwwn(port);\n\n\tlen = sizeof(rhba->hba_id) + sizeof(rhba->port_list);\n\n\tcount = 0;\n\tlen += sizeof(rhba->hba_attr_blk.attr_count);\n\n\t \n\tcurr_ptr = (u8 *) &rhba->hba_attr_blk.hba_attr;\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_NODENAME);\n\ttemplen = sizeof(wwn_t);\n\tmemcpy(attr->value, &bfa_fcs_lport_get_nwwn(port), templen);\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\tcount++;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_MANUFACTURER);\n\ttemplen = (u16) strlen(fcs_hba_attr->manufacturer);\n\tmemcpy(attr->value, fcs_hba_attr->manufacturer, templen);\n\ttemplen = fc_roundup(templen, sizeof(u32));\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\tcount++;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_SERIALNUM);\n\ttemplen = (u16) strlen(fcs_hba_attr->serial_num);\n\tmemcpy(attr->value, fcs_hba_attr->serial_num, templen);\n\ttemplen = fc_roundup(templen, sizeof(u32));\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\tcount++;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_MODEL);\n\ttemplen = (u16) strlen(fcs_hba_attr->model);\n\tmemcpy(attr->value, fcs_hba_attr->model, templen);\n\ttemplen = fc_roundup(templen, sizeof(u32));\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\tcount++;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_MODEL_DESC);\n\ttemplen = (u16) strlen(fcs_hba_attr->model_desc);\n\tmemcpy(attr->value, fcs_hba_attr->model_desc, templen);\n\ttemplen = fc_roundup(templen, sizeof(u32));\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\tcount++;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tif (fcs_hba_attr->hw_version[0] != '\\0') {\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_HW_VERSION);\n\t\ttemplen = (u16) strlen(fcs_hba_attr->hw_version);\n\t\tmemcpy(attr->value, fcs_hba_attr->hw_version, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\tcount++;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\t sizeof(templen));\n\t}\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_DRIVER_VERSION);\n\ttemplen = (u16) strlen(fcs_hba_attr->driver_version);\n\tmemcpy(attr->value, fcs_hba_attr->driver_version, templen);\n\ttemplen = fc_roundup(templen, sizeof(u32));\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\tcount++;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tif (fcs_hba_attr->option_rom_ver[0] != '\\0') {\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_ROM_VERSION);\n\t\ttemplen = (u16) strlen(fcs_hba_attr->option_rom_ver);\n\t\tmemcpy(attr->value, fcs_hba_attr->option_rom_ver, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\tcount++;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\t sizeof(templen));\n\t}\n\n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_FW_VERSION);\n\ttemplen = (u16) strlen(fcs_hba_attr->fw_version);\n\tmemcpy(attr->value, fcs_hba_attr->fw_version, templen);\n\ttemplen = fc_roundup(templen, sizeof(u32));\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\tcount++;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tif (fcs_hba_attr->os_name[0] != '\\0') {\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_OS_NAME);\n\t\ttemplen = (u16) strlen(fcs_hba_attr->os_name);\n\t\tmemcpy(attr->value, fcs_hba_attr->os_name, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\tcount++;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\tsizeof(templen));\n\t}\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_MAX_CT);\n\ttemplen = sizeof(fcs_hba_attr->max_ct_pyld);\n\tmemcpy(attr->value, &fcs_hba_attr->max_ct_pyld, templen);\n\ttemplen = fc_roundup(templen, sizeof(u32));\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\tcount++;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\t \n\tif (fdmi->retry_cnt == 0) {\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_NODE_SYM_NAME);\n\t\ttemplen = sizeof(fcs_hba_attr->node_sym_name);\n\t\tmemcpy(attr->value, &fcs_hba_attr->node_sym_name, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\tcount++;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\tsizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_VENDOR_ID);\n\t\ttemplen = sizeof(fcs_hba_attr->vendor_info);\n\t\tmemcpy(attr->value, &fcs_hba_attr->vendor_info, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\tcount++;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\tsizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_NUM_PORTS);\n\t\ttemplen = sizeof(fcs_hba_attr->num_ports);\n\t\tmemcpy(attr->value, &fcs_hba_attr->num_ports, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\tcount++;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\tsizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_FABRIC_NAME);\n\t\ttemplen = sizeof(fcs_hba_attr->fabric_name);\n\t\tmemcpy(attr->value, &fcs_hba_attr->fabric_name, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\tcount++;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\tsizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_HBA_ATTRIB_BIOS_VER);\n\t\ttemplen = sizeof(fcs_hba_attr->bios_ver);\n\t\tmemcpy(attr->value, &fcs_hba_attr->bios_ver, templen);\n\t\ttemplen = fc_roundup(attr->len, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\tcount++;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\tsizeof(templen));\n\t}\n\n\t \n\tlen += ((sizeof(attr->type) + sizeof(attr->len)) * count);\n\n\trhba->hba_attr_blk.attr_count = cpu_to_be32(count);\n\n\tkfree(fcs_hba_attr);\n\n\treturn len;\n}\n\nstatic void\nbfa_fcs_lport_fdmi_rhba_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\t\tu32 rsp_len, u32 resid_len,\n\t\t\t\tstruct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi =\n\t\t\t\t(struct bfa_fcs_lport_fdmi_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct ct_hdr_s *cthdr = NULL;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\n}\n\n \nstatic void\nbfa_fcs_lport_fdmi_send_rprt(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi = fdmi_cbarg;\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct fchs_s fchs;\n\tu16        len, attr_len;\n\tstruct bfa_fcxp_s *fcxp;\n\tu8        *pyld;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_fdmi_send_rprt, fdmi, BFA_TRUE);\n\t\treturn;\n\t}\n\tfdmi->fcxp = fcxp;\n\n\tpyld = bfa_fcxp_get_reqbuf(fcxp);\n\tmemset(pyld, 0, FC_MAX_PDUSZ);\n\n\tlen = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_lport_get_fcid(port),\n\t\t\t\t   FDMI_RPRT);\n\n\tattr_len =\n\t\tbfa_fcs_lport_fdmi_build_rprt_pyld(fdmi,\n\t\t\t\t\t  (u8 *) ((struct ct_hdr_s *) pyld\n\t\t\t\t\t\t       + 1));\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len + attr_len, &fchs,\n\t\t\t  bfa_fcs_lport_fdmi_rprt_response, (void *)fdmi,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RPRT_SENT);\n}\n\n \nstatic          u16\nbfa_fcs_lport_fdmi_build_portattr_block(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t\t       u8 *pyld)\n{\n\tstruct bfa_fcs_fdmi_port_attr_s fcs_port_attr;\n\tstruct fdmi_port_attr_s *port_attrib = (struct fdmi_port_attr_s *) pyld;\n\tstruct fdmi_attr_s *attr;\n\tu8        *curr_ptr;\n\tu16        len;\n\tu8\tcount = 0;\n\tu16\ttemplen;\n\n\t \n\tbfa_fcs_fdmi_get_portattr(fdmi, &fcs_port_attr);\n\n\tlen = sizeof(port_attrib->attr_count);\n\n\t \n\tcurr_ptr = (u8 *) &port_attrib->port_attr;\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_FC4_TYPES);\n\ttemplen = sizeof(fcs_port_attr.supp_fc4_types);\n\tmemcpy(attr->value, fcs_port_attr.supp_fc4_types, templen);\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\t++count;\n\tattr->len =\n\t\tcpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_SUPP_SPEED);\n\ttemplen = sizeof(fcs_port_attr.supp_speed);\n\tmemcpy(attr->value, &fcs_port_attr.supp_speed, templen);\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\t++count;\n\tattr->len =\n\t\tcpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_SPEED);\n\ttemplen = sizeof(fcs_port_attr.curr_speed);\n\tmemcpy(attr->value, &fcs_port_attr.curr_speed, templen);\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\t++count;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tattr = (struct fdmi_attr_s *) curr_ptr;\n\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_FRAME_SIZE);\n\ttemplen = sizeof(fcs_port_attr.max_frm_size);\n\tmemcpy(attr->value, &fcs_port_attr.max_frm_size, templen);\n\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\tlen += templen;\n\t++count;\n\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t     sizeof(templen));\n\n\t \n\tif (fcs_port_attr.os_device_name[0] != '\\0') {\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_DEV_NAME);\n\t\ttemplen = (u16) strlen(fcs_port_attr.os_device_name);\n\t\tmemcpy(attr->value, fcs_port_attr.os_device_name, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t\tsizeof(templen));\n\t}\n\t \n\tif (fcs_port_attr.host_name[0] != '\\0') {\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_HOST_NAME);\n\t\ttemplen = (u16) strlen(fcs_port_attr.host_name);\n\t\tmemcpy(attr->value, fcs_port_attr.host_name, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\tsizeof(templen));\n\t}\n\n\tif (fdmi->retry_cnt == 0) {\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_NODE_NAME);\n\t\ttemplen = sizeof(fcs_port_attr.node_name);\n\t\tmemcpy(attr->value, &fcs_port_attr.node_name, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t sizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_NAME);\n\t\ttemplen = sizeof(fcs_port_attr.port_name);\n\t\tmemcpy(attr->value, &fcs_port_attr.port_name, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(attr->len) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t sizeof(templen));\n\n\t\tif (fcs_port_attr.port_sym_name.symname[0] != '\\0') {\n\t\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\t\tattr->type =\n\t\t\t\tcpu_to_be16(FDMI_PORT_ATTRIB_PORT_SYM_NAME);\n\t\t\ttemplen = sizeof(fcs_port_attr.port_sym_name);\n\t\t\tmemcpy(attr->value,\n\t\t\t\t&fcs_port_attr.port_sym_name, templen);\n\t\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\t\tcurr_ptr += sizeof(attr->type) +\n\t\t\t\t\tsizeof(templen) + templen;\n\t\t\tlen += templen;\n\t\t\t++count;\n\t\t\tattr->len = cpu_to_be16(templen +\n\t\t\t\tsizeof(attr->type) + sizeof(templen));\n\t\t}\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_TYPE);\n\t\ttemplen = sizeof(fcs_port_attr.port_type);\n\t\tmemcpy(attr->value, &fcs_port_attr.port_type, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t sizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_SUPP_COS);\n\t\ttemplen = sizeof(fcs_port_attr.scos);\n\t\tmemcpy(attr->value, &fcs_port_attr.scos, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t sizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_FAB_NAME);\n\t\ttemplen = sizeof(fcs_port_attr.port_fabric_name);\n\t\tmemcpy(attr->value, &fcs_port_attr.port_fabric_name, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t sizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_FC4_TYPE);\n\t\ttemplen = sizeof(fcs_port_attr.port_act_fc4_type);\n\t\tmemcpy(attr->value, fcs_port_attr.port_act_fc4_type,\n\t\t\t\ttemplen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t sizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_STATE);\n\t\ttemplen = sizeof(fcs_port_attr.port_state);\n\t\tmemcpy(attr->value, &fcs_port_attr.port_state, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\t sizeof(templen));\n\n\t\tattr = (struct fdmi_attr_s *) curr_ptr;\n\t\tattr->type = cpu_to_be16(FDMI_PORT_ATTRIB_PORT_NUM_RPRT);\n\t\ttemplen = sizeof(fcs_port_attr.num_ports);\n\t\tmemcpy(attr->value, &fcs_port_attr.num_ports, templen);\n\t\ttemplen = fc_roundup(templen, sizeof(u32));\n\t\tcurr_ptr += sizeof(attr->type) + sizeof(templen) + templen;\n\t\tlen += templen;\n\t\t++count;\n\t\tattr->len = cpu_to_be16(templen + sizeof(attr->type) +\n\t\t\t\tsizeof(templen));\n\t}\n\n\t \n\tport_attrib->attr_count = cpu_to_be32(count);\n\tlen += ((sizeof(attr->type) + sizeof(attr->len)) * count);\n\treturn len;\n}\n\nstatic          u16\nbfa_fcs_lport_fdmi_build_rprt_pyld(struct bfa_fcs_lport_fdmi_s *fdmi, u8 *pyld)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct fdmi_rprt_s *rprt = (struct fdmi_rprt_s *) pyld;\n\tu16        len;\n\n\trprt->hba_id = bfa_fcs_lport_get_pwwn(bfa_fcs_get_base_port(port->fcs));\n\trprt->port_name = bfa_fcs_lport_get_pwwn(port);\n\n\tlen = bfa_fcs_lport_fdmi_build_portattr_block(fdmi,\n\t\t\t\t(u8 *) &rprt->port_attr_blk);\n\n\tlen += sizeof(rprt->hba_id) + sizeof(rprt->port_name);\n\n\treturn len;\n}\n\nstatic void\nbfa_fcs_lport_fdmi_rprt_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\t\tu32 rsp_len, u32 resid_len,\n\t\t\t\tstruct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi =\n\t\t\t(struct bfa_fcs_lport_fdmi_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct ct_hdr_s *cthdr = NULL;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\n}\n\n \nstatic void\nbfa_fcs_lport_fdmi_send_rpa(void *fdmi_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi = fdmi_cbarg;\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct fchs_s fchs;\n\tu16        len, attr_len;\n\tstruct bfa_fcxp_s *fcxp;\n\tu8        *pyld;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &fdmi->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_fdmi_send_rpa, fdmi, BFA_TRUE);\n\t\treturn;\n\t}\n\tfdmi->fcxp = fcxp;\n\n\tpyld = bfa_fcxp_get_reqbuf(fcxp);\n\tmemset(pyld, 0, FC_MAX_PDUSZ);\n\n\tlen = fc_fdmi_reqhdr_build(&fchs, pyld, bfa_fcs_lport_get_fcid(port),\n\t\t\t\t   FDMI_RPA);\n\n\tattr_len = bfa_fcs_lport_fdmi_build_rpa_pyld(fdmi,\n\t\t\t\t(u8 *) ((struct ct_hdr_s *) pyld + 1));\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len + attr_len, &fchs,\n\t\t\t  bfa_fcs_lport_fdmi_rpa_response, (void *)fdmi,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RPA_SENT);\n}\n\nstatic          u16\nbfa_fcs_lport_fdmi_build_rpa_pyld(struct bfa_fcs_lport_fdmi_s *fdmi, u8 *pyld)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct fdmi_rpa_s *rpa = (struct fdmi_rpa_s *) pyld;\n\tu16        len;\n\n\trpa->port_name = bfa_fcs_lport_get_pwwn(port);\n\n\tlen = bfa_fcs_lport_fdmi_build_portattr_block(fdmi,\n\t\t\t\t(u8 *) &rpa->port_attr_blk);\n\n\tlen += sizeof(rpa->port_name);\n\n\treturn len;\n}\n\nstatic void\nbfa_fcs_lport_fdmi_rpa_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\tvoid *cbarg, bfa_status_t req_status, u32 rsp_len,\n\t\t\tu32 resid_len, struct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi =\n\t\t\t\t(struct bfa_fcs_lport_fdmi_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct ct_hdr_s *cthdr = NULL;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_RSP_ERROR);\n}\n\nstatic void\nbfa_fcs_lport_fdmi_timeout(void *arg)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi = (struct bfa_fcs_lport_fdmi_s *) arg;\n\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_TIMEOUT);\n}\n\nstatic void\nbfa_fcs_fdmi_get_hbaattr(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t struct bfa_fcs_fdmi_hba_attr_s *hba_attr)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct bfa_fcs_driver_info_s  *driver_info = &port->fcs->driver_info;\n\tstruct bfa_fcs_fdmi_port_attr_s fcs_port_attr;\n\n\tmemset(hba_attr, 0, sizeof(struct bfa_fcs_fdmi_hba_attr_s));\n\n\tbfa_ioc_get_adapter_manufacturer(&port->fcs->bfa->ioc,\n\t\t\t\t\thba_attr->manufacturer);\n\tbfa_ioc_get_adapter_serial_num(&port->fcs->bfa->ioc,\n\t\t\t\t\thba_attr->serial_num);\n\tbfa_ioc_get_adapter_model(&port->fcs->bfa->ioc,\n\t\t\t\t\thba_attr->model);\n\tbfa_ioc_get_adapter_model(&port->fcs->bfa->ioc,\n\t\t\t\t\thba_attr->model_desc);\n\tbfa_ioc_get_pci_chip_rev(&port->fcs->bfa->ioc,\n\t\t\t\t\thba_attr->hw_version);\n\tbfa_ioc_get_adapter_optrom_ver(&port->fcs->bfa->ioc,\n\t\t\t\t\thba_attr->option_rom_ver);\n\tbfa_ioc_get_adapter_fw_ver(&port->fcs->bfa->ioc,\n\t\t\t\t\thba_attr->fw_version);\n\n\tstrscpy(hba_attr->driver_version, (char *)driver_info->version,\n\t\tsizeof(hba_attr->driver_version));\n\n\tstrscpy(hba_attr->os_name, driver_info->host_os_name,\n\t\tsizeof(hba_attr->os_name));\n\n\t \n\tif (driver_info->host_os_patch[0] != '\\0') {\n\t\tstrlcat(hba_attr->os_name, BFA_FCS_PORT_SYMBNAME_SEPARATOR,\n\t\t\tsizeof(hba_attr->os_name));\n\t\tstrlcat(hba_attr->os_name, driver_info->host_os_patch,\n\t\t\t\tsizeof(hba_attr->os_name));\n\t}\n\n\t \n\tbfa_fcs_fdmi_get_portattr(fdmi, &fcs_port_attr);\n\thba_attr->max_ct_pyld = fcs_port_attr.max_frm_size;\n\n\tstrscpy(hba_attr->node_sym_name.symname,\n\t\tport->port_cfg.node_sym_name.symname, BFA_SYMNAME_MAXLEN);\n\tstrcpy(hba_attr->vendor_info, \"QLogic\");\n\thba_attr->num_ports =\n\t\tcpu_to_be32(bfa_ioc_get_nports(&port->fcs->bfa->ioc));\n\thba_attr->fabric_name = port->fabric->lps->pr_nwwn;\n\tstrscpy(hba_attr->bios_ver, hba_attr->option_rom_ver, BFA_VERSION_LEN);\n\n}\n\nstatic void\nbfa_fcs_fdmi_get_portattr(struct bfa_fcs_lport_fdmi_s *fdmi,\n\t\t\t  struct bfa_fcs_fdmi_port_attr_s *port_attr)\n{\n\tstruct bfa_fcs_lport_s *port = fdmi->ms->port;\n\tstruct bfa_fcs_driver_info_s  *driver_info = &port->fcs->driver_info;\n\tstruct bfa_port_attr_s pport_attr;\n\tstruct bfa_lport_attr_s lport_attr;\n\n\tmemset(port_attr, 0, sizeof(struct bfa_fcs_fdmi_port_attr_s));\n\n\t \n\tbfa_fcport_get_attr(port->fcs->bfa, &pport_attr);\n\n\t \n\tfc_get_fc4type_bitmask(FC_TYPE_FCP, port_attr->supp_fc4_types);\n\n\t \n\tswitch (pport_attr.speed_supported) {\n\tcase BFA_PORT_SPEED_16GBPS:\n\t\tport_attr->supp_speed =\n\t\t\tcpu_to_be32(BFA_FCS_FDMI_SUPP_SPEEDS_16G);\n\t\tbreak;\n\n\tcase BFA_PORT_SPEED_10GBPS:\n\t\tport_attr->supp_speed =\n\t\t\tcpu_to_be32(BFA_FCS_FDMI_SUPP_SPEEDS_10G);\n\t\tbreak;\n\n\tcase BFA_PORT_SPEED_8GBPS:\n\t\tport_attr->supp_speed =\n\t\t\tcpu_to_be32(BFA_FCS_FDMI_SUPP_SPEEDS_8G);\n\t\tbreak;\n\n\tcase BFA_PORT_SPEED_4GBPS:\n\t\tport_attr->supp_speed =\n\t\t\tcpu_to_be32(BFA_FCS_FDMI_SUPP_SPEEDS_4G);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, pport_attr.speed_supported);\n\t}\n\n\t \n\tport_attr->curr_speed = cpu_to_be32(\n\t\t\t\tbfa_fcs_fdmi_convert_speed(pport_attr.speed));\n\n\t \n\tport_attr->max_frm_size = cpu_to_be32(pport_attr.pport_cfg.maxfrsize);\n\n\t \n\tstrscpy(port_attr->os_device_name, driver_info->os_device_name,\n\t\tsizeof(port_attr->os_device_name));\n\n\t \n\tstrscpy(port_attr->host_name, driver_info->host_machine_name,\n\t\tsizeof(port_attr->host_name));\n\n\tport_attr->node_name = bfa_fcs_lport_get_nwwn(port);\n\tport_attr->port_name = bfa_fcs_lport_get_pwwn(port);\n\n\tstrscpy(port_attr->port_sym_name.symname,\n\t\tbfa_fcs_lport_get_psym_name(port).symname, BFA_SYMNAME_MAXLEN);\n\tbfa_fcs_lport_get_attr(port, &lport_attr);\n\tport_attr->port_type = cpu_to_be32(lport_attr.port_type);\n\tport_attr->scos = pport_attr.cos_supported;\n\tport_attr->port_fabric_name = port->fabric->lps->pr_nwwn;\n\tfc_get_fc4type_bitmask(FC_TYPE_FCP, port_attr->port_act_fc4_type);\n\tport_attr->port_state = cpu_to_be32(pport_attr.port_state);\n\tport_attr->num_ports = cpu_to_be32(port->num_rports);\n}\n\n \nu32\nbfa_fcs_fdmi_convert_speed(bfa_port_speed_t pport_speed)\n{\n\tu32\tret;\n\n\tswitch (pport_speed) {\n\tcase BFA_PORT_SPEED_1GBPS:\n\tcase BFA_PORT_SPEED_2GBPS:\n\t\tret = pport_speed;\n\t\tbreak;\n\n\tcase BFA_PORT_SPEED_4GBPS:\n\t\tret = FDMI_TRANS_SPEED_4G;\n\t\tbreak;\n\n\tcase BFA_PORT_SPEED_8GBPS:\n\t\tret = FDMI_TRANS_SPEED_8G;\n\t\tbreak;\n\n\tcase BFA_PORT_SPEED_10GBPS:\n\t\tret = FDMI_TRANS_SPEED_10G;\n\t\tbreak;\n\n\tcase BFA_PORT_SPEED_16GBPS:\n\t\tret = FDMI_TRANS_SPEED_16G;\n\t\tbreak;\n\n\tdefault:\n\t\tret = FDMI_TRANS_SPEED_UNKNOWN;\n\t}\n\treturn ret;\n}\n\nvoid\nbfa_fcs_lport_fdmi_init(struct bfa_fcs_lport_ms_s *ms)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi = &ms->fdmi;\n\n\tfdmi->ms = ms;\n\tif (ms->port->fcs->fdmi_enabled)\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_offline);\n\telse\n\t\tbfa_sm_set_state(fdmi, bfa_fcs_lport_fdmi_sm_disabled);\n}\n\nvoid\nbfa_fcs_lport_fdmi_offline(struct bfa_fcs_lport_ms_s *ms)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi = &ms->fdmi;\n\n\tfdmi->ms = ms;\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_PORT_OFFLINE);\n}\n\nvoid\nbfa_fcs_lport_fdmi_online(struct bfa_fcs_lport_ms_s *ms)\n{\n\tstruct bfa_fcs_lport_fdmi_s *fdmi = &ms->fdmi;\n\n\tfdmi->ms = ms;\n\tbfa_sm_send_event(fdmi, FDMISM_EVENT_PORT_ONLINE);\n}\n\n#define BFA_FCS_MS_CMD_MAX_RETRIES  2\n\n \nstatic void     bfa_fcs_lport_ms_send_plogi(void *ms_cbarg,\n\t\t\t\t\t   struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_ms_timeout(void *arg);\nstatic void     bfa_fcs_lport_ms_plogi_response(void *fcsarg,\n\t\t\t\t\t       struct bfa_fcxp_s *fcxp,\n\t\t\t\t\t       void *cbarg,\n\t\t\t\t\t       bfa_status_t req_status,\n\t\t\t\t\t       u32 rsp_len,\n\t\t\t\t\t       u32 resid_len,\n\t\t\t\t\t       struct fchs_s *rsp_fchs);\n\nstatic void\tbfa_fcs_lport_ms_send_gmal(void *ms_cbarg,\n\t\t\t\t\tstruct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_ms_gmal_response(void *fcsarg,\n\t\t\t\t\t       struct bfa_fcxp_s *fcxp,\n\t\t\t\t\t       void *cbarg,\n\t\t\t\t\t       bfa_status_t req_status,\n\t\t\t\t\t       u32 rsp_len,\n\t\t\t\t\t       u32 resid_len,\n\t\t\t\t\t       struct fchs_s *rsp_fchs);\nstatic void\tbfa_fcs_lport_ms_send_gfn(void *ms_cbarg,\n\t\t\t\t\tstruct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_ms_gfn_response(void *fcsarg,\n\t\t\t\t\t       struct bfa_fcxp_s *fcxp,\n\t\t\t\t\t       void *cbarg,\n\t\t\t\t\t       bfa_status_t req_status,\n\t\t\t\t\t       u32 rsp_len,\n\t\t\t\t\t       u32 resid_len,\n\t\t\t\t\t       struct fchs_s *rsp_fchs);\n \n\n \nenum port_ms_event {\n\tMSSM_EVENT_PORT_ONLINE = 1,\n\tMSSM_EVENT_PORT_OFFLINE = 2,\n\tMSSM_EVENT_RSP_OK = 3,\n\tMSSM_EVENT_RSP_ERROR = 4,\n\tMSSM_EVENT_TIMEOUT = 5,\n\tMSSM_EVENT_FCXP_SENT = 6,\n\tMSSM_EVENT_PORT_FABRIC_RSCN = 7\n};\n\nstatic void     bfa_fcs_lport_ms_sm_offline(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t   enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_plogi_sending(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t\t enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_plogi(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_plogi_retry(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t       enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_gmal_sending(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t\t enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_gmal(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_gmal_retry(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t       enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_gfn_sending(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t\t enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_gfn(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_gfn_retry(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t       enum port_ms_event event);\nstatic void     bfa_fcs_lport_ms_sm_online(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\t\t  enum port_ms_event event);\n \nstatic void\nbfa_fcs_lport_ms_sm_offline(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_PORT_ONLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_plogi_sending);\n\t\tbfa_fcs_lport_ms_send_plogi(ms, NULL);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_plogi_sending(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_FCXP_SENT:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_plogi);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\n\t\t\t\t\t   &ms->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_plogi(struct bfa_fcs_lport_ms_s *ms,\n\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_RSP_ERROR:\n\t\t \n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_plogi_retry);\n\t\tms->port->stats.ms_retries++;\n\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\n\t\t\t\t    &ms->timer, bfa_fcs_lport_ms_timeout, ms,\n\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\tbreak;\n\n\tcase MSSM_EVENT_RSP_OK:\n\t\t \n\t\tbfa_fcs_lport_fdmi_online(ms);\n\n\t\t \n\t\tif (ms->port->vport) {\n\t\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_online);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gmal_sending);\n\t\tbfa_fcs_lport_ms_send_gmal(ms, NULL);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_fcxp_discard(ms->fcxp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_plogi_retry(struct bfa_fcs_lport_ms_s *ms,\n\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_TIMEOUT:\n\t\t \n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_plogi_sending);\n\t\tbfa_fcs_lport_ms_send_plogi(ms, NULL);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_timer_stop(&ms->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_online(struct bfa_fcs_lport_ms_s *ms,\n\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_FABRIC_RSCN:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_sending);\n\t\tms->retry_cnt = 0;\n\t\tbfa_fcs_lport_ms_send_gfn(ms, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_gmal_sending(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_FCXP_SENT:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gmal);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\n\t\t\t\t\t   &ms->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_gmal(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_RSP_ERROR:\n\t\t \n\t\tif (ms->retry_cnt++ < BFA_FCS_MS_CMD_MAX_RETRIES) {\n\t\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gmal_retry);\n\t\t\tms->port->stats.ms_retries++;\n\t\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\n\t\t\t\t&ms->timer, bfa_fcs_lport_ms_timeout, ms,\n\t\t\t\tBFA_FCS_RETRY_TIMEOUT);\n\t\t} else {\n\t\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_sending);\n\t\t\tbfa_fcs_lport_ms_send_gfn(ms, NULL);\n\t\t\tms->retry_cnt = 0;\n\t\t}\n\t\tbreak;\n\n\tcase MSSM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_sending);\n\t\tbfa_fcs_lport_ms_send_gfn(ms, NULL);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_fcxp_discard(ms->fcxp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_gmal_retry(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_TIMEOUT:\n\t\t \n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gmal_sending);\n\t\tbfa_fcs_lport_ms_send_gmal(ms, NULL);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_timer_stop(&ms->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n \n\nstatic void\nbfa_fcs_lport_ms_send_gmal(void *ms_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = ms_cbarg;\n\tbfa_fcs_lport_t *port = ms->port;\n\tstruct fchs_s\tfchs;\n\tint\t\tlen;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tbfa_trc(port->fcs, port->pid);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ms_send_gmal, ms, BFA_TRUE);\n\t\treturn;\n\t}\n\tms->fcxp = fcxp;\n\n\tlen = fc_gmal_req_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t     bfa_fcs_lport_get_fcid(port),\n\t\t\t\t port->fabric->lps->pr_nwwn);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ms_gmal_response, (void *)ms,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tbfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ms_gmal_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\t\tu32 rsp_len, u32 resid_len,\n\t\t\t\tstruct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = (struct bfa_fcs_lport_ms_s *) cbarg;\n\tbfa_fcs_lport_t *port = ms->port;\n\tstruct ct_hdr_s\t\t*cthdr = NULL;\n\tstruct fcgs_gmal_resp_s *gmal_resp;\n\tstruct fcgs_gmal_entry_s *gmal_entry;\n\tu32\t\tnum_entries;\n\tu8\t\t\t*rsp_str;\n\n\tbfa_trc(port->fcs, req_status);\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tgmal_resp = (struct fcgs_gmal_resp_s *)(cthdr + 1);\n\n\t\tnum_entries = be32_to_cpu(gmal_resp->ms_len);\n\t\tif (num_entries == 0) {\n\t\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n\t\t\treturn;\n\t\t}\n\t\t \n\n\t\tgmal_entry = (struct fcgs_gmal_entry_s *)gmal_resp->ms_ma;\n\t\twhile (num_entries > 0) {\n\t\t\tif (strncmp(gmal_entry->prefix,\n\t\t\t\tCT_GMAL_RESP_PREFIX_HTTP,\n\t\t\t\tsizeof(gmal_entry->prefix)) == 0) {\n\n\t\t\t\t \n\t\t\t\trsp_str = &(gmal_entry->prefix[0]);\n\t\t\t\tif (rsp_str[gmal_entry->len-1] == '/')\n\t\t\t\t\trsp_str[gmal_entry->len-1] = 0;\n\n\t\t\t\t \n\t\t\t\tstrscpy(bfa_fcs_lport_get_fabric_ipaddr(port),\n\t\t\t\t\tgmal_entry->ip_addr,\n\t\t\t\t\tBFA_FCS_FABRIC_IPADDR_SZ);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t--num_entries;\n\t\t\t\t++gmal_entry;\n\t\t\t}\n\t\t}\n\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_gfn_sending(struct bfa_fcs_lport_ms_s *ms,\n\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_FCXP_SENT:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\n\t\t\t\t\t   &ms->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_gfn(struct bfa_fcs_lport_ms_s *ms,\n\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_RSP_ERROR:\n\t\t \n\t\tif (ms->retry_cnt++ < BFA_FCS_MS_CMD_MAX_RETRIES) {\n\t\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_retry);\n\t\t\tms->port->stats.ms_retries++;\n\t\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ms->port),\n\t\t\t\t&ms->timer, bfa_fcs_lport_ms_timeout, ms,\n\t\t\t\tBFA_FCS_RETRY_TIMEOUT);\n\t\t} else {\n\t\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_online);\n\t\t\tms->retry_cnt = 0;\n\t\t}\n\t\tbreak;\n\n\tcase MSSM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_online);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_fcxp_discard(ms->fcxp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_sm_gfn_retry(struct bfa_fcs_lport_ms_s *ms,\n\t\t\t\tenum port_ms_event event)\n{\n\tbfa_trc(ms->port->fcs, ms->port->port_cfg.pwwn);\n\tbfa_trc(ms->port->fcs, event);\n\n\tswitch (event) {\n\tcase MSSM_EVENT_TIMEOUT:\n\t\t \n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_gfn_sending);\n\t\tbfa_fcs_lport_ms_send_gfn(ms, NULL);\n\t\tbreak;\n\n\tcase MSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\t\tbfa_timer_stop(&ms->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ms->port->fcs, event);\n\t}\n}\n \n\nstatic void\nbfa_fcs_lport_ms_send_gfn(void *ms_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = ms_cbarg;\n\tbfa_fcs_lport_t *port = ms->port;\n\tstruct fchs_s\t\tfchs;\n\tint\t\t\tlen;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tbfa_trc(port->fcs, port->pid);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ms_send_gfn, ms, BFA_TRUE);\n\t\treturn;\n\t}\n\tms->fcxp = fcxp;\n\n\tlen = fc_gfn_req_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t     bfa_fcs_lport_get_fcid(port),\n\t\t\t\t port->fabric->lps->pr_nwwn);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ms_gfn_response, (void *)ms,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tbfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ms_gfn_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\tvoid *cbarg, bfa_status_t req_status, u32 rsp_len,\n\t\t\tu32 resid_len, struct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = (struct bfa_fcs_lport_ms_s *) cbarg;\n\tbfa_fcs_lport_t *port = ms->port;\n\tstruct ct_hdr_s\t*cthdr = NULL;\n\twwn_t\t       *gfn_resp;\n\n\tbfa_trc(port->fcs, req_status);\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tgfn_resp = (wwn_t *)(cthdr + 1);\n\t\t \n\t\tif ((memcmp((void *)&bfa_fcs_lport_get_fabric_name(port),\n\t\t\t\tgfn_resp, sizeof(wwn_t)) != 0)) {\n\t\t\tbfa_fcs_fabric_set_fabric_name(port->fabric, *gfn_resp);\n\t\t}\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n}\n\n \n\nstatic void\nbfa_fcs_lport_ms_send_plogi(void *ms_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = ms_cbarg;\n\tstruct bfa_fcs_lport_s *port = ms->port;\n\tstruct fchs_s\tfchs;\n\tint\tlen;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tbfa_trc(port->fcs, port->pid);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tport->stats.ms_plogi_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ms->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ms_send_plogi, ms, BFA_TRUE);\n\t\treturn;\n\t}\n\tms->fcxp = fcxp;\n\n\tlen = fc_plogi_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t     bfa_hton3b(FC_MGMT_SERVER),\n\t\t\t     bfa_fcs_lport_get_fcid(port), 0,\n\t\t\t     port->port_cfg.pwwn, port->port_cfg.nwwn,\n\t\t\t     bfa_fcport_get_maxfrsize(port->fcs->bfa),\n\t\t\t     bfa_fcport_get_rx_bbcredit(port->fcs->bfa));\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ms_plogi_response, (void *)ms,\n\t\t\t  FC_MAX_PDUSZ, FC_ELS_TOV);\n\n\tport->stats.ms_plogi_sent++;\n\tbfa_sm_send_event(ms, MSSM_EVENT_FCXP_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ms_plogi_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\tu32 rsp_len, u32 resid_len, struct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = (struct bfa_fcs_lport_ms_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = ms->port;\n\tstruct fc_els_cmd_s *els_cmd;\n\tstruct fc_ls_rjt_s *ls_rjt;\n\n\tbfa_trc(port->fcs, req_status);\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tport->stats.ms_plogi_rsp_err++;\n\t\tbfa_trc(port->fcs, req_status);\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tels_cmd = (struct fc_els_cmd_s *) BFA_FCXP_RSP_PLD(fcxp);\n\n\tswitch (els_cmd->els_code) {\n\n\tcase FC_ELS_ACC:\n\t\tif (rsp_len < sizeof(struct fc_logi_s)) {\n\t\t\tbfa_trc(port->fcs, rsp_len);\n\t\t\tport->stats.ms_plogi_acc_err++;\n\t\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n\t\t\tbreak;\n\t\t}\n\t\tport->stats.ms_plogi_accepts++;\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_OK);\n\t\tbreak;\n\n\tcase FC_ELS_LS_RJT:\n\t\tls_rjt = (struct fc_ls_rjt_s *) BFA_FCXP_RSP_PLD(fcxp);\n\n\t\tbfa_trc(port->fcs, ls_rjt->reason_code);\n\t\tbfa_trc(port->fcs, ls_rjt->reason_code_expl);\n\n\t\tport->stats.ms_rejects++;\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n\t\tbreak;\n\n\tdefault:\n\t\tport->stats.ms_plogi_unknown_rsp++;\n\t\tbfa_trc(port->fcs, els_cmd->els_code);\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_RSP_ERROR);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ms_timeout(void *arg)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = (struct bfa_fcs_lport_ms_s *) arg;\n\n\tms->port->stats.ms_timeouts++;\n\tbfa_sm_send_event(ms, MSSM_EVENT_TIMEOUT);\n}\n\n\nvoid\nbfa_fcs_lport_ms_init(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);\n\n\tms->port = port;\n\tbfa_sm_set_state(ms, bfa_fcs_lport_ms_sm_offline);\n\n\t \n\tbfa_fcs_lport_fdmi_init(ms);\n}\n\nvoid\nbfa_fcs_lport_ms_offline(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);\n\n\tms->port = port;\n\tbfa_sm_send_event(ms, MSSM_EVENT_PORT_OFFLINE);\n\tbfa_fcs_lport_fdmi_offline(ms);\n}\n\nvoid\nbfa_fcs_lport_ms_online(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);\n\n\tms->port = port;\n\tbfa_sm_send_event(ms, MSSM_EVENT_PORT_ONLINE);\n}\nvoid\nbfa_fcs_lport_ms_fabric_rscn(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_ms_s *ms = BFA_FCS_GET_MS_FROM_PORT(port);\n\n\t \n\tif (bfa_sm_cmp_state(ms, bfa_fcs_lport_ms_sm_online))\n\t\tbfa_sm_send_event(ms, MSSM_EVENT_PORT_FABRIC_RSCN);\n}\n\n \n\n \nstatic void     bfa_fcs_lport_ns_send_plogi(void *ns_cbarg,\n\t\t\t\t\t   struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_ns_send_rspn_id(void *ns_cbarg,\n\t\t\t\t\t     struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_ns_send_rft_id(void *ns_cbarg,\n\t\t\t\t\t    struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_ns_send_rff_id(void *ns_cbarg,\n\t\t\t\t\t    struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_ns_send_gid_ft(void *ns_cbarg,\n\t\t\t\t\t    struct bfa_fcxp_s *fcxp_alloced);\nstatic void\tbfa_fcs_lport_ns_send_rnn_id(void *ns_cbarg,\n\t\t\t\t\tstruct bfa_fcxp_s *fcxp_alloced);\nstatic void\tbfa_fcs_lport_ns_send_rsnn_nn(void *ns_cbarg,\n\t\t\t\t\tstruct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_ns_timeout(void *arg);\nstatic void     bfa_fcs_lport_ns_plogi_response(void *fcsarg,\n\t\t\t\t\t       struct bfa_fcxp_s *fcxp,\n\t\t\t\t\t       void *cbarg,\n\t\t\t\t\t       bfa_status_t req_status,\n\t\t\t\t\t       u32 rsp_len,\n\t\t\t\t\t       u32 resid_len,\n\t\t\t\t\t       struct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_ns_rspn_id_response(void *fcsarg,\n\t\t\t\t\t\t struct bfa_fcxp_s *fcxp,\n\t\t\t\t\t\t void *cbarg,\n\t\t\t\t\t\t bfa_status_t req_status,\n\t\t\t\t\t\t u32 rsp_len,\n\t\t\t\t\t\t u32 resid_len,\n\t\t\t\t\t\t struct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_ns_rft_id_response(void *fcsarg,\n\t\t\t\t\t\tstruct bfa_fcxp_s *fcxp,\n\t\t\t\t\t\tvoid *cbarg,\n\t\t\t\t\t\tbfa_status_t req_status,\n\t\t\t\t\t\tu32 rsp_len,\n\t\t\t\t\t\tu32 resid_len,\n\t\t\t\t\t\tstruct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_ns_rff_id_response(void *fcsarg,\n\t\t\t\t\t\tstruct bfa_fcxp_s *fcxp,\n\t\t\t\t\t\tvoid *cbarg,\n\t\t\t\t\t\tbfa_status_t req_status,\n\t\t\t\t\t\tu32 rsp_len,\n\t\t\t\t\t\tu32 resid_len,\n\t\t\t\t\t\tstruct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_ns_gid_ft_response(void *fcsarg,\n\t\t\t\t\t\tstruct bfa_fcxp_s *fcxp,\n\t\t\t\t\t\tvoid *cbarg,\n\t\t\t\t\t\tbfa_status_t req_status,\n\t\t\t\t\t\tu32 rsp_len,\n\t\t\t\t\t\tu32 resid_len,\n\t\t\t\t\t\tstruct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_ns_rnn_id_response(void *fcsarg,\n\t\t\t\t\t\tstruct bfa_fcxp_s *fcxp,\n\t\t\t\t\t\tvoid *cbarg,\n\t\t\t\t\t\tbfa_status_t req_status,\n\t\t\t\t\t\tu32 rsp_len,\n\t\t\t\t\t\tu32 resid_len,\n\t\t\t\t\t\tstruct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_ns_rsnn_nn_response(void *fcsarg,\n\t\t\t\t\t\tstruct bfa_fcxp_s *fcxp,\n\t\t\t\t\t\tvoid *cbarg,\n\t\t\t\t\t\tbfa_status_t req_status,\n\t\t\t\t\t\tu32 rsp_len,\n\t\t\t\t\t\tu32 resid_len,\n\t\t\t\t\t\tstruct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_ns_process_gidft_pids(\n\t\t\t\tstruct bfa_fcs_lport_s *port,\n\t\t\t\tu32 *pid_buf, u32 n_pids);\n\nstatic void bfa_fcs_lport_ns_boot_target_disc(bfa_fcs_lport_t *port);\n \n\n \nenum vport_ns_event {\n\tNSSM_EVENT_PORT_ONLINE = 1,\n\tNSSM_EVENT_PORT_OFFLINE = 2,\n\tNSSM_EVENT_PLOGI_SENT = 3,\n\tNSSM_EVENT_RSP_OK = 4,\n\tNSSM_EVENT_RSP_ERROR = 5,\n\tNSSM_EVENT_TIMEOUT = 6,\n\tNSSM_EVENT_NS_QUERY = 7,\n\tNSSM_EVENT_RSPNID_SENT = 8,\n\tNSSM_EVENT_RFTID_SENT = 9,\n\tNSSM_EVENT_RFFID_SENT = 10,\n\tNSSM_EVENT_GIDFT_SENT = 11,\n\tNSSM_EVENT_RNNID_SENT = 12,\n\tNSSM_EVENT_RSNN_NN_SENT = 13,\n};\n\nstatic void     bfa_fcs_lport_ns_sm_offline(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t   enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_plogi_sending(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t\t enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_plogi(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_plogi_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t       enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_sending_rspn_id(\n\t\t\t\t\tstruct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rspn_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t   enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rspn_id_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t\t enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_sending_rft_id(\n\t\t\t\t\tstruct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rft_id_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rft_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t  enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_sending_rff_id(\n\t\t\t\t\tstruct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rff_id_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rff_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t  enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_sending_gid_ft(\n\t\t\t\t\tstruct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_gid_ft(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t  enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_gid_ft_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_online(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t  enum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_sending_rnn_id(\n\t\t\t\t\tstruct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rnn_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rnn_id_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_sending_rsnn_nn(\n\t\t\t\t\tstruct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rsnn_nn(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\t\tenum vport_ns_event event);\nstatic void     bfa_fcs_lport_ns_sm_rsnn_nn_retry(\n\t\t\t\t\tstruct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event);\n \nstatic void\nbfa_fcs_lport_ns_sm_offline(struct bfa_fcs_lport_ns_s *ns,\n\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_PORT_ONLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_plogi_sending);\n\t\tbfa_fcs_lport_ns_send_plogi(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_plogi_sending(struct bfa_fcs_lport_ns_s *ns,\n\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_PLOGI_SENT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_plogi);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t\t   &ns->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_plogi(struct bfa_fcs_lport_ns_s *ns,\n\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSP_ERROR:\n\t\t \n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_plogi_retry);\n\t\tns->port->stats.ns_retries++;\n\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t    &ns->timer, bfa_fcs_lport_ns_timeout, ns,\n\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\tbreak;\n\n\tcase NSSM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rnn_id);\n\t\tns->num_rnnid_retries = 0;\n\t\tbfa_fcs_lport_ns_send_rnn_id(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_discard(ns->fcxp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_plogi_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_TIMEOUT:\n\t\t \n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_plogi_sending);\n\t\tbfa_fcs_lport_ns_send_plogi(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_timer_stop(&ns->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_sending_rnn_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RNNID_SENT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rnn_id);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t\t\t&ns->fcxp_wqe);\n\t\tbreak;\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rnn_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rsnn_nn);\n\t\tns->num_rnnid_retries = 0;\n\t\tns->num_rsnn_nn_retries = 0;\n\t\tbfa_fcs_lport_ns_send_rsnn_nn(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_RSP_ERROR:\n\t\tif (ns->num_rnnid_retries < BFA_FCS_MAX_NS_RETRIES) {\n\t\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rnn_id_retry);\n\t\t\tns->port->stats.ns_retries++;\n\t\t\tns->num_rnnid_retries++;\n\t\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t&ns->timer, bfa_fcs_lport_ns_timeout, ns,\n\t\t\t\tBFA_FCS_RETRY_TIMEOUT);\n\t\t} else {\n\t\t\tbfa_sm_set_state(ns,\n\t\t\t\tbfa_fcs_lport_ns_sm_sending_rspn_id);\n\t\t\tbfa_fcs_lport_ns_send_rspn_id(ns, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_fcxp_discard(ns->fcxp);\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rnn_id_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_TIMEOUT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rnn_id);\n\t\tbfa_fcs_lport_ns_send_rnn_id(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_timer_stop(&ns->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_sending_rsnn_nn(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSNN_NN_SENT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rsnn_nn);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t&ns->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rsnn_nn(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rspn_id);\n\t\tns->num_rsnn_nn_retries = 0;\n\t\tbfa_fcs_lport_ns_send_rspn_id(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_RSP_ERROR:\n\t\tif (ns->num_rsnn_nn_retries < BFA_FCS_MAX_NS_RETRIES) {\n\t\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rsnn_nn_retry);\n\t\t\tns->port->stats.ns_retries++;\n\t\t\tns->num_rsnn_nn_retries++;\n\t\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t\t&ns->timer, bfa_fcs_lport_ns_timeout,\n\t\t\t\t\tns, BFA_FCS_RETRY_TIMEOUT);\n\t\t} else {\n\t\t\tbfa_sm_set_state(ns,\n\t\t\t\tbfa_fcs_lport_ns_sm_sending_rspn_id);\n\t\t\tbfa_fcs_lport_ns_send_rspn_id(ns, NULL);\n\t\t}\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_discard(ns->fcxp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rsnn_nn_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_TIMEOUT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rsnn_nn);\n\t\tbfa_fcs_lport_ns_send_rsnn_nn(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_timer_stop(&ns->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_sending_rspn_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t   enum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSPNID_SENT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rspn_id);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t\t   &ns->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rspn_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSP_ERROR:\n\t\t \n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rspn_id_retry);\n\t\tns->port->stats.ns_retries++;\n\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t    &ns->timer, bfa_fcs_lport_ns_timeout, ns,\n\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\tbreak;\n\n\tcase NSSM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rft_id);\n\t\tbfa_fcs_lport_ns_send_rft_id(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_fcxp_discard(ns->fcxp);\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rspn_id_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_TIMEOUT:\n\t\t \n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rspn_id);\n\t\tbfa_fcs_lport_ns_send_rspn_id(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_timer_stop(&ns->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_sending_rft_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t  enum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RFTID_SENT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rft_id);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t\t   &ns->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rft_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSP_OK:\n\t\t \n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rff_id);\n\t\tbfa_fcs_lport_ns_send_rff_id(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_RSP_ERROR:\n\t\t \n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rft_id_retry);\n\t\tns->port->stats.ns_retries++;\n\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t    &ns->timer, bfa_fcs_lport_ns_timeout, ns,\n\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_discard(ns->fcxp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rft_id_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_TIMEOUT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rft_id);\n\t\tbfa_fcs_lport_ns_send_rft_id(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_timer_stop(&ns->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_sending_rff_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t  enum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RFFID_SENT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rff_id);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t\t   &ns->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rff_id(struct bfa_fcs_lport_ns_s *ns,\n\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSP_OK:\n\n\t\t \n\t\tif (__fcs_min_cfg(ns->port->fcs)) {\n\t\t\tbfa_fcs_lport_ns_boot_target_disc(ns->port);\n\t\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_online);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (BFA_FCS_VPORT_IS_INITIATOR_MODE(ns->port)) {\n\t\t\tbfa_sm_set_state(ns,\n\t\t\t\tbfa_fcs_lport_ns_sm_sending_gid_ft);\n\t\t\tbfa_fcs_lport_ns_send_gid_ft(ns, NULL);\n\t\t}\n\t\t \n\t\tbfa_fcs_lport_ms_online(ns->port);\n\t\tbreak;\n\n\tcase NSSM_EVENT_RSP_ERROR:\n\t\t \n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_rff_id_retry);\n\t\tns->port->stats.ns_retries++;\n\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t    &ns->timer, bfa_fcs_lport_ns_timeout, ns,\n\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_discard(ns->fcxp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_rff_id_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_TIMEOUT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_rff_id);\n\t\tbfa_fcs_lport_ns_send_rff_id(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_timer_stop(&ns->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\nstatic void\nbfa_fcs_lport_ns_sm_sending_gid_ft(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\t  enum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_GIDFT_SENT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_gid_ft);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t\t   &ns->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_gid_ft(struct bfa_fcs_lport_ns_s *ns,\n\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_online);\n\t\tbreak;\n\n\tcase NSSM_EVENT_RSP_ERROR:\n\t\t \n\t\t \n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_gid_ft_retry);\n\t\tns->port->stats.ns_retries++;\n\t\tbfa_timer_start(BFA_FCS_GET_HAL_FROM_PORT(ns->port),\n\t\t\t\t    &ns->timer, bfa_fcs_lport_ns_timeout, ns,\n\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_fcxp_discard(ns->fcxp);\n\t\tbreak;\n\n\tcase  NSSM_EVENT_NS_QUERY:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_gid_ft_retry(struct bfa_fcs_lport_ns_s *ns,\n\t\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_TIMEOUT:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_sending_gid_ft);\n\t\tbfa_fcs_lport_ns_send_gid_ft(ns, NULL);\n\t\tbreak;\n\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbfa_timer_stop(&ns->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_ns_sm_online(struct bfa_fcs_lport_ns_s *ns,\n\t\t\tenum vport_ns_event event)\n{\n\tbfa_trc(ns->port->fcs, ns->port->port_cfg.pwwn);\n\tbfa_trc(ns->port->fcs, event);\n\n\tswitch (event) {\n\tcase NSSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n\t\tbreak;\n\n\tcase NSSM_EVENT_NS_QUERY:\n\t\t \n\t\tif (BFA_FCS_VPORT_IS_INITIATOR_MODE(ns->port)) {\n\t\t\tbfa_sm_set_state(ns,\n\t\t\t\tbfa_fcs_lport_ns_sm_sending_gid_ft);\n\t\t\tbfa_fcs_lport_ns_send_gid_ft(ns, NULL);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ns->port->fcs, event);\n\t}\n}\n\n\n\n \n\nstatic void\nbfa_fcs_lport_ns_send_plogi(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct fchs_s fchs;\n\tint             len;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tbfa_trc(port->fcs, port->pid);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tport->stats.ns_plogi_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ns_send_plogi, ns, BFA_TRUE);\n\t\treturn;\n\t}\n\tns->fcxp = fcxp;\n\n\tlen = fc_plogi_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t     bfa_hton3b(FC_NAME_SERVER),\n\t\t\t     bfa_fcs_lport_get_fcid(port), 0,\n\t\t\t     port->port_cfg.pwwn, port->port_cfg.nwwn,\n\t\t\t     bfa_fcport_get_maxfrsize(port->fcs->bfa),\n\t\t\t     bfa_fcport_get_rx_bbcredit(port->fcs->bfa));\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ns_plogi_response, (void *)ns,\n\t\t\t  FC_MAX_PDUSZ, FC_ELS_TOV);\n\tport->stats.ns_plogi_sent++;\n\n\tbfa_sm_send_event(ns, NSSM_EVENT_PLOGI_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ns_plogi_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\tvoid *cbarg, bfa_status_t req_status, u32 rsp_len,\n\t\t       u32 resid_len, struct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\t \n\tstruct fc_els_cmd_s *els_cmd;\n\tstruct fc_ls_rjt_s *ls_rjt;\n\n\tbfa_trc(port->fcs, req_status);\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tport->stats.ns_plogi_rsp_err++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tels_cmd = (struct fc_els_cmd_s *) BFA_FCXP_RSP_PLD(fcxp);\n\n\tswitch (els_cmd->els_code) {\n\n\tcase FC_ELS_ACC:\n\t\tif (rsp_len < sizeof(struct fc_logi_s)) {\n\t\t\tbfa_trc(port->fcs, rsp_len);\n\t\t\tport->stats.ns_plogi_acc_err++;\n\t\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\t\tbreak;\n\t\t}\n\t\tport->stats.ns_plogi_accepts++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t\tbreak;\n\n\tcase FC_ELS_LS_RJT:\n\t\tls_rjt = (struct fc_ls_rjt_s *) BFA_FCXP_RSP_PLD(fcxp);\n\n\t\tbfa_trc(port->fcs, ls_rjt->reason_code);\n\t\tbfa_trc(port->fcs, ls_rjt->reason_code_expl);\n\n\t\tport->stats.ns_rejects++;\n\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\tbreak;\n\n\tdefault:\n\t\tport->stats.ns_plogi_unknown_rsp++;\n\t\tbfa_trc(port->fcs, els_cmd->els_code);\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t}\n}\n\n \nstatic void\nbfa_fcs_lport_ns_send_rnn_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct fchs_s  fchs;\n\tint\tlen;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t\t\tbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tport->stats.ns_rnnid_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ns_send_rnn_id, ns, BFA_TRUE);\n\t\treturn;\n\t}\n\n\tns->fcxp = fcxp;\n\n\tlen = fc_rnnid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t\tbfa_fcs_lport_get_fcid(port),\n\t\t\t\tbfa_fcs_lport_get_fcid(port),\n\t\t\t\tbfa_fcs_lport_get_nwwn(port));\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ns_rnn_id_response, (void *)ns,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tport->stats.ns_rnnid_sent++;\n\tbfa_sm_send_event(ns, NSSM_EVENT_RNNID_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ns_rnn_id_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\t\tu32 rsp_len, u32 resid_len,\n\t\t\t\tstruct fchs_s *rsp_fchs)\n\n{\n\tstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct ct_hdr_s\t*cthdr = NULL;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tport->stats.ns_rnnid_rsp_err++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tport->stats.ns_rnnid_accepts++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tport->stats.ns_rnnid_rejects++;\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n}\n\n \nstatic void\nbfa_fcs_lport_ns_send_rsnn_nn(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct fchs_s  fchs;\n\tint     len;\n\tstruct bfa_fcxp_s *fcxp;\n\tu8 *nsymbl;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t\t\tbfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tport->stats.ns_rsnn_nn_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ns_send_rsnn_nn, ns, BFA_TRUE);\n\t\treturn;\n\t}\n\tns->fcxp = fcxp;\n\n\tnsymbl = (u8 *) &(bfa_fcs_lport_get_nsym_name(\n\t\t\t\t\tbfa_fcs_get_base_port(port->fcs)));\n\n\tlen = fc_rsnn_nn_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t\tbfa_fcs_lport_get_fcid(port),\n\t\t\t\tbfa_fcs_lport_get_nwwn(port), nsymbl);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ns_rsnn_nn_response, (void *)ns,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tport->stats.ns_rsnn_nn_sent++;\n\n\tbfa_sm_send_event(ns, NSSM_EVENT_RSNN_NN_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ns_rsnn_nn_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\t\tu32 rsp_len, u32 resid_len,\n\t\t\t\tstruct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct ct_hdr_s\t*cthdr = NULL;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tport->stats.ns_rsnn_nn_rsp_err++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tport->stats.ns_rsnn_nn_accepts++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tport->stats.ns_rsnn_nn_rejects++;\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n}\n\n \nstatic void\nbfa_fcs_lport_ns_send_rspn_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct fchs_s fchs;\n\tint             len;\n\tstruct bfa_fcxp_s *fcxp;\n\tu8         symbl[256];\n\tu8         *psymbl = &symbl[0];\n\n\tmemset(symbl, 0, sizeof(symbl));\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tport->stats.ns_rspnid_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ns_send_rspn_id, ns, BFA_TRUE);\n\t\treturn;\n\t}\n\tns->fcxp = fcxp;\n\n\t \n\tif (port->vport) {\n\t\t \n\n\t\tstrscpy(symbl,\n\t\t\t(char *)&(bfa_fcs_lport_get_psym_name\n\t\t\t (bfa_fcs_get_base_port(port->fcs))),\n\t\t\tsizeof(symbl));\n\n\t\tstrlcat(symbl, (char *)&(bfa_fcs_lport_get_psym_name(port)),\n\t\t\tsizeof(symbl));\n\t} else {\n\t\tpsymbl = (u8 *) &(bfa_fcs_lport_get_psym_name(port));\n\t}\n\n\tlen = fc_rspnid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t      bfa_fcs_lport_get_fcid(port), 0, psymbl);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ns_rspn_id_response, (void *)ns,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tport->stats.ns_rspnid_sent++;\n\n\tbfa_sm_send_event(ns, NSSM_EVENT_RSPNID_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ns_rspn_id_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\t void *cbarg, bfa_status_t req_status,\n\t\t\t\t u32 rsp_len, u32 resid_len,\n\t\t\t\t struct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct ct_hdr_s *cthdr = NULL;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tport->stats.ns_rspnid_rsp_err++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tport->stats.ns_rspnid_accepts++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tport->stats.ns_rspnid_rejects++;\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n}\n\n \nstatic void\nbfa_fcs_lport_ns_send_rft_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct fchs_s fchs;\n\tint             len;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tport->stats.ns_rftid_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ns_send_rft_id, ns, BFA_TRUE);\n\t\treturn;\n\t}\n\tns->fcxp = fcxp;\n\n\tlen = fc_rftid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t     bfa_fcs_lport_get_fcid(port), 0, port->port_cfg.roles);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ns_rft_id_response, (void *)ns,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tport->stats.ns_rftid_sent++;\n\tbfa_sm_send_event(ns, NSSM_EVENT_RFTID_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ns_rft_id_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\t\tu32 rsp_len, u32 resid_len,\n\t\t\t\tstruct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct ct_hdr_s *cthdr = NULL;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tport->stats.ns_rftid_rsp_err++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tport->stats.ns_rftid_accepts++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tport->stats.ns_rftid_rejects++;\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n}\n\n \nstatic void\nbfa_fcs_lport_ns_send_rff_id(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct fchs_s fchs;\n\tint             len;\n\tstruct bfa_fcxp_s *fcxp;\n\tu8\t\t\tfc4_ftrs = 0;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tport->stats.ns_rffid_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ns_send_rff_id, ns, BFA_TRUE);\n\t\treturn;\n\t}\n\tns->fcxp = fcxp;\n\n\tif (BFA_FCS_VPORT_IS_INITIATOR_MODE(ns->port))\n\t\tfc4_ftrs = FC_GS_FCP_FC4_FEATURE_INITIATOR;\n\n\tlen = fc_rffid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t     bfa_fcs_lport_get_fcid(port), 0,\n\t\t\t\t FC_TYPE_FCP, fc4_ftrs);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ns_rff_id_response, (void *)ns,\n\t\t\t  FC_MAX_PDUSZ, FC_FCCT_TOV);\n\n\tport->stats.ns_rffid_sent++;\n\tbfa_sm_send_event(ns, NSSM_EVENT_RFFID_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ns_rff_id_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\t\tu32 rsp_len, u32 resid_len,\n\t\t\t\tstruct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct ct_hdr_s *cthdr = NULL;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tport->stats.ns_rffid_rsp_err++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tif (cthdr->cmd_rsp_code == CT_RSP_ACCEPT) {\n\t\tport->stats.ns_rffid_accepts++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t\treturn;\n\t}\n\n\tport->stats.ns_rffid_rejects++;\n\tbfa_trc(port->fcs, cthdr->reason_code);\n\tbfa_trc(port->fcs, cthdr->exp_code);\n\n\tif (cthdr->reason_code == CT_RSN_NOT_SUPP) {\n\t\t \n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t} else\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n}\n \nstatic void\nbfa_fcs_lport_ns_send_gid_ft(void *ns_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = ns_cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct fchs_s fchs;\n\tint             len;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tbfa_trc(port->fcs, port->pid);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tport->stats.ns_gidft_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_ns_send_gid_ft, ns, BFA_TRUE);\n\t\treturn;\n\t}\n\tns->fcxp = fcxp;\n\n\t \n\tlen = fc_gid_ft_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t      ns->port->pid, FC_TYPE_FCP);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_ns_gid_ft_response, (void *)ns,\n\t\t\t  bfa_fcxp_get_maxrsp(port->fcs->bfa), FC_FCCT_TOV);\n\n\tport->stats.ns_gidft_sent++;\n\n\tbfa_sm_send_event(ns, NSSM_EVENT_GIDFT_SENT);\n}\n\nstatic void\nbfa_fcs_lport_ns_gid_ft_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\t\tvoid *cbarg, bfa_status_t req_status,\n\t\t\t\tu32 rsp_len, u32 resid_len,\n\t\t\t\tstruct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct ct_hdr_s *cthdr = NULL;\n\tu32        n_pids;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tport->stats.ns_gidft_rsp_err++;\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tif (resid_len != 0) {\n\t\t \n\t\tbfa_trc(port->fcs, rsp_len);\n\t\tbfa_trc(port->fcs, resid_len);\n\t\treturn;\n\t}\n\n\tcthdr = (struct ct_hdr_s *) BFA_FCXP_RSP_PLD(fcxp);\n\tcthdr->cmd_rsp_code = be16_to_cpu(cthdr->cmd_rsp_code);\n\n\tswitch (cthdr->cmd_rsp_code) {\n\n\tcase CT_RSP_ACCEPT:\n\n\t\tport->stats.ns_gidft_accepts++;\n\t\tn_pids = (fc_get_ctresp_pyld_len(rsp_len) / sizeof(u32));\n\t\tbfa_trc(port->fcs, n_pids);\n\t\tbfa_fcs_lport_ns_process_gidft_pids(port,\n\t\t\t\t\t\t   (u32 *) (cthdr + 1),\n\t\t\t\t\t\t   n_pids);\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t\tbreak;\n\n\tcase CT_RSP_REJECT:\n\n\t\t \n\t\tport->stats.ns_gidft_rejects++;\n\t\tbfa_trc(port->fcs, cthdr->reason_code);\n\t\tbfa_trc(port->fcs, cthdr->exp_code);\n\n\t\tif ((cthdr->reason_code == CT_RSN_UNABLE_TO_PERF)\n\t\t    && (cthdr->exp_code == CT_NS_EXP_FT_NOT_REG)) {\n\n\t\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_OK);\n\t\t} else {\n\t\t\t \n\t\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tport->stats.ns_gidft_unknown_rsp++;\n\t\tbfa_trc(port->fcs, cthdr->cmd_rsp_code);\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_RSP_ERROR);\n\t}\n}\n\n \nstatic void\nbfa_fcs_lport_ns_timeout(void *arg)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = (struct bfa_fcs_lport_ns_s *) arg;\n\n\tns->port->stats.ns_timeouts++;\n\tbfa_sm_send_event(ns, NSSM_EVENT_TIMEOUT);\n}\n\n \nstatic void\nbfa_fcs_lport_ns_process_gidft_pids(struct bfa_fcs_lport_s *port, u32 *pid_buf,\n\t\t\t\t   u32 n_pids)\n{\n\tstruct fcgs_gidft_resp_s *gidft_entry;\n\tstruct bfa_fcs_rport_s *rport;\n\tu32        ii;\n\tstruct bfa_fcs_fabric_s *fabric = port->fabric;\n\tstruct bfa_fcs_vport_s *vport;\n\tstruct list_head *qe;\n\tu8 found = 0;\n\n\tfor (ii = 0; ii < n_pids; ii++) {\n\t\tgidft_entry = (struct fcgs_gidft_resp_s *) &pid_buf[ii];\n\n\t\tif (gidft_entry->pid == port->pid)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (gidft_entry->pid == fabric->bport.pid)\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each(qe, &fabric->vport_q) {\n\t\t\tvport = (struct bfa_fcs_vport_s *) qe;\n\t\t\tif (vport->lport.pid == gidft_entry->pid)\n\t\t\t\tfound = 1;\n\t\t}\n\n\t\tif (found) {\n\t\t\tfound = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\trport = bfa_fcs_lport_get_rport_by_pid(port, gidft_entry->pid);\n\t\tif (rport == NULL) {\n\t\t\t \n\t\t\trport = bfa_fcs_rport_create(port, gidft_entry->pid);\n\t\t} else {\n\t\t\t \n\t\t\tbfa_fcs_rport_scn(rport);\n\t\t}\n\n\t\tbfa_trc(port->fcs, gidft_entry->pid);\n\n\t\t \n\t\tif (gidft_entry->last)\n\t\t\treturn;\n\t}\n}\n\n \n\n \nvoid\nbfa_fcs_lport_ns_init(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = BFA_FCS_GET_NS_FROM_PORT(port);\n\n\tns->port = port;\n\tbfa_sm_set_state(ns, bfa_fcs_lport_ns_sm_offline);\n}\n\nvoid\nbfa_fcs_lport_ns_offline(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = BFA_FCS_GET_NS_FROM_PORT(port);\n\n\tns->port = port;\n\tbfa_sm_send_event(ns, NSSM_EVENT_PORT_OFFLINE);\n}\n\nvoid\nbfa_fcs_lport_ns_online(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = BFA_FCS_GET_NS_FROM_PORT(port);\n\n\tns->port = port;\n\tbfa_sm_send_event(ns, NSSM_EVENT_PORT_ONLINE);\n}\n\nvoid\nbfa_fcs_lport_ns_query(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = BFA_FCS_GET_NS_FROM_PORT(port);\n\n\tbfa_trc(port->fcs, port->pid);\n\tif (bfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_online))\n\t\tbfa_sm_send_event(ns, NSSM_EVENT_NS_QUERY);\n}\n\nstatic void\nbfa_fcs_lport_ns_boot_target_disc(bfa_fcs_lport_t *port)\n{\n\n\tstruct bfa_fcs_rport_s *rport;\n\tu8 nwwns;\n\twwn_t  wwns[BFA_PREBOOT_BOOTLUN_MAX];\n\tint ii;\n\n\tbfa_iocfc_get_bootwwns(port->fcs->bfa, &nwwns, wwns);\n\n\tfor (ii = 0 ; ii < nwwns; ++ii) {\n\t\trport = bfa_fcs_rport_create_by_wwn(port, wwns[ii]);\n\t\tWARN_ON(!rport);\n\t}\n}\n\nvoid\nbfa_fcs_lport_ns_util_send_rspn_id(void *cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_ns_s *ns = cbarg;\n\tstruct bfa_fcs_lport_s *port = ns->port;\n\tstruct fchs_s fchs;\n\tstruct bfa_fcxp_s *fcxp;\n\tu8 symbl[256];\n\tint len;\n\n\t \n\tif (bfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_offline) ||\n\t    bfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_plogi_sending) ||\n\t    bfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_plogi) ||\n\t    bfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_plogi_retry) ||\n\t    bfa_sm_cmp_state(ns, bfa_fcs_lport_ns_sm_rspn_id_retry))\n\t\treturn;\n\n\tmemset(symbl, 0, sizeof(symbl));\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\n\tif (!fcxp) {\n\t\tport->stats.ns_rspnid_alloc_wait++;\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &ns->fcxp_wqe,\n\t\t\tbfa_fcs_lport_ns_util_send_rspn_id, ns, BFA_FALSE);\n\t\treturn;\n\t}\n\n\tns->fcxp = fcxp;\n\n\tif (port->vport) {\n\t\t \n\t\tstrscpy(symbl, (char *)&(bfa_fcs_lport_get_psym_name\n\t\t\t(bfa_fcs_get_base_port(port->fcs))),\n\t\t\tsizeof(symbl));\n\n\t\tstrlcat(symbl,\n\t\t\t(char *)&(bfa_fcs_lport_get_psym_name(port)),\n\t\t\tsizeof(symbl));\n\t}\n\n\tlen = fc_rspnid_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t      bfa_fcs_lport_get_fcid(port), 0, symbl);\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t      FC_CLASS_3, len, &fchs, NULL, NULL, FC_MAX_PDUSZ, 0);\n\n\tport->stats.ns_rspnid_sent++;\n}\n\n \n\n#define FC_QOS_RSCN_EVENT\t\t0x0c\n#define FC_FABRIC_NAME_RSCN_EVENT\t0x0d\n\n \nstatic void     bfa_fcs_lport_scn_send_scr(void *scn_cbarg,\n\t\t\t\t\t  struct bfa_fcxp_s *fcxp_alloced);\nstatic void     bfa_fcs_lport_scn_scr_response(void *fcsarg,\n\t\t\t\t\t      struct bfa_fcxp_s *fcxp,\n\t\t\t\t\t      void *cbarg,\n\t\t\t\t\t      bfa_status_t req_status,\n\t\t\t\t\t      u32 rsp_len,\n\t\t\t\t\t      u32 resid_len,\n\t\t\t\t\t      struct fchs_s *rsp_fchs);\nstatic void     bfa_fcs_lport_scn_send_ls_acc(struct bfa_fcs_lport_s *port,\n\t\t\t\t\t     struct fchs_s *rx_fchs);\nstatic void     bfa_fcs_lport_scn_timeout(void *arg);\n\n \n\n \nenum port_scn_event {\n\tSCNSM_EVENT_PORT_ONLINE = 1,\n\tSCNSM_EVENT_PORT_OFFLINE = 2,\n\tSCNSM_EVENT_RSP_OK = 3,\n\tSCNSM_EVENT_RSP_ERROR = 4,\n\tSCNSM_EVENT_TIMEOUT = 5,\n\tSCNSM_EVENT_SCR_SENT = 6,\n};\n\nstatic void     bfa_fcs_lport_scn_sm_offline(struct bfa_fcs_lport_scn_s *scn,\n\t\t\t\t\t    enum port_scn_event event);\nstatic void     bfa_fcs_lport_scn_sm_sending_scr(\n\t\t\t\t\tstruct bfa_fcs_lport_scn_s *scn,\n\t\t\t\t\tenum port_scn_event event);\nstatic void     bfa_fcs_lport_scn_sm_scr(struct bfa_fcs_lport_scn_s *scn,\n\t\t\t\t\tenum port_scn_event event);\nstatic void     bfa_fcs_lport_scn_sm_scr_retry(struct bfa_fcs_lport_scn_s *scn,\n\t\t\t\t\t      enum port_scn_event event);\nstatic void     bfa_fcs_lport_scn_sm_online(struct bfa_fcs_lport_scn_s *scn,\n\t\t\t\t\t   enum port_scn_event event);\n\n \nstatic void\nbfa_fcs_lport_scn_sm_offline(struct bfa_fcs_lport_scn_s *scn,\n\t\t\tenum port_scn_event event)\n{\n\tswitch (event) {\n\tcase SCNSM_EVENT_PORT_ONLINE:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_sending_scr);\n\t\tbfa_fcs_lport_scn_send_scr(scn, NULL);\n\t\tbreak;\n\n\tcase SCNSM_EVENT_PORT_OFFLINE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(scn->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_scn_sm_sending_scr(struct bfa_fcs_lport_scn_s *scn,\n\t\t\t\tenum port_scn_event event)\n{\n\tswitch (event) {\n\tcase SCNSM_EVENT_SCR_SENT:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_scr);\n\t\tbreak;\n\n\tcase SCNSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\n\t\tbfa_fcxp_walloc_cancel(scn->port->fcs->bfa, &scn->fcxp_wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(scn->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_scn_sm_scr(struct bfa_fcs_lport_scn_s *scn,\n\t\t\tenum port_scn_event event)\n{\n\tstruct bfa_fcs_lport_s *port = scn->port;\n\n\tswitch (event) {\n\tcase SCNSM_EVENT_RSP_OK:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_online);\n\t\tbreak;\n\n\tcase SCNSM_EVENT_RSP_ERROR:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_scr_retry);\n\t\tbfa_timer_start(port->fcs->bfa, &scn->timer,\n\t\t\t\t    bfa_fcs_lport_scn_timeout, scn,\n\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\tbreak;\n\n\tcase SCNSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\n\t\tbfa_fcxp_discard(scn->fcxp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_scn_sm_scr_retry(struct bfa_fcs_lport_scn_s *scn,\n\t\t\t\tenum port_scn_event event)\n{\n\tswitch (event) {\n\tcase SCNSM_EVENT_TIMEOUT:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_sending_scr);\n\t\tbfa_fcs_lport_scn_send_scr(scn, NULL);\n\t\tbreak;\n\n\tcase SCNSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\n\t\tbfa_timer_stop(&scn->timer);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(scn->port->fcs, event);\n\t}\n}\n\nstatic void\nbfa_fcs_lport_scn_sm_online(struct bfa_fcs_lport_scn_s *scn,\n\t\t\tenum port_scn_event event)\n{\n\tswitch (event) {\n\tcase SCNSM_EVENT_PORT_OFFLINE:\n\t\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(scn->port->fcs, event);\n\t}\n}\n\n\n\n \n\n \nstatic void\nbfa_fcs_lport_scn_send_scr(void *scn_cbarg, struct bfa_fcxp_s *fcxp_alloced)\n{\n\tstruct bfa_fcs_lport_scn_s *scn = scn_cbarg;\n\tstruct bfa_fcs_lport_s *port = scn->port;\n\tstruct fchs_s fchs;\n\tint             len;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tbfa_trc(port->fcs, port->pid);\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\tfcxp = fcxp_alloced ? fcxp_alloced :\n\t       bfa_fcs_fcxp_alloc(port->fcs, BFA_TRUE);\n\tif (!fcxp) {\n\t\tbfa_fcs_fcxp_alloc_wait(port->fcs->bfa, &scn->fcxp_wqe,\n\t\t\t\tbfa_fcs_lport_scn_send_scr, scn, BFA_TRUE);\n\t\treturn;\n\t}\n\tscn->fcxp = fcxp;\n\n\t \n\tif ((!port->vport) && bfa_ioc_get_fcmode(&port->fcs->bfa->ioc)) {\n\t\tlen = fc_scr_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t\tport->fabric->lps->brcd_switch,\n\t\t\t\tport->pid, 0);\n\t} else {\n\t    len = fc_scr_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t\t    BFA_FALSE,\n\t\t\t\t    port->pid, 0);\n\t}\n\n\tbfa_fcxp_send(fcxp, NULL, port->fabric->vf_id, port->lp_tag, BFA_FALSE,\n\t\t\t  FC_CLASS_3, len, &fchs,\n\t\t\t  bfa_fcs_lport_scn_scr_response,\n\t\t\t  (void *)scn, FC_MAX_PDUSZ, FC_ELS_TOV);\n\n\tbfa_sm_send_event(scn, SCNSM_EVENT_SCR_SENT);\n}\n\nstatic void\nbfa_fcs_lport_scn_scr_response(void *fcsarg, struct bfa_fcxp_s *fcxp,\n\t\t\tvoid *cbarg, bfa_status_t req_status, u32 rsp_len,\n\t\t\t      u32 resid_len, struct fchs_s *rsp_fchs)\n{\n\tstruct bfa_fcs_lport_scn_s *scn = (struct bfa_fcs_lport_scn_s *) cbarg;\n\tstruct bfa_fcs_lport_s *port = scn->port;\n\tstruct fc_els_cmd_s *els_cmd;\n\tstruct fc_ls_rjt_s *ls_rjt;\n\n\tbfa_trc(port->fcs, port->port_cfg.pwwn);\n\n\t \n\tif (req_status != BFA_STATUS_OK) {\n\t\tbfa_trc(port->fcs, req_status);\n\t\tbfa_sm_send_event(scn, SCNSM_EVENT_RSP_ERROR);\n\t\treturn;\n\t}\n\n\tels_cmd = (struct fc_els_cmd_s *) BFA_FCXP_RSP_PLD(fcxp);\n\n\tswitch (els_cmd->els_code) {\n\n\tcase FC_ELS_ACC:\n\t\tbfa_sm_send_event(scn, SCNSM_EVENT_RSP_OK);\n\t\tbreak;\n\n\tcase FC_ELS_LS_RJT:\n\n\t\tls_rjt = (struct fc_ls_rjt_s *) BFA_FCXP_RSP_PLD(fcxp);\n\n\t\tbfa_trc(port->fcs, ls_rjt->reason_code);\n\t\tbfa_trc(port->fcs, ls_rjt->reason_code_expl);\n\n\t\tbfa_sm_send_event(scn, SCNSM_EVENT_RSP_ERROR);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_send_event(scn, SCNSM_EVENT_RSP_ERROR);\n\t}\n}\n\n \nstatic void\nbfa_fcs_lport_scn_send_ls_acc(struct bfa_fcs_lport_s *port,\n\t\t\t\tstruct fchs_s *rx_fchs)\n{\n\tstruct fchs_s fchs;\n\tstruct bfa_fcxp_s *fcxp;\n\tstruct bfa_rport_s *bfa_rport = NULL;\n\tint             len;\n\n\tbfa_trc(port->fcs, rx_fchs->s_id);\n\n\tfcxp = bfa_fcs_fcxp_alloc(port->fcs, BFA_FALSE);\n\tif (!fcxp)\n\t\treturn;\n\n\tlen = fc_ls_acc_build(&fchs, bfa_fcxp_get_reqbuf(fcxp),\n\t\t\t      rx_fchs->s_id, bfa_fcs_lport_get_fcid(port),\n\t\t\t      rx_fchs->ox_id);\n\n\tbfa_fcxp_send(fcxp, bfa_rport, port->fabric->vf_id, port->lp_tag,\n\t\t\t  BFA_FALSE, FC_CLASS_3, len, &fchs, NULL, NULL,\n\t\t\t  FC_MAX_PDUSZ, 0);\n}\n\n \nstatic void\nbfa_fcs_lport_scn_timeout(void *arg)\n{\n\tstruct bfa_fcs_lport_scn_s *scn = (struct bfa_fcs_lport_scn_s *) arg;\n\n\tbfa_sm_send_event(scn, SCNSM_EVENT_TIMEOUT);\n}\n\n\n\n \n\n \nvoid\nbfa_fcs_lport_scn_init(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_scn_s *scn = BFA_FCS_GET_SCN_FROM_PORT(port);\n\n\tscn->port = port;\n\tbfa_sm_set_state(scn, bfa_fcs_lport_scn_sm_offline);\n}\n\nvoid\nbfa_fcs_lport_scn_offline(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_scn_s *scn = BFA_FCS_GET_SCN_FROM_PORT(port);\n\n\tscn->port = port;\n\tbfa_sm_send_event(scn, SCNSM_EVENT_PORT_OFFLINE);\n}\n\nvoid\nbfa_fcs_lport_fab_scn_online(struct bfa_fcs_lport_s *port)\n{\n\tstruct bfa_fcs_lport_scn_s *scn = BFA_FCS_GET_SCN_FROM_PORT(port);\n\n\tscn->port = port;\n\tbfa_sm_send_event(scn, SCNSM_EVENT_PORT_ONLINE);\n}\n\nstatic void\nbfa_fcs_lport_scn_portid_rscn(struct bfa_fcs_lport_s *port, u32 rpid)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct bfa_fcs_fabric_s *fabric = port->fabric;\n\tstruct bfa_fcs_vport_s *vport;\n\tstruct list_head *qe;\n\n\tbfa_trc(port->fcs, rpid);\n\n\t \n\tif (rpid == fabric->bport.pid)\n\t\treturn;\n\n\tlist_for_each(qe, &fabric->vport_q) {\n\t\tvport = (struct bfa_fcs_vport_s *) qe;\n\t\tif (vport->lport.pid == rpid)\n\t\t\treturn;\n\t}\n\t \n\trport = bfa_fcs_lport_get_rport_by_pid(port, rpid);\n\tif (!rport)\n\t\trport = bfa_fcs_lport_get_rport_by_old_pid(port, rpid);\n\n\tif (rport == NULL) {\n\t\t \n\t\tif (!__fcs_min_cfg(port->fcs))\n\t\t\trport = bfa_fcs_rport_create(port, rpid);\n\t} else\n\t\tbfa_fcs_rport_scn(rport);\n}\n\n \n#define __fc_pid_match(__c0, __c1, __fmt)\t\t\\\n\t(((__fmt) == FC_RSCN_FORMAT_FABRIC) ||\t\t\\\n\t (((__fmt) == FC_RSCN_FORMAT_DOMAIN) &&\t\t\\\n\t  ((__c0)[0] == (__c1)[0])) ||\t\t\t\t\\\n\t (((__fmt) == FC_RSCN_FORMAT_AREA) &&\t\t\\\n\t  ((__c0)[0] == (__c1)[0]) &&\t\t\t\t\\\n\t  ((__c0)[1] == (__c1)[1])))\n\nstatic void\nbfa_fcs_lport_scn_multiport_rscn(struct bfa_fcs_lport_s *port,\n\t\t\t\tenum fc_rscn_format format,\n\t\t\t\tu32 rscn_pid)\n{\n\tstruct bfa_fcs_rport_s *rport;\n\tstruct list_head        *qe, *qe_next;\n\tu8        *c0, *c1;\n\n\tbfa_trc(port->fcs, format);\n\tbfa_trc(port->fcs, rscn_pid);\n\n\tc0 = (u8 *) &rscn_pid;\n\n\tlist_for_each_safe(qe, qe_next, &port->rport_q) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tc1 = (u8 *) &rport->pid;\n\t\tif (__fc_pid_match(c0, c1, format))\n\t\t\tbfa_fcs_rport_scn(rport);\n\t}\n}\n\n\nvoid\nbfa_fcs_lport_scn_process_rscn(struct bfa_fcs_lport_s *port,\n\t\t\tstruct fchs_s *fchs, u32 len)\n{\n\tstruct fc_rscn_pl_s *rscn = (struct fc_rscn_pl_s *) (fchs + 1);\n\tint             num_entries;\n\tu32        rscn_pid;\n\tbfa_boolean_t   nsquery = BFA_FALSE, found;\n\tint             i = 0, j;\n\n\tnum_entries =\n\t\t(be16_to_cpu(rscn->payldlen) -\n\t\t sizeof(u32)) / sizeof(rscn->event[0]);\n\n\tbfa_trc(port->fcs, num_entries);\n\n\tport->stats.num_rscn++;\n\n\tbfa_fcs_lport_scn_send_ls_acc(port, fchs);\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\trscn_pid = rscn->event[i].portid;\n\n\t\tbfa_trc(port->fcs, rscn->event[i].format);\n\t\tbfa_trc(port->fcs, rscn_pid);\n\n\t\t \n\t\tfound = BFA_FALSE;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (rscn->event[j].portid == rscn_pid) {\n\t\t\t\tfound = BFA_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (found) {\n\t\t\tbfa_trc(port->fcs, rscn_pid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (rscn->event[i].format) {\n\t\tcase FC_RSCN_FORMAT_PORTID:\n\t\t\tif (rscn->event[i].qualifier == FC_QOS_RSCN_EVENT) {\n\t\t\t\t \n\t\t\t\tbfa_trc(port->fcs, rscn_pid);\n\t\t\t} else {\n\t\t\t\tport->stats.num_portid_rscn++;\n\t\t\t\tbfa_fcs_lport_scn_portid_rscn(port, rscn_pid);\n\t\t\t}\n\t\tbreak;\n\n\t\tcase FC_RSCN_FORMAT_FABRIC:\n\t\t\tif (rscn->event[i].qualifier ==\n\t\t\t\t\tFC_FABRIC_NAME_RSCN_EVENT) {\n\t\t\t\tbfa_fcs_lport_ms_fabric_rscn(port);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\n\t\tcase FC_RSCN_FORMAT_AREA:\n\t\tcase FC_RSCN_FORMAT_DOMAIN:\n\t\t\tnsquery = BFA_TRUE;\n\t\t\tbfa_fcs_lport_scn_multiport_rscn(port,\n\t\t\t\t\t\t\trscn->event[i].format,\n\t\t\t\t\t\t\trscn_pid);\n\t\t\tbreak;\n\n\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tnsquery = BFA_TRUE;\n\t\t}\n\t}\n\n\t \n\tif (nsquery)\n\t\tbfa_fcs_lport_ns_query(port);\n}\n\n \n \nstruct bfa_fcs_lport_s *\nbfa_fcs_get_base_port(struct bfa_fcs_s *fcs)\n{\n\treturn &fcs->fabric.bport;\n}\n\nwwn_t\nbfa_fcs_lport_get_rport(struct bfa_fcs_lport_s *port, wwn_t wwn, int index,\n\t\tint nrports, bfa_boolean_t bwwn)\n{\n\tstruct list_head\t*qh, *qe;\n\tstruct bfa_fcs_rport_s *rport = NULL;\n\tint\ti;\n\tstruct bfa_fcs_s\t*fcs;\n\n\tif (port == NULL || nrports == 0)\n\t\treturn (wwn_t) 0;\n\n\tfcs = port->fcs;\n\tbfa_trc(fcs, (u32) nrports);\n\n\ti = 0;\n\tqh = &port->rport_q;\n\tqe = bfa_q_first(qh);\n\n\twhile ((qe != qh) && (i < nrports)) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tif (bfa_ntoh3b(rport->pid) > 0xFFF000) {\n\t\t\tqe = bfa_q_next(qe);\n\t\t\tbfa_trc(fcs, (u32) rport->pwwn);\n\t\t\tbfa_trc(fcs, rport->pid);\n\t\t\tbfa_trc(fcs, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (bwwn) {\n\t\t\tif (!memcmp(&wwn, &rport->pwwn, 8))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (i == index)\n\t\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t\tqe = bfa_q_next(qe);\n\t}\n\n\tbfa_trc(fcs, i);\n\tif (rport)\n\t\treturn rport->pwwn;\n\telse\n\t\treturn (wwn_t) 0;\n}\n\nvoid\nbfa_fcs_lport_get_rport_quals(struct bfa_fcs_lport_s *port,\n\t\tstruct bfa_rport_qualifier_s rports[], int *nrports)\n{\n\tstruct list_head\t*qh, *qe;\n\tstruct bfa_fcs_rport_s *rport = NULL;\n\tint\ti;\n\tstruct bfa_fcs_s\t*fcs;\n\n\tif (port == NULL || rports == NULL || *nrports == 0)\n\t\treturn;\n\n\tfcs = port->fcs;\n\tbfa_trc(fcs, (u32) *nrports);\n\n\ti = 0;\n\tqh = &port->rport_q;\n\tqe = bfa_q_first(qh);\n\n\twhile ((qe != qh) && (i < *nrports)) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tif (bfa_ntoh3b(rport->pid) > 0xFFF000) {\n\t\t\tqe = bfa_q_next(qe);\n\t\t\tbfa_trc(fcs, (u32) rport->pwwn);\n\t\t\tbfa_trc(fcs, rport->pid);\n\t\t\tbfa_trc(fcs, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rport->pwwn && !rport->pid) {\n\t\t\tqe = bfa_q_next(qe);\n\t\t\tcontinue;\n\t\t}\n\n\t\trports[i].pwwn = rport->pwwn;\n\t\trports[i].pid = rport->pid;\n\n\t\ti++;\n\t\tqe = bfa_q_next(qe);\n\t}\n\n\tbfa_trc(fcs, i);\n\t*nrports = i;\n}\n\n \nbfa_port_speed_t\nbfa_fcs_lport_get_rport_max_speed(bfa_fcs_lport_t *port)\n{\n\tstruct list_head *qh, *qe;\n\tstruct bfa_fcs_rport_s *rport = NULL;\n\tstruct bfa_fcs_s\t*fcs;\n\tbfa_port_speed_t max_speed = 0;\n\tstruct bfa_port_attr_s port_attr;\n\tbfa_port_speed_t port_speed, rport_speed;\n\tbfa_boolean_t trl_enabled;\n\n\tif (port == NULL)\n\t\treturn 0;\n\n\tfcs = port->fcs;\n\ttrl_enabled = bfa_fcport_is_ratelim(port->fcs->bfa);\n\n\t \n\tbfa_fcport_get_attr(port->fcs->bfa, &port_attr);\n\tport_speed = port_attr.speed;\n\tbfa_trc(fcs, port_speed);\n\n\tqh = &port->rport_q;\n\tqe = bfa_q_first(qh);\n\n\twhile (qe != qh) {\n\t\trport = (struct bfa_fcs_rport_s *) qe;\n\t\tif ((bfa_ntoh3b(rport->pid) > 0xFFF000) ||\n\t\t\t(bfa_fcs_rport_get_state(rport) == BFA_RPORT_OFFLINE) ||\n\t\t\t(rport->scsi_function != BFA_RPORT_TARGET)) {\n\t\t\tqe = bfa_q_next(qe);\n\t\t\tcontinue;\n\t\t}\n\n\t\trport_speed = rport->rpf.rpsc_speed;\n\t\tif ((trl_enabled) && (rport_speed ==\n\t\t\tBFA_PORT_SPEED_UNKNOWN)) {\n\t\t\t \n\t\t\trport_speed =\n\t\t\t\tbfa_fcport_get_ratelim_speed(port->fcs->bfa);\n\t\t}\n\n\t\tif (rport_speed > max_speed)\n\t\t\tmax_speed = rport_speed;\n\n\t\tqe = bfa_q_next(qe);\n\t}\n\n\tif (max_speed > port_speed)\n\t\tmax_speed = port_speed;\n\n\tbfa_trc(fcs, max_speed);\n\treturn max_speed;\n}\n\nstruct bfa_fcs_lport_s *\nbfa_fcs_lookup_port(struct bfa_fcs_s *fcs, u16 vf_id, wwn_t lpwwn)\n{\n\tstruct bfa_fcs_vport_s *vport;\n\tbfa_fcs_vf_t   *vf;\n\n\tWARN_ON(fcs == NULL);\n\n\tvf = bfa_fcs_vf_lookup(fcs, vf_id);\n\tif (vf == NULL) {\n\t\tbfa_trc(fcs, vf_id);\n\t\treturn NULL;\n\t}\n\n\tif (!lpwwn || (vf->bport.port_cfg.pwwn == lpwwn))\n\t\treturn &vf->bport;\n\n\tvport = bfa_fcs_fabric_vport_lookup(vf, lpwwn);\n\tif (vport)\n\t\treturn &vport->lport;\n\n\treturn NULL;\n}\n\n \nvoid\nbfa_fcs_lport_get_info(struct bfa_fcs_lport_s *port,\n\t struct bfa_lport_info_s *port_info)\n{\n\n\tbfa_trc(port->fcs, port->fabric->fabric_name);\n\n\tif (port->vport == NULL) {\n\t\t \n\t\tport_info->port_type = BFA_LPORT_TYPE_PHYSICAL;\n\n\t\t \n\t\tport_info->port_state = 0;\n\t\tport_info->offline_reason = 0;\n\n\t\tport_info->port_wwn = bfa_fcs_lport_get_pwwn(port);\n\t\tport_info->node_wwn = bfa_fcs_lport_get_nwwn(port);\n\n\t\tport_info->max_vports_supp =\n\t\t\tbfa_lps_get_max_vport(port->fcs->bfa);\n\t\tport_info->num_vports_inuse =\n\t\t\tport->fabric->num_vports;\n\t\tport_info->max_rports_supp = BFA_FCS_MAX_RPORTS_SUPP;\n\t\tport_info->num_rports_inuse = port->num_rports;\n\t} else {\n\t\t \n\t\tport_info->port_type = BFA_LPORT_TYPE_VIRTUAL;\n\n\t\t \n\t\tport_info->port_state = 0;\n\t\tport_info->offline_reason = 0;\n\n\t\tport_info->port_wwn = bfa_fcs_lport_get_pwwn(port);\n\t\tport_info->node_wwn = bfa_fcs_lport_get_nwwn(port);\n\t}\n}\n\nvoid\nbfa_fcs_lport_get_stats(struct bfa_fcs_lport_s *fcs_port,\n\t struct bfa_lport_stats_s *port_stats)\n{\n\t*port_stats = fcs_port->stats;\n}\n\nvoid\nbfa_fcs_lport_clear_stats(struct bfa_fcs_lport_s *fcs_port)\n{\n\tmemset(&fcs_port->stats, 0, sizeof(struct bfa_lport_stats_s));\n}\n\n \nvoid\nbfa_fcs_lport_lip_scn_online(struct bfa_fcs_lport_s *port)\n{\n\tbfa_fcs_lport_loop_online(port);\n}\n\n \n\n#define __vport_fcs(__vp)       ((__vp)->lport.fcs)\n#define __vport_pwwn(__vp)      ((__vp)->lport.port_cfg.pwwn)\n#define __vport_nwwn(__vp)      ((__vp)->lport.port_cfg.nwwn)\n#define __vport_bfa(__vp)       ((__vp)->lport.fcs->bfa)\n#define __vport_fcid(__vp)      ((__vp)->lport.pid)\n#define __vport_fabric(__vp)    ((__vp)->lport.fabric)\n#define __vport_vfid(__vp)      ((__vp)->lport.fabric->vf_id)\n\n#define BFA_FCS_VPORT_MAX_RETRIES  5\n \nstatic void     bfa_fcs_vport_do_fdisc(struct bfa_fcs_vport_s *vport);\nstatic void     bfa_fcs_vport_timeout(void *vport_arg);\nstatic void     bfa_fcs_vport_do_logo(struct bfa_fcs_vport_s *vport);\nstatic void     bfa_fcs_vport_free(struct bfa_fcs_vport_s *vport);\n\n \n\n \nenum bfa_fcs_vport_event {\n\tBFA_FCS_VPORT_SM_CREATE = 1,\t \n\tBFA_FCS_VPORT_SM_DELETE = 2,\t \n\tBFA_FCS_VPORT_SM_START = 3,\t \n\tBFA_FCS_VPORT_SM_STOP = 4,\t \n\tBFA_FCS_VPORT_SM_ONLINE = 5,\t \n\tBFA_FCS_VPORT_SM_OFFLINE = 6,\t \n\tBFA_FCS_VPORT_SM_FRMSENT = 7,\t \n\tBFA_FCS_VPORT_SM_RSP_OK = 8,\t \n\tBFA_FCS_VPORT_SM_RSP_ERROR = 9,\t \n\tBFA_FCS_VPORT_SM_TIMEOUT = 10,\t \n\tBFA_FCS_VPORT_SM_DELCOMP = 11,\t \n\tBFA_FCS_VPORT_SM_RSP_DUP_WWN = 12,\t \n\tBFA_FCS_VPORT_SM_RSP_FAILED = 13,\t \n\tBFA_FCS_VPORT_SM_STOPCOMP = 14,\t \n\tBFA_FCS_VPORT_SM_FABRIC_MAX = 15,  \n};\n\nstatic void     bfa_fcs_vport_sm_uninit(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\tenum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_created(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\t enum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_offline(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\t enum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_fdisc(struct bfa_fcs_vport_s *vport,\n\t\t\t\t       enum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_fdisc_retry(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\t     enum bfa_fcs_vport_event event);\nstatic void\tbfa_fcs_vport_sm_fdisc_rsp_wait(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\tenum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_online(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\tenum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_deleting(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\t  enum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_cleanup(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\t enum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_logo(struct bfa_fcs_vport_s *vport,\n\t\t\t\t      enum bfa_fcs_vport_event event);\nstatic void     bfa_fcs_vport_sm_error(struct bfa_fcs_vport_s *vport,\n\t\t\t\t      enum bfa_fcs_vport_event event);\nstatic void\tbfa_fcs_vport_sm_stopping(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\tenum bfa_fcs_vport_event event);\nstatic void\tbfa_fcs_vport_sm_logo_for_stop(struct bfa_fcs_vport_s *vport,\n\t\t\t\t\tenum bfa_fcs_vport_event event);\n\nstatic struct bfa_sm_table_s  vport_sm_table[] = {\n\t{BFA_SM(bfa_fcs_vport_sm_uninit), BFA_FCS_VPORT_UNINIT},\n\t{BFA_SM(bfa_fcs_vport_sm_created), BFA_FCS_VPORT_CREATED},\n\t{BFA_SM(bfa_fcs_vport_sm_offline), BFA_FCS_VPORT_OFFLINE},\n\t{BFA_SM(bfa_fcs_vport_sm_fdisc), BFA_FCS_VPORT_FDISC},\n\t{BFA_SM(bfa_fcs_vport_sm_fdisc_retry), BFA_FCS_VPORT_FDISC_RETRY},\n\t{BFA_SM(bfa_fcs_vport_sm_fdisc_rsp_wait), BFA_FCS_VPORT_FDISC_RSP_WAIT},\n\t{BFA_SM(bfa_fcs_vport_sm_online), BFA_FCS_VPORT_ONLINE},\n\t{BFA_SM(bfa_fcs_vport_sm_deleting), BFA_FCS_VPORT_DELETING},\n\t{BFA_SM(bfa_fcs_vport_sm_cleanup), BFA_FCS_VPORT_CLEANUP},\n\t{BFA_SM(bfa_fcs_vport_sm_logo), BFA_FCS_VPORT_LOGO},\n\t{BFA_SM(bfa_fcs_vport_sm_error), BFA_FCS_VPORT_ERROR}\n};\n\n \nstatic void\nbfa_fcs_vport_sm_uninit(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_CREATE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_created);\n\t\tbfa_fcs_fabric_addvport(__vport_fabric(vport), vport);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_created(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_START:\n\t\tif (bfa_sm_cmp_state(__vport_fabric(vport),\n\t\t\t\t\tbfa_fcs_fabric_sm_online)\n\t\t    && bfa_fcs_fabric_npiv_capable(__vport_fabric(vport))) {\n\t\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc);\n\t\t\tbfa_fcs_vport_do_fdisc(vport);\n\t\t} else {\n\t\t\t \n\t\t\tvport->vport_stats.fab_no_npiv++;\n\t\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\n\t\tbfa_fcs_lport_delete(&vport->lport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_ONLINE:\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_offline(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\n\t\tbfa_fcs_lport_delete(&vport->lport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_ONLINE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc);\n\t\tvport->fdisc_retries = 0;\n\t\tbfa_fcs_vport_do_fdisc(vport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_STOP:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\n\t\tbfa_sm_send_event(&vport->lport, BFA_FCS_PORT_SM_STOP);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n\n \nstatic void\nbfa_fcs_vport_sm_fdisc(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc_rsp_wait);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\n\t\tbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_RSP_OK:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_online);\n\t\tbfa_fcs_lport_online(&vport->lport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_RSP_ERROR:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc_retry);\n\t\tbfa_timer_start(__vport_bfa(vport), &vport->timer,\n\t\t\t\t    bfa_fcs_vport_timeout, vport,\n\t\t\t\t    BFA_FCS_RETRY_TIMEOUT);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_RSP_FAILED:\n\tcase BFA_FCS_VPORT_SM_FABRIC_MAX:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_RSP_DUP_WWN:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_error);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_fdisc_retry(struct bfa_fcs_vport_s *vport,\n\t\t\t     enum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\n\t\tbfa_timer_stop(&vport->timer);\n\t\tbfa_fcs_lport_delete(&vport->lport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\n\t\tbfa_timer_stop(&vport->timer);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_TIMEOUT:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_fdisc);\n\t\tvport->vport_stats.fdisc_retries++;\n\t\tvport->fdisc_retries++;\n\t\tbfa_fcs_vport_do_fdisc(vport);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_fdisc_rsp_wait(struct bfa_fcs_vport_s *vport,\n\t\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_RSP_OK:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_deleting);\n\t\tbfa_fcs_lport_delete(&vport->lport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\tcase BFA_FCS_VPORT_SM_RSP_ERROR:\n\tcase BFA_FCS_VPORT_SM_RSP_FAILED:\n\tcase BFA_FCS_VPORT_SM_FABRIC_MAX:\n\tcase BFA_FCS_VPORT_SM_RSP_DUP_WWN:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\n\t\tbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\n\t\tbfa_fcs_lport_delete(&vport->lport);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_online(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_deleting);\n\t\tbfa_fcs_lport_delete(&vport->lport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_STOP:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_stopping);\n\t\tbfa_sm_send_event(&vport->lport, BFA_FCS_PORT_SM_STOP);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_offline);\n\t\tbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\n\t\tbfa_fcs_lport_offline(&vport->lport);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_stopping(struct bfa_fcs_vport_s *vport,\n\t\t\t  enum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_STOPCOMP:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_logo_for_stop);\n\t\tbfa_fcs_vport_do_logo(vport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_deleting(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_DELCOMP:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_logo);\n\t\tbfa_fcs_vport_do_logo(vport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_error(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_cleanup);\n\t\tbfa_fcs_lport_delete(&vport->lport);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_trc(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_cleanup(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_DELCOMP:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_uninit);\n\t\tbfa_fcs_vport_free(vport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_STOPCOMP:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_created);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_logo_for_stop(struct bfa_fcs_vport_s *vport,\n\t\t\t       enum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\tbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\n\t\tfallthrough;\n\n\tcase BFA_FCS_VPORT_SM_RSP_OK:\n\tcase BFA_FCS_VPORT_SM_RSP_ERROR:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_created);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_sm_logo(struct bfa_fcs_vport_s *vport,\n\t\t\tenum bfa_fcs_vport_event event)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), event);\n\n\tswitch (event) {\n\tcase BFA_FCS_VPORT_SM_OFFLINE:\n\t\tbfa_sm_send_event(vport->lps, BFA_LPS_SM_OFFLINE);\n\t\tfallthrough;\n\n\tcase BFA_FCS_VPORT_SM_RSP_OK:\n\tcase BFA_FCS_VPORT_SM_RSP_ERROR:\n\t\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_uninit);\n\t\tbfa_fcs_vport_free(vport);\n\t\tbreak;\n\n\tcase BFA_FCS_VPORT_SM_DELETE:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(__vport_fcs(vport), event);\n\t}\n}\n\n\n\n \n \nstatic void\nbfa_fcs_vport_aen_post(struct bfa_fcs_lport_s *port,\n\t\t       enum bfa_lport_aen_event event)\n{\n\tstruct bfad_s *bfad = (struct bfad_s *)port->fabric->fcs->bfad;\n\tstruct bfa_aen_entry_s  *aen_entry;\n\n\tbfad_get_aen_entry(bfad, aen_entry);\n\tif (!aen_entry)\n\t\treturn;\n\n\taen_entry->aen_data.lport.vf_id = port->fabric->vf_id;\n\taen_entry->aen_data.lport.roles = port->port_cfg.roles;\n\taen_entry->aen_data.lport.ppwwn = bfa_fcs_lport_get_pwwn(\n\t\t\t\t\tbfa_fcs_get_base_port(port->fcs));\n\taen_entry->aen_data.lport.lpwwn = bfa_fcs_lport_get_pwwn(port);\n\n\t \n\tbfad_im_post_vendor_event(aen_entry, bfad, ++port->fcs->fcs_aen_seq,\n\t\t\t\t  BFA_AEN_CAT_LPORT, event);\n}\n\n \nstatic void\nbfa_fcs_vport_do_fdisc(struct bfa_fcs_vport_s *vport)\n{\n\tbfa_lps_fdisc(vport->lps, vport,\n\t\tbfa_fcport_get_maxfrsize(__vport_bfa(vport)),\n\t\t__vport_pwwn(vport), __vport_nwwn(vport));\n\tvport->vport_stats.fdisc_sent++;\n}\n\nstatic void\nbfa_fcs_vport_fdisc_rejected(struct bfa_fcs_vport_s *vport)\n{\n\tu8\t\tlsrjt_rsn = vport->lps->lsrjt_rsn;\n\tu8\t\tlsrjt_expl = vport->lps->lsrjt_expl;\n\n\tbfa_trc(__vport_fcs(vport), lsrjt_rsn);\n\tbfa_trc(__vport_fcs(vport), lsrjt_expl);\n\n\t \n\tswitch (vport->lps->lsrjt_expl) {\n\tcase FC_LS_RJT_EXP_INV_PORT_NAME:  \n\tcase FC_LS_RJT_EXP_INVALID_NPORT_ID:  \n\t\tif (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)\n\t\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\n\t\telse {\n\t\t\tbfa_fcs_vport_aen_post(&vport->lport,\n\t\t\t\t\tBFA_LPORT_AEN_NPIV_DUP_WWN);\n\t\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_DUP_WWN);\n\t\t}\n\t\tbreak;\n\n\tcase FC_LS_RJT_EXP_INSUFF_RES:\n\t\t \n\t\tif (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)\n\t\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\n\t\telse {\n\t\t\tbfa_fcs_vport_aen_post(&vport->lport,\n\t\t\t\t\tBFA_LPORT_AEN_NPIV_FABRIC_MAX);\n\t\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_FABRIC_MAX);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (vport->fdisc_retries == 0)\n\t\t\tbfa_fcs_vport_aen_post(&vport->lport,\n\t\t\t\t\tBFA_LPORT_AEN_NPIV_UNKNOWN);\n\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\n\t}\n}\n\n \nstatic void\nbfa_fcs_vport_do_logo(struct bfa_fcs_vport_s *vport)\n{\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\n\tvport->vport_stats.logo_sent++;\n\tbfa_lps_fdisclogo(vport->lps);\n}\n\n\n \nstatic void\nbfa_fcs_vport_timeout(void *vport_arg)\n{\n\tstruct bfa_fcs_vport_s *vport = (struct bfa_fcs_vport_s *) vport_arg;\n\n\tvport->vport_stats.fdisc_timeouts++;\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_TIMEOUT);\n}\n\nstatic void\nbfa_fcs_vport_free(struct bfa_fcs_vport_s *vport)\n{\n\tstruct bfad_vport_s *vport_drv =\n\t\t\t(struct bfad_vport_s *)vport->vport_drv;\n\n\tbfa_fcs_fabric_delvport(__vport_fabric(vport), vport);\n\tbfa_lps_delete(vport->lps);\n\n\tif (vport_drv->comp_del) {\n\t\tcomplete(vport_drv->comp_del);\n\t\treturn;\n\t}\n\n\t \n\tbfad_im_port_delete(vport_drv->drv_port.bfad, &vport_drv->drv_port);\n}\n\n \n\n \nvoid\nbfa_fcs_vport_online(struct bfa_fcs_vport_s *vport)\n{\n\tvport->vport_stats.fab_online++;\n\tif (bfa_fcs_fabric_npiv_capable(__vport_fabric(vport)))\n\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_ONLINE);\n\telse\n\t\tvport->vport_stats.fab_no_npiv++;\n}\n\n \nvoid\nbfa_fcs_vport_offline(struct bfa_fcs_vport_s *vport)\n{\n\tvport->vport_stats.fab_offline++;\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_OFFLINE);\n}\n\n \nvoid\nbfa_fcs_vport_cleanup(struct bfa_fcs_vport_s *vport)\n{\n\tvport->vport_stats.fab_cleanup++;\n}\n\n \nvoid\nbfa_fcs_vport_fcs_stop(struct bfa_fcs_vport_s *vport)\n{\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_STOP);\n}\n\n \nvoid\nbfa_fcs_vport_fcs_delete(struct bfa_fcs_vport_s *vport)\n{\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_DELETE);\n}\n\n \nvoid\nbfa_fcs_vport_stop_comp(struct bfa_fcs_vport_s *vport)\n{\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_STOPCOMP);\n}\n\n \nvoid\nbfa_fcs_vport_delete_comp(struct bfa_fcs_vport_s *vport)\n{\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_DELCOMP);\n}\n\n\n\n \n\n \nbfa_status_t\nbfa_fcs_vport_create(struct bfa_fcs_vport_s *vport, struct bfa_fcs_s *fcs,\n\t\tu16 vf_id, struct bfa_lport_cfg_s *vport_cfg,\n\t\tstruct bfad_vport_s *vport_drv)\n{\n\tif (vport_cfg->pwwn == 0)\n\t\treturn BFA_STATUS_INVALID_WWN;\n\n\tif (bfa_fcs_lport_get_pwwn(&fcs->fabric.bport) == vport_cfg->pwwn)\n\t\treturn BFA_STATUS_VPORT_WWN_BP;\n\n\tif (bfa_fcs_vport_lookup(fcs, vf_id, vport_cfg->pwwn) != NULL)\n\t\treturn BFA_STATUS_VPORT_EXISTS;\n\n\tif (fcs->fabric.num_vports ==\n\t\t\tbfa_lps_get_max_vport(fcs->bfa))\n\t\treturn BFA_STATUS_VPORT_MAX;\n\n\tvport->lps = bfa_lps_alloc(fcs->bfa);\n\tif (!vport->lps)\n\t\treturn BFA_STATUS_VPORT_MAX;\n\n\tvport->vport_drv = vport_drv;\n\tvport_cfg->preboot_vp = BFA_FALSE;\n\n\tbfa_sm_set_state(vport, bfa_fcs_vport_sm_uninit);\n\tbfa_fcs_lport_attach(&vport->lport, fcs, vf_id, vport);\n\tbfa_fcs_lport_init(&vport->lport, vport_cfg);\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_CREATE);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_fcs_pbc_vport_create(struct bfa_fcs_vport_s *vport, struct bfa_fcs_s *fcs,\n\t\t\tu16 vf_id, struct bfa_lport_cfg_s *vport_cfg,\n\t\t\tstruct bfad_vport_s *vport_drv)\n{\n\tbfa_status_t rc;\n\n\trc = bfa_fcs_vport_create(vport, fcs, vf_id, vport_cfg, vport_drv);\n\tvport->lport.port_cfg.preboot_vp = BFA_TRUE;\n\n\treturn rc;\n}\n\n \nbfa_boolean_t\nbfa_fcs_is_pbc_vport(struct bfa_fcs_vport_s *vport)\n{\n\n\tif (vport && (vport->lport.port_cfg.preboot_vp == BFA_TRUE))\n\t\treturn BFA_TRUE;\n\telse\n\t\treturn BFA_FALSE;\n\n}\n\n \nbfa_status_t\nbfa_fcs_vport_start(struct bfa_fcs_vport_s *vport)\n{\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_START);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_fcs_vport_stop(struct bfa_fcs_vport_s *vport)\n{\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_STOP);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_fcs_vport_delete(struct bfa_fcs_vport_s *vport)\n{\n\n\tif (vport->lport.port_cfg.preboot_vp)\n\t\treturn BFA_STATUS_PBC;\n\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_DELETE);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nvoid\nbfa_fcs_vport_get_attr(struct bfa_fcs_vport_s *vport,\n\t\t\tstruct bfa_vport_attr_s *attr)\n{\n\tif (vport == NULL || attr == NULL)\n\t\treturn;\n\n\tmemset(attr, 0, sizeof(struct bfa_vport_attr_s));\n\n\tbfa_fcs_lport_get_attr(&vport->lport, &attr->port_attr);\n\tattr->vport_state = bfa_sm_to_state(vport_sm_table, vport->sm);\n}\n\n\n \nstruct bfa_fcs_vport_s *\nbfa_fcs_vport_lookup(struct bfa_fcs_s *fcs, u16 vf_id, wwn_t vpwwn)\n{\n\tstruct bfa_fcs_vport_s *vport;\n\tstruct bfa_fcs_fabric_s *fabric;\n\n\tbfa_trc(fcs, vf_id);\n\tbfa_trc(fcs, vpwwn);\n\n\tfabric = bfa_fcs_vf_lookup(fcs, vf_id);\n\tif (!fabric) {\n\t\tbfa_trc(fcs, vf_id);\n\t\treturn NULL;\n\t}\n\n\tvport = bfa_fcs_fabric_vport_lookup(fabric, vpwwn);\n\treturn vport;\n}\n\n \nvoid\nbfa_cb_lps_fdisc_comp(void *bfad, void *uarg, bfa_status_t status)\n{\n\tstruct bfa_fcs_vport_s *vport = uarg;\n\n\tbfa_trc(__vport_fcs(vport), __vport_pwwn(vport));\n\tbfa_trc(__vport_fcs(vport), status);\n\n\tswitch (status) {\n\tcase BFA_STATUS_OK:\n\t\t \n\t\t__vport_fcid(vport) = vport->lps->lp_pid;\n\t\tvport->vport_stats.fdisc_accepts++;\n\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_OK);\n\t\tbreak;\n\n\tcase BFA_STATUS_INVALID_MAC:\n\t\t \n\t\tvport->vport_stats.fdisc_acc_bad++;\n\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\n\n\t\tbreak;\n\n\tcase BFA_STATUS_EPROTOCOL:\n\t\tswitch (vport->lps->ext_status) {\n\t\tcase BFA_EPROTO_BAD_ACCEPT:\n\t\t\tvport->vport_stats.fdisc_acc_bad++;\n\t\t\tbreak;\n\n\t\tcase BFA_EPROTO_UNKNOWN_RSP:\n\t\t\tvport->vport_stats.fdisc_unknown_rsp++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)\n\t\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\n\t\telse\n\t\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_FAILED);\n\n\t\tbreak;\n\n\tcase BFA_STATUS_ETIMER:\n\t\tvport->vport_stats.fdisc_timeouts++;\n\t\tif (vport->fdisc_retries < BFA_FCS_VPORT_MAX_RETRIES)\n\t\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\n\t\telse\n\t\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_FAILED);\n\t\tbreak;\n\n\tcase BFA_STATUS_FABRIC_RJT:\n\t\tvport->vport_stats.fdisc_rejects++;\n\t\tbfa_fcs_vport_fdisc_rejected(vport);\n\t\tbreak;\n\n\tdefault:\n\t\tvport->vport_stats.fdisc_rsp_err++;\n\t\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_ERROR);\n\t}\n}\n\n \nvoid\nbfa_cb_lps_fdisclogo_comp(void *bfad, void *uarg)\n{\n\tstruct bfa_fcs_vport_s *vport = uarg;\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_RSP_OK);\n}\n\n \nvoid\nbfa_cb_lps_cvl_event(void *bfad, void *uarg)\n{\n\tstruct bfa_fcs_vport_s *vport = uarg;\n\n\t \n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_OFFLINE);\n\tbfa_sm_send_event(vport, BFA_FCS_VPORT_SM_ONLINE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}