{
  "module_name": "bfa_svc.c",
  "hash_id": "d2091b9b904600370577623d83cc95d63f18b546d9b60c9a63070cc495d721af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfa_svc.c",
  "human_readable_source": "\n \n\n#include \"bfad_drv.h\"\n#include \"bfad_im.h\"\n#include \"bfa_plog.h\"\n#include \"bfa_cs.h\"\n#include \"bfa_modules.h\"\n\nBFA_TRC_FILE(HAL, FCXP);\n\n \n#define BFA_LPS_MIN_LPORTS      (1)\n#define BFA_LPS_MAX_LPORTS      (256)\n\n \n#define BFA_LPS_MAX_VPORTS_SUPP_CB  255\n#define BFA_LPS_MAX_VPORTS_SUPP_CT  190\n\n\n \n \n#define BFA_PORT_IS_DISABLED(bfa) \\\n\t((bfa_fcport_is_disabled(bfa) == BFA_TRUE) || \\\n\t(bfa_ioc_is_disabled(&bfa->ioc) == BFA_TRUE))\n\n \nenum bfa_fcport_sm_event {\n\tBFA_FCPORT_SM_START\t= 1,\t \n\tBFA_FCPORT_SM_STOP\t= 2,\t \n\tBFA_FCPORT_SM_ENABLE\t= 3,\t \n\tBFA_FCPORT_SM_DISABLE\t= 4,\t \n\tBFA_FCPORT_SM_FWRSP\t= 5,\t \n\tBFA_FCPORT_SM_LINKUP\t= 6,\t \n\tBFA_FCPORT_SM_LINKDOWN\t= 7,\t \n\tBFA_FCPORT_SM_QRESUME\t= 8,\t \n\tBFA_FCPORT_SM_HWFAIL\t= 9,\t \n\tBFA_FCPORT_SM_DPORTENABLE = 10,  \n\tBFA_FCPORT_SM_DPORTDISABLE = 11, \n\tBFA_FCPORT_SM_FAA_MISCONFIG = 12,\t \n\tBFA_FCPORT_SM_DDPORTENABLE  = 13,\t \n\tBFA_FCPORT_SM_DDPORTDISABLE = 14,\t \n};\n\n \n\nenum bfa_fcport_ln_sm_event {\n\tBFA_FCPORT_LN_SM_LINKUP\t\t= 1,\t \n\tBFA_FCPORT_LN_SM_LINKDOWN\t= 2,\t \n\tBFA_FCPORT_LN_SM_NOTIFICATION\t= 3\t \n};\n\n \n#define bfa_rport_offline_cb(__rp) do {\t\t\t\t\t\\\n\tif ((__rp)->bfa->fcs)\t\t\t\t\t\t\\\n\t\tbfa_cb_rport_offline((__rp)->rport_drv);      \\\n\telse {\t\t\t\t\t\t\t\t\\\n\t\tbfa_cb_queue((__rp)->bfa, &(__rp)->hcb_qe,\t\t\\\n\t\t\t\t__bfa_cb_rport_offline, (__rp));      \\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define bfa_rport_online_cb(__rp) do {\t\t\t\t\t\\\n\tif ((__rp)->bfa->fcs)\t\t\t\t\t\t\\\n\t\tbfa_cb_rport_online((__rp)->rport_drv);      \\\n\telse {\t\t\t\t\t\t\t\t\\\n\t\tbfa_cb_queue((__rp)->bfa, &(__rp)->hcb_qe,\t\t\\\n\t\t\t\t  __bfa_cb_rport_online, (__rp));      \\\n\t\t}\t\t\t\t\t\t\t\\\n} while (0)\n\n \nstatic void\t__bfa_fcxp_send_cbfn(void *cbarg, bfa_boolean_t complete);\nstatic void\thal_fcxp_rx_plog(struct bfa_s *bfa, struct bfa_fcxp_s *fcxp,\n\t\t\t\tstruct bfi_fcxp_send_rsp_s *fcxp_rsp);\nstatic void\thal_fcxp_tx_plog(struct bfa_s *bfa, u32 reqlen,\n\t\t\t\tstruct bfa_fcxp_s *fcxp, struct fchs_s *fchs);\nstatic void\tbfa_fcxp_qresume(void *cbarg);\nstatic void\tbfa_fcxp_queue(struct bfa_fcxp_s *fcxp,\n\t\t\t\tstruct bfi_fcxp_send_req_s *send_req);\n\n \nstatic void bfa_lps_login_rsp(struct bfa_s *bfa,\n\t\t\t\tstruct bfi_lps_login_rsp_s *rsp);\nstatic void bfa_lps_no_res(struct bfa_lps_s *first_lps, u8 count);\nstatic void bfa_lps_logout_rsp(struct bfa_s *bfa,\n\t\t\t\tstruct bfi_lps_logout_rsp_s *rsp);\nstatic void bfa_lps_reqq_resume(void *lps_arg);\nstatic void bfa_lps_free(struct bfa_lps_s *lps);\nstatic void bfa_lps_send_login(struct bfa_lps_s *lps);\nstatic void bfa_lps_send_logout(struct bfa_lps_s *lps);\nstatic void bfa_lps_send_set_n2n_pid(struct bfa_lps_s *lps);\nstatic void bfa_lps_login_comp(struct bfa_lps_s *lps);\nstatic void bfa_lps_logout_comp(struct bfa_lps_s *lps);\nstatic void bfa_lps_cvl_event(struct bfa_lps_s *lps);\n\n \nstatic void bfa_lps_sm_init(struct bfa_lps_s *lps, enum bfa_lps_event event);\nstatic void bfa_lps_sm_login(struct bfa_lps_s *lps, enum bfa_lps_event event);\nstatic void bfa_lps_sm_loginwait(struct bfa_lps_s *lps, enum bfa_lps_event\n\t\t\t\t\tevent);\nstatic void bfa_lps_sm_online(struct bfa_lps_s *lps, enum bfa_lps_event event);\nstatic void bfa_lps_sm_online_n2n_pid_wait(struct bfa_lps_s *lps,\n\t\t\t\t\tenum bfa_lps_event event);\nstatic void bfa_lps_sm_logout(struct bfa_lps_s *lps, enum bfa_lps_event event);\nstatic void bfa_lps_sm_logowait(struct bfa_lps_s *lps, enum bfa_lps_event\n\t\t\t\t\tevent);\n\n \nstatic bfa_boolean_t bfa_fcport_send_enable(struct bfa_fcport_s *fcport);\nstatic bfa_boolean_t bfa_fcport_send_disable(struct bfa_fcport_s *fcport);\nstatic void bfa_fcport_update_linkinfo(struct bfa_fcport_s *fcport);\nstatic void bfa_fcport_reset_linkinfo(struct bfa_fcport_s *fcport);\nstatic void bfa_fcport_set_wwns(struct bfa_fcport_s *fcport);\nstatic void __bfa_cb_fcport_event(void *cbarg, bfa_boolean_t complete);\nstatic void bfa_fcport_scn(struct bfa_fcport_s *fcport,\n\t\t\tenum bfa_port_linkstate event, bfa_boolean_t trunk);\nstatic void bfa_fcport_queue_cb(struct bfa_fcport_ln_s *ln,\n\t\t\t\tenum bfa_port_linkstate event);\nstatic void __bfa_cb_fcport_stats_clr(void *cbarg, bfa_boolean_t complete);\nstatic void bfa_fcport_stats_get_timeout(void *cbarg);\nstatic void bfa_fcport_stats_clr_timeout(void *cbarg);\nstatic void bfa_trunk_iocdisable(struct bfa_s *bfa);\n\n \nstatic void     bfa_fcport_sm_uninit(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_enabling_qwait(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_enabling(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_linkdown(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_linkup(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_disabling(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_disabling_qwait(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_toggling_qwait(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_disabled(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_stopped(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_iocdown(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_iocfail(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void\tbfa_fcport_sm_dport(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void     bfa_fcport_sm_ddport(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\nstatic void\tbfa_fcport_sm_faa_misconfig(struct bfa_fcport_s *fcport,\n\t\t\t\t\tenum bfa_fcport_sm_event event);\n\nstatic void     bfa_fcport_ln_sm_dn(struct bfa_fcport_ln_s *ln,\n\t\t\t\t\tenum bfa_fcport_ln_sm_event event);\nstatic void     bfa_fcport_ln_sm_dn_nf(struct bfa_fcport_ln_s *ln,\n\t\t\t\t\tenum bfa_fcport_ln_sm_event event);\nstatic void     bfa_fcport_ln_sm_dn_up_nf(struct bfa_fcport_ln_s *ln,\n\t\t\t\t\tenum bfa_fcport_ln_sm_event event);\nstatic void     bfa_fcport_ln_sm_up(struct bfa_fcport_ln_s *ln,\n\t\t\t\t\tenum bfa_fcport_ln_sm_event event);\nstatic void     bfa_fcport_ln_sm_up_nf(struct bfa_fcport_ln_s *ln,\n\t\t\t\t\tenum bfa_fcport_ln_sm_event event);\nstatic void     bfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln,\n\t\t\t\t\tenum bfa_fcport_ln_sm_event event);\nstatic void     bfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln,\n\t\t\t\t\tenum bfa_fcport_ln_sm_event event);\n\nstatic struct bfa_sm_table_s hal_port_sm_table[] = {\n\t{BFA_SM(bfa_fcport_sm_uninit), BFA_PORT_ST_UNINIT},\n\t{BFA_SM(bfa_fcport_sm_enabling_qwait), BFA_PORT_ST_ENABLING_QWAIT},\n\t{BFA_SM(bfa_fcport_sm_enabling), BFA_PORT_ST_ENABLING},\n\t{BFA_SM(bfa_fcport_sm_linkdown), BFA_PORT_ST_LINKDOWN},\n\t{BFA_SM(bfa_fcport_sm_linkup), BFA_PORT_ST_LINKUP},\n\t{BFA_SM(bfa_fcport_sm_disabling_qwait), BFA_PORT_ST_DISABLING_QWAIT},\n\t{BFA_SM(bfa_fcport_sm_toggling_qwait), BFA_PORT_ST_TOGGLING_QWAIT},\n\t{BFA_SM(bfa_fcport_sm_disabling), BFA_PORT_ST_DISABLING},\n\t{BFA_SM(bfa_fcport_sm_disabled), BFA_PORT_ST_DISABLED},\n\t{BFA_SM(bfa_fcport_sm_stopped), BFA_PORT_ST_STOPPED},\n\t{BFA_SM(bfa_fcport_sm_iocdown), BFA_PORT_ST_IOCDOWN},\n\t{BFA_SM(bfa_fcport_sm_iocfail), BFA_PORT_ST_IOCDOWN},\n\t{BFA_SM(bfa_fcport_sm_dport), BFA_PORT_ST_DPORT},\n\t{BFA_SM(bfa_fcport_sm_ddport), BFA_PORT_ST_DDPORT},\n\t{BFA_SM(bfa_fcport_sm_faa_misconfig), BFA_PORT_ST_FAA_MISCONFIG},\n};\n\n\n \nstatic struct bfa_rport_s *bfa_rport_alloc(struct bfa_rport_mod_s *rp_mod);\nstatic void\t\tbfa_rport_free(struct bfa_rport_s *rport);\nstatic bfa_boolean_t\tbfa_rport_send_fwcreate(struct bfa_rport_s *rp);\nstatic bfa_boolean_t\tbfa_rport_send_fwdelete(struct bfa_rport_s *rp);\nstatic bfa_boolean_t\tbfa_rport_send_fwspeed(struct bfa_rport_s *rp);\nstatic void\t\t__bfa_cb_rport_online(void *cbarg,\n\t\t\t\t\t\tbfa_boolean_t complete);\nstatic void\t\t__bfa_cb_rport_offline(void *cbarg,\n\t\t\t\t\t\tbfa_boolean_t complete);\n\n \nstatic void     bfa_rport_sm_uninit(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_created(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_fwcreate(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_online(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_fwdelete(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_offline(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_deleting(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_offline_pending(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_delete_pending(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_iocdisable(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_fwcreate_qfull(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_fwdelete_qfull(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\nstatic void     bfa_rport_sm_deleting_qfull(struct bfa_rport_s *rp,\n\t\t\t\t\tenum bfa_rport_event event);\n\n \nstatic int\nplkd_validate_logrec(struct bfa_plog_rec_s *pl_rec)\n{\n\tif ((pl_rec->log_type != BFA_PL_LOG_TYPE_INT) &&\n\t\t(pl_rec->log_type != BFA_PL_LOG_TYPE_STRING))\n\t\treturn 1;\n\n\tif ((pl_rec->log_type != BFA_PL_LOG_TYPE_INT) &&\n\t\t(pl_rec->log_num_ints > BFA_PL_INT_LOG_SZ))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\nbfa_plog_add(struct bfa_plog_s *plog, struct bfa_plog_rec_s *pl_rec)\n{\n\tu16 tail;\n\tstruct bfa_plog_rec_s *pl_recp;\n\n\tif (plog->plog_enabled == 0)\n\t\treturn;\n\n\tif (plkd_validate_logrec(pl_rec)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\ttail = plog->tail;\n\n\tpl_recp = &(plog->plog_recs[tail]);\n\n\tmemcpy(pl_recp, pl_rec, sizeof(struct bfa_plog_rec_s));\n\n\tpl_recp->tv = ktime_get_real_seconds();\n\tBFA_PL_LOG_REC_INCR(plog->tail);\n\n\tif (plog->head == plog->tail)\n\t\tBFA_PL_LOG_REC_INCR(plog->head);\n}\n\nvoid\nbfa_plog_init(struct bfa_plog_s *plog)\n{\n\tmemset((char *)plog, 0, sizeof(struct bfa_plog_s));\n\n\tmemcpy(plog->plog_sig, BFA_PL_SIG_STR, BFA_PL_SIG_LEN);\n\tplog->head = plog->tail = 0;\n\tplog->plog_enabled = 1;\n}\n\nvoid\nbfa_plog_str(struct bfa_plog_s *plog, enum bfa_plog_mid mid,\n\t\tenum bfa_plog_eid event,\n\t\tu16 misc, char *log_str)\n{\n\tstruct bfa_plog_rec_s  lp;\n\n\tif (plog->plog_enabled) {\n\t\tmemset(&lp, 0, sizeof(struct bfa_plog_rec_s));\n\t\tlp.mid = mid;\n\t\tlp.eid = event;\n\t\tlp.log_type = BFA_PL_LOG_TYPE_STRING;\n\t\tlp.misc = misc;\n\t\tstrscpy(lp.log_entry.string_log, log_str,\n\t\t\tBFA_PL_STRING_LOG_SZ);\n\t\tlp.log_entry.string_log[BFA_PL_STRING_LOG_SZ - 1] = '\\0';\n\t\tbfa_plog_add(plog, &lp);\n\t}\n}\n\nvoid\nbfa_plog_intarr(struct bfa_plog_s *plog, enum bfa_plog_mid mid,\n\t\tenum bfa_plog_eid event,\n\t\tu16 misc, u32 *intarr, u32 num_ints)\n{\n\tstruct bfa_plog_rec_s  lp;\n\tu32 i;\n\n\tif (num_ints > BFA_PL_INT_LOG_SZ)\n\t\tnum_ints = BFA_PL_INT_LOG_SZ;\n\n\tif (plog->plog_enabled) {\n\t\tmemset(&lp, 0, sizeof(struct bfa_plog_rec_s));\n\t\tlp.mid = mid;\n\t\tlp.eid = event;\n\t\tlp.log_type = BFA_PL_LOG_TYPE_INT;\n\t\tlp.misc = misc;\n\n\t\tfor (i = 0; i < num_ints; i++)\n\t\t\tlp.log_entry.int_log[i] = intarr[i];\n\n\t\tlp.log_num_ints = (u8) num_ints;\n\n\t\tbfa_plog_add(plog, &lp);\n\t}\n}\n\nvoid\nbfa_plog_fchdr(struct bfa_plog_s *plog, enum bfa_plog_mid mid,\n\t\t\tenum bfa_plog_eid event,\n\t\t\tu16 misc, struct fchs_s *fchdr)\n{\n\tu32\t*tmp_int = (u32 *) fchdr;\n\tu32\tints[BFA_PL_INT_LOG_SZ];\n\n\tif (plog->plog_enabled) {\n\t\tints[0] = tmp_int[0];\n\t\tints[1] = tmp_int[1];\n\t\tints[2] = tmp_int[4];\n\n\t\tbfa_plog_intarr(plog, mid, event, misc, ints, 3);\n\t}\n}\n\nvoid\nbfa_plog_fchdr_and_pl(struct bfa_plog_s *plog, enum bfa_plog_mid mid,\n\t\t      enum bfa_plog_eid event, u16 misc, struct fchs_s *fchdr,\n\t\t      u32 pld_w0)\n{\n\tu32\t*tmp_int = (u32 *) fchdr;\n\tu32\tints[BFA_PL_INT_LOG_SZ];\n\n\tif (plog->plog_enabled) {\n\t\tints[0] = tmp_int[0];\n\t\tints[1] = tmp_int[1];\n\t\tints[2] = tmp_int[4];\n\t\tints[3] = pld_w0;\n\n\t\tbfa_plog_intarr(plog, mid, event, misc, ints, 4);\n\t}\n}\n\n\n \n\nstatic void\nclaim_fcxps_mem(struct bfa_fcxp_mod_s *mod)\n{\n\tu16\ti;\n\tstruct bfa_fcxp_s *fcxp;\n\n\tfcxp = (struct bfa_fcxp_s *) bfa_mem_kva_curp(mod);\n\tmemset(fcxp, 0, sizeof(struct bfa_fcxp_s) * mod->num_fcxps);\n\n\tINIT_LIST_HEAD(&mod->fcxp_req_free_q);\n\tINIT_LIST_HEAD(&mod->fcxp_rsp_free_q);\n\tINIT_LIST_HEAD(&mod->fcxp_active_q);\n\tINIT_LIST_HEAD(&mod->fcxp_req_unused_q);\n\tINIT_LIST_HEAD(&mod->fcxp_rsp_unused_q);\n\n\tmod->fcxp_list = fcxp;\n\n\tfor (i = 0; i < mod->num_fcxps; i++) {\n\t\tfcxp->fcxp_mod = mod;\n\t\tfcxp->fcxp_tag = i;\n\n\t\tif (i < (mod->num_fcxps / 2)) {\n\t\t\tlist_add_tail(&fcxp->qe, &mod->fcxp_req_free_q);\n\t\t\tfcxp->req_rsp = BFA_TRUE;\n\t\t} else {\n\t\t\tlist_add_tail(&fcxp->qe, &mod->fcxp_rsp_free_q);\n\t\t\tfcxp->req_rsp = BFA_FALSE;\n\t\t}\n\n\t\tbfa_reqq_winit(&fcxp->reqq_wqe, bfa_fcxp_qresume, fcxp);\n\t\tfcxp->reqq_waiting = BFA_FALSE;\n\n\t\tfcxp = fcxp + 1;\n\t}\n\n\tbfa_mem_kva_curp(mod) = (void *)fcxp;\n}\n\nvoid\nbfa_fcxp_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *minfo,\n\t\tstruct bfa_s *bfa)\n{\n\tstruct bfa_fcxp_mod_s *fcxp_mod = BFA_FCXP_MOD(bfa);\n\tstruct bfa_mem_kva_s *fcxp_kva = BFA_MEM_FCXP_KVA(bfa);\n\tstruct bfa_mem_dma_s *seg_ptr;\n\tu16\tnsegs, idx, per_seg_fcxp;\n\tu16\tnum_fcxps = cfg->fwcfg.num_fcxp_reqs;\n\tu32\tper_fcxp_sz;\n\n\tif (num_fcxps == 0)\n\t\treturn;\n\n\tif (cfg->drvcfg.min_cfg)\n\t\tper_fcxp_sz = 2 * BFA_FCXP_MAX_IBUF_SZ;\n\telse\n\t\tper_fcxp_sz = BFA_FCXP_MAX_IBUF_SZ + BFA_FCXP_MAX_LBUF_SZ;\n\n\t \n\tnsegs = BFI_MEM_DMA_NSEGS(num_fcxps, per_fcxp_sz);\n\tper_seg_fcxp = BFI_MEM_NREQS_SEG(per_fcxp_sz);\n\n\tbfa_mem_dma_seg_iter(fcxp_mod, seg_ptr, nsegs, idx) {\n\t\tif (num_fcxps >= per_seg_fcxp) {\n\t\t\tnum_fcxps -= per_seg_fcxp;\n\t\t\tbfa_mem_dma_setup(minfo, seg_ptr,\n\t\t\t\tper_seg_fcxp * per_fcxp_sz);\n\t\t} else\n\t\t\tbfa_mem_dma_setup(minfo, seg_ptr,\n\t\t\t\tnum_fcxps * per_fcxp_sz);\n\t}\n\n\t \n\tbfa_mem_kva_setup(minfo, fcxp_kva,\n\t\tcfg->fwcfg.num_fcxp_reqs * sizeof(struct bfa_fcxp_s));\n}\n\nvoid\nbfa_fcxp_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\t\tstruct bfa_pcidev_s *pcidev)\n{\n\tstruct bfa_fcxp_mod_s *mod = BFA_FCXP_MOD(bfa);\n\n\tmod->bfa = bfa;\n\tmod->num_fcxps = cfg->fwcfg.num_fcxp_reqs;\n\n\t \n\tmod->req_pld_sz = mod->rsp_pld_sz = BFA_FCXP_MAX_IBUF_SZ;\n\tif (!cfg->drvcfg.min_cfg)\n\t\tmod->rsp_pld_sz = BFA_FCXP_MAX_LBUF_SZ;\n\n\tINIT_LIST_HEAD(&mod->req_wait_q);\n\tINIT_LIST_HEAD(&mod->rsp_wait_q);\n\n\tclaim_fcxps_mem(mod);\n}\n\nvoid\nbfa_fcxp_iocdisable(struct bfa_s *bfa)\n{\n\tstruct bfa_fcxp_mod_s *mod = BFA_FCXP_MOD(bfa);\n\tstruct bfa_fcxp_s *fcxp;\n\tstruct list_head\t      *qe, *qen;\n\n\t \n\tlist_splice_tail_init(&mod->fcxp_req_unused_q, &mod->fcxp_req_free_q);\n\tlist_splice_tail_init(&mod->fcxp_rsp_unused_q, &mod->fcxp_rsp_free_q);\n\n\tlist_for_each_safe(qe, qen, &mod->fcxp_active_q) {\n\t\tfcxp = (struct bfa_fcxp_s *) qe;\n\t\tif (fcxp->caller == NULL) {\n\t\t\tfcxp->send_cbfn(fcxp->caller, fcxp, fcxp->send_cbarg,\n\t\t\t\t\tBFA_STATUS_IOC_FAILURE, 0, 0, NULL);\n\t\t\tbfa_fcxp_free(fcxp);\n\t\t} else {\n\t\t\tfcxp->rsp_status = BFA_STATUS_IOC_FAILURE;\n\t\t\tbfa_cb_queue(bfa, &fcxp->hcb_qe,\n\t\t\t\t     __bfa_fcxp_send_cbfn, fcxp);\n\t\t}\n\t}\n}\n\nstatic struct bfa_fcxp_s *\nbfa_fcxp_get(struct bfa_fcxp_mod_s *fm, bfa_boolean_t req)\n{\n\tstruct bfa_fcxp_s *fcxp;\n\n\tif (req)\n\t\tbfa_q_deq(&fm->fcxp_req_free_q, &fcxp);\n\telse\n\t\tbfa_q_deq(&fm->fcxp_rsp_free_q, &fcxp);\n\n\tif (fcxp)\n\t\tlist_add_tail(&fcxp->qe, &fm->fcxp_active_q);\n\n\treturn fcxp;\n}\n\nstatic void\nbfa_fcxp_init_reqrsp(struct bfa_fcxp_s *fcxp,\n\t       struct bfa_s *bfa,\n\t       u8 *use_ibuf,\n\t       u32 *nr_sgles,\n\t       bfa_fcxp_get_sgaddr_t *r_sga_cbfn,\n\t       bfa_fcxp_get_sglen_t *r_sglen_cbfn,\n\t       struct list_head *r_sgpg_q,\n\t       int n_sgles,\n\t       bfa_fcxp_get_sgaddr_t sga_cbfn,\n\t       bfa_fcxp_get_sglen_t sglen_cbfn)\n{\n\n\tWARN_ON(bfa == NULL);\n\n\tbfa_trc(bfa, fcxp->fcxp_tag);\n\n\tif (n_sgles == 0) {\n\t\t*use_ibuf = 1;\n\t} else {\n\t\tWARN_ON(*sga_cbfn == NULL);\n\t\tWARN_ON(*sglen_cbfn == NULL);\n\n\t\t*use_ibuf = 0;\n\t\t*r_sga_cbfn = sga_cbfn;\n\t\t*r_sglen_cbfn = sglen_cbfn;\n\n\t\t*nr_sgles = n_sgles;\n\n\t\t \n\t\tif (n_sgles > BFI_SGE_INLINE)\n\t\t\tWARN_ON(1);\n\t}\n\n}\n\nstatic void\nbfa_fcxp_init(struct bfa_fcxp_s *fcxp,\n\t       void *caller, struct bfa_s *bfa, int nreq_sgles,\n\t       int nrsp_sgles, bfa_fcxp_get_sgaddr_t req_sga_cbfn,\n\t       bfa_fcxp_get_sglen_t req_sglen_cbfn,\n\t       bfa_fcxp_get_sgaddr_t rsp_sga_cbfn,\n\t       bfa_fcxp_get_sglen_t rsp_sglen_cbfn)\n{\n\n\tWARN_ON(bfa == NULL);\n\n\tbfa_trc(bfa, fcxp->fcxp_tag);\n\n\tfcxp->caller = caller;\n\n\tbfa_fcxp_init_reqrsp(fcxp, bfa,\n\t\t&fcxp->use_ireqbuf, &fcxp->nreq_sgles, &fcxp->req_sga_cbfn,\n\t\t&fcxp->req_sglen_cbfn, &fcxp->req_sgpg_q,\n\t\tnreq_sgles, req_sga_cbfn, req_sglen_cbfn);\n\n\tbfa_fcxp_init_reqrsp(fcxp, bfa,\n\t\t&fcxp->use_irspbuf, &fcxp->nrsp_sgles, &fcxp->rsp_sga_cbfn,\n\t\t&fcxp->rsp_sglen_cbfn, &fcxp->rsp_sgpg_q,\n\t\tnrsp_sgles, rsp_sga_cbfn, rsp_sglen_cbfn);\n\n}\n\nstatic void\nbfa_fcxp_put(struct bfa_fcxp_s *fcxp)\n{\n\tstruct bfa_fcxp_mod_s *mod = fcxp->fcxp_mod;\n\tstruct bfa_fcxp_wqe_s *wqe;\n\n\tif (fcxp->req_rsp)\n\t\tbfa_q_deq(&mod->req_wait_q, &wqe);\n\telse\n\t\tbfa_q_deq(&mod->rsp_wait_q, &wqe);\n\n\tif (wqe) {\n\t\tbfa_trc(mod->bfa, fcxp->fcxp_tag);\n\n\t\tbfa_fcxp_init(fcxp, wqe->caller, wqe->bfa, wqe->nreq_sgles,\n\t\t\twqe->nrsp_sgles, wqe->req_sga_cbfn,\n\t\t\twqe->req_sglen_cbfn, wqe->rsp_sga_cbfn,\n\t\t\twqe->rsp_sglen_cbfn);\n\n\t\twqe->alloc_cbfn(wqe->alloc_cbarg, fcxp);\n\t\treturn;\n\t}\n\n\tWARN_ON(!bfa_q_is_on_q(&mod->fcxp_active_q, fcxp));\n\tlist_del(&fcxp->qe);\n\n\tif (fcxp->req_rsp)\n\t\tlist_add_tail(&fcxp->qe, &mod->fcxp_req_free_q);\n\telse\n\t\tlist_add_tail(&fcxp->qe, &mod->fcxp_rsp_free_q);\n}\n\nstatic void\nbfa_fcxp_null_comp(void *bfad_fcxp, struct bfa_fcxp_s *fcxp, void *cbarg,\n\t\t   bfa_status_t req_status, u32 rsp_len,\n\t\t   u32 resid_len, struct fchs_s *rsp_fchs)\n{\n\t \n}\n\nstatic void\n__bfa_fcxp_send_cbfn(void *cbarg, bfa_boolean_t complete)\n{\n\tstruct bfa_fcxp_s *fcxp = cbarg;\n\n\tif (complete) {\n\t\tfcxp->send_cbfn(fcxp->caller, fcxp, fcxp->send_cbarg,\n\t\t\t\tfcxp->rsp_status, fcxp->rsp_len,\n\t\t\t\tfcxp->residue_len, &fcxp->rsp_fchs);\n\t} else {\n\t\tbfa_fcxp_free(fcxp);\n\t}\n}\n\nstatic void\nhal_fcxp_send_comp(struct bfa_s *bfa, struct bfi_fcxp_send_rsp_s *fcxp_rsp)\n{\n\tstruct bfa_fcxp_mod_s\t*mod = BFA_FCXP_MOD(bfa);\n\tstruct bfa_fcxp_s\t*fcxp;\n\tu16\t\tfcxp_tag = be16_to_cpu(fcxp_rsp->fcxp_tag);\n\n\tbfa_trc(bfa, fcxp_tag);\n\n\tfcxp_rsp->rsp_len = be32_to_cpu(fcxp_rsp->rsp_len);\n\n\t \n\tif (fcxp_rsp->req_status == BFA_STATUS_OK)\n\t\tfcxp_rsp->residue_len = 0;\n\telse\n\t\tfcxp_rsp->residue_len = be32_to_cpu(fcxp_rsp->residue_len);\n\n\tfcxp = BFA_FCXP_FROM_TAG(mod, fcxp_tag);\n\n\tWARN_ON(fcxp->send_cbfn == NULL);\n\n\thal_fcxp_rx_plog(mod->bfa, fcxp, fcxp_rsp);\n\n\tif (fcxp->send_cbfn != NULL) {\n\t\tbfa_trc(mod->bfa, (NULL == fcxp->caller));\n\t\tif (fcxp->caller == NULL) {\n\t\t\tfcxp->send_cbfn(fcxp->caller, fcxp, fcxp->send_cbarg,\n\t\t\t\t\tfcxp_rsp->req_status, fcxp_rsp->rsp_len,\n\t\t\t\t\tfcxp_rsp->residue_len, &fcxp_rsp->fchs);\n\t\t\t \n\t\t\tbfa_fcxp_free(fcxp);\n\t\t} else {\n\t\t\tfcxp->rsp_status = fcxp_rsp->req_status;\n\t\t\tfcxp->rsp_len = fcxp_rsp->rsp_len;\n\t\t\tfcxp->residue_len = fcxp_rsp->residue_len;\n\t\t\tfcxp->rsp_fchs = fcxp_rsp->fchs;\n\n\t\t\tbfa_cb_queue(bfa, &fcxp->hcb_qe,\n\t\t\t\t\t__bfa_fcxp_send_cbfn, fcxp);\n\t\t}\n\t} else {\n\t\tbfa_trc(bfa, (NULL == fcxp->send_cbfn));\n\t}\n}\n\nstatic void\nhal_fcxp_tx_plog(struct bfa_s *bfa, u32 reqlen, struct bfa_fcxp_s *fcxp,\n\t\t struct fchs_s *fchs)\n{\n\t \n\tif (reqlen > 0) {\n\t\tif (fcxp->use_ireqbuf) {\n\t\t\tu32\tpld_w0 =\n\t\t\t\t*((u32 *) BFA_FCXP_REQ_PLD(fcxp));\n\n\t\t\tbfa_plog_fchdr_and_pl(bfa->plog, BFA_PL_MID_HAL_FCXP,\n\t\t\t\t\tBFA_PL_EID_TX,\n\t\t\t\t\treqlen + sizeof(struct fchs_s), fchs,\n\t\t\t\t\tpld_w0);\n\t\t} else {\n\t\t\tbfa_plog_fchdr(bfa->plog, BFA_PL_MID_HAL_FCXP,\n\t\t\t\t\tBFA_PL_EID_TX,\n\t\t\t\t\treqlen + sizeof(struct fchs_s),\n\t\t\t\t\tfchs);\n\t\t}\n\t} else {\n\t\tbfa_plog_fchdr(bfa->plog, BFA_PL_MID_HAL_FCXP, BFA_PL_EID_TX,\n\t\t\t       reqlen + sizeof(struct fchs_s), fchs);\n\t}\n}\n\nstatic void\nhal_fcxp_rx_plog(struct bfa_s *bfa, struct bfa_fcxp_s *fcxp,\n\t\t struct bfi_fcxp_send_rsp_s *fcxp_rsp)\n{\n\tif (fcxp_rsp->rsp_len > 0) {\n\t\tif (fcxp->use_irspbuf) {\n\t\t\tu32\tpld_w0 =\n\t\t\t\t*((u32 *) BFA_FCXP_RSP_PLD(fcxp));\n\n\t\t\tbfa_plog_fchdr_and_pl(bfa->plog, BFA_PL_MID_HAL_FCXP,\n\t\t\t\t\t      BFA_PL_EID_RX,\n\t\t\t\t\t      (u16) fcxp_rsp->rsp_len,\n\t\t\t\t\t      &fcxp_rsp->fchs, pld_w0);\n\t\t} else {\n\t\t\tbfa_plog_fchdr(bfa->plog, BFA_PL_MID_HAL_FCXP,\n\t\t\t\t       BFA_PL_EID_RX,\n\t\t\t\t       (u16) fcxp_rsp->rsp_len,\n\t\t\t\t       &fcxp_rsp->fchs);\n\t\t}\n\t} else {\n\t\tbfa_plog_fchdr(bfa->plog, BFA_PL_MID_HAL_FCXP, BFA_PL_EID_RX,\n\t\t\t       (u16) fcxp_rsp->rsp_len, &fcxp_rsp->fchs);\n\t}\n}\n\n \nstatic void\nbfa_fcxp_qresume(void *cbarg)\n{\n\tstruct bfa_fcxp_s\t\t*fcxp = cbarg;\n\tstruct bfa_s\t\t\t*bfa = fcxp->fcxp_mod->bfa;\n\tstruct bfi_fcxp_send_req_s\t*send_req;\n\n\tfcxp->reqq_waiting = BFA_FALSE;\n\tsend_req = bfa_reqq_next(bfa, BFA_REQQ_FCXP);\n\tbfa_fcxp_queue(fcxp, send_req);\n}\n\n \nstatic void\nbfa_fcxp_queue(struct bfa_fcxp_s *fcxp, struct bfi_fcxp_send_req_s *send_req)\n{\n\tstruct bfa_s\t\t\t*bfa = fcxp->fcxp_mod->bfa;\n\tstruct bfa_fcxp_req_info_s\t*reqi = &fcxp->req_info;\n\tstruct bfa_fcxp_rsp_info_s\t*rspi = &fcxp->rsp_info;\n\tstruct bfa_rport_s\t\t*rport = reqi->bfa_rport;\n\n\tbfi_h2i_set(send_req->mh, BFI_MC_FCXP, BFI_FCXP_H2I_SEND_REQ,\n\t\t    bfa_fn_lpu(bfa));\n\n\tsend_req->fcxp_tag = cpu_to_be16(fcxp->fcxp_tag);\n\tif (rport) {\n\t\tsend_req->rport_fw_hndl = rport->fw_handle;\n\t\tsend_req->max_frmsz = cpu_to_be16(rport->rport_info.max_frmsz);\n\t\tif (send_req->max_frmsz == 0)\n\t\t\tsend_req->max_frmsz = cpu_to_be16(FC_MAX_PDUSZ);\n\t} else {\n\t\tsend_req->rport_fw_hndl = 0;\n\t\tsend_req->max_frmsz = cpu_to_be16(FC_MAX_PDUSZ);\n\t}\n\n\tsend_req->vf_id = cpu_to_be16(reqi->vf_id);\n\tsend_req->lp_fwtag = bfa_lps_get_fwtag(bfa, reqi->lp_tag);\n\tsend_req->class = reqi->class;\n\tsend_req->rsp_timeout = rspi->rsp_timeout;\n\tsend_req->cts = reqi->cts;\n\tsend_req->fchs = reqi->fchs;\n\n\tsend_req->req_len = cpu_to_be32(reqi->req_tot_len);\n\tsend_req->rsp_maxlen = cpu_to_be32(rspi->rsp_maxlen);\n\n\t \n\tif (fcxp->use_ireqbuf == 1) {\n\t\tbfa_alen_set(&send_req->req_alen, reqi->req_tot_len,\n\t\t\t\t\tBFA_FCXP_REQ_PLD_PA(fcxp));\n\t} else {\n\t\tif (fcxp->nreq_sgles > 0) {\n\t\t\tWARN_ON(fcxp->nreq_sgles != 1);\n\t\t\tbfa_alen_set(&send_req->req_alen, reqi->req_tot_len,\n\t\t\t\tfcxp->req_sga_cbfn(fcxp->caller, 0));\n\t\t} else {\n\t\t\tWARN_ON(reqi->req_tot_len != 0);\n\t\t\tbfa_alen_set(&send_req->rsp_alen, 0, 0);\n\t\t}\n\t}\n\n\t \n\tif (fcxp->use_irspbuf == 1) {\n\t\tWARN_ON(rspi->rsp_maxlen > BFA_FCXP_MAX_LBUF_SZ);\n\n\t\tbfa_alen_set(&send_req->rsp_alen, rspi->rsp_maxlen,\n\t\t\t\t\tBFA_FCXP_RSP_PLD_PA(fcxp));\n\t} else {\n\t\tif (fcxp->nrsp_sgles > 0) {\n\t\t\tWARN_ON(fcxp->nrsp_sgles != 1);\n\t\t\tbfa_alen_set(&send_req->rsp_alen, rspi->rsp_maxlen,\n\t\t\t\tfcxp->rsp_sga_cbfn(fcxp->caller, 0));\n\n\t\t} else {\n\t\t\tWARN_ON(rspi->rsp_maxlen != 0);\n\t\t\tbfa_alen_set(&send_req->rsp_alen, 0, 0);\n\t\t}\n\t}\n\n\thal_fcxp_tx_plog(bfa, reqi->req_tot_len, fcxp, &reqi->fchs);\n\n\tbfa_reqq_produce(bfa, BFA_REQQ_FCXP, send_req->mh);\n\n\tbfa_trc(bfa, bfa_reqq_pi(bfa, BFA_REQQ_FCXP));\n\tbfa_trc(bfa, bfa_reqq_ci(bfa, BFA_REQQ_FCXP));\n}\n\n \nstruct bfa_fcxp_s *\nbfa_fcxp_req_rsp_alloc(void *caller, struct bfa_s *bfa, int nreq_sgles,\n\t\tint nrsp_sgles, bfa_fcxp_get_sgaddr_t req_sga_cbfn,\n\t\tbfa_fcxp_get_sglen_t req_sglen_cbfn,\n\t\tbfa_fcxp_get_sgaddr_t rsp_sga_cbfn,\n\t\tbfa_fcxp_get_sglen_t rsp_sglen_cbfn, bfa_boolean_t req)\n{\n\tstruct bfa_fcxp_s *fcxp = NULL;\n\n\tWARN_ON(bfa == NULL);\n\n\tfcxp = bfa_fcxp_get(BFA_FCXP_MOD(bfa), req);\n\tif (fcxp == NULL)\n\t\treturn NULL;\n\n\tbfa_trc(bfa, fcxp->fcxp_tag);\n\n\tbfa_fcxp_init(fcxp, caller, bfa, nreq_sgles, nrsp_sgles, req_sga_cbfn,\n\t\t\treq_sglen_cbfn, rsp_sga_cbfn, rsp_sglen_cbfn);\n\n\treturn fcxp;\n}\n\n \nvoid *\nbfa_fcxp_get_reqbuf(struct bfa_fcxp_s *fcxp)\n{\n\tstruct bfa_fcxp_mod_s *mod = fcxp->fcxp_mod;\n\tvoid\t*reqbuf;\n\n\tWARN_ON(fcxp->use_ireqbuf != 1);\n\treqbuf = bfa_mem_get_dmabuf_kva(mod, fcxp->fcxp_tag,\n\t\t\t\tmod->req_pld_sz + mod->rsp_pld_sz);\n\treturn reqbuf;\n}\n\nu32\nbfa_fcxp_get_reqbufsz(struct bfa_fcxp_s *fcxp)\n{\n\tstruct bfa_fcxp_mod_s *mod = fcxp->fcxp_mod;\n\n\treturn mod->req_pld_sz;\n}\n\n \nvoid *\nbfa_fcxp_get_rspbuf(struct bfa_fcxp_s *fcxp)\n{\n\tstruct bfa_fcxp_mod_s *mod = fcxp->fcxp_mod;\n\tvoid\t*fcxp_buf;\n\n\tWARN_ON(fcxp->use_irspbuf != 1);\n\n\tfcxp_buf = bfa_mem_get_dmabuf_kva(mod, fcxp->fcxp_tag,\n\t\t\t\tmod->req_pld_sz + mod->rsp_pld_sz);\n\n\t \n\treturn ((u8 *) fcxp_buf) + mod->req_pld_sz;\n}\n\n \nvoid\nbfa_fcxp_free(struct bfa_fcxp_s *fcxp)\n{\n\tstruct bfa_fcxp_mod_s *mod = fcxp->fcxp_mod;\n\n\tWARN_ON(fcxp == NULL);\n\tbfa_trc(mod->bfa, fcxp->fcxp_tag);\n\tbfa_fcxp_put(fcxp);\n}\n\n \nvoid\nbfa_fcxp_send(struct bfa_fcxp_s *fcxp, struct bfa_rport_s *rport,\n\t      u16 vf_id, u8 lp_tag, bfa_boolean_t cts, enum fc_cos cos,\n\t      u32 reqlen, struct fchs_s *fchs, bfa_cb_fcxp_send_t cbfn,\n\t      void *cbarg, u32 rsp_maxlen, u8 rsp_timeout)\n{\n\tstruct bfa_s\t\t\t*bfa  = fcxp->fcxp_mod->bfa;\n\tstruct bfa_fcxp_req_info_s\t*reqi = &fcxp->req_info;\n\tstruct bfa_fcxp_rsp_info_s\t*rspi = &fcxp->rsp_info;\n\tstruct bfi_fcxp_send_req_s\t*send_req;\n\n\tbfa_trc(bfa, fcxp->fcxp_tag);\n\n\t \n\treqi->bfa_rport = rport;\n\treqi->vf_id = vf_id;\n\treqi->lp_tag = lp_tag;\n\treqi->class = cos;\n\trspi->rsp_timeout = rsp_timeout;\n\treqi->cts = cts;\n\treqi->fchs = *fchs;\n\treqi->req_tot_len = reqlen;\n\trspi->rsp_maxlen = rsp_maxlen;\n\tfcxp->send_cbfn = cbfn ? cbfn : bfa_fcxp_null_comp;\n\tfcxp->send_cbarg = cbarg;\n\n\t \n\tsend_req = bfa_reqq_next(bfa, BFA_REQQ_FCXP);\n\tif (!send_req) {\n\t\tbfa_trc(bfa, fcxp->fcxp_tag);\n\t\tfcxp->reqq_waiting = BFA_TRUE;\n\t\tbfa_reqq_wait(bfa, BFA_REQQ_FCXP, &fcxp->reqq_wqe);\n\t\treturn;\n\t}\n\n\tbfa_fcxp_queue(fcxp, send_req);\n}\n\n \nbfa_status_t\nbfa_fcxp_abort(struct bfa_fcxp_s *fcxp)\n{\n\tbfa_trc(fcxp->fcxp_mod->bfa, fcxp->fcxp_tag);\n\tWARN_ON(1);\n\treturn BFA_STATUS_OK;\n}\n\nvoid\nbfa_fcxp_req_rsp_alloc_wait(struct bfa_s *bfa, struct bfa_fcxp_wqe_s *wqe,\n\t       bfa_fcxp_alloc_cbfn_t alloc_cbfn, void *alloc_cbarg,\n\t       void *caller, int nreq_sgles,\n\t       int nrsp_sgles, bfa_fcxp_get_sgaddr_t req_sga_cbfn,\n\t       bfa_fcxp_get_sglen_t req_sglen_cbfn,\n\t       bfa_fcxp_get_sgaddr_t rsp_sga_cbfn,\n\t       bfa_fcxp_get_sglen_t rsp_sglen_cbfn, bfa_boolean_t req)\n{\n\tstruct bfa_fcxp_mod_s *mod = BFA_FCXP_MOD(bfa);\n\n\tif (req)\n\t\tWARN_ON(!list_empty(&mod->fcxp_req_free_q));\n\telse\n\t\tWARN_ON(!list_empty(&mod->fcxp_rsp_free_q));\n\n\twqe->alloc_cbfn = alloc_cbfn;\n\twqe->alloc_cbarg = alloc_cbarg;\n\twqe->caller = caller;\n\twqe->bfa = bfa;\n\twqe->nreq_sgles = nreq_sgles;\n\twqe->nrsp_sgles = nrsp_sgles;\n\twqe->req_sga_cbfn = req_sga_cbfn;\n\twqe->req_sglen_cbfn = req_sglen_cbfn;\n\twqe->rsp_sga_cbfn = rsp_sga_cbfn;\n\twqe->rsp_sglen_cbfn = rsp_sglen_cbfn;\n\n\tif (req)\n\t\tlist_add_tail(&wqe->qe, &mod->req_wait_q);\n\telse\n\t\tlist_add_tail(&wqe->qe, &mod->rsp_wait_q);\n}\n\nvoid\nbfa_fcxp_walloc_cancel(struct bfa_s *bfa, struct bfa_fcxp_wqe_s *wqe)\n{\n\tstruct bfa_fcxp_mod_s *mod = BFA_FCXP_MOD(bfa);\n\n\tWARN_ON(!bfa_q_is_on_q(&mod->req_wait_q, wqe) ||\n\t\t!bfa_q_is_on_q(&mod->rsp_wait_q, wqe));\n\tlist_del(&wqe->qe);\n}\n\nvoid\nbfa_fcxp_discard(struct bfa_fcxp_s *fcxp)\n{\n\t \n\tif (fcxp->reqq_waiting) {\n\t\tfcxp->reqq_waiting = BFA_FALSE;\n\t\tbfa_reqq_wcancel(&fcxp->reqq_wqe);\n\t\tbfa_fcxp_free(fcxp);\n\t\treturn;\n\t}\n\n\tfcxp->send_cbfn = bfa_fcxp_null_comp;\n}\n\nvoid\nbfa_fcxp_isr(struct bfa_s *bfa, struct bfi_msg_s *msg)\n{\n\tswitch (msg->mhdr.msg_id) {\n\tcase BFI_FCXP_I2H_SEND_RSP:\n\t\thal_fcxp_send_comp(bfa, (struct bfi_fcxp_send_rsp_s *) msg);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_trc(bfa, msg->mhdr.msg_id);\n\t\tWARN_ON(1);\n\t}\n}\n\nu32\nbfa_fcxp_get_maxrsp(struct bfa_s *bfa)\n{\n\tstruct bfa_fcxp_mod_s *mod = BFA_FCXP_MOD(bfa);\n\n\treturn mod->rsp_pld_sz;\n}\n\nvoid\nbfa_fcxp_res_recfg(struct bfa_s *bfa, u16 num_fcxp_fw)\n{\n\tstruct bfa_fcxp_mod_s\t*mod = BFA_FCXP_MOD(bfa);\n\tstruct list_head\t*qe;\n\tint\ti;\n\n\tfor (i = 0; i < (mod->num_fcxps - num_fcxp_fw); i++) {\n\t\tif (i < ((mod->num_fcxps - num_fcxp_fw) / 2)) {\n\t\t\tbfa_q_deq_tail(&mod->fcxp_req_free_q, &qe);\n\t\t\tlist_add_tail(qe, &mod->fcxp_req_unused_q);\n\t\t} else {\n\t\t\tbfa_q_deq_tail(&mod->fcxp_rsp_free_q, &qe);\n\t\t\tlist_add_tail(qe, &mod->fcxp_rsp_unused_q);\n\t\t}\n\t}\n}\n\n \n\n \nstatic void\nbfa_lps_sm_init(struct bfa_lps_s *lps, enum bfa_lps_event event)\n{\n\tbfa_trc(lps->bfa, lps->bfa_tag);\n\tbfa_trc(lps->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_LPS_SM_LOGIN:\n\t\tif (bfa_reqq_full(lps->bfa, lps->reqq)) {\n\t\t\tbfa_sm_set_state(lps, bfa_lps_sm_loginwait);\n\t\t\tbfa_reqq_wait(lps->bfa, lps->reqq, &lps->wqe);\n\t\t} else {\n\t\t\tbfa_sm_set_state(lps, bfa_lps_sm_login);\n\t\t\tbfa_lps_send_login(lps);\n\t\t}\n\n\t\tif (lps->fdisc)\n\t\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\t\tBFA_PL_EID_LOGIN, 0, \"FDISC Request\");\n\t\telse\n\t\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\t\tBFA_PL_EID_LOGIN, 0, \"FLOGI Request\");\n\t\tbreak;\n\n\tcase BFA_LPS_SM_LOGOUT:\n\t\tbfa_lps_logout_comp(lps);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_DELETE:\n\t\tbfa_lps_free(lps);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_RX_CVL:\n\tcase BFA_LPS_SM_OFFLINE:\n\t\tbreak;\n\n\tcase BFA_LPS_SM_FWRSP:\n\t\t \n\t\tbreak;\n\tcase BFA_LPS_SM_SET_N2N_PID:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(lps->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_lps_sm_login(struct bfa_lps_s *lps, enum bfa_lps_event event)\n{\n\tbfa_trc(lps->bfa, lps->bfa_tag);\n\tbfa_trc(lps->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_LPS_SM_FWRSP:\n\t\tif (lps->status == BFA_STATUS_OK) {\n\t\t\tbfa_sm_set_state(lps, bfa_lps_sm_online);\n\t\t\tif (lps->fdisc)\n\t\t\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\t\t\tBFA_PL_EID_LOGIN, 0, \"FDISC Accept\");\n\t\t\telse\n\t\t\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\t\t\tBFA_PL_EID_LOGIN, 0, \"FLOGI Accept\");\n\t\t\t \n\t\t\tbfa_trc(lps->bfa, lps->fport);\n\t\t\tbfa_trc(lps->bfa, lps->lp_pid);\n\n\t\t\tif (!lps->fport && lps->lp_pid)\n\t\t\t\tbfa_sm_send_event(lps, BFA_LPS_SM_SET_N2N_PID);\n\t\t} else {\n\t\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\t\tif (lps->fdisc)\n\t\t\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\t\t\tBFA_PL_EID_LOGIN, 0,\n\t\t\t\t\t\"FDISC Fail (RJT or timeout)\");\n\t\t\telse\n\t\t\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\t\t\tBFA_PL_EID_LOGIN, 0,\n\t\t\t\t\t\"FLOGI Fail (RJT or timeout)\");\n\t\t}\n\t\tbfa_lps_login_comp(lps);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_OFFLINE:\n\tcase BFA_LPS_SM_DELETE:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_SET_N2N_PID:\n\t\tbfa_trc(lps->bfa, lps->fport);\n\t\tbfa_trc(lps->bfa, lps->lp_pid);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(lps->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_lps_sm_loginwait(struct bfa_lps_s *lps, enum bfa_lps_event event)\n{\n\tbfa_trc(lps->bfa, lps->bfa_tag);\n\tbfa_trc(lps->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_LPS_SM_RESUME:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_login);\n\t\tbfa_lps_send_login(lps);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_OFFLINE:\n\tcase BFA_LPS_SM_DELETE:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\tbfa_reqq_wcancel(&lps->wqe);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_RX_CVL:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(lps->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_lps_sm_online(struct bfa_lps_s *lps, enum bfa_lps_event event)\n{\n\tbfa_trc(lps->bfa, lps->bfa_tag);\n\tbfa_trc(lps->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_LPS_SM_LOGOUT:\n\t\tif (bfa_reqq_full(lps->bfa, lps->reqq)) {\n\t\t\tbfa_sm_set_state(lps, bfa_lps_sm_logowait);\n\t\t\tbfa_reqq_wait(lps->bfa, lps->reqq, &lps->wqe);\n\t\t} else {\n\t\t\tbfa_sm_set_state(lps, bfa_lps_sm_logout);\n\t\t\tbfa_lps_send_logout(lps);\n\t\t}\n\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\tBFA_PL_EID_LOGO, 0, \"Logout\");\n\t\tbreak;\n\n\tcase BFA_LPS_SM_RX_CVL:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\n\t\t \n\t\tbfa_lps_cvl_event(lps);\n\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\tBFA_PL_EID_FIP_FCF_CVL, 0, \"FCF Clear Virt. Link Rx\");\n\t\tbreak;\n\n\tcase BFA_LPS_SM_SET_N2N_PID:\n\t\tif (bfa_reqq_full(lps->bfa, lps->reqq)) {\n\t\t\tbfa_sm_set_state(lps, bfa_lps_sm_online_n2n_pid_wait);\n\t\t\tbfa_reqq_wait(lps->bfa, lps->reqq, &lps->wqe);\n\t\t} else\n\t\t\tbfa_lps_send_set_n2n_pid(lps);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_OFFLINE:\n\tcase BFA_LPS_SM_DELETE:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(lps->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_lps_sm_online_n2n_pid_wait(struct bfa_lps_s *lps, enum bfa_lps_event event)\n{\n\tbfa_trc(lps->bfa, lps->bfa_tag);\n\tbfa_trc(lps->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_LPS_SM_RESUME:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_online);\n\t\tbfa_lps_send_set_n2n_pid(lps);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_LOGOUT:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_logowait);\n\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\tBFA_PL_EID_LOGO, 0, \"Logout\");\n\t\tbreak;\n\n\tcase BFA_LPS_SM_RX_CVL:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\tbfa_reqq_wcancel(&lps->wqe);\n\n\t\t \n\t\tbfa_lps_cvl_event(lps);\n\t\tbfa_plog_str(lps->bfa->plog, BFA_PL_MID_LPS,\n\t\t\tBFA_PL_EID_FIP_FCF_CVL, 0, \"FCF Clear Virt. Link Rx\");\n\t\tbreak;\n\n\tcase BFA_LPS_SM_OFFLINE:\n\tcase BFA_LPS_SM_DELETE:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\tbfa_reqq_wcancel(&lps->wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(lps->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_lps_sm_logout(struct bfa_lps_s *lps, enum bfa_lps_event event)\n{\n\tbfa_trc(lps->bfa, lps->bfa_tag);\n\tbfa_trc(lps->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_LPS_SM_FWRSP:\n\tcase BFA_LPS_SM_OFFLINE:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\tbfa_lps_logout_comp(lps);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_DELETE:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(lps->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_lps_sm_logowait(struct bfa_lps_s *lps, enum bfa_lps_event event)\n{\n\tbfa_trc(lps->bfa, lps->bfa_tag);\n\tbfa_trc(lps->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_LPS_SM_RESUME:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_logout);\n\t\tbfa_lps_send_logout(lps);\n\t\tbreak;\n\n\tcase BFA_LPS_SM_OFFLINE:\n\tcase BFA_LPS_SM_DELETE:\n\t\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\t\tbfa_reqq_wcancel(&lps->wqe);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(lps->bfa, event);\n\t}\n}\n\n\n\n \n\n \nvoid\nbfa_lps_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *minfo,\n\t\tstruct bfa_s *bfa)\n{\n\tstruct bfa_mem_kva_s *lps_kva = BFA_MEM_LPS_KVA(bfa);\n\n\tif (cfg->drvcfg.min_cfg)\n\t\tbfa_mem_kva_setup(minfo, lps_kva,\n\t\t\tsizeof(struct bfa_lps_s) * BFA_LPS_MIN_LPORTS);\n\telse\n\t\tbfa_mem_kva_setup(minfo, lps_kva,\n\t\t\tsizeof(struct bfa_lps_s) * BFA_LPS_MAX_LPORTS);\n}\n\n \nvoid\nbfa_lps_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\tstruct bfa_pcidev_s *pcidev)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\tstruct bfa_lps_s\t*lps;\n\tint\t\t\ti;\n\n\tmod->num_lps = BFA_LPS_MAX_LPORTS;\n\tif (cfg->drvcfg.min_cfg)\n\t\tmod->num_lps = BFA_LPS_MIN_LPORTS;\n\telse\n\t\tmod->num_lps = BFA_LPS_MAX_LPORTS;\n\tmod->lps_arr = lps = (struct bfa_lps_s *) bfa_mem_kva_curp(mod);\n\n\tbfa_mem_kva_curp(mod) += mod->num_lps * sizeof(struct bfa_lps_s);\n\n\tINIT_LIST_HEAD(&mod->lps_free_q);\n\tINIT_LIST_HEAD(&mod->lps_active_q);\n\tINIT_LIST_HEAD(&mod->lps_login_q);\n\n\tfor (i = 0; i < mod->num_lps; i++, lps++) {\n\t\tlps->bfa\t= bfa;\n\t\tlps->bfa_tag\t= (u8) i;\n\t\tlps->reqq\t= BFA_REQQ_LPS;\n\t\tbfa_reqq_winit(&lps->wqe, bfa_lps_reqq_resume, lps);\n\t\tlist_add_tail(&lps->qe, &mod->lps_free_q);\n\t}\n}\n\n \nvoid\nbfa_lps_iocdisable(struct bfa_s *bfa)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\tstruct bfa_lps_s\t*lps;\n\tstruct list_head\t\t*qe, *qen;\n\n\tlist_for_each_safe(qe, qen, &mod->lps_active_q) {\n\t\tlps = (struct bfa_lps_s *) qe;\n\t\tbfa_sm_send_event(lps, BFA_LPS_SM_OFFLINE);\n\t}\n\tlist_for_each_safe(qe, qen, &mod->lps_login_q) {\n\t\tlps = (struct bfa_lps_s *) qe;\n\t\tbfa_sm_send_event(lps, BFA_LPS_SM_OFFLINE);\n\t}\n\tlist_splice_tail_init(&mod->lps_login_q, &mod->lps_active_q);\n}\n\n \nstatic void\nbfa_lps_login_rsp(struct bfa_s *bfa, struct bfi_lps_login_rsp_s *rsp)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\tstruct bfa_lps_s\t*lps;\n\n\tWARN_ON(rsp->bfa_tag >= mod->num_lps);\n\tlps = BFA_LPS_FROM_TAG(mod, rsp->bfa_tag);\n\n\tlps->status = rsp->status;\n\tswitch (rsp->status) {\n\tcase BFA_STATUS_OK:\n\t\tlps->fw_tag\t= rsp->fw_tag;\n\t\tlps->fport\t= rsp->f_port;\n\t\tif (lps->fport)\n\t\t\tlps->lp_pid = rsp->lp_pid;\n\t\tlps->npiv_en\t= rsp->npiv_en;\n\t\tlps->pr_bbcred\t= be16_to_cpu(rsp->bb_credit);\n\t\tlps->pr_pwwn\t= rsp->port_name;\n\t\tlps->pr_nwwn\t= rsp->node_name;\n\t\tlps->auth_req\t= rsp->auth_req;\n\t\tlps->lp_mac\t= rsp->lp_mac;\n\t\tlps->brcd_switch = rsp->brcd_switch;\n\t\tlps->fcf_mac\t= rsp->fcf_mac;\n\n\t\tbreak;\n\n\tcase BFA_STATUS_FABRIC_RJT:\n\t\tlps->lsrjt_rsn = rsp->lsrjt_rsn;\n\t\tlps->lsrjt_expl = rsp->lsrjt_expl;\n\n\t\tbreak;\n\n\tcase BFA_STATUS_EPROTOCOL:\n\t\tlps->ext_status = rsp->ext_status;\n\n\t\tbreak;\n\n\tcase BFA_STATUS_VPORT_MAX:\n\t\tif (rsp->ext_status)\n\t\t\tbfa_lps_no_res(lps, rsp->ext_status);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tlist_del(&lps->qe);\n\tlist_add_tail(&lps->qe, &mod->lps_active_q);\n\tbfa_sm_send_event(lps, BFA_LPS_SM_FWRSP);\n}\n\nstatic void\nbfa_lps_no_res(struct bfa_lps_s *first_lps, u8 count)\n{\n\tstruct bfa_s\t\t*bfa = first_lps->bfa;\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\tstruct list_head\t*qe, *qe_next;\n\tstruct bfa_lps_s\t*lps;\n\n\tbfa_trc(bfa, count);\n\n\tqe = bfa_q_next(first_lps);\n\n\twhile (count && qe) {\n\t\tqe_next = bfa_q_next(qe);\n\t\tlps = (struct bfa_lps_s *)qe;\n\t\tbfa_trc(bfa, lps->bfa_tag);\n\t\tlps->status = first_lps->status;\n\t\tlist_del(&lps->qe);\n\t\tlist_add_tail(&lps->qe, &mod->lps_active_q);\n\t\tbfa_sm_send_event(lps, BFA_LPS_SM_FWRSP);\n\t\tqe = qe_next;\n\t\tcount--;\n\t}\n}\n\n \nstatic void\nbfa_lps_logout_rsp(struct bfa_s *bfa, struct bfi_lps_logout_rsp_s *rsp)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\tstruct bfa_lps_s\t*lps;\n\n\tWARN_ON(rsp->bfa_tag >= mod->num_lps);\n\tlps = BFA_LPS_FROM_TAG(mod, rsp->bfa_tag);\n\n\tbfa_sm_send_event(lps, BFA_LPS_SM_FWRSP);\n}\n\n \nstatic void\nbfa_lps_rx_cvl_event(struct bfa_s *bfa, struct bfi_lps_cvl_event_s *cvl)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\tstruct bfa_lps_s\t*lps;\n\n\tlps = BFA_LPS_FROM_TAG(mod, cvl->bfa_tag);\n\n\tbfa_sm_send_event(lps, BFA_LPS_SM_RX_CVL);\n}\n\n \nstatic void\nbfa_lps_reqq_resume(void *lps_arg)\n{\n\tstruct bfa_lps_s\t*lps = lps_arg;\n\n\tbfa_sm_send_event(lps, BFA_LPS_SM_RESUME);\n}\n\n \nstatic void\nbfa_lps_free(struct bfa_lps_s *lps)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(lps->bfa);\n\n\tlps->lp_pid = 0;\n\tlist_del(&lps->qe);\n\tlist_add_tail(&lps->qe, &mod->lps_free_q);\n}\n\n \nstatic void\nbfa_lps_send_login(struct bfa_lps_s *lps)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(lps->bfa);\n\tstruct bfi_lps_login_req_s\t*m;\n\n\tm = bfa_reqq_next(lps->bfa, lps->reqq);\n\tWARN_ON(!m);\n\n\tbfi_h2i_set(m->mh, BFI_MC_LPS, BFI_LPS_H2I_LOGIN_REQ,\n\t\tbfa_fn_lpu(lps->bfa));\n\n\tm->bfa_tag\t= lps->bfa_tag;\n\tm->alpa\t\t= lps->alpa;\n\tm->pdu_size\t= cpu_to_be16(lps->pdusz);\n\tm->pwwn\t\t= lps->pwwn;\n\tm->nwwn\t\t= lps->nwwn;\n\tm->fdisc\t= lps->fdisc;\n\tm->auth_en\t= lps->auth_en;\n\n\tbfa_reqq_produce(lps->bfa, lps->reqq, m->mh);\n\tlist_del(&lps->qe);\n\tlist_add_tail(&lps->qe, &mod->lps_login_q);\n}\n\n \nstatic void\nbfa_lps_send_logout(struct bfa_lps_s *lps)\n{\n\tstruct bfi_lps_logout_req_s *m;\n\n\tm = bfa_reqq_next(lps->bfa, lps->reqq);\n\tWARN_ON(!m);\n\n\tbfi_h2i_set(m->mh, BFI_MC_LPS, BFI_LPS_H2I_LOGOUT_REQ,\n\t\tbfa_fn_lpu(lps->bfa));\n\n\tm->fw_tag = lps->fw_tag;\n\tm->port_name = lps->pwwn;\n\tbfa_reqq_produce(lps->bfa, lps->reqq, m->mh);\n}\n\n \nstatic void\nbfa_lps_send_set_n2n_pid(struct bfa_lps_s *lps)\n{\n\tstruct bfi_lps_n2n_pid_req_s *m;\n\n\tm = bfa_reqq_next(lps->bfa, lps->reqq);\n\tWARN_ON(!m);\n\n\tbfi_h2i_set(m->mh, BFI_MC_LPS, BFI_LPS_H2I_N2N_PID_REQ,\n\t\tbfa_fn_lpu(lps->bfa));\n\n\tm->fw_tag = lps->fw_tag;\n\tm->lp_pid = lps->lp_pid;\n\tbfa_reqq_produce(lps->bfa, lps->reqq, m->mh);\n}\n\n \nstatic void\nbfa_lps_login_comp_cb(void *arg, bfa_boolean_t complete)\n{\n\tstruct bfa_lps_s *lps\t= arg;\n\n\tif (!complete)\n\t\treturn;\n\n\tif (lps->fdisc)\n\t\tbfa_cb_lps_fdisc_comp(lps->bfa->bfad, lps->uarg, lps->status);\n\telse\n\t\tbfa_cb_lps_flogi_comp(lps->bfa->bfad, lps->uarg, lps->status);\n}\n\n \nstatic void\nbfa_lps_login_comp(struct bfa_lps_s *lps)\n{\n\tif (!lps->bfa->fcs) {\n\t\tbfa_cb_queue(lps->bfa, &lps->hcb_qe, bfa_lps_login_comp_cb,\n\t\t\tlps);\n\t\treturn;\n\t}\n\n\tif (lps->fdisc)\n\t\tbfa_cb_lps_fdisc_comp(lps->bfa->bfad, lps->uarg, lps->status);\n\telse\n\t\tbfa_cb_lps_flogi_comp(lps->bfa->bfad, lps->uarg, lps->status);\n}\n\n \nstatic void\nbfa_lps_logout_comp_cb(void *arg, bfa_boolean_t complete)\n{\n\tstruct bfa_lps_s *lps\t= arg;\n\n\tif (!complete)\n\t\treturn;\n\n\tif (lps->fdisc)\n\t\tbfa_cb_lps_fdisclogo_comp(lps->bfa->bfad, lps->uarg);\n\telse\n\t\tbfa_cb_lps_flogo_comp(lps->bfa->bfad, lps->uarg);\n}\n\n \nstatic void\nbfa_lps_logout_comp(struct bfa_lps_s *lps)\n{\n\tif (!lps->bfa->fcs) {\n\t\tbfa_cb_queue(lps->bfa, &lps->hcb_qe, bfa_lps_logout_comp_cb,\n\t\t\tlps);\n\t\treturn;\n\t}\n\tif (lps->fdisc)\n\t\tbfa_cb_lps_fdisclogo_comp(lps->bfa->bfad, lps->uarg);\n}\n\n \nstatic void\nbfa_lps_cvl_event_cb(void *arg, bfa_boolean_t complete)\n{\n\tstruct bfa_lps_s *lps\t= arg;\n\n\tif (!complete)\n\t\treturn;\n\n\t \n\tif (lps->fdisc)\n\t\tbfa_cb_lps_cvl_event(lps->bfa->bfad, lps->uarg);\n}\n\n \nstatic void\nbfa_lps_cvl_event(struct bfa_lps_s *lps)\n{\n\tif (!lps->bfa->fcs) {\n\t\tbfa_cb_queue(lps->bfa, &lps->hcb_qe, bfa_lps_cvl_event_cb,\n\t\t\tlps);\n\t\treturn;\n\t}\n\n\t \n\tif (lps->fdisc)\n\t\tbfa_cb_lps_cvl_event(lps->bfa->bfad, lps->uarg);\n}\n\n\n\n \n\nu32\nbfa_lps_get_max_vport(struct bfa_s *bfa)\n{\n\tif (bfa_ioc_devid(&bfa->ioc) == BFA_PCI_DEVICE_ID_CT)\n\t\treturn BFA_LPS_MAX_VPORTS_SUPP_CT;\n\telse\n\t\treturn BFA_LPS_MAX_VPORTS_SUPP_CB;\n}\n\n \nstruct bfa_lps_s  *\nbfa_lps_alloc(struct bfa_s *bfa)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\tstruct bfa_lps_s\t*lps = NULL;\n\n\tbfa_q_deq(&mod->lps_free_q, &lps);\n\n\tif (lps == NULL)\n\t\treturn NULL;\n\n\tlist_add_tail(&lps->qe, &mod->lps_active_q);\n\n\tbfa_sm_set_state(lps, bfa_lps_sm_init);\n\treturn lps;\n}\n\n \nvoid\nbfa_lps_delete(struct bfa_lps_s *lps)\n{\n\tbfa_sm_send_event(lps, BFA_LPS_SM_DELETE);\n}\n\n \nvoid\nbfa_lps_flogi(struct bfa_lps_s *lps, void *uarg, u8 alpa, u16 pdusz,\n\twwn_t pwwn, wwn_t nwwn, bfa_boolean_t auth_en)\n{\n\tlps->uarg\t= uarg;\n\tlps->alpa\t= alpa;\n\tlps->pdusz\t= pdusz;\n\tlps->pwwn\t= pwwn;\n\tlps->nwwn\t= nwwn;\n\tlps->fdisc\t= BFA_FALSE;\n\tlps->auth_en\t= auth_en;\n\tbfa_sm_send_event(lps, BFA_LPS_SM_LOGIN);\n}\n\n \nvoid\nbfa_lps_fdisc(struct bfa_lps_s *lps, void *uarg, u16 pdusz, wwn_t pwwn,\n\twwn_t nwwn)\n{\n\tlps->uarg\t= uarg;\n\tlps->alpa\t= 0;\n\tlps->pdusz\t= pdusz;\n\tlps->pwwn\t= pwwn;\n\tlps->nwwn\t= nwwn;\n\tlps->fdisc\t= BFA_TRUE;\n\tlps->auth_en\t= BFA_FALSE;\n\tbfa_sm_send_event(lps, BFA_LPS_SM_LOGIN);\n}\n\n\n \nvoid\nbfa_lps_fdisclogo(struct bfa_lps_s *lps)\n{\n\tbfa_sm_send_event(lps, BFA_LPS_SM_LOGOUT);\n}\n\nu8\nbfa_lps_get_fwtag(struct bfa_s *bfa, u8 lp_tag)\n{\n\tstruct bfa_lps_mod_s    *mod = BFA_LPS_MOD(bfa);\n\n\treturn BFA_LPS_FROM_TAG(mod, lp_tag)->fw_tag;\n}\n\n \nu8\nbfa_lps_get_tag_from_pid(struct bfa_s *bfa, u32 pid)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\tstruct bfa_lps_s\t*lps;\n\tint\t\t\ti;\n\n\tfor (i = 0, lps = mod->lps_arr; i < mod->num_lps; i++, lps++) {\n\t\tif (lps->lp_pid == pid)\n\t\t\treturn lps->bfa_tag;\n\t}\n\n\t \n\treturn 0;\n}\n\n\n \nu32\nbfa_lps_get_base_pid(struct bfa_s *bfa)\n{\n\tstruct bfa_lps_mod_s\t*mod = BFA_LPS_MOD(bfa);\n\n\treturn BFA_LPS_FROM_TAG(mod, 0)->lp_pid;\n}\n\n \nvoid\nbfa_lps_set_n2n_pid(struct bfa_lps_s *lps, uint32_t n2n_pid)\n{\n\tbfa_trc(lps->bfa, lps->bfa_tag);\n\tbfa_trc(lps->bfa, n2n_pid);\n\n\tlps->lp_pid = n2n_pid;\n\tbfa_sm_send_event(lps, BFA_LPS_SM_SET_N2N_PID);\n}\n\n \nvoid\nbfa_lps_isr(struct bfa_s *bfa, struct bfi_msg_s *m)\n{\n\tunion bfi_lps_i2h_msg_u\tmsg;\n\n\tbfa_trc(bfa, m->mhdr.msg_id);\n\tmsg.msg = m;\n\n\tswitch (m->mhdr.msg_id) {\n\tcase BFI_LPS_I2H_LOGIN_RSP:\n\t\tbfa_lps_login_rsp(bfa, msg.login_rsp);\n\t\tbreak;\n\n\tcase BFI_LPS_I2H_LOGOUT_RSP:\n\t\tbfa_lps_logout_rsp(bfa, msg.logout_rsp);\n\t\tbreak;\n\n\tcase BFI_LPS_I2H_CVL_EVENT:\n\t\tbfa_lps_rx_cvl_event(bfa, msg.cvl_event);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_trc(bfa, m->mhdr.msg_id);\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic void\nbfa_fcport_aen_post(struct bfa_fcport_s *fcport, enum bfa_port_aen_event event)\n{\n\tstruct bfad_s *bfad = (struct bfad_s *)fcport->bfa->bfad;\n\tstruct bfa_aen_entry_s  *aen_entry;\n\n\tbfad_get_aen_entry(bfad, aen_entry);\n\tif (!aen_entry)\n\t\treturn;\n\n\taen_entry->aen_data.port.ioc_type = bfa_get_type(fcport->bfa);\n\taen_entry->aen_data.port.pwwn = fcport->pwwn;\n\n\t \n\tbfad_im_post_vendor_event(aen_entry, bfad, ++fcport->bfa->bfa_aen_seq,\n\t\t\t\t  BFA_AEN_CAT_PORT, event);\n}\n\n \nstatic void\nbfa_fcport_sm_uninit(struct bfa_fcport_s *fcport,\n\t\t\tenum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_START:\n\t\t \n\t\tfcport->use_flash_cfg = BFA_TRUE;\n\n\t\tif (bfa_fcport_send_enable(fcport)) {\n\t\t\tbfa_trc(fcport->bfa, BFA_TRUE);\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_enabling);\n\t\t} else {\n\t\t\tbfa_trc(fcport->bfa, BFA_FALSE);\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\tbfa_fcport_sm_enabling_qwait);\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\t \n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabled);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_enabling_qwait(struct bfa_fcport_s *fcport,\n\t\t\t\tenum bfa_fcport_sm_event event)\n{\n\tchar pwwn_buf[BFA_STRING_32];\n\tstruct bfad_s *bfad = (struct bfad_s *)fcport->bfa->bfad;\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_enabling);\n\t\tbfa_fcport_send_enable(fcport);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_reqq_wcancel(&fcport->reqq_wait);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\t \n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabled);\n\t\tbfa_reqq_wcancel(&fcport->reqq_wait);\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\tBFA_PL_EID_PORT_DISABLE, 0, \"Port Disable\");\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\"Base port disabled: WWN = %s\\n\", pwwn_buf);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_LINKUP:\n\tcase BFA_FCPORT_SM_LINKDOWN:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_reqq_wcancel(&fcport->reqq_wait);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_FAA_MISCONFIG:\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_faa_misconfig);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_enabling(struct bfa_fcport_s *fcport,\n\t\t\t\t\t\tenum bfa_fcport_sm_event event)\n{\n\tchar pwwn_buf[BFA_STRING_32];\n\tstruct bfad_s *bfad = (struct bfad_s *)fcport->bfa->bfad;\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_FWRSP:\n\tcase BFA_FCPORT_SM_LINKDOWN:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_linkdown);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_LINKUP:\n\t\tbfa_fcport_update_linkinfo(fcport);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_linkup);\n\n\t\tWARN_ON(!fcport->event_cbfn);\n\t\tbfa_fcport_scn(fcport, BFA_PORT_LINKUP, BFA_FALSE);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\tif (bfa_fcport_send_disable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\t bfa_fcport_sm_disabling_qwait);\n\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\tBFA_PL_EID_PORT_DISABLE, 0, \"Port Disable\");\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\"Base port disabled: WWN = %s\\n\", pwwn_buf);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_FAA_MISCONFIG:\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_faa_misconfig);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_linkdown(struct bfa_fcport_s *fcport,\n\t\t\t\t\t\tenum bfa_fcport_sm_event event)\n{\n\tstruct bfi_fcport_event_s *pevent = fcport->event_arg.i2hmsg.event;\n\tchar pwwn_buf[BFA_STRING_32];\n\tstruct bfad_s *bfad = (struct bfad_s *)fcport->bfa->bfad;\n\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_LINKUP:\n\t\tbfa_fcport_update_linkinfo(fcport);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_linkup);\n\t\tWARN_ON(!fcport->event_cbfn);\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\tBFA_PL_EID_PORT_ST_CHANGE, 0, \"Port Linkup\");\n\t\tif (!bfa_ioc_get_fcmode(&fcport->bfa->ioc)) {\n\n\t\t\tbfa_trc(fcport->bfa,\n\t\t\t\tpevent->link_state.attr.vc_fcf.fcf.fipenabled);\n\t\t\tbfa_trc(fcport->bfa,\n\t\t\t\tpevent->link_state.attr.vc_fcf.fcf.fipfailed);\n\n\t\t\tif (pevent->link_state.attr.vc_fcf.fcf.fipfailed)\n\t\t\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\t\tBFA_PL_EID_FIP_FCF_DISC, 0,\n\t\t\t\t\t\"FIP FCF Discovery Failed\");\n\t\t\telse\n\t\t\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\t\tBFA_PL_EID_FIP_FCF_DISC, 0,\n\t\t\t\t\t\"FIP FCF Discovered\");\n\t\t}\n\n\t\tbfa_fcport_scn(fcport, BFA_PORT_LINKUP, BFA_FALSE);\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\"Base port online: WWN = %s\\n\", pwwn_buf);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_ONLINE);\n\n\t\t \n\t\tif (fcport->cfg.qos_enabled &&\n\t\t    fcport->qos_attr.state != BFA_QOS_ONLINE)\n\t\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_QOS_NEG);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_LINKDOWN:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\tif (bfa_fcport_send_disable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\t bfa_fcport_sm_disabling_qwait);\n\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\tBFA_PL_EID_PORT_DISABLE, 0, \"Port Disable\");\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\"Base port disabled: WWN = %s\\n\", pwwn_buf);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_FAA_MISCONFIG:\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_faa_misconfig);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_linkup(struct bfa_fcport_s *fcport,\n\tenum bfa_fcport_sm_event event)\n{\n\tchar pwwn_buf[BFA_STRING_32];\n\tstruct bfad_s *bfad = (struct bfad_s *)fcport->bfa->bfad;\n\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\tif (bfa_fcport_send_disable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\t bfa_fcport_sm_disabling_qwait);\n\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_scn(fcport, BFA_PORT_LINKDOWN, BFA_FALSE);\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\tBFA_PL_EID_PORT_DISABLE, 0, \"Port Disable\");\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\"Base port offline: WWN = %s\\n\", pwwn_buf);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_OFFLINE);\n\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\"Base port disabled: WWN = %s\\n\", pwwn_buf);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_LINKDOWN:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_linkdown);\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_scn(fcport, BFA_PORT_LINKDOWN, BFA_FALSE);\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\tBFA_PL_EID_PORT_ST_CHANGE, 0, \"Port Linkdown\");\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tif (BFA_PORT_IS_DISABLED(fcport->bfa)) {\n\t\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\t\"Base port offline: WWN = %s\\n\", pwwn_buf);\n\t\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_OFFLINE);\n\t\t} else {\n\t\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\t\"Base port (WWN = %s) \"\n\t\t\t\t\"lost fabric connectivity\\n\", pwwn_buf);\n\t\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tif (BFA_PORT_IS_DISABLED(fcport->bfa)) {\n\t\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\t\"Base port offline: WWN = %s\\n\", pwwn_buf);\n\t\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_OFFLINE);\n\t\t} else {\n\t\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\t\"Base port (WWN = %s) \"\n\t\t\t\t\"lost fabric connectivity\\n\", pwwn_buf);\n\t\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_scn(fcport, BFA_PORT_LINKDOWN, BFA_FALSE);\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tif (BFA_PORT_IS_DISABLED(fcport->bfa)) {\n\t\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\t\"Base port offline: WWN = %s\\n\", pwwn_buf);\n\t\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_OFFLINE);\n\t\t} else {\n\t\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\t\"Base port (WWN = %s) \"\n\t\t\t\t\"lost fabric connectivity\\n\", pwwn_buf);\n\t\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);\n\t\t}\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_FAA_MISCONFIG:\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_faa_misconfig);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_disabling_qwait(struct bfa_fcport_s *fcport,\n\t\t\t\t enum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabling);\n\t\tbfa_fcport_send_disable(fcport);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbfa_reqq_wcancel(&fcport->reqq_wait);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_toggling_qwait);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_LINKUP:\n\tcase BFA_FCPORT_SM_LINKDOWN:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);\n\t\tbfa_reqq_wcancel(&fcport->reqq_wait);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_FAA_MISCONFIG:\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISCONNECT);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_faa_misconfig);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_toggling_qwait(struct bfa_fcport_s *fcport,\n\t\t\t\t enum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabling);\n\t\tbfa_fcport_send_disable(fcport);\n\t\tif (bfa_fcport_send_enable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_enabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\t bfa_fcport_sm_enabling_qwait);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbfa_reqq_wcancel(&fcport->reqq_wait);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabling_qwait);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_LINKUP:\n\tcase BFA_FCPORT_SM_LINKDOWN:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);\n\t\tbfa_reqq_wcancel(&fcport->reqq_wait);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_disabling(struct bfa_fcport_s *fcport,\n\t\t\t\t\t\tenum bfa_fcport_sm_event event)\n{\n\tchar pwwn_buf[BFA_STRING_32];\n\tstruct bfad_s *bfad = (struct bfad_s *)fcport->bfa->bfad;\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_FWRSP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabled);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\tif (bfa_fcport_send_enable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_enabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\t bfa_fcport_sm_enabling_qwait);\n\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\tBFA_PL_EID_PORT_ENABLE, 0, \"Port Enable\");\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\"Base port enabled: WWN = %s\\n\", pwwn_buf);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_ENABLE);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_LINKUP:\n\tcase BFA_FCPORT_SM_LINKDOWN:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_disabled(struct bfa_fcport_s *fcport,\n\t\t\t\t\t\tenum bfa_fcport_sm_event event)\n{\n\tchar pwwn_buf[BFA_STRING_32];\n\tstruct bfad_s *bfad = (struct bfad_s *)fcport->bfa->bfad;\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_START:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\tif (bfa_fcport_send_enable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_enabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\t bfa_fcport_sm_enabling_qwait);\n\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t\tBFA_PL_EID_PORT_ENABLE, 0, \"Port Enable\");\n\t\twwn2str(pwwn_buf, fcport->pwwn);\n\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\"Base port enabled: WWN = %s\\n\", pwwn_buf);\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_ENABLE);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DPORTENABLE:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_dport);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DDPORTENABLE:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_ddport);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_stopped(struct bfa_fcport_s *fcport,\n\t\t\t enum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_START:\n\t\tif (bfa_fcport_send_enable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_enabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\t bfa_fcport_sm_enabling_qwait);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\t;\n\t}\n}\n\n \nstatic void\nbfa_fcport_sm_iocdown(struct bfa_fcport_s *fcport,\n\t\t\t enum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_START:\n\t\tif (bfa_fcport_send_enable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_enabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport,\n\t\t\t\t\t bfa_fcport_sm_enabling_qwait);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\t;\n\t}\n}\n\n \nstatic void\nbfa_fcport_sm_iocfail(struct bfa_fcport_s *fcport,\n\t\t\t enum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_START:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabled);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_ENABLE:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\t;\n\t}\n}\n\nstatic void\nbfa_fcport_sm_dport(struct bfa_fcport_s *fcport, enum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_DPORTENABLE:\n\tcase BFA_FCPORT_SM_DISABLE:\n\tcase BFA_FCPORT_SM_ENABLE:\n\tcase BFA_FCPORT_SM_START:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DPORTDISABLE:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabled);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_ddport(struct bfa_fcport_s *fcport,\n\t\t\tenum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_DISABLE:\n\tcase BFA_FCPORT_SM_DDPORTDISABLE:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabled);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DPORTENABLE:\n\tcase BFA_FCPORT_SM_DPORTDISABLE:\n\tcase BFA_FCPORT_SM_ENABLE:\n\tcase BFA_FCPORT_SM_START:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocfail);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_fcport_sm_faa_misconfig(struct bfa_fcport_s *fcport,\n\t\t\t    enum bfa_fcport_sm_event event)\n{\n\tbfa_trc(fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_SM_DPORTENABLE:\n\tcase BFA_FCPORT_SM_ENABLE:\n\tcase BFA_FCPORT_SM_START:\n\t\t \n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_DISABLE:\n\t\tif (bfa_fcport_send_disable(fcport))\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabling);\n\t\telse\n\t\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_disabling_qwait);\n\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_scn(fcport, BFA_PORT_LINKDOWN, BFA_FALSE);\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\t     BFA_PL_EID_PORT_DISABLE, 0, \"Port Disable\");\n\t\tbfa_fcport_aen_post(fcport, BFA_PORT_AEN_DISABLE);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_STOP:\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_stopped);\n\t\tbreak;\n\n\tcase BFA_FCPORT_SM_HWFAIL:\n\t\tbfa_fcport_reset_linkinfo(fcport);\n\t\tbfa_fcport_scn(fcport, BFA_PORT_LINKDOWN, BFA_FALSE);\n\t\tbfa_sm_set_state(fcport, bfa_fcport_sm_iocdown);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(fcport->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_fcport_ln_sm_dn(struct bfa_fcport_ln_s *ln,\n\t\tenum bfa_fcport_ln_sm_event event)\n{\n\tbfa_trc(ln->fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_LN_SM_LINKUP:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_up_nf);\n\t\tbfa_fcport_queue_cb(ln, BFA_PORT_LINKUP);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ln->fcport->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_fcport_ln_sm_dn_nf(struct bfa_fcport_ln_s *ln,\n\t\tenum bfa_fcport_ln_sm_event event)\n{\n\tbfa_trc(ln->fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_LN_SM_LINKUP:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_up_nf);\n\t\tbreak;\n\n\tcase BFA_FCPORT_LN_SM_NOTIFICATION:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_dn);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ln->fcport->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_fcport_ln_sm_dn_up_nf(struct bfa_fcport_ln_s *ln,\n\t\tenum bfa_fcport_ln_sm_event event)\n{\n\tbfa_trc(ln->fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_LN_SM_LINKDOWN:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_nf);\n\t\tbreak;\n\n\tcase BFA_FCPORT_LN_SM_NOTIFICATION:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_up_nf);\n\t\tbfa_fcport_queue_cb(ln, BFA_PORT_LINKUP);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ln->fcport->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_fcport_ln_sm_up(struct bfa_fcport_ln_s *ln,\n\t\tenum bfa_fcport_ln_sm_event event)\n{\n\tbfa_trc(ln->fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_LN_SM_LINKDOWN:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_nf);\n\t\tbfa_fcport_queue_cb(ln, BFA_PORT_LINKDOWN);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ln->fcport->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_fcport_ln_sm_up_nf(struct bfa_fcport_ln_s *ln,\n\t\tenum bfa_fcport_ln_sm_event event)\n{\n\tbfa_trc(ln->fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_LN_SM_LINKDOWN:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_up_dn_nf);\n\t\tbreak;\n\n\tcase BFA_FCPORT_LN_SM_NOTIFICATION:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_up);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ln->fcport->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln,\n\t\tenum bfa_fcport_ln_sm_event event)\n{\n\tbfa_trc(ln->fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_LN_SM_LINKUP:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_up_dn_up_nf);\n\t\tbreak;\n\n\tcase BFA_FCPORT_LN_SM_NOTIFICATION:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_nf);\n\t\tbfa_fcport_queue_cb(ln, BFA_PORT_LINKDOWN);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ln->fcport->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln,\n\t\t\tenum bfa_fcport_ln_sm_event event)\n{\n\tbfa_trc(ln->fcport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_FCPORT_LN_SM_LINKDOWN:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_up_dn_nf);\n\t\tbreak;\n\n\tcase BFA_FCPORT_LN_SM_NOTIFICATION:\n\t\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_dn_up_nf);\n\t\tbfa_fcport_queue_cb(ln, BFA_PORT_LINKDOWN);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(ln->fcport->bfa, event);\n\t}\n}\n\nstatic void\n__bfa_cb_fcport_event(void *cbarg, bfa_boolean_t complete)\n{\n\tstruct bfa_fcport_ln_s *ln = cbarg;\n\n\tif (complete)\n\t\tln->fcport->event_cbfn(ln->fcport->event_cbarg, ln->ln_event);\n\telse\n\t\tbfa_sm_send_event(ln, BFA_FCPORT_LN_SM_NOTIFICATION);\n}\n\n \nstatic void\nbfa_fcport_scn(struct bfa_fcport_s *fcport, enum bfa_port_linkstate event,\n\tbfa_boolean_t trunk)\n{\n\tif (fcport->cfg.trunked && !trunk)\n\t\treturn;\n\n\tswitch (event) {\n\tcase BFA_PORT_LINKUP:\n\t\tbfa_sm_send_event(&fcport->ln, BFA_FCPORT_LN_SM_LINKUP);\n\t\tbreak;\n\tcase BFA_PORT_LINKDOWN:\n\t\tbfa_sm_send_event(&fcport->ln, BFA_FCPORT_LN_SM_LINKDOWN);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic void\nbfa_fcport_queue_cb(struct bfa_fcport_ln_s *ln, enum bfa_port_linkstate event)\n{\n\tstruct bfa_fcport_s *fcport = ln->fcport;\n\n\tif (fcport->bfa->fcs) {\n\t\tfcport->event_cbfn(fcport->event_cbarg, event);\n\t\tbfa_sm_send_event(ln, BFA_FCPORT_LN_SM_NOTIFICATION);\n\t} else {\n\t\tln->ln_event = event;\n\t\tbfa_cb_queue(fcport->bfa, &ln->ln_qe,\n\t\t\t__bfa_cb_fcport_event, ln);\n\t}\n}\n\n#define FCPORT_STATS_DMA_SZ (BFA_ROUNDUP(sizeof(union bfa_fcport_stats_u), \\\n\t\t\t\t\t\t\tBFA_CACHELINE_SZ))\n\nvoid\nbfa_fcport_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *minfo,\n\t\t   struct bfa_s *bfa)\n{\n\tstruct bfa_mem_dma_s *fcport_dma = BFA_MEM_FCPORT_DMA(bfa);\n\n\tbfa_mem_dma_setup(minfo, fcport_dma, FCPORT_STATS_DMA_SZ);\n}\n\nstatic void\nbfa_fcport_qresume(void *cbarg)\n{\n\tstruct bfa_fcport_s *fcport = cbarg;\n\n\tbfa_sm_send_event(fcport, BFA_FCPORT_SM_QRESUME);\n}\n\nstatic void\nbfa_fcport_mem_claim(struct bfa_fcport_s *fcport)\n{\n\tstruct bfa_mem_dma_s *fcport_dma = &fcport->fcport_dma;\n\n\tfcport->stats_kva = bfa_mem_dma_virt(fcport_dma);\n\tfcport->stats_pa  = bfa_mem_dma_phys(fcport_dma);\n\tfcport->stats = (union bfa_fcport_stats_u *)\n\t\t\t\tbfa_mem_dma_virt(fcport_dma);\n}\n\n \nvoid\nbfa_fcport_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\t\tstruct bfa_pcidev_s *pcidev)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\tstruct bfa_port_cfg_s *port_cfg = &fcport->cfg;\n\tstruct bfa_fcport_ln_s *ln = &fcport->ln;\n\n\tfcport->bfa = bfa;\n\tln->fcport = fcport;\n\n\tbfa_fcport_mem_claim(fcport);\n\n\tbfa_sm_set_state(fcport, bfa_fcport_sm_uninit);\n\tbfa_sm_set_state(ln, bfa_fcport_ln_sm_dn);\n\n\t \n\tfcport->stats_reset_time = ktime_get_seconds();\n\tfcport->stats_dma_ready = BFA_FALSE;\n\n\t \n\tport_cfg->topology = BFA_PORT_TOPOLOGY_P2P;\n\tport_cfg->speed = BFA_PORT_SPEED_AUTO;\n\tport_cfg->trunked = BFA_FALSE;\n\tport_cfg->maxfrsize = 0;\n\n\tport_cfg->trl_def_speed = BFA_PORT_SPEED_1GBPS;\n\tport_cfg->qos_bw.high = BFA_QOS_BW_HIGH;\n\tport_cfg->qos_bw.med = BFA_QOS_BW_MED;\n\tport_cfg->qos_bw.low = BFA_QOS_BW_LOW;\n\n\tfcport->fec_state = BFA_FEC_OFFLINE;\n\n\tINIT_LIST_HEAD(&fcport->stats_pending_q);\n\tINIT_LIST_HEAD(&fcport->statsclr_pending_q);\n\n\tbfa_reqq_winit(&fcport->reqq_wait, bfa_fcport_qresume, fcport);\n}\n\nvoid\nbfa_fcport_start(struct bfa_s *bfa)\n{\n\tbfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_START);\n}\n\n \nvoid\nbfa_fcport_iocdisable(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_sm_send_event(fcport, BFA_FCPORT_SM_HWFAIL);\n\tbfa_trunk_iocdisable(bfa);\n}\n\n \nstatic void\nbfa_fcport_update_loop_info(struct bfa_fcport_s *fcport,\n\t\t\tstruct bfa_fcport_loop_info_s *loop_info)\n{\n\tfcport->myalpa = loop_info->myalpa;\n\tfcport->alpabm_valid =\n\t\t\tloop_info->alpabm_val;\n\tmemcpy(fcport->alpabm.alpa_bm,\n\t\t\tloop_info->alpabm.alpa_bm,\n\t\t\tsizeof(struct fc_alpabm_s));\n}\n\nstatic void\nbfa_fcport_update_linkinfo(struct bfa_fcport_s *fcport)\n{\n\tstruct bfi_fcport_event_s *pevent = fcport->event_arg.i2hmsg.event;\n\tstruct bfa_fcport_trunk_s *trunk = &fcport->trunk;\n\n\tfcport->speed = pevent->link_state.speed;\n\tfcport->topology = pevent->link_state.topology;\n\n\tif (fcport->topology == BFA_PORT_TOPOLOGY_LOOP) {\n\t\tbfa_fcport_update_loop_info(fcport,\n\t\t\t\t&pevent->link_state.attr.loop_info);\n\t\treturn;\n\t}\n\n\t \n\tfcport->qos_attr = pevent->link_state.qos_attr;\n\tfcport->qos_vc_attr = pevent->link_state.attr.vc_fcf.qos_vc_attr;\n\n\tif (fcport->cfg.bb_cr_enabled)\n\t\tfcport->bbcr_attr = pevent->link_state.attr.bbcr_attr;\n\n\tfcport->fec_state = pevent->link_state.fec_state;\n\n\t \n\tif (!fcport->cfg.trunked)\n\t\ttrunk->attr.state = BFA_TRUNK_DISABLED;\n\n\t \n\tfcport->fcoe_vlan =\n\t\tbe16_to_cpu(pevent->link_state.attr.vc_fcf.fcf.vlan);\n\n\tbfa_trc(fcport->bfa, fcport->speed);\n\tbfa_trc(fcport->bfa, fcport->topology);\n}\n\nstatic void\nbfa_fcport_reset_linkinfo(struct bfa_fcport_s *fcport)\n{\n\tfcport->speed = BFA_PORT_SPEED_UNKNOWN;\n\tfcport->topology = BFA_PORT_TOPOLOGY_NONE;\n\tfcport->fec_state = BFA_FEC_OFFLINE;\n}\n\n \nstatic bfa_boolean_t\nbfa_fcport_send_enable(struct bfa_fcport_s *fcport)\n{\n\tstruct bfi_fcport_enable_req_s *m;\n\n\t \n\tfcport->msgtag++;\n\n\t \n\tm = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);\n\tif (!m) {\n\t\tbfa_reqq_wait(fcport->bfa, BFA_REQQ_PORT,\n\t\t\t\t\t\t\t&fcport->reqq_wait);\n\t\treturn BFA_FALSE;\n\t}\n\n\tbfi_h2i_set(m->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_ENABLE_REQ,\n\t\t\tbfa_fn_lpu(fcport->bfa));\n\tm->nwwn = fcport->nwwn;\n\tm->pwwn = fcport->pwwn;\n\tm->port_cfg = fcport->cfg;\n\tm->msgtag = fcport->msgtag;\n\tm->port_cfg.maxfrsize = cpu_to_be16(fcport->cfg.maxfrsize);\n\tm->use_flash_cfg = fcport->use_flash_cfg;\n\tbfa_dma_be_addr_set(m->stats_dma_addr, fcport->stats_pa);\n\tbfa_trc(fcport->bfa, m->stats_dma_addr.a32.addr_lo);\n\tbfa_trc(fcport->bfa, m->stats_dma_addr.a32.addr_hi);\n\n\t \n\tbfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT, m->mh);\n\treturn BFA_TRUE;\n}\n\n \nstatic\tbfa_boolean_t\nbfa_fcport_send_disable(struct bfa_fcport_s *fcport)\n{\n\tstruct bfi_fcport_req_s *m;\n\n\t \n\tfcport->msgtag++;\n\n\t \n\tm = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);\n\tif (!m) {\n\t\tbfa_reqq_wait(fcport->bfa, BFA_REQQ_PORT,\n\t\t\t\t\t\t\t&fcport->reqq_wait);\n\t\treturn BFA_FALSE;\n\t}\n\n\tbfi_h2i_set(m->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_DISABLE_REQ,\n\t\t\tbfa_fn_lpu(fcport->bfa));\n\tm->msgtag = fcport->msgtag;\n\n\t \n\tbfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT, m->mh);\n\n\treturn BFA_TRUE;\n}\n\nstatic void\nbfa_fcport_set_wwns(struct bfa_fcport_s *fcport)\n{\n\tfcport->pwwn = fcport->bfa->ioc.attr->pwwn;\n\tfcport->nwwn = fcport->bfa->ioc.attr->nwwn;\n\n\tbfa_trc(fcport->bfa, fcport->pwwn);\n\tbfa_trc(fcport->bfa, fcport->nwwn);\n}\n\nstatic void\nbfa_fcport_qos_stats_swap(struct bfa_qos_stats_s *d,\n\tstruct bfa_qos_stats_s *s)\n{\n\tu32\t*dip = (u32 *) d;\n\t__be32\t*sip = (__be32 *) s;\n\tint\t\ti;\n\n\t \n\tfor (i = 0; i < (sizeof(struct bfa_qos_stats_s)/sizeof(u32)); ++i)\n\t\tdip[i] = be32_to_cpu(sip[i]);\n}\n\nstatic void\nbfa_fcport_fcoe_stats_swap(struct bfa_fcoe_stats_s *d,\n\tstruct bfa_fcoe_stats_s *s)\n{\n\tu32\t*dip = (u32 *) d;\n\t__be32\t*sip = (__be32 *) s;\n\tint\t\ti;\n\n\tfor (i = 0; i < ((sizeof(struct bfa_fcoe_stats_s))/sizeof(u32));\n\t     i = i + 2) {\n#ifdef __BIG_ENDIAN\n\t\tdip[i] = be32_to_cpu(sip[i]);\n\t\tdip[i + 1] = be32_to_cpu(sip[i + 1]);\n#else\n\t\tdip[i] = be32_to_cpu(sip[i + 1]);\n\t\tdip[i + 1] = be32_to_cpu(sip[i]);\n#endif\n\t}\n}\n\nstatic void\n__bfa_cb_fcport_stats_get(void *cbarg, bfa_boolean_t complete)\n{\n\tstruct bfa_fcport_s *fcport = (struct bfa_fcport_s *)cbarg;\n\tstruct bfa_cb_pending_q_s *cb;\n\tstruct list_head *qe, *qen;\n\tunion bfa_fcport_stats_u *ret;\n\n\tif (complete) {\n\t\ttime64_t time = ktime_get_seconds();\n\n\t\tlist_for_each_safe(qe, qen, &fcport->stats_pending_q) {\n\t\t\tbfa_q_deq(&fcport->stats_pending_q, &qe);\n\t\t\tcb = (struct bfa_cb_pending_q_s *)qe;\n\t\t\tif (fcport->stats_status == BFA_STATUS_OK) {\n\t\t\t\tret = (union bfa_fcport_stats_u *)cb->data;\n\t\t\t\t \n\t\t\t\tif (bfa_ioc_get_fcmode(&fcport->bfa->ioc))\n\t\t\t\t\tbfa_fcport_qos_stats_swap(&ret->fcqos,\n\t\t\t\t\t\t\t&fcport->stats->fcqos);\n\t\t\t\telse {\n\t\t\t\t\tbfa_fcport_fcoe_stats_swap(&ret->fcoe,\n\t\t\t\t\t\t\t&fcport->stats->fcoe);\n\t\t\t\t\tret->fcoe.secs_reset =\n\t\t\t\t\t\ttime - fcport->stats_reset_time;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbfa_cb_queue_status(fcport->bfa, &cb->hcb_qe,\n\t\t\t\t\tfcport->stats_status);\n\t\t}\n\t\tfcport->stats_status = BFA_STATUS_OK;\n\t} else {\n\t\tINIT_LIST_HEAD(&fcport->stats_pending_q);\n\t\tfcport->stats_status = BFA_STATUS_OK;\n\t}\n}\n\nstatic void\nbfa_fcport_stats_get_timeout(void *cbarg)\n{\n\tstruct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;\n\n\tbfa_trc(fcport->bfa, fcport->stats_qfull);\n\n\tif (fcport->stats_qfull) {\n\t\tbfa_reqq_wcancel(&fcport->stats_reqq_wait);\n\t\tfcport->stats_qfull = BFA_FALSE;\n\t}\n\n\tfcport->stats_status = BFA_STATUS_ETIMER;\n\t__bfa_cb_fcport_stats_get(fcport, BFA_TRUE);\n}\n\nstatic void\nbfa_fcport_send_stats_get(void *cbarg)\n{\n\tstruct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;\n\tstruct bfi_fcport_req_s *msg;\n\n\tmsg = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);\n\n\tif (!msg) {\n\t\tfcport->stats_qfull = BFA_TRUE;\n\t\tbfa_reqq_winit(&fcport->stats_reqq_wait,\n\t\t\t\tbfa_fcport_send_stats_get, fcport);\n\t\tbfa_reqq_wait(fcport->bfa, BFA_REQQ_PORT,\n\t\t\t\t&fcport->stats_reqq_wait);\n\t\treturn;\n\t}\n\tfcport->stats_qfull = BFA_FALSE;\n\n\tmemset(msg, 0, sizeof(struct bfi_fcport_req_s));\n\tbfi_h2i_set(msg->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_STATS_GET_REQ,\n\t\t\tbfa_fn_lpu(fcport->bfa));\n\tbfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT, msg->mh);\n}\n\nstatic void\n__bfa_cb_fcport_stats_clr(void *cbarg, bfa_boolean_t complete)\n{\n\tstruct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;\n\tstruct bfa_cb_pending_q_s *cb;\n\tstruct list_head *qe, *qen;\n\n\tif (complete) {\n\t\t \n\t\tfcport->stats_reset_time = ktime_get_seconds();\n\t\tlist_for_each_safe(qe, qen, &fcport->statsclr_pending_q) {\n\t\t\tbfa_q_deq(&fcport->statsclr_pending_q, &qe);\n\t\t\tcb = (struct bfa_cb_pending_q_s *)qe;\n\t\t\tbfa_cb_queue_status(fcport->bfa, &cb->hcb_qe,\n\t\t\t\t\t\tfcport->stats_status);\n\t\t}\n\t\tfcport->stats_status = BFA_STATUS_OK;\n\t} else {\n\t\tINIT_LIST_HEAD(&fcport->statsclr_pending_q);\n\t\tfcport->stats_status = BFA_STATUS_OK;\n\t}\n}\n\nstatic void\nbfa_fcport_stats_clr_timeout(void *cbarg)\n{\n\tstruct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;\n\n\tbfa_trc(fcport->bfa, fcport->stats_qfull);\n\n\tif (fcport->stats_qfull) {\n\t\tbfa_reqq_wcancel(&fcport->stats_reqq_wait);\n\t\tfcport->stats_qfull = BFA_FALSE;\n\t}\n\n\tfcport->stats_status = BFA_STATUS_ETIMER;\n\t__bfa_cb_fcport_stats_clr(fcport, BFA_TRUE);\n}\n\nstatic void\nbfa_fcport_send_stats_clear(void *cbarg)\n{\n\tstruct bfa_fcport_s *fcport = (struct bfa_fcport_s *) cbarg;\n\tstruct bfi_fcport_req_s *msg;\n\n\tmsg = bfa_reqq_next(fcport->bfa, BFA_REQQ_PORT);\n\n\tif (!msg) {\n\t\tfcport->stats_qfull = BFA_TRUE;\n\t\tbfa_reqq_winit(&fcport->stats_reqq_wait,\n\t\t\t\tbfa_fcport_send_stats_clear, fcport);\n\t\tbfa_reqq_wait(fcport->bfa, BFA_REQQ_PORT,\n\t\t\t\t\t\t&fcport->stats_reqq_wait);\n\t\treturn;\n\t}\n\tfcport->stats_qfull = BFA_FALSE;\n\n\tmemset(msg, 0, sizeof(struct bfi_fcport_req_s));\n\tbfi_h2i_set(msg->mh, BFI_MC_FCPORT, BFI_FCPORT_H2I_STATS_CLEAR_REQ,\n\t\t\tbfa_fn_lpu(fcport->bfa));\n\tbfa_reqq_produce(fcport->bfa, BFA_REQQ_PORT, msg->mh);\n}\n\n \nstatic void\nbfa_trunk_scn(struct bfa_fcport_s *fcport, struct bfi_fcport_trunk_scn_s *scn)\n{\n\tstruct bfa_fcport_trunk_s *trunk = &fcport->trunk;\n\tstruct bfi_fcport_trunk_link_s *tlink;\n\tstruct bfa_trunk_link_attr_s *lattr;\n\tenum bfa_trunk_state state_prev;\n\tint i;\n\tint link_bm = 0;\n\n\tbfa_trc(fcport->bfa, fcport->cfg.trunked);\n\tWARN_ON(scn->trunk_state != BFA_TRUNK_ONLINE &&\n\t\t   scn->trunk_state != BFA_TRUNK_OFFLINE);\n\n\tbfa_trc(fcport->bfa, trunk->attr.state);\n\tbfa_trc(fcport->bfa, scn->trunk_state);\n\tbfa_trc(fcport->bfa, scn->trunk_speed);\n\n\t \n\tstate_prev = trunk->attr.state;\n\tif (fcport->cfg.trunked && (trunk->attr.state != BFA_TRUNK_DISABLED))\n\t\ttrunk->attr.state = scn->trunk_state;\n\ttrunk->attr.speed = scn->trunk_speed;\n\tfor (i = 0; i < BFA_TRUNK_MAX_PORTS; i++) {\n\t\tlattr = &trunk->attr.link_attr[i];\n\t\ttlink = &scn->tlink[i];\n\n\t\tlattr->link_state = tlink->state;\n\t\tlattr->trunk_wwn  = tlink->trunk_wwn;\n\t\tlattr->fctl\t  = tlink->fctl;\n\t\tlattr->speed\t  = tlink->speed;\n\t\tlattr->deskew\t  = be32_to_cpu(tlink->deskew);\n\n\t\tif (tlink->state == BFA_TRUNK_LINK_STATE_UP) {\n\t\t\tfcport->speed\t = tlink->speed;\n\t\t\tfcport->topology = BFA_PORT_TOPOLOGY_P2P;\n\t\t\tlink_bm |= 1 << i;\n\t\t}\n\n\t\tbfa_trc(fcport->bfa, lattr->link_state);\n\t\tbfa_trc(fcport->bfa, lattr->trunk_wwn);\n\t\tbfa_trc(fcport->bfa, lattr->fctl);\n\t\tbfa_trc(fcport->bfa, lattr->speed);\n\t\tbfa_trc(fcport->bfa, lattr->deskew);\n\t}\n\n\tswitch (link_bm) {\n\tcase 3:\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\tBFA_PL_EID_TRUNK_SCN, 0, \"Trunk up(0,1)\");\n\t\tbreak;\n\tcase 2:\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\tBFA_PL_EID_TRUNK_SCN, 0, \"Trunk up(-,1)\");\n\t\tbreak;\n\tcase 1:\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\tBFA_PL_EID_TRUNK_SCN, 0, \"Trunk up(0,-)\");\n\t\tbreak;\n\tdefault:\n\t\tbfa_plog_str(fcport->bfa->plog, BFA_PL_MID_HAL,\n\t\t\tBFA_PL_EID_TRUNK_SCN, 0, \"Trunk down\");\n\t}\n\n\t \n\tif ((state_prev != trunk->attr.state) ||\n\t\t(scn->trunk_state == BFA_TRUNK_OFFLINE)) {\n\t\tbfa_fcport_scn(fcport, (scn->trunk_state == BFA_TRUNK_ONLINE) ?\n\t\t\tBFA_PORT_LINKUP : BFA_PORT_LINKDOWN, BFA_TRUE);\n\t}\n}\n\nstatic void\nbfa_trunk_iocdisable(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\tint i = 0;\n\n\t \n\tif (fcport->cfg.trunked) {\n\t\tif (fcport->trunk.attr.state == BFA_TRUNK_ONLINE)\n\t\t\tbfa_fcport_scn(fcport, BFA_PORT_LINKDOWN, BFA_TRUE);\n\n\t\tfcport->trunk.attr.state = BFA_TRUNK_OFFLINE;\n\t\tfcport->trunk.attr.speed = BFA_PORT_SPEED_UNKNOWN;\n\t\tfor (i = 0; i < BFA_TRUNK_MAX_PORTS; i++) {\n\t\t\tfcport->trunk.attr.link_attr[i].trunk_wwn = 0;\n\t\t\tfcport->trunk.attr.link_attr[i].fctl =\n\t\t\t\t\t\tBFA_TRUNK_LINK_FCTL_NORMAL;\n\t\t\tfcport->trunk.attr.link_attr[i].link_state =\n\t\t\t\t\t\tBFA_TRUNK_LINK_STATE_DN_LINKDN;\n\t\t\tfcport->trunk.attr.link_attr[i].speed =\n\t\t\t\t\t\tBFA_PORT_SPEED_UNKNOWN;\n\t\t\tfcport->trunk.attr.link_attr[i].deskew = 0;\n\t\t}\n\t}\n}\n\n \nvoid\nbfa_fcport_init(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\t \n\tbfa_fcport_set_wwns(fcport);\n\tif (fcport->cfg.maxfrsize == 0)\n\t\tfcport->cfg.maxfrsize = bfa_ioc_maxfrsize(&bfa->ioc);\n\tfcport->cfg.rx_bbcredit = bfa_ioc_rx_bbcredit(&bfa->ioc);\n\tfcport->speed_sup = bfa_ioc_speed_sup(&bfa->ioc);\n\n\tif (bfa_fcport_is_pbcdisabled(bfa))\n\t\tbfa->modules.port.pbc_disabled = BFA_TRUE;\n\n\tWARN_ON(!fcport->cfg.maxfrsize);\n\tWARN_ON(!fcport->cfg.rx_bbcredit);\n\tWARN_ON(!fcport->speed_sup);\n}\n\n \nvoid\nbfa_fcport_isr(struct bfa_s *bfa, struct bfi_msg_s *msg)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\tunion bfi_fcport_i2h_msg_u i2hmsg;\n\n\ti2hmsg.msg = msg;\n\tfcport->event_arg.i2hmsg = i2hmsg;\n\n\tbfa_trc(bfa, msg->mhdr.msg_id);\n\tbfa_trc(bfa, bfa_sm_to_state(hal_port_sm_table, fcport->sm));\n\n\tswitch (msg->mhdr.msg_id) {\n\tcase BFI_FCPORT_I2H_ENABLE_RSP:\n\t\tif (fcport->msgtag == i2hmsg.penable_rsp->msgtag) {\n\n\t\t\tfcport->stats_dma_ready = BFA_TRUE;\n\t\t\tif (fcport->use_flash_cfg) {\n\t\t\t\tfcport->cfg = i2hmsg.penable_rsp->port_cfg;\n\t\t\t\tfcport->cfg.maxfrsize =\n\t\t\t\t\tcpu_to_be16(fcport->cfg.maxfrsize);\n\t\t\t\tfcport->cfg.path_tov =\n\t\t\t\t\tcpu_to_be16(fcport->cfg.path_tov);\n\t\t\t\tfcport->cfg.q_depth =\n\t\t\t\t\tcpu_to_be16(fcport->cfg.q_depth);\n\n\t\t\t\tif (fcport->cfg.trunked)\n\t\t\t\t\tfcport->trunk.attr.state =\n\t\t\t\t\t\tBFA_TRUNK_OFFLINE;\n\t\t\t\telse\n\t\t\t\t\tfcport->trunk.attr.state =\n\t\t\t\t\t\tBFA_TRUNK_DISABLED;\n\t\t\t\tfcport->qos_attr.qos_bw =\n\t\t\t\t\ti2hmsg.penable_rsp->port_cfg.qos_bw;\n\t\t\t\tfcport->use_flash_cfg = BFA_FALSE;\n\t\t\t}\n\n\t\t\tif (fcport->cfg.qos_enabled)\n\t\t\t\tfcport->qos_attr.state = BFA_QOS_OFFLINE;\n\t\t\telse\n\t\t\t\tfcport->qos_attr.state = BFA_QOS_DISABLED;\n\n\t\t\tfcport->qos_attr.qos_bw_op =\n\t\t\t\t\ti2hmsg.penable_rsp->port_cfg.qos_bw;\n\n\t\t\tif (fcport->cfg.bb_cr_enabled)\n\t\t\t\tfcport->bbcr_attr.state = BFA_BBCR_OFFLINE;\n\t\t\telse\n\t\t\t\tfcport->bbcr_attr.state = BFA_BBCR_DISABLED;\n\n\t\t\tbfa_sm_send_event(fcport, BFA_FCPORT_SM_FWRSP);\n\t\t}\n\t\tbreak;\n\n\tcase BFI_FCPORT_I2H_DISABLE_RSP:\n\t\tif (fcport->msgtag == i2hmsg.penable_rsp->msgtag)\n\t\t\tbfa_sm_send_event(fcport, BFA_FCPORT_SM_FWRSP);\n\t\tbreak;\n\n\tcase BFI_FCPORT_I2H_EVENT:\n\t\tif (fcport->cfg.bb_cr_enabled)\n\t\t\tfcport->bbcr_attr.state = BFA_BBCR_OFFLINE;\n\t\telse\n\t\t\tfcport->bbcr_attr.state = BFA_BBCR_DISABLED;\n\n\t\tif (i2hmsg.event->link_state.linkstate == BFA_PORT_LINKUP)\n\t\t\tbfa_sm_send_event(fcport, BFA_FCPORT_SM_LINKUP);\n\t\telse {\n\t\t\tif (i2hmsg.event->link_state.linkstate_rsn ==\n\t\t\t    BFA_PORT_LINKSTATE_RSN_FAA_MISCONFIG)\n\t\t\t\tbfa_sm_send_event(fcport,\n\t\t\t\t\t\t  BFA_FCPORT_SM_FAA_MISCONFIG);\n\t\t\telse\n\t\t\t\tbfa_sm_send_event(fcport,\n\t\t\t\t\t\t  BFA_FCPORT_SM_LINKDOWN);\n\t\t}\n\t\tfcport->qos_attr.qos_bw_op =\n\t\t\t\ti2hmsg.event->link_state.qos_attr.qos_bw_op;\n\t\tbreak;\n\n\tcase BFI_FCPORT_I2H_TRUNK_SCN:\n\t\tbfa_trunk_scn(fcport, i2hmsg.trunk_scn);\n\t\tbreak;\n\n\tcase BFI_FCPORT_I2H_STATS_GET_RSP:\n\t\t \n\t\tif (list_empty(&fcport->stats_pending_q) ||\n\t\t    (fcport->stats_status == BFA_STATUS_ETIMER))\n\t\t\tbreak;\n\n\t\tbfa_timer_stop(&fcport->timer);\n\t\tfcport->stats_status = i2hmsg.pstatsget_rsp->status;\n\t\t__bfa_cb_fcport_stats_get(fcport, BFA_TRUE);\n\t\tbreak;\n\n\tcase BFI_FCPORT_I2H_STATS_CLEAR_RSP:\n\t\t \n\t\tif (list_empty(&fcport->statsclr_pending_q) ||\n\t\t    (fcport->stats_status == BFA_STATUS_ETIMER))\n\t\t\tbreak;\n\n\t\tbfa_timer_stop(&fcport->timer);\n\t\tfcport->stats_status = BFA_STATUS_OK;\n\t\t__bfa_cb_fcport_stats_clr(fcport, BFA_TRUE);\n\t\tbreak;\n\n\tcase BFI_FCPORT_I2H_ENABLE_AEN:\n\t\tbfa_sm_send_event(fcport, BFA_FCPORT_SM_ENABLE);\n\t\tbreak;\n\n\tcase BFI_FCPORT_I2H_DISABLE_AEN:\n\t\tbfa_sm_send_event(fcport, BFA_FCPORT_SM_DISABLE);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\tbreak;\n\t}\n}\n\n \nvoid\nbfa_fcport_event_register(struct bfa_s *bfa,\n\t\t\t\tvoid (*cbfn) (void *cbarg,\n\t\t\t\tenum bfa_port_linkstate event),\n\t\t\t\tvoid *cbarg)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tfcport->event_cbfn = cbfn;\n\tfcport->event_cbarg = cbarg;\n}\n\nbfa_status_t\nbfa_fcport_enable(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tif (bfa_fcport_is_pbcdisabled(bfa))\n\t\treturn BFA_STATUS_PBC;\n\n\tif (bfa_ioc_is_disabled(&bfa->ioc))\n\t\treturn BFA_STATUS_IOC_DISABLED;\n\n\tif (fcport->diag_busy)\n\t\treturn BFA_STATUS_DIAG_BUSY;\n\n\tbfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_ENABLE);\n\treturn BFA_STATUS_OK;\n}\n\nbfa_status_t\nbfa_fcport_disable(struct bfa_s *bfa)\n{\n\tif (bfa_fcport_is_pbcdisabled(bfa))\n\t\treturn BFA_STATUS_PBC;\n\n\tif (bfa_ioc_is_disabled(&bfa->ioc))\n\t\treturn BFA_STATUS_IOC_DISABLED;\n\n\tbfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_DISABLE);\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_fcport_is_pbcdisabled(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\tstruct bfa_iocfc_s *iocfc = &bfa->iocfc;\n\tstruct bfi_iocfc_cfgrsp_s *cfgrsp = iocfc->cfgrsp;\n\n\tif (cfgrsp->pbc_cfg.port_enabled == BFI_PBC_PORT_DISABLED) {\n\t\tbfa_trc(bfa, fcport->pwwn);\n\t\treturn BFA_STATUS_PBC;\n\t}\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_fcport_cfg_speed(struct bfa_s *bfa, enum bfa_port_speed speed)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, speed);\n\n\tif (fcport->cfg.trunked == BFA_TRUE)\n\t\treturn BFA_STATUS_TRUNK_ENABLED;\n\tif ((fcport->cfg.topology == BFA_PORT_TOPOLOGY_LOOP) &&\n\t\t\t(speed == BFA_PORT_SPEED_16GBPS))\n\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\tif ((speed != BFA_PORT_SPEED_AUTO) && (speed > fcport->speed_sup)) {\n\t\tbfa_trc(bfa, fcport->speed_sup);\n\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t}\n\n\t \n\tif (bfa_ioc_get_type(&fcport->bfa->ioc) == BFA_IOC_TYPE_FC) {\n\t\t \n\t\tif ((speed == BFA_PORT_SPEED_1GBPS) &&\n\t\t    (bfa_asic_id_ct2(bfa->ioc.pcidev.device_id)))\n\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\n\t\t \n\t\tif (!(speed == BFA_PORT_SPEED_1GBPS ||\n\t\t      speed == BFA_PORT_SPEED_2GBPS ||\n\t\t      speed == BFA_PORT_SPEED_4GBPS ||\n\t\t      speed == BFA_PORT_SPEED_8GBPS ||\n\t\t      speed == BFA_PORT_SPEED_16GBPS ||\n\t\t      speed == BFA_PORT_SPEED_AUTO))\n\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t} else {\n\t\tif (speed != BFA_PORT_SPEED_10GBPS)\n\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t}\n\n\tfcport->cfg.speed = speed;\n\n\treturn BFA_STATUS_OK;\n}\n\n \nenum bfa_port_speed\nbfa_fcport_get_speed(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn fcport->speed;\n}\n\n \nbfa_status_t\nbfa_fcport_cfg_topology(struct bfa_s *bfa, enum bfa_port_topology topology)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, topology);\n\tbfa_trc(bfa, fcport->cfg.topology);\n\n\tswitch (topology) {\n\tcase BFA_PORT_TOPOLOGY_P2P:\n\t\tbreak;\n\n\tcase BFA_PORT_TOPOLOGY_LOOP:\n\t\tif ((bfa_fcport_is_qos_enabled(bfa) != BFA_FALSE) ||\n\t\t\t(fcport->qos_attr.state != BFA_QOS_DISABLED))\n\t\t\treturn BFA_STATUS_ERROR_QOS_ENABLED;\n\t\tif (fcport->cfg.ratelimit != BFA_FALSE)\n\t\t\treturn BFA_STATUS_ERROR_TRL_ENABLED;\n\t\tif ((bfa_fcport_is_trunk_enabled(bfa) != BFA_FALSE) ||\n\t\t\t(fcport->trunk.attr.state != BFA_TRUNK_DISABLED))\n\t\t\treturn BFA_STATUS_ERROR_TRUNK_ENABLED;\n\t\tif ((bfa_fcport_get_speed(bfa) == BFA_PORT_SPEED_16GBPS) ||\n\t\t\t(fcport->cfg.speed == BFA_PORT_SPEED_16GBPS))\n\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t\tif (bfa_mfg_is_mezz(bfa->ioc.attr->card_type))\n\t\t\treturn BFA_STATUS_LOOP_UNSUPP_MEZZ;\n\t\tif (bfa_fcport_is_dport(bfa) != BFA_FALSE)\n\t\t\treturn BFA_STATUS_DPORT_ERR;\n\t\tif (bfa_fcport_is_ddport(bfa) != BFA_FALSE)\n\t\t\treturn BFA_STATUS_DPORT_ERR;\n\t\tbreak;\n\n\tcase BFA_PORT_TOPOLOGY_AUTO:\n\t\tbreak;\n\n\tdefault:\n\t\treturn BFA_STATUS_EINVAL;\n\t}\n\n\tfcport->cfg.topology = topology;\n\treturn BFA_STATUS_OK;\n}\n\n \nenum bfa_port_topology\nbfa_fcport_get_topology(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn fcport->topology;\n}\n\n \nenum bfa_port_topology\nbfa_fcport_get_cfg_topology(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn fcport->cfg.topology;\n}\n\nbfa_status_t\nbfa_fcport_cfg_hardalpa(struct bfa_s *bfa, u8 alpa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, alpa);\n\tbfa_trc(bfa, fcport->cfg.cfg_hardalpa);\n\tbfa_trc(bfa, fcport->cfg.hardalpa);\n\n\tfcport->cfg.cfg_hardalpa = BFA_TRUE;\n\tfcport->cfg.hardalpa = alpa;\n\n\treturn BFA_STATUS_OK;\n}\n\nbfa_status_t\nbfa_fcport_clr_hardalpa(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, fcport->cfg.cfg_hardalpa);\n\tbfa_trc(bfa, fcport->cfg.hardalpa);\n\n\tfcport->cfg.cfg_hardalpa = BFA_FALSE;\n\treturn BFA_STATUS_OK;\n}\n\nbfa_boolean_t\nbfa_fcport_get_hardalpa(struct bfa_s *bfa, u8 *alpa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\t*alpa = fcport->cfg.hardalpa;\n\treturn fcport->cfg.cfg_hardalpa;\n}\n\nu8\nbfa_fcport_get_myalpa(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn fcport->myalpa;\n}\n\nbfa_status_t\nbfa_fcport_cfg_maxfrsize(struct bfa_s *bfa, u16 maxfrsize)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, maxfrsize);\n\tbfa_trc(bfa, fcport->cfg.maxfrsize);\n\n\t \n\tif ((maxfrsize > FC_MAX_PDUSZ) || (maxfrsize < FC_MIN_PDUSZ))\n\t\treturn BFA_STATUS_INVLD_DFSZ;\n\n\t \n\tif ((maxfrsize != FC_MAX_PDUSZ) && (maxfrsize & (maxfrsize - 1)))\n\t\treturn BFA_STATUS_INVLD_DFSZ;\n\n\tfcport->cfg.maxfrsize = maxfrsize;\n\treturn BFA_STATUS_OK;\n}\n\nu16\nbfa_fcport_get_maxfrsize(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn fcport->cfg.maxfrsize;\n}\n\nu8\nbfa_fcport_get_rx_bbcredit(struct bfa_s *bfa)\n{\n\tif (bfa_fcport_get_topology(bfa) != BFA_PORT_TOPOLOGY_LOOP)\n\t\treturn (BFA_FCPORT_MOD(bfa))->cfg.rx_bbcredit;\n\n\telse\n\t\treturn 0;\n}\n\nvoid\nbfa_fcport_set_tx_bbcredit(struct bfa_s *bfa, u16 tx_bbcredit)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tfcport->cfg.tx_bbcredit = (u8)tx_bbcredit;\n}\n\n \n\nwwn_t\nbfa_fcport_get_wwn(struct bfa_s *bfa, bfa_boolean_t node)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\tif (node)\n\t\treturn fcport->nwwn;\n\telse\n\t\treturn fcport->pwwn;\n}\n\nvoid\nbfa_fcport_get_attr(struct bfa_s *bfa, struct bfa_port_attr_s *attr)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tmemset(attr, 0, sizeof(struct bfa_port_attr_s));\n\n\tattr->nwwn = fcport->nwwn;\n\tattr->pwwn = fcport->pwwn;\n\n\tattr->factorypwwn =  bfa->ioc.attr->mfg_pwwn;\n\tattr->factorynwwn =  bfa->ioc.attr->mfg_nwwn;\n\n\tmemcpy(&attr->pport_cfg, &fcport->cfg,\n\t\tsizeof(struct bfa_port_cfg_s));\n\t \n\tattr->pport_cfg.speed = fcport->cfg.speed;\n\tattr->speed_supported = fcport->speed_sup;\n\tattr->speed = fcport->speed;\n\tattr->cos_supported = FC_CLASS_3;\n\n\t \n\tattr->pport_cfg.topology = fcport->cfg.topology;\n\tattr->topology = fcport->topology;\n\tattr->pport_cfg.trunked = fcport->cfg.trunked;\n\n\t \n\tattr->beacon = fcport->beacon;\n\tattr->link_e2e_beacon = fcport->link_e2e_beacon;\n\n\tattr->pport_cfg.path_tov  = bfa_fcpim_path_tov_get(bfa);\n\tattr->pport_cfg.q_depth  = bfa_fcpim_qdepth_get(bfa);\n\tattr->port_state = bfa_sm_to_state(hal_port_sm_table, fcport->sm);\n\n\tattr->fec_state = fcport->fec_state;\n\n\t \n\tif (bfa_fcport_is_pbcdisabled(bfa))\n\t\tattr->port_state = BFA_PORT_ST_PREBOOT_DISABLED;\n\telse {\n\t\tif (bfa_ioc_is_disabled(&fcport->bfa->ioc))\n\t\t\tattr->port_state = BFA_PORT_ST_IOCDIS;\n\t\telse if (bfa_ioc_fw_mismatch(&fcport->bfa->ioc))\n\t\t\tattr->port_state = BFA_PORT_ST_FWMISMATCH;\n\t}\n\n\t \n\tattr->fcoe_vlan = fcport->fcoe_vlan;\n}\n\n#define BFA_FCPORT_STATS_TOV\t1000\n\n \nbfa_status_t\nbfa_fcport_get_stats(struct bfa_s *bfa, struct bfa_cb_pending_q_s *cb)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tif (!bfa_iocfc_is_operational(bfa) ||\n\t    !fcport->stats_dma_ready)\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\tif (!list_empty(&fcport->statsclr_pending_q))\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\tif (list_empty(&fcport->stats_pending_q)) {\n\t\tlist_add_tail(&cb->hcb_qe.qe, &fcport->stats_pending_q);\n\t\tbfa_fcport_send_stats_get(fcport);\n\t\tbfa_timer_start(bfa, &fcport->timer,\n\t\t\t\tbfa_fcport_stats_get_timeout,\n\t\t\t\tfcport, BFA_FCPORT_STATS_TOV);\n\t} else\n\t\tlist_add_tail(&cb->hcb_qe.qe, &fcport->stats_pending_q);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_fcport_clear_stats(struct bfa_s *bfa, struct bfa_cb_pending_q_s *cb)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tif (!bfa_iocfc_is_operational(bfa) ||\n\t    !fcport->stats_dma_ready)\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\tif (!list_empty(&fcport->stats_pending_q))\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\tif (list_empty(&fcport->statsclr_pending_q)) {\n\t\tlist_add_tail(&cb->hcb_qe.qe, &fcport->statsclr_pending_q);\n\t\tbfa_fcport_send_stats_clear(fcport);\n\t\tbfa_timer_start(bfa, &fcport->timer,\n\t\t\t\tbfa_fcport_stats_clr_timeout,\n\t\t\t\tfcport, BFA_FCPORT_STATS_TOV);\n\t} else\n\t\tlist_add_tail(&cb->hcb_qe.qe, &fcport->statsclr_pending_q);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_boolean_t\nbfa_fcport_is_disabled(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==\n\t\tBFA_PORT_ST_DISABLED;\n\n}\n\nbfa_boolean_t\nbfa_fcport_is_dport(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn (bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==\n\t\tBFA_PORT_ST_DPORT);\n}\n\nbfa_boolean_t\nbfa_fcport_is_ddport(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn (bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==\n\t\tBFA_PORT_ST_DDPORT);\n}\n\nbfa_status_t\nbfa_fcport_set_qos_bw(struct bfa_s *bfa, struct bfa_qos_bw_s *qos_bw)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\tenum bfa_ioc_type_e ioc_type = bfa_get_type(bfa);\n\n\tbfa_trc(bfa, ioc_type);\n\n\tif ((qos_bw->high == 0) || (qos_bw->med == 0) || (qos_bw->low == 0))\n\t\treturn BFA_STATUS_QOS_BW_INVALID;\n\n\tif ((qos_bw->high + qos_bw->med + qos_bw->low) != 100)\n\t\treturn BFA_STATUS_QOS_BW_INVALID;\n\n\tif ((qos_bw->med > qos_bw->high) || (qos_bw->low > qos_bw->med) ||\n\t    (qos_bw->low > qos_bw->high))\n\t\treturn BFA_STATUS_QOS_BW_INVALID;\n\n\tif ((ioc_type == BFA_IOC_TYPE_FC) &&\n\t    (fcport->cfg.topology != BFA_PORT_TOPOLOGY_LOOP))\n\t\tfcport->cfg.qos_bw = *qos_bw;\n\n\treturn BFA_STATUS_OK;\n}\n\nbfa_boolean_t\nbfa_fcport_is_ratelim(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn fcport->cfg.ratelimit ? BFA_TRUE : BFA_FALSE;\n\n}\n\n \nvoid\nbfa_fcport_cfg_faa(struct bfa_s *bfa, u8 state)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, state);\n\tfcport->cfg.faa_state = state;\n}\n\n \nenum bfa_port_speed\nbfa_fcport_get_ratelim_speed(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, fcport->cfg.trl_def_speed);\n\treturn fcport->cfg.trl_def_speed;\n\n}\n\nvoid\nbfa_fcport_beacon(void *dev, bfa_boolean_t beacon,\n\t\t  bfa_boolean_t link_e2e_beacon)\n{\n\tstruct bfa_s *bfa = dev;\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, beacon);\n\tbfa_trc(bfa, link_e2e_beacon);\n\tbfa_trc(bfa, fcport->beacon);\n\tbfa_trc(bfa, fcport->link_e2e_beacon);\n\n\tfcport->beacon = beacon;\n\tfcport->link_e2e_beacon = link_e2e_beacon;\n}\n\nbfa_boolean_t\nbfa_fcport_is_linkup(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn\t(!fcport->cfg.trunked &&\n\t\t bfa_sm_cmp_state(fcport, bfa_fcport_sm_linkup)) ||\n\t\t(fcport->cfg.trunked &&\n\t\t fcport->trunk.attr.state == BFA_TRUNK_ONLINE);\n}\n\nbfa_boolean_t\nbfa_fcport_is_qos_enabled(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn fcport->cfg.qos_enabled;\n}\n\nbfa_boolean_t\nbfa_fcport_is_trunk_enabled(struct bfa_s *bfa)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\treturn fcport->cfg.trunked;\n}\n\nbfa_status_t\nbfa_fcport_cfg_bbcr(struct bfa_s *bfa, bfa_boolean_t on_off, u8 bb_scn)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tbfa_trc(bfa, on_off);\n\n\tif (bfa_ioc_get_type(&fcport->bfa->ioc) != BFA_IOC_TYPE_FC)\n\t\treturn BFA_STATUS_BBCR_FC_ONLY;\n\n\tif (bfa_mfg_is_mezz(bfa->ioc.attr->card_type) &&\n\t\t(bfa->ioc.attr->card_type != BFA_MFG_TYPE_CHINOOK))\n\t\treturn BFA_STATUS_CMD_NOTSUPP_MEZZ;\n\n\tif (on_off) {\n\t\tif (fcport->cfg.topology == BFA_PORT_TOPOLOGY_LOOP)\n\t\t\treturn BFA_STATUS_TOPOLOGY_LOOP;\n\n\t\tif (fcport->cfg.qos_enabled)\n\t\t\treturn BFA_STATUS_ERROR_QOS_ENABLED;\n\n\t\tif (fcport->cfg.trunked)\n\t\t\treturn BFA_STATUS_TRUNK_ENABLED;\n\n\t\tif ((fcport->cfg.speed != BFA_PORT_SPEED_AUTO) &&\n\t\t\t(fcport->cfg.speed < bfa_ioc_speed_sup(&bfa->ioc)))\n\t\t\treturn BFA_STATUS_ERR_BBCR_SPEED_UNSUPPORT;\n\n\t\tif (bfa_ioc_speed_sup(&bfa->ioc) < BFA_PORT_SPEED_8GBPS)\n\t\t\treturn BFA_STATUS_FEATURE_NOT_SUPPORTED;\n\n\t\tif (fcport->cfg.bb_cr_enabled) {\n\t\t\tif (bb_scn != fcport->cfg.bb_scn)\n\t\t\t\treturn BFA_STATUS_BBCR_CFG_NO_CHANGE;\n\t\t\telse\n\t\t\t\treturn BFA_STATUS_NO_CHANGE;\n\t\t}\n\n\t\tif ((bb_scn == 0) || (bb_scn > BFA_BB_SCN_MAX))\n\t\t\tbb_scn = BFA_BB_SCN_DEF;\n\n\t\tfcport->cfg.bb_cr_enabled = on_off;\n\t\tfcport->cfg.bb_scn = bb_scn;\n\t} else {\n\t\tif (!fcport->cfg.bb_cr_enabled)\n\t\t\treturn BFA_STATUS_NO_CHANGE;\n\n\t\tfcport->cfg.bb_cr_enabled = on_off;\n\t\tfcport->cfg.bb_scn = 0;\n\t}\n\n\treturn BFA_STATUS_OK;\n}\n\nbfa_status_t\nbfa_fcport_get_bbcr_attr(struct bfa_s *bfa,\n\t\tstruct bfa_bbcr_attr_s *bbcr_attr)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);\n\n\tif (bfa_ioc_get_type(&fcport->bfa->ioc) != BFA_IOC_TYPE_FC)\n\t\treturn BFA_STATUS_BBCR_FC_ONLY;\n\n\tif (fcport->cfg.topology == BFA_PORT_TOPOLOGY_LOOP)\n\t\treturn BFA_STATUS_TOPOLOGY_LOOP;\n\n\t*bbcr_attr = fcport->bbcr_attr;\n\n\treturn BFA_STATUS_OK;\n}\n\nvoid\nbfa_fcport_dportenable(struct bfa_s *bfa)\n{\n\t \n\tbfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_DPORTENABLE);\n\tbfa_port_set_dportenabled(&bfa->modules.port, BFA_TRUE);\n}\n\nvoid\nbfa_fcport_dportdisable(struct bfa_s *bfa)\n{\n\t \n\tbfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_DPORTDISABLE);\n\tbfa_port_set_dportenabled(&bfa->modules.port, BFA_FALSE);\n}\n\nstatic void\nbfa_fcport_ddportenable(struct bfa_s *bfa)\n{\n\t \n\tbfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_DDPORTENABLE);\n}\n\nstatic void\nbfa_fcport_ddportdisable(struct bfa_s *bfa)\n{\n\t \n\tbfa_sm_send_event(BFA_FCPORT_MOD(bfa), BFA_FCPORT_SM_DDPORTDISABLE);\n}\n\n \n \nstatic void\nbfa_rport_sm_uninit(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_CREATE:\n\t\tbfa_stats(rp, sm_un_cr);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_created);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_un_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\nstatic void\nbfa_rport_sm_created(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_ONLINE:\n\t\tbfa_stats(rp, sm_cr_on);\n\t\tif (bfa_rport_send_fwcreate(rp))\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwcreate);\n\t\telse\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwcreate_qfull);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_cr_del);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\t\tbfa_rport_free(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_cr_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_iocdisable);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_cr_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_fwcreate(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_FWRSP:\n\t\tbfa_stats(rp, sm_fwc_rsp);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_online);\n\t\tbfa_rport_online_cb(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_fwc_del);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_delete_pending);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_OFFLINE:\n\t\tbfa_stats(rp, sm_fwc_off);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_offline_pending);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_fwc_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_iocdisable);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_fwc_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_fwcreate_qfull(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwcreate);\n\t\tbfa_rport_send_fwcreate(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_fwc_del);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\t\tbfa_reqq_wcancel(&rp->reqq_wait);\n\t\tbfa_rport_free(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_OFFLINE:\n\t\tbfa_stats(rp, sm_fwc_off);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_offline);\n\t\tbfa_reqq_wcancel(&rp->reqq_wait);\n\t\tbfa_rport_offline_cb(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_fwc_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_iocdisable);\n\t\tbfa_reqq_wcancel(&rp->reqq_wait);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_fwc_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_online(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tstruct bfi_rport_qos_scn_s *qos_scn;\n\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_OFFLINE:\n\t\tbfa_stats(rp, sm_on_off);\n\t\tif (bfa_rport_send_fwdelete(rp))\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwdelete);\n\t\telse\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwdelete_qfull);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_on_del);\n\t\tif (bfa_rport_send_fwdelete(rp))\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_deleting);\n\t\telse\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_deleting_qfull);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_on_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_iocdisable);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_SET_SPEED:\n\t\tbfa_rport_send_fwspeed(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_QOS_SCN:\n\t\tqos_scn = (struct bfi_rport_qos_scn_s *) rp->event_arg.fw_msg;\n\t\trp->qos_attr = qos_scn->new_qos_attr;\n\t\tbfa_trc(rp->bfa, qos_scn->old_qos_attr.qos_flow_id);\n\t\tbfa_trc(rp->bfa, qos_scn->new_qos_attr.qos_flow_id);\n\t\tbfa_trc(rp->bfa, qos_scn->old_qos_attr.qos_priority);\n\t\tbfa_trc(rp->bfa, qos_scn->new_qos_attr.qos_priority);\n\n\t\tqos_scn->old_qos_attr.qos_flow_id  =\n\t\t\tbe32_to_cpu(qos_scn->old_qos_attr.qos_flow_id);\n\t\tqos_scn->new_qos_attr.qos_flow_id  =\n\t\t\tbe32_to_cpu(qos_scn->new_qos_attr.qos_flow_id);\n\n\t\tif (qos_scn->old_qos_attr.qos_flow_id !=\n\t\t\tqos_scn->new_qos_attr.qos_flow_id)\n\t\t\tbfa_cb_rport_qos_scn_flowid(rp->rport_drv,\n\t\t\t\t\t\t    qos_scn->old_qos_attr,\n\t\t\t\t\t\t    qos_scn->new_qos_attr);\n\t\tif (qos_scn->old_qos_attr.qos_priority !=\n\t\t\tqos_scn->new_qos_attr.qos_priority)\n\t\t\tbfa_cb_rport_qos_scn_prio(rp->rport_drv,\n\t\t\t\t\t\t  qos_scn->old_qos_attr,\n\t\t\t\t\t\t  qos_scn->new_qos_attr);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_on_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_fwdelete(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_FWRSP:\n\t\tbfa_stats(rp, sm_fwd_rsp);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_offline);\n\t\tbfa_rport_offline_cb(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_fwd_del);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_deleting);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_fwd_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_iocdisable);\n\t\tbfa_rport_offline_cb(rp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_fwd_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\nstatic void\nbfa_rport_sm_fwdelete_qfull(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwdelete);\n\t\tbfa_rport_send_fwdelete(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_fwd_del);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_deleting_qfull);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_fwd_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_iocdisable);\n\t\tbfa_reqq_wcancel(&rp->reqq_wait);\n\t\tbfa_rport_offline_cb(rp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_fwd_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_offline(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_off_del);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\t\tbfa_rport_free(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_ONLINE:\n\t\tbfa_stats(rp, sm_off_on);\n\t\tif (bfa_rport_send_fwcreate(rp))\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwcreate);\n\t\telse\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwcreate_qfull);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_off_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_iocdisable);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_OFFLINE:\n\t\tbfa_rport_offline_cb(rp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_off_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_deleting(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_FWRSP:\n\t\tbfa_stats(rp, sm_del_fwrsp);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\t\tbfa_rport_free(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_del_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\t\tbfa_rport_free(rp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\nstatic void\nbfa_rport_sm_deleting_qfull(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_QRESUME:\n\t\tbfa_stats(rp, sm_del_fwrsp);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_deleting);\n\t\tbfa_rport_send_fwdelete(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_del_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\t\tbfa_reqq_wcancel(&rp->reqq_wait);\n\t\tbfa_rport_free(rp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_delete_pending(struct bfa_rport_s *rp,\n\t\t\t\tenum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_FWRSP:\n\t\tbfa_stats(rp, sm_delp_fwrsp);\n\t\tif (bfa_rport_send_fwdelete(rp))\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_deleting);\n\t\telse\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_deleting_qfull);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_delp_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\t\tbfa_rport_free(rp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_delp_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_offline_pending(struct bfa_rport_s *rp,\n\t\t\t\t enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_FWRSP:\n\t\tbfa_stats(rp, sm_offp_fwrsp);\n\t\tif (bfa_rport_send_fwdelete(rp))\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwdelete);\n\t\telse\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwdelete_qfull);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_offp_del);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_delete_pending);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbfa_stats(rp, sm_offp_hwf);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_iocdisable);\n\t\tbfa_rport_offline_cb(rp);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_offp_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n \nstatic void\nbfa_rport_sm_iocdisable(struct bfa_rport_s *rp, enum bfa_rport_event event)\n{\n\tbfa_trc(rp->bfa, rp->rport_tag);\n\tbfa_trc(rp->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_RPORT_SM_OFFLINE:\n\t\tbfa_stats(rp, sm_iocd_off);\n\t\tbfa_rport_offline_cb(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_DELETE:\n\t\tbfa_stats(rp, sm_iocd_del);\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\t\tbfa_rport_free(rp);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_ONLINE:\n\t\tbfa_stats(rp, sm_iocd_on);\n\t\tif (bfa_rport_send_fwcreate(rp))\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwcreate);\n\t\telse\n\t\t\tbfa_sm_set_state(rp, bfa_rport_sm_fwcreate_qfull);\n\t\tbreak;\n\n\tcase BFA_RPORT_SM_HWFAIL:\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_stats(rp, sm_iocd_unexp);\n\t\tbfa_sm_fault(rp->bfa, event);\n\t}\n}\n\n\n\n \n\nstatic void\n__bfa_cb_rport_online(void *cbarg, bfa_boolean_t complete)\n{\n\tstruct bfa_rport_s *rp = cbarg;\n\n\tif (complete)\n\t\tbfa_cb_rport_online(rp->rport_drv);\n}\n\nstatic void\n__bfa_cb_rport_offline(void *cbarg, bfa_boolean_t complete)\n{\n\tstruct bfa_rport_s *rp = cbarg;\n\n\tif (complete)\n\t\tbfa_cb_rport_offline(rp->rport_drv);\n}\n\nstatic void\nbfa_rport_qresume(void *cbarg)\n{\n\tstruct bfa_rport_s\t*rp = cbarg;\n\n\tbfa_sm_send_event(rp, BFA_RPORT_SM_QRESUME);\n}\n\nvoid\nbfa_rport_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *minfo,\n\t\tstruct bfa_s *bfa)\n{\n\tstruct bfa_mem_kva_s *rport_kva = BFA_MEM_RPORT_KVA(bfa);\n\n\tif (cfg->fwcfg.num_rports < BFA_RPORT_MIN)\n\t\tcfg->fwcfg.num_rports = BFA_RPORT_MIN;\n\n\t \n\tbfa_mem_kva_setup(minfo, rport_kva,\n\t\tcfg->fwcfg.num_rports * sizeof(struct bfa_rport_s));\n}\n\nvoid\nbfa_rport_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\t\tstruct bfa_pcidev_s *pcidev)\n{\n\tstruct bfa_rport_mod_s *mod = BFA_RPORT_MOD(bfa);\n\tstruct bfa_rport_s *rp;\n\tu16 i;\n\n\tINIT_LIST_HEAD(&mod->rp_free_q);\n\tINIT_LIST_HEAD(&mod->rp_active_q);\n\tINIT_LIST_HEAD(&mod->rp_unused_q);\n\n\trp = (struct bfa_rport_s *) bfa_mem_kva_curp(mod);\n\tmod->rps_list = rp;\n\tmod->num_rports = cfg->fwcfg.num_rports;\n\n\tWARN_ON(!mod->num_rports ||\n\t\t   (mod->num_rports & (mod->num_rports - 1)));\n\n\tfor (i = 0; i < mod->num_rports; i++, rp++) {\n\t\tmemset(rp, 0, sizeof(struct bfa_rport_s));\n\t\trp->bfa = bfa;\n\t\trp->rport_tag = i;\n\t\tbfa_sm_set_state(rp, bfa_rport_sm_uninit);\n\n\t\t \n\t\tif (i)\n\t\t\tlist_add_tail(&rp->qe, &mod->rp_free_q);\n\n\t\tbfa_reqq_winit(&rp->reqq_wait, bfa_rport_qresume, rp);\n\t}\n\n\t \n\tbfa_mem_kva_curp(mod) = (u8 *) rp;\n}\n\nvoid\nbfa_rport_iocdisable(struct bfa_s *bfa)\n{\n\tstruct bfa_rport_mod_s *mod = BFA_RPORT_MOD(bfa);\n\tstruct bfa_rport_s *rport;\n\tstruct list_head *qe, *qen;\n\n\t \n\tlist_splice_tail_init(&mod->rp_unused_q, &mod->rp_free_q);\n\n\tlist_for_each_safe(qe, qen, &mod->rp_active_q) {\n\t\trport = (struct bfa_rport_s *) qe;\n\t\tbfa_sm_send_event(rport, BFA_RPORT_SM_HWFAIL);\n\t}\n}\n\nstatic struct bfa_rport_s *\nbfa_rport_alloc(struct bfa_rport_mod_s *mod)\n{\n\tstruct bfa_rport_s *rport;\n\n\tbfa_q_deq(&mod->rp_free_q, &rport);\n\tif (rport)\n\t\tlist_add_tail(&rport->qe, &mod->rp_active_q);\n\n\treturn rport;\n}\n\nstatic void\nbfa_rport_free(struct bfa_rport_s *rport)\n{\n\tstruct bfa_rport_mod_s *mod = BFA_RPORT_MOD(rport->bfa);\n\n\tWARN_ON(!bfa_q_is_on_q(&mod->rp_active_q, rport));\n\tlist_del(&rport->qe);\n\tlist_add_tail(&rport->qe, &mod->rp_free_q);\n}\n\nstatic bfa_boolean_t\nbfa_rport_send_fwcreate(struct bfa_rport_s *rp)\n{\n\tstruct bfi_rport_create_req_s *m;\n\n\t \n\tm = bfa_reqq_next(rp->bfa, BFA_REQQ_RPORT);\n\tif (!m) {\n\t\tbfa_reqq_wait(rp->bfa, BFA_REQQ_RPORT, &rp->reqq_wait);\n\t\treturn BFA_FALSE;\n\t}\n\n\tbfi_h2i_set(m->mh, BFI_MC_RPORT, BFI_RPORT_H2I_CREATE_REQ,\n\t\t\tbfa_fn_lpu(rp->bfa));\n\tm->bfa_handle = rp->rport_tag;\n\tm->max_frmsz = cpu_to_be16(rp->rport_info.max_frmsz);\n\tm->pid = rp->rport_info.pid;\n\tm->lp_fwtag = bfa_lps_get_fwtag(rp->bfa, (u8)rp->rport_info.lp_tag);\n\tm->local_pid = rp->rport_info.local_pid;\n\tm->fc_class = rp->rport_info.fc_class;\n\tm->vf_en = rp->rport_info.vf_en;\n\tm->vf_id = rp->rport_info.vf_id;\n\tm->cisc = rp->rport_info.cisc;\n\n\t \n\tbfa_reqq_produce(rp->bfa, BFA_REQQ_RPORT, m->mh);\n\treturn BFA_TRUE;\n}\n\nstatic bfa_boolean_t\nbfa_rport_send_fwdelete(struct bfa_rport_s *rp)\n{\n\tstruct bfi_rport_delete_req_s *m;\n\n\t \n\tm = bfa_reqq_next(rp->bfa, BFA_REQQ_RPORT);\n\tif (!m) {\n\t\tbfa_reqq_wait(rp->bfa, BFA_REQQ_RPORT, &rp->reqq_wait);\n\t\treturn BFA_FALSE;\n\t}\n\n\tbfi_h2i_set(m->mh, BFI_MC_RPORT, BFI_RPORT_H2I_DELETE_REQ,\n\t\t\tbfa_fn_lpu(rp->bfa));\n\tm->fw_handle = rp->fw_handle;\n\n\t \n\tbfa_reqq_produce(rp->bfa, BFA_REQQ_RPORT, m->mh);\n\treturn BFA_TRUE;\n}\n\nstatic bfa_boolean_t\nbfa_rport_send_fwspeed(struct bfa_rport_s *rp)\n{\n\tstruct bfa_rport_speed_req_s *m;\n\n\t \n\tm = bfa_reqq_next(rp->bfa, BFA_REQQ_RPORT);\n\tif (!m) {\n\t\tbfa_trc(rp->bfa, rp->rport_info.speed);\n\t\treturn BFA_FALSE;\n\t}\n\n\tbfi_h2i_set(m->mh, BFI_MC_RPORT, BFI_RPORT_H2I_SET_SPEED_REQ,\n\t\t\tbfa_fn_lpu(rp->bfa));\n\tm->fw_handle = rp->fw_handle;\n\tm->speed = (u8)rp->rport_info.speed;\n\n\t \n\tbfa_reqq_produce(rp->bfa, BFA_REQQ_RPORT, m->mh);\n\treturn BFA_TRUE;\n}\n\n\n\n \n\n \nvoid\nbfa_rport_isr(struct bfa_s *bfa, struct bfi_msg_s *m)\n{\n\tunion bfi_rport_i2h_msg_u msg;\n\tstruct bfa_rport_s *rp;\n\n\tbfa_trc(bfa, m->mhdr.msg_id);\n\n\tmsg.msg = m;\n\n\tswitch (m->mhdr.msg_id) {\n\tcase BFI_RPORT_I2H_CREATE_RSP:\n\t\trp = BFA_RPORT_FROM_TAG(bfa, msg.create_rsp->bfa_handle);\n\t\trp->fw_handle = msg.create_rsp->fw_handle;\n\t\trp->qos_attr = msg.create_rsp->qos_attr;\n\t\tbfa_rport_set_lunmask(bfa, rp);\n\t\tWARN_ON(msg.create_rsp->status != BFA_STATUS_OK);\n\t\tbfa_sm_send_event(rp, BFA_RPORT_SM_FWRSP);\n\t\tbreak;\n\n\tcase BFI_RPORT_I2H_DELETE_RSP:\n\t\trp = BFA_RPORT_FROM_TAG(bfa, msg.delete_rsp->bfa_handle);\n\t\tWARN_ON(msg.delete_rsp->status != BFA_STATUS_OK);\n\t\tbfa_rport_unset_lunmask(bfa, rp);\n\t\tbfa_sm_send_event(rp, BFA_RPORT_SM_FWRSP);\n\t\tbreak;\n\n\tcase BFI_RPORT_I2H_QOS_SCN:\n\t\trp = BFA_RPORT_FROM_TAG(bfa, msg.qos_scn_evt->bfa_handle);\n\t\trp->event_arg.fw_msg = msg.qos_scn_evt;\n\t\tbfa_sm_send_event(rp, BFA_RPORT_SM_QOS_SCN);\n\t\tbreak;\n\n\tcase BFI_RPORT_I2H_LIP_SCN_ONLINE:\n\t\tbfa_fcport_update_loop_info(BFA_FCPORT_MOD(bfa),\n\t\t\t\t&msg.lip_scn->loop_info);\n\t\tbfa_cb_rport_scn_online(bfa);\n\t\tbreak;\n\n\tcase BFI_RPORT_I2H_LIP_SCN_OFFLINE:\n\t\tbfa_cb_rport_scn_offline(bfa);\n\t\tbreak;\n\n\tcase BFI_RPORT_I2H_NO_DEV:\n\t\trp = BFA_RPORT_FROM_TAG(bfa, msg.lip_scn->bfa_handle);\n\t\tbfa_cb_rport_scn_no_dev(rp->rport_drv);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_trc(bfa, m->mhdr.msg_id);\n\t\tWARN_ON(1);\n\t}\n}\n\nvoid\nbfa_rport_res_recfg(struct bfa_s *bfa, u16 num_rport_fw)\n{\n\tstruct bfa_rport_mod_s\t*mod = BFA_RPORT_MOD(bfa);\n\tstruct list_head\t*qe;\n\tint\ti;\n\n\tfor (i = 0; i < (mod->num_rports - num_rport_fw); i++) {\n\t\tbfa_q_deq_tail(&mod->rp_free_q, &qe);\n\t\tlist_add_tail(qe, &mod->rp_unused_q);\n\t}\n}\n\n \n\nstruct bfa_rport_s *\nbfa_rport_create(struct bfa_s *bfa, void *rport_drv)\n{\n\tstruct bfa_rport_s *rp;\n\n\trp = bfa_rport_alloc(BFA_RPORT_MOD(bfa));\n\n\tif (rp == NULL)\n\t\treturn NULL;\n\n\trp->bfa = bfa;\n\trp->rport_drv = rport_drv;\n\tmemset(&rp->stats, 0, sizeof(rp->stats));\n\n\tWARN_ON(!bfa_sm_cmp_state(rp, bfa_rport_sm_uninit));\n\tbfa_sm_send_event(rp, BFA_RPORT_SM_CREATE);\n\n\treturn rp;\n}\n\nvoid\nbfa_rport_online(struct bfa_rport_s *rport, struct bfa_rport_info_s *rport_info)\n{\n\tWARN_ON(rport_info->max_frmsz == 0);\n\n\t \n\tif (rport_info->max_frmsz == 0) {\n\t\tbfa_trc(rport->bfa, rport->rport_tag);\n\t\trport_info->max_frmsz = FC_MIN_PDUSZ;\n\t}\n\n\trport->rport_info = *rport_info;\n\tbfa_sm_send_event(rport, BFA_RPORT_SM_ONLINE);\n}\n\nvoid\nbfa_rport_speed(struct bfa_rport_s *rport, enum bfa_port_speed speed)\n{\n\tWARN_ON(speed == 0);\n\tWARN_ON(speed == BFA_PORT_SPEED_AUTO);\n\n\tif (rport) {\n\t\trport->rport_info.speed = speed;\n\t\tbfa_sm_send_event(rport, BFA_RPORT_SM_SET_SPEED);\n\t}\n}\n\n \nvoid\nbfa_rport_set_lunmask(struct bfa_s *bfa, struct bfa_rport_s *rp)\n{\n\tstruct bfa_lps_mod_s\t*lps_mod = BFA_LPS_MOD(bfa);\n\twwn_t\tlp_wwn, rp_wwn;\n\tu8 lp_tag = (u8)rp->rport_info.lp_tag;\n\n\trp_wwn = ((struct bfa_fcs_rport_s *)rp->rport_drv)->pwwn;\n\tlp_wwn = (BFA_LPS_FROM_TAG(lps_mod, rp->rport_info.lp_tag))->pwwn;\n\n\tBFA_LPS_FROM_TAG(lps_mod, rp->rport_info.lp_tag)->lun_mask =\n\t\t\t\t\trp->lun_mask = BFA_TRUE;\n\tbfa_fcpim_lunmask_rp_update(bfa, lp_wwn, rp_wwn, rp->rport_tag, lp_tag);\n}\n\n \nvoid\nbfa_rport_unset_lunmask(struct bfa_s *bfa, struct bfa_rport_s *rp)\n{\n\tstruct bfa_lps_mod_s\t*lps_mod = BFA_LPS_MOD(bfa);\n\twwn_t\tlp_wwn, rp_wwn;\n\n\trp_wwn = ((struct bfa_fcs_rport_s *)rp->rport_drv)->pwwn;\n\tlp_wwn = (BFA_LPS_FROM_TAG(lps_mod, rp->rport_info.lp_tag))->pwwn;\n\n\tBFA_LPS_FROM_TAG(lps_mod, rp->rport_info.lp_tag)->lun_mask =\n\t\t\t\trp->lun_mask = BFA_FALSE;\n\tbfa_fcpim_lunmask_rp_update(bfa, lp_wwn, rp_wwn,\n\t\t\tBFA_RPORT_TAG_INVALID, BFA_LP_TAG_INVALID);\n}\n\n \n\n \nvoid\nbfa_sgpg_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *minfo,\n\t\tstruct bfa_s *bfa)\n{\n\tstruct bfa_sgpg_mod_s *sgpg_mod = BFA_SGPG_MOD(bfa);\n\tstruct bfa_mem_kva_s *sgpg_kva = BFA_MEM_SGPG_KVA(bfa);\n\tstruct bfa_mem_dma_s *seg_ptr;\n\tu16\tnsegs, idx, per_seg_sgpg, num_sgpg;\n\tu32\tsgpg_sz = sizeof(struct bfi_sgpg_s);\n\n\tif (cfg->drvcfg.num_sgpgs < BFA_SGPG_MIN)\n\t\tcfg->drvcfg.num_sgpgs = BFA_SGPG_MIN;\n\telse if (cfg->drvcfg.num_sgpgs > BFA_SGPG_MAX)\n\t\tcfg->drvcfg.num_sgpgs = BFA_SGPG_MAX;\n\n\tnum_sgpg = cfg->drvcfg.num_sgpgs;\n\n\tnsegs = BFI_MEM_DMA_NSEGS(num_sgpg, sgpg_sz);\n\tper_seg_sgpg = BFI_MEM_NREQS_SEG(sgpg_sz);\n\n\tbfa_mem_dma_seg_iter(sgpg_mod, seg_ptr, nsegs, idx) {\n\t\tif (num_sgpg >= per_seg_sgpg) {\n\t\t\tnum_sgpg -= per_seg_sgpg;\n\t\t\tbfa_mem_dma_setup(minfo, seg_ptr,\n\t\t\t\t\tper_seg_sgpg * sgpg_sz);\n\t\t} else\n\t\t\tbfa_mem_dma_setup(minfo, seg_ptr,\n\t\t\t\t\tnum_sgpg * sgpg_sz);\n\t}\n\n\t \n\tbfa_mem_kva_setup(minfo, sgpg_kva,\n\t\tcfg->drvcfg.num_sgpgs * sizeof(struct bfa_sgpg_s));\n}\n\nvoid\nbfa_sgpg_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\t\tstruct bfa_pcidev_s *pcidev)\n{\n\tstruct bfa_sgpg_mod_s *mod = BFA_SGPG_MOD(bfa);\n\tstruct bfa_sgpg_s *hsgpg;\n\tstruct bfi_sgpg_s *sgpg;\n\tu64 align_len;\n\tstruct bfa_mem_dma_s *seg_ptr;\n\tu32\tsgpg_sz = sizeof(struct bfi_sgpg_s);\n\tu16\ti, idx, nsegs, per_seg_sgpg, num_sgpg;\n\n\tunion {\n\t\tu64 pa;\n\t\tunion bfi_addr_u addr;\n\t} sgpg_pa, sgpg_pa_tmp;\n\n\tINIT_LIST_HEAD(&mod->sgpg_q);\n\tINIT_LIST_HEAD(&mod->sgpg_wait_q);\n\n\tbfa_trc(bfa, cfg->drvcfg.num_sgpgs);\n\n\tmod->free_sgpgs = mod->num_sgpgs = cfg->drvcfg.num_sgpgs;\n\n\tnum_sgpg = cfg->drvcfg.num_sgpgs;\n\tnsegs = BFI_MEM_DMA_NSEGS(num_sgpg, sgpg_sz);\n\n\t \n\thsgpg = (struct bfa_sgpg_s *) bfa_mem_kva_curp(mod);\n\n\tbfa_mem_dma_seg_iter(mod, seg_ptr, nsegs, idx) {\n\n\t\tif (!bfa_mem_dma_virt(seg_ptr))\n\t\t\tbreak;\n\n\t\talign_len = BFA_SGPG_ROUNDUP(bfa_mem_dma_phys(seg_ptr)) -\n\t\t\t\t\t     bfa_mem_dma_phys(seg_ptr);\n\n\t\tsgpg = (struct bfi_sgpg_s *)\n\t\t\t(((u8 *) bfa_mem_dma_virt(seg_ptr)) + align_len);\n\t\tsgpg_pa.pa = bfa_mem_dma_phys(seg_ptr) + align_len;\n\t\tWARN_ON(sgpg_pa.pa & (sgpg_sz - 1));\n\n\t\tper_seg_sgpg = (seg_ptr->mem_len - (u32)align_len) / sgpg_sz;\n\n\t\tfor (i = 0; num_sgpg > 0 && i < per_seg_sgpg; i++, num_sgpg--) {\n\t\t\tmemset(hsgpg, 0, sizeof(*hsgpg));\n\t\t\tmemset(sgpg, 0, sizeof(*sgpg));\n\n\t\t\thsgpg->sgpg = sgpg;\n\t\t\tsgpg_pa_tmp.pa = bfa_sgaddr_le(sgpg_pa.pa);\n\t\t\thsgpg->sgpg_pa = sgpg_pa_tmp.addr;\n\t\t\tlist_add_tail(&hsgpg->qe, &mod->sgpg_q);\n\n\t\t\tsgpg++;\n\t\t\thsgpg++;\n\t\t\tsgpg_pa.pa += sgpg_sz;\n\t\t}\n\t}\n\n\tbfa_mem_kva_curp(mod) = (u8 *) hsgpg;\n}\n\nbfa_status_t\nbfa_sgpg_malloc(struct bfa_s *bfa, struct list_head *sgpg_q, int nsgpgs)\n{\n\tstruct bfa_sgpg_mod_s *mod = BFA_SGPG_MOD(bfa);\n\tstruct bfa_sgpg_s *hsgpg;\n\tint i;\n\n\tif (mod->free_sgpgs < nsgpgs)\n\t\treturn BFA_STATUS_ENOMEM;\n\n\tfor (i = 0; i < nsgpgs; i++) {\n\t\tbfa_q_deq(&mod->sgpg_q, &hsgpg);\n\t\tWARN_ON(!hsgpg);\n\t\tlist_add_tail(&hsgpg->qe, sgpg_q);\n\t}\n\n\tmod->free_sgpgs -= nsgpgs;\n\treturn BFA_STATUS_OK;\n}\n\nvoid\nbfa_sgpg_mfree(struct bfa_s *bfa, struct list_head *sgpg_q, int nsgpg)\n{\n\tstruct bfa_sgpg_mod_s *mod = BFA_SGPG_MOD(bfa);\n\tstruct bfa_sgpg_wqe_s *wqe;\n\n\tmod->free_sgpgs += nsgpg;\n\tWARN_ON(mod->free_sgpgs > mod->num_sgpgs);\n\n\tlist_splice_tail_init(sgpg_q, &mod->sgpg_q);\n\n\tif (list_empty(&mod->sgpg_wait_q))\n\t\treturn;\n\n\t \n\tdo {\n\t\twqe = bfa_q_first(&mod->sgpg_wait_q);\n\t\tif (mod->free_sgpgs < wqe->nsgpg)\n\t\t\tnsgpg = mod->free_sgpgs;\n\t\telse\n\t\t\tnsgpg = wqe->nsgpg;\n\t\tbfa_sgpg_malloc(bfa, &wqe->sgpg_q, nsgpg);\n\t\twqe->nsgpg -= nsgpg;\n\t\tif (wqe->nsgpg == 0) {\n\t\t\tlist_del(&wqe->qe);\n\t\t\twqe->cbfn(wqe->cbarg);\n\t\t}\n\t} while (mod->free_sgpgs && !list_empty(&mod->sgpg_wait_q));\n}\n\nvoid\nbfa_sgpg_wait(struct bfa_s *bfa, struct bfa_sgpg_wqe_s *wqe, int nsgpg)\n{\n\tstruct bfa_sgpg_mod_s *mod = BFA_SGPG_MOD(bfa);\n\n\tWARN_ON(nsgpg <= 0);\n\tWARN_ON(nsgpg <= mod->free_sgpgs);\n\n\twqe->nsgpg_total = wqe->nsgpg = nsgpg;\n\n\t \n\tif (mod->free_sgpgs) {\n\t\t \n\t\tWARN_ON(!list_empty(&mod->sgpg_wait_q));\n\t\tlist_splice_tail_init(&mod->sgpg_q, &wqe->sgpg_q);\n\t\twqe->nsgpg -= mod->free_sgpgs;\n\t\tmod->free_sgpgs = 0;\n\t}\n\n\tlist_add_tail(&wqe->qe, &mod->sgpg_wait_q);\n}\n\nvoid\nbfa_sgpg_wcancel(struct bfa_s *bfa, struct bfa_sgpg_wqe_s *wqe)\n{\n\tstruct bfa_sgpg_mod_s *mod = BFA_SGPG_MOD(bfa);\n\n\tWARN_ON(!bfa_q_is_on_q(&mod->sgpg_wait_q, wqe));\n\tlist_del(&wqe->qe);\n\n\tif (wqe->nsgpg_total != wqe->nsgpg)\n\t\tbfa_sgpg_mfree(bfa, &wqe->sgpg_q,\n\t\t\t\t   wqe->nsgpg_total - wqe->nsgpg);\n}\n\nvoid\nbfa_sgpg_winit(struct bfa_sgpg_wqe_s *wqe, void (*cbfn) (void *cbarg),\n\t\t   void *cbarg)\n{\n\tINIT_LIST_HEAD(&wqe->sgpg_q);\n\twqe->cbfn = cbfn;\n\twqe->cbarg = cbarg;\n}\n\n \n \nstatic void\n__bfa_cb_uf_recv(void *cbarg, bfa_boolean_t complete)\n{\n\tstruct bfa_uf_s   *uf = cbarg;\n\tstruct bfa_uf_mod_s *ufm = BFA_UF_MOD(uf->bfa);\n\n\tif (complete)\n\t\tufm->ufrecv(ufm->cbarg, uf);\n}\n\nstatic void\nclaim_uf_post_msgs(struct bfa_uf_mod_s *ufm)\n{\n\tstruct bfi_uf_buf_post_s *uf_bp_msg;\n\tu16 i;\n\tu16 buf_len;\n\n\tufm->uf_buf_posts = (struct bfi_uf_buf_post_s *) bfa_mem_kva_curp(ufm);\n\tuf_bp_msg = ufm->uf_buf_posts;\n\n\tfor (i = 0, uf_bp_msg = ufm->uf_buf_posts; i < ufm->num_ufs;\n\t     i++, uf_bp_msg++) {\n\t\tmemset(uf_bp_msg, 0, sizeof(struct bfi_uf_buf_post_s));\n\n\t\tuf_bp_msg->buf_tag = i;\n\t\tbuf_len = sizeof(struct bfa_uf_buf_s);\n\t\tuf_bp_msg->buf_len = cpu_to_be16(buf_len);\n\t\tbfi_h2i_set(uf_bp_msg->mh, BFI_MC_UF, BFI_UF_H2I_BUF_POST,\n\t\t\t    bfa_fn_lpu(ufm->bfa));\n\t\tbfa_alen_set(&uf_bp_msg->alen, buf_len, ufm_pbs_pa(ufm, i));\n\t}\n\n\t \n\tbfa_mem_kva_curp(ufm) = (u8 *) uf_bp_msg;\n}\n\nstatic void\nclaim_ufs(struct bfa_uf_mod_s *ufm)\n{\n\tu16 i;\n\tstruct bfa_uf_s   *uf;\n\n\t \n\tufm->uf_list = (struct bfa_uf_s *) bfa_mem_kva_curp(ufm);\n\n\t \n\tfor (i = 0, uf = ufm->uf_list; i < ufm->num_ufs; i++, uf++) {\n\t\tmemset(uf, 0, sizeof(struct bfa_uf_s));\n\t\tuf->bfa = ufm->bfa;\n\t\tuf->uf_tag = i;\n\t\tuf->pb_len = BFA_PER_UF_DMA_SZ;\n\t\tuf->buf_kva = bfa_mem_get_dmabuf_kva(ufm, i, BFA_PER_UF_DMA_SZ);\n\t\tuf->buf_pa = ufm_pbs_pa(ufm, i);\n\t\tlist_add_tail(&uf->qe, &ufm->uf_free_q);\n\t}\n\n\t \n\tbfa_mem_kva_curp(ufm) = (u8 *) uf;\n}\n\nstatic void\nuf_mem_claim(struct bfa_uf_mod_s *ufm)\n{\n\tclaim_ufs(ufm);\n\tclaim_uf_post_msgs(ufm);\n}\n\nvoid\nbfa_uf_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *minfo,\n\t\tstruct bfa_s *bfa)\n{\n\tstruct bfa_uf_mod_s *ufm = BFA_UF_MOD(bfa);\n\tstruct bfa_mem_kva_s *uf_kva = BFA_MEM_UF_KVA(bfa);\n\tu32\tnum_ufs = cfg->fwcfg.num_uf_bufs;\n\tstruct bfa_mem_dma_s *seg_ptr;\n\tu16\tnsegs, idx, per_seg_uf = 0;\n\n\tnsegs = BFI_MEM_DMA_NSEGS(num_ufs, BFA_PER_UF_DMA_SZ);\n\tper_seg_uf = BFI_MEM_NREQS_SEG(BFA_PER_UF_DMA_SZ);\n\n\tbfa_mem_dma_seg_iter(ufm, seg_ptr, nsegs, idx) {\n\t\tif (num_ufs >= per_seg_uf) {\n\t\t\tnum_ufs -= per_seg_uf;\n\t\t\tbfa_mem_dma_setup(minfo, seg_ptr,\n\t\t\t\tper_seg_uf * BFA_PER_UF_DMA_SZ);\n\t\t} else\n\t\t\tbfa_mem_dma_setup(minfo, seg_ptr,\n\t\t\t\tnum_ufs * BFA_PER_UF_DMA_SZ);\n\t}\n\n\t \n\tbfa_mem_kva_setup(minfo, uf_kva, cfg->fwcfg.num_uf_bufs *\n\t\t(sizeof(struct bfa_uf_s) + sizeof(struct bfi_uf_buf_post_s)));\n}\n\nvoid\nbfa_uf_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\t\tstruct bfa_pcidev_s *pcidev)\n{\n\tstruct bfa_uf_mod_s *ufm = BFA_UF_MOD(bfa);\n\n\tufm->bfa = bfa;\n\tufm->num_ufs = cfg->fwcfg.num_uf_bufs;\n\tINIT_LIST_HEAD(&ufm->uf_free_q);\n\tINIT_LIST_HEAD(&ufm->uf_posted_q);\n\tINIT_LIST_HEAD(&ufm->uf_unused_q);\n\n\tuf_mem_claim(ufm);\n}\n\nstatic struct bfa_uf_s *\nbfa_uf_get(struct bfa_uf_mod_s *uf_mod)\n{\n\tstruct bfa_uf_s   *uf;\n\n\tbfa_q_deq(&uf_mod->uf_free_q, &uf);\n\treturn uf;\n}\n\nstatic void\nbfa_uf_put(struct bfa_uf_mod_s *uf_mod, struct bfa_uf_s *uf)\n{\n\tlist_add_tail(&uf->qe, &uf_mod->uf_free_q);\n}\n\nstatic bfa_status_t\nbfa_uf_post(struct bfa_uf_mod_s *ufm, struct bfa_uf_s *uf)\n{\n\tstruct bfi_uf_buf_post_s *uf_post_msg;\n\n\tuf_post_msg = bfa_reqq_next(ufm->bfa, BFA_REQQ_FCXP);\n\tif (!uf_post_msg)\n\t\treturn BFA_STATUS_FAILED;\n\n\tmemcpy(uf_post_msg, &ufm->uf_buf_posts[uf->uf_tag],\n\t\t      sizeof(struct bfi_uf_buf_post_s));\n\tbfa_reqq_produce(ufm->bfa, BFA_REQQ_FCXP, uf_post_msg->mh);\n\n\tbfa_trc(ufm->bfa, uf->uf_tag);\n\n\tlist_add_tail(&uf->qe, &ufm->uf_posted_q);\n\treturn BFA_STATUS_OK;\n}\n\nstatic void\nbfa_uf_post_all(struct bfa_uf_mod_s *uf_mod)\n{\n\tstruct bfa_uf_s   *uf;\n\n\twhile ((uf = bfa_uf_get(uf_mod)) != NULL) {\n\t\tif (bfa_uf_post(uf_mod, uf) != BFA_STATUS_OK)\n\t\t\tbreak;\n\t}\n}\n\nstatic void\nuf_recv(struct bfa_s *bfa, struct bfi_uf_frm_rcvd_s *m)\n{\n\tstruct bfa_uf_mod_s *ufm = BFA_UF_MOD(bfa);\n\tu16 uf_tag = m->buf_tag;\n\tstruct bfa_uf_s *uf = &ufm->uf_list[uf_tag];\n\tstruct bfa_uf_buf_s *uf_buf;\n\tuint8_t *buf;\n\n\tuf_buf = (struct bfa_uf_buf_s *)\n\t\t\tbfa_mem_get_dmabuf_kva(ufm, uf_tag, uf->pb_len);\n\tbuf = &uf_buf->d[0];\n\n\tm->frm_len = be16_to_cpu(m->frm_len);\n\tm->xfr_len = be16_to_cpu(m->xfr_len);\n\n\tlist_del(&uf->qe);\t \n\n\tuf->data_ptr = buf;\n\tuf->data_len = m->xfr_len;\n\n\tWARN_ON(uf->data_len < sizeof(struct fchs_s));\n\n\tif (uf->data_len == sizeof(struct fchs_s)) {\n\t\tbfa_plog_fchdr(bfa->plog, BFA_PL_MID_HAL_UF, BFA_PL_EID_RX,\n\t\t\t       uf->data_len, (struct fchs_s *)buf);\n\t} else {\n\t\tu32 pld_w0 = *((u32 *) (buf + sizeof(struct fchs_s)));\n\t\tbfa_plog_fchdr_and_pl(bfa->plog, BFA_PL_MID_HAL_UF,\n\t\t\t\t      BFA_PL_EID_RX, uf->data_len,\n\t\t\t\t      (struct fchs_s *)buf, pld_w0);\n\t}\n\n\tif (bfa->fcs)\n\t\t__bfa_cb_uf_recv(uf, BFA_TRUE);\n\telse\n\t\tbfa_cb_queue(bfa, &uf->hcb_qe, __bfa_cb_uf_recv, uf);\n}\n\nvoid\nbfa_uf_iocdisable(struct bfa_s *bfa)\n{\n\tstruct bfa_uf_mod_s *ufm = BFA_UF_MOD(bfa);\n\tstruct bfa_uf_s *uf;\n\tstruct list_head *qe, *qen;\n\n\t \n\tlist_splice_tail_init(&ufm->uf_unused_q, &ufm->uf_free_q);\n\n\tlist_for_each_safe(qe, qen, &ufm->uf_posted_q) {\n\t\tuf = (struct bfa_uf_s *) qe;\n\t\tlist_del(&uf->qe);\n\t\tbfa_uf_put(ufm, uf);\n\t}\n}\n\nvoid\nbfa_uf_start(struct bfa_s *bfa)\n{\n\tbfa_uf_post_all(BFA_UF_MOD(bfa));\n}\n\n \nvoid\nbfa_uf_recv_register(struct bfa_s *bfa, bfa_cb_uf_recv_t ufrecv, void *cbarg)\n{\n\tstruct bfa_uf_mod_s *ufm = BFA_UF_MOD(bfa);\n\n\tufm->ufrecv = ufrecv;\n\tufm->cbarg = cbarg;\n}\n\n \nvoid\nbfa_uf_free(struct bfa_uf_s *uf)\n{\n\tbfa_uf_put(BFA_UF_MOD(uf->bfa), uf);\n\tbfa_uf_post_all(BFA_UF_MOD(uf->bfa));\n}\n\n\n\n \nvoid\nbfa_uf_isr(struct bfa_s *bfa, struct bfi_msg_s *msg)\n{\n\tbfa_trc(bfa, msg->mhdr.msg_id);\n\n\tswitch (msg->mhdr.msg_id) {\n\tcase BFI_UF_I2H_FRM_RCVD:\n\t\tuf_recv(bfa, (struct bfi_uf_frm_rcvd_s *) msg);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_trc(bfa, msg->mhdr.msg_id);\n\t\tWARN_ON(1);\n\t}\n}\n\nvoid\nbfa_uf_res_recfg(struct bfa_s *bfa, u16 num_uf_fw)\n{\n\tstruct bfa_uf_mod_s\t*mod = BFA_UF_MOD(bfa);\n\tstruct list_head\t*qe;\n\tint\ti;\n\n\tfor (i = 0; i < (mod->num_ufs - num_uf_fw); i++) {\n\t\tbfa_q_deq_tail(&mod->uf_free_q, &qe);\n\t\tlist_add_tail(qe, &mod->uf_unused_q);\n\t}\n}\n\n \n\nenum bfa_dport_test_state_e {\n\tBFA_DPORT_ST_DISABLED\t= 0,\t \n\tBFA_DPORT_ST_INP\t= 1,\t \n\tBFA_DPORT_ST_COMP\t= 2,\t \n\tBFA_DPORT_ST_NO_SFP\t= 3,\t \n\tBFA_DPORT_ST_NOTSTART\t= 4,\t \n};\n\n \nenum bfa_dport_sm_event {\n\tBFA_DPORT_SM_ENABLE\t= 1,\t \n\tBFA_DPORT_SM_DISABLE    = 2,     \n\tBFA_DPORT_SM_FWRSP      = 3,     \n\tBFA_DPORT_SM_QRESUME    = 4,     \n\tBFA_DPORT_SM_HWFAIL     = 5,     \n\tBFA_DPORT_SM_START\t= 6,\t \n\tBFA_DPORT_SM_REQFAIL\t= 7,\t \n\tBFA_DPORT_SM_SCN\t= 8,\t \n};\n\nstatic void bfa_dport_sm_disabled(struct bfa_dport_s *dport,\n\t\t\t\t  enum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_enabling_qwait(struct bfa_dport_s *dport,\n\t\t\t\t  enum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_enabling(struct bfa_dport_s *dport,\n\t\t\t\t  enum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_enabled(struct bfa_dport_s *dport,\n\t\t\t\t enum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_disabling_qwait(struct bfa_dport_s *dport,\n\t\t\t\t enum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_disabling(struct bfa_dport_s *dport,\n\t\t\t\t   enum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_starting_qwait(struct bfa_dport_s *dport,\n\t\t\t\t\tenum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_starting(struct bfa_dport_s *dport,\n\t\t\t\t  enum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_dynamic_disabling(struct bfa_dport_s *dport,\n\t\t\t\t   enum bfa_dport_sm_event event);\nstatic void bfa_dport_sm_dynamic_disabling_qwait(struct bfa_dport_s *dport,\n\t\t\t\t   enum bfa_dport_sm_event event);\nstatic void bfa_dport_qresume(void *cbarg);\nstatic void bfa_dport_req_comp(struct bfa_dport_s *dport,\n\t\t\t\tstruct bfi_diag_dport_rsp_s *msg);\nstatic void bfa_dport_scn(struct bfa_dport_s *dport,\n\t\t\t\tstruct bfi_diag_dport_scn_s *msg);\n\n \n#define BFA_DIAG_QTEST_TOV\t1000     \n\n \nstatic void\nbfa_fcdiag_set_busy_status(struct bfa_fcdiag_s *fcdiag)\n{\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(fcdiag->bfa);\n\n\tif (fcdiag->lb.lock)\n\t\tfcport->diag_busy = BFA_TRUE;\n\telse\n\t\tfcport->diag_busy = BFA_FALSE;\n}\n\nvoid\nbfa_fcdiag_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\t\tstruct bfa_pcidev_s *pcidev)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\tstruct bfa_dport_s  *dport = &fcdiag->dport;\n\n\tfcdiag->bfa             = bfa;\n\tfcdiag->trcmod  = bfa->trcmod;\n\t \n\tdport->bfa = bfa;\n\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\tbfa_reqq_winit(&dport->reqq_wait, bfa_dport_qresume, dport);\n\tdport->cbfn = NULL;\n\tdport->cbarg = NULL;\n\tdport->test_state = BFA_DPORT_ST_DISABLED;\n\tmemset(&dport->result, 0, sizeof(struct bfa_diag_dport_result_s));\n}\n\nvoid\nbfa_fcdiag_iocdisable(struct bfa_s *bfa)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\tstruct bfa_dport_s *dport = &fcdiag->dport;\n\n\tbfa_trc(fcdiag, fcdiag->lb.lock);\n\tif (fcdiag->lb.lock) {\n\t\tfcdiag->lb.status = BFA_STATUS_IOC_FAILURE;\n\t\tfcdiag->lb.cbfn(fcdiag->lb.cbarg, fcdiag->lb.status);\n\t\tfcdiag->lb.lock = 0;\n\t\tbfa_fcdiag_set_busy_status(fcdiag);\n\t}\n\n\tbfa_sm_send_event(dport, BFA_DPORT_SM_HWFAIL);\n}\n\nstatic void\nbfa_fcdiag_queuetest_timeout(void *cbarg)\n{\n\tstruct bfa_fcdiag_s       *fcdiag = cbarg;\n\tstruct bfa_diag_qtest_result_s *res = fcdiag->qtest.result;\n\n\tbfa_trc(fcdiag, fcdiag->qtest.all);\n\tbfa_trc(fcdiag, fcdiag->qtest.count);\n\n\tfcdiag->qtest.timer_active = 0;\n\n\tres->status = BFA_STATUS_ETIMER;\n\tres->count  = QTEST_CNT_DEFAULT - fcdiag->qtest.count;\n\tif (fcdiag->qtest.all)\n\t\tres->queue  = fcdiag->qtest.all;\n\n\tbfa_trc(fcdiag, BFA_STATUS_ETIMER);\n\tfcdiag->qtest.status = BFA_STATUS_ETIMER;\n\tfcdiag->qtest.cbfn(fcdiag->qtest.cbarg, fcdiag->qtest.status);\n\tfcdiag->qtest.lock = 0;\n}\n\nstatic bfa_status_t\nbfa_fcdiag_queuetest_send(struct bfa_fcdiag_s *fcdiag)\n{\n\tu32\ti;\n\tstruct bfi_diag_qtest_req_s *req;\n\n\treq = bfa_reqq_next(fcdiag->bfa, fcdiag->qtest.queue);\n\tif (!req)\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\t \n\tbfi_h2i_set(req->mh, BFI_MC_DIAG, BFI_DIAG_H2I_QTEST,\n\t\tbfa_fn_lpu(fcdiag->bfa));\n\n\tfor (i = 0; i < BFI_LMSG_PL_WSZ; i++)\n\t\treq->data[i] = QTEST_PAT_DEFAULT;\n\n\tbfa_trc(fcdiag, fcdiag->qtest.queue);\n\t \n\tbfa_reqq_produce(fcdiag->bfa, fcdiag->qtest.queue, req->mh);\n\treturn BFA_STATUS_OK;\n}\n\nstatic void\nbfa_fcdiag_queuetest_comp(struct bfa_fcdiag_s *fcdiag,\n\t\t\tbfi_diag_qtest_rsp_t *rsp)\n{\n\tstruct bfa_diag_qtest_result_s *res = fcdiag->qtest.result;\n\tbfa_status_t status = BFA_STATUS_OK;\n\tint i;\n\n\t \n\tif (!fcdiag->qtest.timer_active) {\n\t\tbfa_trc(fcdiag, fcdiag->qtest.timer_active);\n\t\treturn;\n\t}\n\n\t \n\tfcdiag->qtest.count--;\n\n\t \n\tfor (i = 0; i < BFI_LMSG_PL_WSZ; i++) {\n\t\tif (rsp->data[i] != ~(QTEST_PAT_DEFAULT)) {\n\t\t\tres->status = BFA_STATUS_DATACORRUPTED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (res->status == BFA_STATUS_OK) {\n\t\tif (fcdiag->qtest.count > 0) {\n\t\t\tstatus = bfa_fcdiag_queuetest_send(fcdiag);\n\t\t\tif (status == BFA_STATUS_OK)\n\t\t\t\treturn;\n\t\t\telse\n\t\t\t\tres->status = status;\n\t\t} else if (fcdiag->qtest.all > 0 &&\n\t\t\tfcdiag->qtest.queue < (BFI_IOC_MAX_CQS - 1)) {\n\t\t\tfcdiag->qtest.count = QTEST_CNT_DEFAULT;\n\t\t\tfcdiag->qtest.queue++;\n\t\t\tstatus = bfa_fcdiag_queuetest_send(fcdiag);\n\t\t\tif (status == BFA_STATUS_OK)\n\t\t\t\treturn;\n\t\t\telse\n\t\t\t\tres->status = status;\n\t\t}\n\t}\n\n\t \n\tif (fcdiag->qtest.timer_active) {\n\t\tbfa_timer_stop(&fcdiag->qtest.timer);\n\t\tfcdiag->qtest.timer_active = 0;\n\t}\n\tres->queue = fcdiag->qtest.queue;\n\tres->count = QTEST_CNT_DEFAULT - fcdiag->qtest.count;\n\tbfa_trc(fcdiag, res->count);\n\tbfa_trc(fcdiag, res->status);\n\tfcdiag->qtest.status = res->status;\n\tfcdiag->qtest.cbfn(fcdiag->qtest.cbarg, fcdiag->qtest.status);\n\tfcdiag->qtest.lock = 0;\n}\n\nstatic void\nbfa_fcdiag_loopback_comp(struct bfa_fcdiag_s *fcdiag,\n\t\t\tstruct bfi_diag_lb_rsp_s *rsp)\n{\n\tstruct bfa_diag_loopback_result_s *res = fcdiag->lb.result;\n\n\tres->numtxmfrm  = be32_to_cpu(rsp->res.numtxmfrm);\n\tres->numosffrm  = be32_to_cpu(rsp->res.numosffrm);\n\tres->numrcvfrm  = be32_to_cpu(rsp->res.numrcvfrm);\n\tres->badfrminf  = be32_to_cpu(rsp->res.badfrminf);\n\tres->badfrmnum  = be32_to_cpu(rsp->res.badfrmnum);\n\tres->status     = rsp->res.status;\n\tfcdiag->lb.status = rsp->res.status;\n\tbfa_trc(fcdiag, fcdiag->lb.status);\n\tfcdiag->lb.cbfn(fcdiag->lb.cbarg, fcdiag->lb.status);\n\tfcdiag->lb.lock = 0;\n\tbfa_fcdiag_set_busy_status(fcdiag);\n}\n\nstatic bfa_status_t\nbfa_fcdiag_loopback_send(struct bfa_fcdiag_s *fcdiag,\n\t\t\tstruct bfa_diag_loopback_s *loopback)\n{\n\tstruct bfi_diag_lb_req_s *lb_req;\n\n\tlb_req = bfa_reqq_next(fcdiag->bfa, BFA_REQQ_DIAG);\n\tif (!lb_req)\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\t \n\tbfi_h2i_set(lb_req->mh, BFI_MC_DIAG, BFI_DIAG_H2I_LOOPBACK,\n\t\tbfa_fn_lpu(fcdiag->bfa));\n\n\tlb_req->lb_mode = loopback->lb_mode;\n\tlb_req->speed = loopback->speed;\n\tlb_req->loopcnt = loopback->loopcnt;\n\tlb_req->pattern = loopback->pattern;\n\n\t \n\tbfa_reqq_produce(fcdiag->bfa, BFA_REQQ_DIAG, lb_req->mh);\n\n\tbfa_trc(fcdiag, loopback->lb_mode);\n\tbfa_trc(fcdiag, loopback->speed);\n\tbfa_trc(fcdiag, loopback->loopcnt);\n\tbfa_trc(fcdiag, loopback->pattern);\n\treturn BFA_STATUS_OK;\n}\n\n \nvoid\nbfa_fcdiag_intr(struct bfa_s *bfa, struct bfi_msg_s *msg)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\n\tswitch (msg->mhdr.msg_id) {\n\tcase BFI_DIAG_I2H_LOOPBACK:\n\t\tbfa_fcdiag_loopback_comp(fcdiag,\n\t\t\t\t(struct bfi_diag_lb_rsp_s *) msg);\n\t\tbreak;\n\tcase BFI_DIAG_I2H_QTEST:\n\t\tbfa_fcdiag_queuetest_comp(fcdiag, (bfi_diag_qtest_rsp_t *)msg);\n\t\tbreak;\n\tcase BFI_DIAG_I2H_DPORT:\n\t\tbfa_dport_req_comp(&fcdiag->dport,\n\t\t\t\t(struct bfi_diag_dport_rsp_s *)msg);\n\t\tbreak;\n\tcase BFI_DIAG_I2H_DPORT_SCN:\n\t\tbfa_dport_scn(&fcdiag->dport,\n\t\t\t\t(struct bfi_diag_dport_scn_s *)msg);\n\t\tbreak;\n\tdefault:\n\t\tbfa_trc(fcdiag, msg->mhdr.msg_id);\n\t\tWARN_ON(1);\n\t}\n}\n\n \nbfa_status_t\nbfa_fcdiag_loopback(struct bfa_s *bfa, enum bfa_port_opmode opmode,\n\t\tenum bfa_port_speed speed, u32 lpcnt, u32 pat,\n\t\tstruct bfa_diag_loopback_result_s *result, bfa_cb_diag_t cbfn,\n\t\tvoid *cbarg)\n{\n\tstruct  bfa_diag_loopback_s loopback;\n\tstruct bfa_port_attr_s attr;\n\tbfa_status_t status;\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\n\tif (!bfa_iocfc_is_operational(bfa))\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\t \n\tif (bfa_fcport_is_pbcdisabled(bfa)) {\n\t\tbfa_trc(fcdiag, BFA_STATUS_PBC);\n\t\treturn BFA_STATUS_PBC;\n\t}\n\n\tif (bfa_fcport_is_disabled(bfa) == BFA_FALSE) {\n\t\tbfa_trc(fcdiag, opmode);\n\t\treturn BFA_STATUS_PORT_NOT_DISABLED;\n\t}\n\n\t \n\tif (bfa_ioc_get_type(&bfa->ioc) == BFA_IOC_TYPE_FC) {\n\t\tif (!(speed == BFA_PORT_SPEED_1GBPS ||\n\t\t      speed == BFA_PORT_SPEED_2GBPS ||\n\t\t      speed == BFA_PORT_SPEED_4GBPS ||\n\t\t      speed == BFA_PORT_SPEED_8GBPS ||\n\t\t      speed == BFA_PORT_SPEED_16GBPS ||\n\t\t      speed == BFA_PORT_SPEED_AUTO)) {\n\t\t\tbfa_trc(fcdiag, speed);\n\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t\t}\n\t\tbfa_fcport_get_attr(bfa, &attr);\n\t\tbfa_trc(fcdiag, attr.speed_supported);\n\t\tif (speed > attr.speed_supported)\n\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t} else {\n\t\tif (speed != BFA_PORT_SPEED_10GBPS) {\n\t\t\tbfa_trc(fcdiag, speed);\n\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t\t}\n\t}\n\n\t \n\tif ((speed == BFA_PORT_SPEED_1GBPS) &&\n\t    (bfa_asic_id_ct2(bfa->ioc.pcidev.device_id))) {\n\t\tbfa_trc(fcdiag, speed);\n\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t}\n\n\t \n\tif (bfa_mfg_is_mezz(bfa->ioc.attr->card_type)) {\n\t\tif (bfa_ioc_get_type(&bfa->ioc) == BFA_IOC_TYPE_FC) {\n\t\t\tif (!(speed == BFA_PORT_SPEED_1GBPS ||\n\t\t\t      speed == BFA_PORT_SPEED_2GBPS ||\n\t\t\t      speed == BFA_PORT_SPEED_4GBPS ||\n\t\t\t      speed == BFA_PORT_SPEED_8GBPS ||\n\t\t\t      speed == BFA_PORT_SPEED_16GBPS ||\n\t\t\t      speed == BFA_PORT_SPEED_AUTO))\n\t\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t\t} else {\n\t\t\tif (speed != BFA_PORT_SPEED_10GBPS)\n\t\t\t\treturn BFA_STATUS_UNSUPP_SPEED;\n\t\t}\n\t}\n\t \n\tif (bfa_fcport_is_dport(bfa)) {\n\t\tbfa_trc(fcdiag, fcdiag->lb.lock);\n\t\treturn BFA_STATUS_DPORT_ENABLED;\n\t}\n\t \n\tif (fcdiag->lb.lock) {\n\t\tbfa_trc(fcdiag, fcdiag->lb.lock);\n\t\treturn BFA_STATUS_DEVBUSY;\n\t}\n\n\tfcdiag->lb.lock = 1;\n\tloopback.lb_mode = opmode;\n\tloopback.speed = speed;\n\tloopback.loopcnt = lpcnt;\n\tloopback.pattern = pat;\n\tfcdiag->lb.result = result;\n\tfcdiag->lb.cbfn = cbfn;\n\tfcdiag->lb.cbarg = cbarg;\n\tmemset(result, 0, sizeof(struct bfa_diag_loopback_result_s));\n\tbfa_fcdiag_set_busy_status(fcdiag);\n\n\t \n\tstatus = bfa_fcdiag_loopback_send(fcdiag, &loopback);\n\treturn status;\n}\n\n \nbfa_status_t\nbfa_fcdiag_queuetest(struct bfa_s *bfa, u32 force, u32 queue,\n\t\tstruct bfa_diag_qtest_result_s *result, bfa_cb_diag_t cbfn,\n\t\tvoid *cbarg)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\tbfa_status_t status;\n\tbfa_trc(fcdiag, force);\n\tbfa_trc(fcdiag, queue);\n\n\tif (!force && !bfa_iocfc_is_operational(bfa))\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\t \n\tif (fcdiag->qtest.lock) {\n\t\tbfa_trc(fcdiag, fcdiag->qtest.lock);\n\t\treturn BFA_STATUS_DEVBUSY;\n\t}\n\n\t \n\tfcdiag->qtest.lock = 1;\n\tfcdiag->qtest.cbfn = cbfn;\n\tfcdiag->qtest.cbarg = cbarg;\n\tfcdiag->qtest.result = result;\n\tfcdiag->qtest.count = QTEST_CNT_DEFAULT;\n\n\t \n\tfcdiag->qtest.result->status = BFA_STATUS_OK;\n\tfcdiag->qtest.result->count  = 0;\n\n\t \n\tif (queue < BFI_IOC_MAX_CQS) {\n\t\tfcdiag->qtest.result->queue  = (u8)queue;\n\t\tfcdiag->qtest.queue = (u8)queue;\n\t\tfcdiag->qtest.all   = 0;\n\t} else {\n\t\tfcdiag->qtest.result->queue  = 0;\n\t\tfcdiag->qtest.queue = 0;\n\t\tfcdiag->qtest.all   = 1;\n\t}\n\tstatus = bfa_fcdiag_queuetest_send(fcdiag);\n\n\t \n\tif (status == BFA_STATUS_OK) {\n\t\tbfa_timer_start(bfa, &fcdiag->qtest.timer,\n\t\t\t\tbfa_fcdiag_queuetest_timeout, fcdiag,\n\t\t\t\tBFA_DIAG_QTEST_TOV);\n\t\tfcdiag->qtest.timer_active = 1;\n\t}\n\treturn status;\n}\n\n \nbfa_status_t\nbfa_fcdiag_lb_is_running(struct bfa_s *bfa)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\treturn fcdiag->lb.lock ?  BFA_STATUS_DIAG_BUSY : BFA_STATUS_OK;\n}\n\n \n#define bfa_dport_result_start(__dport, __mode) do {\t\t\t\t\\\n\t\t(__dport)->result.start_time = ktime_get_real_seconds();\t\\\n\t\t(__dport)->result.status = DPORT_TEST_ST_INPRG;\t\t\t\\\n\t\t(__dport)->result.mode = (__mode);\t\t\t\t\\\n\t\t(__dport)->result.rp_pwwn = (__dport)->rp_pwwn;\t\t\t\\\n\t\t(__dport)->result.rp_nwwn = (__dport)->rp_nwwn;\t\t\t\\\n\t\t(__dport)->result.lpcnt = (__dport)->lpcnt;\t\t\t\\\n} while (0)\n\nstatic bfa_boolean_t bfa_dport_send_req(struct bfa_dport_s *dport,\n\t\t\t\t\tenum bfi_dport_req req);\nstatic void\nbfa_cb_fcdiag_dport(struct bfa_dport_s *dport, bfa_status_t bfa_status)\n{\n\tif (dport->cbfn != NULL) {\n\t\tdport->cbfn(dport->cbarg, bfa_status);\n\t\tdport->cbfn = NULL;\n\t\tdport->cbarg = NULL;\n\t}\n}\n\nstatic void\nbfa_dport_sm_disabled(struct bfa_dport_s *dport, enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_ENABLE:\n\t\tbfa_fcport_dportenable(dport->bfa);\n\t\tif (bfa_dport_send_req(dport, BFI_DPORT_ENABLE))\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_enabling);\n\t\telse\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_enabling_qwait);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_DISABLE:\n\t\t \n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\t \n\t\tbreak;\n\n\tcase BFA_DPORT_SM_SCN:\n\t\tif (dport->i2hmsg.scn.state ==  BFI_DPORT_SCN_DDPORT_ENABLE) {\n\t\t\tbfa_fcport_ddportenable(dport->bfa);\n\t\t\tdport->dynamic = BFA_TRUE;\n\t\t\tdport->test_state = BFA_DPORT_ST_NOTSTART;\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_enabled);\n\t\t} else {\n\t\t\tbfa_trc(dport->bfa, dport->i2hmsg.scn.state);\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_enabling_qwait(struct bfa_dport_s *dport,\n\t\t\t    enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_enabling);\n\t\tbfa_dport_send_req(dport, BFI_DPORT_ENABLE);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_reqq_wcancel(&dport->reqq_wait);\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbfa_cb_fcdiag_dport(dport, BFA_STATUS_FAILED);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_enabling(struct bfa_dport_s *dport, enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_FWRSP:\n\t\tmemset(&dport->result, 0,\n\t\t\t\tsizeof(struct bfa_diag_dport_result_s));\n\t\tif (dport->i2hmsg.rsp.status == BFA_STATUS_DPORT_INV_SFP) {\n\t\t\tdport->test_state = BFA_DPORT_ST_NO_SFP;\n\t\t} else {\n\t\t\tdport->test_state = BFA_DPORT_ST_INP;\n\t\t\tbfa_dport_result_start(dport, BFA_DPORT_OPMODE_AUTO);\n\t\t}\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_enabled);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_REQFAIL:\n\t\tdport->test_state = BFA_DPORT_ST_DISABLED;\n\t\tbfa_fcport_dportdisable(dport->bfa);\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbfa_cb_fcdiag_dport(dport, BFA_STATUS_FAILED);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_enabled(struct bfa_dport_s *dport, enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_START:\n\t\tif (bfa_dport_send_req(dport, BFI_DPORT_START))\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_starting);\n\t\telse\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_starting_qwait);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_DISABLE:\n\t\tbfa_fcport_dportdisable(dport->bfa);\n\t\tif (bfa_dport_send_req(dport, BFI_DPORT_DISABLE))\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabling);\n\t\telse\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabling_qwait);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_SCN:\n\t\tswitch (dport->i2hmsg.scn.state) {\n\t\tcase BFI_DPORT_SCN_TESTCOMP:\n\t\t\tdport->test_state = BFA_DPORT_ST_COMP;\n\t\t\tbreak;\n\n\t\tcase BFI_DPORT_SCN_TESTSTART:\n\t\t\tdport->test_state = BFA_DPORT_ST_INP;\n\t\t\tbreak;\n\n\t\tcase BFI_DPORT_SCN_TESTSKIP:\n\t\tcase BFI_DPORT_SCN_SUBTESTSTART:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase BFI_DPORT_SCN_SFP_REMOVED:\n\t\t\tdport->test_state = BFA_DPORT_ST_NO_SFP;\n\t\t\tbreak;\n\n\t\tcase BFI_DPORT_SCN_DDPORT_DISABLE:\n\t\t\tbfa_fcport_ddportdisable(dport->bfa);\n\n\t\t\tif (bfa_dport_send_req(dport, BFI_DPORT_DYN_DISABLE))\n\t\t\t\tbfa_sm_set_state(dport,\n\t\t\t\t\t bfa_dport_sm_dynamic_disabling);\n\t\t\telse\n\t\t\t\tbfa_sm_set_state(dport,\n\t\t\t\t\t bfa_dport_sm_dynamic_disabling_qwait);\n\t\t\tbreak;\n\n\t\tcase BFI_DPORT_SCN_FCPORT_DISABLE:\n\t\t\tbfa_fcport_ddportdisable(dport->bfa);\n\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\t\tdport->dynamic = BFA_FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbfa_trc(dport->bfa, dport->i2hmsg.scn.state);\n\t\t\tbfa_sm_fault(dport->bfa, event);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_disabling_qwait(struct bfa_dport_s *dport,\n\t\t\t     enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabling);\n\t\tbfa_dport_send_req(dport, BFI_DPORT_DISABLE);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbfa_reqq_wcancel(&dport->reqq_wait);\n\t\tbfa_cb_fcdiag_dport(dport, BFA_STATUS_OK);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_SCN:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_disabling(struct bfa_dport_s *dport, enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_FWRSP:\n\t\tdport->test_state = BFA_DPORT_ST_DISABLED;\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbfa_cb_fcdiag_dport(dport, BFA_STATUS_OK);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_SCN:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_starting_qwait(struct bfa_dport_s *dport,\n\t\t\t    enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_starting);\n\t\tbfa_dport_send_req(dport, BFI_DPORT_START);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_reqq_wcancel(&dport->reqq_wait);\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbfa_cb_fcdiag_dport(dport, BFA_STATUS_FAILED);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_starting(struct bfa_dport_s *dport, enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_FWRSP:\n\t\tmemset(&dport->result, 0,\n\t\t\t\tsizeof(struct bfa_diag_dport_result_s));\n\t\tif (dport->i2hmsg.rsp.status == BFA_STATUS_DPORT_INV_SFP) {\n\t\t\tdport->test_state = BFA_DPORT_ST_NO_SFP;\n\t\t} else {\n\t\t\tdport->test_state = BFA_DPORT_ST_INP;\n\t\t\tbfa_dport_result_start(dport, BFA_DPORT_OPMODE_MANU);\n\t\t}\n\t\tfallthrough;\n\n\tcase BFA_DPORT_SM_REQFAIL:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_enabled);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbfa_cb_fcdiag_dport(dport, BFA_STATUS_FAILED);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_dynamic_disabling(struct bfa_dport_s *dport,\n\t\t\t       enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_SCN:\n\t\tswitch (dport->i2hmsg.scn.state) {\n\t\tcase BFI_DPORT_SCN_DDPORT_DISABLED:\n\t\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\t\tdport->dynamic = BFA_FALSE;\n\t\t\tbfa_fcport_enable(dport->bfa);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbfa_trc(dport->bfa, dport->i2hmsg.scn.state);\n\t\t\tbfa_sm_fault(dport->bfa, event);\n\n\t\t}\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbfa_cb_fcdiag_dport(dport, BFA_STATUS_OK);\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic void\nbfa_dport_sm_dynamic_disabling_qwait(struct bfa_dport_s *dport,\n\t\t\t    enum bfa_dport_sm_event event)\n{\n\tbfa_trc(dport->bfa, event);\n\n\tswitch (event) {\n\tcase BFA_DPORT_SM_QRESUME:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_dynamic_disabling);\n\t\tbfa_dport_send_req(dport, BFI_DPORT_DYN_DISABLE);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_HWFAIL:\n\t\tbfa_sm_set_state(dport, bfa_dport_sm_disabled);\n\t\tbfa_reqq_wcancel(&dport->reqq_wait);\n\t\tbfa_cb_fcdiag_dport(dport, BFA_STATUS_OK);\n\t\tbreak;\n\n\tcase BFA_DPORT_SM_SCN:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, event);\n\t}\n}\n\nstatic bfa_boolean_t\nbfa_dport_send_req(struct bfa_dport_s *dport, enum bfi_dport_req req)\n{\n\tstruct bfi_diag_dport_req_s *m;\n\n\t \n\tm = bfa_reqq_next(dport->bfa, BFA_REQQ_DIAG);\n\tif (!m) {\n\t\tbfa_reqq_wait(dport->bfa, BFA_REQQ_PORT, &dport->reqq_wait);\n\t\treturn BFA_FALSE;\n\t}\n\n\tbfi_h2i_set(m->mh, BFI_MC_DIAG, BFI_DIAG_H2I_DPORT,\n\t\t    bfa_fn_lpu(dport->bfa));\n\tm->req  = req;\n\tif ((req == BFI_DPORT_ENABLE) || (req == BFI_DPORT_START)) {\n\t\tm->lpcnt = cpu_to_be32(dport->lpcnt);\n\t\tm->payload = cpu_to_be32(dport->payload);\n\t}\n\n\t \n\tbfa_reqq_produce(dport->bfa, BFA_REQQ_DIAG, m->mh);\n\n\treturn BFA_TRUE;\n}\n\nstatic void\nbfa_dport_qresume(void *cbarg)\n{\n\tstruct bfa_dport_s *dport = cbarg;\n\n\tbfa_sm_send_event(dport, BFA_DPORT_SM_QRESUME);\n}\n\nstatic void\nbfa_dport_req_comp(struct bfa_dport_s *dport, struct bfi_diag_dport_rsp_s *msg)\n{\n\tmsg->status = cpu_to_be32(msg->status);\n\tdport->i2hmsg.rsp.status = msg->status;\n\tdport->rp_pwwn = msg->pwwn;\n\tdport->rp_nwwn = msg->nwwn;\n\n\tif ((msg->status == BFA_STATUS_OK) ||\n\t    (msg->status == BFA_STATUS_DPORT_NO_SFP)) {\n\t\tbfa_trc(dport->bfa, msg->status);\n\t\tbfa_trc(dport->bfa, dport->rp_pwwn);\n\t\tbfa_trc(dport->bfa, dport->rp_nwwn);\n\t\tbfa_sm_send_event(dport, BFA_DPORT_SM_FWRSP);\n\n\t} else {\n\t\tbfa_trc(dport->bfa, msg->status);\n\t\tbfa_sm_send_event(dport, BFA_DPORT_SM_REQFAIL);\n\t}\n\tbfa_cb_fcdiag_dport(dport, msg->status);\n}\n\nstatic bfa_boolean_t\nbfa_dport_is_sending_req(struct bfa_dport_s *dport)\n{\n\tif (bfa_sm_cmp_state(dport, bfa_dport_sm_enabling)\t||\n\t    bfa_sm_cmp_state(dport, bfa_dport_sm_enabling_qwait) ||\n\t    bfa_sm_cmp_state(dport, bfa_dport_sm_disabling)\t||\n\t    bfa_sm_cmp_state(dport, bfa_dport_sm_disabling_qwait) ||\n\t    bfa_sm_cmp_state(dport, bfa_dport_sm_starting)\t||\n\t    bfa_sm_cmp_state(dport, bfa_dport_sm_starting_qwait)) {\n\t\treturn BFA_TRUE;\n\t} else {\n\t\treturn BFA_FALSE;\n\t}\n}\n\nstatic void\nbfa_dport_scn(struct bfa_dport_s *dport, struct bfi_diag_dport_scn_s *msg)\n{\n\tint i;\n\tuint8_t subtesttype;\n\n\tbfa_trc(dport->bfa, msg->state);\n\tdport->i2hmsg.scn.state = msg->state;\n\n\tswitch (dport->i2hmsg.scn.state) {\n\tcase BFI_DPORT_SCN_TESTCOMP:\n\t\tdport->result.end_time = ktime_get_real_seconds();\n\t\tbfa_trc(dport->bfa, dport->result.end_time);\n\n\t\tdport->result.status = msg->info.testcomp.status;\n\t\tbfa_trc(dport->bfa, dport->result.status);\n\n\t\tdport->result.roundtrip_latency =\n\t\t\tcpu_to_be32(msg->info.testcomp.latency);\n\t\tdport->result.est_cable_distance =\n\t\t\tcpu_to_be32(msg->info.testcomp.distance);\n\t\tdport->result.buffer_required =\n\t\t\tbe16_to_cpu(msg->info.testcomp.numbuffer);\n\n\t\tdport->result.frmsz = be16_to_cpu(msg->info.testcomp.frm_sz);\n\t\tdport->result.speed = msg->info.testcomp.speed;\n\n\t\tbfa_trc(dport->bfa, dport->result.roundtrip_latency);\n\t\tbfa_trc(dport->bfa, dport->result.est_cable_distance);\n\t\tbfa_trc(dport->bfa, dport->result.buffer_required);\n\t\tbfa_trc(dport->bfa, dport->result.frmsz);\n\t\tbfa_trc(dport->bfa, dport->result.speed);\n\n\t\tfor (i = DPORT_TEST_ELOOP; i < DPORT_TEST_MAX; i++) {\n\t\t\tdport->result.subtest[i].status =\n\t\t\t\tmsg->info.testcomp.subtest_status[i];\n\t\t\tbfa_trc(dport->bfa, dport->result.subtest[i].status);\n\t\t}\n\t\tbreak;\n\n\tcase BFI_DPORT_SCN_TESTSKIP:\n\tcase BFI_DPORT_SCN_DDPORT_ENABLE:\n\t\tmemset(&dport->result, 0,\n\t\t\t\tsizeof(struct bfa_diag_dport_result_s));\n\t\tbreak;\n\n\tcase BFI_DPORT_SCN_TESTSTART:\n\t\tmemset(&dport->result, 0,\n\t\t\t\tsizeof(struct bfa_diag_dport_result_s));\n\t\tdport->rp_pwwn = msg->info.teststart.pwwn;\n\t\tdport->rp_nwwn = msg->info.teststart.nwwn;\n\t\tdport->lpcnt = cpu_to_be32(msg->info.teststart.numfrm);\n\t\tbfa_dport_result_start(dport, msg->info.teststart.mode);\n\t\tbreak;\n\n\tcase BFI_DPORT_SCN_SUBTESTSTART:\n\t\tsubtesttype = msg->info.teststart.type;\n\t\tdport->result.subtest[subtesttype].start_time =\n\t\t\tktime_get_real_seconds();\n\t\tdport->result.subtest[subtesttype].status =\n\t\t\tDPORT_TEST_ST_INPRG;\n\n\t\tbfa_trc(dport->bfa, subtesttype);\n\t\tbfa_trc(dport->bfa,\n\t\t\tdport->result.subtest[subtesttype].start_time);\n\t\tbreak;\n\n\tcase BFI_DPORT_SCN_SFP_REMOVED:\n\tcase BFI_DPORT_SCN_DDPORT_DISABLED:\n\tcase BFI_DPORT_SCN_DDPORT_DISABLE:\n\tcase BFI_DPORT_SCN_FCPORT_DISABLE:\n\t\tdport->result.status = DPORT_TEST_ST_IDLE;\n\t\tbreak;\n\n\tdefault:\n\t\tbfa_sm_fault(dport->bfa, msg->state);\n\t}\n\n\tbfa_sm_send_event(dport, BFA_DPORT_SM_SCN);\n}\n\n \nbfa_status_t\nbfa_dport_enable(struct bfa_s *bfa, u32 lpcnt, u32 pat,\n\t\t\t\tbfa_cb_diag_t cbfn, void *cbarg)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\tstruct bfa_dport_s  *dport = &fcdiag->dport;\n\n\t \n\tif (bfa_mfg_is_mezz(dport->bfa->ioc.attr->card_type)) {\n\t\tbfa_trc(dport->bfa, BFA_STATUS_PBC);\n\t\treturn BFA_STATUS_CMD_NOTSUPP_MEZZ;\n\t}\n\n\t \n\tif (!(bfa_asic_id_ct2(dport->bfa->ioc.pcidev.device_id))) {\n\t\tbfa_trc(dport->bfa, dport->bfa->ioc.pcidev.device_id);\n\t\treturn BFA_STATUS_FEATURE_NOT_SUPPORTED;\n\t}\n\n\t \n\tif (!bfa_iocfc_is_operational(bfa))\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\t \n\tif (bfa_fcport_is_pbcdisabled(bfa)) {\n\t\tbfa_trc(dport->bfa, BFA_STATUS_PBC);\n\t\treturn BFA_STATUS_PBC;\n\t}\n\n\t \n\tif (bfa_ioc_get_type(&bfa->ioc) != BFA_IOC_TYPE_FC) {\n\t\tbfa_trc(dport->bfa, bfa_ioc_get_type(&bfa->ioc));\n\t\treturn BFA_STATUS_CMD_NOTSUPP_CNA;\n\t}\n\n\t \n\tif ((bfa_fcport_get_cfg_topology(bfa) == BFA_PORT_TOPOLOGY_LOOP) ||\n\t    (bfa_fcport_get_topology(bfa) == BFA_PORT_TOPOLOGY_LOOP)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_TOPOLOGY_LOOP;\n\t}\n\n\t \n\tif (bfa_fcport_is_trunk_enabled(bfa)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_ERROR_TRUNK_ENABLED;\n\t}\n\n\t \n\tif (bfa_fcdiag_lb_is_running(bfa)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_DIAG_BUSY;\n\t}\n\n\t \n\tif ((bfa_fcport_is_disabled(bfa) == BFA_FALSE) &&\n\t    (bfa_fcport_is_dport(bfa) == BFA_FALSE)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_PORT_NOT_DISABLED;\n\t}\n\n\t \n\tif (dport->dynamic)\n\t\treturn BFA_STATUS_DDPORT_ERR;\n\n\t \n\tif (bfa_dport_is_sending_req(dport))\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\t \n\tif (bfa_sm_cmp_state(dport, bfa_dport_sm_enabled)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_DPORT_ENABLED;\n\t}\n\n\tbfa_trc(dport->bfa, lpcnt);\n\tbfa_trc(dport->bfa, pat);\n\tdport->lpcnt = (lpcnt) ? lpcnt : DPORT_ENABLE_LOOPCNT_DEFAULT;\n\tdport->payload = (pat) ? pat : LB_PATTERN_DEFAULT;\n\tdport->cbfn = cbfn;\n\tdport->cbarg = cbarg;\n\n\tbfa_sm_send_event(dport, BFA_DPORT_SM_ENABLE);\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_dport_disable(struct bfa_s *bfa, bfa_cb_diag_t cbfn, void *cbarg)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\tstruct bfa_dport_s *dport = &fcdiag->dport;\n\n\tif (bfa_ioc_is_disabled(&bfa->ioc))\n\t\treturn BFA_STATUS_IOC_DISABLED;\n\n\t \n\tif (bfa_fcport_is_pbcdisabled(bfa)) {\n\t\tbfa_trc(dport->bfa, BFA_STATUS_PBC);\n\t\treturn BFA_STATUS_PBC;\n\t}\n\n\t \n\tif (dport->dynamic) {\n\t\treturn BFA_STATUS_DDPORT_ERR;\n\t}\n\n\t \n\tif ((bfa_fcport_is_disabled(bfa) == BFA_FALSE) &&\n\t    (bfa_fcport_is_dport(bfa) == BFA_FALSE)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_PORT_NOT_DISABLED;\n\t}\n\n\t \n\tif (bfa_dport_is_sending_req(dport))\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\t \n\tif (bfa_sm_cmp_state(dport, bfa_dport_sm_disabled)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_DPORT_DISABLED;\n\t}\n\n\tdport->cbfn = cbfn;\n\tdport->cbarg = cbarg;\n\n\tbfa_sm_send_event(dport, BFA_DPORT_SM_DISABLE);\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_dport_start(struct bfa_s *bfa, u32 lpcnt, u32 pat,\n\t\t\tbfa_cb_diag_t cbfn, void *cbarg)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\tstruct bfa_dport_s *dport = &fcdiag->dport;\n\n\t \n\tif (!bfa_iocfc_is_operational(bfa))\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\t \n\tif (dport->dynamic)\n\t\treturn BFA_STATUS_DDPORT_ERR;\n\n\t \n\tif (bfa_dport_is_sending_req(dport))\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\t \n\tif (!bfa_sm_cmp_state(dport, bfa_dport_sm_enabled)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_DPORT_DISABLED;\n\n\t} else {\n\t\tif (dport->test_state == BFA_DPORT_ST_NO_SFP)\n\t\t\treturn BFA_STATUS_DPORT_INV_SFP;\n\n\t\tif (dport->test_state == BFA_DPORT_ST_INP)\n\t\t\treturn BFA_STATUS_DEVBUSY;\n\n\t\tWARN_ON(dport->test_state != BFA_DPORT_ST_COMP);\n\t}\n\n\tbfa_trc(dport->bfa, lpcnt);\n\tbfa_trc(dport->bfa, pat);\n\n\tdport->lpcnt = (lpcnt) ? lpcnt : DPORT_ENABLE_LOOPCNT_DEFAULT;\n\tdport->payload = (pat) ? pat : LB_PATTERN_DEFAULT;\n\n\tdport->cbfn = cbfn;\n\tdport->cbarg = cbarg;\n\n\tbfa_sm_send_event(dport, BFA_DPORT_SM_START);\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_dport_show(struct bfa_s *bfa, struct bfa_diag_dport_result_s *result)\n{\n\tstruct bfa_fcdiag_s *fcdiag = BFA_FCDIAG_MOD(bfa);\n\tstruct bfa_dport_s *dport = &fcdiag->dport;\n\n\t \n\tif (!bfa_iocfc_is_operational(bfa))\n\t\treturn BFA_STATUS_IOC_NON_OP;\n\n\t \n\tif (bfa_dport_is_sending_req(dport))\n\t\treturn BFA_STATUS_DEVBUSY;\n\n\t \n\tif (!bfa_sm_cmp_state(dport, bfa_dport_sm_enabled)) {\n\t\tbfa_trc(dport->bfa, 0);\n\t\treturn BFA_STATUS_DPORT_DISABLED;\n\n\t}\n\n\t \n\tif (dport->test_state == BFA_DPORT_ST_NO_SFP)\n\t\treturn BFA_STATUS_DPORT_INV_SFP;\n\n\tmemcpy(result, &dport->result, sizeof(struct bfa_diag_dport_result_s));\n\n\treturn BFA_STATUS_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}