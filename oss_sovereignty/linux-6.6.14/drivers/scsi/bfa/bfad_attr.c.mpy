{
  "module_name": "bfad_attr.c",
  "hash_id": "4e41f5394efdea6287ca5453ecea1f22e3417c21b70ab5e41ac5b8013699126e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfad_attr.c",
  "human_readable_source": "\n \n\n \n\n#include \"bfad_drv.h\"\n#include \"bfad_im.h\"\n\n \nstatic void\nbfad_im_get_starget_port_id(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu32        fc_id = -1;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tfc_id = bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim);\n\n\tfc_starget_port_id(starget) = fc_id;\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n \nstatic void\nbfad_im_get_starget_node_name(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu64             node_name = 0;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tnode_name = bfa_fcs_itnim_get_nwwn(&itnim->fcs_itnim);\n\n\tfc_starget_node_name(starget) = cpu_to_be64(node_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n \nstatic void\nbfad_im_get_starget_port_name(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bfad_im_port_s *im_port;\n\tstruct bfad_s         *bfad;\n\tstruct bfad_itnim_s   *itnim = NULL;\n\tu64             port_name = 0;\n\tunsigned long   flags;\n\n\tshost = dev_to_shost(starget->dev.parent);\n\tim_port = (struct bfad_im_port_s *) shost->hostdata[0];\n\tbfad = im_port->bfad;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim)\n\t\tport_name = bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim);\n\n\tfc_starget_port_name(starget) = cpu_to_be64(port_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n \nstatic void\nbfad_im_get_host_port_id(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\n\tfc_host_port_id(shost) =\n\t\t\tbfa_hton3b(bfa_fcs_lport_get_fcid(port->fcs_port));\n}\n\n \nstatic void\nbfad_im_get_host_port_type(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_lport_attr_s port_attr;\n\n\tbfa_fcs_lport_get_attr(&bfad->bfa_fcs.fabric.bport, &port_attr);\n\n\tswitch (port_attr.port_type) {\n\tcase BFA_PORT_TYPE_NPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_NLPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_P2P:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_PTP;\n\t\tbreak;\n\tcase BFA_PORT_TYPE_LPORT:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_LPORT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nbfad_im_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_port_attr_s attr;\n\n\tbfa_fcport_get_attr(&bfad->bfa, &attr);\n\n\tswitch (attr.port_state) {\n\tcase BFA_PORT_ST_LINKDOWN:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\t\tbreak;\n\tcase BFA_PORT_ST_LINKUP:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\t\tbreak;\n\tcase BFA_PORT_ST_DISABLED:\n\tcase BFA_PORT_ST_STOPPED:\n\tcase BFA_PORT_ST_IOCDOWN:\n\tcase BFA_PORT_ST_IOCDIS:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n\t\tbreak;\n\tcase BFA_PORT_ST_UNINIT:\n\tcase BFA_PORT_ST_ENABLING_QWAIT:\n\tcase BFA_PORT_ST_ENABLING:\n\tcase BFA_PORT_ST_DISABLING_QWAIT:\n\tcase BFA_PORT_ST_DISABLING:\n\tdefault:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nbfad_im_get_host_active_fc4s(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\n\tmemset(fc_host_active_fc4s(shost), 0,\n\t       sizeof(fc_host_active_fc4s(shost)));\n\n\tif (port->supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\n\t\tfc_host_active_fc4s(shost)[2] = 1;\n\n\tfc_host_active_fc4s(shost)[7] = 1;\n}\n\n \nstatic void\nbfad_im_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_port_attr_s attr;\n\n\tbfa_fcport_get_attr(&bfad->bfa, &attr);\n\tswitch (attr.speed) {\n\tcase BFA_PORT_SPEED_10GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_16GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_8GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_4GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_2GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\n\t\tbreak;\n\tcase BFA_PORT_SPEED_1GBPS:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\n \nstatic void\nbfad_im_get_host_fabric_name(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\twwn_t           fabric_nwwn = 0;\n\n\tfabric_nwwn = bfa_fcs_lport_get_fabric_name(port->fcs_port);\n\n\tfc_host_fabric_name(shost) = cpu_to_be64(fabric_nwwn);\n\n}\n\n \nstatic struct fc_host_statistics *\nbfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK) {\n\t\tkfree(fcstats);\n\t\treturn NULL;\n\t}\n\n\twait_for_completion(&fcomp.comp);\n\n\t \n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\n\tkfree(fcstats);\n\treturn hstats;\n}\n\n \nstatic void\nbfad_im_reset_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunsigned long   flags;\n\tbfa_status_t    rc;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\trc = bfa_port_clear_stats(BFA_FCPORT(&bfad->bfa), bfad_hcb_comp,\n\t\t\t\t\t&fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (rc != BFA_STATUS_OK)\n\t\treturn;\n\n\twait_for_completion(&fcomp.comp);\n\n\treturn;\n}\n\n \nstatic void\nbfad_im_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout)\n{\n\tstruct bfad_itnim_data_s *itnim_data = rport->dd_data;\n\tstruct bfad_itnim_s   *itnim = itnim_data->itnim;\n\tstruct bfad_s         *bfad = itnim->im->bfad;\n\tuint16_t path_tov = bfa_fcpim_path_tov_get(&bfad->bfa);\n\n\trport->dev_loss_tmo = timeout;\n\tif (timeout < path_tov)\n\t\trport->dev_loss_tmo = path_tov + 1;\n}\n\nstatic int\nbfad_im_vport_create(struct fc_vport *fc_vport, bool disable)\n{\n\tchar *vname = fc_vport->symbolic_name;\n\tstruct Scsi_Host *shost = fc_vport->shost;\n\tstruct bfad_im_port_s *im_port =\n\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_lport_cfg_s port_cfg;\n\tstruct bfad_vport_s *vp;\n\tint status = 0, rc;\n\tunsigned long flags;\n\n\tmemset(&port_cfg, 0, sizeof(port_cfg));\n\tu64_to_wwn(fc_vport->node_name, (u8 *)&port_cfg.nwwn);\n\tu64_to_wwn(fc_vport->port_name, (u8 *)&port_cfg.pwwn);\n\tif (strlen(vname) > 0)\n\t\tstrcpy((char *)&port_cfg.sym_name, vname);\n\tport_cfg.roles = BFA_LPORT_ROLE_FCP_IM;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tlist_for_each_entry(vp, &bfad->pbc_vport_list, list_entry) {\n\t\tif (port_cfg.pwwn ==\n\t\t\t\tvp->fcs_vport.lport.port_cfg.pwwn) {\n\t\t\tport_cfg.preboot_vp =\n\t\t\t\tvp->fcs_vport.lport.port_cfg.preboot_vp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\trc = bfad_vport_create(bfad, 0, &port_cfg, &fc_vport->dev);\n\tif (rc == BFA_STATUS_OK) {\n\t\tstruct bfad_vport_s *vport;\n\t\tstruct bfa_fcs_vport_s *fcs_vport;\n\t\tstruct Scsi_Host *vshost;\n\n\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0,\n\t\t\t\t\tport_cfg.pwwn);\n\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\tif (fcs_vport == NULL)\n\t\t\treturn VPCERR_BAD_WWN;\n\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\n\t\tif (disable) {\n\t\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\t\tbfa_fcs_vport_stop(fcs_vport);\n\t\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\t\tfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\n\t\t}\n\n\t\tvport = fcs_vport->vport_drv;\n\t\tvshost = vport->drv_port.im_port->shost;\n\t\tfc_host_node_name(vshost) = wwn_to_u64((u8 *)&port_cfg.nwwn);\n\t\tfc_host_port_name(vshost) = wwn_to_u64((u8 *)&port_cfg.pwwn);\n\t\tfc_host_supported_classes(vshost) = FC_COS_CLASS3;\n\n\t\tmemset(fc_host_supported_fc4s(vshost), 0,\n\t\t\tsizeof(fc_host_supported_fc4s(vshost)));\n\n\t\t \n\t\tif (supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\n\t\t\tfc_host_supported_fc4s(vshost)[2] = 1;\n\n\t\t \n\t\tfc_host_supported_fc4s(vshost)[7] = 1;\n\n\t\tfc_host_supported_speeds(vshost) =\n\t\t\t\tbfad_im_supported_speeds(&bfad->bfa);\n\t\tfc_host_maxframe_size(vshost) =\n\t\t\t\tbfa_fcport_get_maxfrsize(&bfad->bfa);\n\n\t\tfc_vport->dd_data = vport;\n\t\tvport->drv_port.im_port->fc_vport = fc_vport;\n\t} else if (rc == BFA_STATUS_INVALID_WWN)\n\t\treturn VPCERR_BAD_WWN;\n\telse if (rc == BFA_STATUS_VPORT_EXISTS)\n\t\treturn VPCERR_BAD_WWN;\n\telse if (rc == BFA_STATUS_VPORT_MAX)\n\t\treturn VPCERR_NO_FABRIC_SUPP;\n\telse if (rc == BFA_STATUS_VPORT_WWN_BP)\n\t\treturn VPCERR_BAD_WWN;\n\telse\n\t\treturn FC_VPORT_FAILED;\n\n\treturn status;\n}\n\nstatic int\nbfad_im_issue_fc_host_lip(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunsigned long flags;\n\tuint32_t status;\n\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tstatus = bfa_port_disable(&bfad->bfa.modules.port,\n\t\t\t\t\tbfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\twait_for_completion(&fcomp.comp);\n\tif (fcomp.status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tstatus = bfa_port_enable(&bfad->bfa.modules.port,\n\t\t\t\t\tbfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\twait_for_completion(&fcomp.comp);\n\tif (fcomp.status != BFA_STATUS_OK)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int\nbfad_im_vport_delete(struct fc_vport *fc_vport)\n{\n\tstruct bfad_vport_s *vport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) vport->drv_port.im_port;\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\tstruct Scsi_Host *vshost;\n\twwn_t   pwwn;\n\tint rc;\n\tunsigned long flags;\n\tstruct completion fcomp;\n\n\tif (im_port->flags & BFAD_PORT_DELETE) {\n\t\tbfad_scsi_host_free(bfad, im_port);\n\t\tlist_del(&vport->list_entry);\n\t\tkfree(vport);\n\t\treturn 0;\n\t}\n\n\tvshost = vport->drv_port.im_port->shost;\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn VPCERR_BAD_WWN;\n\n\tvport->drv_port.flags |= BFAD_PORT_DELETE;\n\n\tvport->comp_del = &fcomp;\n\tinit_completion(vport->comp_del);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\trc = bfa_fcs_vport_delete(&vport->fcs_vport);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (rc == BFA_STATUS_PBC) {\n\t\tvport->drv_port.flags &= ~BFAD_PORT_DELETE;\n\t\tvport->comp_del = NULL;\n\t\treturn -1;\n\t}\n\n\twait_for_completion(vport->comp_del);\n\n\tbfad_scsi_host_free(bfad, im_port);\n\tlist_del(&vport->list_entry);\n\tkfree(vport);\n\n\treturn 0;\n}\n\nstatic int\nbfad_im_vport_disable(struct fc_vport *fc_vport, bool disable)\n{\n\tstruct bfad_vport_s *vport;\n\tstruct bfad_s *bfad;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\tstruct Scsi_Host *vshost;\n\twwn_t   pwwn;\n\tunsigned long flags;\n\n\tvport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tbfad = vport->drv_port.bfad;\n\tvshost = vport->drv_port.im_port->shost;\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn VPCERR_BAD_WWN;\n\n\tif (disable) {\n\t\tbfa_fcs_vport_stop(fcs_vport);\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\n\t} else {\n\t\tbfa_fcs_vport_start(fcs_vport);\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_ACTIVE);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nbfad_im_vport_set_symbolic_name(struct fc_vport *fc_vport)\n{\n\tstruct bfad_vport_s *vport = (struct bfad_vport_s *)fc_vport->dd_data;\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *)vport->drv_port.im_port;\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct Scsi_Host *vshost = vport->drv_port.im_port->shost;\n\tchar *sym_name = fc_vport->symbolic_name;\n\tstruct bfa_fcs_vport_s *fcs_vport;\n\twwn_t\tpwwn;\n\tunsigned long flags;\n\n\tu64_to_wwn(fc_host_port_name(vshost), (u8 *)&pwwn);\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfcs_vport = bfa_fcs_vport_lookup(&bfad->bfa_fcs, 0, pwwn);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\tif (fcs_vport == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tif (strlen(sym_name) > 0)\n\t\tbfa_fcs_lport_set_symname(&fcs_vport->lport, sym_name);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\nstruct fc_function_template bfad_im_fc_function_template = {\n\n\t \n\t.get_starget_port_id = bfad_im_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\t.get_starget_node_name = bfad_im_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\t.get_starget_port_name = bfad_im_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t \n\t.get_host_port_id = bfad_im_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t \n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t \n\t.show_host_port_type = 1,\n\t.get_host_port_type = bfad_im_get_host_port_type,\n\t.show_host_port_state = 1,\n\t.get_host_port_state = bfad_im_get_host_port_state,\n\t.show_host_active_fc4s = 1,\n\t.get_host_active_fc4s = bfad_im_get_host_active_fc4s,\n\t.show_host_speed = 1,\n\t.get_host_speed = bfad_im_get_host_speed,\n\t.show_host_fabric_name = 1,\n\t.get_host_fabric_name = bfad_im_get_host_fabric_name,\n\n\t.show_host_symbolic_name = 1,\n\n\t \n\t.get_fc_host_stats = bfad_im_get_stats,\n\t.reset_fc_host_stats = bfad_im_reset_stats,\n\n\t \n\t.dd_fcrport_size = sizeof(struct bfad_itnim_data_s *),\n\n\t \n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\t.set_rport_dev_loss_tmo = bfad_im_set_rport_loss_tmo,\n\t.issue_fc_host_lip = bfad_im_issue_fc_host_lip,\n\t.vport_create = bfad_im_vport_create,\n\t.vport_delete = bfad_im_vport_delete,\n\t.vport_disable = bfad_im_vport_disable,\n\t.set_vport_symbolic_name = bfad_im_vport_set_symbolic_name,\n\t.bsg_request = bfad_im_bsg_request,\n\t.bsg_timeout = bfad_im_bsg_timeout,\n};\n\nstruct fc_function_template bfad_im_vport_fc_function_template = {\n\n\t \n\t.get_starget_port_id = bfad_im_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\t.get_starget_node_name = bfad_im_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\t.get_starget_port_name = bfad_im_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t \n\t.get_host_port_id = bfad_im_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t \n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t \n\t.show_host_port_type = 1,\n\t.get_host_port_type = bfad_im_get_host_port_type,\n\t.show_host_port_state = 1,\n\t.get_host_port_state = bfad_im_get_host_port_state,\n\t.show_host_active_fc4s = 1,\n\t.get_host_active_fc4s = bfad_im_get_host_active_fc4s,\n\t.show_host_speed = 1,\n\t.get_host_speed = bfad_im_get_host_speed,\n\t.show_host_fabric_name = 1,\n\t.get_host_fabric_name = bfad_im_get_host_fabric_name,\n\n\t.show_host_symbolic_name = 1,\n\n\t \n\t.get_fc_host_stats = bfad_im_get_stats,\n\t.reset_fc_host_stats = bfad_im_reset_stats,\n\n\t \n\t.dd_fcrport_size = sizeof(struct bfad_itnim_data_s *),\n\n\t \n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\t.set_rport_dev_loss_tmo = bfad_im_set_rport_loss_tmo,\n};\n\n \nstatic ssize_t\nbfad_im_serial_num_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar serial_num[BFA_ADAPTER_SERIAL_NUM_LEN];\n\n\tbfa_get_adapter_serial_num(&bfad->bfa, serial_num);\n\treturn sysfs_emit(buf, \"%s\\n\", serial_num);\n}\n\nstatic ssize_t\nbfad_im_model_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar model[BFA_ADAPTER_MODEL_NAME_LEN];\n\n\tbfa_get_adapter_model(&bfad->bfa, model);\n\treturn sysfs_emit(buf, \"%s\\n\", model);\n}\n\nstatic ssize_t\nbfad_im_model_desc_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar model[BFA_ADAPTER_MODEL_NAME_LEN];\n\tchar model_descr[BFA_ADAPTER_MODEL_DESCR_LEN];\n\tint nports = 0;\n\n\tbfa_get_adapter_model(&bfad->bfa, model);\n\tnports = bfa_get_nports(&bfad->bfa);\n\tif (!strcmp(model, \"QLogic-425\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe dual port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-825\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe dual port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-42B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe dual port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-82B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe dual port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-1010\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps single port CNA\");\n\telse if (!strcmp(model, \"QLogic-1020\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps dual port CNA\");\n\telse if (!strcmp(model, \"QLogic-1007\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps CNA for IBM Blade Center\");\n\telse if (!strcmp(model, \"QLogic-415\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe single port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-815\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe single port FC HBA\");\n\telse if (!strcmp(model, \"QLogic-41B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 4Gbps PCIe single port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-81B\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps PCIe single port FC HBA for HP\");\n\telse if (!strcmp(model, \"QLogic-804\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 8Gbps FC HBA for HP Bladesystem C-class\");\n\telse if (!strcmp(model, \"QLogic-1741\"))\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"QLogic BR-series 10Gbps CNA for Dell M-Series Blade Servers\");\n\telse if (strstr(model, \"QLogic-1860\")) {\n\t\tif (nports == 1 && bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 10Gbps single port CNA\");\n\t\telse if (nports == 1 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe single port FC HBA\");\n\t\telse if (nports == 2 && bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 10Gbps dual port CNA\");\n\t\telse if (nports == 2 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe dual port FC HBA\");\n\t} else if (!strcmp(model, \"QLogic-1867\")) {\n\t\tif (nports == 1 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe single port FC HBA for IBM\");\n\t\telse if (nports == 2 && !bfa_ioc_is_cna(&bfad->bfa.ioc))\n\t\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\t\"QLogic BR-series 16Gbps PCIe dual port FC HBA for IBM\");\n\t} else\n\t\tsnprintf(model_descr, BFA_ADAPTER_MODEL_DESCR_LEN,\n\t\t\t\"Invalid Model\");\n\n\treturn sysfs_emit(buf, \"%s\\n\", model_descr);\n}\n\nstatic ssize_t\nbfad_im_node_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\tu64        nwwn;\n\n\tnwwn = bfa_fcs_lport_get_nwwn(port->fcs_port);\n\treturn sysfs_emit(buf, \"0x%llx\\n\", cpu_to_be64(nwwn));\n}\n\nstatic ssize_t\nbfad_im_symbolic_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tstruct bfa_lport_attr_s port_attr;\n\tchar symname[BFA_SYMNAME_MAXLEN];\n\n\tbfa_fcs_lport_get_attr(&bfad->bfa_fcs.fabric.bport, &port_attr);\n\tstrscpy(symname, port_attr.port_cfg.sym_name.symname,\n\t\t\tBFA_SYMNAME_MAXLEN);\n\treturn sysfs_emit(buf, \"%s\\n\", symname);\n}\n\nstatic ssize_t\nbfad_im_hw_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar hw_ver[BFA_VERSION_LEN];\n\n\tbfa_get_pci_chip_rev(&bfad->bfa, hw_ver);\n\treturn sysfs_emit(buf, \"%s\\n\", hw_ver);\n}\n\nstatic ssize_t\nbfad_im_drv_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", BFAD_DRIVER_VERSION);\n}\n\nstatic ssize_t\nbfad_im_optionrom_version_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar optrom_ver[BFA_VERSION_LEN];\n\n\tbfa_get_adapter_optrom_ver(&bfad->bfa, optrom_ver);\n\treturn sysfs_emit(buf, \"%s\\n\", optrom_ver);\n}\n\nstatic ssize_t\nbfad_im_fw_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\tchar fw_ver[BFA_VERSION_LEN];\n\n\tbfa_get_adapter_fw_ver(&bfad->bfa, fw_ver);\n\treturn sysfs_emit(buf, \"%s\\n\", fw_ver);\n}\n\nstatic ssize_t\nbfad_im_num_of_ports_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\tbfa_get_nports(&bfad->bfa));\n}\n\nstatic ssize_t\nbfad_im_drv_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", BFAD_DRIVER_NAME);\n}\n\nstatic ssize_t\nbfad_im_num_of_discovered_ports_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_port_s    *port = im_port->port;\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tint        nrports = 2048;\n\tstruct bfa_rport_qualifier_s *rports = NULL;\n\tunsigned long   flags;\n\n\trports = kcalloc(nrports, sizeof(struct bfa_rport_qualifier_s),\n\t\t\t GFP_ATOMIC);\n\tif (rports == NULL)\n\t\treturn sysfs_emit(buf, \"Failed\\n\");\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tbfa_fcs_lport_get_rport_quals(port->fcs_port, rports, &nrports);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tkfree(rports);\n\n\treturn sysfs_emit(buf, \"%d\\n\", nrports);\n}\n\nstatic          DEVICE_ATTR(serial_number, S_IRUGO,\n\t\t\t\tbfad_im_serial_num_show, NULL);\nstatic          DEVICE_ATTR(model, S_IRUGO, bfad_im_model_show, NULL);\nstatic          DEVICE_ATTR(model_description, S_IRUGO,\n\t\t\t\tbfad_im_model_desc_show, NULL);\nstatic          DEVICE_ATTR(node_name, S_IRUGO, bfad_im_node_name_show, NULL);\nstatic          DEVICE_ATTR(symbolic_name, S_IRUGO,\n\t\t\t\tbfad_im_symbolic_name_show, NULL);\nstatic          DEVICE_ATTR(hardware_version, S_IRUGO,\n\t\t\t\tbfad_im_hw_version_show, NULL);\nstatic          DEVICE_ATTR(driver_version, S_IRUGO,\n\t\t\t\tbfad_im_drv_version_show, NULL);\nstatic          DEVICE_ATTR(option_rom_version, S_IRUGO,\n\t\t\t\tbfad_im_optionrom_version_show, NULL);\nstatic          DEVICE_ATTR(firmware_version, S_IRUGO,\n\t\t\t\tbfad_im_fw_version_show, NULL);\nstatic          DEVICE_ATTR(number_of_ports, S_IRUGO,\n\t\t\t\tbfad_im_num_of_ports_show, NULL);\nstatic          DEVICE_ATTR(driver_name, S_IRUGO, bfad_im_drv_name_show, NULL);\nstatic          DEVICE_ATTR(number_of_discovered_ports, S_IRUGO,\n\t\t\t\tbfad_im_num_of_discovered_ports_show, NULL);\n\nstatic struct attribute *bfad_im_host_attrs[] = {\n\t&dev_attr_serial_number.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_model_description.attr,\n\t&dev_attr_node_name.attr,\n\t&dev_attr_symbolic_name.attr,\n\t&dev_attr_hardware_version.attr,\n\t&dev_attr_driver_version.attr,\n\t&dev_attr_option_rom_version.attr,\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_number_of_ports.attr,\n\t&dev_attr_driver_name.attr,\n\t&dev_attr_number_of_discovered_ports.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bfad_im_host_attr_group = {\n\t.attrs = bfad_im_host_attrs\n};\n\nconst struct attribute_group *bfad_im_host_groups[] = {\n\t&bfad_im_host_attr_group,\n\tNULL\n};\n\nstatic struct attribute *bfad_im_vport_attrs[] = {\n\t&dev_attr_serial_number.attr,\n\t&dev_attr_model.attr,\n\t&dev_attr_model_description.attr,\n\t&dev_attr_node_name.attr,\n\t&dev_attr_symbolic_name.attr,\n\t&dev_attr_hardware_version.attr,\n\t&dev_attr_driver_version.attr,\n\t&dev_attr_option_rom_version.attr,\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_number_of_ports.attr,\n\t&dev_attr_driver_name.attr,\n\t&dev_attr_number_of_discovered_ports.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group bfad_im_vport_attr_group = {\n\t.attrs = bfad_im_vport_attrs\n};\n\nconst struct attribute_group *bfad_im_vport_groups[] = {\n\t&bfad_im_vport_attr_group,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}