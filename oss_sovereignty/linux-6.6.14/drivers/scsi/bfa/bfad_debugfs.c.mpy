{
  "module_name": "bfad_debugfs.c",
  "hash_id": "67626e1225b99210d54c8442b21c2e576e8a11fcb2b7eb7a79ca21f13a95ddba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfad_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/export.h>\n\n#include \"bfad_drv.h\"\n#include \"bfad_im.h\"\n\n \n\nstruct bfad_debug_info {\n\tchar *debug_buffer;\n\tvoid *i_private;\n\tint buffer_len;\n};\n\nstatic int\nbfad_debugfs_open_drvtrc(struct inode *inode, struct file *file)\n{\n\tstruct bfad_port_s *port = inode->i_private;\n\tstruct bfad_s *bfad = port->bfad;\n\tstruct bfad_debug_info *debug;\n\n\tdebug = kzalloc(sizeof(struct bfad_debug_info), GFP_KERNEL);\n\tif (!debug)\n\t\treturn -ENOMEM;\n\n\tdebug->debug_buffer = (void *) bfad->trcmod;\n\tdebug->buffer_len = sizeof(struct bfa_trc_mod_s);\n\n\tfile->private_data = debug;\n\n\treturn 0;\n}\n\nstatic int\nbfad_debugfs_open_fwtrc(struct inode *inode, struct file *file)\n{\n\tstruct bfad_port_s *port = inode->i_private;\n\tstruct bfad_s *bfad = port->bfad;\n\tstruct bfad_debug_info *fw_debug;\n\tunsigned long flags;\n\tint rc;\n\n\tfw_debug = kzalloc(sizeof(struct bfad_debug_info), GFP_KERNEL);\n\tif (!fw_debug)\n\t\treturn -ENOMEM;\n\n\tfw_debug->buffer_len = sizeof(struct bfa_trc_mod_s);\n\n\tfw_debug->debug_buffer = vzalloc(fw_debug->buffer_len);\n\tif (!fw_debug->debug_buffer) {\n\t\tkfree(fw_debug);\n\t\tprintk(KERN_INFO \"bfad[%d]: Failed to allocate fwtrc buffer\\n\",\n\t\t\t\tbfad->inst_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\trc = bfa_ioc_debug_fwtrc(&bfad->bfa.ioc,\n\t\t\tfw_debug->debug_buffer,\n\t\t\t&fw_debug->buffer_len);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK) {\n\t\tvfree(fw_debug->debug_buffer);\n\t\tfw_debug->debug_buffer = NULL;\n\t\tkfree(fw_debug);\n\t\tprintk(KERN_INFO \"bfad[%d]: Failed to collect fwtrc\\n\",\n\t\t\t\tbfad->inst_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tfile->private_data = fw_debug;\n\n\treturn 0;\n}\n\nstatic int\nbfad_debugfs_open_fwsave(struct inode *inode, struct file *file)\n{\n\tstruct bfad_port_s *port = inode->i_private;\n\tstruct bfad_s *bfad = port->bfad;\n\tstruct bfad_debug_info *fw_debug;\n\tunsigned long flags;\n\tint rc;\n\n\tfw_debug = kzalloc(sizeof(struct bfad_debug_info), GFP_KERNEL);\n\tif (!fw_debug)\n\t\treturn -ENOMEM;\n\n\tfw_debug->buffer_len = sizeof(struct bfa_trc_mod_s);\n\n\tfw_debug->debug_buffer = vzalloc(fw_debug->buffer_len);\n\tif (!fw_debug->debug_buffer) {\n\t\tkfree(fw_debug);\n\t\tprintk(KERN_INFO \"bfad[%d]: Failed to allocate fwsave buffer\\n\",\n\t\t\t\tbfad->inst_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\trc = bfa_ioc_debug_fwsave(&bfad->bfa.ioc,\n\t\t\tfw_debug->debug_buffer,\n\t\t\t&fw_debug->buffer_len);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK) {\n\t\tvfree(fw_debug->debug_buffer);\n\t\tfw_debug->debug_buffer = NULL;\n\t\tkfree(fw_debug);\n\t\tprintk(KERN_INFO \"bfad[%d]: Failed to collect fwsave\\n\",\n\t\t\t\tbfad->inst_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tfile->private_data = fw_debug;\n\n\treturn 0;\n}\n\nstatic int\nbfad_debugfs_open_reg(struct inode *inode, struct file *file)\n{\n\tstruct bfad_debug_info *reg_debug;\n\n\treg_debug = kzalloc(sizeof(struct bfad_debug_info), GFP_KERNEL);\n\tif (!reg_debug)\n\t\treturn -ENOMEM;\n\n\treg_debug->i_private = inode->i_private;\n\n\tfile->private_data = reg_debug;\n\n\treturn 0;\n}\n\n \nstatic loff_t\nbfad_debugfs_lseek(struct file *file, loff_t offset, int orig)\n{\n\tstruct bfad_debug_info *debug = file->private_data;\n\treturn fixed_size_llseek(file, offset, orig,\n\t\t\t\tdebug->buffer_len);\n}\n\nstatic ssize_t\nbfad_debugfs_read(struct file *file, char __user *buf,\n\t\t\tsize_t nbytes, loff_t *pos)\n{\n\tstruct bfad_debug_info *debug = file->private_data;\n\n\tif (!debug || !debug->debug_buffer)\n\t\treturn 0;\n\n\treturn simple_read_from_buffer(buf, nbytes, pos,\n\t\t\t\tdebug->debug_buffer, debug->buffer_len);\n}\n\n#define BFA_REG_CT_ADDRSZ\t(0x40000)\n#define BFA_REG_CB_ADDRSZ\t(0x20000)\n#define BFA_REG_ADDRSZ(__ioc)\t\\\n\t((u32)(bfa_asic_id_ctc(bfa_ioc_devid(__ioc)) ?\t\\\n\t BFA_REG_CT_ADDRSZ : BFA_REG_CB_ADDRSZ))\n#define BFA_REG_ADDRMSK(__ioc)\t(BFA_REG_ADDRSZ(__ioc) - 1)\n\nstatic bfa_status_t\nbfad_reg_offset_check(struct bfa_s *bfa, u32 offset, u32 len)\n{\n\tu8\tarea;\n\n\t \n\tarea = (offset >> 15) & 0x7;\n\tif (area == 0) {\n\t\t \n\t\tif ((offset + (len<<2)) > 0x8000)     \n\t\t\treturn BFA_STATUS_EINVAL;\n\t} else if (area == 0x1) {\n\t\t \n\t\tif ((offset + (len<<2)) > 0x10000)     \n\t\t\treturn BFA_STATUS_EINVAL;\n\t} else {\n\t\t \n\t\tif ((offset + (len<<2)) > BFA_REG_ADDRMSK(&bfa->ioc))\n\t\t\treturn BFA_STATUS_EINVAL;\n\t}\n\treturn BFA_STATUS_OK;\n}\n\nstatic ssize_t\nbfad_debugfs_read_regrd(struct file *file, char __user *buf,\n\t\tsize_t nbytes, loff_t *pos)\n{\n\tstruct bfad_debug_info *regrd_debug = file->private_data;\n\tstruct bfad_port_s *port = (struct bfad_port_s *)regrd_debug->i_private;\n\tstruct bfad_s *bfad = port->bfad;\n\tssize_t rc;\n\n\tif (!bfad->regdata)\n\t\treturn 0;\n\n\trc = simple_read_from_buffer(buf, nbytes, pos,\n\t\t\tbfad->regdata, bfad->reglen);\n\n\tif ((*pos + nbytes) >= bfad->reglen) {\n\t\tkfree(bfad->regdata);\n\t\tbfad->regdata = NULL;\n\t\tbfad->reglen = 0;\n\t}\n\n\treturn rc;\n}\n\nstatic ssize_t\nbfad_debugfs_write_regrd(struct file *file, const char __user *buf,\n\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct bfad_debug_info *regrd_debug = file->private_data;\n\tstruct bfad_port_s *port = (struct bfad_port_s *)regrd_debug->i_private;\n\tstruct bfad_s *bfad = port->bfad;\n\tstruct bfa_s *bfa = &bfad->bfa;\n\tstruct bfa_ioc_s *ioc = &bfa->ioc;\n\tint addr, rc, i;\n\tu32 len;\n\tu32 *regbuf;\n\tvoid __iomem *rb, *reg_addr;\n\tunsigned long flags;\n\tvoid *kern_buf;\n\n\tkern_buf = memdup_user(buf, nbytes);\n\tif (IS_ERR(kern_buf))\n\t\treturn PTR_ERR(kern_buf);\n\n\trc = sscanf(kern_buf, \"%x:%x\", &addr, &len);\n\tif (rc < 2 || len > (UINT_MAX >> 2)) {\n\t\tprintk(KERN_INFO\n\t\t\t\"bfad[%d]: %s failed to read user buf\\n\",\n\t\t\tbfad->inst_no, __func__);\n\t\tkfree(kern_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tkfree(kern_buf);\n\tkfree(bfad->regdata);\n\tbfad->regdata = NULL;\n\tbfad->reglen = 0;\n\n\tbfad->regdata = kzalloc(len << 2, GFP_KERNEL);\n\tif (!bfad->regdata) {\n\t\tprintk(KERN_INFO \"bfad[%d]: Failed to allocate regrd buffer\\n\",\n\t\t\t\tbfad->inst_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tbfad->reglen = len << 2;\n\trb = bfa_ioc_bar0(ioc);\n\taddr &= BFA_REG_ADDRMSK(ioc);\n\n\t \n\trc = bfad_reg_offset_check(bfa, addr, len);\n\tif (rc) {\n\t\tprintk(KERN_INFO \"bfad[%d]: Failed reg offset check\\n\",\n\t\t\t\tbfad->inst_no);\n\t\tkfree(bfad->regdata);\n\t\tbfad->regdata = NULL;\n\t\tbfad->reglen = 0;\n\t\treturn -EINVAL;\n\t}\n\n\treg_addr = rb + addr;\n\tregbuf =  (u32 *)bfad->regdata;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tfor (i = 0; i < len; i++) {\n\t\t*regbuf = readl(reg_addr);\n\t\tregbuf++;\n\t\treg_addr += sizeof(u32);\n\t}\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\treturn nbytes;\n}\n\nstatic ssize_t\nbfad_debugfs_write_regwr(struct file *file, const char __user *buf,\n\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct bfad_debug_info *debug = file->private_data;\n\tstruct bfad_port_s *port = (struct bfad_port_s *)debug->i_private;\n\tstruct bfad_s *bfad = port->bfad;\n\tstruct bfa_s *bfa = &bfad->bfa;\n\tstruct bfa_ioc_s *ioc = &bfa->ioc;\n\tint addr, val, rc;\n\tvoid __iomem *reg_addr;\n\tunsigned long flags;\n\tvoid *kern_buf;\n\n\tkern_buf = memdup_user(buf, nbytes);\n\tif (IS_ERR(kern_buf))\n\t\treturn PTR_ERR(kern_buf);\n\n\trc = sscanf(kern_buf, \"%x:%x\", &addr, &val);\n\tif (rc < 2) {\n\t\tprintk(KERN_INFO\n\t\t\t\"bfad[%d]: %s failed to read user buf\\n\",\n\t\t\tbfad->inst_no, __func__);\n\t\tkfree(kern_buf);\n\t\treturn -EINVAL;\n\t}\n\tkfree(kern_buf);\n\n\taddr &= BFA_REG_ADDRMSK(ioc);  \n\n\t \n\trc = bfad_reg_offset_check(bfa, addr, 1);\n\tif (rc) {\n\t\tprintk(KERN_INFO\n\t\t\t\"bfad[%d]: Failed reg offset check\\n\",\n\t\t\tbfad->inst_no);\n\t\treturn -EINVAL;\n\t}\n\n\treg_addr = (bfa_ioc_bar0(ioc)) + addr;\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\twritel(val, reg_addr);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\treturn nbytes;\n}\n\nstatic int\nbfad_debugfs_release(struct inode *inode, struct file *file)\n{\n\tstruct bfad_debug_info *debug = file->private_data;\n\n\tif (!debug)\n\t\treturn 0;\n\n\tfile->private_data = NULL;\n\tkfree(debug);\n\treturn 0;\n}\n\nstatic int\nbfad_debugfs_release_fwtrc(struct inode *inode, struct file *file)\n{\n\tstruct bfad_debug_info *fw_debug = file->private_data;\n\n\tif (!fw_debug)\n\t\treturn 0;\n\n\tvfree(fw_debug->debug_buffer);\n\n\tfile->private_data = NULL;\n\tkfree(fw_debug);\n\treturn 0;\n}\n\nstatic const struct file_operations bfad_debugfs_op_drvtrc = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbfad_debugfs_open_drvtrc,\n\t.llseek\t\t=\tbfad_debugfs_lseek,\n\t.read\t\t=\tbfad_debugfs_read,\n\t.release\t=\tbfad_debugfs_release,\n};\n\nstatic const struct file_operations bfad_debugfs_op_fwtrc = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbfad_debugfs_open_fwtrc,\n\t.llseek\t\t=\tbfad_debugfs_lseek,\n\t.read\t\t=\tbfad_debugfs_read,\n\t.release\t=\tbfad_debugfs_release_fwtrc,\n};\n\nstatic const struct file_operations bfad_debugfs_op_fwsave = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbfad_debugfs_open_fwsave,\n\t.llseek\t\t=\tbfad_debugfs_lseek,\n\t.read\t\t=\tbfad_debugfs_read,\n\t.release\t=\tbfad_debugfs_release_fwtrc,\n};\n\nstatic const struct file_operations bfad_debugfs_op_regrd = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbfad_debugfs_open_reg,\n\t.llseek\t\t=\tbfad_debugfs_lseek,\n\t.read\t\t=\tbfad_debugfs_read_regrd,\n\t.write\t\t=\tbfad_debugfs_write_regrd,\n\t.release\t=\tbfad_debugfs_release,\n};\n\nstatic const struct file_operations bfad_debugfs_op_regwr = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tbfad_debugfs_open_reg,\n\t.llseek\t\t=\tbfad_debugfs_lseek,\n\t.write\t\t=\tbfad_debugfs_write_regwr,\n\t.release\t=\tbfad_debugfs_release,\n};\n\nstruct bfad_debugfs_entry {\n\tconst char *name;\n\tumode_t\tmode;\n\tconst struct file_operations *fops;\n};\n\nstatic const struct bfad_debugfs_entry bfad_debugfs_files[] = {\n\t{ \"drvtrc\", S_IFREG|S_IRUGO, &bfad_debugfs_op_drvtrc, },\n\t{ \"fwtrc\",  S_IFREG|S_IRUGO, &bfad_debugfs_op_fwtrc,  },\n\t{ \"fwsave\", S_IFREG|S_IRUGO, &bfad_debugfs_op_fwsave, },\n\t{ \"regrd\",  S_IFREG|S_IRUGO|S_IWUSR, &bfad_debugfs_op_regrd,  },\n\t{ \"regwr\",  S_IFREG|S_IWUSR, &bfad_debugfs_op_regwr,  },\n};\n\nstatic struct dentry *bfa_debugfs_root;\nstatic atomic_t bfa_debugfs_port_count;\n\ninline void\nbfad_debugfs_init(struct bfad_port_s *port)\n{\n\tstruct bfad_s *bfad = port->bfad;\n\tconst struct bfad_debugfs_entry *file;\n\tchar name[64];\n\tint i;\n\n\tif (!bfa_debugfs_enable)\n\t\treturn;\n\n\t \n\tif (!bfa_debugfs_root) {\n\t\tbfa_debugfs_root = debugfs_create_dir(\"bfa\", NULL);\n\t\tatomic_set(&bfa_debugfs_port_count, 0);\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"pci_dev:%s\", bfad->pci_name);\n\tif (!port->port_debugfs_root) {\n\t\tport->port_debugfs_root =\n\t\t\tdebugfs_create_dir(name, bfa_debugfs_root);\n\n\t\tatomic_inc(&bfa_debugfs_port_count);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(bfad_debugfs_files); i++) {\n\t\t\tfile = &bfad_debugfs_files[i];\n\t\t\tbfad->bfad_dentry_files[i] =\n\t\t\t\t\tdebugfs_create_file(file->name,\n\t\t\t\t\t\t\tfile->mode,\n\t\t\t\t\t\t\tport->port_debugfs_root,\n\t\t\t\t\t\t\tport,\n\t\t\t\t\t\t\tfile->fops);\n\t\t}\n\t}\n\n\treturn;\n}\n\ninline void\nbfad_debugfs_exit(struct bfad_port_s *port)\n{\n\tstruct bfad_s *bfad = port->bfad;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bfad_debugfs_files); i++) {\n\t\tif (bfad->bfad_dentry_files[i]) {\n\t\t\tdebugfs_remove(bfad->bfad_dentry_files[i]);\n\t\t\tbfad->bfad_dentry_files[i] = NULL;\n\t\t}\n\t}\n\n\t \n\tif (port->port_debugfs_root) {\n\t\tdebugfs_remove(port->port_debugfs_root);\n\t\tport->port_debugfs_root = NULL;\n\t\tatomic_dec(&bfa_debugfs_port_count);\n\t}\n\n\t \n\tif (atomic_read(&bfa_debugfs_port_count) == 0) {\n\t\tdebugfs_remove(bfa_debugfs_root);\n\t\tbfa_debugfs_root = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}