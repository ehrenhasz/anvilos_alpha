{
  "module_name": "bfad_im.c",
  "hash_id": "317069c8c9dd7409fed8c8b97bad914c4173c46e3a9170e7bc19c9c833396b41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfad_im.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/export.h>\n\n#include \"bfad_drv.h\"\n#include \"bfad_im.h\"\n#include \"bfa_fcs.h\"\n\nBFA_TRC_FILE(LDRV, IM);\n\nDEFINE_IDR(bfad_im_port_index);\nstruct scsi_transport_template *bfad_im_scsi_transport_template;\nstruct scsi_transport_template *bfad_im_scsi_vport_transport_template;\nstatic void bfad_im_itnim_work_handler(struct work_struct *work);\nstatic int bfad_im_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *cmnd);\nstatic int bfad_im_slave_alloc(struct scsi_device *sdev);\nstatic void bfad_im_fc_rport_add(struct bfad_im_port_s  *im_port,\n\t\t\t\tstruct bfad_itnim_s *itnim);\n\nvoid\nbfa_cb_ioim_done(void *drv, struct bfad_ioim_s *dio,\n\t\t\tenum bfi_ioim_status io_status, u8 scsi_status,\n\t\t\tint sns_len, u8 *sns_info, s32 residue)\n{\n\tstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;\n\tstruct bfad_s         *bfad = drv;\n\tstruct bfad_itnim_data_s *itnim_data;\n\tstruct bfad_itnim_s *itnim;\n\tu8         host_status = DID_OK;\n\n\tswitch (io_status) {\n\tcase BFI_IOIM_STS_OK:\n\t\tbfa_trc(bfad, scsi_status);\n\t\tscsi_set_resid(cmnd, 0);\n\n\t\tif (sns_len > 0) {\n\t\t\tbfa_trc(bfad, sns_len);\n\t\t\tif (sns_len > SCSI_SENSE_BUFFERSIZE)\n\t\t\t\tsns_len = SCSI_SENSE_BUFFERSIZE;\n\t\t\tmemcpy(cmnd->sense_buffer, sns_info, sns_len);\n\t\t}\n\n\t\tif (residue > 0) {\n\t\t\tbfa_trc(bfad, residue);\n\t\t\tscsi_set_resid(cmnd, residue);\n\t\t\tif (!sns_len && (scsi_status == SAM_STAT_GOOD) &&\n\t\t\t\t(scsi_bufflen(cmnd) - residue) <\n\t\t\t\t\tcmnd->underflow) {\n\t\t\t\tbfa_trc(bfad, 0);\n\t\t\t\thost_status = DID_ERROR;\n\t\t\t}\n\t\t}\n\t\tcmnd->result = host_status << 16 | scsi_status;\n\n\t\tbreak;\n\n\tcase BFI_IOIM_STS_TIMEDOUT:\n\t\tcmnd->result = DID_TIME_OUT << 16;\n\t\tbreak;\n\tcase BFI_IOIM_STS_PATHTOV:\n\t\tcmnd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\tbreak;\n\tdefault:\n\t\tcmnd->result = DID_ERROR << 16;\n\t}\n\n\t \n\tif (cmnd->device->host != NULL)\n\t\tscsi_dma_unmap(cmnd);\n\n\tcmnd->host_scribble = NULL;\n\tbfa_trc(bfad, cmnd->result);\n\n\titnim_data = cmnd->device->hostdata;\n\tif (itnim_data) {\n\t\titnim = itnim_data->itnim;\n\t\tif (!cmnd->result && itnim &&\n\t\t\t (bfa_lun_queue_depth > cmnd->device->queue_depth)) {\n\t\t\t \n\t\t\tbfad_ramp_up_qdepth(itnim, cmnd->device);\n\t\t} else if (cmnd->result == SAM_STAT_TASK_SET_FULL && itnim) {\n\t\t\t \n\t\t\tbfad_handle_qfull(itnim, cmnd->device);\n\t\t}\n\t}\n\n\tscsi_done(cmnd);\n}\n\nvoid\nbfa_cb_ioim_good_comp(void *drv, struct bfad_ioim_s *dio)\n{\n\tstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;\n\tstruct bfad_itnim_data_s *itnim_data;\n\tstruct bfad_itnim_s *itnim;\n\n\tcmnd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\n\t \n\tif (cmnd->device->host != NULL)\n\t\tscsi_dma_unmap(cmnd);\n\n\tcmnd->host_scribble = NULL;\n\n\t \n\tif (bfa_lun_queue_depth > cmnd->device->queue_depth) {\n\t\titnim_data = cmnd->device->hostdata;\n\t\tif (itnim_data) {\n\t\t\titnim = itnim_data->itnim;\n\t\t\tif (itnim)\n\t\t\t\tbfad_ramp_up_qdepth(itnim, cmnd->device);\n\t\t}\n\t}\n\n\tscsi_done(cmnd);\n}\n\nvoid\nbfa_cb_ioim_abort(void *drv, struct bfad_ioim_s *dio)\n{\n\tstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;\n\tstruct bfad_s         *bfad = drv;\n\n\tcmnd->result = DID_ERROR << 16;\n\n\t \n\tif (cmnd->device->host != NULL)\n\t\tscsi_dma_unmap(cmnd);\n\n\tbfa_trc(bfad, cmnd->result);\n\tcmnd->host_scribble = NULL;\n}\n\nvoid\nbfa_cb_tskim_done(void *bfad, struct bfad_tskim_s *dtsk,\n\t\t   enum bfi_tskim_status tsk_status)\n{\n\tstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)dtsk;\n\twait_queue_head_t *wq;\n\n\tbfad_priv(cmnd)->status |= tsk_status << 1;\n\tset_bit(IO_DONE_BIT, &bfad_priv(cmnd)->status);\n\twq = bfad_priv(cmnd)->wq;\n\tbfad_priv(cmnd)->wq = NULL;\n\n\tif (wq)\n\t\twake_up(wq);\n}\n\n \n \nstatic const char *\nbfad_im_info(struct Scsi_Host *shost)\n{\n\tstatic char     bfa_buf[256];\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s *bfad = im_port->bfad;\n\n\tmemset(bfa_buf, 0, sizeof(bfa_buf));\n\tsnprintf(bfa_buf, sizeof(bfa_buf),\n\t\t\"QLogic BR-series FC/FCOE Adapter, hwpath: %s driver: %s\",\n\t\tbfad->pci_name, BFAD_DRIVER_VERSION);\n\n\treturn bfa_buf;\n}\n\n \nstatic int\nbfad_im_abort_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host *shost = cmnd->device->host;\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_ioim_s *hal_io;\n\tunsigned long   flags;\n\tu32        timeout;\n\tint             rc = FAILED;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\thal_io = (struct bfa_ioim_s *) cmnd->host_scribble;\n\tif (!hal_io) {\n\t\t \n\t\trc = SUCCESS;\n\t\tgoto out;\n\t}\n\tif (hal_io->dio != (struct bfad_ioim_s *) cmnd) {\n\t\trc = FAILED;\n\t\tgoto out;\n\t}\n\n\tbfa_trc(bfad, hal_io->iotag);\n\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\"scsi%d: abort cmnd %p iotag %x\\n\",\n\t\tim_port->shost->host_no, cmnd, hal_io->iotag);\n\t(void) bfa_ioim_abort(hal_io);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\t \n\ttimeout = 10;\n\twhile ((struct bfa_ioim_s *) cmnd->host_scribble == hal_io) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(timeout);\n\t\tif (timeout < 4 * HZ)\n\t\t\ttimeout *= 2;\n\t}\n\n\tscsi_done(cmnd);\n\tbfa_trc(bfad, hal_io->iotag);\n\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\"scsi%d: complete abort 0x%p iotag 0x%x\\n\",\n\t\tim_port->shost->host_no, cmnd, hal_io->iotag);\n\treturn SUCCESS;\nout:\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\treturn rc;\n}\n\nstatic bfa_status_t\nbfad_im_target_reset_send(struct bfad_s *bfad, struct scsi_cmnd *cmnd,\n\t\t     struct bfad_itnim_s *itnim)\n{\n\tstruct bfa_tskim_s *tskim;\n\tstruct bfa_itnim_s *bfa_itnim;\n\tbfa_status_t    rc = BFA_STATUS_OK;\n\tstruct scsi_lun scsilun;\n\n\ttskim = bfa_tskim_alloc(&bfad->bfa, (struct bfad_tskim_s *) cmnd);\n\tif (!tskim) {\n\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\"target reset, fail to allocate tskim\\n\");\n\t\trc = BFA_STATUS_FAILED;\n\t\tgoto out;\n\t}\n\n\t \n\tcmnd->host_scribble = NULL;\n\tbfad_priv(cmnd)->status = 0;\n\tbfa_itnim = bfa_fcs_itnim_get_halitn(&itnim->fcs_itnim);\n\t \n\tif (bfa_itnim == NULL) {\n\t\tbfa_tskim_free(tskim);\n\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\"target reset, bfa_itnim is NULL\\n\");\n\t\trc = BFA_STATUS_FAILED;\n\t\tgoto out;\n\t}\n\n\tmemset(&scsilun, 0, sizeof(scsilun));\n\tbfa_tskim_start(tskim, bfa_itnim, scsilun,\n\t\t\t    FCP_TM_TARGET_RESET, BFAD_TARGET_RESET_TMO);\nout:\n\treturn rc;\n}\n\n \nstatic int\nbfad_im_reset_lun_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host *shost = cmnd->device->host;\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_itnim_data_s *itnim_data = cmnd->device->hostdata;\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfa_tskim_s *tskim;\n\tstruct bfad_itnim_s   *itnim;\n\tstruct bfa_itnim_s *bfa_itnim;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\tint             rc = SUCCESS;\n\tunsigned long   flags;\n\tenum bfi_tskim_status task_status;\n\tstruct scsi_lun scsilun;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\titnim = itnim_data->itnim;\n\tif (!itnim) {\n\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\trc = FAILED;\n\t\tgoto out;\n\t}\n\n\ttskim = bfa_tskim_alloc(&bfad->bfa, (struct bfad_tskim_s *) cmnd);\n\tif (!tskim) {\n\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\t\"LUN reset, fail to allocate tskim\");\n\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\trc = FAILED;\n\t\tgoto out;\n\t}\n\n\t \n\tcmnd->host_scribble = NULL;\n\tbfad_priv(cmnd)->wq = &wq;\n\tbfad_priv(cmnd)->status = 0;\n\tbfa_itnim = bfa_fcs_itnim_get_halitn(&itnim->fcs_itnim);\n\t \n\tif (bfa_itnim == NULL) {\n\t\tbfa_tskim_free(tskim);\n\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\"lun reset, bfa_itnim is NULL\\n\");\n\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\trc = FAILED;\n\t\tgoto out;\n\t}\n\tint_to_scsilun(cmnd->device->lun, &scsilun);\n\tbfa_tskim_start(tskim, bfa_itnim, scsilun,\n\t\t\t    FCP_TM_LUN_RESET, BFAD_LUN_RESET_TMO);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\twait_event(wq, test_bit(IO_DONE_BIT, &bfad_priv(cmnd)->status));\n\n\ttask_status = bfad_priv(cmnd)->status >> 1;\n\tif (task_status != BFI_TSKIM_STS_OK) {\n\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\"LUN reset failure, status: %d\\n\", task_status);\n\t\trc = FAILED;\n\t}\n\nout:\n\treturn rc;\n}\n\n \nstatic int\nbfad_im_reset_target_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host *shost = cmnd->device->host;\n\tstruct scsi_target *starget = scsi_target(cmnd->device);\n\tstruct bfad_im_port_s *im_port =\n\t\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_itnim_s   *itnim;\n\tunsigned long   flags;\n\tu32        rc, rtn = FAILED;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\tenum bfi_tskim_status task_status;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\titnim = bfad_get_itnim(im_port, starget->id);\n\tif (itnim) {\n\t\tbfad_priv(cmnd)->wq = &wq;\n\t\trc = bfad_im_target_reset_send(bfad, cmnd, itnim);\n\t\tif (rc == BFA_STATUS_OK) {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\t\twait_event(wq, test_bit(IO_DONE_BIT,\n\t\t\t\t\t\t&bfad_priv(cmnd)->status));\n\t\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\n\t\t\ttask_status = bfad_priv(cmnd)->status >> 1;\n\t\t\tif (task_status != BFI_TSKIM_STS_OK)\n\t\t\t\tBFA_LOG(KERN_ERR, bfad, bfa_log_level,\n\t\t\t\t\t\"target reset failure,\"\n\t\t\t\t\t\" status: %d\\n\", task_status);\n\t\t\telse\n\t\t\t\trtn = SUCCESS;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\treturn rtn;\n}\n\n \nstatic void\nbfad_im_slave_destroy(struct scsi_device *sdev)\n{\n\tsdev->hostdata = NULL;\n\treturn;\n}\n\n \n\n \nint\nbfa_fcb_itnim_alloc(struct bfad_s *bfad, struct bfa_fcs_itnim_s **itnim,\n\t\t    struct bfad_itnim_s **itnim_drv)\n{\n\t*itnim_drv = kzalloc(sizeof(struct bfad_itnim_s), GFP_ATOMIC);\n\tif (*itnim_drv == NULL)\n\t\treturn -ENOMEM;\n\n\t(*itnim_drv)->im = bfad->im;\n\t*itnim = &(*itnim_drv)->fcs_itnim;\n\t(*itnim_drv)->state = ITNIM_STATE_NONE;\n\n\t \n\tINIT_WORK(&(*itnim_drv)->itnim_work, bfad_im_itnim_work_handler);\n\tbfad->bfad_flags |= BFAD_RPORT_ONLINE;\n\treturn 0;\n}\n\n \nvoid\nbfa_fcb_itnim_free(struct bfad_s *bfad, struct bfad_itnim_s *itnim_drv)\n{\n\tstruct bfad_port_s    *port;\n\twwn_t wwpn;\n\tu32 fcid;\n\tchar wwpn_str[32], fcid_str[16];\n\tstruct bfad_im_s\t*im = itnim_drv->im;\n\n\t \n\tWARN_ON(itnim_drv->state == ITNIM_STATE_ONLINE);\n\n\titnim_drv->queue_work = 1;\n\t \n\tif (itnim_drv->state == ITNIM_STATE_OFFLINE_PENDING)\n\t\titnim_drv->queue_work = 0;\n\n\titnim_drv->state = ITNIM_STATE_FREE;\n\tport = bfa_fcs_itnim_get_drvport(&itnim_drv->fcs_itnim);\n\titnim_drv->im_port = port->im_port;\n\twwpn = bfa_fcs_itnim_get_pwwn(&itnim_drv->fcs_itnim);\n\tfcid = bfa_fcs_itnim_get_fcid(&itnim_drv->fcs_itnim);\n\twwn2str(wwpn_str, wwpn);\n\tfcid2str(fcid_str, fcid);\n\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\"ITNIM FREE scsi%d: FCID: %s WWPN: %s\\n\",\n\t\tport->im_port->shost->host_no,\n\t\tfcid_str, wwpn_str);\n\n\t \n\tif (itnim_drv->queue_work)\n\t\tqueue_work(im->drv_workq, &itnim_drv->itnim_work);\n}\n\n \nvoid\nbfa_fcb_itnim_online(struct bfad_itnim_s *itnim_drv)\n{\n\tstruct bfad_port_s    *port;\n\tstruct bfad_im_s\t*im = itnim_drv->im;\n\n\titnim_drv->bfa_itnim = bfa_fcs_itnim_get_halitn(&itnim_drv->fcs_itnim);\n\tport = bfa_fcs_itnim_get_drvport(&itnim_drv->fcs_itnim);\n\titnim_drv->state = ITNIM_STATE_ONLINE;\n\titnim_drv->queue_work = 1;\n\titnim_drv->im_port = port->im_port;\n\n\t \n\tif (itnim_drv->queue_work)\n\t\tqueue_work(im->drv_workq, &itnim_drv->itnim_work);\n}\n\n \nvoid\nbfa_fcb_itnim_offline(struct bfad_itnim_s *itnim_drv)\n{\n\tstruct bfad_port_s    *port;\n\tstruct bfad_s *bfad;\n\tstruct bfad_im_s\t*im = itnim_drv->im;\n\n\tport = bfa_fcs_itnim_get_drvport(&itnim_drv->fcs_itnim);\n\tbfad = port->bfad;\n\tif ((bfad->pport.flags & BFAD_PORT_DELETE) ||\n\t\t (port->flags & BFAD_PORT_DELETE)) {\n\t\titnim_drv->state = ITNIM_STATE_OFFLINE;\n\t\treturn;\n\t}\n\titnim_drv->im_port = port->im_port;\n\titnim_drv->state = ITNIM_STATE_OFFLINE_PENDING;\n\titnim_drv->queue_work = 1;\n\n\t \n\tif (itnim_drv->queue_work)\n\t\tqueue_work(im->drv_workq, &itnim_drv->itnim_work);\n}\n\n \nint\nbfad_im_scsi_host_alloc(struct bfad_s *bfad, struct bfad_im_port_s *im_port,\n\t\t\tstruct device *dev)\n{\n\tstruct bfad_im_port_pointer *im_portp;\n\tint error;\n\n\tmutex_lock(&bfad_mutex);\n\terror = idr_alloc(&bfad_im_port_index, im_port, 0, 0, GFP_KERNEL);\n\tif (error < 0) {\n\t\tmutex_unlock(&bfad_mutex);\n\t\tprintk(KERN_WARNING \"idr_alloc failure\\n\");\n\t\tgoto out;\n\t}\n\tim_port->idr_id = error;\n\tmutex_unlock(&bfad_mutex);\n\n\tim_port->shost = bfad_scsi_host_alloc(im_port, bfad);\n\tif (!im_port->shost) {\n\t\terror = 1;\n\t\tgoto out_free_idr;\n\t}\n\n\tim_portp = shost_priv(im_port->shost);\n\tim_portp->p = im_port;\n\tim_port->shost->unique_id = im_port->idr_id;\n\tim_port->shost->this_id = -1;\n\tim_port->shost->max_id = MAX_FCP_TARGET;\n\tim_port->shost->max_lun = MAX_FCP_LUN;\n\tim_port->shost->max_cmd_len = 16;\n\tim_port->shost->can_queue = bfad->cfg_data.ioc_queue_depth;\n\tif (im_port->port->pvb_type == BFAD_PORT_PHYS_BASE)\n\t\tim_port->shost->transportt = bfad_im_scsi_transport_template;\n\telse\n\t\tim_port->shost->transportt =\n\t\t\t\tbfad_im_scsi_vport_transport_template;\n\n\terror = scsi_add_host_with_dma(im_port->shost, dev, &bfad->pcidev->dev);\n\tif (error) {\n\t\tprintk(KERN_WARNING \"scsi_add_host failure %d\\n\", error);\n\t\tgoto out_fc_rel;\n\t}\n\n\treturn 0;\n\nout_fc_rel:\n\tscsi_host_put(im_port->shost);\n\tim_port->shost = NULL;\nout_free_idr:\n\tmutex_lock(&bfad_mutex);\n\tidr_remove(&bfad_im_port_index, im_port->idr_id);\n\tmutex_unlock(&bfad_mutex);\nout:\n\treturn error;\n}\n\nvoid\nbfad_im_scsi_host_free(struct bfad_s *bfad, struct bfad_im_port_s *im_port)\n{\n\tbfa_trc(bfad, bfad->inst_no);\n\tBFA_LOG(KERN_INFO, bfad, bfa_log_level, \"Free scsi%d\\n\",\n\t\t\tim_port->shost->host_no);\n\n\tfc_remove_host(im_port->shost);\n\n\tscsi_remove_host(im_port->shost);\n\tscsi_host_put(im_port->shost);\n\n\tmutex_lock(&bfad_mutex);\n\tidr_remove(&bfad_im_port_index, im_port->idr_id);\n\tmutex_unlock(&bfad_mutex);\n}\n\nstatic void\nbfad_im_port_delete_handler(struct work_struct *work)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\tcontainer_of(work, struct bfad_im_port_s, port_delete_work);\n\n\tif (im_port->port->pvb_type != BFAD_PORT_PHYS_BASE) {\n\t\tim_port->flags |= BFAD_PORT_DELETE;\n\t\tfc_vport_terminate(im_port->fc_vport);\n\t}\n}\n\nbfa_status_t\nbfad_im_port_new(struct bfad_s *bfad, struct bfad_port_s *port)\n{\n\tint             rc = BFA_STATUS_OK;\n\tstruct bfad_im_port_s *im_port;\n\n\tim_port = kzalloc(sizeof(struct bfad_im_port_s), GFP_ATOMIC);\n\tif (im_port == NULL) {\n\t\trc = BFA_STATUS_ENOMEM;\n\t\tgoto ext;\n\t}\n\tport->im_port = im_port;\n\tim_port->port = port;\n\tim_port->bfad = bfad;\n\n\tINIT_WORK(&im_port->port_delete_work, bfad_im_port_delete_handler);\n\tINIT_LIST_HEAD(&im_port->itnim_mapped_list);\n\tINIT_LIST_HEAD(&im_port->binding_list);\n\next:\n\treturn rc;\n}\n\nvoid\nbfad_im_port_delete(struct bfad_s *bfad, struct bfad_port_s *port)\n{\n\tstruct bfad_im_port_s *im_port = port->im_port;\n\n\tqueue_work(bfad->im->drv_workq,\n\t\t\t\t&im_port->port_delete_work);\n}\n\nvoid\nbfad_im_port_clean(struct bfad_im_port_s *im_port)\n{\n\tstruct bfad_fcp_binding *bp, *bp_new;\n\tunsigned long flags;\n\tstruct bfad_s *bfad =  im_port->bfad;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tlist_for_each_entry_safe(bp, bp_new, &im_port->binding_list,\n\t\t\t\t\tlist_entry) {\n\t\tlist_del(&bp->list_entry);\n\t\tkfree(bp);\n\t}\n\n\t \n\tWARN_ON(!list_empty(&im_port->itnim_mapped_list));\n\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\nstatic void bfad_aen_im_notify_handler(struct work_struct *work)\n{\n\tstruct bfad_im_s *im =\n\t\tcontainer_of(work, struct bfad_im_s, aen_im_notify_work);\n\tstruct bfa_aen_entry_s *aen_entry;\n\tstruct bfad_s *bfad = im->bfad;\n\tstruct Scsi_Host *shost = bfad->pport.im_port->shost;\n\tvoid *event_data;\n\tunsigned long flags;\n\n\twhile (!list_empty(&bfad->active_aen_q)) {\n\t\tspin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);\n\t\tbfa_q_deq(&bfad->active_aen_q, &aen_entry);\n\t\tspin_unlock_irqrestore(&bfad->bfad_aen_spinlock, flags);\n\t\tevent_data = (char *)aen_entry + sizeof(struct list_head);\n\t\tfc_host_post_vendor_event(shost, fc_get_event_number(),\n\t\t\t\tsizeof(struct bfa_aen_entry_s) -\n\t\t\t\tsizeof(struct list_head),\n\t\t\t\t(char *)event_data, BFAD_NL_VENDOR_ID);\n\t\tspin_lock_irqsave(&bfad->bfad_aen_spinlock, flags);\n\t\tlist_add_tail(&aen_entry->qe, &bfad->free_aen_q);\n\t\tspin_unlock_irqrestore(&bfad->bfad_aen_spinlock, flags);\n\t}\n}\n\nbfa_status_t\nbfad_im_probe(struct bfad_s *bfad)\n{\n\tstruct bfad_im_s      *im;\n\n\tim = kzalloc(sizeof(struct bfad_im_s), GFP_KERNEL);\n\tif (im == NULL)\n\t\treturn BFA_STATUS_ENOMEM;\n\n\tbfad->im = im;\n\tim->bfad = bfad;\n\n\tif (bfad_thread_workq(bfad) != BFA_STATUS_OK) {\n\t\tkfree(im);\n\t\treturn BFA_STATUS_FAILED;\n\t}\n\n\tINIT_WORK(&im->aen_im_notify_work, bfad_aen_im_notify_handler);\n\treturn BFA_STATUS_OK;\n}\n\nvoid\nbfad_im_probe_undo(struct bfad_s *bfad)\n{\n\tif (bfad->im) {\n\t\tbfad_destroy_workq(bfad->im);\n\t\tkfree(bfad->im);\n\t\tbfad->im = NULL;\n\t}\n}\n\nstruct Scsi_Host *\nbfad_scsi_host_alloc(struct bfad_im_port_s *im_port, struct bfad_s *bfad)\n{\n\tstruct scsi_host_template *sht;\n\n\tif (im_port->port->pvb_type == BFAD_PORT_PHYS_BASE)\n\t\tsht = &bfad_im_scsi_host_template;\n\telse\n\t\tsht = &bfad_im_vport_template;\n\n\tif (max_xfer_size != BFAD_MAX_SECTORS >> 1)\n\t\tsht->max_sectors = max_xfer_size << 1;\n\n\tsht->sg_tablesize = bfad->cfg_data.io_max_sge;\n\n\treturn scsi_host_alloc(sht, sizeof(struct bfad_im_port_pointer));\n}\n\nvoid\nbfad_scsi_host_free(struct bfad_s *bfad, struct bfad_im_port_s *im_port)\n{\n\tif (!(im_port->flags & BFAD_PORT_DELETE))\n\t\tflush_workqueue(bfad->im->drv_workq);\n\tbfad_im_scsi_host_free(im_port->bfad, im_port);\n\tbfad_im_port_clean(im_port);\n\tkfree(im_port);\n}\n\nvoid\nbfad_destroy_workq(struct bfad_im_s *im)\n{\n\tif (im && im->drv_workq) {\n\t\tdestroy_workqueue(im->drv_workq);\n\t\tim->drv_workq = NULL;\n\t}\n}\n\nbfa_status_t\nbfad_thread_workq(struct bfad_s *bfad)\n{\n\tstruct bfad_im_s      *im = bfad->im;\n\n\tbfa_trc(bfad, 0);\n\tsnprintf(im->drv_workq_name, KOBJ_NAME_LEN, \"bfad_wq_%d\",\n\t\t bfad->inst_no);\n\tim->drv_workq = create_singlethread_workqueue(im->drv_workq_name);\n\tif (!im->drv_workq)\n\t\treturn BFA_STATUS_FAILED;\n\n\treturn BFA_STATUS_OK;\n}\n\n \nstatic int\nbfad_im_slave_configure(struct scsi_device *sdev)\n{\n\tscsi_change_queue_depth(sdev, bfa_lun_queue_depth);\n\treturn 0;\n}\n\nstruct scsi_host_template bfad_im_scsi_host_template = {\n\t.module = THIS_MODULE,\n\t.name = BFAD_DRIVER_NAME,\n\t.info = bfad_im_info,\n\t.queuecommand = bfad_im_queuecommand,\n\t.cmd_size = sizeof(struct bfad_cmd_priv),\n\t.eh_timed_out = fc_eh_timed_out,\n\t.eh_abort_handler = bfad_im_abort_handler,\n\t.eh_device_reset_handler = bfad_im_reset_lun_handler,\n\t.eh_target_reset_handler = bfad_im_reset_target_handler,\n\n\t.slave_alloc = bfad_im_slave_alloc,\n\t.slave_configure = bfad_im_slave_configure,\n\t.slave_destroy = bfad_im_slave_destroy,\n\n\t.this_id = -1,\n\t.sg_tablesize = BFAD_IO_MAX_SGE,\n\t.cmd_per_lun = 3,\n\t.shost_groups = bfad_im_host_groups,\n\t.max_sectors = BFAD_MAX_SECTORS,\n\t.vendor_id = BFA_PCI_VENDOR_ID_BROCADE,\n};\n\nstruct scsi_host_template bfad_im_vport_template = {\n\t.module = THIS_MODULE,\n\t.name = BFAD_DRIVER_NAME,\n\t.info = bfad_im_info,\n\t.queuecommand = bfad_im_queuecommand,\n\t.cmd_size = sizeof(struct bfad_cmd_priv),\n\t.eh_timed_out = fc_eh_timed_out,\n\t.eh_abort_handler = bfad_im_abort_handler,\n\t.eh_device_reset_handler = bfad_im_reset_lun_handler,\n\t.eh_target_reset_handler = bfad_im_reset_target_handler,\n\n\t.slave_alloc = bfad_im_slave_alloc,\n\t.slave_configure = bfad_im_slave_configure,\n\t.slave_destroy = bfad_im_slave_destroy,\n\n\t.this_id = -1,\n\t.sg_tablesize = BFAD_IO_MAX_SGE,\n\t.cmd_per_lun = 3,\n\t.shost_groups = bfad_im_vport_groups,\n\t.max_sectors = BFAD_MAX_SECTORS,\n};\n\nbfa_status_t\nbfad_im_module_init(void)\n{\n\tbfad_im_scsi_transport_template =\n\t\tfc_attach_transport(&bfad_im_fc_function_template);\n\tif (!bfad_im_scsi_transport_template)\n\t\treturn BFA_STATUS_ENOMEM;\n\n\tbfad_im_scsi_vport_transport_template =\n\t\tfc_attach_transport(&bfad_im_vport_fc_function_template);\n\tif (!bfad_im_scsi_vport_transport_template) {\n\t\tfc_release_transport(bfad_im_scsi_transport_template);\n\t\treturn BFA_STATUS_ENOMEM;\n\t}\n\n\treturn BFA_STATUS_OK;\n}\n\nvoid\nbfad_im_module_exit(void)\n{\n\tif (bfad_im_scsi_transport_template)\n\t\tfc_release_transport(bfad_im_scsi_transport_template);\n\n\tif (bfad_im_scsi_vport_transport_template)\n\t\tfc_release_transport(bfad_im_scsi_vport_transport_template);\n\n\tidr_destroy(&bfad_im_port_index);\n}\n\nvoid\nbfad_ramp_up_qdepth(struct bfad_itnim_s *itnim, struct scsi_device *sdev)\n{\n\tstruct scsi_device *tmp_sdev;\n\n\tif (((jiffies - itnim->last_ramp_up_time) >\n\t\tBFA_QUEUE_FULL_RAMP_UP_TIME * HZ) &&\n\t\t((jiffies - itnim->last_queue_full_time) >\n\t\tBFA_QUEUE_FULL_RAMP_UP_TIME * HZ)) {\n\t\tshost_for_each_device(tmp_sdev, sdev->host) {\n\t\t\tif (bfa_lun_queue_depth > tmp_sdev->queue_depth) {\n\t\t\t\tif (tmp_sdev->id != sdev->id)\n\t\t\t\t\tcontinue;\n\t\t\t\tscsi_change_queue_depth(tmp_sdev,\n\t\t\t\t\ttmp_sdev->queue_depth + 1);\n\n\t\t\t\titnim->last_ramp_up_time = jiffies;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\nbfad_handle_qfull(struct bfad_itnim_s *itnim, struct scsi_device *sdev)\n{\n\tstruct scsi_device *tmp_sdev;\n\n\titnim->last_queue_full_time = jiffies;\n\n\tshost_for_each_device(tmp_sdev, sdev->host) {\n\t\tif (tmp_sdev->id != sdev->id)\n\t\t\tcontinue;\n\t\tscsi_track_queue_full(tmp_sdev, tmp_sdev->queue_depth - 1);\n\t}\n}\n\nstruct bfad_itnim_s *\nbfad_get_itnim(struct bfad_im_port_s *im_port, int id)\n{\n\tstruct bfad_itnim_s   *itnim = NULL;\n\n\t \n\tlist_for_each_entry(itnim, &im_port->itnim_mapped_list, list_entry) {\n\t\tif (id == itnim->scsi_tgt_id)\n\t\t\treturn itnim;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int\nbfad_im_check_if_make_lun_visible(struct scsi_device *sdev,\n\t\t\t\t  struct fc_rport *rport)\n{\n\tstruct bfad_itnim_data_s *itnim_data =\n\t\t\t\t(struct bfad_itnim_data_s *) rport->dd_data;\n\tstruct bfa_s *bfa = itnim_data->itnim->bfa_itnim->bfa;\n\tstruct bfa_rport_s *bfa_rport = itnim_data->itnim->bfa_itnim->rport;\n\tstruct bfa_lun_mask_s *lun_list = bfa_get_lun_mask_list(bfa);\n\tint i = 0, ret = -ENXIO;\n\n\tfor (i = 0; i < MAX_LUN_MASK_CFG; i++) {\n\t\tif (lun_list[i].state == BFA_IOIM_LUN_MASK_ACTIVE &&\n\t\t    scsilun_to_int(&lun_list[i].lun) == sdev->lun &&\n\t\t    lun_list[i].rp_tag == bfa_rport->rport_tag &&\n\t\t    lun_list[i].lp_tag == (u8)bfa_rport->rport_info.lp_tag) {\n\t\t\tret = BFA_STATUS_OK;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic int\nbfad_im_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tstruct bfad_itnim_data_s *itnim_data;\n\tstruct bfa_s *bfa;\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\titnim_data = (struct bfad_itnim_data_s *) rport->dd_data;\n\tbfa = itnim_data->itnim->bfa_itnim->bfa;\n\n\tif (bfa_get_lun_mask_status(bfa) == BFA_LUNMASK_ENABLED) {\n\t\t \n\t\tif (sdev->lun == 0) {\n\t\t\tsdev->sdev_bflags |= BLIST_NOREPORTLUN |\n\t\t\t\t\t     BLIST_SPARSELUN;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (bfad_im_check_if_make_lun_visible(sdev, rport) !=\n\t\t\t\t\t\t\tBFA_STATUS_OK)\n\t\t\treturn -ENXIO;\n\t}\ndone:\n\tsdev->hostdata = rport->dd_data;\n\n\treturn 0;\n}\n\nu32\nbfad_im_supported_speeds(struct bfa_s *bfa)\n{\n\tstruct bfa_ioc_attr_s *ioc_attr;\n\tu32 supported_speed = 0;\n\n\tioc_attr = kzalloc(sizeof(struct bfa_ioc_attr_s), GFP_KERNEL);\n\tif (!ioc_attr)\n\t\treturn 0;\n\n\tbfa_ioc_get_attr(&bfa->ioc, ioc_attr);\n\tif (ioc_attr->adapter_attr.max_speed == BFA_PORT_SPEED_16GBPS)\n\t\tsupported_speed |=  FC_PORTSPEED_16GBIT | FC_PORTSPEED_8GBIT |\n\t\t\t\tFC_PORTSPEED_4GBIT | FC_PORTSPEED_2GBIT;\n\telse if (ioc_attr->adapter_attr.max_speed == BFA_PORT_SPEED_8GBPS) {\n\t\tif (ioc_attr->adapter_attr.is_mezz) {\n\t\t\tsupported_speed |= FC_PORTSPEED_8GBIT |\n\t\t\t\tFC_PORTSPEED_4GBIT |\n\t\t\t\tFC_PORTSPEED_2GBIT | FC_PORTSPEED_1GBIT;\n\t\t} else {\n\t\t\tsupported_speed |= FC_PORTSPEED_8GBIT |\n\t\t\t\tFC_PORTSPEED_4GBIT |\n\t\t\t\tFC_PORTSPEED_2GBIT;\n\t\t}\n\t} else if (ioc_attr->adapter_attr.max_speed == BFA_PORT_SPEED_4GBPS) {\n\t\tsupported_speed |=  FC_PORTSPEED_4GBIT | FC_PORTSPEED_2GBIT |\n\t\t\t\tFC_PORTSPEED_1GBIT;\n\t} else if (ioc_attr->adapter_attr.max_speed == BFA_PORT_SPEED_10GBPS) {\n\t\tsupported_speed |= FC_PORTSPEED_10GBIT;\n\t}\n\tkfree(ioc_attr);\n\treturn supported_speed;\n}\n\nvoid\nbfad_fc_host_init(struct bfad_im_port_s *im_port)\n{\n\tstruct Scsi_Host *host = im_port->shost;\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_port_s    *port = im_port->port;\n\tchar symname[BFA_SYMNAME_MAXLEN];\n\tstruct bfa_fcport_s *fcport = BFA_FCPORT_MOD(&bfad->bfa);\n\n\tfc_host_node_name(host) =\n\t\tcpu_to_be64((bfa_fcs_lport_get_nwwn(port->fcs_port)));\n\tfc_host_port_name(host) =\n\t\tcpu_to_be64((bfa_fcs_lport_get_pwwn(port->fcs_port)));\n\tfc_host_max_npiv_vports(host) = bfa_lps_get_max_vport(&bfad->bfa);\n\n\tfc_host_supported_classes(host) = FC_COS_CLASS3;\n\n\tmemset(fc_host_supported_fc4s(host), 0,\n\t       sizeof(fc_host_supported_fc4s(host)));\n\tif (supported_fc4s & BFA_LPORT_ROLE_FCP_IM)\n\t\t \n\t\tfc_host_supported_fc4s(host)[2] = 1;\n\t \n\tfc_host_supported_fc4s(host)[7] = 1;\n\n\tstrscpy(symname, bfad->bfa_fcs.fabric.bport.port_cfg.sym_name.symname,\n\t\tBFA_SYMNAME_MAXLEN);\n\tsprintf(fc_host_symbolic_name(host), \"%s\", symname);\n\n\tfc_host_supported_speeds(host) = bfad_im_supported_speeds(&bfad->bfa);\n\tfc_host_maxframe_size(host) = fcport->cfg.maxfrsize;\n}\n\nstatic void\nbfad_im_fc_rport_add(struct bfad_im_port_s *im_port, struct bfad_itnim_s *itnim)\n{\n\tstruct fc_rport_identifiers rport_ids;\n\tstruct fc_rport *fc_rport;\n\tstruct bfad_itnim_data_s *itnim_data;\n\n\trport_ids.node_name =\n\t\tcpu_to_be64(bfa_fcs_itnim_get_nwwn(&itnim->fcs_itnim));\n\trport_ids.port_name =\n\t\tcpu_to_be64(bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim));\n\trport_ids.port_id =\n\t\tbfa_hton3b(bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim));\n\trport_ids.roles = FC_RPORT_ROLE_UNKNOWN;\n\n\titnim->fc_rport = fc_rport =\n\t\tfc_remote_port_add(im_port->shost, 0, &rport_ids);\n\n\tif (!fc_rport)\n\t\treturn;\n\n\tfc_rport->maxframe_size =\n\t\tbfa_fcs_itnim_get_maxfrsize(&itnim->fcs_itnim);\n\tfc_rport->supported_classes = bfa_fcs_itnim_get_cos(&itnim->fcs_itnim);\n\n\titnim_data = fc_rport->dd_data;\n\titnim_data->itnim = itnim;\n\n\trport_ids.roles |= FC_RPORT_ROLE_FCP_TARGET;\n\n\tif (rport_ids.roles != FC_RPORT_ROLE_UNKNOWN)\n\t\tfc_remote_port_rolechg(fc_rport, rport_ids.roles);\n\n\tif ((fc_rport->scsi_target_id != -1)\n\t    && (fc_rport->scsi_target_id < MAX_FCP_TARGET))\n\t\titnim->scsi_tgt_id = fc_rport->scsi_target_id;\n\n\titnim->channel = fc_rport->channel;\n\n\treturn;\n}\n\n \nstatic void\nbfad_im_itnim_work_handler(struct work_struct *work)\n{\n\tstruct bfad_itnim_s   *itnim = container_of(work, struct bfad_itnim_s,\n\t\t\t\t\t\t\titnim_work);\n\tstruct bfad_im_s      *im = itnim->im;\n\tstruct bfad_s         *bfad = im->bfad;\n\tstruct bfad_im_port_s *im_port;\n\tunsigned long   flags;\n\tstruct fc_rport *fc_rport;\n\twwn_t wwpn;\n\tu32 fcid;\n\tchar wwpn_str[32], fcid_str[16];\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tim_port = itnim->im_port;\n\tbfa_trc(bfad, itnim->state);\n\tswitch (itnim->state) {\n\tcase ITNIM_STATE_ONLINE:\n\t\tif (!itnim->fc_rport) {\n\t\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\t\tbfad_im_fc_rport_add(im_port, itnim);\n\t\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\t\twwpn = bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim);\n\t\t\tfcid = bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim);\n\t\t\twwn2str(wwpn_str, wwpn);\n\t\t\tfcid2str(fcid_str, fcid);\n\t\t\tlist_add_tail(&itnim->list_entry,\n\t\t\t\t&im_port->itnim_mapped_list);\n\t\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\t\"ITNIM ONLINE Target: %d:0:%d \"\n\t\t\t\t\"FCID: %s WWPN: %s\\n\",\n\t\t\t\tim_port->shost->host_no,\n\t\t\t\titnim->scsi_tgt_id,\n\t\t\t\tfcid_str, wwpn_str);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"%s: itnim %llx is already in online state\\n\",\n\t\t\t\t__func__,\n\t\t\t\tbfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim));\n\t\t}\n\n\t\tbreak;\n\tcase ITNIM_STATE_OFFLINE_PENDING:\n\t\titnim->state = ITNIM_STATE_OFFLINE;\n\t\tif (itnim->fc_rport) {\n\t\t\tfc_rport = itnim->fc_rport;\n\t\t\t((struct bfad_itnim_data_s *)\n\t\t\t\tfc_rport->dd_data)->itnim = NULL;\n\t\t\titnim->fc_rport = NULL;\n\t\t\tif (!(im_port->port->flags & BFAD_PORT_DELETE)) {\n\t\t\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\t\t\tfc_rport->dev_loss_tmo =\n\t\t\t\t\tbfa_fcpim_path_tov_get(&bfad->bfa) + 1;\n\t\t\t\tfc_remote_port_delete(fc_rport);\n\t\t\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\t\t}\n\t\t\twwpn = bfa_fcs_itnim_get_pwwn(&itnim->fcs_itnim);\n\t\t\tfcid = bfa_fcs_itnim_get_fcid(&itnim->fcs_itnim);\n\t\t\twwn2str(wwpn_str, wwpn);\n\t\t\tfcid2str(fcid_str, fcid);\n\t\t\tlist_del(&itnim->list_entry);\n\t\t\tBFA_LOG(KERN_INFO, bfad, bfa_log_level,\n\t\t\t\t\"ITNIM OFFLINE Target: %d:0:%d \"\n\t\t\t\t\"FCID: %s WWPN: %s\\n\",\n\t\t\t\tim_port->shost->host_no,\n\t\t\t\titnim->scsi_tgt_id,\n\t\t\t\tfcid_str, wwpn_str);\n\t\t}\n\t\tbreak;\n\tcase ITNIM_STATE_FREE:\n\t\tif (itnim->fc_rport) {\n\t\t\tfc_rport = itnim->fc_rport;\n\t\t\t((struct bfad_itnim_data_s *)\n\t\t\t\tfc_rport->dd_data)->itnim = NULL;\n\t\t\titnim->fc_rport = NULL;\n\t\t\tif (!(im_port->port->flags & BFAD_PORT_DELETE)) {\n\t\t\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\t\t\tfc_rport->dev_loss_tmo =\n\t\t\t\t\tbfa_fcpim_path_tov_get(&bfad->bfa) + 1;\n\t\t\t\tfc_remote_port_delete(fc_rport);\n\t\t\t\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\t\t\t}\n\t\t\tlist_del(&itnim->list_entry);\n\t\t}\n\n\t\tkfree(itnim);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n}\n\n \nstatic int bfad_im_queuecommand_lck(struct scsi_cmnd *cmnd)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tstruct bfad_im_port_s *im_port =\n\t\t(struct bfad_im_port_s *) cmnd->device->host->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_itnim_data_s *itnim_data = cmnd->device->hostdata;\n\tstruct bfad_itnim_s   *itnim;\n\tstruct bfa_ioim_s *hal_io;\n\tunsigned long   flags;\n\tint             rc;\n\tint       sg_cnt = 0;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\n\trc = fc_remote_port_chkready(rport);\n\tif (rc) {\n\t\tcmnd->result = rc;\n\t\tdone(cmnd);\n\t\treturn 0;\n\t}\n\n\tif (bfad->bfad_flags & BFAD_EEH_BUSY) {\n\t\tif (bfad->bfad_flags & BFAD_EEH_PCI_CHANNEL_IO_PERM_FAILURE)\n\t\t\tcmnd->result = DID_NO_CONNECT << 16;\n\t\telse\n\t\t\tcmnd->result = DID_REQUEUE << 16;\n\t\tdone(cmnd);\n\t\treturn 0;\n\t}\n\n\tsg_cnt = scsi_dma_map(cmnd);\n\tif (sg_cnt < 0)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tif (!(bfad->bfad_flags & BFAD_HAL_START_DONE)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"bfad%d, queuecommand %p %x failed, BFA stopped\\n\",\n\t\t       bfad->inst_no, cmnd, cmnd->cmnd[0]);\n\t\tcmnd->result = DID_NO_CONNECT << 16;\n\t\tgoto out_fail_cmd;\n\t}\n\n\n\titnim = itnim_data->itnim;\n\tif (!itnim) {\n\t\tcmnd->result = DID_IMM_RETRY << 16;\n\t\tgoto out_fail_cmd;\n\t}\n\n\thal_io = bfa_ioim_alloc(&bfad->bfa, (struct bfad_ioim_s *) cmnd,\n\t\t\t\t    itnim->bfa_itnim, sg_cnt);\n\tif (!hal_io) {\n\t\tprintk(KERN_WARNING \"hal_io failure\\n\");\n\t\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\t\tscsi_dma_unmap(cmnd);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tcmnd->host_scribble = (char *)hal_io;\n\tbfa_ioim_start(hal_io);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\n\treturn 0;\n\nout_fail_cmd:\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tscsi_dma_unmap(cmnd);\n\tif (done)\n\t\tdone(cmnd);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(bfad_im_queuecommand)\n\nvoid\nbfad_rport_online_wait(struct bfad_s *bfad)\n{\n\tint i;\n\tint rport_delay = 10;\n\n\tfor (i = 0; !(bfad->bfad_flags & BFAD_PORT_ONLINE)\n\t\t&& i < bfa_linkup_delay; i++) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(HZ);\n\t}\n\n\tif (bfad->bfad_flags & BFAD_PORT_ONLINE) {\n\t\trport_delay = rport_delay < bfa_linkup_delay ?\n\t\t\trport_delay : bfa_linkup_delay;\n\t\tfor (i = 0; !(bfad->bfad_flags & BFAD_RPORT_ONLINE)\n\t\t\t&& i < rport_delay; i++) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_timeout(HZ);\n\t\t}\n\n\t\tif (rport_delay > 0 && (bfad->bfad_flags & BFAD_RPORT_ONLINE)) {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_timeout(rport_delay * HZ);\n\t\t}\n\t}\n}\n\nint\nbfad_get_linkup_delay(struct bfad_s *bfad)\n{\n\tu8\t\tnwwns = 0;\n\twwn_t\t\twwns[BFA_PREBOOT_BOOTLUN_MAX];\n\tint\t\tlinkup_delay;\n\n\t \n\n\tbfa_iocfc_get_bootwwns(&bfad->bfa, &nwwns, wwns);\n\n\tif (nwwns > 0)\n\t\t \n\t\tlinkup_delay = 30;\n\telse\n\t\t \n\t\tlinkup_delay = 0;\n\n\treturn linkup_delay;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}