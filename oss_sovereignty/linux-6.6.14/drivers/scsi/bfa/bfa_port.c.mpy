{
  "module_name": "bfa_port.c",
  "hash_id": "401027f3a0fca1edb1453202546345df91aba09be20274caa13eafff6ee594e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfa_port.c",
  "human_readable_source": "\n \n\n#include \"bfad_drv.h\"\n#include \"bfa_defs_svc.h\"\n#include \"bfa_port.h\"\n#include \"bfi.h\"\n#include \"bfa_ioc.h\"\n\n\nBFA_TRC_FILE(CNA, PORT);\n\nstatic void\nbfa_port_stats_swap(struct bfa_port_s *port, union bfa_port_stats_u *stats)\n{\n\tu32    *dip = (u32 *) stats;\n\t__be32    t0, t1;\n\tint\t    i;\n\n\tfor (i = 0; i < sizeof(union bfa_port_stats_u)/sizeof(u32);\n\t\ti += 2) {\n\t\tt0 = dip[i];\n\t\tt1 = dip[i + 1];\n#ifdef __BIG_ENDIAN\n\t\tdip[i] = be32_to_cpu(t0);\n\t\tdip[i + 1] = be32_to_cpu(t1);\n#else\n\t\tdip[i] = be32_to_cpu(t1);\n\t\tdip[i + 1] = be32_to_cpu(t0);\n#endif\n\t}\n}\n\n \nstatic void\nbfa_port_enable_isr(struct bfa_port_s *port, bfa_status_t status)\n{\n\tbfa_trc(port, status);\n\tport->endis_pending = BFA_FALSE;\n\tport->endis_cbfn(port->endis_cbarg, status);\n}\n\n \nstatic void\nbfa_port_disable_isr(struct bfa_port_s *port, bfa_status_t status)\n{\n\tbfa_trc(port, status);\n\tport->endis_pending = BFA_FALSE;\n\tport->endis_cbfn(port->endis_cbarg, status);\n}\n\n \nstatic void\nbfa_port_get_stats_isr(struct bfa_port_s *port, bfa_status_t status)\n{\n\tport->stats_status = status;\n\tport->stats_busy = BFA_FALSE;\n\n\tif (status == BFA_STATUS_OK) {\n\t\tmemcpy(port->stats, port->stats_dma.kva,\n\t\t       sizeof(union bfa_port_stats_u));\n\t\tbfa_port_stats_swap(port, port->stats);\n\n\t\tport->stats->fc.secs_reset = ktime_get_seconds() - port->stats_reset_time;\n\t}\n\n\tif (port->stats_cbfn) {\n\t\tport->stats_cbfn(port->stats_cbarg, status);\n\t\tport->stats_cbfn = NULL;\n\t}\n}\n\n \nstatic void\nbfa_port_clear_stats_isr(struct bfa_port_s *port, bfa_status_t status)\n{\n\tport->stats_status = status;\n\tport->stats_busy   = BFA_FALSE;\n\n\t \n\tport->stats_reset_time = ktime_get_seconds();\n\n\tif (port->stats_cbfn) {\n\t\tport->stats_cbfn(port->stats_cbarg, status);\n\t\tport->stats_cbfn = NULL;\n\t}\n}\n\n \nstatic void\nbfa_port_isr(void *cbarg, struct bfi_mbmsg_s *m)\n{\n\tstruct bfa_port_s *port = (struct bfa_port_s *) cbarg;\n\tunion bfi_port_i2h_msg_u *i2hmsg;\n\n\ti2hmsg = (union bfi_port_i2h_msg_u *) m;\n\tbfa_trc(port, m->mh.msg_id);\n\n\tswitch (m->mh.msg_id) {\n\tcase BFI_PORT_I2H_ENABLE_RSP:\n\t\tif (port->endis_pending == BFA_FALSE)\n\t\t\tbreak;\n\t\tbfa_port_enable_isr(port, i2hmsg->enable_rsp.status);\n\t\tbreak;\n\n\tcase BFI_PORT_I2H_DISABLE_RSP:\n\t\tif (port->endis_pending == BFA_FALSE)\n\t\t\tbreak;\n\t\tbfa_port_disable_isr(port, i2hmsg->disable_rsp.status);\n\t\tbreak;\n\n\tcase BFI_PORT_I2H_GET_STATS_RSP:\n\t\t \n\t\tif (port->stats_busy == BFA_FALSE)\n\t\t\tbreak;\n\t\tbfa_port_get_stats_isr(port, i2hmsg->getstats_rsp.status);\n\t\tbreak;\n\n\tcase BFI_PORT_I2H_CLEAR_STATS_RSP:\n\t\tif (port->stats_busy == BFA_FALSE)\n\t\t\tbreak;\n\t\tbfa_port_clear_stats_isr(port, i2hmsg->clearstats_rsp.status);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\n \nu32\nbfa_port_meminfo(void)\n{\n\treturn BFA_ROUNDUP(sizeof(union bfa_port_stats_u), BFA_DMA_ALIGN_SZ);\n}\n\n \nvoid\nbfa_port_mem_claim(struct bfa_port_s *port, u8 *dma_kva, u64 dma_pa)\n{\n\tport->stats_dma.kva = dma_kva;\n\tport->stats_dma.pa  = dma_pa;\n}\n\n \nbfa_status_t\nbfa_port_enable(struct bfa_port_s *port, bfa_port_endis_cbfn_t cbfn,\n\t\t void *cbarg)\n{\n\tstruct bfi_port_generic_req_s *m;\n\n\t \n\tif (port->pbc_disabled) {\n\t\tbfa_trc(port, BFA_STATUS_PBC);\n\t\treturn BFA_STATUS_PBC;\n\t}\n\n\tif (bfa_ioc_is_disabled(port->ioc)) {\n\t\tbfa_trc(port, BFA_STATUS_IOC_DISABLED);\n\t\treturn BFA_STATUS_IOC_DISABLED;\n\t}\n\n\tif (!bfa_ioc_is_operational(port->ioc)) {\n\t\tbfa_trc(port, BFA_STATUS_IOC_FAILURE);\n\t\treturn BFA_STATUS_IOC_FAILURE;\n\t}\n\n\t \n\tif (port->dport_enabled) {\n\t\tbfa_trc(port, BFA_STATUS_DPORT_ERR);\n\t\treturn BFA_STATUS_DPORT_ERR;\n\t}\n\n\tif (port->endis_pending) {\n\t\tbfa_trc(port, BFA_STATUS_DEVBUSY);\n\t\treturn BFA_STATUS_DEVBUSY;\n\t}\n\n\tm = (struct bfi_port_generic_req_s *) port->endis_mb.msg;\n\n\tport->msgtag++;\n\tport->endis_cbfn    = cbfn;\n\tport->endis_cbarg   = cbarg;\n\tport->endis_pending = BFA_TRUE;\n\n\tbfi_h2i_set(m->mh, BFI_MC_PORT, BFI_PORT_H2I_ENABLE_REQ,\n\t\t    bfa_ioc_portid(port->ioc));\n\tbfa_ioc_mbox_queue(port->ioc, &port->endis_mb);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_port_disable(struct bfa_port_s *port, bfa_port_endis_cbfn_t cbfn,\n\t\t  void *cbarg)\n{\n\tstruct bfi_port_generic_req_s *m;\n\n\t \n\tif (port->pbc_disabled) {\n\t\tbfa_trc(port, BFA_STATUS_PBC);\n\t\treturn BFA_STATUS_PBC;\n\t}\n\n\tif (bfa_ioc_is_disabled(port->ioc)) {\n\t\tbfa_trc(port, BFA_STATUS_IOC_DISABLED);\n\t\treturn BFA_STATUS_IOC_DISABLED;\n\t}\n\n\tif (!bfa_ioc_is_operational(port->ioc)) {\n\t\tbfa_trc(port, BFA_STATUS_IOC_FAILURE);\n\t\treturn BFA_STATUS_IOC_FAILURE;\n\t}\n\n\t \n\tif (port->dport_enabled) {\n\t\tbfa_trc(port, BFA_STATUS_DPORT_ERR);\n\t\treturn BFA_STATUS_DPORT_ERR;\n\t}\n\n\tif (port->endis_pending) {\n\t\tbfa_trc(port, BFA_STATUS_DEVBUSY);\n\t\treturn BFA_STATUS_DEVBUSY;\n\t}\n\n\tm = (struct bfi_port_generic_req_s *) port->endis_mb.msg;\n\n\tport->msgtag++;\n\tport->endis_cbfn    = cbfn;\n\tport->endis_cbarg   = cbarg;\n\tport->endis_pending = BFA_TRUE;\n\n\tbfi_h2i_set(m->mh, BFI_MC_PORT, BFI_PORT_H2I_DISABLE_REQ,\n\t\t    bfa_ioc_portid(port->ioc));\n\tbfa_ioc_mbox_queue(port->ioc, &port->endis_mb);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_port_get_stats(struct bfa_port_s *port, union bfa_port_stats_u *stats,\n\t\t    bfa_port_stats_cbfn_t cbfn, void *cbarg)\n{\n\tstruct bfi_port_get_stats_req_s *m;\n\n\tif (!bfa_ioc_is_operational(port->ioc)) {\n\t\tbfa_trc(port, BFA_STATUS_IOC_FAILURE);\n\t\treturn BFA_STATUS_IOC_FAILURE;\n\t}\n\n\tif (port->stats_busy) {\n\t\tbfa_trc(port, BFA_STATUS_DEVBUSY);\n\t\treturn BFA_STATUS_DEVBUSY;\n\t}\n\n\tm = (struct bfi_port_get_stats_req_s *) port->stats_mb.msg;\n\n\tport->stats\t  = stats;\n\tport->stats_cbfn  = cbfn;\n\tport->stats_cbarg = cbarg;\n\tport->stats_busy  = BFA_TRUE;\n\tbfa_dma_be_addr_set(m->dma_addr, port->stats_dma.pa);\n\n\tbfi_h2i_set(m->mh, BFI_MC_PORT, BFI_PORT_H2I_GET_STATS_REQ,\n\t\t    bfa_ioc_portid(port->ioc));\n\tbfa_ioc_mbox_queue(port->ioc, &port->stats_mb);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nbfa_status_t\nbfa_port_clear_stats(struct bfa_port_s *port, bfa_port_stats_cbfn_t cbfn,\n\t\t      void *cbarg)\n{\n\tstruct bfi_port_generic_req_s *m;\n\n\tif (!bfa_ioc_is_operational(port->ioc)) {\n\t\tbfa_trc(port, BFA_STATUS_IOC_FAILURE);\n\t\treturn BFA_STATUS_IOC_FAILURE;\n\t}\n\n\tif (port->stats_busy) {\n\t\tbfa_trc(port, BFA_STATUS_DEVBUSY);\n\t\treturn BFA_STATUS_DEVBUSY;\n\t}\n\n\tm = (struct bfi_port_generic_req_s *) port->stats_mb.msg;\n\n\tport->stats_cbfn  = cbfn;\n\tport->stats_cbarg = cbarg;\n\tport->stats_busy  = BFA_TRUE;\n\n\tbfi_h2i_set(m->mh, BFI_MC_PORT, BFI_PORT_H2I_CLEAR_STATS_REQ,\n\t\t    bfa_ioc_portid(port->ioc));\n\tbfa_ioc_mbox_queue(port->ioc, &port->stats_mb);\n\n\treturn BFA_STATUS_OK;\n}\n\n \nvoid\nbfa_port_notify(void *arg, enum bfa_ioc_event_e event)\n{\n\tstruct bfa_port_s *port = (struct bfa_port_s *) arg;\n\n\tswitch (event) {\n\tcase BFA_IOC_E_DISABLED:\n\tcase BFA_IOC_E_FAILED:\n\t\t \n\t\tif (port->stats_busy) {\n\t\t\tif (port->stats_cbfn)\n\t\t\t\tport->stats_cbfn(port->stats_cbarg,\n\t\t\t\t\t\tBFA_STATUS_FAILED);\n\t\t\tport->stats_cbfn = NULL;\n\t\t\tport->stats_busy = BFA_FALSE;\n\t\t}\n\n\t\t \n\t\tif (port->endis_pending) {\n\t\t\tif (port->endis_cbfn)\n\t\t\t\tport->endis_cbfn(port->endis_cbarg,\n\t\t\t\t\t\tBFA_STATUS_FAILED);\n\t\t\tport->endis_cbfn = NULL;\n\t\t\tport->endis_pending = BFA_FALSE;\n\t\t}\n\n\t\t \n\t\tif (port->dport_enabled)\n\t\t\tbfa_port_set_dportenabled(port, BFA_FALSE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid\nbfa_port_attach(struct bfa_port_s *port, struct bfa_ioc_s *ioc,\n\t\t void *dev, struct bfa_trc_mod_s *trcmod)\n{\n\tWARN_ON(!port);\n\n\tport->dev    = dev;\n\tport->ioc    = ioc;\n\tport->trcmod = trcmod;\n\n\tport->stats_busy = BFA_FALSE;\n\tport->endis_pending = BFA_FALSE;\n\tport->stats_cbfn = NULL;\n\tport->endis_cbfn = NULL;\n\tport->pbc_disabled = BFA_FALSE;\n\tport->dport_enabled = BFA_FALSE;\n\n\tbfa_ioc_mbox_regisr(port->ioc, BFI_MC_PORT, bfa_port_isr, port);\n\tbfa_q_qe_init(&port->ioc_notify);\n\tbfa_ioc_notify_init(&port->ioc_notify, bfa_port_notify, port);\n\tlist_add_tail(&port->ioc_notify.qe, &port->ioc->notify_q);\n\n\t \n\tport->stats_reset_time = ktime_get_seconds();\n\n\tbfa_trc(port, 0);\n}\n\n \nvoid\nbfa_port_set_dportenabled(struct bfa_port_s *port, bfa_boolean_t enabled)\n{\n\tport->dport_enabled = enabled;\n}\n\n \n\n \nstatic void\nbfa_cee_get_attr_isr(struct bfa_cee_s *cee, bfa_status_t status)\n{\n\tstruct bfa_cee_lldp_cfg_s *lldp_cfg = &cee->attr->lldp_remote;\n\n\tcee->get_attr_status = status;\n\tbfa_trc(cee, 0);\n\tif (status == BFA_STATUS_OK) {\n\t\tbfa_trc(cee, 0);\n\t\tmemcpy(cee->attr, cee->attr_dma.kva,\n\t\t\tsizeof(struct bfa_cee_attr_s));\n\t\tlldp_cfg->time_to_live = be16_to_cpu(lldp_cfg->time_to_live);\n\t\tlldp_cfg->enabled_system_cap =\n\t\t\t\tbe16_to_cpu(lldp_cfg->enabled_system_cap);\n\t}\n\tcee->get_attr_pending = BFA_FALSE;\n\tif (cee->cbfn.get_attr_cbfn) {\n\t\tbfa_trc(cee, 0);\n\t\tcee->cbfn.get_attr_cbfn(cee->cbfn.get_attr_cbarg, status);\n\t}\n}\n\n \nstatic void\nbfa_cee_get_stats_isr(struct bfa_cee_s *cee, bfa_status_t status)\n{\n\tu32 *buffer;\n\tint i;\n\n\tcee->get_stats_status = status;\n\tbfa_trc(cee, 0);\n\tif (status == BFA_STATUS_OK) {\n\t\tbfa_trc(cee, 0);\n\t\tmemcpy(cee->stats, cee->stats_dma.kva,\n\t\t\tsizeof(struct bfa_cee_stats_s));\n\t\t \n\t\tbuffer = (u32 *)cee->stats;\n\t\tfor (i = 0; i < (sizeof(struct bfa_cee_stats_s) /\n\t\t\t\t sizeof(u32)); i++)\n\t\t\tbuffer[i] = cpu_to_be32(buffer[i]);\n\t}\n\tcee->get_stats_pending = BFA_FALSE;\n\tbfa_trc(cee, 0);\n\tif (cee->cbfn.get_stats_cbfn) {\n\t\tbfa_trc(cee, 0);\n\t\tcee->cbfn.get_stats_cbfn(cee->cbfn.get_stats_cbarg, status);\n\t}\n}\n\n \nstatic void\nbfa_cee_reset_stats_isr(struct bfa_cee_s *cee, bfa_status_t status)\n{\n\tcee->reset_stats_status = status;\n\tcee->reset_stats_pending = BFA_FALSE;\n\tif (cee->cbfn.reset_stats_cbfn)\n\t\tcee->cbfn.reset_stats_cbfn(cee->cbfn.reset_stats_cbarg, status);\n}\n\n \nu32\nbfa_cee_meminfo(void)\n{\n\treturn BFA_ROUNDUP(sizeof(struct bfa_cee_attr_s), BFA_DMA_ALIGN_SZ) +\n\t\tBFA_ROUNDUP(sizeof(struct bfa_cee_stats_s), BFA_DMA_ALIGN_SZ);\n}\n\n \nvoid\nbfa_cee_mem_claim(struct bfa_cee_s *cee, u8 *dma_kva, u64 dma_pa)\n{\n\tcee->attr_dma.kva = dma_kva;\n\tcee->attr_dma.pa = dma_pa;\n\tcee->stats_dma.kva = dma_kva + BFA_ROUNDUP(\n\t\t\t     sizeof(struct bfa_cee_attr_s), BFA_DMA_ALIGN_SZ);\n\tcee->stats_dma.pa = dma_pa + BFA_ROUNDUP(\n\t\t\t     sizeof(struct bfa_cee_attr_s), BFA_DMA_ALIGN_SZ);\n\tcee->attr = (struct bfa_cee_attr_s *) dma_kva;\n\tcee->stats = (struct bfa_cee_stats_s *) (dma_kva + BFA_ROUNDUP(\n\t\t\tsizeof(struct bfa_cee_attr_s), BFA_DMA_ALIGN_SZ));\n}\n\n \n\nbfa_status_t\nbfa_cee_get_attr(struct bfa_cee_s *cee, struct bfa_cee_attr_s *attr,\n\t\t bfa_cee_get_attr_cbfn_t cbfn, void *cbarg)\n{\n\tstruct bfi_cee_get_req_s *cmd;\n\n\tWARN_ON((cee == NULL) || (cee->ioc == NULL));\n\tbfa_trc(cee, 0);\n\tif (!bfa_ioc_is_operational(cee->ioc)) {\n\t\tbfa_trc(cee, 0);\n\t\treturn BFA_STATUS_IOC_FAILURE;\n\t}\n\tif (cee->get_attr_pending == BFA_TRUE) {\n\t\tbfa_trc(cee, 0);\n\t\treturn  BFA_STATUS_DEVBUSY;\n\t}\n\tcee->get_attr_pending = BFA_TRUE;\n\tcmd = (struct bfi_cee_get_req_s *) cee->get_cfg_mb.msg;\n\tcee->attr = attr;\n\tcee->cbfn.get_attr_cbfn = cbfn;\n\tcee->cbfn.get_attr_cbarg = cbarg;\n\tbfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_GET_CFG_REQ,\n\t\tbfa_ioc_portid(cee->ioc));\n\tbfa_dma_be_addr_set(cmd->dma_addr, cee->attr_dma.pa);\n\tbfa_ioc_mbox_queue(cee->ioc, &cee->get_cfg_mb);\n\n\treturn BFA_STATUS_OK;\n}\n\n \n\nbfa_status_t\nbfa_cee_get_stats(struct bfa_cee_s *cee, struct bfa_cee_stats_s *stats,\n\t\t  bfa_cee_get_stats_cbfn_t cbfn, void *cbarg)\n{\n\tstruct bfi_cee_get_req_s *cmd;\n\n\tWARN_ON((cee == NULL) || (cee->ioc == NULL));\n\n\tif (!bfa_ioc_is_operational(cee->ioc)) {\n\t\tbfa_trc(cee, 0);\n\t\treturn BFA_STATUS_IOC_FAILURE;\n\t}\n\tif (cee->get_stats_pending == BFA_TRUE) {\n\t\tbfa_trc(cee, 0);\n\t\treturn  BFA_STATUS_DEVBUSY;\n\t}\n\tcee->get_stats_pending = BFA_TRUE;\n\tcmd = (struct bfi_cee_get_req_s *) cee->get_stats_mb.msg;\n\tcee->stats = stats;\n\tcee->cbfn.get_stats_cbfn = cbfn;\n\tcee->cbfn.get_stats_cbarg = cbarg;\n\tbfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_GET_STATS_REQ,\n\t\tbfa_ioc_portid(cee->ioc));\n\tbfa_dma_be_addr_set(cmd->dma_addr, cee->stats_dma.pa);\n\tbfa_ioc_mbox_queue(cee->ioc, &cee->get_stats_mb);\n\n\treturn BFA_STATUS_OK;\n}\n\n \n\nbfa_status_t\nbfa_cee_reset_stats(struct bfa_cee_s *cee,\n\t\t    bfa_cee_reset_stats_cbfn_t cbfn, void *cbarg)\n{\n\tstruct bfi_cee_reset_stats_s *cmd;\n\n\tWARN_ON((cee == NULL) || (cee->ioc == NULL));\n\tif (!bfa_ioc_is_operational(cee->ioc)) {\n\t\tbfa_trc(cee, 0);\n\t\treturn BFA_STATUS_IOC_FAILURE;\n\t}\n\tif (cee->reset_stats_pending == BFA_TRUE) {\n\t\tbfa_trc(cee, 0);\n\t\treturn  BFA_STATUS_DEVBUSY;\n\t}\n\tcee->reset_stats_pending = BFA_TRUE;\n\tcmd = (struct bfi_cee_reset_stats_s *) cee->reset_stats_mb.msg;\n\tcee->cbfn.reset_stats_cbfn = cbfn;\n\tcee->cbfn.reset_stats_cbarg = cbarg;\n\tbfi_h2i_set(cmd->mh, BFI_MC_CEE, BFI_CEE_H2I_RESET_STATS,\n\t\tbfa_ioc_portid(cee->ioc));\n\tbfa_ioc_mbox_queue(cee->ioc, &cee->reset_stats_mb);\n\n\treturn BFA_STATUS_OK;\n}\n\n \n\nstatic void\nbfa_cee_isr(void *cbarg, struct bfi_mbmsg_s *m)\n{\n\tunion bfi_cee_i2h_msg_u *msg;\n\tstruct bfi_cee_get_rsp_s *get_rsp;\n\tstruct bfa_cee_s *cee = (struct bfa_cee_s *) cbarg;\n\tmsg = (union bfi_cee_i2h_msg_u *) m;\n\tget_rsp = (struct bfi_cee_get_rsp_s *) m;\n\tbfa_trc(cee, msg->mh.msg_id);\n\tswitch (msg->mh.msg_id) {\n\tcase BFI_CEE_I2H_GET_CFG_RSP:\n\t\tbfa_trc(cee, get_rsp->cmd_status);\n\t\tbfa_cee_get_attr_isr(cee, get_rsp->cmd_status);\n\t\tbreak;\n\tcase BFI_CEE_I2H_GET_STATS_RSP:\n\t\tbfa_cee_get_stats_isr(cee, get_rsp->cmd_status);\n\t\tbreak;\n\tcase BFI_CEE_I2H_RESET_STATS_RSP:\n\t\tbfa_cee_reset_stats_isr(cee, get_rsp->cmd_status);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\n\n \n\nstatic void\nbfa_cee_notify(void *arg, enum bfa_ioc_event_e event)\n{\n\tstruct bfa_cee_s *cee = (struct bfa_cee_s *) arg;\n\n\tbfa_trc(cee, event);\n\n\tswitch (event) {\n\tcase BFA_IOC_E_DISABLED:\n\tcase BFA_IOC_E_FAILED:\n\t\tif (cee->get_attr_pending == BFA_TRUE) {\n\t\t\tcee->get_attr_status = BFA_STATUS_FAILED;\n\t\t\tcee->get_attr_pending  = BFA_FALSE;\n\t\t\tif (cee->cbfn.get_attr_cbfn) {\n\t\t\t\tcee->cbfn.get_attr_cbfn(\n\t\t\t\t\tcee->cbfn.get_attr_cbarg,\n\t\t\t\t\tBFA_STATUS_FAILED);\n\t\t\t}\n\t\t}\n\t\tif (cee->get_stats_pending == BFA_TRUE) {\n\t\t\tcee->get_stats_status = BFA_STATUS_FAILED;\n\t\t\tcee->get_stats_pending  = BFA_FALSE;\n\t\t\tif (cee->cbfn.get_stats_cbfn) {\n\t\t\t\tcee->cbfn.get_stats_cbfn(\n\t\t\t\tcee->cbfn.get_stats_cbarg,\n\t\t\t\tBFA_STATUS_FAILED);\n\t\t\t}\n\t\t}\n\t\tif (cee->reset_stats_pending == BFA_TRUE) {\n\t\t\tcee->reset_stats_status = BFA_STATUS_FAILED;\n\t\t\tcee->reset_stats_pending  = BFA_FALSE;\n\t\t\tif (cee->cbfn.reset_stats_cbfn) {\n\t\t\t\tcee->cbfn.reset_stats_cbfn(\n\t\t\t\tcee->cbfn.reset_stats_cbarg,\n\t\t\t\tBFA_STATUS_FAILED);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid\nbfa_cee_attach(struct bfa_cee_s *cee, struct bfa_ioc_s *ioc,\n\t\tvoid *dev)\n{\n\tWARN_ON(cee == NULL);\n\tcee->dev = dev;\n\tcee->ioc = ioc;\n\n\tbfa_ioc_mbox_regisr(cee->ioc, BFI_MC_CEE, bfa_cee_isr, cee);\n\tbfa_q_qe_init(&cee->ioc_notify);\n\tbfa_ioc_notify_init(&cee->ioc_notify, bfa_cee_notify, cee);\n\tlist_add_tail(&cee->ioc_notify.qe, &cee->ioc->notify_q);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}