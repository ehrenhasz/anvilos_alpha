{
  "module_name": "bfa_ioc_cb.c",
  "hash_id": "38a4edb4afee77a2d2717721b27ed310d8186ef82314cf88e0aa44909f91d05b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfa_ioc_cb.c",
  "human_readable_source": "\n \n\n#include \"bfad_drv.h\"\n#include \"bfa_ioc.h\"\n#include \"bfi_reg.h\"\n#include \"bfa_defs.h\"\n\nBFA_TRC_FILE(CNA, IOC_CB);\n\n#define bfa_ioc_cb_join_pos(__ioc) ((u32) (1 << BFA_IOC_CB_JOIN_SH))\n\n \nstatic bfa_boolean_t bfa_ioc_cb_firmware_lock(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_firmware_unlock(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_reg_init(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_map_port(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_isr_mode_set(struct bfa_ioc_s *ioc, bfa_boolean_t msix);\nstatic void bfa_ioc_cb_notify_fail(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_ownership_reset(struct bfa_ioc_s *ioc);\nstatic bfa_boolean_t bfa_ioc_cb_sync_start(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_sync_join(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_sync_leave(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_sync_ack(struct bfa_ioc_s *ioc);\nstatic bfa_boolean_t bfa_ioc_cb_sync_complete(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_set_cur_ioc_fwstate(\n\t\t\tstruct bfa_ioc_s *ioc, enum bfi_ioc_state fwstate);\nstatic enum bfi_ioc_state bfa_ioc_cb_get_cur_ioc_fwstate(struct bfa_ioc_s *ioc);\nstatic void bfa_ioc_cb_set_alt_ioc_fwstate(\n\t\t\tstruct bfa_ioc_s *ioc, enum bfi_ioc_state fwstate);\nstatic enum bfi_ioc_state bfa_ioc_cb_get_alt_ioc_fwstate(struct bfa_ioc_s *ioc);\n\nstatic struct bfa_ioc_hwif_s hwif_cb;\n\n \nvoid\nbfa_ioc_set_cb_hwif(struct bfa_ioc_s *ioc)\n{\n\thwif_cb.ioc_pll_init = bfa_ioc_cb_pll_init;\n\thwif_cb.ioc_firmware_lock = bfa_ioc_cb_firmware_lock;\n\thwif_cb.ioc_firmware_unlock = bfa_ioc_cb_firmware_unlock;\n\thwif_cb.ioc_reg_init = bfa_ioc_cb_reg_init;\n\thwif_cb.ioc_map_port = bfa_ioc_cb_map_port;\n\thwif_cb.ioc_isr_mode_set = bfa_ioc_cb_isr_mode_set;\n\thwif_cb.ioc_notify_fail = bfa_ioc_cb_notify_fail;\n\thwif_cb.ioc_ownership_reset = bfa_ioc_cb_ownership_reset;\n\thwif_cb.ioc_sync_start = bfa_ioc_cb_sync_start;\n\thwif_cb.ioc_sync_join = bfa_ioc_cb_sync_join;\n\thwif_cb.ioc_sync_leave = bfa_ioc_cb_sync_leave;\n\thwif_cb.ioc_sync_ack = bfa_ioc_cb_sync_ack;\n\thwif_cb.ioc_sync_complete = bfa_ioc_cb_sync_complete;\n\thwif_cb.ioc_set_fwstate = bfa_ioc_cb_set_cur_ioc_fwstate;\n\thwif_cb.ioc_get_fwstate = bfa_ioc_cb_get_cur_ioc_fwstate;\n\thwif_cb.ioc_set_alt_fwstate = bfa_ioc_cb_set_alt_ioc_fwstate;\n\thwif_cb.ioc_get_alt_fwstate = bfa_ioc_cb_get_alt_ioc_fwstate;\n\n\tioc->ioc_hwif = &hwif_cb;\n}\n\n \nstatic bfa_boolean_t\nbfa_ioc_cb_firmware_lock(struct bfa_ioc_s *ioc)\n{\n\tenum bfi_ioc_state alt_fwstate, cur_fwstate;\n\tstruct bfi_ioc_image_hdr_s fwhdr;\n\n\tcur_fwstate = bfa_ioc_cb_get_cur_ioc_fwstate(ioc);\n\tbfa_trc(ioc, cur_fwstate);\n\talt_fwstate = bfa_ioc_cb_get_alt_ioc_fwstate(ioc);\n\tbfa_trc(ioc, alt_fwstate);\n\n\t \n\tif (cur_fwstate == BFI_IOC_UNINIT)\n\t\treturn BFA_TRUE;\n\t \n\tbfa_ioc_fwver_get(ioc, &fwhdr);\n\tif (!bfa_ioc_fwver_cmp(ioc, &fwhdr) &&\n\t\talt_fwstate != BFI_IOC_DISABLED) {\n\t\tbfa_trc(ioc, alt_fwstate);\n\t\treturn BFA_FALSE;\n\t}\n\n\treturn BFA_TRUE;\n}\n\nstatic void\nbfa_ioc_cb_firmware_unlock(struct bfa_ioc_s *ioc)\n{\n}\n\n \nstatic void\nbfa_ioc_cb_notify_fail(struct bfa_ioc_s *ioc)\n{\n\twritel(~0U, ioc->ioc_regs.err_set);\n\treadl(ioc->ioc_regs.err_set);\n}\n\n \nstatic struct { u32 hfn_mbox, lpu_mbox, hfn_pgn; } iocreg_fnreg[] = {\n\t{ HOSTFN0_LPU_MBOX0_0, LPU_HOSTFN0_MBOX0_0, HOST_PAGE_NUM_FN0 },\n\t{ HOSTFN1_LPU_MBOX0_8, LPU_HOSTFN1_MBOX0_8, HOST_PAGE_NUM_FN1 }\n};\n\n \nstatic struct { u32 hfn, lpu; } iocreg_mbcmd[] = {\n\n\t{ HOSTFN0_LPU0_CMD_STAT, LPU0_HOSTFN0_CMD_STAT },\n\t{ HOSTFN1_LPU1_CMD_STAT, LPU1_HOSTFN1_CMD_STAT }\n};\n\nstatic void\nbfa_ioc_cb_reg_init(struct bfa_ioc_s *ioc)\n{\n\tvoid __iomem *rb;\n\tint\t\tpcifn = bfa_ioc_pcifn(ioc);\n\n\trb = bfa_ioc_bar0(ioc);\n\n\tioc->ioc_regs.hfn_mbox = rb + iocreg_fnreg[pcifn].hfn_mbox;\n\tioc->ioc_regs.lpu_mbox = rb + iocreg_fnreg[pcifn].lpu_mbox;\n\tioc->ioc_regs.host_page_num_fn = rb + iocreg_fnreg[pcifn].hfn_pgn;\n\n\tif (ioc->port_id == 0) {\n\t\tioc->ioc_regs.heartbeat = rb + BFA_IOC0_HBEAT_REG;\n\t\tioc->ioc_regs.ioc_fwstate = rb + BFA_IOC0_STATE_REG;\n\t\tioc->ioc_regs.alt_ioc_fwstate = rb + BFA_IOC1_STATE_REG;\n\t} else {\n\t\tioc->ioc_regs.heartbeat = (rb + BFA_IOC1_HBEAT_REG);\n\t\tioc->ioc_regs.ioc_fwstate = (rb + BFA_IOC1_STATE_REG);\n\t\tioc->ioc_regs.alt_ioc_fwstate = (rb + BFA_IOC0_STATE_REG);\n\t}\n\n\t \n\tioc->ioc_regs.hfn_mbox_cmd = rb + iocreg_mbcmd[pcifn].hfn;\n\tioc->ioc_regs.lpu_mbox_cmd = rb + iocreg_mbcmd[pcifn].lpu;\n\n\t \n\tioc->ioc_regs.pss_ctl_reg = (rb + PSS_CTL_REG);\n\tioc->ioc_regs.pss_err_status_reg = (rb + PSS_ERR_STATUS_REG);\n\tioc->ioc_regs.app_pll_fast_ctl_reg = (rb + APP_PLL_LCLK_CTL_REG);\n\tioc->ioc_regs.app_pll_slow_ctl_reg = (rb + APP_PLL_SCLK_CTL_REG);\n\n\t \n\tioc->ioc_regs.ioc_sem_reg = (rb + HOST_SEM0_REG);\n\tioc->ioc_regs.ioc_init_sem_reg = (rb + HOST_SEM2_REG);\n\n\t \n\tioc->ioc_regs.smem_page_start = (rb + PSS_SMEM_PAGE_START);\n\tioc->ioc_regs.smem_pg0 = BFI_IOC_SMEM_PG0_CB;\n\n\t \n\tioc->ioc_regs.err_set = (rb + ERR_SET_REG);\n}\n\n \n\nstatic void\nbfa_ioc_cb_map_port(struct bfa_ioc_s *ioc)\n{\n\t \n\tioc->port_id = bfa_ioc_pcifn(ioc);\n\n\tbfa_trc(ioc, ioc->port_id);\n}\n\n \nstatic void\nbfa_ioc_cb_isr_mode_set(struct bfa_ioc_s *ioc, bfa_boolean_t msix)\n{\n}\n\n \nstatic bfa_boolean_t\nbfa_ioc_cb_sync_start(struct bfa_ioc_s *ioc)\n{\n\tu32 ioc_fwstate = readl(ioc->ioc_regs.ioc_fwstate);\n\n\t \n\tif (ioc_fwstate & BFA_IOC_CB_JOIN_MASK) {\n\t\twritel(BFI_IOC_UNINIT, ioc->ioc_regs.ioc_fwstate);\n\t\twritel(BFI_IOC_UNINIT, ioc->ioc_regs.alt_ioc_fwstate);\n\t\treturn BFA_TRUE;\n\t}\n\n\treturn bfa_ioc_cb_sync_complete(ioc);\n}\n\n \nstatic void\nbfa_ioc_cb_ownership_reset(struct bfa_ioc_s *ioc)\n{\n\n\t \n\treadl(ioc->ioc_regs.ioc_sem_reg);\n\twritel(1, ioc->ioc_regs.ioc_sem_reg);\n}\n\n \nstatic void\nbfa_ioc_cb_sync_join(struct bfa_ioc_s *ioc)\n{\n\tu32 r32 = readl(ioc->ioc_regs.ioc_fwstate);\n\tu32 join_pos = bfa_ioc_cb_join_pos(ioc);\n\n\twritel((r32 | join_pos), ioc->ioc_regs.ioc_fwstate);\n}\n\nstatic void\nbfa_ioc_cb_sync_leave(struct bfa_ioc_s *ioc)\n{\n\tu32 r32 = readl(ioc->ioc_regs.ioc_fwstate);\n\tu32 join_pos = bfa_ioc_cb_join_pos(ioc);\n\n\twritel((r32 & ~join_pos), ioc->ioc_regs.ioc_fwstate);\n}\n\nstatic void\nbfa_ioc_cb_set_cur_ioc_fwstate(struct bfa_ioc_s *ioc,\n\t\t\tenum bfi_ioc_state fwstate)\n{\n\tu32 r32 = readl(ioc->ioc_regs.ioc_fwstate);\n\n\twritel((fwstate | (r32 & BFA_IOC_CB_JOIN_MASK)),\n\t\t\t\tioc->ioc_regs.ioc_fwstate);\n}\n\nstatic enum bfi_ioc_state\nbfa_ioc_cb_get_cur_ioc_fwstate(struct bfa_ioc_s *ioc)\n{\n\treturn (enum bfi_ioc_state)(readl(ioc->ioc_regs.ioc_fwstate) &\n\t\t\tBFA_IOC_CB_FWSTATE_MASK);\n}\n\nstatic void\nbfa_ioc_cb_set_alt_ioc_fwstate(struct bfa_ioc_s *ioc,\n\t\t\tenum bfi_ioc_state fwstate)\n{\n\tu32 r32 = readl(ioc->ioc_regs.alt_ioc_fwstate);\n\n\twritel((fwstate | (r32 & BFA_IOC_CB_JOIN_MASK)),\n\t\t\t\tioc->ioc_regs.alt_ioc_fwstate);\n}\n\nstatic enum bfi_ioc_state\nbfa_ioc_cb_get_alt_ioc_fwstate(struct bfa_ioc_s *ioc)\n{\n\treturn (enum bfi_ioc_state)(readl(ioc->ioc_regs.alt_ioc_fwstate) &\n\t\t\tBFA_IOC_CB_FWSTATE_MASK);\n}\n\nstatic void\nbfa_ioc_cb_sync_ack(struct bfa_ioc_s *ioc)\n{\n\tbfa_ioc_cb_set_cur_ioc_fwstate(ioc, BFI_IOC_FAIL);\n}\n\nstatic bfa_boolean_t\nbfa_ioc_cb_sync_complete(struct bfa_ioc_s *ioc)\n{\n\tu32 fwstate, alt_fwstate;\n\tfwstate = bfa_ioc_cb_get_cur_ioc_fwstate(ioc);\n\n\t \n\tif (fwstate == BFI_IOC_UNINIT ||\n\t\tfwstate == BFI_IOC_INITING ||\n\t\tfwstate == BFI_IOC_DISABLED ||\n\t\tfwstate == BFI_IOC_MEMTEST ||\n\t\tfwstate == BFI_IOC_OP)\n\t\treturn BFA_TRUE;\n\telse {\n\t\talt_fwstate = bfa_ioc_cb_get_alt_ioc_fwstate(ioc);\n\t\tif (alt_fwstate == BFI_IOC_FAIL ||\n\t\t\talt_fwstate == BFI_IOC_DISABLED ||\n\t\t\talt_fwstate == BFI_IOC_UNINIT ||\n\t\t\talt_fwstate == BFI_IOC_INITING ||\n\t\t\talt_fwstate == BFI_IOC_MEMTEST)\n\t\t\treturn BFA_TRUE;\n\t\telse\n\t\t\treturn BFA_FALSE;\n\t}\n}\n\nbfa_status_t\nbfa_ioc_cb_pll_init(void __iomem *rb, enum bfi_asic_mode fcmode)\n{\n\tu32\tpll_sclk, pll_fclk, join_bits;\n\n\tpll_sclk = __APP_PLL_SCLK_ENABLE | __APP_PLL_SCLK_LRESETN |\n\t\t__APP_PLL_SCLK_P0_1(3U) |\n\t\t__APP_PLL_SCLK_JITLMT0_1(3U) |\n\t\t__APP_PLL_SCLK_CNTLMT0_1(3U);\n\tpll_fclk = __APP_PLL_LCLK_ENABLE | __APP_PLL_LCLK_LRESETN |\n\t\t__APP_PLL_LCLK_RSEL200500 | __APP_PLL_LCLK_P0_1(3U) |\n\t\t__APP_PLL_LCLK_JITLMT0_1(3U) |\n\t\t__APP_PLL_LCLK_CNTLMT0_1(3U);\n\tjoin_bits = readl(rb + BFA_IOC0_STATE_REG) &\n\t\t\tBFA_IOC_CB_JOIN_MASK;\n\twritel((BFI_IOC_UNINIT | join_bits), (rb + BFA_IOC0_STATE_REG));\n\tjoin_bits = readl(rb + BFA_IOC1_STATE_REG) &\n\t\t\tBFA_IOC_CB_JOIN_MASK;\n\twritel((BFI_IOC_UNINIT | join_bits), (rb + BFA_IOC1_STATE_REG));\n\twritel(0xffffffffU, (rb + HOSTFN0_INT_MSK));\n\twritel(0xffffffffU, (rb + HOSTFN1_INT_MSK));\n\twritel(0xffffffffU, (rb + HOSTFN0_INT_STATUS));\n\twritel(0xffffffffU, (rb + HOSTFN1_INT_STATUS));\n\twritel(0xffffffffU, (rb + HOSTFN0_INT_MSK));\n\twritel(0xffffffffU, (rb + HOSTFN1_INT_MSK));\n\twritel(__APP_PLL_SCLK_LOGIC_SOFT_RESET, rb + APP_PLL_SCLK_CTL_REG);\n\twritel(__APP_PLL_SCLK_BYPASS | __APP_PLL_SCLK_LOGIC_SOFT_RESET,\n\t\t\trb + APP_PLL_SCLK_CTL_REG);\n\twritel(__APP_PLL_LCLK_LOGIC_SOFT_RESET, rb + APP_PLL_LCLK_CTL_REG);\n\twritel(__APP_PLL_LCLK_BYPASS | __APP_PLL_LCLK_LOGIC_SOFT_RESET,\n\t\t\trb + APP_PLL_LCLK_CTL_REG);\n\tudelay(2);\n\twritel(__APP_PLL_SCLK_LOGIC_SOFT_RESET, rb + APP_PLL_SCLK_CTL_REG);\n\twritel(__APP_PLL_LCLK_LOGIC_SOFT_RESET, rb + APP_PLL_LCLK_CTL_REG);\n\twritel(pll_sclk | __APP_PLL_SCLK_LOGIC_SOFT_RESET,\n\t\t\trb + APP_PLL_SCLK_CTL_REG);\n\twritel(pll_fclk | __APP_PLL_LCLK_LOGIC_SOFT_RESET,\n\t\t\trb + APP_PLL_LCLK_CTL_REG);\n\tudelay(2000);\n\twritel(0xffffffffU, (rb + HOSTFN0_INT_STATUS));\n\twritel(0xffffffffU, (rb + HOSTFN1_INT_STATUS));\n\twritel(pll_sclk, (rb + APP_PLL_SCLK_CTL_REG));\n\twritel(pll_fclk, (rb + APP_PLL_LCLK_CTL_REG));\n\n\treturn BFA_STATUS_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}