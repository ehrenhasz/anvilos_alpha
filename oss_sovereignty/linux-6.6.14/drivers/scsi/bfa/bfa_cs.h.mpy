{
  "module_name": "bfa_cs.h",
  "hash_id": "d4c1dc0631cd1ceee13b61619586524d9d1072f371aeebe2cf49c7cba94965e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bfa/bfa_cs.h",
  "human_readable_source": " \n \n\n \n\n#ifndef __BFA_CS_H__\n#define __BFA_CS_H__\n\n#include \"bfad_drv.h\"\n\n \n\n#ifndef BFA_TRC_MAX\n#define BFA_TRC_MAX\t(4 * 1024)\n#endif\n\n#define BFA_TRC_TS(_trcm)                               \\\n\t({                                              \\\n\t\tstruct timespec64 ts;                   \\\n\t\t\t\t\t\t\t\\\n\t\tktime_get_ts64(&ts);                    \\\n\t\t(ts.tv_sec*1000000+ts.tv_nsec / 1000);  \\\n\t})\n\n#ifndef BFA_TRC_TS\n#define BFA_TRC_TS(_trcm)\t((_trcm)->ticks++)\n#endif\n\nstruct bfa_trc_s {\n#ifdef __BIG_ENDIAN\n\tu16\tfileno;\n\tu16\tline;\n#else\n\tu16\tline;\n\tu16\tfileno;\n#endif\n\tu32\ttimestamp;\n\tunion {\n\t\tstruct {\n\t\t\tu32\trsvd;\n\t\t\tu32\tu32;\n\t\t} u32;\n\t\tu64\tu64;\n\t} data;\n};\n\nstruct bfa_trc_mod_s {\n\tu32\thead;\n\tu32\ttail;\n\tu32\tntrc;\n\tu32\tstopped;\n\tu32\tticks;\n\tu32\trsvd[3];\n\tstruct bfa_trc_s trc[BFA_TRC_MAX];\n};\n\nenum {\n\tBFA_TRC_HAL  = 1,\t \n\tBFA_TRC_FCS  = 2,\t \n\tBFA_TRC_LDRV = 3,\t \n\tBFA_TRC_CNA  = 4,\t \n};\n#define BFA_TRC_MOD_SH\t10\n#define BFA_TRC_MOD(__mod)\t((BFA_TRC_ ## __mod) << BFA_TRC_MOD_SH)\n\n \n#define BFA_TRC_FILE(__mod, __submod)\t\t\t\t\t\\\n\tstatic int __trc_fileno = ((BFA_TRC_ ## __mod ## _ ## __submod) | \\\n\t\t\t\t\t\t BFA_TRC_MOD(__mod))\n\n\n#define bfa_trc32(_trcp, _data)\t\\\n\t__bfa_trc((_trcp)->trcmod, __trc_fileno, __LINE__, (u32)_data)\n#define bfa_trc(_trcp, _data)\t\\\n\t__bfa_trc((_trcp)->trcmod, __trc_fileno, __LINE__, (u64)_data)\n\nstatic inline void\nbfa_trc_init(struct bfa_trc_mod_s *trcm)\n{\n\ttrcm->head = trcm->tail = trcm->stopped = 0;\n\ttrcm->ntrc = BFA_TRC_MAX;\n}\n\nstatic inline void\nbfa_trc_stop(struct bfa_trc_mod_s *trcm)\n{\n\ttrcm->stopped = 1;\n}\n\nvoid\n__bfa_trc(struct bfa_trc_mod_s *trcm, int fileno, int line, u64 data);\n\nvoid\n__bfa_trc32(struct bfa_trc_mod_s *trcm, int fileno, int line, u32 data);\n\n#define bfa_sm_fault(__mod, __event)\tdo {\t\t\t\t\\\n\tbfa_trc(__mod, (((u32)0xDEAD << 16) | __event));\t\t\\\n\tprintk(KERN_ERR\t\"Assertion failure: %s:%d: %d\",\t\t\t\\\n\t\t__FILE__, __LINE__, (__event));\t\t\t\t\\\n} while (0)\n\n \n#define bfa_q_first(_q) ((void *)(((struct list_head *) (_q))->next))\n#define bfa_q_next(_qe) (((struct list_head *) (_qe))->next)\n#define bfa_q_prev(_qe) (((struct list_head *) (_qe))->prev)\n\n \n#define bfa_q_qe_init(_qe) {\t\t\t\t\\\n\tbfa_q_next(_qe) = (struct list_head *) NULL;\t\\\n\tbfa_q_prev(_qe) = (struct list_head *) NULL;\t\\\n}\n\n \n#define bfa_q_deq(_q, _qe) do {\t\t\t\t\t\t\\\n\tif (!list_empty(_q)) {\t\t\t\t\t\t\\\n\t\t(*((struct list_head **) (_qe))) = bfa_q_next(_q);\t\\\n\t\tbfa_q_prev(bfa_q_next(*((struct list_head **) _qe))) =\t\\\n\t\t\t\t(struct list_head *) (_q);\t\t\\\n\t\tbfa_q_next(_q) = bfa_q_next(*((struct list_head **) _qe));\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t*((struct list_head **) (_qe)) = (struct list_head *) NULL;\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n \n#define bfa_q_deq_tail(_q, _qe) {\t\t\t\t\t\\\n\tif (!list_empty(_q)) {\t\t\t\t\t\t\\\n\t\t*((struct list_head **) (_qe)) = bfa_q_prev(_q);\t\\\n\t\tbfa_q_next(bfa_q_prev(*((struct list_head **) _qe))) =\t\\\n\t\t\t(struct list_head *) (_q);\t\t\t\\\n\t\tbfa_q_prev(_q) = bfa_q_prev(*(struct list_head **) _qe);\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t*((struct list_head **) (_qe)) = (struct list_head *) NULL;\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\nstatic inline int\nbfa_q_is_on_q_func(struct list_head *q, struct list_head *qe)\n{\n\tstruct list_head        *tqe;\n\n\ttqe = bfa_q_next(q);\n\twhile (tqe != q) {\n\t\tif (tqe == qe)\n\t\t\treturn 1;\n\t\ttqe = bfa_q_next(tqe);\n\t\tif (tqe == NULL)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define bfa_q_is_on_q(_q, _qe)      \\\n\tbfa_q_is_on_q_func(_q, (struct list_head *)(_qe))\n\n \n\ntypedef void (*bfa_sm_t)(void *sm, int event);\n\n \n#define bfa_sm_state_decl(oc, st, otype, etype)\t\t\\\n\tstatic void oc ## _sm_ ## st(otype * fsm, etype event)\n\n#define bfa_sm_set_state(_sm, _state)\t((_sm)->sm = (bfa_sm_t)(_state))\n#define bfa_sm_send_event(_sm, _event)\t((_sm)->sm((_sm), (_event)))\n#define bfa_sm_get_state(_sm)\t\t((_sm)->sm)\n#define bfa_sm_cmp_state(_sm, _state)\t((_sm)->sm == (bfa_sm_t)(_state))\n\n \nstruct bfa_sm_table_s {\n\tbfa_sm_t\tsm;\t \n\tint\t\tstate;\t \n\tchar\t\t*name;\t \n};\n#define BFA_SM(_sm)\t((bfa_sm_t)(_sm))\n\n \ntypedef void (*bfa_fsm_t)(void *fsm, int event);\n\n \n#define bfa_fsm_state_decl(oc, st, otype, etype)\t\t\\\n\tstatic void oc ## _sm_ ## st(otype * fsm, etype event);      \\\n\tstatic void oc ## _sm_ ## st ## _entry(otype * fsm)\n\n#define bfa_fsm_set_state(_fsm, _state) do {\t\\\n\t(_fsm)->fsm = (bfa_fsm_t)(_state);      \\\n\t_state ## _entry(_fsm);      \\\n} while (0)\n\n#define bfa_fsm_send_event(_fsm, _event)\t((_fsm)->fsm((_fsm), (_event)))\n#define bfa_fsm_get_state(_fsm)\t\t\t((_fsm)->fsm)\n#define bfa_fsm_cmp_state(_fsm, _state)\t\t\\\n\t((_fsm)->fsm == (bfa_fsm_t)(_state))\n\nstatic inline int\nbfa_sm_to_state(struct bfa_sm_table_s *smt, bfa_sm_t sm)\n{\n\tint\ti = 0;\n\n\twhile (smt[i].sm && smt[i].sm != sm)\n\t\ti++;\n\treturn smt[i].state;\n}\n\n \n\ntypedef void (*bfa_wc_resume_t) (void *cbarg);\n\nstruct bfa_wc_s {\n\tbfa_wc_resume_t wc_resume;\n\tvoid\t\t*wc_cbarg;\n\tint\t\twc_count;\n};\n\nstatic inline void\nbfa_wc_up(struct bfa_wc_s *wc)\n{\n\twc->wc_count++;\n}\n\nstatic inline void\nbfa_wc_down(struct bfa_wc_s *wc)\n{\n\twc->wc_count--;\n\tif (wc->wc_count == 0)\n\t\twc->wc_resume(wc->wc_cbarg);\n}\n\n \nstatic inline void\nbfa_wc_init(struct bfa_wc_s *wc, bfa_wc_resume_t wc_resume, void *wc_cbarg)\n{\n\twc->wc_resume = wc_resume;\n\twc->wc_cbarg = wc_cbarg;\n\twc->wc_count = 0;\n\tbfa_wc_up(wc);\n}\n\n \nstatic inline void\nbfa_wc_wait(struct bfa_wc_s *wc)\n{\n\tbfa_wc_down(wc);\n}\n\nstatic inline void\nwwn2str(char *wwn_str, u64 wwn)\n{\n\tunion {\n\t\tu64 wwn;\n\t\tu8 byte[8];\n\t} w;\n\n\tw.wwn = wwn;\n\tsprintf(wwn_str, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", w.byte[0],\n\t\tw.byte[1], w.byte[2], w.byte[3], w.byte[4], w.byte[5],\n\t\tw.byte[6], w.byte[7]);\n}\n\nstatic inline void\nfcid2str(char *fcid_str, u32 fcid)\n{\n\tunion {\n\t\tu32 fcid;\n\t\tu8 byte[4];\n\t} f;\n\n\tf.fcid = fcid;\n\tsprintf(fcid_str, \"%02x:%02x:%02x\", f.byte[1], f.byte[2], f.byte[3]);\n}\n\n#define bfa_swap_3b(_x)\t\t\t\t\\\n\t((((_x) & 0xff) << 16) |\t\t\\\n\t((_x) & 0x00ff00) |\t\t\t\\\n\t(((_x) & 0xff0000) >> 16))\n\n#ifndef __BIG_ENDIAN\n#define bfa_hton3b(_x)  bfa_swap_3b(_x)\n#else\n#define bfa_hton3b(_x)  (_x)\n#endif\n\n#define bfa_ntoh3b(_x)  bfa_hton3b(_x)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}