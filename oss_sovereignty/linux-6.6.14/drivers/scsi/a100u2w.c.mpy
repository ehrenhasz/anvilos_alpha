{
  "module_name": "a100u2w.c",
  "hash_id": "2670fa648bc05f942feca7753a3827f40dc7a9fb56eb1cee79f9e5c5e74a488a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/a100u2w.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ioport.h>\n#include <linux/dma-mapping.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n#include \"a100u2w.h\"\n\n\nstatic struct orc_scb *__orc_alloc_scb(struct orc_host * host);\nstatic void inia100_scb_handler(struct orc_host *host, struct orc_scb *scb);\n\nstatic struct orc_nvram nvram, *nvramp = &nvram;\n\nstatic u8 default_nvram[64] =\n{\n \n\t0x01,\t\t\t \n\t0x11,\t\t\t \n\t0x60,\t\t\t \n\t0x10,\t\t\t \n\t0x00,\t\t\t \n\t0x01,\t\t\t \n\t0x11,\t\t\t \n\t0x60,\t\t\t \n\t0x10,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x01,\t\t\t \n\t\t\t\t \n\t0x01,\t\t\t \n\t0x01,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t\t\t\t \n\t0x07,\t\t\t \n\t0x83,\t\t\t \n\t0x20,\t\t\t \n\t0x0A,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8,\n\t0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8,\n\t\t\t\t \n\t0x07,\t\t\t \n\t0x83,\t\t\t \n\t0x20,\t\t\t \n\t0x0A,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8,\n\t0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8,\n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00\t\t\t \n};\n\n\nstatic u8 wait_chip_ready(struct orc_host * host)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\t \n\t\tif (inb(host->base + ORC_HCTRL) & HOSTSTOP)\t \n\t\t\treturn 1;\n\t\tmsleep(100);\n\t}\n\treturn 0;\n}\n\nstatic u8 wait_firmware_ready(struct orc_host * host)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\t \n\t\tif (inb(host->base + ORC_HSTUS) & RREADY)\t\t \n\t\t\treturn 1;\n\t\tmsleep(100);\t \n\t}\n\treturn 0;\n}\n\n \nstatic u8 wait_scsi_reset_done(struct orc_host * host)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\t \n\t\tif (!(inb(host->base + ORC_HCTRL) & SCSIRST))\t \n\t\t\treturn 1;\n\t\tmdelay(100);\t \n\t}\n\treturn 0;\n}\n\n \nstatic u8 wait_HDO_off(struct orc_host * host)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\t \n\t\tif (!(inb(host->base + ORC_HCTRL) & HDO))\t\t \n\t\t\treturn 1;\n\t\tmdelay(100);\t \n\t}\n\treturn 0;\n}\n\n \nstatic u8 wait_hdi_set(struct orc_host * host, u8 * data)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\t \n\t\tif ((*data = inb(host->base + ORC_HSTUS)) & HDI)\n\t\t\treturn 1;\t \n\t\tmdelay(100);\t \n\t}\n\treturn 0;\n}\n\n \nstatic unsigned short orc_read_fwrev(struct orc_host * host)\n{\n\tu16 version;\n\tu8 data;\n\n\toutb(ORC_CMD_VERSION, host->base + ORC_HDATA);\n\toutb(HDO, host->base + ORC_HCTRL);\n\tif (wait_HDO_off(host) == 0)\t \n\t\treturn 0;\n\n\tif (wait_hdi_set(host, &data) == 0)\t \n\t\treturn 0;\n\tversion = inb(host->base + ORC_HDATA);\n\toutb(data, host->base + ORC_HSTUS);\t \n\n\tif (wait_hdi_set(host, &data) == 0)\t \n\t\treturn 0;\n\tversion |= inb(host->base + ORC_HDATA) << 8;\n\toutb(data, host->base + ORC_HSTUS);\t \n\n\treturn version;\n}\n\n \nstatic u8 orc_nv_write(struct orc_host * host, unsigned char address, unsigned char value)\n{\n\toutb(ORC_CMD_SET_NVM, host->base + ORC_HDATA);\t \n\toutb(HDO, host->base + ORC_HCTRL);\n\tif (wait_HDO_off(host) == 0)\t \n\t\treturn 0;\n\n\toutb(address, host->base + ORC_HDATA);\t \n\toutb(HDO, host->base + ORC_HCTRL);\n\tif (wait_HDO_off(host) == 0)\t \n\t\treturn 0;\n\n\toutb(value, host->base + ORC_HDATA);\t \n\toutb(HDO, host->base + ORC_HCTRL);\n\tif (wait_HDO_off(host) == 0)\t \n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic u8 orc_nv_read(struct orc_host * host, u8 address, u8 *ptr)\n{\n\tunsigned char data;\n\n\toutb(ORC_CMD_GET_NVM, host->base + ORC_HDATA);\t \n\toutb(HDO, host->base + ORC_HCTRL);\n\tif (wait_HDO_off(host) == 0)\t \n\t\treturn 0;\n\n\toutb(address, host->base + ORC_HDATA);\t \n\toutb(HDO, host->base + ORC_HCTRL);\n\tif (wait_HDO_off(host) == 0)\t \n\t\treturn 0;\n\n\tif (wait_hdi_set(host, &data) == 0)\t \n\t\treturn 0;\n\t*ptr = inb(host->base + ORC_HDATA);\n\toutb(data, host->base + ORC_HSTUS);\t \n\n\treturn 1;\n\n}\n\n \n\nstatic void orc_exec_scb(struct orc_host * host, struct orc_scb * scb)\n{\n\tscb->status = ORCSCB_POST;\n\toutb(scb->scbidx, host->base + ORC_PQUEUE);\n}\n\n\n \n\nstatic int se2_rd_all(struct orc_host * host)\n{\n\tint i;\n\tu8 *np, chksum = 0;\n\n\tnp = (u8 *) nvramp;\n\tfor (i = 0; i < 64; i++, np++) {\t \n\t\tif (orc_nv_read(host, (u8) i, np) == 0)\n\t\t\treturn -1;\n\t}\n\n\t \n\tnp = (u8 *) nvramp;\n\tfor (i = 0; i < 63; i++)\n\t\tchksum += *np++;\n\n\tif (nvramp->CheckSum != (u8) chksum)\n\t\treturn -1;\n\treturn 1;\n}\n\n \n\nstatic void se2_update_all(struct orc_host * host)\n{\t\t\t\t \n\tint i;\n\tu8 *np, *np1, chksum = 0;\n\n\t \n\tnp = (u8 *) default_nvram;\n\tfor (i = 0; i < 63; i++)\n\t\tchksum += *np++;\n\t*np = chksum;\n\n\tnp = (u8 *) default_nvram;\n\tnp1 = (u8 *) nvramp;\n\tfor (i = 0; i < 64; i++, np++, np1++) {\n\t\tif (*np != *np1)\n\t\t\torc_nv_write(host, (u8) i, *np);\n\t}\n}\n\n \n\nstatic void read_eeprom(struct orc_host * host)\n{\n\tif (se2_rd_all(host) != 1) {\n\t\tse2_update_all(host);\t \n\t\tse2_rd_all(host);\t \n\t}\n}\n\n\n \n\nstatic u8 orc_load_firmware(struct orc_host * host)\n{\n\tu32 data32;\n\tu16 bios_addr;\n\tu16 i;\n\tu8 *data32_ptr, data;\n\n\n\t \n\n\tdata = inb(host->base + ORC_GCFG);\n\toutb(data | EEPRG, host->base + ORC_GCFG);\t \n\toutb(0x00, host->base + ORC_EBIOSADR2);\n\toutw(0x0000, host->base + ORC_EBIOSADR0);\n\tif (inb(host->base + ORC_EBIOSDATA) != 0x55) {\n\t\toutb(data, host->base + ORC_GCFG);\t \n\t\treturn 0;\n\t}\n\toutw(0x0001, host->base + ORC_EBIOSADR0);\n\tif (inb(host->base + ORC_EBIOSDATA) != 0xAA) {\n\t\toutb(data, host->base + ORC_GCFG);\t \n\t\treturn 0;\n\t}\n\n\toutb(PRGMRST | DOWNLOAD, host->base + ORC_RISCCTL);\t \n\tdata32_ptr = (u8 *) & data32;\n\tdata32 = cpu_to_le32(0);\t\t \n\toutw(0x0010, host->base + ORC_EBIOSADR0);\n\t*data32_ptr = inb(host->base + ORC_EBIOSDATA);\t\t \n\toutw(0x0011, host->base + ORC_EBIOSADR0);\n\t*(data32_ptr + 1) = inb(host->base + ORC_EBIOSDATA);\t \n\toutw(0x0012, host->base + ORC_EBIOSADR0);\n\t*(data32_ptr + 2) = inb(host->base + ORC_EBIOSDATA);\t \n\toutw(*(data32_ptr + 2), host->base + ORC_EBIOSADR2);\n\toutl(le32_to_cpu(data32), host->base + ORC_FWBASEADR);\t\t \n\n\t \n\n\tudelay(500);\t \n\tbios_addr = (u16) le32_to_cpu(data32);\t \n\tfor (i = 0, data32_ptr = (u8 *) & data32;\t \n\t     i < 0x1000;\t \n\t     i++, bios_addr++) {\n\t\toutw(bios_addr, host->base + ORC_EBIOSADR0);\n\t\t*data32_ptr++ = inb(host->base + ORC_EBIOSDATA);\t \n\t\tif ((i % 4) == 3) {\n\t\t\toutl(le32_to_cpu(data32), host->base + ORC_RISCRAM);\t \n\t\t\tdata32_ptr = (u8 *) & data32;\n\t\t}\n\t}\n\n\t \n\n\toutb(PRGMRST | DOWNLOAD, host->base + ORC_RISCCTL);\t \n\tbios_addr -= 0x1000;\t \n\tfor (i = 0, data32_ptr = (u8 *) & data32;\t \n\t     i < 0x1000;\t \n\t     i++, bios_addr++) {\n\t\toutw(bios_addr, host->base + ORC_EBIOSADR0);\n\t\t*data32_ptr++ = inb(host->base + ORC_EBIOSDATA);\t \n\t\tif ((i % 4) == 3) {\n\t\t\tif (inl(host->base + ORC_RISCRAM) != le32_to_cpu(data32)) {\n\t\t\t\toutb(PRGMRST, host->base + ORC_RISCCTL);\t \n\t\t\t\toutb(data, host->base + ORC_GCFG);\t \n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdata32_ptr = (u8 *) & data32;\n\t\t}\n\t}\n\n\t \n\toutb(PRGMRST, host->base + ORC_RISCCTL);\t \n\toutb(data, host->base + ORC_GCFG);\t \n\treturn 1;\n}\n\n \nstatic void setup_SCBs(struct orc_host * host)\n{\n\tstruct orc_scb *scb;\n\tint i;\n\tstruct orc_extended_scb *escb;\n\tdma_addr_t escb_phys;\n\n\t \n\toutb(ORC_MAXQUEUE, host->base + ORC_SCBSIZE);\t \n\t \n\toutl(host->scb_phys, host->base + ORC_SCBBASE0);\n\t \n\toutl(host->scb_phys, host->base + ORC_SCBBASE1);\n\n\t \n\tscb = host->scb_virt;\n\tescb = host->escb_virt;\n\n\tfor (i = 0; i < ORC_MAXQUEUE; i++) {\n\t\tescb_phys = (host->escb_phys + (sizeof(struct orc_extended_scb) * i));\n\t\tscb->sg_addr = cpu_to_le32((u32) escb_phys);\n\t\tscb->sense_addr = cpu_to_le32((u32) escb_phys);\n\t\tscb->escb = escb;\n\t\tscb->scbidx = i;\n\t\tscb++;\n\t\tescb++;\n\t}\n}\n\n \n\nstatic void init_alloc_map(struct orc_host * host)\n{\n\tu8 i, j;\n\n\tfor (i = 0; i < MAX_CHANNELS; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\thost->allocation_map[i][j] = 0xffffffff;\n\t\t}\n\t}\n}\n\n \n\nstatic int init_orchid(struct orc_host * host)\n{\n\tu8 *ptr;\n\tu16 revision;\n\tu8 i;\n\n\tinit_alloc_map(host);\n\toutb(0xFF, host->base + ORC_GIMSK);\t \n\n\tif (inb(host->base + ORC_HSTUS) & RREADY) {\t \n\t\trevision = orc_read_fwrev(host);\n\t\tif (revision == 0xFFFF) {\n\t\t\toutb(DEVRST, host->base + ORC_HCTRL);\t \n\t\t\tif (wait_chip_ready(host) == 0)\n\t\t\t\treturn -1;\n\t\t\torc_load_firmware(host);\t \n\t\t\tsetup_SCBs(host);\t \n\t\t\toutb(0x00, host->base + ORC_HCTRL);\t \n\t\t\tif (wait_firmware_ready(host) == 0)\n\t\t\t\treturn -1;\n\t\t\t \n\t\t} else {\n\t\t\tsetup_SCBs(host);\t \n\t\t}\n\t} else {\t\t \n\t\toutb(DEVRST, host->base + ORC_HCTRL);\t \n\t\tif (wait_chip_ready(host) == 0)\n\t\t\treturn -1;\n\t\torc_load_firmware(host);\t \n\t\tsetup_SCBs(host);\t \n\t\toutb(HDO, host->base + ORC_HCTRL);\t \n\n\t\t \n\t\tif (wait_firmware_ready(host) == 0)\t\t \n\t\t\treturn -1;\n\t}\n\n\t \n\t \n\tread_eeprom(host);\n\n\tif (nvramp->revision != 1)\n\t\treturn -1;\n\n\thost->scsi_id = nvramp->scsi_id;\n\thost->BIOScfg = nvramp->BIOSConfig1;\n\thost->max_targets = MAX_TARGETS;\n\tptr = (u8 *) & (nvramp->Target00Config);\n\tfor (i = 0; i < 16; ptr++, i++) {\n\t\thost->target_flag[i] = *ptr;\n\t\thost->max_tags[i] = ORC_MAXTAGS;\n\t}\n\n\tif (nvramp->SCSI0Config & NCC_BUSRESET)\n\t\thost->flags |= HCF_SCSI_RESET;\n\toutb(0xFB, host->base + ORC_GIMSK);\t \n\treturn 0;\n}\n\n \n\nstatic int orc_reset_scsi_bus(struct orc_host * host)\n{\t\t\t\t \n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->allocation_lock, flags);\n\n\tinit_alloc_map(host);\n\t \n\toutb(SCSIRST, host->base + ORC_HCTRL);\n\t \n\tif (wait_scsi_reset_done(host) == 0) {\n\t\tspin_unlock_irqrestore(&host->allocation_lock, flags);\n\t\treturn FAILED;\n\t} else {\n\t\tspin_unlock_irqrestore(&host->allocation_lock, flags);\n\t\treturn SUCCESS;\n\t}\n}\n\n \n\nstatic int orc_device_reset(struct orc_host * host, struct scsi_cmnd *cmd, unsigned int target)\n{\t\t\t\t \n\tstruct orc_scb *scb;\n\tstruct orc_extended_scb *escb;\n\tstruct orc_scb *host_scb;\n\tu8 i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&(host->allocation_lock), flags);\n\tscb = (struct orc_scb *) NULL;\n\tescb = (struct orc_extended_scb *) NULL;\n\n\t \n\thost_scb = host->scb_virt;\n\n\t \n\tinit_alloc_map(host);\n\n\t \n\tfor (i = 0; i < ORC_MAXQUEUE; i++) {\n\t\tescb = host_scb->escb;\n\t\tif (host_scb->status && escb->srb == cmd)\n\t\t\tbreak;\n\t\thost_scb++;\n\t}\n\n\tif (i == ORC_MAXQUEUE) {\n\t\tprintk(KERN_ERR \"Unable to Reset - No SCB Found\\n\");\n\t\tspin_unlock_irqrestore(&(host->allocation_lock), flags);\n\t\treturn FAILED;\n\t}\n\n\t \n\tif ((scb = __orc_alloc_scb(host)) == NULL) {\n\t\t \n\t\tspin_unlock_irqrestore(&(host->allocation_lock), flags);\n\t\treturn FAILED;\n\t}\n\n\t \n\tscb->opcode = ORC_BUSDEVRST;\n\tscb->target = target;\n\tscb->hastat = 0;\n\tscb->tastat = 0;\n\tscb->status = 0x0;\n\tscb->link = 0xFF;\n\tscb->reserved0 = 0;\n\tscb->reserved1 = 0;\n\tscb->xferlen = cpu_to_le32(0);\n\tscb->sg_len = cpu_to_le32(0);\n\n\tescb->srb = NULL;\n\tescb->srb = cmd;\n\torc_exec_scb(host, scb);\t \n\tspin_unlock_irqrestore(&host->allocation_lock, flags);\n\treturn SUCCESS;\n}\n\n \n\n\nstatic struct orc_scb *__orc_alloc_scb(struct orc_host * host)\n{\n\tu8 channel;\n\tunsigned long idx;\n\tu8 index;\n\tu8 i;\n\n\tchannel = host->index;\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (index = 0; index < 32; index++) {\n\t\t\tif ((host->allocation_map[channel][i] >> index) & 0x01) {\n\t\t\t\thost->allocation_map[channel][i] &= ~(1 << index);\n\t\t\t\tidx = index + 32 * i;\n\t\t\t\t \n\t\t\t\treturn host->scb_virt + idx;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \n\nstatic struct orc_scb *orc_alloc_scb(struct orc_host * host)\n{\n\tstruct orc_scb *scb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->allocation_lock, flags);\n\tscb = __orc_alloc_scb(host);\n\tspin_unlock_irqrestore(&host->allocation_lock, flags);\n\treturn scb;\n}\n\n \n\nstatic void orc_release_scb(struct orc_host *host, struct orc_scb *scb)\n{\n\tunsigned long flags;\n\tu8 index, i, channel;\n\n\tspin_lock_irqsave(&(host->allocation_lock), flags);\n\tchannel = host->index;\t \n\tindex = scb->scbidx;\n\ti = index / 32;\n\tindex %= 32;\n\thost->allocation_map[channel][i] |= (1 << index);\n\tspin_unlock_irqrestore(&(host->allocation_lock), flags);\n}\n\n \n\nstatic int orchid_abort_scb(struct orc_host * host, struct orc_scb * scb)\n{\n\tunsigned char data, status;\n\n\toutb(ORC_CMD_ABORT_SCB, host->base + ORC_HDATA);\t \n\toutb(HDO, host->base + ORC_HCTRL);\n\tif (wait_HDO_off(host) == 0)\t \n\t\treturn 0;\n\n\toutb(scb->scbidx, host->base + ORC_HDATA);\t \n\toutb(HDO, host->base + ORC_HCTRL);\n\tif (wait_HDO_off(host) == 0)\t \n\t\treturn 0;\n\n\tif (wait_hdi_set(host, &data) == 0)\t \n\t\treturn 0;\n\tstatus = inb(host->base + ORC_HDATA);\n\toutb(data, host->base + ORC_HSTUS);\t \n\n\tif (status == 1)\t \n\t\treturn 0;\t \n\treturn 1;\n}\n\nstatic int inia100_abort_cmd(struct orc_host * host, struct scsi_cmnd *cmd)\n{\n\tstruct orc_extended_scb *escb;\n\tstruct orc_scb *scb;\n\tu8 i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&(host->allocation_lock), flags);\n\n\tscb = host->scb_virt;\n\n\t \n\n\tfor (i = 0; i < ORC_MAXQUEUE; i++, scb++) {\n\t\tescb = scb->escb;\n\t\tif (scb->status && escb->srb == cmd) {\n\t\t\tif (scb->tag_msg == 0) {\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (orchid_abort_scb(host, scb)) {\n\t\t\t\t\tescb->srb = NULL;\n\t\t\t\t\tspin_unlock_irqrestore(&host->allocation_lock, flags);\n\t\t\t\t\treturn SUCCESS;\n\t\t\t\t} else\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock_irqrestore(&host->allocation_lock, flags);\n\treturn FAILED;\n}\n\n \n\nstatic irqreturn_t orc_interrupt(struct orc_host * host)\n{\n\tu8 scb_index;\n\tstruct orc_scb *scb;\n\n\t \n\tif (inb(host->base + ORC_RQUEUECNT) == 0)\n\t\treturn IRQ_NONE;\n\n\tdo {\n\t\t \n\t\tscb_index = inb(host->base + ORC_RQUEUE);\n\n\t\t \n\t\tscb = (struct orc_scb *) ((unsigned long) host->scb_virt + (unsigned long) (sizeof(struct orc_scb) * scb_index));\n\t\tscb->status = 0x0;\n\t\t \n\t\tinia100_scb_handler(host, scb);\n\t} while (inb(host->base + ORC_RQUEUECNT));\n\treturn IRQ_HANDLED;\n}\t\t\t\t \n\n \n\nstatic int inia100_build_scb(struct orc_host * host, struct orc_scb * scb, struct scsi_cmnd * cmd)\n{\t\t\t\t \n\tstruct scatterlist *sg;\n\tstruct orc_sgent *sgent;\t\t \n\tint i, count_sg;\n\tstruct orc_extended_scb *escb;\n\n\t \n\tescb = scb->escb;\n\tescb->srb = cmd;\n\tsgent = NULL;\n\n\t \n\tscb->opcode = ORC_EXECSCSI;\n\tscb->flags = SCF_NO_DCHK;\t \n\tscb->target = cmd->device->id;\n\tscb->lun = cmd->device->lun;\n\tscb->reserved0 = 0;\n\tscb->reserved1 = 0;\n\tscb->sg_len = cpu_to_le32(0);\n\n\tscb->xferlen = cpu_to_le32((u32) scsi_bufflen(cmd));\n\tsgent = (struct orc_sgent *) & escb->sglist[0];\n\n\tcount_sg = scsi_dma_map(cmd);\n\tif (count_sg < 0)\n\t\treturn count_sg;\n\tBUG_ON(count_sg > TOTAL_SG_ENTRY);\n\n\t \n\tif (count_sg) {\n\t\tscb->sg_len = cpu_to_le32((u32) (count_sg * 8));\n\t\tscsi_for_each_sg(cmd, sg, count_sg, i) {\n\t\t\tsgent->base = cpu_to_le32((u32) sg_dma_address(sg));\n\t\t\tsgent->length = cpu_to_le32((u32) sg_dma_len(sg));\n\t\t\tsgent++;\n\t\t}\n\t} else {\n\t\tscb->sg_len = cpu_to_le32(0);\n\t\tsgent->base = cpu_to_le32(0);\n\t\tsgent->length = cpu_to_le32(0);\n\t}\n\tscb->sg_addr = (u32) scb->sense_addr;\t \n\tscb->hastat = 0;\n\tscb->tastat = 0;\n\tscb->link = 0xFF;\n\tscb->sense_len = SENSE_SIZE;\n\tscb->cdb_len = cmd->cmd_len;\n\tif (scb->cdb_len >= IMAX_CDB) {\n\t\tprintk(\"max cdb length= %x\\n\", cmd->cmd_len);\n\t\tscb->cdb_len = IMAX_CDB;\n\t}\n\tscb->ident = (u8)(cmd->device->lun & 0xff) | DISC_ALLOW;\n\tif (cmd->device->tagged_supported) {\t \n\t\tscb->tag_msg = SIMPLE_QUEUE_TAG;\t \n\t} else {\n\t\tscb->tag_msg = 0;\t \n\t}\n\tmemcpy(scb->cdb, cmd->cmnd, scb->cdb_len);\n\treturn 0;\n}\n\n \nstatic int inia100_queue_lck(struct scsi_cmnd *cmd)\n{\n\tstruct orc_scb *scb;\n\tstruct orc_host *host;\t\t \n\n\thost = (struct orc_host *) cmd->device->host->hostdata;\n\t \n\tif ((scb = orc_alloc_scb(host)) == NULL)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (inia100_build_scb(host, scb, cmd)) {\n\t\torc_release_scb(host, scb);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\torc_exec_scb(host, scb);\t \n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(inia100_queue)\n\n \nstatic int inia100_abort(struct scsi_cmnd * cmd)\n{\n\tstruct orc_host *host;\n\n\thost = (struct orc_host *) cmd->device->host->hostdata;\n\treturn inia100_abort_cmd(host, cmd);\n}\n\n \nstatic int inia100_bus_reset(struct scsi_cmnd * cmd)\n{\t\t\t\t \n\tstruct orc_host *host;\n\thost = (struct orc_host *) cmd->device->host->hostdata;\n\treturn orc_reset_scsi_bus(host);\n}\n\n \nstatic int inia100_device_reset(struct scsi_cmnd * cmd)\n{\t\t\t\t \n\tstruct orc_host *host;\n\thost = (struct orc_host *) cmd->device->host->hostdata;\n\treturn orc_device_reset(host, cmd, scmd_id(cmd));\n\n}\n\n \n\nstatic void inia100_scb_handler(struct orc_host *host, struct orc_scb *scb)\n{\n\tstruct scsi_cmnd *cmd;\t \n\tstruct orc_extended_scb *escb;\n\n\tescb = scb->escb;\n\tif ((cmd = (struct scsi_cmnd *) escb->srb) == NULL) {\n\t\tprintk(KERN_ERR \"inia100_scb_handler: SRB pointer is empty\\n\");\n\t\torc_release_scb(host, scb);\t \n\t\treturn;\n\t}\n\tescb->srb = NULL;\n\n\tswitch (scb->hastat) {\n\tcase 0x0:\n\tcase 0xa:\t\t \n\tcase 0xb:\t\t \n\t\tscb->hastat = 0;\n\t\tbreak;\n\n\tcase 0x11:\t\t \n\t\tscb->hastat = DID_TIME_OUT;\n\t\tbreak;\n\n\tcase 0x14:\t\t \n\t\tscb->hastat = DID_RESET;\n\t\tbreak;\n\n\tcase 0x1a:\t\t \n\t\tscb->hastat = DID_ABORT;\n\t\tbreak;\n\n\tcase 0x12:\t\t \n\tcase 0x13:\t\t \n\tcase 0x16:\t\t \n\n\tdefault:\n\t\tprintk(KERN_DEBUG \"inia100: %x %x\\n\", scb->hastat, scb->tastat);\n\t\tscb->hastat = DID_ERROR;\t \n\t\tbreak;\n\t}\n\n\tif (scb->tastat == 2) {\t \n\t\tmemcpy((unsigned char *) &cmd->sense_buffer[0],\n\t\t   (unsigned char *) &escb->sglist[0], SENSE_SIZE);\n\t}\n\tcmd->result = scb->tastat | (scb->hastat << 16);\n\tscsi_dma_unmap(cmd);\n\tscsi_done(cmd);\t\t \n\torc_release_scb(host, scb);\t \n}\n\n \nstatic irqreturn_t inia100_intr(int irqno, void *devid)\n{\n\tstruct Scsi_Host *shost = (struct Scsi_Host *)devid;\n\tstruct orc_host *host = (struct orc_host *)shost->hostdata;\n\tunsigned long flags;\n\tirqreturn_t res;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tres = orc_interrupt(host);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn res;\n}\n\nstatic const struct scsi_host_template inia100_template = {\n\t.proc_name\t\t= \"inia100\",\n\t.name\t\t\t= inia100_REVID,\n\t.queuecommand\t\t= inia100_queue,\n\t.eh_abort_handler\t= inia100_abort,\n\t.eh_bus_reset_handler\t= inia100_bus_reset,\n\t.eh_device_reset_handler = inia100_device_reset,\n\t.can_queue\t\t= 1,\n\t.this_id\t\t= 1,\n\t.sg_tablesize\t\t= SG_ALL,\n};\n\nstatic int inia100_probe_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tstruct Scsi_Host *shost;\n\tstruct orc_host *host;\n\tunsigned long port, bios;\n\tint error = -ENODEV;\n\tu32 sz;\n\n\tif (pci_enable_device(pdev))\n\t\tgoto out;\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tprintk(KERN_WARNING \"Unable to set 32bit DMA \"\n\t\t\t\t    \"on inia100 adapter, ignoring.\\n\");\n\t\tgoto out_disable_device;\n\t}\n\n\tpci_set_master(pdev);\n\n\tport = pci_resource_start(pdev, 0);\n\tif (!request_region(port, 256, \"inia100\")) {\n\t\tprintk(KERN_WARNING \"inia100: io port 0x%lx, is busy.\\n\", port);\n\t\tgoto out_disable_device;\n\t}\n\n\t \n\tbios = inw(port + 0x50);\n\n\n\tshost = scsi_host_alloc(&inia100_template, sizeof(struct orc_host));\n\tif (!shost)\n\t\tgoto out_release_region;\n\n\thost = (struct orc_host *)shost->hostdata;\n\thost->pdev = pdev;\n\thost->base = port;\n\thost->BIOScfg = bios;\n\tspin_lock_init(&host->allocation_lock);\n\n\t \n\tsz = ORC_MAXQUEUE * sizeof(struct orc_scb);\n\thost->scb_virt = dma_alloc_coherent(&pdev->dev, sz, &host->scb_phys,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!host->scb_virt) {\n\t\tprintk(\"inia100: SCB memory allocation error\\n\");\n\t\tgoto out_host_put;\n\t}\n\n\t \n\tsz = ORC_MAXQUEUE * sizeof(struct orc_extended_scb);\n\thost->escb_virt = dma_alloc_coherent(&pdev->dev, sz, &host->escb_phys,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!host->escb_virt) {\n\t\tprintk(\"inia100: ESCB memory allocation error\\n\");\n\t\tgoto out_free_scb_array;\n\t}\n\n\tif (init_orchid(host)) {\t \n\t\tprintk(\"inia100: initial orchid fail!!\\n\");\n\t\tgoto out_free_escb_array;\n\t}\n\n\tshost->io_port = host->base;\n\tshost->n_io_port = 0xff;\n\tshost->can_queue = ORC_MAXQUEUE;\n\tshost->unique_id = shost->io_port;\n\tshost->max_id = host->max_targets;\n\tshost->max_lun = 16;\n\tshost->irq = pdev->irq;\n\tshost->this_id = host->scsi_id;\t \n\tshost->sg_tablesize = TOTAL_SG_ENTRY;\n\n\t \n\terror = request_irq(pdev->irq, inia100_intr, IRQF_SHARED,\n\t\t\t\"inia100\", shost);\n\tif (error < 0) {\n\t\tprintk(KERN_WARNING \"inia100: unable to get irq %d\\n\",\n\t\t\t\tpdev->irq);\n\t\tgoto out_free_escb_array;\n\t}\n\n\tpci_set_drvdata(pdev, shost);\n\n\terror = scsi_add_host(shost, &pdev->dev);\n\tif (error)\n\t\tgoto out_free_irq;\n\n\tscsi_scan_host(shost);\n\treturn 0;\n\nout_free_irq:\n        free_irq(shost->irq, shost);\nout_free_escb_array:\n\tdma_free_coherent(&pdev->dev,\n\t\t\tORC_MAXQUEUE * sizeof(struct orc_extended_scb),\n\t\t\thost->escb_virt, host->escb_phys);\nout_free_scb_array:\n\tdma_free_coherent(&pdev->dev,\n\t\t\tORC_MAXQUEUE * sizeof(struct orc_scb),\n\t\t\thost->scb_virt, host->scb_phys);\nout_host_put:\n\tscsi_host_put(shost);\nout_release_region:\n        release_region(port, 256);\nout_disable_device:\n\tpci_disable_device(pdev);\nout:\n\treturn error;\n}\n\nstatic void inia100_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct orc_host *host = (struct orc_host *)shost->hostdata;\n\n\tscsi_remove_host(shost);\n\n        free_irq(shost->irq, shost);\n\tdma_free_coherent(&pdev->dev,\n\t\t\tORC_MAXQUEUE * sizeof(struct orc_extended_scb),\n\t\t\thost->escb_virt, host->escb_phys);\n\tdma_free_coherent(&pdev->dev,\n\t\t\tORC_MAXQUEUE * sizeof(struct orc_scb),\n\t\t\thost->scb_virt, host->scb_phys);\n        release_region(shost->io_port, 256);\n\n\tscsi_host_put(shost);\n} \n\nstatic struct pci_device_id inia100_pci_tbl[] = {\n\t{PCI_VENDOR_ID_INIT, 0x1060, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, inia100_pci_tbl);\n\nstatic struct pci_driver inia100_pci_driver = {\n\t.name\t\t= \"inia100\",\n\t.id_table\t= inia100_pci_tbl,\n\t.probe\t\t= inia100_probe_one,\n\t.remove\t\t= inia100_remove_one,\n};\n\nmodule_pci_driver(inia100_pci_driver);\n\nMODULE_DESCRIPTION(\"Initio A100U2W SCSI driver\");\nMODULE_AUTHOR(\"Initio Corporation\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}