{
  "module_name": "mv_64xx.c",
  "hash_id": "3c3b8678421a4e950dbe9ad69b0385a54bc8cdc94b8475d0768cff6d75f607d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mvsas/mv_64xx.c",
  "human_readable_source": "\n \n\n#include \"mv_sas.h\"\n#include \"mv_64xx.h\"\n#include \"mv_chips.h\"\n\nstatic void mvs_64xx_detect_porttype(struct mvs_info *mvi, int i)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 reg;\n\tstruct mvs_phy *phy = &mvi->phy[i];\n\n\treg = mr32(MVS_GBL_PORT_TYPE);\n\tphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\n\tif (reg & MODE_SAS_SATA & (1 << i))\n\t\tphy->phy_type |= PORT_TYPE_SAS;\n\telse\n\t\tphy->phy_type |= PORT_TYPE_SATA;\n}\n\nstatic void mvs_64xx_enable_xmt(struct mvs_info *mvi, int phy_id)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\n\ttmp = mr32(MVS_PCS);\n\tif (mvi->chip->n_phy <= MVS_SOC_PORTS)\n\t\ttmp |= 1 << (phy_id + PCS_EN_PORT_XMT_SHIFT);\n\telse\n\t\ttmp |= 1 << (phy_id + PCS_EN_PORT_XMT_SHIFT2);\n\tmw32(MVS_PCS, tmp);\n}\n\nstatic void mvs_64xx_phy_hacks(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tint i;\n\n\tmvs_phy_hacks(mvi);\n\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\tfor (i = 0; i < MVS_SOC_PORTS; i++) {\n\t\t\tmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE8);\n\t\t\tmvs_write_port_vsr_data(mvi, i, 0x2F0);\n\t\t}\n\t} else {\n\t\t \n\t\tmw32(MVS_GBL_PORT_TYPE, 0);\n\t\tfor (i = 0; i < mvi->chip->n_phy; i++) {\n\t\t\tmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE7);\n\t\t\tmvs_write_port_vsr_data(mvi, i, 0x90000000);\n\t\t\tmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE9);\n\t\t\tmvs_write_port_vsr_data(mvi, i, 0x50f2);\n\t\t\tmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE11);\n\t\t\tmvs_write_port_vsr_data(mvi, i, 0x0e);\n\t\t}\n\t}\n}\n\nstatic void mvs_64xx_stp_reset(struct mvs_info *mvi, u32 phy_id)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 reg, tmp;\n\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\tif (phy_id < MVS_SOC_PORTS)\n\t\t\tpci_read_config_dword(mvi->pdev, PCR_PHY_CTL, &reg);\n\t\telse\n\t\t\tpci_read_config_dword(mvi->pdev, PCR_PHY_CTL2, &reg);\n\n\t} else\n\t\treg = mr32(MVS_PHY_CTL);\n\n\ttmp = reg;\n\tif (phy_id < MVS_SOC_PORTS)\n\t\ttmp |= (1U << phy_id) << PCTL_LINK_OFFS;\n\telse\n\t\ttmp |= (1U << (phy_id - MVS_SOC_PORTS)) << PCTL_LINK_OFFS;\n\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\tif (phy_id < MVS_SOC_PORTS) {\n\t\t\tpci_write_config_dword(mvi->pdev, PCR_PHY_CTL, tmp);\n\t\t\tmdelay(10);\n\t\t\tpci_write_config_dword(mvi->pdev, PCR_PHY_CTL, reg);\n\t\t} else {\n\t\t\tpci_write_config_dword(mvi->pdev, PCR_PHY_CTL2, tmp);\n\t\t\tmdelay(10);\n\t\t\tpci_write_config_dword(mvi->pdev, PCR_PHY_CTL2, reg);\n\t\t}\n\t} else {\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t\tmdelay(10);\n\t\tmw32(MVS_PHY_CTL, reg);\n\t}\n}\n\nstatic void mvs_64xx_phy_reset(struct mvs_info *mvi, u32 phy_id, int hard)\n{\n\tu32 tmp;\n\ttmp = mvs_read_port_irq_stat(mvi, phy_id);\n\ttmp &= ~PHYEV_RDY_CH;\n\tmvs_write_port_irq_stat(mvi, phy_id, tmp);\n\ttmp = mvs_read_phy_ctl(mvi, phy_id);\n\tif (hard == MVS_HARD_RESET)\n\t\ttmp |= PHY_RST_HARD;\n\telse if (hard == MVS_SOFT_RESET)\n\t\ttmp |= PHY_RST;\n\tmvs_write_phy_ctl(mvi, phy_id, tmp);\n\tif (hard) {\n\t\tdo {\n\t\t\ttmp = mvs_read_phy_ctl(mvi, phy_id);\n\t\t} while (tmp & PHY_RST_HARD);\n\t}\n}\n\nstatic void\nmvs_64xx_clear_srs_irq(struct mvs_info *mvi, u8 reg_set, u8 clear_all)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\tif (clear_all) {\n\t\ttmp = mr32(MVS_INT_STAT_SRS_0);\n\t\tif (tmp) {\n\t\t\tprintk(KERN_DEBUG \"check SRS 0 %08X.\\n\", tmp);\n\t\t\tmw32(MVS_INT_STAT_SRS_0, tmp);\n\t\t}\n\t} else {\n\t\ttmp = mr32(MVS_INT_STAT_SRS_0);\n\t\tif (tmp &  (1 << (reg_set % 32))) {\n\t\t\tprintk(KERN_DEBUG \"register set 0x%x was stopped.\\n\",\n\t\t\t       reg_set);\n\t\t\tmw32(MVS_INT_STAT_SRS_0, 1 << (reg_set % 32));\n\t\t}\n\t}\n}\n\nstatic int mvs_64xx_chip_reset(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\tint i;\n\n\t \n\tmw32(MVS_GBL_CTL, 0);\n\ttmp = mr32(MVS_GBL_CTL);\n\n\t \n\tif (!(tmp & HBA_RST)) {\n\t\tif (mvi->flags & MVF_PHY_PWR_FIX) {\n\t\t\tpci_read_config_dword(mvi->pdev, PCR_PHY_CTL, &tmp);\n\t\t\ttmp &= ~PCTL_PWR_OFF;\n\t\t\ttmp |= PCTL_PHY_DSBL;\n\t\t\tpci_write_config_dword(mvi->pdev, PCR_PHY_CTL, tmp);\n\n\t\t\tpci_read_config_dword(mvi->pdev, PCR_PHY_CTL2, &tmp);\n\t\t\ttmp &= ~PCTL_PWR_OFF;\n\t\t\ttmp |= PCTL_PHY_DSBL;\n\t\t\tpci_write_config_dword(mvi->pdev, PCR_PHY_CTL2, tmp);\n\t\t}\n\t}\n\n\t \n\tmw32(MVS_GBL_CTL, 0);\n\ttmp = mr32(MVS_GBL_CTL);\n\n\t \n\tif (!(tmp & HBA_RST)) {\n\t\t \n\t\tmw32_f(MVS_GBL_CTL, HBA_RST);\n\t}\n\n\t \n\ti = 1000;\n\twhile (i-- > 0) {\n\t\tmsleep(10);\n\n\t\tif (!(mr32(MVS_GBL_CTL) & HBA_RST))\n\t\t\tbreak;\n\t}\n\tif (mr32(MVS_GBL_CTL) & HBA_RST) {\n\t\tdev_printk(KERN_ERR, mvi->dev, \"HBA reset failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic void mvs_64xx_phy_disable(struct mvs_info *mvi, u32 phy_id)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\tu32 offs;\n\t\tif (phy_id < 4)\n\t\t\toffs = PCR_PHY_CTL;\n\t\telse {\n\t\t\toffs = PCR_PHY_CTL2;\n\t\t\tphy_id -= 4;\n\t\t}\n\t\tpci_read_config_dword(mvi->pdev, offs, &tmp);\n\t\ttmp |= 1U << (PCTL_PHY_DSBL_OFFS + phy_id);\n\t\tpci_write_config_dword(mvi->pdev, offs, tmp);\n\t} else {\n\t\ttmp = mr32(MVS_PHY_CTL);\n\t\ttmp |= 1U << (PCTL_PHY_DSBL_OFFS + phy_id);\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t}\n}\n\nstatic void mvs_64xx_phy_enable(struct mvs_info *mvi, u32 phy_id)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\tu32 offs;\n\t\tif (phy_id < 4)\n\t\t\toffs = PCR_PHY_CTL;\n\t\telse {\n\t\t\toffs = PCR_PHY_CTL2;\n\t\t\tphy_id -= 4;\n\t\t}\n\t\tpci_read_config_dword(mvi->pdev, offs, &tmp);\n\t\ttmp &= ~(1U << (PCTL_PHY_DSBL_OFFS + phy_id));\n\t\tpci_write_config_dword(mvi->pdev, offs, tmp);\n\t} else {\n\t\ttmp = mr32(MVS_PHY_CTL);\n\t\ttmp &= ~(1U << (PCTL_PHY_DSBL_OFFS + phy_id));\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t}\n}\n\nstatic int mvs_64xx_init(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tint i;\n\tu32 tmp, cctl;\n\n\tif (mvi->pdev && mvi->pdev->revision == 0)\n\t\tmvi->flags |= MVF_PHY_PWR_FIX;\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\tmvs_show_pcie_usage(mvi);\n\t\ttmp = mvs_64xx_chip_reset(mvi);\n\t\tif (tmp)\n\t\t\treturn tmp;\n\t} else {\n\t\ttmp = mr32(MVS_PHY_CTL);\n\t\ttmp &= ~PCTL_PWR_OFF;\n\t\ttmp |= PCTL_PHY_DSBL;\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t}\n\n\t \n\t \n\tcctl = mr32(MVS_CTL) & 0xFFFF;\n\tif (cctl & CCTL_RST)\n\t\tcctl &= ~CCTL_RST;\n\telse\n\t\tmw32_f(MVS_CTL, cctl | CCTL_RST);\n\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\t \n\t\tpci_read_config_dword(mvi->pdev, PCR_DEV_CTRL, &tmp);\n\t\ttmp &= ~PRD_REQ_MASK;\n\t\ttmp |= PRD_REQ_SIZE;\n\t\tpci_write_config_dword(mvi->pdev, PCR_DEV_CTRL, tmp);\n\n\t\tpci_read_config_dword(mvi->pdev, PCR_PHY_CTL, &tmp);\n\t\ttmp &= ~PCTL_PWR_OFF;\n\t\ttmp &= ~PCTL_PHY_DSBL;\n\t\tpci_write_config_dword(mvi->pdev, PCR_PHY_CTL, tmp);\n\n\t\tpci_read_config_dword(mvi->pdev, PCR_PHY_CTL2, &tmp);\n\t\ttmp &= PCTL_PWR_OFF;\n\t\ttmp &= ~PCTL_PHY_DSBL;\n\t\tpci_write_config_dword(mvi->pdev, PCR_PHY_CTL2, tmp);\n\t} else {\n\t\ttmp = mr32(MVS_PHY_CTL);\n\t\ttmp &= ~PCTL_PWR_OFF;\n\t\ttmp |= PCTL_COM_ON;\n\t\ttmp &= ~PCTL_PHY_DSBL;\n\t\ttmp |= PCTL_LINK_RST;\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t\tmsleep(100);\n\t\ttmp &= ~PCTL_LINK_RST;\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t\tmsleep(100);\n\t}\n\n\t \n\tmw32(MVS_PCS, 0);\t\t \n\t \n\tmvs_64xx_phy_hacks(mvi);\n\n\ttmp = mvs_cr32(mvi, CMD_PHY_MODE_21);\n\ttmp &= 0x0000ffff;\n\ttmp |= 0x00fa0000;\n\tmvs_cw32(mvi, CMD_PHY_MODE_21, tmp);\n\n\t \n\tmw32(MVS_GBL_PORT_TYPE, MODE_AUTO_DET_EN);\n\n\tmw32(MVS_CMD_LIST_LO, mvi->slot_dma);\n\tmw32(MVS_CMD_LIST_HI, (mvi->slot_dma >> 16) >> 16);\n\n\tmw32(MVS_RX_FIS_LO, mvi->rx_fis_dma);\n\tmw32(MVS_RX_FIS_HI, (mvi->rx_fis_dma >> 16) >> 16);\n\n\tmw32(MVS_TX_CFG, MVS_CHIP_SLOT_SZ);\n\tmw32(MVS_TX_LO, mvi->tx_dma);\n\tmw32(MVS_TX_HI, (mvi->tx_dma >> 16) >> 16);\n\n\tmw32(MVS_RX_CFG, MVS_RX_RING_SZ);\n\tmw32(MVS_RX_LO, mvi->rx_dma);\n\tmw32(MVS_RX_HI, (mvi->rx_dma >> 16) >> 16);\n\n\tfor (i = 0; i < mvi->chip->n_phy; i++) {\n\t\t \n\t\t \n\t\tmvs_set_sas_addr(mvi, i, PHYR_ADDR_LO, PHYR_ADDR_HI,\n\t\t\t\tcpu_to_be64(mvi->phy[i].dev_sas_addr));\n\n\t\tmvs_64xx_enable_xmt(mvi, i);\n\n\t\tmvs_64xx_phy_reset(mvi, i, MVS_HARD_RESET);\n\t\tmsleep(500);\n\t\tmvs_64xx_detect_porttype(mvi, i);\n\t}\n\tif (mvi->flags & MVF_FLAG_SOC) {\n\t\t \n\t\twritel(0x0E008000, regs + 0x000);\n\t\twritel(0x59000008, regs + 0x004);\n\t\twritel(0x20, regs + 0x008);\n\t\twritel(0x20, regs + 0x00c);\n\t\twritel(0x20, regs + 0x010);\n\t\twritel(0x20, regs + 0x014);\n\t\twritel(0x20, regs + 0x018);\n\t\twritel(0x20, regs + 0x01c);\n\t}\n\tfor (i = 0; i < mvi->chip->n_phy; i++) {\n\t\t \n\t\ttmp = mvs_read_port_irq_stat(mvi, i);\n\t\ttmp &= ~PHYEV_SIG_FIS;\n\t\tmvs_write_port_irq_stat(mvi, i, tmp);\n\n\t\t \n\t\ttmp = PHYEV_RDY_CH | PHYEV_BROAD_CH | PHYEV_UNASSOC_FIS |\n\t\t\tPHYEV_ID_DONE | PHYEV_DCDR_ERR | PHYEV_CRC_ERR |\n\t\t\tPHYEV_DEC_ERR;\n\t\tmvs_write_port_irq_mask(mvi, i, tmp);\n\n\t\tmsleep(100);\n\t\tmvs_update_phyinfo(mvi, i, 1);\n\t}\n\n\t \n\tcctl = mr32(MVS_CTL);\n\tcctl |= CCTL_ENDIAN_CMD;\n\tcctl |= CCTL_ENDIAN_DATA;\n\tcctl &= ~CCTL_ENDIAN_OPEN;\n\tcctl |= CCTL_ENDIAN_RSP;\n\tmw32_f(MVS_CTL, cctl);\n\n\t \n\ttmp = mr32(MVS_PCS);\n\ttmp |= PCS_CMD_RST;\n\ttmp &= ~PCS_SELF_CLEAR;\n\tmw32(MVS_PCS, tmp);\n\t \n\ttmp = 0;\n\tif (MVS_CHIP_SLOT_SZ > 0x1ff)\n\t\tmw32(MVS_INT_COAL, 0x1ff | COAL_EN);\n\telse\n\t\tmw32(MVS_INT_COAL, MVS_CHIP_SLOT_SZ | COAL_EN);\n\n\ttmp = 0x10000 | interrupt_coalescing;\n\tmw32(MVS_INT_COAL_TMOUT, tmp);\n\n\t \n\tmw32(MVS_TX_CFG, 0);\n\tmw32(MVS_TX_CFG, MVS_CHIP_SLOT_SZ | TX_EN);\n\tmw32(MVS_RX_CFG, MVS_RX_RING_SZ | RX_EN);\n\t \n\tmw32(MVS_PCS, PCS_SATA_RETRY | PCS_FIS_RX_EN |\n\t\tPCS_CMD_EN | PCS_CMD_STOP_ERR);\n\n\t \n\ttmp = (CINT_PORT_MASK | CINT_DONE | CINT_MEM | CINT_SRS | CINT_CI_STOP |\n\t\tCINT_DMA_PCIE);\n\n\tmw32(MVS_INT_MASK, tmp);\n\n\t \n\tmw32(MVS_INT_MASK_SRS_0, 0xFFFF);\n\n\treturn 0;\n}\n\nstatic int mvs_64xx_ioremap(struct mvs_info *mvi)\n{\n\tif (!mvs_ioremap(mvi, 4, 2))\n\t\treturn 0;\n\treturn -1;\n}\n\nstatic void mvs_64xx_iounmap(struct mvs_info *mvi)\n{\n\tmvs_iounmap(mvi->regs);\n\tmvs_iounmap(mvi->regs_ex);\n}\n\nstatic void mvs_64xx_interrupt_enable(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\n\ttmp = mr32(MVS_GBL_CTL);\n\tmw32(MVS_GBL_CTL, tmp | INT_EN);\n}\n\nstatic void mvs_64xx_interrupt_disable(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\n\ttmp = mr32(MVS_GBL_CTL);\n\tmw32(MVS_GBL_CTL, tmp & ~INT_EN);\n}\n\nstatic u32 mvs_64xx_isr_status(struct mvs_info *mvi, int irq)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 stat;\n\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\tstat = mr32(MVS_GBL_INT_STAT);\n\n\t\tif (stat == 0 || stat == 0xffffffff)\n\t\t\treturn 0;\n\t} else\n\t\tstat = 1;\n\treturn stat;\n}\n\nstatic irqreturn_t mvs_64xx_isr(struct mvs_info *mvi, int irq, u32 stat)\n{\n\tvoid __iomem *regs = mvi->regs;\n\n\t \n\tmw32_f(MVS_INT_STAT, CINT_DONE);\n\n\tspin_lock(&mvi->lock);\n\tmvs_int_full(mvi);\n\tspin_unlock(&mvi->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mvs_64xx_command_active(struct mvs_info *mvi, u32 slot_idx)\n{\n\tu32 tmp;\n\tmvs_cw32(mvi, 0x40 + (slot_idx >> 3), 1 << (slot_idx % 32));\n\tmvs_cw32(mvi, 0x00 + (slot_idx >> 3), 1 << (slot_idx % 32));\n\tdo {\n\t\ttmp = mvs_cr32(mvi, 0x00 + (slot_idx >> 3));\n\t} while (tmp & 1 << (slot_idx % 32));\n\tdo {\n\t\ttmp = mvs_cr32(mvi, 0x40 + (slot_idx >> 3));\n\t} while (tmp & 1 << (slot_idx % 32));\n}\n\nstatic void mvs_64xx_issue_stop(struct mvs_info *mvi, enum mvs_port_type type,\n\t\t\t\tu32 tfs)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\n\tif (type == PORT_TYPE_SATA) {\n\t\ttmp = mr32(MVS_INT_STAT_SRS_0) | (1U << tfs);\n\t\tmw32(MVS_INT_STAT_SRS_0, tmp);\n\t}\n\tmw32(MVS_INT_STAT, CINT_CI_STOP);\n\ttmp = mr32(MVS_PCS) | 0xFF00;\n\tmw32(MVS_PCS, tmp);\n}\n\nstatic void mvs_64xx_free_reg_set(struct mvs_info *mvi, u8 *tfs)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp, offs;\n\n\tif (*tfs == MVS_ID_NOT_MAPPED)\n\t\treturn;\n\n\toffs = 1U << ((*tfs & 0x0f) + PCS_EN_SATA_REG_SHIFT);\n\tif (*tfs < 16) {\n\t\ttmp = mr32(MVS_PCS);\n\t\tmw32(MVS_PCS, tmp & ~offs);\n\t} else {\n\t\ttmp = mr32(MVS_CTL);\n\t\tmw32(MVS_CTL, tmp & ~offs);\n\t}\n\n\ttmp = mr32(MVS_INT_STAT_SRS_0) & (1U << *tfs);\n\tif (tmp)\n\t\tmw32(MVS_INT_STAT_SRS_0, tmp);\n\n\t*tfs = MVS_ID_NOT_MAPPED;\n\treturn;\n}\n\nstatic u8 mvs_64xx_assign_reg_set(struct mvs_info *mvi, u8 *tfs)\n{\n\tint i;\n\tu32 tmp, offs;\n\tvoid __iomem *regs = mvi->regs;\n\n\tif (*tfs != MVS_ID_NOT_MAPPED)\n\t\treturn 0;\n\n\ttmp = mr32(MVS_PCS);\n\n\tfor (i = 0; i < mvi->chip->srs_sz; i++) {\n\t\tif (i == 16)\n\t\t\ttmp = mr32(MVS_CTL);\n\t\toffs = 1U << ((i & 0x0f) + PCS_EN_SATA_REG_SHIFT);\n\t\tif (!(tmp & offs)) {\n\t\t\t*tfs = i;\n\n\t\t\tif (i < 16)\n\t\t\t\tmw32(MVS_PCS, tmp | offs);\n\t\t\telse\n\t\t\t\tmw32(MVS_CTL, tmp | offs);\n\t\t\ttmp = mr32(MVS_INT_STAT_SRS_0) & (1U << i);\n\t\t\tif (tmp)\n\t\t\t\tmw32(MVS_INT_STAT_SRS_0, tmp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn MVS_ID_NOT_MAPPED;\n}\n\nstatic void mvs_64xx_make_prd(struct scatterlist *scatter, int nr, void *prd)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\tstruct mvs_prd *buf_prd = prd;\n\tfor_each_sg(scatter, sg, nr, i) {\n\t\tbuf_prd->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tbuf_prd->len = cpu_to_le32(sg_dma_len(sg));\n\t\tbuf_prd++;\n\t}\n}\n\nstatic int mvs_64xx_oob_done(struct mvs_info *mvi, int i)\n{\n\tu32 phy_st;\n\tmvs_write_port_cfg_addr(mvi, i,\n\t\t\tPHYR_PHY_STAT);\n\tphy_st = mvs_read_port_cfg_data(mvi, i);\n\tif (phy_st & PHY_OOB_DTCTD)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void mvs_64xx_fix_phy_info(struct mvs_info *mvi, int i,\n\t\t\t\tstruct sas_identify_frame *id)\n\n{\n\tstruct mvs_phy *phy = &mvi->phy[i];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\tsas_phy->linkrate =\n\t\t(phy->phy_status & PHY_NEG_SPP_PHYS_LINK_RATE_MASK) >>\n\t\t\tPHY_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET;\n\n\tphy->minimum_linkrate =\n\t\t(phy->phy_status &\n\t\t\tPHY_MIN_SPP_PHYS_LINK_RATE_MASK) >> 8;\n\tphy->maximum_linkrate =\n\t\t(phy->phy_status &\n\t\t\tPHY_MAX_SPP_PHYS_LINK_RATE_MASK) >> 12;\n\n\tmvs_write_port_cfg_addr(mvi, i, PHYR_IDENTIFY);\n\tphy->dev_info = mvs_read_port_cfg_data(mvi, i);\n\n\tmvs_write_port_cfg_addr(mvi, i, PHYR_ATT_DEV_INFO);\n\tphy->att_dev_info = mvs_read_port_cfg_data(mvi, i);\n\n\tmvs_write_port_cfg_addr(mvi, i, PHYR_ATT_ADDR_HI);\n\tphy->att_dev_sas_addr =\n\t     (u64) mvs_read_port_cfg_data(mvi, i) << 32;\n\tmvs_write_port_cfg_addr(mvi, i, PHYR_ATT_ADDR_LO);\n\tphy->att_dev_sas_addr |= mvs_read_port_cfg_data(mvi, i);\n\tphy->att_dev_sas_addr = SAS_ADDR(&phy->att_dev_sas_addr);\n}\n\nstatic void mvs_64xx_phy_work_around(struct mvs_info *mvi, int i)\n{\n\tu32 tmp;\n\tstruct mvs_phy *phy = &mvi->phy[i];\n\tmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE6);\n\ttmp = mvs_read_port_vsr_data(mvi, i);\n\tif (((phy->phy_status & PHY_NEG_SPP_PHYS_LINK_RATE_MASK) >>\n\t     PHY_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET) ==\n\t\tSAS_LINK_RATE_1_5_GBPS)\n\t\ttmp &= ~PHY_MODE6_LATECLK;\n\telse\n\t\ttmp |= PHY_MODE6_LATECLK;\n\tmvs_write_port_vsr_data(mvi, i, tmp);\n}\n\nstatic void mvs_64xx_phy_set_link_rate(struct mvs_info *mvi, u32 phy_id,\n\t\t\tstruct sas_phy_linkrates *rates)\n{\n\tu32 lrmin = 0, lrmax = 0;\n\tu32 tmp;\n\n\ttmp = mvs_read_phy_ctl(mvi, phy_id);\n\tlrmin = (rates->minimum_linkrate << 8);\n\tlrmax = (rates->maximum_linkrate << 12);\n\n\tif (lrmin) {\n\t\ttmp &= ~(0xf << 8);\n\t\ttmp |= lrmin;\n\t}\n\tif (lrmax) {\n\t\ttmp &= ~(0xf << 12);\n\t\ttmp |= lrmax;\n\t}\n\tmvs_write_phy_ctl(mvi, phy_id, tmp);\n\tmvs_64xx_phy_reset(mvi, phy_id, MVS_HARD_RESET);\n}\n\nstatic void mvs_64xx_clear_active_cmds(struct mvs_info *mvi)\n{\n\tu32 tmp;\n\tvoid __iomem *regs = mvi->regs;\n\ttmp = mr32(MVS_PCS);\n\tmw32(MVS_PCS, tmp & 0xFFFF);\n\tmw32(MVS_PCS, tmp);\n\ttmp = mr32(MVS_CTL);\n\tmw32(MVS_CTL, tmp & 0xFFFF);\n\tmw32(MVS_CTL, tmp);\n}\n\n\nstatic u32 mvs_64xx_spi_read_data(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs_ex;\n\treturn ior32(SPI_DATA_REG_64XX);\n}\n\nstatic void mvs_64xx_spi_write_data(struct mvs_info *mvi, u32 data)\n{\n\tvoid __iomem *regs = mvi->regs_ex;\n\n\tiow32(SPI_DATA_REG_64XX, data);\n}\n\n\nstatic int mvs_64xx_spi_buildcmd(struct mvs_info *mvi,\n\t\t\tu32      *dwCmd,\n\t\t\tu8       cmd,\n\t\t\tu8       read,\n\t\t\tu8       length,\n\t\t\tu32      addr\n\t\t\t)\n{\n\tu32  dwTmp;\n\n\tdwTmp = ((u32)cmd << 24) | ((u32)length << 19);\n\tif (read)\n\t\tdwTmp |= 1U<<23;\n\n\tif (addr != MV_MAX_U32) {\n\t\tdwTmp |= 1U<<22;\n\t\tdwTmp |= (addr & 0x0003FFFF);\n\t}\n\n\t*dwCmd = dwTmp;\n\treturn 0;\n}\n\n\nstatic int mvs_64xx_spi_issuecmd(struct mvs_info *mvi, u32 cmd)\n{\n\tvoid __iomem *regs = mvi->regs_ex;\n\tint     retry;\n\n\tfor (retry = 0; retry < 1; retry++) {\n\t\tiow32(SPI_CTRL_REG_64XX, SPI_CTRL_VENDOR_ENABLE);\n\t\tiow32(SPI_CMD_REG_64XX, cmd);\n\t\tiow32(SPI_CTRL_REG_64XX,\n\t\t\tSPI_CTRL_VENDOR_ENABLE | SPI_CTRL_SPISTART);\n\t}\n\n\treturn 0;\n}\n\nstatic int mvs_64xx_spi_waitdataready(struct mvs_info *mvi, u32 timeout)\n{\n\tvoid __iomem *regs = mvi->regs_ex;\n\tu32 i, dwTmp;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tdwTmp = ior32(SPI_CTRL_REG_64XX);\n\t\tif (!(dwTmp & SPI_CTRL_SPISTART))\n\t\t\treturn 0;\n\t\tmsleep(10);\n\t}\n\n\treturn -1;\n}\n\nstatic void mvs_64xx_fix_dma(struct mvs_info *mvi, u32 phy_mask,\n\t\t\t\tint buf_len, int from, void *prd)\n{\n\tint i;\n\tstruct mvs_prd *buf_prd = prd;\n\tdma_addr_t buf_dma = mvi->bulk_buffer_dma;\n\n\tbuf_prd\t+= from;\n\tfor (i = 0; i < MAX_SG_ENTRY - from; i++) {\n\t\tbuf_prd->addr = cpu_to_le64(buf_dma);\n\t\tbuf_prd->len = cpu_to_le32(buf_len);\n\t\t++buf_prd;\n\t}\n}\n\nstatic void mvs_64xx_tune_interrupt(struct mvs_info *mvi, u32 time)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp = 0;\n\t \n\tif (time == 0) {\n\t\tmw32(MVS_INT_COAL, 0);\n\t\tmw32(MVS_INT_COAL_TMOUT, 0x10000);\n\t} else {\n\t\tif (MVS_CHIP_SLOT_SZ > 0x1ff)\n\t\t\tmw32(MVS_INT_COAL, 0x1ff|COAL_EN);\n\t\telse\n\t\t\tmw32(MVS_INT_COAL, MVS_CHIP_SLOT_SZ|COAL_EN);\n\n\t\ttmp = 0x10000 | time;\n\t\tmw32(MVS_INT_COAL_TMOUT, tmp);\n\t}\n}\n\nconst struct mvs_dispatch mvs_64xx_dispatch = {\n\t\"mv64xx\",\n\tmvs_64xx_init,\n\tNULL,\n\tmvs_64xx_ioremap,\n\tmvs_64xx_iounmap,\n\tmvs_64xx_isr,\n\tmvs_64xx_isr_status,\n\tmvs_64xx_interrupt_enable,\n\tmvs_64xx_interrupt_disable,\n\tmvs_read_phy_ctl,\n\tmvs_write_phy_ctl,\n\tmvs_read_port_cfg_data,\n\tmvs_write_port_cfg_data,\n\tmvs_write_port_cfg_addr,\n\tmvs_read_port_vsr_data,\n\tmvs_write_port_vsr_data,\n\tmvs_write_port_vsr_addr,\n\tmvs_read_port_irq_stat,\n\tmvs_write_port_irq_stat,\n\tmvs_read_port_irq_mask,\n\tmvs_write_port_irq_mask,\n\tmvs_64xx_command_active,\n\tmvs_64xx_clear_srs_irq,\n\tmvs_64xx_issue_stop,\n\tmvs_start_delivery,\n\tmvs_rx_update,\n\tmvs_int_full,\n\tmvs_64xx_assign_reg_set,\n\tmvs_64xx_free_reg_set,\n\tmvs_get_prd_size,\n\tmvs_get_prd_count,\n\tmvs_64xx_make_prd,\n\tmvs_64xx_detect_porttype,\n\tmvs_64xx_oob_done,\n\tmvs_64xx_fix_phy_info,\n\tmvs_64xx_phy_work_around,\n\tmvs_64xx_phy_set_link_rate,\n\tmvs_hw_max_link_rate,\n\tmvs_64xx_phy_disable,\n\tmvs_64xx_phy_enable,\n\tmvs_64xx_phy_reset,\n\tmvs_64xx_stp_reset,\n\tmvs_64xx_clear_active_cmds,\n\tmvs_64xx_spi_read_data,\n\tmvs_64xx_spi_write_data,\n\tmvs_64xx_spi_buildcmd,\n\tmvs_64xx_spi_issuecmd,\n\tmvs_64xx_spi_waitdataready,\n\tmvs_64xx_fix_dma,\n\tmvs_64xx_tune_interrupt,\n\tNULL,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}