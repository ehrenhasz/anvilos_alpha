{
  "module_name": "mv_94xx.c",
  "hash_id": "8f555a674d51f0b54c88593c915ffd3054cf2eb80fda44d50869d7dc4a2eadf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mvsas/mv_94xx.c",
  "human_readable_source": "\n \n\n#include \"mv_sas.h\"\n#include \"mv_94xx.h\"\n#include \"mv_chips.h\"\n\nstatic void mvs_94xx_detect_porttype(struct mvs_info *mvi, int i)\n{\n\tu32 reg;\n\tstruct mvs_phy *phy = &mvi->phy[i];\n\tu32 phy_status;\n\n\tmvs_write_port_vsr_addr(mvi, i, VSR_PHY_MODE3);\n\treg = mvs_read_port_vsr_data(mvi, i);\n\tphy_status = ((reg & 0x3f0000) >> 16) & 0xff;\n\tphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\n\tswitch (phy_status) {\n\tcase 0x10:\n\t\tphy->phy_type |= PORT_TYPE_SAS;\n\t\tbreak;\n\tcase 0x1d:\n\tdefault:\n\t\tphy->phy_type |= PORT_TYPE_SATA;\n\t\tbreak;\n\t}\n}\n\nstatic void set_phy_tuning(struct mvs_info *mvi, int phy_id,\n\t\t\t   struct phy_tuning phy_tuning)\n{\n\tu32 tmp, setting_0 = 0, setting_1 = 0;\n\tu8 i;\n\n\t \n\n\t \n\tif (mvi->pdev->revision == VANIR_A0_REV)\n\t\treturn;\n\n\tfor (i = 0; i < 3; i++) {\n\t\t \n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tsetting_0 = GENERATION_1_SETTING;\n\t\t\tsetting_1 = GENERATION_1_2_SETTING;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tsetting_0 = GENERATION_1_2_SETTING;\n\t\t\tsetting_1 = GENERATION_2_3_SETTING;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tsetting_0 = GENERATION_2_3_SETTING;\n\t\t\tsetting_1 = GENERATION_3_4_SETTING;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmvs_write_port_vsr_addr(mvi, phy_id, setting_0);\n\t\ttmp = mvs_read_port_vsr_data(mvi, phy_id);\n\t\ttmp &= ~(0xFBE << 16);\n\t\ttmp |= (((phy_tuning.trans_emp_en << 11) |\n\t\t\t(phy_tuning.trans_emp_amp << 7) |\n\t\t\t(phy_tuning.trans_amp << 1)) << 16);\n\t\tmvs_write_port_vsr_data(mvi, phy_id, tmp);\n\n\t\t \n\t\tmvs_write_port_vsr_addr(mvi, phy_id, setting_1);\n\t\ttmp = mvs_read_port_vsr_data(mvi, phy_id);\n\t\ttmp &= ~(0xC000);\n\t\ttmp |= (phy_tuning.trans_amp_adj << 14);\n\t\tmvs_write_port_vsr_data(mvi, phy_id, tmp);\n\t}\n}\n\nstatic void set_phy_ffe_tuning(struct mvs_info *mvi, int phy_id,\n\t\t\t       struct ffe_control ffe)\n{\n\tu32 tmp;\n\n\t \n\tif ((mvi->pdev->revision == VANIR_A0_REV)\n\t\t|| (mvi->pdev->revision == VANIR_B0_REV))\n\t\treturn;\n\n\t \n\t \n\tmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_FFE_CONTROL);\n\ttmp = mvs_read_port_vsr_data(mvi, phy_id);\n\ttmp &= ~0xFF;\n\n\t \n\ttmp |= ((0x1 << 7) |\n\t\t(ffe.ffe_rss_sel << 4) |\n\t\t(ffe.ffe_cap_sel << 0));\n\n\tmvs_write_port_vsr_data(mvi, phy_id, tmp);\n\n\t \n\tmvs_write_port_vsr_addr(mvi, phy_id, VSR_REF_CLOCK_CRTL);\n\ttmp = mvs_read_port_vsr_data(mvi, phy_id);\n\ttmp &= ~0x40001;\n\t \n\t \n\ttmp |= (0 << 18);\n\tmvs_write_port_vsr_data(mvi, phy_id, tmp);\n\n\t \n\tmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_DFE_UPDATE_CRTL);\n\ttmp = mvs_read_port_vsr_data(mvi, phy_id);\n\ttmp &= ~0xFFF;\n\t \n\t \n\ttmp |= ((0x3F << 6) | (0x0 << 0));\n\tmvs_write_port_vsr_data(mvi, phy_id, tmp);\n\n\t \n\tmvs_write_port_vsr_addr(mvi, phy_id, VSR_REF_CLOCK_CRTL);\n\ttmp = mvs_read_port_vsr_data(mvi, phy_id);\n\ttmp &= ~0x8;\n\t \n\t \n\ttmp |= (0 << 3);\n\tmvs_write_port_vsr_data(mvi, phy_id, tmp);\n}\n\n \nstatic void set_phy_rate(struct mvs_info *mvi, int phy_id, u8 rate)\n{\n\tunion reg_phy_cfg phy_cfg, phy_cfg_tmp;\n\tmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_MODE2);\n\tphy_cfg_tmp.v = mvs_read_port_vsr_data(mvi, phy_id);\n\tphy_cfg.v = 0;\n\tphy_cfg.u.disable_phy = phy_cfg_tmp.u.disable_phy;\n\tphy_cfg.u.sas_support = 1;\n\tphy_cfg.u.sata_support = 1;\n\tphy_cfg.u.sata_host_mode = 1;\n\n\tswitch (rate) {\n\tcase 0x0:\n\t\t \n\t\tphy_cfg.u.speed_support = 1;\n\t\tphy_cfg.u.snw_3_support = 0;\n\t\tphy_cfg.u.tx_lnk_parity = 1;\n\t\tphy_cfg.u.tx_spt_phs_lnk_rate = 0x30;\n\t\tbreak;\n\tcase 0x1:\n\n\t\t \n\t\tphy_cfg.u.speed_support = 3;\n\t\tphy_cfg.u.tx_spt_phs_lnk_rate = 0x3c;\n\t\tphy_cfg.u.tx_lgcl_lnk_rate = 0x08;\n\t\tbreak;\n\tcase 0x2:\n\tdefault:\n\t\t \n\t\tphy_cfg.u.speed_support = 7;\n\t\tphy_cfg.u.snw_3_support = 1;\n\t\tphy_cfg.u.tx_lnk_parity = 1;\n\t\tphy_cfg.u.tx_spt_phs_lnk_rate = 0x3f;\n\t\tphy_cfg.u.tx_lgcl_lnk_rate = 0x09;\n\t\tbreak;\n\t}\n\tmvs_write_port_vsr_data(mvi, phy_id, phy_cfg.v);\n}\n\nstatic void mvs_94xx_config_reg_from_hba(struct mvs_info *mvi, int phy_id)\n{\n\tu32 temp;\n\ttemp = (u32)(*(u32 *)&mvi->hba_info_param.phy_tuning[phy_id]);\n\tif (temp == 0xFFFFFFFFL) {\n\t\tmvi->hba_info_param.phy_tuning[phy_id].trans_emp_amp = 0x6;\n\t\tmvi->hba_info_param.phy_tuning[phy_id].trans_amp = 0x1A;\n\t\tmvi->hba_info_param.phy_tuning[phy_id].trans_amp_adj = 0x3;\n\t}\n\n\ttemp = (u8)(*(u8 *)&mvi->hba_info_param.ffe_ctl[phy_id]);\n\tif (temp == 0xFFL) {\n\t\tswitch (mvi->pdev->revision) {\n\t\tcase VANIR_A0_REV:\n\t\tcase VANIR_B0_REV:\n\t\t\tmvi->hba_info_param.ffe_ctl[phy_id].ffe_rss_sel = 0x7;\n\t\t\tmvi->hba_info_param.ffe_ctl[phy_id].ffe_cap_sel = 0x7;\n\t\t\tbreak;\n\t\tcase VANIR_C0_REV:\n\t\tcase VANIR_C1_REV:\n\t\tcase VANIR_C2_REV:\n\t\tdefault:\n\t\t\tmvi->hba_info_param.ffe_ctl[phy_id].ffe_rss_sel = 0x7;\n\t\t\tmvi->hba_info_param.ffe_ctl[phy_id].ffe_cap_sel = 0xC;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttemp = (u8)(*(u8 *)&mvi->hba_info_param.phy_rate[phy_id]);\n\tif (temp == 0xFFL)\n\t\t \n\t\tmvi->hba_info_param.phy_rate[phy_id] = 0x2;\n\n\tset_phy_tuning(mvi, phy_id,\n\t\tmvi->hba_info_param.phy_tuning[phy_id]);\n\tset_phy_ffe_tuning(mvi, phy_id,\n\t\tmvi->hba_info_param.ffe_ctl[phy_id]);\n\tset_phy_rate(mvi, phy_id,\n\t\tmvi->hba_info_param.phy_rate[phy_id]);\n}\n\nstatic void mvs_94xx_enable_xmt(struct mvs_info *mvi, int phy_id)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\n\ttmp = mr32(MVS_PCS);\n\ttmp |= 1 << (phy_id + PCS_EN_PORT_XMT_SHIFT2);\n\tmw32(MVS_PCS, tmp);\n}\n\nstatic void mvs_94xx_phy_reset(struct mvs_info *mvi, u32 phy_id, int hard)\n{\n\tu32 tmp;\n\tu32 delay = 5000;\n\tif (hard == MVS_PHY_TUNE) {\n\t\tmvs_write_port_cfg_addr(mvi, phy_id, PHYR_SATA_CTL);\n\t\ttmp = mvs_read_port_cfg_data(mvi, phy_id);\n\t\tmvs_write_port_cfg_data(mvi, phy_id, tmp|0x20000000);\n\t\tmvs_write_port_cfg_data(mvi, phy_id, tmp|0x100000);\n\t\treturn;\n\t}\n\ttmp = mvs_read_port_irq_stat(mvi, phy_id);\n\ttmp &= ~PHYEV_RDY_CH;\n\tmvs_write_port_irq_stat(mvi, phy_id, tmp);\n\tif (hard) {\n\t\ttmp = mvs_read_phy_ctl(mvi, phy_id);\n\t\ttmp |= PHY_RST_HARD;\n\t\tmvs_write_phy_ctl(mvi, phy_id, tmp);\n\t\tdo {\n\t\t\ttmp = mvs_read_phy_ctl(mvi, phy_id);\n\t\t\tudelay(10);\n\t\t\tdelay--;\n\t\t} while ((tmp & PHY_RST_HARD) && delay);\n\t\tif (!delay)\n\t\t\tmv_dprintk(\"phy hard reset failed.\\n\");\n\t} else {\n\t\ttmp = mvs_read_phy_ctl(mvi, phy_id);\n\t\ttmp |= PHY_RST;\n\t\tmvs_write_phy_ctl(mvi, phy_id, tmp);\n\t}\n}\n\nstatic void mvs_94xx_phy_disable(struct mvs_info *mvi, u32 phy_id)\n{\n\tu32 tmp;\n\tmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_MODE2);\n\ttmp = mvs_read_port_vsr_data(mvi, phy_id);\n\tmvs_write_port_vsr_data(mvi, phy_id, tmp | 0x00800000);\n}\n\nstatic void mvs_94xx_phy_enable(struct mvs_info *mvi, u32 phy_id)\n{\n\tu32 tmp;\n\tu8 revision = 0;\n\n\trevision = mvi->pdev->revision;\n\tif (revision == VANIR_A0_REV) {\n\t\tmvs_write_port_vsr_addr(mvi, phy_id, CMD_HOST_RD_DATA);\n\t\tmvs_write_port_vsr_data(mvi, phy_id, 0x8300ffc1);\n\t}\n\tif (revision == VANIR_B0_REV) {\n\t\tmvs_write_port_vsr_addr(mvi, phy_id, CMD_APP_MEM_CTL);\n\t\tmvs_write_port_vsr_data(mvi, phy_id, 0x08001006);\n\t\tmvs_write_port_vsr_addr(mvi, phy_id, CMD_HOST_RD_DATA);\n\t\tmvs_write_port_vsr_data(mvi, phy_id, 0x0000705f);\n\t}\n\n\tmvs_write_port_vsr_addr(mvi, phy_id, VSR_PHY_MODE2);\n\ttmp = mvs_read_port_vsr_data(mvi, phy_id);\n\ttmp |= bit(0);\n\tmvs_write_port_vsr_data(mvi, phy_id, tmp & 0xfd7fffff);\n}\n\nstatic void mvs_94xx_sgpio_init(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs_ex - 0x10200;\n\tu32 tmp;\n\n\ttmp = mr32(MVS_HST_CHIP_CONFIG);\n\ttmp |= 0x100;\n\tmw32(MVS_HST_CHIP_CONFIG, tmp);\n\n\tmw32(MVS_SGPIO_CTRL + MVS_SGPIO_HOST_OFFSET * mvi->id,\n\t\tMVS_SGPIO_CTRL_SDOUT_AUTO << MVS_SGPIO_CTRL_SDOUT_SHIFT);\n\n\tmw32(MVS_SGPIO_CFG1 + MVS_SGPIO_HOST_OFFSET * mvi->id,\n\t\t8 << MVS_SGPIO_CFG1_LOWA_SHIFT |\n\t\t8 << MVS_SGPIO_CFG1_HIA_SHIFT |\n\t\t4 << MVS_SGPIO_CFG1_LOWB_SHIFT |\n\t\t4 << MVS_SGPIO_CFG1_HIB_SHIFT |\n\t\t2 << MVS_SGPIO_CFG1_MAXACTON_SHIFT |\n\t\t1 << MVS_SGPIO_CFG1_FORCEACTOFF_SHIFT\n\t);\n\n\tmw32(MVS_SGPIO_CFG2 + MVS_SGPIO_HOST_OFFSET * mvi->id,\n\t\t(300000 / 100) << MVS_SGPIO_CFG2_CLK_SHIFT |  \n\t\t66 << MVS_SGPIO_CFG2_BLINK_SHIFT  \n\t);\n\n\tmw32(MVS_SGPIO_CFG0 + MVS_SGPIO_HOST_OFFSET * mvi->id,\n\t\tMVS_SGPIO_CFG0_ENABLE |\n\t\tMVS_SGPIO_CFG0_BLINKA |\n\t\tMVS_SGPIO_CFG0_BLINKB |\n\t\t \n\t\t(12 - 1) << MVS_SGPIO_CFG0_AUT_BITLEN_SHIFT\n\t);\n\n\tmw32(MVS_SGPIO_DCTRL + MVS_SGPIO_HOST_OFFSET * mvi->id,\n\t\tDEFAULT_SGPIO_BITS);\n\n\tmw32(MVS_SGPIO_DSRC + MVS_SGPIO_HOST_OFFSET * mvi->id,\n\t\t((mvi->id * 4) + 3) << (8 * 3) |\n\t\t((mvi->id * 4) + 2) << (8 * 2) |\n\t\t((mvi->id * 4) + 1) << (8 * 1) |\n\t\t((mvi->id * 4) + 0) << (8 * 0));\n\n}\n\nstatic int mvs_94xx_init(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tint i;\n\tu32 tmp, cctl;\n\tu8 revision;\n\n\trevision = mvi->pdev->revision;\n\tmvs_show_pcie_usage(mvi);\n\tif (mvi->flags & MVF_FLAG_SOC) {\n\t\ttmp = mr32(MVS_PHY_CTL);\n\t\ttmp &= ~PCTL_PWR_OFF;\n\t\ttmp |= PCTL_PHY_DSBL;\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t}\n\n\t \n\t \n\tcctl = mr32(MVS_CTL) & 0xFFFF;\n\tif (cctl & CCTL_RST)\n\t\tcctl &= ~CCTL_RST;\n\telse\n\t\tmw32_f(MVS_CTL, cctl | CCTL_RST);\n\n\tif (mvi->flags & MVF_FLAG_SOC) {\n\t\ttmp = mr32(MVS_PHY_CTL);\n\t\ttmp &= ~PCTL_PWR_OFF;\n\t\ttmp |= PCTL_COM_ON;\n\t\ttmp &= ~PCTL_PHY_DSBL;\n\t\ttmp |= PCTL_LINK_RST;\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t\tmsleep(100);\n\t\ttmp &= ~PCTL_LINK_RST;\n\t\tmw32(MVS_PHY_CTL, tmp);\n\t\tmsleep(100);\n\t}\n\n\t \n\tmw32(MVS_PORTS_IMP, 0xFF);\n\n\tif (revision == VANIR_A0_REV) {\n\t\tmw32(MVS_PA_VSR_ADDR, CMD_CMWK_OOB_DET);\n\t\tmw32(MVS_PA_VSR_PORT, 0x00018080);\n\t}\n\tmw32(MVS_PA_VSR_ADDR, VSR_PHY_MODE2);\n\tif (revision == VANIR_A0_REV || revision == VANIR_B0_REV)\n\t\t \n\t\tmw32(MVS_PA_VSR_PORT, 0x0084d4fe);\n\telse\n\t\t \n\t\tmw32(MVS_PA_VSR_PORT, 0x0084fffe);\n\n\tif (revision == VANIR_B0_REV) {\n\t\tmw32(MVS_PA_VSR_ADDR, CMD_APP_MEM_CTL);\n\t\tmw32(MVS_PA_VSR_PORT, 0x08001006);\n\t\tmw32(MVS_PA_VSR_ADDR, CMD_HOST_RD_DATA);\n\t\tmw32(MVS_PA_VSR_PORT, 0x0000705f);\n\t}\n\n\t \n\tmw32(MVS_PCS, 0);\t\t \n\tmw32(MVS_STP_REG_SET_0, 0);\n\tmw32(MVS_STP_REG_SET_1, 0);\n\n\t \n\tmvs_phy_hacks(mvi);\n\n\t \n\ttmp = mvs_cr32(mvi, CMD_SAS_CTL1);\n\tif ((revision == VANIR_A0_REV) ||\n\t\t(revision == VANIR_B0_REV) ||\n\t\t(revision == VANIR_C0_REV)) {\n\t\ttmp &= ~0xffff;\n\t\ttmp |= 0x007f;\n\t\tmvs_cw32(mvi, CMD_SAS_CTL1, tmp);\n\t}\n\n\t \n\tmw32(MVS_PA_VSR_ADDR, VSR_PHY_ACT_LED);\n\ttmp = mr32(MVS_PA_VSR_PORT);\n\ttmp &= 0xFFFF00FF;\n\ttmp |= 0x00003300;\n\tmw32(MVS_PA_VSR_PORT, tmp);\n\n\tmw32(MVS_CMD_LIST_LO, mvi->slot_dma);\n\tmw32(MVS_CMD_LIST_HI, (mvi->slot_dma >> 16) >> 16);\n\n\tmw32(MVS_RX_FIS_LO, mvi->rx_fis_dma);\n\tmw32(MVS_RX_FIS_HI, (mvi->rx_fis_dma >> 16) >> 16);\n\n\tmw32(MVS_TX_CFG, MVS_CHIP_SLOT_SZ);\n\tmw32(MVS_TX_LO, mvi->tx_dma);\n\tmw32(MVS_TX_HI, (mvi->tx_dma >> 16) >> 16);\n\n\tmw32(MVS_RX_CFG, MVS_RX_RING_SZ);\n\tmw32(MVS_RX_LO, mvi->rx_dma);\n\tmw32(MVS_RX_HI, (mvi->rx_dma >> 16) >> 16);\n\n\tfor (i = 0; i < mvi->chip->n_phy; i++) {\n\t\tmvs_94xx_phy_disable(mvi, i);\n\t\t \n\t\tmvs_set_sas_addr(mvi, i, CONFIG_ID_FRAME3, CONFIG_ID_FRAME4,\n\t\t\t\t\t\tcpu_to_le64(mvi->phy[i].dev_sas_addr));\n\n\t\tmvs_94xx_enable_xmt(mvi, i);\n\t\tmvs_94xx_config_reg_from_hba(mvi, i);\n\t\tmvs_94xx_phy_enable(mvi, i);\n\n\t\tmvs_94xx_phy_reset(mvi, i, PHY_RST_HARD);\n\t\tmsleep(500);\n\t\tmvs_94xx_detect_porttype(mvi, i);\n\t}\n\n\tif (mvi->flags & MVF_FLAG_SOC) {\n\t\t \n\t\twritel(0x0E008000, regs + 0x000);\n\t\twritel(0x59000008, regs + 0x004);\n\t\twritel(0x20, regs + 0x008);\n\t\twritel(0x20, regs + 0x00c);\n\t\twritel(0x20, regs + 0x010);\n\t\twritel(0x20, regs + 0x014);\n\t\twritel(0x20, regs + 0x018);\n\t\twritel(0x20, regs + 0x01c);\n\t}\n\tfor (i = 0; i < mvi->chip->n_phy; i++) {\n\t\t \n\t\ttmp = mvs_read_port_irq_stat(mvi, i);\n\t\ttmp &= ~PHYEV_SIG_FIS;\n\t\tmvs_write_port_irq_stat(mvi, i, tmp);\n\n\t\t \n\t\ttmp = PHYEV_RDY_CH | PHYEV_BROAD_CH |\n\t\t\tPHYEV_ID_DONE  | PHYEV_DCDR_ERR | PHYEV_CRC_ERR ;\n\t\tmvs_write_port_irq_mask(mvi, i, tmp);\n\n\t\tmsleep(100);\n\t\tmvs_update_phyinfo(mvi, i, 1);\n\t}\n\n\t \n\tcctl = mr32(MVS_CTL);\n\tcctl |= CCTL_ENDIAN_CMD;\n\tcctl &= ~CCTL_ENDIAN_OPEN;\n\tcctl |= CCTL_ENDIAN_RSP;\n\tmw32_f(MVS_CTL, cctl);\n\n\t \n\ttmp = mr32(MVS_PCS);\n\ttmp |= PCS_CMD_RST;\n\ttmp &= ~PCS_SELF_CLEAR;\n\tmw32(MVS_PCS, tmp);\n\t \n\ttmp = 0;\n\tif (MVS_CHIP_SLOT_SZ > 0x1ff)\n\t\tmw32(MVS_INT_COAL, 0x1ff | COAL_EN);\n\telse\n\t\tmw32(MVS_INT_COAL, MVS_CHIP_SLOT_SZ | COAL_EN);\n\n\t \n\ttmp = 0x10000 | interrupt_coalescing;\n\tmw32(MVS_INT_COAL_TMOUT, tmp);\n\n\t \n\tmw32(MVS_TX_CFG, 0);\n\tmw32(MVS_TX_CFG, MVS_CHIP_SLOT_SZ | TX_EN);\n\tmw32(MVS_RX_CFG, MVS_RX_RING_SZ | RX_EN);\n\t \n\tmw32(MVS_PCS, PCS_SATA_RETRY_2 | PCS_FIS_RX_EN |\n\t\tPCS_CMD_EN | PCS_CMD_STOP_ERR);\n\n\t \n\ttmp = (CINT_PORT_MASK | CINT_DONE | CINT_MEM | CINT_SRS | CINT_CI_STOP |\n\t\tCINT_DMA_PCIE | CINT_NON_SPEC_NCQ_ERROR);\n\ttmp |= CINT_PHY_MASK;\n\tmw32(MVS_INT_MASK, tmp);\n\n\ttmp = mvs_cr32(mvi, CMD_LINK_TIMER);\n\ttmp |= 0xFFFF0000;\n\tmvs_cw32(mvi, CMD_LINK_TIMER, tmp);\n\n\t \n\ttmp = 0x003F003F;\n\tmvs_cw32(mvi, CMD_PL_TIMER, tmp);\n\n\t \n\ttmp = mvs_cr32(mvi, CMD_PORT_LAYER_TIMER1);\n\ttmp |= 0xFFFF007F;\n\tmvs_cw32(mvi, CMD_PORT_LAYER_TIMER1, tmp);\n\n\t \n\ttmp = mvs_cr32(mvi, CMD_SL_MODE0);\n\ttmp |= 0x00000300;\n\t \n\ttmp &= 0xFFFFFFFE;\n\tmvs_cw32(mvi, CMD_SL_MODE0, tmp);\n\n\t \n\tmw32(MVS_INT_MASK_SRS_0, 0xFFFF);\n\n\tmvs_94xx_sgpio_init(mvi);\n\n\treturn 0;\n}\n\nstatic int mvs_94xx_ioremap(struct mvs_info *mvi)\n{\n\tif (!mvs_ioremap(mvi, 2, -1)) {\n\t\tmvi->regs_ex = mvi->regs + 0x10200;\n\t\tmvi->regs += 0x20000;\n\t\tif (mvi->id == 1)\n\t\t\tmvi->regs += 0x4000;\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic void mvs_94xx_iounmap(struct mvs_info *mvi)\n{\n\tif (mvi->regs) {\n\t\tmvi->regs -= 0x20000;\n\t\tif (mvi->id == 1)\n\t\t\tmvi->regs -= 0x4000;\n\t\tmvs_iounmap(mvi->regs);\n\t}\n}\n\nstatic void mvs_94xx_interrupt_enable(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs_ex;\n\tu32 tmp;\n\n\ttmp = mr32(MVS_GBL_CTL);\n\ttmp |= (MVS_IRQ_SAS_A | MVS_IRQ_SAS_B);\n\tmw32(MVS_GBL_INT_STAT, tmp);\n\twritel(tmp, regs + 0x0C);\n\twritel(tmp, regs + 0x10);\n\twritel(tmp, regs + 0x14);\n\twritel(tmp, regs + 0x18);\n\tmw32(MVS_GBL_CTL, tmp);\n}\n\nstatic void mvs_94xx_interrupt_disable(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs_ex;\n\tu32 tmp;\n\n\ttmp = mr32(MVS_GBL_CTL);\n\n\ttmp &= ~(MVS_IRQ_SAS_A | MVS_IRQ_SAS_B);\n\tmw32(MVS_GBL_INT_STAT, tmp);\n\twritel(tmp, regs + 0x0C);\n\twritel(tmp, regs + 0x10);\n\twritel(tmp, regs + 0x14);\n\twritel(tmp, regs + 0x18);\n\tmw32(MVS_GBL_CTL, tmp);\n}\n\nstatic u32 mvs_94xx_isr_status(struct mvs_info *mvi, int irq)\n{\n\tvoid __iomem *regs = mvi->regs_ex;\n\tu32 stat = 0;\n\tif (!(mvi->flags & MVF_FLAG_SOC)) {\n\t\tstat = mr32(MVS_GBL_INT_STAT);\n\n\t\tif (!(stat & (MVS_IRQ_SAS_A | MVS_IRQ_SAS_B)))\n\t\t\treturn 0;\n\t}\n\treturn stat;\n}\n\nstatic irqreturn_t mvs_94xx_isr(struct mvs_info *mvi, int irq, u32 stat)\n{\n\tvoid __iomem *regs = mvi->regs;\n\n\tif (((stat & MVS_IRQ_SAS_A) && mvi->id == 0) ||\n\t\t\t((stat & MVS_IRQ_SAS_B) && mvi->id == 1)) {\n\t\tmw32_f(MVS_INT_STAT, CINT_DONE);\n\n\t\tspin_lock(&mvi->lock);\n\t\tmvs_int_full(mvi);\n\t\tspin_unlock(&mvi->lock);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void mvs_94xx_command_active(struct mvs_info *mvi, u32 slot_idx)\n{\n\tu32 tmp;\n\ttmp = mvs_cr32(mvi, MVS_COMMAND_ACTIVE+(slot_idx >> 3));\n\tif (tmp & 1 << (slot_idx % 32)) {\n\t\tmv_printk(\"command active %08X,  slot [%x].\\n\", tmp, slot_idx);\n\t\tmvs_cw32(mvi, MVS_COMMAND_ACTIVE + (slot_idx >> 3),\n\t\t\t1 << (slot_idx % 32));\n\t\tdo {\n\t\t\ttmp = mvs_cr32(mvi,\n\t\t\t\tMVS_COMMAND_ACTIVE + (slot_idx >> 3));\n\t\t} while (tmp & 1 << (slot_idx % 32));\n\t}\n}\n\nstatic void\nmvs_94xx_clear_srs_irq(struct mvs_info *mvi, u8 reg_set, u8 clear_all)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\n\tif (clear_all) {\n\t\ttmp = mr32(MVS_INT_STAT_SRS_0);\n\t\tif (tmp) {\n\t\t\tmv_dprintk(\"check SRS 0 %08X.\\n\", tmp);\n\t\t\tmw32(MVS_INT_STAT_SRS_0, tmp);\n\t\t}\n\t\ttmp = mr32(MVS_INT_STAT_SRS_1);\n\t\tif (tmp) {\n\t\t\tmv_dprintk(\"check SRS 1 %08X.\\n\", tmp);\n\t\t\tmw32(MVS_INT_STAT_SRS_1, tmp);\n\t\t}\n\t} else {\n\t\tif (reg_set > 31)\n\t\t\ttmp = mr32(MVS_INT_STAT_SRS_1);\n\t\telse\n\t\t\ttmp = mr32(MVS_INT_STAT_SRS_0);\n\n\t\tif (tmp & (1 << (reg_set % 32))) {\n\t\t\tmv_dprintk(\"register set 0x%x was stopped.\\n\", reg_set);\n\t\t\tif (reg_set > 31)\n\t\t\t\tmw32(MVS_INT_STAT_SRS_1, 1 << (reg_set % 32));\n\t\t\telse\n\t\t\t\tmw32(MVS_INT_STAT_SRS_0, 1 << (reg_set % 32));\n\t\t}\n\t}\n}\n\nstatic void mvs_94xx_issue_stop(struct mvs_info *mvi, enum mvs_port_type type,\n\t\t\t\tu32 tfs)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp;\n\tmvs_94xx_clear_srs_irq(mvi, 0, 1);\n\n\ttmp = mr32(MVS_INT_STAT);\n\tmw32(MVS_INT_STAT, tmp | CINT_CI_STOP);\n\ttmp = mr32(MVS_PCS) | 0xFF00;\n\tmw32(MVS_PCS, tmp);\n}\n\nstatic void mvs_94xx_non_spec_ncq_error(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 err_0, err_1;\n\tu8 i;\n\tstruct mvs_device *device;\n\n\terr_0 = mr32(MVS_NON_NCQ_ERR_0);\n\terr_1 = mr32(MVS_NON_NCQ_ERR_1);\n\n\tmv_dprintk(\"non specific ncq error err_0:%x,err_1:%x.\\n\",\n\t\t\terr_0, err_1);\n\tfor (i = 0; i < 32; i++) {\n\t\tif (err_0 & bit(i)) {\n\t\t\tdevice = mvs_find_dev_by_reg_set(mvi, i);\n\t\t\tif (device)\n\t\t\t\tmvs_release_task(mvi, device->sas_device);\n\t\t}\n\t\tif (err_1 & bit(i)) {\n\t\t\tdevice = mvs_find_dev_by_reg_set(mvi, i+32);\n\t\t\tif (device)\n\t\t\t\tmvs_release_task(mvi, device->sas_device);\n\t\t}\n\t}\n\n\tmw32(MVS_NON_NCQ_ERR_0, err_0);\n\tmw32(MVS_NON_NCQ_ERR_1, err_1);\n}\n\nstatic void mvs_94xx_free_reg_set(struct mvs_info *mvi, u8 *tfs)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu8 reg_set = *tfs;\n\n\tif (*tfs == MVS_ID_NOT_MAPPED)\n\t\treturn;\n\n\tmvi->sata_reg_set &= ~bit(reg_set);\n\tif (reg_set < 32)\n\t\tw_reg_set_enable(reg_set, (u32)mvi->sata_reg_set);\n\telse\n\t\tw_reg_set_enable(reg_set, (u32)(mvi->sata_reg_set >> 32));\n\n\t*tfs = MVS_ID_NOT_MAPPED;\n\n\treturn;\n}\n\nstatic u8 mvs_94xx_assign_reg_set(struct mvs_info *mvi, u8 *tfs)\n{\n\tint i;\n\tvoid __iomem *regs = mvi->regs;\n\n\tif (*tfs != MVS_ID_NOT_MAPPED)\n\t\treturn 0;\n\n\ti = mv_ffc64(mvi->sata_reg_set);\n\tif (i >= 32) {\n\t\tmvi->sata_reg_set |= bit(i);\n\t\tw_reg_set_enable(i, (u32)(mvi->sata_reg_set >> 32));\n\t\t*tfs = i;\n\t\treturn 0;\n\t} else if (i >= 0) {\n\t\tmvi->sata_reg_set |= bit(i);\n\t\tw_reg_set_enable(i, (u32)mvi->sata_reg_set);\n\t\t*tfs = i;\n\t\treturn 0;\n\t}\n\treturn MVS_ID_NOT_MAPPED;\n}\n\nstatic void mvs_94xx_make_prd(struct scatterlist *scatter, int nr, void *prd)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\tstruct mvs_prd *buf_prd = prd;\n\tstruct mvs_prd_imt im_len;\n\t*(u32 *)&im_len = 0;\n\tfor_each_sg(scatter, sg, nr, i) {\n\t\tbuf_prd->addr = cpu_to_le64(sg_dma_address(sg));\n\t\tim_len.len = sg_dma_len(sg);\n\t\tbuf_prd->im_len = cpu_to_le32(*(u32 *)&im_len);\n\t\tbuf_prd++;\n\t}\n}\n\nstatic int mvs_94xx_oob_done(struct mvs_info *mvi, int i)\n{\n\tu32 phy_st;\n\tphy_st = mvs_read_phy_ctl(mvi, i);\n\tif (phy_st & PHY_READY_MASK)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void mvs_94xx_get_dev_identify_frame(struct mvs_info *mvi, int port_id,\n\t\t\t\t\tstruct sas_identify_frame *id)\n{\n\tint i;\n\tu32 id_frame[7];\n\n\tfor (i = 0; i < 7; i++) {\n\t\tmvs_write_port_cfg_addr(mvi, port_id,\n\t\t\t\t\tCONFIG_ID_FRAME0 + i * 4);\n\t\tid_frame[i] = cpu_to_le32(mvs_read_port_cfg_data(mvi, port_id));\n\t}\n\tmemcpy(id, id_frame, 28);\n}\n\nstatic void mvs_94xx_get_att_identify_frame(struct mvs_info *mvi, int port_id,\n\t\t\t\t\tstruct sas_identify_frame *id)\n{\n\tint i;\n\tu32 id_frame[7];\n\n\tfor (i = 0; i < 7; i++) {\n\t\tmvs_write_port_cfg_addr(mvi, port_id,\n\t\t\t\t\tCONFIG_ATT_ID_FRAME0 + i * 4);\n\t\tid_frame[i] = cpu_to_le32(mvs_read_port_cfg_data(mvi, port_id));\n\t\tmv_dprintk(\"94xx phy %d atta frame %d %x.\\n\",\n\t\t\tport_id + mvi->id * mvi->chip->n_phy, i, id_frame[i]);\n\t}\n\tmemcpy(id, id_frame, 28);\n}\n\nstatic u32 mvs_94xx_make_dev_info(struct sas_identify_frame *id)\n{\n\tu32 att_dev_info = 0;\n\n\tatt_dev_info |= id->dev_type;\n\tif (id->stp_iport)\n\t\tatt_dev_info |= PORT_DEV_STP_INIT;\n\tif (id->smp_iport)\n\t\tatt_dev_info |= PORT_DEV_SMP_INIT;\n\tif (id->ssp_iport)\n\t\tatt_dev_info |= PORT_DEV_SSP_INIT;\n\tif (id->stp_tport)\n\t\tatt_dev_info |= PORT_DEV_STP_TRGT;\n\tif (id->smp_tport)\n\t\tatt_dev_info |= PORT_DEV_SMP_TRGT;\n\tif (id->ssp_tport)\n\t\tatt_dev_info |= PORT_DEV_SSP_TRGT;\n\n\tatt_dev_info |= (u32)id->phy_id<<24;\n\treturn att_dev_info;\n}\n\nstatic u32 mvs_94xx_make_att_info(struct sas_identify_frame *id)\n{\n\treturn mvs_94xx_make_dev_info(id);\n}\n\nstatic void mvs_94xx_fix_phy_info(struct mvs_info *mvi, int i,\n\t\t\t\tstruct sas_identify_frame *id)\n{\n\tstruct mvs_phy *phy = &mvi->phy[i];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tmv_dprintk(\"get all reg link rate is 0x%x\\n\", phy->phy_status);\n\tsas_phy->linkrate =\n\t\t(phy->phy_status & PHY_NEG_SPP_PHYS_LINK_RATE_MASK) >>\n\t\t\tPHY_NEG_SPP_PHYS_LINK_RATE_MASK_OFFSET;\n\tsas_phy->linkrate += 0x8;\n\tmv_dprintk(\"get link rate is %d\\n\", sas_phy->linkrate);\n\tphy->minimum_linkrate = SAS_LINK_RATE_1_5_GBPS;\n\tphy->maximum_linkrate = SAS_LINK_RATE_6_0_GBPS;\n\tmvs_94xx_get_dev_identify_frame(mvi, i, id);\n\tphy->dev_info = mvs_94xx_make_dev_info(id);\n\n\tif (phy->phy_type & PORT_TYPE_SAS) {\n\t\tmvs_94xx_get_att_identify_frame(mvi, i, id);\n\t\tphy->att_dev_info = mvs_94xx_make_att_info(id);\n\t\tphy->att_dev_sas_addr = *(u64 *)id->sas_addr;\n\t} else {\n\t\tphy->att_dev_info = PORT_DEV_STP_TRGT | 1;\n\t}\n\n\t \n\tmvs_write_port_cfg_addr(mvi, i, PHYR_PHY_STAT);\n\tmvs_write_port_cfg_data(mvi, i, 0x04);\n\n}\n\nstatic void mvs_94xx_phy_set_link_rate(struct mvs_info *mvi, u32 phy_id,\n\t\t\t\t       struct sas_phy_linkrates *rates)\n{\n\tu32 lrmax = 0;\n\tu32 tmp;\n\n\ttmp = mvs_read_phy_ctl(mvi, phy_id);\n\tlrmax = (rates->maximum_linkrate - SAS_LINK_RATE_1_5_GBPS) << 12;\n\n\tif (lrmax) {\n\t\ttmp &= ~(0x3 << 12);\n\t\ttmp |= lrmax;\n\t}\n\tmvs_write_phy_ctl(mvi, phy_id, tmp);\n\tmvs_94xx_phy_reset(mvi, phy_id, PHY_RST_HARD);\n}\n\nstatic void mvs_94xx_clear_active_cmds(struct mvs_info *mvi)\n{\n\tu32 tmp;\n\tvoid __iomem *regs = mvi->regs;\n\ttmp = mr32(MVS_STP_REG_SET_0);\n\tmw32(MVS_STP_REG_SET_0, 0);\n\tmw32(MVS_STP_REG_SET_0, tmp);\n\ttmp = mr32(MVS_STP_REG_SET_1);\n\tmw32(MVS_STP_REG_SET_1, 0);\n\tmw32(MVS_STP_REG_SET_1, tmp);\n}\n\n\nstatic u32 mvs_94xx_spi_read_data(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs_ex - 0x10200;\n\treturn mr32(SPI_RD_DATA_REG_94XX);\n}\n\nstatic void mvs_94xx_spi_write_data(struct mvs_info *mvi, u32 data)\n{\n\tvoid __iomem *regs = mvi->regs_ex - 0x10200;\n\n\tmw32(SPI_RD_DATA_REG_94XX, data);\n}\n\n\nstatic int mvs_94xx_spi_buildcmd(struct mvs_info *mvi,\n\t\t\t\t u32      *dwCmd,\n\t\t\t\t u8       cmd,\n\t\t\t\t u8       read,\n\t\t\t\t u8       length,\n\t\t\t\t u32      addr\n\t\t\t\t)\n{\n\tvoid __iomem *regs = mvi->regs_ex - 0x10200;\n\tu32  dwTmp;\n\n\tdwTmp = ((u32)cmd << 8) | ((u32)length << 4);\n\tif (read)\n\t\tdwTmp |= SPI_CTRL_READ_94XX;\n\n\tif (addr != MV_MAX_U32) {\n\t\tmw32(SPI_ADDR_REG_94XX, (addr & 0x0003FFFFL));\n\t\tdwTmp |= SPI_ADDR_VLD_94XX;\n\t}\n\n\t*dwCmd = dwTmp;\n\treturn 0;\n}\n\n\nstatic int mvs_94xx_spi_issuecmd(struct mvs_info *mvi, u32 cmd)\n{\n\tvoid __iomem *regs = mvi->regs_ex - 0x10200;\n\tmw32(SPI_CTRL_REG_94XX, cmd | SPI_CTRL_SpiStart_94XX);\n\n\treturn 0;\n}\n\nstatic int mvs_94xx_spi_waitdataready(struct mvs_info *mvi, u32 timeout)\n{\n\tvoid __iomem *regs = mvi->regs_ex - 0x10200;\n\tu32   i, dwTmp;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tdwTmp = mr32(SPI_CTRL_REG_94XX);\n\t\tif (!(dwTmp & SPI_CTRL_SpiStart_94XX))\n\t\t\treturn 0;\n\t\tmsleep(10);\n\t}\n\n\treturn -1;\n}\n\nstatic void mvs_94xx_fix_dma(struct mvs_info *mvi, u32 phy_mask,\n\t\t\t     int buf_len, int from, void *prd)\n{\n\tint i;\n\tstruct mvs_prd *buf_prd = prd;\n\tdma_addr_t buf_dma;\n\tstruct mvs_prd_imt im_len;\n\n\t*(u32 *)&im_len = 0;\n\tbuf_prd += from;\n\n#define PRD_CHAINED_ENTRY 0x01\n\tif ((mvi->pdev->revision == VANIR_A0_REV) ||\n\t\t\t(mvi->pdev->revision == VANIR_B0_REV))\n\t\tbuf_dma = (phy_mask <= 0x08) ?\n\t\t\t\tmvi->bulk_buffer_dma : mvi->bulk_buffer_dma1;\n\telse\n\t\treturn;\n\n\tfor (i = from; i < MAX_SG_ENTRY; i++, ++buf_prd) {\n\t\tif (i == MAX_SG_ENTRY - 1) {\n\t\t\tbuf_prd->addr = cpu_to_le64(virt_to_phys(buf_prd - 1));\n\t\t\tim_len.len = 2;\n\t\t\tim_len.misc_ctl = PRD_CHAINED_ENTRY;\n\t\t} else {\n\t\t\tbuf_prd->addr = cpu_to_le64(buf_dma);\n\t\t\tim_len.len = buf_len;\n\t\t}\n\t\tbuf_prd->im_len = cpu_to_le32(*(u32 *)&im_len);\n\t}\n}\n\nstatic void mvs_94xx_tune_interrupt(struct mvs_info *mvi, u32 time)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp = 0;\n\t \n\tif (time == 0) {\n\t\tmw32(MVS_INT_COAL, 0);\n\t\tmw32(MVS_INT_COAL_TMOUT, 0x10000);\n\t} else {\n\t\tif (MVS_CHIP_SLOT_SZ > 0x1ff)\n\t\t\tmw32(MVS_INT_COAL, 0x1ff|COAL_EN);\n\t\telse\n\t\t\tmw32(MVS_INT_COAL, MVS_CHIP_SLOT_SZ|COAL_EN);\n\n\t\ttmp = 0x10000 | time;\n\t\tmw32(MVS_INT_COAL_TMOUT, tmp);\n\t}\n\n}\n\nstatic int mvs_94xx_gpio_write(struct mvs_prv_info *mvs_prv,\n\t\t\tu8 reg_type, u8 reg_index,\n\t\t\tu8 reg_count, u8 *write_data)\n{\n\tint i;\n\n\tswitch (reg_type) {\n\n\tcase SAS_GPIO_REG_TX_GP:\n\t\tif (reg_index == 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (reg_count > 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (reg_count == 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tfor (i = 0; i < mvs_prv->n_host * 4 * 3; i++) {\n\n\t\t\t \n\t\t\tstruct mvs_info *mvi = mvs_prv->mvi[i/(4*3)];\n\n\t\t\tvoid __iomem *regs = mvi->regs_ex - 0x10200;\n\n\t\t\tint drive = (i/3) & (4-1);  \n\t\t\tint driveshift = drive * 8;  \n\t\t\tu32 block = ioread32be(regs + MVS_SGPIO_DCTRL +\n\t\t\t\tMVS_SGPIO_HOST_OFFSET * mvi->id);\n\n\t\t\t \n\t\t\tu32 bit = get_unaligned_be32(write_data) & (1 << i) ?\n\t\t\t\t1 << driveshift : 0;\n\n\t\t\t \n\t\t\tswitch (i%3) {\n\t\t\tcase 0:  \n\t\t\t\tblock &= ~((0x7 << MVS_SGPIO_DCTRL_ACT_SHIFT)\n\t\t\t\t\t<< driveshift);\n\t\t\t\t\t \n\t\t\t\tblock |= LED_BLINKA_SOF << (\n\t\t\t\t\tMVS_SGPIO_DCTRL_ACT_SHIFT +\n\t\t\t\t\tdriveshift);\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tblock &= ~((0x3 << MVS_SGPIO_DCTRL_LOC_SHIFT)\n\t\t\t\t\t<< driveshift);\n\t\t\t\tblock |= bit << MVS_SGPIO_DCTRL_LOC_SHIFT;\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\tblock &= ~((0x7 << MVS_SGPIO_DCTRL_ERR_SHIFT)\n\t\t\t\t\t<< driveshift);\n\t\t\t\tblock |= bit << MVS_SGPIO_DCTRL_ERR_SHIFT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tiowrite32be(block,\n\t\t\t\tregs + MVS_SGPIO_DCTRL +\n\t\t\t\tMVS_SGPIO_HOST_OFFSET * mvi->id);\n\n\t\t}\n\n\t\treturn reg_count;\n\n\tcase SAS_GPIO_REG_TX:\n\t\tif (reg_index + reg_count > mvs_prv->n_host)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < reg_count; i++) {\n\t\t\tstruct mvs_info *mvi = mvs_prv->mvi[i+reg_index];\n\t\t\tvoid __iomem *regs = mvi->regs_ex - 0x10200;\n\n\t\t\tmw32(MVS_SGPIO_DCTRL + MVS_SGPIO_HOST_OFFSET * mvi->id,\n\t\t\t\t((u32 *) write_data)[i]);\n\t\t}\n\t\treturn reg_count;\n\t}\n\treturn -ENOSYS;\n}\n\nconst struct mvs_dispatch mvs_94xx_dispatch = {\n\t\"mv94xx\",\n\tmvs_94xx_init,\n\tNULL,\n\tmvs_94xx_ioremap,\n\tmvs_94xx_iounmap,\n\tmvs_94xx_isr,\n\tmvs_94xx_isr_status,\n\tmvs_94xx_interrupt_enable,\n\tmvs_94xx_interrupt_disable,\n\tmvs_read_phy_ctl,\n\tmvs_write_phy_ctl,\n\tmvs_read_port_cfg_data,\n\tmvs_write_port_cfg_data,\n\tmvs_write_port_cfg_addr,\n\tmvs_read_port_vsr_data,\n\tmvs_write_port_vsr_data,\n\tmvs_write_port_vsr_addr,\n\tmvs_read_port_irq_stat,\n\tmvs_write_port_irq_stat,\n\tmvs_read_port_irq_mask,\n\tmvs_write_port_irq_mask,\n\tmvs_94xx_command_active,\n\tmvs_94xx_clear_srs_irq,\n\tmvs_94xx_issue_stop,\n\tmvs_start_delivery,\n\tmvs_rx_update,\n\tmvs_int_full,\n\tmvs_94xx_assign_reg_set,\n\tmvs_94xx_free_reg_set,\n\tmvs_get_prd_size,\n\tmvs_get_prd_count,\n\tmvs_94xx_make_prd,\n\tmvs_94xx_detect_porttype,\n\tmvs_94xx_oob_done,\n\tmvs_94xx_fix_phy_info,\n\tNULL,\n\tmvs_94xx_phy_set_link_rate,\n\tmvs_hw_max_link_rate,\n\tmvs_94xx_phy_disable,\n\tmvs_94xx_phy_enable,\n\tmvs_94xx_phy_reset,\n\tNULL,\n\tmvs_94xx_clear_active_cmds,\n\tmvs_94xx_spi_read_data,\n\tmvs_94xx_spi_write_data,\n\tmvs_94xx_spi_buildcmd,\n\tmvs_94xx_spi_issuecmd,\n\tmvs_94xx_spi_waitdataready,\n\tmvs_94xx_fix_dma,\n\tmvs_94xx_tune_interrupt,\n\tmvs_94xx_non_spec_ncq_error,\n\tmvs_94xx_gpio_write,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}