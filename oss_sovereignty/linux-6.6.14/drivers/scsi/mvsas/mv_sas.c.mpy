{
  "module_name": "mv_sas.c",
  "hash_id": "8bf8a45a3672e74404df412e4ca14b90ec336e170adede843041a3eae7d99ac2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mvsas/mv_sas.c",
  "human_readable_source": "\n \n\n#include \"mv_sas.h\"\n\nstatic int mvs_find_tag(struct mvs_info *mvi, struct sas_task *task, u32 *tag)\n{\n\tif (task->lldd_task) {\n\t\tstruct mvs_slot_info *slot;\n\t\tslot = task->lldd_task;\n\t\t*tag = slot->slot_tag;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void mvs_tag_clear(struct mvs_info *mvi, u32 tag)\n{\n\tvoid *bitmap = mvi->rsvd_tags;\n\tclear_bit(tag, bitmap);\n}\n\nstatic void mvs_tag_free(struct mvs_info *mvi, u32 tag)\n{\n\tif (tag >= MVS_RSVD_SLOTS)\n\t\treturn;\n\n\tmvs_tag_clear(mvi, tag);\n}\n\nstatic void mvs_tag_set(struct mvs_info *mvi, unsigned int tag)\n{\n\tvoid *bitmap = mvi->rsvd_tags;\n\tset_bit(tag, bitmap);\n}\n\nstatic int mvs_tag_alloc(struct mvs_info *mvi, u32 *tag_out)\n{\n\tunsigned int index, tag;\n\tvoid *bitmap = mvi->rsvd_tags;\n\n\tindex = find_first_zero_bit(bitmap, MVS_RSVD_SLOTS);\n\ttag = index;\n\tif (tag >= MVS_RSVD_SLOTS)\n\t\treturn -SAS_QUEUE_FULL;\n\tmvs_tag_set(mvi, tag);\n\t*tag_out = tag;\n\treturn 0;\n}\n\nstatic struct mvs_info *mvs_find_dev_mvi(struct domain_device *dev)\n{\n\tunsigned long i = 0, j = 0, hi = 0;\n\tstruct sas_ha_struct *sha = dev->port->ha;\n\tstruct mvs_info *mvi = NULL;\n\tstruct asd_sas_phy *phy;\n\n\twhile (sha->sas_port[i]) {\n\t\tif (sha->sas_port[i] == dev->port) {\n\t\t\tspin_lock(&sha->sas_port[i]->phy_list_lock);\n\t\t\tphy =  container_of(sha->sas_port[i]->phy_list.next,\n\t\t\t\tstruct asd_sas_phy, port_phy_el);\n\t\t\tspin_unlock(&sha->sas_port[i]->phy_list_lock);\n\t\t\tj = 0;\n\t\t\twhile (sha->sas_phy[j]) {\n\t\t\t\tif (sha->sas_phy[j] == phy)\n\t\t\t\t\tbreak;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\thi = j/((struct mvs_prv_info *)sha->lldd_ha)->n_phy;\n\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[hi];\n\n\treturn mvi;\n\n}\n\nstatic int mvs_find_dev_phyno(struct domain_device *dev, int *phyno)\n{\n\tunsigned long i = 0, j = 0, n = 0, num = 0;\n\tstruct mvs_device *mvi_dev = (struct mvs_device *)dev->lldd_dev;\n\tstruct mvs_info *mvi = mvi_dev->mvi_info;\n\tstruct sas_ha_struct *sha = dev->port->ha;\n\n\twhile (sha->sas_port[i]) {\n\t\tif (sha->sas_port[i] == dev->port) {\n\t\t\tstruct asd_sas_phy *phy;\n\n\t\t\tspin_lock(&sha->sas_port[i]->phy_list_lock);\n\t\t\tlist_for_each_entry(phy,\n\t\t\t\t&sha->sas_port[i]->phy_list, port_phy_el) {\n\t\t\t\tj = 0;\n\t\t\t\twhile (sha->sas_phy[j]) {\n\t\t\t\t\tif (sha->sas_phy[j] == phy)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tphyno[n] = (j >= mvi->chip->n_phy) ?\n\t\t\t\t\t(j - mvi->chip->n_phy) : j;\n\t\t\t\tnum++;\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tspin_unlock(&sha->sas_port[i]->phy_list_lock);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn num;\n}\n\nstruct mvs_device *mvs_find_dev_by_reg_set(struct mvs_info *mvi,\n\t\t\t\t\t\tu8 reg_set)\n{\n\tu32 dev_no;\n\tfor (dev_no = 0; dev_no < MVS_MAX_DEVICES; dev_no++) {\n\t\tif (mvi->devices[dev_no].taskfileset == MVS_ID_NOT_MAPPED)\n\t\t\tcontinue;\n\n\t\tif (mvi->devices[dev_no].taskfileset == reg_set)\n\t\t\treturn &mvi->devices[dev_no];\n\t}\n\treturn NULL;\n}\n\nstatic inline void mvs_free_reg_set(struct mvs_info *mvi,\n\t\t\t\tstruct mvs_device *dev)\n{\n\tif (!dev) {\n\t\tmv_printk(\"device has been free.\\n\");\n\t\treturn;\n\t}\n\tif (dev->taskfileset == MVS_ID_NOT_MAPPED)\n\t\treturn;\n\tMVS_CHIP_DISP->free_reg_set(mvi, &dev->taskfileset);\n}\n\nstatic inline u8 mvs_assign_reg_set(struct mvs_info *mvi,\n\t\t\t\tstruct mvs_device *dev)\n{\n\tif (dev->taskfileset != MVS_ID_NOT_MAPPED)\n\t\treturn 0;\n\treturn MVS_CHIP_DISP->assign_reg_set(mvi, &dev->taskfileset);\n}\n\nvoid mvs_phys_reset(struct mvs_info *mvi, u32 phy_mask, int hard)\n{\n\tu32 no;\n\tfor_each_phy(phy_mask, phy_mask, no) {\n\t\tif (!(phy_mask & 1))\n\t\t\tcontinue;\n\t\tMVS_CHIP_DISP->phy_reset(mvi, no, hard);\n\t}\n}\n\nint mvs_phy_control(struct asd_sas_phy *sas_phy, enum phy_func func,\n\t\t\tvoid *funcdata)\n{\n\tint rc = 0, phy_id = sas_phy->id;\n\tu32 tmp, i = 0, hi;\n\tstruct sas_ha_struct *sha = sas_phy->ha;\n\tstruct mvs_info *mvi = NULL;\n\n\twhile (sha->sas_phy[i]) {\n\t\tif (sha->sas_phy[i] == sas_phy)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\thi = i/((struct mvs_prv_info *)sha->lldd_ha)->n_phy;\n\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[hi];\n\n\tswitch (func) {\n\tcase PHY_FUNC_SET_LINK_RATE:\n\t\tMVS_CHIP_DISP->phy_set_link_rate(mvi, phy_id, funcdata);\n\t\tbreak;\n\n\tcase PHY_FUNC_HARD_RESET:\n\t\ttmp = MVS_CHIP_DISP->read_phy_ctl(mvi, phy_id);\n\t\tif (tmp & PHY_RST_HARD)\n\t\t\tbreak;\n\t\tMVS_CHIP_DISP->phy_reset(mvi, phy_id, MVS_HARD_RESET);\n\t\tbreak;\n\n\tcase PHY_FUNC_LINK_RESET:\n\t\tMVS_CHIP_DISP->phy_enable(mvi, phy_id);\n\t\tMVS_CHIP_DISP->phy_reset(mvi, phy_id, MVS_SOFT_RESET);\n\t\tbreak;\n\n\tcase PHY_FUNC_DISABLE:\n\t\tMVS_CHIP_DISP->phy_disable(mvi, phy_id);\n\t\tbreak;\n\tcase PHY_FUNC_RELEASE_SPINUP_HOLD:\n\tdefault:\n\t\trc = -ENOSYS;\n\t}\n\tmsleep(200);\n\treturn rc;\n}\n\nvoid mvs_set_sas_addr(struct mvs_info *mvi, int port_id, u32 off_lo,\n\t\t      u32 off_hi, u64 sas_addr)\n{\n\tu32 lo = (u32)sas_addr;\n\tu32 hi = (u32)(sas_addr>>32);\n\n\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, port_id, off_lo);\n\tMVS_CHIP_DISP->write_port_cfg_data(mvi, port_id, lo);\n\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, port_id, off_hi);\n\tMVS_CHIP_DISP->write_port_cfg_data(mvi, port_id, hi);\n}\n\nstatic void mvs_bytes_dmaed(struct mvs_info *mvi, int i, gfp_t gfp_flags)\n{\n\tstruct mvs_phy *phy = &mvi->phy[i];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\tif (!phy->phy_attached)\n\t\treturn;\n\n\tif (!(phy->att_dev_info & PORT_DEV_TRGT_MASK)\n\t\t&& phy->phy_type & PORT_TYPE_SAS) {\n\t\treturn;\n\t}\n\n\tsas_notify_phy_event(sas_phy, PHYE_OOB_DONE, gfp_flags);\n\n\tif (sas_phy->phy) {\n\t\tstruct sas_phy *sphy = sas_phy->phy;\n\n\t\tsphy->negotiated_linkrate = sas_phy->linkrate;\n\t\tsphy->minimum_linkrate = phy->minimum_linkrate;\n\t\tsphy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\n\t\tsphy->maximum_linkrate = phy->maximum_linkrate;\n\t\tsphy->maximum_linkrate_hw = MVS_CHIP_DISP->phy_max_link_rate();\n\t}\n\n\tif (phy->phy_type & PORT_TYPE_SAS) {\n\t\tstruct sas_identify_frame *id;\n\n\t\tid = (struct sas_identify_frame *)phy->frame_rcvd;\n\t\tid->dev_type = phy->identify.device_type;\n\t\tid->initiator_bits = SAS_PROTOCOL_ALL;\n\t\tid->target_bits = phy->identify.target_port_protocols;\n\n\t\t \n\t\tif (phy->att_dev_info & PORT_SSP_TRGT_MASK) {\n\t\t\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_PHY_STAT);\n\t\t\tMVS_CHIP_DISP->write_port_cfg_data(mvi, i, 0x00);\n\t\t}\n\t} else if (phy->phy_type & PORT_TYPE_SATA) {\n\t\t \n\t}\n\tmv_dprintk(\"phy %d byte dmaded.\\n\", i + mvi->id * mvi->chip->n_phy);\n\n\tsas_phy->frame_rcvd_size = phy->frame_rcvd_size;\n\n\tsas_notify_port_event(sas_phy, PORTE_BYTES_DMAED, gfp_flags);\n}\n\nvoid mvs_scan_start(struct Scsi_Host *shost)\n{\n\tint i, j;\n\tunsigned short core_nr;\n\tstruct mvs_info *mvi;\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct mvs_prv_info *mvs_prv = sha->lldd_ha;\n\n\tcore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\n\n\tfor (j = 0; j < core_nr; j++) {\n\t\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[j];\n\t\tfor (i = 0; i < mvi->chip->n_phy; ++i)\n\t\t\tmvs_bytes_dmaed(mvi, i, GFP_KERNEL);\n\t}\n\tmvs_prv->scan_finished = 1;\n}\n\nint mvs_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tstruct mvs_prv_info *mvs_prv = sha->lldd_ha;\n\n\tif (mvs_prv->scan_finished == 0)\n\t\treturn 0;\n\n\tsas_drain_work(sha);\n\treturn 1;\n}\n\nstatic int mvs_task_prep_smp(struct mvs_info *mvi,\n\t\t\t     struct mvs_task_exec_info *tei)\n{\n\tint elem, rc, i;\n\tstruct sas_ha_struct *sha = mvi->sas;\n\tstruct sas_task *task = tei->task;\n\tstruct mvs_cmd_hdr *hdr = tei->hdr;\n\tstruct domain_device *dev = task->dev;\n\tstruct asd_sas_port *sas_port = dev->port;\n\tstruct sas_phy *sphy = dev->phy;\n\tstruct asd_sas_phy *sas_phy = sha->sas_phy[sphy->number];\n\tstruct scatterlist *sg_req, *sg_resp;\n\tu32 req_len, resp_len, tag = tei->tag;\n\tvoid *buf_tmp;\n\tu8 *buf_oaf;\n\tdma_addr_t buf_tmp_dma;\n\tvoid *buf_prd;\n\tstruct mvs_slot_info *slot = &mvi->slot_info[tag];\n\tu32 flags = (tei->n_elem << MCH_PRD_LEN_SHIFT);\n\n\t \n\tsg_req = &task->smp_task.smp_req;\n\telem = dma_map_sg(mvi->dev, sg_req, 1, DMA_TO_DEVICE);\n\tif (!elem)\n\t\treturn -ENOMEM;\n\treq_len = sg_dma_len(sg_req);\n\n\tsg_resp = &task->smp_task.smp_resp;\n\telem = dma_map_sg(mvi->dev, sg_resp, 1, DMA_FROM_DEVICE);\n\tif (!elem) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tresp_len = SB_RFB_MAX;\n\n\t \n\tif ((req_len & 0x3) || (resp_len & 0x3)) {\n\t\trc = -EINVAL;\n\t\tgoto err_out_2;\n\t}\n\n\t \n\n\t \n\tbuf_tmp = slot->buf;\n\tbuf_tmp_dma = slot->buf_dma;\n\n\thdr->cmd_tbl = cpu_to_le64(sg_dma_address(sg_req));\n\n\t \n\tbuf_oaf = buf_tmp;\n\thdr->open_frame = cpu_to_le64(buf_tmp_dma);\n\n\tbuf_tmp += MVS_OAF_SZ;\n\tbuf_tmp_dma += MVS_OAF_SZ;\n\n\t \n\tbuf_prd = buf_tmp;\n\tif (tei->n_elem)\n\t\thdr->prd_tbl = cpu_to_le64(buf_tmp_dma);\n\telse\n\t\thdr->prd_tbl = 0;\n\n\ti = MVS_CHIP_DISP->prd_size() * tei->n_elem;\n\tbuf_tmp += i;\n\tbuf_tmp_dma += i;\n\n\t \n\tslot->response = buf_tmp;\n\thdr->status_buf = cpu_to_le64(buf_tmp_dma);\n\tif (mvi->flags & MVF_FLAG_SOC)\n\t\thdr->reserved[0] = 0;\n\n\t \n\tslot->tx = mvi->tx_prod;\n\tmvi->tx[mvi->tx_prod] = cpu_to_le32((TXQ_CMD_SMP << TXQ_CMD_SHIFT) |\n\t\t\t\t\tTXQ_MODE_I | tag |\n\t\t\t\t\t(MVS_PHY_ID << TXQ_PHY_SHIFT));\n\n\thdr->flags |= flags;\n\thdr->lens = cpu_to_le32(((resp_len / 4) << 16) | ((req_len - 4) / 4));\n\thdr->tags = cpu_to_le32(tag);\n\thdr->data_len = 0;\n\n\t \n\t \n\tbuf_oaf[0] = (1 << 7) | (PROTOCOL_SMP << 4) | 0x01;\n\tbuf_oaf[1] = min(sas_port->linkrate, dev->linkrate) & 0xf;\n\t*(u16 *)(buf_oaf + 2) = 0xFFFF;\t\t \n\tmemcpy(buf_oaf + 4, dev->sas_addr, SAS_ADDR_SIZE);\n\n\t \n\tMVS_CHIP_DISP->make_prd(task->scatter, tei->n_elem, buf_prd);\n\n\treturn 0;\n\nerr_out_2:\n\tdma_unmap_sg(mvi->dev, &tei->task->smp_task.smp_resp, 1,\n\t\t     DMA_FROM_DEVICE);\nerr_out:\n\tdma_unmap_sg(mvi->dev, &tei->task->smp_task.smp_req, 1,\n\t\t     DMA_TO_DEVICE);\n\treturn rc;\n}\n\nstatic u32 mvs_get_ncq_tag(struct sas_task *task, u32 *tag)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\n\tif (qc) {\n\t\tif (qc->tf.command == ATA_CMD_FPDMA_WRITE ||\n\t\t    qc->tf.command == ATA_CMD_FPDMA_READ ||\n\t\t    qc->tf.command == ATA_CMD_FPDMA_RECV ||\n\t\t    qc->tf.command == ATA_CMD_FPDMA_SEND ||\n\t\t    qc->tf.command == ATA_CMD_NCQ_NON_DATA) {\n\t\t\t*tag = qc->tag;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mvs_task_prep_ata(struct mvs_info *mvi,\n\t\t\t     struct mvs_task_exec_info *tei)\n{\n\tstruct sas_task *task = tei->task;\n\tstruct domain_device *dev = task->dev;\n\tstruct mvs_device *mvi_dev = dev->lldd_dev;\n\tstruct mvs_cmd_hdr *hdr = tei->hdr;\n\tstruct asd_sas_port *sas_port = dev->port;\n\tstruct mvs_slot_info *slot;\n\tvoid *buf_prd;\n\tu32 tag = tei->tag, hdr_tag;\n\tu32 flags, del_q;\n\tvoid *buf_tmp;\n\tu8 *buf_cmd, *buf_oaf;\n\tdma_addr_t buf_tmp_dma;\n\tu32 i, req_len, resp_len;\n\tconst u32 max_resp_len = SB_RFB_MAX;\n\n\tif (mvs_assign_reg_set(mvi, mvi_dev) == MVS_ID_NOT_MAPPED) {\n\t\tmv_dprintk(\"Have not enough regiset for dev %d.\\n\",\n\t\t\tmvi_dev->device_id);\n\t\treturn -EBUSY;\n\t}\n\tslot = &mvi->slot_info[tag];\n\tslot->tx = mvi->tx_prod;\n\tdel_q = TXQ_MODE_I | tag |\n\t\t(TXQ_CMD_STP << TXQ_CMD_SHIFT) |\n\t\t((sas_port->phy_mask & TXQ_PHY_MASK) << TXQ_PHY_SHIFT) |\n\t\t(mvi_dev->taskfileset << TXQ_SRS_SHIFT);\n\tmvi->tx[mvi->tx_prod] = cpu_to_le32(del_q);\n\n\tif (task->data_dir == DMA_FROM_DEVICE)\n\t\tflags = (MVS_CHIP_DISP->prd_count() << MCH_PRD_LEN_SHIFT);\n\telse\n\t\tflags = (tei->n_elem << MCH_PRD_LEN_SHIFT);\n\n\tif (task->ata_task.use_ncq)\n\t\tflags |= MCH_FPDMA;\n\tif (dev->sata_dev.class == ATA_DEV_ATAPI) {\n\t\tif (task->ata_task.fis.command != ATA_CMD_ID_ATAPI)\n\t\t\tflags |= MCH_ATAPI;\n\t}\n\n\thdr->flags = cpu_to_le32(flags);\n\n\tif (task->ata_task.use_ncq && mvs_get_ncq_tag(task, &hdr_tag))\n\t\ttask->ata_task.fis.sector_count |= (u8) (hdr_tag << 3);\n\telse\n\t\thdr_tag = tag;\n\n\thdr->tags = cpu_to_le32(hdr_tag);\n\n\thdr->data_len = cpu_to_le32(task->total_xfer_len);\n\n\t \n\n\t \n\tbuf_cmd = buf_tmp = slot->buf;\n\tbuf_tmp_dma = slot->buf_dma;\n\n\thdr->cmd_tbl = cpu_to_le64(buf_tmp_dma);\n\n\tbuf_tmp += MVS_ATA_CMD_SZ;\n\tbuf_tmp_dma += MVS_ATA_CMD_SZ;\n\n\t \n\t \n\tbuf_oaf = buf_tmp;\n\thdr->open_frame = cpu_to_le64(buf_tmp_dma);\n\n\tbuf_tmp += MVS_OAF_SZ;\n\tbuf_tmp_dma += MVS_OAF_SZ;\n\n\t \n\tbuf_prd = buf_tmp;\n\n\tif (tei->n_elem)\n\t\thdr->prd_tbl = cpu_to_le64(buf_tmp_dma);\n\telse\n\t\thdr->prd_tbl = 0;\n\ti = MVS_CHIP_DISP->prd_size() * MVS_CHIP_DISP->prd_count();\n\n\tbuf_tmp += i;\n\tbuf_tmp_dma += i;\n\n\t \n\tslot->response = buf_tmp;\n\thdr->status_buf = cpu_to_le64(buf_tmp_dma);\n\tif (mvi->flags & MVF_FLAG_SOC)\n\t\thdr->reserved[0] = 0;\n\n\treq_len = sizeof(struct host_to_dev_fis);\n\tresp_len = MVS_SLOT_BUF_SZ - MVS_ATA_CMD_SZ -\n\t    sizeof(struct mvs_err_info) - i;\n\n\t \n\tresp_len = min(resp_len, max_resp_len);\n\thdr->lens = cpu_to_le32(((resp_len / 4) << 16) | (req_len / 4));\n\n\tif (likely(!task->ata_task.device_control_reg_update))\n\t\ttask->ata_task.fis.flags |= 0x80;  \n\t \n\tmemcpy(buf_cmd, &task->ata_task.fis, sizeof(struct host_to_dev_fis));\n\tif (dev->sata_dev.class == ATA_DEV_ATAPI)\n\t\tmemcpy(buf_cmd + STP_ATAPI_CMD,\n\t\t\ttask->ata_task.atapi_packet, 16);\n\n\t \n\t \n\tbuf_oaf[0] = (1 << 7) | (PROTOCOL_STP << 4) | 0x1;\n\tbuf_oaf[1] = min(sas_port->linkrate, dev->linkrate) & 0xf;\n\t*(u16 *)(buf_oaf + 2) = cpu_to_be16(mvi_dev->device_id + 1);\n\tmemcpy(buf_oaf + 4, dev->sas_addr, SAS_ADDR_SIZE);\n\n\t \n\tMVS_CHIP_DISP->make_prd(task->scatter, tei->n_elem, buf_prd);\n\n\tif (task->data_dir == DMA_FROM_DEVICE)\n\t\tMVS_CHIP_DISP->dma_fix(mvi, sas_port->phy_mask,\n\t\t\t\tTRASH_BUCKET_SIZE, tei->n_elem, buf_prd);\n\n\treturn 0;\n}\n\nstatic int mvs_task_prep_ssp(struct mvs_info *mvi,\n\t\t\t     struct mvs_task_exec_info *tei, int is_tmf,\n\t\t\t     struct sas_tmf_task *tmf)\n{\n\tstruct sas_task *task = tei->task;\n\tstruct mvs_cmd_hdr *hdr = tei->hdr;\n\tstruct mvs_port *port = tei->port;\n\tstruct domain_device *dev = task->dev;\n\tstruct mvs_device *mvi_dev = dev->lldd_dev;\n\tstruct asd_sas_port *sas_port = dev->port;\n\tstruct mvs_slot_info *slot;\n\tvoid *buf_prd;\n\tstruct ssp_frame_hdr *ssp_hdr;\n\tvoid *buf_tmp;\n\tu8 *buf_cmd, *buf_oaf;\n\tdma_addr_t buf_tmp_dma;\n\tu32 flags;\n\tu32 resp_len, req_len, i, tag = tei->tag;\n\tconst u32 max_resp_len = SB_RFB_MAX;\n\tu32 phy_mask;\n\n\tslot = &mvi->slot_info[tag];\n\n\tphy_mask = ((port->wide_port_phymap) ? port->wide_port_phymap :\n\t\tsas_port->phy_mask) & TXQ_PHY_MASK;\n\n\tslot->tx = mvi->tx_prod;\n\tmvi->tx[mvi->tx_prod] = cpu_to_le32(TXQ_MODE_I | tag |\n\t\t\t\t(TXQ_CMD_SSP << TXQ_CMD_SHIFT) |\n\t\t\t\t(phy_mask << TXQ_PHY_SHIFT));\n\n\tflags = MCH_RETRY;\n\tif (is_tmf)\n\t\tflags |= (MCH_SSP_FR_TASK << MCH_SSP_FR_TYPE_SHIFT);\n\telse\n\t\tflags |= (MCH_SSP_FR_CMD << MCH_SSP_FR_TYPE_SHIFT);\n\n\thdr->flags = cpu_to_le32(flags | (tei->n_elem << MCH_PRD_LEN_SHIFT));\n\thdr->tags = cpu_to_le32(tag);\n\thdr->data_len = cpu_to_le32(task->total_xfer_len);\n\n\t \n\n\t \n\tbuf_cmd = buf_tmp = slot->buf;\n\tbuf_tmp_dma = slot->buf_dma;\n\n\thdr->cmd_tbl = cpu_to_le64(buf_tmp_dma);\n\n\tbuf_tmp += MVS_SSP_CMD_SZ;\n\tbuf_tmp_dma += MVS_SSP_CMD_SZ;\n\n\t \n\tbuf_oaf = buf_tmp;\n\thdr->open_frame = cpu_to_le64(buf_tmp_dma);\n\n\tbuf_tmp += MVS_OAF_SZ;\n\tbuf_tmp_dma += MVS_OAF_SZ;\n\n\t \n\tbuf_prd = buf_tmp;\n\tif (tei->n_elem)\n\t\thdr->prd_tbl = cpu_to_le64(buf_tmp_dma);\n\telse\n\t\thdr->prd_tbl = 0;\n\n\ti = MVS_CHIP_DISP->prd_size() * tei->n_elem;\n\tbuf_tmp += i;\n\tbuf_tmp_dma += i;\n\n\t \n\tslot->response = buf_tmp;\n\thdr->status_buf = cpu_to_le64(buf_tmp_dma);\n\tif (mvi->flags & MVF_FLAG_SOC)\n\t\thdr->reserved[0] = 0;\n\n\tresp_len = MVS_SLOT_BUF_SZ - MVS_SSP_CMD_SZ - MVS_OAF_SZ -\n\t    sizeof(struct mvs_err_info) - i;\n\tresp_len = min(resp_len, max_resp_len);\n\n\treq_len = sizeof(struct ssp_frame_hdr) + 28;\n\n\t \n\thdr->lens = cpu_to_le32(((resp_len / 4) << 16) | (req_len / 4));\n\n\t \n\t \n\tbuf_oaf[0] = (1 << 7) | (PROTOCOL_SSP << 4) | 0x1;\n\tbuf_oaf[1] = min(sas_port->linkrate, dev->linkrate) & 0xf;\n\t*(u16 *)(buf_oaf + 2) = cpu_to_be16(mvi_dev->device_id + 1);\n\tmemcpy(buf_oaf + 4, dev->sas_addr, SAS_ADDR_SIZE);\n\n\t \n\tssp_hdr = (struct ssp_frame_hdr *)buf_cmd;\n\n\tif (is_tmf)\n\t\tssp_hdr->frame_type = SSP_TASK;\n\telse\n\t\tssp_hdr->frame_type = SSP_COMMAND;\n\n\tmemcpy(ssp_hdr->hashed_dest_addr, dev->hashed_sas_addr,\n\t       HASHED_SAS_ADDR_SIZE);\n\tmemcpy(ssp_hdr->hashed_src_addr,\n\t       dev->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\n\tssp_hdr->tag = cpu_to_be16(tag);\n\n\t \n\tbuf_cmd += sizeof(*ssp_hdr);\n\tmemcpy(buf_cmd, &task->ssp_task.LUN, 8);\n\n\tif (ssp_hdr->frame_type != SSP_TASK) {\n\t\tbuf_cmd[9] = task->ssp_task.task_attr;\n\t\tmemcpy(buf_cmd + 12, task->ssp_task.cmd->cmnd,\n\t\t       task->ssp_task.cmd->cmd_len);\n\t} else{\n\t\tbuf_cmd[10] = tmf->tmf;\n\t\tswitch (tmf->tmf) {\n\t\tcase TMF_ABORT_TASK:\n\t\tcase TMF_QUERY_TASK:\n\t\t\tbuf_cmd[12] =\n\t\t\t\t(tmf->tag_of_task_to_be_managed >> 8) & 0xff;\n\t\t\tbuf_cmd[13] =\n\t\t\t\ttmf->tag_of_task_to_be_managed & 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tMVS_CHIP_DISP->make_prd(task->scatter, tei->n_elem, buf_prd);\n\treturn 0;\n}\n\n#define\tDEV_IS_GONE(mvi_dev)\t((!mvi_dev || (mvi_dev->dev_type == SAS_PHY_UNUSED)))\nstatic int mvs_task_prep(struct sas_task *task, struct mvs_info *mvi, int is_tmf,\n\t\t\t\tstruct sas_tmf_task *tmf, int *pass)\n{\n\tstruct domain_device *dev = task->dev;\n\tstruct mvs_device *mvi_dev = dev->lldd_dev;\n\tstruct mvs_task_exec_info tei;\n\tstruct mvs_slot_info *slot;\n\tu32 tag = 0xdeadbeef, n_elem = 0;\n\tstruct request *rq;\n\tint rc = 0;\n\n\tif (!dev->port) {\n\t\tstruct task_status_struct *tsm = &task->task_status;\n\n\t\ttsm->resp = SAS_TASK_UNDELIVERED;\n\t\ttsm->stat = SAS_PHY_DOWN;\n\t\t \n\t\tif (dev->dev_type != SAS_SATA_DEV)\n\t\t\ttask->task_done(task);\n\t\treturn rc;\n\t}\n\n\tif (DEV_IS_GONE(mvi_dev)) {\n\t\tif (mvi_dev)\n\t\t\tmv_dprintk(\"device %d not ready.\\n\",\n\t\t\t\tmvi_dev->device_id);\n\t\telse\n\t\t\tmv_dprintk(\"device %016llx not ready.\\n\",\n\t\t\t\tSAS_ADDR(dev->sas_addr));\n\n\t\trc = SAS_PHY_DOWN;\n\t\treturn rc;\n\t}\n\ttei.port = dev->port->lldd_port;\n\tif (tei.port && !tei.port->port_attached && !tmf) {\n\t\tif (sas_protocol_ata(task->task_proto)) {\n\t\t\tstruct task_status_struct *ts = &task->task_status;\n\t\t\tmv_dprintk(\"SATA/STP port %d does not attach\"\n\t\t\t\t\t\"device.\\n\", dev->port->id);\n\t\t\tts->resp = SAS_TASK_COMPLETE;\n\t\t\tts->stat = SAS_PHY_DOWN;\n\n\t\t\ttask->task_done(task);\n\n\t\t} else {\n\t\t\tstruct task_status_struct *ts = &task->task_status;\n\t\t\tmv_dprintk(\"SAS port %d does not attach\"\n\t\t\t\t\"device.\\n\", dev->port->id);\n\t\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\t\tts->stat = SAS_PHY_DOWN;\n\t\t\ttask->task_done(task);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tif (!sas_protocol_ata(task->task_proto)) {\n\t\tif (task->num_scatter) {\n\t\t\tn_elem = dma_map_sg(mvi->dev,\n\t\t\t\t\t    task->scatter,\n\t\t\t\t\t    task->num_scatter,\n\t\t\t\t\t    task->data_dir);\n\t\t\tif (!n_elem) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto prep_out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tn_elem = task->num_scatter;\n\t}\n\n\trq = sas_task_find_rq(task);\n\tif (rq) {\n\t\ttag = rq->tag + MVS_RSVD_SLOTS;\n\t} else {\n\t\trc = mvs_tag_alloc(mvi, &tag);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\t}\n\n\tslot = &mvi->slot_info[tag];\n\n\ttask->lldd_task = NULL;\n\tslot->n_elem = n_elem;\n\tslot->slot_tag = tag;\n\n\tslot->buf = dma_pool_zalloc(mvi->dma_pool, GFP_ATOMIC, &slot->buf_dma);\n\tif (!slot->buf) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_tag;\n\t}\n\n\ttei.task = task;\n\ttei.hdr = &mvi->slot[tag];\n\ttei.tag = tag;\n\ttei.n_elem = n_elem;\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SMP:\n\t\trc = mvs_task_prep_smp(mvi, &tei);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SSP:\n\t\trc = mvs_task_prep_ssp(mvi, &tei, is_tmf, tmf);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t\trc = mvs_task_prep_ata(mvi, &tei);\n\t\tbreak;\n\tdefault:\n\t\tdev_printk(KERN_ERR, mvi->dev,\n\t\t\t\"unknown sas_task proto: 0x%x\\n\",\n\t\t\ttask->task_proto);\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (rc) {\n\t\tmv_dprintk(\"rc is %x\\n\", rc);\n\t\tgoto err_out_slot_buf;\n\t}\n\tslot->task = task;\n\tslot->port = tei.port;\n\ttask->lldd_task = slot;\n\tlist_add_tail(&slot->entry, &tei.port->list);\n\n\tmvi_dev->running_req++;\n\t++(*pass);\n\tmvi->tx_prod = (mvi->tx_prod + 1) & (MVS_CHIP_SLOT_SZ - 1);\n\n\treturn rc;\n\nerr_out_slot_buf:\n\tdma_pool_free(mvi->dma_pool, slot->buf, slot->buf_dma);\nerr_out_tag:\n\tmvs_tag_free(mvi, tag);\nerr_out:\n\n\tdev_printk(KERN_ERR, mvi->dev, \"mvsas prep failed[%d]!\\n\", rc);\n\tif (!sas_protocol_ata(task->task_proto))\n\t\tif (n_elem)\n\t\t\tdma_unmap_sg(mvi->dev, task->scatter, n_elem,\n\t\t\t\t     task->data_dir);\nprep_out:\n\treturn rc;\n}\n\nint mvs_queue_command(struct sas_task *task, gfp_t gfp_flags)\n{\n\tstruct mvs_info *mvi = NULL;\n\tu32 rc = 0;\n\tu32 pass = 0;\n\tunsigned long flags = 0;\n\tstruct sas_tmf_task *tmf = task->tmf;\n\tint is_tmf = !!task->tmf;\n\n\tmvi = ((struct mvs_device *)task->dev->lldd_dev)->mvi_info;\n\n\tspin_lock_irqsave(&mvi->lock, flags);\n\trc = mvs_task_prep(task, mvi, is_tmf, tmf, &pass);\n\tif (rc)\n\t\tdev_printk(KERN_ERR, mvi->dev, \"mvsas exec failed[%d]!\\n\", rc);\n\n\tif (likely(pass))\n\t\t\tMVS_CHIP_DISP->start_delivery(mvi, (mvi->tx_prod - 1) &\n\t\t\t\t(MVS_CHIP_SLOT_SZ - 1));\n\tspin_unlock_irqrestore(&mvi->lock, flags);\n\n\treturn rc;\n}\n\nstatic void mvs_slot_free(struct mvs_info *mvi, u32 rx_desc)\n{\n\tu32 slot_idx = rx_desc & RXQ_SLOT_MASK;\n\tmvs_tag_free(mvi, slot_idx);\n}\n\nstatic void mvs_slot_task_free(struct mvs_info *mvi, struct sas_task *task,\n\t\t\t  struct mvs_slot_info *slot, u32 slot_idx)\n{\n\tif (!slot)\n\t\treturn;\n\tif (!slot->task)\n\t\treturn;\n\tif (!sas_protocol_ata(task->task_proto))\n\t\tif (slot->n_elem)\n\t\t\tdma_unmap_sg(mvi->dev, task->scatter,\n\t\t\t\t     slot->n_elem, task->data_dir);\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SMP:\n\t\tdma_unmap_sg(mvi->dev, &task->smp_task.smp_resp, 1,\n\t\t\t     DMA_FROM_DEVICE);\n\t\tdma_unmap_sg(mvi->dev, &task->smp_task.smp_req, 1,\n\t\t\t     DMA_TO_DEVICE);\n\t\tbreak;\n\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SSP:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (slot->buf) {\n\t\tdma_pool_free(mvi->dma_pool, slot->buf, slot->buf_dma);\n\t\tslot->buf = NULL;\n\t}\n\tlist_del_init(&slot->entry);\n\ttask->lldd_task = NULL;\n\tslot->task = NULL;\n\tslot->port = NULL;\n\tslot->slot_tag = 0xFFFFFFFF;\n\tmvs_slot_free(mvi, slot_idx);\n}\n\nstatic void mvs_update_wideport(struct mvs_info *mvi, int phy_no)\n{\n\tstruct mvs_phy *phy = &mvi->phy[phy_no];\n\tstruct mvs_port *port = phy->port;\n\tint j, no;\n\n\tfor_each_phy(port->wide_port_phymap, j, no) {\n\t\tif (j & 1) {\n\t\t\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, no,\n\t\t\t\t\t\tPHYR_WIDE_PORT);\n\t\t\tMVS_CHIP_DISP->write_port_cfg_data(mvi, no,\n\t\t\t\t\t\tport->wide_port_phymap);\n\t\t} else {\n\t\t\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, no,\n\t\t\t\t\t\tPHYR_WIDE_PORT);\n\t\t\tMVS_CHIP_DISP->write_port_cfg_data(mvi, no,\n\t\t\t\t\t\t0);\n\t\t}\n\t}\n}\n\nstatic u32 mvs_is_phy_ready(struct mvs_info *mvi, int i)\n{\n\tu32 tmp;\n\tstruct mvs_phy *phy = &mvi->phy[i];\n\tstruct mvs_port *port = phy->port;\n\n\ttmp = MVS_CHIP_DISP->read_phy_ctl(mvi, i);\n\tif ((tmp & PHY_READY_MASK) && !(phy->irq_status & PHYEV_POOF)) {\n\t\tif (!port)\n\t\t\tphy->phy_attached = 1;\n\t\treturn tmp;\n\t}\n\n\tif (port) {\n\t\tif (phy->phy_type & PORT_TYPE_SAS) {\n\t\t\tport->wide_port_phymap &= ~(1U << i);\n\t\t\tif (!port->wide_port_phymap)\n\t\t\t\tport->port_attached = 0;\n\t\t\tmvs_update_wideport(mvi, i);\n\t\t} else if (phy->phy_type & PORT_TYPE_SATA)\n\t\t\tport->port_attached = 0;\n\t\tphy->port = NULL;\n\t\tphy->phy_attached = 0;\n\t\tphy->phy_type &= ~(PORT_TYPE_SAS | PORT_TYPE_SATA);\n\t}\n\treturn 0;\n}\n\nstatic void *mvs_get_d2h_reg(struct mvs_info *mvi, int i, void *buf)\n{\n\tu32 *s = (u32 *) buf;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_SATA_SIG3);\n\ts[3] = cpu_to_le32(MVS_CHIP_DISP->read_port_cfg_data(mvi, i));\n\n\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_SATA_SIG2);\n\ts[2] = cpu_to_le32(MVS_CHIP_DISP->read_port_cfg_data(mvi, i));\n\n\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_SATA_SIG1);\n\ts[1] = cpu_to_le32(MVS_CHIP_DISP->read_port_cfg_data(mvi, i));\n\n\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_SATA_SIG0);\n\ts[0] = cpu_to_le32(MVS_CHIP_DISP->read_port_cfg_data(mvi, i));\n\n\tif (((s[1] & 0x00FFFFFF) == 0x00EB1401) && (*(u8 *)&s[3] == 0x01))\n\t\ts[1] = 0x00EB1401 | (*((u8 *)&s[1] + 3) & 0x10);\n\n\treturn s;\n}\n\nstatic u32 mvs_is_sig_fis_received(u32 irq_status)\n{\n\treturn irq_status & PHYEV_SIG_FIS;\n}\n\nstatic void mvs_sig_remove_timer(struct mvs_phy *phy)\n{\n\tif (phy->timer.function)\n\t\tdel_timer(&phy->timer);\n\tphy->timer.function = NULL;\n}\n\nvoid mvs_update_phyinfo(struct mvs_info *mvi, int i, int get_st)\n{\n\tstruct mvs_phy *phy = &mvi->phy[i];\n\tstruct sas_identify_frame *id;\n\n\tid = (struct sas_identify_frame *)phy->frame_rcvd;\n\n\tif (get_st) {\n\t\tphy->irq_status = MVS_CHIP_DISP->read_port_irq_stat(mvi, i);\n\t\tphy->phy_status = mvs_is_phy_ready(mvi, i);\n\t}\n\n\tif (phy->phy_status) {\n\t\tint oob_done = 0;\n\t\tstruct asd_sas_phy *sas_phy = &mvi->phy[i].sas_phy;\n\n\t\toob_done = MVS_CHIP_DISP->oob_done(mvi, i);\n\n\t\tMVS_CHIP_DISP->fix_phy_info(mvi, i, id);\n\t\tif (phy->phy_type & PORT_TYPE_SATA) {\n\t\t\tphy->identify.target_port_protocols = SAS_PROTOCOL_STP;\n\t\t\tif (mvs_is_sig_fis_received(phy->irq_status)) {\n\t\t\t\tmvs_sig_remove_timer(phy);\n\t\t\t\tphy->phy_attached = 1;\n\t\t\t\tphy->att_dev_sas_addr =\n\t\t\t\t\ti + mvi->id * mvi->chip->n_phy;\n\t\t\t\tif (oob_done)\n\t\t\t\t\tsas_phy->oob_mode = SATA_OOB_MODE;\n\t\t\t\tphy->frame_rcvd_size =\n\t\t\t\t    sizeof(struct dev_to_host_fis);\n\t\t\t\tmvs_get_d2h_reg(mvi, i, id);\n\t\t\t} else {\n\t\t\t\tu32 tmp;\n\t\t\t\tdev_printk(KERN_DEBUG, mvi->dev,\n\t\t\t\t\t\"Phy%d : No sig fis\\n\", i);\n\t\t\t\ttmp = MVS_CHIP_DISP->read_port_irq_mask(mvi, i);\n\t\t\t\tMVS_CHIP_DISP->write_port_irq_mask(mvi, i,\n\t\t\t\t\t\ttmp | PHYEV_SIG_FIS);\n\t\t\t\tphy->phy_attached = 0;\n\t\t\t\tphy->phy_type &= ~PORT_TYPE_SATA;\n\t\t\t\tgoto out_done;\n\t\t\t}\n\t\t}\telse if (phy->phy_type & PORT_TYPE_SAS\n\t\t\t|| phy->att_dev_info & PORT_SSP_INIT_MASK) {\n\t\t\tphy->phy_attached = 1;\n\t\t\tphy->identify.device_type =\n\t\t\t\tphy->att_dev_info & PORT_DEV_TYPE_MASK;\n\n\t\t\tif (phy->identify.device_type == SAS_END_DEVICE)\n\t\t\t\tphy->identify.target_port_protocols =\n\t\t\t\t\t\t\tSAS_PROTOCOL_SSP;\n\t\t\telse if (phy->identify.device_type != SAS_PHY_UNUSED)\n\t\t\t\tphy->identify.target_port_protocols =\n\t\t\t\t\t\t\tSAS_PROTOCOL_SMP;\n\t\t\tif (oob_done)\n\t\t\t\tsas_phy->oob_mode = SAS_OOB_MODE;\n\t\t\tphy->frame_rcvd_size =\n\t\t\t    sizeof(struct sas_identify_frame);\n\t\t}\n\t\tmemcpy(sas_phy->attached_sas_addr,\n\t\t\t&phy->att_dev_sas_addr, SAS_ADDR_SIZE);\n\n\t\tif (MVS_CHIP_DISP->phy_work_around)\n\t\t\tMVS_CHIP_DISP->phy_work_around(mvi, i);\n\t}\n\tmv_dprintk(\"phy %d attach dev info is %x\\n\",\n\t\ti + mvi->id * mvi->chip->n_phy, phy->att_dev_info);\n\tmv_dprintk(\"phy %d attach sas addr is %llx\\n\",\n\t\ti + mvi->id * mvi->chip->n_phy, phy->att_dev_sas_addr);\nout_done:\n\tif (get_st)\n\t\tMVS_CHIP_DISP->write_port_irq_stat(mvi, i, phy->irq_status);\n}\n\nstatic void mvs_port_notify_formed(struct asd_sas_phy *sas_phy, int lock)\n{\n\tstruct sas_ha_struct *sas_ha = sas_phy->ha;\n\tstruct mvs_info *mvi = NULL; int i = 0, hi;\n\tstruct mvs_phy *phy = sas_phy->lldd_phy;\n\tstruct asd_sas_port *sas_port = sas_phy->port;\n\tstruct mvs_port *port;\n\tunsigned long flags = 0;\n\tif (!sas_port)\n\t\treturn;\n\n\twhile (sas_ha->sas_phy[i]) {\n\t\tif (sas_ha->sas_phy[i] == sas_phy)\n\t\t\tbreak;\n\t\ti++;\n\t}\n\thi = i/((struct mvs_prv_info *)sas_ha->lldd_ha)->n_phy;\n\tmvi = ((struct mvs_prv_info *)sas_ha->lldd_ha)->mvi[hi];\n\tif (i >= mvi->chip->n_phy)\n\t\tport = &mvi->port[i - mvi->chip->n_phy];\n\telse\n\t\tport = &mvi->port[i];\n\tif (lock)\n\t\tspin_lock_irqsave(&mvi->lock, flags);\n\tport->port_attached = 1;\n\tphy->port = port;\n\tsas_port->lldd_port = port;\n\tif (phy->phy_type & PORT_TYPE_SAS) {\n\t\tport->wide_port_phymap = sas_port->phy_mask;\n\t\tmv_printk(\"set wide port phy map %x\\n\", sas_port->phy_mask);\n\t\tmvs_update_wideport(mvi, sas_phy->id);\n\n\t\t \n\t\tif (phy->att_dev_info & PORT_SSP_TRGT_MASK) {\n\t\t\tMVS_CHIP_DISP->write_port_cfg_addr(mvi, i, PHYR_PHY_STAT);\n\t\t\tMVS_CHIP_DISP->write_port_cfg_data(mvi, i, 0x04);\n\t\t}\n\t}\n\tif (lock)\n\t\tspin_unlock_irqrestore(&mvi->lock, flags);\n}\n\nstatic void mvs_port_notify_deformed(struct asd_sas_phy *sas_phy, int lock)\n{\n\tstruct domain_device *dev;\n\tstruct mvs_phy *phy = sas_phy->lldd_phy;\n\tstruct mvs_info *mvi = phy->mvi;\n\tstruct asd_sas_port *port = sas_phy->port;\n\tint phy_no = 0;\n\n\twhile (phy != &mvi->phy[phy_no]) {\n\t\tphy_no++;\n\t\tif (phy_no >= MVS_MAX_PHYS)\n\t\t\treturn;\n\t}\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node)\n\t\tmvs_do_release_task(phy->mvi, phy_no, dev);\n\n}\n\n\nvoid mvs_port_formed(struct asd_sas_phy *sas_phy)\n{\n\tmvs_port_notify_formed(sas_phy, 1);\n}\n\nvoid mvs_port_deformed(struct asd_sas_phy *sas_phy)\n{\n\tmvs_port_notify_deformed(sas_phy, 1);\n}\n\nstatic struct mvs_device *mvs_alloc_dev(struct mvs_info *mvi)\n{\n\tu32 dev;\n\tfor (dev = 0; dev < MVS_MAX_DEVICES; dev++) {\n\t\tif (mvi->devices[dev].dev_type == SAS_PHY_UNUSED) {\n\t\t\tmvi->devices[dev].device_id = dev;\n\t\t\treturn &mvi->devices[dev];\n\t\t}\n\t}\n\n\tif (dev == MVS_MAX_DEVICES)\n\t\tmv_printk(\"max support %d devices, ignore ..\\n\",\n\t\t\tMVS_MAX_DEVICES);\n\n\treturn NULL;\n}\n\nstatic void mvs_free_dev(struct mvs_device *mvi_dev)\n{\n\tu32 id = mvi_dev->device_id;\n\tmemset(mvi_dev, 0, sizeof(*mvi_dev));\n\tmvi_dev->device_id = id;\n\tmvi_dev->dev_type = SAS_PHY_UNUSED;\n\tmvi_dev->dev_status = MVS_DEV_NORMAL;\n\tmvi_dev->taskfileset = MVS_ID_NOT_MAPPED;\n}\n\nstatic int mvs_dev_found_notify(struct domain_device *dev, int lock)\n{\n\tunsigned long flags = 0;\n\tint res = 0;\n\tstruct mvs_info *mvi = NULL;\n\tstruct domain_device *parent_dev = dev->parent;\n\tstruct mvs_device *mvi_device;\n\n\tmvi = mvs_find_dev_mvi(dev);\n\n\tif (lock)\n\t\tspin_lock_irqsave(&mvi->lock, flags);\n\n\tmvi_device = mvs_alloc_dev(mvi);\n\tif (!mvi_device) {\n\t\tres = -1;\n\t\tgoto found_out;\n\t}\n\tdev->lldd_dev = mvi_device;\n\tmvi_device->dev_status = MVS_DEV_NORMAL;\n\tmvi_device->dev_type = dev->dev_type;\n\tmvi_device->mvi_info = mvi;\n\tmvi_device->sas_device = dev;\n\tif (parent_dev && dev_is_expander(parent_dev->dev_type)) {\n\t\tint phy_id;\n\n\t\tphy_id = sas_find_attached_phy_id(&parent_dev->ex_dev, dev);\n\t\tif (phy_id < 0) {\n\t\t\tmv_printk(\"Error: no attached dev:%016llx\"\n\t\t\t\t\"at ex:%016llx.\\n\",\n\t\t\t\tSAS_ADDR(dev->sas_addr),\n\t\t\t\tSAS_ADDR(parent_dev->sas_addr));\n\t\t\tres = phy_id;\n\t\t} else {\n\t\t\tmvi_device->attached_phy = phy_id;\n\t\t}\n\t}\n\nfound_out:\n\tif (lock)\n\t\tspin_unlock_irqrestore(&mvi->lock, flags);\n\treturn res;\n}\n\nint mvs_dev_found(struct domain_device *dev)\n{\n\treturn mvs_dev_found_notify(dev, 1);\n}\n\nstatic void mvs_dev_gone_notify(struct domain_device *dev)\n{\n\tunsigned long flags = 0;\n\tstruct mvs_device *mvi_dev = dev->lldd_dev;\n\tstruct mvs_info *mvi;\n\n\tif (!mvi_dev) {\n\t\tmv_dprintk(\"found dev has gone.\\n\");\n\t\treturn;\n\t}\n\n\tmvi = mvi_dev->mvi_info;\n\n\tspin_lock_irqsave(&mvi->lock, flags);\n\n\tmv_dprintk(\"found dev[%d:%x] is gone.\\n\",\n\t\tmvi_dev->device_id, mvi_dev->dev_type);\n\tmvs_release_task(mvi, dev);\n\tmvs_free_reg_set(mvi, mvi_dev);\n\tmvs_free_dev(mvi_dev);\n\n\tdev->lldd_dev = NULL;\n\tmvi_dev->sas_device = NULL;\n\n\tspin_unlock_irqrestore(&mvi->lock, flags);\n}\n\n\nvoid mvs_dev_gone(struct domain_device *dev)\n{\n\tmvs_dev_gone_notify(dev);\n}\n\n \nstatic int mvs_debug_I_T_nexus_reset(struct domain_device *dev)\n{\n\tint rc;\n\tstruct sas_phy *phy = sas_get_local_phy(dev);\n\tint reset_type = (dev->dev_type == SAS_SATA_DEV ||\n\t\t\t(dev->tproto & SAS_PROTOCOL_STP)) ? 0 : 1;\n\trc = sas_phy_reset(phy, reset_type);\n\tsas_put_local_phy(phy);\n\tmsleep(2000);\n\treturn rc;\n}\n\n \nint mvs_lu_reset(struct domain_device *dev, u8 *lun)\n{\n\tunsigned long flags;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tstruct mvs_device * mvi_dev = dev->lldd_dev;\n\tstruct mvs_info *mvi = mvi_dev->mvi_info;\n\n\tmvi_dev->dev_status = MVS_DEV_EH;\n\trc = sas_lu_reset(dev, lun);\n\tif (rc == TMF_RESP_FUNC_COMPLETE) {\n\t\tspin_lock_irqsave(&mvi->lock, flags);\n\t\tmvs_release_task(mvi, dev);\n\t\tspin_unlock_irqrestore(&mvi->lock, flags);\n\t}\n\t \n\tmv_printk(\"%s for device[%x]:rc= %d\\n\", __func__,\n\t\t\tmvi_dev->device_id, rc);\n\treturn rc;\n}\n\nint mvs_I_T_nexus_reset(struct domain_device *dev)\n{\n\tunsigned long flags;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tstruct mvs_device *mvi_dev = (struct mvs_device *)dev->lldd_dev;\n\tstruct mvs_info *mvi = mvi_dev->mvi_info;\n\n\tif (mvi_dev->dev_status != MVS_DEV_EH)\n\t\treturn TMF_RESP_FUNC_COMPLETE;\n\telse\n\t\tmvi_dev->dev_status = MVS_DEV_NORMAL;\n\trc = mvs_debug_I_T_nexus_reset(dev);\n\tmv_printk(\"%s for device[%x]:rc= %d\\n\",\n\t\t__func__, mvi_dev->device_id, rc);\n\n\tspin_lock_irqsave(&mvi->lock, flags);\n\tmvs_release_task(mvi, dev);\n\tspin_unlock_irqrestore(&mvi->lock, flags);\n\n\treturn rc;\n}\n \nint mvs_query_task(struct sas_task *task)\n{\n\tu32 tag;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\n\tif (task->lldd_task && task->task_proto & SAS_PROTOCOL_SSP) {\n\t\tstruct domain_device *dev = task->dev;\n\t\tstruct mvs_device *mvi_dev = (struct mvs_device *)dev->lldd_dev;\n\t\tstruct mvs_info *mvi = mvi_dev->mvi_info;\n\n\t\trc = mvs_find_tag(mvi, task, &tag);\n\t\tif (rc == 0) {\n\t\t\trc = TMF_RESP_FUNC_FAILED;\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = sas_query_task(task, tag);\n\t\tswitch (rc) {\n\t\t \n\t\tcase TMF_RESP_FUNC_SUCC:\n\t\t \n\t\tcase TMF_RESP_FUNC_FAILED:\n\t\tcase TMF_RESP_FUNC_COMPLETE:\n\t\t\tbreak;\n\t\t}\n\t}\n\tmv_printk(\"%s:rc= %d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nint mvs_abort_task(struct sas_task *task)\n{\n\tstruct domain_device *dev = task->dev;\n\tstruct mvs_device *mvi_dev = (struct mvs_device *)dev->lldd_dev;\n\tstruct mvs_info *mvi;\n\tint rc = TMF_RESP_FUNC_FAILED;\n\tunsigned long flags;\n\tu32 tag;\n\n\tif (!mvi_dev) {\n\t\tmv_printk(\"Device has removed\\n\");\n\t\treturn TMF_RESP_FUNC_FAILED;\n\t}\n\n\tmvi = mvi_dev->mvi_info;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\trc = TMF_RESP_FUNC_COMPLETE;\n\t\tgoto out;\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tmvi_dev->dev_status = MVS_DEV_EH;\n\tif (task->lldd_task && task->task_proto & SAS_PROTOCOL_SSP) {\n\t\trc = mvs_find_tag(mvi, task, &tag);\n\t\tif (rc == 0) {\n\t\t\tmv_printk(\"No such tag in %s\\n\", __func__);\n\t\t\trc = TMF_RESP_FUNC_FAILED;\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = sas_abort_task(task, tag);\n\n\t\t \n\t\tif (rc == TMF_RESP_FUNC_COMPLETE) {\n\t\t\tu32 slot_no;\n\t\t\tstruct mvs_slot_info *slot;\n\n\t\t\tif (task->lldd_task) {\n\t\t\t\tslot = task->lldd_task;\n\t\t\t\tslot_no = (u32) (slot - mvi->slot_info);\n\t\t\t\tspin_lock_irqsave(&mvi->lock, flags);\n\t\t\t\tmvs_slot_complete(mvi, slot_no, 1);\n\t\t\t\tspin_unlock_irqrestore(&mvi->lock, flags);\n\t\t\t}\n\t\t}\n\n\t} else if (task->task_proto & SAS_PROTOCOL_SATA ||\n\t\ttask->task_proto & SAS_PROTOCOL_STP) {\n\t\tif (SAS_SATA_DEV == dev->dev_type) {\n\t\t\tstruct mvs_slot_info *slot = task->lldd_task;\n\t\t\tu32 slot_idx = (u32)(slot - mvi->slot_info);\n\t\t\tmv_dprintk(\"mvs_abort_task() mvi=%p task=%p \"\n\t\t\t\t   \"slot=%p slot_idx=x%x\\n\",\n\t\t\t\t   mvi, task, slot, slot_idx);\n\t\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\t\t\tmvs_slot_task_free(mvi, task, slot, slot_idx);\n\t\t\trc = TMF_RESP_FUNC_COMPLETE;\n\t\t\tgoto out;\n\t\t}\n\n\t}\nout:\n\tif (rc != TMF_RESP_FUNC_COMPLETE)\n\t\tmv_printk(\"%s:rc= %d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic int mvs_sata_done(struct mvs_info *mvi, struct sas_task *task,\n\t\t\tu32 slot_idx, int err)\n{\n\tstruct mvs_device *mvi_dev = task->dev->lldd_dev;\n\tstruct task_status_struct *tstat = &task->task_status;\n\tstruct ata_task_resp *resp = (struct ata_task_resp *)tstat->buf;\n\tint stat = SAM_STAT_GOOD;\n\n\n\tresp->frame_len = sizeof(struct dev_to_host_fis);\n\tmemcpy(&resp->ending_fis[0],\n\t       SATA_RECEIVED_D2H_FIS(mvi_dev->taskfileset),\n\t       sizeof(struct dev_to_host_fis));\n\ttstat->buf_valid_size = sizeof(*resp);\n\tif (unlikely(err)) {\n\t\tif (unlikely(err & CMD_ISS_STPD))\n\t\t\tstat = SAS_OPEN_REJECT;\n\t\telse\n\t\t\tstat = SAS_PROTO_RESPONSE;\n       }\n\n\treturn stat;\n}\n\nstatic void mvs_set_sense(u8 *buffer, int len, int d_sense,\n\t\tint key, int asc, int ascq)\n{\n\tmemset(buffer, 0, len);\n\n\tif (d_sense) {\n\t\t \n\t\tif (len < 4) {\n\t\t\tmv_printk(\"Length %d of sense buffer too small to \"\n\t\t\t\t\"fit sense %x:%x:%x\", len, key, asc, ascq);\n\t\t}\n\n\t\tbuffer[0] = 0x72;\t\t \n\t\tif (len > 1)\n\t\t\tbuffer[1] = key;\t \n\t\tif (len > 2)\n\t\t\tbuffer[2] = asc;\t \n\t\tif (len > 3)\n\t\t\tbuffer[3] = ascq;\t \n\t} else {\n\t\tif (len < 14) {\n\t\t\tmv_printk(\"Length %d of sense buffer too small to \"\n\t\t\t\t\"fit sense %x:%x:%x\", len, key, asc, ascq);\n\t\t}\n\n\t\tbuffer[0] = 0x70;\t\t \n\t\tif (len > 2)\n\t\t\tbuffer[2] = key;\t \n\t\tif (len > 7)\n\t\t\tbuffer[7] = 0x0a;\t \n\t\tif (len > 12)\n\t\t\tbuffer[12] = asc;\t \n\t\tif (len > 13)\n\t\t\tbuffer[13] = ascq;  \n\t}\n\n\treturn;\n}\n\nstatic void mvs_fill_ssp_resp_iu(struct ssp_response_iu *iu,\n\t\t\t\tu8 key, u8 asc, u8 asc_q)\n{\n\tiu->datapres = SAS_DATAPRES_SENSE_DATA;\n\tiu->response_data_len = 0;\n\tiu->sense_data_len = 17;\n\tiu->status = 02;\n\tmvs_set_sense(iu->sense_data, 17, 0,\n\t\t\tkey, asc, asc_q);\n}\n\nstatic int mvs_slot_err(struct mvs_info *mvi, struct sas_task *task,\n\t\t\t u32 slot_idx)\n{\n\tstruct mvs_slot_info *slot = &mvi->slot_info[slot_idx];\n\tint stat;\n\tu32 err_dw0 = le32_to_cpu(*(u32 *)slot->response);\n\tu32 err_dw1 = le32_to_cpu(*((u32 *)slot->response + 1));\n\tu32 tfs = 0;\n\tenum mvs_port_type type = PORT_TYPE_SAS;\n\n\tif (err_dw0 & CMD_ISS_STPD)\n\t\tMVS_CHIP_DISP->issue_stop(mvi, type, tfs);\n\n\tMVS_CHIP_DISP->command_active(mvi, slot_idx);\n\n\tstat = SAM_STAT_CHECK_CONDITION;\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\t{\n\t\tstat = SAS_ABORTED_TASK;\n\t\tif ((err_dw0 & NO_DEST) || err_dw1 & bit(31)) {\n\t\t\tstruct ssp_response_iu *iu = slot->response +\n\t\t\t\tsizeof(struct mvs_err_info);\n\t\t\tmvs_fill_ssp_resp_iu(iu, NOT_READY, 0x04, 01);\n\t\t\tsas_ssp_task_response(mvi->dev, task, iu);\n\t\t\tstat = SAM_STAT_CHECK_CONDITION;\n\t\t}\n\t\tif (err_dw1 & bit(31))\n\t\t\tmv_printk(\"reuse same slot, retry command.\\n\");\n\t\tbreak;\n\t}\n\tcase SAS_PROTOCOL_SMP:\n\t\tstat = SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:\n\t{\n\t\ttask->ata_task.use_ncq = 0;\n\t\tstat = SAS_PROTO_RESPONSE;\n\t\tmvs_sata_done(mvi, task, slot_idx, err_dw0);\n\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn stat;\n}\n\nint mvs_slot_complete(struct mvs_info *mvi, u32 rx_desc, u32 flags)\n{\n\tu32 slot_idx = rx_desc & RXQ_SLOT_MASK;\n\tstruct mvs_slot_info *slot = &mvi->slot_info[slot_idx];\n\tstruct sas_task *task = slot->task;\n\tstruct mvs_device *mvi_dev = NULL;\n\tstruct task_status_struct *tstat;\n\tstruct domain_device *dev;\n\tu32 aborted;\n\n\tvoid *to;\n\tenum exec_status sts;\n\n\tif (unlikely(!task || !task->lldd_task || !task->dev))\n\t\treturn -1;\n\n\ttstat = &task->task_status;\n\tdev = task->dev;\n\tmvi_dev = dev->lldd_dev;\n\n\tspin_lock(&task->task_state_lock);\n\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\t \n\taborted = task->task_state_flags & SAS_TASK_STATE_ABORTED;\n\tspin_unlock(&task->task_state_lock);\n\n\tmemset(tstat, 0, sizeof(*tstat));\n\ttstat->resp = SAS_TASK_COMPLETE;\n\n\tif (unlikely(aborted)) {\n\t\ttstat->stat = SAS_ABORTED_TASK;\n\t\tif (mvi_dev && mvi_dev->running_req)\n\t\t\tmvi_dev->running_req--;\n\t\tif (sas_protocol_ata(task->task_proto))\n\t\t\tmvs_free_reg_set(mvi, mvi_dev);\n\n\t\tmvs_slot_task_free(mvi, task, slot, slot_idx);\n\t\treturn -1;\n\t}\n\n\t \n\tif (unlikely(!mvi_dev || flags)) {\n\t\tif (!mvi_dev)\n\t\t\tmv_dprintk(\"port has not device.\\n\");\n\t\ttstat->stat = SAS_PHY_DOWN;\n\t\tgoto out;\n\t}\n\n\t \n\tif (unlikely((rx_desc & RXQ_ERR)\n\t\t     && (*((u32 *)slot->response)\n\t\t\t || *(((u32 *)slot->response) + 1)))) {\n\t\tmv_dprintk(\"port %d slot %d rx_desc %X has error info\"\n\t\t\t\"%016llX.\\n\", slot->port->sas_port.id, slot_idx,\n\t\t\t rx_desc, get_unaligned_le64(slot->response));\n\t\ttstat->stat = mvs_slot_err(mvi, task, slot_idx);\n\t\ttstat->resp = SAS_TASK_COMPLETE;\n\t\tgoto out;\n\t}\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SSP:\n\t\t \n\t\tif (rx_desc & RXQ_GOOD) {\n\t\t\ttstat->stat = SAS_SAM_STAT_GOOD;\n\t\t\ttstat->resp = SAS_TASK_COMPLETE;\n\t\t}\n\t\t \n\t\telse if (rx_desc & RXQ_RSP) {\n\t\t\tstruct ssp_response_iu *iu = slot->response +\n\t\t\t\t\t\tsizeof(struct mvs_err_info);\n\t\t\tsas_ssp_task_response(mvi->dev, task, iu);\n\t\t} else\n\t\t\ttstat->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\n\tcase SAS_PROTOCOL_SMP: {\n\t\t\tstruct scatterlist *sg_resp = &task->smp_task.smp_resp;\n\t\t\ttstat->stat = SAS_SAM_STAT_GOOD;\n\t\t\tto = kmap_atomic(sg_page(sg_resp));\n\t\t\tmemcpy(to + sg_resp->offset,\n\t\t\t\tslot->response + sizeof(struct mvs_err_info),\n\t\t\t\tsg_dma_len(sg_resp));\n\t\t\tkunmap_atomic(to);\n\t\t\tbreak;\n\t\t}\n\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\tcase SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP: {\n\t\t\ttstat->stat = mvs_sata_done(mvi, task, slot_idx, 0);\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\ttstat->stat = SAS_SAM_STAT_CHECK_CONDITION;\n\t\tbreak;\n\t}\n\tif (!slot->port->port_attached) {\n\t\tmv_dprintk(\"port %d has removed.\\n\", slot->port->sas_port.id);\n\t\ttstat->stat = SAS_PHY_DOWN;\n\t}\n\n\nout:\n\tif (mvi_dev && mvi_dev->running_req) {\n\t\tmvi_dev->running_req--;\n\t\tif (sas_protocol_ata(task->task_proto) && !mvi_dev->running_req)\n\t\t\tmvs_free_reg_set(mvi, mvi_dev);\n\t}\n\tmvs_slot_task_free(mvi, task, slot, slot_idx);\n\tsts = tstat->stat;\n\n\tspin_unlock(&mvi->lock);\n\tif (task->task_done)\n\t\ttask->task_done(task);\n\n\tspin_lock(&mvi->lock);\n\n\treturn sts;\n}\n\nvoid mvs_do_release_task(struct mvs_info *mvi,\n\t\tint phy_no, struct domain_device *dev)\n{\n\tu32 slot_idx;\n\tstruct mvs_phy *phy;\n\tstruct mvs_port *port;\n\tstruct mvs_slot_info *slot, *slot2;\n\n\tphy = &mvi->phy[phy_no];\n\tport = phy->port;\n\tif (!port)\n\t\treturn;\n\t \n\tmvs_int_rx(mvi, false);\n\n\n\n\tlist_for_each_entry_safe(slot, slot2, &port->list, entry) {\n\t\tstruct sas_task *task;\n\t\tslot_idx = (u32) (slot - mvi->slot_info);\n\t\ttask = slot->task;\n\n\t\tif (dev && task->dev != dev)\n\t\t\tcontinue;\n\n\t\tmv_printk(\"Release slot [%x] tag[%x], task [%p]:\\n\",\n\t\t\tslot_idx, slot->slot_tag, task);\n\t\tMVS_CHIP_DISP->command_active(mvi, slot_idx);\n\n\t\tmvs_slot_complete(mvi, slot_idx, 1);\n\t}\n}\n\nvoid mvs_release_task(struct mvs_info *mvi,\n\t\t      struct domain_device *dev)\n{\n\tint i, phyno[WIDE_PORT_MAX_PHY], num;\n\tnum = mvs_find_dev_phyno(dev, phyno);\n\tfor (i = 0; i < num; i++)\n\t\tmvs_do_release_task(mvi, phyno[i], dev);\n}\n\nstatic void mvs_phy_disconnected(struct mvs_phy *phy)\n{\n\tphy->phy_attached = 0;\n\tphy->att_dev_info = 0;\n\tphy->att_dev_sas_addr = 0;\n}\n\nstatic void mvs_work_queue(struct work_struct *work)\n{\n\tstruct delayed_work *dw = container_of(work, struct delayed_work, work);\n\tstruct mvs_wq *mwq = container_of(dw, struct mvs_wq, work_q);\n\tstruct mvs_info *mvi = mwq->mvi;\n\tunsigned long flags;\n\tu32 phy_no = (unsigned long) mwq->data;\n\tstruct mvs_phy *phy = &mvi->phy[phy_no];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\tspin_lock_irqsave(&mvi->lock, flags);\n\tif (mwq->handler & PHY_PLUG_EVENT) {\n\n\t\tif (phy->phy_event & PHY_PLUG_OUT) {\n\t\t\tu32 tmp;\n\n\t\t\ttmp = MVS_CHIP_DISP->read_phy_ctl(mvi, phy_no);\n\t\t\tphy->phy_event &= ~PHY_PLUG_OUT;\n\t\t\tif (!(tmp & PHY_READY_MASK)) {\n\t\t\t\tsas_phy_disconnected(sas_phy);\n\t\t\t\tmvs_phy_disconnected(phy);\n\t\t\t\tsas_notify_phy_event(sas_phy,\n\t\t\t\t\tPHYE_LOSS_OF_SIGNAL, GFP_ATOMIC);\n\t\t\t\tmv_dprintk(\"phy%d Removed Device\\n\", phy_no);\n\t\t\t} else {\n\t\t\t\tMVS_CHIP_DISP->detect_porttype(mvi, phy_no);\n\t\t\t\tmvs_update_phyinfo(mvi, phy_no, 1);\n\t\t\t\tmvs_bytes_dmaed(mvi, phy_no, GFP_ATOMIC);\n\t\t\t\tmvs_port_notify_formed(sas_phy, 0);\n\t\t\t\tmv_dprintk(\"phy%d Attached Device\\n\", phy_no);\n\t\t\t}\n\t\t}\n\t} else if (mwq->handler & EXP_BRCT_CHG) {\n\t\tphy->phy_event &= ~EXP_BRCT_CHG;\n\t\tsas_notify_port_event(sas_phy,\n\t\t\t\tPORTE_BROADCAST_RCVD, GFP_ATOMIC);\n\t\tmv_dprintk(\"phy%d Got Broadcast Change\\n\", phy_no);\n\t}\n\tlist_del(&mwq->entry);\n\tspin_unlock_irqrestore(&mvi->lock, flags);\n\tkfree(mwq);\n}\n\nstatic int mvs_handle_event(struct mvs_info *mvi, void *data, int handler)\n{\n\tstruct mvs_wq *mwq;\n\tint ret = 0;\n\n\tmwq = kmalloc(sizeof(struct mvs_wq), GFP_ATOMIC);\n\tif (mwq) {\n\t\tmwq->mvi = mvi;\n\t\tmwq->data = data;\n\t\tmwq->handler = handler;\n\t\tMV_INIT_DELAYED_WORK(&mwq->work_q, mvs_work_queue, mwq);\n\t\tlist_add_tail(&mwq->entry, &mvi->wq_list);\n\t\tschedule_delayed_work(&mwq->work_q, HZ * 2);\n\t} else\n\t\tret = -ENOMEM;\n\n\treturn ret;\n}\n\nstatic void mvs_sig_time_out(struct timer_list *t)\n{\n\tstruct mvs_phy *phy = from_timer(phy, t, timer);\n\tstruct mvs_info *mvi = phy->mvi;\n\tu8 phy_no;\n\n\tfor (phy_no = 0; phy_no < mvi->chip->n_phy; phy_no++) {\n\t\tif (&mvi->phy[phy_no] == phy) {\n\t\t\tmv_dprintk(\"Get signature time out, reset phy %d\\n\",\n\t\t\t\tphy_no+mvi->id*mvi->chip->n_phy);\n\t\t\tMVS_CHIP_DISP->phy_reset(mvi, phy_no, MVS_HARD_RESET);\n\t\t}\n\t}\n}\n\nvoid mvs_int_port(struct mvs_info *mvi, int phy_no, u32 events)\n{\n\tu32 tmp;\n\tstruct mvs_phy *phy = &mvi->phy[phy_no];\n\n\tphy->irq_status = MVS_CHIP_DISP->read_port_irq_stat(mvi, phy_no);\n\tMVS_CHIP_DISP->write_port_irq_stat(mvi, phy_no, phy->irq_status);\n\tmv_dprintk(\"phy %d ctrl sts=0x%08X.\\n\", phy_no+mvi->id*mvi->chip->n_phy,\n\t\tMVS_CHIP_DISP->read_phy_ctl(mvi, phy_no));\n\tmv_dprintk(\"phy %d irq sts = 0x%08X\\n\", phy_no+mvi->id*mvi->chip->n_phy,\n\t\tphy->irq_status);\n\n\t \n\n\tif (phy->irq_status & PHYEV_DCDR_ERR) {\n\t\tmv_dprintk(\"phy %d STP decoding error.\\n\",\n\t\tphy_no + mvi->id*mvi->chip->n_phy);\n\t}\n\n\tif (phy->irq_status & PHYEV_POOF) {\n\t\tmdelay(500);\n\t\tif (!(phy->phy_event & PHY_PLUG_OUT)) {\n\t\t\tint dev_sata = phy->phy_type & PORT_TYPE_SATA;\n\t\t\tint ready;\n\t\t\tmvs_do_release_task(mvi, phy_no, NULL);\n\t\t\tphy->phy_event |= PHY_PLUG_OUT;\n\t\t\tMVS_CHIP_DISP->clear_srs_irq(mvi, 0, 1);\n\t\t\tmvs_handle_event(mvi,\n\t\t\t\t(void *)(unsigned long)phy_no,\n\t\t\t\tPHY_PLUG_EVENT);\n\t\t\tready = mvs_is_phy_ready(mvi, phy_no);\n\t\t\tif (ready || dev_sata) {\n\t\t\t\tif (MVS_CHIP_DISP->stp_reset)\n\t\t\t\t\tMVS_CHIP_DISP->stp_reset(mvi,\n\t\t\t\t\t\t\tphy_no);\n\t\t\t\telse\n\t\t\t\t\tMVS_CHIP_DISP->phy_reset(mvi,\n\t\t\t\t\t\t\tphy_no, MVS_SOFT_RESET);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (phy->irq_status & PHYEV_COMWAKE) {\n\t\ttmp = MVS_CHIP_DISP->read_port_irq_mask(mvi, phy_no);\n\t\tMVS_CHIP_DISP->write_port_irq_mask(mvi, phy_no,\n\t\t\t\t\ttmp | PHYEV_SIG_FIS);\n\t\tif (phy->timer.function == NULL) {\n\t\t\tphy->timer.function = mvs_sig_time_out;\n\t\t\tphy->timer.expires = jiffies + 5*HZ;\n\t\t\tadd_timer(&phy->timer);\n\t\t}\n\t}\n\tif (phy->irq_status & (PHYEV_SIG_FIS | PHYEV_ID_DONE)) {\n\t\tphy->phy_status = mvs_is_phy_ready(mvi, phy_no);\n\t\tmv_dprintk(\"notify plug in on phy[%d]\\n\", phy_no);\n\t\tif (phy->phy_status) {\n\t\t\tmdelay(10);\n\t\t\tMVS_CHIP_DISP->detect_porttype(mvi, phy_no);\n\t\t\tif (phy->phy_type & PORT_TYPE_SATA) {\n\t\t\t\ttmp = MVS_CHIP_DISP->read_port_irq_mask(\n\t\t\t\t\t\tmvi, phy_no);\n\t\t\t\ttmp &= ~PHYEV_SIG_FIS;\n\t\t\t\tMVS_CHIP_DISP->write_port_irq_mask(mvi,\n\t\t\t\t\t\t\tphy_no, tmp);\n\t\t\t}\n\t\t\tmvs_update_phyinfo(mvi, phy_no, 0);\n\t\t\tif (phy->phy_type & PORT_TYPE_SAS) {\n\t\t\t\tMVS_CHIP_DISP->phy_reset(mvi, phy_no, MVS_PHY_TUNE);\n\t\t\t\tmdelay(10);\n\t\t\t}\n\n\t\t\tmvs_bytes_dmaed(mvi, phy_no, GFP_ATOMIC);\n\t\t\t \n\t\t\tif (phy->phy_event & PHY_PLUG_OUT) {\n\t\t\t\tmvs_port_notify_formed(&phy->sas_phy, 0);\n\t\t\t\tphy->phy_event &= ~PHY_PLUG_OUT;\n\t\t\t}\n\t\t} else {\n\t\t\tmv_dprintk(\"plugin interrupt but phy%d is gone\\n\",\n\t\t\t\tphy_no + mvi->id*mvi->chip->n_phy);\n\t\t}\n\t} else if (phy->irq_status & PHYEV_BROAD_CH) {\n\t\tmv_dprintk(\"phy %d broadcast change.\\n\",\n\t\t\tphy_no + mvi->id*mvi->chip->n_phy);\n\t\tmvs_handle_event(mvi, (void *)(unsigned long)phy_no,\n\t\t\t\tEXP_BRCT_CHG);\n\t}\n}\n\nint mvs_int_rx(struct mvs_info *mvi, bool self_clear)\n{\n\tu32 rx_prod_idx, rx_desc;\n\tbool attn = false;\n\n\t \n\trx_prod_idx = mvi->rx_cons;\n\tmvi->rx_cons = le32_to_cpu(mvi->rx[0]);\n\tif (mvi->rx_cons == 0xfff)\t \n\t\treturn 0;\n\n\t \n\tif (unlikely(mvi->rx_cons == rx_prod_idx))\n\t\tmvi->rx_cons = MVS_CHIP_DISP->rx_update(mvi) & RX_RING_SZ_MASK;\n\n\tif (mvi->rx_cons == rx_prod_idx)\n\t\treturn 0;\n\n\twhile (mvi->rx_cons != rx_prod_idx) {\n\t\t \n\t\trx_prod_idx = (rx_prod_idx + 1) & (MVS_RX_RING_SZ - 1);\n\t\trx_desc = le32_to_cpu(mvi->rx[rx_prod_idx + 1]);\n\n\t\tif (likely(rx_desc & RXQ_DONE))\n\t\t\tmvs_slot_complete(mvi, rx_desc, 0);\n\t\tif (rx_desc & RXQ_ATTN) {\n\t\t\tattn = true;\n\t\t} else if (rx_desc & RXQ_ERR) {\n\t\t\tif (!(rx_desc & RXQ_DONE))\n\t\t\t\tmvs_slot_complete(mvi, rx_desc, 0);\n\t\t} else if (rx_desc & RXQ_SLOT_RESET) {\n\t\t\tmvs_slot_free(mvi, rx_desc);\n\t\t}\n\t}\n\n\tif (attn && self_clear)\n\t\tMVS_CHIP_DISP->int_full(mvi);\n\treturn 0;\n}\n\nint mvs_gpio_write(struct sas_ha_struct *sha, u8 reg_type, u8 reg_index,\n\t\t\tu8 reg_count, u8 *write_data)\n{\n\tstruct mvs_prv_info *mvs_prv = sha->lldd_ha;\n\tstruct mvs_info *mvi = mvs_prv->mvi[0];\n\n\tif (MVS_CHIP_DISP->gpio_write) {\n\t\treturn MVS_CHIP_DISP->gpio_write(mvs_prv, reg_type,\n\t\t\treg_index, reg_count, write_data);\n\t}\n\n\treturn -ENOSYS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}