{
  "module_name": "mv_chips.h",
  "hash_id": "c6c5bb7b4b63ff053e473af4a344befb2039d75e00dc77ab22df5d5661627fc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mvsas/mv_chips.h",
  "human_readable_source": " \n \n\n\n#ifndef _MV_CHIPS_H_\n#define _MV_CHIPS_H_\n\n#define mr32(reg)\treadl(regs + reg)\n#define mw32(reg, val)\twritel((val), regs + reg)\n#define mw32_f(reg, val)\tdo {\t\t\t\\\n\t\t\t\tmw32(reg, val);\t\\\n\t\t\t\tmr32(reg);\t\\\n\t\t\t} while (0)\n\n#define iow32(reg, val) \toutl(val, (unsigned long)(regs + reg))\n#define ior32(reg) \t\tinl((unsigned long)(regs + reg))\n#define iow16(reg, val) \toutw((unsigned long)(val, regs + reg))\n#define ior16(reg) \t\tinw((unsigned long)(regs + reg))\n#define iow8(reg, val) \t\toutb((unsigned long)(val, regs + reg))\n#define ior8(reg) \t\tinb((unsigned long)(regs + reg))\n\nstatic inline u32 mvs_cr32(struct mvs_info *mvi, u32 addr)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tmw32(MVS_CMD_ADDR, addr);\n\treturn mr32(MVS_CMD_DATA);\n}\n\nstatic inline void mvs_cw32(struct mvs_info *mvi, u32 addr, u32 val)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tmw32(MVS_CMD_ADDR, addr);\n\tmw32(MVS_CMD_DATA, val);\n}\n\nstatic inline u32 mvs_read_phy_ctl(struct mvs_info *mvi, u32 port)\n{\n\tvoid __iomem *regs = mvi->regs;\n\treturn (port < 4) ? mr32(MVS_P0_SER_CTLSTAT + port * 4) :\n\t\tmr32(MVS_P4_SER_CTLSTAT + (port - 4) * 4);\n}\n\nstatic inline void mvs_write_phy_ctl(struct mvs_info *mvi, u32 port, u32 val)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tif (port < 4)\n\t\tmw32(MVS_P0_SER_CTLSTAT + port * 4, val);\n\telse\n\t\tmw32(MVS_P4_SER_CTLSTAT + (port - 4) * 4, val);\n}\n\nstatic inline u32 mvs_read_port(struct mvs_info *mvi, u32 off,\n\t\t\t\tu32 off2, u32 port)\n{\n\tvoid __iomem *regs = mvi->regs + off;\n\tvoid __iomem *regs2 = mvi->regs + off2;\n\treturn (port < 4) ? readl(regs + port * 8) :\n\t\treadl(regs2 + (port - 4) * 8);\n}\n\nstatic inline void mvs_write_port(struct mvs_info *mvi, u32 off, u32 off2,\n\t\t\t\tu32 port, u32 val)\n{\n\tvoid __iomem *regs = mvi->regs + off;\n\tvoid __iomem *regs2 = mvi->regs + off2;\n\tif (port < 4)\n\t\twritel(val, regs + port * 8);\n\telse\n\t\twritel(val, regs2 + (port - 4) * 8);\n}\n\nstatic inline u32 mvs_read_port_cfg_data(struct mvs_info *mvi, u32 port)\n{\n\treturn mvs_read_port(mvi, MVS_P0_CFG_DATA,\n\t\t\tMVS_P4_CFG_DATA, port);\n}\n\nstatic inline void mvs_write_port_cfg_data(struct mvs_info *mvi,\n\t\t\t\t\t\tu32 port, u32 val)\n{\n\tmvs_write_port(mvi, MVS_P0_CFG_DATA,\n\t\t\tMVS_P4_CFG_DATA, port, val);\n}\n\nstatic inline void mvs_write_port_cfg_addr(struct mvs_info *mvi,\n\t\t\t\t\t\tu32 port, u32 addr)\n{\n\tmvs_write_port(mvi, MVS_P0_CFG_ADDR,\n\t\t\tMVS_P4_CFG_ADDR, port, addr);\n\tmdelay(10);\n}\n\nstatic inline u32 mvs_read_port_vsr_data(struct mvs_info *mvi, u32 port)\n{\n\treturn mvs_read_port(mvi, MVS_P0_VSR_DATA,\n\t\t\tMVS_P4_VSR_DATA, port);\n}\n\nstatic inline void mvs_write_port_vsr_data(struct mvs_info *mvi,\n\t\t\t\t\t\tu32 port, u32 val)\n{\n\tmvs_write_port(mvi, MVS_P0_VSR_DATA,\n\t\t\tMVS_P4_VSR_DATA, port, val);\n}\n\nstatic inline void mvs_write_port_vsr_addr(struct mvs_info *mvi,\n\t\t\t\t\t\tu32 port, u32 addr)\n{\n\tmvs_write_port(mvi, MVS_P0_VSR_ADDR,\n\t\t\tMVS_P4_VSR_ADDR, port, addr);\n\tmdelay(10);\n}\n\nstatic inline u32 mvs_read_port_irq_stat(struct mvs_info *mvi, u32 port)\n{\n\treturn mvs_read_port(mvi, MVS_P0_INT_STAT,\n\t\t\tMVS_P4_INT_STAT, port);\n}\n\nstatic inline void mvs_write_port_irq_stat(struct mvs_info *mvi,\n\t\t\t\t\t\tu32 port, u32 val)\n{\n\tmvs_write_port(mvi, MVS_P0_INT_STAT,\n\t\t\tMVS_P4_INT_STAT, port, val);\n}\n\nstatic inline u32 mvs_read_port_irq_mask(struct mvs_info *mvi, u32 port)\n{\n\treturn mvs_read_port(mvi, MVS_P0_INT_MASK,\n\t\t\tMVS_P4_INT_MASK, port);\n\n}\n\nstatic inline void mvs_write_port_irq_mask(struct mvs_info *mvi,\n\t\t\t\t\t\tu32 port, u32 val)\n{\n\tmvs_write_port(mvi, MVS_P0_INT_MASK,\n\t\t\tMVS_P4_INT_MASK, port, val);\n}\n\nstatic inline void mvs_phy_hacks(struct mvs_info *mvi)\n{\n\tu32 tmp;\n\n\ttmp = mvs_cr32(mvi, CMD_PHY_TIMER);\n\ttmp &= ~(1 << 9);\n\ttmp |= (1 << 10);\n\tmvs_cw32(mvi, CMD_PHY_TIMER, tmp);\n\n\t \n\tmvs_cw32(mvi, CMD_SAS_CTL1, 0x7f7f);\n\n\t \n\ttmp = mvs_cr32(mvi, CMD_SAS_CTL0);\n\ttmp &= ~0xffff;\n\ttmp |= 0x3fff;\n\tmvs_cw32(mvi, CMD_SAS_CTL0, tmp);\n\n\tmvs_cw32(mvi, CMD_WD_TIMER, 0x7a0000);\n\n\t \n\tmvs_cw32(mvi, CMD_APP_ERR_CONFIG, 0xffefbf7d);\n}\n\nstatic inline void mvs_int_sata(struct mvs_info *mvi)\n{\n\tu32 tmp;\n\tvoid __iomem *regs = mvi->regs;\n\ttmp = mr32(MVS_INT_STAT_SRS_0);\n\tif (tmp)\n\t\tmw32(MVS_INT_STAT_SRS_0, tmp);\n\tMVS_CHIP_DISP->clear_active_cmds(mvi);\n}\n\nstatic inline void mvs_int_full(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tu32 tmp, stat;\n\tint i;\n\n\tstat = mr32(MVS_INT_STAT);\n\tmvs_int_rx(mvi, false);\n\n\tfor (i = 0; i < mvi->chip->n_phy; i++) {\n\t\ttmp = (stat >> i) & (CINT_PORT | CINT_PORT_STOPPED);\n\t\tif (tmp)\n\t\t\tmvs_int_port(mvi, i, tmp);\n\t}\n\n\tif (stat & CINT_NON_SPEC_NCQ_ERROR)\n\t\tMVS_CHIP_DISP->non_spec_ncq_error(mvi);\n\n\tif (stat & CINT_SRS)\n\t\tmvs_int_sata(mvi);\n\n\tmw32(MVS_INT_STAT, stat);\n}\n\nstatic inline void mvs_start_delivery(struct mvs_info *mvi, u32 tx)\n{\n\tvoid __iomem *regs = mvi->regs;\n\tmw32(MVS_TX_PROD_IDX, tx);\n}\n\nstatic inline u32 mvs_rx_update(struct mvs_info *mvi)\n{\n\tvoid __iomem *regs = mvi->regs;\n\treturn mr32(MVS_RX_CONS_IDX);\n}\n\nstatic inline u32 mvs_get_prd_size(void)\n{\n\treturn sizeof(struct mvs_prd);\n}\n\nstatic inline u32 mvs_get_prd_count(void)\n{\n\treturn MAX_SG_ENTRY;\n}\n\nstatic inline void mvs_show_pcie_usage(struct mvs_info *mvi)\n{\n\tu16 link_stat, link_spd;\n\tconst char *spd[] = {\n\t\t\"UnKnown\",\n\t\t\"2.5\",\n\t\t\"5.0\",\n\t};\n\tif (mvi->flags & MVF_FLAG_SOC || mvi->id > 0)\n\t\treturn;\n\n\tpci_read_config_word(mvi->pdev, PCR_LINK_STAT, &link_stat);\n\tlink_spd = (link_stat & PLS_LINK_SPD) >> PLS_LINK_SPD_OFFS;\n\tif (link_spd >= 3)\n\t\tlink_spd = 0;\n\tdev_printk(KERN_INFO, mvi->dev,\n\t\t\"mvsas: PCI-E x%u, Bandwidth Usage: %s Gbps\\n\",\n\t       (link_stat & PLS_NEG_LINK_WD) >> PLS_NEG_LINK_WD_OFFS,\n\t       spd[link_spd]);\n}\n\nstatic inline u32 mvs_hw_max_link_rate(void)\n{\n\treturn MAX_LINK_RATE;\n}\n\n#endif   \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}