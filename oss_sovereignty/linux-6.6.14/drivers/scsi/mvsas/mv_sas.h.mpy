{
  "module_name": "mv_sas.h",
  "hash_id": "ec8373f91239db0d4af5e8bfc453c619ff19c54d32d526da6d184002078455e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mvsas/mv_sas.h",
  "human_readable_source": " \n \n\n#ifndef _MV_SAS_H_\n#define _MV_SAS_H_\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/dma-mapping.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <asm/unaligned.h>\n#include <scsi/libsas.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/sas_ata.h>\n#include \"mv_defs.h\"\n\n#define DRV_NAME\t\t\"mvsas\"\n#define DRV_VERSION\t\t\"0.8.16\"\n#define MVS_ID_NOT_MAPPED\t0x7f\n#define WIDE_PORT_MAX_PHY\t\t4\n#define mv_printk(fmt, arg ...)\t\\\n\tprintk(KERN_DEBUG\"%s %d:\" fmt, __FILE__, __LINE__, ## arg)\n#ifdef MV_DEBUG\n#define mv_dprintk(format, arg...)\t\\\n\tprintk(KERN_DEBUG\"%s %d:\" format, __FILE__, __LINE__, ## arg)\n#else\n#define mv_dprintk(format, arg...) no_printk(format, ## arg)\n#endif\n#define MV_MAX_U32\t\t\t0xffffffff\n\nextern int interrupt_coalescing;\nextern struct mvs_tgt_initiator mvs_tgt;\nextern struct mvs_info *tgt_mvi;\nextern const struct mvs_dispatch mvs_64xx_dispatch;\nextern const struct mvs_dispatch mvs_94xx_dispatch;\n\n#define bit(n) ((u64)1 << n)\n\n#define for_each_phy(__lseq_mask, __mc, __lseq)\t\t\t\\\n\tfor ((__mc) = (__lseq_mask), (__lseq) = 0;\t\t\\\n\t\t\t\t\t(__mc) != 0 ;\t\t\\\n\t\t\t\t\t(++__lseq), (__mc) >>= 1)\n\n#define MVS_PHY_ID (1U << sas_phy->id)\n#define MV_INIT_DELAYED_WORK(w, f, d)\tINIT_DELAYED_WORK(w, f)\n#define UNASSOC_D2H_FIS(id)\t\t\\\n\t((void *) mvi->rx_fis + 0x100 * id)\n#define SATA_RECEIVED_FIS_LIST(reg_set)\t\\\n\t((void *) mvi->rx_fis + mvi->chip->fis_offs + 0x100 * reg_set)\n#define SATA_RECEIVED_SDB_FIS(reg_set)\t\\\n\t(SATA_RECEIVED_FIS_LIST(reg_set) + 0x58)\n#define SATA_RECEIVED_D2H_FIS(reg_set)\t\\\n\t(SATA_RECEIVED_FIS_LIST(reg_set) + 0x40)\n#define SATA_RECEIVED_PIO_FIS(reg_set)\t\\\n\t(SATA_RECEIVED_FIS_LIST(reg_set) + 0x20)\n#define SATA_RECEIVED_DMA_FIS(reg_set)\t\\\n\t(SATA_RECEIVED_FIS_LIST(reg_set) + 0x00)\n\nenum dev_status {\n\tMVS_DEV_NORMAL = 0x0,\n\tMVS_DEV_EH\t= 0x1,\n};\n\nenum dev_reset {\n\tMVS_SOFT_RESET\t= 0,\n\tMVS_HARD_RESET\t= 1,\n\tMVS_PHY_TUNE\t= 2,\n};\n\nstruct mvs_info;\nstruct mvs_prv_info;\n\nstruct mvs_dispatch {\n\tchar *name;\n\tint (*chip_init)(struct mvs_info *mvi);\n\tint (*spi_init)(struct mvs_info *mvi);\n\tint (*chip_ioremap)(struct mvs_info *mvi);\n\tvoid (*chip_iounmap)(struct mvs_info *mvi);\n\tirqreturn_t (*isr)(struct mvs_info *mvi, int irq, u32 stat);\n\tu32 (*isr_status)(struct mvs_info *mvi, int irq);\n\tvoid (*interrupt_enable)(struct mvs_info *mvi);\n\tvoid (*interrupt_disable)(struct mvs_info *mvi);\n\n\tu32 (*read_phy_ctl)(struct mvs_info *mvi, u32 port);\n\tvoid (*write_phy_ctl)(struct mvs_info *mvi, u32 port, u32 val);\n\n\tu32 (*read_port_cfg_data)(struct mvs_info *mvi, u32 port);\n\tvoid (*write_port_cfg_data)(struct mvs_info *mvi, u32 port, u32 val);\n\tvoid (*write_port_cfg_addr)(struct mvs_info *mvi, u32 port, u32 addr);\n\n\tu32 (*read_port_vsr_data)(struct mvs_info *mvi, u32 port);\n\tvoid (*write_port_vsr_data)(struct mvs_info *mvi, u32 port, u32 val);\n\tvoid (*write_port_vsr_addr)(struct mvs_info *mvi, u32 port, u32 addr);\n\n\tu32 (*read_port_irq_stat)(struct mvs_info *mvi, u32 port);\n\tvoid (*write_port_irq_stat)(struct mvs_info *mvi, u32 port, u32 val);\n\n\tu32 (*read_port_irq_mask)(struct mvs_info *mvi, u32 port);\n\tvoid (*write_port_irq_mask)(struct mvs_info *mvi, u32 port, u32 val);\n\n\tvoid (*command_active)(struct mvs_info *mvi, u32 slot_idx);\n\tvoid (*clear_srs_irq)(struct mvs_info *mvi, u8 reg_set, u8 clear_all);\n\tvoid (*issue_stop)(struct mvs_info *mvi, enum mvs_port_type type,\n\t\t\t\tu32 tfs);\n\tvoid (*start_delivery)(struct mvs_info *mvi, u32 tx);\n\tu32 (*rx_update)(struct mvs_info *mvi);\n\tvoid (*int_full)(struct mvs_info *mvi);\n\tu8 (*assign_reg_set)(struct mvs_info *mvi, u8 *tfs);\n\tvoid (*free_reg_set)(struct mvs_info *mvi, u8 *tfs);\n\tu32 (*prd_size)(void);\n\tu32 (*prd_count)(void);\n\tvoid (*make_prd)(struct scatterlist *scatter, int nr, void *prd);\n\tvoid (*detect_porttype)(struct mvs_info *mvi, int i);\n\tint (*oob_done)(struct mvs_info *mvi, int i);\n\tvoid (*fix_phy_info)(struct mvs_info *mvi, int i,\n\t\t\t\tstruct sas_identify_frame *id);\n\tvoid (*phy_work_around)(struct mvs_info *mvi, int i);\n\tvoid (*phy_set_link_rate)(struct mvs_info *mvi, u32 phy_id,\n\t\t\t\tstruct sas_phy_linkrates *rates);\n\tu32 (*phy_max_link_rate)(void);\n\tvoid (*phy_disable)(struct mvs_info *mvi, u32 phy_id);\n\tvoid (*phy_enable)(struct mvs_info *mvi, u32 phy_id);\n\tvoid (*phy_reset)(struct mvs_info *mvi, u32 phy_id, int hard);\n\tvoid (*stp_reset)(struct mvs_info *mvi, u32 phy_id);\n\tvoid (*clear_active_cmds)(struct mvs_info *mvi);\n\tu32 (*spi_read_data)(struct mvs_info *mvi);\n\tvoid (*spi_write_data)(struct mvs_info *mvi, u32 data);\n\tint (*spi_buildcmd)(struct mvs_info *mvi,\n\t\t\t\t\t\tu32      *dwCmd,\n\t\t\t\t\t\tu8       cmd,\n\t\t\t\t\t\tu8       read,\n\t\t\t\t\t\tu8       length,\n\t\t\t\t\t\tu32      addr\n\t\t\t\t\t\t);\n\tint (*spi_issuecmd)(struct mvs_info *mvi, u32 cmd);\n\tint (*spi_waitdataready)(struct mvs_info *mvi, u32 timeout);\n\tvoid (*dma_fix)(struct mvs_info *mvi, u32 phy_mask,\n\t\t\t\tint buf_len, int from, void *prd);\n\tvoid (*tune_interrupt)(struct mvs_info *mvi, u32 time);\n\tvoid (*non_spec_ncq_error)(struct mvs_info *mvi);\n\tint (*gpio_write)(struct mvs_prv_info *mvs_prv, u8 reg_type,\n\t\t\tu8 reg_index, u8 reg_count, u8 *write_data);\n\n};\n\nstruct mvs_chip_info {\n\tu32 \t\tn_host;\n\tu32 \t\tn_phy;\n\tu32 \t\tfis_offs;\n\tu32 \t\tfis_count;\n\tu32 \t\tsrs_sz;\n\tu32\t\tsg_width;\n\tu32 \t\tslot_width;\n\tconst struct mvs_dispatch *dispatch;\n};\n#define MVS_MAX_SG\t\t(1U << mvi->chip->sg_width)\n#define MVS_CHIP_SLOT_SZ\t(1U << mvi->chip->slot_width)\n#define MVS_RX_FISL_SZ\t\t\\\n\t(mvi->chip->fis_offs + (mvi->chip->fis_count * 0x100))\n#define MVS_CHIP_DISP\t\t(mvi->chip->dispatch)\n\nstruct mvs_err_info {\n\t__le32\t\t\tflags;\n\t__le32\t\t\tflags2;\n};\n\nstruct mvs_cmd_hdr {\n\t__le32\t\t\tflags;\t \n\t__le32\t\t\tlens;\t \n\t__le32\t\t\ttags;\t \n\t__le32\t\t\tdata_len;\t \n\t__le64\t\t\tcmd_tbl;  \t \n\t__le64\t\t\topen_frame;\t \n\t__le64\t\t\tstatus_buf;\t \n\t__le64\t\t\tprd_tbl;\t\t \n\t__le32\t\t\treserved[4];\n};\n\nstruct mvs_port {\n\tstruct asd_sas_port\tsas_port;\n\tu8\t\t\tport_attached;\n\tu8\t\t\twide_port_phymap;\n\tstruct list_head\tlist;\n};\n\nstruct mvs_phy {\n\tstruct mvs_info \t\t*mvi;\n\tstruct mvs_port\t\t*port;\n\tstruct asd_sas_phy\tsas_phy;\n\tstruct sas_identify\tidentify;\n\tstruct scsi_device\t*sdev;\n\tstruct timer_list timer;\n\tu64\t\tdev_sas_addr;\n\tu64\t\tatt_dev_sas_addr;\n\tu32\t\tatt_dev_info;\n\tu32\t\tdev_info;\n\tu32\t\tphy_type;\n\tu32\t\tphy_status;\n\tu32\t\tirq_status;\n\tu32\t\tframe_rcvd_size;\n\tu8\t\tframe_rcvd[32];\n\tu8\t\tphy_attached;\n\tu8\t\tphy_mode;\n\tu8\t\treserved[2];\n\tu32\t\tphy_event;\n\tenum sas_linkrate\tminimum_linkrate;\n\tenum sas_linkrate\tmaximum_linkrate;\n};\n\nstruct mvs_device {\n\tstruct list_head\t\tdev_entry;\n\tenum sas_device_type dev_type;\n\tstruct mvs_info *mvi_info;\n\tstruct domain_device *sas_device;\n\tu32 attached_phy;\n\tu32 device_id;\n\tu32 running_req;\n\tu8 taskfileset;\n\tu8 dev_status;\n\tu16 reserved;\n};\n\n \nstruct phy_tuning {\n\t \n\tu8\ttrans_emp_en:1;\n\t \n\tu8\ttrans_emp_amp:4;\n\t \n\tu8\tReserved_2bit_1:3;\n\t \n\tu8\ttrans_amp:5;\n\t \n\tu8\ttrans_amp_adj:2;\n\t \n\tu8\tresv_2bit_2:1;\n\t \n\tu8\treserved[2];\n};\n\nstruct ffe_control {\n\t \n\tu8 ffe_cap_sel:4;\n\t \n\tu8 ffe_rss_sel:3;\n\t \n\tu8 reserved:1;\n};\n\n \nstruct hba_info_page {\n\t \n\t \n\tu8 signature[4];\n\n\t \n\tu32 reserved1[13];\n\n\t \n\t \n\tu64 sas_addr[8];\n\n\t \n\t \n\n\tstruct ffe_control  ffe_ctl[8];\n\t \n\tu32 reserved2[12];\n\n\t \n\t \n\tu8 phy_rate[8];\n\n\t \n\t \n\tstruct phy_tuning   phy_tuning[8];\n\n\t \n\tu32 reserved3[10];\n};\t \n\nstruct mvs_slot_info {\n\tstruct list_head entry;\n\tunion {\n\t\tstruct sas_task *task;\n\t\tvoid *tdata;\n\t};\n\tu32 n_elem;\n\tu32 tx;\n\tu32 slot_tag;\n\n\t \n\tvoid *buf;\n\tdma_addr_t buf_dma;\n\tvoid *response;\n\tstruct mvs_port *port;\n\tstruct mvs_device\t*device;\n\tvoid *open_frame;\n};\n\nstruct mvs_info {\n\tunsigned long flags;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tstruct pci_dev *pdev;\n\tstruct device *dev;\n\n\t \n\tvoid __iomem *regs;\n\n\t \n\tvoid __iomem *regs_ex;\n\tu8 sas_addr[SAS_ADDR_SIZE];\n\n\t \n\tstruct sas_ha_struct *sas;\n\tstruct Scsi_Host *shost;\n\n\t \n\t__le32 *tx;\n\tdma_addr_t tx_dma;\n\n\t \n\tu32 tx_prod;\n\n\t \n\t__le32\t*rx;\n\tdma_addr_t rx_dma;\n\n\t \n\tu32 rx_cons;\n\n\t \n\t__le32 *rx_fis;\n\tdma_addr_t rx_fis_dma;\n\n\t \n\tstruct mvs_cmd_hdr *slot;\n\tdma_addr_t slot_dma;\n\n\tu32 chip_id;\n\tconst struct mvs_chip_info *chip;\n\n\tunsigned long *rsvd_tags;\n\t \n\tstruct mvs_phy phy[MVS_MAX_PHYS];\n\tstruct mvs_port port[MVS_MAX_PHYS];\n\tu32 id;\n\tu64 sata_reg_set;\n\tstruct list_head *hba_list;\n\tstruct list_head soc_entry;\n\tstruct list_head wq_list;\n\tunsigned long instance;\n\tu16 flashid;\n\tu32 flashsize;\n\tu32 flashsectSize;\n\n\tvoid *addon;\n\tstruct hba_info_page hba_info_param;\n\tstruct mvs_device\tdevices[MVS_MAX_DEVICES];\n\tvoid *bulk_buffer;\n\tdma_addr_t bulk_buffer_dma;\n\tvoid *bulk_buffer1;\n\tdma_addr_t bulk_buffer_dma1;\n#define TRASH_BUCKET_SIZE    \t0x20000\n\tvoid *dma_pool;\n\tstruct mvs_slot_info slot_info[];\n};\n\nstruct mvs_prv_info{\n\tu8 n_host;\n\tu8 n_phy;\n\tu8 scan_finished;\n\tu8 reserve;\n\tstruct mvs_info *mvi[2];\n\tstruct tasklet_struct mv_tasklet;\n};\n\nstruct mvs_wq {\n\tstruct delayed_work work_q;\n\tstruct mvs_info *mvi;\n\tvoid *data;\n\tint handler;\n\tstruct list_head entry;\n};\n\nstruct mvs_task_exec_info {\n\tstruct sas_task *task;\n\tstruct mvs_cmd_hdr *hdr;\n\tstruct mvs_port *port;\n\tu32 tag;\n\tint n_elem;\n};\n\n \nvoid mvs_get_sas_addr(void *buf, u32 buflen);\nvoid mvs_iounmap(void __iomem *regs);\nint mvs_ioremap(struct mvs_info *mvi, int bar, int bar_ex);\nvoid mvs_phys_reset(struct mvs_info *mvi, u32 phy_mask, int hard);\nint mvs_phy_control(struct asd_sas_phy *sas_phy, enum phy_func func,\n\t\t\tvoid *funcdata);\nvoid mvs_set_sas_addr(struct mvs_info *mvi, int port_id, u32 off_lo,\n\t\t      u32 off_hi, u64 sas_addr);\nvoid mvs_scan_start(struct Scsi_Host *shost);\nint mvs_scan_finished(struct Scsi_Host *shost, unsigned long time);\nint mvs_queue_command(struct sas_task *task, gfp_t gfp_flags);\nint mvs_abort_task(struct sas_task *task);\nvoid mvs_port_formed(struct asd_sas_phy *sas_phy);\nvoid mvs_port_deformed(struct asd_sas_phy *sas_phy);\nint mvs_dev_found(struct domain_device *dev);\nvoid mvs_dev_gone(struct domain_device *dev);\nint mvs_lu_reset(struct domain_device *dev, u8 *lun);\nint mvs_slot_complete(struct mvs_info *mvi, u32 rx_desc, u32 flags);\nint mvs_I_T_nexus_reset(struct domain_device *dev);\nint mvs_query_task(struct sas_task *task);\nvoid mvs_release_task(struct mvs_info *mvi,\n\t\t\tstruct domain_device *dev);\nvoid mvs_do_release_task(struct mvs_info *mvi, int phy_no,\n\t\t\tstruct domain_device *dev);\nvoid mvs_int_port(struct mvs_info *mvi, int phy_no, u32 events);\nvoid mvs_update_phyinfo(struct mvs_info *mvi, int i, int get_st);\nint mvs_int_rx(struct mvs_info *mvi, bool self_clear);\nstruct mvs_device *mvs_find_dev_by_reg_set(struct mvs_info *mvi, u8 reg_set);\nint mvs_gpio_write(struct sas_ha_struct *, u8 reg_type, u8 reg_index,\n\t\t\tu8 reg_count, u8 *write_data);\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}