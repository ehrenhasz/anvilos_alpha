{
  "module_name": "mv_init.c",
  "hash_id": "174e9ca371db3c998ef43ebb234a84ebd0ab340f075e66e3b9bf8369348be8d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mvsas/mv_init.c",
  "human_readable_source": "\n \n\n\n#include \"mv_sas.h\"\n\nint interrupt_coalescing = 0x80;\n\nstatic struct scsi_transport_template *mvs_stt;\nstatic const struct mvs_chip_info mvs_chips[] = {\n\t[chip_6320] =\t{ 1, 2, 0x400, 17, 16, 6,  9, &mvs_64xx_dispatch, },\n\t[chip_6440] =\t{ 1, 4, 0x400, 17, 16, 6,  9, &mvs_64xx_dispatch, },\n\t[chip_6485] =\t{ 1, 8, 0x800, 33, 32, 6, 10, &mvs_64xx_dispatch, },\n\t[chip_9180] =\t{ 2, 4, 0x800, 17, 64, 8,  9, &mvs_94xx_dispatch, },\n\t[chip_9480] =\t{ 2, 4, 0x800, 17, 64, 8,  9, &mvs_94xx_dispatch, },\n\t[chip_9445] =\t{ 1, 4, 0x800, 17, 64, 8, 11, &mvs_94xx_dispatch, },\n\t[chip_9485] =\t{ 2, 4, 0x800, 17, 64, 8, 11, &mvs_94xx_dispatch, },\n\t[chip_1300] =\t{ 1, 4, 0x400, 17, 16, 6,  9, &mvs_64xx_dispatch, },\n\t[chip_1320] =\t{ 2, 4, 0x800, 17, 64, 8,  9, &mvs_94xx_dispatch, },\n};\n\nstatic const struct attribute_group *mvst_host_groups[];\n\n#define SOC_SAS_NUM 2\n\nstatic const struct scsi_host_template mvs_sht = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= DRV_NAME,\n\t.queuecommand\t\t= sas_queuecommand,\n\t.dma_need_drain\t\t= ata_scsi_dma_need_drain,\n\t.target_alloc\t\t= sas_target_alloc,\n\t.slave_configure\t= sas_slave_configure,\n\t.scan_finished\t\t= mvs_scan_finished,\n\t.scan_start\t\t= mvs_scan_start,\n\t.change_queue_depth\t= sas_change_queue_depth,\n\t.bios_param\t\t= sas_bios_param,\n\t.can_queue\t\t= 1,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.max_sectors\t\t= SCSI_DEFAULT_MAX_SECTORS,\n\t.eh_device_reset_handler = sas_eh_device_reset_handler,\n\t.eh_target_reset_handler = sas_eh_target_reset_handler,\n\t.slave_alloc\t\t= sas_slave_alloc,\n\t.target_destroy\t\t= sas_target_destroy,\n\t.ioctl\t\t\t= sas_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= sas_ioctl,\n#endif\n\t.shost_groups\t\t= mvst_host_groups,\n\t.track_queue_depth\t= 1,\n};\n\nstatic struct sas_domain_function_template mvs_transport_ops = {\n\t.lldd_dev_found \t= mvs_dev_found,\n\t.lldd_dev_gone\t\t= mvs_dev_gone,\n\t.lldd_execute_task\t= mvs_queue_command,\n\t.lldd_control_phy\t= mvs_phy_control,\n\n\t.lldd_abort_task\t= mvs_abort_task,\n\t.lldd_abort_task_set    = sas_abort_task_set,\n\t.lldd_clear_task_set    = sas_clear_task_set,\n\t.lldd_I_T_nexus_reset\t= mvs_I_T_nexus_reset,\n\t.lldd_lu_reset \t\t= mvs_lu_reset,\n\t.lldd_query_task\t= mvs_query_task,\n\t.lldd_port_formed\t= mvs_port_formed,\n\t.lldd_port_deformed     = mvs_port_deformed,\n\n\t.lldd_write_gpio\t= mvs_gpio_write,\n\n};\n\nstatic void mvs_phy_init(struct mvs_info *mvi, int phy_id)\n{\n\tstruct mvs_phy *phy = &mvi->phy[phy_id];\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\tphy->mvi = mvi;\n\tphy->port = NULL;\n\ttimer_setup(&phy->timer, NULL, 0);\n\tsas_phy->enabled = (phy_id < mvi->chip->n_phy) ? 1 : 0;\n\tsas_phy->iproto = SAS_PROTOCOL_ALL;\n\tsas_phy->tproto = 0;\n\tsas_phy->role = PHY_ROLE_INITIATOR;\n\tsas_phy->oob_mode = OOB_NOT_CONNECTED;\n\tsas_phy->linkrate = SAS_LINK_RATE_UNKNOWN;\n\n\tsas_phy->id = phy_id;\n\tsas_phy->sas_addr = &mvi->sas_addr[0];\n\tsas_phy->frame_rcvd = &phy->frame_rcvd[0];\n\tsas_phy->ha = (struct sas_ha_struct *)mvi->shost->hostdata;\n\tsas_phy->lldd_phy = phy;\n}\n\nstatic void mvs_free(struct mvs_info *mvi)\n{\n\tstruct mvs_wq *mwq;\n\tint slot_nr;\n\n\tif (!mvi)\n\t\treturn;\n\n\tif (mvi->flags & MVF_FLAG_SOC)\n\t\tslot_nr = MVS_SOC_SLOTS;\n\telse\n\t\tslot_nr = MVS_CHIP_SLOT_SZ;\n\n\tdma_pool_destroy(mvi->dma_pool);\n\n\tif (mvi->tx)\n\t\tdma_free_coherent(mvi->dev,\n\t\t\t\t  sizeof(*mvi->tx) * MVS_CHIP_SLOT_SZ,\n\t\t\t\t  mvi->tx, mvi->tx_dma);\n\tif (mvi->rx_fis)\n\t\tdma_free_coherent(mvi->dev, MVS_RX_FISL_SZ,\n\t\t\t\t  mvi->rx_fis, mvi->rx_fis_dma);\n\tif (mvi->rx)\n\t\tdma_free_coherent(mvi->dev,\n\t\t\t\t  sizeof(*mvi->rx) * (MVS_RX_RING_SZ + 1),\n\t\t\t\t  mvi->rx, mvi->rx_dma);\n\tif (mvi->slot)\n\t\tdma_free_coherent(mvi->dev,\n\t\t\t\t  sizeof(*mvi->slot) * slot_nr,\n\t\t\t\t  mvi->slot, mvi->slot_dma);\n\n\tif (mvi->bulk_buffer)\n\t\tdma_free_coherent(mvi->dev, TRASH_BUCKET_SIZE,\n\t\t\t\t  mvi->bulk_buffer, mvi->bulk_buffer_dma);\n\tif (mvi->bulk_buffer1)\n\t\tdma_free_coherent(mvi->dev, TRASH_BUCKET_SIZE,\n\t\t\t\t  mvi->bulk_buffer1, mvi->bulk_buffer_dma1);\n\n\tMVS_CHIP_DISP->chip_iounmap(mvi);\n\tif (mvi->shost)\n\t\tscsi_host_put(mvi->shost);\n\tlist_for_each_entry(mwq, &mvi->wq_list, entry)\n\t\tcancel_delayed_work(&mwq->work_q);\n\tkfree(mvi->rsvd_tags);\n\tkfree(mvi);\n}\n\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\nstatic void mvs_tasklet(unsigned long opaque)\n{\n\tu32 stat;\n\tu16 core_nr, i = 0;\n\n\tstruct mvs_info *mvi;\n\tstruct sas_ha_struct *sha = (struct sas_ha_struct *)opaque;\n\n\tcore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\n\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[0];\n\n\tif (unlikely(!mvi))\n\t\tBUG_ON(1);\n\n\tstat = MVS_CHIP_DISP->isr_status(mvi, mvi->pdev->irq);\n\tif (!stat)\n\t\tgoto out;\n\n\tfor (i = 0; i < core_nr; i++) {\n\t\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[i];\n\t\tMVS_CHIP_DISP->isr(mvi, mvi->pdev->irq, stat);\n\t}\nout:\n\tMVS_CHIP_DISP->interrupt_enable(mvi);\n\n}\n#endif\n\nstatic irqreturn_t mvs_interrupt(int irq, void *opaque)\n{\n\tu32 stat;\n\tstruct mvs_info *mvi;\n\tstruct sas_ha_struct *sha = opaque;\n#ifndef CONFIG_SCSI_MVSAS_TASKLET\n\tu32 i;\n\tu32 core_nr;\n\n\tcore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\n#endif\n\n\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[0];\n\n\tif (unlikely(!mvi))\n\t\treturn IRQ_NONE;\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\n\tMVS_CHIP_DISP->interrupt_disable(mvi);\n#endif\n\n\tstat = MVS_CHIP_DISP->isr_status(mvi, irq);\n\tif (!stat) {\n\t#ifdef CONFIG_SCSI_MVSAS_TASKLET\n\t\tMVS_CHIP_DISP->interrupt_enable(mvi);\n\t#endif\n\t\treturn IRQ_NONE;\n\t}\n\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\n\ttasklet_schedule(&((struct mvs_prv_info *)sha->lldd_ha)->mv_tasklet);\n#else\n\tfor (i = 0; i < core_nr; i++) {\n\t\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[i];\n\t\tMVS_CHIP_DISP->isr(mvi, irq, stat);\n\t}\n#endif\n\treturn IRQ_HANDLED;\n}\n\nstatic int mvs_alloc(struct mvs_info *mvi, struct Scsi_Host *shost)\n{\n\tint i = 0, slot_nr;\n\tchar pool_name[32];\n\n\tif (mvi->flags & MVF_FLAG_SOC)\n\t\tslot_nr = MVS_SOC_SLOTS;\n\telse\n\t\tslot_nr = MVS_CHIP_SLOT_SZ;\n\n\tspin_lock_init(&mvi->lock);\n\tfor (i = 0; i < mvi->chip->n_phy; i++) {\n\t\tmvs_phy_init(mvi, i);\n\t\tmvi->port[i].wide_port_phymap = 0;\n\t\tmvi->port[i].port_attached = 0;\n\t\tINIT_LIST_HEAD(&mvi->port[i].list);\n\t}\n\tfor (i = 0; i < MVS_MAX_DEVICES; i++) {\n\t\tmvi->devices[i].taskfileset = MVS_ID_NOT_MAPPED;\n\t\tmvi->devices[i].dev_type = SAS_PHY_UNUSED;\n\t\tmvi->devices[i].device_id = i;\n\t\tmvi->devices[i].dev_status = MVS_DEV_NORMAL;\n\t}\n\n\t \n\tmvi->tx = dma_alloc_coherent(mvi->dev,\n\t\t\t\t     sizeof(*mvi->tx) * MVS_CHIP_SLOT_SZ,\n\t\t\t\t     &mvi->tx_dma, GFP_KERNEL);\n\tif (!mvi->tx)\n\t\tgoto err_out;\n\tmvi->rx_fis = dma_alloc_coherent(mvi->dev, MVS_RX_FISL_SZ,\n\t\t\t\t\t &mvi->rx_fis_dma, GFP_KERNEL);\n\tif (!mvi->rx_fis)\n\t\tgoto err_out;\n\n\tmvi->rx = dma_alloc_coherent(mvi->dev,\n\t\t\t\t     sizeof(*mvi->rx) * (MVS_RX_RING_SZ + 1),\n\t\t\t\t     &mvi->rx_dma, GFP_KERNEL);\n\tif (!mvi->rx)\n\t\tgoto err_out;\n\tmvi->rx[0] = cpu_to_le32(0xfff);\n\tmvi->rx_cons = 0xfff;\n\n\tmvi->slot = dma_alloc_coherent(mvi->dev,\n\t\t\t\t       sizeof(*mvi->slot) * slot_nr,\n\t\t\t\t       &mvi->slot_dma, GFP_KERNEL);\n\tif (!mvi->slot)\n\t\tgoto err_out;\n\n\tmvi->bulk_buffer = dma_alloc_coherent(mvi->dev,\n\t\t\t\t       TRASH_BUCKET_SIZE,\n\t\t\t\t       &mvi->bulk_buffer_dma, GFP_KERNEL);\n\tif (!mvi->bulk_buffer)\n\t\tgoto err_out;\n\n\tmvi->bulk_buffer1 = dma_alloc_coherent(mvi->dev,\n\t\t\t\t       TRASH_BUCKET_SIZE,\n\t\t\t\t       &mvi->bulk_buffer_dma1, GFP_KERNEL);\n\tif (!mvi->bulk_buffer1)\n\t\tgoto err_out;\n\n\tsprintf(pool_name, \"%s%d\", \"mvs_dma_pool\", mvi->id);\n\tmvi->dma_pool = dma_pool_create(pool_name, &mvi->pdev->dev,\n\t\t\t\t\tMVS_SLOT_BUF_SZ, 16, 0);\n\tif (!mvi->dma_pool) {\n\t\t\tprintk(KERN_DEBUG \"failed to create dma pool %s.\\n\", pool_name);\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\nerr_out:\n\treturn 1;\n}\n\n\nint mvs_ioremap(struct mvs_info *mvi, int bar, int bar_ex)\n{\n\tunsigned long res_start, res_len, res_flag_ex = 0;\n\tstruct pci_dev *pdev = mvi->pdev;\n\tif (bar_ex != -1) {\n\t\t \n\t\tres_start = pci_resource_start(pdev, bar_ex);\n\t\tres_len = pci_resource_len(pdev, bar_ex);\n\t\tif (!res_start || !res_len)\n\t\t\tgoto err_out;\n\n\t\tres_flag_ex = pci_resource_flags(pdev, bar_ex);\n\t\tif (res_flag_ex & IORESOURCE_MEM)\n\t\t\tmvi->regs_ex = ioremap(res_start, res_len);\n\t\telse\n\t\t\tmvi->regs_ex = (void *)res_start;\n\t\tif (!mvi->regs_ex)\n\t\t\tgoto err_out;\n\t}\n\n\tres_start = pci_resource_start(pdev, bar);\n\tres_len = pci_resource_len(pdev, bar);\n\tif (!res_start || !res_len) {\n\t\tiounmap(mvi->regs_ex);\n\t\tmvi->regs_ex = NULL;\n\t\tgoto err_out;\n\t}\n\n\tmvi->regs = ioremap(res_start, res_len);\n\n\tif (!mvi->regs) {\n\t\tif (mvi->regs_ex && (res_flag_ex & IORESOURCE_MEM))\n\t\t\tiounmap(mvi->regs_ex);\n\t\tmvi->regs_ex = NULL;\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\nerr_out:\n\treturn -1;\n}\n\nvoid mvs_iounmap(void __iomem *regs)\n{\n\tiounmap(regs);\n}\n\nstatic struct mvs_info *mvs_pci_alloc(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent,\n\t\t\t\tstruct Scsi_Host *shost, unsigned int id)\n{\n\tstruct mvs_info *mvi = NULL;\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\n\tmvi = kzalloc(sizeof(*mvi) +\n\t\t(1L << mvs_chips[ent->driver_data].slot_width) *\n\t\tsizeof(struct mvs_slot_info), GFP_KERNEL);\n\tif (!mvi)\n\t\treturn NULL;\n\n\tmvi->pdev = pdev;\n\tmvi->dev = &pdev->dev;\n\tmvi->chip_id = ent->driver_data;\n\tmvi->chip = &mvs_chips[mvi->chip_id];\n\tINIT_LIST_HEAD(&mvi->wq_list);\n\n\t((struct mvs_prv_info *)sha->lldd_ha)->mvi[id] = mvi;\n\t((struct mvs_prv_info *)sha->lldd_ha)->n_phy = mvi->chip->n_phy;\n\n\tmvi->id = id;\n\tmvi->sas = sha;\n\tmvi->shost = shost;\n\n\tmvi->rsvd_tags = bitmap_zalloc(MVS_RSVD_SLOTS, GFP_KERNEL);\n\tif (!mvi->rsvd_tags)\n\t\tgoto err_out;\n\n\tif (MVS_CHIP_DISP->chip_ioremap(mvi))\n\t\tgoto err_out;\n\tif (!mvs_alloc(mvi, shost))\n\t\treturn mvi;\nerr_out:\n\tmvs_free(mvi);\n\treturn NULL;\n}\n\nstatic int pci_go_64(struct pci_dev *pdev)\n{\n\tint rc;\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rc) {\n\t\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (rc) {\n\t\t\tdev_printk(KERN_ERR, &pdev->dev,\n\t\t\t\t   \"32-bit DMA enable failed\\n\");\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int mvs_prep_sas_ha_init(struct Scsi_Host *shost,\n\t\t\t\tconst struct mvs_chip_info *chip_info)\n{\n\tint phy_nr, port_nr; unsigned short core_nr;\n\tstruct asd_sas_phy **arr_phy;\n\tstruct asd_sas_port **arr_port;\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\n\tcore_nr = chip_info->n_host;\n\tphy_nr  = core_nr * chip_info->n_phy;\n\tport_nr = phy_nr;\n\n\tmemset(sha, 0x00, sizeof(struct sas_ha_struct));\n\tarr_phy  = kcalloc(phy_nr, sizeof(void *), GFP_KERNEL);\n\tarr_port = kcalloc(port_nr, sizeof(void *), GFP_KERNEL);\n\tif (!arr_phy || !arr_port)\n\t\tgoto exit_free;\n\n\tsha->sas_phy = arr_phy;\n\tsha->sas_port = arr_port;\n\tsha->shost = shost;\n\n\tsha->lldd_ha = kzalloc(sizeof(struct mvs_prv_info), GFP_KERNEL);\n\tif (!sha->lldd_ha)\n\t\tgoto exit_free;\n\n\t((struct mvs_prv_info *)sha->lldd_ha)->n_host = core_nr;\n\n\tshost->transportt = mvs_stt;\n\tshost->max_id = MVS_MAX_DEVICES;\n\tshost->max_lun = ~0;\n\tshost->max_channel = 1;\n\tshost->max_cmd_len = 16;\n\n\treturn 0;\nexit_free:\n\tkfree(arr_phy);\n\tkfree(arr_port);\n\treturn -1;\n\n}\n\nstatic void  mvs_post_sas_ha_init(struct Scsi_Host *shost,\n\t\t\tconst struct mvs_chip_info *chip_info)\n{\n\tint can_queue, i = 0, j = 0;\n\tstruct mvs_info *mvi = NULL;\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tunsigned short nr_core = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\n\n\tfor (j = 0; j < nr_core; j++) {\n\t\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[j];\n\t\tfor (i = 0; i < chip_info->n_phy; i++) {\n\t\t\tsha->sas_phy[j * chip_info->n_phy  + i] =\n\t\t\t\t&mvi->phy[i].sas_phy;\n\t\t\tsha->sas_port[j * chip_info->n_phy + i] =\n\t\t\t\t&mvi->port[i].sas_port;\n\t\t}\n\t}\n\n\tsha->sas_ha_name = DRV_NAME;\n\tsha->dev = mvi->dev;\n\tsha->sas_addr = &mvi->sas_addr[0];\n\n\tsha->num_phys = nr_core * chip_info->n_phy;\n\n\tif (mvi->flags & MVF_FLAG_SOC)\n\t\tcan_queue = MVS_SOC_CAN_QUEUE;\n\telse\n\t\tcan_queue = MVS_CHIP_SLOT_SZ;\n\n\tcan_queue -= MVS_RSVD_SLOTS;\n\n\tshost->sg_tablesize = min_t(u16, SG_ALL, MVS_MAX_SG);\n\tshost->can_queue = can_queue;\n\tmvi->shost->cmd_per_lun = MVS_QUEUE_SIZE;\n\tsha->shost = mvi->shost;\n}\n\nstatic void mvs_init_sas_add(struct mvs_info *mvi)\n{\n\tu8 i;\n\tfor (i = 0; i < mvi->chip->n_phy; i++) {\n\t\tmvi->phy[i].dev_sas_addr = 0x5005043011ab0000ULL;\n\t\tmvi->phy[i].dev_sas_addr =\n\t\t\tcpu_to_be64((u64)(*(u64 *)&mvi->phy[i].dev_sas_addr));\n\t}\n\n\tmemcpy(mvi->sas_addr, &mvi->phy[0].dev_sas_addr, SAS_ADDR_SIZE);\n}\n\nstatic int mvs_pci_init(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tunsigned int rc, nhost = 0;\n\tstruct mvs_info *mvi;\n\tirq_handler_t irq_handler = mvs_interrupt;\n\tstruct Scsi_Host *shost = NULL;\n\tconst struct mvs_chip_info *chip;\n\n\tdev_printk(KERN_INFO, &pdev->dev,\n\t\t\"mvsas: driver version %s\\n\", DRV_VERSION);\n\trc = pci_enable_device(pdev);\n\tif (rc)\n\t\tgoto err_out_enable;\n\n\tpci_set_master(pdev);\n\n\trc = pci_request_regions(pdev, DRV_NAME);\n\tif (rc)\n\t\tgoto err_out_disable;\n\n\trc = pci_go_64(pdev);\n\tif (rc)\n\t\tgoto err_out_regions;\n\n\tshost = scsi_host_alloc(&mvs_sht, sizeof(void *));\n\tif (!shost) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_regions;\n\t}\n\n\tchip = &mvs_chips[ent->driver_data];\n\tSHOST_TO_SAS_HA(shost) =\n\t\tkcalloc(1, sizeof(struct sas_ha_struct), GFP_KERNEL);\n\tif (!SHOST_TO_SAS_HA(shost)) {\n\t\tscsi_host_put(shost);\n\t\trc = -ENOMEM;\n\t\tgoto err_out_regions;\n\t}\n\n\trc = mvs_prep_sas_ha_init(shost, chip);\n\tif (rc) {\n\t\tscsi_host_put(shost);\n\t\trc = -ENOMEM;\n\t\tgoto err_out_regions;\n\t}\n\n\tpci_set_drvdata(pdev, SHOST_TO_SAS_HA(shost));\n\n\tdo {\n\t\tmvi = mvs_pci_alloc(pdev, ent, shost, nhost);\n\t\tif (!mvi) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err_out_regions;\n\t\t}\n\n\t\tmemset(&mvi->hba_info_param, 0xFF,\n\t\t\tsizeof(struct hba_info_page));\n\n\t\tmvs_init_sas_add(mvi);\n\n\t\tmvi->instance = nhost;\n\t\trc = MVS_CHIP_DISP->chip_init(mvi);\n\t\tif (rc) {\n\t\t\tmvs_free(mvi);\n\t\t\tgoto err_out_regions;\n\t\t}\n\t\tnhost++;\n\t} while (nhost < chip->n_host);\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\n\t{\n\tstruct mvs_prv_info *mpi = SHOST_TO_SAS_HA(shost)->lldd_ha;\n\n\ttasklet_init(&(mpi->mv_tasklet), mvs_tasklet,\n\t\t     (unsigned long)SHOST_TO_SAS_HA(shost));\n\t}\n#endif\n\n\tmvs_post_sas_ha_init(shost, chip);\n\n\trc = scsi_add_host(shost, &pdev->dev);\n\tif (rc)\n\t\tgoto err_out_shost;\n\n\trc = sas_register_ha(SHOST_TO_SAS_HA(shost));\n\tif (rc)\n\t\tgoto err_out_shost;\n\trc = request_irq(pdev->irq, irq_handler, IRQF_SHARED,\n\t\tDRV_NAME, SHOST_TO_SAS_HA(shost));\n\tif (rc)\n\t\tgoto err_not_sas;\n\n\tMVS_CHIP_DISP->interrupt_enable(mvi);\n\n\tscsi_scan_host(mvi->shost);\n\n\treturn 0;\n\nerr_not_sas:\n\tsas_unregister_ha(SHOST_TO_SAS_HA(shost));\nerr_out_shost:\n\tscsi_remove_host(mvi->shost);\nerr_out_regions:\n\tpci_release_regions(pdev);\nerr_out_disable:\n\tpci_disable_device(pdev);\nerr_out_enable:\n\treturn rc;\n}\n\nstatic void mvs_pci_remove(struct pci_dev *pdev)\n{\n\tunsigned short core_nr, i = 0;\n\tstruct sas_ha_struct *sha = pci_get_drvdata(pdev);\n\tstruct mvs_info *mvi = NULL;\n\n\tcore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\n\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[0];\n\n#ifdef CONFIG_SCSI_MVSAS_TASKLET\n\ttasklet_kill(&((struct mvs_prv_info *)sha->lldd_ha)->mv_tasklet);\n#endif\n\n\tsas_unregister_ha(sha);\n\tsas_remove_host(mvi->shost);\n\n\tMVS_CHIP_DISP->interrupt_disable(mvi);\n\tfree_irq(mvi->pdev->irq, sha);\n\tfor (i = 0; i < core_nr; i++) {\n\t\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[i];\n\t\tmvs_free(mvi);\n\t}\n\tkfree(sha->sas_phy);\n\tkfree(sha->sas_port);\n\tkfree(sha);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\treturn;\n}\n\nstatic struct pci_device_id mvs_pci_table[] = {\n\t{ PCI_VDEVICE(MARVELL, 0x6320), chip_6320 },\n\t{ PCI_VDEVICE(MARVELL, 0x6340), chip_6440 },\n\t{\n\t\t.vendor \t= PCI_VENDOR_ID_MARVELL,\n\t\t.device \t= 0x6440,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= 0x6480,\n\t\t.class\t\t= 0,\n\t\t.class_mask\t= 0,\n\t\t.driver_data\t= chip_6485,\n\t},\n\t{ PCI_VDEVICE(MARVELL, 0x6440), chip_6440 },\n\t{ PCI_VDEVICE(MARVELL, 0x6485), chip_6485 },\n\t{ PCI_VDEVICE(MARVELL, 0x9480), chip_9480 },\n\t{ PCI_VDEVICE(MARVELL, 0x9180), chip_9180 },\n\t{ PCI_VDEVICE(ARECA, PCI_DEVICE_ID_ARECA_1300), chip_1300 },\n\t{ PCI_VDEVICE(ARECA, PCI_DEVICE_ID_ARECA_1320), chip_1320 },\n\t{ PCI_VDEVICE(ADAPTEC2, 0x0450), chip_6440 },\n\t{ PCI_VDEVICE(TTI, 0x2640), chip_6440 },\n\t{ PCI_VDEVICE(TTI, 0x2710), chip_9480 },\n\t{ PCI_VDEVICE(TTI, 0x2720), chip_9480 },\n\t{ PCI_VDEVICE(TTI, 0x2721), chip_9480 },\n\t{ PCI_VDEVICE(TTI, 0x2722), chip_9480 },\n\t{ PCI_VDEVICE(TTI, 0x2740), chip_9480 },\n\t{ PCI_VDEVICE(TTI, 0x2744), chip_9480 },\n\t{ PCI_VDEVICE(TTI, 0x2760), chip_9480 },\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_MARVELL_EXT,\n\t\t.device\t\t= 0x9480,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= 0x9480,\n\t\t.class\t\t= 0,\n\t\t.class_mask\t= 0,\n\t\t.driver_data\t= chip_9480,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_MARVELL_EXT,\n\t\t.device\t\t= 0x9445,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= 0x9480,\n\t\t.class\t\t= 0,\n\t\t.class_mask\t= 0,\n\t\t.driver_data\t= chip_9445,\n\t},\n\t{ PCI_VDEVICE(MARVELL_EXT, 0x9485), chip_9485 },  \n\t{ PCI_VDEVICE(OCZ, 0x1021), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1022), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1040), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1041), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1042), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1043), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1044), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1080), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1083), chip_9485},  \n\t{ PCI_VDEVICE(OCZ, 0x1084), chip_9485},  \n\n\t{ }\t \n};\n\nstatic struct pci_driver mvs_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= mvs_pci_table,\n\t.probe\t\t= mvs_pci_init,\n\t.remove\t\t= mvs_pci_remove,\n};\n\nstatic ssize_t driver_version_show(struct device *cdev,\n\t\t\t\t   struct device_attribute *attr, char *buffer)\n{\n\treturn sysfs_emit(buffer, \"%s\\n\", DRV_VERSION);\n}\n\nstatic DEVICE_ATTR_RO(driver_version);\n\nstatic ssize_t interrupt_coalescing_store(struct device *cdev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buffer, size_t size)\n{\n\tunsigned int val = 0;\n\tstruct mvs_info *mvi = NULL;\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);\n\tu8 i, core_nr;\n\tif (buffer == NULL)\n\t\treturn size;\n\n\tif (sscanf(buffer, \"%u\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif (val >= 0x10000) {\n\t\tmv_dprintk(\"interrupt coalescing timer %d us is\"\n\t\t\t\"too long\\n\", val);\n\t\treturn strlen(buffer);\n\t}\n\n\tinterrupt_coalescing = val;\n\n\tcore_nr = ((struct mvs_prv_info *)sha->lldd_ha)->n_host;\n\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[0];\n\n\tif (unlikely(!mvi))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < core_nr; i++) {\n\t\tmvi = ((struct mvs_prv_info *)sha->lldd_ha)->mvi[i];\n\t\tif (MVS_CHIP_DISP->tune_interrupt)\n\t\t\tMVS_CHIP_DISP->tune_interrupt(mvi,\n\t\t\t\tinterrupt_coalescing);\n\t}\n\tmv_dprintk(\"set interrupt coalescing time to %d us\\n\",\n\t\tinterrupt_coalescing);\n\treturn strlen(buffer);\n}\n\nstatic ssize_t interrupt_coalescing_show(struct device *cdev,\n\t\t\t\t\t struct device_attribute *attr, char *buffer)\n{\n\treturn sysfs_emit(buffer, \"%d\\n\", interrupt_coalescing);\n}\n\nstatic DEVICE_ATTR_RW(interrupt_coalescing);\n\nstatic int __init mvs_init(void)\n{\n\tint rc;\n\tmvs_stt = sas_domain_attach_transport(&mvs_transport_ops);\n\tif (!mvs_stt)\n\t\treturn -ENOMEM;\n\n\trc = pci_register_driver(&mvs_pci_driver);\n\tif (rc)\n\t\tgoto err_out;\n\n\treturn 0;\n\nerr_out:\n\tsas_release_transport(mvs_stt);\n\treturn rc;\n}\n\nstatic void __exit mvs_exit(void)\n{\n\tpci_unregister_driver(&mvs_pci_driver);\n\tsas_release_transport(mvs_stt);\n}\n\nstatic struct attribute *mvst_host_attrs[] = {\n\t&dev_attr_driver_version.attr,\n\t&dev_attr_interrupt_coalescing.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(mvst_host);\n\nmodule_init(mvs_init);\nmodule_exit(mvs_exit);\n\nMODULE_AUTHOR(\"Jeff Garzik <jgarzik@pobox.com>\");\nMODULE_DESCRIPTION(\"Marvell 88SE6440 SAS/SATA controller driver\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(\"GPL\");\n#ifdef CONFIG_PCI\nMODULE_DEVICE_TABLE(pci, mvs_pci_table);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}