{
  "module_name": "qlogicfas.c",
  "hash_id": "26dc509ddcf227e6e01e1fc03254c152d77fec4dfaa8dd06eadb08e3cd336d36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qlogicfas.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/blkdev.h>\t\t \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/unistd.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/dma.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"qlogicfas408.h\"\n\n \n#define INT_TYPE\t2\n\nstatic char qlogicfas_name[] = \"qlogicfas\";\n\n \n \nstatic struct Scsi_Host *__qlogicfas_detect(struct scsi_host_template *host,\n\t\t\t\t\t\t\t\tint qbase,\n\t\t\t\t\t\t\t\tint qlirq)\n{\n\tint qltyp;\t\t \n\tint qinitid;\n\tstruct Scsi_Host *hreg;\t \n\tstruct qlogicfas408_priv *priv;\n\n\t \n\n\tif (!qbase || qlirq == -1)\n\t\tgoto err;\n\n\tif (!request_region(qbase, 0x10, qlogicfas_name)) {\n\t\tprintk(KERN_INFO \"%s: address %#x is busy\\n\", qlogicfas_name,\n\t\t\t\t\t\t\t      qbase);\n\t\tgoto err;\n\t}\n\n\tif (!qlogicfas408_detect(qbase, INT_TYPE)) {\n\t\tprintk(KERN_WARNING \"%s: probe failed for %#x\\n\",\n\t\t\t\t\t\t\t\tqlogicfas_name,\n\t\t\t\t\t\t\t\tqbase);\n\t\tgoto err_release_mem;\n\t}\n\n\tprintk(KERN_INFO \"%s: Using preset base address of %03x,\"\n\t\t\t \" IRQ %d\\n\", qlogicfas_name, qbase, qlirq);\n\n\tqltyp = qlogicfas408_get_chip_type(qbase, INT_TYPE);\n\tqinitid = host->this_id;\n\tif (qinitid < 0)\n\t\tqinitid = 7;\t \n\n\tqlogicfas408_setup(qbase, qinitid, INT_TYPE);\n\n\threg = scsi_host_alloc(host, sizeof(struct qlogicfas408_priv));\n\tif (!hreg)\n\t\tgoto err_release_mem;\n\tpriv = get_priv_by_host(hreg);\n\threg->io_port = qbase;\n\threg->n_io_port = 16;\n\threg->dma_channel = -1;\n\tif (qlirq != -1)\n\t\threg->irq = qlirq;\n\tpriv->qbase = qbase;\n\tpriv->qlirq = qlirq;\n\tpriv->qinitid = qinitid;\n\tpriv->shost = hreg;\n\tpriv->int_type = INT_TYPE;\n\n\tsprintf(priv->qinfo,\n\t\t\"Qlogicfas Driver version 0.46, chip %02X at %03X, IRQ %d, TPdma:%d\",\n\t\tqltyp, qbase, qlirq, QL_TURBO_PDMA);\n\thost->name = qlogicfas_name;\n\n\tif (request_irq(qlirq, qlogicfas408_ihandl, 0, qlogicfas_name, hreg))\n\t\tgoto free_scsi_host;\n\n\tif (scsi_add_host(hreg, NULL))\n\t\tgoto free_interrupt;\n\n\tscsi_scan_host(hreg);\n\n\treturn hreg;\n\nfree_interrupt:\n\tfree_irq(qlirq, hreg);\n\nfree_scsi_host:\n\tscsi_host_put(hreg);\n\nerr_release_mem:\n\trelease_region(qbase, 0x10);\nerr:\n\treturn NULL;\n}\n\n#define MAX_QLOGICFAS\t8\nstatic struct qlogicfas408_priv *cards;\nstatic int iobase[MAX_QLOGICFAS];\nstatic int irq[MAX_QLOGICFAS] = { [0 ... MAX_QLOGICFAS-1] = -1 };\nmodule_param_hw_array(iobase, int, ioport, NULL, 0);\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nMODULE_PARM_DESC(iobase, \"I/O address\");\nMODULE_PARM_DESC(irq, \"IRQ\");\n\nstatic int qlogicfas_detect(struct scsi_host_template *sht)\n{\n\tstruct Scsi_Host *shost;\n\tstruct qlogicfas408_priv *priv;\n\tint num;\n\n\tfor (num = 0; num < MAX_QLOGICFAS; num++) {\n\t\tshost = __qlogicfas_detect(sht, iobase[num], irq[num]);\n\t\tif (shost == NULL) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tpriv = get_priv_by_host(shost);\n\t\tpriv->next = cards;\n\t\tcards = priv;\n\t}\n\n\treturn num;\n}\n\nstatic int qlogicfas_release(struct Scsi_Host *shost)\n{\n\tstruct qlogicfas408_priv *priv = get_priv_by_host(shost);\n\n\tscsi_remove_host(shost);\n\tif (shost->irq) {\n\t\tqlogicfas408_disable_ints(priv);\t\n\t\tfree_irq(shost->irq, shost);\n\t}\n\tif (shost->io_port && shost->n_io_port)\n\t\trelease_region(shost->io_port, shost->n_io_port);\n\tscsi_host_put(shost);\n\n\treturn 0;\n}\n\n \nstatic struct scsi_host_template qlogicfas_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= qlogicfas_name,\n\t.proc_name\t\t= qlogicfas_name,\n\t.info\t\t\t= qlogicfas408_info,\n\t.queuecommand\t\t= qlogicfas408_queuecommand,\n\t.eh_abort_handler\t= qlogicfas408_abort,\n\t.eh_host_reset_handler\t= qlogicfas408_host_reset,\n\t.bios_param\t\t= qlogicfas408_biosparam,\n\t.can_queue\t\t= 1,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n};\n\nstatic __init int qlogicfas_init(void)\n{\n\tif (!qlogicfas_detect(&qlogicfas_driver_template)) {\n\t\t \n\t\tprintk(KERN_INFO \"%s: no cards were found, please specify \"\n\t\t\t\t \"I/O address and IRQ using iobase= and irq= \"\n\t\t\t\t \"options\", qlogicfas_name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic __exit void qlogicfas_exit(void)\n{\n\tstruct qlogicfas408_priv *priv;\n\n\tfor (priv = cards; priv != NULL; priv = priv->next)\n\t\tqlogicfas_release(priv->shost);\n}\n\nMODULE_AUTHOR(\"Tom Zerucha, Michael Griffith\");\nMODULE_DESCRIPTION(\"Driver for the Qlogic FAS408 based ISA card\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(qlogicfas_init);\nmodule_exit(qlogicfas_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}