{
  "module_name": "scsi_ioctl.c",
  "hash_id": "6a2ab4a4cf2e766d488ba735ed92bdc23bfcf2367c5fd112c80b3d698214a79b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_ioctl.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/cdrom.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n#include <scsi/sg.h>\n#include <scsi/scsi_dbg.h>\n\n#include \"scsi_logging.h\"\n\n#define NORMAL_RETRIES\t\t\t5\n#define IOCTL_NORMAL_TIMEOUT\t\t\t(10 * HZ)\n\n#define MAX_BUF PAGE_SIZE\n\n \nstatic int ioctl_probe(struct Scsi_Host *host, void __user *buffer)\n{\n\tunsigned int len, slen;\n\tconst char *string;\n\n\tif (buffer) {\n\t\tif (get_user(len, (unsigned int __user *) buffer))\n\t\t\treturn -EFAULT;\n\n\t\tif (host->hostt->info)\n\t\t\tstring = host->hostt->info(host);\n\t\telse\n\t\t\tstring = host->hostt->name;\n\t\tif (string) {\n\t\t\tslen = strlen(string);\n\t\t\tif (len > slen)\n\t\t\t\tlen = slen + 1;\n\t\t\tif (copy_to_user(buffer, string, len))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int ioctl_internal_command(struct scsi_device *sdev, char *cmd,\n\t\t\t\t  int timeout, int retries)\n{\n\tint result;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\n\tSCSI_LOG_IOCTL(1, sdev_printk(KERN_INFO, sdev,\n\t\t\t\t      \"Trying ioctl with scsi command %d\\n\", *cmd));\n\n\tresult = scsi_execute_cmd(sdev, cmd, REQ_OP_DRV_IN, NULL, 0, timeout,\n\t\t\t\t  retries, &exec_args);\n\n\tSCSI_LOG_IOCTL(2, sdev_printk(KERN_INFO, sdev,\n\t\t\t\t      \"Ioctl returned  0x%x\\n\", result));\n\n\tif (result < 0)\n\t\tgoto out;\n\tif (scsi_sense_valid(&sshdr)) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase ILLEGAL_REQUEST:\n\t\t\tif (cmd[0] == ALLOW_MEDIUM_REMOVAL)\n\t\t\t\tsdev->lockable = 0;\n\t\t\telse\n\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t    \"ioctl_internal_command: \"\n\t\t\t\t\t    \"ILLEGAL REQUEST \"\n\t\t\t\t\t    \"asc=0x%x ascq=0x%x\\n\",\n\t\t\t\t\t    sshdr.asc, sshdr.ascq);\n\t\t\tbreak;\n\t\tcase NOT_READY:\t \n\t\t\tif (sdev->removable)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase UNIT_ATTENTION:\n\t\t\tif (sdev->removable) {\n\t\t\t\tsdev->changed = 1;\n\t\t\t\tresult = 0;\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t \n\t\tdefault:\n\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t    \"ioctl_internal_command return code = %x\\n\",\n\t\t\t\t    result);\n\t\t\tscsi_print_sense_hdr(sdev, NULL, &sshdr);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tSCSI_LOG_IOCTL(2, sdev_printk(KERN_INFO, sdev,\n\t\t\t\t      \"IOCTL Releasing command\\n\"));\n\treturn result;\n}\n\nint scsi_set_medium_removal(struct scsi_device *sdev, char state)\n{\n\tchar scsi_cmd[MAX_COMMAND_SIZE];\n\tint ret;\n\n\tif (!sdev->removable || !sdev->lockable)\n\t       return 0;\n\n\tscsi_cmd[0] = ALLOW_MEDIUM_REMOVAL;\n\tscsi_cmd[1] = 0;\n\tscsi_cmd[2] = 0;\n\tscsi_cmd[3] = 0;\n\tscsi_cmd[4] = state;\n\tscsi_cmd[5] = 0;\n\n\tret = ioctl_internal_command(sdev, scsi_cmd,\n\t\t\tIOCTL_NORMAL_TIMEOUT, NORMAL_RETRIES);\n\tif (ret == 0)\n\t\tsdev->locked = (state == SCSI_REMOVAL_PREVENT);\n\treturn ret;\n}\nEXPORT_SYMBOL(scsi_set_medium_removal);\n\n \nstatic int scsi_ioctl_get_pci(struct scsi_device *sdev, void __user *arg)\n{\n\tstruct device *dev = scsi_get_device(sdev->host);\n\tconst char *name;\n\n        if (!dev)\n\t\treturn -ENXIO;\n\n\tname = dev_name(dev);\n\n\t \n        return copy_to_user(arg, name, min(strlen(name), (size_t)20))\n\t\t? -EFAULT: 0;\n}\n\nstatic int sg_get_version(int __user *p)\n{\n\tstatic const int sg_version_num = 30527;\n\treturn put_user(sg_version_num, p);\n}\n\nstatic int sg_set_timeout(struct scsi_device *sdev, int __user *p)\n{\n\tint timeout, err = get_user(timeout, p);\n\n\tif (!err)\n\t\tsdev->sg_timeout = clock_t_to_jiffies(timeout);\n\n\treturn err;\n}\n\nstatic int sg_get_reserved_size(struct scsi_device *sdev, int __user *p)\n{\n\tint val = min(sdev->sg_reserved_size,\n\t\t      queue_max_bytes(sdev->request_queue));\n\n\treturn put_user(val, p);\n}\n\nstatic int sg_set_reserved_size(struct scsi_device *sdev, int __user *p)\n{\n\tint size, err = get_user(size, p);\n\n\tif (err)\n\t\treturn err;\n\n\tif (size < 0)\n\t\treturn -EINVAL;\n\n\tsdev->sg_reserved_size = min_t(unsigned int, size,\n\t\t\t\t       queue_max_bytes(sdev->request_queue));\n\treturn 0;\n}\n\n \nstatic int sg_emulated_host(struct request_queue *q, int __user *p)\n{\n\treturn put_user(1, p);\n}\n\nstatic int scsi_get_idlun(struct scsi_device *sdev, void __user *argp)\n{\n\tstruct scsi_idlun v = {\n\t\t.dev_id = (sdev->id & 0xff) +\n\t\t\t((sdev->lun & 0xff) << 8) +\n\t\t\t((sdev->channel & 0xff) << 16) +\n\t\t\t((sdev->host->host_no & 0xff) << 24),\n\t\t.host_unique_id = sdev->host->unique_id\n\t};\n\tif (copy_to_user(argp, &v, sizeof(struct scsi_idlun)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int scsi_send_start_stop(struct scsi_device *sdev, int data)\n{\n\tu8 cdb[MAX_COMMAND_SIZE] = { };\n\n\tcdb[0] = START_STOP;\n\tcdb[4] = data;\n\treturn ioctl_internal_command(sdev, cdb, START_STOP_TIMEOUT,\n\t\t\t\t      NORMAL_RETRIES);\n}\n\n \nbool scsi_cmd_allowed(unsigned char *cmd, bool open_for_write)\n{\n\t \n\tif (capable(CAP_SYS_RAWIO))\n\t\treturn true;\n\n\t \n\tswitch (cmd[0]) {\n\t \n\tcase TEST_UNIT_READY:\n\tcase REQUEST_SENSE:\n\tcase READ_6:\n\tcase READ_10:\n\tcase READ_12:\n\tcase READ_16:\n\tcase READ_BUFFER:\n\tcase READ_DEFECT_DATA:\n\tcase READ_CAPACITY:  \n\tcase READ_LONG:\n\tcase INQUIRY:\n\tcase MODE_SENSE:\n\tcase MODE_SENSE_10:\n\tcase LOG_SENSE:\n\tcase START_STOP:\n\tcase GPCMD_VERIFY_10:\n\tcase VERIFY_16:\n\tcase REPORT_LUNS:\n\tcase SERVICE_ACTION_IN_16:\n\tcase RECEIVE_DIAGNOSTIC:\n\tcase MAINTENANCE_IN:  \n\tcase GPCMD_READ_BUFFER_CAPACITY:\n\t \n\tcase GPCMD_PLAY_CD:\n\tcase GPCMD_PLAY_AUDIO_10:\n\tcase GPCMD_PLAY_AUDIO_MSF:\n\tcase GPCMD_PLAY_AUDIO_TI:\n\tcase GPCMD_PAUSE_RESUME:\n\t \n\tcase GPCMD_READ_CD:\n\tcase GPCMD_READ_CD_MSF:\n\tcase GPCMD_READ_DISC_INFO:\n\tcase GPCMD_READ_DVD_STRUCTURE:\n\tcase GPCMD_READ_HEADER:\n\tcase GPCMD_READ_TRACK_RZONE_INFO:\n\tcase GPCMD_READ_SUBCHANNEL:\n\tcase GPCMD_READ_TOC_PMA_ATIP:\n\tcase GPCMD_REPORT_KEY:\n\tcase GPCMD_SCAN:\n\tcase GPCMD_GET_CONFIGURATION:\n\tcase GPCMD_READ_FORMAT_CAPACITIES:\n\tcase GPCMD_GET_EVENT_STATUS_NOTIFICATION:\n\tcase GPCMD_GET_PERFORMANCE:\n\tcase GPCMD_SEEK:\n\tcase GPCMD_STOP_PLAY_SCAN:\n\t \n\tcase ZBC_IN:\n\t\treturn true;\n\t \n\tcase WRITE_6:\n\tcase WRITE_10:\n\tcase WRITE_VERIFY:\n\tcase WRITE_12:\n\tcase WRITE_VERIFY_12:\n\tcase WRITE_16:\n\tcase WRITE_LONG:\n\tcase WRITE_LONG_2:\n\tcase WRITE_SAME:\n\tcase WRITE_SAME_16:\n\tcase WRITE_SAME_32:\n\tcase ERASE:\n\tcase GPCMD_MODE_SELECT_10:\n\tcase MODE_SELECT:\n\tcase LOG_SELECT:\n\tcase GPCMD_BLANK:\n\tcase GPCMD_CLOSE_TRACK:\n\tcase GPCMD_FLUSH_CACHE:\n\tcase GPCMD_FORMAT_UNIT:\n\tcase GPCMD_REPAIR_RZONE_TRACK:\n\tcase GPCMD_RESERVE_RZONE_TRACK:\n\tcase GPCMD_SEND_DVD_STRUCTURE:\n\tcase GPCMD_SEND_EVENT:\n\tcase GPCMD_SEND_OPC:\n\tcase GPCMD_SEND_CUE_SHEET:\n\tcase GPCMD_SET_SPEED:\n\tcase GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL:\n\tcase GPCMD_LOAD_UNLOAD:\n\tcase GPCMD_SET_STREAMING:\n\tcase GPCMD_SET_READ_AHEAD:\n\t \n\tcase ZBC_OUT:\n\t\treturn open_for_write;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL(scsi_cmd_allowed);\n\nstatic int scsi_fill_sghdr_rq(struct scsi_device *sdev, struct request *rq,\n\t\tstruct sg_io_hdr *hdr, bool open_for_write)\n{\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\n\tif (hdr->cmd_len < 6)\n\t\treturn -EMSGSIZE;\n\tif (copy_from_user(scmd->cmnd, hdr->cmdp, hdr->cmd_len))\n\t\treturn -EFAULT;\n\tif (!scsi_cmd_allowed(scmd->cmnd, open_for_write))\n\t\treturn -EPERM;\n\tscmd->cmd_len = hdr->cmd_len;\n\n\trq->timeout = msecs_to_jiffies(hdr->timeout);\n\tif (!rq->timeout)\n\t\trq->timeout = sdev->sg_timeout;\n\tif (!rq->timeout)\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\tif (rq->timeout < BLK_MIN_SG_TIMEOUT)\n\t\trq->timeout = BLK_MIN_SG_TIMEOUT;\n\n\treturn 0;\n}\n\nstatic int scsi_complete_sghdr_rq(struct request *rq, struct sg_io_hdr *hdr,\n\t\tstruct bio *bio)\n{\n\tstruct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);\n\tint r, ret = 0;\n\n\t \n\thdr->status = scmd->result & 0xff;\n\thdr->masked_status = sg_status_byte(scmd->result);\n\thdr->msg_status = COMMAND_COMPLETE;\n\thdr->host_status = host_byte(scmd->result);\n\thdr->driver_status = 0;\n\tif (scsi_status_is_check_condition(hdr->status))\n\t\thdr->driver_status = DRIVER_SENSE;\n\thdr->info = 0;\n\tif (hdr->masked_status || hdr->host_status || hdr->driver_status)\n\t\thdr->info |= SG_INFO_CHECK;\n\thdr->resid = scmd->resid_len;\n\thdr->sb_len_wr = 0;\n\n\tif (scmd->sense_len && hdr->sbp) {\n\t\tint len = min((unsigned int) hdr->mx_sb_len, scmd->sense_len);\n\n\t\tif (!copy_to_user(hdr->sbp, scmd->sense_buffer, len))\n\t\t\thdr->sb_len_wr = len;\n\t\telse\n\t\t\tret = -EFAULT;\n\t}\n\n\tr = blk_rq_unmap_user(bio);\n\tif (!ret)\n\t\tret = r;\n\n\treturn ret;\n}\n\nstatic int sg_io(struct scsi_device *sdev, struct sg_io_hdr *hdr,\n\t\tbool open_for_write)\n{\n\tunsigned long start_time;\n\tssize_t ret = 0;\n\tint writing = 0;\n\tint at_head = 0;\n\tstruct request *rq;\n\tstruct scsi_cmnd *scmd;\n\tstruct bio *bio;\n\n\tif (hdr->interface_id != 'S')\n\t\treturn -EINVAL;\n\n\tif (hdr->dxfer_len > (queue_max_hw_sectors(sdev->request_queue) << 9))\n\t\treturn -EIO;\n\n\tif (hdr->dxfer_len)\n\t\tswitch (hdr->dxfer_direction) {\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\tcase SG_DXFER_TO_DEV:\n\t\t\twriting = 1;\n\t\t\tbreak;\n\t\tcase SG_DXFER_TO_FROM_DEV:\n\t\tcase SG_DXFER_FROM_DEV:\n\t\t\tbreak;\n\t\t}\n\tif (hdr->flags & SG_FLAG_Q_AT_HEAD)\n\t\tat_head = 1;\n\n\trq = scsi_alloc_request(sdev->request_queue, writing ?\n\t\t\t     REQ_OP_DRV_OUT : REQ_OP_DRV_IN, 0);\n\tif (IS_ERR(rq))\n\t\treturn PTR_ERR(rq);\n\tscmd = blk_mq_rq_to_pdu(rq);\n\n\tif (hdr->cmd_len > sizeof(scmd->cmnd)) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_request;\n\t}\n\n\tret = scsi_fill_sghdr_rq(sdev, rq, hdr, open_for_write);\n\tif (ret < 0)\n\t\tgoto out_put_request;\n\n\tret = blk_rq_map_user_io(rq, NULL, hdr->dxferp, hdr->dxfer_len,\n\t\t\tGFP_KERNEL, hdr->iovec_count && hdr->dxfer_len,\n\t\t\thdr->iovec_count, 0, rq_data_dir(rq));\n\tif (ret)\n\t\tgoto out_put_request;\n\n\tbio = rq->bio;\n\tscmd->allowed = 0;\n\n\tstart_time = jiffies;\n\n\tblk_execute_rq(rq, at_head);\n\n\thdr->duration = jiffies_to_msecs(jiffies - start_time);\n\n\tret = scsi_complete_sghdr_rq(rq, hdr, bio);\n\nout_put_request:\n\tblk_mq_free_request(rq);\n\treturn ret;\n}\n\n \nstatic int sg_scsi_ioctl(struct request_queue *q, bool open_for_write,\n\t\tstruct scsi_ioctl_command __user *sic)\n{\n\tstruct request *rq;\n\tint err;\n\tunsigned int in_len, out_len, bytes, opcode, cmdlen;\n\tstruct scsi_cmnd *scmd;\n\tchar *buffer = NULL;\n\n\tif (!sic)\n\t\treturn -EINVAL;\n\n\t \n\tif (get_user(in_len, &sic->inlen))\n\t\treturn -EFAULT;\n\tif (get_user(out_len, &sic->outlen))\n\t\treturn -EFAULT;\n\tif (in_len > PAGE_SIZE || out_len > PAGE_SIZE)\n\t\treturn -EINVAL;\n\tif (get_user(opcode, &sic->data[0]))\n\t\treturn -EFAULT;\n\n\tbytes = max(in_len, out_len);\n\tif (bytes) {\n\t\tbuffer = kzalloc(bytes, GFP_NOIO | GFP_USER | __GFP_NOWARN);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t}\n\n\trq = scsi_alloc_request(q, in_len ? REQ_OP_DRV_OUT : REQ_OP_DRV_IN, 0);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto error_free_buffer;\n\t}\n\tscmd = blk_mq_rq_to_pdu(rq);\n\n\tcmdlen = COMMAND_SIZE(opcode);\n\n\t \n\terr = -EFAULT;\n\tscmd->cmd_len = cmdlen;\n\tif (copy_from_user(scmd->cmnd, sic->data, cmdlen))\n\t\tgoto error;\n\n\tif (in_len && copy_from_user(buffer, sic->data + cmdlen, in_len))\n\t\tgoto error;\n\n\terr = -EPERM;\n\tif (!scsi_cmd_allowed(scmd->cmnd, open_for_write))\n\t\tgoto error;\n\n\t \n\tscmd->allowed = 5;\n\n\tswitch (opcode) {\n\tcase SEND_DIAGNOSTIC:\n\tcase FORMAT_UNIT:\n\t\trq->timeout = FORMAT_UNIT_TIMEOUT;\n\t\tscmd->allowed = 1;\n\t\tbreak;\n\tcase START_STOP:\n\t\trq->timeout = START_STOP_TIMEOUT;\n\t\tbreak;\n\tcase MOVE_MEDIUM:\n\t\trq->timeout = MOVE_MEDIUM_TIMEOUT;\n\t\tbreak;\n\tcase READ_ELEMENT_STATUS:\n\t\trq->timeout = READ_ELEMENT_STATUS_TIMEOUT;\n\t\tbreak;\n\tcase READ_DEFECT_DATA:\n\t\trq->timeout = READ_DEFECT_DATA_TIMEOUT;\n\t\tscmd->allowed = 1;\n\t\tbreak;\n\tdefault:\n\t\trq->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\t\tbreak;\n\t}\n\n\tif (bytes) {\n\t\terr = blk_rq_map_kern(q, rq, buffer, bytes, GFP_NOIO);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tblk_execute_rq(rq, false);\n\n\terr = scmd->result & 0xff;\t \n\tif (err) {\n\t\tif (scmd->sense_len && scmd->sense_buffer) {\n\t\t\t \n\t\t\tif (copy_to_user(sic->data, scmd->sense_buffer,\n\t\t\t\t\t min(scmd->sense_len, 16U)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\t} else {\n\t\tif (copy_to_user(sic->data, buffer, out_len))\n\t\t\terr = -EFAULT;\n\t}\n\nerror:\n\tblk_mq_free_request(rq);\n\nerror_free_buffer:\n\tkfree(buffer);\n\n\treturn err;\n}\n\nint put_sg_io_hdr(const struct sg_io_hdr *hdr, void __user *argp)\n{\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_sg_io_hdr hdr32 =  {\n\t\t\t.interface_id\t = hdr->interface_id,\n\t\t\t.dxfer_direction = hdr->dxfer_direction,\n\t\t\t.cmd_len\t = hdr->cmd_len,\n\t\t\t.mx_sb_len\t = hdr->mx_sb_len,\n\t\t\t.iovec_count\t = hdr->iovec_count,\n\t\t\t.dxfer_len\t = hdr->dxfer_len,\n\t\t\t.dxferp\t\t = (uintptr_t)hdr->dxferp,\n\t\t\t.cmdp\t\t = (uintptr_t)hdr->cmdp,\n\t\t\t.sbp\t\t = (uintptr_t)hdr->sbp,\n\t\t\t.timeout\t = hdr->timeout,\n\t\t\t.flags\t\t = hdr->flags,\n\t\t\t.pack_id\t = hdr->pack_id,\n\t\t\t.usr_ptr\t = (uintptr_t)hdr->usr_ptr,\n\t\t\t.status\t\t = hdr->status,\n\t\t\t.masked_status\t = hdr->masked_status,\n\t\t\t.msg_status\t = hdr->msg_status,\n\t\t\t.sb_len_wr\t = hdr->sb_len_wr,\n\t\t\t.host_status\t = hdr->host_status,\n\t\t\t.driver_status\t = hdr->driver_status,\n\t\t\t.resid\t\t = hdr->resid,\n\t\t\t.duration\t = hdr->duration,\n\t\t\t.info\t\t = hdr->info,\n\t\t};\n\n\t\tif (copy_to_user(argp, &hdr32, sizeof(hdr32)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n#endif\n\n\tif (copy_to_user(argp, hdr, sizeof(*hdr)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(put_sg_io_hdr);\n\nint get_sg_io_hdr(struct sg_io_hdr *hdr, const void __user *argp)\n{\n#ifdef CONFIG_COMPAT\n\tstruct compat_sg_io_hdr hdr32;\n\n\tif (in_compat_syscall()) {\n\t\tif (copy_from_user(&hdr32, argp, sizeof(hdr32)))\n\t\t\treturn -EFAULT;\n\n\t\t*hdr = (struct sg_io_hdr) {\n\t\t\t.interface_id\t = hdr32.interface_id,\n\t\t\t.dxfer_direction = hdr32.dxfer_direction,\n\t\t\t.cmd_len\t = hdr32.cmd_len,\n\t\t\t.mx_sb_len\t = hdr32.mx_sb_len,\n\t\t\t.iovec_count\t = hdr32.iovec_count,\n\t\t\t.dxfer_len\t = hdr32.dxfer_len,\n\t\t\t.dxferp\t\t = compat_ptr(hdr32.dxferp),\n\t\t\t.cmdp\t\t = compat_ptr(hdr32.cmdp),\n\t\t\t.sbp\t\t = compat_ptr(hdr32.sbp),\n\t\t\t.timeout\t = hdr32.timeout,\n\t\t\t.flags\t\t = hdr32.flags,\n\t\t\t.pack_id\t = hdr32.pack_id,\n\t\t\t.usr_ptr\t = compat_ptr(hdr32.usr_ptr),\n\t\t\t.status\t\t = hdr32.status,\n\t\t\t.masked_status\t = hdr32.masked_status,\n\t\t\t.msg_status\t = hdr32.msg_status,\n\t\t\t.sb_len_wr\t = hdr32.sb_len_wr,\n\t\t\t.host_status\t = hdr32.host_status,\n\t\t\t.driver_status\t = hdr32.driver_status,\n\t\t\t.resid\t\t = hdr32.resid,\n\t\t\t.duration\t = hdr32.duration,\n\t\t\t.info\t\t = hdr32.info,\n\t\t};\n\n\t\treturn 0;\n\t}\n#endif\n\n\tif (copy_from_user(hdr, argp, sizeof(*hdr)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(get_sg_io_hdr);\n\n#ifdef CONFIG_COMPAT\nstruct compat_cdrom_generic_command {\n\tunsigned char\tcmd[CDROM_PACKET_SIZE];\n\tcompat_caddr_t\tbuffer;\n\tcompat_uint_t\tbuflen;\n\tcompat_int_t\tstat;\n\tcompat_caddr_t\tsense;\n\tunsigned char\tdata_direction;\n\tunsigned char\tpad[3];\n\tcompat_int_t\tquiet;\n\tcompat_int_t\ttimeout;\n\tcompat_caddr_t\tunused;\n};\n#endif\n\nstatic int scsi_get_cdrom_generic_arg(struct cdrom_generic_command *cgc,\n\t\t\t\t      const void __user *arg)\n{\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_cdrom_generic_command cgc32;\n\n\t\tif (copy_from_user(&cgc32, arg, sizeof(cgc32)))\n\t\t\treturn -EFAULT;\n\n\t\t*cgc = (struct cdrom_generic_command) {\n\t\t\t.buffer\t\t= compat_ptr(cgc32.buffer),\n\t\t\t.buflen\t\t= cgc32.buflen,\n\t\t\t.stat\t\t= cgc32.stat,\n\t\t\t.sense\t\t= compat_ptr(cgc32.sense),\n\t\t\t.data_direction\t= cgc32.data_direction,\n\t\t\t.quiet\t\t= cgc32.quiet,\n\t\t\t.timeout\t= cgc32.timeout,\n\t\t\t.unused\t\t= compat_ptr(cgc32.unused),\n\t\t};\n\t\tmemcpy(&cgc->cmd, &cgc32.cmd, CDROM_PACKET_SIZE);\n\t\treturn 0;\n\t}\n#endif\n\tif (copy_from_user(cgc, arg, sizeof(*cgc)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int scsi_put_cdrom_generic_arg(const struct cdrom_generic_command *cgc,\n\t\t\t\t      void __user *arg)\n{\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tstruct compat_cdrom_generic_command cgc32 = {\n\t\t\t.buffer\t\t= (uintptr_t)(cgc->buffer),\n\t\t\t.buflen\t\t= cgc->buflen,\n\t\t\t.stat\t\t= cgc->stat,\n\t\t\t.sense\t\t= (uintptr_t)(cgc->sense),\n\t\t\t.data_direction\t= cgc->data_direction,\n\t\t\t.quiet\t\t= cgc->quiet,\n\t\t\t.timeout\t= cgc->timeout,\n\t\t\t.unused\t\t= (uintptr_t)(cgc->unused),\n\t\t};\n\t\tmemcpy(&cgc32.cmd, &cgc->cmd, CDROM_PACKET_SIZE);\n\n\t\tif (copy_to_user(arg, &cgc32, sizeof(cgc32)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n#endif\n\tif (copy_to_user(arg, cgc, sizeof(*cgc)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int scsi_cdrom_send_packet(struct scsi_device *sdev, bool open_for_write,\n\t\tvoid __user *arg)\n{\n\tstruct cdrom_generic_command cgc;\n\tstruct sg_io_hdr hdr;\n\tint err;\n\n\terr = scsi_get_cdrom_generic_arg(&cgc, arg);\n\tif (err)\n\t\treturn err;\n\n\tcgc.timeout = clock_t_to_jiffies(cgc.timeout);\n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.interface_id = 'S';\n\thdr.cmd_len = sizeof(cgc.cmd);\n\thdr.dxfer_len = cgc.buflen;\n\tswitch (cgc.data_direction) {\n\tcase CGC_DATA_UNKNOWN:\n\t\thdr.dxfer_direction = SG_DXFER_UNKNOWN;\n\t\tbreak;\n\tcase CGC_DATA_WRITE:\n\t\thdr.dxfer_direction = SG_DXFER_TO_DEV;\n\t\tbreak;\n\tcase CGC_DATA_READ:\n\t\thdr.dxfer_direction = SG_DXFER_FROM_DEV;\n\t\tbreak;\n\tcase CGC_DATA_NONE:\n\t\thdr.dxfer_direction = SG_DXFER_NONE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\thdr.dxferp = cgc.buffer;\n\thdr.sbp = cgc.sense;\n\tif (hdr.sbp)\n\t\thdr.mx_sb_len = sizeof(struct request_sense);\n\thdr.timeout = jiffies_to_msecs(cgc.timeout);\n\thdr.cmdp = ((struct cdrom_generic_command __user *) arg)->cmd;\n\thdr.cmd_len = sizeof(cgc.cmd);\n\n\terr = sg_io(sdev, &hdr, open_for_write);\n\tif (err == -EFAULT)\n\t\treturn -EFAULT;\n\n\tif (hdr.status)\n\t\treturn -EIO;\n\n\tcgc.stat = err;\n\tcgc.buflen = hdr.resid;\n\tif (scsi_put_cdrom_generic_arg(&cgc, arg))\n\t\treturn -EFAULT;\n\n\treturn err;\n}\n\nstatic int scsi_ioctl_sg_io(struct scsi_device *sdev, bool open_for_write,\n\t\tvoid __user *argp)\n{\n\tstruct sg_io_hdr hdr;\n\tint error;\n\n\terror = get_sg_io_hdr(&hdr, argp);\n\tif (error)\n\t\treturn error;\n\terror = sg_io(sdev, &hdr, open_for_write);\n\tif (error == -EFAULT)\n\t\treturn error;\n\tif (put_sg_io_hdr(&hdr, argp))\n\t\treturn -EFAULT;\n\treturn error;\n}\n\n \nint scsi_ioctl(struct scsi_device *sdev, bool open_for_write, int cmd,\n\t\tvoid __user *arg)\n{\n\tstruct request_queue *q = sdev->request_queue;\n\tstruct scsi_sense_hdr sense_hdr;\n\n\t \n\tswitch (cmd) {\n\tcase SCSI_IOCTL_SEND_COMMAND:\n\tcase SCSI_IOCTL_TEST_UNIT_READY:\n\tcase SCSI_IOCTL_BENCHMARK_COMMAND:\n\tcase SCSI_IOCTL_SYNC:\n\tcase SCSI_IOCTL_START_UNIT:\n\tcase SCSI_IOCTL_STOP_UNIT:\n\t\tprintk(KERN_WARNING \"program %s is using a deprecated SCSI \"\n\t\t       \"ioctl, please convert it to SG_IO\\n\", current->comm);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (cmd) {\n\tcase SG_GET_VERSION_NUM:\n\t\treturn sg_get_version(arg);\n\tcase SG_SET_TIMEOUT:\n\t\treturn sg_set_timeout(sdev, arg);\n\tcase SG_GET_TIMEOUT:\n\t\treturn jiffies_to_clock_t(sdev->sg_timeout);\n\tcase SG_GET_RESERVED_SIZE:\n\t\treturn sg_get_reserved_size(sdev, arg);\n\tcase SG_SET_RESERVED_SIZE:\n\t\treturn sg_set_reserved_size(sdev, arg);\n\tcase SG_EMULATED_HOST:\n\t\treturn sg_emulated_host(q, arg);\n\tcase SG_IO:\n\t\treturn scsi_ioctl_sg_io(sdev, open_for_write, arg);\n\tcase SCSI_IOCTL_SEND_COMMAND:\n\t\treturn sg_scsi_ioctl(q, open_for_write, arg);\n\tcase CDROM_SEND_PACKET:\n\t\treturn scsi_cdrom_send_packet(sdev, open_for_write, arg);\n\tcase CDROMCLOSETRAY:\n\t\treturn scsi_send_start_stop(sdev, 3);\n\tcase CDROMEJECT:\n\t\treturn scsi_send_start_stop(sdev, 2);\n\tcase SCSI_IOCTL_GET_IDLUN:\n\t\treturn scsi_get_idlun(sdev, arg);\n\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\treturn put_user(sdev->host->host_no, (int __user *)arg);\n\tcase SCSI_IOCTL_PROBE_HOST:\n\t\treturn ioctl_probe(sdev->host, arg);\n\tcase SCSI_IOCTL_DOORLOCK:\n\t\treturn scsi_set_medium_removal(sdev, SCSI_REMOVAL_PREVENT);\n\tcase SCSI_IOCTL_DOORUNLOCK:\n\t\treturn scsi_set_medium_removal(sdev, SCSI_REMOVAL_ALLOW);\n\tcase SCSI_IOCTL_TEST_UNIT_READY:\n\t\treturn scsi_test_unit_ready(sdev, IOCTL_NORMAL_TIMEOUT,\n\t\t\t\t\t    NORMAL_RETRIES, &sense_hdr);\n\tcase SCSI_IOCTL_START_UNIT:\n\t\treturn scsi_send_start_stop(sdev, 1);\n\tcase SCSI_IOCTL_STOP_UNIT:\n\t\treturn scsi_send_start_stop(sdev, 0);\n        case SCSI_IOCTL_GET_PCI:\n                return scsi_ioctl_get_pci(sdev, arg);\n\tcase SG_SCSI_RESET:\n\t\treturn scsi_ioctl_reset(sdev, arg);\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall()) {\n\t\tif (!sdev->host->hostt->compat_ioctl)\n\t\t\treturn -EINVAL;\n\t\treturn sdev->host->hostt->compat_ioctl(sdev, cmd, arg);\n\t}\n#endif\n\tif (!sdev->host->hostt->ioctl)\n\t\treturn -EINVAL;\n\treturn sdev->host->hostt->ioctl(sdev, cmd, arg);\n}\nEXPORT_SYMBOL(scsi_ioctl);\n\n \nint scsi_ioctl_block_when_processing_errors(struct scsi_device *sdev, int cmd,\n\t\tbool ndelay)\n{\n\tif (cmd == SG_SCSI_RESET && ndelay) {\n\t\tif (scsi_host_in_recovery(sdev->host))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (!scsi_block_when_processing_errors(sdev))\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(scsi_ioctl_block_when_processing_errors);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}