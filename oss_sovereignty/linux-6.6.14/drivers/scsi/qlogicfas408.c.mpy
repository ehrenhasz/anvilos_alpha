{
  "module_name": "qlogicfas408.c",
  "hash_id": "54e1f4d0d0600b5fa17c05e73dca98becc04070d1c224639eb09bb61d881de23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qlogicfas408.c",
  "human_readable_source": " \n \n\n#include <linux/module.h>\n#include <linux/blkdev.h>\t\t \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/proc_fs.h>\n#include <linux/unistd.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/dma.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"qlogicfas408.h\"\n\n \nstatic int qlcfg5 = (XTALFREQ << 5);\t \nstatic int qlcfg6 = SYNCXFRPD;\nstatic int qlcfg7 = SYNCOFFST;\nstatic int qlcfg8 = (SLOWCABLE << 7) | (QL_ENABLE_PARITY << 4);\nstatic int qlcfg9 = ((XTALFREQ + 4) / 5);\nstatic int qlcfgc = (FASTCLK << 3) | (FASTSCSI << 4);\n\n \n\n \n \n \n\n \n\nstatic void ql_zap(struct qlogicfas408_priv *priv)\n{\n\tint x;\n\tint qbase = priv->qbase;\n\tint int_type = priv->int_type;\n\n\tx = inb(qbase + 0xd);\n\tREG0;\n\toutb(3, qbase + 3);\t \n\toutb(2, qbase + 3);\t \n\tif (x & 0x80)\n\t\tREG1;\n}\n\n \n\nstatic int ql_pdma(struct qlogicfas408_priv *priv, int phase, char *request,\n\t\t   int reqlen)\n{\n\tint j;\n\tint qbase = priv->qbase;\n\tj = 0;\n\tif (phase & 1) {\t \n#if QL_TURBO_PDMA\n\t\trtrc(4)\n\t\t \n\t\tif (reqlen >= 128 && (inb(qbase + 8) & 2)) {\t \n\t\t\tinsl(qbase + 4, request, 32);\n\t\t\treqlen -= 128;\n\t\t\trequest += 128;\n\t\t}\n\t\twhile (reqlen >= 84 && !(j & 0xc0))\t \n\t\t\tif ((j = inb(qbase + 8)) & 4)\n\t\t\t{\n\t\t\t\tinsl(qbase + 4, request, 21);\n\t\t\t\treqlen -= 84;\n\t\t\t\trequest += 84;\n\t\t\t}\n\t\tif (reqlen >= 44 && (inb(qbase + 8) & 8)) {\t \n\t\t\tinsl(qbase + 4, request, 11);\n\t\t\treqlen -= 44;\n\t\t\trequest += 44;\n\t\t}\n#endif\n\t\t \n\t\trtrc(7)\n\t\tj = 0;\n\t\twhile (reqlen && !((j & 0x10) && (j & 0xc0)))\n\t\t{\n\t\t\t \n\t\t\tj &= 0xc0;\n\t\t\twhile (reqlen && !((j = inb(qbase + 8)) & 0x10))\n\t\t\t{\n\t\t\t\t*request++ = inb(qbase + 4);\n\t\t\t\treqlen--;\n\t\t\t}\n\t\t\tif (j & 0x10)\n\t\t\t\tj = inb(qbase + 8);\n\n\t\t}\n\t} else {\t\t \n#if QL_TURBO_PDMA\n\t\trtrc(4)\n\t\tif (reqlen >= 128 && inb(qbase + 8) & 0x10) {\t \n\t\t\toutsl(qbase + 4, request, 32);\n\t\t\treqlen -= 128;\n\t\t\trequest += 128;\n\t\t}\n\t\twhile (reqlen >= 84 && !(j & 0xc0))\t \n\t\t\tif (!((j = inb(qbase + 8)) & 8)) {\n\t\t\t\toutsl(qbase + 4, request, 21);\n\t\t\t\treqlen -= 84;\n\t\t\t\trequest += 84;\n\t\t\t}\n\t\tif (reqlen >= 40 && !(inb(qbase + 8) & 4)) {\t \n\t\t\toutsl(qbase + 4, request, 10);\n\t\t\treqlen -= 40;\n\t\t\trequest += 40;\n\t\t}\n#endif\n\t\t \n\t\trtrc(7)\n\t\t    j = 0;\n\t\twhile (reqlen && !((j & 2) && (j & 0xc0))) {\n\t\t\t \n\t\t\twhile (reqlen && !((j = inb(qbase + 8)) & 2))\n\t\t\t{\n\t\t\t\toutb(*request++, qbase + 4);\n\t\t\t\treqlen--;\n\t\t\t}\n\t\t\tif (j & 2)\n\t\t\t\tj = inb(qbase + 8);\n\t\t}\n\t}\n\t \n\treturn inb(qbase + 8) & 0xc0;\n}\n\n \n\nstatic int ql_wai(struct qlogicfas408_priv *priv)\n{\n\tint k;\n\tint qbase = priv->qbase;\n\tunsigned long i;\n\n\tk = 0;\n\ti = jiffies + WATCHDOG;\n\twhile (time_before(jiffies, i) && !priv->qabort &&\n\t\t\t\t\t!((k = inb(qbase + 4)) & 0xe0)) {\n\t\tbarrier();\n\t\tcpu_relax();\n\t}\n\tif (time_after_eq(jiffies, i))\n\t\treturn (DID_TIME_OUT);\n\tif (priv->qabort)\n\t\treturn (priv->qabort == 1 ? DID_ABORT : DID_RESET);\n\tif (k & 0x60)\n\t\tql_zap(priv);\n\tif (k & 0x20)\n\t\treturn (DID_PARITY);\n\tif (k & 0x40)\n\t\treturn (DID_ERROR);\n\treturn 0;\n}\n\n \n\nstatic void ql_icmd(struct scsi_cmnd *cmd)\n{\n\tstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\n\tint\tqbase = priv->qbase;\n\tint\tint_type = priv->int_type;\n\tunsigned int i;\n\n\tpriv->qabort = 0;\n\n\tREG0;\n\t \n\n\tinb(qbase + 5);\t\t \n\tif (inb(qbase + 5))\t \n\t\toutb(2, qbase + 3);\t \n\telse if (inb(qbase + 7) & 0x1f)\n\t\toutb(1, qbase + 3);\t \n\twhile (inb(qbase + 5));\t \n\tREG1;\n\toutb(1, qbase + 8);\t \n\toutb(0, qbase + 0xb);\t \n\tinb(qbase + 8);\t\t \n\tREG0;\n\toutb(0x40, qbase + 0xb);\t \n\n\t \n\toutb(qlcfgc, qbase + 0xc);\n\t \n\toutb(0x40 | qlcfg8 | priv->qinitid, qbase + 8);\n\toutb(qlcfg7, qbase + 7);\n\toutb(qlcfg6, qbase + 6);\n\toutb(qlcfg5, qbase + 5);\t \n\toutb(qlcfg9 & 7, qbase + 9);\t \n \n\toutb(scmd_id(cmd), qbase + 4);\n\n\tfor (i = 0; i < cmd->cmd_len; i++)\n\t\toutb(cmd->cmnd[i], qbase + 2);\n\n\tpriv->qlcmd = cmd;\n\toutb(0x41, qbase + 3);\t \n}\n\n \n\nstatic void ql_pcmd(struct scsi_cmnd *cmd)\n{\n\tunsigned int i, j;\n\tunsigned long k;\n\tunsigned int status;\t \n\tunsigned int message;\t \n\tunsigned int phase;\t \n\tunsigned int reqlen;\t \n\tchar *buf;\n\tstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\n\tint qbase = priv->qbase;\n\tint int_type = priv->int_type;\n\n\trtrc(1)\n\tj = inb(qbase + 6);\n\ti = inb(qbase + 5);\n\tif (i == 0x20) {\n\t\tset_host_byte(cmd, DID_NO_CONNECT);\n\t\treturn;\n\t}\n\ti |= inb(qbase + 5);\t \n\tif (i != 0x18) {\n\t\tprintk(KERN_ERR \"Ql:Bad Interrupt status:%02x\\n\", i);\n\t\tql_zap(priv);\n\t\tset_host_byte(cmd, DID_BAD_INTR);\n\t\treturn;\n\t}\n\tj &= 7;\t\t\t \n\n\t \n\t \n\t \n\n\tif (j != 3 && j != 4) {\n\t\tprintk(KERN_ERR \"Ql:Bad sequence for command %d, int %02X, cmdleft = %d\\n\",\n\t\t     j, i, inb(qbase + 7) & 0x1f);\n\t\tql_zap(priv);\n\t\tset_host_byte(cmd, DID_ERROR);\n\t\treturn;\n\t}\n\n\tif (inb(qbase + 7) & 0x1f)\t \n\t\toutb(1, qbase + 3);\t \n\t \n\treqlen = scsi_bufflen(cmd);\n\t \n\tif (reqlen && !((phase = inb(qbase + 4)) & 6)) {\t \n\t\tstruct scatterlist *sg;\n\t\trtrc(2)\n\t\toutb(reqlen, qbase);\t \n\t\toutb(reqlen >> 8, qbase + 1);\t \n\t\toutb(reqlen >> 16, qbase + 0xe);\t \n\t\toutb(0x90, qbase + 3);\t \n\t\t \n\t\tREG1;\n\n\t\tscsi_for_each_sg(cmd, sg, scsi_sg_count(cmd), i) {\n\t\t\tif (priv->qabort) {\n\t\t\t\tREG0;\n\t\t\t\tset_host_byte(cmd,\n\t\t\t\t\t      priv->qabort == 1 ?\n\t\t\t\t\t      DID_ABORT : DID_RESET);\n\t\t\t}\n\t\t\tbuf = sg_virt(sg);\n\t\t\tif (ql_pdma(priv, phase, buf, sg->length))\n\t\t\t\tbreak;\n\t\t}\n\t\tREG0;\n\t\trtrc(2);\n\t\t \n\t\tif ((k = ql_wai(priv))) {\n\t\t\tset_host_byte(cmd, k);\n\t\t\treturn;\n\t\t}\n\t\tk = inb(qbase + 5);\t \n\t}\n\n\t \n\n\tk = jiffies + WATCHDOG;\n\n\twhile (time_before(jiffies, k) && !priv->qabort &&\n\t\t\t\t\t\t!(inb(qbase + 4) & 6))\n\t\tcpu_relax();\t \n\n\tif (time_after_eq(jiffies, k)) {\n\t\tql_zap(priv);\n\t\tset_host_byte(cmd, DID_TIME_OUT);\n\t\treturn;\n\t}\n\n\t \n\twhile (inb(qbase + 5))\n\t\tcpu_relax();\t \n\n\tif (priv->qabort) {\n\t\tset_host_byte(cmd,\n\t\t\t      priv->qabort == 1 ? DID_ABORT : DID_RESET);\n\t\treturn;\n\t}\n\n\toutb(0x11, qbase + 3);\t \n\tif ((k = ql_wai(priv))) {\n\t\tset_host_byte(cmd, k);\n\t\treturn;\n\t}\n\ti = inb(qbase + 5);\t \n\tj = inb(qbase + 7) & 0x1f;\t \n\tstatus = inb(qbase + 2);\n\tmessage = inb(qbase + 2);\n\n\t \n\tif (!((i == 8 && j == 2) || (i == 0x10 && j == 1))) {\n\t\tprintk(KERN_ERR \"Ql:Error during status phase, int=%02X, %d bytes recd\\n\", i, j);\n\t\tset_host_byte(cmd, DID_ERROR);\n\t}\n\toutb(0x12, qbase + 3);\t \n\trtrc(1);\n\tif ((k = ql_wai(priv))) {\n\t\tset_host_byte(cmd, k);\n\t\treturn;\n\t}\n\n\t \n\n\ti = inb(qbase + 5);\t \n\twhile (!priv->qabort && ((i & 0x20) != 0x20)) {\n\t\tbarrier();\n\t\tcpu_relax();\n\t\ti |= inb(qbase + 5);\n\t}\n\trtrc(0);\n\n\tif (priv->qabort) {\n\t\tset_host_byte(cmd,\n\t\t\t      priv->qabort == 1 ? DID_ABORT : DID_RESET);\n\t\treturn;\n\t}\n\n\tset_host_byte(cmd, DID_OK);\n\tif (message != COMMAND_COMPLETE)\n\t\tscsi_msg_to_host_byte(cmd, message);\n\tset_status_byte(cmd, status);\n\treturn;\n}\n\n \n\nstatic void ql_ihandl(void *dev_id)\n{\n\tstruct scsi_cmnd *icmd;\n\tstruct Scsi_Host *host = dev_id;\n\tstruct qlogicfas408_priv *priv = get_priv_by_host(host);\n\tint qbase = priv->qbase;\n\tREG0;\n\n\tif (!(inb(qbase + 4) & 0x80))\t \n\t\treturn;\n\n\tif (priv->qlcmd == NULL) {\t \n\t\tint i;\n\t\ti = 16;\n\t\twhile (i-- && inb(qbase + 5));\t \n\t\treturn;\n\t}\n\ticmd = priv->qlcmd;\n\tql_pcmd(icmd);\n\tpriv->qlcmd = NULL;\n\t \n\tscsi_done(icmd);\n}\n\nirqreturn_t qlogicfas408_ihandl(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tstruct Scsi_Host *host = dev_id;\n\n\tspin_lock_irqsave(host->host_lock, flags);\n\tql_ihandl(dev_id);\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int qlogicfas408_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\n\n\tset_host_byte(cmd, DID_OK);\n\tset_status_byte(cmd, SAM_STAT_GOOD);\n\tif (scmd_id(cmd) == priv->qinitid) {\n\t\tset_host_byte(cmd, DID_BAD_TARGET);\n\t\tdone(cmd);\n\t\treturn 0;\n\t}\n\n\t \n\twhile (priv->qlcmd != NULL) {\n\t\tbarrier();\n\t\tcpu_relax();\n\t}\n\tql_icmd(cmd);\n\treturn 0;\n}\n\nDEF_SCSI_QCMD(qlogicfas408_queuecommand)\n\n \n\nint qlogicfas408_biosparam(struct scsi_device *disk, struct block_device *dev,\n\t\t\t   sector_t capacity, int ip[])\n{\n \n\tip[0] = 0x40;\n\tip[1] = 0x20;\n\tip[2] = (unsigned long) capacity / (ip[0] * ip[1]);\n\tif (ip[2] > 1024) {\n\t\tip[0] = 0xff;\n\t\tip[1] = 0x3f;\n\t\tip[2] = (unsigned long) capacity / (ip[0] * ip[1]);\n#if 0\n\t\tif (ip[2] > 1023)\n\t\t\tip[2] = 1023;\n#endif\n\t}\n\treturn 0;\n}\n\n \n\nint qlogicfas408_abort(struct scsi_cmnd *cmd)\n{\n\tstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\n\tpriv->qabort = 1;\n\tql_zap(priv);\n\treturn SUCCESS;\n}\n\n \n\nint qlogicfas408_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);\n\tunsigned long flags;\n\n\tpriv->qabort = 2;\n\n\tspin_lock_irqsave(cmd->device->host->host_lock, flags);\n\tql_zap(priv);\n\tspin_unlock_irqrestore(cmd->device->host->host_lock, flags);\n\n\treturn SUCCESS;\n}\n\n \n\nconst char *qlogicfas408_info(struct Scsi_Host *host)\n{\n\tstruct qlogicfas408_priv *priv = get_priv_by_host(host);\n\treturn priv->qinfo;\n}\n\n \n\nint qlogicfas408_get_chip_type(int qbase, int int_type)\n{\n\tREG1;\n\treturn inb(qbase + 0xe) & 0xf8;\n}\n\n \n\nvoid qlogicfas408_setup(int qbase, int id, int int_type)\n{\n\toutb(1, qbase + 8);\t \n\tREG0;\n\toutb(0x40 | qlcfg8 | id, qbase + 8);\t \n\toutb(qlcfg5, qbase + 5);\t \n\toutb(qlcfg9, qbase + 9);\t \n\n#if QL_RESET_AT_START\n\toutb(3, qbase + 3);\n\n\tREG1;\n\t \n\twhile (inb(qbase + 0xf) & 4)\n\t\tcpu_relax();\n\n\tREG0;\n#endif\n}\n\n \n\nint qlogicfas408_detect(int qbase, int int_type)\n{\n\tREG1;\n\treturn (((inb(qbase + 0xe) ^ inb(qbase + 0xe)) == 7) &&\n\t\t((inb(qbase + 0xe) ^ inb(qbase + 0xe)) == 7));\n}\n\n \n\nvoid qlogicfas408_disable_ints(struct qlogicfas408_priv *priv)\n{\n\tint qbase = priv->qbase;\n\tint int_type = priv->int_type;\n\n\tREG1;\n\toutb(0, qbase + 0xb);\t \n}\n\n \n\nstatic int __init qlogicfas408_init(void)\n{\n\treturn 0;\n}\n\nstatic void __exit qlogicfas408_exit(void)\n{\n\n}\n\nMODULE_AUTHOR(\"Tom Zerucha, Michael Griffith\");\nMODULE_DESCRIPTION(\"Driver for the Qlogic FAS SCSI controllers\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(qlogicfas408_init);\nmodule_exit(qlogicfas408_exit);\n\nEXPORT_SYMBOL(qlogicfas408_info);\nEXPORT_SYMBOL(qlogicfas408_queuecommand);\nEXPORT_SYMBOL(qlogicfas408_abort);\nEXPORT_SYMBOL(qlogicfas408_host_reset);\nEXPORT_SYMBOL(qlogicfas408_biosparam);\nEXPORT_SYMBOL(qlogicfas408_ihandl);\nEXPORT_SYMBOL(qlogicfas408_get_chip_type);\nEXPORT_SYMBOL(qlogicfas408_setup);\nEXPORT_SYMBOL(qlogicfas408_detect);\nEXPORT_SYMBOL(qlogicfas408_disable_ints);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}