{
  "module_name": "NCR5380.c",
  "hash_id": "5fe8476e361524cb25ec0d098ca42cefef9453029949a5e928c3580efb1ec769",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/NCR5380.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n \n\n \n\n#ifndef NCR5380_io_delay\n#define NCR5380_io_delay(x)\n#endif\n\n#ifndef NCR5380_acquire_dma_irq\n#define NCR5380_acquire_dma_irq(x)\t(1)\n#endif\n\n#ifndef NCR5380_release_dma_irq\n#define NCR5380_release_dma_irq(x)\n#endif\n\nstatic unsigned int disconnect_mask = ~0;\nmodule_param(disconnect_mask, int, 0444);\n\nstatic int do_abort(struct Scsi_Host *, unsigned int);\nstatic void do_reset(struct Scsi_Host *);\nstatic void bus_reset_cleanup(struct Scsi_Host *);\n\n \n\nstatic inline void initialize_SCp(struct scsi_cmnd *cmd)\n{\n\tstruct NCR5380_cmd *ncmd = NCR5380_to_ncmd(cmd);\n\n\tif (scsi_bufflen(cmd)) {\n\t\tncmd->buffer = scsi_sglist(cmd);\n\t\tncmd->ptr = sg_virt(ncmd->buffer);\n\t\tncmd->this_residual = ncmd->buffer->length;\n\t} else {\n\t\tncmd->buffer = NULL;\n\t\tncmd->ptr = NULL;\n\t\tncmd->this_residual = 0;\n\t}\n\n\tncmd->status = 0;\n\tncmd->message = 0;\n}\n\nstatic inline void advance_sg_buffer(struct NCR5380_cmd *ncmd)\n{\n\tstruct scatterlist *s = ncmd->buffer;\n\n\tif (!ncmd->this_residual && s && !sg_is_last(s)) {\n\t\tncmd->buffer = sg_next(s);\n\t\tncmd->ptr = sg_virt(ncmd->buffer);\n\t\tncmd->this_residual = ncmd->buffer->length;\n\t}\n}\n\nstatic inline void set_resid_from_SCp(struct scsi_cmnd *cmd)\n{\n\tstruct NCR5380_cmd *ncmd = NCR5380_to_ncmd(cmd);\n\tint resid = ncmd->this_residual;\n\tstruct scatterlist *s = ncmd->buffer;\n\n\tif (s)\n\t\twhile (!sg_is_last(s)) {\n\t\t\ts = sg_next(s);\n\t\t\tresid += s->length;\n\t\t}\n\tscsi_set_resid(cmd, resid);\n}\n\n \n\nstatic int NCR5380_poll_politely2(struct NCR5380_hostdata *hostdata,\n                                  unsigned int reg1, u8 bit1, u8 val1,\n                                  unsigned int reg2, u8 bit2, u8 val2,\n                                  unsigned long wait)\n{\n\tunsigned long n = hostdata->poll_loops;\n\tunsigned long deadline = jiffies + wait;\n\n\tdo {\n\t\tif ((NCR5380_read(reg1) & bit1) == val1)\n\t\t\treturn 0;\n\t\tif ((NCR5380_read(reg2) & bit2) == val2)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t} while (n--);\n\n\tif (!wait)\n\t\treturn -ETIMEDOUT;\n\n\t \n\twhile (time_is_after_jiffies(deadline)) {\n\t\tschedule_timeout_uninterruptible(1);\n\t\tif ((NCR5380_read(reg1) & bit1) == val1)\n\t\t\treturn 0;\n\t\tif ((NCR5380_read(reg2) & bit2) == val2)\n\t\t\treturn 0;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n#if NDEBUG\nstatic struct {\n\tunsigned char mask;\n\tconst char *name;\n} signals[] = {\n\t{SR_DBP, \"PARITY\"},\n\t{SR_RST, \"RST\"},\n\t{SR_BSY, \"BSY\"},\n\t{SR_REQ, \"REQ\"},\n\t{SR_MSG, \"MSG\"},\n\t{SR_CD, \"CD\"},\n\t{SR_IO, \"IO\"},\n\t{SR_SEL, \"SEL\"},\n\t{0, NULL}\n},\nbasrs[] = {\n\t{BASR_END_DMA_TRANSFER, \"END OF DMA\"},\n\t{BASR_DRQ, \"DRQ\"},\n\t{BASR_PARITY_ERROR, \"PARITY ERROR\"},\n\t{BASR_IRQ, \"IRQ\"},\n\t{BASR_PHASE_MATCH, \"PHASE MATCH\"},\n\t{BASR_BUSY_ERROR, \"BUSY ERROR\"},\n\t{BASR_ATN, \"ATN\"},\n\t{BASR_ACK, \"ACK\"},\n\t{0, NULL}\n},\nicrs[] = {\n\t{ICR_ASSERT_RST, \"ASSERT RST\"},\n\t{ICR_ARBITRATION_PROGRESS, \"ARB. IN PROGRESS\"},\n\t{ICR_ARBITRATION_LOST, \"LOST ARB.\"},\n\t{ICR_ASSERT_ACK, \"ASSERT ACK\"},\n\t{ICR_ASSERT_BSY, \"ASSERT BSY\"},\n\t{ICR_ASSERT_SEL, \"ASSERT SEL\"},\n\t{ICR_ASSERT_ATN, \"ASSERT ATN\"},\n\t{ICR_ASSERT_DATA, \"ASSERT DATA\"},\n\t{0, NULL}\n},\nmrs[] = {\n\t{MR_BLOCK_DMA_MODE, \"BLOCK DMA MODE\"},\n\t{MR_TARGET, \"TARGET\"},\n\t{MR_ENABLE_PAR_CHECK, \"PARITY CHECK\"},\n\t{MR_ENABLE_PAR_INTR, \"PARITY INTR\"},\n\t{MR_ENABLE_EOP_INTR, \"EOP INTR\"},\n\t{MR_MONITOR_BSY, \"MONITOR BSY\"},\n\t{MR_DMA_MODE, \"DMA MODE\"},\n\t{MR_ARBITRATE, \"ARBITRATE\"},\n\t{0, NULL}\n};\n\n \n\nstatic void NCR5380_print(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned char status, basr, mr, icr, i;\n\n\tstatus = NCR5380_read(STATUS_REG);\n\tmr = NCR5380_read(MODE_REG);\n\ticr = NCR5380_read(INITIATOR_COMMAND_REG);\n\tbasr = NCR5380_read(BUS_AND_STATUS_REG);\n\n\tprintk(KERN_DEBUG \"SR =   0x%02x : \", status);\n\tfor (i = 0; signals[i].mask; ++i)\n\t\tif (status & signals[i].mask)\n\t\t\tprintk(KERN_CONT \"%s, \", signals[i].name);\n\tprintk(KERN_CONT \"\\nBASR = 0x%02x : \", basr);\n\tfor (i = 0; basrs[i].mask; ++i)\n\t\tif (basr & basrs[i].mask)\n\t\t\tprintk(KERN_CONT \"%s, \", basrs[i].name);\n\tprintk(KERN_CONT \"\\nICR =  0x%02x : \", icr);\n\tfor (i = 0; icrs[i].mask; ++i)\n\t\tif (icr & icrs[i].mask)\n\t\t\tprintk(KERN_CONT \"%s, \", icrs[i].name);\n\tprintk(KERN_CONT \"\\nMR =   0x%02x : \", mr);\n\tfor (i = 0; mrs[i].mask; ++i)\n\t\tif (mr & mrs[i].mask)\n\t\t\tprintk(KERN_CONT \"%s, \", mrs[i].name);\n\tprintk(KERN_CONT \"\\n\");\n}\n\nstatic struct {\n\tunsigned char value;\n\tconst char *name;\n} phases[] = {\n\t{PHASE_DATAOUT, \"DATAOUT\"},\n\t{PHASE_DATAIN, \"DATAIN\"},\n\t{PHASE_CMDOUT, \"CMDOUT\"},\n\t{PHASE_STATIN, \"STATIN\"},\n\t{PHASE_MSGOUT, \"MSGOUT\"},\n\t{PHASE_MSGIN, \"MSGIN\"},\n\t{PHASE_UNKNOWN, \"UNKNOWN\"}\n};\n\n \n\nstatic void NCR5380_print_phase(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned char status;\n\tint i;\n\n\tstatus = NCR5380_read(STATUS_REG);\n\tif (!(status & SR_REQ))\n\t\tshost_printk(KERN_DEBUG, instance, \"REQ not asserted, phase unknown.\\n\");\n\telse {\n\t\tfor (i = 0; (phases[i].value != PHASE_UNKNOWN) &&\n\t\t     (phases[i].value != (status & PHASE_MASK)); ++i)\n\t\t\t;\n\t\tshost_printk(KERN_DEBUG, instance, \"phase %s\\n\", phases[i].name);\n\t}\n}\n#endif\n\n \n\nstatic const char *NCR5380_info(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\n\treturn hostdata->info;\n}\n\n \n\nstatic int NCR5380_init(struct Scsi_Host *instance, int flags)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tint i;\n\tunsigned long deadline;\n\tunsigned long accesses_per_ms;\n\n\tinstance->max_lun = 7;\n\n\thostdata->host = instance;\n\thostdata->id_mask = 1 << instance->this_id;\n\thostdata->id_higher_mask = 0;\n\tfor (i = hostdata->id_mask; i <= 0x80; i <<= 1)\n\t\tif (i > hostdata->id_mask)\n\t\t\thostdata->id_higher_mask |= i;\n\tfor (i = 0; i < 8; ++i)\n\t\thostdata->busy[i] = 0;\n\thostdata->dma_len = 0;\n\n\tspin_lock_init(&hostdata->lock);\n\thostdata->connected = NULL;\n\thostdata->sensing = NULL;\n\tINIT_LIST_HEAD(&hostdata->autosense);\n\tINIT_LIST_HEAD(&hostdata->unissued);\n\tINIT_LIST_HEAD(&hostdata->disconnected);\n\n\thostdata->flags = flags;\n\n\tINIT_WORK(&hostdata->main_task, NCR5380_main);\n\thostdata->work_q = alloc_workqueue(\"ncr5380_%d\",\n\t                        WQ_UNBOUND | WQ_MEM_RECLAIM,\n\t\t\t\t0, instance->host_no);\n\tif (!hostdata->work_q)\n\t\treturn -ENOMEM;\n\n\tsnprintf(hostdata->info, sizeof(hostdata->info),\n\t\t\"%s, irq %d, io_port 0x%lx, base 0x%lx, can_queue %d, cmd_per_lun %d, sg_tablesize %d, this_id %d, flags { %s%s%s}\",\n\t\tinstance->hostt->name, instance->irq, hostdata->io_port,\n\t\thostdata->base, instance->can_queue, instance->cmd_per_lun,\n\t\tinstance->sg_tablesize, instance->this_id,\n\t\thostdata->flags & FLAG_DMA_FIXUP     ? \"DMA_FIXUP \"     : \"\",\n\t\thostdata->flags & FLAG_NO_PSEUDO_DMA ? \"NO_PSEUDO_DMA \" : \"\",\n\t\thostdata->flags & FLAG_TOSHIBA_DELAY ? \"TOSHIBA_DELAY \" : \"\");\n\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\tNCR5380_write(MODE_REG, MR_BASE);\n\tNCR5380_write(TARGET_COMMAND_REG, 0);\n\tNCR5380_write(SELECT_ENABLE_REG, 0);\n\n\t \n\ti = 0;\n\tdeadline = jiffies + 1;\n\tdo {\n\t\tcpu_relax();\n\t} while (time_is_after_jiffies(deadline));\n\tdeadline += msecs_to_jiffies(256);\n\tdo {\n\t\tNCR5380_read(STATUS_REG);\n\t\t++i;\n\t\tcpu_relax();\n\t} while (time_is_after_jiffies(deadline));\n\taccesses_per_ms = i / 256;\n\thostdata->poll_loops = NCR5380_REG_POLL_TIME * accesses_per_ms / 2;\n\n\treturn 0;\n}\n\n \n\nstatic int NCR5380_maybe_reset_bus(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tint pass;\n\n\tfor (pass = 1; (NCR5380_read(STATUS_REG) & SR_BSY) && pass <= 6; ++pass) {\n\t\tswitch (pass) {\n\t\tcase 1:\n\t\tcase 3:\n\t\tcase 5:\n\t\t\tshost_printk(KERN_ERR, instance, \"SCSI bus busy, waiting up to five seconds\\n\");\n\t\t\tNCR5380_poll_politely(hostdata,\n\t\t\t                      STATUS_REG, SR_BSY, 0, 5 * HZ);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tshost_printk(KERN_ERR, instance, \"bus busy, attempting abort\\n\");\n\t\t\tdo_abort(instance, 1);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tshost_printk(KERN_ERR, instance, \"bus busy, attempting reset\\n\");\n\t\t\tdo_reset(instance);\n\t\t\t \n\t\t\tif (hostdata->flags & FLAG_TOSHIBA_DELAY)\n\t\t\t\tmsleep(2500);\n\t\t\telse\n\t\t\t\tmsleep(500);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tshost_printk(KERN_ERR, instance, \"bus locked solid\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic void NCR5380_exit(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\n\tcancel_work_sync(&hostdata->main_task);\n\tdestroy_workqueue(hostdata->work_q);\n}\n\n \n\nstatic void complete_cmd(struct Scsi_Host *instance,\n                         struct scsi_cmnd *cmd)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\n\tdsprintk(NDEBUG_QUEUES, instance, \"complete_cmd: cmd %p\\n\", cmd);\n\n\tif (hostdata->sensing == cmd) {\n\t\t \n\t\tif (get_status_byte(cmd) != SAM_STAT_GOOD) {\n\t\t\tscsi_eh_restore_cmnd(cmd, &hostdata->ses);\n\t\t} else {\n\t\t\tscsi_eh_restore_cmnd(cmd, &hostdata->ses);\n\t\t\tset_status_byte(cmd, SAM_STAT_CHECK_CONDITION);\n\t\t}\n\t\thostdata->sensing = NULL;\n\t}\n\n\tscsi_done(cmd);\n}\n\n \n\nstatic int NCR5380_queue_command(struct Scsi_Host *instance,\n                                 struct scsi_cmnd *cmd)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tstruct NCR5380_cmd *ncmd = NCR5380_to_ncmd(cmd);\n\tunsigned long flags;\n\n#if (NDEBUG & NDEBUG_NO_WRITE)\n\tswitch (cmd->cmnd[0]) {\n\tcase WRITE_6:\n\tcase WRITE_10:\n\t\tshost_printk(KERN_DEBUG, instance, \"WRITE attempted with NDEBUG_NO_WRITE set\\n\");\n\t\tcmd->result = (DID_ERROR << 16);\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n#endif  \n\n\tcmd->result = 0;\n\n\tspin_lock_irqsave(&hostdata->lock, flags);\n\n\tif (!NCR5380_acquire_dma_irq(instance)) {\n\t\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\t \n\n\tif (cmd->cmnd[0] == REQUEST_SENSE)\n\t\tlist_add(&ncmd->list, &hostdata->unissued);\n\telse\n\t\tlist_add_tail(&ncmd->list, &hostdata->unissued);\n\n\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\n\tdsprintk(NDEBUG_QUEUES, instance, \"command %p added to %s of queue\\n\",\n\t         cmd, (cmd->cmnd[0] == REQUEST_SENSE) ? \"head\" : \"tail\");\n\n\t \n\tqueue_work(hostdata->work_q, &hostdata->main_task);\n\treturn 0;\n}\n\nstatic inline void maybe_release_dma_irq(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\n\t \n\tif (list_empty(&hostdata->disconnected) &&\n\t    list_empty(&hostdata->unissued) &&\n\t    list_empty(&hostdata->autosense) &&\n\t    !hostdata->connected &&\n\t    !hostdata->selecting) {\n\t\tNCR5380_release_dma_irq(instance);\n\t}\n}\n\n \n\nstatic struct scsi_cmnd *dequeue_next_cmd(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tstruct NCR5380_cmd *ncmd;\n\tstruct scsi_cmnd *cmd;\n\n\tif (hostdata->sensing || list_empty(&hostdata->autosense)) {\n\t\tlist_for_each_entry(ncmd, &hostdata->unissued, list) {\n\t\t\tcmd = NCR5380_to_scmd(ncmd);\n\t\t\tdsprintk(NDEBUG_QUEUES, instance, \"dequeue: cmd=%p target=%d busy=0x%02x lun=%llu\\n\",\n\t\t\t         cmd, scmd_id(cmd), hostdata->busy[scmd_id(cmd)], cmd->device->lun);\n\n\t\t\tif (!(hostdata->busy[scmd_id(cmd)] & (1 << cmd->device->lun))) {\n\t\t\t\tlist_del(&ncmd->list);\n\t\t\t\tdsprintk(NDEBUG_QUEUES, instance,\n\t\t\t\t         \"dequeue: removed %p from issue queue\\n\", cmd);\n\t\t\t\treturn cmd;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tncmd = list_first_entry(&hostdata->autosense,\n\t\t                        struct NCR5380_cmd, list);\n\t\tlist_del(&ncmd->list);\n\t\tcmd = NCR5380_to_scmd(ncmd);\n\t\tdsprintk(NDEBUG_QUEUES, instance,\n\t\t         \"dequeue: removed %p from autosense queue\\n\", cmd);\n\t\tscsi_eh_prep_cmnd(cmd, &hostdata->ses, NULL, 0, ~0);\n\t\thostdata->sensing = cmd;\n\t\treturn cmd;\n\t}\n\treturn NULL;\n}\n\nstatic void requeue_cmd(struct Scsi_Host *instance, struct scsi_cmnd *cmd)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tstruct NCR5380_cmd *ncmd = NCR5380_to_ncmd(cmd);\n\n\tif (hostdata->sensing == cmd) {\n\t\tscsi_eh_restore_cmnd(cmd, &hostdata->ses);\n\t\tlist_add(&ncmd->list, &hostdata->autosense);\n\t\thostdata->sensing = NULL;\n\t} else\n\t\tlist_add(&ncmd->list, &hostdata->unissued);\n}\n\n \n\nstatic void NCR5380_main(struct work_struct *work)\n{\n\tstruct NCR5380_hostdata *hostdata =\n\t\tcontainer_of(work, struct NCR5380_hostdata, main_task);\n\tstruct Scsi_Host *instance = hostdata->host;\n\tint done;\n\n\tdo {\n\t\tdone = 1;\n\n\t\tspin_lock_irq(&hostdata->lock);\n\t\twhile (!hostdata->connected && !hostdata->selecting) {\n\t\t\tstruct scsi_cmnd *cmd = dequeue_next_cmd(instance);\n\n\t\t\tif (!cmd)\n\t\t\t\tbreak;\n\n\t\t\tdsprintk(NDEBUG_MAIN, instance, \"main: dequeued %p\\n\", cmd);\n\n\t\t\t \n\t\t\t \n\n\t\t\tif (!NCR5380_select(instance, cmd)) {\n\t\t\t\tdsprintk(NDEBUG_MAIN, instance, \"main: select complete\\n\");\n\t\t\t} else {\n\t\t\t\tdsprintk(NDEBUG_MAIN | NDEBUG_QUEUES, instance,\n\t\t\t\t         \"main: select failed, returning %p to queue\\n\", cmd);\n\t\t\t\trequeue_cmd(instance, cmd);\n\t\t\t}\n\t\t}\n\t\tif (hostdata->connected && !hostdata->dma_len) {\n\t\t\tdsprintk(NDEBUG_MAIN, instance, \"main: performing information transfer\\n\");\n\t\t\tNCR5380_information_transfer(instance);\n\t\t\tdone = 0;\n\t\t}\n\t\tif (!hostdata->connected) {\n\t\t\tNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\n\t\t\tmaybe_release_dma_irq(instance);\n\t\t}\n\t\tspin_unlock_irq(&hostdata->lock);\n\t\tif (!done)\n\t\t\tcond_resched();\n\t} while (!done);\n}\n\n \n\nstatic void NCR5380_dma_complete(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tstruct NCR5380_cmd *ncmd = NCR5380_to_ncmd(hostdata->connected);\n\tint transferred;\n\tunsigned char **data;\n\tint *count;\n\tint saved_data = 0, overrun = 0;\n\tunsigned char p;\n\n\tif (hostdata->read_overruns) {\n\t\tp = ncmd->phase;\n\t\tif (p & SR_IO) {\n\t\t\tudelay(10);\n\t\t\tif ((NCR5380_read(BUS_AND_STATUS_REG) &\n\t\t\t     (BASR_PHASE_MATCH | BASR_ACK)) ==\n\t\t\t    (BASR_PHASE_MATCH | BASR_ACK)) {\n\t\t\t\tsaved_data = NCR5380_read(INPUT_DATA_REG);\n\t\t\t\toverrun = 1;\n\t\t\t\tdsprintk(NDEBUG_DMA, instance, \"read overrun handled\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef CONFIG_SUN3\n\tif (sun3scsi_dma_finish(hostdata->connected->sc_data_direction)) {\n\t\tpr_err(\"scsi%d: overrun in UDC counter -- not prepared to deal with this!\\n\",\n\t\t       instance->host_no);\n\t\tBUG();\n\t}\n\n\tif ((NCR5380_read(BUS_AND_STATUS_REG) & (BASR_PHASE_MATCH | BASR_ACK)) ==\n\t    (BASR_PHASE_MATCH | BASR_ACK)) {\n\t\tpr_err(\"scsi%d: BASR %02x\\n\", instance->host_no,\n\t\t       NCR5380_read(BUS_AND_STATUS_REG));\n\t\tpr_err(\"scsi%d: bus stuck in data phase -- probably a single byte overrun!\\n\",\n\t\t       instance->host_no);\n\t\tBUG();\n\t}\n#endif\n\n\tNCR5380_write(MODE_REG, MR_BASE);\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\tNCR5380_read(RESET_PARITY_INTERRUPT_REG);\n\n\ttransferred = hostdata->dma_len - NCR5380_dma_residual(hostdata);\n\thostdata->dma_len = 0;\n\n\tdata = (unsigned char **)&ncmd->ptr;\n\tcount = &ncmd->this_residual;\n\t*data += transferred;\n\t*count -= transferred;\n\n\tif (hostdata->read_overruns) {\n\t\tint cnt, toPIO;\n\n\t\tif ((NCR5380_read(STATUS_REG) & PHASE_MASK) == p && (p & SR_IO)) {\n\t\t\tcnt = toPIO = hostdata->read_overruns;\n\t\t\tif (overrun) {\n\t\t\t\tdsprintk(NDEBUG_DMA, instance,\n\t\t\t\t         \"Got an input overrun, using saved byte\\n\");\n\t\t\t\t*(*data)++ = saved_data;\n\t\t\t\t(*count)--;\n\t\t\t\tcnt--;\n\t\t\t\ttoPIO--;\n\t\t\t}\n\t\t\tif (toPIO > 0) {\n\t\t\t\tdsprintk(NDEBUG_DMA, instance,\n\t\t\t\t         \"Doing %d byte PIO to 0x%p\\n\", cnt, *data);\n\t\t\t\tNCR5380_transfer_pio(instance, &p, &cnt, data, 0);\n\t\t\t\t*count -= toPIO - cnt;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\nstatic irqreturn_t __maybe_unused NCR5380_intr(int irq, void *dev_id)\n{\n\tstruct Scsi_Host *instance = dev_id;\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tint handled = 0;\n\tunsigned char basr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hostdata->lock, flags);\n\n\tbasr = NCR5380_read(BUS_AND_STATUS_REG);\n\tif (basr & BASR_IRQ) {\n\t\tunsigned char mr = NCR5380_read(MODE_REG);\n\t\tunsigned char sr = NCR5380_read(STATUS_REG);\n\n\t\tdsprintk(NDEBUG_INTR, instance, \"IRQ %d, BASR 0x%02x, SR 0x%02x, MR 0x%02x\\n\",\n\t\t         irq, basr, sr, mr);\n\n\t\tif ((mr & MR_DMA_MODE) || (mr & MR_MONITOR_BSY)) {\n\t\t\t \n\n\t\t\tdsprintk(NDEBUG_INTR, instance, \"interrupt in DMA mode\\n\");\n\n\t\t\tif (hostdata->connected) {\n\t\t\t\tNCR5380_dma_complete(instance);\n\t\t\t\tqueue_work(hostdata->work_q, &hostdata->main_task);\n\t\t\t} else {\n\t\t\t\tNCR5380_write(MODE_REG, MR_BASE);\n\t\t\t\tNCR5380_read(RESET_PARITY_INTERRUPT_REG);\n\t\t\t}\n\t\t} else if ((NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_mask) &&\n\t\t    (sr & (SR_SEL | SR_IO | SR_BSY | SR_RST)) == (SR_SEL | SR_IO)) {\n\t\t\t \n\t\t\tNCR5380_write(SELECT_ENABLE_REG, 0);\n\t\t\tNCR5380_read(RESET_PARITY_INTERRUPT_REG);\n\n\t\t\tdsprintk(NDEBUG_INTR, instance, \"interrupt with SEL and IO\\n\");\n\n\t\t\tif (!hostdata->connected) {\n\t\t\t\tNCR5380_reselect(instance);\n\t\t\t\tqueue_work(hostdata->work_q, &hostdata->main_task);\n\t\t\t}\n\t\t\tif (!hostdata->connected)\n\t\t\t\tNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\n\t\t} else {\n\t\t\t \n\t\t\tNCR5380_read(RESET_PARITY_INTERRUPT_REG);\n\n\t\t\tif (sr & SR_RST) {\n\t\t\t\t \n\t\t\t\tshost_printk(KERN_WARNING, instance,\n\t\t\t\t\t     \"bus reset interrupt\\n\");\n\t\t\t\tbus_reset_cleanup(instance);\n\t\t\t} else {\n\t\t\t\tdsprintk(NDEBUG_INTR, instance, \"unknown interrupt\\n\");\n\t\t\t}\n#ifdef SUN3_SCSI_VME\n\t\t\tdregs->csr |= CSR_DMA_ENABLE;\n#endif\n\t\t}\n\t\thandled = 1;\n\t} else {\n\t\tdsprintk(NDEBUG_INTR, instance, \"interrupt without IRQ bit\\n\");\n#ifdef SUN3_SCSI_VME\n\t\tdregs->csr |= CSR_DMA_ENABLE;\n#endif\n\t}\n\n\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\nstatic bool NCR5380_select(struct Scsi_Host *instance, struct scsi_cmnd *cmd)\n\t__releases(&hostdata->lock) __acquires(&hostdata->lock)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned char tmp[3], phase;\n\tunsigned char *data;\n\tint len;\n\tint err;\n\tbool ret = true;\n\tbool can_disconnect = instance->irq != NO_IRQ &&\n\t\t\t      cmd->cmnd[0] != REQUEST_SENSE &&\n\t\t\t      (disconnect_mask & BIT(scmd_id(cmd)));\n\n\tNCR5380_dprint(NDEBUG_ARBITRATION, instance);\n\tdsprintk(NDEBUG_ARBITRATION, instance, \"starting arbitration, id = %d\\n\",\n\t         instance->this_id);\n\n\t \n\thostdata->selecting = cmd;\n\n\t \n\n\tNCR5380_write(TARGET_COMMAND_REG, 0);\n\n\t \n\n\tNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);\n\tNCR5380_write(MODE_REG, MR_ARBITRATE);\n\n\t \n\n\tspin_unlock_irq(&hostdata->lock);\n\terr = NCR5380_poll_politely2(hostdata, MODE_REG, MR_ARBITRATE, 0,\n\t                INITIATOR_COMMAND_REG, ICR_ARBITRATION_PROGRESS,\n\t                                       ICR_ARBITRATION_PROGRESS, HZ);\n\tspin_lock_irq(&hostdata->lock);\n\tif (!(NCR5380_read(MODE_REG) & MR_ARBITRATE)) {\n\t\t \n\t\tgoto out;\n\t}\n\tif (!hostdata->selecting) {\n\t\t \n\t\tNCR5380_write(MODE_REG, MR_BASE);\n\t\treturn false;\n\t}\n\tif (err < 0) {\n\t\tNCR5380_write(MODE_REG, MR_BASE);\n\t\tshost_printk(KERN_ERR, instance,\n\t\t             \"select: arbitration timeout\\n\");\n\t\tgoto out;\n\t}\n\tspin_unlock_irq(&hostdata->lock);\n\n\t \n\tudelay(3);\n\n\t \n\tif ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||\n\t    (NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_higher_mask) ||\n\t    (NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST)) {\n\t\tNCR5380_write(MODE_REG, MR_BASE);\n\t\tdsprintk(NDEBUG_ARBITRATION, instance, \"lost arbitration, deasserting MR_ARBITRATE\\n\");\n\t\tspin_lock_irq(&hostdata->lock);\n\t\tgoto out;\n\t}\n\n\t \n\tNCR5380_write(INITIATOR_COMMAND_REG,\n\t\t      ICR_BASE | ICR_ASSERT_SEL | ICR_ASSERT_BSY);\n\n\t \n\n\tif (hostdata->flags & FLAG_TOSHIBA_DELAY)\n\t\tudelay(15);\n\telse\n\t\tudelay(2);\n\n\tspin_lock_irq(&hostdata->lock);\n\n\t \n\tif (!(NCR5380_read(MODE_REG) & MR_ARBITRATE))\n\t\tgoto out;\n\n\tif (!hostdata->selecting) {\n\t\tNCR5380_write(MODE_REG, MR_BASE);\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\treturn false;\n\t}\n\n\tdsprintk(NDEBUG_ARBITRATION, instance, \"won arbitration\\n\");\n\n\t \n\n\tNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask | (1 << scmd_id(cmd)));\n\n\t \n\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY |\n\t              ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_SEL);\n\tNCR5380_write(MODE_REG, MR_BASE);\n\n\t \n\tNCR5380_write(SELECT_ENABLE_REG, 0);\n\n\tspin_unlock_irq(&hostdata->lock);\n\n\t \n\tudelay(1);         \n\n\t \n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA |\n\t              ICR_ASSERT_ATN | ICR_ASSERT_SEL);\n\n\t \n\n\tudelay(1);\n\n\tdsprintk(NDEBUG_SELECTION, instance, \"selecting target %d\\n\", scmd_id(cmd));\n\n\t \n\n\terr = NCR5380_poll_politely(hostdata, STATUS_REG, SR_BSY, SR_BSY,\n\t                            msecs_to_jiffies(250));\n\n\tif ((NCR5380_read(STATUS_REG) & (SR_SEL | SR_IO)) == (SR_SEL | SR_IO)) {\n\t\tspin_lock_irq(&hostdata->lock);\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\tNCR5380_reselect(instance);\n\t\tshost_printk(KERN_ERR, instance, \"reselection after won arbitration?\\n\");\n\t\tgoto out;\n\t}\n\n\tif (err < 0) {\n\t\tspin_lock_irq(&hostdata->lock);\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\n\t\t \n\t\tif (!hostdata->selecting)\n\t\t\treturn false;\n\n\t\tcmd->result = DID_BAD_TARGET << 16;\n\t\tcomplete_cmd(instance, cmd);\n\t\tdsprintk(NDEBUG_SELECTION, instance,\n\t\t\t\"target did not respond within 250ms\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\t \n\n\tudelay(1);\n\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\n\n\t \n\n\t \n\n\terr = NCR5380_poll_politely(hostdata, STATUS_REG, SR_REQ, SR_REQ, HZ);\n\tspin_lock_irq(&hostdata->lock);\n\tif (err < 0) {\n\t\tshost_printk(KERN_ERR, instance, \"select: REQ timeout\\n\");\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\tgoto out;\n\t}\n\tif (!hostdata->selecting) {\n\t\tdo_abort(instance, 0);\n\t\treturn false;\n\t}\n\n\tdsprintk(NDEBUG_SELECTION, instance, \"target %d selected, going into MESSAGE OUT phase.\\n\",\n\t         scmd_id(cmd));\n\ttmp[0] = IDENTIFY(can_disconnect, cmd->device->lun);\n\n\tlen = 1;\n\tdata = tmp;\n\tphase = PHASE_MSGOUT;\n\tNCR5380_transfer_pio(instance, &phase, &len, &data, 0);\n\tif (len) {\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\tcmd->result = DID_ERROR << 16;\n\t\tcomplete_cmd(instance, cmd);\n\t\tdsprintk(NDEBUG_SELECTION, instance, \"IDENTIFY message transfer failed\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tdsprintk(NDEBUG_SELECTION, instance, \"nexus established.\\n\");\n\n\thostdata->connected = cmd;\n\thostdata->busy[cmd->device->id] |= 1 << cmd->device->lun;\n\n#ifdef SUN3_SCSI_VME\n\tdregs->csr |= CSR_INTR;\n#endif\n\n\tinitialize_SCp(cmd);\n\n\tret = false;\n\nout:\n\tif (!hostdata->selecting)\n\t\treturn false;\n\thostdata->selecting = NULL;\n\treturn ret;\n}\n\n \n\n \n\nstatic int NCR5380_transfer_pio(struct Scsi_Host *instance,\n\t\t\t\tunsigned char *phase, int *count,\n\t\t\t\tunsigned char **data, unsigned int can_sleep)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned char p = *phase, tmp;\n\tint c = *count;\n\tunsigned char *d = *data;\n\n\t \n\n\tNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\n\n\tdo {\n\t\t \n\n\t\tif (NCR5380_poll_politely(hostdata, STATUS_REG, SR_REQ, SR_REQ,\n\t\t\t\t\t  HZ * can_sleep) < 0)\n\t\t\tbreak;\n\n\t\tdsprintk(NDEBUG_HANDSHAKE, instance, \"REQ asserted\\n\");\n\n\t\t \n\t\tif ((NCR5380_read(STATUS_REG) & PHASE_MASK) != p) {\n\t\t\tdsprintk(NDEBUG_PIO, instance, \"phase mismatch\\n\");\n\t\t\tNCR5380_dprint_phase(NDEBUG_PIO, instance);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!(p & SR_IO))\n\t\t\tNCR5380_write(OUTPUT_DATA_REG, *d);\n\t\telse\n\t\t\t*d = NCR5380_read(CURRENT_SCSI_DATA_REG);\n\n\t\t++d;\n\n\t\t \n\n\t\tif (!(p & SR_IO)) {\n\t\t\tif (!((p & SR_MSG) && c > 1)) {\n\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\n\t\t\t\tNCR5380_dprint(NDEBUG_PIO, instance);\n\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\n\t\t\t\t              ICR_ASSERT_DATA | ICR_ASSERT_ACK);\n\t\t\t} else {\n\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\n\t\t\t\t              ICR_ASSERT_DATA | ICR_ASSERT_ATN);\n\t\t\t\tNCR5380_dprint(NDEBUG_PIO, instance);\n\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\n\t\t\t\t              ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\n\t\t\t}\n\t\t} else {\n\t\t\tNCR5380_dprint(NDEBUG_PIO, instance);\n\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\n\t\t}\n\n\t\tif (NCR5380_poll_politely(hostdata,\n\t\t                          STATUS_REG, SR_REQ, 0, 5 * HZ * can_sleep) < 0)\n\t\t\tbreak;\n\n\t\tdsprintk(NDEBUG_HANDSHAKE, instance, \"REQ negated, handshake complete\\n\");\n\n \n\t\tif (!(p == PHASE_MSGIN && c == 1)) {\n\t\t\tif (p == PHASE_MSGOUT && c > 1)\n\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\n\t\t\telse\n\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\t}\n\t} while (--c);\n\n\tdsprintk(NDEBUG_PIO, instance, \"residual %d\\n\", c);\n\n\t*count = c;\n\t*data = d;\n\ttmp = NCR5380_read(STATUS_REG);\n\t \n\tif ((tmp & SR_REQ) || ((tmp & SR_IO) && c == 0))\n\t\t*phase = tmp & PHASE_MASK;\n\telse\n\t\t*phase = PHASE_UNKNOWN;\n\n\tif (!c || (*phase == p))\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}\n\n \n\nstatic void do_reset(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata __maybe_unused *hostdata = shost_priv(instance);\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tNCR5380_write(TARGET_COMMAND_REG,\n\t              PHASE_SR_TO_TCR(NCR5380_read(STATUS_REG) & PHASE_MASK));\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST);\n\tudelay(50);\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic int do_abort(struct Scsi_Host *instance, unsigned int can_sleep)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned char *msgptr, phase, tmp;\n\tint len;\n\tint rc;\n\n\t \n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\n\n\t \n\n\trc = NCR5380_poll_politely(hostdata, STATUS_REG, SR_REQ, SR_REQ,\n\t\t\t\t   10 * HZ * can_sleep);\n\tif (rc < 0)\n\t\tgoto out;\n\n\ttmp = NCR5380_read(STATUS_REG) & PHASE_MASK;\n\n\tNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));\n\n\tif (tmp != PHASE_MSGOUT) {\n\t\tNCR5380_write(INITIATOR_COMMAND_REG,\n\t\t              ICR_BASE | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\n\t\trc = NCR5380_poll_politely(hostdata, STATUS_REG, SR_REQ, 0,\n\t\t\t\t\t   3 * HZ * can_sleep);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\n\t}\n\n\ttmp = ABORT;\n\tmsgptr = &tmp;\n\tlen = 1;\n\tphase = PHASE_MSGOUT;\n\tNCR5380_transfer_pio(instance, &phase, &len, &msgptr, can_sleep);\n\tif (len)\n\t\trc = -ENXIO;\n\n\t \n\nout:\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\treturn rc;\n}\n\n \n\n\nstatic int NCR5380_transfer_dma(struct Scsi_Host *instance,\n\t\t\t\tunsigned char *phase, int *count,\n\t\t\t\tunsigned char **data)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tint c = *count;\n\tunsigned char p = *phase;\n\tunsigned char *d = *data;\n\tunsigned char tmp;\n\tint result = 0;\n\n\tif ((tmp = (NCR5380_read(STATUS_REG) & PHASE_MASK)) != p) {\n\t\t*phase = tmp;\n\t\treturn -1;\n\t}\n\n\tNCR5380_to_ncmd(hostdata->connected)->phase = p;\n\n\tif (p & SR_IO) {\n\t\tif (hostdata->read_overruns)\n\t\t\tc -= hostdata->read_overruns;\n\t\telse if (hostdata->flags & FLAG_DMA_FIXUP)\n\t\t\t--c;\n\t}\n\n\tdsprintk(NDEBUG_DMA, instance, \"initializing DMA %s: length %d, address %p\\n\",\n\t         (p & SR_IO) ? \"receive\" : \"send\", c, d);\n\n#ifdef CONFIG_SUN3\n\t \n\tsun3scsi_dma_start(c, *data);\n#endif\n\n\tNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\n\tNCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE | MR_MONITOR_BSY |\n\t                        MR_ENABLE_EOP_INTR);\n\n\tif (!(hostdata->flags & FLAG_LATE_DMA_SETUP)) {\n\t\t \n\t\tif (p & SR_IO)\n\t\t\tresult = NCR5380_dma_recv_setup(hostdata, d, c);\n\t\telse\n\t\t\tresult = NCR5380_dma_send_setup(hostdata, d, c);\n\t}\n\n\t \n\n\tif (p & SR_IO) {\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\tNCR5380_io_delay(1);\n\t\tNCR5380_write(START_DMA_INITIATOR_RECEIVE_REG, 0);\n\t} else {\n\t\tNCR5380_io_delay(1);\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\n\t\tNCR5380_io_delay(1);\n\t\tNCR5380_write(START_DMA_SEND_REG, 0);\n\t\tNCR5380_io_delay(1);\n\t}\n\n#ifdef CONFIG_SUN3\n#ifdef SUN3_SCSI_VME\n\tdregs->csr |= CSR_DMA_ENABLE;\n#endif\n\tsun3_dma_active = 1;\n#endif\n\n\tif (hostdata->flags & FLAG_LATE_DMA_SETUP) {\n\t\t \n\t\tif (p & SR_IO)\n\t\t\tresult = NCR5380_dma_recv_setup(hostdata, d, c);\n\t\telse\n\t\t\tresult = NCR5380_dma_send_setup(hostdata, d, c);\n\t}\n\n\t \n\tif (result < 0)\n\t\treturn result;\n\n\t \n\tif (result > 0) {\n\t\thostdata->dma_len = result;\n\t\treturn 0;\n\t}\n\n\t \n\thostdata->dma_len = c;\n\n \n\n\tif (hostdata->flags & FLAG_DMA_FIXUP) {\n\t\tif (p & SR_IO) {\n\t\t\t \n\n\t\t\tif (NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,\n\t\t\t                          BASR_DRQ, BASR_DRQ, 0) < 0) {\n\t\t\t\tresult = -1;\n\t\t\t\tshost_printk(KERN_ERR, instance, \"PDMA read: DRQ timeout\\n\");\n\t\t\t}\n\t\t\tif (NCR5380_poll_politely(hostdata, STATUS_REG,\n\t\t\t                          SR_REQ, 0, 0) < 0) {\n\t\t\t\tresult = -1;\n\t\t\t\tshost_printk(KERN_ERR, instance, \"PDMA read: !REQ timeout\\n\");\n\t\t\t}\n\t\t\td[*count - 1] = NCR5380_read(INPUT_DATA_REG);\n\t\t} else {\n\t\t\t \n\t\t\tif (NCR5380_poll_politely2(hostdata,\n\t\t\t     BUS_AND_STATUS_REG, BASR_DRQ, BASR_DRQ,\n\t\t\t     BUS_AND_STATUS_REG, BASR_PHASE_MATCH, 0, 0) < 0) {\n\t\t\t\tresult = -1;\n\t\t\t\tshost_printk(KERN_ERR, instance, \"PDMA write: DRQ and phase timeout\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tNCR5380_dma_complete(instance);\n\treturn result;\n}\n\n \n\nstatic void NCR5380_information_transfer(struct Scsi_Host *instance)\n\t__releases(&hostdata->lock) __acquires(&hostdata->lock)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned char msgout = NOP;\n\tint sink = 0;\n\tint len;\n\tint transfersize;\n\tunsigned char *data;\n\tunsigned char phase, tmp, extended_msg[10], old_phase = 0xff;\n\tstruct scsi_cmnd *cmd;\n\n#ifdef SUN3_SCSI_VME\n\tdregs->csr |= CSR_INTR;\n#endif\n\n\twhile ((cmd = hostdata->connected)) {\n\t\tstruct NCR5380_cmd *ncmd = NCR5380_to_ncmd(cmd);\n\n\t\ttmp = NCR5380_read(STATUS_REG);\n\t\t \n\t\tif (tmp & SR_REQ) {\n\t\t\tphase = (tmp & PHASE_MASK);\n\t\t\tif (phase != old_phase) {\n\t\t\t\told_phase = phase;\n\t\t\t\tNCR5380_dprint_phase(NDEBUG_INFORMATION, instance);\n\t\t\t}\n#ifdef CONFIG_SUN3\n\t\t\tif (phase == PHASE_CMDOUT &&\n\t\t\t    sun3_dma_setup_done != cmd) {\n\t\t\t\tint count;\n\n\t\t\t\tadvance_sg_buffer(ncmd);\n\n\t\t\t\tcount = sun3scsi_dma_xfer_len(hostdata, cmd);\n\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\t\t\t\t\tsun3scsi_dma_send_setup(hostdata,\n\t\t\t\t\t\t\t\t\tncmd->ptr, count);\n\t\t\t\t\telse\n\t\t\t\t\t\tsun3scsi_dma_recv_setup(hostdata,\n\t\t\t\t\t\t\t\t\tncmd->ptr, count);\n\t\t\t\t\tsun3_dma_setup_done = cmd;\n\t\t\t\t}\n#ifdef SUN3_SCSI_VME\n\t\t\t\tdregs->csr |= CSR_INTR;\n#endif\n\t\t\t}\n#endif  \n\n\t\t\tif (sink && (phase != PHASE_MSGOUT)) {\n\t\t\t\tNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));\n\n\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN |\n\t\t\t\t              ICR_ASSERT_ACK);\n\t\t\t\twhile (NCR5380_read(STATUS_REG) & SR_REQ)\n\t\t\t\t\t;\n\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\n\t\t\t\t              ICR_ASSERT_ATN);\n\t\t\t\tsink = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (phase) {\n\t\t\tcase PHASE_DATAOUT:\n#if (NDEBUG & NDEBUG_NO_DATAOUT)\n\t\t\t\tshost_printk(KERN_DEBUG, instance, \"NDEBUG_NO_DATAOUT set, attempted DATAOUT aborted\\n\");\n\t\t\t\tsink = 1;\n\t\t\t\tdo_abort(instance, 0);\n\t\t\t\tcmd->result = DID_ERROR << 16;\n\t\t\t\tcomplete_cmd(instance, cmd);\n\t\t\t\thostdata->connected = NULL;\n\t\t\t\thostdata->busy[scmd_id(cmd)] &= ~(1 << cmd->device->lun);\n\t\t\t\treturn;\n#endif\n\t\t\tcase PHASE_DATAIN:\n\t\t\t\t \n\n\t\t\t\tadvance_sg_buffer(ncmd);\n\t\t\t\tdsprintk(NDEBUG_INFORMATION, instance,\n\t\t\t\t\t\"this residual %d, sg ents %d\\n\",\n\t\t\t\t\tncmd->this_residual,\n\t\t\t\t\tsg_nents(ncmd->buffer));\n\n\t\t\t\t \n\n\t\t\t\ttransfersize = 0;\n\t\t\t\tif (!cmd->device->borken)\n\t\t\t\t\ttransfersize = NCR5380_dma_xfer_len(hostdata, cmd);\n\n\t\t\t\tif (transfersize > 0) {\n\t\t\t\t\tlen = transfersize;\n\t\t\t\t\tif (NCR5380_transfer_dma(instance, &phase,\n\t\t\t\t\t    &len, (unsigned char **)&ncmd->ptr)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tscmd_printk(KERN_INFO, cmd,\n\t\t\t\t\t\t\t\"switching to slow handshake\\n\");\n\t\t\t\t\t\tcmd->device->borken = 1;\n\t\t\t\t\t\tdo_reset(instance);\n\t\t\t\t\t\tbus_reset_cleanup(instance);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\ttransfersize = min(ncmd->this_residual,\n\t\t\t\t\t\t\t   NCR5380_PIO_CHUNK_SIZE);\n\t\t\t\t\tlen = transfersize;\n\t\t\t\t\tNCR5380_transfer_pio(instance, &phase, &len,\n\t\t\t\t\t\t\t     (unsigned char **)&ncmd->ptr,\n\t\t\t\t\t\t\t     0);\n\t\t\t\t\tncmd->this_residual -= transfersize - len;\n\t\t\t\t}\n#ifdef CONFIG_SUN3\n\t\t\t\tif (sun3_dma_setup_done == cmd)\n\t\t\t\t\tsun3_dma_setup_done = NULL;\n#endif\n\t\t\t\treturn;\n\t\t\tcase PHASE_MSGIN:\n\t\t\t\tlen = 1;\n\t\t\t\tdata = &tmp;\n\t\t\t\tNCR5380_transfer_pio(instance, &phase, &len, &data, 0);\n\t\t\t\tncmd->message = tmp;\n\n\t\t\t\tswitch (tmp) {\n\t\t\t\tcase ABORT:\n\t\t\t\t\tset_host_byte(cmd, DID_ABORT);\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase COMMAND_COMPLETE:\n\t\t\t\t\t \n\t\t\t\t\tsink = 1;\n\t\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\t\t\t\tdsprintk(NDEBUG_QUEUES, instance,\n\t\t\t\t\t         \"COMMAND COMPLETE %p target %d lun %llu\\n\",\n\t\t\t\t\t         cmd, scmd_id(cmd), cmd->device->lun);\n\n\t\t\t\t\thostdata->connected = NULL;\n\t\t\t\t\thostdata->busy[scmd_id(cmd)] &= ~(1 << cmd->device->lun);\n\n\t\t\t\t\tset_status_byte(cmd, ncmd->status);\n\n\t\t\t\t\tset_resid_from_SCp(cmd);\n\n\t\t\t\t\tif (cmd->cmnd[0] == REQUEST_SENSE)\n\t\t\t\t\t\tcomplete_cmd(instance, cmd);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (ncmd->status == SAM_STAT_CHECK_CONDITION ||\n\t\t\t\t\t\t    ncmd->status == SAM_STAT_COMMAND_TERMINATED) {\n\t\t\t\t\t\t\tdsprintk(NDEBUG_QUEUES, instance, \"autosense: adding cmd %p to tail of autosense queue\\n\",\n\t\t\t\t\t\t\t         cmd);\n\t\t\t\t\t\t\tlist_add_tail(&ncmd->list,\n\t\t\t\t\t\t\t              &hostdata->autosense);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tcomplete_cmd(instance, cmd);\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tNCR5380_write(TARGET_COMMAND_REG, 0);\n\n\t\t\t\t\treturn;\n\t\t\t\tcase MESSAGE_REJECT:\n\t\t\t\t\t \n\t\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\t\t\t\tswitch (hostdata->last_message) {\n\t\t\t\t\tcase HEAD_OF_QUEUE_TAG:\n\t\t\t\t\tcase ORDERED_QUEUE_TAG:\n\t\t\t\t\tcase SIMPLE_QUEUE_TAG:\n\t\t\t\t\t\tcmd->device->simple_tags = 0;\n\t\t\t\t\t\thostdata->busy[cmd->device->id] |= (1 << (cmd->device->lun & 0xFF));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DISCONNECT:\n\t\t\t\t\t \n\t\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\t\t\t\thostdata->connected = NULL;\n\t\t\t\t\tlist_add(&ncmd->list, &hostdata->disconnected);\n\t\t\t\t\tdsprintk(NDEBUG_INFORMATION | NDEBUG_QUEUES,\n\t\t\t\t\t         instance, \"connected command %p for target %d lun %llu moved to disconnected queue\\n\",\n\t\t\t\t\t         cmd, scmd_id(cmd), cmd->device->lun);\n\n\t\t\t\t\t \n\t\t\t\t\tNCR5380_write(TARGET_COMMAND_REG, 0);\n\n#ifdef SUN3_SCSI_VME\n\t\t\t\t\tdregs->csr |= CSR_DMA_ENABLE;\n#endif\n\t\t\t\t\treturn;\n\t\t\t\t\t \n\t\t\t\tcase SAVE_POINTERS:\n\t\t\t\tcase RESTORE_POINTERS:\n\t\t\t\t\t \n\t\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EXTENDED_MESSAGE:\n\t\t\t\t\t \n\t\t\t\t\textended_msg[0] = EXTENDED_MESSAGE;\n\t\t\t\t\t \n\t\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\n\t\t\t\t\tspin_unlock_irq(&hostdata->lock);\n\n\t\t\t\t\tdsprintk(NDEBUG_EXTENDED, instance, \"receiving extended message\\n\");\n\n\t\t\t\t\tlen = 2;\n\t\t\t\t\tdata = extended_msg + 1;\n\t\t\t\t\tphase = PHASE_MSGIN;\n\t\t\t\t\tNCR5380_transfer_pio(instance, &phase, &len, &data, 1);\n\t\t\t\t\tdsprintk(NDEBUG_EXTENDED, instance, \"length %d, code 0x%02x\\n\",\n\t\t\t\t\t         (int)extended_msg[1],\n\t\t\t\t\t         (int)extended_msg[2]);\n\n\t\t\t\t\tif (!len && extended_msg[1] > 0 &&\n\t\t\t\t\t    extended_msg[1] <= sizeof(extended_msg) - 2) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\t\t\t\t\tlen = extended_msg[1] - 1;\n\t\t\t\t\t\tdata = extended_msg + 3;\n\t\t\t\t\t\tphase = PHASE_MSGIN;\n\n\t\t\t\t\t\tNCR5380_transfer_pio(instance, &phase, &len, &data, 1);\n\t\t\t\t\t\tdsprintk(NDEBUG_EXTENDED, instance, \"message received, residual %d\\n\",\n\t\t\t\t\t\t         len);\n\n\t\t\t\t\t\tswitch (extended_msg[2]) {\n\t\t\t\t\t\tcase EXTENDED_SDTR:\n\t\t\t\t\t\tcase EXTENDED_WDTR:\n\t\t\t\t\t\t\ttmp = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (len) {\n\t\t\t\t\t\tshost_printk(KERN_ERR, instance, \"error receiving extended message\\n\");\n\t\t\t\t\t\ttmp = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshost_printk(KERN_NOTICE, instance, \"extended message code %02x length %d is too long\\n\",\n\t\t\t\t\t\t             extended_msg[2], extended_msg[1]);\n\t\t\t\t\t\ttmp = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tspin_lock_irq(&hostdata->lock);\n\t\t\t\t\tif (!hostdata->connected)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t \n\t\t\t\t\tfallthrough;\n\t\t\t\tdefault:\n\t\t\t\t\t \n\t\t\t\t\tif (tmp == EXTENDED_MESSAGE)\n\t\t\t\t\t\tscmd_printk(KERN_INFO, cmd,\n\t\t\t\t\t\t            \"rejecting unknown extended message code %02x, length %d\\n\",\n\t\t\t\t\t\t            extended_msg[2], extended_msg[1]);\n\t\t\t\t\telse if (tmp)\n\t\t\t\t\t\tscmd_printk(KERN_INFO, cmd,\n\t\t\t\t\t\t            \"rejecting unknown message code %02x\\n\",\n\t\t\t\t\t\t            tmp);\n\n\t\t\t\t\tmsgout = MESSAGE_REJECT;\n\t\t\t\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\n\t\t\t\t\tbreak;\n\t\t\t\t}  \n\t\t\t\tbreak;\n\t\t\tcase PHASE_MSGOUT:\n\t\t\t\tlen = 1;\n\t\t\t\tdata = &msgout;\n\t\t\t\thostdata->last_message = msgout;\n\t\t\t\tNCR5380_transfer_pio(instance, &phase, &len, &data, 0);\n\t\t\t\tif (msgout == ABORT) {\n\t\t\t\t\thostdata->connected = NULL;\n\t\t\t\t\thostdata->busy[scmd_id(cmd)] &= ~(1 << cmd->device->lun);\n\t\t\t\t\tcmd->result = DID_ERROR << 16;\n\t\t\t\t\tcomplete_cmd(instance, cmd);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmsgout = NOP;\n\t\t\t\tbreak;\n\t\t\tcase PHASE_CMDOUT:\n\t\t\t\tlen = cmd->cmd_len;\n\t\t\t\tdata = cmd->cmnd;\n\t\t\t\t \n\t\t\t\tNCR5380_transfer_pio(instance, &phase, &len, &data, 0);\n\t\t\t\tbreak;\n\t\t\tcase PHASE_STATIN:\n\t\t\t\tlen = 1;\n\t\t\t\tdata = &tmp;\n\t\t\t\tNCR5380_transfer_pio(instance, &phase, &len, &data, 0);\n\t\t\t\tncmd->status = tmp;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tshost_printk(KERN_ERR, instance, \"unknown phase\\n\");\n\t\t\t\tNCR5380_dprint(NDEBUG_ANY, instance);\n\t\t\t}  \n\t\t} else {\n\t\t\tspin_unlock_irq(&hostdata->lock);\n\t\t\tNCR5380_poll_politely(hostdata, STATUS_REG, SR_REQ, SR_REQ, HZ);\n\t\t\tspin_lock_irq(&hostdata->lock);\n\t\t}\n\t}\n}\n\n \n\nstatic void NCR5380_reselect(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned char target_mask;\n\tunsigned char lun;\n\tunsigned char msg[3];\n\tstruct NCR5380_cmd *ncmd;\n\tstruct scsi_cmnd *tmp;\n\n\t \n\n\tNCR5380_write(MODE_REG, MR_BASE);\n\n\ttarget_mask = NCR5380_read(CURRENT_SCSI_DATA_REG) & ~(hostdata->id_mask);\n\tif (!target_mask || target_mask & (target_mask - 1)) {\n\t\tshost_printk(KERN_WARNING, instance,\n\t\t\t     \"reselect: bad target_mask 0x%02x\\n\", target_mask);\n\t\treturn;\n\t}\n\n\t \n\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY);\n\tif (NCR5380_poll_politely(hostdata,\n\t                          STATUS_REG, SR_SEL, 0, 0) < 0) {\n\t\tshost_printk(KERN_ERR, instance, \"reselect: !SEL timeout\\n\");\n\t\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\t\treturn;\n\t}\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\n\t \n\n\tif (NCR5380_poll_politely(hostdata,\n\t                          STATUS_REG, SR_REQ, SR_REQ, 0) < 0) {\n\t\tif ((NCR5380_read(STATUS_REG) & (SR_BSY | SR_SEL)) == 0)\n\t\t\t \n\t\t\treturn;\n\t\tshost_printk(KERN_ERR, instance, \"reselect: REQ timeout\\n\");\n\t\tdo_abort(instance, 0);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SUN3\n\t \n\tNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(PHASE_MSGIN));\n\n\t \n\tmsg[0] = NCR5380_read(CURRENT_SCSI_DATA_REG);\n#else\n\t{\n\t\tint len = 1;\n\t\tunsigned char *data = msg;\n\t\tunsigned char phase = PHASE_MSGIN;\n\n\t\tNCR5380_transfer_pio(instance, &phase, &len, &data, 0);\n\n\t\tif (len) {\n\t\t\tdo_abort(instance, 0);\n\t\t\treturn;\n\t\t}\n\t}\n#endif  \n\n\tif (!(msg[0] & 0x80)) {\n\t\tshost_printk(KERN_ERR, instance, \"expecting IDENTIFY message, got \");\n\t\tspi_print_msg(msg);\n\t\tprintk(\"\\n\");\n\t\tdo_abort(instance, 0);\n\t\treturn;\n\t}\n\tlun = msg[0] & 0x07;\n\n\t \n\n\t \n\n\ttmp = NULL;\n\tlist_for_each_entry(ncmd, &hostdata->disconnected, list) {\n\t\tstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\n\n\t\tif (target_mask == (1 << scmd_id(cmd)) &&\n\t\t    lun == (u8)cmd->device->lun) {\n\t\t\tlist_del(&ncmd->list);\n\t\t\ttmp = cmd;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tmp) {\n\t\tdsprintk(NDEBUG_RESELECTION | NDEBUG_QUEUES, instance,\n\t\t         \"reselect: removed %p from disconnected queue\\n\", tmp);\n\t} else {\n\t\tint target = ffs(target_mask) - 1;\n\n\t\tshost_printk(KERN_ERR, instance, \"target bitmask 0x%02x lun %d not in disconnected queue.\\n\",\n\t\t             target_mask, lun);\n\t\t \n\t\tif (do_abort(instance, 0) == 0)\n\t\t\thostdata->busy[target] &= ~(1 << lun);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SUN3\n\tif (sun3_dma_setup_done != tmp) {\n\t\tint count;\n\n\t\tadvance_sg_buffer(ncmd);\n\n\t\tcount = sun3scsi_dma_xfer_len(hostdata, tmp);\n\n\t\tif (count > 0) {\n\t\t\tif (tmp->sc_data_direction == DMA_TO_DEVICE)\n\t\t\t\tsun3scsi_dma_send_setup(hostdata,\n\t\t\t\t\t\t\tncmd->ptr, count);\n\t\t\telse\n\t\t\t\tsun3scsi_dma_recv_setup(hostdata,\n\t\t\t\t\t\t\tncmd->ptr, count);\n\t\t\tsun3_dma_setup_done = tmp;\n\t\t}\n\t}\n\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\n#endif  \n\n\t \n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\n\thostdata->connected = tmp;\n\tdsprintk(NDEBUG_RESELECTION, instance, \"nexus established, target %d, lun %llu\\n\",\n\t         scmd_id(tmp), tmp->device->lun);\n}\n\n \n\nstatic bool list_find_cmd(struct list_head *haystack,\n                          struct scsi_cmnd *needle)\n{\n\tstruct NCR5380_cmd *ncmd;\n\n\tlist_for_each_entry(ncmd, haystack, list)\n\t\tif (NCR5380_to_scmd(ncmd) == needle)\n\t\t\treturn true;\n\treturn false;\n}\n\n \n\nstatic bool list_del_cmd(struct list_head *haystack,\n                         struct scsi_cmnd *needle)\n{\n\tif (list_find_cmd(haystack, needle)) {\n\t\tstruct NCR5380_cmd *ncmd = NCR5380_to_ncmd(needle);\n\n\t\tlist_del(&ncmd->list);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \n\nstatic int NCR5380_abort(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *instance = cmd->device->host;\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned long flags;\n\tint result = SUCCESS;\n\n\tspin_lock_irqsave(&hostdata->lock, flags);\n\n#if (NDEBUG & NDEBUG_ANY)\n\tscmd_printk(KERN_INFO, cmd, __func__);\n#endif\n\tNCR5380_dprint(NDEBUG_ANY, instance);\n\tNCR5380_dprint_phase(NDEBUG_ANY, instance);\n\n\tif (list_del_cmd(&hostdata->unissued, cmd)) {\n\t\tdsprintk(NDEBUG_ABORT, instance,\n\t\t         \"abort: removed %p from issue queue\\n\", cmd);\n\t\tcmd->result = DID_ABORT << 16;\n\t\tscsi_done(cmd);  \n\t\tgoto out;\n\t}\n\n\tif (hostdata->selecting == cmd) {\n\t\tdsprintk(NDEBUG_ABORT, instance,\n\t\t         \"abort: cmd %p == selecting\\n\", cmd);\n\t\thostdata->selecting = NULL;\n\t\tcmd->result = DID_ABORT << 16;\n\t\tcomplete_cmd(instance, cmd);\n\t\tgoto out;\n\t}\n\n\tif (list_del_cmd(&hostdata->disconnected, cmd)) {\n\t\tdsprintk(NDEBUG_ABORT, instance,\n\t\t         \"abort: removed %p from disconnected list\\n\", cmd);\n\t\t \n\t\tset_host_byte(cmd, DID_ERROR);\n\t\tcomplete_cmd(instance, cmd);\n\t\tresult = FAILED;\n\t\tgoto out;\n\t}\n\n\tif (hostdata->connected == cmd) {\n\t\tdsprintk(NDEBUG_ABORT, instance, \"abort: cmd %p is connected\\n\", cmd);\n\t\thostdata->connected = NULL;\n\t\thostdata->dma_len = 0;\n\t\tif (do_abort(instance, 0) < 0) {\n\t\t\tset_host_byte(cmd, DID_ERROR);\n\t\t\tcomplete_cmd(instance, cmd);\n\t\t\tresult = FAILED;\n\t\t\tgoto out;\n\t\t}\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\tcomplete_cmd(instance, cmd);\n\t\tgoto out;\n\t}\n\n\tif (list_del_cmd(&hostdata->autosense, cmd)) {\n\t\tdsprintk(NDEBUG_ABORT, instance,\n\t\t         \"abort: removed %p from sense queue\\n\", cmd);\n\t\tcomplete_cmd(instance, cmd);\n\t}\n\nout:\n\tif (result == FAILED)\n\t\tdsprintk(NDEBUG_ABORT, instance, \"abort: failed to abort %p\\n\", cmd);\n\telse {\n\t\thostdata->busy[scmd_id(cmd)] &= ~(1 << cmd->device->lun);\n\t\tdsprintk(NDEBUG_ABORT, instance, \"abort: successfully aborted %p\\n\", cmd);\n\t}\n\n\tqueue_work(hostdata->work_q, &hostdata->main_task);\n\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\n\treturn result;\n}\n\n\nstatic void bus_reset_cleanup(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tint i;\n\tstruct NCR5380_cmd *ncmd;\n\n\t \n\tNCR5380_write(MODE_REG, MR_BASE);\n\tNCR5380_write(TARGET_COMMAND_REG, 0);\n\tNCR5380_write(SELECT_ENABLE_REG, 0);\n\n\t \n\n\tif (hostdata->selecting) {\n\t\thostdata->selecting->result = DID_RESET << 16;\n\t\tcomplete_cmd(instance, hostdata->selecting);\n\t\thostdata->selecting = NULL;\n\t}\n\n\tlist_for_each_entry(ncmd, &hostdata->disconnected, list) {\n\t\tstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\n\n\t\tset_host_byte(cmd, DID_RESET);\n\t\tcomplete_cmd(instance, cmd);\n\t}\n\tINIT_LIST_HEAD(&hostdata->disconnected);\n\n\tlist_for_each_entry(ncmd, &hostdata->autosense, list) {\n\t\tstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\n\n\t\tscsi_done(cmd);\n\t}\n\tINIT_LIST_HEAD(&hostdata->autosense);\n\n\tif (hostdata->connected) {\n\t\tset_host_byte(hostdata->connected, DID_RESET);\n\t\tcomplete_cmd(instance, hostdata->connected);\n\t\thostdata->connected = NULL;\n\t}\n\n\tfor (i = 0; i < 8; ++i)\n\t\thostdata->busy[i] = 0;\n\thostdata->dma_len = 0;\n\n\tqueue_work(hostdata->work_q, &hostdata->main_task);\n}\n\n \n\nstatic int NCR5380_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *instance = cmd->device->host;\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tunsigned long flags;\n\tstruct NCR5380_cmd *ncmd;\n\n\tspin_lock_irqsave(&hostdata->lock, flags);\n\n#if (NDEBUG & NDEBUG_ANY)\n\tshost_printk(KERN_INFO, instance, __func__);\n#endif\n\tNCR5380_dprint(NDEBUG_ANY, instance);\n\tNCR5380_dprint_phase(NDEBUG_ANY, instance);\n\n\tlist_for_each_entry(ncmd, &hostdata->unissued, list) {\n\t\tstruct scsi_cmnd *scmd = NCR5380_to_scmd(ncmd);\n\n\t\tscmd->result = DID_RESET << 16;\n\t\tscsi_done(scmd);\n\t}\n\tINIT_LIST_HEAD(&hostdata->unissued);\n\n\tdo_reset(instance);\n\tbus_reset_cleanup(instance);\n\n\tspin_unlock_irqrestore(&hostdata->lock, flags);\n\n\treturn SUCCESS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}