{
  "module_name": "qla_inline.h",
  "hash_id": "55dbe74a39ab122e2080937f03d41e486596e3d2626507adf9b53e484402e8c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_inline.h",
  "human_readable_source": " \n \n\n#include \"qla_target.h\"\n \nstatic inline uint16_t\nqla24xx_calc_iocbs(scsi_qla_host_t *vha, uint16_t dsds)\n{\n\tuint16_t iocbs;\n\n\tiocbs = 1;\n\tif (dsds > 1) {\n\t\tiocbs += (dsds - 1) / 5;\n\t\tif ((dsds - 1) % 5)\n\t\t\tiocbs++;\n\t}\n\treturn iocbs;\n}\n\n \nstatic __inline__ uint16_t\nqla2x00_debounce_register(volatile __le16 __iomem *addr)\n{\n\tvolatile uint16_t first;\n\tvolatile uint16_t second;\n\n\tdo {\n\t\tfirst = rd_reg_word(addr);\n\t\tbarrier();\n\t\tcpu_relax();\n\t\tsecond = rd_reg_word(addr);\n\t} while (first != second);\n\n\treturn (first);\n}\n\nstatic inline void\nqla2x00_poll(struct rsp_que *rsp)\n{\n\tstruct qla_hw_data *ha = rsp->hw;\n\n\tif (IS_P3P_TYPE(ha))\n\t\tqla82xx_poll(0, rsp);\n\telse\n\t\tha->isp_ops->intr_handler(0, rsp);\n}\n\nstatic inline uint8_t *\nhost_to_fcp_swap(uint8_t *fcp, uint32_t bsize)\n{\n       uint32_t *ifcp = (uint32_t *) fcp;\n       uint32_t *ofcp = (uint32_t *) fcp;\n       uint32_t iter = bsize >> 2;\n\n       for (; iter ; iter--)\n               *ofcp++ = swab32(*ifcp++);\n\n       return fcp;\n}\n\nstatic inline void\nhost_to_adap(uint8_t *src, uint8_t *dst, uint32_t bsize)\n{\n\tuint32_t *isrc = (uint32_t *) src;\n\t__le32 *odest = (__le32 *) dst;\n\tuint32_t iter = bsize >> 2;\n\n\tfor ( ; iter--; isrc++)\n\t\t*odest++ = cpu_to_le32(*isrc);\n}\n\nstatic inline void\nqla2x00_clean_dsd_pool(struct qla_hw_data *ha, struct crc_context *ctx)\n{\n\tstruct dsd_dma *dsd, *tdsd;\n\n\t \n\tlist_for_each_entry_safe(dsd, tdsd, &ctx->dsd_list, list) {\n\t\tdma_pool_free(ha->dl_dma_pool, dsd->dsd_addr,\n\t\t    dsd->dsd_list_dma);\n\t\tlist_del(&dsd->list);\n\t\tkfree(dsd);\n\t}\n\tINIT_LIST_HEAD(&ctx->dsd_list);\n}\n\nstatic inline void\nqla2x00_set_fcport_disc_state(fc_port_t *fcport, int state)\n{\n\tint old_val;\n\tuint8_t shiftbits, mask;\n\tuint8_t port_dstate_str_sz;\n\n\t \n\tshiftbits = 4;\n\tmask = (1 << shiftbits) - 1;\n\n\tport_dstate_str_sz = sizeof(port_dstate_str) / sizeof(char *);\n\tfcport->disc_state = state;\n\twhile (1) {\n\t\told_val = atomic_read(&fcport->shadow_disc_state);\n\t\tif (old_val == atomic_cmpxchg(&fcport->shadow_disc_state,\n\t\t    old_val, (old_val << shiftbits) | state)) {\n\t\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x2134,\n\t\t\t    \"FCPort %8phC disc_state transition: %s to %s - portid=%06x.\\n\",\n\t\t\t    fcport->port_name, (old_val & mask) < port_dstate_str_sz ?\n\t\t\t\t    port_dstate_str[old_val & mask] : \"Unknown\",\n\t\t\t    port_dstate_str[state], fcport->d_id.b24);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic inline int\nqla2x00_hba_err_chk_enabled(srb_t *sp)\n{\n\t \n\tswitch (scsi_get_prot_op(GET_CMD_SP(sp))) {\n\tcase SCSI_PROT_READ_STRIP:\n\tcase SCSI_PROT_WRITE_INSERT:\n\t\tif (ql2xenablehba_err_chk >= 1)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase SCSI_PROT_READ_PASS:\n\tcase SCSI_PROT_WRITE_PASS:\n\t\tif (ql2xenablehba_err_chk >= 2)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase SCSI_PROT_READ_INSERT:\n\tcase SCSI_PROT_WRITE_STRIP:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int\nqla2x00_reset_active(scsi_qla_host_t *vha)\n{\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(vha->hw->pdev);\n\n\t \n\treturn test_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags) ||\n\t    test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags) ||\n\t    test_bit(ISP_ABORT_RETRY, &base_vha->dpc_flags) ||\n\t    test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) ||\n\t    test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\n}\n\nstatic inline int\nqla2x00_chip_is_down(scsi_qla_host_t *vha)\n{\n\treturn (qla2x00_reset_active(vha) || !vha->hw->flags.fw_started);\n}\n\nstatic void qla2xxx_init_sp(srb_t *sp, scsi_qla_host_t *vha,\n\t\t\t    struct qla_qpair *qpair, fc_port_t *fcport)\n{\n\tmemset(sp, 0, sizeof(*sp));\n\tsp->fcport = fcport;\n\tsp->iocbs = 1;\n\tsp->vha = vha;\n\tsp->qpair = qpair;\n\tsp->cmd_type = TYPE_SRB;\n\t \n\tkref_init(&sp->cmd_kref);\n\tINIT_LIST_HEAD(&sp->elem);\n}\n\nstatic inline srb_t *\nqla2xxx_get_qpair_sp(scsi_qla_host_t *vha, struct qla_qpair *qpair,\n    fc_port_t *fcport, gfp_t flag)\n{\n\tsrb_t *sp = NULL;\n\tuint8_t bail;\n\n\tQLA_QPAIR_MARK_BUSY(qpair, bail);\n\tif (unlikely(bail))\n\t\treturn NULL;\n\n\tsp = mempool_alloc(qpair->srb_mempool, flag);\n\tif (sp)\n\t\tqla2xxx_init_sp(sp, vha, qpair, fcport);\n\telse\n\t\tQLA_QPAIR_MARK_NOT_BUSY(qpair);\n\treturn sp;\n}\n\nvoid qla2xxx_rel_done_warning(srb_t *sp, int res);\nvoid qla2xxx_rel_free_warning(srb_t *sp);\n\nstatic inline void\nqla2xxx_rel_qpair_sp(struct qla_qpair *qpair, srb_t *sp)\n{\n\tsp->qpair = NULL;\n\tsp->done = qla2xxx_rel_done_warning;\n\tsp->free = qla2xxx_rel_free_warning;\n\tmempool_free(sp, qpair->srb_mempool);\n\tQLA_QPAIR_MARK_NOT_BUSY(qpair);\n}\n\nstatic inline srb_t *\nqla2x00_get_sp(scsi_qla_host_t *vha, fc_port_t *fcport, gfp_t flag)\n{\n\tsrb_t *sp = NULL;\n\tstruct qla_qpair *qpair;\n\n\tif (unlikely(qla_vha_mark_busy(vha)))\n\t\treturn NULL;\n\n\tqpair = vha->hw->base_qpair;\n\tsp = qla2xxx_get_qpair_sp(vha, qpair, fcport, flag);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->vha = vha;\ndone:\n\tif (!sp)\n\t\tQLA_VHA_MARK_NOT_BUSY(vha);\n\treturn sp;\n}\n\nstatic inline void\nqla2x00_rel_sp(srb_t *sp)\n{\n\tQLA_VHA_MARK_NOT_BUSY(sp->vha);\n\tqla2xxx_rel_qpair_sp(sp->qpair, sp);\n}\n\nstatic inline int\nqla2x00_gid_list_size(struct qla_hw_data *ha)\n{\n\tif (IS_QLAFX00(ha))\n\t\treturn sizeof(uint32_t) * 32;\n\telse\n\t\treturn sizeof(struct gid_list_info) * ha->max_fibre_devices;\n}\n\nstatic inline void\nqla2x00_handle_mbx_completion(struct qla_hw_data *ha, int status)\n{\n\tif (test_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags) &&\n\t    (status & MBX_INTERRUPT) && ha->flags.mbox_int) {\n\t\tset_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\n\t\tclear_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\n\t\tcomplete(&ha->mbx_intr_comp);\n\t}\n}\n\nstatic inline void\nqla2x00_set_retry_delay_timestamp(fc_port_t *fcport, uint16_t sts_qual)\n{\n\tu8 scope;\n\tu16 qual;\n#define SQ_SCOPE_MASK\t\t0xc000  \n#define SQ_SCOPE_SHIFT\t\t14\n#define SQ_QUAL_MASK\t\t0x3fff\n\n#define SQ_MAX_WAIT_SEC\t\t60  \n#define SQ_MAX_WAIT_TIME\t(SQ_MAX_WAIT_SEC * 10)  \n\n\tif (!sts_qual)  \n\t\treturn;\n\n\tscope = (sts_qual & SQ_SCOPE_MASK) >> SQ_SCOPE_SHIFT;\n\t \n\tif (scope != 1 && scope != 2)\n\t\treturn;\n\n\t \n\tif (fcport->retry_delay_timestamp &&\n\t    time_before(jiffies, fcport->retry_delay_timestamp))\n\t\treturn;\n\n\tqual = sts_qual & SQ_QUAL_MASK;\n\tif (qual < 1 || qual > 0x3fef)\n\t\treturn;\n\tqual = min(qual, (u16)SQ_MAX_WAIT_TIME);\n\n\t \n\tfcport->retry_delay_timestamp = jiffies + (qual * HZ / 10);\n\n\tql_log(ql_log_warn, fcport->vha, 0x5101,\n\t       \"%8phC: I/O throttling requested (status qualifier = %04xh), holding off I/Os for %ums.\\n\",\n\t       fcport->port_name, sts_qual, qual * 100);\n}\n\nstatic inline bool\nqla_is_exch_offld_enabled(struct scsi_qla_host *vha)\n{\n\tif (qla_ini_mode_enabled(vha) &&\n\t    (vha->ql2xiniexchg > FW_DEF_EXCHANGES_CNT))\n\t\treturn true;\n\telse if (qla_tgt_mode_enabled(vha) &&\n\t    (vha->ql2xexchoffld > FW_DEF_EXCHANGES_CNT))\n\t\treturn true;\n\telse if (qla_dual_mode_enabled(vha) &&\n\t    ((vha->ql2xiniexchg + vha->ql2xexchoffld) > FW_DEF_EXCHANGES_CNT))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic inline void\nqla_cpu_update(struct qla_qpair *qpair, uint16_t cpuid)\n{\n\tqpair->cpuid = cpuid;\n\n\tif (!list_empty(&qpair->hints_list)) {\n\t\tstruct qla_qpair_hint *h;\n\n\t\tlist_for_each_entry(h, &qpair->hints_list, hint_elem)\n\t\t\th->cpuid = qpair->cpuid;\n\t}\n}\n\nstatic inline struct qla_qpair_hint *\nqla_qpair_to_hint(struct qla_tgt *tgt, struct qla_qpair *qpair)\n{\n\tstruct qla_qpair_hint *h;\n\tu16 i;\n\n\tfor (i = 0; i < tgt->ha->max_qpairs + 1; i++) {\n\t\th = &tgt->qphints[i];\n\t\tif (h->qpair == qpair)\n\t\t\treturn h;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline void\nqla_83xx_start_iocbs(struct qla_qpair *qpair)\n{\n\tstruct req_que *req = qpair->req;\n\n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\twrt_reg_dword(req->req_q_in, req->ring_index);\n}\n\nstatic inline int\nqla2xxx_get_fc4_priority(struct scsi_qla_host *vha)\n{\n\tuint32_t data;\n\n\tdata =\n\t    ((uint8_t *)vha->hw->nvram)[NVRAM_DUAL_FCP_NVME_FLAG_OFFSET];\n\n\n\treturn (data >> 6) & BIT_0 ? FC4_PRIORITY_FCP : FC4_PRIORITY_NVME;\n}\n\nenum {\n\tRESOURCE_NONE,\n\tRESOURCE_IOCB = BIT_0,\n\tRESOURCE_EXCH = BIT_1,   \n\tRESOURCE_FORCE = BIT_2,\n\tRESOURCE_HA = BIT_3,\n};\n\nstatic inline int\nqla_get_fw_resources(struct qla_qpair *qp, struct iocb_resource *iores)\n{\n\tu16 iocbs_used, i;\n\tu16 exch_used;\n\tstruct qla_hw_data *ha = qp->hw;\n\n\tif (!ql2xenforce_iocb_limit) {\n\t\tiores->res_type = RESOURCE_NONE;\n\t\treturn 0;\n\t}\n\tif (iores->res_type & RESOURCE_FORCE)\n\t\tgoto force;\n\n\tif ((iores->iocb_cnt + qp->fwres.iocbs_used) >= qp->fwres.iocbs_qp_limit) {\n\t\t \n\t\tiocbs_used = ha->base_qpair->fwres.iocbs_used;\n\t\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\t\tif (ha->queue_pair_map[i])\n\t\t\t\tiocbs_used += ha->queue_pair_map[i]->fwres.iocbs_used;\n\t\t}\n\n\t\tif ((iores->iocb_cnt + iocbs_used) >= qp->fwres.iocbs_limit) {\n\t\t\tiores->res_type = RESOURCE_NONE;\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\tif (iores->res_type & RESOURCE_EXCH) {\n\t\texch_used = ha->base_qpair->fwres.exch_used;\n\t\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\t\tif (ha->queue_pair_map[i])\n\t\t\t\texch_used += ha->queue_pair_map[i]->fwres.exch_used;\n\t\t}\n\n\t\tif ((exch_used + iores->exch_cnt) >= qp->fwres.exch_limit) {\n\t\t\tiores->res_type = RESOURCE_NONE;\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\tif (ql2xenforce_iocb_limit == 2) {\n\t\tif ((iores->iocb_cnt + atomic_read(&ha->fwres.iocb_used)) >=\n\t\t    ha->fwres.iocb_limit) {\n\t\t\tiores->res_type = RESOURCE_NONE;\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tif (iores->res_type & RESOURCE_EXCH) {\n\t\t\tif ((iores->exch_cnt + atomic_read(&ha->fwres.exch_used)) >=\n\t\t\t    ha->fwres.exch_limit) {\n\t\t\t\tiores->res_type = RESOURCE_NONE;\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t}\n\t}\n\nforce:\n\tqp->fwres.iocbs_used += iores->iocb_cnt;\n\tqp->fwres.exch_used += iores->exch_cnt;\n\tif (ql2xenforce_iocb_limit == 2) {\n\t\tatomic_add(iores->iocb_cnt, &ha->fwres.iocb_used);\n\t\tatomic_add(iores->exch_cnt, &ha->fwres.exch_used);\n\t\tiores->res_type |= RESOURCE_HA;\n\t}\n\treturn 0;\n}\n\n \nstatic void qla_atomic_dtz(atomic_t *v, int amount)\n{\n\tint c, old, dec;\n\n\tc = atomic_read(v);\n\tfor (;;) {\n\t\tdec = c - amount;\n\t\tif (unlikely(dec < 0))\n\t\t\tdec = 0;\n\n\t\told = atomic_cmpxchg((v), c, dec);\n\t\tif (likely(old == c))\n\t\t\tbreak;\n\t\tc = old;\n\t}\n}\n\nstatic inline void\nqla_put_fw_resources(struct qla_qpair *qp, struct iocb_resource *iores)\n{\n\tstruct qla_hw_data *ha = qp->hw;\n\n\tif (iores->res_type & RESOURCE_HA) {\n\t\tif (iores->res_type & RESOURCE_IOCB)\n\t\t\tqla_atomic_dtz(&ha->fwres.iocb_used, iores->iocb_cnt);\n\n\t\tif (iores->res_type & RESOURCE_EXCH)\n\t\t\tqla_atomic_dtz(&ha->fwres.exch_used, iores->exch_cnt);\n\t}\n\n\tif (iores->res_type & RESOURCE_IOCB) {\n\t\tif (qp->fwres.iocbs_used >= iores->iocb_cnt) {\n\t\t\tqp->fwres.iocbs_used -= iores->iocb_cnt;\n\t\t} else {\n\t\t\t \n\t\t\tqp->fwres.iocbs_used = 0;\n\t\t}\n\t}\n\n\tif (iores->res_type & RESOURCE_EXCH) {\n\t\tif (qp->fwres.exch_used >= iores->exch_cnt) {\n\t\t\tqp->fwres.exch_used -= iores->exch_cnt;\n\t\t} else {\n\t\t\t \n\t\t\tqp->fwres.exch_used = 0;\n\t\t}\n\t}\n\tiores->res_type = RESOURCE_NONE;\n}\n\n#define ISP_REG_DISCONNECT 0xffffffffU\n \nstatic inline\nuint32_t qla2x00_isp_reg_stat(struct qla_hw_data *ha)\n{\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\tstruct device_reg_82xx __iomem *reg82 = &ha->iobase->isp82;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn ((rd_reg_dword(&reg82->host_int)) == ISP_REG_DISCONNECT);\n\telse\n\t\treturn ((rd_reg_dword(&reg->host_status)) ==\n\t\t\tISP_REG_DISCONNECT);\n}\n\nstatic inline\nbool qla_pci_disconnected(struct scsi_qla_host *vha,\n\t\t\t  struct device_reg_24xx __iomem *reg)\n{\n\tuint32_t stat;\n\tbool ret = false;\n\n\tstat = rd_reg_dword(&reg->host_status);\n\tif (stat == 0xffffffff) {\n\t\tql_log(ql_log_info, vha, 0x8041,\n\t\t       \"detected PCI disconnect.\\n\");\n\t\tqla_schedule_eeh_work(vha);\n\t\tret = true;\n\t}\n\treturn ret;\n}\n\nstatic inline bool\nfcport_is_smaller(fc_port_t *fcport)\n{\n\tif (wwn_to_u64(fcport->port_name) <\n\t\twwn_to_u64(fcport->vha->port_name))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic inline bool\nfcport_is_bigger(fc_port_t *fcport)\n{\n\treturn !fcport_is_smaller(fcport);\n}\n\nstatic inline struct qla_qpair *\nqla_mapq_nvme_select_qpair(struct qla_hw_data *ha, struct qla_qpair *qpair)\n{\n\tint cpuid = raw_smp_processor_id();\n\n\tif (qpair->cpuid != cpuid &&\n\t    ha->qp_cpu_map[cpuid]) {\n\t\tqpair = ha->qp_cpu_map[cpuid];\n\t}\n\treturn qpair;\n}\n\nstatic inline void\nqla_mapq_init_qp_cpu_map(struct qla_hw_data *ha,\n\t\t\t struct qla_msix_entry *msix,\n\t\t\t struct qla_qpair *qpair)\n{\n\tconst struct cpumask *mask;\n\tunsigned int cpu;\n\n\tif (!ha->qp_cpu_map)\n\t\treturn;\n\tmask = pci_irq_get_affinity(ha->pdev, msix->vector_base0);\n\tif (!mask)\n\t\treturn;\n\tqpair->cpuid = cpumask_first(mask);\n\tfor_each_cpu(cpu, mask) {\n\t\tha->qp_cpu_map[cpu] = qpair;\n\t}\n\tmsix->cpuid = qpair->cpuid;\n\tqpair->cpu_mapped = true;\n}\n\nstatic inline void\nqla_mapq_free_qp_cpu_map(struct qla_hw_data *ha)\n{\n\tif (ha->qp_cpu_map) {\n\t\tkfree(ha->qp_cpu_map);\n\t\tha->qp_cpu_map = NULL;\n\t}\n}\n\nstatic inline int qla_mapq_alloc_qp_cpu_map(struct qla_hw_data *ha)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tif (!ha->qp_cpu_map) {\n\t\tha->qp_cpu_map = kcalloc(NR_CPUS, sizeof(struct qla_qpair *),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ha->qp_cpu_map) {\n\t\t\tql_log(ql_log_fatal, vha, 0x0180,\n\t\t\t       \"Unable to allocate memory for qp_cpu_map ptrs.\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}