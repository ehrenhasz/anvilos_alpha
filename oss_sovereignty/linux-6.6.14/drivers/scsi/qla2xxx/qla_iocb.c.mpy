{
  "module_name": "qla_iocb.c",
  "hash_id": "b1edefc0e8eeaa429bf601157689c7985605625a3853888560faaea373f16b1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_iocb.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_target.h\"\n\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n\n#include <scsi/scsi_tcq.h>\n\nstatic int qla_start_scsi_type6(srb_t *sp);\n \nstatic inline uint16_t\nqla2x00_get_cmd_direction(srb_t *sp)\n{\n\tuint16_t cflags;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tstruct scsi_qla_host *vha = sp->vha;\n\n\tcflags = 0;\n\n\t \n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tcflags = CF_WRITE;\n\t\tvha->qla_stats.output_bytes += scsi_bufflen(cmd);\n\t\tvha->qla_stats.output_requests++;\n\t} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tcflags = CF_READ;\n\t\tvha->qla_stats.input_bytes += scsi_bufflen(cmd);\n\t\tvha->qla_stats.input_requests++;\n\t}\n\treturn (cflags);\n}\n\n \nuint16_t\nqla2x00_calc_iocbs_32(uint16_t dsds)\n{\n\tuint16_t iocbs;\n\n\tiocbs = 1;\n\tif (dsds > 3) {\n\t\tiocbs += (dsds - 3) / 7;\n\t\tif ((dsds - 3) % 7)\n\t\t\tiocbs++;\n\t}\n\treturn (iocbs);\n}\n\n \nuint16_t\nqla2x00_calc_iocbs_64(uint16_t dsds)\n{\n\tuint16_t iocbs;\n\n\tiocbs = 1;\n\tif (dsds > 2) {\n\t\tiocbs += (dsds - 2) / 5;\n\t\tif ((dsds - 2) % 5)\n\t\t\tiocbs++;\n\t}\n\treturn (iocbs);\n}\n\n \nstatic inline cont_entry_t *\nqla2x00_prep_cont_type0_iocb(struct scsi_qla_host *vha)\n{\n\tcont_entry_t *cont_pkt;\n\tstruct req_que *req = vha->req;\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else {\n\t\treq->ring_ptr++;\n\t}\n\n\tcont_pkt = (cont_entry_t *)req->ring_ptr;\n\n\t \n\tput_unaligned_le32(CONTINUE_TYPE, &cont_pkt->entry_type);\n\n\treturn (cont_pkt);\n}\n\n \ncont_a64_entry_t *\nqla2x00_prep_cont_type1_iocb(scsi_qla_host_t *vha, struct req_que *req)\n{\n\tcont_a64_entry_t *cont_pkt;\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else {\n\t\treq->ring_ptr++;\n\t}\n\n\tcont_pkt = (cont_a64_entry_t *)req->ring_ptr;\n\n\t \n\tput_unaligned_le32(IS_QLAFX00(vha->hw) ? CONTINUE_A64_TYPE_FX00 :\n\t\t\t   CONTINUE_A64_TYPE, &cont_pkt->entry_type);\n\n\treturn (cont_pkt);\n}\n\ninline int\nqla24xx_configure_prot_mode(srb_t *sp, uint16_t *fw_prot_opts)\n{\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\n\t \n\t*fw_prot_opts = 0;\n\n\t \n\tswitch (scsi_get_prot_op(cmd)) {\n\tcase SCSI_PROT_READ_STRIP:\n\t\t*fw_prot_opts |= PO_MODE_DIF_REMOVE;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_INSERT:\n\t\t*fw_prot_opts |= PO_MODE_DIF_INSERT;\n\t\tbreak;\n\tcase SCSI_PROT_READ_INSERT:\n\t\t*fw_prot_opts |= PO_MODE_DIF_INSERT;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_STRIP:\n\t\t*fw_prot_opts |= PO_MODE_DIF_REMOVE;\n\t\tbreak;\n\tcase SCSI_PROT_READ_PASS:\n\tcase SCSI_PROT_WRITE_PASS:\n\t\tif (cmd->prot_flags & SCSI_PROT_IP_CHECKSUM)\n\t\t\t*fw_prot_opts |= PO_MODE_DIF_TCP_CKSUM;\n\t\telse\n\t\t\t*fw_prot_opts |= PO_MODE_DIF_PASS;\n\t\tbreak;\n\tdefault:\t \n\t\t*fw_prot_opts |= PO_MODE_DIF_PASS;\n\t\tbreak;\n\t}\n\n\tif (!(cmd->prot_flags & SCSI_PROT_GUARD_CHECK))\n\t\t*fw_prot_opts |= PO_DISABLE_GUARD_CHECK;\n\n\treturn scsi_prot_sg_count(cmd);\n}\n\n \nvoid qla2x00_build_scsi_iocbs_32(srb_t *sp, cmd_entry_t *cmd_pkt,\n    uint16_t tot_dsds)\n{\n\tuint16_t\tavail_dsds;\n\tstruct dsd32\t*cur_dsd;\n\tscsi_qla_host_t\t*vha;\n\tstruct scsi_cmnd *cmd;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tcmd = GET_CMD_SP(sp);\n\n\t \n\tput_unaligned_le32(COMMAND_TYPE, &cmd_pkt->entry_type);\n\n\t \n\tif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\n\t\tcmd_pkt->byte_count = cpu_to_le32(0);\n\t\treturn;\n\t}\n\n\tvha = sp->vha;\n\tcmd_pkt->control_flags |= cpu_to_le16(qla2x00_get_cmd_direction(sp));\n\n\t \n\tavail_dsds = ARRAY_SIZE(cmd_pkt->dsd32);\n\tcur_dsd = cmd_pkt->dsd32;\n\n\t \n\tscsi_for_each_sg(cmd, sg, tot_dsds, i) {\n\t\tcont_entry_t *cont_pkt;\n\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type0_iocb(vha);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = ARRAY_SIZE(cont_pkt->dsd);\n\t\t}\n\n\t\tappend_dsd32(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n}\n\n \nvoid qla2x00_build_scsi_iocbs_64(srb_t *sp, cmd_entry_t *cmd_pkt,\n    uint16_t tot_dsds)\n{\n\tuint16_t\tavail_dsds;\n\tstruct dsd64\t*cur_dsd;\n\tscsi_qla_host_t\t*vha;\n\tstruct scsi_cmnd *cmd;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tcmd = GET_CMD_SP(sp);\n\n\t \n\tput_unaligned_le32(COMMAND_A64_TYPE, &cmd_pkt->entry_type);\n\n\t \n\tif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\n\t\tcmd_pkt->byte_count = cpu_to_le32(0);\n\t\treturn;\n\t}\n\n\tvha = sp->vha;\n\tcmd_pkt->control_flags |= cpu_to_le16(qla2x00_get_cmd_direction(sp));\n\n\t \n\tavail_dsds = ARRAY_SIZE(cmd_pkt->dsd64);\n\tcur_dsd = cmd_pkt->dsd64;\n\n\t \n\tscsi_for_each_sg(cmd, sg, tot_dsds, i) {\n\t\tcont_a64_entry_t *cont_pkt;\n\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = ARRAY_SIZE(cont_pkt->dsd);\n\t\t}\n\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n}\n\n \nuint32_t qla2xxx_get_next_handle(struct req_que *req)\n{\n\tuint32_t index, handle = req->current_outstanding_cmd;\n\n\tfor (index = 1; index < req->num_outstanding_cmds; index++) {\n\t\thandle++;\n\t\tif (handle == req->num_outstanding_cmds)\n\t\t\thandle = 1;\n\t\tif (!req->outstanding_cmds[handle])\n\t\t\treturn handle;\n\t}\n\n\treturn 0;\n}\n\n \nint\nqla2x00_start_scsi(srb_t *sp)\n{\n\tint\t\tnseg;\n\tunsigned long   flags;\n\tscsi_qla_host_t\t*vha;\n\tstruct scsi_cmnd *cmd;\n\tuint32_t\t*clr_ptr;\n\tuint32_t\thandle;\n\tcmd_entry_t\t*cmd_pkt;\n\tuint16_t\tcnt;\n\tuint16_t\treq_cnt;\n\tuint16_t\ttot_dsds;\n\tstruct device_reg_2xxx __iomem *reg;\n\tstruct qla_hw_data *ha;\n\tstruct req_que *req;\n\tstruct rsp_que *rsp;\n\n\t \n\tvha = sp->vha;\n\tha = vha->hw;\n\treg = &ha->iobase->isp;\n\tcmd = GET_CMD_SP(sp);\n\treq = ha->req_q_map[0];\n\trsp = ha->rsp_q_map[0];\n\t \n\ttot_dsds = 0;\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (qla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL) !=\n\t\t    QLA_SUCCESS) {\n\t\t\treturn (QLA_FUNCTION_FAILED);\n\t\t}\n\t\tvha->marker_needed = 0;\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0)\n\t\tgoto queuing_error;\n\n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t    scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t} else\n\t\tnseg = 0;\n\n\ttot_dsds = nseg;\n\n\t \n\treq_cnt = ha->isp_ops->calc_req_entries(tot_dsds);\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tcnt = rd_reg_word_relaxed(ISP_REQ_Q_OUT(ha, reg));\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t    (req->ring_index - cnt);\n\t\t \n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\t}\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\n\tcmd_pkt = (cmd_entry_t *)req->ring_ptr;\n\tcmd_pkt->handle = handle;\n\t \n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t \n\tSET_TARGET_ID(ha, cmd_pkt->target, sp->fcport->loop_id);\n\tcmd_pkt->lun = cpu_to_le16(cmd->device->lun);\n\tcmd_pkt->control_flags = cpu_to_le16(CF_SIMPLE_TAG);\n\n\t \n\tmemcpy(cmd_pkt->scsi_cdb, cmd->cmnd, cmd->cmd_len);\n\tcmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\n\n\t \n\tha->isp_ops->build_iocbs(sp, cmd_pkt, tot_dsds);\n\n\t \n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\twmb();\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\tsp->flags |= SRB_DMA_VALID;\n\n\t \n\twrt_reg_word(ISP_REQ_Q_IN(ha, reg), req->ring_index);\n\trd_reg_word_relaxed(ISP_REQ_Q_IN(ha, reg));\t \n\n\t \n\tif (vha->flags.process_response_queue &&\n\t    rsp->ring_ptr->signature != RESPONSE_PROCESSED)\n\t\tqla2x00_process_response_queue(rsp);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn (QLA_SUCCESS);\n\nqueuing_error:\n\tif (tot_dsds)\n\t\tscsi_dma_unmap(cmd);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn (QLA_FUNCTION_FAILED);\n}\n\n \nvoid\nqla2x00_start_iocbs(struct scsi_qla_host *vha, struct req_que *req)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tdevice_reg_t *reg = ISP_QUE_REG(ha, req->id);\n\n\tif (IS_P3P_TYPE(ha)) {\n\t\tqla82xx_start_iocbs(vha);\n\t} else {\n\t\t \n\t\treq->ring_index++;\n\t\tif (req->ring_index == req->length) {\n\t\t\treq->ring_index = 0;\n\t\t\treq->ring_ptr = req->ring;\n\t\t} else\n\t\t\treq->ring_ptr++;\n\n\t\t \n\t\tif (ha->mqenable || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\twrt_reg_dword(req->req_q_in, req->ring_index);\n\t\t} else if (IS_QLA83XX(ha)) {\n\t\t\twrt_reg_dword(req->req_q_in, req->ring_index);\n\t\t\trd_reg_dword_relaxed(&ha->iobase->isp24.hccr);\n\t\t} else if (IS_QLAFX00(ha)) {\n\t\t\twrt_reg_dword(&reg->ispfx00.req_q_in, req->ring_index);\n\t\t\trd_reg_dword_relaxed(&reg->ispfx00.req_q_in);\n\t\t\tQLAFX00_SET_HST_INTR(ha, ha->rqstq_intr_code);\n\t\t} else if (IS_FWI2_CAPABLE(ha)) {\n\t\t\twrt_reg_dword(&reg->isp24.req_q_in, req->ring_index);\n\t\t\trd_reg_dword_relaxed(&reg->isp24.req_q_in);\n\t\t} else {\n\t\t\twrt_reg_word(ISP_REQ_Q_IN(ha, &reg->isp),\n\t\t\t\treq->ring_index);\n\t\t\trd_reg_word_relaxed(ISP_REQ_Q_IN(ha, &reg->isp));\n\t\t}\n\t}\n}\n\n \nstatic int\n__qla2x00_marker(struct scsi_qla_host *vha, struct qla_qpair *qpair,\n    uint16_t loop_id, uint64_t lun, uint8_t type)\n{\n\tmrk_entry_t *mrk;\n\tstruct mrk_entry_24xx *mrk24 = NULL;\n\tstruct req_que *req = qpair->req;\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\tmrk = (mrk_entry_t *)__qla2x00_alloc_iocbs(qpair, NULL);\n\tif (mrk == NULL) {\n\t\tql_log(ql_log_warn, base_vha, 0x3026,\n\t\t    \"Failed to allocate Marker IOCB.\\n\");\n\n\t\treturn (QLA_FUNCTION_FAILED);\n\t}\n\n\tmrk24 = (struct mrk_entry_24xx *)mrk;\n\n\tmrk->entry_type = MARKER_TYPE;\n\tmrk->modifier = type;\n\tif (type != MK_SYNC_ALL) {\n\t\tif (IS_FWI2_CAPABLE(ha)) {\n\t\t\tmrk24->nport_handle = cpu_to_le16(loop_id);\n\t\t\tint_to_scsilun(lun, (struct scsi_lun *)&mrk24->lun);\n\t\t\thost_to_fcp_swap(mrk24->lun, sizeof(mrk24->lun));\n\t\t\tmrk24->vp_index = vha->vp_idx;\n\t\t} else {\n\t\t\tSET_TARGET_ID(ha, mrk->target, loop_id);\n\t\t\tmrk->lun = cpu_to_le16((uint16_t)lun);\n\t\t}\n\t}\n\n\tif (IS_FWI2_CAPABLE(ha))\n\t\tmrk24->handle = QLA_SKIP_HANDLE;\n\n\twmb();\n\n\tqla2x00_start_iocbs(vha, req);\n\n\treturn (QLA_SUCCESS);\n}\n\nint\nqla2x00_marker(struct scsi_qla_host *vha, struct qla_qpair *qpair,\n    uint16_t loop_id, uint64_t lun, uint8_t type)\n{\n\tint ret;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tret = __qla2x00_marker(vha, qpair, loop_id, lun, type);\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\treturn (ret);\n}\n\n \nint qla2x00_issue_marker(scsi_qla_host_t *vha, int ha_locked)\n{\n\tif (ha_locked) {\n\t\tif (__qla2x00_marker(vha, vha->hw->base_qpair, 0, 0,\n\t\t\t\t\tMK_SYNC_ALL) != QLA_SUCCESS)\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t} else {\n\t\tif (qla2x00_marker(vha, vha->hw->base_qpair, 0, 0,\n\t\t\t\t\tMK_SYNC_ALL) != QLA_SUCCESS)\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\tvha->marker_needed = 0;\n\n\treturn QLA_SUCCESS;\n}\n\nstatic inline int\nqla24xx_build_scsi_type_6_iocbs(srb_t *sp, struct cmd_type_6 *cmd_pkt,\n\tuint16_t tot_dsds)\n{\n\tstruct dsd64 *cur_dsd = NULL, *next_dsd;\n\tstruct scsi_cmnd *cmd;\n\tstruct\tscatterlist *cur_seg;\n\tuint8_t avail_dsds;\n\tuint8_t first_iocb = 1;\n\tuint32_t dsd_list_len;\n\tstruct dsd_dma *dsd_ptr;\n\tstruct ct6_dsd *ctx;\n\tstruct qla_qpair *qpair = sp->qpair;\n\n\tcmd = GET_CMD_SP(sp);\n\n\t \n\tput_unaligned_le32(COMMAND_TYPE_6, &cmd_pkt->entry_type);\n\n\t \n\tif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE ||\n\t    tot_dsds == 0) {\n\t\tcmd_pkt->byte_count = cpu_to_le32(0);\n\t\treturn 0;\n\t}\n\n\t \n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tcmd_pkt->control_flags = cpu_to_le16(CF_WRITE_DATA);\n\t\tqpair->counters.output_bytes += scsi_bufflen(cmd);\n\t\tqpair->counters.output_requests++;\n\t} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tcmd_pkt->control_flags = cpu_to_le16(CF_READ_DATA);\n\t\tqpair->counters.input_bytes += scsi_bufflen(cmd);\n\t\tqpair->counters.input_requests++;\n\t}\n\n\tcur_seg = scsi_sglist(cmd);\n\tctx = &sp->u.scmd.ct6_ctx;\n\n\twhile (tot_dsds) {\n\t\tavail_dsds = (tot_dsds > QLA_DSDS_PER_IOCB) ?\n\t\t    QLA_DSDS_PER_IOCB : tot_dsds;\n\t\ttot_dsds -= avail_dsds;\n\t\tdsd_list_len = (avail_dsds + 1) * QLA_DSD_SIZE;\n\n\t\tdsd_ptr = list_first_entry(&qpair->dsd_list, struct dsd_dma, list);\n\t\tnext_dsd = dsd_ptr->dsd_addr;\n\t\tlist_del(&dsd_ptr->list);\n\t\tqpair->dsd_avail--;\n\t\tlist_add_tail(&dsd_ptr->list, &ctx->dsd_list);\n\t\tctx->dsd_use_cnt++;\n\t\tqpair->dsd_inuse++;\n\n\t\tif (first_iocb) {\n\t\t\tfirst_iocb = 0;\n\t\t\tput_unaligned_le64(dsd_ptr->dsd_list_dma,\n\t\t\t\t\t   &cmd_pkt->fcp_dsd.address);\n\t\t\tcmd_pkt->fcp_dsd.length = cpu_to_le32(dsd_list_len);\n\t\t} else {\n\t\t\tput_unaligned_le64(dsd_ptr->dsd_list_dma,\n\t\t\t\t\t   &cur_dsd->address);\n\t\t\tcur_dsd->length = cpu_to_le32(dsd_list_len);\n\t\t\tcur_dsd++;\n\t\t}\n\t\tcur_dsd = next_dsd;\n\t\twhile (avail_dsds) {\n\t\t\tappend_dsd64(&cur_dsd, cur_seg);\n\t\t\tcur_seg = sg_next(cur_seg);\n\t\t\tavail_dsds--;\n\t\t}\n\t}\n\n\t \n\tcur_dsd->address = 0;\n\tcur_dsd->length = 0;\n\tcur_dsd++;\n\tcmd_pkt->control_flags |= cpu_to_le16(CF_DATA_SEG_DESCR_ENABLE);\n\treturn 0;\n}\n\n \nstatic inline uint16_t\nqla24xx_calc_dsd_lists(uint16_t dsds)\n{\n\tuint16_t dsd_lists = 0;\n\n\tdsd_lists = (dsds/QLA_DSDS_PER_IOCB);\n\tif (dsds % QLA_DSDS_PER_IOCB)\n\t\tdsd_lists++;\n\treturn dsd_lists;\n}\n\n\n \ninline void\nqla24xx_build_scsi_iocbs(srb_t *sp, struct cmd_type_7 *cmd_pkt,\n\tuint16_t tot_dsds, struct req_que *req)\n{\n\tuint16_t\tavail_dsds;\n\tstruct dsd64\t*cur_dsd;\n\tscsi_qla_host_t\t*vha;\n\tstruct scsi_cmnd *cmd;\n\tstruct scatterlist *sg;\n\tint i;\n\tstruct qla_qpair *qpair = sp->qpair;\n\n\tcmd = GET_CMD_SP(sp);\n\n\t \n\tput_unaligned_le32(COMMAND_TYPE_7, &cmd_pkt->entry_type);\n\n\t \n\tif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\n\t\tcmd_pkt->byte_count = cpu_to_le32(0);\n\t\treturn;\n\t}\n\n\tvha = sp->vha;\n\n\t \n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tcmd_pkt->task_mgmt_flags = cpu_to_le16(TMF_WRITE_DATA);\n\t\tqpair->counters.output_bytes += scsi_bufflen(cmd);\n\t\tqpair->counters.output_requests++;\n\t} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tcmd_pkt->task_mgmt_flags = cpu_to_le16(TMF_READ_DATA);\n\t\tqpair->counters.input_bytes += scsi_bufflen(cmd);\n\t\tqpair->counters.input_requests++;\n\t}\n\n\t \n\tavail_dsds = 1;\n\tcur_dsd = &cmd_pkt->dsd;\n\n\t \n\n\tscsi_for_each_sg(cmd, sg, tot_dsds, i) {\n\t\tcont_a64_entry_t *cont_pkt;\n\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type1_iocb(vha, req);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = ARRAY_SIZE(cont_pkt->dsd);\n\t\t}\n\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n}\n\nstruct fw_dif_context {\n\t__le32\tref_tag;\n\t__le16\tapp_tag;\n\tuint8_t ref_tag_mask[4];\t \n\tuint8_t app_tag_mask[2];\t \n};\n\n \nstatic inline void\nqla24xx_set_t10dif_tags(srb_t *sp, struct fw_dif_context *pkt,\n    unsigned int protcnt)\n{\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\n\tpkt->ref_tag = cpu_to_le32(scsi_prot_ref_tag(cmd));\n\n\tif (cmd->prot_flags & SCSI_PROT_REF_CHECK &&\n\t    qla2x00_hba_err_chk_enabled(sp)) {\n\t\tpkt->ref_tag_mask[0] = 0xff;\n\t\tpkt->ref_tag_mask[1] = 0xff;\n\t\tpkt->ref_tag_mask[2] = 0xff;\n\t\tpkt->ref_tag_mask[3] = 0xff;\n\t}\n\n\tpkt->app_tag = cpu_to_le16(0);\n\tpkt->app_tag_mask[0] = 0x0;\n\tpkt->app_tag_mask[1] = 0x0;\n}\n\nint\nqla24xx_get_one_block_sg(uint32_t blk_sz, struct qla2_sgx *sgx,\n\tuint32_t *partial)\n{\n\tstruct scatterlist *sg;\n\tuint32_t cumulative_partial, sg_len;\n\tdma_addr_t sg_dma_addr;\n\n\tif (sgx->num_bytes == sgx->tot_bytes)\n\t\treturn 0;\n\n\tsg = sgx->cur_sg;\n\tcumulative_partial = sgx->tot_partial;\n\n\tsg_dma_addr = sg_dma_address(sg);\n\tsg_len = sg_dma_len(sg);\n\n\tsgx->dma_addr = sg_dma_addr + sgx->bytes_consumed;\n\n\tif ((cumulative_partial + (sg_len - sgx->bytes_consumed)) >= blk_sz) {\n\t\tsgx->dma_len = (blk_sz - cumulative_partial);\n\t\tsgx->tot_partial = 0;\n\t\tsgx->num_bytes += blk_sz;\n\t\t*partial = 0;\n\t} else {\n\t\tsgx->dma_len = sg_len - sgx->bytes_consumed;\n\t\tsgx->tot_partial += sgx->dma_len;\n\t\t*partial = 1;\n\t}\n\n\tsgx->bytes_consumed += sgx->dma_len;\n\n\tif (sg_len == sgx->bytes_consumed) {\n\t\tsg = sg_next(sg);\n\t\tsgx->num_sg++;\n\t\tsgx->cur_sg = sg;\n\t\tsgx->bytes_consumed = 0;\n\t}\n\n\treturn 1;\n}\n\nint\nqla24xx_walk_and_build_sglist_no_difb(struct qla_hw_data *ha, srb_t *sp,\n\tstruct dsd64 *dsd, uint16_t tot_dsds, struct qla_tc_param *tc)\n{\n\tvoid *next_dsd;\n\tuint8_t avail_dsds = 0;\n\tuint32_t dsd_list_len;\n\tstruct dsd_dma *dsd_ptr;\n\tstruct scatterlist *sg_prot;\n\tstruct dsd64 *cur_dsd = dsd;\n\tuint16_t\tused_dsds = tot_dsds;\n\tuint32_t\tprot_int;  \n\tuint32_t\tpartial;\n\tstruct qla2_sgx sgx;\n\tdma_addr_t\tsle_dma;\n\tuint32_t\tsle_dma_len, tot_prot_dma_len = 0;\n\tstruct scsi_cmnd *cmd;\n\n\tmemset(&sgx, 0, sizeof(struct qla2_sgx));\n\tif (sp) {\n\t\tcmd = GET_CMD_SP(sp);\n\t\tprot_int = scsi_prot_interval(cmd);\n\n\t\tsgx.tot_bytes = scsi_bufflen(cmd);\n\t\tsgx.cur_sg = scsi_sglist(cmd);\n\t\tsgx.sp = sp;\n\n\t\tsg_prot = scsi_prot_sglist(cmd);\n\t} else if (tc) {\n\t\tprot_int      = tc->blk_sz;\n\t\tsgx.tot_bytes = tc->bufflen;\n\t\tsgx.cur_sg    = tc->sg;\n\t\tsg_prot\t      = tc->prot_sg;\n\t} else {\n\t\tBUG();\n\t\treturn 1;\n\t}\n\n\twhile (qla24xx_get_one_block_sg(prot_int, &sgx, &partial)) {\n\n\t\tsle_dma = sgx.dma_addr;\n\t\tsle_dma_len = sgx.dma_len;\nalloc_and_fill:\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\tavail_dsds = (used_dsds > QLA_DSDS_PER_IOCB) ?\n\t\t\t\t\tQLA_DSDS_PER_IOCB : used_dsds;\n\t\t\tdsd_list_len = (avail_dsds + 1) * 12;\n\t\t\tused_dsds -= avail_dsds;\n\n\t\t\t \n\t\t\tdsd_ptr = kzalloc(sizeof(struct dsd_dma), GFP_ATOMIC);\n\t\t\tif (!dsd_ptr)\n\t\t\t\treturn 1;\n\n\t\t\t \n\t\t\tdsd_ptr->dsd_addr = next_dsd =\n\t\t\t    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC,\n\t\t\t\t&dsd_ptr->dsd_list_dma);\n\n\t\t\tif (!next_dsd) {\n\t\t\t\t \n\t\t\t\tkfree(dsd_ptr);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (sp) {\n\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t\t      &sp->u.scmd.crc_ctx->dsd_list);\n\n\t\t\t\tsp->flags |= SRB_CRC_CTX_DSD_VALID;\n\t\t\t} else {\n\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t    &(tc->ctx->dsd_list));\n\t\t\t\t*tc->ctx_dsd_alloced = 1;\n\t\t\t}\n\n\n\t\t\t \n\t\t\tput_unaligned_le64(dsd_ptr->dsd_list_dma,\n\t\t\t\t\t   &cur_dsd->address);\n\t\t\tcur_dsd->length = cpu_to_le32(dsd_list_len);\n\t\t\tcur_dsd = next_dsd;\n\t\t}\n\t\tput_unaligned_le64(sle_dma, &cur_dsd->address);\n\t\tcur_dsd->length = cpu_to_le32(sle_dma_len);\n\t\tcur_dsd++;\n\t\tavail_dsds--;\n\n\t\tif (partial == 0) {\n\t\t\t \n\t\t\tsle_dma = sg_dma_address(sg_prot) + tot_prot_dma_len;\n\t\t\tsle_dma_len = 8;\n\n\t\t\ttot_prot_dma_len += sle_dma_len;\n\t\t\tif (tot_prot_dma_len == sg_dma_len(sg_prot)) {\n\t\t\t\ttot_prot_dma_len = 0;\n\t\t\t\tsg_prot = sg_next(sg_prot);\n\t\t\t}\n\n\t\t\tpartial = 1;  \n\t\t\tgoto alloc_and_fill;\n\t\t}\n\t}\n\t \n\tcur_dsd->address = 0;\n\tcur_dsd->length = 0;\n\tcur_dsd++;\n\treturn 0;\n}\n\nint\nqla24xx_walk_and_build_sglist(struct qla_hw_data *ha, srb_t *sp,\n\tstruct dsd64 *dsd, uint16_t tot_dsds, struct qla_tc_param *tc)\n{\n\tvoid *next_dsd;\n\tuint8_t avail_dsds = 0;\n\tuint32_t dsd_list_len;\n\tstruct dsd_dma *dsd_ptr;\n\tstruct scatterlist *sg, *sgl;\n\tstruct dsd64 *cur_dsd = dsd;\n\tint\ti;\n\tuint16_t\tused_dsds = tot_dsds;\n\tstruct scsi_cmnd *cmd;\n\n\tif (sp) {\n\t\tcmd = GET_CMD_SP(sp);\n\t\tsgl = scsi_sglist(cmd);\n\t} else if (tc) {\n\t\tsgl = tc->sg;\n\t} else {\n\t\tBUG();\n\t\treturn 1;\n\t}\n\n\n\tfor_each_sg(sgl, sg, tot_dsds, i) {\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\tavail_dsds = (used_dsds > QLA_DSDS_PER_IOCB) ?\n\t\t\t\t\tQLA_DSDS_PER_IOCB : used_dsds;\n\t\t\tdsd_list_len = (avail_dsds + 1) * 12;\n\t\t\tused_dsds -= avail_dsds;\n\n\t\t\t \n\t\t\tdsd_ptr = kzalloc(sizeof(struct dsd_dma), GFP_ATOMIC);\n\t\t\tif (!dsd_ptr)\n\t\t\t\treturn 1;\n\n\t\t\t \n\t\t\tdsd_ptr->dsd_addr = next_dsd =\n\t\t\t    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC,\n\t\t\t\t&dsd_ptr->dsd_list_dma);\n\n\t\t\tif (!next_dsd) {\n\t\t\t\t \n\t\t\t\tkfree(dsd_ptr);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (sp) {\n\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t\t      &sp->u.scmd.crc_ctx->dsd_list);\n\n\t\t\t\tsp->flags |= SRB_CRC_CTX_DSD_VALID;\n\t\t\t} else {\n\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t    &(tc->ctx->dsd_list));\n\t\t\t\t*tc->ctx_dsd_alloced = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tput_unaligned_le64(dsd_ptr->dsd_list_dma,\n\t\t\t\t\t   &cur_dsd->address);\n\t\t\tcur_dsd->length = cpu_to_le32(dsd_list_len);\n\t\t\tcur_dsd = next_dsd;\n\t\t}\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\n\t}\n\t \n\tcur_dsd->address = 0;\n\tcur_dsd->length = 0;\n\tcur_dsd++;\n\treturn 0;\n}\n\nint\nqla24xx_walk_and_build_prot_sglist(struct qla_hw_data *ha, srb_t *sp,\n\tstruct dsd64 *cur_dsd, uint16_t tot_dsds, struct qla_tgt_cmd *tc)\n{\n\tstruct dsd_dma *dsd_ptr = NULL, *dif_dsd, *nxt_dsd;\n\tstruct scatterlist *sg, *sgl;\n\tstruct crc_context *difctx = NULL;\n\tstruct scsi_qla_host *vha;\n\tuint dsd_list_len;\n\tuint avail_dsds = 0;\n\tuint used_dsds = tot_dsds;\n\tbool dif_local_dma_alloc = false;\n\tbool direction_to_device = false;\n\tint i;\n\n\tif (sp) {\n\t\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\n\t\tsgl = scsi_prot_sglist(cmd);\n\t\tvha = sp->vha;\n\t\tdifctx = sp->u.scmd.crc_ctx;\n\t\tdirection_to_device = cmd->sc_data_direction == DMA_TO_DEVICE;\n\t\tql_dbg(ql_dbg_tgt + ql_dbg_verbose, vha, 0xe021,\n\t\t  \"%s: scsi_cmnd: %p, crc_ctx: %p, sp: %p\\n\",\n\t\t\t__func__, cmd, difctx, sp);\n\t} else if (tc) {\n\t\tvha = tc->vha;\n\t\tsgl = tc->prot_sg;\n\t\tdifctx = tc->ctx;\n\t\tdirection_to_device = tc->dma_data_direction == DMA_TO_DEVICE;\n\t} else {\n\t\tBUG();\n\t\treturn 1;\n\t}\n\n\tql_dbg(ql_dbg_tgt + ql_dbg_verbose, vha, 0xe021,\n\t    \"%s: enter (write=%u)\\n\", __func__, direction_to_device);\n\n\t \n\tif (direction_to_device) {\n\t\tfor_each_sg(sgl, sg, tot_dsds, i) {\n\t\t\tu64 sle_phys = sg_phys(sg);\n\n\t\t\t \n\t\t\tif (MSD(sle_phys + sg->length) ^ MSD(sle_phys)) {\n\t\t\t\tql_dbg(ql_dbg_tgt + ql_dbg_verbose, vha, 0xe022,\n\t\t\t\t    \"%s: page boundary crossing (phys=%llx len=%x)\\n\",\n\t\t\t\t    __func__, sle_phys, sg->length);\n\n\t\t\t\tif (difctx) {\n\t\t\t\t\tha->dif_bundle_crossed_pages++;\n\t\t\t\t\tdif_local_dma_alloc = true;\n\t\t\t\t} else {\n\t\t\t\t\tql_dbg(ql_dbg_tgt + ql_dbg_verbose,\n\t\t\t\t\t    vha, 0xe022,\n\t\t\t\t\t    \"%s: difctx pointer is NULL\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tha->dif_bundle_writes++;\n\t} else {\n\t\tha->dif_bundle_reads++;\n\t}\n\n\tif (ql2xdifbundlinginternalbuffers)\n\t\tdif_local_dma_alloc = direction_to_device;\n\n\tif (dif_local_dma_alloc) {\n\t\tu32 track_difbundl_buf = 0;\n\t\tu32 ldma_sg_len = 0;\n\t\tu8 ldma_needed = 1;\n\n\t\tdifctx->no_dif_bundl = 0;\n\t\tdifctx->dif_bundl_len = 0;\n\n\t\t \n\t\tINIT_LIST_HEAD(&difctx->ldif_dsd_list);\n\t\t \n\t\tINIT_LIST_HEAD(&difctx->ldif_dma_hndl_list);\n\n\t\tfor_each_sg(sgl, sg, tot_dsds, i) {\n\t\t\tu32 sglen = sg_dma_len(sg);\n\n\t\t\tql_dbg(ql_dbg_tgt + ql_dbg_verbose, vha, 0xe023,\n\t\t\t    \"%s: sg[%x] (phys=%llx sglen=%x) ldma_sg_len: %x dif_bundl_len: %x ldma_needed: %x\\n\",\n\t\t\t    __func__, i, (u64)sg_phys(sg), sglen, ldma_sg_len,\n\t\t\t    difctx->dif_bundl_len, ldma_needed);\n\n\t\t\twhile (sglen) {\n\t\t\t\tu32 xfrlen = 0;\n\n\t\t\t\tif (ldma_needed) {\n\t\t\t\t\t \n\t\t\t\t\tdsd_ptr = kzalloc(sizeof(*dsd_ptr),\n\t\t\t\t\t    GFP_ATOMIC);\n\t\t\t\t\tif (!dsd_ptr) {\n\t\t\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe024,\n\t\t\t\t\t\t    \"%s: failed alloc dsd_ptr\\n\",\n\t\t\t\t\t\t    __func__);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tha->dif_bundle_kallocs++;\n\n\t\t\t\t\t \n\t\t\t\t\tdsd_ptr->dsd_addr = dma_pool_alloc\n\t\t\t\t\t\t(ha->dif_bundl_pool, GFP_ATOMIC,\n\t\t\t\t\t\t &dsd_ptr->dsd_list_dma);\n\t\t\t\t\tif (!dsd_ptr->dsd_addr) {\n\t\t\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe024,\n\t\t\t\t\t\t    \"%s: failed alloc ->dsd_ptr\\n\",\n\t\t\t\t\t\t    __func__);\n\t\t\t\t\t\t \n\t\t\t\t\t\tkfree(dsd_ptr);\n\t\t\t\t\t\tha->dif_bundle_kallocs--;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tha->dif_bundle_dma_allocs++;\n\t\t\t\t\tldma_needed = 0;\n\t\t\t\t\tdifctx->no_dif_bundl++;\n\t\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t\t    &difctx->ldif_dma_hndl_list);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\txfrlen = (sglen >\n\t\t\t\t   (DIF_BUNDLING_DMA_POOL_SIZE - ldma_sg_len)) ?\n\t\t\t\t    DIF_BUNDLING_DMA_POOL_SIZE - ldma_sg_len :\n\t\t\t\t    sglen;\n\n\t\t\t\t \n\t\t\t\tsg_pcopy_to_buffer(sgl, sg_nents(sgl),\n\t\t\t\t    dsd_ptr->dsd_addr + ldma_sg_len, xfrlen,\n\t\t\t\t    difctx->dif_bundl_len);\n\t\t\t\tdifctx->dif_bundl_len += xfrlen;\n\t\t\t\tsglen -= xfrlen;\n\t\t\t\tldma_sg_len += xfrlen;\n\t\t\t\tif (ldma_sg_len == DIF_BUNDLING_DMA_POOL_SIZE ||\n\t\t\t\t    sg_is_last(sg)) {\n\t\t\t\t\tldma_needed = 1;\n\t\t\t\t\tldma_sg_len = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttrack_difbundl_buf = used_dsds = difctx->no_dif_bundl;\n\t\tql_dbg(ql_dbg_tgt + ql_dbg_verbose, vha, 0xe025,\n\t\t    \"dif_bundl_len=%x, no_dif_bundl=%x track_difbundl_buf: %x\\n\",\n\t\t    difctx->dif_bundl_len, difctx->no_dif_bundl,\n\t\t    track_difbundl_buf);\n\n\t\tif (sp)\n\t\t\tsp->flags |= SRB_DIF_BUNDL_DMA_VALID;\n\t\telse\n\t\t\ttc->prot_flags = DIF_BUNDL_DMA_VALID;\n\n\t\tlist_for_each_entry_safe(dif_dsd, nxt_dsd,\n\t\t    &difctx->ldif_dma_hndl_list, list) {\n\t\t\tu32 sglen = (difctx->dif_bundl_len >\n\t\t\t    DIF_BUNDLING_DMA_POOL_SIZE) ?\n\t\t\t    DIF_BUNDLING_DMA_POOL_SIZE : difctx->dif_bundl_len;\n\n\t\t\tBUG_ON(track_difbundl_buf == 0);\n\n\t\t\t \n\t\t\tif (avail_dsds == 0) {\n\t\t\t\tql_dbg(ql_dbg_tgt + ql_dbg_verbose, vha,\n\t\t\t\t    0xe024,\n\t\t\t\t    \"%s: adding continuation iocb's\\n\",\n\t\t\t\t    __func__);\n\t\t\t\tavail_dsds = (used_dsds > QLA_DSDS_PER_IOCB) ?\n\t\t\t\t    QLA_DSDS_PER_IOCB : used_dsds;\n\t\t\t\tdsd_list_len = (avail_dsds + 1) * 12;\n\t\t\t\tused_dsds -= avail_dsds;\n\n\t\t\t\t \n\t\t\t\tdsd_ptr = kzalloc(sizeof(*dsd_ptr), GFP_ATOMIC);\n\t\t\t\tif (!dsd_ptr) {\n\t\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe026,\n\t\t\t\t\t    \"%s: failed alloc dsd_ptr\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tha->dif_bundle_kallocs++;\n\n\t\t\t\tdifctx->no_ldif_dsd++;\n\t\t\t\t \n\t\t\t\tdsd_ptr->dsd_addr =\n\t\t\t\t    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC,\n\t\t\t\t\t&dsd_ptr->dsd_list_dma);\n\t\t\t\tif (!dsd_ptr->dsd_addr) {\n\t\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe026,\n\t\t\t\t\t    \"%s: failed alloc ->dsd_addr\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\t \n\t\t\t\t\tkfree(dsd_ptr);\n\t\t\t\t\tha->dif_bundle_kallocs--;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tha->dif_bundle_dma_allocs++;\n\n\t\t\t\tif (sp) {\n\t\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t\t    &difctx->ldif_dsd_list);\n\t\t\t\t\tsp->flags |= SRB_CRC_CTX_DSD_VALID;\n\t\t\t\t} else {\n\t\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t\t    &difctx->ldif_dsd_list);\n\t\t\t\t\ttc->ctx_dsd_alloced = 1;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tput_unaligned_le64(dsd_ptr->dsd_list_dma,\n\t\t\t\t\t\t   &cur_dsd->address);\n\t\t\t\tcur_dsd->length = cpu_to_le32(dsd_list_len);\n\t\t\t\tcur_dsd = dsd_ptr->dsd_addr;\n\t\t\t}\n\t\t\tput_unaligned_le64(dif_dsd->dsd_list_dma,\n\t\t\t\t\t   &cur_dsd->address);\n\t\t\tcur_dsd->length = cpu_to_le32(sglen);\n\t\t\tcur_dsd++;\n\t\t\tavail_dsds--;\n\t\t\tdifctx->dif_bundl_len -= sglen;\n\t\t\ttrack_difbundl_buf--;\n\t\t}\n\n\t\tql_dbg(ql_dbg_tgt + ql_dbg_verbose, vha, 0xe026,\n\t\t    \"%s: no_ldif_dsd:%x, no_dif_bundl:%x\\n\", __func__,\n\t\t\tdifctx->no_ldif_dsd, difctx->no_dif_bundl);\n\t} else {\n\t\tfor_each_sg(sgl, sg, tot_dsds, i) {\n\t\t\t \n\t\t\tif (avail_dsds == 0) {\n\t\t\t\tavail_dsds = (used_dsds > QLA_DSDS_PER_IOCB) ?\n\t\t\t\t    QLA_DSDS_PER_IOCB : used_dsds;\n\t\t\t\tdsd_list_len = (avail_dsds + 1) * 12;\n\t\t\t\tused_dsds -= avail_dsds;\n\n\t\t\t\t \n\t\t\t\tdsd_ptr = kzalloc(sizeof(*dsd_ptr), GFP_ATOMIC);\n\t\t\t\tif (!dsd_ptr) {\n\t\t\t\t\tql_dbg(ql_dbg_tgt + ql_dbg_verbose,\n\t\t\t\t\t    vha, 0xe027,\n\t\t\t\t\t    \"%s: failed alloc dsd_dma...\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tdsd_ptr->dsd_addr =\n\t\t\t\t    dma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC,\n\t\t\t\t\t&dsd_ptr->dsd_list_dma);\n\t\t\t\tif (!dsd_ptr->dsd_addr) {\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tkfree(dsd_ptr);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\tif (sp) {\n\t\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t\t    &difctx->dsd_list);\n\t\t\t\t\tsp->flags |= SRB_CRC_CTX_DSD_VALID;\n\t\t\t\t} else {\n\t\t\t\t\tlist_add_tail(&dsd_ptr->list,\n\t\t\t\t\t    &difctx->dsd_list);\n\t\t\t\t\ttc->ctx_dsd_alloced = 1;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tput_unaligned_le64(dsd_ptr->dsd_list_dma,\n\t\t\t\t\t\t   &cur_dsd->address);\n\t\t\t\tcur_dsd->length = cpu_to_le32(dsd_list_len);\n\t\t\t\tcur_dsd = dsd_ptr->dsd_addr;\n\t\t\t}\n\t\t\tappend_dsd64(&cur_dsd, sg);\n\t\t\tavail_dsds--;\n\t\t}\n\t}\n\t \n\tcur_dsd->address = 0;\n\tcur_dsd->length = 0;\n\tcur_dsd++;\n\treturn 0;\n}\n\n \nstatic inline int\nqla24xx_build_scsi_crc_2_iocbs(srb_t *sp, struct cmd_type_crc_2 *cmd_pkt,\n    uint16_t tot_dsds, uint16_t tot_prot_dsds, uint16_t fw_prot_opts)\n{\n\tstruct dsd64\t\t*cur_dsd;\n\t__be32\t\t\t*fcp_dl;\n\tscsi_qla_host_t\t\t*vha;\n\tstruct scsi_cmnd\t*cmd;\n\tuint32_t\t\ttotal_bytes = 0;\n\tuint32_t\t\tdata_bytes;\n\tuint32_t\t\tdif_bytes;\n\tuint8_t\t\t\tbundling = 1;\n\tuint16_t\t\tblk_size;\n\tstruct crc_context\t*crc_ctx_pkt = NULL;\n\tstruct qla_hw_data\t*ha;\n\tuint8_t\t\t\tadditional_fcpcdb_len;\n\tuint16_t\t\tfcp_cmnd_len;\n\tstruct fcp_cmnd\t\t*fcp_cmnd;\n\tdma_addr_t\t\tcrc_ctx_dma;\n\n\tcmd = GET_CMD_SP(sp);\n\n\t \n\tput_unaligned_le32(COMMAND_TYPE_CRC_2, &cmd_pkt->entry_type);\n\n\tvha = sp->vha;\n\tha = vha->hw;\n\n\t \n\tdata_bytes = scsi_bufflen(cmd);\n\tif (!data_bytes || cmd->sc_data_direction == DMA_NONE) {\n\t\tcmd_pkt->byte_count = cpu_to_le32(0);\n\t\treturn QLA_SUCCESS;\n\t}\n\n\tcmd_pkt->vp_index = sp->vha->vp_idx;\n\n\t \n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tcmd_pkt->control_flags =\n\t\t    cpu_to_le16(CF_WRITE_DATA);\n\t} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tcmd_pkt->control_flags =\n\t\t    cpu_to_le16(CF_READ_DATA);\n\t}\n\n\tif ((scsi_get_prot_op(cmd) == SCSI_PROT_READ_INSERT) ||\n\t    (scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_STRIP) ||\n\t    (scsi_get_prot_op(cmd) == SCSI_PROT_READ_STRIP) ||\n\t    (scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_INSERT))\n\t\tbundling = 0;\n\n\t \n\tcrc_ctx_pkt = sp->u.scmd.crc_ctx =\n\t    dma_pool_zalloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);\n\n\tif (!crc_ctx_pkt)\n\t\tgoto crc_queuing_error;\n\n\tcrc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;\n\n\tsp->flags |= SRB_CRC_CTX_DMA_VALID;\n\n\t \n\tcrc_ctx_pkt->handle = cmd_pkt->handle;\n\n\tINIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);\n\n\tqla24xx_set_t10dif_tags(sp, (struct fw_dif_context *)\n\t    &crc_ctx_pkt->ref_tag, tot_prot_dsds);\n\n\tput_unaligned_le64(crc_ctx_dma, &cmd_pkt->crc_context_address);\n\tcmd_pkt->crc_context_len = cpu_to_le16(CRC_CONTEXT_LEN_FW);\n\n\t \n\tif (cmd->cmd_len > 16) {\n\t\tadditional_fcpcdb_len = cmd->cmd_len - 16;\n\t\tif ((cmd->cmd_len % 4) != 0) {\n\t\t\t \n\t\t\tgoto crc_queuing_error;\n\t\t}\n\t\tfcp_cmnd_len = 12 + cmd->cmd_len + 4;\n\t} else {\n\t\tadditional_fcpcdb_len = 0;\n\t\tfcp_cmnd_len = 12 + 16 + 4;\n\t}\n\n\tfcp_cmnd = &crc_ctx_pkt->fcp_cmnd;\n\n\tfcp_cmnd->additional_cdb_len = additional_fcpcdb_len;\n\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tfcp_cmnd->additional_cdb_len |= 1;\n\telse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\tfcp_cmnd->additional_cdb_len |= 2;\n\n\tint_to_scsilun(cmd->device->lun, &fcp_cmnd->lun);\n\tmemcpy(fcp_cmnd->cdb, cmd->cmnd, cmd->cmd_len);\n\tcmd_pkt->fcp_cmnd_dseg_len = cpu_to_le16(fcp_cmnd_len);\n\tput_unaligned_le64(crc_ctx_dma + CRC_CONTEXT_FCPCMND_OFF,\n\t\t\t   &cmd_pkt->fcp_cmnd_dseg_address);\n\tfcp_cmnd->task_management = 0;\n\tfcp_cmnd->task_attribute = TSK_SIMPLE;\n\n\tcmd_pkt->fcp_rsp_dseg_len = 0;  \n\n\t \n\tdif_bytes = 0;\n\tblk_size = cmd->device->sector_size;\n\tdif_bytes = (data_bytes / blk_size) * 8;\n\n\tswitch (scsi_get_prot_op(GET_CMD_SP(sp))) {\n\tcase SCSI_PROT_READ_INSERT:\n\tcase SCSI_PROT_WRITE_STRIP:\n\t\ttotal_bytes = data_bytes;\n\t\tdata_bytes += dif_bytes;\n\t\tbreak;\n\n\tcase SCSI_PROT_READ_STRIP:\n\tcase SCSI_PROT_WRITE_INSERT:\n\tcase SCSI_PROT_READ_PASS:\n\tcase SCSI_PROT_WRITE_PASS:\n\t\ttotal_bytes = data_bytes + dif_bytes;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (!qla2x00_hba_err_chk_enabled(sp))\n\t\tfw_prot_opts |= 0x10;  \n\t \n\telse if (IS_PI_UNINIT_CAPABLE(ha)) {\n\t\tif ((scsi_get_prot_type(GET_CMD_SP(sp)) == SCSI_PROT_DIF_TYPE1)\n\t\t    || (scsi_get_prot_type(GET_CMD_SP(sp)) ==\n\t\t\tSCSI_PROT_DIF_TYPE2))\n\t\t\tfw_prot_opts |= BIT_10;\n\t\telse if (scsi_get_prot_type(GET_CMD_SP(sp)) ==\n\t\t    SCSI_PROT_DIF_TYPE3)\n\t\t\tfw_prot_opts |= BIT_11;\n\t}\n\n\tif (!bundling) {\n\t\tcur_dsd = &crc_ctx_pkt->u.nobundling.data_dsd[0];\n\t} else {\n\t\t \n\t\tfw_prot_opts |= PO_ENABLE_DIF_BUNDLING;\n\t\tcrc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);\n\t\tcrc_ctx_pkt->u.bundling.dseg_count = cpu_to_le16(tot_dsds -\n\t\t\t\t\t\t\ttot_prot_dsds);\n\t\tcur_dsd = &crc_ctx_pkt->u.bundling.data_dsd[0];\n\t}\n\n\t \n\tcrc_ctx_pkt->blk_size = cpu_to_le16(blk_size);\n\tcrc_ctx_pkt->prot_opts = cpu_to_le16(fw_prot_opts);\n\tcrc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);\n\tcrc_ctx_pkt->guard_seed = cpu_to_le16(0);\n\t \n\tcmd_pkt->byte_count = cpu_to_le32(total_bytes);\n\tfcp_dl = (__be32 *)(crc_ctx_pkt->fcp_cmnd.cdb + 16 +\n\t    additional_fcpcdb_len);\n\t*fcp_dl = htonl(total_bytes);\n\n\tif (!data_bytes || cmd->sc_data_direction == DMA_NONE) {\n\t\tcmd_pkt->byte_count = cpu_to_le32(0);\n\t\treturn QLA_SUCCESS;\n\t}\n\t \n\n\tcmd_pkt->control_flags |= cpu_to_le16(CF_DATA_SEG_DESCR_ENABLE);\n\n\tif (!bundling && tot_prot_dsds) {\n\t\tif (qla24xx_walk_and_build_sglist_no_difb(ha, sp,\n\t\t\tcur_dsd, tot_dsds, NULL))\n\t\t\tgoto crc_queuing_error;\n\t} else if (qla24xx_walk_and_build_sglist(ha, sp, cur_dsd,\n\t\t\t(tot_dsds - tot_prot_dsds), NULL))\n\t\tgoto crc_queuing_error;\n\n\tif (bundling && tot_prot_dsds) {\n\t\t \n\t\tcmd_pkt->control_flags |= cpu_to_le16(CF_DIF_SEG_DESCR_ENABLE);\n\t\tcur_dsd = &crc_ctx_pkt->u.bundling.dif_dsd;\n\t\tif (qla24xx_walk_and_build_prot_sglist(ha, sp, cur_dsd,\n\t\t\t\ttot_prot_dsds, NULL))\n\t\t\tgoto crc_queuing_error;\n\t}\n\treturn QLA_SUCCESS;\n\ncrc_queuing_error:\n\t \n\n\treturn QLA_FUNCTION_FAILED;\n}\n\n \nint\nqla24xx_start_scsi(srb_t *sp)\n{\n\tint\t\tnseg;\n\tunsigned long   flags;\n\tuint32_t\t*clr_ptr;\n\tuint32_t\thandle;\n\tstruct cmd_type_7 *cmd_pkt;\n\tuint16_t\tcnt;\n\tuint16_t\treq_cnt;\n\tuint16_t\ttot_dsds;\n\tstruct req_que *req = NULL;\n\tstruct rsp_que *rsp;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (sp->fcport->edif.enable  && (sp->fcport->flags & FCF_FCSP_DEVICE))\n\t\treturn qla28xx_start_scsi_edif(sp);\n\n\t \n\treq = vha->req;\n\trsp = req->rsp;\n\n\t \n\ttot_dsds = 0;\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (qla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL) !=\n\t\t    QLA_SUCCESS)\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\tvha->marker_needed = 0;\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0)\n\t\tgoto queuing_error;\n\n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t    scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t} else\n\t\tnseg = 0;\n\n\ttot_dsds = nseg;\n\treq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\n\tsp->iores.res_type = RESOURCE_IOCB | RESOURCE_EXCH;\n\tsp->iores.exch_cnt = 1;\n\tsp->iores.iocb_cnt = req_cnt;\n\tif (qla_get_fw_resources(sp->qpair, &sp->iores))\n\t\tgoto queuing_error;\n\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tif (IS_SHADOW_REG_CAPABLE(ha)) {\n\t\t\tcnt = *req->out_ptr;\n\t\t} else {\n\t\t\tcnt = rd_reg_dword_relaxed(req->req_q_out);\n\t\t\tif (qla2x00_check_reg16_for_disconnect(vha, cnt))\n\t\t\t\tgoto queuing_error;\n\t\t}\n\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t\t(req->ring_index - cnt);\n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\t}\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\n\tcmd_pkt = (struct cmd_type_7 *)req->ring_ptr;\n\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\t \n\t \n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t \n\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\tcmd_pkt->vp_index = sp->vha->vp_idx;\n\n\tint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\n\thost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\n\n\tcmd_pkt->task = TSK_SIMPLE;\n\n\t \n\tmemcpy(cmd_pkt->fcp_cdb, cmd->cmnd, cmd->cmd_len);\n\thost_to_fcp_swap(cmd_pkt->fcp_cdb, sizeof(cmd_pkt->fcp_cdb));\n\n\tcmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\n\n\t \n\tqla24xx_build_scsi_iocbs(sp, cmd_pkt, tot_dsds, req);\n\n\t \n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\twmb();\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\tsp->qpair->cmd_cnt++;\n\tsp->flags |= SRB_DMA_VALID;\n\n\t \n\twrt_reg_dword(req->req_q_in, req->ring_index);\n\n\t \n\tif (vha->flags.process_response_queue &&\n\t    rsp->ring_ptr->signature != RESPONSE_PROCESSED)\n\t\tqla24xx_process_response_queue(vha, rsp);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn QLA_SUCCESS;\n\nqueuing_error:\n\tif (tot_dsds)\n\t\tscsi_dma_unmap(cmd);\n\n\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\n \nint\nqla24xx_dif_start_scsi(srb_t *sp)\n{\n\tint\t\t\tnseg;\n\tunsigned long\t\tflags;\n\tuint32_t\t\t*clr_ptr;\n\tuint32_t\t\thandle;\n\tuint16_t\t\tcnt;\n\tuint16_t\t\treq_cnt = 0;\n\tuint16_t\t\ttot_dsds;\n\tuint16_t\t\ttot_prot_dsds;\n\tuint16_t\t\tfw_prot_opts = 0;\n\tstruct req_que\t\t*req = NULL;\n\tstruct rsp_que\t\t*rsp = NULL;\n\tstruct scsi_cmnd\t*cmd = GET_CMD_SP(sp);\n\tstruct scsi_qla_host\t*vha = sp->vha;\n\tstruct qla_hw_data\t*ha = vha->hw;\n\tstruct cmd_type_crc_2\t*cmd_pkt;\n\tuint32_t\t\tstatus = 0;\n\n#define QDSS_GOT_Q_SPACE\tBIT_0\n\n\t \n\tif (scsi_get_prot_op(cmd) == SCSI_PROT_NORMAL) {\n\t\tif (cmd->cmd_len <= 16)\n\t\t\treturn qla24xx_start_scsi(sp);\n\t\telse\n\t\t\treturn qla_start_scsi_type6(sp);\n\t}\n\n\t \n\treq = vha->req;\n\trsp = req->rsp;\n\n\t \n\ttot_dsds = 0;\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (qla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL) !=\n\t\t    QLA_SUCCESS)\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\tvha->marker_needed = 0;\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0)\n\t\tgoto queuing_error;\n\n\t \n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t    scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t\telse\n\t\t\tsp->flags |= SRB_DMA_VALID;\n\n\t\tif ((scsi_get_prot_op(cmd) == SCSI_PROT_READ_INSERT) ||\n\t\t    (scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_STRIP)) {\n\t\t\tstruct qla2_sgx sgx;\n\t\t\tuint32_t\tpartial;\n\n\t\t\tmemset(&sgx, 0, sizeof(struct qla2_sgx));\n\t\t\tsgx.tot_bytes = scsi_bufflen(cmd);\n\t\t\tsgx.cur_sg = scsi_sglist(cmd);\n\t\t\tsgx.sp = sp;\n\n\t\t\tnseg = 0;\n\t\t\twhile (qla24xx_get_one_block_sg(\n\t\t\t    cmd->device->sector_size, &sgx, &partial))\n\t\t\t\tnseg++;\n\t\t}\n\t} else\n\t\tnseg = 0;\n\n\t \n\ttot_dsds = nseg;\n\n\t \n\tif (qla24xx_configure_prot_mode(sp, &fw_prot_opts)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_prot_sglist(cmd),\n\t\t    scsi_prot_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t\telse\n\t\t\tsp->flags |= SRB_CRC_PROT_DMA_VALID;\n\n\t\tif ((scsi_get_prot_op(cmd) == SCSI_PROT_READ_INSERT) ||\n\t\t    (scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_STRIP)) {\n\t\t\tnseg = scsi_bufflen(cmd) / cmd->device->sector_size;\n\t\t}\n\t} else {\n\t\tnseg = 0;\n\t}\n\n\treq_cnt = 1;\n\t \n\ttot_prot_dsds = nseg;\n\ttot_dsds += nseg;\n\n\tsp->iores.res_type = RESOURCE_IOCB | RESOURCE_EXCH;\n\tsp->iores.exch_cnt = 1;\n\tsp->iores.iocb_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\tif (qla_get_fw_resources(sp->qpair, &sp->iores))\n\t\tgoto queuing_error;\n\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tif (IS_SHADOW_REG_CAPABLE(ha)) {\n\t\t\tcnt = *req->out_ptr;\n\t\t} else {\n\t\t\tcnt = rd_reg_dword_relaxed(req->req_q_out);\n\t\t\tif (qla2x00_check_reg16_for_disconnect(vha, cnt))\n\t\t\t\tgoto queuing_error;\n\t\t}\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t\t(req->ring_index - cnt);\n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\t}\n\n\tstatus |= QDSS_GOT_Q_SPACE;\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\n\t \n\tcmd_pkt = (struct cmd_type_crc_2 *)req->ring_ptr;\n\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\n\t \n\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\n\tint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\n\thost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\n\n\t \n\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t \n\tif (qla24xx_build_scsi_crc_2_iocbs(sp, (struct cmd_type_crc_2 *)\n\t    req->ring_ptr, tot_dsds, tot_prot_dsds, fw_prot_opts) !=\n\t\tQLA_SUCCESS)\n\t\tgoto queuing_error;\n\n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\t \n\tcmd_pkt->entry_status = (uint8_t) rsp->id;\n\tcmd_pkt->timeout = cpu_to_le16(0);\n\twmb();\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\tsp->qpair->cmd_cnt++;\n\t \n\twrt_reg_dword(req->req_q_in, req->ring_index);\n\n\t \n\tif (vha->flags.process_response_queue &&\n\t    rsp->ring_ptr->signature != RESPONSE_PROCESSED)\n\t\tqla24xx_process_response_queue(vha, rsp);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n\nqueuing_error:\n\tif (status & QDSS_GOT_Q_SPACE) {\n\t\treq->outstanding_cmds[handle] = NULL;\n\t\treq->cnt += req_cnt;\n\t}\n\t \n\n\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\n \nstatic int\nqla2xxx_start_scsi_mq(srb_t *sp)\n{\n\tint\t\tnseg;\n\tunsigned long   flags;\n\tuint32_t\t*clr_ptr;\n\tuint32_t\thandle;\n\tstruct cmd_type_7 *cmd_pkt;\n\tuint16_t\tcnt;\n\tuint16_t\treq_cnt;\n\tuint16_t\ttot_dsds;\n\tstruct req_que *req = NULL;\n\tstruct rsp_que *rsp;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tstruct scsi_qla_host *vha = sp->fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_qpair *qpair = sp->qpair;\n\n\tif (sp->fcport->edif.enable && (sp->fcport->flags & FCF_FCSP_DEVICE))\n\t\treturn qla28xx_start_scsi_edif(sp);\n\n\t \n\tspin_lock_irqsave(&qpair->qp_lock, flags);\n\n\t \n\treq = qpair->req;\n\trsp = qpair->rsp;\n\n\t \n\ttot_dsds = 0;\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (__qla2x00_marker(vha, qpair, 0, 0, MK_SYNC_ALL) !=\n\t\t    QLA_SUCCESS) {\n\t\t\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t\tvha->marker_needed = 0;\n\t}\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0)\n\t\tgoto queuing_error;\n\n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t    scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t} else\n\t\tnseg = 0;\n\n\ttot_dsds = nseg;\n\treq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\n\tsp->iores.res_type = RESOURCE_IOCB | RESOURCE_EXCH;\n\tsp->iores.exch_cnt = 1;\n\tsp->iores.iocb_cnt = req_cnt;\n\tif (qla_get_fw_resources(sp->qpair, &sp->iores))\n\t\tgoto queuing_error;\n\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tif (IS_SHADOW_REG_CAPABLE(ha)) {\n\t\t\tcnt = *req->out_ptr;\n\t\t} else {\n\t\t\tcnt = rd_reg_dword_relaxed(req->req_q_out);\n\t\t\tif (qla2x00_check_reg16_for_disconnect(vha, cnt))\n\t\t\t\tgoto queuing_error;\n\t\t}\n\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t\t(req->ring_index - cnt);\n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\t}\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\n\tcmd_pkt = (struct cmd_type_7 *)req->ring_ptr;\n\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\t \n\t \n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t \n\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\tcmd_pkt->vp_index = sp->fcport->vha->vp_idx;\n\n\tint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\n\thost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\n\n\tcmd_pkt->task = TSK_SIMPLE;\n\n\t \n\tmemcpy(cmd_pkt->fcp_cdb, cmd->cmnd, cmd->cmd_len);\n\thost_to_fcp_swap(cmd_pkt->fcp_cdb, sizeof(cmd_pkt->fcp_cdb));\n\n\tcmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\n\n\t \n\tqla24xx_build_scsi_iocbs(sp, cmd_pkt, tot_dsds, req);\n\n\t \n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\twmb();\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\tsp->qpair->cmd_cnt++;\n\tsp->flags |= SRB_DMA_VALID;\n\n\t \n\twrt_reg_dword(req->req_q_in, req->ring_index);\n\n\t \n\tif (vha->flags.process_response_queue &&\n\t    rsp->ring_ptr->signature != RESPONSE_PROCESSED)\n\t\tqla24xx_process_response_queue(vha, rsp);\n\n\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\treturn QLA_SUCCESS;\n\nqueuing_error:\n\tif (tot_dsds)\n\t\tscsi_dma_unmap(cmd);\n\n\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\n\n \nint\nqla2xxx_dif_start_scsi_mq(srb_t *sp)\n{\n\tint\t\t\tnseg;\n\tunsigned long\t\tflags;\n\tuint32_t\t\t*clr_ptr;\n\tuint32_t\t\thandle;\n\tuint16_t\t\tcnt;\n\tuint16_t\t\treq_cnt = 0;\n\tuint16_t\t\ttot_dsds;\n\tuint16_t\t\ttot_prot_dsds;\n\tuint16_t\t\tfw_prot_opts = 0;\n\tstruct req_que\t\t*req = NULL;\n\tstruct rsp_que\t\t*rsp = NULL;\n\tstruct scsi_cmnd\t*cmd = GET_CMD_SP(sp);\n\tstruct scsi_qla_host\t*vha = sp->fcport->vha;\n\tstruct qla_hw_data\t*ha = vha->hw;\n\tstruct cmd_type_crc_2\t*cmd_pkt;\n\tuint32_t\t\tstatus = 0;\n\tstruct qla_qpair\t*qpair = sp->qpair;\n\n#define QDSS_GOT_Q_SPACE\tBIT_0\n\n\t \n\tif (!qpair->online) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\treturn QLA_INTERFACE_ERROR;\n\t}\n\n\tif (!qpair->difdix_supported &&\n\t\tscsi_get_prot_op(cmd) != SCSI_PROT_NORMAL) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\treturn QLA_INTERFACE_ERROR;\n\t}\n\n\t \n\tif (scsi_get_prot_op(cmd) == SCSI_PROT_NORMAL) {\n\t\tif (cmd->cmd_len <= 16)\n\t\t\treturn qla2xxx_start_scsi_mq(sp);\n\t\telse\n\t\t\treturn qla_start_scsi_type6(sp);\n\t}\n\n\tspin_lock_irqsave(&qpair->qp_lock, flags);\n\n\t \n\trsp = qpair->rsp;\n\treq = qpair->req;\n\n\t \n\ttot_dsds = 0;\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (__qla2x00_marker(vha, qpair, 0, 0, MK_SYNC_ALL) !=\n\t\t    QLA_SUCCESS) {\n\t\t\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t\tvha->marker_needed = 0;\n\t}\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0)\n\t\tgoto queuing_error;\n\n\t \n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t    scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t\telse\n\t\t\tsp->flags |= SRB_DMA_VALID;\n\n\t\tif ((scsi_get_prot_op(cmd) == SCSI_PROT_READ_INSERT) ||\n\t\t    (scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_STRIP)) {\n\t\t\tstruct qla2_sgx sgx;\n\t\t\tuint32_t\tpartial;\n\n\t\t\tmemset(&sgx, 0, sizeof(struct qla2_sgx));\n\t\t\tsgx.tot_bytes = scsi_bufflen(cmd);\n\t\t\tsgx.cur_sg = scsi_sglist(cmd);\n\t\t\tsgx.sp = sp;\n\n\t\t\tnseg = 0;\n\t\t\twhile (qla24xx_get_one_block_sg(\n\t\t\t    cmd->device->sector_size, &sgx, &partial))\n\t\t\t\tnseg++;\n\t\t}\n\t} else\n\t\tnseg = 0;\n\n\t \n\ttot_dsds = nseg;\n\n\t \n\tif (qla24xx_configure_prot_mode(sp, &fw_prot_opts)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_prot_sglist(cmd),\n\t\t    scsi_prot_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t\telse\n\t\t\tsp->flags |= SRB_CRC_PROT_DMA_VALID;\n\n\t\tif ((scsi_get_prot_op(cmd) == SCSI_PROT_READ_INSERT) ||\n\t\t    (scsi_get_prot_op(cmd) == SCSI_PROT_WRITE_STRIP)) {\n\t\t\tnseg = scsi_bufflen(cmd) / cmd->device->sector_size;\n\t\t}\n\t} else {\n\t\tnseg = 0;\n\t}\n\n\treq_cnt = 1;\n\t \n\ttot_prot_dsds = nseg;\n\ttot_dsds += nseg;\n\n\tsp->iores.res_type = RESOURCE_IOCB | RESOURCE_EXCH;\n\tsp->iores.exch_cnt = 1;\n\tsp->iores.iocb_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\tif (qla_get_fw_resources(sp->qpair, &sp->iores))\n\t\tgoto queuing_error;\n\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tif (IS_SHADOW_REG_CAPABLE(ha)) {\n\t\t\tcnt = *req->out_ptr;\n\t\t} else {\n\t\t\tcnt = rd_reg_dword_relaxed(req->req_q_out);\n\t\t\tif (qla2x00_check_reg16_for_disconnect(vha, cnt))\n\t\t\t\tgoto queuing_error;\n\t\t}\n\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t\t(req->ring_index - cnt);\n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\t}\n\n\tstatus |= QDSS_GOT_Q_SPACE;\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\n\t \n\tcmd_pkt = (struct cmd_type_crc_2 *)req->ring_ptr;\n\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\n\t \n\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\n\tint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\n\thost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\n\n\t \n\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t \n\tif (qla24xx_build_scsi_crc_2_iocbs(sp, (struct cmd_type_crc_2 *)\n\t    req->ring_ptr, tot_dsds, tot_prot_dsds, fw_prot_opts) !=\n\t\tQLA_SUCCESS)\n\t\tgoto queuing_error;\n\n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\tcmd_pkt->timeout = cpu_to_le16(0);\n\twmb();\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\tsp->qpair->cmd_cnt++;\n\t \n\twrt_reg_dword(req->req_q_in, req->ring_index);\n\n\t \n\tif (vha->flags.process_response_queue &&\n\t    rsp->ring_ptr->signature != RESPONSE_PROCESSED)\n\t\tqla24xx_process_response_queue(vha, rsp);\n\n\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\n\treturn QLA_SUCCESS;\n\nqueuing_error:\n\tif (status & QDSS_GOT_Q_SPACE) {\n\t\treq->outstanding_cmds[handle] = NULL;\n\t\treq->cnt += req_cnt;\n\t}\n\t \n\n\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\n \n\n \n\nvoid *\n__qla2x00_alloc_iocbs(struct qla_qpair *qpair, srb_t *sp)\n{\n\tscsi_qla_host_t *vha = qpair->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = qpair->req;\n\tdevice_reg_t *reg = ISP_QUE_REG(ha, req->id);\n\tuint32_t handle;\n\trequest_t *pkt;\n\tuint16_t cnt, req_cnt;\n\n\tpkt = NULL;\n\treq_cnt = 1;\n\thandle = 0;\n\n\tif (sp && (sp->type != SRB_SCSI_CMD)) {\n\t\t \n\t\treq_cnt = sp->iocbs;\n\t}\n\n\t \n\tif (req->cnt < req_cnt + 2) {\n\t\tif (qpair->use_shadow_reg)\n\t\t\tcnt = *req->out_ptr;\n\t\telse if (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t\t    IS_QLA28XX(ha))\n\t\t\tcnt = rd_reg_dword(&reg->isp25mq.req_q_out);\n\t\telse if (IS_P3P_TYPE(ha))\n\t\t\tcnt = rd_reg_dword(reg->isp82.req_q_out);\n\t\telse if (IS_FWI2_CAPABLE(ha))\n\t\t\tcnt = rd_reg_dword(&reg->isp24.req_q_out);\n\t\telse if (IS_QLAFX00(ha))\n\t\t\tcnt = rd_reg_dword(&reg->ispfx00.req_q_out);\n\t\telse\n\t\t\tcnt = qla2x00_debounce_register(\n\t\t\t    ISP_REQ_Q_OUT(ha, &reg->isp));\n\n\t\tif (!qpair->use_shadow_reg && cnt == ISP_REG16_DISCONNECT) {\n\t\t\tqla_schedule_eeh_work(vha);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif  (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t    (req->ring_index - cnt);\n\t}\n\tif (req->cnt < req_cnt + 2)\n\t\tgoto queuing_error;\n\n\tif (sp) {\n\t\thandle = qla2xxx_get_next_handle(req);\n\t\tif (handle == 0) {\n\t\t\tql_log(ql_log_warn, vha, 0x700b,\n\t\t\t    \"No room on outstanding cmd array.\\n\");\n\t\t\tgoto queuing_error;\n\t\t}\n\n\t\t \n\t\treq->current_outstanding_cmd = handle;\n\t\treq->outstanding_cmds[handle] = sp;\n\t\tsp->handle = handle;\n\t}\n\n\t \n\treq->cnt -= req_cnt;\n\tpkt = req->ring_ptr;\n\tmemset(pkt, 0, REQUEST_ENTRY_SIZE);\n\tif (IS_QLAFX00(ha)) {\n\t\twrt_reg_byte((u8 __force __iomem *)&pkt->entry_count, req_cnt);\n\t\twrt_reg_dword((__le32 __force __iomem *)&pkt->handle, handle);\n\t} else {\n\t\tpkt->entry_count = req_cnt;\n\t\tpkt->handle = handle;\n\t}\n\n\treturn pkt;\n\nqueuing_error:\n\tqpair->tgt_counters.num_alloc_iocb_failed++;\n\treturn pkt;\n}\n\nvoid *\nqla2x00_alloc_iocbs_ready(struct qla_qpair *qpair, srb_t *sp)\n{\n\tscsi_qla_host_t *vha = qpair->vha;\n\n\tif (qla2x00_reset_active(vha))\n\t\treturn NULL;\n\n\treturn __qla2x00_alloc_iocbs(qpair, sp);\n}\n\nvoid *\nqla2x00_alloc_iocbs(struct scsi_qla_host *vha, srb_t *sp)\n{\n\treturn __qla2x00_alloc_iocbs(vha->hw->base_qpair, sp);\n}\n\nstatic void\nqla24xx_prli_iocb(srb_t *sp, struct logio_entry_24xx *logio)\n{\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\n\tlogio->entry_type = LOGINOUT_PORT_IOCB_TYPE;\n\tlogio->control_flags = cpu_to_le16(LCF_COMMAND_PRLI);\n\tif (lio->u.logio.flags & SRB_LOGIN_NVME_PRLI) {\n\t\tlogio->control_flags |= cpu_to_le16(LCF_NVME_PRLI);\n\t\tif (sp->vha->flags.nvme_first_burst)\n\t\t\tlogio->io_parameter[0] =\n\t\t\t\tcpu_to_le32(NVME_PRLI_SP_FIRST_BURST);\n\t\tif (sp->vha->flags.nvme2_enabled) {\n\t\t\t \n\t\t\tlogio->io_parameter[0] |=\n\t\t\t\tcpu_to_le32(NVME_PRLI_SP_CONF);\n\t\t\t \n\t\t\tlogio->io_parameter[0] |=\n\t\t\t\tcpu_to_le32(NVME_PRLI_SP_SLER);\n\t\t\t \n\t\t\tlogio->io_parameter[0] |=\n\t\t\t\tcpu_to_le32(NVME_PRLI_SP_PI_CTRL);\n\t\t}\n\t}\n\n\tlogio->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tlogio->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tlogio->port_id[1] = sp->fcport->d_id.b.area;\n\tlogio->port_id[2] = sp->fcport->d_id.b.domain;\n\tlogio->vp_index = sp->vha->vp_idx;\n}\n\nstatic void\nqla24xx_login_iocb(srb_t *sp, struct logio_entry_24xx *logio)\n{\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\n\tlogio->entry_type = LOGINOUT_PORT_IOCB_TYPE;\n\tlogio->control_flags = cpu_to_le16(LCF_COMMAND_PLOGI);\n\n\tif (lio->u.logio.flags & SRB_LOGIN_PRLI_ONLY) {\n\t\tlogio->control_flags = cpu_to_le16(LCF_COMMAND_PRLI);\n\t} else {\n\t\tlogio->control_flags = cpu_to_le16(LCF_COMMAND_PLOGI);\n\t\tif (lio->u.logio.flags & SRB_LOGIN_COND_PLOGI)\n\t\t\tlogio->control_flags |= cpu_to_le16(LCF_COND_PLOGI);\n\t\tif (lio->u.logio.flags & SRB_LOGIN_SKIP_PRLI)\n\t\t\tlogio->control_flags |= cpu_to_le16(LCF_SKIP_PRLI);\n\t\tif (lio->u.logio.flags & SRB_LOGIN_FCSP) {\n\t\t\tlogio->control_flags |=\n\t\t\t    cpu_to_le16(LCF_COMMON_FEAT | LCF_SKIP_PRLI);\n\t\t\tlogio->io_parameter[0] =\n\t\t\t    cpu_to_le32(LIO_COMM_FEAT_FCSP | LIO_COMM_FEAT_CIO);\n\t\t}\n\t}\n\tlogio->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tlogio->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tlogio->port_id[1] = sp->fcport->d_id.b.area;\n\tlogio->port_id[2] = sp->fcport->d_id.b.domain;\n\tlogio->vp_index = sp->vha->vp_idx;\n}\n\nstatic void\nqla2x00_login_iocb(srb_t *sp, struct mbx_entry *mbx)\n{\n\tstruct qla_hw_data *ha = sp->vha->hw;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tuint16_t opts;\n\n\tmbx->entry_type = MBX_IOCB_TYPE;\n\tSET_TARGET_ID(ha, mbx->loop_id, sp->fcport->loop_id);\n\tmbx->mb0 = cpu_to_le16(MBC_LOGIN_FABRIC_PORT);\n\topts = lio->u.logio.flags & SRB_LOGIN_COND_PLOGI ? BIT_0 : 0;\n\topts |= lio->u.logio.flags & SRB_LOGIN_SKIP_PRLI ? BIT_1 : 0;\n\tif (HAS_EXTENDED_IDS(ha)) {\n\t\tmbx->mb1 = cpu_to_le16(sp->fcport->loop_id);\n\t\tmbx->mb10 = cpu_to_le16(opts);\n\t} else {\n\t\tmbx->mb1 = cpu_to_le16((sp->fcport->loop_id << 8) | opts);\n\t}\n\tmbx->mb2 = cpu_to_le16(sp->fcport->d_id.b.domain);\n\tmbx->mb3 = cpu_to_le16(sp->fcport->d_id.b.area << 8 |\n\t    sp->fcport->d_id.b.al_pa);\n\tmbx->mb9 = cpu_to_le16(sp->vha->vp_idx);\n}\n\nstatic void\nqla24xx_logout_iocb(srb_t *sp, struct logio_entry_24xx *logio)\n{\n\tu16 control_flags = LCF_COMMAND_LOGO;\n\tlogio->entry_type = LOGINOUT_PORT_IOCB_TYPE;\n\n\tif (sp->fcport->explicit_logout) {\n\t\tcontrol_flags |= LCF_EXPL_LOGO|LCF_FREE_NPORT;\n\t} else {\n\t\tcontrol_flags |= LCF_IMPL_LOGO;\n\n\t\tif (!sp->fcport->keep_nport_handle)\n\t\t\tcontrol_flags |= LCF_FREE_NPORT;\n\t}\n\n\tlogio->control_flags = cpu_to_le16(control_flags);\n\tlogio->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tlogio->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tlogio->port_id[1] = sp->fcport->d_id.b.area;\n\tlogio->port_id[2] = sp->fcport->d_id.b.domain;\n\tlogio->vp_index = sp->vha->vp_idx;\n}\n\nstatic void\nqla2x00_logout_iocb(srb_t *sp, struct mbx_entry *mbx)\n{\n\tstruct qla_hw_data *ha = sp->vha->hw;\n\n\tmbx->entry_type = MBX_IOCB_TYPE;\n\tSET_TARGET_ID(ha, mbx->loop_id, sp->fcport->loop_id);\n\tmbx->mb0 = cpu_to_le16(MBC_LOGOUT_FABRIC_PORT);\n\tmbx->mb1 = HAS_EXTENDED_IDS(ha) ?\n\t    cpu_to_le16(sp->fcport->loop_id) :\n\t    cpu_to_le16(sp->fcport->loop_id << 8);\n\tmbx->mb2 = cpu_to_le16(sp->fcport->d_id.b.domain);\n\tmbx->mb3 = cpu_to_le16(sp->fcport->d_id.b.area << 8 |\n\t    sp->fcport->d_id.b.al_pa);\n\tmbx->mb9 = cpu_to_le16(sp->vha->vp_idx);\n\t \n}\n\nstatic void\nqla24xx_adisc_iocb(srb_t *sp, struct logio_entry_24xx *logio)\n{\n\tlogio->entry_type = LOGINOUT_PORT_IOCB_TYPE;\n\tlogio->control_flags = cpu_to_le16(LCF_COMMAND_ADISC);\n\tlogio->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tlogio->vp_index = sp->vha->vp_idx;\n}\n\nstatic void\nqla2x00_adisc_iocb(srb_t *sp, struct mbx_entry *mbx)\n{\n\tstruct qla_hw_data *ha = sp->vha->hw;\n\n\tmbx->entry_type = MBX_IOCB_TYPE;\n\tSET_TARGET_ID(ha, mbx->loop_id, sp->fcport->loop_id);\n\tmbx->mb0 = cpu_to_le16(MBC_GET_PORT_DATABASE);\n\tif (HAS_EXTENDED_IDS(ha)) {\n\t\tmbx->mb1 = cpu_to_le16(sp->fcport->loop_id);\n\t\tmbx->mb10 = cpu_to_le16(BIT_0);\n\t} else {\n\t\tmbx->mb1 = cpu_to_le16((sp->fcport->loop_id << 8) | BIT_0);\n\t}\n\tmbx->mb2 = cpu_to_le16(MSW(ha->async_pd_dma));\n\tmbx->mb3 = cpu_to_le16(LSW(ha->async_pd_dma));\n\tmbx->mb6 = cpu_to_le16(MSW(MSD(ha->async_pd_dma)));\n\tmbx->mb7 = cpu_to_le16(LSW(MSD(ha->async_pd_dma)));\n\tmbx->mb9 = cpu_to_le16(sp->vha->vp_idx);\n}\n\nstatic void\nqla24xx_tm_iocb(srb_t *sp, struct tsk_mgmt_entry *tsk)\n{\n\tuint32_t flags;\n\tuint64_t lun;\n\tstruct fc_port *fcport = sp->fcport;\n\tscsi_qla_host_t *vha = fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct srb_iocb *iocb = &sp->u.iocb_cmd;\n\tstruct req_que *req = sp->qpair->req;\n\n\tflags = iocb->u.tmf.flags;\n\tlun = iocb->u.tmf.lun;\n\n\ttsk->entry_type = TSK_MGMT_IOCB_TYPE;\n\ttsk->entry_count = 1;\n\ttsk->handle = make_handle(req->id, tsk->handle);\n\ttsk->nport_handle = cpu_to_le16(fcport->loop_id);\n\ttsk->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\n\ttsk->control_flags = cpu_to_le32(flags);\n\ttsk->port_id[0] = fcport->d_id.b.al_pa;\n\ttsk->port_id[1] = fcport->d_id.b.area;\n\ttsk->port_id[2] = fcport->d_id.b.domain;\n\ttsk->vp_index = fcport->vha->vp_idx;\n\n\tif (flags & (TCF_LUN_RESET | TCF_ABORT_TASK_SET|\n\t    TCF_CLEAR_TASK_SET|TCF_CLEAR_ACA)) {\n\t\tint_to_scsilun(lun, &tsk->lun);\n\t\thost_to_fcp_swap((uint8_t *)&tsk->lun,\n\t\t\tsizeof(tsk->lun));\n\t}\n}\n\nstatic void\nqla2x00_async_done(struct srb *sp, int res)\n{\n\tif (del_timer(&sp->u.iocb_cmd.timer)) {\n\t\t \n\t\tif (kref_put(&sp->cmd_kref, qla2x00_sp_release))\n\t\t\treturn;\n\t}\n\tsp->async_done(sp, res);\n}\n\nvoid\nqla2x00_sp_release(struct kref *kref)\n{\n\tstruct srb *sp = container_of(kref, struct srb, cmd_kref);\n\n\tsp->free(sp);\n}\n\nvoid\nqla2x00_init_async_sp(srb_t *sp, unsigned long tmo,\n\t\t     void (*done)(struct srb *sp, int res))\n{\n\ttimer_setup(&sp->u.iocb_cmd.timer, qla2x00_sp_timeout, 0);\n\tsp->done = qla2x00_async_done;\n\tsp->async_done = done;\n\tsp->free = qla2x00_sp_free;\n\tsp->u.iocb_cmd.timeout = qla2x00_async_iocb_timeout;\n\tsp->u.iocb_cmd.timer.expires = jiffies + tmo * HZ;\n\tif (IS_QLAFX00(sp->vha->hw) && sp->type == SRB_FXIOCB_DCMD)\n\t\tinit_completion(&sp->u.iocb_cmd.u.fxiocb.fxiocb_comp);\n\tsp->start_timer = 1;\n}\n\nstatic void qla2x00_els_dcmd_sp_free(srb_t *sp)\n{\n\tstruct srb_iocb *elsio = &sp->u.iocb_cmd;\n\n\tkfree(sp->fcport);\n\n\tif (elsio->u.els_logo.els_logo_pyld)\n\t\tdma_free_coherent(&sp->vha->hw->pdev->dev, DMA_POOL_SIZE,\n\t\t    elsio->u.els_logo.els_logo_pyld,\n\t\t    elsio->u.els_logo.els_logo_pyld_dma);\n\n\tdel_timer(&elsio->timer);\n\tqla2x00_rel_sp(sp);\n}\n\nstatic void\nqla2x00_els_dcmd_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tfc_port_t *fcport = sp->fcport;\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tunsigned long flags = 0;\n\tint res, h;\n\n\tql_dbg(ql_dbg_io, vha, 0x3069,\n\t    \"%s Timeout, hdl=%x, portid=%02x%02x%02x\\n\",\n\t    sp->name, sp->handle, fcport->d_id.b.domain, fcport->d_id.b.area,\n\t    fcport->d_id.b.al_pa);\n\n\t \n\tres = qla24xx_async_abort_cmd(sp, false);\n\tif (res) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3070,\n\t\t    \"mbx abort_command failed.\\n\");\n\t\tspin_lock_irqsave(sp->qpair->qp_lock_ptr, flags);\n\t\tfor (h = 1; h < sp->qpair->req->num_outstanding_cmds; h++) {\n\t\t\tif (sp->qpair->req->outstanding_cmds[h] == sp) {\n\t\t\t\tsp->qpair->req->outstanding_cmds[h] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(sp->qpair->qp_lock_ptr, flags);\n\t\tcomplete(&lio->u.els_logo.comp);\n\t} else {\n\t\tql_dbg(ql_dbg_io, vha, 0x3071,\n\t\t    \"mbx abort_command success.\\n\");\n\t}\n}\n\nstatic void qla2x00_els_dcmd_sp_done(srb_t *sp, int res)\n{\n\tfc_port_t *fcport = sp->fcport;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tstruct scsi_qla_host *vha = sp->vha;\n\n\tql_dbg(ql_dbg_io, vha, 0x3072,\n\t    \"%s hdl=%x, portid=%02x%02x%02x done\\n\",\n\t    sp->name, sp->handle, fcport->d_id.b.domain,\n\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\tcomplete(&lio->u.els_logo.comp);\n}\n\nint\nqla24xx_els_dcmd_iocb(scsi_qla_host_t *vha, int els_opcode,\n    port_id_t remote_did)\n{\n\tsrb_t *sp;\n\tfc_port_t *fcport = NULL;\n\tstruct srb_iocb *elsio = NULL;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct els_logo_payload logo_pyld;\n\tint rval = QLA_SUCCESS;\n\n\tfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (!fcport) {\n\t       ql_log(ql_log_info, vha, 0x70e5, \"fcport allocation failed\\n\");\n\t       return -ENOMEM;\n\t}\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp) {\n\t\tkfree(fcport);\n\t\tql_log(ql_log_info, vha, 0x70e6,\n\t\t \"SRB allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\telsio = &sp->u.iocb_cmd;\n\tfcport->loop_id = 0xFFFF;\n\tfcport->d_id.b.domain = remote_did.b.domain;\n\tfcport->d_id.b.area = remote_did.b.area;\n\tfcport->d_id.b.al_pa = remote_did.b.al_pa;\n\n\tql_dbg(ql_dbg_io, vha, 0x3073, \"portid=%02x%02x%02x done\\n\",\n\t    fcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\tsp->type = SRB_ELS_DCMD;\n\tsp->name = \"ELS_DCMD\";\n\tsp->fcport = fcport;\n\tqla2x00_init_async_sp(sp, ELS_DCMD_TIMEOUT,\n\t\t\t      qla2x00_els_dcmd_sp_done);\n\tsp->free = qla2x00_els_dcmd_sp_free;\n\tsp->u.iocb_cmd.timeout = qla2x00_els_dcmd_iocb_timeout;\n\tinit_completion(&sp->u.iocb_cmd.u.els_logo.comp);\n\n\telsio->u.els_logo.els_logo_pyld = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t    DMA_POOL_SIZE, &elsio->u.els_logo.els_logo_pyld_dma,\n\t\t\t    GFP_KERNEL);\n\n\tif (!elsio->u.els_logo.els_logo_pyld) {\n\t\t \n\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tmemset(&logo_pyld, 0, sizeof(struct els_logo_payload));\n\n\telsio->u.els_logo.els_cmd = els_opcode;\n\tlogo_pyld.opcode = els_opcode;\n\tlogo_pyld.s_id[0] = vha->d_id.b.al_pa;\n\tlogo_pyld.s_id[1] = vha->d_id.b.area;\n\tlogo_pyld.s_id[2] = vha->d_id.b.domain;\n\thost_to_fcp_swap(logo_pyld.s_id, sizeof(uint32_t));\n\tmemcpy(&logo_pyld.wwpn, vha->port_name, WWN_SIZE);\n\n\tmemcpy(elsio->u.els_logo.els_logo_pyld, &logo_pyld,\n\t    sizeof(struct els_logo_payload));\n\tql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x3075, \"LOGO buffer:\");\n\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x010a,\n\t\t       elsio->u.els_logo.els_logo_pyld,\n\t\t       sizeof(*elsio->u.els_logo.els_logo_pyld));\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tql_dbg(ql_dbg_io, vha, 0x3074,\n\t    \"%s LOGO sent, hdl=%x, loopid=%x, portid=%02x%02x%02x.\\n\",\n\t    sp->name, sp->handle, fcport->loop_id, fcport->d_id.b.domain,\n\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\twait_for_completion(&elsio->u.els_logo.comp);\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\treturn rval;\n}\n\nstatic void\nqla24xx_els_logo_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)\n{\n\tscsi_qla_host_t *vha = sp->vha;\n\tstruct srb_iocb *elsio = &sp->u.iocb_cmd;\n\n\tels_iocb->entry_type = ELS_IOCB_TYPE;\n\tels_iocb->entry_count = 1;\n\tels_iocb->sys_define = 0;\n\tels_iocb->entry_status = 0;\n\tels_iocb->handle = sp->handle;\n\tels_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tels_iocb->tx_dsd_count = cpu_to_le16(1);\n\tels_iocb->vp_index = vha->vp_idx;\n\tels_iocb->sof_type = EST_SOFI3;\n\tels_iocb->rx_dsd_count = 0;\n\tels_iocb->opcode = elsio->u.els_logo.els_cmd;\n\n\tels_iocb->d_id[0] = sp->fcport->d_id.b.al_pa;\n\tels_iocb->d_id[1] = sp->fcport->d_id.b.area;\n\tels_iocb->d_id[2] = sp->fcport->d_id.b.domain;\n\t \n\tels_iocb->s_id[1] = vha->d_id.b.al_pa;\n\tels_iocb->s_id[2] = vha->d_id.b.area;\n\tels_iocb->s_id[0] = vha->d_id.b.domain;\n\n\tif (elsio->u.els_logo.els_cmd == ELS_DCMD_PLOGI) {\n\t\tif (vha->hw->flags.edif_enabled)\n\t\t\tels_iocb->control_flags = cpu_to_le16(ECF_SEC_LOGIN);\n\t\telse\n\t\t\tels_iocb->control_flags = 0;\n\t\tels_iocb->tx_byte_count = els_iocb->tx_len =\n\t\t\tcpu_to_le32(sizeof(struct els_plogi_payload));\n\t\tput_unaligned_le64(elsio->u.els_plogi.els_plogi_pyld_dma,\n\t\t\t\t   &els_iocb->tx_address);\n\t\tels_iocb->rx_dsd_count = cpu_to_le16(1);\n\t\tels_iocb->rx_byte_count = els_iocb->rx_len =\n\t\t\tcpu_to_le32(sizeof(struct els_plogi_payload));\n\t\tput_unaligned_le64(elsio->u.els_plogi.els_resp_pyld_dma,\n\t\t\t\t   &els_iocb->rx_address);\n\n\t\tql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x3073,\n\t\t    \"PLOGI ELS IOCB:\\n\");\n\t\tql_dump_buffer(ql_log_info, vha, 0x0109,\n\t\t    (uint8_t *)els_iocb,\n\t\t    sizeof(*els_iocb));\n\t} else {\n\t\tels_iocb->tx_byte_count =\n\t\t\tcpu_to_le32(sizeof(struct els_logo_payload));\n\t\tput_unaligned_le64(elsio->u.els_logo.els_logo_pyld_dma,\n\t\t\t\t   &els_iocb->tx_address);\n\t\tels_iocb->tx_len = cpu_to_le32(sizeof(struct els_logo_payload));\n\n\t\tels_iocb->rx_byte_count = 0;\n\t\tels_iocb->rx_address = 0;\n\t\tels_iocb->rx_len = 0;\n\t\tql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x3076,\n\t\t       \"LOGO ELS IOCB:\");\n\t\tql_dump_buffer(ql_log_info, vha, 0x010b,\n\t\t\t       els_iocb,\n\t\t\t       sizeof(*els_iocb));\n\t}\n\n\tsp->vha->qla_stats.control_requests++;\n}\n\nvoid\nqla2x00_els_dcmd2_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tfc_port_t *fcport = sp->fcport;\n\tstruct scsi_qla_host *vha = sp->vha;\n\tunsigned long flags = 0;\n\tint res, h;\n\n\tql_dbg(ql_dbg_io + ql_dbg_disc, vha, 0x3069,\n\t    \"%s hdl=%x ELS Timeout, %8phC portid=%06x\\n\",\n\t    sp->name, sp->handle, fcport->port_name, fcport->d_id.b24);\n\n\t \n\tres = qla24xx_async_abort_cmd(sp, false);\n\tql_dbg(ql_dbg_io, vha, 0x3070,\n\t    \"mbx abort_command %s\\n\",\n\t    (res == QLA_SUCCESS) ? \"successful\" : \"failed\");\n\tif (res) {\n\t\tspin_lock_irqsave(sp->qpair->qp_lock_ptr, flags);\n\t\tfor (h = 1; h < sp->qpair->req->num_outstanding_cmds; h++) {\n\t\t\tif (sp->qpair->req->outstanding_cmds[h] == sp) {\n\t\t\t\tsp->qpair->req->outstanding_cmds[h] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(sp->qpair->qp_lock_ptr, flags);\n\t\tsp->done(sp, QLA_FUNCTION_TIMEOUT);\n\t}\n}\n\nvoid qla2x00_els_dcmd2_free(scsi_qla_host_t *vha, struct els_plogi *els_plogi)\n{\n\tif (els_plogi->els_plogi_pyld)\n\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t\t  els_plogi->tx_size,\n\t\t\t\t  els_plogi->els_plogi_pyld,\n\t\t\t\t  els_plogi->els_plogi_pyld_dma);\n\n\tif (els_plogi->els_resp_pyld)\n\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t\t  els_plogi->rx_size,\n\t\t\t\t  els_plogi->els_resp_pyld,\n\t\t\t\t  els_plogi->els_resp_pyld_dma);\n}\n\nstatic void qla2x00_els_dcmd2_sp_done(srb_t *sp, int res)\n{\n\tfc_port_t *fcport = sp->fcport;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct event_arg ea;\n\tstruct qla_work_evt *e;\n\tstruct fc_port *conflict_fcport;\n\tport_id_t cid;\t \n\tconst __le32 *fw_status = sp->u.iocb_cmd.u.els_plogi.fw_status;\n\tu16 lid;\n\n\tql_dbg(ql_dbg_disc, vha, 0x3072,\n\t    \"%s ELS done rc %d hdl=%x, portid=%06x %8phC\\n\",\n\t    sp->name, res, sp->handle, fcport->d_id.b24, fcport->port_name);\n\n\tfcport->flags &= ~(FCF_ASYNC_SENT|FCF_ASYNC_ACTIVE);\n\t \n\tfcport->logout_on_delete = 1;\n\tfcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\n\tif (sp->flags & SRB_WAKEUP_ON_COMP)\n\t\tcomplete(&lio->u.els_plogi.comp);\n\telse {\n\t\tswitch (le32_to_cpu(fw_status[0])) {\n\t\tcase CS_DATA_UNDERRUN:\n\t\tcase CS_COMPLETE:\n\t\t\tmemset(&ea, 0, sizeof(ea));\n\t\t\tea.fcport = fcport;\n\t\t\tea.rc = res;\n\t\t\tqla_handle_els_plogi_done(vha, &ea);\n\t\t\tbreak;\n\n\t\tcase CS_IOCB_ERROR:\n\t\t\tswitch (le32_to_cpu(fw_status[1])) {\n\t\t\tcase LSC_SCODE_PORTID_USED:\n\t\t\t\tlid = le32_to_cpu(fw_status[2]) & 0xffff;\n\t\t\t\tqlt_find_sess_invalidate_other(vha,\n\t\t\t\t    wwn_to_u64(fcport->port_name),\n\t\t\t\t    fcport->d_id, lid, &conflict_fcport);\n\t\t\t\tif (conflict_fcport) {\n\t\t\t\t\t \n\t\t\t\t\tconflict_fcport->conflict = fcport;\n\t\t\t\t\tfcport->login_pause = 1;\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ed,\n\t\t\t\t\t    \"%s %d %8phC pid %06x inuse with lid %#x.\\n\",\n\t\t\t\t\t    __func__, __LINE__,\n\t\t\t\t\t    fcport->port_name,\n\t\t\t\t\t    fcport->d_id.b24, lid);\n\t\t\t\t} else {\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ed,\n\t\t\t\t\t    \"%s %d %8phC pid %06x inuse with lid %#x sched del\\n\",\n\t\t\t\t\t    __func__, __LINE__,\n\t\t\t\t\t    fcport->port_name,\n\t\t\t\t\t    fcport->d_id.b24, lid);\n\t\t\t\t\tqla2x00_clear_loop_id(fcport);\n\t\t\t\t\tset_bit(lid, vha->hw->loop_id_map);\n\t\t\t\t\tfcport->loop_id = lid;\n\t\t\t\t\tfcport->keep_nport_handle = 0;\n\t\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase LSC_SCODE_NPORT_USED:\n\t\t\t\tcid.b.domain = (le32_to_cpu(fw_status[2]) >> 16)\n\t\t\t\t\t& 0xff;\n\t\t\t\tcid.b.area   = (le32_to_cpu(fw_status[2]) >>  8)\n\t\t\t\t\t& 0xff;\n\t\t\t\tcid.b.al_pa  = le32_to_cpu(fw_status[2]) & 0xff;\n\t\t\t\tcid.b.rsvd_1 = 0;\n\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ec,\n\t\t\t\t    \"%s %d %8phC lid %#x in use with pid %06x post gnl\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name,\n\t\t\t\t    fcport->loop_id, cid.b24);\n\t\t\t\tset_bit(fcport->loop_id,\n\t\t\t\t    vha->hw->loop_id_map);\n\t\t\t\tfcport->loop_id = FC_NO_LOOP_ID;\n\t\t\t\tqla24xx_post_gnl_work(vha, fcport);\n\t\t\t\tbreak;\n\n\t\t\tcase LSC_SCODE_NOXCB:\n\t\t\t\tvha->hw->exch_starvation++;\n\t\t\t\tif (vha->hw->exch_starvation > 5) {\n\t\t\t\t\tql_log(ql_log_warn, vha, 0xd046,\n\t\t\t\t\t    \"Exchange starvation. Resetting RISC\\n\");\n\t\t\t\t\tvha->hw->exch_starvation = 0;\n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20eb,\n\t\t\t\t    \"%s %8phC cmd error fw_status 0x%x 0x%x 0x%x\\n\",\n\t\t\t\t    __func__, sp->fcport->port_name,\n\t\t\t\t    fw_status[0], fw_status[1], fw_status[2]);\n\n\t\t\t\tfcport->flags &= ~FCF_ASYNC_SENT;\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20eb,\n\t\t\t    \"%s %8phC cmd error 2 fw_status 0x%x 0x%x 0x%x\\n\",\n\t\t\t    __func__, sp->fcport->port_name,\n\t\t\t    fw_status[0], fw_status[1], fw_status[2]);\n\n\t\t\tsp->fcport->flags &= ~FCF_ASYNC_SENT;\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\tbreak;\n\t\t}\n\n\t\te = qla2x00_alloc_work(vha, QLA_EVT_UNMAP);\n\t\tif (!e) {\n\t\t\tstruct srb_iocb *elsio = &sp->u.iocb_cmd;\n\n\t\t\tqla2x00_els_dcmd2_free(vha, &elsio->u.els_plogi);\n\t\t\t \n\t\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\t\t\treturn;\n\t\t}\n\t\te->u.iosb.sp = sp;\n\t\tqla2x00_post_work(vha, e);\n\t}\n}\n\nint\nqla24xx_els_dcmd2_iocb(scsi_qla_host_t *vha, int els_opcode,\n    fc_port_t *fcport, bool wait)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *elsio = NULL;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_SUCCESS;\n\tvoid\t*ptr, *resp_ptr;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp) {\n\t\tql_log(ql_log_info, vha, 0x70e6,\n\t\t \"SRB allocation failed\\n\");\n\t\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\t\treturn -ENOMEM;\n\t}\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_PEND);\n\telsio = &sp->u.iocb_cmd;\n\tql_dbg(ql_dbg_io, vha, 0x3073,\n\t       \"%s Enter: PLOGI portid=%06x\\n\", __func__, fcport->d_id.b24);\n\n\tif (wait)\n\t\tsp->flags = SRB_WAKEUP_ON_COMP;\n\n\tsp->type = SRB_ELS_DCMD;\n\tsp->name = \"ELS_DCMD\";\n\tsp->fcport = fcport;\n\tqla2x00_init_async_sp(sp, ELS_DCMD_TIMEOUT + 2,\n\t\t\t     qla2x00_els_dcmd2_sp_done);\n\tsp->u.iocb_cmd.timeout = qla2x00_els_dcmd2_iocb_timeout;\n\n\telsio->u.els_plogi.tx_size = elsio->u.els_plogi.rx_size = DMA_POOL_SIZE;\n\n\tptr = elsio->u.els_plogi.els_plogi_pyld =\n\t    dma_alloc_coherent(&ha->pdev->dev, elsio->u.els_plogi.tx_size,\n\t\t&elsio->u.els_plogi.els_plogi_pyld_dma, GFP_KERNEL);\n\n\tif (!elsio->u.els_plogi.els_plogi_pyld) {\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto out;\n\t}\n\n\tresp_ptr = elsio->u.els_plogi.els_resp_pyld =\n\t    dma_alloc_coherent(&ha->pdev->dev, elsio->u.els_plogi.rx_size,\n\t\t&elsio->u.els_plogi.els_resp_pyld_dma, GFP_KERNEL);\n\n\tif (!elsio->u.els_plogi.els_resp_pyld) {\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto out;\n\t}\n\n\tql_dbg(ql_dbg_io, vha, 0x3073, \"PLOGI %p %p\\n\", ptr, resp_ptr);\n\n\tmemset(ptr, 0, sizeof(struct els_plogi_payload));\n\tmemset(resp_ptr, 0, sizeof(struct els_plogi_payload));\n\tmemcpy(elsio->u.els_plogi.els_plogi_pyld->data,\n\t       (void *)&ha->plogi_els_payld + offsetof(struct fc_els_flogi, fl_csp),\n\t       sizeof(ha->plogi_els_payld) - offsetof(struct fc_els_flogi, fl_csp));\n\n\telsio->u.els_plogi.els_cmd = els_opcode;\n\telsio->u.els_plogi.els_plogi_pyld->opcode = els_opcode;\n\n\tif (els_opcode == ELS_DCMD_PLOGI && DBELL_ACTIVE(vha)) {\n\t\tstruct fc_els_flogi *p = ptr;\n\n\t\tp->fl_csp.sp_features |= cpu_to_be16(FC_SP_FT_SEC);\n\t}\n\n\tql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x3073, \"PLOGI buffer:\\n\");\n\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x0109,\n\t    (uint8_t *)elsio->u.els_plogi.els_plogi_pyld,\n\t    sizeof(*elsio->u.els_plogi.els_plogi_pyld));\n\n\tinit_completion(&elsio->u.els_plogi.comp);\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x3074,\n\t\t    \"%s PLOGI sent, hdl=%x, loopid=%x, to port_id %06x from port_id %06x\\n\",\n\t\t    sp->name, sp->handle, fcport->loop_id,\n\t\t    fcport->d_id.b24, vha->d_id.b24);\n\t}\n\n\tif (wait) {\n\t\twait_for_completion(&elsio->u.els_plogi.comp);\n\n\t\tif (elsio->u.els_plogi.comp_status != CS_COMPLETE)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tgoto done;\n\t}\n\nout:\n\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\tqla2x00_els_dcmd2_free(vha, &elsio->u.els_plogi);\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\n \nvoid qla_els_pt_iocb(struct scsi_qla_host *vha,\n\tstruct els_entry_24xx *els_iocb,\n\tstruct qla_els_pt_arg *a)\n{\n\tels_iocb->entry_type = ELS_IOCB_TYPE;\n\tels_iocb->entry_count = 1;\n\tels_iocb->sys_define = 0;\n\tels_iocb->entry_status = 0;\n\tels_iocb->handle = QLA_SKIP_HANDLE;\n\tels_iocb->nport_handle = a->nport_handle;\n\tels_iocb->rx_xchg_address = a->rx_xchg_address;\n\tels_iocb->tx_dsd_count = cpu_to_le16(1);\n\tels_iocb->vp_index = a->vp_idx;\n\tels_iocb->sof_type = EST_SOFI3;\n\tels_iocb->rx_dsd_count = cpu_to_le16(0);\n\tels_iocb->opcode = a->els_opcode;\n\n\tels_iocb->d_id[0] = a->did.b.al_pa;\n\tels_iocb->d_id[1] = a->did.b.area;\n\tels_iocb->d_id[2] = a->did.b.domain;\n\t \n\tels_iocb->s_id[1] = vha->d_id.b.al_pa;\n\tels_iocb->s_id[2] = vha->d_id.b.area;\n\tels_iocb->s_id[0] = vha->d_id.b.domain;\n\n\tels_iocb->control_flags = cpu_to_le16(a->control_flags);\n\n\tels_iocb->tx_byte_count = cpu_to_le32(a->tx_byte_count);\n\tels_iocb->tx_len = cpu_to_le32(a->tx_len);\n\tput_unaligned_le64(a->tx_addr, &els_iocb->tx_address);\n\n\tels_iocb->rx_byte_count = cpu_to_le32(a->rx_byte_count);\n\tels_iocb->rx_len = cpu_to_le32(a->rx_len);\n\tput_unaligned_le64(a->rx_addr, &els_iocb->rx_address);\n}\n\nstatic void\nqla24xx_els_iocb(srb_t *sp, struct els_entry_24xx *els_iocb)\n{\n\tstruct bsg_job *bsg_job = sp->u.bsg_job;\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\n        els_iocb->entry_type = ELS_IOCB_TYPE;\n        els_iocb->entry_count = 1;\n        els_iocb->sys_define = 0;\n        els_iocb->entry_status = 0;\n        els_iocb->handle = sp->handle;\n\tels_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tels_iocb->tx_dsd_count = cpu_to_le16(bsg_job->request_payload.sg_cnt);\n\tels_iocb->vp_index = sp->vha->vp_idx;\n        els_iocb->sof_type = EST_SOFI3;\n\tels_iocb->rx_dsd_count = cpu_to_le16(bsg_job->reply_payload.sg_cnt);\n\n\tels_iocb->opcode =\n\t    sp->type == SRB_ELS_CMD_RPT ?\n\t    bsg_request->rqst_data.r_els.els_code :\n\t    bsg_request->rqst_data.h_els.command_code;\n\tels_iocb->d_id[0] = sp->fcport->d_id.b.al_pa;\n\tels_iocb->d_id[1] = sp->fcport->d_id.b.area;\n\tels_iocb->d_id[2] = sp->fcport->d_id.b.domain;\n        els_iocb->control_flags = 0;\n        els_iocb->rx_byte_count =\n            cpu_to_le32(bsg_job->reply_payload.payload_len);\n        els_iocb->tx_byte_count =\n            cpu_to_le32(bsg_job->request_payload.payload_len);\n\n\tput_unaligned_le64(sg_dma_address(bsg_job->request_payload.sg_list),\n\t\t\t   &els_iocb->tx_address);\n        els_iocb->tx_len = cpu_to_le32(sg_dma_len\n            (bsg_job->request_payload.sg_list));\n\n\tput_unaligned_le64(sg_dma_address(bsg_job->reply_payload.sg_list),\n\t\t\t   &els_iocb->rx_address);\n        els_iocb->rx_len = cpu_to_le32(sg_dma_len\n            (bsg_job->reply_payload.sg_list));\n\n\tsp->vha->qla_stats.control_requests++;\n}\n\nstatic void\nqla2x00_ct_iocb(srb_t *sp, ms_iocb_entry_t *ct_iocb)\n{\n\tuint16_t        avail_dsds;\n\tstruct dsd64\t*cur_dsd;\n\tstruct scatterlist *sg;\n\tint index;\n\tuint16_t tot_dsds;\n\tscsi_qla_host_t *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct bsg_job *bsg_job = sp->u.bsg_job;\n\tint entry_count = 1;\n\n\tmemset(ct_iocb, 0, sizeof(ms_iocb_entry_t));\n\tct_iocb->entry_type = CT_IOCB_TYPE;\n\tct_iocb->entry_status = 0;\n\tct_iocb->handle1 = sp->handle;\n\tSET_TARGET_ID(ha, ct_iocb->loop_id, sp->fcport->loop_id);\n\tct_iocb->status = cpu_to_le16(0);\n\tct_iocb->control_flags = cpu_to_le16(0);\n\tct_iocb->timeout = 0;\n\tct_iocb->cmd_dsd_count =\n\t    cpu_to_le16(bsg_job->request_payload.sg_cnt);\n\tct_iocb->total_dsd_count =\n\t    cpu_to_le16(bsg_job->request_payload.sg_cnt + 1);\n\tct_iocb->req_bytecount =\n\t    cpu_to_le32(bsg_job->request_payload.payload_len);\n\tct_iocb->rsp_bytecount =\n\t    cpu_to_le32(bsg_job->reply_payload.payload_len);\n\n\tput_unaligned_le64(sg_dma_address(bsg_job->request_payload.sg_list),\n\t\t\t   &ct_iocb->req_dsd.address);\n\tct_iocb->req_dsd.length = ct_iocb->req_bytecount;\n\n\tput_unaligned_le64(sg_dma_address(bsg_job->reply_payload.sg_list),\n\t\t\t   &ct_iocb->rsp_dsd.address);\n\tct_iocb->rsp_dsd.length = ct_iocb->rsp_bytecount;\n\n\tavail_dsds = 1;\n\tcur_dsd = &ct_iocb->rsp_dsd;\n\tindex = 0;\n\ttot_dsds = bsg_job->reply_payload.sg_cnt;\n\n\tfor_each_sg(bsg_job->reply_payload.sg_list, sg, tot_dsds, index) {\n\t\tcont_a64_entry_t *cont_pkt;\n\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type1_iocb(vha,\n\t\t\t    vha->hw->req_q_map[0]);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = 5;\n\t\t\tentry_count++;\n\t\t}\n\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n\tct_iocb->entry_count = entry_count;\n\n\tsp->vha->qla_stats.control_requests++;\n}\n\nstatic void\nqla24xx_ct_iocb(srb_t *sp, struct ct_entry_24xx *ct_iocb)\n{\n\tuint16_t        avail_dsds;\n\tstruct dsd64\t*cur_dsd;\n\tstruct scatterlist *sg;\n\tint index;\n\tuint16_t cmd_dsds, rsp_dsds;\n\tscsi_qla_host_t *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct bsg_job *bsg_job = sp->u.bsg_job;\n\tint entry_count = 1;\n\tcont_a64_entry_t *cont_pkt = NULL;\n\n\tct_iocb->entry_type = CT_IOCB_TYPE;\n        ct_iocb->entry_status = 0;\n        ct_iocb->sys_define = 0;\n        ct_iocb->handle = sp->handle;\n\n\tct_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tct_iocb->vp_index = sp->vha->vp_idx;\n\tct_iocb->comp_status = cpu_to_le16(0);\n\n\tcmd_dsds = bsg_job->request_payload.sg_cnt;\n\trsp_dsds = bsg_job->reply_payload.sg_cnt;\n\n\tct_iocb->cmd_dsd_count = cpu_to_le16(cmd_dsds);\n        ct_iocb->timeout = 0;\n\tct_iocb->rsp_dsd_count = cpu_to_le16(rsp_dsds);\n        ct_iocb->cmd_byte_count =\n            cpu_to_le32(bsg_job->request_payload.payload_len);\n\n\tavail_dsds = 2;\n\tcur_dsd = ct_iocb->dsd;\n\tindex = 0;\n\n\tfor_each_sg(bsg_job->request_payload.sg_list, sg, cmd_dsds, index) {\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type1_iocb(\n\t\t\t    vha, ha->req_q_map[0]);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = 5;\n\t\t\tentry_count++;\n\t\t}\n\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n\n\tindex = 0;\n\n\tfor_each_sg(bsg_job->reply_payload.sg_list, sg, rsp_dsds, index) {\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type1_iocb(vha,\n\t\t\t    ha->req_q_map[0]);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = 5;\n\t\t\tentry_count++;\n\t\t}\n\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n        ct_iocb->entry_count = entry_count;\n}\n\n \nint\nqla82xx_start_scsi(srb_t *sp)\n{\n\tint\t\tnseg;\n\tunsigned long   flags;\n\tstruct scsi_cmnd *cmd;\n\tuint32_t\t*clr_ptr;\n\tuint32_t\thandle;\n\tuint16_t\tcnt;\n\tuint16_t\treq_cnt;\n\tuint16_t\ttot_dsds;\n\tstruct device_reg_82xx __iomem *reg;\n\tuint32_t dbval;\n\t__be32 *fcp_dl;\n\tuint8_t additional_cdb_len;\n\tstruct ct6_dsd *ctx;\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = NULL;\n\tstruct rsp_que *rsp = NULL;\n\tstruct qla_qpair *qpair = sp->qpair;\n\n\t \n\treg = &ha->iobase->isp82;\n\tcmd = GET_CMD_SP(sp);\n\treq = vha->req;\n\trsp = ha->rsp_q_map[0];\n\n\t \n\ttot_dsds = 0;\n\n\tdbval = 0x04 | (ha->portnum << 5);\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (qla2x00_marker(vha, ha->base_qpair,\n\t\t\t0, 0, MK_SYNC_ALL) != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x300c,\n\t\t\t    \"qla2x00_marker failed for cmd=%p.\\n\", cmd);\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t\tvha->marker_needed = 0;\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0)\n\t\tgoto queuing_error;\n\n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t    scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t} else\n\t\tnseg = 0;\n\n\ttot_dsds = nseg;\n\n\tif (tot_dsds > ql2xshiftctondsd) {\n\t\tstruct cmd_type_6 *cmd_pkt;\n\t\tuint16_t more_dsd_lists = 0;\n\t\tstruct dsd_dma *dsd_ptr;\n\t\tuint16_t i;\n\n\t\tmore_dsd_lists = qla24xx_calc_dsd_lists(tot_dsds);\n\t\tif ((more_dsd_lists + qpair->dsd_inuse) >= NUM_DSD_CHAIN) {\n\t\t\tql_dbg(ql_dbg_io, vha, 0x300d,\n\t\t\t    \"Num of DSD list %d is than %d for cmd=%p.\\n\",\n\t\t\t    more_dsd_lists + qpair->dsd_inuse, NUM_DSD_CHAIN,\n\t\t\t    cmd);\n\t\t\tgoto queuing_error;\n\t\t}\n\n\t\tif (more_dsd_lists <= qpair->dsd_avail)\n\t\t\tgoto sufficient_dsds;\n\t\telse\n\t\t\tmore_dsd_lists -= qpair->dsd_avail;\n\n\t\tfor (i = 0; i < more_dsd_lists; i++) {\n\t\t\tdsd_ptr = kzalloc(sizeof(struct dsd_dma), GFP_ATOMIC);\n\t\t\tif (!dsd_ptr) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x300e,\n\t\t\t\t    \"Failed to allocate memory for dsd_dma \"\n\t\t\t\t    \"for cmd=%p.\\n\", cmd);\n\t\t\t\tgoto queuing_error;\n\t\t\t}\n\n\t\t\tdsd_ptr->dsd_addr = dma_pool_alloc(ha->dl_dma_pool,\n\t\t\t\tGFP_ATOMIC, &dsd_ptr->dsd_list_dma);\n\t\t\tif (!dsd_ptr->dsd_addr) {\n\t\t\t\tkfree(dsd_ptr);\n\t\t\t\tql_log(ql_log_fatal, vha, 0x300f,\n\t\t\t\t    \"Failed to allocate memory for dsd_addr \"\n\t\t\t\t    \"for cmd=%p.\\n\", cmd);\n\t\t\t\tgoto queuing_error;\n\t\t\t}\n\t\t\tlist_add_tail(&dsd_ptr->list, &qpair->dsd_list);\n\t\t\tqpair->dsd_avail++;\n\t\t}\n\nsufficient_dsds:\n\t\treq_cnt = 1;\n\n\t\tif (req->cnt < (req_cnt + 2)) {\n\t\t\tcnt = (uint16_t)rd_reg_dword_relaxed(\n\t\t\t\t&reg->req_q_out[0]);\n\t\t\tif (req->ring_index < cnt)\n\t\t\t\treq->cnt = cnt - req->ring_index;\n\t\t\telse\n\t\t\t\treq->cnt = req->length -\n\t\t\t\t\t(req->ring_index - cnt);\n\t\t\tif (req->cnt < (req_cnt + 2))\n\t\t\t\tgoto queuing_error;\n\t\t}\n\n\t\tctx = &sp->u.scmd.ct6_ctx;\n\n\t\tmemset(ctx, 0, sizeof(struct ct6_dsd));\n\t\tctx->fcp_cmnd = dma_pool_zalloc(ha->fcp_cmnd_dma_pool,\n\t\t\tGFP_ATOMIC, &ctx->fcp_cmnd_dma);\n\t\tif (!ctx->fcp_cmnd) {\n\t\t\tql_log(ql_log_fatal, vha, 0x3011,\n\t\t\t    \"Failed to allocate fcp_cmnd for cmd=%p.\\n\", cmd);\n\t\t\tgoto queuing_error;\n\t\t}\n\n\t\t \n\t\tINIT_LIST_HEAD(&ctx->dsd_list);\n\t\tctx->dsd_use_cnt = 0;\n\n\t\tif (cmd->cmd_len > 16) {\n\t\t\tadditional_cdb_len = cmd->cmd_len - 16;\n\t\t\tif ((cmd->cmd_len % 4) != 0) {\n\t\t\t\t \n\t\t\t\tql_log(ql_log_warn, vha, 0x3012,\n\t\t\t\t    \"scsi cmd len %d not multiple of 4 \"\n\t\t\t\t    \"for cmd=%p.\\n\", cmd->cmd_len, cmd);\n\t\t\t\tgoto queuing_error_fcp_cmnd;\n\t\t\t}\n\t\t\tctx->fcp_cmnd_len = 12 + cmd->cmd_len + 4;\n\t\t} else {\n\t\t\tadditional_cdb_len = 0;\n\t\t\tctx->fcp_cmnd_len = 12 + 16 + 4;\n\t\t}\n\n\t\tcmd_pkt = (struct cmd_type_6 *)req->ring_ptr;\n\t\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\t\t \n\t\t \n\t\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\t\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\t\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t\t \n\t\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\t\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\t\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\t\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\t\tcmd_pkt->vp_index = sp->vha->vp_idx;\n\n\t\t \n\t\tif (qla24xx_build_scsi_type_6_iocbs(sp, cmd_pkt, tot_dsds))\n\t\t\tgoto queuing_error_fcp_cmnd;\n\n\t\tint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\n\t\thost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\n\n\t\t \n\t\tint_to_scsilun(cmd->device->lun, &ctx->fcp_cmnd->lun);\n\t\tctx->fcp_cmnd->additional_cdb_len = additional_cdb_len;\n\n\t\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\t\tctx->fcp_cmnd->additional_cdb_len |= 1;\n\t\telse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\t\tctx->fcp_cmnd->additional_cdb_len |= 2;\n\n\t\t \n\t\tif (ha->flags.fcp_prio_enabled)\n\t\t\tctx->fcp_cmnd->task_attribute |=\n\t\t\t    sp->fcport->fcp_prio << 3;\n\n\t\tmemcpy(ctx->fcp_cmnd->cdb, cmd->cmnd, cmd->cmd_len);\n\n\t\tfcp_dl = (__be32 *)(ctx->fcp_cmnd->cdb + 16 +\n\t\t    additional_cdb_len);\n\t\t*fcp_dl = htonl((uint32_t)scsi_bufflen(cmd));\n\n\t\tcmd_pkt->fcp_cmnd_dseg_len = cpu_to_le16(ctx->fcp_cmnd_len);\n\t\tput_unaligned_le64(ctx->fcp_cmnd_dma,\n\t\t\t\t   &cmd_pkt->fcp_cmnd_dseg_address);\n\n\t\tsp->flags |= SRB_FCP_CMND_DMA_VALID;\n\t\tcmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\n\t\t \n\t\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\t\t \n\t\tcmd_pkt->entry_status = (uint8_t) rsp->id;\n\t} else {\n\t\tstruct cmd_type_7 *cmd_pkt;\n\n\t\treq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\t\tif (req->cnt < (req_cnt + 2)) {\n\t\t\tcnt = (uint16_t)rd_reg_dword_relaxed(\n\t\t\t    &reg->req_q_out[0]);\n\t\t\tif (req->ring_index < cnt)\n\t\t\t\treq->cnt = cnt - req->ring_index;\n\t\t\telse\n\t\t\t\treq->cnt = req->length -\n\t\t\t\t\t(req->ring_index - cnt);\n\t\t}\n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\n\t\tcmd_pkt = (struct cmd_type_7 *)req->ring_ptr;\n\t\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\t\t \n\t\t \n\t\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\t\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\t\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t\t \n\t\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\t\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\t\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\t\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\t\tcmd_pkt->vp_index = sp->vha->vp_idx;\n\n\t\tint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\n\t\thost_to_fcp_swap((uint8_t *)&cmd_pkt->lun,\n\t\t    sizeof(cmd_pkt->lun));\n\n\t\t \n\t\tif (ha->flags.fcp_prio_enabled)\n\t\t\tcmd_pkt->task |= sp->fcport->fcp_prio << 3;\n\n\t\t \n\t\tmemcpy(cmd_pkt->fcp_cdb, cmd->cmnd, cmd->cmd_len);\n\t\thost_to_fcp_swap(cmd_pkt->fcp_cdb, sizeof(cmd_pkt->fcp_cdb));\n\n\t\tcmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\n\n\t\t \n\t\tqla24xx_build_scsi_iocbs(sp, cmd_pkt, tot_dsds, req);\n\n\t\t \n\t\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\t\t \n\t\tcmd_pkt->entry_status = (uint8_t) rsp->id;\n\n\t}\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\twmb();\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\tsp->flags |= SRB_DMA_VALID;\n\n\t \n\t \n\tdbval = dbval | (req->id << 8) | (req->ring_index << 16);\n\tif (ql2xdbwr)\n\t\tqla82xx_wr_32(ha, (uintptr_t __force)ha->nxdb_wr_ptr, dbval);\n\telse {\n\t\twrt_reg_dword(ha->nxdb_wr_ptr, dbval);\n\t\twmb();\n\t\twhile (rd_reg_dword(ha->nxdb_rd_ptr) != dbval) {\n\t\t\twrt_reg_dword(ha->nxdb_wr_ptr, dbval);\n\t\t\twmb();\n\t\t}\n\t}\n\n\t \n\tif (vha->flags.process_response_queue &&\n\t    rsp->ring_ptr->signature != RESPONSE_PROCESSED)\n\t\tqla24xx_process_response_queue(vha, rsp);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn QLA_SUCCESS;\n\nqueuing_error_fcp_cmnd:\n\tdma_pool_free(ha->fcp_cmnd_dma_pool, ctx->fcp_cmnd, ctx->fcp_cmnd_dma);\nqueuing_error:\n\tif (tot_dsds)\n\t\tscsi_dma_unmap(cmd);\n\n\tif (sp->u.scmd.crc_ctx) {\n\t\tmempool_free(sp->u.scmd.crc_ctx, ha->ctx_mempool);\n\t\tsp->u.scmd.crc_ctx = NULL;\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\nstatic void\nqla24xx_abort_iocb(srb_t *sp, struct abort_entry_24xx *abt_iocb)\n{\n\tstruct srb_iocb *aio = &sp->u.iocb_cmd;\n\tscsi_qla_host_t *vha = sp->vha;\n\tstruct req_que *req = sp->qpair->req;\n\tsrb_t *orig_sp = sp->cmd_sp;\n\n\tmemset(abt_iocb, 0, sizeof(struct abort_entry_24xx));\n\tabt_iocb->entry_type = ABORT_IOCB_TYPE;\n\tabt_iocb->entry_count = 1;\n\tabt_iocb->handle = make_handle(req->id, sp->handle);\n\tif (sp->fcport) {\n\t\tabt_iocb->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\t\tabt_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;\n\t\tabt_iocb->port_id[1] = sp->fcport->d_id.b.area;\n\t\tabt_iocb->port_id[2] = sp->fcport->d_id.b.domain;\n\t}\n\tabt_iocb->handle_to_abort =\n\t\tmake_handle(le16_to_cpu(aio->u.abt.req_que_no),\n\t\t\t    aio->u.abt.cmd_hndl);\n\tabt_iocb->vp_index = vha->vp_idx;\n\tabt_iocb->req_que_no = aio->u.abt.req_que_no;\n\n\t \n\tif (orig_sp)\n\t\tqla_nvme_abort_set_option(abt_iocb, orig_sp);\n\n\t \n\twmb();\n}\n\nstatic void\nqla2x00_mb_iocb(srb_t *sp, struct mbx_24xx_entry *mbx)\n{\n\tint i, sz;\n\n\tmbx->entry_type = MBX_IOCB_TYPE;\n\tmbx->handle = sp->handle;\n\tsz = min(ARRAY_SIZE(mbx->mb), ARRAY_SIZE(sp->u.iocb_cmd.u.mbx.out_mb));\n\n\tfor (i = 0; i < sz; i++)\n\t\tmbx->mb[i] = sp->u.iocb_cmd.u.mbx.out_mb[i];\n}\n\nstatic void\nqla2x00_ctpthru_cmd_iocb(srb_t *sp, struct ct_entry_24xx *ct_pkt)\n{\n\tsp->u.iocb_cmd.u.ctarg.iocb = ct_pkt;\n\tqla24xx_prep_ms_iocb(sp->vha, &sp->u.iocb_cmd.u.ctarg);\n\tct_pkt->handle = sp->handle;\n}\n\nstatic void qla2x00_send_notify_ack_iocb(srb_t *sp,\n\tstruct nack_to_isp *nack)\n{\n\tstruct imm_ntfy_from_isp *ntfy = sp->u.iocb_cmd.u.nack.ntfy;\n\n\tnack->entry_type = NOTIFY_ACK_TYPE;\n\tnack->entry_count = 1;\n\tnack->ox_id = ntfy->ox_id;\n\n\tnack->u.isp24.handle = sp->handle;\n\tnack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;\n\tif (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {\n\t\tnack->u.isp24.flags = ntfy->u.isp24.flags &\n\t\t\tcpu_to_le16(NOTIFY24XX_FLAGS_PUREX_IOCB);\n\t}\n\tnack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;\n\tnack->u.isp24.status = ntfy->u.isp24.status;\n\tnack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;\n\tnack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;\n\tnack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;\n\tnack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;\n\tnack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;\n\tnack->u.isp24.srr_flags = 0;\n\tnack->u.isp24.srr_reject_code = 0;\n\tnack->u.isp24.srr_reject_code_expl = 0;\n\tnack->u.isp24.vp_index = ntfy->u.isp24.vp_index;\n\n\tif (ntfy->u.isp24.status_subcode == ELS_PLOGI &&\n\t    (le16_to_cpu(ntfy->u.isp24.flags) & NOTIFY24XX_FLAGS_FCSP) &&\n\t    sp->vha->hw->flags.edif_enabled) {\n\t\tql_dbg(ql_dbg_disc, sp->vha, 0x3074,\n\t\t    \"%s PLOGI NACK sent with FC SECURITY bit, hdl=%x, loopid=%x, to pid %06x\\n\",\n\t\t    sp->name, sp->handle, sp->fcport->loop_id,\n\t\t    sp->fcport->d_id.b24);\n\t\tnack->u.isp24.flags |= cpu_to_le16(NOTIFY_ACK_FLAGS_FCSP);\n\t}\n}\n\n \nstatic void\nqla_nvme_ls(srb_t *sp, struct pt_ls4_request *cmd_pkt)\n{\n\tstruct srb_iocb *nvme;\n\n\tnvme = &sp->u.iocb_cmd;\n\tcmd_pkt->entry_type = PT_LS4_REQUEST;\n\tcmd_pkt->entry_count = 1;\n\tcmd_pkt->timeout = cpu_to_le16(nvme->u.nvme.timeout_sec);\n\tcmd_pkt->vp_index = sp->fcport->vha->vp_idx;\n\n\tif (sp->unsol_rsp) {\n\t\tcmd_pkt->control_flags =\n\t\t\t\tcpu_to_le16(CF_LS4_RESPONDER << CF_LS4_SHIFT);\n\t\tcmd_pkt->nport_handle = nvme->u.nvme.nport_handle;\n\t\tcmd_pkt->exchange_address = nvme->u.nvme.exchange_address;\n\t} else {\n\t\tcmd_pkt->control_flags =\n\t\t\t\tcpu_to_le16(CF_LS4_ORIGINATOR << CF_LS4_SHIFT);\n\t\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\t\tcmd_pkt->rx_dseg_count = cpu_to_le16(1);\n\t\tcmd_pkt->rx_byte_count = nvme->u.nvme.rsp_len;\n\t\tcmd_pkt->dsd[1].length  = nvme->u.nvme.rsp_len;\n\t\tput_unaligned_le64(nvme->u.nvme.rsp_dma, &cmd_pkt->dsd[1].address);\n\t}\n\n\tcmd_pkt->tx_dseg_count = cpu_to_le16(1);\n\tcmd_pkt->tx_byte_count = nvme->u.nvme.cmd_len;\n\tcmd_pkt->dsd[0].length = nvme->u.nvme.cmd_len;\n\tput_unaligned_le64(nvme->u.nvme.cmd_dma, &cmd_pkt->dsd[0].address);\n}\n\nstatic void\nqla25xx_ctrlvp_iocb(srb_t *sp, struct vp_ctrl_entry_24xx *vce)\n{\n\tint map, pos;\n\n\tvce->entry_type = VP_CTRL_IOCB_TYPE;\n\tvce->handle = sp->handle;\n\tvce->entry_count = 1;\n\tvce->command = cpu_to_le16(sp->u.iocb_cmd.u.ctrlvp.cmd);\n\tvce->vp_count = cpu_to_le16(1);\n\n\t \n\tmap = (sp->u.iocb_cmd.u.ctrlvp.vp_index - 1) / 8;\n\tpos = (sp->u.iocb_cmd.u.ctrlvp.vp_index - 1) & 7;\n\tvce->vp_idx_map[map] |= 1 << pos;\n}\n\nstatic void\nqla24xx_prlo_iocb(srb_t *sp, struct logio_entry_24xx *logio)\n{\n\tlogio->entry_type = LOGINOUT_PORT_IOCB_TYPE;\n\tlogio->control_flags =\n\t    cpu_to_le16(LCF_COMMAND_PRLO|LCF_IMPL_PRLO);\n\n\tlogio->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tlogio->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tlogio->port_id[1] = sp->fcport->d_id.b.area;\n\tlogio->port_id[2] = sp->fcport->d_id.b.domain;\n\tlogio->vp_index = sp->fcport->vha->vp_idx;\n}\n\nstatic int qla_get_iocbs_resource(struct srb *sp)\n{\n\tbool get_exch;\n\tbool push_it_through = false;\n\n\tif (!ql2xenforce_iocb_limit) {\n\t\tsp->iores.res_type = RESOURCE_NONE;\n\t\treturn 0;\n\t}\n\tsp->iores.res_type = RESOURCE_NONE;\n\n\tswitch (sp->type) {\n\tcase SRB_TM_CMD:\n\tcase SRB_PRLI_CMD:\n\tcase SRB_ADISC_CMD:\n\t\tpush_it_through = true;\n\t\tfallthrough;\n\tcase SRB_LOGIN_CMD:\n\tcase SRB_ELS_CMD_RPT:\n\tcase SRB_ELS_CMD_HST:\n\tcase SRB_ELS_CMD_HST_NOLOGIN:\n\tcase SRB_CT_CMD:\n\tcase SRB_NVME_LS:\n\tcase SRB_ELS_DCMD:\n\t\tget_exch = true;\n\t\tbreak;\n\n\tcase SRB_FXIOCB_DCMD:\n\tcase SRB_FXIOCB_BCMD:\n\t\tsp->iores.res_type = RESOURCE_NONE;\n\t\treturn 0;\n\n\tcase SRB_SA_UPDATE:\n\tcase SRB_SA_REPLACE:\n\tcase SRB_MB_IOCB:\n\tcase SRB_ABT_CMD:\n\tcase SRB_NACK_PLOGI:\n\tcase SRB_NACK_PRLI:\n\tcase SRB_NACK_LOGO:\n\tcase SRB_LOGOUT_CMD:\n\tcase SRB_CTRL_VP:\n\tcase SRB_MARKER:\n\tdefault:\n\t\tpush_it_through = true;\n\t\tget_exch = false;\n\t}\n\n\tsp->iores.res_type |= RESOURCE_IOCB;\n\tsp->iores.iocb_cnt = 1;\n\tif (get_exch) {\n\t\tsp->iores.res_type |= RESOURCE_EXCH;\n\t\tsp->iores.exch_cnt = 1;\n\t}\n\tif (push_it_through)\n\t\tsp->iores.res_type |= RESOURCE_FORCE;\n\n\treturn qla_get_fw_resources(sp->qpair, &sp->iores);\n}\n\nstatic void\nqla_marker_iocb(srb_t *sp, struct mrk_entry_24xx *mrk)\n{\n\tmrk->entry_type = MARKER_TYPE;\n\tmrk->modifier = sp->u.iocb_cmd.u.tmf.modifier;\n\tmrk->handle = make_handle(sp->qpair->req->id, sp->handle);\n\tif (sp->u.iocb_cmd.u.tmf.modifier != MK_SYNC_ALL) {\n\t\tmrk->nport_handle = cpu_to_le16(sp->u.iocb_cmd.u.tmf.loop_id);\n\t\tint_to_scsilun(sp->u.iocb_cmd.u.tmf.lun, (struct scsi_lun *)&mrk->lun);\n\t\thost_to_fcp_swap(mrk->lun, sizeof(mrk->lun));\n\t\tmrk->vp_index = sp->u.iocb_cmd.u.tmf.vp_index;\n\t}\n}\n\nint\nqla2x00_start_sp(srb_t *sp)\n{\n\tint rval = QLA_SUCCESS;\n\tscsi_qla_host_t *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_qpair *qp = sp->qpair;\n\tvoid *pkt;\n\tunsigned long flags;\n\n\tif (vha->hw->flags.eeh_busy)\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(qp->qp_lock_ptr, flags);\n\trval = qla_get_iocbs_resource(sp);\n\tif (rval) {\n\t\tspin_unlock_irqrestore(qp->qp_lock_ptr, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tpkt = __qla2x00_alloc_iocbs(sp->qpair, sp);\n\tif (!pkt) {\n\t\trval = -EAGAIN;\n\t\tql_log(ql_log_warn, vha, 0x700c,\n\t\t    \"qla2x00_alloc_iocbs failed.\\n\");\n\t\tgoto done;\n\t}\n\n\tswitch (sp->type) {\n\tcase SRB_LOGIN_CMD:\n\t\tIS_FWI2_CAPABLE(ha) ?\n\t\t    qla24xx_login_iocb(sp, pkt) :\n\t\t    qla2x00_login_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_PRLI_CMD:\n\t\tqla24xx_prli_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_LOGOUT_CMD:\n\t\tIS_FWI2_CAPABLE(ha) ?\n\t\t    qla24xx_logout_iocb(sp, pkt) :\n\t\t    qla2x00_logout_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_ELS_CMD_RPT:\n\tcase SRB_ELS_CMD_HST:\n\t\tqla24xx_els_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_ELS_CMD_HST_NOLOGIN:\n\t\tqla_els_pt_iocb(sp->vha, pkt,  &sp->u.bsg_cmd.u.els_arg);\n\t\t((struct els_entry_24xx *)pkt)->handle = sp->handle;\n\t\tbreak;\n\tcase SRB_CT_CMD:\n\t\tIS_FWI2_CAPABLE(ha) ?\n\t\t    qla24xx_ct_iocb(sp, pkt) :\n\t\t    qla2x00_ct_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_ADISC_CMD:\n\t\tIS_FWI2_CAPABLE(ha) ?\n\t\t    qla24xx_adisc_iocb(sp, pkt) :\n\t\t    qla2x00_adisc_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_TM_CMD:\n\t\tIS_QLAFX00(ha) ?\n\t\t    qlafx00_tm_iocb(sp, pkt) :\n\t\t    qla24xx_tm_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_FXIOCB_DCMD:\n\tcase SRB_FXIOCB_BCMD:\n\t\tqlafx00_fxdisc_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_NVME_LS:\n\t\tqla_nvme_ls(sp, pkt);\n\t\tbreak;\n\tcase SRB_ABT_CMD:\n\t\tIS_QLAFX00(ha) ?\n\t\t\tqlafx00_abort_iocb(sp, pkt) :\n\t\t\tqla24xx_abort_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_ELS_DCMD:\n\t\tqla24xx_els_logo_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_CT_PTHRU_CMD:\n\t\tqla2x00_ctpthru_cmd_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_MB_IOCB:\n\t\tqla2x00_mb_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_NACK_PLOGI:\n\tcase SRB_NACK_PRLI:\n\tcase SRB_NACK_LOGO:\n\t\tqla2x00_send_notify_ack_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_CTRL_VP:\n\t\tqla25xx_ctrlvp_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_PRLO_CMD:\n\t\tqla24xx_prlo_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_SA_UPDATE:\n\t\tqla24xx_sa_update_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_SA_REPLACE:\n\t\tqla24xx_sa_replace_iocb(sp, pkt);\n\t\tbreak;\n\tcase SRB_MARKER:\n\t\tqla_marker_iocb(sp, pkt);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sp->start_timer) {\n\t\t \n\t\tkref_get(&sp->cmd_kref);\n\t\tadd_timer(&sp->u.iocb_cmd.timer);\n\t}\n\n\twmb();\n\tqla2x00_start_iocbs(vha, qp->req);\ndone:\n\tif (rval)\n\t\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\tspin_unlock_irqrestore(qp->qp_lock_ptr, flags);\n\treturn rval;\n}\n\nstatic void\nqla25xx_build_bidir_iocb(srb_t *sp, struct scsi_qla_host *vha,\n\t\t\t\tstruct cmd_bidir *cmd_pkt, uint32_t tot_dsds)\n{\n\tuint16_t avail_dsds;\n\tstruct dsd64 *cur_dsd;\n\tuint32_t req_data_len = 0;\n\tuint32_t rsp_data_len = 0;\n\tstruct scatterlist *sg;\n\tint index;\n\tint entry_count = 1;\n\tstruct bsg_job *bsg_job = sp->u.bsg_job;\n\n\t \n\tput_unaligned_le32(COMMAND_BIDIRECTIONAL, &cmd_pkt->entry_type);\n\n\t \n\tcmd_pkt->wr_dseg_count = cpu_to_le16(bsg_job->request_payload.sg_cnt);\n\tcmd_pkt->rd_dseg_count = cpu_to_le16(bsg_job->reply_payload.sg_cnt);\n\tcmd_pkt->control_flags = cpu_to_le16(BD_WRITE_DATA | BD_READ_DATA |\n\t\t\t\t\t\t\tBD_WRAP_BACK);\n\n\treq_data_len = rsp_data_len = bsg_job->request_payload.payload_len;\n\tcmd_pkt->wr_byte_count = cpu_to_le32(req_data_len);\n\tcmd_pkt->rd_byte_count = cpu_to_le32(rsp_data_len);\n\tcmd_pkt->timeout = cpu_to_le16(qla2x00_get_async_timeout(vha) + 2);\n\n\tvha->bidi_stats.transfer_bytes += req_data_len;\n\tvha->bidi_stats.io_count++;\n\n\tvha->qla_stats.output_bytes += req_data_len;\n\tvha->qla_stats.output_requests++;\n\n\t \n\tavail_dsds = 1;\n\tcur_dsd = &cmd_pkt->fcp_dsd;\n\n\tindex = 0;\n\n\tfor_each_sg(bsg_job->request_payload.sg_list, sg,\n\t\t\t\tbsg_job->request_payload.sg_cnt, index) {\n\t\tcont_a64_entry_t *cont_pkt;\n\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = 5;\n\t\t\tentry_count++;\n\t\t}\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n\t \n\tfor_each_sg(bsg_job->reply_payload.sg_list, sg,\n\t\t\t\tbsg_job->reply_payload.sg_cnt, index) {\n\t\tcont_a64_entry_t *cont_pkt;\n\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type1_iocb(vha, vha->req);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = 5;\n\t\t\tentry_count++;\n\t\t}\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n\t \n\tcmd_pkt->entry_count = entry_count;\n}\n\nint\nqla2x00_start_bidir(srb_t *sp, struct scsi_qla_host *vha, uint32_t tot_dsds)\n{\n\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\tuint32_t handle;\n\tuint16_t req_cnt;\n\tuint16_t cnt;\n\tuint32_t *clr_ptr;\n\tstruct cmd_bidir *cmd_pkt = NULL;\n\tstruct rsp_que *rsp;\n\tstruct req_que *req;\n\tint rval = EXT_STATUS_OK;\n\n\trval = QLA_SUCCESS;\n\n\trsp = ha->rsp_q_map[0];\n\treq = vha->req;\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (qla2x00_marker(vha, ha->base_qpair,\n\t\t\t0, 0, MK_SYNC_ALL) != QLA_SUCCESS)\n\t\t\treturn EXT_STATUS_MAILBOX;\n\t\tvha->marker_needed = 0;\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0) {\n\t\trval = EXT_STATUS_BUSY;\n\t\tgoto queuing_error;\n\t}\n\n\t \n\treq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\n\t \n\tif (req->cnt < req_cnt + 2) {\n\t\tif (IS_SHADOW_REG_CAPABLE(ha)) {\n\t\t\tcnt = *req->out_ptr;\n\t\t} else {\n\t\t\tcnt = rd_reg_dword_relaxed(req->req_q_out);\n\t\t\tif (qla2x00_check_reg16_for_disconnect(vha, cnt))\n\t\t\t\tgoto queuing_error;\n\t\t}\n\n\t\tif  (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t\t(req->ring_index - cnt);\n\t}\n\tif (req->cnt < req_cnt + 2) {\n\t\trval = EXT_STATUS_BUSY;\n\t\tgoto queuing_error;\n\t}\n\n\tcmd_pkt = (struct cmd_bidir *)req->ring_ptr;\n\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\t \n\t \n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\n\t \n\tcmd_pkt->nport_handle = cpu_to_le16(vha->self_login_loop_id);\n\tcmd_pkt->port_id[0] = vha->d_id.b.al_pa;\n\tcmd_pkt->port_id[1] = vha->d_id.b.area;\n\tcmd_pkt->port_id[2] = vha->d_id.b.domain;\n\n\tqla25xx_build_bidir_iocb(sp, vha, cmd_pkt, tot_dsds);\n\tcmd_pkt->entry_status = (uint8_t) rsp->id;\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\treq->cnt -= req_cnt;\n\n\t \n\twmb();\n\tqla2x00_start_iocbs(vha, req);\nqueuing_error:\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn rval;\n}\n\n \nstatic int\nqla_start_scsi_type6(srb_t *sp)\n{\n\tint\t\tnseg;\n\tunsigned long   flags;\n\tuint32_t\t*clr_ptr;\n\tuint32_t\thandle;\n\tstruct cmd_type_6 *cmd_pkt;\n\tuint16_t\tcnt;\n\tuint16_t\treq_cnt;\n\tuint16_t\ttot_dsds;\n\tstruct req_que *req = NULL;\n\tstruct rsp_que *rsp;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tstruct scsi_qla_host *vha = sp->fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_qpair *qpair = sp->qpair;\n\tuint16_t more_dsd_lists = 0;\n\tstruct dsd_dma *dsd_ptr;\n\tuint16_t i;\n\t__be32 *fcp_dl;\n\tuint8_t additional_cdb_len;\n\tstruct ct6_dsd *ctx;\n\n\t \n\tspin_lock_irqsave(&qpair->qp_lock, flags);\n\n\t \n\treq = qpair->req;\n\trsp = qpair->rsp;\n\n\t \n\ttot_dsds = 0;\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (__qla2x00_marker(vha, qpair, 0, 0, MK_SYNC_ALL) != QLA_SUCCESS) {\n\t\t\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t\tvha->marker_needed = 0;\n\t}\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0)\n\t\tgoto queuing_error;\n\n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t\t\t  scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t} else {\n\t\tnseg = 0;\n\t}\n\n\ttot_dsds = nseg;\n\n\t \n\treq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\n\tsp->iores.res_type = RESOURCE_IOCB | RESOURCE_EXCH;\n\tsp->iores.exch_cnt = 1;\n\tsp->iores.iocb_cnt = req_cnt;\n\n\tif (qla_get_fw_resources(sp->qpair, &sp->iores))\n\t\tgoto queuing_error;\n\n\tmore_dsd_lists = qla24xx_calc_dsd_lists(tot_dsds);\n\tif ((more_dsd_lists + qpair->dsd_inuse) >= NUM_DSD_CHAIN) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3028,\n\t\t       \"Num of DSD list %d is than %d for cmd=%p.\\n\",\n\t\t       more_dsd_lists + qpair->dsd_inuse, NUM_DSD_CHAIN, cmd);\n\t\tgoto queuing_error;\n\t}\n\n\tif (more_dsd_lists <= qpair->dsd_avail)\n\t\tgoto sufficient_dsds;\n\telse\n\t\tmore_dsd_lists -= qpair->dsd_avail;\n\n\tfor (i = 0; i < more_dsd_lists; i++) {\n\t\tdsd_ptr = kzalloc(sizeof(*dsd_ptr), GFP_ATOMIC);\n\t\tif (!dsd_ptr) {\n\t\t\tql_log(ql_log_fatal, vha, 0x3029,\n\t\t\t    \"Failed to allocate memory for dsd_dma for cmd=%p.\\n\", cmd);\n\t\t\tgoto queuing_error;\n\t\t}\n\t\tINIT_LIST_HEAD(&dsd_ptr->list);\n\n\t\tdsd_ptr->dsd_addr = dma_pool_alloc(ha->dl_dma_pool,\n\t\t\tGFP_ATOMIC, &dsd_ptr->dsd_list_dma);\n\t\tif (!dsd_ptr->dsd_addr) {\n\t\t\tkfree(dsd_ptr);\n\t\t\tql_log(ql_log_fatal, vha, 0x302a,\n\t\t\t    \"Failed to allocate memory for dsd_addr for cmd=%p.\\n\", cmd);\n\t\t\tgoto queuing_error;\n\t\t}\n\t\tlist_add_tail(&dsd_ptr->list, &qpair->dsd_list);\n\t\tqpair->dsd_avail++;\n\t}\n\nsufficient_dsds:\n\treq_cnt = 1;\n\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tif (IS_SHADOW_REG_CAPABLE(ha)) {\n\t\t\tcnt = *req->out_ptr;\n\t\t} else {\n\t\t\tcnt = (uint16_t)rd_reg_dword_relaxed(req->req_q_out);\n\t\t\tif (qla2x00_check_reg16_for_disconnect(vha, cnt))\n\t\t\t\tgoto queuing_error;\n\t\t}\n\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length - (req->ring_index - cnt);\n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\t}\n\n\tctx = &sp->u.scmd.ct6_ctx;\n\n\tmemset(ctx, 0, sizeof(struct ct6_dsd));\n\tctx->fcp_cmnd = dma_pool_zalloc(ha->fcp_cmnd_dma_pool,\n\t\tGFP_ATOMIC, &ctx->fcp_cmnd_dma);\n\tif (!ctx->fcp_cmnd) {\n\t\tql_log(ql_log_fatal, vha, 0x3031,\n\t\t    \"Failed to allocate fcp_cmnd for cmd=%p.\\n\", cmd);\n\t\tgoto queuing_error;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&ctx->dsd_list);\n\tctx->dsd_use_cnt = 0;\n\n\tif (cmd->cmd_len > 16) {\n\t\tadditional_cdb_len = cmd->cmd_len - 16;\n\t\tif (cmd->cmd_len % 4 ||\n\t\t    cmd->cmd_len > QLA_CDB_BUF_SIZE) {\n\t\t\t \n\t\t\tql_log(ql_log_warn, vha, 0x3033,\n\t\t\t    \"scsi cmd len %d not multiple of 4 for cmd=%p.\\n\",\n\t\t\t    cmd->cmd_len, cmd);\n\t\t\tgoto queuing_error_fcp_cmnd;\n\t\t}\n\t\tctx->fcp_cmnd_len = 12 + cmd->cmd_len + 4;\n\t} else {\n\t\tadditional_cdb_len = 0;\n\t\tctx->fcp_cmnd_len = 12 + 16 + 4;\n\t}\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\n\tcmd_pkt = (struct cmd_type_6 *)req->ring_ptr;\n\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\t \n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t \n\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\tcmd_pkt->vp_index = sp->vha->vp_idx;\n\n\t \n\tqla24xx_build_scsi_type_6_iocbs(sp, cmd_pkt, tot_dsds);\n\n\tint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\n\thost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\n\n\t \n\tint_to_scsilun(cmd->device->lun, &ctx->fcp_cmnd->lun);\n\tctx->fcp_cmnd->additional_cdb_len = additional_cdb_len;\n\n\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tctx->fcp_cmnd->additional_cdb_len |= 1;\n\telse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\tctx->fcp_cmnd->additional_cdb_len |= 2;\n\n\t \n\tif (ha->flags.fcp_prio_enabled)\n\t\tctx->fcp_cmnd->task_attribute |=\n\t\t    sp->fcport->fcp_prio << 3;\n\n\tmemcpy(ctx->fcp_cmnd->cdb, cmd->cmnd, cmd->cmd_len);\n\n\tfcp_dl = (__be32 *)(ctx->fcp_cmnd->cdb + 16 +\n\t    additional_cdb_len);\n\t*fcp_dl = htonl((uint32_t)scsi_bufflen(cmd));\n\n\tcmd_pkt->fcp_cmnd_dseg_len = cpu_to_le16(ctx->fcp_cmnd_len);\n\tput_unaligned_le64(ctx->fcp_cmnd_dma,\n\t\t\t   &cmd_pkt->fcp_cmnd_dseg_address);\n\n\tsp->flags |= SRB_FCP_CMND_DMA_VALID;\n\tcmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\n\t \n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\n\twmb();\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else {\n\t\treq->ring_ptr++;\n\t}\n\n\tsp->qpair->cmd_cnt++;\n\tsp->flags |= SRB_DMA_VALID;\n\n\t \n\twrt_reg_dword(req->req_q_in, req->ring_index);\n\n\t \n\tif (vha->flags.process_response_queue &&\n\t    rsp->ring_ptr->signature != RESPONSE_PROCESSED)\n\t\tqla24xx_process_response_queue(vha, rsp);\n\n\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\n\treturn QLA_SUCCESS;\n\nqueuing_error_fcp_cmnd:\n\tdma_pool_free(ha->fcp_cmnd_dma_pool, ctx->fcp_cmnd, ctx->fcp_cmnd_dma);\n\nqueuing_error:\n\tif (tot_dsds)\n\t\tscsi_dma_unmap(cmd);\n\n\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\n\tif (sp->u.scmd.crc_ctx) {\n\t\tmempool_free(sp->u.scmd.crc_ctx, ha->ctx_mempool);\n\t\tsp->u.scmd.crc_ctx = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\n\treturn QLA_FUNCTION_FAILED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}