{
  "module_name": "qla_mr.c",
  "hash_id": "bae507db0229e6005a822fbde39e1be0c5ff1a225e8bfb8e1aa67d115e0d82de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_mr.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include <linux/delay.h>\n#include <linux/ktime.h>\n#include <linux/pci.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n#include <scsi/scsi_tcq.h>\n#include <linux/utsname.h>\n\n\n \n\n \nstatic int\nqlafx00_mailbox_command(scsi_qla_host_t *vha, struct mbx_cmd_32 *mcp)\n\n{\n\tint\t\trval;\n\tunsigned long    flags = 0;\n\tdevice_reg_t *reg;\n\tuint8_t\t\tabort_active;\n\tuint8_t\t\tio_lock_on;\n\tuint16_t\tcommand = 0;\n\tuint32_t\t*iptr;\n\t__le32 __iomem *optr;\n\tuint32_t\tcnt;\n\tuint32_t\tmboxes;\n\tunsigned long\twait_time;\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\tif (ha->pdev->error_state == pci_channel_io_perm_failure) {\n\t\tql_log(ql_log_warn, vha, 0x115c,\n\t\t    \"PCI channel failed permanently, exiting.\\n\");\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tif (vha->device_flags & DFLG_DEV_FAILED) {\n\t\tql_log(ql_log_warn, vha, 0x115f,\n\t\t    \"Device in failed state, exiting.\\n\");\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\treg = ha->iobase;\n\tio_lock_on = base_vha->flags.init_done;\n\n\trval = QLA_SUCCESS;\n\tabort_active = test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n\n\tif (ha->flags.pci_channel_io_perm_failure) {\n\t\tql_log(ql_log_warn, vha, 0x1175,\n\t\t    \"Perm failure on EEH timeout MBX, exiting.\\n\");\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tif (ha->flags.isp82xx_fw_hung) {\n\t\t \n\t\tmcp->mb[0] = MBS_LINK_DOWN_ERROR;\n\t\tql_log(ql_log_warn, vha, 0x1176,\n\t\t    \"FW hung = %d.\\n\", ha->flags.isp82xx_fw_hung);\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto premature_exit;\n\t}\n\n\t \n\tif (!wait_for_completion_timeout(&ha->mbx_cmd_comp, mcp->tov * HZ)) {\n\t\t \n\t\tql_log(ql_log_warn, vha, 0x1177,\n\t\t    \"Cmd access timeout, cmd=0x%x, Exiting.\\n\",\n\t\t    mcp->mb[0]);\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tha->flags.mbox_busy = 1;\n\t \n\tha->mcp32 = mcp;\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1178,\n\t    \"Prepare to issue mbox cmd=0x%x.\\n\", mcp->mb[0]);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t \n\toptr = &reg->ispfx00.mailbox0;\n\n\tiptr = mcp->mb;\n\tcommand = mcp->mb[0];\n\tmboxes = mcp->out_mb;\n\n\tfor (cnt = 0; cnt < ha->mbx_count; cnt++) {\n\t\tif (mboxes & BIT_0)\n\t\t\twrt_reg_dword(optr, *iptr);\n\n\t\tmboxes >>= 1;\n\t\toptr++;\n\t\tiptr++;\n\t}\n\n\t \n\tha->flags.mbox_int = 0;\n\tclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\n\n\tql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1172,\n\t    (uint8_t *)mcp->mb, 16);\n\tql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1173,\n\t    ((uint8_t *)mcp->mb + 0x10), 16);\n\tql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1174,\n\t    ((uint8_t *)mcp->mb + 0x20), 8);\n\n\t \n\tql_dbg(ql_dbg_mbx, vha, 0x1179,\n\t    \"Going to unlock irq & waiting for interrupts. \"\n\t    \"jiffies=%lx.\\n\", jiffies);\n\n\t \n\tif ((!abort_active && io_lock_on) || IS_NOPOLLING_TYPE(ha)) {\n\t\tset_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\n\n\t\tQLAFX00_SET_HST_INTR(ha, ha->mbx_intr_code);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tWARN_ON_ONCE(wait_for_completion_timeout(&ha->mbx_intr_comp,\n\t\t\t\t\t\t\t mcp->tov * HZ) != 0);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x112c,\n\t\t    \"Cmd=%x Polling Mode.\\n\", command);\n\n\t\tQLAFX00_SET_HST_INTR(ha, ha->mbx_intr_code);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\twait_time = jiffies + mcp->tov * HZ;  \n\t\twhile (!ha->flags.mbox_int) {\n\t\t\tif (time_after(jiffies, wait_time))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tqla2x00_poll(ha->rsp_q_map[0]);\n\n\t\t\tif (!ha->flags.mbox_int &&\n\t\t\t    !(IS_QLA2200(ha) &&\n\t\t\t    command == MBC_LOAD_RISC_RAM_EXTENDED))\n\t\t\t\tusleep_range(10000, 11000);\n\t\t}  \n\t\tql_dbg(ql_dbg_mbx, vha, 0x112d,\n\t\t    \"Waited %d sec.\\n\",\n\t\t    (uint)((jiffies - (wait_time - (mcp->tov * HZ)))/HZ));\n\t}\n\n\t \n\tif (ha->flags.mbox_int) {\n\t\tuint32_t *iptr2;\n\n\t\tql_dbg(ql_dbg_mbx, vha, 0x112e,\n\t\t    \"Cmd=%x completed.\\n\", command);\n\n\t\t \n\t\tha->flags.mbox_int = 0;\n\t\tclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\n\n\t\tif (ha->mailbox_out32[0] != MBS_COMMAND_COMPLETE)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\n\t\t \n\t\tiptr2 = mcp->mb;\n\t\tiptr = (uint32_t *)&ha->mailbox_out32[0];\n\t\tmboxes = mcp->in_mb;\n\t\tfor (cnt = 0; cnt < ha->mbx_count; cnt++) {\n\t\t\tif (mboxes & BIT_0)\n\t\t\t\t*iptr2 = *iptr;\n\n\t\t\tmboxes >>= 1;\n\t\t\tiptr2++;\n\t\t\tiptr++;\n\t\t}\n\t} else {\n\n\t\trval = QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tha->flags.mbox_busy = 0;\n\n\t \n\tha->mcp32 = NULL;\n\n\tif ((abort_active || !io_lock_on) && !IS_NOPOLLING_TYPE(ha)) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x113a,\n\t\t    \"checking for additional resp interrupt.\\n\");\n\n\t\t \n\t\tqla2x00_poll(ha->rsp_q_map[0]);\n\t}\n\n\tif (rval == QLA_FUNCTION_TIMEOUT &&\n\t    mcp->mb[0] != MBC_GEN_SYSTEM_ERROR) {\n\t\tif (!io_lock_on || (mcp->flags & IOCTL_CMD) ||\n\t\t    ha->flags.eeh_busy) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x115d,\n\t\t\t    \"Timeout, schedule isp_abort_needed.\\n\");\n\n\t\t\tif (!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) &&\n\t\t\t    !test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\n\t\t\t    !test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\n\n\t\t\t\tql_log(ql_log_info, base_vha, 0x115e,\n\t\t\t\t    \"Mailbox cmd timeout occurred, cmd=0x%x, \"\n\t\t\t\t    \"mb[0]=0x%x, eeh_busy=0x%x. Scheduling ISP \"\n\t\t\t\t    \"abort.\\n\", command, mcp->mb[0],\n\t\t\t\t    ha->flags.eeh_busy);\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t}\n\t\t} else if (!abort_active) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1160,\n\t\t\t    \"Timeout, calling abort_isp.\\n\");\n\n\t\t\tif (!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) &&\n\t\t\t    !test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\n\t\t\t    !test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\n\n\t\t\t\tql_log(ql_log_info, base_vha, 0x1161,\n\t\t\t\t    \"Mailbox cmd timeout occurred, cmd=0x%x, \"\n\t\t\t\t    \"mb[0]=0x%x. Scheduling ISP abort \",\n\t\t\t\t    command, mcp->mb[0]);\n\n\t\t\t\tset_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\n\t\t\t\tclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t\tif (ha->isp_ops->abort_isp(vha)) {\n\t\t\t\t\t \n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t}\n\t\t\t\tclear_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1162,\n\t\t\t\t    \"Finished abort_isp.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\npremature_exit:\n\t \n\tcomplete(&ha->mbx_cmd_comp);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, base_vha, 0x1163,\n\t\t       \"**** Failed=%x mbx[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x, cmd=%x ****.\\n\",\n\t\t       rval, mcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3],\n\t\t       command);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx, base_vha, 0x1164, \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqlafx00_driver_shutdown(scsi_qla_host_t *vha, int tmo)\n{\n\tint rval;\n\tstruct mbx_cmd_32 mc;\n\tstruct mbx_cmd_32 *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1166,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_MR_DRV_SHUTDOWN;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_0;\n\tif (tmo)\n\t\tmcp->tov = tmo;\n\telse\n\t\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qlafx00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1167,\n\t\t    \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1168,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nstatic int\nqlafx00_get_firmware_state(scsi_qla_host_t *vha, uint32_t *states)\n{\n\tint rval;\n\tstruct mbx_cmd_32 mc;\n\tstruct mbx_cmd_32 *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1169,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_FIRMWARE_STATE;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qlafx00_mailbox_command(vha, mcp);\n\n\t \n\tstates[0] = mcp->mb[1];\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x116a,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x116b,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\treturn rval;\n}\n\n \nint\nqlafx00_init_firmware(scsi_qla_host_t *vha, uint16_t size)\n{\n\tint rval;\n\tstruct mbx_cmd_32 mc;\n\tstruct mbx_cmd_32 *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x116c,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_INITIALIZE_FIRMWARE;\n\n\tmcp->mb[1] = 0;\n\tmcp->mb[2] = MSD(ha->init_cb_dma);\n\tmcp->mb[3] = LSD(ha->init_cb_dma);\n\n\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->buf_size = size;\n\tmcp->flags = MBX_DMA_OUT;\n\tmcp->tov = MBX_TOV_SECONDS;\n\trval = qlafx00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x116d,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x116e,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\treturn rval;\n}\n\n \nstatic int\nqlafx00_mbx_reg_test(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tstruct mbx_cmd_32 mc;\n\tstruct mbx_cmd_32 *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x116f,\n\t    \"Entered %s.\\n\", __func__);\n\n\n\tmcp->mb[0] = MBC_MAILBOX_REGISTER_TEST;\n\tmcp->mb[1] = 0xAAAA;\n\tmcp->mb[2] = 0x5555;\n\tmcp->mb[3] = 0xAA55;\n\tmcp->mb[4] = 0x55AA;\n\tmcp->mb[5] = 0xA5A5;\n\tmcp->mb[6] = 0x5A5A;\n\tmcp->mb[7] = 0x2525;\n\tmcp->mb[8] = 0xBBBB;\n\tmcp->mb[9] = 0x6666;\n\tmcp->mb[10] = 0xBB66;\n\tmcp->mb[11] = 0x66BB;\n\tmcp->mb[12] = 0xB6B6;\n\tmcp->mb[13] = 0x6B6B;\n\tmcp->mb[14] = 0x3636;\n\tmcp->mb[15] = 0xCCCC;\n\n\n\tmcp->out_mb = MBX_15|MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8|\n\t\t\tMBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_15|MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8|\n\t\t\tMBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->buf_size = 0;\n\tmcp->flags = MBX_DMA_OUT;\n\tmcp->tov = MBX_TOV_SECONDS;\n\trval = qlafx00_mailbox_command(vha, mcp);\n\tif (rval == QLA_SUCCESS) {\n\t\tif (mcp->mb[17] != 0xAAAA || mcp->mb[18] != 0x5555 ||\n\t\t    mcp->mb[19] != 0xAA55 || mcp->mb[20] != 0x55AA)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\tif (mcp->mb[21] != 0xA5A5 || mcp->mb[22] != 0x5A5A ||\n\t\t    mcp->mb[23] != 0x2525 || mcp->mb[24] != 0xBBBB)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\tif (mcp->mb[25] != 0x6666 || mcp->mb[26] != 0xBB66 ||\n\t\t    mcp->mb[27] != 0x66BB || mcp->mb[28] != 0xB6B6)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\tif (mcp->mb[29] != 0x6B6B || mcp->mb[30] != 0x3636 ||\n\t\t    mcp->mb[31] != 0xCCCC)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t}\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1170,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1171,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\treturn rval;\n}\n\n \nint\nqlafx00_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t w;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\tw &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\t \n\tif (pci_is_pcie(ha->pdev))\n\t\tpcie_set_readrq(ha->pdev, 2048);\n\n\tha->chip_revision = ha->pdev->revision;\n\n\treturn QLA_SUCCESS;\n}\n\n \nstatic inline void\nqlafx00_soc_cpu_reset(scsi_qla_host_t *vha)\n{\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint i, core;\n\tuint32_t cnt;\n\tuint32_t reg_val;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x80004, 0);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x82004, 0);\n\n\t \n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x60920, 0x02);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x60924, 0x02);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0xf0920, 0x02);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0xf0924, 0x02);\n\n\t \n\treg_val = QLAFX00_GET_HBA_SOC_REG(ha, 0x60840);\n\treg_val &= ~(1<<12);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x60840, reg_val);\n\n\treg_val = QLAFX00_GET_HBA_SOC_REG(ha, 0x60844);\n\treg_val &= ~(1<<12);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x60844, reg_val);\n\n\treg_val = QLAFX00_GET_HBA_SOC_REG(ha, 0x60848);\n\treg_val &= ~(1<<12);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x60848, reg_val);\n\n\treg_val = QLAFX00_GET_HBA_SOC_REG(ha, 0x6084C);\n\treg_val &= ~(1<<12);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x6084C, reg_val);\n\n\tfor (i = 0; i < 100000; i++) {\n\t\tif ((QLAFX00_GET_HBA_SOC_REG(ha, 0xd0000) & 0x10000000) == 0 &&\n\t\t    (QLAFX00_GET_HBA_SOC_REG(ha, 0x10600) & 0x1) == 0)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tQLAFX00_SET_HBA_SOC_REG(ha,\n\t\t    (SOC_SW_RST_CONTROL_REG_CORE0 + 8*i), (0xF01));\n\t\tQLAFX00_SET_HBA_SOC_REG(ha,\n\t\t    (SOC_SW_RST_CONTROL_REG_CORE0 + 4 + 8*i), (0x01010101));\n\t}\n\n\t \n\tQLAFX00_SET_HBA_SOC_REG(ha, SOC_FABRIC_RST_CONTROL_REG, (0x011f0101));\n\n\t \n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x10610, 1);\n\tQLAFX00_SET_HBA_SOC_REG(ha, 0x10600, 0);\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tQLAFX00_SET_HBA_SOC_REG(ha,\n\t\t    (SOC_PWR_MANAGEMENT_PWR_DOWN_REG + 4*i), (0x0));\n\t}\n\n\t \n\tfor (i = 0; i < 115; i++) {\n\t\tQLAFX00_SET_HBA_SOC_REG(ha,\n\t\t    (SOC_INTERRUPT_SOURCE_I_CONTROL_REG + 4*i), (0x0));\n\t}\n\n\t \n\tfor (core = 0; core < 4; core++)\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tQLAFX00_SET_HBA_SOC_REG(ha,\n\t\t\t    (SOC_CORE_TIMER_REG + 0x100*core + 4*i), (0x0));\n\n\t \n\tfor (core = 0; core < 4; core++)\n\t\tQLAFX00_SET_HBA_SOC_REG(ha,\n\t\t    (SOC_IRQ_ACK_REG + 0x100*core), (0x3FF));\n\n\t \n\tQLAFX00_SET_HBA_SOC_REG(ha, SOC_FABRIC_CONTROL_REG, (0x2));\n\tQLAFX00_SET_HBA_SOC_REG(ha, SOC_FABRIC_CONFIG_REG, (0x3));\n\n\t \n\tQLAFX00_SET_HBA_SOC_REG(ha, SOC_FABRIC_RST_CONTROL_REG, (0x0));\n\n\t \n\tQLAFX00_SET_HBA_SOC_REG(ha, SOC_SW_RST_CONTROL_REG_CORE0, (0xF00));\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t \n\tfor (cnt = 10; cnt; cnt--) {\n\t\tmsleep(1000);\n\t\tbarrier();\n\t}\n}\n\n \nint\nqlafx00_soft_reset(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (unlikely(pci_channel_offline(ha->pdev) &&\n\t    ha->flags.pci_channel_io_perm_failure))\n\t\treturn rval;\n\n\tha->isp_ops->disable_intrs(ha);\n\tqlafx00_soc_cpu_reset(vha);\n\n\treturn QLA_SUCCESS;\n}\n\n \nint\nqlafx00_chip_diag(scsi_qla_host_t *vha)\n{\n\tint rval = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\n\tha->fw_transfer_size = REQUEST_ENTRY_SIZE * req->length;\n\n\trval = qlafx00_mbx_reg_test(vha);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x1165,\n\t\t    \"Failed mailbox send register test\\n\");\n\t} else {\n\t\t \n\t\trval = QLA_SUCCESS;\n\t}\n\treturn rval;\n}\n\nvoid\nqlafx00_config_rings(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\n\n\twrt_reg_dword(&reg->req_q_in, 0);\n\twrt_reg_dword(&reg->req_q_out, 0);\n\n\twrt_reg_dword(&reg->rsp_q_in, 0);\n\twrt_reg_dword(&reg->rsp_q_out, 0);\n\n\t \n\trd_reg_dword(&reg->rsp_q_out);\n}\n\nchar *\nqlafx00_pci_info_str(struct scsi_qla_host *vha, char *str, size_t str_len)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (pci_is_pcie(ha->pdev))\n\t\tstrscpy(str, \"PCIe iSA\", str_len);\n\treturn str;\n}\n\nchar *\nqlafx00_fw_version_str(struct scsi_qla_host *vha, char *str, size_t size)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tsnprintf(str, size, \"%s\", ha->mr.fw_version);\n\treturn str;\n}\n\nvoid\nqlafx00_enable_intrs(struct qla_hw_data *ha)\n{\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->interrupts_on = 1;\n\tQLAFX00_ENABLE_ICNTRL_REG(ha);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nvoid\nqlafx00_disable_intrs(struct qla_hw_data *ha)\n{\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->interrupts_on = 0;\n\tQLAFX00_DISABLE_ICNTRL_REG(ha);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nint\nqlafx00_abort_target(fc_port_t *fcport, uint64_t l, int tag)\n{\n\treturn qla2x00_async_tm_cmd(fcport, TCF_TARGET_RESET, l, tag);\n}\n\nint\nqlafx00_lun_reset(fc_port_t *fcport, uint64_t l, int tag)\n{\n\treturn qla2x00_async_tm_cmd(fcport, TCF_LUN_RESET, l, tag);\n}\n\nint\nqlafx00_iospace_config(struct qla_hw_data *ha)\n{\n\tif (pci_request_selected_regions(ha->pdev, ha->bars,\n\t    QLA2XXX_DRIVER_NAME)) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x014e,\n\t\t    \"Failed to reserve PIO/MMIO regions (%s), aborting.\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\t \n\tif (!(pci_resource_flags(ha->pdev, 0) & IORESOURCE_MEM)) {\n\t\tql_log_pci(ql_log_warn, ha->pdev, 0x014f,\n\t\t    \"Invalid pci I/O region size (%s).\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\tif (pci_resource_len(ha->pdev, 0) < BAR0_LEN_FX00) {\n\t\tql_log_pci(ql_log_warn, ha->pdev, 0x0127,\n\t\t    \"Invalid PCI mem BAR0 region size (%s), aborting\\n\",\n\t\t\tpci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\tha->cregbase =\n\t    ioremap(pci_resource_start(ha->pdev, 0), BAR0_LEN_FX00);\n\tif (!ha->cregbase) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0128,\n\t\t    \"cannot remap MMIO (%s), aborting\\n\", pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\tif (!(pci_resource_flags(ha->pdev, 2) & IORESOURCE_MEM)) {\n\t\tql_log_pci(ql_log_warn, ha->pdev, 0x0129,\n\t\t    \"region #2 not an MMIO resource (%s), aborting\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\tif (pci_resource_len(ha->pdev, 2) < BAR2_LEN_FX00) {\n\t\tql_log_pci(ql_log_warn, ha->pdev, 0x012a,\n\t\t    \"Invalid PCI mem BAR2 region size (%s), aborting\\n\",\n\t\t\tpci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\tha->iobase =\n\t    ioremap(pci_resource_start(ha->pdev, 2), BAR2_LEN_FX00);\n\tif (!ha->iobase) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x012b,\n\t\t    \"cannot remap MMIO (%s), aborting\\n\", pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\t \n\tha->max_req_queues = ha->max_rsp_queues = 1;\n\n\tql_log_pci(ql_log_info, ha->pdev, 0x012c,\n\t    \"Bars 0x%x, iobase0 0x%p, iobase2 0x%p\\n\",\n\t    ha->bars, ha->cregbase, ha->iobase);\n\n\treturn 0;\n\niospace_error_exit:\n\treturn -ENOMEM;\n}\n\nstatic void\nqlafx00_save_queue_ptrs(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\n\treq->length_fx00 = req->length;\n\treq->ring_fx00 = req->ring;\n\treq->dma_fx00 = req->dma;\n\n\trsp->length_fx00 = rsp->length;\n\trsp->ring_fx00 = rsp->ring;\n\trsp->dma_fx00 = rsp->dma;\n\n\tql_dbg(ql_dbg_init, vha, 0x012d,\n\t    \"req: %p, ring_fx00: %p, length_fx00: 0x%x,\"\n\t    \"req->dma_fx00: 0x%llx\\n\", req, req->ring_fx00,\n\t    req->length_fx00, (u64)req->dma_fx00);\n\n\tql_dbg(ql_dbg_init, vha, 0x012e,\n\t    \"rsp: %p, ring_fx00: %p, length_fx00: 0x%x,\"\n\t    \"rsp->dma_fx00: 0x%llx\\n\", rsp, rsp->ring_fx00,\n\t    rsp->length_fx00, (u64)rsp->dma_fx00);\n}\n\nstatic int\nqlafx00_config_queues(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\tdma_addr_t bar2_hdl = pci_resource_start(ha->pdev, 2);\n\n\treq->length = ha->req_que_len;\n\treq->ring = (void __force *)ha->iobase + ha->req_que_off;\n\treq->dma = bar2_hdl + ha->req_que_off;\n\tif ((!req->ring) || (req->length == 0)) {\n\t\tql_log_pci(ql_log_info, ha->pdev, 0x012f,\n\t\t    \"Unable to allocate memory for req_ring\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x0130,\n\t    \"req: %p req_ring pointer %p req len 0x%x \"\n\t    \"req off 0x%x\\n, req->dma: 0x%llx\",\n\t    req, req->ring, req->length,\n\t    ha->req_que_off, (u64)req->dma);\n\n\trsp->length = ha->rsp_que_len;\n\trsp->ring = (void __force *)ha->iobase + ha->rsp_que_off;\n\trsp->dma = bar2_hdl + ha->rsp_que_off;\n\tif ((!rsp->ring) || (rsp->length == 0)) {\n\t\tql_log_pci(ql_log_info, ha->pdev, 0x0131,\n\t\t    \"Unable to allocate memory for rsp_ring\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x0132,\n\t    \"rsp: %p rsp_ring pointer %p rsp len 0x%x \"\n\t    \"rsp off 0x%x, rsp->dma: 0x%llx\\n\",\n\t    rsp, rsp->ring, rsp->length,\n\t    ha->rsp_que_off, (u64)rsp->dma);\n\n\treturn QLA_SUCCESS;\n}\n\nstatic int\nqlafx00_init_fw_ready(scsi_qla_host_t *vha)\n{\n\tint rval = 0;\n\tunsigned long wtime;\n\tuint16_t wait_time;\t \n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\n\tuint32_t aenmbx, aenmbx7 = 0;\n\tuint32_t pseudo_aen;\n\tuint32_t state[5];\n\tbool done = false;\n\n\t \n\twait_time = 30;\n\n\tpseudo_aen = rd_reg_dword(&reg->pseudoaen);\n\tif (pseudo_aen == 1) {\n\t\taenmbx7 = rd_reg_dword(&reg->initval7);\n\t\tha->mbx_intr_code = MSW(aenmbx7);\n\t\tha->rqstq_intr_code = LSW(aenmbx7);\n\t\trval = qlafx00_driver_shutdown(vha, 10);\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tqlafx00_soft_reset(vha);\n\t}\n\n\t \n\twtime = jiffies + (wait_time * HZ);\n\tdo {\n\t\taenmbx = rd_reg_dword(&reg->aenmailbox0);\n\t\tbarrier();\n\t\tql_dbg(ql_dbg_mbx, vha, 0x0133,\n\t\t    \"aenmbx: 0x%x\\n\", aenmbx);\n\n\t\tswitch (aenmbx) {\n\t\tcase MBA_FW_NOT_STARTED:\n\t\tcase MBA_FW_STARTING:\n\t\t\tbreak;\n\n\t\tcase MBA_SYSTEM_ERR:\n\t\tcase MBA_REQ_TRANSFER_ERR:\n\t\tcase MBA_RSP_TRANSFER_ERR:\n\t\tcase MBA_FW_INIT_FAILURE:\n\t\t\tqlafx00_soft_reset(vha);\n\t\t\tbreak;\n\n\t\tcase MBA_FW_RESTART_CMPLT:\n\t\t\t \n\t\t\taenmbx7 = rd_reg_dword(&reg->aenmailbox7);\n\t\t\tha->mbx_intr_code = MSW(aenmbx7);\n\t\t\tha->rqstq_intr_code = LSW(aenmbx7);\n\t\t\tha->req_que_off = rd_reg_dword(&reg->aenmailbox1);\n\t\t\tha->rsp_que_off = rd_reg_dword(&reg->aenmailbox3);\n\t\t\tha->req_que_len = rd_reg_dword(&reg->aenmailbox5);\n\t\t\tha->rsp_que_len = rd_reg_dword(&reg->aenmailbox6);\n\t\t\twrt_reg_dword(&reg->aenmailbox0, 0);\n\t\t\trd_reg_dword_relaxed(&reg->aenmailbox0);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0134,\n\t\t\t    \"f/w returned mbx_intr_code: 0x%x, \"\n\t\t\t    \"rqstq_intr_code: 0x%x\\n\",\n\t\t\t    ha->mbx_intr_code, ha->rqstq_intr_code);\n\t\t\tQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\n\t\t\trval = QLA_SUCCESS;\n\t\t\tdone = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif ((aenmbx & 0xFF00) == MBA_FW_INIT_INPROGRESS)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\taenmbx7 = rd_reg_dword(&reg->initval7);\n\t\t\tha->mbx_intr_code = MSW(aenmbx7);\n\t\t\tha->rqstq_intr_code = LSW(aenmbx7);\n\t\t\tha->req_que_off = rd_reg_dword(&reg->initval1);\n\t\t\tha->rsp_que_off = rd_reg_dword(&reg->initval3);\n\t\t\tha->req_que_len = rd_reg_dword(&reg->initval5);\n\t\t\tha->rsp_que_len = rd_reg_dword(&reg->initval6);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0135,\n\t\t\t    \"f/w returned mbx_intr_code: 0x%x, \"\n\t\t\t    \"rqstq_intr_code: 0x%x\\n\",\n\t\t\t    ha->mbx_intr_code, ha->rqstq_intr_code);\n\t\t\tQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\n\n\t\t\t \n\t\t\trval = qlafx00_get_firmware_state(vha, state);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (state[0] == FSTATE_FX00_CONFIG_WAIT) {\n\t\t\t\t \n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tql_dbg(ql_dbg_init, vha, 0x0136,\n\t\t\t    \"Sending Driver shutdown fw_state 0x%x\\n\",\n\t\t\t    state[0]);\n\n\t\t\trval = qlafx00_driver_shutdown(vha, 10);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(500);\n\n\t\t\twtime = jiffies + (wait_time * HZ);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!done) {\n\t\t\tif (time_after_eq(jiffies, wtime)) {\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x0137,\n\t\t\t\t    \"Init f/w failed: aen[7]: 0x%x\\n\",\n\t\t\t\t    rd_reg_dword(&reg->aenmailbox7));\n\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t\tdone = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tmsleep(500);\n\t\t}\n\t} while (!done);\n\n\tif (rval)\n\t\tql_dbg(ql_dbg_init, vha, 0x0138,\n\t\t    \"%s **** FAILED ****.\\n\", __func__);\n\telse\n\t\tql_dbg(ql_dbg_init, vha, 0x0139,\n\t\t    \"%s **** SUCCESS ****.\\n\", __func__);\n\n\treturn rval;\n}\n\n \nint\nqlafx00_fw_ready(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tunsigned long\twtime;\n\tuint16_t\twait_time;\t \n\tuint32_t\tstate[5];\n\n\trval = QLA_SUCCESS;\n\n\twait_time = 10;\n\n\t \n\twtime = jiffies + (wait_time * HZ);\n\n\t \n\tif (!vha->flags.init_done)\n\t\tql_dbg(ql_dbg_init, vha, 0x013a,\n\t\t    \"Waiting for init to complete...\\n\");\n\n\tdo {\n\t\trval = qlafx00_get_firmware_state(vha, state);\n\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tif (state[0] == FSTATE_FX00_INITIALIZED) {\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x013b,\n\t\t\t\t    \"fw_state=%x\\n\", state[0]);\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trval = QLA_FUNCTION_FAILED;\n\n\t\tif (time_after_eq(jiffies, wtime))\n\t\t\tbreak;\n\n\t\t \n\t\tmsleep(500);\n\n\t\tql_dbg(ql_dbg_init, vha, 0x013c,\n\t\t    \"fw_state=%x curr time=%lx.\\n\", state[0], jiffies);\n\t} while (1);\n\n\n\tif (rval)\n\t\tql_dbg(ql_dbg_init, vha, 0x013d,\n\t\t    \"Firmware ready **** FAILED ****.\\n\");\n\telse\n\t\tql_dbg(ql_dbg_init, vha, 0x013e,\n\t\t    \"Firmware ready **** SUCCESS ****.\\n\");\n\n\treturn rval;\n}\n\nstatic int\nqlafx00_find_all_targets(scsi_qla_host_t *vha,\n\tstruct list_head *new_fcports)\n{\n\tint\t\trval;\n\tuint16_t\ttgt_id;\n\tfc_port_t\t*fcport, *new_fcport;\n\tint\t\tfound;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\trval = QLA_SUCCESS;\n\n\tif (!test_bit(LOOP_RESYNC_ACTIVE, &vha->dpc_flags))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif ((atomic_read(&vha->loop_down_timer) ||\n\t     STATE_TRANSITION(vha))) {\n\t\tatomic_set(&vha->loop_down_timer, 0);\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tql_dbg(ql_dbg_disc + ql_dbg_init, vha, 0x2088,\n\t    \"Listing Target bit map...\\n\");\n\tql_dump_buffer(ql_dbg_disc + ql_dbg_init, vha, 0x2089,\n\t    ha->gid_list, 32);\n\n\t \n\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (new_fcport == NULL)\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\n\tfor_each_set_bit(tgt_id, (void *)ha->gid_list,\n\t    QLAFX00_TGT_NODE_LIST_SIZE) {\n\n\t\t \n\t\tnew_fcport->tgt_id = tgt_id;\n\t\trval = qlafx00_fx_disc(vha, new_fcport,\n\t\t    FXDISC_GET_TGT_NODE_INFO);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x208a,\n\t\t\t    \"Target info scan failed -- assuming zero-entry \"\n\t\t\t    \"result...\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfound = 0;\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (memcmp(new_fcport->port_name,\n\t\t\t    fcport->port_name, WWN_SIZE))\n\t\t\t\tcontinue;\n\n\t\t\tfound++;\n\n\t\t\t \n\t\t\tif (fcport->tgt_id == new_fcport->tgt_id &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc + ql_dbg_init, vha, 0x208b,\n\t\t\t    \"TGT-ID Change(%s): Present tgt id: \"\n\t\t\t    \"0x%x state: 0x%x \"\n\t\t\t    \"wwnn = %llx wwpn = %llx.\\n\",\n\t\t\t    __func__, fcport->tgt_id,\n\t\t\t    atomic_read(&fcport->state),\n\t\t\t    (unsigned long long)wwn_to_u64(fcport->node_name),\n\t\t\t    (unsigned long long)wwn_to_u64(fcport->port_name));\n\n\t\t\tql_log(ql_log_info, vha, 0x208c,\n\t\t\t    \"TGT-ID Announce(%s): Discovered tgt \"\n\t\t\t    \"id 0x%x wwnn = %llx \"\n\t\t\t    \"wwpn = %llx.\\n\", __func__, new_fcport->tgt_id,\n\t\t\t    (unsigned long long)\n\t\t\t    wwn_to_u64(new_fcport->node_name),\n\t\t\t    (unsigned long long)\n\t\t\t    wwn_to_u64(new_fcport->port_name));\n\n\t\t\tif (atomic_read(&fcport->state) != FCS_ONLINE) {\n\t\t\t\tfcport->old_tgt_id = fcport->tgt_id;\n\t\t\t\tfcport->tgt_id = new_fcport->tgt_id;\n\t\t\t\tql_log(ql_log_info, vha, 0x208d,\n\t\t\t\t   \"TGT-ID: New fcport Added: %p\\n\", fcport);\n\t\t\t\tqla2x00_update_fcport(vha, fcport);\n\t\t\t} else {\n\t\t\t\tql_log(ql_log_info, vha, 0x208e,\n\t\t\t\t    \" Existing TGT-ID %x did not get \"\n\t\t\t\t    \" offline event from firmware.\\n\",\n\t\t\t\t    fcport->old_tgt_id);\n\t\t\t\tqla2x00_mark_device_lost(vha, fcport, 0);\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tqla2x00_free_fcport(new_fcport);\n\t\t\t\treturn rval;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_add_tail(&new_fcport->list, new_fcports);\n\n\t\t \n\t\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\t\tif (new_fcport == NULL)\n\t\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tqla2x00_free_fcport(new_fcport);\n\treturn rval;\n}\n\n \nstatic int\nqlafx00_configure_all_targets(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tfc_port_t *fcport, *rmptemp;\n\tLIST_HEAD(new_fcports);\n\n\trval = qlafx00_fx_disc(vha, &vha->hw->mr.fcport,\n\t    FXDISC_GET_TGT_NODE_LIST);\n\tif (rval != QLA_SUCCESS) {\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\treturn rval;\n\t}\n\n\trval = qlafx00_find_all_targets(vha, &new_fcports);\n\tif (rval != QLA_SUCCESS) {\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\treturn rval;\n\t}\n\n\t \n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\tbreak;\n\n\t\tif (atomic_read(&fcport->state) == FCS_DEVICE_LOST) {\n\t\t\tif (fcport->port_type != FCT_INITIATOR)\n\t\t\t\tqla2x00_mark_device_lost(vha, fcport, 0);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(fcport, rmptemp, &new_fcports, list) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\tbreak;\n\n\t\tqla2x00_update_fcport(vha, fcport);\n\t\tlist_move_tail(&fcport->list, &vha->vp_fcports);\n\t\tql_log(ql_log_info, vha, 0x208f,\n\t\t    \"Attach new target id 0x%x wwnn = %llx \"\n\t\t    \"wwpn = %llx.\\n\",\n\t\t    fcport->tgt_id,\n\t\t    (unsigned long long)wwn_to_u64(fcport->node_name),\n\t\t    (unsigned long long)wwn_to_u64(fcport->port_name));\n\t}\n\n\t \n\tlist_for_each_entry_safe(fcport, rmptemp, &new_fcports, list) {\n\t\tlist_del(&fcport->list);\n\t\tqla2x00_free_fcport(fcport);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqlafx00_configure_devices(scsi_qla_host_t *vha)\n{\n\tint  rval;\n\tunsigned long flags;\n\n\trval = QLA_SUCCESS;\n\n\tflags = vha->dpc_flags;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2090,\n\t    \"Configure devices -- dpc flags =0x%lx\\n\", flags);\n\n\trval = qlafx00_configure_all_targets(vha);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else {\n\t\t\tatomic_set(&vha->loop_state, LOOP_READY);\n\t\t\tql_log(ql_log_info, vha, 0x2091,\n\t\t\t    \"Device Ready\\n\");\n\t\t}\n\t}\n\n\tif (rval) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2092,\n\t\t    \"%s *** FAILED ***.\\n\", __func__);\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2093,\n\t\t    \"%s: exiting normally.\\n\", __func__);\n\t}\n\treturn rval;\n}\n\nstatic void\nqlafx00_abort_isp_cleanup(scsi_qla_host_t *vha, bool critemp)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tfc_port_t *fcport;\n\n\tvha->flags.online = 0;\n\tha->mr.fw_hbt_en = 0;\n\n\tif (!critemp) {\n\t\tha->flags.chip_reset_done = 0;\n\t\tclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tvha->qla_stats.total_isp_aborts++;\n\t\tql_log(ql_log_info, vha, 0x013f,\n\t\t    \"Performing ISP error recovery - ha = %p.\\n\", ha);\n\t\tha->isp_ops->reset_chip(vha);\n\t}\n\n\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\tatomic_set(&vha->loop_down_timer,\n\t\t    QLAFX00_LOOP_DOWN_TIME);\n\t} else {\n\t\tif (!atomic_read(&vha->loop_down_timer))\n\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t    QLAFX00_LOOP_DOWN_TIME);\n\t}\n\n\t \n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tfcport->flags = 0;\n\t\tif (atomic_read(&fcport->state) == FCS_ONLINE)\n\t\t\tqla2x00_set_fcport_state(fcport, FCS_DEVICE_LOST);\n\t}\n\n\tif (!ha->flags.eeh_busy) {\n\t\tif (critemp) {\n\t\t\tqla2x00_abort_all_cmds(vha, DID_NO_CONNECT << 16);\n\t\t} else {\n\t\t\t \n\t\t\tqla2x00_abort_all_cmds(vha, DID_RESET << 16);\n\t\t}\n\t}\n\n\tqla2x00_free_irqs(vha);\n\tif (critemp)\n\t\tset_bit(FX00_CRITEMP_RECOVERY, &vha->dpc_flags);\n\telse\n\t\tset_bit(FX00_RESET_RECOVERY, &vha->dpc_flags);\n\n\t \n\tQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\n\n\tql_log(ql_log_info, vha, 0x0140,\n\t    \"%s Done done - ha=%p.\\n\", __func__, ha);\n}\n\n \nvoid\nqlafx00_init_response_q_entries(struct rsp_que *rsp)\n{\n\tuint16_t cnt;\n\tresponse_t *pkt;\n\n\trsp->ring_ptr = rsp->ring;\n\trsp->ring_index    = 0;\n\trsp->status_srb = NULL;\n\tpkt = rsp->ring_ptr;\n\tfor (cnt = 0; cnt < rsp->length; cnt++) {\n\t\tpkt->signature = RESPONSE_PROCESSED;\n\t\twrt_reg_dword((void __force __iomem *)&pkt->signature,\n\t\t    RESPONSE_PROCESSED);\n\t\tpkt++;\n\t}\n}\n\nint\nqlafx00_rescan_isp(scsi_qla_host_t *vha)\n{\n\tuint32_t status = QLA_FUNCTION_FAILED;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\n\tuint32_t aenmbx7;\n\n\tqla2x00_request_irqs(ha, ha->rsp_q_map[0]);\n\n\taenmbx7 = rd_reg_dword(&reg->aenmailbox7);\n\tha->mbx_intr_code = MSW(aenmbx7);\n\tha->rqstq_intr_code = LSW(aenmbx7);\n\tha->req_que_off = rd_reg_dword(&reg->aenmailbox1);\n\tha->rsp_que_off = rd_reg_dword(&reg->aenmailbox3);\n\tha->req_que_len = rd_reg_dword(&reg->aenmailbox5);\n\tha->rsp_que_len = rd_reg_dword(&reg->aenmailbox6);\n\n\tql_dbg(ql_dbg_disc, vha, 0x2094,\n\t    \"fw returned mbx_intr_code: 0x%x, rqstq_intr_code: 0x%x \"\n\t    \" Req que offset 0x%x Rsp que offset 0x%x\\n\",\n\t    ha->mbx_intr_code, ha->rqstq_intr_code,\n\t    ha->req_que_off, ha->rsp_que_len);\n\n\t \n\tQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\n\n\tstatus = qla2x00_init_rings(vha);\n\tif (!status) {\n\t\tvha->flags.online = 1;\n\n\t\t \n\t\tif ((vha->device_flags & DFLG_NO_CABLE))\n\t\t\tstatus = 0;\n\t\t \n\t\tif (qlafx00_fx_disc(vha,\n\t\t    &vha->hw->mr.fcport, FXDISC_REG_HOST_INFO))\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2095,\n\t\t\t    \"failed to register host info\\n\");\n\t}\n\tscsi_unblock_requests(vha->host);\n\treturn status;\n}\n\nvoid\nqlafx00_timer_routine(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t fw_heart_beat;\n\tuint32_t aenmbx0;\n\tstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\n\tuint32_t tempc;\n\n\t \n\tif (ha->mr.fw_hbt_cnt)\n\t\tha->mr.fw_hbt_cnt--;\n\telse {\n\t\tif ((!ha->flags.mr_reset_hdlr_active) &&\n\t\t    (!test_bit(UNLOADING, &vha->dpc_flags)) &&\n\t\t    (!test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)) &&\n\t\t    (ha->mr.fw_hbt_en)) {\n\t\t\tfw_heart_beat = rd_reg_dword(&reg->fwheartbeat);\n\t\t\tif (fw_heart_beat != ha->mr.old_fw_hbt_cnt) {\n\t\t\t\tha->mr.old_fw_hbt_cnt = fw_heart_beat;\n\t\t\t\tha->mr.fw_hbt_miss_cnt = 0;\n\t\t\t} else {\n\t\t\t\tha->mr.fw_hbt_miss_cnt++;\n\t\t\t\tif (ha->mr.fw_hbt_miss_cnt ==\n\t\t\t\t    QLAFX00_HEARTBEAT_MISS_CNT) {\n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t\t\tha->mr.fw_hbt_miss_cnt = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tha->mr.fw_hbt_cnt = QLAFX00_HEARTBEAT_INTERVAL;\n\t}\n\n\tif (test_bit(FX00_RESET_RECOVERY, &vha->dpc_flags)) {\n\t\t \n\t\taenmbx0 = rd_reg_dword(&reg->aenmailbox0);\n\t\tif (ha->mr.fw_reset_timer_exp) {\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\tha->mr.fw_reset_timer_exp = 0;\n\t\t} else if (aenmbx0 == MBA_FW_RESTART_CMPLT) {\n\t\t\t \n\t\t\tset_bit(FX00_TARGET_SCAN, &vha->dpc_flags);\n\t\t\tclear_bit(FX00_RESET_RECOVERY, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\tha->mr.fw_reset_timer_tick = QLAFX00_RESET_INTERVAL;\n\t\t} else if ((aenmbx0 == MBA_FW_STARTING) &&\n\t\t    (!ha->mr.fw_hbt_en)) {\n\t\t\tha->mr.fw_hbt_en = 1;\n\t\t} else if (!ha->mr.fw_reset_timer_tick) {\n\t\t\tif (aenmbx0 == ha->mr.old_aenmbx0_state)\n\t\t\t\tha->mr.fw_reset_timer_exp = 1;\n\t\t\tha->mr.fw_reset_timer_tick = QLAFX00_RESET_INTERVAL;\n\t\t} else if (aenmbx0 == 0xFFFFFFFF) {\n\t\t\tuint32_t data0, data1;\n\n\t\t\tdata0 = QLAFX00_RD_REG(ha,\n\t\t\t    QLAFX00_BAR1_BASE_ADDR_REG);\n\t\t\tdata1 = QLAFX00_RD_REG(ha,\n\t\t\t    QLAFX00_PEX0_WIN0_BASE_ADDR_REG);\n\n\t\t\tdata0 &= 0xffff0000;\n\t\t\tdata1 &= 0x0000ffff;\n\n\t\t\tQLAFX00_WR_REG(ha,\n\t\t\t    QLAFX00_PEX0_WIN0_BASE_ADDR_REG,\n\t\t\t    (data0 | data1));\n\t\t} else if ((aenmbx0 & 0xFF00) == MBA_FW_POLL_STATE) {\n\t\t\tha->mr.fw_reset_timer_tick =\n\t\t\t    QLAFX00_MAX_RESET_INTERVAL;\n\t\t} else if (aenmbx0 == MBA_FW_RESET_FCT) {\n\t\t\tha->mr.fw_reset_timer_tick =\n\t\t\t    QLAFX00_MAX_RESET_INTERVAL;\n\t\t}\n\t\tif (ha->mr.old_aenmbx0_state != aenmbx0) {\n\t\t\tha->mr.old_aenmbx0_state = aenmbx0;\n\t\t\tha->mr.fw_reset_timer_tick = QLAFX00_RESET_INTERVAL;\n\t\t}\n\t\tha->mr.fw_reset_timer_tick--;\n\t}\n\tif (test_bit(FX00_CRITEMP_RECOVERY, &vha->dpc_flags)) {\n\t\t \n\t\tif (ha->mr.fw_critemp_timer_tick == 0) {\n\t\t\ttempc = QLAFX00_GET_TEMPERATURE(ha);\n\t\t\tql_dbg(ql_dbg_timer, vha, 0x6012,\n\t\t\t    \"ISPFx00(%s): Critical temp timer, \"\n\t\t\t    \"current SOC temperature: %d\\n\",\n\t\t\t    __func__, tempc);\n\t\t\tif (tempc < ha->mr.critical_temperature) {\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t\tclear_bit(FX00_CRITEMP_RECOVERY,\n\t\t\t\t    &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t}\n\t\t\tha->mr.fw_critemp_timer_tick =\n\t\t\t    QLAFX00_CRITEMP_INTERVAL;\n\t\t} else {\n\t\t\tha->mr.fw_critemp_timer_tick--;\n\t\t}\n\t}\n\tif (ha->mr.host_info_resend) {\n\t\t \n\t\tif (ha->mr.hinfo_resend_timer_tick == 0) {\n\t\t\tha->mr.host_info_resend = false;\n\t\t\tset_bit(FX00_HOST_INFO_RESEND, &vha->dpc_flags);\n\t\t\tha->mr.hinfo_resend_timer_tick =\n\t\t\t    QLAFX00_HINFO_RESEND_INTERVAL;\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t} else {\n\t\t\tha->mr.hinfo_resend_timer_tick--;\n\t\t}\n\t}\n\n}\n\n \nint\nqlafx00_reset_initialize(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (vha->device_flags & DFLG_DEV_FAILED) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0142,\n\t\t    \"Device in failed state\\n\");\n\t\treturn QLA_SUCCESS;\n\t}\n\n\tha->flags.mr_reset_hdlr_active = 1;\n\n\tif (vha->flags.online) {\n\t\tscsi_block_requests(vha->host);\n\t\tqlafx00_abort_isp_cleanup(vha, false);\n\t}\n\n\tql_log(ql_log_info, vha, 0x0143,\n\t    \"(%s): succeeded.\\n\", __func__);\n\tha->flags.mr_reset_hdlr_active = 0;\n\treturn QLA_SUCCESS;\n}\n\n \nint\nqlafx00_abort_isp(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (vha->flags.online) {\n\t\tif (unlikely(pci_channel_offline(ha->pdev) &&\n\t\t    ha->flags.pci_channel_io_perm_failure)) {\n\t\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\n\t\tscsi_block_requests(vha->host);\n\t\tqlafx00_abort_isp_cleanup(vha, false);\n\t} else {\n\t\tscsi_block_requests(vha->host);\n\t\tclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tvha->qla_stats.total_isp_aborts++;\n\t\tha->isp_ops->reset_chip(vha);\n\t\tset_bit(FX00_RESET_RECOVERY, &vha->dpc_flags);\n\t\t \n\t\tQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\n\t}\n\n\tql_log(ql_log_info, vha, 0x0145,\n\t    \"(%s): succeeded.\\n\", __func__);\n\n\treturn QLA_SUCCESS;\n}\n\nstatic inline fc_port_t*\nqlafx00_get_fcport(struct scsi_qla_host *vha, int tgt_id)\n{\n\tfc_port_t\t*fcport;\n\n\t \n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->tgt_id == tgt_id) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5072,\n\t\t\t    \"Matching fcport(%p) found with TGT-ID: 0x%x \"\n\t\t\t    \"and Remote TGT_ID: 0x%x\\n\",\n\t\t\t    fcport, fcport->tgt_id, tgt_id);\n\t\t\treturn fcport;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void\nqlafx00_tgt_detach(struct scsi_qla_host *vha, int tgt_id)\n{\n\tfc_port_t\t*fcport;\n\n\tql_log(ql_log_info, vha, 0x5073,\n\t    \"Detach TGT-ID: 0x%x\\n\", tgt_id);\n\n\tfcport = qlafx00_get_fcport(vha, tgt_id);\n\tif (!fcport)\n\t\treturn;\n\n\tqla2x00_mark_device_lost(vha, fcport, 0);\n\n\treturn;\n}\n\nvoid\nqlafx00_process_aen(struct scsi_qla_host *vha, struct qla_work_evt *evt)\n{\n\tuint32_t aen_code, aen_data;\n\n\taen_code = FCH_EVT_VENDOR_UNIQUE;\n\taen_data = evt->u.aenfx.evtcode;\n\n\tswitch (evt->u.aenfx.evtcode) {\n\tcase QLAFX00_MBA_PORT_UPDATE:\t\t \n\t\tif (evt->u.aenfx.mbx[1] == 0) {\n\t\t\tif (evt->u.aenfx.mbx[2] == 1) {\n\t\t\t\tif (!vha->flags.fw_tgt_reported)\n\t\t\t\t\tvha->flags.fw_tgt_reported = 1;\n\t\t\t\tatomic_set(&vha->loop_down_timer, 0);\n\t\t\t\tatomic_set(&vha->loop_state, LOOP_UP);\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t} else if (evt->u.aenfx.mbx[2] == 2) {\n\t\t\t\tqlafx00_tgt_detach(vha, evt->u.aenfx.mbx[3]);\n\t\t\t}\n\t\t} else if (evt->u.aenfx.mbx[1] == 0xffff) {\n\t\t\tif (evt->u.aenfx.mbx[2] == 1) {\n\t\t\t\tif (!vha->flags.fw_tgt_reported)\n\t\t\t\t\tvha->flags.fw_tgt_reported = 1;\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t} else if (evt->u.aenfx.mbx[2] == 2) {\n\t\t\t\tvha->device_flags |= DFLG_NO_CABLE;\n\t\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase QLAFX00_MBA_LINK_UP:\n\t\taen_code = FCH_EVT_LINKUP;\n\t\taen_data = 0;\n\t\tbreak;\n\tcase QLAFX00_MBA_LINK_DOWN:\n\t\taen_code = FCH_EVT_LINKDOWN;\n\t\taen_data = 0;\n\t\tbreak;\n\tcase QLAFX00_MBA_TEMP_CRIT:\t \n\t\tql_log(ql_log_info, vha, 0x5082,\n\t\t    \"Process critical temperature event \"\n\t\t    \"aenmb[0]: %x\\n\",\n\t\t    evt->u.aenfx.evtcode);\n\t\tscsi_block_requests(vha->host);\n\t\tqlafx00_abort_isp_cleanup(vha, true);\n\t\tscsi_unblock_requests(vha->host);\n\t\tbreak;\n\t}\n\n\tfc_host_post_event(vha->host, fc_get_event_number(),\n\t    aen_code, aen_data);\n}\n\nstatic void\nqlafx00_update_host_attr(scsi_qla_host_t *vha, struct port_info_data *pinfo)\n{\n\tu64 port_name = 0, node_name = 0;\n\n\tport_name = (unsigned long long)wwn_to_u64(pinfo->port_name);\n\tnode_name = (unsigned long long)wwn_to_u64(pinfo->node_name);\n\n\tfc_host_node_name(vha->host) = node_name;\n\tfc_host_port_name(vha->host) = port_name;\n\tif (!pinfo->port_type)\n\t\tvha->hw->current_topology = ISP_CFG_F;\n\tif (pinfo->link_status == QLAFX00_LINK_STATUS_UP)\n\t\tatomic_set(&vha->loop_state, LOOP_READY);\n\telse if (pinfo->link_status == QLAFX00_LINK_STATUS_DOWN)\n\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\tvha->hw->link_data_rate = (uint16_t)pinfo->link_config;\n}\n\nstatic void\nqla2x00_fxdisc_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\n\tcomplete(&lio->u.fxiocb.fxiocb_comp);\n}\n\nstatic void qla2x00_fxdisc_sp_done(srb_t *sp, int res)\n{\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\n\tcomplete(&lio->u.fxiocb.fxiocb_comp);\n}\n\nint\nqlafx00_fx_disc(scsi_qla_host_t *vha, fc_port_t *fcport, uint16_t fx_type)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *fdisc;\n\tint rval = QLA_FUNCTION_FAILED;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct host_system_info *phost_info;\n\tstruct register_host_info *preg_hsi;\n\tstruct new_utsname *p_sysid = NULL;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_FXIOCB_DCMD;\n\tsp->name = \"fxdisc\";\n\tqla2x00_init_async_sp(sp, FXDISC_TIMEOUT,\n\t\t\t      qla2x00_fxdisc_sp_done);\n\tsp->u.iocb_cmd.timeout = qla2x00_fxdisc_iocb_timeout;\n\n\tfdisc = &sp->u.iocb_cmd;\n\tswitch (fx_type) {\n\tcase FXDISC_GET_CONFIG_INFO:\n\tfdisc->u.fxiocb.flags =\n\t\t    SRB_FXDISC_RESP_DMA_VALID;\n\t\tfdisc->u.fxiocb.rsp_len = sizeof(struct config_info_data);\n\t\tbreak;\n\tcase FXDISC_GET_PORT_INFO:\n\t\tfdisc->u.fxiocb.flags =\n\t\t    SRB_FXDISC_RESP_DMA_VALID | SRB_FXDISC_REQ_DWRD_VALID;\n\t\tfdisc->u.fxiocb.rsp_len = QLAFX00_PORT_DATA_INFO;\n\t\tfdisc->u.fxiocb.req_data = cpu_to_le32(fcport->port_id);\n\t\tbreak;\n\tcase FXDISC_GET_TGT_NODE_INFO:\n\t\tfdisc->u.fxiocb.flags =\n\t\t    SRB_FXDISC_RESP_DMA_VALID | SRB_FXDISC_REQ_DWRD_VALID;\n\t\tfdisc->u.fxiocb.rsp_len = QLAFX00_TGT_NODE_INFO;\n\t\tfdisc->u.fxiocb.req_data = cpu_to_le32(fcport->tgt_id);\n\t\tbreak;\n\tcase FXDISC_GET_TGT_NODE_LIST:\n\t\tfdisc->u.fxiocb.flags =\n\t\t    SRB_FXDISC_RESP_DMA_VALID | SRB_FXDISC_REQ_DWRD_VALID;\n\t\tfdisc->u.fxiocb.rsp_len = QLAFX00_TGT_NODE_LIST_SIZE;\n\t\tbreak;\n\tcase FXDISC_REG_HOST_INFO:\n\t\tfdisc->u.fxiocb.flags = SRB_FXDISC_REQ_DMA_VALID;\n\t\tfdisc->u.fxiocb.req_len = sizeof(struct register_host_info);\n\t\tp_sysid = utsname();\n\t\tif (!p_sysid) {\n\t\t\tql_log(ql_log_warn, vha, 0x303c,\n\t\t\t    \"Not able to get the system information\\n\");\n\t\t\tgoto done_free_sp;\n\t\t}\n\t\tbreak;\n\tcase FXDISC_ABORT_IOCTL:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (fdisc->u.fxiocb.flags & SRB_FXDISC_REQ_DMA_VALID) {\n\t\tfdisc->u.fxiocb.req_addr = dma_alloc_coherent(&ha->pdev->dev,\n\t\t    fdisc->u.fxiocb.req_len,\n\t\t    &fdisc->u.fxiocb.req_dma_handle, GFP_KERNEL);\n\t\tif (!fdisc->u.fxiocb.req_addr)\n\t\t\tgoto done_free_sp;\n\n\t\tif (fx_type == FXDISC_REG_HOST_INFO) {\n\t\t\tpreg_hsi = (struct register_host_info *)\n\t\t\t\tfdisc->u.fxiocb.req_addr;\n\t\t\tphost_info = &preg_hsi->hsi;\n\t\t\tmemset(preg_hsi, 0, sizeof(struct register_host_info));\n\t\t\tphost_info->os_type = OS_TYPE_LINUX;\n\t\t\tstrscpy(phost_info->sysname, p_sysid->sysname,\n\t\t\t\tsizeof(phost_info->sysname));\n\t\t\tstrscpy(phost_info->nodename, p_sysid->nodename,\n\t\t\t\tsizeof(phost_info->nodename));\n\t\t\tif (!strcmp(phost_info->nodename, \"(none)\"))\n\t\t\t\tha->mr.host_info_resend = true;\n\t\t\tstrscpy(phost_info->release, p_sysid->release,\n\t\t\t\tsizeof(phost_info->release));\n\t\t\tstrscpy(phost_info->version, p_sysid->version,\n\t\t\t\tsizeof(phost_info->version));\n\t\t\tstrscpy(phost_info->machine, p_sysid->machine,\n\t\t\t\tsizeof(phost_info->machine));\n\t\t\tstrscpy(phost_info->domainname, p_sysid->domainname,\n\t\t\t\tsizeof(phost_info->domainname));\n\t\t\tstrscpy(phost_info->hostdriver, QLA2XXX_VERSION,\n\t\t\t\tsizeof(phost_info->hostdriver));\n\t\t\tpreg_hsi->utc = (uint64_t)ktime_get_real_seconds();\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0149,\n\t\t\t    \"ISP%04X: Host registration with firmware\\n\",\n\t\t\t    ha->pdev->device);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x014a,\n\t\t\t    \"os_type = '%d', sysname = '%s', nodname = '%s'\\n\",\n\t\t\t    phost_info->os_type,\n\t\t\t    phost_info->sysname,\n\t\t\t    phost_info->nodename);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x014b,\n\t\t\t    \"release = '%s', version = '%s'\\n\",\n\t\t\t    phost_info->release,\n\t\t\t    phost_info->version);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x014c,\n\t\t\t    \"machine = '%s' \"\n\t\t\t    \"domainname = '%s', hostdriver = '%s'\\n\",\n\t\t\t    phost_info->machine,\n\t\t\t    phost_info->domainname,\n\t\t\t    phost_info->hostdriver);\n\t\t\tql_dump_buffer(ql_dbg_init + ql_dbg_disc, vha, 0x014d,\n\t\t\t    phost_info, sizeof(*phost_info));\n\t\t}\n\t}\n\n\tif (fdisc->u.fxiocb.flags & SRB_FXDISC_RESP_DMA_VALID) {\n\t\tfdisc->u.fxiocb.rsp_addr = dma_alloc_coherent(&ha->pdev->dev,\n\t\t    fdisc->u.fxiocb.rsp_len,\n\t\t    &fdisc->u.fxiocb.rsp_dma_handle, GFP_KERNEL);\n\t\tif (!fdisc->u.fxiocb.rsp_addr)\n\t\t\tgoto done_unmap_req;\n\t}\n\n\tfdisc->u.fxiocb.req_func_type = cpu_to_le16(fx_type);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_unmap_dma;\n\n\twait_for_completion(&fdisc->u.fxiocb.fxiocb_comp);\n\n\tif (fx_type == FXDISC_GET_CONFIG_INFO) {\n\t\tstruct config_info_data *pinfo =\n\t\t    (struct config_info_data *) fdisc->u.fxiocb.rsp_addr;\n\t\tstrscpy(vha->hw->model_number, pinfo->model_num,\n\t\t\tARRAY_SIZE(vha->hw->model_number));\n\t\tstrscpy(vha->hw->model_desc, pinfo->model_description,\n\t\t\tARRAY_SIZE(vha->hw->model_desc));\n\t\tmemcpy(&vha->hw->mr.symbolic_name, pinfo->symbolic_name,\n\t\t    sizeof(vha->hw->mr.symbolic_name));\n\t\tmemcpy(&vha->hw->mr.serial_num, pinfo->serial_num,\n\t\t    sizeof(vha->hw->mr.serial_num));\n\t\tmemcpy(&vha->hw->mr.hw_version, pinfo->hw_version,\n\t\t    sizeof(vha->hw->mr.hw_version));\n\t\tmemcpy(&vha->hw->mr.fw_version, pinfo->fw_version,\n\t\t    sizeof(vha->hw->mr.fw_version));\n\t\tstrim(vha->hw->mr.fw_version);\n\t\tmemcpy(&vha->hw->mr.uboot_version, pinfo->uboot_version,\n\t\t    sizeof(vha->hw->mr.uboot_version));\n\t\tmemcpy(&vha->hw->mr.fru_serial_num, pinfo->fru_serial_num,\n\t\t    sizeof(vha->hw->mr.fru_serial_num));\n\t\tvha->hw->mr.critical_temperature =\n\t\t    (pinfo->nominal_temp_value) ?\n\t\t    pinfo->nominal_temp_value : QLAFX00_CRITEMP_THRSHLD;\n\t\tha->mr.extended_io_enabled = (pinfo->enabled_capabilities &\n\t\t    QLAFX00_EXTENDED_IO_EN_MASK) != 0;\n\t} else if (fx_type == FXDISC_GET_PORT_INFO) {\n\t\tstruct port_info_data *pinfo =\n\t\t    (struct port_info_data *) fdisc->u.fxiocb.rsp_addr;\n\t\tmemcpy(vha->node_name, pinfo->node_name, WWN_SIZE);\n\t\tmemcpy(vha->port_name, pinfo->port_name, WWN_SIZE);\n\t\tvha->d_id.b.domain = pinfo->port_id[0];\n\t\tvha->d_id.b.area = pinfo->port_id[1];\n\t\tvha->d_id.b.al_pa = pinfo->port_id[2];\n\t\tqlafx00_update_host_attr(vha, pinfo);\n\t\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0141,\n\t\t    pinfo, 16);\n\t} else if (fx_type == FXDISC_GET_TGT_NODE_INFO) {\n\t\tstruct qlafx00_tgt_node_info *pinfo =\n\t\t    (struct qlafx00_tgt_node_info *) fdisc->u.fxiocb.rsp_addr;\n\t\tmemcpy(fcport->node_name, pinfo->tgt_node_wwnn, WWN_SIZE);\n\t\tmemcpy(fcport->port_name, pinfo->tgt_node_wwpn, WWN_SIZE);\n\t\tfcport->port_type = FCT_TARGET;\n\t\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0144,\n\t\t    pinfo, 16);\n\t} else if (fx_type == FXDISC_GET_TGT_NODE_LIST) {\n\t\tstruct qlafx00_tgt_node_info *pinfo =\n\t\t    (struct qlafx00_tgt_node_info *) fdisc->u.fxiocb.rsp_addr;\n\t\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0146,\n\t\t    pinfo, 16);\n\t\tmemcpy(vha->hw->gid_list, pinfo, QLAFX00_TGT_NODE_LIST_SIZE);\n\t} else if (fx_type == FXDISC_ABORT_IOCTL)\n\t\tfdisc->u.fxiocb.result =\n\t\t    (fdisc->u.fxiocb.result ==\n\t\t\tcpu_to_le32(QLAFX00_IOCTL_ICOB_ABORT_SUCCESS)) ?\n\t\t    cpu_to_le32(QLA_SUCCESS) : cpu_to_le32(QLA_FUNCTION_FAILED);\n\n\trval = le32_to_cpu(fdisc->u.fxiocb.result);\n\ndone_unmap_dma:\n\tif (fdisc->u.fxiocb.rsp_addr)\n\t\tdma_free_coherent(&ha->pdev->dev, fdisc->u.fxiocb.rsp_len,\n\t\t    fdisc->u.fxiocb.rsp_addr, fdisc->u.fxiocb.rsp_dma_handle);\n\ndone_unmap_req:\n\tif (fdisc->u.fxiocb.req_addr)\n\t\tdma_free_coherent(&ha->pdev->dev, fdisc->u.fxiocb.req_len,\n\t\t    fdisc->u.fxiocb.req_addr, fdisc->u.fxiocb.req_dma_handle);\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\n \nint\nqlafx00_initialize_adapter(scsi_qla_host_t *vha)\n{\n\tint\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t tempc;\n\n\t \n\tvha->flags.online = 0;\n\tha->flags.chip_reset_done = 0;\n\tvha->flags.reset_active = 0;\n\tha->flags.pci_channel_io_perm_failure = 0;\n\tha->flags.eeh_busy = 0;\n\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\tvha->device_flags = DFLG_NO_CABLE;\n\tvha->dpc_flags = 0;\n\tvha->flags.management_server_logged_in = 0;\n\tha->isp_abort_cnt = 0;\n\tha->beacon_blink_led = 0;\n\n\tset_bit(0, ha->req_qid_map);\n\tset_bit(0, ha->rsp_qid_map);\n\n\tql_dbg(ql_dbg_init, vha, 0x0147,\n\t    \"Configuring PCI space...\\n\");\n\n\trval = ha->isp_ops->pci_config(vha);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0148,\n\t\t    \"Unable to configure PCI space.\\n\");\n\t\treturn rval;\n\t}\n\n\trval = qlafx00_init_fw_ready(vha);\n\tif (rval != QLA_SUCCESS)\n\t\treturn rval;\n\n\tqlafx00_save_queue_ptrs(vha);\n\n\trval = qlafx00_config_queues(vha);\n\tif (rval != QLA_SUCCESS)\n\t\treturn rval;\n\n\t \n\trval = qla2x00_alloc_outstanding_cmds(ha, vha->req);\n\tif (rval != QLA_SUCCESS)\n\t\treturn rval;\n\n\trval = qla2x00_init_rings(vha);\n\tha->flags.chip_reset_done = 1;\n\n\ttempc = QLAFX00_GET_TEMPERATURE(ha);\n\tql_dbg(ql_dbg_init, vha, 0x0152,\n\t    \"ISPFx00(%s): Critical temp timer, current SOC temperature: 0x%x\\n\",\n\t    __func__, tempc);\n\n\treturn rval;\n}\n\nuint32_t\nqlafx00_fw_state_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint rval = QLA_FUNCTION_FAILED;\n\tuint32_t state[1];\n\n\tif (qla2x00_reset_active(vha))\n\t\tql_log(ql_log_warn, vha, 0x70ce,\n\t\t    \"ISP reset active.\\n\");\n\telse if (!vha->hw->flags.eeh_busy) {\n\t\trval = qlafx00_get_firmware_state(vha, state);\n\t}\n\tif (rval != QLA_SUCCESS)\n\t\tmemset(state, -1, sizeof(state));\n\n\treturn state[0];\n}\n\nvoid\nqlafx00_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct qla_hw_data *ha = ((struct scsi_qla_host *)\n\t\t\t\t\t(shost_priv(shost)))->hw;\n\tu32 speed = FC_PORTSPEED_UNKNOWN;\n\n\tswitch (ha->link_data_rate) {\n\tcase QLAFX00_PORT_SPEED_2G:\n\t\tspeed = FC_PORTSPEED_2GBIT;\n\t\tbreak;\n\tcase QLAFX00_PORT_SPEED_4G:\n\t\tspeed = FC_PORTSPEED_4GBIT;\n\t\tbreak;\n\tcase QLAFX00_PORT_SPEED_8G:\n\t\tspeed = FC_PORTSPEED_8GBIT;\n\t\tbreak;\n\tcase QLAFX00_PORT_SPEED_10G:\n\t\tspeed = FC_PORTSPEED_10GBIT;\n\t\tbreak;\n\t}\n\tfc_host_speed(shost) = speed;\n}\n\n \n\nstatic inline void\nqlafx00_handle_sense(srb_t *sp, uint8_t *sense_data, uint32_t par_sense_len,\n\t\t     uint32_t sense_len, struct rsp_que *rsp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct scsi_cmnd *cp = GET_CMD_SP(sp);\n\tuint32_t track_sense_len;\n\n\tSET_FW_SENSE_LEN(sp, sense_len);\n\n\tif (sense_len >= SCSI_SENSE_BUFFERSIZE)\n\t\tsense_len = SCSI_SENSE_BUFFERSIZE;\n\n\tSET_CMD_SENSE_LEN(sp, sense_len);\n\tSET_CMD_SENSE_PTR(sp, cp->sense_buffer);\n\ttrack_sense_len = sense_len;\n\n\tif (sense_len > par_sense_len)\n\t\tsense_len = par_sense_len;\n\n\tmemcpy(cp->sense_buffer, sense_data, sense_len);\n\n\tSET_FW_SENSE_LEN(sp, GET_FW_SENSE_LEN(sp) - sense_len);\n\n\tSET_CMD_SENSE_PTR(sp, cp->sense_buffer + sense_len);\n\ttrack_sense_len -= sense_len;\n\tSET_CMD_SENSE_LEN(sp, track_sense_len);\n\n\tql_dbg(ql_dbg_io, vha, 0x304d,\n\t    \"sense_len=0x%x par_sense_len=0x%x track_sense_len=0x%x.\\n\",\n\t    sense_len, par_sense_len, track_sense_len);\n\tif (GET_FW_SENSE_LEN(sp) > 0) {\n\t\trsp->status_srb = sp;\n\t\tcp->result = res;\n\t}\n\n\tif (sense_len) {\n\t\tql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x3039,\n\t\t    \"Check condition Sense data, nexus%ld:%d:%llu cmd=%p.\\n\",\n\t\t    sp->vha->host_no, cp->device->id, cp->device->lun,\n\t\t    cp);\n\t\tql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x3049,\n\t\t    cp->sense_buffer, sense_len);\n\t}\n}\n\nstatic void\nqlafx00_tm_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\n\t\t      struct tsk_mgmt_entry_fx00 *pkt, srb_t *sp,\n\t\t      __le16 sstatus, __le16 cpstatus)\n{\n\tstruct srb_iocb *tmf;\n\n\ttmf = &sp->u.iocb_cmd;\n\tif (cpstatus != cpu_to_le16((uint16_t)CS_COMPLETE) ||\n\t    (sstatus & cpu_to_le16((uint16_t)SS_RESPONSE_INFO_LEN_VALID)))\n\t\tcpstatus = cpu_to_le16((uint16_t)CS_INCOMPLETE);\n\ttmf->u.tmf.comp_status = cpstatus;\n\tsp->done(sp, 0);\n}\n\nstatic void\nqlafx00_abort_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\n\t\t\t struct abort_iocb_entry_fx00 *pkt)\n{\n\tconst char func[] = \"ABT_IOCB\";\n\tsrb_t *sp;\n\tstruct srb_iocb *abt;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\n\tabt = &sp->u.iocb_cmd;\n\tabt->u.abt.comp_status = pkt->tgt_id_sts;\n\tsp->done(sp, 0);\n}\n\nstatic void\nqlafx00_ioctl_iosb_entry(scsi_qla_host_t *vha, struct req_que *req,\n\t\t\t struct ioctl_iocb_entry_fx00 *pkt)\n{\n\tconst char func[] = \"IOSB_IOCB\";\n\tsrb_t *sp;\n\tstruct bsg_job *bsg_job;\n\tstruct fc_bsg_reply *bsg_reply;\n\tstruct srb_iocb *iocb_job;\n\tint res = 0;\n\tstruct qla_mt_iocb_rsp_fx00 fstatus;\n\tuint8_t\t*fw_sts_ptr;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\n\tif (sp->type == SRB_FXIOCB_DCMD) {\n\t\tiocb_job = &sp->u.iocb_cmd;\n\t\tiocb_job->u.fxiocb.seq_number = pkt->seq_no;\n\t\tiocb_job->u.fxiocb.fw_flags = pkt->fw_iotcl_flags;\n\t\tiocb_job->u.fxiocb.result = pkt->status;\n\t\tif (iocb_job->u.fxiocb.flags & SRB_FXDISC_RSP_DWRD_VALID)\n\t\t\tiocb_job->u.fxiocb.req_data =\n\t\t\t    pkt->dataword_r;\n\t} else {\n\t\tbsg_job = sp->u.bsg_job;\n\t\tbsg_reply = bsg_job->reply;\n\n\t\tmemset(&fstatus, 0, sizeof(struct qla_mt_iocb_rsp_fx00));\n\n\t\tfstatus.reserved_1 = pkt->reserved_0;\n\t\tfstatus.func_type = pkt->comp_func_num;\n\t\tfstatus.ioctl_flags = pkt->fw_iotcl_flags;\n\t\tfstatus.ioctl_data = pkt->dataword_r;\n\t\tfstatus.adapid = pkt->adapid;\n\t\tfstatus.reserved_2 = pkt->dataword_r_extra;\n\t\tfstatus.res_count = pkt->residuallen;\n\t\tfstatus.status = pkt->status;\n\t\tfstatus.seq_number = pkt->seq_no;\n\t\tmemcpy(fstatus.reserved_3,\n\t\t    pkt->reserved_2, 20 * sizeof(uint8_t));\n\n\t\tfw_sts_ptr = bsg_job->reply + sizeof(struct fc_bsg_reply);\n\n\t\tmemcpy(fw_sts_ptr, &fstatus, sizeof(fstatus));\n\t\tbsg_job->reply_len = sizeof(struct fc_bsg_reply) +\n\t\t\tsizeof(struct qla_mt_iocb_rsp_fx00) + sizeof(uint8_t);\n\n\t\tql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\n\t\t    sp->vha, 0x5080, pkt, sizeof(*pkt));\n\n\t\tql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\n\t\t    sp->vha, 0x5074,\n\t\t    fw_sts_ptr, sizeof(fstatus));\n\n\t\tres = bsg_reply->result = DID_OK << 16;\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t    bsg_job->reply_payload.payload_len;\n\t}\n\tsp->done(sp, res);\n}\n\n \nstatic void\nqlafx00_status_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, void *pkt)\n{\n\tsrb_t\t\t*sp;\n\tfc_port_t\t*fcport;\n\tstruct scsi_cmnd *cp;\n\tstruct sts_entry_fx00 *sts;\n\t__le16\t\tcomp_status;\n\t__le16\t\tscsi_status;\n\t__le16\t\tlscsi_status;\n\tint32_t\t\tresid;\n\tuint32_t\tsense_len, par_sense_len, rsp_info_len, resid_len,\n\t    fw_resid_len;\n\tuint8_t\t\t*rsp_info = NULL, *sense_data = NULL;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t hindex, handle;\n\tuint16_t que;\n\tstruct req_que *req;\n\tint logit = 1;\n\tint res = 0;\n\n\tsts = (struct sts_entry_fx00 *) pkt;\n\n\tcomp_status = sts->comp_status;\n\tscsi_status = sts->scsi_status & cpu_to_le16((uint16_t)SS_MASK);\n\thindex = sts->handle;\n\thandle = LSW(hindex);\n\n\tque = MSW(hindex);\n\treq = ha->req_q_map[que];\n\n\t \n\tif (handle < req->num_outstanding_cmds)\n\t\tsp = req->outstanding_cmds[handle];\n\telse\n\t\tsp = NULL;\n\n\tif (sp == NULL) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3034,\n\t\t    \"Invalid status handle (0x%x).\\n\", handle);\n\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\t\treturn;\n\t}\n\n\tif (sp->type == SRB_TM_CMD) {\n\t\treq->outstanding_cmds[handle] = NULL;\n\t\tqlafx00_tm_iocb_entry(vha, req, pkt, sp,\n\t\t    scsi_status, comp_status);\n\t\treturn;\n\t}\n\n\t \n\tif (comp_status == CS_COMPLETE && scsi_status == 0) {\n\t\tqla2x00_process_completed_request(vha, req, handle);\n\t\treturn;\n\t}\n\n\treq->outstanding_cmds[handle] = NULL;\n\tcp = GET_CMD_SP(sp);\n\tif (cp == NULL) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3048,\n\t\t    \"Command already returned (0x%x/%p).\\n\",\n\t\t    handle, sp);\n\n\t\treturn;\n\t}\n\n\tlscsi_status = scsi_status & cpu_to_le16((uint16_t)STATUS_MASK);\n\n\tfcport = sp->fcport;\n\n\tsense_len = par_sense_len = rsp_info_len = resid_len =\n\t\tfw_resid_len = 0;\n\tif (scsi_status & cpu_to_le16((uint16_t)SS_SENSE_LEN_VALID))\n\t\tsense_len = sts->sense_len;\n\tif (scsi_status & cpu_to_le16(((uint16_t)SS_RESIDUAL_UNDER\n\t    | (uint16_t)SS_RESIDUAL_OVER)))\n\t\tresid_len = le32_to_cpu(sts->residual_len);\n\tif (comp_status == cpu_to_le16((uint16_t)CS_DATA_UNDERRUN))\n\t\tfw_resid_len = le32_to_cpu(sts->residual_len);\n\trsp_info = sense_data = sts->data;\n\tpar_sense_len = sizeof(sts->data);\n\n\t \n\tif (comp_status == CS_COMPLETE &&\n\t    scsi_status & cpu_to_le16((uint16_t)SS_RESIDUAL_OVER))\n\t\tcomp_status = cpu_to_le16((uint16_t)CS_DATA_OVERRUN);\n\n\t \n\tswitch (le16_to_cpu(comp_status)) {\n\tcase CS_COMPLETE:\n\tcase CS_QUEUE_FULL:\n\t\tif (scsi_status == 0) {\n\t\t\tres = DID_OK << 16;\n\t\t\tbreak;\n\t\t}\n\t\tif (scsi_status & cpu_to_le16(((uint16_t)SS_RESIDUAL_UNDER\n\t\t    | (uint16_t)SS_RESIDUAL_OVER))) {\n\t\t\tresid = resid_len;\n\t\t\tscsi_set_resid(cp, resid);\n\n\t\t\tif (!lscsi_status &&\n\t\t\t    ((unsigned)(scsi_bufflen(cp) - resid) <\n\t\t\t     cp->underflow)) {\n\t\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3050,\n\t\t\t\t    \"Mid-layer underflow \"\n\t\t\t\t    \"detected (0x%x of 0x%x bytes).\\n\",\n\t\t\t\t    resid, scsi_bufflen(cp));\n\n\t\t\t\tres = DID_ERROR << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = DID_OK << 16 | le16_to_cpu(lscsi_status);\n\n\t\tif (lscsi_status ==\n\t\t    cpu_to_le16((uint16_t)SAM_STAT_TASK_SET_FULL)) {\n\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3051,\n\t\t\t    \"QUEUE FULL detected.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlogit = 0;\n\t\tif (lscsi_status != cpu_to_le16((uint16_t)SS_CHECK_CONDITION))\n\t\t\tbreak;\n\n\t\tmemset(cp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\tif (!(scsi_status & cpu_to_le16((uint16_t)SS_SENSE_LEN_VALID)))\n\t\t\tbreak;\n\n\t\tqlafx00_handle_sense(sp, sense_data, par_sense_len, sense_len,\n\t\t    rsp, res);\n\t\tbreak;\n\n\tcase CS_DATA_UNDERRUN:\n\t\t \n\t\tif (IS_FWI2_CAPABLE(ha) || IS_QLAFX00(ha))\n\t\t\tresid = fw_resid_len;\n\t\telse\n\t\t\tresid = resid_len;\n\t\tscsi_set_resid(cp, resid);\n\t\tif (scsi_status & cpu_to_le16((uint16_t)SS_RESIDUAL_UNDER)) {\n\t\t\tif ((IS_FWI2_CAPABLE(ha) || IS_QLAFX00(ha))\n\t\t\t    && fw_resid_len != resid_len) {\n\t\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3052,\n\t\t\t\t    \"Dropped frame(s) detected \"\n\t\t\t\t    \"(0x%x of 0x%x bytes).\\n\",\n\t\t\t\t    resid, scsi_bufflen(cp));\n\n\t\t\t\tres = DID_ERROR << 16 |\n\t\t\t\t    le16_to_cpu(lscsi_status);\n\t\t\t\tgoto check_scsi_status;\n\t\t\t}\n\n\t\t\tif (!lscsi_status &&\n\t\t\t    ((unsigned)(scsi_bufflen(cp) - resid) <\n\t\t\t    cp->underflow)) {\n\t\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3053,\n\t\t\t\t    \"Mid-layer underflow \"\n\t\t\t\t    \"detected (0x%x of 0x%x bytes, \"\n\t\t\t\t    \"cp->underflow: 0x%x).\\n\",\n\t\t\t\t    resid, scsi_bufflen(cp), cp->underflow);\n\n\t\t\t\tres = DID_ERROR << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (lscsi_status !=\n\t\t    cpu_to_le16((uint16_t)SAM_STAT_TASK_SET_FULL) &&\n\t\t    lscsi_status != cpu_to_le16((uint16_t)SAM_STAT_BUSY)) {\n\t\t\t \n\n\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3054,\n\t\t\t    \"Dropped frame(s) detected (0x%x \"\n\t\t\t    \"of 0x%x bytes).\\n\", resid,\n\t\t\t    scsi_bufflen(cp));\n\n\t\t\tres = DID_ERROR << 16 | le16_to_cpu(lscsi_status);\n\t\t\tgoto check_scsi_status;\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3055,\n\t\t\t    \"scsi_status: 0x%x, lscsi_status: 0x%x\\n\",\n\t\t\t    scsi_status, lscsi_status);\n\t\t}\n\n\t\tres = DID_OK << 16 | le16_to_cpu(lscsi_status);\n\t\tlogit = 0;\n\ncheck_scsi_status:\n\t\t \n\t\tif (lscsi_status != 0) {\n\t\t\tif (lscsi_status ==\n\t\t\t    cpu_to_le16((uint16_t)SAM_STAT_TASK_SET_FULL)) {\n\t\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3056,\n\t\t\t\t    \"QUEUE FULL detected.\\n\");\n\t\t\t\tlogit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lscsi_status !=\n\t\t\t    cpu_to_le16((uint16_t)SS_CHECK_CONDITION))\n\t\t\t\tbreak;\n\n\t\t\tmemset(cp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\t\tif (!(scsi_status &\n\t\t\t    cpu_to_le16((uint16_t)SS_SENSE_LEN_VALID)))\n\t\t\t\tbreak;\n\n\t\t\tqlafx00_handle_sense(sp, sense_data, par_sense_len,\n\t\t\t    sense_len, rsp, res);\n\t\t}\n\t\tbreak;\n\n\tcase CS_PORT_LOGGED_OUT:\n\tcase CS_PORT_CONFIG_CHG:\n\tcase CS_PORT_BUSY:\n\tcase CS_INCOMPLETE:\n\tcase CS_PORT_UNAVAILABLE:\n\tcase CS_TIMEOUT:\n\tcase CS_RESET:\n\n\t\t \n\t\tres = DID_TRANSPORT_DISRUPTED << 16;\n\n\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3057,\n\t\t    \"Port down status: port-state=0x%x.\\n\",\n\t\t    atomic_read(&fcport->state));\n\n\t\tif (atomic_read(&fcport->state) == FCS_ONLINE)\n\t\t\tqla2x00_mark_device_lost(fcport->vha, fcport, 1);\n\t\tbreak;\n\n\tcase CS_ABORTED:\n\t\tres = DID_RESET << 16;\n\t\tbreak;\n\n\tdefault:\n\t\tres = DID_ERROR << 16;\n\t\tbreak;\n\t}\n\n\tif (logit)\n\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3058,\n\t\t    \"FCP command status: 0x%x-0x%x (0x%x) nexus=%ld:%d:%llu \"\n\t\t    \"tgt_id: 0x%x lscsi_status: 0x%x cdb=%10phN len=0x%x \"\n\t\t    \"rsp_info=%p resid=0x%x fw_resid=0x%x sense_len=0x%x, \"\n\t\t    \"par_sense_len=0x%x, rsp_info_len=0x%x\\n\",\n\t\t    comp_status, scsi_status, res, vha->host_no,\n\t\t    cp->device->id, cp->device->lun, fcport->tgt_id,\n\t\t    lscsi_status, cp->cmnd, scsi_bufflen(cp),\n\t\t    rsp_info, resid_len, fw_resid_len, sense_len,\n\t\t    par_sense_len, rsp_info_len);\n\n\tif (rsp->status_srb == NULL)\n\t\tsp->done(sp, res);\n\telse\n\t\tWARN_ON_ONCE(true);\n}\n\n \nstatic void\nqlafx00_status_cont_entry(struct rsp_que *rsp, sts_cont_entry_t *pkt)\n{\n\tuint8_t\tsense_sz = 0;\n\tstruct qla_hw_data *ha = rsp->hw;\n\tstruct scsi_qla_host *vha = pci_get_drvdata(ha->pdev);\n\tsrb_t *sp = rsp->status_srb;\n\tstruct scsi_cmnd *cp;\n\tuint32_t sense_len;\n\tuint8_t *sense_ptr;\n\n\tif (!sp) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3037,\n\t\t    \"no SP, sp = %p\\n\", sp);\n\t\treturn;\n\t}\n\n\tif (!GET_FW_SENSE_LEN(sp)) {\n\t\tql_dbg(ql_dbg_io, vha, 0x304b,\n\t\t    \"no fw sense data, sp = %p\\n\", sp);\n\t\treturn;\n\t}\n\tcp = GET_CMD_SP(sp);\n\tif (cp == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x303b,\n\t\t    \"cmd is NULL: already returned to OS (sp=%p).\\n\", sp);\n\n\t\trsp->status_srb = NULL;\n\t\treturn;\n\t}\n\n\tif (!GET_CMD_SENSE_LEN(sp)) {\n\t\tql_dbg(ql_dbg_io, vha, 0x304c,\n\t\t    \"no sense data, sp = %p\\n\", sp);\n\t} else {\n\t\tsense_len = GET_CMD_SENSE_LEN(sp);\n\t\tsense_ptr = GET_CMD_SENSE_PTR(sp);\n\t\tql_dbg(ql_dbg_io, vha, 0x304f,\n\t\t    \"sp=%p sense_len=0x%x sense_ptr=%p.\\n\",\n\t\t    sp, sense_len, sense_ptr);\n\n\t\tif (sense_len > sizeof(pkt->data))\n\t\t\tsense_sz = sizeof(pkt->data);\n\t\telse\n\t\t\tsense_sz = sense_len;\n\n\t\t \n\t\tql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x304e,\n\t\t    pkt, sizeof(*pkt));\n\t\tmemcpy(sense_ptr, pkt->data, sense_sz);\n\t\tql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x304a,\n\t\t    sense_ptr, sense_sz);\n\n\t\tsense_len -= sense_sz;\n\t\tsense_ptr += sense_sz;\n\n\t\tSET_CMD_SENSE_PTR(sp, sense_ptr);\n\t\tSET_CMD_SENSE_LEN(sp, sense_len);\n\t}\n\tsense_len = GET_FW_SENSE_LEN(sp);\n\tsense_len = (sense_len > sizeof(pkt->data)) ?\n\t    (sense_len - sizeof(pkt->data)) : 0;\n\tSET_FW_SENSE_LEN(sp, sense_len);\n\n\t \n\tif (sense_len == 0) {\n\t\trsp->status_srb = NULL;\n\t\tsp->done(sp, cp->result);\n\t} else {\n\t\tWARN_ON_ONCE(true);\n\t}\n}\n\n \nstatic void\nqlafx00_multistatus_entry(struct scsi_qla_host *vha,\n\tstruct rsp_que *rsp, void *pkt)\n{\n\tsrb_t\t\t*sp;\n\tstruct multi_sts_entry_fx00 *stsmfx;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t handle, hindex, handle_count, i;\n\tuint16_t que;\n\tstruct req_que *req;\n\t__le32 *handle_ptr;\n\n\tstsmfx = (struct multi_sts_entry_fx00 *) pkt;\n\n\thandle_count = stsmfx->handle_count;\n\n\tif (handle_count > MAX_HANDLE_COUNT) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3035,\n\t\t    \"Invalid handle count (0x%x).\\n\", handle_count);\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\t\treturn;\n\t}\n\n\thandle_ptr =  &stsmfx->handles[0];\n\n\tfor (i = 0; i < handle_count; i++) {\n\t\thindex = le32_to_cpu(*handle_ptr);\n\t\thandle = LSW(hindex);\n\t\tque = MSW(hindex);\n\t\treq = ha->req_q_map[que];\n\n\t\t \n\t\tif (handle < req->num_outstanding_cmds)\n\t\t\tsp = req->outstanding_cmds[handle];\n\t\telse\n\t\t\tsp = NULL;\n\n\t\tif (sp == NULL) {\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3044,\n\t\t\t    \"Invalid status handle (0x%x).\\n\", handle);\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\treturn;\n\t\t}\n\t\tqla2x00_process_completed_request(vha, req, handle);\n\t\thandle_ptr++;\n\t}\n}\n\n \nstatic void\nqlafx00_error_entry(scsi_qla_host_t *vha, struct rsp_que *rsp,\n\t\t    struct sts_entry_fx00 *pkt)\n{\n\tsrb_t *sp;\n\tstruct qla_hw_data *ha = vha->hw;\n\tconst char func[] = \"ERROR-IOCB\";\n\tuint16_t que = 0;\n\tstruct req_que *req = NULL;\n\tint res = DID_ERROR << 16;\n\n\treq = ha->req_q_map[que];\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (sp) {\n\t\tsp->done(sp, res);\n\t\treturn;\n\t}\n\n\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\tqla2xxx_wake_dpc(vha);\n}\n\n \nstatic void\nqlafx00_process_response_queue(struct scsi_qla_host *vha,\n\tstruct rsp_que *rsp)\n{\n\tstruct sts_entry_fx00 *pkt;\n\tresponse_t *lptr;\n\tuint16_t lreq_q_in = 0;\n\tuint16_t lreq_q_out = 0;\n\n\tlreq_q_in = rd_reg_dword(rsp->rsp_q_in);\n\tlreq_q_out = rsp->ring_index;\n\n\twhile (lreq_q_in != lreq_q_out) {\n\t\tlptr = rsp->ring_ptr;\n\t\tmemcpy_fromio(rsp->rsp_pkt, (void __iomem *)lptr,\n\t\t    sizeof(rsp->rsp_pkt));\n\t\tpkt = (struct sts_entry_fx00 *)rsp->rsp_pkt;\n\n\t\trsp->ring_index++;\n\t\tlreq_q_out++;\n\t\tif (rsp->ring_index == rsp->length) {\n\t\t\tlreq_q_out = 0;\n\t\t\trsp->ring_index = 0;\n\t\t\trsp->ring_ptr = rsp->ring;\n\t\t} else {\n\t\t\trsp->ring_ptr++;\n\t\t}\n\n\t\tif (pkt->entry_status != 0 &&\n\t\t    pkt->entry_type != IOCTL_IOSB_TYPE_FX00) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x507f,\n\t\t\t       \"type of error status in response: 0x%x\\n\",\n\t\t\t       pkt->entry_status);\n\t\t\tqlafx00_error_entry(vha, rsp,\n\t\t\t\t\t    (struct sts_entry_fx00 *)pkt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (pkt->entry_type) {\n\t\tcase STATUS_TYPE_FX00:\n\t\t\tqlafx00_status_entry(vha, rsp, pkt);\n\t\t\tbreak;\n\n\t\tcase STATUS_CONT_TYPE_FX00:\n\t\t\tqlafx00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);\n\t\t\tbreak;\n\n\t\tcase MULTI_STATUS_TYPE_FX00:\n\t\t\tqlafx00_multistatus_entry(vha, rsp, pkt);\n\t\t\tbreak;\n\n\t\tcase ABORT_IOCB_TYPE_FX00:\n\t\t\tqlafx00_abort_iocb_entry(vha, rsp->req,\n\t\t\t   (struct abort_iocb_entry_fx00 *)pkt);\n\t\t\tbreak;\n\n\t\tcase IOCTL_IOSB_TYPE_FX00:\n\t\t\tqlafx00_ioctl_iosb_entry(vha, rsp->req,\n\t\t\t    (struct ioctl_iocb_entry_fx00 *)pkt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tql_dbg(ql_dbg_async, vha, 0x5081,\n\t\t\t    \"Received unknown response pkt type %x \"\n\t\t\t    \"entry status=%x.\\n\",\n\t\t\t    pkt->entry_type, pkt->entry_status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\twrt_reg_dword(rsp->rsp_q_out, rsp->ring_index);\n}\n\n \nstatic void\nqlafx00_async_event(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_fx00 __iomem *reg;\n\tint data_size = 1;\n\n\treg = &ha->iobase->ispfx00;\n\t \n\tswitch (ha->aenmb[0]) {\n\tcase QLAFX00_MBA_SYSTEM_ERR:\t\t \n\t\tql_log(ql_log_warn, vha, 0x5079,\n\t\t    \"ISP System Error - mbx1=%x\\n\", ha->aenmb[0]);\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase QLAFX00_MBA_SHUTDOWN_RQSTD:\t \n\t\tql_dbg(ql_dbg_async, vha, 0x5076,\n\t\t    \"Asynchronous FW shutdown requested.\\n\");\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\t\tbreak;\n\n\tcase QLAFX00_MBA_PORT_UPDATE:\t\t \n\t\tha->aenmb[1] = rd_reg_dword(&reg->aenmailbox1);\n\t\tha->aenmb[2] = rd_reg_dword(&reg->aenmailbox2);\n\t\tha->aenmb[3] = rd_reg_dword(&reg->aenmailbox3);\n\t\tql_dbg(ql_dbg_async, vha, 0x5077,\n\t\t    \"Asynchronous port Update received \"\n\t\t    \"aenmb[0]: %x, aenmb[1]: %x, aenmb[2]: %x, aenmb[3]: %x\\n\",\n\t\t    ha->aenmb[0], ha->aenmb[1], ha->aenmb[2], ha->aenmb[3]);\n\t\tdata_size = 4;\n\t\tbreak;\n\n\tcase QLAFX00_MBA_TEMP_OVER:\t \n\t\tql_log(ql_log_info, vha, 0x5085,\n\t\t    \"Asynchronous over temperature event received \"\n\t\t    \"aenmb[0]: %x\\n\",\n\t\t    ha->aenmb[0]);\n\t\tbreak;\n\n\tcase QLAFX00_MBA_TEMP_NORM:\t \n\t\tql_log(ql_log_info, vha, 0x5086,\n\t\t    \"Asynchronous normal temperature event received \"\n\t\t    \"aenmb[0]: %x\\n\",\n\t\t    ha->aenmb[0]);\n\t\tbreak;\n\n\tcase QLAFX00_MBA_TEMP_CRIT:\t \n\t\tql_log(ql_log_info, vha, 0x5083,\n\t\t    \"Asynchronous critical temperature event received \"\n\t\t    \"aenmb[0]: %x\\n\",\n\t\tha->aenmb[0]);\n\t\tbreak;\n\n\tdefault:\n\t\tha->aenmb[1] = rd_reg_dword(&reg->aenmailbox1);\n\t\tha->aenmb[2] = rd_reg_dword(&reg->aenmailbox2);\n\t\tha->aenmb[3] = rd_reg_dword(&reg->aenmailbox3);\n\t\tha->aenmb[4] = rd_reg_dword(&reg->aenmailbox4);\n\t\tha->aenmb[5] = rd_reg_dword(&reg->aenmailbox5);\n\t\tha->aenmb[6] = rd_reg_dword(&reg->aenmailbox6);\n\t\tha->aenmb[7] = rd_reg_dword(&reg->aenmailbox7);\n\t\tql_dbg(ql_dbg_async, vha, 0x5078,\n\t\t    \"AEN:%04x %04x %04x %04x :%04x %04x %04x %04x\\n\",\n\t\t    ha->aenmb[0], ha->aenmb[1], ha->aenmb[2], ha->aenmb[3],\n\t\t    ha->aenmb[4], ha->aenmb[5], ha->aenmb[6], ha->aenmb[7]);\n\t\tbreak;\n\t}\n\tqlafx00_post_aenfx_work(vha, ha->aenmb[0],\n\t    (uint32_t *)ha->aenmb, data_size);\n}\n\n \nstatic void\nqlafx00_mbx_completion(scsi_qla_host_t *vha, uint32_t mb0)\n{\n\tuint16_t\tcnt;\n\t__le32 __iomem *wptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\n\n\tif (!ha->mcp32)\n\t\tql_dbg(ql_dbg_async, vha, 0x507e, \"MBX pointer ERROR.\\n\");\n\n\t \n\tha->flags.mbox_int = 1;\n\tha->mailbox_out32[0] = mb0;\n\twptr = &reg->mailbox17;\n\n\tfor (cnt = 1; cnt < ha->mbx_count; cnt++) {\n\t\tha->mailbox_out32[cnt] = rd_reg_dword(wptr);\n\t\twptr++;\n\t}\n}\n\n \nirqreturn_t\nqlafx00_intr_handler(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct device_reg_fx00 __iomem *reg;\n\tint\t\tstatus;\n\tunsigned long\titer;\n\tuint32_t\tstat;\n\tuint32_t\tmb[8];\n\tstruct rsp_que *rsp;\n\tunsigned long\tflags;\n\tuint32_t clr_intr = 0;\n\tuint32_t intr_stat = 0;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tql_log(ql_log_info, NULL, 0x507d,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\n\tha = rsp->hw;\n\treg = &ha->iobase->ispfx00;\n\tstatus = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\tfor (iter = 50; iter--; clr_intr = 0) {\n\t\tstat = QLAFX00_RD_INTR_REG(ha);\n\t\tif (qla2x00_check_reg32_for_disconnect(vha, stat))\n\t\t\tbreak;\n\t\tintr_stat = stat & QLAFX00_HST_INT_STS_BITS;\n\t\tif (!intr_stat)\n\t\t\tbreak;\n\n\t\tif (stat & QLAFX00_INTR_MB_CMPLT) {\n\t\t\tmb[0] = rd_reg_dword(&reg->mailbox16);\n\t\t\tqlafx00_mbx_completion(vha, mb[0]);\n\t\t\tstatus |= MBX_INTERRUPT;\n\t\t\tclr_intr |= QLAFX00_INTR_MB_CMPLT;\n\t\t}\n\t\tif (intr_stat & QLAFX00_INTR_ASYNC_CMPLT) {\n\t\t\tha->aenmb[0] = rd_reg_dword(&reg->aenmailbox0);\n\t\t\tqlafx00_async_event(vha);\n\t\t\tclr_intr |= QLAFX00_INTR_ASYNC_CMPLT;\n\t\t}\n\t\tif (intr_stat & QLAFX00_INTR_RSP_CMPLT) {\n\t\t\tqlafx00_process_response_queue(vha, rsp);\n\t\t\tclr_intr |= QLAFX00_INTR_RSP_CMPLT;\n\t\t}\n\n\t\tQLAFX00_CLR_INTR_REG(ha, clr_intr);\n\t\tQLAFX00_RD_INTR_REG(ha);\n\t}\n\n\tqla2x00_handle_mbx_completion(ha, status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic inline cont_a64_entry_t *\nqlafx00_prep_cont_type1_iocb(struct req_que *req,\n\t\t\t     cont_a64_entry_t *lcont_pkt)\n{\n\tcont_a64_entry_t *cont_pkt;\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else {\n\t\treq->ring_ptr++;\n\t}\n\n\tcont_pkt = (cont_a64_entry_t *)req->ring_ptr;\n\n\t \n\tlcont_pkt->entry_type = CONTINUE_A64_TYPE_FX00;\n\n\treturn cont_pkt;\n}\n\nstatic inline void\nqlafx00_build_scsi_iocbs(srb_t *sp, struct cmd_type_7_fx00 *cmd_pkt,\n\t\t\t uint16_t tot_dsds, struct cmd_type_7_fx00 *lcmd_pkt)\n{\n\tuint16_t\tavail_dsds;\n\tstruct dsd64\t*cur_dsd;\n\tscsi_qla_host_t\t*vha;\n\tstruct scsi_cmnd *cmd;\n\tstruct scatterlist *sg;\n\tint i, cont;\n\tstruct req_que *req;\n\tcont_a64_entry_t lcont_pkt;\n\tcont_a64_entry_t *cont_pkt;\n\n\tvha = sp->vha;\n\treq = vha->req;\n\n\tcmd = GET_CMD_SP(sp);\n\tcont = 0;\n\tcont_pkt = NULL;\n\n\t \n\tlcmd_pkt->entry_type = FX00_COMMAND_TYPE_7;\n\n\t \n\tif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\n\t\tlcmd_pkt->byte_count = cpu_to_le32(0);\n\t\treturn;\n\t}\n\n\t \n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tlcmd_pkt->cntrl_flags = TMF_WRITE_DATA;\n\t\tvha->qla_stats.output_bytes += scsi_bufflen(cmd);\n\t} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tlcmd_pkt->cntrl_flags = TMF_READ_DATA;\n\t\tvha->qla_stats.input_bytes += scsi_bufflen(cmd);\n\t}\n\n\t \n\tavail_dsds = 1;\n\tcur_dsd = &lcmd_pkt->dsd;\n\n\t \n\tscsi_for_each_sg(cmd, sg, tot_dsds, i) {\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tmemset(&lcont_pkt, 0, REQUEST_ENTRY_SIZE);\n\t\t\tcont_pkt =\n\t\t\t    qlafx00_prep_cont_type1_iocb(req, &lcont_pkt);\n\t\t\tcur_dsd = lcont_pkt.dsd;\n\t\t\tavail_dsds = 5;\n\t\t\tcont = 1;\n\t\t}\n\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t\tif (avail_dsds == 0 && cont == 1) {\n\t\t\tcont = 0;\n\t\t\tmemcpy_toio((void __iomem *)cont_pkt, &lcont_pkt,\n\t\t\t    sizeof(lcont_pkt));\n\t\t}\n\n\t}\n\tif (avail_dsds != 0 && cont == 1) {\n\t\tmemcpy_toio((void __iomem *)cont_pkt, &lcont_pkt,\n\t\t    sizeof(lcont_pkt));\n\t}\n}\n\n \nint\nqlafx00_start_scsi(srb_t *sp)\n{\n\tint\t\tnseg;\n\tunsigned long   flags;\n\tuint32_t\thandle;\n\tuint16_t\tcnt;\n\tuint16_t\treq_cnt;\n\tuint16_t\ttot_dsds;\n\tstruct req_que *req = NULL;\n\tstruct rsp_que *rsp = NULL;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct cmd_type_7_fx00 *cmd_pkt;\n\tstruct cmd_type_7_fx00 lcmd_pkt;\n\tstruct scsi_lun llun;\n\n\t \n\trsp = ha->rsp_q_map[0];\n\treq = vha->req;\n\n\t \n\ttot_dsds = 0;\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0)\n\t\tgoto queuing_error;\n\n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t    scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t} else\n\t\tnseg = 0;\n\n\ttot_dsds = nseg;\n\treq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tcnt = rd_reg_dword_relaxed(req->req_q_out);\n\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t\t(req->ring_index - cnt);\n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\t}\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\n\tcmd_pkt = (struct cmd_type_7_fx00 *)req->ring_ptr;\n\n\tmemset(&lcmd_pkt, 0, REQUEST_ENTRY_SIZE);\n\n\tlcmd_pkt.handle = make_handle(req->id, sp->handle);\n\tlcmd_pkt.reserved_0 = 0;\n\tlcmd_pkt.port_path_ctrl = 0;\n\tlcmd_pkt.reserved_1 = 0;\n\tlcmd_pkt.dseg_count = cpu_to_le16(tot_dsds);\n\tlcmd_pkt.tgt_idx = cpu_to_le16(sp->fcport->tgt_id);\n\n\tint_to_scsilun(cmd->device->lun, &llun);\n\thost_to_adap((uint8_t *)&llun, (uint8_t *)&lcmd_pkt.lun,\n\t    sizeof(lcmd_pkt.lun));\n\n\t \n\thost_to_adap(cmd->cmnd, lcmd_pkt.fcp_cdb, sizeof(lcmd_pkt.fcp_cdb));\n\tlcmd_pkt.byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\n\n\t \n\tqlafx00_build_scsi_iocbs(sp, cmd_pkt, tot_dsds, &lcmd_pkt);\n\n\t \n\tlcmd_pkt.entry_count = (uint8_t)req_cnt;\n\n\t \n\tlcmd_pkt.entry_status = (uint8_t) rsp->id;\n\n\tql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x302e,\n\t    cmd->cmnd, cmd->cmd_len);\n\tql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x3032,\n\t    &lcmd_pkt, sizeof(lcmd_pkt));\n\n\tmemcpy_toio((void __iomem *)cmd_pkt, &lcmd_pkt, REQUEST_ENTRY_SIZE);\n\twmb();\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\tsp->flags |= SRB_DMA_VALID;\n\n\t \n\twrt_reg_dword(req->req_q_in, req->ring_index);\n\tQLAFX00_SET_HST_INTR(ha, ha->rqstq_intr_code);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn QLA_SUCCESS;\n\nqueuing_error:\n\tif (tot_dsds)\n\t\tscsi_dma_unmap(cmd);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\nvoid\nqlafx00_tm_iocb(srb_t *sp, struct tsk_mgmt_entry_fx00 *ptm_iocb)\n{\n\tstruct srb_iocb *fxio = &sp->u.iocb_cmd;\n\tscsi_qla_host_t *vha = sp->vha;\n\tstruct req_que *req = vha->req;\n\tstruct tsk_mgmt_entry_fx00 tm_iocb;\n\tstruct scsi_lun llun;\n\n\tmemset(&tm_iocb, 0, sizeof(struct tsk_mgmt_entry_fx00));\n\ttm_iocb.entry_type = TSK_MGMT_IOCB_TYPE_FX00;\n\ttm_iocb.entry_count = 1;\n\ttm_iocb.handle = make_handle(req->id, sp->handle);\n\ttm_iocb.reserved_0 = 0;\n\ttm_iocb.tgt_id = cpu_to_le16(sp->fcport->tgt_id);\n\ttm_iocb.control_flags = cpu_to_le32(fxio->u.tmf.flags);\n\tif (tm_iocb.control_flags == cpu_to_le32((uint32_t)TCF_LUN_RESET)) {\n\t\tint_to_scsilun(fxio->u.tmf.lun, &llun);\n\t\thost_to_adap((uint8_t *)&llun, (uint8_t *)&tm_iocb.lun,\n\t\t    sizeof(struct scsi_lun));\n\t}\n\n\tmemcpy(ptm_iocb, &tm_iocb,\n\t    sizeof(struct tsk_mgmt_entry_fx00));\n\twmb();\n}\n\nvoid\nqlafx00_abort_iocb(srb_t *sp, struct abort_iocb_entry_fx00 *pabt_iocb)\n{\n\tstruct srb_iocb *fxio = &sp->u.iocb_cmd;\n\tscsi_qla_host_t *vha = sp->vha;\n\tstruct req_que *req = vha->req;\n\tstruct abort_iocb_entry_fx00 abt_iocb;\n\n\tmemset(&abt_iocb, 0, sizeof(struct abort_iocb_entry_fx00));\n\tabt_iocb.entry_type = ABORT_IOCB_TYPE_FX00;\n\tabt_iocb.entry_count = 1;\n\tabt_iocb.handle = make_handle(req->id, sp->handle);\n\tabt_iocb.abort_handle = make_handle(req->id, fxio->u.abt.cmd_hndl);\n\tabt_iocb.tgt_id_sts = cpu_to_le16(sp->fcport->tgt_id);\n\tabt_iocb.req_que_no = cpu_to_le16(req->id);\n\n\tmemcpy(pabt_iocb, &abt_iocb,\n\t    sizeof(struct abort_iocb_entry_fx00));\n\twmb();\n}\n\nvoid\nqlafx00_fxdisc_iocb(srb_t *sp, struct fxdisc_entry_fx00 *pfxiocb)\n{\n\tstruct srb_iocb *fxio = &sp->u.iocb_cmd;\n\tstruct qla_mt_iocb_rqst_fx00 *piocb_rqst;\n\tstruct bsg_job *bsg_job;\n\tstruct fc_bsg_request *bsg_request;\n\tstruct fxdisc_entry_fx00 fx_iocb;\n\tuint8_t entry_cnt = 1;\n\n\tmemset(&fx_iocb, 0, sizeof(struct fxdisc_entry_fx00));\n\tfx_iocb.entry_type = FX00_IOCB_TYPE;\n\tfx_iocb.handle = sp->handle;\n\tfx_iocb.entry_count = entry_cnt;\n\n\tif (sp->type == SRB_FXIOCB_DCMD) {\n\t\tfx_iocb.func_num =\n\t\t    sp->u.iocb_cmd.u.fxiocb.req_func_type;\n\t\tfx_iocb.adapid = fxio->u.fxiocb.adapter_id;\n\t\tfx_iocb.adapid_hi = fxio->u.fxiocb.adapter_id_hi;\n\t\tfx_iocb.reserved_0 = fxio->u.fxiocb.reserved_0;\n\t\tfx_iocb.reserved_1 = fxio->u.fxiocb.reserved_1;\n\t\tfx_iocb.dataword_extra = fxio->u.fxiocb.req_data_extra;\n\n\t\tif (fxio->u.fxiocb.flags & SRB_FXDISC_REQ_DMA_VALID) {\n\t\t\tfx_iocb.req_dsdcnt = cpu_to_le16(1);\n\t\t\tfx_iocb.req_xfrcnt =\n\t\t\t    cpu_to_le16(fxio->u.fxiocb.req_len);\n\t\t\tput_unaligned_le64(fxio->u.fxiocb.req_dma_handle,\n\t\t\t\t\t   &fx_iocb.dseg_rq[0].address);\n\t\t\tfx_iocb.dseg_rq[0].length =\n\t\t\t    cpu_to_le32(fxio->u.fxiocb.req_len);\n\t\t}\n\n\t\tif (fxio->u.fxiocb.flags & SRB_FXDISC_RESP_DMA_VALID) {\n\t\t\tfx_iocb.rsp_dsdcnt = cpu_to_le16(1);\n\t\t\tfx_iocb.rsp_xfrcnt =\n\t\t\t    cpu_to_le16(fxio->u.fxiocb.rsp_len);\n\t\t\tput_unaligned_le64(fxio->u.fxiocb.rsp_dma_handle,\n\t\t\t\t\t   &fx_iocb.dseg_rsp[0].address);\n\t\t\tfx_iocb.dseg_rsp[0].length =\n\t\t\t    cpu_to_le32(fxio->u.fxiocb.rsp_len);\n\t\t}\n\n\t\tif (fxio->u.fxiocb.flags & SRB_FXDISC_REQ_DWRD_VALID) {\n\t\t\tfx_iocb.dataword = fxio->u.fxiocb.req_data;\n\t\t}\n\t\tfx_iocb.flags = fxio->u.fxiocb.flags;\n\t} else {\n\t\tstruct scatterlist *sg;\n\n\t\tbsg_job = sp->u.bsg_job;\n\t\tbsg_request = bsg_job->request;\n\t\tpiocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)\n\t\t\t&bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\n\t\tfx_iocb.func_num = piocb_rqst->func_type;\n\t\tfx_iocb.adapid = piocb_rqst->adapid;\n\t\tfx_iocb.adapid_hi = piocb_rqst->adapid_hi;\n\t\tfx_iocb.reserved_0 = piocb_rqst->reserved_0;\n\t\tfx_iocb.reserved_1 = piocb_rqst->reserved_1;\n\t\tfx_iocb.dataword_extra = piocb_rqst->dataword_extra;\n\t\tfx_iocb.dataword = piocb_rqst->dataword;\n\t\tfx_iocb.req_xfrcnt = piocb_rqst->req_len;\n\t\tfx_iocb.rsp_xfrcnt = piocb_rqst->rsp_len;\n\n\t\tif (piocb_rqst->flags & SRB_FXDISC_REQ_DMA_VALID) {\n\t\t\tint avail_dsds, tot_dsds;\n\t\t\tcont_a64_entry_t lcont_pkt;\n\t\t\tcont_a64_entry_t *cont_pkt = NULL;\n\t\t\tstruct dsd64 *cur_dsd;\n\t\t\tint index = 0, cont = 0;\n\n\t\t\tfx_iocb.req_dsdcnt =\n\t\t\t    cpu_to_le16(bsg_job->request_payload.sg_cnt);\n\t\t\ttot_dsds =\n\t\t\t    bsg_job->request_payload.sg_cnt;\n\t\t\tcur_dsd = &fx_iocb.dseg_rq[0];\n\t\t\tavail_dsds = 1;\n\t\t\tfor_each_sg(bsg_job->request_payload.sg_list, sg,\n\t\t\t    tot_dsds, index) {\n\t\t\t\t \n\t\t\t\tif (avail_dsds == 0) {\n\t\t\t\t\t \n\t\t\t\t\tmemset(&lcont_pkt, 0,\n\t\t\t\t\t    REQUEST_ENTRY_SIZE);\n\t\t\t\t\tcont_pkt =\n\t\t\t\t\t    qlafx00_prep_cont_type1_iocb(\n\t\t\t\t\t\tsp->vha->req, &lcont_pkt);\n\t\t\t\t\tcur_dsd = lcont_pkt.dsd;\n\t\t\t\t\tavail_dsds = 5;\n\t\t\t\t\tcont = 1;\n\t\t\t\t\tentry_cnt++;\n\t\t\t\t}\n\n\t\t\t\tappend_dsd64(&cur_dsd, sg);\n\t\t\t\tavail_dsds--;\n\n\t\t\t\tif (avail_dsds == 0 && cont == 1) {\n\t\t\t\t\tcont = 0;\n\t\t\t\t\tmemcpy_toio(\n\t\t\t\t\t    (void __iomem *)cont_pkt,\n\t\t\t\t\t    &lcont_pkt, REQUEST_ENTRY_SIZE);\n\t\t\t\t\tql_dump_buffer(\n\t\t\t\t\t    ql_dbg_user + ql_dbg_verbose,\n\t\t\t\t\t    sp->vha, 0x3042,\n\t\t\t\t\t    (uint8_t *)&lcont_pkt,\n\t\t\t\t\t     REQUEST_ENTRY_SIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avail_dsds != 0 && cont == 1) {\n\t\t\t\tmemcpy_toio((void __iomem *)cont_pkt,\n\t\t\t\t    &lcont_pkt, REQUEST_ENTRY_SIZE);\n\t\t\t\tql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\n\t\t\t\t    sp->vha, 0x3043,\n\t\t\t\t    (uint8_t *)&lcont_pkt, REQUEST_ENTRY_SIZE);\n\t\t\t}\n\t\t}\n\n\t\tif (piocb_rqst->flags & SRB_FXDISC_RESP_DMA_VALID) {\n\t\t\tint avail_dsds, tot_dsds;\n\t\t\tcont_a64_entry_t lcont_pkt;\n\t\t\tcont_a64_entry_t *cont_pkt = NULL;\n\t\t\tstruct dsd64 *cur_dsd;\n\t\t\tint index = 0, cont = 0;\n\n\t\t\tfx_iocb.rsp_dsdcnt =\n\t\t\t   cpu_to_le16(bsg_job->reply_payload.sg_cnt);\n\t\t\ttot_dsds = bsg_job->reply_payload.sg_cnt;\n\t\t\tcur_dsd = &fx_iocb.dseg_rsp[0];\n\t\t\tavail_dsds = 1;\n\n\t\t\tfor_each_sg(bsg_job->reply_payload.sg_list, sg,\n\t\t\t    tot_dsds, index) {\n\t\t\t\t \n\t\t\t\tif (avail_dsds == 0) {\n\t\t\t\t\t \n\t\t\t\t\tmemset(&lcont_pkt, 0,\n\t\t\t\t\t    REQUEST_ENTRY_SIZE);\n\t\t\t\t\tcont_pkt =\n\t\t\t\t\t    qlafx00_prep_cont_type1_iocb(\n\t\t\t\t\t\tsp->vha->req, &lcont_pkt);\n\t\t\t\t\tcur_dsd = lcont_pkt.dsd;\n\t\t\t\t\tavail_dsds = 5;\n\t\t\t\t\tcont = 1;\n\t\t\t\t\tentry_cnt++;\n\t\t\t\t}\n\n\t\t\t\tappend_dsd64(&cur_dsd, sg);\n\t\t\t\tavail_dsds--;\n\n\t\t\t\tif (avail_dsds == 0 && cont == 1) {\n\t\t\t\t\tcont = 0;\n\t\t\t\t\tmemcpy_toio((void __iomem *)cont_pkt,\n\t\t\t\t\t    &lcont_pkt,\n\t\t\t\t\t    REQUEST_ENTRY_SIZE);\n\t\t\t\t\tql_dump_buffer(\n\t\t\t\t\t    ql_dbg_user + ql_dbg_verbose,\n\t\t\t\t\t    sp->vha, 0x3045,\n\t\t\t\t\t    (uint8_t *)&lcont_pkt,\n\t\t\t\t\t    REQUEST_ENTRY_SIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avail_dsds != 0 && cont == 1) {\n\t\t\t\tmemcpy_toio((void __iomem *)cont_pkt,\n\t\t\t\t    &lcont_pkt, REQUEST_ENTRY_SIZE);\n\t\t\t\tql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\n\t\t\t\t    sp->vha, 0x3046,\n\t\t\t\t    (uint8_t *)&lcont_pkt, REQUEST_ENTRY_SIZE);\n\t\t\t}\n\t\t}\n\n\t\tif (piocb_rqst->flags & SRB_FXDISC_REQ_DWRD_VALID)\n\t\t\tfx_iocb.dataword = piocb_rqst->dataword;\n\t\tfx_iocb.flags = piocb_rqst->flags;\n\t\tfx_iocb.entry_count = entry_cnt;\n\t}\n\n\tql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\n\t    sp->vha, 0x3047, &fx_iocb, sizeof(fx_iocb));\n\n\tmemcpy_toio((void __iomem *)pfxiocb, &fx_iocb, sizeof(fx_iocb));\n\twmb();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}