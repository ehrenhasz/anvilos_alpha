{
  "module_name": "qla_isr.c",
  "hash_id": "7b8e0def68b983affe3bbab1adf13e5e11a77d4aa106333a7b68715ff604e0e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_isr.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_target.h\"\n#include \"qla_gbl.h\"\n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/cpu.h>\n#include <linux/t10-pi.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_bsg_fc.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/fc/fc_fs.h>\n#include <linux/nvme-fc-driver.h>\n\nstatic void qla2x00_mbx_completion(scsi_qla_host_t *, uint16_t);\nstatic void qla2x00_status_entry(scsi_qla_host_t *, struct rsp_que *, void *);\nstatic void qla2x00_status_cont_entry(struct rsp_que *, sts_cont_entry_t *);\nstatic int qla2x00_error_entry(scsi_qla_host_t *, struct rsp_que *,\n\tsts_entry_t *);\nstatic void qla27xx_process_purex_fpin(struct scsi_qla_host *vha,\n\tstruct purex_item *item);\nstatic struct purex_item *qla24xx_alloc_purex_item(scsi_qla_host_t *vha,\n\tuint16_t size);\nstatic struct purex_item *qla24xx_copy_std_pkt(struct scsi_qla_host *vha,\n\tvoid *pkt);\nstatic struct purex_item *qla27xx_copy_fpin_pkt(struct scsi_qla_host *vha,\n\tvoid **pkt, struct rsp_que **rsp);\n\nstatic void\nqla27xx_process_purex_fpin(struct scsi_qla_host *vha, struct purex_item *item)\n{\n\tvoid *pkt = &item->iocb;\n\tuint16_t pkt_size = item->size;\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x508d,\n\t       \"%s: Enter\\n\", __func__);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x508e,\n\t       \"-------- ELS REQ -------\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x508f,\n\t\t       pkt, pkt_size);\n\n\tfc_host_fpin_rcv(vha->host, pkt_size, (char *)pkt, 0);\n}\n\nconst char *const port_state_str[] = {\n\t[FCS_UNKNOWN]\t\t= \"Unknown\",\n\t[FCS_UNCONFIGURED]\t= \"UNCONFIGURED\",\n\t[FCS_DEVICE_DEAD]\t= \"DEAD\",\n\t[FCS_DEVICE_LOST]\t= \"LOST\",\n\t[FCS_ONLINE]\t\t= \"ONLINE\"\n};\n\n#define SFP_DISABLE_LASER_INITIATED    0x15   \n#define SFP_ENABLE_LASER_INITIATED     0x16   \n\nstatic inline void display_Laser_info(scsi_qla_host_t *vha,\n\t\t\t\t      u16 mb1, u16 mb2, u16 mb3) {\n\n\tif (mb1 == SFP_DISABLE_LASER_INITIATED)\n\t\tql_log(ql_log_warn, vha, 0xf0a2,\n\t\t       \"SFP temperature (%d C) reached/exceeded the threshold (%d C). Laser is disabled.\\n\",\n\t\t       mb3, mb2);\n\tif (mb1 == SFP_ENABLE_LASER_INITIATED)\n\t\tql_log(ql_log_warn, vha, 0xf0a3,\n\t\t       \"SFP temperature (%d C) reached normal operating level. Laser is enabled.\\n\",\n\t\t       mb3);\n}\n\nstatic void\nqla24xx_process_abts(struct scsi_qla_host *vha, struct purex_item *pkt)\n{\n\tstruct abts_entry_24xx *abts =\n\t    (struct abts_entry_24xx *)&pkt->iocb;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct els_entry_24xx *rsp_els;\n\tstruct abts_entry_24xx *abts_rsp;\n\tdma_addr_t dma;\n\tuint32_t fctl;\n\tint rval;\n\n\tql_dbg(ql_dbg_init, vha, 0x0286, \"%s: entered.\\n\", __func__);\n\n\tql_log(ql_log_warn, vha, 0x0287,\n\t    \"Processing ABTS xchg=%#x oxid=%#x rxid=%#x seqid=%#x seqcnt=%#x\\n\",\n\t    abts->rx_xch_addr_to_abort, abts->ox_id, abts->rx_id,\n\t    abts->seq_id, abts->seq_cnt);\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0287,\n\t    \"-------- ABTS RCV -------\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0287,\n\t    (uint8_t *)abts, sizeof(*abts));\n\n\trsp_els = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_els), &dma,\n\t    GFP_KERNEL);\n\tif (!rsp_els) {\n\t\tql_log(ql_log_warn, vha, 0x0287,\n\t\t    \"Failed allocate dma buffer ABTS/ELS RSP.\\n\");\n\t\treturn;\n\t}\n\n\t \n\trsp_els->entry_type = ELS_IOCB_TYPE;\n\trsp_els->entry_count = 1;\n\trsp_els->nport_handle = cpu_to_le16(~0);\n\trsp_els->rx_xchg_address = abts->rx_xch_addr_to_abort;\n\trsp_els->control_flags = cpu_to_le16(EPD_RX_XCHG);\n\tql_dbg(ql_dbg_init, vha, 0x0283,\n\t    \"Sending ELS Response to terminate exchange %#x...\\n\",\n\t    abts->rx_xch_addr_to_abort);\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0283,\n\t    \"-------- ELS RSP -------\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0283,\n\t    (uint8_t *)rsp_els, sizeof(*rsp_els));\n\trval = qla2x00_issue_iocb(vha, rsp_els, dma, 0);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0288,\n\t\t    \"%s: iocb failed to execute -> %x\\n\", __func__, rval);\n\t} else if (rsp_els->comp_status) {\n\t\tql_log(ql_log_warn, vha, 0x0289,\n\t\t    \"%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\\n\",\n\t\t    __func__, rsp_els->comp_status,\n\t\t    rsp_els->error_subcode_1, rsp_els->error_subcode_2);\n\t} else {\n\t\tql_dbg(ql_dbg_init, vha, 0x028a,\n\t\t    \"%s: abort exchange done.\\n\", __func__);\n\t}\n\n\t \n\tabts_rsp = (void *)rsp_els;\n\tmemset(abts_rsp, 0, sizeof(*abts_rsp));\n\tabts_rsp->entry_type = ABTS_RSP_TYPE;\n\tabts_rsp->entry_count = 1;\n\tabts_rsp->nport_handle = abts->nport_handle;\n\tabts_rsp->vp_idx = abts->vp_idx;\n\tabts_rsp->sof_type = abts->sof_type & 0xf0;\n\tabts_rsp->rx_xch_addr = abts->rx_xch_addr;\n\tabts_rsp->d_id[0] = abts->s_id[0];\n\tabts_rsp->d_id[1] = abts->s_id[1];\n\tabts_rsp->d_id[2] = abts->s_id[2];\n\tabts_rsp->r_ctl = FC_ROUTING_BLD | FC_R_CTL_BLD_BA_ACC;\n\tabts_rsp->s_id[0] = abts->d_id[0];\n\tabts_rsp->s_id[1] = abts->d_id[1];\n\tabts_rsp->s_id[2] = abts->d_id[2];\n\tabts_rsp->cs_ctl = abts->cs_ctl;\n\t \n\tfctl = ~(abts->f_ctl[2] | 0x7F) << 16 |\n\t    FC_F_CTL_LAST_SEQ | FC_F_CTL_END_SEQ | FC_F_CTL_SEQ_INIT;\n\tabts_rsp->f_ctl[0] = fctl >> 0 & 0xff;\n\tabts_rsp->f_ctl[1] = fctl >> 8 & 0xff;\n\tabts_rsp->f_ctl[2] = fctl >> 16 & 0xff;\n\tabts_rsp->type = FC_TYPE_BLD;\n\tabts_rsp->rx_id = abts->rx_id;\n\tabts_rsp->ox_id = abts->ox_id;\n\tabts_rsp->payload.ba_acc.aborted_rx_id = abts->rx_id;\n\tabts_rsp->payload.ba_acc.aborted_ox_id = abts->ox_id;\n\tabts_rsp->payload.ba_acc.high_seq_cnt = cpu_to_le16(~0);\n\tabts_rsp->rx_xch_addr_to_abort = abts->rx_xch_addr_to_abort;\n\tql_dbg(ql_dbg_init, vha, 0x028b,\n\t    \"Sending BA ACC response to ABTS %#x...\\n\",\n\t    abts->rx_xch_addr_to_abort);\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x028b,\n\t    \"-------- ELS RSP -------\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x028b,\n\t    (uint8_t *)abts_rsp, sizeof(*abts_rsp));\n\trval = qla2x00_issue_iocb(vha, abts_rsp, dma, 0);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x028c,\n\t\t    \"%s: iocb failed to execute -> %x\\n\", __func__, rval);\n\t} else if (abts_rsp->comp_status) {\n\t\tql_log(ql_log_warn, vha, 0x028d,\n\t\t    \"%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\\n\",\n\t\t    __func__, abts_rsp->comp_status,\n\t\t    abts_rsp->payload.error.subcode1,\n\t\t    abts_rsp->payload.error.subcode2);\n\t} else {\n\t\tql_dbg(ql_dbg_init, vha, 0x028ea,\n\t\t    \"%s: done.\\n\", __func__);\n\t}\n\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*rsp_els), rsp_els, dma);\n}\n\n \nvoid __qla_consume_iocb(struct scsi_qla_host *vha,\n\tvoid **pkt, struct rsp_que **rsp)\n{\n\tstruct rsp_que *rsp_q = *rsp;\n\tresponse_t *new_pkt;\n\tuint16_t entry_count_remaining;\n\tstruct purex_entry_24xx *purex = *pkt;\n\n\tentry_count_remaining = purex->entry_count;\n\twhile (entry_count_remaining > 0) {\n\t\tnew_pkt = rsp_q->ring_ptr;\n\t\t*pkt = new_pkt;\n\n\t\trsp_q->ring_index++;\n\t\tif (rsp_q->ring_index == rsp_q->length) {\n\t\t\trsp_q->ring_index = 0;\n\t\t\trsp_q->ring_ptr = rsp_q->ring;\n\t\t} else {\n\t\t\trsp_q->ring_ptr++;\n\t\t}\n\n\t\tnew_pkt->signature = RESPONSE_PROCESSED;\n\t\t \n\t\twmb();\n\t\t--entry_count_remaining;\n\t}\n}\n\n \nint __qla_copy_purex_to_buffer(struct scsi_qla_host *vha,\n\tvoid **pkt, struct rsp_que **rsp, u8 *buf, u32 buf_len)\n{\n\tstruct purex_entry_24xx *purex = *pkt;\n\tstruct rsp_que *rsp_q = *rsp;\n\tsts_cont_entry_t *new_pkt;\n\tuint16_t no_bytes = 0, total_bytes = 0, pending_bytes = 0;\n\tuint16_t buffer_copy_offset = 0;\n\tuint16_t entry_count_remaining;\n\tu16 tpad;\n\n\tentry_count_remaining = purex->entry_count;\n\ttotal_bytes = (le16_to_cpu(purex->frame_size) & 0x0FFF)\n\t\t- PURX_ELS_HEADER_SIZE;\n\n\t \n\ttpad = roundup(total_bytes, 4);\n\n\tif (buf_len < tpad) {\n\t\tql_dbg(ql_dbg_async, vha, 0x5084,\n\t\t    \"%s buffer is too small %d < %d\\n\",\n\t\t    __func__, buf_len, tpad);\n\t\t__qla_consume_iocb(vha, pkt, rsp);\n\t\treturn -EIO;\n\t}\n\n\tpending_bytes = total_bytes = tpad;\n\tno_bytes = (pending_bytes > sizeof(purex->els_frame_payload))  ?\n\t    sizeof(purex->els_frame_payload) : pending_bytes;\n\n\tmemcpy(buf, &purex->els_frame_payload[0], no_bytes);\n\tbuffer_copy_offset += no_bytes;\n\tpending_bytes -= no_bytes;\n\t--entry_count_remaining;\n\n\t((response_t *)purex)->signature = RESPONSE_PROCESSED;\n\t \n\twmb();\n\n\tdo {\n\t\twhile ((total_bytes > 0) && (entry_count_remaining > 0)) {\n\t\t\tnew_pkt = (sts_cont_entry_t *)rsp_q->ring_ptr;\n\t\t\t*pkt = new_pkt;\n\n\t\t\tif (new_pkt->entry_type != STATUS_CONT_TYPE) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x507a,\n\t\t\t\t    \"Unexpected IOCB type, partial data 0x%x\\n\",\n\t\t\t\t    buffer_copy_offset);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trsp_q->ring_index++;\n\t\t\tif (rsp_q->ring_index == rsp_q->length) {\n\t\t\t\trsp_q->ring_index = 0;\n\t\t\t\trsp_q->ring_ptr = rsp_q->ring;\n\t\t\t} else {\n\t\t\t\trsp_q->ring_ptr++;\n\t\t\t}\n\t\t\tno_bytes = (pending_bytes > sizeof(new_pkt->data)) ?\n\t\t\t    sizeof(new_pkt->data) : pending_bytes;\n\t\t\tif ((buffer_copy_offset + no_bytes) <= total_bytes) {\n\t\t\t\tmemcpy((buf + buffer_copy_offset), new_pkt->data,\n\t\t\t\t    no_bytes);\n\t\t\t\tbuffer_copy_offset += no_bytes;\n\t\t\t\tpending_bytes -= no_bytes;\n\t\t\t\t--entry_count_remaining;\n\t\t\t} else {\n\t\t\t\tql_log(ql_log_warn, vha, 0x5044,\n\t\t\t\t    \"Attempt to copy more that we got, optimizing..%x\\n\",\n\t\t\t\t    buffer_copy_offset);\n\t\t\t\tmemcpy((buf + buffer_copy_offset), new_pkt->data,\n\t\t\t\t    total_bytes - buffer_copy_offset);\n\t\t\t}\n\n\t\t\t((response_t *)new_pkt)->signature = RESPONSE_PROCESSED;\n\t\t\t \n\t\t\twmb();\n\t\t}\n\n\t\tif (pending_bytes != 0 || entry_count_remaining != 0) {\n\t\t\tql_log(ql_log_fatal, vha, 0x508b,\n\t\t\t    \"Dropping partial Data, underrun bytes = 0x%x, entry cnts 0x%x\\n\",\n\t\t\t    total_bytes, entry_count_remaining);\n\t\t\treturn -EIO;\n\t\t}\n\t} while (entry_count_remaining > 0);\n\n\tbe32_to_cpu_array((u32 *)buf, (__be32 *)buf, total_bytes >> 2);\n\n\treturn 0;\n}\n\n \nirqreturn_t\nqla2100_intr_handler(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct device_reg_2xxx __iomem *reg;\n\tint\t\tstatus;\n\tunsigned long\titer;\n\tuint16_t\thccr;\n\tuint16_t\tmb[8];\n\tstruct rsp_que *rsp;\n\tunsigned long\tflags;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tql_log(ql_log_info, NULL, 0x505d,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn (IRQ_NONE);\n\t}\n\n\tha = rsp->hw;\n\treg = &ha->iobase->isp;\n\tstatus = 0;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\tfor (iter = 50; iter--; ) {\n\t\thccr = rd_reg_word(&reg->hccr);\n\t\tif (qla2x00_check_reg16_for_disconnect(vha, hccr))\n\t\t\tbreak;\n\t\tif (hccr & HCCR_RISC_PAUSE) {\n\t\t\tif (pci_channel_offline(ha->pdev))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\t\t\trd_reg_word(&reg->hccr);\n\n\t\t\tha->isp_ops->fw_dump(vha);\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tbreak;\n\t\t} else if ((rd_reg_word(&reg->istatus) & ISR_RISC_INT) == 0)\n\t\t\tbreak;\n\n\t\tif (rd_reg_word(&reg->semaphore) & BIT_0) {\n\t\t\twrt_reg_word(&reg->hccr, HCCR_CLR_RISC_INT);\n\t\t\trd_reg_word(&reg->hccr);\n\n\t\t\t \n\t\t\tmb[0] = RD_MAILBOX_REG(ha, reg, 0);\n\t\t\tif (mb[0] > 0x3fff && mb[0] < 0x8000) {\n\t\t\t\tqla2x00_mbx_completion(vha, mb[0]);\n\t\t\t\tstatus |= MBX_INTERRUPT;\n\t\t\t} else if (mb[0] > 0x7fff && mb[0] < 0xc000) {\n\t\t\t\tmb[1] = RD_MAILBOX_REG(ha, reg, 1);\n\t\t\t\tmb[2] = RD_MAILBOX_REG(ha, reg, 2);\n\t\t\t\tmb[3] = RD_MAILBOX_REG(ha, reg, 3);\n\t\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x5025,\n\t\t\t\t    \"Unrecognized interrupt type (%d).\\n\",\n\t\t\t\t    mb[0]);\n\t\t\t}\n\t\t\t \n\t\t\twrt_reg_word(&reg->semaphore, 0);\n\t\t\trd_reg_word(&reg->semaphore);\n\t\t} else {\n\t\t\tqla2x00_process_response_queue(rsp);\n\n\t\t\twrt_reg_word(&reg->hccr, HCCR_CLR_RISC_INT);\n\t\t\trd_reg_word(&reg->hccr);\n\t\t}\n\t}\n\tqla2x00_handle_mbx_completion(ha, status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn (IRQ_HANDLED);\n}\n\nbool\nqla2x00_check_reg32_for_disconnect(scsi_qla_host_t *vha, uint32_t reg)\n{\n\t \n\tif (reg == 0xffffffff && !pci_channel_offline(vha->hw->pdev)) {\n\t\tif (!test_and_set_bit(PFLG_DISCONNECTED, &vha->pci_flags) &&\n\t\t    !test_bit(PFLG_DRIVER_REMOVING, &vha->pci_flags) &&\n\t\t    !test_bit(PFLG_DRIVER_PROBING, &vha->pci_flags)) {\n\t\t\tqla_schedule_eeh_work(vha);\n\t\t}\n\t\treturn true;\n\t} else\n\t\treturn false;\n}\n\nbool\nqla2x00_check_reg16_for_disconnect(scsi_qla_host_t *vha, uint16_t reg)\n{\n\treturn qla2x00_check_reg32_for_disconnect(vha, 0xffff0000 | reg);\n}\n\n \nirqreturn_t\nqla2300_intr_handler(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct device_reg_2xxx __iomem *reg;\n\tint\t\tstatus;\n\tunsigned long\titer;\n\tuint32_t\tstat;\n\tuint16_t\thccr;\n\tuint16_t\tmb[8];\n\tstruct rsp_que *rsp;\n\tstruct qla_hw_data *ha;\n\tunsigned long\tflags;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tql_log(ql_log_info, NULL, 0x5058,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn (IRQ_NONE);\n\t}\n\n\tha = rsp->hw;\n\treg = &ha->iobase->isp;\n\tstatus = 0;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\tfor (iter = 50; iter--; ) {\n\t\tstat = rd_reg_dword(&reg->u.isp2300.host_status);\n\t\tif (qla2x00_check_reg32_for_disconnect(vha, stat))\n\t\t\tbreak;\n\t\tif (stat & HSR_RISC_PAUSED) {\n\t\t\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\t\t\tbreak;\n\n\t\t\thccr = rd_reg_word(&reg->hccr);\n\n\t\t\tif (hccr & (BIT_15 | BIT_13 | BIT_11 | BIT_8))\n\t\t\t\tql_log(ql_log_warn, vha, 0x5026,\n\t\t\t\t    \"Parity error -- HCCR=%x, Dumping \"\n\t\t\t\t    \"firmware.\\n\", hccr);\n\t\t\telse\n\t\t\t\tql_log(ql_log_warn, vha, 0x5027,\n\t\t\t\t    \"RISC paused -- HCCR=%x, Dumping \"\n\t\t\t\t    \"firmware.\\n\", hccr);\n\n\t\t\t \n\t\t\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\t\t\trd_reg_word(&reg->hccr);\n\n\t\t\tha->isp_ops->fw_dump(vha);\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tbreak;\n\t\t} else if ((stat & HSR_RISC_INT) == 0)\n\t\t\tbreak;\n\n\t\tswitch (stat & 0xff) {\n\t\tcase 0x1:\n\t\tcase 0x2:\n\t\tcase 0x10:\n\t\tcase 0x11:\n\t\t\tqla2x00_mbx_completion(vha, MSW(stat));\n\t\t\tstatus |= MBX_INTERRUPT;\n\n\t\t\t \n\t\t\twrt_reg_word(&reg->semaphore, 0);\n\t\t\tbreak;\n\t\tcase 0x12:\n\t\t\tmb[0] = MSW(stat);\n\t\t\tmb[1] = RD_MAILBOX_REG(ha, reg, 1);\n\t\t\tmb[2] = RD_MAILBOX_REG(ha, reg, 2);\n\t\t\tmb[3] = RD_MAILBOX_REG(ha, reg, 3);\n\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\tbreak;\n\t\tcase 0x13:\n\t\t\tqla2x00_process_response_queue(rsp);\n\t\t\tbreak;\n\t\tcase 0x15:\n\t\t\tmb[0] = MBA_CMPLT_1_16BIT;\n\t\t\tmb[1] = MSW(stat);\n\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\tbreak;\n\t\tcase 0x16:\n\t\t\tmb[0] = MBA_SCSI_COMPLETION;\n\t\t\tmb[1] = MSW(stat);\n\t\t\tmb[2] = RD_MAILBOX_REG(ha, reg, 2);\n\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5028,\n\t\t\t    \"Unrecognized interrupt type (%d).\\n\", stat & 0xff);\n\t\t\tbreak;\n\t\t}\n\t\twrt_reg_word(&reg->hccr, HCCR_CLR_RISC_INT);\n\t\trd_reg_word_relaxed(&reg->hccr);\n\t}\n\tqla2x00_handle_mbx_completion(ha, status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn (IRQ_HANDLED);\n}\n\n \nstatic void\nqla2x00_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)\n{\n\tuint16_t\tcnt;\n\tuint32_t\tmboxes;\n\t__le16 __iomem *wptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\t \n\tWARN_ON_ONCE(ha->mbx_count > 32);\n\tmboxes = (1ULL << ha->mbx_count) - 1;\n\tif (!ha->mcp)\n\t\tql_dbg(ql_dbg_async, vha, 0x5001, \"MBX pointer ERROR.\\n\");\n\telse\n\t\tmboxes = ha->mcp->in_mb;\n\n\t \n\tha->flags.mbox_int = 1;\n\tha->mailbox_out[0] = mb0;\n\tmboxes >>= 1;\n\twptr = MAILBOX_REG(ha, reg, 1);\n\n\tfor (cnt = 1; cnt < ha->mbx_count; cnt++) {\n\t\tif (IS_QLA2200(ha) && cnt == 8)\n\t\t\twptr = MAILBOX_REG(ha, reg, 8);\n\t\tif ((cnt == 4 || cnt == 5) && (mboxes & BIT_0))\n\t\t\tha->mailbox_out[cnt] = qla2x00_debounce_register(wptr);\n\t\telse if (mboxes & BIT_0)\n\t\t\tha->mailbox_out[cnt] = rd_reg_word(wptr);\n\n\t\twptr++;\n\t\tmboxes >>= 1;\n\t}\n}\n\nstatic void\nqla81xx_idc_event(scsi_qla_host_t *vha, uint16_t aen, uint16_t descr)\n{\n\tstatic char *event[] =\n\t\t{ \"Complete\", \"Request Notification\", \"Time Extension\" };\n\tint rval;\n\tstruct device_reg_24xx __iomem *reg24 = &vha->hw->iobase->isp24;\n\tstruct device_reg_82xx __iomem *reg82 = &vha->hw->iobase->isp82;\n\t__le16 __iomem *wptr;\n\tuint16_t cnt, timeout, mb[QLA_IDC_ACK_REGS];\n\n\t \n\tif (IS_QLA81XX(vha->hw) || IS_QLA83XX(vha->hw))\n\t\twptr = &reg24->mailbox1;\n\telse if (IS_QLA8044(vha->hw))\n\t\twptr = &reg82->mailbox_out[1];\n\telse\n\t\treturn;\n\n\tfor (cnt = 0; cnt < QLA_IDC_ACK_REGS; cnt++, wptr++)\n\t\tmb[cnt] = rd_reg_word(wptr);\n\n\tql_dbg(ql_dbg_async, vha, 0x5021,\n\t    \"Inter-Driver Communication %s -- \"\n\t    \"%04x %04x %04x %04x %04x %04x %04x.\\n\",\n\t    event[aen & 0xff], mb[0], mb[1], mb[2], mb[3],\n\t    mb[4], mb[5], mb[6]);\n\tswitch (aen) {\n\t \n\tcase MBA_IDC_COMPLETE:\n\t\tif (mb[1] >> 15) {\n\t\t\tvha->hw->flags.idc_compl_status = 1;\n\t\t\tif (vha->hw->notify_dcbx_comp && !vha->vp_idx)\n\t\t\t\tcomplete(&vha->hw->dcbx_comp);\n\t\t}\n\t\tbreak;\n\n\tcase MBA_IDC_NOTIFY:\n\t\t \n\t\ttimeout = (descr >> 8) & 0xf;\n\t\tql_dbg(ql_dbg_async, vha, 0x5022,\n\t\t    \"%lu Inter-Driver Communication %s -- ACK timeout=%d.\\n\",\n\t\t    vha->host_no, event[aen & 0xff], timeout);\n\n\t\tif (!timeout)\n\t\t\treturn;\n\t\trval = qla2x00_post_idc_ack_work(vha, mb);\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tql_log(ql_log_warn, vha, 0x5023,\n\t\t\t    \"IDC failed to post ACK.\\n\");\n\t\tbreak;\n\tcase MBA_IDC_TIME_EXT:\n\t\tvha->hw->idc_extend_tmo = descr;\n\t\tql_dbg(ql_dbg_async, vha, 0x5087,\n\t\t    \"%lu Inter-Driver Communication %s -- \"\n\t\t    \"Extend timeout by=%d.\\n\",\n\t\t    vha->host_no, event[aen & 0xff], vha->hw->idc_extend_tmo);\n\t\tbreak;\n\t}\n}\n\n#define LS_UNKNOWN\t2\nconst char *\nqla2x00_get_link_speed_str(struct qla_hw_data *ha, uint16_t speed)\n{\n\tstatic const char *const link_speeds[] = {\n\t\t\"1\", \"2\", \"?\", \"4\", \"8\", \"16\", \"32\", \"64\", \"10\"\n\t};\n#define\tQLA_LAST_SPEED (ARRAY_SIZE(link_speeds) - 1)\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn link_speeds[0];\n\telse if (speed == 0x13)\n\t\treturn link_speeds[QLA_LAST_SPEED];\n\telse if (speed < QLA_LAST_SPEED)\n\t\treturn link_speeds[speed];\n\telse\n\t\treturn link_speeds[LS_UNKNOWN];\n}\n\nstatic void\nqla83xx_handle_8200_aen(scsi_qla_host_t *vha, uint16_t *mb)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tql_dbg(ql_dbg_async, vha, 0x506b, \"AEN Code: mb[0] = 0x%x AEN reason: \"\n\t    \"mb[1] = 0x%x PH-status1: mb[2] = 0x%x PH-status1: mb[6] = 0x%x.\\n\",\n\t    mb[0], mb[1], mb[2], mb[6]);\n\tql_dbg(ql_dbg_async, vha, 0x506c, \"PH-status2: mb[3] = 0x%x \"\n\t    \"PH-status2: mb[7] = 0x%x Device-State: mb[4] = 0x%x \"\n\t    \"Drv-Presence: mb[5] = 0x%x.\\n\", mb[3], mb[7], mb[4], mb[5]);\n\n\tif (mb[1] & (IDC_PEG_HALT_STATUS_CHANGE | IDC_NIC_FW_REPORTED_FAILURE |\n\t\t\t\tIDC_HEARTBEAT_FAILURE)) {\n\t\tha->flags.nic_core_hung = 1;\n\t\tql_log(ql_log_warn, vha, 0x5060,\n\t\t    \"83XX: F/W Error Reported: Check if reset required.\\n\");\n\n\t\tif (mb[1] & IDC_PEG_HALT_STATUS_CHANGE) {\n\t\t\tuint32_t protocol_engine_id, fw_err_code, err_level;\n\n\t\t\t \n\t\t\tprotocol_engine_id = (mb[2] & 0xff);\n\t\t\tfw_err_code = (((mb[2] & 0xff00) >> 8) |\n\t\t\t    ((mb[6] & 0x1fff) << 8));\n\t\t\terr_level = ((mb[6] & 0xe000) >> 13);\n\t\t\tql_log(ql_log_warn, vha, 0x5061, \"PegHalt Status-1 \"\n\t\t\t    \"Register: protocol_engine_id=0x%x \"\n\t\t\t    \"fw_err_code=0x%x err_level=0x%x.\\n\",\n\t\t\t    protocol_engine_id, fw_err_code, err_level);\n\t\t\tql_log(ql_log_warn, vha, 0x5062, \"PegHalt Status-2 \"\n\t\t\t    \"Register: 0x%x%x.\\n\", mb[7], mb[3]);\n\t\t\tif (err_level == ERR_LEVEL_NON_FATAL) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x5063,\n\t\t\t\t    \"Not a fatal error, f/w has recovered itself.\\n\");\n\t\t\t} else if (err_level == ERR_LEVEL_RECOVERABLE_FATAL) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x5064,\n\t\t\t\t    \"Recoverable Fatal error: Chip reset \"\n\t\t\t\t    \"required.\\n\");\n\t\t\t\tqla83xx_schedule_work(vha,\n\t\t\t\t    QLA83XX_NIC_CORE_RESET);\n\t\t\t} else if (err_level == ERR_LEVEL_UNRECOVERABLE_FATAL) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x5065,\n\t\t\t\t    \"Unrecoverable Fatal error: Set FAILED \"\n\t\t\t\t    \"state, reboot required.\\n\");\n\t\t\t\tqla83xx_schedule_work(vha,\n\t\t\t\t    QLA83XX_NIC_CORE_UNRECOVERABLE);\n\t\t\t}\n\t\t}\n\n\t\tif (mb[1] & IDC_NIC_FW_REPORTED_FAILURE) {\n\t\t\tuint16_t peg_fw_state, nw_interface_link_up;\n\t\t\tuint16_t nw_interface_signal_detect, sfp_status;\n\t\t\tuint16_t htbt_counter, htbt_monitor_enable;\n\t\t\tuint16_t sfp_additional_info, sfp_multirate;\n\t\t\tuint16_t sfp_tx_fault, link_speed, dcbx_status;\n\n\t\t\t \n\t\t\tpeg_fw_state = (mb[2] & 0x00ff);\n\t\t\tnw_interface_link_up = ((mb[2] & 0x0100) >> 8);\n\t\t\tnw_interface_signal_detect = ((mb[2] & 0x0200) >> 9);\n\t\t\tsfp_status = ((mb[2] & 0x0c00) >> 10);\n\t\t\thtbt_counter = ((mb[2] & 0x7000) >> 12);\n\t\t\thtbt_monitor_enable = ((mb[2] & 0x8000) >> 15);\n\t\t\tsfp_additional_info = (mb[6] & 0x0003);\n\t\t\tsfp_multirate = ((mb[6] & 0x0004) >> 2);\n\t\t\tsfp_tx_fault = ((mb[6] & 0x0008) >> 3);\n\t\t\tlink_speed = ((mb[6] & 0x0070) >> 4);\n\t\t\tdcbx_status = ((mb[6] & 0x7000) >> 12);\n\n\t\t\tql_log(ql_log_warn, vha, 0x5066,\n\t\t\t    \"Peg-to-Fc Status Register:\\n\"\n\t\t\t    \"peg_fw_state=0x%x, nw_interface_link_up=0x%x, \"\n\t\t\t    \"nw_interface_signal_detect=0x%x\"\n\t\t\t    \"\\nsfp_statis=0x%x.\\n \", peg_fw_state,\n\t\t\t    nw_interface_link_up, nw_interface_signal_detect,\n\t\t\t    sfp_status);\n\t\t\tql_log(ql_log_warn, vha, 0x5067,\n\t\t\t    \"htbt_counter=0x%x, htbt_monitor_enable=0x%x, \"\n\t\t\t    \"sfp_additional_info=0x%x, sfp_multirate=0x%x.\\n \",\n\t\t\t    htbt_counter, htbt_monitor_enable,\n\t\t\t    sfp_additional_info, sfp_multirate);\n\t\t\tql_log(ql_log_warn, vha, 0x5068,\n\t\t\t    \"sfp_tx_fault=0x%x, link_state=0x%x, \"\n\t\t\t    \"dcbx_status=0x%x.\\n\", sfp_tx_fault, link_speed,\n\t\t\t    dcbx_status);\n\n\t\t\tqla83xx_schedule_work(vha, QLA83XX_NIC_CORE_RESET);\n\t\t}\n\n\t\tif (mb[1] & IDC_HEARTBEAT_FAILURE) {\n\t\t\tql_log(ql_log_warn, vha, 0x5069,\n\t\t\t    \"Heartbeat Failure encountered, chip reset \"\n\t\t\t    \"required.\\n\");\n\n\t\t\tqla83xx_schedule_work(vha, QLA83XX_NIC_CORE_RESET);\n\t\t}\n\t}\n\n\tif (mb[1] & IDC_DEVICE_STATE_CHANGE) {\n\t\tql_log(ql_log_info, vha, 0x506a,\n\t\t    \"IDC Device-State changed = 0x%x.\\n\", mb[4]);\n\t\tif (ha->flags.nic_core_reset_owner)\n\t\t\treturn;\n\t\tqla83xx_schedule_work(vha, MBA_IDC_AEN);\n\t}\n}\n\n \nstruct purex_item *\nqla27xx_copy_multiple_pkt(struct scsi_qla_host *vha, void **pkt,\n\t\t\t  struct rsp_que **rsp, bool is_purls,\n\t\t\t  bool byte_order)\n{\n\tstruct purex_entry_24xx *purex = NULL;\n\tstruct pt_ls4_rx_unsol *purls = NULL;\n\tstruct rsp_que *rsp_q = *rsp;\n\tsts_cont_entry_t *new_pkt;\n\tuint16_t no_bytes = 0, total_bytes = 0, pending_bytes = 0;\n\tuint16_t buffer_copy_offset = 0, payload_size = 0;\n\tuint16_t entry_count, entry_count_remaining;\n\tstruct purex_item *item;\n\tvoid *iocb_pkt = NULL;\n\n\tif (is_purls) {\n\t\tpurls = *pkt;\n\t\ttotal_bytes = (le16_to_cpu(purls->frame_size) & 0x0FFF) -\n\t\t\t      PURX_ELS_HEADER_SIZE;\n\t\tentry_count = entry_count_remaining = purls->entry_count;\n\t\tpayload_size = sizeof(purls->payload);\n\t} else {\n\t\tpurex = *pkt;\n\t\ttotal_bytes = (le16_to_cpu(purex->frame_size) & 0x0FFF) -\n\t\t\t      PURX_ELS_HEADER_SIZE;\n\t\tentry_count = entry_count_remaining = purex->entry_count;\n\t\tpayload_size = sizeof(purex->els_frame_payload);\n\t}\n\n\tpending_bytes = total_bytes;\n\tno_bytes = (pending_bytes > payload_size) ? payload_size :\n\t\t   pending_bytes;\n\tql_dbg(ql_dbg_async, vha, 0x509a,\n\t       \"%s LS, frame_size 0x%x, entry count %d\\n\",\n\t       (is_purls ? \"PURLS\" : \"FPIN\"), total_bytes, entry_count);\n\n\titem = qla24xx_alloc_purex_item(vha, total_bytes);\n\tif (!item)\n\t\treturn item;\n\n\tiocb_pkt = &item->iocb;\n\n\tif (is_purls)\n\t\tmemcpy(iocb_pkt, &purls->payload[0], no_bytes);\n\telse\n\t\tmemcpy(iocb_pkt, &purex->els_frame_payload[0], no_bytes);\n\tbuffer_copy_offset += no_bytes;\n\tpending_bytes -= no_bytes;\n\t--entry_count_remaining;\n\n\tif (is_purls)\n\t\t((response_t *)purls)->signature = RESPONSE_PROCESSED;\n\telse\n\t\t((response_t *)purex)->signature = RESPONSE_PROCESSED;\n\twmb();\n\n\tdo {\n\t\twhile ((total_bytes > 0) && (entry_count_remaining > 0)) {\n\t\t\tif (rsp_q->ring_ptr->signature == RESPONSE_PROCESSED) {\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x5084,\n\t\t\t\t       \"Ran out of IOCBs, partial data 0x%x\\n\",\n\t\t\t\t       buffer_copy_offset);\n\t\t\t\tcpu_relax();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnew_pkt = (sts_cont_entry_t *)rsp_q->ring_ptr;\n\t\t\t*pkt = new_pkt;\n\n\t\t\tif (new_pkt->entry_type != STATUS_CONT_TYPE) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x507a,\n\t\t\t\t       \"Unexpected IOCB type, partial data 0x%x\\n\",\n\t\t\t\t       buffer_copy_offset);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trsp_q->ring_index++;\n\t\t\tif (rsp_q->ring_index == rsp_q->length) {\n\t\t\t\trsp_q->ring_index = 0;\n\t\t\t\trsp_q->ring_ptr = rsp_q->ring;\n\t\t\t} else {\n\t\t\t\trsp_q->ring_ptr++;\n\t\t\t}\n\t\t\tno_bytes = (pending_bytes > sizeof(new_pkt->data)) ?\n\t\t\t\tsizeof(new_pkt->data) : pending_bytes;\n\t\t\tif ((buffer_copy_offset + no_bytes) <= total_bytes) {\n\t\t\t\tmemcpy(((uint8_t *)iocb_pkt + buffer_copy_offset),\n\t\t\t\t       new_pkt->data, no_bytes);\n\t\t\t\tbuffer_copy_offset += no_bytes;\n\t\t\t\tpending_bytes -= no_bytes;\n\t\t\t\t--entry_count_remaining;\n\t\t\t} else {\n\t\t\t\tql_log(ql_log_warn, vha, 0x5044,\n\t\t\t\t       \"Attempt to copy more that we got, optimizing..%x\\n\",\n\t\t\t\t       buffer_copy_offset);\n\t\t\t\tmemcpy(((uint8_t *)iocb_pkt + buffer_copy_offset),\n\t\t\t\t       new_pkt->data,\n\t\t\t\t       total_bytes - buffer_copy_offset);\n\t\t\t}\n\n\t\t\t((response_t *)new_pkt)->signature = RESPONSE_PROCESSED;\n\t\t\twmb();\n\t\t}\n\n\t\tif (pending_bytes != 0 || entry_count_remaining != 0) {\n\t\t\tql_log(ql_log_fatal, vha, 0x508b,\n\t\t\t       \"Dropping partial FPIN, underrun bytes = 0x%x, entry cnts 0x%x\\n\",\n\t\t\t       total_bytes, entry_count_remaining);\n\t\t\tqla24xx_free_purex_item(item);\n\t\t\treturn NULL;\n\t\t}\n\t} while (entry_count_remaining > 0);\n\n\tif (byte_order)\n\t\thost_to_fcp_swap((uint8_t *)&item->iocb, total_bytes);\n\n\treturn item;\n}\n\nint\nqla2x00_is_a_vp_did(scsi_qla_host_t *vha, uint32_t rscn_entry)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *vp;\n\tuint32_t vp_did;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!ha->num_vhosts)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tlist_for_each_entry(vp, &ha->vp_list, list) {\n\t\tvp_did = vp->d_id.b24;\n\t\tif (vp_did == rscn_entry) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\treturn ret;\n}\n\nfc_port_t *\nqla2x00_find_fcport_by_loopid(scsi_qla_host_t *vha, uint16_t loop_id)\n{\n\tfc_port_t *f, *tf;\n\n\tf = tf = NULL;\n\tlist_for_each_entry_safe(f, tf, &vha->vp_fcports, list)\n\t\tif (f->loop_id == loop_id)\n\t\t\treturn f;\n\treturn NULL;\n}\n\nfc_port_t *\nqla2x00_find_fcport_by_wwpn(scsi_qla_host_t *vha, u8 *wwpn, u8 incl_deleted)\n{\n\tfc_port_t *f, *tf;\n\n\tf = tf = NULL;\n\tlist_for_each_entry_safe(f, tf, &vha->vp_fcports, list) {\n\t\tif (memcmp(f->port_name, wwpn, WWN_SIZE) == 0) {\n\t\t\tif (incl_deleted)\n\t\t\t\treturn f;\n\t\t\telse if (f->deleted == 0)\n\t\t\t\treturn f;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nfc_port_t *\nqla2x00_find_fcport_by_nportid(scsi_qla_host_t *vha, port_id_t *id,\n\tu8 incl_deleted)\n{\n\tfc_port_t *f, *tf;\n\n\tf = tf = NULL;\n\tlist_for_each_entry_safe(f, tf, &vha->vp_fcports, list) {\n\t\tif (f->d_id.b24 == id->b24) {\n\t\t\tif (incl_deleted)\n\t\t\t\treturn f;\n\t\t\telse if (f->deleted == 0)\n\t\t\t\treturn f;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic void\nqla27xx_handle_8200_aen(scsi_qla_host_t *vha, uint16_t *mb)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tbool reset_isp_needed = false;\n\n\tql_log(ql_log_warn, vha, 0x02f0,\n\t       \"MPI Heartbeat stop. MPI reset is%s needed. \"\n\t       \"MB0[%xh] MB1[%xh] MB2[%xh] MB3[%xh]\\n\",\n\t       mb[1] & BIT_8 ? \"\" : \" not\",\n\t       mb[0], mb[1], mb[2], mb[3]);\n\n\tif ((mb[1] & BIT_8) == 0)\n\t\treturn;\n\n\tql_log(ql_log_warn, vha, 0x02f1,\n\t       \"MPI Heartbeat stop. FW dump needed\\n\");\n\n\tif (ql2xfulldump_on_mpifail) {\n\t\tha->isp_ops->fw_dump(vha);\n\t\treset_isp_needed = true;\n\t}\n\n\tha->isp_ops->mpi_fw_dump(vha, 1);\n\n\tif (reset_isp_needed) {\n\t\tvha->hw->flags.fw_init_done = 0;\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\t}\n}\n\nstatic struct purex_item *\nqla24xx_alloc_purex_item(scsi_qla_host_t *vha, uint16_t size)\n{\n\tstruct purex_item *item = NULL;\n\tuint8_t item_hdr_size = sizeof(*item);\n\n\tif (size > QLA_DEFAULT_PAYLOAD_SIZE) {\n\t\titem = kzalloc(item_hdr_size +\n\t\t    (size - QLA_DEFAULT_PAYLOAD_SIZE), GFP_ATOMIC);\n\t} else {\n\t\tif (atomic_inc_return(&vha->default_item.in_use) == 1) {\n\t\t\titem = &vha->default_item;\n\t\t\tgoto initialize_purex_header;\n\t\t} else {\n\t\t\titem = kzalloc(item_hdr_size, GFP_ATOMIC);\n\t\t}\n\t}\n\tif (!item) {\n\t\tql_log(ql_log_warn, vha, 0x5092,\n\t\t       \">> Failed allocate purex list item.\\n\");\n\n\t\treturn NULL;\n\t}\n\ninitialize_purex_header:\n\titem->vha = vha;\n\titem->size = size;\n\treturn item;\n}\n\nvoid\nqla24xx_queue_purex_item(scsi_qla_host_t *vha, struct purex_item *pkt,\n\t\t\t void (*process_item)(struct scsi_qla_host *vha,\n\t\t\t\t\t      struct purex_item *pkt))\n{\n\tstruct purex_list *list = &vha->purex_list;\n\tulong flags;\n\n\tpkt->process_item = process_item;\n\n\tspin_lock_irqsave(&list->lock, flags);\n\tlist_add_tail(&pkt->list, &list->head);\n\tspin_unlock_irqrestore(&list->lock, flags);\n\n\tset_bit(PROCESS_PUREX_IOCB, &vha->dpc_flags);\n}\n\n \nstatic struct purex_item\n*qla24xx_copy_std_pkt(struct scsi_qla_host *vha, void *pkt)\n{\n\tstruct purex_item *item;\n\n\titem = qla24xx_alloc_purex_item(vha,\n\t\t\t\t\tQLA_DEFAULT_PAYLOAD_SIZE);\n\tif (!item)\n\t\treturn item;\n\n\tmemcpy(&item->iocb, pkt, sizeof(item->iocb));\n\treturn item;\n}\n\n \nstatic struct purex_item *\nqla27xx_copy_fpin_pkt(struct scsi_qla_host *vha, void **pkt,\n\t\t      struct rsp_que **rsp)\n{\n\tstruct purex_entry_24xx *purex = *pkt;\n\tstruct rsp_que *rsp_q = *rsp;\n\tsts_cont_entry_t *new_pkt;\n\tuint16_t no_bytes = 0, total_bytes = 0, pending_bytes = 0;\n\tuint16_t buffer_copy_offset = 0;\n\tuint16_t entry_count, entry_count_remaining;\n\tstruct purex_item *item;\n\tvoid *fpin_pkt = NULL;\n\n\ttotal_bytes = (le16_to_cpu(purex->frame_size) & 0x0FFF)\n\t    - PURX_ELS_HEADER_SIZE;\n\tpending_bytes = total_bytes;\n\tentry_count = entry_count_remaining = purex->entry_count;\n\tno_bytes = (pending_bytes > sizeof(purex->els_frame_payload))  ?\n\t\t   sizeof(purex->els_frame_payload) : pending_bytes;\n\tql_log(ql_log_info, vha, 0x509a,\n\t       \"FPIN ELS, frame_size 0x%x, entry count %d\\n\",\n\t       total_bytes, entry_count);\n\n\titem = qla24xx_alloc_purex_item(vha, total_bytes);\n\tif (!item)\n\t\treturn item;\n\n\tfpin_pkt = &item->iocb;\n\n\tmemcpy(fpin_pkt, &purex->els_frame_payload[0], no_bytes);\n\tbuffer_copy_offset += no_bytes;\n\tpending_bytes -= no_bytes;\n\t--entry_count_remaining;\n\n\t((response_t *)purex)->signature = RESPONSE_PROCESSED;\n\twmb();\n\n\tdo {\n\t\twhile ((total_bytes > 0) && (entry_count_remaining > 0)) {\n\t\t\tif (rsp_q->ring_ptr->signature == RESPONSE_PROCESSED) {\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x5084,\n\t\t\t\t       \"Ran out of IOCBs, partial data 0x%x\\n\",\n\t\t\t\t       buffer_copy_offset);\n\t\t\t\tcpu_relax();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnew_pkt = (sts_cont_entry_t *)rsp_q->ring_ptr;\n\t\t\t*pkt = new_pkt;\n\n\t\t\tif (new_pkt->entry_type != STATUS_CONT_TYPE) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x507a,\n\t\t\t\t       \"Unexpected IOCB type, partial data 0x%x\\n\",\n\t\t\t\t       buffer_copy_offset);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trsp_q->ring_index++;\n\t\t\tif (rsp_q->ring_index == rsp_q->length) {\n\t\t\t\trsp_q->ring_index = 0;\n\t\t\t\trsp_q->ring_ptr = rsp_q->ring;\n\t\t\t} else {\n\t\t\t\trsp_q->ring_ptr++;\n\t\t\t}\n\t\t\tno_bytes = (pending_bytes > sizeof(new_pkt->data)) ?\n\t\t\t    sizeof(new_pkt->data) : pending_bytes;\n\t\t\tif ((buffer_copy_offset + no_bytes) <= total_bytes) {\n\t\t\t\tmemcpy(((uint8_t *)fpin_pkt +\n\t\t\t\t    buffer_copy_offset), new_pkt->data,\n\t\t\t\t    no_bytes);\n\t\t\t\tbuffer_copy_offset += no_bytes;\n\t\t\t\tpending_bytes -= no_bytes;\n\t\t\t\t--entry_count_remaining;\n\t\t\t} else {\n\t\t\t\tql_log(ql_log_warn, vha, 0x5044,\n\t\t\t\t       \"Attempt to copy more that we got, optimizing..%x\\n\",\n\t\t\t\t       buffer_copy_offset);\n\t\t\t\tmemcpy(((uint8_t *)fpin_pkt +\n\t\t\t\t    buffer_copy_offset), new_pkt->data,\n\t\t\t\t    total_bytes - buffer_copy_offset);\n\t\t\t}\n\n\t\t\t((response_t *)new_pkt)->signature = RESPONSE_PROCESSED;\n\t\t\twmb();\n\t\t}\n\n\t\tif (pending_bytes != 0 || entry_count_remaining != 0) {\n\t\t\tql_log(ql_log_fatal, vha, 0x508b,\n\t\t\t       \"Dropping partial FPIN, underrun bytes = 0x%x, entry cnts 0x%x\\n\",\n\t\t\t       total_bytes, entry_count_remaining);\n\t\t\tqla24xx_free_purex_item(item);\n\t\t\treturn NULL;\n\t\t}\n\t} while (entry_count_remaining > 0);\n\thost_to_fcp_swap((uint8_t *)&item->iocb, total_bytes);\n\treturn item;\n}\n\n \nvoid\nqla2x00_async_event(scsi_qla_host_t *vha, struct rsp_que *rsp, uint16_t *mb)\n{\n\tuint16_t\thandle_cnt;\n\tuint16_t\tcnt, mbx;\n\tuint32_t\thandles[5];\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tstruct device_reg_24xx __iomem *reg24 = &ha->iobase->isp24;\n\tstruct device_reg_82xx __iomem *reg82 = &ha->iobase->isp82;\n\tuint32_t\trscn_entry, host_pid;\n\tunsigned long\tflags;\n\tfc_port_t\t*fcport = NULL;\n\n\tif (!vha->hw->flags.fw_started) {\n\t\tql_log(ql_log_warn, vha, 0x50ff,\n\t\t    \"Dropping AEN - %04x %04x %04x %04x.\\n\",\n\t\t    mb[0], mb[1], mb[2], mb[3]);\n\t\treturn;\n\t}\n\n\t \n\thandle_cnt = 0;\n\tif (IS_CNA_CAPABLE(ha))\n\t\tgoto skip_rio;\n\tswitch (mb[0]) {\n\tcase MBA_SCSI_COMPLETION:\n\t\thandles[0] = make_handle(mb[2], mb[1]);\n\t\thandle_cnt = 1;\n\t\tbreak;\n\tcase MBA_CMPLT_1_16BIT:\n\t\thandles[0] = mb[1];\n\t\thandle_cnt = 1;\n\t\tmb[0] = MBA_SCSI_COMPLETION;\n\t\tbreak;\n\tcase MBA_CMPLT_2_16BIT:\n\t\thandles[0] = mb[1];\n\t\thandles[1] = mb[2];\n\t\thandle_cnt = 2;\n\t\tmb[0] = MBA_SCSI_COMPLETION;\n\t\tbreak;\n\tcase MBA_CMPLT_3_16BIT:\n\t\thandles[0] = mb[1];\n\t\thandles[1] = mb[2];\n\t\thandles[2] = mb[3];\n\t\thandle_cnt = 3;\n\t\tmb[0] = MBA_SCSI_COMPLETION;\n\t\tbreak;\n\tcase MBA_CMPLT_4_16BIT:\n\t\thandles[0] = mb[1];\n\t\thandles[1] = mb[2];\n\t\thandles[2] = mb[3];\n\t\thandles[3] = (uint32_t)RD_MAILBOX_REG(ha, reg, 6);\n\t\thandle_cnt = 4;\n\t\tmb[0] = MBA_SCSI_COMPLETION;\n\t\tbreak;\n\tcase MBA_CMPLT_5_16BIT:\n\t\thandles[0] = mb[1];\n\t\thandles[1] = mb[2];\n\t\thandles[2] = mb[3];\n\t\thandles[3] = (uint32_t)RD_MAILBOX_REG(ha, reg, 6);\n\t\thandles[4] = (uint32_t)RD_MAILBOX_REG(ha, reg, 7);\n\t\thandle_cnt = 5;\n\t\tmb[0] = MBA_SCSI_COMPLETION;\n\t\tbreak;\n\tcase MBA_CMPLT_2_32BIT:\n\t\thandles[0] = make_handle(mb[2], mb[1]);\n\t\thandles[1] = make_handle(RD_MAILBOX_REG(ha, reg, 7),\n\t\t\t\t\t RD_MAILBOX_REG(ha, reg, 6));\n\t\thandle_cnt = 2;\n\t\tmb[0] = MBA_SCSI_COMPLETION;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\nskip_rio:\n\tswitch (mb[0]) {\n\tcase MBA_SCSI_COMPLETION:\t \n\t\tif (!vha->flags.online)\n\t\t\tbreak;\n\n\t\tfor (cnt = 0; cnt < handle_cnt; cnt++)\n\t\t\tqla2x00_process_completed_request(vha, rsp->req,\n\t\t\t\thandles[cnt]);\n\t\tbreak;\n\n\tcase MBA_RESET:\t\t\t \n\t\tql_dbg(ql_dbg_async, vha, 0x5002,\n\t\t    \"Asynchronous RESET.\\n\");\n\n\t\tset_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MBA_SYSTEM_ERR:\t\t \n\t\tmbx = 0;\n\n\t\tvha->hw_err_cnt++;\n\n\t\tif (IS_QLA81XX(ha) || IS_QLA83XX(ha) ||\n\t\t    IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tu16 m[4];\n\n\t\t\tm[0] = rd_reg_word(&reg24->mailbox4);\n\t\t\tm[1] = rd_reg_word(&reg24->mailbox5);\n\t\t\tm[2] = rd_reg_word(&reg24->mailbox6);\n\t\t\tmbx = m[3] = rd_reg_word(&reg24->mailbox7);\n\n\t\t\tql_log(ql_log_warn, vha, 0x5003,\n\t\t\t    \"ISP System Error - mbx1=%xh mbx2=%xh mbx3=%xh mbx4=%xh mbx5=%xh mbx6=%xh mbx7=%xh.\\n\",\n\t\t\t    mb[1], mb[2], mb[3], m[0], m[1], m[2], m[3]);\n\t\t} else\n\t\t\tql_log(ql_log_warn, vha, 0x5003,\n\t\t\t    \"ISP System Error - mbx1=%xh mbx2=%xh mbx3=%xh.\\n \",\n\t\t\t    mb[1], mb[2], mb[3]);\n\n\t\tif ((IS_QLA27XX(ha) || IS_QLA28XX(ha)) &&\n\t\t    rd_reg_word(&reg24->mailbox7) & BIT_8)\n\t\t\tha->isp_ops->mpi_fw_dump(vha, 1);\n\t\tha->isp_ops->fw_dump(vha);\n\t\tha->flags.fw_init_done = 0;\n\t\tQLA_FW_STOPPED(ha);\n\n\t\tif (IS_FWI2_CAPABLE(ha)) {\n\t\t\tif (mb[1] == 0 && mb[2] == 0) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x5004,\n\t\t\t\t    \"Unrecoverable Hardware Error: adapter \"\n\t\t\t\t    \"marked OFFLINE!\\n\");\n\t\t\t\tvha->flags.online = 0;\n\t\t\t\tvha->device_flags |= DFLG_DEV_FAILED;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif ((mbx & MBX_3) && (ha->port_no == 0))\n\t\t\t\t\tset_bit(MPI_RESET_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t}\n\t\t} else if (mb[1] == 0) {\n\t\t\tql_log(ql_log_fatal, vha, 0x5005,\n\t\t\t    \"Unrecoverable Hardware Error: adapter marked \"\n\t\t\t    \"OFFLINE!\\n\");\n\t\t\tvha->flags.online = 0;\n\t\t\tvha->device_flags |= DFLG_DEV_FAILED;\n\t\t} else\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MBA_REQ_TRANSFER_ERR:\t \n\t\tql_log(ql_log_warn, vha, 0x5006,\n\t\t    \"ISP Request Transfer Error (%x).\\n\",  mb[1]);\n\n\t\tvha->hw_err_cnt++;\n\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MBA_RSP_TRANSFER_ERR:\t \n\t\tql_log(ql_log_warn, vha, 0x5007,\n\t\t    \"ISP Response Transfer Error (%x).\\n\", mb[1]);\n\n\t\tvha->hw_err_cnt++;\n\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MBA_WAKEUP_THRES:\t\t \n\t\tql_dbg(ql_dbg_async, vha, 0x5008,\n\t\t    \"Asynchronous WAKEUP_THRES (%x).\\n\", mb[1]);\n\t\tbreak;\n\n\tcase MBA_LOOP_INIT_ERR:\n\t\tql_log(ql_log_warn, vha, 0x5090,\n\t\t    \"LOOP INIT ERROR (%x).\\n\", mb[1]);\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MBA_LIP_OCCURRED:\t\t \n\t\tha->flags.lip_ae = 1;\n\n\t\tql_dbg(ql_dbg_async, vha, 0x5009,\n\t\t    \"LIP occurred (%x).\\n\", mb[1]);\n\n\t\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\t\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t}\n\n\t\tif (vha->vp_idx) {\n\t\t\tatomic_set(&vha->vp_state, VP_FAILED);\n\t\t\tfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\n\t\t}\n\n\t\tset_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags);\n\t\tset_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);\n\n\t\tvha->flags.management_server_logged_in = 0;\n\t\tqla2x00_post_aen_work(vha, FCH_EVT_LIP, mb[1]);\n\t\tbreak;\n\n\tcase MBA_LOOP_UP:\t\t \n\t\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\t\tha->link_data_rate = PORT_SPEED_1GB;\n\t\telse\n\t\t\tha->link_data_rate = mb[1];\n\n\t\tql_log(ql_log_info, vha, 0x500a,\n\t\t    \"LOOP UP detected (%s Gbps).\\n\",\n\t\t    qla2x00_get_link_speed_str(ha, ha->link_data_rate));\n\n\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tif (mb[2] & BIT_0)\n\t\t\t\tql_log(ql_log_info, vha, 0x11a0,\n\t\t\t\t    \"FEC=enabled (link up).\\n\");\n\t\t}\n\n\t\tvha->flags.management_server_logged_in = 0;\n\t\tqla2x00_post_aen_work(vha, FCH_EVT_LINKUP, ha->link_data_rate);\n\n\t\tif (vha->link_down_time < vha->hw->port_down_retry_count) {\n\t\t\tvha->short_link_down_cnt++;\n\t\t\tvha->link_down_time = QLA2XX_MAX_LINK_DOWN_TIME;\n\t\t}\n\n\t\tbreak;\n\n\tcase MBA_LOOP_DOWN:\t\t \n\t\tSAVE_TOPO(ha);\n\t\tha->flags.lip_ae = 0;\n\t\tha->current_topology = 0;\n\t\tvha->link_down_time = 0;\n\n\t\tmbx = (IS_QLA81XX(ha) || IS_QLA8031(ha))\n\t\t\t? rd_reg_word(&reg24->mailbox4) : 0;\n\t\tmbx = (IS_P3P_TYPE(ha)) ? rd_reg_word(&reg82->mailbox_out[4])\n\t\t\t: mbx;\n\t\tql_log(ql_log_info, vha, 0x500b,\n\t\t    \"LOOP DOWN detected (%x %x %x %x).\\n\",\n\t\t    mb[1], mb[2], mb[3], mbx);\n\n\t\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\t\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\t\t\t \n\t\t\tif (!vha->vp_idx) {\n\t\t\t\tif (ha->flags.fawwpn_enabled &&\n\t\t\t\t    (ha->current_topology == ISP_CFG_F)) {\n\t\t\t\t\tmemcpy(vha->port_name, ha->port_name, WWN_SIZE);\n\t\t\t\t\tfc_host_port_name(vha->host) =\n\t\t\t\t\t    wwn_to_u64(vha->port_name);\n\t\t\t\t\tql_dbg(ql_dbg_init + ql_dbg_verbose,\n\t\t\t\t\t    vha, 0x00d8, \"LOOP DOWN detected,\"\n\t\t\t\t\t    \"restore WWPN %016llx\\n\",\n\t\t\t\t\t    wwn_to_u64(vha->port_name));\n\t\t\t\t}\n\n\t\t\t\tclear_bit(VP_CONFIG_OK, &vha->vp_flags);\n\t\t\t}\n\n\t\t\tvha->device_flags |= DFLG_NO_CABLE;\n\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t}\n\n\t\tif (vha->vp_idx) {\n\t\t\tatomic_set(&vha->vp_state, VP_FAILED);\n\t\t\tfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\n\t\t}\n\n\t\tvha->flags.management_server_logged_in = 0;\n\t\tha->link_data_rate = PORT_SPEED_UNKNOWN;\n\t\tqla2x00_post_aen_work(vha, FCH_EVT_LINKDOWN, 0);\n\t\tbreak;\n\n\tcase MBA_LIP_RESET:\t\t \n\t\tql_dbg(ql_dbg_async, vha, 0x500c,\n\t\t    \"LIP reset occurred (%x).\\n\", mb[1]);\n\n\t\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\t\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t}\n\n\t\tif (vha->vp_idx) {\n\t\t\tatomic_set(&vha->vp_state, VP_FAILED);\n\t\t\tfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\n\t\t}\n\n\t\tset_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\n\t\tha->operating_mode = LOOP;\n\t\tvha->flags.management_server_logged_in = 0;\n\t\tqla2x00_post_aen_work(vha, FCH_EVT_LIPRESET, mb[1]);\n\t\tbreak;\n\n\t \n\tcase MBA_POINT_TO_POINT:\t \n\t\tha->flags.lip_ae = 0;\n\n\t\tif (IS_QLA2100(ha))\n\t\t\tbreak;\n\n\t\tif (IS_CNA_CAPABLE(ha)) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x500d,\n\t\t\t    \"DCBX Completed -- %04x %04x %04x.\\n\",\n\t\t\t    mb[1], mb[2], mb[3]);\n\t\t\tif (ha->notify_dcbx_comp && !vha->vp_idx)\n\t\t\t\tcomplete(&ha->dcbx_comp);\n\n\t\t} else\n\t\t\tql_dbg(ql_dbg_async, vha, 0x500e,\n\t\t\t    \"Asynchronous P2P MODE received.\\n\");\n\n\t\t \n\t\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\t\tif (!atomic_read(&vha->loop_down_timer))\n\t\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t\t    LOOP_DOWN_TIME);\n\t\t\tif (!N2N_TOPO(ha))\n\t\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t}\n\n\t\tif (vha->vp_idx) {\n\t\t\tatomic_set(&vha->vp_state, VP_FAILED);\n\t\t\tfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\n\t\t}\n\n\t\tif (!(test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)))\n\t\t\tset_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\n\t\tset_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags);\n\t\tset_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);\n\n\t\tvha->flags.management_server_logged_in = 0;\n\t\tbreak;\n\n\tcase MBA_CHG_IN_CONNECTION:\t \n\t\tif (IS_QLA2100(ha))\n\t\t\tbreak;\n\n\t\tql_dbg(ql_dbg_async, vha, 0x500f,\n\t\t    \"Configuration change detected: value=%x.\\n\", mb[1]);\n\n\t\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\t\tif (!atomic_read(&vha->loop_down_timer))\n\t\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t\t    LOOP_DOWN_TIME);\n\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t}\n\n\t\tif (vha->vp_idx) {\n\t\t\tatomic_set(&vha->vp_state, VP_FAILED);\n\t\t\tfc_vport_set_state(vha->fc_vport, FC_VPORT_FAILED);\n\t\t}\n\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MBA_PORT_UPDATE:\t\t \n\t\t \n\t\tif (IS_QLA2XXX_MIDTYPE(ha) &&\n\t\t    ((mb[1] == 0xffff && (mb[3] & 0xff) != 0xff) ||\n\t\t\t(mb[1] != 0xffff)) && vha->vp_idx != (mb[3] & 0xff))\n\t\t\tbreak;\n\n\t\tif (mb[2] == 0x7) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5010,\n\t\t\t    \"Port %s %04x %04x %04x.\\n\",\n\t\t\t    mb[1] == 0xffff ? \"unavailable\" : \"logout\",\n\t\t\t    mb[1], mb[2], mb[3]);\n\n\t\t\tif (mb[1] == 0xffff)\n\t\t\t\tgoto global_port_update;\n\n\t\t\tif (mb[1] == NPH_SNS_LID(ha)) {\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (IS_FWI2_CAPABLE(ha))\n\t\t\t\thandle_cnt = NPH_SNS;\n\t\t\telse\n\t\t\t\thandle_cnt = SIMPLE_NAME_SERVER;\n\t\t\tif (mb[1] == handle_cnt) {\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tfcport = qla2x00_find_fcport_by_loopid(vha, mb[1]);\n\t\t\tif (!fcport)\n\t\t\t\tbreak;\n\t\t\tif (atomic_read(&fcport->state) != FCS_ONLINE)\n\t\t\t\tbreak;\n\t\t\tql_dbg(ql_dbg_async, vha, 0x508a,\n\t\t\t    \"Marking port lost loopid=%04x portid=%06x.\\n\",\n\t\t\t    fcport->loop_id, fcport->d_id.b24);\n\t\t\tif (qla_ini_mode_enabled(vha)) {\n\t\t\t\tfcport->logout_on_delete = 0;\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t}\n\t\t\tbreak;\n\nglobal_port_update:\n\t\t\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\t\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t\t    LOOP_DOWN_TIME);\n\t\t\t\tvha->device_flags |= DFLG_NO_CABLE;\n\t\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t\t}\n\n\t\t\tif (vha->vp_idx) {\n\t\t\t\tatomic_set(&vha->vp_state, VP_FAILED);\n\t\t\t\tfc_vport_set_state(vha->fc_vport,\n\t\t\t\t    FC_VPORT_FAILED);\n\t\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t\t}\n\n\t\t\tvha->flags.management_server_logged_in = 0;\n\t\t\tha->link_data_rate = PORT_SPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tatomic_set(&vha->loop_down_timer, 0);\n\t\tif (atomic_read(&vha->loop_state) != LOOP_DOWN &&\n\t\t\t!ha->flags.n2n_ae  &&\n\t\t    atomic_read(&vha->loop_state) != LOOP_DEAD) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5011,\n\t\t\t    \"Asynchronous PORT UPDATE ignored %04x/%04x/%04x.\\n\",\n\t\t\t    mb[1], mb[2], mb[3]);\n\t\t\tbreak;\n\t\t}\n\n\t\tql_dbg(ql_dbg_async, vha, 0x5012,\n\t\t    \"Port database changed %04x %04x %04x.\\n\",\n\t\t    mb[1], mb[2], mb[3]);\n\n\t\t \n\t\tatomic_set(&vha->loop_state, LOOP_UP);\n\t\tvha->scan.scan_retry = 0;\n\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\tset_bit(VP_CONFIG_OK, &vha->vp_flags);\n\t\tbreak;\n\n\tcase MBA_RSCN_UPDATE:\t\t \n\t\t \n\t\tif (vha->vp_idx && test_bit(VP_SCR_NEEDED, &vha->vp_flags))\n\t\t\tbreak;\n\t\t \n\t\tif (ha->flags.npiv_supported && vha->vp_idx != (mb[3] & 0xff))\n\t\t\tbreak;\n\n\t\tql_log(ql_log_warn, vha, 0x5013,\n\t\t       \"RSCN database changed -- %04x %04x %04x.\\n\",\n\t\t       mb[1], mb[2], mb[3]);\n\n\t\trscn_entry = ((mb[1] & 0xff) << 16) | mb[2];\n\t\thost_pid = (vha->d_id.b.domain << 16) | (vha->d_id.b.area << 8)\n\t\t\t\t| vha->d_id.b.al_pa;\n\t\tif (rscn_entry == host_pid) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5014,\n\t\t\t    \"Ignoring RSCN update to local host \"\n\t\t\t    \"port ID (%06x).\\n\", host_pid);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trscn_entry = ((mb[1] & 0x3ff) << 16) | mb[2];\n\n\t\t \n\t\tif (qla2x00_is_a_vp_did(vha, rscn_entry))\n\t\t\tbreak;\n\n\t\tatomic_set(&vha->loop_down_timer, 0);\n\t\tvha->flags.management_server_logged_in = 0;\n\t\t{\n\t\t\tstruct event_arg ea;\n\n\t\t\tmemset(&ea, 0, sizeof(ea));\n\t\t\tea.id.b24 = rscn_entry;\n\t\t\tea.id.b.rsvd_1 = rscn_entry >> 24;\n\t\t\tqla2x00_handle_rscn(vha, &ea);\n\t\t\tqla2x00_post_aen_work(vha, FCH_EVT_RSCN, rscn_entry);\n\t\t}\n\t\tbreak;\n\tcase MBA_CONGN_NOTI_RECV:\n\t\tif (!ha->flags.scm_enabled ||\n\t\t    mb[1] != QLA_CON_PRIMITIVE_RECEIVED)\n\t\t\tbreak;\n\n\t\tif (mb[2] == QLA_CONGESTION_ARB_WARNING) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x509b,\n\t\t\t       \"Congestion Warning %04x %04x.\\n\", mb[1], mb[2]);\n\t\t} else if (mb[2] == QLA_CONGESTION_ARB_ALARM) {\n\t\t\tql_log(ql_log_warn, vha, 0x509b,\n\t\t\t       \"Congestion Alarm %04x %04x.\\n\", mb[1], mb[2]);\n\t\t}\n\t\tbreak;\n\t \n\tcase MBA_ZIO_RESPONSE:\n\t\tql_dbg(ql_dbg_async, vha, 0x5015,\n\t\t    \"[R|Z]IO update completion.\\n\");\n\n\t\tif (IS_FWI2_CAPABLE(ha))\n\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\telse\n\t\t\tqla2x00_process_response_queue(rsp);\n\t\tbreak;\n\n\tcase MBA_DISCARD_RND_FRAME:\n\t\tql_dbg(ql_dbg_async, vha, 0x5016,\n\t\t    \"Discard RND Frame -- %04x %04x %04x.\\n\",\n\t\t    mb[1], mb[2], mb[3]);\n\t\tvha->interface_err_cnt++;\n\t\tbreak;\n\n\tcase MBA_TRACE_NOTIFICATION:\n\t\tql_dbg(ql_dbg_async, vha, 0x5017,\n\t\t    \"Trace Notification -- %04x %04x.\\n\", mb[1], mb[2]);\n\t\tbreak;\n\n\tcase MBA_ISP84XX_ALERT:\n\t\tql_dbg(ql_dbg_async, vha, 0x5018,\n\t\t    \"ISP84XX Alert Notification -- %04x %04x %04x.\\n\",\n\t\t    mb[1], mb[2], mb[3]);\n\n\t\tspin_lock_irqsave(&ha->cs84xx->access_lock, flags);\n\t\tswitch (mb[1]) {\n\t\tcase A84_PANIC_RECOVERY:\n\t\t\tql_log(ql_log_info, vha, 0x5019,\n\t\t\t    \"Alert 84XX: panic recovery %04x %04x.\\n\",\n\t\t\t    mb[2], mb[3]);\n\t\t\tbreak;\n\t\tcase A84_OP_LOGIN_COMPLETE:\n\t\t\tha->cs84xx->op_fw_version = mb[3] << 16 | mb[2];\n\t\t\tql_log(ql_log_info, vha, 0x501a,\n\t\t\t    \"Alert 84XX: firmware version %x.\\n\",\n\t\t\t    ha->cs84xx->op_fw_version);\n\t\t\tbreak;\n\t\tcase A84_DIAG_LOGIN_COMPLETE:\n\t\t\tha->cs84xx->diag_fw_version = mb[3] << 16 | mb[2];\n\t\t\tql_log(ql_log_info, vha, 0x501b,\n\t\t\t    \"Alert 84XX: diagnostic firmware version %x.\\n\",\n\t\t\t    ha->cs84xx->diag_fw_version);\n\t\t\tbreak;\n\t\tcase A84_GOLD_LOGIN_COMPLETE:\n\t\t\tha->cs84xx->diag_fw_version = mb[3] << 16 | mb[2];\n\t\t\tha->cs84xx->fw_update = 1;\n\t\t\tql_log(ql_log_info, vha, 0x501c,\n\t\t\t    \"Alert 84XX: gold firmware version %x.\\n\",\n\t\t\t    ha->cs84xx->gold_fw_version);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_log(ql_log_warn, vha, 0x501d,\n\t\t\t    \"Alert 84xx: Invalid Alert %04x %04x %04x.\\n\",\n\t\t\t    mb[1], mb[2], mb[3]);\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->cs84xx->access_lock, flags);\n\t\tbreak;\n\tcase MBA_DCBX_START:\n\t\tql_dbg(ql_dbg_async, vha, 0x501e,\n\t\t    \"DCBX Started -- %04x %04x %04x.\\n\",\n\t\t    mb[1], mb[2], mb[3]);\n\t\tbreak;\n\tcase MBA_DCBX_PARAM_UPDATE:\n\t\tql_dbg(ql_dbg_async, vha, 0x501f,\n\t\t    \"DCBX Parameters Updated -- %04x %04x %04x.\\n\",\n\t\t    mb[1], mb[2], mb[3]);\n\t\tbreak;\n\tcase MBA_FCF_CONF_ERR:\n\t\tql_dbg(ql_dbg_async, vha, 0x5020,\n\t\t    \"FCF Configuration Error -- %04x %04x %04x.\\n\",\n\t\t    mb[1], mb[2], mb[3]);\n\t\tbreak;\n\tcase MBA_IDC_NOTIFY:\n\t\tif (IS_QLA8031(vha->hw) || IS_QLA8044(ha)) {\n\t\t\tmb[4] = rd_reg_word(&reg24->mailbox4);\n\t\t\tif (((mb[2] & 0x7fff) == MBC_PORT_RESET ||\n\t\t\t    (mb[2] & 0x7fff) == MBC_SET_PORT_CONFIG) &&\n\t\t\t    (mb[4] & INTERNAL_LOOPBACK_MASK) != 0) {\n\t\t\t\tset_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags);\n\t\t\t\t \n\t\t\t\tif (atomic_read(&vha->loop_state) == LOOP_DOWN)\n\t\t\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t\t\t    LOOP_DOWN_TIME);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tcase MBA_IDC_COMPLETE:\n\t\tif (ha->notify_lb_portup_comp && !vha->vp_idx)\n\t\t\tcomplete(&ha->lb_portup_comp);\n\t\tfallthrough;\n\tcase MBA_IDC_TIME_EXT:\n\t\tif (IS_QLA81XX(vha->hw) || IS_QLA8031(vha->hw) ||\n\t\t    IS_QLA8044(ha))\n\t\t\tqla81xx_idc_event(vha, mb[0], mb[1]);\n\t\tbreak;\n\n\tcase MBA_IDC_AEN:\n\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tvha->hw_err_cnt++;\n\t\t\tqla27xx_handle_8200_aen(vha, mb);\n\t\t} else if (IS_QLA83XX(ha)) {\n\t\t\tmb[4] = rd_reg_word(&reg24->mailbox4);\n\t\t\tmb[5] = rd_reg_word(&reg24->mailbox5);\n\t\t\tmb[6] = rd_reg_word(&reg24->mailbox6);\n\t\t\tmb[7] = rd_reg_word(&reg24->mailbox7);\n\t\t\tqla83xx_handle_8200_aen(vha, mb);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5052,\n\t\t\t    \"skip Heartbeat processing mb0-3=[0x%04x] [0x%04x] [0x%04x] [0x%04x]\\n\",\n\t\t\t    mb[0], mb[1], mb[2], mb[3]);\n\t\t}\n\t\tbreak;\n\n\tcase MBA_DPORT_DIAGNOSTICS:\n\t\tif ((mb[1] & 0xF) == AEN_DONE_DIAG_TEST_WITH_NOERR ||\n\t\t    (mb[1] & 0xF) == AEN_DONE_DIAG_TEST_WITH_ERR)\n\t\t\tvha->dport_status &= ~DPORT_DIAG_IN_PROGRESS;\n\t\tql_dbg(ql_dbg_async, vha, 0x5052,\n\t\t    \"D-Port Diagnostics: %04x %04x %04x %04x\\n\",\n\t\t    mb[0], mb[1], mb[2], mb[3]);\n\t\tmemcpy(vha->dport_data, mb, sizeof(vha->dport_data));\n\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tstatic char *results[] = {\n\t\t\t    \"start\", \"done(pass)\", \"done(error)\", \"undefined\" };\n\t\t\tstatic char *types[] = {\n\t\t\t    \"none\", \"dynamic\", \"static\", \"other\" };\n\t\t\tuint result = mb[1] >> 0 & 0x3;\n\t\t\tuint type = mb[1] >> 6 & 0x3;\n\t\t\tuint sw = mb[1] >> 15 & 0x1;\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5052,\n\t\t\t    \"D-Port Diagnostics: result=%s type=%s [sw=%u]\\n\",\n\t\t\t    results[result], types[type], sw);\n\t\t\tif (result == 2) {\n\t\t\t\tstatic char *reasons[] = {\n\t\t\t\t    \"reserved\", \"unexpected reject\",\n\t\t\t\t    \"unexpected phase\", \"retry exceeded\",\n\t\t\t\t    \"timed out\", \"not supported\",\n\t\t\t\t    \"user stopped\" };\n\t\t\t\tuint reason = mb[2] >> 0 & 0xf;\n\t\t\t\tuint phase = mb[2] >> 12 & 0xf;\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x5052,\n\t\t\t\t    \"D-Port Diagnostics: reason=%s phase=%u \\n\",\n\t\t\t\t    reason < 7 ? reasons[reason] : \"other\",\n\t\t\t\t    phase >> 1);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MBA_TEMPERATURE_ALERT:\n\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\tdisplay_Laser_info(vha, mb[1], mb[2], mb[3]);\n\t\tql_dbg(ql_dbg_async, vha, 0x505e,\n\t\t    \"TEMPERATURE ALERT: %04x %04x %04x\\n\", mb[1], mb[2], mb[3]);\n\t\tbreak;\n\n\tcase MBA_TRANS_INSERT:\n\t\tql_dbg(ql_dbg_async, vha, 0x5091,\n\t\t    \"Transceiver Insertion: %04x\\n\", mb[1]);\n\t\tset_bit(DETECT_SFP_CHANGE, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MBA_TRANS_REMOVE:\n\t\tql_dbg(ql_dbg_async, vha, 0x5091, \"Transceiver Removal\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tql_dbg(ql_dbg_async, vha, 0x5057,\n\t\t    \"Unknown AEN:%04x %04x %04x %04x\\n\",\n\t\t    mb[0], mb[1], mb[2], mb[3]);\n\t}\n\n\tqlt_async_event(mb[0], vha, mb);\n\n\tif (!vha->vp_idx && ha->num_vhosts)\n\t\tqla2x00_alert_all_vps(rsp, mb);\n}\n\n \nvoid\nqla2x00_process_completed_request(struct scsi_qla_host *vha,\n\t\t\t\t  struct req_que *req, uint32_t index)\n{\n\tsrb_t *sp;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (index >= req->num_outstanding_cmds) {\n\t\tql_log(ql_log_warn, vha, 0x3014,\n\t\t    \"Invalid SCSI command index (%x).\\n\", index);\n\n\t\tif (IS_P3P_TYPE(ha))\n\t\t\tset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\n\t\telse\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t}\n\n\tsp = req->outstanding_cmds[index];\n\tif (sp) {\n\t\t \n\t\treq->outstanding_cmds[index] = NULL;\n\n\t\t \n\t\tsp->done(sp, DID_OK << 16);\n\t} else {\n\t\tql_log(ql_log_warn, vha, 0x3016, \"Invalid SCSI SRB.\\n\");\n\n\t\tif (IS_P3P_TYPE(ha))\n\t\t\tset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\n\t\telse\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t}\n}\n\nstatic srb_t *\nqla_get_sp_from_handle(scsi_qla_host_t *vha, const char *func,\n\t\t       struct req_que *req, void *iocb, u16 *ret_index)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tsts_entry_t *pkt = iocb;\n\tsrb_t *sp;\n\tuint16_t index;\n\n\tif (pkt->handle == QLA_SKIP_HANDLE)\n\t\treturn NULL;\n\n\tindex = LSW(pkt->handle);\n\tif (index >= req->num_outstanding_cmds) {\n\t\tql_log(ql_log_warn, vha, 0x5031,\n\t\t\t   \"%s: Invalid command index (%x) type %8ph.\\n\",\n\t\t\t   func, index, iocb);\n\t\tif (IS_P3P_TYPE(ha))\n\t\t\tset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\n\t\telse\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\treturn NULL;\n\t}\n\tsp = req->outstanding_cmds[index];\n\tif (!sp) {\n\t\tql_log(ql_log_warn, vha, 0x5032,\n\t\t\t\"%s: Invalid completion handle (%x) -- timed-out.\\n\",\n\t\t\tfunc, index);\n\t\treturn NULL;\n\t}\n\tif (sp->handle != index) {\n\t\tql_log(ql_log_warn, vha, 0x5033,\n\t\t\t\"%s: SRB handle (%x) mismatch %x.\\n\", func,\n\t\t\tsp->handle, index);\n\t\treturn NULL;\n\t}\n\n\t*ret_index = index;\n\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\treturn sp;\n}\n\nsrb_t *\nqla2x00_get_sp_from_handle(scsi_qla_host_t *vha, const char *func,\n\t\t\t   struct req_que *req, void *iocb)\n{\n\tuint16_t index;\n\tsrb_t *sp;\n\n\tsp = qla_get_sp_from_handle(vha, func, req, iocb, &index);\n\tif (sp)\n\t\treq->outstanding_cmds[index] = NULL;\n\n\treturn sp;\n}\n\nstatic void\nqla2x00_mbx_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\n    struct mbx_entry *mbx)\n{\n\tconst char func[] = \"MBX-IOCB\";\n\tconst char *type;\n\tfc_port_t *fcport;\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tuint16_t *data;\n\tuint16_t status;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, mbx);\n\tif (!sp)\n\t\treturn;\n\n\tlio = &sp->u.iocb_cmd;\n\ttype = sp->name;\n\tfcport = sp->fcport;\n\tdata = lio->u.logio.data;\n\n\tdata[0] = MBS_COMMAND_ERROR;\n\tdata[1] = lio->u.logio.flags & SRB_LOGIN_RETRIED ?\n\t    QLA_LOGIO_LOGIN_RETRIED : 0;\n\tif (mbx->entry_status) {\n\t\tql_dbg(ql_dbg_async, vha, 0x5043,\n\t\t    \"Async-%s error entry - hdl=%x portid=%02x%02x%02x \"\n\t\t    \"entry-status=%x status=%x state-flag=%x \"\n\t\t    \"status-flags=%x.\\n\", type, sp->handle,\n\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t    fcport->d_id.b.al_pa, mbx->entry_status,\n\t\t    le16_to_cpu(mbx->status), le16_to_cpu(mbx->state_flags),\n\t\t    le16_to_cpu(mbx->status_flags));\n\n\t\tql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5029,\n\t\t    mbx, sizeof(*mbx));\n\n\t\tgoto logio_done;\n\t}\n\n\tstatus = le16_to_cpu(mbx->status);\n\tif (status == 0x30 && sp->type == SRB_LOGIN_CMD &&\n\t    le16_to_cpu(mbx->mb0) == MBS_COMMAND_COMPLETE)\n\t\tstatus = 0;\n\tif (!status && le16_to_cpu(mbx->mb0) == MBS_COMMAND_COMPLETE) {\n\t\tql_dbg(ql_dbg_async, vha, 0x5045,\n\t\t    \"Async-%s complete - hdl=%x portid=%02x%02x%02x mbx1=%x.\\n\",\n\t\t    type, sp->handle, fcport->d_id.b.domain,\n\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t\t    le16_to_cpu(mbx->mb1));\n\n\t\tdata[0] = MBS_COMMAND_COMPLETE;\n\t\tif (sp->type == SRB_LOGIN_CMD) {\n\t\t\tfcport->port_type = FCT_TARGET;\n\t\t\tif (le16_to_cpu(mbx->mb1) & BIT_0)\n\t\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\t\telse if (le16_to_cpu(mbx->mb1) & BIT_1)\n\t\t\t\tfcport->flags |= FCF_FCP2_DEVICE;\n\t\t}\n\t\tgoto logio_done;\n\t}\n\n\tdata[0] = le16_to_cpu(mbx->mb0);\n\tswitch (data[0]) {\n\tcase MBS_PORT_ID_USED:\n\t\tdata[1] = le16_to_cpu(mbx->mb1);\n\t\tbreak;\n\tcase MBS_LOOP_ID_USED:\n\t\tbreak;\n\tdefault:\n\t\tdata[0] = MBS_COMMAND_ERROR;\n\t\tbreak;\n\t}\n\n\tql_log(ql_log_warn, vha, 0x5046,\n\t    \"Async-%s failed - hdl=%x portid=%02x%02x%02x status=%x \"\n\t    \"mb0=%x mb1=%x mb2=%x mb6=%x mb7=%x.\\n\", type, sp->handle,\n\t    fcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t    status, le16_to_cpu(mbx->mb0), le16_to_cpu(mbx->mb1),\n\t    le16_to_cpu(mbx->mb2), le16_to_cpu(mbx->mb6),\n\t    le16_to_cpu(mbx->mb7));\n\nlogio_done:\n\tsp->done(sp, 0);\n}\n\nstatic void\nqla24xx_mbx_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\n    struct mbx_24xx_entry *pkt)\n{\n\tconst char func[] = \"MBX-IOCB2\";\n\tstruct qla_hw_data *ha = vha->hw;\n\tsrb_t *sp;\n\tstruct srb_iocb *si;\n\tu16 sz, i;\n\tint res;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\n\tif (sp->type == SRB_SCSI_CMD ||\n\t    sp->type == SRB_NVME_CMD ||\n\t    sp->type == SRB_TM_CMD) {\n\t\tql_log(ql_log_warn, vha, 0x509d,\n\t\t\t\"Inconsistent event entry type %d\\n\", sp->type);\n\t\tif (IS_P3P_TYPE(ha))\n\t\t\tset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\n\t\telse\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t}\n\n\tsi = &sp->u.iocb_cmd;\n\tsz = min(ARRAY_SIZE(pkt->mb), ARRAY_SIZE(sp->u.iocb_cmd.u.mbx.in_mb));\n\n\tfor (i = 0; i < sz; i++)\n\t\tsi->u.mbx.in_mb[i] = pkt->mb[i];\n\n\tres = (si->u.mbx.in_mb[0] & MBS_MASK);\n\n\tsp->done(sp, res);\n}\n\nstatic void\nqla24xxx_nack_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\n    struct nack_to_isp *pkt)\n{\n\tconst char func[] = \"nack\";\n\tsrb_t *sp;\n\tint res = 0;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\n\tif (pkt->u.isp2x.status != cpu_to_le16(NOTIFY_ACK_SUCCESS))\n\t\tres = QLA_FUNCTION_FAILED;\n\n\tsp->done(sp, res);\n}\n\nstatic void\nqla2x00_ct_entry(scsi_qla_host_t *vha, struct req_que *req,\n    sts_entry_t *pkt, int iocb_type)\n{\n\tconst char func[] = \"CT_IOCB\";\n\tconst char *type;\n\tsrb_t *sp;\n\tstruct bsg_job *bsg_job;\n\tstruct fc_bsg_reply *bsg_reply;\n\tuint16_t comp_status;\n\tint res = 0;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\n\tswitch (sp->type) {\n\tcase SRB_CT_CMD:\n\t    bsg_job = sp->u.bsg_job;\n\t    bsg_reply = bsg_job->reply;\n\n\t    type = \"ct pass-through\";\n\n\t    comp_status = le16_to_cpu(pkt->comp_status);\n\n\t     \n\t    bsg_reply->reply_data.ctels_reply.status = FC_CTELS_STATUS_OK;\n\t    bsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\n\t    if (comp_status != CS_COMPLETE) {\n\t\t    if (comp_status == CS_DATA_UNDERRUN) {\n\t\t\t    res = DID_OK << 16;\n\t\t\t    bsg_reply->reply_payload_rcv_len =\n\t\t\t\tle16_to_cpu(pkt->rsp_info_len);\n\n\t\t\t    ql_log(ql_log_warn, vha, 0x5048,\n\t\t\t\t\"CT pass-through-%s error comp_status=0x%x total_byte=0x%x.\\n\",\n\t\t\t\ttype, comp_status,\n\t\t\t\tbsg_reply->reply_payload_rcv_len);\n\t\t    } else {\n\t\t\t    ql_log(ql_log_warn, vha, 0x5049,\n\t\t\t\t\"CT pass-through-%s error comp_status=0x%x.\\n\",\n\t\t\t\ttype, comp_status);\n\t\t\t    res = DID_ERROR << 16;\n\t\t\t    bsg_reply->reply_payload_rcv_len = 0;\n\t\t    }\n\t\t    ql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x5035,\n\t\t\tpkt, sizeof(*pkt));\n\t    } else {\n\t\t    res = DID_OK << 16;\n\t\t    bsg_reply->reply_payload_rcv_len =\n\t\t\tbsg_job->reply_payload.payload_len;\n\t\t    bsg_job->reply_len = 0;\n\t    }\n\t    break;\n\tcase SRB_CT_PTHRU_CMD:\n\t     \n\t     res = qla2x00_chk_ms_status(vha, (ms_iocb_entry_t *)pkt,\n\t\t (struct ct_sns_rsp *)sp->u.iocb_cmd.u.ctarg.rsp,\n\t\t sp->name);\n\t     break;\n\t}\n\n\tsp->done(sp, res);\n}\n\nstatic void\nqla24xx_els_ct_entry(scsi_qla_host_t *v, struct req_que *req,\n    struct sts_entry_24xx *pkt, int iocb_type)\n{\n\tstruct els_sts_entry_24xx *ese = (struct els_sts_entry_24xx *)pkt;\n\tconst char func[] = \"ELS_CT_IOCB\";\n\tconst char *type;\n\tsrb_t *sp;\n\tstruct bsg_job *bsg_job;\n\tstruct fc_bsg_reply *bsg_reply;\n\tuint16_t comp_status;\n\tuint32_t fw_status[3];\n\tint res, logit = 1;\n\tstruct srb_iocb *els;\n\tuint n;\n\tscsi_qla_host_t *vha;\n\tstruct els_sts_entry_24xx *e = (struct els_sts_entry_24xx *)pkt;\n\n\tsp = qla2x00_get_sp_from_handle(v, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\tbsg_job = sp->u.bsg_job;\n\tvha = sp->vha;\n\n\ttype = NULL;\n\n\tcomp_status = fw_status[0] = le16_to_cpu(pkt->comp_status);\n\tfw_status[1] = le32_to_cpu(((struct els_sts_entry_24xx *)pkt)->error_subcode_1);\n\tfw_status[2] = le32_to_cpu(((struct els_sts_entry_24xx *)pkt)->error_subcode_2);\n\n\tswitch (sp->type) {\n\tcase SRB_ELS_CMD_RPT:\n\tcase SRB_ELS_CMD_HST:\n\t\ttype = \"rpt hst\";\n\t\tbreak;\n\tcase SRB_ELS_CMD_HST_NOLOGIN:\n\t\ttype = \"els\";\n\t\t{\n\t\t\tstruct els_entry_24xx *els = (void *)pkt;\n\t\t\tstruct qla_bsg_auth_els_request *p =\n\t\t\t\t(struct qla_bsg_auth_els_request *)bsg_job->request;\n\n\t\t\tql_dbg(ql_dbg_user, vha, 0x700f,\n\t\t\t     \"%s %s. portid=%02x%02x%02x status %x xchg %x bsg ptr %p\\n\",\n\t\t\t     __func__, sc_to_str(p->e.sub_cmd),\n\t\t\t     e->d_id[2], e->d_id[1], e->d_id[0],\n\t\t\t     comp_status, p->e.extra_rx_xchg_address, bsg_job);\n\n\t\t\tif (!(le16_to_cpu(els->control_flags) & ECF_PAYLOAD_DESCR_MASK)) {\n\t\t\t\tif (sp->remap.remapped) {\n\t\t\t\t\tn = sg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t\tbsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t\tsp->remap.rsp.buf,\n\t\t\t\t\t\tsp->remap.rsp.len);\n\t\t\t\t\tql_dbg(ql_dbg_user + ql_dbg_verbose, vha, 0x700e,\n\t\t\t\t\t   \"%s: SG copied %x of %x\\n\",\n\t\t\t\t\t   __func__, n, sp->remap.rsp.len);\n\t\t\t\t} else {\n\t\t\t\t\tql_dbg(ql_dbg_user, vha, 0x700f,\n\t\t\t\t\t   \"%s: NOT REMAPPED (error)...!!!\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SRB_CT_CMD:\n\t\ttype = \"ct pass-through\";\n\t\tbreak;\n\tcase SRB_ELS_DCMD:\n\t\ttype = \"Driver ELS logo\";\n\t\tif (iocb_type != ELS_IOCB_TYPE) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x5047,\n\t\t\t    \"Completing %s: (%p) type=%d.\\n\",\n\t\t\t    type, sp, sp->type);\n\t\t\tsp->done(sp, 0);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase SRB_CT_PTHRU_CMD:\n\t\t \n\t\tres = qla2x00_chk_ms_status(sp->vha, (ms_iocb_entry_t *)pkt,\n\t\t\t(struct ct_sns_rsp *)sp->u.iocb_cmd.u.ctarg.rsp,\n\t\t\tsp->name);\n\t\tsp->done(sp, res);\n\t\treturn;\n\tdefault:\n\t\tql_dbg(ql_dbg_user, vha, 0x503e,\n\t\t    \"Unrecognized SRB: (%p) type=%d.\\n\", sp, sp->type);\n\t\treturn;\n\t}\n\n\tif (iocb_type == ELS_IOCB_TYPE) {\n\t\tels = &sp->u.iocb_cmd;\n\t\tels->u.els_plogi.fw_status[0] = cpu_to_le32(fw_status[0]);\n\t\tels->u.els_plogi.fw_status[1] = cpu_to_le32(fw_status[1]);\n\t\tels->u.els_plogi.fw_status[2] = cpu_to_le32(fw_status[2]);\n\t\tels->u.els_plogi.comp_status = cpu_to_le16(fw_status[0]);\n\t\tif (comp_status == CS_COMPLETE) {\n\t\t\tres =  DID_OK << 16;\n\t\t} else {\n\t\t\tif (comp_status == CS_DATA_UNDERRUN) {\n\t\t\t\tres =  DID_OK << 16;\n\t\t\t\tels->u.els_plogi.len = cpu_to_le16(le32_to_cpu(\n\t\t\t\t\tese->total_byte_count));\n\n\t\t\t\tif (sp->remap.remapped &&\n\t\t\t\t    ((u8 *)sp->remap.rsp.buf)[0] == ELS_LS_ACC) {\n\t\t\t\t\tql_dbg(ql_dbg_user, vha, 0x503f,\n\t\t\t\t\t    \"%s IOCB Done LS_ACC %02x%02x%02x -> %02x%02x%02x\",\n\t\t\t\t\t    __func__, e->s_id[0], e->s_id[2], e->s_id[1],\n\t\t\t\t\t    e->d_id[2], e->d_id[1], e->d_id[0]);\n\t\t\t\t\tlogit = 0;\n\t\t\t\t}\n\n\t\t\t} else if (comp_status == CS_PORT_LOGGED_OUT) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x911e,\n\t\t\t\t       \"%s %d schedule session deletion\\n\",\n\t\t\t\t       __func__, __LINE__);\n\n\t\t\t\tels->u.els_plogi.len = 0;\n\t\t\t\tres = DID_IMM_RETRY << 16;\n\t\t\t\tqlt_schedule_sess_for_deletion(sp->fcport);\n\t\t\t} else {\n\t\t\t\tels->u.els_plogi.len = 0;\n\t\t\t\tres = DID_ERROR << 16;\n\t\t\t}\n\n\t\t\tif (sp->remap.remapped &&\n\t\t\t    ((u8 *)sp->remap.rsp.buf)[0] == ELS_LS_RJT) {\n\t\t\t\tif (logit) {\n\t\t\t\t\tql_dbg(ql_dbg_user, vha, 0x503f,\n\t\t\t\t\t    \"%s IOCB Done LS_RJT hdl=%x comp_status=0x%x\\n\",\n\t\t\t\t\t    type, sp->handle, comp_status);\n\n\t\t\t\t\tql_dbg(ql_dbg_user, vha, 0x503f,\n\t\t\t\t\t    \"subcode 1=0x%x subcode 2=0x%x bytes=0x%x %02x%02x%02x -> %02x%02x%02x\\n\",\n\t\t\t\t\t    fw_status[1], fw_status[2],\n\t\t\t\t\t    le32_to_cpu(((struct els_sts_entry_24xx *)\n\t\t\t\t\t\tpkt)->total_byte_count),\n\t\t\t\t\t    e->s_id[0], e->s_id[2], e->s_id[1],\n\t\t\t\t\t    e->d_id[2], e->d_id[1], e->d_id[0]);\n\t\t\t\t}\n\t\t\t\tif (sp->fcport && sp->fcport->flags & FCF_FCSP_DEVICE &&\n\t\t\t\t    sp->type == SRB_ELS_CMD_HST_NOLOGIN) {\n\t\t\t\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t\t\t\t    \"%s rcv reject. Sched delete\\n\", __func__);\n\t\t\t\t\tqlt_schedule_sess_for_deletion(sp->fcport);\n\t\t\t\t}\n\t\t\t} else if (logit) {\n\t\t\t\tql_log(ql_log_info, vha, 0x503f,\n\t\t\t\t    \"%s IOCB Done hdl=%x comp_status=0x%x\\n\",\n\t\t\t\t    type, sp->handle, comp_status);\n\t\t\t\tql_log(ql_log_info, vha, 0x503f,\n\t\t\t\t    \"subcode 1=0x%x subcode 2=0x%x bytes=0x%x %02x%02x%02x -> %02x%02x%02x\\n\",\n\t\t\t\t    fw_status[1], fw_status[2],\n\t\t\t\t    le32_to_cpu(((struct els_sts_entry_24xx *)\n\t\t\t\t    pkt)->total_byte_count),\n\t\t\t\t    e->s_id[0], e->s_id[2], e->s_id[1],\n\t\t\t\t    e->d_id[2], e->d_id[1], e->d_id[0]);\n\t\t\t}\n\t\t}\n\t\tgoto els_ct_done;\n\t}\n\n\t \n\tbsg_job = sp->u.bsg_job;\n\tbsg_reply = bsg_job->reply;\n\tbsg_reply->reply_data.ctels_reply.status = FC_CTELS_STATUS_OK;\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply) + sizeof(fw_status);\n\n\tif (comp_status != CS_COMPLETE) {\n\t\tif (comp_status == CS_DATA_UNDERRUN) {\n\t\t\tres = DID_OK << 16;\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tle32_to_cpu(ese->total_byte_count);\n\n\t\t\tql_dbg(ql_dbg_user, vha, 0x503f,\n\t\t\t    \"ELS-CT pass-through-%s error hdl=%x comp_status-status=0x%x \"\n\t\t\t    \"error subcode 1=0x%x error subcode 2=0x%x total_byte = 0x%x.\\n\",\n\t\t\t    type, sp->handle, comp_status, fw_status[1], fw_status[2],\n\t\t\t    le32_to_cpu(ese->total_byte_count));\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x5040,\n\t\t\t    \"ELS-CT pass-through-%s error hdl=%x comp_status-status=0x%x \"\n\t\t\t    \"error subcode 1=0x%x error subcode 2=0x%x.\\n\",\n\t\t\t    type, sp->handle, comp_status,\n\t\t\t    le32_to_cpu(ese->error_subcode_1),\n\t\t\t    le32_to_cpu(ese->error_subcode_2));\n\t\t\tres = DID_ERROR << 16;\n\t\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t\t}\n\t\tmemcpy(bsg_job->reply + sizeof(struct fc_bsg_reply),\n\t\t       fw_status, sizeof(fw_status));\n\t\tql_dump_buffer(ql_dbg_user + ql_dbg_buffer, vha, 0x5056,\n\t\t    pkt, sizeof(*pkt));\n\t}\n\telse {\n\t\tres =  DID_OK << 16;\n\t\tbsg_reply->reply_payload_rcv_len = bsg_job->reply_payload.payload_len;\n\t\tbsg_job->reply_len = 0;\n\t}\nels_ct_done:\n\n\tsp->done(sp, res);\n}\n\nstatic void\nqla24xx_logio_entry(scsi_qla_host_t *vha, struct req_que *req,\n    struct logio_entry_24xx *logio)\n{\n\tconst char func[] = \"LOGIO-IOCB\";\n\tconst char *type;\n\tfc_port_t *fcport;\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tuint16_t *data;\n\tuint32_t iop[2];\n\tint logit = 1;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, logio);\n\tif (!sp)\n\t\treturn;\n\n\tlio = &sp->u.iocb_cmd;\n\ttype = sp->name;\n\tfcport = sp->fcport;\n\tdata = lio->u.logio.data;\n\n\tdata[0] = MBS_COMMAND_ERROR;\n\tdata[1] = lio->u.logio.flags & SRB_LOGIN_RETRIED ?\n\t\tQLA_LOGIO_LOGIN_RETRIED : 0;\n\tif (logio->entry_status) {\n\t\tql_log(ql_log_warn, fcport->vha, 0x5034,\n\t\t    \"Async-%s error entry - %8phC hdl=%x\"\n\t\t    \"portid=%02x%02x%02x entry-status=%x.\\n\",\n\t\t    type, fcport->port_name, sp->handle, fcport->d_id.b.domain,\n\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t\t    logio->entry_status);\n\t\tql_dump_buffer(ql_dbg_async + ql_dbg_buffer, vha, 0x504d,\n\t\t    logio, sizeof(*logio));\n\n\t\tgoto logio_done;\n\t}\n\n\tif (le16_to_cpu(logio->comp_status) == CS_COMPLETE) {\n\t\tql_dbg(ql_dbg_async, sp->vha, 0x5036,\n\t\t    \"Async-%s complete: handle=%x pid=%06x wwpn=%8phC iop0=%x\\n\",\n\t\t    type, sp->handle, fcport->d_id.b24, fcport->port_name,\n\t\t    le32_to_cpu(logio->io_parameter[0]));\n\n\t\tvha->hw->exch_starvation = 0;\n\t\tdata[0] = MBS_COMMAND_COMPLETE;\n\n\t\tif (sp->type == SRB_PRLI_CMD) {\n\t\t\tlio->u.logio.iop[0] =\n\t\t\t    le32_to_cpu(logio->io_parameter[0]);\n\t\t\tlio->u.logio.iop[1] =\n\t\t\t    le32_to_cpu(logio->io_parameter[1]);\n\t\t\tgoto logio_done;\n\t\t}\n\n\t\tif (sp->type != SRB_LOGIN_CMD)\n\t\t\tgoto logio_done;\n\n\t\tlio->u.logio.iop[1] = le32_to_cpu(logio->io_parameter[5]);\n\t\tif (le32_to_cpu(logio->io_parameter[5]) & LIO_COMM_FEAT_FCSP)\n\t\t\tfcport->flags |= FCF_FCSP_DEVICE;\n\n\t\tiop[0] = le32_to_cpu(logio->io_parameter[0]);\n\t\tif (iop[0] & BIT_4) {\n\t\t\tfcport->port_type = FCT_TARGET;\n\t\t\tif (iop[0] & BIT_8)\n\t\t\t\tfcport->flags |= FCF_FCP2_DEVICE;\n\t\t} else if (iop[0] & BIT_5)\n\t\t\tfcport->port_type = FCT_INITIATOR;\n\n\t\tif (iop[0] & BIT_7)\n\t\t\tfcport->flags |= FCF_CONF_COMP_SUPPORTED;\n\n\t\tif (logio->io_parameter[7] || logio->io_parameter[8])\n\t\t\tfcport->supported_classes |= FC_COS_CLASS2;\n\t\tif (logio->io_parameter[9] || logio->io_parameter[10])\n\t\t\tfcport->supported_classes |= FC_COS_CLASS3;\n\n\t\tgoto logio_done;\n\t}\n\n\tiop[0] = le32_to_cpu(logio->io_parameter[0]);\n\tiop[1] = le32_to_cpu(logio->io_parameter[1]);\n\tlio->u.logio.iop[0] = iop[0];\n\tlio->u.logio.iop[1] = iop[1];\n\tswitch (iop[0]) {\n\tcase LSC_SCODE_PORTID_USED:\n\t\tdata[0] = MBS_PORT_ID_USED;\n\t\tdata[1] = LSW(iop[1]);\n\t\tlogit = 0;\n\t\tbreak;\n\tcase LSC_SCODE_NPORT_USED:\n\t\tdata[0] = MBS_LOOP_ID_USED;\n\t\tlogit = 0;\n\t\tbreak;\n\tcase LSC_SCODE_CMD_FAILED:\n\t\tif (iop[1] == 0x0606) {\n\t\t\t \n\t\t\tdata[0] = MBS_COMMAND_COMPLETE;\n\t\t\tgoto logio_done;\n\t\t}\n\t\tdata[0] = MBS_COMMAND_ERROR;\n\t\tbreak;\n\tcase LSC_SCODE_NOXCB:\n\t\tvha->hw->exch_starvation++;\n\t\tif (vha->hw->exch_starvation > 5) {\n\t\t\tql_log(ql_log_warn, vha, 0xd046,\n\t\t\t    \"Exchange starvation. Resetting RISC\\n\");\n\n\t\t\tvha->hw->exch_starvation = 0;\n\n\t\t\tif (IS_P3P_TYPE(vha->hw))\n\t\t\t\tset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\n\t\t\telse\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdata[0] = MBS_COMMAND_ERROR;\n\t\tbreak;\n\t}\n\n\tif (logit)\n\t\tql_log(ql_log_warn, sp->vha, 0x5037, \"Async-%s failed: \"\n\t\t       \"handle=%x pid=%06x wwpn=%8phC comp_status=%x iop0=%x iop1=%x\\n\",\n\t\t       type, sp->handle, fcport->d_id.b24, fcport->port_name,\n\t\t       le16_to_cpu(logio->comp_status),\n\t\t       le32_to_cpu(logio->io_parameter[0]),\n\t\t       le32_to_cpu(logio->io_parameter[1]));\n\telse\n\t\tql_dbg(ql_dbg_disc, sp->vha, 0x5037, \"Async-%s failed: \"\n\t\t       \"handle=%x pid=%06x wwpn=%8phC comp_status=%x iop0=%x iop1=%x\\n\",\n\t\t       type, sp->handle, fcport->d_id.b24, fcport->port_name,\n\t\t       le16_to_cpu(logio->comp_status),\n\t\t       le32_to_cpu(logio->io_parameter[0]),\n\t\t       le32_to_cpu(logio->io_parameter[1]));\n\nlogio_done:\n\tsp->done(sp, 0);\n}\n\nstatic void\nqla24xx_tm_iocb_entry(scsi_qla_host_t *vha, struct req_que *req, void *tsk)\n{\n\tconst char func[] = \"TMF-IOCB\";\n\tconst char *type;\n\tfc_port_t *fcport;\n\tsrb_t *sp;\n\tstruct srb_iocb *iocb;\n\tstruct sts_entry_24xx *sts = (struct sts_entry_24xx *)tsk;\n\tu16 comp_status;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, tsk);\n\tif (!sp)\n\t\treturn;\n\n\tcomp_status = le16_to_cpu(sts->comp_status);\n\tiocb = &sp->u.iocb_cmd;\n\ttype = sp->name;\n\tfcport = sp->fcport;\n\tiocb->u.tmf.data = QLA_SUCCESS;\n\n\tif (sts->entry_status) {\n\t\tql_log(ql_log_warn, fcport->vha, 0x5038,\n\t\t    \"Async-%s error - hdl=%x entry-status(%x).\\n\",\n\t\t    type, sp->handle, sts->entry_status);\n\t\tiocb->u.tmf.data = QLA_FUNCTION_FAILED;\n\t} else if (sts->comp_status != cpu_to_le16(CS_COMPLETE)) {\n\t\tql_log(ql_log_warn, fcport->vha, 0x5039,\n\t\t    \"Async-%s error - hdl=%x completion status(%x).\\n\",\n\t\t    type, sp->handle, comp_status);\n\t\tiocb->u.tmf.data = QLA_FUNCTION_FAILED;\n\t} else if ((le16_to_cpu(sts->scsi_status) &\n\t    SS_RESPONSE_INFO_LEN_VALID)) {\n\t\thost_to_fcp_swap(sts->data, sizeof(sts->data));\n\t\tif (le32_to_cpu(sts->rsp_data_len) < 4) {\n\t\t\tql_log(ql_log_warn, fcport->vha, 0x503b,\n\t\t\t    \"Async-%s error - hdl=%x not enough response(%d).\\n\",\n\t\t\t    type, sp->handle, sts->rsp_data_len);\n\t\t} else if (sts->data[3]) {\n\t\t\tql_log(ql_log_warn, fcport->vha, 0x503c,\n\t\t\t    \"Async-%s error - hdl=%x response(%x).\\n\",\n\t\t\t    type, sp->handle, sts->data[3]);\n\t\t\tiocb->u.tmf.data = QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\n\tswitch (comp_status) {\n\tcase CS_PORT_LOGGED_OUT:\n\tcase CS_PORT_CONFIG_CHG:\n\tcase CS_PORT_BUSY:\n\tcase CS_INCOMPLETE:\n\tcase CS_PORT_UNAVAILABLE:\n\tcase CS_RESET:\n\t\tif (atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x3021,\n\t\t\t       \"-Port to be marked lost on fcport=%02x%02x%02x, current port state= %s comp_status %x.\\n\",\n\t\t\t       fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t\t       fcport->d_id.b.al_pa,\n\t\t\t       port_state_str[FCS_ONLINE],\n\t\t\t       comp_status);\n\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (iocb->u.tmf.data != QLA_SUCCESS)\n\t\tql_dump_buffer(ql_dbg_async + ql_dbg_buffer, sp->vha, 0x5055,\n\t\t    sts, sizeof(*sts));\n\n\tsp->done(sp, 0);\n}\n\nstatic void qla24xx_nvme_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\n    void *tsk, srb_t *sp)\n{\n\tfc_port_t *fcport;\n\tstruct srb_iocb *iocb;\n\tstruct sts_entry_24xx *sts = (struct sts_entry_24xx *)tsk;\n\tuint16_t        state_flags;\n\tstruct nvmefc_fcp_req *fd;\n\tuint16_t        ret = QLA_SUCCESS;\n\t__le16\t\tcomp_status = sts->comp_status;\n\tint\t\tlogit = 0;\n\n\tiocb = &sp->u.iocb_cmd;\n\tfcport = sp->fcport;\n\tiocb->u.nvme.comp_status = comp_status;\n\tstate_flags  = le16_to_cpu(sts->state_flags);\n\tfd = iocb->u.nvme.desc;\n\n\tif (unlikely(iocb->u.nvme.aen_op))\n\t\tatomic_dec(&sp->vha->hw->nvme_active_aen_cnt);\n\telse\n\t\tsp->qpair->cmd_completion_cnt++;\n\n\tif (unlikely(comp_status != CS_COMPLETE))\n\t\tlogit = 1;\n\n\tfd->transferred_length = fd->payload_length -\n\t    le32_to_cpu(sts->residual_len);\n\n\t \n\tif (!(state_flags & (SF_FCP_RSP_DMA | SF_NVME_ERSP))) {\n\t\tiocb->u.nvme.rsp_pyld_len = 0;\n\t} else if ((state_flags & (SF_FCP_RSP_DMA | SF_NVME_ERSP)) ==\n\t\t\t(SF_FCP_RSP_DMA | SF_NVME_ERSP)) {\n\t\t \n\t\tiocb->u.nvme.rsp_pyld_len = sts->nvme_rsp_pyld_len;\n\t} else if ((state_flags & SF_FCP_RSP_DMA)) {\n\t\t \n\t\tiocb->u.nvme.rsp_pyld_len = 0;\n\t\tfd->transferred_length = 0;\n\t\tql_dbg(ql_dbg_io, fcport->vha, 0x307a,\n\t\t\t\"Unexpected values in NVMe_RSP IU.\\n\");\n\t\tlogit = 1;\n\t} else if (state_flags & SF_NVME_ERSP) {\n\t\tuint32_t *inbuf, *outbuf;\n\t\tuint16_t iter;\n\n\t\tinbuf = (uint32_t *)&sts->nvme_ersp_data;\n\t\toutbuf = (uint32_t *)fd->rspaddr;\n\t\tiocb->u.nvme.rsp_pyld_len = sts->nvme_rsp_pyld_len;\n\t\tif (unlikely(le16_to_cpu(iocb->u.nvme.rsp_pyld_len) >\n\t\t    sizeof(struct nvme_fc_ersp_iu))) {\n\t\t\tif (ql_mask_match(ql_dbg_io)) {\n\t\t\t\tWARN_ONCE(1, \"Unexpected response payload length %u.\\n\",\n\t\t\t\t    iocb->u.nvme.rsp_pyld_len);\n\t\t\t\tql_log(ql_log_warn, fcport->vha, 0x5100,\n\t\t\t\t    \"Unexpected response payload length %u.\\n\",\n\t\t\t\t    iocb->u.nvme.rsp_pyld_len);\n\t\t\t}\n\t\t\tiocb->u.nvme.rsp_pyld_len =\n\t\t\t\tcpu_to_le16(sizeof(struct nvme_fc_ersp_iu));\n\t\t}\n\t\titer = le16_to_cpu(iocb->u.nvme.rsp_pyld_len) >> 2;\n\t\tfor (; iter; iter--)\n\t\t\t*outbuf++ = swab32(*inbuf++);\n\t}\n\n\tif (state_flags & SF_NVME_ERSP) {\n\t\tstruct nvme_fc_ersp_iu *rsp_iu = fd->rspaddr;\n\t\tu32 tgt_xfer_len;\n\n\t\ttgt_xfer_len = be32_to_cpu(rsp_iu->xfrd_len);\n\t\tif (fd->transferred_length != tgt_xfer_len) {\n\t\t\tql_log(ql_log_warn, fcport->vha, 0x3079,\n\t\t\t       \"Dropped frame(s) detected (sent/rcvd=%u/%u).\\n\",\n\t\t\t       tgt_xfer_len, fd->transferred_length);\n\t\t\tlogit = 1;\n\t\t} else if (le16_to_cpu(comp_status) == CS_DATA_UNDERRUN) {\n\t\t\t \n\t\t\tlogit = 0;\n\t\t}\n\t}\n\n\tif (unlikely(logit))\n\t\tql_dbg(ql_dbg_io, fcport->vha, 0x5060,\n\t\t   \"NVME-%s ERR Handling - hdl=%x status(%x) tr_len:%x resid=%x  ox_id=%x\\n\",\n\t\t   sp->name, sp->handle, comp_status,\n\t\t   fd->transferred_length, le32_to_cpu(sts->residual_len),\n\t\t   sts->ox_id);\n\n\t \n\tswitch (le16_to_cpu(comp_status)) {\n\tcase CS_COMPLETE:\n\t\tbreak;\n\n\tcase CS_RESET:\n\tcase CS_PORT_UNAVAILABLE:\n\tcase CS_PORT_LOGGED_OUT:\n\t\tfcport->nvme_flag |= NVME_FLAG_RESETTING;\n\t\tif (atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x3021,\n\t\t\t       \"Port to be marked lost on fcport=%06x, current \"\n\t\t\t       \"port state= %s comp_status %x.\\n\",\n\t\t\t       fcport->d_id.b24, port_state_str[FCS_ONLINE],\n\t\t\t       comp_status);\n\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t}\n\t\tfallthrough;\n\tcase CS_ABORTED:\n\tcase CS_PORT_BUSY:\n\t\tfd->transferred_length = 0;\n\t\tiocb->u.nvme.rsp_pyld_len = 0;\n\t\tret = QLA_ABORTED;\n\t\tbreak;\n\tcase CS_DATA_UNDERRUN:\n\t\tbreak;\n\tdefault:\n\t\tret = QLA_FUNCTION_FAILED;\n\t\tbreak;\n\t}\n\tsp->done(sp, ret);\n}\n\nstatic void qla_ctrlvp_completed(scsi_qla_host_t *vha, struct req_que *req,\n    struct vp_ctrl_entry_24xx *vce)\n{\n\tconst char func[] = \"CTRLVP-IOCB\";\n\tsrb_t *sp;\n\tint rval = QLA_SUCCESS;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, vce);\n\tif (!sp)\n\t\treturn;\n\n\tif (vce->entry_status != 0) {\n\t\tql_dbg(ql_dbg_vport, vha, 0x10c4,\n\t\t    \"%s: Failed to complete IOCB -- error status (%x)\\n\",\n\t\t    sp->name, vce->entry_status);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else if (vce->comp_status != cpu_to_le16(CS_COMPLETE)) {\n\t\tql_dbg(ql_dbg_vport, vha, 0x10c5,\n\t\t    \"%s: Failed to complete IOCB -- completion status (%x) vpidx %x\\n\",\n\t\t    sp->name, le16_to_cpu(vce->comp_status),\n\t\t    le16_to_cpu(vce->vp_idx_failed));\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tql_dbg(ql_dbg_vport, vha, 0x10c6,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\tsp->rc = rval;\n\tsp->done(sp, rval);\n}\n\n \nstatic void qla2x00_process_response_entry(struct scsi_qla_host *vha,\n\t\t\t\t\t   struct rsp_que *rsp,\n\t\t\t\t\t   sts_entry_t *pkt)\n{\n\tsts21_entry_t *sts21_entry;\n\tsts22_entry_t *sts22_entry;\n\tuint16_t handle_cnt;\n\tuint16_t cnt;\n\n\tswitch (pkt->entry_type) {\n\tcase STATUS_TYPE:\n\t\tqla2x00_status_entry(vha, rsp, pkt);\n\t\tbreak;\n\tcase STATUS_TYPE_21:\n\t\tsts21_entry = (sts21_entry_t *)pkt;\n\t\thandle_cnt = sts21_entry->handle_count;\n\t\tfor (cnt = 0; cnt < handle_cnt; cnt++)\n\t\t\tqla2x00_process_completed_request(vha, rsp->req,\n\t\t\t\t\t\tsts21_entry->handle[cnt]);\n\t\tbreak;\n\tcase STATUS_TYPE_22:\n\t\tsts22_entry = (sts22_entry_t *)pkt;\n\t\thandle_cnt = sts22_entry->handle_count;\n\t\tfor (cnt = 0; cnt < handle_cnt; cnt++)\n\t\t\tqla2x00_process_completed_request(vha, rsp->req,\n\t\t\t\t\t\tsts22_entry->handle[cnt]);\n\t\tbreak;\n\tcase STATUS_CONT_TYPE:\n\t\tqla2x00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);\n\t\tbreak;\n\tcase MBX_IOCB_TYPE:\n\t\tqla2x00_mbx_iocb_entry(vha, rsp->req, (struct mbx_entry *)pkt);\n\t\tbreak;\n\tcase CT_IOCB_TYPE:\n\t\tqla2x00_ct_entry(vha, rsp->req, pkt, CT_IOCB_TYPE);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tql_log(ql_log_warn, vha, 0x504a,\n\t\t       \"Received unknown response pkt type %x entry status=%x.\\n\",\n\t\t       pkt->entry_type, pkt->entry_status);\n\t\tbreak;\n\t}\n}\n\n \nvoid\nqla2x00_process_response_queue(struct rsp_que *rsp)\n{\n\tstruct scsi_qla_host *vha;\n\tstruct qla_hw_data *ha = rsp->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tsts_entry_t\t*pkt;\n\n\tvha = pci_get_drvdata(ha->pdev);\n\n\tif (!vha->flags.online)\n\t\treturn;\n\n\twhile (rsp->ring_ptr->signature != RESPONSE_PROCESSED) {\n\t\tpkt = (sts_entry_t *)rsp->ring_ptr;\n\n\t\trsp->ring_index++;\n\t\tif (rsp->ring_index == rsp->length) {\n\t\t\trsp->ring_index = 0;\n\t\t\trsp->ring_ptr = rsp->ring;\n\t\t} else {\n\t\t\trsp->ring_ptr++;\n\t\t}\n\n\t\tif (pkt->entry_status != 0) {\n\t\t\tqla2x00_error_entry(vha, rsp, pkt);\n\t\t\t((response_t *)pkt)->signature = RESPONSE_PROCESSED;\n\t\t\twmb();\n\t\t\tcontinue;\n\t\t}\n\n\t\tqla2x00_process_response_entry(vha, rsp, pkt);\n\t\t((response_t *)pkt)->signature = RESPONSE_PROCESSED;\n\t\twmb();\n\t}\n\n\t \n\twrt_reg_word(ISP_RSP_Q_OUT(ha, reg), rsp->ring_index);\n}\n\nstatic inline void\nqla2x00_handle_sense(srb_t *sp, uint8_t *sense_data, uint32_t par_sense_len,\n\t\t     uint32_t sense_len, struct rsp_que *rsp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct scsi_cmnd *cp = GET_CMD_SP(sp);\n\tuint32_t track_sense_len;\n\n\tif (sense_len >= SCSI_SENSE_BUFFERSIZE)\n\t\tsense_len = SCSI_SENSE_BUFFERSIZE;\n\n\tSET_CMD_SENSE_LEN(sp, sense_len);\n\tSET_CMD_SENSE_PTR(sp, cp->sense_buffer);\n\ttrack_sense_len = sense_len;\n\n\tif (sense_len > par_sense_len)\n\t\tsense_len = par_sense_len;\n\n\tmemcpy(cp->sense_buffer, sense_data, sense_len);\n\n\tSET_CMD_SENSE_PTR(sp, cp->sense_buffer + sense_len);\n\ttrack_sense_len -= sense_len;\n\tSET_CMD_SENSE_LEN(sp, track_sense_len);\n\n\tif (track_sense_len != 0) {\n\t\trsp->status_srb = sp;\n\t\tcp->result = res;\n\t}\n\n\tif (sense_len) {\n\t\tql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x301c,\n\t\t    \"Check condition Sense data, nexus%ld:%d:%llu cmd=%p.\\n\",\n\t\t    sp->vha->host_no, cp->device->id, cp->device->lun,\n\t\t    cp);\n\t\tql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x302b,\n\t\t    cp->sense_buffer, sense_len);\n\t}\n}\n\nstruct scsi_dif_tuple {\n\t__be16 guard;        \n\t__be16 app_tag;          \n\t__be32 ref_tag;          \n};\n\n \nstatic inline int\nqla2x00_handle_dif_error(srb_t *sp, struct sts_entry_24xx *sts24)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tuint8_t\t\t*ap = &sts24->data[12];\n\tuint8_t\t\t*ep = &sts24->data[20];\n\tuint32_t\te_ref_tag, a_ref_tag;\n\tuint16_t\te_app_tag, a_app_tag;\n\tuint16_t\te_guard, a_guard;\n\n\t \n\ta_guard   = get_unaligned_le16(ap + 2);\n\ta_app_tag = get_unaligned_le16(ap + 0);\n\ta_ref_tag = get_unaligned_le32(ap + 4);\n\te_guard   = get_unaligned_le16(ep + 2);\n\te_app_tag = get_unaligned_le16(ep + 0);\n\te_ref_tag = get_unaligned_le32(ep + 4);\n\n\tql_dbg(ql_dbg_io, vha, 0x3023,\n\t    \"iocb(s) %p Returned STATUS.\\n\", sts24);\n\n\tql_dbg(ql_dbg_io, vha, 0x3024,\n\t    \"DIF ERROR in cmd 0x%x lba 0x%llx act ref\"\n\t    \" tag=0x%x, exp ref_tag=0x%x, act app tag=0x%x, exp app\"\n\t    \" tag=0x%x, act guard=0x%x, exp guard=0x%x.\\n\",\n\t    cmd->cmnd[0], (u64)scsi_get_lba(cmd), a_ref_tag, e_ref_tag,\n\t    a_app_tag, e_app_tag, a_guard, e_guard);\n\n\t \n\tif (a_app_tag == be16_to_cpu(T10_PI_APP_ESCAPE) &&\n\t    (scsi_get_prot_type(cmd) != SCSI_PROT_DIF_TYPE3 ||\n\t     a_ref_tag == be32_to_cpu(T10_PI_REF_ESCAPE))) {\n\t\tuint32_t blocks_done, resid;\n\t\tsector_t lba_s = scsi_get_lba(cmd);\n\n\t\t \n\t\tblocks_done = e_ref_tag - (uint32_t)lba_s + 1;\n\n\t\tresid = scsi_bufflen(cmd) - (blocks_done *\n\t\t    cmd->device->sector_size);\n\n\t\tscsi_set_resid(cmd, resid);\n\t\tcmd->result = DID_OK << 16;\n\n\t\t \n\t\tif (scsi_prot_sg_count(cmd)) {\n\t\t\tuint32_t i, j = 0, k = 0, num_ent;\n\t\t\tstruct scatterlist *sg;\n\t\t\tstruct t10_pi_tuple *spt;\n\n\t\t\t \n\t\t\tscsi_for_each_prot_sg(cmd, sg,\n\t\t\t    scsi_prot_sg_count(cmd), i) {\n\t\t\t\tnum_ent = sg_dma_len(sg) / 8;\n\t\t\t\tif (k + num_ent < blocks_done) {\n\t\t\t\t\tk += num_ent;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tj = blocks_done - k - 1;\n\t\t\t\tk = blocks_done;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (k != blocks_done) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x302f,\n\t\t\t\t    \"unexpected tag values tag:lba=%x:%llx)\\n\",\n\t\t\t\t    e_ref_tag, (unsigned long long)lba_s);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tspt = page_address(sg_page(sg)) + sg->offset;\n\t\t\tspt += j;\n\n\t\t\tspt->app_tag = T10_PI_APP_ESCAPE;\n\t\t\tif (scsi_get_prot_type(cmd) == SCSI_PROT_DIF_TYPE3)\n\t\t\t\tspt->ref_tag = T10_PI_REF_ESCAPE;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (e_guard != a_guard) {\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x1);\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\treturn 1;\n\t}\n\n\t \n\tif (e_ref_tag != a_ref_tag) {\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x3);\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\treturn 1;\n\t}\n\n\t \n\tif (e_app_tag != a_app_tag) {\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x2);\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n\nstatic void\nqla25xx_process_bidir_status_iocb(scsi_qla_host_t *vha, void *pkt,\n\t\t\t\t  struct req_que *req, uint32_t index)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tsrb_t *sp;\n\tuint16_t\tcomp_status;\n\tuint16_t\tscsi_status;\n\tuint16_t thread_id;\n\tuint32_t rval = EXT_STATUS_OK;\n\tstruct bsg_job *bsg_job = NULL;\n\tstruct fc_bsg_request *bsg_request;\n\tstruct fc_bsg_reply *bsg_reply;\n\tsts_entry_t *sts = pkt;\n\tstruct sts_entry_24xx *sts24 = pkt;\n\n\t \n\tif (index >= req->num_outstanding_cmds) {\n\t\tql_log(ql_log_warn, vha, 0x70af,\n\t\t    \"Invalid SCSI completion handle 0x%x.\\n\", index);\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t}\n\n\tsp = req->outstanding_cmds[index];\n\tif (!sp) {\n\t\tql_log(ql_log_warn, vha, 0x70b0,\n\t\t    \"Req:%d: Invalid ISP SCSI completion handle(0x%x)\\n\",\n\t\t    req->id, index);\n\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t}\n\n\t \n\treq->outstanding_cmds[index] = NULL;\n\tbsg_job = sp->u.bsg_job;\n\tbsg_request = bsg_job->request;\n\tbsg_reply = bsg_job->reply;\n\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tcomp_status = le16_to_cpu(sts24->comp_status);\n\t\tscsi_status = le16_to_cpu(sts24->scsi_status) & SS_MASK;\n\t} else {\n\t\tcomp_status = le16_to_cpu(sts->comp_status);\n\t\tscsi_status = le16_to_cpu(sts->scsi_status) & SS_MASK;\n\t}\n\n\tthread_id = bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\tswitch (comp_status) {\n\tcase CS_COMPLETE:\n\t\tif (scsi_status == 0) {\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\t\tbsg_job->reply_payload.payload_len;\n\t\t\tvha->qla_stats.input_bytes +=\n\t\t\t\tbsg_reply->reply_payload_rcv_len;\n\t\t\tvha->qla_stats.input_requests++;\n\t\t\trval = EXT_STATUS_OK;\n\t\t}\n\t\tgoto done;\n\n\tcase CS_DATA_OVERRUN:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b1,\n\t\t    \"Command completed with data overrun thread_id=%d\\n\",\n\t\t    thread_id);\n\t\trval = EXT_STATUS_DATA_OVERRUN;\n\t\tbreak;\n\n\tcase CS_DATA_UNDERRUN:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b2,\n\t\t    \"Command completed with data underrun thread_id=%d\\n\",\n\t\t    thread_id);\n\t\trval = EXT_STATUS_DATA_UNDERRUN;\n\t\tbreak;\n\tcase CS_BIDIR_RD_OVERRUN:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b3,\n\t\t    \"Command completed with read data overrun thread_id=%d\\n\",\n\t\t    thread_id);\n\t\trval = EXT_STATUS_DATA_OVERRUN;\n\t\tbreak;\n\n\tcase CS_BIDIR_RD_WR_OVERRUN:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b4,\n\t\t    \"Command completed with read and write data overrun \"\n\t\t    \"thread_id=%d\\n\", thread_id);\n\t\trval = EXT_STATUS_DATA_OVERRUN;\n\t\tbreak;\n\n\tcase CS_BIDIR_RD_OVERRUN_WR_UNDERRUN:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b5,\n\t\t    \"Command completed with read data over and write data \"\n\t\t    \"underrun thread_id=%d\\n\", thread_id);\n\t\trval = EXT_STATUS_DATA_OVERRUN;\n\t\tbreak;\n\n\tcase CS_BIDIR_RD_UNDERRUN:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b6,\n\t\t    \"Command completed with read data underrun \"\n\t\t    \"thread_id=%d\\n\", thread_id);\n\t\trval = EXT_STATUS_DATA_UNDERRUN;\n\t\tbreak;\n\n\tcase CS_BIDIR_RD_UNDERRUN_WR_OVERRUN:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b7,\n\t\t    \"Command completed with read data under and write data \"\n\t\t    \"overrun thread_id=%d\\n\", thread_id);\n\t\trval = EXT_STATUS_DATA_UNDERRUN;\n\t\tbreak;\n\n\tcase CS_BIDIR_RD_WR_UNDERRUN:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b8,\n\t\t    \"Command completed with read and write data underrun \"\n\t\t    \"thread_id=%d\\n\", thread_id);\n\t\trval = EXT_STATUS_DATA_UNDERRUN;\n\t\tbreak;\n\n\tcase CS_BIDIR_DMA:\n\t\tql_dbg(ql_dbg_user, vha, 0x70b9,\n\t\t    \"Command completed with data DMA error thread_id=%d\\n\",\n\t\t    thread_id);\n\t\trval = EXT_STATUS_DMA_ERR;\n\t\tbreak;\n\n\tcase CS_TIMEOUT:\n\t\tql_dbg(ql_dbg_user, vha, 0x70ba,\n\t\t    \"Command completed with timeout thread_id=%d\\n\",\n\t\t    thread_id);\n\t\trval = EXT_STATUS_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_user, vha, 0x70bb,\n\t\t    \"Command completed with completion status=0x%x \"\n\t\t    \"thread_id=%d\\n\", comp_status, thread_id);\n\t\trval = EXT_STATUS_ERR;\n\t\tbreak;\n\t}\n\tbsg_reply->reply_payload_rcv_len = 0;\n\ndone:\n\t \n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = rval;\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\t \n\tsp->done(sp, DID_OK << 16);\n\n}\n\n \nstatic void\nqla2x00_status_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, void *pkt)\n{\n\tsrb_t\t\t*sp;\n\tfc_port_t\t*fcport;\n\tstruct scsi_cmnd *cp;\n\tsts_entry_t *sts = pkt;\n\tstruct sts_entry_24xx *sts24 = pkt;\n\tuint16_t\tcomp_status;\n\tuint16_t\tscsi_status;\n\tuint16_t\tox_id;\n\tuint8_t\t\tlscsi_status;\n\tint32_t\t\tresid;\n\tuint32_t sense_len, par_sense_len, rsp_info_len, resid_len,\n\t    fw_resid_len;\n\tuint8_t\t\t*rsp_info, *sense_data;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t handle;\n\tuint16_t que;\n\tstruct req_que *req;\n\tint logit = 1;\n\tint res = 0;\n\tuint16_t state_flags = 0;\n\tuint16_t sts_qual = 0;\n\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tcomp_status = le16_to_cpu(sts24->comp_status);\n\t\tscsi_status = le16_to_cpu(sts24->scsi_status) & SS_MASK;\n\t\tstate_flags = le16_to_cpu(sts24->state_flags);\n\t} else {\n\t\tcomp_status = le16_to_cpu(sts->comp_status);\n\t\tscsi_status = le16_to_cpu(sts->scsi_status) & SS_MASK;\n\t}\n\thandle = (uint32_t) LSW(sts->handle);\n\tque = MSW(sts->handle);\n\treq = ha->req_q_map[que];\n\n\t \n\tif (req == NULL ||\n\t    que >= find_first_zero_bit(ha->req_qid_map, ha->max_req_queues)) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3059,\n\t\t    \"Invalid status handle (0x%x): Bad req pointer. req=%p, \"\n\t\t    \"que=%u.\\n\", sts->handle, req, que);\n\t\treturn;\n\t}\n\n\t \n\tif (handle < req->num_outstanding_cmds) {\n\t\tsp = req->outstanding_cmds[handle];\n\t\tif (!sp) {\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3075,\n\t\t\t    \"%s(%ld): Already returned command for status handle (0x%x).\\n\",\n\t\t\t    __func__, vha->host_no, sts->handle);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tql_dbg(ql_dbg_io, vha, 0x3017,\n\t\t    \"Invalid status handle, out of range (0x%x).\\n\",\n\t\t    sts->handle);\n\n\t\tif (!test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)) {\n\t\t\tif (IS_P3P_TYPE(ha))\n\t\t\t\tset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\n\t\t\telse\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t}\n\t\treturn;\n\t}\n\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\n\tif (sp->cmd_type != TYPE_SRB) {\n\t\treq->outstanding_cmds[handle] = NULL;\n\t\tql_dbg(ql_dbg_io, vha, 0x3015,\n\t\t    \"Unknown sp->cmd_type %x %p).\\n\",\n\t\t    sp->cmd_type, sp);\n\t\treturn;\n\t}\n\n\t \n\tif (sp->type == SRB_NVME_CMD) {\n\t\treq->outstanding_cmds[handle] = NULL;\n\t\tqla24xx_nvme_iocb_entry(vha, req, pkt, sp);\n\t\treturn;\n\t}\n\n\tif (unlikely((state_flags & BIT_1) && (sp->type == SRB_BIDI_CMD))) {\n\t\tqla25xx_process_bidir_status_iocb(vha, pkt, req, handle);\n\t\treturn;\n\t}\n\n\t \n\tif (sp->type == SRB_TM_CMD) {\n\t\tqla24xx_tm_iocb_entry(vha, req, pkt);\n\t\treturn;\n\t}\n\n\t \n\tqla_chk_edif_rx_sa_delete_pending(vha, sp, sts24);\n\tsp->qpair->cmd_completion_cnt++;\n\n\tif (comp_status == CS_COMPLETE && scsi_status == 0) {\n\t\tqla2x00_process_completed_request(vha, req, handle);\n\n\t\treturn;\n\t}\n\n\tcp = GET_CMD_SP(sp);\n\tif (cp == NULL) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3018,\n\t\t    \"Command already returned (0x%x/%p).\\n\",\n\t\t    sts->handle, sp);\n\n\t\treq->outstanding_cmds[handle] = NULL;\n\t\treturn;\n\t}\n\n\tlscsi_status = scsi_status & STATUS_MASK;\n\n\tfcport = sp->fcport;\n\n\tox_id = 0;\n\tsense_len = par_sense_len = rsp_info_len = resid_len =\n\t    fw_resid_len = 0;\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tif (scsi_status & SS_SENSE_LEN_VALID)\n\t\t\tsense_len = le32_to_cpu(sts24->sense_len);\n\t\tif (scsi_status & SS_RESPONSE_INFO_LEN_VALID)\n\t\t\trsp_info_len = le32_to_cpu(sts24->rsp_data_len);\n\t\tif (scsi_status & (SS_RESIDUAL_UNDER | SS_RESIDUAL_OVER))\n\t\t\tresid_len = le32_to_cpu(sts24->rsp_residual_count);\n\t\tif (comp_status == CS_DATA_UNDERRUN)\n\t\t\tfw_resid_len = le32_to_cpu(sts24->residual_len);\n\t\trsp_info = sts24->data;\n\t\tsense_data = sts24->data;\n\t\thost_to_fcp_swap(sts24->data, sizeof(sts24->data));\n\t\tox_id = le16_to_cpu(sts24->ox_id);\n\t\tpar_sense_len = sizeof(sts24->data);\n\t\tsts_qual = le16_to_cpu(sts24->status_qualifier);\n\t} else {\n\t\tif (scsi_status & SS_SENSE_LEN_VALID)\n\t\t\tsense_len = le16_to_cpu(sts->req_sense_length);\n\t\tif (scsi_status & SS_RESPONSE_INFO_LEN_VALID)\n\t\t\trsp_info_len = le16_to_cpu(sts->rsp_info_len);\n\t\tresid_len = le32_to_cpu(sts->residual_length);\n\t\trsp_info = sts->rsp_info;\n\t\tsense_data = sts->req_sense_data;\n\t\tpar_sense_len = sizeof(sts->req_sense_data);\n\t}\n\n\t \n\tif (scsi_status & SS_RESPONSE_INFO_LEN_VALID) {\n\t\t \n\t\tif (IS_FWI2_CAPABLE(ha)) {\n\t\t\tsense_data += rsp_info_len;\n\t\t\tpar_sense_len -= rsp_info_len;\n\t\t}\n\t\tif (rsp_info_len > 3 && rsp_info[3]) {\n\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3019,\n\t\t\t    \"FCP I/O protocol failure (0x%x/0x%x).\\n\",\n\t\t\t    rsp_info_len, rsp_info[3]);\n\n\t\t\tres = DID_BUS_BUSY << 16;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (IS_FWI2_CAPABLE(ha) && comp_status == CS_COMPLETE &&\n\t    scsi_status & SS_RESIDUAL_OVER)\n\t\tcomp_status = CS_DATA_OVERRUN;\n\n\t \n\tif (unlikely(lscsi_status == SAM_STAT_TASK_SET_FULL ||\n\t\t     lscsi_status == SAM_STAT_BUSY))\n\t\tqla2x00_set_retry_delay_timestamp(fcport, sts_qual);\n\n\t \n\tswitch (comp_status) {\n\tcase CS_COMPLETE:\n\tcase CS_QUEUE_FULL:\n\t\tif (scsi_status == 0) {\n\t\t\tres = DID_OK << 16;\n\t\t\tbreak;\n\t\t}\n\t\tif (scsi_status & (SS_RESIDUAL_UNDER | SS_RESIDUAL_OVER)) {\n\t\t\tresid = resid_len;\n\t\t\tscsi_set_resid(cp, resid);\n\n\t\t\tif (!lscsi_status &&\n\t\t\t    ((unsigned)(scsi_bufflen(cp) - resid) <\n\t\t\t     cp->underflow)) {\n\t\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x301a,\n\t\t\t\t    \"Mid-layer underflow detected (0x%x of 0x%x bytes).\\n\",\n\t\t\t\t    resid, scsi_bufflen(cp));\n\n\t\t\t\tres = DID_ERROR << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tres = DID_OK << 16 | lscsi_status;\n\n\t\tif (lscsi_status == SAM_STAT_TASK_SET_FULL) {\n\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x301b,\n\t\t\t    \"QUEUE FULL detected.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlogit = 0;\n\t\tif (lscsi_status != SS_CHECK_CONDITION)\n\t\t\tbreak;\n\n\t\tmemset(cp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\tif (!(scsi_status & SS_SENSE_LEN_VALID))\n\t\t\tbreak;\n\n\t\tqla2x00_handle_sense(sp, sense_data, par_sense_len, sense_len,\n\t\t    rsp, res);\n\t\tbreak;\n\n\tcase CS_DATA_UNDERRUN:\n\t\t \n\t\tresid = IS_FWI2_CAPABLE(ha) ? fw_resid_len : resid_len;\n\t\tscsi_set_resid(cp, resid);\n\t\tif (scsi_status & SS_RESIDUAL_UNDER) {\n\t\t\tif (IS_FWI2_CAPABLE(ha) && fw_resid_len != resid_len) {\n\t\t\t\tql_log(ql_log_warn, fcport->vha, 0x301d,\n\t\t\t\t       \"Dropped frame(s) detected (0x%x of 0x%x bytes).\\n\",\n\t\t\t\t       resid, scsi_bufflen(cp));\n\n\t\t\t\tres = DID_ERROR << 16 | lscsi_status;\n\t\t\t\tgoto check_scsi_status;\n\t\t\t}\n\n\t\t\tif (!lscsi_status &&\n\t\t\t    ((unsigned)(scsi_bufflen(cp) - resid) <\n\t\t\t    cp->underflow)) {\n\t\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x301e,\n\t\t\t\t    \"Mid-layer underflow detected (0x%x of 0x%x bytes).\\n\",\n\t\t\t\t    resid, scsi_bufflen(cp));\n\n\t\t\t\tres = DID_ERROR << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (lscsi_status != SAM_STAT_TASK_SET_FULL &&\n\t\t\t    lscsi_status != SAM_STAT_BUSY) {\n\t\t\t \n\n\t\t\tql_log(ql_log_warn, fcport->vha, 0x301f,\n\t\t\t       \"Dropped frame(s) detected (0x%x of 0x%x bytes).\\n\",\n\t\t\t       resid, scsi_bufflen(cp));\n\n\t\t\tvha->interface_err_cnt++;\n\n\t\t\tres = DID_ERROR << 16 | lscsi_status;\n\t\t\tgoto check_scsi_status;\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3030,\n\t\t\t    \"scsi_status: 0x%x, lscsi_status: 0x%x\\n\",\n\t\t\t    scsi_status, lscsi_status);\n\t\t}\n\n\t\tres = DID_OK << 16 | lscsi_status;\n\t\tlogit = 0;\n\ncheck_scsi_status:\n\t\t \n\t\tif (lscsi_status != 0) {\n\t\t\tif (lscsi_status == SAM_STAT_TASK_SET_FULL) {\n\t\t\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3020,\n\t\t\t\t    \"QUEUE FULL detected.\\n\");\n\t\t\t\tlogit = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lscsi_status != SS_CHECK_CONDITION)\n\t\t\t\tbreak;\n\n\t\t\tmemset(cp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\t\t\tif (!(scsi_status & SS_SENSE_LEN_VALID))\n\t\t\t\tbreak;\n\n\t\t\tqla2x00_handle_sense(sp, sense_data, par_sense_len,\n\t\t\t    sense_len, rsp, res);\n\t\t}\n\t\tbreak;\n\n\tcase CS_PORT_LOGGED_OUT:\n\tcase CS_PORT_CONFIG_CHG:\n\tcase CS_PORT_BUSY:\n\tcase CS_INCOMPLETE:\n\tcase CS_PORT_UNAVAILABLE:\n\tcase CS_TIMEOUT:\n\tcase CS_RESET:\n\tcase CS_EDIF_INV_REQ:\n\n\t\t \n\t\tres = DID_TRANSPORT_DISRUPTED << 16;\n\n\t\tif (comp_status == CS_TIMEOUT) {\n\t\t\tif (IS_FWI2_CAPABLE(ha))\n\t\t\t\tbreak;\n\t\t\telse if ((le16_to_cpu(sts->status_flags) &\n\t\t\t    SF_LOGOUT_SENT) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x3021,\n\t\t\t\t\"Port to be marked lost on fcport=%02x%02x%02x, current \"\n\t\t\t\t\"port state= %s comp_status %x.\\n\", fcport->d_id.b.domain,\n\t\t\t\tfcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t\t\t\tport_state_str[FCS_ONLINE],\n\t\t\t\tcomp_status);\n\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t}\n\n\t\tbreak;\n\n\tcase CS_ABORTED:\n\t\tres = DID_RESET << 16;\n\t\tbreak;\n\n\tcase CS_DIF_ERROR:\n\t\tlogit = qla2x00_handle_dif_error(sp, sts24);\n\t\tres = cp->result;\n\t\tbreak;\n\n\tcase CS_TRANSPORT:\n\t\tres = DID_ERROR << 16;\n\t\tvha->hw_err_cnt++;\n\n\t\tif (!IS_PI_SPLIT_DET_CAPABLE(ha))\n\t\t\tbreak;\n\n\t\tif (state_flags & BIT_4)\n\t\t\tscmd_printk(KERN_WARNING, cp,\n\t\t\t    \"Unsupported device '%s' found.\\n\",\n\t\t\t    cp->device->vendor);\n\t\tbreak;\n\n\tcase CS_DMA:\n\t\tql_log(ql_log_info, fcport->vha, 0x3022,\n\t\t    \"CS_DMA error: 0x%x-0x%x (0x%x) nexus=%ld:%d:%llu portid=%06x oxid=0x%x cdb=%10phN len=0x%x rsp_info=0x%x resid=0x%x fw_resid=0x%x sp=%p cp=%p.\\n\",\n\t\t    comp_status, scsi_status, res, vha->host_no,\n\t\t    cp->device->id, cp->device->lun, fcport->d_id.b24,\n\t\t    ox_id, cp->cmnd, scsi_bufflen(cp), rsp_info_len,\n\t\t    resid_len, fw_resid_len, sp, cp);\n\t\tql_dump_buffer(ql_dbg_tgt + ql_dbg_verbose, vha, 0xe0ee,\n\t\t    pkt, sizeof(*sts24));\n\t\tres = DID_ERROR << 16;\n\t\tvha->hw_err_cnt++;\n\t\tbreak;\n\tdefault:\n\t\tres = DID_ERROR << 16;\n\t\tbreak;\n\t}\n\nout:\n\tif (logit)\n\t\tql_dbg(ql_dbg_io, fcport->vha, 0x3022,\n\t\t       \"FCP command status: 0x%x-0x%x (0x%x) nexus=%ld:%d:%llu portid=%02x%02x%02x oxid=0x%x cdb=%10phN len=0x%x rsp_info=0x%x resid=0x%x fw_resid=0x%x sp=%p cp=%p.\\n\",\n\t\t       comp_status, scsi_status, res, vha->host_no,\n\t\t       cp->device->id, cp->device->lun, fcport->d_id.b.domain,\n\t\t       fcport->d_id.b.area, fcport->d_id.b.al_pa, ox_id,\n\t\t       cp->cmnd, scsi_bufflen(cp), rsp_info_len,\n\t\t       resid_len, fw_resid_len, sp, cp);\n\n\tif (rsp->status_srb == NULL)\n\t\tsp->done(sp, res);\n\n\t \n\treq->outstanding_cmds[handle] = NULL;\n}\n\n \nstatic void\nqla2x00_status_cont_entry(struct rsp_que *rsp, sts_cont_entry_t *pkt)\n{\n\tuint8_t\tsense_sz = 0;\n\tstruct qla_hw_data *ha = rsp->hw;\n\tstruct scsi_qla_host *vha = pci_get_drvdata(ha->pdev);\n\tsrb_t *sp = rsp->status_srb;\n\tstruct scsi_cmnd *cp;\n\tuint32_t sense_len;\n\tuint8_t *sense_ptr;\n\n\tif (!sp || !GET_CMD_SENSE_LEN(sp))\n\t\treturn;\n\n\tsense_len = GET_CMD_SENSE_LEN(sp);\n\tsense_ptr = GET_CMD_SENSE_PTR(sp);\n\n\tcp = GET_CMD_SP(sp);\n\tif (cp == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x3025,\n\t\t    \"cmd is NULL: already returned to OS (sp=%p).\\n\", sp);\n\n\t\trsp->status_srb = NULL;\n\t\treturn;\n\t}\n\n\tif (sense_len > sizeof(pkt->data))\n\t\tsense_sz = sizeof(pkt->data);\n\telse\n\t\tsense_sz = sense_len;\n\n\t \n\tif (IS_FWI2_CAPABLE(ha))\n\t\thost_to_fcp_swap(pkt->data, sizeof(pkt->data));\n\tmemcpy(sense_ptr, pkt->data, sense_sz);\n\tql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x302c,\n\t\tsense_ptr, sense_sz);\n\n\tsense_len -= sense_sz;\n\tsense_ptr += sense_sz;\n\n\tSET_CMD_SENSE_PTR(sp, sense_ptr);\n\tSET_CMD_SENSE_LEN(sp, sense_len);\n\n\t \n\tif (sense_len == 0) {\n\t\trsp->status_srb = NULL;\n\t\tsp->done(sp, cp->result);\n\t}\n}\n\n \nstatic int\nqla2x00_error_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, sts_entry_t *pkt)\n{\n\tsrb_t *sp;\n\tstruct qla_hw_data *ha = vha->hw;\n\tconst char func[] = \"ERROR-IOCB\";\n\tuint16_t que = MSW(pkt->handle);\n\tstruct req_que *req = NULL;\n\tint res = DID_ERROR << 16;\n\tu16 index;\n\n\tql_dbg(ql_dbg_async, vha, 0x502a,\n\t    \"iocb type %xh with error status %xh, handle %xh, rspq id %d\\n\",\n\t    pkt->entry_type, pkt->entry_status, pkt->handle, rsp->id);\n\n\tif (que >= ha->max_req_queues || !ha->req_q_map[que])\n\t\tgoto fatal;\n\n\treq = ha->req_q_map[que];\n\n\tif (pkt->entry_status & RF_BUSY)\n\t\tres = DID_BUS_BUSY << 16;\n\n\tif ((pkt->handle & ~QLA_TGT_HANDLE_MASK) == QLA_TGT_SKIP_HANDLE)\n\t\treturn 0;\n\n\tswitch (pkt->entry_type) {\n\tcase NOTIFY_ACK_TYPE:\n\tcase STATUS_CONT_TYPE:\n\tcase LOGINOUT_PORT_IOCB_TYPE:\n\tcase CT_IOCB_TYPE:\n\tcase ELS_IOCB_TYPE:\n\tcase ABORT_IOCB_TYPE:\n\tcase MBX_IOCB_TYPE:\n\tdefault:\n\t\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\t\tif (sp) {\n\t\t\tsp->done(sp, res);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase SA_UPDATE_IOCB_TYPE:\n\tcase ABTS_RESP_24XX:\n\tcase CTIO_TYPE7:\n\tcase CTIO_CRC2:\n\t\treturn 1;\n\tcase STATUS_TYPE:\n\t\tsp = qla_get_sp_from_handle(vha, func, req, pkt, &index);\n\t\tif (sp) {\n\t\t\tsp->done(sp, res);\n\t\t\treq->outstanding_cmds[index] = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\nfatal:\n\tql_log(ql_log_warn, vha, 0x5030,\n\t    \"Error entry - invalid handle/queue (%04x).\\n\", que);\n\treturn 0;\n}\n\n \nstatic void\nqla24xx_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)\n{\n\tuint16_t\tcnt;\n\tuint32_t\tmboxes;\n\t__le16 __iomem *wptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\t \n\tWARN_ON_ONCE(ha->mbx_count > 32);\n\tmboxes = (1ULL << ha->mbx_count) - 1;\n\tif (!ha->mcp)\n\t\tql_dbg(ql_dbg_async, vha, 0x504e, \"MBX pointer ERROR.\\n\");\n\telse\n\t\tmboxes = ha->mcp->in_mb;\n\n\t \n\tha->flags.mbox_int = 1;\n\tha->mailbox_out[0] = mb0;\n\tmboxes >>= 1;\n\twptr = &reg->mailbox1;\n\n\tfor (cnt = 1; cnt < ha->mbx_count; cnt++) {\n\t\tif (mboxes & BIT_0)\n\t\t\tha->mailbox_out[cnt] = rd_reg_word(wptr);\n\n\t\tmboxes >>= 1;\n\t\twptr++;\n\t}\n}\n\nstatic void\nqla24xx_abort_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\n\tstruct abort_entry_24xx *pkt)\n{\n\tconst char func[] = \"ABT_IOCB\";\n\tsrb_t *sp;\n\tsrb_t *orig_sp = NULL;\n\tstruct srb_iocb *abt;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\n\tabt = &sp->u.iocb_cmd;\n\tabt->u.abt.comp_status = pkt->comp_status;\n\torig_sp = sp->cmd_sp;\n\t \n\tif (orig_sp)\n\t\tqla_nvme_abort_process_comp_status(pkt, orig_sp);\n\n\tsp->done(sp, 0);\n}\n\nvoid qla24xx_nvme_ls4_iocb(struct scsi_qla_host *vha,\n    struct pt_ls4_request *pkt, struct req_que *req)\n{\n\tsrb_t *sp;\n\tconst char func[] = \"LS4_IOCB\";\n\tuint16_t comp_status;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\n\tcomp_status = le16_to_cpu(pkt->status);\n\tsp->done(sp, comp_status);\n}\n\n \nstatic int qla_chk_cont_iocb_avail(struct scsi_qla_host *vha,\n\tstruct rsp_que *rsp, response_t *pkt, u32 rsp_q_in)\n{\n\tint start_pkt_ring_index;\n\tu32 iocb_cnt = 0;\n\tint rc = 0;\n\n\tif (pkt->entry_count == 1)\n\t\treturn rc;\n\n\t \n\tif (rsp->ring_index == 0)\n\t\tstart_pkt_ring_index = rsp->length - 1;\n\telse\n\t\tstart_pkt_ring_index = rsp->ring_index - 1;\n\n\tif (rsp_q_in < start_pkt_ring_index)\n\t\t \n\t\tiocb_cnt = rsp->length - start_pkt_ring_index + rsp_q_in;\n\telse\n\t\tiocb_cnt = rsp_q_in - start_pkt_ring_index;\n\n\tif (iocb_cnt < pkt->entry_count)\n\t\trc = -EIO;\n\n\tql_dbg(ql_dbg_init, vha, 0x5091,\n\t       \"%s - ring %p pkt %p entry count %d iocb_cnt %d rsp_q_in %d rc %d\\n\",\n\t       __func__, rsp->ring, pkt, pkt->entry_count, iocb_cnt, rsp_q_in, rc);\n\n\treturn rc;\n}\n\nstatic void qla_marker_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\n\tstruct mrk_entry_24xx *pkt)\n{\n\tconst char func[] = \"MRK-IOCB\";\n\tsrb_t *sp;\n\tint res = QLA_SUCCESS;\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn;\n\n\tsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\n\tif (!sp)\n\t\treturn;\n\n\tif (pkt->entry_status) {\n\t\tql_dbg(ql_dbg_taskm, vha, 0x8025, \"marker failure.\\n\");\n\t\tres = QLA_COMMAND_ERROR;\n\t}\n\tsp->u.iocb_cmd.u.tmf.data = res;\n\tsp->done(sp, res);\n}\n\n \nvoid qla24xx_process_response_queue(struct scsi_qla_host *vha,\n\tstruct rsp_que *rsp)\n{\n\tstruct sts_entry_24xx *pkt;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct purex_entry_24xx *purex_entry;\n\tstruct purex_item *pure_item;\n\tstruct pt_ls4_rx_unsol *p;\n\tu16 rsp_in = 0, cur_ring_index;\n\tint is_shadow_hba;\n\n\tif (!ha->flags.fw_started)\n\t\treturn;\n\n\tif (rsp->qpair->cpuid != raw_smp_processor_id() || !rsp->qpair->rcv_intr) {\n\t\trsp->qpair->rcv_intr = 1;\n\n\t\tif (!rsp->qpair->cpu_mapped)\n\t\t\tqla_cpu_update(rsp->qpair, raw_smp_processor_id());\n\t}\n\n#define __update_rsp_in(_is_shadow_hba, _rsp, _rsp_in)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t_rsp_in = _is_shadow_hba ? *(_rsp)->in_ptr :\t\t\\\n\t\t\t\trd_reg_dword_relaxed((_rsp)->rsp_q_in);\t\\\n\t} while (0)\n\n\tis_shadow_hba = IS_SHADOW_REG_CAPABLE(ha);\n\n\t__update_rsp_in(is_shadow_hba, rsp, rsp_in);\n\n\twhile (rsp->ring_index != rsp_in &&\n\t\t       rsp->ring_ptr->signature != RESPONSE_PROCESSED) {\n\t\tpkt = (struct sts_entry_24xx *)rsp->ring_ptr;\n\t\tcur_ring_index = rsp->ring_index;\n\n\t\trsp->ring_index++;\n\t\tif (rsp->ring_index == rsp->length) {\n\t\t\trsp->ring_index = 0;\n\t\t\trsp->ring_ptr = rsp->ring;\n\t\t} else {\n\t\t\trsp->ring_ptr++;\n\t\t}\n\n\t\tif (pkt->entry_status != 0) {\n\t\t\tif (qla2x00_error_entry(vha, rsp, (sts_entry_t *) pkt))\n\t\t\t\tgoto process_err;\n\n\t\t\t((response_t *)pkt)->signature = RESPONSE_PROCESSED;\n\t\t\twmb();\n\t\t\tcontinue;\n\t\t}\nprocess_err:\n\n\t\tswitch (pkt->entry_type) {\n\t\tcase STATUS_TYPE:\n\t\t\tqla2x00_status_entry(vha, rsp, pkt);\n\t\t\tbreak;\n\t\tcase STATUS_CONT_TYPE:\n\t\t\tqla2x00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);\n\t\t\tbreak;\n\t\tcase VP_RPT_ID_IOCB_TYPE:\n\t\t\tqla24xx_report_id_acquisition(vha,\n\t\t\t    (struct vp_rpt_id_entry_24xx *)pkt);\n\t\t\tbreak;\n\t\tcase LOGINOUT_PORT_IOCB_TYPE:\n\t\t\tqla24xx_logio_entry(vha, rsp->req,\n\t\t\t    (struct logio_entry_24xx *)pkt);\n\t\t\tbreak;\n\t\tcase CT_IOCB_TYPE:\n\t\t\tqla24xx_els_ct_entry(vha, rsp->req, pkt, CT_IOCB_TYPE);\n\t\t\tbreak;\n\t\tcase ELS_IOCB_TYPE:\n\t\t\tqla24xx_els_ct_entry(vha, rsp->req, pkt, ELS_IOCB_TYPE);\n\t\t\tbreak;\n\t\tcase ABTS_RECV_24XX:\n\t\t\tif (qla_ini_mode_enabled(vha)) {\n\t\t\t\tpure_item = qla24xx_copy_std_pkt(vha, pkt);\n\t\t\t\tif (!pure_item)\n\t\t\t\t\tbreak;\n\t\t\t\tqla24xx_queue_purex_item(vha, pure_item,\n\t\t\t\t\t\t\t qla24xx_process_abts);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t\t\t    IS_QLA28XX(ha)) {\n\t\t\t\t \n\t\t\t\tqlt_handle_abts_recv(vha, rsp,\n\t\t\t\t    (response_t *)pkt);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tqlt_24xx_process_atio_queue(vha, 1);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase ABTS_RESP_24XX:\n\t\tcase CTIO_TYPE7:\n\t\tcase CTIO_CRC2:\n\t\t\tqlt_response_pkt_all_vps(vha, rsp, (response_t *)pkt);\n\t\t\tbreak;\n\t\tcase PT_LS4_REQUEST:\n\t\t\tqla24xx_nvme_ls4_iocb(vha, (struct pt_ls4_request *)pkt,\n\t\t\t    rsp->req);\n\t\t\tbreak;\n\t\tcase NOTIFY_ACK_TYPE:\n\t\t\tif (pkt->handle == QLA_TGT_SKIP_HANDLE)\n\t\t\t\tqlt_response_pkt_all_vps(vha, rsp,\n\t\t\t\t    (response_t *)pkt);\n\t\t\telse\n\t\t\t\tqla24xxx_nack_iocb_entry(vha, rsp->req,\n\t\t\t\t\t(struct nack_to_isp *)pkt);\n\t\t\tbreak;\n\t\tcase MARKER_TYPE:\n\t\t\tqla_marker_iocb_entry(vha, rsp->req, (struct mrk_entry_24xx *)pkt);\n\t\t\tbreak;\n\t\tcase ABORT_IOCB_TYPE:\n\t\t\tqla24xx_abort_iocb_entry(vha, rsp->req,\n\t\t\t    (struct abort_entry_24xx *)pkt);\n\t\t\tbreak;\n\t\tcase MBX_IOCB_TYPE:\n\t\t\tqla24xx_mbx_iocb_entry(vha, rsp->req,\n\t\t\t    (struct mbx_24xx_entry *)pkt);\n\t\t\tbreak;\n\t\tcase VP_CTRL_IOCB_TYPE:\n\t\t\tqla_ctrlvp_completed(vha, rsp->req,\n\t\t\t    (struct vp_ctrl_entry_24xx *)pkt);\n\t\t\tbreak;\n\t\tcase PUREX_IOCB_TYPE:\n\t\t\tpurex_entry = (void *)pkt;\n\t\t\tswitch (purex_entry->els_frame_payload[3]) {\n\t\t\tcase ELS_RDP:\n\t\t\t\tpure_item = qla24xx_copy_std_pkt(vha, pkt);\n\t\t\t\tif (!pure_item)\n\t\t\t\t\tbreak;\n\t\t\t\tqla24xx_queue_purex_item(vha, pure_item,\n\t\t\t\t\t\t qla24xx_process_purex_rdp);\n\t\t\t\tbreak;\n\t\t\tcase ELS_FPIN:\n\t\t\t\tif (!vha->hw->flags.scm_enabled) {\n\t\t\t\t\tql_log(ql_log_warn, vha, 0x5094,\n\t\t\t\t\t       \"SCM not active for this port\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpure_item = qla27xx_copy_fpin_pkt(vha,\n\t\t\t\t\t\t\t  (void **)&pkt, &rsp);\n\t\t\t\t__update_rsp_in(is_shadow_hba, rsp, rsp_in);\n\t\t\t\tif (!pure_item)\n\t\t\t\t\tbreak;\n\t\t\t\tqla24xx_queue_purex_item(vha, pure_item,\n\t\t\t\t\t\t qla27xx_process_purex_fpin);\n\t\t\t\tbreak;\n\n\t\t\tcase ELS_AUTH_ELS:\n\t\t\t\tif (qla_chk_cont_iocb_avail(vha, rsp, (response_t *)pkt, rsp_in)) {\n\t\t\t\t\t \n\t\t\t\t\trsp->ring_ptr = (response_t *)pkt;\n\t\t\t\t\trsp->ring_index = cur_ring_index;\n\n\t\t\t\t\tql_dbg(ql_dbg_init, vha, 0x5091,\n\t\t\t\t\t    \"Defer processing ELS opcode %#x...\\n\",\n\t\t\t\t\t    purex_entry->els_frame_payload[3]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tqla24xx_auth_els(vha, (void **)&pkt, &rsp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql_log(ql_log_warn, vha, 0x509c,\n\t\t\t\t       \"Discarding ELS Request opcode 0x%x\\n\",\n\t\t\t\t       purex_entry->els_frame_payload[3]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SA_UPDATE_IOCB_TYPE:\n\t\t\tqla28xx_sa_update_iocb_entry(vha, rsp->req,\n\t\t\t\t(struct sa_update_28xx *)pkt);\n\t\t\tbreak;\n\t\tcase PT_LS4_UNSOL:\n\t\t\tp = (void *)pkt;\n\t\t\tif (qla_chk_cont_iocb_avail(vha, rsp, (response_t *)pkt, rsp_in)) {\n\t\t\t\trsp->ring_ptr = (response_t *)pkt;\n\t\t\t\trsp->ring_index = cur_ring_index;\n\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x2124,\n\t\t\t\t       \"Defer processing UNSOL LS req opcode %#x...\\n\",\n\t\t\t\t       p->payload[0]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tqla2xxx_process_purls_iocb((void **)&pkt, &rsp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tql_dbg(ql_dbg_async, vha, 0x5042,\n\t\t\t       \"Received unknown response pkt type 0x%x entry status=%x.\\n\",\n\t\t\t       pkt->entry_type, pkt->entry_status);\n\t\t\tbreak;\n\t\t}\n\t\t((response_t *)pkt)->signature = RESPONSE_PROCESSED;\n\t\twmb();\n\t}\n\n\t \n\tif (IS_P3P_TYPE(ha)) {\n\t\tstruct device_reg_82xx __iomem *reg = &ha->iobase->isp82;\n\n\t\twrt_reg_dword(&reg->rsp_q_out[0], rsp->ring_index);\n\t} else {\n\t\twrt_reg_dword(rsp->rsp_q_out, rsp->ring_index);\n\t}\n}\n\nstatic void\nqla2xxx_check_risc_status(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint32_t cnt;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tif (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn;\n\n\trval = QLA_SUCCESS;\n\twrt_reg_dword(&reg->iobase_addr, 0x7C00);\n\trd_reg_dword(&reg->iobase_addr);\n\twrt_reg_dword(&reg->iobase_window, 0x0001);\n\tfor (cnt = 10000; (rd_reg_dword(&reg->iobase_window) & BIT_0) == 0 &&\n\t    rval == QLA_SUCCESS; cnt--) {\n\t\tif (cnt) {\n\t\t\twrt_reg_dword(&reg->iobase_window, 0x0001);\n\t\t\tudelay(10);\n\t\t} else\n\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t}\n\tif (rval == QLA_SUCCESS)\n\t\tgoto next_test;\n\n\trval = QLA_SUCCESS;\n\twrt_reg_dword(&reg->iobase_window, 0x0003);\n\tfor (cnt = 100; (rd_reg_dword(&reg->iobase_window) & BIT_0) == 0 &&\n\t    rval == QLA_SUCCESS; cnt--) {\n\t\tif (cnt) {\n\t\t\twrt_reg_dword(&reg->iobase_window, 0x0003);\n\t\t\tudelay(10);\n\t\t} else\n\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t}\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done;\n\nnext_test:\n\tif (rd_reg_dword(&reg->iobase_c8) & BIT_3)\n\t\tql_log(ql_log_info, vha, 0x504c,\n\t\t    \"Additional code -- 0x55AA.\\n\");\n\ndone:\n\twrt_reg_dword(&reg->iobase_window, 0x0000);\n\trd_reg_dword(&reg->iobase_window);\n}\n\n \nirqreturn_t\nqla24xx_intr_handler(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct device_reg_24xx __iomem *reg;\n\tint\t\tstatus;\n\tunsigned long\titer;\n\tuint32_t\tstat;\n\tuint32_t\thccr;\n\tuint16_t\tmb[8];\n\tstruct rsp_que *rsp;\n\tunsigned long\tflags;\n\tbool process_atio = false;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tql_log(ql_log_info, NULL, 0x5059,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\n\tha = rsp->hw;\n\treg = &ha->iobase->isp24;\n\tstatus = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\tfor (iter = 50; iter--; ) {\n\t\tstat = rd_reg_dword(&reg->host_status);\n\t\tif (qla2x00_check_reg32_for_disconnect(vha, stat))\n\t\t\tbreak;\n\t\tif (stat & HSRX_RISC_PAUSED) {\n\t\t\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\t\t\tbreak;\n\n\t\t\thccr = rd_reg_dword(&reg->hccr);\n\n\t\t\tql_log(ql_log_warn, vha, 0x504b,\n\t\t\t    \"RISC paused -- HCCR=%x, Dumping firmware.\\n\",\n\t\t\t    hccr);\n\n\t\t\tqla2xxx_check_risc_status(vha);\n\n\t\t\tha->isp_ops->fw_dump(vha);\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tbreak;\n\t\t} else if ((stat & HSRX_RISC_INT) == 0)\n\t\t\tbreak;\n\n\t\tswitch (stat & 0xff) {\n\t\tcase INTR_ROM_MB_SUCCESS:\n\t\tcase INTR_ROM_MB_FAILED:\n\t\tcase INTR_MB_SUCCESS:\n\t\tcase INTR_MB_FAILED:\n\t\t\tqla24xx_mbx_completion(vha, MSW(stat));\n\t\t\tstatus |= MBX_INTERRUPT;\n\n\t\t\tbreak;\n\t\tcase INTR_ASYNC_EVENT:\n\t\t\tmb[0] = MSW(stat);\n\t\t\tmb[1] = rd_reg_word(&reg->mailbox1);\n\t\t\tmb[2] = rd_reg_word(&reg->mailbox2);\n\t\t\tmb[3] = rd_reg_word(&reg->mailbox3);\n\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\tbreak;\n\t\tcase INTR_RSP_QUE_UPDATE:\n\t\tcase INTR_RSP_QUE_UPDATE_83XX:\n\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\t\tbreak;\n\t\tcase INTR_ATIO_QUE_UPDATE_27XX:\n\t\tcase INTR_ATIO_QUE_UPDATE:\n\t\t\tprocess_atio = true;\n\t\t\tbreak;\n\t\tcase INTR_ATIO_RSP_QUE_UPDATE:\n\t\t\tprocess_atio = true;\n\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_dbg(ql_dbg_async, vha, 0x504f,\n\t\t\t    \"Unrecognized interrupt type (%d).\\n\", stat * 0xff);\n\t\t\tbreak;\n\t\t}\n\t\twrt_reg_dword(&reg->hccr, HCCRX_CLR_RISC_INT);\n\t\trd_reg_dword_relaxed(&reg->hccr);\n\t\tif (unlikely(IS_QLA83XX(ha) && (ha->pdev->revision == 1)))\n\t\t\tndelay(3500);\n\t}\n\tqla2x00_handle_mbx_completion(ha, status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (process_atio) {\n\t\tspin_lock_irqsave(&ha->tgt.atio_lock, flags);\n\t\tqlt_24xx_process_atio_queue(vha, 0);\n\t\tspin_unlock_irqrestore(&ha->tgt.atio_lock, flags);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nqla24xx_msix_rsp_q(int irq, void *dev_id)\n{\n\tstruct qla_hw_data *ha;\n\tstruct rsp_que *rsp;\n\tstruct device_reg_24xx __iomem *reg;\n\tstruct scsi_qla_host *vha;\n\tunsigned long flags;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tql_log(ql_log_info, NULL, 0x505a,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\tha = rsp->hw;\n\treg = &ha->iobase->isp24;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\tvha = pci_get_drvdata(ha->pdev);\n\tqla24xx_process_response_queue(vha, rsp);\n\tif (!ha->flags.disable_msix_handshake) {\n\t\twrt_reg_dword(&reg->hccr, HCCRX_CLR_RISC_INT);\n\t\trd_reg_dword_relaxed(&reg->hccr);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nqla24xx_msix_default(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct rsp_que *rsp;\n\tstruct device_reg_24xx __iomem *reg;\n\tint\t\tstatus;\n\tuint32_t\tstat;\n\tuint32_t\thccr;\n\tuint16_t\tmb[8];\n\tunsigned long flags;\n\tbool process_atio = false;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tql_log(ql_log_info, NULL, 0x505c,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\tha = rsp->hw;\n\treg = &ha->iobase->isp24;\n\tstatus = 0;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\tdo {\n\t\tstat = rd_reg_dword(&reg->host_status);\n\t\tif (qla2x00_check_reg32_for_disconnect(vha, stat))\n\t\t\tbreak;\n\t\tif (stat & HSRX_RISC_PAUSED) {\n\t\t\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\t\t\tbreak;\n\n\t\t\thccr = rd_reg_dword(&reg->hccr);\n\n\t\t\tql_log(ql_log_info, vha, 0x5050,\n\t\t\t    \"RISC paused -- HCCR=%x, Dumping firmware.\\n\",\n\t\t\t    hccr);\n\n\t\t\tqla2xxx_check_risc_status(vha);\n\t\t\tvha->hw_err_cnt++;\n\n\t\t\tha->isp_ops->fw_dump(vha);\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tbreak;\n\t\t} else if ((stat & HSRX_RISC_INT) == 0)\n\t\t\tbreak;\n\n\t\tswitch (stat & 0xff) {\n\t\tcase INTR_ROM_MB_SUCCESS:\n\t\tcase INTR_ROM_MB_FAILED:\n\t\tcase INTR_MB_SUCCESS:\n\t\tcase INTR_MB_FAILED:\n\t\t\tqla24xx_mbx_completion(vha, MSW(stat));\n\t\t\tstatus |= MBX_INTERRUPT;\n\n\t\t\tbreak;\n\t\tcase INTR_ASYNC_EVENT:\n\t\t\tmb[0] = MSW(stat);\n\t\t\tmb[1] = rd_reg_word(&reg->mailbox1);\n\t\t\tmb[2] = rd_reg_word(&reg->mailbox2);\n\t\t\tmb[3] = rd_reg_word(&reg->mailbox3);\n\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\tbreak;\n\t\tcase INTR_RSP_QUE_UPDATE:\n\t\tcase INTR_RSP_QUE_UPDATE_83XX:\n\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\t\tbreak;\n\t\tcase INTR_ATIO_QUE_UPDATE_27XX:\n\t\tcase INTR_ATIO_QUE_UPDATE:\n\t\t\tprocess_atio = true;\n\t\t\tbreak;\n\t\tcase INTR_ATIO_RSP_QUE_UPDATE:\n\t\t\tprocess_atio = true;\n\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5051,\n\t\t\t    \"Unrecognized interrupt type (%d).\\n\", stat & 0xff);\n\t\t\tbreak;\n\t\t}\n\t\twrt_reg_dword(&reg->hccr, HCCRX_CLR_RISC_INT);\n\t} while (0);\n\tqla2x00_handle_mbx_completion(ha, status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (process_atio) {\n\t\tspin_lock_irqsave(&ha->tgt.atio_lock, flags);\n\t\tqlt_24xx_process_atio_queue(vha, 0);\n\t\tspin_unlock_irqrestore(&ha->tgt.atio_lock, flags);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t\nqla2xxx_msix_rsp_q(int irq, void *dev_id)\n{\n\tstruct qla_hw_data *ha;\n\tstruct qla_qpair *qpair;\n\n\tqpair = dev_id;\n\tif (!qpair) {\n\t\tql_log(ql_log_info, NULL, 0x505b,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\tha = qpair->hw;\n\n\tqueue_work(ha->wq, &qpair->q_work);\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t\nqla2xxx_msix_rsp_q_hs(int irq, void *dev_id)\n{\n\tstruct qla_hw_data *ha;\n\tstruct qla_qpair *qpair;\n\tstruct device_reg_24xx __iomem *reg;\n\tunsigned long flags;\n\n\tqpair = dev_id;\n\tif (!qpair) {\n\t\tql_log(ql_log_info, NULL, 0x505b,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\tha = qpair->hw;\n\n\treg = &ha->iobase->isp24;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twrt_reg_dword(&reg->hccr, HCCRX_CLR_RISC_INT);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tqueue_work(ha->wq, &qpair->q_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstruct qla_init_msix_entry {\n\tconst char *name;\n\tirq_handler_t handler;\n};\n\nstatic const struct qla_init_msix_entry msix_entries[] = {\n\t{ \"default\", qla24xx_msix_default },\n\t{ \"rsp_q\", qla24xx_msix_rsp_q },\n\t{ \"atio_q\", qla83xx_msix_atio_q },\n\t{ \"qpair_multiq\", qla2xxx_msix_rsp_q },\n\t{ \"qpair_multiq_hs\", qla2xxx_msix_rsp_q_hs },\n};\n\nstatic const struct qla_init_msix_entry qla82xx_msix_entries[] = {\n\t{ \"qla2xxx (default)\", qla82xx_msix_default },\n\t{ \"qla2xxx (rsp_q)\", qla82xx_msix_rsp_q },\n};\n\nstatic int\nqla24xx_enable_msix(struct qla_hw_data *ha, struct rsp_que *rsp)\n{\n\tint i, ret;\n\tstruct qla_msix_entry *qentry;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\tint min_vecs = QLA_BASE_VECTORS;\n\tstruct irq_affinity desc = {\n\t\t.pre_vectors = QLA_BASE_VECTORS,\n\t};\n\n\tif (QLA_TGT_MODE_ENABLED() && (ql2xenablemsix != 0) &&\n\t    IS_ATIO_MSIX_CAPABLE(ha)) {\n\t\tdesc.pre_vectors++;\n\t\tmin_vecs++;\n\t}\n\n\tif (USER_CTRL_IRQ(ha) || !ha->mqiobase) {\n\t\t \n\t\tret = pci_alloc_irq_vectors(ha->pdev, min_vecs,\n\t\t    min((u16)ha->msix_count, (u16)(num_online_cpus() + min_vecs)),\n\t\t    PCI_IRQ_MSIX);\n\t} else\n\t\tret = pci_alloc_irq_vectors_affinity(ha->pdev, min_vecs,\n\t\t    min((u16)ha->msix_count, (u16)(num_online_cpus() + min_vecs)),\n\t\t    PCI_IRQ_MSIX | PCI_IRQ_AFFINITY,\n\t\t    &desc);\n\n\tif (ret < 0) {\n\t\tql_log(ql_log_fatal, vha, 0x00c7,\n\t\t    \"MSI-X: Failed to enable support, \"\n\t\t    \"giving   up -- %d/%d.\\n\",\n\t\t    ha->msix_count, ret);\n\t\tgoto msix_out;\n\t} else if (ret < ha->msix_count) {\n\t\tql_log(ql_log_info, vha, 0x00c6,\n\t\t    \"MSI-X: Using %d vectors\\n\", ret);\n\t\tha->msix_count = ret;\n\t\t \n\t\tif (ha->mqiobase && (ql2xmqsupport || ql2xnvmeenable)) {\n\t\t\tha->max_req_queues = ha->msix_count - 1;\n\n\t\t\t \n\t\t\tif (QLA_TGT_MODE_ENABLED())\n\t\t\t\tha->max_req_queues--;\n\n\t\t\tha->max_rsp_queues = ha->max_req_queues;\n\n\t\t\tha->max_qpairs = ha->max_req_queues - 1;\n\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0190,\n\t\t\t    \"Adjusted Max no of queues pairs: %d.\\n\", ha->max_qpairs);\n\t\t}\n\t}\n\tvha->irq_offset = desc.pre_vectors;\n\tha->msix_entries = kcalloc(ha->msix_count,\n\t\t\t\t   sizeof(struct qla_msix_entry),\n\t\t\t\t   GFP_KERNEL);\n\tif (!ha->msix_entries) {\n\t\tql_log(ql_log_fatal, vha, 0x00c8,\n\t\t    \"Failed to allocate memory for ha->msix_entries.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_irqs;\n\t}\n\tha->flags.msix_enabled = 1;\n\n\tfor (i = 0; i < ha->msix_count; i++) {\n\t\tqentry = &ha->msix_entries[i];\n\t\tqentry->vector = pci_irq_vector(ha->pdev, i);\n\t\tqentry->vector_base0 = i;\n\t\tqentry->entry = i;\n\t\tqentry->have_irq = 0;\n\t\tqentry->in_use = 0;\n\t\tqentry->handle = NULL;\n\t}\n\n\t \n\tfor (i = 0; i < QLA_BASE_VECTORS; i++) {\n\t\tqentry = &ha->msix_entries[i];\n\t\tqentry->handle = rsp;\n\t\trsp->msix = qentry;\n\t\tscnprintf(qentry->name, sizeof(qentry->name),\n\t\t    \"qla2xxx%lu_%s\", vha->host_no, msix_entries[i].name);\n\t\tif (IS_P3P_TYPE(ha))\n\t\t\tret = request_irq(qentry->vector,\n\t\t\t\tqla82xx_msix_entries[i].handler,\n\t\t\t\t0, qla82xx_msix_entries[i].name, rsp);\n\t\telse\n\t\t\tret = request_irq(qentry->vector,\n\t\t\t\tmsix_entries[i].handler,\n\t\t\t\t0, qentry->name, rsp);\n\t\tif (ret)\n\t\t\tgoto msix_register_fail;\n\t\tqentry->have_irq = 1;\n\t\tqentry->in_use = 1;\n\t}\n\n\t \n\tif (QLA_TGT_MODE_ENABLED() && (ql2xenablemsix != 0) &&\n\t    IS_ATIO_MSIX_CAPABLE(ha)) {\n\t\tqentry = &ha->msix_entries[QLA_ATIO_VECTOR];\n\t\trsp->msix = qentry;\n\t\tqentry->handle = rsp;\n\t\tscnprintf(qentry->name, sizeof(qentry->name),\n\t\t    \"qla2xxx%lu_%s\", vha->host_no,\n\t\t    msix_entries[QLA_ATIO_VECTOR].name);\n\t\tqentry->in_use = 1;\n\t\tret = request_irq(qentry->vector,\n\t\t\tmsix_entries[QLA_ATIO_VECTOR].handler,\n\t\t\t0, qentry->name, rsp);\n\t\tqentry->have_irq = 1;\n\t}\n\nmsix_register_fail:\n\tif (ret) {\n\t\tql_log(ql_log_fatal, vha, 0x00cb,\n\t\t    \"MSI-X: unable to register handler -- %x/%d.\\n\",\n\t\t    qentry->vector, ret);\n\t\tqla2x00_free_irqs(vha);\n\t\tha->mqenable = 0;\n\t\tgoto msix_out;\n\t}\n\n\t \n\tif (IS_MQUE_CAPABLE(ha) &&\n\t    (ha->msixbase && ha->mqiobase && ha->max_qpairs))\n\t\tha->mqenable = 1;\n\telse\n\t\tha->mqenable = 0;\n\n\tql_dbg(ql_dbg_multiq, vha, 0xc005,\n\t    \"mqiobase=%p, max_rsp_queues=%d, max_req_queues=%d.\\n\",\n\t    ha->mqiobase, ha->max_rsp_queues, ha->max_req_queues);\n\tql_dbg(ql_dbg_init, vha, 0x0055,\n\t    \"mqiobase=%p, max_rsp_queues=%d, max_req_queues=%d.\\n\",\n\t    ha->mqiobase, ha->max_rsp_queues, ha->max_req_queues);\n\nmsix_out:\n\treturn ret;\n\nfree_irqs:\n\tpci_free_irq_vectors(ha->pdev);\n\tgoto msix_out;\n}\n\nint\nqla2x00_request_irqs(struct qla_hw_data *ha, struct rsp_que *rsp)\n{\n\tint ret = QLA_FUNCTION_FAILED;\n\tdevice_reg_t *reg = ha->iobase;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\t \n\tif (ql2xenablemsix == 0 || (!IS_QLA2432(ha) && !IS_QLA2532(ha) &&\n\t    !IS_QLA8432(ha) && !IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha) &&\n\t    !IS_QLAFX00(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha)))\n\t\tgoto skip_msi;\n\n\tif (ql2xenablemsix == 2)\n\t\tgoto skip_msix;\n\n\tif (ha->pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&\n\t\t(ha->pdev->subsystem_device == 0x7040 ||\n\t\tha->pdev->subsystem_device == 0x7041 ||\n\t\tha->pdev->subsystem_device == 0x1705)) {\n\t\tql_log(ql_log_warn, vha, 0x0034,\n\t\t    \"MSI-X: Unsupported ISP 2432 SSVID/SSDID (0x%X,0x%X).\\n\",\n\t\t\tha->pdev->subsystem_vendor,\n\t\t\tha->pdev->subsystem_device);\n\t\tgoto skip_msi;\n\t}\n\n\tif (IS_QLA2432(ha) && (ha->pdev->revision < QLA_MSIX_CHIP_REV_24XX)) {\n\t\tql_log(ql_log_warn, vha, 0x0035,\n\t\t    \"MSI-X; Unsupported ISP2432 (0x%X, 0x%X).\\n\",\n\t\t    ha->pdev->revision, QLA_MSIX_CHIP_REV_24XX);\n\t\tgoto skip_msix;\n\t}\n\n\tret = qla24xx_enable_msix(ha, rsp);\n\tif (!ret) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0036,\n\t\t    \"MSI-X: Enabled (0x%X, 0x%X).\\n\",\n\t\t    ha->chip_revision, ha->fw_attributes);\n\t\tgoto clear_risc_ints;\n\t}\n\nskip_msix:\n\n\tql_log(ql_log_info, vha, 0x0037,\n\t    \"Falling back-to MSI mode -- ret=%d.\\n\", ret);\n\n\tif (!IS_QLA24XX(ha) && !IS_QLA2532(ha) && !IS_QLA8432(ha) &&\n\t    !IS_QLA8001(ha) && !IS_P3P_TYPE(ha) && !IS_QLAFX00(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\tgoto skip_msi;\n\n\tret = pci_alloc_irq_vectors(ha->pdev, 1, 1, PCI_IRQ_MSI);\n\tif (ret > 0) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0038,\n\t\t    \"MSI: Enabled.\\n\");\n\t\tha->flags.msi_enabled = 1;\n\t} else\n\t\tql_log(ql_log_warn, vha, 0x0039,\n\t\t    \"Falling back-to INTa mode -- ret=%d.\\n\", ret);\nskip_msi:\n\n\t \n\tif (!ha->flags.msi_enabled && IS_QLA82XX(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tret = request_irq(ha->pdev->irq, ha->isp_ops->intr_handler,\n\t    ha->flags.msi_enabled ? 0 : IRQF_SHARED,\n\t    QLA2XXX_DRIVER_NAME, rsp);\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0x003a,\n\t\t    \"Failed to reserve interrupt %d already in use.\\n\",\n\t\t    ha->pdev->irq);\n\t\tgoto fail;\n\t} else if (!ha->flags.msi_enabled) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0125,\n\t\t    \"INTa mode: Enabled.\\n\");\n\t\tha->flags.mr_intr_valid = 1;\n\t\t \n\t\tha->max_qpairs = 0;\n\t}\n\nclear_risc_ints:\n\tif (IS_FWI2_CAPABLE(ha) || IS_QLAFX00(ha))\n\t\tgoto fail;\n\n\tspin_lock_irq(&ha->hardware_lock);\n\twrt_reg_word(&reg->isp.semaphore, 0);\n\tspin_unlock_irq(&ha->hardware_lock);\n\nfail:\n\treturn ret;\n}\n\nvoid\nqla2x00_free_irqs(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct rsp_que *rsp;\n\tstruct qla_msix_entry *qentry;\n\tint i;\n\n\t \n\tif (!ha->rsp_q_map || !ha->rsp_q_map[0])\n\t\tgoto free_irqs;\n\trsp = ha->rsp_q_map[0];\n\n\tif (ha->flags.msix_enabled) {\n\t\tfor (i = 0; i < ha->msix_count; i++) {\n\t\t\tqentry = &ha->msix_entries[i];\n\t\t\tif (qentry->have_irq) {\n\t\t\t\tirq_set_affinity_notifier(qentry->vector, NULL);\n\t\t\t\tfree_irq(pci_irq_vector(ha->pdev, i), qentry->handle);\n\t\t\t}\n\t\t}\n\t\tkfree(ha->msix_entries);\n\t\tha->msix_entries = NULL;\n\t\tha->flags.msix_enabled = 0;\n\t\tql_dbg(ql_dbg_init, vha, 0x0042,\n\t\t\t\"Disabled MSI-X.\\n\");\n\t} else {\n\t\tfree_irq(pci_irq_vector(ha->pdev, 0), rsp);\n\t}\n\nfree_irqs:\n\tpci_free_irq_vectors(ha->pdev);\n}\n\nint qla25xx_request_irq(struct qla_hw_data *ha, struct qla_qpair *qpair,\n\tstruct qla_msix_entry *msix, int vector_type)\n{\n\tconst struct qla_init_msix_entry *intr = &msix_entries[vector_type];\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\tint ret;\n\n\tscnprintf(msix->name, sizeof(msix->name),\n\t    \"qla2xxx%lu_qpair%d\", vha->host_no, qpair->id);\n\tret = request_irq(msix->vector, intr->handler, 0, msix->name, qpair);\n\tif (ret) {\n\t\tql_log(ql_log_fatal, vha, 0x00e6,\n\t\t    \"MSI-X: Unable to register handler -- %x/%d.\\n\",\n\t\t    msix->vector, ret);\n\t\treturn ret;\n\t}\n\tmsix->have_irq = 1;\n\tmsix->handle = qpair;\n\tqla_mapq_init_qp_cpu_map(ha, msix, qpair);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}