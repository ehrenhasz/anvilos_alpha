{
  "module_name": "qla_target.h",
  "hash_id": "8d1cecf34d6cde069ffa2a7cfb19e8ebc1fc03fd6ed245d71e4116ac5cf0c81a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_target.h",
  "human_readable_source": " \n \n \n\n#ifndef __QLA_TARGET_H\n#define __QLA_TARGET_H\n\n#include \"qla_def.h\"\n#include \"qla_dsd.h\"\n\n \n#define QLA2XXX_TARGET_MAGIC\t269\n\n \n#define QLA2XXX_INITIATOR_MAGIC   57222\n\n#define QLA2XXX_INI_MODE_STR_EXCLUSIVE\t\"exclusive\"\n#define QLA2XXX_INI_MODE_STR_DISABLED\t\"disabled\"\n#define QLA2XXX_INI_MODE_STR_ENABLED\t\"enabled\"\n#define QLA2XXX_INI_MODE_STR_DUAL\t\t\"dual\"\n\n#define QLA2XXX_INI_MODE_EXCLUSIVE\t0\n#define QLA2XXX_INI_MODE_DISABLED\t1\n#define QLA2XXX_INI_MODE_ENABLED\t2\n#define QLA2XXX_INI_MODE_DUAL\t3\n\n#define QLA2XXX_COMMAND_COUNT_INIT\t250\n#define QLA2XXX_IMMED_NOTIFY_COUNT_INIT 250\n\n \n#define CTIO_COMPLETION_HANDLE_MARK\tBIT_29\n#if (CTIO_COMPLETION_HANDLE_MARK <= DEFAULT_OUTSTANDING_COMMANDS)\n#error \"CTIO_COMPLETION_HANDLE_MARK not larger than \"\n\t\"DEFAULT_OUTSTANDING_COMMANDS\"\n#endif\n#define HANDLE_IS_CTIO_COMP(h) (h & CTIO_COMPLETION_HANDLE_MARK)\n\n \n#define CTIO_INTERMEDIATE_HANDLE_MARK\tBIT_30\n#define QLA_TGT_NULL_HANDLE\t0\n\n#define QLA_TGT_HANDLE_MASK  0xF0000000\n#define QLA_QPID_HANDLE_MASK 0x00FF0000  \n#define QLA_CMD_HANDLE_MASK  0x0000FFFF\n#define QLA_TGT_SKIP_HANDLE\t(0xFFFFFFFF & ~QLA_TGT_HANDLE_MASK)\n\n#define QLA_QPID_HANDLE_SHIFT 16\n#define GET_QID(_h) ((_h & QLA_QPID_HANDLE_MASK) >> QLA_QPID_HANDLE_SHIFT)\n\n\n#ifndef OF_SS_MODE_0\n \n#define OF_SS_MODE_0        0\n#define OF_SS_MODE_1        1\n#define OF_SS_MODE_2        2\n#define OF_SS_MODE_3        3\n\n#define OF_EXPL_CONF        BIT_5        \n#define OF_DATA_IN          BIT_6        \n\t\t\t\t\t \n#define OF_DATA_OUT         BIT_7        \n\t\t\t\t\t \n#define OF_NO_DATA          (BIT_7 | BIT_6)\n#define OF_INC_RC           BIT_8        \n#define OF_FAST_POST        BIT_9        \n#define OF_CONF_REQ         BIT_13       \n#define OF_TERM_EXCH        BIT_14       \n#define OF_SSTS             BIT_15       \n#endif\n\n#ifndef QLA_TGT_DATASEGS_PER_CMD32\n#define QLA_TGT_DATASEGS_PER_CMD32\t3\n#define QLA_TGT_DATASEGS_PER_CONT32\t7\n#define QLA_TGT_MAX_SG32(ql) \\\n\t(((ql) > 0) ? (QLA_TGT_DATASEGS_PER_CMD32 + \\\n\t\tQLA_TGT_DATASEGS_PER_CONT32*((ql) - 1)) : 0)\n\n#define QLA_TGT_DATASEGS_PER_CMD64\t2\n#define QLA_TGT_DATASEGS_PER_CONT64\t5\n#define QLA_TGT_MAX_SG64(ql) \\\n\t(((ql) > 0) ? (QLA_TGT_DATASEGS_PER_CMD64 + \\\n\t\tQLA_TGT_DATASEGS_PER_CONT64*((ql) - 1)) : 0)\n#endif\n\n#ifndef QLA_TGT_DATASEGS_PER_CMD_24XX\n#define QLA_TGT_DATASEGS_PER_CMD_24XX\t1\n#define QLA_TGT_DATASEGS_PER_CONT_24XX\t5\n#define QLA_TGT_MAX_SG_24XX(ql) \\\n\t(min(1270, ((ql) > 0) ? (QLA_TGT_DATASEGS_PER_CMD_24XX + \\\n\t\tQLA_TGT_DATASEGS_PER_CONT_24XX*((ql) - 1)) : 0))\n#endif\n\n#define GET_TARGET_ID(ha, iocb) ((HAS_EXTENDED_IDS(ha))\t\t\t\\\n\t\t\t ? le16_to_cpu((iocb)->u.isp2x.target.extended)\t\\\n\t\t\t : (uint16_t)(iocb)->u.isp2x.target.id.standard)\n\n#ifndef NOTIFY_ACK_TYPE\n#define NOTIFY_ACK_TYPE 0x0E\t   \n \nstruct nack_to_isp {\n\tuint8_t\t entry_type;\t\t     \n\tuint8_t\t entry_count;\t\t     \n\tuint8_t\t sys_define;\t\t     \n\tuint8_t\t entry_status;\t\t     \n\tunion {\n\t\tstruct {\n\t\t\t__le32\tsys_define_2;  \n\t\t\ttarget_id_t target;\n\t\t\tuint8_t\t target_id;\n\t\t\tuint8_t\t reserved_1;\n\t\t\t__le16\tflags;\n\t\t\t__le16\tresp_code;\n\t\t\t__le16\tstatus;\n\t\t\t__le16\ttask_flags;\n\t\t\t__le16\tseq_id;\n\t\t\t__le16\tsrr_rx_id;\n\t\t\t__le32\tsrr_rel_offs;\n\t\t\t__le16\tsrr_ui;\n\t\t\t__le16\tsrr_flags;\n\t\t\t__le16\tsrr_reject_code;\n\t\t\tuint8_t  srr_reject_vendor_uniq;\n\t\t\tuint8_t  srr_reject_code_expl;\n\t\t\tuint8_t  reserved_2[24];\n\t\t} isp2x;\n\t\tstruct {\n\t\t\tuint32_t handle;\n\t\t\t__le16\tnport_handle;\n\t\t\tuint16_t reserved_1;\n\t\t\t__le16\tflags;\n\t\t\t__le16\tsrr_rx_id;\n\t\t\t__le16\tstatus;\n\t\t\tuint8_t  status_subcode;\n\t\t\tuint8_t  fw_handle;\n\t\t\t__le32\texchange_address;\n\t\t\t__le32\tsrr_rel_offs;\n\t\t\t__le16\tsrr_ui;\n\t\t\t__le16\tsrr_flags;\n\t\t\tuint8_t  reserved_4[19];\n\t\t\tuint8_t  vp_index;\n\t\t\tuint8_t  srr_reject_vendor_uniq;\n\t\t\tuint8_t  srr_reject_code_expl;\n\t\t\tuint8_t  srr_reject_code;\n\t\t\tuint8_t  reserved_5[5];\n\t\t} isp24;\n\t} u;\n\tuint8_t  reserved[2];\n\t__le16\tox_id;\n} __packed;\n#define NOTIFY_ACK_FLAGS_FCSP\t\tBIT_5\n#define NOTIFY_ACK_FLAGS_TERMINATE\tBIT_3\n#define NOTIFY_ACK_SRR_FLAGS_ACCEPT\t0\n#define NOTIFY_ACK_SRR_FLAGS_REJECT\t1\n\n#define NOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM\t0x9\n\n#define NOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL\t\t0\n#define NOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_UNABLE_TO_SUPPLY_DATA\t0x2a\n\n#define NOTIFY_ACK_SUCCESS      0x01\n#endif\n\n#ifndef ACCEPT_TGT_IO_TYPE\n#define ACCEPT_TGT_IO_TYPE 0x16  \n#endif\n\n#ifndef CONTINUE_TGT_IO_TYPE\n#define CONTINUE_TGT_IO_TYPE 0x17\n \nstruct ctio_to_2xxx {\n\tuint8_t\t entry_type;\t\t \n\tuint8_t\t entry_count;\t\t \n\tuint8_t\t sys_define;\t\t \n\tuint8_t\t entry_status;\t\t \n\tuint32_t handle;\t\t \n\ttarget_id_t target;\n\t__le16\trx_id;\n\t__le16\tflags;\n\t__le16\tstatus;\n\t__le16\ttimeout;\t\t \n\t__le16\tdseg_count;\t\t \n\t__le32\trelative_offset;\n\t__le32\tresidual;\n\t__le16\treserved_1[3];\n\t__le16\tscsi_status;\n\t__le32\ttransfer_length;\n\tstruct dsd32 dsd[3];\n} __packed;\n#define ATIO_PATH_INVALID       0x07\n#define ATIO_CANT_PROV_CAP      0x16\n#define ATIO_CDB_VALID          0x3D\n\n#define ATIO_EXEC_READ          BIT_1\n#define ATIO_EXEC_WRITE         BIT_0\n#endif\n\n#ifndef CTIO_A64_TYPE\n#define CTIO_A64_TYPE 0x1F\n#define CTIO_SUCCESS\t\t\t0x01\n#define CTIO_ABORTED\t\t\t0x02\n#define CTIO_INVALID_RX_ID\t\t0x08\n#define CTIO_TIMEOUT\t\t\t0x0B\n#define CTIO_DIF_ERROR\t\t\t0x0C      \n#define CTIO_LIP_RESET\t\t\t0x0E\n#define CTIO_TARGET_RESET\t\t0x17\n#define CTIO_PORT_UNAVAILABLE\t\t0x28\n#define CTIO_PORT_LOGGED_OUT\t\t0x29\n#define CTIO_PORT_CONF_CHANGED\t\t0x2A\n#define CTIO_SRR_RECEIVED\t\t0x45\n#define CTIO_FAST_AUTH_ERR\t\t0x63\n#define CTIO_FAST_INCOMP_PAD_LEN\t0x65\n#define CTIO_FAST_INVALID_REQ\t\t0x66\n#define CTIO_FAST_SPI_ERR\t\t0x67\n#endif\n\n#ifndef CTIO_RET_TYPE\n#define CTIO_RET_TYPE\t0x17\t\t \n#define ATIO_TYPE7 0x06  \n#endif\n\nstruct fcp_hdr {\n\tuint8_t  r_ctl;\n\tbe_id_t  d_id;\n\tuint8_t  cs_ctl;\n\tbe_id_t  s_id;\n\tuint8_t  type;\n\tuint8_t  f_ctl[3];\n\tuint8_t  seq_id;\n\tuint8_t  df_ctl;\n\tuint16_t seq_cnt;\n\t__be16   ox_id;\n\tuint16_t rx_id;\n\t__le32\tparameter;\n};\n\nstruct fcp_hdr_le {\n\tle_id_t  d_id;\n\tuint8_t  r_ctl;\n\tle_id_t  s_id;\n\tuint8_t  cs_ctl;\n\tuint8_t  f_ctl[3];\n\tuint8_t  type;\n\t__le16\tseq_cnt;\n\tuint8_t  df_ctl;\n\tuint8_t  seq_id;\n\t__le16\trx_id;\n\t__le16\tox_id;\n\t__le32\tparameter;\n};\n\n#define F_CTL_EXCH_CONTEXT_RESP\tBIT_23\n#define F_CTL_SEQ_CONTEXT_RESIP\tBIT_22\n#define F_CTL_LAST_SEQ\t\tBIT_20\n#define F_CTL_END_SEQ\t\tBIT_19\n#define F_CTL_SEQ_INITIATIVE\tBIT_16\n\n#define R_CTL_BASIC_LINK_SERV\t0x80\n#define R_CTL_B_ACC\t\t0x4\n#define R_CTL_B_RJT\t\t0x5\n\nstruct atio7_fcp_cmnd {\n\tuint64_t lun;\n\tuint8_t  cmnd_ref;\n\tuint8_t  task_attr:3;\n\tuint8_t  reserved:5;\n\tuint8_t  task_mgmt_flags;\n#define FCP_CMND_TASK_MGMT_CLEAR_ACA\t\t6\n#define FCP_CMND_TASK_MGMT_TARGET_RESET\t\t5\n#define FCP_CMND_TASK_MGMT_LU_RESET\t\t4\n#define FCP_CMND_TASK_MGMT_CLEAR_TASK_SET\t2\n#define FCP_CMND_TASK_MGMT_ABORT_TASK_SET\t1\n\tuint8_t  wrdata:1;\n\tuint8_t  rddata:1;\n\tuint8_t  add_cdb_len:6;\n\tuint8_t  cdb[16];\n\t \n\tuint8_t  add_cdb[4];\n\t \n} __packed;\n\n \nstruct atio_from_isp {\n\tunion {\n\t\tstruct {\n\t\t\t__le16\tentry_hdr;\n\t\t\tuint8_t  sys_define;    \n\t\t\tuint8_t  entry_status;  \n\t\t\t__le32\tsys_define_2;  \n\t\t\ttarget_id_t target;\n\t\t\t__le16\trx_id;\n\t\t\t__le16\tflags;\n\t\t\t__le16\tstatus;\n\t\t\tuint8_t  command_ref;\n\t\t\tuint8_t  task_codes;\n\t\t\tuint8_t  task_flags;\n\t\t\tuint8_t  execution_codes;\n\t\t\tuint8_t  cdb[MAX_CMDSZ];\n\t\t\t__le32\tdata_length;\n\t\t\t__le16\tlun;\n\t\t\tuint8_t  initiator_port_name[WWN_SIZE];  \n\t\t\t__le16\treserved_32[6];\n\t\t\t__le16\tox_id;\n\t\t} isp2x;\n\t\tstruct {\n\t\t\t__le16\tentry_hdr;\n\t\t\tuint8_t  fcp_cmnd_len_low;\n\t\t\tuint8_t  fcp_cmnd_len_high:4;\n\t\t\tuint8_t  attr:4;\n\t\t\t__le32\texchange_addr;\n#define ATIO_EXCHANGE_ADDRESS_UNKNOWN\t0xFFFFFFFF\n\t\t\tstruct fcp_hdr fcp_hdr;\n\t\t\tstruct atio7_fcp_cmnd fcp_cmnd;\n\t\t} isp24;\n\t\tstruct {\n\t\t\tuint8_t  entry_type;\t \n\t\t\tuint8_t  entry_count;\t \n\t\t\t__le16\t attr_n_length;\n#define FCP_CMD_LENGTH_MASK 0x0fff\n#define FCP_CMD_LENGTH_MIN  0x38\n\t\t\tuint8_t  data[56];\n\t\t\t__le32\tsignature;\n#define ATIO_PROCESSED 0xDEADDEAD\t\t \n\t\t} raw;\n\t} u;\n} __packed;\n\nstatic inline int fcpcmd_is_corrupted(struct atio *atio)\n{\n\tif (atio->entry_type == ATIO_TYPE7 &&\n\t    ((le16_to_cpu(atio->attr_n_length) & FCP_CMD_LENGTH_MASK) <\n\t     FCP_CMD_LENGTH_MIN))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic inline void adjust_corrupted_atio(struct atio_from_isp *atio)\n{\n\tatio->u.raw.attr_n_length = cpu_to_le16(FCP_CMD_LENGTH_MIN);\n\tatio->u.isp24.fcp_cmnd.add_cdb_len = 0;\n}\n\nstatic inline int get_datalen_for_atio(struct atio_from_isp *atio)\n{\n\tint len = atio->u.isp24.fcp_cmnd.add_cdb_len;\n\n\treturn get_unaligned_be32(&atio->u.isp24.fcp_cmnd.add_cdb[len * 4]);\n}\n\n#define CTIO_TYPE7 0x12  \n\n \n\nstruct ctio7_to_24xx {\n\tuint8_t\t entry_type;\t\t     \n\tuint8_t\t entry_count;\t\t     \n\tuint8_t\t sys_define;\t\t     \n\tuint8_t\t entry_status;\t\t     \n\tuint32_t handle;\t\t     \n\t__le16\tnport_handle;\n#define CTIO7_NHANDLE_UNRECOGNIZED\t0xFFFF\n\t__le16\ttimeout;\n\t__le16\tdseg_count;\t\t     \n\tuint8_t  vp_index;\n\tuint8_t  add_flags;\n\tle_id_t  initiator_id;\n\tuint8_t  reserved;\n\t__le32\texchange_addr;\n\tunion {\n\t\tstruct {\n\t\t\t__le16\treserved1;\n\t\t\t__le16 flags;\n\t\t\tunion {\n\t\t\t\t__le32\tresidual;\n\t\t\t\tstruct {\n\t\t\t\t\tuint8_t rsvd1;\n\t\t\t\t\tuint8_t edif_flags;\n#define EF_EN_EDIF\tBIT_0\n#define EF_NEW_SA\tBIT_1\n\t\t\t\t\tuint16_t rsvd2;\n\t\t\t\t};\n\t\t\t};\n\t\t\t__le16 ox_id;\n\t\t\t__le16\tscsi_status;\n\t\t\t__le32\trelative_offset;\n\t\t\t__le32\treserved2;\n\t\t\t__le32\ttransfer_length;\n\t\t\t__le32\treserved3;\n\t\t\tstruct dsd64 dsd;\n\t\t} status0;\n\t\tstruct {\n\t\t\t__le16\tsense_length;\n\t\t\t__le16 flags;\n\t\t\t__le32\tresidual;\n\t\t\t__le16 ox_id;\n\t\t\t__le16\tscsi_status;\n\t\t\t__le16\tresponse_len;\n\t\t\t__le16\treserved;\n\t\t\tuint8_t sense_data[24];\n\t\t} status1;\n\t} u;\n} __packed;\n\n \nstruct ctio7_from_24xx {\n\tuint8_t\t entry_type;\t\t     \n\tuint8_t\t entry_count;\t\t     \n\tuint8_t\t sys_define;\t\t     \n\tuint8_t\t entry_status;\t\t     \n\tuint32_t handle;\t\t     \n\t__le16\tstatus;\n\t__le16\ttimeout;\n\t__le16\tdseg_count;\t\t     \n\tuint8_t  vp_index;\n\tuint8_t  reserved1[5];\n\t__le32\texchange_address;\n\t__le16\tedif_sa_index;\n\t__le16\tflags;\n\t__le32\tresidual;\n\t__le16\tox_id;\n\t__le16\treserved3;\n\t__le32\trelative_offset;\n\tuint8_t  reserved4[24];\n} __packed;\n\n \n#define CTIO7_FLAGS_SEND_STATUS\t\tBIT_15\n#define CTIO7_FLAGS_TERMINATE\t\tBIT_14\n#define CTIO7_FLAGS_CONFORM_REQ\t\tBIT_13\n#define CTIO7_FLAGS_DONT_RET_CTIO\tBIT_8\n#define CTIO7_FLAGS_STATUS_MODE_0\t0\n#define CTIO7_FLAGS_STATUS_MODE_1\tBIT_6\n#define CTIO7_FLAGS_STATUS_MODE_2\tBIT_7\n#define CTIO7_FLAGS_EXPLICIT_CONFORM\tBIT_5\n#define CTIO7_FLAGS_CONFIRM_SATISF\tBIT_4\n#define CTIO7_FLAGS_DSD_PTR\t\tBIT_2\n#define CTIO7_FLAGS_DATA_IN\t\tBIT_1  \n#define CTIO7_FLAGS_DATA_OUT\t\tBIT_0  \n\n#define ELS_PLOGI\t\t\t0x3\n#define ELS_FLOGI\t\t\t0x4\n#define ELS_LOGO\t\t\t0x5\n#define ELS_PRLI\t\t\t0x20\n#define ELS_PRLO\t\t\t0x21\n#define ELS_TPRLO\t\t\t0x24\n#define ELS_PDISC\t\t\t0x50\n#define ELS_ADISC\t\t\t0x52\n\n \nstruct ctio_crc2_to_fw {\n\tuint8_t entry_type;\t\t \n#define CTIO_CRC2 0x7A\n\tuint8_t entry_count;\t\t \n\tuint8_t sys_define;\t\t \n\tuint8_t entry_status;\t\t \n\n\tuint32_t handle;\t\t \n\t__le16\tnport_handle;\t\t \n\t__le16 timeout;\t\t \n\n\t__le16\tdseg_count;\t\t \n\tuint8_t  vp_index;\n\tuint8_t  add_flags;\t\t \n#define CTIO_CRC2_AF_DIF_DSD_ENA BIT_3\n\n\tle_id_t  initiator_id;\t\t \n\tuint8_t  reserved1;\n\t__le32\texchange_addr;\t\t \n\t__le16\treserved2;\n\t__le16 flags;\t\t\t \n\t__le32\tresidual;\n\t__le16 ox_id;\n\t__le16\tscsi_status;\n\t__le32 relative_offset;\n\t__le32\treserved5;\n\t__le32 transfer_length;\t\t \n\t__le32\treserved6;\n\t__le64\t crc_context_address __packed;  \n\t__le16\tcrc_context_len;\t \n\t__le16\treserved_1;\t\t \n};\n\n \nstruct ctio_crc_from_fw {\n\tuint8_t entry_type;\t\t \n\tuint8_t entry_count;\t\t \n\tuint8_t sys_define;\t\t \n\tuint8_t entry_status;\t\t \n\n\tuint32_t handle;\t\t \n\t__le16\tstatus;\n\t__le16\ttimeout;\t\t \n\t__le16\tdseg_count;\t\t \n\t__le32\treserved1;\n\t__le16\tstate_flags;\n#define CTIO_CRC_SF_DIF_CHOPPED BIT_4\n\n\t__le32\texchange_address;\t \n\t__le16\treserved2;\n\t__le16\tflags;\n\t__le32\tresid_xfer_length;\n\t__le16\tox_id;\n\tuint8_t  reserved3[12];\n\t__le16\trunt_guard;\t\t \n\tuint8_t  actual_dif[8];\n\tuint8_t  expected_dif[8];\n} __packed;\n\n \n#define ABTS_RECV_24XX\t\t0x54  \n#define ABTS_RESP_24XX\t\t0x55  \n\n \nstruct abts_recv_from_24xx {\n\tuint8_t\t entry_type;\t\t     \n\tuint8_t\t entry_count;\t\t     \n\tuint8_t\t sys_define;\t\t     \n\tuint8_t\t entry_status;\t\t     \n\tuint8_t  reserved_1[6];\n\t__le16\tnport_handle;\n\tuint8_t  reserved_2[2];\n\tuint8_t  vp_index;\n\tuint8_t  reserved_3:4;\n\tuint8_t  sof_type:4;\n\t__le32\texchange_address;\n\tstruct fcp_hdr_le fcp_hdr_le;\n\tuint8_t  reserved_4[16];\n\t__le32\texchange_addr_to_abort;\n} __packed;\n\n#define ABTS_PARAM_ABORT_SEQ\t\tBIT_0\n\nstruct ba_acc_le {\n\t__le16\treserved;\n\tuint8_t  seq_id_last;\n\tuint8_t  seq_id_valid;\n#define SEQ_ID_VALID\t0x80\n#define SEQ_ID_INVALID\t0x00\n\t__le16\trx_id;\n\t__le16\tox_id;\n\t__le16\thigh_seq_cnt;\n\t__le16\tlow_seq_cnt;\n} __packed;\n\nstruct ba_rjt_le {\n\tuint8_t vendor_uniq;\n\tuint8_t reason_expl;\n\tuint8_t reason_code;\n#define BA_RJT_REASON_CODE_INVALID_COMMAND\t0x1\n#define BA_RJT_REASON_CODE_UNABLE_TO_PERFORM\t0x9\n\tuint8_t reserved;\n} __packed;\n\n \nstruct abts_resp_to_24xx {\n\tuint8_t\t entry_type;\t\t     \n\tuint8_t\t entry_count;\t\t     \n\tuint8_t\t sys_define;\t\t     \n\tuint8_t\t entry_status;\t\t     \n\tuint32_t handle;\n\t__le16\treserved_1;\n\t__le16\tnport_handle;\n\t__le16\tcontrol_flags;\n#define ABTS_CONTR_FLG_TERM_EXCHG\tBIT_0\n\tuint8_t  vp_index;\n\tuint8_t  reserved_3:4;\n\tuint8_t  sof_type:4;\n\t__le32\texchange_address;\n\tstruct fcp_hdr_le fcp_hdr_le;\n\tunion {\n\t\tstruct ba_acc_le ba_acct;\n\t\tstruct ba_rjt_le ba_rjt;\n\t} __packed payload;\n\t__le32\treserved_4;\n\t__le32\texchange_addr_to_abort;\n} __packed;\n\n \nstruct abts_resp_from_24xx_fw {\n\tuint8_t\t entry_type;\t\t     \n\tuint8_t\t entry_count;\t\t     \n\tuint8_t\t sys_define;\t\t     \n\tuint8_t\t entry_status;\t\t     \n\tuint32_t handle;\n\t__le16\tcompl_status;\n#define ABTS_RESP_COMPL_SUCCESS\t\t0\n#define ABTS_RESP_COMPL_SUBCODE_ERROR\t0x31\n\t__le16\tnport_handle;\n\t__le16\treserved_1;\n\tuint8_t  reserved_2;\n\tuint8_t  reserved_3:4;\n\tuint8_t  sof_type:4;\n\t__le32\texchange_address;\n\tstruct fcp_hdr_le fcp_hdr_le;\n\tuint8_t reserved_4[8];\n\t__le32\terror_subcode1;\n#define ABTS_RESP_SUBCODE_ERR_ABORTED_EXCH_NOT_TERM\t0x1E\n\t__le32\terror_subcode2;\n\t__le32\texchange_addr_to_abort;\n} __packed;\n\n \n\nstruct qla_tgt_mgmt_cmd;\nstruct fc_port;\nstruct qla_tgt_cmd;\n\n \nstruct qla_tgt_func_tmpl {\n\tstruct qla_tgt_cmd *(*find_cmd_by_tag)(struct fc_port *, uint64_t);\n\tint (*handle_cmd)(struct scsi_qla_host *, struct qla_tgt_cmd *,\n\t\t\tunsigned char *, uint32_t, int, int, int);\n\tvoid (*handle_data)(struct qla_tgt_cmd *);\n\tint (*handle_tmr)(struct qla_tgt_mgmt_cmd *, u64, uint16_t,\n\t\t\tuint32_t);\n\tstruct qla_tgt_cmd *(*get_cmd)(struct fc_port *);\n\tvoid (*rel_cmd)(struct qla_tgt_cmd *);\n\tvoid (*free_cmd)(struct qla_tgt_cmd *);\n\tvoid (*free_mcmd)(struct qla_tgt_mgmt_cmd *);\n\tvoid (*free_session)(struct fc_port *);\n\n\tint (*check_initiator_node_acl)(struct scsi_qla_host *, unsigned char *,\n\t\t\t\t\tstruct fc_port *);\n\tvoid (*update_sess)(struct fc_port *, port_id_t, uint16_t, bool);\n\tstruct fc_port *(*find_sess_by_loop_id)(struct scsi_qla_host *,\n\t\t\t\t\t\tconst uint16_t);\n\tstruct fc_port *(*find_sess_by_s_id)(struct scsi_qla_host *,\n\t\t\t\t\t     const be_id_t);\n\tvoid (*clear_nacl_from_fcport_map)(struct fc_port *);\n\tvoid (*put_sess)(struct fc_port *);\n\tvoid (*shutdown_sess)(struct fc_port *);\n\tint (*get_dif_tags)(struct qla_tgt_cmd *cmd, uint16_t *pfw_prot_opts);\n\tint (*chk_dif_tags)(uint32_t tag);\n\tvoid (*add_target)(struct scsi_qla_host *);\n\tvoid (*remove_target)(struct scsi_qla_host *);\n};\n\nint qla2x00_wait_for_hba_online(struct scsi_qla_host *);\n\n#include <target/target_core_base.h>\n\n#define QLA_TGT_TIMEOUT\t\t\t10\t \n\n#define QLA_TGT_MAX_HW_PENDING_TIME\t60  \n\n \n#define IMM_NTFY_LIP_RESET          0x000E\n#define IMM_NTFY_LIP_LINK_REINIT    0x000F\n#define IMM_NTFY_IOCB_OVERFLOW      0x0016\n#define IMM_NTFY_ABORT_TASK         0x0020\n#define IMM_NTFY_PORT_LOGOUT        0x0029\n#define IMM_NTFY_PORT_CONFIG        0x002A\n#define IMM_NTFY_GLBL_TPRLO         0x002D\n#define IMM_NTFY_GLBL_LOGO          0x002E\n#define IMM_NTFY_RESOURCE           0x0034\n#define IMM_NTFY_MSG_RX             0x0036\n#define IMM_NTFY_SRR                0x0045\n#define IMM_NTFY_ELS                0x0046\n\n \n#define IMM_NTFY_TASK_MGMT_SHIFT    8\n\n#define QLA_TGT_CLEAR_ACA               0x40\n#define QLA_TGT_TARGET_RESET            0x20\n#define QLA_TGT_LUN_RESET               0x10\n#define QLA_TGT_CLEAR_TS                0x04\n#define QLA_TGT_ABORT_TS                0x02\n#define QLA_TGT_ABORT_ALL_SESS          0xFFFF\n#define QLA_TGT_ABORT_ALL               0xFFFE\n#define QLA_TGT_NEXUS_LOSS_SESS         0xFFFD\n#define QLA_TGT_NEXUS_LOSS              0xFFFC\n#define QLA_TGT_ABTS\t\t\t0xFFFB\n#define QLA_TGT_2G_ABORT_TASK\t\t0xFFFA\n\n \n#define NOTIFY_ACK_RES_COUNT        BIT_8\n#define NOTIFY_ACK_CLEAR_LIP_RESET  BIT_5\n#define NOTIFY_ACK_TM_RESP_CODE_VALID BIT_4\n\n \n#define QLA_TGT_STATE_NEW\t\t0  \n#define QLA_TGT_STATE_NEED_DATA\t\t1  \n#define QLA_TGT_STATE_DATA_IN\t\t2  \n#define QLA_TGT_STATE_PROCESSED\t\t3  \n\n \n#define ATIO_SIMPLE_QUEUE           0\n#define ATIO_HEAD_OF_QUEUE          1\n#define ATIO_ORDERED_QUEUE          2\n#define ATIO_ACA_QUEUE              4\n#define ATIO_UNTAGGED               5\n\n \n#define\tFC_TM_SUCCESS               0\n#define\tFC_TM_BAD_FCP_DATA          1\n#define\tFC_TM_BAD_CMD               2\n#define\tFC_TM_FCP_DATA_MISMATCH     3\n#define\tFC_TM_REJECT                4\n#define FC_TM_FAILED                5\n\n#define QLA_TGT_SENSE_VALID(sense)  ((sense != NULL) && \\\n\t\t\t\t(((const uint8_t *)(sense))[0] & 0x70) == 0x70)\n\nstruct qla_port_24xx_data {\n\tuint8_t port_name[WWN_SIZE];\n\tuint16_t loop_id;\n\tuint16_t reserved;\n};\n\nstruct qla_qpair_hint {\n\tstruct list_head hint_elem;\n\tstruct qla_qpair *qpair;\n\tu16 cpuid;\n\tuint8_t cmd_cnt;\n};\n\nstruct qla_tgt {\n\tstruct scsi_qla_host *vha;\n\tstruct qla_hw_data *ha;\n\tstruct btree_head64 lun_qpair_map;\n\tstruct qla_qpair_hint *qphints;\n\t \n\tint atio_irq_cmd_count;\n\n\tint sg_tablesize;\n\n\t \n\tunsigned int link_reinit_iocb_pending:1;\n\n\t \n\tint tgt_stop;  \n\tint tgt_stopped;  \n\n\t \n\tint sess_count;\n\n\tspinlock_t sess_work_lock;\n\tstruct list_head sess_works_list;\n\tstruct work_struct sess_work;\n\n\tstruct imm_ntfy_from_isp link_reinit_iocb;\n\twait_queue_head_t waitQ;\n\tint notify_ack_expected;\n\tint abts_resp_expected;\n\tint modify_lun_expected;\n\tatomic_t tgt_global_resets_count;\n\tstruct list_head tgt_list_entry;\n};\n\nstruct qla_tgt_sess_op {\n\tstruct scsi_qla_host *vha;\n\tuint32_t chip_reset;\n\tstruct atio_from_isp atio;\n\tstruct work_struct work;\n\tstruct list_head cmd_list;\n\tbool aborted;\n\tstruct rsp_que *rsp;\n};\n\nenum trace_flags {\n\tTRC_NEW_CMD = BIT_0,\n\tTRC_DO_WORK = BIT_1,\n\tTRC_DO_WORK_ERR = BIT_2,\n\tTRC_XFR_RDY = BIT_3,\n\tTRC_XMIT_DATA = BIT_4,\n\tTRC_XMIT_STATUS = BIT_5,\n\tTRC_SRR_RSP =  BIT_6,\n\tTRC_SRR_XRDY = BIT_7,\n\tTRC_SRR_TERM = BIT_8,\n\tTRC_SRR_CTIO = BIT_9,\n\tTRC_FLUSH = BIT_10,\n\tTRC_CTIO_ERR = BIT_11,\n\tTRC_CTIO_DONE = BIT_12,\n\tTRC_CTIO_ABORTED =  BIT_13,\n\tTRC_CTIO_STRANGE = BIT_14,\n\tTRC_CMD_DONE = BIT_15,\n\tTRC_CMD_CHK_STOP = BIT_16,\n\tTRC_CMD_FREE = BIT_17,\n\tTRC_DATA_IN = BIT_18,\n\tTRC_ABORT = BIT_19,\n\tTRC_DIF_ERR = BIT_20,\n};\n\nstruct qla_tgt_cmd {\n\t \n\tuint8_t cmd_type;\n\tuint8_t pad[7];\n\tstruct se_cmd se_cmd;\n\tstruct list_head sess_cmd_list;\n\tstruct fc_port *sess;\n\tstruct qla_qpair *qpair;\n\tuint32_t reset_count;\n\tint state;\n\tstruct work_struct work;\n\t \n\tunsigned char sense_buffer[TRANSPORT_SENSE_BUFFER];\n\n\tspinlock_t cmd_lock;\n\t \n\tunsigned int conf_compl_supported:1;\n\tunsigned int sg_mapped:1;\n\tunsigned int write_data_transferred:1;\n\tunsigned int q_full:1;\n\tunsigned int term_exchg:1;\n\tunsigned int cmd_sent_to_fw:1;\n\tunsigned int cmd_in_wq:1;\n\tunsigned int edif:1;\n\n\t \n\tunsigned int aborted;\n\n\tstruct scatterlist *sg;\t \n\tint sg_cnt;\t\t \n\tint bufflen;\t\t \n\tint offset;\n\tu64 unpacked_lun;\n\tenum dma_data_direction dma_data_direction;\n\n\tuint16_t ctio_flags;\n\tuint16_t vp_idx;\n\tuint16_t loop_id;\t \n\tstruct qla_tgt *tgt;\t \n\tstruct scsi_qla_host *vha;\n\tstruct list_head cmd_list;\n\n\tstruct atio_from_isp atio;\n\n\tuint8_t ctx_dsd_alloced;\n\n\t \n#define DIF_ERR_NONE 0\n#define DIF_ERR_GRD 1\n#define DIF_ERR_REF 2\n#define DIF_ERR_APP 3\n\tint8_t dif_err_code;\n\tstruct scatterlist *prot_sg;\n\tuint32_t prot_sg_cnt;\n\tuint32_t blk_sz, num_blks;\n\tuint8_t scsi_status, sense_key, asc, ascq;\n\n\tstruct crc_context *ctx;\n\tconst uint8_t\t*cdb;\n\tuint64_t\tlba;\n\tuint16_t\ta_guard, e_guard, a_app_tag, e_app_tag;\n\tuint32_t\ta_ref_tag, e_ref_tag;\n#define DIF_BUNDL_DMA_VALID 1\n\tuint16_t prot_flags;\n\n\tuint64_t jiffies_at_alloc;\n\tuint64_t jiffies_at_free;\n\n\tenum trace_flags trc_flags;\n};\n\nstruct qla_tgt_sess_work_param {\n\tstruct list_head sess_works_list_entry;\n\n#define QLA_TGT_SESS_WORK_ABORT\t1\n\tint type;\n\n\tunion {\n\t\tstruct abts_recv_from_24xx abts;\n\t\tstruct imm_ntfy_from_isp tm_iocb;\n\t\tstruct atio_from_isp tm_iocb2;\n\t};\n};\n\nstruct qla_tgt_mgmt_cmd {\n\tuint8_t cmd_type;\n\tuint8_t pad[3];\n\tuint16_t tmr_func;\n\tuint8_t fc_tm_rsp;\n\tuint8_t abort_io_attr;\n\tstruct fc_port *sess;\n\tstruct qla_qpair *qpair;\n\tstruct scsi_qla_host *vha;\n\tstruct se_cmd se_cmd;\n\tstruct work_struct free_work;\n\tunsigned int flags;\n#define QLA24XX_MGMT_SEND_NACK\tBIT_0\n#define QLA24XX_MGMT_ABORT_IO_ATTR_VALID BIT_1\n\tuint32_t reset_count;\n\tstruct work_struct work;\n\tuint64_t unpacked_lun;\n\tunion {\n\t\tstruct atio_from_isp atio;\n\t\tstruct imm_ntfy_from_isp imm_ntfy;\n\t\tstruct abts_recv_from_24xx abts;\n\t} __packed orig_iocb;\n};\n\nstruct qla_tgt_prm {\n\tstruct qla_tgt_cmd *cmd;\n\tstruct qla_tgt *tgt;\n\tvoid *pkt;\n\tstruct scatterlist *sg;\t \n\tunsigned char *sense_buffer;\n\tint seg_cnt;\n\tint req_cnt;\n\tuint16_t rq_result;\n\tint sense_buffer_len;\n\tint residual;\n\tint add_status_pkt;\n\t \n\tstruct scatterlist *prot_sg;\n\tuint16_t prot_seg_cnt;\n\tuint16_t tot_dsds;\n};\n\n \n#define IS_SW_RESV_ADDR(_s_id) \\\n\t((_s_id.b.domain == 0xff) && ((_s_id.b.area & 0xf0) == 0xf0))\n\n#define QLA_TGT_XMIT_DATA\t\t1\n#define QLA_TGT_XMIT_STATUS\t\t2\n#define QLA_TGT_XMIT_ALL\t\t(QLA_TGT_XMIT_STATUS|QLA_TGT_XMIT_DATA)\n\n\nextern struct qla_tgt_data qla_target;\n\n \nextern int qlt_add_target(struct qla_hw_data *, struct scsi_qla_host *);\nextern int qlt_remove_target(struct qla_hw_data *, struct scsi_qla_host *);\nextern int qlt_lport_register(void *, u64, u64, u64,\n\t\t\tint (*callback)(struct scsi_qla_host *, void *, u64, u64));\nextern void qlt_lport_deregister(struct scsi_qla_host *);\nextern void qlt_unreg_sess(struct fc_port *);\nextern void qlt_fc_port_added(struct scsi_qla_host *, fc_port_t *);\nextern void qlt_fc_port_deleted(struct scsi_qla_host *, fc_port_t *, int);\nextern int __init qlt_init(void);\nextern void qlt_exit(void);\nextern void qlt_free_session_done(struct work_struct *);\n \n#define QLA_TGT_MODE_ENABLED() (ql2x_ini_mode != QLA2XXX_INI_MODE_ENABLED)\n\nextern int ql2x_ini_mode;\n\nstatic inline bool qla_tgt_mode_enabled(struct scsi_qla_host *ha)\n{\n\treturn ha->host->active_mode == MODE_TARGET;\n}\n\nstatic inline bool qla_ini_mode_enabled(struct scsi_qla_host *ha)\n{\n\treturn ha->host->active_mode == MODE_INITIATOR;\n}\n\nstatic inline bool qla_dual_mode_enabled(struct scsi_qla_host *ha)\n{\n\treturn (ha->host->active_mode == MODE_DUAL);\n}\n\nstatic inline uint32_t sid_to_key(const be_id_t s_id)\n{\n\treturn s_id.domain << 16 |\n\t\ts_id.area << 8 |\n\t\ts_id.al_pa;\n}\n\n \nextern void qlt_response_pkt_all_vps(struct scsi_qla_host *, struct rsp_que *,\n\tresponse_t *);\nextern int qlt_rdy_to_xfer(struct qla_tgt_cmd *);\nextern int qlt_xmit_response(struct qla_tgt_cmd *, int, uint8_t);\nextern int qlt_abort_cmd(struct qla_tgt_cmd *);\nextern void qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *);\nextern void qlt_free_mcmd(struct qla_tgt_mgmt_cmd *);\nextern void qlt_free_cmd(struct qla_tgt_cmd *cmd);\nextern void qlt_async_event(uint16_t, struct scsi_qla_host *, uint16_t *);\nextern void qlt_enable_vha(struct scsi_qla_host *);\nextern void qlt_vport_create(struct scsi_qla_host *, struct qla_hw_data *);\nextern u8 qlt_rff_id(struct scsi_qla_host *);\nextern void qlt_init_atio_q_entries(struct scsi_qla_host *);\nextern void qlt_24xx_process_atio_queue(struct scsi_qla_host *, uint8_t);\nextern void qlt_24xx_config_rings(struct scsi_qla_host *);\nextern void qlt_24xx_config_nvram_stage1(struct scsi_qla_host *,\n\tstruct nvram_24xx *);\nextern void qlt_24xx_config_nvram_stage2(struct scsi_qla_host *,\n\tstruct init_cb_24xx *);\nextern void qlt_81xx_config_nvram_stage2(struct scsi_qla_host *,\n\tstruct init_cb_81xx *);\nextern void qlt_81xx_config_nvram_stage1(struct scsi_qla_host *,\n\tstruct nvram_81xx *);\nextern void qlt_modify_vp_config(struct scsi_qla_host *,\n\tstruct vp_config_entry_24xx *);\nextern void qlt_probe_one_stage1(struct scsi_qla_host *, struct qla_hw_data *);\nextern int qlt_mem_alloc(struct qla_hw_data *);\nextern void qlt_mem_free(struct qla_hw_data *);\nextern int qlt_stop_phase1(struct qla_tgt *);\nextern void qlt_stop_phase2(struct qla_tgt *);\nextern irqreturn_t qla83xx_msix_atio_q(int, void *);\nextern void qlt_83xx_iospace_config(struct qla_hw_data *);\nextern int qlt_free_qfull_cmds(struct qla_qpair *);\nextern void qlt_logo_completion_handler(fc_port_t *, int);\nextern void qlt_do_generation_tick(struct scsi_qla_host *, int *);\n\nvoid qlt_send_resp_ctio(struct qla_qpair *, struct qla_tgt_cmd *, uint8_t,\n    uint8_t, uint8_t, uint8_t);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}