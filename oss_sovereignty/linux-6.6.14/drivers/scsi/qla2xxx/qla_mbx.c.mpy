{
  "module_name": "qla_mbx.c",
  "hash_id": "e29d248f33d69021c6fae94d9a63f01f61a9923b5f5b0fdf8c19dcee09170e44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_mbx.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_target.h\"\n\n#include <linux/delay.h>\n#include <linux/gfp.h>\n\n#ifdef CONFIG_PPC\n#define IS_PPCARCH      true\n#else\n#define IS_PPCARCH      false\n#endif\n\nstatic struct mb_cmd_name {\n\tuint16_t cmd;\n\tconst char *str;\n} mb_str[] = {\n\t{MBC_GET_PORT_DATABASE,\t\t\"GPDB\"},\n\t{MBC_GET_ID_LIST,\t\t\"GIDList\"},\n\t{MBC_GET_LINK_PRIV_STATS,\t\"Stats\"},\n\t{MBC_GET_RESOURCE_COUNTS,\t\"ResCnt\"},\n};\n\nstatic const char *mb_to_str(uint16_t cmd)\n{\n\tint i;\n\tstruct mb_cmd_name *e;\n\n\tfor (i = 0; i < ARRAY_SIZE(mb_str); i++) {\n\t\te = mb_str + i;\n\t\tif (cmd == e->cmd)\n\t\t\treturn e->str;\n\t}\n\treturn \"unknown\";\n}\n\nstatic struct rom_cmd {\n\tuint16_t cmd;\n} rom_cmds[] = {\n\t{ MBC_LOAD_RAM },\n\t{ MBC_EXECUTE_FIRMWARE },\n\t{ MBC_READ_RAM_WORD },\n\t{ MBC_MAILBOX_REGISTER_TEST },\n\t{ MBC_VERIFY_CHECKSUM },\n\t{ MBC_GET_FIRMWARE_VERSION },\n\t{ MBC_LOAD_RISC_RAM },\n\t{ MBC_DUMP_RISC_RAM },\n\t{ MBC_LOAD_RISC_RAM_EXTENDED },\n\t{ MBC_DUMP_RISC_RAM_EXTENDED },\n\t{ MBC_WRITE_RAM_WORD_EXTENDED },\n\t{ MBC_READ_RAM_EXTENDED },\n\t{ MBC_GET_RESOURCE_COUNTS },\n\t{ MBC_SET_FIRMWARE_OPTION },\n\t{ MBC_MID_INITIALIZE_FIRMWARE },\n\t{ MBC_GET_FIRMWARE_STATE },\n\t{ MBC_GET_MEM_OFFLOAD_CNTRL_STAT },\n\t{ MBC_GET_RETRY_COUNT },\n\t{ MBC_TRACE_CONTROL },\n\t{ MBC_INITIALIZE_MULTIQ },\n\t{ MBC_IOCB_COMMAND_A64 },\n\t{ MBC_GET_ADAPTER_LOOP_ID },\n\t{ MBC_READ_SFP },\n\t{ MBC_SET_RNID_PARAMS },\n\t{ MBC_GET_RNID_PARAMS },\n\t{ MBC_GET_SET_ZIO_THRESHOLD },\n};\n\nstatic int is_rom_cmd(uint16_t cmd)\n{\n\tint i;\n\tstruct  rom_cmd *wc;\n\n\tfor (i = 0; i < ARRAY_SIZE(rom_cmds); i++) {\n\t\twc = rom_cmds + i;\n\t\tif (wc->cmd == cmd)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nqla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)\n{\n\tint\t\trval, i;\n\tunsigned long    flags = 0;\n\tdevice_reg_t *reg;\n\tuint8_t\t\tabort_active, eeh_delay;\n\tuint8_t\t\tio_lock_on;\n\tuint16_t\tcommand = 0;\n\tuint16_t\t*iptr;\n\t__le16 __iomem  *optr;\n\tuint32_t\tcnt;\n\tuint32_t\tmboxes;\n\tunsigned long\twait_time;\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tu32 chip_reset;\n\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1000, \"Entered %s.\\n\", __func__);\n\n\tif (ha->pdev->error_state == pci_channel_io_perm_failure) {\n\t\tql_log(ql_log_warn, vha, 0x1001,\n\t\t    \"PCI channel failed permanently, exiting.\\n\");\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tif (vha->device_flags & DFLG_DEV_FAILED) {\n\t\tql_log(ql_log_warn, vha, 0x1002,\n\t\t    \"Device in failed state, exiting.\\n\");\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\t \n\tif (test_bit(PFLG_DISCONNECTED, &base_vha->dpc_flags) &&\n\t    test_bit(UNLOADING, &base_vha->dpc_flags)) {\n\t\tql_log(ql_log_warn, vha, 0xd04e,\n\t\t    \"PCI error, exiting.\\n\");\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\teeh_delay = 0;\n\treg = ha->iobase;\n\tio_lock_on = base_vha->flags.init_done;\n\n\trval = QLA_SUCCESS;\n\tabort_active = test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n\tchip_reset = ha->chip_reset;\n\n\tif (ha->flags.pci_channel_io_perm_failure) {\n\t\tql_log(ql_log_warn, vha, 0x1003,\n\t\t    \"Perm failure on EEH timeout MBX, exiting.\\n\");\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tif (IS_P3P_TYPE(ha) && ha->flags.isp82xx_fw_hung) {\n\t\t \n\t\tmcp->mb[0] = MBS_LINK_DOWN_ERROR;\n\t\tql_log(ql_log_warn, vha, 0x1004,\n\t\t    \"FW hung = %d.\\n\", ha->flags.isp82xx_fw_hung);\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\t \n\tif (((test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags) ||\n\t      test_bit(ISP_ABORT_RETRY, &base_vha->dpc_flags) ||\n\t      test_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags)) &&\n\t      !is_rom_cmd(mcp->mb[0])) || ha->flags.eeh_busy) {\n\t\tql_log(ql_log_info, vha, 0x1005,\n\t\t    \"Cmd 0x%x aborted with timeout since ISP Abort is pending\\n\",\n\t\t    mcp->mb[0]);\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tatomic_inc(&ha->num_pend_mbx_stage1);\n\t \n\tif (!wait_for_completion_timeout(&ha->mbx_cmd_comp, mcp->tov * HZ)) {\n\t\t \n\t\tql_log(ql_log_warn, vha, 0xd035,\n\t\t    \"Cmd access timeout, cmd=0x%x, Exiting.\\n\",\n\t\t    mcp->mb[0]);\n\t\tvha->hw_err_cnt++;\n\t\tatomic_dec(&ha->num_pend_mbx_stage1);\n\t\treturn QLA_FUNCTION_TIMEOUT;\n\t}\n\tatomic_dec(&ha->num_pend_mbx_stage1);\n\tif (ha->flags.purge_mbox || chip_reset != ha->chip_reset ||\n\t    ha->flags.eeh_busy) {\n\t\tql_log(ql_log_warn, vha, 0xd035,\n\t\t       \"Error detected: purge[%d] eeh[%d] cmd=0x%x, Exiting.\\n\",\n\t\t       ha->flags.purge_mbox, ha->flags.eeh_busy, mcp->mb[0]);\n\t\trval = QLA_ABORTED;\n\t\tgoto premature_exit;\n\t}\n\n\n\t \n\tha->mcp = mcp;\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1006,\n\t    \"Prepare to issue mbox cmd=0x%x.\\n\", mcp->mb[0]);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\tif (ha->flags.purge_mbox || chip_reset != ha->chip_reset ||\n\t    ha->flags.mbox_busy) {\n\t\trval = QLA_ABORTED;\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\tgoto premature_exit;\n\t}\n\tha->flags.mbox_busy = 1;\n\n\t \n\tif (IS_P3P_TYPE(ha))\n\t\toptr = &reg->isp82.mailbox_in[0];\n\telse if (IS_FWI2_CAPABLE(ha) && !(IS_P3P_TYPE(ha)))\n\t\toptr = &reg->isp24.mailbox0;\n\telse\n\t\toptr = MAILBOX_REG(ha, &reg->isp, 0);\n\n\tiptr = mcp->mb;\n\tcommand = mcp->mb[0];\n\tmboxes = mcp->out_mb;\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1111,\n\t    \"Mailbox registers (OUT):\\n\");\n\tfor (cnt = 0; cnt < ha->mbx_count; cnt++) {\n\t\tif (IS_QLA2200(ha) && cnt == 8)\n\t\t\toptr = MAILBOX_REG(ha, &reg->isp, 8);\n\t\tif (mboxes & BIT_0) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1112,\n\t\t\t    \"mbox[%d]<-0x%04x\\n\", cnt, *iptr);\n\t\t\twrt_reg_word(optr, *iptr);\n\t\t} else {\n\t\t\twrt_reg_word(optr, 0);\n\t\t}\n\n\t\tmboxes >>= 1;\n\t\toptr++;\n\t\tiptr++;\n\t}\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1117,\n\t    \"I/O Address = %p.\\n\", optr);\n\n\t \n\tha->flags.mbox_int = 0;\n\tclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\n\n\t \n\tql_dbg(ql_dbg_mbx, vha, 0x100f,\n\t    \"Going to unlock irq & waiting for interrupts. \"\n\t    \"jiffies=%lx.\\n\", jiffies);\n\n\t \n\tatomic_inc(&ha->num_pend_mbx_stage2);\n\tif ((!abort_active && io_lock_on) || IS_NOPOLLING_TYPE(ha)) {\n\t\tset_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\n\n\t\tif (IS_P3P_TYPE(ha))\n\t\t\twrt_reg_dword(&reg->isp82.hint, HINT_MBX_INT_PENDING);\n\t\telse if (IS_FWI2_CAPABLE(ha))\n\t\t\twrt_reg_dword(&reg->isp24.hccr, HCCRX_SET_HOST_INT);\n\t\telse\n\t\t\twrt_reg_word(&reg->isp.hccr, HCCR_SET_HOST_INT);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\twait_time = jiffies;\n\t\tif (!wait_for_completion_timeout(&ha->mbx_intr_comp,\n\t\t    mcp->tov * HZ)) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x117a,\n\t\t\t    \"cmd=%x Timeout.\\n\", command);\n\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\tclear_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\t\tif (chip_reset != ha->chip_reset) {\n\t\t\t\teeh_delay = ha->flags.eeh_busy ? 1 : 0;\n\n\t\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\t\tha->flags.mbox_busy = 0;\n\t\t\t\tspin_unlock_irqrestore(&ha->hardware_lock,\n\t\t\t\t    flags);\n\t\t\t\tatomic_dec(&ha->num_pend_mbx_stage2);\n\t\t\t\trval = QLA_ABORTED;\n\t\t\t\tgoto premature_exit;\n\t\t\t}\n\t\t} else if (ha->flags.purge_mbox ||\n\t\t    chip_reset != ha->chip_reset) {\n\t\t\teeh_delay = ha->flags.eeh_busy ? 1 : 0;\n\n\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\tha->flags.mbox_busy = 0;\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\t\tatomic_dec(&ha->num_pend_mbx_stage2);\n\t\t\trval = QLA_ABORTED;\n\t\t\tgoto premature_exit;\n\t\t}\n\n\t\tif (time_after(jiffies, wait_time + 5 * HZ))\n\t\t\tql_log(ql_log_warn, vha, 0x1015, \"cmd=0x%x, waited %d msecs\\n\",\n\t\t\t    command, jiffies_to_msecs(jiffies - wait_time));\n\t} else {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1011,\n\t\t    \"Cmd=%x Polling Mode.\\n\", command);\n\n\t\tif (IS_P3P_TYPE(ha)) {\n\t\t\tif (rd_reg_dword(&reg->isp82.hint) &\n\t\t\t\tHINT_MBX_INT_PENDING) {\n\t\t\t\tha->flags.mbox_busy = 0;\n\t\t\t\tspin_unlock_irqrestore(&ha->hardware_lock,\n\t\t\t\t\tflags);\n\t\t\t\tatomic_dec(&ha->num_pend_mbx_stage2);\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1012,\n\t\t\t\t    \"Pending mailbox timeout, exiting.\\n\");\n\t\t\t\tvha->hw_err_cnt++;\n\t\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t\t\t\tgoto premature_exit;\n\t\t\t}\n\t\t\twrt_reg_dword(&reg->isp82.hint, HINT_MBX_INT_PENDING);\n\t\t} else if (IS_FWI2_CAPABLE(ha))\n\t\t\twrt_reg_dword(&reg->isp24.hccr, HCCRX_SET_HOST_INT);\n\t\telse\n\t\t\twrt_reg_word(&reg->isp.hccr, HCCR_SET_HOST_INT);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\twait_time = jiffies + mcp->tov * HZ;  \n\t\twhile (!ha->flags.mbox_int) {\n\t\t\tif (ha->flags.purge_mbox ||\n\t\t\t    chip_reset != ha->chip_reset) {\n\t\t\t\teeh_delay = ha->flags.eeh_busy ? 1 : 0;\n\n\t\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\t\tha->flags.mbox_busy = 0;\n\t\t\t\tspin_unlock_irqrestore(&ha->hardware_lock,\n\t\t\t\t    flags);\n\t\t\t\tatomic_dec(&ha->num_pend_mbx_stage2);\n\t\t\t\trval = QLA_ABORTED;\n\t\t\t\tgoto premature_exit;\n\t\t\t}\n\n\t\t\tif (time_after(jiffies, wait_time))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tqla2x00_poll(ha->rsp_q_map[0]);\n\n\t\t\tif (!ha->flags.mbox_int &&\n\t\t\t    !(IS_QLA2200(ha) &&\n\t\t\t    command == MBC_LOAD_RISC_RAM_EXTENDED))\n\t\t\t\tmsleep(10);\n\t\t}  \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1013,\n\t\t    \"Waited %d sec.\\n\",\n\t\t    (uint)((jiffies - (wait_time - (mcp->tov * HZ)))/HZ));\n\t}\n\tatomic_dec(&ha->num_pend_mbx_stage2);\n\n\t \n\tif (ha->flags.mbox_int) {\n\t\tuint16_t *iptr2;\n\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1014,\n\t\t    \"Cmd=%x completed.\\n\", command);\n\n\t\t \n\t\tha->flags.mbox_int = 0;\n\t\tclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\n\n\t\tif (IS_P3P_TYPE(ha) && ha->flags.isp82xx_fw_hung) {\n\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\tha->flags.mbox_busy = 0;\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\t\t \n\t\t\tmcp->mb[0] = MBS_LINK_DOWN_ERROR;\n\t\t\tha->mcp = NULL;\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tql_log(ql_log_warn, vha, 0xd048,\n\t\t\t    \"FW hung = %d.\\n\", ha->flags.isp82xx_fw_hung);\n\t\t\tgoto premature_exit;\n\t\t}\n\n\t\tif (ha->mailbox_out[0] != MBS_COMMAND_COMPLETE) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x11ff,\n\t\t\t       \"mb_out[0] = %#x <> %#x\\n\", ha->mailbox_out[0],\n\t\t\t       MBS_COMMAND_COMPLETE);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t}\n\n\t\t \n\t\tiptr2 = mcp->mb;\n\t\tiptr = (uint16_t *)&ha->mailbox_out[0];\n\t\tmboxes = mcp->in_mb;\n\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1113,\n\t\t    \"Mailbox registers (IN):\\n\");\n\t\tfor (cnt = 0; cnt < ha->mbx_count; cnt++) {\n\t\t\tif (mboxes & BIT_0) {\n\t\t\t\t*iptr2 = *iptr;\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1114,\n\t\t\t\t    \"mbox[%d]->0x%04x\\n\", cnt, *iptr2);\n\t\t\t}\n\n\t\t\tmboxes >>= 1;\n\t\t\tiptr2++;\n\t\t\tiptr++;\n\t\t}\n\t} else {\n\n\t\tuint16_t mb[8];\n\t\tuint32_t ictrl, host_status, hccr;\n\t\tuint16_t        w;\n\n\t\tif (IS_FWI2_CAPABLE(ha)) {\n\t\t\tmb[0] = rd_reg_word(&reg->isp24.mailbox0);\n\t\t\tmb[1] = rd_reg_word(&reg->isp24.mailbox1);\n\t\t\tmb[2] = rd_reg_word(&reg->isp24.mailbox2);\n\t\t\tmb[3] = rd_reg_word(&reg->isp24.mailbox3);\n\t\t\tmb[7] = rd_reg_word(&reg->isp24.mailbox7);\n\t\t\tictrl = rd_reg_dword(&reg->isp24.ictrl);\n\t\t\thost_status = rd_reg_dword(&reg->isp24.host_status);\n\t\t\thccr = rd_reg_dword(&reg->isp24.hccr);\n\n\t\t\tql_log(ql_log_warn, vha, 0xd04c,\n\t\t\t    \"MBX Command timeout for cmd %x, iocontrol=%x jiffies=%lx \"\n\t\t\t    \"mb[0-3]=[0x%x 0x%x 0x%x 0x%x] mb7 0x%x host_status 0x%x hccr 0x%x\\n\",\n\t\t\t    command, ictrl, jiffies, mb[0], mb[1], mb[2], mb[3],\n\t\t\t    mb[7], host_status, hccr);\n\t\t\tvha->hw_err_cnt++;\n\n\t\t} else {\n\t\t\tmb[0] = RD_MAILBOX_REG(ha, &reg->isp, 0);\n\t\t\tictrl = rd_reg_word(&reg->isp.ictrl);\n\t\t\tql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1119,\n\t\t\t    \"MBX Command timeout for cmd %x, iocontrol=%x jiffies=%lx \"\n\t\t\t    \"mb[0]=0x%x\\n\", command, ictrl, jiffies, mb[0]);\n\t\t\tvha->hw_err_cnt++;\n\t\t}\n\t\tql_dump_regs(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1019);\n\n\t\t \n\t\tif (!pci_channel_offline(vha->hw->pdev)) {\n\t\t\tpci_read_config_word(ha->pdev, PCI_VENDOR_ID, &w);\n\t\t\tif (w == 0xffff || ictrl == 0xffffffff ||\n\t\t\t    (chip_reset != ha->chip_reset)) {\n\t\t\t\t \n\t\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\t\tha->flags.mbox_busy = 0;\n\t\t\t\tspin_unlock_irqrestore(&ha->hardware_lock,\n\t\t\t\t    flags);\n\t\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t\t\t\tgoto premature_exit;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (mcp->mb[0] != MBC_GEN_SYSTEM_ERROR)\n\t\t\t\tqla2xxx_dump_fw(vha);\n\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t\t }\n\t}\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->flags.mbox_busy = 0;\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t \n\tha->mcp = NULL;\n\n\tif ((abort_active || !io_lock_on) && !IS_NOPOLLING_TYPE(ha)) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x101a,\n\t\t    \"Checking for additional resp interrupt.\\n\");\n\n\t\t \n\t\tqla2x00_poll(ha->rsp_q_map[0]);\n\t}\n\n\tif (rval == QLA_FUNCTION_TIMEOUT &&\n\t    mcp->mb[0] != MBC_GEN_SYSTEM_ERROR) {\n\t\tif (!io_lock_on || (mcp->flags & IOCTL_CMD) ||\n\t\t    ha->flags.eeh_busy) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x101b,\n\t\t\t    \"Timeout, schedule isp_abort_needed.\\n\");\n\n\t\t\tif (!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) &&\n\t\t\t    !test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\n\t\t\t    !test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\n\t\t\t\tif (IS_QLA82XX(ha)) {\n\t\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x112a,\n\t\t\t\t\t    \"disabling pause transmit on port \"\n\t\t\t\t\t    \"0 & 1.\\n\");\n\t\t\t\t\tqla82xx_wr_32(ha,\n\t\t\t\t\t    QLA82XX_CRB_NIU + 0x98,\n\t\t\t\t\t    CRB_NIU_XG_PAUSE_CTL_P0|\n\t\t\t\t\t    CRB_NIU_XG_PAUSE_CTL_P1);\n\t\t\t\t}\n\t\t\t\tql_log(ql_log_info, base_vha, 0x101c,\n\t\t\t\t    \"Mailbox cmd timeout occurred, cmd=0x%x, \"\n\t\t\t\t    \"mb[0]=0x%x, eeh_busy=0x%x. Scheduling ISP \"\n\t\t\t\t    \"abort.\\n\", command, mcp->mb[0],\n\t\t\t\t    ha->flags.eeh_busy);\n\t\t\t\tvha->hw_err_cnt++;\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t}\n\t\t} else if (current == ha->dpc_thread) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x101d,\n\t\t\t    \"Timeout, calling abort_isp.\\n\");\n\n\t\t\tif (!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) &&\n\t\t\t    !test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\n\t\t\t    !test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\n\t\t\t\tif (IS_QLA82XX(ha)) {\n\t\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x112b,\n\t\t\t\t\t    \"disabling pause transmit on port \"\n\t\t\t\t\t    \"0 & 1.\\n\");\n\t\t\t\t\tqla82xx_wr_32(ha,\n\t\t\t\t\t    QLA82XX_CRB_NIU + 0x98,\n\t\t\t\t\t    CRB_NIU_XG_PAUSE_CTL_P0|\n\t\t\t\t\t    CRB_NIU_XG_PAUSE_CTL_P1);\n\t\t\t\t}\n\t\t\t\tql_log(ql_log_info, base_vha, 0x101e,\n\t\t\t\t    \"Mailbox cmd timeout occurred, cmd=0x%x, \"\n\t\t\t\t    \"mb[0]=0x%x. Scheduling ISP abort \",\n\t\t\t\t    command, mcp->mb[0]);\n\t\t\t\tvha->hw_err_cnt++;\n\t\t\t\tset_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\n\t\t\t\tclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t\t \n\t\t\t\tcomplete(&ha->mbx_cmd_comp);\n\t\t\t\tif (ha->isp_ops->abort_isp(vha) &&\n\t\t\t\t    !ha->flags.eeh_busy) {\n\t\t\t\t\t \n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t}\n\t\t\t\tclear_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x101f,\n\t\t\t\t    \"Finished abort_isp.\\n\");\n\t\t\t\tgoto mbx_done;\n\t\t\t}\n\t\t}\n\t}\n\npremature_exit:\n\t \n\tcomplete(&ha->mbx_cmd_comp);\n\nmbx_done:\n\tif (rval == QLA_ABORTED) {\n\t\tql_log(ql_log_info, vha, 0xd035,\n\t\t    \"Chip Reset in progress. Purging Mbox cmd=0x%x.\\n\",\n\t\t    mcp->mb[0]);\n\t} else if (rval) {\n\t\tif (ql2xextended_error_logging & (ql_dbg_disc|ql_dbg_mbx)) {\n\t\t\tpr_warn(\"%s [%s]-%04x:%ld: **** Failed=%x\", QL_MSGHDR,\n\t\t\t    dev_name(&ha->pdev->dev), 0x1020+0x800,\n\t\t\t    vha->host_no, rval);\n\t\t\tmboxes = mcp->in_mb;\n\t\t\tcnt = 4;\n\t\t\tfor (i = 0; i < ha->mbx_count && cnt; i++, mboxes >>= 1)\n\t\t\t\tif (mboxes & BIT_0) {\n\t\t\t\t\tprintk(\" mb[%u]=%x\", i, mcp->mb[i]);\n\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\tpr_warn(\" cmd=%x ****\\n\", command);\n\t\t}\n\t\tif (IS_FWI2_CAPABLE(ha) && !(IS_P3P_TYPE(ha))) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1198,\n\t\t\t    \"host_status=%#x intr_ctrl=%#x intr_status=%#x\\n\",\n\t\t\t    rd_reg_dword(&reg->isp24.host_status),\n\t\t\t    rd_reg_dword(&reg->isp24.ictrl),\n\t\t\t    rd_reg_dword(&reg->isp24.istatus));\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1206,\n\t\t\t    \"ctrl_status=%#x ictrl=%#x istatus=%#x\\n\",\n\t\t\t    rd_reg_word(&reg->isp.ctrl_status),\n\t\t\t    rd_reg_word(&reg->isp.ictrl),\n\t\t\t    rd_reg_word(&reg->isp.istatus));\n\t\t}\n\t} else {\n\t\tql_dbg(ql_dbg_mbx, base_vha, 0x1021, \"Done %s.\\n\", __func__);\n\t}\n\n\ti = 500;\n\twhile (i && eeh_delay && (ha->pci_error_state < QLA_PCI_SLOT_RESET)) {\n\t\t \n\t\tmsleep(1);\n\t\ti--;\n\t}\n\treturn rval;\n}\n\nint\nqla2x00_load_ram(scsi_qla_host_t *vha, dma_addr_t req_dma, uint32_t risc_addr,\n    uint32_t risc_code_size)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1022,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (MSW(risc_addr) || IS_FWI2_CAPABLE(ha)) {\n\t\tmcp->mb[0] = MBC_LOAD_RISC_RAM_EXTENDED;\n\t\tmcp->mb[8] = MSW(risc_addr);\n\t\tmcp->out_mb = MBX_8|MBX_0;\n\t} else {\n\t\tmcp->mb[0] = MBC_LOAD_RISC_RAM;\n\t\tmcp->out_mb = MBX_0;\n\t}\n\tmcp->mb[1] = LSW(risc_addr);\n\tmcp->mb[2] = MSW(req_dma);\n\tmcp->mb[3] = LSW(req_dma);\n\tmcp->mb[6] = MSW(MSD(req_dma));\n\tmcp->mb[7] = LSW(MSD(req_dma));\n\tmcp->out_mb |= MBX_7|MBX_6|MBX_3|MBX_2|MBX_1;\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tmcp->mb[4] = MSW(risc_code_size);\n\t\tmcp->mb[5] = LSW(risc_code_size);\n\t\tmcp->out_mb |= MBX_5|MBX_4;\n\t} else {\n\t\tmcp->mb[4] = LSW(risc_code_size);\n\t\tmcp->out_mb |= MBX_4;\n\t}\n\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1023,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t\tvha->hw_err_cnt++;\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1024,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n#define\tNVME_ENABLE_FLAG\tBIT_3\n#define\tEDIF_HW_SUPPORT\t\tBIT_10\n\n \nint\nqla2x00_execute_fw(scsi_qla_host_t *vha, uint32_t risc_addr)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tu8 semaphore = 0;\n#define EXE_FW_FORCE_SEMAPHORE BIT_7\n\tu8 retry = 5;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1025,\n\t    \"Entered %s.\\n\", __func__);\n\nagain:\n\tmcp->mb[0] = MBC_EXECUTE_FIRMWARE;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_0;\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tmcp->mb[1] = MSW(risc_addr);\n\t\tmcp->mb[2] = LSW(risc_addr);\n\t\tmcp->mb[3] = 0;\n\t\tmcp->mb[4] = 0;\n\t\tmcp->mb[11] = 0;\n\n\t\t \n\t\tif (ha->flags.lr_detected) {\n\t\t\tmcp->mb[4] = BIT_0;\n\t\t\tif (IS_BPM_RANGE_CAPABLE(ha))\n\t\t\t\tmcp->mb[4] |=\n\t\t\t\t    ha->lr_distance << LR_DIST_FW_POS;\n\t\t}\n\n\t\tif (ql2xnvmeenable && (IS_QLA27XX(ha) || IS_QLA28XX(ha)))\n\t\t\tmcp->mb[4] |= NVME_ENABLE_FLAG;\n\n\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tstruct nvram_81xx *nv = ha->nvram;\n\t\t\t \n\t\t\tif (nv->min_supported_speed >= 2 &&\n\t\t\t    nv->min_supported_speed <= 5) {\n\t\t\t\tmcp->mb[4] |= BIT_4;\n\t\t\t\tmcp->mb[11] |= nv->min_supported_speed & 0xF;\n\t\t\t\tmcp->out_mb |= MBX_11;\n\t\t\t\tmcp->in_mb |= BIT_5;\n\t\t\t\tvha->min_supported_speed =\n\t\t\t\t    nv->min_supported_speed;\n\t\t\t}\n\n\t\t\tif (IS_PPCARCH)\n\t\t\t\tmcp->mb[11] |= BIT_4;\n\t\t}\n\n\t\tif (ha->flags.exlogins_enabled)\n\t\t\tmcp->mb[4] |= ENABLE_EXTENDED_LOGIN;\n\n\t\tif (ha->flags.exchoffld_enabled)\n\t\t\tmcp->mb[4] |= ENABLE_EXCHANGE_OFFLD;\n\n\t\tif (semaphore)\n\t\t\tmcp->mb[11] |= EXE_FW_FORCE_SEMAPHORE;\n\n\t\tmcp->out_mb |= MBX_4 | MBX_3 | MBX_2 | MBX_1 | MBX_11;\n\t\tmcp->in_mb |= MBX_5 | MBX_3 | MBX_2 | MBX_1;\n\t} else {\n\t\tmcp->mb[1] = LSW(risc_addr);\n\t\tmcp->out_mb |= MBX_1;\n\t\tif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\n\t\t\tmcp->mb[2] = 0;\n\t\t\tmcp->out_mb |= MBX_2;\n\t\t}\n\t}\n\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tif (IS_QLA28XX(ha) && rval == QLA_COMMAND_ERROR &&\n\t\t    mcp->mb[1] == 0x27 && retry) {\n\t\t\tsemaphore = 1;\n\t\t\tretry--;\n\t\t\tql_dbg(ql_dbg_async, vha, 0x1026,\n\t\t\t    \"Exe FW: force semaphore.\\n\");\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tretry--;\n\t\t\tql_dbg(ql_dbg_async, vha, 0x509d,\n\t\t\t    \"Exe FW retry: mb[0]=%x retry[%d]\\n\", mcp->mb[0], retry);\n\t\t\tgoto again;\n\t\t}\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1026,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t\tvha->hw_err_cnt++;\n\t\treturn rval;\n\t}\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\tgoto done;\n\n\tha->fw_ability_mask = mcp->mb[3] << 16 | mcp->mb[2];\n\tql_dbg(ql_dbg_mbx, vha, 0x119a,\n\t    \"fw_ability_mask=%x.\\n\", ha->fw_ability_mask);\n\tql_dbg(ql_dbg_mbx, vha, 0x1027, \"exchanges=%x.\\n\", mcp->mb[1]);\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tha->max_supported_speed = mcp->mb[2] & (BIT_0|BIT_1);\n\t\tql_dbg(ql_dbg_mbx, vha, 0x119b, \"max_supported_speed=%s.\\n\",\n\t\t    ha->max_supported_speed == 0 ? \"16Gps\" :\n\t\t    ha->max_supported_speed == 1 ? \"32Gps\" :\n\t\t    ha->max_supported_speed == 2 ? \"64Gps\" : \"unknown\");\n\t\tif (vha->min_supported_speed) {\n\t\t\tha->min_supported_speed = mcp->mb[5] &\n\t\t\t    (BIT_0 | BIT_1 | BIT_2);\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x119c,\n\t\t\t    \"min_supported_speed=%s.\\n\",\n\t\t\t    ha->min_supported_speed == 6 ? \"64Gps\" :\n\t\t\t    ha->min_supported_speed == 5 ? \"32Gps\" :\n\t\t\t    ha->min_supported_speed == 4 ? \"16Gps\" :\n\t\t\t    ha->min_supported_speed == 3 ? \"8Gps\" :\n\t\t\t    ha->min_supported_speed == 2 ? \"4Gps\" : \"unknown\");\n\t\t}\n\t}\n\n\tif (IS_QLA28XX(ha) && (mcp->mb[5] & EDIF_HW_SUPPORT)) {\n\t\tha->flags.edif_hw = 1;\n\t\tql_log(ql_log_info, vha, 0xffff,\n\t\t    \"%s: edif HW\\n\", __func__);\n\t}\n\ndone:\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1028,\n\t    \"Done %s.\\n\", __func__);\n\n\treturn rval;\n}\n\n \n#define\tFETCH_XLOGINS_STAT\t0x8\nint\nqla_get_exlogin_status(scsi_qla_host_t *vha, uint16_t *buf_sz,\n\tuint16_t *ex_logins_cnt)\n{\n\tint rval;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118f,\n\t    \"Entered %s\\n\", __func__);\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;\n\tmcp->mb[1] = FETCH_XLOGINS_STAT;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_10|MBX_4|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1115, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\t*buf_sz = mcp->mb[4];\n\t\t*ex_logins_cnt = mcp->mb[10];\n\n\t\tql_log(ql_log_info, vha, 0x1190,\n\t\t    \"buffer size 0x%x, exchange login count=%d\\n\",\n\t\t    mcp->mb[4], mcp->mb[10]);\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1116,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \n#define CONFIG_XLOGINS_MEM\t0x9\nint\nqla_set_exlogin_mem_cfg(scsi_qla_host_t *vha, dma_addr_t phys_addr)\n{\n\tint\t\trval;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x111a,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;\n\tmcp->mb[1] = CONFIG_XLOGINS_MEM;\n\tmcp->mb[2] = MSW(phys_addr);\n\tmcp->mb[3] = LSW(phys_addr);\n\tmcp->mb[6] = MSW(MSD(phys_addr));\n\tmcp->mb[7] = LSW(MSD(phys_addr));\n\tmcp->mb[8] = MSW(ha->exlogin_size);\n\tmcp->mb[9] = LSW(ha->exlogin_size);\n\tmcp->out_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_11|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x111b,\n\t\t       \"EXlogin Failed=%x. MB0=%x MB11=%x\\n\",\n\t\t       rval, mcp->mb[0], mcp->mb[11]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118c,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \n#define\tFETCH_XCHOFFLD_STAT\t0x2\nint\nqla_get_exchoffld_status(scsi_qla_host_t *vha, uint16_t *buf_sz,\n\tuint16_t *ex_logins_cnt)\n{\n\tint rval;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1019,\n\t    \"Entered %s\\n\", __func__);\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;\n\tmcp->mb[1] = FETCH_XCHOFFLD_STAT;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_10|MBX_4|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1155, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\t*buf_sz = mcp->mb[4];\n\t\t*ex_logins_cnt = mcp->mb[10];\n\n\t\tql_log(ql_log_info, vha, 0x118e,\n\t\t    \"buffer size 0x%x, exchange offload count=%d\\n\",\n\t\t    mcp->mb[4], mcp->mb[10]);\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1156,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \n#define CONFIG_XCHOFFLD_MEM\t0x3\nint\nqla_set_exchoffld_mem_cfg(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1157,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = MBC_GET_MEM_OFFLOAD_CNTRL_STAT;\n\tmcp->mb[1] = CONFIG_XCHOFFLD_MEM;\n\tmcp->mb[2] = MSW(ha->exchoffld_buf_dma);\n\tmcp->mb[3] = LSW(ha->exchoffld_buf_dma);\n\tmcp->mb[6] = MSW(MSD(ha->exchoffld_buf_dma));\n\tmcp->mb[7] = LSW(MSD(ha->exchoffld_buf_dma));\n\tmcp->mb[8] = MSW(ha->exchoffld_size);\n\tmcp->mb[9] = LSW(ha->exchoffld_size);\n\tmcp->out_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_11|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1158, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1192,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_get_fw_version(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1029,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_FIRMWARE_VERSION;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tif (IS_QLA81XX(vha->hw) || IS_QLA8031(ha) || IS_QLA8044(ha))\n\t\tmcp->in_mb |= MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8;\n\tif (IS_FWI2_CAPABLE(ha))\n\t\tmcp->in_mb |= MBX_17|MBX_16|MBX_15;\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tmcp->in_mb |=\n\t\t    MBX_25|MBX_24|MBX_23|MBX_22|MBX_21|MBX_20|MBX_19|MBX_18|\n\t\t    MBX_14|MBX_13|MBX_11|MBX_10|MBX_9|MBX_8|MBX_7;\n\n\tmcp->flags = 0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto failed;\n\n\t \n\tha->fw_major_version = mcp->mb[1];\n\tha->fw_minor_version = mcp->mb[2];\n\tha->fw_subminor_version = mcp->mb[3];\n\tha->fw_attributes = mcp->mb[6];\n\tif (IS_QLA2100(vha->hw) || IS_QLA2200(vha->hw))\n\t\tha->fw_memory_size = 0x1FFFF;\t\t \n\telse\n\t\tha->fw_memory_size = (mcp->mb[5] << 16) | mcp->mb[4];\n\n\tif (IS_QLA81XX(vha->hw) || IS_QLA8031(vha->hw) || IS_QLA8044(ha)) {\n\t\tha->mpi_version[0] = mcp->mb[10] & 0xff;\n\t\tha->mpi_version[1] = mcp->mb[11] >> 8;\n\t\tha->mpi_version[2] = mcp->mb[11] & 0xff;\n\t\tha->mpi_capabilities = (mcp->mb[12] << 16) | mcp->mb[13];\n\t\tha->phy_version[0] = mcp->mb[8] & 0xff;\n\t\tha->phy_version[1] = mcp->mb[9] >> 8;\n\t\tha->phy_version[2] = mcp->mb[9] & 0xff;\n\t}\n\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tha->fw_attributes_h = mcp->mb[15];\n\t\tha->fw_attributes_ext[0] = mcp->mb[16];\n\t\tha->fw_attributes_ext[1] = mcp->mb[17];\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1139,\n\t\t    \"%s: FW_attributes Upper: 0x%x, Lower: 0x%x.\\n\",\n\t\t    __func__, mcp->mb[15], mcp->mb[6]);\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x112f,\n\t\t    \"%s: Ext_FwAttributes Upper: 0x%x, Lower: 0x%x.\\n\",\n\t\t    __func__, mcp->mb[17], mcp->mb[16]);\n\n\t\tif (ha->fw_attributes_h & 0x4)\n\t\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118d,\n\t\t\t    \"%s: Firmware supports Extended Login 0x%x\\n\",\n\t\t\t    __func__, ha->fw_attributes_h);\n\n\t\tif (ha->fw_attributes_h & 0x8)\n\t\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1191,\n\t\t\t    \"%s: Firmware supports Exchange Offload 0x%x\\n\",\n\t\t\t    __func__, ha->fw_attributes_h);\n\n\t\t \n\t\tif ((ha->fw_attributes_h &\n\t\t    (FW_ATTR_H_NVME | FW_ATTR_H_NVME_UPDATED)) &&\n\t\t\tql2xnvmeenable) {\n\t\t\tif (ha->fw_attributes_h & FW_ATTR_H_NVME_FBURST)\n\t\t\t\tvha->flags.nvme_first_burst = 1;\n\n\t\t\tvha->flags.nvme_enabled = 1;\n\t\t\tql_log(ql_log_info, vha, 0xd302,\n\t\t\t    \"%s: FC-NVMe is Enabled (0x%x)\\n\",\n\t\t\t     __func__, ha->fw_attributes_h);\n\t\t}\n\n\t\t \n\t\tif (ha->fw_attributes_ext[0] & FW_ATTR_EXT0_NVME2) {\n\t\t\tql_log(ql_log_info, vha, 0xd302,\n\t\t\t       \"Firmware supports NVMe2 0x%x\\n\",\n\t\t\t       ha->fw_attributes_ext[0]);\n\t\t\tvha->flags.nvme2_enabled = 1;\n\t\t}\n\n\t\tif (IS_QLA28XX(ha) && ha->flags.edif_hw && ql2xsecenable &&\n\t\t    (ha->fw_attributes_ext[0] & FW_ATTR_EXT0_EDIF)) {\n\t\t\tha->flags.edif_enabled = 1;\n\t\t\tql_log(ql_log_info, vha, 0xffff,\n\t\t\t       \"%s: edif is enabled\\n\", __func__);\n\t\t}\n\t}\n\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tha->serdes_version[0] = mcp->mb[7] & 0xff;\n\t\tha->serdes_version[1] = mcp->mb[8] >> 8;\n\t\tha->serdes_version[2] = mcp->mb[8] & 0xff;\n\t\tha->mpi_version[0] = mcp->mb[10] & 0xff;\n\t\tha->mpi_version[1] = mcp->mb[11] >> 8;\n\t\tha->mpi_version[2] = mcp->mb[11] & 0xff;\n\t\tha->pep_version[0] = mcp->mb[13] & 0xff;\n\t\tha->pep_version[1] = mcp->mb[14] >> 8;\n\t\tha->pep_version[2] = mcp->mb[14] & 0xff;\n\t\tha->fw_shared_ram_start = (mcp->mb[19] << 16) | mcp->mb[18];\n\t\tha->fw_shared_ram_end = (mcp->mb[21] << 16) | mcp->mb[20];\n\t\tha->fw_ddr_ram_start = (mcp->mb[23] << 16) | mcp->mb[22];\n\t\tha->fw_ddr_ram_end = (mcp->mb[25] << 16) | mcp->mb[24];\n\t\tif (IS_QLA28XX(ha)) {\n\t\t\tif (mcp->mb[16] & BIT_10)\n\t\t\t\tha->flags.secure_fw = 1;\n\n\t\t\tql_log(ql_log_info, vha, 0xffff,\n\t\t\t    \"Secure Flash Update in FW: %s\\n\",\n\t\t\t    (ha->flags.secure_fw) ? \"Supported\" :\n\t\t\t    \"Not Supported\");\n\t\t}\n\n\t\tif (ha->flags.scm_supported_a &&\n\t\t    (ha->fw_attributes_ext[0] & FW_ATTR_EXT0_SCM_SUPPORTED)) {\n\t\t\tha->flags.scm_supported_f = 1;\n\t\t\tha->sf_init_cb->flags |= cpu_to_le16(BIT_13);\n\t\t}\n\t\tql_log(ql_log_info, vha, 0x11a3, \"SCM in FW: %s\\n\",\n\t\t       (ha->flags.scm_supported_f) ? \"Supported\" :\n\t\t       \"Not Supported\");\n\n\t\tif (vha->flags.nvme2_enabled) {\n\t\t\t \n\t\t\tha->sf_init_cb->flags |= cpu_to_le16(BIT_15);\n\t\t\t \n\t\t\tha->sf_init_cb->flags |= cpu_to_le16(BIT_14);\n\t\t}\n\t}\n\nfailed:\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x102a, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x102b,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\treturn rval;\n}\n\n \nint\nqla2x00_get_fw_options(scsi_qla_host_t *vha, uint16_t *fwopts)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x102c,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_FIRMWARE_OPTION;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x102d, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tfwopts[0] = mcp->mb[0];\n\t\tfwopts[1] = mcp->mb[1];\n\t\tfwopts[2] = mcp->mb[2];\n\t\tfwopts[3] = mcp->mb[3];\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x102e,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n\n \nint\nqla2x00_set_fw_options(scsi_qla_host_t *vha, uint16_t *fwopts)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x102f,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_SET_FIRMWARE_OPTION;\n\tmcp->mb[1] = fwopts[1];\n\tmcp->mb[2] = fwopts[2];\n\tmcp->mb[3] = fwopts[3];\n\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tif (IS_FWI2_CAPABLE(vha->hw)) {\n\t\tmcp->in_mb |= MBX_1;\n\t\tmcp->mb[10] = fwopts[10];\n\t\tmcp->out_mb |= MBX_10;\n\t} else {\n\t\tmcp->mb[10] = fwopts[10];\n\t\tmcp->mb[11] = fwopts[11];\n\t\tmcp->mb[12] = 0;\t \n\t\tmcp->out_mb |= MBX_12|MBX_11|MBX_10;\n\t}\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tfwopts[0] = mcp->mb[0];\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1030,\n\t\t    \"Failed=%x (%x/%x).\\n\", rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1031,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_mbx_reg_test(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1032,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_MAILBOX_REGISTER_TEST;\n\tmcp->mb[1] = 0xAAAA;\n\tmcp->mb[2] = 0x5555;\n\tmcp->mb[3] = 0xAA55;\n\tmcp->mb[4] = 0x55AA;\n\tmcp->mb[5] = 0xA5A5;\n\tmcp->mb[6] = 0x5A5A;\n\tmcp->mb[7] = 0x2525;\n\tmcp->out_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tif (mcp->mb[1] != 0xAAAA || mcp->mb[2] != 0x5555 ||\n\t\t    mcp->mb[3] != 0xAA55 || mcp->mb[4] != 0x55AA)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\tif (mcp->mb[5] != 0xA5A5 || mcp->mb[6] != 0x5A5A ||\n\t\t    mcp->mb[7] != 0x2525)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t}\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1033, \"Failed=%x.\\n\", rval);\n\t\tvha->hw_err_cnt++;\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1034,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_verify_checksum(scsi_qla_host_t *vha, uint32_t risc_addr)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1035,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_VERIFY_CHECKSUM;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_0;\n\tif (IS_FWI2_CAPABLE(vha->hw)) {\n\t\tmcp->mb[1] = MSW(risc_addr);\n\t\tmcp->mb[2] = LSW(risc_addr);\n\t\tmcp->out_mb |= MBX_2|MBX_1;\n\t\tmcp->in_mb |= MBX_2|MBX_1;\n\t} else {\n\t\tmcp->mb[1] = LSW(risc_addr);\n\t\tmcp->out_mb |= MBX_1;\n\t\tmcp->in_mb |= MBX_1;\n\t}\n\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1036,\n\t\t    \"Failed=%x chm sum=%x.\\n\", rval, IS_FWI2_CAPABLE(vha->hw) ?\n\t\t    (mcp->mb[2] << 16) | mcp->mb[1] : mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1037,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_issue_iocb_timeout(scsi_qla_host_t *vha, void *buffer,\n    dma_addr_t phys_addr, size_t size, uint32_t tov)\n{\n\tint\t\trval;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\n\tif (!vha->hw->flags.fw_started)\n\t\treturn QLA_INVALID_COMMAND;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1038,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_IOCB_COMMAND_A64;\n\tmcp->mb[1] = 0;\n\tmcp->mb[2] = MSW(LSD(phys_addr));\n\tmcp->mb[3] = LSW(LSD(phys_addr));\n\tmcp->mb[6] = MSW(MSD(phys_addr));\n\tmcp->mb[7] = LSW(MSD(phys_addr));\n\tmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = tov;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1039, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tsts_entry_t *sts_entry = buffer;\n\n\t\t \n\t\tsts_entry->entry_status &=\n\t\t    IS_FWI2_CAPABLE(vha->hw) ? RF_MASK_24XX : RF_MASK;\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103a,\n\t\t    \"Done %s (status=%x).\\n\", __func__,\n\t\t    sts_entry->entry_status);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_issue_iocb(scsi_qla_host_t *vha, void *buffer, dma_addr_t phys_addr,\n    size_t size)\n{\n\treturn qla2x00_issue_iocb_timeout(vha, buffer, phys_addr, size,\n\t    MBX_TOV_SECONDS);\n}\n\n \nint\nqla2x00_abort_command(srb_t *sp)\n{\n\tunsigned long   flags = 0;\n\tint\t\trval;\n\tuint32_t\thandle = 0;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\tfc_port_t\t*fcport = sp->fcport;\n\tscsi_qla_host_t *vha = fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103b,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (sp->qpair)\n\t\treq = sp->qpair->req;\n\telse\n\t\treq = vha->req;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (handle = 1; handle < req->num_outstanding_cmds; handle++) {\n\t\tif (req->outstanding_cmds[handle] == sp)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (handle == req->num_outstanding_cmds) {\n\t\t \n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tmcp->mb[0] = MBC_ABORT_COMMAND;\n\tif (HAS_EXTENDED_IDS(ha))\n\t\tmcp->mb[1] = fcport->loop_id;\n\telse\n\t\tmcp->mb[1] = fcport->loop_id << 8;\n\tmcp->mb[2] = (uint16_t)handle;\n\tmcp->mb[3] = (uint16_t)(handle >> 16);\n\tmcp->mb[6] = (uint16_t)cmd->device->lun;\n\tmcp->out_mb = MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x103c, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103d,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_abort_target(struct fc_port *fcport, uint64_t l, int tag)\n{\n\tint rval, rval2;\n\tmbx_cmd_t  mc;\n\tmbx_cmd_t  *mcp = &mc;\n\tscsi_qla_host_t *vha;\n\n\tvha = fcport->vha;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103e,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_ABORT_TARGET;\n\tmcp->out_mb = MBX_9|MBX_2|MBX_1|MBX_0;\n\tif (HAS_EXTENDED_IDS(vha->hw)) {\n\t\tmcp->mb[1] = fcport->loop_id;\n\t\tmcp->mb[10] = 0;\n\t\tmcp->out_mb |= MBX_10;\n\t} else {\n\t\tmcp->mb[1] = fcport->loop_id << 8;\n\t}\n\tmcp->mb[2] = vha->hw->loop_reset_delay;\n\tmcp->mb[9] = vha->vp_idx;\n\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103f,\n\t\t    \"Failed=%x.\\n\", rval);\n\t}\n\n\t \n\trval2 = qla2x00_marker(vha, vha->hw->base_qpair, fcport->loop_id, 0,\n\t\t\t\t\t\t\tMK_SYNC_ID);\n\tif (rval2 != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1040,\n\t\t    \"Failed to issue marker IOCB (%x).\\n\", rval2);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1041,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_lun_reset(struct fc_port *fcport, uint64_t l, int tag)\n{\n\tint rval, rval2;\n\tmbx_cmd_t  mc;\n\tmbx_cmd_t  *mcp = &mc;\n\tscsi_qla_host_t *vha;\n\n\tvha = fcport->vha;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1042,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_LUN_RESET;\n\tmcp->out_mb = MBX_9|MBX_3|MBX_2|MBX_1|MBX_0;\n\tif (HAS_EXTENDED_IDS(vha->hw))\n\t\tmcp->mb[1] = fcport->loop_id;\n\telse\n\t\tmcp->mb[1] = fcport->loop_id << 8;\n\tmcp->mb[2] = (u32)l;\n\tmcp->mb[3] = 0;\n\tmcp->mb[9] = vha->vp_idx;\n\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1043, \"Failed=%x.\\n\", rval);\n\t}\n\n\t \n\trval2 = qla2x00_marker(vha, vha->hw->base_qpair, fcport->loop_id, l,\n\t\t\t\t\t\t\t\tMK_SYNC_ID_LUN);\n\tif (rval2 != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1044,\n\t\t    \"Failed to issue marker IOCB (%x).\\n\", rval2);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1045,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_get_adapter_id(scsi_qla_host_t *vha, uint16_t *id, uint8_t *al_pa,\n    uint8_t *area, uint8_t *domain, uint16_t *top, uint16_t *sw_cap)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1046,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_ADAPTER_LOOP_ID;\n\tmcp->mb[9] = vha->vp_idx;\n\tmcp->out_mb = MBX_9|MBX_0;\n\tmcp->in_mb = MBX_9|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tif (IS_CNA_CAPABLE(vha->hw))\n\t\tmcp->in_mb |= MBX_13|MBX_12|MBX_11|MBX_10;\n\tif (IS_FWI2_CAPABLE(vha->hw))\n\t\tmcp->in_mb |= MBX_19|MBX_18|MBX_17|MBX_16;\n\tif (IS_QLA27XX(vha->hw) || IS_QLA28XX(vha->hw))\n\t\tmcp->in_mb |= MBX_15|MBX_21|MBX_22|MBX_23;\n\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (mcp->mb[0] == MBS_COMMAND_ERROR)\n\t\trval = QLA_COMMAND_ERROR;\n\telse if (mcp->mb[0] == MBS_INVALID_COMMAND)\n\t\trval = QLA_INVALID_COMMAND;\n\n\t \n\t*id = mcp->mb[1];\n\t*al_pa = LSB(mcp->mb[2]);\n\t*area = MSB(mcp->mb[2]);\n\t*domain\t= LSB(mcp->mb[3]);\n\t*top = mcp->mb[6];\n\t*sw_cap = mcp->mb[7];\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1047, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1048,\n\t\t    \"Done %s.\\n\", __func__);\n\n\t\tif (IS_CNA_CAPABLE(vha->hw)) {\n\t\t\tvha->fcoe_vlan_id = mcp->mb[9] & 0xfff;\n\t\t\tvha->fcoe_fcf_idx = mcp->mb[10];\n\t\t\tvha->fcoe_vn_port_mac[5] = mcp->mb[11] >> 8;\n\t\t\tvha->fcoe_vn_port_mac[4] = mcp->mb[11] & 0xff;\n\t\t\tvha->fcoe_vn_port_mac[3] = mcp->mb[12] >> 8;\n\t\t\tvha->fcoe_vn_port_mac[2] = mcp->mb[12] & 0xff;\n\t\t\tvha->fcoe_vn_port_mac[1] = mcp->mb[13] >> 8;\n\t\t\tvha->fcoe_vn_port_mac[0] = mcp->mb[13] & 0xff;\n\t\t}\n\t\t \n\t\tif (IS_FAWWN_CAPABLE(vha->hw)) {\n\t\t\tif (mcp->mb[7] & BIT_14) {\n\t\t\t\tvha->port_name[0] = MSB(mcp->mb[16]);\n\t\t\t\tvha->port_name[1] = LSB(mcp->mb[16]);\n\t\t\t\tvha->port_name[2] = MSB(mcp->mb[17]);\n\t\t\t\tvha->port_name[3] = LSB(mcp->mb[17]);\n\t\t\t\tvha->port_name[4] = MSB(mcp->mb[18]);\n\t\t\t\tvha->port_name[5] = LSB(mcp->mb[18]);\n\t\t\t\tvha->port_name[6] = MSB(mcp->mb[19]);\n\t\t\t\tvha->port_name[7] = LSB(mcp->mb[19]);\n\t\t\t\tfc_host_port_name(vha->host) =\n\t\t\t\t    wwn_to_u64(vha->port_name);\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x10ca,\n\t\t\t\t    \"FA-WWN acquired %016llx\\n\",\n\t\t\t\t    wwn_to_u64(vha->port_name));\n\t\t\t}\n\t\t}\n\n\t\tif (IS_QLA27XX(vha->hw) || IS_QLA28XX(vha->hw)) {\n\t\t\tvha->bbcr = mcp->mb[15];\n\t\t\tif (mcp->mb[7] & SCM_EDC_ACC_RECEIVED) {\n\t\t\t\tql_log(ql_log_info, vha, 0x11a4,\n\t\t\t\t       \"SCM: EDC ELS completed, flags 0x%x\\n\",\n\t\t\t\t       mcp->mb[21]);\n\t\t\t}\n\t\t\tif (mcp->mb[7] & SCM_RDF_ACC_RECEIVED) {\n\t\t\t\tvha->hw->flags.scm_enabled = 1;\n\t\t\t\tvha->scm_fabric_connection_flags |=\n\t\t\t\t    SCM_FLAG_RDF_COMPLETED;\n\t\t\t\tql_log(ql_log_info, vha, 0x11a5,\n\t\t\t\t       \"SCM: RDF ELS completed, flags 0x%x\\n\",\n\t\t\t\t       mcp->mb[23]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_get_retry_cnt(scsi_qla_host_t *vha, uint8_t *retry_cnt, uint8_t *tov,\n    uint16_t *r_a_tov)\n{\n\tint rval;\n\tuint16_t ratov;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1049,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_RETRY_COUNT;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x104a,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\t \n\t\t*r_a_tov = mcp->mb[3] / 2;\n\t\tratov = (mcp->mb[3]/2) / 10;   \n\t\tif (mcp->mb[1] * ratov > (*retry_cnt) * (*tov)) {\n\t\t\t \n\t\t\t*retry_cnt = (uint8_t)mcp->mb[1];\n\t\t\t*tov = ratov;\n\t\t}\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x104b,\n\t\t    \"Done %s mb3=%d ratov=%d.\\n\", __func__, mcp->mb[3], ratov);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_init_firmware(scsi_qla_host_t *vha, uint16_t size)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x104c,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (IS_P3P_TYPE(ha) && ql2xdbwr)\n\t\tqla82xx_wr_32(ha, (uintptr_t __force)ha->nxdb_wr_ptr,\n\t\t\t(0x04 | (ha->portnum << 5) | (0 << 8) | (0 << 16)));\n\n\tif (ha->flags.npiv_supported)\n\t\tmcp->mb[0] = MBC_MID_INITIALIZE_FIRMWARE;\n\telse\n\t\tmcp->mb[0] = MBC_INITIALIZE_FIRMWARE;\n\n\tmcp->mb[1] = 0;\n\tmcp->mb[2] = MSW(ha->init_cb_dma);\n\tmcp->mb[3] = LSW(ha->init_cb_dma);\n\tmcp->mb[6] = MSW(MSD(ha->init_cb_dma));\n\tmcp->mb[7] = LSW(MSD(ha->init_cb_dma));\n\tmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tif (ha->ex_init_cb && ha->ex_init_cb->ex_version) {\n\t\tmcp->mb[1] = BIT_0;\n\t\tmcp->mb[10] = MSW(ha->ex_init_cb_dma);\n\t\tmcp->mb[11] = LSW(ha->ex_init_cb_dma);\n\t\tmcp->mb[12] = MSW(MSD(ha->ex_init_cb_dma));\n\t\tmcp->mb[13] = LSW(MSD(ha->ex_init_cb_dma));\n\t\tmcp->mb[14] = sizeof(*ha->ex_init_cb);\n\t\tmcp->out_mb |= MBX_14|MBX_13|MBX_12|MBX_11|MBX_10;\n\t}\n\n\tif (ha->flags.scm_supported_f || vha->flags.nvme2_enabled) {\n\t\tmcp->mb[1] |= BIT_1;\n\t\tmcp->mb[16] = MSW(ha->sf_init_cb_dma);\n\t\tmcp->mb[17] = LSW(ha->sf_init_cb_dma);\n\t\tmcp->mb[18] = MSW(MSD(ha->sf_init_cb_dma));\n\t\tmcp->mb[19] = LSW(MSD(ha->sf_init_cb_dma));\n\t\tmcp->mb[15] = sizeof(*ha->sf_init_cb);\n\t\tmcp->out_mb |= MBX_19|MBX_18|MBX_17|MBX_16|MBX_15;\n\t}\n\n\t \n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t \n\t\tmcp->in_mb  |= MBX_3;\n\tmcp->buf_size = size;\n\tmcp->flags = MBX_DMA_OUT;\n\tmcp->tov = MBX_TOV_SECONDS;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x104d,\n\t\t    \"Failed=%x mb[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3]);\n\t\tif (ha->init_cb) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x104d, \"init_cb:\\n\");\n\t\t\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha,\n\t\t\t    0x0104d, ha->init_cb, sizeof(*ha->init_cb));\n\t\t}\n\t\tif (ha->ex_init_cb && ha->ex_init_cb->ex_version) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x104d, \"ex_init_cb:\\n\");\n\t\t\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha,\n\t\t\t    0x0104d, ha->ex_init_cb, sizeof(*ha->ex_init_cb));\n\t\t}\n\t} else {\n\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tif (mcp->mb[2] == 6 || mcp->mb[3] == 2)\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x119d,\n\t\t\t\t    \"Invalid SFP/Validation Failed\\n\");\n\t\t}\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x104e,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n\n \nint\nqla2x00_get_port_database(scsi_qla_host_t *vha, fc_port_t *fcport, uint8_t opt)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tport_database_t *pd;\n\tstruct port_database_24xx *pd24;\n\tdma_addr_t pd_dma;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x104f,\n\t    \"Entered %s.\\n\", __func__);\n\n\tpd24 = NULL;\n\tpd = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);\n\tif (pd  == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x1050,\n\t\t    \"Failed to allocate port database structure.\\n\");\n\t\tfcport->query = 0;\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tmcp->mb[0] = MBC_GET_PORT_DATABASE;\n\tif (opt != 0 && !IS_FWI2_CAPABLE(ha))\n\t\tmcp->mb[0] = MBC_ENHANCED_GET_PORT_DATABASE;\n\tmcp->mb[2] = MSW(pd_dma);\n\tmcp->mb[3] = LSW(pd_dma);\n\tmcp->mb[6] = MSW(MSD(pd_dma));\n\tmcp->mb[7] = LSW(MSD(pd_dma));\n\tmcp->mb[9] = vha->vp_idx;\n\tmcp->out_mb = MBX_9|MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tmcp->mb[1] = fcport->loop_id;\n\t\tmcp->mb[10] = opt;\n\t\tmcp->out_mb |= MBX_10|MBX_1;\n\t\tmcp->in_mb |= MBX_1;\n\t} else if (HAS_EXTENDED_IDS(ha)) {\n\t\tmcp->mb[1] = fcport->loop_id;\n\t\tmcp->mb[10] = opt;\n\t\tmcp->out_mb |= MBX_10|MBX_1;\n\t} else {\n\t\tmcp->mb[1] = fcport->loop_id << 8 | opt;\n\t\tmcp->out_mb |= MBX_1;\n\t}\n\tmcp->buf_size = IS_FWI2_CAPABLE(ha) ?\n\t    PORT_DATABASE_24XX_SIZE : PORT_DATABASE_SIZE;\n\tmcp->flags = MBX_DMA_IN;\n\tmcp->tov = (ha->login_timeout * 2) + (ha->login_timeout / 2);\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto gpd_error_out;\n\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tuint64_t zero = 0;\n\t\tu8 current_login_state, last_login_state;\n\n\t\tpd24 = (struct port_database_24xx *) pd;\n\n\t\t \n\t\tif (NVME_TARGET(ha, fcport)) {\n\t\t\tcurrent_login_state = pd24->current_login_state >> 4;\n\t\t\tlast_login_state = pd24->last_login_state >> 4;\n\t\t} else {\n\t\t\tcurrent_login_state = pd24->current_login_state & 0xf;\n\t\t\tlast_login_state = pd24->last_login_state & 0xf;\n\t\t}\n\t\tfcport->current_login_state = pd24->current_login_state;\n\t\tfcport->last_login_state = pd24->last_login_state;\n\n\t\t \n\t\tif (current_login_state != PDS_PRLI_COMPLETE &&\n\t\t    last_login_state != PDS_PRLI_COMPLETE) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x119a,\n\t\t\t    \"Unable to verify login-state (%x/%x) for loop_id %x.\\n\",\n\t\t\t    current_login_state, last_login_state,\n\t\t\t    fcport->loop_id);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\n\t\t\tif (!fcport->query)\n\t\t\t\tgoto gpd_error_out;\n\t\t}\n\n\t\tif (fcport->loop_id == FC_NO_LOOP_ID ||\n\t\t    (memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&\n\t\t     memcmp(fcport->port_name, pd24->port_name, 8))) {\n\t\t\t \n\t\t\trval = QLA_NOT_LOGGED_IN;\n\t\t\tgoto gpd_error_out;\n\t\t}\n\n\t\t \n\t\tmemcpy(fcport->node_name, pd24->node_name, WWN_SIZE);\n\t\tmemcpy(fcport->port_name, pd24->port_name, WWN_SIZE);\n\n\t\t \n\t\tfcport->d_id.b.domain = pd24->port_id[0];\n\t\tfcport->d_id.b.area = pd24->port_id[1];\n\t\tfcport->d_id.b.al_pa = pd24->port_id[2];\n\t\tfcport->d_id.b.rsvd_1 = 0;\n\n\t\t \n\t\tif ((pd24->prli_svc_param_word_3[0] & BIT_4) == 0)\n\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\telse\n\t\t\tfcport->port_type = FCT_TARGET;\n\n\t\t \n\t\tfcport->supported_classes = (pd24->flags & PDF_CLASS_2) ?\n\t\t\t\tFC_COS_CLASS2 : FC_COS_CLASS3;\n\n\t\tif (pd24->prli_svc_param_word_3[0] & BIT_7)\n\t\t\tfcport->flags |= FCF_CONF_COMP_SUPPORTED;\n\t} else {\n\t\tuint64_t zero = 0;\n\n\t\t \n\t\tif (pd->master_state != PD_STATE_PORT_LOGGED_IN &&\n\t\t    pd->slave_state != PD_STATE_PORT_LOGGED_IN) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x100a,\n\t\t\t    \"Unable to verify login-state (%x/%x) - \"\n\t\t\t    \"portid=%02x%02x%02x.\\n\", pd->master_state,\n\t\t\t    pd->slave_state, fcport->d_id.b.domain,\n\t\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tgoto gpd_error_out;\n\t\t}\n\n\t\tif (fcport->loop_id == FC_NO_LOOP_ID ||\n\t\t    (memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&\n\t\t     memcmp(fcport->port_name, pd->port_name, 8))) {\n\t\t\t \n\t\t\trval = QLA_NOT_LOGGED_IN;\n\t\t\tgoto gpd_error_out;\n\t\t}\n\n\t\t \n\t\tmemcpy(fcport->node_name, pd->node_name, WWN_SIZE);\n\t\tmemcpy(fcport->port_name, pd->port_name, WWN_SIZE);\n\n\t\t \n\t\tfcport->d_id.b.domain = pd->port_id[0];\n\t\tfcport->d_id.b.area = pd->port_id[3];\n\t\tfcport->d_id.b.al_pa = pd->port_id[2];\n\t\tfcport->d_id.b.rsvd_1 = 0;\n\n\t\t \n\t\tif ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)\n\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\telse\n\t\t\tfcport->port_type = FCT_TARGET;\n\n\t\t \n\t\tfcport->supported_classes = (pd->options & BIT_4) ?\n\t\t    FC_COS_CLASS2 : FC_COS_CLASS3;\n\t}\n\ngpd_error_out:\n\tdma_pool_free(ha->s_dma_pool, pd, pd_dma);\n\tfcport->query = 0;\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1052,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\", rval,\n\t\t    mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1053,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla24xx_get_port_database(scsi_qla_host_t *vha, u16 nport_handle,\n\tstruct port_database_24xx *pdb)\n{\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tdma_addr_t pdb_dma;\n\tint rval;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1115,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(pdb, 0, sizeof(*pdb));\n\n\tpdb_dma = dma_map_single(&vha->hw->pdev->dev, pdb,\n\t    sizeof(*pdb), DMA_FROM_DEVICE);\n\tif (!pdb_dma) {\n\t\tql_log(ql_log_warn, vha, 0x1116, \"Failed to map dma buffer.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tmcp->mb[0] = MBC_GET_PORT_DATABASE;\n\tmcp->mb[1] = nport_handle;\n\tmcp->mb[2] = MSW(LSD(pdb_dma));\n\tmcp->mb[3] = LSW(LSD(pdb_dma));\n\tmcp->mb[6] = MSW(MSD(pdb_dma));\n\tmcp->mb[7] = LSW(MSD(pdb_dma));\n\tmcp->mb[9] = 0;\n\tmcp->mb[10] = 0;\n\tmcp->out_mb = MBX_10|MBX_9|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->buf_size = sizeof(*pdb);\n\tmcp->flags = MBX_DMA_IN;\n\tmcp->tov = vha->hw->login_timeout * 2;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x111a,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x111b,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\tdma_unmap_single(&vha->hw->pdev->dev, pdb_dma,\n\t    sizeof(*pdb), DMA_FROM_DEVICE);\n\n\treturn rval;\n}\n\n \nint\nqla2x00_get_firmware_state(scsi_qla_host_t *vha, uint16_t *states)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1054,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!ha->flags.fw_started)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_GET_FIRMWARE_STATE;\n\tmcp->out_mb = MBX_0;\n\tif (IS_FWI2_CAPABLE(vha->hw))\n\t\tmcp->in_mb = MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\telse\n\t\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\t \n\tstates[0] = mcp->mb[1];\n\tif (IS_FWI2_CAPABLE(vha->hw)) {\n\t\tstates[1] = mcp->mb[2];\n\t\tstates[2] = mcp->mb[3];   \n\t\tstates[3] = mcp->mb[4];\n\t\tstates[4] = mcp->mb[5];\n\t\tstates[5] = mcp->mb[6];   \n\t}\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1055, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tif (mcp->mb[2] == 6 || mcp->mb[3] == 2)\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x119e,\n\t\t\t\t    \"Invalid SFP/Validation Failed\\n\");\n\t\t}\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1056,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_get_port_name(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t *name,\n    uint8_t opt)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1057,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_PORT_NAME;\n\tmcp->mb[9] = vha->vp_idx;\n\tmcp->out_mb = MBX_9|MBX_1|MBX_0;\n\tif (HAS_EXTENDED_IDS(vha->hw)) {\n\t\tmcp->mb[1] = loop_id;\n\t\tmcp->mb[10] = opt;\n\t\tmcp->out_mb |= MBX_10;\n\t} else {\n\t\tmcp->mb[1] = loop_id << 8 | opt;\n\t}\n\n\tmcp->in_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1058, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tif (name != NULL) {\n\t\t\t \n\t\t\tname[0] = MSB(mcp->mb[2]);\n\t\t\tname[1] = LSB(mcp->mb[2]);\n\t\t\tname[2] = MSB(mcp->mb[3]);\n\t\t\tname[3] = LSB(mcp->mb[3]);\n\t\t\tname[4] = MSB(mcp->mb[6]);\n\t\t\tname[5] = LSB(mcp->mb[6]);\n\t\t\tname[6] = MSB(mcp->mb[7]);\n\t\t\tname[7] = LSB(mcp->mb[7]);\n\t\t}\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1059,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla24xx_link_initialize(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1152,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(vha->hw) || IS_CNA_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_LINK_INITIALIZATION;\n\tmcp->mb[1] = BIT_4;\n\tif (vha->hw->operating_mode == LOOP)\n\t\tmcp->mb[1] |= BIT_6;\n\telse\n\t\tmcp->mb[1] |= BIT_5;\n\tmcp->mb[2] = 0;\n\tmcp->mb[3] = 0;\n\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1153, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1154,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_lip_reset(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_disc, vha, 0x105a,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (IS_CNA_CAPABLE(vha->hw)) {\n\t\t \n\t\tmcp->mb[0] = MBC_LIP_FULL_LOGIN;\n\t\tmcp->mb[1] = BIT_1;\n\t\tmcp->mb[2] = 0;\n\t\tmcp->out_mb = MBX_2|MBX_1|MBX_0;\n\t} else if (IS_FWI2_CAPABLE(vha->hw)) {\n\t\tmcp->mb[0] = MBC_LIP_FULL_LOGIN;\n\t\tmcp->mb[1] = BIT_4;\n\t\tmcp->mb[2] = 0;\n\t\tmcp->mb[3] = vha->hw->loop_reset_delay;\n\t\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\t} else {\n\t\tmcp->mb[0] = MBC_LIP_RESET;\n\t\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\t\tif (HAS_EXTENDED_IDS(vha->hw)) {\n\t\t\tmcp->mb[1] = 0x00ff;\n\t\t\tmcp->mb[10] = 0;\n\t\t\tmcp->out_mb |= MBX_10;\n\t\t} else {\n\t\t\tmcp->mb[1] = 0xff00;\n\t\t}\n\t\tmcp->mb[2] = vha->hw->loop_reset_delay;\n\t\tmcp->mb[3] = 0;\n\t}\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x105b, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x105c,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_send_sns(scsi_qla_host_t *vha, dma_addr_t sns_phys_address,\n    uint16_t cmd_size, size_t buf_size)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x105d,\n\t    \"Entered %s.\\n\", __func__);\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x105e,\n\t    \"Retry cnt=%d ratov=%d total tov=%d.\\n\",\n\t    vha->hw->retry_count, vha->hw->login_timeout, mcp->tov);\n\n\tmcp->mb[0] = MBC_SEND_SNS_COMMAND;\n\tmcp->mb[1] = cmd_size;\n\tmcp->mb[2] = MSW(sns_phys_address);\n\tmcp->mb[3] = LSW(sns_phys_address);\n\tmcp->mb[6] = MSW(MSD(sns_phys_address));\n\tmcp->mb[7] = LSW(MSD(sns_phys_address));\n\tmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0|MBX_1;\n\tmcp->buf_size = buf_size;\n\tmcp->flags = MBX_DMA_OUT|MBX_DMA_IN;\n\tmcp->tov = (vha->hw->login_timeout * 2) + (vha->hw->login_timeout / 2);\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x105f,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1060,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla24xx_login_fabric(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,\n    uint8_t area, uint8_t al_pa, uint16_t *mb, uint8_t opt)\n{\n\tint\t\trval;\n\n\tstruct logio_entry_24xx *lg;\n\tdma_addr_t\tlg_dma;\n\tuint32_t\tiop[2];\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1061,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (vha->vp_idx && vha->qpair)\n\t\treq = vha->qpair->req;\n\telse\n\t\treq = ha->req_q_map[0];\n\n\tlg = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &lg_dma);\n\tif (lg == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x1062,\n\t\t    \"Failed to allocate login IOCB.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tlg->entry_type = LOGINOUT_PORT_IOCB_TYPE;\n\tlg->entry_count = 1;\n\tlg->handle = make_handle(req->id, lg->handle);\n\tlg->nport_handle = cpu_to_le16(loop_id);\n\tlg->control_flags = cpu_to_le16(LCF_COMMAND_PLOGI);\n\tif (opt & BIT_0)\n\t\tlg->control_flags |= cpu_to_le16(LCF_COND_PLOGI);\n\tif (opt & BIT_1)\n\t\tlg->control_flags |= cpu_to_le16(LCF_SKIP_PRLI);\n\tlg->port_id[0] = al_pa;\n\tlg->port_id[1] = area;\n\tlg->port_id[2] = domain;\n\tlg->vp_index = vha->vp_idx;\n\trval = qla2x00_issue_iocb_timeout(vha, lg, lg_dma, 0,\n\t    (ha->r_a_tov / 10 * 2) + 2);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1063,\n\t\t    \"Failed to issue login IOCB (%x).\\n\", rval);\n\t} else if (lg->entry_status != 0) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1064,\n\t\t    \"Failed to complete IOCB -- error status (%x).\\n\",\n\t\t    lg->entry_status);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else if (lg->comp_status != cpu_to_le16(CS_COMPLETE)) {\n\t\tiop[0] = le32_to_cpu(lg->io_parameter[0]);\n\t\tiop[1] = le32_to_cpu(lg->io_parameter[1]);\n\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1065,\n\t\t    \"Failed to complete IOCB -- completion  status (%x) \"\n\t\t    \"ioparam=%x/%x.\\n\", le16_to_cpu(lg->comp_status),\n\t\t    iop[0], iop[1]);\n\n\t\tswitch (iop[0]) {\n\t\tcase LSC_SCODE_PORTID_USED:\n\t\t\tmb[0] = MBS_PORT_ID_USED;\n\t\t\tmb[1] = LSW(iop[1]);\n\t\t\tbreak;\n\t\tcase LSC_SCODE_NPORT_USED:\n\t\t\tmb[0] = MBS_LOOP_ID_USED;\n\t\t\tbreak;\n\t\tcase LSC_SCODE_NOLINK:\n\t\tcase LSC_SCODE_NOIOCB:\n\t\tcase LSC_SCODE_NOXCB:\n\t\tcase LSC_SCODE_CMD_FAILED:\n\t\tcase LSC_SCODE_NOFABRIC:\n\t\tcase LSC_SCODE_FW_NOT_READY:\n\t\tcase LSC_SCODE_NOT_LOGGED_IN:\n\t\tcase LSC_SCODE_NOPCB:\n\t\tcase LSC_SCODE_ELS_REJECT:\n\t\tcase LSC_SCODE_CMD_PARAM_ERR:\n\t\tcase LSC_SCODE_NONPORT:\n\t\tcase LSC_SCODE_LOGGED_IN:\n\t\tcase LSC_SCODE_NOFLOGI_ACC:\n\t\tdefault:\n\t\t\tmb[0] = MBS_COMMAND_ERROR;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1066,\n\t\t    \"Done %s.\\n\", __func__);\n\n\t\tiop[0] = le32_to_cpu(lg->io_parameter[0]);\n\n\t\tmb[0] = MBS_COMMAND_COMPLETE;\n\t\tmb[1] = 0;\n\t\tif (iop[0] & BIT_4) {\n\t\t\tif (iop[0] & BIT_8)\n\t\t\t\tmb[1] |= BIT_1;\n\t\t} else\n\t\t\tmb[1] = BIT_0;\n\n\t\t \n\t\tmb[10] = 0;\n\t\tif (lg->io_parameter[7] || lg->io_parameter[8])\n\t\t\tmb[10] |= BIT_0;\t \n\t\tif (lg->io_parameter[9] || lg->io_parameter[10])\n\t\t\tmb[10] |= BIT_1;\t \n\t\tif (lg->io_parameter[0] & cpu_to_le32(BIT_7))\n\t\t\tmb[10] |= BIT_7;\t \n\t}\n\n\tdma_pool_free(ha->s_dma_pool, lg, lg_dma);\n\n\treturn rval;\n}\n\n \nint\nqla2x00_login_fabric(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,\n    uint8_t area, uint8_t al_pa, uint16_t *mb, uint8_t opt)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1067,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_LOGIN_FABRIC_PORT;\n\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tif (HAS_EXTENDED_IDS(ha)) {\n\t\tmcp->mb[1] = loop_id;\n\t\tmcp->mb[10] = opt;\n\t\tmcp->out_mb |= MBX_10;\n\t} else {\n\t\tmcp->mb[1] = (loop_id << 8) | opt;\n\t}\n\tmcp->mb[2] = domain;\n\tmcp->mb[3] = area << 8 | al_pa;\n\n\tmcp->in_mb = MBX_7|MBX_6|MBX_2|MBX_1|MBX_0;\n\tmcp->tov = (ha->login_timeout * 2) + (ha->login_timeout / 2);\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\t \n\tif (mb != NULL) {\n\t\tmb[0] = mcp->mb[0];\n\t\tmb[1] = mcp->mb[1];\n\t\tmb[2] = mcp->mb[2];\n\t\tmb[6] = mcp->mb[6];\n\t\tmb[7] = mcp->mb[7];\n\t\t \n\t\tmb[10] = 0;\n\t}\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tif (mcp->mb[0] == 0x4001 || mcp->mb[0] == 0x4002 ||\n\t\t    mcp->mb[0] == 0x4003 || mcp->mb[0] == 0x4005 ||\n\t\t    mcp->mb[0] == 0x4006)\n\t\t\trval = QLA_SUCCESS;\n\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1068,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1069,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_login_local_device(scsi_qla_host_t *vha, fc_port_t *fcport,\n    uint16_t *mb_ret, uint8_t opt)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x106a,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (IS_FWI2_CAPABLE(ha))\n\t\treturn qla24xx_login_fabric(vha, fcport->loop_id,\n\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t    fcport->d_id.b.al_pa, mb_ret, opt);\n\n\tmcp->mb[0] = MBC_LOGIN_LOOP_PORT;\n\tif (HAS_EXTENDED_IDS(ha))\n\t\tmcp->mb[1] = fcport->loop_id;\n\telse\n\t\tmcp->mb[1] = fcport->loop_id << 8;\n\tmcp->mb[2] = opt;\n\tmcp->out_mb = MBX_2|MBX_1|MBX_0;\n \tmcp->in_mb = MBX_7|MBX_6|MBX_1|MBX_0;\n\tmcp->tov = (ha->login_timeout * 2) + (ha->login_timeout / 2);\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n \t \n \tif (mb_ret != NULL) {\n \t\tmb_ret[0] = mcp->mb[0];\n \t\tmb_ret[1] = mcp->mb[1];\n \t\tmb_ret[6] = mcp->mb[6];\n \t\tmb_ret[7] = mcp->mb[7];\n \t}\n\n\tif (rval != QLA_SUCCESS) {\n \t\t \n \t\tif (mcp->mb[0] == 0x4005 || mcp->mb[0] == 0x4006)\n \t\t\trval = QLA_SUCCESS;\n\n\t\tql_dbg(ql_dbg_mbx, vha, 0x106b,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x mb[6]=%x mb[7]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1], mcp->mb[6], mcp->mb[7]);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x106c,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn (rval);\n}\n\nint\nqla24xx_fabric_logout(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,\n    uint8_t area, uint8_t al_pa)\n{\n\tint\t\trval;\n\tstruct logio_entry_24xx *lg;\n\tdma_addr_t\tlg_dma;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x106d,\n\t    \"Entered %s.\\n\", __func__);\n\n\tlg = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &lg_dma);\n\tif (lg == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x106e,\n\t\t    \"Failed to allocate logout IOCB.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\treq = vha->req;\n\tlg->entry_type = LOGINOUT_PORT_IOCB_TYPE;\n\tlg->entry_count = 1;\n\tlg->handle = make_handle(req->id, lg->handle);\n\tlg->nport_handle = cpu_to_le16(loop_id);\n\tlg->control_flags =\n\t    cpu_to_le16(LCF_COMMAND_LOGO|LCF_IMPL_LOGO|\n\t\tLCF_FREE_NPORT);\n\tlg->port_id[0] = al_pa;\n\tlg->port_id[1] = area;\n\tlg->port_id[2] = domain;\n\tlg->vp_index = vha->vp_idx;\n\trval = qla2x00_issue_iocb_timeout(vha, lg, lg_dma, 0,\n\t    (ha->r_a_tov / 10 * 2) + 2);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x106f,\n\t\t    \"Failed to issue logout IOCB (%x).\\n\", rval);\n\t} else if (lg->entry_status != 0) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1070,\n\t\t    \"Failed to complete IOCB -- error status (%x).\\n\",\n\t\t    lg->entry_status);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else if (lg->comp_status != cpu_to_le16(CS_COMPLETE)) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1071,\n\t\t    \"Failed to complete IOCB -- completion status (%x) \"\n\t\t    \"ioparam=%x/%x.\\n\", le16_to_cpu(lg->comp_status),\n\t\t    le32_to_cpu(lg->io_parameter[0]),\n\t\t    le32_to_cpu(lg->io_parameter[1]));\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1072,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\tdma_pool_free(ha->s_dma_pool, lg, lg_dma);\n\n\treturn rval;\n}\n\n \nint\nqla2x00_fabric_logout(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,\n    uint8_t area, uint8_t al_pa)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1073,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_LOGOUT_FABRIC_PORT;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tif (HAS_EXTENDED_IDS(vha->hw)) {\n\t\tmcp->mb[1] = loop_id;\n\t\tmcp->mb[10] = 0;\n\t\tmcp->out_mb |= MBX_10;\n\t} else {\n\t\tmcp->mb[1] = loop_id << 8;\n\t}\n\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1074,\n\t\t    \"Failed=%x mb[1]=%x.\\n\", rval, mcp->mb[1]);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1075,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_full_login_lip(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1076,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_LIP_FULL_LOGIN;\n\tmcp->mb[1] = IS_FWI2_CAPABLE(vha->hw) ? BIT_4 : 0;\n\tmcp->mb[2] = 0;\n\tmcp->mb[3] = 0;\n\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1077, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1078,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_get_id_list(scsi_qla_host_t *vha, void *id_list, dma_addr_t id_list_dma,\n    uint16_t *entries)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1079,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (id_list == NULL)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_GET_ID_LIST;\n\tmcp->out_mb = MBX_0;\n\tif (IS_FWI2_CAPABLE(vha->hw)) {\n\t\tmcp->mb[2] = MSW(id_list_dma);\n\t\tmcp->mb[3] = LSW(id_list_dma);\n\t\tmcp->mb[6] = MSW(MSD(id_list_dma));\n\t\tmcp->mb[7] = LSW(MSD(id_list_dma));\n\t\tmcp->mb[8] = 0;\n\t\tmcp->mb[9] = vha->vp_idx;\n\t\tmcp->out_mb |= MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2;\n\t} else {\n\t\tmcp->mb[1] = MSW(id_list_dma);\n\t\tmcp->mb[2] = LSW(id_list_dma);\n\t\tmcp->mb[3] = MSW(MSD(id_list_dma));\n\t\tmcp->mb[6] = LSW(MSD(id_list_dma));\n\t\tmcp->out_mb |= MBX_6|MBX_3|MBX_2|MBX_1;\n\t}\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x107a, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\t*entries = mcp->mb[1];\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x107b,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_get_resource_cnts(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x107c,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_RESOURCE_COUNTS;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_11|MBX_10|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tif (IS_QLA81XX(ha) || IS_QLA83XX(ha) ||\n\t    IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tmcp->in_mb |= MBX_12;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x107d,\n\t\t    \"Failed mb[0]=%x.\\n\", mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x107e,\n\t\t    \"Done %s mb1=%x mb2=%x mb3=%x mb6=%x mb7=%x mb10=%x \"\n\t\t    \"mb11=%x mb12=%x.\\n\", __func__, mcp->mb[1], mcp->mb[2],\n\t\t    mcp->mb[3], mcp->mb[6], mcp->mb[7], mcp->mb[10],\n\t\t    mcp->mb[11], mcp->mb[12]);\n\n\t\tha->orig_fw_tgt_xcb_count =  mcp->mb[1];\n\t\tha->cur_fw_tgt_xcb_count = mcp->mb[2];\n\t\tha->cur_fw_xcb_count = mcp->mb[3];\n\t\tha->orig_fw_xcb_count = mcp->mb[6];\n\t\tha->cur_fw_iocb_count = mcp->mb[7];\n\t\tha->orig_fw_iocb_count = mcp->mb[10];\n\t\tif (ha->flags.npiv_supported)\n\t\t\tha->max_npiv_vports = mcp->mb[11];\n\t\tif (IS_QLA81XX(ha) || IS_QLA83XX(ha))\n\t\t\tha->fw_max_fcf_count = mcp->mb[12];\n\t}\n\n\treturn (rval);\n}\n\n \nint\nqla2x00_get_fcal_position_map(scsi_qla_host_t *vha, char *pos_map,\n\t\tu8 *num_entries)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tchar *pmap;\n\tdma_addr_t pmap_dma;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x107f,\n\t    \"Entered %s.\\n\", __func__);\n\n\tpmap = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &pmap_dma);\n\tif (pmap  == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x1080,\n\t\t    \"Memory alloc failed.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tmcp->mb[0] = MBC_GET_FC_AL_POSITION_MAP;\n\tmcp->mb[2] = MSW(pmap_dma);\n\tmcp->mb[3] = LSW(pmap_dma);\n\tmcp->mb[6] = MSW(MSD(pmap_dma));\n\tmcp->mb[7] = LSW(MSD(pmap_dma));\n\tmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->buf_size = FCAL_MAP_SIZE;\n\tmcp->flags = MBX_DMA_IN;\n\tmcp->tov = (ha->login_timeout * 2) + (ha->login_timeout / 2);\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1081,\n\t\t    \"mb0/mb1=%x/%X FC/AL position map size (%x).\\n\",\n\t\t    mcp->mb[0], mcp->mb[1], (unsigned)pmap[0]);\n\t\tql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x111d,\n\t\t    pmap, pmap[0] + 1);\n\n\t\tif (pos_map)\n\t\t\tmemcpy(pos_map, pmap, FCAL_MAP_SIZE);\n\t\tif (num_entries)\n\t\t\t*num_entries = pmap[0];\n\t}\n\tdma_pool_free(ha->s_dma_pool, pmap, pmap_dma);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1082, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1083,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_get_link_status(scsi_qla_host_t *vha, uint16_t loop_id,\n    struct link_statistics *stats, dma_addr_t stats_dma)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tuint32_t *iter = (uint32_t *)stats;\n\tushort dwords = offsetof(typeof(*stats), link_up_cnt)/sizeof(*iter);\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1084,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_LINK_STATUS;\n\tmcp->mb[2] = MSW(LSD(stats_dma));\n\tmcp->mb[3] = LSW(LSD(stats_dma));\n\tmcp->mb[6] = MSW(MSD(stats_dma));\n\tmcp->mb[7] = LSW(MSD(stats_dma));\n\tmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tmcp->mb[1] = loop_id;\n\t\tmcp->mb[4] = 0;\n\t\tmcp->mb[10] = 0;\n\t\tmcp->out_mb |= MBX_10|MBX_4|MBX_1;\n\t\tmcp->in_mb |= MBX_1;\n\t} else if (HAS_EXTENDED_IDS(ha)) {\n\t\tmcp->mb[1] = loop_id;\n\t\tmcp->mb[10] = 0;\n\t\tmcp->out_mb |= MBX_10|MBX_1;\n\t} else {\n\t\tmcp->mb[1] = loop_id << 8;\n\t\tmcp->out_mb |= MBX_1;\n\t}\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = IOCTL_CMD;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tif (mcp->mb[0] != MBS_COMMAND_COMPLETE) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1085,\n\t\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1086,\n\t\t\t    \"Done %s.\\n\", __func__);\n\t\t\tfor ( ; dwords--; iter++)\n\t\t\t\tle32_to_cpus(iter);\n\t\t}\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x1087, \"Failed=%x.\\n\", rval);\n\t}\n\n\treturn rval;\n}\n\nint\nqla24xx_get_isp_stats(scsi_qla_host_t *vha, struct link_statistics *stats,\n    dma_addr_t stats_dma, uint16_t options)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tuint32_t *iter = (uint32_t *)stats;\n\tushort dwords = sizeof(*stats)/sizeof(*iter);\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1088,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(&mc, 0, sizeof(mc));\n\tmc.mb[0] = MBC_GET_LINK_PRIV_STATS;\n\tmc.mb[2] = MSW(LSD(stats_dma));\n\tmc.mb[3] = LSW(LSD(stats_dma));\n\tmc.mb[6] = MSW(MSD(stats_dma));\n\tmc.mb[7] = LSW(MSD(stats_dma));\n\tmc.mb[8] = dwords;\n\tmc.mb[9] = vha->vp_idx;\n\tmc.mb[10] = options;\n\n\trval = qla24xx_send_mb_cmd(vha, &mc);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tif (mcp->mb[0] != MBS_COMMAND_COMPLETE) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1089,\n\t\t\t    \"Failed mb[0]=%x.\\n\", mcp->mb[0]);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x108a,\n\t\t\t    \"Done %s.\\n\", __func__);\n\t\t\t \n\t\t\tfor ( ; dwords--; iter++)\n\t\t\t\tle32_to_cpus(iter);\n\t\t}\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x108b, \"Failed=%x.\\n\", rval);\n\t}\n\n\treturn rval;\n}\n\nint\nqla24xx_abort_command(srb_t *sp)\n{\n\tint\t\trval;\n\tunsigned long   flags = 0;\n\n\tstruct abort_entry_24xx *abt;\n\tdma_addr_t\tabt_dma;\n\tuint32_t\thandle;\n\tfc_port_t\t*fcport = sp->fcport;\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req;\n\tstruct qla_qpair *qpair = sp->qpair;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x108c,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (sp->qpair)\n\t\treq = sp->qpair->req;\n\telse\n\t\treturn QLA_ERR_NO_QPAIR;\n\n\tif (ql2xasynctmfenable)\n\t\treturn qla24xx_async_abort_command(sp);\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tfor (handle = 1; handle < req->num_outstanding_cmds; handle++) {\n\t\tif (req->outstanding_cmds[handle] == sp)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\tif (handle == req->num_outstanding_cmds) {\n\t\t \n\t\treturn QLA_ERR_NOT_FOUND;\n\t}\n\n\tabt = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &abt_dma);\n\tif (abt == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x108d,\n\t\t    \"Failed to allocate abort IOCB.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tabt->entry_type = ABORT_IOCB_TYPE;\n\tabt->entry_count = 1;\n\tabt->handle = make_handle(req->id, abt->handle);\n\tabt->nport_handle = cpu_to_le16(fcport->loop_id);\n\tabt->handle_to_abort = make_handle(req->id, handle);\n\tabt->port_id[0] = fcport->d_id.b.al_pa;\n\tabt->port_id[1] = fcport->d_id.b.area;\n\tabt->port_id[2] = fcport->d_id.b.domain;\n\tabt->vp_index = fcport->vha->vp_idx;\n\n\tabt->req_que_no = cpu_to_le16(req->id);\n\t \n\tqla_nvme_abort_set_option(abt, sp);\n\n\trval = qla2x00_issue_iocb(vha, abt, abt_dma, 0);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x108e,\n\t\t    \"Failed to issue IOCB (%x).\\n\", rval);\n\t} else if (abt->entry_status != 0) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x108f,\n\t\t    \"Failed to complete IOCB -- error status (%x).\\n\",\n\t\t    abt->entry_status);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else if (abt->nport_handle != cpu_to_le16(0)) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1090,\n\t\t    \"Failed to complete IOCB -- completion status (%x).\\n\",\n\t\t    le16_to_cpu(abt->nport_handle));\n\t\tif (abt->nport_handle == cpu_to_le16(CS_IOCB_ERROR))\n\t\t\trval = QLA_FUNCTION_PARAMETER_ERROR;\n\t\telse\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1091,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\tif (rval == QLA_SUCCESS)\n\t\tqla_nvme_abort_process_comp_status(abt, sp);\n\n\tqla_wait_nvme_release_cmd_kref(sp);\n\n\tdma_pool_free(ha->s_dma_pool, abt, abt_dma);\n\n\treturn rval;\n}\n\nstruct tsk_mgmt_cmd {\n\tunion {\n\t\tstruct tsk_mgmt_entry tsk;\n\t\tstruct sts_entry_24xx sts;\n\t} p;\n};\n\nstatic int\n__qla24xx_issue_tmf(char *name, uint32_t type, struct fc_port *fcport,\n    uint64_t l, int tag)\n{\n\tint\t\trval, rval2;\n\tstruct tsk_mgmt_cmd *tsk;\n\tstruct sts_entry_24xx *sts;\n\tdma_addr_t\ttsk_dma;\n\tscsi_qla_host_t *vha;\n\tstruct qla_hw_data *ha;\n\tstruct req_que *req;\n\tstruct qla_qpair *qpair;\n\n\tvha = fcport->vha;\n\tha = vha->hw;\n\treq = vha->req;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1092,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (vha->vp_idx && vha->qpair) {\n\t\t \n\t\tqpair = vha->qpair;\n\t\treq = qpair->req;\n\t}\n\n\ttsk = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &tsk_dma);\n\tif (tsk == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x1093,\n\t\t    \"Failed to allocate task management IOCB.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\ttsk->p.tsk.entry_type = TSK_MGMT_IOCB_TYPE;\n\ttsk->p.tsk.entry_count = 1;\n\ttsk->p.tsk.handle = make_handle(req->id, tsk->p.tsk.handle);\n\ttsk->p.tsk.nport_handle = cpu_to_le16(fcport->loop_id);\n\ttsk->p.tsk.timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\n\ttsk->p.tsk.control_flags = cpu_to_le32(type);\n\ttsk->p.tsk.port_id[0] = fcport->d_id.b.al_pa;\n\ttsk->p.tsk.port_id[1] = fcport->d_id.b.area;\n\ttsk->p.tsk.port_id[2] = fcport->d_id.b.domain;\n\ttsk->p.tsk.vp_index = fcport->vha->vp_idx;\n\tif (type == TCF_LUN_RESET) {\n\t\tint_to_scsilun(l, &tsk->p.tsk.lun);\n\t\thost_to_fcp_swap((uint8_t *)&tsk->p.tsk.lun,\n\t\t    sizeof(tsk->p.tsk.lun));\n\t}\n\n\tsts = &tsk->p.sts;\n\trval = qla2x00_issue_iocb(vha, tsk, tsk_dma, 0);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1094,\n\t\t    \"Failed to issue %s reset IOCB (%x).\\n\", name, rval);\n\t} else if (sts->entry_status != 0) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1095,\n\t\t    \"Failed to complete IOCB -- error status (%x).\\n\",\n\t\t    sts->entry_status);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else if (sts->comp_status != cpu_to_le16(CS_COMPLETE)) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1096,\n\t\t    \"Failed to complete IOCB -- completion status (%x).\\n\",\n\t\t    le16_to_cpu(sts->comp_status));\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else if (le16_to_cpu(sts->scsi_status) &\n\t    SS_RESPONSE_INFO_LEN_VALID) {\n\t\tif (le32_to_cpu(sts->rsp_data_len) < 4) {\n\t\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1097,\n\t\t\t    \"Ignoring inconsistent data length -- not enough \"\n\t\t\t    \"response info (%d).\\n\",\n\t\t\t    le32_to_cpu(sts->rsp_data_len));\n\t\t} else if (sts->data[3]) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1098,\n\t\t\t    \"Failed to complete IOCB -- response (%x).\\n\",\n\t\t\t    sts->data[3]);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\n\t \n\trval2 = qla2x00_marker(vha, ha->base_qpair, fcport->loop_id, l,\n\t    type == TCF_LUN_RESET ? MK_SYNC_ID_LUN : MK_SYNC_ID);\n\tif (rval2 != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1099,\n\t\t    \"Failed to issue marker IOCB (%x).\\n\", rval2);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x109a,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\tdma_pool_free(ha->s_dma_pool, tsk, tsk_dma);\n\n\treturn rval;\n}\n\nint\nqla24xx_abort_target(struct fc_port *fcport, uint64_t l, int tag)\n{\n\tstruct qla_hw_data *ha = fcport->vha->hw;\n\n\tif ((ql2xasynctmfenable) && IS_FWI2_CAPABLE(ha))\n\t\treturn qla2x00_async_tm_cmd(fcport, TCF_TARGET_RESET, l, tag);\n\n\treturn __qla24xx_issue_tmf(\"Target\", TCF_TARGET_RESET, fcport, l, tag);\n}\n\nint\nqla24xx_lun_reset(struct fc_port *fcport, uint64_t l, int tag)\n{\n\tstruct qla_hw_data *ha = fcport->vha->hw;\n\n\tif ((ql2xasynctmfenable) && IS_FWI2_CAPABLE(ha))\n\t\treturn qla2x00_async_tm_cmd(fcport, TCF_LUN_RESET, l, tag);\n\n\treturn __qla24xx_issue_tmf(\"Lun\", TCF_LUN_RESET, fcport, l, tag);\n}\n\nint\nqla2x00_system_error(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA23XX(ha) && !IS_FWI2_CAPABLE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x109b,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GEN_SYSTEM_ERROR;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = 5;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x109c, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x109d,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_write_serdes_word(scsi_qla_host_t *vha, uint16_t addr, uint16_t data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA25XX(vha->hw) && !IS_QLA2031(vha->hw) &&\n\t    !IS_QLA27XX(vha->hw) && !IS_QLA28XX(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1182,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_WRITE_SERDES;\n\tmcp->mb[1] = addr;\n\tif (IS_QLA2031(vha->hw))\n\t\tmcp->mb[2] = data & 0xff;\n\telse\n\t\tmcp->mb[2] = data;\n\n\tmcp->mb[3] = 0;\n\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1183,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1184,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_read_serdes_word(scsi_qla_host_t *vha, uint16_t addr, uint16_t *data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA25XX(vha->hw) && !IS_QLA2031(vha->hw) &&\n\t    !IS_QLA27XX(vha->hw) && !IS_QLA28XX(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1185,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_READ_SERDES;\n\tmcp->mb[1] = addr;\n\tmcp->mb[3] = 0;\n\tmcp->out_mb = MBX_3|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (IS_QLA2031(vha->hw))\n\t\t*data = mcp->mb[1] & 0xff;\n\telse\n\t\t*data = mcp->mb[1];\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1186,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1187,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla8044_write_serdes_word(scsi_qla_host_t *vha, uint32_t addr, uint32_t data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA8044(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x11a0,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_SET_GET_ETH_SERDES_REG;\n\tmcp->mb[1] = HCS_WRITE_SERDES;\n\tmcp->mb[3] = LSW(addr);\n\tmcp->mb[4] = MSW(addr);\n\tmcp->mb[5] = LSW(data);\n\tmcp->mb[6] = MSW(data);\n\tmcp->out_mb = MBX_6|MBX_5|MBX_4|MBX_3|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x11a1,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1188,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla8044_read_serdes_word(scsi_qla_host_t *vha, uint32_t addr, uint32_t *data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA8044(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1189,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_SET_GET_ETH_SERDES_REG;\n\tmcp->mb[1] = HCS_READ_SERDES;\n\tmcp->mb[3] = LSW(addr);\n\tmcp->mb[4] = MSW(addr);\n\tmcp->out_mb = MBX_4|MBX_3|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\t*data = mcp->mb[2] << 16 | mcp->mb[1];\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x118a,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118b,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_set_serdes_params(scsi_qla_host_t *vha, uint16_t sw_em_1g,\n    uint16_t sw_em_2g, uint16_t sw_em_4g)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x109e,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_SERDES_PARAMS;\n\tmcp->mb[1] = BIT_0;\n\tmcp->mb[2] = sw_em_1g | BIT_15;\n\tmcp->mb[3] = sw_em_2g | BIT_15;\n\tmcp->mb[4] = sw_em_4g | BIT_15;\n\tmcp->out_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_mbx, vha, 0x109f,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a0,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_stop_firmware(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a1,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_STOP_FIRMWARE;\n\tmcp->mb[1] = 0;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = 5;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10a2, \"Failed=%x.\\n\", rval);\n\t\tif (mcp->mb[0] == MBS_INVALID_COMMAND)\n\t\t\trval = QLA_INVALID_COMMAND;\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a3,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_enable_eft_trace(scsi_qla_host_t *vha, dma_addr_t eft_dma,\n    uint16_t buffers)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a4,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif (unlikely(pci_channel_offline(vha->hw->pdev)))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_TRACE_CONTROL;\n\tmcp->mb[1] = TC_EFT_ENABLE;\n\tmcp->mb[2] = LSW(eft_dma);\n\tmcp->mb[3] = MSW(eft_dma);\n\tmcp->mb[4] = LSW(MSD(eft_dma));\n\tmcp->mb[5] = MSW(MSD(eft_dma));\n\tmcp->mb[6] = buffers;\n\tmcp->mb[7] = TC_AEN_DISABLE;\n\tmcp->out_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10a5,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a6,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_disable_eft_trace(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a7,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif (unlikely(pci_channel_offline(vha->hw->pdev)))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_TRACE_CONTROL;\n\tmcp->mb[1] = TC_EFT_DISABLE;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10a8,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a9,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_enable_fce_trace(scsi_qla_host_t *vha, dma_addr_t fce_dma,\n    uint16_t buffers, uint16_t *mb, uint32_t *dwords)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10aa,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_QLA25XX(vha->hw) && !IS_QLA81XX(vha->hw) &&\n\t    !IS_QLA83XX(vha->hw) && !IS_QLA27XX(vha->hw) &&\n\t    !IS_QLA28XX(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif (unlikely(pci_channel_offline(vha->hw->pdev)))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_TRACE_CONTROL;\n\tmcp->mb[1] = TC_FCE_ENABLE;\n\tmcp->mb[2] = LSW(fce_dma);\n\tmcp->mb[3] = MSW(fce_dma);\n\tmcp->mb[4] = LSW(MSD(fce_dma));\n\tmcp->mb[5] = MSW(MSD(fce_dma));\n\tmcp->mb[6] = buffers;\n\tmcp->mb[7] = TC_AEN_DISABLE;\n\tmcp->mb[8] = 0;\n\tmcp->mb[9] = TC_FCE_DEFAULT_RX_SIZE;\n\tmcp->mb[10] = TC_FCE_DEFAULT_TX_SIZE;\n\tmcp->out_mb = MBX_10|MBX_9|MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|\n\t    MBX_1|MBX_0;\n\tmcp->in_mb = MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10ab,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ac,\n\t\t    \"Done %s.\\n\", __func__);\n\n\t\tif (mb)\n\t\t\tmemcpy(mb, mcp->mb, 8 * sizeof(*mb));\n\t\tif (dwords)\n\t\t\t*dwords = buffers;\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_disable_fce_trace(scsi_qla_host_t *vha, uint64_t *wr, uint64_t *rd)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ad,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif (unlikely(pci_channel_offline(vha->hw->pdev)))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_TRACE_CONTROL;\n\tmcp->mb[1] = TC_FCE_DISABLE;\n\tmcp->mb[2] = TC_FCE_DISABLE_TRACE;\n\tmcp->out_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|\n\t    MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10ae,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10af,\n\t\t    \"Done %s.\\n\", __func__);\n\n\t\tif (wr)\n\t\t\t*wr = (uint64_t) mcp->mb[5] << 48 |\n\t\t\t    (uint64_t) mcp->mb[4] << 32 |\n\t\t\t    (uint64_t) mcp->mb[3] << 16 |\n\t\t\t    (uint64_t) mcp->mb[2];\n\t\tif (rd)\n\t\t\t*rd = (uint64_t) mcp->mb[9] << 48 |\n\t\t\t    (uint64_t) mcp->mb[8] << 32 |\n\t\t\t    (uint64_t) mcp->mb[7] << 16 |\n\t\t\t    (uint64_t) mcp->mb[6];\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_get_idma_speed(scsi_qla_host_t *vha, uint16_t loop_id,\n\tuint16_t *port_speed, uint16_t *mb)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b0,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_IIDMA_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_PORT_PARAMS;\n\tmcp->mb[1] = loop_id;\n\tmcp->mb[2] = mcp->mb[3] = 0;\n\tmcp->mb[9] = vha->vp_idx;\n\tmcp->out_mb = MBX_9|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_3|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\t \n\tif (mb) {\n\t\tmb[0] = mcp->mb[0];\n\t\tmb[1] = mcp->mb[1];\n\t\tmb[3] = mcp->mb[3];\n\t}\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10b1, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b2,\n\t\t    \"Done %s.\\n\", __func__);\n\t\tif (port_speed)\n\t\t\t*port_speed = mcp->mb[3];\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_set_idma_speed(scsi_qla_host_t *vha, uint16_t loop_id,\n    uint16_t port_speed, uint16_t *mb)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b3,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_IIDMA_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_PORT_PARAMS;\n\tmcp->mb[1] = loop_id;\n\tmcp->mb[2] = BIT_0;\n\tmcp->mb[3] = port_speed & 0x3F;\n\tmcp->mb[9] = vha->vp_idx;\n\tmcp->out_mb = MBX_9|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_3|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\t \n\tif (mb) {\n\t\tmb[0] = mcp->mb[0];\n\t\tmb[1] = mcp->mb[1];\n\t\tmb[3] = mcp->mb[3];\n\t}\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10b4,\n\t\t    \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b5,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nvoid\nqla24xx_report_id_acquisition(scsi_qla_host_t *vha,\n\tstruct vp_rpt_id_entry_24xx *rptid_entry)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *vp = NULL;\n\tunsigned long   flags;\n\tint found;\n\tport_id_t id;\n\tstruct fc_port *fcport;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b6,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (rptid_entry->entry_status != 0)\n\t\treturn;\n\n\tid.b.domain = rptid_entry->port_id[2];\n\tid.b.area   = rptid_entry->port_id[1];\n\tid.b.al_pa  = rptid_entry->port_id[0];\n\tid.b.rsvd_1 = 0;\n\tha->flags.n2n_ae = 0;\n\n\tif (rptid_entry->format == 0) {\n\t\t \n\t\tql_dbg(ql_dbg_async, vha, 0x10b7,\n\t\t    \"Format 0 : Number of VPs setup %d, number of \"\n\t\t    \"VPs acquired %d.\\n\", rptid_entry->vp_setup,\n\t\t    rptid_entry->vp_acquired);\n\t\tql_dbg(ql_dbg_async, vha, 0x10b8,\n\t\t    \"Primary port id %02x%02x%02x.\\n\",\n\t\t    rptid_entry->port_id[2], rptid_entry->port_id[1],\n\t\t    rptid_entry->port_id[0]);\n\t\tha->current_topology = ISP_CFG_NL;\n\t\tqla_update_host_map(vha, id);\n\n\t} else if (rptid_entry->format == 1) {\n\t\t \n\t\tql_dbg(ql_dbg_async, vha, 0x10b9,\n\t\t    \"Format 1: VP[%d] enabled - status %d - with \"\n\t\t    \"port id %02x%02x%02x.\\n\", rptid_entry->vp_idx,\n\t\t\trptid_entry->vp_status,\n\t\t    rptid_entry->port_id[2], rptid_entry->port_id[1],\n\t\t    rptid_entry->port_id[0]);\n\t\tql_dbg(ql_dbg_async, vha, 0x5075,\n\t\t   \"Format 1: Remote WWPN %8phC.\\n\",\n\t\t   rptid_entry->u.f1.port_name);\n\n\t\tql_dbg(ql_dbg_async, vha, 0x5075,\n\t\t   \"Format 1: WWPN %8phC.\\n\",\n\t\t   vha->port_name);\n\n\t\tswitch (rptid_entry->u.f1.flags & TOPO_MASK) {\n\t\tcase TOPO_N2N:\n\t\t\tha->current_topology = ISP_CFG_N;\n\t\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\t\tfcport->scan_state = QLA_FCPORT_SCAN;\n\t\t\t\tfcport->n2n_flag = 0;\n\t\t\t}\n\t\t\tid.b24 = 0;\n\t\t\tif (wwn_to_u64(vha->port_name) >\n\t\t\t    wwn_to_u64(rptid_entry->u.f1.port_name)) {\n\t\t\t\tvha->d_id.b24 = 0;\n\t\t\t\tvha->d_id.b.al_pa = 1;\n\t\t\t\tha->flags.n2n_bigger = 1;\n\n\t\t\t\tid.b.al_pa = 2;\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x5075,\n\t\t\t\t    \"Format 1: assign local id %x remote id %x\\n\",\n\t\t\t\t    vha->d_id.b24, id.b24);\n\t\t\t} else {\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x5075,\n\t\t\t\t    \"Format 1: Remote login - Waiting for WWPN %8phC.\\n\",\n\t\t\t\t    rptid_entry->u.f1.port_name);\n\t\t\t\tha->flags.n2n_bigger = 0;\n\t\t\t}\n\n\t\t\tfcport = qla2x00_find_fcport_by_wwpn(vha,\n\t\t\t    rptid_entry->u.f1.port_name, 1);\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\n\t\t\tif (fcport) {\n\t\t\t\tfcport->plogi_nack_done_deadline = jiffies + HZ;\n\t\t\t\tfcport->dm_login_expire = jiffies +\n\t\t\t\t\tQLA_N2N_WAIT_TIME * HZ;\n\t\t\t\tfcport->scan_state = QLA_FCPORT_FOUND;\n\t\t\t\tfcport->n2n_flag = 1;\n\t\t\t\tfcport->keep_nport_handle = 1;\n\t\t\t\tfcport->login_retry = vha->hw->login_retry_count;\n\t\t\t\tfcport->fc4_type = FS_FC4TYPE_FCP;\n\t\t\t\tif (vha->flags.nvme_enabled)\n\t\t\t\t\tfcport->fc4_type |= FS_FC4TYPE_NVME;\n\n\t\t\t\tif (wwn_to_u64(vha->port_name) >\n\t\t\t\t    wwn_to_u64(fcport->port_name)) {\n\t\t\t\t\tfcport->d_id = id;\n\t\t\t\t}\n\n\t\t\t\tswitch (fcport->disc_state) {\n\t\t\t\tcase DSC_DELETED:\n\t\t\t\t\tset_bit(RELOGIN_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DSC_DELETE_PEND:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tqla24xx_post_newsess_work(vha, &id,\n\t\t\t\t    rptid_entry->u.f1.port_name,\n\t\t\t\t    rptid_entry->u.f1.node_name,\n\t\t\t\t    NULL,\n\t\t\t\t    FS_FCP_IS_N2N);\n\t\t\t}\n\n\t\t\t \n\n\t\t\tset_bit(N2N_LOGIN_NEEDED, &vha->dpc_flags);\n\t\t\treturn;\n\t\tcase TOPO_FL:\n\t\t\tha->current_topology = ISP_CFG_FL;\n\t\t\tbreak;\n\t\tcase TOPO_F:\n\t\t\tha->current_topology = ISP_CFG_F;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tha->flags.gpsc_supported = 1;\n\t\tha->current_topology = ISP_CFG_F;\n\t\t \n\t\tvha->flags.bbcr_enable = (rptid_entry->u.f1.bbcr & 0xf) != 0;\n\n\t\tif (rptid_entry->vp_idx == 0) {\n\t\t\tif (rptid_entry->vp_status == VP_STAT_COMPL) {\n\t\t\t\t \n\t\t\t\tif (qla_ini_mode_enabled(vha) &&\n\t\t\t\t    ha->flags.fawwpn_enabled &&\n\t\t\t\t    (rptid_entry->u.f1.flags &\n\t\t\t\t     BIT_6)) {\n\t\t\t\t\tmemcpy(vha->port_name,\n\t\t\t\t\t    rptid_entry->u.f1.port_name,\n\t\t\t\t\t    WWN_SIZE);\n\t\t\t\t}\n\n\t\t\t\tqla_update_host_map(vha, id);\n\t\t\t}\n\n\t\t\tset_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags);\n\t\t\tset_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);\n\t\t} else {\n\t\t\tif (rptid_entry->vp_status != VP_STAT_COMPL &&\n\t\t\t\trptid_entry->vp_status != VP_STAT_ID_CHG) {\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x10ba,\n\t\t\t\t    \"Could not acquire ID for VP[%d].\\n\",\n\t\t\t\t    rptid_entry->vp_idx);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfound = 0;\n\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\tlist_for_each_entry(vp, &ha->vp_list, list) {\n\t\t\t\tif (rptid_entry->vp_idx == vp->vp_idx) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\t\tif (!found)\n\t\t\t\treturn;\n\n\t\t\tqla_update_host_map(vp, id);\n\n\t\t\t \n\t\t\tset_bit(VP_IDX_ACQUIRED, &vp->vp_flags);\n\t\t\tset_bit(REGISTER_FC4_NEEDED, &vp->dpc_flags);\n\t\t\tset_bit(REGISTER_FDMI_NEEDED, &vp->dpc_flags);\n\t\t}\n\t\tset_bit(VP_DPC_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\t} else if (rptid_entry->format == 2) {\n\t\tql_dbg(ql_dbg_async, vha, 0x505f,\n\t\t    \"RIDA: format 2/N2N Primary port id %02x%02x%02x.\\n\",\n\t\t    rptid_entry->port_id[2], rptid_entry->port_id[1],\n\t\t    rptid_entry->port_id[0]);\n\n\t\tql_dbg(ql_dbg_async, vha, 0x5075,\n\t\t    \"N2N: Remote WWPN %8phC.\\n\",\n\t\t    rptid_entry->u.f2.port_name);\n\n\t\t \n\t\tha->current_topology = ISP_CFG_N;\n\t\tha->flags.rida_fmt2 = 1;\n\t\tvha->d_id.b.domain = rptid_entry->port_id[2];\n\t\tvha->d_id.b.area = rptid_entry->port_id[1];\n\t\tvha->d_id.b.al_pa = rptid_entry->port_id[0];\n\n\t\tha->flags.n2n_ae = 1;\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tqla_update_vp_map(vha, SET_AL_PA);\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tfcport->scan_state = QLA_FCPORT_SCAN;\n\t\t\tfcport->n2n_flag = 0;\n\t\t}\n\n\t\tfcport = qla2x00_find_fcport_by_wwpn(vha,\n\t\t    rptid_entry->u.f2.port_name, 1);\n\n\t\tif (fcport) {\n\t\t\tfcport->login_retry = vha->hw->login_retry_count;\n\t\t\tfcport->plogi_nack_done_deadline = jiffies + HZ;\n\t\t\tfcport->scan_state = QLA_FCPORT_FOUND;\n\t\t\tfcport->keep_nport_handle = 1;\n\t\t\tfcport->n2n_flag = 1;\n\t\t\tfcport->d_id.b.domain =\n\t\t\t\trptid_entry->u.f2.remote_nport_id[2];\n\t\t\tfcport->d_id.b.area =\n\t\t\t\trptid_entry->u.f2.remote_nport_id[1];\n\t\t\tfcport->d_id.b.al_pa =\n\t\t\t\trptid_entry->u.f2.remote_nport_id[0];\n\n\t\t\t \n\t\t\tif (atomic_read(&fcport->state) == FCS_ONLINE)\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t}\n\t}\n}\n\n \nint\nqla24xx_modify_vp_config(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tstruct vp_config_entry_24xx *vpmod;\n\tdma_addr_t\tvpmod_dma;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\n\t \n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10bb,\n\t    \"Entered %s.\\n\", __func__);\n\n\tvpmod = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &vpmod_dma);\n\tif (!vpmod) {\n\t\tql_log(ql_log_warn, vha, 0x10bc,\n\t\t    \"Failed to allocate modify VP IOCB.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tvpmod->entry_type = VP_CONFIG_IOCB_TYPE;\n\tvpmod->entry_count = 1;\n\tvpmod->command = VCT_COMMAND_MOD_ENABLE_VPS;\n\tvpmod->vp_count = 1;\n\tvpmod->vp_index1 = vha->vp_idx;\n\tvpmod->options_idx1 = BIT_3|BIT_4|BIT_5;\n\n\tqlt_modify_vp_config(vha, vpmod);\n\n\tmemcpy(vpmod->node_name_idx1, vha->node_name, WWN_SIZE);\n\tmemcpy(vpmod->port_name_idx1, vha->port_name, WWN_SIZE);\n\tvpmod->entry_count = 1;\n\n\trval = qla2x00_issue_iocb(base_vha, vpmod, vpmod_dma, 0);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10bd,\n\t\t    \"Failed to issue VP config IOCB (%x).\\n\", rval);\n\t} else if (vpmod->comp_status != 0) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10be,\n\t\t    \"Failed to complete IOCB -- error status (%x).\\n\",\n\t\t    vpmod->comp_status);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else if (vpmod->comp_status != cpu_to_le16(CS_COMPLETE)) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10bf,\n\t\t    \"Failed to complete IOCB -- completion status (%x).\\n\",\n\t\t    le16_to_cpu(vpmod->comp_status));\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c0,\n\t\t    \"Done %s.\\n\", __func__);\n\t\tfc_vport_set_state(vha->fc_vport, FC_VPORT_INITIALIZING);\n\t}\n\tdma_pool_free(ha->s_dma_pool, vpmod, vpmod_dma);\n\n\treturn rval;\n}\n\n \n\nint\nqla2x00_send_change_request(scsi_qla_host_t *vha, uint16_t format,\n\t\t\t    uint16_t vp_idx)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c7,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_SEND_CHANGE_REQUEST;\n\tmcp->mb[1] = format;\n\tmcp->mb[9] = vp_idx;\n\tmcp->out_mb = MBX_9|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0|MBX_1;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tif (mcp->mb[0] != MBS_COMMAND_COMPLETE) {\n\t\t\trval = BIT_1;\n\t\t}\n\t} else\n\t\trval = BIT_1;\n\n\treturn rval;\n}\n\nint\nqla2x00_dump_ram(scsi_qla_host_t *vha, dma_addr_t req_dma, uint32_t addr,\n    uint32_t size)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1009,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (MSW(addr) || IS_FWI2_CAPABLE(vha->hw)) {\n\t\tmcp->mb[0] = MBC_DUMP_RISC_RAM_EXTENDED;\n\t\tmcp->mb[8] = MSW(addr);\n\t\tmcp->mb[10] = 0;\n\t\tmcp->out_mb = MBX_10|MBX_8|MBX_0;\n\t} else {\n\t\tmcp->mb[0] = MBC_DUMP_RISC_RAM;\n\t\tmcp->out_mb = MBX_0;\n\t}\n\tmcp->mb[1] = LSW(addr);\n\tmcp->mb[2] = MSW(req_dma);\n\tmcp->mb[3] = LSW(req_dma);\n\tmcp->mb[6] = MSW(MSD(req_dma));\n\tmcp->mb[7] = LSW(MSD(req_dma));\n\tmcp->out_mb |= MBX_7|MBX_6|MBX_3|MBX_2|MBX_1;\n\tif (IS_FWI2_CAPABLE(vha->hw)) {\n\t\tmcp->mb[4] = MSW(size);\n\t\tmcp->mb[5] = LSW(size);\n\t\tmcp->out_mb |= MBX_5|MBX_4;\n\t} else {\n\t\tmcp->mb[4] = LSW(size);\n\t\tmcp->out_mb |= MBX_4;\n\t}\n\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1008,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1007,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n \n\nstruct cs84xx_mgmt_cmd {\n\tunion {\n\t\tstruct verify_chip_entry_84xx req;\n\t\tstruct verify_chip_rsp_84xx rsp;\n\t} p;\n};\n\nint\nqla84xx_verify_chip(struct scsi_qla_host *vha, uint16_t *status)\n{\n\tint rval, retry;\n\tstruct cs84xx_mgmt_cmd *mn;\n\tdma_addr_t mn_dma;\n\tuint16_t options;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c8,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmn = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &mn_dma);\n\tif (mn == NULL) {\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\t \n\toptions = ha->cs84xx->fw_update ? VCO_FORCE_UPDATE : 0;\n\t \n\t \n\t \n\toptions |= VCO_END_OF_DATA;\n\n\tdo {\n\t\tretry = 0;\n\t\tmemset(mn, 0, sizeof(*mn));\n\t\tmn->p.req.entry_type = VERIFY_CHIP_IOCB_TYPE;\n\t\tmn->p.req.entry_count = 1;\n\t\tmn->p.req.options = cpu_to_le16(options);\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x111c,\n\t\t    \"Dump of Verify Request.\\n\");\n\t\tql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x111e,\n\t\t    mn, sizeof(*mn));\n\n\t\trval = qla2x00_issue_iocb_timeout(vha, mn, mn_dma, 0, 120);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x10cb,\n\t\t\t    \"Failed to issue verify IOCB (%x).\\n\", rval);\n\t\t\tgoto verify_done;\n\t\t}\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1110,\n\t\t    \"Dump of Verify Response.\\n\");\n\t\tql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1118,\n\t\t    mn, sizeof(*mn));\n\n\t\tstatus[0] = le16_to_cpu(mn->p.rsp.comp_status);\n\t\tstatus[1] = status[0] == CS_VCS_CHIP_FAILURE ?\n\t\t    le16_to_cpu(mn->p.rsp.failure_code) : 0;\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ce,\n\t\t    \"cs=%x fc=%x.\\n\", status[0], status[1]);\n\n\t\tif (status[0] != CS_COMPLETE) {\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tif (!(options & VCO_DONT_UPDATE_FW)) {\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x10cf,\n\t\t\t\t    \"Firmware update failed. Retrying \"\n\t\t\t\t    \"without update firmware.\\n\");\n\t\t\t\toptions |= VCO_DONT_UPDATE_FW;\n\t\t\t\toptions &= ~VCO_FORCE_UPDATE;\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d0,\n\t\t\t    \"Firmware updated to %x.\\n\",\n\t\t\t    le32_to_cpu(mn->p.rsp.fw_ver));\n\n\t\t\t \n\t\t\tspin_lock_irqsave(&ha->cs84xx->access_lock, flags);\n\t\t\tha->cs84xx->op_fw_version =\n\t\t\t    le32_to_cpu(mn->p.rsp.fw_ver);\n\t\t\tspin_unlock_irqrestore(&ha->cs84xx->access_lock,\n\t\t\t    flags);\n\t\t}\n\t} while (retry);\n\nverify_done:\n\tdma_pool_free(ha->s_dma_pool, mn, mn_dma);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10d1,\n\t\t    \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d2,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla25xx_init_req_que(struct scsi_qla_host *vha, struct req_que *req)\n{\n\tint rval;\n\tunsigned long flags;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->flags.fw_started)\n\t\treturn QLA_SUCCESS;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d3,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (IS_SHADOW_REG_CAPABLE(ha))\n\t\treq->options |= BIT_13;\n\n\tmcp->mb[0] = MBC_INITIALIZE_MULTIQ;\n\tmcp->mb[1] = req->options;\n\tmcp->mb[2] = MSW(LSD(req->dma));\n\tmcp->mb[3] = LSW(LSD(req->dma));\n\tmcp->mb[6] = MSW(MSD(req->dma));\n\tmcp->mb[7] = LSW(MSD(req->dma));\n\tmcp->mb[5] = req->length;\n\tif (req->rsp)\n\t\tmcp->mb[10] = req->rsp->id;\n\tmcp->mb[12] = req->qos;\n\tmcp->mb[11] = req->vp_idx;\n\tmcp->mb[13] = req->rid;\n\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tmcp->mb[15] = 0;\n\n\tmcp->mb[4] = req->id;\n\t \n\tmcp->mb[8] = 0;\n\t \n\tmcp->mb[9] = *req->out_ptr = 0;\n\tmcp->out_mb = MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8|MBX_7|\n\t\t\tMBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->flags = MBX_DMA_OUT;\n\tmcp->tov = MBX_TOV_SECONDS * 2;\n\n\tif (IS_QLA81XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha))\n\t\tmcp->in_mb |= MBX_1;\n\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tmcp->out_mb |= MBX_15;\n\t\t \n\t\tmcp->in_mb |= MBX_9 | MBX_8 | MBX_7;\n\t}\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tif (!(req->options & BIT_0)) {\n\t\twrt_reg_dword(req->req_q_in, 0);\n\t\tif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\t\twrt_reg_dword(req->req_q_out, 0);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10d4,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d5,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla25xx_init_rsp_que(struct scsi_qla_host *vha, struct rsp_que *rsp)\n{\n\tint rval;\n\tunsigned long flags;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->flags.fw_started)\n\t\treturn QLA_SUCCESS;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d6,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (IS_SHADOW_REG_CAPABLE(ha))\n\t\trsp->options |= BIT_13;\n\n\tmcp->mb[0] = MBC_INITIALIZE_MULTIQ;\n\tmcp->mb[1] = rsp->options;\n\tmcp->mb[2] = MSW(LSD(rsp->dma));\n\tmcp->mb[3] = LSW(LSD(rsp->dma));\n\tmcp->mb[6] = MSW(MSD(rsp->dma));\n\tmcp->mb[7] = LSW(MSD(rsp->dma));\n\tmcp->mb[5] = rsp->length;\n\tmcp->mb[14] = rsp->msix->entry;\n\tmcp->mb[13] = rsp->rid;\n\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tmcp->mb[15] = 0;\n\n\tmcp->mb[4] = rsp->id;\n\t \n\tmcp->mb[8] = *rsp->in_ptr = 0;\n\t \n\tmcp->mb[9] = 0;\n\tmcp->out_mb = MBX_14|MBX_13|MBX_9|MBX_8|MBX_7\n\t\t\t|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->flags = MBX_DMA_OUT;\n\tmcp->tov = MBX_TOV_SECONDS * 2;\n\n\tif (IS_QLA81XX(ha)) {\n\t\tmcp->out_mb |= MBX_12|MBX_11|MBX_10;\n\t\tmcp->in_mb |= MBX_1;\n\t} else if (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tmcp->out_mb |= MBX_15|MBX_12|MBX_11|MBX_10;\n\t\tmcp->in_mb |= MBX_1;\n\t\t \n\t\tmcp->in_mb |= MBX_9 | MBX_8 | MBX_7;\n\t}\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tif (!(rsp->options & BIT_0)) {\n\t\twrt_reg_dword(rsp->rsp_q_out, 0);\n\t\tif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\t\twrt_reg_dword(rsp->rsp_q_in, 0);\n\t}\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10d7,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d8,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_idc_ack(scsi_qla_host_t *vha, uint16_t *mb)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d9,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_IDC_ACK;\n\tmemcpy(&mcp->mb[1], mb, QLA_IDC_ACK_REGS * sizeof(uint16_t));\n\tmcp->out_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10da,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10db,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_fac_get_sector_size(scsi_qla_host_t *vha, uint32_t *sector_size)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10dc,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_QLA81XX(vha->hw) && !IS_QLA83XX(vha->hw) &&\n\t    !IS_QLA27XX(vha->hw) && !IS_QLA28XX(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_FLASH_ACCESS_CTRL;\n\tmcp->mb[1] = FAC_OPT_CMD_GET_SECTOR_SIZE;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10dd,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10de,\n\t\t    \"Done %s.\\n\", __func__);\n\t\t*sector_size = mcp->mb[1];\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_fac_do_write_enable(scsi_qla_host_t *vha, int enable)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA81XX(vha->hw) && !IS_QLA83XX(vha->hw) &&\n\t    !IS_QLA27XX(vha->hw) && !IS_QLA28XX(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10df,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_FLASH_ACCESS_CTRL;\n\tmcp->mb[1] = enable ? FAC_OPT_CMD_WRITE_ENABLE :\n\t    FAC_OPT_CMD_WRITE_PROTECT;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10e0,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e1,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_fac_erase_sector(scsi_qla_host_t *vha, uint32_t start, uint32_t finish)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA81XX(vha->hw) && !IS_QLA83XX(vha->hw) &&\n\t    !IS_QLA27XX(vha->hw) && !IS_QLA28XX(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e2,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_FLASH_ACCESS_CTRL;\n\tmcp->mb[1] = FAC_OPT_CMD_ERASE_SECTOR;\n\tmcp->mb[2] = LSW(start);\n\tmcp->mb[3] = MSW(start);\n\tmcp->mb[4] = LSW(finish);\n\tmcp->mb[5] = MSW(finish);\n\tmcp->out_mb = MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10e3,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e4,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_fac_semaphore_access(scsi_qla_host_t *vha, int lock)\n{\n\tint rval = QLA_SUCCESS;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn rval;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e2,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_FLASH_ACCESS_CTRL;\n\tmcp->mb[1] = (lock ? FAC_OPT_CMD_LOCK_SEMAPHORE :\n\t    FAC_OPT_CMD_UNLOCK_SEMAPHORE);\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10e3,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e4,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_restart_mpi_firmware(scsi_qla_host_t *vha)\n{\n\tint rval = 0;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e5,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_RESTART_MPI_FW;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_0|MBX_1;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10e6,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e7,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla82xx_set_driver_version(scsi_qla_host_t *vha, char *version)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tint i;\n\tint len;\n\t__le16 *str;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_P3P_TYPE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x117b,\n\t    \"Entered %s.\\n\", __func__);\n\n\tstr = (__force __le16 *)version;\n\tlen = strlen(version);\n\n\tmcp->mb[0] = MBC_SET_RNID_PARAMS;\n\tmcp->mb[1] = RNID_TYPE_SET_VERSION << 8;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tfor (i = 4; i < 16 && len; i++, str++, len -= 2) {\n\t\tmcp->mb[i] = le16_to_cpup(str);\n\t\tmcp->out_mb |= 1<<i;\n\t}\n\tfor (; i < 16; i++) {\n\t\tmcp->mb[i] = 0;\n\t\tmcp->out_mb |= 1<<i;\n\t}\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x117c,\n\t\t    \"Failed=%x mb[0]=%x,%x.\\n\", rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x117d,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla25xx_set_driver_version(scsi_qla_host_t *vha, char *version)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tint len;\n\tuint16_t dwlen;\n\tuint8_t *str;\n\tdma_addr_t str_dma;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_FWI2_CAPABLE(ha) || IS_QLA24XX_TYPE(ha) || IS_QLA81XX(ha) ||\n\t    IS_P3P_TYPE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x117e,\n\t    \"Entered %s.\\n\", __func__);\n\n\tstr = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &str_dma);\n\tif (!str) {\n\t\tql_log(ql_log_warn, vha, 0x117f,\n\t\t    \"Failed to allocate driver version param.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tmemcpy(str, \"\\x7\\x3\\x11\\x0\", 4);\n\tdwlen = str[0];\n\tlen = dwlen * 4 - 4;\n\tmemset(str + 4, 0, len);\n\tif (len > strlen(version))\n\t\tlen = strlen(version);\n\tmemcpy(str + 4, version, len);\n\n\tmcp->mb[0] = MBC_SET_RNID_PARAMS;\n\tmcp->mb[1] = RNID_TYPE_SET_VERSION << 8 | dwlen;\n\tmcp->mb[2] = MSW(LSD(str_dma));\n\tmcp->mb[3] = LSW(LSD(str_dma));\n\tmcp->mb[6] = MSW(MSD(str_dma));\n\tmcp->mb[7] = LSW(MSD(str_dma));\n\tmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1180,\n\t\t    \"Failed=%x mb[0]=%x,%x.\\n\", rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1181,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\tdma_pool_free(ha->s_dma_pool, str, str_dma);\n\n\treturn rval;\n}\n\nint\nqla24xx_get_port_login_templ(scsi_qla_host_t *vha, dma_addr_t buf_dma,\n\t\t\t     void *buf, uint16_t bufsiz)\n{\n\tint rval, i;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tuint32_t\t*bp;\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1159,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_RNID_PARAMS;\n\tmcp->mb[1] = RNID_TYPE_PORT_LOGIN << 8;\n\tmcp->mb[2] = MSW(buf_dma);\n\tmcp->mb[3] = LSW(buf_dma);\n\tmcp->mb[6] = MSW(MSD(buf_dma));\n\tmcp->mb[7] = LSW(MSD(buf_dma));\n\tmcp->mb[8] = bufsiz/4;\n\tmcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x115a,\n\t\t    \"Failed=%x mb[0]=%x,%x.\\n\", rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x115b,\n\t\t    \"Done %s.\\n\", __func__);\n\t\tbp = (uint32_t *) buf;\n\t\tfor (i = 0; i < (bufsiz-4)/4; i++, bp++)\n\t\t\t*bp = le32_to_cpu((__force __le32)*bp);\n\t}\n\n\treturn rval;\n}\n\n#define PUREX_CMD_COUNT\t4\nint\nqla25xx_set_els_cmds_supported(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tuint8_t *els_cmd_map;\n\tuint8_t active_cnt = 0;\n\tdma_addr_t els_cmd_map_dma;\n\tuint8_t cmd_opcode[PUREX_CMD_COUNT];\n\tuint8_t i, index, purex_bit;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA25XX(ha) && !IS_QLA2031(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_SUCCESS;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1197,\n\t    \"Entered %s.\\n\", __func__);\n\n\tels_cmd_map = dma_alloc_coherent(&ha->pdev->dev, ELS_CMD_MAP_SIZE,\n\t    &els_cmd_map_dma, GFP_KERNEL);\n\tif (!els_cmd_map) {\n\t\tql_log(ql_log_warn, vha, 0x7101,\n\t\t    \"Failed to allocate RDP els command param.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\t \n\tif (ql2xrdpenable) {\n\t\tcmd_opcode[active_cnt] = ELS_RDP;\n\t\tactive_cnt++;\n\t}\n\tif (ha->flags.scm_supported_f) {\n\t\tcmd_opcode[active_cnt] = ELS_FPIN;\n\t\tactive_cnt++;\n\t}\n\tif (ha->flags.edif_enabled) {\n\t\tcmd_opcode[active_cnt] = ELS_AUTH_ELS;\n\t\tactive_cnt++;\n\t}\n\n\tfor (i = 0; i < active_cnt; i++) {\n\t\tindex = cmd_opcode[i] / 8;\n\t\tpurex_bit = cmd_opcode[i] % 8;\n\t\tels_cmd_map[index] |= 1 << purex_bit;\n\t}\n\n\tmcp->mb[0] = MBC_SET_RNID_PARAMS;\n\tmcp->mb[1] = RNID_TYPE_ELS_CMD << 8;\n\tmcp->mb[2] = MSW(LSD(els_cmd_map_dma));\n\tmcp->mb[3] = LSW(LSD(els_cmd_map_dma));\n\tmcp->mb[6] = MSW(MSD(els_cmd_map_dma));\n\tmcp->mb[7] = LSW(MSD(els_cmd_map_dma));\n\tmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = MBX_DMA_OUT;\n\tmcp->buf_size = ELS_CMD_MAP_SIZE;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x118d,\n\t\t    \"Failed=%x (%x,%x).\\n\", rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118c,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\tdma_free_coherent(&ha->pdev->dev, ELS_CMD_MAP_SIZE,\n\t   els_cmd_map, els_cmd_map_dma);\n\n\treturn rval;\n}\n\nstatic int\nqla2x00_read_asic_temperature(scsi_qla_host_t *vha, uint16_t *temp)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1159,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_GET_RNID_PARAMS;\n\tmcp->mb[1] = RNID_TYPE_ASIC_TEMP << 8;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\t*temp = mcp->mb[1];\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x115a,\n\t\t    \"Failed=%x mb[0]=%x,%x.\\n\", rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x115b,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_read_sfp(scsi_qla_host_t *vha, dma_addr_t sfp_dma, uint8_t *sfp,\n\tuint16_t dev, uint16_t off, uint16_t len, uint16_t opt)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e8,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif (len == 1)\n\t\topt |= BIT_0;\n\n\tmcp->mb[0] = MBC_READ_SFP;\n\tmcp->mb[1] = dev;\n\tmcp->mb[2] = MSW(LSD(sfp_dma));\n\tmcp->mb[3] = LSW(LSD(sfp_dma));\n\tmcp->mb[6] = MSW(MSD(sfp_dma));\n\tmcp->mb[7] = LSW(MSD(sfp_dma));\n\tmcp->mb[8] = len;\n\tmcp->mb[9] = off;\n\tmcp->mb[10] = opt;\n\tmcp->out_mb = MBX_10|MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (opt & BIT_0)\n\t\t*sfp = mcp->mb[1];\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10e9,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t\tif (mcp->mb[0] == MBS_COMMAND_ERROR && mcp->mb[1] == 0x22) {\n\t\t\t \n\t\t\trval = QLA_INTERFACE_ERROR;\n\t\t}\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ea,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_write_sfp(scsi_qla_host_t *vha, dma_addr_t sfp_dma, uint8_t *sfp,\n\tuint16_t dev, uint16_t off, uint16_t len, uint16_t opt)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10eb,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif (len == 1)\n\t\topt |= BIT_0;\n\n\tif (opt & BIT_0)\n\t\tlen = *sfp;\n\n\tmcp->mb[0] = MBC_WRITE_SFP;\n\tmcp->mb[1] = dev;\n\tmcp->mb[2] = MSW(LSD(sfp_dma));\n\tmcp->mb[3] = LSW(LSD(sfp_dma));\n\tmcp->mb[6] = MSW(MSD(sfp_dma));\n\tmcp->mb[7] = LSW(MSD(sfp_dma));\n\tmcp->mb[8] = len;\n\tmcp->mb[9] = off;\n\tmcp->mb[10] = opt;\n\tmcp->out_mb = MBX_10|MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10ec,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ed,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_get_xgmac_stats(scsi_qla_host_t *vha, dma_addr_t stats_dma,\n    uint16_t size_in_bytes, uint16_t *actual_size)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ee,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_CNA_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_GET_XGMAC_STATS;\n\tmcp->mb[2] = MSW(stats_dma);\n\tmcp->mb[3] = LSW(stats_dma);\n\tmcp->mb[6] = MSW(MSD(stats_dma));\n\tmcp->mb[7] = LSW(MSD(stats_dma));\n\tmcp->mb[8] = size_in_bytes >> 2;\n\tmcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10ef,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f0,\n\t\t    \"Done %s.\\n\", __func__);\n\n\n\t\t*actual_size = mcp->mb[2] << 2;\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_get_dcbx_params(scsi_qla_host_t *vha, dma_addr_t tlv_dma,\n    uint16_t size)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f1,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_CNA_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_GET_DCBX_PARAMS;\n\tmcp->mb[1] = 0;\n\tmcp->mb[2] = MSW(tlv_dma);\n\tmcp->mb[3] = LSW(tlv_dma);\n\tmcp->mb[6] = MSW(MSD(tlv_dma));\n\tmcp->mb[7] = LSW(MSD(tlv_dma));\n\tmcp->mb[8] = size;\n\tmcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10f2,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f3,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_read_ram_word(scsi_qla_host_t *vha, uint32_t risc_addr, uint32_t *data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f4,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_READ_RAM_EXTENDED;\n\tmcp->mb[1] = LSW(risc_addr);\n\tmcp->mb[8] = MSW(risc_addr);\n\tmcp->out_mb = MBX_8|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_3|MBX_2|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10f5,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f6,\n\t\t    \"Done %s.\\n\", __func__);\n\t\t*data = mcp->mb[3] << 16 | mcp->mb[2];\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_loopback_test(scsi_qla_host_t *vha, struct msg_echo_lb *mreq,\n\tuint16_t *mresp)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f7,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = MBC_DIAGNOSTIC_LOOP_BACK;\n\tmcp->mb[1] = mreq->options | BIT_6;\t\n\n\t \n\tmcp->mb[10] = LSW(mreq->transfer_size);\n\tmcp->mb[11] = MSW(mreq->transfer_size);\n\n\t \n\tmcp->mb[14] = LSW(mreq->send_dma);\n\tmcp->mb[15] = MSW(mreq->send_dma);\n\tmcp->mb[20] = LSW(MSD(mreq->send_dma));\n\tmcp->mb[21] = MSW(MSD(mreq->send_dma));\n\n\t \n\tmcp->mb[16] = LSW(mreq->rcv_dma);\n\tmcp->mb[17] = MSW(mreq->rcv_dma);\n\tmcp->mb[6] = LSW(MSD(mreq->rcv_dma));\n\tmcp->mb[7] = MSW(MSD(mreq->rcv_dma));\n\n\t \n\tmcp->mb[18] = LSW(mreq->iteration_count);\n\tmcp->mb[19] = MSW(mreq->iteration_count);\n\n\tmcp->out_mb = MBX_21|MBX_20|MBX_19|MBX_18|MBX_17|MBX_16|MBX_15|\n\t    MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_7|MBX_6|MBX_1|MBX_0;\n\tif (IS_CNA_CAPABLE(vha->hw))\n\t\tmcp->out_mb |= MBX_2;\n\tmcp->in_mb = MBX_19|MBX_18|MBX_3|MBX_2|MBX_1|MBX_0;\n\n\tmcp->buf_size = mreq->transfer_size;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10f8,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[3]=%x mb[18]=%x \"\n\t\t    \"mb[19]=%x.\\n\", rval, mcp->mb[0], mcp->mb[1], mcp->mb[2],\n\t\t    mcp->mb[3], mcp->mb[18], mcp->mb[19]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f9,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\t \n\tmemcpy( mresp, mcp->mb, 64);\n\treturn rval;\n}\n\nint\nqla2x00_echo_test(scsi_qla_host_t *vha, struct msg_echo_lb *mreq,\n\tuint16_t *mresp)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10fa,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = MBC_DIAGNOSTIC_ECHO;\n\t \n\tmcp->mb[1] = mreq->options | BIT_15 | BIT_6;\n\tif (IS_CNA_CAPABLE(ha)) {\n\t\tmcp->mb[2] = vha->fcoe_fcf_idx;\n\t}\n\tmcp->mb[16] = LSW(mreq->rcv_dma);\n\tmcp->mb[17] = MSW(mreq->rcv_dma);\n\tmcp->mb[6] = LSW(MSD(mreq->rcv_dma));\n\tmcp->mb[7] = MSW(MSD(mreq->rcv_dma));\n\n\tmcp->mb[10] = LSW(mreq->transfer_size);\n\n\tmcp->mb[14] = LSW(mreq->send_dma);\n\tmcp->mb[15] = MSW(mreq->send_dma);\n\tmcp->mb[20] = LSW(MSD(mreq->send_dma));\n\tmcp->mb[21] = MSW(MSD(mreq->send_dma));\n\n\tmcp->out_mb = MBX_21|MBX_20|MBX_17|MBX_16|MBX_15|\n\t    MBX_14|MBX_10|MBX_7|MBX_6|MBX_1|MBX_0;\n\tif (IS_CNA_CAPABLE(ha))\n\t\tmcp->out_mb |= MBX_2;\n\n\tmcp->in_mb = MBX_0;\n\tif (IS_CNA_CAPABLE(ha) || IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha) ||\n\t    IS_QLA2031(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tmcp->in_mb |= MBX_1;\n\tif (IS_CNA_CAPABLE(ha) || IS_QLA2031(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha))\n\t\tmcp->in_mb |= MBX_3;\n\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\n\tmcp->buf_size = mreq->transfer_size;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10fb,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10fc,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\t \n\tmemcpy(mresp, mcp->mb, 64);\n\treturn rval;\n}\n\nint\nqla84xx_reset_chip(scsi_qla_host_t *vha, uint16_t enable_diagnostic)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10fd,\n\t    \"Entered %s enable_diag=%d.\\n\", __func__, enable_diagnostic);\n\n\tmcp->mb[0] = MBC_ISP84XX_RESET;\n\tmcp->mb[1] = enable_diagnostic;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS)\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10fe, \"Failed=%x.\\n\", rval);\n\telse\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ff,\n\t\t    \"Done %s.\\n\", __func__);\n\n\treturn rval;\n}\n\nint\nqla2x00_write_ram_word(scsi_qla_host_t *vha, uint32_t risc_addr, uint32_t data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1100,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_WRITE_RAM_WORD_EXTENDED;\n\tmcp->mb[1] = LSW(risc_addr);\n\tmcp->mb[2] = LSW(data);\n\tmcp->mb[3] = MSW(data);\n\tmcp->mb[8] = MSW(risc_addr);\n\tmcp->out_mb = MBX_8|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1101,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1102,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_write_mpi_register(scsi_qla_host_t *vha, uint16_t *mb)\n{\n\tint rval;\n\tuint32_t stat, timer;\n\tuint16_t mb0 = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\trval = QLA_SUCCESS;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1103,\n\t    \"Entered %s.\\n\", __func__);\n\n\tclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\n\n\t \n\twrt_reg_word(&reg->mailbox0, MBC_WRITE_MPI_REGISTER);\n\twrt_reg_word(&reg->mailbox1, mb[0]);\n\twrt_reg_word(&reg->mailbox2, mb[1]);\n\twrt_reg_word(&reg->mailbox3, mb[2]);\n\twrt_reg_word(&reg->mailbox4, mb[3]);\n\n\twrt_reg_dword(&reg->hccr, HCCRX_SET_HOST_INT);\n\n\t \n\tfor (timer = 6000000; timer; timer--) {\n\t\t \n\t\tstat = rd_reg_dword(&reg->host_status);\n\t\tif (stat & HSRX_RISC_INT) {\n\t\t\tstat &= 0xff;\n\n\t\t\tif (stat == 0x1 || stat == 0x2 ||\n\t\t\t    stat == 0x10 || stat == 0x11) {\n\t\t\t\tset_bit(MBX_INTERRUPT,\n\t\t\t\t    &ha->mbx_cmd_flags);\n\t\t\t\tmb0 = rd_reg_word(&reg->mailbox0);\n\t\t\t\twrt_reg_dword(&reg->hccr,\n\t\t\t\t    HCCRX_CLR_RISC_INT);\n\t\t\t\trd_reg_dword(&reg->hccr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tudelay(5);\n\t}\n\n\tif (test_and_clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags))\n\t\trval = mb0 & MBS_MASK;\n\telse\n\t\trval = QLA_FUNCTION_FAILED;\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1104,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1105,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla2x00_set_data_rate(scsi_qla_host_t *vha, uint16_t mode)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t val;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1106,\n\t    \"Entered %s speed:0x%x mode:0x%x.\\n\", __func__, ha->set_data_rate,\n\t    mode);\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmemset(mcp, 0, sizeof(*mcp));\n\tswitch (ha->set_data_rate) {\n\tcase PORT_SPEED_AUTO:\n\tcase PORT_SPEED_4GB:\n\tcase PORT_SPEED_8GB:\n\tcase PORT_SPEED_16GB:\n\tcase PORT_SPEED_32GB:\n\t\tval = ha->set_data_rate;\n\t\tbreak;\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0x1199,\n\t\t    \"Unrecognized speed setting:%d. Setting Autoneg\\n\",\n\t\t    ha->set_data_rate);\n\t\tval = ha->set_data_rate = PORT_SPEED_AUTO;\n\t\tbreak;\n\t}\n\n\tmcp->mb[0] = MBC_DATA_RATE;\n\tmcp->mb[1] = mode;\n\tmcp->mb[2] = val;\n\n\tmcp->out_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tmcp->in_mb |= MBX_4|MBX_3;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1107,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tif (mcp->mb[1] != 0x7)\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1179,\n\t\t\t\t\"Speed set:0x%x\\n\", mcp->mb[1]);\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1108,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_get_data_rate(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1106,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_DATA_RATE;\n\tmcp->mb[1] = QLA_GET_DATA_RATE;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tmcp->in_mb |= MBX_4|MBX_3;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1107,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tif (mcp->mb[1] != 0x7)\n\t\t\tha->link_data_rate = mcp->mb[1];\n\n\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tif (mcp->mb[4] & BIT_0)\n\t\t\t\tql_log(ql_log_info, vha, 0x11a2,\n\t\t\t\t    \"FEC=enabled (data rate).\\n\");\n\t\t}\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1108,\n\t\t    \"Done %s.\\n\", __func__);\n\t\tif (mcp->mb[1] != 0x7)\n\t\t\tha->link_data_rate = mcp->mb[1];\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_get_port_config(scsi_qla_host_t *vha, uint16_t *mb)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1109,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA83XX(ha) && !IS_QLA8044(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\tmcp->mb[0] = MBC_GET_PORT_CONFIG;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x110a,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\t \n\t\tmemcpy(mb, &mcp->mb[1], sizeof(uint16_t) * 4);\n\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x110b,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\treturn rval;\n}\n\nint\nqla81xx_set_port_config(scsi_qla_host_t *vha, uint16_t *mb)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x110c,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_SET_PORT_CONFIG;\n\t \n\tmemcpy(&mcp->mb[1], mb, sizeof(uint16_t) * 4);\n\tmcp->out_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x110d,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x110e,\n\t\t    \"Done %s.\\n\", __func__);\n\n\treturn rval;\n}\n\n\nint\nqla24xx_set_fcp_prio(scsi_qla_host_t *vha, uint16_t loop_id, uint16_t priority,\n\t\tuint16_t *mb)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x110f,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmcp->mb[0] = MBC_PORT_PARAMS;\n\tmcp->mb[1] = loop_id;\n\tif (ha->flags.fcp_prio_enabled)\n\t\tmcp->mb[2] = BIT_1;\n\telse\n\t\tmcp->mb[2] = BIT_2;\n\tmcp->mb[4] = priority & 0xf;\n\tmcp->mb[9] = vha->vp_idx;\n\tmcp->out_mb = MBX_9|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_4|MBX_3|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (mb != NULL) {\n\t\tmb[0] = mcp->mb[0];\n\t\tmb[1] = mcp->mb[1];\n\t\tmb[3] = mcp->mb[3];\n\t\tmb[4] = mcp->mb[4];\n\t}\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10cd, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10cc,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_get_thermal_temp(scsi_qla_host_t *vha, uint16_t *temp)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint8_t byte;\n\n\tif (!IS_FWI2_CAPABLE(ha) || IS_QLA24XX_TYPE(ha) || IS_QLA81XX(ha)) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1150,\n\t\t    \"Thermal not supported by this card.\\n\");\n\t\treturn rval;\n\t}\n\n\tif (IS_QLA25XX(ha)) {\n\t\tif (ha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&\n\t\t    ha->pdev->subsystem_device == 0x0175) {\n\t\t\trval = qla2x00_read_sfp(vha, 0, &byte,\n\t\t\t    0x98, 0x1, 1, BIT_13|BIT_0);\n\t\t\t*temp = byte;\n\t\t\treturn rval;\n\t\t}\n\t\tif (ha->pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&\n\t\t    ha->pdev->subsystem_device == 0x338e) {\n\t\t\trval = qla2x00_read_sfp(vha, 0, &byte,\n\t\t\t    0x98, 0x1, 1, BIT_15|BIT_14|BIT_0);\n\t\t\t*temp = byte;\n\t\t\treturn rval;\n\t\t}\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10c9,\n\t\t    \"Thermal not supported by this card.\\n\");\n\t\treturn rval;\n\t}\n\n\tif (IS_QLA82XX(ha)) {\n\t\t*temp = qla82xx_read_temperature(vha);\n\t\trval = QLA_SUCCESS;\n\t\treturn rval;\n\t} else if (IS_QLA8044(ha)) {\n\t\t*temp = qla8044_read_temperature(vha);\n\t\trval = QLA_SUCCESS;\n\t\treturn rval;\n\t}\n\n\trval = qla2x00_read_asic_temperature(vha, temp);\n\treturn rval;\n}\n\nint\nqla82xx_mbx_intr_enable(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1017,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmemset(mcp, 0, sizeof(mbx_cmd_t));\n\tmcp->mb[0] = MBC_TOGGLE_INTERRUPT;\n\tmcp->mb[1] = 1;\n\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1016,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x100e,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla82xx_mbx_intr_disable(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x100d,\n\t    \"Entered %s.\\n\", __func__);\n\n\tif (!IS_P3P_TYPE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmemset(mcp, 0, sizeof(mbx_cmd_t));\n\tmcp->mb[0] = MBC_TOGGLE_INTERRUPT;\n\tmcp->mb[1] = 0;\n\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x100c,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x100b,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla82xx_md_get_template_size(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x111f,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = LSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\n\tmcp->mb[1] = MSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\n\tmcp->mb[2] = LSW(RQST_TMPLT_SIZE);\n\tmcp->mb[3] = MSW(RQST_TMPLT_SIZE);\n\n\tmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8|\n\t    MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\n\tmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\n\tmcp->tov = MBX_TOV_SECONDS;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\t \n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1120,\n\t\t    \"mailbox command FAILED=0x%x, subcode=%x.\\n\",\n\t\t    (mcp->mb[1] << 16) | mcp->mb[0],\n\t\t    (mcp->mb[3] << 16) | mcp->mb[2]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1121,\n\t\t    \"Done %s.\\n\", __func__);\n\t\tha->md_template_size = ((mcp->mb[3] << 16) | mcp->mb[2]);\n\t\tif (!ha->md_template_size) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1122,\n\t\t\t    \"Null template size obtained.\\n\");\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\treturn rval;\n}\n\nint\nqla82xx_md_get_template(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1123,\n\t    \"Entered %s.\\n\", __func__);\n\n\tha->md_tmplt_hdr = dma_alloc_coherent(&ha->pdev->dev,\n\t   ha->md_template_size, &ha->md_tmplt_hdr_dma, GFP_KERNEL);\n\tif (!ha->md_tmplt_hdr) {\n\t\tql_log(ql_log_warn, vha, 0x1124,\n\t\t    \"Unable to allocate memory for Minidump template.\\n\");\n\t\treturn rval;\n\t}\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = LSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\n\tmcp->mb[1] = MSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\n\tmcp->mb[2] = LSW(RQST_TMPLT);\n\tmcp->mb[3] = MSW(RQST_TMPLT);\n\tmcp->mb[4] = LSW(LSD(ha->md_tmplt_hdr_dma));\n\tmcp->mb[5] = MSW(LSD(ha->md_tmplt_hdr_dma));\n\tmcp->mb[6] = LSW(MSD(ha->md_tmplt_hdr_dma));\n\tmcp->mb[7] = MSW(MSD(ha->md_tmplt_hdr_dma));\n\tmcp->mb[8] = LSW(ha->md_template_size);\n\tmcp->mb[9] = MSW(ha->md_template_size);\n\n\tmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->out_mb = MBX_11|MBX_10|MBX_9|MBX_8|\n\t    MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1125,\n\t\t    \"mailbox command FAILED=0x%x, subcode=%x.\\n\",\n\t\t    ((mcp->mb[1] << 16) | mcp->mb[0]),\n\t\t    ((mcp->mb[3] << 16) | mcp->mb[2]));\n\t} else\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1126,\n\t\t    \"Done %s.\\n\", __func__);\n\treturn rval;\n}\n\nint\nqla8044_md_get_template(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tint rval = QLA_FUNCTION_FAILED;\n\tint offset = 0, size = MINIDUMP_SIZE_36K;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0xb11f,\n\t    \"Entered %s.\\n\", __func__);\n\n\tha->md_tmplt_hdr = dma_alloc_coherent(&ha->pdev->dev,\n\t   ha->md_template_size, &ha->md_tmplt_hdr_dma, GFP_KERNEL);\n\tif (!ha->md_tmplt_hdr) {\n\t\tql_log(ql_log_warn, vha, 0xb11b,\n\t\t    \"Unable to allocate memory for Minidump template.\\n\");\n\t\treturn rval;\n\t}\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\twhile (offset < ha->md_template_size) {\n\t\tmcp->mb[0] = LSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\n\t\tmcp->mb[1] = MSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\n\t\tmcp->mb[2] = LSW(RQST_TMPLT);\n\t\tmcp->mb[3] = MSW(RQST_TMPLT);\n\t\tmcp->mb[4] = LSW(LSD(ha->md_tmplt_hdr_dma + offset));\n\t\tmcp->mb[5] = MSW(LSD(ha->md_tmplt_hdr_dma + offset));\n\t\tmcp->mb[6] = LSW(MSD(ha->md_tmplt_hdr_dma + offset));\n\t\tmcp->mb[7] = MSW(MSD(ha->md_tmplt_hdr_dma + offset));\n\t\tmcp->mb[8] = LSW(size);\n\t\tmcp->mb[9] = MSW(size);\n\t\tmcp->mb[10] = offset & 0x0000FFFF;\n\t\tmcp->mb[11] = offset & 0xFFFF0000;\n\t\tmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\n\t\tmcp->tov = MBX_TOV_SECONDS;\n\t\tmcp->out_mb = MBX_11|MBX_10|MBX_9|MBX_8|\n\t\t\tMBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\t\tmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\t\trval = qla2x00_mailbox_command(vha, mcp);\n\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0xb11c,\n\t\t\t\t\"mailbox command FAILED=0x%x, subcode=%x.\\n\",\n\t\t\t\t((mcp->mb[1] << 16) | mcp->mb[0]),\n\t\t\t\t((mcp->mb[3] << 16) | mcp->mb[2]));\n\t\t\treturn rval;\n\t\t} else\n\t\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0xb11d,\n\t\t\t\t\"Done %s.\\n\", __func__);\n\t\toffset = offset + size;\n\t}\n\treturn rval;\n}\n\nint\nqla81xx_set_led_config(scsi_qla_host_t *vha, uint16_t *led_cfg)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA8031(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1133,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(mcp, 0, sizeof(mbx_cmd_t));\n\tmcp->mb[0] = MBC_SET_LED_CONFIG;\n\tmcp->mb[1] = led_cfg[0];\n\tmcp->mb[2] = led_cfg[1];\n\tif (IS_QLA8031(ha)) {\n\t\tmcp->mb[3] = led_cfg[2];\n\t\tmcp->mb[4] = led_cfg[3];\n\t\tmcp->mb[5] = led_cfg[4];\n\t\tmcp->mb[6] = led_cfg[5];\n\t}\n\n\tmcp->out_mb = MBX_2|MBX_1|MBX_0;\n\tif (IS_QLA8031(ha))\n\t\tmcp->out_mb |= MBX_6|MBX_5|MBX_4|MBX_3;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1134,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1135,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla81xx_get_led_config(scsi_qla_host_t *vha, uint16_t *led_cfg)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA8031(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1136,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmemset(mcp, 0, sizeof(mbx_cmd_t));\n\tmcp->mb[0] = MBC_GET_LED_CONFIG;\n\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tif (IS_QLA8031(ha))\n\t\tmcp->in_mb |= MBX_6|MBX_5|MBX_4|MBX_3;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1137,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tled_cfg[0] = mcp->mb[1];\n\t\tled_cfg[1] = mcp->mb[2];\n\t\tif (IS_QLA8031(ha)) {\n\t\t\tled_cfg[2] = mcp->mb[3];\n\t\t\tled_cfg[3] = mcp->mb[4];\n\t\t\tled_cfg[4] = mcp->mb[5];\n\t\t\tled_cfg[5] = mcp->mb[6];\n\t\t}\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1138,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla82xx_mbx_beacon_ctl(scsi_qla_host_t *vha, int enable)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_P3P_TYPE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1127,\n\t\t\"Entered %s.\\n\", __func__);\n\n\tmemset(mcp, 0, sizeof(mbx_cmd_t));\n\tmcp->mb[0] = MBC_SET_LED_CONFIG;\n\tif (enable)\n\t\tmcp->mb[7] = 0xE;\n\telse\n\t\tmcp->mb[7] = 0xD;\n\n\tmcp->out_mb = MBX_7|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1128,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1129,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla83xx_wr_reg(scsi_qla_host_t *vha, uint32_t reg, uint32_t data)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1130,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_WRITE_REMOTE_REG;\n\tmcp->mb[1] = LSW(reg);\n\tmcp->mb[2] = MSW(reg);\n\tmcp->mb[3] = LSW(data);\n\tmcp->mb[4] = MSW(data);\n\tmcp->out_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1131,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1132,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_port_logout(scsi_qla_host_t *vha, struct fc_port *fcport)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x113b,\n\t\t    \"Implicit LOGO Unsupported.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x113c,\n\t    \"Entering %s.\\n\",  __func__);\n\n\t \n\tmcp->mb[0] = MBC_PORT_LOGOUT;\n\tmcp->mb[1] = fcport->loop_id;\n\tmcp->mb[10] = BIT_15;\n\tmcp->out_mb = MBX_10|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval != QLA_SUCCESS)\n\t\tql_dbg(ql_dbg_mbx, vha, 0x113d,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\telse\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x113e,\n\t\t    \"Done %s.\\n\", __func__);\n\n\treturn rval;\n}\n\nint\nqla83xx_rd_reg(scsi_qla_host_t *vha, uint32_t reg, uint32_t *data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long retry_max_time = jiffies + (2 * HZ);\n\n\tif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx, vha, 0x114b, \"Entered %s.\\n\", __func__);\n\nretry_rd_reg:\n\tmcp->mb[0] = MBC_READ_REMOTE_REG;\n\tmcp->mb[1] = LSW(reg);\n\tmcp->mb[2] = MSW(reg);\n\tmcp->out_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_4|MBX_3|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x114c,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t} else {\n\t\t*data = (mcp->mb[3] | (mcp->mb[4] << 16));\n\t\tif (*data == QLA8XXX_BAD_VALUE) {\n\t\t\t \n\t\t\tif (time_after(jiffies, retry_max_time)) {\n\t\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1141,\n\t\t\t\t    \"Failure to read CAMRAM register. \"\n\t\t\t\t    \"data=0x%x.\\n\", *data);\n\t\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t\t}\n\t\t\tmsleep(100);\n\t\t\tgoto retry_rd_reg;\n\t\t}\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1142, \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla83xx_restart_nic_firmware(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA83XX(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1143, \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_RESTART_NIC_FIRMWARE;\n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1144,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1]);\n\t\tqla2xxx_dump_fw(vha);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1145, \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla83xx_access_control(scsi_qla_host_t *vha, uint16_t options,\n\tuint32_t start_addr, uint32_t end_addr, uint16_t *sector_size)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tuint8_t subcode = (uint8_t)options;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA8031(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1146, \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_SET_ACCESS_CONTROL;\n\tmcp->mb[1] = options;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tif (subcode & BIT_2) {\n\t\tmcp->mb[2] = LSW(start_addr);\n\t\tmcp->mb[3] = MSW(start_addr);\n\t\tmcp->mb[4] = LSW(end_addr);\n\t\tmcp->mb[5] = MSW(end_addr);\n\t\tmcp->out_mb |= MBX_5|MBX_4|MBX_3|MBX_2;\n\t}\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tif (!(subcode & (BIT_2 | BIT_5)))\n\t\tmcp->in_mb |= MBX_4|MBX_3;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1147,\n\t\t    \"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[3]=%x mb[4]=%x.\\n\",\n\t\t    rval, mcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3],\n\t\t    mcp->mb[4]);\n\t\tqla2xxx_dump_fw(vha);\n\t} else {\n\t\tif (subcode & BIT_5)\n\t\t\t*sector_size = mcp->mb[1];\n\t\telse if (subcode & (BIT_6 | BIT_7)) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1148,\n\t\t\t    \"Driver-lock id=%x%x\", mcp->mb[4], mcp->mb[3]);\n\t\t} else if (subcode & (BIT_3 | BIT_4)) {\n\t\t\tql_dbg(ql_dbg_mbx, vha, 0x1149,\n\t\t\t    \"Flash-lock id=%x%x\", mcp->mb[4], mcp->mb[3]);\n\t\t}\n\t\tql_dbg(ql_dbg_mbx, vha, 0x114a, \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla2x00_dump_mctp_data(scsi_qla_host_t *vha, dma_addr_t req_dma, uint32_t addr,\n\tuint32_t size)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tif (!IS_MCTP_CAPABLE(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x114f,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_DUMP_RISC_RAM_EXTENDED;\n\tmcp->mb[1] = LSW(addr);\n\tmcp->mb[2] = MSW(req_dma);\n\tmcp->mb[3] = LSW(req_dma);\n\tmcp->mb[4] = MSW(size);\n\tmcp->mb[5] = LSW(size);\n\tmcp->mb[6] = MSW(MSD(req_dma));\n\tmcp->mb[7] = LSW(MSD(req_dma));\n\tmcp->mb[8] = MSW(addr);\n\t \n\t \n\tmcp->mb[10] = BIT_7 | 0x40;\n\n\tmcp->out_mb |= MBX_10|MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|\n\t    MBX_0;\n\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x114e,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x114d,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nqla26xx_dport_diagnostics(scsi_qla_host_t *vha,\n\tvoid *dd_buf, uint size, uint options)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tdma_addr_t dd_dma;\n\n\tif (!IS_QLA83XX(vha->hw) && !IS_QLA27XX(vha->hw) &&\n\t    !IS_QLA28XX(vha->hw))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x119f,\n\t    \"Entered %s.\\n\", __func__);\n\n\tdd_dma = dma_map_single(&vha->hw->pdev->dev,\n\t    dd_buf, size, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&vha->hw->pdev->dev, dd_dma)) {\n\t\tql_log(ql_log_warn, vha, 0x1194, \"Failed to map dma buffer.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tmemset(dd_buf, 0, size);\n\n\tmcp->mb[0] = MBC_DPORT_DIAGNOSTICS;\n\tmcp->mb[1] = options;\n\tmcp->mb[2] = MSW(LSD(dd_dma));\n\tmcp->mb[3] = LSW(LSD(dd_dma));\n\tmcp->mb[6] = MSW(MSD(dd_dma));\n\tmcp->mb[7] = LSW(MSD(dd_dma));\n\tmcp->mb[8] = size;\n\tmcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->buf_size = size;\n\tmcp->flags = MBX_DMA_IN;\n\tmcp->tov = MBX_TOV_SECONDS * 4;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1195, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1196,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\tdma_unmap_single(&vha->hw->pdev->dev, dd_dma,\n\t    size, DMA_FROM_DEVICE);\n\n\treturn rval;\n}\n\nint\nqla26xx_dport_diagnostics_v2(scsi_qla_host_t *vha,\n\t\t\t     struct qla_dport_diag_v2 *dd,  mbx_cmd_t *mcp)\n{\n\tint rval;\n\tdma_addr_t dd_dma;\n\tuint size = sizeof(dd->buf);\n\tuint16_t options = dd->options;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x119f,\n\t       \"Entered %s.\\n\", __func__);\n\n\tdd_dma = dma_map_single(&vha->hw->pdev->dev,\n\t\t\t\tdd->buf, size, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&vha->hw->pdev->dev, dd_dma)) {\n\t\tql_log(ql_log_warn, vha, 0x1194,\n\t\t       \"Failed to map dma buffer.\\n\");\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\t}\n\n\tmemset(dd->buf, 0, size);\n\n\tmcp->mb[0] = MBC_DPORT_DIAGNOSTICS;\n\tmcp->mb[1] = options;\n\tmcp->mb[2] = MSW(LSD(dd_dma));\n\tmcp->mb[3] = LSW(LSD(dd_dma));\n\tmcp->mb[6] = MSW(MSD(dd_dma));\n\tmcp->mb[7] = LSW(MSD(dd_dma));\n\tmcp->mb[8] = size;\n\tmcp->out_mb = MBX_8 | MBX_7 | MBX_6 | MBX_3 | MBX_2 | MBX_1 | MBX_0;\n\tmcp->in_mb = MBX_3 | MBX_2 | MBX_1 | MBX_0;\n\tmcp->buf_size = size;\n\tmcp->flags = MBX_DMA_IN;\n\tmcp->tov = MBX_TOV_SECONDS * 4;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1195, \"Failed=%x.\\n\", rval);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1196,\n\t\t       \"Done %s.\\n\", __func__);\n\t}\n\n\tdma_unmap_single(&vha->hw->pdev->dev, dd_dma, size, DMA_FROM_DEVICE);\n\n\treturn rval;\n}\n\nstatic void qla2x00_async_mb_sp_done(srb_t *sp, int res)\n{\n\tsp->u.iocb_cmd.u.mbx.rc = res;\n\n\tcomplete(&sp->u.iocb_cmd.u.mbx.comp);\n\t \n}\n\n \nint qla24xx_send_mb_cmd(struct scsi_qla_host *vha, mbx_cmd_t *mcp)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tsrb_t *sp;\n\tstruct srb_iocb *c;\n\n\tif (!vha->hw->flags.fw_started)\n\t\tgoto done;\n\n\t \n\tsp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tc = &sp->u.iocb_cmd;\n\tinit_completion(&c->u.mbx.comp);\n\n\tsp->type = SRB_MB_IOCB;\n\tsp->name = mb_to_str(mcp->mb[0]);\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_mb_sp_done);\n\n\tmemcpy(sp->u.iocb_cmd.u.mbx.out_mb, mcp->mb, SIZEOF_IOCB_MB_REG);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1018,\n\t\t    \"%s: %s Failed submission. %x.\\n\",\n\t\t    __func__, sp->name, rval);\n\t\tgoto done_free_sp;\n\t}\n\n\tql_dbg(ql_dbg_mbx, vha, 0x113f, \"MB:%s hndl %x submitted\\n\",\n\t    sp->name, sp->handle);\n\n\twait_for_completion(&c->u.mbx.comp);\n\tmemcpy(mcp->mb, sp->u.iocb_cmd.u.mbx.in_mb, SIZEOF_IOCB_MB_REG);\n\n\trval = c->u.mbx.rc;\n\tswitch (rval) {\n\tcase QLA_FUNCTION_TIMEOUT:\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1140, \"%s: %s Timeout. %x.\\n\",\n\t\t    __func__, sp->name, rval);\n\t\tbreak;\n\tcase  QLA_SUCCESS:\n\t\tql_dbg(ql_dbg_mbx, vha, 0x119d, \"%s: %s done.\\n\",\n\t\t    __func__, sp->name);\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_mbx, vha, 0x119e, \"%s: %s Failed. %x.\\n\",\n\t\t    __func__, sp->name, rval);\n\t\tbreak;\n\t}\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\n \nint qla24xx_gpdb_wait(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tdma_addr_t pd_dma;\n\tstruct port_database_24xx *pd;\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\n\tif (!vha->hw->flags.fw_started)\n\t\tgoto done;\n\n\tpd = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);\n\tif (pd  == NULL) {\n\t\tql_log(ql_log_warn, vha, 0xd047,\n\t\t    \"Failed to allocate port database structure.\\n\");\n\t\tgoto done_free_sp;\n\t}\n\n\tmemset(&mc, 0, sizeof(mc));\n\tmc.mb[0] = MBC_GET_PORT_DATABASE;\n\tmc.mb[1] = fcport->loop_id;\n\tmc.mb[2] = MSW(pd_dma);\n\tmc.mb[3] = LSW(pd_dma);\n\tmc.mb[6] = MSW(MSD(pd_dma));\n\tmc.mb[7] = LSW(MSD(pd_dma));\n\tmc.mb[9] = vha->vp_idx;\n\tmc.mb[10] = opt;\n\n\trval = qla24xx_send_mb_cmd(vha, &mc);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x1193,\n\t\t    \"%s: %8phC fail\\n\", __func__, fcport->port_name);\n\t\tgoto done_free_sp;\n\t}\n\n\trval = __qla24xx_parse_gpdb(vha, fcport, pd);\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1197, \"%s: %8phC done\\n\",\n\t    __func__, fcport->port_name);\n\ndone_free_sp:\n\tif (pd)\n\t\tdma_pool_free(ha->s_dma_pool, pd, pd_dma);\ndone:\n\treturn rval;\n}\n\nint __qla24xx_parse_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport,\n    struct port_database_24xx *pd)\n{\n\tint rval = QLA_SUCCESS;\n\tuint64_t zero = 0;\n\tu8 current_login_state, last_login_state;\n\n\tif (NVME_TARGET(vha->hw, fcport)) {\n\t\tcurrent_login_state = pd->current_login_state >> 4;\n\t\tlast_login_state = pd->last_login_state >> 4;\n\t} else {\n\t\tcurrent_login_state = pd->current_login_state & 0xf;\n\t\tlast_login_state = pd->last_login_state & 0xf;\n\t}\n\n\t \n\tif (current_login_state != PDS_PRLI_COMPLETE) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x119a,\n\t\t    \"Unable to verify login-state (%x/%x) for loop_id %x.\\n\",\n\t\t    current_login_state, last_login_state, fcport->loop_id);\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto gpd_error_out;\n\t}\n\n\tif (fcport->loop_id == FC_NO_LOOP_ID ||\n\t    (memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&\n\t     memcmp(fcport->port_name, pd->port_name, 8))) {\n\t\t \n\t\trval = QLA_NOT_LOGGED_IN;\n\t\tgoto gpd_error_out;\n\t}\n\n\t \n\tmemcpy(fcport->node_name, pd->node_name, WWN_SIZE);\n\tmemcpy(fcport->port_name, pd->port_name, WWN_SIZE);\n\n\t \n\tfcport->d_id.b.domain = pd->port_id[0];\n\tfcport->d_id.b.area = pd->port_id[1];\n\tfcport->d_id.b.al_pa = pd->port_id[2];\n\tfcport->d_id.b.rsvd_1 = 0;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2062,\n\t     \"%8phC SVC Param w3 %02x%02x\",\n\t     fcport->port_name,\n\t     pd->prli_svc_param_word_3[1],\n\t     pd->prli_svc_param_word_3[0]);\n\n\tif (NVME_TARGET(vha->hw, fcport)) {\n\t\tfcport->port_type = FCT_NVME;\n\t\tif ((pd->prli_svc_param_word_3[0] & BIT_5) == 0)\n\t\t\tfcport->port_type |= FCT_NVME_INITIATOR;\n\t\tif ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)\n\t\t\tfcport->port_type |= FCT_NVME_TARGET;\n\t\tif ((pd->prli_svc_param_word_3[0] & BIT_3) == 0)\n\t\t\tfcport->port_type |= FCT_NVME_DISCOVERY;\n\t} else {\n\t\t \n\t\tif ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)\n\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\telse\n\t\t\tfcport->port_type = FCT_TARGET;\n\t}\n\t \n\tfcport->supported_classes = (pd->flags & PDF_CLASS_2) ?\n\t\tFC_COS_CLASS2 : FC_COS_CLASS3;\n\n\tif (pd->prli_svc_param_word_3[0] & BIT_7) {\n\t\tfcport->flags |= FCF_CONF_COMP_SUPPORTED;\n\t\tfcport->conf_compl_supported = 1;\n\t}\n\ngpd_error_out:\n\treturn rval;\n}\n\n \nint qla24xx_gidlist_wait(struct scsi_qla_host *vha,\n\tvoid *id_list, dma_addr_t id_list_dma, uint16_t *entries)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tmbx_cmd_t mc;\n\n\tif (!vha->hw->flags.fw_started)\n\t\tgoto done;\n\n\tmemset(&mc, 0, sizeof(mc));\n\tmc.mb[0] = MBC_GET_ID_LIST;\n\tmc.mb[2] = MSW(id_list_dma);\n\tmc.mb[3] = LSW(id_list_dma);\n\tmc.mb[6] = MSW(MSD(id_list_dma));\n\tmc.mb[7] = LSW(MSD(id_list_dma));\n\tmc.mb[8] = 0;\n\tmc.mb[9] = vha->vp_idx;\n\n\trval = qla24xx_send_mb_cmd(vha, &mc);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x119b,\n\t\t    \"%s:  fail\\n\", __func__);\n\t} else {\n\t\t*entries = mc.mb[1];\n\t\tql_dbg(ql_dbg_mbx, vha, 0x119c,\n\t\t    \"%s:  done\\n\", __func__);\n\t}\ndone:\n\treturn rval;\n}\n\nint qla27xx_set_zio_threshold(scsi_qla_host_t *vha, uint16_t value)\n{\n\tint rval;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1200,\n\t    \"Entered %s\\n\", __func__);\n\n\tmemset(mcp->mb, 0 , sizeof(mcp->mb));\n\tmcp->mb[0] = MBC_GET_SET_ZIO_THRESHOLD;\n\tmcp->mb[1] = 1;\n\tmcp->mb[2] = value;\n\tmcp->out_mb = MBX_2 | MBX_1 | MBX_0;\n\tmcp->in_mb = MBX_2 | MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1201, \"%s %x\\n\",\n\t    (rval != QLA_SUCCESS) ? \"Failed\"  : \"Done\", rval);\n\n\treturn rval;\n}\n\nint qla27xx_get_zio_threshold(scsi_qla_host_t *vha, uint16_t *value)\n{\n\tint rval;\n\tmbx_cmd_t\tmc;\n\tmbx_cmd_t\t*mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1203,\n\t    \"Entered %s\\n\", __func__);\n\n\tmemset(mcp->mb, 0, sizeof(mcp->mb));\n\tmcp->mb[0] = MBC_GET_SET_ZIO_THRESHOLD;\n\tmcp->mb[1] = 0;\n\tmcp->out_mb = MBX_1 | MBX_0;\n\tmcp->in_mb = MBX_2 | MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval == QLA_SUCCESS)\n\t\t*value = mc.mb[2];\n\n\tql_dbg(ql_dbg_mbx, vha, 0x1205, \"%s %x\\n\",\n\t    (rval != QLA_SUCCESS) ? \"Failed\" : \"Done\", rval);\n\n\treturn rval;\n}\n\nint\nqla2x00_read_sfp_dev(struct scsi_qla_host *vha, char *buf, int count)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t iter, addr, offset;\n\tdma_addr_t phys_addr;\n\tint rval, c;\n\tu8 *sfp_data;\n\n\tmemset(ha->sfp_data, 0, SFP_DEV_SIZE);\n\taddr = 0xa0;\n\tphys_addr = ha->sfp_data_dma;\n\tsfp_data = ha->sfp_data;\n\toffset = c = 0;\n\n\tfor (iter = 0; iter < SFP_DEV_SIZE / SFP_BLOCK_SIZE; iter++) {\n\t\tif (iter == 4) {\n\t\t\t \n\t\t\taddr = 0xa2;\n\t\t\toffset = 0;\n\t\t}\n\n\t\trval = qla2x00_read_sfp(vha, phys_addr, sfp_data,\n\t\t    addr, offset, SFP_BLOCK_SIZE, BIT_1);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x706d,\n\t\t\t    \"Unable to read SFP data (%x/%x/%x).\\n\", rval,\n\t\t\t    addr, offset);\n\n\t\t\treturn rval;\n\t\t}\n\n\t\tif (buf && (c < count)) {\n\t\t\tu16 sz;\n\n\t\t\tif ((count - c) >= SFP_BLOCK_SIZE)\n\t\t\t\tsz = SFP_BLOCK_SIZE;\n\t\t\telse\n\t\t\t\tsz = count - c;\n\n\t\t\tmemcpy(buf, sfp_data, sz);\n\t\t\tbuf += SFP_BLOCK_SIZE;\n\t\t\tc += sz;\n\t\t}\n\t\tphys_addr += SFP_BLOCK_SIZE;\n\t\tsfp_data  += SFP_BLOCK_SIZE;\n\t\toffset += SFP_BLOCK_SIZE;\n\t}\n\n\treturn rval;\n}\n\nint qla24xx_res_count_wait(struct scsi_qla_host *vha,\n    uint16_t *out_mb, int out_mb_sz)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tmbx_cmd_t mc;\n\n\tif (!vha->hw->flags.fw_started)\n\t\tgoto done;\n\n\tmemset(&mc, 0, sizeof(mc));\n\tmc.mb[0] = MBC_GET_RESOURCE_COUNTS;\n\n\trval = qla24xx_send_mb_cmd(vha, &mc);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0xffff,\n\t\t\t\"%s:  fail\\n\", __func__);\n\t} else {\n\t\tif (out_mb_sz <= SIZEOF_IOCB_MB_REG)\n\t\t\tmemcpy(out_mb, mc.mb, out_mb_sz);\n\t\telse\n\t\t\tmemcpy(out_mb, mc.mb, SIZEOF_IOCB_MB_REG);\n\n\t\tql_dbg(ql_dbg_mbx, vha, 0xffff,\n\t\t\t\"%s:  done\\n\", __func__);\n\t}\ndone:\n\treturn rval;\n}\n\nint qla28xx_secure_flash_update(scsi_qla_host_t *vha, uint16_t opts,\n    uint16_t region, uint32_t len, dma_addr_t sfub_dma_addr,\n    uint32_t sfub_len)\n{\n\tint\t\trval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tmcp->mb[0] = MBC_SECURE_FLASH_UPDATE;\n\tmcp->mb[1] = opts;\n\tmcp->mb[2] = region;\n\tmcp->mb[3] = MSW(len);\n\tmcp->mb[4] = LSW(len);\n\tmcp->mb[5] = MSW(sfub_dma_addr);\n\tmcp->mb[6] = LSW(sfub_dma_addr);\n\tmcp->mb[7] = MSW(MSD(sfub_dma_addr));\n\tmcp->mb[8] = LSW(MSD(sfub_dma_addr));\n\tmcp->mb[9] = sfub_len;\n\tmcp->out_mb =\n\t    MBX_9|MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0xffff, \"%s(%ld): failed rval 0x%x, %x %x %x\",\n\t\t\t__func__, vha->host_no, rval, mcp->mb[0], mcp->mb[1],\n\t\t\tmcp->mb[2]);\n\t}\n\n\treturn rval;\n}\n\nint qla2xxx_write_remote_register(scsi_qla_host_t *vha, uint32_t addr,\n    uint32_t data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e8,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_WRITE_REMOTE_REG;\n\tmcp->mb[1] = LSW(addr);\n\tmcp->mb[2] = MSW(addr);\n\tmcp->mb[3] = LSW(data);\n\tmcp->mb[4] = MSW(data);\n\tmcp->out_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10e9,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ea,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint qla2xxx_read_remote_register(scsi_qla_host_t *vha, uint32_t addr,\n    uint32_t *data)\n{\n\tint rval;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\n\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e8,\n\t    \"Entered %s.\\n\", __func__);\n\n\tmcp->mb[0] = MBC_READ_REMOTE_REG;\n\tmcp->mb[1] = LSW(addr);\n\tmcp->mb[2] = MSW(addr);\n\tmcp->out_mb = MBX_2|MBX_1|MBX_0;\n\tmcp->in_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\t*data = (uint32_t)((((uint32_t)mcp->mb[4]) << 16) | mcp->mb[3]);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x10e9,\n\t\t    \"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ea,\n\t\t    \"Done %s.\\n\", __func__);\n\t}\n\n\treturn rval;\n}\n\nint\nql26xx_led_config(scsi_qla_host_t *vha, uint16_t options, uint16_t *led)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tint rval;\n\n\tif (!IS_QLA2031(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_mbx, vha, 0x7070, \"Entered %s (options=%x).\\n\",\n\t    __func__, options);\n\n\tmcp->mb[0] = MBC_SET_GET_FC_LED_CONFIG;\n\tmcp->mb[1] = options;\n\tmcp->out_mb = MBX_1|MBX_0;\n\tmcp->in_mb = MBX_1|MBX_0;\n\tif (options & BIT_0) {\n\t\tif (options & BIT_1) {\n\t\t\tmcp->mb[2] = led[2];\n\t\t\tmcp->out_mb |= MBX_2;\n\t\t}\n\t\tif (options & BIT_2) {\n\t\t\tmcp->mb[3] = led[0];\n\t\t\tmcp->out_mb |= MBX_3;\n\t\t}\n\t\tif (options & BIT_3) {\n\t\t\tmcp->mb[4] = led[1];\n\t\t\tmcp->out_mb |= MBX_4;\n\t\t}\n\t} else {\n\t\tmcp->in_mb |= MBX_4|MBX_3|MBX_2;\n\t}\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\tif (rval) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0x7071, \"Failed %s %x (mb=%x,%x)\\n\",\n\t\t    __func__, rval, mcp->mb[0], mcp->mb[1]);\n\t\treturn rval;\n\t}\n\n\tif (options & BIT_0) {\n\t\tha->beacon_blink_led = 0;\n\t\tql_dbg(ql_dbg_mbx, vha, 0x7072, \"Done %s\\n\", __func__);\n\t} else {\n\t\tled[2] = mcp->mb[2];\n\t\tled[0] = mcp->mb[3];\n\t\tled[1] = mcp->mb[4];\n\t\tql_dbg(ql_dbg_mbx, vha, 0x7073, \"Done %s (led=%x,%x,%x)\\n\",\n\t\t    __func__, led[0], led[1], led[2]);\n\t}\n\n\treturn rval;\n}\n\n \nvoid qla_no_op_mb(struct scsi_qla_host *vha)\n{\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tint rval;\n\n\tmemset(&mc, 0, sizeof(mc));\n\tmcp->mb[0] = 0; \n\tmcp->out_mb = MBX_0;\n\tmcp->in_mb = MBX_0;\n\tmcp->tov = 5;\n\tmcp->flags = 0;\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval) {\n\t\tql_dbg(ql_dbg_async, vha, 0x7071,\n\t\t\t\"Failed %s %x\\n\", __func__, rval);\n\t}\n}\n\nint qla_mailbox_passthru(scsi_qla_host_t *vha,\n\t\t\t uint16_t *mbx_in, uint16_t *mbx_out)\n{\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tint rval = -EINVAL;\n\n\tmemset(&mc, 0, sizeof(mc));\n\t \n\tmemcpy(&mcp->mb, (char *)mbx_in, (32 * sizeof(uint16_t)));\n\n\tmcp->out_mb = 0xFFFFFFFF;\n\tmcp->in_mb = 0xFFFFFFFF;\n\n\tmcp->tov = MBX_TOV_SECONDS;\n\tmcp->flags = 0;\n\tmcp->bufp = NULL;\n\n\trval = qla2x00_mailbox_command(vha, mcp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_mbx, vha, 0xf0a2,\n\t\t\t\"Failed=%x mb[0]=%x.\\n\", rval, mcp->mb[0]);\n\t} else {\n\t\tql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0xf0a3, \"Done %s.\\n\",\n\t\t       __func__);\n\t\t \n\t\tmemcpy(mbx_out, &mcp->mb, 32 * sizeof(uint16_t));\n\t}\n\n\treturn rval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}