{
  "module_name": "qla_dfs.c",
  "hash_id": "63815b8aae58535c3f8fa0a49e44cf4aae29321782af083fe1c744539f89be7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_dfs.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\nstatic struct dentry *qla2x00_dfs_root;\nstatic atomic_t qla2x00_dfs_root_count;\n\n#define QLA_DFS_RPORT_DEVLOSS_TMO\t1\n\nstatic int\nqla_dfs_rport_get(struct fc_port *fp, int attr_id, u64 *val)\n{\n\tswitch (attr_id) {\n\tcase QLA_DFS_RPORT_DEVLOSS_TMO:\n\t\t \n\t\tif (!(fp->nvme_flag & NVME_FLAG_REGISTERED))\n\t\t\treturn -EIO;\n\t\t*val = fp->nvme_remote_port->dev_loss_tmo;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int\nqla_dfs_rport_set(struct fc_port *fp, int attr_id, u64 val)\n{\n\tswitch (attr_id) {\n\tcase QLA_DFS_RPORT_DEVLOSS_TMO:\n\t\t \n\t\tif (!(fp->nvme_flag & NVME_FLAG_REGISTERED))\n\t\t\treturn -EIO;\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\t\treturn nvme_fc_set_remoteport_devloss(fp->nvme_remote_port,\n\t\t\t\t\t\t      val);\n#else  \n\t\treturn -EINVAL;\n#endif  \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#define DEFINE_QLA_DFS_RPORT_RW_ATTR(_attr_id, _attr)\t\t\\\nstatic int qla_dfs_rport_##_attr##_get(void *data, u64 *val)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct fc_port *fp = data;\t\t\t\t\\\n\treturn qla_dfs_rport_get(fp, _attr_id, val);\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic int qla_dfs_rport_##_attr##_set(void *data, u64 val)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct fc_port *fp = data;\t\t\t\t\\\n\treturn qla_dfs_rport_set(fp, _attr_id, val);\t\t\\\n}\t\t\t\t\t\t\t\t\\\nDEFINE_DEBUGFS_ATTRIBUTE(qla_dfs_rport_##_attr##_fops,\t\t\\\n\t\tqla_dfs_rport_##_attr##_get,\t\t\t\\\n\t\tqla_dfs_rport_##_attr##_set, \"%llu\\n\")\n\n \n#define DEFINE_QLA_DFS_RPORT_FIELD_GET(_attr, _get_val)\t\t\t\\\nstatic int qla_dfs_rport_field_##_attr##_get(void *data, u64 *val)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_port *fp = data;\t\t\t\t\t\\\n\t*val = _get_val;\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nDEFINE_DEBUGFS_ATTRIBUTE(qla_dfs_rport_field_##_attr##_fops,\t\t\\\n\t\tqla_dfs_rport_field_##_attr##_get,\t\t\t\\\n\t\tNULL, \"%llu\\n\")\n\n#define DEFINE_QLA_DFS_RPORT_ACCESS(_attr, _get_val) \\\n\tDEFINE_QLA_DFS_RPORT_FIELD_GET(_attr, _get_val)\n\n#define DEFINE_QLA_DFS_RPORT_FIELD(_attr) \\\n\tDEFINE_QLA_DFS_RPORT_FIELD_GET(_attr, fp->_attr)\n\nDEFINE_QLA_DFS_RPORT_RW_ATTR(QLA_DFS_RPORT_DEVLOSS_TMO, dev_loss_tmo);\n\nDEFINE_QLA_DFS_RPORT_FIELD(disc_state);\nDEFINE_QLA_DFS_RPORT_FIELD(scan_state);\nDEFINE_QLA_DFS_RPORT_FIELD(fw_login_state);\nDEFINE_QLA_DFS_RPORT_FIELD(login_pause);\nDEFINE_QLA_DFS_RPORT_FIELD(flags);\nDEFINE_QLA_DFS_RPORT_FIELD(nvme_flag);\nDEFINE_QLA_DFS_RPORT_FIELD(last_rscn_gen);\nDEFINE_QLA_DFS_RPORT_FIELD(rscn_gen);\nDEFINE_QLA_DFS_RPORT_FIELD(login_gen);\nDEFINE_QLA_DFS_RPORT_FIELD(loop_id);\nDEFINE_QLA_DFS_RPORT_FIELD_GET(port_id, fp->d_id.b24);\nDEFINE_QLA_DFS_RPORT_FIELD_GET(sess_kref, kref_read(&fp->sess_kref));\n\nvoid\nqla2x00_dfs_create_rport(scsi_qla_host_t *vha, struct fc_port *fp)\n{\n\tchar wwn[32];\n\n#define QLA_CREATE_RPORT_FIELD_ATTR(_attr)\t\t\t\\\n\tdebugfs_create_file(#_attr, 0400, fp->dfs_rport_dir,\t\\\n\t\tfp, &qla_dfs_rport_field_##_attr##_fops)\n\n\tif (!vha->dfs_rport_root || fp->dfs_rport_dir)\n\t\treturn;\n\n\tsprintf(wwn, \"pn-%016llx\", wwn_to_u64(fp->port_name));\n\tfp->dfs_rport_dir = debugfs_create_dir(wwn, vha->dfs_rport_root);\n\tif (IS_ERR(fp->dfs_rport_dir))\n\t\treturn;\n\tif (NVME_TARGET(vha->hw, fp))\n\t\tdebugfs_create_file(\"dev_loss_tmo\", 0600, fp->dfs_rport_dir,\n\t\t\t\t    fp, &qla_dfs_rport_dev_loss_tmo_fops);\n\n\tQLA_CREATE_RPORT_FIELD_ATTR(disc_state);\n\tQLA_CREATE_RPORT_FIELD_ATTR(scan_state);\n\tQLA_CREATE_RPORT_FIELD_ATTR(fw_login_state);\n\tQLA_CREATE_RPORT_FIELD_ATTR(login_pause);\n\tQLA_CREATE_RPORT_FIELD_ATTR(flags);\n\tQLA_CREATE_RPORT_FIELD_ATTR(nvme_flag);\n\tQLA_CREATE_RPORT_FIELD_ATTR(last_rscn_gen);\n\tQLA_CREATE_RPORT_FIELD_ATTR(rscn_gen);\n\tQLA_CREATE_RPORT_FIELD_ATTR(login_gen);\n\tQLA_CREATE_RPORT_FIELD_ATTR(loop_id);\n\tQLA_CREATE_RPORT_FIELD_ATTR(port_id);\n\tQLA_CREATE_RPORT_FIELD_ATTR(sess_kref);\n}\n\nvoid\nqla2x00_dfs_remove_rport(scsi_qla_host_t *vha, struct fc_port *fp)\n{\n\tif (!vha->dfs_rport_root || !fp->dfs_rport_dir)\n\t\treturn;\n\tdebugfs_remove_recursive(fp->dfs_rport_dir);\n\tfp->dfs_rport_dir = NULL;\n}\n\nstatic int\nqla2x00_dfs_tgt_sess_show(struct seq_file *s, void *unused)\n{\n\tscsi_qla_host_t *vha = s->private;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\tstruct fc_port *sess = NULL;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\n\tseq_printf(s, \"%s\\n\", vha->host_str);\n\tif (tgt) {\n\t\tseq_puts(s, \"Port ID   Port Name                Handle\\n\");\n\n\t\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\t\tlist_for_each_entry(sess, &vha->vp_fcports, list)\n\t\t\tseq_printf(s, \"%02x:%02x:%02x  %8phC  %d\\n\",\n\t\t\t    sess->d_id.b.domain, sess->d_id.b.area,\n\t\t\t    sess->d_id.b.al_pa, sess->port_name,\n\t\t\t    sess->loop_id);\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(qla2x00_dfs_tgt_sess);\n\nstatic int\nqla2x00_dfs_tgt_port_database_show(struct seq_file *s, void *unused)\n{\n\tscsi_qla_host_t *vha = s->private;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct gid_list_info *gid_list;\n\tdma_addr_t gid_list_dma;\n\tfc_port_t fc_port;\n\tchar *id_iter;\n\tint rc, i;\n\tuint16_t entries, loop_id;\n\n\tseq_printf(s, \"%s\\n\", vha->host_str);\n\tgid_list = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t      qla2x00_gid_list_size(ha),\n\t\t\t\t      &gid_list_dma, GFP_KERNEL);\n\tif (!gid_list) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7018,\n\t\t       \"DMA allocation failed for %u\\n\",\n\t\t       qla2x00_gid_list_size(ha));\n\t\treturn 0;\n\t}\n\n\trc = qla24xx_gidlist_wait(vha, gid_list, gid_list_dma,\n\t\t\t\t  &entries);\n\tif (rc != QLA_SUCCESS)\n\t\tgoto out_free_id_list;\n\n\tid_iter = (char *)gid_list;\n\n\tseq_puts(s, \"Port Name\tPort ID\t\tLoop ID\\n\");\n\n\tfor (i = 0; i < entries; i++) {\n\t\tstruct gid_list_info *gid =\n\t\t\t(struct gid_list_info *)id_iter;\n\t\tloop_id = le16_to_cpu(gid->loop_id);\n\t\tmemset(&fc_port, 0, sizeof(fc_port_t));\n\n\t\tfc_port.loop_id = loop_id;\n\n\t\trc = qla24xx_gpdb_wait(vha, &fc_port, 0);\n\t\tseq_printf(s, \"%8phC  %02x%02x%02x  %d\\n\",\n\t\t\t   fc_port.port_name, fc_port.d_id.b.domain,\n\t\t\t   fc_port.d_id.b.area, fc_port.d_id.b.al_pa,\n\t\t\t   fc_port.loop_id);\n\t\tid_iter += ha->gid_list_info_size;\n\t}\nout_free_id_list:\n\tdma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),\n\t\t\t  gid_list, gid_list_dma);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(qla2x00_dfs_tgt_port_database);\n\nstatic int\nqla_dfs_fw_resource_cnt_show(struct seq_file *s, void *unused)\n{\n\tstruct scsi_qla_host *vha = s->private;\n\tuint16_t mb[MAX_IOCB_MB_REG];\n\tint rc;\n\tstruct qla_hw_data *ha = vha->hw;\n\tu16 iocbs_used, i, exch_used;\n\n\trc = qla24xx_res_count_wait(vha, mb, SIZEOF_IOCB_MB_REG);\n\tif (rc != QLA_SUCCESS) {\n\t\tseq_printf(s, \"Mailbox Command failed %d, mb %#x\", rc, mb[0]);\n\t} else {\n\t\tseq_puts(s, \"FW Resource count\\n\\n\");\n\t\tseq_printf(s, \"Original TGT exchg count[%d]\\n\", mb[1]);\n\t\tseq_printf(s, \"Current TGT exchg count[%d]\\n\", mb[2]);\n\t\tseq_printf(s, \"Current Initiator Exchange count[%d]\\n\", mb[3]);\n\t\tseq_printf(s, \"Original Initiator Exchange count[%d]\\n\", mb[6]);\n\t\tseq_printf(s, \"Current IOCB count[%d]\\n\", mb[7]);\n\t\tseq_printf(s, \"Original IOCB count[%d]\\n\", mb[10]);\n\t\tseq_printf(s, \"MAX VP count[%d]\\n\", mb[11]);\n\t\tseq_printf(s, \"MAX FCF count[%d]\\n\", mb[12]);\n\t\tseq_printf(s, \"Current free pageable XCB buffer cnt[%d]\\n\",\n\t\t    mb[20]);\n\t\tseq_printf(s, \"Original Initiator fast XCB buffer cnt[%d]\\n\",\n\t\t    mb[21]);\n\t\tseq_printf(s, \"Current free Initiator fast XCB buffer cnt[%d]\\n\",\n\t\t    mb[22]);\n\t\tseq_printf(s, \"Original Target fast XCB buffer cnt[%d]\\n\",\n\t\t    mb[23]);\n\t}\n\n\tif (ql2xenforce_iocb_limit) {\n\t\t \n\t\tiocbs_used = ha->base_qpair->fwres.iocbs_used;\n\t\texch_used = ha->base_qpair->fwres.exch_used;\n\t\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\t\tif (ha->queue_pair_map[i]) {\n\t\t\t\tiocbs_used += ha->queue_pair_map[i]->fwres.iocbs_used;\n\t\t\t\texch_used += ha->queue_pair_map[i]->fwres.exch_used;\n\t\t\t}\n\t\t}\n\n\t\tseq_printf(s, \"Driver: estimate iocb used [%d] high water limit [%d]\\n\",\n\t\t\t   iocbs_used, ha->base_qpair->fwres.iocbs_limit);\n\n\t\tseq_printf(s, \"estimate exchange used[%d] high water limit [%d] n\",\n\t\t\t   exch_used, ha->base_qpair->fwres.exch_limit);\n\n\t\tif (ql2xenforce_iocb_limit == 2) {\n\t\t\tiocbs_used = atomic_read(&ha->fwres.iocb_used);\n\t\t\texch_used  = atomic_read(&ha->fwres.exch_used);\n\t\t\tseq_printf(s, \"        estimate iocb2 used [%d] high water limit [%d]\\n\",\n\t\t\t\t\tiocbs_used, ha->fwres.iocb_limit);\n\n\t\t\tseq_printf(s, \"        estimate exchange2 used[%d] high water limit [%d] \\n\",\n\t\t\t\t\texch_used, ha->fwres.exch_limit);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(qla_dfs_fw_resource_cnt);\n\nstatic int\nqla_dfs_tgt_counters_show(struct seq_file *s, void *unused)\n{\n\tstruct scsi_qla_host *vha = s->private;\n\tstruct qla_qpair *qpair = vha->hw->base_qpair;\n\tuint64_t qla_core_sbt_cmd, core_qla_que_buf, qla_core_ret_ctio,\n\t\tcore_qla_snd_status, qla_core_ret_sta_ctio, core_qla_free_cmd,\n\t\tnum_q_full_sent, num_alloc_iocb_failed, num_term_xchg_sent;\n\tu16 i;\n\tfc_port_t *fcport = NULL;\n\n\tif (qla2x00_chip_is_down(vha))\n\t\treturn 0;\n\n\tqla_core_sbt_cmd = qpair->tgt_counters.qla_core_sbt_cmd;\n\tcore_qla_que_buf = qpair->tgt_counters.core_qla_que_buf;\n\tqla_core_ret_ctio = qpair->tgt_counters.qla_core_ret_ctio;\n\tcore_qla_snd_status = qpair->tgt_counters.core_qla_snd_status;\n\tqla_core_ret_sta_ctio = qpair->tgt_counters.qla_core_ret_sta_ctio;\n\tcore_qla_free_cmd = qpair->tgt_counters.core_qla_free_cmd;\n\tnum_q_full_sent = qpair->tgt_counters.num_q_full_sent;\n\tnum_alloc_iocb_failed = qpair->tgt_counters.num_alloc_iocb_failed;\n\tnum_term_xchg_sent = qpair->tgt_counters.num_term_xchg_sent;\n\n\tfor (i = 0; i < vha->hw->max_qpairs; i++) {\n\t\tqpair = vha->hw->queue_pair_map[i];\n\t\tif (!qpair)\n\t\t\tcontinue;\n\t\tqla_core_sbt_cmd += qpair->tgt_counters.qla_core_sbt_cmd;\n\t\tcore_qla_que_buf += qpair->tgt_counters.core_qla_que_buf;\n\t\tqla_core_ret_ctio += qpair->tgt_counters.qla_core_ret_ctio;\n\t\tcore_qla_snd_status += qpair->tgt_counters.core_qla_snd_status;\n\t\tqla_core_ret_sta_ctio +=\n\t\t    qpair->tgt_counters.qla_core_ret_sta_ctio;\n\t\tcore_qla_free_cmd += qpair->tgt_counters.core_qla_free_cmd;\n\t\tnum_q_full_sent += qpair->tgt_counters.num_q_full_sent;\n\t\tnum_alloc_iocb_failed +=\n\t\t    qpair->tgt_counters.num_alloc_iocb_failed;\n\t\tnum_term_xchg_sent += qpair->tgt_counters.num_term_xchg_sent;\n\t}\n\n\tseq_puts(s, \"Target Counters\\n\");\n\tseq_printf(s, \"qla_core_sbt_cmd = %lld\\n\",\n\t\tqla_core_sbt_cmd);\n\tseq_printf(s, \"qla_core_ret_sta_ctio = %lld\\n\",\n\t\tqla_core_ret_sta_ctio);\n\tseq_printf(s, \"qla_core_ret_ctio = %lld\\n\",\n\t\tqla_core_ret_ctio);\n\tseq_printf(s, \"core_qla_que_buf = %lld\\n\",\n\t\tcore_qla_que_buf);\n\tseq_printf(s, \"core_qla_snd_status = %lld\\n\",\n\t\tcore_qla_snd_status);\n\tseq_printf(s, \"core_qla_free_cmd = %lld\\n\",\n\t\tcore_qla_free_cmd);\n\tseq_printf(s, \"num alloc iocb failed = %lld\\n\",\n\t\tnum_alloc_iocb_failed);\n\tseq_printf(s, \"num term exchange sent = %lld\\n\",\n\t\tnum_term_xchg_sent);\n\tseq_printf(s, \"num Q full sent = %lld\\n\",\n\t\tnum_q_full_sent);\n\n\t \n\tseq_printf(s, \"DIF Inp Bytes = %lld\\n\",\n\t\tvha->qla_stats.qla_dif_stats.dif_input_bytes);\n\tseq_printf(s, \"DIF Outp Bytes = %lld\\n\",\n\t\tvha->qla_stats.qla_dif_stats.dif_output_bytes);\n\tseq_printf(s, \"DIF Inp Req = %lld\\n\",\n\t\tvha->qla_stats.qla_dif_stats.dif_input_requests);\n\tseq_printf(s, \"DIF Outp Req = %lld\\n\",\n\t\tvha->qla_stats.qla_dif_stats.dif_output_requests);\n\tseq_printf(s, \"DIF Guard err = %d\\n\",\n\t\tvha->qla_stats.qla_dif_stats.dif_guard_err);\n\tseq_printf(s, \"DIF Ref tag err = %d\\n\",\n\t\tvha->qla_stats.qla_dif_stats.dif_ref_tag_err);\n\tseq_printf(s, \"DIF App tag err = %d\\n\",\n\t\tvha->qla_stats.qla_dif_stats.dif_app_tag_err);\n\n\tseq_puts(s, \"\\n\");\n\tseq_puts(s, \"Initiator Error Counters\\n\");\n\tseq_printf(s, \"HW Error Count =\t\t%14lld\\n\",\n\t\t   vha->hw_err_cnt);\n\tseq_printf(s, \"Link Down Count =\t%14lld\\n\",\n\t\t   vha->short_link_down_cnt);\n\tseq_printf(s, \"Interface Err Count =\t%14lld\\n\",\n\t\t   vha->interface_err_cnt);\n\tseq_printf(s, \"Cmd Timeout Count =\t%14lld\\n\",\n\t\t   vha->cmd_timeout_cnt);\n\tseq_printf(s, \"Reset Count =\t\t%14lld\\n\",\n\t\t   vha->reset_cmd_err_cnt);\n\tseq_puts(s, \"\\n\");\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (!fcport->rport)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \"Target Num = %7d Link Down Count = %14lld\\n\",\n\t\t\t   fcport->rport->number, fcport->tgt_short_link_down_cnt);\n\t}\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(qla_dfs_tgt_counters);\n\nstatic int\nqla2x00_dfs_fce_show(struct seq_file *s, void *unused)\n{\n\tscsi_qla_host_t *vha = s->private;\n\tuint32_t cnt;\n\tuint32_t *fce;\n\tuint64_t fce_start;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmutex_lock(&ha->fce_mutex);\n\n\tseq_puts(s, \"FCE Trace Buffer\\n\");\n\tseq_printf(s, \"In Pointer = %llx\\n\\n\", (unsigned long long)ha->fce_wr);\n\tseq_printf(s, \"Base = %llx\\n\\n\", (unsigned long long) ha->fce_dma);\n\tseq_puts(s, \"FCE Enable Registers\\n\");\n\tseq_printf(s, \"%08x %08x %08x %08x %08x %08x\\n\",\n\t    ha->fce_mb[0], ha->fce_mb[2], ha->fce_mb[3], ha->fce_mb[4],\n\t    ha->fce_mb[5], ha->fce_mb[6]);\n\n\tfce = (uint32_t *) ha->fce;\n\tfce_start = (unsigned long long) ha->fce_dma;\n\tfor (cnt = 0; cnt < fce_calc_size(ha->fce_bufs) / 4; cnt++) {\n\t\tif (cnt % 8 == 0)\n\t\t\tseq_printf(s, \"\\n%llx: \",\n\t\t\t    (unsigned long long)((cnt * 4) + fce_start));\n\t\telse\n\t\t\tseq_putc(s, ' ');\n\t\tseq_printf(s, \"%08x\", *fce++);\n\t}\n\n\tseq_puts(s, \"\\nEnd\\n\");\n\n\tmutex_unlock(&ha->fce_mutex);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_dfs_fce_open(struct inode *inode, struct file *file)\n{\n\tscsi_qla_host_t *vha = inode->i_private;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\n\tif (!ha->flags.fce_enabled)\n\t\tgoto out;\n\n\tmutex_lock(&ha->fce_mutex);\n\n\t \n\trval = qla2x00_disable_fce_trace(vha, &ha->fce_wr, &ha->fce_rd);\n\tif (rval)\n\t\tql_dbg(ql_dbg_user, vha, 0x705c,\n\t\t    \"DebugFS: Unable to disable FCE (%d).\\n\", rval);\n\n\tha->flags.fce_enabled = 0;\n\n\tmutex_unlock(&ha->fce_mutex);\nout:\n\treturn single_open(file, qla2x00_dfs_fce_show, vha);\n}\n\nstatic int\nqla2x00_dfs_fce_release(struct inode *inode, struct file *file)\n{\n\tscsi_qla_host_t *vha = inode->i_private;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\n\tif (ha->flags.fce_enabled)\n\t\tgoto out;\n\n\tmutex_lock(&ha->fce_mutex);\n\n\t \n\tha->flags.fce_enabled = 1;\n\tmemset(ha->fce, 0, fce_calc_size(ha->fce_bufs));\n\trval = qla2x00_enable_fce_trace(vha, ha->fce_dma, ha->fce_bufs,\n\t    ha->fce_mb, &ha->fce_bufs);\n\tif (rval) {\n\t\tql_dbg(ql_dbg_user, vha, 0x700d,\n\t\t    \"DebugFS: Unable to reinitialize FCE (%d).\\n\", rval);\n\t\tha->flags.fce_enabled = 0;\n\t}\n\n\tmutex_unlock(&ha->fce_mutex);\nout:\n\treturn single_release(inode, file);\n}\n\nstatic const struct file_operations dfs_fce_ops = {\n\t.open\t\t= qla2x00_dfs_fce_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= qla2x00_dfs_fce_release,\n};\n\nstatic int\nqla_dfs_naqp_show(struct seq_file *s, void *unused)\n{\n\tstruct scsi_qla_host *vha = s->private;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tseq_printf(s, \"%d\\n\", ha->tgt.num_act_qpairs);\n\treturn 0;\n}\n\n \n#define QLA_DFS_SETUP_RD(_name, _ctx_struct)\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nqla_dfs_##_name##_open(struct inode *inode, struct file *file)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t_ctx_struct *__ctx = inode->i_private;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn single_open(file, qla_dfs_##_name##_show, __ctx);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations qla_dfs_##_name##_ops = {\t\t\\\n\t.open           = qla_dfs_##_name##_open,\t\t\t\\\n\t.read           = seq_read,\t\t\t\t\t\\\n\t.llseek         = seq_lseek,\t\t\t\t\t\\\n\t.release        = single_release,\t\t\t\t\\\n};\n\n#define QLA_DFS_SETUP_RW(_name, _ctx_struct)\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nqla_dfs_##_name##_open(struct inode *inode, struct file *file)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t_ctx_struct *__ctx = inode->i_private;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn single_open(file, qla_dfs_##_name##_show, __ctx);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic const struct file_operations qla_dfs_##_name##_ops = {\t\t\\\n\t.open           = qla_dfs_##_name##_open,\t\t\t\\\n\t.read           = seq_read,\t\t\t\t\t\\\n\t.llseek         = seq_lseek,\t\t\t\t\t\\\n\t.release        = single_release,\t\t\t\t\\\n\t.write\t\t= qla_dfs_##_name##_write,\t\t\t\\\n};\n\n#define QLA_DFS_ROOT_CREATE_FILE(_name, _perm, _ctx)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!qla_dfs_##_name)\t\t\t\t\t\\\n\t\t\tqla_dfs_##_name = debugfs_create_file(#_name,\t\\\n\t\t\t\t\t_perm, qla2x00_dfs_root, _ctx,\t\\\n\t\t\t\t\t&qla_dfs_##_name##_ops);\t\\\n\t} while (0)\n\n#define QLA_DFS_ROOT_REMOVE_FILE(_name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (qla_dfs_##_name) {\t\t\t\t\t\\\n\t\t\tdebugfs_remove(qla_dfs_##_name);\t\t\\\n\t\t\tqla_dfs_##_name = NULL;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define QLA_DFS_CREATE_FILE(_struct, _name, _perm, _parent, _ctx)\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\t(_struct)->dfs_##_name = debugfs_create_file(#_name,\t\\\n\t\t\t\t\t_perm, _parent, _ctx,\t\t\\\n\t\t\t\t\t&qla_dfs_##_name##_ops)\t\t\\\n\t} while (0)\n\n#define QLA_DFS_REMOVE_FILE(_struct, _name)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((_struct)->dfs_##_name) {\t\t\t\t\\\n\t\t\tdebugfs_remove((_struct)->dfs_##_name);\t\t\\\n\t\t\t(_struct)->dfs_##_name = NULL;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic int\nqla_dfs_naqp_open(struct inode *inode, struct file *file)\n{\n\tstruct scsi_qla_host *vha = inode->i_private;\n\n\treturn single_open(file, qla_dfs_naqp_show, vha);\n}\n\nstatic ssize_t\nqla_dfs_naqp_write(struct file *file, const char __user *buffer,\n    size_t count, loff_t *pos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct scsi_qla_host *vha = s->private;\n\tstruct qla_hw_data *ha = vha->hw;\n\tchar *buf;\n\tint rc = 0;\n\tunsigned long num_act_qp;\n\n\tif (!(IS_QLA27XX(ha) || IS_QLA83XX(ha) || IS_QLA28XX(ha))) {\n\t\tpr_err(\"host%ld: this adapter does not support Multi Q.\",\n\t\t    vha->host_no);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!vha->flags.qpairs_available) {\n\t\tpr_err(\"host%ld: Driver is not setup with Multi Q.\",\n\t\t    vha->host_no);\n\t\treturn -EINVAL;\n\t}\n\tbuf = memdup_user_nul(buffer, count);\n\tif (IS_ERR(buf)) {\n\t\tpr_err(\"host%ld: fail to copy user buffer.\",\n\t\t    vha->host_no);\n\t\treturn PTR_ERR(buf);\n\t}\n\n\tnum_act_qp = simple_strtoul(buf, NULL, 0);\n\n\tif (num_act_qp >= vha->hw->max_qpairs) {\n\t\tpr_err(\"User set invalid number of qpairs %lu. Max = %d\",\n\t\t    num_act_qp, vha->hw->max_qpairs);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\tif (num_act_qp != ha->tgt.num_act_qpairs) {\n\t\tha->tgt.num_act_qpairs = num_act_qp;\n\t\tqlt_clr_qp_table(vha);\n\t}\n\trc = count;\nout_free:\n\tkfree(buf);\n\treturn rc;\n}\n\nstatic const struct file_operations dfs_naqp_ops = {\n\t.open\t\t= qla_dfs_naqp_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n\t.write\t\t= qla_dfs_naqp_write,\n};\n\n\nint\nqla2x00_dfs_setup(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\tgoto out;\n\tif (!ha->fce)\n\t\tgoto out;\n\n\tif (qla2x00_dfs_root)\n\t\tgoto create_dir;\n\n\tatomic_set(&qla2x00_dfs_root_count, 0);\n\tqla2x00_dfs_root = debugfs_create_dir(QLA2XXX_DRIVER_NAME, NULL);\n\ncreate_dir:\n\tif (ha->dfs_dir)\n\t\tgoto create_nodes;\n\n\tmutex_init(&ha->fce_mutex);\n\tha->dfs_dir = debugfs_create_dir(vha->host_str, qla2x00_dfs_root);\n\n\tatomic_inc(&qla2x00_dfs_root_count);\n\ncreate_nodes:\n\tha->dfs_fw_resource_cnt = debugfs_create_file(\"fw_resource_count\",\n\t    S_IRUSR, ha->dfs_dir, vha, &qla_dfs_fw_resource_cnt_fops);\n\n\tha->dfs_tgt_counters = debugfs_create_file(\"tgt_counters\", S_IRUSR,\n\t    ha->dfs_dir, vha, &qla_dfs_tgt_counters_fops);\n\n\tha->tgt.dfs_tgt_port_database = debugfs_create_file(\"tgt_port_database\",\n\t    S_IRUSR,  ha->dfs_dir, vha, &qla2x00_dfs_tgt_port_database_fops);\n\n\tha->dfs_fce = debugfs_create_file(\"fce\", S_IRUSR, ha->dfs_dir, vha,\n\t    &dfs_fce_ops);\n\n\tha->tgt.dfs_tgt_sess = debugfs_create_file(\"tgt_sess\",\n\t\tS_IRUSR, ha->dfs_dir, vha, &qla2x00_dfs_tgt_sess_fops);\n\n\tif (IS_QLA27XX(ha) || IS_QLA83XX(ha) || IS_QLA28XX(ha)) {\n\t\tha->tgt.dfs_naqp = debugfs_create_file(\"naqp\",\n\t\t    0400, ha->dfs_dir, vha, &dfs_naqp_ops);\n\t\tif (IS_ERR(ha->tgt.dfs_naqp)) {\n\t\t\tql_log(ql_log_warn, vha, 0xd011,\n\t\t\t       \"Unable to create debugFS naqp node.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\tvha->dfs_rport_root = debugfs_create_dir(\"rports\", ha->dfs_dir);\n\tif (IS_ERR(vha->dfs_rport_root)) {\n\t\tql_log(ql_log_warn, vha, 0xd012,\n\t\t       \"Unable to create debugFS rports node.\\n\");\n\t\tgoto out;\n\t}\nout:\n\treturn 0;\n}\n\nint\nqla2x00_dfs_remove(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (ha->tgt.dfs_naqp) {\n\t\tdebugfs_remove(ha->tgt.dfs_naqp);\n\t\tha->tgt.dfs_naqp = NULL;\n\t}\n\n\tif (ha->tgt.dfs_tgt_sess) {\n\t\tdebugfs_remove(ha->tgt.dfs_tgt_sess);\n\t\tha->tgt.dfs_tgt_sess = NULL;\n\t}\n\n\tif (ha->tgt.dfs_tgt_port_database) {\n\t\tdebugfs_remove(ha->tgt.dfs_tgt_port_database);\n\t\tha->tgt.dfs_tgt_port_database = NULL;\n\t}\n\n\tif (ha->dfs_fw_resource_cnt) {\n\t\tdebugfs_remove(ha->dfs_fw_resource_cnt);\n\t\tha->dfs_fw_resource_cnt = NULL;\n\t}\n\n\tif (ha->dfs_tgt_counters) {\n\t\tdebugfs_remove(ha->dfs_tgt_counters);\n\t\tha->dfs_tgt_counters = NULL;\n\t}\n\n\tif (ha->dfs_fce) {\n\t\tdebugfs_remove(ha->dfs_fce);\n\t\tha->dfs_fce = NULL;\n\t}\n\n\tif (vha->dfs_rport_root) {\n\t\tdebugfs_remove_recursive(vha->dfs_rport_root);\n\t\tvha->dfs_rport_root = NULL;\n\t}\n\n\tif (ha->dfs_dir) {\n\t\tdebugfs_remove(ha->dfs_dir);\n\t\tha->dfs_dir = NULL;\n\t\tatomic_dec(&qla2x00_dfs_root_count);\n\t}\n\n\tif (atomic_read(&qla2x00_dfs_root_count) == 0 &&\n\t    qla2x00_dfs_root) {\n\t\tdebugfs_remove(qla2x00_dfs_root);\n\t\tqla2x00_dfs_root = NULL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}