{
  "module_name": "qla_tmpl.c",
  "hash_id": "11a830d8e1fe210ae5f16abf9fedd2d8077b64b63d96cf3f4c8fc3a698b503a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_tmpl.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_tmpl.h\"\n\n#define ISPREG(vha)\t(&(vha)->hw->iobase->isp24)\n#define IOBAR(reg)\toffsetof(typeof(*(reg)), iobase_addr)\n#define IOBASE(vha)\tIOBAR(ISPREG(vha))\n#define INVALID_ENTRY ((struct qla27xx_fwdt_entry *)0xffffffffffffffffUL)\n\nstatic inline void\nqla27xx_insert16(uint16_t value, void *buf, ulong *len)\n{\n\tif (buf) {\n\t\tbuf += *len;\n\t\t*(__le16 *)buf = cpu_to_le16(value);\n\t}\n\t*len += sizeof(value);\n}\n\nstatic inline void\nqla27xx_insert32(uint32_t value, void *buf, ulong *len)\n{\n\tif (buf) {\n\t\tbuf += *len;\n\t\t*(__le32 *)buf = cpu_to_le32(value);\n\t}\n\t*len += sizeof(value);\n}\n\nstatic inline void\nqla27xx_insertbuf(void *mem, ulong size, void *buf, ulong *len)\n{\n\tif (buf && mem && size) {\n\t\tbuf += *len;\n\t\tmemcpy(buf, mem, size);\n\t}\n\t*len += size;\n}\n\nstatic inline void\nqla27xx_read8(void __iomem *window, void *buf, ulong *len)\n{\n\tuint8_t value = ~0;\n\n\tif (buf) {\n\t\tvalue = rd_reg_byte(window);\n\t}\n\tqla27xx_insert32(value, buf, len);\n}\n\nstatic inline void\nqla27xx_read16(void __iomem *window, void *buf, ulong *len)\n{\n\tuint16_t value = ~0;\n\n\tif (buf) {\n\t\tvalue = rd_reg_word(window);\n\t}\n\tqla27xx_insert32(value, buf, len);\n}\n\nstatic inline void\nqla27xx_read32(void __iomem *window, void *buf, ulong *len)\n{\n\tuint32_t value = ~0;\n\n\tif (buf) {\n\t\tvalue = rd_reg_dword(window);\n\t}\n\tqla27xx_insert32(value, buf, len);\n}\n\nstatic inline void (*qla27xx_read_vector(uint width))(void __iomem*, void *, ulong *)\n{\n\treturn\n\t    (width == 1) ? qla27xx_read8 :\n\t    (width == 2) ? qla27xx_read16 :\n\t\t\t   qla27xx_read32;\n}\n\nstatic inline void\nqla27xx_read_reg(__iomem struct device_reg_24xx *reg,\n\tuint offset, void *buf, ulong *len)\n{\n\tvoid __iomem *window = (void __iomem *)reg + offset;\n\n\tqla27xx_read32(window, buf, len);\n}\n\nstatic inline void\nqla27xx_write_reg(__iomem struct device_reg_24xx *reg,\n\tuint offset, uint32_t data, void *buf)\n{\n\tif (buf) {\n\t\tvoid __iomem *window = (void __iomem *)reg + offset;\n\n\t\twrt_reg_dword(window, data);\n\t}\n}\n\nstatic inline void\nqla27xx_read_window(__iomem struct device_reg_24xx *reg,\n\tuint32_t addr, uint offset, uint count, uint width, void *buf,\n\tulong *len)\n{\n\tvoid __iomem *window = (void __iomem *)reg + offset;\n\tvoid (*readn)(void __iomem*, void *, ulong *) = qla27xx_read_vector(width);\n\n\tqla27xx_write_reg(reg, IOBAR(reg), addr, buf);\n\twhile (count--) {\n\t\tqla27xx_insert32(addr, buf, len);\n\t\treadn(window, buf, len);\n\t\twindow += width;\n\t\taddr++;\n\t}\n}\n\nstatic inline void\nqla27xx_skip_entry(struct qla27xx_fwdt_entry *ent, void *buf)\n{\n\tif (buf)\n\t\tent->hdr.driver_flags |= DRIVER_FLAG_SKIP_ENTRY;\n}\n\nstatic inline struct qla27xx_fwdt_entry *\nqla27xx_next_entry(struct qla27xx_fwdt_entry *ent)\n{\n\treturn (void *)ent + le32_to_cpu(ent->hdr.size);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t0(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tql_dbg(ql_dbg_misc, vha, 0xd100,\n\t    \"%s: nop [%lx]\\n\", __func__, *len);\n\tqla27xx_skip_entry(ent, buf);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t255(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tql_dbg(ql_dbg_misc, vha, 0xd1ff,\n\t    \"%s: end [%lx]\\n\", __func__, *len);\n\tqla27xx_skip_entry(ent, buf);\n\n\t \n\treturn NULL;\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t256(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong addr = le32_to_cpu(ent->t256.base_addr);\n\tuint offset = ent->t256.pci_offset;\n\tulong count = le16_to_cpu(ent->t256.reg_count);\n\tuint width = ent->t256.reg_width;\n\n\tql_dbg(ql_dbg_misc, vha, 0xd200,\n\t    \"%s: rdio t1 [%lx]\\n\", __func__, *len);\n\tqla27xx_read_window(ISPREG(vha), addr, offset, count, width, buf, len);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t257(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong addr = le32_to_cpu(ent->t257.base_addr);\n\tuint offset = ent->t257.pci_offset;\n\tulong data = le32_to_cpu(ent->t257.write_data);\n\n\tql_dbg(ql_dbg_misc, vha, 0xd201,\n\t    \"%s: wrio t1 [%lx]\\n\", __func__, *len);\n\tqla27xx_write_reg(ISPREG(vha), IOBASE(vha), addr, buf);\n\tqla27xx_write_reg(ISPREG(vha), offset, data, buf);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t258(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tuint banksel = ent->t258.banksel_offset;\n\tulong bank = le32_to_cpu(ent->t258.bank);\n\tulong addr = le32_to_cpu(ent->t258.base_addr);\n\tuint offset = ent->t258.pci_offset;\n\tuint count = le16_to_cpu(ent->t258.reg_count);\n\tuint width = ent->t258.reg_width;\n\n\tql_dbg(ql_dbg_misc, vha, 0xd202,\n\t    \"%s: rdio t2 [%lx]\\n\", __func__, *len);\n\tqla27xx_write_reg(ISPREG(vha), banksel, bank, buf);\n\tqla27xx_read_window(ISPREG(vha), addr, offset, count, width, buf, len);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t259(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong addr = le32_to_cpu(ent->t259.base_addr);\n\tuint banksel = ent->t259.banksel_offset;\n\tulong bank = le32_to_cpu(ent->t259.bank);\n\tuint offset = ent->t259.pci_offset;\n\tulong data = le32_to_cpu(ent->t259.write_data);\n\n\tql_dbg(ql_dbg_misc, vha, 0xd203,\n\t    \"%s: wrio t2 [%lx]\\n\", __func__, *len);\n\tqla27xx_write_reg(ISPREG(vha), IOBASE(vha), addr, buf);\n\tqla27xx_write_reg(ISPREG(vha), banksel, bank, buf);\n\tqla27xx_write_reg(ISPREG(vha), offset, data, buf);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t260(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tuint offset = ent->t260.pci_offset;\n\n\tql_dbg(ql_dbg_misc, vha, 0xd204,\n\t    \"%s: rdpci [%lx]\\n\", __func__, *len);\n\tqla27xx_insert32(offset, buf, len);\n\tqla27xx_read_reg(ISPREG(vha), offset, buf, len);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t261(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tuint offset = ent->t261.pci_offset;\n\tulong data = le32_to_cpu(ent->t261.write_data);\n\n\tql_dbg(ql_dbg_misc, vha, 0xd205,\n\t    \"%s: wrpci [%lx]\\n\", __func__, *len);\n\tqla27xx_write_reg(ISPREG(vha), offset, data, buf);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t262(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tuint area = ent->t262.ram_area;\n\tulong start = le32_to_cpu(ent->t262.start_addr);\n\tulong end = le32_to_cpu(ent->t262.end_addr);\n\tulong dwords;\n\tint rc;\n\n\tql_dbg(ql_dbg_misc, vha, 0xd206,\n\t    \"%s: rdram(%x) [%lx]\\n\", __func__, ent->t262.ram_area, *len);\n\n\tif (area == T262_RAM_AREA_CRITICAL_RAM) {\n\t\t;\n\t} else if (area == T262_RAM_AREA_EXTERNAL_RAM) {\n\t\tend = vha->hw->fw_memory_size;\n\t\tif (buf)\n\t\t\tent->t262.end_addr = cpu_to_le32(end);\n\t} else if (area == T262_RAM_AREA_SHARED_RAM) {\n\t\tstart = vha->hw->fw_shared_ram_start;\n\t\tend = vha->hw->fw_shared_ram_end;\n\t\tif (buf) {\n\t\t\tent->t262.start_addr = cpu_to_le32(start);\n\t\t\tent->t262.end_addr = cpu_to_le32(end);\n\t\t}\n\t} else if (area == T262_RAM_AREA_DDR_RAM) {\n\t\tstart = vha->hw->fw_ddr_ram_start;\n\t\tend = vha->hw->fw_ddr_ram_end;\n\t\tif (buf) {\n\t\t\tent->t262.start_addr = cpu_to_le32(start);\n\t\t\tent->t262.end_addr = cpu_to_le32(end);\n\t\t}\n\t} else if (area == T262_RAM_AREA_MISC) {\n\t\tif (buf) {\n\t\t\tent->t262.start_addr = cpu_to_le32(start);\n\t\t\tent->t262.end_addr = cpu_to_le32(end);\n\t\t}\n\t} else {\n\t\tql_dbg(ql_dbg_misc, vha, 0xd022,\n\t\t    \"%s: unknown area %x\\n\", __func__, area);\n\t\tqla27xx_skip_entry(ent, buf);\n\t\tgoto done;\n\t}\n\n\tif (end < start || start == 0 || end == 0) {\n\t\tql_dbg(ql_dbg_misc, vha, 0xd023,\n\t\t    \"%s: unusable range (start=%lx end=%lx)\\n\",\n\t\t    __func__, start, end);\n\t\tqla27xx_skip_entry(ent, buf);\n\t\tgoto done;\n\t}\n\n\tdwords = end - start + 1;\n\tif (buf) {\n\t\tbuf += *len;\n\t\trc = qla24xx_dump_ram(vha->hw, start, buf, dwords, &buf);\n\t\tif (rc != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0xffff,\n\t\t\t    \"%s: dump ram MB failed. Area %xh start %lxh end %lxh\\n\",\n\t\t\t    __func__, area, start, end);\n\t\t\treturn INVALID_ENTRY;\n\t\t}\n\t}\n\t*len += dwords * sizeof(uint32_t);\ndone:\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t263(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tuint type = ent->t263.queue_type;\n\tuint count = 0;\n\tuint i;\n\tuint length;\n\n\tql_dbg(ql_dbg_misc + ql_dbg_verbose, vha, 0xd207,\n\t    \"%s: getq(%x) [%lx]\\n\", __func__, type, *len);\n\tif (type == T263_QUEUE_TYPE_REQ) {\n\t\tfor (i = 0; i < vha->hw->max_req_queues; i++) {\n\t\t\tstruct req_que *req = vha->hw->req_q_map[i];\n\n\t\t\tif (req || !buf) {\n\t\t\t\tlength = req ?\n\t\t\t\t    req->length : REQUEST_ENTRY_CNT_24XX;\n\t\t\t\tqla27xx_insert16(i, buf, len);\n\t\t\t\tqla27xx_insert16(length, buf, len);\n\t\t\t\tqla27xx_insertbuf(req ? req->ring : NULL,\n\t\t\t\t    length * sizeof(*req->ring), buf, len);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t} else if (type == T263_QUEUE_TYPE_RSP) {\n\t\tfor (i = 0; i < vha->hw->max_rsp_queues; i++) {\n\t\t\tstruct rsp_que *rsp = vha->hw->rsp_q_map[i];\n\n\t\t\tif (rsp || !buf) {\n\t\t\t\tlength = rsp ?\n\t\t\t\t    rsp->length : RESPONSE_ENTRY_CNT_MQ;\n\t\t\t\tqla27xx_insert16(i, buf, len);\n\t\t\t\tqla27xx_insert16(length, buf, len);\n\t\t\t\tqla27xx_insertbuf(rsp ? rsp->ring : NULL,\n\t\t\t\t    length * sizeof(*rsp->ring), buf, len);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t} else if (QLA_TGT_MODE_ENABLED() &&\n\t    ent->t263.queue_type == T263_QUEUE_TYPE_ATIO) {\n\t\tstruct qla_hw_data *ha = vha->hw;\n\t\tstruct atio *atr = ha->tgt.atio_ring;\n\n\t\tif (atr || !buf) {\n\t\t\tlength = ha->tgt.atio_q_length;\n\t\t\tqla27xx_insert16(0, buf, len);\n\t\t\tqla27xx_insert16(length, buf, len);\n\t\t\tqla27xx_insertbuf(atr, length * sizeof(*atr), buf, len);\n\t\t\tcount++;\n\t\t}\n\t} else {\n\t\tql_dbg(ql_dbg_misc, vha, 0xd026,\n\t\t    \"%s: unknown queue %x\\n\", __func__, type);\n\t\tqla27xx_skip_entry(ent, buf);\n\t}\n\n\tif (buf) {\n\t\tif (count)\n\t\t\tent->t263.num_queues = count;\n\t\telse\n\t\t\tqla27xx_skip_entry(ent, buf);\n\t}\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t264(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tql_dbg(ql_dbg_misc, vha, 0xd208,\n\t    \"%s: getfce [%lx]\\n\", __func__, *len);\n\tif (vha->hw->fce) {\n\t\tif (buf) {\n\t\t\tent->t264.fce_trace_size = FCE_SIZE;\n\t\t\tent->t264.write_pointer = vha->hw->fce_wr;\n\t\t\tent->t264.base_pointer = vha->hw->fce_dma;\n\t\t\tent->t264.fce_enable_mb0 = vha->hw->fce_mb[0];\n\t\t\tent->t264.fce_enable_mb2 = vha->hw->fce_mb[2];\n\t\t\tent->t264.fce_enable_mb3 = vha->hw->fce_mb[3];\n\t\t\tent->t264.fce_enable_mb4 = vha->hw->fce_mb[4];\n\t\t\tent->t264.fce_enable_mb5 = vha->hw->fce_mb[5];\n\t\t\tent->t264.fce_enable_mb6 = vha->hw->fce_mb[6];\n\t\t}\n\t\tqla27xx_insertbuf(vha->hw->fce, FCE_SIZE, buf, len);\n\t} else {\n\t\tql_dbg(ql_dbg_misc, vha, 0xd027,\n\t\t    \"%s: missing fce\\n\", __func__);\n\t\tqla27xx_skip_entry(ent, buf);\n\t}\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t265(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tql_dbg(ql_dbg_misc + ql_dbg_verbose, vha, 0xd209,\n\t    \"%s: pause risc [%lx]\\n\", __func__, *len);\n\tif (buf)\n\t\tqla24xx_pause_risc(ISPREG(vha), vha->hw);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t266(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tql_dbg(ql_dbg_misc, vha, 0xd20a,\n\t    \"%s: reset risc [%lx]\\n\", __func__, *len);\n\tif (buf) {\n\t\tif (qla24xx_soft_reset(vha->hw) != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x5001,\n\t\t\t    \"%s: unable to soft reset\\n\", __func__);\n\t\t\treturn INVALID_ENTRY;\n\t\t}\n\t}\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t267(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tuint offset = ent->t267.pci_offset;\n\tulong data = le32_to_cpu(ent->t267.data);\n\n\tql_dbg(ql_dbg_misc, vha, 0xd20b,\n\t    \"%s: dis intr [%lx]\\n\", __func__, *len);\n\tqla27xx_write_reg(ISPREG(vha), offset, data, buf);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t268(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tql_dbg(ql_dbg_misc, vha, 0xd20c,\n\t    \"%s: gethb(%x) [%lx]\\n\", __func__, ent->t268.buf_type, *len);\n\tswitch (ent->t268.buf_type) {\n\tcase T268_BUF_TYPE_EXTD_TRACE:\n\t\tif (vha->hw->eft) {\n\t\t\tif (buf) {\n\t\t\t\tent->t268.buf_size = EFT_SIZE;\n\t\t\t\tent->t268.start_addr = vha->hw->eft_dma;\n\t\t\t}\n\t\t\tqla27xx_insertbuf(vha->hw->eft, EFT_SIZE, buf, len);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_misc, vha, 0xd028,\n\t\t\t    \"%s: missing eft\\n\", __func__);\n\t\t\tqla27xx_skip_entry(ent, buf);\n\t\t}\n\t\tbreak;\n\tcase T268_BUF_TYPE_EXCH_BUFOFF:\n\t\tif (vha->hw->exchoffld_buf) {\n\t\t\tif (buf) {\n\t\t\t\tent->t268.buf_size = vha->hw->exchoffld_size;\n\t\t\t\tent->t268.start_addr =\n\t\t\t\t\tvha->hw->exchoffld_buf_dma;\n\t\t\t}\n\t\t\tqla27xx_insertbuf(vha->hw->exchoffld_buf,\n\t\t\t    vha->hw->exchoffld_size, buf, len);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_misc, vha, 0xd028,\n\t\t\t    \"%s: missing exch offld\\n\", __func__);\n\t\t\tqla27xx_skip_entry(ent, buf);\n\t\t}\n\t\tbreak;\n\tcase T268_BUF_TYPE_EXTD_LOGIN:\n\t\tif (vha->hw->exlogin_buf) {\n\t\t\tif (buf) {\n\t\t\t\tent->t268.buf_size = vha->hw->exlogin_size;\n\t\t\t\tent->t268.start_addr =\n\t\t\t\t\tvha->hw->exlogin_buf_dma;\n\t\t\t}\n\t\t\tqla27xx_insertbuf(vha->hw->exlogin_buf,\n\t\t\t    vha->hw->exlogin_size, buf, len);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_misc, vha, 0xd028,\n\t\t\t    \"%s: missing ext login\\n\", __func__);\n\t\t\tqla27xx_skip_entry(ent, buf);\n\t\t}\n\t\tbreak;\n\n\tcase T268_BUF_TYPE_REQ_MIRROR:\n\tcase T268_BUF_TYPE_RSP_MIRROR:\n\t\t \n\t\tqla27xx_skip_entry(ent, buf);\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_async, vha, 0xd02b,\n\t\t    \"%s: unknown buffer %x\\n\", __func__, ent->t268.buf_type);\n\t\tqla27xx_skip_entry(ent, buf);\n\t\tbreak;\n\t}\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t269(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tql_dbg(ql_dbg_misc, vha, 0xd20d,\n\t    \"%s: scratch [%lx]\\n\", __func__, *len);\n\tqla27xx_insert32(0xaaaaaaaa, buf, len);\n\tqla27xx_insert32(0xbbbbbbbb, buf, len);\n\tqla27xx_insert32(0xcccccccc, buf, len);\n\tqla27xx_insert32(0xdddddddd, buf, len);\n\tqla27xx_insert32(*len + sizeof(uint32_t), buf, len);\n\tif (buf)\n\t\tent->t269.scratch_size = 5 * sizeof(uint32_t);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t270(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong addr = le32_to_cpu(ent->t270.addr);\n\tulong dwords = le32_to_cpu(ent->t270.count);\n\n\tql_dbg(ql_dbg_misc, vha, 0xd20e,\n\t    \"%s: rdremreg [%lx]\\n\", __func__, *len);\n\tqla27xx_write_reg(ISPREG(vha), IOBASE_ADDR, 0x40, buf);\n\twhile (dwords--) {\n\t\tqla27xx_write_reg(ISPREG(vha), 0xc0, addr|0x80000000, buf);\n\t\tqla27xx_insert32(addr, buf, len);\n\t\tqla27xx_read_reg(ISPREG(vha), 0xc4, buf, len);\n\t\taddr += sizeof(uint32_t);\n\t}\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t271(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong addr = le32_to_cpu(ent->t271.addr);\n\tulong data = le32_to_cpu(ent->t271.data);\n\n\tql_dbg(ql_dbg_misc, vha, 0xd20f,\n\t    \"%s: wrremreg [%lx]\\n\", __func__, *len);\n\tqla27xx_write_reg(ISPREG(vha), IOBASE(vha), 0x40, buf);\n\tqla27xx_write_reg(ISPREG(vha), 0xc4, data, buf);\n\tqla27xx_write_reg(ISPREG(vha), 0xc0, addr, buf);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t272(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong dwords = le32_to_cpu(ent->t272.count);\n\tulong start = le32_to_cpu(ent->t272.addr);\n\n\tql_dbg(ql_dbg_misc, vha, 0xd210,\n\t    \"%s: rdremram [%lx]\\n\", __func__, *len);\n\tif (buf) {\n\t\tql_dbg(ql_dbg_misc, vha, 0xd02c,\n\t\t    \"%s: @%lx -> (%lx dwords)\\n\", __func__, start, dwords);\n\t\tbuf += *len;\n\t\tqla27xx_dump_mpi_ram(vha->hw, start, buf, dwords, &buf);\n\t}\n\t*len += dwords * sizeof(uint32_t);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t273(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong dwords = le32_to_cpu(ent->t273.count);\n\tulong addr = le32_to_cpu(ent->t273.addr);\n\tuint32_t value;\n\n\tql_dbg(ql_dbg_misc, vha, 0xd211,\n\t    \"%s: pcicfg [%lx]\\n\", __func__, *len);\n\twhile (dwords--) {\n\t\tvalue = ~0;\n\t\tif (pci_read_config_dword(vha->hw->pdev, addr, &value))\n\t\t\tql_dbg(ql_dbg_misc, vha, 0xd02d,\n\t\t\t    \"%s: failed pcicfg read at %lx\\n\", __func__, addr);\n\t\tqla27xx_insert32(addr, buf, len);\n\t\tqla27xx_insert32(value, buf, len);\n\t\taddr += sizeof(uint32_t);\n\t}\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t274(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong type = ent->t274.queue_type;\n\tuint count = 0;\n\tuint i;\n\n\tql_dbg(ql_dbg_misc + ql_dbg_verbose, vha, 0xd212,\n\t    \"%s: getqsh(%lx) [%lx]\\n\", __func__, type, *len);\n\tif (type == T274_QUEUE_TYPE_REQ_SHAD) {\n\t\tfor (i = 0; i < vha->hw->max_req_queues; i++) {\n\t\t\tstruct req_que *req = vha->hw->req_q_map[i];\n\n\t\t\tif (req || !buf) {\n\t\t\t\tqla27xx_insert16(i, buf, len);\n\t\t\t\tqla27xx_insert16(1, buf, len);\n\t\t\t\tqla27xx_insert32(req && req->out_ptr ?\n\t\t\t\t    *req->out_ptr : 0, buf, len);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t} else if (type == T274_QUEUE_TYPE_RSP_SHAD) {\n\t\tfor (i = 0; i < vha->hw->max_rsp_queues; i++) {\n\t\t\tstruct rsp_que *rsp = vha->hw->rsp_q_map[i];\n\n\t\t\tif (rsp || !buf) {\n\t\t\t\tqla27xx_insert16(i, buf, len);\n\t\t\t\tqla27xx_insert16(1, buf, len);\n\t\t\t\tqla27xx_insert32(rsp && rsp->in_ptr ?\n\t\t\t\t    *rsp->in_ptr : 0, buf, len);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t} else if (QLA_TGT_MODE_ENABLED() &&\n\t    ent->t274.queue_type == T274_QUEUE_TYPE_ATIO_SHAD) {\n\t\tstruct qla_hw_data *ha = vha->hw;\n\t\tstruct atio *atr = ha->tgt.atio_ring_ptr;\n\n\t\tif (atr || !buf) {\n\t\t\tqla27xx_insert16(0, buf, len);\n\t\t\tqla27xx_insert16(1, buf, len);\n\t\t\tqla27xx_insert32(ha->tgt.atio_q_in ?\n\t\t\t    readl(ha->tgt.atio_q_in) : 0, buf, len);\n\t\t\tcount++;\n\t\t}\n\t} else {\n\t\tql_dbg(ql_dbg_misc, vha, 0xd02f,\n\t\t    \"%s: unknown queue %lx\\n\", __func__, type);\n\t\tqla27xx_skip_entry(ent, buf);\n\t}\n\n\tif (buf) {\n\t\tif (count)\n\t\t\tent->t274.num_queues = count;\n\t\telse\n\t\t\tqla27xx_skip_entry(ent, buf);\n\t}\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t275(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong offset = offsetof(typeof(*ent), t275.buffer);\n\tulong length = le32_to_cpu(ent->t275.length);\n\tulong size = le32_to_cpu(ent->hdr.size);\n\tvoid *buffer = ent->t275.buffer;\n\n\tql_dbg(ql_dbg_misc + ql_dbg_verbose, vha, 0xd213,\n\t    \"%s: buffer(%lx) [%lx]\\n\", __func__, length, *len);\n\tif (!length) {\n\t\tql_dbg(ql_dbg_misc, vha, 0xd020,\n\t\t    \"%s: buffer zero length\\n\", __func__);\n\t\tqla27xx_skip_entry(ent, buf);\n\t\tgoto done;\n\t}\n\tif (offset + length > size) {\n\t\tlength = size - offset;\n\t\tql_dbg(ql_dbg_misc, vha, 0xd030,\n\t\t    \"%s: buffer overflow, truncate [%lx]\\n\", __func__, length);\n\t\tent->t275.length = cpu_to_le32(length);\n\t}\n\n\tqla27xx_insertbuf(buffer, length, buf, len);\ndone:\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t276(struct scsi_qla_host *vha,\n    struct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tql_dbg(ql_dbg_misc + ql_dbg_verbose, vha, 0xd214,\n\t    \"%s: cond [%lx]\\n\", __func__, *len);\n\n\tif (buf) {\n\t\tulong cond1 = le32_to_cpu(ent->t276.cond1);\n\t\tulong cond2 = le32_to_cpu(ent->t276.cond2);\n\t\tuint type = vha->hw->pdev->device >> 4 & 0xf;\n\t\tuint func = vha->hw->port_no & 0x3;\n\n\t\tif (type != cond1 || func != cond2) {\n\t\t\tstruct qla27xx_fwdt_template *tmp = buf;\n\n\t\t\ttmp->count--;\n\t\t\tent = qla27xx_next_entry(ent);\n\t\t\tqla27xx_skip_entry(ent, buf);\n\t\t}\n\t}\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t277(struct scsi_qla_host *vha,\n    struct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong cmd_addr = le32_to_cpu(ent->t277.cmd_addr);\n\tulong wr_cmd_data = le32_to_cpu(ent->t277.wr_cmd_data);\n\tulong data_addr = le32_to_cpu(ent->t277.data_addr);\n\n\tql_dbg(ql_dbg_misc + ql_dbg_verbose, vha, 0xd215,\n\t    \"%s: rdpep [%lx]\\n\", __func__, *len);\n\tqla27xx_insert32(wr_cmd_data, buf, len);\n\tqla27xx_write_reg(ISPREG(vha), cmd_addr, wr_cmd_data, buf);\n\tqla27xx_read_reg(ISPREG(vha), data_addr, buf, len);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_t278(struct scsi_qla_host *vha,\n    struct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong cmd_addr = le32_to_cpu(ent->t278.cmd_addr);\n\tulong wr_cmd_data = le32_to_cpu(ent->t278.wr_cmd_data);\n\tulong data_addr = le32_to_cpu(ent->t278.data_addr);\n\tulong wr_data = le32_to_cpu(ent->t278.wr_data);\n\n\tql_dbg(ql_dbg_misc + ql_dbg_verbose, vha, 0xd216,\n\t    \"%s: wrpep [%lx]\\n\", __func__, *len);\n\tqla27xx_write_reg(ISPREG(vha), data_addr, wr_data, buf);\n\tqla27xx_write_reg(ISPREG(vha), cmd_addr, wr_cmd_data, buf);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct qla27xx_fwdt_entry *\nqla27xx_fwdt_entry_other(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_entry *ent, void *buf, ulong *len)\n{\n\tulong type = le32_to_cpu(ent->hdr.type);\n\n\tql_dbg(ql_dbg_misc, vha, 0xd2ff,\n\t    \"%s: other %lx [%lx]\\n\", __func__, type, *len);\n\tqla27xx_skip_entry(ent, buf);\n\n\treturn qla27xx_next_entry(ent);\n}\n\nstatic struct {\n\tuint type;\n\ttypeof(qla27xx_fwdt_entry_other)(*call);\n} qla27xx_fwdt_entry_call[] = {\n\t{ ENTRY_TYPE_NOP,\t\tqla27xx_fwdt_entry_t0    },\n\t{ ENTRY_TYPE_TMP_END,\t\tqla27xx_fwdt_entry_t255  },\n\t{ ENTRY_TYPE_RD_IOB_T1,\t\tqla27xx_fwdt_entry_t256  },\n\t{ ENTRY_TYPE_WR_IOB_T1,\t\tqla27xx_fwdt_entry_t257  },\n\t{ ENTRY_TYPE_RD_IOB_T2,\t\tqla27xx_fwdt_entry_t258  },\n\t{ ENTRY_TYPE_WR_IOB_T2,\t\tqla27xx_fwdt_entry_t259  },\n\t{ ENTRY_TYPE_RD_PCI,\t\tqla27xx_fwdt_entry_t260  },\n\t{ ENTRY_TYPE_WR_PCI,\t\tqla27xx_fwdt_entry_t261  },\n\t{ ENTRY_TYPE_RD_RAM,\t\tqla27xx_fwdt_entry_t262  },\n\t{ ENTRY_TYPE_GET_QUEUE,\t\tqla27xx_fwdt_entry_t263  },\n\t{ ENTRY_TYPE_GET_FCE,\t\tqla27xx_fwdt_entry_t264  },\n\t{ ENTRY_TYPE_PSE_RISC,\t\tqla27xx_fwdt_entry_t265  },\n\t{ ENTRY_TYPE_RST_RISC,\t\tqla27xx_fwdt_entry_t266  },\n\t{ ENTRY_TYPE_DIS_INTR,\t\tqla27xx_fwdt_entry_t267  },\n\t{ ENTRY_TYPE_GET_HBUF,\t\tqla27xx_fwdt_entry_t268  },\n\t{ ENTRY_TYPE_SCRATCH,\t\tqla27xx_fwdt_entry_t269  },\n\t{ ENTRY_TYPE_RDREMREG,\t\tqla27xx_fwdt_entry_t270  },\n\t{ ENTRY_TYPE_WRREMREG,\t\tqla27xx_fwdt_entry_t271  },\n\t{ ENTRY_TYPE_RDREMRAM,\t\tqla27xx_fwdt_entry_t272  },\n\t{ ENTRY_TYPE_PCICFG,\t\tqla27xx_fwdt_entry_t273  },\n\t{ ENTRY_TYPE_GET_SHADOW,\tqla27xx_fwdt_entry_t274  },\n\t{ ENTRY_TYPE_WRITE_BUF,\t\tqla27xx_fwdt_entry_t275  },\n\t{ ENTRY_TYPE_CONDITIONAL,\tqla27xx_fwdt_entry_t276  },\n\t{ ENTRY_TYPE_RDPEPREG,\t\tqla27xx_fwdt_entry_t277  },\n\t{ ENTRY_TYPE_WRPEPREG,\t\tqla27xx_fwdt_entry_t278  },\n\t{ -1,\t\t\t\tqla27xx_fwdt_entry_other }\n};\n\nstatic inline\ntypeof(qla27xx_fwdt_entry_call->call)(qla27xx_find_entry(uint type))\n{\n\ttypeof(*qla27xx_fwdt_entry_call) *list = qla27xx_fwdt_entry_call;\n\n\twhile (list->type < type)\n\t\tlist++;\n\n\tif (list->type == type)\n\t\treturn list->call;\n\treturn qla27xx_fwdt_entry_other;\n}\n\nstatic void\nqla27xx_walk_template(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_template *tmp, void *buf, ulong *len)\n{\n\tstruct qla27xx_fwdt_entry *ent = (void *)tmp +\n\t    le32_to_cpu(tmp->entry_offset);\n\tulong type;\n\n\ttmp->count = le32_to_cpu(tmp->entry_count);\n\tql_dbg(ql_dbg_misc, vha, 0xd01a,\n\t    \"%s: entry count %u\\n\", __func__, tmp->count);\n\twhile (ent && tmp->count--) {\n\t\ttype = le32_to_cpu(ent->hdr.type);\n\t\tent = qla27xx_find_entry(type)(vha, ent, buf, len);\n\t\tif (!ent)\n\t\t\tbreak;\n\n\t\tif (ent == INVALID_ENTRY) {\n\t\t\t*len = 0;\n\t\t\tql_dbg(ql_dbg_async, vha, 0xffff,\n\t\t\t    \"Unable to capture FW dump\");\n\t\t\tgoto bailout;\n\t\t}\n\t}\n\n\tif (tmp->count)\n\t\tql_dbg(ql_dbg_misc, vha, 0xd018,\n\t\t    \"%s: entry count residual=+%u\\n\", __func__, tmp->count);\n\n\tif (ent)\n\t\tql_dbg(ql_dbg_misc, vha, 0xd019,\n\t\t    \"%s: missing end entry\\n\", __func__);\n\nbailout:\n\tcpu_to_le32s(&tmp->count);\t \n}\n\nstatic void\nqla27xx_time_stamp(struct qla27xx_fwdt_template *tmp)\n{\n\ttmp->capture_timestamp = cpu_to_le32(jiffies);\n}\n\nstatic void\nqla27xx_driver_info(struct qla27xx_fwdt_template *tmp)\n{\n\tuint8_t v[] = { 0, 0, 0, 0, 0, 0 };\n\n\tWARN_ON_ONCE(sscanf(qla2x00_version_str,\n\t\t\t    \"%hhu.%hhu.%hhu.%hhu\",\n\t\t\t    v + 0, v + 1, v + 2, v + 3) != 4);\n\n\ttmp->driver_info[0] = cpu_to_le32(\n\t\tv[3] << 24 | v[2] << 16 | v[1] << 8 | v[0]);\n\ttmp->driver_info[1] = cpu_to_le32(v[5] << 8 | v[4]);\n\ttmp->driver_info[2] = __constant_cpu_to_le32(0x12345678);\n}\n\nstatic void\nqla27xx_firmware_info(struct scsi_qla_host *vha,\n    struct qla27xx_fwdt_template *tmp)\n{\n\ttmp->firmware_version[0] = cpu_to_le32(vha->hw->fw_major_version);\n\ttmp->firmware_version[1] = cpu_to_le32(vha->hw->fw_minor_version);\n\ttmp->firmware_version[2] = cpu_to_le32(vha->hw->fw_subminor_version);\n\ttmp->firmware_version[3] = cpu_to_le32(\n\t\tvha->hw->fw_attributes_h << 16 | vha->hw->fw_attributes);\n\ttmp->firmware_version[4] = cpu_to_le32(\n\t  vha->hw->fw_attributes_ext[1] << 16 | vha->hw->fw_attributes_ext[0]);\n}\n\nstatic void\nql27xx_edit_template(struct scsi_qla_host *vha,\n\tstruct qla27xx_fwdt_template *tmp)\n{\n\tqla27xx_time_stamp(tmp);\n\tqla27xx_driver_info(tmp);\n\tqla27xx_firmware_info(vha, tmp);\n}\n\nstatic inline uint32_t\nqla27xx_template_checksum(void *p, ulong size)\n{\n\t__le32 *buf = p;\n\tuint64_t sum = 0;\n\n\tsize /= sizeof(*buf);\n\n\tfor ( ; size--; buf++)\n\t\tsum += le32_to_cpu(*buf);\n\n\tsum = (sum & 0xffffffff) + (sum >> 32);\n\n\treturn ~sum;\n}\n\nstatic inline int\nqla27xx_verify_template_checksum(struct qla27xx_fwdt_template *tmp)\n{\n\treturn qla27xx_template_checksum(tmp,\n\t\tle32_to_cpu(tmp->template_size)) == 0;\n}\n\nstatic inline int\nqla27xx_verify_template_header(struct qla27xx_fwdt_template *tmp)\n{\n\treturn le32_to_cpu(tmp->template_type) == TEMPLATE_TYPE_FWDUMP;\n}\n\nstatic ulong\nqla27xx_execute_fwdt_template(struct scsi_qla_host *vha,\n    struct qla27xx_fwdt_template *tmp, void *buf)\n{\n\tulong len = 0;\n\n\tif (qla27xx_fwdt_template_valid(tmp)) {\n\t\tlen = le32_to_cpu(tmp->template_size);\n\t\ttmp = memcpy(buf, tmp, len);\n\t\tql27xx_edit_template(vha, tmp);\n\t\tqla27xx_walk_template(vha, tmp, buf, &len);\n\t}\n\n\treturn len;\n}\n\nulong\nqla27xx_fwdt_calculate_dump_size(struct scsi_qla_host *vha, void *p)\n{\n\tstruct qla27xx_fwdt_template *tmp = p;\n\tulong len = 0;\n\n\tif (qla27xx_fwdt_template_valid(tmp)) {\n\t\tlen = le32_to_cpu(tmp->template_size);\n\t\tqla27xx_walk_template(vha, tmp, NULL, &len);\n\t}\n\n\treturn len;\n}\n\nulong\nqla27xx_fwdt_template_size(void *p)\n{\n\tstruct qla27xx_fwdt_template *tmp = p;\n\n\treturn le32_to_cpu(tmp->template_size);\n}\n\nint\nqla27xx_fwdt_template_valid(void *p)\n{\n\tstruct qla27xx_fwdt_template *tmp = p;\n\n\tif (!qla27xx_verify_template_header(tmp)) {\n\t\tql_log(ql_log_warn, NULL, 0xd01c,\n\t\t    \"%s: template type %x\\n\", __func__,\n\t\t    le32_to_cpu(tmp->template_type));\n\t\treturn false;\n\t}\n\n\tif (!qla27xx_verify_template_checksum(tmp)) {\n\t\tql_log(ql_log_warn, NULL, 0xd01d,\n\t\t    \"%s: failed template checksum\\n\", __func__);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid\nqla27xx_mpi_fwdump(scsi_qla_host_t *vha, int hardware_locked)\n{\n\tulong flags = 0;\n\n\tif (!hardware_locked)\n\t\tspin_lock_irqsave(&vha->hw->hardware_lock, flags);\n\tif (!vha->hw->mpi_fw_dump) {\n\t\tql_log(ql_log_warn, vha, 0x02f3, \"-> mpi_fwdump no buffer\\n\");\n\t} else {\n\t\tstruct fwdt *fwdt = &vha->hw->fwdt[1];\n\t\tulong len;\n\t\tvoid *buf = vha->hw->mpi_fw_dump;\n\t\tbool walk_template_only = false;\n\n\t\tif (vha->hw->mpi_fw_dumped) {\n\t\t\t \n\t\t\tbuf += fwdt->dump_size;\n\t\t\twalk_template_only = true;\n\t\t\tql_log(ql_log_warn, vha, 0x02f4,\n\t\t\t       \"-> MPI firmware already dumped -- dump saving to temporary buffer %p.\\n\",\n\t\t\t       buf);\n\t\t}\n\n\t\tql_log(ql_log_warn, vha, 0x02f5, \"-> fwdt1 running...\\n\");\n\t\tif (!fwdt->template) {\n\t\t\tql_log(ql_log_warn, vha, 0x02f6,\n\t\t\t       \"-> fwdt1 no template\\n\");\n\t\t\tgoto bailout;\n\t\t}\n\t\tlen = qla27xx_execute_fwdt_template(vha, fwdt->template, buf);\n\t\tif (len == 0) {\n\t\t\tgoto bailout;\n\t\t} else if (len != fwdt->dump_size) {\n\t\t\tql_log(ql_log_warn, vha, 0x02f7,\n\t\t\t       \"-> fwdt1 fwdump residual=%+ld\\n\",\n\t\t\t       fwdt->dump_size - len);\n\t\t}\n\t\tvha->hw->stat.num_mpi_reset++;\n\t\tif (walk_template_only)\n\t\t\tgoto bailout;\n\n\t\tvha->hw->mpi_fw_dump_len = len;\n\t\tvha->hw->mpi_fw_dumped = 1;\n\n\t\tql_log(ql_log_warn, vha, 0x02f8,\n\t\t       \"-> MPI firmware dump saved to buffer (%lu/%p)\\n\",\n\t\t       vha->host_no, vha->hw->mpi_fw_dump);\n\t\tqla2x00_post_uevent_work(vha, QLA_UEVENT_CODE_FW_DUMP);\n\t}\n\nbailout:\n\tif (!hardware_locked)\n\t\tspin_unlock_irqrestore(&vha->hw->hardware_lock, flags);\n}\n\nvoid\nqla27xx_fwdump(scsi_qla_host_t *vha)\n{\n\tlockdep_assert_held(&vha->hw->hardware_lock);\n\n\tif (!vha->hw->fw_dump) {\n\t\tql_log(ql_log_warn, vha, 0xd01e, \"-> fwdump no buffer\\n\");\n\t} else if (vha->hw->fw_dumped) {\n\t\tql_log(ql_log_warn, vha, 0xd01f,\n\t\t    \"-> Firmware already dumped (%p) -- ignoring request\\n\",\n\t\t    vha->hw->fw_dump);\n\t} else {\n\t\tstruct fwdt *fwdt = vha->hw->fwdt;\n\t\tulong len;\n\t\tvoid *buf = vha->hw->fw_dump;\n\n\t\tql_log(ql_log_warn, vha, 0xd011, \"-> fwdt0 running...\\n\");\n\t\tif (!fwdt->template) {\n\t\t\tql_log(ql_log_warn, vha, 0xd012,\n\t\t\t       \"-> fwdt0 no template\\n\");\n\t\t\treturn;\n\t\t}\n\t\tlen = qla27xx_execute_fwdt_template(vha, fwdt->template, buf);\n\t\tif (len == 0) {\n\t\t\treturn;\n\t\t} else if (len != fwdt->dump_size) {\n\t\t\tql_log(ql_log_warn, vha, 0xd013,\n\t\t\t       \"-> fwdt0 fwdump residual=%+ld\\n\",\n\t\t\t\tfwdt->dump_size - len);\n\t\t}\n\n\t\tvha->hw->fw_dump_len = len;\n\t\tvha->hw->fw_dumped = true;\n\n\t\tql_log(ql_log_warn, vha, 0xd015,\n\t\t    \"-> Firmware dump saved to buffer (%lu/%p) <%lx>\\n\",\n\t\t    vha->host_no, vha->hw->fw_dump, vha->hw->fw_dump_cap_flags);\n\t\tqla2x00_post_uevent_work(vha, QLA_UEVENT_CODE_FW_DUMP);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}