{
  "module_name": "qla_bsg.c",
  "hash_id": "7b0091df571210603e77c977c8e9e076bea2f3cdb95adba0cb8f5918ceb440d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_bsg.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_gbl.h\"\n\n#include <linux/kthread.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/bsg-lib.h>\n\nstatic void qla2xxx_free_fcport_work(struct work_struct *work)\n{\n\tstruct fc_port *fcport = container_of(work, typeof(*fcport),\n\t    free_work);\n\n\tqla2x00_free_fcport(fcport);\n}\n\n \nvoid qla2x00_bsg_job_done(srb_t *sp, int res)\n{\n\tstruct bsg_job *bsg_job = sp->u.bsg_job;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\n\tql_dbg(ql_dbg_user, sp->vha, 0x7009,\n\t    \"%s: sp hdl %x, result=%x bsg ptr %p\\n\",\n\t    __func__, sp->handle, res, bsg_job);\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\n\tbsg_reply->result = res;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n}\n\nvoid qla2x00_bsg_sp_free(srb_t *sp)\n{\n\tstruct qla_hw_data *ha = sp->vha->hw;\n\tstruct bsg_job *bsg_job = sp->u.bsg_job;\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct qla_mt_iocb_rqst_fx00 *piocb_rqst;\n\n\tif (sp->type == SRB_FXIOCB_BCMD) {\n\t\tpiocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)\n\t\t    &bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\n\t\tif (piocb_rqst->flags & SRB_FXDISC_REQ_DMA_VALID)\n\t\t\tdma_unmap_sg(&ha->pdev->dev,\n\t\t\t    bsg_job->request_payload.sg_list,\n\t\t\t    bsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\n\t\tif (piocb_rqst->flags & SRB_FXDISC_RESP_DMA_VALID)\n\t\t\tdma_unmap_sg(&ha->pdev->dev,\n\t\t\t    bsg_job->reply_payload.sg_list,\n\t\t\t    bsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\t} else {\n\n\t\tif (sp->remap.remapped) {\n\t\t\tdma_pool_free(ha->purex_dma_pool, sp->remap.rsp.buf,\n\t\t\t    sp->remap.rsp.dma);\n\t\t\tdma_pool_free(ha->purex_dma_pool, sp->remap.req.buf,\n\t\t\t    sp->remap.req.dma);\n\t\t} else {\n\t\t\tdma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\t\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\n\t\t\tdma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\n\t\t\t\tbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\t\t}\n\t}\n\n\tif (sp->type == SRB_CT_CMD ||\n\t    sp->type == SRB_FXIOCB_BCMD ||\n\t    sp->type == SRB_ELS_CMD_HST) {\n\t\tINIT_WORK(&sp->fcport->free_work, qla2xxx_free_fcport_work);\n\t\tqueue_work(ha->wq, &sp->fcport->free_work);\n\t}\n\n\tqla2x00_rel_sp(sp);\n}\n\nint\nqla24xx_fcp_prio_cfg_valid(scsi_qla_host_t *vha,\n\tstruct qla_fcp_prio_cfg *pri_cfg, uint8_t flag)\n{\n\tint i, ret, num_valid;\n\tuint8_t *bcode;\n\tstruct qla_fcp_prio_entry *pri_entry;\n\tuint32_t *bcode_val_ptr, bcode_val;\n\n\tret = 1;\n\tnum_valid = 0;\n\tbcode = (uint8_t *)pri_cfg;\n\tbcode_val_ptr = (uint32_t *)pri_cfg;\n\tbcode_val = (uint32_t)(*bcode_val_ptr);\n\n\tif (bcode_val == 0xFFFFFFFF) {\n\t\t \n\t\tql_dbg(ql_dbg_user, vha, 0x7051,\n\t\t    \"No FCP Priority config data.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (memcmp(bcode, \"HQOS\", 4)) {\n\t\t \n\t\tql_dbg(ql_dbg_user, vha, 0x7052,\n\t\t    \"Invalid FCP Priority data header. bcode=0x%x.\\n\",\n\t\t    bcode_val);\n\t\treturn 0;\n\t}\n\tif (flag != 1)\n\t\treturn ret;\n\n\tpri_entry = &pri_cfg->entry[0];\n\tfor (i = 0; i < pri_cfg->num_entries; i++) {\n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_TAG_VALID)\n\t\t\tnum_valid++;\n\t\tpri_entry++;\n\t}\n\n\tif (num_valid == 0) {\n\t\t \n\t\tql_dbg(ql_dbg_user, vha, 0x7053,\n\t\t    \"No valid FCP Priority data entries.\\n\");\n\t\tret = 0;\n\t} else {\n\t\t \n\t\tql_dbg(ql_dbg_user, vha, 0x7054,\n\t\t    \"Valid FCP priority data. num entries = %d.\\n\",\n\t\t    num_valid);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nqla24xx_proc_fcp_prio_cfg_cmd(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint ret = 0;\n\tuint32_t len;\n\tuint32_t oper;\n\n\tif (!(IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha) || IS_P3P_TYPE(ha))) {\n\t\tret = -EINVAL;\n\t\tgoto exit_fcp_prio_cfg;\n\t}\n\n\t \n\toper = bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\n\t \n\tif (!ha->fcp_prio_cfg && (oper != QLFC_FCP_PRIO_SET_CONFIG)) {\n\t\tret = -EINVAL;\n\t\tgoto exit_fcp_prio_cfg;\n\t}\n\tswitch (oper) {\n\tcase QLFC_FCP_PRIO_DISABLE:\n\t\tif (ha->flags.fcp_prio_enabled) {\n\t\t\tha->flags.fcp_prio_enabled = 0;\n\t\t\tha->fcp_prio_cfg->attributes &=\n\t\t\t\t~FCP_PRIO_ATTR_ENABLE;\n\t\t\tqla24xx_update_all_fcp_prio(vha);\n\t\t\tbsg_reply->result = DID_OK;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbsg_reply->result = (DID_ERROR << 16);\n\t\t\tgoto exit_fcp_prio_cfg;\n\t\t}\n\t\tbreak;\n\n\tcase QLFC_FCP_PRIO_ENABLE:\n\t\tif (!ha->flags.fcp_prio_enabled) {\n\t\t\tif (ha->fcp_prio_cfg) {\n\t\t\t\tha->flags.fcp_prio_enabled = 1;\n\t\t\t\tha->fcp_prio_cfg->attributes |=\n\t\t\t\t    FCP_PRIO_ATTR_ENABLE;\n\t\t\t\tqla24xx_update_all_fcp_prio(vha);\n\t\t\t\tbsg_reply->result = DID_OK;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbsg_reply->result = (DID_ERROR << 16);\n\t\t\t\tgoto exit_fcp_prio_cfg;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase QLFC_FCP_PRIO_GET_CONFIG:\n\t\tlen = bsg_job->reply_payload.payload_len;\n\t\tif (!len || len > FCP_PRIO_CFG_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tbsg_reply->result = (DID_ERROR << 16);\n\t\t\tgoto exit_fcp_prio_cfg;\n\t\t}\n\n\t\tbsg_reply->result = DID_OK;\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(\n\t\t\tbsg_job->reply_payload.sg_list,\n\t\t\tbsg_job->reply_payload.sg_cnt, ha->fcp_prio_cfg,\n\t\t\tlen);\n\n\t\tbreak;\n\n\tcase QLFC_FCP_PRIO_SET_CONFIG:\n\t\tlen = bsg_job->request_payload.payload_len;\n\t\tif (!len || len > FCP_PRIO_CFG_SIZE) {\n\t\t\tbsg_reply->result = (DID_ERROR << 16);\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit_fcp_prio_cfg;\n\t\t}\n\n\t\tif (!ha->fcp_prio_cfg) {\n\t\t\tha->fcp_prio_cfg = vmalloc(FCP_PRIO_CFG_SIZE);\n\t\t\tif (!ha->fcp_prio_cfg) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x7050,\n\t\t\t\t    \"Unable to allocate memory for fcp prio \"\n\t\t\t\t    \"config data (%x).\\n\", FCP_PRIO_CFG_SIZE);\n\t\t\t\tbsg_reply->result = (DID_ERROR << 16);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit_fcp_prio_cfg;\n\t\t\t}\n\t\t}\n\n\t\tmemset(ha->fcp_prio_cfg, 0, FCP_PRIO_CFG_SIZE);\n\t\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt, ha->fcp_prio_cfg,\n\t\t\tFCP_PRIO_CFG_SIZE);\n\n\t\t \n\n\t\tif (!qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 1)) {\n\t\t\tbsg_reply->result = (DID_ERROR << 16);\n\t\t\tret = -EINVAL;\n\t\t\t \n\t\t\tvfree(ha->fcp_prio_cfg);\n\t\t\tha->fcp_prio_cfg = NULL;\n\t\t\tgoto exit_fcp_prio_cfg;\n\t\t}\n\n\t\tha->flags.fcp_prio_enabled = 0;\n\t\tif (ha->fcp_prio_cfg->attributes & FCP_PRIO_ATTR_ENABLE)\n\t\t\tha->flags.fcp_prio_enabled = 1;\n\t\tqla24xx_update_all_fcp_prio(vha);\n\t\tbsg_reply->result = DID_OK;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nexit_fcp_prio_cfg:\n\tif (!ret)\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn ret;\n}\n\nstatic int\nqla2x00_process_els(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_rport *rport;\n\tfc_port_t *fcport = NULL;\n\tstruct Scsi_Host *host;\n\tscsi_qla_host_t *vha;\n\tstruct qla_hw_data *ha;\n\tsrb_t *sp;\n\tconst char *type;\n\tint req_sg_cnt, rsp_sg_cnt;\n\tint rval =  (DID_ERROR << 16);\n\tuint32_t els_cmd = 0;\n\tint qla_port_allocated = 0;\n\n\tif (bsg_request->msgcode == FC_BSG_RPT_ELS) {\n\t\trport = fc_bsg_to_rport(bsg_job);\n\t\tif (!rport) {\n\t\t\trval = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tfcport = *(fc_port_t **) rport->dd_data;\n\t\thost = rport_to_shost(rport);\n\t\tvha = shost_priv(host);\n\t\tha = vha->hw;\n\t\ttype = \"FC_BSG_RPT_ELS\";\n\t} else {\n\t\thost = fc_bsg_to_shost(bsg_job);\n\t\tvha = shost_priv(host);\n\t\tha = vha->hw;\n\t\ttype = \"FC_BSG_HST_ELS_NOLOGIN\";\n\t\tels_cmd = bsg_request->rqst_data.h_els.command_code;\n\t\tif (els_cmd == ELS_AUTH_ELS)\n\t\t\treturn qla_edif_process_els(vha, bsg_job);\n\t}\n\n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x7005, \"Host not online.\\n\");\n\t\trval = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!IS_FWI2_CAPABLE(ha)) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7001,\n\t\t    \"ELS passthru not supported for ISP23xx based adapters.\\n\");\n\t\trval = -EPERM;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bsg_job->request_payload.sg_cnt > 1 ||\n\t\tbsg_job->reply_payload.sg_cnt > 1) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7002,\n\t\t    \"Multiple SG's are not supported for ELS requests, \"\n\t\t    \"request_sg_cnt=%x reply_sg_cnt=%x.\\n\",\n\t\t    bsg_job->request_payload.sg_cnt,\n\t\t    bsg_job->reply_payload.sg_cnt);\n\t\trval = -EPERM;\n\t\tgoto done;\n\t}\n\n\t \n\tif (bsg_request->msgcode == FC_BSG_RPT_ELS) {\n\t\t \n\t\tif (atomic_read(&fcport->state) != FCS_ONLINE) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x7003,\n\t\t\t    \"Port %06X is not online for ELS passthru.\\n\",\n\t\t\t    fcport->d_id.b24);\n\t\t\trval = -EIO;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\t \n\t\tfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\t\tif (!fcport) {\n\t\t\trval = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\n\t\tqla_port_allocated = 1;\n\t\t \n\t\tfcport->vha = vha;\n\t\tfcport->d_id.b.al_pa =\n\t\t\tbsg_request->rqst_data.h_els.port_id[0];\n\t\tfcport->d_id.b.area =\n\t\t\tbsg_request->rqst_data.h_els.port_id[1];\n\t\tfcport->d_id.b.domain =\n\t\t\tbsg_request->rqst_data.h_els.port_id[2];\n\t\tfcport->loop_id =\n\t\t\t(fcport->d_id.b.al_pa == 0xFD) ?\n\t\t\tNPH_FABRIC_CONTROLLER : NPH_F_PORT;\n\t}\n\n\treq_sg_cnt =\n\t\tdma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\tif (!req_sg_cnt) {\n\t\tdma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\t    bsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\t\trval = -ENOMEM;\n\t\tgoto done_free_fcport;\n\t}\n\n\trsp_sg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\n\t\tbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n        if (!rsp_sg_cnt) {\n\t\tdma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\n\t\t    bsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\t\trval = -ENOMEM;\n\t\tgoto done_free_fcport;\n\t}\n\n\tif ((req_sg_cnt !=  bsg_job->request_payload.sg_cnt) ||\n\t\t(rsp_sg_cnt != bsg_job->reply_payload.sg_cnt)) {\n\t\tql_log(ql_log_warn, vha, 0x7008,\n\t\t    \"dma mapping resulted in different sg counts, \"\n\t\t    \"request_sg_cnt: %x dma_request_sg_cnt:%x reply_sg_cnt:%x \"\n\t\t    \"dma_reply_sg_cnt:%x.\\n\", bsg_job->request_payload.sg_cnt,\n\t\t    req_sg_cnt, bsg_job->reply_payload.sg_cnt, rsp_sg_cnt);\n\t\trval = -EAGAIN;\n\t\tgoto done_unmap_sg;\n\t}\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp) {\n\t\trval = -ENOMEM;\n\t\tgoto done_unmap_sg;\n\t}\n\n\tsp->type =\n\t\t(bsg_request->msgcode == FC_BSG_RPT_ELS ?\n\t\t SRB_ELS_CMD_RPT : SRB_ELS_CMD_HST);\n\tsp->name =\n\t\t(bsg_request->msgcode == FC_BSG_RPT_ELS ?\n\t\t \"bsg_els_rpt\" : \"bsg_els_hst\");\n\tsp->u.bsg_job = bsg_job;\n\tsp->free = qla2x00_bsg_sp_free;\n\tsp->done = qla2x00_bsg_job_done;\n\n\tql_dbg(ql_dbg_user, vha, 0x700a,\n\t    \"bsg rqst type: %s els type: %x - loop-id=%x \"\n\t    \"portid=%-2x%02x%02x.\\n\", type,\n\t    bsg_request->rqst_data.h_els.command_code, fcport->loop_id,\n\t    fcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x700e,\n\t\t    \"qla2x00_start_sp failed = %d\\n\", rval);\n\t\tqla2x00_rel_sp(sp);\n\t\trval = -EIO;\n\t\tgoto done_unmap_sg;\n\t}\n\treturn rval;\n\ndone_unmap_sg:\n\tdma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\tdma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\n\t\tbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\tgoto done_free_fcport;\n\ndone_free_fcport:\n\tif (qla_port_allocated)\n\t\tqla2x00_free_fcport(fcport);\ndone:\n\treturn rval;\n}\n\nstatic inline uint16_t\nqla24xx_calc_ct_iocbs(uint16_t dsds)\n{\n\tuint16_t iocbs;\n\n\tiocbs = 1;\n\tif (dsds > 2) {\n\t\tiocbs += (dsds - 2) / 5;\n\t\tif ((dsds - 2) % 5)\n\t\t\tiocbs++;\n\t}\n\treturn iocbs;\n}\n\nstatic int\nqla2x00_process_ct(struct bsg_job *bsg_job)\n{\n\tsrb_t *sp;\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = (DID_ERROR << 16);\n\tint req_sg_cnt, rsp_sg_cnt;\n\tuint16_t loop_id;\n\tstruct fc_port *fcport;\n\tchar  *type = \"FC_BSG_HST_CT\";\n\n\treq_sg_cnt =\n\t\tdma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\tif (!req_sg_cnt) {\n\t\tql_log(ql_log_warn, vha, 0x700f,\n\t\t    \"dma_map_sg return %d for request\\n\", req_sg_cnt);\n\t\trval = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\trsp_sg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\n\t\tbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\tif (!rsp_sg_cnt) {\n\t\tql_log(ql_log_warn, vha, 0x7010,\n\t\t    \"dma_map_sg return %d for reply\\n\", rsp_sg_cnt);\n\t\trval = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tif ((req_sg_cnt !=  bsg_job->request_payload.sg_cnt) ||\n\t    (rsp_sg_cnt != bsg_job->reply_payload.sg_cnt)) {\n\t\tql_log(ql_log_warn, vha, 0x7011,\n\t\t    \"request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt:%x \"\n\t\t    \"dma_reply_sg_cnt: %x\\n\", bsg_job->request_payload.sg_cnt,\n\t\t    req_sg_cnt, bsg_job->reply_payload.sg_cnt, rsp_sg_cnt);\n\t\trval = -EAGAIN;\n\t\tgoto done_unmap_sg;\n\t}\n\n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x7012,\n\t\t    \"Host is not online.\\n\");\n\t\trval = -EIO;\n\t\tgoto done_unmap_sg;\n\t}\n\n\tloop_id =\n\t\t(bsg_request->rqst_data.h_ct.preamble_word1 & 0xFF000000)\n\t\t\t>> 24;\n\tswitch (loop_id) {\n\tcase 0xFC:\n\t\tloop_id = NPH_SNS;\n\t\tbreak;\n\tcase 0xFA:\n\t\tloop_id = vha->mgmt_svr_loop_id;\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_user, vha, 0x7013,\n\t\t    \"Unknown loop id: %x.\\n\", loop_id);\n\t\trval = -EINVAL;\n\t\tgoto done_unmap_sg;\n\t}\n\n\t \n\tfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (!fcport) {\n\t\tql_log(ql_log_warn, vha, 0x7014,\n\t\t    \"Failed to allocate fcport.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done_unmap_sg;\n\t}\n\n\t \n\tfcport->vha = vha;\n\tfcport->d_id.b.al_pa = bsg_request->rqst_data.h_ct.port_id[0];\n\tfcport->d_id.b.area = bsg_request->rqst_data.h_ct.port_id[1];\n\tfcport->d_id.b.domain = bsg_request->rqst_data.h_ct.port_id[2];\n\tfcport->loop_id = loop_id;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp) {\n\t\tql_log(ql_log_warn, vha, 0x7015,\n\t\t    \"qla2x00_get_sp failed.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done_free_fcport;\n\t}\n\n\tsp->type = SRB_CT_CMD;\n\tsp->name = \"bsg_ct\";\n\tsp->iocbs = qla24xx_calc_ct_iocbs(req_sg_cnt + rsp_sg_cnt);\n\tsp->u.bsg_job = bsg_job;\n\tsp->free = qla2x00_bsg_sp_free;\n\tsp->done = qla2x00_bsg_job_done;\n\n\tql_dbg(ql_dbg_user, vha, 0x7016,\n\t    \"bsg rqst type: %s else type: %x - \"\n\t    \"loop-id=%x portid=%02x%02x%02x.\\n\", type,\n\t    (bsg_request->rqst_data.h_ct.preamble_word2 >> 16),\n\t    fcport->loop_id, fcport->d_id.b.domain, fcport->d_id.b.area,\n\t    fcport->d_id.b.al_pa);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x7017,\n\t\t    \"qla2x00_start_sp failed=%d.\\n\", rval);\n\t\tqla2x00_rel_sp(sp);\n\t\trval = -EIO;\n\t\tgoto done_free_fcport;\n\t}\n\treturn rval;\n\ndone_free_fcport:\n\tqla2x00_free_fcport(fcport);\ndone_unmap_sg:\n\tdma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\tdma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\n\t\tbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\ndone:\n\treturn rval;\n}\n\n \nstatic inline int\nqla81xx_reset_loopback_mode(scsi_qla_host_t *vha, uint16_t *config,\n\t\t\t    int wait, int wait2)\n{\n\tint ret = 0;\n\tint rval = 0;\n\tuint16_t new_config[4];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA8031(ha) && !IS_QLA8044(ha))\n\t\tgoto done_reset_internal;\n\n\tmemset(new_config, 0 , sizeof(new_config));\n\tif ((config[0] & INTERNAL_LOOPBACK_MASK) >> 1 ==\n\t    ENABLE_INTERNAL_LOOPBACK ||\n\t    (config[0] & INTERNAL_LOOPBACK_MASK) >> 1 ==\n\t    ENABLE_EXTERNAL_LOOPBACK) {\n\t\tnew_config[0] = config[0] & ~INTERNAL_LOOPBACK_MASK;\n\t\tql_dbg(ql_dbg_user, vha, 0x70bf, \"new_config[0]=%02x\\n\",\n\t\t    (new_config[0] & INTERNAL_LOOPBACK_MASK));\n\t\tmemcpy(&new_config[1], &config[1], sizeof(uint16_t) * 3) ;\n\n\t\tha->notify_dcbx_comp = wait;\n\t\tha->notify_lb_portup_comp = wait2;\n\n\t\tret = qla81xx_set_port_config(vha, new_config);\n\t\tif (ret != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x7025,\n\t\t\t    \"Set port config failed.\\n\");\n\t\t\tha->notify_dcbx_comp = 0;\n\t\t\tha->notify_lb_portup_comp = 0;\n\t\t\trval = -EINVAL;\n\t\t\tgoto done_reset_internal;\n\t\t}\n\n\t\t \n\t\tif (wait && !wait_for_completion_timeout(&ha->dcbx_comp,\n\t\t\t(DCBX_COMP_TIMEOUT * HZ))) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x7026,\n\t\t\t    \"DCBX completion not received.\\n\");\n\t\t\tha->notify_dcbx_comp = 0;\n\t\t\tha->notify_lb_portup_comp = 0;\n\t\t\trval = -EINVAL;\n\t\t\tgoto done_reset_internal;\n\t\t} else\n\t\t\tql_dbg(ql_dbg_user, vha, 0x7027,\n\t\t\t    \"DCBX completion received.\\n\");\n\n\t\tif (wait2 &&\n\t\t    !wait_for_completion_timeout(&ha->lb_portup_comp,\n\t\t    (LB_PORTUP_COMP_TIMEOUT * HZ))) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x70c5,\n\t\t\t    \"Port up completion not received.\\n\");\n\t\t\tha->notify_lb_portup_comp = 0;\n\t\t\trval = -EINVAL;\n\t\t\tgoto done_reset_internal;\n\t\t} else\n\t\t\tql_dbg(ql_dbg_user, vha, 0x70c6,\n\t\t\t    \"Port up completion received.\\n\");\n\n\t\tha->notify_dcbx_comp = 0;\n\t\tha->notify_lb_portup_comp = 0;\n\t}\ndone_reset_internal:\n\treturn rval;\n}\n\n \nstatic inline int\nqla81xx_set_loopback_mode(scsi_qla_host_t *vha, uint16_t *config,\n\tuint16_t *new_config, uint16_t mode)\n{\n\tint ret = 0;\n\tint rval = 0;\n\tunsigned long rem_tmo = 0, current_tmo = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA8031(ha) && !IS_QLA8044(ha))\n\t\tgoto done_set_internal;\n\n\tif (mode == INTERNAL_LOOPBACK)\n\t\tnew_config[0] = config[0] | (ENABLE_INTERNAL_LOOPBACK << 1);\n\telse if (mode == EXTERNAL_LOOPBACK)\n\t\tnew_config[0] = config[0] | (ENABLE_EXTERNAL_LOOPBACK << 1);\n\tql_dbg(ql_dbg_user, vha, 0x70be,\n\t     \"new_config[0]=%02x\\n\", (new_config[0] & INTERNAL_LOOPBACK_MASK));\n\n\tmemcpy(&new_config[1], &config[1], sizeof(uint16_t) * 3);\n\n\tha->notify_dcbx_comp = 1;\n\tret = qla81xx_set_port_config(vha, new_config);\n\tif (ret != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x7021,\n\t\t    \"set port config failed.\\n\");\n\t\tha->notify_dcbx_comp = 0;\n\t\trval = -EINVAL;\n\t\tgoto done_set_internal;\n\t}\n\n\t \n\tcurrent_tmo = DCBX_COMP_TIMEOUT * HZ;\n\twhile (1) {\n\t\trem_tmo = wait_for_completion_timeout(&ha->dcbx_comp,\n\t\t    current_tmo);\n\t\tif (!ha->idc_extend_tmo || rem_tmo) {\n\t\t\tha->idc_extend_tmo = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcurrent_tmo = ha->idc_extend_tmo * HZ;\n\t\tha->idc_extend_tmo = 0;\n\t}\n\n\tif (!rem_tmo) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7022,\n\t\t    \"DCBX completion not received.\\n\");\n\t\tret = qla81xx_reset_loopback_mode(vha, new_config, 0, 0);\n\t\t \n\t\tif (ret) {\n\t\t\tqla2xxx_dump_fw(vha);\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t}\n\t\trval = -EINVAL;\n\t} else {\n\t\tif (ha->flags.idc_compl_status) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x70c3,\n\t\t\t    \"Bad status in IDC Completion AEN\\n\");\n\t\t\trval = -EINVAL;\n\t\t\tha->flags.idc_compl_status = 0;\n\t\t} else\n\t\t\tql_dbg(ql_dbg_user, vha, 0x7023,\n\t\t\t    \"DCBX completion received.\\n\");\n\t}\n\n\tha->notify_dcbx_comp = 0;\n\tha->idc_extend_tmo = 0;\n\ndone_set_internal:\n\treturn rval;\n}\n\nstatic int\nqla2x00_process_loopback(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\tuint8_t command_sent;\n\tchar *type;\n\tstruct msg_echo_lb elreq;\n\tuint16_t response[MAILBOX_REGISTER_COUNT];\n\tuint16_t config[4], new_config[4];\n\tuint8_t *fw_sts_ptr;\n\tvoid *req_data = NULL;\n\tdma_addr_t req_data_dma;\n\tuint32_t req_data_len;\n\tuint8_t *rsp_data = NULL;\n\tdma_addr_t rsp_data_dma;\n\tuint32_t rsp_data_len;\n\n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x7019, \"Host is not online.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmemset(&elreq, 0, sizeof(elreq));\n\n\telreq.req_sg_cnt = dma_map_sg(&ha->pdev->dev,\n\t\tbsg_job->request_payload.sg_list, bsg_job->request_payload.sg_cnt,\n\t\tDMA_TO_DEVICE);\n\n\tif (!elreq.req_sg_cnt) {\n\t\tql_log(ql_log_warn, vha, 0x701a,\n\t\t    \"dma_map_sg returned %d for request.\\n\", elreq.req_sg_cnt);\n\t\treturn -ENOMEM;\n\t}\n\n\telreq.rsp_sg_cnt = dma_map_sg(&ha->pdev->dev,\n\t\tbsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,\n\t\tDMA_FROM_DEVICE);\n\n\tif (!elreq.rsp_sg_cnt) {\n\t\tql_log(ql_log_warn, vha, 0x701b,\n\t\t    \"dma_map_sg returned %d for reply.\\n\", elreq.rsp_sg_cnt);\n\t\trval = -ENOMEM;\n\t\tgoto done_unmap_req_sg;\n\t}\n\n\tif ((elreq.req_sg_cnt !=  bsg_job->request_payload.sg_cnt) ||\n\t\t(elreq.rsp_sg_cnt != bsg_job->reply_payload.sg_cnt)) {\n\t\tql_log(ql_log_warn, vha, 0x701c,\n\t\t    \"dma mapping resulted in different sg counts, \"\n\t\t    \"request_sg_cnt: %x dma_request_sg_cnt: %x \"\n\t\t    \"reply_sg_cnt: %x dma_reply_sg_cnt: %x.\\n\",\n\t\t    bsg_job->request_payload.sg_cnt, elreq.req_sg_cnt,\n\t\t    bsg_job->reply_payload.sg_cnt, elreq.rsp_sg_cnt);\n\t\trval = -EAGAIN;\n\t\tgoto done_unmap_sg;\n\t}\n\treq_data_len = rsp_data_len = bsg_job->request_payload.payload_len;\n\treq_data = dma_alloc_coherent(&ha->pdev->dev, req_data_len,\n\t\t&req_data_dma, GFP_KERNEL);\n\tif (!req_data) {\n\t\tql_log(ql_log_warn, vha, 0x701d,\n\t\t    \"dma alloc failed for req_data.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done_unmap_sg;\n\t}\n\n\trsp_data = dma_alloc_coherent(&ha->pdev->dev, rsp_data_len,\n\t\t&rsp_data_dma, GFP_KERNEL);\n\tif (!rsp_data) {\n\t\tql_log(ql_log_warn, vha, 0x7004,\n\t\t    \"dma alloc failed for rsp_data.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done_free_dma_req;\n\t}\n\n\t \n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt, req_data, req_data_len);\n\n\telreq.send_dma = req_data_dma;\n\telreq.rcv_dma = rsp_data_dma;\n\telreq.transfer_size = req_data_len;\n\n\telreq.options = bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\telreq.iteration_count =\n\t    bsg_request->rqst_data.h_vendor.vendor_cmd[2];\n\n\tif (atomic_read(&vha->loop_state) == LOOP_READY &&\n\t    ((ha->current_topology == ISP_CFG_F && (elreq.options & 7) >= 2) ||\n\t    ((IS_QLA81XX(ha) || IS_QLA8031(ha) || IS_QLA8044(ha)) &&\n\t    get_unaligned_le32(req_data) == ELS_OPCODE_BYTE &&\n\t    req_data_len == MAX_ELS_FRAME_PAYLOAD &&\n\t    elreq.options == EXTERNAL_LOOPBACK))) {\n\t\ttype = \"FC_BSG_HST_VENDOR_ECHO_DIAG\";\n\t\tql_dbg(ql_dbg_user, vha, 0x701e,\n\t\t    \"BSG request type: %s.\\n\", type);\n\t\tcommand_sent = INT_DEF_LB_ECHO_CMD;\n\t\trval = qla2x00_echo_test(vha, &elreq, response);\n\t} else {\n\t\tif (IS_QLA81XX(ha) || IS_QLA8031(ha) || IS_QLA8044(ha)) {\n\t\t\tmemset(config, 0, sizeof(config));\n\t\t\tmemset(new_config, 0, sizeof(new_config));\n\n\t\t\tif (qla81xx_get_port_config(vha, config)) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x701f,\n\t\t\t\t    \"Get port config failed.\\n\");\n\t\t\t\trval = -EPERM;\n\t\t\t\tgoto done_free_dma_rsp;\n\t\t\t}\n\n\t\t\tif ((config[0] & INTERNAL_LOOPBACK_MASK) != 0) {\n\t\t\t\tql_dbg(ql_dbg_user, vha, 0x70c4,\n\t\t\t\t    \"Loopback operation already in \"\n\t\t\t\t    \"progress.\\n\");\n\t\t\t\trval = -EAGAIN;\n\t\t\t\tgoto done_free_dma_rsp;\n\t\t\t}\n\n\t\t\tql_dbg(ql_dbg_user, vha, 0x70c0,\n\t\t\t    \"elreq.options=%04x\\n\", elreq.options);\n\n\t\t\tif (elreq.options == EXTERNAL_LOOPBACK)\n\t\t\t\tif (IS_QLA8031(ha) || IS_QLA8044(ha))\n\t\t\t\t\trval = qla81xx_set_loopback_mode(vha,\n\t\t\t\t\t    config, new_config, elreq.options);\n\t\t\t\telse\n\t\t\t\t\trval = qla81xx_reset_loopback_mode(vha,\n\t\t\t\t\t    config, 1, 0);\n\t\t\telse\n\t\t\t\trval = qla81xx_set_loopback_mode(vha, config,\n\t\t\t\t    new_config, elreq.options);\n\n\t\t\tif (rval) {\n\t\t\t\trval = -EPERM;\n\t\t\t\tgoto done_free_dma_rsp;\n\t\t\t}\n\n\t\t\ttype = \"FC_BSG_HST_VENDOR_LOOPBACK\";\n\t\t\tql_dbg(ql_dbg_user, vha, 0x7028,\n\t\t\t    \"BSG request type: %s.\\n\", type);\n\n\t\t\tcommand_sent = INT_DEF_LB_LOOPBACK_CMD;\n\t\t\trval = qla2x00_loopback_test(vha, &elreq, response);\n\n\t\t\tif (response[0] == MBS_COMMAND_ERROR &&\n\t\t\t\t\tresponse[1] == MBS_LB_RESET) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x7029,\n\t\t\t\t    \"MBX command error, Aborting ISP.\\n\");\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t\tqla2x00_wait_for_chip_reset(vha);\n\t\t\t\t \n\t\t\t\tif (IS_QLA81XX(ha)) {\n\t\t\t\t\tif (qla81xx_restart_mpi_firmware(vha) !=\n\t\t\t\t\t    QLA_SUCCESS) {\n\t\t\t\t\t\tql_log(ql_log_warn, vha, 0x702a,\n\t\t\t\t\t\t    \"MPI reset failed.\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trval = -EIO;\n\t\t\t\tgoto done_free_dma_rsp;\n\t\t\t}\n\n\t\t\tif (new_config[0]) {\n\t\t\t\tint ret;\n\n\t\t\t\t \n\t\t\t\tret = qla81xx_reset_loopback_mode(vha,\n\t\t\t\t    new_config, 0, 1);\n\t\t\t\tif (ret) {\n\t\t\t\t\t \n\t\t\t\t\tqla2xxx_dump_fw(vha);\n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\t\t\ttype = \"FC_BSG_HST_VENDOR_LOOPBACK\";\n\t\t\tql_dbg(ql_dbg_user, vha, 0x702b,\n\t\t\t    \"BSG request type: %s.\\n\", type);\n\t\t\tcommand_sent = INT_DEF_LB_LOOPBACK_CMD;\n\t\t\trval = qla2x00_loopback_test(vha, &elreq, response);\n\t\t}\n\t}\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x702c,\n\t\t    \"Vendor request %s failed.\\n\", type);\n\n\t\trval = 0;\n\t\tbsg_reply->result = (DID_ERROR << 16);\n\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t} else {\n\t\tql_dbg(ql_dbg_user, vha, 0x702d,\n\t\t    \"Vendor request %s completed.\\n\", type);\n\t\tbsg_reply->result = (DID_OK << 16);\n\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\tbsg_job->reply_payload.sg_cnt, rsp_data,\n\t\t\trsp_data_len);\n\t}\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply) +\n\t    sizeof(response) + sizeof(uint8_t);\n\tfw_sts_ptr = bsg_job->reply + sizeof(struct fc_bsg_reply);\n\tmemcpy(bsg_job->reply + sizeof(struct fc_bsg_reply), response,\n\t\t\tsizeof(response));\n\tfw_sts_ptr += sizeof(response);\n\t*fw_sts_ptr = command_sent;\n\ndone_free_dma_rsp:\n\tdma_free_coherent(&ha->pdev->dev, rsp_data_len,\n\t\trsp_data, rsp_data_dma);\ndone_free_dma_req:\n\tdma_free_coherent(&ha->pdev->dev, req_data_len,\n\t\treq_data, req_data_dma);\ndone_unmap_sg:\n\tdma_unmap_sg(&ha->pdev->dev,\n\t    bsg_job->reply_payload.sg_list,\n\t    bsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\ndone_unmap_req_sg:\n\tdma_unmap_sg(&ha->pdev->dev,\n\t    bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\tif (!rval)\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rval;\n}\n\nstatic int\nqla84xx_reset(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\tuint32_t flag;\n\n\tif (!IS_QLA84XX(ha)) {\n\t\tql_dbg(ql_dbg_user, vha, 0x702f, \"Not 84xx, exiting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tflag = bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\n\trval = qla84xx_reset_chip(vha, flag == A84_ISSUE_RESET_DIAG_FW);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x7030,\n\t\t    \"Vendor request 84xx reset failed.\\n\");\n\t\trval = (DID_ERROR << 16);\n\n\t} else {\n\t\tql_dbg(ql_dbg_user, vha, 0x7031,\n\t\t    \"Vendor request 84xx reset completed.\\n\");\n\t\tbsg_reply->result = DID_OK;\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t}\n\n\treturn rval;\n}\n\nstatic int\nqla84xx_updatefw(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct verify_chip_entry_84xx *mn = NULL;\n\tdma_addr_t mn_dma, fw_dma;\n\tvoid *fw_buf = NULL;\n\tint rval = 0;\n\tuint32_t sg_cnt;\n\tuint32_t data_len;\n\tuint16_t options;\n\tuint32_t flag;\n\tuint32_t fw_ver;\n\n\tif (!IS_QLA84XX(ha)) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7032,\n\t\t    \"Not 84xx, exiting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsg_cnt = dma_map_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\tif (!sg_cnt) {\n\t\tql_log(ql_log_warn, vha, 0x7033,\n\t\t    \"dma_map_sg returned %d for request.\\n\", sg_cnt);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sg_cnt != bsg_job->request_payload.sg_cnt) {\n\t\tql_log(ql_log_warn, vha, 0x7034,\n\t\t    \"DMA mapping resulted in different sg counts, \"\n\t\t    \"request_sg_cnt: %x dma_request_sg_cnt: %x.\\n\",\n\t\t    bsg_job->request_payload.sg_cnt, sg_cnt);\n\t\trval = -EAGAIN;\n\t\tgoto done_unmap_sg;\n\t}\n\n\tdata_len = bsg_job->request_payload.payload_len;\n\tfw_buf = dma_alloc_coherent(&ha->pdev->dev, data_len,\n\t\t&fw_dma, GFP_KERNEL);\n\tif (!fw_buf) {\n\t\tql_log(ql_log_warn, vha, 0x7035,\n\t\t    \"DMA alloc failed for fw_buf.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done_unmap_sg;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt, fw_buf, data_len);\n\n\tmn = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &mn_dma);\n\tif (!mn) {\n\t\tql_log(ql_log_warn, vha, 0x7036,\n\t\t    \"DMA alloc failed for fw buffer.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done_free_fw_buf;\n\t}\n\n\tflag = bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\tfw_ver = get_unaligned_le32((uint32_t *)fw_buf + 2);\n\n\tmn->entry_type = VERIFY_CHIP_IOCB_TYPE;\n\tmn->entry_count = 1;\n\n\toptions = VCO_FORCE_UPDATE | VCO_END_OF_DATA;\n\tif (flag == A84_ISSUE_UPDATE_DIAGFW_CMD)\n\t\toptions |= VCO_DIAG_FW;\n\n\tmn->options = cpu_to_le16(options);\n\tmn->fw_ver =  cpu_to_le32(fw_ver);\n\tmn->fw_size =  cpu_to_le32(data_len);\n\tmn->fw_seq_size =  cpu_to_le32(data_len);\n\tput_unaligned_le64(fw_dma, &mn->dsd.address);\n\tmn->dsd.length = cpu_to_le32(data_len);\n\tmn->data_seg_cnt = cpu_to_le16(1);\n\n\trval = qla2x00_issue_iocb_timeout(vha, mn, mn_dma, 0, 120);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x7037,\n\t\t    \"Vendor request 84xx updatefw failed.\\n\");\n\n\t\trval = (DID_ERROR << 16);\n\t} else {\n\t\tql_dbg(ql_dbg_user, vha, 0x7038,\n\t\t    \"Vendor request 84xx updatefw completed.\\n\");\n\n\t\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\t\tbsg_reply->result = DID_OK;\n\t}\n\n\tdma_pool_free(ha->s_dma_pool, mn, mn_dma);\n\ndone_free_fw_buf:\n\tdma_free_coherent(&ha->pdev->dev, data_len, fw_buf, fw_dma);\n\ndone_unmap_sg:\n\tdma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\n\tif (!rval)\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rval;\n}\n\nstatic int\nqla84xx_mgmt_cmd(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct access_chip_84xx *mn = NULL;\n\tdma_addr_t mn_dma, mgmt_dma;\n\tvoid *mgmt_b = NULL;\n\tint rval = 0;\n\tstruct qla_bsg_a84_mgmt *ql84_mgmt;\n\tuint32_t sg_cnt;\n\tuint32_t data_len = 0;\n\tuint32_t dma_direction = DMA_NONE;\n\n\tif (!IS_QLA84XX(ha)) {\n\t\tql_log(ql_log_warn, vha, 0x703a,\n\t\t    \"Not 84xx, exiting.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmn = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &mn_dma);\n\tif (!mn) {\n\t\tql_log(ql_log_warn, vha, 0x703c,\n\t\t    \"DMA alloc failed for fw buffer.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmn->entry_type = ACCESS_CHIP_IOCB_TYPE;\n\tmn->entry_count = 1;\n\tql84_mgmt = (void *)bsg_request + sizeof(struct fc_bsg_request);\n\tswitch (ql84_mgmt->mgmt.cmd) {\n\tcase QLA84_MGMT_READ_MEM:\n\tcase QLA84_MGMT_GET_INFO:\n\t\tsg_cnt = dma_map_sg(&ha->pdev->dev,\n\t\t\tbsg_job->reply_payload.sg_list,\n\t\t\tbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\t\tif (!sg_cnt) {\n\t\t\tql_log(ql_log_warn, vha, 0x703d,\n\t\t\t    \"dma_map_sg returned %d for reply.\\n\", sg_cnt);\n\t\t\trval = -ENOMEM;\n\t\t\tgoto exit_mgmt;\n\t\t}\n\n\t\tdma_direction = DMA_FROM_DEVICE;\n\n\t\tif (sg_cnt != bsg_job->reply_payload.sg_cnt) {\n\t\t\tql_log(ql_log_warn, vha, 0x703e,\n\t\t\t    \"DMA mapping resulted in different sg counts, \"\n\t\t\t    \"reply_sg_cnt: %x dma_reply_sg_cnt: %x.\\n\",\n\t\t\t    bsg_job->reply_payload.sg_cnt, sg_cnt);\n\t\t\trval = -EAGAIN;\n\t\t\tgoto done_unmap_sg;\n\t\t}\n\n\t\tdata_len = bsg_job->reply_payload.payload_len;\n\n\t\tmgmt_b = dma_alloc_coherent(&ha->pdev->dev, data_len,\n\t\t    &mgmt_dma, GFP_KERNEL);\n\t\tif (!mgmt_b) {\n\t\t\tql_log(ql_log_warn, vha, 0x703f,\n\t\t\t    \"DMA alloc failed for mgmt_b.\\n\");\n\t\t\trval = -ENOMEM;\n\t\t\tgoto done_unmap_sg;\n\t\t}\n\n\t\tif (ql84_mgmt->mgmt.cmd == QLA84_MGMT_READ_MEM) {\n\t\t\tmn->options = cpu_to_le16(ACO_DUMP_MEMORY);\n\t\t\tmn->parameter1 =\n\t\t\t\tcpu_to_le32(\n\t\t\t\tql84_mgmt->mgmt.mgmtp.u.mem.start_addr);\n\n\t\t} else if (ql84_mgmt->mgmt.cmd == QLA84_MGMT_GET_INFO) {\n\t\t\tmn->options = cpu_to_le16(ACO_REQUEST_INFO);\n\t\t\tmn->parameter1 =\n\t\t\t\tcpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.info.type);\n\n\t\t\tmn->parameter2 =\n\t\t\t\tcpu_to_le32(\n\t\t\t\tql84_mgmt->mgmt.mgmtp.u.info.context);\n\t\t}\n\t\tbreak;\n\n\tcase QLA84_MGMT_WRITE_MEM:\n\t\tsg_cnt = dma_map_sg(&ha->pdev->dev,\n\t\t\tbsg_job->request_payload.sg_list,\n\t\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\n\t\tif (!sg_cnt) {\n\t\t\tql_log(ql_log_warn, vha, 0x7040,\n\t\t\t    \"dma_map_sg returned %d.\\n\", sg_cnt);\n\t\t\trval = -ENOMEM;\n\t\t\tgoto exit_mgmt;\n\t\t}\n\n\t\tdma_direction = DMA_TO_DEVICE;\n\n\t\tif (sg_cnt != bsg_job->request_payload.sg_cnt) {\n\t\t\tql_log(ql_log_warn, vha, 0x7041,\n\t\t\t    \"DMA mapping resulted in different sg counts, \"\n\t\t\t    \"request_sg_cnt: %x dma_request_sg_cnt: %x.\\n\",\n\t\t\t    bsg_job->request_payload.sg_cnt, sg_cnt);\n\t\t\trval = -EAGAIN;\n\t\t\tgoto done_unmap_sg;\n\t\t}\n\n\t\tdata_len = bsg_job->request_payload.payload_len;\n\t\tmgmt_b = dma_alloc_coherent(&ha->pdev->dev, data_len,\n\t\t\t&mgmt_dma, GFP_KERNEL);\n\t\tif (!mgmt_b) {\n\t\t\tql_log(ql_log_warn, vha, 0x7042,\n\t\t\t    \"DMA alloc failed for mgmt_b.\\n\");\n\t\t\trval = -ENOMEM;\n\t\t\tgoto done_unmap_sg;\n\t\t}\n\n\t\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\tbsg_job->request_payload.sg_cnt, mgmt_b, data_len);\n\n\t\tmn->options = cpu_to_le16(ACO_LOAD_MEMORY);\n\t\tmn->parameter1 =\n\t\t\tcpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.mem.start_addr);\n\t\tbreak;\n\n\tcase QLA84_MGMT_CHNG_CONFIG:\n\t\tmn->options = cpu_to_le16(ACO_CHANGE_CONFIG_PARAM);\n\t\tmn->parameter1 =\n\t\t\tcpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.config.id);\n\n\t\tmn->parameter2 =\n\t\t\tcpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.config.param0);\n\n\t\tmn->parameter3 =\n\t\t\tcpu_to_le32(ql84_mgmt->mgmt.mgmtp.u.config.param1);\n\t\tbreak;\n\n\tdefault:\n\t\trval = -EIO;\n\t\tgoto exit_mgmt;\n\t}\n\n\tif (ql84_mgmt->mgmt.cmd != QLA84_MGMT_CHNG_CONFIG) {\n\t\tmn->total_byte_cnt = cpu_to_le32(ql84_mgmt->mgmt.len);\n\t\tmn->dseg_count = cpu_to_le16(1);\n\t\tput_unaligned_le64(mgmt_dma, &mn->dsd.address);\n\t\tmn->dsd.length = cpu_to_le32(ql84_mgmt->mgmt.len);\n\t}\n\n\trval = qla2x00_issue_iocb(vha, mn, mn_dma, 0);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x7043,\n\t\t    \"Vendor request 84xx mgmt failed.\\n\");\n\n\t\trval = (DID_ERROR << 16);\n\n\t} else {\n\t\tql_dbg(ql_dbg_user, vha, 0x7044,\n\t\t    \"Vendor request 84xx mgmt completed.\\n\");\n\n\t\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\t\tbsg_reply->result = DID_OK;\n\n\t\tif ((ql84_mgmt->mgmt.cmd == QLA84_MGMT_READ_MEM) ||\n\t\t\t(ql84_mgmt->mgmt.cmd == QLA84_MGMT_GET_INFO)) {\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tbsg_job->reply_payload.payload_len;\n\n\t\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\tbsg_job->reply_payload.sg_cnt, mgmt_b,\n\t\t\t\tdata_len);\n\t\t}\n\t}\n\ndone_unmap_sg:\n\tif (mgmt_b)\n\t\tdma_free_coherent(&ha->pdev->dev, data_len, mgmt_b, mgmt_dma);\n\n\tif (dma_direction == DMA_TO_DEVICE)\n\t\tdma_unmap_sg(&ha->pdev->dev, bsg_job->request_payload.sg_list,\n\t\t\tbsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\telse if (dma_direction == DMA_FROM_DEVICE)\n\t\tdma_unmap_sg(&ha->pdev->dev, bsg_job->reply_payload.sg_list,\n\t\t\tbsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\nexit_mgmt:\n\tdma_pool_free(ha->s_dma_pool, mn, mn_dma);\n\n\tif (!rval)\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rval;\n}\n\nstatic int\nqla24xx_iidma(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tint rval = 0;\n\tstruct qla_port_param *port_param = NULL;\n\tfc_port_t *fcport = NULL;\n\tint found = 0;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tuint8_t *rsp_ptr = NULL;\n\n\tif (!IS_IIDMA_CAPABLE(vha->hw)) {\n\t\tql_log(ql_log_info, vha, 0x7046, \"iiDMA not supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tport_param = (void *)bsg_request + sizeof(struct fc_bsg_request);\n\tif (port_param->fc_scsi_addr.dest_type != EXT_DEF_TYPE_WWPN) {\n\t\tql_log(ql_log_warn, vha, 0x7048,\n\t\t    \"Invalid destination type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->port_type != FCT_TARGET)\n\t\t\tcontinue;\n\n\t\tif (memcmp(port_param->fc_scsi_addr.dest_addr.wwpn,\n\t\t\tfcport->port_name, sizeof(fcport->port_name)))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\n\tif (!found) {\n\t\tql_log(ql_log_warn, vha, 0x7049,\n\t\t    \"Failed to find port.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (atomic_read(&fcport->state) != FCS_ONLINE) {\n\t\tql_log(ql_log_warn, vha, 0x704a,\n\t\t    \"Port is not online.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fcport->flags & FCF_LOGIN_NEEDED) {\n\t\tql_log(ql_log_warn, vha, 0x704b,\n\t\t    \"Remote port not logged in flags = 0x%x.\\n\", fcport->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (port_param->mode)\n\t\trval = qla2x00_set_idma_speed(vha, fcport->loop_id,\n\t\t\tport_param->speed, mb);\n\telse\n\t\trval = qla2x00_get_idma_speed(vha, fcport->loop_id,\n\t\t\t&port_param->speed, mb);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x704c,\n\t\t    \"iiDMA cmd failed for %8phN -- \"\n\t\t    \"%04x %x %04x %04x.\\n\", fcport->port_name,\n\t\t    rval, fcport->fp_speed, mb[0], mb[1]);\n\t\trval = (DID_ERROR << 16);\n\t} else {\n\t\tif (!port_param->mode) {\n\t\t\tbsg_job->reply_len = sizeof(struct fc_bsg_reply) +\n\t\t\t\tsizeof(struct qla_port_param);\n\n\t\t\trsp_ptr = ((uint8_t *)bsg_reply) +\n\t\t\t\tsizeof(struct fc_bsg_reply);\n\n\t\t\tmemcpy(rsp_ptr, port_param,\n\t\t\t\tsizeof(struct qla_port_param));\n\t\t}\n\n\t\tbsg_reply->result = DID_OK;\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t}\n\n\treturn rval;\n}\n\nstatic int\nqla2x00_optrom_setup(struct bsg_job *bsg_job, scsi_qla_host_t *vha,\n\tuint8_t is_update)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tuint32_t start = 0;\n\tint valid = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn -EINVAL;\n\n\tstart = bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\tif (start > ha->optrom_size) {\n\t\tql_log(ql_log_warn, vha, 0x7055,\n\t\t    \"start %d > optrom_size %d.\\n\", start, ha->optrom_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ha->optrom_state != QLA_SWAITING) {\n\t\tql_log(ql_log_info, vha, 0x7056,\n\t\t    \"optrom_state %d.\\n\", ha->optrom_state);\n\t\treturn -EBUSY;\n\t}\n\n\tha->optrom_region_start = start;\n\tql_dbg(ql_dbg_user, vha, 0x7057, \"is_update=%d.\\n\", is_update);\n\tif (is_update) {\n\t\tif (ha->optrom_size == OPTROM_SIZE_2300 && start == 0)\n\t\t\tvalid = 1;\n\t\telse if (start == (ha->flt_region_boot * 4) ||\n\t\t    start == (ha->flt_region_fw * 4))\n\t\t\tvalid = 1;\n\t\telse if (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha) ||\n\t\t    IS_CNA_CAPABLE(ha) || IS_QLA2031(ha) || IS_QLA27XX(ha) ||\n\t\t    IS_QLA28XX(ha))\n\t\t\tvalid = 1;\n\t\tif (!valid) {\n\t\t\tql_log(ql_log_warn, vha, 0x7058,\n\t\t\t    \"Invalid start region 0x%x/0x%x.\\n\", start,\n\t\t\t    bsg_job->request_payload.payload_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tha->optrom_region_size = start +\n\t\t    bsg_job->request_payload.payload_len > ha->optrom_size ?\n\t\t    ha->optrom_size - start :\n\t\t    bsg_job->request_payload.payload_len;\n\t\tha->optrom_state = QLA_SWRITING;\n\t} else {\n\t\tha->optrom_region_size = start +\n\t\t    bsg_job->reply_payload.payload_len > ha->optrom_size ?\n\t\t    ha->optrom_size - start :\n\t\t    bsg_job->reply_payload.payload_len;\n\t\tha->optrom_state = QLA_SREADING;\n\t}\n\n\tha->optrom_buffer = vzalloc(ha->optrom_region_size);\n\tif (!ha->optrom_buffer) {\n\t\tql_log(ql_log_warn, vha, 0x7059,\n\t\t    \"Read: Unable to allocate memory for optrom retrieval \"\n\t\t    \"(%x)\\n\", ha->optrom_region_size);\n\n\t\tha->optrom_state = QLA_SWAITING;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_read_optrom(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\n\tif (ha->flags.nic_core_reset_hdlr_active)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&ha->optrom_mutex);\n\trval = qla2x00_optrom_setup(bsg_job, vha, 0);\n\tif (rval) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn rval;\n\t}\n\n\tha->isp_ops->read_optrom(vha, ha->optrom_buffer,\n\t    ha->optrom_region_start, ha->optrom_region_size);\n\n\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t    bsg_job->reply_payload.sg_cnt, ha->optrom_buffer,\n\t    ha->optrom_region_size);\n\n\tbsg_reply->reply_payload_rcv_len = ha->optrom_region_size;\n\tbsg_reply->result = DID_OK;\n\tvfree(ha->optrom_buffer);\n\tha->optrom_buffer = NULL;\n\tha->optrom_state = QLA_SWAITING;\n\tmutex_unlock(&ha->optrom_mutex);\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rval;\n}\n\nstatic int\nqla2x00_update_optrom(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\n\tmutex_lock(&ha->optrom_mutex);\n\trval = qla2x00_optrom_setup(bsg_job, vha, 1);\n\tif (rval) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn rval;\n\t}\n\n\t \n\tha->flags.isp82xx_no_md_cap = 1;\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, ha->optrom_buffer,\n\t    ha->optrom_region_size);\n\n\trval = ha->isp_ops->write_optrom(vha, ha->optrom_buffer,\n\t    ha->optrom_region_start, ha->optrom_region_size);\n\n\tif (rval) {\n\t\tbsg_reply->result = -EINVAL;\n\t\trval = -EINVAL;\n\t} else {\n\t\tbsg_reply->result = DID_OK;\n\t}\n\tvfree(ha->optrom_buffer);\n\tha->optrom_buffer = NULL;\n\tha->optrom_state = QLA_SWAITING;\n\tmutex_unlock(&ha->optrom_mutex);\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rval;\n}\n\nstatic int\nqla2x00_update_fru_versions(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\tuint8_t bsg[DMA_POOL_SIZE];\n\tstruct qla_image_version_list *list = (void *)bsg;\n\tstruct qla_image_version *image;\n\tuint32_t count;\n\tdma_addr_t sfp_dma;\n\tvoid *sfp = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &sfp_dma);\n\n\tif (!sfp) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_NO_MEMORY;\n\t\tgoto done;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, list, sizeof(bsg));\n\n\timage = list->version;\n\tcount = list->count;\n\twhile (count--) {\n\t\tmemcpy(sfp, &image->field_info, sizeof(image->field_info));\n\t\trval = qla2x00_write_sfp(vha, sfp_dma, sfp,\n\t\t    image->field_address.device, image->field_address.offset,\n\t\t    sizeof(image->field_info), image->field_address.option);\n\t\tif (rval) {\n\t\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t\t    EXT_STATUS_MAILBOX;\n\t\t\tgoto dealloc;\n\t\t}\n\t\timage++;\n\t}\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = 0;\n\ndealloc:\n\tdma_pool_free(ha->s_dma_pool, sfp, sfp_dma);\n\ndone:\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_read_fru_status(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\tuint8_t bsg[DMA_POOL_SIZE];\n\tstruct qla_status_reg *sr = (void *)bsg;\n\tdma_addr_t sfp_dma;\n\tuint8_t *sfp = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &sfp_dma);\n\n\tif (!sfp) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_NO_MEMORY;\n\t\tgoto done;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, sr, sizeof(*sr));\n\n\trval = qla2x00_read_sfp(vha, sfp_dma, sfp,\n\t    sr->field_address.device, sr->field_address.offset,\n\t    sizeof(sr->status_reg), sr->field_address.option);\n\tsr->status_reg = *sfp;\n\n\tif (rval) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_MAILBOX;\n\t\tgoto dealloc;\n\t}\n\n\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t    bsg_job->reply_payload.sg_cnt, sr, sizeof(*sr));\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = 0;\n\ndealloc:\n\tdma_pool_free(ha->s_dma_pool, sfp, sfp_dma);\n\ndone:\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->reply_payload_rcv_len = sizeof(*sr);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_write_fru_status(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\tuint8_t bsg[DMA_POOL_SIZE];\n\tstruct qla_status_reg *sr = (void *)bsg;\n\tdma_addr_t sfp_dma;\n\tuint8_t *sfp = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &sfp_dma);\n\n\tif (!sfp) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_NO_MEMORY;\n\t\tgoto done;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, sr, sizeof(*sr));\n\n\t*sfp = sr->status_reg;\n\trval = qla2x00_write_sfp(vha, sfp_dma, sfp,\n\t    sr->field_address.device, sr->field_address.offset,\n\t    sizeof(sr->status_reg), sr->field_address.option);\n\n\tif (rval) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_MAILBOX;\n\t\tgoto dealloc;\n\t}\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = 0;\n\ndealloc:\n\tdma_pool_free(ha->s_dma_pool, sfp, sfp_dma);\n\ndone:\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_write_i2c(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\tuint8_t bsg[DMA_POOL_SIZE];\n\tstruct qla_i2c_access *i2c = (void *)bsg;\n\tdma_addr_t sfp_dma;\n\tuint8_t *sfp = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &sfp_dma);\n\n\tif (!sfp) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_NO_MEMORY;\n\t\tgoto done;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, i2c, sizeof(*i2c));\n\n\tmemcpy(sfp, i2c->buffer, i2c->length);\n\trval = qla2x00_write_sfp(vha, sfp_dma, sfp,\n\t    i2c->device, i2c->offset, i2c->length, i2c->option);\n\n\tif (rval) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_MAILBOX;\n\t\tgoto dealloc;\n\t}\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = 0;\n\ndealloc:\n\tdma_pool_free(ha->s_dma_pool, sfp, sfp_dma);\n\ndone:\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_read_i2c(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\tuint8_t bsg[DMA_POOL_SIZE];\n\tstruct qla_i2c_access *i2c = (void *)bsg;\n\tdma_addr_t sfp_dma;\n\tuint8_t *sfp = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &sfp_dma);\n\n\tif (!sfp) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_NO_MEMORY;\n\t\tgoto done;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, i2c, sizeof(*i2c));\n\n\trval = qla2x00_read_sfp(vha, sfp_dma, sfp,\n\t\ti2c->device, i2c->offset, i2c->length, i2c->option);\n\n\tif (rval) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_MAILBOX;\n\t\tgoto dealloc;\n\t}\n\n\tmemcpy(i2c->buffer, sfp, i2c->length);\n\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t    bsg_job->reply_payload.sg_cnt, i2c, sizeof(*i2c));\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = 0;\n\ndealloc:\n\tdma_pool_free(ha->s_dma_pool, sfp, sfp_dma);\n\ndone:\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->reply_payload_rcv_len = sizeof(*i2c);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\n\treturn 0;\n}\n\nstatic int\nqla24xx_process_bidir_cmd(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t rval = EXT_STATUS_OK;\n\tuint16_t req_sg_cnt = 0;\n\tuint16_t rsp_sg_cnt = 0;\n\tuint16_t nextlid = 0;\n\tuint32_t tot_dsds;\n\tsrb_t *sp = NULL;\n\tuint32_t req_data_len;\n\tuint32_t rsp_data_len;\n\n\t \n\tif (!IS_BIDI_CAPABLE(ha)) {\n\t\tql_log(ql_log_warn, vha, 0x70a0,\n\t\t\t\"This adapter is not supported\\n\");\n\t\trval = EXT_STATUS_NOT_SUPPORTED;\n\t\tgoto done;\n\t}\n\n\tif (test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) ||\n\t\ttest_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) ||\n\t\ttest_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\n\t\trval =  EXT_STATUS_BUSY;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x70a1,\n\t\t\t\"Host is not online\\n\");\n\t\trval = EXT_STATUS_DEVICE_OFFLINE;\n\t\tgoto done;\n\t}\n\n\t \n\tif (vha->device_flags & DFLG_NO_CABLE) {\n\t\tql_log(ql_log_warn, vha, 0x70a2,\n\t\t\t\"Cable is unplugged...\\n\");\n\t\trval = EXT_STATUS_INVALID_CFG;\n\t\tgoto done;\n\t}\n\n\t \n\tif (ha->current_topology != ISP_CFG_F) {\n\t\tql_log(ql_log_warn, vha, 0x70a3,\n\t\t\t\"Host is not connected to the switch\\n\");\n\t\trval = EXT_STATUS_INVALID_CFG;\n\t\tgoto done;\n\t}\n\n\t \n\tif (ha->operating_mode != P2P) {\n\t\tql_log(ql_log_warn, vha, 0x70a4,\n\t\t    \"Host operating mode is not P2p\\n\");\n\t\trval = EXT_STATUS_INVALID_CFG;\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&ha->selflogin_lock);\n\tif (vha->self_login_loop_id == 0) {\n\t\t \n\t\tvha->bidir_fcport.vha = vha;\n\t\tvha->bidir_fcport.d_id.b.al_pa = vha->d_id.b.al_pa;\n\t\tvha->bidir_fcport.d_id.b.area = vha->d_id.b.area;\n\t\tvha->bidir_fcport.d_id.b.domain = vha->d_id.b.domain;\n\t\tvha->bidir_fcport.loop_id = vha->loop_id;\n\n\t\tif (qla2x00_fabric_login(vha, &(vha->bidir_fcport), &nextlid)) {\n\t\t\tql_log(ql_log_warn, vha, 0x70a7,\n\t\t\t    \"Failed to login port %06X for bidirectional IOCB\\n\",\n\t\t\t    vha->bidir_fcport.d_id.b24);\n\t\t\tmutex_unlock(&ha->selflogin_lock);\n\t\t\trval = EXT_STATUS_MAILBOX;\n\t\t\tgoto done;\n\t\t}\n\t\tvha->self_login_loop_id = nextlid - 1;\n\n\t}\n\t \n\tmutex_unlock(&ha->selflogin_lock);\n\n\tvha->bidir_fcport.loop_id = vha->self_login_loop_id;\n\n\treq_sg_cnt = dma_map_sg(&ha->pdev->dev,\n\t\tbsg_job->request_payload.sg_list,\n\t\tbsg_job->request_payload.sg_cnt,\n\t\tDMA_TO_DEVICE);\n\n\tif (!req_sg_cnt) {\n\t\trval = EXT_STATUS_NO_MEMORY;\n\t\tgoto done;\n\t}\n\n\trsp_sg_cnt = dma_map_sg(&ha->pdev->dev,\n\t\tbsg_job->reply_payload.sg_list, bsg_job->reply_payload.sg_cnt,\n\t\tDMA_FROM_DEVICE);\n\n\tif (!rsp_sg_cnt) {\n\t\trval = EXT_STATUS_NO_MEMORY;\n\t\tgoto done_unmap_req_sg;\n\t}\n\n\tif ((req_sg_cnt !=  bsg_job->request_payload.sg_cnt) ||\n\t\t(rsp_sg_cnt != bsg_job->reply_payload.sg_cnt)) {\n\t\tql_dbg(ql_dbg_user, vha, 0x70a9,\n\t\t    \"Dma mapping resulted in different sg counts \"\n\t\t    \"[request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt: \"\n\t\t    \"%x dma_reply_sg_cnt: %x]\\n\",\n\t\t    bsg_job->request_payload.sg_cnt, req_sg_cnt,\n\t\t    bsg_job->reply_payload.sg_cnt, rsp_sg_cnt);\n\t\trval = EXT_STATUS_NO_MEMORY;\n\t\tgoto done_unmap_sg;\n\t}\n\n\treq_data_len = bsg_job->request_payload.payload_len;\n\trsp_data_len = bsg_job->reply_payload.payload_len;\n\n\tif (req_data_len != rsp_data_len) {\n\t\trval = EXT_STATUS_BUSY;\n\t\tql_log(ql_log_warn, vha, 0x70aa,\n\t\t    \"req_data_len != rsp_data_len\\n\");\n\t\tgoto done_unmap_sg;\n\t}\n\n\t \n\tsp = qla2x00_get_sp(vha, &(vha->bidir_fcport), GFP_KERNEL);\n\tif (!sp) {\n\t\tql_dbg(ql_dbg_user, vha, 0x70ac,\n\t\t    \"Alloc SRB structure failed\\n\");\n\t\trval = EXT_STATUS_NO_MEMORY;\n\t\tgoto done_unmap_sg;\n\t}\n\n\t \n\tsp->u.bsg_job = bsg_job;\n\tsp->free = qla2x00_bsg_sp_free;\n\tsp->type = SRB_BIDI_CMD;\n\tsp->done = qla2x00_bsg_job_done;\n\n\t \n\ttot_dsds = rsp_sg_cnt + req_sg_cnt;\n\n\trval = qla2x00_start_bidir(sp, vha, tot_dsds);\n\tif (rval != EXT_STATUS_OK)\n\t\tgoto done_free_srb;\n\t \n\treturn rval;\n\ndone_free_srb:\n\tmempool_free(sp, ha->srb_mempool);\ndone_unmap_sg:\n\tdma_unmap_sg(&ha->pdev->dev,\n\t    bsg_job->reply_payload.sg_list,\n\t    bsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\ndone_unmap_req_sg:\n\tdma_unmap_sg(&ha->pdev->dev,\n\t    bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\ndone:\n\n\t \n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = rval;\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->reply_payload_rcv_len = 0;\n\tbsg_reply->result = (DID_OK) << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\t \n\treturn 0;\n}\n\nstatic int\nqlafx00_mgmt_cmd(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = (DID_ERROR << 16);\n\tstruct qla_mt_iocb_rqst_fx00 *piocb_rqst;\n\tsrb_t *sp;\n\tint req_sg_cnt = 0, rsp_sg_cnt = 0;\n\tstruct fc_port *fcport;\n\tchar  *type = \"FC_BSG_HST_FX_MGMT\";\n\n\t \n\tpiocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)\n\t    &bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\n\t \n\tql_dump_buffer(ql_dbg_user + ql_dbg_verbose , vha, 0x70cf,\n\t    piocb_rqst, sizeof(*piocb_rqst));\n\n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x70d0,\n\t\t    \"Host is not online.\\n\");\n\t\trval = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (piocb_rqst->flags & SRB_FXDISC_REQ_DMA_VALID) {\n\t\treq_sg_cnt = dma_map_sg(&ha->pdev->dev,\n\t\t    bsg_job->request_payload.sg_list,\n\t\t    bsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\t\tif (!req_sg_cnt) {\n\t\t\tql_log(ql_log_warn, vha, 0x70c7,\n\t\t\t    \"dma_map_sg return %d for request\\n\", req_sg_cnt);\n\t\t\trval = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (piocb_rqst->flags & SRB_FXDISC_RESP_DMA_VALID) {\n\t\trsp_sg_cnt = dma_map_sg(&ha->pdev->dev,\n\t\t    bsg_job->reply_payload.sg_list,\n\t\t    bsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\t\tif (!rsp_sg_cnt) {\n\t\t\tql_log(ql_log_warn, vha, 0x70c8,\n\t\t\t    \"dma_map_sg return %d for reply\\n\", rsp_sg_cnt);\n\t\t\trval = -ENOMEM;\n\t\t\tgoto done_unmap_req_sg;\n\t\t}\n\t}\n\n\tql_dbg(ql_dbg_user, vha, 0x70c9,\n\t    \"request_sg_cnt: %x dma_request_sg_cnt: %x reply_sg_cnt:%x \"\n\t    \"dma_reply_sg_cnt: %x\\n\", bsg_job->request_payload.sg_cnt,\n\t    req_sg_cnt, bsg_job->reply_payload.sg_cnt, rsp_sg_cnt);\n\n\t \n\tfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (!fcport) {\n\t\tql_log(ql_log_warn, vha, 0x70ca,\n\t\t    \"Failed to allocate fcport.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done_unmap_rsp_sg;\n\t}\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp) {\n\t\tql_log(ql_log_warn, vha, 0x70cb,\n\t\t    \"qla2x00_get_sp failed.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done_free_fcport;\n\t}\n\n\t \n\tfcport->vha = vha;\n\tfcport->loop_id = le32_to_cpu(piocb_rqst->dataword);\n\n\tsp->type = SRB_FXIOCB_BCMD;\n\tsp->name = \"bsg_fx_mgmt\";\n\tsp->iocbs = qla24xx_calc_ct_iocbs(req_sg_cnt + rsp_sg_cnt);\n\tsp->u.bsg_job = bsg_job;\n\tsp->free = qla2x00_bsg_sp_free;\n\tsp->done = qla2x00_bsg_job_done;\n\n\tql_dbg(ql_dbg_user, vha, 0x70cc,\n\t    \"bsg rqst type: %s fx_mgmt_type: %x id=%x\\n\",\n\t    type, piocb_rqst->func_type, fcport->loop_id);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x70cd,\n\t\t    \"qla2x00_start_sp failed=%d.\\n\", rval);\n\t\tmempool_free(sp, ha->srb_mempool);\n\t\trval = -EIO;\n\t\tgoto done_free_fcport;\n\t}\n\treturn rval;\n\ndone_free_fcport:\n\tqla2x00_free_fcport(fcport);\n\ndone_unmap_rsp_sg:\n\tif (piocb_rqst->flags & SRB_FXDISC_RESP_DMA_VALID)\n\t\tdma_unmap_sg(&ha->pdev->dev,\n\t\t    bsg_job->reply_payload.sg_list,\n\t\t    bsg_job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\ndone_unmap_req_sg:\n\tif (piocb_rqst->flags & SRB_FXDISC_REQ_DMA_VALID)\n\t\tdma_unmap_sg(&ha->pdev->dev,\n\t\t    bsg_job->request_payload.sg_list,\n\t\t    bsg_job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\ndone:\n\treturn rval;\n}\n\nstatic int\nqla26xx_serdes_op(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tint rval = 0;\n\tstruct qla_serdes_reg sr;\n\n\tmemset(&sr, 0, sizeof(sr));\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &sr, sizeof(sr));\n\n\tswitch (sr.cmd) {\n\tcase INT_SC_SERDES_WRITE_REG:\n\t\trval = qla2x00_write_serdes_word(vha, sr.addr, sr.val);\n\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t\tbreak;\n\tcase INT_SC_SERDES_READ_REG:\n\t\trval = qla2x00_read_serdes_word(vha, sr.addr, &sr.val);\n\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t    bsg_job->reply_payload.sg_cnt, &sr, sizeof(sr));\n\t\tbsg_reply->reply_payload_rcv_len = sizeof(sr);\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_user, vha, 0x708c,\n\t\t    \"Unknown serdes cmd %x.\\n\", sr.cmd);\n\t\trval = -EINVAL;\n\t\tbreak;\n\t}\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t    rval ? EXT_STATUS_MAILBOX : 0;\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn 0;\n}\n\nstatic int\nqla8044_serdes_op(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tint rval = 0;\n\tstruct qla_serdes_reg_ex sr;\n\n\tmemset(&sr, 0, sizeof(sr));\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &sr, sizeof(sr));\n\n\tswitch (sr.cmd) {\n\tcase INT_SC_SERDES_WRITE_REG:\n\t\trval = qla8044_write_serdes_word(vha, sr.addr, sr.val);\n\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t\tbreak;\n\tcase INT_SC_SERDES_READ_REG:\n\t\trval = qla8044_read_serdes_word(vha, sr.addr, &sr.val);\n\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t    bsg_job->reply_payload.sg_cnt, &sr, sizeof(sr));\n\t\tbsg_reply->reply_payload_rcv_len = sizeof(sr);\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_user, vha, 0x7020,\n\t\t    \"Unknown serdes cmd %x.\\n\", sr.cmd);\n\t\trval = -EINVAL;\n\t\tbreak;\n\t}\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t    rval ? EXT_STATUS_MAILBOX : 0;\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn 0;\n}\n\nstatic int\nqla27xx_get_flash_upd_cap(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_flash_update_caps cap;\n\n\tif (!(IS_QLA27XX(ha)) && !IS_QLA28XX(ha))\n\t\treturn -EPERM;\n\n\tmemset(&cap, 0, sizeof(cap));\n\tcap.capabilities = (uint64_t)ha->fw_attributes_ext[1] << 48 |\n\t\t\t   (uint64_t)ha->fw_attributes_ext[0] << 32 |\n\t\t\t   (uint64_t)ha->fw_attributes_h << 16 |\n\t\t\t   (uint64_t)ha->fw_attributes;\n\n\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t    bsg_job->reply_payload.sg_cnt, &cap, sizeof(cap));\n\tbsg_reply->reply_payload_rcv_len = sizeof(cap);\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t    EXT_STATUS_OK;\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn 0;\n}\n\nstatic int\nqla27xx_set_flash_upd_cap(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint64_t online_fw_attr = 0;\n\tstruct qla_flash_update_caps cap;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn -EPERM;\n\n\tmemset(&cap, 0, sizeof(cap));\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &cap, sizeof(cap));\n\n\tonline_fw_attr = (uint64_t)ha->fw_attributes_ext[1] << 48 |\n\t\t\t (uint64_t)ha->fw_attributes_ext[0] << 32 |\n\t\t\t (uint64_t)ha->fw_attributes_h << 16 |\n\t\t\t (uint64_t)ha->fw_attributes;\n\n\tif (online_fw_attr != cap.capabilities) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_INVALID_PARAM;\n\t\treturn -EINVAL;\n\t}\n\n\tif (cap.outage_duration < MAX_LOOP_TIMEOUT)  {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t    EXT_STATUS_INVALID_PARAM;\n\t\treturn -EINVAL;\n\t}\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t    EXT_STATUS_OK;\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn 0;\n}\n\nstatic int\nqla27xx_get_bbcr_data(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_bbcr_data bbcr;\n\tuint16_t loop_id, topo, sw_cap;\n\tuint8_t domain, area, al_pa, state;\n\tint rval;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn -EPERM;\n\n\tmemset(&bbcr, 0, sizeof(bbcr));\n\n\tif (vha->flags.bbcr_enable)\n\t\tbbcr.status = QLA_BBCR_STATUS_ENABLED;\n\telse\n\t\tbbcr.status = QLA_BBCR_STATUS_DISABLED;\n\n\tif (bbcr.status == QLA_BBCR_STATUS_ENABLED) {\n\t\trval = qla2x00_get_adapter_id(vha, &loop_id, &al_pa,\n\t\t\t&area, &domain, &topo, &sw_cap);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tbbcr.status = QLA_BBCR_STATUS_UNKNOWN;\n\t\t\tbbcr.state = QLA_BBCR_STATE_OFFLINE;\n\t\t\tbbcr.mbx1 = loop_id;\n\t\t\tgoto done;\n\t\t}\n\n\t\tstate = (vha->bbcr >> 12) & 0x1;\n\n\t\tif (state) {\n\t\t\tbbcr.state = QLA_BBCR_STATE_OFFLINE;\n\t\t\tbbcr.offline_reason_code = QLA_BBCR_REASON_LOGIN_REJECT;\n\t\t} else {\n\t\t\tbbcr.state = QLA_BBCR_STATE_ONLINE;\n\t\t\tbbcr.negotiated_bbscn = (vha->bbcr >> 8) & 0xf;\n\t\t}\n\n\t\tbbcr.configured_bbscn = vha->bbcr & 0xf;\n\t}\n\ndone:\n\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\tbsg_job->reply_payload.sg_cnt, &bbcr, sizeof(bbcr));\n\tbsg_reply->reply_payload_rcv_len = sizeof(bbcr);\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn 0;\n}\n\nstatic int\nqla2x00_get_priv_stats(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tstruct link_statistics *stats = NULL;\n\tdma_addr_t stats_dma;\n\tint rval;\n\tuint32_t *cmd = bsg_request->rqst_data.h_vendor.vendor_cmd;\n\tuint options = cmd[0] == QL_VND_GET_PRIV_STATS_EX ? cmd[1] : 0;\n\n\tif (test_bit(UNLOADING, &vha->dpc_flags))\n\t\treturn -ENODEV;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn -ENODEV;\n\n\tif (qla2x00_reset_active(vha))\n\t\treturn -EBUSY;\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn -EPERM;\n\n\tstats = dma_alloc_coherent(&ha->pdev->dev, sizeof(*stats), &stats_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!stats) {\n\t\tql_log(ql_log_warn, vha, 0x70e2,\n\t\t    \"Failed to allocate memory for stats.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trval = qla24xx_get_isp_stats(base_vha, stats, stats_dma, options);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tql_dump_buffer(ql_dbg_user + ql_dbg_verbose, vha, 0x70e5,\n\t\t\tstats, sizeof(*stats));\n\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\tbsg_job->reply_payload.sg_cnt, stats, sizeof(*stats));\n\t}\n\n\tbsg_reply->reply_payload_rcv_len = sizeof(*stats);\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t    rval ? EXT_STATUS_MAILBOX : EXT_STATUS_OK;\n\n\tbsg_job->reply_len = sizeof(*bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*stats),\n\t\tstats, stats_dma);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_do_dport_diagnostics(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tint rval;\n\tstruct qla_dport_diag *dd;\n\n\tif (!IS_QLA83XX(vha->hw) && !IS_QLA27XX(vha->hw) &&\n\t    !IS_QLA28XX(vha->hw))\n\t\treturn -EPERM;\n\n\tdd = kmalloc(sizeof(*dd), GFP_KERNEL);\n\tif (!dd) {\n\t\tql_log(ql_log_warn, vha, 0x70db,\n\t\t    \"Failed to allocate memory for dport.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, dd, sizeof(*dd));\n\n\trval = qla26xx_dport_diagnostics(\n\t    vha, dd->buf, sizeof(dd->buf), dd->options);\n\tif (rval == QLA_SUCCESS) {\n\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t    bsg_job->reply_payload.sg_cnt, dd, sizeof(*dd));\n\t}\n\n\tbsg_reply->reply_payload_rcv_len = sizeof(*dd);\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t    rval ? EXT_STATUS_MAILBOX : EXT_STATUS_OK;\n\n\tbsg_job->reply_len = sizeof(*bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\n\tkfree(dd);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_do_dport_diagnostics_v2(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tint rval;\n\tstruct qla_dport_diag_v2 *dd;\n\tmbx_cmd_t mc;\n\tmbx_cmd_t *mcp = &mc;\n\tuint16_t options;\n\n\tif (!IS_DPORT_CAPABLE(vha->hw))\n\t\treturn -EPERM;\n\n\tdd = kzalloc(sizeof(*dd), GFP_KERNEL);\n\tif (!dd)\n\t\treturn -ENOMEM;\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\tbsg_job->request_payload.sg_cnt, dd, sizeof(*dd));\n\n\toptions  = dd->options;\n\n\t \n\tif (options == QLA_GET_DPORT_RESULT_V2 &&\n\t    vha->dport_status & DPORT_DIAG_IN_PROGRESS) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t\t\t\tEXT_STATUS_DPORT_DIAG_IN_PROCESS;\n\t\tgoto dportcomplete;\n\t}\n\n\t \n\tif (vha->dport_status & DPORT_DIAG_CHIP_RESET_IN_PROGRESS &&\n\t    (options == QLA_START_DPORT_TEST_V2 ||\n\t     options == QLA_RESTART_DPORT_TEST_V2)) {\n\t\tvha->dport_status &= ~DPORT_DIAG_CHIP_RESET_IN_PROGRESS;\n\t}\n\n\t \n\tif (vha->dport_status & DPORT_DIAG_CHIP_RESET_IN_PROGRESS &&\n\t    options == QLA_GET_DPORT_RESULT_V2) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t\t\t\tEXT_STATUS_DPORT_DIAG_NOT_RUNNING;\n\t\tgoto dportcomplete;\n\t}\n\n\trval = qla26xx_dport_diagnostics_v2(vha, dd, mcp);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t\t\t\tEXT_STATUS_OK;\n\t\tif (options == QLA_START_DPORT_TEST_V2 ||\n\t\t    options == QLA_RESTART_DPORT_TEST_V2) {\n\t\t\tdd->mbx1 = mcp->mb[0];\n\t\t\tdd->mbx2 = mcp->mb[1];\n\t\t\tvha->dport_status |=  DPORT_DIAG_IN_PROGRESS;\n\t\t} else if (options == QLA_GET_DPORT_RESULT_V2) {\n\t\t\tdd->mbx1 = le16_to_cpu(vha->dport_data[1]);\n\t\t\tdd->mbx2 = le16_to_cpu(vha->dport_data[2]);\n\t\t}\n\t} else {\n\t\tdd->mbx1 = mcp->mb[0];\n\t\tdd->mbx2 = mcp->mb[1];\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] =\n\t\t\t\tEXT_STATUS_DPORT_DIAG_ERR;\n\t}\n\ndportcomplete:\n\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t    bsg_job->reply_payload.sg_cnt, dd, sizeof(*dd));\n\n\tbsg_reply->reply_payload_rcv_len = sizeof(*dd);\n\tbsg_job->reply_len = sizeof(*bsg_reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\n\tkfree(dd);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_get_flash_image_status(struct bsg_job *bsg_job)\n{\n\tscsi_qla_host_t *vha = shost_priv(fc_bsg_to_shost(bsg_job));\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_active_regions regions = { };\n\tstruct active_regions active_regions = { };\n\n\tqla27xx_get_active_image(vha, &active_regions);\n\tregions.global_image = active_regions.global;\n\n\tif (IS_QLA27XX(ha))\n\t\tregions.nvme_params = QLA27XX_PRIMARY_IMAGE;\n\n\tif (IS_QLA28XX(ha)) {\n\t\tqla28xx_get_aux_images(vha, &active_regions);\n\t\tregions.board_config = active_regions.aux.board_config;\n\t\tregions.vpd_nvram = active_regions.aux.vpd_nvram;\n\t\tregions.npiv_config_0_1 = active_regions.aux.npiv_config_0_1;\n\t\tregions.npiv_config_2_3 = active_regions.aux.npiv_config_2_3;\n\t\tregions.nvme_params = active_regions.aux.nvme_params;\n\t}\n\n\tql_dbg(ql_dbg_user, vha, 0x70e1,\n\t    \"%s(%lu): FW=%u BCFG=%u VPDNVR=%u NPIV01=%u NPIV02=%u NVME_PARAMS=%u\\n\",\n\t    __func__, vha->host_no, regions.global_image,\n\t    regions.board_config, regions.vpd_nvram,\n\t    regions.npiv_config_0_1, regions.npiv_config_2_3, regions.nvme_params);\n\n\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t    bsg_job->reply_payload.sg_cnt, &regions, sizeof(regions));\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;\n\tbsg_reply->reply_payload_rcv_len = sizeof(regions);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t    bsg_reply->reply_payload_rcv_len);\n\n\treturn 0;\n}\n\nstatic int\nqla2x00_manage_host_stats(struct bsg_job *bsg_job)\n{\n\tscsi_qla_host_t *vha = shost_priv(fc_bsg_to_shost(bsg_job));\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct ql_vnd_mng_host_stats_param *req_data;\n\tstruct ql_vnd_mng_host_stats_resp rsp_data;\n\tu32 req_data_len;\n\tint ret = 0;\n\n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"Host is not online.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treq_data_len = bsg_job->request_payload.payload_len;\n\n\tif (req_data_len != sizeof(struct ql_vnd_mng_host_stats_param)) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"req_data_len invalid.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treq_data = kzalloc(sizeof(*req_data), GFP_KERNEL);\n\tif (!req_data) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"req_data memory allocation failure.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\t  bsg_job->request_payload.sg_cnt, req_data,\n\t\t\t  req_data_len);\n\n\tswitch (req_data->action) {\n\tcase QLA_STOP:\n\t\tret = qla2xxx_stop_stats(vha->host, req_data->stat_type);\n\t\tbreak;\n\tcase QLA_START:\n\t\tret = qla2xxx_start_stats(vha->host, req_data->stat_type);\n\t\tbreak;\n\tcase QLA_CLEAR:\n\t\tret = qla2xxx_reset_stats(vha->host, req_data->stat_type);\n\t\tbreak;\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0x0000, \"Invalid action.\\n\");\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\tkfree(req_data);\n\n\t \n\trsp_data.status = ret;\n\tbsg_job->reply_payload.payload_len = sizeof(struct ql_vnd_mng_host_stats_resp);\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;\n\tbsg_reply->reply_payload_rcv_len =\n\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t    bsg_job->reply_payload.sg_cnt,\n\t\t\t\t    &rsp_data,\n\t\t\t\t    sizeof(struct ql_vnd_mng_host_stats_resp));\n\n\tbsg_reply->result = DID_OK;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\n\treturn ret;\n}\n\nstatic int\nqla2x00_get_host_stats(struct bsg_job *bsg_job)\n{\n\tscsi_qla_host_t *vha = shost_priv(fc_bsg_to_shost(bsg_job));\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct ql_vnd_stats_param *req_data;\n\tstruct ql_vnd_host_stats_resp rsp_data;\n\tu32 req_data_len;\n\tint ret = 0;\n\tu64 ini_entry_count = 0;\n\tu64 entry_count = 0;\n\tu64 tgt_num = 0;\n\tu64 tmp_stat_type = 0;\n\tu64 response_len = 0;\n\tvoid *data;\n\n\treq_data_len = bsg_job->request_payload.payload_len;\n\n\tif (req_data_len != sizeof(struct ql_vnd_stats_param)) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"req_data_len invalid.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treq_data = kzalloc(sizeof(*req_data), GFP_KERNEL);\n\tif (!req_data) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"req_data memory allocation failure.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\t  bsg_job->request_payload.sg_cnt, req_data, req_data_len);\n\n\t \n\ttmp_stat_type = req_data->stat_type;\n\n\tif (tmp_stat_type & QLA2XX_TGT_SHT_LNK_DOWN) {\n\t\t \n\t\ttgt_num = qla2x00_get_num_tgts(vha);\n\t\t \n\t\ttmp_stat_type &= ~(1 << 17);\n\t}\n\n\t \n\tini_entry_count = qla2x00_count_set_bits(tmp_stat_type);\n\n\t \n\tentry_count = ini_entry_count + tgt_num;\n\n\tresponse_len = sizeof(struct ql_vnd_host_stats_resp) +\n\t\t(sizeof(struct ql_vnd_stat_entry) * entry_count);\n\n\tif (response_len > bsg_job->reply_payload.payload_len) {\n\t\trsp_data.status = EXT_STATUS_BUFFER_TOO_SMALL;\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_BUFFER_TOO_SMALL;\n\t\tbsg_job->reply_payload.payload_len = sizeof(struct ql_vnd_mng_host_stats_resp);\n\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t    bsg_job->reply_payload.sg_cnt, &rsp_data,\n\t\t\t\t\t    sizeof(struct ql_vnd_mng_host_stats_resp));\n\n\t\tbsg_reply->result = DID_OK;\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\t\tgoto host_stat_out;\n\t}\n\n\tdata = kzalloc(response_len, GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto host_stat_out;\n\t}\n\n\tret = qla2xxx_get_ini_stats(fc_bsg_to_shost(bsg_job), req_data->stat_type,\n\t\t\t\t    data, response_len);\n\n\trsp_data.status = EXT_STATUS_OK;\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;\n\n\tbsg_reply->reply_payload_rcv_len = sg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t\t\t       bsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t\t\t       data, response_len);\n\tbsg_reply->result = DID_OK;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\n\tkfree(data);\nhost_stat_out:\n\tkfree(req_data);\n\treturn ret;\n}\n\nstatic struct fc_rport *\nqla2xxx_find_rport(scsi_qla_host_t *vha, uint32_t tgt_num)\n{\n\tfc_port_t *fcport = NULL;\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->rport->number == tgt_num)\n\t\t\treturn fcport->rport;\n\t}\n\treturn NULL;\n}\n\nstatic int\nqla2x00_get_tgt_stats(struct bsg_job *bsg_job)\n{\n\tscsi_qla_host_t *vha = shost_priv(fc_bsg_to_shost(bsg_job));\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct ql_vnd_tgt_stats_param *req_data;\n\tu32 req_data_len;\n\tint ret = 0;\n\tu64 response_len = 0;\n\tstruct ql_vnd_tgt_stats_resp *data = NULL;\n\tstruct fc_rport *rport = NULL;\n\n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"Host is not online.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treq_data_len = bsg_job->request_payload.payload_len;\n\n\tif (req_data_len != sizeof(struct ql_vnd_stat_entry)) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"req_data_len invalid.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treq_data = kzalloc(sizeof(*req_data), GFP_KERNEL);\n\tif (!req_data) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"req_data memory allocation failure.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\t  bsg_job->request_payload.sg_cnt,\n\t\t\t  req_data, req_data_len);\n\n\tresponse_len = sizeof(struct ql_vnd_tgt_stats_resp) +\n\t\tsizeof(struct ql_vnd_stat_entry);\n\n\t \n\tdata = kzalloc(response_len, GFP_KERNEL);\n\tif (!data) {\n\t\tkfree(req_data);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (response_len > bsg_job->reply_payload.payload_len) {\n\t\tdata->status = EXT_STATUS_BUFFER_TOO_SMALL;\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_BUFFER_TOO_SMALL;\n\t\tbsg_job->reply_payload.payload_len = sizeof(struct ql_vnd_mng_host_stats_resp);\n\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t    bsg_job->reply_payload.sg_cnt, data,\n\t\t\t\t\t    sizeof(struct ql_vnd_tgt_stats_resp));\n\n\t\tbsg_reply->result = DID_OK;\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\t\tgoto tgt_stat_out;\n\t}\n\n\trport = qla2xxx_find_rport(vha, req_data->tgt_id);\n\tif (!rport) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"target %d not found.\\n\", req_data->tgt_id);\n\t\tret = EXT_STATUS_INVALID_PARAM;\n\t\tdata->status = EXT_STATUS_INVALID_PARAM;\n\t\tgoto reply;\n\t}\n\n\tret = qla2xxx_get_tgt_stats(fc_bsg_to_shost(bsg_job), req_data->stat_type,\n\t\t\t\t    rport, (void *)data, response_len);\n\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;\nreply:\n\tbsg_reply->reply_payload_rcv_len =\n\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t    bsg_job->reply_payload.sg_cnt, data,\n\t\t\t\t    response_len);\n\tbsg_reply->result = DID_OK;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\ntgt_stat_out:\n\tkfree(data);\n\tkfree(req_data);\n\n\treturn ret;\n}\n\nstatic int\nqla2x00_manage_host_port(struct bsg_job *bsg_job)\n{\n\tscsi_qla_host_t *vha = shost_priv(fc_bsg_to_shost(bsg_job));\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct ql_vnd_mng_host_port_param *req_data;\n\tstruct ql_vnd_mng_host_port_resp rsp_data;\n\tu32 req_data_len;\n\tint ret = 0;\n\n\treq_data_len = bsg_job->request_payload.payload_len;\n\n\tif (req_data_len != sizeof(struct ql_vnd_mng_host_port_param)) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"req_data_len invalid.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treq_data = kzalloc(sizeof(*req_data), GFP_KERNEL);\n\tif (!req_data) {\n\t\tql_log(ql_log_warn, vha, 0x0000, \"req_data memory allocation failure.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\t  bsg_job->request_payload.sg_cnt, req_data, req_data_len);\n\n\tswitch (req_data->action) {\n\tcase QLA_ENABLE:\n\t\tret = qla2xxx_enable_port(vha->host);\n\t\tbreak;\n\tcase QLA_DISABLE:\n\t\tret = qla2xxx_disable_port(vha->host);\n\t\tbreak;\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0x0000, \"Invalid action.\\n\");\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\tkfree(req_data);\n\n\t \n\trsp_data.status = ret;\n\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;\n\tbsg_job->reply_payload.payload_len = sizeof(struct ql_vnd_mng_host_port_resp);\n\n\tbsg_reply->reply_payload_rcv_len =\n\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t    bsg_job->reply_payload.sg_cnt, &rsp_data,\n\t\t\t\t    sizeof(struct ql_vnd_mng_host_port_resp));\n\tbsg_reply->result = DID_OK;\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\n\treturn ret;\n}\n\nstatic int\nqla2x00_process_vendor_specific(struct scsi_qla_host *vha, struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\n\tql_dbg(ql_dbg_edif, vha, 0x911b, \"%s FC_BSG_HST_VENDOR cmd[0]=0x%x\\n\",\n\t    __func__, bsg_request->rqst_data.h_vendor.vendor_cmd[0]);\n\n\tswitch (bsg_request->rqst_data.h_vendor.vendor_cmd[0]) {\n\tcase QL_VND_LOOPBACK:\n\t\treturn qla2x00_process_loopback(bsg_job);\n\n\tcase QL_VND_A84_RESET:\n\t\treturn qla84xx_reset(bsg_job);\n\n\tcase QL_VND_A84_UPDATE_FW:\n\t\treturn qla84xx_updatefw(bsg_job);\n\n\tcase QL_VND_A84_MGMT_CMD:\n\t\treturn qla84xx_mgmt_cmd(bsg_job);\n\n\tcase QL_VND_IIDMA:\n\t\treturn qla24xx_iidma(bsg_job);\n\n\tcase QL_VND_FCP_PRIO_CFG_CMD:\n\t\treturn qla24xx_proc_fcp_prio_cfg_cmd(bsg_job);\n\n\tcase QL_VND_READ_FLASH:\n\t\treturn qla2x00_read_optrom(bsg_job);\n\n\tcase QL_VND_UPDATE_FLASH:\n\t\treturn qla2x00_update_optrom(bsg_job);\n\n\tcase QL_VND_SET_FRU_VERSION:\n\t\treturn qla2x00_update_fru_versions(bsg_job);\n\n\tcase QL_VND_READ_FRU_STATUS:\n\t\treturn qla2x00_read_fru_status(bsg_job);\n\n\tcase QL_VND_WRITE_FRU_STATUS:\n\t\treturn qla2x00_write_fru_status(bsg_job);\n\n\tcase QL_VND_WRITE_I2C:\n\t\treturn qla2x00_write_i2c(bsg_job);\n\n\tcase QL_VND_READ_I2C:\n\t\treturn qla2x00_read_i2c(bsg_job);\n\n\tcase QL_VND_DIAG_IO_CMD:\n\t\treturn qla24xx_process_bidir_cmd(bsg_job);\n\n\tcase QL_VND_FX00_MGMT_CMD:\n\t\treturn qlafx00_mgmt_cmd(bsg_job);\n\n\tcase QL_VND_SERDES_OP:\n\t\treturn qla26xx_serdes_op(bsg_job);\n\n\tcase QL_VND_SERDES_OP_EX:\n\t\treturn qla8044_serdes_op(bsg_job);\n\n\tcase QL_VND_GET_FLASH_UPDATE_CAPS:\n\t\treturn qla27xx_get_flash_upd_cap(bsg_job);\n\n\tcase QL_VND_SET_FLASH_UPDATE_CAPS:\n\t\treturn qla27xx_set_flash_upd_cap(bsg_job);\n\n\tcase QL_VND_GET_BBCR_DATA:\n\t\treturn qla27xx_get_bbcr_data(bsg_job);\n\n\tcase QL_VND_GET_PRIV_STATS:\n\tcase QL_VND_GET_PRIV_STATS_EX:\n\t\treturn qla2x00_get_priv_stats(bsg_job);\n\n\tcase QL_VND_DPORT_DIAGNOSTICS:\n\t\treturn qla2x00_do_dport_diagnostics(bsg_job);\n\n\tcase QL_VND_DPORT_DIAGNOSTICS_V2:\n\t\treturn qla2x00_do_dport_diagnostics_v2(bsg_job);\n\n\tcase QL_VND_EDIF_MGMT:\n\t\treturn qla_edif_app_mgmt(bsg_job);\n\n\tcase QL_VND_SS_GET_FLASH_IMAGE_STATUS:\n\t\treturn qla2x00_get_flash_image_status(bsg_job);\n\n\tcase QL_VND_MANAGE_HOST_STATS:\n\t\treturn qla2x00_manage_host_stats(bsg_job);\n\n\tcase QL_VND_GET_HOST_STATS:\n\t\treturn qla2x00_get_host_stats(bsg_job);\n\n\tcase QL_VND_GET_TGT_STATS:\n\t\treturn qla2x00_get_tgt_stats(bsg_job);\n\n\tcase QL_VND_MANAGE_HOST_PORT:\n\t\treturn qla2x00_manage_host_port(bsg_job);\n\n\tcase QL_VND_MBX_PASSTHRU:\n\t\treturn qla2x00_mailbox_passthru(bsg_job);\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\nint\nqla24xx_bsg_request(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tint ret = -EINVAL;\n\tstruct fc_rport *rport;\n\tstruct Scsi_Host *host;\n\tscsi_qla_host_t *vha;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (bsg_request->msgcode == FC_BSG_RPT_ELS) {\n\t\trport = fc_bsg_to_rport(bsg_job);\n\t\tif (!rport)\n\t\t\treturn ret;\n\t\thost = rport_to_shost(rport);\n\t\tvha = shost_priv(host);\n\t} else {\n\t\thost = fc_bsg_to_shost(bsg_job);\n\t\tvha = shost_priv(host);\n\t}\n\n\t \n\tif (bsg_request->rqst_data.h_vendor.vendor_cmd[0] == QL_VND_MANAGE_HOST_PORT ||\n\t    bsg_request->rqst_data.h_vendor.vendor_cmd[0] == QL_VND_GET_HOST_STATS)\n\t\tgoto skip_chip_chk;\n\n\tif (vha->hw->flags.port_isolated) {\n\t\tbsg_reply->result = DID_ERROR;\n\t\t \n\t\treturn -EPERM;\n\t}\n\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tql_dbg(ql_dbg_user, vha, 0x709f,\n\t\t    \"BSG: ISP abort active/needed -- cmd=%d.\\n\",\n\t\t    bsg_request->msgcode);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(PFLG_DRIVER_REMOVING, &vha->pci_flags)) {\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\treturn -EIO;\n\t}\n\nskip_chip_chk:\n\tql_dbg(ql_dbg_user + ql_dbg_verbose, vha, 0x7000,\n\t    \"Entered %s msgcode=0x%x. bsg ptr %px\\n\",\n\t    __func__, bsg_request->msgcode, bsg_job);\n\n\tswitch (bsg_request->msgcode) {\n\tcase FC_BSG_RPT_ELS:\n\tcase FC_BSG_HST_ELS_NOLOGIN:\n\t\tret = qla2x00_process_els(bsg_job);\n\t\tbreak;\n\tcase FC_BSG_HST_CT:\n\t\tret = qla2x00_process_ct(bsg_job);\n\t\tbreak;\n\tcase FC_BSG_HST_VENDOR:\n\t\tret = qla2x00_process_vendor_specific(vha, bsg_job);\n\t\tbreak;\n\tcase FC_BSG_HST_ADD_RPORT:\n\tcase FC_BSG_HST_DEL_RPORT:\n\tcase FC_BSG_RPT_CT:\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0x705a, \"Unsupported BSG request.\\n\");\n\t\tbreak;\n\t}\n\n\tql_dbg(ql_dbg_user + ql_dbg_verbose, vha, 0x7000,\n\t    \"%s done with return %x\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nint\nqla24xx_bsg_timeout(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tscsi_qla_host_t *vha = shost_priv(fc_bsg_to_shost(bsg_job));\n\tstruct qla_hw_data *ha = vha->hw;\n\tsrb_t *sp;\n\tint cnt, que;\n\tunsigned long flags;\n\tstruct req_que *req;\n\n\tql_log(ql_log_info, vha, 0x708b, \"%s CMD timeout. bsg ptr %p.\\n\",\n\t    __func__, bsg_job);\n\n\tif (qla2x00_isp_reg_stat(ha)) {\n\t\tql_log(ql_log_info, vha, 0x9007,\n\t\t    \"PCI/Register disconnect.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (que = 0; que < ha->max_req_queues; que++) {\n\t\treq = ha->req_q_map[que];\n\t\tif (!req)\n\t\t\tcontinue;\n\n\t\tfor (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {\n\t\t\tsp = req->outstanding_cmds[cnt];\n\t\t\tif (sp &&\n\t\t\t    (sp->type == SRB_CT_CMD ||\n\t\t\t     sp->type == SRB_ELS_CMD_HST ||\n\t\t\t     sp->type == SRB_ELS_CMD_HST_NOLOGIN ||\n\t\t\t     sp->type == SRB_FXIOCB_BCMD) &&\n\t\t\t    sp->u.bsg_job == bsg_job) {\n\t\t\t\treq->outstanding_cmds[cnt] = NULL;\n\t\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\t\t\tif (!ha->flags.eeh_busy && ha->isp_ops->abort_command(sp)) {\n\t\t\t\t\tql_log(ql_log_warn, vha, 0x7089,\n\t\t\t\t\t    \"mbx abort_command failed.\\n\");\n\t\t\t\t\tbsg_reply->result = -EIO;\n\t\t\t\t} else {\n\t\t\t\t\tql_dbg(ql_dbg_user, vha, 0x708a,\n\t\t\t\t\t    \"mbx abort_command success.\\n\");\n\t\t\t\t\tbsg_reply->result = 0;\n\t\t\t\t}\n\t\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\t\tgoto done;\n\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\tql_log(ql_log_info, vha, 0x708b, \"SRB not found to abort.\\n\");\n\tbsg_reply->result = -ENXIO;\n\treturn 0;\n\ndone:\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\treturn 0;\n}\n\nint qla2x00_mailbox_passthru(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tscsi_qla_host_t *vha = shost_priv(fc_bsg_to_shost(bsg_job));\n\tint ret = -EINVAL;\n\tint ptsize = sizeof(struct qla_mbx_passthru);\n\tstruct qla_mbx_passthru *req_data = NULL;\n\tuint32_t req_data_len;\n\n\treq_data_len = bsg_job->request_payload.payload_len;\n\tif (req_data_len != ptsize) {\n\t\tql_log(ql_log_warn, vha, 0xf0a3, \"req_data_len invalid.\\n\");\n\t\treturn -EIO;\n\t}\n\treq_data = kzalloc(ptsize, GFP_KERNEL);\n\tif (!req_data) {\n\t\tql_log(ql_log_warn, vha, 0xf0a4,\n\t\t       \"req_data memory allocation failure.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\t  bsg_job->request_payload.sg_cnt, req_data, ptsize);\n\tret = qla_mailbox_passthru(vha, req_data->mbx_in, req_data->mbx_out);\n\n\t \n\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t    bsg_job->reply_payload.sg_cnt, req_data, ptsize);\n\n\tbsg_reply->reply_payload_rcv_len = ptsize;\n\tif (ret == QLA_SUCCESS)\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_OK;\n\telse\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp[0] = EXT_STATUS_ERR;\n\n\tbsg_job->reply_len = sizeof(*bsg_job->reply);\n\tbsg_reply->result = DID_OK << 16;\n\tbsg_job_done(bsg_job, bsg_reply->result, bsg_reply->reply_payload_rcv_len);\n\n\tkfree(req_data);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}