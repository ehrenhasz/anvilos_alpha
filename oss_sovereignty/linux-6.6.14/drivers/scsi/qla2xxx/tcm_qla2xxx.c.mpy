{
  "module_name": "tcm_qla2xxx.c",
  "hash_id": "26fbe30f03b40d1b6d5d06edbe120e65f6389be42d55e6734c7e041bf7474d7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/tcm_qla2xxx.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/utsname.h>\n#include <linux/vmalloc.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi_host.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n\n#include \"qla_def.h\"\n#include \"qla_target.h\"\n#include \"tcm_qla2xxx.h\"\n\nstatic struct workqueue_struct *tcm_qla2xxx_free_wq;\n\n \nstatic ssize_t tcm_qla2xxx_parse_wwn(const char *name, u64 *wwn, int strict)\n{\n\tconst char *cp;\n\tchar c;\n\tu32 nibble;\n\tu32 byte = 0;\n\tu32 pos = 0;\n\tu32 err;\n\n\t*wwn = 0;\n\tfor (cp = name; cp < &name[TCM_QLA2XXX_NAMELEN - 1]; cp++) {\n\t\tc = *cp;\n\t\tif (c == '\\n' && cp[1] == '\\0')\n\t\t\tcontinue;\n\t\tif (strict && pos++ == 2 && byte++ < 7) {\n\t\t\tpos = 0;\n\t\t\tif (c == ':')\n\t\t\t\tcontinue;\n\t\t\terr = 1;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (c == '\\0') {\n\t\t\terr = 2;\n\t\t\tif (strict && byte != 8)\n\t\t\t\tgoto fail;\n\t\t\treturn cp - name;\n\t\t}\n\t\terr = 3;\n\t\tif (isdigit(c))\n\t\t\tnibble = c - '0';\n\t\telse if (isxdigit(c) && (islower(c) || !strict))\n\t\t\tnibble = tolower(c) - 'a' + 10;\n\t\telse\n\t\t\tgoto fail;\n\t\t*wwn = (*wwn << 4) | nibble;\n\t}\n\terr = 4;\nfail:\n\tpr_debug(\"err %u len %zu pos %u byte %u\\n\",\n\t\t\terr, cp - name, pos, byte);\n\treturn -1;\n}\n\nstatic ssize_t tcm_qla2xxx_format_wwn(char *buf, size_t len, u64 wwn)\n{\n\tu8 b[8];\n\n\tput_unaligned_be64(wwn, b);\n\treturn snprintf(buf, len,\n\t\t\"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\",\n\t\tb[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n}\n\n \nstatic int tcm_qla2xxx_npiv_extract_wwn(const char *ns, u64 *nm)\n{\n\tunsigned int i, j;\n\tu8 wwn[8];\n\n\tmemset(wwn, 0, sizeof(wwn));\n\n\t \n\tfor (i = 0, j = 0; i < 16; i++) {\n\t\tint value;\n\n\t\tvalue = hex_to_bin(*ns++);\n\t\tif (value >= 0)\n\t\t\tj = (j << 4) | value;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (i % 2) {\n\t\t\twwn[i/2] = j & 0xff;\n\t\t\tj = 0;\n\t\t}\n\t}\n\n\t*nm = wwn_to_u64(wwn);\n\treturn 0;\n}\n\n \nstatic int tcm_qla2xxx_npiv_parse_wwn(\n\tconst char *name,\n\tsize_t count,\n\tu64 *wwpn,\n\tu64 *wwnn)\n{\n\tunsigned int cnt = count;\n\tint rc;\n\n\t*wwpn = 0;\n\t*wwnn = 0;\n\n\t \n\tif (name[cnt-1] == '\\n' || name[cnt-1] == 0)\n\t\tcnt--;\n\n\t \n\tif ((cnt != (16+1+16)) || (name[16] != ':'))\n\t\treturn -EINVAL;\n\n\trc = tcm_qla2xxx_npiv_extract_wwn(&name[0], wwpn);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = tcm_qla2xxx_npiv_extract_wwn(&name[17], wwnn);\n\tif (rc != 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic char *tcm_qla2xxx_get_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\tstruct tcm_qla2xxx_lport *lport = tpg->lport;\n\n\treturn lport->lport_naa_name;\n}\n\nstatic u16 tcm_qla2xxx_get_tag(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\treturn tpg->lport_tpgt;\n}\n\nstatic int tcm_qla2xxx_check_demo_mode(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\treturn tpg->tpg_attrib.generate_node_acls;\n}\n\nstatic int tcm_qla2xxx_check_demo_mode_cache(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\treturn tpg->tpg_attrib.cache_dynamic_acls;\n}\n\nstatic int tcm_qla2xxx_check_demo_write_protect(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\treturn tpg->tpg_attrib.demo_mode_write_protect;\n}\n\nstatic int tcm_qla2xxx_check_prod_write_protect(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\treturn tpg->tpg_attrib.prod_mode_write_protect;\n}\n\nstatic int tcm_qla2xxx_check_demo_mode_login_only(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\treturn tpg->tpg_attrib.demo_mode_login_only;\n}\n\nstatic int tcm_qla2xxx_check_prot_fabric_only(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\treturn tpg->tpg_attrib.fabric_prot_type;\n}\n\nstatic u32 tcm_qla2xxx_tpg_get_inst_index(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\treturn tpg->lport_tpgt;\n}\n\nstatic void tcm_qla2xxx_complete_mcmd(struct work_struct *work)\n{\n\tstruct qla_tgt_mgmt_cmd *mcmd = container_of(work,\n\t\t\tstruct qla_tgt_mgmt_cmd, free_work);\n\n\ttransport_generic_free_cmd(&mcmd->se_cmd, 0);\n}\n\n \nstatic void tcm_qla2xxx_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd)\n{\n\tif (!mcmd)\n\t\treturn;\n\tINIT_WORK(&mcmd->free_work, tcm_qla2xxx_complete_mcmd);\n\tqueue_work(tcm_qla2xxx_free_wq, &mcmd->free_work);\n}\n\nstatic void tcm_qla2xxx_complete_free(struct work_struct *work)\n{\n\tstruct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);\n\tunsigned long flags;\n\n\tcmd->cmd_in_wq = 0;\n\n\tWARN_ON(cmd->trc_flags & TRC_CMD_FREE);\n\n\t \n\tcmd->qpair->tgt_counters.qla_core_ret_sta_ctio++;\n\tcmd->trc_flags |= TRC_CMD_FREE;\n\tcmd->cmd_sent_to_fw = 0;\n\n\tspin_lock_irqsave(&cmd->sess->sess_cmd_lock, flags);\n\tlist_del_init(&cmd->sess_cmd_list);\n\tspin_unlock_irqrestore(&cmd->sess->sess_cmd_lock, flags);\n\n\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n}\n\nstatic struct qla_tgt_cmd *tcm_qla2xxx_get_cmd(struct fc_port *sess)\n{\n\tstruct se_session *se_sess = sess->se_sess;\n\tstruct qla_tgt_cmd *cmd;\n\tint tag, cpu;\n\n\ttag = sbitmap_queue_get(&se_sess->sess_tag_pool, &cpu);\n\tif (tag < 0)\n\t\treturn NULL;\n\n\tcmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];\n\tmemset(cmd, 0, sizeof(struct qla_tgt_cmd));\n\tcmd->se_cmd.map_tag = tag;\n\tcmd->se_cmd.map_cpu = cpu;\n\n\treturn cmd;\n}\n\nstatic void tcm_qla2xxx_rel_cmd(struct qla_tgt_cmd *cmd)\n{\n\ttarget_free_tag(cmd->sess->se_sess, &cmd->se_cmd);\n}\n\n \nstatic void tcm_qla2xxx_free_cmd(struct qla_tgt_cmd *cmd)\n{\n\tcmd->qpair->tgt_counters.core_qla_free_cmd++;\n\tcmd->cmd_in_wq = 1;\n\n\tWARN_ON(cmd->trc_flags & TRC_CMD_DONE);\n\tcmd->trc_flags |= TRC_CMD_DONE;\n\n\tINIT_WORK(&cmd->work, tcm_qla2xxx_complete_free);\n\tqueue_work(tcm_qla2xxx_free_wq, &cmd->work);\n}\n\n \nstatic int tcm_qla2xxx_check_stop_free(struct se_cmd *se_cmd)\n{\n\tstruct qla_tgt_cmd *cmd;\n\n\tif ((se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) == 0) {\n\t\tcmd = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);\n\t\tcmd->trc_flags |= TRC_CMD_CHK_STOP;\n\t}\n\n\treturn target_put_sess_cmd(se_cmd);\n}\n\n \nstatic void tcm_qla2xxx_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct qla_tgt_cmd *cmd;\n\n\tif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) {\n\t\tstruct qla_tgt_mgmt_cmd *mcmd = container_of(se_cmd,\n\t\t\t\tstruct qla_tgt_mgmt_cmd, se_cmd);\n\t\tqlt_free_mcmd(mcmd);\n\t\treturn;\n\t}\n\tcmd = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);\n\n\tif (WARN_ON(cmd->cmd_sent_to_fw))\n\t\treturn;\n\n\tqlt_free_cmd(cmd);\n}\n\nstatic void tcm_qla2xxx_release_session(struct kref *kref)\n{\n\tstruct fc_port  *sess = container_of(kref,\n\t    struct fc_port, sess_kref);\n\n\tqlt_unreg_sess(sess);\n}\n\nstatic void tcm_qla2xxx_put_sess(struct fc_port *sess)\n{\n\tif (!sess)\n\t\treturn;\n\n\tkref_put(&sess->sess_kref, tcm_qla2xxx_release_session);\n}\n\nstatic void tcm_qla2xxx_close_session(struct se_session *se_sess)\n{\n\tstruct fc_port *sess = se_sess->fabric_sess_ptr;\n\n\tBUG_ON(!sess);\n\n\ttarget_stop_session(se_sess);\n\n\tsess->explicit_logout = 1;\n\ttcm_qla2xxx_put_sess(sess);\n}\n\nstatic int tcm_qla2xxx_write_pending(struct se_cmd *se_cmd)\n{\n\tstruct qla_tgt_cmd *cmd = container_of(se_cmd,\n\t\t\t\tstruct qla_tgt_cmd, se_cmd);\n\n\tif (cmd->aborted) {\n\t\t \n\t\tpr_debug(\"write_pending aborted cmd[%p] refcount %d \"\n\t\t\t\"transport_state %x, t_state %x, se_cmd_flags %x\\n\",\n\t\t\tcmd, kref_read(&cmd->se_cmd.cmd_kref),\n\t\t\tcmd->se_cmd.transport_state,\n\t\t\tcmd->se_cmd.t_state,\n\t\t\tcmd->se_cmd.se_cmd_flags);\n\t\ttransport_generic_request_failure(&cmd->se_cmd,\n\t\t\tTCM_CHECK_CONDITION_ABORT_CMD);\n\t\treturn 0;\n\t}\n\tcmd->trc_flags |= TRC_XFR_RDY;\n\tcmd->bufflen = se_cmd->data_length;\n\tcmd->dma_data_direction = target_reverse_dma_direction(se_cmd);\n\n\tcmd->sg_cnt = se_cmd->t_data_nents;\n\tcmd->sg = se_cmd->t_data_sg;\n\n\tcmd->prot_sg_cnt = se_cmd->t_prot_nents;\n\tcmd->prot_sg = se_cmd->t_prot_sg;\n\tcmd->blk_sz  = se_cmd->se_dev->dev_attrib.block_size;\n\tse_cmd->pi_err = 0;\n\n\t \n\treturn qlt_rdy_to_xfer(cmd);\n}\n\nstatic int tcm_qla2xxx_get_cmd_state(struct se_cmd *se_cmd)\n{\n\tif (!(se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {\n\t\tstruct qla_tgt_cmd *cmd = container_of(se_cmd,\n\t\t\t\tstruct qla_tgt_cmd, se_cmd);\n\t\treturn cmd->state;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tcm_qla2xxx_handle_cmd(scsi_qla_host_t *vha, struct qla_tgt_cmd *cmd,\n\tunsigned char *cdb, uint32_t data_length, int fcp_task_attr,\n\tint data_dir, int bidi)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct se_session *se_sess;\n\tstruct fc_port *sess;\n#ifdef CONFIG_TCM_QLA2XXX_DEBUG\n\tstruct se_portal_group *se_tpg;\n\tstruct tcm_qla2xxx_tpg *tpg;\n#endif\n\tint rc, target_flags = TARGET_SCF_ACK_KREF;\n\tunsigned long flags;\n\n\tif (bidi)\n\t\ttarget_flags |= TARGET_SCF_BIDI_OP;\n\n\tif (se_cmd->cpuid != WORK_CPU_UNBOUND)\n\t\ttarget_flags |= TARGET_SCF_USE_CPUID;\n\n\tsess = cmd->sess;\n\tif (!sess) {\n\t\tpr_err(\"Unable to locate struct fc_port from qla_tgt_cmd\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tse_sess = sess->se_sess;\n\tif (!se_sess) {\n\t\tpr_err(\"Unable to locate active struct se_session\\n\");\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_TCM_QLA2XXX_DEBUG\n\tse_tpg = se_sess->se_tpg;\n\ttpg = container_of(se_tpg, struct tcm_qla2xxx_tpg, se_tpg);\n\tif (unlikely(tpg->tpg_attrib.jam_host)) {\n\t\t \n\t\treturn 0;\n\t}\n#endif\n\tcmd->qpair->tgt_counters.qla_core_sbt_cmd++;\n\n\tspin_lock_irqsave(&sess->sess_cmd_lock, flags);\n\tlist_add_tail(&cmd->sess_cmd_list, &sess->sess_cmd_list);\n\tspin_unlock_irqrestore(&sess->sess_cmd_lock, flags);\n\n\trc = target_init_cmd(se_cmd, se_sess, &cmd->sense_buffer[0],\n\t\t\t     cmd->unpacked_lun, data_length, fcp_task_attr,\n\t\t\t     data_dir, target_flags);\n\tif (rc)\n\t\treturn rc;\n\n\tif (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,\n\t\t\t       GFP_KERNEL))\n\t\treturn 0;\n\n\ttarget_submit(se_cmd);\n\treturn 0;\n}\n\nstatic void tcm_qla2xxx_handle_data_work(struct work_struct *work)\n{\n\tstruct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);\n\n\t \n\tcmd->cmd_in_wq = 0;\n\tcmd->cmd_sent_to_fw = 0;\n\tif (cmd->aborted) {\n\t\ttransport_generic_request_failure(&cmd->se_cmd,\n\t\t\tTCM_CHECK_CONDITION_ABORT_CMD);\n\t\treturn;\n\t}\n\n\tcmd->qpair->tgt_counters.qla_core_ret_ctio++;\n\tif (!cmd->write_data_transferred) {\n\t\tswitch (cmd->dif_err_code) {\n\t\tcase DIF_ERR_GRD:\n\t\t\tcmd->se_cmd.pi_err =\n\t\t\t    TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;\n\t\t\tbreak;\n\t\tcase DIF_ERR_REF:\n\t\t\tcmd->se_cmd.pi_err =\n\t\t\t    TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;\n\t\t\tbreak;\n\t\tcase DIF_ERR_APP:\n\t\t\tcmd->se_cmd.pi_err =\n\t\t\t    TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;\n\t\t\tbreak;\n\t\tcase DIF_ERR_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->se_cmd.pi_err)\n\t\t\ttransport_generic_request_failure(&cmd->se_cmd,\n\t\t\t\tcmd->se_cmd.pi_err);\n\t\telse\n\t\t\ttransport_generic_request_failure(&cmd->se_cmd,\n\t\t\t\tTCM_CHECK_CONDITION_ABORT_CMD);\n\n\t\treturn;\n\t}\n\n\treturn target_execute_cmd(&cmd->se_cmd);\n}\n\n \nstatic void tcm_qla2xxx_handle_data(struct qla_tgt_cmd *cmd)\n{\n\tcmd->trc_flags |= TRC_DATA_IN;\n\tcmd->cmd_in_wq = 1;\n\tINIT_WORK(&cmd->work, tcm_qla2xxx_handle_data_work);\n\tqueue_work(tcm_qla2xxx_free_wq, &cmd->work);\n}\n\nstatic int tcm_qla2xxx_chk_dif_tags(uint32_t tag)\n{\n\treturn 0;\n}\n\nstatic int tcm_qla2xxx_dif_tags(struct qla_tgt_cmd *cmd,\n    uint16_t *pfw_prot_opts)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\n\tif (!(se_cmd->prot_checks & TARGET_DIF_CHECK_GUARD))\n\t\t*pfw_prot_opts |= PO_DISABLE_GUARD_CHECK;\n\n\tif (!(se_cmd->prot_checks & TARGET_DIF_CHECK_APPTAG))\n\t\t*pfw_prot_opts |= PO_DIS_APP_TAG_VALD;\n\n\treturn 0;\n}\n\n \nstatic int tcm_qla2xxx_handle_tmr(struct qla_tgt_mgmt_cmd *mcmd, u64 lun,\n\tuint16_t tmr_func, uint32_t tag)\n{\n\tstruct fc_port *sess = mcmd->sess;\n\tstruct se_cmd *se_cmd = &mcmd->se_cmd;\n\tint transl_tmr_func = 0;\n\n\tswitch (tmr_func) {\n\tcase QLA_TGT_ABTS:\n\t\tpr_debug(\"%ld: ABTS received\\n\", sess->vha->host_no);\n\t\ttransl_tmr_func = TMR_ABORT_TASK;\n\t\tbreak;\n\tcase QLA_TGT_2G_ABORT_TASK:\n\t\tpr_debug(\"%ld: 2G Abort Task received\\n\", sess->vha->host_no);\n\t\ttransl_tmr_func = TMR_ABORT_TASK;\n\t\tbreak;\n\tcase QLA_TGT_CLEAR_ACA:\n\t\tpr_debug(\"%ld: CLEAR_ACA received\\n\", sess->vha->host_no);\n\t\ttransl_tmr_func = TMR_CLEAR_ACA;\n\t\tbreak;\n\tcase QLA_TGT_TARGET_RESET:\n\t\tpr_debug(\"%ld: TARGET_RESET received\\n\", sess->vha->host_no);\n\t\ttransl_tmr_func = TMR_TARGET_WARM_RESET;\n\t\tbreak;\n\tcase QLA_TGT_LUN_RESET:\n\t\tpr_debug(\"%ld: LUN_RESET received\\n\", sess->vha->host_no);\n\t\ttransl_tmr_func = TMR_LUN_RESET;\n\t\tbreak;\n\tcase QLA_TGT_CLEAR_TS:\n\t\tpr_debug(\"%ld: CLEAR_TS received\\n\", sess->vha->host_no);\n\t\ttransl_tmr_func = TMR_CLEAR_TASK_SET;\n\t\tbreak;\n\tcase QLA_TGT_ABORT_TS:\n\t\tpr_debug(\"%ld: ABORT_TS received\\n\", sess->vha->host_no);\n\t\ttransl_tmr_func = TMR_ABORT_TASK_SET;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"%ld: Unknown task mgmt fn 0x%x\\n\",\n\t\t    sess->vha->host_no, tmr_func);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn target_submit_tmr(se_cmd, sess->se_sess, NULL, lun, mcmd,\n\t    transl_tmr_func, GFP_ATOMIC, tag, TARGET_SCF_ACK_KREF);\n}\n\nstatic struct qla_tgt_cmd *tcm_qla2xxx_find_cmd_by_tag(struct fc_port *sess,\n    uint64_t tag)\n{\n\tstruct qla_tgt_cmd *cmd;\n\tunsigned long flags;\n\n\tif (!sess->se_sess)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&sess->sess_cmd_lock, flags);\n\tlist_for_each_entry(cmd, &sess->sess_cmd_list, sess_cmd_list) {\n\t\tif (cmd->se_cmd.tag == tag)\n\t\t\tgoto done;\n\t}\n\tcmd = NULL;\ndone:\n\tspin_unlock_irqrestore(&sess->sess_cmd_lock, flags);\n\n\treturn cmd;\n}\n\nstatic int tcm_qla2xxx_queue_data_in(struct se_cmd *se_cmd)\n{\n\tstruct qla_tgt_cmd *cmd = container_of(se_cmd,\n\t\t\t\tstruct qla_tgt_cmd, se_cmd);\n\n\tif (cmd->aborted) {\n\t\t \n\t\tpr_debug(\"queue_data_in aborted cmd[%p] refcount %d \"\n\t\t\t\"transport_state %x, t_state %x, se_cmd_flags %x\\n\",\n\t\t\tcmd, kref_read(&cmd->se_cmd.cmd_kref),\n\t\t\tcmd->se_cmd.transport_state,\n\t\t\tcmd->se_cmd.t_state,\n\t\t\tcmd->se_cmd.se_cmd_flags);\n\t\treturn 0;\n\t}\n\n\tcmd->trc_flags |= TRC_XMIT_DATA;\n\tcmd->bufflen = se_cmd->data_length;\n\tcmd->dma_data_direction = target_reverse_dma_direction(se_cmd);\n\n\tcmd->sg_cnt = se_cmd->t_data_nents;\n\tcmd->sg = se_cmd->t_data_sg;\n\tcmd->offset = 0;\n\n\tcmd->prot_sg_cnt = se_cmd->t_prot_nents;\n\tcmd->prot_sg = se_cmd->t_prot_sg;\n\tcmd->blk_sz  = se_cmd->se_dev->dev_attrib.block_size;\n\tse_cmd->pi_err = 0;\n\n\t \n\treturn qlt_xmit_response(cmd, QLA_TGT_XMIT_DATA|QLA_TGT_XMIT_STATUS,\n\t\t\t\tse_cmd->scsi_status);\n}\n\nstatic int tcm_qla2xxx_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct qla_tgt_cmd *cmd = container_of(se_cmd,\n\t\t\t\tstruct qla_tgt_cmd, se_cmd);\n\tint xmit_type = QLA_TGT_XMIT_STATUS;\n\n\tif (cmd->aborted) {\n\t\t \n\t\tpr_debug(\n\t\t    \"queue_data_in aborted cmd[%p] refcount %d transport_state %x, t_state %x, se_cmd_flags %x\\n\",\n\t\t    cmd, kref_read(&cmd->se_cmd.cmd_kref),\n\t\t    cmd->se_cmd.transport_state, cmd->se_cmd.t_state,\n\t\t    cmd->se_cmd.se_cmd_flags);\n\t\treturn 0;\n\t}\n\tcmd->bufflen = se_cmd->data_length;\n\tcmd->sg = NULL;\n\tcmd->sg_cnt = 0;\n\tcmd->offset = 0;\n\tcmd->dma_data_direction = target_reverse_dma_direction(se_cmd);\n\tcmd->trc_flags |= TRC_XMIT_STATUS;\n\n\tif (se_cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t \n\t\tif (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\t\tse_cmd->se_cmd_flags &= ~SCF_OVERFLOW_BIT;\n\t\t\tse_cmd->residual_count = 0;\n\t\t}\n\t\tse_cmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;\n\t\tse_cmd->residual_count += se_cmd->data_length;\n\n\t\tcmd->bufflen = 0;\n\t}\n\t \n\treturn qlt_xmit_response(cmd, xmit_type, se_cmd->scsi_status);\n}\n\nstatic void tcm_qla2xxx_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n\tstruct se_tmr_req *se_tmr = se_cmd->se_tmr_req;\n\tstruct qla_tgt_mgmt_cmd *mcmd = container_of(se_cmd,\n\t\t\t\tstruct qla_tgt_mgmt_cmd, se_cmd);\n\n\tpr_debug(\"queue_tm_rsp: mcmd: %p func: 0x%02x response: 0x%02x\\n\",\n\t\t\tmcmd, se_tmr->function, se_tmr->response);\n\t \n\tswitch (se_tmr->response) {\n\tcase TMR_FUNCTION_COMPLETE:\n\t\tmcmd->fc_tm_rsp = FC_TM_SUCCESS;\n\t\tbreak;\n\tcase TMR_TASK_DOES_NOT_EXIST:\n\t\tmcmd->fc_tm_rsp = FC_TM_BAD_CMD;\n\t\tbreak;\n\tcase TMR_FUNCTION_REJECTED:\n\t\tmcmd->fc_tm_rsp = FC_TM_REJECT;\n\t\tbreak;\n\tcase TMR_LUN_DOES_NOT_EXIST:\n\tdefault:\n\t\tmcmd->fc_tm_rsp = FC_TM_FAILED;\n\t\tbreak;\n\t}\n\t \n\tqlt_xmit_tm_rsp(mcmd);\n}\n\nstatic void tcm_qla2xxx_aborted_task(struct se_cmd *se_cmd)\n{\n\tstruct qla_tgt_cmd *cmd;\n\tunsigned long flags;\n\n\tif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\n\t\treturn;\n\n\tcmd  = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);\n\n\tspin_lock_irqsave(&cmd->sess->sess_cmd_lock, flags);\n\tlist_del_init(&cmd->sess_cmd_list);\n\tspin_unlock_irqrestore(&cmd->sess->sess_cmd_lock, flags);\n\n\tqlt_abort_cmd(cmd);\n}\n\nstatic void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *,\n\t\t\tstruct tcm_qla2xxx_nacl *, struct fc_port *);\n \nstatic void tcm_qla2xxx_clear_nacl_from_fcport_map(struct fc_port *sess)\n{\n\tstruct se_node_acl *se_nacl = sess->se_sess->se_node_acl;\n\tstruct se_portal_group *se_tpg = se_nacl->se_tpg;\n\tstruct se_wwn *se_wwn = se_tpg->se_tpg_wwn;\n\tstruct tcm_qla2xxx_lport *lport = container_of(se_wwn,\n\t\t\t\tstruct tcm_qla2xxx_lport, lport_wwn);\n\tstruct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,\n\t\t\t\tstruct tcm_qla2xxx_nacl, se_node_acl);\n\tvoid *node;\n\n\tpr_debug(\"fc_rport domain: port_id 0x%06x\\n\", nacl->nport_id);\n\n\tnode = btree_remove32(&lport->lport_fcport_map, nacl->nport_id);\n\tif (WARN_ON(node && (node != se_nacl))) {\n\t\t \n\t\tbtree_insert32(&lport->lport_fcport_map, nacl->nport_id,\n\t\t\t       node, GFP_ATOMIC);\n\t}\n\n\tpr_debug(\"Removed from fcport_map: %p for WWNN: 0x%016LX, port_id: 0x%06x\\n\",\n\t    se_nacl, nacl->nport_wwnn, nacl->nport_id);\n\t \n\ttcm_qla2xxx_clear_sess_lookup(lport, nacl, sess);\n}\n\nstatic void tcm_qla2xxx_shutdown_sess(struct fc_port *sess)\n{\n\ttarget_stop_session(sess->se_sess);\n}\n\nstatic int tcm_qla2xxx_init_nodeacl(struct se_node_acl *se_nacl,\n\t\tconst char *name)\n{\n\tstruct tcm_qla2xxx_nacl *nacl =\n\t\tcontainer_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);\n\tu64 wwnn;\n\n\tif (tcm_qla2xxx_parse_wwn(name, &wwnn, 1) < 0)\n\t\treturn -EINVAL;\n\n\tnacl->nport_wwnn = wwnn;\n\ttcm_qla2xxx_format_wwn(&nacl->nport_name[0], TCM_QLA2XXX_NAMELEN, wwnn);\n\n\treturn 0;\n}\n\n \n\n#define DEF_QLA_TPG_ATTRIB(name)\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t tcm_qla2xxx_tpg_attrib_##name##_show(\t\t\t\\\n\t\tstruct config_item *item, char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\t\t\\\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\t\t\\\n\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(page, \"%d\\n\", tpg->tpg_attrib.name);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t tcm_qla2xxx_tpg_attrib_##name##_store(\t\t\t\\\n\t\tstruct config_item *item, const char *page, size_t count) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\t\t\\\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\t\t\\\n\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\t\t\\\n\tstruct tcm_qla2xxx_tpg_attrib *a = &tpg->tpg_attrib;\t\t\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtoul(page, 0, &val);\t\t\t\t\t\\\n\tif (ret < 0) {\t\t\t\t\t\t\t\\\n\t\tpr_err(\"kstrtoul() failed with\"\t\t\t\t\\\n\t\t\t\t\" ret: %d\\n\", ret);\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif ((val != 0) && (val != 1)) {\t\t\t\t\t\\\n\t\tpr_err(\"Illegal boolean value %lu\\n\", val);\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ta->name = val;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(tcm_qla2xxx_tpg_attrib_, name)\n\nDEF_QLA_TPG_ATTRIB(generate_node_acls);\nDEF_QLA_TPG_ATTRIB(cache_dynamic_acls);\nDEF_QLA_TPG_ATTRIB(demo_mode_write_protect);\nDEF_QLA_TPG_ATTRIB(prod_mode_write_protect);\nDEF_QLA_TPG_ATTRIB(demo_mode_login_only);\n#ifdef CONFIG_TCM_QLA2XXX_DEBUG\nDEF_QLA_TPG_ATTRIB(jam_host);\n#endif\n\nstatic struct configfs_attribute *tcm_qla2xxx_tpg_attrib_attrs[] = {\n\t&tcm_qla2xxx_tpg_attrib_attr_generate_node_acls,\n\t&tcm_qla2xxx_tpg_attrib_attr_cache_dynamic_acls,\n\t&tcm_qla2xxx_tpg_attrib_attr_demo_mode_write_protect,\n\t&tcm_qla2xxx_tpg_attrib_attr_prod_mode_write_protect,\n\t&tcm_qla2xxx_tpg_attrib_attr_demo_mode_login_only,\n#ifdef CONFIG_TCM_QLA2XXX_DEBUG\n\t&tcm_qla2xxx_tpg_attrib_attr_jam_host,\n#endif\n\tNULL,\n};\n\n \n\nstatic int tcm_qla2xxx_enable_tpg(struct se_portal_group *se_tpg,\n\t\t\t\t  bool enable)\n{\n\tstruct se_wwn *se_wwn = se_tpg->se_tpg_wwn;\n\tstruct tcm_qla2xxx_lport *lport = container_of(se_wwn,\n\t\t\tstruct tcm_qla2xxx_lport, lport_wwn);\n\tstruct scsi_qla_host *vha = lport->qla_vha;\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\tif (enable) {\n\t\tif (atomic_read(&tpg->lport_tpg_enabled))\n\t\t\treturn -EEXIST;\n\n\t\tatomic_set(&tpg->lport_tpg_enabled, 1);\n\t\tqlt_enable_vha(vha);\n\t} else {\n\t\tif (!atomic_read(&tpg->lport_tpg_enabled))\n\t\t\treturn 0;\n\n\t\tatomic_set(&tpg->lport_tpg_enabled, 0);\n\t\tqlt_stop_phase1(vha->vha_tgt.qla_tgt);\n\t\tqlt_stop_phase2(vha->vha_tgt.qla_tgt);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t tcm_qla2xxx_tpg_dynamic_sessions_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn target_show_dynamic_sessions(to_tpg(item), page);\n}\n\nstatic ssize_t tcm_qla2xxx_tpg_fabric_prot_type_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\tunsigned long val;\n\tint ret = kstrtoul(page, 0, &val);\n\n\tif (ret) {\n\t\tpr_err(\"kstrtoul() returned %d for fabric_prot_type\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (val != 0 && val != 1 && val != 3) {\n\t\tpr_err(\"Invalid qla2xxx fabric_prot_type: %lu\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\ttpg->tpg_attrib.fabric_prot_type = val;\n\n\treturn count;\n}\n\nstatic ssize_t tcm_qla2xxx_tpg_fabric_prot_type_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\treturn sprintf(page, \"%d\\n\", tpg->tpg_attrib.fabric_prot_type);\n}\n\nCONFIGFS_ATTR_RO(tcm_qla2xxx_tpg_, dynamic_sessions);\nCONFIGFS_ATTR(tcm_qla2xxx_tpg_, fabric_prot_type);\n\nstatic struct configfs_attribute *tcm_qla2xxx_tpg_attrs[] = {\n\t&tcm_qla2xxx_tpg_attr_dynamic_sessions,\n\t&tcm_qla2xxx_tpg_attr_fabric_prot_type,\n\tNULL,\n};\n\nstatic struct se_portal_group *tcm_qla2xxx_make_tpg(struct se_wwn *wwn,\n\t\t\t\t\t\t    const char *name)\n{\n\tstruct tcm_qla2xxx_lport *lport = container_of(wwn,\n\t\t\tstruct tcm_qla2xxx_lport, lport_wwn);\n\tstruct tcm_qla2xxx_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((tpgt != 1)) {\n\t\tpr_err(\"In non NPIV mode, a single TPG=1 is used for HW port mappings\\n\");\n\t\treturn ERR_PTR(-ENOSYS);\n\t}\n\n\ttpg = kzalloc(sizeof(struct tcm_qla2xxx_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct tcm_qla2xxx_tpg\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\ttpg->lport = lport;\n\ttpg->lport_tpgt = tpgt;\n\t \n\ttpg->tpg_attrib.generate_node_acls = 1;\n\ttpg->tpg_attrib.demo_mode_write_protect = 1;\n\ttpg->tpg_attrib.cache_dynamic_acls = 1;\n\ttpg->tpg_attrib.demo_mode_login_only = 1;\n\ttpg->tpg_attrib.jam_host = 0;\n\n\tret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\n\tlport->tpg_1 = tpg;\n\n\treturn &tpg->se_tpg;\n}\n\nstatic void tcm_qla2xxx_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\tstruct tcm_qla2xxx_lport *lport = tpg->lport;\n\tstruct scsi_qla_host *vha = lport->qla_vha;\n\t \n\tif (vha->vha_tgt.qla_tgt && !vha->vha_tgt.qla_tgt->tgt_stop)\n\t\tqlt_stop_phase1(vha->vha_tgt.qla_tgt);\n\n\tcore_tpg_deregister(se_tpg);\n\t \n\tlport->tpg_1 = NULL;\n\tkfree(tpg);\n}\n\nstatic int tcm_qla2xxx_npiv_enable_tpg(struct se_portal_group *se_tpg,\n\t\t\t\t    bool enable)\n{\n\tstruct se_wwn *se_wwn = se_tpg->se_tpg_wwn;\n\tstruct tcm_qla2xxx_lport *lport = container_of(se_wwn,\n\t\t\tstruct tcm_qla2xxx_lport, lport_wwn);\n\tstruct scsi_qla_host *vha = lport->qla_vha;\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\n\tif (enable) {\n\t\tif (atomic_read(&tpg->lport_tpg_enabled))\n\t\t\treturn -EEXIST;\n\n\t\tatomic_set(&tpg->lport_tpg_enabled, 1);\n\t\tqlt_enable_vha(vha);\n\t} else {\n\t\tif (!atomic_read(&tpg->lport_tpg_enabled))\n\t\t\treturn 0;\n\n\t\tatomic_set(&tpg->lport_tpg_enabled, 0);\n\t\tqlt_stop_phase1(vha->vha_tgt.qla_tgt);\n\t\tqlt_stop_phase2(vha->vha_tgt.qla_tgt);\n\t}\n\n\treturn 0;\n}\n\nstatic struct se_portal_group *tcm_qla2xxx_npiv_make_tpg(struct se_wwn *wwn,\n\t\t\t\t\t\t\t const char *name)\n{\n\tstruct tcm_qla2xxx_lport *lport = container_of(wwn,\n\t\t\tstruct tcm_qla2xxx_lport, lport_wwn);\n\tstruct tcm_qla2xxx_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(struct tcm_qla2xxx_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct tcm_qla2xxx_tpg\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\ttpg->lport = lport;\n\ttpg->lport_tpgt = tpgt;\n\n\t \n\ttpg->tpg_attrib.generate_node_acls = 1;\n\ttpg->tpg_attrib.demo_mode_write_protect = 1;\n\ttpg->tpg_attrib.cache_dynamic_acls = 1;\n\ttpg->tpg_attrib.demo_mode_login_only = 1;\n\n\tret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tlport->tpg_1 = tpg;\n\treturn &tpg->se_tpg;\n}\n\n \nstatic struct fc_port *tcm_qla2xxx_find_sess_by_s_id(scsi_qla_host_t *vha,\n\t\t\t\t\t\t     const be_id_t s_id)\n{\n\tstruct tcm_qla2xxx_lport *lport;\n\tstruct se_node_acl *se_nacl;\n\tstruct tcm_qla2xxx_nacl *nacl;\n\tu32 key;\n\n\tlport = vha->vha_tgt.target_lport_ptr;\n\tif (!lport) {\n\t\tpr_err(\"Unable to locate struct tcm_qla2xxx_lport\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tkey = sid_to_key(s_id);\n\tpr_debug(\"find_sess_by_s_id: 0x%06x\\n\", key);\n\n\tse_nacl = btree_lookup32(&lport->lport_fcport_map, key);\n\tif (!se_nacl) {\n\t\tpr_debug(\"Unable to locate s_id: 0x%06x\\n\", key);\n\t\treturn NULL;\n\t}\n\tpr_debug(\"find_sess_by_s_id: located se_nacl: %p, initiatorname: %s\\n\",\n\t    se_nacl, se_nacl->initiatorname);\n\n\tnacl = container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);\n\tif (!nacl->fc_port) {\n\t\tpr_err(\"Unable to locate struct fc_port\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn nacl->fc_port;\n}\n\n \nstatic void tcm_qla2xxx_set_sess_by_s_id(\n\tstruct tcm_qla2xxx_lport *lport,\n\tstruct se_node_acl *new_se_nacl,\n\tstruct tcm_qla2xxx_nacl *nacl,\n\tstruct se_session *se_sess,\n\tstruct fc_port *fc_port,\n\tbe_id_t s_id)\n{\n\tu32 key;\n\tvoid *slot;\n\tint rc;\n\n\tkey = sid_to_key(s_id);\n\tpr_debug(\"set_sess_by_s_id: %06x\\n\", key);\n\n\tslot = btree_lookup32(&lport->lport_fcport_map, key);\n\tif (!slot) {\n\t\tif (new_se_nacl) {\n\t\t\tpr_debug(\"Setting up new fc_port entry to new_se_nacl\\n\");\n\t\t\tnacl->nport_id = key;\n\t\t\trc = btree_insert32(&lport->lport_fcport_map, key,\n\t\t\t\t\tnew_se_nacl, GFP_ATOMIC);\n\t\t\tif (rc)\n\t\t\t\tprintk(KERN_ERR \"Unable to insert s_id into fcport_map: %06x\\n\",\n\t\t\t\t    (int)key);\n\t\t} else {\n\t\t\tpr_debug(\"Wiping nonexisting fc_port entry\\n\");\n\t\t}\n\n\t\tfc_port->se_sess = se_sess;\n\t\tnacl->fc_port = fc_port;\n\t\treturn;\n\t}\n\n\tif (nacl->fc_port) {\n\t\tif (new_se_nacl == NULL) {\n\t\t\tpr_debug(\"Clearing existing nacl->fc_port and fc_port entry\\n\");\n\t\t\tbtree_remove32(&lport->lport_fcport_map, key);\n\t\t\tnacl->fc_port = NULL;\n\t\t\treturn;\n\t\t}\n\t\tpr_debug(\"Replacing existing nacl->fc_port and fc_port entry\\n\");\n\t\tbtree_update32(&lport->lport_fcport_map, key, new_se_nacl);\n\t\tfc_port->se_sess = se_sess;\n\t\tnacl->fc_port = fc_port;\n\t\treturn;\n\t}\n\n\tif (new_se_nacl == NULL) {\n\t\tpr_debug(\"Clearing existing fc_port entry\\n\");\n\t\tbtree_remove32(&lport->lport_fcport_map, key);\n\t\treturn;\n\t}\n\n\tpr_debug(\"Replacing existing fc_port entry w/o active nacl->fc_port\\n\");\n\tbtree_update32(&lport->lport_fcport_map, key, new_se_nacl);\n\tfc_port->se_sess = se_sess;\n\tnacl->fc_port = fc_port;\n\n\tpr_debug(\"Setup nacl->fc_port %p by s_id for se_nacl: %p, initiatorname: %s\\n\",\n\t    nacl->fc_port, new_se_nacl, new_se_nacl->initiatorname);\n}\n\n \nstatic struct fc_port *tcm_qla2xxx_find_sess_by_loop_id(\n\tscsi_qla_host_t *vha,\n\tconst uint16_t loop_id)\n{\n\tstruct tcm_qla2xxx_lport *lport;\n\tstruct se_node_acl *se_nacl;\n\tstruct tcm_qla2xxx_nacl *nacl;\n\tstruct tcm_qla2xxx_fc_loopid *fc_loopid;\n\n\tlport = vha->vha_tgt.target_lport_ptr;\n\tif (!lport) {\n\t\tpr_err(\"Unable to locate struct tcm_qla2xxx_lport\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tpr_debug(\"find_sess_by_loop_id: Using loop_id: 0x%04x\\n\", loop_id);\n\n\tfc_loopid = lport->lport_loopid_map + loop_id;\n\tse_nacl = fc_loopid->se_nacl;\n\tif (!se_nacl) {\n\t\tpr_debug(\"Unable to locate se_nacl by loop_id: 0x%04x\\n\",\n\t\t    loop_id);\n\t\treturn NULL;\n\t}\n\n\tnacl = container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);\n\n\tif (!nacl->fc_port) {\n\t\tpr_err(\"Unable to locate struct fc_port\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn nacl->fc_port;\n}\n\n \nstatic void tcm_qla2xxx_set_sess_by_loop_id(\n\tstruct tcm_qla2xxx_lport *lport,\n\tstruct se_node_acl *new_se_nacl,\n\tstruct tcm_qla2xxx_nacl *nacl,\n\tstruct se_session *se_sess,\n\tstruct fc_port *fc_port,\n\tuint16_t loop_id)\n{\n\tstruct se_node_acl *saved_nacl;\n\tstruct tcm_qla2xxx_fc_loopid *fc_loopid;\n\n\tpr_debug(\"set_sess_by_loop_id: Using loop_id: 0x%04x\\n\", loop_id);\n\n\tfc_loopid = &((struct tcm_qla2xxx_fc_loopid *)\n\t\t\tlport->lport_loopid_map)[loop_id];\n\n\tsaved_nacl = fc_loopid->se_nacl;\n\tif (!saved_nacl) {\n\t\tpr_debug(\"Setting up new fc_loopid->se_nacl to new_se_nacl\\n\");\n\t\tfc_loopid->se_nacl = new_se_nacl;\n\t\tif (fc_port->se_sess != se_sess)\n\t\t\tfc_port->se_sess = se_sess;\n\t\tif (nacl->fc_port != fc_port)\n\t\t\tnacl->fc_port = fc_port;\n\t\treturn;\n\t}\n\n\tif (nacl->fc_port) {\n\t\tif (new_se_nacl == NULL) {\n\t\t\tpr_debug(\"Clearing nacl->fc_port and fc_loopid->se_nacl\\n\");\n\t\t\tfc_loopid->se_nacl = NULL;\n\t\t\tnacl->fc_port = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tpr_debug(\"Replacing existing nacl->fc_port and fc_loopid->se_nacl\\n\");\n\t\tfc_loopid->se_nacl = new_se_nacl;\n\t\tif (fc_port->se_sess != se_sess)\n\t\t\tfc_port->se_sess = se_sess;\n\t\tif (nacl->fc_port != fc_port)\n\t\t\tnacl->fc_port = fc_port;\n\t\treturn;\n\t}\n\n\tif (new_se_nacl == NULL) {\n\t\tpr_debug(\"Clearing fc_loopid->se_nacl\\n\");\n\t\tfc_loopid->se_nacl = NULL;\n\t\treturn;\n\t}\n\n\tpr_debug(\"Replacing existing fc_loopid->se_nacl w/o active nacl->fc_port\\n\");\n\tfc_loopid->se_nacl = new_se_nacl;\n\tif (fc_port->se_sess != se_sess)\n\t\tfc_port->se_sess = se_sess;\n\tif (nacl->fc_port != fc_port)\n\t\tnacl->fc_port = fc_port;\n\n\tpr_debug(\"Setup nacl->fc_port %p by loop_id for se_nacl: %p, initiatorname: %s\\n\",\n\t    nacl->fc_port, new_se_nacl, new_se_nacl->initiatorname);\n}\n\n \nstatic void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *lport,\n\t\tstruct tcm_qla2xxx_nacl *nacl, struct fc_port *sess)\n{\n\tstruct se_session *se_sess = sess->se_sess;\n\n\ttcm_qla2xxx_set_sess_by_s_id(lport, NULL, nacl, se_sess,\n\t\t\t\t     sess, port_id_to_be_id(sess->d_id));\n\ttcm_qla2xxx_set_sess_by_loop_id(lport, NULL, nacl, se_sess,\n\t\t\t\tsess, sess->loop_id);\n}\n\nstatic void tcm_qla2xxx_free_session(struct fc_port *sess)\n{\n\tstruct qla_tgt *tgt = sess->tgt;\n\tstruct qla_hw_data *ha = tgt->ha;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\tstruct se_session *se_sess;\n\tstruct tcm_qla2xxx_lport *lport;\n\n\tse_sess = sess->se_sess;\n\tif (!se_sess) {\n\t\tpr_err(\"struct fc_port->se_sess is NULL\\n\");\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tlport = vha->vha_tgt.target_lport_ptr;\n\tif (!lport) {\n\t\tpr_err(\"Unable to locate struct tcm_qla2xxx_lport\\n\");\n\t\tdump_stack();\n\t\treturn;\n\t}\n\ttarget_wait_for_sess_cmds(se_sess);\n\n\ttarget_remove_session(se_sess);\n}\n\nstatic int tcm_qla2xxx_session_cb(struct se_portal_group *se_tpg,\n\t\t\t\t  struct se_session *se_sess, void *p)\n{\n\tstruct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct tcm_qla2xxx_tpg, se_tpg);\n\tstruct tcm_qla2xxx_lport *lport = tpg->lport;\n\tstruct qla_hw_data *ha = lport->qla_vha->hw;\n\tstruct se_node_acl *se_nacl = se_sess->se_node_acl;\n\tstruct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,\n\t\t\t\tstruct tcm_qla2xxx_nacl, se_node_acl);\n\tstruct fc_port *qlat_sess = p;\n\tuint16_t loop_id = qlat_sess->loop_id;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\ttcm_qla2xxx_set_sess_by_s_id(lport, se_nacl, nacl, se_sess, qlat_sess,\n\t\t\t\t     port_id_to_be_id(qlat_sess->d_id));\n\ttcm_qla2xxx_set_sess_by_loop_id(lport, se_nacl, nacl,\n\t\t\t\t\tse_sess, qlat_sess, loop_id);\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int tcm_qla2xxx_check_initiator_node_acl(\n\tscsi_qla_host_t *vha,\n\tunsigned char *fc_wwpn,\n\tstruct fc_port *qlat_sess)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct tcm_qla2xxx_lport *lport;\n\tstruct tcm_qla2xxx_tpg *tpg;\n\tstruct se_session *se_sess;\n\tunsigned char port_name[36];\n\tint num_tags = (ha->cur_fw_xcb_count) ? ha->cur_fw_xcb_count :\n\t\t       TCM_QLA2XXX_DEFAULT_TAGS;\n\n\tlport = vha->vha_tgt.target_lport_ptr;\n\tif (!lport) {\n\t\tpr_err(\"Unable to locate struct tcm_qla2xxx_lport\\n\");\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\t \n\ttpg = lport->tpg_1;\n\tif (!tpg) {\n\t\tpr_err(\"Unable to locate struct tcm_qla2xxx_lport->tpg_1\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tmemset(&port_name, 0, 36);\n\tsnprintf(port_name, sizeof(port_name), \"%8phC\", fc_wwpn);\n\t \n\tse_sess = target_setup_session(&tpg->se_tpg, num_tags,\n\t\t\t\t       sizeof(struct qla_tgt_cmd),\n\t\t\t\t       TARGET_PROT_ALL, port_name,\n\t\t\t\t       qlat_sess, tcm_qla2xxx_session_cb);\n\tif (IS_ERR(se_sess))\n\t\treturn PTR_ERR(se_sess);\n\n\treturn 0;\n}\n\nstatic void tcm_qla2xxx_update_sess(struct fc_port *sess, port_id_t s_id,\n\t\t\t\t    uint16_t loop_id, bool conf_compl_supported)\n{\n\tstruct qla_tgt *tgt = sess->tgt;\n\tstruct qla_hw_data *ha = tgt->ha;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\tstruct tcm_qla2xxx_lport *lport = vha->vha_tgt.target_lport_ptr;\n\tstruct se_node_acl *se_nacl = sess->se_sess->se_node_acl;\n\tstruct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,\n\t\t\tstruct tcm_qla2xxx_nacl, se_node_acl);\n\tu32 key;\n\n\n\tif (sess->loop_id != loop_id || sess->d_id.b24 != s_id.b24)\n\t\tpr_info(\"Updating session %p from port %8phC loop_id %d -> %d s_id %x:%x:%x -> %x:%x:%x\\n\",\n\t\t    sess, sess->port_name,\n\t\t    sess->loop_id, loop_id, sess->d_id.b.domain,\n\t\t    sess->d_id.b.area, sess->d_id.b.al_pa, s_id.b.domain,\n\t\t    s_id.b.area, s_id.b.al_pa);\n\n\tif (sess->loop_id != loop_id) {\n\t\t \n\t\tif (lport->lport_loopid_map[sess->loop_id].se_nacl == se_nacl)\n\t\t\tlport->lport_loopid_map[sess->loop_id].se_nacl = NULL;\n\n\t\tlport->lport_loopid_map[loop_id].se_nacl = se_nacl;\n\n\t\tsess->loop_id = loop_id;\n\t}\n\n\tif (sess->d_id.b24 != s_id.b24) {\n\t\tkey = (((u32) sess->d_id.b.domain << 16) |\n\t\t       ((u32) sess->d_id.b.area   <<  8) |\n\t\t       ((u32) sess->d_id.b.al_pa));\n\n\t\tif (btree_lookup32(&lport->lport_fcport_map, key))\n\t\t\tWARN(btree_remove32(&lport->lport_fcport_map, key) !=\n\t\t\t    se_nacl, \"Found wrong se_nacl when updating s_id %x:%x:%x\\n\",\n\t\t\t    sess->d_id.b.domain, sess->d_id.b.area,\n\t\t\t    sess->d_id.b.al_pa);\n\t\telse\n\t\t\tWARN(1, \"No lport_fcport_map entry for s_id %x:%x:%x\\n\",\n\t\t\t     sess->d_id.b.domain, sess->d_id.b.area,\n\t\t\t     sess->d_id.b.al_pa);\n\n\t\tkey = (((u32) s_id.b.domain << 16) |\n\t\t       ((u32) s_id.b.area   <<  8) |\n\t\t       ((u32) s_id.b.al_pa));\n\n\t\tif (btree_lookup32(&lport->lport_fcport_map, key)) {\n\t\t\tWARN(1, \"Already have lport_fcport_map entry for s_id %x:%x:%x\\n\",\n\t\t\t     s_id.b.domain, s_id.b.area, s_id.b.al_pa);\n\t\t\tbtree_update32(&lport->lport_fcport_map, key, se_nacl);\n\t\t} else {\n\t\t\tbtree_insert32(&lport->lport_fcport_map, key, se_nacl,\n\t\t\t    GFP_ATOMIC);\n\t\t}\n\n\t\tsess->d_id = s_id;\n\t\tnacl->nport_id = key;\n\t}\n\n\tsess->conf_compl_supported = conf_compl_supported;\n\n}\n\n \nstatic const struct qla_tgt_func_tmpl tcm_qla2xxx_template = {\n\t.find_cmd_by_tag\t= tcm_qla2xxx_find_cmd_by_tag,\n\t.handle_cmd\t\t= tcm_qla2xxx_handle_cmd,\n\t.handle_data\t\t= tcm_qla2xxx_handle_data,\n\t.handle_tmr\t\t= tcm_qla2xxx_handle_tmr,\n\t.get_cmd\t\t= tcm_qla2xxx_get_cmd,\n\t.rel_cmd\t\t= tcm_qla2xxx_rel_cmd,\n\t.free_cmd\t\t= tcm_qla2xxx_free_cmd,\n\t.free_mcmd\t\t= tcm_qla2xxx_free_mcmd,\n\t.free_session\t\t= tcm_qla2xxx_free_session,\n\t.update_sess\t\t= tcm_qla2xxx_update_sess,\n\t.check_initiator_node_acl = tcm_qla2xxx_check_initiator_node_acl,\n\t.find_sess_by_s_id\t= tcm_qla2xxx_find_sess_by_s_id,\n\t.find_sess_by_loop_id\t= tcm_qla2xxx_find_sess_by_loop_id,\n\t.clear_nacl_from_fcport_map = tcm_qla2xxx_clear_nacl_from_fcport_map,\n\t.put_sess\t\t= tcm_qla2xxx_put_sess,\n\t.shutdown_sess\t\t= tcm_qla2xxx_shutdown_sess,\n\t.get_dif_tags\t\t= tcm_qla2xxx_dif_tags,\n\t.chk_dif_tags\t\t= tcm_qla2xxx_chk_dif_tags,\n};\n\nstatic int tcm_qla2xxx_init_lport(struct tcm_qla2xxx_lport *lport)\n{\n\tint rc;\n\tsize_t map_sz;\n\n\trc = btree_init32(&lport->lport_fcport_map);\n\tif (rc) {\n\t\tpr_err(\"Unable to initialize lport->lport_fcport_map btree\\n\");\n\t\treturn rc;\n\t}\n\n\tmap_sz = array_size(65536, sizeof(struct tcm_qla2xxx_fc_loopid));\n\n\tlport->lport_loopid_map = vzalloc(map_sz);\n\tif (!lport->lport_loopid_map) {\n\t\tpr_err(\"Unable to allocate lport->lport_loopid_map of %zu bytes\\n\", map_sz);\n\t\tbtree_destroy32(&lport->lport_fcport_map);\n\t\treturn -ENOMEM;\n\t}\n\tpr_debug(\"qla2xxx: Allocated lport_loopid_map of %zu bytes\\n\", map_sz);\n\treturn 0;\n}\n\nstatic int tcm_qla2xxx_lport_register_cb(struct scsi_qla_host *vha,\n\t\t\t\t\t void *target_lport_ptr,\n\t\t\t\t\t u64 npiv_wwpn, u64 npiv_wwnn)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct tcm_qla2xxx_lport *lport =\n\t\t\t(struct tcm_qla2xxx_lport *)target_lport_ptr;\n\t \n\tha->tgt.tgt_ops = &tcm_qla2xxx_template;\n\tvha->vha_tgt.target_lport_ptr = target_lport_ptr;\n\tlport->qla_vha = vha;\n\n\treturn 0;\n}\n\nstatic struct se_wwn *tcm_qla2xxx_make_lport(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_qla2xxx_lport *lport;\n\tu64 wwpn;\n\tint ret = -ENODEV;\n\n\tif (tcm_qla2xxx_parse_wwn(name, &wwpn, 1) < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlport = kzalloc(sizeof(struct tcm_qla2xxx_lport), GFP_KERNEL);\n\tif (!lport) {\n\t\tpr_err(\"Unable to allocate struct tcm_qla2xxx_lport\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlport->lport_wwpn = wwpn;\n\ttcm_qla2xxx_format_wwn(&lport->lport_name[0], TCM_QLA2XXX_NAMELEN,\n\t\t\t\twwpn);\n\tsprintf(lport->lport_naa_name, \"naa.%016llx\", (unsigned long long) wwpn);\n\n\tret = tcm_qla2xxx_init_lport(lport);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = qlt_lport_register(lport, wwpn, 0, 0,\n\t\t\t\t tcm_qla2xxx_lport_register_cb);\n\tif (ret != 0)\n\t\tgoto out_lport;\n\n\treturn &lport->lport_wwn;\nout_lport:\n\tvfree(lport->lport_loopid_map);\n\tbtree_destroy32(&lport->lport_fcport_map);\nout:\n\tkfree(lport);\n\treturn ERR_PTR(ret);\n}\n\nstatic void tcm_qla2xxx_drop_lport(struct se_wwn *wwn)\n{\n\tstruct tcm_qla2xxx_lport *lport = container_of(wwn,\n\t\t\tstruct tcm_qla2xxx_lport, lport_wwn);\n\tstruct scsi_qla_host *vha = lport->qla_vha;\n\tstruct se_node_acl *node;\n\tu32 key = 0;\n\n\t \n\tif (vha->vha_tgt.qla_tgt && !vha->vha_tgt.qla_tgt->tgt_stopped)\n\t\tqlt_stop_phase2(vha->vha_tgt.qla_tgt);\n\n\tqlt_lport_deregister(vha);\n\n\tvfree(lport->lport_loopid_map);\n\tbtree_for_each_safe32(&lport->lport_fcport_map, key, node)\n\t\tbtree_remove32(&lport->lport_fcport_map, key);\n\tbtree_destroy32(&lport->lport_fcport_map);\n\tkfree(lport);\n}\n\nstatic int tcm_qla2xxx_lport_register_npiv_cb(struct scsi_qla_host *base_vha,\n\t\t\t\t\t      void *target_lport_ptr,\n\t\t\t\t\t      u64 npiv_wwpn, u64 npiv_wwnn)\n{\n\tstruct fc_vport *vport;\n\tstruct Scsi_Host *sh = base_vha->host;\n\tstruct scsi_qla_host *npiv_vha;\n\tstruct tcm_qla2xxx_lport *lport =\n\t\t\t(struct tcm_qla2xxx_lport *)target_lport_ptr;\n\tstruct tcm_qla2xxx_lport *base_lport =\n\t\t\t(struct tcm_qla2xxx_lport *)base_vha->vha_tgt.target_lport_ptr;\n\tstruct fc_vport_identifiers vport_id;\n\n\tif (qla_ini_mode_enabled(base_vha)) {\n\t\tpr_err(\"qla2xxx base_vha not enabled for target mode\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (!base_lport || !base_lport->tpg_1 ||\n\t    !atomic_read(&base_lport->tpg_1->lport_tpg_enabled)) {\n\t\tpr_err(\"qla2xxx base_lport or tpg_1 not available\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tmemset(&vport_id, 0, sizeof(vport_id));\n\tvport_id.port_name = npiv_wwpn;\n\tvport_id.node_name = npiv_wwnn;\n\tvport_id.roles = FC_PORT_ROLE_FCP_INITIATOR;\n\tvport_id.vport_type = FC_PORTTYPE_NPIV;\n\tvport_id.disable = false;\n\n\tvport = fc_vport_create(sh, 0, &vport_id);\n\tif (!vport) {\n\t\tpr_err(\"fc_vport_create failed for qla2xxx_npiv\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tnpiv_vha = (struct scsi_qla_host *)vport->dd_data;\n\tnpiv_vha->vha_tgt.target_lport_ptr = target_lport_ptr;\n\tlport->qla_vha = npiv_vha;\n\tscsi_host_get(npiv_vha->host);\n\treturn 0;\n}\n\n\nstatic struct se_wwn *tcm_qla2xxx_npiv_make_lport(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_qla2xxx_lport *lport;\n\tu64 phys_wwpn, npiv_wwpn, npiv_wwnn;\n\tchar *p, tmp[128];\n\tint ret;\n\n\tsnprintf(tmp, 128, \"%s\", name);\n\n\tp = strchr(tmp, '@');\n\tif (!p) {\n\t\tpr_err(\"Unable to locate NPIV '@' separator\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t*p++ = '\\0';\n\n\tif (tcm_qla2xxx_parse_wwn(tmp, &phys_wwpn, 1) < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tcm_qla2xxx_npiv_parse_wwn(p, strlen(p)+1,\n\t\t\t\t       &npiv_wwpn, &npiv_wwnn) < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlport = kzalloc(sizeof(struct tcm_qla2xxx_lport), GFP_KERNEL);\n\tif (!lport) {\n\t\tpr_err(\"Unable to allocate struct tcm_qla2xxx_lport for NPIV\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlport->lport_npiv_wwpn = npiv_wwpn;\n\tlport->lport_npiv_wwnn = npiv_wwnn;\n\tsprintf(lport->lport_naa_name, \"naa.%016llx\", (unsigned long long) npiv_wwpn);\n\n\tret = tcm_qla2xxx_init_lport(lport);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = qlt_lport_register(lport, phys_wwpn, npiv_wwpn, npiv_wwnn,\n\t\t\t\t tcm_qla2xxx_lport_register_npiv_cb);\n\tif (ret != 0)\n\t\tgoto out_lport;\n\n\treturn &lport->lport_wwn;\nout_lport:\n\tvfree(lport->lport_loopid_map);\n\tbtree_destroy32(&lport->lport_fcport_map);\nout:\n\tkfree(lport);\n\treturn ERR_PTR(ret);\n}\n\nstatic void tcm_qla2xxx_npiv_drop_lport(struct se_wwn *wwn)\n{\n\tstruct tcm_qla2xxx_lport *lport = container_of(wwn,\n\t\t\tstruct tcm_qla2xxx_lport, lport_wwn);\n\tstruct scsi_qla_host *npiv_vha = lport->qla_vha;\n\tstruct qla_hw_data *ha = npiv_vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\tscsi_host_put(npiv_vha->host);\n\t \n\tfc_vport_terminate(npiv_vha->fc_vport);\n\tscsi_host_put(base_vha->host);\n\tkfree(lport);\n}\n\n\nstatic ssize_t tcm_qla2xxx_wwn_version_show(struct config_item *item,\n\t\tchar *page)\n{\n\treturn sprintf(page,\n\t    \"TCM QLOGIC QLA2XXX NPIV capable fabric module %s on %s/%s on %s\\n\",\n\t    QLA2XXX_VERSION, utsname()->sysname,\n\t    utsname()->machine, utsname()->release);\n}\n\nCONFIGFS_ATTR_RO(tcm_qla2xxx_wwn_, version);\n\nstatic struct configfs_attribute *tcm_qla2xxx_wwn_attrs[] = {\n\t&tcm_qla2xxx_wwn_attr_version,\n\tNULL,\n};\n\nstatic const struct target_core_fabric_ops tcm_qla2xxx_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"qla2xxx\",\n\t.node_acl_size\t\t\t= sizeof(struct tcm_qla2xxx_nacl),\n\t \n\t.max_data_sg_nents\t\t= 1200,\n\t.tpg_get_wwn\t\t\t= tcm_qla2xxx_get_fabric_wwn,\n\t.tpg_get_tag\t\t\t= tcm_qla2xxx_get_tag,\n\t.tpg_check_demo_mode\t\t= tcm_qla2xxx_check_demo_mode,\n\t.tpg_check_demo_mode_cache\t= tcm_qla2xxx_check_demo_mode_cache,\n\t.tpg_check_demo_mode_write_protect =\n\t\t\t\t\ttcm_qla2xxx_check_demo_write_protect,\n\t.tpg_check_prod_mode_write_protect =\n\t\t\t\t\ttcm_qla2xxx_check_prod_write_protect,\n\t.tpg_check_prot_fabric_only\t= tcm_qla2xxx_check_prot_fabric_only,\n\t.tpg_check_demo_mode_login_only = tcm_qla2xxx_check_demo_mode_login_only,\n\t.tpg_get_inst_index\t\t= tcm_qla2xxx_tpg_get_inst_index,\n\t.check_stop_free\t\t= tcm_qla2xxx_check_stop_free,\n\t.release_cmd\t\t\t= tcm_qla2xxx_release_cmd,\n\t.close_session\t\t\t= tcm_qla2xxx_close_session,\n\t.sess_get_initiator_sid\t\t= NULL,\n\t.write_pending\t\t\t= tcm_qla2xxx_write_pending,\n\t.get_cmd_state\t\t\t= tcm_qla2xxx_get_cmd_state,\n\t.queue_data_in\t\t\t= tcm_qla2xxx_queue_data_in,\n\t.queue_status\t\t\t= tcm_qla2xxx_queue_status,\n\t.queue_tm_rsp\t\t\t= tcm_qla2xxx_queue_tm_rsp,\n\t.aborted_task\t\t\t= tcm_qla2xxx_aborted_task,\n\t \n\t.fabric_make_wwn\t\t= tcm_qla2xxx_make_lport,\n\t.fabric_drop_wwn\t\t= tcm_qla2xxx_drop_lport,\n\t.fabric_make_tpg\t\t= tcm_qla2xxx_make_tpg,\n\t.fabric_enable_tpg\t\t= tcm_qla2xxx_enable_tpg,\n\t.fabric_drop_tpg\t\t= tcm_qla2xxx_drop_tpg,\n\t.fabric_init_nodeacl\t\t= tcm_qla2xxx_init_nodeacl,\n\n\t.tfc_wwn_attrs\t\t\t= tcm_qla2xxx_wwn_attrs,\n\t.tfc_tpg_base_attrs\t\t= tcm_qla2xxx_tpg_attrs,\n\t.tfc_tpg_attrib_attrs\t\t= tcm_qla2xxx_tpg_attrib_attrs,\n};\n\nstatic const struct target_core_fabric_ops tcm_qla2xxx_npiv_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"qla2xxx_npiv\",\n\t.node_acl_size\t\t\t= sizeof(struct tcm_qla2xxx_nacl),\n\t.tpg_get_wwn\t\t\t= tcm_qla2xxx_get_fabric_wwn,\n\t.tpg_get_tag\t\t\t= tcm_qla2xxx_get_tag,\n\t.tpg_check_demo_mode\t\t= tcm_qla2xxx_check_demo_mode,\n\t.tpg_check_demo_mode_cache\t= tcm_qla2xxx_check_demo_mode_cache,\n\t.tpg_check_demo_mode_write_protect = tcm_qla2xxx_check_demo_mode,\n\t.tpg_check_prod_mode_write_protect =\n\t    tcm_qla2xxx_check_prod_write_protect,\n\t.tpg_check_demo_mode_login_only\t= tcm_qla2xxx_check_demo_mode_login_only,\n\t.tpg_get_inst_index\t\t= tcm_qla2xxx_tpg_get_inst_index,\n\t.check_stop_free                = tcm_qla2xxx_check_stop_free,\n\t.release_cmd\t\t\t= tcm_qla2xxx_release_cmd,\n\t.close_session\t\t\t= tcm_qla2xxx_close_session,\n\t.sess_get_initiator_sid\t\t= NULL,\n\t.write_pending\t\t\t= tcm_qla2xxx_write_pending,\n\t.get_cmd_state\t\t\t= tcm_qla2xxx_get_cmd_state,\n\t.queue_data_in\t\t\t= tcm_qla2xxx_queue_data_in,\n\t.queue_status\t\t\t= tcm_qla2xxx_queue_status,\n\t.queue_tm_rsp\t\t\t= tcm_qla2xxx_queue_tm_rsp,\n\t.aborted_task\t\t\t= tcm_qla2xxx_aborted_task,\n\t \n\t.fabric_make_wwn\t\t= tcm_qla2xxx_npiv_make_lport,\n\t.fabric_drop_wwn\t\t= tcm_qla2xxx_npiv_drop_lport,\n\t.fabric_make_tpg\t\t= tcm_qla2xxx_npiv_make_tpg,\n\t.fabric_enable_tpg\t\t= tcm_qla2xxx_npiv_enable_tpg,\n\t.fabric_drop_tpg\t\t= tcm_qla2xxx_drop_tpg,\n\t.fabric_init_nodeacl\t\t= tcm_qla2xxx_init_nodeacl,\n\n\t.tfc_wwn_attrs\t\t\t= tcm_qla2xxx_wwn_attrs,\n};\n\nstatic int tcm_qla2xxx_register_configfs(void)\n{\n\tint ret;\n\n\tpr_debug(\"TCM QLOGIC QLA2XXX fabric module %s on %s/%s on %s\\n\",\n\t    QLA2XXX_VERSION, utsname()->sysname,\n\t    utsname()->machine, utsname()->release);\n\n\tret = target_register_template(&tcm_qla2xxx_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = target_register_template(&tcm_qla2xxx_npiv_ops);\n\tif (ret)\n\t\tgoto out_fabric;\n\n\ttcm_qla2xxx_free_wq = alloc_workqueue(\"tcm_qla2xxx_free\",\n\t\t\t\t\t\tWQ_MEM_RECLAIM, 0);\n\tif (!tcm_qla2xxx_free_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto out_fabric_npiv;\n\t}\n\n\treturn 0;\n\nout_fabric_npiv:\n\ttarget_unregister_template(&tcm_qla2xxx_npiv_ops);\nout_fabric:\n\ttarget_unregister_template(&tcm_qla2xxx_ops);\n\treturn ret;\n}\n\nstatic void tcm_qla2xxx_deregister_configfs(void)\n{\n\tdestroy_workqueue(tcm_qla2xxx_free_wq);\n\n\ttarget_unregister_template(&tcm_qla2xxx_ops);\n\ttarget_unregister_template(&tcm_qla2xxx_npiv_ops);\n}\n\nstatic int __init tcm_qla2xxx_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct abts_recv_from_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct abts_resp_from_24xx_fw) != 64);\n\tBUILD_BUG_ON(sizeof(struct atio7_fcp_cmnd) != 32);\n\tBUILD_BUG_ON(sizeof(struct atio_from_isp) != 64);\n\tBUILD_BUG_ON(sizeof(struct ba_acc_le) != 12);\n\tBUILD_BUG_ON(sizeof(struct ba_rjt_le) != 4);\n\tBUILD_BUG_ON(sizeof(struct ctio7_from_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct ctio7_to_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct ctio_crc2_to_fw) != 64);\n\tBUILD_BUG_ON(sizeof(struct ctio_crc_from_fw) != 64);\n\tBUILD_BUG_ON(sizeof(struct ctio_to_2xxx) != 64);\n\tBUILD_BUG_ON(sizeof(struct fcp_hdr) != 24);\n\tBUILD_BUG_ON(sizeof(struct fcp_hdr_le) != 24);\n\tBUILD_BUG_ON(sizeof(struct nack_to_isp) != 64);\n\n\tret = tcm_qla2xxx_register_configfs();\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void __exit tcm_qla2xxx_exit(void)\n{\n\ttcm_qla2xxx_deregister_configfs();\n}\n\nMODULE_DESCRIPTION(\"TCM QLA24XX+ series NPIV enabled fabric driver\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(tcm_qla2xxx_init);\nmodule_exit(tcm_qla2xxx_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}