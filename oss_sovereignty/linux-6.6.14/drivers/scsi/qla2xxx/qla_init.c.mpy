{
  "module_name": "qla_init.c",
  "hash_id": "53644187e1202228fecba8f248172bbd5a34ea08dcddbf1fa1662281929825a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_init.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_gbl.h\"\n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\n#include \"qla_devtbl.h\"\n\n#ifdef CONFIG_SPARC\n#include <asm/prom.h>\n#endif\n\n#include \"qla_target.h\"\n\n \nstatic int qla2x00_isp_firmware(scsi_qla_host_t *);\nstatic int qla2x00_setup_chip(scsi_qla_host_t *);\nstatic int qla2x00_fw_ready(scsi_qla_host_t *);\nstatic int qla2x00_configure_hba(scsi_qla_host_t *);\nstatic int qla2x00_configure_loop(scsi_qla_host_t *);\nstatic int qla2x00_configure_local_loop(scsi_qla_host_t *);\nstatic int qla2x00_configure_fabric(scsi_qla_host_t *);\nstatic int qla2x00_find_all_fabric_devs(scsi_qla_host_t *);\nstatic int qla2x00_restart_isp(scsi_qla_host_t *);\n\nstatic struct qla_chip_state_84xx *qla84xx_get_chip(struct scsi_qla_host *);\nstatic int qla84xx_init_chip(scsi_qla_host_t *);\nstatic int qla25xx_init_queues(struct qla_hw_data *);\nstatic void qla24xx_handle_gpdb_event(scsi_qla_host_t *vha,\n\t\t\t\t      struct event_arg *ea);\nstatic void qla24xx_handle_prli_done_event(struct scsi_qla_host *,\n    struct event_arg *);\nstatic void __qla24xx_handle_gpdb_event(scsi_qla_host_t *, struct event_arg *);\n\n \n\nvoid\nqla2x00_sp_timeout(struct timer_list *t)\n{\n\tsrb_t *sp = from_timer(sp, t, u.iocb_cmd.timer);\n\tstruct srb_iocb *iocb;\n\tscsi_qla_host_t *vha = sp->vha;\n\n\tWARN_ON(irqs_disabled());\n\tiocb = &sp->u.iocb_cmd;\n\tiocb->timeout(sp);\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\n\tif (vha && qla2x00_isp_reg_stat(vha->hw)) {\n\t\tql_log(ql_log_info, vha, 0x9008,\n\t\t    \"PCI/Register disconnect.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t}\n}\n\nvoid qla2x00_sp_free(srb_t *sp)\n{\n\tstruct srb_iocb *iocb = &sp->u.iocb_cmd;\n\n\tdel_timer(&iocb->timer);\n\tqla2x00_rel_sp(sp);\n}\n\nvoid qla2xxx_rel_done_warning(srb_t *sp, int res)\n{\n\tWARN_ONCE(1, \"Calling done() of an already freed srb %p object\\n\", sp);\n}\n\nvoid qla2xxx_rel_free_warning(srb_t *sp)\n{\n\tWARN_ONCE(1, \"Calling free() of an already freed srb %p object\\n\", sp);\n}\n\n \n\nunsigned long\nqla2x00_get_async_timeout(struct scsi_qla_host *vha)\n{\n\tunsigned long tmo;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\ttmo = ha->r_a_tov / 10 * 2;\n\tif (IS_QLAFX00(ha)) {\n\t\ttmo = FX00_DEF_RATOV * 2;\n\t} else if (!IS_FWI2_CAPABLE(ha)) {\n\t\t \n\t\ttmo = ha->login_timeout;\n\t}\n\treturn tmo;\n}\n\nstatic void qla24xx_abort_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tstruct srb_iocb *abt = &sp->u.iocb_cmd;\n\tstruct qla_qpair *qpair = sp->qpair;\n\tu32 handle;\n\tunsigned long flags;\n\tint sp_found = 0, cmdsp_found = 0;\n\n\tif (sp->cmd_sp)\n\t\tql_dbg(ql_dbg_async, sp->vha, 0x507c,\n\t\t    \"Abort timeout - cmd hdl=%x, cmd type=%x hdl=%x, type=%x\\n\",\n\t\t    sp->cmd_sp->handle, sp->cmd_sp->type,\n\t\t    sp->handle, sp->type);\n\telse\n\t\tql_dbg(ql_dbg_async, sp->vha, 0x507c,\n\t\t    \"Abort timeout 2 - hdl=%x, type=%x\\n\",\n\t\t    sp->handle, sp->type);\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tfor (handle = 1; handle < qpair->req->num_outstanding_cmds; handle++) {\n\t\tif (sp->cmd_sp && (qpair->req->outstanding_cmds[handle] ==\n\t\t    sp->cmd_sp)) {\n\t\t\tqpair->req->outstanding_cmds[handle] = NULL;\n\t\t\tcmdsp_found = 1;\n\t\t\tqla_put_fw_resources(qpair, &sp->cmd_sp->iores);\n\t\t}\n\n\t\t \n\t\tif (qpair->req->outstanding_cmds[handle] == sp) {\n\t\t\tqpair->req->outstanding_cmds[handle] = NULL;\n\t\t\tsp_found = 1;\n\t\t\tqla_put_fw_resources(qpair, &sp->iores);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\tif (cmdsp_found && sp->cmd_sp) {\n\t\t \n\t\tsp->cmd_sp->done(sp->cmd_sp, QLA_OS_TIMER_EXPIRED);\n\t}\n\n\tif (sp_found) {\n\t\tabt->u.abt.comp_status = cpu_to_le16(CS_TIMEOUT);\n\t\tsp->done(sp, QLA_OS_TIMER_EXPIRED);\n\t}\n}\n\nstatic void qla24xx_abort_sp_done(srb_t *sp, int res)\n{\n\tstruct srb_iocb *abt = &sp->u.iocb_cmd;\n\tsrb_t *orig_sp = sp->cmd_sp;\n\n\tif (orig_sp)\n\t\tqla_wait_nvme_release_cmd_kref(orig_sp);\n\n\tif (sp->flags & SRB_WAKEUP_ON_COMP)\n\t\tcomplete(&abt->u.abt.comp);\n\telse\n\t\t \n\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint qla24xx_async_abort_cmd(srb_t *cmd_sp, bool wait)\n{\n\tscsi_qla_host_t *vha = cmd_sp->vha;\n\tstruct srb_iocb *abt_iocb;\n\tsrb_t *sp;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\t \n\tsp = qla2xxx_get_qpair_sp(cmd_sp->vha, cmd_sp->qpair, cmd_sp->fcport,\n\t\t\t\t  GFP_ATOMIC);\n\tif (!sp)\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\n\tqla_vha_mark_busy(vha);\n\tabt_iocb = &sp->u.iocb_cmd;\n\tsp->type = SRB_ABT_CMD;\n\tsp->name = \"abort\";\n\tsp->qpair = cmd_sp->qpair;\n\tsp->cmd_sp = cmd_sp;\n\tif (wait)\n\t\tsp->flags = SRB_WAKEUP_ON_COMP;\n\n\tinit_completion(&abt_iocb->u.abt.comp);\n\t \n\tqla2x00_init_async_sp(sp, 42, qla24xx_abort_sp_done);\n\tsp->u.iocb_cmd.timeout = qla24xx_abort_iocb_timeout;\n\n\tabt_iocb->u.abt.cmd_hndl = cmd_sp->handle;\n\tabt_iocb->u.abt.req_que_no = cpu_to_le16(cmd_sp->qpair->req->id);\n\n\tql_dbg(ql_dbg_async, vha, 0x507c,\n\t       \"Abort command issued - hdl=%x, type=%x\\n\", cmd_sp->handle,\n\t       cmd_sp->type);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\t\treturn rval;\n\t}\n\n\tif (wait) {\n\t\twait_for_completion(&abt_iocb->u.abt.comp);\n\t\trval = abt_iocb->u.abt.comp_status == CS_COMPLETE ?\n\t\t\tQLA_SUCCESS : QLA_ERR_FROM_FW;\n\t\t \n\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\t}\n\n\treturn rval;\n}\n\nvoid\nqla2x00_async_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tfc_port_t *fcport = sp->fcport;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tint rc, h;\n\tunsigned long flags;\n\n\tif (fcport) {\n\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x2071,\n\t\t    \"Async-%s timeout - hdl=%x portid=%06x %8phC.\\n\",\n\t\t    sp->name, sp->handle, fcport->d_id.b24, fcport->port_name);\n\n\t\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\t} else {\n\t\tpr_info(\"Async-%s timeout - hdl=%x.\\n\",\n\t\t    sp->name, sp->handle);\n\t}\n\n\tswitch (sp->type) {\n\tcase SRB_LOGIN_CMD:\n\t\trc = qla24xx_async_abort_cmd(sp, false);\n\t\tif (rc) {\n\t\t\t \n\t\t\tlio->u.logio.data[0] = MBS_COMMAND_ERROR;\n\t\t\tlio->u.logio.data[1] =\n\t\t\t\tlio->u.logio.flags & SRB_LOGIN_RETRIED ?\n\t\t\t\tQLA_LOGIO_LOGIN_RETRIED : 0;\n\t\t\tspin_lock_irqsave(sp->qpair->qp_lock_ptr, flags);\n\t\t\tfor (h = 1; h < sp->qpair->req->num_outstanding_cmds;\n\t\t\t    h++) {\n\t\t\t\tif (sp->qpair->req->outstanding_cmds[h] ==\n\t\t\t\t    sp) {\n\t\t\t\t\tsp->qpair->req->outstanding_cmds[h] =\n\t\t\t\t\t    NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(sp->qpair->qp_lock_ptr, flags);\n\t\t\tsp->done(sp, QLA_FUNCTION_TIMEOUT);\n\t\t}\n\t\tbreak;\n\tcase SRB_LOGOUT_CMD:\n\tcase SRB_CT_PTHRU_CMD:\n\tcase SRB_MB_IOCB:\n\tcase SRB_NACK_PLOGI:\n\tcase SRB_NACK_PRLI:\n\tcase SRB_NACK_LOGO:\n\tcase SRB_CTRL_VP:\n\tdefault:\n\t\trc = qla24xx_async_abort_cmd(sp, false);\n\t\tif (rc) {\n\t\t\tspin_lock_irqsave(sp->qpair->qp_lock_ptr, flags);\n\t\t\tfor (h = 1; h < sp->qpair->req->num_outstanding_cmds;\n\t\t\t    h++) {\n\t\t\t\tif (sp->qpair->req->outstanding_cmds[h] ==\n\t\t\t\t    sp) {\n\t\t\t\t\tsp->qpair->req->outstanding_cmds[h] =\n\t\t\t\t\t    NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(sp->qpair->qp_lock_ptr, flags);\n\t\t\tsp->done(sp, QLA_FUNCTION_TIMEOUT);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void qla2x00_async_login_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tstruct event_arg ea;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20dd,\n\t    \"%s %8phC res %d \\n\", __func__, sp->fcport->port_name, res);\n\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\n\tif (!test_bit(UNLOADING, &vha->dpc_flags)) {\n\t\tmemset(&ea, 0, sizeof(ea));\n\t\tea.fcport = sp->fcport;\n\t\tea.data[0] = lio->u.logio.data[0];\n\t\tea.data[1] = lio->u.logio.data[1];\n\t\tea.iop[0] = lio->u.logio.iop[0];\n\t\tea.iop[1] = lio->u.logio.iop[1];\n\t\tea.sp = sp;\n\t\tif (res)\n\t\t\tea.data[0] = MBS_COMMAND_ERROR;\n\t\tqla24xx_handle_plogi_done_event(vha, &ea);\n\t}\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint\nqla2x00_async_login(struct scsi_qla_host *vha, fc_port_t *fcport,\n    uint16_t *data)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT) ||\n\t    fcport->loop_id == FC_NO_LOOP_ID) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"%s: %8phC - not sending command.\\n\",\n\t\t    __func__, fcport->port_name);\n\t\treturn rval;\n\t}\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_PEND);\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tfcport->logout_completed = 0;\n\n\tsp->type = SRB_LOGIN_CMD;\n\tsp->name = \"login\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_login_sp_done);\n\n\tlio = &sp->u.iocb_cmd;\n\tif (N2N_TOPO(fcport->vha->hw) && fcport_is_bigger(fcport)) {\n\t\tlio->u.logio.flags |= SRB_LOGIN_PRLI_ONLY;\n\t} else {\n\t\tif (vha->hw->flags.edif_enabled &&\n\t\t    DBELL_ACTIVE(vha)) {\n\t\t\tlio->u.logio.flags |=\n\t\t\t\t(SRB_LOGIN_FCSP | SRB_LOGIN_SKIP_PRLI);\n\t\t} else {\n\t\t\tlio->u.logio.flags |= SRB_LOGIN_COND_PLOGI;\n\t\t}\n\t}\n\n\tif (NVME_TARGET(vha->hw, fcport))\n\t\tlio->u.logio.flags |= SRB_LOGIN_SKIP_PRLI;\n\n\trval = qla2x00_start_sp(sp);\n\n\tql_dbg(ql_dbg_disc, vha, 0x2072,\n\t       \"Async-login - %8phC hdl=%x, loopid=%x portid=%06x retries=%d %s.\\n\",\n\t       fcport->port_name, sp->handle, fcport->loop_id,\n\t       fcport->d_id.b24, fcport->login_retry,\n\t       lio->u.logio.flags & SRB_LOGIN_FCSP ? \"FCSP\" : \"\");\n\n\tif (rval != QLA_SUCCESS) {\n\t\tfcport->flags |= FCF_LOGIN_NEEDED;\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\tfcport->flags &= ~FCF_ASYNC_SENT;\ndone:\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\n\t \n\tqla2x00_set_fcport_disc_state(fcport, DSC_DELETED);\n\treturn rval;\n}\n\nstatic void qla2x00_async_logout_sp_done(srb_t *sp, int res)\n{\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\tsp->fcport->login_gen++;\n\tqlt_logo_completion_handler(sp->fcport, sp->u.iocb_cmd.u.logio.data[0]);\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint\nqla2x00_async_logout(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tsrb_t *sp;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_LOGOUT_CMD;\n\tsp->name = \"logout\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_logout_sp_done),\n\n\tql_dbg(ql_dbg_disc, vha, 0x2070,\n\t    \"Async-logout - hdl=%x loop-id=%x portid=%02x%02x%02x %8phC explicit %d.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b.domain,\n\t\tfcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t\tfcport->port_name, fcport->explicit_logout);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\treturn rval;\n}\n\nvoid\nqla2x00_async_prlo_done(struct scsi_qla_host *vha, fc_port_t *fcport,\n    uint16_t *data)\n{\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\t \n\tif (!fcport->tgt_session)\n\t\tqla2x00_mark_device_lost(vha, fcport, 1);\n\tqlt_logo_completion_handler(fcport, data[0]);\n}\n\nstatic void qla2x00_async_prlo_sp_done(srb_t *sp, int res)\n{\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tstruct scsi_qla_host *vha = sp->vha;\n\n\tsp->fcport->flags &= ~FCF_ASYNC_ACTIVE;\n\tif (!test_bit(UNLOADING, &vha->dpc_flags))\n\t\tqla2x00_post_async_prlo_done_work(sp->fcport->vha, sp->fcport,\n\t\t    lio->u.logio.data);\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint\nqla2x00_async_prlo(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tsrb_t *sp;\n\tint rval;\n\n\trval = QLA_FUNCTION_FAILED;\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_PRLO_CMD;\n\tsp->name = \"prlo\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_prlo_sp_done);\n\n\tql_dbg(ql_dbg_disc, vha, 0x2070,\n\t    \"Async-prlo - hdl=%x loop-id=%x portid=%02x%02x%02x.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b.domain,\n\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\treturn rval;\n}\n\nstatic\nvoid qla24xx_handle_adisc_event(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tstruct fc_port *fcport = ea->fcport;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d2,\n\t    \"%s %8phC DS %d LS %d rc %d login %d|%d rscn %d|%d lid %d\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, ea->rc, fcport->login_gen, ea->sp->gen2,\n\t    fcport->rscn_gen, ea->sp->gen1, fcport->loop_id);\n\n\tWARN_ONCE(!qla2xxx_is_valid_mbs(ea->data[0]), \"mbs: %#x\\n\",\n\t\t  ea->data[0]);\n\n\tif (ea->data[0] != MBS_COMMAND_COMPLETE) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2066,\n\t\t    \"%s %8phC: adisc fail: post delete\\n\",\n\t\t    __func__, ea->fcport->port_name);\n\n\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\t \n\t\tif (fcport->deleted == QLA_SESS_DELETED)\n\t\t\tfcport->deleted = 0;\n\n\t\tfcport->logout_on_delete = 1;\n\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\t\tqlt_schedule_sess_for_deletion(ea->fcport);\n\t\treturn;\n\t}\n\n\tif (ea->fcport->disc_state == DSC_DELETE_PEND)\n\t\treturn;\n\n\tif (ea->sp->gen2 != ea->fcport->login_gen) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC generation changed\\n\",\n\t\t    __func__, ea->fcport->port_name);\n\t\treturn;\n\t} else if (ea->sp->gen1 != ea->fcport->rscn_gen) {\n\t\tqla_rscn_replay(fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t}\n\n\t__qla24xx_handle_gpdb_event(vha, ea);\n}\n\nstatic int qla_post_els_plogi_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_ELS_PLOGI);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\tfcport->flags |= FCF_ASYNC_ACTIVE;\n\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_PEND);\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void qla2x00_async_adisc_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct event_arg ea;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2066,\n\t    \"Async done-%s res %x %8phC\\n\",\n\t    sp->name, res, sp->fcport->port_name);\n\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\n\tmemset(&ea, 0, sizeof(ea));\n\tea.rc = res;\n\tea.data[0] = lio->u.logio.data[0];\n\tea.data[1] = lio->u.logio.data[1];\n\tea.iop[0] = lio->u.logio.iop[0];\n\tea.iop[1] = lio->u.logio.iop[1];\n\tea.fcport = sp->fcport;\n\tea.sp = sp;\n\tif (res)\n\t\tea.data[0] = MBS_COMMAND_ERROR;\n\n\tqla24xx_handle_adisc_event(vha, &ea);\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint\nqla2x00_async_adisc(struct scsi_qla_host *vha, fc_port_t *fcport,\n    uint16_t *data)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (IS_SESSION_DELETED(fcport)) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t       \"%s: %8phC is being delete - not sending command.\\n\",\n\t\t       __func__, fcport->port_name);\n\t\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\t\treturn rval;\n\t}\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT))\n\t\treturn rval;\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_ADISC_CMD;\n\tsp->name = \"adisc\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_adisc_sp_done);\n\n\tif (data[1] & QLA_LOGIO_LOGIN_RETRIED) {\n\t\tlio = &sp->u.iocb_cmd;\n\t\tlio->u.logio.flags |= SRB_LOGIN_RETRIED;\n\t}\n\n\tql_dbg(ql_dbg_disc, vha, 0x206f,\n\t    \"Async-adisc - hdl=%x loopid=%x portid=%06x %8phC.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b24, fcport->port_name);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\tqla2x00_post_async_adisc_work(vha, fcport, data);\n\treturn rval;\n}\n\nstatic bool qla2x00_is_reserved_id(scsi_qla_host_t *vha, uint16_t loop_id)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_FWI2_CAPABLE(ha))\n\t\treturn loop_id > NPH_LAST_HANDLE;\n\n\treturn (loop_id > ha->max_loop_id && loop_id < SNS_FIRST_LOOP_ID) ||\n\t\tloop_id == MANAGEMENT_SERVER || loop_id == BROADCAST;\n}\n\n \nstatic int qla2x00_find_new_loop_id(scsi_qla_host_t *vha, fc_port_t *dev)\n{\n\tint\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags = 0;\n\n\trval = QLA_SUCCESS;\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\n\tdev->loop_id = find_first_zero_bit(ha->loop_id_map, LOOPID_MAP_SIZE);\n\tif (dev->loop_id >= LOOPID_MAP_SIZE ||\n\t    qla2x00_is_reserved_id(vha, dev->loop_id)) {\n\t\tdev->loop_id = FC_NO_LOOP_ID;\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tset_bit(dev->loop_id, ha->loop_id_map);\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\tif (rval == QLA_SUCCESS)\n\t\tql_dbg(ql_dbg_disc, dev->vha, 0x2086,\n\t\t       \"Assigning new loopid=%x, portid=%x.\\n\",\n\t\t       dev->loop_id, dev->d_id.b24);\n\telse\n\t\tql_log(ql_log_warn, dev->vha, 0x2087,\n\t\t       \"No loop_id's available, portid=%x.\\n\",\n\t\t       dev->d_id.b24);\n\n\treturn rval;\n}\n\nvoid qla2x00_clear_loop_id(fc_port_t *fcport)\n{\n\tstruct qla_hw_data *ha = fcport->vha->hw;\n\n\tif (fcport->loop_id == FC_NO_LOOP_ID ||\n\t    qla2x00_is_reserved_id(fcport->vha, fcport->loop_id))\n\t\treturn;\n\n\tclear_bit(fcport->loop_id, ha->loop_id_map);\n\tfcport->loop_id = FC_NO_LOOP_ID;\n}\n\nstatic void qla24xx_handle_gnl_done_event(scsi_qla_host_t *vha,\n\tstruct event_arg *ea)\n{\n\tfc_port_t *fcport, *conflict_fcport;\n\tstruct get_name_list_extended *e;\n\tu16 i, n, found = 0, loop_id;\n\tport_id_t id;\n\tu64 wwn;\n\tu16 data[2];\n\tu8 current_login_state, nvme_cls;\n\n\tfcport = ea->fcport;\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"%s %8phC DS %d LS rc %d %d login %d|%d rscn %d|%d lid %d edif %d\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, ea->rc,\n\t    fcport->login_gen, fcport->last_login_gen,\n\t    fcport->rscn_gen, fcport->last_rscn_gen, vha->loop_id, fcport->edif.enable);\n\n\tif (fcport->disc_state == DSC_DELETE_PEND)\n\t\treturn;\n\n\tif (ea->rc) {  \n\t\tif (fcport->login_retry == 0) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20de,\n\t\t\t    \"GNL failed Port login retry %8phN, retry cnt=%d.\\n\",\n\t\t\t    fcport->port_name, fcport->login_retry);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (fcport->last_rscn_gen != fcport->rscn_gen) {\n\t\tqla_rscn_replay(fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t} else if (fcport->last_login_gen != fcport->login_gen) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e0,\n\t\t    \"%s %8phC login gen changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t}\n\n\tn = ea->data[0] / sizeof(struct get_name_list_extended);\n\n\tql_dbg(ql_dbg_disc, vha, 0x20e1,\n\t    \"%s %d %8phC n %d %02x%02x%02x lid %d \\n\",\n\t    __func__, __LINE__, fcport->port_name, n,\n\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t    fcport->d_id.b.al_pa, fcport->loop_id);\n\n\tfor (i = 0; i < n; i++) {\n\t\te = &vha->gnl.l[i];\n\t\twwn = wwn_to_u64(e->port_name);\n\t\tid.b.domain = e->port_id[2];\n\t\tid.b.area = e->port_id[1];\n\t\tid.b.al_pa = e->port_id[0];\n\t\tid.b.rsvd_1 = 0;\n\n\t\tif (memcmp((u8 *)&wwn, fcport->port_name, WWN_SIZE))\n\t\t\tcontinue;\n\n\t\tif (IS_SW_RESV_ADDR(id))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\n\t\tloop_id = le16_to_cpu(e->nport_handle);\n\t\tloop_id = (loop_id & 0x7fff);\n\t\tnvme_cls = e->current_login_state >> 4;\n\t\tcurrent_login_state = e->current_login_state & 0xf;\n\n\t\tif (PRLI_PHASE(nvme_cls)) {\n\t\t\tcurrent_login_state = nvme_cls;\n\t\t\tfcport->fc4_type &= ~FS_FC4TYPE_FCP;\n\t\t\tfcport->fc4_type |= FS_FC4TYPE_NVME;\n\t\t} else if (PRLI_PHASE(current_login_state)) {\n\t\t\tfcport->fc4_type |= FS_FC4TYPE_FCP;\n\t\t\tfcport->fc4_type &= ~FS_FC4TYPE_NVME;\n\t\t}\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e2,\n\t\t    \"%s found %8phC CLS [%x|%x] fc4_type %d ID[%06x|%06x] lid[%d|%d]\\n\",\n\t\t    __func__, fcport->port_name,\n\t\t    e->current_login_state, fcport->fw_login_state,\n\t\t    fcport->fc4_type, id.b24, fcport->d_id.b24,\n\t\t    loop_id, fcport->loop_id);\n\n\t\tswitch (fcport->disc_state) {\n\t\tcase DSC_DELETE_PEND:\n\t\tcase DSC_DELETED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ((id.b24 != fcport->d_id.b24 &&\n\t\t\t    fcport->d_id.b24 &&\n\t\t\t    fcport->loop_id != FC_NO_LOOP_ID) ||\n\t\t\t    (fcport->loop_id != FC_NO_LOOP_ID &&\n\t\t\t\tfcport->loop_id != loop_id)) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20e3,\n\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tif (fcport->n2n_flag)\n\t\t\t\t\tfcport->d_id.b24 = 0;\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tfcport->loop_id = loop_id;\n\t\tif (fcport->n2n_flag)\n\t\t\tfcport->d_id.b24 = id.b24;\n\n\t\twwn = wwn_to_u64(fcport->port_name);\n\t\tqlt_find_sess_invalidate_other(vha, wwn,\n\t\t\tid, loop_id, &conflict_fcport);\n\n\t\tif (conflict_fcport) {\n\t\t\t \n\t\t\tconflict_fcport->conflict = fcport;\n\t\t\tfcport->login_pause = 1;\n\t\t}\n\n\t\tswitch (vha->hw->current_topology) {\n\t\tdefault:\n\t\t\tswitch (current_login_state) {\n\t\t\tcase DSC_LS_PRLI_COMP:\n\t\t\t\tql_dbg(ql_dbg_disc,\n\t\t\t\t    vha, 0x20e4, \"%s %d %8phC post gpdb\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\n\t\t\t\tif ((e->prli_svc_param_word_3[0] & BIT_4) == 0)\n\t\t\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\t\t\telse\n\t\t\t\t\tfcport->port_type = FCT_TARGET;\n\t\t\t\tdata[0] = data[1] = 0;\n\t\t\t\tqla2x00_post_async_adisc_work(vha, fcport,\n\t\t\t\t    data);\n\t\t\t\tbreak;\n\t\t\tcase DSC_LS_PLOGI_COMP:\n\t\t\t\tif (vha->hw->flags.edif_enabled) {\n\t\t\t\t\t \n\t\t\t\t\tqla24xx_post_gpdb_work(vha, fcport, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase DSC_LS_PORT_UNAVAIL:\n\t\t\tdefault:\n\t\t\t\tif (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\t\t\t\tqla2x00_find_new_loop_id(vha, fcport);\n\t\t\t\t\tfcport->fw_login_state =\n\t\t\t\t\t    DSC_LS_PORT_UNAVAIL;\n\t\t\t\t}\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20e5,\n\t\t\t\t    \"%s %d %8phC\\n\", __func__, __LINE__,\n\t\t\t\t    fcport->port_name);\n\t\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ISP_CFG_N:\n\t\t\tfcport->fw_login_state = current_login_state;\n\t\t\tfcport->d_id = id;\n\t\t\tswitch (current_login_state) {\n\t\t\tcase DSC_LS_PRLI_PEND:\n\t\t\t\t \n\t\t\t\tqla2x00_set_fcport_disc_state(fcport,\n\t\t\t\t    DSC_DELETED);\n\t\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\t\tbreak;\n\t\t\tcase DSC_LS_PRLI_COMP:\n\t\t\t\tif ((e->prli_svc_param_word_3[0] & BIT_4) == 0)\n\t\t\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\t\t\telse\n\t\t\t\t\tfcport->port_type = FCT_TARGET;\n\n\t\t\t\tdata[0] = data[1] = 0;\n\t\t\t\tqla2x00_post_async_adisc_work(vha, fcport,\n\t\t\t\t    data);\n\t\t\t\tbreak;\n\t\t\tcase DSC_LS_PLOGI_COMP:\n\t\t\t\tif (vha->hw->flags.edif_enabled &&\n\t\t\t\t    DBELL_ACTIVE(vha)) {\n\t\t\t\t\t \n\t\t\t\t\tqla24xx_post_gpdb_work(vha, fcport, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fcport_is_bigger(fcport)) {\n\t\t\t\t\t \n\t\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID)\n\t\t\t\t\t\tqla2x00_clear_loop_id(fcport);\n\n\t\t\t\t\tfcport->loop_id = loop_id;\n\t\t\t\t\tqla24xx_fcport_handle_login(vha,\n\t\t\t\t\t    fcport);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tif (fcport_is_smaller(fcport)) {\n\t\t\t\t\t \n\t\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID)\n\t\t\t\t\t\tqla2x00_clear_loop_id(fcport);\n\n\t\t\t\t\tfcport->loop_id = loop_id;\n\t\t\t\t\tqla24xx_fcport_handle_login(vha,\n\t\t\t\t\t    fcport);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}  \n\t}\n\n\tif (!found) {\n\t\tswitch (vha->hw->current_topology) {\n\t\tcase ISP_CFG_F:\n\t\tcase ISP_CFG_FL:\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\te = &vha->gnl.l[i];\n\t\t\t\tid.b.domain = e->port_id[0];\n\t\t\t\tid.b.area = e->port_id[1];\n\t\t\t\tid.b.al_pa = e->port_id[2];\n\t\t\t\tid.b.rsvd_1 = 0;\n\t\t\t\tloop_id = le16_to_cpu(e->nport_handle);\n\n\t\t\t\tif (fcport->d_id.b24 == id.b24) {\n\t\t\t\t\tconflict_fcport =\n\t\t\t\t\t    qla2x00_find_fcport_by_wwpn(vha,\n\t\t\t\t\t\te->port_name, 0);\n\t\t\t\t\tif (conflict_fcport) {\n\t\t\t\t\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose,\n\t\t\t\t\t\t    vha, 0x20e5,\n\t\t\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t\t\t    __func__, __LINE__,\n\t\t\t\t\t\t    conflict_fcport->port_name);\n\t\t\t\t\t\tqlt_schedule_sess_for_deletion\n\t\t\t\t\t\t\t(conflict_fcport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (fcport->loop_id == loop_id)\n\t\t\t\t\tfcport->loop_id = FC_NO_LOOP_ID;\n\t\t\t}\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\tbreak;\n\t\tcase ISP_CFG_N:\n\t\t\tqla2x00_set_fcport_disc_state(fcport, DSC_DELETED);\n\t\t\tif (time_after_eq(jiffies, fcport->dm_login_expire)) {\n\t\t\t\tif (fcport->n2n_link_reset_cnt < 2) {\n\t\t\t\t\tfcport->n2n_link_reset_cnt++;\n\t\t\t\t\t \n\t\t\t\t\tset_bit(N2N_LINK_RESET,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t} else {\n\t\t\t\t\tif (fcport->n2n_chip_reset < 1) {\n\t\t\t\t\t\tql_log(ql_log_info, vha, 0x705d,\n\t\t\t\t\t\t    \"Chip reset to bring laser down\");\n\t\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\t\tfcport->n2n_chip_reset++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tql_log(ql_log_info, vha, 0x705d,\n\t\t\t\t\t\t    \"Remote port %8ph is not coming back\\n\",\n\t\t\t\t\t\t    fcport->port_name);\n\t\t\t\t\t\tfcport->scan_state = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ISP_CFG_NL:\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}  \n\nstatic void qla24xx_async_gnl_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tunsigned long flags;\n\tstruct fc_port *fcport = NULL, *tf;\n\tu16 i, n = 0, loop_id;\n\tstruct event_arg ea;\n\tstruct get_name_list_extended *e;\n\tu64 wwn;\n\tstruct list_head h;\n\tbool found = false;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20e7,\n\t    \"Async done-%s res %x mb[1]=%x mb[2]=%x \\n\",\n\t    sp->name, res, sp->u.iocb_cmd.u.mbx.in_mb[1],\n\t    sp->u.iocb_cmd.u.mbx.in_mb[2]);\n\n\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT|FCF_ASYNC_ACTIVE);\n\tmemset(&ea, 0, sizeof(ea));\n\tea.sp = sp;\n\tea.rc = res;\n\n\tif (sp->u.iocb_cmd.u.mbx.in_mb[1] >=\n\t    sizeof(struct get_name_list_extended)) {\n\t\tn = sp->u.iocb_cmd.u.mbx.in_mb[1] /\n\t\t    sizeof(struct get_name_list_extended);\n\t\tea.data[0] = sp->u.iocb_cmd.u.mbx.in_mb[1];  \n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\te = &vha->gnl.l[i];\n\t\tloop_id = le16_to_cpu(e->nport_handle);\n\t\t \n\t\tloop_id = (loop_id & 0x7fff);\n\t\tset_bit(loop_id, vha->hw->loop_id_map);\n\t\twwn = wwn_to_u64(e->port_name);\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e8,\n\t\t    \"%s %8phC %02x:%02x:%02x CLS %x/%x lid %x \\n\",\n\t\t    __func__, &wwn, e->port_id[2], e->port_id[1],\n\t\t    e->port_id[0], e->current_login_state, e->last_login_state,\n\t\t    (loop_id & 0x7fff));\n\t}\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\n\tINIT_LIST_HEAD(&h);\n\tfcport = tf = NULL;\n\tif (!list_empty(&vha->gnl.fcports))\n\t\tlist_splice_init(&vha->gnl.fcports, &h);\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\tlist_for_each_entry_safe(fcport, tf, &h, gnl_entry) {\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\tlist_del_init(&fcport->gnl_entry);\n\t\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\tea.fcport = fcport;\n\n\t\tqla24xx_handle_gnl_done_event(vha, &ea);\n\t}\n\n\t \n\tfor (i = 0; i < n; i++) {\n\t\tport_id_t id;\n\t\tu64 wwnn;\n\n\t\te = &vha->gnl.l[i];\n\t\twwn = wwn_to_u64(e->port_name);\n\n\t\tfound = false;\n\t\tlist_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {\n\t\t\tif (!memcmp((u8 *)&wwn, fcport->port_name,\n\t\t\t    WWN_SIZE)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tid.b.domain = e->port_id[2];\n\t\tid.b.area = e->port_id[1];\n\t\tid.b.al_pa = e->port_id[0];\n\t\tid.b.rsvd_1 = 0;\n\n\t\tif (!found && wwn && !IS_SW_RESV_ADDR(id)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2065,\n\t\t\t    \"%s %d %8phC %06x post new sess\\n\",\n\t\t\t    __func__, __LINE__, (u8 *)&wwn, id.b24);\n\t\t\twwnn = wwn_to_u64(e->node_name);\n\t\t\tqla24xx_post_newsess_work(vha, &id, (u8 *)&wwn,\n\t\t\t    (u8 *)&wwnn, NULL, 0);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tvha->gnl.sent = 0;\n\tif (!list_empty(&vha->gnl.fcports)) {\n\t\t \n\t\tlist_for_each_entry_safe(fcport, tf, &vha->gnl.fcports,\n\t\t    gnl_entry) {\n\t\t\tlist_del_init(&fcport->gnl_entry);\n\t\t\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\t\t\tif (qla24xx_post_gnl_work(vha, fcport) == QLA_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint qla24xx_async_gnl(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tsrb_t *sp;\n\tint rval = QLA_FUNCTION_FAILED;\n\tunsigned long flags;\n\tu16 *mb;\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT))\n\t\tgoto done;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d9,\n\t    \"Async-gnlist WWPN %8phC \\n\", fcport->port_name);\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tqla2x00_set_fcport_disc_state(fcport, DSC_GNL);\n\tfcport->last_rscn_gen = fcport->rscn_gen;\n\tfcport->last_login_gen = fcport->login_gen;\n\n\tlist_add_tail(&fcport->gnl_entry, &vha->gnl.fcports);\n\tif (vha->gnl.sent) {\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\treturn QLA_SUCCESS;\n\t}\n\tvha->gnl.sent = 1;\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_MB_IOCB;\n\tsp->name = \"gnlist\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla24xx_async_gnl_sp_done);\n\n\tmb = sp->u.iocb_cmd.u.mbx.out_mb;\n\tmb[0] = MBC_PORT_NODE_NAME_LIST;\n\tmb[1] = BIT_2 | BIT_3;\n\tmb[2] = MSW(vha->gnl.ldma);\n\tmb[3] = LSW(vha->gnl.ldma);\n\tmb[6] = MSW(MSD(vha->gnl.ldma));\n\tmb[7] = LSW(MSD(vha->gnl.ldma));\n\tmb[8] = vha->gnl.size;\n\tmb[9] = vha->vp_idx;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20da,\n\t    \"Async-%s - OUT WWPN %8phC hndl %x\\n\",\n\t    sp->name, fcport->port_name, sp->handle);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\tfcport->flags &= ~(FCF_ASYNC_SENT);\ndone:\n\tfcport->flags &= ~(FCF_ASYNC_ACTIVE);\n\treturn rval;\n}\n\nint qla24xx_post_gnl_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_GNL);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\tfcport->flags |= FCF_ASYNC_ACTIVE;\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void qla24xx_async_gpdb_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tfc_port_t *fcport = sp->fcport;\n\tu16 *mb = sp->u.iocb_cmd.u.mbx.in_mb;\n\tstruct event_arg ea;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20db,\n\t    \"Async done-%s res %x, WWPN %8phC mb[1]=%x mb[2]=%x \\n\",\n\t    sp->name, res, fcport->port_name, mb[1], mb[2]);\n\n\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\n\tif (res == QLA_FUNCTION_TIMEOUT)\n\t\tgoto done;\n\n\tmemset(&ea, 0, sizeof(ea));\n\tea.fcport = fcport;\n\tea.sp = sp;\n\n\tqla24xx_handle_gpdb_event(vha, &ea);\n\ndone:\n\tdma_pool_free(ha->s_dma_pool, sp->u.iocb_cmd.u.mbx.in,\n\t\tsp->u.iocb_cmd.u.mbx.in_dma);\n\n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint qla24xx_post_prli_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\tif (vha->host->active_mode == MODE_TARGET)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_PRLI);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void qla2x00_async_prli_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct srb_iocb *lio = &sp->u.iocb_cmd;\n\tstruct event_arg ea;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2129,\n\t    \"%s %8phC res %x\\n\", __func__,\n\t    sp->fcport->port_name, res);\n\n\tsp->fcport->flags &= ~FCF_ASYNC_SENT;\n\n\tif (!test_bit(UNLOADING, &vha->dpc_flags)) {\n\t\tmemset(&ea, 0, sizeof(ea));\n\t\tea.fcport = sp->fcport;\n\t\tea.data[0] = lio->u.logio.data[0];\n\t\tea.data[1] = lio->u.logio.data[1];\n\t\tea.iop[0] = lio->u.logio.iop[0];\n\t\tea.iop[1] = lio->u.logio.iop[1];\n\t\tea.sp = sp;\n\t\tif (res == QLA_OS_TIMER_EXPIRED)\n\t\t\tea.data[0] = QLA_OS_TIMER_EXPIRED;\n\t\telse if (res)\n\t\t\tea.data[0] = MBS_COMMAND_ERROR;\n\n\t\tqla24xx_handle_prli_done_event(vha, &ea);\n\t}\n\n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint\nqla24xx_async_prli(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *lio;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (!vha->flags.online) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff, \"%s %d %8phC exit\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\treturn rval;\n\t}\n\n\tif ((fcport->fw_login_state == DSC_LS_PLOGI_PEND ||\n\t    fcport->fw_login_state == DSC_LS_PRLI_PEND) &&\n\t    qla_dual_mode_enabled(vha)) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff, \"%s %d %8phC exit\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\treturn rval;\n\t}\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\treturn rval;\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tfcport->logout_completed = 0;\n\n\tsp->type = SRB_PRLI_CMD;\n\tsp->name = \"prli\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_prli_sp_done);\n\n\tlio = &sp->u.iocb_cmd;\n\tlio->u.logio.flags = 0;\n\n\tif (NVME_TARGET(vha->hw, fcport))\n\t\tlio->u.logio.flags |= SRB_LOGIN_NVME_PRLI;\n\n\tql_dbg(ql_dbg_disc, vha, 0x211b,\n\t    \"Async-prli - %8phC hdl=%x, loopid=%x portid=%06x retries=%d fc4type %x priority %x %s.\\n\",\n\t    fcport->port_name, sp->handle, fcport->loop_id, fcport->d_id.b24,\n\t    fcport->login_retry, fcport->fc4_type, vha->hw->fc4_type_priority,\n\t    NVME_TARGET(vha->hw, fcport) ? \"nvme\" : \"fcp\");\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tfcport->flags |= FCF_LOGIN_NEEDED;\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\tfcport->flags &= ~FCF_ASYNC_SENT;\n\treturn rval;\n}\n\nint qla24xx_post_gpdb_work(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_GPDB);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\te->u.fcport.opt = opt;\n\tfcport->flags |= FCF_ASYNC_ACTIVE;\n\treturn qla2x00_post_work(vha, e);\n}\n\nint qla24xx_async_gpdb(struct scsi_qla_host *vha, fc_port_t *fcport, u8 opt)\n{\n\tsrb_t *sp;\n\tstruct srb_iocb *mbx;\n\tint rval = QLA_FUNCTION_FAILED;\n\tu16 *mb;\n\tdma_addr_t pd_dma;\n\tstruct port_database_24xx *pd;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_SESSION_DELETED(fcport)) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t       \"%s: %8phC is being delete - not sending command.\\n\",\n\t\t       __func__, fcport->port_name);\n\t\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\t\treturn rval;\n\t}\n\n\tif (!vha->flags.online || fcport->flags & FCF_ASYNC_SENT) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"%s: %8phC online %d flags %x - not sending command.\\n\",\n\t\t    __func__, fcport->port_name, vha->flags.online, fcport->flags);\n\t\tgoto done;\n\t}\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tqla2x00_set_fcport_disc_state(fcport, DSC_GPDB);\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tsp->type = SRB_MB_IOCB;\n\tsp->name = \"gpdb\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla24xx_async_gpdb_sp_done);\n\n\tpd = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);\n\tif (pd == NULL) {\n\t\tql_log(ql_log_warn, vha, 0xd043,\n\t\t    \"Failed to allocate port database structure.\\n\");\n\t\tgoto done_free_sp;\n\t}\n\n\tmb = sp->u.iocb_cmd.u.mbx.out_mb;\n\tmb[0] = MBC_GET_PORT_DATABASE;\n\tmb[1] = fcport->loop_id;\n\tmb[2] = MSW(pd_dma);\n\tmb[3] = LSW(pd_dma);\n\tmb[6] = MSW(MSD(pd_dma));\n\tmb[7] = LSW(MSD(pd_dma));\n\tmb[9] = vha->vp_idx;\n\tmb[10] = opt;\n\n\tmbx = &sp->u.iocb_cmd;\n\tmbx->u.mbx.in = (void *)pd;\n\tmbx->u.mbx.in_dma = pd_dma;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20dc,\n\t    \"Async-%s %8phC hndl %x opt %x\\n\",\n\t    sp->name, fcport->port_name, sp->handle, opt);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\treturn rval;\n\ndone_free_sp:\n\tif (pd)\n\t\tdma_pool_free(ha->s_dma_pool, pd, pd_dma);\n\n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\tfcport->flags &= ~FCF_ASYNC_SENT;\ndone:\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\tqla24xx_post_gpdb_work(vha, fcport, opt);\n\treturn rval;\n}\n\nstatic\nvoid __qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tea->fcport->login_gen++;\n\tea->fcport->logout_on_delete = 1;\n\n\tif (!ea->fcport->login_succ && !IS_SW_RESV_ADDR(ea->fcport->d_id)) {\n\t\tvha->fcport_count++;\n\t\tea->fcport->login_succ = 1;\n\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\tqla24xx_sched_upd_fcport(ea->fcport);\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t} else if (ea->fcport->login_succ) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x20d6,\n\t\t    \"%s %d %8phC session revalidate success\\n\",\n\t\t    __func__, __LINE__, ea->fcport->port_name);\n\t\tqla2x00_set_fcport_disc_state(ea->fcport, DSC_LOGIN_COMPLETE);\n\t}\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n}\n\nstatic int\tqla_chk_secure_login(scsi_qla_host_t\t*vha, fc_port_t *fcport,\n\tstruct port_database_24xx *pd)\n{\n\tint rc = 0;\n\n\tif (pd->secure_login) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x104d,\n\t\t    \"Secure Login established on %8phC\\n\",\n\t\t    fcport->port_name);\n\t\tfcport->flags |= FCF_FCSP_DEVICE;\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x104d,\n\t\t    \"non-Secure Login %8phC\",\n\t\t    fcport->port_name);\n\t\tfcport->flags &= ~FCF_FCSP_DEVICE;\n\t}\n\tif (vha->hw->flags.edif_enabled) {\n\t\tif (fcport->flags & FCF_FCSP_DEVICE) {\n\t\t\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_AUTH_PEND);\n\t\t\t \n\t\t\tfcport->edif.rx_sa_set = 0;\n\t\t\tfcport->edif.tx_sa_set = 0;\n\t\t\tfcport->edif.rx_sa_pending = 0;\n\t\t\tfcport->edif.tx_sa_pending = 0;\n\n\t\t\tqla2x00_post_aen_work(vha, FCH_EVT_PORT_ONLINE,\n\t\t\t    fcport->d_id.b24);\n\n\t\t\tif (DBELL_ACTIVE(vha)) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ef,\n\t\t\t\t    \"%s %d %8phC EDIF: post DB_AUTH: AUTH needed\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tfcport->edif.app_sess_online = 1;\n\n\t\t\t\tqla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_NEEDED,\n\t\t\t\t    fcport->d_id.b24, 0, fcport);\n\t\t\t}\n\n\t\t\trc = 1;\n\t\t} else if (qla_ini_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2117,\n\t\t\t    \"%s %d %8phC post prli\\n\",\n\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\tqla24xx_post_prli_work(vha, fcport);\n\t\t\trc = 1;\n\t\t}\n\t}\n\treturn rc;\n}\n\nstatic\nvoid qla24xx_handle_gpdb_event(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tfc_port_t *fcport = ea->fcport;\n\tstruct port_database_24xx *pd;\n\tstruct srb *sp = ea->sp;\n\tuint8_t\tls;\n\n\tpd = (struct port_database_24xx *)sp->u.iocb_cmd.u.mbx.in;\n\n\tfcport->flags &= ~FCF_ASYNC_SENT;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d2,\n\t    \"%s %8phC DS %d LS %x fc4_type %x rc %x\\n\", __func__,\n\t    fcport->port_name, fcport->disc_state, pd->current_login_state,\n\t    fcport->fc4_type, ea->rc);\n\n\tif (fcport->disc_state == DSC_DELETE_PEND) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d5, \"%s %d %8phC\\n\",\n\t\t       __func__, __LINE__, fcport->port_name);\n\t\treturn;\n\t}\n\n\tif (NVME_TARGET(vha->hw, fcport))\n\t\tls = pd->current_login_state >> 4;\n\telse\n\t\tls = pd->current_login_state & 0xf;\n\n\tif (ea->sp->gen2 != fcport->login_gen) {\n\t\t \n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC generation changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\treturn;\n\t} else if (ea->sp->gen1 != fcport->rscn_gen) {\n\t\tqla_rscn_replay(fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d5, \"%s %d %8phC, ls %x\\n\",\n\t\t       __func__, __LINE__, fcport->port_name, ls);\n\t\treturn;\n\t}\n\n\tswitch (ls) {\n\tcase PDS_PRLI_COMPLETE:\n\t\t__qla24xx_parse_gpdb(vha, fcport, pd);\n\t\tbreak;\n\tcase PDS_PLOGI_COMPLETE:\n\t\tif (qla_chk_secure_login(vha, fcport, pd)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20d5, \"%s %d %8phC, ls %x\\n\",\n\t\t\t       __func__, __LINE__, fcport->port_name, ls);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase PDS_PLOGI_PENDING:\n\tcase PDS_PRLI_PENDING:\n\tcase PDS_PRLI2_PENDING:\n\t\t \n\t\tif (qla_dual_mode_enabled(vha) ||\n\t\t    qla_ini_mode_enabled(vha)) {\n\t\t\tqla2x00_set_fcport_disc_state(fcport, DSC_GNL);\n\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t}\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d5, \"%s %d %8phC, ls %x\\n\",\n\t\t       __func__, __LINE__, fcport->port_name, ls);\n\t\treturn;\n\tcase PDS_LOGO_PENDING:\n\tcase PDS_PORT_UNAVAILABLE:\n\tdefault:\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d5, \"%s %d %8phC post del sess\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t}\n\t__qla24xx_handle_gpdb_event(vha, ea);\n}  \n\nstatic void qla_chk_n2n_b4_login(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tu8 login = 0;\n\tint rc;\n\n\tql_dbg(ql_dbg_disc, vha, 0x307b,\n\t    \"%s %8phC DS %d LS %d lid %d retries=%d\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, fcport->loop_id, fcport->login_retry);\n\n\tif (qla_tgt_mode_enabled(vha))\n\t\treturn;\n\n\tif (qla_dual_mode_enabled(vha)) {\n\t\tif (N2N_TOPO(vha->hw)) {\n\t\t\tu64 mywwn, wwn;\n\n\t\t\tmywwn = wwn_to_u64(vha->port_name);\n\t\t\twwn = wwn_to_u64(fcport->port_name);\n\t\t\tif (mywwn > wwn)\n\t\t\t\tlogin = 1;\n\t\t\telse if ((fcport->fw_login_state == DSC_LS_PLOGI_COMP)\n\t\t\t    && time_after_eq(jiffies,\n\t\t\t\t    fcport->plogi_nack_done_deadline))\n\t\t\t\tlogin = 1;\n\t\t} else {\n\t\t\tlogin = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tlogin = 1;\n\t}\n\n\tif (login && fcport->login_retry) {\n\t\tfcport->login_retry--;\n\t\tif (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\t\tfcport->fw_login_state = DSC_LS_PORT_UNAVAIL;\n\t\t\trc = qla2x00_find_new_loop_id(vha, fcport);\n\t\t\tif (rc) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20e6,\n\t\t\t\t    \"%s %d %8phC post del sess - out of loopid\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tfcport->scan_state = 0;\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tql_dbg(ql_dbg_disc, vha, 0x20bf,\n\t\t    \"%s %d %8phC post login\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\tqla2x00_post_async_login_work(vha, fcport, NULL);\n\t}\n}\n\nint qla24xx_fcport_handle_login(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tu16 data[2];\n\tu16 sec;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d8,\n\t    \"%s %8phC DS %d LS %d P %d fl %x confl %p rscn %d|%d login %d lid %d scan %d fc4type %x\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, fcport->login_pause, fcport->flags,\n\t    fcport->conflict, fcport->last_rscn_gen, fcport->rscn_gen,\n\t    fcport->login_gen, fcport->loop_id, fcport->scan_state,\n\t    fcport->fc4_type);\n\n\tif (fcport->scan_state != QLA_FCPORT_FOUND ||\n\t    fcport->disc_state == DSC_DELETE_PEND)\n\t\treturn 0;\n\n\tif ((fcport->loop_id != FC_NO_LOOP_ID) &&\n\t    qla_dual_mode_enabled(vha) &&\n\t    ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||\n\t     (fcport->fw_login_state == DSC_LS_PRLI_PEND)))\n\t\treturn 0;\n\n\tif (fcport->fw_login_state == DSC_LS_PLOGI_COMP &&\n\t    !N2N_TOPO(vha->hw)) {\n\t\tif (time_before_eq(jiffies, fcport->plogi_nack_done_deadline)) {\n\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (vha->host->active_mode == MODE_TARGET && !N2N_TOPO(vha->hw))\n\t\treturn 0;\n\n\tif (fcport->flags & (FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE)) {\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\treturn 0;\n\t}\n\n\tswitch (fcport->disc_state) {\n\tcase DSC_DELETED:\n\t\tswitch (vha->hw->current_topology) {\n\t\tcase ISP_CFG_N:\n\t\t\tif (fcport_is_smaller(fcport)) {\n\t\t\t\t \n\t\t\t\tif (fcport->login_retry) {\n\t\t\t\t\tif (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\t\t\t\t\tqla2x00_find_new_loop_id(vha,\n\t\t\t\t\t\t    fcport);\n\t\t\t\t\t\tfcport->fw_login_state =\n\t\t\t\t\t\t    DSC_LS_PORT_UNAVAIL;\n\t\t\t\t\t}\n\t\t\t\t\tfcport->login_retry--;\n\t\t\t\t\tqla_post_els_plogi_work(vha, fcport);\n\t\t\t\t} else {\n\t\t\t\t\tql_log(ql_log_info, vha, 0x705d,\n\t\t\t\t\t    \"Unable to reach remote port %8phC\",\n\t\t\t\t\t    fcport->port_name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tqla24xx_post_gnl_work(vha, fcport);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20bd,\n\t\t\t\t    \"%s %d %8phC post gnl\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tqla24xx_post_gnl_work(vha, fcport);\n\t\t\t} else {\n\t\t\t\tqla_chk_n2n_b4_login(vha, fcport);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase DSC_GNL:\n\t\tswitch (vha->hw->current_topology) {\n\t\tcase ISP_CFG_N:\n\t\t\tif ((fcport->current_login_state & 0xf) == 0x6) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t\t\t    \"%s %d %8phC post GPDB work\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tfcport->chip_reset =\n\t\t\t\t\tvha->hw->base_qpair->chip_reset;\n\t\t\t\tqla24xx_post_gpdb_work(vha, fcport, 0);\n\t\t\t}  else {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t\t\t    \"%s %d %8phC post %s PRLI\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name,\n\t\t\t\t    NVME_TARGET(vha->hw, fcport) ? \"NVME\" :\n\t\t\t\t    \"FC\");\n\t\t\t\tqla24xx_post_prli_work(vha, fcport);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fcport->login_pause) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20d8,\n\t\t\t\t    \"%s %d %8phC exit\\n\",\n\t\t\t\t    __func__, __LINE__,\n\t\t\t\t    fcport->port_name);\n\t\t\t\tfcport->last_rscn_gen = fcport->rscn_gen;\n\t\t\t\tfcport->last_login_gen = fcport->login_gen;\n\t\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqla_chk_n2n_b4_login(vha, fcport);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase DSC_LOGIN_FAILED:\n\t\tif (N2N_TOPO(vha->hw))\n\t\t\tqla_chk_n2n_b4_login(vha, fcport);\n\t\telse\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\tbreak;\n\n\tcase DSC_LOGIN_COMPLETE:\n\t\t \n\t\tdata[0] = data[1] = 0;\n\t\tqla2x00_post_async_adisc_work(vha, fcport, data);\n\t\tbreak;\n\n\tcase DSC_LOGIN_PEND:\n\t\tif (vha->hw->flags.edif_enabled)\n\t\t\tbreak;\n\n\t\tif (fcport->fw_login_state == DSC_LS_PLOGI_COMP) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t\t       \"%s %d %8phC post %s PRLI\\n\",\n\t\t\t       __func__, __LINE__, fcport->port_name,\n\t\t\t       NVME_TARGET(vha->hw, fcport) ? \"NVME\" : \"FC\");\n\t\t\tqla24xx_post_prli_work(vha, fcport);\n\t\t}\n\t\tbreak;\n\n\tcase DSC_UPD_FCPORT:\n\t\tsec =  jiffies_to_msecs(jiffies -\n\t\t    fcport->jiffies_at_registration)/1000;\n\t\tif (fcport->sec_since_registration < sec && sec &&\n\t\t    !(sec % 60)) {\n\t\t\tfcport->sec_since_registration = sec;\n\t\t\tql_dbg(ql_dbg_disc, fcport->vha, 0xffff,\n\t\t\t    \"%s %8phC - Slow Rport registration(%d Sec)\\n\",\n\t\t\t    __func__, fcport->port_name, sec);\n\t\t}\n\n\t\tif (fcport->next_disc_state != DSC_DELETE_PEND)\n\t\t\tfcport->next_disc_state = DSC_ADISC;\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint qla24xx_post_newsess_work(struct scsi_qla_host *vha, port_id_t *id,\n    u8 *port_name, u8 *node_name, void *pla, u8 fc4_type)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_NEW_SESS);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.new_sess.id = *id;\n\te->u.new_sess.pla = pla;\n\te->u.new_sess.fc4_type = fc4_type;\n\tmemcpy(e->u.new_sess.port_name, port_name, WWN_SIZE);\n\tif (node_name)\n\t\tmemcpy(e->u.new_sess.node_name, node_name, WWN_SIZE);\n\n\treturn qla2x00_post_work(vha, e);\n}\n\nvoid qla2x00_handle_rscn(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tfc_port_t *fcport;\n\tunsigned long flags;\n\n\tswitch (ea->id.b.rsvd_1) {\n\tcase RSCN_PORT_ADDR:\n\t\tfcport = qla2x00_find_fcport_by_nportid(vha, &ea->id, 1);\n\t\tif (fcport) {\n\t\t\tif (ql2xfc2target &&\n\t\t\t    fcport->flags & FCF_FCP2_DEVICE &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2115,\n\t\t\t\t       \"Delaying session delete for FCP2 portid=%06x %8phC \",\n\t\t\t\t\tfcport->d_id.b24, fcport->port_name);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (vha->hw->flags.edif_enabled && DBELL_ACTIVE(vha)) {\n\t\t\t\t \n\t\t\t\tif (atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\t\t\t \n\t\t\t\t\tfcport->scan_needed = 1;\n\t\t\t\t\tfcport->rscn_gen++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfcport->scan_needed = 1;\n\t\t\t\tfcport->rscn_gen++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase RSCN_AREA_ADDR:\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (fcport->flags & FCF_FCP2_DEVICE &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE)\n\t\t\t\tcontinue;\n\n\t\t\tif ((ea->id.b24 & 0xffff00) == (fcport->d_id.b24 & 0xffff00)) {\n\t\t\t\tfcport->scan_needed = 1;\n\t\t\t\tfcport->rscn_gen++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase RSCN_DOM_ADDR:\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (fcport->flags & FCF_FCP2_DEVICE &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE)\n\t\t\t\tcontinue;\n\n\t\t\tif ((ea->id.b24 & 0xff0000) == (fcport->d_id.b24 & 0xff0000)) {\n\t\t\t\tfcport->scan_needed = 1;\n\t\t\t\tfcport->rscn_gen++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase RSCN_FAB_ADDR:\n\tdefault:\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (fcport->flags & FCF_FCP2_DEVICE &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE)\n\t\t\t\tcontinue;\n\n\t\t\tfcport->scan_needed = 1;\n\t\t\tfcport->rscn_gen++;\n\t\t}\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tif (vha->scan.scan_flags == 0) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff, \"%s: schedule\\n\", __func__);\n\t\tvha->scan.scan_flags |= SF_QUEUED;\n\t\tschedule_delayed_work(&vha->scan.scan_work, 5);\n\t}\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n}\n\nvoid qla24xx_handle_relogin_event(scsi_qla_host_t *vha,\n\tstruct event_arg *ea)\n{\n\tfc_port_t *fcport = ea->fcport;\n\n\tif (test_bit(UNLOADING, &vha->dpc_flags))\n\t\treturn;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2102,\n\t    \"%s %8phC DS %d LS %d P %d del %d cnfl %p rscn %d|%d login %d|%d fl %x\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, fcport->login_pause,\n\t    fcport->deleted, fcport->conflict,\n\t    fcport->last_rscn_gen, fcport->rscn_gen,\n\t    fcport->last_login_gen, fcport->login_gen,\n\t    fcport->flags);\n\n\tif (fcport->last_rscn_gen != fcport->rscn_gen) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e9, \"%s %d %8phC post gnl\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\tqla24xx_post_gnl_work(vha, fcport);\n\t\treturn;\n\t}\n\n\tqla24xx_fcport_handle_login(vha, fcport);\n}\n\nvoid qla_handle_els_plogi_done(scsi_qla_host_t *vha,\n\t\t\t\t      struct event_arg *ea)\n{\n\tif (N2N_TOPO(vha->hw) && fcport_is_smaller(ea->fcport) &&\n\t    vha->hw->flags.edif_enabled) {\n\t\t \n\t\tqla24xx_post_gpdb_work(vha, ea->fcport, 0);\n\t\treturn;\n\t}\n\n\t \n\tif (vha->host->active_mode == MODE_TARGET)\n\t\treturn;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t    \"%s %d %8phC post PRLI\\n\",\n\t    __func__, __LINE__, ea->fcport->port_name);\n\tqla24xx_post_prli_work(vha, ea->fcport);\n}\n\n \nvoid qla_rscn_replay(fc_port_t *fcport)\n{\n\tstruct event_arg ea;\n\n\tswitch (fcport->disc_state) {\n\tcase DSC_DELETE_PEND:\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (fcport->scan_needed) {\n\t\tmemset(&ea, 0, sizeof(ea));\n\t\tea.id = fcport->d_id;\n\t\tea.id.b.rsvd_1 = RSCN_PORT_ADDR;\n\t\tqla2x00_handle_rscn(fcport->vha, &ea);\n\t}\n}\n\nstatic void\nqla2x00_tmf_iocb_timeout(void *data)\n{\n\tsrb_t *sp = data;\n\tstruct srb_iocb *tmf = &sp->u.iocb_cmd;\n\tint rc, h;\n\tunsigned long flags;\n\n\tif (sp->type == SRB_MARKER)\n\t\trc = QLA_FUNCTION_FAILED;\n\telse\n\t\trc = qla24xx_async_abort_cmd(sp, false);\n\n\tif (rc) {\n\t\tspin_lock_irqsave(sp->qpair->qp_lock_ptr, flags);\n\t\tfor (h = 1; h < sp->qpair->req->num_outstanding_cmds; h++) {\n\t\t\tif (sp->qpair->req->outstanding_cmds[h] == sp) {\n\t\t\t\tsp->qpair->req->outstanding_cmds[h] = NULL;\n\t\t\t\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(sp->qpair->qp_lock_ptr, flags);\n\t\ttmf->u.tmf.comp_status = cpu_to_le16(CS_TIMEOUT);\n\t\ttmf->u.tmf.data = QLA_FUNCTION_FAILED;\n\t\tcomplete(&tmf->u.tmf.comp);\n\t}\n}\n\nstatic void qla_marker_sp_done(srb_t *sp, int res)\n{\n\tstruct srb_iocb *tmf = &sp->u.iocb_cmd;\n\n\tif (res != QLA_SUCCESS)\n\t\tql_dbg(ql_dbg_taskm, sp->vha, 0x8004,\n\t\t    \"Async-marker fail hdl=%x portid=%06x ctrl=%x lun=%lld qp=%d.\\n\",\n\t\t    sp->handle, sp->fcport->d_id.b24, sp->u.iocb_cmd.u.tmf.flags,\n\t\t    sp->u.iocb_cmd.u.tmf.lun, sp->qpair->id);\n\n\tsp->u.iocb_cmd.u.tmf.data = res;\n\tcomplete(&tmf->u.tmf.comp);\n}\n\n#define  START_SP_W_RETRIES(_sp, _rval, _chip_gen, _login_gen) \\\n{\\\n\tint cnt = 5; \\\n\tdo { \\\n\t\tif (_chip_gen != sp->vha->hw->chip_reset || _login_gen != sp->fcport->login_gen) {\\\n\t\t\t_rval = EINVAL; \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\t_rval = qla2x00_start_sp(_sp); \\\n\t\tif (_rval == EAGAIN) \\\n\t\t\tmsleep(1); \\\n\t\telse \\\n\t\t\tbreak; \\\n\t\tcnt--; \\\n\t} while (cnt); \\\n}\n\n \nstatic int\nqla26xx_marker(struct tmf_arg *arg)\n{\n\tstruct scsi_qla_host *vha = arg->vha;\n\tstruct srb_iocb *tm_iocb;\n\tsrb_t *sp;\n\tint rval = QLA_FUNCTION_FAILED;\n\tfc_port_t *fcport = arg->fcport;\n\tu32 chip_gen, login_gen;\n\n\tif (TMF_NOT_READY(arg->fcport)) {\n\t\tql_dbg(ql_dbg_taskm, vha, 0x8039,\n\t\t    \"FC port not ready for marker loop-id=%x portid=%06x modifier=%x lun=%lld qp=%d.\\n\",\n\t\t    fcport->loop_id, fcport->d_id.b24,\n\t\t    arg->modifier, arg->lun, arg->qpair->id);\n\t\treturn QLA_SUSPENDED;\n\t}\n\n\tchip_gen = vha->hw->chip_reset;\n\tlogin_gen = fcport->login_gen;\n\n\t \n\tsp = qla2xxx_get_qpair_sp(vha, arg->qpair, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_MARKER;\n\tsp->name = \"marker\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha), qla_marker_sp_done);\n\tsp->u.iocb_cmd.timeout = qla2x00_tmf_iocb_timeout;\n\n\ttm_iocb = &sp->u.iocb_cmd;\n\tinit_completion(&tm_iocb->u.tmf.comp);\n\ttm_iocb->u.tmf.modifier = arg->modifier;\n\ttm_iocb->u.tmf.lun = arg->lun;\n\ttm_iocb->u.tmf.loop_id = fcport->loop_id;\n\ttm_iocb->u.tmf.vp_index = vha->vp_idx;\n\n\tSTART_SP_W_RETRIES(sp, rval, chip_gen, login_gen);\n\n\tql_dbg(ql_dbg_taskm, vha, 0x8006,\n\t    \"Async-marker hdl=%x loop-id=%x portid=%06x modifier=%x lun=%lld qp=%d rval %d.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b24,\n\t    arg->modifier, arg->lun, sp->qpair->id, rval);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x8031,\n\t\t    \"Marker IOCB send failure (%x).\\n\", rval);\n\t\tgoto done_free_sp;\n\t}\n\n\twait_for_completion(&tm_iocb->u.tmf.comp);\n\trval = tm_iocb->u.tmf.data;\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x8019,\n\t\t    \"Marker failed hdl=%x loop-id=%x portid=%06x modifier=%x lun=%lld qp=%d rval %d.\\n\",\n\t\t    sp->handle, fcport->loop_id, fcport->d_id.b24,\n\t\t    arg->modifier, arg->lun, sp->qpair->id, rval);\n\t}\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\nstatic void qla2x00_tmf_sp_done(srb_t *sp, int res)\n{\n\tstruct srb_iocb *tmf = &sp->u.iocb_cmd;\n\n\tif (res)\n\t\ttmf->u.tmf.data = res;\n\tcomplete(&tmf->u.tmf.comp);\n}\n\nstatic int qla_tmf_wait(struct tmf_arg *arg)\n{\n\t \n\tif (arg->flags & (TCF_LUN_RESET | TCF_ABORT_TASK_SET | TCF_CLEAR_TASK_SET))\n\t\treturn qla2x00_eh_wait_for_pending_commands(arg->vha,\n\t\t    arg->fcport->d_id.b24, arg->lun, WAIT_LUN);\n\telse\n\t\treturn qla2x00_eh_wait_for_pending_commands(arg->vha,\n\t\t    arg->fcport->d_id.b24, arg->lun, WAIT_TARGET);\n}\n\nstatic int\n__qla2x00_async_tm_cmd(struct tmf_arg *arg)\n{\n\tstruct scsi_qla_host *vha = arg->vha;\n\tstruct srb_iocb *tm_iocb;\n\tsrb_t *sp;\n\tint rval = QLA_FUNCTION_FAILED;\n\tfc_port_t *fcport = arg->fcport;\n\tu32 chip_gen, login_gen;\n\tu64 jif;\n\n\tif (TMF_NOT_READY(arg->fcport)) {\n\t\tql_dbg(ql_dbg_taskm, vha, 0x8032,\n\t\t    \"FC port not ready for TM command loop-id=%x portid=%06x modifier=%x lun=%lld qp=%d.\\n\",\n\t\t    fcport->loop_id, fcport->d_id.b24,\n\t\t    arg->modifier, arg->lun, arg->qpair->id);\n\t\treturn QLA_SUSPENDED;\n\t}\n\n\tchip_gen = vha->hw->chip_reset;\n\tlogin_gen = fcport->login_gen;\n\n\t \n\tsp = qla2xxx_get_qpair_sp(vha, arg->qpair, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tqla_vha_mark_busy(vha);\n\tsp->type = SRB_TM_CMD;\n\tsp->name = \"tmf\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha),\n\t\t\t      qla2x00_tmf_sp_done);\n\tsp->u.iocb_cmd.timeout = qla2x00_tmf_iocb_timeout;\n\n\ttm_iocb = &sp->u.iocb_cmd;\n\tinit_completion(&tm_iocb->u.tmf.comp);\n\ttm_iocb->u.tmf.flags = arg->flags;\n\ttm_iocb->u.tmf.lun = arg->lun;\n\n\tSTART_SP_W_RETRIES(sp, rval, chip_gen, login_gen);\n\n\tql_dbg(ql_dbg_taskm, vha, 0x802f,\n\t    \"Async-tmf hdl=%x loop-id=%x portid=%06x ctrl=%x lun=%lld qp=%d rval=%x.\\n\",\n\t    sp->handle, fcport->loop_id, fcport->d_id.b24,\n\t    arg->flags, arg->lun, sp->qpair->id, rval);\n\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\twait_for_completion(&tm_iocb->u.tmf.comp);\n\n\trval = tm_iocb->u.tmf.data;\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x8030,\n\t\t    \"TM IOCB failed (%x).\\n\", rval);\n\t}\n\n\tif (!test_bit(UNLOADING, &vha->dpc_flags) && !IS_QLAFX00(vha->hw)) {\n\t\tjif = jiffies;\n\t\tif (qla_tmf_wait(arg)) {\n\t\t\tql_log(ql_log_info, vha, 0x803e,\n\t\t\t       \"Waited %u ms Nexus=%ld:%06x:%llu.\\n\",\n\t\t\t       jiffies_to_msecs(jiffies - jif), vha->host_no,\n\t\t\t       fcport->d_id.b24, arg->lun);\n\t\t}\n\n\t\tif (chip_gen == vha->hw->chip_reset && login_gen == fcport->login_gen) {\n\t\t\trval = qla26xx_marker(arg);\n\t\t} else {\n\t\t\tql_log(ql_log_info, vha, 0x803e,\n\t\t\t       \"Skip Marker due to disruption. Nexus=%ld:%06x:%llu.\\n\",\n\t\t\t       vha->host_no, fcport->d_id.b24, arg->lun);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\tif (tm_iocb->u.tmf.data)\n\t\trval = tm_iocb->u.tmf.data;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\nstatic void qla_put_tmf(struct tmf_arg *arg)\n{\n\tstruct scsi_qla_host *vha = arg->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tha->active_tmf--;\n\tlist_del(&arg->tmf_elem);\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n}\n\nstatic\nint qla_get_tmf(struct tmf_arg *arg)\n{\n\tstruct scsi_qla_host *vha = arg->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\tfc_port_t *fcport = arg->fcport;\n\tint rc = 0;\n\tstruct tmf_arg *t;\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tlist_for_each_entry(t, &ha->tmf_active, tmf_elem) {\n\t\tif (t->fcport == arg->fcport && t->lun == arg->lun) {\n\t\t\t \n\t\t\tql_log(ql_log_warn, vha, 0x802c,\n\t\t\t       \"found duplicate TMF.  Nexus=%ld:%06x:%llu.\\n\",\n\t\t\t       vha->host_no, fcport->d_id.b24, arg->lun);\n\t\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tlist_add_tail(&arg->tmf_elem, &ha->tmf_pending);\n\twhile (ha->active_tmf >= MAX_ACTIVE_TMF) {\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\t\tmsleep(1);\n\n\t\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\t\tif (TMF_NOT_READY(fcport)) {\n\t\t\tql_log(ql_log_warn, vha, 0x802c,\n\t\t\t    \"Unable to acquire TM resource due to disruption.\\n\");\n\t\t\trc = EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (ha->active_tmf < MAX_ACTIVE_TMF &&\n\t\t    list_is_first(&arg->tmf_elem, &ha->tmf_pending))\n\t\t\tbreak;\n\t}\n\n\tlist_del(&arg->tmf_elem);\n\n\tif (!rc) {\n\t\tha->active_tmf++;\n\t\tlist_add_tail(&arg->tmf_elem, &ha->tmf_active);\n\t}\n\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\treturn rc;\n}\n\nint\nqla2x00_async_tm_cmd(fc_port_t *fcport, uint32_t flags, uint64_t lun,\n\t\t     uint32_t tag)\n{\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct tmf_arg a;\n\tint rval = QLA_SUCCESS;\n\n\tif (TMF_NOT_READY(fcport))\n\t\treturn QLA_SUSPENDED;\n\n\ta.vha = fcport->vha;\n\ta.fcport = fcport;\n\ta.lun = lun;\n\ta.flags = flags;\n\tINIT_LIST_HEAD(&a.tmf_elem);\n\n\tif (flags & (TCF_LUN_RESET|TCF_ABORT_TASK_SET|TCF_CLEAR_TASK_SET|TCF_CLEAR_ACA)) {\n\t\ta.modifier = MK_SYNC_ID_LUN;\n\t} else {\n\t\ta.modifier = MK_SYNC_ID;\n\t}\n\n\tif (qla_get_tmf(&a))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\ta.qpair = vha->hw->base_qpair;\n\trval = __qla2x00_async_tm_cmd(&a);\n\n\tqla_put_tmf(&a);\n\treturn rval;\n}\n\nint\nqla24xx_async_abort_command(srb_t *sp)\n{\n\tunsigned long   flags = 0;\n\n\tuint32_t\thandle;\n\tfc_port_t\t*fcport = sp->fcport;\n\tstruct qla_qpair *qpair = sp->qpair;\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct req_que *req = qpair->req;\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tfor (handle = 1; handle < req->num_outstanding_cmds; handle++) {\n\t\tif (req->outstanding_cmds[handle] == sp)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\tif (handle == req->num_outstanding_cmds) {\n\t\t \n\t\treturn QLA_ERR_NOT_FOUND;\n\t}\n\tif (sp->type == SRB_FXIOCB_DCMD)\n\t\treturn qlafx00_fx_disc(vha, &vha->hw->mr.fcport,\n\t\t    FXDISC_ABORT_IOCTL);\n\n\treturn qla24xx_async_abort_cmd(sp, true);\n}\n\nstatic void\nqla24xx_handle_prli_done_event(struct scsi_qla_host *vha, struct event_arg *ea)\n{\n\tstruct srb *sp;\n\tWARN_ONCE(!qla2xxx_is_valid_mbs(ea->data[0]), \"mbs: %#x\\n\",\n\t\t  ea->data[0]);\n\n\tswitch (ea->data[0]) {\n\tcase MBS_COMMAND_COMPLETE:\n\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t    \"%s %d %8phC post gpdb\\n\",\n\t\t    __func__, __LINE__, ea->fcport->port_name);\n\n\t\tea->fcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\t\tea->fcport->logout_on_delete = 1;\n\t\tea->fcport->nvme_prli_service_param = ea->iop[0];\n\t\tif (ea->iop[0] & NVME_PRLI_SP_FIRST_BURST)\n\t\t\tea->fcport->nvme_first_burst_size =\n\t\t\t    (ea->iop[1] & 0xffff) * 512;\n\t\telse\n\t\t\tea->fcport->nvme_first_burst_size = 0;\n\t\tqla24xx_post_gpdb_work(vha, ea->fcport, 0);\n\t\tbreak;\n\tdefault:\n\t\tsp = ea->sp;\n\t\tql_dbg(ql_dbg_disc, vha, 0x2118,\n\t\t       \"%s %d %8phC priority %s, fc4type %x prev try %s\\n\",\n\t\t       __func__, __LINE__, ea->fcport->port_name,\n\t\t       vha->hw->fc4_type_priority == FC4_PRIORITY_FCP ?\n\t\t       \"FCP\" : \"NVMe\", ea->fcport->fc4_type,\n\t\t       (sp->u.iocb_cmd.u.logio.flags & SRB_LOGIN_NVME_PRLI) ?\n\t\t\t\"NVME\" : \"FCP\");\n\n\t\tif (NVME_FCP_TARGET(ea->fcport)) {\n\t\t\tif (sp->u.iocb_cmd.u.logio.flags & SRB_LOGIN_NVME_PRLI)\n\t\t\t\tea->fcport->do_prli_nvme = 0;\n\t\t\telse\n\t\t\t\tea->fcport->do_prli_nvme = 1;\n\t\t} else {\n\t\t\tea->fcport->do_prli_nvme = 0;\n\t\t}\n\n\t\tif (N2N_TOPO(vha->hw)) {\n\t\t\tif (ea->fcport->n2n_link_reset_cnt ==\n\t\t\t    vha->hw->login_retry_count &&\n\t\t\t    ea->fcport->flags & FCF_FCSP_DEVICE) {\n\t\t\t\t \n\t\t\t\tea->fcport->n2n_link_reset_cnt = 0;\n\t\t\t}\n\n\t\t\tif (ea->fcport->n2n_link_reset_cnt <\n\t\t\t    vha->hw->login_retry_count) {\n\t\t\t\tea->fcport->n2n_link_reset_cnt++;\n\t\t\t\tvha->relogin_jif = jiffies + 2 * HZ;\n\t\t\t\t \n\t\t\t\tset_bit(N2N_LINK_RESET, &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t} else {\n\t\t\t\tql_log(ql_log_warn, vha, 0x2119,\n\t\t\t\t       \"%s %d %8phC Unable to reconnect\\n\",\n\t\t\t\t       __func__, __LINE__,\n\t\t\t\t       ea->fcport->port_name);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tea->fcport->flags &= ~FCF_ASYNC_SENT;\n\t\t\tea->fcport->keep_nport_handle = 0;\n\t\t\tea->fcport->logout_on_delete = 1;\n\t\t\tqlt_schedule_sess_for_deletion(ea->fcport);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid\nqla24xx_handle_plogi_done_event(struct scsi_qla_host *vha, struct event_arg *ea)\n{\n\tport_id_t cid;\t \n\tu16 lid;\n\tstruct fc_port *conflict_fcport;\n\tunsigned long flags;\n\tstruct fc_port *fcport = ea->fcport;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"%s %8phC DS %d LS %d rc %d login %d|%d rscn %d|%d data %x|%x iop %x|%x\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, ea->rc, ea->sp->gen2, fcport->login_gen,\n\t    ea->sp->gen1, fcport->rscn_gen,\n\t    ea->data[0], ea->data[1], ea->iop[0], ea->iop[1]);\n\n\tif ((fcport->fw_login_state == DSC_LS_PLOGI_PEND) ||\n\t    (fcport->fw_login_state == DSC_LS_PRLI_PEND)) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20ea,\n\t\t    \"%s %d %8phC Remote is trying to login\\n\",\n\t\t    __func__, __LINE__, fcport->port_name);\n\t\treturn;\n\t}\n\n\tif ((fcport->disc_state == DSC_DELETE_PEND) ||\n\t    (fcport->disc_state == DSC_DELETED)) {\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t}\n\n\tif (ea->sp->gen2 != fcport->login_gen) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC generation changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t} else if (ea->sp->gen1 != fcport->rscn_gen) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC RSCN generation changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\tqla_rscn_replay(fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t}\n\n\tWARN_ONCE(!qla2xxx_is_valid_mbs(ea->data[0]), \"mbs: %#x\\n\",\n\t\t  ea->data[0]);\n\n\tswitch (ea->data[0]) {\n\tcase MBS_COMMAND_COMPLETE:\n\t\t \n\t\tif (vha->hw->flags.edif_enabled) {\n\t\t\tset_bit(ea->fcport->loop_id, vha->hw->loop_id_map);\n\t\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t\tea->fcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\t\t\tea->fcport->logout_on_delete = 1;\n\t\t\tea->fcport->send_els_logo = 0;\n\t\t\tea->fcport->fw_login_state = DSC_LS_PLOGI_COMP;\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t\t\tqla24xx_post_gpdb_work(vha, ea->fcport, 0);\n\t\t} else {\n\t\t\tif (NVME_TARGET(vha->hw, fcport)) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2117,\n\t\t\t\t    \"%s %d %8phC post prli\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name);\n\t\t\t\tqla24xx_post_prli_work(vha, fcport);\n\t\t\t} else {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ea,\n\t\t\t\t    \"%s %d %8phC LoopID 0x%x in use with %06x. post gpdb\\n\",\n\t\t\t\t    __func__, __LINE__, fcport->port_name,\n\t\t\t\t    fcport->loop_id, fcport->d_id.b24);\n\n\t\t\t\tset_bit(fcport->loop_id, vha->hw->loop_id_map);\n\t\t\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t\t\tfcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\t\t\t\tfcport->logout_on_delete = 1;\n\t\t\t\tfcport->send_els_logo = 0;\n\t\t\t\tfcport->fw_login_state = DSC_LS_PRLI_COMP;\n\t\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t\t\t\tqla24xx_post_gpdb_work(vha, fcport, 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MBS_COMMAND_ERROR:\n\t\tql_dbg(ql_dbg_disc, vha, 0x20eb, \"%s %d %8phC cmd error %x\\n\",\n\t\t    __func__, __LINE__, ea->fcport->port_name, ea->data[1]);\n\n\t\tqlt_schedule_sess_for_deletion(ea->fcport);\n\t\tbreak;\n\tcase MBS_LOOP_ID_USED:\n\t\t \n\t\tcid.b.domain = (ea->iop[1] >> 16) & 0xff;\n\t\tcid.b.area   = (ea->iop[1] >>  8) & 0xff;\n\t\tcid.b.al_pa  = ea->iop[1] & 0xff;\n\t\tcid.b.rsvd_1 = 0;\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20ec,\n\t\t    \"%s %d %8phC lid %#x in use with pid %06x post gnl\\n\",\n\t\t    __func__, __LINE__, ea->fcport->port_name,\n\t\t    ea->fcport->loop_id, cid.b24);\n\n\t\tset_bit(ea->fcport->loop_id, vha->hw->loop_id_map);\n\t\tea->fcport->loop_id = FC_NO_LOOP_ID;\n\t\tqla24xx_post_gnl_work(vha, ea->fcport);\n\t\tbreak;\n\tcase MBS_PORT_ID_USED:\n\t\tlid = ea->iop[1] & 0xffff;\n\t\tqlt_find_sess_invalidate_other(vha,\n\t\t    wwn_to_u64(ea->fcport->port_name),\n\t\t    ea->fcport->d_id, lid, &conflict_fcport);\n\n\t\tif (conflict_fcport) {\n\t\t\t \n\t\t\tconflict_fcport->conflict = ea->fcport;\n\t\t\tea->fcport->login_pause = 1;\n\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ed,\n\t\t\t    \"%s %d %8phC NPortId %06x inuse with loopid 0x%x.\\n\",\n\t\t\t    __func__, __LINE__, ea->fcport->port_name,\n\t\t\t    ea->fcport->d_id.b24, lid);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ed,\n\t\t\t    \"%s %d %8phC NPortId %06x inuse with loopid 0x%x. sched delete\\n\",\n\t\t\t    __func__, __LINE__, ea->fcport->port_name,\n\t\t\t    ea->fcport->d_id.b24, lid);\n\n\t\t\tqla2x00_clear_loop_id(ea->fcport);\n\t\t\tset_bit(lid, vha->hw->loop_id_map);\n\t\t\tea->fcport->loop_id = lid;\n\t\t\tea->fcport->keep_nport_handle = 0;\n\t\t\tea->fcport->logout_on_delete = 1;\n\t\t\tqlt_schedule_sess_for_deletion(ea->fcport);\n\t\t}\n\t\tbreak;\n\t}\n\treturn;\n}\n\n \n \n \n\nstatic int\nqla83xx_nic_core_fw_load(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t idc_major_ver, idc_minor_ver;\n\tuint16_t config[4];\n\n\tqla83xx_idc_lock(vha, 0);\n\n\t \n\tha->fcoe_dev_init_timeout = QLA83XX_IDC_INITIALIZATION_TIMEOUT;\n\tha->fcoe_reset_timeout = QLA83XX_IDC_RESET_ACK_TIMEOUT;\n\n\t \n\tif (__qla83xx_set_drv_presence(vha) != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb077,\n\t\t    \"Error while setting DRV-Presence.\\n\");\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto exit;\n\t}\n\n\t \n\tqla83xx_reset_ownership(vha);\n\n\t \n\tqla83xx_rd_reg(vha, QLA83XX_IDC_MAJOR_VERSION, &idc_major_ver);\n\tif (ha->flags.nic_core_reset_owner) {\n\t\t \n\t\tidc_major_ver = QLA83XX_SUPP_IDC_MAJOR_VERSION;\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_MAJOR_VERSION, idc_major_ver);\n\n\t\t \n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_LOCK_RECOVERY, 0);\n\t} else if (idc_major_ver != QLA83XX_SUPP_IDC_MAJOR_VERSION) {\n\t\t \n\t\tql_log(ql_log_warn, vha, 0xb07d,\n\t\t    \"Failing load, idc_major_ver=%d, expected_major_ver=%d.\\n\",\n\t\t    idc_major_ver, QLA83XX_SUPP_IDC_MAJOR_VERSION);\n\t\t__qla83xx_clear_drv_presence(vha);\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto exit;\n\t}\n\t \n\tqla83xx_rd_reg(vha, QLA83XX_IDC_MINOR_VERSION, &idc_minor_ver);\n\tidc_minor_ver |= (QLA83XX_SUPP_IDC_MINOR_VERSION << (ha->portnum * 2));\n\tqla83xx_wr_reg(vha, QLA83XX_IDC_MINOR_VERSION, idc_minor_ver);\n\n\tif (ha->flags.nic_core_reset_owner) {\n\t\tmemset(config, 0, sizeof(config));\n\t\tif (!qla81xx_get_port_config(vha, config))\n\t\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE,\n\t\t\t    QLA8XXX_DEV_READY);\n\t}\n\n\trval = qla83xx_idc_state_handler(vha);\n\nexit:\n\tqla83xx_idc_unlock(vha, 0);\n\n\treturn rval;\n}\n\n \nint\nqla2x00_initialize_adapter(scsi_qla_host_t *vha)\n{\n\tint\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tmemset(&vha->qla_stats, 0, sizeof(vha->qla_stats));\n\tmemset(&vha->fc_host_stat, 0, sizeof(vha->fc_host_stat));\n\n\t \n\tvha->flags.online = 0;\n\tha->flags.chip_reset_done = 0;\n\tvha->flags.reset_active = 0;\n\tha->flags.pci_channel_io_perm_failure = 0;\n\tha->flags.eeh_busy = 0;\n\tvha->qla_stats.jiffies_at_last_reset = get_jiffies_64();\n\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\tvha->device_flags = DFLG_NO_CABLE;\n\tvha->dpc_flags = 0;\n\tvha->flags.management_server_logged_in = 0;\n\tvha->marker_needed = 0;\n\tha->isp_abort_cnt = 0;\n\tha->beacon_blink_led = 0;\n\n\tset_bit(0, ha->req_qid_map);\n\tset_bit(0, ha->rsp_qid_map);\n\n\tql_dbg(ql_dbg_init, vha, 0x0040,\n\t    \"Configuring PCI space...\\n\");\n\trval = ha->isp_ops->pci_config(vha);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0044,\n\t\t    \"Unable to configure PCI space.\\n\");\n\t\treturn (rval);\n\t}\n\n\tha->isp_ops->reset_chip(vha);\n\n\t \n\tif (IS_QLA28XX(ha)) {\n\t\tif (rd_reg_word(&reg->mailbox12) & BIT_0)\n\t\t\tha->flags.secure_adapter = 1;\n\t\tql_log(ql_log_info, vha, 0xffff, \"Secure Adapter: %s\\n\",\n\t\t    (ha->flags.secure_adapter) ? \"Yes\" : \"No\");\n\t}\n\n\n\trval = qla2xxx_get_flash_info(vha);\n\tif (rval) {\n\t\tql_log(ql_log_fatal, vha, 0x004f,\n\t\t    \"Unable to validate FLASH data.\\n\");\n\t\treturn rval;\n\t}\n\n\tif (IS_QLA8044(ha)) {\n\t\tqla8044_read_reset_template(vha);\n\n\t\t \n\t\tif (ql2xdontresethba == 1)\n\t\t\tqla8044_set_idc_dontreset(vha);\n\t}\n\n\tha->isp_ops->get_flash_version(vha, req->ring);\n\tql_dbg(ql_dbg_init, vha, 0x0061,\n\t    \"Configure NVRAM parameters...\\n\");\n\n\t \n\tha->fc4_type_priority = FC4_PRIORITY_FCP;\n\n\tha->isp_ops->nvram_config(vha);\n\n\tif (ha->fc4_type_priority != FC4_PRIORITY_FCP &&\n\t    ha->fc4_type_priority != FC4_PRIORITY_NVME)\n\t\tha->fc4_type_priority = FC4_PRIORITY_FCP;\n\n\tql_log(ql_log_info, vha, 0xffff, \"FC4 priority set to %s\\n\",\n\t       ha->fc4_type_priority == FC4_PRIORITY_FCP ? \"FCP\" : \"NVMe\");\n\n\tif (ha->flags.disable_serdes) {\n\t\t \n\t\tql_log(ql_log_info, vha, 0x0077,\n\t\t    \"Masking HBA WWPN %8phN (via NVRAM).\\n\", vha->port_name);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x0078,\n\t    \"Verifying loaded RISC code...\\n\");\n\n\t \n\tif (ql2xsmartsan) {\n\t\tql2xfdmienable = 1;\n\t\tql2xrdpenable = 1;\n\t}\n\n\tif (qla2x00_isp_firmware(vha) != QLA_SUCCESS) {\n\t\trval = ha->isp_ops->chip_diag(vha);\n\t\tif (rval)\n\t\t\treturn (rval);\n\t\trval = qla2x00_setup_chip(vha);\n\t\tif (rval)\n\t\t\treturn (rval);\n\t}\n\n\tif (IS_QLA84XX(ha)) {\n\t\tha->cs84xx = qla84xx_get_chip(vha);\n\t\tif (!ha->cs84xx) {\n\t\t\tql_log(ql_log_warn, vha, 0x00d0,\n\t\t\t    \"Unable to configure ISP84XX.\\n\");\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\n\tif (qla_ini_mode_enabled(vha) || qla_dual_mode_enabled(vha))\n\t\trval = qla2x00_init_rings(vha);\n\n\t \n\tif (rval != QLA_SUCCESS)\n\t\treturn rval;\n\n\tha->flags.chip_reset_done = 1;\n\n\tif (rval == QLA_SUCCESS && IS_QLA84XX(ha)) {\n\t\t \n\t\trval = qla84xx_init_chip(vha);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x00d4,\n\t\t\t    \"Unable to initialize ISP84XX.\\n\");\n\t\t\tqla84xx_put_chip(vha);\n\t\t}\n\t}\n\n\t \n\tif (IS_QLA8031(ha)) {\n\t\trval = qla83xx_nic_core_fw_load(vha);\n\t\tif (rval)\n\t\t\tql_log(ql_log_warn, vha, 0x0124,\n\t\t\t    \"Error in initializing NIC Core f/w.\\n\");\n\t}\n\n\tif (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha))\n\t\tqla24xx_read_fcp_prio_cfg(vha);\n\n\tif (IS_P3P_TYPE(ha))\n\t\tqla82xx_set_driver_version(vha, QLA2XXX_VERSION);\n\telse\n\t\tqla25xx_set_driver_version(vha, QLA2XXX_VERSION);\n\n\treturn (rval);\n}\n\n \nint\nqla2100_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t w;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\tpci_disable_rom(ha->pdev);\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->pci_attr = rd_reg_word(&reg->ctrl_status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n \nint\nqla2300_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t\tw;\n\tunsigned long   flags = 0;\n\tuint32_t\tcnt;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\n\tif (IS_QLA2322(ha) || IS_QLA6322(ha))\n\t\tw &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\t \n\tif (IS_QLA2300(ha)) {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t\t \n\t\twrt_reg_word(&reg->hccr, HCCR_PAUSE_RISC);\n\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\tif ((rd_reg_word(&reg->hccr) & HCCR_RISC_PAUSE) != 0)\n\t\t\t\tbreak;\n\n\t\t\tudelay(10);\n\t\t}\n\n\t\t \n\t\twrt_reg_word(&reg->ctrl_status, 0x20);\n\t\trd_reg_word(&reg->ctrl_status);\n\n\t\t \n\t\tha->fb_rev = RD_FB_CMD_REG(ha, reg);\n\n\t\tif (ha->fb_rev == FPM_2300)\n\t\t\tpci_clear_mwi(ha->pdev);\n\n\t\t \n\t\twrt_reg_word(&reg->ctrl_status, 0x0);\n\t\trd_reg_word(&reg->ctrl_status);\n\n\t\t \n\t\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\tif ((rd_reg_word(&reg->hccr) & HCCR_RISC_PAUSE) == 0)\n\t\t\t\tbreak;\n\n\t\t\tudelay(10);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\tpci_write_config_byte(ha->pdev, PCI_LATENCY_TIMER, 0x80);\n\n\tpci_disable_rom(ha->pdev);\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->pci_attr = rd_reg_word(&reg->ctrl_status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n \nint\nqla24xx_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t w;\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\tw &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\tpci_write_config_byte(ha->pdev, PCI_LATENCY_TIMER, 0x80);\n\n\t \n\tif (pci_find_capability(ha->pdev, PCI_CAP_ID_PCIX))\n\t\tpcix_set_mmrbc(ha->pdev, 2048);\n\n\t \n\tif (pci_is_pcie(ha->pdev))\n\t\tpcie_set_readrq(ha->pdev, 4096);\n\n\tpci_disable_rom(ha->pdev);\n\n\tha->chip_revision = ha->pdev->revision;\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->pci_attr = rd_reg_dword(&reg->ctrl_status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n \nint\nqla25xx_pci_config(scsi_qla_host_t *vha)\n{\n\tuint16_t w;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tpci_set_master(ha->pdev);\n\tpci_try_set_mwi(ha->pdev);\n\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\n\tw &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n\n\t \n\tif (pci_is_pcie(ha->pdev))\n\t\tpcie_set_readrq(ha->pdev, 4096);\n\n\tpci_disable_rom(ha->pdev);\n\n\tha->chip_revision = ha->pdev->revision;\n\n\treturn QLA_SUCCESS;\n}\n\n \nstatic int\nqla2x00_isp_firmware(scsi_qla_host_t *vha)\n{\n\tint  rval;\n\tuint16_t loop_id, topo, sw_cap;\n\tuint8_t domain, area, al_pa;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\trval = QLA_FUNCTION_FAILED;\n\n\tif (ha->flags.disable_risc_code_load) {\n\t\tql_log(ql_log_info, vha, 0x0079, \"RISC CODE NOT loaded.\\n\");\n\n\t\t \n\t\trval = qla2x00_verify_checksum(vha, ha->fw_srisc_address);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\t \n\t\t\trval = qla2x00_get_adapter_id(vha, &loop_id, &al_pa,\n\t\t\t    &area, &domain, &topo, &sw_cap);\n\t\t}\n\t}\n\n\tif (rval)\n\t\tql_dbg(ql_dbg_init, vha, 0x007a,\n\t\t    \"**** Load RISC code ****.\\n\");\n\n\treturn (rval);\n}\n\n \nint\nqla2x00_reset_chip(scsi_qla_host_t *vha)\n{\n\tunsigned long   flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tuint32_t\tcnt;\n\tuint16_t\tcmd;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn rval;\n\n\tha->isp_ops->disable_intrs(ha);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t \n\tcmd = 0;\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &cmd);\n\tcmd &= ~PCI_COMMAND_MASTER;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, cmd);\n\n\tif (!IS_QLA2100(ha)) {\n\t\t \n\t\twrt_reg_word(&reg->hccr, HCCR_PAUSE_RISC);\n\t\tif (IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\t\tif ((rd_reg_word(&reg->hccr) &\n\t\t\t\t    HCCR_RISC_PAUSE) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(100);\n\t\t\t}\n\t\t} else {\n\t\t\trd_reg_word(&reg->hccr);\t \n\t\t\tudelay(10);\n\t\t}\n\n\t\t \n\t\twrt_reg_word(&reg->ctrl_status, 0x20);\n\t\trd_reg_word(&reg->ctrl_status);\t\t \n\n\t\t \n\t\twrt_reg_word(&reg->fpm_diag_config, 0x100);\n\t\trd_reg_word(&reg->fpm_diag_config);\t \n\n\t\t \n\t\tif (!IS_QLA2200(ha)) {\n\t\t\twrt_reg_word(&reg->fpm_diag_config, 0x0);\n\t\t\trd_reg_word(&reg->fpm_diag_config);  \n\t\t}\n\n\t\t \n\t\twrt_reg_word(&reg->ctrl_status, 0x10);\n\t\trd_reg_word(&reg->ctrl_status);\t\t \n\n\t\t \n\t\tif (IS_QLA2200(ha)) {\n\t\t\tWRT_FB_CMD_REG(ha, reg, 0xa000);\n\t\t\tRD_FB_CMD_REG(ha, reg);\t\t \n\t\t} else {\n\t\t\tWRT_FB_CMD_REG(ha, reg, 0x00fc);\n\n\t\t\t \n\t\t\tfor (cnt = 0; cnt < 3000; cnt++) {\n\t\t\t\tif ((RD_FB_CMD_REG(ha, reg) & 0xff) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(100);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twrt_reg_word(&reg->ctrl_status, 0);\n\t\trd_reg_word(&reg->ctrl_status);\t\t \n\n\t\t \n\t\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\t\trd_reg_word(&reg->hccr);\t\t \n\n\t\t \n\t\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\t\trd_reg_word(&reg->hccr);\t\t \n\t}\n\n\twrt_reg_word(&reg->hccr, HCCR_CLR_RISC_INT);\n\twrt_reg_word(&reg->hccr, HCCR_CLR_HOST_INT);\n\n\t \n\twrt_reg_word(&reg->ctrl_status, CSR_ISP_SOFT_RESET);\n\n\t \n\tif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\t \n\t\tudelay(20);\n\t\tfor (cnt = 30000; cnt; cnt--) {\n\t\t\tif ((rd_reg_word(&reg->ctrl_status) &\n\t\t\t    CSR_ISP_SOFT_RESET) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(100);\n\t\t}\n\t} else\n\t\tudelay(10);\n\n\t \n\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\n\twrt_reg_word(&reg->semaphore, 0);\n\n\t \n\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\trd_reg_word(&reg->hccr);\t\t\t \n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\tif (RD_MAILBOX_REG(ha, reg, 0) != MBS_BUSY)\n\t\t\t\tbreak;\n\n\t\t\tudelay(100);\n\t\t}\n\t} else\n\t\tudelay(100);\n\n\t \n\tcmd |= PCI_COMMAND_MASTER;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, cmd);\n\n\t \n\tif (!IS_QLA2100(ha)) {\n\t\twrt_reg_word(&reg->hccr, HCCR_DISABLE_PARITY_PAUSE);\n\t\trd_reg_word(&reg->hccr);\t\t \n\t}\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n \nstatic int\nqla81xx_reset_mpi(scsi_qla_host_t *vha)\n{\n\tuint16_t mb[4] = {0x1010, 0, 1, 0};\n\n\tif (!IS_QLA81XX(vha->hw))\n\t\treturn QLA_SUCCESS;\n\n\treturn qla81xx_write_mpi_register(vha, mb);\n}\n\nstatic int\nqla_chk_risc_recovery(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\t__le16 __iomem *mbptr = &reg->mailbox0;\n\tint i;\n\tu16 mb[32];\n\tint rc = QLA_SUCCESS;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn rc;\n\n\t \n\tmb[0] = rd_reg_word(mbptr);\n\tmbptr++;\n\tif (mb[0] == 0xf) {\n\t\trc = QLA_FUNCTION_FAILED;\n\n\t\tfor (i = 1; i < 32; i++) {\n\t\t\tmb[i] = rd_reg_word(mbptr);\n\t\t\tmbptr++;\n\t\t}\n\n\t\tql_log(ql_log_warn, vha, 0x1015,\n\t\t       \"RISC reset failed. mb[0-7] %04xh %04xh %04xh %04xh %04xh %04xh %04xh %04xh\\n\",\n\t\t       mb[0], mb[1], mb[2], mb[3], mb[4], mb[5], mb[6], mb[7]);\n\t\tql_log(ql_log_warn, vha, 0x1015,\n\t\t       \"RISC reset failed. mb[8-15] %04xh %04xh %04xh %04xh %04xh %04xh %04xh %04xh\\n\",\n\t\t       mb[8], mb[9], mb[10], mb[11], mb[12], mb[13], mb[14],\n\t\t       mb[15]);\n\t\tql_log(ql_log_warn, vha, 0x1015,\n\t\t       \"RISC reset failed. mb[16-23] %04xh %04xh %04xh %04xh %04xh %04xh %04xh %04xh\\n\",\n\t\t       mb[16], mb[17], mb[18], mb[19], mb[20], mb[21], mb[22],\n\t\t       mb[23]);\n\t\tql_log(ql_log_warn, vha, 0x1015,\n\t\t       \"RISC reset failed. mb[24-31] %04xh %04xh %04xh %04xh %04xh %04xh %04xh %04xh\\n\",\n\t\t       mb[24], mb[25], mb[26], mb[27], mb[28], mb[29], mb[30],\n\t\t       mb[31]);\n\t}\n\treturn rc;\n}\n\n \nstatic inline int\nqla24xx_reset_risc(scsi_qla_host_t *vha)\n{\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\tuint32_t cnt;\n\tuint16_t wd;\n\tstatic int abts_cnt;  \n\tint rval = QLA_SUCCESS;\n\tint print = 1;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t \n\twrt_reg_dword(&reg->ctrl_status, CSRX_DMA_SHUTDOWN|MWB_4096_BYTES);\n\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\tif ((rd_reg_dword(&reg->ctrl_status) & CSRX_DMA_ACTIVE) == 0)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!(rd_reg_dword(&reg->ctrl_status) & CSRX_DMA_ACTIVE))\n\t\tset_bit(DMA_SHUTDOWN_CMPL, &ha->fw_dump_cap_flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x017e,\n\t    \"HCCR: 0x%x, Control Status %x, DMA active status:0x%x\\n\",\n\t    rd_reg_dword(&reg->hccr),\n\t    rd_reg_dword(&reg->ctrl_status),\n\t    (rd_reg_dword(&reg->ctrl_status) & CSRX_DMA_ACTIVE));\n\n\twrt_reg_dword(&reg->ctrl_status,\n\t    CSRX_ISP_SOFT_RESET|CSRX_DMA_SHUTDOWN|MWB_4096_BYTES);\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &wd);\n\n\tudelay(100);\n\n\t \n\trd_reg_word(&reg->mailbox0);\n\tfor (cnt = 10000; rd_reg_word(&reg->mailbox0) != 0 &&\n\t    rval == QLA_SUCCESS; cnt--) {\n\t\tbarrier();\n\t\tif (cnt)\n\t\t\tudelay(5);\n\t\telse\n\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t}\n\n\tif (rval == QLA_SUCCESS)\n\t\tset_bit(ISP_MBX_RDY, &ha->fw_dump_cap_flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x017f,\n\t    \"HCCR: 0x%x, MailBox0 Status 0x%x\\n\",\n\t    rd_reg_dword(&reg->hccr),\n\t    rd_reg_word(&reg->mailbox0));\n\n\t \n\trd_reg_dword(&reg->ctrl_status);\n\tfor (cnt = 0; cnt < 60; cnt++) {\n\t\tbarrier();\n\t\tif ((rd_reg_dword(&reg->ctrl_status) &\n\t\t    CSRX_ISP_SOFT_RESET) == 0)\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t}\n\tif (!(rd_reg_dword(&reg->ctrl_status) & CSRX_ISP_SOFT_RESET))\n\t\tset_bit(ISP_SOFT_RESET_CMPL, &ha->fw_dump_cap_flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015d,\n\t    \"HCCR: 0x%x, Soft Reset status: 0x%x\\n\",\n\t    rd_reg_dword(&reg->hccr),\n\t    rd_reg_dword(&reg->ctrl_status));\n\n\t \n\tif (test_and_clear_bit(MPI_RESET_NEEDED, &vha->dpc_flags)) {\n\t\tif (qla81xx_reset_mpi(vha) != QLA_SUCCESS) {\n\t\t\tif (++abts_cnt < 5) {\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t\tset_bit(MPI_RESET_NEEDED, &vha->dpc_flags);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tabts_cnt = 0;\n\t\t\t\tvha->flags.online = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\twrt_reg_dword(&reg->hccr, HCCRX_SET_RISC_RESET);\n\trd_reg_dword(&reg->hccr);\n\n\twrt_reg_dword(&reg->hccr, HCCRX_REL_RISC_PAUSE);\n\trd_reg_dword(&reg->hccr);\n\n\twrt_reg_dword(&reg->hccr, HCCRX_CLR_RISC_RESET);\n\tmdelay(10);\n\trd_reg_dword(&reg->hccr);\n\n\twd = rd_reg_word(&reg->mailbox0);\n\tfor (cnt = 300; wd != 0 && rval == QLA_SUCCESS; cnt--) {\n\t\tbarrier();\n\t\tif (cnt) {\n\t\t\tmdelay(1);\n\t\t\tif (print && qla_chk_risc_recovery(vha))\n\t\t\t\tprint = 0;\n\n\t\t\twd = rd_reg_word(&reg->mailbox0);\n\t\t} else {\n\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\n\t\t\tql_log(ql_log_warn, vha, 0x015e,\n\t\t\t       \"RISC reset timeout\\n\");\n\t\t}\n\t}\n\n\tif (rval == QLA_SUCCESS)\n\t\tset_bit(RISC_RDY_AFT_RESET, &ha->fw_dump_cap_flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015e,\n\t    \"Host Risc 0x%x, mailbox0 0x%x\\n\",\n\t    rd_reg_dword(&reg->hccr),\n\t     rd_reg_word(&reg->mailbox0));\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x015f,\n\t    \"Driver in %s mode\\n\",\n\t    IS_NOPOLLING_TYPE(ha) ? \"Interrupt\" : \"Polling\");\n\n\tif (IS_NOPOLLING_TYPE(ha))\n\t\tha->isp_ops->enable_intrs(ha);\n\n\treturn rval;\n}\n\nstatic void\nqla25xx_read_risc_sema_reg(scsi_qla_host_t *vha, uint32_t *data)\n{\n\tstruct device_reg_24xx __iomem *reg = &vha->hw->iobase->isp24;\n\n\twrt_reg_dword(&reg->iobase_addr, RISC_REGISTER_BASE_OFFSET);\n\t*data = rd_reg_dword(&reg->iobase_window + RISC_REGISTER_WINDOW_OFFSET);\n}\n\nstatic void\nqla25xx_write_risc_sema_reg(scsi_qla_host_t *vha, uint32_t data)\n{\n\tstruct device_reg_24xx __iomem *reg = &vha->hw->iobase->isp24;\n\n\twrt_reg_dword(&reg->iobase_addr, RISC_REGISTER_BASE_OFFSET);\n\twrt_reg_dword(&reg->iobase_window + RISC_REGISTER_WINDOW_OFFSET, data);\n}\n\nstatic void\nqla25xx_manipulate_risc_semaphore(scsi_qla_host_t *vha)\n{\n\tuint32_t wd32 = 0;\n\tuint delta_msec = 100;\n\tuint elapsed_msec = 0;\n\tuint timeout_msec;\n\tulong n;\n\n\tif (vha->hw->pdev->subsystem_device != 0x0175 &&\n\t    vha->hw->pdev->subsystem_device != 0x0240)\n\t\treturn;\n\n\twrt_reg_dword(&vha->hw->iobase->isp24.hccr, HCCRX_SET_RISC_PAUSE);\n\tudelay(100);\n\nattempt:\n\ttimeout_msec = TIMEOUT_SEMAPHORE;\n\tn = timeout_msec / delta_msec;\n\twhile (n--) {\n\t\tqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_SET);\n\t\tqla25xx_read_risc_sema_reg(vha, &wd32);\n\t\tif (wd32 & RISC_SEMAPHORE)\n\t\t\tbreak;\n\t\tmsleep(delta_msec);\n\t\telapsed_msec += delta_msec;\n\t\tif (elapsed_msec > TIMEOUT_TOTAL_ELAPSED)\n\t\t\tgoto force;\n\t}\n\n\tif (!(wd32 & RISC_SEMAPHORE))\n\t\tgoto force;\n\n\tif (!(wd32 & RISC_SEMAPHORE_FORCE))\n\t\tgoto acquired;\n\n\tqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_CLR);\n\ttimeout_msec = TIMEOUT_SEMAPHORE_FORCE;\n\tn = timeout_msec / delta_msec;\n\twhile (n--) {\n\t\tqla25xx_read_risc_sema_reg(vha, &wd32);\n\t\tif (!(wd32 & RISC_SEMAPHORE_FORCE))\n\t\t\tbreak;\n\t\tmsleep(delta_msec);\n\t\telapsed_msec += delta_msec;\n\t\tif (elapsed_msec > TIMEOUT_TOTAL_ELAPSED)\n\t\t\tgoto force;\n\t}\n\n\tif (wd32 & RISC_SEMAPHORE_FORCE)\n\t\tqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_FORCE_CLR);\n\n\tgoto attempt;\n\nforce:\n\tqla25xx_write_risc_sema_reg(vha, RISC_SEMAPHORE_FORCE_SET);\n\nacquired:\n\treturn;\n}\n\n \nint\nqla24xx_reset_chip(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (pci_channel_offline(ha->pdev) &&\n\t    ha->flags.pci_channel_io_perm_failure) {\n\t\treturn rval;\n\t}\n\n\tha->isp_ops->disable_intrs(ha);\n\n\tqla25xx_manipulate_risc_semaphore(vha);\n\n\t \n\trval = qla24xx_reset_risc(vha);\n\n\treturn rval;\n}\n\n \nint\nqla2x00_chip_diag(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tunsigned long\tflags = 0;\n\tuint16_t\tdata;\n\tuint32_t\tcnt;\n\tuint16_t\tmb[5];\n\tstruct req_que *req = ha->req_q_map[0];\n\n\t \n\trval = QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_init, vha, 0x007b, \"Testing device at %p.\\n\",\n\t       &reg->flash_address);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t \n\twrt_reg_word(&reg->ctrl_status, CSR_ISP_SOFT_RESET);\n\n\t \n\tudelay(20);\n\tdata = qla2x00_debounce_register(&reg->ctrl_status);\n\tfor (cnt = 6000000 ; cnt && (data & CSR_ISP_SOFT_RESET); cnt--) {\n\t\tudelay(5);\n\t\tdata = rd_reg_word(&reg->ctrl_status);\n\t\tbarrier();\n\t}\n\n\tif (!cnt)\n\t\tgoto chip_diag_failed;\n\n\tql_dbg(ql_dbg_init, vha, 0x007c,\n\t    \"Reset register cleared by chip reset.\\n\");\n\n\t \n\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\n\t \n\tif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\tdata = qla2x00_debounce_register(MAILBOX_REG(ha, reg, 0));\n\t\tfor (cnt = 6000000; cnt && (data == MBS_BUSY); cnt--) {\n\t\t\tudelay(5);\n\t\t\tdata = RD_MAILBOX_REG(ha, reg, 0);\n\t\t\tbarrier();\n\t\t}\n\t} else\n\t\tudelay(10);\n\n\tif (!cnt)\n\t\tgoto chip_diag_failed;\n\n\t \n\tql_dbg(ql_dbg_init, vha, 0x007d, \"Checking product ID of chip.\\n\");\n\n\tmb[1] = RD_MAILBOX_REG(ha, reg, 1);\n\tmb[2] = RD_MAILBOX_REG(ha, reg, 2);\n\tmb[3] = RD_MAILBOX_REG(ha, reg, 3);\n\tmb[4] = qla2x00_debounce_register(MAILBOX_REG(ha, reg, 4));\n\tif (mb[1] != PROD_ID_1 || (mb[2] != PROD_ID_2 && mb[2] != PROD_ID_2a) ||\n\t    mb[3] != PROD_ID_3) {\n\t\tql_log(ql_log_warn, vha, 0x0062,\n\t\t    \"Wrong product ID = 0x%x,0x%x,0x%x.\\n\",\n\t\t    mb[1], mb[2], mb[3]);\n\n\t\tgoto chip_diag_failed;\n\t}\n\tha->product_id[0] = mb[1];\n\tha->product_id[1] = mb[2];\n\tha->product_id[2] = mb[3];\n\tha->product_id[3] = mb[4];\n\n\t \n\tif (req->length > 1024)\n\t\tha->fw_transfer_size = REQUEST_ENTRY_SIZE * 1024;\n\telse\n\t\tha->fw_transfer_size = REQUEST_ENTRY_SIZE *\n\t\t    req->length;\n\n\tif (IS_QLA2200(ha) &&\n\t    RD_MAILBOX_REG(ha, reg, 7) == QLA2200A_RISC_ROM_VER) {\n\t\t \n\t\tql_dbg(ql_dbg_init, vha, 0x007e, \"Found QLA2200A Chip.\\n\");\n\n\t\tha->device_type |= DT_ISP2200A;\n\t\tha->fw_transfer_size = 128;\n\t}\n\n\t \n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tql_dbg(ql_dbg_init, vha, 0x007f, \"Checking mailboxes.\\n\");\n\trval = qla2x00_mbx_reg_test(vha);\n\tif (rval)\n\t\tql_log(ql_log_warn, vha, 0x0080,\n\t\t    \"Failed mailbox send register test.\\n\");\n\telse\n\t\t \n\t\trval = QLA_SUCCESS;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\nchip_diag_failed:\n\tif (rval)\n\t\tql_log(ql_log_info, vha, 0x0081,\n\t\t    \"Chip diagnostics **** FAILED ****.\\n\");\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn (rval);\n}\n\n \nint\nqla24xx_chip_diag(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn QLA_SUCCESS;\n\n\tha->fw_transfer_size = REQUEST_ENTRY_SIZE * req->length;\n\n\trval = qla2x00_mbx_reg_test(vha);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0082,\n\t\t    \"Failed mailbox send register test.\\n\");\n\t} else {\n\t\t \n\t\trval = QLA_SUCCESS;\n\t}\n\n\treturn rval;\n}\n\nstatic void\nqla2x00_init_fce_trace(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tdma_addr_t tc_dma;\n\tvoid *tc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn;\n\n\tif (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn;\n\n\tif (ha->fce) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00bd,\n\t\t       \"%s: FCE Mem is already allocated.\\n\",\n\t\t       __func__);\n\t\treturn;\n\t}\n\n\t \n\ttc = dma_alloc_coherent(&ha->pdev->dev, FCE_SIZE, &tc_dma,\n\t\t\t\tGFP_KERNEL);\n\tif (!tc) {\n\t\tql_log(ql_log_warn, vha, 0x00be,\n\t\t       \"Unable to allocate (%d KB) for FCE.\\n\",\n\t\t       FCE_SIZE / 1024);\n\t\treturn;\n\t}\n\n\trval = qla2x00_enable_fce_trace(vha, tc_dma, FCE_NUM_BUFFERS,\n\t\t\t\t\tha->fce_mb, &ha->fce_bufs);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x00bf,\n\t\t       \"Unable to initialize FCE (%d).\\n\", rval);\n\t\tdma_free_coherent(&ha->pdev->dev, FCE_SIZE, tc, tc_dma);\n\t\treturn;\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x00c0,\n\t       \"Allocated (%d KB) for FCE...\\n\", FCE_SIZE / 1024);\n\n\tha->flags.fce_enabled = 1;\n\tha->fce_dma = tc_dma;\n\tha->fce = tc;\n}\n\nstatic void\nqla2x00_init_eft_trace(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tdma_addr_t tc_dma;\n\tvoid *tc;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn;\n\n\tif (ha->eft) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00bd,\n\t\t    \"%s: EFT Mem is already allocated.\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\n\t \n\ttc = dma_alloc_coherent(&ha->pdev->dev, EFT_SIZE, &tc_dma,\n\t\t\t\tGFP_KERNEL);\n\tif (!tc) {\n\t\tql_log(ql_log_warn, vha, 0x00c1,\n\t\t       \"Unable to allocate (%d KB) for EFT.\\n\",\n\t\t       EFT_SIZE / 1024);\n\t\treturn;\n\t}\n\n\trval = qla2x00_enable_eft_trace(vha, tc_dma, EFT_NUM_BUFFERS);\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x00c2,\n\t\t       \"Unable to initialize EFT (%d).\\n\", rval);\n\t\tdma_free_coherent(&ha->pdev->dev, EFT_SIZE, tc, tc_dma);\n\t\treturn;\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x00c3,\n\t       \"Allocated (%d KB) EFT ...\\n\", EFT_SIZE / 1024);\n\n\tha->eft_dma = tc_dma;\n\tha->eft = tc;\n}\n\nstatic void\nqla2x00_alloc_offload_mem(scsi_qla_host_t *vha)\n{\n\tqla2x00_init_fce_trace(vha);\n\tqla2x00_init_eft_trace(vha);\n}\n\nvoid\nqla2x00_alloc_fw_dump(scsi_qla_host_t *vha)\n{\n\tuint32_t dump_size, fixed_size, mem_size, req_q_size, rsp_q_size,\n\t    eft_size, fce_size, mq_size;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\tstruct qla2xxx_fw_dump *fw_dump;\n\n\tif (ha->fw_dump) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00bd,\n\t\t    \"Firmware dump already allocated.\\n\");\n\t\treturn;\n\t}\n\n\tha->fw_dumped = 0;\n\tha->fw_dump_cap_flags = 0;\n\tdump_size = fixed_size = mem_size = eft_size = fce_size = mq_size = 0;\n\treq_q_size = rsp_q_size = 0;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t\tfixed_size = sizeof(struct qla2100_fw_dump);\n\t} else if (IS_QLA23XX(ha)) {\n\t\tfixed_size = offsetof(struct qla2300_fw_dump, data_ram);\n\t\tmem_size = (ha->fw_memory_size - 0x11000 + 1) *\n\t\t    sizeof(uint16_t);\n\t} else if (IS_FWI2_CAPABLE(ha)) {\n\t\tif (IS_QLA83XX(ha))\n\t\t\tfixed_size = offsetof(struct qla83xx_fw_dump, ext_mem);\n\t\telse if (IS_QLA81XX(ha))\n\t\t\tfixed_size = offsetof(struct qla81xx_fw_dump, ext_mem);\n\t\telse if (IS_QLA25XX(ha))\n\t\t\tfixed_size = offsetof(struct qla25xx_fw_dump, ext_mem);\n\t\telse\n\t\t\tfixed_size = offsetof(struct qla24xx_fw_dump, ext_mem);\n\n\t\tmem_size = (ha->fw_memory_size - 0x100000 + 1) *\n\t\t    sizeof(uint32_t);\n\t\tif (ha->mqenable) {\n\t\t\tif (!IS_QLA83XX(ha))\n\t\t\t\tmq_size = sizeof(struct qla2xxx_mq_chain);\n\t\t\t \n\t\t\tmq_size += (ha->max_req_queues - 1) *\n\t\t\t    (req->length * sizeof(request_t));\n\t\t\tmq_size += (ha->max_rsp_queues - 1) *\n\t\t\t    (rsp->length * sizeof(response_t));\n\t\t}\n\t\tif (ha->tgt.atio_ring)\n\t\t\tmq_size += ha->tgt.atio_q_length * sizeof(request_t);\n\n\t\tqla2x00_init_fce_trace(vha);\n\t\tif (ha->fce)\n\t\t\tfce_size = sizeof(struct qla2xxx_fce_chain) + FCE_SIZE;\n\t\tqla2x00_init_eft_trace(vha);\n\t\tif (ha->eft)\n\t\t\teft_size = EFT_SIZE;\n\t}\n\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tstruct fwdt *fwdt = ha->fwdt;\n\t\tuint j;\n\n\t\tfor (j = 0; j < 2; j++, fwdt++) {\n\t\t\tif (!fwdt->template) {\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x00ba,\n\t\t\t\t    \"-> fwdt%u no template\\n\", j);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00fa,\n\t\t\t    \"-> fwdt%u calculating fwdump size...\\n\", j);\n\t\t\tfwdt->dump_size = qla27xx_fwdt_calculate_dump_size(\n\t\t\t    vha, fwdt->template);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00fa,\n\t\t\t    \"-> fwdt%u calculated fwdump size = %#lx bytes\\n\",\n\t\t\t    j, fwdt->dump_size);\n\t\t\tdump_size += fwdt->dump_size;\n\t\t}\n\t\t \n\t\tdump_size += ha->fwdt[1].dump_size;\n\t} else {\n\t\treq_q_size = req->length * sizeof(request_t);\n\t\trsp_q_size = rsp->length * sizeof(response_t);\n\t\tdump_size = offsetof(struct qla2xxx_fw_dump, isp);\n\t\tdump_size += fixed_size + mem_size + req_q_size + rsp_q_size\n\t\t\t+ eft_size;\n\t\tha->chain_offset = dump_size;\n\t\tdump_size += mq_size + fce_size;\n\t\tif (ha->exchoffld_buf)\n\t\t\tdump_size += sizeof(struct qla2xxx_offld_chain) +\n\t\t\t\tha->exchoffld_size;\n\t\tif (ha->exlogin_buf)\n\t\t\tdump_size += sizeof(struct qla2xxx_offld_chain) +\n\t\t\t\tha->exlogin_size;\n\t}\n\n\tif (!ha->fw_dump_len || dump_size > ha->fw_dump_alloc_len) {\n\n\t\tql_dbg(ql_dbg_init, vha, 0x00c5,\n\t\t    \"%s dump_size %d fw_dump_len %d fw_dump_alloc_len %d\\n\",\n\t\t    __func__, dump_size, ha->fw_dump_len,\n\t\t    ha->fw_dump_alloc_len);\n\n\t\tfw_dump = vmalloc(dump_size);\n\t\tif (!fw_dump) {\n\t\t\tql_log(ql_log_warn, vha, 0x00c4,\n\t\t\t    \"Unable to allocate (%d KB) for firmware dump.\\n\",\n\t\t\t    dump_size / 1024);\n\t\t} else {\n\t\t\tmutex_lock(&ha->optrom_mutex);\n\t\t\tif (ha->fw_dumped) {\n\t\t\t\tmemcpy(fw_dump, ha->fw_dump, ha->fw_dump_len);\n\t\t\t\tvfree(ha->fw_dump);\n\t\t\t\tha->fw_dump = fw_dump;\n\t\t\t\tha->fw_dump_alloc_len =  dump_size;\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x00c5,\n\t\t\t\t    \"Re-Allocated (%d KB) and save firmware dump.\\n\",\n\t\t\t\t    dump_size / 1024);\n\t\t\t} else {\n\t\t\t\tvfree(ha->fw_dump);\n\t\t\t\tha->fw_dump = fw_dump;\n\n\t\t\t\tha->fw_dump_len = ha->fw_dump_alloc_len =\n\t\t\t\t    dump_size;\n\t\t\t\tql_dbg(ql_dbg_init, vha, 0x00c5,\n\t\t\t\t    \"Allocated (%d KB) for firmware dump.\\n\",\n\t\t\t\t    dump_size / 1024);\n\n\t\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\t\t\tha->mpi_fw_dump = (char *)fw_dump +\n\t\t\t\t\t\tha->fwdt[1].dump_size;\n\t\t\t\t\tmutex_unlock(&ha->optrom_mutex);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tha->fw_dump->signature[0] = 'Q';\n\t\t\t\tha->fw_dump->signature[1] = 'L';\n\t\t\t\tha->fw_dump->signature[2] = 'G';\n\t\t\t\tha->fw_dump->signature[3] = 'C';\n\t\t\t\tha->fw_dump->version = htonl(1);\n\n\t\t\t\tha->fw_dump->fixed_size = htonl(fixed_size);\n\t\t\t\tha->fw_dump->mem_size = htonl(mem_size);\n\t\t\t\tha->fw_dump->req_q_size = htonl(req_q_size);\n\t\t\t\tha->fw_dump->rsp_q_size = htonl(rsp_q_size);\n\n\t\t\t\tha->fw_dump->eft_size = htonl(eft_size);\n\t\t\t\tha->fw_dump->eft_addr_l =\n\t\t\t\t    htonl(LSD(ha->eft_dma));\n\t\t\t\tha->fw_dump->eft_addr_h =\n\t\t\t\t    htonl(MSD(ha->eft_dma));\n\n\t\t\t\tha->fw_dump->header_size =\n\t\t\t\t\thtonl(offsetof\n\t\t\t\t\t    (struct qla2xxx_fw_dump, isp));\n\t\t\t}\n\t\t\tmutex_unlock(&ha->optrom_mutex);\n\t\t}\n\t}\n}\n\nstatic int\nqla81xx_mpi_sync(scsi_qla_host_t *vha)\n{\n#define MPS_MASK\t0xe0\n\tint rval;\n\tuint16_t dc;\n\tuint32_t dw;\n\n\tif (!IS_QLA81XX(vha->hw))\n\t\treturn QLA_SUCCESS;\n\n\trval = qla2x00_write_ram_word(vha, 0x7c00, 1);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x0105,\n\t\t    \"Unable to acquire semaphore.\\n\");\n\t\tgoto done;\n\t}\n\n\tpci_read_config_word(vha->hw->pdev, 0x54, &dc);\n\trval = qla2x00_read_ram_word(vha, 0x7a15, &dw);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x0067, \"Unable to read sync.\\n\");\n\t\tgoto done_release;\n\t}\n\n\tdc &= MPS_MASK;\n\tif (dc == (dw & MPS_MASK))\n\t\tgoto done_release;\n\n\tdw &= ~MPS_MASK;\n\tdw |= dc;\n\trval = qla2x00_write_ram_word(vha, 0x7a15, dw);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x0114, \"Unable to gain sync.\\n\");\n\t}\n\ndone_release:\n\trval = qla2x00_write_ram_word(vha, 0x7c00, 0);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x006d,\n\t\t    \"Unable to release semaphore.\\n\");\n\t}\n\ndone:\n\treturn rval;\n}\n\nint\nqla2x00_alloc_outstanding_cmds(struct qla_hw_data *ha, struct req_que *req)\n{\n\t \n\tif (req->outstanding_cmds)\n\t\treturn QLA_SUCCESS;\n\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treq->num_outstanding_cmds = DEFAULT_OUTSTANDING_COMMANDS;\n\telse {\n\t\tif (ha->cur_fw_xcb_count <= ha->cur_fw_iocb_count)\n\t\t\treq->num_outstanding_cmds = ha->cur_fw_xcb_count;\n\t\telse\n\t\t\treq->num_outstanding_cmds = ha->cur_fw_iocb_count;\n\t}\n\n\treq->outstanding_cmds = kcalloc(req->num_outstanding_cmds,\n\t\t\t\t\tsizeof(srb_t *),\n\t\t\t\t\tGFP_KERNEL);\n\n\tif (!req->outstanding_cmds) {\n\t\t \n\t\treq->num_outstanding_cmds = MIN_OUTSTANDING_COMMANDS;\n\t\treq->outstanding_cmds = kcalloc(req->num_outstanding_cmds,\n\t\t\t\t\t\tsizeof(srb_t *),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!req->outstanding_cmds) {\n\t\t\tql_log(ql_log_fatal, NULL, 0x0126,\n\t\t\t    \"Failed to allocate memory for \"\n\t\t\t    \"outstanding_cmds for req_que %p.\\n\", req);\n\t\t\treq->num_outstanding_cmds = 0;\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\n#define PRINT_FIELD(_field, _flag, _str) {\t\t\\\n\tif (a0->_field & _flag) {\\\n\t\tif (p) {\\\n\t\t\tstrcat(ptr, \"|\");\\\n\t\t\tptr++;\\\n\t\t\tleftover--;\\\n\t\t} \\\n\t\tlen = snprintf(ptr, leftover, \"%s\", _str);\t\\\n\t\tp = 1;\\\n\t\tleftover -= len;\\\n\t\tptr += len; \\\n\t} \\\n}\n\nstatic void qla2xxx_print_sfp_info(struct scsi_qla_host *vha)\n{\n#define STR_LEN 64\n\tstruct sff_8247_a0 *a0 = (struct sff_8247_a0 *)vha->hw->sfp_data;\n\tu8 str[STR_LEN], *ptr, p;\n\tint leftover, len;\n\n\tmemset(str, 0, STR_LEN);\n\tsnprintf(str, SFF_VEN_NAME_LEN+1, a0->vendor_name);\n\tql_dbg(ql_dbg_init, vha, 0x015a,\n\t    \"SFP MFG Name: %s\\n\", str);\n\n\tmemset(str, 0, STR_LEN);\n\tsnprintf(str, SFF_PART_NAME_LEN+1, a0->vendor_pn);\n\tql_dbg(ql_dbg_init, vha, 0x015c,\n\t    \"SFP Part Name: %s\\n\", str);\n\n\t \n\tmemset(str, 0, STR_LEN);\n\tptr = str;\n\tleftover = STR_LEN;\n\tp = len = 0;\n\tPRINT_FIELD(fc_med_cc9, FC_MED_TW, \"Twin AX\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_TP, \"Twisted Pair\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_MI, \"Min Coax\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_TV, \"Video Coax\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_M6, \"MultiMode 62.5um\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_M5, \"MultiMode 50um\");\n\tPRINT_FIELD(fc_med_cc9, FC_MED_SM, \"SingleMode\");\n\tql_dbg(ql_dbg_init, vha, 0x0160,\n\t    \"SFP Media: %s\\n\", str);\n\n\t \n\tmemset(str, 0, STR_LEN);\n\tptr = str;\n\tleftover = STR_LEN;\n\tp = len = 0;\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_VL, \"Very Long\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_S, \"Short\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_I, \"Intermediate\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_L, \"Long\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_M, \"Medium\");\n\tql_dbg(ql_dbg_init, vha, 0x0196,\n\t    \"SFP Link Length: %s\\n\", str);\n\n\tmemset(str, 0, STR_LEN);\n\tptr = str;\n\tleftover = STR_LEN;\n\tp = len = 0;\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_SA, \"Short Wave (SA)\");\n\tPRINT_FIELD(fc_ll_cc7, FC_LL_LC, \"Long Wave(LC)\");\n\tPRINT_FIELD(fc_tec_cc8, FC_TEC_SN, \"Short Wave (SN)\");\n\tPRINT_FIELD(fc_tec_cc8, FC_TEC_SL, \"Short Wave (SL)\");\n\tPRINT_FIELD(fc_tec_cc8, FC_TEC_LL, \"Long Wave (LL)\");\n\tql_dbg(ql_dbg_init, vha, 0x016e,\n\t    \"SFP FC Link Tech: %s\\n\", str);\n\n\tif (a0->length_km)\n\t\tql_dbg(ql_dbg_init, vha, 0x016f,\n\t\t    \"SFP Distant: %d km\\n\", a0->length_km);\n\tif (a0->length_100m)\n\t\tql_dbg(ql_dbg_init, vha, 0x0170,\n\t\t    \"SFP Distant: %d m\\n\", a0->length_100m*100);\n\tif (a0->length_50um_10m)\n\t\tql_dbg(ql_dbg_init, vha, 0x0189,\n\t\t    \"SFP Distant (WL=50um): %d m\\n\", a0->length_50um_10m * 10);\n\tif (a0->length_62um_10m)\n\t\tql_dbg(ql_dbg_init, vha, 0x018a,\n\t\t  \"SFP Distant (WL=62.5um): %d m\\n\", a0->length_62um_10m * 10);\n\tif (a0->length_om4_10m)\n\t\tql_dbg(ql_dbg_init, vha, 0x0194,\n\t\t    \"SFP Distant (OM4): %d m\\n\", a0->length_om4_10m * 10);\n\tif (a0->length_om3_10m)\n\t\tql_dbg(ql_dbg_init, vha, 0x0195,\n\t\t    \"SFP Distant (OM3): %d m\\n\", a0->length_om3_10m * 10);\n}\n\n\n \nint\nqla24xx_detect_sfp(scsi_qla_host_t *vha)\n{\n\tint rc, used_nvram;\n\tstruct sff_8247_a0 *a;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct nvram_81xx *nv = ha->nvram;\n#define LR_DISTANCE_UNKNOWN\t2\n\tstatic const char * const types[] = { \"Short\", \"Long\" };\n\tstatic const char * const lengths[] = { \"(10km)\", \"(5km)\", \"\" };\n\tu8 ll = 0;\n\n\t \n\tused_nvram = 0;\n\tha->flags.lr_detected = 0;\n\tif (IS_BPM_RANGE_CAPABLE(ha) &&\n\t    (nv->enhanced_features & NEF_LR_DIST_ENABLE)) {\n\t\tused_nvram = 1;\n\t\tha->flags.lr_detected = 1;\n\t\tha->lr_distance =\n\t\t    (nv->enhanced_features >> LR_DIST_NV_POS)\n\t\t     & LR_DIST_NV_MASK;\n\t}\n\n\tif (!IS_BPM_ENABLED(vha))\n\t\tgoto out;\n\t \n\trc = qla2x00_read_sfp_dev(vha, NULL, 0);\n\tif (rc)\n\t\tgoto out;\n\n\tused_nvram = 0;\n\ta = (struct sff_8247_a0 *)vha->hw->sfp_data;\n\tqla2xxx_print_sfp_info(vha);\n\n\tha->flags.lr_detected = 0;\n\tll = a->fc_ll_cc7;\n\tif (ll & FC_LL_VL || ll & FC_LL_L) {\n\t\t \n\t\tha->flags.lr_detected = 1;\n\n\t\tif (a->length_km > 5 || a->length_100m > 50)\n\t\t\tha->lr_distance = LR_DISTANCE_10K;\n\t\telse\n\t\t\tha->lr_distance = LR_DISTANCE_5K;\n\t}\n\nout:\n\tql_dbg(ql_dbg_async, vha, 0x507b,\n\t    \"SFP detect: %s-Range SFP %s (nvr=%x ll=%x lr=%x lrd=%x).\\n\",\n\t    types[ha->flags.lr_detected],\n\t    ha->flags.lr_detected ? lengths[ha->lr_distance] :\n\t       lengths[LR_DISTANCE_UNKNOWN],\n\t    used_nvram, ll, ha->flags.lr_detected, ha->lr_distance);\n\treturn ha->flags.lr_detected;\n}\n\nstatic void __qla_adjust_iocb_limit(struct qla_qpair *qpair)\n{\n\tu8 num_qps;\n\tu16 limit;\n\tstruct qla_hw_data *ha = qpair->vha->hw;\n\n\tnum_qps = ha->num_qpairs + 1;\n\tlimit = (ha->orig_fw_iocb_count * QLA_IOCB_PCT_LIMIT) / 100;\n\n\tqpair->fwres.iocbs_total = ha->orig_fw_iocb_count;\n\tqpair->fwres.iocbs_limit = limit;\n\tqpair->fwres.iocbs_qp_limit = limit / num_qps;\n\n\tqpair->fwres.exch_total = ha->orig_fw_xcb_count;\n\tqpair->fwres.exch_limit = (ha->orig_fw_xcb_count *\n\t\t\t\t   QLA_IOCB_PCT_LIMIT) / 100;\n}\n\nvoid qla_init_iocb_limit(scsi_qla_host_t *vha)\n{\n\tu8 i;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t__qla_adjust_iocb_limit(ha->base_qpair);\n\tha->base_qpair->fwres.iocbs_used = 0;\n\tha->base_qpair->fwres.exch_used  = 0;\n\n\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\tif (ha->queue_pair_map[i])  {\n\t\t\t__qla_adjust_iocb_limit(ha->queue_pair_map[i]);\n\t\t\tha->queue_pair_map[i]->fwres.iocbs_used = 0;\n\t\t\tha->queue_pair_map[i]->fwres.exch_used = 0;\n\t\t}\n\t}\n\n\tha->fwres.iocb_total = ha->orig_fw_iocb_count;\n\tha->fwres.iocb_limit = (ha->orig_fw_iocb_count * QLA_IOCB_PCT_LIMIT) / 100;\n\tha->fwres.exch_total = ha->orig_fw_xcb_count;\n\tha->fwres.exch_limit = (ha->orig_fw_xcb_count * QLA_IOCB_PCT_LIMIT) / 100;\n\n\tatomic_set(&ha->fwres.iocb_used, 0);\n\tatomic_set(&ha->fwres.exch_used, 0);\n}\n\nvoid qla_adjust_iocb_limit(scsi_qla_host_t *vha)\n{\n\tu8 i;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t__qla_adjust_iocb_limit(ha->base_qpair);\n\n\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\tif (ha->queue_pair_map[i])\n\t\t\t__qla_adjust_iocb_limit(ha->queue_pair_map[i]);\n\t}\n}\n\n \nstatic int\nqla2x00_setup_chip(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint32_t srisc_address = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tunsigned long flags;\n\tuint16_t fw_major_version;\n\tint done_once = 0;\n\n\tif (IS_P3P_TYPE(ha)) {\n\t\trval = ha->isp_ops->load_risc(vha, &srisc_address);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tqla2x00_stop_firmware(vha);\n\t\t\tgoto enable_82xx_npiv;\n\t\t} else\n\t\t\tgoto failed;\n\t}\n\n\tif (!IS_FWI2_CAPABLE(ha) && !IS_QLA2100(ha) && !IS_QLA2200(ha)) {\n\t\t \n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twrt_reg_word(&reg->hccr, (HCCR_ENABLE_PARITY + 0x0));\n\t\trd_reg_word(&reg->hccr);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\tqla81xx_mpi_sync(vha);\n\nexecute_fw_with_lr:\n\t \n\trval = ha->isp_ops->load_risc(vha, &srisc_address);\n\tif (rval == QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00c9,\n\t\t    \"Verifying Checksum of loaded RISC code.\\n\");\n\n\t\trval = qla2x00_verify_checksum(vha, srisc_address);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_init, vha, 0x00ca,\n\t\t\t    \"Starting firmware.\\n\");\n\n\t\t\tif (ql2xexlogins)\n\t\t\t\tha->flags.exlogins_enabled = 1;\n\n\t\t\tif (qla_is_exch_offld_enabled(vha))\n\t\t\t\tha->flags.exchoffld_enabled = 1;\n\n\t\t\trval = qla2x00_execute_fw(vha, srisc_address);\n\t\t\t \n\t\t\tif (rval == QLA_SUCCESS) {\n\t\t\t\t \n\t\t\t\tif (!done_once++ && qla24xx_detect_sfp(vha)) {\n\t\t\t\t\tql_dbg(ql_dbg_init, vha, 0x00ca,\n\t\t\t\t\t    \"Re-starting firmware -- BPM.\\n\");\n\t\t\t\t\t \n\t\t\t\t\tha->isp_ops->reset_chip(vha);\n\t\t\t\t\tha->isp_ops->chip_diag(vha);\n\t\t\t\t\tgoto execute_fw_with_lr;\n\t\t\t\t}\n\n\t\t\t\tif (IS_ZIO_THRESHOLD_CAPABLE(ha))\n\t\t\t\t\tqla27xx_set_zio_threshold(vha,\n\t\t\t\t\t    ha->last_zio_threshold);\n\n\t\t\t\trval = qla2x00_set_exlogins_buffer(vha);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tgoto failed;\n\n\t\t\t\trval = qla2x00_set_exchoffld_buffer(vha);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tgoto failed;\n\nenable_82xx_npiv:\n\t\t\t\tfw_major_version = ha->fw_major_version;\n\t\t\t\tif (IS_P3P_TYPE(ha))\n\t\t\t\t\tqla82xx_check_md_needed(vha);\n\t\t\t\telse\n\t\t\t\t\trval = qla2x00_get_fw_version(vha);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tgoto failed;\n\t\t\t\tha->flags.npiv_supported = 0;\n\t\t\t\tif (IS_QLA2XXX_MIDTYPE(ha) &&\n\t\t\t\t\t (ha->fw_attributes & BIT_2)) {\n\t\t\t\t\tha->flags.npiv_supported = 1;\n\t\t\t\t\tif ((!ha->max_npiv_vports) ||\n\t\t\t\t\t    ((ha->max_npiv_vports + 1) %\n\t\t\t\t\t    MIN_MULTI_ID_FABRIC))\n\t\t\t\t\t\tha->max_npiv_vports =\n\t\t\t\t\t\t    MIN_MULTI_ID_FABRIC - 1;\n\t\t\t\t}\n\t\t\t\tqla2x00_get_resource_cnts(vha);\n\t\t\t\tqla_init_iocb_limit(vha);\n\n\t\t\t\t \n\t\t\t\trval = qla2x00_alloc_outstanding_cmds(ha,\n\t\t\t\t    vha->req);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tgoto failed;\n\n\t\t\t\tif (!fw_major_version && !(IS_P3P_TYPE(ha)))\n\t\t\t\t\tqla2x00_alloc_offload_mem(vha);\n\n\t\t\t\tif (ql2xallocfwdump && !(IS_P3P_TYPE(ha)))\n\t\t\t\t\tqla2x00_alloc_fw_dump(vha);\n\n\t\t\t} else {\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t} else {\n\t\t\tql_log(ql_log_fatal, vha, 0x00cd,\n\t\t\t    \"ISP Firmware failed checksum.\\n\");\n\t\t\tgoto failed;\n\t\t}\n\n\t\t \n\t\tif (ql2xrdpenable || ha->flags.scm_supported_f ||\n\t\t    ha->flags.edif_enabled)\n\t\t\tqla25xx_set_els_cmds_supported(vha);\n\t} else\n\t\tgoto failed;\n\n\tif (!IS_FWI2_CAPABLE(ha) && !IS_QLA2100(ha) && !IS_QLA2200(ha)) {\n\t\t \n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tif (IS_QLA2300(ha))\n\t\t\t \n\t\t\twrt_reg_word(&reg->hccr, HCCR_ENABLE_PARITY + 0x1);\n\t\telse\n\t\t\t \n\t\t\twrt_reg_word(&reg->hccr, HCCR_ENABLE_PARITY + 0x7);\n\t\trd_reg_word(&reg->hccr);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tha->flags.fac_supported = 1;\n\telse if (rval == QLA_SUCCESS && IS_FAC_REQUIRED(ha)) {\n\t\tuint32_t size;\n\n\t\trval = qla81xx_fac_get_sector_size(vha, &size);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tha->flags.fac_supported = 1;\n\t\t\tha->fdt_block_size = size << 2;\n\t\t} else {\n\t\t\tql_log(ql_log_warn, vha, 0x00ce,\n\t\t\t    \"Unsupported FAC firmware (%d.%02d.%02d).\\n\",\n\t\t\t    ha->fw_major_version, ha->fw_minor_version,\n\t\t\t    ha->fw_subminor_version);\n\n\t\t\tif (IS_QLA83XX(ha)) {\n\t\t\t\tha->flags.fac_supported = 0;\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\nfailed:\n\tif (rval) {\n\t\tql_log(ql_log_fatal, vha, 0x00cf,\n\t\t    \"Setup chip ****FAILED****.\\n\");\n\t}\n\n\treturn (rval);\n}\n\n \nvoid\nqla2x00_init_response_q_entries(struct rsp_que *rsp)\n{\n\tuint16_t cnt;\n\tresponse_t *pkt;\n\n\trsp->ring_ptr = rsp->ring;\n\trsp->ring_index    = 0;\n\trsp->status_srb = NULL;\n\tpkt = rsp->ring_ptr;\n\tfor (cnt = 0; cnt < rsp->length; cnt++) {\n\t\tpkt->signature = RESPONSE_PROCESSED;\n\t\tpkt++;\n\t}\n}\n\n \nvoid\nqla2x00_update_fw_options(scsi_qla_host_t *vha)\n{\n\tuint16_t swing, emphasis, tx_sens, rx_sens;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmemset(ha->fw_options, 0, sizeof(ha->fw_options));\n\tqla2x00_get_fw_options(vha, ha->fw_options);\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn;\n\n\t \n\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x0115,\n\t    \"Serial link options.\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0109,\n\t    ha->fw_seriallink_options, sizeof(ha->fw_seriallink_options));\n\n\tha->fw_options[1] &= ~FO1_SET_EMPHASIS_SWING;\n\tif (ha->fw_seriallink_options[3] & BIT_2) {\n\t\tha->fw_options[1] |= FO1_SET_EMPHASIS_SWING;\n\n\t\t \n\t\tswing = ha->fw_seriallink_options[2] & (BIT_2 | BIT_1 | BIT_0);\n\t\temphasis = (ha->fw_seriallink_options[2] &\n\t\t    (BIT_4 | BIT_3)) >> 3;\n\t\ttx_sens = ha->fw_seriallink_options[0] &\n\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\trx_sens = (ha->fw_seriallink_options[0] &\n\t\t    (BIT_7 | BIT_6 | BIT_5 | BIT_4)) >> 4;\n\t\tha->fw_options[10] = (emphasis << 14) | (swing << 8);\n\t\tif (IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA6312(ha)) {\n\t\t\tif (rx_sens == 0x0)\n\t\t\t\trx_sens = 0x3;\n\t\t\tha->fw_options[10] |= (tx_sens << 4) | rx_sens;\n\t\t} else if (IS_QLA2322(ha) || IS_QLA6322(ha))\n\t\t\tha->fw_options[10] |= BIT_5 |\n\t\t\t    ((rx_sens & (BIT_1 | BIT_0)) << 2) |\n\t\t\t    (tx_sens & (BIT_1 | BIT_0));\n\n\t\t \n\t\tswing = (ha->fw_seriallink_options[2] &\n\t\t    (BIT_7 | BIT_6 | BIT_5)) >> 5;\n\t\temphasis = ha->fw_seriallink_options[3] & (BIT_1 | BIT_0);\n\t\ttx_sens = ha->fw_seriallink_options[1] &\n\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\trx_sens = (ha->fw_seriallink_options[1] &\n\t\t    (BIT_7 | BIT_6 | BIT_5 | BIT_4)) >> 4;\n\t\tha->fw_options[11] = (emphasis << 14) | (swing << 8);\n\t\tif (IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA6312(ha)) {\n\t\t\tif (rx_sens == 0x0)\n\t\t\t\trx_sens = 0x3;\n\t\t\tha->fw_options[11] |= (tx_sens << 4) | rx_sens;\n\t\t} else if (IS_QLA2322(ha) || IS_QLA6322(ha))\n\t\t\tha->fw_options[11] |= BIT_5 |\n\t\t\t    ((rx_sens & (BIT_1 | BIT_0)) << 2) |\n\t\t\t    (tx_sens & (BIT_1 | BIT_0));\n\t}\n\n\t \n\t \n\tha->fw_options[3] |= BIT_13;\n\n\t \n\tif (ha->flags.enable_led_scheme)\n\t\tha->fw_options[2] |= BIT_12;\n\n\t \n\tif (IS_QLA6312(ha))\n\t\tha->fw_options[2] |= BIT_13;\n\n\t \n\tif (ha->operating_mode == P2P) {\n\t\tha->fw_options[2] |= BIT_3;\n\t\tql_dbg(ql_dbg_disc, vha, 0x2100,\n\t\t    \"(%s): Setting FLOGI retry BIT in fw_options[2]: 0x%x\\n\",\n\t\t\t__func__, ha->fw_options[2]);\n\t}\n\n\t \n\tqla2x00_set_fw_options(vha, ha->fw_options);\n}\n\nvoid\nqla24xx_update_fw_options(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn;\n\n\t \n\tif (ql2xfwholdabts)\n\t\tha->fw_options[3] |= BIT_12;\n\n\t \n\tif (ha->operating_mode == P2P) {\n\t\tha->fw_options[2] |= BIT_3;\n\t\tql_dbg(ql_dbg_disc, vha, 0x2101,\n\t\t    \"(%s): Setting FLOGI retry BIT in fw_options[2]: 0x%x\\n\",\n\t\t\t__func__, ha->fw_options[2]);\n\t}\n\n\t \n\tif (ql2xmvasynctoatio && !ha->flags.edif_enabled &&\n\t    (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))) {\n\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t    qla_dual_mode_enabled(vha))\n\t\t\tha->fw_options[2] |= BIT_11;\n\t\telse\n\t\t\tha->fw_options[2] &= ~BIT_11;\n\t}\n\n\tif (IS_QLA25XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\t \n\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t    qla_dual_mode_enabled(vha))\n\t\t\tha->fw_options[2] |= BIT_4;\n\t\telse\n\t\t\tha->fw_options[2] &= ~(BIT_4);\n\n\t\t \n\t\tif (qla2xuseresexchforels)\n\t\t\tha->fw_options[2] |= BIT_8;\n\t\telse\n\t\t\tha->fw_options[2] &= ~BIT_8;\n\n\t\t \n\t\tif (ha->flags.edif_enabled &&\n\t\t    DBELL_ACTIVE(vha)) {\n\t\t\tha->fw_options[3] |= BIT_15;\n\t\t\tha->flags.n2n_fw_acc_sec = 1;\n\t\t} else {\n\t\t\tha->fw_options[3] &= ~BIT_15;\n\t\t\tha->flags.n2n_fw_acc_sec = 0;\n\t\t}\n\t}\n\n\tif (ql2xrdpenable || ha->flags.scm_supported_f ||\n\t    ha->flags.edif_enabled)\n\t\tha->fw_options[1] |= ADD_FO1_ENABLE_PUREX_IOCB;\n\n\t \n\tif (IS_BPM_RANGE_CAPABLE(ha))\n\t\tha->fw_options[3] |= BIT_10;\n\n\tql_dbg(ql_dbg_init, vha, 0x00e8,\n\t    \"%s, add FW options 1-3 = 0x%04x 0x%04x 0x%04x mode %x\\n\",\n\t    __func__, ha->fw_options[1], ha->fw_options[2],\n\t    ha->fw_options[3], vha->host->active_mode);\n\n\tif (ha->fw_options[1] || ha->fw_options[2] || ha->fw_options[3])\n\t\tqla2x00_set_fw_options(vha, ha->fw_options);\n\n\t \n\tif ((le16_to_cpu(ha->fw_seriallink_options24[0]) & BIT_0) == 0)\n\t\treturn;\n\n\trval = qla2x00_set_serdes_params(vha,\n\t    le16_to_cpu(ha->fw_seriallink_options24[1]),\n\t    le16_to_cpu(ha->fw_seriallink_options24[2]),\n\t    le16_to_cpu(ha->fw_seriallink_options24[3]));\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x0104,\n\t\t    \"Unable to update Serial Link options (%x).\\n\", rval);\n\t}\n}\n\nvoid\nqla2x00_config_rings(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\n\t \n\tha->init_cb->request_q_outpointer = cpu_to_le16(0);\n\tha->init_cb->response_q_inpointer = cpu_to_le16(0);\n\tha->init_cb->request_q_length = cpu_to_le16(req->length);\n\tha->init_cb->response_q_length = cpu_to_le16(rsp->length);\n\tput_unaligned_le64(req->dma, &ha->init_cb->request_q_address);\n\tput_unaligned_le64(rsp->dma, &ha->init_cb->response_q_address);\n\n\twrt_reg_word(ISP_REQ_Q_IN(ha, reg), 0);\n\twrt_reg_word(ISP_REQ_Q_OUT(ha, reg), 0);\n\twrt_reg_word(ISP_RSP_Q_IN(ha, reg), 0);\n\twrt_reg_word(ISP_RSP_Q_OUT(ha, reg), 0);\n\trd_reg_word(ISP_RSP_Q_OUT(ha, reg));\t\t \n}\n\nvoid\nqla24xx_config_rings(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tdevice_reg_t *reg = ISP_QUE_REG(ha, 0);\n\tstruct device_reg_2xxx __iomem *ioreg = &ha->iobase->isp;\n\tstruct qla_msix_entry *msix;\n\tstruct init_cb_24xx *icb;\n\tuint16_t rid = 0;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\n\t \n\ticb = (struct init_cb_24xx *)ha->init_cb;\n\ticb->request_q_outpointer = cpu_to_le16(0);\n\ticb->response_q_inpointer = cpu_to_le16(0);\n\ticb->request_q_length = cpu_to_le16(req->length);\n\ticb->response_q_length = cpu_to_le16(rsp->length);\n\tput_unaligned_le64(req->dma, &icb->request_q_address);\n\tput_unaligned_le64(rsp->dma, &icb->response_q_address);\n\n\t \n\ticb->atio_q_inpointer = cpu_to_le16(0);\n\ticb->atio_q_length = cpu_to_le16(ha->tgt.atio_q_length);\n\tput_unaligned_le64(ha->tgt.atio_dma, &icb->atio_q_address);\n\n\tif (IS_SHADOW_REG_CAPABLE(ha))\n\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_30|BIT_29);\n\n\tif (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\ticb->qos = cpu_to_le16(QLA_DEFAULT_QUE_QOS);\n\t\ticb->rid = cpu_to_le16(rid);\n\t\tif (ha->flags.msix_enabled) {\n\t\t\tmsix = &ha->msix_entries[1];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0019,\n\t\t\t    \"Registering vector 0x%x for base que.\\n\",\n\t\t\t    msix->entry);\n\t\t\ticb->msix = cpu_to_le16(msix->entry);\n\t\t}\n\t\t \n\t\tif (MSB(rid))\n\t\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_19);\n\t\t \n\t\tif (LSB(rid))\n\t\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_18);\n\n\t\t \n\t\tif ((ha->fw_attributes & BIT_6) && (IS_MSIX_NACK_CAPABLE(ha)) &&\n\t\t    (ha->flags.msix_enabled)) {\n\t\t\ticb->firmware_options_2 &= cpu_to_le32(~BIT_22);\n\t\t\tha->flags.disable_msix_handshake = 1;\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00fe,\n\t\t\t    \"MSIX Handshake Disable Mode turned on.\\n\");\n\t\t} else {\n\t\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_22);\n\t\t}\n\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_23);\n\n\t\twrt_reg_dword(&reg->isp25mq.req_q_in, 0);\n\t\twrt_reg_dword(&reg->isp25mq.req_q_out, 0);\n\t\twrt_reg_dword(&reg->isp25mq.rsp_q_in, 0);\n\t\twrt_reg_dword(&reg->isp25mq.rsp_q_out, 0);\n\t} else {\n\t\twrt_reg_dword(&reg->isp24.req_q_in, 0);\n\t\twrt_reg_dword(&reg->isp24.req_q_out, 0);\n\t\twrt_reg_dword(&reg->isp24.rsp_q_in, 0);\n\t\twrt_reg_dword(&reg->isp24.rsp_q_out, 0);\n\t}\n\n\tqlt_24xx_config_rings(vha);\n\n\t \n\tif (ha->set_data_rate) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00fd,\n\t\t    \"Speed set by user : %s Gbps \\n\",\n\t\t    qla2x00_get_link_speed_str(ha, ha->set_data_rate));\n\t\ticb->firmware_options_3 = cpu_to_le32(ha->set_data_rate << 13);\n\t}\n\n\t \n\trd_reg_word(&ioreg->hccr);\n}\n\n \nint\nqla2x00_init_rings(scsi_qla_host_t *vha)\n{\n\tint\trval;\n\tunsigned long flags = 0;\n\tint cnt, que;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req;\n\tstruct rsp_que *rsp;\n\tstruct mid_init_cb_24xx *mid_init_cb =\n\t    (struct mid_init_cb_24xx *) ha->init_cb;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t \n\tfor (que = 0; que < ha->max_req_queues; que++) {\n\t\treq = ha->req_q_map[que];\n\t\tif (!req || !test_bit(que, ha->req_qid_map))\n\t\t\tcontinue;\n\t\treq->out_ptr = (uint16_t *)(req->ring + req->length);\n\t\t*req->out_ptr = 0;\n\t\tfor (cnt = 1; cnt < req->num_outstanding_cmds; cnt++)\n\t\t\treq->outstanding_cmds[cnt] = NULL;\n\n\t\treq->current_outstanding_cmd = 1;\n\n\t\t \n\t\treq->ring_ptr  = req->ring;\n\t\treq->ring_index    = 0;\n\t\treq->cnt      = req->length;\n\t}\n\n\tfor (que = 0; que < ha->max_rsp_queues; que++) {\n\t\trsp = ha->rsp_q_map[que];\n\t\tif (!rsp || !test_bit(que, ha->rsp_qid_map))\n\t\t\tcontinue;\n\t\trsp->in_ptr = (uint16_t *)(rsp->ring + rsp->length);\n\t\t*rsp->in_ptr = 0;\n\t\t \n\t\tif (IS_QLAFX00(ha))\n\t\t\tqlafx00_init_response_q_entries(rsp);\n\t\telse\n\t\t\tqla2x00_init_response_q_entries(rsp);\n\t}\n\n\tha->tgt.atio_ring_ptr = ha->tgt.atio_ring;\n\tha->tgt.atio_ring_index = 0;\n\t \n\tqlt_init_atio_q_entries(vha);\n\n\tha->isp_ops->config_rings(vha);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (IS_QLAFX00(ha)) {\n\t\trval = qlafx00_init_firmware(vha, ha->init_cb_size);\n\t\tgoto next_check;\n\t}\n\n\t \n\tha->isp_ops->update_fw_options(vha);\n\n\tql_dbg(ql_dbg_init, vha, 0x00d1,\n\t       \"Issue init firmware FW opt 1-3= %08x %08x %08x.\\n\",\n\t       le32_to_cpu(mid_init_cb->init_cb.firmware_options_1),\n\t       le32_to_cpu(mid_init_cb->init_cb.firmware_options_2),\n\t       le32_to_cpu(mid_init_cb->init_cb.firmware_options_3));\n\n\tif (ha->flags.npiv_supported) {\n\t\tif (ha->operating_mode == LOOP && !IS_CNA_CAPABLE(ha))\n\t\t\tha->max_npiv_vports = MIN_MULTI_ID_FABRIC - 1;\n\t\tmid_init_cb->count = cpu_to_le16(ha->max_npiv_vports);\n\t}\n\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tmid_init_cb->options = cpu_to_le16(BIT_1);\n\t\tmid_init_cb->init_cb.execution_throttle =\n\t\t    cpu_to_le16(ha->cur_fw_xcb_count);\n\t\tha->flags.dport_enabled =\n\t\t\t(le32_to_cpu(mid_init_cb->init_cb.firmware_options_1) &\n\t\t\t BIT_7) != 0;\n\t\tql_dbg(ql_dbg_init, vha, 0x0191, \"DPORT Support: %s.\\n\",\n\t\t    (ha->flags.dport_enabled) ? \"enabled\" : \"disabled\");\n\t\t \n\t\tha->flags.fawwpn_enabled =\n\t\t\t(le32_to_cpu(mid_init_cb->init_cb.firmware_options_1) &\n\t\t\t BIT_6) != 0;\n\t\tql_dbg(ql_dbg_init, vha, 0x00bc, \"FA-WWPN Support: %s.\\n\",\n\t\t    (ha->flags.fawwpn_enabled) ? \"enabled\" : \"disabled\");\n\t\t \n\t\tmemcpy(ha->port_name, ha->init_cb->port_name, WWN_SIZE);\n\t}\n\n\t \n\tif (ha->flags.edif_enabled)\n\t\tmid_init_cb->init_cb.frame_payload_size = cpu_to_le16(ELS_MAX_PAYLOAD);\n\n\tQLA_FW_STARTED(ha);\n\trval = qla2x00_init_firmware(vha, ha->init_cb_size);\nnext_check:\n\tif (rval) {\n\t\tQLA_FW_STOPPED(ha);\n\t\tql_log(ql_log_fatal, vha, 0x00d2,\n\t\t    \"Init Firmware **** FAILED ****.\\n\");\n\t} else {\n\t\tql_dbg(ql_dbg_init, vha, 0x00d3,\n\t\t    \"Init Firmware -- success.\\n\");\n\t\tvha->u_ql2xexchoffld = vha->u_ql2xiniexchg = 0;\n\t}\n\n\treturn (rval);\n}\n\n \nstatic int\nqla2x00_fw_ready(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tunsigned long\twtime, mtime, cs84xx_time;\n\tuint16_t\tmin_wait;\t \n\tuint16_t\twait_time;\t \n\tuint16_t\tstate[6];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLAFX00(vha->hw))\n\t\treturn qlafx00_fw_ready(vha);\n\n\t \n\tif (IS_P3P_TYPE(ha))\n\t\tmin_wait = 30;\n\telse\n\t\tmin_wait = 20;\n\n\t \n\tif ((wait_time = (ha->retry_count*ha->login_timeout) + 5) < min_wait) {\n\t\twait_time = min_wait;\n\t}\n\n\t \n\tmtime = jiffies + (min_wait * HZ);\n\n\t \n\twtime = jiffies + (wait_time * HZ);\n\n\t \n\tif (!vha->flags.init_done)\n\t\tql_log(ql_log_info, vha, 0x801e,\n\t\t    \"Waiting for LIP to complete.\\n\");\n\n\tdo {\n\t\tmemset(state, -1, sizeof(state));\n\t\trval = qla2x00_get_firmware_state(vha, state);\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tif (state[0] < FSTATE_LOSS_OF_SYNC) {\n\t\t\t\tvha->device_flags &= ~DFLG_NO_CABLE;\n\t\t\t}\n\t\t\tif (IS_QLA84XX(ha) && state[0] != FSTATE_READY) {\n\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x801f,\n\t\t\t\t    \"fw_state=%x 84xx=%x.\\n\", state[0],\n\t\t\t\t    state[2]);\n\t\t\t\tif ((state[2] & FSTATE_LOGGED_IN) &&\n\t\t\t\t     (state[2] & FSTATE_WAITING_FOR_VERIFY)) {\n\t\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8028,\n\t\t\t\t\t    \"Sending verify iocb.\\n\");\n\n\t\t\t\t\tcs84xx_time = jiffies;\n\t\t\t\t\trval = qla84xx_init_chip(vha);\n\t\t\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\t\t\tql_log(ql_log_warn,\n\t\t\t\t\t\t    vha, 0x8007,\n\t\t\t\t\t\t    \"Init chip failed.\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tcs84xx_time = jiffies - cs84xx_time;\n\t\t\t\t\twtime += cs84xx_time;\n\t\t\t\t\tmtime += cs84xx_time;\n\t\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8008,\n\t\t\t\t\t    \"Increasing wait time by %ld. \"\n\t\t\t\t\t    \"New time %ld.\\n\", cs84xx_time,\n\t\t\t\t\t    wtime);\n\t\t\t\t}\n\t\t\t} else if (state[0] == FSTATE_READY) {\n\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8037,\n\t\t\t\t    \"F/W Ready - OK.\\n\");\n\n\t\t\t\tqla2x00_get_retry_cnt(vha, &ha->retry_count,\n\t\t\t\t    &ha->login_timeout, &ha->r_a_tov);\n\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trval = QLA_FUNCTION_FAILED;\n\n\t\t\tif (atomic_read(&vha->loop_down_timer) &&\n\t\t\t    state[0] != FSTATE_READY) {\n\t\t\t\t \n\t\t\t\tif (time_after_eq(jiffies, mtime)) {\n\t\t\t\t\tql_log(ql_log_info, vha, 0x8038,\n\t\t\t\t\t    \"Cable is unplugged...\\n\");\n\n\t\t\t\t\tvha->device_flags |= DFLG_NO_CABLE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (time_after_eq(jiffies, mtime) ||\n\t\t\t\tha->flags.isp82xx_fw_hung)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (time_after_eq(jiffies, wtime))\n\t\t\tbreak;\n\n\t\t \n\t\tmsleep(500);\n\t} while (1);\n\n\tql_dbg(ql_dbg_taskm, vha, 0x803a,\n\t    \"fw_state=%x (%x, %x, %x, %x %x) curr time=%lx.\\n\", state[0],\n\t    state[1], state[2], state[3], state[4], state[5], jiffies);\n\n\tif (rval && !(vha->device_flags & DFLG_NO_CABLE)) {\n\t\tql_log(ql_log_warn, vha, 0x803b,\n\t\t    \"Firmware ready **** FAILED ****.\\n\");\n\t}\n\n\treturn (rval);\n}\n\n \nstatic int\nqla2x00_configure_hba(scsi_qla_host_t *vha)\n{\n\tint       rval;\n\tuint16_t      loop_id;\n\tuint16_t      topo;\n\tuint16_t      sw_cap;\n\tuint8_t       al_pa;\n\tuint8_t       area;\n\tuint8_t       domain;\n\tchar\t\tconnect_type[22];\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tport_id_t id;\n\tunsigned long flags;\n\n\t \n\trval = qla2x00_get_adapter_id(vha,\n\t    &loop_id, &al_pa, &area, &domain, &topo, &sw_cap);\n\tif (rval != QLA_SUCCESS) {\n\t\tif (LOOP_TRANSITION(vha) || atomic_read(&ha->loop_down_timer) ||\n\t\t    IS_CNA_CAPABLE(ha) ||\n\t\t    (rval == QLA_COMMAND_ERROR && loop_id == 0x7)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2008,\n\t\t\t    \"Loop is in a transition state.\\n\");\n\t\t} else {\n\t\t\tql_log(ql_log_warn, vha, 0x2009,\n\t\t\t    \"Unable to get host loop ID.\\n\");\n\t\t\tif (IS_FWI2_CAPABLE(ha) && (vha == base_vha) &&\n\t\t\t    (rval == QLA_COMMAND_ERROR && loop_id == 0x1b)) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x1151,\n\t\t\t\t    \"Doing link init.\\n\");\n\t\t\t\tif (qla24xx_link_initialize(vha) == QLA_SUCCESS)\n\t\t\t\t\treturn rval;\n\t\t\t}\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t}\n\t\treturn (rval);\n\t}\n\n\tif (topo == 4) {\n\t\tql_log(ql_log_info, vha, 0x200a,\n\t\t    \"Cannot get topology - retrying.\\n\");\n\t\treturn (QLA_FUNCTION_FAILED);\n\t}\n\n\tvha->loop_id = loop_id;\n\n\t \n\tha->min_external_loopid = SNS_FIRST_LOOP_ID;\n\tha->operating_mode = LOOP;\n\n\tswitch (topo) {\n\tcase 0:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200b, \"HBA in NL topology.\\n\");\n\t\tha->switch_cap = 0;\n\t\tha->current_topology = ISP_CFG_NL;\n\t\tstrcpy(connect_type, \"(Loop)\");\n\t\tbreak;\n\n\tcase 1:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200c, \"HBA in FL topology.\\n\");\n\t\tha->switch_cap = sw_cap;\n\t\tha->current_topology = ISP_CFG_FL;\n\t\tstrcpy(connect_type, \"(FL_Port)\");\n\t\tbreak;\n\n\tcase 2:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200d, \"HBA in N P2P topology.\\n\");\n\t\tha->switch_cap = 0;\n\t\tha->operating_mode = P2P;\n\t\tha->current_topology = ISP_CFG_N;\n\t\tstrcpy(connect_type, \"(N_Port-to-N_Port)\");\n\t\tbreak;\n\n\tcase 3:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200e, \"HBA in F P2P topology.\\n\");\n\t\tha->switch_cap = sw_cap;\n\t\tha->operating_mode = P2P;\n\t\tha->current_topology = ISP_CFG_F;\n\t\tstrcpy(connect_type, \"(F_Port)\");\n\t\tbreak;\n\n\tdefault:\n\t\tql_dbg(ql_dbg_disc, vha, 0x200f,\n\t\t    \"HBA in unknown topology %x, using NL.\\n\", topo);\n\t\tha->switch_cap = 0;\n\t\tha->current_topology = ISP_CFG_NL;\n\t\tstrcpy(connect_type, \"(Loop)\");\n\t\tbreak;\n\t}\n\n\t \n\t \n\tid.b.domain = domain;\n\tid.b.area = area;\n\tid.b.al_pa = al_pa;\n\tid.b.rsvd_1 = 0;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tif (vha->hw->flags.edif_enabled) {\n\t\tif (topo != 2)\n\t\t\tqla_update_host_map(vha, id);\n\t} else if (!(topo == 2 && ha->flags.n2n_bigger))\n\t\tqla_update_host_map(vha, id);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (!vha->flags.init_done)\n\t\tql_log(ql_log_info, vha, 0x2010,\n\t\t    \"Topology - %s, Host Loop address 0x%x.\\n\",\n\t\t    connect_type, vha->loop_id);\n\n\treturn(rval);\n}\n\ninline void\nqla2x00_set_model_info(scsi_qla_host_t *vha, uint8_t *model, size_t len,\n\t\t       const char *def)\n{\n\tchar *st, *en;\n\tuint16_t index;\n\tuint64_t zero[2] = { 0 };\n\tstruct qla_hw_data *ha = vha->hw;\n\tint use_tbl = !IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&\n\t    !IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha);\n\n\tif (len > sizeof(zero))\n\t\tlen = sizeof(zero);\n\tif (memcmp(model, &zero, len) != 0) {\n\t\tmemcpy(ha->model_number, model, len);\n\t\tst = en = ha->model_number;\n\t\ten += len - 1;\n\t\twhile (en > st) {\n\t\t\tif (*en != 0x20 && *en != 0x00)\n\t\t\t\tbreak;\n\t\t\t*en-- = '\\0';\n\t\t}\n\n\t\tindex = (ha->pdev->subsystem_device & 0xff);\n\t\tif (use_tbl &&\n\t\t    ha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&\n\t\t    index < QLA_MODEL_NAMES)\n\t\t\tstrscpy(ha->model_desc,\n\t\t\t    qla2x00_model_name[index * 2 + 1],\n\t\t\t    sizeof(ha->model_desc));\n\t} else {\n\t\tindex = (ha->pdev->subsystem_device & 0xff);\n\t\tif (use_tbl &&\n\t\t    ha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&\n\t\t    index < QLA_MODEL_NAMES) {\n\t\t\tstrscpy(ha->model_number,\n\t\t\t\tqla2x00_model_name[index * 2],\n\t\t\t\tsizeof(ha->model_number));\n\t\t\tstrscpy(ha->model_desc,\n\t\t\t    qla2x00_model_name[index * 2 + 1],\n\t\t\t    sizeof(ha->model_desc));\n\t\t} else {\n\t\t\tstrscpy(ha->model_number, def,\n\t\t\t\tsizeof(ha->model_number));\n\t\t}\n\t}\n\tif (IS_FWI2_CAPABLE(ha))\n\t\tqla2xxx_get_vpd_field(vha, \"\\x82\", ha->model_desc,\n\t\t    sizeof(ha->model_desc));\n}\n\n \nstatic void qla2xxx_nvram_wwn_from_ofw(scsi_qla_host_t *vha, nvram_t *nv)\n{\n#ifdef CONFIG_SPARC\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct pci_dev *pdev = ha->pdev;\n\tstruct device_node *dp = pci_device_to_OF_node(pdev);\n\tconst u8 *val;\n\tint len;\n\n\tval = of_get_property(dp, \"port-wwn\", &len);\n\tif (val && len >= WWN_SIZE)\n\t\tmemcpy(nv->port_name, val, WWN_SIZE);\n\n\tval = of_get_property(dp, \"node-wwn\", &len);\n\tif (val && len >= WWN_SIZE)\n\t\tmemcpy(nv->node_name, val, WWN_SIZE);\n#endif\n}\n\n \nint\nqla2x00_nvram_config(scsi_qla_host_t *vha)\n{\n\tint             rval;\n\tuint8_t         chksum = 0;\n\tuint16_t        cnt;\n\tuint8_t         *dptr1, *dptr2;\n\tstruct qla_hw_data *ha = vha->hw;\n\tinit_cb_t       *icb = ha->init_cb;\n\tnvram_t         *nv = ha->nvram;\n\tuint8_t         *ptr = ha->nvram;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\trval = QLA_SUCCESS;\n\n\t \n\tha->nvram_size = sizeof(*nv);\n\tha->nvram_base = 0;\n\tif (!IS_QLA2100(ha) && !IS_QLA2200(ha) && !IS_QLA2300(ha))\n\t\tif ((rd_reg_word(&reg->ctrl_status) >> 14) == 1)\n\t\t\tha->nvram_base = 0x80;\n\n\t \n\tha->isp_ops->read_nvram(vha, ptr, ha->nvram_base, ha->nvram_size);\n\tfor (cnt = 0, chksum = 0; cnt < ha->nvram_size; cnt++)\n\t\tchksum += *ptr++;\n\n\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x010f,\n\t    \"Contents of NVRAM.\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0110,\n\t    nv, ha->nvram_size);\n\n\t \n\tif (chksum || memcmp(\"ISP \", nv->id, sizeof(nv->id)) ||\n\t    nv->nvram_version < 1) {\n\t\t \n\t\tql_log(ql_log_warn, vha, 0x0064,\n\t\t    \"Inconsistent NVRAM detected: checksum=%#x id=%.4s version=%#x.\\n\",\n\t\t    chksum, nv->id, nv->nvram_version);\n\t\tql_log(ql_log_warn, vha, 0x0065,\n\t\t    \"Falling back to \"\n\t\t    \"functioning (yet invalid -- WWPN) defaults.\\n\");\n\n\t\t \n\t\tmemset(nv, 0, ha->nvram_size);\n\t\tnv->parameter_block_version = ICB_VERSION;\n\n\t\tif (IS_QLA23XX(ha)) {\n\t\t\tnv->firmware_options[0] = BIT_2 | BIT_1;\n\t\t\tnv->firmware_options[1] = BIT_7 | BIT_5;\n\t\t\tnv->add_firmware_options[0] = BIT_5;\n\t\t\tnv->add_firmware_options[1] = BIT_5 | BIT_4;\n\t\t\tnv->frame_payload_size = cpu_to_le16(2048);\n\t\t\tnv->special_options[1] = BIT_7;\n\t\t} else if (IS_QLA2200(ha)) {\n\t\t\tnv->firmware_options[0] = BIT_2 | BIT_1;\n\t\t\tnv->firmware_options[1] = BIT_7 | BIT_5;\n\t\t\tnv->add_firmware_options[0] = BIT_5;\n\t\t\tnv->add_firmware_options[1] = BIT_5 | BIT_4;\n\t\t\tnv->frame_payload_size = cpu_to_le16(1024);\n\t\t} else if (IS_QLA2100(ha)) {\n\t\t\tnv->firmware_options[0] = BIT_3 | BIT_1;\n\t\t\tnv->firmware_options[1] = BIT_5;\n\t\t\tnv->frame_payload_size = cpu_to_le16(1024);\n\t\t}\n\n\t\tnv->max_iocb_allocation = cpu_to_le16(256);\n\t\tnv->execution_throttle = cpu_to_le16(16);\n\t\tnv->retry_count = 8;\n\t\tnv->retry_delay = 1;\n\n\t\tnv->port_name[0] = 33;\n\t\tnv->port_name[3] = 224;\n\t\tnv->port_name[4] = 139;\n\n\t\tqla2xxx_nvram_wwn_from_ofw(vha, nv);\n\n\t\tnv->login_timeout = 4;\n\n\t\t \n\t\tnv->host_p[1] = BIT_2;\n\t\tnv->reset_delay = 5;\n\t\tnv->port_down_retry_count = 8;\n\t\tnv->max_luns_per_target = cpu_to_le16(8);\n\t\tnv->link_down_timeout = 60;\n\n\t\trval = 1;\n\t}\n\n\t \n\tmemset(icb, 0, ha->init_cb_size);\n\n\t \n\tnv->firmware_options[0] |= (BIT_6 | BIT_1);\n\tnv->firmware_options[0] &= ~(BIT_5 | BIT_4);\n\tnv->firmware_options[1] |= (BIT_5 | BIT_0);\n\tnv->firmware_options[1] &= ~BIT_4;\n\n\tif (IS_QLA23XX(ha)) {\n\t\tnv->firmware_options[0] |= BIT_2;\n\t\tnv->firmware_options[0] &= ~BIT_3;\n\t\tnv->special_options[0] &= ~BIT_6;\n\t\tnv->add_firmware_options[1] |= BIT_5 | BIT_4;\n\n\t\tif (IS_QLA2300(ha)) {\n\t\t\tif (ha->fb_rev == FPM_2310) {\n\t\t\t\tstrcpy(ha->model_number, \"QLA2310\");\n\t\t\t} else {\n\t\t\t\tstrcpy(ha->model_number, \"QLA2300\");\n\t\t\t}\n\t\t} else {\n\t\t\tqla2x00_set_model_info(vha, nv->model_number,\n\t\t\t    sizeof(nv->model_number), \"QLA23xx\");\n\t\t}\n\t} else if (IS_QLA2200(ha)) {\n\t\tnv->firmware_options[0] |= BIT_2;\n\t\t \n\t\tif ((nv->add_firmware_options[0] & (BIT_6 | BIT_5 | BIT_4)) ==\n\t\t    (BIT_5 | BIT_4)) {\n\t\t\t \n\t\t\tnv->add_firmware_options[0] &= ~(BIT_6 | BIT_5 | BIT_4);\n\t\t\tnv->add_firmware_options[0] |= BIT_5;\n\t\t}\n\t\tstrcpy(ha->model_number, \"QLA22xx\");\n\t} else   {\n\t\tstrcpy(ha->model_number, \"QLA2100\");\n\t}\n\n\t \n\tdptr1 = (uint8_t *)icb;\n\tdptr2 = (uint8_t *)&nv->parameter_block_version;\n\tcnt = (uint8_t *)&icb->request_q_outpointer - (uint8_t *)&icb->version;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\n\t \n\tdptr1 = (uint8_t *)icb->add_firmware_options;\n\tcnt = (uint8_t *)icb->reserved_3 - (uint8_t *)icb->add_firmware_options;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\tha->frame_payload_size = le16_to_cpu(icb->frame_payload_size);\n\t \n\tif (nv->host_p[1] & BIT_7) {\n\t\tmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\n\t\tmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\n\t}\n\n\t \n\tif ((icb->firmware_options[1] & BIT_6) == 0) {\n\t\t \n\t\tmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\n\t\ticb->node_name[0] &= 0xF0;\n\t}\n\n\t \n\n\t \n\tif (nv->host_p[0] & BIT_7)\n\t\tql2xextended_error_logging = QL_DBG_DEFAULT1_MASK;\n\tha->flags.disable_risc_code_load = ((nv->host_p[0] & BIT_4) ? 1 : 0);\n\t \n\tif (!IS_QLA2100(ha) && !IS_QLA2200(ha))\n\t\tha->flags.disable_risc_code_load = 0;\n\tha->flags.enable_lip_reset = ((nv->host_p[1] & BIT_1) ? 1 : 0);\n\tha->flags.enable_lip_full_login = ((nv->host_p[1] & BIT_2) ? 1 : 0);\n\tha->flags.enable_target_reset = ((nv->host_p[1] & BIT_3) ? 1 : 0);\n\tha->flags.enable_led_scheme = (nv->special_options[1] & BIT_4) ? 1 : 0;\n\tha->flags.disable_serdes = 0;\n\n\tha->operating_mode =\n\t    (icb->add_firmware_options[0] & (BIT_6 | BIT_5 | BIT_4)) >> 4;\n\n\tmemcpy(ha->fw_seriallink_options, nv->seriallink_options,\n\t    sizeof(ha->fw_seriallink_options));\n\n\t \n\tha->serial0 = icb->port_name[5];\n\tha->serial1 = icb->port_name[6];\n\tha->serial2 = icb->port_name[7];\n\tmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\n\tmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\n\n\ticb->execution_throttle = cpu_to_le16(0xFFFF);\n\n\tha->retry_count = nv->retry_count;\n\n\t \n\tif (nv->login_timeout != ql2xlogintimeout)\n\t\tnv->login_timeout = ql2xlogintimeout;\n\tif (nv->login_timeout < 4)\n\t\tnv->login_timeout = 4;\n\tha->login_timeout = nv->login_timeout;\n\n\t \n\tha->r_a_tov = 100;\n\n\tha->loop_reset_delay = nv->reset_delay;\n\n\t \n\tif (nv->link_down_timeout == 0) {\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\n\t} else {\n\t\tha->link_down_timeout =\t nv->link_down_timeout;\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - ha->link_down_timeout);\n\t}\n\n\t \n\tha->port_down_retry_count = nv->port_down_retry_count;\n\tif (qlport_down_retry)\n\t\tha->port_down_retry_count = qlport_down_retry;\n\t \n\tha->login_retry_count  = nv->retry_count;\n\tif (ha->port_down_retry_count == nv->port_down_retry_count &&\n\t    ha->port_down_retry_count > 3)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\telse if (ha->port_down_retry_count > (int)ha->login_retry_count)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\tif (ql2xloginretrycount)\n\t\tha->login_retry_count = ql2xloginretrycount;\n\n\ticb->lun_enables = cpu_to_le16(0);\n\ticb->command_resource_count = 0;\n\ticb->immediate_notify_resource_count = 0;\n\ticb->timeout = cpu_to_le16(0);\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t\t \n\t\ticb->firmware_options[0] &= ~BIT_3;\n\t\ticb->add_firmware_options[0] &=\n\t\t    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\ticb->add_firmware_options[0] |= BIT_2;\n\t\ticb->response_accumulation_timer = 3;\n\t\ticb->interrupt_delay_timer = 5;\n\n\t\tvha->flags.process_response_queue = 1;\n\t} else {\n\t\t \n\t\tif (!vha->flags.init_done) {\n\t\t\tha->zio_mode = icb->add_firmware_options[0] &\n\t\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\t\tha->zio_timer = icb->interrupt_delay_timer ?\n\t\t\t    icb->interrupt_delay_timer : 2;\n\t\t}\n\t\ticb->add_firmware_options[0] &=\n\t\t    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\tvha->flags.process_response_queue = 0;\n\t\tif (ha->zio_mode != QLA_ZIO_DISABLED) {\n\t\t\tha->zio_mode = QLA_ZIO_MODE_6;\n\n\t\t\tql_log(ql_log_info, vha, 0x0068,\n\t\t\t    \"ZIO mode %d enabled; timer delay (%d us).\\n\",\n\t\t\t    ha->zio_mode, ha->zio_timer * 100);\n\n\t\t\ticb->add_firmware_options[0] |= (uint8_t)ha->zio_mode;\n\t\t\ticb->interrupt_delay_timer = (uint8_t)ha->zio_timer;\n\t\t\tvha->flags.process_response_queue = 1;\n\t\t}\n\t}\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0069,\n\t\t    \"NVRAM configuration failed.\\n\");\n\t}\n\treturn (rval);\n}\n\nvoid qla2x00_set_fcport_state(fc_port_t *fcport, int state)\n{\n\tint old_state;\n\n\told_state = atomic_read(&fcport->state);\n\tatomic_set(&fcport->state, state);\n\n\t \n\tif (old_state && old_state != state) {\n\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x207d,\n\t\t       \"FCPort %8phC state transitioned from %s to %s - portid=%02x%02x%02x.\\n\",\n\t\t       fcport->port_name, port_state_str[old_state],\n\t\t       port_state_str[state], fcport->d_id.b.domain,\n\t\t       fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\t}\n}\n\n \nfc_port_t *\nqla2x00_alloc_fcport(scsi_qla_host_t *vha, gfp_t flags)\n{\n\tfc_port_t *fcport;\n\n\tfcport = kzalloc(sizeof(fc_port_t), flags);\n\tif (!fcport)\n\t\treturn NULL;\n\n\tfcport->ct_desc.ct_sns = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t\tsizeof(struct ct_sns_pkt), &fcport->ct_desc.ct_sns_dma,\n\t\tflags);\n\tif (!fcport->ct_desc.ct_sns) {\n\t\tql_log(ql_log_warn, vha, 0xd049,\n\t\t    \"Failed to allocate ct_sns request.\\n\");\n\t\tkfree(fcport);\n\t\treturn NULL;\n\t}\n\n\t \n\tfcport->vha = vha;\n\tfcport->port_type = FCT_UNKNOWN;\n\tfcport->loop_id = FC_NO_LOOP_ID;\n\tqla2x00_set_fcport_state(fcport, FCS_UNCONFIGURED);\n\tfcport->supported_classes = FC_COS_UNSPECIFIED;\n\tfcport->fp_speed = PORT_SPEED_UNKNOWN;\n\n\tfcport->disc_state = DSC_DELETED;\n\tfcport->fw_login_state = DSC_LS_PORT_UNAVAIL;\n\tfcport->deleted = QLA_SESS_DELETED;\n\tfcport->login_retry = vha->hw->login_retry_count;\n\tfcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\tfcport->logout_on_delete = 1;\n\tfcport->tgt_link_down_time = QLA2XX_MAX_LINK_DOWN_TIME;\n\tfcport->tgt_short_link_down_cnt = 0;\n\tfcport->dev_loss_tmo = 0;\n\n\tif (!fcport->ct_desc.ct_sns) {\n\t\tql_log(ql_log_warn, vha, 0xd049,\n\t\t    \"Failed to allocate ct_sns request.\\n\");\n\t\tkfree(fcport);\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&fcport->del_work, qla24xx_delete_sess_fn);\n\tINIT_WORK(&fcport->free_work, qlt_free_session_done);\n\tINIT_WORK(&fcport->reg_work, qla_register_fcport_fn);\n\tINIT_LIST_HEAD(&fcport->gnl_entry);\n\tINIT_LIST_HEAD(&fcport->list);\n\tINIT_LIST_HEAD(&fcport->unsol_ctx_head);\n\n\tINIT_LIST_HEAD(&fcport->sess_cmd_list);\n\tspin_lock_init(&fcport->sess_cmd_lock);\n\n\tspin_lock_init(&fcport->edif.sa_list_lock);\n\tINIT_LIST_HEAD(&fcport->edif.tx_sa_list);\n\tINIT_LIST_HEAD(&fcport->edif.rx_sa_list);\n\n\tspin_lock_init(&fcport->edif.indx_list_lock);\n\tINIT_LIST_HEAD(&fcport->edif.edif_indx_list);\n\n\treturn fcport;\n}\n\nvoid\nqla2x00_free_fcport(fc_port_t *fcport)\n{\n\tif (fcport->ct_desc.ct_sns) {\n\t\tdma_free_coherent(&fcport->vha->hw->pdev->dev,\n\t\t\tsizeof(struct ct_sns_pkt), fcport->ct_desc.ct_sns,\n\t\t\tfcport->ct_desc.ct_sns_dma);\n\n\t\tfcport->ct_desc.ct_sns = NULL;\n\t}\n\n\tqla_edif_flush_sa_ctl_lists(fcport);\n\tlist_del(&fcport->list);\n\tqla2x00_clear_loop_id(fcport);\n\n\tqla_edif_list_del(fcport);\n\n\tkfree(fcport);\n}\n\nstatic void qla_get_login_template(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\tu32 *bp, sz;\n\t__be32 *q;\n\n\tmemset(ha->init_cb, 0, ha->init_cb_size);\n\tsz = min_t(int, sizeof(struct fc_els_flogi), ha->init_cb_size);\n\trval = qla24xx_get_port_login_templ(vha, ha->init_cb_dma,\n\t\t\t\t\t    ha->init_cb, sz);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_init, vha, 0x00d1,\n\t\t       \"PLOGI ELS param read fail.\\n\");\n\t\treturn;\n\t}\n\tq = (__be32 *)&ha->plogi_els_payld.fl_csp;\n\n\tbp = (uint32_t *)ha->init_cb;\n\tcpu_to_be32_array(q, bp, sz / 4);\n\tha->flags.plogi_template_valid = 1;\n}\n\n \nstatic int\nqla2x00_configure_loop(scsi_qla_host_t *vha)\n{\n\tint  rval;\n\tunsigned long flags, save_flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\trval = QLA_SUCCESS;\n\n\t \n\tif (test_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags)) {\n\t\trval = qla2x00_configure_hba(vha);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2013,\n\t\t\t    \"Unable to configure HBA.\\n\");\n\t\t\treturn (rval);\n\t\t}\n\t}\n\n\tsave_flags = flags = vha->dpc_flags;\n\tql_dbg(ql_dbg_disc, vha, 0x2014,\n\t    \"Configure loop -- dpc flags = 0x%lx.\\n\", flags);\n\n\t \n\tclear_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\tclear_bit(RSCN_UPDATE, &vha->dpc_flags);\n\n\tqla2x00_get_data_rate(vha);\n\tqla_get_login_template(vha);\n\n\t \n\tif ((ha->current_topology == ISP_CFG_FL ||\n\t    ha->current_topology == ISP_CFG_F) &&\n\t    (test_bit(LOCAL_LOOP_UPDATE, &flags))) {\n\n\t\tset_bit(RSCN_UPDATE, &flags);\n\t\tclear_bit(LOCAL_LOOP_UPDATE, &flags);\n\n\t} else if (ha->current_topology == ISP_CFG_NL ||\n\t\t   ha->current_topology == ISP_CFG_N) {\n\t\tclear_bit(RSCN_UPDATE, &flags);\n\t\tset_bit(LOCAL_LOOP_UPDATE, &flags);\n\t} else if (!vha->flags.online ||\n\t    (test_bit(ABORT_ISP_ACTIVE, &flags))) {\n\t\tset_bit(RSCN_UPDATE, &flags);\n\t\tset_bit(LOCAL_LOOP_UPDATE, &flags);\n\t}\n\n\tif (test_bit(LOCAL_LOOP_UPDATE, &flags)) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2015,\n\t\t\t    \"Loop resync needed, failing.\\n\");\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else\n\t\t\trval = qla2x00_configure_local_loop(vha);\n\t}\n\n\tif (rval == QLA_SUCCESS && test_bit(RSCN_UPDATE, &flags)) {\n\t\tif (LOOP_TRANSITION(vha)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2099,\n\t\t\t    \"Needs RSCN update and loop transition.\\n\");\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t}\n\t\telse\n\t\t\trval = qla2x00_configure_fabric(vha);\n\t}\n\n\tif (rval == QLA_SUCCESS) {\n\t\tif (atomic_read(&vha->loop_down_timer) ||\n\t\t    test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else {\n\t\t\tatomic_set(&vha->loop_state, LOOP_READY);\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2069,\n\t\t\t    \"LOOP READY.\\n\");\n\t\t\tha->flags.fw_init_done = 1;\n\n\t\t\t \n\t\t\tif (ha->flags.edif_enabled && DBELL_INACTIVE(vha))\n\t\t\t\tqla2x00_post_aen_work(vha, FCH_EVT_LINKUP,\n\t\t\t\t\t\t      ha->link_data_rate);\n\n\t\t\t \n\t\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t\t    qla_dual_mode_enabled(vha)) {\n\t\t\t\tspin_lock_irqsave(&ha->tgt.atio_lock, flags);\n\t\t\t\tqlt_24xx_process_atio_queue(vha, 0);\n\t\t\t\tspin_unlock_irqrestore(&ha->tgt.atio_lock,\n\t\t\t\t    flags);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rval) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x206a,\n\t\t    \"%s *** FAILED ***.\\n\", __func__);\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x206b,\n\t\t    \"%s: exiting normally. local port wwpn %8phN id %06x)\\n\",\n\t\t    __func__, vha->port_name, vha->d_id.b24);\n\t}\n\n\t \n\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\n\t\tif (test_bit(LOCAL_LOOP_UPDATE, &save_flags))\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\tif (test_bit(RSCN_UPDATE, &save_flags)) {\n\t\t\tset_bit(RSCN_UPDATE, &vha->dpc_flags);\n\t\t}\n\t}\n\n\treturn (rval);\n}\n\nstatic int qla2x00_configure_n2n_loop(scsi_qla_host_t *vha)\n{\n\tunsigned long flags;\n\tfc_port_t *fcport;\n\n\tql_dbg(ql_dbg_disc, vha, 0x206a, \"%s %d.\\n\", __func__, __LINE__);\n\n\tif (test_and_clear_bit(N2N_LOGIN_NEEDED, &vha->dpc_flags))\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->n2n_flag) {\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tvha->scan.scan_retry++;\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\tif (vha->scan.scan_retry < MAX_SCAN_RETRIES) {\n\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t}\n\treturn QLA_FUNCTION_FAILED;\n}\n\nstatic void\nqla_reinitialize_link(scsi_qla_host_t *vha)\n{\n\tint rval;\n\n\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\trval = qla2x00_full_login_lip(vha);\n\tif (rval == QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xd050, \"Link reinitialized\\n\");\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0xd051,\n\t\t\t\"Link reinitialization failed (%d)\\n\", rval);\n\t}\n}\n\n \nstatic int\nqla2x00_configure_local_loop(scsi_qla_host_t *vha)\n{\n\tint\t\trval, rval2;\n\tint\t\tfound;\n\tfc_port_t\t*fcport, *new_fcport;\n\tuint16_t\tindex;\n\tuint16_t\tentries;\n\tstruct gid_list_info *gid;\n\tuint16_t\tloop_id;\n\tuint8_t\t\tdomain, area, al_pa;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\n\t \n\tif (N2N_TOPO(ha))\n\t\treturn qla2x00_configure_n2n_loop(vha);\n\n\tnew_fcport = NULL;\n\tentries = MAX_FIBRE_DEVICES_LOOP;\n\n\t \n\tmemset(ha->gid_list, 0, qla2x00_gid_list_size(ha));\n\trval = qla2x00_get_id_list(vha, ha->gid_list, ha->gid_list_dma,\n\t    &entries);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto err;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2011,\n\t    \"Entries in ID list (%d).\\n\", entries);\n\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2075,\n\t    ha->gid_list, entries * sizeof(*ha->gid_list));\n\n\tif (entries == 0) {\n\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\tvha->scan.scan_retry++;\n\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\t\tif (vha->scan.scan_retry < MAX_SCAN_RETRIES) {\n\t\t\tu8 loop_map_entries = 0;\n\t\t\tint rc;\n\n\t\t\trc = qla2x00_get_fcal_position_map(vha, NULL,\n\t\t\t\t\t\t&loop_map_entries);\n\t\t\tif (rc == QLA_SUCCESS && loop_map_entries > 1) {\n\t\t\t\t \n\t\t\t\tqla_reinitialize_link(vha);\n\t\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t\t}\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t}\n\t} else {\n\t\tvha->scan.scan_retry = 0;\n\t}\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tfcport->scan_state = QLA_FCPORT_SCAN;\n\t}\n\n\t \n\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (new_fcport == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x2012,\n\t\t    \"Memory allocation failed for fcport.\\n\");\n\t\trval = QLA_MEMORY_ALLOC_FAILED;\n\t\tgoto err;\n\t}\n\tnew_fcport->flags &= ~FCF_FABRIC_DEVICE;\n\n\t \n\tgid = ha->gid_list;\n\tfor (index = 0; index < entries; index++) {\n\t\tdomain = gid->domain;\n\t\tarea = gid->area;\n\t\tal_pa = gid->al_pa;\n\t\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\t\tloop_id = gid->loop_id_2100;\n\t\telse\n\t\t\tloop_id = le16_to_cpu(gid->loop_id);\n\t\tgid = (void *)gid + ha->gid_list_info_size;\n\n\t\t \n\t\tif ((domain & 0xf0) == 0xf0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (area && domain && ((area != vha->d_id.b.area) ||\n\t\t    (domain != vha->d_id.b.domain)) &&\n\t\t    (ha->current_topology == ISP_CFG_NL))\n\t\t\tcontinue;\n\n\n\t\t \n\t\tif (loop_id > LAST_LOCAL_LOOP_ID)\n\t\t\tcontinue;\n\n\t\tmemset(new_fcport->port_name, 0, WWN_SIZE);\n\n\t\t \n\t\tnew_fcport->d_id.b.domain = domain;\n\t\tnew_fcport->d_id.b.area = area;\n\t\tnew_fcport->d_id.b.al_pa = al_pa;\n\t\tnew_fcport->loop_id = loop_id;\n\t\tnew_fcport->scan_state = QLA_FCPORT_FOUND;\n\n\t\trval2 = qla2x00_get_port_database(vha, new_fcport, 0);\n\t\tif (rval2 != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2097,\n\t\t\t    \"Failed to retrieve fcport information \"\n\t\t\t    \"-- get_port_database=%x, loop_id=0x%04x.\\n\",\n\t\t\t    rval2, new_fcport->loop_id);\n\t\t\t \n\t\t\tif (ha->current_topology != ISP_CFG_N) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2105,\n\t\t\t\t    \"Scheduling resync.\\n\");\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t \n\t\tfound = 0;\n\t\tfcport = NULL;\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (memcmp(new_fcport->port_name, fcport->port_name,\n\t\t\t    WWN_SIZE))\n\t\t\t\tcontinue;\n\n\t\t\tfcport->flags &= ~FCF_FABRIC_DEVICE;\n\t\t\tfcport->loop_id = new_fcport->loop_id;\n\t\t\tfcport->port_type = new_fcport->port_type;\n\t\t\tfcport->d_id.b24 = new_fcport->d_id.b24;\n\t\t\tmemcpy(fcport->node_name, new_fcport->node_name,\n\t\t\t    WWN_SIZE);\n\t\t\tfcport->scan_state = QLA_FCPORT_FOUND;\n\t\t\tif (fcport->login_retry == 0) {\n\t\t\t\tfcport->login_retry = vha->hw->login_retry_count;\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2135,\n\t\t\t\t    \"Port login retry %8phN, lid 0x%04x retry cnt=%d.\\n\",\n\t\t\t\t    fcport->port_name, fcport->loop_id,\n\t\t\t\t    fcport->login_retry);\n\t\t\t}\n\t\t\tfound++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!found) {\n\t\t\t \n\t\t\tlist_add_tail(&new_fcport->list, &vha->vp_fcports);\n\n\t\t\t \n\t\t\tfcport = new_fcport;\n\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t\t\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\n\t\t\tif (new_fcport == NULL) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xd031,\n\t\t\t\t    \"Failed to allocate memory for fcport.\\n\");\n\t\t\t\trval = QLA_MEMORY_ALLOC_FAILED;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t\tnew_fcport->flags &= ~FCF_FABRIC_DEVICE;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t\t \n\t\tfcport->fp_speed = ha->link_data_rate;\n\t}\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\tbreak;\n\n\t\tif (fcport->scan_state == QLA_FCPORT_SCAN) {\n\t\t\tif ((qla_dual_mode_enabled(vha) ||\n\t\t\t    qla_ini_mode_enabled(vha)) &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\t\tqla2x00_mark_device_lost(vha, fcport,\n\t\t\t\t\tql2xplogiabsentdevice);\n\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID &&\n\t\t\t\t    (fcport->flags & FCF_FCP2_DEVICE) == 0 &&\n\t\t\t\t    fcport->port_type != FCT_INITIATOR &&\n\t\t\t\t    fcport->port_type != FCT_BROADCAST) {\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20f0,\n\t\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t\t    __func__, __LINE__,\n\t\t\t\t\t    fcport->port_name);\n\n\t\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fcport->scan_state == QLA_FCPORT_FOUND)\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t}\n\n\tqla2x00_free_fcport(new_fcport);\n\n\treturn rval;\n\nerr:\n\tql_dbg(ql_dbg_disc, vha, 0x2098,\n\t       \"Configure local loop error exit: rval=%x.\\n\", rval);\n\treturn rval;\n}\n\nstatic void\nqla2x00_iidma_fcport(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint rval;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_IIDMA_CAPABLE(ha))\n\t\treturn;\n\n\tif (atomic_read(&fcport->state) != FCS_ONLINE)\n\t\treturn;\n\n\tif (fcport->fp_speed == PORT_SPEED_UNKNOWN ||\n\t    fcport->fp_speed > ha->link_data_rate ||\n\t    !ha->flags.gpsc_supported)\n\t\treturn;\n\n\trval = qla2x00_set_idma_speed(vha, fcport->loop_id, fcport->fp_speed,\n\t    mb);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2004,\n\t\t    \"Unable to adjust iIDMA %8phN -- %04x %x %04x %04x.\\n\",\n\t\t    fcport->port_name, rval, fcport->fp_speed, mb[0], mb[1]);\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2005,\n\t\t    \"iIDMA adjusted to %s GB/s (%X) on %8phN.\\n\",\n\t\t    qla2x00_get_link_speed_str(ha, fcport->fp_speed),\n\t\t    fcport->fp_speed, fcport->port_name);\n\t}\n}\n\nvoid qla_do_iidma_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tqla2x00_iidma_fcport(vha, fcport);\n\tqla24xx_update_fcport_fcp_prio(vha, fcport);\n}\n\nint qla_post_iidma_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_IIDMA);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\treturn qla2x00_post_work(vha, e);\n}\n\n \nstatic void\nqla2x00_reg_remote_port(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tstruct fc_rport_identifiers rport_ids;\n\tstruct fc_rport *rport;\n\tunsigned long flags;\n\n\tif (atomic_read(&fcport->state) == FCS_ONLINE)\n\t\treturn;\n\n\trport_ids.node_name = wwn_to_u64(fcport->node_name);\n\trport_ids.port_name = wwn_to_u64(fcport->port_name);\n\trport_ids.port_id = fcport->d_id.b.domain << 16 |\n\t    fcport->d_id.b.area << 8 | fcport->d_id.b.al_pa;\n\trport_ids.roles = FC_RPORT_ROLE_UNKNOWN;\n\tfcport->rport = rport = fc_remote_port_add(vha->host, 0, &rport_ids);\n\tif (!rport) {\n\t\tql_log(ql_log_warn, vha, 0x2006,\n\t\t    \"Unable to allocate fc remote port.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(fcport->vha->host->host_lock, flags);\n\t*((fc_port_t **)rport->dd_data) = fcport;\n\tspin_unlock_irqrestore(fcport->vha->host->host_lock, flags);\n\tfcport->dev_loss_tmo = rport->dev_loss_tmo;\n\n\trport->supported_classes = fcport->supported_classes;\n\n\trport_ids.roles = FC_PORT_ROLE_UNKNOWN;\n\tif (fcport->port_type == FCT_INITIATOR)\n\t\trport_ids.roles |= FC_PORT_ROLE_FCP_INITIATOR;\n\tif (fcport->port_type == FCT_TARGET)\n\t\trport_ids.roles |= FC_PORT_ROLE_FCP_TARGET;\n\tif (fcport->port_type & FCT_NVME_INITIATOR)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_INITIATOR;\n\tif (fcport->port_type & FCT_NVME_TARGET)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_TARGET;\n\tif (fcport->port_type & FCT_NVME_DISCOVERY)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_DISCOVERY;\n\n\tfc_remote_port_rolechg(rport, rport_ids.roles);\n\n\tql_dbg(ql_dbg_disc, vha, 0x20ee,\n\t    \"%s: %8phN. rport %ld:0:%d (%p) is %s mode\\n\",\n\t    __func__, fcport->port_name, vha->host_no,\n\t    rport->scsi_target_id, rport,\n\t    (fcport->port_type == FCT_TARGET) ? \"tgt\" :\n\t    ((fcport->port_type & FCT_NVME) ? \"nvme\" : \"ini\"));\n}\n\n \nvoid\nqla2x00_update_fcport(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tunsigned long flags;\n\n\tif (IS_SW_RESV_ADDR(fcport->d_id))\n\t\treturn;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20ef, \"%s %8phC\\n\",\n\t    __func__, fcport->port_name);\n\n\tqla2x00_set_fcport_disc_state(fcport, DSC_UPD_FCPORT);\n\tfcport->login_retry = vha->hw->login_retry_count;\n\tfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tfcport->deleted = 0;\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\tif (vha->hw->current_topology == ISP_CFG_NL)\n\t\tfcport->logout_on_delete = 0;\n\telse\n\t\tfcport->logout_on_delete = 1;\n\tfcport->n2n_chip_reset = fcport->n2n_link_reset_cnt = 0;\n\n\tif (fcport->tgt_link_down_time < fcport->dev_loss_tmo) {\n\t\tfcport->tgt_short_link_down_cnt++;\n\t\tfcport->tgt_link_down_time = QLA2XX_MAX_LINK_DOWN_TIME;\n\t}\n\n\tswitch (vha->hw->current_topology) {\n\tcase ISP_CFG_N:\n\tcase ISP_CFG_NL:\n\t\tfcport->keep_nport_handle = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tqla2x00_iidma_fcport(vha, fcport);\n\n\tqla2x00_dfs_create_rport(vha, fcport);\n\n\tqla24xx_update_fcport_fcp_prio(vha, fcport);\n\n\tswitch (vha->host->active_mode) {\n\tcase MODE_INITIATOR:\n\t\tqla2x00_reg_remote_port(vha, fcport);\n\t\tbreak;\n\tcase MODE_TARGET:\n\t\tif (!vha->vha_tgt.qla_tgt->tgt_stop &&\n\t\t\t!vha->vha_tgt.qla_tgt->tgt_stopped)\n\t\t\tqlt_fc_port_added(vha, fcport);\n\t\tbreak;\n\tcase MODE_DUAL:\n\t\tqla2x00_reg_remote_port(vha, fcport);\n\t\tif (!vha->vha_tgt.qla_tgt->tgt_stop &&\n\t\t\t!vha->vha_tgt.qla_tgt->tgt_stopped)\n\t\t\tqlt_fc_port_added(vha, fcport);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (NVME_TARGET(vha->hw, fcport))\n\t\tqla_nvme_register_remote(vha, fcport);\n\n\tqla2x00_set_fcport_state(fcport, FCS_ONLINE);\n\n\tif (IS_IIDMA_CAPABLE(vha->hw) && vha->hw->flags.gpsc_supported) {\n\t\tif (fcport->id_changed) {\n\t\t\tfcport->id_changed = 0;\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20d7,\n\t\t\t    \"%s %d %8phC post gfpnid fcp_cnt %d\\n\",\n\t\t\t    __func__, __LINE__, fcport->port_name,\n\t\t\t    vha->fcport_count);\n\t\t\tqla24xx_post_gfpnid_work(vha, fcport);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20d7,\n\t\t\t    \"%s %d %8phC post gpsc fcp_cnt %d\\n\",\n\t\t\t    __func__, __LINE__, fcport->port_name,\n\t\t\t    vha->fcport_count);\n\t\t\tqla24xx_post_gpsc_work(vha, fcport);\n\t\t}\n\t}\n\n\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_COMPLETE);\n}\n\nvoid qla_register_fcport_fn(struct work_struct *work)\n{\n\tfc_port_t *fcport = container_of(work, struct fc_port, reg_work);\n\tu32 rscn_gen = fcport->rscn_gen;\n\tu16 data[2];\n\n\tif (IS_SW_RESV_ADDR(fcport->d_id))\n\t\treturn;\n\n\tqla2x00_update_fcport(fcport->vha, fcport);\n\n\tql_dbg(ql_dbg_disc, fcport->vha, 0x911e,\n\t       \"%s rscn gen %d/%d next DS %d\\n\", __func__,\n\t       rscn_gen, fcport->rscn_gen, fcport->next_disc_state);\n\n\tif (rscn_gen != fcport->rscn_gen) {\n\t\t \n\t\tswitch (fcport->next_disc_state) {\n\t\tcase DSC_DELETE_PEND:\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\tbreak;\n\t\tcase DSC_ADISC:\n\t\t\tdata[0] = data[1] = 0;\n\t\t\tqla2x00_post_async_adisc_work(fcport->vha, fcport,\n\t\t\t    data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int\nqla2x00_configure_fabric(scsi_qla_host_t *vha)\n{\n\tint\trval;\n\tfc_port_t\t*fcport;\n\tuint16_t\tmb[MAILBOX_REGISTER_COUNT];\n\tuint16_t\tloop_id;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint\t\tdiscovery_gen;\n\n\t \n\tif (IS_FWI2_CAPABLE(ha))\n\t\tloop_id = NPH_F_PORT;\n\telse\n\t\tloop_id = SNS_FL_PORT;\n\trval = qla2x00_get_port_name(vha, loop_id, vha->fabric_node_name, 1);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20a0,\n\t\t    \"MBX_GET_PORT_NAME failed, No FL Port.\\n\");\n\n\t\tvha->device_flags &= ~SWITCH_FOUND;\n\t\treturn (QLA_SUCCESS);\n\t}\n\tvha->device_flags |= SWITCH_FOUND;\n\n\trval = qla2x00_get_port_name(vha, loop_id, vha->fabric_port_name, 0);\n\tif (rval != QLA_SUCCESS)\n\t\tql_dbg(ql_dbg_disc, vha, 0x20ff,\n\t\t    \"Failed to get Fabric Port Name\\n\");\n\n\tif (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {\n\t\trval = qla2x00_send_change_request(vha, 0x3, 0);\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tql_log(ql_log_warn, vha, 0x121,\n\t\t\t    \"Failed to enable receiving of RSCN requests: 0x%x.\\n\",\n\t\t\t    rval);\n\t}\n\n\tdo {\n\t\tqla2x00_mgmt_svr_login(vha);\n\n\t\t \n\t\tloop_id = NPH_SNS_LID(ha);\n\t\trval = ha->isp_ops->fabric_login(vha, loop_id, 0xff, 0xff,\n\t\t    0xfc, mb, BIT_1|BIT_0);\n\t\tif (rval != QLA_SUCCESS || mb[0] != MBS_COMMAND_COMPLETE) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20a1,\n\t\t\t    \"Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x (%x).\\n\",\n\t\t\t    loop_id, mb[0], mb[1], mb[2], mb[6], mb[7], rval);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\treturn rval;\n\t\t}\n\n\t\t \n\t\tif (ql2xfdmienable &&\n\t\t    test_and_clear_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags))\n\t\t\tqla2x00_fdmi_register(vha);\n\n\t\tif (test_and_clear_bit(REGISTER_FC4_NEEDED, &vha->dpc_flags)) {\n\t\t\tif (qla2x00_rft_id(vha)) {\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20a2,\n\t\t\t\t    \"Register FC-4 TYPE failed.\\n\");\n\t\t\t\tif (test_bit(LOOP_RESYNC_NEEDED,\n\t\t\t\t    &vha->dpc_flags))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (qla2x00_rff_id(vha, FC4_TYPE_FCP_SCSI)) {\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x209a,\n\t\t\t\t    \"Register FC-4 Features failed.\\n\");\n\t\t\t\tif (test_bit(LOOP_RESYNC_NEEDED,\n\t\t\t\t    &vha->dpc_flags))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (vha->flags.nvme_enabled) {\n\t\t\t\tif (qla2x00_rff_id(vha, FC_TYPE_NVME)) {\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2049,\n\t\t\t\t\t    \"Register NVME FC Type Features failed.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (qla2x00_rnn_id(vha)) {\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2104,\n\t\t\t\t    \"Register Node Name failed.\\n\");\n\t\t\t\tif (test_bit(LOOP_RESYNC_NEEDED,\n\t\t\t\t    &vha->dpc_flags))\n\t\t\t\t\tbreak;\n\t\t\t} else if (qla2x00_rsnn_nn(vha)) {\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x209b,\n\t\t\t\t    \"Register Symbolic Node Name failed.\\n\");\n\t\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\t \n\t\tqlt_do_generation_tick(vha, &discovery_gen);\n\n\t\tif (USE_ASYNC_SCAN(ha)) {\n\t\t\trval = qla24xx_async_gpnft(vha, FC4_TYPE_FCP_SCSI,\n\t\t\t    NULL);\n\t\t\tif (rval)\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t} else  {\n\t\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list)\n\t\t\t\tfcport->scan_state = QLA_FCPORT_SCAN;\n\n\t\t\trval = qla2x00_find_all_fabric_devs(vha);\n\t\t}\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tbreak;\n\t} while (0);\n\n\tif (!vha->nvme_local_port && vha->flags.nvme_enabled)\n\t\tqla_nvme_register_hba(vha);\n\n\tif (rval)\n\t\tql_dbg(ql_dbg_disc, vha, 0x2068,\n\t\t    \"Configure fabric error exit rval=%d.\\n\", rval);\n\n\treturn (rval);\n}\n\n \nstatic int\nqla2x00_find_all_fabric_devs(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tuint16_t\tloop_id;\n\tfc_port_t\t*fcport, *new_fcport;\n\tint\t\tfound;\n\n\tsw_info_t\t*swl;\n\tint\t\tswl_idx;\n\tint\t\tfirst_dev, last_dev;\n\tport_id_t\twrap = {}, nxt_d_id;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tunsigned long flags;\n\n\trval = QLA_SUCCESS;\n\n\t \n\tif (!ha->swl)\n\t\tha->swl = kcalloc(ha->max_fibre_devices, sizeof(sw_info_t),\n\t\t    GFP_KERNEL);\n\tswl = ha->swl;\n\tif (!swl) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x209c,\n\t\t    \"GID_PT allocations failed, fallback on GA_NXT.\\n\");\n\t} else {\n\t\tmemset(swl, 0, ha->max_fibre_devices * sizeof(sw_info_t));\n\t\tif (qla2x00_gid_pt(vha, swl) != QLA_SUCCESS) {\n\t\t\tswl = NULL;\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t} else if (qla2x00_gpn_id(vha, swl) != QLA_SUCCESS) {\n\t\t\tswl = NULL;\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t} else if (qla2x00_gnn_id(vha, swl) != QLA_SUCCESS) {\n\t\t\tswl = NULL;\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t} else if (qla2x00_gfpn_id(vha, swl) != QLA_SUCCESS) {\n\t\t\tswl = NULL;\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t}\n\n\t\t \n\t\tif (swl) {\n\t\t\tqla2x00_gff_id(vha, swl);\n\t\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\t\treturn rval;\n\t\t}\n\t}\n\tswl_idx = 0;\n\n\t \n\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (new_fcport == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x209d,\n\t\t    \"Failed to allocate memory for fcport.\\n\");\n\t\treturn (QLA_MEMORY_ALLOC_FAILED);\n\t}\n\tnew_fcport->flags |= (FCF_FABRIC_DEVICE | FCF_LOGIN_NEEDED);\n\t \n\tfirst_dev = 1;\n\tlast_dev = 0;\n\n\t \n\tloop_id = ha->min_external_loopid;\n\tfor (; loop_id <= ha->max_loop_id; loop_id++) {\n\t\tif (qla2x00_is_reserved_id(vha, loop_id))\n\t\t\tcontinue;\n\n\t\tif (ha->current_topology == ISP_CFG_FL &&\n\t\t    (atomic_read(&vha->loop_down_timer) ||\n\t\t     LOOP_TRANSITION(vha))) {\n\t\t\tatomic_set(&vha->loop_down_timer, 0);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (swl != NULL) {\n\t\t\tif (last_dev) {\n\t\t\t\twrap.b24 = new_fcport->d_id.b24;\n\t\t\t} else {\n\t\t\t\tnew_fcport->d_id.b24 = swl[swl_idx].d_id.b24;\n\t\t\t\tmemcpy(new_fcport->node_name,\n\t\t\t\t    swl[swl_idx].node_name, WWN_SIZE);\n\t\t\t\tmemcpy(new_fcport->port_name,\n\t\t\t\t    swl[swl_idx].port_name, WWN_SIZE);\n\t\t\t\tmemcpy(new_fcport->fabric_port_name,\n\t\t\t\t    swl[swl_idx].fabric_port_name, WWN_SIZE);\n\t\t\t\tnew_fcport->fp_speed = swl[swl_idx].fp_speed;\n\t\t\t\tnew_fcport->fc4_type = swl[swl_idx].fc4_type;\n\n\t\t\t\tnew_fcport->nvme_flag = 0;\n\t\t\t\tif (vha->flags.nvme_enabled &&\n\t\t\t\t    swl[swl_idx].fc4_type & FS_FC4TYPE_NVME) {\n\t\t\t\t\tql_log(ql_log_info, vha, 0x2131,\n\t\t\t\t\t    \"FOUND: NVME port %8phC as FC Type 28h\\n\",\n\t\t\t\t\t    new_fcport->port_name);\n\t\t\t\t}\n\n\t\t\t\tif (swl[swl_idx].d_id.b.rsvd_1 != 0) {\n\t\t\t\t\tlast_dev = 1;\n\t\t\t\t}\n\t\t\t\tswl_idx++;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trval = qla2x00_ga_nxt(vha, new_fcport);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x209e,\n\t\t\t\t    \"SNS scan failed -- assuming \"\n\t\t\t\t    \"zero-entry result.\\n\");\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (first_dev) {\n\t\t\twrap.b24 = new_fcport->d_id.b24;\n\t\t\tfirst_dev = 0;\n\t\t} else if (new_fcport->d_id.b24 == wrap.b24) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x209f,\n\t\t\t    \"Device wrap (%02x%02x%02x).\\n\",\n\t\t\t    new_fcport->d_id.b.domain,\n\t\t\t    new_fcport->d_id.b.area,\n\t\t\t    new_fcport->d_id.b.al_pa);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (new_fcport->d_id.b24 == base_vha->d_id.b24)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (qla2x00_is_a_vp_did(vha, new_fcport->d_id.b24))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (((new_fcport->d_id.b24 & 0xffff00) ==\n\t\t    (vha->d_id.b24 & 0xffff00)) && ha->current_topology ==\n\t\t\tISP_CFG_FL)\n\t\t\t    continue;\n\n\t\t \n\t\tif ((new_fcport->d_id.b.domain & 0xf0) == 0xf0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ql2xgffidenable &&\n\t\t    (!(new_fcport->fc4_type & FS_FC4TYPE_FCP) &&\n\t\t    new_fcport->fc4_type != 0))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\n\t\t \n\t\tfound = 0;\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (memcmp(new_fcport->port_name, fcport->port_name,\n\t\t\t    WWN_SIZE))\n\t\t\t\tcontinue;\n\n\t\t\tfcport->scan_state = QLA_FCPORT_FOUND;\n\n\t\t\tfound++;\n\n\t\t\t \n\t\t\tmemcpy(fcport->fabric_port_name,\n\t\t\t    new_fcport->fabric_port_name, WWN_SIZE);\n\t\t\tfcport->fp_speed = new_fcport->fp_speed;\n\n\t\t\t \n\t\t\tif (fcport->d_id.b24 == new_fcport->d_id.b24 &&\n\t\t\t    (atomic_read(&fcport->state) == FCS_ONLINE ||\n\t\t\t     (vha->host->active_mode == MODE_TARGET))) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (fcport->login_retry == 0)\n\t\t\t\tfcport->login_retry =\n\t\t\t\t\tvha->hw->login_retry_count;\n\t\t\t \n\t\t\tif ((fcport->flags & FCF_FABRIC_DEVICE) == 0) {\n\t\t\t\tfcport->d_id.b24 = new_fcport->d_id.b24;\n\t\t\t\tqla2x00_clear_loop_id(fcport);\n\t\t\t\tfcport->flags |= (FCF_FABRIC_DEVICE |\n\t\t\t\t    FCF_LOGIN_NEEDED);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (qla_tgt_mode_enabled(base_vha)) {\n\t\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf080,\n\t\t\t\t\t \"port changed FC ID, %8phC\"\n\t\t\t\t\t \" old %x:%x:%x (loop_id 0x%04x)-> new %x:%x:%x\\n\",\n\t\t\t\t\t fcport->port_name,\n\t\t\t\t\t fcport->d_id.b.domain,\n\t\t\t\t\t fcport->d_id.b.area,\n\t\t\t\t\t fcport->d_id.b.al_pa,\n\t\t\t\t\t fcport->loop_id,\n\t\t\t\t\t new_fcport->d_id.b.domain,\n\t\t\t\t\t new_fcport->d_id.b.area,\n\t\t\t\t\t new_fcport->d_id.b.al_pa);\n\t\t\t\tfcport->d_id.b24 = new_fcport->d_id.b24;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfcport->d_id.b24 = new_fcport->d_id.b24;\n\t\t\tfcport->flags |= FCF_LOGIN_NEEDED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found && NVME_TARGET(vha->hw, fcport)) {\n\t\t\tif (fcport->disc_state == DSC_DELETE_PEND) {\n\t\t\t\tqla2x00_set_fcport_disc_state(fcport, DSC_GNL);\n\t\t\t\tvha->fcport_count--;\n\t\t\t\tfcport->login_succ = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (found) {\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tnew_fcport->scan_state = QLA_FCPORT_FOUND;\n\t\tlist_add_tail(&new_fcport->list, &vha->vp_fcports);\n\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\n\t\t \n\t\tnxt_d_id.b24 = new_fcport->d_id.b24;\n\t\tnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\t\tif (new_fcport == NULL) {\n\t\t\tql_log(ql_log_warn, vha, 0xd032,\n\t\t\t    \"Memory allocation failed for fcport.\\n\");\n\t\t\treturn (QLA_MEMORY_ALLOC_FAILED);\n\t\t}\n\t\tnew_fcport->flags |= (FCF_FABRIC_DEVICE | FCF_LOGIN_NEEDED);\n\t\tnew_fcport->d_id.b24 = nxt_d_id.b24;\n\t}\n\n\tqla2x00_free_fcport(new_fcport);\n\n\t \n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\tbreak;\n\n\t\tif ((fcport->flags & FCF_FABRIC_DEVICE) == 0)\n\t\t\tcontinue;\n\n\t\tif (fcport->scan_state == QLA_FCPORT_SCAN) {\n\t\t\tif ((qla_dual_mode_enabled(vha) ||\n\t\t\t    qla_ini_mode_enabled(vha)) &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\t\t\tqla2x00_mark_device_lost(vha, fcport,\n\t\t\t\t\tql2xplogiabsentdevice);\n\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID &&\n\t\t\t\t    (fcport->flags & FCF_FCP2_DEVICE) == 0 &&\n\t\t\t\t    fcport->port_type != FCT_INITIATOR &&\n\t\t\t\t    fcport->port_type != FCT_BROADCAST) {\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20f0,\n\t\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t\t    __func__, __LINE__,\n\t\t\t\t\t    fcport->port_name);\n\t\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fcport->scan_state == QLA_FCPORT_FOUND &&\n\t\t    (fcport->flags & FCF_LOGIN_NEEDED) != 0)\n\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t}\n\treturn (rval);\n}\n\n \nint\nqla2x00_reserve_mgmt_server_loop_id(scsi_qla_host_t *vha)\n{\n\tint loop_id = FC_NO_LOOP_ID;\n\tint lid = NPH_MGMT_SERVER - vha->vp_idx;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (vha->vp_idx == 0) {\n\t\tset_bit(NPH_MGMT_SERVER, ha->loop_id_map);\n\t\treturn NPH_MGMT_SERVER;\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tfor (; lid > 0; lid--) {\n\t\tif (!test_bit(lid, vha->hw->loop_id_map)) {\n\t\t\tset_bit(lid, vha->hw->loop_id_map);\n\t\t\tloop_id = lid;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\treturn loop_id;\n}\n\n \nint\nqla2x00_fabric_login(scsi_qla_host_t *vha, fc_port_t *fcport,\n    uint16_t *next_loopid)\n{\n\tint\trval;\n\tint\tretry;\n\tuint16_t tmp_loopid;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tretry = 0;\n\ttmp_loopid = 0;\n\n\tfor (;;) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2000,\n\t\t    \"Trying Fabric Login w/loop id 0x%04x for port \"\n\t\t    \"%02x%02x%02x.\\n\",\n\t\t    fcport->loop_id, fcport->d_id.b.domain,\n\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\t\t \n\t\trval = ha->isp_ops->fabric_login(vha, fcport->loop_id,\n\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t    fcport->d_id.b.al_pa, mb, BIT_0);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\treturn rval;\n\t\t}\n\t\tif (mb[0] == MBS_PORT_ID_USED) {\n\t\t\t \n\t\t\tretry++;\n\t\t\ttmp_loopid = fcport->loop_id;\n\t\t\tfcport->loop_id = mb[1];\n\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2001,\n\t\t\t    \"Fabric Login: port in use - next loop \"\n\t\t\t    \"id=0x%04x, port id= %02x%02x%02x.\\n\",\n\t\t\t    fcport->loop_id, fcport->d_id.b.domain,\n\t\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\t\t} else if (mb[0] == MBS_COMMAND_COMPLETE) {\n\t\t\t \n\t\t\tif (retry) {\n\t\t\t\t \n\t\t\t\t*next_loopid = tmp_loopid;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t*next_loopid = (fcport->loop_id + 1);\n\t\t\t}\n\n\t\t\tif (mb[1] & BIT_0) {\n\t\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\t\t} else {\n\t\t\t\tfcport->port_type = FCT_TARGET;\n\t\t\t\tif (mb[1] & BIT_1) {\n\t\t\t\t\tfcport->flags |= FCF_FCP2_DEVICE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mb[10] & BIT_0)\n\t\t\t\tfcport->supported_classes |= FC_COS_CLASS2;\n\t\t\tif (mb[10] & BIT_1)\n\t\t\t\tfcport->supported_classes |= FC_COS_CLASS3;\n\n\t\t\tif (IS_FWI2_CAPABLE(ha)) {\n\t\t\t\tif (mb[10] & BIT_7)\n\t\t\t\t\tfcport->flags |=\n\t\t\t\t\t    FCF_CONF_COMP_SUPPORTED;\n\t\t\t}\n\n\t\t\trval = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t} else if (mb[0] == MBS_LOOP_ID_USED) {\n\t\t\t \n\t\t\tfcport->loop_id++;\n\t\t\trval = qla2x00_find_new_loop_id(vha, fcport);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (mb[0] == MBS_COMMAND_ERROR) {\n\t\t\t \n\t\t\t*next_loopid = fcport->loop_id;\n\t\t\tha->isp_ops->fabric_logout(vha, fcport->loop_id,\n\t\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t\t    fcport->d_id.b.al_pa);\n\t\t\tqla2x00_mark_device_lost(vha, fcport, 1);\n\n\t\t\trval = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2002,\n\t\t\t    \"Failed=%x port_id=%02x%02x%02x loop_id=%x \"\n\t\t\t    \"jiffies=%lx.\\n\", mb[0], fcport->d_id.b.domain,\n\t\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa,\n\t\t\t    fcport->loop_id, jiffies);\n\n\t\t\t*next_loopid = fcport->loop_id;\n\t\t\tha->isp_ops->fabric_logout(vha, fcport->loop_id,\n\t\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t\t    fcport->d_id.b.al_pa);\n\t\t\tqla2x00_clear_loop_id(fcport);\n\t\t\tfcport->login_retry = 0;\n\n\t\t\trval = 3;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (rval);\n}\n\n \nint\nqla2x00_local_device_login(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint\t\trval;\n\tuint16_t\tmb[MAILBOX_REGISTER_COUNT];\n\n\tmemset(mb, 0, sizeof(mb));\n\trval = qla2x00_login_local_device(vha, fcport, mb, BIT_0);\n\tif (rval == QLA_SUCCESS) {\n\t\t \n\t\tif (mb[0] == MBS_COMMAND_ERROR)\n\t\t\trval = 1;\n\t\telse if (mb[0] == MBS_COMMAND_PARAMETER_ERROR)\n\t\t\t \n\t\t\trval = 3;\n\t}\n\n\treturn (rval);\n}\n\n \nint\nqla2x00_loop_resync(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tuint32_t wait_time;\n\n\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\tif (vha->flags.online) {\n\t\tif (!(rval = qla2x00_fw_ready(vha))) {\n\t\t\t \n\t\t\twait_time = 256;\n\t\t\tdo {\n\t\t\t\tif (!IS_QLAFX00(vha->hw)) {\n\t\t\t\t\t \n\t\t\t\t\tqla2x00_marker(vha, vha->hw->base_qpair,\n\t\t\t\t\t    0, 0, MK_SYNC_ALL);\n\t\t\t\t\tvha->marker_needed = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tclear_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\n\t\t\t\tif (IS_QLAFX00(vha->hw))\n\t\t\t\t\tqlafx00_configure_devices(vha);\n\t\t\t\telse\n\t\t\t\t\tqla2x00_configure_loop(vha);\n\n\t\t\t\twait_time--;\n\t\t\t} while (!atomic_read(&vha->loop_down_timer) &&\n\t\t\t\t!(test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags))\n\t\t\t\t&& wait_time && (test_bit(LOOP_RESYNC_NEEDED,\n\t\t\t\t&vha->dpc_flags)));\n\t\t}\n\t}\n\n\tif (test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags))\n\t\treturn (QLA_FUNCTION_FAILED);\n\n\tif (rval)\n\t\tql_dbg(ql_dbg_disc, vha, 0x206c,\n\t\t    \"%s *** FAILED ***.\\n\", __func__);\n\n\treturn (rval);\n}\n\n \n\nint qla2x00_perform_loop_resync(scsi_qla_host_t *ha)\n{\n\tint32_t rval = 0;\n\n\tif (!test_and_set_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags)) {\n\t\t \n\t\tatomic_set(&ha->loop_down_timer, 0);\n\t\tif (!(ha->device_flags & DFLG_NO_CABLE)) {\n\t\t\tatomic_set(&ha->loop_state, LOOP_UP);\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &ha->dpc_flags);\n\t\t\tset_bit(REGISTER_FC4_NEEDED, &ha->dpc_flags);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &ha->dpc_flags);\n\n\t\t\trval = qla2x00_loop_resync(ha);\n\t\t} else\n\t\t\tatomic_set(&ha->loop_state, LOOP_DEAD);\n\n\t\tclear_bit(LOOP_RESYNC_ACTIVE, &ha->dpc_flags);\n\t}\n\n\treturn rval;\n}\n\n \nvoid\nqla83xx_reset_ownership(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_presence, drv_presence_mask;\n\tuint32_t dev_part_info1, dev_part_info2, class_type;\n\tuint32_t class_type_mask = 0x3;\n\tuint16_t fcoe_other_function = 0xffff, i;\n\n\tif (IS_QLA8044(ha)) {\n\t\tdrv_presence = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DRV_ACTIVE_INDEX);\n\t\tdev_part_info1 = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DEV_PART_INFO_INDEX);\n\t\tdev_part_info2 = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DEV_PART_INFO2);\n\t} else {\n\t\tqla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\n\t\tqla83xx_rd_reg(vha, QLA83XX_DEV_PARTINFO1, &dev_part_info1);\n\t\tqla83xx_rd_reg(vha, QLA83XX_DEV_PARTINFO2, &dev_part_info2);\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tclass_type = ((dev_part_info1 >> (i * 4)) & class_type_mask);\n\t\tif ((class_type == QLA83XX_CLASS_TYPE_FCOE) &&\n\t\t    (i != ha->portnum)) {\n\t\t\tfcoe_other_function = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (fcoe_other_function == 0xffff) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tclass_type = ((dev_part_info2 >> (i * 4)) &\n\t\t\t    class_type_mask);\n\t\t\tif ((class_type == QLA83XX_CLASS_TYPE_FCOE) &&\n\t\t\t    ((i + 8) != ha->portnum)) {\n\t\t\t\tfcoe_other_function = i + 8;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tdrv_presence_mask = ~((1 << (ha->portnum)) |\n\t\t\t((fcoe_other_function == 0xffff) ?\n\t\t\t 0 : (1 << (fcoe_other_function))));\n\n\t \n\tif (!(drv_presence & drv_presence_mask) &&\n\t\t\t(ha->portnum < fcoe_other_function)) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb07f,\n\t\t    \"This host is Reset owner.\\n\");\n\t\tha->flags.nic_core_reset_owner = 1;\n\t}\n}\n\nstatic int\n__qla83xx_set_drv_ack(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_ack;\n\n\trval = qla83xx_rd_reg(vha, QLA83XX_IDC_DRIVER_ACK, &drv_ack);\n\tif (rval == QLA_SUCCESS) {\n\t\tdrv_ack |= (1 << ha->portnum);\n\t\trval = qla83xx_wr_reg(vha, QLA83XX_IDC_DRIVER_ACK, drv_ack);\n\t}\n\n\treturn rval;\n}\n\nstatic int\n__qla83xx_clear_drv_ack(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_ack;\n\n\trval = qla83xx_rd_reg(vha, QLA83XX_IDC_DRIVER_ACK, &drv_ack);\n\tif (rval == QLA_SUCCESS) {\n\t\tdrv_ack &= ~(1 << ha->portnum);\n\t\trval = qla83xx_wr_reg(vha, QLA83XX_IDC_DRIVER_ACK, drv_ack);\n\t}\n\n\treturn rval;\n}\n\n \nvoid\nqla83xx_idc_audit(scsi_qla_host_t *vha, int audit_type)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t idc_audit_reg = 0, duration_secs = 0;\n\n\tswitch (audit_type) {\n\tcase IDC_AUDIT_TIMESTAMP:\n\t\tha->idc_audit_ts = (jiffies_to_msecs(jiffies) / 1000);\n\t\tidc_audit_reg = (ha->portnum) |\n\t\t    (IDC_AUDIT_TIMESTAMP << 7) | (ha->idc_audit_ts << 8);\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_AUDIT, idc_audit_reg);\n\t\tbreak;\n\n\tcase IDC_AUDIT_COMPLETION:\n\t\tduration_secs = ((jiffies_to_msecs(jiffies) -\n\t\t    jiffies_to_msecs(ha->idc_audit_ts)) / 1000);\n\t\tidc_audit_reg = (ha->portnum) |\n\t\t    (IDC_AUDIT_COMPLETION << 7) | (duration_secs << 8);\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_AUDIT, idc_audit_reg);\n\t\tbreak;\n\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0xb078,\n\t\t    \"Invalid audit type specified.\\n\");\n\t\tbreak;\n\t}\n}\n\n \nstatic int\nqla83xx_initiating_reset(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t  idc_control, dev_state;\n\n\t__qla83xx_get_idc_control(vha, &idc_control);\n\tif ((idc_control & QLA83XX_IDC_RESET_DISABLED)) {\n\t\tql_log(ql_log_info, vha, 0xb080,\n\t\t    \"NIC Core reset has been disabled. idc-control=0x%x\\n\",\n\t\t    idc_control);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\t \n\tqla83xx_rd_reg(vha, QLA83XX_IDC_DEV_STATE, &dev_state);\n\tif (ha->flags.nic_core_reset_owner && dev_state == QLA8XXX_DEV_READY) {\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE,\n\t\t    QLA8XXX_DEV_NEED_RESET);\n\t\tql_log(ql_log_info, vha, 0xb056, \"HW State: NEED RESET.\\n\");\n\t\tqla83xx_idc_audit(vha, IDC_AUDIT_TIMESTAMP);\n\t} else {\n\t\tql_log(ql_log_info, vha, 0xb057, \"HW State: %s.\\n\",\n\t\t\t\tqdev_state(dev_state));\n\n\t\t \n\t\t \n\t\twhile (dev_state == QLA8XXX_DEV_READY) {\n\t\t\tqla83xx_idc_unlock(vha, 0);\n\t\t\tmsleep(200);\n\t\t\tqla83xx_idc_lock(vha, 0);\n\t\t\tqla83xx_rd_reg(vha, QLA83XX_IDC_DEV_STATE, &dev_state);\n\t\t}\n\t}\n\n\t \n\t__qla83xx_set_drv_ack(vha);\n\n\treturn QLA_SUCCESS;\n}\n\nint\n__qla83xx_set_idc_control(scsi_qla_host_t *vha, uint32_t idc_control)\n{\n\treturn qla83xx_wr_reg(vha, QLA83XX_IDC_CONTROL, idc_control);\n}\n\nint\n__qla83xx_get_idc_control(scsi_qla_host_t *vha, uint32_t *idc_control)\n{\n\treturn qla83xx_rd_reg(vha, QLA83XX_IDC_CONTROL, idc_control);\n}\n\nstatic int\nqla83xx_check_driver_presence(scsi_qla_host_t *vha)\n{\n\tuint32_t drv_presence = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\n\tif (drv_presence & (1 << ha->portnum))\n\t\treturn QLA_SUCCESS;\n\telse\n\t\treturn QLA_TEST_FAILED;\n}\n\nint\nqla83xx_nic_core_reset(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb058,\n\t    \"Entered  %s().\\n\", __func__);\n\n\tif (vha->device_flags & DFLG_DEV_FAILED) {\n\t\tql_log(ql_log_warn, vha, 0xb059,\n\t\t    \"Device in unrecoverable FAILED state.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tqla83xx_idc_lock(vha, 0);\n\n\tif (qla83xx_check_driver_presence(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0xb05a,\n\t\t    \"Function=0x%x has been removed from IDC participation.\\n\",\n\t\t    ha->portnum);\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto exit;\n\t}\n\n\tqla83xx_reset_ownership(vha);\n\n\trval = qla83xx_initiating_reset(vha);\n\n\t \n\tif (rval == QLA_SUCCESS) {\n\t\trval = qla83xx_idc_state_handler(vha);\n\n\t\tif (rval == QLA_SUCCESS)\n\t\t\tha->flags.nic_core_hung = 0;\n\t\t__qla83xx_clear_drv_ack(vha);\n\t}\n\nexit:\n\tqla83xx_idc_unlock(vha, 0);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb05b, \"Exiting %s.\\n\", __func__);\n\n\treturn rval;\n}\n\nint\nqla2xxx_mctp_dump(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (!IS_MCTP_CAPABLE(ha)) {\n\t\t \n\t\tql_log(ql_log_info, vha, 0x506d,\n\t\t    \"This board is not MCTP capable\\n\");\n\t\treturn rval;\n\t}\n\n\tif (!ha->mctp_dump) {\n\t\tha->mctp_dump = dma_alloc_coherent(&ha->pdev->dev,\n\t\t    MCTP_DUMP_SIZE, &ha->mctp_dump_dma, GFP_KERNEL);\n\n\t\tif (!ha->mctp_dump) {\n\t\t\tql_log(ql_log_warn, vha, 0x506e,\n\t\t\t    \"Failed to allocate memory for mctp dump\\n\");\n\t\t\treturn rval;\n\t\t}\n\t}\n\n#define MCTP_DUMP_STR_ADDR\t0x00000000\n\trval = qla2x00_dump_mctp_data(vha, ha->mctp_dump_dma,\n\t    MCTP_DUMP_STR_ADDR, MCTP_DUMP_SIZE/4);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x506f,\n\t\t    \"Failed to capture mctp dump\\n\");\n\t} else {\n\t\tql_log(ql_log_info, vha, 0x5070,\n\t\t    \"Mctp dump capture for host (%ld/%p).\\n\",\n\t\t    vha->host_no, ha->mctp_dump);\n\t\tha->mctp_dumped = 1;\n\t}\n\n\tif (!ha->flags.nic_core_reset_hdlr_active && !ha->portnum) {\n\t\tha->flags.nic_core_reset_hdlr_active = 1;\n\t\trval = qla83xx_restart_nic_firmware(vha);\n\t\tif (rval)\n\t\t\t \n\t\t\tql_log(ql_log_warn, vha, 0x5071,\n\t\t\t    \"Failed to restart nic firmware\\n\");\n\t\telse\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb084,\n\t\t\t    \"Restarted NIC firmware successfully.\\n\");\n\t\tha->flags.nic_core_reset_hdlr_active = 0;\n\t}\n\n\treturn rval;\n\n}\n\n \nvoid\nqla2x00_quiesce_io(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *vp, *tvp;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_dpc, vha, 0x401d,\n\t    \"Quiescing I/O - ha=%p.\\n\", ha);\n\n\tatomic_set(&ha->loop_down_timer, LOOP_DOWN_TIME);\n\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\tqla2x00_mark_all_devices_lost(vha);\n\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tlist_for_each_entry_safe(vp, tvp, &ha->vp_list, list) {\n\t\t\tatomic_inc(&vp->vref_count);\n\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\t\tqla2x00_mark_all_devices_lost(vp);\n\n\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\tatomic_dec(&vp->vref_count);\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\t} else {\n\t\tif (!atomic_read(&vha->loop_down_timer))\n\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t\t\tLOOP_DOWN_TIME);\n\t}\n\t \n\tWARN_ON_ONCE(qla2x00_eh_wait_for_pending_commands(vha, 0, 0, WAIT_HOST)\n\t\t     != QLA_SUCCESS);\n}\n\nvoid\nqla2x00_abort_isp_cleanup(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *vp, *tvp;\n\tunsigned long flags;\n\tfc_port_t *fcport;\n\tu16 i;\n\n\t \n\tif (!(IS_P3P_TYPE(ha)))\n\t\tvha->flags.online = 0;\n\tha->flags.chip_reset_done = 0;\n\tclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\tvha->qla_stats.total_isp_aborts++;\n\n\tql_log(ql_log_info, vha, 0x00af,\n\t    \"Performing ISP error recovery - ha=%p.\\n\", ha);\n\n\tha->flags.purge_mbox = 1;\n\t \n\tif (!(IS_P3P_TYPE(ha)))\n\t\tha->isp_ops->reset_chip(vha);\n\n\tha->link_data_rate = PORT_SPEED_UNKNOWN;\n\tSAVE_TOPO(ha);\n\tha->flags.rida_fmt2 = 0;\n\tha->flags.n2n_ae = 0;\n\tha->flags.lip_ae = 0;\n\tha->current_topology = 0;\n\tQLA_FW_STOPPED(ha);\n\tha->flags.fw_init_done = 0;\n\tha->chip_reset++;\n\tha->base_qpair->chip_reset = ha->chip_reset;\n\tha->base_qpair->cmd_cnt = ha->base_qpair->cmd_completion_cnt = 0;\n\tha->base_qpair->prev_completion_cnt = 0;\n\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\tif (ha->queue_pair_map[i]) {\n\t\t\tha->queue_pair_map[i]->chip_reset =\n\t\t\t\tha->base_qpair->chip_reset;\n\t\t\tha->queue_pair_map[i]->cmd_cnt =\n\t\t\t    ha->queue_pair_map[i]->cmd_completion_cnt = 0;\n\t\t\tha->base_qpair->prev_completion_cnt = 0;\n\t\t}\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tif (test_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags)) {\n\t\tclear_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\n\t\tcomplete(&ha->mbx_intr_comp);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\ti = 0;\n\twhile (atomic_read(&ha->num_pend_mbx_stage2) ||\n\t    atomic_read(&ha->num_pend_mbx_stage1)) {\n\t\tmsleep(20);\n\t\ti++;\n\t\tif (i > 50)\n\t\t\tbreak;\n\t}\n\tha->flags.purge_mbox = 0;\n\n\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\tif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\n\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\tqla2x00_mark_all_devices_lost(vha);\n\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tlist_for_each_entry_safe(vp, tvp, &ha->vp_list, list) {\n\t\t\tatomic_inc(&vp->vref_count);\n\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\t\tqla2x00_mark_all_devices_lost(vp);\n\n\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\tatomic_dec(&vp->vref_count);\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\t} else {\n\t\tif (!atomic_read(&vha->loop_down_timer))\n\t\t\tatomic_set(&vha->loop_down_timer,\n\t\t\t    LOOP_DOWN_TIME);\n\t}\n\n\t \n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\n\t\tfcport->scan_state = 0;\n\t}\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tlist_for_each_entry_safe(vp, tvp, &ha->vp_list, list) {\n\t\tatomic_inc(&vp->vref_count);\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\tlist_for_each_entry(fcport, &vp->vp_fcports, list)\n\t\t\tfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\n\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tatomic_dec(&vp->vref_count);\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t \n\tif (IS_P3P_TYPE(ha)) {\n\t\tqla82xx_chip_reset_cleanup(vha);\n\t\tql_log(ql_log_info, vha, 0x00b4,\n\t\t       \"Done chip reset cleanup.\\n\");\n\n\t\t \n\t\tvha->flags.online = 0;\n\t}\n\n\t \n\tqla2x00_abort_all_cmds(vha, DID_RESET << 16);\n\t \n\twmb();\n}\n\n \nint\nqla2x00_abort_isp(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint8_t        status = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *vp, *tvp;\n\tstruct req_que *req = ha->req_q_map[0];\n\tunsigned long flags;\n\n\tif (vha->flags.online) {\n\t\tqla2x00_abort_isp_cleanup(vha);\n\n\t\tvha->dport_status |= DPORT_DIAG_CHIP_RESET_IN_PROGRESS;\n\t\tvha->dport_status &= ~DPORT_DIAG_IN_PROGRESS;\n\n\t\tif (vha->hw->flags.port_isolated)\n\t\t\treturn status;\n\n\t\tif (qla2x00_isp_reg_stat(ha)) {\n\t\t\tql_log(ql_log_info, vha, 0x803f,\n\t\t\t       \"ISP Abort - ISP reg disconnect, exiting.\\n\");\n\t\t\treturn status;\n\t\t}\n\n\t\tif (test_and_clear_bit(ISP_ABORT_TO_ROM, &vha->dpc_flags)) {\n\t\t\tha->flags.chip_reset_done = 1;\n\t\t\tvha->flags.online = 1;\n\t\t\tstatus = 0;\n\t\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\t\t\treturn status;\n\t\t}\n\n\t\tif (IS_QLA8031(ha)) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb05c,\n\t\t\t    \"Clearing fcoe driver presence.\\n\");\n\t\t\tif (qla83xx_clear_drv_presence(vha) != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb073,\n\t\t\t\t    \"Error while clearing DRV-Presence.\\n\");\n\t\t}\n\n\t\tif (unlikely(pci_channel_offline(ha->pdev) &&\n\t\t    ha->flags.pci_channel_io_perm_failure)) {\n\t\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\t\t\tstatus = 0;\n\t\t\treturn status;\n\t\t}\n\n\t\tswitch (vha->qlini_mode) {\n\t\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\t\tif (!qla_tgt_mode_enabled(vha))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase QLA2XXX_INI_MODE_DUAL:\n\t\t\tif (!qla_dual_mode_enabled(vha) &&\n\t\t\t    !qla_ini_mode_enabled(vha))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tha->isp_ops->get_flash_version(vha, req->ring);\n\n\t\tif (qla2x00_isp_reg_stat(ha)) {\n\t\t\tql_log(ql_log_info, vha, 0x803f,\n\t\t\t       \"ISP Abort - ISP reg disconnect pre nvram config, exiting.\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tha->isp_ops->nvram_config(vha);\n\n\t\tif (qla2x00_isp_reg_stat(ha)) {\n\t\t\tql_log(ql_log_info, vha, 0x803f,\n\t\t\t       \"ISP Abort - ISP reg disconnect post nvmram config, exiting.\\n\");\n\t\t\treturn status;\n\t\t}\n\t\tif (!qla2x00_restart_isp(vha)) {\n\t\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\n\t\t\tif (!atomic_read(&vha->loop_down_timer)) {\n\t\t\t\t \n\t\t\t\tvha->marker_needed = 1;\n\t\t\t}\n\n\t\t\tvha->flags.online = 1;\n\n\t\t\tha->isp_ops->enable_intrs(ha);\n\n\t\t\tha->isp_abort_cnt = 0;\n\t\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\n\t\t\tif (IS_QLA81XX(ha) || IS_QLA8031(ha))\n\t\t\t\tqla2x00_get_fw_version(vha);\n\t\t\tif (ha->fce) {\n\t\t\t\tha->flags.fce_enabled = 1;\n\t\t\t\tmemset(ha->fce, 0,\n\t\t\t\t    fce_calc_size(ha->fce_bufs));\n\t\t\t\trval = qla2x00_enable_fce_trace(vha,\n\t\t\t\t    ha->fce_dma, ha->fce_bufs, ha->fce_mb,\n\t\t\t\t    &ha->fce_bufs);\n\t\t\t\tif (rval) {\n\t\t\t\t\tql_log(ql_log_warn, vha, 0x8033,\n\t\t\t\t\t    \"Unable to reinitialize FCE \"\n\t\t\t\t\t    \"(%d).\\n\", rval);\n\t\t\t\t\tha->flags.fce_enabled = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ha->eft) {\n\t\t\t\tmemset(ha->eft, 0, EFT_SIZE);\n\t\t\t\trval = qla2x00_enable_eft_trace(vha,\n\t\t\t\t    ha->eft_dma, EFT_NUM_BUFFERS);\n\t\t\t\tif (rval) {\n\t\t\t\t\tql_log(ql_log_warn, vha, 0x8034,\n\t\t\t\t\t    \"Unable to reinitialize EFT \"\n\t\t\t\t\t    \"(%d).\\n\", rval);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\t \n\t\t\tvha->flags.online = 1;\n\t\t\tif (test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\n\t\t\t\tif (ha->isp_abort_cnt == 0) {\n\t\t\t\t\tql_log(ql_log_fatal, vha, 0x8035,\n\t\t\t\t\t    \"ISP error recover failed - \"\n\t\t\t\t\t    \"board disabled.\\n\");\n\t\t\t\t\t \n\t\t\t\t\tqla2x00_abort_isp_cleanup(vha);\n\t\t\t\t\tvha->flags.online = 0;\n\t\t\t\t\tclear_bit(ISP_ABORT_RETRY,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\tstatus = 0;\n\t\t\t\t} else {  \n\t\t\t\t\tha->isp_abort_cnt--;\n\t\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8020,\n\t\t\t\t\t    \"ISP abort - retry remaining %d.\\n\",\n\t\t\t\t\t    ha->isp_abort_cnt);\n\t\t\t\t\tstatus = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tha->isp_abort_cnt = MAX_RETRIES_OF_ISP_ABORT;\n\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8021,\n\t\t\t\t    \"ISP error recovery - retrying (%d) \"\n\t\t\t\t    \"more times.\\n\", ha->isp_abort_cnt);\n\t\t\t\tset_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (vha->hw->flags.port_isolated) {\n\t\tqla2x00_abort_isp_cleanup(vha);\n\t\treturn status;\n\t}\n\n\tif (!status) {\n\t\tql_dbg(ql_dbg_taskm, vha, 0x8022, \"%s succeeded.\\n\", __func__);\n\t\tqla2x00_configure_hba(vha);\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tlist_for_each_entry_safe(vp, tvp, &ha->vp_list, list) {\n\t\t\tif (vp->vp_idx) {\n\t\t\t\tatomic_inc(&vp->vref_count);\n\t\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\t\t\tqla2x00_vp_abort_isp(vp);\n\n\t\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\t\tatomic_dec(&vp->vref_count);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\tif (IS_QLA8031(ha)) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb05d,\n\t\t\t    \"Setting back fcoe driver presence.\\n\");\n\t\t\tif (qla83xx_set_drv_presence(vha) != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb074,\n\t\t\t\t    \"Error while setting DRV-Presence.\\n\");\n\t\t}\n\t} else {\n\t\tql_log(ql_log_warn, vha, 0x8023, \"%s **** FAILED ****.\\n\",\n\t\t       __func__);\n\t}\n\n\treturn(status);\n}\n\n \nstatic int\nqla2x00_restart_isp(scsi_qla_host_t *vha)\n{\n\tint status;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (qla2x00_isp_firmware(vha)) {\n\t\tvha->flags.online = 0;\n\t\tstatus = ha->isp_ops->chip_diag(vha);\n\t\tif (status)\n\t\t\treturn status;\n\t\tstatus = qla2x00_setup_chip(vha);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tstatus = qla2x00_init_rings(vha);\n\tif (status)\n\t\treturn status;\n\n\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\tha->flags.chip_reset_done = 1;\n\n\t \n\tqla25xx_init_queues(ha);\n\n\tstatus = qla2x00_fw_ready(vha);\n\tif (status) {\n\t\t \n\t\treturn vha->device_flags & DFLG_NO_CABLE ? 0 : status;\n\t}\n\n\t \n\tqla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL);\n\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\n\treturn 0;\n}\n\nstatic int\nqla25xx_init_queues(struct qla_hw_data *ha)\n{\n\tstruct rsp_que *rsp = NULL;\n\tstruct req_que *req = NULL;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tint ret = -1;\n\tint i;\n\n\tfor (i = 1; i < ha->max_rsp_queues; i++) {\n\t\trsp = ha->rsp_q_map[i];\n\t\tif (rsp && test_bit(i, ha->rsp_qid_map)) {\n\t\t\trsp->options &= ~BIT_0;\n\t\t\tret = qla25xx_init_rsp_que(base_vha, rsp);\n\t\t\tif (ret != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_init, base_vha, 0x00ff,\n\t\t\t\t    \"%s Rsp que: %d init failed.\\n\",\n\t\t\t\t    __func__, rsp->id);\n\t\t\telse\n\t\t\t\tql_dbg(ql_dbg_init, base_vha, 0x0100,\n\t\t\t\t    \"%s Rsp que: %d inited.\\n\",\n\t\t\t\t    __func__, rsp->id);\n\t\t}\n\t}\n\tfor (i = 1; i < ha->max_req_queues; i++) {\n\t\treq = ha->req_q_map[i];\n\t\tif (req && test_bit(i, ha->req_qid_map)) {\n\t\t\t \n\t\t\treq->options &= ~BIT_0;\n\t\t\tret = qla25xx_init_req_que(base_vha, req);\n\t\t\tif (ret != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_init, base_vha, 0x0101,\n\t\t\t\t    \"%s Req que: %d init failed.\\n\",\n\t\t\t\t    __func__, req->id);\n\t\t\telse\n\t\t\t\tql_dbg(ql_dbg_init, base_vha, 0x0102,\n\t\t\t\t    \"%s Req que: %d inited.\\n\",\n\t\t\t\t    __func__, req->id);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nint\nqla2x00_reset_adapter(scsi_qla_host_t *vha)\n{\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tvha->flags.online = 0;\n\tha->isp_ops->disable_intrs(ha);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twrt_reg_word(&reg->hccr, HCCR_RESET_RISC);\n\trd_reg_word(&reg->hccr);\t\t\t \n\twrt_reg_word(&reg->hccr, HCCR_RELEASE_RISC);\n\trd_reg_word(&reg->hccr);\t\t\t \n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\nint\nqla24xx_reset_adapter(scsi_qla_host_t *vha)\n{\n\tunsigned long flags = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn QLA_SUCCESS;\n\n\tvha->flags.online = 0;\n\tha->isp_ops->disable_intrs(ha);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twrt_reg_dword(&reg->hccr, HCCRX_SET_RISC_RESET);\n\trd_reg_dword(&reg->hccr);\n\twrt_reg_dword(&reg->hccr, HCCRX_REL_RISC_PAUSE);\n\trd_reg_dword(&reg->hccr);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (IS_NOPOLLING_TYPE(ha))\n\t\tha->isp_ops->enable_intrs(ha);\n\n\treturn QLA_SUCCESS;\n}\n\n \nstatic void qla24xx_nvram_wwn_from_ofw(scsi_qla_host_t *vha,\n\tstruct nvram_24xx *nv)\n{\n#ifdef CONFIG_SPARC\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct pci_dev *pdev = ha->pdev;\n\tstruct device_node *dp = pci_device_to_OF_node(pdev);\n\tconst u8 *val;\n\tint len;\n\n\tval = of_get_property(dp, \"port-wwn\", &len);\n\tif (val && len >= WWN_SIZE)\n\t\tmemcpy(nv->port_name, val, WWN_SIZE);\n\n\tval = of_get_property(dp, \"node-wwn\", &len);\n\tif (val && len >= WWN_SIZE)\n\t\tmemcpy(nv->node_name, val, WWN_SIZE);\n#endif\n}\n\nint\nqla24xx_nvram_config(scsi_qla_host_t *vha)\n{\n\tint   rval;\n\tstruct init_cb_24xx *icb;\n\tstruct nvram_24xx *nv;\n\t__le32 *dptr;\n\tuint8_t  *dptr1, *dptr2;\n\tuint32_t chksum;\n\tuint16_t cnt;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\trval = QLA_SUCCESS;\n\ticb = (struct init_cb_24xx *)ha->init_cb;\n\tnv = ha->nvram;\n\n\t \n\tif (ha->port_no == 0) {\n\t\tha->nvram_base = FA_NVRAM_FUNC0_ADDR;\n\t\tha->vpd_base = FA_NVRAM_VPD0_ADDR;\n\t} else {\n\t\tha->nvram_base = FA_NVRAM_FUNC1_ADDR;\n\t\tha->vpd_base = FA_NVRAM_VPD1_ADDR;\n\t}\n\n\tha->nvram_size = sizeof(*nv);\n\tha->vpd_size = FA_NVRAM_VPD_SIZE;\n\n\t \n\tha->vpd = ha->nvram + VPD_OFFSET;\n\tha->isp_ops->read_nvram(vha, ha->vpd,\n\t    ha->nvram_base - FA_NVRAM_FUNC0_ADDR, FA_NVRAM_VPD_SIZE * 4);\n\n\t \n\tdptr = (__force __le32 *)nv;\n\tha->isp_ops->read_nvram(vha, dptr, ha->nvram_base, ha->nvram_size);\n\tfor (cnt = 0, chksum = 0; cnt < ha->nvram_size >> 2; cnt++, dptr++)\n\t\tchksum += le32_to_cpu(*dptr);\n\n\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x006a,\n\t    \"Contents of NVRAM\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010d,\n\t    nv, ha->nvram_size);\n\n\t \n\tif (chksum || memcmp(\"ISP \", nv->id, sizeof(nv->id)) ||\n\t    le16_to_cpu(nv->nvram_version) < ICB_VERSION) {\n\t\t \n\t\tql_log(ql_log_warn, vha, 0x006b,\n\t\t    \"Inconsistent NVRAM checksum=%#x id=%.4s version=%#x.\\n\",\n\t\t    chksum, nv->id, nv->nvram_version);\n\t\tql_dump_buffer(ql_dbg_init, vha, 0x006b, nv, sizeof(*nv));\n\t\tql_log(ql_log_warn, vha, 0x006c,\n\t\t    \"Falling back to functioning (yet invalid -- WWPN) \"\n\t\t    \"defaults.\\n\");\n\n\t\t \n\t\tmemset(nv, 0, ha->nvram_size);\n\t\tnv->nvram_version = cpu_to_le16(ICB_VERSION);\n\t\tnv->version = cpu_to_le16(ICB_VERSION);\n\t\tnv->frame_payload_size = cpu_to_le16(2048);\n\t\tnv->execution_throttle = cpu_to_le16(0xFFFF);\n\t\tnv->exchange_count = cpu_to_le16(0);\n\t\tnv->hard_address = cpu_to_le16(124);\n\t\tnv->port_name[0] = 0x21;\n\t\tnv->port_name[1] = 0x00 + ha->port_no + 1;\n\t\tnv->port_name[2] = 0x00;\n\t\tnv->port_name[3] = 0xe0;\n\t\tnv->port_name[4] = 0x8b;\n\t\tnv->port_name[5] = 0x1c;\n\t\tnv->port_name[6] = 0x55;\n\t\tnv->port_name[7] = 0x86;\n\t\tnv->node_name[0] = 0x20;\n\t\tnv->node_name[1] = 0x00;\n\t\tnv->node_name[2] = 0x00;\n\t\tnv->node_name[3] = 0xe0;\n\t\tnv->node_name[4] = 0x8b;\n\t\tnv->node_name[5] = 0x1c;\n\t\tnv->node_name[6] = 0x55;\n\t\tnv->node_name[7] = 0x86;\n\t\tqla24xx_nvram_wwn_from_ofw(vha, nv);\n\t\tnv->login_retry_count = cpu_to_le16(8);\n\t\tnv->interrupt_delay_timer = cpu_to_le16(0);\n\t\tnv->login_timeout = cpu_to_le16(0);\n\t\tnv->firmware_options_1 =\n\t\t    cpu_to_le32(BIT_14|BIT_13|BIT_2|BIT_1);\n\t\tnv->firmware_options_2 = cpu_to_le32(2 << 4);\n\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_12);\n\t\tnv->firmware_options_3 = cpu_to_le32(2 << 13);\n\t\tnv->host_p = cpu_to_le32(BIT_11|BIT_10);\n\t\tnv->efi_parameters = cpu_to_le32(0);\n\t\tnv->reset_delay = 5;\n\t\tnv->max_luns_per_target = cpu_to_le16(128);\n\t\tnv->port_down_retry_count = cpu_to_le16(30);\n\t\tnv->link_down_timeout = cpu_to_le16(30);\n\n\t\trval = 1;\n\t}\n\n\tif (qla_tgt_mode_enabled(vha)) {\n\t\t \n\t\tnv->firmware_options_1 &= cpu_to_le32(~BIT_13);\n\t\t \n\t\tnv->host_p &= cpu_to_le32(~BIT_10);\n\t}\n\n\tqlt_24xx_config_nvram_stage1(vha, nv);\n\n\t \n\tmemset(icb, 0, ha->init_cb_size);\n\n\t \n\tdptr1 = (uint8_t *)icb;\n\tdptr2 = (uint8_t *)&nv->version;\n\tcnt = (uint8_t *)&icb->response_q_inpointer - (uint8_t *)&icb->version;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\n\ticb->login_retry_count = nv->login_retry_count;\n\ticb->link_down_on_nos = nv->link_down_on_nos;\n\n\t \n\tdptr1 = (uint8_t *)&icb->interrupt_delay_timer;\n\tdptr2 = (uint8_t *)&nv->interrupt_delay_timer;\n\tcnt = (uint8_t *)&icb->reserved_3 -\n\t    (uint8_t *)&icb->interrupt_delay_timer;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\tha->frame_payload_size = le16_to_cpu(icb->frame_payload_size);\n\t \n\tqla2x00_set_model_info(vha, nv->model_name, sizeof(nv->model_name),\n\t    \"QLA2462\");\n\n\tqlt_24xx_config_nvram_stage2(vha, icb);\n\n\tif (nv->host_p & cpu_to_le32(BIT_15)) {\n\t\t \n\t\tmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\n\t\tmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\n\t}\n\n\t \n\tif ((icb->firmware_options_1 & cpu_to_le32(BIT_14)) == 0) {\n\t\t \n\t\tmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\n\t\ticb->node_name[0] &= 0xF0;\n\t}\n\n\t \n\tha->flags.disable_risc_code_load = 0;\n\tha->flags.enable_lip_reset = 0;\n\tha->flags.enable_lip_full_login =\n\t    le32_to_cpu(nv->host_p) & BIT_10 ? 1 : 0;\n\tha->flags.enable_target_reset =\n\t    le32_to_cpu(nv->host_p) & BIT_11 ? 1 : 0;\n\tha->flags.enable_led_scheme = 0;\n\tha->flags.disable_serdes = le32_to_cpu(nv->host_p) & BIT_5 ? 1 : 0;\n\n\tha->operating_mode = (le32_to_cpu(icb->firmware_options_2) &\n\t    (BIT_6 | BIT_5 | BIT_4)) >> 4;\n\n\tmemcpy(ha->fw_seriallink_options24, nv->seriallink_options,\n\t    sizeof(ha->fw_seriallink_options24));\n\n\t \n\tha->serial0 = icb->port_name[5];\n\tha->serial1 = icb->port_name[6];\n\tha->serial2 = icb->port_name[7];\n\tmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\n\tmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\n\n\ticb->execution_throttle = cpu_to_le16(0xFFFF);\n\n\tha->retry_count = le16_to_cpu(nv->login_retry_count);\n\n\t \n\tif (le16_to_cpu(nv->login_timeout) < ql2xlogintimeout)\n\t\tnv->login_timeout = cpu_to_le16(ql2xlogintimeout);\n\tif (le16_to_cpu(nv->login_timeout) < 4)\n\t\tnv->login_timeout = cpu_to_le16(4);\n\tha->login_timeout = le16_to_cpu(nv->login_timeout);\n\n\t \n\tha->r_a_tov = 100;\n\n\tha->loop_reset_delay = nv->reset_delay;\n\n\t \n\tif (le16_to_cpu(nv->link_down_timeout) == 0) {\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\n\t} else {\n\t\tha->link_down_timeout =\tle16_to_cpu(nv->link_down_timeout);\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - ha->link_down_timeout);\n\t}\n\n\t \n\tha->port_down_retry_count = le16_to_cpu(nv->port_down_retry_count);\n\tif (qlport_down_retry)\n\t\tha->port_down_retry_count = qlport_down_retry;\n\n\t \n\tha->login_retry_count  = le16_to_cpu(nv->login_retry_count);\n\tif (ha->port_down_retry_count ==\n\t    le16_to_cpu(nv->port_down_retry_count) &&\n\t    ha->port_down_retry_count > 3)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\telse if (ha->port_down_retry_count > (int)ha->login_retry_count)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\tif (ql2xloginretrycount)\n\t\tha->login_retry_count = ql2xloginretrycount;\n\n\t \n\ticb->firmware_options_3 |= cpu_to_le32(BIT_8);\n\n\t \n\tif (!vha->flags.init_done) {\n\t\tha->zio_mode = le32_to_cpu(icb->firmware_options_2) &\n\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\tha->zio_timer = le16_to_cpu(icb->interrupt_delay_timer) ?\n\t\t    le16_to_cpu(icb->interrupt_delay_timer) : 2;\n\t}\n\ticb->firmware_options_2 &= cpu_to_le32(\n\t    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0));\n\tif (ha->zio_mode != QLA_ZIO_DISABLED) {\n\t\tha->zio_mode = QLA_ZIO_MODE_6;\n\n\t\tql_log(ql_log_info, vha, 0x006f,\n\t\t    \"ZIO mode %d enabled; timer delay (%d us).\\n\",\n\t\t    ha->zio_mode, ha->zio_timer * 100);\n\n\t\ticb->firmware_options_2 |= cpu_to_le32(\n\t\t    (uint32_t)ha->zio_mode);\n\t\ticb->interrupt_delay_timer = cpu_to_le16(ha->zio_timer);\n\t}\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0070,\n\t\t    \"NVRAM configuration failed.\\n\");\n\t}\n\treturn (rval);\n}\n\nstatic void\nqla27xx_print_image(struct scsi_qla_host *vha, char *name,\n    struct qla27xx_image_status *image_status)\n{\n\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t    \"%s %s: mask=%#02x gen=%#04x ver=%u.%u map=%#01x sum=%#08x sig=%#08x\\n\",\n\t    name, \"status\",\n\t    image_status->image_status_mask,\n\t    le16_to_cpu(image_status->generation),\n\t    image_status->ver_major,\n\t    image_status->ver_minor,\n\t    image_status->bitmap,\n\t    le32_to_cpu(image_status->checksum),\n\t    le32_to_cpu(image_status->signature));\n}\n\nstatic bool\nqla28xx_check_aux_image_status_signature(\n    struct qla27xx_image_status *image_status)\n{\n\tulong signature = le32_to_cpu(image_status->signature);\n\n\treturn signature != QLA28XX_AUX_IMG_STATUS_SIGN;\n}\n\nstatic bool\nqla27xx_check_image_status_signature(struct qla27xx_image_status *image_status)\n{\n\tulong signature = le32_to_cpu(image_status->signature);\n\n\treturn\n\t    signature != QLA27XX_IMG_STATUS_SIGN &&\n\t    signature != QLA28XX_IMG_STATUS_SIGN;\n}\n\nstatic ulong\nqla27xx_image_status_checksum(struct qla27xx_image_status *image_status)\n{\n\t__le32 *p = (__force __le32 *)image_status;\n\tuint n = sizeof(*image_status) / sizeof(*p);\n\tuint32_t sum = 0;\n\n\tfor ( ; n--; p++)\n\t\tsum += le32_to_cpup(p);\n\n\treturn sum;\n}\n\nstatic inline uint\nqla28xx_component_bitmask(struct qla27xx_image_status *aux, uint bitmask)\n{\n\treturn aux->bitmap & bitmask ?\n\t    QLA27XX_SECONDARY_IMAGE : QLA27XX_PRIMARY_IMAGE;\n}\n\nstatic void\nqla28xx_component_status(\n    struct active_regions *active_regions, struct qla27xx_image_status *aux)\n{\n\tactive_regions->aux.board_config =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_BOARD_CONFIG);\n\n\tactive_regions->aux.vpd_nvram =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_VPD_NVRAM);\n\n\tactive_regions->aux.npiv_config_0_1 =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_NPIV_CONFIG_0_1);\n\n\tactive_regions->aux.npiv_config_2_3 =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_NPIV_CONFIG_2_3);\n\n\tactive_regions->aux.nvme_params =\n\t    qla28xx_component_bitmask(aux, QLA28XX_AUX_IMG_NVME_PARAMS);\n}\n\nstatic int\nqla27xx_compare_image_generation(\n    struct qla27xx_image_status *pri_image_status,\n    struct qla27xx_image_status *sec_image_status)\n{\n\t \n\tint16_t delta =\n\t    le16_to_cpu(pri_image_status->generation) -\n\t    le16_to_cpu(sec_image_status->generation);\n\n\tql_dbg(ql_dbg_init, NULL, 0x0180, \"generation delta = %d\\n\", delta);\n\n\treturn delta;\n}\n\nvoid\nqla28xx_get_aux_images(\n\tstruct scsi_qla_host *vha, struct active_regions *active_regions)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla27xx_image_status pri_aux_image_status, sec_aux_image_status;\n\tbool valid_pri_image = false, valid_sec_image = false;\n\tbool active_pri_image = false, active_sec_image = false;\n\n\tif (!ha->flt_region_aux_img_status_pri) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a, \"Primary aux image not addressed\\n\");\n\t\tgoto check_sec_image;\n\t}\n\n\tqla24xx_read_flash_data(vha, (uint32_t *)&pri_aux_image_status,\n\t    ha->flt_region_aux_img_status_pri,\n\t    sizeof(pri_aux_image_status) >> 2);\n\tqla27xx_print_image(vha, \"Primary aux image\", &pri_aux_image_status);\n\n\tif (qla28xx_check_aux_image_status_signature(&pri_aux_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t\t    \"Primary aux image signature (%#x) not valid\\n\",\n\t\t    le32_to_cpu(pri_aux_image_status.signature));\n\t\tgoto check_sec_image;\n\t}\n\n\tif (qla27xx_image_status_checksum(&pri_aux_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018c,\n\t\t    \"Primary aux image checksum failed\\n\");\n\t\tgoto check_sec_image;\n\t}\n\n\tvalid_pri_image = true;\n\n\tif (pri_aux_image_status.image_status_mask & 1) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018d,\n\t\t    \"Primary aux image is active\\n\");\n\t\tactive_pri_image = true;\n\t}\n\ncheck_sec_image:\n\tif (!ha->flt_region_aux_img_status_sec) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a,\n\t\t    \"Secondary aux image not addressed\\n\");\n\t\tgoto check_valid_image;\n\t}\n\n\tqla24xx_read_flash_data(vha, (uint32_t *)&sec_aux_image_status,\n\t    ha->flt_region_aux_img_status_sec,\n\t    sizeof(sec_aux_image_status) >> 2);\n\tqla27xx_print_image(vha, \"Secondary aux image\", &sec_aux_image_status);\n\n\tif (qla28xx_check_aux_image_status_signature(&sec_aux_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t\t    \"Secondary aux image signature (%#x) not valid\\n\",\n\t\t    le32_to_cpu(sec_aux_image_status.signature));\n\t\tgoto check_valid_image;\n\t}\n\n\tif (qla27xx_image_status_checksum(&sec_aux_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018c,\n\t\t    \"Secondary aux image checksum failed\\n\");\n\t\tgoto check_valid_image;\n\t}\n\n\tvalid_sec_image = true;\n\n\tif (sec_aux_image_status.image_status_mask & 1) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018d,\n\t\t    \"Secondary aux image is active\\n\");\n\t\tactive_sec_image = true;\n\t}\n\ncheck_valid_image:\n\tif (valid_pri_image && active_pri_image &&\n\t    valid_sec_image && active_sec_image) {\n\t\tif (qla27xx_compare_image_generation(&pri_aux_image_status,\n\t\t    &sec_aux_image_status) >= 0) {\n\t\t\tqla28xx_component_status(active_regions,\n\t\t\t    &pri_aux_image_status);\n\t\t} else {\n\t\t\tqla28xx_component_status(active_regions,\n\t\t\t    &sec_aux_image_status);\n\t\t}\n\t} else if (valid_pri_image && active_pri_image) {\n\t\tqla28xx_component_status(active_regions, &pri_aux_image_status);\n\t} else if (valid_sec_image && active_sec_image) {\n\t\tqla28xx_component_status(active_regions, &sec_aux_image_status);\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x018f,\n\t    \"aux images active: BCFG=%u VPD/NVR=%u NPIV0/1=%u NPIV2/3=%u, NVME=%u\\n\",\n\t    active_regions->aux.board_config,\n\t    active_regions->aux.vpd_nvram,\n\t    active_regions->aux.npiv_config_0_1,\n\t    active_regions->aux.npiv_config_2_3,\n\t    active_regions->aux.nvme_params);\n}\n\nvoid\nqla27xx_get_active_image(struct scsi_qla_host *vha,\n    struct active_regions *active_regions)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla27xx_image_status pri_image_status, sec_image_status;\n\tbool valid_pri_image = false, valid_sec_image = false;\n\tbool active_pri_image = false, active_sec_image = false;\n\n\tif (!ha->flt_region_img_status_pri) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a, \"Primary image not addressed\\n\");\n\t\tgoto check_sec_image;\n\t}\n\n\tif (qla24xx_read_flash_data(vha, (uint32_t *)&pri_image_status,\n\t    ha->flt_region_img_status_pri, sizeof(pri_image_status) >> 2) !=\n\t    QLA_SUCCESS) {\n\t\tWARN_ON_ONCE(true);\n\t\tgoto check_sec_image;\n\t}\n\tqla27xx_print_image(vha, \"Primary image\", &pri_image_status);\n\n\tif (qla27xx_check_image_status_signature(&pri_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t\t    \"Primary image signature (%#x) not valid\\n\",\n\t\t    le32_to_cpu(pri_image_status.signature));\n\t\tgoto check_sec_image;\n\t}\n\n\tif (qla27xx_image_status_checksum(&pri_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018c,\n\t\t    \"Primary image checksum failed\\n\");\n\t\tgoto check_sec_image;\n\t}\n\n\tvalid_pri_image = true;\n\n\tif (pri_image_status.image_status_mask & 1) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018d,\n\t\t    \"Primary image is active\\n\");\n\t\tactive_pri_image = true;\n\t}\n\ncheck_sec_image:\n\tif (!ha->flt_region_img_status_sec) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a, \"Secondary image not addressed\\n\");\n\t\tgoto check_valid_image;\n\t}\n\n\tqla24xx_read_flash_data(vha, (uint32_t *)(&sec_image_status),\n\t    ha->flt_region_img_status_sec, sizeof(sec_image_status) >> 2);\n\tqla27xx_print_image(vha, \"Secondary image\", &sec_image_status);\n\n\tif (qla27xx_check_image_status_signature(&sec_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018b,\n\t\t    \"Secondary image signature (%#x) not valid\\n\",\n\t\t    le32_to_cpu(sec_image_status.signature));\n\t\tgoto check_valid_image;\n\t}\n\n\tif (qla27xx_image_status_checksum(&sec_image_status)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018c,\n\t\t    \"Secondary image checksum failed\\n\");\n\t\tgoto check_valid_image;\n\t}\n\n\tvalid_sec_image = true;\n\n\tif (sec_image_status.image_status_mask & 1) {\n\t\tql_dbg(ql_dbg_init, vha, 0x018d,\n\t\t    \"Secondary image is active\\n\");\n\t\tactive_sec_image = true;\n\t}\n\ncheck_valid_image:\n\tif (valid_pri_image && active_pri_image)\n\t\tactive_regions->global = QLA27XX_PRIMARY_IMAGE;\n\n\tif (valid_sec_image && active_sec_image) {\n\t\tif (!active_regions->global ||\n\t\t    qla27xx_compare_image_generation(\n\t\t\t&pri_image_status, &sec_image_status) < 0) {\n\t\t\tactive_regions->global = QLA27XX_SECONDARY_IMAGE;\n\t\t}\n\t}\n\n\tql_dbg(ql_dbg_init, vha, 0x018f, \"active image %s (%u)\\n\",\n\t    active_regions->global == QLA27XX_DEFAULT_IMAGE ?\n\t\t\"default (boot/fw)\" :\n\t    active_regions->global == QLA27XX_PRIMARY_IMAGE ?\n\t\t\"primary\" :\n\t    active_regions->global == QLA27XX_SECONDARY_IMAGE ?\n\t\t\"secondary\" : \"invalid\",\n\t    active_regions->global);\n}\n\nbool qla24xx_risc_firmware_invalid(uint32_t *dword)\n{\n\treturn\n\t    !(dword[4] | dword[5] | dword[6] | dword[7]) ||\n\t    !(~dword[4] | ~dword[5] | ~dword[6] | ~dword[7]);\n}\n\nstatic int\nqla24xx_load_risc_flash(scsi_qla_host_t *vha, uint32_t *srisc_addr,\n    uint32_t faddr)\n{\n\tint rval;\n\tuint templates, segments, fragment;\n\tulong i;\n\tuint j;\n\tulong dlen;\n\tuint32_t *dcode;\n\tuint32_t risc_addr, risc_size, risc_attr = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct fwdt *fwdt = ha->fwdt;\n\n\tql_dbg(ql_dbg_init, vha, 0x008b,\n\t    \"FW: Loading firmware from flash (%x).\\n\", faddr);\n\n\tdcode = (uint32_t *)req->ring;\n\tqla24xx_read_flash_data(vha, dcode, faddr, 8);\n\tif (qla24xx_risc_firmware_invalid(dcode)) {\n\t\tql_log(ql_log_fatal, vha, 0x008c,\n\t\t    \"Unable to verify the integrity of flash firmware \"\n\t\t    \"image.\\n\");\n\t\tql_log(ql_log_fatal, vha, 0x008d,\n\t\t    \"Firmware data: %08x %08x %08x %08x.\\n\",\n\t\t    dcode[0], dcode[1], dcode[2], dcode[3]);\n\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tdcode = (uint32_t *)req->ring;\n\t*srisc_addr = 0;\n\tsegments = FA_RISC_CODE_SEGMENTS;\n\tfor (j = 0; j < segments; j++) {\n\t\tql_dbg(ql_dbg_init, vha, 0x008d,\n\t\t    \"-> Loading segment %u...\\n\", j);\n\t\tqla24xx_read_flash_data(vha, dcode, faddr, 10);\n\t\trisc_addr = be32_to_cpu((__force __be32)dcode[2]);\n\t\trisc_size = be32_to_cpu((__force __be32)dcode[3]);\n\t\tif (!*srisc_addr) {\n\t\t\t*srisc_addr = risc_addr;\n\t\t\trisc_attr = be32_to_cpu((__force __be32)dcode[9]);\n\t\t}\n\n\t\tdlen = ha->fw_transfer_size >> 2;\n\t\tfor (fragment = 0; risc_size; fragment++) {\n\t\t\tif (dlen > risc_size)\n\t\t\t\tdlen = risc_size;\n\n\t\t\tql_dbg(ql_dbg_init, vha, 0x008e,\n\t\t\t    \"-> Loading fragment %u: %#x <- %#x (%#lx dwords)...\\n\",\n\t\t\t    fragment, risc_addr, faddr, dlen);\n\t\t\tqla24xx_read_flash_data(vha, dcode, faddr, dlen);\n\t\t\tfor (i = 0; i < dlen; i++)\n\t\t\t\tdcode[i] = swab32(dcode[i]);\n\n\t\t\trval = qla2x00_load_ram(vha, req->dma, risc_addr, dlen);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x008f,\n\t\t\t\t    \"-> Failed load firmware fragment %u.\\n\",\n\t\t\t\t    fragment);\n\t\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t\t}\n\n\t\t\tfaddr += dlen;\n\t\t\trisc_addr += dlen;\n\t\t\trisc_size -= dlen;\n\t\t}\n\t}\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_SUCCESS;\n\n\ttemplates = (risc_attr & BIT_9) ? 2 : 1;\n\tql_dbg(ql_dbg_init, vha, 0x0160, \"-> templates = %u\\n\", templates);\n\tfor (j = 0; j < templates; j++, fwdt++) {\n\t\tvfree(fwdt->template);\n\t\tfwdt->template = NULL;\n\t\tfwdt->length = 0;\n\n\t\tdcode = (uint32_t *)req->ring;\n\t\tqla24xx_read_flash_data(vha, dcode, faddr, 7);\n\t\trisc_size = be32_to_cpu((__force __be32)dcode[2]);\n\t\tql_dbg(ql_dbg_init, vha, 0x0161,\n\t\t    \"-> fwdt%u template array at %#x (%#x dwords)\\n\",\n\t\t    j, faddr, risc_size);\n\t\tif (!risc_size || !~risc_size) {\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0162,\n\t\t\t    \"-> fwdt%u failed to read array\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\t \n\t\tfaddr += 7;\n\t\trisc_size -= 8;\n\n\t\tql_dbg(ql_dbg_init, vha, 0x0163,\n\t\t    \"-> fwdt%u template allocate template %#x words...\\n\",\n\t\t    j, risc_size);\n\t\tfwdt->template = vmalloc_array(risc_size, sizeof(*dcode));\n\t\tif (!fwdt->template) {\n\t\t\tql_log(ql_log_warn, vha, 0x0164,\n\t\t\t    \"-> fwdt%u failed allocate template.\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdcode = fwdt->template;\n\t\tqla24xx_read_flash_data(vha, dcode, faddr, risc_size);\n\n\t\tif (!qla27xx_fwdt_template_valid(dcode)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0165,\n\t\t\t    \"-> fwdt%u failed template validate\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdlen = qla27xx_fwdt_template_size(dcode);\n\t\tql_dbg(ql_dbg_init, vha, 0x0166,\n\t\t    \"-> fwdt%u template size %#lx bytes (%#lx words)\\n\",\n\t\t    j, dlen, dlen / sizeof(*dcode));\n\t\tif (dlen > risc_size * sizeof(*dcode)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0167,\n\t\t\t    \"-> fwdt%u template exceeds array (%-lu bytes)\\n\",\n\t\t\t    j, dlen - risc_size * sizeof(*dcode));\n\t\t\tgoto failed;\n\t\t}\n\n\t\tfwdt->length = dlen;\n\t\tql_dbg(ql_dbg_init, vha, 0x0168,\n\t\t    \"-> fwdt%u loaded template ok\\n\", j);\n\n\t\tfaddr += risc_size + 1;\n\t}\n\n\treturn QLA_SUCCESS;\n\nfailed:\n\tvfree(fwdt->template);\n\tfwdt->template = NULL;\n\tfwdt->length = 0;\n\n\treturn QLA_SUCCESS;\n}\n\n#define QLA_FW_URL \"http://ldriver.qlogic.com/firmware/\"\n\nint\nqla2x00_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint\trval;\n\tint\ti, fragment;\n\tuint16_t *wcode;\n\t__be16\t *fwcode;\n\tuint32_t risc_addr, risc_size, fwclen, wlen, *seg;\n\tstruct fw_blob *blob;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\n\t \n\tblob = qla2x00_request_firmware(vha);\n\tif (!blob) {\n\t\tql_log(ql_log_info, vha, 0x0083,\n\t\t    \"Firmware image unavailable.\\n\");\n\t\tql_log(ql_log_info, vha, 0x0084,\n\t\t    \"Firmware images can be retrieved from: \"QLA_FW_URL \".\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\trval = QLA_SUCCESS;\n\n\twcode = (uint16_t *)req->ring;\n\t*srisc_addr = 0;\n\tfwcode = (__force __be16 *)blob->fw->data;\n\tfwclen = 0;\n\n\t \n\tif (blob->fw->size < 8 * sizeof(uint16_t)) {\n\t\tql_log(ql_log_fatal, vha, 0x0085,\n\t\t    \"Unable to verify integrity of firmware image (%zd).\\n\",\n\t\t    blob->fw->size);\n\t\tgoto fail_fw_integrity;\n\t}\n\tfor (i = 0; i < 4; i++)\n\t\twcode[i] = be16_to_cpu(fwcode[i + 4]);\n\tif ((wcode[0] == 0xffff && wcode[1] == 0xffff && wcode[2] == 0xffff &&\n\t    wcode[3] == 0xffff) || (wcode[0] == 0 && wcode[1] == 0 &&\n\t\twcode[2] == 0 && wcode[3] == 0)) {\n\t\tql_log(ql_log_fatal, vha, 0x0086,\n\t\t    \"Unable to verify integrity of firmware image.\\n\");\n\t\tql_log(ql_log_fatal, vha, 0x0087,\n\t\t    \"Firmware data: %04x %04x %04x %04x.\\n\",\n\t\t    wcode[0], wcode[1], wcode[2], wcode[3]);\n\t\tgoto fail_fw_integrity;\n\t}\n\n\tseg = blob->segs;\n\twhile (*seg && rval == QLA_SUCCESS) {\n\t\trisc_addr = *seg;\n\t\t*srisc_addr = *srisc_addr == 0 ? *seg : *srisc_addr;\n\t\trisc_size = be16_to_cpu(fwcode[3]);\n\n\t\t \n\t\tfwclen += risc_size * sizeof(uint16_t);\n\t\tif (blob->fw->size < fwclen) {\n\t\t\tql_log(ql_log_fatal, vha, 0x0088,\n\t\t\t    \"Unable to verify integrity of firmware image \"\n\t\t\t    \"(%zd).\\n\", blob->fw->size);\n\t\t\tgoto fail_fw_integrity;\n\t\t}\n\n\t\tfragment = 0;\n\t\twhile (risc_size > 0 && rval == QLA_SUCCESS) {\n\t\t\twlen = (uint16_t)(ha->fw_transfer_size >> 1);\n\t\t\tif (wlen > risc_size)\n\t\t\t\twlen = risc_size;\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0089,\n\t\t\t    \"Loading risc segment@ risc addr %x number of \"\n\t\t\t    \"words 0x%x.\\n\", risc_addr, wlen);\n\n\t\t\tfor (i = 0; i < wlen; i++)\n\t\t\t\twcode[i] = swab16((__force u32)fwcode[i]);\n\n\t\t\trval = qla2x00_load_ram(vha, req->dma, risc_addr,\n\t\t\t    wlen);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x008a,\n\t\t\t\t    \"Failed to load segment %d of firmware.\\n\",\n\t\t\t\t    fragment);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfwcode += wlen;\n\t\t\trisc_addr += wlen;\n\t\t\trisc_size -= wlen;\n\t\t\tfragment++;\n\t\t}\n\n\t\t \n\t\tseg++;\n\t}\n\treturn rval;\n\nfail_fw_integrity:\n\treturn QLA_FUNCTION_FAILED;\n}\n\nstatic int\nqla24xx_load_risc_blob(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint\trval;\n\tuint templates, segments, fragment;\n\tuint32_t *dcode;\n\tulong dlen;\n\tuint32_t risc_addr, risc_size, risc_attr = 0;\n\tulong i;\n\tuint j;\n\tstruct fw_blob *blob;\n\t__be32 *fwcode;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct fwdt *fwdt = ha->fwdt;\n\n\tql_dbg(ql_dbg_init, vha, 0x0090,\n\t    \"-> FW: Loading via request-firmware.\\n\");\n\n\tblob = qla2x00_request_firmware(vha);\n\tif (!blob) {\n\t\tql_log(ql_log_warn, vha, 0x0092,\n\t\t    \"-> Firmware file not found.\\n\");\n\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tfwcode = (__force __be32 *)blob->fw->data;\n\tdcode = (__force uint32_t *)fwcode;\n\tif (qla24xx_risc_firmware_invalid(dcode)) {\n\t\tql_log(ql_log_fatal, vha, 0x0093,\n\t\t    \"Unable to verify integrity of firmware image (%zd).\\n\",\n\t\t    blob->fw->size);\n\t\tql_log(ql_log_fatal, vha, 0x0095,\n\t\t    \"Firmware data: %08x %08x %08x %08x.\\n\",\n\t\t    dcode[0], dcode[1], dcode[2], dcode[3]);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tdcode = (uint32_t *)req->ring;\n\t*srisc_addr = 0;\n\tsegments = FA_RISC_CODE_SEGMENTS;\n\tfor (j = 0; j < segments; j++) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0096,\n\t\t    \"-> Loading segment %u...\\n\", j);\n\t\trisc_addr = be32_to_cpu(fwcode[2]);\n\t\trisc_size = be32_to_cpu(fwcode[3]);\n\n\t\tif (!*srisc_addr) {\n\t\t\t*srisc_addr = risc_addr;\n\t\t\trisc_attr = be32_to_cpu(fwcode[9]);\n\t\t}\n\n\t\tdlen = ha->fw_transfer_size >> 2;\n\t\tfor (fragment = 0; risc_size; fragment++) {\n\t\t\tif (dlen > risc_size)\n\t\t\t\tdlen = risc_size;\n\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0097,\n\t\t\t    \"-> Loading fragment %u: %#x <- %#x (%#lx words)...\\n\",\n\t\t\t    fragment, risc_addr,\n\t\t\t    (uint32_t)(fwcode - (typeof(fwcode))blob->fw->data),\n\t\t\t    dlen);\n\n\t\t\tfor (i = 0; i < dlen; i++)\n\t\t\t\tdcode[i] = swab32((__force u32)fwcode[i]);\n\n\t\t\trval = qla2x00_load_ram(vha, req->dma, risc_addr, dlen);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0x0098,\n\t\t\t\t    \"-> Failed load firmware fragment %u.\\n\",\n\t\t\t\t    fragment);\n\t\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t\t}\n\n\t\t\tfwcode += dlen;\n\t\t\trisc_addr += dlen;\n\t\t\trisc_size -= dlen;\n\t\t}\n\t}\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_SUCCESS;\n\n\ttemplates = (risc_attr & BIT_9) ? 2 : 1;\n\tql_dbg(ql_dbg_init, vha, 0x0170, \"-> templates = %u\\n\", templates);\n\tfor (j = 0; j < templates; j++, fwdt++) {\n\t\tvfree(fwdt->template);\n\t\tfwdt->template = NULL;\n\t\tfwdt->length = 0;\n\n\t\trisc_size = be32_to_cpu(fwcode[2]);\n\t\tql_dbg(ql_dbg_init, vha, 0x0171,\n\t\t    \"-> fwdt%u template array at %#x (%#x dwords)\\n\",\n\t\t    j, (uint32_t)((void *)fwcode - (void *)blob->fw->data),\n\t\t    risc_size);\n\t\tif (!risc_size || !~risc_size) {\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0172,\n\t\t\t    \"-> fwdt%u failed to read array\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\t \n\t\tfwcode += 7;\n\t\trisc_size -= 8;\n\n\t\tql_dbg(ql_dbg_init, vha, 0x0173,\n\t\t    \"-> fwdt%u template allocate template %#x words...\\n\",\n\t\t    j, risc_size);\n\t\tfwdt->template = vmalloc_array(risc_size, sizeof(*dcode));\n\t\tif (!fwdt->template) {\n\t\t\tql_log(ql_log_warn, vha, 0x0174,\n\t\t\t    \"-> fwdt%u failed allocate template.\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdcode = fwdt->template;\n\t\tfor (i = 0; i < risc_size; i++)\n\t\t\tdcode[i] = (__force u32)fwcode[i];\n\n\t\tif (!qla27xx_fwdt_template_valid(dcode)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0175,\n\t\t\t    \"-> fwdt%u failed template validate\\n\", j);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tdlen = qla27xx_fwdt_template_size(dcode);\n\t\tql_dbg(ql_dbg_init, vha, 0x0176,\n\t\t    \"-> fwdt%u template size %#lx bytes (%#lx words)\\n\",\n\t\t    j, dlen, dlen / sizeof(*dcode));\n\t\tif (dlen > risc_size * sizeof(*dcode)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0177,\n\t\t\t    \"-> fwdt%u template exceeds array (%-lu bytes)\\n\",\n\t\t\t    j, dlen - risc_size * sizeof(*dcode));\n\t\t\tgoto failed;\n\t\t}\n\n\t\tfwdt->length = dlen;\n\t\tql_dbg(ql_dbg_init, vha, 0x0178,\n\t\t    \"-> fwdt%u loaded template ok\\n\", j);\n\n\t\tfwcode += risc_size + 1;\n\t}\n\n\treturn QLA_SUCCESS;\n\nfailed:\n\tvfree(fwdt->template);\n\tfwdt->template = NULL;\n\tfwdt->length = 0;\n\n\treturn QLA_SUCCESS;\n}\n\nint\nqla24xx_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint rval;\n\n\tif (ql2xfwloadbin == 1)\n\t\treturn qla81xx_load_risc(vha, srisc_addr);\n\n\t \n\trval = qla24xx_load_risc_blob(vha, srisc_addr);\n\tif (rval == QLA_SUCCESS)\n\t\treturn rval;\n\n\treturn qla24xx_load_risc_flash(vha, srisc_addr,\n\t    vha->hw->flt_region_fw);\n}\n\nint\nqla81xx_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct active_regions active_regions = { };\n\n\tif (ql2xfwloadbin == 2)\n\t\tgoto try_blob_fw;\n\n\t \n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\tgoto try_primary_fw;\n\n\tqla27xx_get_active_image(vha, &active_regions);\n\n\tif (active_regions.global != QLA27XX_SECONDARY_IMAGE)\n\t\tgoto try_primary_fw;\n\n\tql_dbg(ql_dbg_init, vha, 0x008b,\n\t    \"Loading secondary firmware image.\\n\");\n\trval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_fw_sec);\n\tif (!rval)\n\t\treturn rval;\n\ntry_primary_fw:\n\tql_dbg(ql_dbg_init, vha, 0x008b,\n\t    \"Loading primary firmware image.\\n\");\n\trval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_fw);\n\tif (!rval)\n\t\treturn rval;\n\ntry_blob_fw:\n\trval = qla24xx_load_risc_blob(vha, srisc_addr);\n\tif (!rval || !ha->flt_region_gold_fw)\n\t\treturn rval;\n\n\tql_log(ql_log_info, vha, 0x0099,\n\t    \"Attempting to fallback to golden firmware.\\n\");\n\trval = qla24xx_load_risc_flash(vha, srisc_addr, ha->flt_region_gold_fw);\n\tif (rval)\n\t\treturn rval;\n\n\tql_log(ql_log_info, vha, 0x009a, \"Need firmware flash update.\\n\");\n\tha->flags.running_gold_fw = 1;\n\treturn rval;\n}\n\nvoid\nqla2x00_try_to_stop_firmware(scsi_qla_host_t *vha)\n{\n\tint ret, retries;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (ha->flags.pci_channel_io_perm_failure)\n\t\treturn;\n\tif (!IS_FWI2_CAPABLE(ha))\n\t\treturn;\n\tif (!ha->fw_major_version)\n\t\treturn;\n\tif (!ha->flags.fw_started)\n\t\treturn;\n\n\tret = qla2x00_stop_firmware(vha);\n\tfor (retries = 5; ret != QLA_SUCCESS && ret != QLA_FUNCTION_TIMEOUT &&\n\t    ret != QLA_INVALID_COMMAND && retries ; retries--) {\n\t\tha->isp_ops->reset_chip(vha);\n\t\tif (ha->isp_ops->chip_diag(vha) != QLA_SUCCESS)\n\t\t\tcontinue;\n\t\tif (qla2x00_setup_chip(vha) != QLA_SUCCESS)\n\t\t\tcontinue;\n\t\tql_log(ql_log_info, vha, 0x8015,\n\t\t    \"Attempting retry of stop-firmware command.\\n\");\n\t\tret = qla2x00_stop_firmware(vha);\n\t}\n\n\tQLA_FW_STOPPED(ha);\n\tha->flags.fw_init_done = 0;\n}\n\nint\nqla24xx_configure_vhba(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tint rval2;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\n\tif (!vha->vp_idx)\n\t\treturn -EINVAL;\n\n\trval = qla2x00_fw_ready(base_vha);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\t\tqla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL);\n\t}\n\n\tvha->flags.management_server_logged_in = 0;\n\n\t \n\trval2 = ha->isp_ops->fabric_login(vha, NPH_SNS, 0xff, 0xff, 0xfc, mb,\n\t    BIT_1);\n\tif (rval2 != QLA_SUCCESS || mb[0] != MBS_COMMAND_COMPLETE) {\n\t\tif (rval2 == QLA_MEMORY_ALLOC_FAILED)\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0120,\n\t\t\t    \"Failed SNS login: loop_id=%x, rval2=%d\\n\",\n\t\t\t    NPH_SNS, rval2);\n\t\telse\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0103,\n\t\t\t    \"Failed SNS login: loop_id=%x mb[0]=%x mb[1]=%x \"\n\t\t\t    \"mb[2]=%x mb[6]=%x mb[7]=%x.\\n\",\n\t\t\t    NPH_SNS, mb[0], mb[1], mb[2], mb[6], mb[7]);\n\t\treturn (QLA_FUNCTION_FAILED);\n\t}\n\n\tatomic_set(&vha->loop_down_timer, 0);\n\tatomic_set(&vha->loop_state, LOOP_UP);\n\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\trval = qla2x00_loop_resync(base_vha);\n\n\treturn rval;\n}\n\n \n\nstatic LIST_HEAD(qla_cs84xx_list);\nstatic DEFINE_MUTEX(qla_cs84xx_mutex);\n\nstatic struct qla_chip_state_84xx *\nqla84xx_get_chip(struct scsi_qla_host *vha)\n{\n\tstruct qla_chip_state_84xx *cs84xx;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmutex_lock(&qla_cs84xx_mutex);\n\n\t \n\tlist_for_each_entry(cs84xx, &qla_cs84xx_list, list) {\n\t\tif (cs84xx->bus == ha->pdev->bus) {\n\t\t\tkref_get(&cs84xx->kref);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tcs84xx = kzalloc(sizeof(*cs84xx), GFP_KERNEL);\n\tif (!cs84xx)\n\t\tgoto done;\n\n\tkref_init(&cs84xx->kref);\n\tspin_lock_init(&cs84xx->access_lock);\n\tmutex_init(&cs84xx->fw_update_mutex);\n\tcs84xx->bus = ha->pdev->bus;\n\n\tlist_add_tail(&cs84xx->list, &qla_cs84xx_list);\ndone:\n\tmutex_unlock(&qla_cs84xx_mutex);\n\treturn cs84xx;\n}\n\nstatic void\n__qla84xx_chip_release(struct kref *kref)\n{\n\tstruct qla_chip_state_84xx *cs84xx =\n\t    container_of(kref, struct qla_chip_state_84xx, kref);\n\n\tmutex_lock(&qla_cs84xx_mutex);\n\tlist_del(&cs84xx->list);\n\tmutex_unlock(&qla_cs84xx_mutex);\n\tkfree(cs84xx);\n}\n\nvoid\nqla84xx_put_chip(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (ha->cs84xx)\n\t\tkref_put(&ha->cs84xx->kref, __qla84xx_chip_release);\n}\n\nstatic int\nqla84xx_init_chip(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint16_t status[2];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmutex_lock(&ha->cs84xx->fw_update_mutex);\n\n\trval = qla84xx_verify_chip(vha, status);\n\n\tmutex_unlock(&ha->cs84xx->fw_update_mutex);\n\n\treturn rval != QLA_SUCCESS || status[0] ? QLA_FUNCTION_FAILED :\n\t    QLA_SUCCESS;\n}\n\n \n\nint\nqla81xx_nvram_config(scsi_qla_host_t *vha)\n{\n\tint   rval;\n\tstruct init_cb_81xx *icb;\n\tstruct nvram_81xx *nv;\n\t__le32 *dptr;\n\tuint8_t  *dptr1, *dptr2;\n\tuint32_t chksum;\n\tuint16_t cnt;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t faddr;\n\tstruct active_regions active_regions = { };\n\n\trval = QLA_SUCCESS;\n\ticb = (struct init_cb_81xx *)ha->init_cb;\n\tnv = ha->nvram;\n\n\t \n\tha->nvram_size = sizeof(*nv);\n\tha->vpd_size = FA_NVRAM_VPD_SIZE;\n\tif (IS_P3P_TYPE(ha) || IS_QLA8031(ha))\n\t\tha->vpd_size = FA_VPD_SIZE_82XX;\n\n\tif (IS_QLA28XX(ha) || IS_QLA27XX(ha))\n\t\tqla28xx_get_aux_images(vha, &active_regions);\n\n\t \n\tha->vpd = ha->nvram + VPD_OFFSET;\n\n\tfaddr = ha->flt_region_vpd;\n\tif (IS_QLA28XX(ha)) {\n\t\tif (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)\n\t\t\tfaddr = ha->flt_region_vpd_sec;\n\t\tql_dbg(ql_dbg_init, vha, 0x0110,\n\t\t    \"Loading %s nvram image.\\n\",\n\t\t    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?\n\t\t    \"primary\" : \"secondary\");\n\t}\n\tha->isp_ops->read_optrom(vha, ha->vpd, faddr << 2, ha->vpd_size);\n\n\t \n\tfaddr = ha->flt_region_nvram;\n\tif (IS_QLA28XX(ha)) {\n\t\tif (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)\n\t\t\tfaddr = ha->flt_region_nvram_sec;\n\t}\n\tql_dbg(ql_dbg_init, vha, 0x0110,\n\t    \"Loading %s nvram image.\\n\",\n\t    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?\n\t    \"primary\" : \"secondary\");\n\tha->isp_ops->read_optrom(vha, ha->nvram, faddr << 2, ha->nvram_size);\n\n\tdptr = (__force __le32 *)nv;\n\tfor (cnt = 0, chksum = 0; cnt < ha->nvram_size >> 2; cnt++, dptr++)\n\t\tchksum += le32_to_cpu(*dptr);\n\n\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x0111,\n\t    \"Contents of NVRAM:\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0112,\n\t    nv, ha->nvram_size);\n\n\t \n\tif (chksum || memcmp(\"ISP \", nv->id, sizeof(nv->id)) ||\n\t    le16_to_cpu(nv->nvram_version) < ICB_VERSION) {\n\t\t \n\t\tql_log(ql_log_info, vha, 0x0073,\n\t\t    \"Inconsistent NVRAM checksum=%#x id=%.4s version=%#x.\\n\",\n\t\t    chksum, nv->id, le16_to_cpu(nv->nvram_version));\n\t\tql_dump_buffer(ql_dbg_init, vha, 0x0073, nv, sizeof(*nv));\n\t\tql_log(ql_log_info, vha, 0x0074,\n\t\t    \"Falling back to functioning (yet invalid -- WWPN) \"\n\t\t    \"defaults.\\n\");\n\n\t\t \n\t\tmemset(nv, 0, ha->nvram_size);\n\t\tnv->nvram_version = cpu_to_le16(ICB_VERSION);\n\t\tnv->version = cpu_to_le16(ICB_VERSION);\n\t\tnv->frame_payload_size = cpu_to_le16(2048);\n\t\tnv->execution_throttle = cpu_to_le16(0xFFFF);\n\t\tnv->exchange_count = cpu_to_le16(0);\n\t\tnv->port_name[0] = 0x21;\n\t\tnv->port_name[1] = 0x00 + ha->port_no + 1;\n\t\tnv->port_name[2] = 0x00;\n\t\tnv->port_name[3] = 0xe0;\n\t\tnv->port_name[4] = 0x8b;\n\t\tnv->port_name[5] = 0x1c;\n\t\tnv->port_name[6] = 0x55;\n\t\tnv->port_name[7] = 0x86;\n\t\tnv->node_name[0] = 0x20;\n\t\tnv->node_name[1] = 0x00;\n\t\tnv->node_name[2] = 0x00;\n\t\tnv->node_name[3] = 0xe0;\n\t\tnv->node_name[4] = 0x8b;\n\t\tnv->node_name[5] = 0x1c;\n\t\tnv->node_name[6] = 0x55;\n\t\tnv->node_name[7] = 0x86;\n\t\tnv->login_retry_count = cpu_to_le16(8);\n\t\tnv->interrupt_delay_timer = cpu_to_le16(0);\n\t\tnv->login_timeout = cpu_to_le16(0);\n\t\tnv->firmware_options_1 =\n\t\t    cpu_to_le32(BIT_14|BIT_13|BIT_2|BIT_1);\n\t\tnv->firmware_options_2 = cpu_to_le32(2 << 4);\n\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_12);\n\t\tnv->firmware_options_3 = cpu_to_le32(2 << 13);\n\t\tnv->host_p = cpu_to_le32(BIT_11|BIT_10);\n\t\tnv->efi_parameters = cpu_to_le32(0);\n\t\tnv->reset_delay = 5;\n\t\tnv->max_luns_per_target = cpu_to_le16(128);\n\t\tnv->port_down_retry_count = cpu_to_le16(30);\n\t\tnv->link_down_timeout = cpu_to_le16(180);\n\t\tnv->enode_mac[0] = 0x00;\n\t\tnv->enode_mac[1] = 0xC0;\n\t\tnv->enode_mac[2] = 0xDD;\n\t\tnv->enode_mac[3] = 0x04;\n\t\tnv->enode_mac[4] = 0x05;\n\t\tnv->enode_mac[5] = 0x06 + ha->port_no + 1;\n\n\t\trval = 1;\n\t}\n\n\tif (IS_T10_PI_CAPABLE(ha))\n\t\tnv->frame_payload_size &= cpu_to_le16(~7);\n\n\tqlt_81xx_config_nvram_stage1(vha, nv);\n\n\t \n\tmemset(icb, 0, ha->init_cb_size);\n\n\t \n\tdptr1 = (uint8_t *)icb;\n\tdptr2 = (uint8_t *)&nv->version;\n\tcnt = (uint8_t *)&icb->response_q_inpointer - (uint8_t *)&icb->version;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\n\ticb->login_retry_count = nv->login_retry_count;\n\n\t \n\tdptr1 = (uint8_t *)&icb->interrupt_delay_timer;\n\tdptr2 = (uint8_t *)&nv->interrupt_delay_timer;\n\tcnt = (uint8_t *)&icb->reserved_5 -\n\t    (uint8_t *)&icb->interrupt_delay_timer;\n\twhile (cnt--)\n\t\t*dptr1++ = *dptr2++;\n\n\tmemcpy(icb->enode_mac, nv->enode_mac, sizeof(icb->enode_mac));\n\t \n\tif (!memcmp(icb->enode_mac, \"\\0\\0\\0\\0\\0\\0\", sizeof(icb->enode_mac))) {\n\t\ticb->enode_mac[0] = 0x00;\n\t\ticb->enode_mac[1] = 0xC0;\n\t\ticb->enode_mac[2] = 0xDD;\n\t\ticb->enode_mac[3] = 0x04;\n\t\ticb->enode_mac[4] = 0x05;\n\t\ticb->enode_mac[5] = 0x06 + ha->port_no + 1;\n\t}\n\n\t \n\tmemcpy(ha->ex_init_cb, &nv->ex_version, sizeof(*ha->ex_init_cb));\n\tha->frame_payload_size = le16_to_cpu(icb->frame_payload_size);\n\t \n\tqla2x00_set_model_info(vha, nv->model_name, sizeof(nv->model_name),\n\t    \"QLE8XXX\");\n\n\tqlt_81xx_config_nvram_stage2(vha, icb);\n\n\t \n\tif (nv->host_p & cpu_to_le32(BIT_15)) {\n\t\tmemcpy(icb->node_name, nv->alternate_node_name, WWN_SIZE);\n\t\tmemcpy(icb->port_name, nv->alternate_port_name, WWN_SIZE);\n\t}\n\n\t \n\tif ((icb->firmware_options_1 & cpu_to_le32(BIT_14)) == 0) {\n\t\t \n\t\tmemcpy(icb->node_name, icb->port_name, WWN_SIZE);\n\t\ticb->node_name[0] &= 0xF0;\n\t}\n\n\tif (IS_QLA28XX(ha) || IS_QLA27XX(ha)) {\n\t\tif ((nv->enhanced_features & BIT_7) == 0)\n\t\t\tha->flags.scm_supported_a = 1;\n\t}\n\n\t \n\tha->flags.disable_risc_code_load = 0;\n\tha->flags.enable_lip_reset = 0;\n\tha->flags.enable_lip_full_login =\n\t    le32_to_cpu(nv->host_p) & BIT_10 ? 1 : 0;\n\tha->flags.enable_target_reset =\n\t    le32_to_cpu(nv->host_p) & BIT_11 ? 1 : 0;\n\tha->flags.enable_led_scheme = 0;\n\tha->flags.disable_serdes = le32_to_cpu(nv->host_p) & BIT_5 ? 1 : 0;\n\n\tha->operating_mode = (le32_to_cpu(icb->firmware_options_2) &\n\t    (BIT_6 | BIT_5 | BIT_4)) >> 4;\n\n\t \n\tha->serial0 = icb->port_name[5];\n\tha->serial1 = icb->port_name[6];\n\tha->serial2 = icb->port_name[7];\n\tmemcpy(vha->node_name, icb->node_name, WWN_SIZE);\n\tmemcpy(vha->port_name, icb->port_name, WWN_SIZE);\n\n\ticb->execution_throttle = cpu_to_le16(0xFFFF);\n\n\tha->retry_count = le16_to_cpu(nv->login_retry_count);\n\n\t \n\tif (le16_to_cpu(nv->login_timeout) < ql2xlogintimeout)\n\t\tnv->login_timeout = cpu_to_le16(ql2xlogintimeout);\n\tif (le16_to_cpu(nv->login_timeout) < 4)\n\t\tnv->login_timeout = cpu_to_le16(4);\n\tha->login_timeout = le16_to_cpu(nv->login_timeout);\n\n\t \n\tha->r_a_tov = 100;\n\n\tha->loop_reset_delay = nv->reset_delay;\n\n\t \n\tif (le16_to_cpu(nv->link_down_timeout) == 0) {\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - LOOP_DOWN_TIMEOUT);\n\t} else {\n\t\tha->link_down_timeout =\tle16_to_cpu(nv->link_down_timeout);\n\t\tha->loop_down_abort_time =\n\t\t    (LOOP_DOWN_TIME - ha->link_down_timeout);\n\t}\n\n\t \n\tha->port_down_retry_count = le16_to_cpu(nv->port_down_retry_count);\n\tif (qlport_down_retry)\n\t\tha->port_down_retry_count = qlport_down_retry;\n\n\t \n\tha->login_retry_count  = le16_to_cpu(nv->login_retry_count);\n\tif (ha->port_down_retry_count ==\n\t    le16_to_cpu(nv->port_down_retry_count) &&\n\t    ha->port_down_retry_count > 3)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\telse if (ha->port_down_retry_count > (int)ha->login_retry_count)\n\t\tha->login_retry_count = ha->port_down_retry_count;\n\tif (ql2xloginretrycount)\n\t\tha->login_retry_count = ql2xloginretrycount;\n\n\t \n\tif (!vha->hw->flags.msix_enabled &&\n\t    (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)))\n\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_22);\n\n\t \n\tif (!vha->flags.init_done) {\n\t\tha->zio_mode = le32_to_cpu(icb->firmware_options_2) &\n\t\t    (BIT_3 | BIT_2 | BIT_1 | BIT_0);\n\t\tha->zio_timer = le16_to_cpu(icb->interrupt_delay_timer) ?\n\t\t    le16_to_cpu(icb->interrupt_delay_timer) : 2;\n\t}\n\ticb->firmware_options_2 &= cpu_to_le32(\n\t    ~(BIT_3 | BIT_2 | BIT_1 | BIT_0));\n\tvha->flags.process_response_queue = 0;\n\tif (ha->zio_mode != QLA_ZIO_DISABLED) {\n\t\tha->zio_mode = QLA_ZIO_MODE_6;\n\n\t\tql_log(ql_log_info, vha, 0x0075,\n\t\t    \"ZIO mode %d enabled; timer delay (%d us).\\n\",\n\t\t    ha->zio_mode,\n\t\t    ha->zio_timer * 100);\n\n\t\ticb->firmware_options_2 |= cpu_to_le32(\n\t\t    (uint32_t)ha->zio_mode);\n\t\ticb->interrupt_delay_timer = cpu_to_le16(ha->zio_timer);\n\t\tvha->flags.process_response_queue = 1;\n\t}\n\n\t  \n\ticb->firmware_options_3 |= cpu_to_le32(BIT_0);\n\n\t \n\ticb->firmware_options_3 |= cpu_to_le32(BIT_8);\n\n\t \n\tha->fc4_type_priority = qla2xxx_get_fc4_priority(vha);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0076,\n\t\t    \"NVRAM configuration failed.\\n\");\n\t}\n\treturn (rval);\n}\n\nint\nqla82xx_restart_isp(scsi_qla_host_t *vha)\n{\n\tint status, rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *vp, *tvp;\n\tunsigned long flags;\n\n\tstatus = qla2x00_init_rings(vha);\n\tif (!status) {\n\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\t\tha->flags.chip_reset_done = 1;\n\n\t\tstatus = qla2x00_fw_ready(vha);\n\t\tif (!status) {\n\t\t\t \n\t\t\tqla2x00_marker(vha, ha->base_qpair, 0, 0, MK_SYNC_ALL);\n\t\t\tvha->flags.online = 1;\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t}\n\n\t\t \n\t\tif ((vha->device_flags & DFLG_NO_CABLE))\n\t\t\tstatus = 0;\n\t}\n\n\tif (!status) {\n\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\n\t\tif (!atomic_read(&vha->loop_down_timer)) {\n\t\t\t \n\t\t\tvha->marker_needed = 1;\n\t\t}\n\n\t\tha->isp_ops->enable_intrs(ha);\n\n\t\tha->isp_abort_cnt = 0;\n\t\tclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\n\t\t \n\t\tstatus = qla82xx_check_md_needed(vha);\n\n\t\tif (ha->fce) {\n\t\t\tha->flags.fce_enabled = 1;\n\t\t\tmemset(ha->fce, 0,\n\t\t\t    fce_calc_size(ha->fce_bufs));\n\t\t\trval = qla2x00_enable_fce_trace(vha,\n\t\t\t    ha->fce_dma, ha->fce_bufs, ha->fce_mb,\n\t\t\t    &ha->fce_bufs);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x8001,\n\t\t\t\t    \"Unable to reinitialize FCE (%d).\\n\",\n\t\t\t\t    rval);\n\t\t\t\tha->flags.fce_enabled = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (ha->eft) {\n\t\t\tmemset(ha->eft, 0, EFT_SIZE);\n\t\t\trval = qla2x00_enable_eft_trace(vha,\n\t\t\t    ha->eft_dma, EFT_NUM_BUFFERS);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x8010,\n\t\t\t\t    \"Unable to reinitialize EFT (%d).\\n\",\n\t\t\t\t    rval);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!status) {\n\t\tql_dbg(ql_dbg_taskm, vha, 0x8011,\n\t\t    \"qla82xx_restart_isp succeeded.\\n\");\n\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tlist_for_each_entry_safe(vp, tvp, &ha->vp_list, list) {\n\t\t\tif (vp->vp_idx) {\n\t\t\t\tatomic_inc(&vp->vref_count);\n\t\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t\t\t\tqla2x00_vp_abort_isp(vp);\n\n\t\t\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\t\t\tatomic_dec(&vp->vref_count);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t} else {\n\t\tql_log(ql_log_warn, vha, 0x8016,\n\t\t    \"qla82xx_restart_isp **** FAILED ****.\\n\");\n\t}\n\n\treturn status;\n}\n\n \nstatic int\nqla24xx_get_fcp_prio(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint i, entries;\n\tuint8_t pid_match, wwn_match;\n\tint priority;\n\tuint32_t pid1, pid2;\n\tuint64_t wwn1, wwn2;\n\tstruct qla_fcp_prio_entry *pri_entry;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->fcp_prio_cfg || !ha->flags.fcp_prio_enabled)\n\t\treturn -1;\n\n\tpriority = -1;\n\tentries = ha->fcp_prio_cfg->num_entries;\n\tpri_entry = &ha->fcp_prio_cfg->entry[0];\n\n\tfor (i = 0; i < entries; i++) {\n\t\tpid_match = wwn_match = 0;\n\n\t\tif (!(pri_entry->flags & FCP_PRIO_ENTRY_VALID)) {\n\t\t\tpri_entry++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_SPID_VALID) {\n\t\t\tpid1 = pri_entry->src_pid & INVALID_PORT_ID;\n\t\t\tpid2 = vha->d_id.b24 & INVALID_PORT_ID;\n\t\t\tif (pid1 == INVALID_PORT_ID)\n\t\t\t\tpid_match++;\n\t\t\telse if (pid1 == pid2)\n\t\t\t\tpid_match++;\n\t\t}\n\n\t\t \n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_DPID_VALID) {\n\t\t\tpid1 = pri_entry->dst_pid & INVALID_PORT_ID;\n\t\t\tpid2 = fcport->d_id.b24 & INVALID_PORT_ID;\n\t\t\tif (pid1 == INVALID_PORT_ID)\n\t\t\t\tpid_match++;\n\t\t\telse if (pid1 == pid2)\n\t\t\t\tpid_match++;\n\t\t}\n\n\t\t \n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_SWWN_VALID) {\n\t\t\twwn1 = wwn_to_u64(vha->port_name);\n\t\t\twwn2 = wwn_to_u64(pri_entry->src_wwpn);\n\t\t\tif (wwn2 == (uint64_t)-1)\n\t\t\t\twwn_match++;\n\t\t\telse if (wwn1 == wwn2)\n\t\t\t\twwn_match++;\n\t\t}\n\n\t\t \n\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_DWWN_VALID) {\n\t\t\twwn1 = wwn_to_u64(fcport->port_name);\n\t\t\twwn2 = wwn_to_u64(pri_entry->dst_wwpn);\n\t\t\tif (wwn2 == (uint64_t)-1)\n\t\t\t\twwn_match++;\n\t\t\telse if (wwn1 == wwn2)\n\t\t\t\twwn_match++;\n\t\t}\n\n\t\tif (pid_match == 2 || wwn_match == 2) {\n\t\t\t \n\t\t\tif (pri_entry->flags & FCP_PRIO_ENTRY_TAG_VALID)\n\t\t\t\tpriority = pri_entry->tag;\n\t\t\tbreak;\n\t\t}\n\n\t\tpri_entry++;\n\t}\n\n\treturn priority;\n}\n\n \nint\nqla24xx_update_fcport_fcp_prio(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint ret;\n\tint priority;\n\tuint16_t mb[5];\n\n\tif (fcport->port_type != FCT_TARGET ||\n\t    fcport->loop_id == FC_NO_LOOP_ID)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tpriority = qla24xx_get_fcp_prio(vha, fcport);\n\tif (priority < 0)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tif (IS_P3P_TYPE(vha->hw)) {\n\t\tfcport->fcp_prio = priority & 0xf;\n\t\treturn QLA_SUCCESS;\n\t}\n\n\tret = qla24xx_set_fcp_prio(vha, fcport->loop_id, priority, mb);\n\tif (ret == QLA_SUCCESS) {\n\t\tif (fcport->fcp_prio != priority)\n\t\t\tql_dbg(ql_dbg_user, vha, 0x709e,\n\t\t\t    \"Updated FCP_CMND priority - value=%d loop_id=%d \"\n\t\t\t    \"port_id=%02x%02x%02x.\\n\", priority,\n\t\t\t    fcport->loop_id, fcport->d_id.b.domain,\n\t\t\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\t\tfcport->fcp_prio = priority & 0xf;\n\t} else\n\t\tql_dbg(ql_dbg_user, vha, 0x704f,\n\t\t    \"Unable to update FCP_CMND priority - ret=0x%x for \"\n\t\t    \"loop_id=%d port_id=%02x%02x%02x.\\n\", ret, fcport->loop_id,\n\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t    fcport->d_id.b.al_pa);\n\treturn  ret;\n}\n\n \nint\nqla24xx_update_all_fcp_prio(scsi_qla_host_t *vha)\n{\n\tint ret;\n\tfc_port_t *fcport;\n\n\tret = QLA_FUNCTION_FAILED;\n\t \n\tlist_for_each_entry(fcport, &vha->vp_fcports, list)\n\t\tret = qla24xx_update_fcport_fcp_prio(vha, fcport);\n\n\treturn ret;\n}\n\nstruct qla_qpair *qla2xxx_create_qpair(struct scsi_qla_host *vha, int qos,\n\tint vp_idx, bool startqp)\n{\n\tint rsp_id = 0;\n\tint  req_id = 0;\n\tint i;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t qpair_id = 0;\n\tstruct qla_qpair *qpair = NULL;\n\tstruct qla_msix_entry *msix;\n\n\tif (!(ha->fw_attributes & BIT_6) || !ha->flags.msix_enabled) {\n\t\tql_log(ql_log_warn, vha, 0x00181,\n\t\t    \"FW/Driver is not multi-queue capable.\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (ql2xmqsupport || ql2xnvmeenable) {\n\t\tqpair = kzalloc(sizeof(struct qla_qpair), GFP_KERNEL);\n\t\tif (qpair == NULL) {\n\t\t\tql_log(ql_log_warn, vha, 0x0182,\n\t\t\t    \"Failed to allocate memory for queue pair.\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tqpair->hw = vha->hw;\n\t\tqpair->vha = vha;\n\t\tqpair->qp_lock_ptr = &qpair->qp_lock;\n\t\tspin_lock_init(&qpair->qp_lock);\n\t\tqpair->use_shadow_reg = IS_SHADOW_REG_CAPABLE(ha) ? 1 : 0;\n\n\t\t \n\t\tmutex_lock(&ha->mq_lock);\n\t\tqpair_id = find_first_zero_bit(ha->qpair_qid_map, ha->max_qpairs);\n\t\tif (ha->num_qpairs >= ha->max_qpairs) {\n\t\t\tmutex_unlock(&ha->mq_lock);\n\t\t\tql_log(ql_log_warn, vha, 0x0183,\n\t\t\t    \"No resources to create additional q pair.\\n\");\n\t\t\tgoto fail_qid_map;\n\t\t}\n\t\tha->num_qpairs++;\n\t\tset_bit(qpair_id, ha->qpair_qid_map);\n\t\tha->queue_pair_map[qpair_id] = qpair;\n\t\tqpair->id = qpair_id;\n\t\tqpair->vp_idx = vp_idx;\n\t\tqpair->fw_started = ha->flags.fw_started;\n\t\tINIT_LIST_HEAD(&qpair->hints_list);\n\t\tINIT_LIST_HEAD(&qpair->dsd_list);\n\t\tqpair->chip_reset = ha->base_qpair->chip_reset;\n\t\tqpair->enable_class_2 = ha->base_qpair->enable_class_2;\n\t\tqpair->enable_explicit_conf =\n\t\t    ha->base_qpair->enable_explicit_conf;\n\n\t\tfor (i = 0; i < ha->msix_count; i++) {\n\t\t\tmsix = &ha->msix_entries[i];\n\t\t\tif (msix->in_use)\n\t\t\t\tcontinue;\n\t\t\tqpair->msix = msix;\n\t\t\tql_dbg(ql_dbg_multiq, vha, 0xc00f,\n\t\t\t    \"Vector %x selected for qpair\\n\", msix->vector);\n\t\t\tbreak;\n\t\t}\n\t\tif (!qpair->msix) {\n\t\t\tql_log(ql_log_warn, vha, 0x0184,\n\t\t\t    \"Out of MSI-X vectors!.\\n\");\n\t\t\tgoto fail_msix;\n\t\t}\n\n\t\tqpair->msix->in_use = 1;\n\t\tlist_add_tail(&qpair->qp_list_elem, &vha->qp_list);\n\t\tqpair->pdev = ha->pdev;\n\t\tif (IS_QLA27XX(ha) || IS_QLA83XX(ha) || IS_QLA28XX(ha))\n\t\t\tqpair->reqq_start_iocbs = qla_83xx_start_iocbs;\n\n\t\tmutex_unlock(&ha->mq_lock);\n\n\t\t \n\t\trsp_id = qla25xx_create_rsp_que(ha, 0, 0, 0, qpair, startqp);\n\t\tif (!rsp_id) {\n\t\t\tql_log(ql_log_warn, vha, 0x0185,\n\t\t\t    \"Failed to create response queue.\\n\");\n\t\t\tgoto fail_rsp;\n\t\t}\n\n\t\tqpair->rsp = ha->rsp_q_map[rsp_id];\n\n\t\t \n\t\treq_id = qla25xx_create_req_que(ha, 0, vp_idx, 0, rsp_id, qos,\n\t\t    startqp);\n\t\tif (!req_id) {\n\t\t\tql_log(ql_log_warn, vha, 0x0186,\n\t\t\t    \"Failed to create request queue.\\n\");\n\t\t\tgoto fail_req;\n\t\t}\n\n\t\tqpair->req = ha->req_q_map[req_id];\n\t\tqpair->rsp->req = qpair->req;\n\t\tqpair->rsp->qpair = qpair;\n\n\t\tif (!qpair->cpu_mapped)\n\t\t\tqla_cpu_update(qpair, raw_smp_processor_id());\n\n\t\tif (IS_T10_PI_CAPABLE(ha) && ql2xenabledif) {\n\t\t\tif (ha->fw_attributes & BIT_4)\n\t\t\t\tqpair->difdix_supported = 1;\n\t\t}\n\n\t\tqpair->srb_mempool = mempool_create_slab_pool(SRB_MIN_REQ, srb_cachep);\n\t\tif (!qpair->srb_mempool) {\n\t\t\tql_log(ql_log_warn, vha, 0xd036,\n\t\t\t    \"Failed to create srb mempool for qpair %d\\n\",\n\t\t\t    qpair->id);\n\t\t\tgoto fail_mempool;\n\t\t}\n\n\t\tif (qla_create_buf_pool(vha, qpair)) {\n\t\t\tql_log(ql_log_warn, vha, 0xd036,\n\t\t\t    \"Failed to initialize buf pool for qpair %d\\n\",\n\t\t\t    qpair->id);\n\t\t\tgoto fail_bufpool;\n\t\t}\n\n\t\t \n\t\tqpair->online = 1;\n\n\t\tif (!vha->flags.qpairs_available)\n\t\t\tvha->flags.qpairs_available = 1;\n\n\t\tql_dbg(ql_dbg_multiq, vha, 0xc00d,\n\t\t    \"Request/Response queue pair created, id %d\\n\",\n\t\t    qpair->id);\n\t\tql_dbg(ql_dbg_init, vha, 0x0187,\n\t\t    \"Request/Response queue pair created, id %d\\n\",\n\t\t    qpair->id);\n\t}\n\treturn qpair;\n\nfail_bufpool:\n\tmempool_destroy(qpair->srb_mempool);\nfail_mempool:\n\tqla25xx_delete_req_que(vha, qpair->req);\nfail_req:\n\tqla25xx_delete_rsp_que(vha, qpair->rsp);\nfail_rsp:\n\tmutex_lock(&ha->mq_lock);\n\tqpair->msix->in_use = 0;\n\tlist_del(&qpair->qp_list_elem);\n\tif (list_empty(&vha->qp_list))\n\t\tvha->flags.qpairs_available = 0;\nfail_msix:\n\tha->queue_pair_map[qpair_id] = NULL;\n\tclear_bit(qpair_id, ha->qpair_qid_map);\n\tha->num_qpairs--;\n\tmutex_unlock(&ha->mq_lock);\nfail_qid_map:\n\tkfree(qpair);\n\treturn NULL;\n}\n\nint qla2xxx_delete_qpair(struct scsi_qla_host *vha, struct qla_qpair *qpair)\n{\n\tint ret = QLA_FUNCTION_FAILED;\n\tstruct qla_hw_data *ha = qpair->hw;\n\n\tqpair->delete_in_progress = 1;\n\n\tqla_free_buf_pool(qpair);\n\n\tret = qla25xx_delete_req_que(vha, qpair->req);\n\tif (ret != QLA_SUCCESS)\n\t\tgoto fail;\n\n\tret = qla25xx_delete_rsp_que(vha, qpair->rsp);\n\tif (ret != QLA_SUCCESS)\n\t\tgoto fail;\n\n\tif (!list_empty(&qpair->dsd_list)) {\n\t\tstruct dsd_dma *dsd_ptr, *tdsd_ptr;\n\n\t\t \n\t\tlist_for_each_entry_safe(dsd_ptr, tdsd_ptr,\n\t\t\t\t\t &qpair->dsd_list, list) {\n\t\t\tdma_pool_free(ha->dl_dma_pool, dsd_ptr->dsd_addr,\n\t\t\t\t      dsd_ptr->dsd_list_dma);\n\t\t\tlist_del(&dsd_ptr->list);\n\t\t\tkfree(dsd_ptr);\n\t\t}\n\t}\n\n\tmutex_lock(&ha->mq_lock);\n\tha->queue_pair_map[qpair->id] = NULL;\n\tclear_bit(qpair->id, ha->qpair_qid_map);\n\tha->num_qpairs--;\n\tlist_del(&qpair->qp_list_elem);\n\tif (list_empty(&vha->qp_list)) {\n\t\tvha->flags.qpairs_available = 0;\n\t\tvha->flags.qpairs_req_created = 0;\n\t\tvha->flags.qpairs_rsp_created = 0;\n\t}\n\tmempool_destroy(qpair->srb_mempool);\n\tkfree(qpair);\n\tmutex_unlock(&ha->mq_lock);\n\n\treturn QLA_SUCCESS;\nfail:\n\treturn ret;\n}\n\nuint64_t\nqla2x00_count_set_bits(uint32_t num)\n{\n\t \n\tu64 count = 0;\n\n\twhile (num) {\n\t\tnum &= (num - 1);\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nuint64_t\nqla2x00_get_num_tgts(scsi_qla_host_t *vha)\n{\n\tfc_port_t *f, *tf;\n\tu64 count = 0;\n\n\tf = NULL;\n\ttf = NULL;\n\n\tlist_for_each_entry_safe(f, tf, &vha->vp_fcports, list) {\n\t\tif (f->port_type != FCT_TARGET)\n\t\t\tcontinue;\n\t\tcount++;\n\t}\n\treturn count;\n}\n\nint qla2xxx_reset_stats(struct Scsi_Host *host, u32 flags)\n{\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tfc_port_t *fcport = NULL;\n\tunsigned long int_flags;\n\n\tif (flags & QLA2XX_HW_ERROR)\n\t\tvha->hw_err_cnt = 0;\n\tif (flags & QLA2XX_SHT_LNK_DWN)\n\t\tvha->short_link_down_cnt = 0;\n\tif (flags & QLA2XX_INT_ERR)\n\t\tvha->interface_err_cnt = 0;\n\tif (flags & QLA2XX_CMD_TIMEOUT)\n\t\tvha->cmd_timeout_cnt = 0;\n\tif (flags & QLA2XX_RESET_CMD_ERR)\n\t\tvha->reset_cmd_err_cnt = 0;\n\tif (flags & QLA2XX_TGT_SHT_LNK_DOWN) {\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, int_flags);\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tfcport->tgt_short_link_down_cnt = 0;\n\t\t\tfcport->tgt_link_down_time = QLA2XX_MAX_LINK_DOWN_TIME;\n\t\t}\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, int_flags);\n\t}\n\tvha->link_down_time = QLA2XX_MAX_LINK_DOWN_TIME;\n\treturn 0;\n}\n\nint qla2xxx_start_stats(struct Scsi_Host *host, u32 flags)\n{\n\treturn qla2xxx_reset_stats(host, flags);\n}\n\nint qla2xxx_stop_stats(struct Scsi_Host *host, u32 flags)\n{\n\treturn qla2xxx_reset_stats(host, flags);\n}\n\nint qla2xxx_get_ini_stats(struct Scsi_Host *host, u32 flags,\n\t\t\t  void *data, u64 size)\n{\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tstruct ql_vnd_host_stats_resp *resp = (struct ql_vnd_host_stats_resp *)data;\n\tstruct ql_vnd_stats *rsp_data = &resp->stats;\n\tu64 ini_entry_count = 0;\n\tu64 i = 0;\n\tu64 entry_count = 0;\n\tu64 num_tgt = 0;\n\tu32 tmp_stat_type = 0;\n\tfc_port_t *fcport = NULL;\n\tunsigned long int_flags;\n\n\t \n\ttmp_stat_type = flags;\n\n\tif (tmp_stat_type & BIT_17) {\n\t\tnum_tgt = qla2x00_get_num_tgts(vha);\n\t\t \n\t\ttmp_stat_type &= ~(1 << 17);\n\t}\n\tini_entry_count = qla2x00_count_set_bits(tmp_stat_type);\n\n\tentry_count = ini_entry_count + num_tgt;\n\n\trsp_data->entry_count = entry_count;\n\n\ti = 0;\n\tif (flags & QLA2XX_HW_ERROR) {\n\t\trsp_data->entry[i].stat_type = QLA2XX_HW_ERROR;\n\t\trsp_data->entry[i].tgt_num = 0x0;\n\t\trsp_data->entry[i].cnt = vha->hw_err_cnt;\n\t\ti++;\n\t}\n\n\tif (flags & QLA2XX_SHT_LNK_DWN) {\n\t\trsp_data->entry[i].stat_type = QLA2XX_SHT_LNK_DWN;\n\t\trsp_data->entry[i].tgt_num = 0x0;\n\t\trsp_data->entry[i].cnt = vha->short_link_down_cnt;\n\t\ti++;\n\t}\n\n\tif (flags & QLA2XX_INT_ERR) {\n\t\trsp_data->entry[i].stat_type = QLA2XX_INT_ERR;\n\t\trsp_data->entry[i].tgt_num = 0x0;\n\t\trsp_data->entry[i].cnt = vha->interface_err_cnt;\n\t\ti++;\n\t}\n\n\tif (flags & QLA2XX_CMD_TIMEOUT) {\n\t\trsp_data->entry[i].stat_type = QLA2XX_CMD_TIMEOUT;\n\t\trsp_data->entry[i].tgt_num = 0x0;\n\t\trsp_data->entry[i].cnt = vha->cmd_timeout_cnt;\n\t\ti++;\n\t}\n\n\tif (flags & QLA2XX_RESET_CMD_ERR) {\n\t\trsp_data->entry[i].stat_type = QLA2XX_RESET_CMD_ERR;\n\t\trsp_data->entry[i].tgt_num = 0x0;\n\t\trsp_data->entry[i].cnt = vha->reset_cmd_err_cnt;\n\t\ti++;\n\t}\n\n\t \n\tif (flags & QLA2XX_TGT_SHT_LNK_DOWN) {\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, int_flags);\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (fcport->port_type != FCT_TARGET)\n\t\t\t\tcontinue;\n\t\t\tif (!fcport->rport)\n\t\t\t\tcontinue;\n\t\t\trsp_data->entry[i].stat_type = QLA2XX_TGT_SHT_LNK_DOWN;\n\t\t\trsp_data->entry[i].tgt_num = fcport->rport->number;\n\t\t\trsp_data->entry[i].cnt = fcport->tgt_short_link_down_cnt;\n\t\t\ti++;\n\t\t}\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, int_flags);\n\t}\n\tresp->status = EXT_STATUS_OK;\n\n\treturn 0;\n}\n\nint qla2xxx_get_tgt_stats(struct Scsi_Host *host, u32 flags,\n\t\t\t  struct fc_rport *rport, void *data, u64 size)\n{\n\tstruct ql_vnd_tgt_stats_resp *tgt_data = data;\n\tfc_port_t *fcport = *(fc_port_t **)rport->dd_data;\n\n\ttgt_data->status = 0;\n\ttgt_data->stats.entry_count = 1;\n\ttgt_data->stats.entry[0].stat_type = flags;\n\ttgt_data->stats.entry[0].tgt_num = rport->number;\n\ttgt_data->stats.entry[0].cnt = fcport->tgt_short_link_down_cnt;\n\n\treturn 0;\n}\n\nint qla2xxx_disable_port(struct Scsi_Host *host)\n{\n\tscsi_qla_host_t *vha = shost_priv(host);\n\n\tvha->hw->flags.port_isolated = 1;\n\n\tif (qla2x00_isp_reg_stat(vha->hw)) {\n\t\tql_log(ql_log_info, vha, 0x9006,\n\t\t    \"PCI/Register disconnect, exiting.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t\treturn FAILED;\n\t}\n\tif (qla2x00_chip_is_down(vha))\n\t\treturn 0;\n\n\tif (vha->flags.online) {\n\t\tqla2x00_abort_isp_cleanup(vha);\n\t\tqla2x00_wait_for_sess_deletion(vha);\n\t}\n\n\treturn 0;\n}\n\nint qla2xxx_enable_port(struct Scsi_Host *host)\n{\n\tscsi_qla_host_t *vha = shost_priv(host);\n\n\tif (qla2x00_isp_reg_stat(vha->hw)) {\n\t\tql_log(ql_log_info, vha, 0x9001,\n\t\t    \"PCI/Register disconnect, exiting.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t\treturn FAILED;\n\t}\n\n\tvha->hw->flags.port_isolated = 0;\n\t \n\tvha->flags.online = 1;\n\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\tqla2xxx_wake_dpc(vha);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}