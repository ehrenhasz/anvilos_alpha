{
  "module_name": "qla_gs.c",
  "hash_id": "dfe6020d3980a36102e5ea718ad70e5a3085310c943e5600892fa3517f4eaf1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_gs.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_target.h\"\n#include <linux/utsname.h>\n\nstatic int qla2x00_sns_ga_nxt(scsi_qla_host_t *, fc_port_t *);\nstatic int qla2x00_sns_gid_pt(scsi_qla_host_t *, sw_info_t *);\nstatic int qla2x00_sns_gpn_id(scsi_qla_host_t *, sw_info_t *);\nstatic int qla2x00_sns_gnn_id(scsi_qla_host_t *, sw_info_t *);\nstatic int qla2x00_sns_rft_id(scsi_qla_host_t *);\nstatic int qla2x00_sns_rnn_id(scsi_qla_host_t *);\nstatic int qla_async_rftid(scsi_qla_host_t *, port_id_t *);\nstatic int qla_async_rffid(scsi_qla_host_t *, port_id_t *, u8, u8);\nstatic int qla_async_rnnid(scsi_qla_host_t *, port_id_t *, u8*);\nstatic int qla_async_rsnn_nn(scsi_qla_host_t *);\n\n\n\n \nvoid *\nqla2x00_prep_ms_iocb(scsi_qla_host_t *vha, struct ct_arg *arg)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tms_iocb_entry_t *ms_pkt;\n\n\tms_pkt = (ms_iocb_entry_t *)arg->iocb;\n\tmemset(ms_pkt, 0, sizeof(ms_iocb_entry_t));\n\n\tms_pkt->entry_type = MS_IOCB_TYPE;\n\tms_pkt->entry_count = 1;\n\tSET_TARGET_ID(ha, ms_pkt->loop_id, SIMPLE_NAME_SERVER);\n\tms_pkt->control_flags = cpu_to_le16(CF_READ | CF_HEAD_TAG);\n\tms_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\n\tms_pkt->cmd_dsd_count = cpu_to_le16(1);\n\tms_pkt->total_dsd_count = cpu_to_le16(2);\n\tms_pkt->rsp_bytecount = cpu_to_le32(arg->rsp_size);\n\tms_pkt->req_bytecount = cpu_to_le32(arg->req_size);\n\n\tput_unaligned_le64(arg->req_dma, &ms_pkt->req_dsd.address);\n\tms_pkt->req_dsd.length = ms_pkt->req_bytecount;\n\n\tput_unaligned_le64(arg->rsp_dma, &ms_pkt->rsp_dsd.address);\n\tms_pkt->rsp_dsd.length = ms_pkt->rsp_bytecount;\n\n\tvha->qla_stats.control_requests++;\n\n\treturn (ms_pkt);\n}\n\n \nvoid *\nqla24xx_prep_ms_iocb(scsi_qla_host_t *vha, struct ct_arg *arg)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct ct_entry_24xx *ct_pkt;\n\n\tct_pkt = (struct ct_entry_24xx *)arg->iocb;\n\tmemset(ct_pkt, 0, sizeof(struct ct_entry_24xx));\n\n\tct_pkt->entry_type = CT_IOCB_TYPE;\n\tct_pkt->entry_count = 1;\n\tct_pkt->nport_handle = cpu_to_le16(arg->nport_handle);\n\tct_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\n\tct_pkt->cmd_dsd_count = cpu_to_le16(1);\n\tct_pkt->rsp_dsd_count = cpu_to_le16(1);\n\tct_pkt->rsp_byte_count = cpu_to_le32(arg->rsp_size);\n\tct_pkt->cmd_byte_count = cpu_to_le32(arg->req_size);\n\n\tput_unaligned_le64(arg->req_dma, &ct_pkt->dsd[0].address);\n\tct_pkt->dsd[0].length = ct_pkt->cmd_byte_count;\n\n\tput_unaligned_le64(arg->rsp_dma, &ct_pkt->dsd[1].address);\n\tct_pkt->dsd[1].length = ct_pkt->rsp_byte_count;\n\tct_pkt->vp_index = vha->vp_idx;\n\n\tvha->qla_stats.control_requests++;\n\n\treturn (ct_pkt);\n}\n\n \nstatic inline struct ct_sns_req *\nqla2x00_prep_ct_req(struct ct_sns_pkt *p, uint16_t cmd, uint16_t rsp_size)\n{\n\tmemset(p, 0, sizeof(struct ct_sns_pkt));\n\n\tp->p.req.header.revision = 0x01;\n\tp->p.req.header.gs_type = 0xFC;\n\tp->p.req.header.gs_subtype = 0x02;\n\tp->p.req.command = cpu_to_be16(cmd);\n\tp->p.req.max_rsp_size = cpu_to_be16((rsp_size - 16) / 4);\n\n\treturn &p->p.req;\n}\n\nint\nqla2x00_chk_ms_status(scsi_qla_host_t *vha, ms_iocb_entry_t *ms_pkt,\n    struct ct_sns_rsp *ct_rsp, const char *routine)\n{\n\tint rval;\n\tuint16_t comp_status;\n\tstruct qla_hw_data *ha = vha->hw;\n\tbool lid_is_sns = false;\n\n\trval = QLA_FUNCTION_FAILED;\n\tif (ms_pkt->entry_status != 0) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2031,\n\t\t    \"%s failed, error status (%x) on port_id: %02x%02x%02x.\\n\",\n\t\t    routine, ms_pkt->entry_status, vha->d_id.b.domain,\n\t\t    vha->d_id.b.area, vha->d_id.b.al_pa);\n\t} else {\n\t\tif (IS_FWI2_CAPABLE(ha))\n\t\t\tcomp_status = le16_to_cpu(\n\t\t\t    ((struct ct_entry_24xx *)ms_pkt)->comp_status);\n\t\telse\n\t\t\tcomp_status = le16_to_cpu(ms_pkt->status);\n\t\tswitch (comp_status) {\n\t\tcase CS_COMPLETE:\n\t\tcase CS_DATA_UNDERRUN:\n\t\tcase CS_DATA_OVERRUN:\t\t \n\t\t\tif (ct_rsp->header.response !=\n\t\t\t    cpu_to_be16(CT_ACCEPT_RESPONSE)) {\n\t\t\t\tql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x2077,\n\t\t\t\t    \"%s failed rejected request on port_id: %02x%02x%02x Completion status 0x%x, response 0x%x\\n\",\n\t\t\t\t    routine, vha->d_id.b.domain,\n\t\t\t\t    vha->d_id.b.area, vha->d_id.b.al_pa,\n\t\t\t\t    comp_status, ct_rsp->header.response);\n\t\t\t\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha,\n\t\t\t\t    0x2078, ct_rsp,\n\t\t\t\t    offsetof(typeof(*ct_rsp), rsp));\n\t\t\t\trval = QLA_INVALID_COMMAND;\n\t\t\t} else\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\tbreak;\n\t\tcase CS_PORT_LOGGED_OUT:\n\t\t\tif (IS_FWI2_CAPABLE(ha)) {\n\t\t\t\tif (le16_to_cpu(ms_pkt->loop_id.extended) ==\n\t\t\t\t    NPH_SNS)\n\t\t\t\t\tlid_is_sns = true;\n\t\t\t} else {\n\t\t\t\tif (le16_to_cpu(ms_pkt->loop_id.extended) ==\n\t\t\t\t    SIMPLE_NAME_SERVER)\n\t\t\t\t\tlid_is_sns = true;\n\t\t\t}\n\t\t\tif (lid_is_sns) {\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x502b,\n\t\t\t\t\t\"%s failed, Name server has logged out\",\n\t\t\t\t\troutine);\n\t\t\t\trval = QLA_NOT_LOGGED_IN;\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CS_TIMEOUT:\n\t\t\trval = QLA_FUNCTION_TIMEOUT;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2033,\n\t\t\t    \"%s failed, completion status (%x) on port_id: \"\n\t\t\t    \"%02x%02x%02x.\\n\", routine, comp_status,\n\t\t\t    vha->d_id.b.domain, vha->d_id.b.area,\n\t\t\t    vha->d_id.b.al_pa);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rval;\n}\n\n \nint\nqla2x00_ga_nxt(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint\t\trval;\n\n\tms_iocb_entry_t\t*ms_pkt;\n\tstruct ct_sns_req\t*ct_req;\n\tstruct ct_sns_rsp\t*ct_rsp;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct ct_arg arg;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn qla2x00_sns_ga_nxt(vha, fcport);\n\n\targ.iocb = ha->ms_iocb;\n\targ.req_dma = ha->ct_sns_dma;\n\targ.rsp_dma = ha->ct_sns_dma;\n\targ.req_size = GA_NXT_REQ_SIZE;\n\targ.rsp_size = GA_NXT_RSP_SIZE;\n\targ.nport_handle = NPH_SNS;\n\n\t \n\t \n\tms_pkt = ha->isp_ops->prep_ms_iocb(vha, &arg);\n\n\t \n\tct_req = qla2x00_prep_ct_req(ha->ct_sns, GA_NXT_CMD,\n\t    GA_NXT_RSP_SIZE);\n\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t \n\tct_req->req.port_id.port_id = port_id_to_be_id(fcport->d_id);\n\n\t \n\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t    sizeof(ms_iocb_entry_t));\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x2062,\n\t\t    \"GA_NXT issue IOCB failed (%d).\\n\", rval);\n\t} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, \"GA_NXT\") !=\n\t    QLA_SUCCESS) {\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\t \n\t\tfcport->d_id = be_to_port_id(ct_rsp->rsp.ga_nxt.port_id);\n\n\t\tmemcpy(fcport->node_name, ct_rsp->rsp.ga_nxt.node_name,\n\t\t    WWN_SIZE);\n\t\tmemcpy(fcport->port_name, ct_rsp->rsp.ga_nxt.port_name,\n\t\t    WWN_SIZE);\n\n\t\tfcport->fc4_type = (ct_rsp->rsp.ga_nxt.fc4_types[2] & BIT_0) ?\n\t\t    FS_FC4TYPE_FCP : FC4_TYPE_OTHER;\n\n\t\tif (ct_rsp->rsp.ga_nxt.port_type != NS_N_PORT_TYPE &&\n\t\t    ct_rsp->rsp.ga_nxt.port_type != NS_NL_PORT_TYPE)\n\t\t\tfcport->d_id.b.domain = 0xf0;\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x2063,\n\t\t    \"GA_NXT entry - nn %8phN pn %8phN \"\n\t\t    \"port_id=%02x%02x%02x.\\n\",\n\t\t    fcport->node_name, fcport->port_name,\n\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t    fcport->d_id.b.al_pa);\n\t}\n\n\treturn (rval);\n}\n\nstatic inline int\nqla2x00_gid_pt_rsp_size(scsi_qla_host_t *vha)\n{\n\treturn vha->hw->max_fibre_devices * 4 + 16;\n}\n\n \nint\nqla2x00_gid_pt(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval;\n\tuint16_t\ti;\n\n\tms_iocb_entry_t\t*ms_pkt;\n\tstruct ct_sns_req\t*ct_req;\n\tstruct ct_sns_rsp\t*ct_rsp;\n\n\tstruct ct_sns_gid_pt_data *gid_data;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t gid_pt_rsp_size;\n\tstruct ct_arg arg;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn qla2x00_sns_gid_pt(vha, list);\n\n\tgid_data = NULL;\n\tgid_pt_rsp_size = qla2x00_gid_pt_rsp_size(vha);\n\n\targ.iocb = ha->ms_iocb;\n\targ.req_dma = ha->ct_sns_dma;\n\targ.rsp_dma = ha->ct_sns_dma;\n\targ.req_size = GID_PT_REQ_SIZE;\n\targ.rsp_size = gid_pt_rsp_size;\n\targ.nport_handle = NPH_SNS;\n\n\t \n\t \n\tms_pkt = ha->isp_ops->prep_ms_iocb(vha, &arg);\n\n\t \n\tct_req = qla2x00_prep_ct_req(ha->ct_sns, GID_PT_CMD, gid_pt_rsp_size);\n\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t \n\tct_req->req.gid_pt.port_type = NS_NX_PORT_TYPE;\n\n\t \n\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t    sizeof(ms_iocb_entry_t));\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x2055,\n\t\t    \"GID_PT issue IOCB failed (%d).\\n\", rval);\n\t} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, \"GID_PT\") !=\n\t    QLA_SUCCESS) {\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t\tgid_data = &ct_rsp->rsp.gid_pt.entries[i];\n\t\t\tlist[i].d_id = be_to_port_id(gid_data->port_id);\n\t\t\tmemset(list[i].fabric_port_name, 0, WWN_SIZE);\n\t\t\tlist[i].fp_speed = PORT_SPEED_UNKNOWN;\n\n\t\t\t \n\t\t\tif (gid_data->control_byte & BIT_7) {\n\t\t\t\tlist[i].d_id.b.rsvd_1 = gid_data->control_byte;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i == ha->max_fibre_devices)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t}\n\n\treturn (rval);\n}\n\n \nint\nqla2x00_gpn_id(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval = QLA_SUCCESS;\n\tuint16_t\ti;\n\n\tms_iocb_entry_t\t*ms_pkt;\n\tstruct ct_sns_req\t*ct_req;\n\tstruct ct_sns_rsp\t*ct_rsp;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct ct_arg arg;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn qla2x00_sns_gpn_id(vha, list);\n\n\targ.iocb = ha->ms_iocb;\n\targ.req_dma = ha->ct_sns_dma;\n\targ.rsp_dma = ha->ct_sns_dma;\n\targ.req_size = GPN_ID_REQ_SIZE;\n\targ.rsp_size = GPN_ID_RSP_SIZE;\n\targ.nport_handle = NPH_SNS;\n\n\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t \n\t\t \n\t\tms_pkt = ha->isp_ops->prep_ms_iocb(vha, &arg);\n\n\t\t \n\t\tct_req = qla2x00_prep_ct_req(ha->ct_sns, GPN_ID_CMD,\n\t\t    GPN_ID_RSP_SIZE);\n\t\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t\t \n\t\tct_req->req.port_id.port_id = port_id_to_be_id(list[i].d_id);\n\n\t\t \n\t\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t\t    sizeof(ms_iocb_entry_t));\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2056,\n\t\t\t    \"GPN_ID issue IOCB failed (%d).\\n\", rval);\n\t\t\tbreak;\n\t\t} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\n\t\t    \"GPN_ID\") != QLA_SUCCESS) {\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(list[i].port_name,\n\t\t\t    ct_rsp->rsp.gpn_id.port_name, WWN_SIZE);\n\t\t}\n\n\t\t \n\t\tif (list[i].d_id.b.rsvd_1 != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (rval);\n}\n\n \nint\nqla2x00_gnn_id(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval = QLA_SUCCESS;\n\tuint16_t\ti;\n\tstruct qla_hw_data *ha = vha->hw;\n\tms_iocb_entry_t\t*ms_pkt;\n\tstruct ct_sns_req\t*ct_req;\n\tstruct ct_sns_rsp\t*ct_rsp;\n\tstruct ct_arg arg;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn qla2x00_sns_gnn_id(vha, list);\n\n\targ.iocb = ha->ms_iocb;\n\targ.req_dma = ha->ct_sns_dma;\n\targ.rsp_dma = ha->ct_sns_dma;\n\targ.req_size = GNN_ID_REQ_SIZE;\n\targ.rsp_size = GNN_ID_RSP_SIZE;\n\targ.nport_handle = NPH_SNS;\n\n\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t \n\t\t \n\t\tms_pkt = ha->isp_ops->prep_ms_iocb(vha, &arg);\n\n\t\t \n\t\tct_req = qla2x00_prep_ct_req(ha->ct_sns, GNN_ID_CMD,\n\t\t    GNN_ID_RSP_SIZE);\n\t\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t\t \n\t\tct_req->req.port_id.port_id = port_id_to_be_id(list[i].d_id);\n\n\t\t \n\t\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t\t    sizeof(ms_iocb_entry_t));\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2057,\n\t\t\t    \"GNN_ID issue IOCB failed (%d).\\n\", rval);\n\t\t\tbreak;\n\t\t} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\n\t\t    \"GNN_ID\") != QLA_SUCCESS) {\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(list[i].node_name,\n\t\t\t    ct_rsp->rsp.gnn_id.node_name, WWN_SIZE);\n\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2058,\n\t\t\t    \"GID_PT entry - nn %8phN pn %8phN \"\n\t\t\t    \"portid=%02x%02x%02x.\\n\",\n\t\t\t    list[i].node_name, list[i].port_name,\n\t\t\t    list[i].d_id.b.domain, list[i].d_id.b.area,\n\t\t\t    list[i].d_id.b.al_pa);\n\t\t}\n\n\t\t \n\t\tif (list[i].d_id.b.rsvd_1 != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (rval);\n}\n\nstatic void qla2x00_async_sns_sp_done(srb_t *sp, int rc)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct ct_sns_pkt *ct_sns;\n\tstruct qla_work_evt *e;\n\n\tsp->rc = rc;\n\tif (rc == QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x204f,\n\t\t    \"Async done-%s exiting normally.\\n\",\n\t\t    sp->name);\n\t} else if (rc == QLA_FUNCTION_TIMEOUT) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x204f,\n\t\t    \"Async done-%s timeout\\n\", sp->name);\n\t} else {\n\t\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.rsp;\n\t\tmemset(ct_sns, 0, sizeof(*ct_sns));\n\t\tsp->retry_count++;\n\t\tif (sp->retry_count > 3)\n\t\t\tgoto err;\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x204f,\n\t\t    \"Async done-%s fail rc %x.  Retry count %d\\n\",\n\t\t    sp->name, rc, sp->retry_count);\n\n\t\te = qla2x00_alloc_work(vha, QLA_EVT_SP_RETRY);\n\t\tif (!e)\n\t\t\tgoto err2;\n\n\t\te->u.iosb.sp = sp;\n\t\tqla2x00_post_work(vha, e);\n\t\treturn;\n\t}\n\nerr:\n\te = qla2x00_alloc_work(vha, QLA_EVT_UNMAP);\nerr2:\n\tif (!e) {\n\t\t \n\t\tif (sp->u.iocb_cmd.u.ctarg.req) {\n\t\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req_allocated_size,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req_dma);\n\t\t\tsp->u.iocb_cmd.u.ctarg.req = NULL;\n\t\t}\n\n\t\tif (sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.rsp_allocated_size,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.rsp,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.rsp_dma);\n\t\t\tsp->u.iocb_cmd.u.ctarg.rsp = NULL;\n\t\t}\n\n\t\t \n\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\t\treturn;\n\t}\n\n\te->u.iosb.sp = sp;\n\tqla2x00_post_work(vha, e);\n}\n\n \nint\nqla2x00_rft_id(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn qla2x00_sns_rft_id(vha);\n\n\treturn qla_async_rftid(vha, &vha->d_id);\n}\n\nstatic int qla_async_rftid(scsi_qla_host_t *vha, port_id_t *d_id)\n{\n\tint rval = QLA_MEMORY_ALLOC_FAILED;\n\tstruct ct_sns_req *ct_req;\n\tsrb_t *sp;\n\tstruct ct_sns_pkt *ct_sns;\n\n\tif (!vha->flags.online)\n\t\tgoto done;\n\n\t \n\tsp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"rft_id\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_sns_sp_done);\n\n\tsp->u.iocb_cmd.u.ctarg.req = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.req_dma,\n\t    GFP_KERNEL);\n\tsp->u.iocb_cmd.u.ctarg.req_allocated_size = sizeof(struct ct_sns_pkt);\n\tif (!sp->u.iocb_cmd.u.ctarg.req) {\n\t\tql_log(ql_log_warn, vha, 0xd041,\n\t\t    \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t    __func__);\n\t\tgoto done_free_sp;\n\t}\n\n\tsp->u.iocb_cmd.u.ctarg.rsp = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.rsp_dma,\n\t    GFP_KERNEL);\n\tsp->u.iocb_cmd.u.ctarg.rsp_allocated_size = sizeof(struct ct_sns_pkt);\n\tif (!sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tql_log(ql_log_warn, vha, 0xd042,\n\t\t    \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t    __func__);\n\t\tgoto done_free_sp;\n\t}\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.rsp;\n\tmemset(ct_sns, 0, sizeof(*ct_sns));\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;\n\n\t \n\tct_req = qla2x00_prep_ct_req(ct_sns, RFT_ID_CMD, RFT_ID_RSP_SIZE);\n\n\t \n\tct_req->req.rft_id.port_id = port_id_to_be_id(vha->d_id);\n\tct_req->req.rft_id.fc4_types[2] = 0x01;\t\t \n\n\tif (vha->flags.nvme_enabled && qla_ini_mode_enabled(vha))\n\t\tct_req->req.rft_id.fc4_types[6] = 1;     \n\n\tsp->u.iocb_cmd.u.ctarg.req_size = RFT_ID_REQ_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.rsp_size = RFT_ID_RSP_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"Async-%s - hdl=%x portid %06x.\\n\",\n\t    sp->name, sp->handle, d_id->b24);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2043,\n\t\t    \"RFT_ID issue IOCB failed (%d).\\n\", rval);\n\t\tgoto done_free_sp;\n\t}\n\treturn rval;\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\n \nint\nqla2x00_rff_id(scsi_qla_host_t *vha, u8 type)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2046,\n\t\t    \"RFF_ID call not supported on ISP2100/ISP2200.\\n\");\n\t\treturn (QLA_SUCCESS);\n\t}\n\n\treturn qla_async_rffid(vha, &vha->d_id, qlt_rff_id(vha), type);\n}\n\nstatic int qla_async_rffid(scsi_qla_host_t *vha, port_id_t *d_id,\n    u8 fc4feature, u8 fc4type)\n{\n\tint rval = QLA_MEMORY_ALLOC_FAILED;\n\tstruct ct_sns_req *ct_req;\n\tsrb_t *sp;\n\tstruct ct_sns_pkt *ct_sns;\n\n\t \n\tsp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"rff_id\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_sns_sp_done);\n\n\tsp->u.iocb_cmd.u.ctarg.req = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.req_dma,\n\t    GFP_KERNEL);\n\tsp->u.iocb_cmd.u.ctarg.req_allocated_size = sizeof(struct ct_sns_pkt);\n\tif (!sp->u.iocb_cmd.u.ctarg.req) {\n\t\tql_log(ql_log_warn, vha, 0xd041,\n\t\t    \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t    __func__);\n\t\tgoto done_free_sp;\n\t}\n\n\tsp->u.iocb_cmd.u.ctarg.rsp = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.rsp_dma,\n\t    GFP_KERNEL);\n\tsp->u.iocb_cmd.u.ctarg.rsp_allocated_size = sizeof(struct ct_sns_pkt);\n\tif (!sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tql_log(ql_log_warn, vha, 0xd042,\n\t\t    \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t    __func__);\n\t\tgoto done_free_sp;\n\t}\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.rsp;\n\tmemset(ct_sns, 0, sizeof(*ct_sns));\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;\n\n\t \n\tct_req = qla2x00_prep_ct_req(ct_sns, RFF_ID_CMD, RFF_ID_RSP_SIZE);\n\n\t \n\tct_req->req.rff_id.port_id = port_id_to_be_id(*d_id);\n\tct_req->req.rff_id.fc4_feature = fc4feature;\n\tct_req->req.rff_id.fc4_type = fc4type;\t\t \n\n\tsp->u.iocb_cmd.u.ctarg.req_size = RFF_ID_REQ_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.rsp_size = RFF_ID_RSP_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"Async-%s - hdl=%x portid %06x feature %x type %x.\\n\",\n\t    sp->name, sp->handle, d_id->b24, fc4feature, fc4type);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2047,\n\t\t    \"RFF_ID issue IOCB failed (%d).\\n\", rval);\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\n \nint\nqla2x00_rnn_id(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn qla2x00_sns_rnn_id(vha);\n\n\treturn  qla_async_rnnid(vha, &vha->d_id, vha->node_name);\n}\n\nstatic int qla_async_rnnid(scsi_qla_host_t *vha, port_id_t *d_id,\n\tu8 *node_name)\n{\n\tint rval = QLA_MEMORY_ALLOC_FAILED;\n\tstruct ct_sns_req *ct_req;\n\tsrb_t *sp;\n\tstruct ct_sns_pkt *ct_sns;\n\n\t \n\tsp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"rnid\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_sns_sp_done);\n\n\tsp->u.iocb_cmd.u.ctarg.req = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.req_dma,\n\t    GFP_KERNEL);\n\tsp->u.iocb_cmd.u.ctarg.req_allocated_size = sizeof(struct ct_sns_pkt);\n\tif (!sp->u.iocb_cmd.u.ctarg.req) {\n\t\tql_log(ql_log_warn, vha, 0xd041,\n\t\t    \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t    __func__);\n\t\tgoto done_free_sp;\n\t}\n\n\tsp->u.iocb_cmd.u.ctarg.rsp = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.rsp_dma,\n\t    GFP_KERNEL);\n\tsp->u.iocb_cmd.u.ctarg.rsp_allocated_size = sizeof(struct ct_sns_pkt);\n\tif (!sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tql_log(ql_log_warn, vha, 0xd042,\n\t\t    \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t    __func__);\n\t\tgoto done_free_sp;\n\t}\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.rsp;\n\tmemset(ct_sns, 0, sizeof(*ct_sns));\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;\n\n\t \n\tct_req = qla2x00_prep_ct_req(ct_sns, RNN_ID_CMD, RNN_ID_RSP_SIZE);\n\n\t \n\tct_req->req.rnn_id.port_id = port_id_to_be_id(vha->d_id);\n\tmemcpy(ct_req->req.rnn_id.node_name, vha->node_name, WWN_SIZE);\n\n\tsp->u.iocb_cmd.u.ctarg.req_size = RNN_ID_REQ_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.rsp_size = RNN_ID_RSP_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"Async-%s - hdl=%x portid %06x\\n\",\n\t    sp->name, sp->handle, d_id->b24);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x204d,\n\t\t    \"RNN_ID issue IOCB failed (%d).\\n\", rval);\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\nsize_t\nqla2x00_get_sym_node_name(scsi_qla_host_t *vha, uint8_t *snn, size_t size)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLAFX00(ha))\n\t\treturn scnprintf(snn, size, \"%s FW:v%s DVR:v%s\",\n\t\t    ha->model_number, ha->mr.fw_version, qla2x00_version_str);\n\n\treturn scnprintf(snn, size, \"%s FW:v%d.%02d.%02d DVR:v%s\",\n\t    ha->model_number, ha->fw_major_version, ha->fw_minor_version,\n\t    ha->fw_subminor_version, qla2x00_version_str);\n}\n\n \nint\nqla2x00_rsnn_nn(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2050,\n\t\t    \"RSNN_ID call unsupported on ISP2100/ISP2200.\\n\");\n\t\treturn (QLA_SUCCESS);\n\t}\n\n\treturn qla_async_rsnn_nn(vha);\n}\n\nstatic int qla_async_rsnn_nn(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_MEMORY_ALLOC_FAILED;\n\tstruct ct_sns_req *ct_req;\n\tsrb_t *sp;\n\tstruct ct_sns_pkt *ct_sns;\n\n\t \n\tsp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"rsnn_nn\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_sns_sp_done);\n\n\tsp->u.iocb_cmd.u.ctarg.req = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.req_dma,\n\t    GFP_KERNEL);\n\tsp->u.iocb_cmd.u.ctarg.req_allocated_size = sizeof(struct ct_sns_pkt);\n\tif (!sp->u.iocb_cmd.u.ctarg.req) {\n\t\tql_log(ql_log_warn, vha, 0xd041,\n\t\t    \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t    __func__);\n\t\tgoto done_free_sp;\n\t}\n\n\tsp->u.iocb_cmd.u.ctarg.rsp = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t    sizeof(struct ct_sns_pkt), &sp->u.iocb_cmd.u.ctarg.rsp_dma,\n\t    GFP_KERNEL);\n\tsp->u.iocb_cmd.u.ctarg.rsp_allocated_size = sizeof(struct ct_sns_pkt);\n\tif (!sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tql_log(ql_log_warn, vha, 0xd042,\n\t\t    \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t    __func__);\n\t\tgoto done_free_sp;\n\t}\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.rsp;\n\tmemset(ct_sns, 0, sizeof(*ct_sns));\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;\n\n\t \n\tct_req = qla2x00_prep_ct_req(ct_sns, RSNN_NN_CMD, RSNN_NN_RSP_SIZE);\n\n\t \n\tmemcpy(ct_req->req.rsnn_nn.node_name, vha->node_name, WWN_SIZE);\n\n\t \n\tqla2x00_get_sym_node_name(vha, ct_req->req.rsnn_nn.sym_node_name,\n\t    sizeof(ct_req->req.rsnn_nn.sym_node_name));\n\tct_req->req.rsnn_nn.name_len =\n\t    (uint8_t)strlen(ct_req->req.rsnn_nn.sym_node_name);\n\n\n\tsp->u.iocb_cmd.u.ctarg.req_size = 24 + 1 + ct_req->req.rsnn_nn.name_len;\n\tsp->u.iocb_cmd.u.ctarg.rsp_size = RSNN_NN_RSP_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"Async-%s - hdl=%x.\\n\",\n\t    sp->name, sp->handle);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2043,\n\t\t    \"RFT_ID issue IOCB failed (%d).\\n\", rval);\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\n \nstatic inline struct sns_cmd_pkt *\nqla2x00_prep_sns_cmd(scsi_qla_host_t *vha, uint16_t cmd, uint16_t scmd_len,\n    uint16_t data_size)\n{\n\tuint16_t\t\twc;\n\tstruct sns_cmd_pkt\t*sns_cmd;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tsns_cmd = ha->sns_cmd;\n\tmemset(sns_cmd, 0, sizeof(struct sns_cmd_pkt));\n\twc = data_size / 2;\t\t\t \n\tsns_cmd->p.cmd.buffer_length = cpu_to_le16(wc);\n\tput_unaligned_le64(ha->sns_cmd_dma, &sns_cmd->p.cmd.buffer_address);\n\tsns_cmd->p.cmd.subcommand_length = cpu_to_le16(scmd_len);\n\tsns_cmd->p.cmd.subcommand = cpu_to_le16(cmd);\n\twc = (data_size - 16) / 4;\t\t \n\tsns_cmd->p.cmd.size = cpu_to_le16(wc);\n\n\tvha->qla_stats.control_requests++;\n\n\treturn (sns_cmd);\n}\n\n \nstatic int\nqla2x00_sns_ga_nxt(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint\t\trval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct sns_cmd_pkt\t*sns_cmd;\n\n\t \n\t \n\tsns_cmd = qla2x00_prep_sns_cmd(vha, GA_NXT_CMD, GA_NXT_SNS_SCMD_LEN,\n\t    GA_NXT_SNS_DATA_SIZE);\n\n\t \n\tsns_cmd->p.cmd.param[0] = fcport->d_id.b.al_pa;\n\tsns_cmd->p.cmd.param[1] = fcport->d_id.b.area;\n\tsns_cmd->p.cmd.param[2] = fcport->d_id.b.domain;\n\n\t \n\trval = qla2x00_send_sns(vha, ha->sns_cmd_dma, GA_NXT_SNS_CMD_SIZE / 2,\n\t    sizeof(struct sns_cmd_pkt));\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x205f,\n\t\t    \"GA_NXT Send SNS failed (%d).\\n\", rval);\n\t} else if (sns_cmd->p.gan_data[8] != 0x80 ||\n\t    sns_cmd->p.gan_data[9] != 0x02) {\n\t\tql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x2084,\n\t\t    \"GA_NXT failed, rejected request ga_nxt_rsp:\\n\");\n\t\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2074,\n\t\t    sns_cmd->p.gan_data, 16);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\t \n\t\tfcport->d_id.b.domain = sns_cmd->p.gan_data[17];\n\t\tfcport->d_id.b.area = sns_cmd->p.gan_data[18];\n\t\tfcport->d_id.b.al_pa = sns_cmd->p.gan_data[19];\n\n\t\tmemcpy(fcport->node_name, &sns_cmd->p.gan_data[284], WWN_SIZE);\n\t\tmemcpy(fcport->port_name, &sns_cmd->p.gan_data[20], WWN_SIZE);\n\n\t\tif (sns_cmd->p.gan_data[16] != NS_N_PORT_TYPE &&\n\t\t    sns_cmd->p.gan_data[16] != NS_NL_PORT_TYPE)\n\t\t\tfcport->d_id.b.domain = 0xf0;\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x2061,\n\t\t    \"GA_NXT entry - nn %8phN pn %8phN \"\n\t\t    \"port_id=%02x%02x%02x.\\n\",\n\t\t    fcport->node_name, fcport->port_name,\n\t\t    fcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t    fcport->d_id.b.al_pa);\n\t}\n\n\treturn (rval);\n}\n\n \nstatic int\nqla2x00_sns_gid_pt(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t\ti;\n\tuint8_t\t\t*entry;\n\tstruct sns_cmd_pkt\t*sns_cmd;\n\tuint16_t gid_pt_sns_data_size;\n\n\tgid_pt_sns_data_size = qla2x00_gid_pt_rsp_size(vha);\n\n\t \n\t \n\tsns_cmd = qla2x00_prep_sns_cmd(vha, GID_PT_CMD, GID_PT_SNS_SCMD_LEN,\n\t    gid_pt_sns_data_size);\n\n\t \n\tsns_cmd->p.cmd.param[0] = NS_NX_PORT_TYPE;\n\n\t \n\trval = qla2x00_send_sns(vha, ha->sns_cmd_dma, GID_PT_SNS_CMD_SIZE / 2,\n\t    sizeof(struct sns_cmd_pkt));\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x206d,\n\t\t    \"GID_PT Send SNS failed (%d).\\n\", rval);\n\t} else if (sns_cmd->p.gid_data[8] != 0x80 ||\n\t    sns_cmd->p.gid_data[9] != 0x02) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x202f,\n\t\t    \"GID_PT failed, rejected request, gid_rsp:\\n\");\n\t\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2081,\n\t\t    sns_cmd->p.gid_data, 16);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t\tentry = &sns_cmd->p.gid_data[(i * 4) + 16];\n\t\t\tlist[i].d_id.b.domain = entry[1];\n\t\t\tlist[i].d_id.b.area = entry[2];\n\t\t\tlist[i].d_id.b.al_pa = entry[3];\n\n\t\t\t \n\t\t\tif (entry[0] & BIT_7) {\n\t\t\t\tlist[i].d_id.b.rsvd_1 = entry[0];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i == ha->max_fibre_devices)\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t}\n\n\treturn (rval);\n}\n\n \nstatic int\nqla2x00_sns_gpn_id(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t\ti;\n\tstruct sns_cmd_pkt\t*sns_cmd;\n\n\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t \n\t\t \n\t\tsns_cmd = qla2x00_prep_sns_cmd(vha, GPN_ID_CMD,\n\t\t    GPN_ID_SNS_SCMD_LEN, GPN_ID_SNS_DATA_SIZE);\n\n\t\t \n\t\tsns_cmd->p.cmd.param[0] = list[i].d_id.b.al_pa;\n\t\tsns_cmd->p.cmd.param[1] = list[i].d_id.b.area;\n\t\tsns_cmd->p.cmd.param[2] = list[i].d_id.b.domain;\n\n\t\t \n\t\trval = qla2x00_send_sns(vha, ha->sns_cmd_dma,\n\t\t    GPN_ID_SNS_CMD_SIZE / 2, sizeof(struct sns_cmd_pkt));\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2032,\n\t\t\t    \"GPN_ID Send SNS failed (%d).\\n\", rval);\n\t\t} else if (sns_cmd->p.gpn_data[8] != 0x80 ||\n\t\t    sns_cmd->p.gpn_data[9] != 0x02) {\n\t\t\tql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x207e,\n\t\t\t    \"GPN_ID failed, rejected request, gpn_rsp:\\n\");\n\t\t\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x207f,\n\t\t\t    sns_cmd->p.gpn_data, 16);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(list[i].port_name, &sns_cmd->p.gpn_data[16],\n\t\t\t    WWN_SIZE);\n\t\t}\n\n\t\t \n\t\tif (list[i].d_id.b.rsvd_1 != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (rval);\n}\n\n \nstatic int\nqla2x00_sns_gnn_id(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t\ti;\n\tstruct sns_cmd_pkt\t*sns_cmd;\n\n\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t \n\t\t \n\t\tsns_cmd = qla2x00_prep_sns_cmd(vha, GNN_ID_CMD,\n\t\t    GNN_ID_SNS_SCMD_LEN, GNN_ID_SNS_DATA_SIZE);\n\n\t\t \n\t\tsns_cmd->p.cmd.param[0] = list[i].d_id.b.al_pa;\n\t\tsns_cmd->p.cmd.param[1] = list[i].d_id.b.area;\n\t\tsns_cmd->p.cmd.param[2] = list[i].d_id.b.domain;\n\n\t\t \n\t\trval = qla2x00_send_sns(vha, ha->sns_cmd_dma,\n\t\t    GNN_ID_SNS_CMD_SIZE / 2, sizeof(struct sns_cmd_pkt));\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0x203f,\n\t\t\t    \"GNN_ID Send SNS failed (%d).\\n\", rval);\n\t\t} else if (sns_cmd->p.gnn_data[8] != 0x80 ||\n\t\t    sns_cmd->p.gnn_data[9] != 0x02) {\n\t\t\tql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x2082,\n\t\t\t    \"GNN_ID failed, rejected request, gnn_rsp:\\n\");\n\t\t\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x207a,\n\t\t\t    sns_cmd->p.gnn_data, 16);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(list[i].node_name, &sns_cmd->p.gnn_data[16],\n\t\t\t    WWN_SIZE);\n\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x206e,\n\t\t\t    \"GID_PT entry - nn %8phN pn %8phN \"\n\t\t\t    \"port_id=%02x%02x%02x.\\n\",\n\t\t\t    list[i].node_name, list[i].port_name,\n\t\t\t    list[i].d_id.b.domain, list[i].d_id.b.area,\n\t\t\t    list[i].d_id.b.al_pa);\n\t\t}\n\n\t\t \n\t\tif (list[i].d_id.b.rsvd_1 != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (rval);\n}\n\n \nstatic int\nqla2x00_sns_rft_id(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct sns_cmd_pkt\t*sns_cmd;\n\n\t \n\t \n\tsns_cmd = qla2x00_prep_sns_cmd(vha, RFT_ID_CMD, RFT_ID_SNS_SCMD_LEN,\n\t    RFT_ID_SNS_DATA_SIZE);\n\n\t \n\tsns_cmd->p.cmd.param[0] = vha->d_id.b.al_pa;\n\tsns_cmd->p.cmd.param[1] = vha->d_id.b.area;\n\tsns_cmd->p.cmd.param[2] = vha->d_id.b.domain;\n\n\tsns_cmd->p.cmd.param[5] = 0x01;\t\t\t \n\n\t \n\trval = qla2x00_send_sns(vha, ha->sns_cmd_dma, RFT_ID_SNS_CMD_SIZE / 2,\n\t    sizeof(struct sns_cmd_pkt));\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x2060,\n\t\t    \"RFT_ID Send SNS failed (%d).\\n\", rval);\n\t} else if (sns_cmd->p.rft_data[8] != 0x80 ||\n\t    sns_cmd->p.rft_data[9] != 0x02) {\n\t\tql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x2083,\n\t\t    \"RFT_ID failed, rejected request rft_rsp:\\n\");\n\t\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x2080,\n\t\t    sns_cmd->p.rft_data, 16);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2073,\n\t\t    \"RFT_ID exiting normally.\\n\");\n\t}\n\n\treturn (rval);\n}\n\n \nstatic int\nqla2x00_sns_rnn_id(scsi_qla_host_t *vha)\n{\n\tint\t\trval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct sns_cmd_pkt\t*sns_cmd;\n\n\t \n\t \n\tsns_cmd = qla2x00_prep_sns_cmd(vha, RNN_ID_CMD, RNN_ID_SNS_SCMD_LEN,\n\t    RNN_ID_SNS_DATA_SIZE);\n\n\t \n\tsns_cmd->p.cmd.param[0] = vha->d_id.b.al_pa;\n\tsns_cmd->p.cmd.param[1] = vha->d_id.b.area;\n\tsns_cmd->p.cmd.param[2] = vha->d_id.b.domain;\n\n\tsns_cmd->p.cmd.param[4] = vha->node_name[7];\n\tsns_cmd->p.cmd.param[5] = vha->node_name[6];\n\tsns_cmd->p.cmd.param[6] = vha->node_name[5];\n\tsns_cmd->p.cmd.param[7] = vha->node_name[4];\n\tsns_cmd->p.cmd.param[8] = vha->node_name[3];\n\tsns_cmd->p.cmd.param[9] = vha->node_name[2];\n\tsns_cmd->p.cmd.param[10] = vha->node_name[1];\n\tsns_cmd->p.cmd.param[11] = vha->node_name[0];\n\n\t \n\trval = qla2x00_send_sns(vha, ha->sns_cmd_dma, RNN_ID_SNS_CMD_SIZE / 2,\n\t    sizeof(struct sns_cmd_pkt));\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x204a,\n\t\t    \"RNN_ID Send SNS failed (%d).\\n\", rval);\n\t} else if (sns_cmd->p.rnn_data[8] != 0x80 ||\n\t    sns_cmd->p.rnn_data[9] != 0x02) {\n\t\tql_dbg(ql_dbg_disc + ql_dbg_buffer, vha, 0x207b,\n\t\t    \"RNN_ID failed, rejected request, rnn_rsp:\\n\");\n\t\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x207c,\n\t\t    sns_cmd->p.rnn_data, 16);\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x204c,\n\t\t    \"RNN_ID exiting normally.\\n\");\n\t}\n\n\treturn (rval);\n}\n\n \nint\nqla2x00_mgmt_svr_login(scsi_qla_host_t *vha)\n{\n\tint ret, rval;\n\tuint16_t mb[MAILBOX_REGISTER_COUNT];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tret = QLA_SUCCESS;\n\tif (vha->flags.management_server_logged_in)\n\t\treturn ret;\n\n\trval = ha->isp_ops->fabric_login(vha, vha->mgmt_svr_loop_id, 0xff, 0xff,\n\t    0xfa, mb, BIT_1);\n\tif (rval != QLA_SUCCESS || mb[0] != MBS_COMMAND_COMPLETE) {\n\t\tif (rval == QLA_MEMORY_ALLOC_FAILED)\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2085,\n\t\t\t    \"Failed management_server login: loopid=%x \"\n\t\t\t    \"rval=%d\\n\", vha->mgmt_svr_loop_id, rval);\n\t\telse\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2024,\n\t\t\t    \"Failed management_server login: loopid=%x \"\n\t\t\t    \"mb[0]=%x mb[1]=%x mb[2]=%x mb[6]=%x mb[7]=%x.\\n\",\n\t\t\t    vha->mgmt_svr_loop_id, mb[0], mb[1], mb[2], mb[6],\n\t\t\t    mb[7]);\n\t\tret = QLA_FUNCTION_FAILED;\n\t} else\n\t\tvha->flags.management_server_logged_in = 1;\n\n\treturn ret;\n}\n\n \nvoid *\nqla2x00_prep_ms_fdmi_iocb(scsi_qla_host_t *vha, uint32_t req_size,\n    uint32_t rsp_size)\n{\n\tms_iocb_entry_t *ms_pkt;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tms_pkt = ha->ms_iocb;\n\tmemset(ms_pkt, 0, sizeof(ms_iocb_entry_t));\n\n\tms_pkt->entry_type = MS_IOCB_TYPE;\n\tms_pkt->entry_count = 1;\n\tSET_TARGET_ID(ha, ms_pkt->loop_id, vha->mgmt_svr_loop_id);\n\tms_pkt->control_flags = cpu_to_le16(CF_READ | CF_HEAD_TAG);\n\tms_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\n\tms_pkt->cmd_dsd_count = cpu_to_le16(1);\n\tms_pkt->total_dsd_count = cpu_to_le16(2);\n\tms_pkt->rsp_bytecount = cpu_to_le32(rsp_size);\n\tms_pkt->req_bytecount = cpu_to_le32(req_size);\n\n\tput_unaligned_le64(ha->ct_sns_dma, &ms_pkt->req_dsd.address);\n\tms_pkt->req_dsd.length = ms_pkt->req_bytecount;\n\n\tput_unaligned_le64(ha->ct_sns_dma, &ms_pkt->rsp_dsd.address);\n\tms_pkt->rsp_dsd.length = ms_pkt->rsp_bytecount;\n\n\treturn ms_pkt;\n}\n\n \nvoid *\nqla24xx_prep_ms_fdmi_iocb(scsi_qla_host_t *vha, uint32_t req_size,\n    uint32_t rsp_size)\n{\n\tstruct ct_entry_24xx *ct_pkt;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;\n\tmemset(ct_pkt, 0, sizeof(struct ct_entry_24xx));\n\n\tct_pkt->entry_type = CT_IOCB_TYPE;\n\tct_pkt->entry_count = 1;\n\tct_pkt->nport_handle = cpu_to_le16(vha->mgmt_svr_loop_id);\n\tct_pkt->timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\n\tct_pkt->cmd_dsd_count = cpu_to_le16(1);\n\tct_pkt->rsp_dsd_count = cpu_to_le16(1);\n\tct_pkt->rsp_byte_count = cpu_to_le32(rsp_size);\n\tct_pkt->cmd_byte_count = cpu_to_le32(req_size);\n\n\tput_unaligned_le64(ha->ct_sns_dma, &ct_pkt->dsd[0].address);\n\tct_pkt->dsd[0].length = ct_pkt->cmd_byte_count;\n\n\tput_unaligned_le64(ha->ct_sns_dma, &ct_pkt->dsd[1].address);\n\tct_pkt->dsd[1].length = ct_pkt->rsp_byte_count;\n\tct_pkt->vp_index = vha->vp_idx;\n\n\treturn ct_pkt;\n}\n\nstatic void\nqla2x00_update_ms_fdmi_iocb(scsi_qla_host_t *vha, uint32_t req_size)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tms_iocb_entry_t *ms_pkt = ha->ms_iocb;\n\tstruct ct_entry_24xx *ct_pkt = (struct ct_entry_24xx *)ha->ms_iocb;\n\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tct_pkt->cmd_byte_count = cpu_to_le32(req_size);\n\t\tct_pkt->dsd[0].length = ct_pkt->cmd_byte_count;\n\t} else {\n\t\tms_pkt->req_bytecount = cpu_to_le32(req_size);\n\t\tms_pkt->req_dsd.length = ms_pkt->req_bytecount;\n\t}\n}\n\n \nstatic inline struct ct_sns_req *\nqla2x00_prep_ct_fdmi_req(struct ct_sns_pkt *p, uint16_t cmd,\n    uint16_t rsp_size)\n{\n\tmemset(p, 0, sizeof(struct ct_sns_pkt));\n\n\tp->p.req.header.revision = 0x01;\n\tp->p.req.header.gs_type = 0xFA;\n\tp->p.req.header.gs_subtype = 0x10;\n\tp->p.req.command = cpu_to_be16(cmd);\n\tp->p.req.max_rsp_size = cpu_to_be16((rsp_size - 16) / 4);\n\n\treturn &p->p.req;\n}\n\nuint\nqla25xx_fdmi_port_speed_capability(struct qla_hw_data *ha)\n{\n\tuint speeds = 0;\n\n\tif (IS_CNA_CAPABLE(ha))\n\t\treturn FDMI_PORT_SPEED_10GB;\n\tif (IS_QLA28XX(ha) || IS_QLA27XX(ha)) {\n\t\tif (ha->max_supported_speed == 2) {\n\t\t\tif (ha->min_supported_speed <= 6)\n\t\t\t\tspeeds |= FDMI_PORT_SPEED_64GB;\n\t\t}\n\t\tif (ha->max_supported_speed == 2 ||\n\t\t    ha->max_supported_speed == 1) {\n\t\t\tif (ha->min_supported_speed <= 5)\n\t\t\t\tspeeds |= FDMI_PORT_SPEED_32GB;\n\t\t}\n\t\tif (ha->max_supported_speed == 2 ||\n\t\t    ha->max_supported_speed == 1 ||\n\t\t    ha->max_supported_speed == 0) {\n\t\t\tif (ha->min_supported_speed <= 4)\n\t\t\t\tspeeds |= FDMI_PORT_SPEED_16GB;\n\t\t}\n\t\tif (ha->max_supported_speed == 1 ||\n\t\t    ha->max_supported_speed == 0) {\n\t\t\tif (ha->min_supported_speed <= 3)\n\t\t\t\tspeeds |= FDMI_PORT_SPEED_8GB;\n\t\t}\n\t\tif (ha->max_supported_speed == 0) {\n\t\t\tif (ha->min_supported_speed <= 2)\n\t\t\t\tspeeds |= FDMI_PORT_SPEED_4GB;\n\t\t}\n\t\treturn speeds;\n\t}\n\tif (IS_QLA2031(ha)) {\n\t\tif ((ha->pdev->subsystem_vendor == 0x103C) &&\n\t\t    ((ha->pdev->subsystem_device == 0x8002) ||\n\t\t    (ha->pdev->subsystem_device == 0x8086))) {\n\t\t\tspeeds = FDMI_PORT_SPEED_16GB;\n\t\t} else {\n\t\t\tspeeds = FDMI_PORT_SPEED_16GB|FDMI_PORT_SPEED_8GB|\n\t\t\t\tFDMI_PORT_SPEED_4GB;\n\t\t}\n\t\treturn speeds;\n\t}\n\tif (IS_QLA25XX(ha) || IS_QLAFX00(ha))\n\t\treturn FDMI_PORT_SPEED_8GB|FDMI_PORT_SPEED_4GB|\n\t\t\tFDMI_PORT_SPEED_2GB|FDMI_PORT_SPEED_1GB;\n\tif (IS_QLA24XX_TYPE(ha))\n\t\treturn FDMI_PORT_SPEED_4GB|FDMI_PORT_SPEED_2GB|\n\t\t\tFDMI_PORT_SPEED_1GB;\n\tif (IS_QLA23XX(ha))\n\t\treturn FDMI_PORT_SPEED_2GB|FDMI_PORT_SPEED_1GB;\n\treturn FDMI_PORT_SPEED_1GB;\n}\n\nuint\nqla25xx_fdmi_port_speed_currently(struct qla_hw_data *ha)\n{\n\tswitch (ha->link_data_rate) {\n\tcase PORT_SPEED_1GB:\n\t\treturn FDMI_PORT_SPEED_1GB;\n\tcase PORT_SPEED_2GB:\n\t\treturn FDMI_PORT_SPEED_2GB;\n\tcase PORT_SPEED_4GB:\n\t\treturn FDMI_PORT_SPEED_4GB;\n\tcase PORT_SPEED_8GB:\n\t\treturn FDMI_PORT_SPEED_8GB;\n\tcase PORT_SPEED_10GB:\n\t\treturn FDMI_PORT_SPEED_10GB;\n\tcase PORT_SPEED_16GB:\n\t\treturn FDMI_PORT_SPEED_16GB;\n\tcase PORT_SPEED_32GB:\n\t\treturn FDMI_PORT_SPEED_32GB;\n\tcase PORT_SPEED_64GB:\n\t\treturn FDMI_PORT_SPEED_64GB;\n\tdefault:\n\t\treturn FDMI_PORT_SPEED_UNKNOWN;\n\t}\n}\n\n \nstatic unsigned long\nqla2x00_hba_attributes(scsi_qla_host_t *vha, void *entries,\n\tunsigned int callopt)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct new_utsname *p_sysid = utsname();\n\tstruct ct_fdmi_hba_attr *eiter;\n\tuint16_t alen;\n\tunsigned long size = 0;\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_NODE_NAME);\n\tmemcpy(eiter->a.node_name, vha->node_name, sizeof(eiter->a.node_name));\n\talen = sizeof(eiter->a.node_name);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a0,\n\t    \"NODENAME = %016llx.\\n\", wwn_to_u64(eiter->a.node_name));\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_MANUFACTURER);\n\talen = scnprintf(\n\t\teiter->a.manufacturer, sizeof(eiter->a.manufacturer),\n\t\t\"%s\", QLA2XXX_MANUFACTURER);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a1,\n\t    \"MANUFACTURER = %s.\\n\", eiter->a.manufacturer);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_SERIAL_NUMBER);\n\talen = 0;\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\talen = qla2xxx_get_vpd_field(vha, \"SN\",\n\t\t    eiter->a.serial_num, sizeof(eiter->a.serial_num));\n\t}\n\tif (!alen) {\n\t\tuint32_t sn = ((ha->serial0 & 0x1f) << 16) |\n\t\t\t(ha->serial2 << 8) | ha->serial1;\n\t\talen = scnprintf(\n\t\t\teiter->a.serial_num, sizeof(eiter->a.serial_num),\n\t\t\t\"%c%05d\", 'A' + sn / 100000, sn % 100000);\n\t}\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a2,\n\t    \"SERIAL NUMBER = %s.\\n\", eiter->a.serial_num);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_MODEL);\n\talen = scnprintf(\n\t\teiter->a.model, sizeof(eiter->a.model),\n\t\t\"%s\", ha->model_number);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a3,\n\t    \"MODEL NAME = %s.\\n\", eiter->a.model);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_MODEL_DESCRIPTION);\n\talen = scnprintf(\n\t\teiter->a.model_desc, sizeof(eiter->a.model_desc),\n\t\t\"%s\", ha->model_desc);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a4,\n\t    \"MODEL DESCRIPTION = %s.\\n\", eiter->a.model_desc);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_HARDWARE_VERSION);\n\talen = 0;\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tif (!alen) {\n\t\t\talen = qla2xxx_get_vpd_field(vha, \"MN\",\n\t\t\t    eiter->a.hw_version, sizeof(eiter->a.hw_version));\n\t\t}\n\t\tif (!alen) {\n\t\t\talen = qla2xxx_get_vpd_field(vha, \"EC\",\n\t\t\t    eiter->a.hw_version, sizeof(eiter->a.hw_version));\n\t\t}\n\t}\n\tif (!alen) {\n\t\talen = scnprintf(\n\t\t\teiter->a.hw_version, sizeof(eiter->a.hw_version),\n\t\t\t\"HW:%s\", ha->adapter_id);\n\t}\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a5,\n\t    \"HARDWARE VERSION = %s.\\n\", eiter->a.hw_version);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_DRIVER_VERSION);\n\talen = scnprintf(\n\t\teiter->a.driver_version, sizeof(eiter->a.driver_version),\n\t\t\"%s\", qla2x00_version_str);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a6,\n\t    \"DRIVER VERSION = %s.\\n\", eiter->a.driver_version);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_OPTION_ROM_VERSION);\n\talen = scnprintf(\n\t\teiter->a.orom_version, sizeof(eiter->a.orom_version),\n\t\t\"%d.%02d\", ha->bios_revision[1], ha->bios_revision[0]);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20a7,\n\t    \"OPTROM VERSION = %d.%02d.\\n\",\n\t    eiter->a.orom_version[1], eiter->a.orom_version[0]);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_FIRMWARE_VERSION);\n\tha->isp_ops->fw_version_str(vha, eiter->a.fw_version,\n\t    sizeof(eiter->a.fw_version));\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a8,\n\t    \"FIRMWARE VERSION = %s.\\n\", eiter->a.fw_version);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_OS_NAME_AND_VERSION);\n\talen = 0;\n\tif (p_sysid) {\n\t\talen = scnprintf(\n\t\t\teiter->a.os_version, sizeof(eiter->a.os_version),\n\t\t\t\"%s %s %s\",\n\t\t\tp_sysid->sysname, p_sysid->release, p_sysid->machine);\n\t}\n\tif (!alen) {\n\t\talen = scnprintf(\n\t\t\teiter->a.os_version, sizeof(eiter->a.os_version),\n\t\t\t\"%s %s\",\n\t\t\t\"Linux\", fc_host_system_hostname(vha->host));\n\t}\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20a9,\n\t    \"OS VERSION = %s.\\n\", eiter->a.os_version);\n\tif (callopt == CALLOPT_FDMI1)\n\t\tgoto done;\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_MAXIMUM_CT_PAYLOAD_LENGTH);\n\teiter->a.max_ct_len = cpu_to_be32(ha->frame_payload_size >> 2);\n\n\talen = sizeof(eiter->a.max_ct_len);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20aa,\n\t    \"CT PAYLOAD LENGTH = 0x%x.\\n\", be32_to_cpu(eiter->a.max_ct_len));\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_NODE_SYMBOLIC_NAME);\n\talen = qla2x00_get_sym_node_name(vha, eiter->a.sym_name,\n\t    sizeof(eiter->a.sym_name));\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20ab,\n\t    \"SYMBOLIC NAME = %s.\\n\", eiter->a.sym_name);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_VENDOR_SPECIFIC_INFO);\n\teiter->a.vendor_specific_info = cpu_to_be32(PCI_VENDOR_ID_QLOGIC);\n\talen = sizeof(eiter->a.vendor_specific_info);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20ac,\n\t    \"VENDOR SPECIFIC INFO = 0x%x.\\n\",\n\t    be32_to_cpu(eiter->a.vendor_specific_info));\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_NUM_PORTS);\n\teiter->a.num_ports = cpu_to_be32(1);\n\talen = sizeof(eiter->a.num_ports);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20ad,\n\t    \"PORT COUNT = %x.\\n\", be32_to_cpu(eiter->a.num_ports));\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_FABRIC_NAME);\n\tmemcpy(eiter->a.fabric_name, vha->fabric_node_name,\n\t    sizeof(eiter->a.fabric_name));\n\talen = sizeof(eiter->a.fabric_name);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20ae,\n\t    \"FABRIC NAME = %016llx.\\n\", wwn_to_u64(eiter->a.fabric_name));\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_BOOT_BIOS_NAME);\n\talen = scnprintf(\n\t\teiter->a.bios_name, sizeof(eiter->a.bios_name),\n\t\t\"BIOS %d.%02d\", ha->bios_revision[1], ha->bios_revision[0]);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20af,\n\t    \"BIOS NAME = %s\\n\", eiter->a.bios_name);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_HBA_VENDOR_IDENTIFIER);\n\talen = scnprintf(\n\t\teiter->a.vendor_identifier, sizeof(eiter->a.vendor_identifier),\n\t\t\"%s\", \"QLGC\");\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20b0,\n\t    \"VENDOR IDENTIFIER = %s.\\n\", eiter->a.vendor_identifier);\ndone:\n\treturn size;\n}\n\n \nstatic unsigned long\nqla2x00_port_attributes(scsi_qla_host_t *vha, void *entries,\n\tunsigned int callopt)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct new_utsname *p_sysid = utsname();\n\tchar *hostname = p_sysid ?\n\t\tp_sysid->nodename : fc_host_system_hostname(vha->host);\n\tstruct ct_fdmi_port_attr *eiter;\n\tuint16_t alen;\n\tunsigned long size = 0;\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_FC4_TYPES);\n\teiter->a.fc4_types[0] = 0x00;\n\teiter->a.fc4_types[1] = 0x00;\n\teiter->a.fc4_types[2] = 0x01;\n\teiter->a.fc4_types[3] = 0x00;\n\talen = sizeof(eiter->a.fc4_types);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c0,\n\t    \"FC4 TYPES = %016llx.\\n\", *(uint64_t *)eiter->a.fc4_types);\n\tif (vha->flags.nvme_enabled) {\n\t\teiter->a.fc4_types[6] = 1;       \n\t\tql_dbg(ql_dbg_disc, vha, 0x211f,\n\t\t    \"NVME FC4 Type = %02x 0x0 0x0 0x0 0x0 0x0.\\n\",\n\t\t    eiter->a.fc4_types[6]);\n\t}\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_SUPPORT_SPEED);\n\teiter->a.sup_speed = cpu_to_be32(\n\t\tqla25xx_fdmi_port_speed_capability(ha));\n\talen = sizeof(eiter->a.sup_speed);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c1,\n\t    \"SUPPORTED SPEED = %x.\\n\", be32_to_cpu(eiter->a.sup_speed));\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_CURRENT_SPEED);\n\teiter->a.cur_speed = cpu_to_be32(\n\t\tqla25xx_fdmi_port_speed_currently(ha));\n\talen = sizeof(eiter->a.cur_speed);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c2,\n\t    \"CURRENT SPEED = %x.\\n\", be32_to_cpu(eiter->a.cur_speed));\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_MAX_FRAME_SIZE);\n\teiter->a.max_frame_size = cpu_to_be32(ha->frame_payload_size);\n\talen = sizeof(eiter->a.max_frame_size);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c3,\n\t    \"MAX FRAME SIZE = %x.\\n\", be32_to_cpu(eiter->a.max_frame_size));\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_OS_DEVICE_NAME);\n\talen = scnprintf(\n\t\teiter->a.os_dev_name, sizeof(eiter->a.os_dev_name),\n\t\t\"%s:host%lu\", QLA2XXX_DRIVER_NAME, vha->host_no);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c4,\n\t    \"OS DEVICE NAME = %s.\\n\", eiter->a.os_dev_name);\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_HOST_NAME);\n\tif (!*hostname || !strncmp(hostname, \"(none)\", 6))\n\t\thostname = \"Linux-default\";\n\talen = scnprintf(\n\t\teiter->a.host_name, sizeof(eiter->a.host_name),\n\t\t\"%s\", hostname);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c5,\n\t    \"HOSTNAME = %s.\\n\", eiter->a.host_name);\n\n\tif (callopt == CALLOPT_FDMI1)\n\t\tgoto done;\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_NODE_NAME);\n\tmemcpy(eiter->a.node_name, vha->node_name, sizeof(eiter->a.node_name));\n\talen = sizeof(eiter->a.node_name);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c6,\n\t    \"NODENAME = %016llx.\\n\", wwn_to_u64(eiter->a.node_name));\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_NAME);\n\tmemcpy(eiter->a.port_name, vha->port_name, sizeof(eiter->a.port_name));\n\talen = sizeof(eiter->a.port_name);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c7,\n\t    \"PORTNAME = %016llx.\\n\", wwn_to_u64(eiter->a.port_name));\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_SYM_NAME);\n\talen = qla2x00_get_sym_node_name(vha, eiter->a.port_sym_name,\n\t    sizeof(eiter->a.port_sym_name));\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c8,\n\t    \"PORT SYMBOLIC NAME = %s\\n\", eiter->a.port_sym_name);\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_TYPE);\n\teiter->a.port_type = cpu_to_be32(NS_NX_PORT_TYPE);\n\talen = sizeof(eiter->a.port_type);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20c9,\n\t    \"PORT TYPE = %x.\\n\", be32_to_cpu(eiter->a.port_type));\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_SUPP_COS);\n\teiter->a.port_supported_cos = cpu_to_be32(FC_CLASS_3);\n\talen = sizeof(eiter->a.port_supported_cos);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20ca,\n\t    \"SUPPORTED COS = %08x\\n\", be32_to_cpu(eiter->a.port_supported_cos));\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_FABRIC_NAME);\n\tmemcpy(eiter->a.fabric_name, vha->fabric_node_name,\n\t    sizeof(eiter->a.fabric_name));\n\talen = sizeof(eiter->a.fabric_name);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20cb,\n\t    \"FABRIC NAME = %016llx.\\n\", wwn_to_u64(eiter->a.fabric_name));\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_FC4_TYPE);\n\teiter->a.port_fc4_type[0] = 0x00;\n\teiter->a.port_fc4_type[1] = 0x00;\n\teiter->a.port_fc4_type[2] = 0x01;\n\teiter->a.port_fc4_type[3] = 0x00;\n\talen = sizeof(eiter->a.port_fc4_type);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20cc,\n\t    \"PORT ACTIVE FC4 TYPE = %016llx.\\n\",\n\t    *(uint64_t *)eiter->a.port_fc4_type);\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_STATE);\n\teiter->a.port_state = cpu_to_be32(2);\n\talen = sizeof(eiter->a.port_state);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20cd,\n\t    \"PORT_STATE = %x.\\n\", be32_to_cpu(eiter->a.port_state));\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_COUNT);\n\teiter->a.num_ports = cpu_to_be32(1);\n\talen = sizeof(eiter->a.num_ports);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20ce,\n\t    \"PORT COUNT = %x.\\n\", be32_to_cpu(eiter->a.num_ports));\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_PORT_IDENTIFIER);\n\teiter->a.port_id = cpu_to_be32(vha->d_id.b24);\n\talen = sizeof(eiter->a.port_id);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20cf,\n\t    \"PORT ID = %x.\\n\", be32_to_cpu(eiter->a.port_id));\n\n\tif (callopt == CALLOPT_FDMI2 || !ql2xsmartsan)\n\t\tgoto done;\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_SMARTSAN_SERVICE);\n\talen = scnprintf(\n\t\teiter->a.smartsan_service, sizeof(eiter->a.smartsan_service),\n\t\t\"%s\", \"Smart SAN Initiator\");\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20d0,\n\t    \"SMARTSAN SERVICE CATEGORY = %s.\\n\", eiter->a.smartsan_service);\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_SMARTSAN_GUID);\n\tmemcpy(eiter->a.smartsan_guid, vha->node_name, WWN_SIZE);\n\tmemcpy(eiter->a.smartsan_guid + WWN_SIZE, vha->port_name, WWN_SIZE);\n\talen = sizeof(eiter->a.smartsan_guid);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20d1,\n\t    \"Smart SAN GUID = %016llx-%016llx\\n\",\n\t    wwn_to_u64(eiter->a.smartsan_guid),\n\t    wwn_to_u64(eiter->a.smartsan_guid + WWN_SIZE));\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_SMARTSAN_VERSION);\n\talen = scnprintf(\n\t\teiter->a.smartsan_version, sizeof(eiter->a.smartsan_version),\n\t\t\"%s\", \"Smart SAN Version 2.0\");\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20d2,\n\t    \"SMARTSAN VERSION = %s\\n\", eiter->a.smartsan_version);\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_SMARTSAN_PROD_NAME);\n\talen = scnprintf(eiter->a.smartsan_prod_name,\n\t\tsizeof(eiter->a.smartsan_prod_name),\n\t\t\"ISP%04x\", ha->pdev->device);\n\talen += FDMI_ATTR_ALIGNMENT(alen);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t    \"SMARTSAN PRODUCT NAME = %s\\n\", eiter->a.smartsan_prod_name);\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_SMARTSAN_PORT_INFO);\n\teiter->a.smartsan_port_info = cpu_to_be32(vha->vp_idx ? 2 : 1);\n\talen = sizeof(eiter->a.smartsan_port_info);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20d4,\n\t    \"SMARTSAN PORT INFO = %x\\n\", eiter->a.smartsan_port_info);\n\n\t \n\teiter = entries + size;\n\teiter->type = cpu_to_be16(FDMI_SMARTSAN_SECURITY_SUPPORT);\n\teiter->a.smartsan_security_support = cpu_to_be32(1);\n\talen = sizeof(eiter->a.smartsan_security_support);\n\talen += FDMI_ATTR_TYPELEN(eiter);\n\teiter->len = cpu_to_be16(alen);\n\tsize += alen;\n\tql_dbg(ql_dbg_disc, vha, 0x20d6,\n\t    \"SMARTSAN SECURITY SUPPORT = %d\\n\",\n\t    be32_to_cpu(eiter->a.smartsan_security_support));\n\ndone:\n\treturn size;\n}\n\n \nstatic int\nqla2x00_fdmi_rhba(scsi_qla_host_t *vha, unsigned int callopt)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long size = 0;\n\tunsigned int rval, count;\n\tms_iocb_entry_t *ms_pkt;\n\tstruct ct_sns_req *ct_req;\n\tstruct ct_sns_rsp *ct_rsp;\n\tvoid *entries;\n\n\tcount = callopt != CALLOPT_FDMI1 ?\n\t    FDMI2_HBA_ATTR_COUNT : FDMI1_HBA_ATTR_COUNT;\n\n\tsize = RHBA_RSP_SIZE;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20e0,\n\t    \"RHBA (callopt=%x count=%u size=%lu).\\n\", callopt, count, size);\n\n\t \n\tms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, 0, size);\n\n\t \n\tct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, RHBA_CMD, size);\n\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t \n\tmemcpy(ct_req->req.rhba.hba_identifier, vha->port_name,\n\t    sizeof(ct_req->req.rhba.hba_identifier));\n\tsize += sizeof(ct_req->req.rhba.hba_identifier);\n\n\tct_req->req.rhba.entry_count = cpu_to_be32(1);\n\tsize += sizeof(ct_req->req.rhba.entry_count);\n\n\tmemcpy(ct_req->req.rhba.port_name, vha->port_name,\n\t    sizeof(ct_req->req.rhba.port_name));\n\tsize += sizeof(ct_req->req.rhba.port_name);\n\n\t \n\tct_req->req.rhba.attrs.count = cpu_to_be32(count);\n\tsize += sizeof(ct_req->req.rhba.attrs.count);\n\n\t \n\tentries = &ct_req->req.rhba.attrs.entry;\n\n\tsize += qla2x00_hba_attributes(vha, entries, callopt);\n\n\t \n\tqla2x00_update_ms_fdmi_iocb(vha, size + 16);\n\n\tql_dbg(ql_dbg_disc, vha, 0x20e1,\n\t    \"RHBA %016llx %016llx.\\n\",\n\t    wwn_to_u64(ct_req->req.rhba.hba_identifier),\n\t    wwn_to_u64(ct_req->req.rhba.port_name));\n\n\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x20e2,\n\t    entries, size);\n\n\t \n\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t    sizeof(*ha->ms_iocb));\n\tif (rval) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e3,\n\t\t    \"RHBA iocb failed (%d).\\n\", rval);\n\t\treturn rval;\n\t}\n\n\trval = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, \"RHBA\");\n\tif (rval) {\n\t\tif (ct_rsp->header.reason_code == CT_REASON_CANNOT_PERFORM &&\n\t\t    ct_rsp->header.explanation_code ==\n\t\t    CT_EXPL_ALREADY_REGISTERED) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20e4,\n\t\t\t    \"RHBA already registered.\\n\");\n\t\t\treturn QLA_ALREADY_REGISTERED;\n\t\t}\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20e5,\n\t\t    \"RHBA failed, CT Reason %#x, CT Explanation %#x\\n\",\n\t\t    ct_rsp->header.reason_code,\n\t\t    ct_rsp->header.explanation_code);\n\t\treturn rval;\n\t}\n\n\tql_dbg(ql_dbg_disc, vha, 0x20e6, \"RHBA exiting normally.\\n\");\n\treturn rval;\n}\n\n\nstatic int\nqla2x00_fdmi_dhba(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tms_iocb_entry_t *ms_pkt;\n\tstruct ct_sns_req *ct_req;\n\tstruct ct_sns_rsp *ct_rsp;\n\t \n\t \n\tms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, DHBA_REQ_SIZE,\n\t    DHBA_RSP_SIZE);\n\t \n\tct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, DHBA_CMD, DHBA_RSP_SIZE);\n\tct_rsp = &ha->ct_sns->p.rsp;\n\t \n\tmemcpy(ct_req->req.dhba.port_name, vha->port_name, WWN_SIZE);\n\tql_dbg(ql_dbg_disc, vha, 0x2036,\n\t    \"DHBA portname = %8phN.\\n\", ct_req->req.dhba.port_name);\n\t \n\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t    sizeof(ms_iocb_entry_t));\n\tif (rval != QLA_SUCCESS) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x2037,\n\t\t    \"DHBA issue IOCB failed (%d).\\n\", rval);\n\t} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, \"DHBA\") !=\n\t    QLA_SUCCESS) {\n\t\trval = QLA_FUNCTION_FAILED;\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2038,\n\t\t    \"DHBA exiting normally.\\n\");\n\t}\n\treturn rval;\n}\n\n \nstatic int\nqla2x00_fdmi_rprt(scsi_qla_host_t *vha, int callopt)\n{\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(vha->hw->pdev);\n\tstruct qla_hw_data *ha = vha->hw;\n\tulong size = 0;\n\tuint rval, count;\n\tms_iocb_entry_t *ms_pkt;\n\tstruct ct_sns_req *ct_req;\n\tstruct ct_sns_rsp *ct_rsp;\n\tvoid *entries;\n\tcount = callopt == CALLOPT_FDMI2_SMARTSAN && ql2xsmartsan ?\n\t\tFDMI2_SMARTSAN_PORT_ATTR_COUNT :\n\t\tcallopt != CALLOPT_FDMI1 ?\n\t\tFDMI2_PORT_ATTR_COUNT : FDMI1_PORT_ATTR_COUNT;\n\n\tsize = RPRT_RSP_SIZE;\n\tql_dbg(ql_dbg_disc, vha, 0x20e8,\n\t    \"RPRT (callopt=%x count=%u size=%lu).\\n\", callopt, count, size);\n\t \n\tms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, 0, size);\n\t \n\tct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, RPRT_CMD, size);\n\tct_rsp = &ha->ct_sns->p.rsp;\n\t \n\tmemcpy(ct_req->req.rprt.hba_identifier, base_vha->port_name,\n\t    sizeof(ct_req->req.rprt.hba_identifier));\n\tsize += sizeof(ct_req->req.rprt.hba_identifier);\n\tmemcpy(ct_req->req.rprt.port_name, vha->port_name,\n\t    sizeof(ct_req->req.rprt.port_name));\n\tsize += sizeof(ct_req->req.rprt.port_name);\n\t \n\tct_req->req.rprt.attrs.count = cpu_to_be32(count);\n\tsize += sizeof(ct_req->req.rprt.attrs.count);\n\t \n\tentries = ct_req->req.rprt.attrs.entry;\n\tsize += qla2x00_port_attributes(vha, entries, callopt);\n\t \n\tqla2x00_update_ms_fdmi_iocb(vha, size + 16);\n\tql_dbg(ql_dbg_disc, vha, 0x20e9,\n\t    \"RPRT %016llx  %016llx.\\n\",\n\t    wwn_to_u64(ct_req->req.rprt.port_name),\n\t    wwn_to_u64(ct_req->req.rprt.port_name));\n\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x20ea,\n\t    entries, size);\n\t \n\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t    sizeof(*ha->ms_iocb));\n\tif (rval) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20eb,\n\t\t    \"RPRT iocb failed (%d).\\n\", rval);\n\t\treturn rval;\n\t}\n\trval = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, \"RPRT\");\n\tif (rval) {\n\t\tif (ct_rsp->header.reason_code == CT_REASON_CANNOT_PERFORM &&\n\t\t    ct_rsp->header.explanation_code ==\n\t\t    CT_EXPL_ALREADY_REGISTERED) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ec,\n\t\t\t    \"RPRT already registered.\\n\");\n\t\t\treturn QLA_ALREADY_REGISTERED;\n\t\t}\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20ed,\n\t\t    \"RPRT failed, CT Reason code: %#x, CT Explanation %#x\\n\",\n\t\t    ct_rsp->header.reason_code,\n\t\t    ct_rsp->header.explanation_code);\n\t\treturn rval;\n\t}\n\tql_dbg(ql_dbg_disc, vha, 0x20ee, \"RPRT exiting normally.\\n\");\n\treturn rval;\n}\n\n \nstatic int\nqla2x00_fdmi_rpa(scsi_qla_host_t *vha, uint callopt)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tulong size = 0;\n\tuint rval, count;\n\tms_iocb_entry_t *ms_pkt;\n\tstruct ct_sns_req *ct_req;\n\tstruct ct_sns_rsp *ct_rsp;\n\tvoid *entries;\n\n\tcount =\n\t    callopt == CALLOPT_FDMI2_SMARTSAN && ql2xsmartsan ?\n\t\tFDMI2_SMARTSAN_PORT_ATTR_COUNT :\n\t    callopt != CALLOPT_FDMI1 ?\n\t\tFDMI2_PORT_ATTR_COUNT : FDMI1_PORT_ATTR_COUNT;\n\n\tsize =\n\t    callopt != CALLOPT_FDMI1 ?\n\t\tSMARTSAN_RPA_RSP_SIZE : RPA_RSP_SIZE;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20f0,\n\t    \"RPA (callopt=%x count=%u size=%lu).\\n\", callopt, count, size);\n\n\t \n\tms_pkt = ha->isp_ops->prep_ms_fdmi_iocb(vha, 0, size);\n\n\t \n\tct_req = qla2x00_prep_ct_fdmi_req(ha->ct_sns, RPA_CMD, size);\n\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t \n\tmemcpy(ct_req->req.rpa.port_name, vha->port_name,\n\t    sizeof(ct_req->req.rpa.port_name));\n\tsize += sizeof(ct_req->req.rpa.port_name);\n\n\t \n\tct_req->req.rpa.attrs.count = cpu_to_be32(count);\n\tsize += sizeof(ct_req->req.rpa.attrs.count);\n\n\t \n\tentries = ct_req->req.rpa.attrs.entry;\n\n\tsize += qla2x00_port_attributes(vha, entries, callopt);\n\n\t \n\tqla2x00_update_ms_fdmi_iocb(vha, size + 16);\n\n\tql_dbg(ql_dbg_disc, vha, 0x20f1,\n\t    \"RPA %016llx.\\n\", wwn_to_u64(ct_req->req.rpa.port_name));\n\n\tql_dump_buffer(ql_dbg_disc + ql_dbg_buffer, vha, 0x20f2,\n\t    entries, size);\n\n\t \n\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t    sizeof(*ha->ms_iocb));\n\tif (rval) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x20f3,\n\t\t    \"RPA iocb failed (%d).\\n\", rval);\n\t\treturn rval;\n\t}\n\n\trval = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp, \"RPA\");\n\tif (rval) {\n\t\tif (ct_rsp->header.reason_code == CT_REASON_CANNOT_PERFORM &&\n\t\t    ct_rsp->header.explanation_code ==\n\t\t    CT_EXPL_ALREADY_REGISTERED) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20f4,\n\t\t\t    \"RPA already registered.\\n\");\n\t\t\treturn QLA_ALREADY_REGISTERED;\n\t\t}\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20f5,\n\t\t    \"RPA failed, CT Reason code: %#x, CT Explanation %#x\\n\",\n\t\t    ct_rsp->header.reason_code,\n\t\t    ct_rsp->header.explanation_code);\n\t\treturn rval;\n\t}\n\n\tql_dbg(ql_dbg_disc, vha, 0x20f6, \"RPA exiting normally.\\n\");\n\treturn rval;\n}\n\n \nint\nqla2x00_fdmi_register(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha) ||\n\t    IS_QLAFX00(ha))\n\t\treturn rval;\n\n\trval = qla2x00_mgmt_svr_login(vha);\n\tif (rval)\n\t\treturn rval;\n\n\t \n\tif (vha->vp_idx) {\n\t\tif (ql2xsmartsan)\n\t\t\trval = qla2x00_fdmi_rprt(vha, CALLOPT_FDMI2_SMARTSAN);\n\t\tif (rval || !ql2xsmartsan)\n\t\t\trval = qla2x00_fdmi_rprt(vha, CALLOPT_FDMI2);\n\t\tif (rval)\n\t\t\trval = qla2x00_fdmi_rprt(vha, CALLOPT_FDMI1);\n\n\t\treturn rval;\n\t}\n\n\t \n\trval = qla2x00_fdmi_rhba(vha, CALLOPT_FDMI2);\n\tif (rval) {\n\t\tif (rval != QLA_ALREADY_REGISTERED)\n\t\t\tgoto try_fdmi;\n\n\t\trval = qla2x00_fdmi_dhba(vha);\n\t\tif (rval)\n\t\t\tgoto try_fdmi;\n\n\t\trval = qla2x00_fdmi_rhba(vha, CALLOPT_FDMI2);\n\t\tif (rval)\n\t\t\tgoto try_fdmi;\n\t}\n\n\tif (ql2xsmartsan)\n\t\trval = qla2x00_fdmi_rpa(vha, CALLOPT_FDMI2_SMARTSAN);\n\tif (rval || !ql2xsmartsan)\n\t\trval = qla2x00_fdmi_rpa(vha, CALLOPT_FDMI2);\n\tif (rval)\n\t\tgoto try_fdmi;\n\n\treturn rval;\n\ntry_fdmi:\n\trval = qla2x00_fdmi_rhba(vha, CALLOPT_FDMI1);\n\tif (rval) {\n\t\tif (rval != QLA_ALREADY_REGISTERED)\n\t\t\treturn rval;\n\n\t\trval = qla2x00_fdmi_dhba(vha);\n\t\tif (rval)\n\t\t\treturn rval;\n\n\t\trval = qla2x00_fdmi_rhba(vha, CALLOPT_FDMI1);\n\t\tif (rval)\n\t\t\treturn rval;\n\t}\n\n\trval = qla2x00_fdmi_rpa(vha, CALLOPT_FDMI1);\n\n\treturn rval;\n}\n\n \nint\nqla2x00_gfpn_id(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval = QLA_SUCCESS;\n\tuint16_t\ti;\n\tstruct qla_hw_data *ha = vha->hw;\n\tms_iocb_entry_t\t*ms_pkt;\n\tstruct ct_sns_req\t*ct_req;\n\tstruct ct_sns_rsp\t*ct_rsp;\n\tstruct ct_arg arg;\n\n\tif (!IS_IIDMA_CAPABLE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\targ.iocb = ha->ms_iocb;\n\targ.req_dma = ha->ct_sns_dma;\n\targ.rsp_dma = ha->ct_sns_dma;\n\targ.req_size = GFPN_ID_REQ_SIZE;\n\targ.rsp_size = GFPN_ID_RSP_SIZE;\n\targ.nport_handle = NPH_SNS;\n\n\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t \n\t\t \n\t\tms_pkt = ha->isp_ops->prep_ms_iocb(vha, &arg);\n\n\t\t \n\t\tct_req = qla2x00_prep_ct_req(ha->ct_sns, GFPN_ID_CMD,\n\t\t    GFPN_ID_RSP_SIZE);\n\t\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t\t \n\t\tct_req->req.port_id.port_id = port_id_to_be_id(list[i].d_id);\n\n\t\t \n\t\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t\t    sizeof(ms_iocb_entry_t));\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2023,\n\t\t\t    \"GFPN_ID issue IOCB failed (%d).\\n\", rval);\n\t\t\tbreak;\n\t\t} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\n\t\t    \"GFPN_ID\") != QLA_SUCCESS) {\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(list[i].fabric_port_name,\n\t\t\t    ct_rsp->rsp.gfpn_id.port_name, WWN_SIZE);\n\t\t}\n\n\t\t \n\t\tif (list[i].d_id.b.rsvd_1 != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (rval);\n}\n\n\nstatic inline struct ct_sns_req *\nqla24xx_prep_ct_fm_req(struct ct_sns_pkt *p, uint16_t cmd,\n    uint16_t rsp_size)\n{\n\tmemset(p, 0, sizeof(struct ct_sns_pkt));\n\n\tp->p.req.header.revision = 0x01;\n\tp->p.req.header.gs_type = 0xFA;\n\tp->p.req.header.gs_subtype = 0x01;\n\tp->p.req.command = cpu_to_be16(cmd);\n\tp->p.req.max_rsp_size = cpu_to_be16((rsp_size - 16) / 4);\n\n\treturn &p->p.req;\n}\n\nstatic uint16_t\nqla2x00_port_speed_capability(uint16_t speed)\n{\n\tswitch (speed) {\n\tcase BIT_15:\n\t\treturn PORT_SPEED_1GB;\n\tcase BIT_14:\n\t\treturn PORT_SPEED_2GB;\n\tcase BIT_13:\n\t\treturn PORT_SPEED_4GB;\n\tcase BIT_12:\n\t\treturn PORT_SPEED_10GB;\n\tcase BIT_11:\n\t\treturn PORT_SPEED_8GB;\n\tcase BIT_10:\n\t\treturn PORT_SPEED_16GB;\n\tcase BIT_8:\n\t\treturn PORT_SPEED_32GB;\n\tcase BIT_7:\n\t\treturn PORT_SPEED_64GB;\n\tdefault:\n\t\treturn PORT_SPEED_UNKNOWN;\n\t}\n}\n\n \nint\nqla2x00_gpsc(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval;\n\tuint16_t\ti;\n\tstruct qla_hw_data *ha = vha->hw;\n\tms_iocb_entry_t *ms_pkt;\n\tstruct ct_sns_req\t*ct_req;\n\tstruct ct_sns_rsp\t*ct_rsp;\n\tstruct ct_arg arg;\n\n\tif (!IS_IIDMA_CAPABLE(ha))\n\t\treturn QLA_FUNCTION_FAILED;\n\tif (!ha->flags.gpsc_supported)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\trval = qla2x00_mgmt_svr_login(vha);\n\tif (rval)\n\t\treturn rval;\n\n\targ.iocb = ha->ms_iocb;\n\targ.req_dma = ha->ct_sns_dma;\n\targ.rsp_dma = ha->ct_sns_dma;\n\targ.req_size = GPSC_REQ_SIZE;\n\targ.rsp_size = GPSC_RSP_SIZE;\n\targ.nport_handle = vha->mgmt_svr_loop_id;\n\n\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t \n\t\t \n\t\tms_pkt = qla24xx_prep_ms_iocb(vha, &arg);\n\n\t\t \n\t\tct_req = qla24xx_prep_ct_fm_req(ha->ct_sns, GPSC_CMD,\n\t\t    GPSC_RSP_SIZE);\n\t\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t\t \n\t\tmemcpy(ct_req->req.gpsc.port_name, list[i].fabric_port_name,\n\t\t    WWN_SIZE);\n\n\t\t \n\t\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t\t    sizeof(ms_iocb_entry_t));\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2059,\n\t\t\t    \"GPSC issue IOCB failed (%d).\\n\", rval);\n\t\t} else if ((rval = qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\n\t\t    \"GPSC\")) != QLA_SUCCESS) {\n\t\t\t \n\t\t\tif (rval == QLA_INVALID_COMMAND &&\n\t\t\t    (ct_rsp->header.reason_code ==\n\t\t\t\tCT_REASON_INVALID_COMMAND_CODE ||\n\t\t\t     ct_rsp->header.reason_code ==\n\t\t\t\tCT_REASON_COMMAND_UNSUPPORTED)) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x205a,\n\t\t\t\t    \"GPSC command unsupported, disabling \"\n\t\t\t\t    \"query.\\n\");\n\t\t\t\tha->flags.gpsc_supported = 0;\n\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t} else {\n\t\t\tlist->fp_speed = qla2x00_port_speed_capability(\n\t\t\t    be16_to_cpu(ct_rsp->rsp.gpsc.speed));\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x205b,\n\t\t\t    \"GPSC ext entry - fpn \"\n\t\t\t    \"%8phN speeds=%04x speed=%04x.\\n\",\n\t\t\t    list[i].fabric_port_name,\n\t\t\t    be16_to_cpu(ct_rsp->rsp.gpsc.speeds),\n\t\t\t    be16_to_cpu(ct_rsp->rsp.gpsc.speed));\n\t\t}\n\n\t\t \n\t\tif (list[i].d_id.b.rsvd_1 != 0)\n\t\t\tbreak;\n\t}\n\n\treturn (rval);\n}\n\n \nvoid\nqla2x00_gff_id(scsi_qla_host_t *vha, sw_info_t *list)\n{\n\tint\t\trval;\n\tuint16_t\ti;\n\n\tms_iocb_entry_t\t*ms_pkt;\n\tstruct ct_sns_req\t*ct_req;\n\tstruct ct_sns_rsp\t*ct_rsp;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint8_t fcp_scsi_features = 0, nvme_features = 0;\n\tstruct ct_arg arg;\n\n\tfor (i = 0; i < ha->max_fibre_devices; i++) {\n\t\t \n\t\tlist[i].fc4_type = 0;\n\n\t\t \n\t\tif (!IS_FWI2_CAPABLE(ha))\n\t\t\tcontinue;\n\n\t\targ.iocb = ha->ms_iocb;\n\t\targ.req_dma = ha->ct_sns_dma;\n\t\targ.rsp_dma = ha->ct_sns_dma;\n\t\targ.req_size = GFF_ID_REQ_SIZE;\n\t\targ.rsp_size = GFF_ID_RSP_SIZE;\n\t\targ.nport_handle = NPH_SNS;\n\n\t\t \n\t\tms_pkt = ha->isp_ops->prep_ms_iocb(vha, &arg);\n\n\t\t \n\t\tct_req = qla2x00_prep_ct_req(ha->ct_sns, GFF_ID_CMD,\n\t\t    GFF_ID_RSP_SIZE);\n\t\tct_rsp = &ha->ct_sns->p.rsp;\n\n\t\t \n\t\tct_req->req.port_id.port_id = port_id_to_be_id(list[i].d_id);\n\n\t\t \n\t\trval = qla2x00_issue_iocb(vha, ha->ms_iocb, ha->ms_iocb_dma,\n\t\t   sizeof(ms_iocb_entry_t));\n\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x205c,\n\t\t\t    \"GFF_ID issue IOCB failed (%d).\\n\", rval);\n\t\t} else if (qla2x00_chk_ms_status(vha, ms_pkt, ct_rsp,\n\t\t\t       \"GFF_ID\") != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x205d,\n\t\t\t    \"GFF_ID IOCB status had a failure status code.\\n\");\n\t\t} else {\n\t\t\tfcp_scsi_features =\n\t\t\t   ct_rsp->rsp.gff_id.fc4_features[GFF_FCP_SCSI_OFFSET];\n\t\t\tfcp_scsi_features &= 0x0f;\n\n\t\t\tif (fcp_scsi_features) {\n\t\t\t\tlist[i].fc4_type = FS_FC4TYPE_FCP;\n\t\t\t\tlist[i].fc4_features = fcp_scsi_features;\n\t\t\t}\n\n\t\t\tnvme_features =\n\t\t\t    ct_rsp->rsp.gff_id.fc4_features[GFF_NVME_OFFSET];\n\t\t\tnvme_features &= 0xf;\n\n\t\t\tif (nvme_features) {\n\t\t\t\tlist[i].fc4_type |= FS_FC4TYPE_NVME;\n\t\t\t\tlist[i].fc4_features = nvme_features;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (list[i].d_id.b.rsvd_1 != 0)\n\t\t\tbreak;\n\t}\n}\n\nint qla24xx_post_gpsc_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_GPSC);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\treturn qla2x00_post_work(vha, e);\n}\n\nvoid qla24xx_handle_gpsc_event(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tstruct fc_port *fcport = ea->fcport;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20d8,\n\t    \"%s %8phC DS %d LS %d rc %d login %d|%d rscn %d|%d lid %d\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, ea->rc, ea->sp->gen2, fcport->login_gen,\n\t    ea->sp->gen2, fcport->rscn_gen|ea->sp->gen1, fcport->loop_id);\n\n\tif (fcport->disc_state == DSC_DELETE_PEND)\n\t\treturn;\n\n\t \n\tif (fcport->disc_state == DSC_LOGIN_AUTH_PEND)\n\t\treturn;\n\n\tif (ea->sp->gen2 != fcport->login_gen) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC generation changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\treturn;\n\t} else if (ea->sp->gen1 != fcport->rscn_gen) {\n\t\treturn;\n\t}\n\n\tqla_post_iidma_work(vha, fcport);\n}\n\nstatic void qla24xx_async_gpsc_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tfc_port_t *fcport = sp->fcport;\n\tstruct ct_sns_rsp       *ct_rsp;\n\tstruct event_arg ea;\n\n\tct_rsp = &fcport->ct_desc.ct_sns->p.rsp;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2053,\n\t    \"Async done-%s res %x, WWPN %8phC \\n\",\n\t    sp->name, res, fcport->port_name);\n\n\tfcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\n\tif (res == QLA_FUNCTION_TIMEOUT)\n\t\tgoto done;\n\n\tif (res == (DID_ERROR << 16)) {\n\t\t \n\t\tgoto done;\n\t} else if (res) {\n\t\tif ((ct_rsp->header.reason_code ==\n\t\t\t CT_REASON_INVALID_COMMAND_CODE) ||\n\t\t\t(ct_rsp->header.reason_code ==\n\t\t\tCT_REASON_COMMAND_UNSUPPORTED)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2019,\n\t\t\t    \"GPSC command unsupported, disabling query.\\n\");\n\t\t\tha->flags.gpsc_supported = 0;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tfcport->fp_speed = qla2x00_port_speed_capability(\n\t\t    be16_to_cpu(ct_rsp->rsp.gpsc.speed));\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x2054,\n\t\t    \"Async-%s OUT WWPN %8phC speeds=%04x speed=%04x.\\n\",\n\t\t    sp->name, fcport->fabric_port_name,\n\t\t    be16_to_cpu(ct_rsp->rsp.gpsc.speeds),\n\t\t    be16_to_cpu(ct_rsp->rsp.gpsc.speed));\n\t}\n\tmemset(&ea, 0, sizeof(ea));\n\tea.rc = res;\n\tea.fcport = fcport;\n\tea.sp = sp;\n\tqla24xx_handle_gpsc_event(vha, &ea);\n\ndone:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint qla24xx_async_gpsc(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tstruct ct_sns_req       *ct_req;\n\tsrb_t *sp;\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT))\n\t\treturn rval;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"gpsc\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla24xx_async_gpsc_sp_done);\n\n\t \n\tct_req = qla24xx_prep_ct_fm_req(fcport->ct_desc.ct_sns, GPSC_CMD,\n\t\tGPSC_RSP_SIZE);\n\n\t \n\tmemcpy(ct_req->req.gpsc.port_name, fcport->fabric_port_name,\n\t\tWWN_SIZE);\n\n\tsp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;\n\tsp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;\n\tsp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;\n\tsp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;\n\tsp->u.iocb_cmd.u.ctarg.req_size = GPSC_REQ_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.rsp_size = GPSC_RSP_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = vha->mgmt_svr_loop_id;\n\n\tql_dbg(ql_dbg_disc, vha, 0x205e,\n\t    \"Async-%s %8phC hdl=%x loopid=%x portid=%02x%02x%02x.\\n\",\n\t    sp->name, fcport->port_name, sp->handle,\n\t    fcport->loop_id, fcport->d_id.b.domain,\n\t    fcport->d_id.b.area, fcport->d_id.b.al_pa);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\nvoid qla24xx_sp_unmap(scsi_qla_host_t *vha, srb_t *sp)\n{\n\tstruct srb_iocb *c = &sp->u.iocb_cmd;\n\n\tswitch (sp->type) {\n\tcase SRB_ELS_DCMD:\n\t\tqla2x00_els_dcmd2_free(vha, &c->u.els_plogi);\n\t\tbreak;\n\tcase SRB_CT_PTHRU_CMD:\n\tdefault:\n\t\tif (sp->u.iocb_cmd.u.ctarg.req) {\n\t\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req_allocated_size,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req_dma);\n\t\t\tsp->u.iocb_cmd.u.ctarg.req = NULL;\n\t\t}\n\n\t\tif (sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.rsp_allocated_size,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.rsp,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.rsp_dma);\n\t\t\tsp->u.iocb_cmd.u.ctarg.rsp = NULL;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nvoid qla24xx_async_gffid_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tfc_port_t *fcport = sp->fcport;\n\tstruct ct_sns_rsp *ct_rsp;\n\tuint8_t fc4_scsi_feat;\n\tuint8_t fc4_nvme_feat;\n\n\tql_dbg(ql_dbg_disc, vha, 0x2133,\n\t       \"Async done-%s res %x ID %x. %8phC\\n\",\n\t       sp->name, res, fcport->d_id.b24, fcport->port_name);\n\n\tct_rsp = sp->u.iocb_cmd.u.ctarg.rsp;\n\tfc4_scsi_feat = ct_rsp->rsp.gff_id.fc4_features[GFF_FCP_SCSI_OFFSET];\n\tfc4_nvme_feat = ct_rsp->rsp.gff_id.fc4_features[GFF_NVME_OFFSET];\n\tsp->rc = res;\n\n\t \n\tif (!res) {\n\t\tif (fc4_scsi_feat & 0xf) {\n\t\t\t \n\t\t\tfcport->fc4_type = FS_FC4TYPE_FCP;\n\t\t\tfcport->fc4_features = fc4_scsi_feat & 0xf;\n\t\t}\n\n\t\tif (fc4_nvme_feat & 0xf) {\n\t\t\t \n\t\t\tfcport->fc4_type |= FS_FC4TYPE_NVME;\n\t\t\tfcport->fc4_features = fc4_nvme_feat & 0xf;\n\t\t}\n\t}\n\n\tif (sp->flags & SRB_WAKEUP_ON_COMP) {\n\t\tcomplete(sp->comp);\n\t} else  {\n\t\tif (sp->u.iocb_cmd.u.ctarg.req) {\n\t\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t\tsp->u.iocb_cmd.u.ctarg.req_allocated_size,\n\t\t\t\tsp->u.iocb_cmd.u.ctarg.req,\n\t\t\t\tsp->u.iocb_cmd.u.ctarg.req_dma);\n\t\t\tsp->u.iocb_cmd.u.ctarg.req = NULL;\n\t\t}\n\n\t\tif (sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t\tsp->u.iocb_cmd.u.ctarg.rsp_allocated_size,\n\t\t\t\tsp->u.iocb_cmd.u.ctarg.rsp,\n\t\t\t\tsp->u.iocb_cmd.u.ctarg.rsp_dma);\n\t\t\tsp->u.iocb_cmd.u.ctarg.rsp = NULL;\n\t\t}\n\n\t\t \n\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\t\t \n\t\tdump_stack();\n\t}\n}\n\n \nint qla24xx_async_gffid(scsi_qla_host_t *vha, fc_port_t *fcport, bool wait)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tstruct ct_sns_req       *ct_req;\n\tsrb_t *sp;\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\n\t \n\tif (!vha->flags.online || !wait)\n\t\treturn rval;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp)\n\t\treturn rval;\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"gffid\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla24xx_async_gffid_sp_done);\n\tsp->comp = &comp;\n\tsp->u.iocb_cmd.timeout = qla2x00_els_dcmd2_iocb_timeout;\n\n\tif (wait)\n\t\tsp->flags = SRB_WAKEUP_ON_COMP;\n\n\tsp->u.iocb_cmd.u.ctarg.req_allocated_size = sizeof(struct ct_sns_pkt);\n\tsp->u.iocb_cmd.u.ctarg.req = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t\t\t\tsp->u.iocb_cmd.u.ctarg.req_allocated_size,\n\t\t\t\t&sp->u.iocb_cmd.u.ctarg.req_dma,\n\t    GFP_KERNEL);\n\tif (!sp->u.iocb_cmd.u.ctarg.req) {\n\t\tql_log(ql_log_warn, vha, 0xd041,\n\t\t       \"%s: Failed to allocate ct_sns request.\\n\",\n\t\t       __func__);\n\t\tgoto done_free_sp;\n\t}\n\n\tsp->u.iocb_cmd.u.ctarg.rsp_allocated_size = sizeof(struct ct_sns_pkt);\n\tsp->u.iocb_cmd.u.ctarg.rsp = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t\t\t\tsp->u.iocb_cmd.u.ctarg.rsp_allocated_size,\n\t\t\t\t&sp->u.iocb_cmd.u.ctarg.rsp_dma,\n\t    GFP_KERNEL);\n\tif (!sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tql_log(ql_log_warn, vha, 0xd041,\n\t\t       \"%s: Failed to allocate ct_sns response.\\n\",\n\t\t       __func__);\n\t\tgoto done_free_sp;\n\t}\n\n\t \n\tct_req = qla2x00_prep_ct_req(sp->u.iocb_cmd.u.ctarg.req, GFF_ID_CMD, GFF_ID_RSP_SIZE);\n\n\tct_req->req.gff_id.port_id[0] = fcport->d_id.b.domain;\n\tct_req->req.gff_id.port_id[1] = fcport->d_id.b.area;\n\tct_req->req.gff_id.port_id[2] = fcport->d_id.b.al_pa;\n\n\tsp->u.iocb_cmd.u.ctarg.req_size = GFF_ID_REQ_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.rsp_size = GFF_ID_RSP_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;\n\n\trval = qla2x00_start_sp(sp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto done_free_sp;\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0x3074,\n\t\t       \"Async-%s hdl=%x portid %06x\\n\",\n\t\t       sp->name, sp->handle, fcport->d_id.b24);\n\t}\n\n\twait_for_completion(sp->comp);\n\trval = sp->rc;\n\ndone_free_sp:\n\tif (sp->u.iocb_cmd.u.ctarg.req) {\n\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t\t  sp->u.iocb_cmd.u.ctarg.req_allocated_size,\n\t\t\t\t  sp->u.iocb_cmd.u.ctarg.req,\n\t\t\t\t  sp->u.iocb_cmd.u.ctarg.req_dma);\n\t\tsp->u.iocb_cmd.u.ctarg.req = NULL;\n\t}\n\n\tif (sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t\t  sp->u.iocb_cmd.u.ctarg.rsp_allocated_size,\n\t\t\t\t  sp->u.iocb_cmd.u.ctarg.rsp,\n\t\t\t\t  sp->u.iocb_cmd.u.ctarg.rsp_dma);\n\t\tsp->u.iocb_cmd.u.ctarg.rsp = NULL;\n\t}\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\treturn rval;\n}\n\n \nstatic int qla2x00_is_a_vp(scsi_qla_host_t *vha, u64 wwn)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *vp;\n\tunsigned long flags;\n\tu64 twwn;\n\tint rc = 0;\n\n\tif (!ha->num_vhosts)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tlist_for_each_entry(vp, &ha->vp_list, list) {\n\t\ttwwn = wwn_to_u64(vp->port_name);\n\t\tif (wwn == twwn) {\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\treturn rc;\n}\n\nvoid qla24xx_async_gnnft_done(scsi_qla_host_t *vha, srb_t *sp)\n{\n\tfc_port_t *fcport;\n\tu32 i, rc;\n\tbool found;\n\tstruct fab_scan_rp *rp, *trp;\n\tunsigned long flags;\n\tu8 recheck = 0;\n\tu16 dup = 0, dup_cnt = 0;\n\n\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,\n\t    \"%s enter\\n\", __func__);\n\n\tif (sp->gen1 != vha->hw->base_qpair->chip_reset) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t    \"%s scan stop due to chip reset %x/%x\\n\",\n\t\t    sp->name, sp->gen1, vha->hw->base_qpair->chip_reset);\n\t\tgoto out;\n\t}\n\n\trc = sp->rc;\n\tif (rc) {\n\t\tvha->scan.scan_retry++;\n\t\tif (vha->scan.scan_retry < MAX_SCAN_RETRIES) {\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t    \"%s: Fabric scan failed for %d retries.\\n\",\n\t\t\t    __func__, vha->scan.scan_retry);\n\t\t\t \n\t\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\t\tif ((fcport->flags & FCF_FABRIC_DEVICE) != 0) {\n\t\t\t\t\tfcport->scan_state = QLA_FCPORT_SCAN;\n\t\t\t\t\tif (fcport->loop_id == FC_NO_LOOP_ID)\n\t\t\t\t\t\tfcport->logout_on_delete = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tfcport->logout_on_delete = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto login_logout;\n\t\t}\n\t}\n\tvha->scan.scan_retry = 0;\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list)\n\t\tfcport->scan_state = QLA_FCPORT_SCAN;\n\n\tfor (i = 0; i < vha->hw->max_fibre_devices; i++) {\n\t\tu64 wwn;\n\t\tint k;\n\n\t\trp = &vha->scan.l[i];\n\t\tfound = false;\n\n\t\twwn = wwn_to_u64(rp->port_name);\n\t\tif (wwn == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (k = i + 1; k < vha->hw->max_fibre_devices; k++) {\n\t\t\ttrp = &vha->scan.l[k];\n\t\t\tif (rp->id.b24 == trp->id.b24) {\n\t\t\t\tdup = 1;\n\t\t\t\tdup_cnt++;\n\t\t\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose,\n\t\t\t\t    vha, 0xffff,\n\t\t\t\t    \"Detected duplicate NPORT ID from switch data base: ID %06x WWN %8phN WWN %8phN\\n\",\n\t\t\t\t    rp->id.b24, rp->port_name, trp->port_name);\n\t\t\t\tmemset(trp, 0, sizeof(*trp));\n\t\t\t}\n\t\t}\n\n\t\tif (!memcmp(rp->port_name, vha->port_name, WWN_SIZE))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((rp->id.b.domain & 0xf0) == 0xf0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (qla2x00_is_a_vp(vha, wwn))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (memcmp(rp->port_name, fcport->port_name, WWN_SIZE))\n\t\t\t\tcontinue;\n\t\t\tfcport->scan_state = QLA_FCPORT_FOUND;\n\t\t\tfcport->last_rscn_gen = fcport->rscn_gen;\n\t\t\tfcport->fc4_type = rp->fc4type;\n\t\t\tfound = true;\n\n\t\t\tif (fcport->scan_needed) {\n\t\t\t\tif (NVME_PRIORITY(vha->hw, fcport))\n\t\t\t\t\tfcport->do_prli_nvme = 1;\n\t\t\t\telse\n\t\t\t\t\tfcport->do_prli_nvme = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tif ((fcport->flags & FCF_FABRIC_DEVICE) == 0) {\n\t\t\t\tqla2x00_clear_loop_id(fcport);\n\t\t\t\tfcport->flags |= FCF_FABRIC_DEVICE;\n\t\t\t} else if (fcport->d_id.b24 != rp->id.b24 ||\n\t\t\t\t   (fcport->scan_needed &&\n\t\t\t\t    fcport->port_type != FCT_INITIATOR &&\n\t\t\t\t    fcport->port_type != FCT_NVME_INITIATOR)) {\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t}\n\t\t\tfcport->d_id.b24 = rp->id.b24;\n\t\t\tfcport->scan_needed = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t    \"%s %d %8phC post new sess\\n\",\n\t\t\t    __func__, __LINE__, rp->port_name);\n\t\t\tqla24xx_post_newsess_work(vha, &rp->id, rp->port_name,\n\t\t\t    rp->node_name, NULL, rp->fc4type);\n\t\t}\n\t}\n\n\tif (dup) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"Detected %d duplicate NPORT ID(s) from switch data base\\n\",\n\t\t    dup_cnt);\n\t}\n\nlogin_logout:\n\t \n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif ((fcport->flags & FCF_FABRIC_DEVICE) == 0) {\n\t\t\tfcport->scan_needed = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fcport->scan_state != QLA_FCPORT_FOUND) {\n\t\t\tbool do_delete = false;\n\n\t\t\tif (fcport->scan_needed &&\n\t\t\t    fcport->disc_state == DSC_LOGIN_PEND) {\n\t\t\t\t \n\t\t\t\tfcport->logout_on_delete = 1;\n\t\t\t\tdo_delete = true;\n\t\t\t}\n\n\t\t\tfcport->scan_needed = 0;\n\t\t\tif (((qla_dual_mode_enabled(vha) ||\n\t\t\t      qla_ini_mode_enabled(vha)) &&\n\t\t\t    atomic_read(&fcport->state) == FCS_ONLINE) ||\n\t\t\t\tdo_delete) {\n\t\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID) {\n\t\t\t\t\tif (fcport->flags & FCF_FCP2_DEVICE)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tql_log(ql_log_warn, vha, 0x20f0,\n\t\t\t\t\t       \"%s %d %8phC post del sess\\n\",\n\t\t\t\t\t       __func__, __LINE__,\n\t\t\t\t\t       fcport->port_name);\n\n\t\t\t\t\tfcport->tgt_link_down_time = 0;\n\t\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (fcport->scan_needed ||\n\t\t\t    fcport->disc_state != DSC_LOGIN_COMPLETE) {\n\t\t\t\tif (fcport->login_retry == 0) {\n\t\t\t\t\tfcport->login_retry =\n\t\t\t\t\t\tvha->hw->login_retry_count;\n\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20a3,\n\t\t\t\t\t    \"Port login retry %8phN, lid 0x%04x retry cnt=%d.\\n\",\n\t\t\t\t\t    fcport->port_name, fcport->loop_id,\n\t\t\t\t\t    fcport->login_retry);\n\t\t\t\t}\n\t\t\t\tfcport->scan_needed = 0;\n\t\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\t}\n\t\t}\n\t}\n\n\trecheck = 1;\nout:\n\tqla24xx_sp_unmap(vha, sp);\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tvha->scan.scan_flags &= ~SF_SCANNING;\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\tif (recheck) {\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (fcport->scan_needed) {\n\t\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int qla2x00_post_gnnft_gpnft_done_work(struct scsi_qla_host *vha,\n    srb_t *sp, int cmd)\n{\n\tstruct qla_work_evt *e;\n\n\tif (cmd != QLA_EVT_GPNFT_DONE && cmd != QLA_EVT_GNNFT_DONE)\n\t\treturn QLA_PARAMETER_ERROR;\n\n\te = qla2x00_alloc_work(vha, cmd);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.iosb.sp = sp;\n\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic int qla2x00_post_nvme_gpnft_work(struct scsi_qla_host *vha,\n    srb_t *sp, int cmd)\n{\n\tstruct qla_work_evt *e;\n\n\tif (cmd != QLA_EVT_GPNFT)\n\t\treturn QLA_PARAMETER_ERROR;\n\n\te = qla2x00_alloc_work(vha, cmd);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.gpnft.fc4_type = FC4_TYPE_NVME;\n\te->u.gpnft.sp = sp;\n\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void qla2x00_find_free_fcp_nvme_slot(struct scsi_qla_host *vha,\n\tstruct srb *sp)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint num_fibre_dev = ha->max_fibre_devices;\n\tstruct ct_sns_req *ct_req =\n\t\t(struct ct_sns_req *)sp->u.iocb_cmd.u.ctarg.req;\n\tstruct ct_sns_gpnft_rsp *ct_rsp =\n\t\t(struct ct_sns_gpnft_rsp *)sp->u.iocb_cmd.u.ctarg.rsp;\n\tstruct ct_sns_gpn_ft_data *d;\n\tstruct fab_scan_rp *rp;\n\tu16 cmd = be16_to_cpu(ct_req->command);\n\tu8 fc4_type = sp->gen2;\n\tint i, j, k;\n\tport_id_t id;\n\tu8 found;\n\tu64 wwn;\n\n\tj = 0;\n\tfor (i = 0; i < num_fibre_dev; i++) {\n\t\td  = &ct_rsp->entries[i];\n\n\t\tid.b.rsvd_1 = 0;\n\t\tid.b.domain = d->port_id[0];\n\t\tid.b.area   = d->port_id[1];\n\t\tid.b.al_pa  = d->port_id[2];\n\t\twwn = wwn_to_u64(d->port_name);\n\n\t\tif (id.b24 == 0 || wwn == 0)\n\t\t\tcontinue;\n\n\t\tif (fc4_type == FC4_TYPE_FCP_SCSI) {\n\t\t\tif (cmd == GPN_FT_CMD) {\n\t\t\t\trp = &vha->scan.l[j];\n\t\t\t\trp->id = id;\n\t\t\t\tmemcpy(rp->port_name, d->port_name, 8);\n\t\t\t\tj++;\n\t\t\t\trp->fc4type = FS_FC4TYPE_FCP;\n\t\t\t} else {\n\t\t\t\tfor (k = 0; k < num_fibre_dev; k++) {\n\t\t\t\t\trp = &vha->scan.l[k];\n\t\t\t\t\tif (id.b24 == rp->id.b24) {\n\t\t\t\t\t\tmemcpy(rp->node_name,\n\t\t\t\t\t\t    d->port_name, 8);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (cmd == GPN_FT_CMD) {\n\t\t\t\tfound = 0;\n\n\t\t\t\tfor (k = 0; k < num_fibre_dev; k++) {\n\t\t\t\t\trp = &vha->scan.l[k];\n\t\t\t\t\tif (!memcmp(rp->port_name,\n\t\t\t\t\t    d->port_name, 8)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\trp->fc4type |= FS_FC4TYPE_NVME;\n\t\t\t\t\t\tfound = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (!found) {\n\t\t\t\t\tfor (k = 0; k < num_fibre_dev; k++) {\n\t\t\t\t\t\trp = &vha->scan.l[k];\n\t\t\t\t\t\tif (wwn_to_u64(rp->port_name)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trp->id = id;\n\t\t\t\t\t\t\tmemcpy(rp->port_name,\n\t\t\t\t\t\t\t    d->port_name, 8);\n\t\t\t\t\t\t\trp->fc4type =\n\t\t\t\t\t\t\t    FS_FC4TYPE_NVME;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (k = 0; k < num_fibre_dev; k++) {\n\t\t\t\t\trp = &vha->scan.l[k];\n\t\t\t\t\tif (id.b24 == rp->id.b24) {\n\t\t\t\t\t\tmemcpy(rp->node_name,\n\t\t\t\t\t\t    d->port_name, 8);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void qla2x00_async_gpnft_gnnft_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct ct_sns_req *ct_req =\n\t\t(struct ct_sns_req *)sp->u.iocb_cmd.u.ctarg.req;\n\tu16 cmd = be16_to_cpu(ct_req->command);\n\tu8 fc4_type = sp->gen2;\n\tunsigned long flags;\n\tint rc;\n\n\t \n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"Async done-%s res %x FC4Type %x\\n\",\n\t    sp->name, res, sp->gen2);\n\n\tsp->rc = res;\n\tif (res) {\n\t\tunsigned long flags;\n\t\tconst char *name = sp->name;\n\n\t\tif (res == QLA_OS_TIMER_EXPIRED) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t       \"%s: Switch Zone check please .\\n\",\n\t\t\t       name);\n\t\t\tqla2x00_mark_all_devices_lost(vha);\n\t\t}\n\n\t\t \n\t\trc = qla2x00_post_gnnft_gpnft_done_work(vha, sp,\n\t\t    QLA_EVT_GNNFT_DONE);\n\t\tif (rc) {\n\t\t\t \n\t\t\tqla24xx_sp_unmap(vha, sp);\n\n\t\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\t\tvha->scan.scan_flags &= ~SF_SCANNING;\n\t\t\tvha->scan.scan_retry++;\n\t\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\t\t\tif (vha->scan.scan_retry < MAX_SCAN_RETRIES) {\n\t\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t} else {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t\t    \"Async done-%s rescan failed on all retries.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tqla2x00_find_free_fcp_nvme_slot(vha, sp);\n\n\tif ((fc4_type == FC4_TYPE_FCP_SCSI) && vha->flags.nvme_enabled &&\n\t    cmd == GNN_FT_CMD) {\n\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\tvha->scan.scan_flags &= ~SF_SCANNING;\n\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\t\tsp->rc = res;\n\t\trc = qla2x00_post_nvme_gpnft_work(vha, sp, QLA_EVT_GPNFT);\n\t\tif (rc) {\n\t\t\tqla24xx_sp_unmap(vha, sp);\n\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (cmd == GPN_FT_CMD) {\n\t\trc = qla2x00_post_gnnft_gpnft_done_work(vha, sp,\n\t\t    QLA_EVT_GPNFT_DONE);\n\t} else {\n\t\trc = qla2x00_post_gnnft_gpnft_done_work(vha, sp,\n\t\t    QLA_EVT_GNNFT_DONE);\n\t}\n\n\tif (rc) {\n\t\tqla24xx_sp_unmap(vha, sp);\n\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\treturn;\n\t}\n}\n\n \nstatic int qla24xx_async_gnnft(scsi_qla_host_t *vha, struct srb *sp,\n    u8 fc4_type)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tstruct ct_sns_req *ct_req;\n\tstruct ct_sns_pkt *ct_sns;\n\tunsigned long flags;\n\n\tif (!vha->flags.online) {\n\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\tvha->scan.scan_flags &= ~SF_SCANNING;\n\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\t\tgoto done_free_sp;\n\t}\n\n\tif (!sp->u.iocb_cmd.u.ctarg.req || !sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"%s: req %p rsp %p are not setup\\n\",\n\t\t    __func__, sp->u.iocb_cmd.u.ctarg.req,\n\t\t    sp->u.iocb_cmd.u.ctarg.rsp);\n\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\tvha->scan.scan_flags &= ~SF_SCANNING;\n\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\t\tWARN_ON(1);\n\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\tgoto done_free_sp;\n\t}\n\n\tql_dbg(ql_dbg_disc, vha, 0xfffff,\n\t    \"%s: FC4Type %x, CT-PASSTHRU %s command ctarg rsp size %d, ctarg req size %d\\n\",\n\t    __func__, fc4_type, sp->name, sp->u.iocb_cmd.u.ctarg.rsp_size,\n\t     sp->u.iocb_cmd.u.ctarg.req_size);\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"gnnft\";\n\tsp->gen1 = vha->hw->base_qpair->chip_reset;\n\tsp->gen2 = fc4_type;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_gpnft_gnnft_sp_done);\n\n\tmemset(sp->u.iocb_cmd.u.ctarg.rsp, 0, sp->u.iocb_cmd.u.ctarg.rsp_size);\n\tmemset(sp->u.iocb_cmd.u.ctarg.req, 0, sp->u.iocb_cmd.u.ctarg.req_size);\n\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;\n\t \n\tct_req = qla2x00_prep_ct_req(ct_sns, GNN_FT_CMD,\n\t    sp->u.iocb_cmd.u.ctarg.rsp_size);\n\n\t \n\tct_req->req.gpn_ft.port_type = fc4_type;\n\n\tsp->u.iocb_cmd.u.ctarg.req_size = GNN_FT_REQ_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"Async-%s hdl=%x FC4Type %x.\\n\", sp->name,\n\t    sp->handle, ct_req->req.gpn_ft.port_type);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\tif (sp->u.iocb_cmd.u.ctarg.req) {\n\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t    sp->u.iocb_cmd.u.ctarg.req_allocated_size,\n\t\t    sp->u.iocb_cmd.u.ctarg.req,\n\t\t    sp->u.iocb_cmd.u.ctarg.req_dma);\n\t\tsp->u.iocb_cmd.u.ctarg.req = NULL;\n\t}\n\tif (sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t    sp->u.iocb_cmd.u.ctarg.rsp_allocated_size,\n\t\t    sp->u.iocb_cmd.u.ctarg.rsp,\n\t\t    sp->u.iocb_cmd.u.ctarg.rsp_dma);\n\t\tsp->u.iocb_cmd.u.ctarg.rsp = NULL;\n\t}\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tvha->scan.scan_flags &= ~SF_SCANNING;\n\tif (vha->scan.scan_flags == 0) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t    \"%s: schedule\\n\", __func__);\n\t\tvha->scan.scan_flags |= SF_QUEUED;\n\t\tschedule_delayed_work(&vha->scan.scan_work, 5);\n\t}\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\n\treturn rval;\n}  \n\nvoid qla24xx_async_gpnft_done(scsi_qla_host_t *vha, srb_t *sp)\n{\n\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,\n\t    \"%s enter\\n\", __func__);\n\tqla24xx_async_gnnft(vha, sp, sp->gen2);\n}\n\n \nint qla24xx_async_gpnft(scsi_qla_host_t *vha, u8 fc4_type, srb_t *sp)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tstruct ct_sns_req       *ct_req;\n\tstruct ct_sns_pkt *ct_sns;\n\tu32 rspsz;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,\n\t    \"%s enter\\n\", __func__);\n\n\tif (!vha->flags.online)\n\t\treturn rval;\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tif (vha->scan.scan_flags & SF_SCANNING) {\n\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,\n\t\t    \"%s: scan active\\n\", __func__);\n\t\treturn rval;\n\t}\n\tvha->scan.scan_flags |= SF_SCANNING;\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\tif (fc4_type == FC4_TYPE_FCP_SCSI) {\n\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,\n\t\t    \"%s: Performing FCP Scan\\n\", __func__);\n\n\t\tif (sp) {\n\t\t\t \n\t\t\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\t\t}\n\n\t\t \n\t\tsp = qla2x00_get_sp(vha, NULL, GFP_KERNEL);\n\t\tif (!sp) {\n\t\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\t\tvha->scan.scan_flags &= ~SF_SCANNING;\n\t\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\t\t\treturn rval;\n\t\t}\n\n\t\tsp->u.iocb_cmd.u.ctarg.req = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t\t\t\t\t\t\t\tsizeof(struct ct_sns_pkt),\n\t\t\t\t\t\t\t\t&sp->u.iocb_cmd.u.ctarg.req_dma,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tsp->u.iocb_cmd.u.ctarg.req_allocated_size = sizeof(struct ct_sns_pkt);\n\t\tif (!sp->u.iocb_cmd.u.ctarg.req) {\n\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t    \"Failed to allocate ct_sns request.\\n\");\n\t\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\t\tvha->scan.scan_flags &= ~SF_SCANNING;\n\t\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\t\t\tqla2x00_rel_sp(sp);\n\t\t\treturn rval;\n\t\t}\n\t\tsp->u.iocb_cmd.u.ctarg.req_size = GPN_FT_REQ_SIZE;\n\n\t\trspsz = sizeof(struct ct_sns_gpnft_rsp) +\n\t\t\tvha->hw->max_fibre_devices *\n\t\t\t    sizeof(struct ct_sns_gpn_ft_data);\n\n\t\tsp->u.iocb_cmd.u.ctarg.rsp = dma_alloc_coherent(&vha->hw->pdev->dev,\n\t\t\t\t\t\t\t\trspsz,\n\t\t\t\t\t\t\t\t&sp->u.iocb_cmd.u.ctarg.rsp_dma,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tsp->u.iocb_cmd.u.ctarg.rsp_allocated_size = rspsz;\n\t\tif (!sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t    \"Failed to allocate ct_sns request.\\n\");\n\t\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\t\tvha->scan.scan_flags &= ~SF_SCANNING;\n\t\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\t\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req_allocated_size,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req,\n\t\t\t    sp->u.iocb_cmd.u.ctarg.req_dma);\n\t\t\tsp->u.iocb_cmd.u.ctarg.req = NULL;\n\t\t\t \n\t\t\tqla2x00_rel_sp(sp);\n\t\t\treturn rval;\n\t\t}\n\t\tsp->u.iocb_cmd.u.ctarg.rsp_size = rspsz;\n\n\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,\n\t\t    \"%s scan list size %d\\n\", __func__, vha->scan.size);\n\n\t\tmemset(vha->scan.l, 0, vha->scan.size);\n\t} else if (!sp) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t    \"NVME scan did not provide SP\\n\");\n\t\treturn rval;\n\t}\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"gpnft\";\n\tsp->gen1 = vha->hw->base_qpair->chip_reset;\n\tsp->gen2 = fc4_type;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_gpnft_gnnft_sp_done);\n\n\trspsz = sp->u.iocb_cmd.u.ctarg.rsp_size;\n\tmemset(sp->u.iocb_cmd.u.ctarg.rsp, 0, sp->u.iocb_cmd.u.ctarg.rsp_size);\n\tmemset(sp->u.iocb_cmd.u.ctarg.req, 0, sp->u.iocb_cmd.u.ctarg.req_size);\n\n\tct_sns = (struct ct_sns_pkt *)sp->u.iocb_cmd.u.ctarg.req;\n\t \n\tct_req = qla2x00_prep_ct_req(ct_sns, GPN_FT_CMD, rspsz);\n\n\t \n\tct_req->req.gpn_ft.port_type = fc4_type;\n\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"Async-%s hdl=%x FC4Type %x.\\n\", sp->name,\n\t    sp->handle, ct_req->req.gpn_ft.port_type);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\n\ndone_free_sp:\n\tif (sp->u.iocb_cmd.u.ctarg.req) {\n\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t    sp->u.iocb_cmd.u.ctarg.req_allocated_size,\n\t\t    sp->u.iocb_cmd.u.ctarg.req,\n\t\t    sp->u.iocb_cmd.u.ctarg.req_dma);\n\t\tsp->u.iocb_cmd.u.ctarg.req = NULL;\n\t}\n\tif (sp->u.iocb_cmd.u.ctarg.rsp) {\n\t\tdma_free_coherent(&vha->hw->pdev->dev,\n\t\t    sp->u.iocb_cmd.u.ctarg.rsp_allocated_size,\n\t\t    sp->u.iocb_cmd.u.ctarg.rsp,\n\t\t    sp->u.iocb_cmd.u.ctarg.rsp_dma);\n\t\tsp->u.iocb_cmd.u.ctarg.rsp = NULL;\n\t}\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tvha->scan.scan_flags &= ~SF_SCANNING;\n\tif (vha->scan.scan_flags == 0) {\n\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,\n\t\t    \"%s: Scan scheduled.\\n\", __func__);\n\t\tvha->scan.scan_flags |= SF_QUEUED;\n\t\tschedule_delayed_work(&vha->scan.scan_work, 5);\n\t}\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\n\treturn rval;\n}\n\nvoid qla_scan_work_fn(struct work_struct *work)\n{\n\tstruct fab_scan *s = container_of(to_delayed_work(work),\n\t    struct fab_scan, scan_work);\n\tstruct scsi_qla_host *vha = container_of(s, struct scsi_qla_host,\n\t    scan);\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"%s: schedule loop resync\\n\", __func__);\n\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\tqla2xxx_wake_dpc(vha);\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tvha->scan.scan_flags &= ~SF_QUEUED;\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n}\n\n \nvoid qla24xx_handle_gfpnid_event(scsi_qla_host_t *vha, struct event_arg *ea)\n{\n\tfc_port_t *fcport = ea->fcport;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"%s %8phC DS %d LS %d rc %d login %d|%d rscn %d|%d fcpcnt %d\\n\",\n\t    __func__, fcport->port_name, fcport->disc_state,\n\t    fcport->fw_login_state, ea->rc, fcport->login_gen, ea->sp->gen2,\n\t    fcport->rscn_gen, ea->sp->gen1, vha->fcport_count);\n\n\tif (fcport->disc_state == DSC_DELETE_PEND)\n\t\treturn;\n\n\tif (ea->sp->gen2 != fcport->login_gen) {\n\t\t \n\t\tql_dbg(ql_dbg_disc, vha, 0x20d3,\n\t\t    \"%s %8phC generation changed\\n\",\n\t\t    __func__, fcport->port_name);\n\t\treturn;\n\t} else if (ea->sp->gen1 != fcport->rscn_gen) {\n\t\treturn;\n\t}\n\n\tqla24xx_post_gpsc_work(vha, fcport);\n}\n\nstatic void qla2x00_async_gfpnid_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tfc_port_t *fcport = sp->fcport;\n\tu8 *fpn = fcport->ct_desc.ct_sns->p.rsp.rsp.gfpn_id.port_name;\n\tstruct event_arg ea;\n\tu64 wwn;\n\n\twwn = wwn_to_u64(fpn);\n\tif (wwn)\n\t\tmemcpy(fcport->fabric_port_name, fpn, WWN_SIZE);\n\n\tmemset(&ea, 0, sizeof(ea));\n\tea.fcport = fcport;\n\tea.sp = sp;\n\tea.rc = res;\n\n\tql_dbg(ql_dbg_disc, vha, 0x204f,\n\t    \"Async done-%s res %x, WWPN %8phC %8phC\\n\",\n\t    sp->name, res, fcport->port_name, fcport->fabric_port_name);\n\n\tqla24xx_handle_gfpnid_event(vha, &ea);\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint qla24xx_async_gfpnid(scsi_qla_host_t *vha, fc_port_t *fcport)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tstruct ct_sns_req       *ct_req;\n\tsrb_t *sp;\n\n\tif (!vha->flags.online || (fcport->flags & FCF_ASYNC_SENT))\n\t\treturn rval;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = SRB_CT_PTHRU_CMD;\n\tsp->name = \"gfpnid\";\n\tsp->gen1 = fcport->rscn_gen;\n\tsp->gen2 = fcport->login_gen;\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_gfpnid_sp_done);\n\n\t \n\tct_req = qla2x00_prep_ct_req(fcport->ct_desc.ct_sns, GFPN_ID_CMD,\n\t    GFPN_ID_RSP_SIZE);\n\n\t \n\tct_req->req.port_id.port_id = port_id_to_be_id(fcport->d_id);\n\n\n\t \n\tsp->u.iocb_cmd.u.ctarg.req = fcport->ct_desc.ct_sns;\n\tsp->u.iocb_cmd.u.ctarg.req_dma = fcport->ct_desc.ct_sns_dma;\n\tsp->u.iocb_cmd.u.ctarg.rsp = fcport->ct_desc.ct_sns;\n\tsp->u.iocb_cmd.u.ctarg.rsp_dma = fcport->ct_desc.ct_sns_dma;\n\tsp->u.iocb_cmd.u.ctarg.req_size = GFPN_ID_REQ_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.rsp_size = GFPN_ID_RSP_SIZE;\n\tsp->u.iocb_cmd.u.ctarg.nport_handle = NPH_SNS;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"Async-%s - %8phC hdl=%x loopid=%x portid %06x.\\n\",\n\t    sp->name, fcport->port_name,\n\t    sp->handle, fcport->loop_id, fcport->d_id.b24);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\n\treturn rval;\n\ndone_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\treturn rval;\n}\n\nint qla24xx_post_gfpnid_work(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_work_evt *e;\n\tint ls;\n\n\tls = atomic_read(&vha->loop_state);\n\tif (((ls != LOOP_READY) && (ls != LOOP_UP)) ||\n\t\ttest_bit(UNLOADING, &vha->dpc_flags))\n\t\treturn 0;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_GFPNID);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.fcport.fcport = fcport;\n\treturn qla2x00_post_work(vha, e);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}