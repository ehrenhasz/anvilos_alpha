{
  "module_name": "qla_sup.c",
  "hash_id": "3169e1445a6188fd5a578fe179b10b28c5e5070eadb1c8a27a5a3ad4f4d40ec5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_sup.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n\n \n\n \nstatic void\nqla2x00_lock_nvram_access(struct qla_hw_data *ha)\n{\n\tuint16_t data;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tif (!IS_QLA2100(ha) && !IS_QLA2200(ha) && !IS_QLA2300(ha)) {\n\t\tdata = rd_reg_word(&reg->nvram);\n\t\twhile (data & NVR_BUSY) {\n\t\t\tudelay(100);\n\t\t\tdata = rd_reg_word(&reg->nvram);\n\t\t}\n\n\t\t \n\t\twrt_reg_word(&reg->u.isp2300.host_semaphore, 0x1);\n\t\trd_reg_word(&reg->u.isp2300.host_semaphore);\n\t\tudelay(5);\n\t\tdata = rd_reg_word(&reg->u.isp2300.host_semaphore);\n\t\twhile ((data & BIT_0) == 0) {\n\t\t\t \n\t\t\tudelay(100);\n\t\t\twrt_reg_word(&reg->u.isp2300.host_semaphore, 0x1);\n\t\t\trd_reg_word(&reg->u.isp2300.host_semaphore);\n\t\t\tudelay(5);\n\t\t\tdata = rd_reg_word(&reg->u.isp2300.host_semaphore);\n\t\t}\n\t}\n}\n\n \nstatic void\nqla2x00_unlock_nvram_access(struct qla_hw_data *ha)\n{\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tif (!IS_QLA2100(ha) && !IS_QLA2200(ha) && !IS_QLA2300(ha)) {\n\t\twrt_reg_word(&reg->u.isp2300.host_semaphore, 0);\n\t\trd_reg_word(&reg->u.isp2300.host_semaphore);\n\t}\n}\n\n \nstatic void\nqla2x00_nv_write(struct qla_hw_data *ha, uint16_t data)\n{\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\twrt_reg_word(&reg->nvram, data | NVR_SELECT | NVR_WRT_ENABLE);\n\trd_reg_word(&reg->nvram);\t\t \n\tNVRAM_DELAY();\n\twrt_reg_word(&reg->nvram, data | NVR_SELECT | NVR_CLOCK |\n\t    NVR_WRT_ENABLE);\n\trd_reg_word(&reg->nvram);\t\t \n\tNVRAM_DELAY();\n\twrt_reg_word(&reg->nvram, data | NVR_SELECT | NVR_WRT_ENABLE);\n\trd_reg_word(&reg->nvram);\t\t \n\tNVRAM_DELAY();\n}\n\n \nstatic uint16_t\nqla2x00_nvram_request(struct qla_hw_data *ha, uint32_t nv_cmd)\n{\n\tuint8_t\t\tcnt;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tuint16_t\tdata = 0;\n\tuint16_t\treg_data;\n\n\t \n\tnv_cmd <<= 5;\n\tfor (cnt = 0; cnt < 11; cnt++) {\n\t\tif (nv_cmd & BIT_31)\n\t\t\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\t\telse\n\t\t\tqla2x00_nv_write(ha, 0);\n\t\tnv_cmd <<= 1;\n\t}\n\n\t \n\tfor (cnt = 0; cnt < 16; cnt++) {\n\t\twrt_reg_word(&reg->nvram, NVR_SELECT | NVR_CLOCK);\n\t\trd_reg_word(&reg->nvram);\t \n\t\tNVRAM_DELAY();\n\t\tdata <<= 1;\n\t\treg_data = rd_reg_word(&reg->nvram);\n\t\tif (reg_data & NVR_DATA_IN)\n\t\t\tdata |= BIT_0;\n\t\twrt_reg_word(&reg->nvram, NVR_SELECT);\n\t\trd_reg_word(&reg->nvram);\t \n\t\tNVRAM_DELAY();\n\t}\n\n\t \n\twrt_reg_word(&reg->nvram, NVR_DESELECT);\n\trd_reg_word(&reg->nvram);\t\t \n\tNVRAM_DELAY();\n\n\treturn data;\n}\n\n\n \nstatic uint16_t\nqla2x00_get_nvram_word(struct qla_hw_data *ha, uint32_t addr)\n{\n\tuint16_t\tdata;\n\tuint32_t\tnv_cmd;\n\n\tnv_cmd = addr << 16;\n\tnv_cmd |= NV_READ_OP;\n\tdata = qla2x00_nvram_request(ha, nv_cmd);\n\n\treturn (data);\n}\n\n \nstatic void\nqla2x00_nv_deselect(struct qla_hw_data *ha)\n{\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\twrt_reg_word(&reg->nvram, NVR_DESELECT);\n\trd_reg_word(&reg->nvram);\t\t \n\tNVRAM_DELAY();\n}\n\n \nstatic void\nqla2x00_write_nvram_word(struct qla_hw_data *ha, uint32_t addr, __le16 data)\n{\n\tint count;\n\tuint16_t word;\n\tuint32_t nv_cmd, wait_cnt;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\tqla2x00_nv_write(ha, 0);\n\tqla2x00_nv_write(ha, 0);\n\n\tfor (word = 0; word < 8; word++)\n\t\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\tnv_cmd = (addr << 16) | NV_WRITE_OP;\n\tnv_cmd |= (__force u16)data;\n\tnv_cmd <<= 5;\n\tfor (count = 0; count < 27; count++) {\n\t\tif (nv_cmd & BIT_31)\n\t\t\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\t\telse\n\t\t\tqla2x00_nv_write(ha, 0);\n\n\t\tnv_cmd <<= 1;\n\t}\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\twrt_reg_word(&reg->nvram, NVR_SELECT);\n\trd_reg_word(&reg->nvram);\t\t \n\twait_cnt = NVR_WAIT_CNT;\n\tdo {\n\t\tif (!--wait_cnt) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x708d,\n\t\t\t    \"NVRAM didn't go ready...\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tNVRAM_DELAY();\n\t\tword = rd_reg_word(&reg->nvram);\n\t} while ((word & NVR_DATA_IN) == 0);\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\tfor (count = 0; count < 10; count++)\n\t\tqla2x00_nv_write(ha, 0);\n\n\tqla2x00_nv_deselect(ha);\n}\n\nstatic int\nqla2x00_write_nvram_word_tmo(struct qla_hw_data *ha, uint32_t addr,\n\t\t\t     __le16 data, uint32_t tmo)\n{\n\tint ret, count;\n\tuint16_t word;\n\tuint32_t nv_cmd;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tret = QLA_SUCCESS;\n\n\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\tqla2x00_nv_write(ha, 0);\n\tqla2x00_nv_write(ha, 0);\n\n\tfor (word = 0; word < 8; word++)\n\t\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\tnv_cmd = (addr << 16) | NV_WRITE_OP;\n\tnv_cmd |= (__force u16)data;\n\tnv_cmd <<= 5;\n\tfor (count = 0; count < 27; count++) {\n\t\tif (nv_cmd & BIT_31)\n\t\t\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\t\telse\n\t\t\tqla2x00_nv_write(ha, 0);\n\n\t\tnv_cmd <<= 1;\n\t}\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\twrt_reg_word(&reg->nvram, NVR_SELECT);\n\trd_reg_word(&reg->nvram);\t\t \n\tdo {\n\t\tNVRAM_DELAY();\n\t\tword = rd_reg_word(&reg->nvram);\n\t\tif (!--tmo) {\n\t\t\tret = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\t} while ((word & NVR_DATA_IN) == 0);\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\tfor (count = 0; count < 10; count++)\n\t\tqla2x00_nv_write(ha, 0);\n\n\tqla2x00_nv_deselect(ha);\n\n\treturn ret;\n}\n\n \nstatic int\nqla2x00_clear_nvram_protection(struct qla_hw_data *ha)\n{\n\tint ret, stat;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tuint32_t word, wait_cnt;\n\t__le16 wprot, wprot_old;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\t \n\tret = QLA_FUNCTION_FAILED;\n\n\twprot_old = cpu_to_le16(qla2x00_get_nvram_word(ha, ha->nvram_base));\n\tstat = qla2x00_write_nvram_word_tmo(ha, ha->nvram_base,\n\t\t\t\t\t    cpu_to_le16(0x1234), 100000);\n\twprot = cpu_to_le16(qla2x00_get_nvram_word(ha, ha->nvram_base));\n\tif (stat != QLA_SUCCESS || wprot != cpu_to_le16(0x1234)) {\n\t\t \n\t\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\t\tqla2x00_nv_write(ha, 0);\n\t\tqla2x00_nv_write(ha, 0);\n\t\tfor (word = 0; word < 8; word++)\n\t\t\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\n\t\tqla2x00_nv_deselect(ha);\n\n\t\t \n\t\tqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\n\t\tqla2x00_nv_write(ha, NVR_PR_ENABLE);\n\t\tqla2x00_nv_write(ha, NVR_PR_ENABLE);\n\t\tfor (word = 0; word < 8; word++)\n\t\t\tqla2x00_nv_write(ha, NVR_DATA_OUT | NVR_PR_ENABLE);\n\n\t\tqla2x00_nv_deselect(ha);\n\n\t\t \n\t\tqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\n\t\tqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\n\t\tqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\n\t\tfor (word = 0; word < 8; word++)\n\t\t\tqla2x00_nv_write(ha, NVR_DATA_OUT | NVR_PR_ENABLE);\n\n\t\tqla2x00_nv_deselect(ha);\n\n\t\t \n\t\twrt_reg_word(&reg->nvram, NVR_SELECT);\n\t\trd_reg_word(&reg->nvram);\t \n\t\twait_cnt = NVR_WAIT_CNT;\n\t\tdo {\n\t\t\tif (!--wait_cnt) {\n\t\t\t\tql_dbg(ql_dbg_user, vha, 0x708e,\n\t\t\t\t    \"NVRAM didn't go ready...\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tNVRAM_DELAY();\n\t\t\tword = rd_reg_word(&reg->nvram);\n\t\t} while ((word & NVR_DATA_IN) == 0);\n\n\t\tif (wait_cnt)\n\t\t\tret = QLA_SUCCESS;\n\t} else\n\t\tqla2x00_write_nvram_word(ha, ha->nvram_base, wprot_old);\n\n\treturn ret;\n}\n\nstatic void\nqla2x00_set_nvram_protection(struct qla_hw_data *ha, int stat)\n{\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tuint32_t word, wait_cnt;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tif (stat != QLA_SUCCESS)\n\t\treturn;\n\n\t \n\t \n\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\tqla2x00_nv_write(ha, 0);\n\tqla2x00_nv_write(ha, 0);\n\tfor (word = 0; word < 8; word++)\n\t\tqla2x00_nv_write(ha, NVR_DATA_OUT);\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\tqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\n\tqla2x00_nv_write(ha, NVR_PR_ENABLE);\n\tqla2x00_nv_write(ha, NVR_PR_ENABLE);\n\tfor (word = 0; word < 8; word++)\n\t\tqla2x00_nv_write(ha, NVR_DATA_OUT | NVR_PR_ENABLE);\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\tqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\n\tqla2x00_nv_write(ha, NVR_PR_ENABLE);\n\tqla2x00_nv_write(ha, NVR_PR_ENABLE | NVR_DATA_OUT);\n\tfor (word = 0; word < 8; word++)\n\t\tqla2x00_nv_write(ha, NVR_PR_ENABLE);\n\n\tqla2x00_nv_deselect(ha);\n\n\t \n\twrt_reg_word(&reg->nvram, NVR_SELECT);\n\trd_reg_word(&reg->nvram);\t\t \n\twait_cnt = NVR_WAIT_CNT;\n\tdo {\n\t\tif (!--wait_cnt) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x708f,\n\t\t\t    \"NVRAM didn't go ready...\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tNVRAM_DELAY();\n\t\tword = rd_reg_word(&reg->nvram);\n\t} while ((word & NVR_DATA_IN) == 0);\n}\n\n\n \n \n \n\nstatic inline uint32_t\nflash_conf_addr(struct qla_hw_data *ha, uint32_t faddr)\n{\n\treturn ha->flash_conf_off + faddr;\n}\n\nstatic inline uint32_t\nflash_data_addr(struct qla_hw_data *ha, uint32_t faddr)\n{\n\treturn ha->flash_data_off + faddr;\n}\n\nstatic inline uint32_t\nnvram_conf_addr(struct qla_hw_data *ha, uint32_t naddr)\n{\n\treturn ha->nvram_conf_off + naddr;\n}\n\nstatic inline uint32_t\nnvram_data_addr(struct qla_hw_data *ha, uint32_t naddr)\n{\n\treturn ha->nvram_data_off + naddr;\n}\n\nstatic int\nqla24xx_read_flash_dword(struct qla_hw_data *ha, uint32_t addr, uint32_t *data)\n{\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\tulong cnt = 30000;\n\n\twrt_reg_dword(&reg->flash_addr, addr & ~FARX_DATA_FLAG);\n\n\twhile (cnt--) {\n\t\tif (rd_reg_dword(&reg->flash_addr) & FARX_DATA_FLAG) {\n\t\t\t*data = rd_reg_dword(&reg->flash_data);\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\t\tudelay(10);\n\t\tcond_resched();\n\t}\n\n\tql_log(ql_log_warn, pci_get_drvdata(ha->pdev), 0x7090,\n\t    \"Flash read dword at %x timeout.\\n\", addr);\n\t*data = 0xDEADDEAD;\n\treturn QLA_FUNCTION_TIMEOUT;\n}\n\nint\nqla24xx_read_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,\n    uint32_t dwords)\n{\n\tulong i;\n\tint ret = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tfaddr =  flash_data_addr(ha, faddr);\n\tfor (i = 0; i < dwords; i++, faddr++, dwptr++) {\n\t\tret = qla24xx_read_flash_dword(ha, faddr, dwptr);\n\t\tif (ret != QLA_SUCCESS)\n\t\t\tbreak;\n\t\tcpu_to_le32s(dwptr);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nqla24xx_write_flash_dword(struct qla_hw_data *ha, uint32_t addr, uint32_t data)\n{\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\tulong cnt = 500000;\n\n\twrt_reg_dword(&reg->flash_data, data);\n\twrt_reg_dword(&reg->flash_addr, addr | FARX_DATA_FLAG);\n\n\twhile (cnt--) {\n\t\tif (!(rd_reg_dword(&reg->flash_addr) & FARX_DATA_FLAG))\n\t\t\treturn QLA_SUCCESS;\n\t\tudelay(10);\n\t\tcond_resched();\n\t}\n\n\tql_log(ql_log_warn, pci_get_drvdata(ha->pdev), 0x7090,\n\t    \"Flash write dword at %x timeout.\\n\", addr);\n\treturn QLA_FUNCTION_TIMEOUT;\n}\n\nstatic void\nqla24xx_get_flash_manufacturer(struct qla_hw_data *ha, uint8_t *man_id,\n    uint8_t *flash_id)\n{\n\tuint32_t faddr, ids = 0;\n\n\t*man_id = *flash_id = 0;\n\n\tfaddr = flash_conf_addr(ha, 0x03ab);\n\tif (!qla24xx_read_flash_dword(ha, faddr, &ids)) {\n\t\t*man_id = LSB(ids);\n\t\t*flash_id = MSB(ids);\n\t}\n\n\t \n\tif (ids != 0xDEADDEAD && (*man_id == 0 || *flash_id == 0)) {\n\t\t \n\t\tfaddr = flash_conf_addr(ha, 0x009f);\n\t\tif (!qla24xx_read_flash_dword(ha, faddr, &ids)) {\n\t\t\t*man_id = LSB(ids);\n\t\t\t*flash_id = MSB(ids);\n\t\t}\n\t}\n}\n\nstatic int\nqla2xxx_find_flt_start(scsi_qla_host_t *vha, uint32_t *start)\n{\n\tconst char *loc, *locations[] = { \"DEF\", \"PCI\" };\n\tuint32_t pcihdr, pcids;\n\tuint16_t cnt, chksum;\n\t__le16 *wptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct qla_flt_location *fltl = (void *)req->ring;\n\tuint32_t *dcode = (uint32_t *)req->ring;\n\tuint8_t *buf = (void *)req->ring, *bcode,  last_image;\n\n\t \n\n\t \n\tloc = locations[0];\n\t*start = 0;\n\tif (IS_QLA24XX_TYPE(ha))\n\t\t*start = FA_FLASH_LAYOUT_ADDR_24;\n\telse if (IS_QLA25XX(ha))\n\t\t*start = FA_FLASH_LAYOUT_ADDR;\n\telse if (IS_QLA81XX(ha))\n\t\t*start = FA_FLASH_LAYOUT_ADDR_81;\n\telse if (IS_P3P_TYPE(ha)) {\n\t\t*start = FA_FLASH_LAYOUT_ADDR_82;\n\t\tgoto end;\n\t} else if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {\n\t\t*start = FA_FLASH_LAYOUT_ADDR_83;\n\t\tgoto end;\n\t} else if (IS_QLA28XX(ha)) {\n\t\t*start = FA_FLASH_LAYOUT_ADDR_28;\n\t\tgoto end;\n\t}\n\n\t \n\tpcihdr = 0;\n\tdo {\n\t\t \n\t\tqla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 0x20);\n\t\tbcode = buf + (pcihdr % 4);\n\t\tif (bcode[0x0] != 0x55 || bcode[0x1] != 0xaa)\n\t\t\tgoto end;\n\n\t\t \n\t\tpcids = pcihdr + ((bcode[0x19] << 8) | bcode[0x18]);\n\t\tqla24xx_read_flash_data(vha, dcode, pcids >> 2, 0x20);\n\t\tbcode = buf + (pcihdr % 4);\n\n\t\t \n\t\tif (bcode[0x0] != 'P' || bcode[0x1] != 'C' ||\n\t\t    bcode[0x2] != 'I' || bcode[0x3] != 'R')\n\t\t\tgoto end;\n\n\t\tlast_image = bcode[0x15] & BIT_7;\n\n\t\t \n\t\tpcihdr += ((bcode[0x11] << 8) | bcode[0x10]) * 512;\n\t} while (!last_image);\n\n\t \n\tqla24xx_read_flash_data(vha, dcode, pcihdr >> 2, sizeof(*fltl) >> 2);\n\tif (memcmp(fltl->sig, \"QFLT\", 4))\n\t\tgoto end;\n\n\twptr = (__force __le16 *)req->ring;\n\tcnt = sizeof(*fltl) / sizeof(*wptr);\n\tfor (chksum = 0; cnt--; wptr++)\n\t\tchksum += le16_to_cpu(*wptr);\n\tif (chksum) {\n\t\tql_log(ql_log_fatal, vha, 0x0045,\n\t\t    \"Inconsistent FLTL detected: checksum=0x%x.\\n\", chksum);\n\t\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010e,\n\t\t    fltl, sizeof(*fltl));\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\t \n\tloc = locations[1];\n\t*start = (le16_to_cpu(fltl->start_hi) << 16 |\n\t    le16_to_cpu(fltl->start_lo)) >> 2;\nend:\n\tql_dbg(ql_dbg_init, vha, 0x0046,\n\t    \"FLTL[%s] = 0x%x.\\n\",\n\t    loc, *start);\n\treturn QLA_SUCCESS;\n}\n\nstatic void\nqla2xxx_get_flt_info(scsi_qla_host_t *vha, uint32_t flt_addr)\n{\n\tconst char *locations[] = { \"DEF\", \"FLT\" }, *loc = locations[1];\n\tconst uint32_t def_fw[] =\n\t\t{ FA_RISC_CODE_ADDR, FA_RISC_CODE_ADDR, FA_RISC_CODE_ADDR_81 };\n\tconst uint32_t def_boot[] =\n\t\t{ FA_BOOT_CODE_ADDR, FA_BOOT_CODE_ADDR, FA_BOOT_CODE_ADDR_81 };\n\tconst uint32_t def_vpd_nvram[] =\n\t\t{ FA_VPD_NVRAM_ADDR, FA_VPD_NVRAM_ADDR, FA_VPD_NVRAM_ADDR_81 };\n\tconst uint32_t def_vpd0[] =\n\t\t{ 0, 0, FA_VPD0_ADDR_81 };\n\tconst uint32_t def_vpd1[] =\n\t\t{ 0, 0, FA_VPD1_ADDR_81 };\n\tconst uint32_t def_nvram0[] =\n\t\t{ 0, 0, FA_NVRAM0_ADDR_81 };\n\tconst uint32_t def_nvram1[] =\n\t\t{ 0, 0, FA_NVRAM1_ADDR_81 };\n\tconst uint32_t def_fdt[] =\n\t\t{ FA_FLASH_DESCR_ADDR_24, FA_FLASH_DESCR_ADDR,\n\t\t\tFA_FLASH_DESCR_ADDR_81 };\n\tconst uint32_t def_npiv_conf0[] =\n\t\t{ FA_NPIV_CONF0_ADDR_24, FA_NPIV_CONF0_ADDR,\n\t\t\tFA_NPIV_CONF0_ADDR_81 };\n\tconst uint32_t def_npiv_conf1[] =\n\t\t{ FA_NPIV_CONF1_ADDR_24, FA_NPIV_CONF1_ADDR,\n\t\t\tFA_NPIV_CONF1_ADDR_81 };\n\tconst uint32_t fcp_prio_cfg0[] =\n\t\t{ FA_FCP_PRIO0_ADDR, FA_FCP_PRIO0_ADDR_25,\n\t\t\t0 };\n\tconst uint32_t fcp_prio_cfg1[] =\n\t\t{ FA_FCP_PRIO1_ADDR, FA_FCP_PRIO1_ADDR_25,\n\t\t\t0 };\n\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t def = IS_QLA81XX(ha) ? 2 : IS_QLA25XX(ha) ? 1 : 0;\n\tstruct qla_flt_header *flt = ha->flt;\n\tstruct qla_flt_region *region = &flt->region[0];\n\t__le16 *wptr;\n\tuint16_t cnt, chksum;\n\tuint32_t start;\n\n\t \n\tha->flt_region_fcp_prio = (ha->port_no == 0) ?\n\t    fcp_prio_cfg0[def] : fcp_prio_cfg1[def];\n\n\tha->flt_region_flt = flt_addr;\n\twptr = (__force __le16 *)ha->flt;\n\tha->isp_ops->read_optrom(vha, flt, flt_addr << 2,\n\t    (sizeof(struct qla_flt_header) + FLT_REGIONS_SIZE));\n\n\tif (le16_to_cpu(*wptr) == 0xffff)\n\t\tgoto no_flash_data;\n\tif (flt->version != cpu_to_le16(1)) {\n\t\tql_log(ql_log_warn, vha, 0x0047,\n\t\t    \"Unsupported FLT detected: version=0x%x length=0x%x checksum=0x%x.\\n\",\n\t\t    le16_to_cpu(flt->version), le16_to_cpu(flt->length),\n\t\t    le16_to_cpu(flt->checksum));\n\t\tgoto no_flash_data;\n\t}\n\n\tcnt = (sizeof(*flt) + le16_to_cpu(flt->length)) / sizeof(*wptr);\n\tfor (chksum = 0; cnt--; wptr++)\n\t\tchksum += le16_to_cpu(*wptr);\n\tif (chksum) {\n\t\tql_log(ql_log_fatal, vha, 0x0048,\n\t\t    \"Inconsistent FLT detected: version=0x%x length=0x%x checksum=0x%x.\\n\",\n\t\t    le16_to_cpu(flt->version), le16_to_cpu(flt->length),\n\t\t    le16_to_cpu(flt->checksum));\n\t\tgoto no_flash_data;\n\t}\n\n\tcnt = le16_to_cpu(flt->length) / sizeof(*region);\n\tfor ( ; cnt; cnt--, region++) {\n\t\t \n\t\tstart = le32_to_cpu(region->start) >> 2;\n\t\tql_dbg(ql_dbg_init, vha, 0x0049,\n\t\t    \"FLT[%#x]: start=%#x end=%#x size=%#x.\\n\",\n\t\t    le16_to_cpu(region->code), start,\n\t\t    le32_to_cpu(region->end) >> 2,\n\t\t    le32_to_cpu(region->size) >> 2);\n\t\tif (region->attribute)\n\t\t\tql_log(ql_dbg_init, vha, 0xffff,\n\t\t\t    \"Region %x is secure\\n\", region->code);\n\n\t\tswitch (le16_to_cpu(region->code)) {\n\t\tcase FLT_REG_FCOE_FW:\n\t\t\tif (!IS_QLA8031(ha))\n\t\t\t\tbreak;\n\t\t\tha->flt_region_fw = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FW:\n\t\t\tif (IS_QLA8031(ha))\n\t\t\t\tbreak;\n\t\t\tha->flt_region_fw = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_BOOT_CODE:\n\t\t\tha->flt_region_boot = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_0:\n\t\t\tif (IS_QLA8031(ha))\n\t\t\t\tbreak;\n\t\t\tha->flt_region_vpd_nvram = start;\n\t\t\tif (IS_P3P_TYPE(ha))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 0)\n\t\t\t\tha->flt_region_vpd = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_1:\n\t\t\tif (IS_P3P_TYPE(ha) || IS_QLA8031(ha))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 1)\n\t\t\t\tha->flt_region_vpd = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_2:\n\t\t\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 2)\n\t\t\t\tha->flt_region_vpd = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_3:\n\t\t\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 3)\n\t\t\t\tha->flt_region_vpd = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NVRAM_0:\n\t\t\tif (IS_QLA8031(ha))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 0)\n\t\t\t\tha->flt_region_nvram = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NVRAM_1:\n\t\t\tif (IS_QLA8031(ha))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 1)\n\t\t\t\tha->flt_region_nvram = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NVRAM_2:\n\t\t\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 2)\n\t\t\t\tha->flt_region_nvram = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NVRAM_3:\n\t\t\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 3)\n\t\t\t\tha->flt_region_nvram = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FDT:\n\t\t\tha->flt_region_fdt = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NPIV_CONF_0:\n\t\t\tif (ha->port_no == 0)\n\t\t\t\tha->flt_region_npiv_conf = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NPIV_CONF_1:\n\t\t\tif (ha->port_no == 1)\n\t\t\t\tha->flt_region_npiv_conf = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_GOLD_FW:\n\t\t\tha->flt_region_gold_fw = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FCP_PRIO_0:\n\t\t\tif (ha->port_no == 0)\n\t\t\t\tha->flt_region_fcp_prio = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FCP_PRIO_1:\n\t\t\tif (ha->port_no == 1)\n\t\t\t\tha->flt_region_fcp_prio = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_BOOT_CODE_82XX:\n\t\t\tha->flt_region_boot = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_BOOT_CODE_8044:\n\t\t\tif (IS_QLA8044(ha))\n\t\t\t\tha->flt_region_boot = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FW_82XX:\n\t\t\tha->flt_region_fw = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_CNA_FW:\n\t\t\tif (IS_CNA_CAPABLE(ha))\n\t\t\t\tha->flt_region_fw = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_GOLD_FW_82XX:\n\t\t\tha->flt_region_gold_fw = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_BOOTLOAD_82XX:\n\t\t\tha->flt_region_bootload = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_8XXX:\n\t\t\tif (IS_CNA_CAPABLE(ha))\n\t\t\t\tha->flt_region_vpd = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FCOE_NVRAM_0:\n\t\t\tif (!(IS_QLA8031(ha) || IS_QLA8044(ha)))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 0)\n\t\t\t\tha->flt_region_nvram = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FCOE_NVRAM_1:\n\t\t\tif (!(IS_QLA8031(ha) || IS_QLA8044(ha)))\n\t\t\t\tbreak;\n\t\t\tif (ha->port_no == 1)\n\t\t\t\tha->flt_region_nvram = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_IMG_PRI_27XX:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tha->flt_region_img_status_pri = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_IMG_SEC_27XX:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tha->flt_region_img_status_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FW_SEC_27XX:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tha->flt_region_fw_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_BOOTLOAD_SEC_27XX:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tha->flt_region_boot_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_AUX_IMG_PRI_28XX:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tha->flt_region_aux_img_status_pri = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_AUX_IMG_SEC_28XX:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tha->flt_region_aux_img_status_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NVRAM_SEC_28XX_0:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tif (ha->port_no == 0)\n\t\t\t\t\tha->flt_region_nvram_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NVRAM_SEC_28XX_1:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tif (ha->port_no == 1)\n\t\t\t\t\tha->flt_region_nvram_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NVRAM_SEC_28XX_2:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tif (ha->port_no == 2)\n\t\t\t\t\tha->flt_region_nvram_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_NVRAM_SEC_28XX_3:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tif (ha->port_no == 3)\n\t\t\t\t\tha->flt_region_nvram_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_SEC_27XX_0:\n\t\tcase FLT_REG_VPD_SEC_28XX_0:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\t\tha->flt_region_vpd_nvram_sec = start;\n\t\t\t\tif (ha->port_no == 0)\n\t\t\t\t\tha->flt_region_vpd_sec = start;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_SEC_27XX_1:\n\t\tcase FLT_REG_VPD_SEC_28XX_1:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tif (ha->port_no == 1)\n\t\t\t\t\tha->flt_region_vpd_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_SEC_27XX_2:\n\t\tcase FLT_REG_VPD_SEC_28XX_2:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tif (ha->port_no == 2)\n\t\t\t\t\tha->flt_region_vpd_sec = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_VPD_SEC_27XX_3:\n\t\tcase FLT_REG_VPD_SEC_28XX_3:\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tif (ha->port_no == 3)\n\t\t\t\t\tha->flt_region_vpd_sec = start;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgoto done;\n\nno_flash_data:\n\t \n\tloc = locations[0];\n\tha->flt_region_fw = def_fw[def];\n\tha->flt_region_boot = def_boot[def];\n\tha->flt_region_vpd_nvram = def_vpd_nvram[def];\n\tha->flt_region_vpd = (ha->port_no == 0) ?\n\t    def_vpd0[def] : def_vpd1[def];\n\tha->flt_region_nvram = (ha->port_no == 0) ?\n\t    def_nvram0[def] : def_nvram1[def];\n\tha->flt_region_fdt = def_fdt[def];\n\tha->flt_region_npiv_conf = (ha->port_no == 0) ?\n\t    def_npiv_conf0[def] : def_npiv_conf1[def];\ndone:\n\tql_dbg(ql_dbg_init, vha, 0x004a,\n\t    \"FLT[%s]: boot=0x%x fw=0x%x vpd_nvram=0x%x vpd=0x%x nvram=0x%x \"\n\t    \"fdt=0x%x flt=0x%x npiv=0x%x fcp_prif_cfg=0x%x.\\n\",\n\t    loc, ha->flt_region_boot, ha->flt_region_fw,\n\t    ha->flt_region_vpd_nvram, ha->flt_region_vpd, ha->flt_region_nvram,\n\t    ha->flt_region_fdt, ha->flt_region_flt, ha->flt_region_npiv_conf,\n\t    ha->flt_region_fcp_prio);\n}\n\nstatic void\nqla2xxx_get_fdt_info(scsi_qla_host_t *vha)\n{\n#define FLASH_BLK_SIZE_4K\t0x1000\n#define FLASH_BLK_SIZE_32K\t0x8000\n#define FLASH_BLK_SIZE_64K\t0x10000\n\tconst char *loc, *locations[] = { \"MID\", \"FDT\" };\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tuint16_t cnt, chksum;\n\t__le16 *wptr = (__force __le16 *)req->ring;\n\tstruct qla_fdt_layout *fdt = (struct qla_fdt_layout *)req->ring;\n\tuint8_t\tman_id, flash_id;\n\tuint16_t mid = 0, fid = 0;\n\n\tha->isp_ops->read_optrom(vha, fdt, ha->flt_region_fdt << 2,\n\t    OPTROM_BURST_DWORDS);\n\tif (le16_to_cpu(*wptr) == 0xffff)\n\t\tgoto no_flash_data;\n\tif (memcmp(fdt->sig, \"QLID\", 4))\n\t\tgoto no_flash_data;\n\n\tfor (cnt = 0, chksum = 0; cnt < sizeof(*fdt) >> 1; cnt++, wptr++)\n\t\tchksum += le16_to_cpu(*wptr);\n\tif (chksum) {\n\t\tql_dbg(ql_dbg_init, vha, 0x004c,\n\t\t    \"Inconsistent FDT detected:\"\n\t\t    \" checksum=0x%x id=%c version0x%x.\\n\", chksum,\n\t\t    fdt->sig[0], le16_to_cpu(fdt->version));\n\t\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0113,\n\t\t    fdt, sizeof(*fdt));\n\t\tgoto no_flash_data;\n\t}\n\n\tloc = locations[1];\n\tmid = le16_to_cpu(fdt->man_id);\n\tfid = le16_to_cpu(fdt->id);\n\tha->fdt_wrt_disable = fdt->wrt_disable_bits;\n\tha->fdt_wrt_enable = fdt->wrt_enable_bits;\n\tha->fdt_wrt_sts_reg_cmd = fdt->wrt_sts_reg_cmd;\n\tif (IS_QLA8044(ha))\n\t\tha->fdt_erase_cmd = fdt->erase_cmd;\n\telse\n\t\tha->fdt_erase_cmd =\n\t\t    flash_conf_addr(ha, 0x0300 | fdt->erase_cmd);\n\tha->fdt_block_size = le32_to_cpu(fdt->block_size);\n\tif (fdt->unprotect_sec_cmd) {\n\t\tha->fdt_unprotect_sec_cmd = flash_conf_addr(ha, 0x0300 |\n\t\t    fdt->unprotect_sec_cmd);\n\t\tha->fdt_protect_sec_cmd = fdt->protect_sec_cmd ?\n\t\t    flash_conf_addr(ha, 0x0300 | fdt->protect_sec_cmd) :\n\t\t    flash_conf_addr(ha, 0x0336);\n\t}\n\tgoto done;\nno_flash_data:\n\tloc = locations[0];\n\tif (IS_P3P_TYPE(ha)) {\n\t\tha->fdt_block_size = FLASH_BLK_SIZE_64K;\n\t\tgoto done;\n\t}\n\tqla24xx_get_flash_manufacturer(ha, &man_id, &flash_id);\n\tmid = man_id;\n\tfid = flash_id;\n\tha->fdt_wrt_disable = 0x9c;\n\tha->fdt_erase_cmd = flash_conf_addr(ha, 0x03d8);\n\tswitch (man_id) {\n\tcase 0xbf:  \n\t\tif (flash_id == 0x8e)\n\t\t\tha->fdt_block_size = FLASH_BLK_SIZE_64K;\n\t\telse\n\t\t\tha->fdt_block_size = FLASH_BLK_SIZE_32K;\n\n\t\tif (flash_id == 0x80)\n\t\t\tha->fdt_erase_cmd = flash_conf_addr(ha, 0x0352);\n\t\tbreak;\n\tcase 0x13:  \n\t\tha->fdt_block_size = FLASH_BLK_SIZE_64K;\n\t\tbreak;\n\tcase 0x1f:  \n\t\tha->fdt_block_size = FLASH_BLK_SIZE_4K;\n\t\tha->fdt_erase_cmd = flash_conf_addr(ha, 0x0320);\n\t\tha->fdt_unprotect_sec_cmd = flash_conf_addr(ha, 0x0339);\n\t\tha->fdt_protect_sec_cmd = flash_conf_addr(ha, 0x0336);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tha->fdt_block_size = FLASH_BLK_SIZE_64K;\n\t\tbreak;\n\t}\ndone:\n\tql_dbg(ql_dbg_init, vha, 0x004d,\n\t    \"FDT[%s]: (0x%x/0x%x) erase=0x%x \"\n\t    \"pr=%x wrtd=0x%x blk=0x%x.\\n\",\n\t    loc, mid, fid,\n\t    ha->fdt_erase_cmd, ha->fdt_protect_sec_cmd,\n\t    ha->fdt_wrt_disable, ha->fdt_block_size);\n\n}\n\nstatic void\nqla2xxx_get_idc_param(scsi_qla_host_t *vha)\n{\n#define QLA82XX_IDC_PARAM_ADDR       0x003e885c\n\t__le32 *wptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\n\tif (!(IS_P3P_TYPE(ha)))\n\t\treturn;\n\n\twptr = (__force __le32 *)req->ring;\n\tha->isp_ops->read_optrom(vha, req->ring, QLA82XX_IDC_PARAM_ADDR, 8);\n\n\tif (*wptr == cpu_to_le32(0xffffffff)) {\n\t\tha->fcoe_dev_init_timeout = QLA82XX_ROM_DEV_INIT_TIMEOUT;\n\t\tha->fcoe_reset_timeout = QLA82XX_ROM_DRV_RESET_ACK_TIMEOUT;\n\t} else {\n\t\tha->fcoe_dev_init_timeout = le32_to_cpu(*wptr);\n\t\twptr++;\n\t\tha->fcoe_reset_timeout = le32_to_cpu(*wptr);\n\t}\n\tql_dbg(ql_dbg_init, vha, 0x004e,\n\t    \"fcoe_dev_init_timeout=%d \"\n\t    \"fcoe_reset_timeout=%d.\\n\", ha->fcoe_dev_init_timeout,\n\t    ha->fcoe_reset_timeout);\n\treturn;\n}\n\nint\nqla2xxx_get_flash_info(scsi_qla_host_t *vha)\n{\n\tint ret;\n\tuint32_t flt_addr;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&\n\t    !IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn QLA_SUCCESS;\n\n\tret = qla2xxx_find_flt_start(vha, &flt_addr);\n\tif (ret != QLA_SUCCESS)\n\t\treturn ret;\n\n\tqla2xxx_get_flt_info(vha, flt_addr);\n\tqla2xxx_get_fdt_info(vha);\n\tqla2xxx_get_idc_param(vha);\n\n\treturn QLA_SUCCESS;\n}\n\nvoid\nqla2xxx_flash_npiv_conf(scsi_qla_host_t *vha)\n{\n#define NPIV_CONFIG_SIZE\t(16*1024)\n\tvoid *data;\n\t__le16 *wptr;\n\tuint16_t cnt, chksum;\n\tint i;\n\tstruct qla_npiv_header hdr;\n\tstruct qla_npiv_entry *entry;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha) &&\n\t    !IS_CNA_CAPABLE(ha) && !IS_QLA2031(ha))\n\t\treturn;\n\n\tif (ha->flags.nic_core_reset_hdlr_active)\n\t\treturn;\n\n\tif (IS_QLA8044(ha))\n\t\treturn;\n\n\tha->isp_ops->read_optrom(vha, &hdr, ha->flt_region_npiv_conf << 2,\n\t    sizeof(struct qla_npiv_header));\n\tif (hdr.version == cpu_to_le16(0xffff))\n\t\treturn;\n\tif (hdr.version != cpu_to_le16(1)) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7090,\n\t\t    \"Unsupported NPIV-Config \"\n\t\t    \"detected: version=0x%x entries=0x%x checksum=0x%x.\\n\",\n\t\t    le16_to_cpu(hdr.version), le16_to_cpu(hdr.entries),\n\t\t    le16_to_cpu(hdr.checksum));\n\t\treturn;\n\t}\n\n\tdata = kmalloc(NPIV_CONFIG_SIZE, GFP_KERNEL);\n\tif (!data) {\n\t\tql_log(ql_log_warn, vha, 0x7091,\n\t\t    \"Unable to allocate memory for data.\\n\");\n\t\treturn;\n\t}\n\n\tha->isp_ops->read_optrom(vha, data, ha->flt_region_npiv_conf << 2,\n\t    NPIV_CONFIG_SIZE);\n\n\tcnt = (sizeof(hdr) + le16_to_cpu(hdr.entries) * sizeof(*entry)) >> 1;\n\tfor (wptr = data, chksum = 0; cnt--; wptr++)\n\t\tchksum += le16_to_cpu(*wptr);\n\tif (chksum) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7092,\n\t\t    \"Inconsistent NPIV-Config \"\n\t\t    \"detected: version=0x%x entries=0x%x checksum=0x%x.\\n\",\n\t\t    le16_to_cpu(hdr.version), le16_to_cpu(hdr.entries),\n\t\t    le16_to_cpu(hdr.checksum));\n\t\tgoto done;\n\t}\n\n\tentry = data + sizeof(struct qla_npiv_header);\n\tcnt = le16_to_cpu(hdr.entries);\n\tfor (i = 0; cnt; cnt--, entry++, i++) {\n\t\tuint16_t flags;\n\t\tstruct fc_vport_identifiers vid;\n\t\tstruct fc_vport *vport;\n\n\t\tmemcpy(&ha->npiv_info[i], entry, sizeof(struct qla_npiv_entry));\n\n\t\tflags = le16_to_cpu(entry->flags);\n\t\tif (flags == 0xffff)\n\t\t\tcontinue;\n\t\tif ((flags & BIT_0) == 0)\n\t\t\tcontinue;\n\n\t\tmemset(&vid, 0, sizeof(vid));\n\t\tvid.roles = FC_PORT_ROLE_FCP_INITIATOR;\n\t\tvid.vport_type = FC_PORTTYPE_NPIV;\n\t\tvid.disable = false;\n\t\tvid.port_name = wwn_to_u64(entry->port_name);\n\t\tvid.node_name = wwn_to_u64(entry->node_name);\n\n\t\tql_dbg(ql_dbg_user, vha, 0x7093,\n\t\t    \"NPIV[%02x]: wwpn=%llx wwnn=%llx vf_id=%#x Q_qos=%#x F_qos=%#x.\\n\",\n\t\t    cnt, vid.port_name, vid.node_name,\n\t\t    le16_to_cpu(entry->vf_id),\n\t\t    entry->q_qos, entry->f_qos);\n\n\t\tif (i < QLA_PRECONFIG_VPORTS) {\n\t\t\tvport = fc_vport_create(vha->host, 0, &vid);\n\t\t\tif (!vport)\n\t\t\t\tql_log(ql_log_warn, vha, 0x7094,\n\t\t\t\t    \"NPIV-Config Failed to create vport [%02x]: wwpn=%llx wwnn=%llx.\\n\",\n\t\t\t\t    cnt, vid.port_name, vid.node_name);\n\t\t}\n\t}\ndone:\n\tkfree(data);\n}\n\nstatic int\nqla24xx_unprotect_flash(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tif (ha->flags.fac_supported)\n\t\treturn qla81xx_fac_do_write_enable(vha, 1);\n\n\t \n\twrt_reg_dword(&reg->ctrl_status,\n\t    rd_reg_dword(&reg->ctrl_status) | CSRX_FLASH_ENABLE);\n\trd_reg_dword(&reg->ctrl_status);\t \n\n\tif (!ha->fdt_wrt_disable)\n\t\tgoto done;\n\n\t \n\tqla24xx_write_flash_dword(ha, flash_conf_addr(ha, 0x101), 0);\n\t \n\tqla24xx_write_flash_dword(ha, flash_conf_addr(ha, 0x101), 0);\ndone:\n\treturn QLA_SUCCESS;\n}\n\nstatic int\nqla24xx_protect_flash(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\tulong cnt = 300;\n\tuint32_t faddr, dword;\n\n\tif (ha->flags.fac_supported)\n\t\treturn qla81xx_fac_do_write_enable(vha, 0);\n\n\tif (!ha->fdt_wrt_disable)\n\t\tgoto skip_wrt_protect;\n\n\t \n\tfaddr = flash_conf_addr(ha, 0x101);\n\tqla24xx_write_flash_dword(ha, faddr, ha->fdt_wrt_disable);\n\tfaddr = flash_conf_addr(ha, 0x5);\n\twhile (cnt--) {\n\t\tif (!qla24xx_read_flash_dword(ha, faddr, &dword)) {\n\t\t\tif (!(dword & BIT_0))\n\t\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\nskip_wrt_protect:\n\t \n\twrt_reg_dword(&reg->ctrl_status,\n\t    rd_reg_dword(&reg->ctrl_status) & ~CSRX_FLASH_ENABLE);\n\n\treturn QLA_SUCCESS;\n}\n\nstatic int\nqla24xx_erase_sector(scsi_qla_host_t *vha, uint32_t fdata)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t start, finish;\n\n\tif (ha->flags.fac_supported) {\n\t\tstart = fdata >> 2;\n\t\tfinish = start + (ha->fdt_block_size >> 2) - 1;\n\t\treturn qla81xx_fac_erase_sector(vha, flash_data_addr(ha,\n\t\t    start), flash_data_addr(ha, finish));\n\t}\n\n\treturn qla24xx_write_flash_dword(ha, ha->fdt_erase_cmd,\n\t    (fdata & 0xff00) | ((fdata << 16) & 0xff0000) |\n\t    ((fdata >> 16) & 0xff));\n}\n\nstatic int\nqla24xx_write_flash_data(scsi_qla_host_t *vha, __le32 *dwptr, uint32_t faddr,\n    uint32_t dwords)\n{\n\tint ret;\n\tulong liter;\n\tulong dburst = OPTROM_BURST_DWORDS;  \n\tuint32_t sec_mask, rest_addr, fdata;\n\tdma_addr_t optrom_dma;\n\tvoid *optrom = NULL;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA25XX(ha) && !IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\tgoto next;\n\n\t \n\toptrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\n\t    &optrom_dma, GFP_KERNEL);\n\tif (!optrom) {\n\t\tql_log(ql_log_warn, vha, 0x7095,\n\t\t    \"Failed allocate burst (%x bytes)\\n\", OPTROM_BURST_SIZE);\n\t}\n\nnext:\n\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,\n\t    \"Unprotect flash...\\n\");\n\tret = qla24xx_unprotect_flash(vha);\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0x7096,\n\t\t    \"Failed to unprotect flash.\\n\");\n\t\tgoto done;\n\t}\n\n\trest_addr = (ha->fdt_block_size >> 2) - 1;\n\tsec_mask = ~rest_addr;\n\tfor (liter = 0; liter < dwords; liter++, faddr++, dwptr++) {\n\t\tfdata = (faddr & sec_mask) << 2;\n\n\t\t \n\t\tif (!(faddr & rest_addr)) {\n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,\n\t\t\t    \"Erase sector %#x...\\n\", faddr);\n\n\t\t\tret = qla24xx_erase_sector(vha, fdata);\n\t\t\tif (ret) {\n\t\t\t\tql_dbg(ql_dbg_user, vha, 0x7007,\n\t\t\t\t    \"Failed to erase sector %x.\\n\", faddr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (optrom) {\n\t\t\t \n\t\t\tif (dwords - liter < dburst)\n\t\t\t\tdburst = dwords - liter;\n\n\t\t\t \n\t\t\tmemcpy(optrom, dwptr, dburst << 2);\n\n\t\t\t \n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,\n\t\t\t    \"Write burst (%#lx dwords)...\\n\", dburst);\n\t\t\tret = qla2x00_load_ram(vha, optrom_dma,\n\t\t\t    flash_data_addr(ha, faddr), dburst);\n\t\t\tif (!ret) {\n\t\t\t\tliter += dburst - 1;\n\t\t\t\tfaddr += dburst - 1;\n\t\t\t\tdwptr += dburst - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tql_log(ql_log_warn, vha, 0x7097,\n\t\t\t    \"Failed burst-write at %x (%p/%#llx)....\\n\",\n\t\t\t    flash_data_addr(ha, faddr), optrom,\n\t\t\t    (u64)optrom_dma);\n\n\t\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t    OPTROM_BURST_SIZE, optrom, optrom_dma);\n\t\t\toptrom = NULL;\n\t\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\t\tbreak;\n\t\t\tql_log(ql_log_warn, vha, 0x7098,\n\t\t\t    \"Reverting to slow write...\\n\");\n\t\t}\n\n\t\t \n\t\tret = qla24xx_write_flash_dword(ha,\n\t\t    flash_data_addr(ha, faddr), le32_to_cpu(*dwptr));\n\t\tif (ret) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x7006,\n\t\t\t    \"Failed slow write %x (%x)\\n\", faddr, *dwptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,\n\t    \"Protect flash...\\n\");\n\tret = qla24xx_protect_flash(vha);\n\tif (ret)\n\t\tql_log(ql_log_warn, vha, 0x7099,\n\t\t    \"Failed to protect flash\\n\");\ndone:\n\tif (optrom)\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t    OPTROM_BURST_SIZE, optrom, optrom_dma);\n\n\treturn ret;\n}\n\nuint8_t *\nqla2x00_read_nvram_data(scsi_qla_host_t *vha, void *buf, uint32_t naddr,\n    uint32_t bytes)\n{\n\tuint32_t i;\n\t__le16 *wptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\twptr = buf;\n\tqla2x00_lock_nvram_access(ha);\n\tfor (i = 0; i < bytes >> 1; i++, naddr++)\n\t\twptr[i] = cpu_to_le16(qla2x00_get_nvram_word(ha,\n\t\t    naddr));\n\tqla2x00_unlock_nvram_access(ha);\n\n\treturn buf;\n}\n\nuint8_t *\nqla24xx_read_nvram_data(scsi_qla_host_t *vha, void *buf, uint32_t naddr,\n    uint32_t bytes)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t *dwptr = buf;\n\tuint32_t i;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn  buf;\n\n\t \n\tnaddr = nvram_data_addr(ha, naddr);\n\tbytes >>= 2;\n\tfor (i = 0; i < bytes; i++, naddr++, dwptr++) {\n\t\tif (qla24xx_read_flash_dword(ha, naddr, dwptr))\n\t\t\tbreak;\n\t\tcpu_to_le32s(dwptr);\n\t}\n\n\treturn buf;\n}\n\nint\nqla2x00_write_nvram_data(scsi_qla_host_t *vha, void *buf, uint32_t naddr,\n    uint32_t bytes)\n{\n\tint ret, stat;\n\tuint32_t i;\n\tuint16_t *wptr;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tret = QLA_SUCCESS;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqla2x00_lock_nvram_access(ha);\n\n\t \n\tstat = qla2x00_clear_nvram_protection(ha);\n\n\twptr = (uint16_t *)buf;\n\tfor (i = 0; i < bytes >> 1; i++, naddr++) {\n\t\tqla2x00_write_nvram_word(ha, naddr,\n\t\t    cpu_to_le16(*wptr));\n\t\twptr++;\n\t}\n\n\t \n\tqla2x00_set_nvram_protection(ha, stat);\n\n\tqla2x00_unlock_nvram_access(ha);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn ret;\n}\n\nint\nqla24xx_write_nvram_data(scsi_qla_host_t *vha, void *buf, uint32_t naddr,\n    uint32_t bytes)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\t__le32 *dwptr = buf;\n\tuint32_t i;\n\tint ret;\n\n\tret = QLA_SUCCESS;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn ret;\n\n\t \n\twrt_reg_dword(&reg->ctrl_status,\n\t    rd_reg_dword(&reg->ctrl_status) | CSRX_FLASH_ENABLE);\n\trd_reg_dword(&reg->ctrl_status);\t \n\n\t \n\tqla24xx_write_flash_dword(ha, nvram_conf_addr(ha, 0x101), 0);\n\tqla24xx_write_flash_dword(ha, nvram_conf_addr(ha, 0x101), 0);\n\n\t \n\tnaddr = nvram_data_addr(ha, naddr);\n\tbytes >>= 2;\n\tfor (i = 0; i < bytes; i++, naddr++, dwptr++) {\n\t\tif (qla24xx_write_flash_dword(ha, naddr, le32_to_cpu(*dwptr))) {\n\t\t\tql_dbg(ql_dbg_user, vha, 0x709a,\n\t\t\t    \"Unable to program nvram address=%x data=%x.\\n\",\n\t\t\t    naddr, *dwptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tqla24xx_write_flash_dword(ha, nvram_conf_addr(ha, 0x101), 0x8c);\n\n\t \n\twrt_reg_dword(&reg->ctrl_status,\n\t    rd_reg_dword(&reg->ctrl_status) & ~CSRX_FLASH_ENABLE);\n\trd_reg_dword(&reg->ctrl_status);\t \n\n\treturn ret;\n}\n\nuint8_t *\nqla25xx_read_nvram_data(scsi_qla_host_t *vha, void *buf, uint32_t naddr,\n    uint32_t bytes)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t *dwptr = buf;\n\tuint32_t i;\n\n\t \n\tnaddr = flash_data_addr(ha, ha->flt_region_vpd_nvram | naddr);\n\tbytes >>= 2;\n\tfor (i = 0; i < bytes; i++, naddr++, dwptr++) {\n\t\tif (qla24xx_read_flash_dword(ha, naddr, dwptr))\n\t\t\tbreak;\n\n\t\tcpu_to_le32s(dwptr);\n\t}\n\n\treturn buf;\n}\n\n#define RMW_BUFFER_SIZE\t(64 * 1024)\nint\nqla25xx_write_nvram_data(scsi_qla_host_t *vha, void *buf, uint32_t naddr,\n    uint32_t bytes)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint8_t *dbuf = vmalloc(RMW_BUFFER_SIZE);\n\n\tif (!dbuf)\n\t\treturn QLA_MEMORY_ALLOC_FAILED;\n\tha->isp_ops->read_optrom(vha, dbuf, ha->flt_region_vpd_nvram << 2,\n\t    RMW_BUFFER_SIZE);\n\tmemcpy(dbuf + (naddr << 2), buf, bytes);\n\tha->isp_ops->write_optrom(vha, dbuf, ha->flt_region_vpd_nvram << 2,\n\t    RMW_BUFFER_SIZE);\n\tvfree(dbuf);\n\n\treturn QLA_SUCCESS;\n}\n\nstatic inline void\nqla2x00_flip_colors(struct qla_hw_data *ha, uint16_t *pflags)\n{\n\tif (IS_QLA2322(ha)) {\n\t\t \n\t\tif (ha->beacon_color_state == QLA_LED_ALL_ON) {\n\t\t\t \n\t\t\tha->beacon_color_state = 0;\n\t\t\t*pflags = GPIO_LED_ALL_OFF;\n\t\t} else {\n\t\t\t \n\t\t\tha->beacon_color_state = QLA_LED_ALL_ON;\n\t\t\t*pflags = GPIO_LED_RGA_ON;\n\t\t}\n\t} else {\n\t\t \n\t\tif (ha->beacon_color_state == QLA_LED_GRN_ON) {\n\t\t\t \n\t\t\tha->beacon_color_state = 0;\n\t\t\t*pflags = GPIO_LED_GREEN_OFF_AMBER_OFF;\n\t\t} else {\n\t\t\t \n\t\t\tha->beacon_color_state = QLA_LED_GRN_ON;\n\t\t\t*pflags = GPIO_LED_GREEN_ON_AMBER_OFF;\n\t\t}\n\t}\n}\n\n#define PIO_REG(h, r) ((h)->pio_address + offsetof(struct device_reg_2xxx, r))\n\nvoid\nqla2x00_beacon_blink(struct scsi_qla_host *vha)\n{\n\tuint16_t gpio_enable;\n\tuint16_t gpio_data;\n\tuint16_t led_color = 0;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t \n\tif (ha->pio_address) {\n\t\tgpio_enable = RD_REG_WORD_PIO(PIO_REG(ha, gpioe));\n\t\tgpio_data = RD_REG_WORD_PIO(PIO_REG(ha, gpiod));\n\t} else {\n\t\tgpio_enable = rd_reg_word(&reg->gpioe);\n\t\tgpio_data = rd_reg_word(&reg->gpiod);\n\t}\n\n\t \n\tgpio_enable |= GPIO_LED_MASK;\n\n\tif (ha->pio_address) {\n\t\tWRT_REG_WORD_PIO(PIO_REG(ha, gpioe), gpio_enable);\n\t} else {\n\t\twrt_reg_word(&reg->gpioe, gpio_enable);\n\t\trd_reg_word(&reg->gpioe);\n\t}\n\n\tqla2x00_flip_colors(ha, &led_color);\n\n\t \n\tgpio_data &= ~GPIO_LED_MASK;\n\n\t \n\tgpio_data |= led_color;\n\n\t \n\tif (ha->pio_address) {\n\t\tWRT_REG_WORD_PIO(PIO_REG(ha, gpiod), gpio_data);\n\t} else {\n\t\twrt_reg_word(&reg->gpiod, gpio_data);\n\t\trd_reg_word(&reg->gpiod);\n\t}\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nint\nqla2x00_beacon_on(struct scsi_qla_host *vha)\n{\n\tuint16_t gpio_enable;\n\tuint16_t gpio_data;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tha->fw_options[1] &= ~FO1_SET_EMPHASIS_SWING;\n\tha->fw_options[1] |= FO1_DISABLE_GPIO6_7;\n\n\tif (qla2x00_set_fw_options(vha, ha->fw_options) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x709b,\n\t\t    \"Unable to update fw options (beacon on).\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tif (ha->pio_address) {\n\t\tgpio_enable = RD_REG_WORD_PIO(PIO_REG(ha, gpioe));\n\t\tgpio_data = RD_REG_WORD_PIO(PIO_REG(ha, gpiod));\n\t} else {\n\t\tgpio_enable = rd_reg_word(&reg->gpioe);\n\t\tgpio_data = rd_reg_word(&reg->gpiod);\n\t}\n\tgpio_enable |= GPIO_LED_MASK;\n\n\t \n\tif (ha->pio_address) {\n\t\tWRT_REG_WORD_PIO(PIO_REG(ha, gpioe), gpio_enable);\n\t} else {\n\t\twrt_reg_word(&reg->gpioe, gpio_enable);\n\t\trd_reg_word(&reg->gpioe);\n\t}\n\n\t \n\tgpio_data &= ~GPIO_LED_MASK;\n\tif (ha->pio_address) {\n\t\tWRT_REG_WORD_PIO(PIO_REG(ha, gpiod), gpio_data);\n\t} else {\n\t\twrt_reg_word(&reg->gpiod, gpio_data);\n\t\trd_reg_word(&reg->gpiod);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t \n\tha->beacon_blink_led = 1;\n\tha->beacon_color_state = 0;\n\n\treturn QLA_SUCCESS;\n}\n\nint\nqla2x00_beacon_off(struct scsi_qla_host *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tha->beacon_blink_led = 0;\n\n\t \n\tif (IS_QLA2322(ha))\n\t\tha->beacon_color_state = QLA_LED_ALL_ON;\n\telse\n\t\tha->beacon_color_state = QLA_LED_GRN_ON;\n\n\tha->isp_ops->beacon_blink(vha);\t \n\n\tha->fw_options[1] &= ~FO1_SET_EMPHASIS_SWING;\n\tha->fw_options[1] &= ~FO1_DISABLE_GPIO6_7;\n\n\trval = qla2x00_set_fw_options(vha, ha->fw_options);\n\tif (rval != QLA_SUCCESS)\n\t\tql_log(ql_log_warn, vha, 0x709c,\n\t\t    \"Unable to update fw options (beacon off).\\n\");\n\treturn rval;\n}\n\n\nstatic inline void\nqla24xx_flip_colors(struct qla_hw_data *ha, uint16_t *pflags)\n{\n\t \n\tif (ha->beacon_color_state == QLA_LED_ALL_ON) {\n\t\t \n\t\tha->beacon_color_state = 0;\n\t\t*pflags = 0;\n\t} else {\n\t\t \n\t\tha->beacon_color_state = QLA_LED_ALL_ON;\n\t\t*pflags = GPDX_LED_YELLOW_ON | GPDX_LED_AMBER_ON;\n\t}\n}\n\nvoid\nqla24xx_beacon_blink(struct scsi_qla_host *vha)\n{\n\tuint16_t led_color = 0;\n\tuint32_t gpio_data;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tgpio_data = rd_reg_dword(&reg->gpiod);\n\n\t \n\tgpio_data |= GPDX_LED_UPDATE_MASK;\n\n\twrt_reg_dword(&reg->gpiod, gpio_data);\n\tgpio_data = rd_reg_dword(&reg->gpiod);\n\n\t \n\tqla24xx_flip_colors(ha, &led_color);\n\n\t \n\tgpio_data &= ~GPDX_LED_COLOR_MASK;\n\n\t \n\tgpio_data |= led_color;\n\n\t \n\twrt_reg_dword(&reg->gpiod, gpio_data);\n\tgpio_data = rd_reg_dword(&reg->gpiod);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nstatic uint32_t\nqla83xx_select_led_port(struct qla_hw_data *ha)\n{\n\tuint32_t led_select_value = 0;\n\n\tif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\tgoto out;\n\n\tif (ha->port_no == 0)\n\t\tled_select_value = QLA83XX_LED_PORT0;\n\telse\n\t\tled_select_value = QLA83XX_LED_PORT1;\n\nout:\n\treturn led_select_value;\n}\n\nvoid\nqla83xx_beacon_blink(struct scsi_qla_host *vha)\n{\n\tuint32_t led_select_value;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t led_cfg[6];\n\tuint16_t orig_led_cfg[6];\n\tuint32_t led_10_value, led_43_value;\n\n\tif (!IS_QLA83XX(ha) && !IS_QLA81XX(ha) && !IS_QLA27XX(ha) &&\n\t    !IS_QLA28XX(ha))\n\t\treturn;\n\n\tif (!ha->beacon_blink_led)\n\t\treturn;\n\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tqla2x00_write_ram_word(vha, 0x1003, 0x40000230);\n\t\tqla2x00_write_ram_word(vha, 0x1004, 0x40000230);\n\t} else if (IS_QLA2031(ha)) {\n\t\tled_select_value = qla83xx_select_led_port(ha);\n\n\t\tqla83xx_wr_reg(vha, led_select_value, 0x40000230);\n\t\tqla83xx_wr_reg(vha, led_select_value + 4, 0x40000230);\n\t} else if (IS_QLA8031(ha)) {\n\t\tled_select_value = qla83xx_select_led_port(ha);\n\n\t\tqla83xx_rd_reg(vha, led_select_value, &led_10_value);\n\t\tqla83xx_rd_reg(vha, led_select_value + 0x10, &led_43_value);\n\t\tqla83xx_wr_reg(vha, led_select_value, 0x01f44000);\n\t\tmsleep(500);\n\t\tqla83xx_wr_reg(vha, led_select_value, 0x400001f4);\n\t\tmsleep(1000);\n\t\tqla83xx_wr_reg(vha, led_select_value, led_10_value);\n\t\tqla83xx_wr_reg(vha, led_select_value + 0x10, led_43_value);\n\t} else if (IS_QLA81XX(ha)) {\n\t\tint rval;\n\n\t\t \n\t\trval = qla81xx_get_led_config(vha, orig_led_cfg);\n\t\t \n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tif (IS_QLA81XX(ha)) {\n\t\t\t\tled_cfg[0] = 0x4000;\n\t\t\t\tled_cfg[1] = 0x2000;\n\t\t\t\tled_cfg[2] = 0;\n\t\t\t\tled_cfg[3] = 0;\n\t\t\t\tled_cfg[4] = 0;\n\t\t\t\tled_cfg[5] = 0;\n\t\t\t} else {\n\t\t\t\tled_cfg[0] = 0x4000;\n\t\t\t\tled_cfg[1] = 0x4000;\n\t\t\t\tled_cfg[2] = 0x4000;\n\t\t\t\tled_cfg[3] = 0x2000;\n\t\t\t\tled_cfg[4] = 0;\n\t\t\t\tled_cfg[5] = 0x2000;\n\t\t\t}\n\t\t\trval = qla81xx_set_led_config(vha, led_cfg);\n\t\t\tmsleep(1000);\n\t\t\tif (IS_QLA81XX(ha)) {\n\t\t\t\tled_cfg[0] = 0x4000;\n\t\t\t\tled_cfg[1] = 0x2000;\n\t\t\t\tled_cfg[2] = 0;\n\t\t\t} else {\n\t\t\t\tled_cfg[0] = 0x4000;\n\t\t\t\tled_cfg[1] = 0x2000;\n\t\t\t\tled_cfg[2] = 0x4000;\n\t\t\t\tled_cfg[3] = 0x4000;\n\t\t\t\tled_cfg[4] = 0;\n\t\t\t\tled_cfg[5] = 0x2000;\n\t\t\t}\n\t\t\trval = qla81xx_set_led_config(vha, led_cfg);\n\t\t}\n\t\t \n\t\tqla81xx_set_led_config(vha, orig_led_cfg);\n\t}\n}\n\nint\nqla24xx_beacon_on(struct scsi_qla_host *vha)\n{\n\tuint32_t gpio_data;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn QLA_SUCCESS;\n\n\tif (IS_QLA8031(ha) || IS_QLA81XX(ha))\n\t\tgoto skip_gpio;  \n\n\tif (ha->beacon_blink_led == 0) {\n\t\t \n\t\tha->fw_options[1] |= ADD_FO1_DISABLE_GPIO_LED_CTRL;\n\n\t\tif (qla2x00_set_fw_options(vha, ha->fw_options) != QLA_SUCCESS)\n\t\t\treturn QLA_FUNCTION_FAILED;\n\n\t\tif (qla2x00_get_fw_options(vha, ha->fw_options) !=\n\t\t    QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x7009,\n\t\t\t    \"Unable to update fw options (beacon on).\\n\");\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\n\t\tif (IS_QLA2031(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\tgoto skip_gpio;\n\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tgpio_data = rd_reg_dword(&reg->gpiod);\n\n\t\t \n\t\tgpio_data |= GPDX_LED_UPDATE_MASK;\n\t\twrt_reg_dword(&reg->gpiod, gpio_data);\n\t\trd_reg_dword(&reg->gpiod);\n\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\t \n\tha->beacon_color_state = 0;\n\nskip_gpio:\n\t \n\tha->beacon_blink_led = 1;\n\n\treturn QLA_SUCCESS;\n}\n\nint\nqla24xx_beacon_off(struct scsi_qla_host *vha)\n{\n\tuint32_t gpio_data;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn QLA_SUCCESS;\n\n\tif (!ha->flags.fw_started)\n\t\treturn QLA_SUCCESS;\n\n\tha->beacon_blink_led = 0;\n\n\tif (IS_QLA2031(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tgoto set_fw_options;\n\n\tif (IS_QLA8031(ha) || IS_QLA81XX(ha))\n\t\treturn QLA_SUCCESS;\n\n\tha->beacon_color_state = QLA_LED_ALL_ON;\n\n\tha->isp_ops->beacon_blink(vha);\t \n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tgpio_data = rd_reg_dword(&reg->gpiod);\n\n\t \n\tgpio_data &= ~GPDX_LED_UPDATE_MASK;\n\twrt_reg_dword(&reg->gpiod, gpio_data);\n\trd_reg_dword(&reg->gpiod);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\nset_fw_options:\n\tha->fw_options[1] &= ~ADD_FO1_DISABLE_GPIO_LED_CTRL;\n\n\tif (qla2x00_set_fw_options(vha, ha->fw_options) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x704d,\n\t\t    \"Unable to update fw options (beacon on).\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tif (qla2x00_get_fw_options(vha, ha->fw_options) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x704e,\n\t\t    \"Unable to update fw options (beacon on).\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\n\n \n\n \nstatic void\nqla2x00_flash_enable(struct qla_hw_data *ha)\n{\n\tuint16_t data;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tdata = rd_reg_word(&reg->ctrl_status);\n\tdata |= CSR_FLASH_ENABLE;\n\twrt_reg_word(&reg->ctrl_status, data);\n\trd_reg_word(&reg->ctrl_status);\t\t \n}\n\n \nstatic void\nqla2x00_flash_disable(struct qla_hw_data *ha)\n{\n\tuint16_t data;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tdata = rd_reg_word(&reg->ctrl_status);\n\tdata &= ~(CSR_FLASH_ENABLE);\n\twrt_reg_word(&reg->ctrl_status, data);\n\trd_reg_word(&reg->ctrl_status);\t\t \n}\n\n \nstatic uint8_t\nqla2x00_read_flash_byte(struct qla_hw_data *ha, uint32_t addr)\n{\n\tuint16_t data;\n\tuint16_t bank_select;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tbank_select = rd_reg_word(&reg->ctrl_status);\n\n\tif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\n\t\t \n\t\t \n\t\tbank_select &= ~0xf8;\n\t\tbank_select |= addr >> 12 & 0xf0;\n\t\tbank_select |= CSR_FLASH_64K_BANK;\n\t\twrt_reg_word(&reg->ctrl_status, bank_select);\n\t\trd_reg_word(&reg->ctrl_status);\t \n\n\t\twrt_reg_word(&reg->flash_address, (uint16_t)addr);\n\t\tdata = rd_reg_word(&reg->flash_data);\n\n\t\treturn (uint8_t)data;\n\t}\n\n\t \n\tif ((addr & BIT_16) && ((bank_select & CSR_FLASH_64K_BANK) == 0)) {\n\t\tbank_select |= CSR_FLASH_64K_BANK;\n\t\twrt_reg_word(&reg->ctrl_status, bank_select);\n\t\trd_reg_word(&reg->ctrl_status);\t \n\t} else if (((addr & BIT_16) == 0) &&\n\t    (bank_select & CSR_FLASH_64K_BANK)) {\n\t\tbank_select &= ~(CSR_FLASH_64K_BANK);\n\t\twrt_reg_word(&reg->ctrl_status, bank_select);\n\t\trd_reg_word(&reg->ctrl_status);\t \n\t}\n\n\t \n\tif (ha->pio_address) {\n\t\tuint16_t data2;\n\n\t\tWRT_REG_WORD_PIO(PIO_REG(ha, flash_address), (uint16_t)addr);\n\t\tdo {\n\t\t\tdata = RD_REG_WORD_PIO(PIO_REG(ha, flash_data));\n\t\t\tbarrier();\n\t\t\tcpu_relax();\n\t\t\tdata2 = RD_REG_WORD_PIO(PIO_REG(ha, flash_data));\n\t\t} while (data != data2);\n\t} else {\n\t\twrt_reg_word(&reg->flash_address, (uint16_t)addr);\n\t\tdata = qla2x00_debounce_register(&reg->flash_data);\n\t}\n\n\treturn (uint8_t)data;\n}\n\n \nstatic void\nqla2x00_write_flash_byte(struct qla_hw_data *ha, uint32_t addr, uint8_t data)\n{\n\tuint16_t bank_select;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tbank_select = rd_reg_word(&reg->ctrl_status);\n\tif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\n\t\t \n\t\t \n\t\tbank_select &= ~0xf8;\n\t\tbank_select |= addr >> 12 & 0xf0;\n\t\tbank_select |= CSR_FLASH_64K_BANK;\n\t\twrt_reg_word(&reg->ctrl_status, bank_select);\n\t\trd_reg_word(&reg->ctrl_status);\t \n\n\t\twrt_reg_word(&reg->flash_address, (uint16_t)addr);\n\t\trd_reg_word(&reg->ctrl_status);\t\t \n\t\twrt_reg_word(&reg->flash_data, (uint16_t)data);\n\t\trd_reg_word(&reg->ctrl_status);\t\t \n\n\t\treturn;\n\t}\n\n\t \n\tif ((addr & BIT_16) && ((bank_select & CSR_FLASH_64K_BANK) == 0)) {\n\t\tbank_select |= CSR_FLASH_64K_BANK;\n\t\twrt_reg_word(&reg->ctrl_status, bank_select);\n\t\trd_reg_word(&reg->ctrl_status);\t \n\t} else if (((addr & BIT_16) == 0) &&\n\t    (bank_select & CSR_FLASH_64K_BANK)) {\n\t\tbank_select &= ~(CSR_FLASH_64K_BANK);\n\t\twrt_reg_word(&reg->ctrl_status, bank_select);\n\t\trd_reg_word(&reg->ctrl_status);\t \n\t}\n\n\t \n\tif (ha->pio_address) {\n\t\tWRT_REG_WORD_PIO(PIO_REG(ha, flash_address), (uint16_t)addr);\n\t\tWRT_REG_WORD_PIO(PIO_REG(ha, flash_data), (uint16_t)data);\n\t} else {\n\t\twrt_reg_word(&reg->flash_address, (uint16_t)addr);\n\t\trd_reg_word(&reg->ctrl_status);\t\t \n\t\twrt_reg_word(&reg->flash_data, (uint16_t)data);\n\t\trd_reg_word(&reg->ctrl_status);\t\t \n\t}\n}\n\n \nstatic int\nqla2x00_poll_flash(struct qla_hw_data *ha, uint32_t addr, uint8_t poll_data,\n    uint8_t man_id, uint8_t flash_id)\n{\n\tint status;\n\tuint8_t flash_data;\n\tuint32_t cnt;\n\n\tstatus = 1;\n\n\t \n\tpoll_data &= BIT_7;\n\tfor (cnt = 3000000; cnt; cnt--) {\n\t\tflash_data = qla2x00_read_flash_byte(ha, addr);\n\t\tif ((flash_data & BIT_7) == poll_data) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (man_id != 0x40 && man_id != 0xda) {\n\t\t\tif ((flash_data & BIT_5) && cnt > 2)\n\t\t\t\tcnt = 2;\n\t\t}\n\t\tudelay(10);\n\t\tbarrier();\n\t\tcond_resched();\n\t}\n\treturn status;\n}\n\n \nstatic int\nqla2x00_program_flash_address(struct qla_hw_data *ha, uint32_t addr,\n    uint8_t data, uint8_t man_id, uint8_t flash_id)\n{\n\t \n\tif (IS_OEM_001(ha)) {\n\t\tqla2x00_write_flash_byte(ha, 0xaaa, 0xaa);\n\t\tqla2x00_write_flash_byte(ha, 0x555, 0x55);\n\t\tqla2x00_write_flash_byte(ha, 0xaaa, 0xa0);\n\t\tqla2x00_write_flash_byte(ha, addr, data);\n\t} else {\n\t\tif (man_id == 0xda && flash_id == 0xc1) {\n\t\t\tqla2x00_write_flash_byte(ha, addr, data);\n\t\t\tif (addr & 0x7e)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\n\t\t\tqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\n\t\t\tqla2x00_write_flash_byte(ha, 0x5555, 0xa0);\n\t\t\tqla2x00_write_flash_byte(ha, addr, data);\n\t\t}\n\t}\n\n\tudelay(150);\n\n\t \n\treturn qla2x00_poll_flash(ha, addr, data, man_id, flash_id);\n}\n\n \nstatic int\nqla2x00_erase_flash(struct qla_hw_data *ha, uint8_t man_id, uint8_t flash_id)\n{\n\t \n\tif (IS_OEM_001(ha)) {\n\t\tqla2x00_write_flash_byte(ha, 0xaaa, 0xaa);\n\t\tqla2x00_write_flash_byte(ha, 0x555, 0x55);\n\t\tqla2x00_write_flash_byte(ha, 0xaaa, 0x80);\n\t\tqla2x00_write_flash_byte(ha, 0xaaa, 0xaa);\n\t\tqla2x00_write_flash_byte(ha, 0x555, 0x55);\n\t\tqla2x00_write_flash_byte(ha, 0xaaa, 0x10);\n\t} else {\n\t\tqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\n\t\tqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\n\t\tqla2x00_write_flash_byte(ha, 0x5555, 0x80);\n\t\tqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\n\t\tqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\n\t\tqla2x00_write_flash_byte(ha, 0x5555, 0x10);\n\t}\n\n\tudelay(150);\n\n\t \n\treturn qla2x00_poll_flash(ha, 0x00, 0x80, man_id, flash_id);\n}\n\n \nstatic int\nqla2x00_erase_flash_sector(struct qla_hw_data *ha, uint32_t addr,\n    uint32_t sec_mask, uint8_t man_id, uint8_t flash_id)\n{\n\t \n\tqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\n\tqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\n\tqla2x00_write_flash_byte(ha, 0x5555, 0x80);\n\tqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\n\tqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\n\tif (man_id == 0x1f && flash_id == 0x13)\n\t\tqla2x00_write_flash_byte(ha, addr & sec_mask, 0x10);\n\telse\n\t\tqla2x00_write_flash_byte(ha, addr & sec_mask, 0x30);\n\n\tudelay(150);\n\n\t \n\treturn qla2x00_poll_flash(ha, addr, 0x80, man_id, flash_id);\n}\n\n \nstatic void\nqla2x00_get_flash_manufacturer(struct qla_hw_data *ha, uint8_t *man_id,\n    uint8_t *flash_id)\n{\n\tqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\n\tqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\n\tqla2x00_write_flash_byte(ha, 0x5555, 0x90);\n\t*man_id = qla2x00_read_flash_byte(ha, 0x0000);\n\t*flash_id = qla2x00_read_flash_byte(ha, 0x0001);\n\tqla2x00_write_flash_byte(ha, 0x5555, 0xaa);\n\tqla2x00_write_flash_byte(ha, 0x2aaa, 0x55);\n\tqla2x00_write_flash_byte(ha, 0x5555, 0xf0);\n}\n\nstatic void\nqla2x00_read_flash_data(struct qla_hw_data *ha, uint8_t *tmp_buf,\n\tuint32_t saddr, uint32_t length)\n{\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tuint32_t midpoint, ilength;\n\tuint8_t data;\n\n\tmidpoint = length / 2;\n\n\twrt_reg_word(&reg->nvram, 0);\n\trd_reg_word(&reg->nvram);\n\tfor (ilength = 0; ilength < length; saddr++, ilength++, tmp_buf++) {\n\t\tif (ilength == midpoint) {\n\t\t\twrt_reg_word(&reg->nvram, NVR_SELECT);\n\t\t\trd_reg_word(&reg->nvram);\n\t\t}\n\t\tdata = qla2x00_read_flash_byte(ha, saddr);\n\t\tif (saddr % 100)\n\t\t\tudelay(10);\n\t\t*tmp_buf = data;\n\t\tcond_resched();\n\t}\n}\n\nstatic inline void\nqla2x00_suspend_hba(struct scsi_qla_host *vha)\n{\n\tint cnt;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\t \n\tscsi_block_requests(vha->host);\n\tha->isp_ops->disable_intrs(ha);\n\tset_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twrt_reg_word(&reg->hccr, HCCR_PAUSE_RISC);\n\trd_reg_word(&reg->hccr);\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha) || IS_QLA2300(ha)) {\n\t\tfor (cnt = 0; cnt < 30000; cnt++) {\n\t\t\tif ((rd_reg_word(&reg->hccr) & HCCR_RISC_PAUSE) != 0)\n\t\t\t\tbreak;\n\t\t\tudelay(100);\n\t\t}\n\t} else {\n\t\tudelay(10);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nstatic inline void\nqla2x00_resume_hba(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tclear_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\n\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\tqla2xxx_wake_dpc(vha);\n\tqla2x00_wait_for_chip_reset(vha);\n\tscsi_unblock_requests(vha->host);\n}\n\nvoid *\nqla2x00_read_optrom_data(struct scsi_qla_host *vha, void *buf,\n    uint32_t offset, uint32_t length)\n{\n\tuint32_t addr, midpoint;\n\tuint8_t *data;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\t \n\tqla2x00_suspend_hba(vha);\n\n\t \n\tmidpoint = ha->optrom_size / 2;\n\n\tqla2x00_flash_enable(ha);\n\twrt_reg_word(&reg->nvram, 0);\n\trd_reg_word(&reg->nvram);\t\t \n\tfor (addr = offset, data = buf; addr < length; addr++, data++) {\n\t\tif (addr == midpoint) {\n\t\t\twrt_reg_word(&reg->nvram, NVR_SELECT);\n\t\t\trd_reg_word(&reg->nvram);\t \n\t\t}\n\n\t\t*data = qla2x00_read_flash_byte(ha, addr);\n\t}\n\tqla2x00_flash_disable(ha);\n\n\t \n\tqla2x00_resume_hba(vha);\n\n\treturn buf;\n}\n\nint\nqla2x00_write_optrom_data(struct scsi_qla_host *vha, void *buf,\n    uint32_t offset, uint32_t length)\n{\n\n\tint rval;\n\tuint8_t man_id, flash_id, sec_number, *data;\n\tuint16_t wd;\n\tuint32_t addr, liter, sec_mask, rest_addr;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\t \n\tqla2x00_suspend_hba(vha);\n\n\trval = QLA_SUCCESS;\n\tsec_number = 0;\n\n\t \n\twrt_reg_word(&reg->ctrl_status, CSR_ISP_SOFT_RESET);\n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &wd);\n\n\t \n\tqla2x00_flash_enable(ha);\n\tdo {\t \n\t\t \n\t\tif (IS_OEM_001(ha)) {\n\t\t\t \n\t\t\tman_id = flash_id = 0;\n\t\t\trest_addr = 0xffff;\n\t\t\tsec_mask   = 0x10000;\n\t\t\tgoto update_flash;\n\t\t}\n\t\tqla2x00_get_flash_manufacturer(ha, &man_id, &flash_id);\n\t\tswitch (man_id) {\n\t\tcase 0x20:  \n\t\t\tif (flash_id == 0xd2 || flash_id == 0xe3) {\n\t\t\t\t \n\t\t\t\trest_addr = 0xffff;\n\t\t\t\tsec_mask = 0x10000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\trest_addr = 0x3fff;\n\t\t\tsec_mask = 0x1c000;\n\t\t\tbreak;\n\t\tcase 0x40:  \n\t\t\t \n\t\t\trest_addr = 0x1ff;\n\t\t\tsec_mask = 0x1fe00;\n\t\t\tbreak;\n\t\tcase 0xbf:  \n\t\t\t \n\t\t\trest_addr = 0xfff;\n\t\t\tsec_mask = 0x1f000;\n\t\t\tbreak;\n\t\tcase 0xda:  \n\t\t\t \n\t\t\trest_addr = 0x7f;\n\t\t\tsec_mask = 0x1ff80;\n\t\t\tbreak;\n\t\tcase 0xc2:  \n\t\t\t \n\t\t\tif (flash_id == 0x38 || flash_id == 0x4f) {\n\t\t\t\trest_addr = 0xffff;\n\t\t\t\tsec_mask = 0x10000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\n\t\tcase 0x1f:  \n\t\t\t \n\t\t\tif (flash_id == 0x13) {\n\t\t\t\trest_addr = 0x7fffffff;\n\t\t\t\tsec_mask =   0x80000000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\n\t\tcase 0x01:  \n\t\t\tif (flash_id == 0x38 || flash_id == 0x40 ||\n\t\t\t    flash_id == 0x4f) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\trest_addr = 0xffff;\n\t\t\t\tsec_mask = 0x10000;\n\t\t\t\tbreak;\n\t\t\t} else if (flash_id == 0x3e) {\n\t\t\t\t \n\t\t\t\trest_addr = 0xffff;\n\t\t\t\tsec_mask = 0x10000;\n\t\t\t\tbreak;\n\t\t\t} else if (flash_id == 0x20 || flash_id == 0x6e) {\n\t\t\t\t \n\t\t\t\trest_addr = 0x3fff;\n\t\t\t\tsec_mask = 0x1c000;\n\t\t\t\tbreak;\n\t\t\t} else if (flash_id == 0x6d) {\n\t\t\t\t \n\t\t\t\trest_addr = 0x1fff;\n\t\t\t\tsec_mask = 0x1e000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\t \n\t\t\trest_addr = 0x3fff;\n\t\t\tsec_mask = 0x1c000;\n\t\t\tbreak;\n\t\t}\n\nupdate_flash:\n\t\tif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\n\t\t\tif (qla2x00_erase_flash(ha, man_id, flash_id)) {\n\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (addr = offset, liter = 0; liter < length; liter++,\n\t\t    addr++) {\n\t\t\tdata = buf + liter;\n\t\t\t \n\t\t\tif ((addr & rest_addr) == 0) {\n\t\t\t\tif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\n\t\t\t\t\tif (addr >= 0x10000UL) {\n\t\t\t\t\t\tif (((addr >> 12) & 0xf0) &&\n\t\t\t\t\t\t    ((man_id == 0x01 &&\n\t\t\t\t\t\t\tflash_id == 0x3e) ||\n\t\t\t\t\t\t     (man_id == 0x20 &&\n\t\t\t\t\t\t\t flash_id == 0xd2))) {\n\t\t\t\t\t\t\tsec_number++;\n\t\t\t\t\t\t\tif (sec_number == 1) {\n\t\t\t\t\t\t\t\trest_addr =\n\t\t\t\t\t\t\t\t    0x7fff;\n\t\t\t\t\t\t\t\tsec_mask =\n\t\t\t\t\t\t\t\t    0x18000;\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t    sec_number == 2 ||\n\t\t\t\t\t\t\t    sec_number == 3) {\n\t\t\t\t\t\t\t\trest_addr =\n\t\t\t\t\t\t\t\t    0x1fff;\n\t\t\t\t\t\t\t\tsec_mask =\n\t\t\t\t\t\t\t\t    0x1e000;\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t    sec_number == 4) {\n\t\t\t\t\t\t\t\trest_addr =\n\t\t\t\t\t\t\t\t    0x3fff;\n\t\t\t\t\t\t\t\tsec_mask =\n\t\t\t\t\t\t\t\t    0x1c000;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (addr == ha->optrom_size / 2) {\n\t\t\t\t\twrt_reg_word(&reg->nvram, NVR_SELECT);\n\t\t\t\t\trd_reg_word(&reg->nvram);\n\t\t\t\t}\n\n\t\t\t\tif (flash_id == 0xda && man_id == 0xc1) {\n\t\t\t\t\tqla2x00_write_flash_byte(ha, 0x5555,\n\t\t\t\t\t    0xaa);\n\t\t\t\t\tqla2x00_write_flash_byte(ha, 0x2aaa,\n\t\t\t\t\t    0x55);\n\t\t\t\t\tqla2x00_write_flash_byte(ha, 0x5555,\n\t\t\t\t\t    0xa0);\n\t\t\t\t} else if (!IS_QLA2322(ha) && !IS_QLA6322(ha)) {\n\t\t\t\t\t \n\t\t\t\t\tif (qla2x00_erase_flash_sector(ha,\n\t\t\t\t\t    addr, sec_mask, man_id,\n\t\t\t\t\t    flash_id)) {\n\t\t\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (man_id == 0x01 && flash_id == 0x6d)\n\t\t\t\t\t\tsec_number++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (man_id == 0x01 && flash_id == 0x6d) {\n\t\t\t\tif (sec_number == 1 &&\n\t\t\t\t    addr == (rest_addr - 1)) {\n\t\t\t\t\trest_addr = 0x0fff;\n\t\t\t\t\tsec_mask   = 0x1f000;\n\t\t\t\t} else if (sec_number == 3 && (addr & 0x7ffe)) {\n\t\t\t\t\trest_addr = 0x3fff;\n\t\t\t\t\tsec_mask   = 0x1c000;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (qla2x00_program_flash_address(ha, addr, *data,\n\t\t\t    man_id, flash_id)) {\n\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t} while (0);\n\tqla2x00_flash_disable(ha);\n\n\t \n\tqla2x00_resume_hba(vha);\n\n\treturn rval;\n}\n\nvoid *\nqla24xx_read_optrom_data(struct scsi_qla_host *vha, void *buf,\n    uint32_t offset, uint32_t length)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tscsi_block_requests(vha->host);\n\tset_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\n\n\t \n\tqla24xx_read_flash_data(vha, buf, offset >> 2, length >> 2);\n\n\t \n\tclear_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\n\tscsi_unblock_requests(vha->host);\n\n\treturn buf;\n}\n\nstatic int\nqla28xx_extract_sfub_and_verify(struct scsi_qla_host *vha, __le32 *buf,\n    uint32_t len, uint32_t buf_size_without_sfub, uint8_t *sfub_buf)\n{\n\tuint32_t check_sum = 0;\n\t__le32 *p;\n\tint i;\n\n\tp = buf + buf_size_without_sfub;\n\n\t \n\tmemcpy(sfub_buf, (uint8_t *)p,\n\t    sizeof(struct secure_flash_update_block));\n\n\tfor (i = 0; i < (sizeof(struct secure_flash_update_block) >> 2); i++)\n\t\tcheck_sum += le32_to_cpu(p[i]);\n\n\tcheck_sum = (~check_sum) + 1;\n\n\tif (check_sum != le32_to_cpu(p[i])) {\n\t\tql_log(ql_log_warn, vha, 0x7097,\n\t\t    \"SFUB checksum failed, 0x%x, 0x%x\\n\",\n\t\t    check_sum, le32_to_cpu(p[i]));\n\t\treturn QLA_COMMAND_ERROR;\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\nstatic int\nqla28xx_get_flash_region(struct scsi_qla_host *vha, uint32_t start,\n    struct qla_flt_region *region)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_flt_header *flt = ha->flt;\n\tstruct qla_flt_region *flt_reg = &flt->region[0];\n\tuint16_t cnt;\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (!ha->flt)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tcnt = le16_to_cpu(flt->length) / sizeof(struct qla_flt_region);\n\tfor (; cnt; cnt--, flt_reg++) {\n\t\tif (le32_to_cpu(flt_reg->start) == start) {\n\t\t\tmemcpy((uint8_t *)region, flt_reg,\n\t\t\t    sizeof(struct qla_flt_region));\n\t\t\trval = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rval;\n}\n\nstatic int\nqla28xx_write_flash_data(scsi_qla_host_t *vha, uint32_t *dwptr, uint32_t faddr,\n    uint32_t dwords)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tulong liter;\n\tulong dburst = OPTROM_BURST_DWORDS;  \n\tuint32_t sec_mask, rest_addr, fdata;\n\tvoid *optrom = NULL;\n\tdma_addr_t optrom_dma;\n\tint rval, ret;\n\tstruct secure_flash_update_block *sfub;\n\tdma_addr_t sfub_dma;\n\tuint32_t offset = faddr << 2;\n\tuint32_t buf_size_without_sfub = 0;\n\tstruct qla_flt_region region;\n\tbool reset_to_rom = false;\n\tuint32_t risc_size, risc_attr = 0;\n\t__be32 *fw_array = NULL;\n\n\t \n\trval = qla28xx_get_flash_region(vha, offset, &region);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"Invalid address %x - not a region start address\\n\",\n\t\t    offset);\n\t\tgoto done;\n\t}\n\n\t \n\toptrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\n\t    &optrom_dma, GFP_KERNEL);\n\tif (!optrom) {\n\t\tql_log(ql_log_warn, vha, 0x7095,\n\t\t    \"Failed allocate burst (%x bytes)\\n\", OPTROM_BURST_SIZE);\n\t\trval = QLA_COMMAND_ERROR;\n\t\tgoto done;\n\t}\n\n\t \n\tif (ha->flags.secure_adapter && region.attribute) {\n\n\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,\n\t\t    \"Region %x is secure\\n\", le16_to_cpu(region.code));\n\n\t\tswitch (le16_to_cpu(region.code)) {\n\t\tcase FLT_REG_FW:\n\t\tcase FLT_REG_FW_SEC_27XX:\n\t\tcase FLT_REG_MPI_PRI_28XX:\n\t\tcase FLT_REG_MPI_SEC_28XX:\n\t\t\tfw_array = (__force __be32 *)dwptr;\n\n\t\t\t \n\t\t\trisc_size = be32_to_cpu(fw_array[3]);\n\t\t\trisc_attr = be32_to_cpu(fw_array[9]);\n\n\t\t\tbuf_size_without_sfub = risc_size;\n\t\t\tfw_array += risc_size;\n\n\t\t\t \n\t\t\trisc_size = be32_to_cpu(fw_array[3]);\n\n\t\t\tbuf_size_without_sfub += risc_size;\n\t\t\tfw_array += risc_size;\n\n\t\t\t \n\t\t\trisc_size = be32_to_cpu(fw_array[2]);\n\n\t\t\t \n\t\t\tbuf_size_without_sfub += risc_size;\n\t\t\tfw_array += risc_size;\n\n\t\t\tif (risc_attr & BIT_9) {\n\t\t\t\t \n\t\t\t\trisc_size = be32_to_cpu(fw_array[2]);\n\n\t\t\t\t \n\t\t\t\tbuf_size_without_sfub += risc_size;\n\t\t\t\tfw_array += risc_size;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FLT_REG_PEP_PRI_28XX:\n\t\tcase FLT_REG_PEP_SEC_28XX:\n\t\t\tfw_array = (__force __be32 *)dwptr;\n\n\t\t\t \n\t\t\trisc_size = be32_to_cpu(fw_array[3]);\n\t\t\trisc_attr = be32_to_cpu(fw_array[9]);\n\n\t\t\tbuf_size_without_sfub = risc_size;\n\t\t\tfw_array += risc_size;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha,\n\t\t\t    0xffff, \"Secure region %x not supported\\n\",\n\t\t\t    le16_to_cpu(region.code));\n\t\t\trval = QLA_COMMAND_ERROR;\n\t\t\tgoto done;\n\t\t}\n\n\t\tsfub = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\tsizeof(struct secure_flash_update_block), &sfub_dma,\n\t\t\tGFP_KERNEL);\n\t\tif (!sfub) {\n\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t    \"Unable to allocate memory for SFUB\\n\");\n\t\t\trval = QLA_COMMAND_ERROR;\n\t\t\tgoto done;\n\t\t}\n\n\t\trval = qla28xx_extract_sfub_and_verify(vha, (__le32 *)dwptr,\n\t\t\tdwords, buf_size_without_sfub, (uint8_t *)sfub);\n\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tgoto done;\n\n\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,\n\t\t    \"SFUB extract and verify successful\\n\");\n\t}\n\n\trest_addr = (ha->fdt_block_size >> 2) - 1;\n\tsec_mask = ~rest_addr;\n\n\t \n\trval = qla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_LOCK);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"Unable to lock flash semaphore.\");\n\t\tgoto done;\n\t}\n\n\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,\n\t    \"Unprotect flash...\\n\");\n\trval = qla24xx_unprotect_flash(vha);\n\tif (rval) {\n\t\tqla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_UNLOCK);\n\t\tql_log(ql_log_warn, vha, 0x7096, \"Failed unprotect flash\\n\");\n\t\tgoto done;\n\t}\n\n\tfor (liter = 0; liter < dwords; liter++, faddr++) {\n\t\tfdata = (faddr & sec_mask) << 2;\n\n\t\t \n\t\tif (!(faddr & rest_addr)) {\n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,\n\t\t\t    \"Erase sector %#x...\\n\", faddr);\n\t\t\trval = qla24xx_erase_sector(vha, fdata);\n\t\t\tif (rval) {\n\t\t\t\tql_dbg(ql_dbg_user, vha, 0x7007,\n\t\t\t\t    \"Failed erase sector %#x\\n\", faddr);\n\t\t\t\tgoto write_protect;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ha->flags.secure_adapter) {\n\t\t \n\t\tif (!ha->flags.secure_fw) {\n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,\n\t\t\t    \"Disable Write and Release Semaphore.\");\n\t\t\trval = qla24xx_protect_flash(vha);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla81xx_fac_semaphore_access(vha,\n\t\t\t\t\tFAC_SEMAPHORE_UNLOCK);\n\t\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t\t    \"Unable to protect flash.\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,\n\t\t\t    \"Reset chip to ROM.\");\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tset_bit(ISP_ABORT_TO_ROM, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\trval = qla2x00_wait_for_chip_reset(vha);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t\t    \"Unable to reset to ROM code.\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\treset_to_rom = true;\n\t\t\tha->flags.fac_supported = 0;\n\n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,\n\t\t\t    \"Lock Semaphore\");\n\t\t\trval = qla2xxx_write_remote_register(vha,\n\t\t\t    FLASH_SEMAPHORE_REGISTER_ADDR, 0x00020002);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t\t    \"Unable to lock flash semaphore.\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t \n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,\n\t\t\t    \"Enable Write.\");\n\t\t\trval = qla2x00_write_ram_word(vha, 0x7ffd0101, 0);\n\t\t\tif (rval) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x7096,\n\t\t\t\t    \"Failed unprotect flash\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (region.attribute && buf_size_without_sfub) {\n\t\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0xffff,\n\t\t\t    \"Sending Secure Flash MB Cmd\\n\");\n\t\t\trval = qla28xx_secure_flash_update(vha, 0,\n\t\t\t\tle16_to_cpu(region.code),\n\t\t\t\tbuf_size_without_sfub, sfub_dma,\n\t\t\t\tsizeof(struct secure_flash_update_block) >> 2);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t\t    \"Secure Flash MB Cmd failed %x.\", rval);\n\t\t\t\tgoto write_protect;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t \n\tfaddr = offset >> 2;\n\n\tfor (liter = 0; liter < dwords; liter++, faddr++, dwptr++) {\n\t\tfdata = (faddr & sec_mask) << 2;\n\n\t\t \n\t\tif (dwords - liter < dburst)\n\t\t\tdburst = dwords - liter;\n\n\t\t \n\t\tmemcpy(optrom, dwptr, dburst << 2);\n\n\t\t \n\t\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,\n\t\t    \"Write burst (%#lx dwords)...\\n\", dburst);\n\t\trval = qla2x00_load_ram(vha, optrom_dma,\n\t\t    flash_data_addr(ha, faddr), dburst);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x7097,\n\t\t\t    \"Failed burst write at %x (%p/%#llx)...\\n\",\n\t\t\t    flash_data_addr(ha, faddr), optrom,\n\t\t\t    (u64)optrom_dma);\n\t\t\tbreak;\n\t\t}\n\n\t\tliter += dburst - 1;\n\t\tfaddr += dburst - 1;\n\t\tdwptr += dburst - 1;\n\t}\n\nwrite_protect:\n\tql_log(ql_log_warn + ql_dbg_verbose, vha, 0x7095,\n\t    \"Protect flash...\\n\");\n\tret = qla24xx_protect_flash(vha);\n\tif (ret) {\n\t\tqla81xx_fac_semaphore_access(vha, FAC_SEMAPHORE_UNLOCK);\n\t\tql_log(ql_log_warn, vha, 0x7099,\n\t\t    \"Failed protect flash\\n\");\n\t\trval = QLA_COMMAND_ERROR;\n\t}\n\n\tif (reset_to_rom == true) {\n\t\t \n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\n\t\tret = qla2x00_wait_for_hba_online(vha);\n\t\tif (ret != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t    \"Adapter did not come out of reset\\n\");\n\t\t\trval = QLA_COMMAND_ERROR;\n\t\t}\n\t}\n\ndone:\n\tif (optrom)\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t    OPTROM_BURST_SIZE, optrom, optrom_dma);\n\n\treturn rval;\n}\n\nint\nqla24xx_write_optrom_data(struct scsi_qla_host *vha, void *buf,\n    uint32_t offset, uint32_t length)\n{\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tscsi_block_requests(vha->host);\n\tset_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\n\n\t \n\tif (IS_QLA28XX(ha))\n\t\trval = qla28xx_write_flash_data(vha, buf, offset >> 2,\n\t\t\t\t\t\tlength >> 2);\n\telse\n\t\trval = qla24xx_write_flash_data(vha, buf, offset >> 2,\n\t\t\t\t\t\tlength >> 2);\n\n\tclear_bit(MBX_UPDATE_FLASH_ACTIVE, &ha->mbx_cmd_flags);\n\tscsi_unblock_requests(vha->host);\n\n\treturn rval;\n}\n\nvoid *\nqla25xx_read_optrom_data(struct scsi_qla_host *vha, void *buf,\n    uint32_t offset, uint32_t length)\n{\n\tint rval;\n\tdma_addr_t optrom_dma;\n\tvoid *optrom;\n\tuint8_t *pbuf;\n\tuint32_t faddr, left, burst;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha) ||\n\t    IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tgoto try_fast;\n\tif (offset & 0xfff)\n\t\tgoto slow_read;\n\tif (length < OPTROM_BURST_SIZE)\n\t\tgoto slow_read;\n\ntry_fast:\n\tif (offset & 0xff)\n\t\tgoto slow_read;\n\toptrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\n\t    &optrom_dma, GFP_KERNEL);\n\tif (!optrom) {\n\t\tql_log(ql_log_warn, vha, 0x00cc,\n\t\t    \"Unable to allocate memory for optrom burst read (%x KB).\\n\",\n\t\t    OPTROM_BURST_SIZE / 1024);\n\t\tgoto slow_read;\n\t}\n\n\tpbuf = buf;\n\tfaddr = offset >> 2;\n\tleft = length >> 2;\n\tburst = OPTROM_BURST_DWORDS;\n\twhile (left != 0) {\n\t\tif (burst > left)\n\t\t\tburst = left;\n\n\t\trval = qla2x00_dump_ram(vha, optrom_dma,\n\t\t    flash_data_addr(ha, faddr), burst);\n\t\tif (rval) {\n\t\t\tql_log(ql_log_warn, vha, 0x00f5,\n\t\t\t    \"Unable to burst-read optrom segment (%x/%x/%llx).\\n\",\n\t\t\t    rval, flash_data_addr(ha, faddr),\n\t\t\t    (unsigned long long)optrom_dma);\n\t\t\tql_log(ql_log_warn, vha, 0x00f6,\n\t\t\t    \"Reverting to slow-read.\\n\");\n\n\t\t\tdma_free_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\n\t\t\t    optrom, optrom_dma);\n\t\t\tgoto slow_read;\n\t\t}\n\n\t\tmemcpy(pbuf, optrom, burst * 4);\n\n\t\tleft -= burst;\n\t\tfaddr += burst;\n\t\tpbuf += burst * 4;\n\t}\n\n\tdma_free_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE, optrom,\n\t    optrom_dma);\n\n\treturn buf;\n\nslow_read:\n    return qla24xx_read_optrom_data(vha, buf, offset, length);\n}\n\n \nstatic void\nqla2x00_get_fcode_version(struct qla_hw_data *ha, uint32_t pcids)\n{\n\tint ret = QLA_FUNCTION_FAILED;\n\tuint32_t istart, iend, iter, vend;\n\tuint8_t do_next, rbyte, *vbyte;\n\n\tmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\n\n\t \n\tistart = pcids +\n\t    ((qla2x00_read_flash_byte(ha, pcids + 0x0B) << 8) |\n\t\tqla2x00_read_flash_byte(ha, pcids + 0x0A));\n\tiend = istart + 0x100;\n\tdo {\n\t\t \n\t\tdo_next = 0;\n\t\titer = istart;\n\t\twhile ((iter < iend) && !do_next) {\n\t\t\titer++;\n\t\t\tif (qla2x00_read_flash_byte(ha, iter) == '/') {\n\t\t\t\tif (qla2x00_read_flash_byte(ha, iter + 2) ==\n\t\t\t\t    '/')\n\t\t\t\t\tdo_next++;\n\t\t\t\telse if (qla2x00_read_flash_byte(ha,\n\t\t\t\t    iter + 3) == '/')\n\t\t\t\t\tdo_next++;\n\t\t\t}\n\t\t}\n\t\tif (!do_next)\n\t\t\tbreak;\n\n\t\t \n\t\tdo_next = 0;\n\t\twhile ((iter > istart) && !do_next) {\n\t\t\titer--;\n\t\t\tif (qla2x00_read_flash_byte(ha, iter) == ' ')\n\t\t\t\tdo_next++;\n\t\t}\n\t\tif (!do_next)\n\t\t\tbreak;\n\n\t\t \n\t\tvend = iter - 1;\n\t\tdo_next = 0;\n\t\twhile ((iter > istart) && !do_next) {\n\t\t\titer--;\n\t\t\trbyte = qla2x00_read_flash_byte(ha, iter);\n\t\t\tif (rbyte == ' ' || rbyte == 0xd || rbyte == 0x10)\n\t\t\t\tdo_next++;\n\t\t}\n\t\tif (!do_next)\n\t\t\tbreak;\n\n\t\t \n\t\titer++;\n\t\tif ((vend - iter) &&\n\t\t    ((vend - iter) < sizeof(ha->fcode_revision))) {\n\t\t\tvbyte = ha->fcode_revision;\n\t\t\twhile (iter <= vend) {\n\t\t\t\t*vbyte++ = qla2x00_read_flash_byte(ha, iter);\n\t\t\t\titer++;\n\t\t\t}\n\t\t\tret = QLA_SUCCESS;\n\t\t}\n\t} while (0);\n\n\tif (ret != QLA_SUCCESS)\n\t\tmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\n}\n\nint\nqla2x00_get_flash_version(scsi_qla_host_t *vha, void *mbuf)\n{\n\tint ret = QLA_SUCCESS;\n\tuint8_t code_type, last_image;\n\tuint32_t pcihdr, pcids;\n\tuint8_t *dbyte;\n\tuint16_t *dcode;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->pio_address || !mbuf)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmemset(ha->bios_revision, 0, sizeof(ha->bios_revision));\n\tmemset(ha->efi_revision, 0, sizeof(ha->efi_revision));\n\tmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\n\tmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\n\n\tqla2x00_flash_enable(ha);\n\n\t \n\tpcihdr = 0;\n\tlast_image = 1;\n\tdo {\n\t\t \n\t\tif (qla2x00_read_flash_byte(ha, pcihdr) != 0x55 ||\n\t\t    qla2x00_read_flash_byte(ha, pcihdr + 0x01) != 0xaa) {\n\t\t\t \n\t\t\tql_log(ql_log_fatal, vha, 0x0050,\n\t\t\t    \"No matching ROM signature.\\n\");\n\t\t\tret = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpcids = pcihdr +\n\t\t    ((qla2x00_read_flash_byte(ha, pcihdr + 0x19) << 8) |\n\t\t\tqla2x00_read_flash_byte(ha, pcihdr + 0x18));\n\n\t\t \n\t\tif (qla2x00_read_flash_byte(ha, pcids) != 'P' ||\n\t\t    qla2x00_read_flash_byte(ha, pcids + 0x1) != 'C' ||\n\t\t    qla2x00_read_flash_byte(ha, pcids + 0x2) != 'I' ||\n\t\t    qla2x00_read_flash_byte(ha, pcids + 0x3) != 'R') {\n\t\t\t \n\t\t\tql_log(ql_log_fatal, vha, 0x0051,\n\t\t\t    \"PCI data struct not found pcir_adr=%x.\\n\", pcids);\n\t\t\tret = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcode_type = qla2x00_read_flash_byte(ha, pcids + 0x14);\n\t\tswitch (code_type) {\n\t\tcase ROM_CODE_TYPE_BIOS:\n\t\t\t \n\t\t\tha->bios_revision[0] =\n\t\t\t    qla2x00_read_flash_byte(ha, pcids + 0x12);\n\t\t\tha->bios_revision[1] =\n\t\t\t    qla2x00_read_flash_byte(ha, pcids + 0x13);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0052,\n\t\t\t    \"Read BIOS %d.%d.\\n\",\n\t\t\t    ha->bios_revision[1], ha->bios_revision[0]);\n\t\t\tbreak;\n\t\tcase ROM_CODE_TYPE_FCODE:\n\t\t\t \n\t\t\t \n\t\t\tqla2x00_get_fcode_version(ha, pcids);\n\t\t\tbreak;\n\t\tcase ROM_CODE_TYPE_EFI:\n\t\t\t \n\t\t\tha->efi_revision[0] =\n\t\t\t    qla2x00_read_flash_byte(ha, pcids + 0x12);\n\t\t\tha->efi_revision[1] =\n\t\t\t    qla2x00_read_flash_byte(ha, pcids + 0x13);\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0053,\n\t\t\t    \"Read EFI %d.%d.\\n\",\n\t\t\t    ha->efi_revision[1], ha->efi_revision[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_log(ql_log_warn, vha, 0x0054,\n\t\t\t    \"Unrecognized code type %x at pcids %x.\\n\",\n\t\t\t    code_type, pcids);\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_image = qla2x00_read_flash_byte(ha, pcids + 0x15) & BIT_7;\n\n\t\t \n\t\tpcihdr += ((qla2x00_read_flash_byte(ha, pcids + 0x11) << 8) |\n\t\t    qla2x00_read_flash_byte(ha, pcids + 0x10)) * 512;\n\t} while (!last_image);\n\n\tif (IS_QLA2322(ha)) {\n\t\t \n\t\tmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\n\t\tdbyte = mbuf;\n\t\tmemset(dbyte, 0, 8);\n\t\tdcode = (uint16_t *)dbyte;\n\n\t\tqla2x00_read_flash_data(ha, dbyte, ha->flt_region_fw * 4 + 10,\n\t\t    8);\n\t\tql_dbg(ql_dbg_init + ql_dbg_buffer, vha, 0x010a,\n\t\t    \"Dumping fw \"\n\t\t    \"ver from flash:.\\n\");\n\t\tql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x010b,\n\t\t    dbyte, 32);\n\n\t\tif ((dcode[0] == 0xffff && dcode[1] == 0xffff &&\n\t\t    dcode[2] == 0xffff && dcode[3] == 0xffff) ||\n\t\t    (dcode[0] == 0 && dcode[1] == 0 && dcode[2] == 0 &&\n\t\t    dcode[3] == 0)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0057,\n\t\t\t    \"Unrecognized fw revision at %x.\\n\",\n\t\t\t    ha->flt_region_fw * 4);\n\t\t} else {\n\t\t\t \n\t\t\tha->fw_revision[0] = dbyte[0] << 16 | dbyte[1];\n\t\t\tha->fw_revision[1] = dbyte[2] << 16 | dbyte[3];\n\t\t\tha->fw_revision[2] = dbyte[4] << 16 | dbyte[5];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0058,\n\t\t\t    \"FW Version: \"\n\t\t\t    \"%d.%d.%d.\\n\", ha->fw_revision[0],\n\t\t\t    ha->fw_revision[1], ha->fw_revision[2]);\n\t\t}\n\t}\n\n\tqla2x00_flash_disable(ha);\n\n\treturn ret;\n}\n\nint\nqla82xx_get_flash_version(scsi_qla_host_t *vha, void *mbuf)\n{\n\tint ret = QLA_SUCCESS;\n\tuint32_t pcihdr, pcids;\n\tuint32_t *dcode = mbuf;\n\tuint8_t *bcode = mbuf;\n\tuint8_t code_type, last_image;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!mbuf)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmemset(ha->bios_revision, 0, sizeof(ha->bios_revision));\n\tmemset(ha->efi_revision, 0, sizeof(ha->efi_revision));\n\tmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\n\tmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\n\n\t \n\tpcihdr = ha->flt_region_boot << 2;\n\tlast_image = 1;\n\tdo {\n\t\t \n\t\tha->isp_ops->read_optrom(vha, dcode, pcihdr, 0x20 * 4);\n\t\tbcode = mbuf + (pcihdr % 4);\n\t\tif (memcmp(bcode, \"\\x55\\xaa\", 2)) {\n\t\t\t \n\t\t\tql_log(ql_log_fatal, vha, 0x0154,\n\t\t\t    \"No matching ROM signature.\\n\");\n\t\t\tret = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpcids = pcihdr + ((bcode[0x19] << 8) | bcode[0x18]);\n\n\t\tha->isp_ops->read_optrom(vha, dcode, pcids, 0x20 * 4);\n\t\tbcode = mbuf + (pcihdr % 4);\n\n\t\t \n\t\tif (memcmp(bcode, \"PCIR\", 4)) {\n\t\t\t \n\t\t\tql_log(ql_log_fatal, vha, 0x0155,\n\t\t\t    \"PCI data struct not found pcir_adr=%x.\\n\", pcids);\n\t\t\tret = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcode_type = bcode[0x14];\n\t\tswitch (code_type) {\n\t\tcase ROM_CODE_TYPE_BIOS:\n\t\t\t \n\t\t\tha->bios_revision[0] = bcode[0x12];\n\t\t\tha->bios_revision[1] = bcode[0x13];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0156,\n\t\t\t    \"Read BIOS %d.%d.\\n\",\n\t\t\t    ha->bios_revision[1], ha->bios_revision[0]);\n\t\t\tbreak;\n\t\tcase ROM_CODE_TYPE_FCODE:\n\t\t\t \n\t\t\tha->fcode_revision[0] = bcode[0x12];\n\t\t\tha->fcode_revision[1] = bcode[0x13];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0157,\n\t\t\t    \"Read FCODE %d.%d.\\n\",\n\t\t\t    ha->fcode_revision[1], ha->fcode_revision[0]);\n\t\t\tbreak;\n\t\tcase ROM_CODE_TYPE_EFI:\n\t\t\t \n\t\t\tha->efi_revision[0] = bcode[0x12];\n\t\t\tha->efi_revision[1] = bcode[0x13];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x0158,\n\t\t\t    \"Read EFI %d.%d.\\n\",\n\t\t\t    ha->efi_revision[1], ha->efi_revision[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_log(ql_log_warn, vha, 0x0159,\n\t\t\t    \"Unrecognized code type %x at pcids %x.\\n\",\n\t\t\t    code_type, pcids);\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_image = bcode[0x15] & BIT_7;\n\n\t\t \n\t\tpcihdr += ((bcode[0x11] << 8) | bcode[0x10]) * 512;\n\t} while (!last_image);\n\n\t \n\tmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\n\tdcode = mbuf;\n\tha->isp_ops->read_optrom(vha, dcode, ha->flt_region_fw << 2, 0x20);\n\tbcode = mbuf + (pcihdr % 4);\n\n\t \n\tif (bcode[0x0] == 0x3 && bcode[0x1] == 0x0 &&\n\t    bcode[0x2] == 0x40 && bcode[0x3] == 0x40) {\n\t\tha->fw_revision[0] = bcode[0x4];\n\t\tha->fw_revision[1] = bcode[0x5];\n\t\tha->fw_revision[2] = bcode[0x6];\n\t\tql_dbg(ql_dbg_init, vha, 0x0153,\n\t\t    \"Firmware revision %d.%d.%d\\n\",\n\t\t    ha->fw_revision[0], ha->fw_revision[1],\n\t\t    ha->fw_revision[2]);\n\t}\n\n\treturn ret;\n}\n\nint\nqla24xx_get_flash_version(scsi_qla_host_t *vha, void *mbuf)\n{\n\tint ret = QLA_SUCCESS;\n\tuint32_t pcihdr = 0, pcids = 0;\n\tuint32_t *dcode = mbuf;\n\tuint8_t *bcode = mbuf;\n\tuint8_t code_type, last_image;\n\tint i;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t faddr = 0;\n\tstruct active_regions active_regions = { };\n\n\tif (IS_P3P_TYPE(ha))\n\t\treturn ret;\n\n\tif (!mbuf)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmemset(ha->bios_revision, 0, sizeof(ha->bios_revision));\n\tmemset(ha->efi_revision, 0, sizeof(ha->efi_revision));\n\tmemset(ha->fcode_revision, 0, sizeof(ha->fcode_revision));\n\tmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\n\n\tpcihdr = ha->flt_region_boot << 2;\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tqla27xx_get_active_image(vha, &active_regions);\n\t\tif (active_regions.global == QLA27XX_SECONDARY_IMAGE) {\n\t\t\tpcihdr = ha->flt_region_boot_sec << 2;\n\t\t}\n\t}\n\n\tdo {\n\t\t \n\t\tqla24xx_read_flash_data(vha, dcode, pcihdr >> 2, 0x20);\n\t\tbcode = mbuf + (pcihdr % 4);\n\t\tif (memcmp(bcode, \"\\x55\\xaa\", 2)) {\n\t\t\t \n\t\t\tql_log(ql_log_fatal, vha, 0x0059,\n\t\t\t    \"No matching ROM signature.\\n\");\n\t\t\tret = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpcids = pcihdr + ((bcode[0x19] << 8) | bcode[0x18]);\n\n\t\tqla24xx_read_flash_data(vha, dcode, pcids >> 2, 0x20);\n\t\tbcode = mbuf + (pcihdr % 4);\n\n\t\t \n\t\tif (memcmp(bcode, \"PCIR\", 4)) {\n\t\t\t \n\t\t\tql_log(ql_log_fatal, vha, 0x005a,\n\t\t\t    \"PCI data struct not found pcir_adr=%x.\\n\", pcids);\n\t\t\tql_dump_buffer(ql_dbg_init, vha, 0x0059, dcode, 32);\n\t\t\tret = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcode_type = bcode[0x14];\n\t\tswitch (code_type) {\n\t\tcase ROM_CODE_TYPE_BIOS:\n\t\t\t \n\t\t\tha->bios_revision[0] = bcode[0x12];\n\t\t\tha->bios_revision[1] = bcode[0x13];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x005b,\n\t\t\t    \"Read BIOS %d.%d.\\n\",\n\t\t\t    ha->bios_revision[1], ha->bios_revision[0]);\n\t\t\tbreak;\n\t\tcase ROM_CODE_TYPE_FCODE:\n\t\t\t \n\t\t\tha->fcode_revision[0] = bcode[0x12];\n\t\t\tha->fcode_revision[1] = bcode[0x13];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x005c,\n\t\t\t    \"Read FCODE %d.%d.\\n\",\n\t\t\t    ha->fcode_revision[1], ha->fcode_revision[0]);\n\t\t\tbreak;\n\t\tcase ROM_CODE_TYPE_EFI:\n\t\t\t \n\t\t\tha->efi_revision[0] = bcode[0x12];\n\t\t\tha->efi_revision[1] = bcode[0x13];\n\t\t\tql_dbg(ql_dbg_init, vha, 0x005d,\n\t\t\t    \"Read EFI %d.%d.\\n\",\n\t\t\t    ha->efi_revision[1], ha->efi_revision[0]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_log(ql_log_warn, vha, 0x005e,\n\t\t\t    \"Unrecognized code type %x at pcids %x.\\n\",\n\t\t\t    code_type, pcids);\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_image = bcode[0x15] & BIT_7;\n\n\t\t \n\t\tpcihdr += ((bcode[0x11] << 8) | bcode[0x10]) * 512;\n\t} while (!last_image);\n\n\t \n\tmemset(ha->fw_revision, 0, sizeof(ha->fw_revision));\n\tfaddr = ha->flt_region_fw;\n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tqla27xx_get_active_image(vha, &active_regions);\n\t\tif (active_regions.global == QLA27XX_SECONDARY_IMAGE)\n\t\t\tfaddr = ha->flt_region_fw_sec;\n\t}\n\n\tqla24xx_read_flash_data(vha, dcode, faddr, 8);\n\tif (qla24xx_risc_firmware_invalid(dcode)) {\n\t\tql_log(ql_log_warn, vha, 0x005f,\n\t\t    \"Unrecognized fw revision at %x.\\n\",\n\t\t    ha->flt_region_fw * 4);\n\t\tql_dump_buffer(ql_dbg_init, vha, 0x005f, dcode, 32);\n\t} else {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tha->fw_revision[i] =\n\t\t\t\tbe32_to_cpu((__force __be32)dcode[4+i]);\n\t\tql_dbg(ql_dbg_init, vha, 0x0060,\n\t\t    \"Firmware revision (flash) %u.%u.%u (%x).\\n\",\n\t\t    ha->fw_revision[0], ha->fw_revision[1],\n\t\t    ha->fw_revision[2], ha->fw_revision[3]);\n\t}\n\n\t \n\tif (!IS_QLA81XX(ha)) {\n\t\t \n\t\treturn ret;\n\t}\n\n\tmemset(ha->gold_fw_version, 0, sizeof(ha->gold_fw_version));\n\tfaddr = ha->flt_region_gold_fw;\n\tqla24xx_read_flash_data(vha, dcode, ha->flt_region_gold_fw, 8);\n\tif (qla24xx_risc_firmware_invalid(dcode)) {\n\t\tql_log(ql_log_warn, vha, 0x0056,\n\t\t    \"Unrecognized golden fw at %#x.\\n\", faddr);\n\t\tql_dump_buffer(ql_dbg_init, vha, 0x0056, dcode, 32);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tha->gold_fw_version[i] =\n\t\t\tbe32_to_cpu((__force __be32)dcode[4+i]);\n\n\treturn ret;\n}\n\nstatic int\nqla2xxx_is_vpd_valid(uint8_t *pos, uint8_t *end)\n{\n\tif (pos >= end || *pos != 0x82)\n\t\treturn 0;\n\n\tpos += 3 + pos[1];\n\tif (pos >= end || *pos != 0x90)\n\t\treturn 0;\n\n\tpos += 3 + pos[1];\n\tif (pos >= end || *pos != 0x78)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint\nqla2xxx_get_vpd_field(scsi_qla_host_t *vha, char *key, char *str, size_t size)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint8_t *pos = ha->vpd;\n\tuint8_t *end = pos + ha->vpd_size;\n\tint len = 0;\n\n\tif (!IS_FWI2_CAPABLE(ha) || !qla2xxx_is_vpd_valid(pos, end))\n\t\treturn 0;\n\n\twhile (pos < end && *pos != 0x78) {\n\t\tlen = (*pos == 0x82) ? pos[1] : pos[2];\n\n\t\tif (!strncmp(pos, key, strlen(key)))\n\t\t\tbreak;\n\n\t\tif (*pos != 0x90 && *pos != 0x91)\n\t\t\tpos += len;\n\n\t\tpos += 3;\n\t}\n\n\tif (pos < end - len && *pos != 0x78)\n\t\treturn scnprintf(str, size, \"%.*s\", len, pos + 3);\n\n\treturn 0;\n}\n\nint\nqla24xx_read_fcp_prio_cfg(scsi_qla_host_t *vha)\n{\n\tint len, max_len;\n\tuint32_t fcp_prio_addr;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->fcp_prio_cfg) {\n\t\tha->fcp_prio_cfg = vmalloc(FCP_PRIO_CFG_SIZE);\n\t\tif (!ha->fcp_prio_cfg) {\n\t\t\tql_log(ql_log_warn, vha, 0x00d5,\n\t\t\t    \"Unable to allocate memory for fcp priority data (%x).\\n\",\n\t\t\t    FCP_PRIO_CFG_SIZE);\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\tmemset(ha->fcp_prio_cfg, 0, FCP_PRIO_CFG_SIZE);\n\n\tfcp_prio_addr = ha->flt_region_fcp_prio;\n\n\t \n\tha->isp_ops->read_optrom(vha, ha->fcp_prio_cfg,\n\t\t\tfcp_prio_addr << 2, FCP_PRIO_CFG_HDR_SIZE);\n\n\tif (!qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 0))\n\t\tgoto fail;\n\n\t \n\tfcp_prio_addr += (FCP_PRIO_CFG_HDR_SIZE >> 2);\n\tlen = ha->fcp_prio_cfg->num_entries * sizeof(struct qla_fcp_prio_entry);\n\tmax_len = FCP_PRIO_CFG_SIZE - FCP_PRIO_CFG_HDR_SIZE;\n\n\tha->isp_ops->read_optrom(vha, &ha->fcp_prio_cfg->entry[0],\n\t\t\tfcp_prio_addr << 2, (len < max_len ? len : max_len));\n\n\t \n\tif (!qla24xx_fcp_prio_cfg_valid(vha, ha->fcp_prio_cfg, 1))\n\t\tgoto fail;\n\n\tha->flags.fcp_prio_enabled = 1;\n\treturn QLA_SUCCESS;\nfail:\n\tvfree(ha->fcp_prio_cfg);\n\tha->fcp_prio_cfg = NULL;\n\treturn QLA_FUNCTION_FAILED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}