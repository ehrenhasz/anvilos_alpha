{
  "module_name": "qla_target.c",
  "hash_id": "a33014ad8464360cc1e8f5541bd110cf9244f2d886dbc3c7a12a153298eb1297",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_target.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/workqueue.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"qla_def.h\"\n#include \"qla_target.h\"\n\nstatic int ql2xtgt_tape_enable;\nmodule_param(ql2xtgt_tape_enable, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xtgt_tape_enable,\n\t\t\"Enables Sequence level error recovery (aka FC Tape). Default is 0 - no SLER. 1 - Enable SLER.\");\n\nstatic char *qlini_mode = QLA2XXX_INI_MODE_STR_ENABLED;\nmodule_param(qlini_mode, charp, S_IRUGO);\nMODULE_PARM_DESC(qlini_mode,\n\t\"Determines when initiator mode will be enabled. Possible values: \"\n\t\"\\\"exclusive\\\" - initiator mode will be enabled on load, \"\n\t\"disabled on enabling target mode and then on disabling target mode \"\n\t\"enabled back; \"\n\t\"\\\"disabled\\\" - initiator mode will never be enabled; \"\n\t\"\\\"dual\\\" - Initiator Modes will be enabled. Target Mode can be activated \"\n\t\"when ready \"\n\t\"\\\"enabled\\\" (default) - initiator mode will always stay enabled.\");\n\nint ql2xuctrlirq = 1;\nmodule_param(ql2xuctrlirq, int, 0644);\nMODULE_PARM_DESC(ql2xuctrlirq,\n    \"User to control IRQ placement via smp_affinity.\"\n    \"Valid with qlini_mode=disabled.\"\n    \"1(default): enable\");\n\nint ql2x_ini_mode = QLA2XXX_INI_MODE_EXCLUSIVE;\n\nstatic int qla_sam_status = SAM_STAT_BUSY;\nstatic int tc_sam_status = SAM_STAT_TASK_SET_FULL;  \n\n \nenum fcp_resp_rsp_codes {\n\tFCP_TMF_CMPL = 0,\n\tFCP_DATA_LEN_INVALID = 1,\n\tFCP_CMND_FIELDS_INVALID = 2,\n\tFCP_DATA_PARAM_MISMATCH = 3,\n\tFCP_TMF_REJECTED = 4,\n\tFCP_TMF_FAILED = 5,\n\tFCP_TMF_INVALID_LUN = 9,\n};\n\n \n#define FCP_PTA_SIMPLE      0    \n#define FCP_PTA_HEADQ       1    \n#define FCP_PTA_ORDERED     2    \n#define FCP_PTA_ACA         4    \n#define FCP_PTA_MASK        7    \n#define FCP_PRI_SHIFT       3    \n#define FCP_PRI_RESVD_MASK  0x80         \n\n \n \nstatic void qlt_24xx_atio_pkt(struct scsi_qla_host *ha,\n\tstruct atio_from_isp *pkt, uint8_t);\nstatic void qlt_response_pkt(struct scsi_qla_host *ha, struct rsp_que *rsp,\n\tresponse_t *pkt);\nstatic int qlt_issue_task_mgmt(struct fc_port *sess, u64 lun,\n\tint fn, void *iocb, int flags);\nstatic void qlt_send_term_exchange(struct qla_qpair *, struct qla_tgt_cmd\n\t*cmd, struct atio_from_isp *atio, int ha_locked, int ul_abort);\nstatic void qlt_alloc_qfull_cmd(struct scsi_qla_host *vha,\n\tstruct atio_from_isp *atio, uint16_t status, int qfull);\nstatic void qlt_disable_vha(struct scsi_qla_host *vha);\nstatic void qlt_clear_tgt_db(struct qla_tgt *tgt);\nstatic void qlt_send_notify_ack(struct qla_qpair *qpair,\n\tstruct imm_ntfy_from_isp *ntfy,\n\tuint32_t add_flags, uint16_t resp_code, int resp_code_valid,\n\tuint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan);\nstatic void qlt_send_term_imm_notif(struct scsi_qla_host *vha,\n\tstruct imm_ntfy_from_isp *imm, int ha_locked);\nstatic struct fc_port *qlt_create_sess(struct scsi_qla_host *vha,\n\tfc_port_t *fcport, bool local);\nvoid qlt_unreg_sess(struct fc_port *sess);\nstatic void qlt_24xx_handle_abts(struct scsi_qla_host *,\n\tstruct abts_recv_from_24xx *);\nstatic void qlt_send_busy(struct qla_qpair *, struct atio_from_isp *,\n    uint16_t);\nstatic int qlt_check_reserve_free_req(struct qla_qpair *qpair, uint32_t);\nstatic inline uint32_t qlt_make_handle(struct qla_qpair *);\n\n \nstatic struct kmem_cache *qla_tgt_mgmt_cmd_cachep;\nstruct kmem_cache *qla_tgt_plogi_cachep;\nstatic mempool_t *qla_tgt_mgmt_cmd_mempool;\nstatic struct workqueue_struct *qla_tgt_wq;\nstatic DEFINE_MUTEX(qla_tgt_mutex);\nstatic LIST_HEAD(qla_tgt_glist);\n\nstatic const char *prot_op_str(u32 prot_op)\n{\n\tswitch (prot_op) {\n\tcase TARGET_PROT_NORMAL:\treturn \"NORMAL\";\n\tcase TARGET_PROT_DIN_INSERT:\treturn \"DIN_INSERT\";\n\tcase TARGET_PROT_DOUT_INSERT:\treturn \"DOUT_INSERT\";\n\tcase TARGET_PROT_DIN_STRIP:\treturn \"DIN_STRIP\";\n\tcase TARGET_PROT_DOUT_STRIP:\treturn \"DOUT_STRIP\";\n\tcase TARGET_PROT_DIN_PASS:\treturn \"DIN_PASS\";\n\tcase TARGET_PROT_DOUT_PASS:\treturn \"DOUT_PASS\";\n\tdefault:\t\t\treturn \"UNKNOWN\";\n\t}\n}\n\n \nvoid qlt_do_generation_tick(struct scsi_qla_host *vha, int *dest)\n{\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(vha->hw->pdev);\n\t*dest = atomic_inc_return(&base_vha->generation_tick);\n\t \n\twmb();\n}\n\n \nstatic inline int qlt_issue_marker(struct scsi_qla_host *vha, int vha_locked)\n{\n\t \n\tif (unlikely(vha->marker_needed != 0)) {\n\t\tint rc = qla2x00_issue_marker(vha, vha_locked);\n\n\t\tif (rc != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe03d,\n\t\t\t    \"qla_target(%d): issue_marker() failed\\n\",\n\t\t\t    vha->vp_idx);\n\t\t}\n\t\treturn rc;\n\t}\n\treturn QLA_SUCCESS;\n}\n\nstruct scsi_qla_host *qla_find_host_by_d_id(struct scsi_qla_host *vha,\n\t\t\t\t\t    be_id_t d_id)\n{\n\tstruct scsi_qla_host *host;\n\tuint32_t key;\n\n\tif (vha->d_id.b.area == d_id.area &&\n\t    vha->d_id.b.domain == d_id.domain &&\n\t    vha->d_id.b.al_pa == d_id.al_pa)\n\t\treturn vha;\n\n\tkey = be_to_port_id(d_id).b24;\n\n\thost = btree_lookup32(&vha->hw->host_map, key);\n\tif (!host)\n\t\tql_dbg(ql_dbg_tgt_mgt + ql_dbg_verbose, vha, 0xf005,\n\t\t    \"Unable to find host %06x\\n\", key);\n\n\treturn host;\n}\n\nstatic inline void qlt_incr_num_pend_cmds(struct scsi_qla_host *vha)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);\n\n\tvha->hw->tgt.num_pend_cmds++;\n\tif (vha->hw->tgt.num_pend_cmds > vha->qla_stats.stat_max_pend_cmds)\n\t\tvha->qla_stats.stat_max_pend_cmds =\n\t\t\tvha->hw->tgt.num_pend_cmds;\n\tspin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);\n}\nstatic inline void qlt_decr_num_pend_cmds(struct scsi_qla_host *vha)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);\n\tvha->hw->tgt.num_pend_cmds--;\n\tspin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);\n}\n\n\nstatic void qlt_queue_unknown_atio(scsi_qla_host_t *vha,\n\tstruct atio_from_isp *atio, uint8_t ha_locked)\n{\n\tstruct qla_tgt_sess_op *u;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tunsigned long flags;\n\n\tif (tgt->tgt_stop) {\n\t\tql_dbg(ql_dbg_async, vha, 0x502c,\n\t\t    \"qla_target(%d): dropping unknown ATIO_TYPE7, because tgt is being stopped\",\n\t\t    vha->vp_idx);\n\t\tgoto out_term;\n\t}\n\n\tu = kzalloc(sizeof(*u), GFP_ATOMIC);\n\tif (u == NULL)\n\t\tgoto out_term;\n\n\tu->vha = vha;\n\tmemcpy(&u->atio, atio, sizeof(*atio));\n\tINIT_LIST_HEAD(&u->cmd_list);\n\n\tspin_lock_irqsave(&vha->cmd_list_lock, flags);\n\tlist_add_tail(&u->cmd_list, &vha->unknown_atio_list);\n\tspin_unlock_irqrestore(&vha->cmd_list_lock, flags);\n\n\tschedule_delayed_work(&vha->unknown_atio_work, 1);\n\nout:\n\treturn;\n\nout_term:\n\tqlt_send_term_exchange(vha->hw->base_qpair, NULL, atio, ha_locked, 0);\n\tgoto out;\n}\n\nstatic void qlt_try_to_dequeue_unknown_atios(struct scsi_qla_host *vha,\n\tuint8_t ha_locked)\n{\n\tstruct qla_tgt_sess_op *u, *t;\n\tscsi_qla_host_t *host;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tunsigned long flags;\n\tuint8_t queued = 0;\n\n\tlist_for_each_entry_safe(u, t, &vha->unknown_atio_list, cmd_list) {\n\t\tif (u->aborted) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0x502e,\n\t\t\t    \"Freeing unknown %s %p, because of Abort\\n\",\n\t\t\t    \"ATIO_TYPE7\", u);\n\t\t\tqlt_send_term_exchange(vha->hw->base_qpair, NULL,\n\t\t\t    &u->atio, ha_locked, 0);\n\t\t\tgoto abort;\n\t\t}\n\n\t\thost = qla_find_host_by_d_id(vha, u->atio.u.isp24.fcp_hdr.d_id);\n\t\tif (host != NULL) {\n\t\t\tql_dbg(ql_dbg_async + ql_dbg_verbose, vha, 0x502f,\n\t\t\t    \"Requeuing unknown ATIO_TYPE7 %p\\n\", u);\n\t\t\tqlt_24xx_atio_pkt(host, &u->atio, ha_locked);\n\t\t} else if (tgt->tgt_stop) {\n\t\t\tql_dbg(ql_dbg_async + ql_dbg_verbose, vha, 0x503a,\n\t\t\t    \"Freeing unknown %s %p, because tgt is being stopped\\n\",\n\t\t\t    \"ATIO_TYPE7\", u);\n\t\t\tqlt_send_term_exchange(vha->hw->base_qpair, NULL,\n\t\t\t    &u->atio, ha_locked, 0);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_async + ql_dbg_verbose, vha, 0x503d,\n\t\t\t    \"Reschedule u %p, vha %p, host %p\\n\", u, vha, host);\n\t\t\tif (!queued) {\n\t\t\t\tqueued = 1;\n\t\t\t\tschedule_delayed_work(&vha->unknown_atio_work,\n\t\t\t\t    1);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\nabort:\n\t\tspin_lock_irqsave(&vha->cmd_list_lock, flags);\n\t\tlist_del(&u->cmd_list);\n\t\tspin_unlock_irqrestore(&vha->cmd_list_lock, flags);\n\t\tkfree(u);\n\t}\n}\n\nvoid qlt_unknown_atio_work_fn(struct work_struct *work)\n{\n\tstruct scsi_qla_host *vha = container_of(to_delayed_work(work),\n\t    struct scsi_qla_host, unknown_atio_work);\n\n\tqlt_try_to_dequeue_unknown_atios(vha, 0);\n}\n\nstatic bool qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,\n\tstruct atio_from_isp *atio, uint8_t ha_locked)\n{\n\tql_dbg(ql_dbg_tgt, vha, 0xe072,\n\t\t\"%s: qla_target(%d): type %x ox_id %04x\\n\",\n\t\t__func__, vha->vp_idx, atio->u.raw.entry_type,\n\t\tbe16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));\n\n\tswitch (atio->u.raw.entry_type) {\n\tcase ATIO_TYPE7:\n\t{\n\t\tstruct scsi_qla_host *host = qla_find_host_by_d_id(vha,\n\t\t    atio->u.isp24.fcp_hdr.d_id);\n\t\tif (unlikely(NULL == host)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe03e,\n\t\t\t    \"qla_target(%d): Received ATIO_TYPE7 \"\n\t\t\t    \"with unknown d_id %x:%x:%x\\n\", vha->vp_idx,\n\t\t\t    atio->u.isp24.fcp_hdr.d_id.domain,\n\t\t\t    atio->u.isp24.fcp_hdr.d_id.area,\n\t\t\t    atio->u.isp24.fcp_hdr.d_id.al_pa);\n\n\n\t\t\tqlt_queue_unknown_atio(vha, atio, ha_locked);\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(!list_empty(&vha->unknown_atio_list)))\n\t\t\tqlt_try_to_dequeue_unknown_atios(vha, ha_locked);\n\n\t\tqlt_24xx_atio_pkt(host, atio, ha_locked);\n\t\tbreak;\n\t}\n\n\tcase IMMED_NOTIFY_TYPE:\n\t{\n\t\tstruct scsi_qla_host *host = vha;\n\t\tstruct imm_ntfy_from_isp *entry =\n\t\t    (struct imm_ntfy_from_isp *)atio;\n\n\t\tqlt_issue_marker(vha, ha_locked);\n\n\t\tif ((entry->u.isp24.vp_index != 0xFF) &&\n\t\t    (entry->u.isp24.nport_handle != cpu_to_le16(0xFFFF))) {\n\t\t\thost = qla_find_host_by_vp_idx(vha,\n\t\t\t    entry->u.isp24.vp_index);\n\t\t\tif (unlikely(!host)) {\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe03f,\n\t\t\t\t    \"qla_target(%d): Received \"\n\t\t\t\t    \"ATIO (IMMED_NOTIFY_TYPE) \"\n\t\t\t\t    \"with unknown vp_index %d\\n\",\n\t\t\t\t    vha->vp_idx, entry->u.isp24.vp_index);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqlt_24xx_atio_pkt(host, atio, ha_locked);\n\t\tbreak;\n\t}\n\n\tcase VP_RPT_ID_IOCB_TYPE:\n\t\tqla24xx_report_id_acquisition(vha,\n\t\t\t(struct vp_rpt_id_entry_24xx *)atio);\n\t\tbreak;\n\n\tcase ABTS_RECV_24XX:\n\t{\n\t\tstruct abts_recv_from_24xx *entry =\n\t\t\t(struct abts_recv_from_24xx *)atio;\n\t\tstruct scsi_qla_host *host = qla_find_host_by_vp_idx(vha,\n\t\t\tentry->vp_index);\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!host)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe00a,\n\t\t\t    \"qla_target(%d): Response pkt (ABTS_RECV_24XX) \"\n\t\t\t    \"received, with unknown vp_index %d\\n\",\n\t\t\t    vha->vp_idx, entry->vp_index);\n\t\t\tbreak;\n\t\t}\n\t\tif (!ha_locked)\n\t\t\tspin_lock_irqsave(&host->hw->hardware_lock, flags);\n\t\tqlt_24xx_handle_abts(host, (struct abts_recv_from_24xx *)atio);\n\t\tif (!ha_locked)\n\t\t\tspin_unlock_irqrestore(&host->hw->hardware_lock, flags);\n\t\tbreak;\n\t}\n\n\t \n\n\tdefault:\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe040,\n\t\t    \"qla_target(%d): Received unknown ATIO atio \"\n\t\t    \"type %x\\n\", vha->vp_idx, atio->u.raw.entry_type);\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nvoid qlt_response_pkt_all_vps(struct scsi_qla_host *vha,\n\tstruct rsp_que *rsp, response_t *pkt)\n{\n\tswitch (pkt->entry_type) {\n\tcase CTIO_CRC2:\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe073,\n\t\t\t\"qla_target(%d):%s: CRC2 Response pkt\\n\",\n\t\t\tvha->vp_idx, __func__);\n\t\tfallthrough;\n\tcase CTIO_TYPE7:\n\t{\n\t\tstruct ctio7_from_24xx *entry = (struct ctio7_from_24xx *)pkt;\n\t\tstruct scsi_qla_host *host = qla_find_host_by_vp_idx(vha,\n\t\t    entry->vp_index);\n\t\tif (unlikely(!host)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe041,\n\t\t\t    \"qla_target(%d): Response pkt (CTIO_TYPE7) \"\n\t\t\t    \"received, with unknown vp_index %d\\n\",\n\t\t\t    vha->vp_idx, entry->vp_index);\n\t\t\tbreak;\n\t\t}\n\t\tqlt_response_pkt(host, rsp, pkt);\n\t\tbreak;\n\t}\n\n\tcase IMMED_NOTIFY_TYPE:\n\t{\n\t\tstruct scsi_qla_host *host;\n\t\tstruct imm_ntfy_from_isp *entry =\n\t\t    (struct imm_ntfy_from_isp *)pkt;\n\n\t\thost = qla_find_host_by_vp_idx(vha, entry->u.isp24.vp_index);\n\t\tif (unlikely(!host)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe042,\n\t\t\t    \"qla_target(%d): Response pkt (IMMED_NOTIFY_TYPE) \"\n\t\t\t    \"received, with unknown vp_index %d\\n\",\n\t\t\t    vha->vp_idx, entry->u.isp24.vp_index);\n\t\t\tbreak;\n\t\t}\n\t\tqlt_response_pkt(host, rsp, pkt);\n\t\tbreak;\n\t}\n\n\tcase NOTIFY_ACK_TYPE:\n\t{\n\t\tstruct scsi_qla_host *host = vha;\n\t\tstruct nack_to_isp *entry = (struct nack_to_isp *)pkt;\n\n\t\tif (0xFF != entry->u.isp24.vp_index) {\n\t\t\thost = qla_find_host_by_vp_idx(vha,\n\t\t\t    entry->u.isp24.vp_index);\n\t\t\tif (unlikely(!host)) {\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe043,\n\t\t\t\t    \"qla_target(%d): Response \"\n\t\t\t\t    \"pkt (NOTIFY_ACK_TYPE) \"\n\t\t\t\t    \"received, with unknown \"\n\t\t\t\t    \"vp_index %d\\n\", vha->vp_idx,\n\t\t\t\t    entry->u.isp24.vp_index);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqlt_response_pkt(host, rsp, pkt);\n\t\tbreak;\n\t}\n\n\tcase ABTS_RECV_24XX:\n\t{\n\t\tstruct abts_recv_from_24xx *entry =\n\t\t    (struct abts_recv_from_24xx *)pkt;\n\t\tstruct scsi_qla_host *host = qla_find_host_by_vp_idx(vha,\n\t\t    entry->vp_index);\n\t\tif (unlikely(!host)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe044,\n\t\t\t    \"qla_target(%d): Response pkt \"\n\t\t\t    \"(ABTS_RECV_24XX) received, with unknown \"\n\t\t\t    \"vp_index %d\\n\", vha->vp_idx, entry->vp_index);\n\t\t\tbreak;\n\t\t}\n\t\tqlt_response_pkt(host, rsp, pkt);\n\t\tbreak;\n\t}\n\n\tcase ABTS_RESP_24XX:\n\t{\n\t\tstruct abts_resp_to_24xx *entry =\n\t\t    (struct abts_resp_to_24xx *)pkt;\n\t\tstruct scsi_qla_host *host = qla_find_host_by_vp_idx(vha,\n\t\t    entry->vp_index);\n\t\tif (unlikely(!host)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe045,\n\t\t\t    \"qla_target(%d): Response pkt \"\n\t\t\t    \"(ABTS_RECV_24XX) received, with unknown \"\n\t\t\t    \"vp_index %d\\n\", vha->vp_idx, entry->vp_index);\n\t\t\tbreak;\n\t\t}\n\t\tqlt_response_pkt(host, rsp, pkt);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tqlt_response_pkt(vha, rsp, pkt);\n\t\tbreak;\n\t}\n\n}\n\n \nstatic int qla24xx_post_nack_work(struct scsi_qla_host *vha, fc_port_t *fcport,\n\tstruct imm_ntfy_from_isp *ntfy, int type)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_NACK);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.nack.fcport = fcport;\n\te->u.nack.type = type;\n\tmemcpy(e->u.nack.iocb, ntfy, sizeof(struct imm_ntfy_from_isp));\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void qla2x00_async_nack_sp_done(srb_t *sp, int res)\n{\n\tstruct scsi_qla_host *vha = sp->vha;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20f2,\n\t    \"Async done-%s res %x %8phC  type %d\\n\",\n\t    sp->name, res, sp->fcport->port_name, sp->type);\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tsp->fcport->flags &= ~FCF_ASYNC_SENT;\n\tsp->fcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\n\tswitch (sp->type) {\n\tcase SRB_NACK_PLOGI:\n\t\tsp->fcport->login_gen++;\n\t\tsp->fcport->fw_login_state = DSC_LS_PLOGI_COMP;\n\t\tsp->fcport->logout_on_delete = 1;\n\t\tsp->fcport->plogi_nack_done_deadline = jiffies + HZ;\n\t\tsp->fcport->send_els_logo = 0;\n\n\t\tif (sp->fcport->flags & FCF_FCSP_DEVICE) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x20ef,\n\t\t\t    \"%s %8phC edif: PLOGI- AUTH WAIT\\n\", __func__,\n\t\t\t    sp->fcport->port_name);\n\t\t\tqla2x00_set_fcport_disc_state(sp->fcport,\n\t\t\t    DSC_LOGIN_AUTH_PEND);\n\t\t\tqla2x00_post_aen_work(vha, FCH_EVT_PORT_ONLINE,\n\t\t\t    sp->fcport->d_id.b24);\n\t\t\tqla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_NEEDED, sp->fcport->d_id.b24,\n\t\t\t    0, sp->fcport);\n\t\t}\n\t\tbreak;\n\n\tcase SRB_NACK_PRLI:\n\t\tsp->fcport->fw_login_state = DSC_LS_PRLI_COMP;\n\t\tsp->fcport->deleted = 0;\n\t\tsp->fcport->send_els_logo = 0;\n\n\t\tif (!sp->fcport->login_succ &&\n\t\t    !IS_SW_RESV_ADDR(sp->fcport->d_id)) {\n\t\t\tsp->fcport->login_succ = 1;\n\n\t\t\tvha->fcport_count++;\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\t\tqla24xx_sched_upd_fcport(sp->fcport);\n\t\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t} else {\n\t\t\tsp->fcport->login_retry = 0;\n\t\t\tqla2x00_set_fcport_disc_state(sp->fcport,\n\t\t\t    DSC_LOGIN_COMPLETE);\n\t\t\tsp->fcport->deleted = 0;\n\t\t\tsp->fcport->logout_on_delete = 1;\n\t\t}\n\t\tbreak;\n\n\tcase SRB_NACK_LOGO:\n\t\tsp->fcport->login_gen++;\n\t\tsp->fcport->fw_login_state = DSC_LS_PORT_UNAVAIL;\n\t\tqlt_logo_completion_handler(sp->fcport, MBS_COMMAND_COMPLETE);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\nint qla24xx_async_notify_ack(scsi_qla_host_t *vha, fc_port_t *fcport,\n\tstruct imm_ntfy_from_isp *ntfy, int type)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tsrb_t *sp;\n\tchar *c = NULL;\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tswitch (type) {\n\tcase SRB_NACK_PLOGI:\n\t\tfcport->fw_login_state = DSC_LS_PLOGI_PEND;\n\t\tc = \"PLOGI\";\n\t\tif (vha->hw->flags.edif_enabled &&\n\t\t    (le16_to_cpu(ntfy->u.isp24.flags) & NOTIFY24XX_FLAGS_FCSP))\n\t\t\tfcport->flags |= FCF_FCSP_DEVICE;\n\t\tbreak;\n\tcase SRB_NACK_PRLI:\n\t\tfcport->fw_login_state = DSC_LS_PRLI_PEND;\n\t\tfcport->deleted = 0;\n\t\tc = \"PRLI\";\n\t\tbreak;\n\tcase SRB_NACK_LOGO:\n\t\tfcport->fw_login_state = DSC_LS_LOGO_PEND;\n\t\tc = \"LOGO\";\n\t\tbreak;\n\t}\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);\n\tif (!sp)\n\t\tgoto done;\n\n\tsp->type = type;\n\tsp->name = \"nack\";\n\tqla2x00_init_async_sp(sp, qla2x00_get_async_timeout(vha) + 2,\n\t\t\t      qla2x00_async_nack_sp_done);\n\n\tsp->u.iocb_cmd.u.nack.ntfy = ntfy;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20f4,\n\t    \"Async-%s %8phC hndl %x %s\\n\",\n\t    sp->name, fcport->port_name, sp->handle, c);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free_sp;\n\n\treturn rval;\n\ndone_free_sp:\n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\ndone:\n\tfcport->flags &= ~FCF_ASYNC_SENT;\n\treturn rval;\n}\n\nvoid qla24xx_do_nack_work(struct scsi_qla_host *vha, struct qla_work_evt *e)\n{\n\tfc_port_t *t;\n\n\tswitch (e->u.nack.type) {\n\tcase SRB_NACK_PRLI:\n\t\tt = e->u.nack.fcport;\n\t\tflush_work(&t->del_work);\n\t\tflush_work(&t->free_work);\n\t\tmutex_lock(&vha->vha_tgt.tgt_mutex);\n\t\tt = qlt_create_sess(vha, e->u.nack.fcport, 0);\n\t\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\t\tif (t) {\n\t\t\tql_log(ql_log_info, vha, 0xd034,\n\t\t\t    \"%s create sess success %p\", __func__, t);\n\t\t\t \n\t\t\tvha->hw->tgt.tgt_ops->put_sess(e->u.nack.fcport);\n\t\t}\n\t\tbreak;\n\t}\n\tqla24xx_async_notify_ack(vha, e->u.nack.fcport,\n\t    (struct imm_ntfy_from_isp *)e->u.nack.iocb, e->u.nack.type);\n}\n\nvoid qla24xx_delete_sess_fn(struct work_struct *work)\n{\n\tfc_port_t *fcport = container_of(work, struct fc_port, del_work);\n\tstruct qla_hw_data *ha = NULL;\n\n\tif (!fcport || !fcport->vha || !fcport->vha->hw)\n\t\treturn;\n\n\tha = fcport->vha->hw;\n\n\tif (fcport->se_sess) {\n\t\tha->tgt.tgt_ops->shutdown_sess(fcport);\n\t\tha->tgt.tgt_ops->put_sess(fcport);\n\t} else {\n\t\tqlt_unreg_sess(fcport);\n\t}\n}\n\n \nvoid qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tstruct fc_port *sess = fcport;\n\tunsigned long flags;\n\n\tif (!vha->hw->tgt.tgt_ops)\n\t\treturn;\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tif (tgt->tgt_stop) {\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t\treturn;\n\t}\n\n\tif (fcport->disc_state == DSC_DELETE_PEND) {\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t\treturn;\n\t}\n\n\tif (!sess->se_sess) {\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\t\tmutex_lock(&vha->vha_tgt.tgt_mutex);\n\t\tsess = qlt_create_sess(vha, fcport, false);\n\t\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\n\t\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\t} else {\n\t\tif (fcport->fw_login_state == DSC_LS_PRLI_COMP) {\n\t\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!kref_get_unless_zero(&sess->sess_kref)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2107,\n\t\t\t    \"%s: kref_get fail sess %8phC \\n\",\n\t\t\t    __func__, sess->port_name);\n\t\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf04c,\n\t\t    \"qla_target(%u): %ssession for port %8phC \"\n\t\t    \"(loop ID %d) reappeared\\n\", vha->vp_idx,\n\t\t    sess->local ? \"local \" : \"\", sess->port_name, sess->loop_id);\n\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf007,\n\t\t    \"Reappeared sess %p\\n\", sess);\n\n\t\tha->tgt.tgt_ops->update_sess(sess, fcport->d_id,\n\t\t    fcport->loop_id,\n\t\t    (fcport->flags & FCF_CONF_COMP_SUPPORTED));\n\t}\n\n\tif (sess && sess->local) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf04d,\n\t\t    \"qla_target(%u): local session for \"\n\t\t    \"port %8phC (loop ID %d) became global\\n\", vha->vp_idx,\n\t\t    fcport->port_name, sess->loop_id);\n\t\tsess->local = 0;\n\t}\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\tha->tgt.tgt_ops->put_sess(sess);\n}\n\n \nstatic struct qlt_plogi_ack_t *\nqlt_plogi_ack_find_add(struct scsi_qla_host *vha, port_id_t *id,\n\t\t       struct imm_ntfy_from_isp *iocb)\n{\n\tstruct qlt_plogi_ack_t *pla;\n\n\tlockdep_assert_held(&vha->hw->hardware_lock);\n\n\tlist_for_each_entry(pla, &vha->plogi_ack_list, list) {\n\t\tif (pla->id.b24 == id->b24) {\n\t\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0x210d,\n\t\t\t    \"%s %d %8phC Term INOT due to new INOT\",\n\t\t\t    __func__, __LINE__,\n\t\t\t    pla->iocb.u.isp24.port_name);\n\t\t\tqlt_send_term_imm_notif(vha, &pla->iocb, 1);\n\t\t\tmemcpy(&pla->iocb, iocb, sizeof(pla->iocb));\n\t\t\treturn pla;\n\t\t}\n\t}\n\n\tpla = kmem_cache_zalloc(qla_tgt_plogi_cachep, GFP_ATOMIC);\n\tif (!pla) {\n\t\tql_dbg(ql_dbg_async, vha, 0x5088,\n\t\t       \"qla_target(%d): Allocation of plogi_ack failed\\n\",\n\t\t       vha->vp_idx);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(&pla->iocb, iocb, sizeof(pla->iocb));\n\tpla->id = *id;\n\tlist_add_tail(&pla->list, &vha->plogi_ack_list);\n\n\treturn pla;\n}\n\nvoid qlt_plogi_ack_unref(struct scsi_qla_host *vha,\n    struct qlt_plogi_ack_t *pla)\n{\n\tstruct imm_ntfy_from_isp *iocb = &pla->iocb;\n\tport_id_t port_id;\n\tuint16_t loop_id;\n\tfc_port_t *fcport = pla->fcport;\n\n\tBUG_ON(!pla->ref_count);\n\tpla->ref_count--;\n\n\tif (pla->ref_count)\n\t\treturn;\n\n\tql_dbg(ql_dbg_disc, vha, 0x5089,\n\t    \"Sending PLOGI ACK to wwn %8phC s_id %02x:%02x:%02x loop_id %#04x\"\n\t    \" exch %#x ox_id %#x\\n\", iocb->u.isp24.port_name,\n\t    iocb->u.isp24.port_id[2], iocb->u.isp24.port_id[1],\n\t    iocb->u.isp24.port_id[0],\n\t    le16_to_cpu(iocb->u.isp24.nport_handle),\n\t    iocb->u.isp24.exchange_address, iocb->ox_id);\n\n\tport_id.b.domain = iocb->u.isp24.port_id[2];\n\tport_id.b.area   = iocb->u.isp24.port_id[1];\n\tport_id.b.al_pa  = iocb->u.isp24.port_id[0];\n\tport_id.b.rsvd_1 = 0;\n\n\tloop_id = le16_to_cpu(iocb->u.isp24.nport_handle);\n\n\tfcport->loop_id = loop_id;\n\tfcport->d_id = port_id;\n\tif (iocb->u.isp24.status_subcode == ELS_PLOGI)\n\t\tqla24xx_post_nack_work(vha, fcport, iocb, SRB_NACK_PLOGI);\n\telse\n\t\tqla24xx_post_nack_work(vha, fcport, iocb, SRB_NACK_PRLI);\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->plogi_link[QLT_PLOGI_LINK_SAME_WWN] == pla)\n\t\t\tfcport->plogi_link[QLT_PLOGI_LINK_SAME_WWN] = NULL;\n\t\tif (fcport->plogi_link[QLT_PLOGI_LINK_CONFLICT] == pla)\n\t\t\tfcport->plogi_link[QLT_PLOGI_LINK_CONFLICT] = NULL;\n\t}\n\n\tlist_del(&pla->list);\n\tkmem_cache_free(qla_tgt_plogi_cachep, pla);\n}\n\nvoid\nqlt_plogi_ack_link(struct scsi_qla_host *vha, struct qlt_plogi_ack_t *pla,\n    struct fc_port *sess, enum qlt_plogi_link_t link)\n{\n\tstruct imm_ntfy_from_isp *iocb = &pla->iocb;\n\t \n\tpla->ref_count++;\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf097,\n\t\t\"Linking sess %p [%d] wwn %8phC with PLOGI ACK to wwn %8phC\"\n\t\t\" s_id %02x:%02x:%02x, ref=%d pla %p link %d\\n\",\n\t\tsess, link, sess->port_name,\n\t\tiocb->u.isp24.port_name, iocb->u.isp24.port_id[2],\n\t\tiocb->u.isp24.port_id[1], iocb->u.isp24.port_id[0],\n\t\tpla->ref_count, pla, link);\n\n\tif (link == QLT_PLOGI_LINK_CONFLICT) {\n\t\tswitch (sess->disc_state) {\n\t\tcase DSC_DELETED:\n\t\tcase DSC_DELETE_PEND:\n\t\t\tpla->ref_count--;\n\t\t\treturn;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sess->plogi_link[link])\n\t\tqlt_plogi_ack_unref(vha, sess->plogi_link[link]);\n\n\tif (link == QLT_PLOGI_LINK_SAME_WWN)\n\t\tpla->fcport = sess;\n\n\tsess->plogi_link[link] = pla;\n}\n\ntypedef struct {\n\t \n\tport_id_t id;\n\t \n\tint cmd_count;\n\n\t \n\tstruct list_head list;\n} qlt_port_logo_t;\n\nstatic void\nqlt_send_first_logo(struct scsi_qla_host *vha, qlt_port_logo_t *logo)\n{\n\tqlt_port_logo_t *tmp;\n\tint res;\n\n\tif (test_bit(PFLG_DRIVER_REMOVING, &vha->pci_flags)) {\n\t\tres = 0;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&vha->vha_tgt.tgt_mutex);\n\n\tlist_for_each_entry(tmp, &vha->logo_list, list) {\n\t\tif (tmp->id.b24 == logo->id.b24) {\n\t\t\ttmp->cmd_count += logo->cmd_count;\n\t\t\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_add_tail(&logo->list, &vha->logo_list);\n\n\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\n\tres = qla24xx_els_dcmd_iocb(vha, ELS_DCMD_LOGO, logo->id);\n\n\tmutex_lock(&vha->vha_tgt.tgt_mutex);\n\tlist_del(&logo->list);\n\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\nout:\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf098,\n\t    \"Finished LOGO to %02x:%02x:%02x, dropped %d cmds, res = %#x\\n\",\n\t    logo->id.b.domain, logo->id.b.area, logo->id.b.al_pa,\n\t    logo->cmd_count, res);\n}\n\nvoid qlt_free_session_done(struct work_struct *work)\n{\n\tstruct fc_port *sess = container_of(work, struct fc_port,\n\t    free_work);\n\tstruct qla_tgt *tgt = sess->tgt;\n\tstruct scsi_qla_host *vha = sess->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\tbool logout_started = false;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tstruct qlt_plogi_ack_t *own =\n\t\tsess->plogi_link[QLT_PLOGI_LINK_SAME_WWN];\n\n\tql_dbg(ql_dbg_disc, vha, 0xf084,\n\t\t\"%s: se_sess %p / sess %p from port %8phC loop_id %#04x\"\n\t\t\" s_id %02x:%02x:%02x logout %d keep %d els_logo %d\\n\",\n\t\t__func__, sess->se_sess, sess, sess->port_name, sess->loop_id,\n\t\tsess->d_id.b.domain, sess->d_id.b.area, sess->d_id.b.al_pa,\n\t\tsess->logout_on_delete, sess->keep_nport_handle,\n\t\tsess->send_els_logo);\n\n\tif (!IS_SW_RESV_ADDR(sess->d_id)) {\n\t\tqla2x00_mark_device_lost(vha, sess, 0);\n\n\t\tif (sess->send_els_logo) {\n\t\t\tqlt_port_logo_t logo;\n\n\t\t\tlogo.id = sess->d_id;\n\t\t\tlogo.cmd_count = 0;\n\t\t\tINIT_LIST_HEAD(&logo.list);\n\t\t\tif (!own)\n\t\t\t\tqlt_send_first_logo(vha, &logo);\n\t\t\tsess->send_els_logo = 0;\n\t\t}\n\n\t\tif (sess->logout_on_delete && sess->loop_id != FC_NO_LOOP_ID) {\n\t\t\tint rc;\n\n\t\t\tif (!own ||\n\t\t\t     (own->iocb.u.isp24.status_subcode == ELS_PLOGI)) {\n\t\t\t\tsess->logout_completed = 0;\n\t\t\t\trc = qla2x00_post_async_logout_work(vha, sess,\n\t\t\t\t    NULL);\n\t\t\t\tif (rc != QLA_SUCCESS)\n\t\t\t\t\tql_log(ql_log_warn, vha, 0xf085,\n\t\t\t\t\t    \"Schedule logo failed sess %p rc %d\\n\",\n\t\t\t\t\t    sess, rc);\n\t\t\t\telse\n\t\t\t\t\tlogout_started = true;\n\t\t\t} else if (own && (own->iocb.u.isp24.status_subcode ==\n\t\t\t\tELS_PRLI) && ha->flags.rida_fmt2) {\n\t\t\t\trc = qla2x00_post_async_prlo_work(vha, sess,\n\t\t\t\t    NULL);\n\t\t\t\tif (rc != QLA_SUCCESS)\n\t\t\t\t\tql_log(ql_log_warn, vha, 0xf085,\n\t\t\t\t\t    \"Schedule PRLO failed sess %p rc %d\\n\",\n\t\t\t\t\t    sess, rc);\n\t\t\t\telse\n\t\t\t\t\tlogout_started = true;\n\t\t\t}\n\t\t}  \n\n\t\tif (sess->nvme_flag & NVME_FLAG_REGISTERED &&\n\t\t    !(sess->nvme_flag & NVME_FLAG_DELETING)) {\n\t\t\tsess->nvme_flag |= NVME_FLAG_DELETING;\n\t\t\tqla_nvme_unregister_remote_port(sess);\n\t\t}\n\n\t\tif (ha->flags.edif_enabled &&\n\t\t\t\t(!own || own->iocb.u.isp24.status_subcode == ELS_PLOGI)) {\n\t\t\tsess->edif.authok = 0;\n\t\t\tif (!ha->flags.host_shutting_down) {\n\t\t\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t\t\t       \"%s wwpn %8phC calling qla2x00_release_all_sadb\\n\",\n\t\t\t\t       __func__, sess->port_name);\n\t\t\t\tqla2x00_release_all_sadb(vha, sess);\n\t\t\t} else {\n\t\t\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t\t\t       \"%s bypassing release_all_sadb\\n\",\n\t\t\t\t       __func__);\n\t\t\t}\n\n\t\t\tqla_edif_clear_appdata(vha, sess);\n\t\t\tqla_edif_sess_down(vha, sess);\n\t\t}\n\t}\n\n\t \n\tif (sess->se_sess != NULL)\n\t\tha->tgt.tgt_ops->free_session(sess);\n\n\tif (logout_started) {\n\t\tbool traced = false;\n\t\tu16 cnt = 0;\n\n\t\twhile (!READ_ONCE(sess->logout_completed)) {\n\t\t\tif (!traced) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0xf086,\n\t\t\t\t\t\"%s: waiting for sess %p logout\\n\",\n\t\t\t\t\t__func__, sess);\n\t\t\t\ttraced = true;\n\t\t\t}\n\t\t\tmsleep(100);\n\t\t\tcnt++;\n\t\t\t \n\t\t\tif (cnt > 230)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tql_dbg(ql_dbg_disc, vha, 0xf087,\n\t\t    \"%s: sess %p logout completed\\n\", __func__, sess);\n\t}\n\n\tif (sess->logo_ack_needed) {\n\t\tsess->logo_ack_needed = 0;\n\t\tqla24xx_async_notify_ack(vha, sess,\n\t\t\t(struct imm_ntfy_from_isp *)sess->iocb, SRB_NACK_LOGO);\n\t}\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tif (sess->se_sess) {\n\t\tsess->se_sess = NULL;\n\t\tif (tgt && !IS_SW_RESV_ADDR(sess->d_id))\n\t\t\ttgt->sess_count--;\n\t}\n\n\tqla2x00_set_fcport_disc_state(sess, DSC_DELETED);\n\tsess->fw_login_state = DSC_LS_PORT_UNAVAIL;\n\n\tif (sess->login_succ && !IS_SW_RESV_ADDR(sess->d_id)) {\n\t\tvha->fcport_count--;\n\t\tsess->login_succ = 0;\n\t}\n\n\tqla2x00_clear_loop_id(sess);\n\n\tif (sess->conflict) {\n\t\tsess->conflict->login_pause = 0;\n\t\tsess->conflict = NULL;\n\t\tif (!test_bit(UNLOADING, &vha->dpc_flags))\n\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t}\n\n\t{\n\t\tstruct qlt_plogi_ack_t *con =\n\t\t    sess->plogi_link[QLT_PLOGI_LINK_CONFLICT];\n\t\tstruct imm_ntfy_from_isp *iocb;\n\n\t\town = sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN];\n\n\t\tif (con) {\n\t\t\tiocb = &con->iocb;\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf099,\n\t\t\t\t \"se_sess %p / sess %p port %8phC is gone,\"\n\t\t\t\t \" %s (ref=%d), releasing PLOGI for %8phC (ref=%d)\\n\",\n\t\t\t\t sess->se_sess, sess, sess->port_name,\n\t\t\t\t own ? \"releasing own PLOGI\" : \"no own PLOGI pending\",\n\t\t\t\t own ? own->ref_count : -1,\n\t\t\t\t iocb->u.isp24.port_name, con->ref_count);\n\t\t\tqlt_plogi_ack_unref(vha, con);\n\t\t\tsess->plogi_link[QLT_PLOGI_LINK_CONFLICT] = NULL;\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf09a,\n\t\t\t    \"se_sess %p / sess %p port %8phC is gone, %s (ref=%d)\\n\",\n\t\t\t    sess->se_sess, sess, sess->port_name,\n\t\t\t    own ? \"releasing own PLOGI\" :\n\t\t\t    \"no own PLOGI pending\",\n\t\t\t    own ? own->ref_count : -1);\n\t\t}\n\n\t\tif (own) {\n\t\t\tsess->fw_login_state = DSC_LS_PLOGI_PEND;\n\t\t\tqlt_plogi_ack_unref(vha, own);\n\t\t\tsess->plogi_link[QLT_PLOGI_LINK_SAME_WWN] = NULL;\n\t\t}\n\t}\n\n\tsess->explicit_logout = 0;\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\tqla2x00_dfs_remove_rport(vha, sess);\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tsess->flags &= ~FCF_ASYNC_SENT;\n\tsess->deleted = QLA_SESS_DELETED;\n\tsess->free_pending = 0;\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\tql_dbg(ql_dbg_disc, vha, 0xf001,\n\t    \"Unregistration of sess %p %8phC finished fcp_cnt %d\\n\",\n\t\tsess, sess->port_name, vha->fcport_count);\n\n\tif (tgt && (tgt->sess_count == 0))\n\t\twake_up_all(&tgt->waitQ);\n\n\tif (!test_bit(PFLG_DRIVER_REMOVING, &base_vha->pci_flags) &&\n\t    !(vha->vp_idx && test_bit(VPORT_DELETE, &vha->dpc_flags)) &&\n\t    (!tgt || !tgt->tgt_stop) && !LOOP_TRANSITION(vha)) {\n\t\tswitch (vha->host->active_mode) {\n\t\tcase MODE_INITIATOR:\n\t\tcase MODE_DUAL:\n\t\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\tbreak;\n\t\tcase MODE_TARGET:\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (vha->fcport_count == 0)\n\t\twake_up_all(&vha->fcport_waitQ);\n}\n\n \nvoid qlt_unreg_sess(struct fc_port *sess)\n{\n\tstruct scsi_qla_host *vha = sess->vha;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_disc, sess->vha, 0x210a,\n\t    \"%s sess %p for deletion %8phC\\n\",\n\t    __func__, sess, sess->port_name);\n\n\tspin_lock_irqsave(&sess->vha->work_lock, flags);\n\tif (sess->free_pending) {\n\t\tspin_unlock_irqrestore(&sess->vha->work_lock, flags);\n\t\treturn;\n\t}\n\tsess->free_pending = 1;\n\t \n\tsess->flags |= FCF_ASYNC_SENT;\n\tsess->deleted = QLA_SESS_DELETION_IN_PROGRESS;\n\tspin_unlock_irqrestore(&sess->vha->work_lock, flags);\n\n\tif (sess->se_sess)\n\t\tvha->hw->tgt.tgt_ops->clear_nacl_from_fcport_map(sess);\n\n\tqla2x00_set_fcport_disc_state(sess, DSC_DELETE_PEND);\n\tsess->last_rscn_gen = sess->rscn_gen;\n\tsess->last_login_gen = sess->login_gen;\n\n\tqueue_work(sess->vha->hw->wq, &sess->free_work);\n}\nEXPORT_SYMBOL(qlt_unreg_sess);\n\nstatic int qlt_reset(struct scsi_qla_host *vha, void *iocb, int mcmd)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess = NULL;\n\tuint16_t loop_id;\n\tint res = 0;\n\tstruct imm_ntfy_from_isp *n = (struct imm_ntfy_from_isp *)iocb;\n\tunsigned long flags;\n\n\tloop_id = le16_to_cpu(n->u.isp24.nport_handle);\n\tif (loop_id == 0xFFFF) {\n\t\t \n\t\tatomic_inc(&vha->vha_tgt.qla_tgt->tgt_global_resets_count);\n\t\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\t\tqlt_clear_tgt_db(vha->vha_tgt.qla_tgt);\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t} else {\n\t\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\t\tsess = ha->tgt.tgt_ops->find_sess_by_loop_id(vha, loop_id);\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t}\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe000,\n\t    \"Using sess for qla_tgt_reset: %p\\n\", sess);\n\tif (!sess) {\n\t\tres = -ESRCH;\n\t\treturn res;\n\t}\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe047,\n\t    \"scsi(%ld): resetting (session %p from port %8phC mcmd %x, \"\n\t    \"loop_id %d)\\n\", vha->host_no, sess, sess->port_name,\n\t    mcmd, loop_id);\n\n\treturn qlt_issue_task_mgmt(sess, 0, mcmd, iocb, QLA24XX_MGMT_SEND_NACK);\n}\n\nstatic void qla24xx_chk_fcp_state(struct fc_port *sess)\n{\n\tif (sess->chip_reset != sess->vha->hw->base_qpair->chip_reset) {\n\t\tsess->logout_on_delete = 0;\n\t\tsess->logo_ack_needed = 0;\n\t\tsess->fw_login_state = DSC_LS_PORT_UNAVAIL;\n\t}\n}\n\nvoid qlt_schedule_sess_for_deletion(struct fc_port *sess)\n{\n\tstruct qla_tgt *tgt = sess->tgt;\n\tunsigned long flags;\n\tu16 sec;\n\n\tswitch (sess->disc_state) {\n\tcase DSC_DELETE_PEND:\n\t\treturn;\n\tcase DSC_DELETED:\n\t\tif (!sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN] &&\n\t\t\t!sess->plogi_link[QLT_PLOGI_LINK_CONFLICT]) {\n\t\t\tif (tgt && tgt->tgt_stop && tgt->sess_count == 0)\n\t\t\t\twake_up_all(&tgt->waitQ);\n\n\t\t\tif (sess->vha->fcport_count == 0)\n\t\t\t\twake_up_all(&sess->vha->fcport_waitQ);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase DSC_UPD_FCPORT:\n\t\t \n\t\tsess->next_disc_state = DSC_DELETE_PEND;\n\t\tsec = jiffies_to_msecs(jiffies -\n\t\t    sess->jiffies_at_registration)/1000;\n\t\tif (sess->sec_since_registration < sec && sec && !(sec % 5)) {\n\t\t\tsess->sec_since_registration = sec;\n\t\t\tql_dbg(ql_dbg_disc, sess->vha, 0xffff,\n\t\t\t    \"%s %8phC : Slow Rport registration(%d Sec)\\n\",\n\t\t\t    __func__, sess->port_name, sec);\n\t\t}\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&sess->vha->work_lock, flags);\n\tif (sess->deleted == QLA_SESS_DELETION_IN_PROGRESS) {\n\t\tspin_unlock_irqrestore(&sess->vha->work_lock, flags);\n\t\treturn;\n\t}\n\tsess->deleted = QLA_SESS_DELETION_IN_PROGRESS;\n\tspin_unlock_irqrestore(&sess->vha->work_lock, flags);\n\n\tsess->prli_pend_timer = 0;\n\tqla2x00_set_fcport_disc_state(sess, DSC_DELETE_PEND);\n\n\tqla24xx_chk_fcp_state(sess);\n\n\tql_dbg(ql_log_warn, sess->vha, 0xe001,\n\t    \"Scheduling sess %p for deletion %8phC fc4_type %x\\n\",\n\t    sess, sess->port_name, sess->fc4_type);\n\n\tWARN_ON(!queue_work(sess->vha->hw->wq, &sess->del_work));\n}\n\nstatic void qlt_clear_tgt_db(struct qla_tgt *tgt)\n{\n\tstruct fc_port *sess;\n\tscsi_qla_host_t *vha = tgt->vha;\n\n\tlist_for_each_entry(sess, &vha->vp_fcports, list) {\n\t\tif (sess->se_sess)\n\t\t\tqlt_schedule_sess_for_deletion(sess);\n\t}\n\n\t \n}\n\nstatic int qla24xx_get_loop_id(struct scsi_qla_host *vha, be_id_t s_id,\n\tuint16_t *loop_id)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tdma_addr_t gid_list_dma;\n\tstruct gid_list_info *gid_list, *gid;\n\tint res, rc, i;\n\tuint16_t entries;\n\n\tgid_list = dma_alloc_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),\n\t    &gid_list_dma, GFP_KERNEL);\n\tif (!gid_list) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf044,\n\t\t    \"qla_target(%d): DMA Alloc failed of %u\\n\",\n\t\t    vha->vp_idx, qla2x00_gid_list_size(ha));\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trc = qla24xx_gidlist_wait(vha, gid_list, gid_list_dma, &entries);\n\tif (rc != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf045,\n\t\t    \"qla_target(%d): get_id_list() failed: %x\\n\",\n\t\t    vha->vp_idx, rc);\n\t\tres = -EBUSY;\n\t\tgoto out_free_id_list;\n\t}\n\n\tgid = gid_list;\n\tres = -ENOENT;\n\tfor (i = 0; i < entries; i++) {\n\t\tif (gid->al_pa == s_id.al_pa &&\n\t\t    gid->area == s_id.area &&\n\t\t    gid->domain == s_id.domain) {\n\t\t\t*loop_id = le16_to_cpu(gid->loop_id);\n\t\t\tres = 0;\n\t\t\tbreak;\n\t\t}\n\t\tgid = (void *)gid + ha->gid_list_info_size;\n\t}\n\nout_free_id_list:\n\tdma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),\n\t    gid_list, gid_list_dma);\n\treturn res;\n}\n\n \nstatic struct fc_port *qlt_create_sess(\n\tstruct scsi_qla_host *vha,\n\tfc_port_t *fcport,\n\tbool local)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess = fcport;\n\tunsigned long flags;\n\n\tif (vha->vha_tgt.qla_tgt->tgt_stop)\n\t\treturn NULL;\n\n\tif (fcport->se_sess) {\n\t\tif (!kref_get_unless_zero(&sess->sess_kref)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20f6,\n\t\t\t    \"%s: kref_get_unless_zero failed for %8phC\\n\",\n\t\t\t    __func__, sess->port_name);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn fcport;\n\t}\n\tsess->tgt = vha->vha_tgt.qla_tgt;\n\tsess->local = local;\n\n\t \n\tsess->logout_on_delete = 1;\n\tsess->keep_nport_handle = 0;\n\tsess->logout_completed = 0;\n\n\tif (ha->tgt.tgt_ops->check_initiator_node_acl(vha,\n\t    &fcport->port_name[0], sess) < 0) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf015,\n\t\t    \"(%d) %8phC check_initiator_node_acl failed\\n\",\n\t\t    vha->vp_idx, fcport->port_name);\n\t\treturn NULL;\n\t} else {\n\t\tkref_init(&fcport->sess_kref);\n\t\t \n\t\tif (!kref_get_unless_zero(&sess->sess_kref)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20f7,\n\t\t\t    \"%s: kref_get_unless_zero failed for %8phC\\n\",\n\t\t\t    __func__, sess->port_name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\t\tif (!IS_SW_RESV_ADDR(sess->d_id))\n\t\t\tvha->vha_tgt.qla_tgt->sess_count++;\n\n\t\tqlt_do_generation_tick(vha, &sess->generation);\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\t}\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf006,\n\t    \"Adding sess %p se_sess %p  to tgt %p sess_count %d\\n\",\n\t    sess, sess->se_sess, vha->vha_tgt.qla_tgt,\n\t    vha->vha_tgt.qla_tgt->sess_count);\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf04b,\n\t    \"qla_target(%d): %ssession for wwn %8phC (loop_id %d, \"\n\t    \"s_id %x:%x:%x, confirmed completion %ssupported) added\\n\",\n\t    vha->vp_idx, local ?  \"local \" : \"\", fcport->port_name,\n\t    fcport->loop_id, sess->d_id.b.domain, sess->d_id.b.area,\n\t    sess->d_id.b.al_pa, sess->conf_compl_supported ?  \"\" : \"not \");\n\n\treturn sess;\n}\n\n \nvoid\nqlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport, int max_gen)\n{\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tstruct fc_port *sess = fcport;\n\tunsigned long flags;\n\n\tif (!vha->hw->tgt.tgt_ops)\n\t\treturn;\n\n\tif (!tgt)\n\t\treturn;\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tif (tgt->tgt_stop) {\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\treturn;\n\t}\n\tif (!sess->se_sess) {\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\treturn;\n\t}\n\n\tif (max_gen - sess->generation < 0) {\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf092,\n\t\t    \"Ignoring stale deletion request for se_sess %p / sess %p\"\n\t\t    \" for port %8phC, req_gen %d, sess_gen %d\\n\",\n\t\t    sess->se_sess, sess, sess->port_name, max_gen,\n\t\t    sess->generation);\n\t\treturn;\n\t}\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf008, \"qla_tgt_fc_port_deleted %p\", sess);\n\n\tsess->local = 1;\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\tqlt_schedule_sess_for_deletion(sess);\n}\n\nstatic inline int test_tgt_sess_count(struct qla_tgt *tgt)\n{\n\tstruct qla_hw_data *ha = tgt->ha;\n\tunsigned long flags;\n\tint res;\n\t \n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tql_dbg(ql_dbg_tgt, tgt->vha, 0xe002,\n\t    \"tgt %p, sess_count=%d\\n\",\n\t    tgt, tgt->sess_count);\n\tres = (tgt->sess_count == 0);\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\treturn res;\n}\n\n \nint qlt_stop_phase1(struct qla_tgt *tgt)\n{\n\tstruct scsi_qla_host *vha = tgt->vha;\n\tstruct qla_hw_data *ha = tgt->ha;\n\tunsigned long flags;\n\n\tmutex_lock(&ha->optrom_mutex);\n\tmutex_lock(&qla_tgt_mutex);\n\n\tif (tgt->tgt_stop || tgt->tgt_stopped) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf04e,\n\t\t    \"Already in tgt->tgt_stop or tgt_stopped state\\n\");\n\t\tmutex_unlock(&qla_tgt_mutex);\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -EPERM;\n\t}\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xe003, \"Stopping target for host %ld(%p)\\n\",\n\t    vha->host_no, vha);\n\t \n\tmutex_lock(&vha->vha_tgt.tgt_mutex);\n\ttgt->tgt_stop = 1;\n\tqlt_clear_tgt_db(tgt);\n\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\tmutex_unlock(&qla_tgt_mutex);\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf009,\n\t    \"Waiting for sess works (tgt %p)\", tgt);\n\tspin_lock_irqsave(&tgt->sess_work_lock, flags);\n\tdo {\n\t\tspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\n\t\tflush_work(&tgt->sess_work);\n\t\tspin_lock_irqsave(&tgt->sess_work_lock, flags);\n\t} while (!list_empty(&tgt->sess_works_list));\n\tspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf00a,\n\t    \"Waiting for tgt %p: sess_count=%d\\n\", tgt, tgt->sess_count);\n\n\twait_event_timeout(tgt->waitQ, test_tgt_sess_count(tgt), 10*HZ);\n\n\t \n\tif (!ha->flags.host_shutting_down &&\n\t    (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)))\n\t\tqlt_disable_vha(vha);\n\n\t \n\twait_event_timeout(tgt->waitQ, test_tgt_sess_count(tgt), 10*HZ);\n\tmutex_unlock(&ha->optrom_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(qlt_stop_phase1);\n\n \nvoid qlt_stop_phase2(struct qla_tgt *tgt)\n{\n\tscsi_qla_host_t *vha = tgt->vha;\n\n\tif (tgt->tgt_stopped) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf04f,\n\t\t    \"Already in tgt->tgt_stopped state\\n\");\n\t\tdump_stack();\n\t\treturn;\n\t}\n\tif (!tgt->tgt_stop) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf00b,\n\t\t    \"%s: phase1 stop is not completed\\n\", __func__);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tmutex_lock(&tgt->ha->optrom_mutex);\n\tmutex_lock(&vha->vha_tgt.tgt_mutex);\n\ttgt->tgt_stop = 0;\n\ttgt->tgt_stopped = 1;\n\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\tmutex_unlock(&tgt->ha->optrom_mutex);\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf00c, \"Stop of tgt %p finished\\n\",\n\t    tgt);\n\n\tswitch (vha->qlini_mode) {\n\tcase QLA2XXX_INI_MODE_EXCLUSIVE:\n\t\tvha->flags.online = 1;\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(qlt_stop_phase2);\n\n \nstatic void qlt_release(struct qla_tgt *tgt)\n{\n\tscsi_qla_host_t *vha = tgt->vha;\n\tvoid *node;\n\tu64 key = 0;\n\tu16 i;\n\tstruct qla_qpair_hint *h;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!tgt->tgt_stop && !tgt->tgt_stopped)\n\t\tqlt_stop_phase1(tgt);\n\n\tif (!tgt->tgt_stopped)\n\t\tqlt_stop_phase2(tgt);\n\n\tfor (i = 0; i < vha->hw->max_qpairs + 1; i++) {\n\t\tunsigned long flags;\n\n\t\th = &tgt->qphints[i];\n\t\tif (h->qpair) {\n\t\t\tspin_lock_irqsave(h->qpair->qp_lock_ptr, flags);\n\t\t\tlist_del(&h->hint_elem);\n\t\t\tspin_unlock_irqrestore(h->qpair->qp_lock_ptr, flags);\n\t\t\th->qpair = NULL;\n\t\t}\n\t}\n\tkfree(tgt->qphints);\n\tmutex_lock(&qla_tgt_mutex);\n\tlist_del(&vha->vha_tgt.qla_tgt->tgt_list_entry);\n\tmutex_unlock(&qla_tgt_mutex);\n\n\tbtree_for_each_safe64(&tgt->lun_qpair_map, key, node)\n\t\tbtree_remove64(&tgt->lun_qpair_map, key);\n\n\tbtree_destroy64(&tgt->lun_qpair_map);\n\n\tif (vha->vp_idx)\n\t\tif (ha->tgt.tgt_ops &&\n\t\t    ha->tgt.tgt_ops->remove_target &&\n\t\t    vha->vha_tgt.target_lport_ptr)\n\t\t\tha->tgt.tgt_ops->remove_target(vha);\n\n\tvha->vha_tgt.qla_tgt = NULL;\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf00d,\n\t    \"Release of tgt %p finished\\n\", tgt);\n\n\tkfree(tgt);\n}\n\n \nstatic int qlt_sched_sess_work(struct qla_tgt *tgt, int type,\n\tconst void *param, unsigned int param_size)\n{\n\tstruct qla_tgt_sess_work_param *prm;\n\tunsigned long flags;\n\n\tprm = kzalloc(sizeof(*prm), GFP_ATOMIC);\n\tif (!prm) {\n\t\tql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf050,\n\t\t    \"qla_target(%d): Unable to create session \"\n\t\t    \"work, command will be refused\", 0);\n\t\treturn -ENOMEM;\n\t}\n\n\tql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf00e,\n\t    \"Scheduling work (type %d, prm %p)\"\n\t    \" to find session for param %p (size %d, tgt %p)\\n\",\n\t    type, prm, param, param_size, tgt);\n\n\tprm->type = type;\n\tmemcpy(&prm->tm_iocb, param, param_size);\n\n\tspin_lock_irqsave(&tgt->sess_work_lock, flags);\n\tlist_add_tail(&prm->sess_works_list_entry, &tgt->sess_works_list);\n\tspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\n\n\tschedule_work(&tgt->sess_work);\n\n\treturn 0;\n}\n\n \nstatic void qlt_send_notify_ack(struct qla_qpair *qpair,\n\tstruct imm_ntfy_from_isp *ntfy,\n\tuint32_t add_flags, uint16_t resp_code, int resp_code_valid,\n\tuint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan)\n{\n\tstruct scsi_qla_host *vha = qpair->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\trequest_t *pkt;\n\tstruct nack_to_isp *nack;\n\n\tif (!ha->flags.fw_started)\n\t\treturn;\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe004, \"Sending NOTIFY_ACK (ha=%p)\\n\", ha);\n\n\tpkt = (request_t *)__qla2x00_alloc_iocbs(qpair, NULL);\n\tif (!pkt) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe049,\n\t\t    \"qla_target(%d): %s failed: unable to allocate \"\n\t\t    \"request packet\\n\", vha->vp_idx, __func__);\n\t\treturn;\n\t}\n\n\tif (vha->vha_tgt.qla_tgt != NULL)\n\t\tvha->vha_tgt.qla_tgt->notify_ack_expected++;\n\n\tpkt->entry_type = NOTIFY_ACK_TYPE;\n\tpkt->entry_count = 1;\n\n\tnack = (struct nack_to_isp *)pkt;\n\tnack->ox_id = ntfy->ox_id;\n\n\tnack->u.isp24.handle = QLA_TGT_SKIP_HANDLE;\n\tnack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;\n\tif (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {\n\t\tnack->u.isp24.flags = ntfy->u.isp24.flags &\n\t\t\tcpu_to_le16(NOTIFY24XX_FLAGS_PUREX_IOCB);\n\t}\n\tnack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;\n\tnack->u.isp24.status = ntfy->u.isp24.status;\n\tnack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;\n\tnack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;\n\tnack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;\n\tnack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;\n\tnack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;\n\tnack->u.isp24.srr_flags = cpu_to_le16(srr_flags);\n\tnack->u.isp24.srr_reject_code = srr_reject_code;\n\tnack->u.isp24.srr_reject_code_expl = srr_explan;\n\tnack->u.isp24.vp_index = ntfy->u.isp24.vp_index;\n\n\t \n\tif (ntfy->u.isp24.status_subcode == ELS_PLOGI &&\n\t    (le16_to_cpu(ntfy->u.isp24.flags) & NOTIFY24XX_FLAGS_FCSP)) {\n\t\tnack->u.isp24.flags |= cpu_to_le16(NOTIFY_ACK_FLAGS_FCSP);\n\t}\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe005,\n\t    \"qla_target(%d): Sending 24xx Notify Ack %d\\n\",\n\t    vha->vp_idx, nack->u.isp24.status);\n\n\t \n\twmb();\n\tqla2x00_start_iocbs(vha, qpair->req);\n}\n\nstatic int qlt_build_abts_resp_iocb(struct qla_tgt_mgmt_cmd *mcmd)\n{\n\tstruct scsi_qla_host *vha = mcmd->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct abts_resp_to_24xx *resp;\n\t__le32 f_ctl;\n\tuint32_t h;\n\tuint8_t *p;\n\tint rc;\n\tstruct abts_recv_from_24xx *abts = &mcmd->orig_iocb.abts;\n\tstruct qla_qpair *qpair = mcmd->qpair;\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe006,\n\t    \"Sending task mgmt ABTS response (ha=%p, status=%x)\\n\",\n\t    ha, mcmd->fc_tm_rsp);\n\n\trc = qlt_check_reserve_free_req(qpair, 1);\n\tif (rc) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe04a,\n\t\t    \"qla_target(%d): %s failed: unable to allocate request packet\\n\",\n\t\t    vha->vp_idx, __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tresp = (struct abts_resp_to_24xx *)qpair->req->ring_ptr;\n\tmemset(resp, 0, sizeof(*resp));\n\n\th = qlt_make_handle(qpair);\n\tif (unlikely(h == QLA_TGT_NULL_HANDLE)) {\n\t\t \n\t\treturn -EAGAIN;\n\t} else {\n\t\tqpair->req->outstanding_cmds[h] = (srb_t *)mcmd;\n\t}\n\n\tresp->handle = make_handle(qpair->req->id, h);\n\tresp->entry_type = ABTS_RESP_24XX;\n\tresp->entry_count = 1;\n\tresp->nport_handle = abts->nport_handle;\n\tresp->vp_index = vha->vp_idx;\n\tresp->sof_type = abts->sof_type;\n\tresp->exchange_address = abts->exchange_address;\n\tresp->fcp_hdr_le = abts->fcp_hdr_le;\n\tf_ctl = cpu_to_le32(F_CTL_EXCH_CONTEXT_RESP |\n\t    F_CTL_LAST_SEQ | F_CTL_END_SEQ |\n\t    F_CTL_SEQ_INITIATIVE);\n\tp = (uint8_t *)&f_ctl;\n\tresp->fcp_hdr_le.f_ctl[0] = *p++;\n\tresp->fcp_hdr_le.f_ctl[1] = *p++;\n\tresp->fcp_hdr_le.f_ctl[2] = *p;\n\n\tresp->fcp_hdr_le.d_id = abts->fcp_hdr_le.s_id;\n\tresp->fcp_hdr_le.s_id = abts->fcp_hdr_le.d_id;\n\n\tresp->exchange_addr_to_abort = abts->exchange_addr_to_abort;\n\tif (mcmd->fc_tm_rsp == FCP_TMF_CMPL) {\n\t\tresp->fcp_hdr_le.r_ctl = R_CTL_BASIC_LINK_SERV | R_CTL_B_ACC;\n\t\tresp->payload.ba_acct.seq_id_valid = SEQ_ID_INVALID;\n\t\tresp->payload.ba_acct.low_seq_cnt = 0x0000;\n\t\tresp->payload.ba_acct.high_seq_cnt = cpu_to_le16(0xFFFF);\n\t\tresp->payload.ba_acct.ox_id = abts->fcp_hdr_le.ox_id;\n\t\tresp->payload.ba_acct.rx_id = abts->fcp_hdr_le.rx_id;\n\t} else {\n\t\tresp->fcp_hdr_le.r_ctl = R_CTL_BASIC_LINK_SERV | R_CTL_B_RJT;\n\t\tresp->payload.ba_rjt.reason_code =\n\t\t\tBA_RJT_REASON_CODE_UNABLE_TO_PERFORM;\n\t\t \n\t}\n\n\tvha->vha_tgt.qla_tgt->abts_resp_expected++;\n\n\t \n\twmb();\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(vha, qpair->req);\n\n\treturn rc;\n}\n\n \nstatic void qlt_24xx_send_abts_resp(struct qla_qpair *qpair,\n\tstruct abts_recv_from_24xx *abts, uint32_t status,\n\tbool ids_reversed)\n{\n\tstruct scsi_qla_host *vha = qpair->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct abts_resp_to_24xx *resp;\n\t__le32 f_ctl;\n\tuint8_t *p;\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe006,\n\t    \"Sending task mgmt ABTS response (ha=%p, atio=%p, status=%x\\n\",\n\t    ha, abts, status);\n\n\tresp = (struct abts_resp_to_24xx *)qla2x00_alloc_iocbs_ready(qpair,\n\t    NULL);\n\tif (!resp) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe04a,\n\t\t    \"qla_target(%d): %s failed: unable to allocate \"\n\t\t    \"request packet\", vha->vp_idx, __func__);\n\t\treturn;\n\t}\n\n\tresp->entry_type = ABTS_RESP_24XX;\n\tresp->handle = QLA_TGT_SKIP_HANDLE;\n\tresp->entry_count = 1;\n\tresp->nport_handle = abts->nport_handle;\n\tresp->vp_index = vha->vp_idx;\n\tresp->sof_type = abts->sof_type;\n\tresp->exchange_address = abts->exchange_address;\n\tresp->fcp_hdr_le = abts->fcp_hdr_le;\n\tf_ctl = cpu_to_le32(F_CTL_EXCH_CONTEXT_RESP |\n\t    F_CTL_LAST_SEQ | F_CTL_END_SEQ |\n\t    F_CTL_SEQ_INITIATIVE);\n\tp = (uint8_t *)&f_ctl;\n\tresp->fcp_hdr_le.f_ctl[0] = *p++;\n\tresp->fcp_hdr_le.f_ctl[1] = *p++;\n\tresp->fcp_hdr_le.f_ctl[2] = *p;\n\tif (ids_reversed) {\n\t\tresp->fcp_hdr_le.d_id = abts->fcp_hdr_le.d_id;\n\t\tresp->fcp_hdr_le.s_id = abts->fcp_hdr_le.s_id;\n\t} else {\n\t\tresp->fcp_hdr_le.d_id = abts->fcp_hdr_le.s_id;\n\t\tresp->fcp_hdr_le.s_id = abts->fcp_hdr_le.d_id;\n\t}\n\tresp->exchange_addr_to_abort = abts->exchange_addr_to_abort;\n\tif (status == FCP_TMF_CMPL) {\n\t\tresp->fcp_hdr_le.r_ctl = R_CTL_BASIC_LINK_SERV | R_CTL_B_ACC;\n\t\tresp->payload.ba_acct.seq_id_valid = SEQ_ID_INVALID;\n\t\tresp->payload.ba_acct.low_seq_cnt = 0x0000;\n\t\tresp->payload.ba_acct.high_seq_cnt = cpu_to_le16(0xFFFF);\n\t\tresp->payload.ba_acct.ox_id = abts->fcp_hdr_le.ox_id;\n\t\tresp->payload.ba_acct.rx_id = abts->fcp_hdr_le.rx_id;\n\t} else {\n\t\tresp->fcp_hdr_le.r_ctl = R_CTL_BASIC_LINK_SERV | R_CTL_B_RJT;\n\t\tresp->payload.ba_rjt.reason_code =\n\t\t\tBA_RJT_REASON_CODE_UNABLE_TO_PERFORM;\n\t\t \n\t}\n\n\tvha->vha_tgt.qla_tgt->abts_resp_expected++;\n\n\t \n\twmb();\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(vha, qpair->req);\n}\n\n \nstatic void qlt_24xx_retry_term_exchange(struct scsi_qla_host *vha,\n    struct qla_qpair *qpair, response_t *pkt, struct qla_tgt_mgmt_cmd *mcmd)\n{\n\tstruct ctio7_to_24xx *ctio;\n\tu16 tmp;\n\tstruct abts_recv_from_24xx *entry;\n\n\tctio = (struct ctio7_to_24xx *)qla2x00_alloc_iocbs_ready(qpair, NULL);\n\tif (ctio == NULL) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe04b,\n\t\t    \"qla_target(%d): %s failed: unable to allocate \"\n\t\t    \"request packet\\n\", vha->vp_idx, __func__);\n\t\treturn;\n\t}\n\n\tif (mcmd)\n\t\t \n\t\tentry = &mcmd->orig_iocb.abts;\n\telse\n\t\t \n\t\tentry = (struct abts_recv_from_24xx *)pkt;\n\n\t \n\n\tctio->entry_type = CTIO_TYPE7;\n\tctio->entry_count = 1;\n\tctio->nport_handle = entry->nport_handle;\n\tctio->handle = QLA_TGT_SKIP_HANDLE |\tCTIO_COMPLETION_HANDLE_MARK;\n\tctio->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);\n\tctio->vp_index = vha->vp_idx;\n\tctio->exchange_addr = entry->exchange_addr_to_abort;\n\ttmp = (CTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_TERMINATE);\n\n\tif (mcmd) {\n\t\tctio->initiator_id = entry->fcp_hdr_le.s_id;\n\n\t\tif (mcmd->flags & QLA24XX_MGMT_ABORT_IO_ATTR_VALID)\n\t\t\ttmp |= (mcmd->abort_io_attr << 9);\n\t\telse if (qpair->retry_term_cnt & 1)\n\t\t\ttmp |= (0x4 << 9);\n\t} else {\n\t\tctio->initiator_id = entry->fcp_hdr_le.d_id;\n\n\t\tif (qpair->retry_term_cnt & 1)\n\t\t\ttmp |= (0x4 << 9);\n\t}\n\tctio->u.status1.flags = cpu_to_le16(tmp);\n\tctio->u.status1.ox_id = entry->fcp_hdr_le.ox_id;\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe007,\n\t    \"Sending retry TERM EXCH CTIO7 flags %04xh oxid %04xh attr valid %x\\n\",\n\t    le16_to_cpu(ctio->u.status1.flags),\n\t    le16_to_cpu(ctio->u.status1.ox_id),\n\t    (mcmd && mcmd->flags & QLA24XX_MGMT_ABORT_IO_ATTR_VALID) ? 1 : 0);\n\n\t \n\twmb();\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(vha, qpair->req);\n\n\tif (mcmd)\n\t\tqlt_build_abts_resp_iocb(mcmd);\n\telse\n\t\tqlt_24xx_send_abts_resp(qpair,\n\t\t    (struct abts_recv_from_24xx *)entry, FCP_TMF_CMPL, true);\n\n}\n\n \nstatic void abort_cmds_for_lun(struct scsi_qla_host *vha, u64 lun, be_id_t s_id)\n{\n\tstruct qla_tgt_sess_op *op;\n\tstruct qla_tgt_cmd *cmd;\n\tuint32_t key;\n\tunsigned long flags;\n\n\tkey = sid_to_key(s_id);\n\tspin_lock_irqsave(&vha->cmd_list_lock, flags);\n\tlist_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {\n\t\tuint32_t op_key;\n\t\tu64 op_lun;\n\n\t\top_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);\n\t\top_lun = scsilun_to_int(\n\t\t\t(struct scsi_lun *)&op->atio.u.isp24.fcp_cmnd.lun);\n\t\tif (op_key == key && op_lun == lun)\n\t\t\top->aborted = true;\n\t}\n\n\tlist_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {\n\t\tuint32_t cmd_key;\n\t\tu64 cmd_lun;\n\n\t\tcmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);\n\t\tcmd_lun = scsilun_to_int(\n\t\t\t(struct scsi_lun *)&cmd->atio.u.isp24.fcp_cmnd.lun);\n\t\tif (cmd_key == key && cmd_lun == lun)\n\t\t\tcmd->aborted = 1;\n\t}\n\tspin_unlock_irqrestore(&vha->cmd_list_lock, flags);\n}\n\nstatic struct qla_qpair_hint *qlt_find_qphint(struct scsi_qla_host *vha,\n    uint64_t unpacked_lun)\n{\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tstruct qla_qpair_hint *h = NULL;\n\n\tif (vha->flags.qpairs_available) {\n\t\th = btree_lookup64(&tgt->lun_qpair_map, unpacked_lun);\n\t\tif (!h)\n\t\t\th = &tgt->qphints[0];\n\t} else {\n\t\th = &tgt->qphints[0];\n\t}\n\n\treturn h;\n}\n\nstatic void qlt_do_tmr_work(struct work_struct *work)\n{\n\tstruct qla_tgt_mgmt_cmd *mcmd =\n\t\tcontainer_of(work, struct qla_tgt_mgmt_cmd, work);\n\tstruct qla_hw_data *ha = mcmd->vha->hw;\n\tint rc;\n\tuint32_t tag;\n\tunsigned long flags;\n\n\tswitch (mcmd->tmr_func) {\n\tcase QLA_TGT_ABTS:\n\t\ttag = le32_to_cpu(mcmd->orig_iocb.abts.exchange_addr_to_abort);\n\t\tbreak;\n\tdefault:\n\t\ttag = 0;\n\t\tbreak;\n\t}\n\n\trc = ha->tgt.tgt_ops->handle_tmr(mcmd, mcmd->unpacked_lun,\n\t    mcmd->tmr_func, tag);\n\n\tif (rc != 0) {\n\t\tspin_lock_irqsave(mcmd->qpair->qp_lock_ptr, flags);\n\t\tswitch (mcmd->tmr_func) {\n\t\tcase QLA_TGT_ABTS:\n\t\t\tmcmd->fc_tm_rsp = FCP_TMF_REJECTED;\n\t\t\tqlt_build_abts_resp_iocb(mcmd);\n\t\t\tbreak;\n\t\tcase QLA_TGT_LUN_RESET:\n\t\tcase QLA_TGT_CLEAR_TS:\n\t\tcase QLA_TGT_ABORT_TS:\n\t\tcase QLA_TGT_CLEAR_ACA:\n\t\tcase QLA_TGT_TARGET_RESET:\n\t\t\tqlt_send_busy(mcmd->qpair, &mcmd->orig_iocb.atio,\n\t\t\t    qla_sam_status);\n\t\t\tbreak;\n\n\t\tcase QLA_TGT_ABORT_ALL:\n\t\tcase QLA_TGT_NEXUS_LOSS_SESS:\n\t\tcase QLA_TGT_NEXUS_LOSS:\n\t\t\tqlt_send_notify_ack(mcmd->qpair,\n\t\t\t    &mcmd->orig_iocb.imm_ntfy, 0, 0, 0, 0, 0, 0);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(mcmd->qpair->qp_lock_ptr, flags);\n\n\t\tql_dbg(ql_dbg_tgt_mgt, mcmd->vha, 0xf052,\n\t\t    \"qla_target(%d):  tgt_ops->handle_tmr() failed: %d\\n\",\n\t\t    mcmd->vha->vp_idx, rc);\n\t\tmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\n\t}\n}\n\n \nstatic int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,\n\tstruct abts_recv_from_24xx *abts, struct fc_port *sess)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt_mgmt_cmd *mcmd;\n\tstruct qla_qpair_hint *h = &vha->vha_tgt.qla_tgt->qphints[0];\n\tstruct qla_tgt_cmd *abort_cmd;\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf00f,\n\t    \"qla_target(%d): task abort (tag=%d)\\n\",\n\t    vha->vp_idx, abts->exchange_addr_to_abort);\n\n\tmcmd = mempool_alloc(qla_tgt_mgmt_cmd_mempool, GFP_ATOMIC);\n\tif (mcmd == NULL) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf051,\n\t\t    \"qla_target(%d): %s: Allocation of ABORT cmd failed\",\n\t\t    vha->vp_idx, __func__);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(mcmd, 0, sizeof(*mcmd));\n\tmcmd->cmd_type = TYPE_TGT_TMCMD;\n\tmcmd->sess = sess;\n\tmemcpy(&mcmd->orig_iocb.abts, abts, sizeof(mcmd->orig_iocb.abts));\n\tmcmd->reset_count = ha->base_qpair->chip_reset;\n\tmcmd->tmr_func = QLA_TGT_ABTS;\n\tmcmd->qpair = h->qpair;\n\tmcmd->vha = vha;\n\n\t \n\tmcmd->se_cmd.cpuid = h->cpuid;\n\n\tabort_cmd = ha->tgt.tgt_ops->find_cmd_by_tag(sess,\n\t\t\t\tle32_to_cpu(abts->exchange_addr_to_abort));\n\tif (!abort_cmd) {\n\t\tmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\n\t\treturn -EIO;\n\t}\n\tmcmd->unpacked_lun = abort_cmd->se_cmd.orig_fe_lun;\n\n\tif (abort_cmd->qpair) {\n\t\tmcmd->qpair = abort_cmd->qpair;\n\t\tmcmd->se_cmd.cpuid = abort_cmd->se_cmd.cpuid;\n\t\tmcmd->abort_io_attr = abort_cmd->atio.u.isp24.attr;\n\t\tmcmd->flags = QLA24XX_MGMT_ABORT_IO_ATTR_VALID;\n\t}\n\n\tINIT_WORK(&mcmd->work, qlt_do_tmr_work);\n\tqueue_work_on(mcmd->se_cmd.cpuid, qla_tgt_wq, &mcmd->work);\n\n\treturn 0;\n}\n\n \nstatic void qlt_24xx_handle_abts(struct scsi_qla_host *vha,\n\tstruct abts_recv_from_24xx *abts)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess;\n\tuint32_t tag = le32_to_cpu(abts->exchange_addr_to_abort);\n\tbe_id_t s_id;\n\tint rc;\n\tunsigned long flags;\n\n\tif (le32_to_cpu(abts->fcp_hdr_le.parameter) & ABTS_PARAM_ABORT_SEQ) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf053,\n\t\t    \"qla_target(%d): ABTS: Abort Sequence not \"\n\t\t    \"supported\\n\", vha->vp_idx);\n\t\tqlt_24xx_send_abts_resp(ha->base_qpair, abts, FCP_TMF_REJECTED,\n\t\t    false);\n\t\treturn;\n\t}\n\n\tif (tag == ATIO_EXCHANGE_ADDRESS_UNKNOWN) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf010,\n\t\t    \"qla_target(%d): ABTS: Unknown Exchange \"\n\t\t    \"Address received\\n\", vha->vp_idx);\n\t\tqlt_24xx_send_abts_resp(ha->base_qpair, abts, FCP_TMF_REJECTED,\n\t\t    false);\n\t\treturn;\n\t}\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf011,\n\t    \"qla_target(%d): task abort (s_id=%x:%x:%x, \"\n\t    \"tag=%d, param=%x)\\n\", vha->vp_idx, abts->fcp_hdr_le.s_id.domain,\n\t    abts->fcp_hdr_le.s_id.area, abts->fcp_hdr_le.s_id.al_pa, tag,\n\t    le32_to_cpu(abts->fcp_hdr_le.parameter));\n\n\ts_id = le_id_to_be(abts->fcp_hdr_le.s_id);\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, s_id);\n\tif (!sess) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf012,\n\t\t    \"qla_target(%d): task abort for non-existent session\\n\",\n\t\t    vha->vp_idx);\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\t\tqlt_24xx_send_abts_resp(ha->base_qpair, abts, FCP_TMF_REJECTED,\n\t\t\t    false);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\n\tif (sess->deleted) {\n\t\tqlt_24xx_send_abts_resp(ha->base_qpair, abts, FCP_TMF_REJECTED,\n\t\t    false);\n\t\treturn;\n\t}\n\n\trc = __qlt_24xx_handle_abts(vha, abts, sess);\n\tif (rc != 0) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf054,\n\t\t    \"qla_target(%d): __qlt_24xx_handle_abts() failed: %d\\n\",\n\t\t    vha->vp_idx, rc);\n\t\tqlt_24xx_send_abts_resp(ha->base_qpair, abts, FCP_TMF_REJECTED,\n\t\t    false);\n\t\treturn;\n\t}\n}\n\n \nstatic void qlt_24xx_send_task_mgmt_ctio(struct qla_qpair *qpair,\n\tstruct qla_tgt_mgmt_cmd *mcmd, uint32_t resp_code)\n{\n\tstruct scsi_qla_host *ha = mcmd->vha;\n\tstruct atio_from_isp *atio = &mcmd->orig_iocb.atio;\n\tstruct ctio7_to_24xx *ctio;\n\tuint16_t temp;\n\n\tql_dbg(ql_dbg_tgt, ha, 0xe008,\n\t    \"Sending task mgmt CTIO7 (ha=%p, atio=%p, resp_code=%x\\n\",\n\t    ha, atio, resp_code);\n\n\n\tctio = (struct ctio7_to_24xx *)__qla2x00_alloc_iocbs(qpair, NULL);\n\tif (ctio == NULL) {\n\t\tql_dbg(ql_dbg_tgt, ha, 0xe04c,\n\t\t    \"qla_target(%d): %s failed: unable to allocate \"\n\t\t    \"request packet\\n\", ha->vp_idx, __func__);\n\t\treturn;\n\t}\n\n\tctio->entry_type = CTIO_TYPE7;\n\tctio->entry_count = 1;\n\tctio->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;\n\tctio->nport_handle = cpu_to_le16(mcmd->sess->loop_id);\n\tctio->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);\n\tctio->vp_index = ha->vp_idx;\n\tctio->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);\n\tctio->exchange_addr = atio->u.isp24.exchange_addr;\n\ttemp = (atio->u.isp24.attr << 9)|\n\t\tCTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_SEND_STATUS;\n\tctio->u.status1.flags = cpu_to_le16(temp);\n\ttemp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\n\tctio->u.status1.ox_id = cpu_to_le16(temp);\n\tctio->u.status1.scsi_status =\n\t    cpu_to_le16(SS_RESPONSE_INFO_LEN_VALID);\n\tctio->u.status1.response_len = cpu_to_le16(8);\n\tctio->u.status1.sense_data[0] = resp_code;\n\n\t \n\twmb();\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(ha, qpair->req);\n}\n\nvoid qlt_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd)\n{\n\tmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\n}\nEXPORT_SYMBOL(qlt_free_mcmd);\n\n \nvoid qlt_send_resp_ctio(struct qla_qpair *qpair, struct qla_tgt_cmd *cmd,\n    uint8_t scsi_status, uint8_t sense_key, uint8_t asc, uint8_t ascq)\n{\n\tstruct atio_from_isp *atio = &cmd->atio;\n\tstruct ctio7_to_24xx *ctio;\n\tuint16_t temp;\n\tstruct scsi_qla_host *vha = cmd->vha;\n\n\tql_dbg(ql_dbg_tgt_dif, vha, 0x3066,\n\t    \"Sending response CTIO7 (vha=%p, atio=%p, scsi_status=%02x, \"\n\t    \"sense_key=%02x, asc=%02x, ascq=%02x\",\n\t    vha, atio, scsi_status, sense_key, asc, ascq);\n\n\tctio = (struct ctio7_to_24xx *)qla2x00_alloc_iocbs(vha, NULL);\n\tif (!ctio) {\n\t\tql_dbg(ql_dbg_async, vha, 0x3067,\n\t\t    \"qla2x00t(%ld): %s failed: unable to allocate request packet\",\n\t\t    vha->host_no, __func__);\n\t\tgoto out;\n\t}\n\n\tctio->entry_type = CTIO_TYPE7;\n\tctio->entry_count = 1;\n\tctio->handle = QLA_TGT_SKIP_HANDLE;\n\tctio->nport_handle = cpu_to_le16(cmd->sess->loop_id);\n\tctio->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);\n\tctio->vp_index = vha->vp_idx;\n\tctio->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);\n\tctio->exchange_addr = atio->u.isp24.exchange_addr;\n\ttemp = (atio->u.isp24.attr << 9) |\n\t    CTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_SEND_STATUS;\n\tctio->u.status1.flags = cpu_to_le16(temp);\n\ttemp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\n\tctio->u.status1.ox_id = cpu_to_le16(temp);\n\tctio->u.status1.scsi_status =\n\t    cpu_to_le16(SS_RESPONSE_INFO_LEN_VALID | scsi_status);\n\tctio->u.status1.response_len = cpu_to_le16(18);\n\tctio->u.status1.residual = cpu_to_le32(get_datalen_for_atio(atio));\n\n\tif (ctio->u.status1.residual != 0)\n\t\tctio->u.status1.scsi_status |=\n\t\t    cpu_to_le16(SS_RESIDUAL_UNDER);\n\n\t \n\tctio->u.status1.sense_data[0] = 0x70;\n\tctio->u.status1.sense_data[2] = sense_key;\n\t \n\tctio->u.status1.sense_data[7] = 0xa;\n\t \n\tctio->u.status1.sense_data[12] = asc;\n\tctio->u.status1.sense_data[13] = ascq;\n\n\t \n\twmb();\n\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(vha, qpair->req);\n\nout:\n\treturn;\n}\n\n \nvoid qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *mcmd)\n{\n\tstruct scsi_qla_host *vha = mcmd->sess->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\tstruct qla_qpair *qpair = mcmd->qpair;\n\tbool free_mcmd = true;\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf013,\n\t    \"TM response mcmd (%p) status %#x state %#x\",\n\t    mcmd, mcmd->fc_tm_rsp, mcmd->flags);\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\n\tif (!vha->flags.online || mcmd->reset_count != qpair->chip_reset) {\n\t\t \n\t\tql_dbg(ql_dbg_async, vha, 0xe100,\n\t\t\t\"RESET-TMR online/active/old-count/new-count = %d/%d/%d/%d.\\n\",\n\t\t\tvha->flags.online, qla2x00_reset_active(vha),\n\t\t\tmcmd->reset_count, qpair->chip_reset);\n\t\tha->tgt.tgt_ops->free_mcmd(mcmd);\n\t\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\t\treturn;\n\t}\n\n\tif (mcmd->flags == QLA24XX_MGMT_SEND_NACK) {\n\t\tswitch (mcmd->orig_iocb.imm_ntfy.u.isp24.status_subcode) {\n\t\tcase ELS_LOGO:\n\t\tcase ELS_PRLO:\n\t\tcase ELS_TPRLO:\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x2106,\n\t\t\t    \"TM response logo %8phC status %#x state %#x\",\n\t\t\t    mcmd->sess->port_name, mcmd->fc_tm_rsp,\n\t\t\t    mcmd->flags);\n\t\t\tqlt_schedule_sess_for_deletion(mcmd->sess);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tqlt_send_notify_ack(vha->hw->base_qpair,\n\t\t\t    &mcmd->orig_iocb.imm_ntfy, 0, 0, 0, 0, 0, 0);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (mcmd->orig_iocb.atio.u.raw.entry_type == ABTS_RECV_24XX) {\n\t\t\tqlt_build_abts_resp_iocb(mcmd);\n\t\t\tfree_mcmd = false;\n\t\t} else\n\t\t\tqlt_24xx_send_task_mgmt_ctio(qpair, mcmd,\n\t\t\t    mcmd->fc_tm_rsp);\n\t}\n\t \n\tif (free_mcmd)\n\t\tha->tgt.tgt_ops->free_mcmd(mcmd);\n\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n}\nEXPORT_SYMBOL(qlt_xmit_tm_rsp);\n\n \nstatic int qlt_pci_map_calc_cnt(struct qla_tgt_prm *prm)\n{\n\tstruct qla_tgt_cmd *cmd = prm->cmd;\n\n\tBUG_ON(cmd->sg_cnt == 0);\n\n\tprm->sg = (struct scatterlist *)cmd->sg;\n\tprm->seg_cnt = dma_map_sg(&cmd->qpair->pdev->dev, cmd->sg,\n\t    cmd->sg_cnt, cmd->dma_data_direction);\n\tif (unlikely(prm->seg_cnt == 0))\n\t\tgoto out_err;\n\n\tprm->cmd->sg_mapped = 1;\n\n\tif (cmd->se_cmd.prot_op == TARGET_PROT_NORMAL) {\n\t\t \n\t\tif (prm->seg_cnt > QLA_TGT_DATASEGS_PER_CMD_24XX)\n\t\t\tprm->req_cnt += DIV_ROUND_UP(prm->seg_cnt -\n\t\t\tQLA_TGT_DATASEGS_PER_CMD_24XX,\n\t\t\tQLA_TGT_DATASEGS_PER_CONT_24XX);\n\t} else {\n\t\t \n\t\tif ((cmd->se_cmd.prot_op == TARGET_PROT_DIN_INSERT) ||\n\t\t    (cmd->se_cmd.prot_op == TARGET_PROT_DOUT_STRIP)) {\n\t\t\tprm->seg_cnt = DIV_ROUND_UP(cmd->bufflen, cmd->blk_sz);\n\t\t\tprm->tot_dsds = prm->seg_cnt;\n\t\t} else\n\t\t\tprm->tot_dsds = prm->seg_cnt;\n\n\t\tif (cmd->prot_sg_cnt) {\n\t\t\tprm->prot_sg      = cmd->prot_sg;\n\t\t\tprm->prot_seg_cnt = dma_map_sg(&cmd->qpair->pdev->dev,\n\t\t\t\tcmd->prot_sg, cmd->prot_sg_cnt,\n\t\t\t\tcmd->dma_data_direction);\n\t\t\tif (unlikely(prm->prot_seg_cnt == 0))\n\t\t\t\tgoto out_err;\n\n\t\t\tif ((cmd->se_cmd.prot_op == TARGET_PROT_DIN_INSERT) ||\n\t\t\t    (cmd->se_cmd.prot_op == TARGET_PROT_DOUT_STRIP)) {\n\t\t\t\t \n\t\t\t\tprm->prot_seg_cnt = DIV_ROUND_UP(cmd->bufflen,\n\t\t\t\t\t\t\t\tcmd->blk_sz);\n\t\t\t\tprm->tot_dsds += prm->prot_seg_cnt;\n\t\t\t} else\n\t\t\t\tprm->tot_dsds += prm->prot_seg_cnt;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_err:\n\tql_dbg_qp(ql_dbg_tgt, prm->cmd->qpair, 0xe04d,\n\t    \"qla_target(%d): PCI mapping failed: sg_cnt=%d\",\n\t    0, prm->cmd->sg_cnt);\n\treturn -1;\n}\n\nstatic void qlt_unmap_sg(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd)\n{\n\tstruct qla_hw_data *ha;\n\tstruct qla_qpair *qpair;\n\n\tif (!cmd->sg_mapped)\n\t\treturn;\n\n\tqpair = cmd->qpair;\n\n\tdma_unmap_sg(&qpair->pdev->dev, cmd->sg, cmd->sg_cnt,\n\t    cmd->dma_data_direction);\n\tcmd->sg_mapped = 0;\n\n\tif (cmd->prot_sg_cnt)\n\t\tdma_unmap_sg(&qpair->pdev->dev, cmd->prot_sg, cmd->prot_sg_cnt,\n\t\t\tcmd->dma_data_direction);\n\n\tif (!cmd->ctx)\n\t\treturn;\n\tha = vha->hw;\n\tif (cmd->ctx_dsd_alloced)\n\t\tqla2x00_clean_dsd_pool(ha, cmd->ctx);\n\n\tdma_pool_free(ha->dl_dma_pool, cmd->ctx, cmd->ctx->crc_ctx_dma);\n}\n\nstatic int qlt_check_reserve_free_req(struct qla_qpair *qpair,\n\tuint32_t req_cnt)\n{\n\tuint32_t cnt;\n\tstruct req_que *req = qpair->req;\n\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tcnt = (uint16_t)(qpair->use_shadow_reg ? *req->out_ptr :\n\t\t    rd_reg_dword_relaxed(req->req_q_out));\n\n\t\tif  (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length - (req->ring_index - cnt);\n\n\t\tif (unlikely(req->cnt < (req_cnt + 2)))\n\t\t\treturn -EAGAIN;\n\t}\n\n\treq->cnt -= req_cnt;\n\n\treturn 0;\n}\n\n \nstatic inline void *qlt_get_req_pkt(struct req_que *req)\n{\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else {\n\t\treq->ring_ptr++;\n\t}\n\treturn (cont_entry_t *)req->ring_ptr;\n}\n\n \nstatic inline uint32_t qlt_make_handle(struct qla_qpair *qpair)\n{\n\tuint32_t h;\n\tint index;\n\tuint8_t found = 0;\n\tstruct req_que *req = qpair->req;\n\n\th = req->current_outstanding_cmd;\n\n\tfor (index = 1; index < req->num_outstanding_cmds; index++) {\n\t\th++;\n\t\tif (h == req->num_outstanding_cmds)\n\t\t\th = 1;\n\n\t\tif (h == QLA_TGT_SKIP_HANDLE)\n\t\t\tcontinue;\n\n\t\tif (!req->outstanding_cmds[h]) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\treq->current_outstanding_cmd = h;\n\t} else {\n\t\tql_dbg(ql_dbg_io, qpair->vha, 0x305b,\n\t\t    \"qla_target(%d): Ran out of empty cmd slots\\n\",\n\t\t    qpair->vha->vp_idx);\n\t\th = QLA_TGT_NULL_HANDLE;\n\t}\n\n\treturn h;\n}\n\n \nstatic int qlt_24xx_build_ctio_pkt(struct qla_qpair *qpair,\n\tstruct qla_tgt_prm *prm)\n{\n\tuint32_t h;\n\tstruct ctio7_to_24xx *pkt;\n\tstruct atio_from_isp *atio = &prm->cmd->atio;\n\tuint16_t temp;\n\tstruct qla_tgt_cmd      *cmd = prm->cmd;\n\n\tpkt = (struct ctio7_to_24xx *)qpair->req->ring_ptr;\n\tprm->pkt = pkt;\n\tmemset(pkt, 0, sizeof(*pkt));\n\n\tpkt->entry_type = CTIO_TYPE7;\n\tpkt->entry_count = (uint8_t)prm->req_cnt;\n\tpkt->vp_index = prm->cmd->vp_idx;\n\n\th = qlt_make_handle(qpair);\n\tif (unlikely(h == QLA_TGT_NULL_HANDLE)) {\n\t\t \n\t\treturn -EAGAIN;\n\t} else\n\t\tqpair->req->outstanding_cmds[h] = (srb_t *)prm->cmd;\n\n\tpkt->handle = make_handle(qpair->req->id, h);\n\tpkt->handle |= CTIO_COMPLETION_HANDLE_MARK;\n\tpkt->nport_handle = cpu_to_le16(prm->cmd->loop_id);\n\tpkt->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);\n\tpkt->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);\n\tpkt->exchange_addr = atio->u.isp24.exchange_addr;\n\ttemp = atio->u.isp24.attr << 9;\n\tpkt->u.status0.flags |= cpu_to_le16(temp);\n\ttemp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\n\tpkt->u.status0.ox_id = cpu_to_le16(temp);\n\tpkt->u.status0.relative_offset = cpu_to_le32(prm->cmd->offset);\n\n\tif (cmd->edif) {\n\t\tif (cmd->dma_data_direction == DMA_TO_DEVICE)\n\t\t\tprm->cmd->sess->edif.rx_bytes += cmd->bufflen;\n\t\tif (cmd->dma_data_direction == DMA_FROM_DEVICE)\n\t\t\tprm->cmd->sess->edif.tx_bytes += cmd->bufflen;\n\n\t\tpkt->u.status0.edif_flags |= EF_EN_EDIF;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void qlt_load_cont_data_segments(struct qla_tgt_prm *prm)\n{\n\tint cnt;\n\tstruct dsd64 *cur_dsd;\n\n\t \n\twhile (prm->seg_cnt > 0) {\n\t\tcont_a64_entry_t *cont_pkt64 =\n\t\t\t(cont_a64_entry_t *)qlt_get_req_pkt(\n\t\t\t   prm->cmd->qpair->req);\n\n\t\t \n\n\t\tmemset(cont_pkt64, 0, sizeof(*cont_pkt64));\n\n\t\tcont_pkt64->entry_count = 1;\n\t\tcont_pkt64->sys_define = 0;\n\n\t\tcont_pkt64->entry_type = CONTINUE_A64_TYPE;\n\t\tcur_dsd = cont_pkt64->dsd;\n\n\t\t \n\t\tfor (cnt = 0;\n\t\t    cnt < QLA_TGT_DATASEGS_PER_CONT_24XX && prm->seg_cnt;\n\t\t    cnt++, prm->seg_cnt--) {\n\t\t\tappend_dsd64(&cur_dsd, prm->sg);\n\t\t\tprm->sg = sg_next(prm->sg);\n\t\t}\n\t}\n}\n\n \nstatic void qlt_load_data_segments(struct qla_tgt_prm *prm)\n{\n\tint cnt;\n\tstruct dsd64 *cur_dsd;\n\tstruct ctio7_to_24xx *pkt24 = (struct ctio7_to_24xx *)prm->pkt;\n\n\tpkt24->u.status0.transfer_length = cpu_to_le32(prm->cmd->bufflen);\n\n\t \n\tcur_dsd = &pkt24->u.status0.dsd;\n\n\t \n\tif (prm->seg_cnt)\n\t\tpkt24->dseg_count = cpu_to_le16(prm->seg_cnt);\n\n\tif (prm->seg_cnt == 0) {\n\t\t \n\t\tcur_dsd->address = 0;\n\t\tcur_dsd->length = 0;\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tfor (cnt = 0;\n\t    (cnt < QLA_TGT_DATASEGS_PER_CMD_24XX) && prm->seg_cnt;\n\t    cnt++, prm->seg_cnt--) {\n\t\tappend_dsd64(&cur_dsd, prm->sg);\n\t\tprm->sg = sg_next(prm->sg);\n\t}\n\n\tqlt_load_cont_data_segments(prm);\n}\n\nstatic inline int qlt_has_data(struct qla_tgt_cmd *cmd)\n{\n\treturn cmd->bufflen > 0;\n}\n\nstatic void qlt_print_dif_err(struct qla_tgt_prm *prm)\n{\n\tstruct qla_tgt_cmd *cmd;\n\tstruct scsi_qla_host *vha;\n\n\t \n\tif (prm->sense_buffer && (prm->sense_buffer[12] == 0x10)) {\n\t\tcmd = prm->cmd;\n\t\tvha = cmd->vha;\n\t\t \n\t\tswitch (prm->sense_buffer[13]) {\n\t\tcase 1:\n\t\t\tql_dbg(ql_dbg_tgt_dif, vha, 0xe00b,\n\t\t\t    \"BE detected Guard TAG ERR: lba[0x%llx|%lld] len[0x%x] \"\n\t\t\t    \"se_cmd=%p tag[%x]\",\n\t\t\t    cmd->lba, cmd->lba, cmd->num_blks, &cmd->se_cmd,\n\t\t\t    cmd->atio.u.isp24.exchange_addr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tql_dbg(ql_dbg_tgt_dif, vha, 0xe00c,\n\t\t\t    \"BE detected APP TAG ERR: lba[0x%llx|%lld] len[0x%x] \"\n\t\t\t    \"se_cmd=%p tag[%x]\",\n\t\t\t    cmd->lba, cmd->lba, cmd->num_blks, &cmd->se_cmd,\n\t\t\t    cmd->atio.u.isp24.exchange_addr);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tql_dbg(ql_dbg_tgt_dif, vha, 0xe00f,\n\t\t\t    \"BE detected REF TAG ERR: lba[0x%llx|%lld] len[0x%x] \"\n\t\t\t    \"se_cmd=%p tag[%x]\",\n\t\t\t    cmd->lba, cmd->lba, cmd->num_blks, &cmd->se_cmd,\n\t\t\t    cmd->atio.u.isp24.exchange_addr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_dbg(ql_dbg_tgt_dif, vha, 0xe010,\n\t\t\t    \"BE detected Dif ERR: lba[%llx|%lld] len[%x] \"\n\t\t\t    \"se_cmd=%p tag[%x]\",\n\t\t\t    cmd->lba, cmd->lba, cmd->num_blks, &cmd->se_cmd,\n\t\t\t    cmd->atio.u.isp24.exchange_addr);\n\t\t\tbreak;\n\t\t}\n\t\tql_dump_buffer(ql_dbg_tgt_dif, vha, 0xe011, cmd->cdb, 16);\n\t}\n}\n\n \nstatic int qlt_pre_xmit_response(struct qla_tgt_cmd *cmd,\n\tstruct qla_tgt_prm *prm, int xmit_type, uint8_t scsi_status,\n\tuint32_t *full_req_cnt)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct qla_qpair *qpair = cmd->qpair;\n\n\tprm->cmd = cmd;\n\tprm->tgt = cmd->tgt;\n\tprm->pkt = NULL;\n\tprm->rq_result = scsi_status;\n\tprm->sense_buffer = &cmd->sense_buffer[0];\n\tprm->sense_buffer_len = TRANSPORT_SENSE_BUFFER;\n\tprm->sg = NULL;\n\tprm->seg_cnt = -1;\n\tprm->req_cnt = 1;\n\tprm->residual = 0;\n\tprm->add_status_pkt = 0;\n\tprm->prot_sg = NULL;\n\tprm->prot_seg_cnt = 0;\n\tprm->tot_dsds = 0;\n\n\tif ((xmit_type & QLA_TGT_XMIT_DATA) && qlt_has_data(cmd)) {\n\t\tif  (qlt_pci_map_calc_cnt(prm) != 0)\n\t\t\treturn -EAGAIN;\n\t}\n\n\t*full_req_cnt = prm->req_cnt;\n\n\tif (se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\tprm->residual = se_cmd->residual_count;\n\t\tql_dbg_qp(ql_dbg_io + ql_dbg_verbose, qpair, 0x305c,\n\t\t    \"Residual underflow: %d (tag %lld, op %x, bufflen %d, rq_result %x)\\n\",\n\t\t       prm->residual, se_cmd->tag,\n\t\t       se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,\n\t\t       cmd->bufflen, prm->rq_result);\n\t\tprm->rq_result |= SS_RESIDUAL_UNDER;\n\t} else if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\tprm->residual = se_cmd->residual_count;\n\t\tql_dbg_qp(ql_dbg_io, qpair, 0x305d,\n\t\t    \"Residual overflow: %d (tag %lld, op %x, bufflen %d, rq_result %x)\\n\",\n\t\t       prm->residual, se_cmd->tag, se_cmd->t_task_cdb ?\n\t\t       se_cmd->t_task_cdb[0] : 0, cmd->bufflen, prm->rq_result);\n\t\tprm->rq_result |= SS_RESIDUAL_OVER;\n\t}\n\n\tif (xmit_type & QLA_TGT_XMIT_STATUS) {\n\t\t \n\t\tif (qlt_has_data(cmd)) {\n\t\t\tif (QLA_TGT_SENSE_VALID(prm->sense_buffer) ||\n\t\t\t    (IS_FWI2_CAPABLE(cmd->vha->hw) &&\n\t\t\t    (prm->rq_result != 0))) {\n\t\t\t\tprm->add_status_pkt = 1;\n\t\t\t\t(*full_req_cnt)++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int qlt_need_explicit_conf(struct qla_tgt_cmd *cmd,\n    int sending_sense)\n{\n\tif (cmd->qpair->enable_class_2)\n\t\treturn 0;\n\n\tif (sending_sense)\n\t\treturn cmd->conf_compl_supported;\n\telse\n\t\treturn cmd->qpair->enable_explicit_conf &&\n                    cmd->conf_compl_supported;\n}\n\nstatic void qlt_24xx_init_ctio_to_isp(struct ctio7_to_24xx *ctio,\n\tstruct qla_tgt_prm *prm)\n{\n\tprm->sense_buffer_len = min_t(uint32_t, prm->sense_buffer_len,\n\t    (uint32_t)sizeof(ctio->u.status1.sense_data));\n\tctio->u.status0.flags |= cpu_to_le16(CTIO7_FLAGS_SEND_STATUS);\n\tif (qlt_need_explicit_conf(prm->cmd, 0)) {\n\t\tctio->u.status0.flags |= cpu_to_le16(\n\t\t    CTIO7_FLAGS_EXPLICIT_CONFORM |\n\t\t    CTIO7_FLAGS_CONFORM_REQ);\n\t}\n\tctio->u.status0.residual = cpu_to_le32(prm->residual);\n\tctio->u.status0.scsi_status = cpu_to_le16(prm->rq_result);\n\tif (QLA_TGT_SENSE_VALID(prm->sense_buffer)) {\n\t\tint i;\n\n\t\tif (qlt_need_explicit_conf(prm->cmd, 1)) {\n\t\t\tif ((prm->rq_result & SS_SCSI_STATUS_BYTE) != 0) {\n\t\t\t\tql_dbg_qp(ql_dbg_tgt, prm->cmd->qpair, 0xe017,\n\t\t\t\t    \"Skipping EXPLICIT_CONFORM and \"\n\t\t\t\t    \"CTIO7_FLAGS_CONFORM_REQ for FCP READ w/ \"\n\t\t\t\t    \"non GOOD status\\n\");\n\t\t\t\tgoto skip_explict_conf;\n\t\t\t}\n\t\t\tctio->u.status1.flags |= cpu_to_le16(\n\t\t\t    CTIO7_FLAGS_EXPLICIT_CONFORM |\n\t\t\t    CTIO7_FLAGS_CONFORM_REQ);\n\t\t}\nskip_explict_conf:\n\t\tctio->u.status1.flags &=\n\t\t    ~cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_0);\n\t\tctio->u.status1.flags |=\n\t\t    cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1);\n\t\tctio->u.status1.scsi_status |=\n\t\t    cpu_to_le16(SS_SENSE_LEN_VALID);\n\t\tctio->u.status1.sense_length =\n\t\t    cpu_to_le16(prm->sense_buffer_len);\n\t\tfor (i = 0; i < prm->sense_buffer_len/4; i++) {\n\t\t\tuint32_t v;\n\n\t\t\tv = get_unaligned_be32(\n\t\t\t\t\t&((uint32_t *)prm->sense_buffer)[i]);\n\t\t\tput_unaligned_le32(v,\n\t\t\t\t&((uint32_t *)ctio->u.status1.sense_data)[i]);\n\t\t}\n\t\tqlt_print_dif_err(prm);\n\n\t} else {\n\t\tctio->u.status1.flags &=\n\t\t    ~cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_0);\n\t\tctio->u.status1.flags |=\n\t\t    cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1);\n\t\tctio->u.status1.sense_length = 0;\n\t\tmemset(ctio->u.status1.sense_data, 0,\n\t\t    sizeof(ctio->u.status1.sense_data));\n\t}\n\n\t \n}\n\nstatic inline int\nqlt_hba_err_chk_enabled(struct se_cmd *se_cmd)\n{\n\tswitch (se_cmd->prot_op) {\n\tcase TARGET_PROT_DOUT_INSERT:\n\tcase TARGET_PROT_DIN_STRIP:\n\t\tif (ql2xenablehba_err_chk >= 1)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase TARGET_PROT_DOUT_PASS:\n\tcase TARGET_PROT_DIN_PASS:\n\t\tif (ql2xenablehba_err_chk >= 2)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase TARGET_PROT_DIN_INSERT:\n\tcase TARGET_PROT_DOUT_STRIP:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic inline int\nqla_tgt_ref_mask_check(struct se_cmd *se_cmd)\n{\n\tswitch (se_cmd->prot_op) {\n\tcase TARGET_PROT_DIN_INSERT:\n\tcase TARGET_PROT_DOUT_INSERT:\n\tcase TARGET_PROT_DIN_STRIP:\n\tcase TARGET_PROT_DOUT_STRIP:\n\tcase TARGET_PROT_DIN_PASS:\n\tcase TARGET_PROT_DOUT_PASS:\n\t    return 1;\n\tdefault:\n\t    return 0;\n\t}\n\treturn 0;\n}\n\n \nstatic void\nqla_tgt_set_dif_tags(struct qla_tgt_cmd *cmd, struct crc_context *ctx,\n    uint16_t *pfw_prot_opts)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tuint32_t lba = 0xffffffff & se_cmd->t_task_lba;\n\tscsi_qla_host_t *vha = cmd->tgt->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t t32 = 0;\n\n\t \n\tctx->app_tag = 0;\n\tctx->app_tag_mask[0] = 0x0;\n\tctx->app_tag_mask[1] = 0x0;\n\n\tif (IS_PI_UNINIT_CAPABLE(ha)) {\n\t\tif ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||\n\t\t    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))\n\t\t\t*pfw_prot_opts |= PO_DIS_VALD_APP_ESC;\n\t\telse if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)\n\t\t\t*pfw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;\n\t}\n\n\tt32 = ha->tgt.tgt_ops->get_dif_tags(cmd, pfw_prot_opts);\n\n\tswitch (se_cmd->prot_type) {\n\tcase TARGET_DIF_TYPE0_PROT:\n\t\t \n\t\tctx->ref_tag = cpu_to_le32(lba);\n\t\t \n\t\tctx->ref_tag_mask[0] = 0xff;\n\t\tctx->ref_tag_mask[1] = 0xff;\n\t\tctx->ref_tag_mask[2] = 0xff;\n\t\tctx->ref_tag_mask[3] = 0xff;\n\t\tbreak;\n\tcase TARGET_DIF_TYPE1_PROT:\n\t     \n\t    ctx->ref_tag = cpu_to_le32(lba);\n\t    if (!qla_tgt_ref_mask_check(se_cmd) ||\n\t\t!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {\n\t\t    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;\n\t\t    break;\n\t    }\n\t     \n\t    ctx->ref_tag_mask[0] = 0xff;\n\t    ctx->ref_tag_mask[1] = 0xff;\n\t    ctx->ref_tag_mask[2] = 0xff;\n\t    ctx->ref_tag_mask[3] = 0xff;\n\t    break;\n\tcase TARGET_DIF_TYPE2_PROT:\n\t     \n\t    ctx->ref_tag = cpu_to_le32(lba);\n\t    if (!qla_tgt_ref_mask_check(se_cmd) ||\n\t\t!(ha->tgt.tgt_ops->chk_dif_tags(t32))) {\n\t\t    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;\n\t\t    break;\n\t    }\n\t     \n\t    ctx->ref_tag_mask[0] = 0xff;\n\t    ctx->ref_tag_mask[1] = 0xff;\n\t    ctx->ref_tag_mask[2] = 0xff;\n\t    ctx->ref_tag_mask[3] = 0xff;\n\t    break;\n\tcase TARGET_DIF_TYPE3_PROT:\n\t     \n\t    *pfw_prot_opts |= PO_DIS_REF_TAG_VALD;\n\t    ctx->ref_tag_mask[0] = ctx->ref_tag_mask[1] =\n\t\tctx->ref_tag_mask[2] = ctx->ref_tag_mask[3] = 0x00;\n\t    break;\n\t}\n}\n\nstatic inline int\nqlt_build_ctio_crc2_pkt(struct qla_qpair *qpair, struct qla_tgt_prm *prm)\n{\n\tstruct dsd64\t\t*cur_dsd;\n\tuint32_t\t\ttransfer_length = 0;\n\tuint32_t\t\tdata_bytes;\n\tuint32_t\t\tdif_bytes;\n\tuint8_t\t\t\tbundling = 1;\n\tstruct crc_context\t*crc_ctx_pkt = NULL;\n\tstruct qla_hw_data\t*ha;\n\tstruct ctio_crc2_to_fw\t*pkt;\n\tdma_addr_t\t\tcrc_ctx_dma;\n\tuint16_t\t\tfw_prot_opts = 0;\n\tstruct qla_tgt_cmd\t*cmd = prm->cmd;\n\tstruct se_cmd\t\t*se_cmd = &cmd->se_cmd;\n\tuint32_t h;\n\tstruct atio_from_isp *atio = &prm->cmd->atio;\n\tstruct qla_tc_param\ttc;\n\tuint16_t t16;\n\tscsi_qla_host_t *vha = cmd->vha;\n\n\tha = vha->hw;\n\n\tpkt = (struct ctio_crc2_to_fw *)qpair->req->ring_ptr;\n\tprm->pkt = pkt;\n\tmemset(pkt, 0, sizeof(*pkt));\n\n\tql_dbg_qp(ql_dbg_tgt, cmd->qpair, 0xe071,\n\t\t\"qla_target(%d):%s: se_cmd[%p] CRC2 prot_op[0x%x] cmd prot sg:cnt[%p:%x] lba[%llu]\\n\",\n\t\tcmd->vp_idx, __func__, se_cmd, se_cmd->prot_op,\n\t\tprm->prot_sg, prm->prot_seg_cnt, se_cmd->t_task_lba);\n\n\tif ((se_cmd->prot_op == TARGET_PROT_DIN_INSERT) ||\n\t    (se_cmd->prot_op == TARGET_PROT_DOUT_STRIP))\n\t\tbundling = 0;\n\n\t \n\tdata_bytes = cmd->bufflen;\n\tdif_bytes  = (data_bytes / cmd->blk_sz) * 8;\n\n\tswitch (se_cmd->prot_op) {\n\tcase TARGET_PROT_DIN_INSERT:\n\tcase TARGET_PROT_DOUT_STRIP:\n\t\ttransfer_length = data_bytes;\n\t\tif (cmd->prot_sg_cnt)\n\t\t\tdata_bytes += dif_bytes;\n\t\tbreak;\n\tcase TARGET_PROT_DIN_STRIP:\n\tcase TARGET_PROT_DOUT_INSERT:\n\tcase TARGET_PROT_DIN_PASS:\n\tcase TARGET_PROT_DOUT_PASS:\n\t\ttransfer_length = data_bytes + dif_bytes;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (!qlt_hba_err_chk_enabled(se_cmd))\n\t\tfw_prot_opts |= 0x10;  \n\t \n\telse if (IS_PI_UNINIT_CAPABLE(ha)) {\n\t\tif ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||\n\t\t    (se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))\n\t\t\tfw_prot_opts |= PO_DIS_VALD_APP_ESC;\n\t\telse if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)\n\t\t\tfw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;\n\t}\n\n\tswitch (se_cmd->prot_op) {\n\tcase TARGET_PROT_DIN_INSERT:\n\tcase TARGET_PROT_DOUT_INSERT:\n\t\tfw_prot_opts |= PO_MODE_DIF_INSERT;\n\t\tbreak;\n\tcase TARGET_PROT_DIN_STRIP:\n\tcase TARGET_PROT_DOUT_STRIP:\n\t\tfw_prot_opts |= PO_MODE_DIF_REMOVE;\n\t\tbreak;\n\tcase TARGET_PROT_DIN_PASS:\n\tcase TARGET_PROT_DOUT_PASS:\n\t\tfw_prot_opts |= PO_MODE_DIF_PASS;\n\t\t \n\t\tbreak;\n\tdefault: \n\t\tfw_prot_opts |= PO_MODE_DIF_PASS;\n\t\tbreak;\n\t}\n\n\t \n\t \n\tpkt->entry_type  = CTIO_CRC2;\n\tpkt->entry_count = 1;\n\tpkt->vp_index = cmd->vp_idx;\n\n\th = qlt_make_handle(qpair);\n\tif (unlikely(h == QLA_TGT_NULL_HANDLE)) {\n\t\t \n\t\treturn -EAGAIN;\n\t} else\n\t\tqpair->req->outstanding_cmds[h] = (srb_t *)prm->cmd;\n\n\tpkt->handle  = make_handle(qpair->req->id, h);\n\tpkt->handle |= CTIO_COMPLETION_HANDLE_MARK;\n\tpkt->nport_handle = cpu_to_le16(prm->cmd->loop_id);\n\tpkt->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);\n\tpkt->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);\n\tpkt->exchange_addr   = atio->u.isp24.exchange_addr;\n\n\t \n\tt16 = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\n\tpkt->ox_id  = cpu_to_le16(t16);\n\n\tt16 = (atio->u.isp24.attr << 9);\n\tpkt->flags |= cpu_to_le16(t16);\n\tpkt->relative_offset = cpu_to_le32(prm->cmd->offset);\n\n\t \n\tif (cmd->dma_data_direction == DMA_TO_DEVICE)\n\t\tpkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_IN);\n\telse if (cmd->dma_data_direction == DMA_FROM_DEVICE)\n\t\tpkt->flags = cpu_to_le16(CTIO7_FLAGS_DATA_OUT);\n\n\tpkt->dseg_count = cpu_to_le16(prm->tot_dsds);\n\t \n\tpkt->transfer_length = cpu_to_le32(transfer_length);\n\n\t \n\n\t \n\tcrc_ctx_pkt = cmd->ctx =\n\t    dma_pool_zalloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);\n\n\tif (!crc_ctx_pkt)\n\t\tgoto crc_queuing_error;\n\n\tcrc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;\n\tINIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);\n\n\t \n\tcrc_ctx_pkt->handle = pkt->handle;\n\n\tqla_tgt_set_dif_tags(cmd, crc_ctx_pkt, &fw_prot_opts);\n\n\tput_unaligned_le64(crc_ctx_dma, &pkt->crc_context_address);\n\tpkt->crc_context_len = cpu_to_le16(CRC_CONTEXT_LEN_FW);\n\n\tif (!bundling) {\n\t\tcur_dsd = &crc_ctx_pkt->u.nobundling.data_dsd[0];\n\t} else {\n\t\t \n\t\tfw_prot_opts |= PO_ENABLE_DIF_BUNDLING;\n\t\tcrc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);\n\t\tcrc_ctx_pkt->u.bundling.dseg_count =\n\t\t\tcpu_to_le16(prm->tot_dsds - prm->prot_seg_cnt);\n\t\tcur_dsd = &crc_ctx_pkt->u.bundling.data_dsd[0];\n\t}\n\n\t \n\tcrc_ctx_pkt->blk_size   = cpu_to_le16(cmd->blk_sz);\n\tcrc_ctx_pkt->prot_opts  = cpu_to_le16(fw_prot_opts);\n\tcrc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);\n\tcrc_ctx_pkt->guard_seed = cpu_to_le16(0);\n\n\tmemset((uint8_t *)&tc, 0 , sizeof(tc));\n\ttc.vha = vha;\n\ttc.blk_sz = cmd->blk_sz;\n\ttc.bufflen = cmd->bufflen;\n\ttc.sg = cmd->sg;\n\ttc.prot_sg = cmd->prot_sg;\n\ttc.ctx = crc_ctx_pkt;\n\ttc.ctx_dsd_alloced = &cmd->ctx_dsd_alloced;\n\n\t \n\tpkt->flags |= cpu_to_le16(CTIO7_FLAGS_DSD_PTR);\n\n\tif (!bundling && prm->prot_seg_cnt) {\n\t\tif (qla24xx_walk_and_build_sglist_no_difb(ha, NULL, cur_dsd,\n\t\t\tprm->tot_dsds, &tc))\n\t\t\tgoto crc_queuing_error;\n\t} else if (qla24xx_walk_and_build_sglist(ha, NULL, cur_dsd,\n\t\t(prm->tot_dsds - prm->prot_seg_cnt), &tc))\n\t\tgoto crc_queuing_error;\n\n\tif (bundling && prm->prot_seg_cnt) {\n\t\t \n\t\tpkt->add_flags |= CTIO_CRC2_AF_DIF_DSD_ENA;\n\n\t\tcur_dsd = &crc_ctx_pkt->u.bundling.dif_dsd;\n\t\tif (qla24xx_walk_and_build_prot_sglist(ha, NULL, cur_dsd,\n\t\t\tprm->prot_seg_cnt, cmd))\n\t\t\tgoto crc_queuing_error;\n\t}\n\treturn QLA_SUCCESS;\n\ncrc_queuing_error:\n\t \n\tqpair->req->outstanding_cmds[h] = NULL;\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\n \nint qlt_xmit_response(struct qla_tgt_cmd *cmd, int xmit_type,\n\tuint8_t scsi_status)\n{\n\tstruct scsi_qla_host *vha = cmd->vha;\n\tstruct qla_qpair *qpair = cmd->qpair;\n\tstruct ctio7_to_24xx *pkt;\n\tstruct qla_tgt_prm prm;\n\tuint32_t full_req_cnt = 0;\n\tunsigned long flags = 0;\n\tint res;\n\n\tif (!qpair->fw_started || (cmd->reset_count != qpair->chip_reset) ||\n\t    (cmd->sess && cmd->sess->deleted)) {\n\t\tcmd->state = QLA_TGT_STATE_PROCESSED;\n\t\treturn 0;\n\t}\n\n\tql_dbg_qp(ql_dbg_tgt, qpair, 0xe018,\n\t    \"is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, cmd->dma_data_direction=%d se_cmd[%p] qp %d\\n\",\n\t    (xmit_type & QLA_TGT_XMIT_STATUS) ?\n\t    1 : 0, cmd->bufflen, cmd->sg_cnt, cmd->dma_data_direction,\n\t    &cmd->se_cmd, qpair->id);\n\n\tres = qlt_pre_xmit_response(cmd, &prm, xmit_type, scsi_status,\n\t    &full_req_cnt);\n\tif (unlikely(res != 0)) {\n\t\treturn res;\n\t}\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\n\tif (xmit_type == QLA_TGT_XMIT_STATUS)\n\t\tqpair->tgt_counters.core_qla_snd_status++;\n\telse\n\t\tqpair->tgt_counters.core_qla_que_buf++;\n\n\tif (!qpair->fw_started || cmd->reset_count != qpair->chip_reset) {\n\t\t \n\t\tcmd->state = QLA_TGT_STATE_PROCESSED;\n\t\tql_dbg_qp(ql_dbg_async, qpair, 0xe101,\n\t\t\t\"RESET-RSP online/active/old-count/new-count = %d/%d/%d/%d.\\n\",\n\t\t\tvha->flags.online, qla2x00_reset_active(vha),\n\t\t\tcmd->reset_count, qpair->chip_reset);\n\t\tres = 0;\n\t\tgoto out_unmap_unlock;\n\t}\n\n\t \n\tres = qlt_check_reserve_free_req(qpair, full_req_cnt);\n\tif (unlikely(res))\n\t\tgoto out_unmap_unlock;\n\n\tif (cmd->se_cmd.prot_op && (xmit_type & QLA_TGT_XMIT_DATA))\n\t\tres = qlt_build_ctio_crc2_pkt(qpair, &prm);\n\telse\n\t\tres = qlt_24xx_build_ctio_pkt(qpair, &prm);\n\tif (unlikely(res != 0)) {\n\t\tqpair->req->cnt += full_req_cnt;\n\t\tgoto out_unmap_unlock;\n\t}\n\n\tpkt = (struct ctio7_to_24xx *)prm.pkt;\n\n\tif (qlt_has_data(cmd) && (xmit_type & QLA_TGT_XMIT_DATA)) {\n\t\tpkt->u.status0.flags |=\n\t\t    cpu_to_le16(CTIO7_FLAGS_DATA_IN |\n\t\t\tCTIO7_FLAGS_STATUS_MODE_0);\n\n\t\tif (cmd->se_cmd.prot_op == TARGET_PROT_NORMAL)\n\t\t\tqlt_load_data_segments(&prm);\n\n\t\tif (prm.add_status_pkt == 0) {\n\t\t\tif (xmit_type & QLA_TGT_XMIT_STATUS) {\n\t\t\t\tpkt->u.status0.scsi_status =\n\t\t\t\t    cpu_to_le16(prm.rq_result);\n\t\t\t\tif (!cmd->edif)\n\t\t\t\t\tpkt->u.status0.residual =\n\t\t\t\t\t\tcpu_to_le32(prm.residual);\n\n\t\t\t\tpkt->u.status0.flags |= cpu_to_le16(\n\t\t\t\t    CTIO7_FLAGS_SEND_STATUS);\n\t\t\t\tif (qlt_need_explicit_conf(cmd, 0)) {\n\t\t\t\t\tpkt->u.status0.flags |=\n\t\t\t\t\t    cpu_to_le16(\n\t\t\t\t\t\tCTIO7_FLAGS_EXPLICIT_CONFORM |\n\t\t\t\t\t\tCTIO7_FLAGS_CONFORM_REQ);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\t \n\t\t\tstruct ctio7_to_24xx *ctio =\n\t\t\t\t(struct ctio7_to_24xx *)qlt_get_req_pkt(\n\t\t\t\t    qpair->req);\n\n\t\t\tql_dbg_qp(ql_dbg_tgt, qpair, 0x305e,\n\t\t\t    \"Building additional status packet 0x%p.\\n\",\n\t\t\t    ctio);\n\n\t\t\t \n\t\t\tmemcpy(ctio, pkt, sizeof(*ctio));\n\t\t\t \n\t\t\tctio->entry_count = 1;\n\t\t\tctio->entry_type = CTIO_TYPE7;\n\t\t\tctio->dseg_count = 0;\n\t\t\tctio->u.status1.flags &= ~cpu_to_le16(\n\t\t\t    CTIO7_FLAGS_DATA_IN);\n\n\t\t\t \n\t\t\tpkt->handle |= CTIO_INTERMEDIATE_HANDLE_MARK;\n\t\t\tpkt->u.status0.flags |= cpu_to_le16(\n\t\t\t    CTIO7_FLAGS_DONT_RET_CTIO);\n\n\t\t\t \n\t\t\tqlt_24xx_init_ctio_to_isp((struct ctio7_to_24xx *)ctio,\n\t\t\t    &prm);\n\t\t}\n\t} else\n\t\tqlt_24xx_init_ctio_to_isp(pkt, &prm);\n\n\n\tcmd->state = QLA_TGT_STATE_PROCESSED;  \n\tcmd->cmd_sent_to_fw = 1;\n\tcmd->ctio_flags = le16_to_cpu(pkt->u.status0.flags);\n\n\t \n\twmb();\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(vha, qpair->req);\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\treturn 0;\n\nout_unmap_unlock:\n\tqlt_unmap_sg(vha, cmd);\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(qlt_xmit_response);\n\nint qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd)\n{\n\tstruct ctio7_to_24xx *pkt;\n\tstruct scsi_qla_host *vha = cmd->vha;\n\tstruct qla_tgt *tgt = cmd->tgt;\n\tstruct qla_tgt_prm prm;\n\tunsigned long flags = 0;\n\tint res = 0;\n\tstruct qla_qpair *qpair = cmd->qpair;\n\n\tmemset(&prm, 0, sizeof(prm));\n\tprm.cmd = cmd;\n\tprm.tgt = tgt;\n\tprm.sg = NULL;\n\tprm.req_cnt = 1;\n\n\tif (!qpair->fw_started || (cmd->reset_count != qpair->chip_reset) ||\n\t    (cmd->sess && cmd->sess->deleted)) {\n\t\t \n\t\tcmd->aborted = 1;\n\t\tcmd->write_data_transferred = 0;\n\t\tcmd->state = QLA_TGT_STATE_DATA_IN;\n\t\tvha->hw->tgt.tgt_ops->handle_data(cmd);\n\t\tql_dbg_qp(ql_dbg_async, qpair, 0xe102,\n\t\t\t\"RESET-XFR online/active/old-count/new-count = %d/%d/%d/%d.\\n\",\n\t\t\tvha->flags.online, qla2x00_reset_active(vha),\n\t\t\tcmd->reset_count, qpair->chip_reset);\n\t\treturn 0;\n\t}\n\n\t \n\tif (qlt_pci_map_calc_cnt(&prm) != 0)\n\t\treturn -EAGAIN;\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\t \n\tres = qlt_check_reserve_free_req(qpair, prm.req_cnt);\n\tif (res != 0)\n\t\tgoto out_unlock_free_unmap;\n\tif (cmd->se_cmd.prot_op)\n\t\tres = qlt_build_ctio_crc2_pkt(qpair, &prm);\n\telse\n\t\tres = qlt_24xx_build_ctio_pkt(qpair, &prm);\n\n\tif (unlikely(res != 0)) {\n\t\tqpair->req->cnt += prm.req_cnt;\n\t\tgoto out_unlock_free_unmap;\n\t}\n\n\tpkt = (struct ctio7_to_24xx *)prm.pkt;\n\tpkt->u.status0.flags |= cpu_to_le16(CTIO7_FLAGS_DATA_OUT |\n\t    CTIO7_FLAGS_STATUS_MODE_0);\n\n\tif (cmd->se_cmd.prot_op == TARGET_PROT_NORMAL)\n\t\tqlt_load_data_segments(&prm);\n\n\tcmd->state = QLA_TGT_STATE_NEED_DATA;\n\tcmd->cmd_sent_to_fw = 1;\n\tcmd->ctio_flags = le16_to_cpu(pkt->u.status0.flags);\n\n\t \n\twmb();\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(vha, qpair->req);\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\treturn res;\n\nout_unlock_free_unmap:\n\tqlt_unmap_sg(vha, cmd);\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\treturn res;\n}\nEXPORT_SYMBOL(qlt_rdy_to_xfer);\n\n\n \nstatic void\nqlt_handle_dif_error(struct qla_qpair *qpair, struct qla_tgt_cmd *cmd,\n\tstruct ctio_crc_from_fw *sts)\n{\n\tuint8_t\t\t*ap = &sts->actual_dif[0];\n\tuint8_t\t\t*ep = &sts->expected_dif[0];\n\tuint64_t\tlba = cmd->se_cmd.t_task_lba;\n\tuint8_t scsi_status, sense_key, asc, ascq;\n\tunsigned long flags;\n\tstruct scsi_qla_host *vha = cmd->vha;\n\n\tcmd->trc_flags |= TRC_DIF_ERR;\n\n\tcmd->a_guard   = get_unaligned_be16(ap + 0);\n\tcmd->a_app_tag = get_unaligned_be16(ap + 2);\n\tcmd->a_ref_tag = get_unaligned_be32(ap + 4);\n\n\tcmd->e_guard   = get_unaligned_be16(ep + 0);\n\tcmd->e_app_tag = get_unaligned_be16(ep + 2);\n\tcmd->e_ref_tag = get_unaligned_be32(ep + 4);\n\n\tql_dbg(ql_dbg_tgt_dif, vha, 0xf075,\n\t    \"%s: aborted %d state %d\\n\", __func__, cmd->aborted, cmd->state);\n\n\tscsi_status = sense_key = asc = ascq = 0;\n\n\t \n\tif (cmd->e_app_tag != cmd->a_app_tag) {\n\t\tql_dbg(ql_dbg_tgt_dif, vha, 0xe00d,\n\t\t    \"App Tag ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] Ref[%x|%x], App[%x|%x], Guard [%x|%x] cmd=%p ox_id[%04x]\",\n\t\t    cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,\n\t\t    cmd->a_ref_tag, cmd->e_ref_tag, cmd->a_app_tag,\n\t\t    cmd->e_app_tag, cmd->a_guard, cmd->e_guard, cmd,\n\t\t    cmd->atio.u.isp24.fcp_hdr.ox_id);\n\n\t\tcmd->dif_err_code = DIF_ERR_APP;\n\t\tscsi_status = SAM_STAT_CHECK_CONDITION;\n\t\tsense_key = ABORTED_COMMAND;\n\t\tasc = 0x10;\n\t\tascq = 0x2;\n\t}\n\n\t \n\tif (cmd->e_ref_tag != cmd->a_ref_tag) {\n\t\tql_dbg(ql_dbg_tgt_dif, vha, 0xe00e,\n\t\t    \"Ref Tag ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] Ref[%x|%x], App[%x|%x], Guard[%x|%x] cmd=%p ox_id[%04x] \",\n\t\t    cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,\n\t\t    cmd->a_ref_tag, cmd->e_ref_tag, cmd->a_app_tag,\n\t\t    cmd->e_app_tag, cmd->a_guard, cmd->e_guard, cmd,\n\t\t    cmd->atio.u.isp24.fcp_hdr.ox_id);\n\n\t\tcmd->dif_err_code = DIF_ERR_REF;\n\t\tscsi_status = SAM_STAT_CHECK_CONDITION;\n\t\tsense_key = ABORTED_COMMAND;\n\t\tasc = 0x10;\n\t\tascq = 0x3;\n\t\tgoto out;\n\t}\n\n\t \n\tif (cmd->e_guard != cmd->a_guard) {\n\t\tql_dbg(ql_dbg_tgt_dif, vha, 0xe012,\n\t\t    \"Guard ERR: cdb[%x] lba[%llx %llx] blks[%x] [Actual|Expected] Ref[%x|%x], App[%x|%x], Guard [%x|%x] cmd=%p ox_id[%04x]\",\n\t\t    cmd->cdb[0], lba, (lba+cmd->num_blks), cmd->num_blks,\n\t\t    cmd->a_ref_tag, cmd->e_ref_tag, cmd->a_app_tag,\n\t\t    cmd->e_app_tag, cmd->a_guard, cmd->e_guard, cmd,\n\t\t    cmd->atio.u.isp24.fcp_hdr.ox_id);\n\n\t\tcmd->dif_err_code = DIF_ERR_GRD;\n\t\tscsi_status = SAM_STAT_CHECK_CONDITION;\n\t\tsense_key = ABORTED_COMMAND;\n\t\tasc = 0x10;\n\t\tascq = 0x1;\n\t}\nout:\n\tswitch (cmd->state) {\n\tcase QLA_TGT_STATE_NEED_DATA:\n\t\t \n\t\tcmd->state = QLA_TGT_STATE_DATA_IN;\n\t\tvha->hw->tgt.tgt_ops->handle_data(cmd);\n\t\tbreak;\n\tdefault:\n\t\tspin_lock_irqsave(&cmd->cmd_lock, flags);\n\t\tif (cmd->aborted) {\n\t\t\tspin_unlock_irqrestore(&cmd->cmd_lock, flags);\n\t\t\tvha->hw->tgt.tgt_ops->free_cmd(cmd);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&cmd->cmd_lock, flags);\n\n\t\tqlt_send_resp_ctio(qpair, cmd, scsi_status, sense_key, asc,\n\t\t    ascq);\n\t\t \n\t\tvha->hw->tgt.tgt_ops->free_cmd(cmd);\n\t\tbreak;\n\t}\n}\n\n \n \nstatic int __qlt_send_term_imm_notif(struct scsi_qla_host *vha,\n\tstruct imm_ntfy_from_isp *ntfy)\n{\n\tstruct nack_to_isp *nack;\n\tstruct qla_hw_data *ha = vha->hw;\n\trequest_t *pkt;\n\tint ret = 0;\n\n\tql_dbg(ql_dbg_tgt_tmr, vha, 0xe01c,\n\t    \"Sending TERM ELS CTIO (ha=%p)\\n\", ha);\n\n\tpkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);\n\tif (pkt == NULL) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe080,\n\t\t    \"qla_target(%d): %s failed: unable to allocate \"\n\t\t    \"request packet\\n\", vha->vp_idx, __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tpkt->entry_type = NOTIFY_ACK_TYPE;\n\tpkt->entry_count = 1;\n\tpkt->handle = QLA_TGT_SKIP_HANDLE;\n\n\tnack = (struct nack_to_isp *)pkt;\n\tnack->ox_id = ntfy->ox_id;\n\n\tnack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;\n\tif (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {\n\t\tnack->u.isp24.flags = ntfy->u.isp24.flags &\n\t\t\tcpu_to_le16(NOTIFY24XX_FLAGS_PUREX_IOCB);\n\t}\n\n\t \n\tnack->u.isp24.flags |=\n\t\t__constant_cpu_to_le16(NOTIFY_ACK_FLAGS_TERMINATE);\n\n\tnack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;\n\tnack->u.isp24.status = ntfy->u.isp24.status;\n\tnack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;\n\tnack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;\n\tnack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;\n\tnack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;\n\tnack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;\n\tnack->u.isp24.vp_index = ntfy->u.isp24.vp_index;\n\n\tqla2x00_start_iocbs(vha, vha->req);\n\treturn ret;\n}\n\nstatic void qlt_send_term_imm_notif(struct scsi_qla_host *vha,\n\tstruct imm_ntfy_from_isp *imm, int ha_locked)\n{\n\tint rc;\n\n\tWARN_ON_ONCE(!ha_locked);\n\trc = __qlt_send_term_imm_notif(vha, imm);\n\tpr_debug(\"rc = %d\\n\", rc);\n}\n\n \nstatic int __qlt_send_term_exchange(struct qla_qpair *qpair,\n\tstruct qla_tgt_cmd *cmd,\n\tstruct atio_from_isp *atio)\n{\n\tstruct scsi_qla_host *vha = qpair->vha;\n\tstruct ctio7_to_24xx *ctio24;\n\tstruct qla_hw_data *ha = vha->hw;\n\trequest_t *pkt;\n\tint ret = 0;\n\tuint16_t temp;\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe009, \"Sending TERM EXCH CTIO (ha=%p)\\n\", ha);\n\n\tif (cmd)\n\t\tvha = cmd->vha;\n\n\tpkt = (request_t *)qla2x00_alloc_iocbs_ready(qpair, NULL);\n\tif (pkt == NULL) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe050,\n\t\t    \"qla_target(%d): %s failed: unable to allocate \"\n\t\t    \"request packet\\n\", vha->vp_idx, __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (cmd != NULL) {\n\t\tif (cmd->state < QLA_TGT_STATE_PROCESSED) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe051,\n\t\t\t    \"qla_target(%d): Terminating cmd %p with \"\n\t\t\t    \"incorrect state %d\\n\", vha->vp_idx, cmd,\n\t\t\t    cmd->state);\n\t\t} else\n\t\t\tret = 1;\n\t}\n\n\tqpair->tgt_counters.num_term_xchg_sent++;\n\tpkt->entry_count = 1;\n\tpkt->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;\n\n\tctio24 = (struct ctio7_to_24xx *)pkt;\n\tctio24->entry_type = CTIO_TYPE7;\n\tctio24->nport_handle = cpu_to_le16(CTIO7_NHANDLE_UNRECOGNIZED);\n\tctio24->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);\n\tctio24->vp_index = vha->vp_idx;\n\tctio24->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);\n\tctio24->exchange_addr = atio->u.isp24.exchange_addr;\n\ttemp = (atio->u.isp24.attr << 9) | CTIO7_FLAGS_STATUS_MODE_1 |\n\t\tCTIO7_FLAGS_TERMINATE;\n\tctio24->u.status1.flags = cpu_to_le16(temp);\n\ttemp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\n\tctio24->u.status1.ox_id = cpu_to_le16(temp);\n\n\t \n\twmb();\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(vha, qpair->req);\n\treturn ret;\n}\n\nstatic void qlt_send_term_exchange(struct qla_qpair *qpair,\n\tstruct qla_tgt_cmd *cmd, struct atio_from_isp *atio, int ha_locked,\n\tint ul_abort)\n{\n\tstruct scsi_qla_host *vha;\n\tunsigned long flags = 0;\n\tint rc;\n\n\t \n\tif (cmd)\n\t\tvha = cmd->vha;\n\telse\n\t\tvha = qpair->vha;\n\n\tif (ha_locked) {\n\t\trc = __qlt_send_term_exchange(qpair, cmd, atio);\n\t\tif (rc == -ENOMEM)\n\t\t\tqlt_alloc_qfull_cmd(vha, atio, 0, 0);\n\t\tgoto done;\n\t}\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\trc = __qlt_send_term_exchange(qpair, cmd, atio);\n\tif (rc == -ENOMEM)\n\t\tqlt_alloc_qfull_cmd(vha, atio, 0, 0);\n\ndone:\n\tif (cmd && !ul_abort && !cmd->aborted) {\n\t\tif (cmd->sg_mapped)\n\t\t\tqlt_unmap_sg(vha, cmd);\n\t\tvha->hw->tgt.tgt_ops->free_cmd(cmd);\n\t}\n\n\tif (!ha_locked)\n\t\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\treturn;\n}\n\nstatic void qlt_init_term_exchange(struct scsi_qla_host *vha)\n{\n\tstruct list_head free_list;\n\tstruct qla_tgt_cmd *cmd, *tcmd;\n\n\tvha->hw->tgt.leak_exchg_thresh_hold =\n\t    (vha->hw->cur_fw_xcb_count/100) * LEAK_EXCHG_THRESH_HOLD_PERCENT;\n\n\tcmd = tcmd = NULL;\n\tif (!list_empty(&vha->hw->tgt.q_full_list)) {\n\t\tINIT_LIST_HEAD(&free_list);\n\t\tlist_splice_init(&vha->hw->tgt.q_full_list, &free_list);\n\n\t\tlist_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {\n\t\t\tlist_del(&cmd->cmd_list);\n\t\t\t \n\t\t\tqlt_free_cmd(cmd);\n\t\t\tvha->hw->tgt.num_qfull_cmds_alloc--;\n\t\t}\n\t}\n\tvha->hw->tgt.num_qfull_cmds_dropped = 0;\n}\n\nstatic void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)\n{\n\tuint32_t total_leaked;\n\n\ttotal_leaked = vha->hw->tgt.num_qfull_cmds_dropped;\n\n\tif (vha->hw->tgt.leak_exchg_thresh_hold &&\n\t    (total_leaked > vha->hw->tgt.leak_exchg_thresh_hold)) {\n\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe079,\n\t\t    \"Chip reset due to exchange starvation: %d/%d.\\n\",\n\t\t    total_leaked, vha->hw->cur_fw_xcb_count);\n\n\t\tif (IS_P3P_TYPE(vha->hw))\n\t\t\tset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\n\t\telse\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\t}\n\n}\n\nint qlt_abort_cmd(struct qla_tgt_cmd *cmd)\n{\n\tstruct qla_tgt *tgt = cmd->tgt;\n\tstruct scsi_qla_host *vha = tgt->vha;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,\n\t    \"qla_target(%d): terminating exchange for aborted cmd=%p \"\n\t    \"(se_cmd=%p, tag=%llu)\", vha->vp_idx, cmd, &cmd->se_cmd,\n\t    se_cmd->tag);\n\n\tspin_lock_irqsave(&cmd->cmd_lock, flags);\n\tif (cmd->aborted) {\n\t\tif (cmd->sg_mapped)\n\t\t\tqlt_unmap_sg(vha, cmd);\n\n\t\tspin_unlock_irqrestore(&cmd->cmd_lock, flags);\n\t\t \n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf016,\n\t\t    \"multiple abort. %p transport_state %x, t_state %x, \"\n\t\t    \"se_cmd_flags %x\\n\", cmd, cmd->se_cmd.transport_state,\n\t\t    cmd->se_cmd.t_state, cmd->se_cmd.se_cmd_flags);\n\t\treturn -EIO;\n\t}\n\tcmd->aborted = 1;\n\tcmd->trc_flags |= TRC_ABORT;\n\tspin_unlock_irqrestore(&cmd->cmd_lock, flags);\n\n\tqlt_send_term_exchange(cmd->qpair, cmd, &cmd->atio, 0, 1);\n\treturn 0;\n}\nEXPORT_SYMBOL(qlt_abort_cmd);\n\nvoid qlt_free_cmd(struct qla_tgt_cmd *cmd)\n{\n\tstruct fc_port *sess = cmd->sess;\n\n\tql_dbg(ql_dbg_tgt, cmd->vha, 0xe074,\n\t    \"%s: se_cmd[%p] ox_id %04x\\n\",\n\t    __func__, &cmd->se_cmd,\n\t    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));\n\n\tBUG_ON(cmd->cmd_in_wq);\n\n\tif (!cmd->q_full)\n\t\tqlt_decr_num_pend_cmds(cmd->vha);\n\n\tBUG_ON(cmd->sg_mapped);\n\tcmd->jiffies_at_free = get_jiffies_64();\n\n\tif (!sess || !sess->se_sess) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tcmd->jiffies_at_free = get_jiffies_64();\n\tcmd->vha->hw->tgt.tgt_ops->rel_cmd(cmd);\n}\nEXPORT_SYMBOL(qlt_free_cmd);\n\n \nstatic int qlt_term_ctio_exchange(struct qla_qpair *qpair, void *ctio,\n\tstruct qla_tgt_cmd *cmd, uint32_t status)\n{\n\tint term = 0;\n\tstruct scsi_qla_host *vha = qpair->vha;\n\n\tif (cmd->se_cmd.prot_op)\n\t\tql_dbg(ql_dbg_tgt_dif, vha, 0xe013,\n\t\t    \"Term DIF cmd: lba[0x%llx|%lld] len[0x%x] \"\n\t\t    \"se_cmd=%p tag[%x] op %#x/%s\",\n\t\t     cmd->lba, cmd->lba,\n\t\t     cmd->num_blks, &cmd->se_cmd,\n\t\t     cmd->atio.u.isp24.exchange_addr,\n\t\t     cmd->se_cmd.prot_op,\n\t\t     prot_op_str(cmd->se_cmd.prot_op));\n\n\tif (ctio != NULL) {\n\t\tstruct ctio7_from_24xx *c = (struct ctio7_from_24xx *)ctio;\n\n\t\tterm = !(c->flags &\n\t\t    cpu_to_le16(OF_TERM_EXCH));\n\t} else\n\t\tterm = 1;\n\n\tif (term)\n\t\tqlt_send_term_exchange(qpair, cmd, &cmd->atio, 1, 0);\n\n\treturn term;\n}\n\n\n \nstatic void *qlt_ctio_to_cmd(struct scsi_qla_host *vha,\n\tstruct rsp_que *rsp, uint32_t handle, void *ctio)\n{\n\tvoid *cmd = NULL;\n\tstruct req_que *req;\n\tint qid = GET_QID(handle);\n\tuint32_t h = handle & ~QLA_TGT_HANDLE_MASK;\n\n\tif (unlikely(h == QLA_TGT_SKIP_HANDLE))\n\t\treturn NULL;\n\n\tif (qid == rsp->req->id) {\n\t\treq = rsp->req;\n\t} else if (vha->hw->req_q_map[qid]) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0x1000a,\n\t\t    \"qla_target(%d): CTIO completion with different QID %d handle %x\\n\",\n\t\t    vha->vp_idx, rsp->id, handle);\n\t\treq = vha->hw->req_q_map[qid];\n\t} else {\n\t\treturn NULL;\n\t}\n\n\th &= QLA_CMD_HANDLE_MASK;\n\n\tif (h != QLA_TGT_NULL_HANDLE) {\n\t\tif (unlikely(h >= req->num_outstanding_cmds)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe052,\n\t\t\t    \"qla_target(%d): Wrong handle %x received\\n\",\n\t\t\t    vha->vp_idx, handle);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcmd = req->outstanding_cmds[h];\n\t\tif (unlikely(cmd == NULL)) {\n\t\t\tql_dbg(ql_dbg_async, vha, 0xe053,\n\t\t\t    \"qla_target(%d): Suspicious: unable to find the command with handle %x req->id %d rsp->id %d\\n\",\n\t\t\t\tvha->vp_idx, handle, req->id, rsp->id);\n\t\t\treturn NULL;\n\t\t}\n\t\treq->outstanding_cmds[h] = NULL;\n\t} else if (ctio != NULL) {\n\t\t \n\t\tql_dbg(ql_dbg_tgt, vha, 0xe054,\n\t\t    \"qla_target(%d): Wrong CTIO received: QLA24xx doesn't \"\n\t\t    \"support NULL handles\\n\", vha->vp_idx);\n\t\treturn NULL;\n\t}\n\n\treturn cmd;\n}\n\n \nstatic void qlt_do_ctio_completion(struct scsi_qla_host *vha,\n    struct rsp_que *rsp, uint32_t handle, uint32_t status, void *ctio)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct se_cmd *se_cmd;\n\tstruct qla_tgt_cmd *cmd;\n\tstruct qla_qpair *qpair = rsp->qpair;\n\n\tif (handle & CTIO_INTERMEDIATE_HANDLE_MARK) {\n\t\t \n\t\tif (status != CTIO_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf01d,\n\t\t\t    \"Intermediate CTIO received\"\n\t\t\t    \" (status %x)\\n\", status);\n\t\t}\n\t\treturn;\n\t}\n\n\tcmd = qlt_ctio_to_cmd(vha, rsp, handle, ctio);\n\tif (cmd == NULL)\n\t\treturn;\n\n\tif ((le16_to_cpu(((struct ctio7_from_24xx *)ctio)->flags) & CTIO7_FLAGS_DATA_OUT) &&\n\t    cmd->sess) {\n\t\tqlt_chk_edif_rx_sa_delete_pending(vha, cmd->sess,\n\t\t    (struct ctio7_from_24xx *)ctio);\n\t}\n\n\tse_cmd = &cmd->se_cmd;\n\tcmd->cmd_sent_to_fw = 0;\n\n\tqlt_unmap_sg(vha, cmd);\n\n\tif (unlikely(status != CTIO_SUCCESS)) {\n\t\tswitch (status & 0xFFFF) {\n\t\tcase CTIO_INVALID_RX_ID:\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_info(&vha->hw->pdev->dev,\n\t\t\t\t    \"qla_target(%d): CTIO with INVALID_RX_ID ATIO attr %x CTIO Flags %x|%x\\n\",\n\t\t\t\t    vha->vp_idx, cmd->atio.u.isp24.attr,\n\t\t\t\t    ((cmd->ctio_flags >> 9) & 0xf),\n\t\t\t\t    cmd->ctio_flags);\n\n\t\t\tbreak;\n\t\tcase CTIO_LIP_RESET:\n\t\tcase CTIO_TARGET_RESET:\n\t\tcase CTIO_ABORTED:\n\t\t\t \n\t\tcase CTIO_TIMEOUT:\n\t\t\t \n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf058,\n\t\t\t    \"qla_target(%d): CTIO with \"\n\t\t\t    \"status %#x received, state %x, se_cmd %p, \"\n\t\t\t    \"(LIP_RESET=e, ABORTED=2, TARGET_RESET=17, \"\n\t\t\t    \"TIMEOUT=b, INVALID_RX_ID=8)\\n\", vha->vp_idx,\n\t\t\t    status, cmd->state, se_cmd);\n\t\t\tbreak;\n\n\t\tcase CTIO_PORT_LOGGED_OUT:\n\t\tcase CTIO_PORT_UNAVAILABLE:\n\t\t{\n\t\t\tint logged_out =\n\t\t\t\t(status & 0xFFFF) == CTIO_PORT_LOGGED_OUT;\n\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf059,\n\t\t\t    \"qla_target(%d): CTIO with %s status %x \"\n\t\t\t    \"received (state %x, se_cmd %p)\\n\", vha->vp_idx,\n\t\t\t    logged_out ? \"PORT LOGGED OUT\" : \"PORT UNAVAILABLE\",\n\t\t\t    status, cmd->state, se_cmd);\n\n\t\t\tif (logged_out && cmd->sess) {\n\t\t\t\t \n\t\t\t\tcmd->sess->send_els_logo = 1;\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20f8,\n\t\t\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t\t\t    __func__, __LINE__, cmd->sess->port_name);\n\n\t\t\t\tqlt_schedule_sess_for_deletion(cmd->sess);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase CTIO_DIF_ERROR: {\n\t\t\tstruct ctio_crc_from_fw *crc =\n\t\t\t\t(struct ctio_crc_from_fw *)ctio;\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf073,\n\t\t\t    \"qla_target(%d): CTIO with DIF_ERROR status %x \"\n\t\t\t    \"received (state %x, ulp_cmd %p) actual_dif[0x%llx] \"\n\t\t\t    \"expect_dif[0x%llx]\\n\",\n\t\t\t    vha->vp_idx, status, cmd->state, se_cmd,\n\t\t\t    *((u64 *)&crc->actual_dif[0]),\n\t\t\t    *((u64 *)&crc->expected_dif[0]));\n\n\t\t\tqlt_handle_dif_error(qpair, cmd, ctio);\n\t\t\treturn;\n\t\t}\n\n\t\tcase CTIO_FAST_AUTH_ERR:\n\t\tcase CTIO_FAST_INCOMP_PAD_LEN:\n\t\tcase CTIO_FAST_INVALID_REQ:\n\t\tcase CTIO_FAST_SPI_ERR:\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf05b,\n\t\t\t    \"qla_target(%d): CTIO with EDIF error status 0x%x received (state %x, se_cmd %p\\n\",\n\t\t\t    vha->vp_idx, status, cmd->state, se_cmd);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf05b,\n\t\t\t    \"qla_target(%d): CTIO with error status 0x%x received (state %x, se_cmd %p\\n\",\n\t\t\t    vha->vp_idx, status, cmd->state, se_cmd);\n\t\t\tbreak;\n\t\t}\n\n\n\t\t \n\t\tif ((cmd->state != QLA_TGT_STATE_NEED_DATA) &&\n\t\t    (!cmd->aborted)) {\n\t\t\tcmd->trc_flags |= TRC_CTIO_ERR;\n\t\t\tif (qlt_term_ctio_exchange(qpair, ctio, cmd, status))\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\tif (cmd->state == QLA_TGT_STATE_PROCESSED) {\n\t\tcmd->trc_flags |= TRC_CTIO_DONE;\n\t} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {\n\t\tcmd->state = QLA_TGT_STATE_DATA_IN;\n\n\t\tif (status == CTIO_SUCCESS)\n\t\t\tcmd->write_data_transferred = 1;\n\n\t\tha->tgt.tgt_ops->handle_data(cmd);\n\t\treturn;\n\t} else if (cmd->aborted) {\n\t\tcmd->trc_flags |= TRC_CTIO_ABORTED;\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf01e,\n\t\t  \"Aborted command %p (tag %lld) finished\\n\", cmd, se_cmd->tag);\n\t} else {\n\t\tcmd->trc_flags |= TRC_CTIO_STRANGE;\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf05c,\n\t\t    \"qla_target(%d): A command in state (%d) should \"\n\t\t    \"not return a CTIO complete\\n\", vha->vp_idx, cmd->state);\n\t}\n\n\tif (unlikely(status != CTIO_SUCCESS) &&\n\t\t!cmd->aborted) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf01f, \"Finishing failed CTIO\\n\");\n\t\tdump_stack();\n\t}\n\n\tha->tgt.tgt_ops->free_cmd(cmd);\n}\n\nstatic inline int qlt_get_fcp_task_attr(struct scsi_qla_host *vha,\n\tuint8_t task_codes)\n{\n\tint fcp_task_attr;\n\n\tswitch (task_codes) {\n\tcase ATIO_SIMPLE_QUEUE:\n\t\tfcp_task_attr = TCM_SIMPLE_TAG;\n\t\tbreak;\n\tcase ATIO_HEAD_OF_QUEUE:\n\t\tfcp_task_attr = TCM_HEAD_TAG;\n\t\tbreak;\n\tcase ATIO_ORDERED_QUEUE:\n\t\tfcp_task_attr = TCM_ORDERED_TAG;\n\t\tbreak;\n\tcase ATIO_ACA_QUEUE:\n\t\tfcp_task_attr = TCM_ACA_TAG;\n\t\tbreak;\n\tcase ATIO_UNTAGGED:\n\t\tfcp_task_attr = TCM_SIMPLE_TAG;\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf05d,\n\t\t    \"qla_target: unknown task code %x, use ORDERED instead\\n\",\n\t\t    task_codes);\n\t\tfcp_task_attr = TCM_ORDERED_TAG;\n\t\tbreak;\n\t}\n\n\treturn fcp_task_attr;\n}\n\n \nstatic void __qlt_do_work(struct qla_tgt_cmd *cmd)\n{\n\tscsi_qla_host_t *vha = cmd->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess = cmd->sess;\n\tstruct atio_from_isp *atio = &cmd->atio;\n\tunsigned char *cdb;\n\tunsigned long flags;\n\tuint32_t data_length;\n\tint ret, fcp_task_attr, data_dir, bidi = 0;\n\tstruct qla_qpair *qpair = cmd->qpair;\n\n\tcmd->cmd_in_wq = 0;\n\tcmd->trc_flags |= TRC_DO_WORK;\n\n\tif (cmd->aborted) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf082,\n\t\t    \"cmd with tag %u is aborted\\n\",\n\t\t    cmd->atio.u.isp24.exchange_addr);\n\t\tgoto out_term;\n\t}\n\n\tspin_lock_init(&cmd->cmd_lock);\n\tcdb = &atio->u.isp24.fcp_cmnd.cdb[0];\n\tcmd->se_cmd.tag = le32_to_cpu(atio->u.isp24.exchange_addr);\n\n\tif (atio->u.isp24.fcp_cmnd.rddata &&\n\t    atio->u.isp24.fcp_cmnd.wrdata) {\n\t\tbidi = 1;\n\t\tdata_dir = DMA_TO_DEVICE;\n\t} else if (atio->u.isp24.fcp_cmnd.rddata)\n\t\tdata_dir = DMA_FROM_DEVICE;\n\telse if (atio->u.isp24.fcp_cmnd.wrdata)\n\t\tdata_dir = DMA_TO_DEVICE;\n\telse\n\t\tdata_dir = DMA_NONE;\n\n\tfcp_task_attr = qlt_get_fcp_task_attr(vha,\n\t    atio->u.isp24.fcp_cmnd.task_attr);\n\tdata_length = get_datalen_for_atio(atio);\n\n\tret = ha->tgt.tgt_ops->handle_cmd(vha, cmd, cdb, data_length,\n\t\t\t\t          fcp_task_attr, data_dir, bidi);\n\tif (ret != 0)\n\t\tgoto out_term;\n\t \n\tha->tgt.tgt_ops->put_sess(sess);\n\treturn;\n\nout_term:\n\tql_dbg(ql_dbg_io, vha, 0x3060, \"Terminating work cmd %p\", cmd);\n\t \n\tcmd->trc_flags |= TRC_DO_WORK_ERR;\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tqlt_send_term_exchange(qpair, NULL, &cmd->atio, 1, 0);\n\n\tqlt_decr_num_pend_cmds(vha);\n\tcmd->vha->hw->tgt.tgt_ops->rel_cmd(cmd);\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\tha->tgt.tgt_ops->put_sess(sess);\n}\n\nstatic void qlt_do_work(struct work_struct *work)\n{\n\tstruct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);\n\tscsi_qla_host_t *vha = cmd->vha;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vha->cmd_list_lock, flags);\n\tlist_del(&cmd->cmd_list);\n\tspin_unlock_irqrestore(&vha->cmd_list_lock, flags);\n\n\t__qlt_do_work(cmd);\n}\n\nvoid qlt_clr_qp_table(struct scsi_qla_host *vha)\n{\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tvoid *node;\n\tu64 key = 0;\n\n\tql_log(ql_log_info, vha, 0x706c,\n\t    \"User update Number of Active Qpairs %d\\n\",\n\t    ha->tgt.num_act_qpairs);\n\n\tspin_lock_irqsave(&ha->tgt.atio_lock, flags);\n\n\tbtree_for_each_safe64(&tgt->lun_qpair_map, key, node)\n\t\tbtree_remove64(&tgt->lun_qpair_map, key);\n\n\tha->base_qpair->lun_cnt = 0;\n\tfor (key = 0; key < ha->max_qpairs; key++)\n\t\tif (ha->queue_pair_map[key])\n\t\t\tha->queue_pair_map[key]->lun_cnt = 0;\n\n\tspin_unlock_irqrestore(&ha->tgt.atio_lock, flags);\n}\n\nstatic void qlt_assign_qpair(struct scsi_qla_host *vha,\n\tstruct qla_tgt_cmd *cmd)\n{\n\tstruct qla_qpair *qpair, *qp;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tstruct qla_qpair_hint *h;\n\n\tif (vha->flags.qpairs_available) {\n\t\th = btree_lookup64(&tgt->lun_qpair_map, cmd->unpacked_lun);\n\t\tif (unlikely(!h)) {\n\t\t\t \n\t\t\tint lcnt = 0, rc;\n\t\t\tstruct scsi_qla_host *base_vha =\n\t\t\t\tpci_get_drvdata(vha->hw->pdev);\n\n\t\t\tqpair = vha->hw->base_qpair;\n\t\t\tif (qpair->lun_cnt == 0) {\n\t\t\t\tqpair->lun_cnt++;\n\t\t\t\th = qla_qpair_to_hint(tgt, qpair);\n\t\t\t\tBUG_ON(!h);\n\t\t\t\trc = btree_insert64(&tgt->lun_qpair_map,\n\t\t\t\t\tcmd->unpacked_lun, h, GFP_ATOMIC);\n\t\t\t\tif (rc) {\n\t\t\t\t\tqpair->lun_cnt--;\n\t\t\t\t\tql_log(ql_log_info, vha, 0xd037,\n\t\t\t\t\t    \"Unable to insert lun %llx into lun_qpair_map\\n\",\n\t\t\t\t\t    cmd->unpacked_lun);\n\t\t\t\t}\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tlcnt = qpair->lun_cnt;\n\t\t\t}\n\n\t\t\th = NULL;\n\t\t\tlist_for_each_entry(qp, &base_vha->qp_list,\n\t\t\t    qp_list_elem) {\n\t\t\t\tif (qp->lun_cnt == 0) {\n\t\t\t\t\tqp->lun_cnt++;\n\t\t\t\t\th = qla_qpair_to_hint(tgt, qp);\n\t\t\t\t\tBUG_ON(!h);\n\t\t\t\t\trc = btree_insert64(&tgt->lun_qpair_map,\n\t\t\t\t\t    cmd->unpacked_lun, h, GFP_ATOMIC);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tqp->lun_cnt--;\n\t\t\t\t\t\tql_log(ql_log_info, vha, 0xd038,\n\t\t\t\t\t\t\t\"Unable to insert lun %llx into lun_qpair_map\\n\",\n\t\t\t\t\t\t\tcmd->unpacked_lun);\n\t\t\t\t\t}\n\t\t\t\t\tqpair = qp;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\tif (qp->lun_cnt < lcnt) {\n\t\t\t\t\t\tlcnt = qp->lun_cnt;\n\t\t\t\t\t\tqpair = qp;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBUG_ON(!qpair);\n\t\t\tqpair->lun_cnt++;\n\t\t\th = qla_qpair_to_hint(tgt, qpair);\n\t\t\tBUG_ON(!h);\n\t\t\trc = btree_insert64(&tgt->lun_qpair_map,\n\t\t\t\tcmd->unpacked_lun, h, GFP_ATOMIC);\n\t\t\tif (rc) {\n\t\t\t\tqpair->lun_cnt--;\n\t\t\t\tql_log(ql_log_info, vha, 0xd039,\n\t\t\t\t   \"Unable to insert lun %llx into lun_qpair_map\\n\",\n\t\t\t\t   cmd->unpacked_lun);\n\t\t\t}\n\t\t}\n\t} else {\n\t\th = &tgt->qphints[0];\n\t}\nout:\n\tcmd->qpair = h->qpair;\n\tcmd->se_cmd.cpuid = h->cpuid;\n}\n\nstatic struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,\n\t\t\t\t       struct fc_port *sess,\n\t\t\t\t       struct atio_from_isp *atio)\n{\n\tstruct qla_tgt_cmd *cmd;\n\n\tcmd = vha->hw->tgt.tgt_ops->get_cmd(sess);\n\tif (!cmd)\n\t\treturn NULL;\n\n\tcmd->cmd_type = TYPE_TGT_CMD;\n\tmemcpy(&cmd->atio, atio, sizeof(*atio));\n\tINIT_LIST_HEAD(&cmd->sess_cmd_list);\n\tcmd->state = QLA_TGT_STATE_NEW;\n\tcmd->tgt = vha->vha_tgt.qla_tgt;\n\tqlt_incr_num_pend_cmds(vha);\n\tcmd->vha = vha;\n\tcmd->sess = sess;\n\tcmd->loop_id = sess->loop_id;\n\tcmd->conf_compl_supported = sess->conf_compl_supported;\n\n\tcmd->trc_flags = 0;\n\tcmd->jiffies_at_alloc = get_jiffies_64();\n\n\tcmd->unpacked_lun = scsilun_to_int(\n\t    (struct scsi_lun *)&atio->u.isp24.fcp_cmnd.lun);\n\tqlt_assign_qpair(vha, cmd);\n\tcmd->reset_count = vha->hw->base_qpair->chip_reset;\n\tcmd->vp_idx = vha->vp_idx;\n\tcmd->edif = sess->edif.enable;\n\n\treturn cmd;\n}\n\n \nstatic int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha,\n\tstruct atio_from_isp *atio)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tstruct fc_port *sess;\n\tstruct qla_tgt_cmd *cmd;\n\tunsigned long flags;\n\tport_id_t id;\n\n\tif (unlikely(tgt->tgt_stop)) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3061,\n\t\t    \"New command while device %p is shutting down\\n\", tgt);\n\t\treturn -ENODEV;\n\t}\n\n\tid = be_to_port_id(atio->u.isp24.fcp_hdr.s_id);\n\tif (IS_SW_RESV_ADDR(id))\n\t\treturn -EBUSY;\n\n\tsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, atio->u.isp24.fcp_hdr.s_id);\n\tif (unlikely(!sess))\n\t\treturn -EFAULT;\n\n\t \n\tif (sess->deleted) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf002,\n\t\t    \"New command while old session %p is being deleted\\n\",\n\t\t    sess);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (!kref_get_unless_zero(&sess->sess_kref)) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf004,\n\t\t    \"%s: kref_get fail, %8phC oxid %x \\n\",\n\t\t    __func__, sess->port_name,\n\t\t     be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));\n\t\treturn -EFAULT;\n\t}\n\n\tcmd = qlt_get_tag(vha, sess, atio);\n\tif (!cmd) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3062,\n\t\t    \"qla_target(%d): Allocation of cmd failed\\n\", vha->vp_idx);\n\t\tha->tgt.tgt_ops->put_sess(sess);\n\t\treturn -EBUSY;\n\t}\n\n\tcmd->cmd_in_wq = 1;\n\tcmd->trc_flags |= TRC_NEW_CMD;\n\n\tspin_lock_irqsave(&vha->cmd_list_lock, flags);\n\tlist_add_tail(&cmd->cmd_list, &vha->qla_cmd_list);\n\tspin_unlock_irqrestore(&vha->cmd_list_lock, flags);\n\n\tINIT_WORK(&cmd->work, qlt_do_work);\n\tif (vha->flags.qpairs_available) {\n\t\tqueue_work_on(cmd->se_cmd.cpuid, qla_tgt_wq, &cmd->work);\n\t} else if (ha->msix_count) {\n\t\tif (cmd->atio.u.isp24.fcp_cmnd.rddata)\n\t\t\tqueue_work(qla_tgt_wq, &cmd->work);\n\t\telse\n\t\t\tqueue_work_on(cmd->se_cmd.cpuid, qla_tgt_wq,\n\t\t\t    &cmd->work);\n\t} else {\n\t\tqueue_work(qla_tgt_wq, &cmd->work);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int qlt_issue_task_mgmt(struct fc_port *sess, u64 lun,\n\tint fn, void *iocb, int flags)\n{\n\tstruct scsi_qla_host *vha = sess->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt_mgmt_cmd *mcmd;\n\tstruct atio_from_isp *a = (struct atio_from_isp *)iocb;\n\tstruct qla_qpair_hint *h = &vha->vha_tgt.qla_tgt->qphints[0];\n\n\tmcmd = mempool_alloc(qla_tgt_mgmt_cmd_mempool, GFP_ATOMIC);\n\tif (!mcmd) {\n\t\tql_dbg(ql_dbg_tgt_tmr, vha, 0x10009,\n\t\t    \"qla_target(%d): Allocation of management \"\n\t\t    \"command failed, some commands and their data could \"\n\t\t    \"leak\\n\", vha->vp_idx);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(mcmd, 0, sizeof(*mcmd));\n\tmcmd->sess = sess;\n\n\tif (iocb) {\n\t\tmemcpy(&mcmd->orig_iocb.imm_ntfy, iocb,\n\t\t    sizeof(mcmd->orig_iocb.imm_ntfy));\n\t}\n\tmcmd->tmr_func = fn;\n\tmcmd->flags = flags;\n\tmcmd->reset_count = ha->base_qpair->chip_reset;\n\tmcmd->qpair = h->qpair;\n\tmcmd->vha = vha;\n\tmcmd->se_cmd.cpuid = h->cpuid;\n\tmcmd->unpacked_lun = lun;\n\n\tswitch (fn) {\n\tcase QLA_TGT_LUN_RESET:\n\tcase QLA_TGT_CLEAR_TS:\n\tcase QLA_TGT_ABORT_TS:\n\t\tabort_cmds_for_lun(vha, lun, a->u.isp24.fcp_hdr.s_id);\n\t\tfallthrough;\n\tcase QLA_TGT_CLEAR_ACA:\n\t\th = qlt_find_qphint(vha, mcmd->unpacked_lun);\n\t\tmcmd->qpair = h->qpair;\n\t\tmcmd->se_cmd.cpuid = h->cpuid;\n\t\tbreak;\n\n\tcase QLA_TGT_TARGET_RESET:\n\tcase QLA_TGT_NEXUS_LOSS_SESS:\n\tcase QLA_TGT_NEXUS_LOSS:\n\tcase QLA_TGT_ABORT_ALL:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tINIT_WORK(&mcmd->work, qlt_do_tmr_work);\n\tqueue_work_on(mcmd->se_cmd.cpuid, qla_tgt_wq,\n\t    &mcmd->work);\n\n\treturn 0;\n}\n\n \nstatic int qlt_handle_task_mgmt(struct scsi_qla_host *vha, void *iocb)\n{\n\tstruct atio_from_isp *a = (struct atio_from_isp *)iocb;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess;\n\tu64 unpacked_lun;\n\tint fn;\n\tunsigned long flags;\n\n\tfn = a->u.isp24.fcp_cmnd.task_mgmt_flags;\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,\n\t    a->u.isp24.fcp_hdr.s_id);\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\tunpacked_lun =\n\t    scsilun_to_int((struct scsi_lun *)&a->u.isp24.fcp_cmnd.lun);\n\n\tif (sess == NULL || sess->deleted)\n\t\treturn -EFAULT;\n\n\treturn qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);\n}\n\n \nstatic int __qlt_abort_task(struct scsi_qla_host *vha,\n\tstruct imm_ntfy_from_isp *iocb, struct fc_port *sess)\n{\n\tstruct atio_from_isp *a = (struct atio_from_isp *)iocb;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt_mgmt_cmd *mcmd;\n\tu64 unpacked_lun;\n\tint rc;\n\n\tmcmd = mempool_alloc(qla_tgt_mgmt_cmd_mempool, GFP_ATOMIC);\n\tif (mcmd == NULL) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf05f,\n\t\t    \"qla_target(%d): %s: Allocation of ABORT cmd failed\\n\",\n\t\t    vha->vp_idx, __func__);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(mcmd, 0, sizeof(*mcmd));\n\n\tmcmd->sess = sess;\n\tmemcpy(&mcmd->orig_iocb.imm_ntfy, iocb,\n\t    sizeof(mcmd->orig_iocb.imm_ntfy));\n\n\tunpacked_lun =\n\t    scsilun_to_int((struct scsi_lun *)&a->u.isp24.fcp_cmnd.lun);\n\tmcmd->reset_count = ha->base_qpair->chip_reset;\n\tmcmd->tmr_func = QLA_TGT_2G_ABORT_TASK;\n\tmcmd->qpair = ha->base_qpair;\n\n\trc = ha->tgt.tgt_ops->handle_tmr(mcmd, unpacked_lun, mcmd->tmr_func,\n\t    le16_to_cpu(iocb->u.isp2x.seq_id));\n\tif (rc != 0) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf060,\n\t\t    \"qla_target(%d): tgt_ops->handle_tmr() failed: %d\\n\",\n\t\t    vha->vp_idx, rc);\n\t\tmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int qlt_abort_task(struct scsi_qla_host *vha,\n\tstruct imm_ntfy_from_isp *iocb)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess;\n\tint loop_id;\n\tunsigned long flags;\n\n\tloop_id = GET_TARGET_ID(ha, (struct atio_from_isp *)iocb);\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tsess = ha->tgt.tgt_ops->find_sess_by_loop_id(vha, loop_id);\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\tif (sess == NULL) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf025,\n\t\t    \"qla_target(%d): task abort for unexisting \"\n\t\t    \"session\\n\", vha->vp_idx);\n\t\treturn qlt_sched_sess_work(vha->vha_tgt.qla_tgt,\n\t\t    QLA_TGT_SESS_WORK_ABORT, iocb, sizeof(*iocb));\n\t}\n\n\treturn __qlt_abort_task(vha, iocb, sess);\n}\n\nvoid qlt_logo_completion_handler(fc_port_t *fcport, int rc)\n{\n\tif (rc != MBS_COMMAND_COMPLETE) {\n\t\tql_dbg(ql_dbg_tgt_mgt, fcport->vha, 0xf093,\n\t\t\t\"%s: se_sess %p / sess %p from\"\n\t\t\t\" port %8phC loop_id %#04x s_id %02x:%02x:%02x\"\n\t\t\t\" LOGO failed: %#x\\n\",\n\t\t\t__func__,\n\t\t\tfcport->se_sess,\n\t\t\tfcport,\n\t\t\tfcport->port_name, fcport->loop_id,\n\t\t\tfcport->d_id.b.domain, fcport->d_id.b.area,\n\t\t\tfcport->d_id.b.al_pa, rc);\n\t}\n\n\tfcport->logout_completed = 1;\n}\n\n \nstruct fc_port *\nqlt_find_sess_invalidate_other(scsi_qla_host_t *vha, uint64_t wwn,\n    port_id_t port_id, uint16_t loop_id, struct fc_port **conflict_sess)\n{\n\tstruct fc_port *sess = NULL, *other_sess;\n\tuint64_t other_wwn;\n\n\t*conflict_sess = NULL;\n\n\tlist_for_each_entry(other_sess, &vha->vp_fcports, list) {\n\n\t\tother_wwn = wwn_to_u64(other_sess->port_name);\n\n\t\tif (wwn == other_wwn) {\n\t\t\tWARN_ON(sess);\n\t\t\tsess = other_sess;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (port_id.b24 == other_sess->d_id.b24) {\n\t\t\tif (loop_id != other_sess->loop_id) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x1000c,\n\t\t\t\t    \"Invalidating sess %p loop_id %d wwn %llx.\\n\",\n\t\t\t\t    other_sess, other_sess->loop_id, other_wwn);\n\n\t\t\t\t \n\t\t\t\tqlt_schedule_sess_for_deletion(other_sess);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0xf01b,\n\t\t\t\t    \"Invalidating sess %p loop_id %d wwn %llx.\\n\",\n\t\t\t\t    other_sess, other_sess->loop_id, other_wwn);\n\n\t\t\t\tother_sess->keep_nport_handle = 1;\n\t\t\t\tif (other_sess->disc_state != DSC_DELETED)\n\t\t\t\t\t*conflict_sess = other_sess;\n\t\t\t\tqlt_schedule_sess_for_deletion(other_sess);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((loop_id == other_sess->loop_id) &&\n\t\t\t(loop_id != FC_NO_LOOP_ID)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x1000d,\n\t\t\t       \"Invalidating sess %p loop_id %d wwn %llx.\\n\",\n\t\t\t       other_sess, other_sess->loop_id, other_wwn);\n\n\t\t\t \n\t\t\tqlt_schedule_sess_for_deletion(other_sess);\n\t\t}\n\t}\n\n\treturn sess;\n}\n\n \nstatic int abort_cmds_for_s_id(struct scsi_qla_host *vha, port_id_t *s_id)\n{\n\tstruct qla_tgt_sess_op *op;\n\tstruct qla_tgt_cmd *cmd;\n\tuint32_t key;\n\tint count = 0;\n\tunsigned long flags;\n\n\tkey = (((u32)s_id->b.domain << 16) |\n\t       ((u32)s_id->b.area   <<  8) |\n\t       ((u32)s_id->b.al_pa));\n\n\tspin_lock_irqsave(&vha->cmd_list_lock, flags);\n\tlist_for_each_entry(op, &vha->unknown_atio_list, cmd_list) {\n\t\tuint32_t op_key = sid_to_key(op->atio.u.isp24.fcp_hdr.s_id);\n\n\t\tif (op_key == key) {\n\t\t\top->aborted = true;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tlist_for_each_entry(cmd, &vha->qla_cmd_list, cmd_list) {\n\t\tuint32_t cmd_key = sid_to_key(cmd->atio.u.isp24.fcp_hdr.s_id);\n\n\t\tif (cmd_key == key) {\n\t\t\tcmd->aborted = 1;\n\t\t\tcount++;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vha->cmd_list_lock, flags);\n\n\treturn count;\n}\n\nstatic int qlt_handle_login(struct scsi_qla_host *vha,\n    struct imm_ntfy_from_isp *iocb)\n{\n\tstruct fc_port *sess = NULL, *conflict_sess = NULL;\n\tuint64_t wwn;\n\tport_id_t port_id;\n\tuint16_t loop_id, wd3_lo;\n\tint res = 0;\n\tstruct qlt_plogi_ack_t *pla;\n\tunsigned long flags;\n\n\tlockdep_assert_held(&vha->hw->hardware_lock);\n\n\twwn = wwn_to_u64(iocb->u.isp24.port_name);\n\n\tport_id.b.domain = iocb->u.isp24.port_id[2];\n\tport_id.b.area   = iocb->u.isp24.port_id[1];\n\tport_id.b.al_pa  = iocb->u.isp24.port_id[0];\n\tport_id.b.rsvd_1 = 0;\n\n\tloop_id = le16_to_cpu(iocb->u.isp24.nport_handle);\n\n\t \n\tabort_cmds_for_s_id(vha, &port_id);\n\n\tif (wwn) {\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\tsess = qlt_find_sess_invalidate_other(vha, wwn,\n\t\t    port_id, loop_id, &conflict_sess);\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t} else {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t    \"%s %d Term INOT due to WWN=0 lid=%d, NportID %06X \",\n\t\t    __func__, __LINE__, loop_id, port_id.b24);\n\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\tgoto out;\n\t}\n\n\tif (IS_SW_RESV_ADDR(port_id)) {\n\t\tres = 1;\n\t\tgoto out;\n\t}\n\n\tif (vha->hw->flags.edif_enabled &&\n\t    !(vha->e_dbell.db_flags & EDB_ACTIVE) &&\n\t    iocb->u.isp24.status_subcode == ELS_PLOGI &&\n\t    !(le16_to_cpu(iocb->u.isp24.flags) & NOTIFY24XX_FLAGS_FCSP)) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t\"%s %d Term INOT due to app not available lid=%d, NportID %06X \",\n\t\t\t__func__, __LINE__, loop_id, port_id.b24);\n\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\tgoto out;\n\t}\n\n\tif (vha->hw->flags.edif_enabled) {\n\t\tif (DBELL_INACTIVE(vha)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t       \"%s %d Term INOT due to app not started lid=%d, NportID %06X \",\n\t\t\t       __func__, __LINE__, loop_id, port_id.b24);\n\t\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\t\tgoto out;\n\t\t} else if (iocb->u.isp24.status_subcode == ELS_PLOGI &&\n\t\t\t   !(le16_to_cpu(iocb->u.isp24.flags) & NOTIFY24XX_FLAGS_FCSP)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t       \"%s %d Term INOT due to unsecure lid=%d, NportID %06X \",\n\t\t\t       __func__, __LINE__, loop_id, port_id.b24);\n\t\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpla = qlt_plogi_ack_find_add(vha, &port_id, iocb);\n\tif (!pla) {\n\t\tql_dbg(ql_dbg_disc + ql_dbg_verbose, vha, 0xffff,\n\t\t    \"%s %d %8phC Term INOT due to mem alloc fail\",\n\t\t    __func__, __LINE__,\n\t\t    iocb->u.isp24.port_name);\n\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\tgoto out;\n\t}\n\n\tif (conflict_sess) {\n\t\tconflict_sess->login_gen++;\n\t\tqlt_plogi_ack_link(vha, pla, conflict_sess,\n\t\t    QLT_PLOGI_LINK_CONFLICT);\n\t}\n\n\tif (!sess) {\n\t\tpla->ref_count++;\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t    \"%s %d %8phC post new sess\\n\",\n\t\t    __func__, __LINE__, iocb->u.isp24.port_name);\n\t\tif (iocb->u.isp24.status_subcode == ELS_PLOGI)\n\t\t\tqla24xx_post_newsess_work(vha, &port_id,\n\t\t\t    iocb->u.isp24.port_name,\n\t\t\t    iocb->u.isp24.u.plogi.node_name,\n\t\t\t    pla, 0);\n\t\telse\n\t\t\tqla24xx_post_newsess_work(vha, &port_id,\n\t\t\t    iocb->u.isp24.port_name, NULL,\n\t\t\t    pla, 0);\n\n\t\tgoto out;\n\t}\n\n\tif (sess->disc_state == DSC_UPD_FCPORT) {\n\t\tu16 sec;\n\n\t\t \n\t\tsess->next_disc_state = DSC_DELETE_PEND;\n\t\tsec = jiffies_to_msecs(jiffies -\n\t\t    sess->jiffies_at_registration) / 1000;\n\t\tif (sess->sec_since_registration < sec && sec &&\n\t\t    !(sec % 5)) {\n\t\t\tsess->sec_since_registration = sec;\n\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t    \"%s %8phC - Slow Rport registration (%d Sec)\\n\",\n\t\t\t    __func__, sess->port_name, sec);\n\t\t}\n\n\t\tif (!conflict_sess) {\n\t\t\tlist_del(&pla->list);\n\t\t\tkmem_cache_free(qla_tgt_plogi_cachep, pla);\n\t\t}\n\n\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\tgoto out;\n\t}\n\n\tqlt_plogi_ack_link(vha, pla, sess, QLT_PLOGI_LINK_SAME_WWN);\n\tsess->d_id = port_id;\n\tsess->login_gen++;\n\tsess->loop_id = loop_id;\n\n\tif (iocb->u.isp24.status_subcode == ELS_PLOGI) {\n\t\t \n\t\tif (N2N_TOPO(vha->hw) && fcport_is_bigger(sess))\n\t\t\tvha->d_id = sess->d_id;\n\n\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t    \"%s %8phC - send port online\\n\",\n\t\t    __func__, sess->port_name);\n\n\t\tqla2x00_post_aen_work(vha, FCH_EVT_PORT_ONLINE,\n\t\t    sess->d_id.b24);\n\t}\n\n\tif (iocb->u.isp24.status_subcode == ELS_PRLI) {\n\t\tsess->fw_login_state = DSC_LS_PRLI_PEND;\n\t\tsess->local = 0;\n\t\tsess->loop_id = loop_id;\n\t\tsess->d_id = port_id;\n\t\tsess->fw_login_state = DSC_LS_PRLI_PEND;\n\t\twd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);\n\n\t\tif (wd3_lo & BIT_7)\n\t\t\tsess->conf_compl_supported = 1;\n\n\t\tif ((wd3_lo & BIT_4) == 0)\n\t\t\tsess->port_type = FCT_INITIATOR;\n\t\telse\n\t\t\tsess->port_type = FCT_TARGET;\n\n\t} else\n\t\tsess->fw_login_state = DSC_LS_PLOGI_PEND;\n\n\n\tql_dbg(ql_dbg_disc, vha, 0x20f9,\n\t    \"%s %d %8phC  DS %d\\n\",\n\t    __func__, __LINE__, sess->port_name, sess->disc_state);\n\n\tswitch (sess->disc_state) {\n\tcase DSC_DELETED:\n\tcase DSC_LOGIN_PEND:\n\t\tqlt_plogi_ack_unref(vha, pla);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tsess->keep_nport_handle = ((sess->loop_id == loop_id) &&\n\t\t    (sess->d_id.b24 == port_id.b24));\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20f9,\n\t\t    \"%s %d %8phC post del sess\\n\",\n\t\t    __func__, __LINE__, sess->port_name);\n\n\n\t\tqlt_schedule_sess_for_deletion(sess);\n\t\tbreak;\n\t}\nout:\n\treturn res;\n}\n\n \nstatic int qlt_24xx_handle_els(struct scsi_qla_host *vha,\n\tstruct imm_ntfy_from_isp *iocb)\n{\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess = NULL, *conflict_sess = NULL;\n\tuint64_t wwn;\n\tport_id_t port_id;\n\tuint16_t loop_id;\n\tuint16_t wd3_lo;\n\tint res = 0;\n\tunsigned long flags;\n\n\tlockdep_assert_held(&ha->hardware_lock);\n\n\twwn = wwn_to_u64(iocb->u.isp24.port_name);\n\n\tport_id.b.domain = iocb->u.isp24.port_id[2];\n\tport_id.b.area   = iocb->u.isp24.port_id[1];\n\tport_id.b.al_pa  = iocb->u.isp24.port_id[0];\n\tport_id.b.rsvd_1 = 0;\n\n\tloop_id = le16_to_cpu(iocb->u.isp24.nport_handle);\n\n\tql_dbg(ql_dbg_disc, vha, 0xf026,\n\t    \"qla_target(%d): Port ID: %02x:%02x:%02x ELS opcode: 0x%02x lid %d %8phC\\n\",\n\t    vha->vp_idx, iocb->u.isp24.port_id[2],\n\t\tiocb->u.isp24.port_id[1], iocb->u.isp24.port_id[0],\n\t\t   iocb->u.isp24.status_subcode, loop_id,\n\t\tiocb->u.isp24.port_name);\n\n\t \n\tswitch (iocb->u.isp24.status_subcode) {\n\tcase ELS_PLOGI:\n\t\tres = qlt_handle_login(vha, iocb);\n\t\tbreak;\n\n\tcase ELS_PRLI:\n\t\tif (N2N_TOPO(ha)) {\n\t\t\tsess = qla2x00_find_fcport_by_wwpn(vha,\n\t\t\t    iocb->u.isp24.port_name, 1);\n\n\t\t\tif (vha->hw->flags.edif_enabled && sess &&\n\t\t\t    (!(sess->flags & FCF_FCSP_DEVICE) ||\n\t\t\t     !sess->edif.authok)) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t\t       \"%s %d %8phC Term PRLI due to unauthorize PRLI\\n\",\n\t\t\t\t       __func__, __LINE__, iocb->u.isp24.port_name);\n\t\t\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sess && sess->plogi_link[QLT_PLOGI_LINK_SAME_WWN]) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t\t    \"%s %d %8phC Term PRLI due to PLOGI ACK not completed\\n\",\n\t\t\t\t    __func__, __LINE__,\n\t\t\t\t    iocb->u.isp24.port_name);\n\t\t\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tres = qlt_handle_login(vha, iocb);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_SW_RESV_ADDR(port_id)) {\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\twd3_lo = le16_to_cpu(iocb->u.isp24.u.prli.wd3_lo);\n\n\t\tif (wwn) {\n\t\t\tspin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);\n\t\t\tsess = qlt_find_sess_invalidate_other(vha, wwn, port_id,\n\t\t\t\tloop_id, &conflict_sess);\n\t\t\tspin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);\n\t\t}\n\n\t\tif (conflict_sess) {\n\t\t\tswitch (conflict_sess->disc_state) {\n\t\t\tcase DSC_DELETED:\n\t\t\tcase DSC_DELETE_PEND:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf09b,\n\t\t\t\t    \"PRLI with conflicting sess %p port %8phC\\n\",\n\t\t\t\t    conflict_sess, conflict_sess->port_name);\n\t\t\t\tconflict_sess->fw_login_state =\n\t\t\t\t    DSC_LS_PORT_UNAVAIL;\n\t\t\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sess != NULL) {\n\t\t\tbool delete = false;\n\t\t\tint sec;\n\n\t\t\tif (vha->hw->flags.edif_enabled && sess &&\n\t\t\t    (!(sess->flags & FCF_FCSP_DEVICE) ||\n\t\t\t     !sess->edif.authok)) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t\t       \"%s %d %8phC Term PRLI due to unauthorize prli\\n\",\n\t\t\t\t       __func__, __LINE__, iocb->u.isp24.port_name);\n\t\t\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_lock_irqsave(&tgt->ha->tgt.sess_lock, flags);\n\t\t\tswitch (sess->fw_login_state) {\n\t\t\tcase DSC_LS_PLOGI_PEND:\n\t\t\tcase DSC_LS_PLOGI_COMP:\n\t\t\tcase DSC_LS_PRLI_COMP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdelete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (sess->disc_state) {\n\t\t\tcase DSC_UPD_FCPORT:\n\t\t\t\tspin_unlock_irqrestore(&tgt->ha->tgt.sess_lock,\n\t\t\t\t    flags);\n\n\t\t\t\tsec = jiffies_to_msecs(jiffies -\n\t\t\t\t    sess->jiffies_at_registration)/1000;\n\t\t\t\tif (sess->sec_since_registration < sec && sec &&\n\t\t\t\t    !(sec % 5)) {\n\t\t\t\t\tsess->sec_since_registration = sec;\n\t\t\t\t\tql_dbg(ql_dbg_disc, sess->vha, 0xffff,\n\t\t\t\t\t    \"%s %8phC : Slow Rport registration(%d Sec)\\n\",\n\t\t\t\t\t    __func__, sess->port_name, sec);\n\t\t\t\t}\n\t\t\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\t\t\treturn 0;\n\n\t\t\tcase DSC_LOGIN_PEND:\n\t\t\tcase DSC_GPDB:\n\t\t\tcase DSC_LOGIN_COMPLETE:\n\t\t\tcase DSC_ADISC:\n\t\t\t\tdelete = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (delete) {\n\t\t\t\tspin_unlock_irqrestore(&tgt->ha->tgt.sess_lock,\n\t\t\t\t    flags);\n\t\t\t\t \n\t\t\t\tql_log(ql_log_warn, sess->vha, 0xf095,\n\t\t\t\t    \"sess %p PRLI received, before plogi ack.\\n\",\n\t\t\t\t    sess);\n\t\t\t\tqlt_send_term_imm_notif(vha, iocb, 1);\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf096,\n\t\t\t    \"PRLI (loop_id %#04x) for existing sess %p (loop_id %#04x)\\n\",\n\t\t\t    sess->loop_id, sess, iocb->u.isp24.nport_handle);\n\n\t\t\tsess->local = 0;\n\t\t\tsess->loop_id = loop_id;\n\t\t\tsess->d_id = port_id;\n\t\t\tsess->fw_login_state = DSC_LS_PRLI_PEND;\n\n\t\t\tif (wd3_lo & BIT_7)\n\t\t\t\tsess->conf_compl_supported = 1;\n\n\t\t\tif ((wd3_lo & BIT_4) == 0)\n\t\t\t\tsess->port_type = FCT_INITIATOR;\n\t\t\telse\n\t\t\t\tsess->port_type = FCT_TARGET;\n\n\t\t\tspin_unlock_irqrestore(&tgt->ha->tgt.sess_lock, flags);\n\t\t}\n\t\tres = 1;  \n\n\t\t \n\t\tif (ha->current_topology != ISP_CFG_F) {\n\t\t\tif (sess) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20fa,\n\t\t\t\t    \"%s %d %8phC post nack\\n\",\n\t\t\t\t    __func__, __LINE__, sess->port_name);\n\t\t\t\tqla24xx_post_nack_work(vha, sess, iocb,\n\t\t\t\t\tSRB_NACK_PRLI);\n\t\t\t\tres = 0;\n\t\t\t} else {\n\t\t\t\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\t\t\t\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t}\n\t\t} else {\n\t\t\tif (sess) {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20fb,\n\t\t\t\t    \"%s %d %8phC post nack\\n\",\n\t\t\t\t    __func__, __LINE__, sess->port_name);\n\t\t\t\tqla24xx_post_nack_work(vha, sess, iocb,\n\t\t\t\t\tSRB_NACK_PRLI);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ELS_TPRLO:\n\t\tif (le16_to_cpu(iocb->u.isp24.flags) &\n\t\t\tNOTIFY24XX_FLAGS_GLOBAL_TPRLO) {\n\t\t\tloop_id = 0xFFFF;\n\t\t\tqlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS);\n\t\t\tres = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase ELS_LOGO:\n\tcase ELS_PRLO:\n\t\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\t\tsess = qla2x00_find_fcport_by_loopid(vha, loop_id);\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\t\tif (sess) {\n\t\t\tsess->login_gen++;\n\t\t\tsess->fw_login_state = DSC_LS_LOGO_PEND;\n\t\t\tsess->logo_ack_needed = 1;\n\t\t\tmemcpy(sess->iocb, iocb, IOCB_SIZE);\n\t\t}\n\n\t\tres = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);\n\n\t\tql_dbg(ql_dbg_disc, vha, 0x20fc,\n\t\t    \"%s: logo %llx res %d sess %p \",\n\t\t    __func__, wwn, res, sess);\n\t\tif (res == 0) {\n\t\t\t \n\t\t\tBUG_ON(!sess);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t \n\t\t\tif (sess) {\n\t\t\t\tqlt_schedule_sess_for_deletion(sess);\n\t\t\t\tres = 0;\n\t\t\t}\n\t\t\t \n\t\t}\n\t\tbreak;\n\tcase ELS_PDISC:\n\tcase ELS_ADISC:\n\t{\n\t\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\n\t\tif (tgt->link_reinit_iocb_pending) {\n\t\t\tqlt_send_notify_ack(ha->base_qpair,\n\t\t\t    &tgt->link_reinit_iocb, 0, 0, 0, 0, 0, 0);\n\t\t\ttgt->link_reinit_iocb_pending = 0;\n\t\t}\n\n\t\tsess = qla2x00_find_fcport_by_wwpn(vha,\n\t\t    iocb->u.isp24.port_name, 1);\n\t\tif (sess) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x20fd,\n\t\t\t\t\"sess %p lid %d|%d DS %d LS %d\\n\",\n\t\t\t\tsess, sess->loop_id, loop_id,\n\t\t\t\tsess->disc_state, sess->fw_login_state);\n\t\t}\n\n\t\tres = 1;  \n\t\tbreak;\n\t}\n\n\tcase ELS_FLOGI:\t \n\tdefault:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf061,\n\t\t    \"qla_target(%d): Unsupported ELS command %x \"\n\t\t    \"received\\n\", vha->vp_idx, iocb->u.isp24.status_subcode);\n\t\tres = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);\n\t\tbreak;\n\t}\n\n\tql_dbg(ql_dbg_disc, vha, 0xf026,\n\t    \"qla_target(%d): Exit ELS opcode: 0x%02x res %d\\n\",\n\t    vha->vp_idx, iocb->u.isp24.status_subcode, res);\n\n\treturn res;\n}\n\n \nstatic void qlt_handle_imm_notify(struct scsi_qla_host *vha,\n\tstruct imm_ntfy_from_isp *iocb)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t add_flags = 0;\n\tint send_notify_ack = 1;\n\tuint16_t status;\n\n\tlockdep_assert_held(&ha->hardware_lock);\n\n\tstatus = le16_to_cpu(iocb->u.isp2x.status);\n\tswitch (status) {\n\tcase IMM_NTFY_LIP_RESET:\n\t{\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf032,\n\t\t    \"qla_target(%d): LIP reset (loop %#x), subcode %x\\n\",\n\t\t    vha->vp_idx, le16_to_cpu(iocb->u.isp24.nport_handle),\n\t\t    iocb->u.isp24.status_subcode);\n\n\t\tif (qlt_reset(vha, iocb, QLA_TGT_ABORT_ALL) == 0)\n\t\t\tsend_notify_ack = 0;\n\t\tbreak;\n\t}\n\n\tcase IMM_NTFY_LIP_LINK_REINIT:\n\t{\n\t\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf033,\n\t\t    \"qla_target(%d): LINK REINIT (loop %#x, \"\n\t\t    \"subcode %x)\\n\", vha->vp_idx,\n\t\t    le16_to_cpu(iocb->u.isp24.nport_handle),\n\t\t    iocb->u.isp24.status_subcode);\n\t\tif (tgt->link_reinit_iocb_pending) {\n\t\t\tqlt_send_notify_ack(ha->base_qpair,\n\t\t\t    &tgt->link_reinit_iocb, 0, 0, 0, 0, 0, 0);\n\t\t}\n\t\tmemcpy(&tgt->link_reinit_iocb, iocb, sizeof(*iocb));\n\t\ttgt->link_reinit_iocb_pending = 1;\n\t\t \n\t\tsend_notify_ack = 0;\n\t\tbreak;\n\t}\n\n\tcase IMM_NTFY_PORT_LOGOUT:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf034,\n\t\t    \"qla_target(%d): Port logout (loop \"\n\t\t    \"%#x, subcode %x)\\n\", vha->vp_idx,\n\t\t    le16_to_cpu(iocb->u.isp24.nport_handle),\n\t\t    iocb->u.isp24.status_subcode);\n\n\t\tif (qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS) == 0)\n\t\t\tsend_notify_ack = 0;\n\t\t \n\t\tbreak;\n\n\tcase IMM_NTFY_GLBL_TPRLO:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf035,\n\t\t    \"qla_target(%d): Global TPRLO (%x)\\n\", vha->vp_idx, status);\n\t\tif (qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS) == 0)\n\t\t\tsend_notify_ack = 0;\n\t\t \n\t\tbreak;\n\n\tcase IMM_NTFY_PORT_CONFIG:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf036,\n\t\t    \"qla_target(%d): Port config changed (%x)\\n\", vha->vp_idx,\n\t\t    status);\n\t\tif (qlt_reset(vha, iocb, QLA_TGT_ABORT_ALL) == 0)\n\t\t\tsend_notify_ack = 0;\n\t\t \n\t\tbreak;\n\n\tcase IMM_NTFY_GLBL_LOGO:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf06a,\n\t\t    \"qla_target(%d): Link failure detected\\n\",\n\t\t    vha->vp_idx);\n\t\t \n\t\tif (qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS) == 0)\n\t\t\tsend_notify_ack = 0;\n\t\tbreak;\n\n\tcase IMM_NTFY_IOCB_OVERFLOW:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf06b,\n\t\t    \"qla_target(%d): Cannot provide requested \"\n\t\t    \"capability (IOCB overflowed the immediate notify \"\n\t\t    \"resource count)\\n\", vha->vp_idx);\n\t\tbreak;\n\n\tcase IMM_NTFY_ABORT_TASK:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf037,\n\t\t    \"qla_target(%d): Abort Task (S %08x I %#x -> \"\n\t\t    \"L %#x)\\n\", vha->vp_idx,\n\t\t    le16_to_cpu(iocb->u.isp2x.seq_id),\n\t\t    GET_TARGET_ID(ha, (struct atio_from_isp *)iocb),\n\t\t    le16_to_cpu(iocb->u.isp2x.lun));\n\t\tif (qlt_abort_task(vha, iocb) == 0)\n\t\t\tsend_notify_ack = 0;\n\t\tbreak;\n\n\tcase IMM_NTFY_RESOURCE:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf06c,\n\t\t    \"qla_target(%d): Out of resources, host %ld\\n\",\n\t\t    vha->vp_idx, vha->host_no);\n\t\tbreak;\n\n\tcase IMM_NTFY_MSG_RX:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf038,\n\t\t    \"qla_target(%d): Immediate notify task %x\\n\",\n\t\t    vha->vp_idx, iocb->u.isp2x.task_flags);\n\t\tbreak;\n\n\tcase IMM_NTFY_ELS:\n\t\tif (qlt_24xx_handle_els(vha, iocb) == 0)\n\t\t\tsend_notify_ack = 0;\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf06d,\n\t\t    \"qla_target(%d): Received unknown immediate \"\n\t\t    \"notify status %x\\n\", vha->vp_idx, status);\n\t\tbreak;\n\t}\n\n\tif (send_notify_ack)\n\t\tqlt_send_notify_ack(ha->base_qpair, iocb, add_flags, 0, 0, 0,\n\t\t    0, 0);\n}\n\n \nstatic int __qlt_send_busy(struct qla_qpair *qpair,\n\tstruct atio_from_isp *atio, uint16_t status)\n{\n\tstruct scsi_qla_host *vha = qpair->vha;\n\tstruct ctio7_to_24xx *ctio24;\n\tstruct qla_hw_data *ha = vha->hw;\n\trequest_t *pkt;\n\tstruct fc_port *sess = NULL;\n\tunsigned long flags;\n\tu16 temp;\n\tport_id_t id;\n\n\tid = be_to_port_id(atio->u.isp24.fcp_hdr.s_id);\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tsess = qla2x00_find_fcport_by_nportid(vha, &id, 1);\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\tif (!sess) {\n\t\tqlt_send_term_exchange(qpair, NULL, atio, 1, 0);\n\t\treturn 0;\n\t}\n\t \n\n\tpkt = (request_t *)__qla2x00_alloc_iocbs(qpair, NULL);\n\tif (!pkt) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3063,\n\t\t    \"qla_target(%d): %s failed: unable to allocate \"\n\t\t    \"request packet\", vha->vp_idx, __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tqpair->tgt_counters.num_q_full_sent++;\n\tpkt->entry_count = 1;\n\tpkt->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;\n\n\tctio24 = (struct ctio7_to_24xx *)pkt;\n\tctio24->entry_type = CTIO_TYPE7;\n\tctio24->nport_handle = cpu_to_le16(sess->loop_id);\n\tctio24->timeout = cpu_to_le16(QLA_TGT_TIMEOUT);\n\tctio24->vp_index = vha->vp_idx;\n\tctio24->initiator_id = be_id_to_le(atio->u.isp24.fcp_hdr.s_id);\n\tctio24->exchange_addr = atio->u.isp24.exchange_addr;\n\ttemp = (atio->u.isp24.attr << 9) |\n\t\tCTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_SEND_STATUS |\n\t\tCTIO7_FLAGS_DONT_RET_CTIO;\n\tctio24->u.status1.flags = cpu_to_le16(temp);\n\t \n\tctio24->u.status1.ox_id =\n\t\tcpu_to_le16(be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));\n\tctio24->u.status1.scsi_status = cpu_to_le16(status);\n\n\tctio24->u.status1.residual = cpu_to_le32(get_datalen_for_atio(atio));\n\n\tif (ctio24->u.status1.residual != 0)\n\t\tctio24->u.status1.scsi_status |= cpu_to_le16(SS_RESIDUAL_UNDER);\n\n\t \n\twmb();\n\tif (qpair->reqq_start_iocbs)\n\t\tqpair->reqq_start_iocbs(qpair);\n\telse\n\t\tqla2x00_start_iocbs(vha, qpair->req);\n\treturn 0;\n}\n\n \nstatic void\nqlt_alloc_qfull_cmd(struct scsi_qla_host *vha,\n\tstruct atio_from_isp *atio, uint16_t status, int qfull)\n{\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess;\n\tstruct qla_tgt_cmd *cmd;\n\tunsigned long flags;\n\n\tif (unlikely(tgt->tgt_stop)) {\n\t\tql_dbg(ql_dbg_io, vha, 0x300a,\n\t\t\t\"New command while device %p is shutting down\\n\", tgt);\n\t\treturn;\n\t}\n\n\tif ((vha->hw->tgt.num_qfull_cmds_alloc + 1) > MAX_QFULL_CMDS_ALLOC) {\n\t\tvha->hw->tgt.num_qfull_cmds_dropped++;\n\t\tif (vha->hw->tgt.num_qfull_cmds_dropped >\n\t\t\tvha->qla_stats.stat_max_qfull_cmds_dropped)\n\t\t\tvha->qla_stats.stat_max_qfull_cmds_dropped =\n\t\t\t\tvha->hw->tgt.num_qfull_cmds_dropped;\n\n\t\tql_dbg(ql_dbg_io, vha, 0x3068,\n\t\t\t\"qla_target(%d): %s: QFull CMD dropped[%d]\\n\",\n\t\t\tvha->vp_idx, __func__,\n\t\t\tvha->hw->tgt.num_qfull_cmds_dropped);\n\n\t\tqlt_chk_exch_leak_thresh_hold(vha);\n\t\treturn;\n\t}\n\n\tsess = ha->tgt.tgt_ops->find_sess_by_s_id\n\t\t(vha, atio->u.isp24.fcp_hdr.s_id);\n\tif (!sess)\n\t\treturn;\n\n\tcmd = ha->tgt.tgt_ops->get_cmd(sess);\n\tif (!cmd) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3009,\n\t\t\t\"qla_target(%d): %s: Allocation of cmd failed\\n\",\n\t\t\tvha->vp_idx, __func__);\n\n\t\tvha->hw->tgt.num_qfull_cmds_dropped++;\n\t\tif (vha->hw->tgt.num_qfull_cmds_dropped >\n\t\t\tvha->qla_stats.stat_max_qfull_cmds_dropped)\n\t\t\tvha->qla_stats.stat_max_qfull_cmds_dropped =\n\t\t\t\tvha->hw->tgt.num_qfull_cmds_dropped;\n\n\t\tqlt_chk_exch_leak_thresh_hold(vha);\n\t\treturn;\n\t}\n\n\tqlt_incr_num_pend_cmds(vha);\n\tINIT_LIST_HEAD(&cmd->cmd_list);\n\tmemcpy(&cmd->atio, atio, sizeof(*atio));\n\n\tcmd->tgt = vha->vha_tgt.qla_tgt;\n\tcmd->vha = vha;\n\tcmd->reset_count = ha->base_qpair->chip_reset;\n\tcmd->q_full = 1;\n\tcmd->qpair = ha->base_qpair;\n\n\tif (qfull) {\n\t\tcmd->q_full = 1;\n\t\t \n\t\tcmd->state = status;\n\t} else\n\t\tcmd->term_exchg = 1;\n\n\tspin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);\n\tlist_add_tail(&cmd->cmd_list, &vha->hw->tgt.q_full_list);\n\n\tvha->hw->tgt.num_qfull_cmds_alloc++;\n\tif (vha->hw->tgt.num_qfull_cmds_alloc >\n\t\tvha->qla_stats.stat_max_qfull_cmds_alloc)\n\t\tvha->qla_stats.stat_max_qfull_cmds_alloc =\n\t\t\tvha->hw->tgt.num_qfull_cmds_alloc;\n\tspin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);\n}\n\nint\nqlt_free_qfull_cmds(struct qla_qpair *qpair)\n{\n\tstruct scsi_qla_host *vha = qpair->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\tstruct qla_tgt_cmd *cmd, *tcmd;\n\tstruct list_head free_list, q_full_list;\n\tint rc = 0;\n\n\tif (list_empty(&ha->tgt.q_full_list))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&free_list);\n\tINIT_LIST_HEAD(&q_full_list);\n\n\tspin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);\n\tif (list_empty(&ha->tgt.q_full_list)) {\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);\n\t\treturn 0;\n\t}\n\n\tlist_splice_init(&vha->hw->tgt.q_full_list, &q_full_list);\n\tspin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tlist_for_each_entry_safe(cmd, tcmd, &q_full_list, cmd_list) {\n\t\tif (cmd->q_full)\n\t\t\t \n\t\t\trc = __qlt_send_busy(qpair, &cmd->atio, cmd->state);\n\t\telse if (cmd->term_exchg)\n\t\t\trc = __qlt_send_term_exchange(qpair, NULL, &cmd->atio);\n\n\t\tif (rc == -ENOMEM)\n\t\t\tbreak;\n\n\t\tif (cmd->q_full)\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3006,\n\t\t\t    \"%s: busy sent for ox_id[%04x]\\n\", __func__,\n\t\t\t    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));\n\t\telse if (cmd->term_exchg)\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3007,\n\t\t\t    \"%s: Term exchg sent for ox_id[%04x]\\n\", __func__,\n\t\t\t    be16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));\n\t\telse\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3008,\n\t\t\t    \"%s: Unexpected cmd in QFull list %p\\n\", __func__,\n\t\t\t    cmd);\n\n\t\tlist_move_tail(&cmd->cmd_list, &free_list);\n\n\t\t \n\t\tvha->hw->tgt.num_qfull_cmds_alloc--;\n\t}\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\tcmd = NULL;\n\n\tlist_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {\n\t\tlist_del(&cmd->cmd_list);\n\t\t \n\t\tqlt_free_cmd(cmd);\n\t}\n\n\tif (!list_empty(&q_full_list)) {\n\t\tspin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);\n\t\tlist_splice(&q_full_list, &vha->hw->tgt.q_full_list);\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);\n\t}\n\n\treturn rc;\n}\n\nstatic void\nqlt_send_busy(struct qla_qpair *qpair, struct atio_from_isp *atio,\n    uint16_t status)\n{\n\tint rc = 0;\n\tstruct scsi_qla_host *vha = qpair->vha;\n\n\trc = __qlt_send_busy(qpair, atio, status);\n\tif (rc == -ENOMEM)\n\t\tqlt_alloc_qfull_cmd(vha, atio, status, 1);\n}\n\nstatic int\nqlt_chk_qfull_thresh_hold(struct scsi_qla_host *vha, struct qla_qpair *qpair,\n\tstruct atio_from_isp *atio, uint8_t ha_locked)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\n\tif (ha->tgt.num_pend_cmds < Q_FULL_THRESH_HOLD(ha))\n\t\treturn 0;\n\n\tif (!ha_locked)\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqlt_send_busy(qpair, atio, qla_sam_status);\n\tif (!ha_locked)\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn 1;\n}\n\n \n \nstatic void qlt_24xx_atio_pkt(struct scsi_qla_host *vha,\n\tstruct atio_from_isp *atio, uint8_t ha_locked)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tint rc;\n\tunsigned long flags = 0;\n\n\tif (unlikely(tgt == NULL)) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0x3064,\n\t\t    \"ATIO pkt, but no tgt (ha %p)\", ha);\n\t\treturn;\n\t}\n\t \n\n\ttgt->atio_irq_cmd_count++;\n\n\tswitch (atio->u.raw.entry_type) {\n\tcase ATIO_TYPE7:\n\t\tif (unlikely(atio->u.isp24.exchange_addr ==\n\t\t\t     cpu_to_le32(ATIO_EXCHANGE_ADDRESS_UNKNOWN))) {\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3065,\n\t\t\t    \"qla_target(%d): ATIO_TYPE7 \"\n\t\t\t    \"received with UNKNOWN exchange address, \"\n\t\t\t    \"sending QUEUE_FULL\\n\", vha->vp_idx);\n\t\t\tif (!ha_locked)\n\t\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\tqlt_send_busy(ha->base_qpair, atio, qla_sam_status);\n\t\t\tif (!ha_locked)\n\t\t\t\tspin_unlock_irqrestore(&ha->hardware_lock,\n\t\t\t\t    flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (likely(atio->u.isp24.fcp_cmnd.task_mgmt_flags == 0)) {\n\t\t\trc = qlt_chk_qfull_thresh_hold(vha, ha->base_qpair,\n\t\t\t    atio, ha_locked);\n\t\t\tif (rc != 0) {\n\t\t\t\ttgt->atio_irq_cmd_count--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trc = qlt_handle_cmd_for_atio(vha, atio);\n\t\t} else {\n\t\t\trc = qlt_handle_task_mgmt(vha, atio);\n\t\t}\n\t\tif (unlikely(rc != 0)) {\n\t\t\tif (!ha_locked)\n\t\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\tswitch (rc) {\n\t\t\tcase -ENODEV:\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe05f,\n\t\t\t\t    \"qla_target: Unable to send command to target\\n\");\n\t\t\t\tbreak;\n\t\t\tcase -EBADF:\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe05f,\n\t\t\t\t    \"qla_target: Unable to send command to target, sending TERM EXCHANGE for rsp\\n\");\n\t\t\t\tqlt_send_term_exchange(ha->base_qpair, NULL,\n\t\t\t\t    atio, 1, 0);\n\t\t\t\tbreak;\n\t\t\tcase -EBUSY:\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe060,\n\t\t\t\t    \"qla_target(%d): Unable to send command to target, sending BUSY status\\n\",\n\t\t\t\t    vha->vp_idx);\n\t\t\t\tqlt_send_busy(ha->base_qpair, atio,\n\t\t\t\t    tc_sam_status);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe060,\n\t\t\t\t    \"qla_target(%d): Unable to send command to target, sending BUSY status\\n\",\n\t\t\t\t    vha->vp_idx);\n\t\t\t\tqlt_send_busy(ha->base_qpair, atio,\n\t\t\t\t    qla_sam_status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!ha_locked)\n\t\t\t\tspin_unlock_irqrestore(&ha->hardware_lock,\n\t\t\t\t    flags);\n\t\t}\n\t\tbreak;\n\n\tcase IMMED_NOTIFY_TYPE:\n\t{\n\t\tif (unlikely(atio->u.isp2x.entry_status != 0)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe05b,\n\t\t\t    \"qla_target(%d): Received ATIO packet %x \"\n\t\t\t    \"with error status %x\\n\", vha->vp_idx,\n\t\t\t    atio->u.raw.entry_type,\n\t\t\t    atio->u.isp2x.entry_status);\n\t\t\tbreak;\n\t\t}\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe02e, \"%s\", \"IMMED_NOTIFY ATIO\");\n\n\t\tif (!ha_locked)\n\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tqlt_handle_imm_notify(vha, (struct imm_ntfy_from_isp *)atio);\n\t\tif (!ha_locked)\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe05c,\n\t\t    \"qla_target(%d): Received unknown ATIO atio \"\n\t\t    \"type %x\\n\", vha->vp_idx, atio->u.raw.entry_type);\n\t\tbreak;\n\t}\n\n\ttgt->atio_irq_cmd_count--;\n}\n\n \nstatic int qlt_chk_unresolv_exchg(struct scsi_qla_host *vha,\n    struct qla_qpair *qpair, struct abts_resp_from_24xx_fw *entry)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rc = 0;\n\n\t \n\tif (qpair->retry_term_exchg_addr == entry->exchange_addr_to_abort &&\n\t    qpair->retry_term_jiff == jiffies) {\n\t\t \n\t\tqpair->retry_term_cnt++;\n\t\tif (qpair->retry_term_cnt >= 5) {\n\t\t\trc = -EIO;\n\t\t\tqpair->retry_term_cnt = 0;\n\t\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t\t    \"Unable to send ABTS Respond. Dumping firmware.\\n\");\n\t\t\tql_dump_buffer(ql_dbg_tgt_mgt + ql_dbg_buffer,\n\t\t\t    vha, 0xffff, (uint8_t *)entry, sizeof(*entry));\n\n\t\t\tif (qpair == ha->base_qpair)\n\t\t\t\tha->isp_ops->fw_dump(vha);\n\t\t\telse\n\t\t\t\tqla2xxx_dump_fw(vha);\n\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t}\n\t} else if (qpair->retry_term_jiff != jiffies) {\n\t\tqpair->retry_term_exchg_addr = entry->exchange_addr_to_abort;\n\t\tqpair->retry_term_cnt = 0;\n\t\tqpair->retry_term_jiff = jiffies;\n\t}\n\n\treturn rc;\n}\n\n\nstatic void qlt_handle_abts_completion(struct scsi_qla_host *vha,\n\tstruct rsp_que *rsp, response_t *pkt)\n{\n\tstruct abts_resp_from_24xx_fw *entry =\n\t\t(struct abts_resp_from_24xx_fw *)pkt;\n\tu32 h = pkt->handle & ~QLA_TGT_HANDLE_MASK;\n\tstruct qla_tgt_mgmt_cmd *mcmd;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmcmd = qlt_ctio_to_cmd(vha, rsp, pkt->handle, pkt);\n\tif (mcmd == NULL && h != QLA_TGT_SKIP_HANDLE) {\n\t\tql_dbg(ql_dbg_async, vha, 0xe064,\n\t\t    \"qla_target(%d): ABTS Comp without mcmd\\n\",\n\t\t    vha->vp_idx);\n\t\treturn;\n\t}\n\n\tif (mcmd)\n\t\tvha  = mcmd->vha;\n\tvha->vha_tgt.qla_tgt->abts_resp_expected--;\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe038,\n\t    \"ABTS_RESP_24XX: compl_status %x\\n\",\n\t    entry->compl_status);\n\n\tif (le16_to_cpu(entry->compl_status) != ABTS_RESP_COMPL_SUCCESS) {\n\t\tif (le32_to_cpu(entry->error_subcode1) == 0x1E &&\n\t\t    le32_to_cpu(entry->error_subcode2) == 0) {\n\t\t\tif (qlt_chk_unresolv_exchg(vha, rsp->qpair, entry)) {\n\t\t\t\tha->tgt.tgt_ops->free_mcmd(mcmd);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tqlt_24xx_retry_term_exchange(vha, rsp->qpair,\n\t\t\t    pkt, mcmd);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe063,\n\t\t\t    \"qla_target(%d): ABTS_RESP_24XX failed %x (subcode %x:%x)\",\n\t\t\t    vha->vp_idx, entry->compl_status,\n\t\t\t    entry->error_subcode1,\n\t\t\t    entry->error_subcode2);\n\t\t\tha->tgt.tgt_ops->free_mcmd(mcmd);\n\t\t}\n\t} else if (mcmd) {\n\t\tha->tgt.tgt_ops->free_mcmd(mcmd);\n\t}\n}\n\n \n \nstatic void qlt_response_pkt(struct scsi_qla_host *vha,\n\tstruct rsp_que *rsp, response_t *pkt)\n{\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\n\tif (unlikely(tgt == NULL)) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe05d,\n\t\t    \"qla_target(%d): Response pkt %x received, but no tgt (ha %p)\\n\",\n\t\t    vha->vp_idx, pkt->entry_type, vha->hw);\n\t\treturn;\n\t}\n\n\t \n\n\tswitch (pkt->entry_type) {\n\tcase CTIO_CRC2:\n\tcase CTIO_TYPE7:\n\t{\n\t\tstruct ctio7_from_24xx *entry = (struct ctio7_from_24xx *)pkt;\n\n\t\tqlt_do_ctio_completion(vha, rsp, entry->handle,\n\t\t    le16_to_cpu(entry->status)|(pkt->entry_status << 16),\n\t\t    entry);\n\t\tbreak;\n\t}\n\n\tcase ACCEPT_TGT_IO_TYPE:\n\t{\n\t\tstruct atio_from_isp *atio = (struct atio_from_isp *)pkt;\n\t\tint rc;\n\n\t\tif (atio->u.isp2x.status !=\n\t\t    cpu_to_le16(ATIO_CDB_VALID)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe05e,\n\t\t\t    \"qla_target(%d): ATIO with error \"\n\t\t\t    \"status %x received\\n\", vha->vp_idx,\n\t\t\t    le16_to_cpu(atio->u.isp2x.status));\n\t\t\tbreak;\n\t\t}\n\n\t\trc = qlt_chk_qfull_thresh_hold(vha, rsp->qpair, atio, 1);\n\t\tif (rc != 0)\n\t\t\treturn;\n\n\t\trc = qlt_handle_cmd_for_atio(vha, atio);\n\t\tif (unlikely(rc != 0)) {\n\t\t\tswitch (rc) {\n\t\t\tcase -ENODEV:\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe05f,\n\t\t\t\t    \"qla_target: Unable to send command to target\\n\");\n\t\t\t\tbreak;\n\t\t\tcase -EBADF:\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe05f,\n\t\t\t\t    \"qla_target: Unable to send command to target, sending TERM EXCHANGE for rsp\\n\");\n\t\t\t\tqlt_send_term_exchange(rsp->qpair, NULL,\n\t\t\t\t    atio, 1, 0);\n\t\t\t\tbreak;\n\t\t\tcase -EBUSY:\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe060,\n\t\t\t\t    \"qla_target(%d): Unable to send command to target, sending BUSY status\\n\",\n\t\t\t\t    vha->vp_idx);\n\t\t\t\tqlt_send_busy(rsp->qpair, atio,\n\t\t\t\t    tc_sam_status);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe060,\n\t\t\t\t    \"qla_target(%d): Unable to send command to target, sending BUSY status\\n\",\n\t\t\t\t    vha->vp_idx);\n\t\t\t\tqlt_send_busy(rsp->qpair, atio,\n\t\t\t\t    qla_sam_status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tbreak;\n\n\tcase CONTINUE_TGT_IO_TYPE:\n\t{\n\t\tstruct ctio_to_2xxx *entry = (struct ctio_to_2xxx *)pkt;\n\n\t\tqlt_do_ctio_completion(vha, rsp, entry->handle,\n\t\t    le16_to_cpu(entry->status)|(pkt->entry_status << 16),\n\t\t    entry);\n\t\tbreak;\n\t}\n\n\tcase CTIO_A64_TYPE:\n\t{\n\t\tstruct ctio_to_2xxx *entry = (struct ctio_to_2xxx *)pkt;\n\n\t\tqlt_do_ctio_completion(vha, rsp, entry->handle,\n\t\t    le16_to_cpu(entry->status)|(pkt->entry_status << 16),\n\t\t    entry);\n\t\tbreak;\n\t}\n\n\tcase IMMED_NOTIFY_TYPE:\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe035, \"%s\", \"IMMED_NOTIFY\\n\");\n\t\tqlt_handle_imm_notify(vha, (struct imm_ntfy_from_isp *)pkt);\n\t\tbreak;\n\n\tcase NOTIFY_ACK_TYPE:\n\t\tif (tgt->notify_ack_expected > 0) {\n\t\t\tstruct nack_to_isp *entry = (struct nack_to_isp *)pkt;\n\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe036,\n\t\t\t    \"NOTIFY_ACK seq %08x status %x\\n\",\n\t\t\t    le16_to_cpu(entry->u.isp2x.seq_id),\n\t\t\t    le16_to_cpu(entry->u.isp2x.status));\n\t\t\ttgt->notify_ack_expected--;\n\t\t\tif (entry->u.isp2x.status !=\n\t\t\t    cpu_to_le16(NOTIFY_ACK_SUCCESS)) {\n\t\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe061,\n\t\t\t\t    \"qla_target(%d): NOTIFY_ACK \"\n\t\t\t\t    \"failed %x\\n\", vha->vp_idx,\n\t\t\t\t    le16_to_cpu(entry->u.isp2x.status));\n\t\t\t}\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe062,\n\t\t\t    \"qla_target(%d): Unexpected NOTIFY_ACK received\\n\",\n\t\t\t    vha->vp_idx);\n\t\t}\n\t\tbreak;\n\n\tcase ABTS_RECV_24XX:\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe037,\n\t\t    \"ABTS_RECV_24XX: instance %d\\n\", vha->vp_idx);\n\t\tqlt_24xx_handle_abts(vha, (struct abts_recv_from_24xx *)pkt);\n\t\tbreak;\n\n\tcase ABTS_RESP_24XX:\n\t\tif (tgt->abts_resp_expected > 0) {\n\t\t\tqlt_handle_abts_completion(vha, rsp, pkt);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe064,\n\t\t\t    \"qla_target(%d): Unexpected ABTS_RESP_24XX \"\n\t\t\t    \"received\\n\", vha->vp_idx);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe065,\n\t\t    \"qla_target(%d): Received unknown response pkt \"\n\t\t    \"type %x\\n\", vha->vp_idx, pkt->entry_type);\n\t\tbreak;\n\t}\n\n}\n\n \nvoid qlt_async_event(uint16_t code, struct scsi_qla_host *vha,\n\tuint16_t *mailbox)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tint login_code;\n\n\tif (!tgt || tgt->tgt_stop || tgt->tgt_stopped)\n\t\treturn;\n\n\tif (((code == MBA_POINT_TO_POINT) || (code == MBA_CHG_IN_CONNECTION)) &&\n\t    IS_QLA2100(ha))\n\t\treturn;\n\t \n\n\n\tswitch (code) {\n\tcase MBA_RESET:\t\t\t \n\tcase MBA_SYSTEM_ERR:\t\t \n\tcase MBA_REQ_TRANSFER_ERR:\t \n\tcase MBA_RSP_TRANSFER_ERR:\t \n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf03a,\n\t\t    \"qla_target(%d): System error async event %#x \"\n\t\t    \"occurred\", vha->vp_idx, code);\n\t\tbreak;\n\tcase MBA_WAKEUP_THRES:\t\t \n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MBA_LOOP_UP:\n\t{\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf03b,\n\t\t    \"qla_target(%d): Async LOOP_UP occurred \"\n\t\t    \"(m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)\", vha->vp_idx,\n\t\t    mailbox[0], mailbox[1], mailbox[2], mailbox[3]);\n\t\tif (tgt->link_reinit_iocb_pending) {\n\t\t\tqlt_send_notify_ack(ha->base_qpair,\n\t\t\t    &tgt->link_reinit_iocb,\n\t\t\t    0, 0, 0, 0, 0, 0);\n\t\t\ttgt->link_reinit_iocb_pending = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase MBA_LIP_OCCURRED:\n\tcase MBA_LOOP_DOWN:\n\tcase MBA_LIP_RESET:\n\tcase MBA_RSCN_UPDATE:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf03c,\n\t\t    \"qla_target(%d): Async event %#x occurred \"\n\t\t    \"(m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)\", vha->vp_idx, code,\n\t\t    mailbox[0], mailbox[1], mailbox[2], mailbox[3]);\n\t\tbreak;\n\n\tcase MBA_REJECTED_FCP_CMD:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf017,\n\t\t    \"qla_target(%d): Async event LS_REJECT occurred (m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)\",\n\t\t    vha->vp_idx,\n\t\t    mailbox[0], mailbox[1], mailbox[2], mailbox[3]);\n\n\t\tif (mailbox[3] == 1) {\n\t\t\t \n\t\t\tvha->hw->exch_starvation++;\n\t\t\tif (vha->hw->exch_starvation > 5) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xd03a,\n\t\t\t\t    \"Exchange starvation-. Resetting RISC\\n\");\n\n\t\t\t\tvha->hw->exch_starvation = 0;\n\t\t\t\tif (IS_P3P_TYPE(vha->hw))\n\t\t\t\t\tset_bit(FCOE_CTX_RESET_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\telse\n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MBA_PORT_UPDATE:\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf03d,\n\t\t    \"qla_target(%d): Port update async event %#x \"\n\t\t    \"occurred: updating the ports database (m[0]=%x, m[1]=%x, \"\n\t\t    \"m[2]=%x, m[3]=%x)\", vha->vp_idx, code,\n\t\t    mailbox[0], mailbox[1], mailbox[2], mailbox[3]);\n\n\t\tlogin_code = mailbox[2];\n\t\tif (login_code == 0x4) {\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf03e,\n\t\t\t    \"Async MB 2: Got PLOGI Complete\\n\");\n\t\t\tvha->hw->exch_starvation = 0;\n\t\t} else if (login_code == 0x7)\n\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf03f,\n\t\t\t    \"Async MB 2: Port Logged Out\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\nstatic fc_port_t *qlt_get_port_database(struct scsi_qla_host *vha,\n\tuint16_t loop_id)\n{\n\tfc_port_t *fcport, *tfcp, *del;\n\tint rc;\n\tunsigned long flags;\n\tu8 newfcport = 0;\n\n\tfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\tif (!fcport) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf06f,\n\t\t    \"qla_target(%d): Allocation of tmp FC port failed\",\n\t\t    vha->vp_idx);\n\t\treturn NULL;\n\t}\n\n\tfcport->loop_id = loop_id;\n\n\trc = qla24xx_gpdb_wait(vha, fcport, 0);\n\tif (rc != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf070,\n\t\t    \"qla_target(%d): Failed to retrieve fcport \"\n\t\t    \"information -- get_port_database() returned %x \"\n\t\t    \"(loop_id=0x%04x)\", vha->vp_idx, rc, loop_id);\n\t\tkfree(fcport);\n\t\treturn NULL;\n\t}\n\n\tdel = NULL;\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\ttfcp = qla2x00_find_fcport_by_wwpn(vha, fcport->port_name, 1);\n\n\tif (tfcp) {\n\t\ttfcp->d_id = fcport->d_id;\n\t\ttfcp->port_type = fcport->port_type;\n\t\ttfcp->supported_classes = fcport->supported_classes;\n\t\ttfcp->flags |= fcport->flags;\n\t\ttfcp->scan_state = QLA_FCPORT_FOUND;\n\n\t\tdel = fcport;\n\t\tfcport = tfcp;\n\t} else {\n\t\tif (vha->hw->current_topology == ISP_CFG_F)\n\t\t\tfcport->flags |= FCF_FABRIC_DEVICE;\n\n\t\tlist_add_tail(&fcport->list, &vha->vp_fcports);\n\t\tif (!IS_SW_RESV_ADDR(fcport->d_id))\n\t\t   vha->fcport_count++;\n\t\tfcport->login_gen++;\n\t\tqla2x00_set_fcport_disc_state(fcport, DSC_LOGIN_COMPLETE);\n\t\tfcport->login_succ = 1;\n\t\tnewfcport = 1;\n\t}\n\n\tfcport->deleted = 0;\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\tswitch (vha->host->active_mode) {\n\tcase MODE_INITIATOR:\n\tcase MODE_DUAL:\n\t\tif (newfcport) {\n\t\t\tif (!IS_IIDMA_CAPABLE(vha->hw) || !vha->hw->flags.gpsc_supported) {\n\t\t\t\tqla24xx_sched_upd_fcport(fcport);\n\t\t\t} else {\n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x20ff,\n\t\t\t\t   \"%s %d %8phC post gpsc fcp_cnt %d\\n\",\n\t\t\t\t   __func__, __LINE__, fcport->port_name, vha->fcport_count);\n\t\t\t\tqla24xx_post_gpsc_work(vha, fcport);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MODE_TARGET:\n\tdefault:\n\t\tbreak;\n\t}\n\tif (del)\n\t\tqla2x00_free_fcport(del);\n\n\treturn fcport;\n}\n\n \nstatic struct fc_port *qlt_make_local_sess(struct scsi_qla_host *vha,\n\t\t\t\t\t   be_id_t s_id)\n{\n\tstruct fc_port *sess = NULL;\n\tfc_port_t *fcport = NULL;\n\tint rc, global_resets;\n\tuint16_t loop_id = 0;\n\n\tif (s_id.domain == 0xFF && s_id.area == 0xFC) {\n\t\t \n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf042,\n\t\t    \"Unable to find initiator with S_ID %x:%x:%x\",\n\t\t    s_id.domain, s_id.area, s_id.al_pa);\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&vha->vha_tgt.tgt_mutex);\n\nretry:\n\tglobal_resets =\n\t    atomic_read(&vha->vha_tgt.qla_tgt->tgt_global_resets_count);\n\n\trc = qla24xx_get_loop_id(vha, s_id, &loop_id);\n\tif (rc != 0) {\n\t\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\n\t\tql_log(ql_log_info, vha, 0xf071,\n\t\t    \"qla_target(%d): Unable to find \"\n\t\t    \"initiator with S_ID %x:%x:%x\",\n\t\t    vha->vp_idx, s_id.domain, s_id.area, s_id.al_pa);\n\n\t\tif (rc == -ENOENT) {\n\t\t\tqlt_port_logo_t logo;\n\n\t\t\tlogo.id = be_to_port_id(s_id);\n\t\t\tlogo.cmd_count = 1;\n\t\t\tqlt_send_first_logo(vha, &logo);\n\t\t}\n\n\t\treturn NULL;\n\t}\n\n\tfcport = qlt_get_port_database(vha, loop_id);\n\tif (!fcport) {\n\t\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\t\treturn NULL;\n\t}\n\n\tif (global_resets !=\n\t    atomic_read(&vha->vha_tgt.qla_tgt->tgt_global_resets_count)) {\n\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf043,\n\t\t    \"qla_target(%d): global reset during session discovery \"\n\t\t    \"(counter was %d, new %d), retrying\", vha->vp_idx,\n\t\t    global_resets,\n\t\t    atomic_read(&vha->vha_tgt.\n\t\t\tqla_tgt->tgt_global_resets_count));\n\t\tgoto retry;\n\t}\n\n\tsess = qlt_create_sess(vha, fcport, true);\n\n\tmutex_unlock(&vha->vha_tgt.tgt_mutex);\n\n\treturn sess;\n}\n\nstatic void qlt_abort_work(struct qla_tgt *tgt,\n\tstruct qla_tgt_sess_work_param *prm)\n{\n\tstruct scsi_qla_host *vha = tgt->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fc_port *sess = NULL;\n\tunsigned long flags = 0, flags2 = 0;\n\tbe_id_t s_id;\n\tint rc;\n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags2);\n\n\tif (tgt->tgt_stop)\n\t\tgoto out_term2;\n\n\ts_id = le_id_to_be(prm->abts.fcp_hdr_le.s_id);\n\n\tsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, s_id);\n\tif (!sess) {\n\t\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);\n\n\t\tsess = qlt_make_local_sess(vha, s_id);\n\t\t \n\n\t\tspin_lock_irqsave(&ha->tgt.sess_lock, flags2);\n\t\tif (!sess)\n\t\t\tgoto out_term2;\n\t} else {\n\t\tif (sess->deleted) {\n\t\t\tsess = NULL;\n\t\t\tgoto out_term2;\n\t\t}\n\n\t\tif (!kref_get_unless_zero(&sess->sess_kref)) {\n\t\t\tql_dbg(ql_dbg_tgt_tmr, vha, 0xf01c,\n\t\t\t    \"%s: kref_get fail %8phC \\n\",\n\t\t\t     __func__, sess->port_name);\n\t\t\tsess = NULL;\n\t\t\tgoto out_term2;\n\t\t}\n\t}\n\n\trc = __qlt_24xx_handle_abts(vha, &prm->abts, sess);\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);\n\n\tha->tgt.tgt_ops->put_sess(sess);\n\n\tif (rc != 0)\n\t\tgoto out_term;\n\treturn;\n\nout_term2:\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags2);\n\nout_term:\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqlt_24xx_send_abts_resp(ha->base_qpair, &prm->abts,\n\t    FCP_TMF_REJECTED, false);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nstatic void qlt_sess_work_fn(struct work_struct *work)\n{\n\tstruct qla_tgt *tgt = container_of(work, struct qla_tgt, sess_work);\n\tstruct scsi_qla_host *vha = tgt->vha;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf000, \"Sess work (tgt %p)\", tgt);\n\n\tspin_lock_irqsave(&tgt->sess_work_lock, flags);\n\twhile (!list_empty(&tgt->sess_works_list)) {\n\t\tstruct qla_tgt_sess_work_param *prm = list_entry(\n\t\t    tgt->sess_works_list.next, typeof(*prm),\n\t\t    sess_works_list_entry);\n\n\t\t \n\t\tlist_del(&prm->sess_works_list_entry);\n\n\t\tspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\n\n\t\tswitch (prm->type) {\n\t\tcase QLA_TGT_SESS_WORK_ABORT:\n\t\t\tqlt_abort_work(tgt, prm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG_ON(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irqsave(&tgt->sess_work_lock, flags);\n\n\t\tkfree(prm);\n\t}\n\tspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\n}\n\n \nint qlt_add_target(struct qla_hw_data *ha, struct scsi_qla_host *base_vha)\n{\n\tstruct qla_tgt *tgt;\n\tint rc, i;\n\tstruct qla_qpair_hint *h;\n\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn 0;\n\n\tif (!IS_TGT_MODE_CAPABLE(ha)) {\n\t\tql_log(ql_log_warn, base_vha, 0xe070,\n\t\t    \"This adapter does not support target mode.\\n\");\n\t\treturn 0;\n\t}\n\n\tql_dbg(ql_dbg_tgt, base_vha, 0xe03b,\n\t    \"Registering target for host %ld(%p).\\n\", base_vha->host_no, ha);\n\n\tBUG_ON(base_vha->vha_tgt.qla_tgt != NULL);\n\n\ttgt = kzalloc(sizeof(struct qla_tgt), GFP_KERNEL);\n\tif (!tgt) {\n\t\tql_dbg(ql_dbg_tgt, base_vha, 0xe066,\n\t\t    \"Unable to allocate struct qla_tgt\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttgt->qphints = kcalloc(ha->max_qpairs + 1,\n\t\t\t       sizeof(struct qla_qpair_hint),\n\t\t\t       GFP_KERNEL);\n\tif (!tgt->qphints) {\n\t\tkfree(tgt);\n\t\tql_log(ql_log_warn, base_vha, 0x0197,\n\t\t    \"Unable to allocate qpair hints.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tqla2xxx_driver_template.supported_mode |= MODE_TARGET;\n\n\trc = btree_init64(&tgt->lun_qpair_map);\n\tif (rc) {\n\t\tkfree(tgt->qphints);\n\t\tkfree(tgt);\n\t\tql_log(ql_log_info, base_vha, 0x0198,\n\t\t\t\"Unable to initialize lun_qpair_map btree\\n\");\n\t\treturn -EIO;\n\t}\n\th = &tgt->qphints[0];\n\th->qpair = ha->base_qpair;\n\tINIT_LIST_HEAD(&h->hint_elem);\n\th->cpuid = ha->base_qpair->cpuid;\n\tlist_add_tail(&h->hint_elem, &ha->base_qpair->hints_list);\n\n\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\tunsigned long flags;\n\n\t\tstruct qla_qpair *qpair = ha->queue_pair_map[i];\n\n\t\th = &tgt->qphints[i + 1];\n\t\tINIT_LIST_HEAD(&h->hint_elem);\n\t\tif (qpair) {\n\t\t\th->qpair = qpair;\n\t\t\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\t\t\tlist_add_tail(&h->hint_elem, &qpair->hints_list);\n\t\t\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\t\t\th->cpuid = qpair->cpuid;\n\t\t}\n\t}\n\n\ttgt->ha = ha;\n\ttgt->vha = base_vha;\n\tinit_waitqueue_head(&tgt->waitQ);\n\tspin_lock_init(&tgt->sess_work_lock);\n\tINIT_WORK(&tgt->sess_work, qlt_sess_work_fn);\n\tINIT_LIST_HEAD(&tgt->sess_works_list);\n\tatomic_set(&tgt->tgt_global_resets_count, 0);\n\n\tbase_vha->vha_tgt.qla_tgt = tgt;\n\n\tql_dbg(ql_dbg_tgt, base_vha, 0xe067,\n\t\t\"qla_target(%d): using 64 Bit PCI addressing\",\n\t\tbase_vha->vp_idx);\n\t \n\ttgt->sg_tablesize = QLA_TGT_MAX_SG_24XX(base_vha->req->length - 3);\n\n\tmutex_lock(&qla_tgt_mutex);\n\tlist_add_tail(&tgt->tgt_list_entry, &qla_tgt_glist);\n\tmutex_unlock(&qla_tgt_mutex);\n\n\tif (ha->tgt.tgt_ops && ha->tgt.tgt_ops->add_target)\n\t\tha->tgt.tgt_ops->add_target(base_vha);\n\n\treturn 0;\n}\n\n \nint qlt_remove_target(struct qla_hw_data *ha, struct scsi_qla_host *vha)\n{\n\tif (!vha->vha_tgt.qla_tgt)\n\t\treturn 0;\n\n\tif (vha->fc_vport) {\n\t\tqlt_release(vha->vha_tgt.qla_tgt);\n\t\treturn 0;\n\t}\n\n\t \n\tqlt_init_term_exchange(vha);\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe03c, \"Unregistering target for host %ld(%p)\",\n\t    vha->host_no, ha);\n\tqlt_release(vha->vha_tgt.qla_tgt);\n\n\treturn 0;\n}\n\nvoid qla_remove_hostmap(struct qla_hw_data *ha)\n{\n\tstruct scsi_qla_host *node;\n\tu32 key = 0;\n\n\tbtree_for_each_safe32(&ha->host_map, key, node)\n\t\tbtree_remove32(&ha->host_map, key);\n\n\tbtree_destroy32(&ha->host_map);\n}\n\nstatic void qlt_lport_dump(struct scsi_qla_host *vha, u64 wwpn,\n\tunsigned char *b)\n{\n\tpr_debug(\"qla2xxx HW vha->node_name: %8phC\\n\", vha->node_name);\n\tpr_debug(\"qla2xxx HW vha->port_name: %8phC\\n\", vha->port_name);\n\tput_unaligned_be64(wwpn, b);\n\tpr_debug(\"qla2xxx passed configfs WWPN: %8phC\\n\", b);\n}\n\n \nint qlt_lport_register(void *target_lport_ptr, u64 phys_wwpn,\n\t\t       u64 npiv_wwpn, u64 npiv_wwnn,\n\t\t       int (*callback)(struct scsi_qla_host *, void *, u64, u64))\n{\n\tstruct qla_tgt *tgt;\n\tstruct scsi_qla_host *vha;\n\tstruct qla_hw_data *ha;\n\tstruct Scsi_Host *host;\n\tunsigned long flags;\n\tint rc;\n\tu8 b[WWN_SIZE];\n\n\tmutex_lock(&qla_tgt_mutex);\n\tlist_for_each_entry(tgt, &qla_tgt_glist, tgt_list_entry) {\n\t\tvha = tgt->vha;\n\t\tha = vha->hw;\n\n\t\thost = vha->host;\n\t\tif (!host)\n\t\t\tcontinue;\n\n\t\tif (!(host->hostt->supported_mode & MODE_TARGET))\n\t\t\tcontinue;\n\n\t\tif (vha->qlini_mode == QLA2XXX_INI_MODE_ENABLED)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tif ((!npiv_wwpn || !npiv_wwnn) && host->active_mode & MODE_TARGET) {\n\t\t\tpr_debug(\"MODE_TARGET already active on qla2xxx(%d)\\n\",\n\t\t\t    host->host_no);\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tif (tgt->tgt_stop) {\n\t\t\tpr_debug(\"MODE_TARGET in shutdown on qla2xxx(%d)\\n\",\n\t\t\t\t host->host_no);\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tif (!scsi_host_get(host)) {\n\t\t\tql_dbg(ql_dbg_tgt, vha, 0xe068,\n\t\t\t    \"Unable to scsi_host_get() for\"\n\t\t\t    \" qla2xxx scsi_host\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tqlt_lport_dump(vha, phys_wwpn, b);\n\n\t\tif (memcmp(vha->port_name, b, WWN_SIZE)) {\n\t\t\tscsi_host_put(host);\n\t\t\tcontinue;\n\t\t}\n\t\trc = (*callback)(vha, target_lport_ptr, npiv_wwpn, npiv_wwnn);\n\t\tif (rc != 0)\n\t\t\tscsi_host_put(host);\n\n\t\tmutex_unlock(&qla_tgt_mutex);\n\t\treturn rc;\n\t}\n\tmutex_unlock(&qla_tgt_mutex);\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(qlt_lport_register);\n\n \nvoid qlt_lport_deregister(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct Scsi_Host *sh = vha->host;\n\t \n\tvha->vha_tgt.target_lport_ptr = NULL;\n\tha->tgt.tgt_ops = NULL;\n\t \n\tscsi_host_put(sh);\n}\nEXPORT_SYMBOL(qlt_lport_deregister);\n\n \nvoid qlt_set_mode(struct scsi_qla_host *vha)\n{\n\tswitch (vha->qlini_mode) {\n\tcase QLA2XXX_INI_MODE_DISABLED:\n\tcase QLA2XXX_INI_MODE_EXCLUSIVE:\n\t\tvha->host->active_mode = MODE_TARGET;\n\t\tbreak;\n\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\tvha->host->active_mode = MODE_INITIATOR;\n\t\tbreak;\n\tcase QLA2XXX_INI_MODE_DUAL:\n\t\tvha->host->active_mode = MODE_DUAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void qlt_clear_mode(struct scsi_qla_host *vha)\n{\n\tswitch (vha->qlini_mode) {\n\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\tvha->host->active_mode = MODE_UNKNOWN;\n\t\tbreak;\n\tcase QLA2XXX_INI_MODE_EXCLUSIVE:\n\t\tvha->host->active_mode = MODE_INITIATOR;\n\t\tbreak;\n\tcase QLA2XXX_INI_MODE_ENABLED:\n\tcase QLA2XXX_INI_MODE_DUAL:\n\t\tvha->host->active_mode = MODE_INITIATOR;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid\nqlt_enable_vha(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tunsigned long flags;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\tif (!tgt) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe069,\n\t\t    \"Unable to locate qla_tgt pointer from\"\n\t\t    \" struct qla_hw_data\\n\");\n\t\tdump_stack();\n\t\treturn;\n\t}\n\tif (vha->qlini_mode == QLA2XXX_INI_MODE_ENABLED)\n\t\treturn;\n\n\tif (ha->tgt.num_act_qpairs > ha->max_qpairs)\n\t\tha->tgt.num_act_qpairs = ha->max_qpairs;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\ttgt->tgt_stopped = 0;\n\tqlt_set_mode(vha);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tmutex_lock(&ha->optrom_mutex);\n\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf021,\n\t    \"%s.\\n\", __func__);\n\tif (vha->vp_idx) {\n\t\tqla24xx_disable_vp(vha);\n\t\tqla24xx_enable_vp(vha);\n\t} else {\n\t\tset_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(base_vha);\n\t\tWARN_ON_ONCE(qla2x00_wait_for_hba_online(base_vha) !=\n\t\t\t     QLA_SUCCESS);\n\t}\n\tmutex_unlock(&ha->optrom_mutex);\n}\nEXPORT_SYMBOL(qlt_enable_vha);\n\n \nstatic void qlt_disable_vha(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tunsigned long flags;\n\n\tif (!tgt) {\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe06a,\n\t\t    \"Unable to locate qla_tgt pointer from\"\n\t\t    \" struct qla_hw_data\\n\");\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqlt_clear_mode(vha);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\tqla2xxx_wake_dpc(vha);\n\n\t \n\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS)\n\t\tql_dbg(ql_dbg_tgt, vha, 0xe081,\n\t\t       \"adapter is offline\\n\");\n}\n\n \nvoid\nqlt_vport_create(struct scsi_qla_host *vha, struct qla_hw_data *ha)\n{\n\tvha->vha_tgt.qla_tgt = NULL;\n\n\tmutex_init(&vha->vha_tgt.tgt_mutex);\n\tmutex_init(&vha->vha_tgt.tgt_host_action_mutex);\n\n\tINIT_LIST_HEAD(&vha->unknown_atio_list);\n\tINIT_DELAYED_WORK(&vha->unknown_atio_work, qlt_unknown_atio_work_fn);\n\n\tqlt_clear_mode(vha);\n\n\t \n\tha->tgt.atio_q_length = ATIO_ENTRY_CNT_24XX;\n\n\tqlt_add_target(ha, vha);\n}\n\nu8\nqlt_rff_id(struct scsi_qla_host *vha)\n{\n\tu8 fc4_feature = 0;\n\t \n\tif (qla_tgt_mode_enabled(vha)) {\n\t\tfc4_feature = BIT_0;\n\t} else if (qla_ini_mode_enabled(vha)) {\n\t\tfc4_feature = BIT_1;\n\t} else if (qla_dual_mode_enabled(vha))\n\t\tfc4_feature = BIT_0 | BIT_1;\n\n\treturn fc4_feature;\n}\n\n \nvoid\nqlt_init_atio_q_entries(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t cnt;\n\tstruct atio_from_isp *pkt = (struct atio_from_isp *)ha->tgt.atio_ring;\n\n\tif (qla_ini_mode_enabled(vha))\n\t\treturn;\n\n\tfor (cnt = 0; cnt < ha->tgt.atio_q_length; cnt++) {\n\t\tpkt->u.raw.signature = cpu_to_le32(ATIO_PROCESSED);\n\t\tpkt++;\n\t}\n\n}\n\n \nvoid\nqlt_24xx_process_atio_queue(struct scsi_qla_host *vha, uint8_t ha_locked)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct atio_from_isp *pkt;\n\tint cnt, i;\n\n\tif (!ha->flags.fw_started)\n\t\treturn;\n\n\twhile ((ha->tgt.atio_ring_ptr->signature != ATIO_PROCESSED) ||\n\t    fcpcmd_is_corrupted(ha->tgt.atio_ring_ptr)) {\n\t\tpkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;\n\t\tcnt = pkt->u.raw.entry_count;\n\n\t\tif (unlikely(fcpcmd_is_corrupted(ha->tgt.atio_ring_ptr))) {\n\t\t\t \n\t\t\tql_log(ql_log_warn, vha, 0xd03c,\n\t\t\t    \"corrupted fcp frame SID[%3phN] OXID[%04x] EXCG[%x] %64phN\\n\",\n\t\t\t    &pkt->u.isp24.fcp_hdr.s_id,\n\t\t\t    be16_to_cpu(pkt->u.isp24.fcp_hdr.ox_id),\n\t\t\t    pkt->u.isp24.exchange_addr, pkt);\n\n\t\t\tadjust_corrupted_atio(pkt);\n\t\t\tqlt_send_term_exchange(ha->base_qpair, NULL, pkt,\n\t\t\t    ha_locked, 0);\n\t\t} else {\n\t\t\tqlt_24xx_atio_pkt_all_vps(vha,\n\t\t\t    (struct atio_from_isp *)pkt, ha_locked);\n\t\t}\n\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tha->tgt.atio_ring_index++;\n\t\t\tif (ha->tgt.atio_ring_index == ha->tgt.atio_q_length) {\n\t\t\t\tha->tgt.atio_ring_index = 0;\n\t\t\t\tha->tgt.atio_ring_ptr = ha->tgt.atio_ring;\n\t\t\t} else\n\t\t\t\tha->tgt.atio_ring_ptr++;\n\n\t\t\tpkt->u.raw.signature = cpu_to_le32(ATIO_PROCESSED);\n\t\t\tpkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;\n\t\t}\n\t\twmb();\n\t}\n\n\t \n\twrt_reg_dword(ISP_ATIO_Q_OUT(vha), ha->tgt.atio_ring_index);\n}\n\nvoid\nqlt_24xx_config_rings(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_msix_entry *msix = &ha->msix_entries[2];\n\tstruct init_cb_24xx *icb = (struct init_cb_24xx *)ha->init_cb;\n\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\twrt_reg_dword(ISP_ATIO_Q_IN(vha), 0);\n\twrt_reg_dword(ISP_ATIO_Q_OUT(vha), 0);\n\trd_reg_dword(ISP_ATIO_Q_OUT(vha));\n\n\tif (ha->flags.msix_enabled) {\n\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\ticb->msix_atio = cpu_to_le16(msix->entry);\n\t\t\ticb->firmware_options_2 &= cpu_to_le32(~BIT_26);\n\t\t\tql_dbg(ql_dbg_init, vha, 0xf072,\n\t\t\t    \"Registering ICB vector 0x%x for atio que.\\n\",\n\t\t\t    msix->entry);\n\t\t}\n\t} else {\n\t\t \n\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\ticb->msix_atio = 0;\n\t\t\ticb->firmware_options_2 |= cpu_to_le32(BIT_26);\n\t\t\tql_dbg(ql_dbg_init, vha, 0xf072,\n\t\t\t    \"%s: Use INTx for ATIOQ.\\n\", __func__);\n\t\t}\n\t}\n}\n\nvoid\nqlt_24xx_config_nvram_stage1(struct scsi_qla_host *vha, struct nvram_24xx *nv)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tu32 tmp;\n\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\tif (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {\n\t\tif (!ha->tgt.saved_set) {\n\t\t\t \n\t\t\tha->tgt.saved_exchange_count = nv->exchange_count;\n\t\t\tha->tgt.saved_firmware_options_1 =\n\t\t\t    nv->firmware_options_1;\n\t\t\tha->tgt.saved_firmware_options_2 =\n\t\t\t    nv->firmware_options_2;\n\t\t\tha->tgt.saved_firmware_options_3 =\n\t\t\t    nv->firmware_options_3;\n\t\t\tha->tgt.saved_set = 1;\n\t\t}\n\n\t\tif (qla_tgt_mode_enabled(vha))\n\t\t\tnv->exchange_count = cpu_to_le16(0xFFFF);\n\t\telse\t\t\t \n\t\t\tnv->exchange_count = cpu_to_le16(vha->ql2xexchoffld);\n\n\t\t \n\t\tnv->firmware_options_1 |= cpu_to_le32(BIT_4);\n\n\t\t \n\t\tif (qla_tgt_mode_enabled(vha))\n\t\t\tnv->firmware_options_1 |= cpu_to_le32(BIT_5);\n\n\t\t \n\t\tnv->firmware_options_1 &= cpu_to_le32(~BIT_13);\n\t\t \n\t\tnv->firmware_options_1 &= cpu_to_le32(~BIT_9);\n\t\tif (ql2xtgt_tape_enable)\n\t\t\t \n\t\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_12);\n\t\telse\n\t\t\t \n\t\t\tnv->firmware_options_2 &= cpu_to_le32(~BIT_12);\n\n\t\t \n\t\tnv->host_p &= cpu_to_le32(~BIT_10);\n\n\t\t \n\t\tnv->firmware_options_1 &= cpu_to_le32(~BIT_15);\n\t\t \n\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_14);\n\n\t\tif (IS_QLA25XX(ha)) {\n\t\t\t \n\t\t\ttmp = ~(BIT_4|BIT_5|BIT_6);\n\t\t\tnv->firmware_options_2 &= cpu_to_le32(tmp);\n\t\t\ttmp = P2P << 4;\n\t\t\tnv->firmware_options_2 |= cpu_to_le32(tmp);\n\t\t}\n\t} else {\n\t\tif (ha->tgt.saved_set) {\n\t\t\tnv->exchange_count = ha->tgt.saved_exchange_count;\n\t\t\tnv->firmware_options_1 =\n\t\t\t    ha->tgt.saved_firmware_options_1;\n\t\t\tnv->firmware_options_2 =\n\t\t\t    ha->tgt.saved_firmware_options_2;\n\t\t\tnv->firmware_options_3 =\n\t\t\t    ha->tgt.saved_firmware_options_3;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ha->base_qpair->enable_class_2) {\n\t\tif (vha->flags.init_done)\n\t\t\tfc_host_supported_classes(vha->host) =\n\t\t\t\tFC_COS_CLASS2 | FC_COS_CLASS3;\n\n\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_8);\n\t} else {\n\t\tif (vha->flags.init_done)\n\t\t\tfc_host_supported_classes(vha->host) = FC_COS_CLASS3;\n\n\t\tnv->firmware_options_2 &= ~cpu_to_le32(BIT_8);\n\t}\n}\n\nvoid\nqlt_24xx_config_nvram_stage2(struct scsi_qla_host *vha,\n\tstruct init_cb_24xx *icb)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\tif (ha->tgt.node_name_set) {\n\t\tmemcpy(icb->node_name, ha->tgt.tgt_node_name, WWN_SIZE);\n\t\ticb->firmware_options_1 |= cpu_to_le32(BIT_14);\n\t}\n}\n\nvoid\nqlt_81xx_config_nvram_stage1(struct scsi_qla_host *vha, struct nvram_81xx *nv)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tu32 tmp;\n\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\tif (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha)) {\n\t\tif (!ha->tgt.saved_set) {\n\t\t\t \n\t\t\tha->tgt.saved_exchange_count = nv->exchange_count;\n\t\t\tha->tgt.saved_firmware_options_1 =\n\t\t\t    nv->firmware_options_1;\n\t\t\tha->tgt.saved_firmware_options_2 =\n\t\t\t    nv->firmware_options_2;\n\t\t\tha->tgt.saved_firmware_options_3 =\n\t\t\t    nv->firmware_options_3;\n\t\t\tha->tgt.saved_set = 1;\n\t\t}\n\n\t\tif (qla_tgt_mode_enabled(vha))\n\t\t\tnv->exchange_count = cpu_to_le16(0xFFFF);\n\t\telse\t\t\t \n\t\t\tnv->exchange_count = cpu_to_le16(vha->ql2xexchoffld);\n\n\t\t \n\t\tnv->firmware_options_1 |= cpu_to_le32(BIT_4);\n\n\t\t \n\t\tif (qla_tgt_mode_enabled(vha))\n\t\t\tnv->firmware_options_1 |= cpu_to_le32(BIT_5);\n\t\t \n\t\tnv->firmware_options_1 &= cpu_to_le32(~BIT_13);\n\t\t \n\t\tnv->firmware_options_1 &= cpu_to_le32(~BIT_9);\n\t\t \n\t\tnv->firmware_options_1 &= cpu_to_le32(~BIT_15);\n\t\tif (ql2xtgt_tape_enable)\n\t\t\t \n\t\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_12);\n\t\telse\n\t\t\t \n\t\t\tnv->firmware_options_2 &= cpu_to_le32(~BIT_12);\n\n\t\t \n\t\tnv->host_p &= cpu_to_le32(~BIT_10);\n\t\t \n\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_14);\n\n\t\t \n\t\ttmp = ~(BIT_4|BIT_5|BIT_6);\n\t\tnv->firmware_options_2 &= cpu_to_le32(tmp);\n\t\ttmp = P2P << 4;\n\t\tnv->firmware_options_2 |= cpu_to_le32(tmp);\n\t} else {\n\t\tif (ha->tgt.saved_set) {\n\t\t\tnv->exchange_count = ha->tgt.saved_exchange_count;\n\t\t\tnv->firmware_options_1 =\n\t\t\t    ha->tgt.saved_firmware_options_1;\n\t\t\tnv->firmware_options_2 =\n\t\t\t    ha->tgt.saved_firmware_options_2;\n\t\t\tnv->firmware_options_3 =\n\t\t\t    ha->tgt.saved_firmware_options_3;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ha->base_qpair->enable_class_2) {\n\t\tif (vha->flags.init_done)\n\t\t\tfc_host_supported_classes(vha->host) =\n\t\t\t\tFC_COS_CLASS2 | FC_COS_CLASS3;\n\n\t\tnv->firmware_options_2 |= cpu_to_le32(BIT_8);\n\t} else {\n\t\tif (vha->flags.init_done)\n\t\t\tfc_host_supported_classes(vha->host) = FC_COS_CLASS3;\n\n\t\tnv->firmware_options_2 &= ~cpu_to_le32(BIT_8);\n\t}\n}\n\nvoid\nqlt_81xx_config_nvram_stage2(struct scsi_qla_host *vha,\n\tstruct init_cb_81xx *icb)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\tif (ha->tgt.node_name_set) {\n\t\tmemcpy(icb->node_name, ha->tgt.tgt_node_name, WWN_SIZE);\n\t\ticb->firmware_options_1 |= cpu_to_le32(BIT_14);\n\t}\n}\n\nvoid\nqlt_83xx_iospace_config(struct qla_hw_data *ha)\n{\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\tha->msix_count += 1;  \n}\n\n\nvoid\nqlt_modify_vp_config(struct scsi_qla_host *vha,\n\tstruct vp_config_entry_24xx *vpmod)\n{\n\t \n\tif (qla_tgt_mode_enabled(vha) || qla_dual_mode_enabled(vha))\n\t\tvpmod->options_idx1 &= ~BIT_5;\n\n\t \n\tif (qla_tgt_mode_enabled(vha))\n\t\tvpmod->options_idx1 &= ~BIT_4;\n}\n\nvoid\nqlt_probe_one_stage1(struct scsi_qla_host *base_vha, struct qla_hw_data *ha)\n{\n\tmutex_init(&base_vha->vha_tgt.tgt_mutex);\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\tif  (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tISP_ATIO_Q_IN(base_vha) = &ha->mqiobase->isp25mq.atio_q_in;\n\t\tISP_ATIO_Q_OUT(base_vha) = &ha->mqiobase->isp25mq.atio_q_out;\n\t} else {\n\t\tISP_ATIO_Q_IN(base_vha) = &ha->iobase->isp24.atio_q_in;\n\t\tISP_ATIO_Q_OUT(base_vha) = &ha->iobase->isp24.atio_q_out;\n\t}\n\n\tmutex_init(&base_vha->vha_tgt.tgt_host_action_mutex);\n\n\tINIT_LIST_HEAD(&base_vha->unknown_atio_list);\n\tINIT_DELAYED_WORK(&base_vha->unknown_atio_work,\n\t    qlt_unknown_atio_work_fn);\n\n\tqlt_clear_mode(base_vha);\n\n\tqla_update_vp_map(base_vha, SET_VP_IDX);\n}\n\nirqreturn_t\nqla83xx_msix_atio_q(int irq, void *dev_id)\n{\n\tstruct rsp_que *rsp;\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tunsigned long flags;\n\n\trsp = (struct rsp_que *) dev_id;\n\tha = rsp->hw;\n\tvha = pci_get_drvdata(ha->pdev);\n\n\tspin_lock_irqsave(&ha->tgt.atio_lock, flags);\n\n\tqlt_24xx_process_atio_queue(vha, 0);\n\n\tspin_unlock_irqrestore(&ha->tgt.atio_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nqlt_handle_abts_recv_work(struct work_struct *work)\n{\n\tstruct qla_tgt_sess_op *op = container_of(work,\n\t\tstruct qla_tgt_sess_op, work);\n\tscsi_qla_host_t *vha = op->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\n\tif (qla2x00_reset_active(vha) ||\n\t    (op->chip_reset != ha->base_qpair->chip_reset))\n\t\treturn;\n\n\tspin_lock_irqsave(&ha->tgt.atio_lock, flags);\n\tqlt_24xx_process_atio_queue(vha, 0);\n\tspin_unlock_irqrestore(&ha->tgt.atio_lock, flags);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqlt_response_pkt_all_vps(vha, op->rsp, (response_t *)&op->atio);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tkfree(op);\n}\n\nvoid\nqlt_handle_abts_recv(struct scsi_qla_host *vha, struct rsp_que *rsp,\n    response_t *pkt)\n{\n\tstruct qla_tgt_sess_op *op;\n\n\top = kzalloc(sizeof(*op), GFP_ATOMIC);\n\n\tif (!op) {\n\t\t \n\t\tqlt_response_pkt_all_vps(vha, rsp, pkt);\n\t\treturn;\n\t}\n\n\tmemcpy(&op->atio, pkt, sizeof(*pkt));\n\top->vha = vha;\n\top->chip_reset = vha->hw->base_qpair->chip_reset;\n\top->rsp = rsp;\n\tINIT_WORK(&op->work, qlt_handle_abts_recv_work);\n\tqueue_work(qla_tgt_wq, &op->work);\n\treturn;\n}\n\nint\nqlt_mem_alloc(struct qla_hw_data *ha)\n{\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn 0;\n\n\tha->tgt.atio_ring = dma_alloc_coherent(&ha->pdev->dev,\n\t    (ha->tgt.atio_q_length + 1) * sizeof(struct atio_from_isp),\n\t    &ha->tgt.atio_dma, GFP_KERNEL);\n\tif (!ha->tgt.atio_ring) {\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid\nqlt_mem_free(struct qla_hw_data *ha)\n{\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\tif (ha->tgt.atio_ring) {\n\t\tdma_free_coherent(&ha->pdev->dev, (ha->tgt.atio_q_length + 1) *\n\t\t    sizeof(struct atio_from_isp), ha->tgt.atio_ring,\n\t\t    ha->tgt.atio_dma);\n\t}\n\tha->tgt.atio_ring = NULL;\n\tha->tgt.atio_dma = 0;\n}\n\nstatic int __init qlt_parse_ini_mode(void)\n{\n\tif (strcasecmp(qlini_mode, QLA2XXX_INI_MODE_STR_EXCLUSIVE) == 0)\n\t\tql2x_ini_mode = QLA2XXX_INI_MODE_EXCLUSIVE;\n\telse if (strcasecmp(qlini_mode, QLA2XXX_INI_MODE_STR_DISABLED) == 0)\n\t\tql2x_ini_mode = QLA2XXX_INI_MODE_DISABLED;\n\telse if (strcasecmp(qlini_mode, QLA2XXX_INI_MODE_STR_ENABLED) == 0)\n\t\tql2x_ini_mode = QLA2XXX_INI_MODE_ENABLED;\n\telse if (strcasecmp(qlini_mode, QLA2XXX_INI_MODE_STR_DUAL) == 0)\n\t\tql2x_ini_mode = QLA2XXX_INI_MODE_DUAL;\n\telse\n\t\treturn false;\n\n\treturn true;\n}\n\nint __init qlt_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct ctio7_to_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct ctio_to_2xxx) != 64);\n\n\tif (!qlt_parse_ini_mode()) {\n\t\tql_log(ql_log_fatal, NULL, 0xe06b,\n\t\t    \"qlt_parse_ini_mode() failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn 0;\n\n\tqla_tgt_mgmt_cmd_cachep = kmem_cache_create(\"qla_tgt_mgmt_cmd_cachep\",\n\t    sizeof(struct qla_tgt_mgmt_cmd), __alignof__(struct\n\t    qla_tgt_mgmt_cmd), 0, NULL);\n\tif (!qla_tgt_mgmt_cmd_cachep) {\n\t\tql_log(ql_log_fatal, NULL, 0xd04b,\n\t\t    \"kmem_cache_create for qla_tgt_mgmt_cmd_cachep failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tqla_tgt_plogi_cachep = kmem_cache_create(\"qla_tgt_plogi_cachep\",\n\t    sizeof(struct qlt_plogi_ack_t), __alignof__(struct qlt_plogi_ack_t),\n\t    0, NULL);\n\n\tif (!qla_tgt_plogi_cachep) {\n\t\tql_log(ql_log_fatal, NULL, 0xe06d,\n\t\t    \"kmem_cache_create for qla_tgt_plogi_cachep failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_mgmt_cmd_cachep;\n\t}\n\n\tqla_tgt_mgmt_cmd_mempool = mempool_create(25, mempool_alloc_slab,\n\t    mempool_free_slab, qla_tgt_mgmt_cmd_cachep);\n\tif (!qla_tgt_mgmt_cmd_mempool) {\n\t\tql_log(ql_log_fatal, NULL, 0xe06e,\n\t\t    \"mempool_create for qla_tgt_mgmt_cmd_mempool failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_plogi_cachep;\n\t}\n\n\tqla_tgt_wq = alloc_workqueue(\"qla_tgt_wq\", 0, 0);\n\tif (!qla_tgt_wq) {\n\t\tql_log(ql_log_fatal, NULL, 0xe06f,\n\t\t    \"alloc_workqueue for qla_tgt_wq failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_cmd_mempool;\n\t}\n\t \n\treturn (ql2x_ini_mode == QLA2XXX_INI_MODE_DISABLED) ? 1 : 0;\n\nout_cmd_mempool:\n\tmempool_destroy(qla_tgt_mgmt_cmd_mempool);\nout_plogi_cachep:\n\tkmem_cache_destroy(qla_tgt_plogi_cachep);\nout_mgmt_cmd_cachep:\n\tkmem_cache_destroy(qla_tgt_mgmt_cmd_cachep);\n\treturn ret;\n}\n\nvoid qlt_exit(void)\n{\n\tif (!QLA_TGT_MODE_ENABLED())\n\t\treturn;\n\n\tdestroy_workqueue(qla_tgt_wq);\n\tmempool_destroy(qla_tgt_mgmt_cmd_mempool);\n\tkmem_cache_destroy(qla_tgt_plogi_cachep);\n\tkmem_cache_destroy(qla_tgt_mgmt_cmd_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}