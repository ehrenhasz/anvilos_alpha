{
  "module_name": "qla_nvme.c",
  "hash_id": "236ea986047101a98ded5cdd2e6945c83e834ad4b0309bf9fc1d40d2476f578d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_nvme.c",
  "human_readable_source": "\n \n#include \"qla_nvme.h\"\n#include <linux/scatterlist.h>\n#include <linux/delay.h>\n#include <linux/nvme.h>\n#include <linux/nvme-fc.h>\n#include <linux/blk-mq-pci.h>\n#include <linux/blk-mq.h>\n\nstatic struct nvme_fc_port_template qla_nvme_fc_transport;\nstatic int qla_nvme_ls_reject_iocb(struct scsi_qla_host *vha,\n\t\t\t\t   struct qla_qpair *qp,\n\t\t\t\t   struct qla_nvme_lsrjt_pt_arg *a,\n\t\t\t\t   bool is_xchg_terminate);\n\nstruct qla_nvme_unsol_ctx {\n\tstruct list_head elem;\n\tstruct scsi_qla_host *vha;\n\tstruct fc_port *fcport;\n\tstruct srb *sp;\n\tstruct nvmefc_ls_rsp lsrsp;\n\tstruct nvmefc_ls_rsp *fd_rsp;\n\tstruct work_struct lsrsp_work;\n\tstruct work_struct abort_work;\n\t__le32 exchange_address;\n\t__le16 nport_handle;\n\t__le16 ox_id;\n\tint comp_status;\n\tspinlock_t cmd_lock;\n};\n\nint qla_nvme_register_remote(struct scsi_qla_host *vha, struct fc_port *fcport)\n{\n\tstruct qla_nvme_rport *rport;\n\tstruct nvme_fc_port_info req;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_NVME_FC))\n\t\treturn 0;\n\n\tif (!vha->flags.nvme_enabled) {\n\t\tql_log(ql_log_info, vha, 0x2100,\n\t\t    \"%s: Not registering target since Host NVME is not enabled\\n\",\n\t\t    __func__);\n\t\treturn 0;\n\t}\n\n\tif (!vha->nvme_local_port && qla_nvme_register_hba(vha))\n\t\treturn 0;\n\n\tif (!(fcport->nvme_prli_service_param &\n\t    (NVME_PRLI_SP_TARGET | NVME_PRLI_SP_DISCOVERY)) ||\n\t\t(fcport->nvme_flag & NVME_FLAG_REGISTERED))\n\t\treturn 0;\n\n\tfcport->nvme_flag &= ~NVME_FLAG_RESETTING;\n\n\tmemset(&req, 0, sizeof(struct nvme_fc_port_info));\n\treq.port_name = wwn_to_u64(fcport->port_name);\n\treq.node_name = wwn_to_u64(fcport->node_name);\n\treq.port_role = 0;\n\treq.dev_loss_tmo = fcport->dev_loss_tmo;\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_INITIATOR)\n\t\treq.port_role = FC_PORT_ROLE_NVME_INITIATOR;\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_TARGET)\n\t\treq.port_role |= FC_PORT_ROLE_NVME_TARGET;\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_DISCOVERY)\n\t\treq.port_role |= FC_PORT_ROLE_NVME_DISCOVERY;\n\n\treq.port_id = fcport->d_id.b24;\n\n\tql_log(ql_log_info, vha, 0x2102,\n\t    \"%s: traddr=nn-0x%016llx:pn-0x%016llx PortID:%06x\\n\",\n\t    __func__, req.node_name, req.port_name,\n\t    req.port_id);\n\n\tret = nvme_fc_register_remoteport(vha->nvme_local_port, &req,\n\t    &fcport->nvme_remote_port);\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0x212e,\n\t\t    \"Failed to register remote port. Transport returned %d\\n\",\n\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tnvme_fc_set_remoteport_devloss(fcport->nvme_remote_port,\n\t\t\t\t       fcport->dev_loss_tmo);\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_SLER)\n\t\tql_log(ql_log_info, vha, 0x212a,\n\t\t       \"PortID:%06x Supports SLER\\n\", req.port_id);\n\n\tif (fcport->nvme_prli_service_param & NVME_PRLI_SP_PI_CTRL)\n\t\tql_log(ql_log_info, vha, 0x212b,\n\t\t       \"PortID:%06x Supports PI control\\n\", req.port_id);\n\n\trport = fcport->nvme_remote_port->private;\n\trport->fcport = fcport;\n\n\tfcport->nvme_flag |= NVME_FLAG_REGISTERED;\n\treturn 0;\n}\n\n \nstatic int qla_nvme_alloc_queue(struct nvme_fc_local_port *lport,\n    unsigned int qidx, u16 qsize, void **handle)\n{\n\tstruct scsi_qla_host *vha;\n\tstruct qla_hw_data *ha;\n\tstruct qla_qpair *qpair;\n\n\t \n\tif (qidx)\n\t\tqidx--;\n\n\tvha = (struct scsi_qla_host *)lport->private;\n\tha = vha->hw;\n\n\tql_log(ql_log_info, vha, 0x2104,\n\t    \"%s: handle %p, idx =%d, qsize %d\\n\",\n\t    __func__, handle, qidx, qsize);\n\n\tif (qidx > qla_nvme_fc_transport.max_hw_queues) {\n\t\tql_log(ql_log_warn, vha, 0x212f,\n\t\t    \"%s: Illegal qidx=%d. Max=%d\\n\",\n\t\t    __func__, qidx, qla_nvme_fc_transport.max_hw_queues);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!ha->max_qpairs) {\n\t\tqpair = ha->base_qpair;\n\t} else {\n\t\tif (ha->queue_pair_map[qidx]) {\n\t\t\t*handle = ha->queue_pair_map[qidx];\n\t\t\tql_log(ql_log_info, vha, 0x2121,\n\t\t\t       \"Returning existing qpair of %p for idx=%x\\n\",\n\t\t\t       *handle, qidx);\n\t\t\treturn 0;\n\t\t}\n\n\t\tqpair = qla2xxx_create_qpair(vha, 5, vha->vp_idx, true);\n\t\tif (!qpair) {\n\t\t\tql_log(ql_log_warn, vha, 0x2122,\n\t\t\t       \"Failed to allocate qpair\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tqla_adjust_iocb_limit(vha);\n\t}\n\t*handle = qpair;\n\n\treturn 0;\n}\n\nstatic void qla_nvme_release_fcp_cmd_kref(struct kref *kref)\n{\n\tstruct srb *sp = container_of(kref, struct srb, cmd_kref);\n\tstruct nvme_private *priv = (struct nvme_private *)sp->priv;\n\tstruct nvmefc_fcp_req *fd;\n\tstruct srb_iocb *nvme;\n\tunsigned long flags;\n\n\tif (!priv)\n\t\tgoto out;\n\n\tnvme = &sp->u.iocb_cmd;\n\tfd = nvme->u.nvme.desc;\n\n\tspin_lock_irqsave(&priv->cmd_lock, flags);\n\tpriv->sp = NULL;\n\tsp->priv = NULL;\n\tif (priv->comp_status == QLA_SUCCESS) {\n\t\tfd->rcv_rsplen = le16_to_cpu(nvme->u.nvme.rsp_pyld_len);\n\t\tfd->status = NVME_SC_SUCCESS;\n\t} else {\n\t\tfd->rcv_rsplen = 0;\n\t\tfd->transferred_length = 0;\n\t\tfd->status = NVME_SC_INTERNAL;\n\t}\n\tspin_unlock_irqrestore(&priv->cmd_lock, flags);\n\n\tfd->done(fd);\nout:\n\tqla2xxx_rel_qpair_sp(sp->qpair, sp);\n}\n\nstatic void qla_nvme_release_ls_cmd_kref(struct kref *kref)\n{\n\tstruct srb *sp = container_of(kref, struct srb, cmd_kref);\n\tstruct nvme_private *priv = (struct nvme_private *)sp->priv;\n\tstruct nvmefc_ls_req *fd;\n\tunsigned long flags;\n\n\tif (!priv)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&priv->cmd_lock, flags);\n\tpriv->sp = NULL;\n\tsp->priv = NULL;\n\tspin_unlock_irqrestore(&priv->cmd_lock, flags);\n\n\tfd = priv->fd;\n\n\tfd->done(fd, priv->comp_status);\nout:\n\tqla2x00_rel_sp(sp);\n}\n\nstatic void qla_nvme_ls_complete(struct work_struct *work)\n{\n\tstruct nvme_private *priv =\n\t\tcontainer_of(work, struct nvme_private, ls_work);\n\n\tkref_put(&priv->sp->cmd_kref, qla_nvme_release_ls_cmd_kref);\n}\n\nstatic void qla_nvme_sp_ls_done(srb_t *sp, int res)\n{\n\tstruct nvme_private *priv = sp->priv;\n\n\tif (WARN_ON_ONCE(kref_read(&sp->cmd_kref) == 0))\n\t\treturn;\n\n\tif (res)\n\t\tres = -EINVAL;\n\n\tpriv->comp_status = res;\n\tINIT_WORK(&priv->ls_work, qla_nvme_ls_complete);\n\tschedule_work(&priv->ls_work);\n}\n\nstatic void qla_nvme_release_lsrsp_cmd_kref(struct kref *kref)\n{\n\tstruct srb *sp = container_of(kref, struct srb, cmd_kref);\n\tstruct qla_nvme_unsol_ctx *uctx = sp->priv;\n\tstruct nvmefc_ls_rsp *fd_rsp;\n\tunsigned long flags;\n\n\tif (!uctx) {\n\t\tqla2x00_rel_sp(sp);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&uctx->cmd_lock, flags);\n\tuctx->sp = NULL;\n\tsp->priv = NULL;\n\tspin_unlock_irqrestore(&uctx->cmd_lock, flags);\n\n\tfd_rsp = uctx->fd_rsp;\n\n\tlist_del(&uctx->elem);\n\n\tfd_rsp->done(fd_rsp);\n\tkfree(uctx);\n\tqla2x00_rel_sp(sp);\n}\n\nstatic void qla_nvme_lsrsp_complete(struct work_struct *work)\n{\n\tstruct qla_nvme_unsol_ctx *uctx =\n\t\tcontainer_of(work, struct qla_nvme_unsol_ctx, lsrsp_work);\n\n\tkref_put(&uctx->sp->cmd_kref, qla_nvme_release_lsrsp_cmd_kref);\n}\n\nstatic void qla_nvme_sp_lsrsp_done(srb_t *sp, int res)\n{\n\tstruct qla_nvme_unsol_ctx *uctx = sp->priv;\n\n\tif (WARN_ON_ONCE(kref_read(&sp->cmd_kref) == 0))\n\t\treturn;\n\n\tif (res)\n\t\tres = -EINVAL;\n\n\tuctx->comp_status = res;\n\tINIT_WORK(&uctx->lsrsp_work, qla_nvme_lsrsp_complete);\n\tschedule_work(&uctx->lsrsp_work);\n}\n\n \nstatic void qla_nvme_sp_done(srb_t *sp, int res)\n{\n\tstruct nvme_private *priv = sp->priv;\n\n\tpriv->comp_status = res;\n\tkref_put(&sp->cmd_kref, qla_nvme_release_fcp_cmd_kref);\n\n\treturn;\n}\n\nstatic void qla_nvme_abort_work(struct work_struct *work)\n{\n\tstruct nvme_private *priv =\n\t\tcontainer_of(work, struct nvme_private, abort_work);\n\tsrb_t *sp = priv->sp;\n\tfc_port_t *fcport = sp->fcport;\n\tstruct qla_hw_data *ha = fcport->vha->hw;\n\tint rval, abts_done_called = 1;\n\tbool io_wait_for_abort_done;\n\tuint32_t handle;\n\n\tql_dbg(ql_dbg_io, fcport->vha, 0xffff,\n\t       \"%s called for sp=%p, hndl=%x on fcport=%p desc=%p deleted=%d\\n\",\n\t       __func__, sp, sp->handle, fcport, sp->u.iocb_cmd.u.nvme.desc, fcport->deleted);\n\n\tif (!ha->flags.fw_started || fcport->deleted == QLA_SESS_DELETED)\n\t\tgoto out;\n\n\tif (ha->flags.host_shutting_down) {\n\t\tql_log(ql_log_info, sp->fcport->vha, 0xffff,\n\t\t    \"%s Calling done on sp: %p, type: 0x%x\\n\",\n\t\t    __func__, sp, sp->type);\n\t\tsp->done(sp, 0);\n\t\tgoto out;\n\t}\n\n\t \n\tio_wait_for_abort_done = ql2xabts_wait_nvme &&\n\t\t\t\t\tQLA_ABTS_WAIT_ENABLED(sp);\n\thandle = sp->handle;\n\n\trval = ha->isp_ops->abort_command(sp);\n\n\tql_dbg(ql_dbg_io, fcport->vha, 0x212b,\n\t    \"%s: %s command for sp=%p, handle=%x on fcport=%p rval=%x\\n\",\n\t    __func__, (rval != QLA_SUCCESS) ? \"Failed to abort\" : \"Aborted\",\n\t    sp, handle, fcport, rval);\n\n\t \n\tif (ql2xasynctmfenable &&\n\t    rval != QLA_SUCCESS && rval != QLA_ERR_FROM_FW)\n\t\tabts_done_called = 0;\n\n\t \n\tif (abts_done_called && io_wait_for_abort_done)\n\t\treturn;\nout:\n\t \n\tkref_put(&sp->cmd_kref, sp->put_fn);\n}\n\nstatic int qla_nvme_xmt_ls_rsp(struct nvme_fc_local_port *lport,\n\t\t\t       struct nvme_fc_remote_port *rport,\n\t\t\t       struct nvmefc_ls_rsp *fd_resp)\n{\n\tstruct qla_nvme_unsol_ctx *uctx = container_of(fd_resp,\n\t\t\t\tstruct qla_nvme_unsol_ctx, lsrsp);\n\tstruct qla_nvme_rport *qla_rport = rport->private;\n\tfc_port_t *fcport = qla_rport->fcport;\n\tstruct scsi_qla_host *vha = uctx->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_nvme_lsrjt_pt_arg a;\n\tstruct srb_iocb *nvme;\n\tsrb_t *sp;\n\tint rval = QLA_FUNCTION_FAILED;\n\tuint8_t cnt = 0;\n\n\tif (!fcport || fcport->deleted)\n\t\tgoto out;\n\n\tif (!ha->flags.fw_started)\n\t\tgoto out;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);\n\tif (!sp)\n\t\tgoto out;\n\n\tsp->type = SRB_NVME_LS;\n\tsp->name = \"nvme_ls\";\n\tsp->done = qla_nvme_sp_lsrsp_done;\n\tsp->put_fn = qla_nvme_release_lsrsp_cmd_kref;\n\tsp->priv = (void *)uctx;\n\tsp->unsol_rsp = 1;\n\tuctx->sp = sp;\n\tspin_lock_init(&uctx->cmd_lock);\n\tnvme = &sp->u.iocb_cmd;\n\tuctx->fd_rsp = fd_resp;\n\tnvme->u.nvme.desc = fd_resp;\n\tnvme->u.nvme.dir = 0;\n\tnvme->u.nvme.dl = 0;\n\tnvme->u.nvme.timeout_sec = 0;\n\tnvme->u.nvme.cmd_dma = fd_resp->rspdma;\n\tnvme->u.nvme.cmd_len = cpu_to_le32(fd_resp->rsplen);\n\tnvme->u.nvme.rsp_len = 0;\n\tnvme->u.nvme.rsp_dma = 0;\n\tnvme->u.nvme.exchange_address = uctx->exchange_address;\n\tnvme->u.nvme.nport_handle = uctx->nport_handle;\n\tnvme->u.nvme.ox_id = uctx->ox_id;\n\tdma_sync_single_for_device(&ha->pdev->dev, nvme->u.nvme.cmd_dma,\n\t\t\t\t   fd_resp->rsplen, DMA_TO_DEVICE);\n\n\tql_dbg(ql_dbg_unsol, vha, 0x2122,\n\t       \"Unsol lsreq portid=%06x %8phC exchange_address 0x%x ox_id 0x%x hdl 0x%x\\n\",\n\t       fcport->d_id.b24, fcport->port_name, uctx->exchange_address,\n\t       uctx->ox_id, uctx->nport_handle);\nretry:\n\trval = qla2x00_start_sp(sp);\n\tswitch (rval) {\n\tcase QLA_SUCCESS:\n\t\tbreak;\n\tcase EAGAIN:\n\t\tmsleep(PURLS_MSLEEP_INTERVAL);\n\t\tcnt++;\n\t\tif (cnt < PURLS_RETRY_COUNT)\n\t\t\tgoto retry;\n\n\t\tfallthrough;\n\tdefault:\n\t\tql_dbg(ql_log_warn, vha, 0x2123,\n\t\t       \"Failed to xmit Unsol ls response = %d\\n\", rval);\n\t\trval = -EIO;\n\t\tqla2x00_rel_sp(sp);\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tmemset((void *)&a, 0, sizeof(a));\n\ta.vp_idx = vha->vp_idx;\n\ta.nport_handle = uctx->nport_handle;\n\ta.xchg_address = uctx->exchange_address;\n\tqla_nvme_ls_reject_iocb(vha, ha->base_qpair, &a, true);\n\tkfree(uctx);\n\treturn rval;\n}\n\nstatic void qla_nvme_ls_abort(struct nvme_fc_local_port *lport,\n    struct nvme_fc_remote_port *rport, struct nvmefc_ls_req *fd)\n{\n\tstruct nvme_private *priv = fd->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->cmd_lock, flags);\n\tif (!priv->sp) {\n\t\tspin_unlock_irqrestore(&priv->cmd_lock, flags);\n\t\treturn;\n\t}\n\n\tif (!kref_get_unless_zero(&priv->sp->cmd_kref)) {\n\t\tspin_unlock_irqrestore(&priv->cmd_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->cmd_lock, flags);\n\n\tINIT_WORK(&priv->abort_work, qla_nvme_abort_work);\n\tschedule_work(&priv->abort_work);\n}\n\nstatic int qla_nvme_ls_req(struct nvme_fc_local_port *lport,\n    struct nvme_fc_remote_port *rport, struct nvmefc_ls_req *fd)\n{\n\tstruct qla_nvme_rport *qla_rport = rport->private;\n\tfc_port_t *fcport = qla_rport->fcport;\n\tstruct srb_iocb   *nvme;\n\tstruct nvme_private *priv = fd->private;\n\tstruct scsi_qla_host *vha;\n\tint     rval = QLA_FUNCTION_FAILED;\n\tstruct qla_hw_data *ha;\n\tsrb_t           *sp;\n\n\tif (!fcport || fcport->deleted)\n\t\treturn rval;\n\n\tvha = fcport->vha;\n\tha = vha->hw;\n\n\tif (!ha->flags.fw_started)\n\t\treturn rval;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_ATOMIC);\n\tif (!sp)\n\t\treturn rval;\n\n\tsp->type = SRB_NVME_LS;\n\tsp->name = \"nvme_ls\";\n\tsp->done = qla_nvme_sp_ls_done;\n\tsp->put_fn = qla_nvme_release_ls_cmd_kref;\n\tsp->priv = priv;\n\tpriv->sp = sp;\n\tkref_init(&sp->cmd_kref);\n\tspin_lock_init(&priv->cmd_lock);\n\tnvme = &sp->u.iocb_cmd;\n\tpriv->fd = fd;\n\tnvme->u.nvme.desc = fd;\n\tnvme->u.nvme.dir = 0;\n\tnvme->u.nvme.dl = 0;\n\tnvme->u.nvme.cmd_len = cpu_to_le32(fd->rqstlen);\n\tnvme->u.nvme.rsp_len = cpu_to_le32(fd->rsplen);\n\tnvme->u.nvme.rsp_dma = fd->rspdma;\n\tnvme->u.nvme.timeout_sec = fd->timeout;\n\tnvme->u.nvme.cmd_dma = fd->rqstdma;\n\tdma_sync_single_for_device(&ha->pdev->dev, nvme->u.nvme.cmd_dma,\n\t    fd->rqstlen, DMA_TO_DEVICE);\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x700e,\n\t\t    \"qla2x00_start_sp failed = %d\\n\", rval);\n\t\tsp->priv = NULL;\n\t\tpriv->sp = NULL;\n\t\tqla2x00_rel_sp(sp);\n\t\treturn rval;\n\t}\n\n\treturn rval;\n}\n\nstatic void qla_nvme_fcp_abort(struct nvme_fc_local_port *lport,\n    struct nvme_fc_remote_port *rport, void *hw_queue_handle,\n    struct nvmefc_fcp_req *fd)\n{\n\tstruct nvme_private *priv = fd->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->cmd_lock, flags);\n\tif (!priv->sp) {\n\t\tspin_unlock_irqrestore(&priv->cmd_lock, flags);\n\t\treturn;\n\t}\n\tif (!kref_get_unless_zero(&priv->sp->cmd_kref)) {\n\t\tspin_unlock_irqrestore(&priv->cmd_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->cmd_lock, flags);\n\n\tINIT_WORK(&priv->abort_work, qla_nvme_abort_work);\n\tschedule_work(&priv->abort_work);\n}\n\nstatic inline int qla2x00_start_nvme_mq(srb_t *sp)\n{\n\tunsigned long   flags;\n\tuint32_t        *clr_ptr;\n\tuint32_t        handle;\n\tstruct cmd_nvme *cmd_pkt;\n\tuint16_t        cnt, i;\n\tuint16_t        req_cnt;\n\tuint16_t        tot_dsds;\n\tuint16_t\tavail_dsds;\n\tstruct dsd64\t*cur_dsd;\n\tstruct req_que *req = NULL;\n\tstruct rsp_que *rsp = NULL;\n\tstruct scsi_qla_host *vha = sp->fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla_qpair *qpair = sp->qpair;\n\tstruct srb_iocb *nvme = &sp->u.iocb_cmd;\n\tstruct scatterlist *sgl, *sg;\n\tstruct nvmefc_fcp_req *fd = nvme->u.nvme.desc;\n\tstruct nvme_fc_cmd_iu *cmd = fd->cmdaddr;\n\tuint32_t        rval = QLA_SUCCESS;\n\n\t \n\treq = qpair->req;\n\trsp = qpair->rsp;\n\ttot_dsds = fd->sg_cnt;\n\n\t \n\tspin_lock_irqsave(&qpair->qp_lock, flags);\n\n\thandle = qla2xxx_get_next_handle(req);\n\tif (handle == 0) {\n\t\trval = -EBUSY;\n\t\tgoto queuing_error;\n\t}\n\treq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\n\tsp->iores.res_type = RESOURCE_IOCB | RESOURCE_EXCH;\n\tsp->iores.exch_cnt = 1;\n\tsp->iores.iocb_cnt = req_cnt;\n\tif (qla_get_fw_resources(sp->qpair, &sp->iores)) {\n\t\trval = -EBUSY;\n\t\tgoto queuing_error;\n\t}\n\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tif (IS_SHADOW_REG_CAPABLE(ha)) {\n\t\t\tcnt = *req->out_ptr;\n\t\t} else {\n\t\t\tcnt = rd_reg_dword_relaxed(req->req_q_out);\n\t\t\tif (qla2x00_check_reg16_for_disconnect(vha, cnt)) {\n\t\t\t\trval = -EBUSY;\n\t\t\t\tgoto queuing_error;\n\t\t\t}\n\t\t}\n\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length - (req->ring_index - cnt);\n\n\t\tif (req->cnt < (req_cnt + 2)){\n\t\t\trval = -EBUSY;\n\t\t\tgoto queuing_error;\n\t\t}\n\t}\n\n\tif (unlikely(!fd->sqid)) {\n\t\tif (cmd->sqe.common.opcode == nvme_admin_async_event) {\n\t\t\tnvme->u.nvme.aen_op = 1;\n\t\t\tatomic_inc(&ha->nvme_active_aen_cnt);\n\t\t}\n\t}\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\treq->cnt -= req_cnt;\n\n\tcmd_pkt = (struct cmd_nvme *)req->ring_ptr;\n\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\t \n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\n\tcmd_pkt->entry_status = 0;\n\n\t \n\tcmd_pkt->entry_type = COMMAND_NVME;\n\n\t \n\tif (fd->io_dir == NVMEFC_FCP_READ) {\n\t\tcmd_pkt->control_flags = cpu_to_le16(CF_READ_DATA);\n\t\tqpair->counters.input_bytes += fd->payload_length;\n\t\tqpair->counters.input_requests++;\n\t} else if (fd->io_dir == NVMEFC_FCP_WRITE) {\n\t\tcmd_pkt->control_flags = cpu_to_le16(CF_WRITE_DATA);\n\t\tif ((vha->flags.nvme_first_burst) &&\n\t\t    (sp->fcport->nvme_prli_service_param &\n\t\t\tNVME_PRLI_SP_FIRST_BURST)) {\n\t\t\tif ((fd->payload_length <=\n\t\t\t    sp->fcport->nvme_first_burst_size) ||\n\t\t\t\t(sp->fcport->nvme_first_burst_size == 0))\n\t\t\t\tcmd_pkt->control_flags |=\n\t\t\t\t\tcpu_to_le16(CF_NVME_FIRST_BURST_ENABLE);\n\t\t}\n\t\tqpair->counters.output_bytes += fd->payload_length;\n\t\tqpair->counters.output_requests++;\n\t} else if (fd->io_dir == 0) {\n\t\tcmd_pkt->control_flags = 0;\n\t}\n\n\tif (sp->fcport->edif.enable && fd->io_dir != 0)\n\t\tcmd_pkt->control_flags |= cpu_to_le16(CF_EN_EDIF);\n\n\t \n\tif (vha->flags.nvme2_enabled &&\n\t    cmd->sqe.common.opcode == nvme_admin_async_event) {\n\t\tcmd_pkt->control_flags |= cpu_to_le16(CF_ADMIN_ASYNC_EVENT);\n\t}\n\n\t \n\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\tcmd_pkt->vp_index = sp->fcport->vha->vp_idx;\n\n\t \n\tcmd_pkt->nvme_rsp_dsd_len = cpu_to_le16(fd->rsplen);\n\tput_unaligned_le64(fd->rspdma, &cmd_pkt->nvme_rsp_dseg_address);\n\n\t \n\tcmd_pkt->nvme_cmnd_dseg_len = cpu_to_le16(fd->cmdlen);\n\tcmd_pkt->nvme_cmnd_dseg_address = cpu_to_le64(fd->cmddma);\n\n\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\tcmd_pkt->byte_count = cpu_to_le32(fd->payload_length);\n\n\t \n\tavail_dsds = 1;\n\tcur_dsd = &cmd_pkt->nvme_dsd;\n\tsgl = fd->first_sgl;\n\n\t \n\tfor_each_sg(sgl, sg, tot_dsds, i) {\n\t\tcont_a64_entry_t *cont_pkt;\n\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\n\t\t\t \n\t\t\treq->ring_index++;\n\t\t\tif (req->ring_index == req->length) {\n\t\t\t\treq->ring_index = 0;\n\t\t\t\treq->ring_ptr = req->ring;\n\t\t\t} else {\n\t\t\t\treq->ring_ptr++;\n\t\t\t}\n\t\t\tcont_pkt = (cont_a64_entry_t *)req->ring_ptr;\n\t\t\tput_unaligned_le32(CONTINUE_A64_TYPE,\n\t\t\t\t\t   &cont_pkt->entry_type);\n\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = ARRAY_SIZE(cont_pkt->dsd);\n\t\t}\n\n\t\tappend_dsd64(&cur_dsd, sg);\n\t\tavail_dsds--;\n\t}\n\n\t \n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\twmb();\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else {\n\t\treq->ring_ptr++;\n\t}\n\n\t \n\tif (!nvme->u.nvme.aen_op)\n\t\tsp->qpair->cmd_cnt++;\n\n\t \n\twrt_reg_dword(req->req_q_in, req->ring_index);\n\n\tif (vha->flags.process_response_queue &&\n\t    rsp->ring_ptr->signature != RESPONSE_PROCESSED)\n\t\tqla24xx_process_response_queue(vha, rsp);\n\nqueuing_error:\n\tif (rval)\n\t\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\tspin_unlock_irqrestore(&qpair->qp_lock, flags);\n\n\treturn rval;\n}\n\n \nstatic int qla_nvme_post_cmd(struct nvme_fc_local_port *lport,\n    struct nvme_fc_remote_port *rport, void *hw_queue_handle,\n    struct nvmefc_fcp_req *fd)\n{\n\tfc_port_t *fcport;\n\tstruct srb_iocb *nvme;\n\tstruct scsi_qla_host *vha;\n\tstruct qla_hw_data *ha;\n\tint rval;\n\tsrb_t *sp;\n\tstruct qla_qpair *qpair = hw_queue_handle;\n\tstruct nvme_private *priv = fd->private;\n\tstruct qla_nvme_rport *qla_rport = rport->private;\n\n\tif (!priv) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tfcport = qla_rport->fcport;\n\n\tif (unlikely(!qpair || !fcport || fcport->deleted))\n\t\treturn -EBUSY;\n\n\tif (!(fcport->nvme_flag & NVME_FLAG_REGISTERED))\n\t\treturn -ENODEV;\n\n\tvha = fcport->vha;\n\tha = vha->hw;\n\n\tif (test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags))\n\t\treturn -EBUSY;\n\n\t \n\tif (fcport->nvme_flag & NVME_FLAG_RESETTING)\n\t\treturn -EBUSY;\n\n\tqpair = qla_mapq_nvme_select_qpair(ha, qpair);\n\n\t \n\tsp = qla2xxx_get_qpair_sp(vha, qpair, fcport, GFP_ATOMIC);\n\tif (!sp)\n\t\treturn -EBUSY;\n\n\tkref_init(&sp->cmd_kref);\n\tspin_lock_init(&priv->cmd_lock);\n\tsp->priv = priv;\n\tpriv->sp = sp;\n\tsp->type = SRB_NVME_CMD;\n\tsp->name = \"nvme_cmd\";\n\tsp->done = qla_nvme_sp_done;\n\tsp->put_fn = qla_nvme_release_fcp_cmd_kref;\n\tsp->qpair = qpair;\n\tsp->vha = vha;\n\tsp->cmd_sp = sp;\n\tnvme = &sp->u.iocb_cmd;\n\tnvme->u.nvme.desc = fd;\n\n\trval = qla2x00_start_nvme_mq(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_io + ql_dbg_verbose, vha, 0x212d,\n\t\t    \"qla2x00_start_nvme_mq failed = %d\\n\", rval);\n\t\tsp->priv = NULL;\n\t\tpriv->sp = NULL;\n\t\tqla2xxx_rel_qpair_sp(sp->qpair, sp);\n\t}\n\n\treturn rval;\n}\n\nstatic void qla_nvme_map_queues(struct nvme_fc_local_port *lport,\n\t\tstruct blk_mq_queue_map *map)\n{\n\tstruct scsi_qla_host *vha = lport->private;\n\n\tblk_mq_pci_map_queues(map, vha->hw->pdev, vha->irq_offset);\n}\n\nstatic void qla_nvme_localport_delete(struct nvme_fc_local_port *lport)\n{\n\tstruct scsi_qla_host *vha = lport->private;\n\n\tql_log(ql_log_info, vha, 0x210f,\n\t    \"localport delete of %p completed.\\n\", vha->nvme_local_port);\n\tvha->nvme_local_port = NULL;\n\tcomplete(&vha->nvme_del_done);\n}\n\nstatic void qla_nvme_remoteport_delete(struct nvme_fc_remote_port *rport)\n{\n\tfc_port_t *fcport;\n\tstruct qla_nvme_rport *qla_rport = rport->private;\n\n\tfcport = qla_rport->fcport;\n\tfcport->nvme_remote_port = NULL;\n\tfcport->nvme_flag &= ~NVME_FLAG_REGISTERED;\n\tfcport->nvme_flag &= ~NVME_FLAG_DELETING;\n\tql_log(ql_log_info, fcport->vha, 0x2110,\n\t    \"remoteport_delete of %p %8phN completed.\\n\",\n\t    fcport, fcport->port_name);\n\tcomplete(&fcport->nvme_del_done);\n}\n\nstatic struct nvme_fc_port_template qla_nvme_fc_transport = {\n\t.localport_delete = qla_nvme_localport_delete,\n\t.remoteport_delete = qla_nvme_remoteport_delete,\n\t.create_queue   = qla_nvme_alloc_queue,\n\t.delete_queue \t= NULL,\n\t.ls_req\t\t= qla_nvme_ls_req,\n\t.ls_abort\t= qla_nvme_ls_abort,\n\t.fcp_io\t\t= qla_nvme_post_cmd,\n\t.fcp_abort\t= qla_nvme_fcp_abort,\n\t.xmt_ls_rsp\t= qla_nvme_xmt_ls_rsp,\n\t.map_queues\t= qla_nvme_map_queues,\n\t.max_hw_queues  = DEF_NVME_HW_QUEUES,\n\t.max_sgl_segments = 1024,\n\t.max_dif_sgl_segments = 64,\n\t.dma_boundary = 0xFFFFFFFF,\n\t.local_priv_sz  = 8,\n\t.remote_priv_sz = sizeof(struct qla_nvme_rport),\n\t.lsrqst_priv_sz = sizeof(struct nvme_private),\n\t.fcprqst_priv_sz = sizeof(struct nvme_private),\n};\n\nvoid qla_nvme_unregister_remote_port(struct fc_port *fcport)\n{\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_NVME_FC))\n\t\treturn;\n\n\tql_log(ql_log_warn, fcport->vha, 0x2112,\n\t    \"%s: unregister remoteport on %p %8phN\\n\",\n\t    __func__, fcport, fcport->port_name);\n\n\tif (test_bit(PFLG_DRIVER_REMOVING, &fcport->vha->pci_flags))\n\t\tnvme_fc_set_remoteport_devloss(fcport->nvme_remote_port, 0);\n\n\tinit_completion(&fcport->nvme_del_done);\n\tret = nvme_fc_unregister_remoteport(fcport->nvme_remote_port);\n\tif (ret)\n\t\tql_log(ql_log_info, fcport->vha, 0x2114,\n\t\t\t\"%s: Failed to unregister nvme_remote_port (%d)\\n\",\n\t\t\t    __func__, ret);\n\twait_for_completion(&fcport->nvme_del_done);\n}\n\nvoid qla_nvme_delete(struct scsi_qla_host *vha)\n{\n\tint nv_ret;\n\n\tif (!IS_ENABLED(CONFIG_NVME_FC))\n\t\treturn;\n\n\tif (vha->nvme_local_port) {\n\t\tinit_completion(&vha->nvme_del_done);\n\t\tql_log(ql_log_info, vha, 0x2116,\n\t\t\t\"unregister localport=%p\\n\",\n\t\t\tvha->nvme_local_port);\n\t\tnv_ret = nvme_fc_unregister_localport(vha->nvme_local_port);\n\t\tif (nv_ret)\n\t\t\tql_log(ql_log_info, vha, 0x2115,\n\t\t\t    \"Unregister of localport failed\\n\");\n\t\telse\n\t\t\twait_for_completion(&vha->nvme_del_done);\n\t}\n}\n\nint qla_nvme_register_hba(struct scsi_qla_host *vha)\n{\n\tstruct nvme_fc_port_template *tmpl;\n\tstruct qla_hw_data *ha;\n\tstruct nvme_fc_port_info pinfo;\n\tint ret = -EINVAL;\n\n\tif (!IS_ENABLED(CONFIG_NVME_FC))\n\t\treturn ret;\n\n\tha = vha->hw;\n\ttmpl = &qla_nvme_fc_transport;\n\n\tif (ql2xnvme_queues < MIN_NVME_HW_QUEUES) {\n\t\tql_log(ql_log_warn, vha, 0xfffd,\n\t\t    \"ql2xnvme_queues=%d is lower than minimum queues: %d. Resetting ql2xnvme_queues to:%d\\n\",\n\t\t    ql2xnvme_queues, MIN_NVME_HW_QUEUES, DEF_NVME_HW_QUEUES);\n\t\tql2xnvme_queues = DEF_NVME_HW_QUEUES;\n\t} else if (ql2xnvme_queues > (ha->max_qpairs - 1)) {\n\t\tql_log(ql_log_warn, vha, 0xfffd,\n\t\t       \"ql2xnvme_queues=%d is greater than available IRQs: %d. Resetting ql2xnvme_queues to: %d\\n\",\n\t\t       ql2xnvme_queues, (ha->max_qpairs - 1),\n\t\t       (ha->max_qpairs - 1));\n\t\tql2xnvme_queues = ((ha->max_qpairs - 1));\n\t}\n\n\tqla_nvme_fc_transport.max_hw_queues =\n\t    min((uint8_t)(ql2xnvme_queues),\n\t\t(uint8_t)((ha->max_qpairs - 1) ? (ha->max_qpairs - 1) : 1));\n\n\tql_log(ql_log_info, vha, 0xfffb,\n\t       \"Number of NVME queues used for this port: %d\\n\",\n\t    qla_nvme_fc_transport.max_hw_queues);\n\n\tpinfo.node_name = wwn_to_u64(vha->node_name);\n\tpinfo.port_name = wwn_to_u64(vha->port_name);\n\tpinfo.port_role = FC_PORT_ROLE_NVME_INITIATOR;\n\tpinfo.port_id = vha->d_id.b24;\n\n\tmutex_lock(&ha->vport_lock);\n\t \n\tif (!vha->nvme_local_port) {\n\t\tql_log(ql_log_info, vha, 0xffff,\n\t\t    \"register_localport: host-traddr=nn-0x%llx:pn-0x%llx on portID:%x\\n\",\n\t\t    pinfo.node_name, pinfo.port_name, pinfo.port_id);\n\t\tqla_nvme_fc_transport.dma_boundary = vha->host->dma_boundary;\n\n\t\tret = nvme_fc_register_localport(&pinfo, tmpl,\n\t\t\t\t\t\t get_device(&ha->pdev->dev),\n\t\t\t\t\t\t &vha->nvme_local_port);\n\t\tmutex_unlock(&ha->vport_lock);\n\t} else {\n\t\tmutex_unlock(&ha->vport_lock);\n\t\treturn 0;\n\t}\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"register_localport failed: ret=%x\\n\", ret);\n\t} else {\n\t\tvha->nvme_local_port->private = vha;\n\t}\n\n\treturn ret;\n}\n\nvoid qla_nvme_abort_set_option(struct abort_entry_24xx *abt, srb_t *orig_sp)\n{\n\tstruct qla_hw_data *ha;\n\n\tif (!(ql2xabts_wait_nvme && QLA_ABTS_WAIT_ENABLED(orig_sp)))\n\t\treturn;\n\n\tha = orig_sp->fcport->vha->hw;\n\n\tWARN_ON_ONCE(abt->options & cpu_to_le16(BIT_0));\n\t \n\tabt->options |= cpu_to_le16(AOF_ABTS_RTY_CNT);\n\tabt->drv.abts_rty_cnt = cpu_to_le16(2);\n\t \n\tabt->options |= cpu_to_le16(AOF_RSP_TIMEOUT);\n\t \n\tabt->drv.rsp_timeout = cpu_to_le16(2 * (ha->r_a_tov / 10));\n}\n\nvoid qla_nvme_abort_process_comp_status(struct abort_entry_24xx *abt, srb_t *orig_sp)\n{\n\tu16\tcomp_status;\n\tstruct scsi_qla_host *vha;\n\n\tif (!(ql2xabts_wait_nvme && QLA_ABTS_WAIT_ENABLED(orig_sp)))\n\t\treturn;\n\n\tvha = orig_sp->fcport->vha;\n\n\tcomp_status = le16_to_cpu(abt->comp_status);\n\tswitch (comp_status) {\n\tcase CS_RESET:\t\t \n\tcase CS_ABORTED:\t \n\t \n\tcase CS_TIMEOUT:\n\t \n\tcase CS_PORT_UNAVAILABLE:\n\t \n\tcase CS_PORT_LOGGED_OUT:\n\t \n\tcase CS_PORT_CONFIG_CHG:\n\t\tql_dbg(ql_dbg_async, vha, 0xf09d,\n\t\t       \"Abort I/O IOCB completed with error, comp_status=%x\\n\",\n\t\tcomp_status);\n\t\tbreak;\n\n\t \n\tcase CS_REJECT_RECEIVED:\n\t\tql_dbg(ql_dbg_async, vha, 0xf09e,\n\t\t       \"BA_RJT was received for the ABTS rjt_vendorUnique = %u\",\n\t\t\tabt->fw.ba_rjt_vendorUnique);\n\t\tql_dbg(ql_dbg_async + ql_dbg_mbx, vha, 0xf09e,\n\t\t       \"ba_rjt_reasonCodeExpl = %u, ba_rjt_reasonCode = %u\\n\",\n\t\t       abt->fw.ba_rjt_reasonCodeExpl, abt->fw.ba_rjt_reasonCode);\n\t\tbreak;\n\n\tcase CS_COMPLETE:\n\t\tql_dbg(ql_dbg_async + ql_dbg_verbose, vha, 0xf09f,\n\t\t       \"IOCB request is completed successfully comp_status=%x\\n\",\n\t\tcomp_status);\n\t\tbreak;\n\n\tcase CS_IOCB_ERROR:\n\t\tql_dbg(ql_dbg_async, vha, 0xf0a0,\n\t\t       \"IOCB request is failed, comp_status=%x\\n\", comp_status);\n\t\tbreak;\n\n\tdefault:\n\t\tql_dbg(ql_dbg_async, vha, 0xf0a1,\n\t\t       \"Invalid Abort IO IOCB Completion Status %x\\n\",\n\t\tcomp_status);\n\t\tbreak;\n\t}\n}\n\ninline void qla_wait_nvme_release_cmd_kref(srb_t *orig_sp)\n{\n\tif (!(ql2xabts_wait_nvme && QLA_ABTS_WAIT_ENABLED(orig_sp)))\n\t\treturn;\n\tkref_put(&orig_sp->cmd_kref, orig_sp->put_fn);\n}\n\nstatic void qla_nvme_fc_format_rjt(void *buf, u8 ls_cmd, u8 reason,\n\t\t\t\t   u8 explanation, u8 vendor)\n{\n\tstruct fcnvme_ls_rjt *rjt = buf;\n\n\trjt->w0.ls_cmd = FCNVME_LSDESC_RQST;\n\trjt->desc_list_len = fcnvme_lsdesc_len(sizeof(struct fcnvme_ls_rjt));\n\trjt->rqst.desc_tag = cpu_to_be32(FCNVME_LSDESC_RQST);\n\trjt->rqst.desc_len =\n\t\tfcnvme_lsdesc_len(sizeof(struct fcnvme_lsdesc_rqst));\n\trjt->rqst.w0.ls_cmd = ls_cmd;\n\trjt->rjt.desc_tag = cpu_to_be32(FCNVME_LSDESC_RJT);\n\trjt->rjt.desc_len = fcnvme_lsdesc_len(sizeof(struct fcnvme_lsdesc_rjt));\n\trjt->rjt.reason_code = reason;\n\trjt->rjt.reason_explanation = explanation;\n\trjt->rjt.vendor = vendor;\n}\n\nstatic void qla_nvme_lsrjt_pt_iocb(struct scsi_qla_host *vha,\n\t\t\t\t   struct pt_ls4_request *lsrjt_iocb,\n\t\t\t\t   struct qla_nvme_lsrjt_pt_arg *a)\n{\n\tlsrjt_iocb->entry_type = PT_LS4_REQUEST;\n\tlsrjt_iocb->entry_count = 1;\n\tlsrjt_iocb->sys_define = 0;\n\tlsrjt_iocb->entry_status = 0;\n\tlsrjt_iocb->handle = QLA_SKIP_HANDLE;\n\tlsrjt_iocb->nport_handle = a->nport_handle;\n\tlsrjt_iocb->exchange_address = a->xchg_address;\n\tlsrjt_iocb->vp_index = a->vp_idx;\n\n\tlsrjt_iocb->control_flags = cpu_to_le16(a->control_flags);\n\n\tput_unaligned_le64(a->tx_addr, &lsrjt_iocb->dsd[0].address);\n\tlsrjt_iocb->dsd[0].length = cpu_to_le32(a->tx_byte_count);\n\tlsrjt_iocb->tx_dseg_count = cpu_to_le16(1);\n\tlsrjt_iocb->tx_byte_count = cpu_to_le32(a->tx_byte_count);\n\n\tput_unaligned_le64(a->rx_addr, &lsrjt_iocb->dsd[1].address);\n\tlsrjt_iocb->dsd[1].length = 0;\n\tlsrjt_iocb->rx_dseg_count = 0;\n\tlsrjt_iocb->rx_byte_count = 0;\n}\n\nstatic int\nqla_nvme_ls_reject_iocb(struct scsi_qla_host *vha, struct qla_qpair *qp,\n\t\t\tstruct qla_nvme_lsrjt_pt_arg *a, bool is_xchg_terminate)\n{\n\tstruct pt_ls4_request *lsrjt_iocb;\n\n\tlsrjt_iocb = __qla2x00_alloc_iocbs(qp, NULL);\n\tif (!lsrjt_iocb) {\n\t\tql_log(ql_log_warn, vha, 0x210e,\n\t\t       \"qla2x00_alloc_iocbs failed.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tif (!is_xchg_terminate) {\n\t\tqla_nvme_fc_format_rjt((void *)vha->hw->lsrjt.c, a->opcode,\n\t\t\t\t       a->reason, a->explanation, 0);\n\n\t\ta->tx_byte_count = sizeof(struct fcnvme_ls_rjt);\n\t\ta->tx_addr = vha->hw->lsrjt.cdma;\n\t\ta->control_flags = CF_LS4_RESPONDER << CF_LS4_SHIFT;\n\n\t\tql_dbg(ql_dbg_unsol, vha, 0x211f,\n\t\t       \"Sending nvme fc ls reject ox_id %04x op %04x\\n\",\n\t\t       a->ox_id, a->opcode);\n\t\tql_dump_buffer(ql_dbg_unsol + ql_dbg_verbose, vha, 0x210f,\n\t\t\t       vha->hw->lsrjt.c, sizeof(*vha->hw->lsrjt.c));\n\t} else {\n\t\ta->tx_byte_count = 0;\n\t\ta->control_flags = CF_LS4_RESPONDER_TERM << CF_LS4_SHIFT;\n\t\tql_dbg(ql_dbg_unsol, vha, 0x2110,\n\t\t       \"Terminate nvme ls xchg 0x%x\\n\", a->xchg_address);\n\t}\n\n\tqla_nvme_lsrjt_pt_iocb(vha, lsrjt_iocb, a);\n\t \n\twmb();\n\tqla2x00_start_iocbs(vha, qp->req);\n\treturn 0;\n}\n\n \nstatic void\nqla2xxx_process_purls_pkt(struct scsi_qla_host *vha, struct purex_item *item)\n{\n\tstruct qla_nvme_unsol_ctx *uctx = item->purls_context;\n\tstruct qla_nvme_lsrjt_pt_arg a;\n\tint ret = 1;\n\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tret = nvme_fc_rcv_ls_req(uctx->fcport->nvme_remote_port, &uctx->lsrsp,\n\t\t\t\t &item->iocb, item->size);\n#endif\n\tif (ret) {\n\t\tql_dbg(ql_dbg_unsol, vha, 0x2125, \"NVMe transport ls_req failed\\n\");\n\t\tmemset((void *)&a, 0, sizeof(a));\n\t\ta.vp_idx = vha->vp_idx;\n\t\ta.nport_handle = uctx->nport_handle;\n\t\ta.xchg_address = uctx->exchange_address;\n\t\tqla_nvme_ls_reject_iocb(vha, vha->hw->base_qpair, &a, true);\n\t\tlist_del(&uctx->elem);\n\t\tkfree(uctx);\n\t}\n}\n\nstatic scsi_qla_host_t *\nqla2xxx_get_vha_from_vp_idx(struct qla_hw_data *ha, uint16_t vp_index)\n{\n\tscsi_qla_host_t *base_vha, *vha, *tvp;\n\tunsigned long flags;\n\n\tbase_vha = pci_get_drvdata(ha->pdev);\n\n\tif (!vp_index && !ha->num_vhosts)\n\t\treturn base_vha;\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tlist_for_each_entry_safe(vha, tvp, &ha->vp_list, list) {\n\t\tif (vha->vp_idx == vp_index) {\n\t\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\t\t\treturn vha;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\treturn NULL;\n}\n\nvoid qla2xxx_process_purls_iocb(void **pkt, struct rsp_que **rsp)\n{\n\tstruct nvme_fc_remote_port *rport;\n\tstruct qla_nvme_rport *qla_rport;\n\tstruct qla_nvme_lsrjt_pt_arg a;\n\tstruct pt_ls4_rx_unsol *p = *pkt;\n\tstruct qla_nvme_unsol_ctx *uctx;\n\tstruct rsp_que *rsp_q = *rsp;\n\tstruct qla_hw_data *ha;\n\tscsi_qla_host_t\t*vha;\n\tfc_port_t *fcport = NULL;\n\tstruct purex_item *item;\n\tport_id_t d_id = {0};\n\tport_id_t id = {0};\n\tu8 *opcode;\n\tbool xmt_reject = false;\n\n\tha = rsp_q->hw;\n\n\tvha = qla2xxx_get_vha_from_vp_idx(ha, p->vp_index);\n\tif (!vha) {\n\t\tql_log(ql_log_warn, NULL, 0x2110, \"Invalid vp index %d\\n\", p->vp_index);\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tmemset((void *)&a, 0, sizeof(a));\n\topcode = (u8 *)&p->payload[0];\n\ta.opcode = opcode[3];\n\ta.vp_idx = p->vp_index;\n\ta.nport_handle = p->nport_handle;\n\ta.ox_id = p->ox_id;\n\ta.xchg_address = p->exchange_address;\n\n\tid.b.domain = p->s_id.domain;\n\tid.b.area   = p->s_id.area;\n\tid.b.al_pa  = p->s_id.al_pa;\n\td_id.b.domain = p->d_id[2];\n\td_id.b.area   = p->d_id[1];\n\td_id.b.al_pa  = p->d_id[0];\n\n\tfcport = qla2x00_find_fcport_by_nportid(vha, &id, 0);\n\tif (!fcport) {\n\t\tql_dbg(ql_dbg_unsol, vha, 0x211e,\n\t\t       \"Failed to find sid=%06x did=%06x\\n\",\n\t\t       id.b24, d_id.b24);\n\t\ta.reason = FCNVME_RJT_RC_INV_ASSOC;\n\t\ta.explanation = FCNVME_RJT_EXP_NONE;\n\t\txmt_reject = true;\n\t\tgoto out;\n\t}\n\trport = fcport->nvme_remote_port;\n\tqla_rport = rport->private;\n\n\titem = qla27xx_copy_multiple_pkt(vha, pkt, rsp, true, false);\n\tif (!item) {\n\t\ta.reason = FCNVME_RJT_RC_LOGIC;\n\t\ta.explanation = FCNVME_RJT_EXP_NONE;\n\t\txmt_reject = true;\n\t\tgoto out;\n\t}\n\n\tuctx = kzalloc(sizeof(*uctx), GFP_ATOMIC);\n\tif (!uctx) {\n\t\tql_log(ql_log_info, vha, 0x2126, \"Failed allocate memory\\n\");\n\t\ta.reason = FCNVME_RJT_RC_LOGIC;\n\t\ta.explanation = FCNVME_RJT_EXP_NONE;\n\t\txmt_reject = true;\n\t\tkfree(item);\n\t\tgoto out;\n\t}\n\n\tuctx->vha = vha;\n\tuctx->fcport = fcport;\n\tuctx->exchange_address = p->exchange_address;\n\tuctx->nport_handle = p->nport_handle;\n\tuctx->ox_id = p->ox_id;\n\tqla_rport->uctx = uctx;\n\tINIT_LIST_HEAD(&uctx->elem);\n\tlist_add_tail(&uctx->elem, &fcport->unsol_ctx_head);\n\titem->purls_context = (void *)uctx;\n\n\tql_dbg(ql_dbg_unsol, vha, 0x2121,\n\t       \"PURLS OP[%01x] size %d xchg addr 0x%x portid %06x\\n\",\n\t       item->iocb.iocb[3], item->size, uctx->exchange_address,\n\t       fcport->d_id.b24);\n\t \n\tql_dump_buffer(ql_dbg_unsol + ql_dbg_verbose, vha, 0x2120,\n\t\t       &item->iocb, item->size);\n\n\tqla24xx_queue_purex_item(vha, item, qla2xxx_process_purls_pkt);\nout:\n\tif (xmt_reject) {\n\t\tqla_nvme_ls_reject_iocb(vha, (*rsp)->qpair, &a, false);\n\t\t__qla_consume_iocb(vha, pkt, rsp);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}