{
  "module_name": "qla_attr.c",
  "hash_id": "2adbea03d80d23c757bcb0ea4720397c7abbf76f012bce8bfde1a7eebe784933",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_attr.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_target.h\"\n\n#include <linux/kthread.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\nstatic int qla24xx_vport_disable(struct fc_vport *, bool);\n\n \n\nstatic ssize_t\nqla2x00_sysfs_read_fw_dump(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t   char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = 0;\n\n\tif (!(ha->fw_dump_reading || ha->mctp_dump_reading ||\n\t      ha->mpi_fw_dump_reading))\n\t\treturn 0;\n\n\tmutex_lock(&ha->optrom_mutex);\n\tif (IS_P3P_TYPE(ha)) {\n\t\tif (off < ha->md_template_size) {\n\t\t\trval = memory_read_from_buffer(buf, count,\n\t\t\t    &off, ha->md_tmplt_hdr, ha->md_template_size);\n\t\t} else {\n\t\t\toff -= ha->md_template_size;\n\t\t\trval = memory_read_from_buffer(buf, count,\n\t\t\t    &off, ha->md_dump, ha->md_dump_size);\n\t\t}\n\t} else if (ha->mctp_dumped && ha->mctp_dump_reading) {\n\t\trval = memory_read_from_buffer(buf, count, &off, ha->mctp_dump,\n\t\t    MCTP_DUMP_SIZE);\n\t} else if (ha->mpi_fw_dumped && ha->mpi_fw_dump_reading) {\n\t\trval = memory_read_from_buffer(buf, count, &off,\n\t\t\t\t\t       ha->mpi_fw_dump,\n\t\t\t\t\t       ha->mpi_fw_dump_len);\n\t} else if (ha->fw_dump_reading) {\n\t\trval = memory_read_from_buffer(buf, count, &off, ha->fw_dump,\n\t\t\t\t\tha->fw_dump_len);\n\t} else {\n\t\trval = 0;\n\t}\n\tmutex_unlock(&ha->optrom_mutex);\n\treturn rval;\n}\n\nstatic ssize_t\nqla2x00_sysfs_write_fw_dump(struct file *filp, struct kobject *kobj,\n\t\t\t    struct bin_attribute *bin_attr,\n\t\t\t    char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tint reading;\n\n\tif (off != 0)\n\t\treturn (0);\n\n\treading = simple_strtol(buf, NULL, 10);\n\tswitch (reading) {\n\tcase 0:\n\t\tif (!ha->fw_dump_reading)\n\t\t\tbreak;\n\n\t\tql_log(ql_log_info, vha, 0x705d,\n\t\t    \"Firmware dump cleared on (%ld).\\n\", vha->host_no);\n\n\t\tif (IS_P3P_TYPE(ha)) {\n\t\t\tqla82xx_md_free(vha);\n\t\t\tqla82xx_md_prep(vha);\n\t\t}\n\t\tha->fw_dump_reading = 0;\n\t\tha->fw_dumped = false;\n\t\tbreak;\n\tcase 1:\n\t\tif (ha->fw_dumped && !ha->fw_dump_reading) {\n\t\t\tha->fw_dump_reading = 1;\n\n\t\t\tql_log(ql_log_info, vha, 0x705e,\n\t\t\t    \"Raw firmware dump ready for read on (%ld).\\n\",\n\t\t\t    vha->host_no);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tqla2x00_alloc_fw_dump(vha);\n\t\tbreak;\n\tcase 3:\n\t\tif (IS_QLA82XX(ha)) {\n\t\t\tqla82xx_idc_lock(ha);\n\t\t\tqla82xx_set_reset_owner(vha);\n\t\t\tqla82xx_idc_unlock(ha);\n\t\t} else if (IS_QLA8044(ha)) {\n\t\t\tqla8044_idc_lock(ha);\n\t\t\tqla82xx_set_reset_owner(vha);\n\t\t\tqla8044_idc_unlock(ha);\n\t\t} else {\n\t\t\tqla2x00_system_error(vha);\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\tif (IS_P3P_TYPE(ha)) {\n\t\t\tif (ha->md_tmplt_hdr)\n\t\t\t\tql_dbg(ql_dbg_user, vha, 0x705b,\n\t\t\t\t    \"MiniDump supported with this firmware.\\n\");\n\t\t\telse\n\t\t\t\tql_dbg(ql_dbg_user, vha, 0x709d,\n\t\t\t\t    \"MiniDump not supported with this firmware.\\n\");\n\t\t}\n\t\tbreak;\n\tcase 5:\n\t\tif (IS_P3P_TYPE(ha))\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\tcase 6:\n\t\tif (!ha->mctp_dump_reading)\n\t\t\tbreak;\n\t\tql_log(ql_log_info, vha, 0x70c1,\n\t\t    \"MCTP dump cleared on (%ld).\\n\", vha->host_no);\n\t\tha->mctp_dump_reading = 0;\n\t\tha->mctp_dumped = 0;\n\t\tbreak;\n\tcase 7:\n\t\tif (ha->mctp_dumped && !ha->mctp_dump_reading) {\n\t\t\tha->mctp_dump_reading = 1;\n\t\t\tql_log(ql_log_info, vha, 0x70c2,\n\t\t\t    \"Raw mctp dump ready for read on (%ld).\\n\",\n\t\t\t    vha->host_no);\n\t\t}\n\t\tbreak;\n\tcase 8:\n\t\tif (!ha->mpi_fw_dump_reading)\n\t\t\tbreak;\n\t\tql_log(ql_log_info, vha, 0x70e7,\n\t\t       \"MPI firmware dump cleared on (%ld).\\n\", vha->host_no);\n\t\tha->mpi_fw_dump_reading = 0;\n\t\tha->mpi_fw_dumped = 0;\n\t\tbreak;\n\tcase 9:\n\t\tif (ha->mpi_fw_dumped && !ha->mpi_fw_dump_reading) {\n\t\t\tha->mpi_fw_dump_reading = 1;\n\t\t\tql_log(ql_log_info, vha, 0x70e8,\n\t\t\t       \"Raw MPI firmware dump ready for read on (%ld).\\n\",\n\t\t\t       vha->host_no);\n\t\t}\n\t\tbreak;\n\tcase 10:\n\t\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tql_log(ql_log_info, vha, 0x70e9,\n\t\t\t       \"Issuing MPI firmware dump on host#%ld.\\n\",\n\t\t\t       vha->host_no);\n\t\t\tha->isp_ops->mpi_fw_dump(vha, 0);\n\t\t}\n\t\tbreak;\n\t}\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_fw_dump_attr = {\n\t.attr = {\n\t\t.name = \"fw_dump\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 0,\n\t.read = qla2x00_sysfs_read_fw_dump,\n\t.write = qla2x00_sysfs_write_fw_dump,\n};\n\nstatic ssize_t\nqla2x00_sysfs_read_nvram(struct file *filp, struct kobject *kobj,\n\t\t\t struct bin_attribute *bin_attr,\n\t\t\t char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t faddr;\n\tstruct active_regions active_regions = { };\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn 0;\n\n\tmutex_lock(&ha->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!IS_NOCACHE_VPD_TYPE(ha)) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\tgoto skip;\n\t}\n\n\tfaddr = ha->flt_region_nvram;\n\tif (IS_QLA28XX(ha)) {\n\t\tqla28xx_get_aux_images(vha, &active_regions);\n\t\tif (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)\n\t\t\tfaddr = ha->flt_region_nvram_sec;\n\t}\n\tha->isp_ops->read_optrom(vha, ha->nvram, faddr << 2, ha->nvram_size);\n\n\tmutex_unlock(&ha->optrom_mutex);\n\nskip:\n\treturn memory_read_from_buffer(buf, count, &off, ha->nvram,\n\t\t\t\t\tha->nvram_size);\n}\n\nstatic ssize_t\nqla2x00_sysfs_write_nvram(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t\tcnt;\n\n\tif (!capable(CAP_SYS_ADMIN) || off != 0 || count != ha->nvram_size ||\n\t    !ha->isp_ops->write_nvram)\n\t\treturn -EINVAL;\n\n\t \n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\t__le32 *iter = (__force __le32 *)buf;\n\t\tuint32_t chksum;\n\n\t\tchksum = 0;\n\t\tfor (cnt = 0; cnt < ((count >> 2) - 1); cnt++, iter++)\n\t\t\tchksum += le32_to_cpu(*iter);\n\t\tchksum = ~chksum + 1;\n\t\t*iter = cpu_to_le32(chksum);\n\t} else {\n\t\tuint8_t *iter;\n\t\tuint8_t chksum;\n\n\t\titer = (uint8_t *)buf;\n\t\tchksum = 0;\n\t\tfor (cnt = 0; cnt < count - 1; cnt++)\n\t\t\tchksum += *iter++;\n\t\tchksum = ~chksum + 1;\n\t\t*iter = chksum;\n\t}\n\n\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x705f,\n\t\t    \"HBA not online, failing NVRAM update.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tmutex_lock(&ha->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tha->isp_ops->write_nvram(vha, buf, ha->nvram_base, count);\n\tha->isp_ops->read_nvram(vha, ha->nvram, ha->nvram_base,\n\t    count);\n\tmutex_unlock(&ha->optrom_mutex);\n\n\tql_dbg(ql_dbg_user, vha, 0x7060,\n\t    \"Setting ISP_ABORT_NEEDED\\n\");\n\t \n\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\tqla2xxx_wake_dpc(vha);\n\tqla2x00_wait_for_chip_reset(vha);\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_nvram_attr = {\n\t.attr = {\n\t\t.name = \"nvram\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 512,\n\t.read = qla2x00_sysfs_read_nvram,\n\t.write = qla2x00_sysfs_write_nvram,\n};\n\nstatic ssize_t\nqla2x00_sysfs_read_optrom(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tssize_t rval = 0;\n\n\tmutex_lock(&ha->optrom_mutex);\n\n\tif (ha->optrom_state != QLA_SREADING)\n\t\tgoto out;\n\n\trval = memory_read_from_buffer(buf, count, &off, ha->optrom_buffer,\n\t    ha->optrom_region_size);\n\nout:\n\tmutex_unlock(&ha->optrom_mutex);\n\n\treturn rval;\n}\n\nstatic ssize_t\nqla2x00_sysfs_write_optrom(struct file *filp, struct kobject *kobj,\n\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t   char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tmutex_lock(&ha->optrom_mutex);\n\n\tif (ha->optrom_state != QLA_SWRITING) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -EINVAL;\n\t}\n\tif (off > ha->optrom_region_size) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -ERANGE;\n\t}\n\tif (off + count > ha->optrom_region_size)\n\t\tcount = ha->optrom_region_size - off;\n\n\tmemcpy(&ha->optrom_buffer[off], buf, count);\n\tmutex_unlock(&ha->optrom_mutex);\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_optrom_attr = {\n\t.attr = {\n\t\t.name = \"optrom\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 0,\n\t.read = qla2x00_sysfs_read_optrom,\n\t.write = qla2x00_sysfs_write_optrom,\n};\n\nstatic ssize_t\nqla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,\n\t\t\t       struct bin_attribute *bin_attr,\n\t\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t start = 0;\n\tuint32_t size = ha->optrom_size;\n\tint val, valid;\n\tssize_t rval = count;\n\n\tif (off)\n\t\treturn -EINVAL;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn -EAGAIN;\n\n\tif (sscanf(buf, \"%d:%x:%x\", &val, &start, &size) < 1)\n\t\treturn -EINVAL;\n\tif (start > ha->optrom_size)\n\t\treturn -EINVAL;\n\tif (size > ha->optrom_size - start)\n\t\tsize = ha->optrom_size - start;\n\n\tmutex_lock(&ha->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -EAGAIN;\n\t}\n\tswitch (val) {\n\tcase 0:\n\t\tif (ha->optrom_state != QLA_SREADING &&\n\t\t    ha->optrom_state != QLA_SWRITING) {\n\t\t\trval =  -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tha->optrom_state = QLA_SWAITING;\n\n\t\tql_dbg(ql_dbg_user, vha, 0x7061,\n\t\t    \"Freeing flash region allocation -- 0x%x bytes.\\n\",\n\t\t    ha->optrom_region_size);\n\n\t\tvfree(ha->optrom_buffer);\n\t\tha->optrom_buffer = NULL;\n\t\tbreak;\n\tcase 1:\n\t\tif (ha->optrom_state != QLA_SWAITING) {\n\t\t\trval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tha->optrom_region_start = start;\n\t\tha->optrom_region_size = size;\n\n\t\tha->optrom_state = QLA_SREADING;\n\t\tha->optrom_buffer = vzalloc(ha->optrom_region_size);\n\t\tif (ha->optrom_buffer == NULL) {\n\t\t\tql_log(ql_log_warn, vha, 0x7062,\n\t\t\t    \"Unable to allocate memory for optrom retrieval \"\n\t\t\t    \"(%x).\\n\", ha->optrom_region_size);\n\n\t\t\tha->optrom_state = QLA_SWAITING;\n\t\t\trval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x7063,\n\t\t\t    \"HBA not online, failing NVRAM update.\\n\");\n\t\t\trval = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tql_dbg(ql_dbg_user, vha, 0x7064,\n\t\t    \"Reading flash region -- 0x%x/0x%x.\\n\",\n\t\t    ha->optrom_region_start, ha->optrom_region_size);\n\n\t\tha->isp_ops->read_optrom(vha, ha->optrom_buffer,\n\t\t    ha->optrom_region_start, ha->optrom_region_size);\n\t\tbreak;\n\tcase 2:\n\t\tif (ha->optrom_state != QLA_SWAITING) {\n\t\t\trval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tvalid = 0;\n\t\tif (ha->optrom_size == OPTROM_SIZE_2300 && start == 0)\n\t\t\tvalid = 1;\n\t\telse if (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha))\n\t\t\tvalid = 1;\n\t\tif (!valid) {\n\t\t\tql_log(ql_log_warn, vha, 0x7065,\n\t\t\t    \"Invalid start region 0x%x/0x%x.\\n\", start, size);\n\t\t\trval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tha->optrom_region_start = start;\n\t\tha->optrom_region_size = size;\n\n\t\tha->optrom_state = QLA_SWRITING;\n\t\tha->optrom_buffer = vzalloc(ha->optrom_region_size);\n\t\tif (ha->optrom_buffer == NULL) {\n\t\t\tql_log(ql_log_warn, vha, 0x7066,\n\t\t\t    \"Unable to allocate memory for optrom update \"\n\t\t\t    \"(%x)\\n\", ha->optrom_region_size);\n\n\t\t\tha->optrom_state = QLA_SWAITING;\n\t\t\trval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tql_dbg(ql_dbg_user, vha, 0x7067,\n\t\t    \"Staging flash region write -- 0x%x/0x%x.\\n\",\n\t\t    ha->optrom_region_start, ha->optrom_region_size);\n\n\t\tbreak;\n\tcase 3:\n\t\tif (ha->optrom_state != QLA_SWRITING) {\n\t\t\trval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x7068,\n\t\t\t    \"HBA not online, failing flash update.\\n\");\n\t\t\trval = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tql_dbg(ql_dbg_user, vha, 0x7069,\n\t\t    \"Writing flash region -- 0x%x/0x%x.\\n\",\n\t\t    ha->optrom_region_start, ha->optrom_region_size);\n\n\t\trval = ha->isp_ops->write_optrom(vha, ha->optrom_buffer,\n\t\t    ha->optrom_region_start, ha->optrom_region_size);\n\t\tif (rval)\n\t\t\trval = -EIO;\n\t\tbreak;\n\tdefault:\n\t\trval = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&ha->optrom_mutex);\n\treturn rval;\n}\n\nstatic struct bin_attribute sysfs_optrom_ctl_attr = {\n\t.attr = {\n\t\t.name = \"optrom_ctl\",\n\t\t.mode = S_IWUSR,\n\t},\n\t.size = 0,\n\t.write = qla2x00_sysfs_write_optrom_ctl,\n};\n\nstatic ssize_t\nqla2x00_sysfs_read_vpd(struct file *filp, struct kobject *kobj,\n\t\t       struct bin_attribute *bin_attr,\n\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t faddr;\n\tstruct active_regions active_regions = { };\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn -EAGAIN;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EINVAL;\n\n\tif (!IS_NOCACHE_VPD_TYPE(ha))\n\t\tgoto skip;\n\n\tfaddr = ha->flt_region_vpd << 2;\n\n\tif (IS_QLA28XX(ha)) {\n\t\tqla28xx_get_aux_images(vha, &active_regions);\n\t\tif (active_regions.aux.vpd_nvram == QLA27XX_SECONDARY_IMAGE)\n\t\t\tfaddr = ha->flt_region_vpd_sec << 2;\n\n\t\tql_dbg(ql_dbg_init, vha, 0x7070,\n\t\t    \"Loading %s nvram image.\\n\",\n\t\t    active_regions.aux.vpd_nvram == QLA27XX_PRIMARY_IMAGE ?\n\t\t    \"primary\" : \"secondary\");\n\t}\n\n\tmutex_lock(&ha->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\tha->isp_ops->read_optrom(vha, ha->vpd, faddr, ha->vpd_size);\n\tmutex_unlock(&ha->optrom_mutex);\n\n\tha->isp_ops->read_optrom(vha, ha->vpd, faddr, ha->vpd_size);\nskip:\n\treturn memory_read_from_buffer(buf, count, &off, ha->vpd, ha->vpd_size);\n}\n\nstatic ssize_t\nqla2x00_sysfs_write_vpd(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr,\n\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint8_t *tmp_data;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn 0;\n\n\tif (qla2x00_chip_is_down(vha))\n\t\treturn 0;\n\n\tif (!capable(CAP_SYS_ADMIN) || off != 0 || count != ha->vpd_size ||\n\t    !ha->isp_ops->write_nvram)\n\t\treturn 0;\n\n\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x706a,\n\t\t    \"HBA not online, failing VPD update.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tmutex_lock(&ha->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tha->isp_ops->write_nvram(vha, buf, ha->vpd_base, count);\n\tha->isp_ops->read_nvram(vha, ha->vpd, ha->vpd_base, count);\n\n\t \n\tif (!IS_FWI2_CAPABLE(ha)) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\ttmp_data = vmalloc(256);\n\tif (!tmp_data) {\n\t\tmutex_unlock(&ha->optrom_mutex);\n\t\tql_log(ql_log_warn, vha, 0x706b,\n\t\t    \"Unable to allocate memory for VPD information update.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tha->isp_ops->get_flash_version(vha, tmp_data);\n\tvfree(tmp_data);\n\n\tmutex_unlock(&ha->optrom_mutex);\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_vpd_attr = {\n\t.attr = {\n\t\t.name = \"vpd\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 0,\n\t.read = qla2x00_sysfs_read_vpd,\n\t.write = qla2x00_sysfs_write_vpd,\n};\n\nstatic ssize_t\nqla2x00_sysfs_read_sfp(struct file *filp, struct kobject *kobj,\n\t\t       struct bin_attribute *bin_attr,\n\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tint rval;\n\n\tif (!capable(CAP_SYS_ADMIN) || off != 0 || count < SFP_DEV_SIZE)\n\t\treturn 0;\n\n\tmutex_lock(&vha->hw->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\treturn 0;\n\t}\n\n\trval = qla2x00_read_sfp_dev(vha, buf, count);\n\tmutex_unlock(&vha->hw->optrom_mutex);\n\n\tif (rval)\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_sfp_attr = {\n\t.attr = {\n\t\t.name = \"sfp\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = SFP_DEV_SIZE,\n\t.read = qla2x00_sysfs_read_sfp,\n};\n\nstatic ssize_t\nqla2x00_sysfs_write_reset(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr,\n\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tint type;\n\tuint32_t idc_control;\n\tuint8_t *tmp_data = NULL;\n\n\tif (off != 0)\n\t\treturn -EINVAL;\n\n\ttype = simple_strtol(buf, NULL, 10);\n\tswitch (type) {\n\tcase 0x2025c:\n\t\tql_log(ql_log_info, vha, 0x706e,\n\t\t    \"Issuing ISP reset.\\n\");\n\n\t\tif (vha->hw->flags.port_isolated) {\n\t\t\tql_log(ql_log_info, vha, 0x706e,\n\t\t\t       \"Port is isolated, returning.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tscsi_block_requests(vha->host);\n\t\tif (IS_QLA82XX(ha)) {\n\t\t\tha->flags.isp82xx_no_md_cap = 1;\n\t\t\tqla82xx_idc_lock(ha);\n\t\t\tqla82xx_set_reset_owner(vha);\n\t\t\tqla82xx_idc_unlock(ha);\n\t\t} else if (IS_QLA8044(ha)) {\n\t\t\tqla8044_idc_lock(ha);\n\t\t\tidc_control = qla8044_rd_reg(ha,\n\t\t\t    QLA8044_IDC_DRV_CTRL);\n\t\t\tqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL,\n\t\t\t    (idc_control | GRACEFUL_RESET_BIT1));\n\t\t\tqla82xx_set_reset_owner(vha);\n\t\t\tqla8044_idc_unlock(ha);\n\t\t} else {\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t}\n\t\tqla2x00_wait_for_chip_reset(vha);\n\t\tscsi_unblock_requests(vha->host);\n\t\tbreak;\n\tcase 0x2025d:\n\t\tif (!IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\n\t\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\t\treturn -EPERM;\n\n\t\tql_log(ql_log_info, vha, 0x706f,\n\t\t    \"Issuing MPI reset.\\n\");\n\n\t\tif (IS_QLA83XX(ha)) {\n\t\t\tuint32_t idc_control;\n\n\t\t\tqla83xx_idc_lock(vha, 0);\n\t\t\t__qla83xx_get_idc_control(vha, &idc_control);\n\t\t\tidc_control |= QLA83XX_IDC_GRACEFUL_RESET;\n\t\t\t__qla83xx_set_idc_control(vha, idc_control);\n\t\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE,\n\t\t\t    QLA8XXX_DEV_NEED_RESET);\n\t\t\tqla83xx_idc_audit(vha, IDC_AUDIT_TIMESTAMP);\n\t\t\tqla83xx_idc_unlock(vha, 0);\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ON_ONCE(qla2x00_wait_for_hba_online(vha) !=\n\t\t\t\t     QLA_SUCCESS);\n\n\t\t\t \n\t\t\tscsi_block_requests(vha->host);\n\t\t\tif (qla81xx_restart_mpi_firmware(vha) != QLA_SUCCESS)\n\t\t\t\tql_log(ql_log_warn, vha, 0x7070,\n\t\t\t\t    \"MPI reset failed.\\n\");\n\t\t\tscsi_unblock_requests(vha->host);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x2025e:\n\t\tif (!IS_P3P_TYPE(ha) || vha != base_vha) {\n\t\t\tql_log(ql_log_info, vha, 0x7071,\n\t\t\t    \"FCoE ctx reset not supported.\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tql_log(ql_log_info, vha, 0x7072,\n\t\t    \"Issuing FCoE ctx reset.\\n\");\n\t\tset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\t\tqla2x00_wait_for_fcoe_ctx_reset(vha);\n\t\tbreak;\n\tcase 0x2025f:\n\t\tif (!IS_QLA8031(ha))\n\t\t\treturn -EPERM;\n\t\tql_log(ql_log_info, vha, 0x70bc,\n\t\t    \"Disabling Reset by IDC control\\n\");\n\t\tqla83xx_idc_lock(vha, 0);\n\t\t__qla83xx_get_idc_control(vha, &idc_control);\n\t\tidc_control |= QLA83XX_IDC_RESET_DISABLED;\n\t\t__qla83xx_set_idc_control(vha, idc_control);\n\t\tqla83xx_idc_unlock(vha, 0);\n\t\tbreak;\n\tcase 0x20260:\n\t\tif (!IS_QLA8031(ha))\n\t\t\treturn -EPERM;\n\t\tql_log(ql_log_info, vha, 0x70bd,\n\t\t    \"Enabling Reset by IDC control\\n\");\n\t\tqla83xx_idc_lock(vha, 0);\n\t\t__qla83xx_get_idc_control(vha, &idc_control);\n\t\tidc_control &= ~QLA83XX_IDC_RESET_DISABLED;\n\t\t__qla83xx_set_idc_control(vha, idc_control);\n\t\tqla83xx_idc_unlock(vha, 0);\n\t\tbreak;\n\tcase 0x20261:\n\t\tql_dbg(ql_dbg_user, vha, 0x70e0,\n\t\t    \"Updating cache versions without reset \");\n\n\t\ttmp_data = vmalloc(256);\n\t\tif (!tmp_data) {\n\t\t\tql_log(ql_log_warn, vha, 0x70e1,\n\t\t\t    \"Unable to allocate memory for VPD information update.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tha->isp_ops->get_flash_version(vha, tmp_data);\n\t\tvfree(tmp_data);\n\t\tbreak;\n\t}\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_reset_attr = {\n\t.attr = {\n\t\t.name = \"reset\",\n\t\t.mode = S_IWUSR,\n\t},\n\t.size = 0,\n\t.write = qla2x00_sysfs_write_reset,\n};\n\nstatic ssize_t\nqla2x00_issue_logo(struct file *filp, struct kobject *kobj,\n\t\t\tstruct bin_attribute *bin_attr,\n\t\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tint type;\n\tport_id_t did;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn 0;\n\n\tif (unlikely(pci_channel_offline(vha->hw->pdev)))\n\t\treturn 0;\n\n\tif (qla2x00_chip_is_down(vha))\n\t\treturn 0;\n\n\ttype = simple_strtol(buf, NULL, 10);\n\n\tdid.b.domain = (type & 0x00ff0000) >> 16;\n\tdid.b.area = (type & 0x0000ff00) >> 8;\n\tdid.b.al_pa = (type & 0x000000ff);\n\n\tql_log(ql_log_info, vha, 0xd04d, \"portid=%02x%02x%02x done\\n\",\n\t    did.b.domain, did.b.area, did.b.al_pa);\n\n\tql_log(ql_log_info, vha, 0x70e4, \"%s: %d\\n\", __func__, type);\n\n\tqla24xx_els_dcmd_iocb(vha, ELS_DCMD_LOGO, did);\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_issue_logo_attr = {\n\t.attr = {\n\t\t.name = \"issue_logo\",\n\t\t.mode = S_IWUSR,\n\t},\n\t.size = 0,\n\t.write = qla2x00_issue_logo,\n};\n\nstatic ssize_t\nqla2x00_sysfs_read_xgmac_stats(struct file *filp, struct kobject *kobj,\n\t\t       struct bin_attribute *bin_attr,\n\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\tuint16_t actual_size;\n\n\tif (!capable(CAP_SYS_ADMIN) || off != 0 || count > XGMAC_DATA_SIZE)\n\t\treturn 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn 0;\n\tmutex_lock(&vha->hw->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\treturn 0;\n\t}\n\n\tif (ha->xgmac_data)\n\t\tgoto do_read;\n\n\tha->xgmac_data = dma_alloc_coherent(&ha->pdev->dev, XGMAC_DATA_SIZE,\n\t    &ha->xgmac_data_dma, GFP_KERNEL);\n\tif (!ha->xgmac_data) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\tql_log(ql_log_warn, vha, 0x7076,\n\t\t    \"Unable to allocate memory for XGMAC read-data.\\n\");\n\t\treturn 0;\n\t}\n\ndo_read:\n\tactual_size = 0;\n\tmemset(ha->xgmac_data, 0, XGMAC_DATA_SIZE);\n\n\trval = qla2x00_get_xgmac_stats(vha, ha->xgmac_data_dma,\n\t    XGMAC_DATA_SIZE, &actual_size);\n\n\tmutex_unlock(&vha->hw->optrom_mutex);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x7077,\n\t\t    \"Unable to read XGMAC data (%x).\\n\", rval);\n\t\tcount = 0;\n\t}\n\n\tcount = actual_size > count ? count : actual_size;\n\tmemcpy(buf, ha->xgmac_data, count);\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_xgmac_stats_attr = {\n\t.attr = {\n\t\t.name = \"xgmac_stats\",\n\t\t.mode = S_IRUSR,\n\t},\n\t.size = 0,\n\t.read = qla2x00_sysfs_read_xgmac_stats,\n};\n\nstatic ssize_t\nqla2x00_sysfs_read_dcbx_tlv(struct file *filp, struct kobject *kobj,\n\t\t       struct bin_attribute *bin_attr,\n\t\t       char *buf, loff_t off, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(container_of(kobj,\n\t    struct device, kobj)));\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\n\tif (!capable(CAP_SYS_ADMIN) || off != 0 || count > DCBX_TLV_DATA_SIZE)\n\t\treturn 0;\n\n\tmutex_lock(&vha->hw->optrom_mutex);\n\tif (ha->dcbx_tlv)\n\t\tgoto do_read;\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\treturn 0;\n\t}\n\n\tha->dcbx_tlv = dma_alloc_coherent(&ha->pdev->dev, DCBX_TLV_DATA_SIZE,\n\t    &ha->dcbx_tlv_dma, GFP_KERNEL);\n\tif (!ha->dcbx_tlv) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\tql_log(ql_log_warn, vha, 0x7078,\n\t\t    \"Unable to allocate memory for DCBX TLV read-data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\ndo_read:\n\tmemset(ha->dcbx_tlv, 0, DCBX_TLV_DATA_SIZE);\n\n\trval = qla2x00_get_dcbx_params(vha, ha->dcbx_tlv_dma,\n\t    DCBX_TLV_DATA_SIZE);\n\n\tmutex_unlock(&vha->hw->optrom_mutex);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x7079,\n\t\t    \"Unable to read DCBX TLV (%x).\\n\", rval);\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(buf, ha->dcbx_tlv, count);\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_dcbx_tlv_attr = {\n\t.attr = {\n\t\t.name = \"dcbx_tlv\",\n\t\t.mode = S_IRUSR,\n\t},\n\t.size = 0,\n\t.read = qla2x00_sysfs_read_dcbx_tlv,\n};\n\nstatic struct sysfs_entry {\n\tchar *name;\n\tstruct bin_attribute *attr;\n\tint type;\n} bin_file_entries[] = {\n\t{ \"fw_dump\", &sysfs_fw_dump_attr, },\n\t{ \"nvram\", &sysfs_nvram_attr, },\n\t{ \"optrom\", &sysfs_optrom_attr, },\n\t{ \"optrom_ctl\", &sysfs_optrom_ctl_attr, },\n\t{ \"vpd\", &sysfs_vpd_attr, 1 },\n\t{ \"sfp\", &sysfs_sfp_attr, 1 },\n\t{ \"reset\", &sysfs_reset_attr, },\n\t{ \"issue_logo\", &sysfs_issue_logo_attr, },\n\t{ \"xgmac_stats\", &sysfs_xgmac_stats_attr, 3 },\n\t{ \"dcbx_tlv\", &sysfs_dcbx_tlv_attr, 3 },\n\t{ NULL },\n};\n\nvoid\nqla2x00_alloc_sysfs_attr(scsi_qla_host_t *vha)\n{\n\tstruct Scsi_Host *host = vha->host;\n\tstruct sysfs_entry *iter;\n\tint ret;\n\n\tfor (iter = bin_file_entries; iter->name; iter++) {\n\t\tif (iter->type && !IS_FWI2_CAPABLE(vha->hw))\n\t\t\tcontinue;\n\t\tif (iter->type == 2 && !IS_QLA25XX(vha->hw))\n\t\t\tcontinue;\n\t\tif (iter->type == 3 && !(IS_CNA_CAPABLE(vha->hw)))\n\t\t\tcontinue;\n\n\t\tret = sysfs_create_bin_file(&host->shost_gendev.kobj,\n\t\t    iter->attr);\n\t\tif (ret)\n\t\t\tql_log(ql_log_warn, vha, 0x00f3,\n\t\t\t    \"Unable to create sysfs %s binary attribute (%d).\\n\",\n\t\t\t    iter->name, ret);\n\t\telse\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00f4,\n\t\t\t    \"Successfully created sysfs %s binary attribute.\\n\",\n\t\t\t    iter->name);\n\t}\n}\n\nvoid\nqla2x00_free_sysfs_attr(scsi_qla_host_t *vha, bool stop_beacon)\n{\n\tstruct Scsi_Host *host = vha->host;\n\tstruct sysfs_entry *iter;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tfor (iter = bin_file_entries; iter->name; iter++) {\n\t\tif (iter->type && !IS_FWI2_CAPABLE(ha))\n\t\t\tcontinue;\n\t\tif (iter->type == 2 && !IS_QLA25XX(ha))\n\t\t\tcontinue;\n\t\tif (iter->type == 3 && !(IS_CNA_CAPABLE(ha)))\n\t\t\tcontinue;\n\n\t\tsysfs_remove_bin_file(&host->shost_gendev.kobj,\n\t\t    iter->attr);\n\t}\n\n\tif (stop_beacon && ha->beacon_blink_led == 1)\n\t\tha->isp_ops->beacon_off(vha);\n}\n\n \n\nstatic ssize_t\nqla2x00_driver_version_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", qla2x00_version_str);\n}\n\nstatic ssize_t\nqla2x00_fw_version_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tchar fw_str[128];\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t    ha->isp_ops->fw_version_str(vha, fw_str, sizeof(fw_str)));\n}\n\nstatic ssize_t\nqla2x00_serial_num_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t sn;\n\n\tif (IS_QLAFX00(vha->hw)) {\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t    vha->hw->mr.serial_num);\n\t} else if (IS_FWI2_CAPABLE(ha)) {\n\t\tqla2xxx_get_vpd_field(vha, \"SN\", buf, PAGE_SIZE - 1);\n\t\treturn strlen(strcat(buf, \"\\n\"));\n\t}\n\n\tsn = ((ha->serial0 & 0x1f) << 16) | (ha->serial2 << 8) | ha->serial1;\n\treturn scnprintf(buf, PAGE_SIZE, \"%c%05d\\n\", 'A' + sn / 100000,\n\t    sn % 100000);\n}\n\nstatic ssize_t\nqla2x00_isp_name_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"ISP%04X\\n\", vha->hw->pdev->device);\n}\n\nstatic ssize_t\nqla2x00_isp_id_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLAFX00(vha->hw))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t    vha->hw->mr.hw_version);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%04x %04x %04x %04x\\n\",\n\t    ha->product_id[0], ha->product_id[1], ha->product_id[2],\n\t    ha->product_id[3]);\n}\n\nstatic ssize_t\nqla2x00_model_name_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", vha->hw->model_number);\n}\n\nstatic ssize_t\nqla2x00_model_desc_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", vha->hw->model_desc);\n}\n\nstatic ssize_t\nqla2x00_pci_info_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tchar pci_info[30];\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t vha->hw->isp_ops->pci_info_str(vha, pci_info,\n\t\t\t\t\t\t\tsizeof(pci_info)));\n}\n\nstatic ssize_t\nqla2x00_link_state_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tint len = 0;\n\n\tif (atomic_read(&vha->loop_state) == LOOP_DOWN ||\n\t    atomic_read(&vha->loop_state) == LOOP_DEAD ||\n\t    vha->device_flags & DFLG_NO_CABLE)\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"Link Down\\n\");\n\telse if (atomic_read(&vha->loop_state) != LOOP_READY ||\n\t    qla2x00_chip_is_down(vha))\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"Unknown Link State\\n\");\n\telse {\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"Link Up - \");\n\n\t\tswitch (ha->current_topology) {\n\t\tcase ISP_CFG_NL:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Loop\\n\");\n\t\t\tbreak;\n\t\tcase ISP_CFG_FL:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"FL_Port\\n\");\n\t\t\tbreak;\n\t\tcase ISP_CFG_N:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t    \"N_Port to N_Port\\n\");\n\t\t\tbreak;\n\t\tcase ISP_CFG_F:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"F_Port\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Loop\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn len;\n}\n\nstatic ssize_t\nqla2x00_zio_show(struct device *dev, struct device_attribute *attr,\n\t\t char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint len = 0;\n\n\tswitch (vha->hw->zio_mode) {\n\tcase QLA_ZIO_MODE_6:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Mode 6\\n\");\n\t\tbreak;\n\tcase QLA_ZIO_DISABLED:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Disabled\\n\");\n\t\tbreak;\n\t}\n\treturn len;\n}\n\nstatic ssize_t\nqla2x00_zio_store(struct device *dev, struct device_attribute *attr,\n\t\t  const char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tint val = 0;\n\tuint16_t zio_mode;\n\n\tif (!IS_ZIO_SUPPORTED(ha))\n\t\treturn -ENOTSUPP;\n\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\tzio_mode = QLA_ZIO_MODE_6;\n\telse\n\t\tzio_mode = QLA_ZIO_DISABLED;\n\n\t \n\tif (zio_mode != QLA_ZIO_DISABLED || ha->zio_mode != QLA_ZIO_DISABLED) {\n\t\tha->zio_mode = zio_mode;\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t}\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nqla2x00_zio_timer_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d us\\n\", vha->hw->zio_timer * 100);\n}\n\nstatic ssize_t\nqla2x00_zio_timer_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint val = 0;\n\tuint16_t zio_timer;\n\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val > 25500 || val < 100)\n\t\treturn -ERANGE;\n\n\tzio_timer = (uint16_t)(val / 100);\n\tvha->hw->zio_timer = zio_timer;\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nqla_zio_threshold_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d exchanges\\n\",\n\t    vha->hw->last_zio_threshold);\n}\n\nstatic ssize_t\nqla_zio_threshold_store(struct device *dev, struct device_attribute *attr,\n    const char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint val = 0;\n\n\tif (vha->hw->zio_mode != QLA_ZIO_MODE_6)\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val < 0 || val > 256)\n\t\treturn -ERANGE;\n\n\tatomic_set(&vha->hw->zio_threshold, val);\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nqla2x00_beacon_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint len = 0;\n\n\tif (vha->hw->beacon_blink_led)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Enabled\\n\");\n\telse\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Disabled\\n\");\n\treturn len;\n}\n\nstatic ssize_t\nqla2x00_beacon_store(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tint val = 0;\n\tint rval;\n\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha))\n\t\treturn -EPERM;\n\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&vha->hw->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\tql_log(ql_log_warn, vha, 0x707a,\n\t\t    \"Abort ISP active -- ignoring beacon request.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (val)\n\t\trval = ha->isp_ops->beacon_on(vha);\n\telse\n\t\trval = ha->isp_ops->beacon_off(vha);\n\n\tif (rval != QLA_SUCCESS)\n\t\tcount = 0;\n\n\tmutex_unlock(&vha->hw->optrom_mutex);\n\n\treturn count;\n}\n\nstatic ssize_t\nqla2x00_beacon_config_show(struct device *dev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t led[3] = { 0 };\n\n\tif (!IS_QLA2031(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn -EPERM;\n\n\tif (ql26xx_led_config(vha, 0, led))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%#04hx %#04hx %#04hx\\n\",\n\t    led[0], led[1], led[2]);\n}\n\nstatic ssize_t\nqla2x00_beacon_config_store(struct device *dev, struct device_attribute *attr,\n\tconst char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t options = BIT_0;\n\tuint16_t led[3] = { 0 };\n\tuint16_t word[4];\n\tint n;\n\n\tif (!IS_QLA2031(ha) && !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn -EPERM;\n\n\tn = sscanf(buf, \"%hx %hx %hx %hx\", word+0, word+1, word+2, word+3);\n\tif (n == 4) {\n\t\tif (word[0] == 3) {\n\t\t\toptions |= BIT_3|BIT_2|BIT_1;\n\t\t\tled[0] = word[1];\n\t\t\tled[1] = word[2];\n\t\t\tled[2] = word[3];\n\t\t\tgoto write;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tif (n == 2) {\n\t\t \n\t\tif (word[0] == 0) {\n\t\t\toptions |= BIT_2;\n\t\t\tled[0] = word[1];\n\t\t\tgoto write;\n\t\t}\n\t\tif (word[0] == 1) {\n\t\t\toptions |= BIT_3;\n\t\t\tled[1] = word[1];\n\t\t\tgoto write;\n\t\t}\n\t\tif (word[0] == 2) {\n\t\t\toptions |= BIT_1;\n\t\t\tled[2] = word[1];\n\t\t\tgoto write;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n\nwrite:\n\tif (ql26xx_led_config(vha, options, led))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic ssize_t\nqla2x00_optrom_bios_version_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d\\n\", ha->bios_revision[1],\n\t    ha->bios_revision[0]);\n}\n\nstatic ssize_t\nqla2x00_optrom_efi_version_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d\\n\", ha->efi_revision[1],\n\t    ha->efi_revision[0]);\n}\n\nstatic ssize_t\nqla2x00_optrom_fcode_version_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d\\n\", ha->fcode_revision[1],\n\t    ha->fcode_revision[0]);\n}\n\nstatic ssize_t\nqla2x00_optrom_fw_version_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d.%02d %d\\n\",\n\t    ha->fw_revision[0], ha->fw_revision[1], ha->fw_revision[2],\n\t    ha->fw_revision[3]);\n}\n\nstatic ssize_t\nqla2x00_optrom_gold_fw_version_show(struct device *dev,\n    struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA83XX(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d.%02d (%d)\\n\",\n\t    ha->gold_fw_version[0], ha->gold_fw_version[1],\n\t    ha->gold_fw_version[2], ha->gold_fw_version[3]);\n}\n\nstatic ssize_t\nqla2x00_total_isp_aborts_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t    vha->qla_stats.total_isp_aborts);\n}\n\nstatic ssize_t\nqla24xx_84xx_fw_version_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tint rval = QLA_SUCCESS;\n\tuint16_t status[2] = { 0 };\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA84XX(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\tif (!ha->cs84xx->op_fw_version) {\n\t\trval = qla84xx_verify_chip(vha, status);\n\n\t\tif (!rval && !status[0])\n\t\t\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\",\n\t\t\t    (uint32_t)ha->cs84xx->op_fw_version);\n\t}\n\n\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n}\n\nstatic ssize_t\nqla2x00_serdes_version_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d.%02d\\n\",\n\t    ha->serdes_version[0], ha->serdes_version[1],\n\t    ha->serdes_version[2]);\n}\n\nstatic ssize_t\nqla2x00_mpi_version_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA8031(ha) && !IS_QLA8044(ha) &&\n\t    !IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d.%02d (%x)\\n\",\n\t    ha->mpi_version[0], ha->mpi_version[1], ha->mpi_version[2],\n\t    ha->mpi_capabilities);\n}\n\nstatic ssize_t\nqla2x00_phy_version_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA81XX(ha) && !IS_QLA8031(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d.%02d\\n\",\n\t    ha->phy_version[0], ha->phy_version[1], ha->phy_version[2]);\n}\n\nstatic ssize_t\nqla2x00_flash_block_size_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%x\\n\", ha->fdt_block_size);\n}\n\nstatic ssize_t\nqla2x00_vlan_id_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\tif (!IS_CNA_CAPABLE(vha->hw))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", vha->fcoe_vlan_id);\n}\n\nstatic ssize_t\nqla2x00_vn_port_mac_address_show(struct device *dev,\n    struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\tif (!IS_CNA_CAPABLE(vha->hw))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%pMR\\n\", vha->fcoe_vn_port_mac);\n}\n\nstatic ssize_t\nqla2x00_fabric_param_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", vha->hw->switch_cap);\n}\n\nstatic ssize_t\nqla2x00_thermal_temp_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tuint16_t temp = 0;\n\tint rc;\n\n\tmutex_lock(&vha->hw->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\tql_log(ql_log_warn, vha, 0x70dc, \"ISP reset active.\\n\");\n\t\tgoto done;\n\t}\n\n\tif (vha->hw->flags.eeh_busy) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\tql_log(ql_log_warn, vha, 0x70dd, \"PCI EEH busy.\\n\");\n\t\tgoto done;\n\t}\n\n\trc = qla2x00_get_thermal_temp(vha, &temp);\n\tmutex_unlock(&vha->hw->optrom_mutex);\n\tif (rc == QLA_SUCCESS)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", temp);\n\ndone:\n\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n}\n\nstatic ssize_t\nqla2x00_fw_state_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint rval = QLA_FUNCTION_FAILED;\n\tuint16_t state[6];\n\tuint32_t pstate;\n\n\tif (IS_QLAFX00(vha->hw)) {\n\t\tpstate = qlafx00_fw_state_show(dev, attr, buf);\n\t\treturn scnprintf(buf, PAGE_SIZE, \"0x%x\\n\", pstate);\n\t}\n\n\tmutex_lock(&vha->hw->optrom_mutex);\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\tql_log(ql_log_warn, vha, 0x707c,\n\t\t    \"ISP reset active.\\n\");\n\t\tgoto out;\n\t} else if (vha->hw->flags.eeh_busy) {\n\t\tmutex_unlock(&vha->hw->optrom_mutex);\n\t\tgoto out;\n\t}\n\n\trval = qla2x00_get_firmware_state(vha, state);\n\tmutex_unlock(&vha->hw->optrom_mutex);\nout:\n\tif (rval != QLA_SUCCESS) {\n\t\tmemset(state, -1, sizeof(state));\n\t\trval = qla2x00_get_firmware_state(vha, state);\n\t}\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t    state[0], state[1], state[2], state[3], state[4], state[5]);\n}\n\nstatic ssize_t\nqla2x00_diag_requests_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\tif (!IS_BIDI_CAPABLE(vha->hw))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\", vha->bidi_stats.io_count);\n}\n\nstatic ssize_t\nqla2x00_diag_megabytes_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\tif (!IS_BIDI_CAPABLE(vha->hw))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t    vha->bidi_stats.transfer_bytes >> 20);\n}\n\nstatic ssize_t\nqla2x00_fw_dump_size_show(struct device *dev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t size;\n\n\tif (!ha->fw_dumped)\n\t\tsize = 0;\n\telse if (IS_P3P_TYPE(ha))\n\t\tsize = ha->md_template_size + ha->md_dump_size;\n\telse\n\t\tsize = ha->fw_dump_len;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", size);\n}\n\nstatic ssize_t\nqla2x00_allow_cna_fw_dump_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\tif (!IS_P3P_TYPE(vha->hw))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\telse\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t    vha->hw->allow_cna_fw_dump ? \"true\" : \"false\");\n}\n\nstatic ssize_t\nqla2x00_allow_cna_fw_dump_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint val = 0;\n\n\tif (!IS_P3P_TYPE(vha->hw))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tvha->hw->allow_cna_fw_dump = val != 0;\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nqla2x00_pep_version_show(struct device *dev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d.%02d.%02d\\n\",\n\t    ha->pep_version[0], ha->pep_version[1], ha->pep_version[2]);\n}\n\nstatic ssize_t\nqla2x00_min_supported_speed_show(struct device *dev,\n    struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t    ha->min_supported_speed == 6 ? \"64Gps\" :\n\t    ha->min_supported_speed == 5 ? \"32Gps\" :\n\t    ha->min_supported_speed == 4 ? \"16Gps\" :\n\t    ha->min_supported_speed == 3 ? \"8Gps\" :\n\t    ha->min_supported_speed == 2 ? \"4Gps\" :\n\t    ha->min_supported_speed != 0 ? \"unknown\" : \"\");\n}\n\nstatic ssize_t\nqla2x00_max_supported_speed_show(struct device *dev,\n    struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t    ha->max_supported_speed  == 2 ? \"64Gps\" :\n\t    ha->max_supported_speed  == 1 ? \"32Gps\" :\n\t    ha->max_supported_speed  == 0 ? \"16Gps\" : \"unknown\");\n}\n\nstatic ssize_t\nqla2x00_port_speed_store(struct device *dev, struct device_attribute *attr,\n    const char *buf, size_t count)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(dev));\n\tulong type, speed;\n\tint oldspeed, rval;\n\tint mode = QLA_SET_DATA_RATE_LR;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha)) {\n\t\tql_log(ql_log_warn, vha, 0x70d8,\n\t\t    \"Speed setting not supported \\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trval = kstrtol(buf, 10, &type);\n\tif (rval)\n\t\treturn rval;\n\tspeed = type;\n\tif (type == 40 || type == 80 || type == 160 ||\n\t    type == 320) {\n\t\tql_dbg(ql_dbg_user, vha, 0x70d9,\n\t\t    \"Setting will be affected after a loss of sync\\n\");\n\t\ttype = type/10;\n\t\tmode = QLA_SET_DATA_RATE_NOLR;\n\t}\n\n\toldspeed = ha->set_data_rate;\n\n\tswitch (type) {\n\tcase 0:\n\t\tha->set_data_rate = PORT_SPEED_AUTO;\n\t\tbreak;\n\tcase 4:\n\t\tha->set_data_rate = PORT_SPEED_4GB;\n\t\tbreak;\n\tcase 8:\n\t\tha->set_data_rate = PORT_SPEED_8GB;\n\t\tbreak;\n\tcase 16:\n\t\tha->set_data_rate = PORT_SPEED_16GB;\n\t\tbreak;\n\tcase 32:\n\t\tha->set_data_rate = PORT_SPEED_32GB;\n\t\tbreak;\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0x1199,\n\t\t    \"Unrecognized speed setting:%lx. Setting Autoneg\\n\",\n\t\t    speed);\n\t\tha->set_data_rate = PORT_SPEED_AUTO;\n\t}\n\n\tif (qla2x00_chip_is_down(vha) || (oldspeed == ha->set_data_rate))\n\t\treturn -EINVAL;\n\n\tql_log(ql_log_info, vha, 0x70da,\n\t    \"Setting speed to %lx Gbps \\n\", type);\n\n\trval = qla2x00_set_data_rate(vha, mode);\n\tif (rval != QLA_SUCCESS)\n\t\treturn -EIO;\n\n\treturn strlen(buf);\n}\n\nstatic const struct {\n\tu16 rate;\n\tchar *str;\n} port_speed_str[] = {\n\t{ PORT_SPEED_4GB, \"4\" },\n\t{ PORT_SPEED_8GB, \"8\" },\n\t{ PORT_SPEED_16GB, \"16\" },\n\t{ PORT_SPEED_32GB, \"32\" },\n\t{ PORT_SPEED_64GB, \"64\" },\n\t{ PORT_SPEED_10GB, \"10\" },\n};\n\nstatic ssize_t\nqla2x00_port_speed_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tstruct scsi_qla_host *vha = shost_priv(dev_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\tssize_t rval;\n\tu16 i;\n\tchar *speed = \"Unknown\";\n\n\trval = qla2x00_get_data_rate(vha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x70db,\n\t\t    \"Unable to get port speed rval:%zd\\n\", rval);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(port_speed_str); i++) {\n\t\tif (port_speed_str[i].rate != ha->link_data_rate)\n\t\t\tcontinue;\n\t\tspeed = port_speed_str[i].str;\n\t\tbreak;\n\t}\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", speed);\n}\n\nstatic ssize_t\nqla2x00_mpi_pause_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint rval = 0;\n\n\tif (sscanf(buf, \"%d\", &rval) != 1)\n\t\treturn -EINVAL;\n\n\tql_log(ql_log_warn, vha, 0x7089, \"Pausing MPI...\\n\");\n\n\trval = qla83xx_wr_reg(vha, 0x002012d4, 0x30000001);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x708a, \"Unable to pause MPI.\\n\");\n\t\tcount = 0;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(mpi_pause, S_IWUSR, NULL, qla2x00_mpi_pause_store);\n\n \n\nstatic ssize_t\nqlini_mode_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint len = 0;\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t    \"Supported options: enabled | disabled | dual | exclusive\\n\");\n\n\t \n\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Current selection: \");\n\n\tswitch (vha->qlini_mode) {\n\tcase QLA2XXX_INI_MODE_EXCLUSIVE:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t    QLA2XXX_INI_MODE_STR_EXCLUSIVE);\n\t\tbreak;\n\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t    QLA2XXX_INI_MODE_STR_DISABLED);\n\t\tbreak;\n\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t    QLA2XXX_INI_MODE_STR_ENABLED);\n\t\tbreak;\n\tcase QLA2XXX_INI_MODE_DUAL:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t    QLA2XXX_INI_MODE_STR_DUAL);\n\t\tbreak;\n\t}\n\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"\\n\");\n\n\treturn len;\n}\n\nstatic char *mode_to_str[] = {\n\t\"exclusive\",\n\t\"disabled\",\n\t\"enabled\",\n\t\"dual\",\n};\n\n#define NEED_EXCH_OFFLOAD(_exchg) ((_exchg) > FW_DEF_EXCHANGES_CNT)\nstatic void qla_set_ini_mode(scsi_qla_host_t *vha, int op)\n{\n\tenum {\n\t\tNO_ACTION,\n\t\tMODE_CHANGE_ACCEPT,\n\t\tMODE_CHANGE_NO_ACTION,\n\t\tTARGET_STILL_ACTIVE,\n\t};\n\tint action = NO_ACTION;\n\tint set_mode = 0;\n\tu8  eo_toggle = 0;\t \n\n\tswitch (vha->qlini_mode) {\n\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\tswitch (op) {\n\t\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\t\tif (qla_tgt_mode_enabled(vha)) {\n\t\t\t\tif (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=\n\t\t\t\t    vha->hw->flags.exchoffld_enabled)\n\t\t\t\t\teo_toggle = 1;\n\t\t\t\tif (((vha->ql2xexchoffld !=\n\t\t\t\t    vha->u_ql2xexchoffld) &&\n\t\t\t\t    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||\n\t\t\t\t    eo_toggle) {\n\t\t\t\t\t \n\t\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t\t} else {\n\t\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA2XXX_INI_MODE_EXCLUSIVE:\n\t\t\tif (qla_tgt_mode_enabled(vha)) {\n\t\t\t\tif (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=\n\t\t\t\t    vha->hw->flags.exchoffld_enabled)\n\t\t\t\t\teo_toggle = 1;\n\t\t\t\tif (((vha->ql2xexchoffld !=\n\t\t\t\t    vha->u_ql2xexchoffld) &&\n\t\t\t\t    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||\n\t\t\t\t    eo_toggle) {\n\t\t\t\t\t \n\t\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t\t} else {\n\t\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA2XXX_INI_MODE_DUAL:\n\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t \n\t\t\tif (qla_tgt_mode_enabled(vha)) {\n\t\t\t\tset_mode = 1;\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t} else {\n\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\t\tif (qla_tgt_mode_enabled(vha))\n\t\t\t\taction = TARGET_STILL_ACTIVE;\n\t\t\telse {\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t\tset_mode = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QLA2XXX_INI_MODE_EXCLUSIVE:\n\t\tswitch (op) {\n\t\tcase QLA2XXX_INI_MODE_EXCLUSIVE:\n\t\t\tif (qla_tgt_mode_enabled(vha)) {\n\t\t\t\tif (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=\n\t\t\t\t    vha->hw->flags.exchoffld_enabled)\n\t\t\t\t\teo_toggle = 1;\n\t\t\t\tif (((vha->ql2xexchoffld !=\n\t\t\t\t    vha->u_ql2xexchoffld) &&\n\t\t\t\t    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||\n\t\t\t\t    eo_toggle)\n\t\t\t\t\t \n\t\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t\telse\n\t\t\t\t\taction = NO_ACTION;\n\t\t\t} else\n\t\t\t\taction = NO_ACTION;\n\n\t\t\tbreak;\n\n\t\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\t\tif (qla_tgt_mode_enabled(vha)) {\n\t\t\t\tif (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld) !=\n\t\t\t\t    vha->hw->flags.exchoffld_enabled)\n\t\t\t\t\teo_toggle = 1;\n\t\t\t\tif (((vha->ql2xexchoffld !=\n\t\t\t\t      vha->u_ql2xexchoffld) &&\n\t\t\t\t    NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld)) ||\n\t\t\t\t    eo_toggle)\n\t\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t\telse\n\t\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\t} else\n\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\tbreak;\n\n\t\tcase QLA2XXX_INI_MODE_DUAL:  \n\t\t\tif (qla_tgt_mode_enabled(vha)) {\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t\tset_mode = 1;\n\t\t\t} else\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\tbreak;\n\n\t\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\t\tif (qla_tgt_mode_enabled(vha))\n\t\t\t\taction = TARGET_STILL_ACTIVE;\n\t\t\telse {\n\t\t\t\tif (vha->hw->flags.fw_started)\n\t\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\t\telse\n\t\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\tswitch (op) {\n\t\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\t\tif (NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg) !=\n\t\t\t    vha->hw->flags.exchoffld_enabled)\n\t\t\t\teo_toggle = 1;\n\t\t\tif (((vha->ql2xiniexchg != vha->u_ql2xiniexchg) &&\n\t\t\t\tNEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg)) ||\n\t\t\t    eo_toggle)\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\telse\n\t\t\t\taction = NO_ACTION;\n\t\t\tbreak;\n\t\tcase QLA2XXX_INI_MODE_DUAL:\n\t\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase QLA2XXX_INI_MODE_DUAL:\n\t\tswitch (op) {\n\t\tcase QLA2XXX_INI_MODE_DUAL:\n\t\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t\t    qla_dual_mode_enabled(vha)) {\n\t\t\t\tif (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld +\n\t\t\t\t\tvha->u_ql2xiniexchg) !=\n\t\t\t\t    vha->hw->flags.exchoffld_enabled)\n\t\t\t\t\teo_toggle = 1;\n\n\t\t\t\tif ((((vha->ql2xexchoffld +\n\t\t\t\t       vha->ql2xiniexchg) !=\n\t\t\t\t    (vha->u_ql2xiniexchg +\n\t\t\t\t     vha->u_ql2xexchoffld)) &&\n\t\t\t\t    NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg +\n\t\t\t\t\tvha->u_ql2xexchoffld)) || eo_toggle)\n\t\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t\telse\n\t\t\t\t\taction = NO_ACTION;\n\t\t\t} else {\n\t\t\t\tif (NEED_EXCH_OFFLOAD(vha->u_ql2xexchoffld +\n\t\t\t\t\tvha->u_ql2xiniexchg) !=\n\t\t\t\t    vha->hw->flags.exchoffld_enabled)\n\t\t\t\t\teo_toggle = 1;\n\n\t\t\t\tif ((((vha->ql2xexchoffld + vha->ql2xiniexchg)\n\t\t\t\t    != (vha->u_ql2xiniexchg +\n\t\t\t\t\tvha->u_ql2xexchoffld)) &&\n\t\t\t\t    NEED_EXCH_OFFLOAD(vha->u_ql2xiniexchg +\n\t\t\t\t\tvha->u_ql2xexchoffld)) || eo_toggle)\n\t\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\t\telse\n\t\t\t\t\taction = NO_ACTION;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t\t    qla_dual_mode_enabled(vha)) {\n\t\t\t\t \n\t\t\t\tset_mode = 1;\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t} else {\n\t\t\t\taction = MODE_CHANGE_NO_ACTION;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QLA2XXX_INI_MODE_EXCLUSIVE:\n\t\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t\t    qla_dual_mode_enabled(vha)) {\n\t\t\t\tset_mode = 1;\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t} else {\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\t\tif (qla_tgt_mode_enabled(vha) ||\n\t\t\t    qla_dual_mode_enabled(vha)) {\n\t\t\t\taction = TARGET_STILL_ACTIVE;\n\t\t\t} else {\n\t\t\t\taction = MODE_CHANGE_ACCEPT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (action) {\n\tcase MODE_CHANGE_ACCEPT:\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"Mode change accepted. From %s to %s, Tgt exchg %d|%d. ini exchg %d|%d\\n\",\n\t\t    mode_to_str[vha->qlini_mode], mode_to_str[op],\n\t\t    vha->ql2xexchoffld, vha->u_ql2xexchoffld,\n\t\t    vha->ql2xiniexchg, vha->u_ql2xiniexchg);\n\n\t\tvha->qlini_mode = op;\n\t\tvha->ql2xexchoffld = vha->u_ql2xexchoffld;\n\t\tvha->ql2xiniexchg = vha->u_ql2xiniexchg;\n\t\tif (set_mode)\n\t\t\tqlt_set_mode(vha);\n\t\tvha->flags.online = 1;\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\n\tcase MODE_CHANGE_NO_ACTION:\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"Mode is set. No action taken. From %s to %s, Tgt exchg %d|%d. ini exchg %d|%d\\n\",\n\t\t    mode_to_str[vha->qlini_mode], mode_to_str[op],\n\t\t    vha->ql2xexchoffld, vha->u_ql2xexchoffld,\n\t\t    vha->ql2xiniexchg, vha->u_ql2xiniexchg);\n\t\tvha->qlini_mode = op;\n\t\tvha->ql2xexchoffld = vha->u_ql2xexchoffld;\n\t\tvha->ql2xiniexchg = vha->u_ql2xiniexchg;\n\t\tbreak;\n\n\tcase TARGET_STILL_ACTIVE:\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"Target Mode is active. Unable to change Mode.\\n\");\n\t\tbreak;\n\n\tcase NO_ACTION:\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0xffff,\n\t\t    \"Mode unchange. No action taken. %d|%d pct %d|%d.\\n\",\n\t\t    vha->qlini_mode, op,\n\t\t    vha->ql2xexchoffld, vha->u_ql2xexchoffld);\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t\nqlini_mode_store(struct device *dev, struct device_attribute *attr,\n    const char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint ini;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (strncasecmp(QLA2XXX_INI_MODE_STR_EXCLUSIVE, buf,\n\t\tstrlen(QLA2XXX_INI_MODE_STR_EXCLUSIVE)) == 0)\n\t\tini = QLA2XXX_INI_MODE_EXCLUSIVE;\n\telse if (strncasecmp(QLA2XXX_INI_MODE_STR_DISABLED, buf,\n\t\tstrlen(QLA2XXX_INI_MODE_STR_DISABLED)) == 0)\n\t\tini = QLA2XXX_INI_MODE_DISABLED;\n\telse if (strncasecmp(QLA2XXX_INI_MODE_STR_ENABLED, buf,\n\t\t  strlen(QLA2XXX_INI_MODE_STR_ENABLED)) == 0)\n\t\tini = QLA2XXX_INI_MODE_ENABLED;\n\telse if (strncasecmp(QLA2XXX_INI_MODE_STR_DUAL, buf,\n\t\tstrlen(QLA2XXX_INI_MODE_STR_DUAL)) == 0)\n\t\tini = QLA2XXX_INI_MODE_DUAL;\n\telse\n\t\treturn -EINVAL;\n\n\tqla_set_ini_mode(vha, ini);\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nql2xexchoffld_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint len = 0;\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\"target exchange: new %d : current: %d\\n\\n\",\n\t\tvha->u_ql2xexchoffld, vha->ql2xexchoffld);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t    \"Please (re)set operating mode via \\\"/sys/class/scsi_host/host%ld/qlini_mode\\\" to load new setting.\\n\",\n\t    vha->host_no);\n\n\treturn len;\n}\n\nstatic ssize_t\nql2xexchoffld_store(struct device *dev, struct device_attribute *attr,\n    const char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint val = 0;\n\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif (val > FW_MAX_EXCHANGES_CNT)\n\t\tval = FW_MAX_EXCHANGES_CNT;\n\telse if (val < 0)\n\t\tval = 0;\n\n\tvha->u_ql2xexchoffld = val;\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nql2xiniexchg_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint len = 0;\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\"target exchange: new %d : current: %d\\n\\n\",\n\t\tvha->u_ql2xiniexchg, vha->ql2xiniexchg);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t    \"Please (re)set operating mode via \\\"/sys/class/scsi_host/host%ld/qlini_mode\\\" to load new setting.\\n\",\n\t    vha->host_no);\n\n\treturn len;\n}\n\nstatic ssize_t\nql2xiniexchg_store(struct device *dev, struct device_attribute *attr,\n    const char *buf, size_t count)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tint val = 0;\n\n\tif (sscanf(buf, \"%d\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif (val > FW_MAX_EXCHANGES_CNT)\n\t\tval = FW_MAX_EXCHANGES_CNT;\n\telse if (val < 0)\n\t\tval = 0;\n\n\tvha->u_ql2xiniexchg = val;\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nqla2x00_dif_bundle_statistics_show(struct device *dev,\n    struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\treturn scnprintf(buf, PAGE_SIZE,\n\t    \"cross=%llu read=%llu write=%llu kalloc=%llu dma_alloc=%llu unusable=%u\\n\",\n\t    ha->dif_bundle_crossed_pages, ha->dif_bundle_reads,\n\t    ha->dif_bundle_writes, ha->dif_bundle_kallocs,\n\t    ha->dif_bundle_dma_allocs, ha->pool.unusable.count);\n}\n\nstatic ssize_t\nqla2x00_fw_attr_show(struct device *dev,\n    struct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!IS_QLA27XX(ha) && !IS_QLA28XX(ha))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llx\\n\",\n\t    (uint64_t)ha->fw_attributes_ext[1] << 48 |\n\t    (uint64_t)ha->fw_attributes_ext[0] << 32 |\n\t    (uint64_t)ha->fw_attributes_h << 16 |\n\t    (uint64_t)ha->fw_attributes);\n}\n\nstatic ssize_t\nqla2x00_port_no_show(struct device *dev, struct device_attribute *attr,\n    char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", vha->hw->port_no);\n}\n\nstatic ssize_t\nqla2x00_dport_diagnostics_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\n\n\tif (!IS_QLA83XX(vha->hw) && !IS_QLA27XX(vha->hw) &&\n\t    !IS_QLA28XX(vha->hw))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\tif (!*vha->dport_data)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"\\n\");\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%04x %04x %04x %04x\\n\",\n\t    vha->dport_data[0], vha->dport_data[1],\n\t    vha->dport_data[2], vha->dport_data[3]);\n}\nstatic DEVICE_ATTR(dport_diagnostics, 0444,\n\t   qla2x00_dport_diagnostics_show, NULL);\n\nstatic DEVICE_ATTR(driver_version, S_IRUGO, qla2x00_driver_version_show, NULL);\nstatic DEVICE_ATTR(fw_version, S_IRUGO, qla2x00_fw_version_show, NULL);\nstatic DEVICE_ATTR(serial_num, S_IRUGO, qla2x00_serial_num_show, NULL);\nstatic DEVICE_ATTR(isp_name, S_IRUGO, qla2x00_isp_name_show, NULL);\nstatic DEVICE_ATTR(isp_id, S_IRUGO, qla2x00_isp_id_show, NULL);\nstatic DEVICE_ATTR(model_name, S_IRUGO, qla2x00_model_name_show, NULL);\nstatic DEVICE_ATTR(model_desc, S_IRUGO, qla2x00_model_desc_show, NULL);\nstatic DEVICE_ATTR(pci_info, S_IRUGO, qla2x00_pci_info_show, NULL);\nstatic DEVICE_ATTR(link_state, S_IRUGO, qla2x00_link_state_show, NULL);\nstatic DEVICE_ATTR(zio, S_IRUGO | S_IWUSR, qla2x00_zio_show, qla2x00_zio_store);\nstatic DEVICE_ATTR(zio_timer, S_IRUGO | S_IWUSR, qla2x00_zio_timer_show,\n\t\t   qla2x00_zio_timer_store);\nstatic DEVICE_ATTR(beacon, S_IRUGO | S_IWUSR, qla2x00_beacon_show,\n\t\t   qla2x00_beacon_store);\nstatic DEVICE_ATTR(beacon_config, 0644, qla2x00_beacon_config_show,\n\t\t   qla2x00_beacon_config_store);\nstatic DEVICE_ATTR(optrom_bios_version, S_IRUGO,\n\t\t   qla2x00_optrom_bios_version_show, NULL);\nstatic DEVICE_ATTR(optrom_efi_version, S_IRUGO,\n\t\t   qla2x00_optrom_efi_version_show, NULL);\nstatic DEVICE_ATTR(optrom_fcode_version, S_IRUGO,\n\t\t   qla2x00_optrom_fcode_version_show, NULL);\nstatic DEVICE_ATTR(optrom_fw_version, S_IRUGO, qla2x00_optrom_fw_version_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(optrom_gold_fw_version, S_IRUGO,\n    qla2x00_optrom_gold_fw_version_show, NULL);\nstatic DEVICE_ATTR(84xx_fw_version, S_IRUGO, qla24xx_84xx_fw_version_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(total_isp_aborts, S_IRUGO, qla2x00_total_isp_aborts_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(serdes_version, 0444, qla2x00_serdes_version_show, NULL);\nstatic DEVICE_ATTR(mpi_version, S_IRUGO, qla2x00_mpi_version_show, NULL);\nstatic DEVICE_ATTR(phy_version, S_IRUGO, qla2x00_phy_version_show, NULL);\nstatic DEVICE_ATTR(flash_block_size, S_IRUGO, qla2x00_flash_block_size_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(vlan_id, S_IRUGO, qla2x00_vlan_id_show, NULL);\nstatic DEVICE_ATTR(vn_port_mac_address, S_IRUGO,\n\t\t   qla2x00_vn_port_mac_address_show, NULL);\nstatic DEVICE_ATTR(fabric_param, S_IRUGO, qla2x00_fabric_param_show, NULL);\nstatic DEVICE_ATTR(fw_state, S_IRUGO, qla2x00_fw_state_show, NULL);\nstatic DEVICE_ATTR(thermal_temp, S_IRUGO, qla2x00_thermal_temp_show, NULL);\nstatic DEVICE_ATTR(diag_requests, S_IRUGO, qla2x00_diag_requests_show, NULL);\nstatic DEVICE_ATTR(diag_megabytes, S_IRUGO, qla2x00_diag_megabytes_show, NULL);\nstatic DEVICE_ATTR(fw_dump_size, S_IRUGO, qla2x00_fw_dump_size_show, NULL);\nstatic DEVICE_ATTR(allow_cna_fw_dump, S_IRUGO | S_IWUSR,\n\t\t   qla2x00_allow_cna_fw_dump_show,\n\t\t   qla2x00_allow_cna_fw_dump_store);\nstatic DEVICE_ATTR(pep_version, S_IRUGO, qla2x00_pep_version_show, NULL);\nstatic DEVICE_ATTR(min_supported_speed, 0444,\n\t\t   qla2x00_min_supported_speed_show, NULL);\nstatic DEVICE_ATTR(max_supported_speed, 0444,\n\t\t   qla2x00_max_supported_speed_show, NULL);\nstatic DEVICE_ATTR(zio_threshold, 0644,\n    qla_zio_threshold_show,\n    qla_zio_threshold_store);\nstatic DEVICE_ATTR_RW(qlini_mode);\nstatic DEVICE_ATTR_RW(ql2xexchoffld);\nstatic DEVICE_ATTR_RW(ql2xiniexchg);\nstatic DEVICE_ATTR(dif_bundle_statistics, 0444,\n    qla2x00_dif_bundle_statistics_show, NULL);\nstatic DEVICE_ATTR(port_speed, 0644, qla2x00_port_speed_show,\n    qla2x00_port_speed_store);\nstatic DEVICE_ATTR(port_no, 0444, qla2x00_port_no_show, NULL);\nstatic DEVICE_ATTR(fw_attr, 0444, qla2x00_fw_attr_show, NULL);\n\nstatic struct attribute *qla2x00_host_attrs[] = {\n\t&dev_attr_driver_version.attr,\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_serial_num.attr,\n\t&dev_attr_isp_name.attr,\n\t&dev_attr_isp_id.attr,\n\t&dev_attr_model_name.attr,\n\t&dev_attr_model_desc.attr,\n\t&dev_attr_pci_info.attr,\n\t&dev_attr_link_state.attr,\n\t&dev_attr_zio.attr,\n\t&dev_attr_zio_timer.attr,\n\t&dev_attr_beacon.attr,\n\t&dev_attr_beacon_config.attr,\n\t&dev_attr_optrom_bios_version.attr,\n\t&dev_attr_optrom_efi_version.attr,\n\t&dev_attr_optrom_fcode_version.attr,\n\t&dev_attr_optrom_fw_version.attr,\n\t&dev_attr_84xx_fw_version.attr,\n\t&dev_attr_total_isp_aborts.attr,\n\t&dev_attr_serdes_version.attr,\n\t&dev_attr_mpi_version.attr,\n\t&dev_attr_phy_version.attr,\n\t&dev_attr_flash_block_size.attr,\n\t&dev_attr_vlan_id.attr,\n\t&dev_attr_vn_port_mac_address.attr,\n\t&dev_attr_fabric_param.attr,\n\t&dev_attr_fw_state.attr,\n\t&dev_attr_optrom_gold_fw_version.attr,\n\t&dev_attr_thermal_temp.attr,\n\t&dev_attr_diag_requests.attr,\n\t&dev_attr_diag_megabytes.attr,\n\t&dev_attr_fw_dump_size.attr,\n\t&dev_attr_allow_cna_fw_dump.attr,\n\t&dev_attr_pep_version.attr,\n\t&dev_attr_min_supported_speed.attr,\n\t&dev_attr_max_supported_speed.attr,\n\t&dev_attr_zio_threshold.attr,\n\t&dev_attr_dif_bundle_statistics.attr,\n\t&dev_attr_port_speed.attr,\n\t&dev_attr_port_no.attr,\n\t&dev_attr_fw_attr.attr,\n\t&dev_attr_dport_diagnostics.attr,\n\t&dev_attr_mpi_pause.attr,\n\t&dev_attr_qlini_mode.attr,\n\t&dev_attr_ql2xiniexchg.attr,\n\t&dev_attr_ql2xexchoffld.attr,\n\tNULL,\n};\n\nstatic umode_t qla_host_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, int i)\n{\n\tif (ql2x_ini_mode != QLA2XXX_INI_MODE_DUAL &&\n\t    (attr == &dev_attr_qlini_mode.attr ||\n\t     attr == &dev_attr_ql2xiniexchg.attr ||\n\t     attr == &dev_attr_ql2xexchoffld.attr))\n\t\treturn 0;\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group qla2x00_host_attr_group = {\n\t.is_visible = qla_host_attr_is_visible,\n\t.attrs = qla2x00_host_attrs\n};\n\nconst struct attribute_group *qla2x00_host_groups[] = {\n\t&qla2x00_host_attr_group,\n\tNULL\n};\n\n \n\nstatic void\nqla2x00_get_host_port_id(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\n\tfc_host_port_id(shost) = vha->d_id.b.domain << 16 |\n\t    vha->d_id.b.area << 8 | vha->d_id.b.al_pa;\n}\n\nstatic void\nqla2x00_get_host_speed(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\tu32 speed;\n\n\tif (IS_QLAFX00(vha->hw)) {\n\t\tqlafx00_get_host_speed(shost);\n\t\treturn;\n\t}\n\n\tswitch (vha->hw->link_data_rate) {\n\tcase PORT_SPEED_1GB:\n\t\tspeed = FC_PORTSPEED_1GBIT;\n\t\tbreak;\n\tcase PORT_SPEED_2GB:\n\t\tspeed = FC_PORTSPEED_2GBIT;\n\t\tbreak;\n\tcase PORT_SPEED_4GB:\n\t\tspeed = FC_PORTSPEED_4GBIT;\n\t\tbreak;\n\tcase PORT_SPEED_8GB:\n\t\tspeed = FC_PORTSPEED_8GBIT;\n\t\tbreak;\n\tcase PORT_SPEED_10GB:\n\t\tspeed = FC_PORTSPEED_10GBIT;\n\t\tbreak;\n\tcase PORT_SPEED_16GB:\n\t\tspeed = FC_PORTSPEED_16GBIT;\n\t\tbreak;\n\tcase PORT_SPEED_32GB:\n\t\tspeed = FC_PORTSPEED_32GBIT;\n\t\tbreak;\n\tcase PORT_SPEED_64GB:\n\t\tspeed = FC_PORTSPEED_64GBIT;\n\t\tbreak;\n\tdefault:\n\t\tspeed = FC_PORTSPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tfc_host_speed(shost) = speed;\n}\n\nstatic void\nqla2x00_get_host_port_type(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\tuint32_t port_type;\n\n\tif (vha->vp_idx) {\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\n\t\treturn;\n\t}\n\tswitch (vha->hw->current_topology) {\n\tcase ISP_CFG_NL:\n\t\tport_type = FC_PORTTYPE_LPORT;\n\t\tbreak;\n\tcase ISP_CFG_FL:\n\t\tport_type = FC_PORTTYPE_NLPORT;\n\t\tbreak;\n\tcase ISP_CFG_N:\n\t\tport_type = FC_PORTTYPE_PTP;\n\t\tbreak;\n\tcase ISP_CFG_F:\n\t\tport_type = FC_PORTTYPE_NPORT;\n\t\tbreak;\n\tdefault:\n\t\tport_type = FC_PORTTYPE_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tfc_host_port_type(shost) = port_type;\n}\n\nstatic void\nqla2x00_get_starget_node_name(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *host = dev_to_shost(starget->dev.parent);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tfc_port_t *fcport;\n\tu64 node_name = 0;\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->rport &&\n\t\t    starget->id == fcport->rport->scsi_target_id) {\n\t\t\tnode_name = wwn_to_u64(fcport->node_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfc_starget_node_name(starget) = node_name;\n}\n\nstatic void\nqla2x00_get_starget_port_name(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *host = dev_to_shost(starget->dev.parent);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tfc_port_t *fcport;\n\tu64 port_name = 0;\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->rport &&\n\t\t    starget->id == fcport->rport->scsi_target_id) {\n\t\t\tport_name = wwn_to_u64(fcport->port_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfc_starget_port_name(starget) = port_name;\n}\n\nstatic void\nqla2x00_get_starget_port_id(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *host = dev_to_shost(starget->dev.parent);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tfc_port_t *fcport;\n\tuint32_t port_id = ~0U;\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->rport &&\n\t\t    starget->id == fcport->rport->scsi_target_id) {\n\t\t\tport_id = fcport->d_id.b.domain << 16 |\n\t\t\t    fcport->d_id.b.area << 8 | fcport->d_id.b.al_pa;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfc_starget_port_id(starget) = port_id;\n}\n\nstatic inline void\nqla2x00_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\n{\n\tfc_port_t *fcport = *(fc_port_t **)rport->dd_data;\n\n\trport->dev_loss_tmo = timeout ? timeout : 1;\n\n\tif (IS_ENABLED(CONFIG_NVME_FC) && fcport && fcport->nvme_remote_port)\n\t\tnvme_fc_set_remoteport_devloss(fcport->nvme_remote_port,\n\t\t\t\t\t       rport->dev_loss_tmo);\n}\n\nstatic void\nqla2x00_dev_loss_tmo_callbk(struct fc_rport *rport)\n{\n\tstruct Scsi_Host *host = rport_to_shost(rport);\n\tfc_port_t *fcport = *(fc_port_t **)rport->dd_data;\n\tunsigned long flags;\n\n\tif (!fcport)\n\t\treturn;\n\n\tql_dbg(ql_dbg_async, fcport->vha, 0x5101,\n\t       DBG_FCPORT_PRFMT(fcport, \"dev_loss_tmo expiry, rport_state=%d\",\n\t\t\t\trport->port_state));\n\n\t \n\tif (fcport->scan_state != QLA_FCPORT_FOUND)\n\t\tqla2x00_set_fcport_state(fcport, FCS_DEVICE_DEAD);\n\n\t \n\tspin_lock_irqsave(host->host_lock, flags);\n\t \n\tif (rport->port_state != FC_PORTSTATE_ONLINE) {\n\t\tfcport->rport = NULL;\n\t\t*((fc_port_t **)rport->dd_data) = NULL;\n\t}\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\n\tif (test_bit(ABORT_ISP_ACTIVE, &fcport->vha->dpc_flags))\n\t\treturn;\n\n\tif (unlikely(pci_channel_offline(fcport->vha->hw->pdev))) {\n\t\tqla2x00_abort_all_cmds(fcport->vha, DID_NO_CONNECT << 16);\n\t\treturn;\n\t}\n}\n\nstatic void\nqla2x00_terminate_rport_io(struct fc_rport *rport)\n{\n\tfc_port_t *fcport = *(fc_port_t **)rport->dd_data;\n\tscsi_qla_host_t *vha;\n\n\tif (!fcport)\n\t\treturn;\n\n\tif (test_bit(UNLOADING, &fcport->vha->dpc_flags))\n\t\treturn;\n\n\tif (test_bit(ABORT_ISP_ACTIVE, &fcport->vha->dpc_flags))\n\t\treturn;\n\tvha = fcport->vha;\n\n\tif (unlikely(pci_channel_offline(fcport->vha->hw->pdev))) {\n\t\tqla2x00_abort_all_cmds(fcport->vha, DID_NO_CONNECT << 16);\n\t\tqla2x00_eh_wait_for_pending_commands(fcport->vha, fcport->d_id.b24,\n\t\t\t0, WAIT_TARGET);\n\t\treturn;\n\t}\n\t \n\tif (fcport->loop_id != FC_NO_LOOP_ID) {\n\t\tif (IS_FWI2_CAPABLE(fcport->vha->hw) &&\n\t\t    fcport->scan_state != QLA_FCPORT_FOUND) {\n\t\t\tif (fcport->loop_id != FC_NO_LOOP_ID)\n\t\t\t\tfcport->logout_on_delete = 1;\n\n\t\t\tif (!EDIF_NEGOTIATION_PENDING(fcport)) {\n\t\t\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x911e,\n\t\t\t\t       \"%s %d schedule session deletion\\n\", __func__,\n\t\t\t\t       __LINE__);\n\t\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\t}\n\t\t} else if (!IS_FWI2_CAPABLE(fcport->vha->hw)) {\n\t\t\tqla2x00_port_logout(fcport->vha, fcport);\n\t\t}\n\t}\n\n\t \n\tif (qla2x00_eh_wait_for_pending_commands(fcport->vha, fcport->d_id.b24, 0, WAIT_TARGET)) {\n\t\tql_log(ql_log_warn, vha, 0x300b,\n\t\t       \"IO not return.  Resetting. \\n\");\n\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\tqla2xxx_wake_dpc(vha);\n\t\tqla2x00_wait_for_chip_reset(vha);\n\t}\n}\n\nstatic int\nqla2x00_issue_lip(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\n\tif (IS_QLAFX00(vha->hw))\n\t\treturn 0;\n\n\tif (vha->hw->flags.port_isolated)\n\t\treturn 0;\n\n\tqla2x00_loop_reset(vha);\n\treturn 0;\n}\n\nstatic struct fc_host_statistics *\nqla2x00_get_fc_host_stats(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tint rval;\n\tstruct link_statistics *stats;\n\tdma_addr_t stats_dma;\n\tstruct fc_host_statistics *p = &vha->fc_host_stat;\n\tstruct qla_qpair *qpair;\n\tint i;\n\tu64 ib = 0, ob = 0, ir = 0, or = 0;\n\n\tmemset(p, -1, sizeof(*p));\n\n\tif (IS_QLAFX00(vha->hw))\n\t\tgoto done;\n\n\tif (test_bit(UNLOADING, &vha->dpc_flags))\n\t\tgoto done;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\tgoto done;\n\n\tif (qla2x00_chip_is_down(vha))\n\t\tgoto done;\n\n\tstats = dma_alloc_coherent(&ha->pdev->dev, sizeof(*stats), &stats_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!stats) {\n\t\tql_log(ql_log_warn, vha, 0x707d,\n\t\t    \"Failed to allocate memory for stats.\\n\");\n\t\tgoto done;\n\t}\n\n\trval = QLA_FUNCTION_FAILED;\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\trval = qla24xx_get_isp_stats(base_vha, stats, stats_dma, 0);\n\t} else if (atomic_read(&base_vha->loop_state) == LOOP_READY &&\n\t    !ha->dpc_active) {\n\t\t \n\t\trval = qla2x00_get_link_status(base_vha, base_vha->loop_id,\n\t\t\t\t\t\tstats, stats_dma);\n\t}\n\n\tif (rval != QLA_SUCCESS)\n\t\tgoto done_free;\n\n\t \n\tfor (i = 0; i < vha->hw->max_qpairs; i++) {\n\t\tqpair = vha->hw->queue_pair_map[i];\n\t\tif (!qpair)\n\t\t\tcontinue;\n\t\tir += qpair->counters.input_requests;\n\t\tor += qpair->counters.output_requests;\n\t\tib += qpair->counters.input_bytes;\n\t\tob += qpair->counters.output_bytes;\n\t}\n\tir += ha->base_qpair->counters.input_requests;\n\tor += ha->base_qpair->counters.output_requests;\n\tib += ha->base_qpair->counters.input_bytes;\n\tob += ha->base_qpair->counters.output_bytes;\n\n\tir += vha->qla_stats.input_requests;\n\tor += vha->qla_stats.output_requests;\n\tib += vha->qla_stats.input_bytes;\n\tob += vha->qla_stats.output_bytes;\n\t \n\n\tp->link_failure_count = le32_to_cpu(stats->link_fail_cnt);\n\tp->loss_of_sync_count = le32_to_cpu(stats->loss_sync_cnt);\n\tp->loss_of_signal_count = le32_to_cpu(stats->loss_sig_cnt);\n\tp->prim_seq_protocol_err_count = le32_to_cpu(stats->prim_seq_err_cnt);\n\tp->invalid_tx_word_count = le32_to_cpu(stats->inval_xmit_word_cnt);\n\tp->invalid_crc_count = le32_to_cpu(stats->inval_crc_cnt);\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tp->lip_count = le32_to_cpu(stats->lip_cnt);\n\t\tp->tx_frames = le32_to_cpu(stats->tx_frames);\n\t\tp->rx_frames = le32_to_cpu(stats->rx_frames);\n\t\tp->dumped_frames = le32_to_cpu(stats->discarded_frames);\n\t\tp->nos_count = le32_to_cpu(stats->nos_rcvd);\n\t\tp->error_frames =\n\t\t    le32_to_cpu(stats->dropped_frames) +\n\t\t    le32_to_cpu(stats->discarded_frames);\n\t\tif (IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\t\tp->rx_words = le64_to_cpu(stats->fpm_recv_word_cnt);\n\t\t\tp->tx_words = le64_to_cpu(stats->fpm_xmit_word_cnt);\n\t\t} else {\n\t\t\tp->rx_words = ib >> 2;\n\t\t\tp->tx_words = ob >> 2;\n\t\t}\n\t}\n\n\tp->fcp_control_requests = vha->qla_stats.control_requests;\n\tp->fcp_input_requests = ir;\n\tp->fcp_output_requests = or;\n\tp->fcp_input_megabytes  = ib >> 20;\n\tp->fcp_output_megabytes = ob >> 20;\n\tp->seconds_since_last_reset =\n\t    get_jiffies_64() - vha->qla_stats.jiffies_at_last_reset;\n\tdo_div(p->seconds_since_last_reset, HZ);\n\ndone_free:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct link_statistics),\n\t    stats, stats_dma);\ndone:\n\treturn p;\n}\n\nstatic void\nqla2x00_reset_host_stats(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tstruct link_statistics *stats;\n\tdma_addr_t stats_dma;\n\tint i;\n\tstruct qla_qpair *qpair;\n\n\tmemset(&vha->qla_stats, 0, sizeof(vha->qla_stats));\n\tmemset(&vha->fc_host_stat, 0, sizeof(vha->fc_host_stat));\n\tfor (i = 0; i < vha->hw->max_qpairs; i++) {\n\t\tqpair = vha->hw->queue_pair_map[i];\n\t\tif (!qpair)\n\t\t\tcontinue;\n\t\tmemset(&qpair->counters, 0, sizeof(qpair->counters));\n\t}\n\tmemset(&ha->base_qpair->counters, 0, sizeof(qpair->counters));\n\n\tvha->qla_stats.jiffies_at_last_reset = get_jiffies_64();\n\n\tif (IS_FWI2_CAPABLE(ha)) {\n\t\tint rval;\n\n\t\tstats = dma_alloc_coherent(&ha->pdev->dev,\n\t\t    sizeof(*stats), &stats_dma, GFP_KERNEL);\n\t\tif (!stats) {\n\t\t\tql_log(ql_log_warn, vha, 0x70d7,\n\t\t\t    \"Failed to allocate memory for stats.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\trval = qla24xx_get_isp_stats(base_vha, stats, stats_dma, BIT_0);\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tql_log(ql_log_warn, vha, 0x70de,\n\t\t\t       \"Resetting ISP statistics failed: rval = %d\\n\",\n\t\t\t       rval);\n\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*stats),\n\t\t    stats, stats_dma);\n\t}\n}\n\nstatic void\nqla2x00_get_host_symbolic_name(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\n\tqla2x00_get_sym_node_name(vha, fc_host_symbolic_name(shost),\n\t    sizeof(fc_host_symbolic_name(shost)));\n}\n\nstatic void\nqla2x00_set_host_system_hostname(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\n\tset_bit(REGISTER_FDMI_NEEDED, &vha->dpc_flags);\n}\n\nstatic void\nqla2x00_get_host_fabric_name(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\tstatic const uint8_t node_name[WWN_SIZE] = {\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n\t};\n\tu64 fabric_name = wwn_to_u64(node_name);\n\n\tif (vha->device_flags & SWITCH_FOUND)\n\t\tfabric_name = wwn_to_u64(vha->fabric_node_name);\n\n\tfc_host_fabric_name(shost) = fabric_name;\n}\n\nstatic void\nqla2x00_get_host_port_state(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(vha->hw->pdev);\n\n\tif (!base_vha->flags.online) {\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n\t\treturn;\n\t}\n\n\tswitch (atomic_read(&base_vha->loop_state)) {\n\tcase LOOP_UPDATE:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_DIAGNOSTICS;\n\t\tbreak;\n\tcase LOOP_DOWN:\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &base_vha->dpc_flags))\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_DIAGNOSTICS;\n\t\telse\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\t\tbreak;\n\tcase LOOP_DEAD:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\t\tbreak;\n\tcase LOOP_READY:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\t\tbreak;\n\tdefault:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\nstatic int\nqla24xx_vport_create(struct fc_vport *fc_vport, bool disable)\n{\n\tint\tret = 0;\n\tuint8_t\tqos = 0;\n\tscsi_qla_host_t *base_vha = shost_priv(fc_vport->shost);\n\tscsi_qla_host_t *vha = NULL;\n\tstruct qla_hw_data *ha = base_vha->hw;\n\tint\tcnt;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct qla_qpair *qpair;\n\n\tret = qla24xx_vport_create_req_sanity_check(fc_vport);\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0x707e,\n\t\t    \"Vport sanity check failed, status %x\\n\", ret);\n\t\treturn (ret);\n\t}\n\n\tvha = qla24xx_create_vhost(fc_vport);\n\tif (vha == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x707f, \"Vport create host failed.\\n\");\n\t\treturn FC_VPORT_FAILED;\n\t}\n\tif (disable) {\n\t\tatomic_set(&vha->vp_state, VP_OFFLINE);\n\t\tfc_vport_set_state(fc_vport, FC_VPORT_DISABLED);\n\t} else\n\t\tatomic_set(&vha->vp_state, VP_FAILED);\n\n\t \n\tql_log(ql_log_info, vha, 0x7080,\n\t    \"VP entry id %d assigned.\\n\", vha->vp_idx);\n\n\t \n\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\tvha->vp_err_state = VP_ERR_PORTDWN;\n\tvha->vp_prev_err_state = VP_ERR_UNKWN;\n\t \n\tif (atomic_read(&base_vha->loop_state) == LOOP_DOWN ||\n\t    atomic_read(&base_vha->loop_state) == LOOP_DEAD) {\n\t\t \n\t\tql_dbg(ql_dbg_user, vha, 0x7081,\n\t\t    \"Vport loop state is not UP.\\n\");\n\t\tatomic_set(&vha->loop_state, LOOP_DEAD);\n\t\tif (!disable)\n\t\t\tfc_vport_set_state(fc_vport, FC_VPORT_LINKDOWN);\n\t}\n\n\tif (IS_T10_PI_CAPABLE(ha) && ql2xenabledif) {\n\t\tif (ha->fw_attributes & BIT_4) {\n\t\t\tint prot = 0, guard;\n\n\t\t\tvha->flags.difdix_supported = 1;\n\t\t\tql_dbg(ql_dbg_user, vha, 0x7082,\n\t\t\t    \"Registered for DIF/DIX type 1 and 3 protection.\\n\");\n\t\t\tscsi_host_set_prot(vha->host,\n\t\t\t    prot | SHOST_DIF_TYPE1_PROTECTION\n\t\t\t    | SHOST_DIF_TYPE2_PROTECTION\n\t\t\t    | SHOST_DIF_TYPE3_PROTECTION\n\t\t\t    | SHOST_DIX_TYPE1_PROTECTION\n\t\t\t    | SHOST_DIX_TYPE2_PROTECTION\n\t\t\t    | SHOST_DIX_TYPE3_PROTECTION);\n\n\t\t\tguard = SHOST_DIX_GUARD_CRC;\n\n\t\t\tif (IS_PI_IPGUARD_CAPABLE(ha) &&\n\t\t\t    (ql2xenabledif > 1 || IS_PI_DIFB_DIX0_CAPABLE(ha)))\n\t\t\t\tguard |= SHOST_DIX_GUARD_IP;\n\n\t\t\tscsi_host_set_guard(vha->host, guard);\n\t\t} else\n\t\t\tvha->flags.difdix_supported = 0;\n\t}\n\n\tif (scsi_add_host_with_dma(vha->host, &fc_vport->dev,\n\t\t\t\t   &ha->pdev->dev)) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7083,\n\t\t    \"scsi_add_host failure for VP[%d].\\n\", vha->vp_idx);\n\t\tgoto vport_create_failed_2;\n\t}\n\n\t \n\tfc_host_dev_loss_tmo(vha->host) = ha->port_down_retry_count;\n\tfc_host_node_name(vha->host) = wwn_to_u64(vha->node_name);\n\tfc_host_port_name(vha->host) = wwn_to_u64(vha->port_name);\n\tfc_host_supported_classes(vha->host) =\n\t\tfc_host_supported_classes(base_vha->host);\n\tfc_host_supported_speeds(vha->host) =\n\t\tfc_host_supported_speeds(base_vha->host);\n\n\tqlt_vport_create(vha, ha);\n\tqla24xx_vport_disable(fc_vport, disable);\n\n\tif (!ql2xmqsupport || !ha->npiv_info)\n\t\tgoto vport_queue;\n\n\t \n\tfor (cnt = 0; cnt < ha->nvram_npiv_size; cnt++) {\n\t\tif (memcmp(ha->npiv_info[cnt].port_name, vha->port_name, 8) == 0\n\t\t\t&& memcmp(ha->npiv_info[cnt].node_name, vha->node_name,\n\t\t\t\t\t8) == 0) {\n\t\t\tqos = ha->npiv_info[cnt].q_qos;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (qos) {\n\t\tqpair = qla2xxx_create_qpair(vha, qos, vha->vp_idx, true);\n\t\tif (!qpair)\n\t\t\tql_log(ql_log_warn, vha, 0x7084,\n\t\t\t    \"Can't create qpair for VP[%d]\\n\",\n\t\t\t    vha->vp_idx);\n\t\telse {\n\t\t\tql_dbg(ql_dbg_multiq, vha, 0xc001,\n\t\t\t    \"Queue pair: %d Qos: %d) created for VP[%d]\\n\",\n\t\t\t    qpair->id, qos, vha->vp_idx);\n\t\t\tql_dbg(ql_dbg_user, vha, 0x7085,\n\t\t\t    \"Queue Pair: %d Qos: %d) created for VP[%d]\\n\",\n\t\t\t    qpair->id, qos, vha->vp_idx);\n\t\t\treq = qpair->req;\n\t\t\tvha->qpair = qpair;\n\t\t}\n\t}\n\nvport_queue:\n\tvha->req = req;\n\treturn 0;\n\nvport_create_failed_2:\n\tqla24xx_disable_vp(vha);\n\tqla24xx_deallocate_vp_id(vha);\n\tscsi_host_put(vha->host);\n\treturn FC_VPORT_FAILED;\n}\n\nstatic int\nqla24xx_vport_delete(struct fc_vport *fc_vport)\n{\n\tscsi_qla_host_t *vha = fc_vport->dd_data;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t id = vha->vp_idx;\n\n\tset_bit(VPORT_DELETE, &vha->dpc_flags);\n\n\twhile (test_bit(LOOP_RESYNC_ACTIVE, &vha->dpc_flags))\n\t\tmsleep(1000);\n\n\n\tqla24xx_disable_vp(vha);\n\tqla2x00_wait_for_sess_deletion(vha);\n\n\tqla_nvme_delete(vha);\n\tqla_enode_stop(vha);\n\tqla_edb_stop(vha);\n\n\tvha->flags.delete_progress = 1;\n\n\tqlt_remove_target(ha, vha);\n\n\tfc_remove_host(vha->host);\n\n\tscsi_remove_host(vha->host);\n\n\t \n\tqla24xx_deallocate_vp_id(vha);\n\n\tif (vha->timer_active) {\n\t\tqla2x00_vp_stop_timer(vha);\n\t\tql_dbg(ql_dbg_user, vha, 0x7086,\n\t\t    \"Timer for the VP[%d] has stopped\\n\", vha->vp_idx);\n\t}\n\n\tqla2x00_free_fcports(vha);\n\n\tmutex_lock(&ha->vport_lock);\n\tha->cur_vport_count--;\n\tclear_bit(vha->vp_idx, ha->vp_idx_map);\n\tmutex_unlock(&ha->vport_lock);\n\n\tdma_free_coherent(&ha->pdev->dev, vha->gnl.size, vha->gnl.l,\n\t    vha->gnl.ldma);\n\n\tvha->gnl.l = NULL;\n\n\tvfree(vha->scan.l);\n\n\tif (vha->qpair && vha->qpair->vp_idx == vha->vp_idx) {\n\t\tif (qla2xxx_delete_qpair(vha, vha->qpair) != QLA_SUCCESS)\n\t\t\tql_log(ql_log_warn, vha, 0x7087,\n\t\t\t    \"Queue Pair delete failed.\\n\");\n\t}\n\n\tql_log(ql_log_info, vha, 0x7088, \"VP[%d] deleted.\\n\", id);\n\tscsi_host_put(vha->host);\n\treturn 0;\n}\n\nstatic int\nqla24xx_vport_disable(struct fc_vport *fc_vport, bool disable)\n{\n\tscsi_qla_host_t *vha = fc_vport->dd_data;\n\n\tif (disable)\n\t\tqla24xx_disable_vp(vha);\n\telse\n\t\tqla24xx_enable_vp(vha);\n\n\treturn 0;\n}\n\nstruct fc_function_template qla2xxx_transport_functions = {\n\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_speeds = 1,\n\n\t.get_host_port_id = qla2x00_get_host_port_id,\n\t.show_host_port_id = 1,\n\t.get_host_speed = qla2x00_get_host_speed,\n\t.show_host_speed = 1,\n\t.get_host_port_type = qla2x00_get_host_port_type,\n\t.show_host_port_type = 1,\n\t.get_host_symbolic_name = qla2x00_get_host_symbolic_name,\n\t.show_host_symbolic_name = 1,\n\t.set_host_system_hostname = qla2x00_set_host_system_hostname,\n\t.show_host_system_hostname = 1,\n\t.get_host_fabric_name = qla2x00_get_host_fabric_name,\n\t.show_host_fabric_name = 1,\n\t.get_host_port_state = qla2x00_get_host_port_state,\n\t.show_host_port_state = 1,\n\n\t.dd_fcrport_size = sizeof(struct fc_port *),\n\t.show_rport_supported_classes = 1,\n\n\t.get_starget_node_name = qla2x00_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\t.get_starget_port_name = qla2x00_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\t.get_starget_port_id  = qla2x00_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\n\t.set_rport_dev_loss_tmo = qla2x00_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.issue_fc_host_lip = qla2x00_issue_lip,\n\t.dev_loss_tmo_callbk = qla2x00_dev_loss_tmo_callbk,\n\t.terminate_rport_io = qla2x00_terminate_rport_io,\n\t.get_fc_host_stats = qla2x00_get_fc_host_stats,\n\t.reset_fc_host_stats = qla2x00_reset_host_stats,\n\n\t.vport_create = qla24xx_vport_create,\n\t.vport_disable = qla24xx_vport_disable,\n\t.vport_delete = qla24xx_vport_delete,\n\t.bsg_request = qla24xx_bsg_request,\n\t.bsg_timeout = qla24xx_bsg_timeout,\n};\n\nstruct fc_function_template qla2xxx_transport_vport_functions = {\n\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\n\t.get_host_port_id = qla2x00_get_host_port_id,\n\t.show_host_port_id = 1,\n\t.get_host_speed = qla2x00_get_host_speed,\n\t.show_host_speed = 1,\n\t.get_host_port_type = qla2x00_get_host_port_type,\n\t.show_host_port_type = 1,\n\t.get_host_symbolic_name = qla2x00_get_host_symbolic_name,\n\t.show_host_symbolic_name = 1,\n\t.set_host_system_hostname = qla2x00_set_host_system_hostname,\n\t.show_host_system_hostname = 1,\n\t.get_host_fabric_name = qla2x00_get_host_fabric_name,\n\t.show_host_fabric_name = 1,\n\t.get_host_port_state = qla2x00_get_host_port_state,\n\t.show_host_port_state = 1,\n\n\t.dd_fcrport_size = sizeof(struct fc_port *),\n\t.show_rport_supported_classes = 1,\n\n\t.get_starget_node_name = qla2x00_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\t.get_starget_port_name = qla2x00_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\t.get_starget_port_id  = qla2x00_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\n\t.set_rport_dev_loss_tmo = qla2x00_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.issue_fc_host_lip = qla2x00_issue_lip,\n\t.dev_loss_tmo_callbk = qla2x00_dev_loss_tmo_callbk,\n\t.terminate_rport_io = qla2x00_terminate_rport_io,\n\t.get_fc_host_stats = qla2x00_get_fc_host_stats,\n\t.reset_fc_host_stats = qla2x00_reset_host_stats,\n\n\t.bsg_request = qla24xx_bsg_request,\n\t.bsg_timeout = qla24xx_bsg_timeout,\n};\n\nstatic uint\nqla2x00_get_host_supported_speeds(scsi_qla_host_t *vha, uint speeds)\n{\n\tuint supported_speeds = FC_PORTSPEED_UNKNOWN;\n\n\tif (speeds & FDMI_PORT_SPEED_64GB)\n\t\tsupported_speeds |= FC_PORTSPEED_64GBIT;\n\tif (speeds & FDMI_PORT_SPEED_32GB)\n\t\tsupported_speeds |= FC_PORTSPEED_32GBIT;\n\tif (speeds & FDMI_PORT_SPEED_16GB)\n\t\tsupported_speeds |= FC_PORTSPEED_16GBIT;\n\tif (speeds & FDMI_PORT_SPEED_8GB)\n\t\tsupported_speeds |= FC_PORTSPEED_8GBIT;\n\tif (speeds & FDMI_PORT_SPEED_4GB)\n\t\tsupported_speeds |= FC_PORTSPEED_4GBIT;\n\tif (speeds & FDMI_PORT_SPEED_2GB)\n\t\tsupported_speeds |= FC_PORTSPEED_2GBIT;\n\tif (speeds & FDMI_PORT_SPEED_1GB)\n\t\tsupported_speeds |= FC_PORTSPEED_1GBIT;\n\n\treturn supported_speeds;\n}\n\nvoid\nqla2x00_init_host_attr(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tu32 speeds = 0, fdmi_speed = 0;\n\n\tfc_host_dev_loss_tmo(vha->host) = ha->port_down_retry_count;\n\tfc_host_node_name(vha->host) = wwn_to_u64(vha->node_name);\n\tfc_host_port_name(vha->host) = wwn_to_u64(vha->port_name);\n\tfc_host_supported_classes(vha->host) = ha->base_qpair->enable_class_2 ?\n\t\t\t(FC_COS_CLASS2|FC_COS_CLASS3) : FC_COS_CLASS3;\n\tfc_host_max_npiv_vports(vha->host) = ha->max_npiv_vports;\n\tfc_host_npiv_vports_inuse(vha->host) = ha->cur_vport_count;\n\n\tfdmi_speed = qla25xx_fdmi_port_speed_capability(ha);\n\tspeeds = qla2x00_get_host_supported_speeds(vha, fdmi_speed);\n\n\tfc_host_supported_speeds(vha->host) = speeds;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}