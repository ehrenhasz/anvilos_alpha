{
  "module_name": "qla_nx.c",
  "hash_id": "83494a88f42e3467d5cce3fcdc119208c72befced0eea5b641068956d9b1bd32",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_nx.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include <linux/delay.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/pci.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n#include <scsi/scsi_tcq.h>\n\n#define MASK(n)\t\t\t((1ULL<<(n))-1)\n#define MN_WIN(addr) (((addr & 0x1fc0000) >> 1) | \\\n\t((addr >> 25) & 0x3ff))\n#define OCM_WIN(addr) (((addr & 0x1ff0000) >> 1) | \\\n\t((addr >> 25) & 0x3ff))\n#define MS_WIN(addr) (addr & 0x0ffc0000)\n#define QLA82XX_PCI_MN_2M   (0)\n#define QLA82XX_PCI_MS_2M   (0x80000)\n#define QLA82XX_PCI_OCM0_2M (0xc0000)\n#define VALID_OCM_ADDR(addr) (((addr) & 0x3f800) != 0x3f800)\n#define GET_MEM_OFFS_2M(addr) (addr & MASK(18))\n#define BLOCK_PROTECT_BITS 0x0F\n\n \n#define CRB_BLK(off)\t((off >> 20) & 0x3f)\n#define CRB_SUBBLK(off)\t((off >> 16) & 0xf)\n#define CRB_WINDOW_2M\t(0x130060)\n#define QLA82XX_PCI_CAMQM_2M_END\t(0x04800800UL)\n#define CRB_HI(off)\t((qla82xx_crb_hub_agt[CRB_BLK(off)] << 20) | \\\n\t\t\t((off) & 0xf0000))\n#define QLA82XX_PCI_CAMQM_2M_BASE\t(0x000ff800UL)\n#define CRB_INDIRECT_2M\t(0x1e0000UL)\n\n#define MAX_CRB_XFORM 60\nstatic unsigned long crb_addr_xform[MAX_CRB_XFORM];\nstatic int qla82xx_crb_table_initialized;\n\n#define qla82xx_crb_addr_transform(name) \\\n\t(crb_addr_xform[QLA82XX_HW_PX_MAP_CRB_##name] = \\\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_##name << 20)\n\nconst int MD_MIU_TEST_AGT_RDDATA[] = {\n\t0x410000A8, 0x410000AC,\n\t0x410000B8, 0x410000BC\n};\n\nstatic void qla82xx_crb_addr_transform_setup(void)\n{\n\tqla82xx_crb_addr_transform(XDMA);\n\tqla82xx_crb_addr_transform(TIMR);\n\tqla82xx_crb_addr_transform(SRE);\n\tqla82xx_crb_addr_transform(SQN3);\n\tqla82xx_crb_addr_transform(SQN2);\n\tqla82xx_crb_addr_transform(SQN1);\n\tqla82xx_crb_addr_transform(SQN0);\n\tqla82xx_crb_addr_transform(SQS3);\n\tqla82xx_crb_addr_transform(SQS2);\n\tqla82xx_crb_addr_transform(SQS1);\n\tqla82xx_crb_addr_transform(SQS0);\n\tqla82xx_crb_addr_transform(RPMX7);\n\tqla82xx_crb_addr_transform(RPMX6);\n\tqla82xx_crb_addr_transform(RPMX5);\n\tqla82xx_crb_addr_transform(RPMX4);\n\tqla82xx_crb_addr_transform(RPMX3);\n\tqla82xx_crb_addr_transform(RPMX2);\n\tqla82xx_crb_addr_transform(RPMX1);\n\tqla82xx_crb_addr_transform(RPMX0);\n\tqla82xx_crb_addr_transform(ROMUSB);\n\tqla82xx_crb_addr_transform(SN);\n\tqla82xx_crb_addr_transform(QMN);\n\tqla82xx_crb_addr_transform(QMS);\n\tqla82xx_crb_addr_transform(PGNI);\n\tqla82xx_crb_addr_transform(PGND);\n\tqla82xx_crb_addr_transform(PGN3);\n\tqla82xx_crb_addr_transform(PGN2);\n\tqla82xx_crb_addr_transform(PGN1);\n\tqla82xx_crb_addr_transform(PGN0);\n\tqla82xx_crb_addr_transform(PGSI);\n\tqla82xx_crb_addr_transform(PGSD);\n\tqla82xx_crb_addr_transform(PGS3);\n\tqla82xx_crb_addr_transform(PGS2);\n\tqla82xx_crb_addr_transform(PGS1);\n\tqla82xx_crb_addr_transform(PGS0);\n\tqla82xx_crb_addr_transform(PS);\n\tqla82xx_crb_addr_transform(PH);\n\tqla82xx_crb_addr_transform(NIU);\n\tqla82xx_crb_addr_transform(I2Q);\n\tqla82xx_crb_addr_transform(EG);\n\tqla82xx_crb_addr_transform(MN);\n\tqla82xx_crb_addr_transform(MS);\n\tqla82xx_crb_addr_transform(CAS2);\n\tqla82xx_crb_addr_transform(CAS1);\n\tqla82xx_crb_addr_transform(CAS0);\n\tqla82xx_crb_addr_transform(CAM);\n\tqla82xx_crb_addr_transform(C2C1);\n\tqla82xx_crb_addr_transform(C2C0);\n\tqla82xx_crb_addr_transform(SMB);\n\tqla82xx_crb_addr_transform(OCM0);\n\t \n\tqla82xx_crb_addr_transform(I2C0);\n\n\tqla82xx_crb_table_initialized = 1;\n}\n\nstatic struct crb_128M_2M_block_map crb_128M_2M_map[64] = {\n\t{{{0, 0,         0,         0} } },\n\t{{{1, 0x0100000, 0x0102000, 0x120000},\n\t{1, 0x0110000, 0x0120000, 0x130000},\n\t{1, 0x0120000, 0x0122000, 0x124000},\n\t{1, 0x0130000, 0x0132000, 0x126000},\n\t{1, 0x0140000, 0x0142000, 0x128000},\n\t{1, 0x0150000, 0x0152000, 0x12a000},\n\t{1, 0x0160000, 0x0170000, 0x110000},\n\t{1, 0x0170000, 0x0172000, 0x12e000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{1, 0x01e0000, 0x01e0800, 0x122000},\n\t{0, 0x0000000, 0x0000000, 0x000000} } } ,\n\t{{{1, 0x0200000, 0x0210000, 0x180000} } },\n\t{{{0, 0,         0,         0} } },\n\t{{{1, 0x0400000, 0x0401000, 0x169000} } },\n\t{{{1, 0x0500000, 0x0510000, 0x140000} } },\n\t{{{1, 0x0600000, 0x0610000, 0x1c0000} } },\n\t{{{1, 0x0700000, 0x0704000, 0x1b8000} } },\n\t{{{1, 0x0800000, 0x0802000, 0x170000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{1, 0x08f0000, 0x08f2000, 0x172000} } },\n\t{{{1, 0x0900000, 0x0902000, 0x174000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{1, 0x09f0000, 0x09f2000, 0x176000} } },\n\t{{{0, 0x0a00000, 0x0a02000, 0x178000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{1, 0x0af0000, 0x0af2000, 0x17a000} } },\n\t{{{0, 0x0b00000, 0x0b02000, 0x17c000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{1, 0x0bf0000, 0x0bf2000, 0x17e000} } },\n\t{{{1, 0x0c00000, 0x0c04000, 0x1d4000} } },\n\t{{{1, 0x0d00000, 0x0d04000, 0x1a4000} } },\n\t{{{1, 0x0e00000, 0x0e04000, 0x1a0000} } },\n\t{{{1, 0x0f00000, 0x0f01000, 0x164000} } },\n\t{{{0, 0x1000000, 0x1004000, 0x1a8000} } },\n\t{{{1, 0x1100000, 0x1101000, 0x160000} } },\n\t{{{1, 0x1200000, 0x1201000, 0x161000} } },\n\t{{{1, 0x1300000, 0x1301000, 0x162000} } },\n\t{{{1, 0x1400000, 0x1401000, 0x163000} } },\n\t{{{1, 0x1500000, 0x1501000, 0x165000} } },\n\t{{{1, 0x1600000, 0x1601000, 0x166000} } },\n\t{{{0, 0,         0,         0} } },\n\t{{{0, 0,         0,         0} } },\n\t{{{0, 0,         0,         0} } },\n\t{{{0, 0,         0,         0} } },\n\t{{{0, 0,         0,         0} } },\n\t{{{0, 0,         0,         0} } },\n\t{{{1, 0x1d00000, 0x1d10000, 0x190000} } },\n\t{{{1, 0x1e00000, 0x1e01000, 0x16a000} } },\n\t{{{1, 0x1f00000, 0x1f10000, 0x150000} } },\n\t{{{0} } },\n\t{{{1, 0x2100000, 0x2102000, 0x120000},\n\t{1, 0x2110000, 0x2120000, 0x130000},\n\t{1, 0x2120000, 0x2122000, 0x124000},\n\t{1, 0x2130000, 0x2132000, 0x126000},\n\t{1, 0x2140000, 0x2142000, 0x128000},\n\t{1, 0x2150000, 0x2152000, 0x12a000},\n\t{1, 0x2160000, 0x2170000, 0x110000},\n\t{1, 0x2170000, 0x2172000, 0x12e000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000},\n\t{0, 0x0000000, 0x0000000, 0x000000} } },\n\t{{{1, 0x2200000, 0x2204000, 0x1b0000} } },\n\t{{{0} } },\n\t{{{0} } },\n\t{{{0} } },\n\t{{{0} } },\n\t{{{0} } },\n\t{{{1, 0x2800000, 0x2804000, 0x1a4000} } },\n\t{{{1, 0x2900000, 0x2901000, 0x16b000} } },\n\t{{{1, 0x2a00000, 0x2a00400, 0x1ac400} } },\n\t{{{1, 0x2b00000, 0x2b00400, 0x1ac800} } },\n\t{{{1, 0x2c00000, 0x2c00400, 0x1acc00} } },\n\t{{{1, 0x2d00000, 0x2d00400, 0x1ad000} } },\n\t{{{1, 0x2e00000, 0x2e00400, 0x1ad400} } },\n\t{{{1, 0x2f00000, 0x2f00400, 0x1ad800} } },\n\t{{{1, 0x3000000, 0x3000400, 0x1adc00} } },\n\t{{{0, 0x3100000, 0x3104000, 0x1a8000} } },\n\t{{{1, 0x3200000, 0x3204000, 0x1d4000} } },\n\t{{{1, 0x3300000, 0x3304000, 0x1a0000} } },\n\t{{{0} } },\n\t{{{1, 0x3500000, 0x3500400, 0x1ac000} } },\n\t{{{1, 0x3600000, 0x3600400, 0x1ae000} } },\n\t{{{1, 0x3700000, 0x3700400, 0x1ae400} } },\n\t{{{1, 0x3800000, 0x3804000, 0x1d0000} } },\n\t{{{1, 0x3900000, 0x3904000, 0x1b4000} } },\n\t{{{1, 0x3a00000, 0x3a04000, 0x1d8000} } },\n\t{{{0} } },\n\t{{{0} } },\n\t{{{1, 0x3d00000, 0x3d04000, 0x1dc000} } },\n\t{{{1, 0x3e00000, 0x3e01000, 0x167000} } },\n\t{{{1, 0x3f00000, 0x3f01000, 0x168000} } }\n};\n\n \nstatic unsigned qla82xx_crb_hub_agt[64] = {\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PS,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_MN,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_MS,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SRE,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_NIU,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_QMN,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SQN0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SQN1,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SQN2,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SQN3,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_I2Q,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_TIMR,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_ROMUSB,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN4,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_XDMA,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN1,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN2,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN3,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGND,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGNI,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGS0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGS1,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGS2,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGS3,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGSI,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SN,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_EG,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PS,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_CAM,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_TIMR,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX1,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX2,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX3,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX4,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX5,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX6,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX7,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_XDMA,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_I2Q,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_ROMUSB,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX8,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX9,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_OCM0,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SMB,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_I2C0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_I2C1,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGNC,\n\t0,\n};\n\n \nstatic const char *const q_dev_state[] = {\n\t[QLA8XXX_DEV_UNKNOWN]\t\t= \"Unknown\",\n\t[QLA8XXX_DEV_COLD]\t\t= \"Cold/Re-init\",\n\t[QLA8XXX_DEV_INITIALIZING]\t= \"Initializing\",\n\t[QLA8XXX_DEV_READY]\t\t= \"Ready\",\n\t[QLA8XXX_DEV_NEED_RESET]\t= \"Need Reset\",\n\t[QLA8XXX_DEV_NEED_QUIESCENT]\t= \"Need Quiescent\",\n\t[QLA8XXX_DEV_FAILED]\t\t= \"Failed\",\n\t[QLA8XXX_DEV_QUIESCENT]\t\t= \"Quiescent\",\n};\n\nconst char *qdev_state(uint32_t dev_state)\n{\n\treturn (dev_state < MAX_STATES) ? q_dev_state[dev_state] : \"Unknown\";\n}\n\n \nstatic void\nqla82xx_pci_set_crbwindow_2M(struct qla_hw_data *ha, ulong off_in,\n\t\t\t     void __iomem **off_out)\n{\n\tu32 win_read;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tha->crb_win = CRB_HI(off_in);\n\twritel(ha->crb_win, CRB_WINDOW_2M + ha->nx_pcibase);\n\n\t \n\twin_read = rd_reg_dword(CRB_WINDOW_2M + ha->nx_pcibase);\n\tif (win_read != ha->crb_win) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb000,\n\t\t    \"%s: Written crbwin (0x%x) \"\n\t\t    \"!= Read crbwin (0x%x), off=0x%lx.\\n\",\n\t\t    __func__, ha->crb_win, win_read, off_in);\n\t}\n\t*off_out = (off_in & MASK(16)) + CRB_INDIRECT_2M + ha->nx_pcibase;\n}\n\nstatic int\nqla82xx_pci_get_crb_addr_2M(struct qla_hw_data *ha, ulong off_in,\n\t\t\t    void __iomem **off_out)\n{\n\tstruct crb_128M_2M_sub_block_map *m;\n\n\tif (off_in >= QLA82XX_CRB_MAX)\n\t\treturn -1;\n\n\tif (off_in >= QLA82XX_PCI_CAMQM && off_in < QLA82XX_PCI_CAMQM_2M_END) {\n\t\t*off_out = (off_in - QLA82XX_PCI_CAMQM) +\n\t\t    QLA82XX_PCI_CAMQM_2M_BASE + ha->nx_pcibase;\n\t\treturn 0;\n\t}\n\n\tif (off_in < QLA82XX_PCI_CRBSPACE)\n\t\treturn -1;\n\n\toff_in -= QLA82XX_PCI_CRBSPACE;\n\n\t \n\tm = &crb_128M_2M_map[CRB_BLK(off_in)].sub_block[CRB_SUBBLK(off_in)];\n\n\tif (m->valid && (m->start_128M <= off_in) && (m->end_128M > off_in)) {\n\t\t*off_out = off_in + m->start_2M - m->start_128M + ha->nx_pcibase;\n\t\treturn 0;\n\t}\n\t \n\t*off_out = (void __iomem *)off_in;\n\treturn 1;\n}\n\n#define CRB_WIN_LOCK_TIMEOUT 100000000\nstatic int qla82xx_crb_win_lock(struct qla_hw_data *ha)\n{\n\tint done = 0, timeout = 0;\n\n\twhile (!done) {\n\t\t \n\t\tdone = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_LOCK));\n\t\tif (done == 1)\n\t\t\tbreak;\n\t\tif (timeout >= CRB_WIN_LOCK_TIMEOUT)\n\t\t\treturn -1;\n\t\ttimeout++;\n\t}\n\tqla82xx_wr_32(ha, QLA82XX_CRB_WIN_LOCK_ID, ha->portnum);\n\treturn 0;\n}\n\nint\nqla82xx_wr_32(struct qla_hw_data *ha, ulong off_in, u32 data)\n{\n\tvoid __iomem *off;\n\tunsigned long flags = 0;\n\tint rv;\n\n\trv = qla82xx_pci_get_crb_addr_2M(ha, off_in, &off);\n\n\tBUG_ON(rv == -1);\n\n\tif (rv == 1) {\n#ifndef __CHECKER__\n\t\twrite_lock_irqsave(&ha->hw_lock, flags);\n#endif\n\t\tqla82xx_crb_win_lock(ha);\n\t\tqla82xx_pci_set_crbwindow_2M(ha, off_in, &off);\n\t}\n\n\twritel(data, (void __iomem *)off);\n\n\tif (rv == 1) {\n\t\tqla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));\n#ifndef __CHECKER__\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n#endif\n\t}\n\treturn 0;\n}\n\nint\nqla82xx_rd_32(struct qla_hw_data *ha, ulong off_in)\n{\n\tvoid __iomem *off;\n\tunsigned long flags = 0;\n\tint rv;\n\tu32 data;\n\n\trv = qla82xx_pci_get_crb_addr_2M(ha, off_in, &off);\n\n\tBUG_ON(rv == -1);\n\n\tif (rv == 1) {\n#ifndef __CHECKER__\n\t\twrite_lock_irqsave(&ha->hw_lock, flags);\n#endif\n\t\tqla82xx_crb_win_lock(ha);\n\t\tqla82xx_pci_set_crbwindow_2M(ha, off_in, &off);\n\t}\n\tdata = rd_reg_dword(off);\n\n\tif (rv == 1) {\n\t\tqla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));\n#ifndef __CHECKER__\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n#endif\n\t}\n\treturn data;\n}\n\n \nint qla82xx_idc_lock(struct qla_hw_data *ha)\n{\n\tconst int delay_ms = 100, timeout_ms = 2000;\n\tint done, total = 0;\n\n\tmight_sleep();\n\n\twhile (true) {\n\t\t \n\t\tdone = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_LOCK));\n\t\tif (done == 1)\n\t\t\tbreak;\n\t\tif (WARN_ON_ONCE(total >= timeout_ms))\n\t\t\treturn -1;\n\n\t\ttotal += delay_ms;\n\t\tmsleep(delay_ms);\n\t}\n\n\treturn 0;\n}\n\nvoid qla82xx_idc_unlock(struct qla_hw_data *ha)\n{\n\tqla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_UNLOCK));\n}\n\n \nstatic unsigned long\nqla82xx_pci_mem_bound_check(struct qla_hw_data *ha,\n\tunsigned long long addr, int size)\n{\n\tif (!addr_in_range(addr, QLA82XX_ADDR_DDR_NET,\n\t\tQLA82XX_ADDR_DDR_NET_MAX) ||\n\t\t!addr_in_range(addr + size - 1, QLA82XX_ADDR_DDR_NET,\n\t\tQLA82XX_ADDR_DDR_NET_MAX) ||\n\t\t((size != 1) && (size != 2) && (size != 4) && (size != 8)))\n\t\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic int qla82xx_pci_set_window_warning_count;\n\nstatic unsigned long\nqla82xx_pci_set_window(struct qla_hw_data *ha, unsigned long long addr)\n{\n\tint window;\n\tu32 win_read;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tif (addr_in_range(addr, QLA82XX_ADDR_DDR_NET,\n\t\tQLA82XX_ADDR_DDR_NET_MAX)) {\n\t\t \n\t\twindow = MN_WIN(addr);\n\t\tha->ddr_mn_window = window;\n\t\tqla82xx_wr_32(ha,\n\t\t\tha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);\n\t\twin_read = qla82xx_rd_32(ha,\n\t\t\tha->mn_win_crb | QLA82XX_PCI_CRBSPACE);\n\t\tif ((win_read << 17) != window) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb003,\n\t\t\t    \"%s: Written MNwin (0x%x) != Read MNwin (0x%x).\\n\",\n\t\t\t    __func__, window, win_read);\n\t\t}\n\t\taddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_DDR_NET;\n\t} else if (addr_in_range(addr, QLA82XX_ADDR_OCM0,\n\t\tQLA82XX_ADDR_OCM0_MAX)) {\n\t\tunsigned int temp1;\n\n\t\tif ((addr & 0x00ff800) == 0xff800) {\n\t\t\tql_log(ql_log_warn, vha, 0xb004,\n\t\t\t    \"%s: QM access not handled.\\n\", __func__);\n\t\t\taddr = -1UL;\n\t\t}\n\t\twindow = OCM_WIN(addr);\n\t\tha->ddr_mn_window = window;\n\t\tqla82xx_wr_32(ha,\n\t\t\tha->mn_win_crb | QLA82XX_PCI_CRBSPACE, window);\n\t\twin_read = qla82xx_rd_32(ha,\n\t\t\tha->mn_win_crb | QLA82XX_PCI_CRBSPACE);\n\t\ttemp1 = ((window & 0x1FF) << 7) |\n\t\t    ((window & 0x0FFFE0000) >> 17);\n\t\tif (win_read != temp1) {\n\t\t\tql_log(ql_log_warn, vha, 0xb005,\n\t\t\t    \"%s: Written OCMwin (0x%x) != Read OCMwin (0x%x).\\n\",\n\t\t\t    __func__, temp1, win_read);\n\t\t}\n\t\taddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_OCM0_2M;\n\n\t} else if (addr_in_range(addr, QLA82XX_ADDR_QDR_NET,\n\t\tQLA82XX_P3_ADDR_QDR_NET_MAX)) {\n\t\t \n\t\twindow = MS_WIN(addr);\n\t\tha->qdr_sn_window = window;\n\t\tqla82xx_wr_32(ha,\n\t\t\tha->ms_win_crb | QLA82XX_PCI_CRBSPACE, window);\n\t\twin_read = qla82xx_rd_32(ha,\n\t\t\tha->ms_win_crb | QLA82XX_PCI_CRBSPACE);\n\t\tif (win_read != window) {\n\t\t\tql_log(ql_log_warn, vha, 0xb006,\n\t\t\t    \"%s: Written MSwin (0x%x) != Read MSwin (0x%x).\\n\",\n\t\t\t    __func__, window, win_read);\n\t\t}\n\t\taddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_QDR_NET;\n\t} else {\n\t\t \n\t\tif ((qla82xx_pci_set_window_warning_count++ < 8) ||\n\t\t    (qla82xx_pci_set_window_warning_count%64 == 0)) {\n\t\t\tql_log(ql_log_warn, vha, 0xb007,\n\t\t\t    \"%s: Warning:%s Unknown address range!.\\n\",\n\t\t\t    __func__, QLA2XXX_DRIVER_NAME);\n\t\t}\n\t\taddr = -1UL;\n\t}\n\treturn addr;\n}\n\n \nstatic int qla82xx_pci_is_same_window(struct qla_hw_data *ha,\n\tunsigned long long addr)\n{\n\tint\t\t\twindow;\n\tunsigned long long\tqdr_max;\n\n\tqdr_max = QLA82XX_P3_ADDR_QDR_NET_MAX;\n\n\t \n\tif (addr_in_range(addr, QLA82XX_ADDR_DDR_NET,\n\t\tQLA82XX_ADDR_DDR_NET_MAX))\n\t\tBUG();\n\telse if (addr_in_range(addr, QLA82XX_ADDR_OCM0,\n\t\tQLA82XX_ADDR_OCM0_MAX))\n\t\treturn 1;\n\telse if (addr_in_range(addr, QLA82XX_ADDR_OCM1,\n\t\tQLA82XX_ADDR_OCM1_MAX))\n\t\treturn 1;\n\telse if (addr_in_range(addr, QLA82XX_ADDR_QDR_NET, qdr_max)) {\n\t\t \n\t\twindow = ((addr - QLA82XX_ADDR_QDR_NET) >> 22) & 0x3f;\n\t\tif (ha->qdr_sn_window == window)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int qla82xx_pci_mem_read_direct(struct qla_hw_data *ha,\n\tu64 off, void *data, int size)\n{\n\tunsigned long   flags;\n\tvoid __iomem *addr = NULL;\n\tint             ret = 0;\n\tu64             start;\n\tuint8_t __iomem  *mem_ptr = NULL;\n\tunsigned long   mem_base;\n\tunsigned long   mem_page;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\n\t \n\tstart = qla82xx_pci_set_window(ha, off);\n\tif ((start == -1UL) ||\n\t\t(qla82xx_pci_is_same_window(ha, off + size - 1) == 0)) {\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\tql_log(ql_log_fatal, vha, 0xb008,\n\t\t    \"%s out of bound pci memory \"\n\t\t    \"access, offset is 0x%llx.\\n\",\n\t\t    QLA2XXX_DRIVER_NAME, off);\n\t\treturn -1;\n\t}\n\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\tmem_base = pci_resource_start(ha->pdev, 0);\n\tmem_page = start & PAGE_MASK;\n\t \n\tif (mem_page != ((start + size - 1) & PAGE_MASK))\n\t\tmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE * 2);\n\telse\n\t\tmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\n\tif (mem_ptr == NULL) {\n\t\t*(u8  *)data = 0;\n\t\treturn -1;\n\t}\n\taddr = mem_ptr;\n\taddr += start & (PAGE_SIZE - 1);\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\n\tswitch (size) {\n\tcase 1:\n\t\t*(u8  *)data = readb(addr);\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)data = readw(addr);\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)data = readl(addr);\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)data = readq(addr);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\n\tif (mem_ptr)\n\t\tiounmap(mem_ptr);\n\treturn ret;\n}\n\nstatic int\nqla82xx_pci_mem_write_direct(struct qla_hw_data *ha,\n\tu64 off, void *data, int size)\n{\n\tunsigned long   flags;\n\tvoid  __iomem *addr = NULL;\n\tint             ret = 0;\n\tu64             start;\n\tuint8_t __iomem *mem_ptr = NULL;\n\tunsigned long   mem_base;\n\tunsigned long   mem_page;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\n\t \n\tstart = qla82xx_pci_set_window(ha, off);\n\tif ((start == -1UL) ||\n\t\t(qla82xx_pci_is_same_window(ha, off + size - 1) == 0)) {\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\tql_log(ql_log_fatal, vha, 0xb009,\n\t\t    \"%s out of bound memory \"\n\t\t    \"access, offset is 0x%llx.\\n\",\n\t\t    QLA2XXX_DRIVER_NAME, off);\n\t\treturn -1;\n\t}\n\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\tmem_base = pci_resource_start(ha->pdev, 0);\n\tmem_page = start & PAGE_MASK;\n\t \n\tif (mem_page != ((start + size - 1) & PAGE_MASK))\n\t\tmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE*2);\n\telse\n\t\tmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\n\tif (mem_ptr == NULL)\n\t\treturn -1;\n\n\taddr = mem_ptr;\n\taddr += start & (PAGE_SIZE - 1);\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\n\tswitch (size) {\n\tcase 1:\n\t\twriteb(*(u8  *)data, addr);\n\t\tbreak;\n\tcase 2:\n\t\twritew(*(u16 *)data, addr);\n\t\tbreak;\n\tcase 4:\n\t\twritel(*(u32 *)data, addr);\n\t\tbreak;\n\tcase 8:\n\t\twriteq(*(u64 *)data, addr);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\tif (mem_ptr)\n\t\tiounmap(mem_ptr);\n\treturn ret;\n}\n\n#define MTU_FUDGE_FACTOR 100\nstatic unsigned long\nqla82xx_decode_crb_addr(unsigned long addr)\n{\n\tint i;\n\tunsigned long base_addr, offset, pci_base;\n\n\tif (!qla82xx_crb_table_initialized)\n\t\tqla82xx_crb_addr_transform_setup();\n\n\tpci_base = ADDR_ERROR;\n\tbase_addr = addr & 0xfff00000;\n\toffset = addr & 0x000fffff;\n\n\tfor (i = 0; i < MAX_CRB_XFORM; i++) {\n\t\tif (crb_addr_xform[i] == base_addr) {\n\t\t\tpci_base = i << 20;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pci_base == ADDR_ERROR)\n\t\treturn pci_base;\n\treturn pci_base + offset;\n}\n\nstatic long rom_max_timeout = 100;\nstatic long qla82xx_rom_lock_timeout = 100;\n\nstatic int\nqla82xx_rom_lock(struct qla_hw_data *ha)\n{\n\tint done = 0, timeout = 0;\n\tuint32_t lock_owner = 0;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\twhile (!done) {\n\t\t \n\t\tdone = qla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_LOCK));\n\t\tif (done == 1)\n\t\t\tbreak;\n\t\tif (timeout >= qla82xx_rom_lock_timeout) {\n\t\t\tlock_owner = qla82xx_rd_32(ha, QLA82XX_ROM_LOCK_ID);\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb157,\n\t\t\t    \"%s: Simultaneous flash access by following ports, active port = %d: accessing port = %d\",\n\t\t\t    __func__, ha->portnum, lock_owner);\n\t\t\treturn -1;\n\t\t}\n\t\ttimeout++;\n\t}\n\tqla82xx_wr_32(ha, QLA82XX_ROM_LOCK_ID, ha->portnum);\n\treturn 0;\n}\n\nstatic void\nqla82xx_rom_unlock(struct qla_hw_data *ha)\n{\n\tqla82xx_wr_32(ha, QLA82XX_ROM_LOCK_ID, 0xffffffff);\n\tqla82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_UNLOCK));\n}\n\nstatic int\nqla82xx_wait_rom_busy(struct qla_hw_data *ha)\n{\n\tlong timeout = 0;\n\tlong done = 0 ;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\twhile (done == 0) {\n\t\tdone = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);\n\t\tdone &= 4;\n\t\ttimeout++;\n\t\tif (timeout >= rom_max_timeout) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb00a,\n\t\t\t    \"%s: Timeout reached waiting for rom busy.\\n\",\n\t\t\t    QLA2XXX_DRIVER_NAME);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nqla82xx_wait_rom_done(struct qla_hw_data *ha)\n{\n\tlong timeout = 0;\n\tlong done = 0 ;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\twhile (done == 0) {\n\t\tdone = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);\n\t\tdone &= 2;\n\t\ttimeout++;\n\t\tif (timeout >= rom_max_timeout) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb00b,\n\t\t\t    \"%s: Timeout reached waiting for rom done.\\n\",\n\t\t\t    QLA2XXX_DRIVER_NAME);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nqla82xx_md_rw_32(struct qla_hw_data *ha, uint32_t off, u32 data, uint8_t flag)\n{\n\tuint32_t  off_value, rval = 0;\n\n\twrt_reg_dword(CRB_WINDOW_2M + ha->nx_pcibase, off & 0xFFFF0000);\n\n\t \n\trd_reg_dword(CRB_WINDOW_2M + ha->nx_pcibase);\n\toff_value  = (off & 0x0000FFFF);\n\n\tif (flag)\n\t\twrt_reg_dword(off_value + CRB_INDIRECT_2M + ha->nx_pcibase,\n\t\t\t      data);\n\telse\n\t\trval = rd_reg_dword(off_value + CRB_INDIRECT_2M +\n\t\t\t\t    ha->nx_pcibase);\n\n\treturn rval;\n}\n\nstatic int\nqla82xx_do_rom_fast_read(struct qla_hw_data *ha, int addr, int *valp)\n{\n\t \n\tqla82xx_md_rw_32(ha, MD_DIRECT_ROM_WINDOW, (addr & 0xFFFF0000), 1);\n\t*valp = qla82xx_md_rw_32(ha, MD_DIRECT_ROM_READ_BASE +\n\t    (addr & 0x0000FFFF), 0, 0);\n\n\treturn 0;\n}\n\nstatic int\nqla82xx_rom_fast_read(struct qla_hw_data *ha, int addr, int *valp)\n{\n\tint ret, loops = 0;\n\tuint32_t lock_owner = 0;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\twhile ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {\n\t\tudelay(100);\n\t\tschedule();\n\t\tloops++;\n\t}\n\tif (loops >= 50000) {\n\t\tlock_owner = qla82xx_rd_32(ha, QLA82XX_ROM_LOCK_ID);\n\t\tql_log(ql_log_fatal, vha, 0x00b9,\n\t\t    \"Failed to acquire SEM2 lock, Lock Owner %u.\\n\",\n\t\t    lock_owner);\n\t\treturn -1;\n\t}\n\tret = qla82xx_do_rom_fast_read(ha, addr, valp);\n\tqla82xx_rom_unlock(ha);\n\treturn ret;\n}\n\nstatic int\nqla82xx_read_status_reg(struct qla_hw_data *ha, uint32_t *val)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_RDSR);\n\tqla82xx_wait_rom_busy(ha);\n\tif (qla82xx_wait_rom_done(ha)) {\n\t\tql_log(ql_log_warn, vha, 0xb00c,\n\t\t    \"Error waiting for rom done.\\n\");\n\t\treturn -1;\n\t}\n\t*val = qla82xx_rd_32(ha, QLA82XX_ROMUSB_ROM_RDATA);\n\treturn 0;\n}\n\nstatic int\nqla82xx_flash_wait_write_finish(struct qla_hw_data *ha)\n{\n\tuint32_t val = 0;\n\tint i, ret;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);\n\tfor (i = 0; i < 50000; i++) {\n\t\tret = qla82xx_read_status_reg(ha, &val);\n\t\tif (ret < 0 || (val & 1) == 0)\n\t\t\treturn ret;\n\t\tudelay(10);\n\t\tcond_resched();\n\t}\n\tql_log(ql_log_warn, vha, 0xb00d,\n\t       \"Timeout reached waiting for write finish.\\n\");\n\treturn -1;\n}\n\nstatic int\nqla82xx_flash_set_write_enable(struct qla_hw_data *ha)\n{\n\tuint32_t val;\n\n\tqla82xx_wait_rom_busy(ha);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_WREN);\n\tqla82xx_wait_rom_busy(ha);\n\tif (qla82xx_wait_rom_done(ha))\n\t\treturn -1;\n\tif (qla82xx_read_status_reg(ha, &val) != 0)\n\t\treturn -1;\n\tif ((val & 2) != 2)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int\nqla82xx_write_status_reg(struct qla_hw_data *ha, uint32_t val)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tif (qla82xx_flash_set_write_enable(ha))\n\t\treturn -1;\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_WDATA, val);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, 0x1);\n\tif (qla82xx_wait_rom_done(ha)) {\n\t\tql_log(ql_log_warn, vha, 0xb00e,\n\t\t    \"Error waiting for rom done.\\n\");\n\t\treturn -1;\n\t}\n\treturn qla82xx_flash_wait_write_finish(ha);\n}\n\nstatic int\nqla82xx_write_disable_flash(struct qla_hw_data *ha)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_WRDI);\n\tif (qla82xx_wait_rom_done(ha)) {\n\t\tql_log(ql_log_warn, vha, 0xb00f,\n\t\t    \"Error waiting for rom done.\\n\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nql82xx_rom_lock_d(struct qla_hw_data *ha)\n{\n\tint loops = 0;\n\tuint32_t lock_owner = 0;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\twhile ((qla82xx_rom_lock(ha) != 0) && (loops < 50000)) {\n\t\tudelay(100);\n\t\tcond_resched();\n\t\tloops++;\n\t}\n\tif (loops >= 50000) {\n\t\tlock_owner = qla82xx_rd_32(ha, QLA82XX_ROM_LOCK_ID);\n\t\tql_log(ql_log_warn, vha, 0xb010,\n\t\t    \"ROM lock failed, Lock Owner %u.\\n\", lock_owner);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nqla82xx_write_flash_dword(struct qla_hw_data *ha, uint32_t flashaddr,\n\tuint32_t data)\n{\n\tint ret = 0;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tret = ql82xx_rom_lock_d(ha);\n\tif (ret < 0) {\n\t\tql_log(ql_log_warn, vha, 0xb011,\n\t\t    \"ROM lock failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qla82xx_flash_set_write_enable(ha);\n\tif (ret < 0)\n\t\tgoto done_write;\n\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_WDATA, data);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, flashaddr);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_PP);\n\tqla82xx_wait_rom_busy(ha);\n\tif (qla82xx_wait_rom_done(ha)) {\n\t\tql_log(ql_log_warn, vha, 0xb012,\n\t\t    \"Error waiting for rom done.\\n\");\n\t\tret = -1;\n\t\tgoto done_write;\n\t}\n\n\tret = qla82xx_flash_wait_write_finish(ha);\n\ndone_write:\n\tqla82xx_rom_unlock(ha);\n\treturn ret;\n}\n\n \nstatic int\nqla82xx_pinit_from_rom(scsi_qla_host_t *vha)\n{\n\tint addr, val;\n\tint i ;\n\tstruct crb_addr_pair *buf;\n\tunsigned long off;\n\tunsigned offset, n;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tstruct crb_addr_pair {\n\t\tlong addr;\n\t\tlong data;\n\t};\n\n\t \n\tqla82xx_rom_lock(ha);\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x10, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x14, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x18, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x1c, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x20, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x24, 0x0);\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x40, 0xff);\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x70000, 0x00);\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x80000, 0x00);\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x90000, 0x00);\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xa0000, 0x00);\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xb0000, 0x00);\n\n\t \n\tval = qla82xx_rd_32(ha, QLA82XX_CRB_SRE + 0x1000);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_SRE + 0x1000, val & (~(0x1)));\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_EPG + 0x1300, 0x1);\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x0, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x8, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x10, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x18, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x100, 0x0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x200, 0x0);\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x3c, 1);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x3c, 1);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x3c, 1);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x3c, 1);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_4 + 0x3c, 1);\n\tmsleep(20);\n\n\t \n\tif (test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags))\n\t\t \n\t\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);\n\telse\n\t\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);\n\tqla82xx_rom_unlock(ha);\n\n\t \n\tn = 0;\n\tif (qla82xx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||\n\t    qla82xx_rom_fast_read(ha, 4, &n) != 0) {\n\t\tql_log(ql_log_fatal, vha, 0x006e,\n\t\t    \"Error Reading crb_init area: n: %08x.\\n\", n);\n\t\treturn -1;\n\t}\n\n\t \n\toffset = n & 0xffffU;\n\tn = (n >> 16) & 0xffffU;\n\n\t \n\tif (n  >= 1024) {\n\t\tql_log(ql_log_fatal, vha, 0x0071,\n\t\t    \"Card flash not initialized:n=0x%x.\\n\", n);\n\t\treturn -1;\n\t}\n\n\tql_log(ql_log_info, vha, 0x0072,\n\t    \"%d CRB init values found in ROM.\\n\", n);\n\n\tbuf = kmalloc_array(n, sizeof(struct crb_addr_pair), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tql_log(ql_log_fatal, vha, 0x010c,\n\t\t    \"Unable to allocate memory.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (qla82xx_rom_fast_read(ha, 8*i + 4*offset, &val) != 0 ||\n\t\t    qla82xx_rom_fast_read(ha, 8*i + 4*offset + 4, &addr) != 0) {\n\t\t\tkfree(buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf[i].addr = addr;\n\t\tbuf[i].data = val;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\t \n\t\toff = qla82xx_decode_crb_addr((unsigned long)buf[i].addr) +\n\t\t    QLA82XX_PCI_CRBSPACE;\n\t\t \n\n\t\t \n\t\tif (off == QLA82XX_CAM_RAM(0x1fc))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (off == (ROMUSB_GLB + 0xbc))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (off == (ROMUSB_GLB + 0xc8))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION))\n\t\t\tcontinue;\n\n\t\tif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION2))\n\t\t\tcontinue;\n\n\t\tif ((off & 0x0ff00000) == QLA82XX_CRB_SMB)\n\t\t\tcontinue;\n\n\t\tif ((off & 0x0ff00000) == QLA82XX_CRB_DDR_NET)\n\t\t\tcontinue;\n\n\t\tif (off == ADDR_ERROR) {\n\t\t\tql_log(ql_log_fatal, vha, 0x0116,\n\t\t\t    \"Unknown addr: 0x%08lx.\\n\", buf[i].addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqla82xx_wr_32(ha, off, buf[i].data);\n\n\t\t \n\t\tif (off == QLA82XX_ROMUSB_GLB_SW_RESET)\n\t\t\tmsleep(1000);\n\n\t\t \n\t\tmsleep(1);\n\t}\n\n\tkfree(buf);\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0xec, 0x1e);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0x4c, 8);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_I+0x4c, 8);\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0x8, 0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0xc, 0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0x8, 0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0xc, 0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0x8, 0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0xc, 0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0x8, 0);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0xc, 0);\n\treturn 0;\n}\n\nstatic int\nqla82xx_pci_mem_write_2M(struct qla_hw_data *ha,\n\t\tu64 off, void *data, int size)\n{\n\tint i, j, ret = 0, loop, sz[2], off0;\n\tint scale, shift_amount, startword;\n\tuint32_t temp;\n\tuint64_t off8, mem_crb, tmpw, word[2] = {0, 0};\n\n\t \n\tif (off >= QLA82XX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\n\t\tmem_crb = QLA82XX_CRB_QDR_NET;\n\telse {\n\t\tmem_crb = QLA82XX_CRB_DDR_NET;\n\t\tif (qla82xx_pci_mem_bound_check(ha, off, size) == 0)\n\t\t\treturn qla82xx_pci_mem_write_direct(ha,\n\t\t\t    off, data, size);\n\t}\n\n\toff0 = off & 0x7;\n\tsz[0] = (size < (8 - off0)) ? size : (8 - off0);\n\tsz[1] = size - sz[0];\n\n\toff8 = off & 0xfffffff0;\n\tloop = (((off & 0xf) + size - 1) >> 4) + 1;\n\tshift_amount = 4;\n\tscale = 2;\n\tstartword = (off & 0xf)/8;\n\n\tfor (i = 0; i < loop; i++) {\n\t\tif (qla82xx_pci_mem_read_2M(ha, off8 +\n\t\t    (i << shift_amount), &word[i * scale], 8))\n\t\t\treturn -1;\n\t}\n\n\tswitch (size) {\n\tcase 1:\n\t\ttmpw = *((uint8_t *)data);\n\t\tbreak;\n\tcase 2:\n\t\ttmpw = *((uint16_t *)data);\n\t\tbreak;\n\tcase 4:\n\t\ttmpw = *((uint32_t *)data);\n\t\tbreak;\n\tcase 8:\n\tdefault:\n\t\ttmpw = *((uint64_t *)data);\n\t\tbreak;\n\t}\n\n\tif (sz[0] == 8) {\n\t\tword[startword] = tmpw;\n\t} else {\n\t\tword[startword] &=\n\t\t\t~((~(~0ULL << (sz[0] * 8))) << (off0 * 8));\n\t\tword[startword] |= tmpw << (off0 * 8);\n\t}\n\tif (sz[1] != 0) {\n\t\tword[startword+1] &= ~(~0ULL << (sz[1] * 8));\n\t\tword[startword+1] |= tmpw >> (sz[0] * 8);\n\t}\n\n\tfor (i = 0; i < loop; i++) {\n\t\ttemp = off8 + (i << shift_amount);\n\t\tqla82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_LO, temp);\n\t\ttemp = 0;\n\t\tqla82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_HI, temp);\n\t\ttemp = word[i * scale] & 0xffffffff;\n\t\tqla82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_LO, temp);\n\t\ttemp = (word[i * scale] >> 32) & 0xffffffff;\n\t\tqla82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_HI, temp);\n\t\ttemp = word[i*scale + 1] & 0xffffffff;\n\t\tqla82xx_wr_32(ha, mem_crb +\n\t\t    MIU_TEST_AGT_WRDATA_UPPER_LO, temp);\n\t\ttemp = (word[i*scale + 1] >> 32) & 0xffffffff;\n\t\tqla82xx_wr_32(ha, mem_crb +\n\t\t    MIU_TEST_AGT_WRDATA_UPPER_HI, temp);\n\n\t\ttemp = MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;\n\t\tqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\n\t\ttemp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE | MIU_TA_CTL_WRITE;\n\t\tqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\ttemp = qla82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\n\t\t\tif ((temp & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_err(&ha->pdev->dev,\n\t\t\t\t    \"failed to write through agent.\\n\");\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\nqla82xx_fw_load_from_flash(struct qla_hw_data *ha)\n{\n\tint  i;\n\tlong size = 0;\n\tlong flashaddr = ha->flt_region_bootload << 2;\n\tlong memaddr = BOOTLD_START;\n\tu64 data;\n\tu32 high, low;\n\n\tsize = (IMAGE_START - BOOTLD_START) / 8;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif ((qla82xx_rom_fast_read(ha, flashaddr, (int *)&low)) ||\n\t\t    (qla82xx_rom_fast_read(ha, flashaddr + 4, (int *)&high))) {\n\t\t\treturn -1;\n\t\t}\n\t\tdata = ((u64)high << 32) | low ;\n\t\tqla82xx_pci_mem_write_2M(ha, memaddr, &data, 8);\n\t\tflashaddr += 8;\n\t\tmemaddr += 8;\n\n\t\tif (i % 0x1000 == 0)\n\t\t\tmsleep(1);\n\t}\n\tudelay(100);\n\tread_lock(&ha->hw_lock);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);\n\tread_unlock(&ha->hw_lock);\n\treturn 0;\n}\n\nint\nqla82xx_pci_mem_read_2M(struct qla_hw_data *ha,\n\t\tu64 off, void *data, int size)\n{\n\tint i, j = 0, k, start, end, loop, sz[2], off0[2];\n\tint\t      shift_amount;\n\tuint32_t      temp;\n\tuint64_t      off8, val, mem_crb, word[2] = {0, 0};\n\n\t \n\n\tif (off >= QLA82XX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\n\t\tmem_crb = QLA82XX_CRB_QDR_NET;\n\telse {\n\t\tmem_crb = QLA82XX_CRB_DDR_NET;\n\t\tif (qla82xx_pci_mem_bound_check(ha, off, size) == 0)\n\t\t\treturn qla82xx_pci_mem_read_direct(ha,\n\t\t\t    off, data, size);\n\t}\n\n\toff8 = off & 0xfffffff0;\n\toff0[0] = off & 0xf;\n\tsz[0] = (size < (16 - off0[0])) ? size : (16 - off0[0]);\n\tshift_amount = 4;\n\tloop = ((off0[0] + size - 1) >> shift_amount) + 1;\n\toff0[1] = 0;\n\tsz[1] = size - sz[0];\n\n\tfor (i = 0; i < loop; i++) {\n\t\ttemp = off8 + (i << shift_amount);\n\t\tqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);\n\t\ttemp = 0;\n\t\tqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);\n\t\ttemp = MIU_TA_CTL_ENABLE;\n\t\tqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\n\t\ttemp = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE;\n\t\tqla82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\ttemp = qla82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\n\t\t\tif ((temp & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_err(&ha->pdev->dev,\n\t\t\t\t    \"failed to read through agent.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tstart = off0[i] >> 2;\n\t\tend   = (off0[i] + sz[i] - 1) >> 2;\n\t\tfor (k = start; k <= end; k++) {\n\t\t\ttemp = qla82xx_rd_32(ha,\n\t\t\t\t\tmem_crb + MIU_TEST_AGT_RDDATA(k));\n\t\t\tword[i] |= ((uint64_t)temp << (32 * (k & 1)));\n\t\t}\n\t}\n\n\tif (j >= MAX_CTL_CHECK)\n\t\treturn -1;\n\n\tif ((off0[0] & 7) == 0) {\n\t\tval = word[0];\n\t} else {\n\t\tval = ((word[0] >> (off0[0] * 8)) & (~(~0ULL << (sz[0] * 8)))) |\n\t\t\t((word[1] & (~(~0ULL << (sz[1] * 8)))) << (sz[0] * 8));\n\t}\n\n\tswitch (size) {\n\tcase 1:\n\t\t*(uint8_t  *)data = val;\n\t\tbreak;\n\tcase 2:\n\t\t*(uint16_t *)data = val;\n\t\tbreak;\n\tcase 4:\n\t\t*(uint32_t *)data = val;\n\t\tbreak;\n\tcase 8:\n\t\t*(uint64_t *)data = val;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n\nstatic struct qla82xx_uri_table_desc *\nqla82xx_get_table_desc(const u8 *unirom, int section)\n{\n\tuint32_t i;\n\tstruct qla82xx_uri_table_desc *directory =\n\t\t(struct qla82xx_uri_table_desc *)&unirom[0];\n\tuint32_t offset;\n\tuint32_t tab_type;\n\tuint32_t entries = le32_to_cpu(directory->num_entries);\n\n\tfor (i = 0; i < entries; i++) {\n\t\toffset = le32_to_cpu(directory->findex) +\n\t\t    (i * le32_to_cpu(directory->entry_size));\n\t\ttab_type = get_unaligned_le32((u32 *)&unirom[offset] + 8);\n\n\t\tif (tab_type == section)\n\t\t\treturn (struct qla82xx_uri_table_desc *)&unirom[offset];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct qla82xx_uri_data_desc *\nqla82xx_get_data_desc(struct qla_hw_data *ha,\n\tu32 section, u32 idx_offset)\n{\n\tconst u8 *unirom = ha->hablob->fw->data;\n\tint idx = get_unaligned_le32((u32 *)&unirom[ha->file_prd_off] +\n\t\t\t\t     idx_offset);\n\tstruct qla82xx_uri_table_desc *tab_desc = NULL;\n\tuint32_t offset;\n\n\ttab_desc = qla82xx_get_table_desc(unirom, section);\n\tif (!tab_desc)\n\t\treturn NULL;\n\n\toffset = le32_to_cpu(tab_desc->findex) +\n\t    (le32_to_cpu(tab_desc->entry_size) * idx);\n\n\treturn (struct qla82xx_uri_data_desc *)&unirom[offset];\n}\n\nstatic u8 *\nqla82xx_get_bootld_offset(struct qla_hw_data *ha)\n{\n\tu32 offset = BOOTLD_START;\n\tstruct qla82xx_uri_data_desc *uri_desc = NULL;\n\n\tif (ha->fw_type == QLA82XX_UNIFIED_ROMIMAGE) {\n\t\turi_desc = qla82xx_get_data_desc(ha,\n\t\t    QLA82XX_URI_DIR_SECT_BOOTLD, QLA82XX_URI_BOOTLD_IDX_OFF);\n\t\tif (uri_desc)\n\t\t\toffset = le32_to_cpu(uri_desc->findex);\n\t}\n\n\treturn (u8 *)&ha->hablob->fw->data[offset];\n}\n\nstatic u32 qla82xx_get_fw_size(struct qla_hw_data *ha)\n{\n\tstruct qla82xx_uri_data_desc *uri_desc = NULL;\n\n\tif (ha->fw_type == QLA82XX_UNIFIED_ROMIMAGE) {\n\t\turi_desc =  qla82xx_get_data_desc(ha, QLA82XX_URI_DIR_SECT_FW,\n\t\t    QLA82XX_URI_FIRMWARE_IDX_OFF);\n\t\tif (uri_desc)\n\t\t\treturn le32_to_cpu(uri_desc->size);\n\t}\n\n\treturn get_unaligned_le32(&ha->hablob->fw->data[FW_SIZE_OFFSET]);\n}\n\nstatic u8 *\nqla82xx_get_fw_offs(struct qla_hw_data *ha)\n{\n\tu32 offset = IMAGE_START;\n\tstruct qla82xx_uri_data_desc *uri_desc = NULL;\n\n\tif (ha->fw_type == QLA82XX_UNIFIED_ROMIMAGE) {\n\t\turi_desc = qla82xx_get_data_desc(ha, QLA82XX_URI_DIR_SECT_FW,\n\t\t\tQLA82XX_URI_FIRMWARE_IDX_OFF);\n\t\tif (uri_desc)\n\t\t\toffset = le32_to_cpu(uri_desc->findex);\n\t}\n\n\treturn (u8 *)&ha->hablob->fw->data[offset];\n}\n\n \nint qla82xx_pci_region_offset(struct pci_dev *pdev, int region)\n{\n\tunsigned long val = 0;\n\tu32 control;\n\n\tswitch (region) {\n\tcase 0:\n\t\tval = 0;\n\t\tbreak;\n\tcase 1:\n\t\tpci_read_config_dword(pdev, QLA82XX_PCI_REG_MSIX_TBL, &control);\n\t\tval = control + QLA82XX_MSIX_TBL_SPACE;\n\t\tbreak;\n\t}\n\treturn val;\n}\n\n\nint\nqla82xx_iospace_config(struct qla_hw_data *ha)\n{\n\tuint32_t len = 0;\n\n\tif (pci_request_regions(ha->pdev, QLA2XXX_DRIVER_NAME)) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x000c,\n\t\t    \"Failed to reserver selected regions.\\n\");\n\t\tgoto iospace_error_exit;\n\t}\n\n\t \n\tif (!(pci_resource_flags(ha->pdev, 0) & IORESOURCE_MEM)) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x000d,\n\t\t    \"Region #0 not an MMIO resource, aborting.\\n\");\n\t\tgoto iospace_error_exit;\n\t}\n\n\tlen = pci_resource_len(ha->pdev, 0);\n\tha->nx_pcibase = ioremap(pci_resource_start(ha->pdev, 0), len);\n\tif (!ha->nx_pcibase) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x000e,\n\t\t    \"Cannot remap pcibase MMIO, aborting.\\n\");\n\t\tgoto iospace_error_exit;\n\t}\n\n\t \n\tif (IS_QLA8044(ha)) {\n\t\tha->iobase = ha->nx_pcibase;\n\t} else if (IS_QLA82XX(ha)) {\n\t\tha->iobase = ha->nx_pcibase + 0xbc000 + (ha->pdev->devfn << 11);\n\t}\n\n\tif (!ql2xdbwr) {\n\t\tha->nxdb_wr_ptr = ioremap((pci_resource_start(ha->pdev, 4) +\n\t\t    (ha->pdev->devfn << 12)), 4);\n\t\tif (!ha->nxdb_wr_ptr) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x000f,\n\t\t\t    \"Cannot remap MMIO, aborting.\\n\");\n\t\t\tgoto iospace_error_exit;\n\t\t}\n\n\t\t \n\t\tha->nxdb_rd_ptr = ha->nx_pcibase + (512 * 1024) +\n\t\t    (ha->pdev->devfn * 8);\n\t} else {\n\t\tha->nxdb_wr_ptr = (void __iomem *)(ha->pdev->devfn == 6 ?\n\t\t\tQLA82XX_CAMRAM_DB1 :\n\t\t\tQLA82XX_CAMRAM_DB2);\n\t}\n\n\tha->max_req_queues = ha->max_rsp_queues = 1;\n\tha->msix_count = ha->max_rsp_queues + 1;\n\tql_dbg_pci(ql_dbg_multiq, ha->pdev, 0xc006,\n\t    \"nx_pci_base=%p iobase=%p \"\n\t    \"max_req_queues=%d msix_count=%d.\\n\",\n\t    ha->nx_pcibase, ha->iobase,\n\t    ha->max_req_queues, ha->msix_count);\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0010,\n\t    \"nx_pci_base=%p iobase=%p \"\n\t    \"max_req_queues=%d msix_count=%d.\\n\",\n\t    ha->nx_pcibase, ha->iobase,\n\t    ha->max_req_queues, ha->msix_count);\n\treturn 0;\n\niospace_error_exit:\n\treturn -ENOMEM;\n}\n\n \n\n \n\n \nint\nqla82xx_pci_config(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint ret;\n\n\tpci_set_master(ha->pdev);\n\tret = pci_set_mwi(ha->pdev);\n\tha->chip_revision = ha->pdev->revision;\n\tql_dbg(ql_dbg_init, vha, 0x0043,\n\t    \"Chip revision:%d; pci_set_mwi() returned %d.\\n\",\n\t    ha->chip_revision, ret);\n\treturn 0;\n}\n\n \nint\nqla82xx_reset_chip(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tha->isp_ops->disable_intrs(ha);\n\n\treturn QLA_SUCCESS;\n}\n\nvoid qla82xx_config_rings(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_82xx __iomem *reg = &ha->iobase->isp82;\n\tstruct init_cb_81xx *icb;\n\tstruct req_que *req = ha->req_q_map[0];\n\tstruct rsp_que *rsp = ha->rsp_q_map[0];\n\n\t \n\ticb = (struct init_cb_81xx *)ha->init_cb;\n\ticb->request_q_outpointer = cpu_to_le16(0);\n\ticb->response_q_inpointer = cpu_to_le16(0);\n\ticb->request_q_length = cpu_to_le16(req->length);\n\ticb->response_q_length = cpu_to_le16(rsp->length);\n\tput_unaligned_le64(req->dma, &icb->request_q_address);\n\tput_unaligned_le64(rsp->dma, &icb->response_q_address);\n\n\twrt_reg_dword(&reg->req_q_out[0], 0);\n\twrt_reg_dword(&reg->rsp_q_in[0], 0);\n\twrt_reg_dword(&reg->rsp_q_out[0], 0);\n}\n\nstatic int\nqla82xx_fw_load_from_blob(struct qla_hw_data *ha)\n{\n\tu64 *ptr64;\n\tu32 i, flashaddr, size;\n\t__le64 data;\n\n\tsize = (IMAGE_START - BOOTLD_START) / 8;\n\n\tptr64 = (u64 *)qla82xx_get_bootld_offset(ha);\n\tflashaddr = BOOTLD_START;\n\n\tfor (i = 0; i < size; i++) {\n\t\tdata = cpu_to_le64(ptr64[i]);\n\t\tif (qla82xx_pci_mem_write_2M(ha, flashaddr, &data, 8))\n\t\t\treturn -EIO;\n\t\tflashaddr += 8;\n\t}\n\n\tflashaddr = FLASH_ADDR_START;\n\tsize = qla82xx_get_fw_size(ha) / 8;\n\tptr64 = (u64 *)qla82xx_get_fw_offs(ha);\n\n\tfor (i = 0; i < size; i++) {\n\t\tdata = cpu_to_le64(ptr64[i]);\n\n\t\tif (qla82xx_pci_mem_write_2M(ha, flashaddr, &data, 8))\n\t\t\treturn -EIO;\n\t\tflashaddr += 8;\n\t}\n\tudelay(100);\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_CAM_RAM(0x1fc), QLA82XX_BDINFO_MAGIC);\n\n\tread_lock(&ha->hw_lock);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);\n\tread_unlock(&ha->hw_lock);\n\treturn 0;\n}\n\nstatic int\nqla82xx_set_product_offset(struct qla_hw_data *ha)\n{\n\tstruct qla82xx_uri_table_desc *ptab_desc = NULL;\n\tconst uint8_t *unirom = ha->hablob->fw->data;\n\tuint32_t i;\n\tuint32_t entries;\n\tuint32_t flags, file_chiprev, offset;\n\tuint8_t chiprev = ha->chip_revision;\n\t \n\tint mn_present = 0;\n\tuint32_t flagbit;\n\n\tptab_desc = qla82xx_get_table_desc(unirom,\n\t\t QLA82XX_URI_DIR_SECT_PRODUCT_TBL);\n\tif (!ptab_desc)\n\t\treturn -1;\n\n\tentries = le32_to_cpu(ptab_desc->num_entries);\n\n\tfor (i = 0; i < entries; i++) {\n\t\toffset = le32_to_cpu(ptab_desc->findex) +\n\t\t\t(i * le32_to_cpu(ptab_desc->entry_size));\n\t\tflags = le32_to_cpu(*((__le32 *)&unirom[offset] +\n\t\t\tQLA82XX_URI_FLAGS_OFF));\n\t\tfile_chiprev = le32_to_cpu(*((__le32 *)&unirom[offset] +\n\t\t\tQLA82XX_URI_CHIP_REV_OFF));\n\n\t\tflagbit = mn_present ? 1 : 2;\n\n\t\tif ((chiprev == file_chiprev) && ((1ULL << flagbit) & flags)) {\n\t\t\tha->file_prd_off = offset;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic int\nqla82xx_validate_firmware_blob(scsi_qla_host_t *vha, uint8_t fw_type)\n{\n\tuint32_t val;\n\tuint32_t min_size;\n\tstruct qla_hw_data *ha = vha->hw;\n\tconst struct firmware *fw = ha->hablob->fw;\n\n\tha->fw_type = fw_type;\n\n\tif (fw_type == QLA82XX_UNIFIED_ROMIMAGE) {\n\t\tif (qla82xx_set_product_offset(ha))\n\t\t\treturn -EINVAL;\n\n\t\tmin_size = QLA82XX_URI_FW_MIN_SIZE;\n\t} else {\n\t\tval = get_unaligned_le32(&fw->data[QLA82XX_FW_MAGIC_OFFSET]);\n\t\tif (val != QLA82XX_BDINFO_MAGIC)\n\t\t\treturn -EINVAL;\n\n\t\tmin_size = QLA82XX_FW_MIN_SIZE;\n\t}\n\n\tif (fw->size < min_size)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int\nqla82xx_check_cmdpeg_state(struct qla_hw_data *ha)\n{\n\tu32 val = 0;\n\tint retries = 60;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tdo {\n\t\tread_lock(&ha->hw_lock);\n\t\tval = qla82xx_rd_32(ha, CRB_CMDPEG_STATE);\n\t\tread_unlock(&ha->hw_lock);\n\n\t\tswitch (val) {\n\t\tcase PHAN_INITIALIZE_COMPLETE:\n\t\tcase PHAN_INITIALIZE_ACK:\n\t\t\treturn QLA_SUCCESS;\n\t\tcase PHAN_INITIALIZE_FAILED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tql_log(ql_log_info, vha, 0x00a8,\n\t\t    \"CRB_CMDPEG_STATE: 0x%x and retries:0x%x.\\n\",\n\t\t    val, retries);\n\n\t\tmsleep(500);\n\n\t} while (--retries);\n\n\tql_log(ql_log_fatal, vha, 0x00a9,\n\t    \"Cmd Peg initialization failed: 0x%x.\\n\", val);\n\n\tval = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_PEGTUNE_DONE);\n\tread_lock(&ha->hw_lock);\n\tqla82xx_wr_32(ha, CRB_CMDPEG_STATE, PHAN_INITIALIZE_FAILED);\n\tread_unlock(&ha->hw_lock);\n\treturn QLA_FUNCTION_FAILED;\n}\n\nstatic int\nqla82xx_check_rcvpeg_state(struct qla_hw_data *ha)\n{\n\tu32 val = 0;\n\tint retries = 60;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tdo {\n\t\tread_lock(&ha->hw_lock);\n\t\tval = qla82xx_rd_32(ha, CRB_RCVPEG_STATE);\n\t\tread_unlock(&ha->hw_lock);\n\n\t\tswitch (val) {\n\t\tcase PHAN_INITIALIZE_COMPLETE:\n\t\tcase PHAN_INITIALIZE_ACK:\n\t\t\treturn QLA_SUCCESS;\n\t\tcase PHAN_INITIALIZE_FAILED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tql_log(ql_log_info, vha, 0x00ab,\n\t\t    \"CRB_RCVPEG_STATE: 0x%x and retries: 0x%x.\\n\",\n\t\t    val, retries);\n\n\t\tmsleep(500);\n\n\t} while (--retries);\n\n\tql_log(ql_log_fatal, vha, 0x00ac,\n\t    \"Rcv Peg initialization failed: 0x%x.\\n\", val);\n\tread_lock(&ha->hw_lock);\n\tqla82xx_wr_32(ha, CRB_RCVPEG_STATE, PHAN_INITIALIZE_FAILED);\n\tread_unlock(&ha->hw_lock);\n\treturn QLA_FUNCTION_FAILED;\n}\n\n \nstatic struct qla82xx_legacy_intr_set legacy_intr[] =\n\tQLA82XX_LEGACY_INTR_CONFIG;\n\n \nvoid\nqla82xx_mbx_completion(scsi_qla_host_t *vha, uint16_t mb0)\n{\n\tuint16_t\tcnt;\n\t__le16 __iomem *wptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct device_reg_82xx __iomem *reg = &ha->iobase->isp82;\n\n\twptr = &reg->mailbox_out[1];\n\n\t \n\tha->flags.mbox_int = 1;\n\tha->mailbox_out[0] = mb0;\n\n\tfor (cnt = 1; cnt < ha->mbx_count; cnt++) {\n\t\tha->mailbox_out[cnt] = rd_reg_word(wptr);\n\t\twptr++;\n\t}\n\n\tif (!ha->mcp)\n\t\tql_dbg(ql_dbg_async, vha, 0x5053,\n\t\t    \"MBX pointer ERROR.\\n\");\n}\n\n \nirqreturn_t\nqla82xx_intr_handler(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct rsp_que *rsp;\n\tstruct device_reg_82xx __iomem *reg;\n\tint status = 0, status1 = 0;\n\tunsigned long\tflags;\n\tunsigned long\titer;\n\tuint32_t\tstat = 0;\n\tuint16_t\tmb[8];\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tql_log(ql_log_info, NULL, 0xb053,\n\t\t    \"%s: NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\tha = rsp->hw;\n\n\tif (!ha->flags.msi_enabled) {\n\t\tstatus = qla82xx_rd_32(ha, ISR_INT_VECTOR);\n\t\tif (!(status & ha->nx_legacy_intr.int_vec_bit))\n\t\t\treturn IRQ_NONE;\n\n\t\tstatus1 = qla82xx_rd_32(ha, ISR_INT_STATE_REG);\n\t\tif (!ISR_IS_LEGACY_INTR_TRIGGERED(status1))\n\t\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tqla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);\n\n\t \n\tqla82xx_rd_32(ha, ISR_INT_VECTOR);\n\tqla82xx_rd_32(ha, ISR_INT_VECTOR);\n\n\treg = &ha->iobase->isp82;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\tfor (iter = 1; iter--; ) {\n\n\t\tif (rd_reg_dword(&reg->host_int)) {\n\t\t\tstat = rd_reg_dword(&reg->host_status);\n\n\t\t\tswitch (stat & 0xff) {\n\t\t\tcase 0x1:\n\t\t\tcase 0x2:\n\t\t\tcase 0x10:\n\t\t\tcase 0x11:\n\t\t\t\tqla82xx_mbx_completion(vha, MSW(stat));\n\t\t\t\tstatus |= MBX_INTERRUPT;\n\t\t\t\tbreak;\n\t\t\tcase 0x12:\n\t\t\t\tmb[0] = MSW(stat);\n\t\t\t\tmb[1] = rd_reg_word(&reg->mailbox_out[1]);\n\t\t\t\tmb[2] = rd_reg_word(&reg->mailbox_out[2]);\n\t\t\t\tmb[3] = rd_reg_word(&reg->mailbox_out[3]);\n\t\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\t\tbreak;\n\t\t\tcase 0x13:\n\t\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x5054,\n\t\t\t\t    \"Unrecognized interrupt type (%d).\\n\",\n\t\t\t\t    stat & 0xff);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twrt_reg_dword(&reg->host_int, 0);\n\t}\n\n\tqla2x00_handle_mbx_completion(ha, status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (!ha->flags.msi_enabled)\n\t\tqla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t\nqla82xx_msix_default(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct rsp_que *rsp;\n\tstruct device_reg_82xx __iomem *reg;\n\tint status = 0;\n\tunsigned long flags;\n\tuint32_t stat = 0;\n\tuint32_t host_int = 0;\n\tuint16_t mb[8];\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tprintk(KERN_INFO\n\t\t\t\"%s(): NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\tha = rsp->hw;\n\n\treg = &ha->iobase->isp82;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\tdo {\n\t\thost_int = rd_reg_dword(&reg->host_int);\n\t\tif (qla2x00_check_reg32_for_disconnect(vha, host_int))\n\t\t\tbreak;\n\t\tif (host_int) {\n\t\t\tstat = rd_reg_dword(&reg->host_status);\n\n\t\t\tswitch (stat & 0xff) {\n\t\t\tcase 0x1:\n\t\t\tcase 0x2:\n\t\t\tcase 0x10:\n\t\t\tcase 0x11:\n\t\t\t\tqla82xx_mbx_completion(vha, MSW(stat));\n\t\t\t\tstatus |= MBX_INTERRUPT;\n\t\t\t\tbreak;\n\t\t\tcase 0x12:\n\t\t\t\tmb[0] = MSW(stat);\n\t\t\t\tmb[1] = rd_reg_word(&reg->mailbox_out[1]);\n\t\t\t\tmb[2] = rd_reg_word(&reg->mailbox_out[2]);\n\t\t\t\tmb[3] = rd_reg_word(&reg->mailbox_out[3]);\n\t\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\t\tbreak;\n\t\t\tcase 0x13:\n\t\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x5041,\n\t\t\t\t    \"Unrecognized interrupt type (%d).\\n\",\n\t\t\t\t    stat & 0xff);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twrt_reg_dword(&reg->host_int, 0);\n\t} while (0);\n\n\tqla2x00_handle_mbx_completion(ha, status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t\nqla82xx_msix_rsp_q(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct rsp_que *rsp;\n\tstruct device_reg_82xx __iomem *reg;\n\tunsigned long flags;\n\tuint32_t host_int = 0;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tprintk(KERN_INFO\n\t\t\t\"%s(): NULL response queue pointer.\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\n\tha = rsp->hw;\n\treg = &ha->iobase->isp82;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\thost_int = rd_reg_dword(&reg->host_int);\n\tif (qla2x00_check_reg32_for_disconnect(vha, host_int))\n\t\tgoto out;\n\tqla24xx_process_response_queue(vha, rsp);\n\twrt_reg_dword(&reg->host_int, 0);\nout:\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nvoid\nqla82xx_poll(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct rsp_que *rsp;\n\tstruct device_reg_82xx __iomem *reg;\n\tuint32_t stat;\n\tuint32_t host_int = 0;\n\tuint16_t mb[8];\n\tunsigned long flags;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tprintk(KERN_INFO\n\t\t\t\"%s(): NULL response queue pointer.\\n\", __func__);\n\t\treturn;\n\t}\n\tha = rsp->hw;\n\n\treg = &ha->iobase->isp82;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvha = pci_get_drvdata(ha->pdev);\n\n\thost_int = rd_reg_dword(&reg->host_int);\n\tif (qla2x00_check_reg32_for_disconnect(vha, host_int))\n\t\tgoto out;\n\tif (host_int) {\n\t\tstat = rd_reg_dword(&reg->host_status);\n\t\tswitch (stat & 0xff) {\n\t\tcase 0x1:\n\t\tcase 0x2:\n\t\tcase 0x10:\n\t\tcase 0x11:\n\t\t\tqla82xx_mbx_completion(vha, MSW(stat));\n\t\t\tbreak;\n\t\tcase 0x12:\n\t\t\tmb[0] = MSW(stat);\n\t\t\tmb[1] = rd_reg_word(&reg->mailbox_out[1]);\n\t\t\tmb[2] = rd_reg_word(&reg->mailbox_out[2]);\n\t\t\tmb[3] = rd_reg_word(&reg->mailbox_out[3]);\n\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\tbreak;\n\t\tcase 0x13:\n\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb013,\n\t\t\t    \"Unrecognized interrupt type (%d).\\n\",\n\t\t\t    stat * 0xff);\n\t\t\tbreak;\n\t\t}\n\t\twrt_reg_dword(&reg->host_int, 0);\n\t}\nout:\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nvoid\nqla82xx_enable_intrs(struct qla_hw_data *ha)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tqla82xx_mbx_intr_enable(vha);\n\tspin_lock_irq(&ha->hardware_lock);\n\tif (IS_QLA8044(ha))\n\t\tqla8044_wr_reg(ha, LEG_INTR_MASK_OFFSET, 0);\n\telse\n\t\tqla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\n\tspin_unlock_irq(&ha->hardware_lock);\n\tha->interrupts_on = 1;\n}\n\nvoid\nqla82xx_disable_intrs(struct qla_hw_data *ha)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tif (ha->interrupts_on)\n\t\tqla82xx_mbx_intr_disable(vha);\n\n\tspin_lock_irq(&ha->hardware_lock);\n\tif (IS_QLA8044(ha))\n\t\tqla8044_wr_reg(ha, LEG_INTR_MASK_OFFSET, 1);\n\telse\n\t\tqla82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);\n\tspin_unlock_irq(&ha->hardware_lock);\n\tha->interrupts_on = 0;\n}\n\nvoid qla82xx_init_flags(struct qla_hw_data *ha)\n{\n\tstruct qla82xx_legacy_intr_set *nx_legacy_intr;\n\n\t \n\trwlock_init(&ha->hw_lock);\n\tha->qdr_sn_window = -1;\n\tha->ddr_mn_window = -1;\n\tha->curr_window = 255;\n\tha->portnum = PCI_FUNC(ha->pdev->devfn);\n\tnx_legacy_intr = &legacy_intr[ha->portnum];\n\tha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;\n\tha->nx_legacy_intr.tgt_status_reg = nx_legacy_intr->tgt_status_reg;\n\tha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;\n\tha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;\n}\n\nstatic inline void\nqla82xx_set_idc_version(scsi_qla_host_t *vha)\n{\n\tint idc_ver;\n\tuint32_t drv_active;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\tif (drv_active == (QLA82XX_DRV_ACTIVE << (ha->portnum * 4))) {\n\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_IDC_VERSION,\n\t\t    QLA82XX_IDC_VERSION);\n\t\tql_log(ql_log_info, vha, 0xb082,\n\t\t    \"IDC version updated to %d\\n\", QLA82XX_IDC_VERSION);\n\t} else {\n\t\tidc_ver = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_IDC_VERSION);\n\t\tif (idc_ver != QLA82XX_IDC_VERSION)\n\t\t\tql_log(ql_log_info, vha, 0xb083,\n\t\t\t    \"qla2xxx driver IDC version %d is not compatible \"\n\t\t\t    \"with IDC version %d of the other drivers\\n\",\n\t\t\t    QLA82XX_IDC_VERSION, idc_ver);\n\t}\n}\n\ninline void\nqla82xx_set_drv_active(scsi_qla_host_t *vha)\n{\n\tuint32_t drv_active;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\n\t \n\tif (drv_active == 0xffffffff) {\n\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE,\n\t\t\tQLA82XX_DRV_NOT_ACTIVE);\n\t\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\t}\n\tdrv_active |= (QLA82XX_DRV_ACTIVE << (ha->portnum * 4));\n\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);\n}\n\ninline void\nqla82xx_clear_drv_active(struct qla_hw_data *ha)\n{\n\tuint32_t drv_active;\n\n\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\tdrv_active &= ~(QLA82XX_DRV_ACTIVE << (ha->portnum * 4));\n\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_ACTIVE, drv_active);\n}\n\nstatic inline int\nqla82xx_need_reset(struct qla_hw_data *ha)\n{\n\tuint32_t drv_state;\n\tint rval;\n\n\tif (ha->flags.nic_core_reset_owner)\n\t\treturn 1;\n\telse {\n\t\tdrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\t\trval = drv_state & (QLA82XX_DRVST_RST_RDY << (ha->portnum * 4));\n\t\treturn rval;\n\t}\n}\n\nstatic inline void\nqla82xx_set_rst_ready(struct qla_hw_data *ha)\n{\n\tuint32_t drv_state;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tdrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\n\t \n\tif (drv_state == 0xffffffff) {\n\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, QLA82XX_DRVST_NOT_RDY);\n\t\tdrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\t}\n\tdrv_state |= (QLA82XX_DRVST_RST_RDY << (ha->portnum * 4));\n\tql_dbg(ql_dbg_init, vha, 0x00bb,\n\t    \"drv_state = 0x%08x.\\n\", drv_state);\n\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);\n}\n\nstatic inline void\nqla82xx_clear_rst_ready(struct qla_hw_data *ha)\n{\n\tuint32_t drv_state;\n\n\tdrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\tdrv_state &= ~(QLA82XX_DRVST_RST_RDY << (ha->portnum * 4));\n\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, drv_state);\n}\n\nstatic inline void\nqla82xx_set_qsnt_ready(struct qla_hw_data *ha)\n{\n\tuint32_t qsnt_state;\n\n\tqsnt_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\tqsnt_state |= (QLA82XX_DRVST_QSNT_RDY << (ha->portnum * 4));\n\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);\n}\n\nvoid\nqla82xx_clear_qsnt_ready(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t qsnt_state;\n\n\tqsnt_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\tqsnt_state &= ~(QLA82XX_DRVST_QSNT_RDY << (ha->portnum * 4));\n\tqla82xx_wr_32(ha, QLA82XX_CRB_DRV_STATE, qsnt_state);\n}\n\nstatic int\nqla82xx_load_fw(scsi_qla_host_t *vha)\n{\n\tint rst;\n\tstruct fw_blob *blob;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (qla82xx_pinit_from_rom(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, vha, 0x009f,\n\t\t    \"Error during CRB initialization.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\tudelay(500);\n\n\t \n\trst = qla82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET);\n\trst &= ~((1 << 28) | (1 << 24));\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, rst);\n\n\t \n\tif (ql2xfwloadbin == 2)\n\t\tgoto try_blob_fw;\n\n\tql_log(ql_log_info, vha, 0x00a0,\n\t    \"Attempting to load firmware from flash.\\n\");\n\n\tif (qla82xx_fw_load_from_flash(ha) == QLA_SUCCESS) {\n\t\tql_log(ql_log_info, vha, 0x00a1,\n\t\t    \"Firmware loaded successfully from flash.\\n\");\n\t\treturn QLA_SUCCESS;\n\t} else {\n\t\tql_log(ql_log_warn, vha, 0x0108,\n\t\t    \"Firmware load from flash failed.\\n\");\n\t}\n\ntry_blob_fw:\n\tql_log(ql_log_info, vha, 0x00a2,\n\t    \"Attempting to load firmware from blob.\\n\");\n\n\t \n\tblob = ha->hablob = qla2x00_request_firmware(vha);\n\tif (!blob) {\n\t\tql_log(ql_log_fatal, vha, 0x00a3,\n\t\t    \"Firmware image not present.\\n\");\n\t\tgoto fw_load_failed;\n\t}\n\n\t \n\tif (qla82xx_validate_firmware_blob(vha,\n\t\tQLA82XX_FLASH_ROMIMAGE)) {\n\t\t \n\t\tif (qla82xx_validate_firmware_blob(vha,\n\t\t\tQLA82XX_UNIFIED_ROMIMAGE)) {\n\t\t\tql_log(ql_log_fatal, vha, 0x00a4,\n\t\t\t    \"No valid firmware image found.\\n\");\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\n\tif (qla82xx_fw_load_from_blob(ha) == QLA_SUCCESS) {\n\t\tql_log(ql_log_info, vha, 0x00a5,\n\t\t    \"Firmware loaded successfully from binary blob.\\n\");\n\t\treturn QLA_SUCCESS;\n\t}\n\n\tql_log(ql_log_fatal, vha, 0x00a6,\n\t       \"Firmware load failed for binary blob.\\n\");\n\tblob->fw = NULL;\n\tblob = NULL;\n\nfw_load_failed:\n\treturn QLA_FUNCTION_FAILED;\n}\n\nint\nqla82xx_start_firmware(scsi_qla_host_t *vha)\n{\n\tuint16_t      lnk;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tqla82xx_wr_32(ha, CRB_DMA_SHIFT, QLA82XX_DMA_SHIFT_VALUE);\n\n\t \n\tqla82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);\n\tqla82xx_wr_32(ha, CRB_RCVPEG_STATE, 0);\n\n\t \n\tqla82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS1, 0);\n\tqla82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS2, 0);\n\n\tif (qla82xx_load_fw(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, vha, 0x00a7,\n\t\t    \"Error trying to start fw.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\t \n\tif (qla82xx_check_cmdpeg_state(ha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, vha, 0x00aa,\n\t\t    \"Error during card handshake.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\t \n\tpcie_capability_read_word(ha->pdev, PCI_EXP_LNKSTA, &lnk);\n\tha->link_width = (lnk >> 4) & 0x3f;\n\n\t \n\treturn qla82xx_check_rcvpeg_state(ha);\n}\n\nstatic __le32 *\nqla82xx_read_flash_data(scsi_qla_host_t *vha, __le32 *dwptr, uint32_t faddr,\n\tuint32_t length)\n{\n\tuint32_t i;\n\tuint32_t val;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tfor (i = 0; i < length/4; i++, faddr += 4) {\n\t\tif (qla82xx_rom_fast_read(ha, faddr, &val)) {\n\t\t\tql_log(ql_log_warn, vha, 0x0106,\n\t\t\t    \"Do ROM fast read failed.\\n\");\n\t\t\tgoto done_read;\n\t\t}\n\t\tdwptr[i] = cpu_to_le32(val);\n\t}\ndone_read:\n\treturn dwptr;\n}\n\nstatic int\nqla82xx_unprotect_flash(struct qla_hw_data *ha)\n{\n\tint ret;\n\tuint32_t val;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tret = ql82xx_rom_lock_d(ha);\n\tif (ret < 0) {\n\t\tql_log(ql_log_warn, vha, 0xb014,\n\t\t    \"ROM Lock failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qla82xx_read_status_reg(ha, &val);\n\tif (ret < 0)\n\t\tgoto done_unprotect;\n\n\tval &= ~(BLOCK_PROTECT_BITS << 2);\n\tret = qla82xx_write_status_reg(ha, val);\n\tif (ret < 0) {\n\t\tval |= (BLOCK_PROTECT_BITS << 2);\n\t\tqla82xx_write_status_reg(ha, val);\n\t}\n\n\tif (qla82xx_write_disable_flash(ha) != 0)\n\t\tql_log(ql_log_warn, vha, 0xb015,\n\t\t    \"Write disable failed.\\n\");\n\ndone_unprotect:\n\tqla82xx_rom_unlock(ha);\n\treturn ret;\n}\n\nstatic int\nqla82xx_protect_flash(struct qla_hw_data *ha)\n{\n\tint ret;\n\tuint32_t val;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tret = ql82xx_rom_lock_d(ha);\n\tif (ret < 0) {\n\t\tql_log(ql_log_warn, vha, 0xb016,\n\t\t    \"ROM Lock failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qla82xx_read_status_reg(ha, &val);\n\tif (ret < 0)\n\t\tgoto done_protect;\n\n\tval |= (BLOCK_PROTECT_BITS << 2);\n\t \n\tret = qla82xx_write_status_reg(ha, val);\n\tif (ret < 0)\n\t\tql_log(ql_log_warn, vha, 0xb017,\n\t\t    \"Write status register failed.\\n\");\n\n\tif (qla82xx_write_disable_flash(ha) != 0)\n\t\tql_log(ql_log_warn, vha, 0xb018,\n\t\t    \"Write disable failed.\\n\");\ndone_protect:\n\tqla82xx_rom_unlock(ha);\n\treturn ret;\n}\n\nstatic int\nqla82xx_erase_sector(struct qla_hw_data *ha, int addr)\n{\n\tint ret = 0;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tret = ql82xx_rom_lock_d(ha);\n\tif (ret < 0) {\n\t\tql_log(ql_log_warn, vha, 0xb019,\n\t\t    \"ROM Lock failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tqla82xx_flash_set_write_enable(ha);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, addr);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);\n\tqla82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, M25P_INSTR_SE);\n\n\tif (qla82xx_wait_rom_done(ha)) {\n\t\tql_log(ql_log_warn, vha, 0xb01a,\n\t\t    \"Error waiting for rom done.\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tret = qla82xx_flash_wait_write_finish(ha);\ndone:\n\tqla82xx_rom_unlock(ha);\n\treturn ret;\n}\n\n \nvoid *\nqla82xx_read_optrom_data(struct scsi_qla_host *vha, void *buf,\n\tuint32_t offset, uint32_t length)\n{\n\tscsi_block_requests(vha->host);\n\tqla82xx_read_flash_data(vha, buf, offset, length);\n\tscsi_unblock_requests(vha->host);\n\treturn buf;\n}\n\nstatic int\nqla82xx_write_flash_data(struct scsi_qla_host *vha, __le32 *dwptr,\n\tuint32_t faddr, uint32_t dwords)\n{\n\tint ret;\n\tuint32_t liter;\n\tuint32_t rest_addr;\n\tdma_addr_t optrom_dma;\n\tvoid *optrom = NULL;\n\tint page_mode = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tret = -1;\n\n\t \n\tif (page_mode && !(faddr & 0xfff) &&\n\t    dwords > OPTROM_BURST_DWORDS) {\n\t\toptrom = dma_alloc_coherent(&ha->pdev->dev, OPTROM_BURST_SIZE,\n\t\t    &optrom_dma, GFP_KERNEL);\n\t\tif (!optrom) {\n\t\t\tql_log(ql_log_warn, vha, 0xb01b,\n\t\t\t    \"Unable to allocate memory \"\n\t\t\t    \"for optrom burst write (%x KB).\\n\",\n\t\t\t    OPTROM_BURST_SIZE / 1024);\n\t\t}\n\t}\n\n\trest_addr = ha->fdt_block_size - 1;\n\n\tret = qla82xx_unprotect_flash(ha);\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0xb01c,\n\t\t    \"Unable to unprotect flash for update.\\n\");\n\t\tgoto write_done;\n\t}\n\n\tfor (liter = 0; liter < dwords; liter++, faddr += 4, dwptr++) {\n\t\t \n\t\tif ((faddr & rest_addr) == 0) {\n\n\t\t\tret = qla82xx_erase_sector(ha, faddr);\n\t\t\tif (ret) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xb01d,\n\t\t\t\t    \"Unable to erase sector: address=%x.\\n\",\n\t\t\t\t    faddr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (optrom && (liter + OPTROM_BURST_DWORDS) <= dwords) {\n\t\t\t \n\t\t\tmemcpy(optrom, dwptr, OPTROM_BURST_SIZE);\n\n\t\t\tret = qla2x00_load_ram(vha, optrom_dma,\n\t\t\t    (ha->flash_data_off | faddr),\n\t\t\t    OPTROM_BURST_DWORDS);\n\t\t\tif (ret != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xb01e,\n\t\t\t\t    \"Unable to burst-write optrom segment \"\n\t\t\t\t    \"(%x/%x/%llx).\\n\", ret,\n\t\t\t\t    (ha->flash_data_off | faddr),\n\t\t\t\t    (unsigned long long)optrom_dma);\n\t\t\t\tql_log(ql_log_warn, vha, 0xb01f,\n\t\t\t\t    \"Reverting to slow-write.\\n\");\n\n\t\t\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t\t    OPTROM_BURST_SIZE, optrom, optrom_dma);\n\t\t\t\toptrom = NULL;\n\t\t\t} else {\n\t\t\t\tliter += OPTROM_BURST_DWORDS - 1;\n\t\t\t\tfaddr += OPTROM_BURST_DWORDS - 1;\n\t\t\t\tdwptr += OPTROM_BURST_DWORDS - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tret = qla82xx_write_flash_dword(ha, faddr,\n\t\t\t\t\t\tle32_to_cpu(*dwptr));\n\t\tif (ret) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb020,\n\t\t\t    \"Unable to program flash address=%x data=%x.\\n\",\n\t\t\t    faddr, *dwptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = qla82xx_protect_flash(ha);\n\tif (ret)\n\t\tql_log(ql_log_warn, vha, 0xb021,\n\t\t    \"Unable to protect flash after update.\\n\");\nwrite_done:\n\tif (optrom)\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t    OPTROM_BURST_SIZE, optrom, optrom_dma);\n\treturn ret;\n}\n\nint\nqla82xx_write_optrom_data(struct scsi_qla_host *vha, void *buf,\n\tuint32_t offset, uint32_t length)\n{\n\tint rval;\n\n\t \n\tscsi_block_requests(vha->host);\n\trval = qla82xx_write_flash_data(vha, buf, offset, length >> 2);\n\tscsi_unblock_requests(vha->host);\n\n\t \n\tif (rval)\n\t\trval = QLA_FUNCTION_FAILED;\n\telse\n\t\trval = QLA_SUCCESS;\n\treturn rval;\n}\n\nvoid\nqla82xx_start_iocbs(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\tuint32_t dbval;\n\n\t \n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else\n\t\treq->ring_ptr++;\n\n\tdbval = 0x04 | (ha->portnum << 5);\n\n\tdbval = dbval | (req->id << 8) | (req->ring_index << 16);\n\tif (ql2xdbwr)\n\t\tqla82xx_wr_32(ha, (unsigned long)ha->nxdb_wr_ptr, dbval);\n\telse {\n\t\twrt_reg_dword(ha->nxdb_wr_ptr, dbval);\n\t\twmb();\n\t\twhile (rd_reg_dword(ha->nxdb_rd_ptr) != dbval) {\n\t\t\twrt_reg_dword(ha->nxdb_wr_ptr, dbval);\n\t\t\twmb();\n\t\t}\n\t}\n}\n\nstatic void\nqla82xx_rom_lock_recovery(struct qla_hw_data *ha)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\tuint32_t lock_owner = 0;\n\n\tif (qla82xx_rom_lock(ha)) {\n\t\tlock_owner = qla82xx_rd_32(ha, QLA82XX_ROM_LOCK_ID);\n\t\t \n\t\tql_log(ql_log_info, vha, 0xb022,\n\t\t    \"Resetting rom_lock, Lock Owner %u.\\n\", lock_owner);\n\t}\n\t \n\tqla82xx_rom_unlock(ha);\n}\n\n \nstatic int\nqla82xx_device_bootstrap(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tint i;\n\tuint32_t old_count, count;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint need_reset = 0;\n\n\tneed_reset = qla82xx_need_reset(ha);\n\n\tif (need_reset) {\n\t\t \n\t\tif (ha->flags.isp82xx_fw_hung)\n\t\t\tqla82xx_rom_lock_recovery(ha);\n\t} else  {\n\t\told_count = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tmsleep(200);\n\t\t\tcount = qla82xx_rd_32(ha, QLA82XX_PEG_ALIVE_COUNTER);\n\t\t\tif (count != old_count) {\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\tgoto dev_ready;\n\t\t\t}\n\t\t}\n\t\tqla82xx_rom_lock_recovery(ha);\n\t}\n\n\t \n\tql_log(ql_log_info, vha, 0x009e,\n\t    \"HW State: INITIALIZING.\\n\");\n\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_INITIALIZING);\n\n\tqla82xx_idc_unlock(ha);\n\trval = qla82xx_start_firmware(vha);\n\tqla82xx_idc_lock(ha);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, vha, 0x00ad,\n\t\t    \"HW State: FAILED.\\n\");\n\t\tqla82xx_clear_drv_active(ha);\n\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_FAILED);\n\t\treturn rval;\n\t}\n\ndev_ready:\n\tql_log(ql_log_info, vha, 0x00ae,\n\t    \"HW State: READY.\\n\");\n\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_READY);\n\n\treturn QLA_SUCCESS;\n}\n\n \n\nstatic void\nqla82xx_need_qsnt_handler(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t dev_state, drv_state, drv_active;\n\tunsigned long reset_timeout;\n\n\tif (vha->flags.online) {\n\t\t \n\t\tqla2x00_quiesce_io(vha);\n\t}\n\n\t \n\tqla82xx_set_qsnt_ready(ha);\n\n\t \n\treset_timeout = jiffies + (30 * HZ);\n\n\tdrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\t \n\tdrv_active = drv_active << 0x01;\n\n\twhile (drv_state != drv_active) {\n\n\t\tif (time_after_eq(jiffies, reset_timeout)) {\n\t\t\t \n\t\t\tql_log(ql_log_info, vha, 0xb023,\n\t\t\t    \"%s : QUIESCENT TIMEOUT DRV_ACTIVE:%d \"\n\t\t\t    \"DRV_STATE:%d.\\n\", QLA2XXX_DRIVER_NAME,\n\t\t\t    drv_active, drv_state);\n\t\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\n\t\t\t    QLA8XXX_DEV_READY);\n\t\t\tql_log(ql_log_info, vha, 0xb025,\n\t\t\t    \"HW State: DEV_READY.\\n\");\n\t\t\tqla82xx_idc_unlock(ha);\n\t\t\tqla2x00_perform_loop_resync(vha);\n\t\t\tqla82xx_idc_lock(ha);\n\n\t\t\tqla82xx_clear_qsnt_ready(vha);\n\t\t\treturn;\n\t\t}\n\n\t\tqla82xx_idc_unlock(ha);\n\t\tmsleep(1000);\n\t\tqla82xx_idc_lock(ha);\n\n\t\tdrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\t\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\t\tdrv_active = drv_active << 0x01;\n\t}\n\tdev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\t \n\tif (dev_state == QLA8XXX_DEV_NEED_QUIESCENT) {\n\t\tql_log(ql_log_info, vha, 0xb026,\n\t\t    \"HW State: DEV_QUIESCENT.\\n\");\n\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_QUIESCENT);\n\t}\n}\n\n \nuint32_t\nqla82xx_wait_for_state_change(scsi_qla_host_t *vha, uint32_t curr_state)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t dev_state;\n\n\tdo {\n\t\tmsleep(1000);\n\t\tqla82xx_idc_lock(ha);\n\t\tdev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\t\tqla82xx_idc_unlock(ha);\n\t} while (dev_state == curr_state);\n\n\treturn dev_state;\n}\n\nvoid\nqla8xxx_dev_failed_handler(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tql_log(ql_log_fatal, vha, 0x00b8,\n\t    \"Disabling the board.\\n\");\n\n\tif (IS_QLA82XX(ha)) {\n\t\tqla82xx_clear_drv_active(ha);\n\t\tqla82xx_idc_unlock(ha);\n\t} else if (IS_QLA8044(ha)) {\n\t\tqla8044_clear_drv_active(ha);\n\t\tqla8044_idc_unlock(ha);\n\t}\n\n\t \n\tvha->device_flags |= DFLG_DEV_FAILED;\n\tqla2x00_abort_all_cmds(vha, DID_NO_CONNECT << 16);\n\tqla2x00_mark_all_devices_lost(vha);\n\tvha->flags.online = 0;\n\tvha->flags.init_done = 0;\n}\n\n \nstatic void\nqla82xx_need_reset_handler(scsi_qla_host_t *vha)\n{\n\tuint32_t dev_state, drv_state, drv_active;\n\tuint32_t active_mask = 0;\n\tunsigned long reset_timeout;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req = ha->req_q_map[0];\n\n\tif (vha->flags.online) {\n\t\tqla82xx_idc_unlock(ha);\n\t\tqla2x00_abort_isp_cleanup(vha);\n\t\tha->isp_ops->get_flash_version(vha, req->ring);\n\t\tha->isp_ops->nvram_config(vha);\n\t\tqla82xx_idc_lock(ha);\n\t}\n\n\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\tif (!ha->flags.nic_core_reset_owner) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb028,\n\t\t    \"reset_acknowledged by 0x%x\\n\", ha->portnum);\n\t\tqla82xx_set_rst_ready(ha);\n\t} else {\n\t\tactive_mask = ~(QLA82XX_DRV_ACTIVE << (ha->portnum * 4));\n\t\tdrv_active &= active_mask;\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb029,\n\t\t    \"active_mask: 0x%08x\\n\", active_mask);\n\t}\n\n\t \n\treset_timeout = jiffies + (ha->fcoe_reset_timeout * HZ);\n\n\tdrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\tdev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb02a,\n\t    \"drv_state: 0x%08x, drv_active: 0x%08x, \"\n\t    \"dev_state: 0x%08x, active_mask: 0x%08x\\n\",\n\t    drv_state, drv_active, dev_state, active_mask);\n\n\twhile (drv_state != drv_active &&\n\t    dev_state != QLA8XXX_DEV_INITIALIZING) {\n\t\tif (time_after_eq(jiffies, reset_timeout)) {\n\t\t\tql_log(ql_log_warn, vha, 0x00b5,\n\t\t\t    \"Reset timeout.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tqla82xx_idc_unlock(ha);\n\t\tmsleep(1000);\n\t\tqla82xx_idc_lock(ha);\n\t\tdrv_state = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\t\tdrv_active = qla82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\t\tif (ha->flags.nic_core_reset_owner)\n\t\t\tdrv_active &= active_mask;\n\t\tdev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\t}\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb02b,\n\t    \"drv_state: 0x%08x, drv_active: 0x%08x, \"\n\t    \"dev_state: 0x%08x, active_mask: 0x%08x\\n\",\n\t    drv_state, drv_active, dev_state, active_mask);\n\n\tql_log(ql_log_info, vha, 0x00b6,\n\t    \"Device state is 0x%x = %s.\\n\",\n\t    dev_state, qdev_state(dev_state));\n\n\t \n\tif (dev_state != QLA8XXX_DEV_INITIALIZING &&\n\t    dev_state != QLA8XXX_DEV_COLD) {\n\t\tql_log(ql_log_info, vha, 0x00b7,\n\t\t    \"HW State: COLD/RE-INIT.\\n\");\n\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_COLD);\n\t\tqla82xx_set_rst_ready(ha);\n\t\tif (ql2xmdenable) {\n\t\t\tif (qla82xx_md_collect(vha))\n\t\t\t\tql_log(ql_log_warn, vha, 0xb02c,\n\t\t\t\t    \"Minidump not collected.\\n\");\n\t\t} else\n\t\t\tql_log(ql_log_warn, vha, 0xb04f,\n\t\t\t    \"Minidump disabled.\\n\");\n\t}\n}\n\nint\nqla82xx_check_md_needed(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint16_t fw_major_version, fw_minor_version, fw_subminor_version;\n\tint rval = QLA_SUCCESS;\n\n\tfw_major_version = ha->fw_major_version;\n\tfw_minor_version = ha->fw_minor_version;\n\tfw_subminor_version = ha->fw_subminor_version;\n\n\trval = qla2x00_get_fw_version(vha);\n\tif (rval != QLA_SUCCESS)\n\t\treturn rval;\n\n\tif (ql2xmdenable) {\n\t\tif (!ha->fw_dumped) {\n\t\t\tif ((fw_major_version != ha->fw_major_version ||\n\t\t\t    fw_minor_version != ha->fw_minor_version ||\n\t\t\t    fw_subminor_version != ha->fw_subminor_version) ||\n\t\t\t    (ha->prev_minidump_failed)) {\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb02d,\n\t\t\t\t    \"Firmware version differs Previous version: %d:%d:%d - New version: %d:%d:%d, prev_minidump_failed: %d.\\n\",\n\t\t\t\t    fw_major_version, fw_minor_version,\n\t\t\t\t    fw_subminor_version,\n\t\t\t\t    ha->fw_major_version,\n\t\t\t\t    ha->fw_minor_version,\n\t\t\t\t    ha->fw_subminor_version,\n\t\t\t\t    ha->prev_minidump_failed);\n\t\t\t\t \n\t\t\t\tqla82xx_md_free(vha);\n\t\t\t\t \n\t\t\t\tqla82xx_md_prep(vha);\n\t\t\t}\n\t\t} else\n\t\t\tql_log(ql_log_info, vha, 0xb02e,\n\t\t\t    \"Firmware dump available to retrieve\\n\");\n\t}\n\treturn rval;\n}\n\n\nstatic int\nqla82xx_check_fw_alive(scsi_qla_host_t *vha)\n{\n\tuint32_t fw_heartbeat_counter;\n\tint status = 0;\n\n\tfw_heartbeat_counter = qla82xx_rd_32(vha->hw,\n\t\tQLA82XX_PEG_ALIVE_COUNTER);\n\t \n\tif (fw_heartbeat_counter == 0xffffffff) {\n\t\tql_dbg(ql_dbg_timer, vha, 0x6003,\n\t\t    \"FW heartbeat counter is 0xffffffff, \"\n\t\t    \"returning status=%d.\\n\", status);\n\t\treturn status;\n\t}\n\tif (vha->fw_heartbeat_counter == fw_heartbeat_counter) {\n\t\tvha->seconds_since_last_heartbeat++;\n\t\t \n\t\tif (vha->seconds_since_last_heartbeat == 2) {\n\t\t\tvha->seconds_since_last_heartbeat = 0;\n\t\t\tstatus = 1;\n\t\t}\n\t} else\n\t\tvha->seconds_since_last_heartbeat = 0;\n\tvha->fw_heartbeat_counter = fw_heartbeat_counter;\n\tif (status)\n\t\tql_dbg(ql_dbg_timer, vha, 0x6004,\n\t\t    \"Returning status=%d.\\n\", status);\n\treturn status;\n}\n\n \nint\nqla82xx_device_state_handler(scsi_qla_host_t *vha)\n{\n\tuint32_t dev_state;\n\tuint32_t old_dev_state;\n\tint rval = QLA_SUCCESS;\n\tunsigned long dev_init_timeout;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint loopcount = 0;\n\n\tqla82xx_idc_lock(ha);\n\tif (!vha->flags.init_done) {\n\t\tqla82xx_set_drv_active(vha);\n\t\tqla82xx_set_idc_version(vha);\n\t}\n\n\tdev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\told_dev_state = dev_state;\n\tql_log(ql_log_info, vha, 0x009b,\n\t    \"Device state is 0x%x = %s.\\n\",\n\t    dev_state, qdev_state(dev_state));\n\n\t \n\tdev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout * HZ);\n\n\twhile (1) {\n\n\t\tif (time_after_eq(jiffies, dev_init_timeout)) {\n\t\t\tql_log(ql_log_fatal, vha, 0x009c,\n\t\t\t    \"Device init failed.\\n\");\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tdev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\t\tif (old_dev_state != dev_state) {\n\t\t\tloopcount = 0;\n\t\t\told_dev_state = dev_state;\n\t\t}\n\t\tif (loopcount < 5) {\n\t\t\tql_log(ql_log_info, vha, 0x009d,\n\t\t\t    \"Device state is 0x%x = %s.\\n\",\n\t\t\t    dev_state, qdev_state(dev_state));\n\t\t}\n\n\t\tswitch (dev_state) {\n\t\tcase QLA8XXX_DEV_READY:\n\t\t\tha->flags.nic_core_reset_owner = 0;\n\t\t\tgoto rel_lock;\n\t\tcase QLA8XXX_DEV_COLD:\n\t\t\trval = qla82xx_device_bootstrap(vha);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_INITIALIZING:\n\t\t\tqla82xx_idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tqla82xx_idc_lock(ha);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_NEED_RESET:\n\t\t\tif (!ql2xdontresethba)\n\t\t\t\tqla82xx_need_reset_handler(vha);\n\t\t\telse {\n\t\t\t\tqla82xx_idc_unlock(ha);\n\t\t\t\tmsleep(1000);\n\t\t\t\tqla82xx_idc_lock(ha);\n\t\t\t}\n\t\t\tdev_init_timeout = jiffies +\n\t\t\t    (ha->fcoe_dev_init_timeout * HZ);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_NEED_QUIESCENT:\n\t\t\tqla82xx_need_qsnt_handler(vha);\n\t\t\t \n\t\t\tdev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout\n\t\t\t\t\t\t\t * HZ);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_QUIESCENT:\n\t\t\t \n\t\t\tif (ha->flags.quiesce_owner)\n\t\t\t\tgoto rel_lock;\n\n\t\t\tqla82xx_idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tqla82xx_idc_lock(ha);\n\n\t\t\t \n\t\t\tdev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout\n\t\t\t\t\t\t\t * HZ);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_FAILED:\n\t\t\tqla8xxx_dev_failed_handler(vha);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tgoto exit;\n\t\tdefault:\n\t\t\tqla82xx_idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tqla82xx_idc_lock(ha);\n\t\t}\n\t\tloopcount++;\n\t}\nrel_lock:\n\tqla82xx_idc_unlock(ha);\nexit:\n\treturn rval;\n}\n\nstatic int qla82xx_check_temp(scsi_qla_host_t *vha)\n{\n\tuint32_t temp, temp_state, temp_val;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\ttemp = qla82xx_rd_32(ha, CRB_TEMP_STATE);\n\ttemp_state = qla82xx_get_temp_state(temp);\n\ttemp_val = qla82xx_get_temp_val(temp);\n\n\tif (temp_state == QLA82XX_TEMP_PANIC) {\n\t\tql_log(ql_log_warn, vha, 0x600e,\n\t\t    \"Device temperature %d degrees C exceeds \"\n\t\t    \" maximum allowed. Hardware has been shut down.\\n\",\n\t\t    temp_val);\n\t\treturn 1;\n\t} else if (temp_state == QLA82XX_TEMP_WARN) {\n\t\tql_log(ql_log_warn, vha, 0x600f,\n\t\t    \"Device temperature %d degrees C exceeds \"\n\t\t    \"operating range. Immediate action needed.\\n\",\n\t\t    temp_val);\n\t}\n\treturn 0;\n}\n\nint qla82xx_read_temperature(scsi_qla_host_t *vha)\n{\n\tuint32_t temp;\n\n\ttemp = qla82xx_rd_32(vha->hw, CRB_TEMP_STATE);\n\treturn qla82xx_get_temp_val(temp);\n}\n\nvoid qla82xx_clear_pending_mbx(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (ha->flags.mbox_busy) {\n\t\tha->flags.mbox_int = 1;\n\t\tha->flags.mbox_busy = 0;\n\t\tql_log(ql_log_warn, vha, 0x6010,\n\t\t    \"Doing premature completion of mbx command.\\n\");\n\t\tif (test_and_clear_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags))\n\t\t\tcomplete(&ha->mbx_intr_comp);\n\t}\n}\n\nvoid qla82xx_watchdog(scsi_qla_host_t *vha)\n{\n\tuint32_t dev_state, halt_status;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (!ha->flags.nic_core_reset_hdlr_active) {\n\t\tdev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\t\tif (qla82xx_check_temp(vha)) {\n\t\t\tset_bit(ISP_UNRECOVERABLE, &vha->dpc_flags);\n\t\t\tha->flags.isp82xx_fw_hung = 1;\n\t\t\tqla82xx_clear_pending_mbx(vha);\n\t\t} else if (dev_state == QLA8XXX_DEV_NEED_RESET &&\n\t\t    !test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags)) {\n\t\t\tql_log(ql_log_warn, vha, 0x6001,\n\t\t\t    \"Adapter reset needed.\\n\");\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t} else if (dev_state == QLA8XXX_DEV_NEED_QUIESCENT &&\n\t\t\t!test_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags)) {\n\t\t\tql_log(ql_log_warn, vha, 0x6002,\n\t\t\t    \"Quiescent needed.\\n\");\n\t\t\tset_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags);\n\t\t} else if (dev_state == QLA8XXX_DEV_FAILED &&\n\t\t\t!test_bit(ISP_UNRECOVERABLE, &vha->dpc_flags) &&\n\t\t\tvha->flags.online == 1) {\n\t\t\tql_log(ql_log_warn, vha, 0xb055,\n\t\t\t    \"Adapter state is failed. Offlining.\\n\");\n\t\t\tset_bit(ISP_UNRECOVERABLE, &vha->dpc_flags);\n\t\t\tha->flags.isp82xx_fw_hung = 1;\n\t\t\tqla82xx_clear_pending_mbx(vha);\n\t\t} else {\n\t\t\tif (qla82xx_check_fw_alive(vha)) {\n\t\t\t\tql_dbg(ql_dbg_timer, vha, 0x6011,\n\t\t\t\t    \"disabling pause transmit on port 0 & 1.\\n\");\n\t\t\t\tqla82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\n\t\t\t\t    CRB_NIU_XG_PAUSE_CTL_P0|CRB_NIU_XG_PAUSE_CTL_P1);\n\t\t\t\thalt_status = qla82xx_rd_32(ha,\n\t\t\t\t    QLA82XX_PEG_HALT_STATUS1);\n\t\t\t\tql_log(ql_log_info, vha, 0x6005,\n\t\t\t\t    \"dumping hw/fw registers:.\\n \"\n\t\t\t\t    \" PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,.\\n \"\n\t\t\t\t    \" PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,.\\n \"\n\t\t\t\t    \" PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,.\\n \"\n\t\t\t\t    \" PEG_NET_4_PC: 0x%x.\\n\", halt_status,\n\t\t\t\t    qla82xx_rd_32(ha, QLA82XX_PEG_HALT_STATUS2),\n\t\t\t\t    qla82xx_rd_32(ha,\n\t\t\t\t\t    QLA82XX_CRB_PEG_NET_0 + 0x3c),\n\t\t\t\t    qla82xx_rd_32(ha,\n\t\t\t\t\t    QLA82XX_CRB_PEG_NET_1 + 0x3c),\n\t\t\t\t    qla82xx_rd_32(ha,\n\t\t\t\t\t    QLA82XX_CRB_PEG_NET_2 + 0x3c),\n\t\t\t\t    qla82xx_rd_32(ha,\n\t\t\t\t\t    QLA82XX_CRB_PEG_NET_3 + 0x3c),\n\t\t\t\t    qla82xx_rd_32(ha,\n\t\t\t\t\t    QLA82XX_CRB_PEG_NET_4 + 0x3c));\n\t\t\t\tif (((halt_status & 0x1fffff00) >> 8) == 0x67)\n\t\t\t\t\tql_log(ql_log_warn, vha, 0xb052,\n\t\t\t\t\t    \"Firmware aborted with \"\n\t\t\t\t\t    \"error code 0x00006700. Device is \"\n\t\t\t\t\t    \"being reset.\\n\");\n\t\t\t\tif (halt_status & HALT_STATUS_UNRECOVERABLE) {\n\t\t\t\t\tset_bit(ISP_UNRECOVERABLE,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t} else {\n\t\t\t\t\tql_log(ql_log_info, vha, 0x6006,\n\t\t\t\t\t    \"Detect abort  needed.\\n\");\n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t}\n\t\t\t\tha->flags.isp82xx_fw_hung = 1;\n\t\t\t\tql_log(ql_log_warn, vha, 0x6007, \"Firmware hung.\\n\");\n\t\t\t\tqla82xx_clear_pending_mbx(vha);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint qla82xx_load_risc(scsi_qla_host_t *vha, uint32_t *srisc_addr)\n{\n\tint rval = -1;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLA82XX(ha))\n\t\trval = qla82xx_device_state_handler(vha);\n\telse if (IS_QLA8044(ha)) {\n\t\tqla8044_idc_lock(ha);\n\t\t \n\t\tqla83xx_reset_ownership(vha);\n\t\tqla8044_idc_unlock(ha);\n\t\trval = qla8044_device_state_handler(vha);\n\t}\n\treturn rval;\n}\n\nvoid\nqla82xx_set_reset_owner(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t dev_state = 0;\n\n\tif (IS_QLA82XX(ha))\n\t\tdev_state = qla82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\telse if (IS_QLA8044(ha))\n\t\tdev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\n\n\tif (dev_state == QLA8XXX_DEV_READY) {\n\t\tql_log(ql_log_info, vha, 0xb02f,\n\t\t    \"HW State: NEED RESET\\n\");\n\t\tif (IS_QLA82XX(ha)) {\n\t\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\n\t\t\t    QLA8XXX_DEV_NEED_RESET);\n\t\t\tha->flags.nic_core_reset_owner = 1;\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb030,\n\t\t\t    \"reset_owner is 0x%x\\n\", ha->portnum);\n\t\t} else if (IS_QLA8044(ha))\n\t\t\tqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\n\t\t\t    QLA8XXX_DEV_NEED_RESET);\n\t} else\n\t\tql_log(ql_log_info, vha, 0xb031,\n\t\t    \"Device state is 0x%x = %s.\\n\",\n\t\t    dev_state, qdev_state(dev_state));\n}\n\n \nint\nqla82xx_abort_isp(scsi_qla_host_t *vha)\n{\n\tint rval = -1;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (vha->device_flags & DFLG_DEV_FAILED) {\n\t\tql_log(ql_log_warn, vha, 0x8024,\n\t\t    \"Device in failed state, exiting.\\n\");\n\t\treturn QLA_SUCCESS;\n\t}\n\tha->flags.nic_core_reset_hdlr_active = 1;\n\n\tqla82xx_idc_lock(ha);\n\tqla82xx_set_reset_owner(vha);\n\tqla82xx_idc_unlock(ha);\n\n\tif (IS_QLA82XX(ha))\n\t\trval = qla82xx_device_state_handler(vha);\n\telse if (IS_QLA8044(ha)) {\n\t\tqla8044_idc_lock(ha);\n\t\t \n\t\tqla83xx_reset_ownership(vha);\n\t\tqla8044_idc_unlock(ha);\n\t\trval = qla8044_device_state_handler(vha);\n\t}\n\n\tqla82xx_idc_lock(ha);\n\tqla82xx_clear_rst_ready(ha);\n\tqla82xx_idc_unlock(ha);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tha->flags.isp82xx_fw_hung = 0;\n\t\tha->flags.nic_core_reset_hdlr_active = 0;\n\t\tqla82xx_restart_isp(vha);\n\t}\n\n\tif (rval) {\n\t\tvha->flags.online = 1;\n\t\tif (test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\n\t\t\tif (ha->isp_abort_cnt == 0) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x8027,\n\t\t\t\t    \"ISP error recover failed - board \"\n\t\t\t\t    \"disabled.\\n\");\n\t\t\t\t \n\t\t\t\tha->isp_ops->reset_adapter(vha);\n\t\t\t\tvha->flags.online = 0;\n\t\t\t\tclear_bit(ISP_ABORT_RETRY,\n\t\t\t\t    &vha->dpc_flags);\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t} else {  \n\t\t\t\tha->isp_abort_cnt--;\n\t\t\t\tql_log(ql_log_warn, vha, 0x8036,\n\t\t\t\t    \"ISP abort - retry remaining %d.\\n\",\n\t\t\t\t    ha->isp_abort_cnt);\n\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t}\n\t\t} else {\n\t\t\tha->isp_abort_cnt = MAX_RETRIES_OF_ISP_ABORT;\n\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8029,\n\t\t\t    \"ISP error recovery - retrying (%d) more times.\\n\",\n\t\t\t    ha->isp_abort_cnt);\n\t\t\tset_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t}\n\t}\n\treturn rval;\n}\n\n \nint qla82xx_fcoe_ctx_reset(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\n\tif (vha->flags.online) {\n\t\t \n\t\tqla2x00_abort_isp_cleanup(vha);\n\t}\n\n\t \n\tqla2x00_try_to_stop_firmware(vha);\n\n\t \n\trval = qla82xx_restart_isp(vha);\n\n\treturn rval;\n}\n\n \nint qla2x00_wait_for_fcoe_ctx_reset(scsi_qla_host_t *vha)\n{\n\tint status = QLA_FUNCTION_FAILED;\n\tunsigned long wait_reset;\n\n\twait_reset = jiffies + (MAX_LOOP_TIMEOUT * HZ);\n\twhile ((test_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags) ||\n\t    test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags))\n\t    && time_before(jiffies, wait_reset)) {\n\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(HZ);\n\n\t\tif (!test_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags) &&\n\t\t    !test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)) {\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t}\n\tql_dbg(ql_dbg_p3p, vha, 0xb027,\n\t       \"%s: status=%d.\\n\", __func__, status);\n\n\treturn status;\n}\n\nvoid\nqla82xx_chip_reset_cleanup(scsi_qla_host_t *vha)\n{\n\tint i, fw_state = 0;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (!ha->flags.isp82xx_fw_hung) {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tmsleep(1000);\n\t\t\tif (IS_QLA82XX(ha))\n\t\t\t\tfw_state = qla82xx_check_fw_alive(vha);\n\t\t\telse if (IS_QLA8044(ha))\n\t\t\t\tfw_state = qla8044_check_fw_alive(vha);\n\t\t\tif (fw_state) {\n\t\t\t\tha->flags.isp82xx_fw_hung = 1;\n\t\t\t\tqla82xx_clear_pending_mbx(vha);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tql_dbg(ql_dbg_init, vha, 0x00b0,\n\t    \"Entered %s fw_hung=%d.\\n\",\n\t    __func__, ha->flags.isp82xx_fw_hung);\n\n\t \n\tif (!ha->flags.isp82xx_fw_hung) {\n\t\tint cnt, que;\n\t\tsrb_t *sp;\n\t\tstruct req_que *req;\n\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tfor (que = 0; que < ha->max_req_queues; que++) {\n\t\t\treq = ha->req_q_map[que];\n\t\t\tif (!req)\n\t\t\t\tcontinue;\n\t\t\tfor (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {\n\t\t\t\tsp = req->outstanding_cmds[cnt];\n\t\t\t\tif (sp) {\n\t\t\t\t\tif ((!sp->u.scmd.crc_ctx ||\n\t\t\t\t\t    (sp->flags &\n\t\t\t\t\t\tSRB_FCP_CMND_DMA_VALID)) &&\n\t\t\t\t\t\t!ha->flags.isp82xx_fw_hung) {\n\t\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t    &ha->hardware_lock, flags);\n\t\t\t\t\t\tif (ha->isp_ops->abort_command(sp)) {\n\t\t\t\t\t\t\tql_log(ql_log_info, vha,\n\t\t\t\t\t\t\t    0x00b1,\n\t\t\t\t\t\t\t    \"mbx abort failed.\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tql_log(ql_log_info, vha,\n\t\t\t\t\t\t\t    0x00b2,\n\t\t\t\t\t\t\t    \"mbx abort success.\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\t \n\t\tif (qla2x00_eh_wait_for_pending_commands(vha, 0, 0,\n\t\t    WAIT_HOST) == QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_init, vha, 0x00b3,\n\t\t\t    \"Done wait for \"\n\t\t\t    \"pending commands.\\n\");\n\t\t} else {\n\t\t\tWARN_ON_ONCE(true);\n\t\t}\n\t}\n}\n\n \nstatic int\nqla82xx_minidump_process_control(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct qla82xx_md_entry_crb *crb_entry;\n\tuint32_t read_value, opcode, poll_time;\n\tuint32_t addr, index, crb_addr;\n\tunsigned long wtime;\n\tstruct qla82xx_md_template_hdr *tmplt_hdr;\n\tuint32_t rval = QLA_SUCCESS;\n\tint i;\n\n\ttmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;\n\tcrb_entry = (struct qla82xx_md_entry_crb *)entry_hdr;\n\tcrb_addr = crb_entry->addr;\n\n\tfor (i = 0; i < crb_entry->op_count; i++) {\n\t\topcode = crb_entry->crb_ctrl.opcode;\n\t\tif (opcode & QLA82XX_DBG_OPCODE_WR) {\n\t\t\tqla82xx_md_rw_32(ha, crb_addr,\n\t\t\t    crb_entry->value_1, 1);\n\t\t\topcode &= ~QLA82XX_DBG_OPCODE_WR;\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_RW) {\n\t\t\tread_value = qla82xx_md_rw_32(ha, crb_addr, 0, 0);\n\t\t\tqla82xx_md_rw_32(ha, crb_addr, read_value, 1);\n\t\t\topcode &= ~QLA82XX_DBG_OPCODE_RW;\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_AND) {\n\t\t\tread_value = qla82xx_md_rw_32(ha, crb_addr, 0, 0);\n\t\t\tread_value &= crb_entry->value_2;\n\t\t\topcode &= ~QLA82XX_DBG_OPCODE_AND;\n\t\t\tif (opcode & QLA82XX_DBG_OPCODE_OR) {\n\t\t\t\tread_value |= crb_entry->value_3;\n\t\t\t\topcode &= ~QLA82XX_DBG_OPCODE_OR;\n\t\t\t}\n\t\t\tqla82xx_md_rw_32(ha, crb_addr, read_value, 1);\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_OR) {\n\t\t\tread_value = qla82xx_md_rw_32(ha, crb_addr, 0, 0);\n\t\t\tread_value |= crb_entry->value_3;\n\t\t\tqla82xx_md_rw_32(ha, crb_addr, read_value, 1);\n\t\t\topcode &= ~QLA82XX_DBG_OPCODE_OR;\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_POLL) {\n\t\t\tpoll_time = crb_entry->crb_strd.poll_timeout;\n\t\t\twtime = jiffies + poll_time;\n\t\t\tread_value = qla82xx_md_rw_32(ha, crb_addr, 0, 0);\n\n\t\t\tdo {\n\t\t\t\tif ((read_value & crb_entry->value_2)\n\t\t\t\t    == crb_entry->value_1)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (time_after_eq(jiffies, wtime)) {\n\t\t\t\t\t \n\t\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tread_value = qla82xx_md_rw_32(ha,\n\t\t\t\t\t    crb_addr, 0, 0);\n\t\t\t} while (1);\n\t\t\topcode &= ~QLA82XX_DBG_OPCODE_POLL;\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_RDSTATE) {\n\t\t\tif (crb_entry->crb_strd.state_index_a) {\n\t\t\t\tindex = crb_entry->crb_strd.state_index_a;\n\t\t\t\taddr = tmplt_hdr->saved_state_array[index];\n\t\t\t} else\n\t\t\t\taddr = crb_addr;\n\n\t\t\tread_value = qla82xx_md_rw_32(ha, addr, 0, 0);\n\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\ttmplt_hdr->saved_state_array[index] = read_value;\n\t\t\topcode &= ~QLA82XX_DBG_OPCODE_RDSTATE;\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_WRSTATE) {\n\t\t\tif (crb_entry->crb_strd.state_index_a) {\n\t\t\t\tindex = crb_entry->crb_strd.state_index_a;\n\t\t\t\taddr = tmplt_hdr->saved_state_array[index];\n\t\t\t} else\n\t\t\t\taddr = crb_addr;\n\n\t\t\tif (crb_entry->crb_ctrl.state_index_v) {\n\t\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\t\tread_value =\n\t\t\t\t    tmplt_hdr->saved_state_array[index];\n\t\t\t} else\n\t\t\t\tread_value = crb_entry->value_1;\n\n\t\t\tqla82xx_md_rw_32(ha, addr, read_value, 1);\n\t\t\topcode &= ~QLA82XX_DBG_OPCODE_WRSTATE;\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_MDSTATE) {\n\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\tread_value = tmplt_hdr->saved_state_array[index];\n\t\t\tread_value <<= crb_entry->crb_ctrl.shl;\n\t\t\tread_value >>= crb_entry->crb_ctrl.shr;\n\t\t\tif (crb_entry->value_2)\n\t\t\t\tread_value &= crb_entry->value_2;\n\t\t\tread_value |= crb_entry->value_3;\n\t\t\tread_value += crb_entry->value_1;\n\t\t\ttmplt_hdr->saved_state_array[index] = read_value;\n\t\t\topcode &= ~QLA82XX_DBG_OPCODE_MDSTATE;\n\t\t}\n\t\tcrb_addr += crb_entry->crb_strd.addr_stride;\n\t}\n\treturn rval;\n}\n\nstatic void\nqla82xx_minidump_process_rdocm(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t r_addr, r_stride, loop_cnt, i, r_value;\n\tstruct qla82xx_md_entry_rdocm *ocm_hdr;\n\t__le32 *data_ptr = *d_ptr;\n\n\tocm_hdr = (struct qla82xx_md_entry_rdocm *)entry_hdr;\n\tr_addr = ocm_hdr->read_addr;\n\tr_stride = ocm_hdr->read_addr_stride;\n\tloop_cnt = ocm_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tr_value = rd_reg_dword(r_addr + ha->nx_pcibase);\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\tr_addr += r_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic void\nqla82xx_minidump_process_rdmux(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t r_addr, s_stride, s_addr, s_value, loop_cnt, i, r_value;\n\tstruct qla82xx_md_entry_mux *mux_hdr;\n\t__le32 *data_ptr = *d_ptr;\n\n\tmux_hdr = (struct qla82xx_md_entry_mux *)entry_hdr;\n\tr_addr = mux_hdr->read_addr;\n\ts_addr = mux_hdr->select_addr;\n\ts_stride = mux_hdr->select_value_stride;\n\ts_value = mux_hdr->select_value;\n\tloop_cnt = mux_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tqla82xx_md_rw_32(ha, s_addr, s_value, 1);\n\t\tr_value = qla82xx_md_rw_32(ha, r_addr, 0, 0);\n\t\t*data_ptr++ = cpu_to_le32(s_value);\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\ts_value += s_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic void\nqla82xx_minidump_process_rdcrb(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t r_addr, r_stride, loop_cnt, i, r_value;\n\tstruct qla82xx_md_entry_crb *crb_hdr;\n\t__le32 *data_ptr = *d_ptr;\n\n\tcrb_hdr = (struct qla82xx_md_entry_crb *)entry_hdr;\n\tr_addr = crb_hdr->addr;\n\tr_stride = crb_hdr->crb_strd.addr_stride;\n\tloop_cnt = crb_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tr_value = qla82xx_md_rw_32(ha, r_addr, 0, 0);\n\t\t*data_ptr++ = cpu_to_le32(r_addr);\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\tr_addr += r_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic int\nqla82xx_minidump_process_l2tag(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t addr, r_addr, c_addr, t_r_addr;\n\tuint32_t i, k, loop_count, t_value, r_cnt, r_value;\n\tunsigned long p_wait, w_time, p_mask;\n\tuint32_t c_value_w, c_value_r;\n\tstruct qla82xx_md_entry_cache *cache_hdr;\n\tint rval = QLA_FUNCTION_FAILED;\n\t__le32 *data_ptr = *d_ptr;\n\n\tcache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;\n\tloop_count = cache_hdr->op_count;\n\tr_addr = cache_hdr->read_addr;\n\tc_addr = cache_hdr->control_addr;\n\tc_value_w = cache_hdr->cache_ctrl.write_value;\n\n\tt_r_addr = cache_hdr->tag_reg_addr;\n\tt_value = cache_hdr->addr_ctrl.init_tag_value;\n\tr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\n\tp_wait = cache_hdr->cache_ctrl.poll_wait;\n\tp_mask = cache_hdr->cache_ctrl.poll_mask;\n\n\tfor (i = 0; i < loop_count; i++) {\n\t\tqla82xx_md_rw_32(ha, t_r_addr, t_value, 1);\n\t\tif (c_value_w)\n\t\t\tqla82xx_md_rw_32(ha, c_addr, c_value_w, 1);\n\n\t\tif (p_mask) {\n\t\t\tw_time = jiffies + p_wait;\n\t\t\tdo {\n\t\t\t\tc_value_r = qla82xx_md_rw_32(ha, c_addr, 0, 0);\n\t\t\t\tif ((c_value_r & p_mask) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\telse if (time_after_eq(jiffies, w_time)) {\n\t\t\t\t\t \n\t\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb032,\n\t\t\t\t\t    \"c_value_r: 0x%x, poll_mask: 0x%lx, \"\n\t\t\t\t\t    \"w_time: 0x%lx\\n\",\n\t\t\t\t\t    c_value_r, p_mask, w_time);\n\t\t\t\t\treturn rval;\n\t\t\t\t}\n\t\t\t} while (1);\n\t\t}\n\n\t\taddr = r_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tr_value = qla82xx_md_rw_32(ha, addr, 0, 0);\n\t\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\t\taddr += cache_hdr->read_ctrl.read_addr_stride;\n\t\t}\n\t\tt_value += cache_hdr->addr_ctrl.tag_value_stride;\n\t}\n\t*d_ptr = data_ptr;\n\treturn QLA_SUCCESS;\n}\n\nstatic void\nqla82xx_minidump_process_l1cache(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t addr, r_addr, c_addr, t_r_addr;\n\tuint32_t i, k, loop_count, t_value, r_cnt, r_value;\n\tuint32_t c_value_w;\n\tstruct qla82xx_md_entry_cache *cache_hdr;\n\t__le32 *data_ptr = *d_ptr;\n\n\tcache_hdr = (struct qla82xx_md_entry_cache *)entry_hdr;\n\tloop_count = cache_hdr->op_count;\n\tr_addr = cache_hdr->read_addr;\n\tc_addr = cache_hdr->control_addr;\n\tc_value_w = cache_hdr->cache_ctrl.write_value;\n\n\tt_r_addr = cache_hdr->tag_reg_addr;\n\tt_value = cache_hdr->addr_ctrl.init_tag_value;\n\tr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\n\n\tfor (i = 0; i < loop_count; i++) {\n\t\tqla82xx_md_rw_32(ha, t_r_addr, t_value, 1);\n\t\tqla82xx_md_rw_32(ha, c_addr, c_value_w, 1);\n\t\taddr = r_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tr_value = qla82xx_md_rw_32(ha, addr, 0, 0);\n\t\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\t\taddr += cache_hdr->read_ctrl.read_addr_stride;\n\t\t}\n\t\tt_value += cache_hdr->addr_ctrl.tag_value_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic void\nqla82xx_minidump_process_queue(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t s_addr, r_addr;\n\tuint32_t r_stride, r_value, r_cnt, qid = 0;\n\tuint32_t i, k, loop_cnt;\n\tstruct qla82xx_md_entry_queue *q_hdr;\n\t__le32 *data_ptr = *d_ptr;\n\n\tq_hdr = (struct qla82xx_md_entry_queue *)entry_hdr;\n\ts_addr = q_hdr->select_addr;\n\tr_cnt = q_hdr->rd_strd.read_addr_cnt;\n\tr_stride = q_hdr->rd_strd.read_addr_stride;\n\tloop_cnt = q_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tqla82xx_md_rw_32(ha, s_addr, qid, 1);\n\t\tr_addr = q_hdr->read_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tr_value = qla82xx_md_rw_32(ha, r_addr, 0, 0);\n\t\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\t\tr_addr += r_stride;\n\t\t}\n\t\tqid += q_hdr->q_strd.queue_id_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic void\nqla82xx_minidump_process_rdrom(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t r_addr, r_value;\n\tuint32_t i, loop_cnt;\n\tstruct qla82xx_md_entry_rdrom *rom_hdr;\n\t__le32 *data_ptr = *d_ptr;\n\n\trom_hdr = (struct qla82xx_md_entry_rdrom *)entry_hdr;\n\tr_addr = rom_hdr->read_addr;\n\tloop_cnt = rom_hdr->read_data_size/sizeof(uint32_t);\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tqla82xx_md_rw_32(ha, MD_DIRECT_ROM_WINDOW,\n\t\t    (r_addr & 0xFFFF0000), 1);\n\t\tr_value = qla82xx_md_rw_32(ha,\n\t\t    MD_DIRECT_ROM_READ_BASE +\n\t\t    (r_addr & 0x0000FFFF), 0, 0);\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\tr_addr += sizeof(uint32_t);\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic int\nqla82xx_minidump_process_rdmem(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, __le32 **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t r_addr, r_value, r_data;\n\tuint32_t i, j, loop_cnt;\n\tstruct qla82xx_md_entry_rdmem *m_hdr;\n\tunsigned long flags;\n\tint rval = QLA_FUNCTION_FAILED;\n\t__le32 *data_ptr = *d_ptr;\n\n\tm_hdr = (struct qla82xx_md_entry_rdmem *)entry_hdr;\n\tr_addr = m_hdr->read_addr;\n\tloop_cnt = m_hdr->read_data_size/16;\n\n\tif (r_addr & 0xf) {\n\t\tql_log(ql_log_warn, vha, 0xb033,\n\t\t    \"Read addr 0x%x not 16 bytes aligned\\n\", r_addr);\n\t\treturn rval;\n\t}\n\n\tif (m_hdr->read_data_size % 16) {\n\t\tql_log(ql_log_warn, vha, 0xb034,\n\t\t    \"Read data[0x%x] not multiple of 16 bytes\\n\",\n\t\t    m_hdr->read_data_size);\n\t\treturn rval;\n\t}\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb035,\n\t    \"[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\\n\",\n\t    __func__, r_addr, m_hdr->read_data_size, loop_cnt);\n\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tqla82xx_md_rw_32(ha, MD_MIU_TEST_AGT_ADDR_LO, r_addr, 1);\n\t\tr_value = 0;\n\t\tqla82xx_md_rw_32(ha, MD_MIU_TEST_AGT_ADDR_HI, r_value, 1);\n\t\tr_value = MIU_TA_CTL_ENABLE;\n\t\tqla82xx_md_rw_32(ha, MD_MIU_TEST_AGT_CTRL, r_value, 1);\n\t\tr_value = MIU_TA_CTL_START | MIU_TA_CTL_ENABLE;\n\t\tqla82xx_md_rw_32(ha, MD_MIU_TEST_AGT_CTRL, r_value, 1);\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\tr_value = qla82xx_md_rw_32(ha,\n\t\t\t    MD_MIU_TEST_AGT_CTRL, 0, 0);\n\t\t\tif ((r_value & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tprintk_ratelimited(KERN_ERR\n\t\t\t    \"failed to read through agent\\n\");\n\t\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\t\treturn rval;\n\t\t}\n\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tr_data = qla82xx_md_rw_32(ha,\n\t\t\t    MD_MIU_TEST_AGT_RDDATA[j], 0, 0);\n\t\t\t*data_ptr++ = cpu_to_le32(r_data);\n\t\t}\n\t\tr_addr += 16;\n\t}\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t*d_ptr = data_ptr;\n\treturn QLA_SUCCESS;\n}\n\nint\nqla82xx_validate_template_chksum(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint64_t chksum = 0;\n\tuint32_t *d_ptr = (uint32_t *)ha->md_tmplt_hdr;\n\tint count = ha->md_template_size/sizeof(uint32_t);\n\n\twhile (count-- > 0)\n\t\tchksum += *d_ptr++;\n\twhile (chksum >> 32)\n\t\tchksum = (chksum & 0xFFFFFFFF) + (chksum >> 32);\n\treturn ~chksum;\n}\n\nstatic void\nqla82xx_mark_entry_skipped(scsi_qla_host_t *vha,\n\tqla82xx_md_entry_hdr_t *entry_hdr, int index)\n{\n\tentry_hdr->d_ctrl.driver_flags |= QLA82XX_DBG_SKIPPED_FLAG;\n\tql_dbg(ql_dbg_p3p, vha, 0xb036,\n\t    \"Skipping entry[%d]: \"\n\t    \"ETYPE[0x%x]-ELEVEL[0x%x]\\n\",\n\t    index, entry_hdr->entry_type,\n\t    entry_hdr->d_ctrl.entry_capture_mask);\n}\n\nint\nqla82xx_md_collect(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint no_entry_hdr = 0;\n\tqla82xx_md_entry_hdr_t *entry_hdr;\n\tstruct qla82xx_md_template_hdr *tmplt_hdr;\n\t__le32 *data_ptr;\n\tuint32_t total_data_size = 0, f_capture_mask, data_collected = 0;\n\tint i = 0, rval = QLA_FUNCTION_FAILED;\n\n\ttmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;\n\tdata_ptr = ha->md_dump;\n\n\tif (ha->fw_dumped) {\n\t\tql_log(ql_log_warn, vha, 0xb037,\n\t\t    \"Firmware has been previously dumped (%p) \"\n\t\t    \"-- ignoring request.\\n\", ha->fw_dump);\n\t\tgoto md_failed;\n\t}\n\n\tha->fw_dumped = false;\n\n\tif (!ha->md_tmplt_hdr || !ha->md_dump) {\n\t\tql_log(ql_log_warn, vha, 0xb038,\n\t\t    \"Memory not allocated for minidump capture\\n\");\n\t\tgoto md_failed;\n\t}\n\n\tif (ha->flags.isp82xx_no_md_cap) {\n\t\tql_log(ql_log_warn, vha, 0xb054,\n\t\t    \"Forced reset from application, \"\n\t\t    \"ignore minidump capture\\n\");\n\t\tha->flags.isp82xx_no_md_cap = 0;\n\t\tgoto md_failed;\n\t}\n\n\tif (qla82xx_validate_template_chksum(vha)) {\n\t\tql_log(ql_log_info, vha, 0xb039,\n\t\t    \"Template checksum validation error\\n\");\n\t\tgoto md_failed;\n\t}\n\n\tno_entry_hdr = tmplt_hdr->num_of_entries;\n\tql_dbg(ql_dbg_p3p, vha, 0xb03a,\n\t    \"No of entry headers in Template: 0x%x\\n\", no_entry_hdr);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb03b,\n\t    \"Capture Mask obtained: 0x%x\\n\", tmplt_hdr->capture_debug_level);\n\n\tf_capture_mask = tmplt_hdr->capture_debug_level & 0xFF;\n\n\t \n\tif ((f_capture_mask & 0x3) != 0x3) {\n\t\tql_log(ql_log_warn, vha, 0xb03c,\n\t\t    \"Minimum required capture mask[0x%x] level not set\\n\",\n\t\t    f_capture_mask);\n\t\tgoto md_failed;\n\t}\n\ttmplt_hdr->driver_capture_mask = ql2xmdcapmask;\n\n\ttmplt_hdr->driver_info[0] = vha->host_no;\n\ttmplt_hdr->driver_info[1] = (QLA_DRIVER_MAJOR_VER << 24) |\n\t    (QLA_DRIVER_MINOR_VER << 16) | (QLA_DRIVER_PATCH_VER << 8) |\n\t    QLA_DRIVER_BETA_VER;\n\n\ttotal_data_size = ha->md_dump_size;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb03d,\n\t    \"Total minidump data_size 0x%x to be captured\\n\", total_data_size);\n\n\t \n\tif (tmplt_hdr->entry_type != QLA82XX_TLHDR) {\n\t\tql_log(ql_log_warn, vha, 0xb04e,\n\t\t    \"Bad template header entry type: 0x%x obtained\\n\",\n\t\t    tmplt_hdr->entry_type);\n\t\tgoto md_failed;\n\t}\n\n\tentry_hdr = (qla82xx_md_entry_hdr_t *)\n\t    (((uint8_t *)ha->md_tmplt_hdr) + tmplt_hdr->first_entry_offset);\n\n\t \n\tfor (i = 0; i < no_entry_hdr; i++) {\n\n\t\tif (data_collected > total_data_size) {\n\t\t\tql_log(ql_log_warn, vha, 0xb03e,\n\t\t\t    \"More MiniDump data collected: [0x%x]\\n\",\n\t\t\t    data_collected);\n\t\t\tgoto md_failed;\n\t\t}\n\n\t\tif (!(entry_hdr->d_ctrl.entry_capture_mask &\n\t\t    ql2xmdcapmask)) {\n\t\t\tentry_hdr->d_ctrl.driver_flags |=\n\t\t\t    QLA82XX_DBG_SKIPPED_FLAG;\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb03f,\n\t\t\t    \"Skipping entry[%d]: \"\n\t\t\t    \"ETYPE[0x%x]-ELEVEL[0x%x]\\n\",\n\t\t\t    i, entry_hdr->entry_type,\n\t\t\t    entry_hdr->d_ctrl.entry_capture_mask);\n\t\t\tgoto skip_nxt_entry;\n\t\t}\n\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb040,\n\t\t    \"[%s]: data ptr[%d]: %p, entry_hdr: %p\\n\"\n\t\t    \"entry_type: 0x%x, capture_mask: 0x%x\\n\",\n\t\t    __func__, i, data_ptr, entry_hdr,\n\t\t    entry_hdr->entry_type,\n\t\t    entry_hdr->d_ctrl.entry_capture_mask);\n\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb041,\n\t\t    \"Data collected: [0x%x], Dump size left:[0x%x]\\n\",\n\t\t    data_collected, (ha->md_dump_size - data_collected));\n\n\t\t \n\t\tswitch (entry_hdr->entry_type) {\n\t\tcase QLA82XX_RDEND:\n\t\t\tqla82xx_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA82XX_CNTRL:\n\t\t\trval = qla82xx_minidump_process_control(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla82xx_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\t\tgoto md_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA82XX_RDCRB:\n\t\t\tqla82xx_minidump_process_rdcrb(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_RDMEM:\n\t\t\trval = qla82xx_minidump_process_rdmem(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla82xx_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\t\tgoto md_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA82XX_BOARD:\n\t\tcase QLA82XX_RDROM:\n\t\t\tqla82xx_minidump_process_rdrom(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_L2DTG:\n\t\tcase QLA82XX_L2ITG:\n\t\tcase QLA82XX_L2DAT:\n\t\tcase QLA82XX_L2INS:\n\t\t\trval = qla82xx_minidump_process_l2tag(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla82xx_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\t\tgoto md_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA82XX_L1DAT:\n\t\tcase QLA82XX_L1INS:\n\t\t\tqla82xx_minidump_process_l1cache(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_RDOCM:\n\t\t\tqla82xx_minidump_process_rdocm(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_RDMUX:\n\t\t\tqla82xx_minidump_process_rdmux(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_QUEUE:\n\t\t\tqla82xx_minidump_process_queue(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_RDNOP:\n\t\tdefault:\n\t\t\tqla82xx_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\t}\n\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb042,\n\t\t    \"[%s]: data ptr[%d]: %p\\n\", __func__, i, data_ptr);\n\n\t\tdata_collected = (uint8_t *)data_ptr -\n\t\t    (uint8_t *)ha->md_dump;\nskip_nxt_entry:\n\t\tentry_hdr = (qla82xx_md_entry_hdr_t *)\n\t\t    (((uint8_t *)entry_hdr) + entry_hdr->entry_size);\n\t}\n\n\tif (data_collected != total_data_size) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb043,\n\t\t    \"MiniDump data mismatch: Data collected: [0x%x],\"\n\t\t    \"total_data_size:[0x%x]\\n\",\n\t\t    data_collected, total_data_size);\n\t\tgoto md_failed;\n\t}\n\n\tql_log(ql_log_info, vha, 0xb044,\n\t    \"Firmware dump saved to temp buffer (%ld/%p %ld/%p).\\n\",\n\t    vha->host_no, ha->md_tmplt_hdr, vha->host_no, ha->md_dump);\n\tha->fw_dumped = true;\n\tqla2x00_post_uevent_work(vha, QLA_UEVENT_CODE_FW_DUMP);\n\nmd_failed:\n\treturn rval;\n}\n\nint\nqla82xx_md_alloc(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint i, k;\n\tstruct qla82xx_md_template_hdr *tmplt_hdr;\n\n\ttmplt_hdr = (struct qla82xx_md_template_hdr *)ha->md_tmplt_hdr;\n\n\tif (ql2xmdcapmask < 0x3 || ql2xmdcapmask > 0x7F) {\n\t\tql2xmdcapmask = tmplt_hdr->capture_debug_level & 0xFF;\n\t\tql_log(ql_log_info, vha, 0xb045,\n\t\t    \"Forcing driver capture mask to firmware default capture mask: 0x%x.\\n\",\n\t\t    ql2xmdcapmask);\n\t}\n\n\tfor (i = 0x2, k = 1; (i & QLA82XX_DEFAULT_CAP_MASK); i <<= 1, k++) {\n\t\tif (i & ql2xmdcapmask)\n\t\t\tha->md_dump_size += tmplt_hdr->capture_size_array[k];\n\t}\n\n\tif (ha->md_dump) {\n\t\tql_log(ql_log_warn, vha, 0xb046,\n\t\t    \"Firmware dump previously allocated.\\n\");\n\t\treturn 1;\n\t}\n\n\tha->md_dump = vmalloc(ha->md_dump_size);\n\tif (ha->md_dump == NULL) {\n\t\tql_log(ql_log_warn, vha, 0xb047,\n\t\t    \"Unable to allocate memory for Minidump size \"\n\t\t    \"(0x%x).\\n\", ha->md_dump_size);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid\nqla82xx_md_free(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (ha->md_tmplt_hdr) {\n\t\tql_log(ql_log_info, vha, 0xb048,\n\t\t    \"Free MiniDump template: %p, size (%d KB)\\n\",\n\t\t    ha->md_tmplt_hdr, ha->md_template_size / 1024);\n\t\tdma_free_coherent(&ha->pdev->dev, ha->md_template_size,\n\t\t    ha->md_tmplt_hdr, ha->md_tmplt_hdr_dma);\n\t\tha->md_tmplt_hdr = NULL;\n\t}\n\n\t \n\tif (ha->md_dump) {\n\t\tql_log(ql_log_info, vha, 0xb049,\n\t\t    \"Free MiniDump memory: %p, size (%d KB)\\n\",\n\t\t    ha->md_dump, ha->md_dump_size / 1024);\n\t\tvfree(ha->md_dump);\n\t\tha->md_dump_size = 0;\n\t\tha->md_dump = NULL;\n\t}\n}\n\nvoid\nqla82xx_md_prep(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval;\n\n\t \n\trval = qla82xx_md_get_template_size(vha);\n\tif (rval == QLA_SUCCESS) {\n\t\tql_log(ql_log_info, vha, 0xb04a,\n\t\t    \"MiniDump Template size obtained (%d KB)\\n\",\n\t\t    ha->md_template_size / 1024);\n\n\t\t \n\t\tif (IS_QLA8044(ha))\n\t\t\trval = qla8044_md_get_template(vha);\n\t\telse\n\t\t\trval = qla82xx_md_get_template(vha);\n\n\t\tif (rval == QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb04b,\n\t\t\t    \"MiniDump Template obtained\\n\");\n\n\t\t\t \n\t\t\trval = qla82xx_md_alloc(vha);\n\t\t\tif (rval == QLA_SUCCESS)\n\t\t\t\tql_log(ql_log_info, vha, 0xb04c,\n\t\t\t\t    \"MiniDump memory allocated (%d KB)\\n\",\n\t\t\t\t    ha->md_dump_size / 1024);\n\t\t\telse {\n\t\t\t\tql_log(ql_log_info, vha, 0xb04d,\n\t\t\t\t    \"Free MiniDump template: %p, size: (%d KB)\\n\",\n\t\t\t\t    ha->md_tmplt_hdr,\n\t\t\t\t    ha->md_template_size / 1024);\n\t\t\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t\t    ha->md_template_size,\n\t\t\t\t    ha->md_tmplt_hdr, ha->md_tmplt_hdr_dma);\n\t\t\t\tha->md_tmplt_hdr = NULL;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nint\nqla82xx_beacon_on(struct scsi_qla_host *vha)\n{\n\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqla82xx_idc_lock(ha);\n\trval = qla82xx_mbx_beacon_ctl(vha, 1);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0xb050,\n\t\t    \"mbx set led config failed in %s\\n\", __func__);\n\t\tgoto exit;\n\t}\n\tha->beacon_blink_led = 1;\nexit:\n\tqla82xx_idc_unlock(ha);\n\treturn rval;\n}\n\nint\nqla82xx_beacon_off(struct scsi_qla_host *vha)\n{\n\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqla82xx_idc_lock(ha);\n\trval = qla82xx_mbx_beacon_ctl(vha, 0);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0xb051,\n\t\t    \"mbx set led config failed in %s\\n\", __func__);\n\t\tgoto exit;\n\t}\n\tha->beacon_blink_led = 0;\nexit:\n\tqla82xx_idc_unlock(ha);\n\treturn rval;\n}\n\nvoid\nqla82xx_fw_dump(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->allow_cna_fw_dump)\n\t\treturn;\n\n\tscsi_block_requests(vha->host);\n\tha->flags.isp82xx_no_md_cap = 1;\n\tqla82xx_idc_lock(ha);\n\tqla82xx_set_reset_owner(vha);\n\tqla82xx_idc_unlock(ha);\n\tqla2x00_wait_for_chip_reset(vha);\n\tscsi_unblock_requests(vha->host);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}