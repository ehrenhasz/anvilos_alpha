{
  "module_name": "qla_nx2.c",
  "hash_id": "a5daa4e00598dfccc61d3497630bcf4210f4d1811c3797737390a5066e36bef4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_nx2.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n\n#include \"qla_def.h\"\n#include \"qla_gbl.h\"\n\n#define TIMEOUT_100_MS 100\n\nstatic const uint32_t qla8044_reg_tbl[] = {\n\tQLA8044_PEG_HALT_STATUS1,\n\tQLA8044_PEG_HALT_STATUS2,\n\tQLA8044_PEG_ALIVE_COUNTER,\n\tQLA8044_CRB_DRV_ACTIVE,\n\tQLA8044_CRB_DEV_STATE,\n\tQLA8044_CRB_DRV_STATE,\n\tQLA8044_CRB_DRV_SCRATCH,\n\tQLA8044_CRB_DEV_PART_INFO1,\n\tQLA8044_CRB_IDC_VER_MAJOR,\n\tQLA8044_FW_VER_MAJOR,\n\tQLA8044_FW_VER_MINOR,\n\tQLA8044_FW_VER_SUB,\n\tQLA8044_CMDPEG_STATE,\n\tQLA8044_ASIC_TEMP,\n};\n\n \nuint32_t\nqla8044_rd_reg(struct qla_hw_data *ha, ulong addr)\n{\n\treturn readl((void __iomem *) (ha->nx_pcibase + addr));\n}\n\nvoid\nqla8044_wr_reg(struct qla_hw_data *ha, ulong addr, uint32_t val)\n{\n\twritel(val, (void __iomem *)((ha)->nx_pcibase + addr));\n}\n\nint\nqla8044_rd_direct(struct scsi_qla_host *vha,\n\tconst uint32_t crb_reg)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (crb_reg < CRB_REG_INDEX_MAX)\n\t\treturn qla8044_rd_reg(ha, qla8044_reg_tbl[crb_reg]);\n\telse\n\t\treturn QLA_FUNCTION_FAILED;\n}\n\nvoid\nqla8044_wr_direct(struct scsi_qla_host *vha,\n\tconst uint32_t crb_reg,\n\tconst uint32_t value)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (crb_reg < CRB_REG_INDEX_MAX)\n\t\tqla8044_wr_reg(ha, qla8044_reg_tbl[crb_reg], value);\n}\n\nstatic int\nqla8044_set_win_base(scsi_qla_host_t *vha, uint32_t addr)\n{\n\tuint32_t val;\n\tint ret_val = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqla8044_wr_reg(ha, QLA8044_CRB_WIN_FUNC(ha->portnum), addr);\n\tval = qla8044_rd_reg(ha, QLA8044_CRB_WIN_FUNC(ha->portnum));\n\n\tif (val != addr) {\n\t\tql_log(ql_log_warn, vha, 0xb087,\n\t\t    \"%s: Failed to set register window : \"\n\t\t    \"addr written 0x%x, read 0x%x!\\n\",\n\t\t    __func__, addr, val);\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t}\n\treturn ret_val;\n}\n\nstatic int\nqla8044_rd_reg_indirect(scsi_qla_host_t *vha, uint32_t addr, uint32_t *data)\n{\n\tint ret_val = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tret_val = qla8044_set_win_base(vha, addr);\n\tif (!ret_val)\n\t\t*data = qla8044_rd_reg(ha, QLA8044_WILDCARD);\n\telse\n\t\tql_log(ql_log_warn, vha, 0xb088,\n\t\t    \"%s: failed read of addr 0x%x!\\n\", __func__, addr);\n\treturn ret_val;\n}\n\nstatic int\nqla8044_wr_reg_indirect(scsi_qla_host_t *vha, uint32_t addr, uint32_t data)\n{\n\tint ret_val = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tret_val = qla8044_set_win_base(vha, addr);\n\tif (!ret_val)\n\t\tqla8044_wr_reg(ha, QLA8044_WILDCARD, data);\n\telse\n\t\tql_log(ql_log_warn, vha, 0xb089,\n\t\t    \"%s: failed wrt to addr 0x%x, data 0x%x\\n\",\n\t\t    __func__, addr, data);\n\treturn ret_val;\n}\n\n \nstatic void\nqla8044_read_write_crb_reg(struct scsi_qla_host *vha,\n\tuint32_t raddr, uint32_t waddr)\n{\n\tuint32_t value;\n\n\tqla8044_rd_reg_indirect(vha, raddr, &value);\n\tqla8044_wr_reg_indirect(vha, waddr, value);\n}\n\nstatic int\nqla8044_poll_wait_for_ready(struct scsi_qla_host *vha, uint32_t addr1,\n\tuint32_t mask)\n{\n\tunsigned long timeout;\n\tuint32_t temp = 0;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(TIMEOUT_100_MS);\n\tdo {\n\t\tqla8044_rd_reg_indirect(vha, addr1, &temp);\n\t\tif ((temp & mask) != 0)\n\t\t\tbreak;\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tql_log(ql_log_warn, vha, 0xb151,\n\t\t\t\t\"Error in processing rdmdio entry\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic uint32_t\nqla8044_ipmdio_rd_reg(struct scsi_qla_host *vha,\n\tuint32_t addr1, uint32_t addr3, uint32_t mask, uint32_t addr)\n{\n\tuint32_t temp;\n\tint ret = 0;\n\n\tret = qla8044_poll_wait_for_ready(vha, addr1, mask);\n\tif (ret == -1)\n\t\treturn -1;\n\n\ttemp = (0x40000000 | addr);\n\tqla8044_wr_reg_indirect(vha, addr1, temp);\n\n\tret = qla8044_poll_wait_for_ready(vha, addr1, mask);\n\tif (ret == -1)\n\t\treturn 0;\n\n\tqla8044_rd_reg_indirect(vha, addr3, &ret);\n\n\treturn ret;\n}\n\n\nstatic int\nqla8044_poll_wait_ipmdio_bus_idle(struct scsi_qla_host *vha,\n\tuint32_t addr1, uint32_t addr2, uint32_t addr3, uint32_t mask)\n{\n\tunsigned long timeout;\n\tuint32_t temp;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(TIMEOUT_100_MS);\n\tdo {\n\t\ttemp = qla8044_ipmdio_rd_reg(vha, addr1, addr3, mask, addr2);\n\t\tif ((temp & 0x1) != 1)\n\t\t\tbreak;\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tql_log(ql_log_warn, vha, 0xb152,\n\t\t\t    \"Error in processing mdiobus idle\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int\nqla8044_ipmdio_wr_reg(struct scsi_qla_host *vha, uint32_t addr1,\n\tuint32_t addr3, uint32_t mask, uint32_t addr, uint32_t value)\n{\n\tint ret = 0;\n\n\tret = qla8044_poll_wait_for_ready(vha, addr1, mask);\n\tif (ret == -1)\n\t\treturn -1;\n\n\tqla8044_wr_reg_indirect(vha, addr3, value);\n\tqla8044_wr_reg_indirect(vha, addr1, addr);\n\n\tret = qla8044_poll_wait_for_ready(vha, addr1, mask);\n\tif (ret == -1)\n\t\treturn -1;\n\n\treturn 0;\n}\n \nstatic void\nqla8044_rmw_crb_reg(struct scsi_qla_host *vha,\n\tuint32_t raddr, uint32_t waddr,\tstruct qla8044_rmw *p_rmw_hdr)\n{\n\tuint32_t value;\n\n\tif (p_rmw_hdr->index_a)\n\t\tvalue = vha->reset_tmplt.array[p_rmw_hdr->index_a];\n\telse\n\t\tqla8044_rd_reg_indirect(vha, raddr, &value);\n\tvalue &= p_rmw_hdr->test_mask;\n\tvalue <<= p_rmw_hdr->shl;\n\tvalue >>= p_rmw_hdr->shr;\n\tvalue |= p_rmw_hdr->or_value;\n\tvalue ^= p_rmw_hdr->xor_value;\n\tqla8044_wr_reg_indirect(vha, waddr, value);\n\treturn;\n}\n\nstatic inline void\nqla8044_set_qsnt_ready(struct scsi_qla_host *vha)\n{\n\tuint32_t qsnt_state;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqsnt_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\n\tqsnt_state |= (1 << ha->portnum);\n\tqla8044_wr_direct(vha, QLA8044_CRB_DRV_STATE_INDEX, qsnt_state);\n\tql_log(ql_log_info, vha, 0xb08e, \"%s(%ld): qsnt_state: 0x%08x\\n\",\n\t     __func__, vha->host_no, qsnt_state);\n}\n\nvoid\nqla8044_clear_qsnt_ready(struct scsi_qla_host *vha)\n{\n\tuint32_t qsnt_state;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqsnt_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\n\tqsnt_state &= ~(1 << ha->portnum);\n\tqla8044_wr_direct(vha, QLA8044_CRB_DRV_STATE_INDEX, qsnt_state);\n\tql_log(ql_log_info, vha, 0xb08f, \"%s(%ld): qsnt_state: 0x%08x\\n\",\n\t    __func__, vha->host_no, qsnt_state);\n}\n\n \nstatic int\nqla8044_lock_recovery(struct scsi_qla_host *vha)\n{\n\tuint32_t lock = 0, lockid;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tlockid = qla8044_rd_reg(ha, QLA8044_DRV_LOCKRECOVERY);\n\n\t \n\tif ((lockid & IDC_LOCK_RECOVERY_STATE_MASK) != 0)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\t \n\tqla8044_wr_reg(ha, QLA8044_DRV_LOCKRECOVERY,\n\t    (ha->portnum <<\n\t     IDC_LOCK_RECOVERY_STATE_SHIFT_BITS) | INTENT_TO_RECOVER);\n\tmsleep(200);\n\n\t \n\tlockid = qla8044_rd_reg(ha, QLA8044_DRV_LOCKRECOVERY);\n\tif ((lockid & IDC_LOCK_RECOVERY_OWNER_MASK) != (ha->portnum <<\n\t    IDC_LOCK_RECOVERY_STATE_SHIFT_BITS))\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb08B, \"%s:%d: IDC Lock recovery initiated\\n\"\n\t    , __func__, ha->portnum);\n\n\t \n\tqla8044_wr_reg(ha, QLA8044_DRV_LOCKRECOVERY,\n\t    (ha->portnum << IDC_LOCK_RECOVERY_STATE_SHIFT_BITS) |\n\t    PROCEED_TO_RECOVER);\n\n\t \n\tqla8044_wr_reg(ha, QLA8044_DRV_LOCK_ID, 0xFF);\n\tqla8044_rd_reg(ha, QLA8044_DRV_UNLOCK);\n\n\t \n\tqla8044_wr_reg(ha, QLA8044_DRV_LOCKRECOVERY, 0);\n\n\t \n\tlock = qla8044_rd_reg(ha, QLA8044_DRV_LOCK);\n\tif (lock) {\n\t\tlockid = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\n\t\tlockid = ((lockid + (1 << 8)) & ~0xFF) | ha->portnum;\n\t\tqla8044_wr_reg(ha, QLA8044_DRV_LOCK_ID, lockid);\n\t\treturn QLA_SUCCESS;\n\t} else\n\t\treturn QLA_FUNCTION_FAILED;\n}\n\nint\nqla8044_idc_lock(struct qla_hw_data *ha)\n{\n\tuint32_t ret_val = QLA_SUCCESS, timeout = 0, status = 0;\n\tuint32_t lock_id, lock_cnt, func_num, tmo_owner = 0, first_owner = 0;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\twhile (status == 0) {\n\t\t \n\t\tstatus = qla8044_rd_reg(ha, QLA8044_DRV_LOCK);\n\n\t\tif (status) {\n\t\t\t \n\t\t\tlock_id = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\n\t\t\tlock_id = ((lock_id + (1 << 8)) & ~0xFF) | ha->portnum;\n\t\t\tqla8044_wr_reg(ha, QLA8044_DRV_LOCK_ID, lock_id);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (timeout == 0)\n\t\t\tfirst_owner = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\n\n\t\tif (++timeout >=\n\t\t    (QLA8044_DRV_LOCK_TIMEOUT / QLA8044_DRV_LOCK_MSLEEP)) {\n\t\t\ttmo_owner = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\n\t\t\tfunc_num = tmo_owner & 0xFF;\n\t\t\tlock_cnt = tmo_owner >> 8;\n\t\t\tql_log(ql_log_warn, vha, 0xb114,\n\t\t\t    \"%s: Lock by func %d failed after 2s, lock held \"\n\t\t\t    \"by func %d, lock count %d, first_owner %d\\n\",\n\t\t\t    __func__, ha->portnum, func_num, lock_cnt,\n\t\t\t    (first_owner & 0xFF));\n\t\t\tif (first_owner != tmo_owner) {\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb115,\n\t\t\t\t    \"%s: %d: IDC lock failed\\n\",\n\t\t\t\t    __func__, ha->portnum);\n\t\t\t\ttimeout = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (qla8044_lock_recovery(vha) == QLA_SUCCESS) {\n\t\t\t\t\t \n\t\t\t\t\tret_val = QLA_SUCCESS;\n\t\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb116,\n\t\t\t\t\t    \"%s:IDC lock Recovery by %d\"\n\t\t\t\t\t    \"successful...\\n\", __func__,\n\t\t\t\t\t     ha->portnum);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb08a,\n\t\t\t\t       \"%s: IDC lock Recovery by %d \"\n\t\t\t\t       \"failed, Retrying timeout\\n\", __func__,\n\t\t\t\t       ha->portnum);\n\t\t\t\ttimeout = 0;\n\t\t\t}\n\t\t}\n\t\tmsleep(QLA8044_DRV_LOCK_MSLEEP);\n\t}\n\treturn ret_val;\n}\n\nvoid\nqla8044_idc_unlock(struct qla_hw_data *ha)\n{\n\tint id;\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tid = qla8044_rd_reg(ha, QLA8044_DRV_LOCK_ID);\n\n\tif ((id & 0xFF) != ha->portnum) {\n\t\tql_log(ql_log_warn, vha, 0xb118,\n\t\t    \"%s: IDC Unlock by %d failed, lock owner is %d!\\n\",\n\t\t    __func__, ha->portnum, (id & 0xFF));\n\t\treturn;\n\t}\n\n\t \n\tqla8044_wr_reg(ha, QLA8044_DRV_LOCK_ID, (id | 0xFF));\n\tqla8044_rd_reg(ha, QLA8044_DRV_UNLOCK);\n}\n\n \nstatic int\nqla8044_flash_lock(scsi_qla_host_t *vha)\n{\n\tint lock_owner;\n\tint timeout = 0;\n\tuint32_t lock_status = 0;\n\tint ret_val = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\twhile (lock_status == 0) {\n\t\tlock_status = qla8044_rd_reg(ha, QLA8044_FLASH_LOCK);\n\t\tif (lock_status)\n\t\t\tbreak;\n\n\t\tif (++timeout >= QLA8044_FLASH_LOCK_TIMEOUT / 20) {\n\t\t\tlock_owner = qla8044_rd_reg(ha,\n\t\t\t    QLA8044_FLASH_LOCK_ID);\n\t\t\tql_log(ql_log_warn, vha, 0xb113,\n\t\t\t    \"%s: Simultaneous flash access by following ports, active port = %d: accessing port = %d\",\n\t\t\t    __func__, ha->portnum, lock_owner);\n\t\t\tret_val = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t}\n\tqla8044_wr_reg(ha, QLA8044_FLASH_LOCK_ID, ha->portnum);\n\treturn ret_val;\n}\n\nstatic void\nqla8044_flash_unlock(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tqla8044_wr_reg(ha, QLA8044_FLASH_LOCK_ID, 0xFF);\n\tqla8044_rd_reg(ha, QLA8044_FLASH_UNLOCK);\n}\n\n\nstatic\nvoid qla8044_flash_lock_recovery(struct scsi_qla_host *vha)\n{\n\n\tif (qla8044_flash_lock(vha)) {\n\t\t \n\t\tql_log(ql_log_warn, vha, 0xb120, \"Resetting flash_lock\\n\");\n\t}\n\n\t \n\tqla8044_flash_unlock(vha);\n}\n\n \nstatic int\nqla8044_read_flash_data(scsi_qla_host_t *vha,  uint8_t *p_data,\n\tuint32_t flash_addr, int u32_word_count)\n{\n\tint i, ret_val = QLA_SUCCESS;\n\tuint32_t u32_word;\n\n\tif (qla8044_flash_lock(vha) != QLA_SUCCESS) {\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t\tgoto exit_lock_error;\n\t}\n\n\tif (flash_addr & 0x03) {\n\t\tql_log(ql_log_warn, vha, 0xb117,\n\t\t    \"%s: Illegal addr = 0x%x\\n\", __func__, flash_addr);\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t\tgoto exit_flash_read;\n\t}\n\n\tfor (i = 0; i < u32_word_count; i++) {\n\t\tif (qla8044_wr_reg_indirect(vha, QLA8044_FLASH_DIRECT_WINDOW,\n\t\t    (flash_addr & 0xFFFF0000))) {\n\t\t\tql_log(ql_log_warn, vha, 0xb119,\n\t\t\t    \"%s: failed to write addr 0x%x to \"\n\t\t\t    \"FLASH_DIRECT_WINDOW\\n! \",\n\t\t\t    __func__, flash_addr);\n\t\t\tret_val = QLA_FUNCTION_FAILED;\n\t\t\tgoto exit_flash_read;\n\t\t}\n\n\t\tret_val = qla8044_rd_reg_indirect(vha,\n\t\t    QLA8044_FLASH_DIRECT_DATA(flash_addr),\n\t\t    &u32_word);\n\t\tif (ret_val != QLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0xb08c,\n\t\t\t    \"%s: failed to read addr 0x%x!\\n\",\n\t\t\t    __func__, flash_addr);\n\t\t\tgoto exit_flash_read;\n\t\t}\n\n\t\t*(uint32_t *)p_data = u32_word;\n\t\tp_data = p_data + 4;\n\t\tflash_addr = flash_addr + 4;\n\t}\n\nexit_flash_read:\n\tqla8044_flash_unlock(vha);\n\nexit_lock_error:\n\treturn ret_val;\n}\n\n \nvoid *\nqla8044_read_optrom_data(struct scsi_qla_host *vha, void *buf,\n\tuint32_t offset, uint32_t length)\n{\n\tscsi_block_requests(vha->host);\n\tif (qla8044_read_flash_data(vha, buf, offset, length / 4)\n\t    != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha,  0xb08d,\n\t\t    \"%s: Failed to read from flash\\n\",\n\t\t    __func__);\n\t}\n\tscsi_unblock_requests(vha->host);\n\treturn buf;\n}\n\nstatic inline int\nqla8044_need_reset(struct scsi_qla_host *vha)\n{\n\tuint32_t drv_state, drv_active;\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tdrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\n\tdrv_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\n\n\trval = drv_state & (1 << ha->portnum);\n\n\tif (ha->flags.eeh_busy && drv_active)\n\t\trval = 1;\n\treturn rval;\n}\n\n \nstatic void\nqla8044_write_list(struct scsi_qla_host *vha,\n\tstruct qla8044_reset_entry_hdr *p_hdr)\n{\n\tstruct qla8044_entry *p_entry;\n\tuint32_t i;\n\n\tp_entry = (struct qla8044_entry *)((char *)p_hdr +\n\t    sizeof(struct qla8044_reset_entry_hdr));\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla8044_wr_reg_indirect(vha, p_entry->arg1, p_entry->arg2);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((uint32_t)(p_hdr->delay));\n\t}\n}\n\n \nstatic void\nqla8044_read_write_list(struct scsi_qla_host *vha,\n\tstruct qla8044_reset_entry_hdr *p_hdr)\n{\n\tstruct qla8044_entry *p_entry;\n\tuint32_t i;\n\n\tp_entry = (struct qla8044_entry *)((char *)p_hdr +\n\t    sizeof(struct qla8044_reset_entry_hdr));\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla8044_read_write_crb_reg(vha, p_entry->arg1,\n\t\t    p_entry->arg2);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((uint32_t)(p_hdr->delay));\n\t}\n}\n\n \nstatic int\nqla8044_poll_reg(struct scsi_qla_host *vha, uint32_t addr,\n\tint duration, uint32_t test_mask, uint32_t test_result)\n{\n\tuint32_t value = 0;\n\tint timeout_error;\n\tuint8_t retries;\n\tint ret_val = QLA_SUCCESS;\n\n\tret_val = qla8044_rd_reg_indirect(vha, addr, &value);\n\tif (ret_val == QLA_FUNCTION_FAILED) {\n\t\ttimeout_error = 1;\n\t\tgoto exit_poll_reg;\n\t}\n\n\t \n\tretries = duration/10;\n\n\tdo {\n\t\tif ((value & test_mask) != test_result) {\n\t\t\ttimeout_error = 1;\n\t\t\tmsleep(duration/10);\n\t\t\tret_val = qla8044_rd_reg_indirect(vha, addr, &value);\n\t\t\tif (ret_val == QLA_FUNCTION_FAILED) {\n\t\t\t\ttimeout_error = 1;\n\t\t\t\tgoto exit_poll_reg;\n\t\t\t}\n\t\t} else {\n\t\t\ttimeout_error = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (retries--);\n\nexit_poll_reg:\n\tif (timeout_error) {\n\t\tvha->reset_tmplt.seq_error++;\n\t\tql_log(ql_log_fatal, vha, 0xb090,\n\t\t    \"%s: Poll Failed: 0x%08x 0x%08x 0x%08x\\n\",\n\t\t    __func__, value, test_mask, test_result);\n\t}\n\n\treturn timeout_error;\n}\n\n \nstatic void\nqla8044_poll_list(struct scsi_qla_host *vha,\n\tstruct qla8044_reset_entry_hdr *p_hdr)\n{\n\tlong delay;\n\tstruct qla8044_entry *p_entry;\n\tstruct qla8044_poll *p_poll;\n\tuint32_t i;\n\tuint32_t value;\n\n\tp_poll = (struct qla8044_poll *)\n\t\t((char *)p_hdr + sizeof(struct qla8044_reset_entry_hdr));\n\n\t \n\tp_entry = (struct qla8044_entry *)((char *)p_poll +\n\t    sizeof(struct qla8044_poll));\n\n\tdelay = (long)p_hdr->delay;\n\n\tif (!delay) {\n\t\tfor (i = 0; i < p_hdr->count; i++, p_entry++)\n\t\t\tqla8044_poll_reg(vha, p_entry->arg1,\n\t\t\t    delay, p_poll->test_mask, p_poll->test_value);\n\t} else {\n\t\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\t\tif (delay) {\n\t\t\t\tif (qla8044_poll_reg(vha,\n\t\t\t\t    p_entry->arg1, delay,\n\t\t\t\t    p_poll->test_mask,\n\t\t\t\t    p_poll->test_value)) {\n\t\t\t\t\t \n\t\t\t\t\tqla8044_rd_reg_indirect(vha,\n\t\t\t\t\t    p_entry->arg1, &value);\n\t\t\t\t\tqla8044_rd_reg_indirect(vha,\n\t\t\t\t\t    p_entry->arg2, &value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\nqla8044_poll_write_list(struct scsi_qla_host *vha,\n\tstruct qla8044_reset_entry_hdr *p_hdr)\n{\n\tlong delay;\n\tstruct qla8044_quad_entry *p_entry;\n\tstruct qla8044_poll *p_poll;\n\tuint32_t i;\n\n\tp_poll = (struct qla8044_poll *)((char *)p_hdr +\n\t    sizeof(struct qla8044_reset_entry_hdr));\n\n\tp_entry = (struct qla8044_quad_entry *)((char *)p_poll +\n\t    sizeof(struct qla8044_poll));\n\n\tdelay = (long)p_hdr->delay;\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla8044_wr_reg_indirect(vha,\n\t\t    p_entry->dr_addr, p_entry->dr_value);\n\t\tqla8044_wr_reg_indirect(vha,\n\t\t    p_entry->ar_addr, p_entry->ar_value);\n\t\tif (delay) {\n\t\t\tif (qla8044_poll_reg(vha,\n\t\t\t    p_entry->ar_addr, delay,\n\t\t\t    p_poll->test_mask,\n\t\t\t    p_poll->test_value)) {\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb091,\n\t\t\t\t    \"%s: Timeout Error: poll list, \",\n\t\t\t\t    __func__);\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb092,\n\t\t\t\t    \"item_num %d, entry_num %d\\n\", i,\n\t\t\t\t    vha->reset_tmplt.seq_index);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\nqla8044_read_modify_write(struct scsi_qla_host *vha,\n\tstruct qla8044_reset_entry_hdr *p_hdr)\n{\n\tstruct qla8044_entry *p_entry;\n\tstruct qla8044_rmw *p_rmw_hdr;\n\tuint32_t i;\n\n\tp_rmw_hdr = (struct qla8044_rmw *)((char *)p_hdr +\n\t    sizeof(struct qla8044_reset_entry_hdr));\n\n\tp_entry = (struct qla8044_entry *)((char *)p_rmw_hdr +\n\t    sizeof(struct qla8044_rmw));\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla8044_rmw_crb_reg(vha, p_entry->arg1,\n\t\t    p_entry->arg2, p_rmw_hdr);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((uint32_t)(p_hdr->delay));\n\t}\n}\n\n \nstatic\nvoid qla8044_pause(struct scsi_qla_host *vha,\n\tstruct qla8044_reset_entry_hdr *p_hdr)\n{\n\tif (p_hdr->delay)\n\t\tmdelay((uint32_t)((long)p_hdr->delay));\n}\n\n \nstatic void\nqla8044_template_end(struct scsi_qla_host *vha,\n\tstruct qla8044_reset_entry_hdr *p_hdr)\n{\n\tvha->reset_tmplt.template_end = 1;\n\n\tif (vha->reset_tmplt.seq_error == 0) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb093,\n\t\t    \"%s: Reset sequence completed SUCCESSFULLY.\\n\", __func__);\n\t} else {\n\t\tql_log(ql_log_fatal, vha, 0xb094,\n\t\t    \"%s: Reset sequence completed with some timeout \"\n\t\t    \"errors.\\n\", __func__);\n\t}\n}\n\n \nstatic void\nqla8044_poll_read_list(struct scsi_qla_host *vha,\n\tstruct qla8044_reset_entry_hdr *p_hdr)\n{\n\tlong delay;\n\tint index;\n\tstruct qla8044_quad_entry *p_entry;\n\tstruct qla8044_poll *p_poll;\n\tuint32_t i;\n\tuint32_t value;\n\n\tp_poll = (struct qla8044_poll *)\n\t\t((char *)p_hdr + sizeof(struct qla8044_reset_entry_hdr));\n\n\tp_entry = (struct qla8044_quad_entry *)\n\t\t((char *)p_poll + sizeof(struct qla8044_poll));\n\n\tdelay = (long)p_hdr->delay;\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla8044_wr_reg_indirect(vha, p_entry->ar_addr,\n\t\t    p_entry->ar_value);\n\t\tif (delay) {\n\t\t\tif (qla8044_poll_reg(vha, p_entry->ar_addr, delay,\n\t\t\t    p_poll->test_mask, p_poll->test_value)) {\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb095,\n\t\t\t\t    \"%s: Timeout Error: poll \"\n\t\t\t\t    \"list, \", __func__);\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb096,\n\t\t\t\t    \"Item_num %d, \"\n\t\t\t\t    \"entry_num %d\\n\", i,\n\t\t\t\t    vha->reset_tmplt.seq_index);\n\t\t\t} else {\n\t\t\t\tindex = vha->reset_tmplt.array_index;\n\t\t\t\tqla8044_rd_reg_indirect(vha,\n\t\t\t\t    p_entry->dr_addr, &value);\n\t\t\t\tvha->reset_tmplt.array[index++] = value;\n\t\t\t\tif (index == QLA8044_MAX_RESET_SEQ_ENTRIES)\n\t\t\t\t\tvha->reset_tmplt.array_index = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\nqla8044_process_reset_template(struct scsi_qla_host *vha,\n\tchar *p_buff)\n{\n\tint index, entries;\n\tstruct qla8044_reset_entry_hdr *p_hdr;\n\tchar *p_entry = p_buff;\n\n\tvha->reset_tmplt.seq_end = 0;\n\tvha->reset_tmplt.template_end = 0;\n\tentries = vha->reset_tmplt.hdr->entries;\n\tindex = vha->reset_tmplt.seq_index;\n\n\tfor (; (!vha->reset_tmplt.seq_end) && (index  < entries); index++) {\n\t\tp_hdr = (struct qla8044_reset_entry_hdr *)p_entry;\n\t\tswitch (p_hdr->cmd) {\n\t\tcase OPCODE_NOP:\n\t\t\tbreak;\n\t\tcase OPCODE_WRITE_LIST:\n\t\t\tqla8044_write_list(vha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_READ_WRITE_LIST:\n\t\t\tqla8044_read_write_list(vha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_POLL_LIST:\n\t\t\tqla8044_poll_list(vha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_POLL_WRITE_LIST:\n\t\t\tqla8044_poll_write_list(vha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_READ_MODIFY_WRITE:\n\t\t\tqla8044_read_modify_write(vha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_SEQ_PAUSE:\n\t\t\tqla8044_pause(vha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_SEQ_END:\n\t\t\tvha->reset_tmplt.seq_end = 1;\n\t\t\tbreak;\n\t\tcase OPCODE_TMPL_END:\n\t\t\tqla8044_template_end(vha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_POLL_READ_LIST:\n\t\t\tqla8044_poll_read_list(vha, p_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_log(ql_log_fatal, vha, 0xb097,\n\t\t\t    \"%s: Unknown command ==> 0x%04x on \"\n\t\t\t    \"entry = %d\\n\", __func__, p_hdr->cmd, index);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tp_entry += p_hdr->size;\n\t}\n\tvha->reset_tmplt.seq_index = index;\n}\n\nstatic void\nqla8044_process_init_seq(struct scsi_qla_host *vha)\n{\n\tqla8044_process_reset_template(vha,\n\t    vha->reset_tmplt.init_offset);\n\tif (vha->reset_tmplt.seq_end != 1)\n\t\tql_log(ql_log_fatal, vha, 0xb098,\n\t\t    \"%s: Abrupt INIT Sub-Sequence end.\\n\",\n\t\t    __func__);\n}\n\nstatic void\nqla8044_process_stop_seq(struct scsi_qla_host *vha)\n{\n\tvha->reset_tmplt.seq_index = 0;\n\tqla8044_process_reset_template(vha, vha->reset_tmplt.stop_offset);\n\tif (vha->reset_tmplt.seq_end != 1)\n\t\tql_log(ql_log_fatal, vha, 0xb099,\n\t\t    \"%s: Abrupt STOP Sub-Sequence end.\\n\", __func__);\n}\n\nstatic void\nqla8044_process_start_seq(struct scsi_qla_host *vha)\n{\n\tqla8044_process_reset_template(vha, vha->reset_tmplt.start_offset);\n\tif (vha->reset_tmplt.template_end != 1)\n\t\tql_log(ql_log_fatal, vha, 0xb09a,\n\t\t    \"%s: Abrupt START Sub-Sequence end.\\n\",\n\t\t    __func__);\n}\n\nstatic int\nqla8044_lockless_flash_read_u32(struct scsi_qla_host *vha,\n\tuint32_t flash_addr, uint8_t *p_data, int u32_word_count)\n{\n\tuint32_t i;\n\tuint32_t u32_word;\n\tuint32_t flash_offset;\n\tuint32_t addr = flash_addr;\n\tint ret_val = QLA_SUCCESS;\n\n\tflash_offset = addr & (QLA8044_FLASH_SECTOR_SIZE - 1);\n\n\tif (addr & 0x3) {\n\t\tql_log(ql_log_fatal, vha, 0xb09b, \"%s: Illegal addr = 0x%x\\n\",\n\t\t    __func__, addr);\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t\tgoto exit_lockless_read;\n\t}\n\n\tret_val = qla8044_wr_reg_indirect(vha,\n\t    QLA8044_FLASH_DIRECT_WINDOW, (addr));\n\n\tif (ret_val != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, vha, 0xb09c,\n\t\t    \"%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\\n\",\n\t\t    __func__, addr);\n\t\tgoto exit_lockless_read;\n\t}\n\n\t \n\tif ((flash_offset + (u32_word_count * sizeof(uint32_t))) >\n\t    (QLA8044_FLASH_SECTOR_SIZE - 1)) {\n\t\t \n\t\tfor (i = 0; i < u32_word_count; i++) {\n\t\t\tret_val = qla8044_rd_reg_indirect(vha,\n\t\t\t    QLA8044_FLASH_DIRECT_DATA(addr), &u32_word);\n\t\t\tif (ret_val != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0xb09d,\n\t\t\t\t    \"%s: failed to read addr 0x%x!\\n\",\n\t\t\t\t    __func__, addr);\n\t\t\t\tgoto exit_lockless_read;\n\t\t\t}\n\t\t\t*(uint32_t *)p_data  = u32_word;\n\t\t\tp_data = p_data + 4;\n\t\t\taddr = addr + 4;\n\t\t\tflash_offset = flash_offset + 4;\n\t\t\tif (flash_offset > (QLA8044_FLASH_SECTOR_SIZE - 1)) {\n\t\t\t\t \n\t\t\t\tret_val = qla8044_wr_reg_indirect(vha,\n\t\t\t\t    QLA8044_FLASH_DIRECT_WINDOW, (addr));\n\t\t\t\tif (ret_val != QLA_SUCCESS) {\n\t\t\t\t\tql_log(ql_log_fatal, vha, 0xb09f,\n\t\t\t\t\t    \"%s: failed to write addr \"\n\t\t\t\t\t    \"0x%x to FLASH_DIRECT_WINDOW!\\n\",\n\t\t\t\t\t    __func__, addr);\n\t\t\t\t\tgoto exit_lockless_read;\n\t\t\t\t}\n\t\t\t\tflash_offset = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < u32_word_count; i++) {\n\t\t\tret_val = qla8044_rd_reg_indirect(vha,\n\t\t\t    QLA8044_FLASH_DIRECT_DATA(addr), &u32_word);\n\t\t\tif (ret_val != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0xb0a0,\n\t\t\t\t    \"%s: failed to read addr 0x%x!\\n\",\n\t\t\t\t    __func__, addr);\n\t\t\t\tgoto exit_lockless_read;\n\t\t\t}\n\t\t\t*(uint32_t *)p_data = u32_word;\n\t\t\tp_data = p_data + 4;\n\t\t\taddr = addr + 4;\n\t\t}\n\t}\n\nexit_lockless_read:\n\treturn ret_val;\n}\n\n \nstatic int\nqla8044_ms_mem_write_128b(struct scsi_qla_host *vha,\n\tuint64_t addr, uint32_t *data, uint32_t count)\n{\n\tint i, j, ret_val = QLA_SUCCESS;\n\tuint32_t agt_ctrl;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (addr & 0xF) {\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t\tgoto exit_ms_mem_write;\n\t}\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\n\t \n\tret_val = qla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_ADDR_HI, 0);\n\tif (ret_val == QLA_FUNCTION_FAILED) {\n\t\tql_log(ql_log_fatal, vha, 0xb0a1,\n\t\t    \"%s: write to AGT_ADDR_HI failed!\\n\", __func__);\n\t\tgoto exit_ms_mem_write_unlock;\n\t}\n\n\tfor (i = 0; i < count; i++, addr += 16) {\n\t\tif (!((addr_in_range(addr, QLA8044_ADDR_QDR_NET,\n\t\t    QLA8044_ADDR_QDR_NET_MAX)) ||\n\t\t    (addr_in_range(addr, QLA8044_ADDR_DDR_NET,\n\t\t\tQLA8044_ADDR_DDR_NET_MAX)))) {\n\t\t\tret_val = QLA_FUNCTION_FAILED;\n\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t}\n\n\t\tret_val = qla8044_wr_reg_indirect(vha,\n\t\t    MD_MIU_TEST_AGT_ADDR_LO, addr);\n\n\t\t \n\t\tret_val += qla8044_wr_reg_indirect(vha,\n\t\t    MD_MIU_TEST_AGT_WRDATA_LO, *data++);\n\t\tret_val += qla8044_wr_reg_indirect(vha,\n\t\t    MD_MIU_TEST_AGT_WRDATA_HI, *data++);\n\t\tret_val += qla8044_wr_reg_indirect(vha,\n\t\t    MD_MIU_TEST_AGT_WRDATA_ULO, *data++);\n\t\tret_val += qla8044_wr_reg_indirect(vha,\n\t\t    MD_MIU_TEST_AGT_WRDATA_UHI, *data++);\n\t\tif (ret_val == QLA_FUNCTION_FAILED) {\n\t\t\tql_log(ql_log_fatal, vha, 0xb0a2,\n\t\t\t    \"%s: write to AGT_WRDATA failed!\\n\",\n\t\t\t    __func__);\n\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t}\n\n\t\t \n\t\tret_val = qla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL,\n\t\t    MIU_TA_CTL_WRITE_ENABLE);\n\t\tret_val += qla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL,\n\t\t    MIU_TA_CTL_WRITE_START);\n\t\tif (ret_val == QLA_FUNCTION_FAILED) {\n\t\t\tql_log(ql_log_fatal, vha, 0xb0a3,\n\t\t\t    \"%s: write to AGT_CTRL failed!\\n\", __func__);\n\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t}\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\tret_val = qla8044_rd_reg_indirect(vha,\n\t\t\t    MD_MIU_TEST_AGT_CTRL, &agt_ctrl);\n\t\t\tif (ret_val == QLA_FUNCTION_FAILED) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0xb0a4,\n\t\t\t\t    \"%s: failed to read \"\n\t\t\t\t    \"MD_MIU_TEST_AGT_CTRL!\\n\", __func__);\n\t\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t\t}\n\t\t\tif ((agt_ctrl & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tql_log(ql_log_fatal, vha, 0xb0a5,\n\t\t\t    \"%s: MS memory write failed!\\n\",\n\t\t\t   __func__);\n\t\t\tret_val = QLA_FUNCTION_FAILED;\n\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t}\n\t}\n\nexit_ms_mem_write_unlock:\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\nexit_ms_mem_write:\n\treturn ret_val;\n}\n\nstatic int\nqla8044_copy_bootloader(struct scsi_qla_host *vha)\n{\n\tuint8_t *p_cache;\n\tuint32_t src, count, size;\n\tuint64_t dest;\n\tint ret_val = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tsrc = QLA8044_BOOTLOADER_FLASH_ADDR;\n\tdest = qla8044_rd_reg(ha, QLA8044_BOOTLOADER_ADDR);\n\tsize = qla8044_rd_reg(ha, QLA8044_BOOTLOADER_SIZE);\n\n\t \n\tif (size & 0xF)\n\t\tsize = (size + 16) & ~0xF;\n\n\t \n\tcount = size/16;\n\n\tp_cache = vmalloc(size);\n\tif (p_cache == NULL) {\n\t\tql_log(ql_log_fatal, vha, 0xb0a6,\n\t\t    \"%s: Failed to allocate memory for \"\n\t\t    \"boot loader cache\\n\", __func__);\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t\tgoto exit_copy_bootloader;\n\t}\n\n\tret_val = qla8044_lockless_flash_read_u32(vha, src,\n\t    p_cache, size/sizeof(uint32_t));\n\tif (ret_val == QLA_FUNCTION_FAILED) {\n\t\tql_log(ql_log_fatal, vha, 0xb0a7,\n\t\t    \"%s: Error reading F/W from flash!!!\\n\", __func__);\n\t\tgoto exit_copy_error;\n\t}\n\tql_dbg(ql_dbg_p3p, vha, 0xb0a8, \"%s: Read F/W from flash!\\n\",\n\t    __func__);\n\n\t \n\tret_val = qla8044_ms_mem_write_128b(vha, dest,\n\t    (uint32_t *)p_cache, count);\n\tif (ret_val == QLA_FUNCTION_FAILED) {\n\t\tql_log(ql_log_fatal, vha, 0xb0a9,\n\t\t    \"%s: Error writing F/W to MS !!!\\n\", __func__);\n\t\tgoto exit_copy_error;\n\t}\n\tql_dbg(ql_dbg_p3p, vha, 0xb0aa,\n\t    \"%s: Wrote F/W (size %d) to MS !!!\\n\",\n\t    __func__, size);\n\nexit_copy_error:\n\tvfree(p_cache);\n\nexit_copy_bootloader:\n\treturn ret_val;\n}\n\nstatic int\nqla8044_restart(struct scsi_qla_host *vha)\n{\n\tint ret_val = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqla8044_process_stop_seq(vha);\n\n\t \n\tif (ql2xmdenable)\n\t\tqla8044_get_minidump(vha);\n\telse\n\t\tql_log(ql_log_fatal, vha, 0xb14c,\n\t\t    \"Minidump disabled.\\n\");\n\n\tqla8044_process_init_seq(vha);\n\n\tif (qla8044_copy_bootloader(vha)) {\n\t\tql_log(ql_log_fatal, vha, 0xb0ab,\n\t\t    \"%s: Copy bootloader, firmware restart failed!\\n\",\n\t\t    __func__);\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t\tgoto exit_restart;\n\t}\n\n\t \n\tqla8044_wr_reg(ha, QLA8044_FW_IMAGE_VALID, QLA8044_BOOT_FROM_FLASH);\n\n\tqla8044_process_start_seq(vha);\n\nexit_restart:\n\treturn ret_val;\n}\n\n \nstatic int\nqla8044_check_cmd_peg_status(struct scsi_qla_host *vha)\n{\n\tuint32_t val, ret_val = QLA_FUNCTION_FAILED;\n\tint retries = CRB_CMDPEG_CHECK_RETRY_COUNT;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tdo {\n\t\tval = qla8044_rd_reg(ha, QLA8044_CMDPEG_STATE);\n\t\tif (val == PHAN_INITIALIZE_COMPLETE) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb0ac,\n\t\t\t    \"%s: Command Peg initialization \"\n\t\t\t    \"complete! state=0x%x\\n\", __func__, val);\n\t\t\tret_val = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(CRB_CMDPEG_CHECK_DELAY);\n\t} while (--retries);\n\n\treturn ret_val;\n}\n\nstatic int\nqla8044_start_firmware(struct scsi_qla_host *vha)\n{\n\tint ret_val = QLA_SUCCESS;\n\n\tif (qla8044_restart(vha)) {\n\t\tql_log(ql_log_fatal, vha, 0xb0ad,\n\t\t    \"%s: Restart Error!!!, Need Reset!!!\\n\",\n\t\t    __func__);\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t\tgoto exit_start_fw;\n\t} else\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb0af,\n\t\t    \"%s: Restart done!\\n\", __func__);\n\n\tret_val = qla8044_check_cmd_peg_status(vha);\n\tif (ret_val) {\n\t\tql_log(ql_log_fatal, vha, 0xb0b0,\n\t\t    \"%s: Peg not initialized!\\n\", __func__);\n\t\tret_val = QLA_FUNCTION_FAILED;\n\t}\n\nexit_start_fw:\n\treturn ret_val;\n}\n\nvoid\nqla8044_clear_drv_active(struct qla_hw_data *ha)\n{\n\tuint32_t drv_active;\n\tstruct scsi_qla_host *vha = pci_get_drvdata(ha->pdev);\n\n\tdrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\n\tdrv_active &= ~(1 << (ha->portnum));\n\n\tql_log(ql_log_info, vha, 0xb0b1,\n\t    \"%s(%ld): drv_active: 0x%08x\\n\",\n\t    __func__, vha->host_no, drv_active);\n\n\tqla8044_wr_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX, drv_active);\n}\n\n \nstatic int\nqla8044_device_bootstrap(struct scsi_qla_host *vha)\n{\n\tint rval = QLA_FUNCTION_FAILED;\n\tint i;\n\tuint32_t old_count = 0, count = 0;\n\tint need_reset = 0;\n\tuint32_t idc_ctrl;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tneed_reset = qla8044_need_reset(vha);\n\n\tif (!need_reset) {\n\t\told_count = qla8044_rd_direct(vha,\n\t\t    QLA8044_PEG_ALIVE_COUNTER_INDEX);\n\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tmsleep(200);\n\n\t\t\tcount = qla8044_rd_direct(vha,\n\t\t\t    QLA8044_PEG_ALIVE_COUNTER_INDEX);\n\t\t\tif (count != old_count) {\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\tgoto dev_ready;\n\t\t\t}\n\t\t}\n\t\tqla8044_flash_lock_recovery(vha);\n\t} else {\n\t\t \n\t\tif (ha->flags.isp82xx_fw_hung)\n\t\t\tqla8044_flash_lock_recovery(vha);\n\t}\n\n\t \n\tql_log(ql_log_info, vha, 0xb0b2,\n\t    \"%s: HW State: INITIALIZING\\n\", __func__);\n\tqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\n\t    QLA8XXX_DEV_INITIALIZING);\n\n\tqla8044_idc_unlock(ha);\n\trval = qla8044_start_firmware(vha);\n\tqla8044_idc_lock(ha);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_info, vha, 0xb0b3,\n\t\t     \"%s: HW State: FAILED\\n\", __func__);\n\t\tqla8044_clear_drv_active(ha);\n\t\tqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\n\t\t    QLA8XXX_DEV_FAILED);\n\t\treturn rval;\n\t}\n\n\t \n\tidc_ctrl = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\n\tif (idc_ctrl & GRACEFUL_RESET_BIT1) {\n\t\tqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL,\n\t\t    (idc_ctrl & ~GRACEFUL_RESET_BIT1));\n\t\tha->fw_dumped = false;\n\t}\n\ndev_ready:\n\tql_log(ql_log_info, vha, 0xb0b4,\n\t    \"%s: HW State: READY\\n\", __func__);\n\tqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX, QLA8XXX_DEV_READY);\n\n\treturn rval;\n}\n\n \nstatic void\nqla8044_dump_reset_seq_hdr(struct scsi_qla_host *vha)\n{\n\tu8 *phdr;\n\n\tif (!vha->reset_tmplt.buff) {\n\t\tql_log(ql_log_fatal, vha, 0xb0b5,\n\t\t    \"%s: Error Invalid reset_seq_template\\n\", __func__);\n\t\treturn;\n\t}\n\n\tphdr = vha->reset_tmplt.buff;\n\tql_dbg(ql_dbg_p3p, vha, 0xb0b6,\n\t    \"Reset Template :\\n\\t0x%X 0x%X 0x%X 0x%X\"\n\t    \"0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\\n\"\n\t    \"\\t0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\\n\\n\",\n\t    *phdr, *(phdr+1), *(phdr+2), *(phdr+3), *(phdr+4),\n\t    *(phdr+5), *(phdr+6), *(phdr+7), *(phdr + 8),\n\t    *(phdr+9), *(phdr+10), *(phdr+11), *(phdr+12),\n\t    *(phdr+13), *(phdr+14), *(phdr+15));\n}\n\n \nstatic int\nqla8044_reset_seq_checksum_test(struct scsi_qla_host *vha)\n{\n\tuint32_t sum =  0;\n\tuint16_t *buff = (uint16_t *)vha->reset_tmplt.buff;\n\tint u16_count =  vha->reset_tmplt.hdr->size / sizeof(uint16_t);\n\n\twhile (u16_count-- > 0)\n\t\tsum += *buff++;\n\n\twhile (sum >> 16)\n\t\tsum = (sum & 0xFFFF) +  (sum >> 16);\n\n\t \n\tif (~sum) {\n\t\treturn QLA_SUCCESS;\n\t} else {\n\t\tql_log(ql_log_fatal, vha, 0xb0b7,\n\t\t    \"%s: Reset seq checksum failed\\n\", __func__);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n}\n\n \nvoid\nqla8044_read_reset_template(struct scsi_qla_host *vha)\n{\n\tuint8_t *p_buff;\n\tuint32_t addr, tmplt_hdr_def_size, tmplt_hdr_size;\n\n\tvha->reset_tmplt.seq_error = 0;\n\tvha->reset_tmplt.buff = vmalloc(QLA8044_RESTART_TEMPLATE_SIZE);\n\tif (vha->reset_tmplt.buff == NULL) {\n\t\tql_log(ql_log_fatal, vha, 0xb0b8,\n\t\t    \"%s: Failed to allocate reset template resources\\n\",\n\t\t    __func__);\n\t\tgoto exit_read_reset_template;\n\t}\n\n\tp_buff = vha->reset_tmplt.buff;\n\taddr = QLA8044_RESET_TEMPLATE_ADDR;\n\n\ttmplt_hdr_def_size =\n\t    sizeof(struct qla8044_reset_template_hdr) / sizeof(uint32_t);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0b9,\n\t    \"%s: Read template hdr size %d from Flash\\n\",\n\t    __func__, tmplt_hdr_def_size);\n\n\t \n\tif (qla8044_read_flash_data(vha, p_buff, addr, tmplt_hdr_def_size)) {\n\t\tql_log(ql_log_fatal, vha, 0xb0ba,\n\t\t    \"%s: Failed to read reset template\\n\", __func__);\n\t\tgoto exit_read_template_error;\n\t}\n\n\tvha->reset_tmplt.hdr =\n\t (struct qla8044_reset_template_hdr *) vha->reset_tmplt.buff;\n\n\t \n\ttmplt_hdr_size = vha->reset_tmplt.hdr->hdr_size/sizeof(uint32_t);\n\tif ((tmplt_hdr_size != tmplt_hdr_def_size) ||\n\t    (vha->reset_tmplt.hdr->signature != RESET_TMPLT_HDR_SIGNATURE)) {\n\t\tql_log(ql_log_fatal, vha, 0xb0bb,\n\t\t    \"%s: Template Header size invalid %d \"\n\t\t    \"tmplt_hdr_def_size %d!!!\\n\", __func__,\n\t\t    tmplt_hdr_size, tmplt_hdr_def_size);\n\t\tgoto exit_read_template_error;\n\t}\n\n\taddr = QLA8044_RESET_TEMPLATE_ADDR + vha->reset_tmplt.hdr->hdr_size;\n\tp_buff = vha->reset_tmplt.buff + vha->reset_tmplt.hdr->hdr_size;\n\ttmplt_hdr_def_size = (vha->reset_tmplt.hdr->size -\n\t    vha->reset_tmplt.hdr->hdr_size)/sizeof(uint32_t);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0bc,\n\t    \"%s: Read rest of the template size %d\\n\",\n\t    __func__, vha->reset_tmplt.hdr->size);\n\n\t \n\tif (qla8044_read_flash_data(vha, p_buff, addr, tmplt_hdr_def_size)) {\n\t\tql_log(ql_log_fatal, vha, 0xb0bd,\n\t\t    \"%s: Failed to read reset template\\n\", __func__);\n\t\tgoto exit_read_template_error;\n\t}\n\n\t \n\tif (qla8044_reset_seq_checksum_test(vha)) {\n\t\tql_log(ql_log_fatal, vha, 0xb0be,\n\t\t    \"%s: Reset Seq checksum failed!\\n\", __func__);\n\t\tgoto exit_read_template_error;\n\t}\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0bf,\n\t    \"%s: Reset Seq checksum passed! Get stop, \"\n\t    \"start and init seq offsets\\n\", __func__);\n\n\t \n\tvha->reset_tmplt.init_offset = vha->reset_tmplt.buff +\n\t    vha->reset_tmplt.hdr->init_seq_offset;\n\n\tvha->reset_tmplt.start_offset = vha->reset_tmplt.buff +\n\t    vha->reset_tmplt.hdr->start_seq_offset;\n\n\tvha->reset_tmplt.stop_offset = vha->reset_tmplt.buff +\n\t    vha->reset_tmplt.hdr->hdr_size;\n\n\tqla8044_dump_reset_seq_hdr(vha);\n\n\tgoto exit_read_reset_template;\n\nexit_read_template_error:\n\tvfree(vha->reset_tmplt.buff);\n\nexit_read_reset_template:\n\treturn;\n}\n\nvoid\nqla8044_set_idc_dontreset(struct scsi_qla_host *vha)\n{\n\tuint32_t idc_ctrl;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tidc_ctrl = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\n\tidc_ctrl |= DONTRESET_BIT0;\n\tql_dbg(ql_dbg_p3p, vha, 0xb0c0,\n\t    \"%s: idc_ctrl = %d\\n\", __func__, idc_ctrl);\n\tqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL, idc_ctrl);\n}\n\nstatic inline void\nqla8044_set_rst_ready(struct scsi_qla_host *vha)\n{\n\tuint32_t drv_state;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tdrv_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\n\n\t \n\tdrv_state |= (1 << ha->portnum);\n\n\tql_log(ql_log_info, vha, 0xb0c1,\n\t    \"%s(%ld): drv_state: 0x%08x\\n\",\n\t    __func__, vha->host_no, drv_state);\n\tqla8044_wr_direct(vha, QLA8044_CRB_DRV_STATE_INDEX, drv_state);\n}\n\n \nstatic void\nqla8044_need_reset_handler(struct scsi_qla_host *vha)\n{\n\tuint32_t dev_state = 0, drv_state, drv_active;\n\tunsigned long reset_timeout;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_log(ql_log_fatal, vha, 0xb0c2,\n\t    \"%s: Performing ISP error recovery\\n\", __func__);\n\n\tif (vha->flags.online) {\n\t\tqla8044_idc_unlock(ha);\n\t\tqla2x00_abort_isp_cleanup(vha);\n\t\tha->isp_ops->get_flash_version(vha, vha->req->ring);\n\t\tha->isp_ops->nvram_config(vha);\n\t\tqla8044_idc_lock(ha);\n\t}\n\n\tdev_state = qla8044_rd_direct(vha,\n\t    QLA8044_CRB_DEV_STATE_INDEX);\n\tdrv_state = qla8044_rd_direct(vha,\n\t    QLA8044_CRB_DRV_STATE_INDEX);\n\tdrv_active = qla8044_rd_direct(vha,\n\t    QLA8044_CRB_DRV_ACTIVE_INDEX);\n\n\tql_log(ql_log_info, vha, 0xb0c5,\n\t    \"%s(%ld): drv_state = 0x%x, drv_active = 0x%x dev_state = 0x%x\\n\",\n\t    __func__, vha->host_no, drv_state, drv_active, dev_state);\n\n\tqla8044_set_rst_ready(vha);\n\n\t \n\treset_timeout = jiffies + (ha->fcoe_reset_timeout * HZ);\n\n\tdo {\n\t\tif (time_after_eq(jiffies, reset_timeout)) {\n\t\t\tql_log(ql_log_info, vha, 0xb0c4,\n\t\t\t    \"%s: Function %d: Reset Ack Timeout!, drv_state: 0x%08x, drv_active: 0x%08x\\n\",\n\t\t\t    __func__, ha->portnum, drv_state, drv_active);\n\t\t\tbreak;\n\t\t}\n\n\t\tqla8044_idc_unlock(ha);\n\t\tmsleep(1000);\n\t\tqla8044_idc_lock(ha);\n\n\t\tdev_state = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DEV_STATE_INDEX);\n\t\tdrv_state = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DRV_STATE_INDEX);\n\t\tdrv_active = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DRV_ACTIVE_INDEX);\n\t} while (((drv_state & drv_active) != drv_active) &&\n\t    (dev_state == QLA8XXX_DEV_NEED_RESET));\n\n\t \n\tif (drv_state != drv_active) {\n\t\tql_log(ql_log_info, vha, 0xb0c7,\n\t\t    \"%s(%ld): Function %d turning off drv_active of non-acking function 0x%x\\n\",\n\t\t    __func__, vha->host_no, ha->portnum,\n\t\t    (drv_active ^ drv_state));\n\t\tdrv_active = drv_active & drv_state;\n\t\tqla8044_wr_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX,\n\t\t    drv_active);\n\t} else {\n\t\t \n\t\tif ((ha->flags.nic_core_reset_owner) &&\n\t\t    (dev_state == QLA8XXX_DEV_NEED_RESET)) {\n\t\t\tha->flags.nic_core_reset_owner = 0;\n\t\t\tqla8044_device_bootstrap(vha);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (!(drv_active & (1 << ha->portnum))) {\n\t\tha->flags.nic_core_reset_owner = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (ha->flags.nic_core_reset_owner ||\n\t    ((drv_state & drv_active) == QLA8044_FUN7_ACTIVE_INDEX)) {\n\t\tha->flags.nic_core_reset_owner = 0;\n\t\tqla8044_device_bootstrap(vha);\n\t}\n}\n\nstatic void\nqla8044_set_drv_active(struct scsi_qla_host *vha)\n{\n\tuint32_t drv_active;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tdrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\n\n\t \n\tdrv_active |= (1 << ha->portnum);\n\n\tql_log(ql_log_info, vha, 0xb0c8,\n\t    \"%s(%ld): drv_active: 0x%08x\\n\",\n\t    __func__, vha->host_no, drv_active);\n\tqla8044_wr_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX, drv_active);\n}\n\nstatic int\nqla8044_check_drv_active(struct scsi_qla_host *vha)\n{\n\tuint32_t drv_active;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tdrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\n\tif (drv_active & (1 << ha->portnum))\n\t\treturn QLA_SUCCESS;\n\telse\n\t\treturn QLA_TEST_FAILED;\n}\n\nstatic void\nqla8044_clear_idc_dontreset(struct scsi_qla_host *vha)\n{\n\tuint32_t idc_ctrl;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tidc_ctrl = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\n\tidc_ctrl &= ~DONTRESET_BIT0;\n\tql_log(ql_log_info, vha, 0xb0c9,\n\t    \"%s: idc_ctrl = %d\\n\", __func__,\n\t    idc_ctrl);\n\tqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL, idc_ctrl);\n}\n\nstatic int\nqla8044_set_idc_ver(struct scsi_qla_host *vha)\n{\n\tint idc_ver;\n\tuint32_t drv_active;\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tdrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\n\tif (drv_active == (1 << ha->portnum)) {\n\t\tidc_ver = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DRV_IDC_VERSION_INDEX);\n\t\tidc_ver &= (~0xFF);\n\t\tidc_ver |= QLA8044_IDC_VER_MAJ_VALUE;\n\t\tqla8044_wr_direct(vha, QLA8044_CRB_DRV_IDC_VERSION_INDEX,\n\t\t    idc_ver);\n\t\tql_log(ql_log_info, vha, 0xb0ca,\n\t\t    \"%s: IDC version updated to %d\\n\",\n\t\t    __func__, idc_ver);\n\t} else {\n\t\tidc_ver = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DRV_IDC_VERSION_INDEX);\n\t\tidc_ver &= 0xFF;\n\t\tif (QLA8044_IDC_VER_MAJ_VALUE != idc_ver) {\n\t\t\tql_log(ql_log_info, vha, 0xb0cb,\n\t\t\t    \"%s: qla4xxx driver IDC version %d \"\n\t\t\t    \"is not compatible with IDC version %d \"\n\t\t\t    \"of other drivers!\\n\",\n\t\t\t    __func__, QLA8044_IDC_VER_MAJ_VALUE,\n\t\t\t    idc_ver);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tgoto exit_set_idc_ver;\n\t\t}\n\t}\n\n\t \n\tidc_ver = qla8044_rd_reg(ha, QLA8044_CRB_IDC_VER_MINOR);\n\tidc_ver &= ~(0x03 << (ha->portnum * 2));\n\tidc_ver |= (QLA8044_IDC_VER_MIN_VALUE << (ha->portnum * 2));\n\tqla8044_wr_reg(ha, QLA8044_CRB_IDC_VER_MINOR, idc_ver);\n\nexit_set_idc_ver:\n\treturn rval;\n}\n\nstatic int\nqla8044_update_idc_reg(struct scsi_qla_host *vha)\n{\n\tuint32_t drv_active;\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (vha->flags.init_done)\n\t\tgoto exit_update_idc_reg;\n\n\tqla8044_idc_lock(ha);\n\tqla8044_set_drv_active(vha);\n\n\tdrv_active = qla8044_rd_direct(vha,\n\t    QLA8044_CRB_DRV_ACTIVE_INDEX);\n\n\t \n\tif ((drv_active == (1 << ha->portnum)) && !ql2xdontresethba)\n\t\tqla8044_clear_idc_dontreset(vha);\n\n\trval = qla8044_set_idc_ver(vha);\n\tif (rval == QLA_FUNCTION_FAILED)\n\t\tqla8044_clear_drv_active(ha);\n\tqla8044_idc_unlock(ha);\n\nexit_update_idc_reg:\n\treturn rval;\n}\n\n \nstatic void\nqla8044_need_qsnt_handler(struct scsi_qla_host *vha)\n{\n\tunsigned long qsnt_timeout;\n\tuint32_t drv_state, drv_active, dev_state;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (vha->flags.online)\n\t\tqla2x00_quiesce_io(vha);\n\telse\n\t\treturn;\n\n\tqla8044_set_qsnt_ready(vha);\n\n\t \n\tqsnt_timeout = jiffies + (QSNT_ACK_TOV * HZ);\n\tdrv_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\n\tdrv_active = qla8044_rd_direct(vha, QLA8044_CRB_DRV_ACTIVE_INDEX);\n\n\t \n\tdrv_active = drv_active << 1;\n\n\twhile (drv_state != drv_active) {\n\t\tif (time_after_eq(jiffies, qsnt_timeout)) {\n\t\t\t \n\t\t\tclear_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags);\n\t\t\tqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\n\t\t\t\t\t    QLA8XXX_DEV_READY);\n\t\t\tqla8044_clear_qsnt_ready(vha);\n\t\t\tql_log(ql_log_info, vha, 0xb0cc,\n\t\t\t    \"Timeout waiting for quiescent ack!!!\\n\");\n\t\t\treturn;\n\t\t}\n\t\tqla8044_idc_unlock(ha);\n\t\tmsleep(1000);\n\t\tqla8044_idc_lock(ha);\n\n\t\tdrv_state = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DRV_STATE_INDEX);\n\t\tdrv_active = qla8044_rd_direct(vha,\n\t\t    QLA8044_CRB_DRV_ACTIVE_INDEX);\n\t\tdrv_active = drv_active << 1;\n\t}\n\n\t \n\tdev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\n\n\tif (dev_state == QLA8XXX_DEV_NEED_QUIESCENT) {\n\t\tqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\n\t\t    QLA8XXX_DEV_QUIESCENT);\n\t\tql_log(ql_log_info, vha, 0xb0cd,\n\t\t    \"%s: HW State: QUIESCENT\\n\", __func__);\n\t}\n}\n\n \nint\nqla8044_device_state_handler(struct scsi_qla_host *vha)\n{\n\tuint32_t dev_state;\n\tint rval = QLA_SUCCESS;\n\tunsigned long dev_init_timeout;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\trval = qla8044_update_idc_reg(vha);\n\tif (rval == QLA_FUNCTION_FAILED)\n\t\tgoto exit_error;\n\n\tdev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\n\tql_dbg(ql_dbg_p3p, vha, 0xb0ce,\n\t    \"Device state is 0x%x = %s\\n\",\n\t    dev_state, qdev_state(dev_state));\n\n\t \n\tdev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout * HZ);\n\n\tqla8044_idc_lock(ha);\n\n\twhile (1) {\n\t\tif (time_after_eq(jiffies, dev_init_timeout)) {\n\t\t\tif (qla8044_check_drv_active(vha) == QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xb0cf,\n\t\t\t\t    \"%s: Device Init Failed 0x%x = %s\\n\",\n\t\t\t\t    QLA2XXX_DRIVER_NAME, dev_state,\n\t\t\t\t    qdev_state(dev_state));\n\t\t\t\tqla8044_wr_direct(vha,\n\t\t\t\t    QLA8044_CRB_DEV_STATE_INDEX,\n\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\t}\n\t\t}\n\n\t\tdev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\n\t\tql_log(ql_log_info, vha, 0xb0d0,\n\t\t    \"Device state is 0x%x = %s\\n\",\n\t\t    dev_state, qdev_state(dev_state));\n\n\t\t \n\t\tswitch (dev_state) {\n\t\tcase QLA8XXX_DEV_READY:\n\t\t\tha->flags.nic_core_reset_owner = 0;\n\t\t\tgoto exit;\n\t\tcase QLA8XXX_DEV_COLD:\n\t\t\trval = qla8044_device_bootstrap(vha);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_INITIALIZING:\n\t\t\tqla8044_idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tqla8044_idc_lock(ha);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_NEED_RESET:\n\t\t\t \n\t\t\tqla8044_need_reset_handler(vha);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_NEED_QUIESCENT:\n\t\t\t \n\t\t\tqla8044_need_qsnt_handler(vha);\n\n\t\t\t \n\t\t\tdev_init_timeout = jiffies +\n\t\t\t    (ha->fcoe_reset_timeout * HZ);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_QUIESCENT:\n\t\t\tql_log(ql_log_info, vha, 0xb0d1,\n\t\t\t    \"HW State: QUIESCENT\\n\");\n\n\t\t\tqla8044_idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tqla8044_idc_lock(ha);\n\n\t\t\t \n\t\t\tdev_init_timeout = jiffies +\n\t\t\t    (ha->fcoe_reset_timeout * HZ);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_FAILED:\n\t\t\tha->flags.nic_core_reset_owner = 0;\n\t\t\tqla8044_idc_unlock(ha);\n\t\t\tqla8xxx_dev_failed_handler(vha);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tqla8044_idc_lock(ha);\n\t\t\tgoto exit;\n\t\tdefault:\n\t\t\tqla8044_idc_unlock(ha);\n\t\t\tqla8xxx_dev_failed_handler(vha);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tqla8044_idc_lock(ha);\n\t\t\tgoto exit;\n\t\t}\n\t}\nexit:\n\tqla8044_idc_unlock(ha);\n\nexit_error:\n\treturn rval;\n}\n\n \nstatic int\nqla8044_check_temp(struct scsi_qla_host *vha)\n{\n\tuint32_t temp, temp_state, temp_val;\n\tint status = QLA_SUCCESS;\n\n\ttemp = qla8044_rd_direct(vha, QLA8044_CRB_TEMP_STATE_INDEX);\n\ttemp_state = qla82xx_get_temp_state(temp);\n\ttemp_val = qla82xx_get_temp_val(temp);\n\n\tif (temp_state == QLA82XX_TEMP_PANIC) {\n\t\tql_log(ql_log_warn, vha, 0xb0d2,\n\t\t    \"Device temperature %d degrees C\"\n\t\t    \" exceeds maximum allowed. Hardware has been shut\"\n\t\t    \" down\\n\", temp_val);\n\t\tstatus = QLA_FUNCTION_FAILED;\n\t\treturn status;\n\t} else if (temp_state == QLA82XX_TEMP_WARN) {\n\t\tql_log(ql_log_warn, vha, 0xb0d3,\n\t\t    \"Device temperature %d\"\n\t\t    \" degrees C exceeds operating range.\"\n\t\t    \" Immediate action needed.\\n\", temp_val);\n\t}\n\treturn 0;\n}\n\nint qla8044_read_temperature(scsi_qla_host_t *vha)\n{\n\tuint32_t temp;\n\n\ttemp = qla8044_rd_direct(vha, QLA8044_CRB_TEMP_STATE_INDEX);\n\treturn qla82xx_get_temp_val(temp);\n}\n\n \nint\nqla8044_check_fw_alive(struct scsi_qla_host *vha)\n{\n\tuint32_t fw_heartbeat_counter;\n\tuint32_t halt_status1, halt_status2;\n\tint status = QLA_SUCCESS;\n\n\tfw_heartbeat_counter = qla8044_rd_direct(vha,\n\t    QLA8044_PEG_ALIVE_COUNTER_INDEX);\n\n\t \n\tif (fw_heartbeat_counter == 0xffffffff) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb0d4,\n\t\t    \"scsi%ld: %s: Device in frozen \"\n\t\t    \"state, QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\\n\",\n\t\t    vha->host_no, __func__);\n\t\treturn status;\n\t}\n\n\tif (vha->fw_heartbeat_counter == fw_heartbeat_counter) {\n\t\tvha->seconds_since_last_heartbeat++;\n\t\t \n\t\tif (vha->seconds_since_last_heartbeat == 2) {\n\t\t\tvha->seconds_since_last_heartbeat = 0;\n\t\t\thalt_status1 = qla8044_rd_direct(vha,\n\t\t\t    QLA8044_PEG_HALT_STATUS1_INDEX);\n\t\t\thalt_status2 = qla8044_rd_direct(vha,\n\t\t\t    QLA8044_PEG_HALT_STATUS2_INDEX);\n\n\t\t\tql_log(ql_log_info, vha, 0xb0d5,\n\t\t\t    \"scsi(%ld): %s, ISP8044 \"\n\t\t\t    \"Dumping hw/fw registers:\\n\"\n\t\t\t    \" PEG_HALT_STATUS1: 0x%x, \"\n\t\t\t    \"PEG_HALT_STATUS2: 0x%x,\\n\",\n\t\t\t    vha->host_no, __func__, halt_status1,\n\t\t\t    halt_status2);\n\t\t\tstatus = QLA_FUNCTION_FAILED;\n\t\t}\n\t} else\n\t\tvha->seconds_since_last_heartbeat = 0;\n\n\tvha->fw_heartbeat_counter = fw_heartbeat_counter;\n\treturn status;\n}\n\nvoid\nqla8044_watchdog(struct scsi_qla_host *vha)\n{\n\tuint32_t dev_state, halt_status;\n\tint halt_status_unrecoverable = 0;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (!(test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) ||\n\t    test_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags))) {\n\t\tdev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\n\n\t\tif (qla8044_check_fw_alive(vha)) {\n\t\t\tha->flags.isp82xx_fw_hung = 1;\n\t\t\tql_log(ql_log_warn, vha, 0xb10a,\n\t\t\t    \"Firmware hung.\\n\");\n\t\t\tqla82xx_clear_pending_mbx(vha);\n\t\t}\n\n\t\tif (qla8044_check_temp(vha)) {\n\t\t\tset_bit(ISP_UNRECOVERABLE, &vha->dpc_flags);\n\t\t\tha->flags.isp82xx_fw_hung = 1;\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t} else if (dev_state == QLA8XXX_DEV_NEED_RESET &&\n\t\t\t   !test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags)) {\n\t\t\tql_log(ql_log_info, vha, 0xb0d6,\n\t\t\t    \"%s: HW State: NEED RESET!\\n\",\n\t\t\t    __func__);\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t} else if (dev_state == QLA8XXX_DEV_NEED_QUIESCENT &&\n\t\t    !test_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags)) {\n\t\t\tql_log(ql_log_info, vha, 0xb0d7,\n\t\t\t    \"%s: HW State: NEED QUIES detected!\\n\",\n\t\t\t    __func__);\n\t\t\tset_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t} else  {\n\t\t\t \n\t\t\tif (ha->flags.isp82xx_fw_hung) {\n\t\t\t\thalt_status = qla8044_rd_direct(vha,\n\t\t\t\t\tQLA8044_PEG_HALT_STATUS1_INDEX);\n\t\t\t\tif (halt_status &\n\t\t\t\t    QLA8044_HALT_STATUS_FW_RESET) {\n\t\t\t\t\tql_log(ql_log_fatal, vha,\n\t\t\t\t\t    0xb0d8, \"%s: Firmware \"\n\t\t\t\t\t    \"error detected device \"\n\t\t\t\t\t    \"is being reset\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t} else if (halt_status &\n\t\t\t\t\t    QLA8044_HALT_STATUS_UNRECOVERABLE) {\n\t\t\t\t\t\thalt_status_unrecoverable = 1;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (halt_status_unrecoverable) {\n\t\t\t\t\tset_bit(ISP_UNRECOVERABLE,\n\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t} else {\n\t\t\t\t\tif (dev_state ==\n\t\t\t\t\t    QLA8XXX_DEV_QUIESCENT) {\n\t\t\t\t\t\tset_bit(FCOE_CTX_RESET_NEEDED,\n\t\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\t\tql_log(ql_log_info, vha, 0xb0d9,\n\t\t\t\t\t\t    \"%s: FW CONTEXT Reset \"\n\t\t\t\t\t\t    \"needed!\\n\", __func__);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tql_log(ql_log_info, vha,\n\t\t\t\t\t\t    0xb0da, \"%s: \"\n\t\t\t\t\t\t    \"detect abort needed\\n\",\n\t\t\t\t\t\t    __func__);\n\t\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nstatic int\nqla8044_minidump_process_control(struct scsi_qla_host *vha,\n\t\t\t\t struct qla8044_minidump_entry_hdr *entry_hdr)\n{\n\tstruct qla8044_minidump_entry_crb *crb_entry;\n\tuint32_t read_value, opcode, poll_time, addr, index;\n\tuint32_t crb_addr, rval = QLA_SUCCESS;\n\tunsigned long wtime;\n\tstruct qla8044_minidump_template_hdr *tmplt_hdr;\n\tint i;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0dd, \"Entering fn: %s\\n\", __func__);\n\ttmplt_hdr = (struct qla8044_minidump_template_hdr *)\n\t\tha->md_tmplt_hdr;\n\tcrb_entry = (struct qla8044_minidump_entry_crb *)entry_hdr;\n\n\tcrb_addr = crb_entry->addr;\n\tfor (i = 0; i < crb_entry->op_count; i++) {\n\t\topcode = crb_entry->crb_ctrl.opcode;\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_WR) {\n\t\t\tqla8044_wr_reg_indirect(vha, crb_addr,\n\t\t\t    crb_entry->value_1);\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_RW) {\n\t\t\tqla8044_rd_reg_indirect(vha, crb_addr, &read_value);\n\t\t\tqla8044_wr_reg_indirect(vha, crb_addr, read_value);\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_AND) {\n\t\t\tqla8044_rd_reg_indirect(vha, crb_addr, &read_value);\n\t\t\tread_value &= crb_entry->value_2;\n\t\t\tif (opcode & QLA82XX_DBG_OPCODE_OR) {\n\t\t\t\tread_value |= crb_entry->value_3;\n\t\t\t\topcode &= ~QLA82XX_DBG_OPCODE_OR;\n\t\t\t}\n\t\t\tqla8044_wr_reg_indirect(vha, crb_addr, read_value);\n\t\t}\n\t\tif (opcode & QLA82XX_DBG_OPCODE_OR) {\n\t\t\tqla8044_rd_reg_indirect(vha, crb_addr, &read_value);\n\t\t\tread_value |= crb_entry->value_3;\n\t\t\tqla8044_wr_reg_indirect(vha, crb_addr, read_value);\n\t\t}\n\t\tif (opcode & QLA82XX_DBG_OPCODE_POLL) {\n\t\t\tpoll_time = crb_entry->crb_strd.poll_timeout;\n\t\t\twtime = jiffies + poll_time;\n\t\t\tqla8044_rd_reg_indirect(vha, crb_addr, &read_value);\n\n\t\t\tdo {\n\t\t\t\tif ((read_value & crb_entry->value_2) ==\n\t\t\t\t    crb_entry->value_1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (time_after_eq(jiffies, wtime)) {\n\t\t\t\t\t \n\t\t\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tqla8044_rd_reg_indirect(vha,\n\t\t\t\t\t    crb_addr, &read_value);\n\t\t\t\t}\n\t\t\t} while (1);\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_RDSTATE) {\n\t\t\tif (crb_entry->crb_strd.state_index_a) {\n\t\t\t\tindex = crb_entry->crb_strd.state_index_a;\n\t\t\t\taddr = tmplt_hdr->saved_state_array[index];\n\t\t\t} else {\n\t\t\t\taddr = crb_addr;\n\t\t\t}\n\n\t\t\tqla8044_rd_reg_indirect(vha, addr, &read_value);\n\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\ttmplt_hdr->saved_state_array[index] = read_value;\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_WRSTATE) {\n\t\t\tif (crb_entry->crb_strd.state_index_a) {\n\t\t\t\tindex = crb_entry->crb_strd.state_index_a;\n\t\t\t\taddr = tmplt_hdr->saved_state_array[index];\n\t\t\t} else {\n\t\t\t\taddr = crb_addr;\n\t\t\t}\n\n\t\t\tif (crb_entry->crb_ctrl.state_index_v) {\n\t\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\t\tread_value =\n\t\t\t\t    tmplt_hdr->saved_state_array[index];\n\t\t\t} else {\n\t\t\t\tread_value = crb_entry->value_1;\n\t\t\t}\n\n\t\t\tqla8044_wr_reg_indirect(vha, addr, read_value);\n\t\t}\n\n\t\tif (opcode & QLA82XX_DBG_OPCODE_MDSTATE) {\n\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\tread_value = tmplt_hdr->saved_state_array[index];\n\t\t\tread_value <<= crb_entry->crb_ctrl.shl;\n\t\t\tread_value >>= crb_entry->crb_ctrl.shr;\n\t\t\tif (crb_entry->value_2)\n\t\t\t\tread_value &= crb_entry->value_2;\n\t\t\tread_value |= crb_entry->value_3;\n\t\t\tread_value += crb_entry->value_1;\n\t\t\ttmplt_hdr->saved_state_array[index] = read_value;\n\t\t}\n\t\tcrb_addr += crb_entry->crb_strd.addr_stride;\n\t}\n\treturn rval;\n}\n\nstatic void\nqla8044_minidump_process_rdcrb(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tuint32_t r_addr, r_stride, loop_cnt, i, r_value;\n\tstruct qla8044_minidump_entry_crb *crb_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0de, \"Entering fn: %s\\n\", __func__);\n\tcrb_hdr = (struct qla8044_minidump_entry_crb *)entry_hdr;\n\tr_addr = crb_hdr->addr;\n\tr_stride = crb_hdr->crb_strd.addr_stride;\n\tloop_cnt = crb_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tqla8044_rd_reg_indirect(vha, r_addr, &r_value);\n\t\t*data_ptr++ = r_addr;\n\t\t*data_ptr++ = r_value;\n\t\tr_addr += r_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic int\nqla8044_minidump_process_rdmem(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tuint32_t r_addr, r_value, r_data;\n\tuint32_t i, j, loop_cnt;\n\tstruct qla8044_minidump_entry_rdmem *m_hdr;\n\tunsigned long flags;\n\tuint32_t *data_ptr = *d_ptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0df, \"Entering fn: %s\\n\", __func__);\n\tm_hdr = (struct qla8044_minidump_entry_rdmem *)entry_hdr;\n\tr_addr = m_hdr->read_addr;\n\tloop_cnt = m_hdr->read_data_size/16;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0f0,\n\t    \"[%s]: Read addr: 0x%x, read_data_size: 0x%x\\n\",\n\t    __func__, r_addr, m_hdr->read_data_size);\n\n\tif (r_addr & 0xf) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb0f1,\n\t\t    \"[%s]: Read addr 0x%x not 16 bytes aligned\\n\",\n\t\t    __func__, r_addr);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tif (m_hdr->read_data_size % 16) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb0f2,\n\t\t    \"[%s]: Read data[0x%x] not multiple of 16 bytes\\n\",\n\t\t    __func__, m_hdr->read_data_size);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0f3,\n\t    \"[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\\n\",\n\t    __func__, r_addr, m_hdr->read_data_size, loop_cnt);\n\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tqla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_ADDR_LO, r_addr);\n\t\tr_value = 0;\n\t\tqla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_ADDR_HI, r_value);\n\t\tr_value = MIU_TA_CTL_ENABLE;\n\t\tqla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL, r_value);\n\t\tr_value = MIU_TA_CTL_START_ENABLE;\n\t\tqla8044_wr_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL, r_value);\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\tqla8044_rd_reg_indirect(vha, MD_MIU_TEST_AGT_CTRL,\n\t\t\t    &r_value);\n\t\t\tif ((r_value & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tqla8044_rd_reg_indirect(vha, MD_MIU_TEST_AGT_RDDATA[j],\n\t\t\t    &r_data);\n\t\t\t*data_ptr++ = r_data;\n\t\t}\n\n\t\tr_addr += 16;\n\t}\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0f4,\n\t    \"Leaving fn: %s datacount: 0x%x\\n\",\n\t     __func__, (loop_cnt * 16));\n\n\t*d_ptr = data_ptr;\n\treturn QLA_SUCCESS;\n}\n\n \nstatic uint32_t\nqla8044_minidump_process_rdrom(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tuint32_t fl_addr, u32_count, rval;\n\tstruct qla8044_minidump_entry_rdrom *rom_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\trom_hdr = (struct qla8044_minidump_entry_rdrom *)entry_hdr;\n\tfl_addr = rom_hdr->read_addr;\n\tu32_count = (rom_hdr->read_data_size)/sizeof(uint32_t);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0f5, \"[%s]: fl_addr: 0x%x, count: 0x%x\\n\",\n\t    __func__, fl_addr, u32_count);\n\n\trval = qla8044_lockless_flash_read_u32(vha, fl_addr,\n\t    (u8 *)(data_ptr), u32_count);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, vha, 0xb0f6,\n\t\t    \"%s: Flash Read Error,Count=%d\\n\", __func__, u32_count);\n\t\treturn QLA_FUNCTION_FAILED;\n\t} else {\n\t\tdata_ptr += u32_count;\n\t\t*d_ptr = data_ptr;\n\t\treturn QLA_SUCCESS;\n\t}\n}\n\nstatic void\nqla8044_mark_entry_skipped(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, int index)\n{\n\tentry_hdr->d_ctrl.driver_flags |= QLA82XX_DBG_SKIPPED_FLAG;\n\n\tql_log(ql_log_info, vha, 0xb0f7,\n\t    \"scsi(%ld): Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\\n\",\n\t    vha->host_no, index, entry_hdr->entry_type,\n\t    entry_hdr->d_ctrl.entry_capture_mask);\n}\n\nstatic int\nqla8044_minidump_process_l2tag(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr,\n\t\t\t\t uint32_t **d_ptr)\n{\n\tuint32_t addr, r_addr, c_addr, t_r_addr;\n\tuint32_t i, k, loop_count, t_value, r_cnt, r_value;\n\tunsigned long p_wait, w_time, p_mask;\n\tuint32_t c_value_w, c_value_r;\n\tstruct qla8044_minidump_entry_cache *cache_hdr;\n\tint rval = QLA_FUNCTION_FAILED;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0f8, \"Entering fn: %s\\n\", __func__);\n\tcache_hdr = (struct qla8044_minidump_entry_cache *)entry_hdr;\n\n\tloop_count = cache_hdr->op_count;\n\tr_addr = cache_hdr->read_addr;\n\tc_addr = cache_hdr->control_addr;\n\tc_value_w = cache_hdr->cache_ctrl.write_value;\n\n\tt_r_addr = cache_hdr->tag_reg_addr;\n\tt_value = cache_hdr->addr_ctrl.init_tag_value;\n\tr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\n\tp_wait = cache_hdr->cache_ctrl.poll_wait;\n\tp_mask = cache_hdr->cache_ctrl.poll_mask;\n\n\tfor (i = 0; i < loop_count; i++) {\n\t\tqla8044_wr_reg_indirect(vha, t_r_addr, t_value);\n\t\tif (c_value_w)\n\t\t\tqla8044_wr_reg_indirect(vha, c_addr, c_value_w);\n\n\t\tif (p_mask) {\n\t\t\tw_time = jiffies + p_wait;\n\t\t\tdo {\n\t\t\t\tqla8044_rd_reg_indirect(vha, c_addr,\n\t\t\t\t    &c_value_r);\n\t\t\t\tif ((c_value_r & p_mask) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (time_after_eq(jiffies, w_time)) {\n\t\t\t\t\t \n\t\t\t\t\treturn rval;\n\t\t\t\t}\n\t\t\t} while (1);\n\t\t}\n\n\t\taddr = r_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tqla8044_rd_reg_indirect(vha, addr, &r_value);\n\t\t\t*data_ptr++ = r_value;\n\t\t\taddr += cache_hdr->read_ctrl.read_addr_stride;\n\t\t}\n\t\tt_value += cache_hdr->addr_ctrl.tag_value_stride;\n\t}\n\t*d_ptr = data_ptr;\n\treturn QLA_SUCCESS;\n}\n\nstatic void\nqla8044_minidump_process_l1cache(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tuint32_t addr, r_addr, c_addr, t_r_addr;\n\tuint32_t i, k, loop_count, t_value, r_cnt, r_value;\n\tuint32_t c_value_w;\n\tstruct qla8044_minidump_entry_cache *cache_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tcache_hdr = (struct qla8044_minidump_entry_cache *)entry_hdr;\n\tloop_count = cache_hdr->op_count;\n\tr_addr = cache_hdr->read_addr;\n\tc_addr = cache_hdr->control_addr;\n\tc_value_w = cache_hdr->cache_ctrl.write_value;\n\n\tt_r_addr = cache_hdr->tag_reg_addr;\n\tt_value = cache_hdr->addr_ctrl.init_tag_value;\n\tr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\n\n\tfor (i = 0; i < loop_count; i++) {\n\t\tqla8044_wr_reg_indirect(vha, t_r_addr, t_value);\n\t\tqla8044_wr_reg_indirect(vha, c_addr, c_value_w);\n\t\taddr = r_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tqla8044_rd_reg_indirect(vha, addr, &r_value);\n\t\t\t*data_ptr++ = r_value;\n\t\t\taddr += cache_hdr->read_ctrl.read_addr_stride;\n\t\t}\n\t\tt_value += cache_hdr->addr_ctrl.tag_value_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic void\nqla8044_minidump_process_rdocm(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tuint32_t r_addr, r_stride, loop_cnt, i, r_value;\n\tstruct qla8044_minidump_entry_rdocm *ocm_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0f9, \"Entering fn: %s\\n\", __func__);\n\n\tocm_hdr = (struct qla8044_minidump_entry_rdocm *)entry_hdr;\n\tr_addr = ocm_hdr->read_addr;\n\tr_stride = ocm_hdr->read_addr_stride;\n\tloop_cnt = ocm_hdr->op_count;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0fa,\n\t    \"[%s]: r_addr: 0x%x, r_stride: 0x%x, loop_cnt: 0x%x\\n\",\n\t    __func__, r_addr, r_stride, loop_cnt);\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tr_value = readl((void __iomem *)(r_addr + ha->nx_pcibase));\n\t\t*data_ptr++ = r_value;\n\t\tr_addr += r_stride;\n\t}\n\tql_dbg(ql_dbg_p3p, vha, 0xb0fb, \"Leaving fn: %s datacount: 0x%lx\\n\",\n\t    __func__, (long unsigned int) (loop_cnt * sizeof(uint32_t)));\n\n\t*d_ptr = data_ptr;\n}\n\nstatic void\nqla8044_minidump_process_rdmux(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr,\n\tuint32_t **d_ptr)\n{\n\tuint32_t r_addr, s_stride, s_addr, s_value, loop_cnt, i, r_value = 0;\n\tstruct qla8044_minidump_entry_mux *mux_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0fc, \"Entering fn: %s\\n\", __func__);\n\n\tmux_hdr = (struct qla8044_minidump_entry_mux *)entry_hdr;\n\tr_addr = mux_hdr->read_addr;\n\ts_addr = mux_hdr->select_addr;\n\ts_stride = mux_hdr->select_value_stride;\n\ts_value = mux_hdr->select_value;\n\tloop_cnt = mux_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tqla8044_wr_reg_indirect(vha, s_addr, s_value);\n\t\tqla8044_rd_reg_indirect(vha, r_addr, &r_value);\n\t\t*data_ptr++ = s_value;\n\t\t*data_ptr++ = r_value;\n\t\ts_value += s_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic void\nqla8044_minidump_process_queue(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr,\n\tuint32_t **d_ptr)\n{\n\tuint32_t s_addr, r_addr;\n\tuint32_t r_stride, r_value, r_cnt, qid = 0;\n\tuint32_t i, k, loop_cnt;\n\tstruct qla8044_minidump_entry_queue *q_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb0fd, \"Entering fn: %s\\n\", __func__);\n\tq_hdr = (struct qla8044_minidump_entry_queue *)entry_hdr;\n\ts_addr = q_hdr->select_addr;\n\tr_cnt = q_hdr->rd_strd.read_addr_cnt;\n\tr_stride = q_hdr->rd_strd.read_addr_stride;\n\tloop_cnt = q_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tqla8044_wr_reg_indirect(vha, s_addr, qid);\n\t\tr_addr = q_hdr->read_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tqla8044_rd_reg_indirect(vha, r_addr, &r_value);\n\t\t\t*data_ptr++ = r_value;\n\t\t\tr_addr += r_stride;\n\t\t}\n\t\tqid += q_hdr->q_strd.queue_id_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\n \nstatic uint32_t\nqla8044_minidump_process_pollrd(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr,\n\tuint32_t **d_ptr)\n{\n\tuint32_t r_addr, s_addr, s_value, r_value, poll_wait, poll_mask;\n\tuint16_t s_stride, i;\n\tstruct qla8044_minidump_entry_pollrd *pollrd_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tpollrd_hdr = (struct qla8044_minidump_entry_pollrd *) entry_hdr;\n\ts_addr = pollrd_hdr->select_addr;\n\tr_addr = pollrd_hdr->read_addr;\n\ts_value = pollrd_hdr->select_value;\n\ts_stride = pollrd_hdr->select_value_stride;\n\n\tpoll_wait = pollrd_hdr->poll_wait;\n\tpoll_mask = pollrd_hdr->poll_mask;\n\n\tfor (i = 0; i < pollrd_hdr->op_count; i++) {\n\t\tqla8044_wr_reg_indirect(vha, s_addr, s_value);\n\t\tpoll_wait = pollrd_hdr->poll_wait;\n\t\twhile (1) {\n\t\t\tqla8044_rd_reg_indirect(vha, s_addr, &r_value);\n\t\t\tif ((r_value & poll_mask) != 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tusleep_range(1000, 1100);\n\t\t\t\tif (--poll_wait == 0) {\n\t\t\t\t\tql_log(ql_log_fatal, vha, 0xb0fe,\n\t\t\t\t\t    \"%s: TIMEOUT\\n\", __func__);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqla8044_rd_reg_indirect(vha, r_addr, &r_value);\n\t\t*data_ptr++ = s_value;\n\t\t*data_ptr++ = r_value;\n\n\t\ts_value += s_stride;\n\t}\n\t*d_ptr = data_ptr;\n\treturn QLA_SUCCESS;\n\nerror:\n\treturn QLA_FUNCTION_FAILED;\n}\n\nstatic void\nqla8044_minidump_process_rdmux2(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tuint32_t sel_val1, sel_val2, t_sel_val, data, i;\n\tuint32_t sel_addr1, sel_addr2, sel_val_mask, read_addr;\n\tstruct qla8044_minidump_entry_rdmux2 *rdmux2_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\trdmux2_hdr = (struct qla8044_minidump_entry_rdmux2 *) entry_hdr;\n\tsel_val1 = rdmux2_hdr->select_value_1;\n\tsel_val2 = rdmux2_hdr->select_value_2;\n\tsel_addr1 = rdmux2_hdr->select_addr_1;\n\tsel_addr2 = rdmux2_hdr->select_addr_2;\n\tsel_val_mask = rdmux2_hdr->select_value_mask;\n\tread_addr = rdmux2_hdr->read_addr;\n\n\tfor (i = 0; i < rdmux2_hdr->op_count; i++) {\n\t\tqla8044_wr_reg_indirect(vha, sel_addr1, sel_val1);\n\t\tt_sel_val = sel_val1 & sel_val_mask;\n\t\t*data_ptr++ = t_sel_val;\n\n\t\tqla8044_wr_reg_indirect(vha, sel_addr2, t_sel_val);\n\t\tqla8044_rd_reg_indirect(vha, read_addr, &data);\n\n\t\t*data_ptr++ = data;\n\n\t\tqla8044_wr_reg_indirect(vha, sel_addr1, sel_val2);\n\t\tt_sel_val = sel_val2 & sel_val_mask;\n\t\t*data_ptr++ = t_sel_val;\n\n\t\tqla8044_wr_reg_indirect(vha, sel_addr2, t_sel_val);\n\t\tqla8044_rd_reg_indirect(vha, read_addr, &data);\n\n\t\t*data_ptr++ = data;\n\n\t\tsel_val1 += rdmux2_hdr->select_value_stride;\n\t\tsel_val2 += rdmux2_hdr->select_value_stride;\n\t}\n\n\t*d_ptr = data_ptr;\n}\n\nstatic uint32_t\nqla8044_minidump_process_pollrdmwr(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr,\n\tuint32_t **d_ptr)\n{\n\tuint32_t poll_wait, poll_mask, r_value, data;\n\tuint32_t addr_1, addr_2, value_1, value_2;\n\tstruct qla8044_minidump_entry_pollrdmwr *poll_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tpoll_hdr = (struct qla8044_minidump_entry_pollrdmwr *) entry_hdr;\n\taddr_1 = poll_hdr->addr_1;\n\taddr_2 = poll_hdr->addr_2;\n\tvalue_1 = poll_hdr->value_1;\n\tvalue_2 = poll_hdr->value_2;\n\tpoll_mask = poll_hdr->poll_mask;\n\n\tqla8044_wr_reg_indirect(vha, addr_1, value_1);\n\n\tpoll_wait = poll_hdr->poll_wait;\n\twhile (1) {\n\t\tqla8044_rd_reg_indirect(vha, addr_1, &r_value);\n\n\t\tif ((r_value & poll_mask) != 0) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tusleep_range(1000, 1100);\n\t\t\tif (--poll_wait == 0) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0xb0ff,\n\t\t\t\t    \"%s: TIMEOUT\\n\", __func__);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tqla8044_rd_reg_indirect(vha, addr_2, &data);\n\tdata &= poll_hdr->modify_mask;\n\tqla8044_wr_reg_indirect(vha, addr_2, data);\n\tqla8044_wr_reg_indirect(vha, addr_1, value_2);\n\n\tpoll_wait = poll_hdr->poll_wait;\n\twhile (1) {\n\t\tqla8044_rd_reg_indirect(vha, addr_1, &r_value);\n\n\t\tif ((r_value & poll_mask) != 0) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tusleep_range(1000, 1100);\n\t\t\tif (--poll_wait == 0) {\n\t\t\t\tql_log(ql_log_fatal, vha, 0xb100,\n\t\t\t\t    \"%s: TIMEOUT2\\n\", __func__);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t*data_ptr++ = addr_2;\n\t*data_ptr++ = data;\n\n\t*d_ptr = data_ptr;\n\n\treturn QLA_SUCCESS;\n\nerror:\n\treturn QLA_FUNCTION_FAILED;\n}\n\n#define ISP8044_PEX_DMA_ENGINE_INDEX\t\t8\n#define ISP8044_PEX_DMA_BASE_ADDRESS\t\t0x77320000\n#define ISP8044_PEX_DMA_NUM_OFFSET\t\t0x10000UL\n#define ISP8044_PEX_DMA_CMD_ADDR_LOW\t\t0x0\n#define ISP8044_PEX_DMA_CMD_ADDR_HIGH\t\t0x04\n#define ISP8044_PEX_DMA_CMD_STS_AND_CNTRL\t0x08\n\n#define ISP8044_PEX_DMA_READ_SIZE\t(16 * 1024)\n#define ISP8044_PEX_DMA_MAX_WAIT\t(100 * 100)  \n\nstatic int\nqla8044_check_dma_engine_state(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_SUCCESS;\n\tuint32_t dma_eng_num = 0, cmd_sts_and_cntrl = 0;\n\tuint64_t dma_base_addr = 0;\n\tstruct qla8044_minidump_template_hdr *tmplt_hdr = NULL;\n\n\ttmplt_hdr = ha->md_tmplt_hdr;\n\tdma_eng_num =\n\t    tmplt_hdr->saved_state_array[ISP8044_PEX_DMA_ENGINE_INDEX];\n\tdma_base_addr = ISP8044_PEX_DMA_BASE_ADDRESS +\n\t\t(dma_eng_num * ISP8044_PEX_DMA_NUM_OFFSET);\n\n\t \n\trval = qla8044_rd_reg_indirect(vha,\n\t    (dma_base_addr + ISP8044_PEX_DMA_CMD_STS_AND_CNTRL),\n\t    &cmd_sts_and_cntrl);\n\tif (rval)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\t \n\tif (cmd_sts_and_cntrl & BIT_31)\n\t\treturn QLA_SUCCESS;\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\nstatic int\nqla8044_start_pex_dma(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_rdmem_pex_dma *m_hdr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_SUCCESS, wait = 0;\n\tuint32_t dma_eng_num = 0, cmd_sts_and_cntrl = 0;\n\tuint64_t dma_base_addr = 0;\n\tstruct qla8044_minidump_template_hdr *tmplt_hdr = NULL;\n\n\ttmplt_hdr = ha->md_tmplt_hdr;\n\tdma_eng_num =\n\t    tmplt_hdr->saved_state_array[ISP8044_PEX_DMA_ENGINE_INDEX];\n\tdma_base_addr = ISP8044_PEX_DMA_BASE_ADDRESS +\n\t\t(dma_eng_num * ISP8044_PEX_DMA_NUM_OFFSET);\n\n\trval = qla8044_wr_reg_indirect(vha,\n\t    dma_base_addr + ISP8044_PEX_DMA_CMD_ADDR_LOW,\n\t    m_hdr->desc_card_addr);\n\tif (rval)\n\t\tgoto error_exit;\n\n\trval = qla8044_wr_reg_indirect(vha,\n\t    dma_base_addr + ISP8044_PEX_DMA_CMD_ADDR_HIGH, 0);\n\tif (rval)\n\t\tgoto error_exit;\n\n\trval = qla8044_wr_reg_indirect(vha,\n\t    dma_base_addr + ISP8044_PEX_DMA_CMD_STS_AND_CNTRL,\n\t    m_hdr->start_dma_cmd);\n\tif (rval)\n\t\tgoto error_exit;\n\n\t \n\tfor (wait = 0; wait < ISP8044_PEX_DMA_MAX_WAIT; wait++) {\n\t\trval = qla8044_rd_reg_indirect(vha,\n\t\t    (dma_base_addr + ISP8044_PEX_DMA_CMD_STS_AND_CNTRL),\n\t\t    &cmd_sts_and_cntrl);\n\t\tif (rval)\n\t\t\tgoto error_exit;\n\n\t\tif ((cmd_sts_and_cntrl & BIT_1) == 0)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\t \n\tif (wait >= ISP8044_PEX_DMA_MAX_WAIT) {\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto error_exit;\n\t}\n\nerror_exit:\n\treturn rval;\n}\n\nstatic int\nqla8044_minidump_pex_dma_read(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tint rval = QLA_SUCCESS;\n\tstruct qla8044_minidump_entry_rdmem_pex_dma *m_hdr = NULL;\n\tuint32_t chunk_size, read_size;\n\tuint8_t *data_ptr = (uint8_t *)*d_ptr;\n\tvoid *rdmem_buffer = NULL;\n\tdma_addr_t rdmem_dma;\n\tstruct qla8044_pex_dma_descriptor dma_desc;\n\n\trval = qla8044_check_dma_engine_state(vha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb147,\n\t\t    \"DMA engine not available. Fallback to rdmem-read.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tm_hdr = (void *)entry_hdr;\n\n\trdmem_buffer = dma_alloc_coherent(&ha->pdev->dev,\n\t    ISP8044_PEX_DMA_READ_SIZE, &rdmem_dma, GFP_KERNEL);\n\tif (!rdmem_buffer) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb148,\n\t\t    \"Unable to allocate rdmem dma buffer\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\t \n\t \n\tdma_desc.cmd.dma_desc_cmd = (m_hdr->dma_desc_cmd & 0xff0f);\n\tdma_desc.cmd.dma_desc_cmd |=\n\t    ((PCI_FUNC(ha->pdev->devfn) & 0xf) << 0x4);\n\n\tdma_desc.dma_bus_addr = rdmem_dma;\n\tdma_desc.cmd.read_data_size = chunk_size = ISP8044_PEX_DMA_READ_SIZE;\n\tread_size = 0;\n\n\t \n\twhile (read_size < m_hdr->read_data_size) {\n\t\tif (m_hdr->read_data_size - read_size <\n\t\t    ISP8044_PEX_DMA_READ_SIZE) {\n\t\t\tchunk_size = (m_hdr->read_data_size - read_size);\n\t\t\tdma_desc.cmd.read_data_size = chunk_size;\n\t\t}\n\n\t\tdma_desc.src_addr = m_hdr->read_addr + read_size;\n\n\t\t \n\t\trval = qla8044_ms_mem_write_128b(vha,\n\t\t    m_hdr->desc_card_addr, (uint32_t *)&dma_desc,\n\t\t    (sizeof(struct qla8044_pex_dma_descriptor)/16));\n\t\tif (rval) {\n\t\t\tql_log(ql_log_warn, vha, 0xb14a,\n\t\t\t    \"%s: Error writing rdmem-dma-init to MS !!!\\n\",\n\t\t\t    __func__);\n\t\t\tgoto error_exit;\n\t\t}\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb14b,\n\t\t    \"%s: Dma-descriptor: Instruct for rdmem dma \"\n\t\t    \"(chunk_size 0x%x).\\n\", __func__, chunk_size);\n\n\t\t \n\t\trval = qla8044_start_pex_dma(vha, m_hdr);\n\t\tif (rval)\n\t\t\tgoto error_exit;\n\n\t\tmemcpy(data_ptr, rdmem_buffer, chunk_size);\n\t\tdata_ptr += chunk_size;\n\t\tread_size += chunk_size;\n\t}\n\n\t*d_ptr = (uint32_t *)data_ptr;\n\nerror_exit:\n\tif (rdmem_buffer)\n\t\tdma_free_coherent(&ha->pdev->dev, ISP8044_PEX_DMA_READ_SIZE,\n\t\t    rdmem_buffer, rdmem_dma);\n\n\treturn rval;\n}\n\nstatic uint32_t\nqla8044_minidump_process_rddfe(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tint loop_cnt;\n\tuint32_t addr1, addr2, value, data, temp, wrVal;\n\tuint8_t stride, stride2;\n\tuint16_t count;\n\tuint32_t poll, mask, modify_mask;\n\tuint32_t wait_count = 0;\n\tuint32_t *data_ptr = *d_ptr;\n\tstruct qla8044_minidump_entry_rddfe *rddfe;\n\n\trddfe = (struct qla8044_minidump_entry_rddfe *) entry_hdr;\n\n\taddr1 = rddfe->addr_1;\n\tvalue = rddfe->value;\n\tstride = rddfe->stride;\n\tstride2 = rddfe->stride2;\n\tcount = rddfe->count;\n\n\tpoll = rddfe->poll;\n\tmask = rddfe->mask;\n\tmodify_mask = rddfe->modify_mask;\n\n\taddr2 = addr1 + stride;\n\n\tfor (loop_cnt = 0x0; loop_cnt < count; loop_cnt++) {\n\t\tqla8044_wr_reg_indirect(vha, addr1, (0x40000000 | value));\n\n\t\twait_count = 0;\n\t\twhile (wait_count < poll) {\n\t\t\tqla8044_rd_reg_indirect(vha, addr1, &temp);\n\t\t\tif ((temp & mask) != 0)\n\t\t\t\tbreak;\n\t\t\twait_count++;\n\t\t}\n\n\t\tif (wait_count == poll) {\n\t\t\tql_log(ql_log_warn, vha, 0xb153,\n\t\t\t    \"%s: TIMEOUT\\n\", __func__);\n\t\t\tgoto error;\n\t\t} else {\n\t\t\tqla8044_rd_reg_indirect(vha, addr2, &temp);\n\t\t\ttemp = temp & modify_mask;\n\t\t\ttemp = (temp | ((loop_cnt << 16) | loop_cnt));\n\t\t\twrVal = ((temp << 16) | temp);\n\n\t\t\tqla8044_wr_reg_indirect(vha, addr2, wrVal);\n\t\t\tqla8044_wr_reg_indirect(vha, addr1, value);\n\n\t\t\twait_count = 0;\n\t\t\twhile (wait_count < poll) {\n\t\t\t\tqla8044_rd_reg_indirect(vha, addr1, &temp);\n\t\t\t\tif ((temp & mask) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\twait_count++;\n\t\t\t}\n\t\t\tif (wait_count == poll) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xb154,\n\t\t\t\t    \"%s: TIMEOUT\\n\", __func__);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tqla8044_wr_reg_indirect(vha, addr1,\n\t\t\t    ((0x40000000 | value) + stride2));\n\t\t\twait_count = 0;\n\t\t\twhile (wait_count < poll) {\n\t\t\t\tqla8044_rd_reg_indirect(vha, addr1, &temp);\n\t\t\t\tif ((temp & mask) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\twait_count++;\n\t\t\t}\n\n\t\t\tif (wait_count == poll) {\n\t\t\t\tql_log(ql_log_warn, vha, 0xb155,\n\t\t\t\t    \"%s: TIMEOUT\\n\", __func__);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tqla8044_rd_reg_indirect(vha, addr2, &data);\n\n\t\t\t*data_ptr++ = wrVal;\n\t\t\t*data_ptr++ = data;\n\t\t}\n\n\t}\n\n\t*d_ptr = data_ptr;\n\treturn QLA_SUCCESS;\n\nerror:\n\treturn -1;\n\n}\n\nstatic uint32_t\nqla8044_minidump_process_rdmdio(struct scsi_qla_host *vha,\n\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tint ret = 0;\n\tuint32_t addr1, addr2, value1, value2, data, selVal;\n\tuint8_t stride1, stride2;\n\tuint32_t addr3, addr4, addr5, addr6, addr7;\n\tuint16_t count, loop_cnt;\n\tuint32_t mask;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tstruct qla8044_minidump_entry_rdmdio *rdmdio;\n\n\trdmdio = (struct qla8044_minidump_entry_rdmdio *) entry_hdr;\n\n\taddr1 = rdmdio->addr_1;\n\taddr2 = rdmdio->addr_2;\n\tvalue1 = rdmdio->value_1;\n\tstride1 = rdmdio->stride_1;\n\tstride2 = rdmdio->stride_2;\n\tcount = rdmdio->count;\n\n\tmask = rdmdio->mask;\n\tvalue2 = rdmdio->value_2;\n\n\taddr3 = addr1 + stride1;\n\n\tfor (loop_cnt = 0; loop_cnt < count; loop_cnt++) {\n\t\tret = qla8044_poll_wait_ipmdio_bus_idle(vha, addr1, addr2,\n\t\t    addr3, mask);\n\t\tif (ret == -1)\n\t\t\tgoto error;\n\n\t\taddr4 = addr2 - stride1;\n\t\tret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask, addr4,\n\t\t    value2);\n\t\tif (ret == -1)\n\t\t\tgoto error;\n\n\t\taddr5 = addr2 - (2 * stride1);\n\t\tret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask, addr5,\n\t\t    value1);\n\t\tif (ret == -1)\n\t\t\tgoto error;\n\n\t\taddr6 = addr2 - (3 * stride1);\n\t\tret = qla8044_ipmdio_wr_reg(vha, addr1, addr3, mask,\n\t\t    addr6, 0x2);\n\t\tif (ret == -1)\n\t\t\tgoto error;\n\n\t\tret = qla8044_poll_wait_ipmdio_bus_idle(vha, addr1, addr2,\n\t\t    addr3, mask);\n\t\tif (ret == -1)\n\t\t\tgoto error;\n\n\t\taddr7 = addr2 - (4 * stride1);\n\t\tdata = qla8044_ipmdio_rd_reg(vha, addr1, addr3, mask, addr7);\n\t\tif (data == -1)\n\t\t\tgoto error;\n\n\t\tselVal = (value2 << 18) | (value1 << 2) | 2;\n\n\t\tstride2 = rdmdio->stride_2;\n\t\t*data_ptr++ = selVal;\n\t\t*data_ptr++ = data;\n\n\t\tvalue1 = value1 + stride2;\n\t\t*d_ptr = data_ptr;\n\t}\n\n\treturn 0;\n\nerror:\n\treturn -1;\n}\n\nstatic uint32_t qla8044_minidump_process_pollwr(struct scsi_qla_host *vha,\n\t\tstruct qla8044_minidump_entry_hdr *entry_hdr, uint32_t **d_ptr)\n{\n\tuint32_t addr1, addr2, value1, value2, poll, r_value;\n\tuint32_t wait_count = 0;\n\tstruct qla8044_minidump_entry_pollwr *pollwr_hdr;\n\n\tpollwr_hdr = (struct qla8044_minidump_entry_pollwr *)entry_hdr;\n\taddr1 = pollwr_hdr->addr_1;\n\taddr2 = pollwr_hdr->addr_2;\n\tvalue1 = pollwr_hdr->value_1;\n\tvalue2 = pollwr_hdr->value_2;\n\n\tpoll = pollwr_hdr->poll;\n\n\twhile (wait_count < poll) {\n\t\tqla8044_rd_reg_indirect(vha, addr1, &r_value);\n\n\t\tif ((r_value & poll) != 0)\n\t\t\tbreak;\n\t\twait_count++;\n\t}\n\n\tif (wait_count == poll) {\n\t\tql_log(ql_log_warn, vha, 0xb156, \"%s: TIMEOUT\\n\", __func__);\n\t\tgoto error;\n\t}\n\n\tqla8044_wr_reg_indirect(vha, addr2, value2);\n\tqla8044_wr_reg_indirect(vha, addr1, value1);\n\n\twait_count = 0;\n\twhile (wait_count < poll) {\n\t\tqla8044_rd_reg_indirect(vha, addr1, &r_value);\n\n\t\tif ((r_value & poll) != 0)\n\t\t\tbreak;\n\t\twait_count++;\n\t}\n\n\treturn QLA_SUCCESS;\n\nerror:\n\treturn -1;\n}\n\n \nint\nqla8044_collect_md_data(struct scsi_qla_host *vha)\n{\n\tint num_entry_hdr = 0;\n\tstruct qla8044_minidump_entry_hdr *entry_hdr;\n\tstruct qla8044_minidump_template_hdr *tmplt_hdr;\n\tuint32_t *data_ptr;\n\tuint32_t data_collected = 0, f_capture_mask;\n\tint i, rval = QLA_FUNCTION_FAILED;\n\tuint64_t now;\n\tuint32_t timestamp, idc_control;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->md_dump) {\n\t\tql_log(ql_log_info, vha, 0xb101,\n\t\t    \"%s(%ld) No buffer to dump\\n\",\n\t\t    __func__, vha->host_no);\n\t\treturn rval;\n\t}\n\n\tif (ha->fw_dumped) {\n\t\tql_log(ql_log_warn, vha, 0xb10d,\n\t\t    \"Firmware has been previously dumped (%p) \"\n\t\t    \"-- ignoring request.\\n\", ha->fw_dump);\n\t\tgoto md_failed;\n\t}\n\n\tha->fw_dumped = false;\n\n\tif (!ha->md_tmplt_hdr || !ha->md_dump) {\n\t\tql_log(ql_log_warn, vha, 0xb10e,\n\t\t    \"Memory not allocated for minidump capture\\n\");\n\t\tgoto md_failed;\n\t}\n\n\tqla8044_idc_lock(ha);\n\tidc_control = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\n\tif (idc_control & GRACEFUL_RESET_BIT1) {\n\t\tql_log(ql_log_warn, vha, 0xb112,\n\t\t    \"Forced reset from application, \"\n\t\t    \"ignore minidump capture\\n\");\n\t\tqla8044_wr_reg(ha, QLA8044_IDC_DRV_CTRL,\n\t\t    (idc_control & ~GRACEFUL_RESET_BIT1));\n\t\tqla8044_idc_unlock(ha);\n\n\t\tgoto md_failed;\n\t}\n\tqla8044_idc_unlock(ha);\n\n\tif (qla82xx_validate_template_chksum(vha)) {\n\t\tql_log(ql_log_info, vha, 0xb109,\n\t\t    \"Template checksum validation error\\n\");\n\t\tgoto md_failed;\n\t}\n\n\ttmplt_hdr = (struct qla8044_minidump_template_hdr *)\n\t\tha->md_tmplt_hdr;\n\tdata_ptr = (uint32_t *)((uint8_t *)ha->md_dump);\n\tnum_entry_hdr = tmplt_hdr->num_of_entries;\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb11a,\n\t    \"Capture Mask obtained: 0x%x\\n\", tmplt_hdr->capture_debug_level);\n\n\tf_capture_mask = tmplt_hdr->capture_debug_level & 0xFF;\n\n\t \n\tif ((f_capture_mask & 0x3) != 0x3) {\n\t\tql_log(ql_log_warn, vha, 0xb10f,\n\t\t    \"Minimum required capture mask[0x%x] level not set\\n\",\n\t\t    f_capture_mask);\n\n\t}\n\ttmplt_hdr->driver_capture_mask = ql2xmdcapmask;\n\tql_log(ql_log_info, vha, 0xb102,\n\t    \"[%s]: starting data ptr: %p\\n\",\n\t   __func__, data_ptr);\n\tql_log(ql_log_info, vha, 0xb10b,\n\t   \"[%s]: no of entry headers in Template: 0x%x\\n\",\n\t   __func__, num_entry_hdr);\n\tql_log(ql_log_info, vha, 0xb10c,\n\t    \"[%s]: Total_data_size 0x%x, %d obtained\\n\",\n\t   __func__, ha->md_dump_size, ha->md_dump_size);\n\n\t \n\tnow = get_jiffies_64();\n\ttimestamp = (u32)(jiffies_to_msecs(now) / 1000);\n\ttmplt_hdr->driver_timestamp = timestamp;\n\n\tentry_hdr = (struct qla8044_minidump_entry_hdr *)\n\t\t(((uint8_t *)ha->md_tmplt_hdr) + tmplt_hdr->first_entry_offset);\n\ttmplt_hdr->saved_state_array[QLA8044_SS_OCM_WNDREG_INDEX] =\n\t    tmplt_hdr->ocm_window_reg[ha->portnum];\n\n\t \n\tfor (i = 0; i < num_entry_hdr; i++) {\n\t\tif (data_collected > ha->md_dump_size) {\n\t\t\tql_log(ql_log_info, vha, 0xb103,\n\t\t\t    \"Data collected: [0x%x], \"\n\t\t\t    \"Total Dump size: [0x%x]\\n\",\n\t\t\t    data_collected, ha->md_dump_size);\n\t\t\treturn rval;\n\t\t}\n\n\t\tif (!(entry_hdr->d_ctrl.entry_capture_mask &\n\t\t      ql2xmdcapmask)) {\n\t\t\tentry_hdr->d_ctrl.driver_flags |=\n\t\t\t    QLA82XX_DBG_SKIPPED_FLAG;\n\t\t\tgoto skip_nxt_entry;\n\t\t}\n\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb104,\n\t\t    \"Data collected: [0x%x], Dump size left:[0x%x]\\n\",\n\t\t    data_collected,\n\t\t    (ha->md_dump_size - data_collected));\n\n\t\t \n\t\tswitch (entry_hdr->entry_type) {\n\t\tcase QLA82XX_RDEND:\n\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA82XX_CNTRL:\n\t\t\trval = qla8044_minidump_process_control(vha,\n\t\t\t    entry_hdr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\t\tgoto md_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA82XX_RDCRB:\n\t\t\tqla8044_minidump_process_rdcrb(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_RDMEM:\n\t\t\trval = qla8044_minidump_pex_dma_read(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\trval = qla8044_minidump_process_rdmem(vha,\n\t\t\t\t    entry_hdr, &data_ptr);\n\t\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\t\tqla8044_mark_entry_skipped(vha,\n\t\t\t\t\t    entry_hdr, i);\n\t\t\t\t\tgoto md_failed;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA82XX_BOARD:\n\t\tcase QLA82XX_RDROM:\n\t\t\trval = qla8044_minidump_process_rdrom(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla8044_mark_entry_skipped(vha,\n\t\t\t\t    entry_hdr, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA82XX_L2DTG:\n\t\tcase QLA82XX_L2ITG:\n\t\tcase QLA82XX_L2DAT:\n\t\tcase QLA82XX_L2INS:\n\t\t\trval = qla8044_minidump_process_l2tag(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\t\tgoto md_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA8044_L1DTG:\n\t\tcase QLA8044_L1ITG:\n\t\tcase QLA82XX_L1DAT:\n\t\tcase QLA82XX_L1INS:\n\t\t\tqla8044_minidump_process_l1cache(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_RDOCM:\n\t\t\tqla8044_minidump_process_rdocm(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_RDMUX:\n\t\t\tqla8044_minidump_process_rdmux(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA82XX_QUEUE:\n\t\t\tqla8044_minidump_process_queue(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA8044_POLLRD:\n\t\t\trval = qla8044_minidump_process_pollrd(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8044_RDMUX2:\n\t\t\tqla8044_minidump_process_rdmux2(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA8044_POLLRDMWR:\n\t\t\trval = qla8044_minidump_process_pollrdmwr(vha,\n\t\t\t    entry_hdr, &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8044_RDDFE:\n\t\t\trval = qla8044_minidump_process_rddfe(vha, entry_hdr,\n\t\t\t    &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8044_RDMDIO:\n\t\t\trval = qla8044_minidump_process_rdmdio(vha, entry_hdr,\n\t\t\t    &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8044_POLLWR:\n\t\t\trval = qla8044_minidump_process_pollwr(vha, entry_hdr,\n\t\t\t    &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA82XX_RDNOP:\n\t\tdefault:\n\t\t\tqla8044_mark_entry_skipped(vha, entry_hdr, i);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata_collected = (uint8_t *)data_ptr -\n\t\t    (uint8_t *)((uint8_t *)ha->md_dump);\nskip_nxt_entry:\n\t\t \n\t\tentry_hdr = (struct qla8044_minidump_entry_hdr *)\n\t\t    (((uint8_t *)entry_hdr) + entry_hdr->entry_size);\n\t}\n\n\tif (data_collected != ha->md_dump_size) {\n\t\tql_log(ql_log_info, vha, 0xb105,\n\t\t    \"Dump data mismatch: Data collected: \"\n\t\t    \"[0x%x], total_data_size:[0x%x]\\n\",\n\t\t    data_collected, ha->md_dump_size);\n\t\trval = QLA_FUNCTION_FAILED;\n\t\tgoto md_failed;\n\t}\n\n\tql_log(ql_log_info, vha, 0xb110,\n\t    \"Firmware dump saved to temp buffer (%ld/%p %ld/%p).\\n\",\n\t    vha->host_no, ha->md_tmplt_hdr, vha->host_no, ha->md_dump);\n\tha->fw_dumped = true;\n\tqla2x00_post_uevent_work(vha, QLA_UEVENT_CODE_FW_DUMP);\n\n\n\tql_log(ql_log_info, vha, 0xb106,\n\t    \"Leaving fn: %s Last entry: 0x%x\\n\",\n\t    __func__, i);\nmd_failed:\n\treturn rval;\n}\n\nvoid\nqla8044_get_minidump(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!qla8044_collect_md_data(vha)) {\n\t\tha->fw_dumped = true;\n\t\tha->prev_minidump_failed = 0;\n\t} else {\n\t\tql_log(ql_log_fatal, vha, 0xb0db,\n\t\t    \"%s: Unable to collect minidump\\n\",\n\t\t    __func__);\n\t\tha->prev_minidump_failed = 1;\n\t}\n}\n\nstatic int\nqla8044_poll_flash_status_reg(struct scsi_qla_host *vha)\n{\n\tuint32_t flash_status;\n\tint retries = QLA8044_FLASH_READ_RETRY_COUNT;\n\tint ret_val = QLA_SUCCESS;\n\n\twhile (retries--) {\n\t\tret_val = qla8044_rd_reg_indirect(vha, QLA8044_FLASH_STATUS,\n\t\t    &flash_status);\n\t\tif (ret_val) {\n\t\t\tql_log(ql_log_warn, vha, 0xb13c,\n\t\t\t    \"%s: Failed to read FLASH_STATUS reg.\\n\",\n\t\t\t    __func__);\n\t\t\tbreak;\n\t\t}\n\t\tif ((flash_status & QLA8044_FLASH_STATUS_READY) ==\n\t\t    QLA8044_FLASH_STATUS_READY)\n\t\t\tbreak;\n\t\tmsleep(QLA8044_FLASH_STATUS_REG_POLL_DELAY);\n\t}\n\n\tif (!retries)\n\t\tret_val = QLA_FUNCTION_FAILED;\n\n\treturn ret_val;\n}\n\nstatic int\nqla8044_write_flash_status_reg(struct scsi_qla_host *vha,\n\t\t\t       uint32_t data)\n{\n\tint ret_val = QLA_SUCCESS;\n\tuint32_t cmd;\n\n\tcmd = vha->hw->fdt_wrt_sts_reg_cmd;\n\n\tret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\n\t    QLA8044_FLASH_STATUS_WRITE_DEF_SIG | cmd);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb125,\n\t\t    \"%s: Failed to write to FLASH_ADDR.\\n\", __func__);\n\t\tgoto exit_func;\n\t}\n\n\tret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA, data);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb126,\n\t\t    \"%s: Failed to write to FLASH_WRDATA.\\n\", __func__);\n\t\tgoto exit_func;\n\t}\n\n\tret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\n\t    QLA8044_FLASH_SECOND_ERASE_MS_VAL);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb127,\n\t\t    \"%s: Failed to write to FLASH_CONTROL.\\n\", __func__);\n\t\tgoto exit_func;\n\t}\n\n\tret_val = qla8044_poll_flash_status_reg(vha);\n\tif (ret_val)\n\t\tql_log(ql_log_warn, vha, 0xb128,\n\t\t    \"%s: Error polling flash status reg.\\n\", __func__);\n\nexit_func:\n\treturn ret_val;\n}\n\n \nstatic int\nqla8044_unprotect_flash(scsi_qla_host_t *vha)\n{\n\tint ret_val;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tret_val = qla8044_write_flash_status_reg(vha, ha->fdt_wrt_enable);\n\tif (ret_val)\n\t\tql_log(ql_log_warn, vha, 0xb139,\n\t\t    \"%s: Write flash status failed.\\n\", __func__);\n\n\treturn ret_val;\n}\n\n \nstatic int\nqla8044_protect_flash(scsi_qla_host_t *vha)\n{\n\tint ret_val;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tret_val = qla8044_write_flash_status_reg(vha, ha->fdt_wrt_disable);\n\tif (ret_val)\n\t\tql_log(ql_log_warn, vha, 0xb13b,\n\t\t    \"%s: Write flash status failed.\\n\", __func__);\n\n\treturn ret_val;\n}\n\n\nstatic int\nqla8044_erase_flash_sector(struct scsi_qla_host *vha,\n\t\t\t   uint32_t sector_start_addr)\n{\n\tuint32_t reversed_addr;\n\tint ret_val = QLA_SUCCESS;\n\n\tret_val = qla8044_poll_flash_status_reg(vha);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb12e,\n\t\t    \"%s: Poll flash status after erase failed..\\n\", __func__);\n\t}\n\n\treversed_addr = (((sector_start_addr & 0xFF) << 16) |\n\t    (sector_start_addr & 0xFF00) |\n\t    ((sector_start_addr & 0xFF0000) >> 16));\n\n\tret_val = qla8044_wr_reg_indirect(vha,\n\t    QLA8044_FLASH_WRDATA, reversed_addr);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb12f,\n\t\t    \"%s: Failed to write to FLASH_WRDATA.\\n\", __func__);\n\t}\n\tret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\n\t   QLA8044_FLASH_ERASE_SIG | vha->hw->fdt_erase_cmd);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb130,\n\t\t    \"%s: Failed to write to FLASH_ADDR.\\n\", __func__);\n\t}\n\tret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\n\t    QLA8044_FLASH_LAST_ERASE_MS_VAL);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb131,\n\t\t    \"%s: Failed write to FLASH_CONTROL.\\n\", __func__);\n\t}\n\tret_val = qla8044_poll_flash_status_reg(vha);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb132,\n\t\t    \"%s: Poll flash status failed.\\n\", __func__);\n\t}\n\n\n\treturn ret_val;\n}\n\n \nstatic int\nqla8044_flash_write_u32(struct scsi_qla_host *vha, uint32_t addr,\n\t\t\tuint32_t *p_data)\n{\n\tint ret_val = QLA_SUCCESS;\n\n\tret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\n\t    0x00800000 | (addr >> 2));\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb134,\n\t\t    \"%s: Failed write to FLASH_ADDR.\\n\", __func__);\n\t\tgoto exit_func;\n\t}\n\tret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA, *p_data);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb135,\n\t\t    \"%s: Failed write to FLASH_WRDATA.\\n\", __func__);\n\t\tgoto exit_func;\n\t}\n\tret_val = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL, 0x3D);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb136,\n\t\t    \"%s: Failed write to FLASH_CONTROL.\\n\", __func__);\n\t\tgoto exit_func;\n\t}\n\tret_val = qla8044_poll_flash_status_reg(vha);\n\tif (ret_val) {\n\t\tql_log(ql_log_warn, vha, 0xb137,\n\t\t    \"%s: Poll flash status failed.\\n\", __func__);\n\t}\n\nexit_func:\n\treturn ret_val;\n}\n\nstatic int\nqla8044_write_flash_buffer_mode(scsi_qla_host_t *vha, uint32_t *dwptr,\n\t\t\t\tuint32_t faddr, uint32_t dwords)\n{\n\tint ret = QLA_FUNCTION_FAILED;\n\tuint32_t spi_val;\n\n\tif (dwords < QLA8044_MIN_OPTROM_BURST_DWORDS ||\n\t    dwords > QLA8044_MAX_OPTROM_BURST_DWORDS) {\n\t\tql_dbg(ql_dbg_user, vha, 0xb123,\n\t\t    \"Got unsupported dwords = 0x%x.\\n\",\n\t\t    dwords);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tqla8044_rd_reg_indirect(vha, QLA8044_FLASH_SPI_CONTROL, &spi_val);\n\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_SPI_CONTROL,\n\t    spi_val | QLA8044_FLASH_SPI_CTL);\n\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\n\t    QLA8044_FLASH_FIRST_TEMP_VAL);\n\n\t \n\tret = qla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA,\n\t    *dwptr++);\n\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\n\t    QLA8044_FLASH_FIRST_MS_PATTERN);\n\n\tret = qla8044_poll_flash_status_reg(vha);\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0xb124,\n\t\t    \"%s: Failed.\\n\", __func__);\n\t\tgoto exit_func;\n\t}\n\n\tdwords--;\n\n\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\n\t    QLA8044_FLASH_SECOND_TEMP_VAL);\n\n\n\t \n\twhile (dwords != 1) {\n\t\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA, *dwptr++);\n\t\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\n\t\t    QLA8044_FLASH_SECOND_MS_PATTERN);\n\t\tret = qla8044_poll_flash_status_reg(vha);\n\t\tif (ret) {\n\t\t\tql_log(ql_log_warn, vha, 0xb129,\n\t\t\t    \"%s: Failed.\\n\", __func__);\n\t\t\tgoto exit_func;\n\t\t}\n\t\tdwords--;\n\t}\n\n\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_ADDR,\n\t    QLA8044_FLASH_FIRST_TEMP_VAL | (faddr >> 2));\n\n\t \n\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_WRDATA, *dwptr++);\n\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_CONTROL,\n\t    QLA8044_FLASH_LAST_MS_PATTERN);\n\tret = qla8044_poll_flash_status_reg(vha);\n\tif (ret) {\n\t\tql_log(ql_log_warn, vha, 0xb12a,\n\t\t    \"%s: Failed.\\n\", __func__);\n\t\tgoto exit_func;\n\t}\n\tqla8044_rd_reg_indirect(vha, QLA8044_FLASH_SPI_STATUS, &spi_val);\n\n\tif ((spi_val & QLA8044_FLASH_SPI_CTL) == QLA8044_FLASH_SPI_CTL) {\n\t\tql_log(ql_log_warn, vha, 0xb12b,\n\t\t    \"%s: Failed.\\n\", __func__);\n\t\tspi_val = 0;\n\t\t \n\t\tqla8044_rd_reg_indirect(vha, QLA8044_FLASH_SPI_CONTROL,\n\t\t    &spi_val);\n\t\tqla8044_wr_reg_indirect(vha, QLA8044_FLASH_SPI_CONTROL,\n\t\t    spi_val | QLA8044_FLASH_SPI_CTL);\n\t}\nexit_func:\n\treturn ret;\n}\n\nstatic int\nqla8044_write_flash_dword_mode(scsi_qla_host_t *vha, uint32_t *dwptr,\n\t\t\t       uint32_t faddr, uint32_t dwords)\n{\n\tint ret = QLA_FUNCTION_FAILED;\n\tuint32_t liter;\n\n\tfor (liter = 0; liter < dwords; liter++, faddr += 4, dwptr++) {\n\t\tret = qla8044_flash_write_u32(vha, faddr, dwptr);\n\t\tif (ret) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb141,\n\t\t\t    \"%s: flash address=%x data=%x.\\n\", __func__,\n\t\t\t     faddr, *dwptr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint\nqla8044_write_optrom_data(struct scsi_qla_host *vha, void *buf,\n\t\t\t  uint32_t offset, uint32_t length)\n{\n\tint rval = QLA_FUNCTION_FAILED, i, burst_iter_count;\n\tint dword_count, erase_sec_count;\n\tuint32_t erase_offset;\n\tuint8_t *p_cache, *p_src;\n\n\terase_offset = offset;\n\n\tp_cache = kcalloc(length, sizeof(uint8_t), GFP_KERNEL);\n\tif (!p_cache)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmemcpy(p_cache, buf, length);\n\tp_src = p_cache;\n\tdword_count = length / sizeof(uint32_t);\n\t \n\tburst_iter_count = dword_count / QLA8044_MAX_OPTROM_BURST_DWORDS;\n\terase_sec_count = length / QLA8044_SECTOR_SIZE;\n\n\t \n\tscsi_block_requests(vha->host);\n\t \n\tqla8044_flash_lock(vha);\n\tqla8044_unprotect_flash(vha);\n\n\t \n\tfor (i = 0; i < erase_sec_count; i++) {\n\t\trval = qla8044_erase_flash_sector(vha, erase_offset);\n\t\tql_dbg(ql_dbg_user, vha, 0xb138,\n\t\t    \"Done erase of sector=0x%x.\\n\",\n\t\t    erase_offset);\n\t\tif (rval) {\n\t\t\tql_log(ql_log_warn, vha, 0xb121,\n\t\t\t    \"Failed to erase the sector having address: \"\n\t\t\t    \"0x%x.\\n\", erase_offset);\n\t\t\tgoto out;\n\t\t}\n\t\terase_offset += QLA8044_SECTOR_SIZE;\n\t}\n\tql_dbg(ql_dbg_user, vha, 0xb13f,\n\t    \"Got write for addr = 0x%x length=0x%x.\\n\",\n\t    offset, length);\n\n\tfor (i = 0; i < burst_iter_count; i++) {\n\n\t\t \n\t\trval = qla8044_write_flash_buffer_mode(vha, (uint32_t *)p_src,\n\t\t    offset, QLA8044_MAX_OPTROM_BURST_DWORDS);\n\t\tif (rval) {\n\t\t\t \n\t\t\tql_log(ql_log_warn, vha, 0xb122,\n\t\t\t    \"Failed to write flash in buffer mode, \"\n\t\t\t    \"Reverting to slow-write.\\n\");\n\t\t\trval = qla8044_write_flash_dword_mode(vha,\n\t\t\t    (uint32_t *)p_src, offset,\n\t\t\t    QLA8044_MAX_OPTROM_BURST_DWORDS);\n\t\t}\n\t\tp_src +=  sizeof(uint32_t) * QLA8044_MAX_OPTROM_BURST_DWORDS;\n\t\toffset += sizeof(uint32_t) * QLA8044_MAX_OPTROM_BURST_DWORDS;\n\t}\n\tql_dbg(ql_dbg_user, vha, 0xb133,\n\t    \"Done writing.\\n\");\n\nout:\n\tqla8044_protect_flash(vha);\n\tqla8044_flash_unlock(vha);\n\tscsi_unblock_requests(vha->host);\n\tkfree(p_cache);\n\n\treturn rval;\n}\n\n#define LEG_INT_PTR_B31\t\t(1 << 31)\n#define LEG_INT_PTR_B30\t\t(1 << 30)\n#define PF_BITS_MASK\t\t(0xF << 16)\n \nirqreturn_t\nqla8044_intr_handler(int irq, void *dev_id)\n{\n\tscsi_qla_host_t\t*vha;\n\tstruct qla_hw_data *ha;\n\tstruct rsp_que *rsp;\n\tstruct device_reg_82xx __iomem *reg;\n\tint\t\tstatus = 0;\n\tunsigned long\tflags;\n\tunsigned long\titer;\n\tuint32_t\tstat;\n\tuint16_t\tmb[8];\n\tuint32_t leg_int_ptr = 0, pf_bit;\n\n\trsp = (struct rsp_que *) dev_id;\n\tif (!rsp) {\n\t\tql_log(ql_log_info, NULL, 0xb143,\n\t\t    \"%s(): NULL response queue pointer\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\tha = rsp->hw;\n\tvha = pci_get_drvdata(ha->pdev);\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn IRQ_HANDLED;\n\n\tleg_int_ptr = qla8044_rd_reg(ha, LEG_INTR_PTR_OFFSET);\n\n\t \n\tif (!(leg_int_ptr & (LEG_INT_PTR_B31))) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb144,\n\t\t    \"%s: Legacy Interrupt Bit 31 not set, \"\n\t\t    \"spurious interrupt!\\n\", __func__);\n\t\treturn IRQ_NONE;\n\t}\n\n\tpf_bit = ha->portnum << 16;\n\t \n\tif ((leg_int_ptr & (PF_BITS_MASK)) != pf_bit) {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb145,\n\t\t    \"%s: Incorrect function ID 0x%x in \"\n\t\t    \"legacy interrupt register, \"\n\t\t    \"ha->pf_bit = 0x%x\\n\", __func__,\n\t\t    (leg_int_ptr & (PF_BITS_MASK)), pf_bit);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tqla8044_wr_reg(ha, LEG_INTR_TRIG_OFFSET, 0);\n\tdo {\n\t\tleg_int_ptr = qla8044_rd_reg(ha, LEG_INTR_PTR_OFFSET);\n\t\tif ((leg_int_ptr & (PF_BITS_MASK)) != pf_bit)\n\t\t\tbreak;\n\t} while (leg_int_ptr & (LEG_INT_PTR_B30));\n\n\treg = &ha->iobase->isp82;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (iter = 1; iter--; ) {\n\n\t\tif (rd_reg_dword(&reg->host_int)) {\n\t\t\tstat = rd_reg_dword(&reg->host_status);\n\t\t\tif ((stat & HSRX_RISC_INT) == 0)\n\t\t\t\tbreak;\n\n\t\t\tswitch (stat & 0xff) {\n\t\t\tcase 0x1:\n\t\t\tcase 0x2:\n\t\t\tcase 0x10:\n\t\t\tcase 0x11:\n\t\t\t\tqla82xx_mbx_completion(vha, MSW(stat));\n\t\t\t\tstatus |= MBX_INTERRUPT;\n\t\t\t\tbreak;\n\t\t\tcase 0x12:\n\t\t\t\tmb[0] = MSW(stat);\n\t\t\t\tmb[1] = rd_reg_word(&reg->mailbox_out[1]);\n\t\t\t\tmb[2] = rd_reg_word(&reg->mailbox_out[2]);\n\t\t\t\tmb[3] = rd_reg_word(&reg->mailbox_out[3]);\n\t\t\t\tqla2x00_async_event(vha, rsp, mb);\n\t\t\t\tbreak;\n\t\t\tcase 0x13:\n\t\t\t\tqla24xx_process_response_queue(vha, rsp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb146,\n\t\t\t\t    \"Unrecognized interrupt type \"\n\t\t\t\t    \"(%d).\\n\", stat & 0xff);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twrt_reg_dword(&reg->host_int, 0);\n\t}\n\n\tqla2x00_handle_mbx_completion(ha, status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nqla8044_idc_dontreset(struct qla_hw_data *ha)\n{\n\tuint32_t idc_ctrl;\n\n\tidc_ctrl = qla8044_rd_reg(ha, QLA8044_IDC_DRV_CTRL);\n\treturn idc_ctrl & DONTRESET_BIT0;\n}\n\nstatic void\nqla8044_clear_rst_ready(scsi_qla_host_t *vha)\n{\n\tuint32_t drv_state;\n\n\tdrv_state = qla8044_rd_direct(vha, QLA8044_CRB_DRV_STATE_INDEX);\n\n\t \n\tdrv_state &= ~(1 << vha->hw->portnum);\n\n\tql_dbg(ql_dbg_p3p, vha, 0xb13d,\n\t    \"drv_state: 0x%08x\\n\", drv_state);\n\tqla8044_wr_direct(vha, QLA8044_CRB_DRV_STATE_INDEX, drv_state);\n}\n\nint\nqla8044_abort_isp(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint32_t dev_state;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqla8044_idc_lock(ha);\n\tdev_state = qla8044_rd_direct(vha, QLA8044_CRB_DEV_STATE_INDEX);\n\n\tif (ql2xdontresethba)\n\t\tqla8044_set_idc_dontreset(vha);\n\n\t \n\tif (dev_state == QLA8XXX_DEV_READY) {\n\t\t \n\t\tif (qla8044_idc_dontreset(ha) == DONTRESET_BIT0) {\n\t\t\tql_dbg(ql_dbg_p3p, vha, 0xb13e,\n\t\t\t    \"Reset recovery disabled\\n\");\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tgoto exit_isp_reset;\n\t\t}\n\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb140,\n\t\t    \"HW State: NEED RESET\\n\");\n\t\tqla8044_wr_direct(vha, QLA8044_CRB_DEV_STATE_INDEX,\n\t\t    QLA8XXX_DEV_NEED_RESET);\n\t}\n\n\t \n\tqla83xx_reset_ownership(vha);\n\n\tqla8044_idc_unlock(ha);\n\trval = qla8044_device_state_handler(vha);\n\tqla8044_idc_lock(ha);\n\tqla8044_clear_rst_ready(vha);\n\nexit_isp_reset:\n\tqla8044_idc_unlock(ha);\n\tif (rval == QLA_SUCCESS) {\n\t\tha->flags.isp82xx_fw_hung = 0;\n\t\tha->flags.nic_core_reset_hdlr_active = 0;\n\t\trval = qla82xx_restart_isp(vha);\n\t}\n\n\treturn rval;\n}\n\nvoid\nqla8044_fw_dump(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->allow_cna_fw_dump)\n\t\treturn;\n\n\tscsi_block_requests(vha->host);\n\tha->flags.isp82xx_no_md_cap = 1;\n\tqla8044_idc_lock(ha);\n\tqla82xx_set_reset_owner(vha);\n\tqla8044_idc_unlock(ha);\n\tqla2x00_wait_for_chip_reset(vha);\n\tscsi_unblock_requests(vha->host);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}