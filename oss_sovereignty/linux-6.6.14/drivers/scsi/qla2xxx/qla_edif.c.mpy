{
  "module_name": "qla_edif.c",
  "hash_id": "48b396e8246c4376c3ca103f200e9bcf216de88180734ddd28d87eff0adb2ab0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_edif.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n#include \"qla_edif.h\"\n\n#include <linux/kthread.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <scsi/scsi_tcq.h>\n\nstatic struct edif_sa_index_entry *qla_edif_sadb_find_sa_index_entry(uint16_t nport_handle,\n\t\tstruct list_head *sa_list);\nstatic uint16_t qla_edif_sadb_get_sa_index(fc_port_t *fcport,\n\t\tstruct qla_sa_update_frame *sa_frame);\nstatic int qla_edif_sadb_delete_sa_index(fc_port_t *fcport, uint16_t nport_handle,\n\t\tuint16_t sa_index);\nstatic int qla_pur_get_pending(scsi_qla_host_t *, fc_port_t *, struct bsg_job *);\n\nstruct edb_node {\n\tstruct  list_head\tlist;\n\tuint32_t\t\tntype;\n\tunion {\n\t\tport_id_t\tplogi_did;\n\t\tuint32_t\tasync;\n\t\tport_id_t\tels_sid;\n\t\tstruct edif_sa_update_aen\tsa_aen;\n\t} u;\n};\n\nstatic struct els_sub_cmd {\n\tuint16_t cmd;\n\tconst char *str;\n} sc_str[] = {\n\t{SEND_ELS, \"send ELS\"},\n\t{SEND_ELS_REPLY, \"send ELS Reply\"},\n\t{PULL_ELS, \"retrieve ELS\"},\n};\n\nconst char *sc_to_str(uint16_t cmd)\n{\n\tint i;\n\tstruct els_sub_cmd *e;\n\n\tfor (i = 0; i < ARRAY_SIZE(sc_str); i++) {\n\t\te = sc_str + i;\n\t\tif (cmd == e->cmd)\n\t\t\treturn e->str;\n\t}\n\treturn \"unknown\";\n}\n\nstatic struct edb_node *qla_edb_getnext(scsi_qla_host_t *vha)\n{\n\tunsigned long   flags;\n\tstruct edb_node *edbnode = NULL;\n\n\tspin_lock_irqsave(&vha->e_dbell.db_lock, flags);\n\n\t \n\tif (!list_empty(&vha->e_dbell.head)) {\n\t\tedbnode = list_first_entry(&vha->e_dbell.head,\n\t\t\t\t\t   struct edb_node, list);\n\t\tlist_del_init(&edbnode->list);\n\t}\n\n\tspin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);\n\n\treturn edbnode;\n}\n\nstatic void qla_edb_node_free(scsi_qla_host_t *vha, struct edb_node *node)\n{\n\tlist_del_init(&node->list);\n\tkfree(node);\n}\n\nstatic struct edif_list_entry *qla_edif_list_find_sa_index(fc_port_t *fcport,\n\t\tuint16_t handle)\n{\n\tstruct edif_list_entry *entry;\n\tstruct edif_list_entry *tentry;\n\tstruct list_head *indx_list = &fcport->edif.edif_indx_list;\n\n\tlist_for_each_entry_safe(entry, tentry, indx_list, next) {\n\t\tif (entry->handle == handle)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\n \nstatic void qla2x00_sa_replace_iocb_timeout(struct timer_list *t)\n{\n\tstruct edif_list_entry *edif_entry = from_timer(edif_entry, t, timer);\n\tfc_port_t *fcport = edif_entry->fcport;\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct  edif_sa_ctl *sa_ctl;\n\tuint16_t nport_handle;\n\tunsigned long flags = 0;\n\n\tql_dbg(ql_dbg_edif, vha, 0x3069,\n\t    \"%s:  nport_handle 0x%x,  SA REPL Delay Timeout, %8phC portid=%06x\\n\",\n\t    __func__, edif_entry->handle, fcport->port_name, fcport->d_id.b24);\n\n\t \n\tspin_lock_irqsave(&fcport->edif.indx_list_lock, flags);\n\n\t \n\tif (edif_entry->delete_sa_index != INVALID_EDIF_SA_INDEX) {\n\t\tuint16_t delete_sa_index = edif_entry->delete_sa_index;\n\n\t\tedif_entry->delete_sa_index = INVALID_EDIF_SA_INDEX;\n\t\tnport_handle = edif_entry->handle;\n\t\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n\n\t\tsa_ctl = qla_edif_find_sa_ctl_by_index(fcport,\n\t\t    delete_sa_index, 0);\n\n\t\tif (sa_ctl) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t    \"%s: sa_ctl: %p, delete index %d, update index: %d, lid: 0x%x\\n\",\n\t\t\t    __func__, sa_ctl, delete_sa_index, edif_entry->update_sa_index,\n\t\t\t    nport_handle);\n\n\t\t\tsa_ctl->flags = EDIF_SA_CTL_FLG_DEL;\n\t\t\tset_bit(EDIF_SA_CTL_REPL, &sa_ctl->state);\n\t\t\tqla_post_sa_replace_work(fcport->vha, fcport,\n\t\t\t    nport_handle, sa_ctl);\n\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t    \"%s: sa_ctl not found for delete_sa_index: %d\\n\",\n\t\t\t    __func__, edif_entry->delete_sa_index);\n\t\t}\n\t} else {\n\t\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n\t}\n}\n\n \nstatic int qla_edif_list_add_sa_update_index(fc_port_t *fcport,\n\t\tuint16_t sa_index, uint16_t handle)\n{\n\tstruct edif_list_entry *entry;\n\tunsigned long flags = 0;\n\n\t \n\tentry = qla_edif_list_find_sa_index(fcport, handle);\n\tif (entry) {\n\t\tentry->update_sa_index = sa_index;\n\t\tentry->count = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tentry = kzalloc((sizeof(struct edif_list_entry)), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&entry->next);\n\tentry->handle = handle;\n\tentry->update_sa_index = sa_index;\n\tentry->delete_sa_index = INVALID_EDIF_SA_INDEX;\n\tentry->count = 0;\n\tentry->flags = 0;\n\ttimer_setup(&entry->timer, qla2x00_sa_replace_iocb_timeout, 0);\n\tspin_lock_irqsave(&fcport->edif.indx_list_lock, flags);\n\tlist_add_tail(&entry->next, &fcport->edif.edif_indx_list);\n\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n\treturn 0;\n}\n\n \nstatic void qla_edif_list_delete_sa_index(fc_port_t *fcport, struct edif_list_entry *entry)\n{\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&fcport->edif.indx_list_lock, flags);\n\tlist_del(&entry->next);\n\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n}\n\nint qla_post_sa_replace_work(struct scsi_qla_host *vha,\n\t fc_port_t *fcport, uint16_t nport_handle, struct edif_sa_ctl *sa_ctl)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_SA_REPLACE);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.sa_update.fcport = fcport;\n\te->u.sa_update.sa_ctl = sa_ctl;\n\te->u.sa_update.nport_handle = nport_handle;\n\tfcport->flags |= FCF_ASYNC_ACTIVE;\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void\nqla_edif_sa_ctl_init(scsi_qla_host_t *vha, struct fc_port  *fcport)\n{\n\tql_dbg(ql_dbg_edif, vha, 0x2058,\n\t    \"Init SA_CTL List for fcport - nn %8phN pn %8phN portid=%06x.\\n\",\n\t    fcport->node_name, fcport->port_name, fcport->d_id.b24);\n\n\tfcport->edif.tx_rekey_cnt = 0;\n\tfcport->edif.rx_rekey_cnt = 0;\n\n\tfcport->edif.tx_bytes = 0;\n\tfcport->edif.rx_bytes = 0;\n}\n\nstatic int qla_bsg_check(scsi_qla_host_t *vha, struct bsg_job *bsg_job,\nfc_port_t *fcport)\n{\n\tstruct extra_auth_els *p;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct qla_bsg_auth_els_request *req =\n\t    (struct qla_bsg_auth_els_request *)bsg_job->request;\n\n\tif (!vha->hw->flags.edif_enabled) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x9105,\n\t\t    \"%s edif not enabled\\n\", __func__);\n\t\tgoto done;\n\t}\n\tif (DBELL_INACTIVE(vha)) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t    \"%s doorbell not enabled\\n\", __func__);\n\t\tgoto done;\n\t}\n\n\tp = &req->e;\n\n\t \n\tif (p->sub_cmd == PULL_ELS) {\n\t\tstruct qla_bsg_auth_els_reply *rpl =\n\t\t\t(struct qla_bsg_auth_els_reply *)bsg_job->reply;\n\n\t\tqla_pur_get_pending(vha, fcport, bsg_job);\n\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t\"%s %s %8phN sid=%x. xchg %x, nb=%xh bsg ptr %p\\n\",\n\t\t\t__func__, sc_to_str(p->sub_cmd), fcport->port_name,\n\t\t\tfcport->d_id.b24, rpl->rx_xchg_address,\n\t\t\trpl->r.reply_payload_rcv_len, bsg_job);\n\n\t\tgoto done;\n\t}\n\treturn 0;\n\ndone:\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\tbsg_reply->reply_payload_rcv_len);\n\treturn -EIO;\n}\n\nfc_port_t *\nqla2x00_find_fcport_by_pid(scsi_qla_host_t *vha, port_id_t *id)\n{\n\tfc_port_t *f, *tf;\n\n\tf = NULL;\n\tlist_for_each_entry_safe(f, tf, &vha->vp_fcports, list) {\n\t\tif (f->d_id.b24 == id->b24)\n\t\t\treturn f;\n\t}\n\treturn NULL;\n}\n\n \nstatic bool\nqla_edif_app_check(scsi_qla_host_t *vha, struct app_id appid)\n{\n\t \n\n\tif (appid.app_vid != EDIF_APP_ID) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d, \"%s app id not ok (%x)\",\n\t\t    __func__, appid.app_vid);\n\t\treturn false;\n\t}\n\n\tif (appid.version != EDIF_VERSION1) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d, \"%s app version is not ok (%x)\",\n\t\t    __func__, appid.version);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void\nqla_edif_free_sa_ctl(fc_port_t *fcport, struct edif_sa_ctl *sa_ctl,\n\tint index)\n{\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&fcport->edif.sa_list_lock, flags);\n\tlist_del(&sa_ctl->next);\n\tspin_unlock_irqrestore(&fcport->edif.sa_list_lock, flags);\n\tif (index >= 512)\n\t\tfcport->edif.tx_rekey_cnt--;\n\telse\n\t\tfcport->edif.rx_rekey_cnt--;\n\tkfree(sa_ctl);\n}\n\n \nstatic void qla_edif_add_sa_index_to_freepool(fc_port_t *fcport, int dir,\n\t\tuint16_t sa_index)\n{\n\tvoid *sa_id_map;\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags = 0;\n\tu16 lsa_index = sa_index;\n\n\tql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,\n\t    \"%s: entry\\n\", __func__);\n\n\tif (dir) {\n\t\tsa_id_map = ha->edif_tx_sa_id_map;\n\t\tlsa_index -= EDIF_TX_SA_INDEX_BASE;\n\t} else {\n\t\tsa_id_map = ha->edif_rx_sa_id_map;\n\t}\n\n\tspin_lock_irqsave(&ha->sadb_fp_lock, flags);\n\tclear_bit(lsa_index, sa_id_map);\n\tspin_unlock_irqrestore(&ha->sadb_fp_lock, flags);\n\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t    \"%s: index %d added to free pool\\n\", __func__, sa_index);\n}\n\nstatic void __qla2x00_release_all_sadb(struct scsi_qla_host *vha,\n\tstruct fc_port *fcport, struct edif_sa_index_entry *entry,\n\tint pdir)\n{\n\tstruct edif_list_entry *edif_entry;\n\tstruct  edif_sa_ctl *sa_ctl;\n\tint i, dir;\n\tint key_cnt = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (entry->sa_pair[i].sa_index == INVALID_EDIF_SA_INDEX)\n\t\t\tcontinue;\n\n\t\tif (fcport->loop_id != entry->handle) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t    \"%s: ** WARNING %d** entry handle: 0x%x, lid: 0x%x, sa_index: %d\\n\",\n\t\t\t    __func__, i, entry->handle, fcport->loop_id,\n\t\t\t    entry->sa_pair[i].sa_index);\n\t\t}\n\n\t\t \n\t\tsa_ctl = qla_edif_find_sa_ctl_by_index(fcport,\n\t\t\t\tentry->sa_pair[i].sa_index, pdir);\n\t\tif (sa_ctl &&\n\t\t    qla_edif_find_sa_ctl_by_index(fcport, sa_ctl->index, pdir)) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t    \"%s: freeing sa_ctl for index %d\\n\", __func__, sa_ctl->index);\n\t\t\tqla_edif_free_sa_ctl(fcport, sa_ctl, sa_ctl->index);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t    \"%s: sa_ctl NOT freed, sa_ctl: %p\\n\", __func__, sa_ctl);\n\t\t}\n\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t\"%s: freeing sa_index %d, nph: 0x%x\\n\",\n\t\t\t__func__, entry->sa_pair[i].sa_index, entry->handle);\n\n\t\tdir = (entry->sa_pair[i].sa_index <\n\t\t\tEDIF_TX_SA_INDEX_BASE) ? 0 : 1;\n\t\tqla_edif_add_sa_index_to_freepool(fcport, dir,\n\t\t\tentry->sa_pair[i].sa_index);\n\n\t\t \n\t\tif (pdir != SAU_FLG_TX) {\n\t\t\tedif_entry =\n\t\t\t\tqla_edif_list_find_sa_index(fcport, entry->handle);\n\t\t\tif (edif_entry) {\n\t\t\t\tql_dbg(ql_dbg_edif, vha, 0x5033,\n\t\t\t\t    \"%s: remove edif_entry %p, update_sa_index: 0x%x, delete_sa_index: 0x%x\\n\",\n\t\t\t\t    __func__, edif_entry, edif_entry->update_sa_index,\n\t\t\t\t    edif_entry->delete_sa_index);\n\t\t\t\tqla_edif_list_delete_sa_index(fcport, edif_entry);\n\t\t\t\t \n\t\t\t\tif (edif_entry->delete_sa_index !=\n\t\t\t\t\t\tINVALID_EDIF_SA_INDEX) {\n\t\t\t\t\ttimer_shutdown(&edif_entry->timer);\n\n\t\t\t\t\t \n\t\t\t\t\tfcport->edif.rx_sa_set = 1;\n\t\t\t\t\tfcport->edif.rx_sa_pending = 0;\n\t\t\t\t\tqla_edb_eventcreate(vha,\n\t\t\t\t\t\t\tVND_CMD_AUTH_STATE_SAUPDATE_COMPL,\n\t\t\t\t\t\t\tQL_VND_SA_STAT_SUCCESS,\n\t\t\t\t\t\t\tQL_VND_RX_SA_KEY, fcport);\n\t\t\t\t}\n\t\t\t\tql_dbg(ql_dbg_edif, vha, 0x5033,\n\t\t\t\t    \"%s: release edif_entry %p, update_sa_index: 0x%x, delete_sa_index: 0x%x\\n\",\n\t\t\t\t    __func__, edif_entry, edif_entry->update_sa_index,\n\t\t\t\t    edif_entry->delete_sa_index);\n\n\t\t\t\tkfree(edif_entry);\n\t\t\t}\n\t\t}\n\t\tkey_cnt++;\n\t}\n\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t    \"%s: %d %s keys released\\n\",\n\t    __func__, key_cnt, pdir ? \"tx\" : \"rx\");\n}\n\n \nvoid qla2x00_release_all_sadb(struct scsi_qla_host *vha, struct fc_port *fcport)\n{\n\tstruct edif_sa_index_entry *entry, *tmp;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,\n\t    \"%s: Starting...\\n\", __func__);\n\n\tspin_lock_irqsave(&ha->sadb_lock, flags);\n\n\tlist_for_each_entry_safe(entry, tmp, &ha->sadb_rx_index_list, next) {\n\t\tif (entry->fcport == fcport) {\n\t\t\tlist_del(&entry->next);\n\t\t\tspin_unlock_irqrestore(&ha->sadb_lock, flags);\n\t\t\t__qla2x00_release_all_sadb(vha, fcport, entry, 0);\n\t\t\tkfree(entry);\n\t\t\tspin_lock_irqsave(&ha->sadb_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(entry, tmp, &ha->sadb_tx_index_list, next) {\n\t\tif (entry->fcport == fcport) {\n\t\t\tlist_del(&entry->next);\n\t\t\tspin_unlock_irqrestore(&ha->sadb_lock, flags);\n\n\t\t\t__qla2x00_release_all_sadb(vha, fcport, entry, SAU_FLG_TX);\n\n\t\t\tkfree(entry);\n\t\t\tspin_lock_irqsave(&ha->sadb_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->sadb_lock, flags);\n}\n\n \nstatic int qla_delete_n2n_sess_and_wait(scsi_qla_host_t *vha)\n{\n\tstruct fc_port *fcport;\n\tint rc = -EIO;\n\tulong expire = jiffies + 23 * HZ;\n\n\tif (!N2N_TOPO(vha->hw))\n\t\treturn 0;\n\n\tfcport = NULL;\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (!fcport->n2n_flag)\n\t\t\tcontinue;\n\n\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x2016,\n\t\t       \"%s reset sess at app start \\n\", __func__);\n\n\t\tqla_edif_sa_ctl_init(vha, fcport);\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\n\t\twhile (time_before_eq(jiffies, expire)) {\n\t\t\tif (fcport->disc_state != DSC_DELETE_PEND) {\n\t\t\t\trc = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1);\n\t\t}\n\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int\nqla_edif_app_start(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tint32_t\t\t\trval = 0;\n\tstruct fc_bsg_reply\t*bsg_reply = bsg_job->reply;\n\tstruct app_start\tappstart;\n\tstruct app_start_reply\tappreply;\n\tstruct fc_port  *fcport, *tf;\n\n\tql_log(ql_log_info, vha, 0x1313,\n\t       \"EDIF application registration with driver, FC device connections will be re-established.\\n\");\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &appstart,\n\t    sizeof(struct app_start));\n\n\tql_dbg(ql_dbg_edif, vha, 0x911d, \"%s app_vid=%x app_start_flags %x\\n\",\n\t     __func__, appstart.app_info.app_vid, appstart.app_start_flags);\n\n\tif (DBELL_INACTIVE(vha)) {\n\t\t \n\t\tvha->e_dbell.db_flags |= EDB_ACTIVE;\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (N2N_TOPO(vha->hw)) {\n\t\tlist_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list)\n\t\t\tfcport->n2n_link_reset_cnt = 0;\n\n\t\tif (vha->hw->flags.n2n_fw_acc_sec) {\n\t\t\tbool link_bounce = false;\n\t\t\t \n\t\t\tif (qla_delete_n2n_sess_and_wait(vha))\n\t\t\t\tlink_bounce = true;\n\n\t\t\t \n\t\t\tif (!vha->hw->flags.n2n_bigger || link_bounce) {\n\t\t\t\tset_bit(N2N_LINK_RESET, &vha->dpc_flags);\n\t\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\t}\n\t\t} else {\n\t\t\tqla2x00_wait_for_hba_online(vha);\n\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t\tqla2x00_wait_for_hba_online(vha);\n\t\t}\n\t} else {\n\t\tlist_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x2058,\n\t\t\t       \"FCSP - nn %8phN pn %8phN portid=%06x.\\n\",\n\t\t\t       fcport->node_name, fcport->port_name,\n\t\t\t       fcport->d_id.b24);\n\t\t\tql_dbg(ql_dbg_edif, vha, 0xf084,\n\t\t\t       \"%s: se_sess %p / sess %p from port %8phC \"\n\t\t\t       \"loop_id %#04x s_id %06x logout %d \"\n\t\t\t       \"keep %d els_logo %d disc state %d auth state %d\"\n\t\t\t       \"stop state %d\\n\",\n\t\t\t       __func__, fcport->se_sess, fcport,\n\t\t\t       fcport->port_name, fcport->loop_id,\n\t\t\t       fcport->d_id.b24, fcport->logout_on_delete,\n\t\t\t       fcport->keep_nport_handle, fcport->send_els_logo,\n\t\t\t       fcport->disc_state, fcport->edif.auth_state,\n\t\t\t       fcport->edif.app_stop);\n\n\t\t\tif (atomic_read(&vha->loop_state) == LOOP_DOWN)\n\t\t\t\tbreak;\n\n\t\t\tfcport->login_retry = vha->hw->login_retry_count;\n\n\t\t\tfcport->edif.app_stop = 0;\n\t\t\tfcport->edif.app_sess_online = 0;\n\n\t\t\tif (fcport->scan_state != QLA_FCPORT_FOUND)\n\t\t\t\tcontinue;\n\n\t\t\tif (fcport->port_type == FCT_UNKNOWN &&\n\t\t\t    !fcport->fc4_features)\n\t\t\t\trval = qla24xx_async_gffid(vha, fcport, true);\n\n\t\t\tif (!rval && !(fcport->fc4_features & FC4_FF_TARGET ||\n\t\t\t    fcport->port_type & (FCT_TARGET|FCT_NVME_TARGET)))\n\t\t\t\tcontinue;\n\n\t\t\trval = 0;\n\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t\t       \"%s wwpn %8phC calling qla_edif_reset_auth_wait\\n\",\n\t\t\t       __func__, fcport->port_name);\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t\tqla_edif_sa_ctl_init(vha, fcport);\n\t\t}\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t}\n\n\tif (vha->pur_cinfo.enode_flags != ENODE_ACTIVE) {\n\t\t \n\t\tvha->pur_cinfo.enode_flags = ENODE_ACTIVE;\n\t} else {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911f, \"%s enode already active\\n\",\n\t\t     __func__);\n\t}\n\nout:\n\tappreply.host_support_edif = vha->hw->flags.edif_enabled;\n\tappreply.edif_enode_active = vha->pur_cinfo.enode_flags;\n\tappreply.edif_edb_active = vha->e_dbell.db_flags;\n\tappreply.version = EDIF_VERSION1;\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\n\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\n\tbsg_reply->reply_payload_rcv_len = sg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t\t\t       bsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t\t\t       &appreply,\n\t\t\t\t\t\t\t       sizeof(struct app_start_reply));\n\n\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t    \"%s app start completed with 0x%x\\n\",\n\t    __func__, rval);\n\n\treturn rval;\n}\n\n \nstatic int\nqla_edif_app_stop(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tstruct app_stop         appstop;\n\tstruct fc_bsg_reply     *bsg_reply = bsg_job->reply;\n\tstruct fc_port  *fcport, *tf;\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &appstop,\n\t    sizeof(struct app_stop));\n\n\tql_dbg(ql_dbg_edif, vha, 0x911d, \"%s Stopping APP: app_vid=%x\\n\",\n\t    __func__, appstop.app_info.app_vid);\n\n\t \n\n\t \n\tqla_enode_stop(vha);         \n\tqla_edb_stop(vha);           \n\n\tlist_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {\n\t\tif (!(fcport->flags & FCF_FCSP_DEVICE))\n\t\t\tcontinue;\n\n\t\tif (fcport->flags & FCF_FCSP_DEVICE) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0xf084,\n\t\t\t    \"%s: sess %p from port %8phC lid %#04x s_id %06x logout %d keep %d els_logo %d\\n\",\n\t\t\t    __func__, fcport,\n\t\t\t    fcport->port_name, fcport->loop_id, fcport->d_id.b24,\n\t\t\t    fcport->logout_on_delete, fcport->keep_nport_handle,\n\t\t\t    fcport->send_els_logo);\n\n\t\t\tif (atomic_read(&vha->loop_state) == LOOP_DOWN)\n\t\t\t\tbreak;\n\n\t\t\tfcport->edif.app_stop = 1;\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t\t\t\"%s wwpn %8phC calling qla_edif_reset_auth_wait\\n\",\n\t\t\t\t__func__, fcport->port_name);\n\n\t\t\tfcport->send_els_logo = 1;\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t}\n\t}\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\n\t \n\n\treturn 0;\n}\n\nstatic int\nqla_edif_app_chk_sa_update(scsi_qla_host_t *vha, fc_port_t *fcport,\n\t\tstruct app_plogi_reply *appplogireply)\n{\n\tint\tret = 0;\n\n\tif (!(fcport->edif.rx_sa_set && fcport->edif.tx_sa_set)) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t    \"%s: wwpn %8phC Both SA indexes has not been SET TX %d, RX %d.\\n\",\n\t\t    __func__, fcport->port_name, fcport->edif.tx_sa_set,\n\t\t    fcport->edif.rx_sa_set);\n\t\tappplogireply->prli_status = 0;\n\t\tret = 1;\n\t} else  {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t    \"%s wwpn %8phC Both SA(s) updated.\\n\", __func__,\n\t\t    fcport->port_name);\n\t\tfcport->edif.rx_sa_set = fcport->edif.tx_sa_set = 0;\n\t\tfcport->edif.rx_sa_pending = fcport->edif.tx_sa_pending = 0;\n\t\tappplogireply->prli_status = 1;\n\t}\n\treturn ret;\n}\n\n \nstatic int\nqla_edif_app_authok(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tstruct auth_complete_cmd appplogiok;\n\tstruct app_plogi_reply\tappplogireply = {0};\n\tstruct fc_bsg_reply\t*bsg_reply = bsg_job->reply;\n\tfc_port_t\t\t*fcport = NULL;\n\tport_id_t\t\tportid = {0};\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &appplogiok,\n\t    sizeof(struct auth_complete_cmd));\n\n\t \n\tportid.b.domain = appplogiok.u.d_id.b.domain;\n\tportid.b.area   = appplogiok.u.d_id.b.area;\n\tportid.b.al_pa  = appplogiok.u.d_id.b.al_pa;\n\n\tappplogireply.version = EDIF_VERSION1;\n\tswitch (appplogiok.type) {\n\tcase PL_TYPE_WWPN:\n\t\tfcport = qla2x00_find_fcport_by_wwpn(vha,\n\t\t    appplogiok.u.wwpn, 0);\n\t\tif (!fcport)\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t    \"%s wwpn lookup failed: %8phC\\n\",\n\t\t\t    __func__, appplogiok.u.wwpn);\n\t\tbreak;\n\tcase PL_TYPE_DID:\n\t\tfcport = qla2x00_find_fcport_by_pid(vha, &portid);\n\t\tif (!fcport)\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t    \"%s d_id lookup failed: %x\\n\", __func__,\n\t\t\t    portid.b24);\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s undefined type: %x\\n\", __func__,\n\t\t    appplogiok.type);\n\t\tbreak;\n\t}\n\n\tif (!fcport) {\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\tgoto errstate_exit;\n\t}\n\n\t \n\tif (atomic_read(&fcport->state) == FCS_ONLINE) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s Skipping PRLI complete based on rekey\\n\", __func__);\n\t\tappplogireply.prli_status = 1;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\t\tqla_edif_app_chk_sa_update(vha, fcport, &appplogireply);\n\t\tgoto errstate_exit;\n\t}\n\n\t \n\tif (fcport->disc_state != DSC_LOGIN_AUTH_PEND) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t    \"%s wwpn %8phC is not in auth pending state (%x)\\n\",\n\t\t    __func__, fcport->port_name, fcport->disc_state);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\t\tappplogireply.prli_status = 0;\n\t\tgoto errstate_exit;\n\t}\n\n\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\tappplogireply.prli_status = 1;\n\tfcport->edif.authok = 1;\n\tif (!(fcport->edif.rx_sa_set && fcport->edif.tx_sa_set)) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t    \"%s: wwpn %8phC Both SA indexes has not been SET TX %d, RX %d.\\n\",\n\t\t    __func__, fcport->port_name, fcport->edif.tx_sa_set,\n\t\t    fcport->edif.rx_sa_set);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\t\tappplogireply.prli_status = 0;\n\t\tgoto errstate_exit;\n\n\t} else {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t    \"%s wwpn %8phC Both SA(s) updated.\\n\", __func__,\n\t\t    fcport->port_name);\n\t\tfcport->edif.rx_sa_set = fcport->edif.tx_sa_set = 0;\n\t\tfcport->edif.rx_sa_pending = fcport->edif.tx_sa_pending = 0;\n\t}\n\n\tif (qla_ini_mode_enabled(vha)) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t    \"%s AUTH complete - RESUME with prli for wwpn %8phC\\n\",\n\t\t    __func__, fcport->port_name);\n\t\tqla24xx_post_prli_work(vha, fcport);\n\t}\n\nerrstate_exit:\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->reply_payload_rcv_len = sg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t\t\t       bsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t\t\t       &appplogireply,\n\t\t\t\t\t\t\t       sizeof(struct app_plogi_reply));\n\n\treturn 0;\n}\n\n \nstatic int\nqla_edif_app_authfail(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tint32_t\t\t\trval = 0;\n\tstruct auth_complete_cmd appplogifail;\n\tstruct fc_bsg_reply\t*bsg_reply = bsg_job->reply;\n\tfc_port_t\t\t*fcport = NULL;\n\tport_id_t\t\tportid = {0};\n\n\tql_dbg(ql_dbg_edif, vha, 0x911d, \"%s app auth fail\\n\", __func__);\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &appplogifail,\n\t    sizeof(struct auth_complete_cmd));\n\n\t \n\tportid.b.domain = appplogifail.u.d_id.b.domain;\n\tportid.b.area   = appplogifail.u.d_id.b.area;\n\tportid.b.al_pa  = appplogifail.u.d_id.b.al_pa;\n\n\t \n\tswitch (appplogifail.type) {\n\tcase PL_TYPE_WWPN:\n\t\tfcport = qla2x00_find_fcport_by_wwpn(vha,\n\t\t    appplogifail.u.wwpn, 0);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\t\tbreak;\n\tcase PL_TYPE_DID:\n\t\tfcport = qla2x00_find_fcport_by_pid(vha, &portid);\n\t\tif (!fcport)\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t    \"%s d_id lookup failed: %x\\n\", __func__,\n\t\t\t    portid.b24);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t    \"%s undefined type: %x\\n\", __func__,\n\t\t    appplogifail.type);\n\t\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\trval = -1;\n\t\tbreak;\n\t}\n\n\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t    \"%s fcport is 0x%p\\n\", __func__, fcport);\n\n\tif (fcport) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x911e,\n\t\t    \"%s reset the auth process - %8phC, loopid=%x portid=%06x.\\n\",\n\t\t    __func__, fcport->port_name, fcport->loop_id, fcport->d_id.b24);\n\n\t\tif (qla_ini_mode_enabled(fcport->vha)) {\n\t\t\tfcport->send_els_logo = 1;\n\t\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\t}\n\t}\n\n\treturn rval;\n}\n\n \nstatic int\nqla_edif_app_getfcinfo(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tint32_t\t\t\trval = 0;\n\tint32_t\t\t\tpcnt = 0;\n\tstruct fc_bsg_reply\t*bsg_reply = bsg_job->reply;\n\tstruct app_pinfo_req\tapp_req;\n\tstruct app_pinfo_reply\t*app_reply;\n\tport_id_t\t\ttdid;\n\n\tql_dbg(ql_dbg_edif, vha, 0x911d, \"%s app get fcinfo\\n\", __func__);\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &app_req,\n\t    sizeof(struct app_pinfo_req));\n\n\tapp_reply = kzalloc((sizeof(struct app_pinfo_reply) +\n\t    sizeof(struct app_pinfo) * app_req.num_ports), GFP_KERNEL);\n\n\tif (!app_reply) {\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\trval = -1;\n\t} else {\n\t\tstruct fc_port\t*fcport = NULL, *tf;\n\n\t\tapp_reply->version = EDIF_VERSION1;\n\n\t\tlist_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {\n\t\t\tif (!(fcport->flags & FCF_FCSP_DEVICE))\n\t\t\t\tcontinue;\n\n\t\t\ttdid.b.domain = app_req.remote_pid.domain;\n\t\t\ttdid.b.area = app_req.remote_pid.area;\n\t\t\ttdid.b.al_pa = app_req.remote_pid.al_pa;\n\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x2058,\n\t\t\t    \"APP request entry - portid=%06x.\\n\", tdid.b24);\n\n\t\t\t \n\t\t\tif (pcnt >= app_req.num_ports)\n\t\t\t\tbreak;\n\n\t\t\tif (tdid.b24 != 0 && tdid.b24 != fcport->d_id.b24)\n\t\t\t\tcontinue;\n\n\t\t\tif (!N2N_TOPO(vha->hw)) {\n\t\t\t\tif (fcport->scan_state != QLA_FCPORT_FOUND)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (fcport->port_type == FCT_UNKNOWN &&\n\t\t\t\t    !fcport->fc4_features)\n\t\t\t\t\trval = qla24xx_async_gffid(vha, fcport,\n\t\t\t\t\t\t\t\t   true);\n\n\t\t\t\tif (!rval &&\n\t\t\t\t    !(fcport->fc4_features & FC4_FF_TARGET ||\n\t\t\t\t      fcport->port_type &\n\t\t\t\t      (FCT_TARGET | FCT_NVME_TARGET)))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trval = 0;\n\n\t\t\tapp_reply->ports[pcnt].version = EDIF_VERSION1;\n\t\t\tapp_reply->ports[pcnt].remote_type =\n\t\t\t\tVND_CMD_RTYPE_UNKNOWN;\n\t\t\tif (fcport->port_type & (FCT_NVME_TARGET | FCT_TARGET))\n\t\t\t\tapp_reply->ports[pcnt].remote_type |=\n\t\t\t\t\tVND_CMD_RTYPE_TARGET;\n\t\t\tif (fcport->port_type & (FCT_NVME_INITIATOR | FCT_INITIATOR))\n\t\t\t\tapp_reply->ports[pcnt].remote_type |=\n\t\t\t\t\tVND_CMD_RTYPE_INITIATOR;\n\n\t\t\tapp_reply->ports[pcnt].remote_pid = fcport->d_id;\n\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x2058,\n\t\t\t    \"Found FC_SP fcport - nn %8phN pn %8phN pcnt %d portid=%06x secure %d.\\n\",\n\t\t\t    fcport->node_name, fcport->port_name, pcnt,\n\t\t\t    fcport->d_id.b24, fcport->flags & FCF_FCSP_DEVICE);\n\n\t\t\tswitch (fcport->edif.auth_state) {\n\t\t\tcase VND_CMD_AUTH_STATE_ELS_RCVD:\n\t\t\t\tif (fcport->disc_state == DSC_LOGIN_AUTH_PEND) {\n\t\t\t\t\tfcport->edif.auth_state = VND_CMD_AUTH_STATE_NEEDED;\n\t\t\t\t\tapp_reply->ports[pcnt].auth_state =\n\t\t\t\t\t\tVND_CMD_AUTH_STATE_NEEDED;\n\t\t\t\t} else {\n\t\t\t\t\tapp_reply->ports[pcnt].auth_state =\n\t\t\t\t\t\tVND_CMD_AUTH_STATE_ELS_RCVD;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tapp_reply->ports[pcnt].auth_state = fcport->edif.auth_state;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmemcpy(app_reply->ports[pcnt].remote_wwpn,\n\t\t\t    fcport->port_name, 8);\n\n\t\t\tapp_reply->ports[pcnt].remote_state =\n\t\t\t\t(atomic_read(&fcport->state) ==\n\t\t\t\t    FCS_ONLINE ? 1 : 0);\n\n\t\t\tpcnt++;\n\n\t\t\tif (tdid.b24 != 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tapp_reply->port_count = pcnt;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\t}\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->reply_payload_rcv_len = sg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t\t\t       bsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t\t\t       app_reply,\n\t\t\t\t\t\t\t       sizeof(struct app_pinfo_reply) + sizeof(struct app_pinfo) * pcnt);\n\n\tkfree(app_reply);\n\n\treturn rval;\n}\n\n \nstatic int32_t\nqla_edif_app_getstats(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tint32_t\t\t\trval = 0;\n\tstruct fc_bsg_reply\t*bsg_reply = bsg_job->reply;\n\tuint32_t size;\n\n\tstruct app_sinfo_req\tapp_req;\n\tstruct app_stats_reply\t*app_reply;\n\tuint32_t pcnt = 0;\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &app_req,\n\t    sizeof(struct app_sinfo_req));\n\tif (app_req.num_ports == 0) {\n\t\tql_dbg(ql_dbg_async, vha, 0x911d,\n\t\t   \"%s app did not indicate number of ports to return\\n\",\n\t\t    __func__);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\trval = -1;\n\t}\n\n\tsize = sizeof(struct app_stats_reply) +\n\t    (sizeof(struct app_sinfo) * app_req.num_ports);\n\n\tapp_reply = kzalloc(size, GFP_KERNEL);\n\tif (!app_reply) {\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\trval = -1;\n\t} else {\n\t\tstruct fc_port\t*fcport = NULL, *tf;\n\n\t\tapp_reply->version = EDIF_VERSION1;\n\n\t\tlist_for_each_entry_safe(fcport, tf, &vha->vp_fcports, list) {\n\t\t\tif (fcport->edif.enable) {\n\t\t\t\tif (pcnt > app_req.num_ports)\n\t\t\t\t\tbreak;\n\n\t\t\t\tapp_reply->elem[pcnt].rekey_count =\n\t\t\t\t    fcport->edif.rekey_cnt;\n\t\t\t\tapp_reply->elem[pcnt].tx_bytes =\n\t\t\t\t    fcport->edif.tx_bytes;\n\t\t\t\tapp_reply->elem[pcnt].rx_bytes =\n\t\t\t\t    fcport->edif.rx_bytes;\n\n\t\t\t\tmemcpy(app_reply->elem[pcnt].remote_wwpn,\n\t\t\t\t    fcport->port_name, 8);\n\n\t\t\t\tpcnt++;\n\t\t\t}\n\t\t}\n\t\tapp_reply->elem_count = pcnt;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\t}\n\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tbsg_reply->reply_payload_rcv_len =\n\t    sg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t       bsg_job->reply_payload.sg_cnt, app_reply,\n\t       sizeof(struct app_stats_reply) + (sizeof(struct app_sinfo) * pcnt));\n\n\tkfree(app_reply);\n\n\treturn rval;\n}\n\nstatic int32_t\nqla_edif_ack(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tstruct fc_port *fcport;\n\tstruct aen_complete_cmd ack;\n\tstruct fc_bsg_reply     *bsg_reply = bsg_job->reply;\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\t  bsg_job->request_payload.sg_cnt, &ack, sizeof(ack));\n\n\tql_dbg(ql_dbg_edif, vha, 0x70cf,\n\t       \"%s: %06x event_code %x\\n\",\n\t       __func__, ack.port_id.b24, ack.event_code);\n\n\tfcport = qla2x00_find_fcport_by_pid(vha, &ack.port_id);\n\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\n\tif (!fcport) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x70cf,\n\t\t       \"%s: unable to find fcport %06x \\n\",\n\t\t       __func__, ack.port_id.b24);\n\t\treturn 0;\n\t}\n\n\tswitch (ack.event_code) {\n\tcase VND_CMD_AUTH_STATE_SESSION_SHUTDOWN:\n\t\tfcport->edif.sess_down_acked = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int qla_edif_consume_dbell(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_reply\t*bsg_reply = bsg_job->reply;\n\tu32 sg_skip, reply_payload_len;\n\tbool keep;\n\tstruct edb_node *dbnode = NULL;\n\tstruct edif_app_dbell ap;\n\tint dat_size = 0;\n\n\tsg_skip = 0;\n\treply_payload_len = bsg_job->reply_payload.payload_len;\n\n\twhile ((reply_payload_len - sg_skip) >= sizeof(struct edb_node)) {\n\t\tdbnode = qla_edb_getnext(vha);\n\t\tif (dbnode) {\n\t\t\tkeep = true;\n\t\t\tdat_size = 0;\n\t\t\tap.event_code = dbnode->ntype;\n\t\t\tswitch (dbnode->ntype) {\n\t\t\tcase VND_CMD_AUTH_STATE_SESSION_SHUTDOWN:\n\t\t\tcase VND_CMD_AUTH_STATE_NEEDED:\n\t\t\t\tap.port_id = dbnode->u.plogi_did;\n\t\t\t\tdat_size += sizeof(ap.port_id);\n\t\t\t\tbreak;\n\t\t\tcase VND_CMD_AUTH_STATE_ELS_RCVD:\n\t\t\t\tap.port_id = dbnode->u.els_sid;\n\t\t\t\tdat_size += sizeof(ap.port_id);\n\t\t\t\tbreak;\n\t\t\tcase VND_CMD_AUTH_STATE_SAUPDATE_COMPL:\n\t\t\t\tap.port_id = dbnode->u.sa_aen.port_id;\n\t\t\t\tmemcpy(&ap.event_data, &dbnode->u,\n\t\t\t\t    sizeof(struct edif_sa_update_aen));\n\t\t\t\tdat_size += sizeof(struct edif_sa_update_aen);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep = false;\n\t\t\t\tql_log(ql_log_warn, vha, 0x09102,\n\t\t\t\t\t\"%s unknown DB type=%d %p\\n\",\n\t\t\t\t\t__func__, dbnode->ntype, dbnode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tap.event_data_size = dat_size;\n\t\t\t \n\t\t\tdat_size += 8;\n\t\t\tif (keep)\n\t\t\t\tsg_skip += sg_copy_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t\tbsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t\t&ap, dat_size, sg_skip, false);\n\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t\t\t\"%s Doorbell consumed : type=%d %p\\n\",\n\t\t\t\t__func__, dbnode->ntype, dbnode);\n\n\t\t\tkfree(dbnode);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\tbsg_reply->reply_payload_rcv_len = sg_skip;\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\n\treturn 0;\n}\n\nstatic void __qla_edif_dbell_bsg_done(scsi_qla_host_t *vha, struct bsg_job *bsg_job,\n\tu32 delay)\n{\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\n\t \n\tif (delay)\n\t\tmsleep(delay);\n\n\tqla_edif_consume_dbell(vha, bsg_job);\n\n\tbsg_job_done(bsg_job, bsg_reply->result, bsg_reply->reply_payload_rcv_len);\n}\n\nstatic void qla_edif_dbell_bsg_done(scsi_qla_host_t *vha)\n{\n\tunsigned long flags;\n\tstruct bsg_job *prev_bsg_job = NULL;\n\n\tspin_lock_irqsave(&vha->e_dbell.db_lock, flags);\n\tif (vha->e_dbell.dbell_bsg_job) {\n\t\tprev_bsg_job = vha->e_dbell.dbell_bsg_job;\n\t\tvha->e_dbell.dbell_bsg_job = NULL;\n\t}\n\tspin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);\n\n\tif (prev_bsg_job)\n\t\t__qla_edif_dbell_bsg_done(vha, prev_bsg_job, 0);\n}\n\nstatic int\nqla_edif_dbell_bsg(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tunsigned long flags;\n\tbool return_bsg = false;\n\n\t \n\tqla_edif_dbell_bsg_done(vha);\n\n\tspin_lock_irqsave(&vha->e_dbell.db_lock, flags);\n\tif (list_empty(&vha->e_dbell.head) && DBELL_ACTIVE(vha)) {\n\t\t \n\t\tvha->e_dbell.dbell_bsg_job = bsg_job;\n\t\tvha->e_dbell.bsg_expire = jiffies + 10 * HZ;\n\t} else {\n\t\treturn_bsg = true;\n\t}\n\tspin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);\n\n\tif (return_bsg)\n\t\t__qla_edif_dbell_bsg_done(vha, bsg_job, 1);\n\n\treturn 0;\n}\n\nint32_t\nqla_edif_app_mgmt(struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request\t*bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply\t*bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t\t\t*vha = shost_priv(host);\n\tstruct app_id\t\tappcheck;\n\tbool done = true;\n\tint32_t         rval = 0;\n\tuint32_t\tvnd_sc = bsg_request->rqst_data.h_vendor.vendor_cmd[1];\n\tu32 level = ql_dbg_edif;\n\n\t \n\tif (vnd_sc == QL_VND_SC_READ_DBELL)\n\t\tlevel = 0;\n\n\tql_dbg(level, vha, 0x911d, \"%s vnd subcmd=%x\\n\",\n\t    __func__, vnd_sc);\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &appcheck,\n\t    sizeof(struct app_id));\n\n\tif (!vha->hw->flags.edif_enabled ||\n\t\ttest_bit(VPORT_DELETE, &vha->dpc_flags)) {\n\t\tql_dbg(level, vha, 0x911d,\n\t\t    \"%s edif not enabled or vp delete. bsg ptr done %p. dpc_flags %lx\\n\",\n\t\t    __func__, bsg_job, vha->dpc_flags);\n\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\tgoto done;\n\t}\n\n\tif (!qla_edif_app_check(vha, appcheck)) {\n\t\tql_dbg(level, vha, 0x911d,\n\t\t    \"%s app checked failed.\\n\",\n\t\t    __func__);\n\n\t\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\tgoto done;\n\t}\n\n\tswitch (vnd_sc) {\n\tcase QL_VND_SC_SA_UPDATE:\n\t\tdone = false;\n\t\trval = qla24xx_sadb_update(bsg_job);\n\t\tbreak;\n\tcase QL_VND_SC_APP_START:\n\t\trval = qla_edif_app_start(vha, bsg_job);\n\t\tbreak;\n\tcase QL_VND_SC_APP_STOP:\n\t\trval = qla_edif_app_stop(vha, bsg_job);\n\t\tbreak;\n\tcase QL_VND_SC_AUTH_OK:\n\t\trval = qla_edif_app_authok(vha, bsg_job);\n\t\tbreak;\n\tcase QL_VND_SC_AUTH_FAIL:\n\t\trval = qla_edif_app_authfail(vha, bsg_job);\n\t\tbreak;\n\tcase QL_VND_SC_GET_FCINFO:\n\t\trval = qla_edif_app_getfcinfo(vha, bsg_job);\n\t\tbreak;\n\tcase QL_VND_SC_GET_STATS:\n\t\trval = qla_edif_app_getstats(vha, bsg_job);\n\t\tbreak;\n\tcase QL_VND_SC_AEN_COMPLETE:\n\t\trval = qla_edif_ack(vha, bsg_job);\n\t\tbreak;\n\tcase QL_VND_SC_READ_DBELL:\n\t\trval = qla_edif_dbell_bsg(vha, bsg_job);\n\t\tdone = false;\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d, \"%s unknown cmd=%x\\n\",\n\t\t    __func__,\n\t\t    bsg_request->rqst_data.h_vendor.vendor_cmd[1]);\n\t\trval = EXT_STATUS_INVALID_PARAM;\n\t\tdone = false;\n\t\tbreak;\n\t}\n\ndone:\n\tif (done) {\n\t\tql_dbg(level, vha, 0x7009,\n\t\t    \"%s: %d  bsg ptr done %p\\n\", __func__, __LINE__, bsg_job);\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t    bsg_reply->reply_payload_rcv_len);\n\t}\n\n\treturn rval;\n}\n\nstatic struct edif_sa_ctl *\nqla_edif_add_sa_ctl(fc_port_t *fcport, struct qla_sa_update_frame *sa_frame,\n\tint dir)\n{\n\tstruct\tedif_sa_ctl *sa_ctl;\n\tstruct qla_sa_update_frame *sap;\n\tint\tindex = sa_frame->fast_sa_index;\n\tunsigned long flags = 0;\n\n\tsa_ctl = kzalloc(sizeof(*sa_ctl), GFP_KERNEL);\n\tif (!sa_ctl) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, fcport->vha, 0x9100,\n\t\t    \"unable to allocate SA CTL\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&sa_ctl->next);\n\tsap = &sa_ctl->sa_frame;\n\t*sap = *sa_frame;\n\tsa_ctl->index = index;\n\tsa_ctl->fcport = fcport;\n\tsa_ctl->flags = 0;\n\tsa_ctl->state = 0L;\n\tql_dbg(ql_dbg_edif, fcport->vha, 0x9100,\n\t    \"%s: Added sa_ctl %p, index %d, state 0x%lx\\n\",\n\t    __func__, sa_ctl, sa_ctl->index, sa_ctl->state);\n\tspin_lock_irqsave(&fcport->edif.sa_list_lock, flags);\n\tif (dir == SAU_FLG_TX)\n\t\tlist_add_tail(&sa_ctl->next, &fcport->edif.tx_sa_list);\n\telse\n\t\tlist_add_tail(&sa_ctl->next, &fcport->edif.rx_sa_list);\n\tspin_unlock_irqrestore(&fcport->edif.sa_list_lock, flags);\n\n\treturn sa_ctl;\n}\n\nvoid\nqla_edif_flush_sa_ctl_lists(fc_port_t *fcport)\n{\n\tstruct edif_sa_ctl *sa_ctl, *tsa_ctl;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&fcport->edif.sa_list_lock, flags);\n\n\tlist_for_each_entry_safe(sa_ctl, tsa_ctl, &fcport->edif.tx_sa_list,\n\t    next) {\n\t\tlist_del(&sa_ctl->next);\n\t\tkfree(sa_ctl);\n\t}\n\n\tlist_for_each_entry_safe(sa_ctl, tsa_ctl, &fcport->edif.rx_sa_list,\n\t    next) {\n\t\tlist_del(&sa_ctl->next);\n\t\tkfree(sa_ctl);\n\t}\n\n\tspin_unlock_irqrestore(&fcport->edif.sa_list_lock, flags);\n}\n\nstruct edif_sa_ctl *\nqla_edif_find_sa_ctl_by_index(fc_port_t *fcport, int index, int dir)\n{\n\tstruct edif_sa_ctl *sa_ctl, *tsa_ctl;\n\tstruct list_head *sa_list;\n\n\tif (dir == SAU_FLG_TX)\n\t\tsa_list = &fcport->edif.tx_sa_list;\n\telse\n\t\tsa_list = &fcport->edif.rx_sa_list;\n\n\tlist_for_each_entry_safe(sa_ctl, tsa_ctl, sa_list, next) {\n\t\tif (test_bit(EDIF_SA_CTL_USED, &sa_ctl->state) &&\n\t\t    sa_ctl->index == index)\n\t\t\treturn sa_ctl;\n\t}\n\treturn NULL;\n}\n\n \nstatic int\nqla24xx_check_sadb_avail_slot(struct bsg_job *bsg_job, fc_port_t *fcport,\n\tstruct qla_sa_update_frame *sa_frame)\n{\n\tstruct edif_sa_ctl *sa_ctl = NULL;\n\tint dir;\n\tuint16_t sa_index;\n\n\tdir = (sa_frame->flags & SAU_FLG_TX);\n\n\t \n\tsa_index = qla_edif_sadb_get_sa_index(fcport, sa_frame);\n\tif (sa_index == RX_DELETE_NO_EDIF_SA_INDEX) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, fcport->vha, 0x3063,\n\t\t    \"%s: rx delete for lid 0x%x, spi 0x%x, no entry found\\n\",\n\t\t    __func__, fcport->loop_id, sa_frame->spi);\n\n\t\t \n\t\tfcport->edif.rx_sa_set = 1;\n\t\tfcport->edif.rx_sa_pending = 0;\n\t\tqla_edb_eventcreate(fcport->vha,\n\t\t    VND_CMD_AUTH_STATE_SAUPDATE_COMPL,\n\t\t    QL_VND_SA_STAT_SUCCESS,\n\t\t    QL_VND_RX_SA_KEY, fcport);\n\n\t\t \n\t\treturn RX_DELETE_NO_EDIF_SA_INDEX;\n\t} else if (sa_index == INVALID_EDIF_SA_INDEX) {\n\t\tql_dbg(ql_dbg_edif, fcport->vha, 0x9100,\n\t\t    \"%s: Failed to get sa_index for spi 0x%x, dir: %d\\n\",\n\t\t    __func__, sa_frame->spi, dir);\n\t\treturn INVALID_EDIF_SA_INDEX;\n\t}\n\n\tql_dbg(ql_dbg_edif, fcport->vha, 0x9100,\n\t    \"%s: index %d allocated to spi 0x%x, dir: %d, nport_handle: 0x%x\\n\",\n\t    __func__, sa_index, sa_frame->spi, dir, fcport->loop_id);\n\n\t \n\tsa_frame->fast_sa_index = sa_index;\n\t \n\tsa_ctl = qla_edif_add_sa_ctl(fcport, sa_frame, dir);\n\tif (!sa_ctl) {\n\t\tql_dbg(ql_dbg_edif, fcport->vha, 0x9100,\n\t\t    \"%s: Failed to add sa_ctl for spi 0x%x, dir: %d, sa_index: %d\\n\",\n\t\t    __func__, sa_frame->spi, dir, sa_index);\n\t\treturn -1;\n\t}\n\n\tset_bit(EDIF_SA_CTL_USED, &sa_ctl->state);\n\n\tif (dir == SAU_FLG_TX)\n\t\tfcport->edif.tx_rekey_cnt++;\n\telse\n\t\tfcport->edif.rx_rekey_cnt++;\n\n\tql_dbg(ql_dbg_edif, fcport->vha, 0x9100,\n\t    \"%s: Found sa_ctl %p, index %d, state 0x%lx, tx_cnt %d, rx_cnt %d, nport_handle: 0x%x\\n\",\n\t    __func__, sa_ctl, sa_ctl->index, sa_ctl->state,\n\t    fcport->edif.tx_rekey_cnt,\n\t    fcport->edif.rx_rekey_cnt, fcport->loop_id);\n\n\treturn 0;\n}\n\n#define QLA_SA_UPDATE_FLAGS_RX_KEY      0x0\n#define QLA_SA_UPDATE_FLAGS_TX_KEY      0x2\n#define EDIF_MSLEEP_INTERVAL 100\n#define EDIF_RETRY_COUNT  50\n\nint\nqla24xx_sadb_update(struct bsg_job *bsg_job)\n{\n\tstruct\tfc_bsg_reply\t*bsg_reply = bsg_job->reply;\n\tstruct Scsi_Host *host = fc_bsg_to_shost(bsg_job);\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tfc_port_t\t\t*fcport = NULL;\n\tsrb_t\t\t\t*sp = NULL;\n\tstruct edif_list_entry *edif_entry = NULL;\n\tint\t\t\tfound = 0;\n\tint\t\t\trval = 0;\n\tint result = 0, cnt;\n\tstruct qla_sa_update_frame sa_frame;\n\tstruct srb_iocb *iocb_cmd;\n\tport_id_t portid;\n\n\tql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x911d,\n\t    \"%s entered, vha: 0x%p\\n\", __func__, vha);\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, &sa_frame,\n\t    sizeof(struct qla_sa_update_frame));\n\n\t \n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x70a1, \"Host is not online\\n\");\n\t\trval = -EIO;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\tgoto done;\n\t}\n\n\tif (DBELL_INACTIVE(vha)) {\n\t\tql_log(ql_log_warn, vha, 0x70a1, \"App not started\\n\");\n\t\trval = -EIO;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\tgoto done;\n\t}\n\n\t \n\tportid.b.domain = sa_frame.port_id.b.domain;\n\tportid.b.area   = sa_frame.port_id.b.area;\n\tportid.b.al_pa  = sa_frame.port_id.b.al_pa;\n\n\tfcport = qla2x00_find_fcport_by_pid(vha, &portid);\n\tif (fcport) {\n\t\tfound = 1;\n\t\tif (sa_frame.flags == QLA_SA_UPDATE_FLAGS_TX_KEY)\n\t\t\tfcport->edif.tx_bytes = 0;\n\t\tif (sa_frame.flags == QLA_SA_UPDATE_FLAGS_RX_KEY)\n\t\t\tfcport->edif.rx_bytes = 0;\n\t}\n\n\tif (!found) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x70a3, \"Failed to find port= %06x\\n\",\n\t\t    sa_frame.port_id.b24);\n\t\trval = -EINVAL;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_NO_CONNECT);\n\t\tgoto done;\n\t}\n\n\t \n\tif (fcport->loop_id == FC_NO_LOOP_ID) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x70e1,\n\t\t    \"%s: %8phN lid=FC_NO_LOOP_ID, spi: 0x%x, DS %d, returning NO_CONNECT\\n\",\n\t\t    __func__, fcport->port_name, sa_frame.spi,\n\t\t    fcport->disc_state);\n\t\trval = -EINVAL;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_NO_CONNECT);\n\t\tgoto done;\n\t}\n\n\t \n\tresult = qla24xx_check_sadb_avail_slot(bsg_job, fcport, &sa_frame);\n\n\t \n\tif (result == INVALID_EDIF_SA_INDEX) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x70e1,\n\t\t    \"%s: %8phN, skipping update.\\n\",\n\t\t    __func__, fcport->port_name);\n\t\trval = -EINVAL;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\tgoto done;\n\n\t \n\t} else if (result == RX_DELETE_NO_EDIF_SA_INDEX) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x70e1,\n\t\t    \"%s: %8phN, skipping rx delete.\\n\",\n\t\t    __func__, fcport->port_name);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\t\tgoto done;\n\t}\n\n\tql_dbg(ql_dbg_edif, vha, 0x70e1,\n\t    \"%s: %8phN, sa_index in sa_frame: %d flags %xh\\n\",\n\t    __func__, fcport->port_name, sa_frame.fast_sa_index,\n\t    sa_frame.flags);\n\n\t \n\tif (((sa_frame.flags & SAU_FLG_TX) == 0) &&\n\t    (sa_frame.flags & SAU_FLG_INV)) {\n\t\tuint16_t nport_handle = fcport->loop_id;\n\t\tuint16_t sa_index = sa_frame.fast_sa_index;\n\n\t\t \n\t\tedif_entry = qla_edif_list_find_sa_index(fcport, fcport->loop_id);\n\t\tif (!edif_entry) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t    \"%s: WARNING: no active sa_index for nport_handle 0x%x, forcing delete for sa_index 0x%x\\n\",\n\t\t\t    __func__, fcport->loop_id, sa_index);\n\t\t\tgoto force_rx_delete;\n\t\t}\n\n\t\t \n\t\tif ((sa_frame.flags & SAU_FLG_FORCE_DELETE) == SAU_FLG_FORCE_DELETE) {\n\t\t\tqla_edif_list_delete_sa_index(fcport, edif_entry);\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t    \"%s: FORCE DELETE flag found for nport_handle 0x%x, sa_index 0x%x, forcing DELETE\\n\",\n\t\t\t    __func__, fcport->loop_id, sa_index);\n\t\t\tkfree(edif_entry);\n\t\t\tgoto force_rx_delete;\n\t\t}\n\n\t\t \n\t\tif (edif_entry->delete_sa_index != INVALID_EDIF_SA_INDEX) {\n\t\t\tstruct edif_sa_ctl *sa_ctl;\n\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t    \"%s: delete for lid 0x%x, delete_sa_index %d is pending\\n\",\n\t\t\t    __func__, edif_entry->handle, edif_entry->delete_sa_index);\n\n\t\t\t \n\t\t\tsa_ctl = qla_edif_find_sa_ctl_by_index(fcport, sa_index,\n\t\t\t    (sa_frame.flags & SAU_FLG_TX));\n\t\t\tif (sa_ctl) {\n\t\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t\t    \"%s: freeing sa_ctl for index %d\\n\",\n\t\t\t\t    __func__, sa_ctl->index);\n\t\t\t\tqla_edif_free_sa_ctl(fcport, sa_ctl, sa_ctl->index);\n\t\t\t}\n\n\t\t\t \n\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t    \"%s: freeing sa_index %d, nph: 0x%x\\n\",\n\t\t\t    __func__, sa_index, nport_handle);\n\t\t\tqla_edif_sadb_delete_sa_index(fcport, nport_handle, sa_index);\n\n\t\t\trval = -EINVAL;\n\t\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\t\tgoto done;\n\t\t}\n\n\t\tfcport->edif.rekey_cnt++;\n\n\t\t \n\t\tedif_entry->fcport = fcport;\n\t\tedif_entry->timer.expires = jiffies + RX_DELAY_DELETE_TIMEOUT * HZ;\n\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s: adding timer, entry: %p, delete sa_index %d, lid 0x%x to edif_list\\n\",\n\t\t    __func__, edif_entry, sa_index, nport_handle);\n\n\t\t \n\t\tadd_timer(&edif_entry->timer);\n\n\t\t \n\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s: delete sa_index %d, lid 0x%x to edif_list. bsg done ptr %p\\n\",\n\t\t    __func__, sa_index, nport_handle, bsg_job);\n\n\t\tedif_entry->delete_sa_index = sa_index;\n\n\t\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\t\tbsg_reply->result = DID_OK << 16;\n\n\t\tgoto done;\n\n\t \n\t} else if (((sa_frame.flags & SAU_FLG_TX) == 0) &&\n\t    ((sa_frame.flags & SAU_FLG_INV) == 0)) {\n\t\t \n\t\tuint32_t nport_handle = fcport->loop_id;\n\t\tuint16_t sa_index = sa_frame.fast_sa_index;\n\t\tint result;\n\n\t\t \n\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s:  adding update sa_index %d, lid 0x%x to edif_list\\n\",\n\t\t    __func__, sa_index, nport_handle);\n\n\t\tresult = qla_edif_list_add_sa_update_index(fcport, sa_index,\n\t\t    nport_handle);\n\t\tif (result) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t    \"%s: SA_UPDATE failed to add new sa index %d to list for lid 0x%x\\n\",\n\t\t\t    __func__, sa_index, nport_handle);\n\t\t}\n\t}\n\tif (sa_frame.flags & SAU_FLG_GMAC_MODE)\n\t\tfcport->edif.aes_gmac = 1;\n\telse\n\t\tfcport->edif.aes_gmac = 0;\n\nforce_rx_delete:\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp) {\n\t\trval = -ENOMEM;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);\n\t\tgoto done;\n\t}\n\n\tsp->type = SRB_SA_UPDATE;\n\tsp->name = \"bsg_sa_update\";\n\tsp->u.bsg_job = bsg_job;\n\t \n\tsp->free = qla2x00_rel_sp;\n\tsp->done = qla2x00_bsg_job_done;\n\tiocb_cmd = &sp->u.iocb_cmd;\n\tiocb_cmd->u.sa_update.sa_frame  = sa_frame;\n\tcnt = 0;\nretry:\n\trval = qla2x00_start_sp(sp);\n\tswitch (rval) {\n\tcase QLA_SUCCESS:\n\t\tbreak;\n\tcase EAGAIN:\n\t\tmsleep(EDIF_MSLEEP_INTERVAL);\n\t\tcnt++;\n\t\tif (cnt < EDIF_RETRY_COUNT)\n\t\t\tgoto retry;\n\n\t\tfallthrough;\n\tdefault:\n\t\tql_log(ql_dbg_edif, vha, 0x70e3,\n\t\t       \"%s qla2x00_start_sp failed=%d.\\n\",\n\t\t       __func__, rval);\n\n\t\tqla2x00_rel_sp(sp);\n\t\trval = -EIO;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);\n\t\tgoto done;\n\t}\n\n\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t    \"%s:  %s sent, hdl=%x, portid=%06x.\\n\",\n\t    __func__, sp->name, sp->handle, fcport->d_id.b24);\n\n\tfcport->edif.rekey_cnt++;\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tSET_DID_STATUS(bsg_reply->result, DID_OK);\n\n\treturn 0;\n\n \ndone:\n\tbsg_job->reply_len = sizeof(struct fc_bsg_reply);\n\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t    \"%s:status: FAIL, result: 0x%x, bsg ptr done %p\\n\",\n\t    __func__, bsg_reply->result, bsg_job);\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t    bsg_reply->reply_payload_rcv_len);\n\n\treturn 0;\n}\n\nstatic void\nqla_enode_free(scsi_qla_host_t *vha, struct enode *node)\n{\n\tnode->ntype = N_UNDEF;\n\tkfree(node);\n}\n\n \nvoid\nqla_enode_init(scsi_qla_host_t *vha)\n{\n\tstruct\tqla_hw_data *ha = vha->hw;\n\tchar\tname[32];\n\n\tif (vha->pur_cinfo.enode_flags == ENODE_ACTIVE) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x09102, \"%s enode still active\\n\",\n\t\t    __func__);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_init(&vha->pur_cinfo.pur_lock);\n\tINIT_LIST_HEAD(&vha->pur_cinfo.head);\n\n\tsnprintf(name, sizeof(name), \"%s_%d_purex\", QLA2XXX_DRIVER_NAME,\n\t    ha->pdev->device);\n}\n\n \nvoid\nqla_enode_stop(scsi_qla_host_t *vha)\n{\n\tunsigned long flags;\n\tstruct enode *node, *q;\n\n\tif (vha->pur_cinfo.enode_flags != ENODE_ACTIVE) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t    \"%s enode not active\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&vha->pur_cinfo.pur_lock, flags);\n\n\tvha->pur_cinfo.enode_flags &= ~ENODE_ACTIVE;  \n\n\t \n\tlist_for_each_entry_safe(node, q, &vha->pur_cinfo.head, list) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x910f,\n\t\t    \"%s freeing enode type=%x, cnt=%x\\n\", __func__, node->ntype,\n\t\t    node->dinfo.nodecnt);\n\t\tlist_del_init(&node->list);\n\t\tqla_enode_free(vha, node);\n\t}\n\tspin_unlock_irqrestore(&vha->pur_cinfo.pur_lock, flags);\n}\n\nstatic void qla_enode_clear(scsi_qla_host_t *vha, port_id_t portid)\n{\n\tunsigned    long flags;\n\tstruct enode    *e, *tmp;\n\tstruct purexevent   *purex;\n\tLIST_HEAD(enode_list);\n\n\tif (vha->pur_cinfo.enode_flags != ENODE_ACTIVE) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t       \"%s enode not active\\n\", __func__);\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&vha->pur_cinfo.pur_lock, flags);\n\tlist_for_each_entry_safe(e, tmp, &vha->pur_cinfo.head, list) {\n\t\tpurex = &e->u.purexinfo;\n\t\tif (purex->pur_info.pur_sid.b24 == portid.b24) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t\t    \"%s free ELS sid=%06x. xchg %x, nb=%xh\\n\",\n\t\t\t    __func__, portid.b24,\n\t\t\t    purex->pur_info.pur_rx_xchg_address,\n\t\t\t    purex->pur_info.pur_bytes_rcvd);\n\n\t\t\tlist_del_init(&e->list);\n\t\t\tlist_add_tail(&e->list, &enode_list);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vha->pur_cinfo.pur_lock, flags);\n\n\tlist_for_each_entry_safe(e, tmp, &enode_list, list) {\n\t\tlist_del_init(&e->list);\n\t\tqla_enode_free(vha, e);\n\t}\n}\n\n \nstatic struct enode *\nqla_enode_alloc(scsi_qla_host_t *vha, uint32_t ntype)\n{\n\tstruct enode\t\t*node;\n\tstruct purexevent\t*purex;\n\n\tnode = kzalloc(RX_ELS_SIZE, GFP_ATOMIC);\n\tif (!node)\n\t\treturn NULL;\n\n\tpurex = &node->u.purexinfo;\n\tpurex->msgp = (u8 *)(node + 1);\n\tpurex->msgp_len = ELS_MAX_PAYLOAD;\n\n\tnode->ntype = ntype;\n\tINIT_LIST_HEAD(&node->list);\n\treturn node;\n}\n\nstatic void\nqla_enode_add(scsi_qla_host_t *vha, struct enode *ptr)\n{\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x9109,\n\t    \"%s add enode for type=%x, cnt=%x\\n\",\n\t    __func__, ptr->ntype, ptr->dinfo.nodecnt);\n\n\tspin_lock_irqsave(&vha->pur_cinfo.pur_lock, flags);\n\tlist_add_tail(&ptr->list, &vha->pur_cinfo.head);\n\tspin_unlock_irqrestore(&vha->pur_cinfo.pur_lock, flags);\n\n\treturn;\n}\n\nstatic struct enode *\nqla_enode_find(scsi_qla_host_t *vha, uint32_t ntype, uint32_t p1, uint32_t p2)\n{\n\tstruct enode\t\t*node_rtn = NULL;\n\tstruct enode\t\t*list_node, *q;\n\tunsigned long\t\tflags;\n\tuint32_t\t\tsid;\n\tstruct purexevent\t*purex;\n\n\t \n\tspin_lock_irqsave(&vha->pur_cinfo.pur_lock, flags);\n\n\tlist_for_each_entry_safe(list_node, q, &vha->pur_cinfo.head, list) {\n\n\t\t \n\t\tpurex = &list_node->u.purexinfo;\n\t\tsid = p1;\n\n\t\tif (purex->pur_info.pur_sid.b24 == sid) {\n\t\t\t \n\t\t\tnode_rtn = list_node;\n\t\t\tlist_del(&list_node->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&vha->pur_cinfo.pur_lock, flags);\n\n\treturn node_rtn;\n}\n\n \nstatic int\nqla_pur_get_pending(scsi_qla_host_t *vha, fc_port_t *fcport,\n\tstruct bsg_job *bsg_job)\n{\n\tstruct enode\t\t*ptr;\n\tstruct purexevent\t*purex;\n\tstruct qla_bsg_auth_els_reply *rpl =\n\t    (struct qla_bsg_auth_els_reply *)bsg_job->reply;\n\n\tbsg_job->reply_len = sizeof(*rpl);\n\n\tptr = qla_enode_find(vha, N_PUREX, fcport->d_id.b24, PUR_GET);\n\tif (!ptr) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x9111,\n\t\t    \"%s no enode data found for %8phN sid=%06x\\n\",\n\t\t    __func__, fcport->port_name, fcport->d_id.b24);\n\t\tSET_DID_STATUS(rpl->r.result, DID_IMM_RETRY);\n\t\treturn -EIO;\n\t}\n\n\t \n\tpurex = &ptr->u.purexinfo;\n\n\t \n\trpl->rx_xchg_address = purex->pur_info.pur_rx_xchg_address;\n\n\tSET_DID_STATUS(rpl->r.result, DID_OK);\n\trpl->r.reply_payload_rcv_len =\n\t    sg_pcopy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\tbsg_job->reply_payload.sg_cnt, purex->msgp,\n\t\tpurex->pur_info.pur_bytes_rcvd, 0);\n\n\t \n\tqla_enode_free(vha, ptr);\n\n\treturn 0;\n}\n\n \nstatic int\nqla_els_reject_iocb(scsi_qla_host_t *vha, struct qla_qpair *qp,\n\tstruct qla_els_pt_arg *a)\n{\n\tstruct els_entry_24xx *els_iocb;\n\n\tels_iocb = __qla2x00_alloc_iocbs(qp, NULL);\n\tif (!els_iocb) {\n\t\tql_log(ql_log_warn, vha, 0x700c,\n\t\t    \"qla2x00_alloc_iocbs failed.\\n\");\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\tqla_els_pt_iocb(vha, els_iocb, a);\n\n\tql_dbg(ql_dbg_edif, vha, 0x0183,\n\t    \"Sending ELS reject ox_id %04x s:%06x -> d:%06x\\n\",\n\t    a->ox_id, a->sid.b24, a->did.b24);\n\tql_dump_buffer(ql_dbg_edif + ql_dbg_verbose, vha, 0x0185,\n\t    vha->hw->elsrej.c, sizeof(*vha->hw->elsrej.c));\n\t \n\twmb();\n\tqla2x00_start_iocbs(vha, qp->req);\n\treturn 0;\n}\n\nvoid\nqla_edb_init(scsi_qla_host_t *vha)\n{\n\tif (DBELL_ACTIVE(vha)) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t    \"edif db already initialized, cannot reinit\\n\");\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_init(&vha->e_dbell.db_lock);\n\tINIT_LIST_HEAD(&vha->e_dbell.head);\n}\n\nstatic void qla_edb_clear(scsi_qla_host_t *vha, port_id_t portid)\n{\n\tunsigned long flags;\n\tstruct edb_node *e, *tmp;\n\tport_id_t sid;\n\tLIST_HEAD(edb_list);\n\n\tif (DBELL_INACTIVE(vha)) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t       \"%s doorbell not enabled\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&vha->e_dbell.db_lock, flags);\n\tlist_for_each_entry_safe(e, tmp, &vha->e_dbell.head, list) {\n\t\tswitch (e->ntype) {\n\t\tcase VND_CMD_AUTH_STATE_NEEDED:\n\t\tcase VND_CMD_AUTH_STATE_SESSION_SHUTDOWN:\n\t\t\tsid = e->u.plogi_did;\n\t\t\tbreak;\n\t\tcase VND_CMD_AUTH_STATE_ELS_RCVD:\n\t\t\tsid = e->u.els_sid;\n\t\t\tbreak;\n\t\tcase VND_CMD_AUTH_STATE_SAUPDATE_COMPL:\n\t\t\t \n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tql_log(ql_log_warn, vha, 0x09102,\n\t\t\t       \"%s unknown node type: %x\\n\", __func__, e->ntype);\n\t\t\tsid.b24 = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (sid.b24 == portid.b24) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x910f,\n\t\t\t       \"%s free doorbell event : node type = %x %p\\n\",\n\t\t\t       __func__, e->ntype, e);\n\t\t\tlist_del_init(&e->list);\n\t\t\tlist_add_tail(&e->list, &edb_list);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);\n\n\tlist_for_each_entry_safe(e, tmp, &edb_list, list)\n\t\tqla_edb_node_free(vha, e);\n}\n\n \n\nvoid\nqla_edb_stop(scsi_qla_host_t *vha)\n{\n\tunsigned long flags;\n\tstruct edb_node *node, *q;\n\n\tif (DBELL_INACTIVE(vha)) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t    \"%s doorbell not enabled\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&vha->e_dbell.db_lock, flags);\n\n\tvha->e_dbell.db_flags &= ~EDB_ACTIVE;  \n\t \n\tlist_for_each_entry_safe(node, q, &vha->e_dbell.head, list) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x910f,\n\t\t    \"%s freeing edb_node type=%x\\n\",\n\t\t    __func__, node->ntype);\n\t\tqla_edb_node_free(vha, node);\n\t}\n\tspin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);\n\n\tqla_edif_dbell_bsg_done(vha);\n}\n\nstatic struct edb_node *\nqla_edb_node_alloc(scsi_qla_host_t *vha, uint32_t ntype)\n{\n\tstruct edb_node\t*node;\n\n\tnode = kzalloc(sizeof(*node), GFP_ATOMIC);\n\tif (!node) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x9100,\n\t\t    \"edb node unable to be allocated\\n\");\n\t\treturn NULL;\n\t}\n\n\tnode->ntype = ntype;\n\tINIT_LIST_HEAD(&node->list);\n\treturn node;\n}\n\n \nstatic bool\nqla_edb_node_add(scsi_qla_host_t *vha, struct edb_node *ptr)\n{\n\tunsigned long\t\tflags;\n\n\tif (DBELL_INACTIVE(vha)) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t    \"%s doorbell not enabled\\n\", __func__);\n\t\treturn false;\n\t}\n\n\tspin_lock_irqsave(&vha->e_dbell.db_lock, flags);\n\tlist_add_tail(&ptr->list, &vha->e_dbell.head);\n\tspin_unlock_irqrestore(&vha->e_dbell.db_lock, flags);\n\n\treturn true;\n}\n\n \nvoid\nqla_edb_eventcreate(scsi_qla_host_t *vha, uint32_t dbtype,\n\tuint32_t data, uint32_t data2, fc_port_t\t*sfcport)\n{\n\tstruct edb_node\t*edbnode;\n\tfc_port_t *fcport = sfcport;\n\tport_id_t id;\n\n\tif (!vha->hw->flags.edif_enabled) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (DBELL_INACTIVE(vha)) {\n\t\tif (fcport)\n\t\t\tfcport->edif.auth_state = dbtype;\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t    \"%s doorbell not enabled (type=%d\\n\", __func__, dbtype);\n\t\treturn;\n\t}\n\n\tedbnode = qla_edb_node_alloc(vha, dbtype);\n\tif (!edbnode) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t    \"%s unable to alloc db node\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!fcport) {\n\t\tid.b.domain = (data >> 16) & 0xff;\n\t\tid.b.area = (data >> 8) & 0xff;\n\t\tid.b.al_pa = data & 0xff;\n\t\tql_dbg(ql_dbg_edif, vha, 0x09222,\n\t\t    \"%s: Arrived s_id: %06x\\n\", __func__,\n\t\t    id.b24);\n\t\tfcport = qla2x00_find_fcport_by_pid(vha, &id);\n\t\tif (!fcport) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t\t    \"%s can't find fcport for sid= 0x%x - ignoring\\n\",\n\t\t\t__func__, id.b24);\n\t\t\tkfree(edbnode);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tswitch (dbtype) {\n\tcase VND_CMD_AUTH_STATE_NEEDED:\n\tcase VND_CMD_AUTH_STATE_SESSION_SHUTDOWN:\n\t\tedbnode->u.plogi_did.b24 = fcport->d_id.b24;\n\t\tbreak;\n\tcase VND_CMD_AUTH_STATE_ELS_RCVD:\n\t\tedbnode->u.els_sid.b24 = fcport->d_id.b24;\n\t\tbreak;\n\tcase VND_CMD_AUTH_STATE_SAUPDATE_COMPL:\n\t\tedbnode->u.sa_aen.port_id = fcport->d_id;\n\t\tedbnode->u.sa_aen.status =  data;\n\t\tedbnode->u.sa_aen.key_type =  data2;\n\t\tedbnode->u.sa_aen.version = EDIF_VERSION1;\n\t\tbreak;\n\tdefault:\n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t\t\"%s unknown type: %x\\n\", __func__, dbtype);\n\t\tkfree(edbnode);\n\t\tedbnode = NULL;\n\t\tbreak;\n\t}\n\n\tif (edbnode) {\n\t\tif (!qla_edb_node_add(vha, edbnode)) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t\t    \"%s unable to add dbnode\\n\", __func__);\n\t\t\tkfree(edbnode);\n\t\t\treturn;\n\t\t}\n\t\tql_dbg(ql_dbg_edif, vha, 0x09102,\n\t\t    \"%s Doorbell produced : type=%d %p\\n\", __func__, dbtype, edbnode);\n\t\tqla_edif_dbell_bsg_done(vha);\n\t\tif (fcport)\n\t\t\tfcport->edif.auth_state = dbtype;\n\t}\n}\n\nvoid\nqla_edif_timer(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!vha->vp_idx && N2N_TOPO(ha) && ha->flags.n2n_fw_acc_sec) {\n\t\tif (DBELL_INACTIVE(vha) &&\n\t\t    ha->edif_post_stop_cnt_down) {\n\t\t\tha->edif_post_stop_cnt_down--;\n\n\t\t\t \n\t\t\tif (ha->edif_post_stop_cnt_down == 0) {\n\t\t\t\tql_dbg(ql_dbg_async, vha, 0x911d,\n\t\t\t\t       \"%s chip reset to turn off PLOGI ACC + secure\\n\",\n\t\t\t\t       __func__);\n\t\t\t\tset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\n\t\t\t}\n\t\t} else {\n\t\t\tha->edif_post_stop_cnt_down = 60;\n\t\t}\n\t}\n\n\tif (vha->e_dbell.dbell_bsg_job && time_after_eq(jiffies, vha->e_dbell.bsg_expire))\n\t\tqla_edif_dbell_bsg_done(vha);\n}\n\nstatic void qla_noop_sp_done(srb_t *sp, int res)\n{\n\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n}\n\n \nint\nqla24xx_issue_sa_replace_iocb(scsi_qla_host_t *vha, struct qla_work_evt *e)\n{\n\tsrb_t *sp;\n\tfc_port_t\t*fcport = NULL;\n\tstruct srb_iocb *iocb_cmd = NULL;\n\tint rval = QLA_SUCCESS;\n\tstruct\tedif_sa_ctl *sa_ctl = e->u.sa_update.sa_ctl;\n\tuint16_t nport_handle = e->u.sa_update.nport_handle;\n\n\tql_dbg(ql_dbg_edif, vha, 0x70e6,\n\t    \"%s: starting,  sa_ctl: %p\\n\", __func__, sa_ctl);\n\n\tif (!sa_ctl) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x70e6,\n\t\t    \"sa_ctl allocation failed\\n\");\n\t\trval = -ENOMEM;\n\t\treturn rval;\n\t}\n\n\tfcport = sa_ctl->fcport;\n\n\t \n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x70e6,\n\t\t \"SRB allocation failed\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tfcport->flags |= FCF_ASYNC_SENT;\n\tiocb_cmd = &sp->u.iocb_cmd;\n\tiocb_cmd->u.sa_update.sa_ctl = sa_ctl;\n\n\tql_dbg(ql_dbg_edif, vha, 0x3073,\n\t    \"Enter: SA REPL portid=%06x, sa_ctl %p, index %x, nport_handle: 0x%x\\n\",\n\t    fcport->d_id.b24, sa_ctl, sa_ctl->index, nport_handle);\n\t \n\tif (sa_ctl->flags & EDIF_SA_CTL_FLG_CLEANUP_DEL) {\n\t\t \n\t\tsp->flags |= SRB_EDIF_CLEANUP_DELETE;\n\t\tql_dbg(ql_dbg_edif, vha, 0x70e6,\n\t\t    \"%s: sp 0x%p flagged as cleanup delete\\n\", __func__, sp);\n\t}\n\n\tsp->type = SRB_SA_REPLACE;\n\tsp->name = \"SA_REPLACE\";\n\tsp->fcport = fcport;\n\tsp->free = qla2x00_rel_sp;\n\tsp->done = qla_noop_sp_done;\n\n\trval = qla2x00_start_sp(sp);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tgoto done_free_sp;\n\t}\n\n\treturn rval;\ndone_free_sp:\n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\tfcport->flags &= ~FCF_ASYNC_SENT;\ndone:\n\tfcport->flags &= ~FCF_ASYNC_ACTIVE;\n\treturn rval;\n}\n\nvoid qla24xx_sa_update_iocb(srb_t *sp, struct sa_update_28xx *sa_update_iocb)\n{\n\tint\titr = 0;\n\tstruct\tscsi_qla_host\t\t*vha = sp->vha;\n\tstruct\tqla_sa_update_frame\t*sa_frame =\n\t\t&sp->u.iocb_cmd.u.sa_update.sa_frame;\n\tu8 flags = 0;\n\n\tswitch (sa_frame->flags & (SAU_FLG_INV | SAU_FLG_TX)) {\n\tcase 0:\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s: EDIF SA UPDATE RX IOCB  vha: 0x%p  index: %d\\n\",\n\t\t    __func__, vha, sa_frame->fast_sa_index);\n\t\tbreak;\n\tcase 1:\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s: EDIF SA DELETE RX IOCB  vha: 0x%p  index: %d\\n\",\n\t\t    __func__, vha, sa_frame->fast_sa_index);\n\t\tflags |= SA_FLAG_INVALIDATE;\n\t\tbreak;\n\tcase 2:\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s: EDIF SA UPDATE TX IOCB  vha: 0x%p  index: %d\\n\",\n\t\t    __func__, vha, sa_frame->fast_sa_index);\n\t\tflags |= SA_FLAG_TX;\n\t\tbreak;\n\tcase 3:\n\t\tql_dbg(ql_dbg_edif, vha, 0x911d,\n\t\t    \"%s: EDIF SA DELETE TX IOCB  vha: 0x%p  index: %d\\n\",\n\t\t    __func__, vha, sa_frame->fast_sa_index);\n\t\tflags |= SA_FLAG_TX | SA_FLAG_INVALIDATE;\n\t\tbreak;\n\t}\n\n\tsa_update_iocb->entry_type = SA_UPDATE_IOCB_TYPE;\n\tsa_update_iocb->entry_count = 1;\n\tsa_update_iocb->sys_define = 0;\n\tsa_update_iocb->entry_status = 0;\n\tsa_update_iocb->handle = sp->handle;\n\tsa_update_iocb->u.nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tsa_update_iocb->vp_index = sp->fcport->vha->vp_idx;\n\tsa_update_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tsa_update_iocb->port_id[1] = sp->fcport->d_id.b.area;\n\tsa_update_iocb->port_id[2] = sp->fcport->d_id.b.domain;\n\n\tsa_update_iocb->flags = flags;\n\tsa_update_iocb->salt = cpu_to_le32(sa_frame->salt);\n\tsa_update_iocb->spi = cpu_to_le32(sa_frame->spi);\n\tsa_update_iocb->sa_index = cpu_to_le16(sa_frame->fast_sa_index);\n\n\tsa_update_iocb->sa_control |= SA_CNTL_ENC_FCSP;\n\tif (sp->fcport->edif.aes_gmac)\n\t\tsa_update_iocb->sa_control |= SA_CNTL_AES_GMAC;\n\n\tif (sa_frame->flags & SAU_FLG_KEY256) {\n\t\tsa_update_iocb->sa_control |= SA_CNTL_KEY256;\n\t\tfor (itr = 0; itr < 32; itr++)\n\t\t\tsa_update_iocb->sa_key[itr] = sa_frame->sa_key[itr];\n\t} else {\n\t\tsa_update_iocb->sa_control |= SA_CNTL_KEY128;\n\t\tfor (itr = 0; itr < 16; itr++)\n\t\t\tsa_update_iocb->sa_key[itr] = sa_frame->sa_key[itr];\n\t}\n\n\tql_dbg(ql_dbg_edif, vha, 0x921d,\n\t    \"%s SAU Port ID = %02x%02x%02x, flags=%xh, index=%u, ctl=%xh, SPI 0x%x flags 0x%x hdl=%x gmac %d\\n\",\n\t    __func__, sa_update_iocb->port_id[2], sa_update_iocb->port_id[1],\n\t    sa_update_iocb->port_id[0], sa_update_iocb->flags, sa_update_iocb->sa_index,\n\t    sa_update_iocb->sa_control, sa_update_iocb->spi, sa_frame->flags, sp->handle,\n\t    sp->fcport->edif.aes_gmac);\n\n\tif (sa_frame->flags & SAU_FLG_TX)\n\t\tsp->fcport->edif.tx_sa_pending = 1;\n\telse\n\t\tsp->fcport->edif.rx_sa_pending = 1;\n\n\tsp->fcport->vha->qla_stats.control_requests++;\n}\n\nvoid\nqla24xx_sa_replace_iocb(srb_t *sp, struct sa_update_28xx *sa_update_iocb)\n{\n\tstruct\tscsi_qla_host\t\t*vha = sp->vha;\n\tstruct srb_iocb *srb_iocb = &sp->u.iocb_cmd;\n\tstruct\tedif_sa_ctl\t\t*sa_ctl = srb_iocb->u.sa_update.sa_ctl;\n\tuint16_t nport_handle = sp->fcport->loop_id;\n\n\tsa_update_iocb->entry_type = SA_UPDATE_IOCB_TYPE;\n\tsa_update_iocb->entry_count = 1;\n\tsa_update_iocb->sys_define = 0;\n\tsa_update_iocb->entry_status = 0;\n\tsa_update_iocb->handle = sp->handle;\n\n\tsa_update_iocb->u.nport_handle = cpu_to_le16(nport_handle);\n\n\tsa_update_iocb->vp_index = sp->fcport->vha->vp_idx;\n\tsa_update_iocb->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tsa_update_iocb->port_id[1] = sp->fcport->d_id.b.area;\n\tsa_update_iocb->port_id[2] = sp->fcport->d_id.b.domain;\n\n\t \n\tsa_update_iocb->flags = SA_FLAG_INVALIDATE;\n\tsa_update_iocb->salt = 0;\n\tsa_update_iocb->spi = 0;\n\tsa_update_iocb->sa_index = cpu_to_le16(sa_ctl->index);\n\tsa_update_iocb->sa_control = 0;\n\n\tql_dbg(ql_dbg_edif, vha, 0x921d,\n\t    \"%s SAU DELETE RX Port ID = %02x:%02x:%02x, lid %d flags=%xh, index=%u, hdl=%x\\n\",\n\t    __func__, sa_update_iocb->port_id[2], sa_update_iocb->port_id[1],\n\t    sa_update_iocb->port_id[0], nport_handle, sa_update_iocb->flags,\n\t    sa_update_iocb->sa_index, sp->handle);\n\n\tsp->fcport->vha->qla_stats.control_requests++;\n}\n\nvoid qla24xx_auth_els(scsi_qla_host_t *vha, void **pkt, struct rsp_que **rsp)\n{\n\tstruct purex_entry_24xx *p = *pkt;\n\tstruct enode\t\t*ptr;\n\tint\t\tsid;\n\tu16 totlen;\n\tstruct purexevent\t*purex;\n\tstruct scsi_qla_host *host = NULL;\n\tint rc;\n\tstruct fc_port *fcport;\n\tstruct qla_els_pt_arg a;\n\tbe_id_t beid;\n\n\tmemset(&a, 0, sizeof(a));\n\n\ta.els_opcode = ELS_AUTH_ELS;\n\ta.nport_handle = p->nport_handle;\n\ta.rx_xchg_address = p->rx_xchg_addr;\n\ta.did.b.domain = p->s_id[2];\n\ta.did.b.area   = p->s_id[1];\n\ta.did.b.al_pa  = p->s_id[0];\n\ta.tx_byte_count = a.tx_len = sizeof(struct fc_els_ls_rjt);\n\ta.tx_addr = vha->hw->elsrej.cdma;\n\ta.vp_idx = vha->vp_idx;\n\ta.control_flags = EPD_ELS_RJT;\n\ta.ox_id = le16_to_cpu(p->ox_id);\n\n\tsid = p->s_id[0] | (p->s_id[1] << 8) | (p->s_id[2] << 16);\n\n\ttotlen = (le16_to_cpu(p->frame_size) & 0x0fff) - PURX_ELS_HEADER_SIZE;\n\tif (le16_to_cpu(p->status_flags) & 0x8000) {\n\t\ttotlen = le16_to_cpu(p->trunc_frame_size);\n\t\tqla_els_reject_iocb(vha, (*rsp)->qpair, &a);\n\t\t__qla_consume_iocb(vha, pkt, rsp);\n\t\treturn;\n\t}\n\n\tif (totlen > ELS_MAX_PAYLOAD) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x0910d,\n\t\t    \"%s WARNING: verbose ELS frame received (totlen=%x)\\n\",\n\t\t    __func__, totlen);\n\t\tqla_els_reject_iocb(vha, (*rsp)->qpair, &a);\n\t\t__qla_consume_iocb(vha, pkt, rsp);\n\t\treturn;\n\t}\n\n\tif (!vha->hw->flags.edif_enabled) {\n\t\t \n\t\tql_dbg(ql_dbg_edif, vha, 0x910e, \"%s edif not enabled\\n\",\n\t\t    __func__);\n\t\tqla_els_reject_iocb(vha, (*rsp)->qpair, &a);\n\t\t__qla_consume_iocb(vha, pkt, rsp);\n\t\treturn;\n\t}\n\n\tptr = qla_enode_alloc(vha, N_PUREX);\n\tif (!ptr) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x09109,\n\t\t    \"WARNING: enode alloc failed for sid=%x\\n\",\n\t\t    sid);\n\t\tqla_els_reject_iocb(vha, (*rsp)->qpair, &a);\n\t\t__qla_consume_iocb(vha, pkt, rsp);\n\t\treturn;\n\t}\n\n\tpurex = &ptr->u.purexinfo;\n\tpurex->pur_info.pur_sid = a.did;\n\tpurex->pur_info.pur_bytes_rcvd = totlen;\n\tpurex->pur_info.pur_rx_xchg_address = le32_to_cpu(p->rx_xchg_addr);\n\tpurex->pur_info.pur_nphdl = le16_to_cpu(p->nport_handle);\n\tpurex->pur_info.pur_did.b.domain =  p->d_id[2];\n\tpurex->pur_info.pur_did.b.area =  p->d_id[1];\n\tpurex->pur_info.pur_did.b.al_pa =  p->d_id[0];\n\tpurex->pur_info.vp_idx = p->vp_idx;\n\n\ta.sid = purex->pur_info.pur_did;\n\n\trc = __qla_copy_purex_to_buffer(vha, pkt, rsp, purex->msgp,\n\t\tpurex->msgp_len);\n\tif (rc) {\n\t\tqla_els_reject_iocb(vha, (*rsp)->qpair, &a);\n\t\tqla_enode_free(vha, ptr);\n\t\treturn;\n\t}\n\tbeid.al_pa = purex->pur_info.pur_did.b.al_pa;\n\tbeid.area   = purex->pur_info.pur_did.b.area;\n\tbeid.domain = purex->pur_info.pur_did.b.domain;\n\thost = qla_find_host_by_d_id(vha, beid);\n\tif (!host) {\n\t\tql_log(ql_log_fatal, vha, 0x508b,\n\t\t    \"%s Drop ELS due to unable to find host %06x\\n\",\n\t\t    __func__, purex->pur_info.pur_did.b24);\n\n\t\tqla_els_reject_iocb(vha, (*rsp)->qpair, &a);\n\t\tqla_enode_free(vha, ptr);\n\t\treturn;\n\t}\n\n\tfcport = qla2x00_find_fcport_by_pid(host, &purex->pur_info.pur_sid);\n\n\tif (DBELL_INACTIVE(vha)) {\n\t\tql_dbg(ql_dbg_edif, host, 0x0910c, \"%s e_dbell.db_flags =%x %06x\\n\",\n\t\t    __func__, host->e_dbell.db_flags,\n\t\t    fcport ? fcport->d_id.b24 : 0);\n\n\t\tqla_els_reject_iocb(host, (*rsp)->qpair, &a);\n\t\tqla_enode_free(host, ptr);\n\t\treturn;\n\t}\n\n\tif (fcport && EDIF_SESSION_DOWN(fcport)) {\n\t\tql_dbg(ql_dbg_edif, host, 0x13b6,\n\t\t    \"%s terminate exchange. Send logo to 0x%x\\n\",\n\t\t    __func__, a.did.b24);\n\n\t\ta.tx_byte_count = a.tx_len = 0;\n\t\ta.tx_addr = 0;\n\t\ta.control_flags = EPD_RX_XCHG;   \n\t\tqla_els_reject_iocb(host, (*rsp)->qpair, &a);\n\t\tqla_enode_free(host, ptr);\n\t\t \n\t\tfcport->send_els_logo = 1;\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t\treturn;\n\t}\n\n\t \n\tqla_enode_add(host, ptr);\n\n\tql_dbg(ql_dbg_edif, host, 0x0910c,\n\t    \"%s COMPLETE purex->pur_info.pur_bytes_rcvd =%xh s:%06x -> d:%06x xchg=%xh\\n\",\n\t    __func__, purex->pur_info.pur_bytes_rcvd, purex->pur_info.pur_sid.b24,\n\t    purex->pur_info.pur_did.b24, purex->pur_info.pur_rx_xchg_address);\n\n\tqla_edb_eventcreate(host, VND_CMD_AUTH_STATE_ELS_RCVD, sid, 0, NULL);\n}\n\nstatic uint16_t  qla_edif_get_sa_index_from_freepool(fc_port_t *fcport, int dir)\n{\n\tstruct scsi_qla_host *vha = fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tvoid *sa_id_map;\n\tunsigned long flags = 0;\n\tu16 sa_index;\n\n\tql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,\n\t    \"%s: entry\\n\", __func__);\n\n\tif (dir)\n\t\tsa_id_map = ha->edif_tx_sa_id_map;\n\telse\n\t\tsa_id_map = ha->edif_rx_sa_id_map;\n\n\tspin_lock_irqsave(&ha->sadb_fp_lock, flags);\n\tsa_index = find_first_zero_bit(sa_id_map, EDIF_NUM_SA_INDEX);\n\tif (sa_index >=  EDIF_NUM_SA_INDEX) {\n\t\tspin_unlock_irqrestore(&ha->sadb_fp_lock, flags);\n\t\treturn INVALID_EDIF_SA_INDEX;\n\t}\n\tset_bit(sa_index, sa_id_map);\n\tspin_unlock_irqrestore(&ha->sadb_fp_lock, flags);\n\n\tif (dir)\n\t\tsa_index += EDIF_TX_SA_INDEX_BASE;\n\n\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t    \"%s: index retrieved from free pool %d\\n\", __func__, sa_index);\n\n\treturn sa_index;\n}\n\n \nstatic struct edif_sa_index_entry *\nqla_edif_sadb_find_sa_index_entry(uint16_t nport_handle,\n\t\tstruct list_head *sa_list)\n{\n\tstruct edif_sa_index_entry *entry;\n\tstruct edif_sa_index_entry *tentry;\n\tstruct list_head *indx_list = sa_list;\n\n\tlist_for_each_entry_safe(entry, tentry, indx_list, next) {\n\t\tif (entry->handle == nport_handle)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\n \nstatic int qla_edif_sadb_delete_sa_index(fc_port_t *fcport, uint16_t nport_handle,\n\t\tuint16_t sa_index)\n{\n\tstruct edif_sa_index_entry *entry;\n\tstruct list_head *sa_list;\n\tint dir = (sa_index < EDIF_TX_SA_INDEX_BASE) ? 0 : 1;\n\tint slot = 0;\n\tint free_slot_count = 0;\n\tscsi_qla_host_t *vha = fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags = 0;\n\n\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t    \"%s: entry\\n\", __func__);\n\n\tif (dir)\n\t\tsa_list = &ha->sadb_tx_index_list;\n\telse\n\t\tsa_list = &ha->sadb_rx_index_list;\n\n\tentry = qla_edif_sadb_find_sa_index_entry(nport_handle, sa_list);\n\tif (!entry) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: no entry found for nport_handle 0x%x\\n\",\n\t\t    __func__, nport_handle);\n\t\treturn -1;\n\t}\n\n\tspin_lock_irqsave(&ha->sadb_lock, flags);\n\t \n\tfor (slot = 0; slot < 2; slot++) {\n\t\tif (entry->sa_pair[slot].sa_index == sa_index) {\n\t\t\tentry->sa_pair[slot].sa_index = INVALID_EDIF_SA_INDEX;\n\t\t\tentry->sa_pair[slot].spi = 0;\n\t\t\tfree_slot_count++;\n\t\t\tqla_edif_add_sa_index_to_freepool(fcport, dir, sa_index);\n\t\t} else if (entry->sa_pair[slot].sa_index == INVALID_EDIF_SA_INDEX) {\n\t\t\tfree_slot_count++;\n\t\t}\n\t}\n\n\tif (free_slot_count == 2) {\n\t\tlist_del(&entry->next);\n\t\tkfree(entry);\n\t}\n\tspin_unlock_irqrestore(&ha->sadb_lock, flags);\n\n\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t    \"%s: sa_index %d removed, free_slot_count: %d\\n\",\n\t    __func__, sa_index, free_slot_count);\n\n\treturn 0;\n}\n\nvoid\nqla28xx_sa_update_iocb_entry(scsi_qla_host_t *v, struct req_que *req,\n\tstruct sa_update_28xx *pkt)\n{\n\tconst char *func = \"SA_UPDATE_RESPONSE_IOCB\";\n\tsrb_t *sp;\n\tstruct edif_sa_ctl *sa_ctl;\n\tint old_sa_deleted = 1;\n\tuint16_t nport_handle;\n\tstruct scsi_qla_host *vha;\n\n\tsp = qla2x00_get_sp_from_handle(v, func, req, pkt);\n\n\tif (!sp) {\n\t\tql_dbg(ql_dbg_edif, v, 0x3063,\n\t\t\t\"%s: no sp found for pkt\\n\", __func__);\n\t\treturn;\n\t}\n\t \n\tvha = sp->vha;\n\n\tswitch (pkt->flags & (SA_FLAG_INVALIDATE | SA_FLAG_TX)) {\n\tcase 0:\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: EDIF SA UPDATE RX IOCB  vha: 0x%p  index: %d\\n\",\n\t\t    __func__, vha, pkt->sa_index);\n\t\tbreak;\n\tcase 1:\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: EDIF SA DELETE RX IOCB  vha: 0x%p  index: %d\\n\",\n\t\t    __func__, vha, pkt->sa_index);\n\t\tbreak;\n\tcase 2:\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: EDIF SA UPDATE TX IOCB  vha: 0x%p  index: %d\\n\",\n\t\t    __func__, vha, pkt->sa_index);\n\t\tbreak;\n\tcase 3:\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: EDIF SA DELETE TX IOCB  vha: 0x%p  index: %d\\n\",\n\t\t    __func__, vha, pkt->sa_index);\n\t\tbreak;\n\t}\n\n\t \n\tnport_handle = sp->fcport->loop_id;\n\n\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t    \"%s: %8phN comp status=%x old_sa_info=%x new_sa_info=%x lid %d, index=0x%x pkt_flags %xh hdl=%x\\n\",\n\t    __func__, sp->fcport->port_name, pkt->u.comp_sts, pkt->old_sa_info, pkt->new_sa_info,\n\t    nport_handle, pkt->sa_index, pkt->flags, sp->handle);\n\n\t \n\tif ((pkt->flags & (SA_FLAG_INVALIDATE | SA_FLAG_TX)) ==  SA_FLAG_INVALIDATE) {\n\t\tstruct edif_list_entry *edif_entry;\n\n\t\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\n\t\tedif_entry = qla_edif_list_find_sa_index(sp->fcport, nport_handle);\n\t\tif (edif_entry) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x5033,\n\t\t\t    \"%s: removing edif_entry %p, new sa_index: 0x%x\\n\",\n\t\t\t    __func__, edif_entry, pkt->sa_index);\n\t\t\tqla_edif_list_delete_sa_index(sp->fcport, edif_entry);\n\t\t\ttimer_shutdown(&edif_entry->timer);\n\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x5033,\n\t\t\t    \"%s: releasing edif_entry %p, new sa_index: 0x%x\\n\",\n\t\t\t    __func__, edif_entry, pkt->sa_index);\n\n\t\t\tkfree(edif_entry);\n\t\t}\n\t}\n\n\t \n\tif (pkt->flags & SA_FLAG_INVALIDATE)\n\t\told_sa_deleted = (le16_to_cpu(pkt->new_sa_info) == 0xffff) ? 1 : 0;\n\n\t \n\n\t \n\tif (sp->flags & SRB_EDIF_CLEANUP_DELETE) {\n\t\tsp->fcport->flags &= ~(FCF_ASYNC_SENT | FCF_ASYNC_ACTIVE);\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: nph 0x%x, sa_index %d removed from fw\\n\",\n\t\t    __func__, sp->fcport->loop_id, pkt->sa_index);\n\n\t} else if ((pkt->entry_status == 0) && (pkt->u.comp_sts == 0) &&\n\t    old_sa_deleted) {\n\t\t \n\t\tql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,\n\t\t\t\"SA(%x)updated for s_id %02x%02x%02x\\n\",\n\t\t\tpkt->new_sa_info,\n\t\t\tpkt->port_id[2], pkt->port_id[1], pkt->port_id[0]);\n\t\tsp->fcport->edif.enable = 1;\n\t\tif (pkt->flags & SA_FLAG_TX) {\n\t\t\tsp->fcport->edif.tx_sa_set = 1;\n\t\t\tsp->fcport->edif.tx_sa_pending = 0;\n\t\t\tqla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SAUPDATE_COMPL,\n\t\t\t\tQL_VND_SA_STAT_SUCCESS,\n\t\t\t\tQL_VND_TX_SA_KEY, sp->fcport);\n\t\t} else {\n\t\t\tsp->fcport->edif.rx_sa_set = 1;\n\t\t\tsp->fcport->edif.rx_sa_pending = 0;\n\t\t\tqla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SAUPDATE_COMPL,\n\t\t\t\tQL_VND_SA_STAT_SUCCESS,\n\t\t\t\tQL_VND_RX_SA_KEY, sp->fcport);\n\t\t}\n\t} else {\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: %8phN SA update FAILED: sa_index: %d, new_sa_info %d, %02x%02x%02x\\n\",\n\t\t    __func__, sp->fcport->port_name, pkt->sa_index, pkt->new_sa_info,\n\t\t    pkt->port_id[2], pkt->port_id[1], pkt->port_id[0]);\n\n\t\tif (pkt->flags & SA_FLAG_TX)\n\t\t\tqla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SAUPDATE_COMPL,\n\t\t\t\t(le16_to_cpu(pkt->u.comp_sts) << 16) | QL_VND_SA_STAT_FAILED,\n\t\t\t\tQL_VND_TX_SA_KEY, sp->fcport);\n\t\telse\n\t\t\tqla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SAUPDATE_COMPL,\n\t\t\t\t(le16_to_cpu(pkt->u.comp_sts) << 16) | QL_VND_SA_STAT_FAILED,\n\t\t\t\tQL_VND_RX_SA_KEY, sp->fcport);\n\t}\n\n\t \n\tif (pkt->flags & SA_FLAG_INVALIDATE) {\n\t\t \n\t\tsa_ctl = qla_edif_find_sa_ctl_by_index(sp->fcport,\n\t\t    le16_to_cpu(pkt->sa_index), (pkt->flags & SA_FLAG_TX));\n\t\tif (sa_ctl &&\n\t\t    qla_edif_find_sa_ctl_by_index(sp->fcport, sa_ctl->index,\n\t\t\t(pkt->flags & SA_FLAG_TX)) != NULL) {\n\t\t\tql_dbg(ql_dbg_edif + ql_dbg_verbose, vha, 0x3063,\n\t\t\t    \"%s: freeing sa_ctl for index %d\\n\",\n\t\t\t    __func__, sa_ctl->index);\n\t\t\tqla_edif_free_sa_ctl(sp->fcport, sa_ctl, sa_ctl->index);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t    \"%s: sa_ctl NOT freed, sa_ctl: %p\\n\",\n\t\t\t    __func__, sa_ctl);\n\t\t}\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: freeing sa_index %d, nph: 0x%x\\n\",\n\t\t    __func__, le16_to_cpu(pkt->sa_index), nport_handle);\n\t\tqla_edif_sadb_delete_sa_index(sp->fcport, nport_handle,\n\t\t    le16_to_cpu(pkt->sa_index));\n\t \n\t} else if (pkt->u.comp_sts) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: freeing sa_index %d, nph: 0x%x\\n\",\n\t\t    __func__, pkt->sa_index, nport_handle);\n\t\tqla_edif_sadb_delete_sa_index(sp->fcport, nport_handle,\n\t\t    le16_to_cpu(pkt->sa_index));\n\t\tswitch (le16_to_cpu(pkt->u.comp_sts)) {\n\t\tcase CS_PORT_EDIF_UNAVAIL:\n\t\tcase CS_PORT_EDIF_LOGOUT:\n\t\t\tqlt_schedule_sess_for_deletion(sp->fcport);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsp->done(sp, 0);\n}\n\n \nint\nqla28xx_start_scsi_edif(srb_t *sp)\n{\n\tint             nseg;\n\tunsigned long   flags;\n\tstruct scsi_cmnd *cmd;\n\tuint32_t        *clr_ptr;\n\tuint32_t        index, i;\n\tuint32_t        handle;\n\tuint16_t        cnt;\n\tint16_t        req_cnt;\n\tuint16_t        tot_dsds;\n\t__be32 *fcp_dl;\n\tuint8_t additional_cdb_len;\n\tstruct ct6_dsd *ctx;\n\tstruct scsi_qla_host *vha = sp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct cmd_type_6 *cmd_pkt;\n\tstruct dsd64\t*cur_dsd;\n\tuint8_t\t\tavail_dsds = 0;\n\tstruct scatterlist *sg;\n\tstruct req_que *req = sp->qpair->req;\n\tspinlock_t *lock = sp->qpair->qp_lock_ptr;\n\n\t \n\tcmd = GET_CMD_SP(sp);\n\n\t \n\ttot_dsds = 0;\n\n\t \n\tif (vha->marker_needed != 0) {\n\t\tif (qla2x00_marker(vha, sp->qpair, 0, 0, MK_SYNC_ALL) !=\n\t\t\tQLA_SUCCESS) {\n\t\t\tql_log(ql_log_warn, vha, 0x300c,\n\t\t\t    \"qla2x00_marker failed for cmd=%p.\\n\", cmd);\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t\t}\n\t\tvha->marker_needed = 0;\n\t}\n\n\t \n\tspin_lock_irqsave(lock, flags);\n\n\t \n\thandle = req->current_outstanding_cmd;\n\tfor (index = 1; index < req->num_outstanding_cmds; index++) {\n\t\thandle++;\n\t\tif (handle == req->num_outstanding_cmds)\n\t\t\thandle = 1;\n\t\tif (!req->outstanding_cmds[handle])\n\t\t\tbreak;\n\t}\n\tif (index == req->num_outstanding_cmds)\n\t\tgoto queuing_error;\n\n\t \n\tif (scsi_sg_count(cmd)) {\n\t\tnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\n\t\t    scsi_sg_count(cmd), cmd->sc_data_direction);\n\t\tif (unlikely(!nseg))\n\t\t\tgoto queuing_error;\n\t} else {\n\t\tnseg = 0;\n\t}\n\n\ttot_dsds = nseg;\n\treq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\n\n\tsp->iores.res_type = RESOURCE_IOCB | RESOURCE_EXCH;\n\tsp->iores.exch_cnt = 1;\n\tsp->iores.iocb_cnt = req_cnt;\n\tif (qla_get_fw_resources(sp->qpair, &sp->iores))\n\t\tgoto queuing_error;\n\n\tif (req->cnt < (req_cnt + 2)) {\n\t\tcnt = IS_SHADOW_REG_CAPABLE(ha) ? *req->out_ptr :\n\t\t    rd_reg_dword(req->req_q_out);\n\t\tif (req->ring_index < cnt)\n\t\t\treq->cnt = cnt - req->ring_index;\n\t\telse\n\t\t\treq->cnt = req->length -\n\t\t\t    (req->ring_index - cnt);\n\t\tif (req->cnt < (req_cnt + 2))\n\t\t\tgoto queuing_error;\n\t}\n\n\tif (qla_get_buf(vha, sp->qpair, &sp->u.scmd.buf_dsc)) {\n\t\tql_log(ql_log_fatal, vha, 0x3011,\n\t\t    \"Failed to allocate buf for fcp_cmnd for cmd=%p.\\n\", cmd);\n\t\tgoto queuing_error;\n\t}\n\n\tsp->flags |= SRB_GOT_BUF;\n\tctx = &sp->u.scmd.ct6_ctx;\n\tctx->fcp_cmnd = sp->u.scmd.buf_dsc.buf;\n\tctx->fcp_cmnd_dma = sp->u.scmd.buf_dsc.buf_dma;\n\n\tif (cmd->cmd_len > 16) {\n\t\tadditional_cdb_len = cmd->cmd_len - 16;\n\t\tif ((cmd->cmd_len % 4) != 0) {\n\t\t\t \n\t\t\tql_log(ql_log_warn, vha, 0x3012,\n\t\t\t    \"scsi cmd len %d not multiple of 4 for cmd=%p.\\n\",\n\t\t\t    cmd->cmd_len, cmd);\n\t\t\tgoto queuing_error_fcp_cmnd;\n\t\t}\n\t\tctx->fcp_cmnd_len = 12 + cmd->cmd_len + 4;\n\t} else {\n\t\tadditional_cdb_len = 0;\n\t\tctx->fcp_cmnd_len = 12 + 16 + 4;\n\t}\n\n\tcmd_pkt = (struct cmd_type_6 *)req->ring_ptr;\n\tcmd_pkt->handle = make_handle(req->id, handle);\n\n\t \n\tclr_ptr = (uint32_t *)cmd_pkt + 2;\n\tmemset(clr_ptr, 0, REQUEST_ENTRY_SIZE - 8);\n\tcmd_pkt->dseg_count = cpu_to_le16(tot_dsds);\n\n\t \n\tif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\n\t\tcmd_pkt->byte_count = cpu_to_le32(0);\n\t\tgoto no_dsds;\n\t}\n\n\t \n\tif (cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tcmd_pkt->control_flags = cpu_to_le16(CF_WRITE_DATA);\n\t\tvha->qla_stats.output_bytes += scsi_bufflen(cmd);\n\t\tvha->qla_stats.output_requests++;\n\t\tsp->fcport->edif.tx_bytes += scsi_bufflen(cmd);\n\t} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tcmd_pkt->control_flags = cpu_to_le16(CF_READ_DATA);\n\t\tvha->qla_stats.input_bytes += scsi_bufflen(cmd);\n\t\tvha->qla_stats.input_requests++;\n\t\tsp->fcport->edif.rx_bytes += scsi_bufflen(cmd);\n\t}\n\n\tcmd_pkt->control_flags |= cpu_to_le16(CF_EN_EDIF);\n\tcmd_pkt->control_flags &= ~(cpu_to_le16(CF_NEW_SA));\n\n\t \n\tavail_dsds = 1;\n\tcur_dsd = &cmd_pkt->fcp_dsd;\n\n\t \n\tscsi_for_each_sg(cmd, sg, tot_dsds, i) {\n\t\tdma_addr_t      sle_dma;\n\t\tcont_a64_entry_t *cont_pkt;\n\n\t\t \n\t\tif (avail_dsds == 0) {\n\t\t\t \n\t\t\tcont_pkt = qla2x00_prep_cont_type1_iocb(vha, req);\n\t\t\tcur_dsd = cont_pkt->dsd;\n\t\t\tavail_dsds = 5;\n\t\t}\n\n\t\tsle_dma = sg_dma_address(sg);\n\t\tput_unaligned_le64(sle_dma, &cur_dsd->address);\n\t\tcur_dsd->length = cpu_to_le32(sg_dma_len(sg));\n\t\tcur_dsd++;\n\t\tavail_dsds--;\n\t}\n\nno_dsds:\n\t \n\tcmd_pkt->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\tcmd_pkt->port_id[0] = sp->fcport->d_id.b.al_pa;\n\tcmd_pkt->port_id[1] = sp->fcport->d_id.b.area;\n\tcmd_pkt->port_id[2] = sp->fcport->d_id.b.domain;\n\tcmd_pkt->vp_index = sp->vha->vp_idx;\n\n\tcmd_pkt->entry_type = COMMAND_TYPE_6;\n\n\t \n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\n\tint_to_scsilun(cmd->device->lun, &cmd_pkt->lun);\n\thost_to_fcp_swap((uint8_t *)&cmd_pkt->lun, sizeof(cmd_pkt->lun));\n\n\t \n\tint_to_scsilun(cmd->device->lun, &ctx->fcp_cmnd->lun);\n\tctx->fcp_cmnd->additional_cdb_len = additional_cdb_len;\n\n\tif (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tctx->fcp_cmnd->additional_cdb_len |= 1;\n\telse if (cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\tctx->fcp_cmnd->additional_cdb_len |= 2;\n\n\t \n\tif (ha->flags.fcp_prio_enabled)\n\t\tctx->fcp_cmnd->task_attribute |=\n\t\t    sp->fcport->fcp_prio << 3;\n\n\tmemcpy(ctx->fcp_cmnd->cdb, cmd->cmnd, cmd->cmd_len);\n\n\tfcp_dl = (__be32 *)(ctx->fcp_cmnd->cdb + 16 +\n\t    additional_cdb_len);\n\t*fcp_dl = htonl((uint32_t)scsi_bufflen(cmd));\n\n\tcmd_pkt->fcp_cmnd_dseg_len = cpu_to_le16(ctx->fcp_cmnd_len);\n\tput_unaligned_le64(ctx->fcp_cmnd_dma, &cmd_pkt->fcp_cmnd_dseg_address);\n\n\tcmd_pkt->byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\n\t \n\tcmd_pkt->entry_count = (uint8_t)req_cnt;\n\tcmd_pkt->entry_status = 0;\n\n\t \n\treq->current_outstanding_cmd = handle;\n\treq->outstanding_cmds[handle] = sp;\n\tsp->handle = handle;\n\tcmd->host_scribble = (unsigned char *)(unsigned long)handle;\n\treq->cnt -= req_cnt;\n\n\t \n\twmb();\n\treq->ring_index++;\n\tif (req->ring_index == req->length) {\n\t\treq->ring_index = 0;\n\t\treq->ring_ptr = req->ring;\n\t} else {\n\t\treq->ring_ptr++;\n\t}\n\n\tsp->qpair->cmd_cnt++;\n\t \n\twrt_reg_dword(req->req_q_in, req->ring_index);\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\treturn QLA_SUCCESS;\n\nqueuing_error_fcp_cmnd:\nqueuing_error:\n\tif (tot_dsds)\n\t\tscsi_dma_unmap(cmd);\n\n\tqla_put_buf(sp->qpair, &sp->u.scmd.buf_dsc);\n\tqla_put_fw_resources(sp->qpair, &sp->iores);\n\tspin_unlock_irqrestore(lock, flags);\n\n\treturn QLA_FUNCTION_FAILED;\n}\n\n \n\n \nvoid qla_edif_list_del(fc_port_t *fcport)\n{\n\tstruct edif_list_entry *indx_lst;\n\tstruct edif_list_entry *tindx_lst;\n\tstruct list_head *indx_list = &fcport->edif.edif_indx_list;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&fcport->edif.indx_list_lock, flags);\n\tlist_for_each_entry_safe(indx_lst, tindx_lst, indx_list, next) {\n\t\tlist_del(&indx_lst->next);\n\t\tkfree(indx_lst);\n\t}\n\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n}\n\n \n\n \nstatic uint16_t qla_edif_sadb_get_sa_index(fc_port_t *fcport,\n\t\tstruct qla_sa_update_frame *sa_frame)\n{\n\tstruct edif_sa_index_entry *entry;\n\tstruct list_head *sa_list;\n\tuint16_t sa_index;\n\tint dir = sa_frame->flags & SAU_FLG_TX;\n\tint slot = 0;\n\tint free_slot = -1;\n\tscsi_qla_host_t *vha = fcport->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags = 0;\n\tuint16_t nport_handle = fcport->loop_id;\n\n\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t    \"%s: entry  fc_port: %p, nport_handle: 0x%x\\n\",\n\t    __func__, fcport, nport_handle);\n\n\tif (dir)\n\t\tsa_list = &ha->sadb_tx_index_list;\n\telse\n\t\tsa_list = &ha->sadb_rx_index_list;\n\n\tentry = qla_edif_sadb_find_sa_index_entry(nport_handle, sa_list);\n\tif (!entry) {\n\t\tif ((sa_frame->flags & (SAU_FLG_TX | SAU_FLG_INV)) == SAU_FLG_INV) {\n\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t    \"%s: rx delete request with no entry\\n\", __func__);\n\t\t\treturn RX_DELETE_NO_EDIF_SA_INDEX;\n\t\t}\n\n\t\t \n\t\tentry = kzalloc((sizeof(struct edif_sa_index_entry)), GFP_ATOMIC);\n\t\tif (!entry)\n\t\t\treturn INVALID_EDIF_SA_INDEX;\n\n\t\tsa_index = qla_edif_get_sa_index_from_freepool(fcport, dir);\n\t\tif (sa_index == INVALID_EDIF_SA_INDEX) {\n\t\t\tkfree(entry);\n\t\t\treturn INVALID_EDIF_SA_INDEX;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&entry->next);\n\t\tentry->handle = nport_handle;\n\t\tentry->fcport = fcport;\n\t\tentry->sa_pair[0].spi = sa_frame->spi;\n\t\tentry->sa_pair[0].sa_index = sa_index;\n\t\tentry->sa_pair[1].spi = 0;\n\t\tentry->sa_pair[1].sa_index = INVALID_EDIF_SA_INDEX;\n\t\tspin_lock_irqsave(&ha->sadb_lock, flags);\n\t\tlist_add_tail(&entry->next, sa_list);\n\t\tspin_unlock_irqrestore(&ha->sadb_lock, flags);\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: Created new sadb entry for nport_handle 0x%x, spi 0x%x, returning sa_index %d\\n\",\n\t\t    __func__, nport_handle, sa_frame->spi, sa_index);\n\n\t\treturn sa_index;\n\t}\n\n\tspin_lock_irqsave(&ha->sadb_lock, flags);\n\n\t \n\tfor (slot = 0; slot < 2; slot++) {\n\t\tif (entry->sa_pair[slot].sa_index == INVALID_EDIF_SA_INDEX) {\n\t\t\tfree_slot = slot;\n\t\t} else {\n\t\t\tif (entry->sa_pair[slot].spi == sa_frame->spi) {\n\t\t\t\tspin_unlock_irqrestore(&ha->sadb_lock, flags);\n\t\t\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t\t\t    \"%s: sadb slot %d entry for lid 0x%x, spi 0x%x found, sa_index %d\\n\",\n\t\t\t\t    __func__, slot, entry->handle, sa_frame->spi,\n\t\t\t\t    entry->sa_pair[slot].sa_index);\n\t\t\t\treturn entry->sa_pair[slot].sa_index;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->sadb_lock, flags);\n\n\t \n\tif (free_slot == -1) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: WARNING: No free slots in sadb for nport_handle 0x%x, spi: 0x%x\\n\",\n\t\t    __func__, entry->handle, sa_frame->spi);\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: Slot 0  spi: 0x%x  sa_index: %d,  Slot 1  spi: 0x%x  sa_index: %d\\n\",\n\t\t    __func__, entry->sa_pair[0].spi, entry->sa_pair[0].sa_index,\n\t\t    entry->sa_pair[1].spi, entry->sa_pair[1].sa_index);\n\n\t\treturn INVALID_EDIF_SA_INDEX;\n\t}\n\n\t \n\tsa_index = qla_edif_get_sa_index_from_freepool(fcport, dir);\n\tif (sa_index == INVALID_EDIF_SA_INDEX) {\n\t\tql_dbg(ql_dbg_edif, fcport->vha, 0x3063,\n\t\t    \"%s: empty freepool!!\\n\", __func__);\n\t\treturn INVALID_EDIF_SA_INDEX;\n\t}\n\n\tspin_lock_irqsave(&ha->sadb_lock, flags);\n\tentry->sa_pair[free_slot].spi = sa_frame->spi;\n\tentry->sa_pair[free_slot].sa_index = sa_index;\n\tspin_unlock_irqrestore(&ha->sadb_lock, flags);\n\tql_dbg(ql_dbg_edif, fcport->vha, 0x3063,\n\t    \"%s: sadb slot %d entry for nport_handle 0x%x, spi 0x%x added, returning sa_index %d\\n\",\n\t    __func__, free_slot, entry->handle, sa_frame->spi, sa_index);\n\n\treturn sa_index;\n}\n\n \nvoid qla_edif_sadb_release(struct qla_hw_data *ha)\n{\n\tstruct edif_sa_index_entry *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &ha->sadb_rx_index_list, next) {\n\t\tlist_del(&entry->next);\n\t\tkfree(entry);\n\t}\n\n\tlist_for_each_entry_safe(entry, tmp, &ha->sadb_tx_index_list, next) {\n\t\tlist_del(&entry->next);\n\t\tkfree(entry);\n\t}\n}\n\n \n\n \nint qla_edif_sadb_build_free_pool(struct qla_hw_data *ha)\n{\n\tha->edif_tx_sa_id_map =\n\t    kcalloc(BITS_TO_LONGS(EDIF_NUM_SA_INDEX), sizeof(long), GFP_KERNEL);\n\n\tif (!ha->edif_tx_sa_id_map) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0009,\n\t\t    \"Unable to allocate memory for sadb tx.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tha->edif_rx_sa_id_map =\n\t    kcalloc(BITS_TO_LONGS(EDIF_NUM_SA_INDEX), sizeof(long), GFP_KERNEL);\n\tif (!ha->edif_rx_sa_id_map) {\n\t\tkfree(ha->edif_tx_sa_id_map);\n\t\tha->edif_tx_sa_id_map = NULL;\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0009,\n\t\t    \"Unable to allocate memory for sadb rx.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nvoid qla_edif_sadb_release_free_pool(struct qla_hw_data *ha)\n{\n\tkfree(ha->edif_tx_sa_id_map);\n\tha->edif_tx_sa_id_map = NULL;\n\tkfree(ha->edif_rx_sa_id_map);\n\tha->edif_rx_sa_id_map = NULL;\n}\n\nstatic void __chk_edif_rx_sa_delete_pending(scsi_qla_host_t *vha,\n\t\tfc_port_t *fcport, uint32_t handle, uint16_t sa_index)\n{\n\tstruct edif_list_entry *edif_entry;\n\tstruct edif_sa_ctl *sa_ctl;\n\tuint16_t delete_sa_index = INVALID_EDIF_SA_INDEX;\n\tunsigned long flags = 0;\n\tuint16_t nport_handle = fcport->loop_id;\n\tuint16_t cached_nport_handle;\n\n\tspin_lock_irqsave(&fcport->edif.indx_list_lock, flags);\n\tedif_entry = qla_edif_list_find_sa_index(fcport, nport_handle);\n\tif (!edif_entry) {\n\t\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n\t\treturn;\t\t \n\t}\n\n\t \n\tif (edif_entry->delete_sa_index == INVALID_EDIF_SA_INDEX ||\n\t    edif_entry->update_sa_index != sa_index) {\n\t\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (edif_entry->count++ < EDIF_RX_DELETE_FILTER_COUNT) {\n\t\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n\t\treturn;\n\t}\n\n\tql_dbg(ql_dbg_edif, vha, 0x5033,\n\t    \"%s: invalidating delete_sa_index,  update_sa_index: 0x%x sa_index: 0x%x, delete_sa_index: 0x%x\\n\",\n\t    __func__, edif_entry->update_sa_index, sa_index, edif_entry->delete_sa_index);\n\n\tdelete_sa_index = edif_entry->delete_sa_index;\n\tedif_entry->delete_sa_index = INVALID_EDIF_SA_INDEX;\n\tcached_nport_handle = edif_entry->handle;\n\tspin_unlock_irqrestore(&fcport->edif.indx_list_lock, flags);\n\n\t \n\tif (nport_handle != cached_nport_handle) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: POST SA DELETE nport_handle mismatch: lid: 0x%x, edif_entry nph: 0x%x\\n\",\n\t\t    __func__, nport_handle, cached_nport_handle);\n\t}\n\n\t \n\tsa_ctl = qla_edif_find_sa_ctl_by_index(fcport, delete_sa_index, 0);\n\tif (sa_ctl) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: POST SA DELETE sa_ctl: %p, index recvd %d\\n\",\n\t\t    __func__, sa_ctl, sa_index);\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"delete index %d, update index: %d, nport handle: 0x%x, handle: 0x%x\\n\",\n\t\t    delete_sa_index,\n\t\t    edif_entry->update_sa_index, nport_handle, handle);\n\n\t\tsa_ctl->flags = EDIF_SA_CTL_FLG_DEL;\n\t\tset_bit(EDIF_SA_CTL_REPL, &sa_ctl->state);\n\t\tqla_post_sa_replace_work(fcport->vha, fcport,\n\t\t    nport_handle, sa_ctl);\n\t} else {\n\t\tql_dbg(ql_dbg_edif, vha, 0x3063,\n\t\t    \"%s: POST SA DELETE sa_ctl not found for delete_sa_index: %d\\n\",\n\t\t    __func__, delete_sa_index);\n\t}\n}\n\nvoid qla_chk_edif_rx_sa_delete_pending(scsi_qla_host_t *vha,\n\t\tsrb_t *sp, struct sts_entry_24xx *sts24)\n{\n\tfc_port_t *fcport = sp->fcport;\n\t \n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tuint32_t handle;\n\n\thandle = (uint32_t)LSW(sts24->handle);\n\n\t \n\tif (cmd->sc_data_direction != DMA_FROM_DEVICE)\n\t\treturn;\n\n\treturn __chk_edif_rx_sa_delete_pending(vha, fcport, handle,\n\t   le16_to_cpu(sts24->edif_sa_index));\n}\n\nvoid qlt_chk_edif_rx_sa_delete_pending(scsi_qla_host_t *vha, fc_port_t *fcport,\n\t\tstruct ctio7_from_24xx *pkt)\n{\n\t__chk_edif_rx_sa_delete_pending(vha, fcport,\n\t    pkt->handle, le16_to_cpu(pkt->edif_sa_index));\n}\n\nstatic void qla_parse_auth_els_ctl(struct srb *sp)\n{\n\tstruct qla_els_pt_arg *a = &sp->u.bsg_cmd.u.els_arg;\n\tstruct bsg_job *bsg_job = sp->u.bsg_cmd.bsg_job;\n\tstruct fc_bsg_request *request = bsg_job->request;\n\tstruct qla_bsg_auth_els_request *p =\n\t    (struct qla_bsg_auth_els_request *)bsg_job->request;\n\n\ta->tx_len = a->tx_byte_count = sp->remap.req.len;\n\ta->tx_addr = sp->remap.req.dma;\n\ta->rx_len = a->rx_byte_count = sp->remap.rsp.len;\n\ta->rx_addr = sp->remap.rsp.dma;\n\n\tif (p->e.sub_cmd == SEND_ELS_REPLY) {\n\t\ta->control_flags = p->e.extra_control_flags << 13;\n\t\ta->rx_xchg_address = cpu_to_le32(p->e.extra_rx_xchg_address);\n\t\tif (p->e.extra_control_flags == BSG_CTL_FLAG_LS_ACC)\n\t\t\ta->els_opcode = ELS_LS_ACC;\n\t\telse if (p->e.extra_control_flags == BSG_CTL_FLAG_LS_RJT)\n\t\t\ta->els_opcode = ELS_LS_RJT;\n\t}\n\ta->did = sp->fcport->d_id;\n\ta->els_opcode =  request->rqst_data.h_els.command_code;\n\ta->nport_handle = cpu_to_le16(sp->fcport->loop_id);\n\ta->vp_idx = sp->vha->vp_idx;\n}\n\nint qla_edif_process_els(scsi_qla_host_t *vha, struct bsg_job *bsg_job)\n{\n\tstruct fc_bsg_request *bsg_request = bsg_job->request;\n\tstruct fc_bsg_reply *bsg_reply = bsg_job->reply;\n\tfc_port_t *fcport = NULL;\n\tstruct qla_hw_data *ha = vha->hw;\n\tsrb_t *sp;\n\tint rval =  (DID_ERROR << 16), cnt;\n\tport_id_t d_id;\n\tstruct qla_bsg_auth_els_request *p =\n\t    (struct qla_bsg_auth_els_request *)bsg_job->request;\n\tstruct qla_bsg_auth_els_reply *rpl =\n\t    (struct qla_bsg_auth_els_reply *)bsg_job->reply;\n\n\trpl->version = EDIF_VERSION1;\n\n\td_id.b.al_pa = bsg_request->rqst_data.h_els.port_id[2];\n\td_id.b.area = bsg_request->rqst_data.h_els.port_id[1];\n\td_id.b.domain = bsg_request->rqst_data.h_els.port_id[0];\n\n\t \n\tfcport = qla2x00_find_fcport_by_pid(vha, &d_id);\n\tif (!fcport) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x911a,\n\t\t    \"%s fcport not find online portid=%06x.\\n\",\n\t\t    __func__, d_id.b24);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_ERROR);\n\t\treturn -EIO;\n\t}\n\n\tif (qla_bsg_check(vha, bsg_job, fcport))\n\t\treturn 0;\n\n\tif (EDIF_SESS_DELETE(fcport)) {\n\t\tql_dbg(ql_dbg_edif, vha, 0x910d,\n\t\t    \"%s ELS code %x, no loop id.\\n\", __func__,\n\t\t    bsg_request->rqst_data.r_els.els_code);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_BAD_TARGET);\n\t\treturn -ENXIO;\n\t}\n\n\tif (!vha->flags.online) {\n\t\tql_log(ql_log_warn, vha, 0x7005, \"Host not online.\\n\");\n\t\tSET_DID_STATUS(bsg_reply->result, DID_BAD_TARGET);\n\t\trval = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!IS_FWI2_CAPABLE(ha)) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7001,\n\t\t    \"ELS passthru not supported for ISP23xx based adapters.\\n\");\n\t\tSET_DID_STATUS(bsg_reply->result, DID_BAD_TARGET);\n\t\trval = -EPERM;\n\t\tgoto done;\n\t}\n\n\tsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\n\tif (!sp) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7004,\n\t\t    \"Failed get sp pid=%06x\\n\", fcport->d_id.b24);\n\t\trval = -ENOMEM;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);\n\t\tgoto done;\n\t}\n\n\tsp->remap.req.len = bsg_job->request_payload.payload_len;\n\tsp->remap.req.buf = dma_pool_alloc(ha->purex_dma_pool,\n\t    GFP_KERNEL, &sp->remap.req.dma);\n\tif (!sp->remap.req.buf) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7005,\n\t\t    \"Failed allocate request dma len=%x\\n\",\n\t\t    bsg_job->request_payload.payload_len);\n\t\trval = -ENOMEM;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);\n\t\tgoto done_free_sp;\n\t}\n\n\tsp->remap.rsp.len = bsg_job->reply_payload.payload_len;\n\tsp->remap.rsp.buf = dma_pool_alloc(ha->purex_dma_pool,\n\t    GFP_KERNEL, &sp->remap.rsp.dma);\n\tif (!sp->remap.rsp.buf) {\n\t\tql_dbg(ql_dbg_user, vha, 0x7006,\n\t\t    \"Failed allocate response dma len=%x\\n\",\n\t\t    bsg_job->reply_payload.payload_len);\n\t\trval = -ENOMEM;\n\t\tSET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);\n\t\tgoto done_free_remap_req;\n\t}\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t    bsg_job->request_payload.sg_cnt, sp->remap.req.buf,\n\t    sp->remap.req.len);\n\tsp->remap.remapped = true;\n\n\tsp->type = SRB_ELS_CMD_HST_NOLOGIN;\n\tsp->name = \"SPCN_BSG_HST_NOLOGIN\";\n\tsp->u.bsg_cmd.bsg_job = bsg_job;\n\tqla_parse_auth_els_ctl(sp);\n\n\tsp->free = qla2x00_bsg_sp_free;\n\tsp->done = qla2x00_bsg_job_done;\n\n\tcnt = 0;\nretry:\n\trval = qla2x00_start_sp(sp);\n\tswitch (rval) {\n\tcase QLA_SUCCESS:\n\t\tql_dbg(ql_dbg_edif, vha, 0x700a,\n\t\t       \"%s %s %8phN xchg %x ctlflag %x hdl %x reqlen %xh bsg ptr %p\\n\",\n\t\t       __func__, sc_to_str(p->e.sub_cmd), fcport->port_name,\n\t\t       p->e.extra_rx_xchg_address, p->e.extra_control_flags,\n\t\t       sp->handle, sp->remap.req.len, bsg_job);\n\t\tbreak;\n\tcase EAGAIN:\n\t\tmsleep(EDIF_MSLEEP_INTERVAL);\n\t\tcnt++;\n\t\tif (cnt < EDIF_RETRY_COUNT)\n\t\t\tgoto retry;\n\t\tfallthrough;\n\tdefault:\n\t\tql_log(ql_log_warn, vha, 0x700e,\n\t\t    \"%s qla2x00_start_sp failed = %d\\n\", __func__, rval);\n\t\tSET_DID_STATUS(bsg_reply->result, DID_IMM_RETRY);\n\t\trval = -EIO;\n\t\tgoto done_free_remap_rsp;\n\t}\n\treturn rval;\n\ndone_free_remap_rsp:\n\tdma_pool_free(ha->purex_dma_pool, sp->remap.rsp.buf,\n\t    sp->remap.rsp.dma);\ndone_free_remap_req:\n\tdma_pool_free(ha->purex_dma_pool, sp->remap.req.buf,\n\t    sp->remap.req.dma);\ndone_free_sp:\n\tqla2x00_rel_sp(sp);\n\ndone:\n\treturn rval;\n}\n\nvoid qla_edif_sess_down(struct scsi_qla_host *vha, struct fc_port *sess)\n{\n\tu16 cnt = 0;\n\n\tif (sess->edif.app_sess_online && DBELL_ACTIVE(vha)) {\n\t\tql_dbg(ql_dbg_disc, vha, 0xf09c,\n\t\t\t\"%s: sess %8phN send port_offline event\\n\",\n\t\t\t__func__, sess->port_name);\n\t\tsess->edif.app_sess_online = 0;\n\t\tsess->edif.sess_down_acked = 0;\n\t\tqla_edb_eventcreate(vha, VND_CMD_AUTH_STATE_SESSION_SHUTDOWN,\n\t\t    sess->d_id.b24, 0, sess);\n\t\tqla2x00_post_aen_work(vha, FCH_EVT_PORT_OFFLINE, sess->d_id.b24);\n\n\t\twhile (!READ_ONCE(sess->edif.sess_down_acked) &&\n\t\t       !test_bit(VPORT_DELETE, &vha->dpc_flags)) {\n\t\t\tmsleep(100);\n\t\t\tcnt++;\n\t\t\tif (cnt > 100)\n\t\t\t\tbreak;\n\t\t}\n\t\tsess->edif.sess_down_acked = 0;\n\t\tql_dbg(ql_dbg_disc, vha, 0xf09c,\n\t\t       \"%s: sess %8phN port_offline event completed\\n\",\n\t\t       __func__, sess->port_name);\n\t}\n}\n\nvoid qla_edif_clear_appdata(struct scsi_qla_host *vha, struct fc_port *fcport)\n{\n\tif (!(fcport->flags & FCF_FCSP_DEVICE))\n\t\treturn;\n\n\tqla_edb_clear(vha, fcport->d_id);\n\tqla_enode_clear(vha, fcport->d_id);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}