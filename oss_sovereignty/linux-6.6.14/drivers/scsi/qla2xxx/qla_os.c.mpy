{
  "module_name": "qla_os.c",
  "hash_id": "00dee54e24ad82c5fbd6caf1963dafde7968f933d3f8bb54fb01ab17781d9774",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla2xxx/qla_os.c",
  "human_readable_source": "\n \n#include \"qla_def.h\"\n\n#include <linux/moduleparam.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/blk-mq-pci.h>\n#include <linux/refcount.h>\n#include <linux/crash_dump.h>\n#include <linux/trace_events.h>\n#include <linux/trace.h>\n\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsicam.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_fc.h>\n\n#include \"qla_target.h\"\n\n \nchar qla2x00_version_str[40];\n\nstatic int apidev_major;\n\n \nstruct kmem_cache *srb_cachep;\n\nstatic struct trace_array *qla_trc_array;\n\nint ql2xfulldump_on_mpifail;\nmodule_param(ql2xfulldump_on_mpifail, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql2xfulldump_on_mpifail,\n\t\t \"Set this to take full dump on MPI hang.\");\n\nint ql2xenforce_iocb_limit = 2;\nmodule_param(ql2xenforce_iocb_limit, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql2xenforce_iocb_limit,\n\t\t \"Enforce IOCB throttling, to avoid FW congestion. (default: 2) \"\n\t\t \"1: track usage per queue, 2: track usage per adapter\");\n\n \nstatic struct kmem_cache *ctx_cachep;\n \nuint ql_errlev = 0x8001;\n\nint ql2xsecenable;\nmodule_param(ql2xsecenable, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xsecenable,\n\t\"Enable/disable security. 0(Default) - Security disabled. 1 - Security enabled.\");\n\nstatic int ql2xenableclass2;\nmodule_param(ql2xenableclass2, int, S_IRUGO|S_IRUSR);\nMODULE_PARM_DESC(ql2xenableclass2,\n\t\t\"Specify if Class 2 operations are supported from the very \"\n\t\t\"beginning. Default is 0 - class 2 not supported.\");\n\n\nint ql2xlogintimeout = 20;\nmodule_param(ql2xlogintimeout, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xlogintimeout,\n\t\t\"Login timeout value in seconds.\");\n\nint qlport_down_retry;\nmodule_param(qlport_down_retry, int, S_IRUGO);\nMODULE_PARM_DESC(qlport_down_retry,\n\t\t\"Maximum number of command retries to a port that returns \"\n\t\t\"a PORT-DOWN status.\");\n\nint ql2xplogiabsentdevice;\nmodule_param(ql2xplogiabsentdevice, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xplogiabsentdevice,\n\t\t\"Option to enable PLOGI to devices that are not present after \"\n\t\t\"a Fabric scan.  This is needed for several broken switches. \"\n\t\t\"Default is 0 - no PLOGI. 1 - perform PLOGI.\");\n\nint ql2xloginretrycount;\nmodule_param(ql2xloginretrycount, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xloginretrycount,\n\t\t\"Specify an alternate value for the NVRAM login retry count.\");\n\nint ql2xallocfwdump = 1;\nmodule_param(ql2xallocfwdump, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xallocfwdump,\n\t\t\"Option to enable allocation of memory for a firmware dump \"\n\t\t\"during HBA initialization.  Memory allocation requirements \"\n\t\t\"vary by ISP type.  Default is 1 - allocate memory.\");\n\nint ql2xextended_error_logging;\nmodule_param(ql2xextended_error_logging, int, S_IRUGO|S_IWUSR);\nmodule_param_named(logging, ql2xextended_error_logging, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xextended_error_logging,\n\t\t\"Option to enable extended error logging,\\n\"\n\t\t\"\\t\\tDefault is 0 - no logging.  0x40000000 - Module Init & Probe.\\n\"\n\t\t\"\\t\\t0x20000000 - Mailbox Cmnds. 0x10000000 - Device Discovery.\\n\"\n\t\t\"\\t\\t0x08000000 - IO tracing.    0x04000000 - DPC Thread.\\n\"\n\t\t\"\\t\\t0x02000000 - Async events.  0x01000000 - Timer routines.\\n\"\n\t\t\"\\t\\t0x00800000 - User space.    0x00400000 - Task Management.\\n\"\n\t\t\"\\t\\t0x00200000 - AER/EEH.       0x00100000 - Multi Q.\\n\"\n\t\t\"\\t\\t0x00080000 - P3P Specific.  0x00040000 - Virtual Port.\\n\"\n\t\t\"\\t\\t0x00020000 - Buffer Dump.   0x00010000 - Misc.\\n\"\n\t\t\"\\t\\t0x00008000 - Verbose.       0x00004000 - Target.\\n\"\n\t\t\"\\t\\t0x00002000 - Target Mgmt.   0x00001000 - Target TMF.\\n\"\n\t\t\"\\t\\t0x7fffffff - For enabling all logs, can be too many logs.\\n\"\n\t\t\"\\t\\t0x1e400000 - Preferred value for capturing essential \"\n\t\t\"debug information (equivalent to old \"\n\t\t\"ql2xextended_error_logging=1).\\n\"\n\t\t\"\\t\\tDo LOGICAL OR of the value to enable more than one level\");\n\nint ql2xextended_error_logging_ktrace = 1;\nmodule_param(ql2xextended_error_logging_ktrace, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xextended_error_logging_ktrace,\n\t\t\"Same BIT definition as ql2xextended_error_logging, but used to control logging to kernel trace buffer (default=1).\\n\");\n\nint ql2xshiftctondsd = 6;\nmodule_param(ql2xshiftctondsd, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xshiftctondsd,\n\t\t\"Set to control shifting of command type processing \"\n\t\t\"based on total number of SG elements.\");\n\nint ql2xfdmienable = 1;\nmodule_param(ql2xfdmienable, int, S_IRUGO|S_IWUSR);\nmodule_param_named(fdmi, ql2xfdmienable, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xfdmienable,\n\t\t\"Enables FDMI registrations. \"\n\t\t\"0 - no FDMI registrations. \"\n\t\t\"1 - provide FDMI registrations (default).\");\n\n#define MAX_Q_DEPTH\t64\nstatic int ql2xmaxqdepth = MAX_Q_DEPTH;\nmodule_param(ql2xmaxqdepth, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xmaxqdepth,\n\t\t\"Maximum queue depth to set for each LUN. \"\n\t\t\"Default is 64.\");\n\nint ql2xenabledif = 2;\nmodule_param(ql2xenabledif, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xenabledif,\n\t\t\" Enable T10-CRC-DIF:\\n\"\n\t\t\" Default is 2.\\n\"\n\t\t\"  0 -- No DIF Support\\n\"\n\t\t\"  1 -- Enable DIF for all types\\n\"\n\t\t\"  2 -- Enable DIF for all types, except Type 0.\\n\");\n\n#if (IS_ENABLED(CONFIG_NVME_FC))\nint ql2xnvmeenable = 1;\n#else\nint ql2xnvmeenable;\n#endif\nmodule_param(ql2xnvmeenable, int, 0644);\nMODULE_PARM_DESC(ql2xnvmeenable,\n    \"Enables NVME support. \"\n    \"0 - no NVMe.  Default is Y\");\n\nint ql2xenablehba_err_chk = 2;\nmodule_param(ql2xenablehba_err_chk, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xenablehba_err_chk,\n\t\t\" Enable T10-CRC-DIF Error isolation by HBA:\\n\"\n\t\t\" Default is 2.\\n\"\n\t\t\"  0 -- Error isolation disabled\\n\"\n\t\t\"  1 -- Error isolation enabled only for DIX Type 0\\n\"\n\t\t\"  2 -- Error isolation enabled for all Types\\n\");\n\nint ql2xiidmaenable = 1;\nmodule_param(ql2xiidmaenable, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xiidmaenable,\n\t\t\"Enables iIDMA settings \"\n\t\t\"Default is 1 - perform iIDMA. 0 - no iIDMA.\");\n\nint ql2xmqsupport = 1;\nmodule_param(ql2xmqsupport, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xmqsupport,\n\t\t\"Enable on demand multiple queue pairs support \"\n\t\t\"Default is 1 for supported. \"\n\t\t\"Set it to 0 to turn off mq qpair support.\");\n\nint ql2xfwloadbin;\nmodule_param(ql2xfwloadbin, int, S_IRUGO|S_IWUSR);\nmodule_param_named(fwload, ql2xfwloadbin, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xfwloadbin,\n\t\t\"Option to specify location from which to load ISP firmware:.\\n\"\n\t\t\" 2 -- load firmware via the request_firmware() (hotplug).\\n\"\n\t\t\"      interface.\\n\"\n\t\t\" 1 -- load firmware from flash.\\n\"\n\t\t\" 0 -- use default semantics.\\n\");\n\nint ql2xetsenable;\nmodule_param(ql2xetsenable, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xetsenable,\n\t\t\"Enables firmware ETS burst.\"\n\t\t\"Default is 0 - skip ETS enablement.\");\n\nint ql2xdbwr = 1;\nmodule_param(ql2xdbwr, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xdbwr,\n\t\t\"Option to specify scheme for request queue posting.\\n\"\n\t\t\" 0 -- Regular doorbell.\\n\"\n\t\t\" 1 -- CAMRAM doorbell (faster).\\n\");\n\nint ql2xgffidenable;\nmodule_param(ql2xgffidenable, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xgffidenable,\n\t\t\"Enables GFF_ID checks of port type. \"\n\t\t\"Default is 0 - Do not use GFF_ID information.\");\n\nint ql2xasynctmfenable = 1;\nmodule_param(ql2xasynctmfenable, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xasynctmfenable,\n\t\t\"Enables issue of TM IOCBs asynchronously via IOCB mechanism\"\n\t\t\"Default is 1 - Issue TM IOCBs via mailbox mechanism.\");\n\nint ql2xdontresethba;\nmodule_param(ql2xdontresethba, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xdontresethba,\n\t\t\"Option to specify reset behaviour.\\n\"\n\t\t\" 0 (Default) -- Reset on failure.\\n\"\n\t\t\" 1 -- Do not reset on failure.\\n\");\n\nuint64_t ql2xmaxlun = MAX_LUNS;\nmodule_param(ql2xmaxlun, ullong, S_IRUGO);\nMODULE_PARM_DESC(ql2xmaxlun,\n\t\t\"Defines the maximum LU number to register with the SCSI \"\n\t\t\"midlayer. Default is 65535.\");\n\nint ql2xmdcapmask = 0x1F;\nmodule_param(ql2xmdcapmask, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xmdcapmask,\n\t\t\"Set the Minidump driver capture mask level. \"\n\t\t\"Default is 0x1F - Can be set to 0x3, 0x7, 0xF, 0x1F, 0x7F.\");\n\nint ql2xmdenable = 1;\nmodule_param(ql2xmdenable, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xmdenable,\n\t\t\"Enable/disable MiniDump. \"\n\t\t\"0 - MiniDump disabled. \"\n\t\t\"1 (Default) - MiniDump enabled.\");\n\nint ql2xexlogins;\nmodule_param(ql2xexlogins, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xexlogins,\n\t\t \"Number of extended Logins. \"\n\t\t \"0 (Default)- Disabled.\");\n\nint ql2xexchoffld = 1024;\nmodule_param(ql2xexchoffld, uint, 0644);\nMODULE_PARM_DESC(ql2xexchoffld,\n\t\"Number of target exchanges.\");\n\nint ql2xiniexchg = 1024;\nmodule_param(ql2xiniexchg, uint, 0644);\nMODULE_PARM_DESC(ql2xiniexchg,\n\t\"Number of initiator exchanges.\");\n\nint ql2xfwholdabts;\nmodule_param(ql2xfwholdabts, int, S_IRUGO);\nMODULE_PARM_DESC(ql2xfwholdabts,\n\t\t\"Allow FW to hold status IOCB until ABTS rsp received. \"\n\t\t\"0 (Default) Do not set fw option. \"\n\t\t\"1 - Set fw option to hold ABTS.\");\n\nint ql2xmvasynctoatio = 1;\nmodule_param(ql2xmvasynctoatio, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql2xmvasynctoatio,\n\t\t\"Move PUREX, ABTS RX and RIDA IOCBs to ATIOQ\"\n\t\t\"0 (Default). Do not move IOCBs\"\n\t\t\"1 - Move IOCBs.\");\n\nint ql2xautodetectsfp = 1;\nmodule_param(ql2xautodetectsfp, int, 0444);\nMODULE_PARM_DESC(ql2xautodetectsfp,\n\t\t \"Detect SFP range and set appropriate distance.\\n\"\n\t\t \"1 (Default): Enable\\n\");\n\nint ql2xenablemsix = 1;\nmodule_param(ql2xenablemsix, int, 0444);\nMODULE_PARM_DESC(ql2xenablemsix,\n\t\t \"Set to enable MSI or MSI-X interrupt mechanism.\\n\"\n\t\t \" Default is 1, enable MSI-X interrupt mechanism.\\n\"\n\t\t \" 0 -- enable traditional pin-based mechanism.\\n\"\n\t\t \" 1 -- enable MSI-X interrupt mechanism.\\n\"\n\t\t \" 2 -- enable MSI interrupt mechanism.\\n\");\n\nint qla2xuseresexchforels;\nmodule_param(qla2xuseresexchforels, int, 0444);\nMODULE_PARM_DESC(qla2xuseresexchforels,\n\t\t \"Reserve 1/2 of emergency exchanges for ELS.\\n\"\n\t\t \" 0 (default): disabled\");\n\nstatic int ql2xprotmask;\nmodule_param(ql2xprotmask, int, 0644);\nMODULE_PARM_DESC(ql2xprotmask,\n\t\t \"Override DIF/DIX protection capabilities mask\\n\"\n\t\t \"Default is 0 which sets protection mask based on \"\n\t\t \"capabilities reported by HBA firmware.\\n\");\n\nstatic int ql2xprotguard;\nmodule_param(ql2xprotguard, int, 0644);\nMODULE_PARM_DESC(ql2xprotguard, \"Override choice of DIX checksum\\n\"\n\t\t \"  0 -- Let HBA firmware decide\\n\"\n\t\t \"  1 -- Force T10 CRC\\n\"\n\t\t \"  2 -- Force IP checksum\\n\");\n\nint ql2xdifbundlinginternalbuffers;\nmodule_param(ql2xdifbundlinginternalbuffers, int, 0644);\nMODULE_PARM_DESC(ql2xdifbundlinginternalbuffers,\n    \"Force using internal buffers for DIF information\\n\"\n    \"0 (Default). Based on check.\\n\"\n    \"1 Force using internal buffers\\n\");\n\nint ql2xsmartsan;\nmodule_param(ql2xsmartsan, int, 0444);\nmodule_param_named(smartsan, ql2xsmartsan, int, 0444);\nMODULE_PARM_DESC(ql2xsmartsan,\n\t\t\"Send SmartSAN Management Attributes for FDMI Registration.\"\n\t\t\" Default is 0 - No SmartSAN registration,\"\n\t\t\" 1 - Register SmartSAN Management Attributes.\");\n\nint ql2xrdpenable;\nmodule_param(ql2xrdpenable, int, 0444);\nmodule_param_named(rdpenable, ql2xrdpenable, int, 0444);\nMODULE_PARM_DESC(ql2xrdpenable,\n\t\t\"Enables RDP responses. \"\n\t\t\"0 - no RDP responses (default). \"\n\t\t\"1 - provide RDP responses.\");\nint ql2xabts_wait_nvme = 1;\nmodule_param(ql2xabts_wait_nvme, int, 0444);\nMODULE_PARM_DESC(ql2xabts_wait_nvme,\n\t\t \"To wait for ABTS response on I/O timeouts for NVMe. (default: 1)\");\n\n\nstatic u32 ql2xdelay_before_pci_error_handling = 5;\nmodule_param(ql2xdelay_before_pci_error_handling, uint, 0644);\nMODULE_PARM_DESC(ql2xdelay_before_pci_error_handling,\n\t\"Number of seconds delayed before qla begin PCI error self-handling (default: 5).\\n\");\n\nstatic void qla2x00_clear_drv_active(struct qla_hw_data *);\nstatic void qla2x00_free_device(scsi_qla_host_t *);\nstatic void qla2xxx_map_queues(struct Scsi_Host *shost);\nstatic void qla2x00_destroy_deferred_work(struct qla_hw_data *);\n\nu32 ql2xnvme_queues = DEF_NVME_HW_QUEUES;\nmodule_param(ql2xnvme_queues, uint, S_IRUGO);\nMODULE_PARM_DESC(ql2xnvme_queues,\n\t\"Number of NVMe Queues that can be configured.\\n\"\n\t\"Final value will be min(ql2xnvme_queues, num_cpus,num_chip_queues)\\n\"\n\t\"1 - Minimum number of queues supported\\n\"\n\t\"8 - Default value\");\n\nint ql2xfc2target = 1;\nmodule_param(ql2xfc2target, int, 0444);\nMODULE_PARM_DESC(qla2xfc2target,\n\t\t  \"Enables FC2 Target support. \"\n\t\t  \"0 - FC2 Target support is disabled. \"\n\t\t  \"1 - FC2 Target support is enabled (default).\");\n\nstatic struct scsi_transport_template *qla2xxx_transport_template = NULL;\nstruct scsi_transport_template *qla2xxx_transport_vport_template = NULL;\n\n \n\n__inline__ void\nqla2x00_start_timer(scsi_qla_host_t *vha, unsigned long interval)\n{\n\ttimer_setup(&vha->timer, qla2x00_timer, 0);\n\tvha->timer.expires = jiffies + interval * HZ;\n\tadd_timer(&vha->timer);\n\tvha->timer_active = 1;\n}\n\nstatic inline void\nqla2x00_restart_timer(scsi_qla_host_t *vha, unsigned long interval)\n{\n\t \n\tif (vha->device_flags & DFLG_DEV_FAILED) {\n\t\tql_dbg(ql_dbg_timer, vha, 0x600d,\n\t\t    \"Device in a failed state, returning.\\n\");\n\t\treturn;\n\t}\n\n\tmod_timer(&vha->timer, jiffies + interval * HZ);\n}\n\nstatic __inline__ void\nqla2x00_stop_timer(scsi_qla_host_t *vha)\n{\n\tdel_timer_sync(&vha->timer);\n\tvha->timer_active = 0;\n}\n\nstatic int qla2x00_do_dpc(void *data);\n\nstatic void qla2x00_rst_aen(scsi_qla_host_t *);\n\nstatic int qla2x00_mem_alloc(struct qla_hw_data *, uint16_t, uint16_t,\n\tstruct req_que **, struct rsp_que **);\nstatic void qla2x00_free_fw_dump(struct qla_hw_data *);\nstatic void qla2x00_mem_free(struct qla_hw_data *);\nint qla2xxx_mqueuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd,\n\tstruct qla_qpair *qpair);\n\n \nstatic void qla_init_base_qpair(struct scsi_qla_host *vha, struct req_que *req,\n    struct rsp_que *rsp)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\trsp->qpair = ha->base_qpair;\n\trsp->req = req;\n\tha->base_qpair->hw = ha;\n\tha->base_qpair->req = req;\n\tha->base_qpair->rsp = rsp;\n\tha->base_qpair->vha = vha;\n\tha->base_qpair->qp_lock_ptr = &ha->hardware_lock;\n\tha->base_qpair->use_shadow_reg = IS_SHADOW_REG_CAPABLE(ha) ? 1 : 0;\n\tha->base_qpair->msix = &ha->msix_entries[QLA_MSIX_RSP_Q];\n\tha->base_qpair->srb_mempool = ha->srb_mempool;\n\tINIT_LIST_HEAD(&ha->base_qpair->hints_list);\n\tINIT_LIST_HEAD(&ha->base_qpair->dsd_list);\n\tha->base_qpair->enable_class_2 = ql2xenableclass2;\n\t \n\tqla_cpu_update(rsp->qpair, raw_smp_processor_id());\n\tha->base_qpair->pdev = ha->pdev;\n\n\tif (IS_QLA27XX(ha) || IS_QLA83XX(ha) || IS_QLA28XX(ha))\n\t\tha->base_qpair->reqq_start_iocbs = qla_83xx_start_iocbs;\n}\n\nstatic int qla2x00_alloc_queues(struct qla_hw_data *ha, struct req_que *req,\n\t\t\t\tstruct rsp_que *rsp)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\n\n\tha->req_q_map = kcalloc(ha->max_req_queues, sizeof(struct req_que *),\n\t\t\t\tGFP_KERNEL);\n\tif (!ha->req_q_map) {\n\t\tql_log(ql_log_fatal, vha, 0x003b,\n\t\t    \"Unable to allocate memory for request queue ptrs.\\n\");\n\t\tgoto fail_req_map;\n\t}\n\n\tha->rsp_q_map = kcalloc(ha->max_rsp_queues, sizeof(struct rsp_que *),\n\t\t\t\tGFP_KERNEL);\n\tif (!ha->rsp_q_map) {\n\t\tql_log(ql_log_fatal, vha, 0x003c,\n\t\t    \"Unable to allocate memory for response queue ptrs.\\n\");\n\t\tgoto fail_rsp_map;\n\t}\n\n\tha->base_qpair = kzalloc(sizeof(struct qla_qpair), GFP_KERNEL);\n\tif (ha->base_qpair == NULL) {\n\t\tql_log(ql_log_warn, vha, 0x00e0,\n\t\t    \"Failed to allocate base queue pair memory.\\n\");\n\t\tgoto fail_base_qpair;\n\t}\n\n\tqla_init_base_qpair(vha, req, rsp);\n\n\tif ((ql2xmqsupport || ql2xnvmeenable) && ha->max_qpairs) {\n\t\tha->queue_pair_map = kcalloc(ha->max_qpairs, sizeof(struct qla_qpair *),\n\t\t\tGFP_KERNEL);\n\t\tif (!ha->queue_pair_map) {\n\t\t\tql_log(ql_log_fatal, vha, 0x0180,\n\t\t\t    \"Unable to allocate memory for queue pair ptrs.\\n\");\n\t\t\tgoto fail_qpair_map;\n\t\t}\n\t\tif (qla_mapq_alloc_qp_cpu_map(ha) != 0) {\n\t\t\tkfree(ha->queue_pair_map);\n\t\t\tha->queue_pair_map = NULL;\n\t\t\tgoto fail_qpair_map;\n\t\t}\n\t}\n\n\t \n\tha->rsp_q_map[0] = rsp;\n\tha->req_q_map[0] = req;\n\tset_bit(0, ha->rsp_qid_map);\n\tset_bit(0, ha->req_qid_map);\n\treturn 0;\n\nfail_qpair_map:\n\tkfree(ha->base_qpair);\n\tha->base_qpair = NULL;\nfail_base_qpair:\n\tkfree(ha->rsp_q_map);\n\tha->rsp_q_map = NULL;\nfail_rsp_map:\n\tkfree(ha->req_q_map);\n\tha->req_q_map = NULL;\nfail_req_map:\n\treturn -ENOMEM;\n}\n\nstatic void qla2x00_free_req_que(struct qla_hw_data *ha, struct req_que *req)\n{\n\tif (IS_QLAFX00(ha)) {\n\t\tif (req && req->ring_fx00)\n\t\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t    (req->length_fx00 + 1) * sizeof(request_t),\n\t\t\t    req->ring_fx00, req->dma_fx00);\n\t} else if (req && req->ring)\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t(req->length + 1) * sizeof(request_t),\n\t\treq->ring, req->dma);\n\n\tif (req)\n\t\tkfree(req->outstanding_cmds);\n\n\tkfree(req);\n}\n\nstatic void qla2x00_free_rsp_que(struct qla_hw_data *ha, struct rsp_que *rsp)\n{\n\tif (IS_QLAFX00(ha)) {\n\t\tif (rsp && rsp->ring_fx00)\n\t\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t    (rsp->length_fx00 + 1) * sizeof(request_t),\n\t\t\t    rsp->ring_fx00, rsp->dma_fx00);\n\t} else if (rsp && rsp->ring) {\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t(rsp->length + 1) * sizeof(response_t),\n\t\trsp->ring, rsp->dma);\n\t}\n\tkfree(rsp);\n}\n\nstatic void qla2x00_free_queues(struct qla_hw_data *ha)\n{\n\tstruct req_que *req;\n\tstruct rsp_que *rsp;\n\tint cnt;\n\tunsigned long flags;\n\n\tif (ha->queue_pair_map) {\n\t\tkfree(ha->queue_pair_map);\n\t\tha->queue_pair_map = NULL;\n\t}\n\tif (ha->base_qpair) {\n\t\tkfree(ha->base_qpair);\n\t\tha->base_qpair = NULL;\n\t}\n\n\tqla_mapq_free_qp_cpu_map(ha);\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (cnt = 0; cnt < ha->max_req_queues; cnt++) {\n\t\tif (!test_bit(cnt, ha->req_qid_map))\n\t\t\tcontinue;\n\n\t\treq = ha->req_q_map[cnt];\n\t\tclear_bit(cnt, ha->req_qid_map);\n\t\tha->req_q_map[cnt] = NULL;\n\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\tqla2x00_free_req_que(ha, req);\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tkfree(ha->req_q_map);\n\tha->req_q_map = NULL;\n\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (cnt = 0; cnt < ha->max_rsp_queues; cnt++) {\n\t\tif (!test_bit(cnt, ha->rsp_qid_map))\n\t\t\tcontinue;\n\n\t\trsp = ha->rsp_q_map[cnt];\n\t\tclear_bit(cnt, ha->rsp_qid_map);\n\t\tha->rsp_q_map[cnt] =  NULL;\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\tqla2x00_free_rsp_que(ha, rsp);\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tkfree(ha->rsp_q_map);\n\tha->rsp_q_map = NULL;\n}\n\nstatic char *\nqla2x00_pci_info_str(struct scsi_qla_host *vha, char *str, size_t str_len)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstatic const char *const pci_bus_modes[] = {\n\t\t\"33\", \"66\", \"100\", \"133\",\n\t};\n\tuint16_t pci_bus;\n\n\tpci_bus = (ha->pci_attr & (BIT_9 | BIT_10)) >> 9;\n\tif (pci_bus) {\n\t\tsnprintf(str, str_len, \"PCI-X (%s MHz)\",\n\t\t\t pci_bus_modes[pci_bus]);\n\t} else {\n\t\tpci_bus = (ha->pci_attr & BIT_8) >> 8;\n\t\tsnprintf(str, str_len, \"PCI (%s MHz)\", pci_bus_modes[pci_bus]);\n\t}\n\n\treturn str;\n}\n\nstatic char *\nqla24xx_pci_info_str(struct scsi_qla_host *vha, char *str, size_t str_len)\n{\n\tstatic const char *const pci_bus_modes[] = {\n\t\t\"33\", \"66\", \"100\", \"133\",\n\t};\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t pci_bus;\n\n\tif (pci_is_pcie(ha->pdev)) {\n\t\tuint32_t lstat, lspeed, lwidth;\n\t\tconst char *speed_str;\n\n\t\tpcie_capability_read_dword(ha->pdev, PCI_EXP_LNKCAP, &lstat);\n\t\tlspeed = lstat & PCI_EXP_LNKCAP_SLS;\n\t\tlwidth = (lstat & PCI_EXP_LNKCAP_MLW) >> 4;\n\n\t\tswitch (lspeed) {\n\t\tcase 1:\n\t\t\tspeed_str = \"2.5GT/s\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tspeed_str = \"5.0GT/s\";\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tspeed_str = \"8.0GT/s\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tspeed_str = \"16.0GT/s\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspeed_str = \"<unknown>\";\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf(str, str_len, \"PCIe (%s x%d)\", speed_str, lwidth);\n\n\t\treturn str;\n\t}\n\n\tpci_bus = (ha->pci_attr & CSRX_PCIX_BUS_MODE_MASK) >> 8;\n\tif (pci_bus == 0 || pci_bus == 8)\n\t\tsnprintf(str, str_len, \"PCI (%s MHz)\",\n\t\t\t pci_bus_modes[pci_bus >> 3]);\n\telse\n\t\tsnprintf(str, str_len, \"PCI-X Mode %d (%s MHz)\",\n\t\t\t pci_bus & 4 ? 2 : 1,\n\t\t\t pci_bus_modes[pci_bus & 3]);\n\n\treturn str;\n}\n\nstatic char *\nqla2x00_fw_version_str(struct scsi_qla_host *vha, char *str, size_t size)\n{\n\tchar un_str[10];\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tsnprintf(str, size, \"%d.%02d.%02d \", ha->fw_major_version,\n\t    ha->fw_minor_version, ha->fw_subminor_version);\n\n\tif (ha->fw_attributes & BIT_9) {\n\t\tstrcat(str, \"FLX\");\n\t\treturn (str);\n\t}\n\n\tswitch (ha->fw_attributes & 0xFF) {\n\tcase 0x7:\n\t\tstrcat(str, \"EF\");\n\t\tbreak;\n\tcase 0x17:\n\t\tstrcat(str, \"TP\");\n\t\tbreak;\n\tcase 0x37:\n\t\tstrcat(str, \"IP\");\n\t\tbreak;\n\tcase 0x77:\n\t\tstrcat(str, \"VI\");\n\t\tbreak;\n\tdefault:\n\t\tsprintf(un_str, \"(%x)\", ha->fw_attributes);\n\t\tstrcat(str, un_str);\n\t\tbreak;\n\t}\n\tif (ha->fw_attributes & 0x100)\n\t\tstrcat(str, \"X\");\n\n\treturn (str);\n}\n\nstatic char *\nqla24xx_fw_version_str(struct scsi_qla_host *vha, char *str, size_t size)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tsnprintf(str, size, \"%d.%02d.%02d (%x)\", ha->fw_major_version,\n\t    ha->fw_minor_version, ha->fw_subminor_version, ha->fw_attributes);\n\treturn str;\n}\n\nvoid qla2x00_sp_free_dma(srb_t *sp)\n{\n\tstruct qla_hw_data *ha = sp->vha->hw;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\n\tif (sp->flags & SRB_DMA_VALID) {\n\t\tscsi_dma_unmap(cmd);\n\t\tsp->flags &= ~SRB_DMA_VALID;\n\t}\n\n\tif (sp->flags & SRB_CRC_PROT_DMA_VALID) {\n\t\tdma_unmap_sg(&ha->pdev->dev, scsi_prot_sglist(cmd),\n\t\t    scsi_prot_sg_count(cmd), cmd->sc_data_direction);\n\t\tsp->flags &= ~SRB_CRC_PROT_DMA_VALID;\n\t}\n\n\tif (sp->flags & SRB_CRC_CTX_DSD_VALID) {\n\t\t \n\t\tqla2x00_clean_dsd_pool(ha, sp->u.scmd.crc_ctx);\n\t\tsp->flags &= ~SRB_CRC_CTX_DSD_VALID;\n\t}\n\n\tif (sp->flags & SRB_CRC_CTX_DMA_VALID) {\n\t\tstruct crc_context *ctx0 = sp->u.scmd.crc_ctx;\n\n\t\tdma_pool_free(ha->dl_dma_pool, ctx0, ctx0->crc_ctx_dma);\n\t\tsp->flags &= ~SRB_CRC_CTX_DMA_VALID;\n\t}\n\n\tif (sp->flags & SRB_FCP_CMND_DMA_VALID) {\n\t\tstruct ct6_dsd *ctx1 = &sp->u.scmd.ct6_ctx;\n\n\t\tdma_pool_free(ha->fcp_cmnd_dma_pool, ctx1->fcp_cmnd,\n\t\t    ctx1->fcp_cmnd_dma);\n\t\tlist_splice(&ctx1->dsd_list, &sp->qpair->dsd_list);\n\t\tsp->qpair->dsd_inuse -= ctx1->dsd_use_cnt;\n\t\tsp->qpair->dsd_avail += ctx1->dsd_use_cnt;\n\t}\n\n\tif (sp->flags & SRB_GOT_BUF)\n\t\tqla_put_buf(sp->qpair, &sp->u.scmd.buf_dsc);\n}\n\nvoid qla2x00_sp_compl(srb_t *sp, int res)\n{\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tstruct completion *comp = sp->comp;\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\tcmd->result = res;\n\tsp->type = 0;\n\tscsi_done(cmd);\n\tif (comp)\n\t\tcomplete(comp);\n}\n\nvoid qla2xxx_qpair_sp_free_dma(srb_t *sp)\n{\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tstruct qla_hw_data *ha = sp->fcport->vha->hw;\n\n\tif (sp->flags & SRB_DMA_VALID) {\n\t\tscsi_dma_unmap(cmd);\n\t\tsp->flags &= ~SRB_DMA_VALID;\n\t}\n\n\tif (sp->flags & SRB_CRC_PROT_DMA_VALID) {\n\t\tdma_unmap_sg(&ha->pdev->dev, scsi_prot_sglist(cmd),\n\t\t    scsi_prot_sg_count(cmd), cmd->sc_data_direction);\n\t\tsp->flags &= ~SRB_CRC_PROT_DMA_VALID;\n\t}\n\n\tif (sp->flags & SRB_CRC_CTX_DSD_VALID) {\n\t\t \n\t\tqla2x00_clean_dsd_pool(ha, sp->u.scmd.crc_ctx);\n\t\tsp->flags &= ~SRB_CRC_CTX_DSD_VALID;\n\t}\n\n\tif (sp->flags & SRB_DIF_BUNDL_DMA_VALID) {\n\t\tstruct crc_context *difctx = sp->u.scmd.crc_ctx;\n\t\tstruct dsd_dma *dif_dsd, *nxt_dsd;\n\n\t\tlist_for_each_entry_safe(dif_dsd, nxt_dsd,\n\t\t    &difctx->ldif_dma_hndl_list, list) {\n\t\t\tlist_del(&dif_dsd->list);\n\t\t\tdma_pool_free(ha->dif_bundl_pool, dif_dsd->dsd_addr,\n\t\t\t    dif_dsd->dsd_list_dma);\n\t\t\tkfree(dif_dsd);\n\t\t\tdifctx->no_dif_bundl--;\n\t\t}\n\n\t\tlist_for_each_entry_safe(dif_dsd, nxt_dsd,\n\t\t    &difctx->ldif_dsd_list, list) {\n\t\t\tlist_del(&dif_dsd->list);\n\t\t\tdma_pool_free(ha->dl_dma_pool, dif_dsd->dsd_addr,\n\t\t\t    dif_dsd->dsd_list_dma);\n\t\t\tkfree(dif_dsd);\n\t\t\tdifctx->no_ldif_dsd--;\n\t\t}\n\n\t\tif (difctx->no_ldif_dsd) {\n\t\t\tql_dbg(ql_dbg_tgt+ql_dbg_verbose, sp->vha, 0xe022,\n\t\t\t    \"%s: difctx->no_ldif_dsd=%x\\n\",\n\t\t\t    __func__, difctx->no_ldif_dsd);\n\t\t}\n\n\t\tif (difctx->no_dif_bundl) {\n\t\t\tql_dbg(ql_dbg_tgt+ql_dbg_verbose, sp->vha, 0xe022,\n\t\t\t    \"%s: difctx->no_dif_bundl=%x\\n\",\n\t\t\t    __func__, difctx->no_dif_bundl);\n\t\t}\n\t\tsp->flags &= ~SRB_DIF_BUNDL_DMA_VALID;\n\t}\n\n\tif (sp->flags & SRB_FCP_CMND_DMA_VALID) {\n\t\tstruct ct6_dsd *ctx1 = &sp->u.scmd.ct6_ctx;\n\n\t\tdma_pool_free(ha->fcp_cmnd_dma_pool, ctx1->fcp_cmnd,\n\t\t    ctx1->fcp_cmnd_dma);\n\t\tlist_splice(&ctx1->dsd_list, &sp->qpair->dsd_list);\n\t\tsp->qpair->dsd_inuse -= ctx1->dsd_use_cnt;\n\t\tsp->qpair->dsd_avail += ctx1->dsd_use_cnt;\n\t\tsp->flags &= ~SRB_FCP_CMND_DMA_VALID;\n\t}\n\n\tif (sp->flags & SRB_CRC_CTX_DMA_VALID) {\n\t\tstruct crc_context *ctx0 = sp->u.scmd.crc_ctx;\n\n\t\tdma_pool_free(ha->dl_dma_pool, ctx0, ctx0->crc_ctx_dma);\n\t\tsp->flags &= ~SRB_CRC_CTX_DMA_VALID;\n\t}\n\n\tif (sp->flags & SRB_GOT_BUF)\n\t\tqla_put_buf(sp->qpair, &sp->u.scmd.buf_dsc);\n}\n\nvoid qla2xxx_qpair_sp_compl(srb_t *sp, int res)\n{\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tstruct completion *comp = sp->comp;\n\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\tcmd->result = res;\n\tsp->type = 0;\n\tscsi_done(cmd);\n\tif (comp)\n\t\tcomplete(comp);\n}\n\nstatic int\nqla2xxx_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\n{\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tfc_port_t *fcport = (struct fc_port *) cmd->device->hostdata;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmd->device));\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tsrb_t *sp;\n\tint rval;\n\n\tif (unlikely(test_bit(UNLOADING, &base_vha->dpc_flags)) ||\n\t    WARN_ON_ONCE(!rport)) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\tgoto qc24_fail_command;\n\t}\n\n\tif (ha->mqenable) {\n\t\tuint32_t tag;\n\t\tuint16_t hwq;\n\t\tstruct qla_qpair *qpair = NULL;\n\n\t\ttag = blk_mq_unique_tag(scsi_cmd_to_rq(cmd));\n\t\thwq = blk_mq_unique_tag_to_hwq(tag);\n\t\tqpair = ha->queue_pair_map[hwq];\n\n\t\tif (qpair)\n\t\t\treturn qla2xxx_mqueuecommand(host, cmd, qpair);\n\t}\n\n\tif (ha->flags.eeh_busy) {\n\t\tif (ha->flags.pci_channel_io_perm_failure) {\n\t\t\tql_dbg(ql_dbg_aer, vha, 0x9010,\n\t\t\t    \"PCI Channel IO permanent failure, exiting \"\n\t\t\t    \"cmd=%p.\\n\", cmd);\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_aer, vha, 0x9011,\n\t\t\t    \"EEH_Busy, Requeuing the cmd=%p.\\n\", cmd);\n\t\t\tcmd->result = DID_REQUEUE << 16;\n\t\t}\n\t\tgoto qc24_fail_command;\n\t}\n\n\trval = fc_remote_port_chkready(rport);\n\tif (rval) {\n\t\tcmd->result = rval;\n\t\tql_dbg(ql_dbg_io + ql_dbg_verbose, vha, 0x3003,\n\t\t    \"fc_remote_port_chkready failed for cmd=%p, rval=0x%x.\\n\",\n\t\t    cmd, rval);\n\t\tgoto qc24_fail_command;\n\t}\n\n\tif (!vha->flags.difdix_supported &&\n\t\tscsi_get_prot_op(cmd) != SCSI_PROT_NORMAL) {\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3004,\n\t\t\t    \"DIF Cap not reg, fail DIF capable cmd's:%p.\\n\",\n\t\t\t    cmd);\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\tgoto qc24_fail_command;\n\t}\n\n\tif (!fcport || fcport->deleted) {\n\t\tcmd->result = DID_IMM_RETRY << 16;\n\t\tgoto qc24_fail_command;\n\t}\n\n\tif (atomic_read(&fcport->state) != FCS_ONLINE || fcport->deleted) {\n\t\tif (atomic_read(&fcport->state) == FCS_DEVICE_DEAD ||\n\t\t\tatomic_read(&base_vha->loop_state) == LOOP_DEAD) {\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3005,\n\t\t\t    \"Returning DNC, fcport_state=%d loop_state=%d.\\n\",\n\t\t\t    atomic_read(&fcport->state),\n\t\t\t    atomic_read(&base_vha->loop_state));\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\tgoto qc24_fail_command;\n\t\t}\n\t\tgoto qc24_target_busy;\n\t}\n\n\t \n\tif (fcport->retry_delay_timestamp == 0) {\n\t\t \n\t} else if (time_after(jiffies, fcport->retry_delay_timestamp))\n\t\tfcport->retry_delay_timestamp = 0;\n\telse\n\t\tgoto qc24_target_busy;\n\n\tsp = scsi_cmd_priv(cmd);\n\t \n\tqla2xxx_init_sp(sp, vha, vha->hw->base_qpair, fcport);\n\n\tsp->u.scmd.cmd = cmd;\n\tsp->type = SRB_SCSI_CMD;\n\tsp->free = qla2x00_sp_free_dma;\n\tsp->done = qla2x00_sp_compl;\n\n\trval = ha->isp_ops->start_scsi(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_io + ql_dbg_verbose, vha, 0x3013,\n\t\t    \"Start scsi failed rval=%d for cmd=%p.\\n\", rval, cmd);\n\t\tgoto qc24_host_busy_free_sp;\n\t}\n\n\treturn 0;\n\nqc24_host_busy_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\nqc24_target_busy:\n\treturn SCSI_MLQUEUE_TARGET_BUSY;\n\nqc24_fail_command:\n\tscsi_done(cmd);\n\n\treturn 0;\n}\n\n \nint\nqla2xxx_mqueuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd,\n    struct qla_qpair *qpair)\n{\n\tscsi_qla_host_t *vha = shost_priv(host);\n\tfc_port_t *fcport = (struct fc_port *) cmd->device->hostdata;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmd->device));\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tsrb_t *sp;\n\tint rval;\n\n\trval = rport ? fc_remote_port_chkready(rport) : (DID_NO_CONNECT << 16);\n\tif (rval) {\n\t\tcmd->result = rval;\n\t\tql_dbg(ql_dbg_io + ql_dbg_verbose, vha, 0x3076,\n\t\t    \"fc_remote_port_chkready failed for cmd=%p, rval=0x%x.\\n\",\n\t\t    cmd, rval);\n\t\tgoto qc24_fail_command;\n\t}\n\n\tif (!qpair->online) {\n\t\tql_dbg(ql_dbg_io, vha, 0x3077,\n\t\t       \"qpair not online. eeh_busy=%d.\\n\", ha->flags.eeh_busy);\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\tgoto qc24_fail_command;\n\t}\n\n\tif (!fcport || fcport->deleted) {\n\t\tcmd->result = DID_IMM_RETRY << 16;\n\t\tgoto qc24_fail_command;\n\t}\n\n\tif (atomic_read(&fcport->state) != FCS_ONLINE || fcport->deleted) {\n\t\tif (atomic_read(&fcport->state) == FCS_DEVICE_DEAD ||\n\t\t\tatomic_read(&base_vha->loop_state) == LOOP_DEAD) {\n\t\t\tql_dbg(ql_dbg_io, vha, 0x3077,\n\t\t\t    \"Returning DNC, fcport_state=%d loop_state=%d.\\n\",\n\t\t\t    atomic_read(&fcport->state),\n\t\t\t    atomic_read(&base_vha->loop_state));\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\tgoto qc24_fail_command;\n\t\t}\n\t\tgoto qc24_target_busy;\n\t}\n\n\t \n\tif (fcport->retry_delay_timestamp == 0) {\n\t\t \n\t} else if (time_after(jiffies, fcport->retry_delay_timestamp))\n\t\tfcport->retry_delay_timestamp = 0;\n\telse\n\t\tgoto qc24_target_busy;\n\n\tsp = scsi_cmd_priv(cmd);\n\t \n\tqla2xxx_init_sp(sp, vha, qpair, fcport);\n\n\tsp->u.scmd.cmd = cmd;\n\tsp->type = SRB_SCSI_CMD;\n\tsp->free = qla2xxx_qpair_sp_free_dma;\n\tsp->done = qla2xxx_qpair_sp_compl;\n\n\trval = ha->isp_ops->start_scsi_mq(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_io + ql_dbg_verbose, vha, 0x3078,\n\t\t    \"Start scsi failed rval=%d for cmd=%p.\\n\", rval, cmd);\n\t\tgoto qc24_host_busy_free_sp;\n\t}\n\n\treturn 0;\n\nqc24_host_busy_free_sp:\n\t \n\tkref_put(&sp->cmd_kref, qla2x00_sp_release);\n\nqc24_target_busy:\n\treturn SCSI_MLQUEUE_TARGET_BUSY;\n\nqc24_fail_command:\n\tscsi_done(cmd);\n\n\treturn 0;\n}\n\n \nint\nqla2x00_wait_for_hba_online(scsi_qla_host_t *vha)\n{\n\tint\t\treturn_status;\n\tunsigned long\twait_online;\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\twait_online = jiffies + (MAX_LOOP_TIMEOUT * HZ);\n\twhile (((test_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags)) ||\n\t    test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags) ||\n\t    test_bit(ISP_ABORT_RETRY, &base_vha->dpc_flags) ||\n\t    ha->dpc_active) && time_before(jiffies, wait_online)) {\n\n\t\tmsleep(1000);\n\t}\n\tif (base_vha->flags.online)\n\t\treturn_status = QLA_SUCCESS;\n\telse\n\t\treturn_status = QLA_FUNCTION_FAILED;\n\n\treturn (return_status);\n}\n\nstatic inline int test_fcport_count(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tunsigned long flags;\n\tint res;\n\t \n\n\tspin_lock_irqsave(&ha->tgt.sess_lock, flags);\n\tql_dbg(ql_dbg_init, vha, 0x00ec,\n\t    \"tgt %p, fcport_count=%d\\n\",\n\t    vha, vha->fcport_count);\n\tres = (vha->fcport_count == 0);\n\tif  (res) {\n\t\tstruct fc_port *fcport;\n\n\t\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t\tif (fcport->deleted != QLA_SESS_DELETED) {\n\t\t\t\t \n\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->tgt.sess_lock, flags);\n\n\treturn res;\n}\n\n \nvoid\nqla2x00_wait_for_sess_deletion(scsi_qla_host_t *vha)\n{\n\tu8 i;\n\n\tqla2x00_mark_all_devices_lost(vha);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tif (wait_event_timeout(vha->fcport_waitQ,\n\t\t    test_fcport_count(vha), HZ) > 0)\n\t\t\tbreak;\n\t}\n\n\tflush_workqueue(vha->hw->wq);\n}\n\n \nstatic void\nqla2x00_wait_for_hba_ready(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\twhile ((qla2x00_reset_active(vha) || ha->dpc_active ||\n\t\tha->flags.mbox_busy) ||\n\t       test_bit(FX00_RESET_RECOVERY, &vha->dpc_flags) ||\n\t       test_bit(FX00_TARGET_SCAN, &vha->dpc_flags)) {\n\t\tif (test_bit(UNLOADING, &base_vha->dpc_flags))\n\t\t\tbreak;\n\t\tmsleep(1000);\n\t}\n}\n\nint\nqla2x00_wait_for_chip_reset(scsi_qla_host_t *vha)\n{\n\tint\t\treturn_status;\n\tunsigned long\twait_reset;\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\twait_reset = jiffies + (MAX_LOOP_TIMEOUT * HZ);\n\twhile (((test_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags)) ||\n\t    test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags) ||\n\t    test_bit(ISP_ABORT_RETRY, &base_vha->dpc_flags) ||\n\t    ha->dpc_active) && time_before(jiffies, wait_reset)) {\n\n\t\tmsleep(1000);\n\n\t\tif (!test_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags) &&\n\t\t    ha->flags.chip_reset_done)\n\t\t\tbreak;\n\t}\n\tif (ha->flags.chip_reset_done)\n\t\treturn_status = QLA_SUCCESS;\n\telse\n\t\treturn_status = QLA_FUNCTION_FAILED;\n\n\treturn return_status;\n}\n\n \nstatic int\nqla2xxx_eh_abort(struct scsi_cmnd *cmd)\n{\n\tscsi_qla_host_t *vha = shost_priv(cmd->device->host);\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tsrb_t *sp;\n\tint ret;\n\tunsigned int id;\n\tuint64_t lun;\n\tint rval;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t ratov_j;\n\tstruct qla_qpair *qpair;\n\tunsigned long flags;\n\tint fast_fail_status = SUCCESS;\n\n\tif (qla2x00_isp_reg_stat(ha)) {\n\t\tql_log(ql_log_info, vha, 0x8042,\n\t\t    \"PCI/Register disconnect, exiting.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t\treturn FAILED;\n\t}\n\n\t \n\tret = fc_block_scsi_eh(cmd);\n\tif (ret != 0)\n\t\tfast_fail_status = ret;\n\n\tsp = scsi_cmd_priv(cmd);\n\tqpair = sp->qpair;\n\n\tvha->cmd_timeout_cnt++;\n\n\tif ((sp->fcport && sp->fcport->deleted) || !qpair)\n\t\treturn fast_fail_status != SUCCESS ? fast_fail_status : FAILED;\n\n\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\tsp->comp = &comp;\n\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\n\tid = cmd->device->id;\n\tlun = cmd->device->lun;\n\n\tql_dbg(ql_dbg_taskm, vha, 0x8002,\n\t    \"Aborting from RISC nexus=%ld:%d:%llu sp=%p cmd=%p handle=%x\\n\",\n\t    vha->host_no, id, lun, sp, cmd, sp->handle);\n\n\t \n\trval = ha->isp_ops->abort_command(sp);\n\n\tql_dbg(ql_dbg_taskm, vha, 0x8003,\n\t       \"Abort command mbx cmd=%p, rval=%x.\\n\", cmd, rval);\n\n\t \n\tratov_j = ha->r_a_tov/10 * 4 * 1000;\n\tratov_j = msecs_to_jiffies(ratov_j);\n\tswitch (rval) {\n\tcase QLA_SUCCESS:\n\t\tif (!wait_for_completion_timeout(&comp, ratov_j)) {\n\t\t\tql_dbg(ql_dbg_taskm, vha, 0xffff,\n\t\t\t    \"%s: Abort wait timer (4 * R_A_TOV[%d]) expired\\n\",\n\t\t\t    __func__, ha->r_a_tov/10);\n\t\t\tret = FAILED;\n\t\t} else {\n\t\t\tret = fast_fail_status;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = FAILED;\n\t\tbreak;\n\t}\n\n\tsp->comp = NULL;\n\n\tql_log(ql_log_info, vha, 0x801c,\n\t    \"Abort command issued nexus=%ld:%d:%llu -- %x.\\n\",\n\t    vha->host_no, id, lun, ret);\n\n\treturn ret;\n}\n\n#define ABORT_POLLING_PERIOD\t1000\n#define ABORT_WAIT_ITER\t\t((2 * 1000) / (ABORT_POLLING_PERIOD))\n\n \nstatic int\n__qla2x00_eh_wait_for_pending_commands(struct qla_qpair *qpair, unsigned int t,\n\t\t\t\t       uint64_t l, enum nexus_wait_type type)\n{\n\tint cnt, match, status;\n\tunsigned long flags;\n\tscsi_qla_host_t *vha = qpair->vha;\n\tstruct req_que *req = qpair->req;\n\tsrb_t *sp;\n\tstruct scsi_cmnd *cmd;\n\tunsigned long wait_iter = ABORT_WAIT_ITER;\n\tbool found;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tstatus = QLA_SUCCESS;\n\n\twhile (wait_iter--) {\n\t\tfound = false;\n\n\t\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\t\tfor (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {\n\t\t\tsp = req->outstanding_cmds[cnt];\n\t\t\tif (!sp)\n\t\t\t\tcontinue;\n\t\t\tif (sp->type != SRB_SCSI_CMD)\n\t\t\t\tcontinue;\n\t\t\tif (vha->vp_idx != sp->vha->vp_idx)\n\t\t\t\tcontinue;\n\t\t\tmatch = 0;\n\t\t\tcmd = GET_CMD_SP(sp);\n\t\t\tswitch (type) {\n\t\t\tcase WAIT_HOST:\n\t\t\t\tmatch = 1;\n\t\t\t\tbreak;\n\t\t\tcase WAIT_TARGET:\n\t\t\t\tif (sp->fcport)\n\t\t\t\t\tmatch = sp->fcport->d_id.b24 == t;\n\t\t\t\telse\n\t\t\t\t\tmatch = 0;\n\t\t\t\tbreak;\n\t\t\tcase WAIT_LUN:\n\t\t\t\tif (sp->fcport)\n\t\t\t\t\tmatch = (sp->fcport->d_id.b24 == t &&\n\t\t\t\t\t\tcmd->device->lun == l);\n\t\t\t\telse\n\t\t\t\t\tmatch = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!match)\n\t\t\t\tcontinue;\n\n\t\t\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\t\t\tif (unlikely(pci_channel_offline(ha->pdev)) ||\n\t\t\t    ha->flags.eeh_busy) {\n\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0x8005,\n\t\t\t\t    \"Return:eh_wait.\\n\");\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\t \n\t\t\tmsleep(ABORT_POLLING_PERIOD);\n\t\t\tspin_lock_irqsave(qpair->qp_lock_ptr, flags);\n\t\t\tfound = true;\n\t\t}\n\t\tspin_unlock_irqrestore(qpair->qp_lock_ptr, flags);\n\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\n\tif (wait_iter == -1)\n\t\tstatus = QLA_FUNCTION_FAILED;\n\n\treturn status;\n}\n\nint\nqla2x00_eh_wait_for_pending_commands(scsi_qla_host_t *vha, unsigned int t,\n\t\t\t\t     uint64_t l, enum nexus_wait_type type)\n{\n\tstruct qla_qpair *qpair;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint i, status = QLA_SUCCESS;\n\n\tstatus = __qla2x00_eh_wait_for_pending_commands(ha->base_qpair, t, l,\n\t\t\t\t\t\t\ttype);\n\tfor (i = 0; status == QLA_SUCCESS && i < ha->max_qpairs; i++) {\n\t\tqpair = ha->queue_pair_map[i];\n\t\tif (!qpair)\n\t\t\tcontinue;\n\t\tstatus = __qla2x00_eh_wait_for_pending_commands(qpair, t, l,\n\t\t\t\t\t\t\t\ttype);\n\t}\n\treturn status;\n}\n\nstatic char *reset_errors[] = {\n\t\"HBA not online\",\n\t\"HBA not ready\",\n\t\"Task management failed\",\n\t\"Waiting for command completions\",\n};\n\nstatic int\nqla2xxx_eh_device_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tscsi_qla_host_t *vha = shost_priv(sdev->host);\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tfc_port_t *fcport = (struct fc_port *) sdev->hostdata;\n\tstruct qla_hw_data *ha = vha->hw;\n\tint err;\n\n\tif (qla2x00_isp_reg_stat(ha)) {\n\t\tql_log(ql_log_info, vha, 0x803e,\n\t\t    \"PCI/Register disconnect, exiting.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t\treturn FAILED;\n\t}\n\n\tif (!fcport) {\n\t\treturn FAILED;\n\t}\n\n\terr = fc_block_rport(rport);\n\tif (err != 0)\n\t\treturn err;\n\n\tif (fcport->deleted)\n\t\treturn FAILED;\n\n\tql_log(ql_log_info, vha, 0x8009,\n\t    \"DEVICE RESET ISSUED nexus=%ld:%d:%llu cmd=%p.\\n\", vha->host_no,\n\t    sdev->id, sdev->lun, cmd);\n\n\terr = 0;\n\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x800a,\n\t\t    \"Wait for hba online failed for cmd=%p.\\n\", cmd);\n\t\tgoto eh_reset_failed;\n\t}\n\terr = 2;\n\tif (ha->isp_ops->lun_reset(fcport, sdev->lun, 1)\n\t\t!= QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x800c,\n\t\t    \"do_reset failed for cmd=%p.\\n\", cmd);\n\t\tgoto eh_reset_failed;\n\t}\n\terr = 3;\n\tif (qla2x00_eh_wait_for_pending_commands(vha, fcport->d_id.b24,\n\t\t\t\t\t\t cmd->device->lun,\n\t\t\t\t\t\t WAIT_LUN) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x800d,\n\t\t    \"wait for pending cmds failed for cmd=%p.\\n\", cmd);\n\t\tgoto eh_reset_failed;\n\t}\n\n\tql_log(ql_log_info, vha, 0x800e,\n\t    \"DEVICE RESET SUCCEEDED nexus:%ld:%d:%llu cmd=%p.\\n\",\n\t    vha->host_no, sdev->id, sdev->lun, cmd);\n\n\treturn SUCCESS;\n\neh_reset_failed:\n\tql_log(ql_log_info, vha, 0x800f,\n\t    \"DEVICE RESET FAILED: %s nexus=%ld:%d:%llu cmd=%p.\\n\",\n\t    reset_errors[err], vha->host_no, sdev->id, sdev->lun,\n\t    cmd);\n\tvha->reset_cmd_err_cnt++;\n\treturn FAILED;\n}\n\nstatic int\nqla2xxx_eh_target_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tscsi_qla_host_t *vha = shost_priv(rport_to_shost(rport));\n\tstruct qla_hw_data *ha = vha->hw;\n\tfc_port_t *fcport = *(fc_port_t **)rport->dd_data;\n\tint err;\n\n\tif (qla2x00_isp_reg_stat(ha)) {\n\t\tql_log(ql_log_info, vha, 0x803f,\n\t\t    \"PCI/Register disconnect, exiting.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t\treturn FAILED;\n\t}\n\n\tif (!fcport) {\n\t\treturn FAILED;\n\t}\n\n\terr = fc_block_rport(rport);\n\tif (err != 0)\n\t\treturn err;\n\n\tif (fcport->deleted)\n\t\treturn FAILED;\n\n\tql_log(ql_log_info, vha, 0x8009,\n\t    \"TARGET RESET ISSUED nexus=%ld:%d cmd=%p.\\n\", vha->host_no,\n\t    sdev->id, cmd);\n\n\terr = 0;\n\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x800a,\n\t\t    \"Wait for hba online failed for cmd=%p.\\n\", cmd);\n\t\tgoto eh_reset_failed;\n\t}\n\terr = 2;\n\tif (ha->isp_ops->target_reset(fcport, 0, 0) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x800c,\n\t\t    \"target_reset failed for cmd=%p.\\n\", cmd);\n\t\tgoto eh_reset_failed;\n\t}\n\terr = 3;\n\tif (qla2x00_eh_wait_for_pending_commands(vha, fcport->d_id.b24, 0,\n\t\t\t\t\t\t WAIT_TARGET) != QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x800d,\n\t\t    \"wait for pending cmds failed for cmd=%p.\\n\", cmd);\n\t\tgoto eh_reset_failed;\n\t}\n\n\tql_log(ql_log_info, vha, 0x800e,\n\t    \"TARGET RESET SUCCEEDED nexus:%ld:%d cmd=%p.\\n\",\n\t    vha->host_no, sdev->id, cmd);\n\n\treturn SUCCESS;\n\neh_reset_failed:\n\tql_log(ql_log_info, vha, 0x800f,\n\t    \"TARGET RESET FAILED: %s nexus=%ld:%d:%llu cmd=%p.\\n\",\n\t    reset_errors[err], vha->host_no, cmd->device->id, cmd->device->lun,\n\t    cmd);\n\tvha->reset_cmd_err_cnt++;\n\treturn FAILED;\n}\n\n \nstatic int\nqla2xxx_eh_bus_reset(struct scsi_cmnd *cmd)\n{\n\tscsi_qla_host_t *vha = shost_priv(cmd->device->host);\n\tint ret = FAILED;\n\tunsigned int id;\n\tuint64_t lun;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (qla2x00_isp_reg_stat(ha)) {\n\t\tql_log(ql_log_info, vha, 0x8040,\n\t\t    \"PCI/Register disconnect, exiting.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t\treturn FAILED;\n\t}\n\n\tid = cmd->device->id;\n\tlun = cmd->device->lun;\n\n\tif (qla2x00_chip_is_down(vha))\n\t\treturn ret;\n\n\tql_log(ql_log_info, vha, 0x8012,\n\t    \"BUS RESET ISSUED nexus=%ld:%d:%llu.\\n\", vha->host_no, id, lun);\n\n\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, vha, 0x8013,\n\t\t    \"Wait for hba online failed board disabled.\\n\");\n\t\tgoto eh_bus_reset_done;\n\t}\n\n\tif (qla2x00_loop_reset(vha) == QLA_SUCCESS)\n\t\tret = SUCCESS;\n\n\tif (ret == FAILED)\n\t\tgoto eh_bus_reset_done;\n\n\t \n\tif (qla2x00_eh_wait_for_pending_commands(vha, 0, 0, WAIT_HOST) !=\n\t    QLA_SUCCESS) {\n\t\tql_log(ql_log_warn, vha, 0x8014,\n\t\t    \"Wait for pending commands failed.\\n\");\n\t\tret = FAILED;\n\t}\n\neh_bus_reset_done:\n\tql_log(ql_log_warn, vha, 0x802b,\n\t    \"BUS RESET %s nexus=%ld:%d:%llu.\\n\",\n\t    (ret == FAILED) ? \"FAILED\" : \"SUCCEEDED\", vha->host_no, id, lun);\n\n\treturn ret;\n}\n\n \nstatic int\nqla2xxx_eh_host_reset(struct scsi_cmnd *cmd)\n{\n\tscsi_qla_host_t *vha = shost_priv(cmd->device->host);\n\tstruct qla_hw_data *ha = vha->hw;\n\tint ret = FAILED;\n\tunsigned int id;\n\tuint64_t lun;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\tif (qla2x00_isp_reg_stat(ha)) {\n\t\tql_log(ql_log_info, vha, 0x8041,\n\t\t    \"PCI/Register disconnect, exiting.\\n\");\n\t\tqla_pci_set_eeh_busy(vha);\n\t\treturn SUCCESS;\n\t}\n\n\tid = cmd->device->id;\n\tlun = cmd->device->lun;\n\n\tql_log(ql_log_info, vha, 0x8018,\n\t    \"ADAPTER RESET ISSUED nexus=%ld:%d:%llu.\\n\", vha->host_no, id, lun);\n\n\t \n\tif (qla2x00_reset_active(vha) || ha->optrom_state != QLA_SWAITING)\n\t\tgoto eh_host_reset_lock;\n\n\tif (vha != base_vha) {\n\t\tif (qla2x00_vp_abort_isp(vha))\n\t\t\tgoto eh_host_reset_lock;\n\t} else {\n\t\tif (IS_P3P_TYPE(vha->hw)) {\n\t\t\tif (!qla82xx_fcoe_ctx_reset(vha)) {\n\t\t\t\t \n\t\t\t\tret = SUCCESS;\n\t\t\t\tgoto eh_host_reset_lock;\n\t\t\t}\n\t\t\t \n\t\t}\n\t\tif (ha->wq)\n\t\t\tflush_workqueue(ha->wq);\n\n\t\tset_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n\t\tif (ha->isp_ops->abort_isp(base_vha)) {\n\t\t\tclear_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n\t\t\t \n\t\t\tset_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags);\n\n\t\t\tif (qla2x00_wait_for_hba_online(vha) != QLA_SUCCESS) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x802a,\n\t\t\t\t    \"wait for hba online failed.\\n\");\n\t\t\t\tgoto eh_host_reset_lock;\n\t\t\t}\n\t\t}\n\t\tclear_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n\t}\n\n\t \n\tif (qla2x00_eh_wait_for_pending_commands(vha, 0, 0, WAIT_HOST) ==\n\t\tQLA_SUCCESS)\n\t\tret = SUCCESS;\n\neh_host_reset_lock:\n\tql_log(ql_log_info, vha, 0x8017,\n\t    \"ADAPTER RESET %s nexus=%ld:%d:%llu.\\n\",\n\t    (ret == FAILED) ? \"FAILED\" : \"SUCCEEDED\", vha->host_no, id, lun);\n\n\treturn ret;\n}\n\n \nint\nqla2x00_loop_reset(scsi_qla_host_t *vha)\n{\n\tint ret;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (IS_QLAFX00(ha))\n\t\treturn QLA_SUCCESS;\n\n\tif (ha->flags.enable_lip_full_login && !IS_CNA_CAPABLE(ha)) {\n\t\tatomic_set(&vha->loop_state, LOOP_DOWN);\n\t\tatomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\n\t\tqla2x00_mark_all_devices_lost(vha);\n\t\tret = qla2x00_full_login_lip(vha);\n\t\tif (ret != QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_taskm, vha, 0x802d,\n\t\t\t    \"full_login_lip=%d.\\n\", ret);\n\t\t}\n\t}\n\n\tif (ha->flags.enable_lip_reset) {\n\t\tret = qla2x00_lip_reset(vha);\n\t\tif (ret != QLA_SUCCESS)\n\t\t\tql_dbg(ql_dbg_taskm, vha, 0x802e,\n\t\t\t    \"lip_reset failed (%d).\\n\", ret);\n\t}\n\n\t \n\tvha->marker_needed = 1;\n\n\treturn QLA_SUCCESS;\n}\n\n \nstatic void qla2x00_abort_srb(struct qla_qpair *qp, srb_t *sp, const int res,\n\t\t\t      unsigned long *flags)\n\t__releases(qp->qp_lock_ptr)\n\t__acquires(qp->qp_lock_ptr)\n{\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tscsi_qla_host_t *vha = qp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\n\tint rval;\n\tbool ret_cmd;\n\tuint32_t ratov_j;\n\n\tlockdep_assert_held(qp->qp_lock_ptr);\n\n\tif (qla2x00_chip_is_down(vha)) {\n\t\tsp->done(sp, res);\n\t\treturn;\n\t}\n\n\tif (sp->type == SRB_NVME_CMD || sp->type == SRB_NVME_LS ||\n\t    (sp->type == SRB_SCSI_CMD && !ha->flags.eeh_busy &&\n\t     !test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\n\t     !qla2x00_isp_reg_stat(ha))) {\n\t\tif (sp->comp) {\n\t\t\tsp->done(sp, res);\n\t\t\treturn;\n\t\t}\n\n\t\tsp->comp = &comp;\n\t\tspin_unlock_irqrestore(qp->qp_lock_ptr, *flags);\n\n\t\trval = ha->isp_ops->abort_command(sp);\n\t\t \n\t\tret_cmd = false;\n\t\tratov_j = ha->r_a_tov/10 * 4 * 1000;\n\t\tratov_j = msecs_to_jiffies(ratov_j);\n\t\tswitch (rval) {\n\t\tcase QLA_SUCCESS:\n\t\t\tif (wait_for_completion_timeout(&comp, ratov_j)) {\n\t\t\t\tql_dbg(ql_dbg_taskm, vha, 0xffff,\n\t\t\t\t    \"%s: Abort wait timer (4 * R_A_TOV[%d]) expired\\n\",\n\t\t\t\t    __func__, ha->r_a_tov/10);\n\t\t\t\tret_cmd = true;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_cmd = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irqsave(qp->qp_lock_ptr, *flags);\n\t\tswitch (sp->type) {\n\t\tcase SRB_SCSI_CMD:\n\t\t\tif (ret_cmd && blk_mq_request_started(scsi_cmd_to_rq(cmd)))\n\t\t\t\tsp->done(sp, res);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ret_cmd)\n\t\t\t\tsp->done(sp, res);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsp->done(sp, res);\n\t}\n}\n\n \nstatic void\n__qla2x00_abort_all_cmds(struct qla_qpair *qp, int res)\n{\n\tint cnt;\n\tunsigned long flags;\n\tsrb_t *sp;\n\tscsi_qla_host_t *vha = qp->vha;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req;\n\tstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\n\tstruct qla_tgt_cmd *cmd;\n\n\tif (!ha->req_q_map)\n\t\treturn;\n\tspin_lock_irqsave(qp->qp_lock_ptr, flags);\n\treq = qp->req;\n\tfor (cnt = 1; cnt < req->num_outstanding_cmds; cnt++) {\n\t\tsp = req->outstanding_cmds[cnt];\n\t\tif (sp) {\n\t\t\t \n\t\t\tif (qla2x00_chip_is_down(vha)) {\n\t\t\t\treq->outstanding_cmds[cnt] = NULL;\n\t\t\t\tspin_unlock_irqrestore(qp->qp_lock_ptr, flags);\n\t\t\t\tsp->done(sp, res);\n\t\t\t\tspin_lock_irqsave(qp->qp_lock_ptr, flags);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (sp->cmd_type) {\n\t\t\tcase TYPE_SRB:\n\t\t\t\tqla2x00_abort_srb(qp, sp, res, &flags);\n\t\t\t\tbreak;\n\t\t\tcase TYPE_TGT_CMD:\n\t\t\t\tif (!vha->hw->tgt.tgt_ops || !tgt ||\n\t\t\t\t    qla_ini_mode_enabled(vha)) {\n\t\t\t\t\tql_dbg(ql_dbg_tgt_mgt, vha, 0xf003,\n\t\t\t\t\t    \"HOST-ABORT-HNDLR: dpc_flags=%lx. Target mode disabled\\n\",\n\t\t\t\t\t    vha->dpc_flags);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcmd = (struct qla_tgt_cmd *)sp;\n\t\t\t\tcmd->aborted = 1;\n\t\t\t\tbreak;\n\t\t\tcase TYPE_TGT_TMCMD:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treq->outstanding_cmds[cnt] = NULL;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(qp->qp_lock_ptr, flags);\n}\n\n \nvoid\nqla2x00_abort_all_cmds(scsi_qla_host_t *vha, int res)\n{\n\tint que;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (!ha->base_qpair)\n\t\treturn;\n\t__qla2x00_abort_all_cmds(ha->base_qpair, res);\n\n\tif (!ha->queue_pair_map)\n\t\treturn;\n\tfor (que = 0; que < ha->max_qpairs; que++) {\n\t\tif (!ha->queue_pair_map[que])\n\t\t\tcontinue;\n\n\t\t__qla2x00_abort_all_cmds(ha->queue_pair_map[que], res);\n\t}\n}\n\nstatic int\nqla2xxx_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\tsdev->hostdata = *(fc_port_t **)rport->dd_data;\n\n\treturn 0;\n}\n\nstatic int\nqla2xxx_slave_configure(struct scsi_device *sdev)\n{\n\tscsi_qla_host_t *vha = shost_priv(sdev->host);\n\tstruct req_que *req = vha->req;\n\n\tif (IS_T10_PI_CAPABLE(vha->hw))\n\t\tblk_queue_update_dma_alignment(sdev->request_queue, 0x7);\n\n\tscsi_change_queue_depth(sdev, req->max_q_depth);\n\treturn 0;\n}\n\nstatic void\nqla2xxx_slave_destroy(struct scsi_device *sdev)\n{\n\tsdev->hostdata = NULL;\n}\n\n \nstatic void\nqla2x00_config_dma_addressing(struct qla_hw_data *ha)\n{\n\t \n\tha->flags.enable_64bit_addressing = 0;\n\n\tif (!dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(64))) {\n\t\t \n\t\tif (MSD(dma_get_required_mask(&ha->pdev->dev)) &&\n\t\t    !dma_set_coherent_mask(&ha->pdev->dev, DMA_BIT_MASK(64))) {\n\t\t\t \n\t\t\tha->flags.enable_64bit_addressing = 1;\n\t\t\tha->isp_ops->calc_req_entries = qla2x00_calc_iocbs_64;\n\t\t\tha->isp_ops->build_iocbs = qla2x00_build_scsi_iocbs_64;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(32));\n\tdma_set_coherent_mask(&ha->pdev->dev, DMA_BIT_MASK(32));\n}\n\nstatic void\nqla2x00_enable_intrs(struct qla_hw_data *ha)\n{\n\tunsigned long flags = 0;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->interrupts_on = 1;\n\t \n\twrt_reg_word(&reg->ictrl, ICR_EN_INT | ICR_EN_RISC);\n\trd_reg_word(&reg->ictrl);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n}\n\nstatic void\nqla2x00_disable_intrs(struct qla_hw_data *ha)\n{\n\tunsigned long flags = 0;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->interrupts_on = 0;\n\t \n\twrt_reg_word(&reg->ictrl, 0);\n\trd_reg_word(&reg->ictrl);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nstatic void\nqla24xx_enable_intrs(struct qla_hw_data *ha)\n{\n\tunsigned long flags = 0;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->interrupts_on = 1;\n\twrt_reg_dword(&reg->ictrl, ICRX_EN_RISC_INT);\n\trd_reg_dword(&reg->ictrl);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nstatic void\nqla24xx_disable_intrs(struct qla_hw_data *ha)\n{\n\tunsigned long flags = 0;\n\tstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\n\n\tif (IS_NOPOLLING_TYPE(ha))\n\t\treturn;\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->interrupts_on = 0;\n\twrt_reg_dword(&reg->ictrl, 0);\n\trd_reg_dword(&reg->ictrl);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nstatic int\nqla2x00_iospace_config(struct qla_hw_data *ha)\n{\n\tresource_size_t pio;\n\tuint16_t msix;\n\n\tif (pci_request_selected_regions(ha->pdev, ha->bars,\n\t    QLA2XXX_DRIVER_NAME)) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0011,\n\t\t    \"Failed to reserve PIO/MMIO regions (%s), aborting.\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\tif (!(ha->bars & 1))\n\t\tgoto skip_pio;\n\n\t \n\tpio = pci_resource_start(ha->pdev, 0);\n\tif (pci_resource_flags(ha->pdev, 0) & IORESOURCE_IO) {\n\t\tif (pci_resource_len(ha->pdev, 0) < MIN_IOBASE_LEN) {\n\t\t\tql_log_pci(ql_log_warn, ha->pdev, 0x0012,\n\t\t\t    \"Invalid pci I/O region size (%s).\\n\",\n\t\t\t    pci_name(ha->pdev));\n\t\t\tpio = 0;\n\t\t}\n\t} else {\n\t\tql_log_pci(ql_log_warn, ha->pdev, 0x0013,\n\t\t    \"Region #0 no a PIO resource (%s).\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tpio = 0;\n\t}\n\tha->pio_address = pio;\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0014,\n\t    \"PIO address=%llu.\\n\",\n\t    (unsigned long long)ha->pio_address);\n\nskip_pio:\n\t \n\tif (!(pci_resource_flags(ha->pdev, 1) & IORESOURCE_MEM)) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0015,\n\t\t    \"Region #1 not an MMIO resource (%s), aborting.\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\tif (pci_resource_len(ha->pdev, 1) < MIN_IOBASE_LEN) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0016,\n\t\t    \"Invalid PCI mem region size (%s), aborting.\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\tha->iobase = ioremap(pci_resource_start(ha->pdev, 1), MIN_IOBASE_LEN);\n\tif (!ha->iobase) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0017,\n\t\t    \"Cannot remap MMIO (%s), aborting.\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\t \n\tha->max_req_queues = ha->max_rsp_queues = 1;\n\tha->msix_count = QLA_BASE_VECTORS;\n\n\t \n\tif (!(ha->fw_attributes & BIT_6))\n\t\tgoto mqiobase_exit;\n\n\tif (!ql2xmqsupport || !ql2xnvmeenable ||\n\t    (!IS_QLA25XX(ha) && !IS_QLA81XX(ha)))\n\t\tgoto mqiobase_exit;\n\n\tha->mqiobase = ioremap(pci_resource_start(ha->pdev, 3),\n\t\t\tpci_resource_len(ha->pdev, 3));\n\tif (ha->mqiobase) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0018,\n\t\t    \"MQIO Base=%p.\\n\", ha->mqiobase);\n\t\t \n\t\tpci_read_config_word(ha->pdev, QLA_PCI_MSIX_CONTROL, &msix);\n\t\tha->msix_count = msix + 1;\n\t\t \n\t\t \n\t\tha->max_req_queues = ha->msix_count - 1;\n\t\tha->max_rsp_queues = ha->max_req_queues;\n\t\t \n\t\tha->max_qpairs = ha->max_rsp_queues - 1;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0188,\n\t\t    \"Max no of queues pairs: %d.\\n\", ha->max_qpairs);\n\n\t\tql_log_pci(ql_log_info, ha->pdev, 0x001a,\n\t\t    \"MSI-X vector count: %d.\\n\", ha->msix_count);\n\t} else\n\t\tql_log_pci(ql_log_info, ha->pdev, 0x001b,\n\t\t    \"BAR 3 not enabled.\\n\");\n\nmqiobase_exit:\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x001c,\n\t    \"MSIX Count: %d.\\n\", ha->msix_count);\n\treturn (0);\n\niospace_error_exit:\n\treturn (-ENOMEM);\n}\n\n\nstatic int\nqla83xx_iospace_config(struct qla_hw_data *ha)\n{\n\tuint16_t msix;\n\n\tif (pci_request_selected_regions(ha->pdev, ha->bars,\n\t    QLA2XXX_DRIVER_NAME)) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0117,\n\t\t    \"Failed to reserve PIO/MMIO regions (%s), aborting.\\n\",\n\t\t    pci_name(ha->pdev));\n\n\t\tgoto iospace_error_exit;\n\t}\n\n\t \n\tif (!(pci_resource_flags(ha->pdev, 0) & IORESOURCE_MEM)) {\n\t\tql_log_pci(ql_log_warn, ha->pdev, 0x0118,\n\t\t    \"Invalid pci I/O region size (%s).\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\tif (pci_resource_len(ha->pdev, 0) < MIN_IOBASE_LEN) {\n\t\tql_log_pci(ql_log_warn, ha->pdev, 0x0119,\n\t\t    \"Invalid PCI mem region size (%s), aborting\\n\",\n\t\t\tpci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\tha->iobase = ioremap(pci_resource_start(ha->pdev, 0), MIN_IOBASE_LEN);\n\tif (!ha->iobase) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x011a,\n\t\t    \"Cannot remap MMIO (%s), aborting.\\n\",\n\t\t    pci_name(ha->pdev));\n\t\tgoto iospace_error_exit;\n\t}\n\n\t \n\t \n\tha->max_req_queues = ha->max_rsp_queues = 1;\n\tha->msix_count = QLA_BASE_VECTORS;\n\tha->mqiobase = ioremap(pci_resource_start(ha->pdev, 4),\n\t\t\tpci_resource_len(ha->pdev, 4));\n\n\tif (!ha->mqiobase) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x011d,\n\t\t    \"BAR2/region4 not enabled\\n\");\n\t\tgoto mqiobase_exit;\n\t}\n\n\tha->msixbase = ioremap(pci_resource_start(ha->pdev, 2),\n\t\t\tpci_resource_len(ha->pdev, 2));\n\tif (ha->msixbase) {\n\t\t \n\t\tpci_read_config_word(ha->pdev,\n\t\t    QLA_83XX_PCI_MSIX_CONTROL, &msix);\n\t\tha->msix_count = (msix & PCI_MSIX_FLAGS_QSIZE)  + 1;\n\t\t \n\t\tif (ql2xmqsupport || ql2xnvmeenable) {\n\t\t\t \n\t\t\tha->max_req_queues = ha->msix_count - 1;\n\n\t\t\t \n\t\t\tif (QLA_TGT_MODE_ENABLED())\n\t\t\t\tha->max_req_queues--;\n\n\t\t\tha->max_rsp_queues = ha->max_req_queues;\n\n\t\t\t \n\t\t\tha->max_qpairs = ha->max_req_queues - 1;\n\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x00e3,\n\t\t\t    \"Max no of queues pairs: %d.\\n\", ha->max_qpairs);\n\t\t}\n\t\tql_log_pci(ql_log_info, ha->pdev, 0x011c,\n\t\t    \"MSI-X vector count: %d.\\n\", ha->msix_count);\n\t} else\n\t\tql_log_pci(ql_log_info, ha->pdev, 0x011e,\n\t\t    \"BAR 1 not enabled.\\n\");\n\nmqiobase_exit:\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x011f,\n\t    \"MSIX Count: %d.\\n\", ha->msix_count);\n\treturn 0;\n\niospace_error_exit:\n\treturn -ENOMEM;\n}\n\nstatic struct isp_operations qla2100_isp_ops = {\n\t.pci_config\t\t= qla2100_pci_config,\n\t.reset_chip\t\t= qla2x00_reset_chip,\n\t.chip_diag\t\t= qla2x00_chip_diag,\n\t.config_rings\t\t= qla2x00_config_rings,\n\t.reset_adapter\t\t= qla2x00_reset_adapter,\n\t.nvram_config\t\t= qla2x00_nvram_config,\n\t.update_fw_options\t= qla2x00_update_fw_options,\n\t.load_risc\t\t= qla2x00_load_risc,\n\t.pci_info_str\t\t= qla2x00_pci_info_str,\n\t.fw_version_str\t\t= qla2x00_fw_version_str,\n\t.intr_handler\t\t= qla2100_intr_handler,\n\t.enable_intrs\t\t= qla2x00_enable_intrs,\n\t.disable_intrs\t\t= qla2x00_disable_intrs,\n\t.abort_command\t\t= qla2x00_abort_command,\n\t.target_reset\t\t= qla2x00_abort_target,\n\t.lun_reset\t\t= qla2x00_lun_reset,\n\t.fabric_login\t\t= qla2x00_login_fabric,\n\t.fabric_logout\t\t= qla2x00_fabric_logout,\n\t.calc_req_entries\t= qla2x00_calc_iocbs_32,\n\t.build_iocbs\t\t= qla2x00_build_scsi_iocbs_32,\n\t.prep_ms_iocb\t\t= qla2x00_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla2x00_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= qla2x00_read_nvram_data,\n\t.write_nvram\t\t= qla2x00_write_nvram_data,\n\t.fw_dump\t\t= qla2100_fw_dump,\n\t.beacon_on\t\t= NULL,\n\t.beacon_off\t\t= NULL,\n\t.beacon_blink\t\t= NULL,\n\t.read_optrom\t\t= qla2x00_read_optrom_data,\n\t.write_optrom\t\t= qla2x00_write_optrom_data,\n\t.get_flash_version\t= qla2x00_get_flash_version,\n\t.start_scsi\t\t= qla2x00_start_scsi,\n\t.start_scsi_mq          = NULL,\n\t.abort_isp\t\t= qla2x00_abort_isp,\n\t.iospace_config     \t= qla2x00_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic struct isp_operations qla2300_isp_ops = {\n\t.pci_config\t\t= qla2300_pci_config,\n\t.reset_chip\t\t= qla2x00_reset_chip,\n\t.chip_diag\t\t= qla2x00_chip_diag,\n\t.config_rings\t\t= qla2x00_config_rings,\n\t.reset_adapter\t\t= qla2x00_reset_adapter,\n\t.nvram_config\t\t= qla2x00_nvram_config,\n\t.update_fw_options\t= qla2x00_update_fw_options,\n\t.load_risc\t\t= qla2x00_load_risc,\n\t.pci_info_str\t\t= qla2x00_pci_info_str,\n\t.fw_version_str\t\t= qla2x00_fw_version_str,\n\t.intr_handler\t\t= qla2300_intr_handler,\n\t.enable_intrs\t\t= qla2x00_enable_intrs,\n\t.disable_intrs\t\t= qla2x00_disable_intrs,\n\t.abort_command\t\t= qla2x00_abort_command,\n\t.target_reset\t\t= qla2x00_abort_target,\n\t.lun_reset\t\t= qla2x00_lun_reset,\n\t.fabric_login\t\t= qla2x00_login_fabric,\n\t.fabric_logout\t\t= qla2x00_fabric_logout,\n\t.calc_req_entries\t= qla2x00_calc_iocbs_32,\n\t.build_iocbs\t\t= qla2x00_build_scsi_iocbs_32,\n\t.prep_ms_iocb\t\t= qla2x00_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla2x00_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= qla2x00_read_nvram_data,\n\t.write_nvram\t\t= qla2x00_write_nvram_data,\n\t.fw_dump\t\t= qla2300_fw_dump,\n\t.beacon_on\t\t= qla2x00_beacon_on,\n\t.beacon_off\t\t= qla2x00_beacon_off,\n\t.beacon_blink\t\t= qla2x00_beacon_blink,\n\t.read_optrom\t\t= qla2x00_read_optrom_data,\n\t.write_optrom\t\t= qla2x00_write_optrom_data,\n\t.get_flash_version\t= qla2x00_get_flash_version,\n\t.start_scsi\t\t= qla2x00_start_scsi,\n\t.start_scsi_mq          = NULL,\n\t.abort_isp\t\t= qla2x00_abort_isp,\n\t.iospace_config\t\t= qla2x00_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic struct isp_operations qla24xx_isp_ops = {\n\t.pci_config\t\t= qla24xx_pci_config,\n\t.reset_chip\t\t= qla24xx_reset_chip,\n\t.chip_diag\t\t= qla24xx_chip_diag,\n\t.config_rings\t\t= qla24xx_config_rings,\n\t.reset_adapter\t\t= qla24xx_reset_adapter,\n\t.nvram_config\t\t= qla24xx_nvram_config,\n\t.update_fw_options\t= qla24xx_update_fw_options,\n\t.load_risc\t\t= qla24xx_load_risc,\n\t.pci_info_str\t\t= qla24xx_pci_info_str,\n\t.fw_version_str\t\t= qla24xx_fw_version_str,\n\t.intr_handler\t\t= qla24xx_intr_handler,\n\t.enable_intrs\t\t= qla24xx_enable_intrs,\n\t.disable_intrs\t\t= qla24xx_disable_intrs,\n\t.abort_command\t\t= qla24xx_abort_command,\n\t.target_reset\t\t= qla24xx_abort_target,\n\t.lun_reset\t\t= qla24xx_lun_reset,\n\t.fabric_login\t\t= qla24xx_login_fabric,\n\t.fabric_logout\t\t= qla24xx_fabric_logout,\n\t.calc_req_entries\t= NULL,\n\t.build_iocbs\t\t= NULL,\n\t.prep_ms_iocb\t\t= qla24xx_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla24xx_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= qla24xx_read_nvram_data,\n\t.write_nvram\t\t= qla24xx_write_nvram_data,\n\t.fw_dump\t\t= qla24xx_fw_dump,\n\t.beacon_on\t\t= qla24xx_beacon_on,\n\t.beacon_off\t\t= qla24xx_beacon_off,\n\t.beacon_blink\t\t= qla24xx_beacon_blink,\n\t.read_optrom\t\t= qla24xx_read_optrom_data,\n\t.write_optrom\t\t= qla24xx_write_optrom_data,\n\t.get_flash_version\t= qla24xx_get_flash_version,\n\t.start_scsi\t\t= qla24xx_start_scsi,\n\t.start_scsi_mq          = NULL,\n\t.abort_isp\t\t= qla2x00_abort_isp,\n\t.iospace_config\t\t= qla2x00_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic struct isp_operations qla25xx_isp_ops = {\n\t.pci_config\t\t= qla25xx_pci_config,\n\t.reset_chip\t\t= qla24xx_reset_chip,\n\t.chip_diag\t\t= qla24xx_chip_diag,\n\t.config_rings\t\t= qla24xx_config_rings,\n\t.reset_adapter\t\t= qla24xx_reset_adapter,\n\t.nvram_config\t\t= qla24xx_nvram_config,\n\t.update_fw_options\t= qla24xx_update_fw_options,\n\t.load_risc\t\t= qla24xx_load_risc,\n\t.pci_info_str\t\t= qla24xx_pci_info_str,\n\t.fw_version_str\t\t= qla24xx_fw_version_str,\n\t.intr_handler\t\t= qla24xx_intr_handler,\n\t.enable_intrs\t\t= qla24xx_enable_intrs,\n\t.disable_intrs\t\t= qla24xx_disable_intrs,\n\t.abort_command\t\t= qla24xx_abort_command,\n\t.target_reset\t\t= qla24xx_abort_target,\n\t.lun_reset\t\t= qla24xx_lun_reset,\n\t.fabric_login\t\t= qla24xx_login_fabric,\n\t.fabric_logout\t\t= qla24xx_fabric_logout,\n\t.calc_req_entries\t= NULL,\n\t.build_iocbs\t\t= NULL,\n\t.prep_ms_iocb\t\t= qla24xx_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla24xx_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= qla25xx_read_nvram_data,\n\t.write_nvram\t\t= qla25xx_write_nvram_data,\n\t.fw_dump\t\t= qla25xx_fw_dump,\n\t.beacon_on\t\t= qla24xx_beacon_on,\n\t.beacon_off\t\t= qla24xx_beacon_off,\n\t.beacon_blink\t\t= qla24xx_beacon_blink,\n\t.read_optrom\t\t= qla25xx_read_optrom_data,\n\t.write_optrom\t\t= qla24xx_write_optrom_data,\n\t.get_flash_version\t= qla24xx_get_flash_version,\n\t.start_scsi\t\t= qla24xx_dif_start_scsi,\n\t.start_scsi_mq          = qla2xxx_dif_start_scsi_mq,\n\t.abort_isp\t\t= qla2x00_abort_isp,\n\t.iospace_config\t\t= qla2x00_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic struct isp_operations qla81xx_isp_ops = {\n\t.pci_config\t\t= qla25xx_pci_config,\n\t.reset_chip\t\t= qla24xx_reset_chip,\n\t.chip_diag\t\t= qla24xx_chip_diag,\n\t.config_rings\t\t= qla24xx_config_rings,\n\t.reset_adapter\t\t= qla24xx_reset_adapter,\n\t.nvram_config\t\t= qla81xx_nvram_config,\n\t.update_fw_options\t= qla24xx_update_fw_options,\n\t.load_risc\t\t= qla81xx_load_risc,\n\t.pci_info_str\t\t= qla24xx_pci_info_str,\n\t.fw_version_str\t\t= qla24xx_fw_version_str,\n\t.intr_handler\t\t= qla24xx_intr_handler,\n\t.enable_intrs\t\t= qla24xx_enable_intrs,\n\t.disable_intrs\t\t= qla24xx_disable_intrs,\n\t.abort_command\t\t= qla24xx_abort_command,\n\t.target_reset\t\t= qla24xx_abort_target,\n\t.lun_reset\t\t= qla24xx_lun_reset,\n\t.fabric_login\t\t= qla24xx_login_fabric,\n\t.fabric_logout\t\t= qla24xx_fabric_logout,\n\t.calc_req_entries\t= NULL,\n\t.build_iocbs\t\t= NULL,\n\t.prep_ms_iocb\t\t= qla24xx_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla24xx_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= NULL,\n\t.write_nvram\t\t= NULL,\n\t.fw_dump\t\t= qla81xx_fw_dump,\n\t.beacon_on\t\t= qla24xx_beacon_on,\n\t.beacon_off\t\t= qla24xx_beacon_off,\n\t.beacon_blink\t\t= qla83xx_beacon_blink,\n\t.read_optrom\t\t= qla25xx_read_optrom_data,\n\t.write_optrom\t\t= qla24xx_write_optrom_data,\n\t.get_flash_version\t= qla24xx_get_flash_version,\n\t.start_scsi\t\t= qla24xx_dif_start_scsi,\n\t.start_scsi_mq          = qla2xxx_dif_start_scsi_mq,\n\t.abort_isp\t\t= qla2x00_abort_isp,\n\t.iospace_config\t\t= qla2x00_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic struct isp_operations qla82xx_isp_ops = {\n\t.pci_config\t\t= qla82xx_pci_config,\n\t.reset_chip\t\t= qla82xx_reset_chip,\n\t.chip_diag\t\t= qla24xx_chip_diag,\n\t.config_rings\t\t= qla82xx_config_rings,\n\t.reset_adapter\t\t= qla24xx_reset_adapter,\n\t.nvram_config\t\t= qla81xx_nvram_config,\n\t.update_fw_options\t= qla24xx_update_fw_options,\n\t.load_risc\t\t= qla82xx_load_risc,\n\t.pci_info_str\t\t= qla24xx_pci_info_str,\n\t.fw_version_str\t\t= qla24xx_fw_version_str,\n\t.intr_handler\t\t= qla82xx_intr_handler,\n\t.enable_intrs\t\t= qla82xx_enable_intrs,\n\t.disable_intrs\t\t= qla82xx_disable_intrs,\n\t.abort_command\t\t= qla24xx_abort_command,\n\t.target_reset\t\t= qla24xx_abort_target,\n\t.lun_reset\t\t= qla24xx_lun_reset,\n\t.fabric_login\t\t= qla24xx_login_fabric,\n\t.fabric_logout\t\t= qla24xx_fabric_logout,\n\t.calc_req_entries\t= NULL,\n\t.build_iocbs\t\t= NULL,\n\t.prep_ms_iocb\t\t= qla24xx_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla24xx_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= qla24xx_read_nvram_data,\n\t.write_nvram\t\t= qla24xx_write_nvram_data,\n\t.fw_dump\t\t= qla82xx_fw_dump,\n\t.beacon_on\t\t= qla82xx_beacon_on,\n\t.beacon_off\t\t= qla82xx_beacon_off,\n\t.beacon_blink\t\t= NULL,\n\t.read_optrom\t\t= qla82xx_read_optrom_data,\n\t.write_optrom\t\t= qla82xx_write_optrom_data,\n\t.get_flash_version\t= qla82xx_get_flash_version,\n\t.start_scsi             = qla82xx_start_scsi,\n\t.start_scsi_mq          = NULL,\n\t.abort_isp\t\t= qla82xx_abort_isp,\n\t.iospace_config     \t= qla82xx_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic struct isp_operations qla8044_isp_ops = {\n\t.pci_config\t\t= qla82xx_pci_config,\n\t.reset_chip\t\t= qla82xx_reset_chip,\n\t.chip_diag\t\t= qla24xx_chip_diag,\n\t.config_rings\t\t= qla82xx_config_rings,\n\t.reset_adapter\t\t= qla24xx_reset_adapter,\n\t.nvram_config\t\t= qla81xx_nvram_config,\n\t.update_fw_options\t= qla24xx_update_fw_options,\n\t.load_risc\t\t= qla82xx_load_risc,\n\t.pci_info_str\t\t= qla24xx_pci_info_str,\n\t.fw_version_str\t\t= qla24xx_fw_version_str,\n\t.intr_handler\t\t= qla8044_intr_handler,\n\t.enable_intrs\t\t= qla82xx_enable_intrs,\n\t.disable_intrs\t\t= qla82xx_disable_intrs,\n\t.abort_command\t\t= qla24xx_abort_command,\n\t.target_reset\t\t= qla24xx_abort_target,\n\t.lun_reset\t\t= qla24xx_lun_reset,\n\t.fabric_login\t\t= qla24xx_login_fabric,\n\t.fabric_logout\t\t= qla24xx_fabric_logout,\n\t.calc_req_entries\t= NULL,\n\t.build_iocbs\t\t= NULL,\n\t.prep_ms_iocb\t\t= qla24xx_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla24xx_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= NULL,\n\t.write_nvram\t\t= NULL,\n\t.fw_dump\t\t= qla8044_fw_dump,\n\t.beacon_on\t\t= qla82xx_beacon_on,\n\t.beacon_off\t\t= qla82xx_beacon_off,\n\t.beacon_blink\t\t= NULL,\n\t.read_optrom\t\t= qla8044_read_optrom_data,\n\t.write_optrom\t\t= qla8044_write_optrom_data,\n\t.get_flash_version\t= qla82xx_get_flash_version,\n\t.start_scsi             = qla82xx_start_scsi,\n\t.start_scsi_mq          = NULL,\n\t.abort_isp\t\t= qla8044_abort_isp,\n\t.iospace_config\t\t= qla82xx_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic struct isp_operations qla83xx_isp_ops = {\n\t.pci_config\t\t= qla25xx_pci_config,\n\t.reset_chip\t\t= qla24xx_reset_chip,\n\t.chip_diag\t\t= qla24xx_chip_diag,\n\t.config_rings\t\t= qla24xx_config_rings,\n\t.reset_adapter\t\t= qla24xx_reset_adapter,\n\t.nvram_config\t\t= qla81xx_nvram_config,\n\t.update_fw_options\t= qla24xx_update_fw_options,\n\t.load_risc\t\t= qla81xx_load_risc,\n\t.pci_info_str\t\t= qla24xx_pci_info_str,\n\t.fw_version_str\t\t= qla24xx_fw_version_str,\n\t.intr_handler\t\t= qla24xx_intr_handler,\n\t.enable_intrs\t\t= qla24xx_enable_intrs,\n\t.disable_intrs\t\t= qla24xx_disable_intrs,\n\t.abort_command\t\t= qla24xx_abort_command,\n\t.target_reset\t\t= qla24xx_abort_target,\n\t.lun_reset\t\t= qla24xx_lun_reset,\n\t.fabric_login\t\t= qla24xx_login_fabric,\n\t.fabric_logout\t\t= qla24xx_fabric_logout,\n\t.calc_req_entries\t= NULL,\n\t.build_iocbs\t\t= NULL,\n\t.prep_ms_iocb\t\t= qla24xx_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla24xx_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= NULL,\n\t.write_nvram\t\t= NULL,\n\t.fw_dump\t\t= qla83xx_fw_dump,\n\t.beacon_on\t\t= qla24xx_beacon_on,\n\t.beacon_off\t\t= qla24xx_beacon_off,\n\t.beacon_blink\t\t= qla83xx_beacon_blink,\n\t.read_optrom\t\t= qla25xx_read_optrom_data,\n\t.write_optrom\t\t= qla24xx_write_optrom_data,\n\t.get_flash_version\t= qla24xx_get_flash_version,\n\t.start_scsi\t\t= qla24xx_dif_start_scsi,\n\t.start_scsi_mq          = qla2xxx_dif_start_scsi_mq,\n\t.abort_isp\t\t= qla2x00_abort_isp,\n\t.iospace_config\t\t= qla83xx_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic struct isp_operations qlafx00_isp_ops = {\n\t.pci_config\t\t= qlafx00_pci_config,\n\t.reset_chip\t\t= qlafx00_soft_reset,\n\t.chip_diag\t\t= qlafx00_chip_diag,\n\t.config_rings\t\t= qlafx00_config_rings,\n\t.reset_adapter\t\t= qlafx00_soft_reset,\n\t.nvram_config\t\t= NULL,\n\t.update_fw_options\t= NULL,\n\t.load_risc\t\t= NULL,\n\t.pci_info_str\t\t= qlafx00_pci_info_str,\n\t.fw_version_str\t\t= qlafx00_fw_version_str,\n\t.intr_handler\t\t= qlafx00_intr_handler,\n\t.enable_intrs\t\t= qlafx00_enable_intrs,\n\t.disable_intrs\t\t= qlafx00_disable_intrs,\n\t.abort_command\t\t= qla24xx_async_abort_command,\n\t.target_reset\t\t= qlafx00_abort_target,\n\t.lun_reset\t\t= qlafx00_lun_reset,\n\t.fabric_login\t\t= NULL,\n\t.fabric_logout\t\t= NULL,\n\t.calc_req_entries\t= NULL,\n\t.build_iocbs\t\t= NULL,\n\t.prep_ms_iocb\t\t= qla24xx_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla24xx_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= qla24xx_read_nvram_data,\n\t.write_nvram\t\t= qla24xx_write_nvram_data,\n\t.fw_dump\t\t= NULL,\n\t.beacon_on\t\t= qla24xx_beacon_on,\n\t.beacon_off\t\t= qla24xx_beacon_off,\n\t.beacon_blink\t\t= NULL,\n\t.read_optrom\t\t= qla24xx_read_optrom_data,\n\t.write_optrom\t\t= qla24xx_write_optrom_data,\n\t.get_flash_version\t= qla24xx_get_flash_version,\n\t.start_scsi\t\t= qlafx00_start_scsi,\n\t.start_scsi_mq          = NULL,\n\t.abort_isp\t\t= qlafx00_abort_isp,\n\t.iospace_config\t\t= qlafx00_iospace_config,\n\t.initialize_adapter\t= qlafx00_initialize_adapter,\n};\n\nstatic struct isp_operations qla27xx_isp_ops = {\n\t.pci_config\t\t= qla25xx_pci_config,\n\t.reset_chip\t\t= qla24xx_reset_chip,\n\t.chip_diag\t\t= qla24xx_chip_diag,\n\t.config_rings\t\t= qla24xx_config_rings,\n\t.reset_adapter\t\t= qla24xx_reset_adapter,\n\t.nvram_config\t\t= qla81xx_nvram_config,\n\t.update_fw_options\t= qla24xx_update_fw_options,\n\t.load_risc\t\t= qla81xx_load_risc,\n\t.pci_info_str\t\t= qla24xx_pci_info_str,\n\t.fw_version_str\t\t= qla24xx_fw_version_str,\n\t.intr_handler\t\t= qla24xx_intr_handler,\n\t.enable_intrs\t\t= qla24xx_enable_intrs,\n\t.disable_intrs\t\t= qla24xx_disable_intrs,\n\t.abort_command\t\t= qla24xx_abort_command,\n\t.target_reset\t\t= qla24xx_abort_target,\n\t.lun_reset\t\t= qla24xx_lun_reset,\n\t.fabric_login\t\t= qla24xx_login_fabric,\n\t.fabric_logout\t\t= qla24xx_fabric_logout,\n\t.calc_req_entries\t= NULL,\n\t.build_iocbs\t\t= NULL,\n\t.prep_ms_iocb\t\t= qla24xx_prep_ms_iocb,\n\t.prep_ms_fdmi_iocb\t= qla24xx_prep_ms_fdmi_iocb,\n\t.read_nvram\t\t= NULL,\n\t.write_nvram\t\t= NULL,\n\t.fw_dump\t\t= qla27xx_fwdump,\n\t.mpi_fw_dump\t\t= qla27xx_mpi_fwdump,\n\t.beacon_on\t\t= qla24xx_beacon_on,\n\t.beacon_off\t\t= qla24xx_beacon_off,\n\t.beacon_blink\t\t= qla83xx_beacon_blink,\n\t.read_optrom\t\t= qla25xx_read_optrom_data,\n\t.write_optrom\t\t= qla24xx_write_optrom_data,\n\t.get_flash_version\t= qla24xx_get_flash_version,\n\t.start_scsi\t\t= qla24xx_dif_start_scsi,\n\t.start_scsi_mq          = qla2xxx_dif_start_scsi_mq,\n\t.abort_isp\t\t= qla2x00_abort_isp,\n\t.iospace_config\t\t= qla83xx_iospace_config,\n\t.initialize_adapter\t= qla2x00_initialize_adapter,\n};\n\nstatic inline void\nqla2x00_set_isp_flags(struct qla_hw_data *ha)\n{\n\tha->device_type = DT_EXTENDED_IDS;\n\tswitch (ha->pdev->device) {\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2100:\n\t\tha->isp_type |= DT_ISP2100;\n\t\tha->device_type &= ~DT_EXTENDED_IDS;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2100;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2200:\n\t\tha->isp_type |= DT_ISP2200;\n\t\tha->device_type &= ~DT_EXTENDED_IDS;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2100;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2300:\n\t\tha->isp_type |= DT_ISP2300;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2300;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2312:\n\t\tha->isp_type |= DT_ISP2312;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2300;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2322:\n\t\tha->isp_type |= DT_ISP2322;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tif (ha->pdev->subsystem_vendor == 0x1028 &&\n\t\t    ha->pdev->subsystem_device == 0x0170)\n\t\t\tha->device_type |= DT_OEM_001;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2300;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP6312:\n\t\tha->isp_type |= DT_ISP6312;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2300;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP6322:\n\t\tha->isp_type |= DT_ISP6322;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2300;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2422:\n\t\tha->isp_type |= DT_ISP2422;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2432:\n\t\tha->isp_type |= DT_ISP2432;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP8432:\n\t\tha->isp_type |= DT_ISP8432;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP5422:\n\t\tha->isp_type |= DT_ISP5422;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP5432:\n\t\tha->isp_type |= DT_ISP5432;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2532:\n\t\tha->isp_type |= DT_ISP2532;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP8001:\n\t\tha->isp_type |= DT_ISP8001;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP8021:\n\t\tha->isp_type |= DT_ISP8021;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\t \n\t\tqla82xx_init_flags(ha);\n\t\tbreak;\n\t case PCI_DEVICE_ID_QLOGIC_ISP8044:\n\t\tha->isp_type |= DT_ISP8044;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\t \n\t\tqla82xx_init_flags(ha);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2031:\n\t\tha->isp_type |= DT_ISP2031;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->device_type |= DT_T10_PI;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP8031:\n\t\tha->isp_type |= DT_ISP8031;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->device_type |= DT_T10_PI;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISPF001:\n\t\tha->isp_type |= DT_ISPFX00;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2071:\n\t\tha->isp_type |= DT_ISP2071;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->device_type |= DT_T10_PI;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2271:\n\t\tha->isp_type |= DT_ISP2271;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->device_type |= DT_T10_PI;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2261:\n\t\tha->isp_type |= DT_ISP2261;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->device_type |= DT_T10_PI;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2081:\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2089:\n\t\tha->isp_type |= DT_ISP2081;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->device_type |= DT_T10_PI;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2281:\n\tcase PCI_DEVICE_ID_QLOGIC_ISP2289:\n\t\tha->isp_type |= DT_ISP2281;\n\t\tha->device_type |= DT_ZIO_SUPPORTED;\n\t\tha->device_type |= DT_FWI2;\n\t\tha->device_type |= DT_IIDMA;\n\t\tha->device_type |= DT_T10_PI;\n\t\tha->fw_srisc_address = RISC_START_ADDRESS_2400;\n\t\tbreak;\n\t}\n\n\tif (IS_QLA82XX(ha))\n\t\tha->port_no = ha->portnum & 1;\n\telse {\n\t\t \n\t\tpci_read_config_byte(ha->pdev, PCI_INTERRUPT_PIN, &ha->port_no);\n\t\tif (IS_QLA25XX(ha) || IS_QLA2031(ha) ||\n\t\t    IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\t\tha->port_no--;\n\t\telse\n\t\t\tha->port_no = !(ha->port_no & 1);\n\t}\n\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x000b,\n\t    \"device_type=0x%x port=%d fw_srisc_address=0x%x.\\n\",\n\t    ha->device_type, ha->port_no, ha->fw_srisc_address);\n}\n\nstatic void\nqla2xxx_scan_start(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\n\tif (vha->hw->flags.running_gold_fw)\n\t\treturn;\n\n\tset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\n\tset_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);\n\tset_bit(RSCN_UPDATE, &vha->dpc_flags);\n\tset_bit(NPIV_CONFIG_NEEDED, &vha->dpc_flags);\n}\n\nstatic int\nqla2xxx_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\tscsi_qla_host_t *vha = shost_priv(shost);\n\n\tif (test_bit(UNLOADING, &vha->dpc_flags))\n\t\treturn 1;\n\tif (!vha->host)\n\t\treturn 1;\n\tif (time > vha->hw->loop_reset_delay * HZ)\n\t\treturn 1;\n\n\treturn atomic_read(&vha->loop_state) == LOOP_READY;\n}\n\nstatic void qla_heartbeat_work_fn(struct work_struct *work)\n{\n\tstruct qla_hw_data *ha = container_of(work,\n\t\tstruct qla_hw_data, heartbeat_work);\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\n\tif (!ha->flags.mbox_busy && base_vha->flags.init_done)\n\t\tqla_no_op_mb(base_vha);\n}\n\nstatic void qla2x00_iocb_work_fn(struct work_struct *work)\n{\n\tstruct scsi_qla_host *vha = container_of(work,\n\t\tstruct scsi_qla_host, iocb_work);\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tint i = 2;\n\tunsigned long flags;\n\n\tif (test_bit(UNLOADING, &base_vha->dpc_flags))\n\t\treturn;\n\n\twhile (!list_empty(&vha->work_list) && i > 0) {\n\t\tqla2x00_do_work(vha);\n\t\ti--;\n\t}\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tclear_bit(IOCB_WORK_ACTIVE, &vha->dpc_flags);\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n}\n\nstatic void\nqla_trace_init(void)\n{\n\tqla_trc_array = trace_array_get_by_name(\"qla2xxx\");\n\tif (!qla_trc_array) {\n\t\tql_log(ql_log_fatal, NULL, 0x0001,\n\t\t       \"Unable to create qla2xxx trace instance, instance logging will be disabled.\\n\");\n\t\treturn;\n\t}\n\n\tQLA_TRACE_ENABLE(qla_trc_array);\n}\n\nstatic void\nqla_trace_uninit(void)\n{\n\tif (!qla_trc_array)\n\t\treturn;\n\ttrace_array_put(qla_trc_array);\n}\n\n \nstatic int\nqla2x00_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint\tret = -ENODEV;\n\tstruct Scsi_Host *host;\n\tscsi_qla_host_t *base_vha = NULL;\n\tstruct qla_hw_data *ha;\n\tchar pci_info[30];\n\tchar fw_str[30], wq_name[30];\n\tstruct scsi_host_template *sht;\n\tint bars, mem_only = 0;\n\tuint16_t req_length = 0, rsp_length = 0;\n\tstruct req_que *req = NULL;\n\tstruct rsp_que *rsp = NULL;\n\tint i;\n\n\tbars = pci_select_bars(pdev, IORESOURCE_MEM | IORESOURCE_IO);\n\tsht = &qla2xxx_driver_template;\n\tif (pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2422 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2432 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8432 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP5422 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP5432 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2532 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8001 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8021 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2031 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8031 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISPF001 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8044 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2071 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2271 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2261 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2081 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2281 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2089 ||\n\t    pdev->device == PCI_DEVICE_ID_QLOGIC_ISP2289) {\n\t\tbars = pci_select_bars(pdev, IORESOURCE_MEM);\n\t\tmem_only = 1;\n\t\tql_dbg_pci(ql_dbg_init, pdev, 0x0007,\n\t\t    \"Mem only adapter.\\n\");\n\t}\n\tql_dbg_pci(ql_dbg_init, pdev, 0x0008,\n\t    \"Bars=%d.\\n\", bars);\n\n\tif (mem_only) {\n\t\tif (pci_enable_device_mem(pdev))\n\t\t\treturn ret;\n\t} else {\n\t\tif (pci_enable_device(pdev))\n\t\t\treturn ret;\n\t}\n\n\tif (is_kdump_kernel()) {\n\t\tql2xmqsupport = 0;\n\t\tql2xallocfwdump = 0;\n\t}\n\n\tha = kzalloc(sizeof(struct qla_hw_data), GFP_KERNEL);\n\tif (!ha) {\n\t\tql_log_pci(ql_log_fatal, pdev, 0x0009,\n\t\t    \"Unable to allocate memory for ha.\\n\");\n\t\tgoto disable_device;\n\t}\n\tql_dbg_pci(ql_dbg_init, pdev, 0x000a,\n\t    \"Memory allocated for ha=%p.\\n\", ha);\n\tha->pdev = pdev;\n\tINIT_LIST_HEAD(&ha->tgt.q_full_list);\n\tspin_lock_init(&ha->tgt.q_full_lock);\n\tspin_lock_init(&ha->tgt.sess_lock);\n\tspin_lock_init(&ha->tgt.atio_lock);\n\n\tspin_lock_init(&ha->sadb_lock);\n\tINIT_LIST_HEAD(&ha->sadb_tx_index_list);\n\tINIT_LIST_HEAD(&ha->sadb_rx_index_list);\n\n\tspin_lock_init(&ha->sadb_fp_lock);\n\n\tif (qla_edif_sadb_build_free_pool(ha)) {\n\t\tkfree(ha);\n\t\tgoto  disable_device;\n\t}\n\n\tatomic_set(&ha->nvme_active_aen_cnt, 0);\n\n\t \n\tha->bars = bars;\n\tha->mem_only = mem_only;\n\tspin_lock_init(&ha->hardware_lock);\n\tspin_lock_init(&ha->vport_slock);\n\tmutex_init(&ha->selflogin_lock);\n\tmutex_init(&ha->optrom_mutex);\n\n\t \n\tqla2x00_set_isp_flags(ha);\n\n\t \n\tif (IS_QLA24XX(ha) || IS_QLA25XX(ha) || IS_QLA81XX(ha) ||\n\t    IS_QLA83XX(ha) || IS_QLA27XX(ha) || IS_QLA28XX(ha))\n\t\tpdev->needs_freset = 1;\n\n\tha->prev_topology = 0;\n\tha->init_cb_size = sizeof(init_cb_t);\n\tha->link_data_rate = PORT_SPEED_UNKNOWN;\n\tha->optrom_size = OPTROM_SIZE_2300;\n\tha->max_exchg = FW_MAX_EXCHANGES_CNT;\n\tatomic_set(&ha->num_pend_mbx_stage1, 0);\n\tatomic_set(&ha->num_pend_mbx_stage2, 0);\n\tatomic_set(&ha->zio_threshold, DEFAULT_ZIO_THRESHOLD);\n\tha->last_zio_threshold = DEFAULT_ZIO_THRESHOLD;\n\tINIT_LIST_HEAD(&ha->tmf_pending);\n\tINIT_LIST_HEAD(&ha->tmf_active);\n\n\t \n\tif (IS_QLA2100(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2100;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT_2100;\n\t\treq_length = REQUEST_ENTRY_CNT_2100;\n\t\trsp_length = RESPONSE_ENTRY_CNT_2100;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2100;\n\t\tha->gid_list_info_size = 4;\n\t\tha->flash_conf_off = ~0;\n\t\tha->flash_data_off = ~0;\n\t\tha->nvram_conf_off = ~0;\n\t\tha->nvram_data_off = ~0;\n\t\tha->isp_ops = &qla2100_isp_ops;\n\t} else if (IS_QLA2200(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2100;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT_2200;\n\t\treq_length = REQUEST_ENTRY_CNT_2200;\n\t\trsp_length = RESPONSE_ENTRY_CNT_2100;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2100;\n\t\tha->gid_list_info_size = 4;\n\t\tha->flash_conf_off = ~0;\n\t\tha->flash_data_off = ~0;\n\t\tha->nvram_conf_off = ~0;\n\t\tha->nvram_data_off = ~0;\n\t\tha->isp_ops = &qla2100_isp_ops;\n\t} else if (IS_QLA23XX(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2100;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_2200;\n\t\trsp_length = RESPONSE_ENTRY_CNT_2300;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->gid_list_info_size = 6;\n\t\tif (IS_QLA2322(ha) || IS_QLA6322(ha))\n\t\t\tha->optrom_size = OPTROM_SIZE_2322;\n\t\tha->flash_conf_off = ~0;\n\t\tha->flash_data_off = ~0;\n\t\tha->nvram_conf_off = ~0;\n\t\tha->nvram_data_off = ~0;\n\t\tha->isp_ops = &qla2300_isp_ops;\n\t} else if (IS_QLA24XX_TYPE(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2400;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_24XX;\n\t\trsp_length = RESPONSE_ENTRY_CNT_2300;\n\t\tha->tgt.atio_q_length = ATIO_ENTRY_CNT_24XX;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->init_cb_size = sizeof(struct mid_init_cb_24xx);\n\t\tha->gid_list_info_size = 8;\n\t\tha->optrom_size = OPTROM_SIZE_24XX;\n\t\tha->nvram_npiv_size = QLA_MAX_VPORTS_QLA24XX;\n\t\tha->isp_ops = &qla24xx_isp_ops;\n\t\tha->flash_conf_off = FARX_ACCESS_FLASH_CONF;\n\t\tha->flash_data_off = FARX_ACCESS_FLASH_DATA;\n\t\tha->nvram_conf_off = FARX_ACCESS_NVRAM_CONF;\n\t\tha->nvram_data_off = FARX_ACCESS_NVRAM_DATA;\n\t} else if (IS_QLA25XX(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2400;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_24XX;\n\t\trsp_length = RESPONSE_ENTRY_CNT_2300;\n\t\tha->tgt.atio_q_length = ATIO_ENTRY_CNT_24XX;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->init_cb_size = sizeof(struct mid_init_cb_24xx);\n\t\tha->gid_list_info_size = 8;\n\t\tha->optrom_size = OPTROM_SIZE_25XX;\n\t\tha->nvram_npiv_size = QLA_MAX_VPORTS_QLA25XX;\n\t\tha->isp_ops = &qla25xx_isp_ops;\n\t\tha->flash_conf_off = FARX_ACCESS_FLASH_CONF;\n\t\tha->flash_data_off = FARX_ACCESS_FLASH_DATA;\n\t\tha->nvram_conf_off = FARX_ACCESS_NVRAM_CONF;\n\t\tha->nvram_data_off = FARX_ACCESS_NVRAM_DATA;\n\t} else if (IS_QLA81XX(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2400;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_24XX;\n\t\trsp_length = RESPONSE_ENTRY_CNT_2300;\n\t\tha->tgt.atio_q_length = ATIO_ENTRY_CNT_24XX;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->init_cb_size = sizeof(struct mid_init_cb_81xx);\n\t\tha->gid_list_info_size = 8;\n\t\tha->optrom_size = OPTROM_SIZE_81XX;\n\t\tha->nvram_npiv_size = QLA_MAX_VPORTS_QLA25XX;\n\t\tha->isp_ops = &qla81xx_isp_ops;\n\t\tha->flash_conf_off = FARX_ACCESS_FLASH_CONF_81XX;\n\t\tha->flash_data_off = FARX_ACCESS_FLASH_DATA_81XX;\n\t\tha->nvram_conf_off = ~0;\n\t\tha->nvram_data_off = ~0;\n\t} else if (IS_QLA82XX(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2400;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_82XX;\n\t\trsp_length = RESPONSE_ENTRY_CNT_82XX;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->init_cb_size = sizeof(struct mid_init_cb_81xx);\n\t\tha->gid_list_info_size = 8;\n\t\tha->optrom_size = OPTROM_SIZE_82XX;\n\t\tha->nvram_npiv_size = QLA_MAX_VPORTS_QLA25XX;\n\t\tha->isp_ops = &qla82xx_isp_ops;\n\t\tha->flash_conf_off = FARX_ACCESS_FLASH_CONF;\n\t\tha->flash_data_off = FARX_ACCESS_FLASH_DATA;\n\t\tha->nvram_conf_off = FARX_ACCESS_NVRAM_CONF;\n\t\tha->nvram_data_off = FARX_ACCESS_NVRAM_DATA;\n\t} else if (IS_QLA8044(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2400;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_82XX;\n\t\trsp_length = RESPONSE_ENTRY_CNT_82XX;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->init_cb_size = sizeof(struct mid_init_cb_81xx);\n\t\tha->gid_list_info_size = 8;\n\t\tha->optrom_size = OPTROM_SIZE_83XX;\n\t\tha->nvram_npiv_size = QLA_MAX_VPORTS_QLA25XX;\n\t\tha->isp_ops = &qla8044_isp_ops;\n\t\tha->flash_conf_off = FARX_ACCESS_FLASH_CONF;\n\t\tha->flash_data_off = FARX_ACCESS_FLASH_DATA;\n\t\tha->nvram_conf_off = FARX_ACCESS_NVRAM_CONF;\n\t\tha->nvram_data_off = FARX_ACCESS_NVRAM_DATA;\n\t} else if (IS_QLA83XX(ha)) {\n\t\tha->portnum = PCI_FUNC(ha->pdev->devfn);\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2400;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_83XX;\n\t\trsp_length = RESPONSE_ENTRY_CNT_83XX;\n\t\tha->tgt.atio_q_length = ATIO_ENTRY_CNT_24XX;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->init_cb_size = sizeof(struct mid_init_cb_81xx);\n\t\tha->gid_list_info_size = 8;\n\t\tha->optrom_size = OPTROM_SIZE_83XX;\n\t\tha->nvram_npiv_size = QLA_MAX_VPORTS_QLA25XX;\n\t\tha->isp_ops = &qla83xx_isp_ops;\n\t\tha->flash_conf_off = FARX_ACCESS_FLASH_CONF_81XX;\n\t\tha->flash_data_off = FARX_ACCESS_FLASH_DATA_81XX;\n\t\tha->nvram_conf_off = ~0;\n\t\tha->nvram_data_off = ~0;\n\t}  else if (IS_QLAFX00(ha)) {\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_FX00;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT_FX00;\n\t\tha->aen_mbx_count = AEN_MAILBOX_REGISTER_COUNT_FX00;\n\t\treq_length = REQUEST_ENTRY_CNT_FX00;\n\t\trsp_length = RESPONSE_ENTRY_CNT_FX00;\n\t\tha->isp_ops = &qlafx00_isp_ops;\n\t\tha->port_down_retry_count = 30;  \n\t\tha->mr.fw_hbt_cnt = QLAFX00_HEARTBEAT_INTERVAL;\n\t\tha->mr.fw_reset_timer_tick = QLAFX00_RESET_INTERVAL;\n\t\tha->mr.fw_critemp_timer_tick = QLAFX00_CRITEMP_INTERVAL;\n\t\tha->mr.fw_hbt_en = 1;\n\t\tha->mr.host_info_resend = false;\n\t\tha->mr.hinfo_resend_timer_tick = QLAFX00_HINFO_RESEND_INTERVAL;\n\t} else if (IS_QLA27XX(ha)) {\n\t\tha->portnum = PCI_FUNC(ha->pdev->devfn);\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2400;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_83XX;\n\t\trsp_length = RESPONSE_ENTRY_CNT_83XX;\n\t\tha->tgt.atio_q_length = ATIO_ENTRY_CNT_24XX;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->init_cb_size = sizeof(struct mid_init_cb_81xx);\n\t\tha->gid_list_info_size = 8;\n\t\tha->optrom_size = OPTROM_SIZE_83XX;\n\t\tha->nvram_npiv_size = QLA_MAX_VPORTS_QLA25XX;\n\t\tha->isp_ops = &qla27xx_isp_ops;\n\t\tha->flash_conf_off = FARX_ACCESS_FLASH_CONF_81XX;\n\t\tha->flash_data_off = FARX_ACCESS_FLASH_DATA_81XX;\n\t\tha->nvram_conf_off = ~0;\n\t\tha->nvram_data_off = ~0;\n\t} else if (IS_QLA28XX(ha)) {\n\t\tha->portnum = PCI_FUNC(ha->pdev->devfn);\n\t\tha->max_fibre_devices = MAX_FIBRE_DEVICES_2400;\n\t\tha->mbx_count = MAILBOX_REGISTER_COUNT;\n\t\treq_length = REQUEST_ENTRY_CNT_83XX;\n\t\trsp_length = RESPONSE_ENTRY_CNT_83XX;\n\t\tha->tgt.atio_q_length = ATIO_ENTRY_CNT_24XX;\n\t\tha->max_loop_id = SNS_LAST_LOOP_ID_2300;\n\t\tha->init_cb_size = sizeof(struct mid_init_cb_81xx);\n\t\tha->gid_list_info_size = 8;\n\t\tha->optrom_size = OPTROM_SIZE_28XX;\n\t\tha->nvram_npiv_size = QLA_MAX_VPORTS_QLA25XX;\n\t\tha->isp_ops = &qla27xx_isp_ops;\n\t\tha->flash_conf_off = FARX_ACCESS_FLASH_CONF_28XX;\n\t\tha->flash_data_off = FARX_ACCESS_FLASH_DATA_28XX;\n\t\tha->nvram_conf_off = ~0;\n\t\tha->nvram_data_off = ~0;\n\t}\n\n\tql_dbg_pci(ql_dbg_init, pdev, 0x001e,\n\t    \"mbx_count=%d, req_length=%d, \"\n\t    \"rsp_length=%d, max_loop_id=%d, init_cb_size=%d, \"\n\t    \"gid_list_info_size=%d, optrom_size=%d, nvram_npiv_size=%d, \"\n\t    \"max_fibre_devices=%d.\\n\",\n\t    ha->mbx_count, req_length, rsp_length, ha->max_loop_id,\n\t    ha->init_cb_size, ha->gid_list_info_size, ha->optrom_size,\n\t    ha->nvram_npiv_size, ha->max_fibre_devices);\n\tql_dbg_pci(ql_dbg_init, pdev, 0x001f,\n\t    \"isp_ops=%p, flash_conf_off=%d, \"\n\t    \"flash_data_off=%d, nvram_conf_off=%d, nvram_data_off=%d.\\n\",\n\t    ha->isp_ops, ha->flash_conf_off, ha->flash_data_off,\n\t    ha->nvram_conf_off, ha->nvram_data_off);\n\n\t \n\tret = ha->isp_ops->iospace_config(ha);\n\tif (ret)\n\t\tgoto iospace_config_failed;\n\n\tql_log_pci(ql_log_info, pdev, 0x001d,\n\t    \"Found an ISP%04X irq %d iobase 0x%p.\\n\",\n\t    pdev->device, pdev->irq, ha->iobase);\n\tmutex_init(&ha->vport_lock);\n\tmutex_init(&ha->mq_lock);\n\tinit_completion(&ha->mbx_cmd_comp);\n\tcomplete(&ha->mbx_cmd_comp);\n\tinit_completion(&ha->mbx_intr_comp);\n\tinit_completion(&ha->dcbx_comp);\n\tinit_completion(&ha->lb_portup_comp);\n\n\tset_bit(0, (unsigned long *) ha->vp_idx_map);\n\n\tqla2x00_config_dma_addressing(ha);\n\tql_dbg_pci(ql_dbg_init, pdev, 0x0020,\n\t    \"64 Bit addressing is %s.\\n\",\n\t    ha->flags.enable_64bit_addressing ? \"enable\" :\n\t    \"disable\");\n\tret = qla2x00_mem_alloc(ha, req_length, rsp_length, &req, &rsp);\n\tif (ret) {\n\t\tql_log_pci(ql_log_fatal, pdev, 0x0031,\n\t\t    \"Failed to allocate memory for adapter, aborting.\\n\");\n\n\t\tgoto probe_hw_failed;\n\t}\n\n\treq->max_q_depth = MAX_Q_DEPTH;\n\tif (ql2xmaxqdepth != 0 && ql2xmaxqdepth <= 0xffffU)\n\t\treq->max_q_depth = ql2xmaxqdepth;\n\n\n\tbase_vha = qla2x00_create_host(sht, ha);\n\tif (!base_vha) {\n\t\tret = -ENOMEM;\n\t\tgoto probe_hw_failed;\n\t}\n\n\tpci_set_drvdata(pdev, base_vha);\n\tset_bit(PFLG_DRIVER_PROBING, &base_vha->pci_flags);\n\n\thost = base_vha->host;\n\tbase_vha->req = req;\n\tif (IS_QLA2XXX_MIDTYPE(ha))\n\t\tbase_vha->mgmt_svr_loop_id =\n\t\t\tqla2x00_reserve_mgmt_server_loop_id(base_vha);\n\telse\n\t\tbase_vha->mgmt_svr_loop_id = MANAGEMENT_SERVER +\n\t\t\t\t\t\tbase_vha->vp_idx;\n\n\t \n\tha->mr.fcport.vha = base_vha;\n\tha->mr.fcport.port_type = FCT_UNKNOWN;\n\tha->mr.fcport.loop_id = FC_NO_LOOP_ID;\n\tqla2x00_set_fcport_state(&ha->mr.fcport, FCS_UNCONFIGURED);\n\tha->mr.fcport.supported_classes = FC_COS_UNSPECIFIED;\n\tha->mr.fcport.scan_state = 1;\n\n\tqla2xxx_reset_stats(host, QLA2XX_HW_ERROR | QLA2XX_SHT_LNK_DWN |\n\t\t\t    QLA2XX_INT_ERR | QLA2XX_CMD_TIMEOUT |\n\t\t\t    QLA2XX_RESET_CMD_ERR | QLA2XX_TGT_SHT_LNK_DOWN);\n\n\t \n\tif (!IS_FWI2_CAPABLE(ha)) {\n\t\tif (IS_QLA2100(ha))\n\t\t\thost->sg_tablesize = 32;\n\t} else {\n\t\tif (!IS_QLA82XX(ha))\n\t\t\thost->sg_tablesize = QLA_SG_ALL;\n\t}\n\thost->max_id = ha->max_fibre_devices;\n\thost->cmd_per_lun = 3;\n\thost->unique_id = host->host_no;\n\n\tif (ql2xenabledif && ql2xenabledif != 2) {\n\t\tql_log(ql_log_warn, base_vha, 0x302d,\n\t\t       \"Invalid value for ql2xenabledif, resetting it to default (2)\\n\");\n\t\tql2xenabledif = 2;\n\t}\n\n\tif (IS_T10_PI_CAPABLE(ha) && ql2xenabledif)\n\t\thost->max_cmd_len = 32;\n\telse\n\t\thost->max_cmd_len = MAX_CMDSZ;\n\thost->max_channel = MAX_BUSES - 1;\n\t \n\tif (!IS_QLAFX00(ha) && !IS_FWI2_CAPABLE(ha) &&\n\t    ql2xmaxlun > 0xffff)\n\t\thost->max_lun = 0xffff;\n\telse\n\t\thost->max_lun = ql2xmaxlun;\n\thost->transportt = qla2xxx_transport_template;\n\tsht->vendor_id = (SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_QLOGIC);\n\n\tql_dbg(ql_dbg_init, base_vha, 0x0033,\n\t    \"max_id=%d this_id=%d \"\n\t    \"cmd_per_len=%d unique_id=%d max_cmd_len=%d max_channel=%d \"\n\t    \"max_lun=%llu transportt=%p, vendor_id=%llu.\\n\", host->max_id,\n\t    host->this_id, host->cmd_per_lun, host->unique_id,\n\t    host->max_cmd_len, host->max_channel, host->max_lun,\n\t    host->transportt, sht->vendor_id);\n\n\tINIT_WORK(&ha->heartbeat_work, qla_heartbeat_work_fn);\n\n\t \n\tret = qla2x00_request_irqs(ha, rsp);\n\tif (ret)\n\t\tgoto probe_failed;\n\n\t \n\tret = qla2x00_alloc_queues(ha, req, rsp);\n\tif (ret) {\n\t\tql_log(ql_log_fatal, base_vha, 0x003d,\n\t\t    \"Failed to allocate memory for queue pointers...\"\n\t\t    \"aborting.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto probe_failed;\n\t}\n\n\tif (ha->mqenable) {\n\t\t \n\t\thost->nr_hw_queues = ha->max_qpairs;\n\n\t\tql_dbg(ql_dbg_init, base_vha, 0x0192,\n\t\t\t\"blk/scsi-mq enabled, HW queues = %d.\\n\", host->nr_hw_queues);\n\t} else {\n\t\tif (ql2xnvmeenable) {\n\t\t\thost->nr_hw_queues = ha->max_qpairs;\n\t\t\tql_dbg(ql_dbg_init, base_vha, 0x0194,\n\t\t\t    \"FC-NVMe support is enabled, HW queues=%d\\n\",\n\t\t\t    host->nr_hw_queues);\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_init, base_vha, 0x0193,\n\t\t\t    \"blk/scsi-mq disabled.\\n\");\n\t\t}\n\t}\n\n\tqlt_probe_one_stage1(base_vha, ha);\n\n\tpci_save_state(pdev);\n\n\t \n\trsp->req = req;\n\treq->rsp = rsp;\n\n\tif (IS_QLAFX00(ha)) {\n\t\tha->rsp_q_map[0] = rsp;\n\t\tha->req_q_map[0] = req;\n\t\tset_bit(0, ha->req_qid_map);\n\t\tset_bit(0, ha->rsp_qid_map);\n\t}\n\n\t \n\treq->req_q_in = &ha->iobase->isp24.req_q_in;\n\treq->req_q_out = &ha->iobase->isp24.req_q_out;\n\trsp->rsp_q_in = &ha->iobase->isp24.rsp_q_in;\n\trsp->rsp_q_out = &ha->iobase->isp24.rsp_q_out;\n\tif (ha->mqenable || IS_QLA83XX(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\treq->req_q_in = &ha->mqiobase->isp25mq.req_q_in;\n\t\treq->req_q_out = &ha->mqiobase->isp25mq.req_q_out;\n\t\trsp->rsp_q_in = &ha->mqiobase->isp25mq.rsp_q_in;\n\t\trsp->rsp_q_out =  &ha->mqiobase->isp25mq.rsp_q_out;\n\t}\n\n\tif (IS_QLAFX00(ha)) {\n\t\treq->req_q_in = &ha->iobase->ispfx00.req_q_in;\n\t\treq->req_q_out = &ha->iobase->ispfx00.req_q_out;\n\t\trsp->rsp_q_in = &ha->iobase->ispfx00.rsp_q_in;\n\t\trsp->rsp_q_out = &ha->iobase->ispfx00.rsp_q_out;\n\t}\n\n\tif (IS_P3P_TYPE(ha)) {\n\t\treq->req_q_out = &ha->iobase->isp82.req_q_out[0];\n\t\trsp->rsp_q_in = &ha->iobase->isp82.rsp_q_in[0];\n\t\trsp->rsp_q_out = &ha->iobase->isp82.rsp_q_out[0];\n\t}\n\n\tql_dbg(ql_dbg_multiq, base_vha, 0xc009,\n\t    \"rsp_q_map=%p req_q_map=%p rsp->req=%p req->rsp=%p.\\n\",\n\t    ha->rsp_q_map, ha->req_q_map, rsp->req, req->rsp);\n\tql_dbg(ql_dbg_multiq, base_vha, 0xc00a,\n\t    \"req->req_q_in=%p req->req_q_out=%p \"\n\t    \"rsp->rsp_q_in=%p rsp->rsp_q_out=%p.\\n\",\n\t    req->req_q_in, req->req_q_out,\n\t    rsp->rsp_q_in, rsp->rsp_q_out);\n\tql_dbg(ql_dbg_init, base_vha, 0x003e,\n\t    \"rsp_q_map=%p req_q_map=%p rsp->req=%p req->rsp=%p.\\n\",\n\t    ha->rsp_q_map, ha->req_q_map, rsp->req, req->rsp);\n\tql_dbg(ql_dbg_init, base_vha, 0x003f,\n\t    \"req->req_q_in=%p req->req_q_out=%p rsp->rsp_q_in=%p rsp->rsp_q_out=%p.\\n\",\n\t    req->req_q_in, req->req_q_out, rsp->rsp_q_in, rsp->rsp_q_out);\n\n\tha->wq = alloc_workqueue(\"qla2xxx_wq\", WQ_MEM_RECLAIM, 0);\n\tif (unlikely(!ha->wq)) {\n\t\tret = -ENOMEM;\n\t\tgoto probe_failed;\n\t}\n\n\tif (ha->isp_ops->initialize_adapter(base_vha)) {\n\t\tql_log(ql_log_fatal, base_vha, 0x00d6,\n\t\t    \"Failed to initialize adapter - Adapter flags %x.\\n\",\n\t\t    base_vha->device_flags);\n\n\t\tif (IS_QLA82XX(ha)) {\n\t\t\tqla82xx_idc_lock(ha);\n\t\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\n\t\t\t\tQLA8XXX_DEV_FAILED);\n\t\t\tqla82xx_idc_unlock(ha);\n\t\t\tql_log(ql_log_fatal, base_vha, 0x00d7,\n\t\t\t    \"HW State: FAILED.\\n\");\n\t\t} else if (IS_QLA8044(ha)) {\n\t\t\tqla8044_idc_lock(ha);\n\t\t\tqla8044_wr_direct(base_vha,\n\t\t\t\tQLA8044_CRB_DEV_STATE_INDEX,\n\t\t\t\tQLA8XXX_DEV_FAILED);\n\t\t\tqla8044_idc_unlock(ha);\n\t\t\tql_log(ql_log_fatal, base_vha, 0x0150,\n\t\t\t    \"HW State: FAILED.\\n\");\n\t\t}\n\n\t\tret = -ENODEV;\n\t\tgoto probe_failed;\n\t}\n\n\tif (IS_QLAFX00(ha))\n\t\thost->can_queue = QLAFX00_MAX_CANQUEUE;\n\telse\n\t\thost->can_queue = req->num_outstanding_cmds - 10;\n\n\tql_dbg(ql_dbg_init, base_vha, 0x0032,\n\t    \"can_queue=%d, req=%p, mgmt_svr_loop_id=%d, sg_tablesize=%d.\\n\",\n\t    host->can_queue, base_vha->req,\n\t    base_vha->mgmt_svr_loop_id, host->sg_tablesize);\n\n\t \n\tif (IS_QLA25XX(ha) && !(ha->fw_attributes & BIT_6))\n\t\tha->mqenable = 0;\n\n\tif (ha->mqenable) {\n\t\tbool startit = false;\n\n\t\tif (QLA_TGT_MODE_ENABLED())\n\t\t\tstartit = false;\n\n\t\tif (ql2x_ini_mode == QLA2XXX_INI_MODE_ENABLED)\n\t\t\tstartit = true;\n\n\t\t \n\t\tfor (i = 0; i < ha->max_qpairs; i++)\n\t\t\tqla2xxx_create_qpair(base_vha, 5, 0, startit);\n\t}\n\tqla_init_iocb_limit(base_vha);\n\n\tif (ha->flags.running_gold_fw)\n\t\tgoto skip_dpc;\n\n\t \n\tha->dpc_thread = kthread_create(qla2x00_do_dpc, ha,\n\t    \"%s_dpc\", base_vha->host_str);\n\tif (IS_ERR(ha->dpc_thread)) {\n\t\tql_log(ql_log_fatal, base_vha, 0x00ed,\n\t\t    \"Failed to start DPC thread.\\n\");\n\t\tret = PTR_ERR(ha->dpc_thread);\n\t\tha->dpc_thread = NULL;\n\t\tgoto probe_failed;\n\t}\n\tql_dbg(ql_dbg_init, base_vha, 0x00ee,\n\t    \"DPC thread started successfully.\\n\");\n\n\t \n\tqla2xxx_wake_dpc(base_vha);\n\n\tINIT_WORK(&ha->board_disable, qla2x00_disable_board_on_pci_error);\n\n\tif (IS_QLA8031(ha) || IS_MCTP_CAPABLE(ha)) {\n\t\tsprintf(wq_name, \"qla2xxx_%lu_dpc_lp_wq\", base_vha->host_no);\n\t\tha->dpc_lp_wq = create_singlethread_workqueue(wq_name);\n\t\tINIT_WORK(&ha->idc_aen, qla83xx_service_idc_aen);\n\n\t\tsprintf(wq_name, \"qla2xxx_%lu_dpc_hp_wq\", base_vha->host_no);\n\t\tha->dpc_hp_wq = create_singlethread_workqueue(wq_name);\n\t\tINIT_WORK(&ha->nic_core_reset, qla83xx_nic_core_reset_work);\n\t\tINIT_WORK(&ha->idc_state_handler,\n\t\t    qla83xx_idc_state_handler_work);\n\t\tINIT_WORK(&ha->nic_core_unrecoverable,\n\t\t    qla83xx_nic_core_unrecoverable_work);\n\t}\n\nskip_dpc:\n\tlist_add_tail(&base_vha->list, &ha->vp_list);\n\tbase_vha->host->irq = ha->pdev->irq;\n\n\t \n\tqla2x00_start_timer(base_vha, WATCH_INTERVAL);\n\tql_dbg(ql_dbg_init, base_vha, 0x00ef,\n\t    \"Started qla2x00_timer with \"\n\t    \"interval=%d.\\n\", WATCH_INTERVAL);\n\tql_dbg(ql_dbg_init, base_vha, 0x00f0,\n\t    \"Detected hba at address=%p.\\n\",\n\t    ha);\n\n\tif (IS_T10_PI_CAPABLE(ha) && ql2xenabledif) {\n\t\tif (ha->fw_attributes & BIT_4) {\n\t\t\tint prot = 0, guard;\n\n\t\t\tbase_vha->flags.difdix_supported = 1;\n\t\t\tql_dbg(ql_dbg_init, base_vha, 0x00f1,\n\t\t\t    \"Registering for DIF/DIX type 1 and 3 protection.\\n\");\n\t\t\tif (ql2xprotmask)\n\t\t\t\tscsi_host_set_prot(host, ql2xprotmask);\n\t\t\telse\n\t\t\t\tscsi_host_set_prot(host,\n\t\t\t\t    prot | SHOST_DIF_TYPE1_PROTECTION\n\t\t\t\t    | SHOST_DIF_TYPE2_PROTECTION\n\t\t\t\t    | SHOST_DIF_TYPE3_PROTECTION\n\t\t\t\t    | SHOST_DIX_TYPE1_PROTECTION\n\t\t\t\t    | SHOST_DIX_TYPE2_PROTECTION\n\t\t\t\t    | SHOST_DIX_TYPE3_PROTECTION);\n\n\t\t\tguard = SHOST_DIX_GUARD_CRC;\n\n\t\t\tif (IS_PI_IPGUARD_CAPABLE(ha) &&\n\t\t\t    (ql2xenabledif > 1 || IS_PI_DIFB_DIX0_CAPABLE(ha)))\n\t\t\t\tguard |= SHOST_DIX_GUARD_IP;\n\n\t\t\tif (ql2xprotguard)\n\t\t\t\tscsi_host_set_guard(host, ql2xprotguard);\n\t\t\telse\n\t\t\t\tscsi_host_set_guard(host, guard);\n\t\t} else\n\t\t\tbase_vha->flags.difdix_supported = 0;\n\t}\n\n\tha->isp_ops->enable_intrs(ha);\n\n\tif (IS_QLAFX00(ha)) {\n\t\tret = qlafx00_fx_disc(base_vha,\n\t\t\t&base_vha->hw->mr.fcport, FXDISC_GET_CONFIG_INFO);\n\t\thost->sg_tablesize = (ha->mr.extended_io_enabled) ?\n\t\t    QLA_SG_ALL : 128;\n\t}\n\n\tret = scsi_add_host(host, &pdev->dev);\n\tif (ret)\n\t\tgoto probe_failed;\n\n\tbase_vha->flags.init_done = 1;\n\tbase_vha->flags.online = 1;\n\tha->prev_minidump_failed = 0;\n\n\tql_dbg(ql_dbg_init, base_vha, 0x00f2,\n\t    \"Init done and hba is online.\\n\");\n\n\tif (qla_ini_mode_enabled(base_vha) ||\n\t\tqla_dual_mode_enabled(base_vha))\n\t\tscsi_scan_host(host);\n\telse\n\t\tql_log(ql_log_info, base_vha, 0x0122,\n\t\t\t\"skipping scsi_scan_host() for non-initiator port\\n\");\n\n\tqla2x00_alloc_sysfs_attr(base_vha);\n\n\tif (IS_QLAFX00(ha)) {\n\t\tret = qlafx00_fx_disc(base_vha,\n\t\t\t&base_vha->hw->mr.fcport, FXDISC_GET_PORT_INFO);\n\n\t\t \n\t\tret =  qlafx00_fx_disc(base_vha,\n\t\t\t&base_vha->hw->mr.fcport, FXDISC_REG_HOST_INFO);\n\t}\n\n\tqla2x00_init_host_attr(base_vha);\n\n\tqla2x00_dfs_setup(base_vha);\n\n\tql_log(ql_log_info, base_vha, 0x00fb,\n\t    \"QLogic %s - %s.\\n\", ha->model_number, ha->model_desc);\n\tql_log(ql_log_info, base_vha, 0x00fc,\n\t    \"ISP%04X: %s @ %s hdma%c host#=%ld fw=%s.\\n\",\n\t    pdev->device, ha->isp_ops->pci_info_str(base_vha, pci_info,\n\t\t\t\t\t\t       sizeof(pci_info)),\n\t    pci_name(pdev), ha->flags.enable_64bit_addressing ? '+' : '-',\n\t    base_vha->host_no,\n\t    ha->isp_ops->fw_version_str(base_vha, fw_str, sizeof(fw_str)));\n\n\tqlt_add_target(ha, base_vha);\n\n\tclear_bit(PFLG_DRIVER_PROBING, &base_vha->pci_flags);\n\n\tif (test_bit(UNLOADING, &base_vha->dpc_flags))\n\t\treturn -ENODEV;\n\n\treturn 0;\n\nprobe_failed:\n\tqla_enode_stop(base_vha);\n\tqla_edb_stop(base_vha);\n\tvfree(base_vha->scan.l);\n\tif (base_vha->gnl.l) {\n\t\tdma_free_coherent(&ha->pdev->dev, base_vha->gnl.size,\n\t\t\t\tbase_vha->gnl.l, base_vha->gnl.ldma);\n\t\tbase_vha->gnl.l = NULL;\n\t}\n\n\tif (base_vha->timer_active)\n\t\tqla2x00_stop_timer(base_vha);\n\tbase_vha->flags.online = 0;\n\tif (ha->dpc_thread) {\n\t\tstruct task_struct *t = ha->dpc_thread;\n\n\t\tha->dpc_thread = NULL;\n\t\tkthread_stop(t);\n\t}\n\n\tqla2x00_free_device(base_vha);\n\tscsi_host_put(base_vha->host);\n\t \n\treq = NULL;\n\trsp = NULL;\n\nprobe_hw_failed:\n\tqla2x00_mem_free(ha);\n\tqla2x00_free_req_que(ha, req);\n\tqla2x00_free_rsp_que(ha, rsp);\n\tqla2x00_clear_drv_active(ha);\n\niospace_config_failed:\n\tif (IS_P3P_TYPE(ha)) {\n\t\tif (!ha->nx_pcibase)\n\t\t\tiounmap((device_reg_t *)ha->nx_pcibase);\n\t\tif (!ql2xdbwr)\n\t\t\tiounmap((device_reg_t *)ha->nxdb_wr_ptr);\n\t} else {\n\t\tif (ha->iobase)\n\t\t\tiounmap(ha->iobase);\n\t\tif (ha->cregbase)\n\t\t\tiounmap(ha->cregbase);\n\t}\n\tpci_release_selected_regions(ha->pdev, ha->bars);\n\tkfree(ha);\n\ndisable_device:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void __qla_set_remove_flag(scsi_qla_host_t *base_vha)\n{\n\tscsi_qla_host_t *vp;\n\tunsigned long flags;\n\tstruct qla_hw_data *ha;\n\n\tif (!base_vha)\n\t\treturn;\n\n\tha = base_vha->hw;\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tlist_for_each_entry(vp, &ha->vp_list, list)\n\t\tset_bit(PFLG_DRIVER_REMOVING, &vp->pci_flags);\n\n\t \n\tset_bit(PFLG_DRIVER_REMOVING, &base_vha->pci_flags);\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n}\n\nstatic void\nqla2x00_shutdown(struct pci_dev *pdev)\n{\n\tscsi_qla_host_t *vha;\n\tstruct qla_hw_data  *ha;\n\n\tvha = pci_get_drvdata(pdev);\n\tha = vha->hw;\n\n\tql_log(ql_log_info, vha, 0xfffa,\n\t\t\"Adapter shutdown\\n\");\n\n\t \n\t__qla_set_remove_flag(vha);\n\tcancel_work_sync(&ha->board_disable);\n\n\tif (!atomic_read(&pdev->enable_cnt))\n\t\treturn;\n\n\t \n\tif (IS_QLAFX00(ha))\n\t\tqlafx00_driver_shutdown(vha, 20);\n\n\t \n\tif (ha->flags.fce_enabled) {\n\t\tqla2x00_disable_fce_trace(vha, NULL, NULL);\n\t\tha->flags.fce_enabled = 0;\n\t}\n\n\t \n\tif (ha->eft)\n\t\tqla2x00_disable_eft_trace(vha);\n\n\tif (IS_QLA25XX(ha) ||  IS_QLA2031(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\tif (ha->flags.fw_started)\n\t\t\tqla2x00_abort_isp_cleanup(vha);\n\t} else {\n\t\t \n\t\tqla2x00_try_to_stop_firmware(vha);\n\t}\n\n\t \n\tif (vha->timer_active)\n\t\tqla2x00_stop_timer(vha);\n\n\t \n\tvha->flags.online = 0;\n\n\t \n\tif (ha->interrupts_on) {\n\t\tvha->flags.init_done = 0;\n\t\tha->isp_ops->disable_intrs(ha);\n\t}\n\n\tqla2x00_free_irqs(vha);\n\n\tqla2x00_free_fw_dump(ha);\n\n\tpci_disable_device(pdev);\n\tql_log(ql_log_info, vha, 0xfffe,\n\t\t\"Adapter shutdown successfully.\\n\");\n}\n\n \nstatic void\nqla2x00_delete_all_vps(struct qla_hw_data *ha, scsi_qla_host_t *base_vha)\n{\n\tscsi_qla_host_t *vha;\n\tunsigned long flags;\n\n\tmutex_lock(&ha->vport_lock);\n\twhile (ha->cur_vport_count) {\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\n\t\tBUG_ON(base_vha->list.next == &ha->vp_list);\n\t\t \n\t\tvha = list_first_entry(&base_vha->list, scsi_qla_host_t, list);\n\t\tscsi_host_get(vha->host);\n\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\t\tmutex_unlock(&ha->vport_lock);\n\n\t\tqla_nvme_delete(vha);\n\n\t\tfc_vport_terminate(vha->fc_vport);\n\t\tscsi_host_put(vha->host);\n\n\t\tmutex_lock(&ha->vport_lock);\n\t}\n\tmutex_unlock(&ha->vport_lock);\n}\n\n \nstatic void\nqla2x00_destroy_deferred_work(struct qla_hw_data *ha)\n{\n\t \n\tif (ha->dpc_lp_wq) {\n\t\tcancel_work_sync(&ha->idc_aen);\n\t\tdestroy_workqueue(ha->dpc_lp_wq);\n\t\tha->dpc_lp_wq = NULL;\n\t}\n\n\tif (ha->dpc_hp_wq) {\n\t\tcancel_work_sync(&ha->nic_core_reset);\n\t\tcancel_work_sync(&ha->idc_state_handler);\n\t\tcancel_work_sync(&ha->nic_core_unrecoverable);\n\t\tdestroy_workqueue(ha->dpc_hp_wq);\n\t\tha->dpc_hp_wq = NULL;\n\t}\n\n\t \n\tif (ha->dpc_thread) {\n\t\tstruct task_struct *t = ha->dpc_thread;\n\n\t\t \n\t\tha->dpc_thread = NULL;\n\t\tkthread_stop(t);\n\t}\n}\n\nstatic void\nqla2x00_unmap_iobases(struct qla_hw_data *ha)\n{\n\tif (IS_QLA82XX(ha)) {\n\n\t\tiounmap((device_reg_t *)ha->nx_pcibase);\n\t\tif (!ql2xdbwr)\n\t\t\tiounmap((device_reg_t *)ha->nxdb_wr_ptr);\n\t} else {\n\t\tif (ha->iobase)\n\t\t\tiounmap(ha->iobase);\n\n\t\tif (ha->cregbase)\n\t\t\tiounmap(ha->cregbase);\n\n\t\tif (ha->mqiobase)\n\t\t\tiounmap(ha->mqiobase);\n\n\t\tif (ha->msixbase)\n\t\t\tiounmap(ha->msixbase);\n\t}\n}\n\nstatic void\nqla2x00_clear_drv_active(struct qla_hw_data *ha)\n{\n\tif (IS_QLA8044(ha)) {\n\t\tqla8044_idc_lock(ha);\n\t\tqla8044_clear_drv_active(ha);\n\t\tqla8044_idc_unlock(ha);\n\t} else if (IS_QLA82XX(ha)) {\n\t\tqla82xx_idc_lock(ha);\n\t\tqla82xx_clear_drv_active(ha);\n\t\tqla82xx_idc_unlock(ha);\n\t}\n}\n\nstatic void\nqla2x00_remove_one(struct pci_dev *pdev)\n{\n\tscsi_qla_host_t *base_vha;\n\tstruct qla_hw_data  *ha;\n\n\tbase_vha = pci_get_drvdata(pdev);\n\tha = base_vha->hw;\n\tql_log(ql_log_info, base_vha, 0xb079,\n\t    \"Removing driver\\n\");\n\t__qla_set_remove_flag(base_vha);\n\tcancel_work_sync(&ha->board_disable);\n\n\t \n\tif (!atomic_read(&pdev->enable_cnt)) {\n\t\tdma_free_coherent(&ha->pdev->dev, base_vha->gnl.size,\n\t\t    base_vha->gnl.l, base_vha->gnl.ldma);\n\t\tbase_vha->gnl.l = NULL;\n\t\tscsi_host_put(base_vha->host);\n\t\tkfree(ha);\n\t\tpci_set_drvdata(pdev, NULL);\n\t\treturn;\n\t}\n\tqla2x00_wait_for_hba_ready(base_vha);\n\n\t \n\tif (test_and_set_bit(UNLOADING, &base_vha->dpc_flags))\n\t\treturn;\n\n\tif (IS_QLA25XX(ha) || IS_QLA2031(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\tif (ha->flags.fw_started)\n\t\t\tqla2x00_abort_isp_cleanup(base_vha);\n\t} else if (!IS_QLAFX00(ha)) {\n\t\tif (IS_QLA8031(ha)) {\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb07e,\n\t\t\t    \"Clearing fcoe driver presence.\\n\");\n\t\t\tif (qla83xx_clear_drv_presence(base_vha) != QLA_SUCCESS)\n\t\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb079,\n\t\t\t\t    \"Error while clearing DRV-Presence.\\n\");\n\t\t}\n\n\t\tqla2x00_try_to_stop_firmware(base_vha);\n\t}\n\n\tqla2x00_wait_for_sess_deletion(base_vha);\n\n\tqla_nvme_delete(base_vha);\n\n\tdma_free_coherent(&ha->pdev->dev,\n\t\tbase_vha->gnl.size, base_vha->gnl.l, base_vha->gnl.ldma);\n\n\tbase_vha->gnl.l = NULL;\n\tqla_enode_stop(base_vha);\n\tqla_edb_stop(base_vha);\n\n\tvfree(base_vha->scan.l);\n\n\tif (IS_QLAFX00(ha))\n\t\tqlafx00_driver_shutdown(base_vha, 20);\n\n\tqla2x00_delete_all_vps(ha, base_vha);\n\n\tqla2x00_dfs_remove(base_vha);\n\n\tqla84xx_put_chip(base_vha);\n\n\t \n\tif (base_vha->timer_active)\n\t\tqla2x00_stop_timer(base_vha);\n\n\tbase_vha->flags.online = 0;\n\n\t \n\tif (ha->exlogin_buf)\n\t\tqla2x00_free_exlogin_buffer(ha);\n\n\t \n\tif (ha->exchoffld_buf)\n\t\tqla2x00_free_exchoffld_buffer(ha);\n\n\tqla2x00_destroy_deferred_work(ha);\n\n\tqlt_remove_target(ha, base_vha);\n\n\tqla2x00_free_sysfs_attr(base_vha, true);\n\n\tfc_remove_host(base_vha->host);\n\n\tscsi_remove_host(base_vha->host);\n\n\tqla2x00_free_device(base_vha);\n\n\tqla2x00_clear_drv_active(ha);\n\n\tscsi_host_put(base_vha->host);\n\n\tqla2x00_unmap_iobases(ha);\n\n\tpci_release_selected_regions(ha->pdev, ha->bars);\n\tkfree(ha);\n\n\tpci_disable_device(pdev);\n}\n\nstatic inline void\nqla24xx_free_purex_list(struct purex_list *list)\n{\n\tstruct purex_item *item, *next;\n\tulong flags;\n\n\tspin_lock_irqsave(&list->lock, flags);\n\tlist_for_each_entry_safe(item, next, &list->head, list) {\n\t\tlist_del(&item->list);\n\t\tif (item == &item->vha->default_item)\n\t\t\tcontinue;\n\t\tkfree(item);\n\t}\n\tspin_unlock_irqrestore(&list->lock, flags);\n}\n\nstatic void\nqla2x00_free_device(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tqla2x00_abort_all_cmds(vha, DID_NO_CONNECT << 16);\n\n\t \n\tif (vha->timer_active)\n\t\tqla2x00_stop_timer(vha);\n\n\tqla25xx_delete_queues(vha);\n\tvha->flags.online = 0;\n\n\t \n\tif (ha->interrupts_on) {\n\t\tvha->flags.init_done = 0;\n\t\tha->isp_ops->disable_intrs(ha);\n\t}\n\n\tqla2x00_free_fcports(vha);\n\n\tqla2x00_free_irqs(vha);\n\n\t \n\tif (ha->wq) {\n\t\tdestroy_workqueue(ha->wq);\n\t\tha->wq = NULL;\n\t}\n\n\n\tqla24xx_free_purex_list(&vha->purex_list);\n\n\tqla2x00_mem_free(ha);\n\n\tqla82xx_md_free(vha);\n\n\tqla_edif_sadb_release_free_pool(ha);\n\tqla_edif_sadb_release(ha);\n\n\tqla2x00_free_queues(ha);\n}\n\nvoid qla2x00_free_fcports(struct scsi_qla_host *vha)\n{\n\tfc_port_t *fcport, *tfcport;\n\n\tlist_for_each_entry_safe(fcport, tfcport, &vha->vp_fcports, list)\n\t\tqla2x00_free_fcport(fcport);\n}\n\nstatic inline void\nqla2x00_schedule_rport_del(struct scsi_qla_host *vha, fc_port_t *fcport)\n{\n\tint now;\n\n\tif (!fcport->rport)\n\t\treturn;\n\n\tif (fcport->rport) {\n\t\tql_dbg(ql_dbg_disc, fcport->vha, 0x2109,\n\t\t    \"%s %8phN. rport %p roles %x\\n\",\n\t\t    __func__, fcport->port_name, fcport->rport,\n\t\t    fcport->rport->roles);\n\t\tfc_remote_port_delete(fcport->rport);\n\t}\n\tqlt_do_generation_tick(vha, &now);\n}\n\n \nvoid qla2x00_mark_device_lost(scsi_qla_host_t *vha, fc_port_t *fcport,\n    int do_login)\n{\n\tif (IS_QLAFX00(vha->hw)) {\n\t\tqla2x00_set_fcport_state(fcport, FCS_DEVICE_LOST);\n\t\tqla2x00_schedule_rport_del(vha, fcport);\n\t\treturn;\n\t}\n\n\tif (atomic_read(&fcport->state) == FCS_ONLINE &&\n\t    vha->vp_idx == fcport->vha->vp_idx) {\n\t\tqla2x00_set_fcport_state(fcport, FCS_DEVICE_LOST);\n\t\tqla2x00_schedule_rport_del(vha, fcport);\n\t}\n\n\t \n\tif (atomic_read(&fcport->state) != FCS_DEVICE_DEAD)\n\t\tqla2x00_set_fcport_state(fcport, FCS_DEVICE_LOST);\n\n\tif (!do_login)\n\t\treturn;\n\n\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n}\n\nvoid\nqla2x00_mark_all_devices_lost(scsi_qla_host_t *vha)\n{\n\tfc_port_t *fcport;\n\n\tql_dbg(ql_dbg_disc, vha, 0x20f1,\n\t    \"Mark all dev lost\\n\");\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (ql2xfc2target &&\n\t\t    fcport->loop_id != FC_NO_LOOP_ID &&\n\t\t    (fcport->flags & FCF_FCP2_DEVICE) &&\n\t\t    fcport->port_type == FCT_TARGET &&\n\t\t    !qla2x00_reset_active(vha)) {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0x211a,\n\t\t\t       \"Delaying session delete for FCP2 flags 0x%x port_type = 0x%x port_id=%06x %phC\",\n\t\t\t       fcport->flags, fcport->port_type,\n\t\t\t       fcport->d_id.b24, fcport->port_name);\n\t\t\tcontinue;\n\t\t}\n\t\tfcport->scan_state = 0;\n\t\tqlt_schedule_sess_for_deletion(fcport);\n\t}\n}\n\nstatic void qla2x00_set_reserved_loop_ids(struct qla_hw_data *ha)\n{\n\tint i;\n\n\tif (IS_FWI2_CAPABLE(ha))\n\t\treturn;\n\n\tfor (i = 0; i < SNS_FIRST_LOOP_ID; i++)\n\t\tset_bit(i, ha->loop_id_map);\n\tset_bit(MANAGEMENT_SERVER, ha->loop_id_map);\n\tset_bit(BROADCAST, ha->loop_id_map);\n}\n\n \nstatic int\nqla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,\n\tstruct req_que **req, struct rsp_que **rsp)\n{\n\tchar\tname[16];\n\tint rc;\n\n\tif (QLA_TGT_MODE_ENABLED() || EDIF_CAP(ha)) {\n\t\tha->vp_map = kcalloc(MAX_MULTI_ID_FABRIC, sizeof(struct qla_vp_map), GFP_KERNEL);\n\t\tif (!ha->vp_map)\n\t\t\tgoto fail;\n\t}\n\n\tha->init_cb = dma_alloc_coherent(&ha->pdev->dev, ha->init_cb_size,\n\t\t&ha->init_cb_dma, GFP_KERNEL);\n\tif (!ha->init_cb)\n\t\tgoto fail_free_vp_map;\n\n\trc = btree_init32(&ha->host_map);\n\tif (rc)\n\t\tgoto fail_free_init_cb;\n\n\tif (qlt_mem_alloc(ha) < 0)\n\t\tgoto fail_free_btree;\n\n\tha->gid_list = dma_alloc_coherent(&ha->pdev->dev,\n\t\tqla2x00_gid_list_size(ha), &ha->gid_list_dma, GFP_KERNEL);\n\tif (!ha->gid_list)\n\t\tgoto fail_free_tgt_mem;\n\n\tha->srb_mempool = mempool_create_slab_pool(SRB_MIN_REQ, srb_cachep);\n\tif (!ha->srb_mempool)\n\t\tgoto fail_free_gid_list;\n\n\tif (IS_P3P_TYPE(ha) || IS_QLA27XX(ha) || (ql2xsecenable && IS_QLA28XX(ha))) {\n\t\t \n\t\tif (!ctx_cachep) {\n\t\t\tctx_cachep = kmem_cache_create(\"qla2xxx_ctx\",\n\t\t\t\tsizeof(struct ct6_dsd), 0,\n\t\t\t\tSLAB_HWCACHE_ALIGN, NULL);\n\t\t\tif (!ctx_cachep)\n\t\t\t\tgoto fail_free_srb_mempool;\n\t\t}\n\t\tha->ctx_mempool = mempool_create_slab_pool(SRB_MIN_REQ,\n\t\t\tctx_cachep);\n\t\tif (!ha->ctx_mempool)\n\t\t\tgoto fail_free_srb_mempool;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0021,\n\t\t    \"ctx_cachep=%p ctx_mempool=%p.\\n\",\n\t\t    ctx_cachep, ha->ctx_mempool);\n\t}\n\n\t \n\tha->nvram = kzalloc(MAX_NVRAM_SIZE, GFP_KERNEL);\n\tif (!ha->nvram)\n\t\tgoto fail_free_ctx_mempool;\n\n\tsnprintf(name, sizeof(name), \"%s_%d\", QLA2XXX_DRIVER_NAME,\n\t\tha->pdev->device);\n\tha->s_dma_pool = dma_pool_create(name, &ha->pdev->dev,\n\t\tDMA_POOL_SIZE, 8, 0);\n\tif (!ha->s_dma_pool)\n\t\tgoto fail_free_nvram;\n\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0022,\n\t    \"init_cb=%p gid_list=%p, srb_mempool=%p s_dma_pool=%p.\\n\",\n\t    ha->init_cb, ha->gid_list, ha->srb_mempool, ha->s_dma_pool);\n\n\tif (IS_P3P_TYPE(ha) || ql2xenabledif || (IS_QLA28XX(ha) && ql2xsecenable)) {\n\t\tha->dl_dma_pool = dma_pool_create(name, &ha->pdev->dev,\n\t\t\tDSD_LIST_DMA_POOL_SIZE, 8, 0);\n\t\tif (!ha->dl_dma_pool) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0023,\n\t\t\t    \"Failed to allocate memory for dl_dma_pool.\\n\");\n\t\t\tgoto fail_s_dma_pool;\n\t\t}\n\n\t\tha->fcp_cmnd_dma_pool = dma_pool_create(name, &ha->pdev->dev,\n\t\t\tFCP_CMND_DMA_POOL_SIZE, 8, 0);\n\t\tif (!ha->fcp_cmnd_dma_pool) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0024,\n\t\t\t    \"Failed to allocate memory for fcp_cmnd_dma_pool.\\n\");\n\t\t\tgoto fail_dl_dma_pool;\n\t\t}\n\n\t\tif (ql2xenabledif) {\n\t\t\tu64 bufsize = DIF_BUNDLING_DMA_POOL_SIZE;\n\t\t\tstruct dsd_dma *dsd, *nxt;\n\t\t\tuint i;\n\t\t\t \n\t\t\tha->dif_bundl_pool = dma_pool_create(name,\n\t\t\t    &ha->pdev->dev, DIF_BUNDLING_DMA_POOL_SIZE, 8, 0);\n\t\t\tif (!ha->dif_bundl_pool) {\n\t\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0024,\n\t\t\t\t    \"%s: failed create dif_bundl_pool\\n\",\n\t\t\t\t    __func__);\n\t\t\t\tgoto fail_dif_bundl_dma_pool;\n\t\t\t}\n\n\t\t\tINIT_LIST_HEAD(&ha->pool.good.head);\n\t\t\tINIT_LIST_HEAD(&ha->pool.unusable.head);\n\t\t\tha->pool.good.count = 0;\n\t\t\tha->pool.unusable.count = 0;\n\t\t\tfor (i = 0; i < 128; i++) {\n\t\t\t\tdsd = kzalloc(sizeof(*dsd), GFP_ATOMIC);\n\t\t\t\tif (!dsd) {\n\t\t\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev,\n\t\t\t\t\t    0xe0ee, \"%s: failed alloc dsd\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tha->dif_bundle_kallocs++;\n\n\t\t\t\tdsd->dsd_addr = dma_pool_alloc(\n\t\t\t\t    ha->dif_bundl_pool, GFP_ATOMIC,\n\t\t\t\t    &dsd->dsd_list_dma);\n\t\t\t\tif (!dsd->dsd_addr) {\n\t\t\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev,\n\t\t\t\t\t    0xe0ee,\n\t\t\t\t\t    \"%s: failed alloc ->dsd_addr\\n\",\n\t\t\t\t\t    __func__);\n\t\t\t\t\tkfree(dsd);\n\t\t\t\t\tha->dif_bundle_kallocs--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tha->dif_bundle_dma_allocs++;\n\n\t\t\t\t \n\t\t\t\tif (MSD(dsd->dsd_list_dma) ^\n\t\t\t\t    MSD(dsd->dsd_list_dma + bufsize)) {\n\t\t\t\t\tlist_add_tail(&dsd->list,\n\t\t\t\t\t    &ha->pool.unusable.head);\n\t\t\t\t\tha->pool.unusable.count++;\n\t\t\t\t} else {\n\t\t\t\t\tlist_add_tail(&dsd->list,\n\t\t\t\t\t    &ha->pool.good.head);\n\t\t\t\t\tha->pool.good.count++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_for_each_entry_safe(dsd, nxt,\n\t\t\t    &ha->pool.good.head, list) {\n\t\t\t\tlist_del(&dsd->list);\n\t\t\t\tdma_pool_free(ha->dif_bundl_pool,\n\t\t\t\t    dsd->dsd_addr, dsd->dsd_list_dma);\n\t\t\t\tha->dif_bundle_dma_allocs--;\n\t\t\t\tkfree(dsd);\n\t\t\t\tha->dif_bundle_kallocs--;\n\t\t\t}\n\n\t\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0024,\n\t\t\t    \"%s: dif dma pool (good=%u unusable=%u)\\n\",\n\t\t\t    __func__, ha->pool.good.count,\n\t\t\t    ha->pool.unusable.count);\n\t\t}\n\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0025,\n\t\t    \"dl_dma_pool=%p fcp_cmnd_dma_pool=%p dif_bundl_pool=%p.\\n\",\n\t\t    ha->dl_dma_pool, ha->fcp_cmnd_dma_pool,\n\t\t    ha->dif_bundl_pool);\n\t}\n\n\t \n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\n\t \n\t\tha->sns_cmd = dma_alloc_coherent(&ha->pdev->dev,\n\t\tsizeof(struct sns_cmd_pkt), &ha->sns_cmd_dma, GFP_KERNEL);\n\t\tif (!ha->sns_cmd)\n\t\t\tgoto fail_dma_pool;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0026,\n\t\t    \"sns_cmd: %p.\\n\", ha->sns_cmd);\n\t} else {\n\t \n\t\tha->ms_iocb = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,\n\t\t\t&ha->ms_iocb_dma);\n\t\tif (!ha->ms_iocb)\n\t\t\tgoto fail_dma_pool;\n\t \n\t\tha->ct_sns = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\tsizeof(struct ct_sns_pkt), &ha->ct_sns_dma, GFP_KERNEL);\n\t\tif (!ha->ct_sns)\n\t\t\tgoto fail_free_ms_iocb;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0027,\n\t\t    \"ms_iocb=%p ct_sns=%p.\\n\",\n\t\t    ha->ms_iocb, ha->ct_sns);\n\t}\n\n\t \n\t*req = kzalloc(sizeof(struct req_que), GFP_KERNEL);\n\tif (!*req) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0028,\n\t\t    \"Failed to allocate memory for req.\\n\");\n\t\tgoto fail_req;\n\t}\n\t(*req)->length = req_len;\n\t(*req)->ring = dma_alloc_coherent(&ha->pdev->dev,\n\t\t((*req)->length + 1) * sizeof(request_t),\n\t\t&(*req)->dma, GFP_KERNEL);\n\tif (!(*req)->ring) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0029,\n\t\t    \"Failed to allocate memory for req_ring.\\n\");\n\t\tgoto fail_req_ring;\n\t}\n\t \n\t*rsp = kzalloc(sizeof(struct rsp_que), GFP_KERNEL);\n\tif (!*rsp) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x002a,\n\t\t    \"Failed to allocate memory for rsp.\\n\");\n\t\tgoto fail_rsp;\n\t}\n\t(*rsp)->hw = ha;\n\t(*rsp)->length = rsp_len;\n\t(*rsp)->ring = dma_alloc_coherent(&ha->pdev->dev,\n\t\t((*rsp)->length + 1) * sizeof(response_t),\n\t\t&(*rsp)->dma, GFP_KERNEL);\n\tif (!(*rsp)->ring) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x002b,\n\t\t    \"Failed to allocate memory for rsp_ring.\\n\");\n\t\tgoto fail_rsp_ring;\n\t}\n\t(*req)->rsp = *rsp;\n\t(*rsp)->req = *req;\n\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x002c,\n\t    \"req=%p req->length=%d req->ring=%p rsp=%p \"\n\t    \"rsp->length=%d rsp->ring=%p.\\n\",\n\t    *req, (*req)->length, (*req)->ring, *rsp, (*rsp)->length,\n\t    (*rsp)->ring);\n\t \n\tif (ha->nvram_npiv_size) {\n\t\tha->npiv_info = kcalloc(ha->nvram_npiv_size,\n\t\t\t\t\tsizeof(struct qla_npiv_entry),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!ha->npiv_info) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x002d,\n\t\t\t    \"Failed to allocate memory for npiv_info.\\n\");\n\t\t\tgoto fail_npiv_info;\n\t\t}\n\t} else\n\t\tha->npiv_info = NULL;\n\n\t \n\tif (IS_CNA_CAPABLE(ha) || IS_QLA2031(ha) || IS_QLA27XX(ha) ||\n\t    IS_QLA28XX(ha)) {\n\t\tha->ex_init_cb = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,\n\t\t    &ha->ex_init_cb_dma);\n\t\tif (!ha->ex_init_cb)\n\t\t\tgoto fail_ex_init_cb;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x002e,\n\t\t    \"ex_init_cb=%p.\\n\", ha->ex_init_cb);\n\t}\n\n\t \n\tif (IS_QLA27XX(ha) || IS_QLA28XX(ha)) {\n\t\tha->sf_init_cb = dma_pool_zalloc(ha->s_dma_pool, GFP_KERNEL,\n\t\t\t\t\t\t&ha->sf_init_cb_dma);\n\t\tif (!ha->sf_init_cb)\n\t\t\tgoto fail_sf_init_cb;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0199,\n\t\t\t   \"sf_init_cb=%p.\\n\", ha->sf_init_cb);\n\t}\n\n\n\t \n\tif (!IS_FWI2_CAPABLE(ha)) {\n\t\tha->async_pd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL,\n\t\t\t&ha->async_pd_dma);\n\t\tif (!ha->async_pd)\n\t\t\tgoto fail_async_pd;\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x002f,\n\t\t    \"async_pd=%p.\\n\", ha->async_pd);\n\t}\n\n\tINIT_LIST_HEAD(&ha->vp_list);\n\n\t \n\tha->loop_id_map = kcalloc(BITS_TO_LONGS(LOOPID_MAP_SIZE),\n\t\t\t\t  sizeof(long),\n\t\t\t\t  GFP_KERNEL);\n\tif (!ha->loop_id_map)\n\t\tgoto fail_loop_id_map;\n\telse {\n\t\tqla2x00_set_reserved_loop_ids(ha);\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x0123,\n\t\t    \"loop_id_map=%p.\\n\", ha->loop_id_map);\n\t}\n\n\tha->sfp_data = dma_alloc_coherent(&ha->pdev->dev,\n\t    SFP_DEV_SIZE, &ha->sfp_data_dma, GFP_KERNEL);\n\tif (!ha->sfp_data) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x011b,\n\t\t    \"Unable to allocate memory for SFP read-data.\\n\");\n\t\tgoto fail_sfp_data;\n\t}\n\n\tha->flt = dma_alloc_coherent(&ha->pdev->dev,\n\t    sizeof(struct qla_flt_header) + FLT_REGIONS_SIZE, &ha->flt_dma,\n\t    GFP_KERNEL);\n\tif (!ha->flt) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x011b,\n\t\t    \"Unable to allocate memory for FLT.\\n\");\n\t\tgoto fail_flt_buffer;\n\t}\n\n\t \n\tha->purex_dma_pool = dma_pool_create(name, &ha->pdev->dev,\n\t    ELS_MAX_PAYLOAD, 8, 0);\n\n\tif (!ha->purex_dma_pool) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0x011b,\n\t\t    \"Unable to allocate purex_dma_pool.\\n\");\n\t\tgoto fail_flt;\n\t}\n\n\tha->elsrej.size = sizeof(struct fc_els_ls_rjt) + 16;\n\tha->elsrej.c = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t  ha->elsrej.size,\n\t\t\t\t\t  &ha->elsrej.cdma,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!ha->elsrej.c) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0xffff,\n\t\t    \"Alloc failed for els reject cmd.\\n\");\n\t\tgoto fail_elsrej;\n\t}\n\tha->elsrej.c->er_cmd = ELS_LS_RJT;\n\tha->elsrej.c->er_reason = ELS_RJT_LOGIC;\n\tha->elsrej.c->er_explan = ELS_EXPL_UNAB_DATA;\n\n\tha->lsrjt.size = sizeof(struct fcnvme_ls_rjt);\n\tha->lsrjt.c = dma_alloc_coherent(&ha->pdev->dev, ha->lsrjt.size,\n\t\t\t&ha->lsrjt.cdma, GFP_KERNEL);\n\tif (!ha->lsrjt.c) {\n\t\tql_dbg_pci(ql_dbg_init, ha->pdev, 0xffff,\n\t\t\t   \"Alloc failed for nvme fc reject cmd.\\n\");\n\t\tgoto fail_lsrjt;\n\t}\n\n\treturn 0;\n\nfail_lsrjt:\n\tdma_free_coherent(&ha->pdev->dev, ha->elsrej.size,\n\t\t\t  ha->elsrej.c, ha->elsrej.cdma);\nfail_elsrej:\n\tdma_pool_destroy(ha->purex_dma_pool);\nfail_flt:\n\tdma_free_coherent(&ha->pdev->dev, SFP_DEV_SIZE,\n\t    ha->flt, ha->flt_dma);\n\nfail_flt_buffer:\n\tdma_free_coherent(&ha->pdev->dev, SFP_DEV_SIZE,\n\t    ha->sfp_data, ha->sfp_data_dma);\nfail_sfp_data:\n\tkfree(ha->loop_id_map);\nfail_loop_id_map:\n\tdma_pool_free(ha->s_dma_pool, ha->async_pd, ha->async_pd_dma);\nfail_async_pd:\n\tdma_pool_free(ha->s_dma_pool, ha->sf_init_cb, ha->sf_init_cb_dma);\nfail_sf_init_cb:\n\tdma_pool_free(ha->s_dma_pool, ha->ex_init_cb, ha->ex_init_cb_dma);\nfail_ex_init_cb:\n\tkfree(ha->npiv_info);\nfail_npiv_info:\n\tdma_free_coherent(&ha->pdev->dev, ((*rsp)->length + 1) *\n\t\tsizeof(response_t), (*rsp)->ring, (*rsp)->dma);\n\t(*rsp)->ring = NULL;\n\t(*rsp)->dma = 0;\nfail_rsp_ring:\n\tkfree(*rsp);\n\t*rsp = NULL;\nfail_rsp:\n\tdma_free_coherent(&ha->pdev->dev, ((*req)->length + 1) *\n\t\tsizeof(request_t), (*req)->ring, (*req)->dma);\n\t(*req)->ring = NULL;\n\t(*req)->dma = 0;\nfail_req_ring:\n\tkfree(*req);\n\t*req = NULL;\nfail_req:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct ct_sns_pkt),\n\t\tha->ct_sns, ha->ct_sns_dma);\n\tha->ct_sns = NULL;\n\tha->ct_sns_dma = 0;\nfail_free_ms_iocb:\n\tdma_pool_free(ha->s_dma_pool, ha->ms_iocb, ha->ms_iocb_dma);\n\tha->ms_iocb = NULL;\n\tha->ms_iocb_dma = 0;\n\n\tif (ha->sns_cmd)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(struct sns_cmd_pkt),\n\t\t    ha->sns_cmd, ha->sns_cmd_dma);\nfail_dma_pool:\n\tif (ql2xenabledif) {\n\t\tstruct dsd_dma *dsd, *nxt;\n\n\t\tlist_for_each_entry_safe(dsd, nxt, &ha->pool.unusable.head,\n\t\t    list) {\n\t\t\tlist_del(&dsd->list);\n\t\t\tdma_pool_free(ha->dif_bundl_pool, dsd->dsd_addr,\n\t\t\t    dsd->dsd_list_dma);\n\t\t\tha->dif_bundle_dma_allocs--;\n\t\t\tkfree(dsd);\n\t\t\tha->dif_bundle_kallocs--;\n\t\t\tha->pool.unusable.count--;\n\t\t}\n\t\tdma_pool_destroy(ha->dif_bundl_pool);\n\t\tha->dif_bundl_pool = NULL;\n\t}\n\nfail_dif_bundl_dma_pool:\n\tif (IS_QLA82XX(ha) || ql2xenabledif) {\n\t\tdma_pool_destroy(ha->fcp_cmnd_dma_pool);\n\t\tha->fcp_cmnd_dma_pool = NULL;\n\t}\nfail_dl_dma_pool:\n\tif (IS_QLA82XX(ha) || ql2xenabledif) {\n\t\tdma_pool_destroy(ha->dl_dma_pool);\n\t\tha->dl_dma_pool = NULL;\n\t}\nfail_s_dma_pool:\n\tdma_pool_destroy(ha->s_dma_pool);\n\tha->s_dma_pool = NULL;\nfail_free_nvram:\n\tkfree(ha->nvram);\n\tha->nvram = NULL;\nfail_free_ctx_mempool:\n\tmempool_destroy(ha->ctx_mempool);\n\tha->ctx_mempool = NULL;\nfail_free_srb_mempool:\n\tmempool_destroy(ha->srb_mempool);\n\tha->srb_mempool = NULL;\nfail_free_gid_list:\n\tdma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),\n\tha->gid_list,\n\tha->gid_list_dma);\n\tha->gid_list = NULL;\n\tha->gid_list_dma = 0;\nfail_free_tgt_mem:\n\tqlt_mem_free(ha);\nfail_free_btree:\n\tbtree_destroy32(&ha->host_map);\nfail_free_init_cb:\n\tdma_free_coherent(&ha->pdev->dev, ha->init_cb_size, ha->init_cb,\n\tha->init_cb_dma);\n\tha->init_cb = NULL;\n\tha->init_cb_dma = 0;\nfail_free_vp_map:\n\tkfree(ha->vp_map);\nfail:\n\tql_log(ql_log_fatal, NULL, 0x0030,\n\t    \"Memory allocation failure.\\n\");\n\treturn -ENOMEM;\n}\n\nint\nqla2x00_set_exlogins_buffer(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tuint16_t\tsize, max_cnt;\n\tuint32_t temp;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\t \n\tif (ql2xexlogins <= MAX_FIBRE_DEVICES_2400)\n\t\treturn QLA_SUCCESS;\n\n\tif (!IS_EXLOGIN_OFFLD_CAPABLE(ha))\n\t\treturn QLA_SUCCESS;\n\n\tql_log(ql_log_info, vha, 0xd021, \"EXLOGIN count: %d.\\n\", ql2xexlogins);\n\tmax_cnt = 0;\n\trval = qla_get_exlogin_status(vha, &size, &max_cnt);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0xd029,\n\t\t    \"Failed to get exlogin status.\\n\");\n\t\treturn rval;\n\t}\n\n\ttemp = (ql2xexlogins > max_cnt) ? max_cnt : ql2xexlogins;\n\ttemp *= size;\n\n\tif (temp != ha->exlogin_size) {\n\t\tqla2x00_free_exlogin_buffer(ha);\n\t\tha->exlogin_size = temp;\n\n\t\tql_log(ql_log_info, vha, 0xd024,\n\t\t    \"EXLOGIN: max_logins=%d, portdb=0x%x, total=%d.\\n\",\n\t\t    max_cnt, size, temp);\n\n\t\tql_log(ql_log_info, vha, 0xd025,\n\t\t    \"EXLOGIN: requested size=0x%x\\n\", ha->exlogin_size);\n\n\t\t \n\t\tha->exlogin_buf = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\tha->exlogin_size, &ha->exlogin_buf_dma, GFP_KERNEL);\n\t\tif (!ha->exlogin_buf) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0xd02a,\n\t\t    \"Failed to allocate memory for exlogin_buf_dma.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\trval = qla_set_exlogin_mem_cfg(vha, ha->exlogin_buf_dma);\n\tif (rval) {\n\t\tql_log(ql_log_fatal, vha, 0xd033,\n\t\t    \"Setup extended login buffer  ****FAILED****.\\n\");\n\t\tqla2x00_free_exlogin_buffer(ha);\n\t}\n\n\treturn rval;\n}\n\n \nvoid\nqla2x00_free_exlogin_buffer(struct qla_hw_data *ha)\n{\n\tif (ha->exlogin_buf) {\n\t\tdma_free_coherent(&ha->pdev->dev, ha->exlogin_size,\n\t\t    ha->exlogin_buf, ha->exlogin_buf_dma);\n\t\tha->exlogin_buf = NULL;\n\t\tha->exlogin_size = 0;\n\t}\n}\n\nstatic void\nqla2x00_number_of_exch(scsi_qla_host_t *vha, u32 *ret_cnt, u16 max_cnt)\n{\n\tu32 temp;\n\tstruct init_cb_81xx *icb = (struct init_cb_81xx *)&vha->hw->init_cb;\n\t*ret_cnt = FW_DEF_EXCHANGES_CNT;\n\n\tif (max_cnt > vha->hw->max_exchg)\n\t\tmax_cnt = vha->hw->max_exchg;\n\n\tif (qla_ini_mode_enabled(vha)) {\n\t\tif (vha->ql2xiniexchg > max_cnt)\n\t\t\tvha->ql2xiniexchg = max_cnt;\n\n\t\tif (vha->ql2xiniexchg > FW_DEF_EXCHANGES_CNT)\n\t\t\t*ret_cnt = vha->ql2xiniexchg;\n\n\t} else if (qla_tgt_mode_enabled(vha)) {\n\t\tif (vha->ql2xexchoffld > max_cnt) {\n\t\t\tvha->ql2xexchoffld = max_cnt;\n\t\t\ticb->exchange_count = cpu_to_le16(vha->ql2xexchoffld);\n\t\t}\n\n\t\tif (vha->ql2xexchoffld > FW_DEF_EXCHANGES_CNT)\n\t\t\t*ret_cnt = vha->ql2xexchoffld;\n\t} else if (qla_dual_mode_enabled(vha)) {\n\t\ttemp = vha->ql2xiniexchg + vha->ql2xexchoffld;\n\t\tif (temp > max_cnt) {\n\t\t\tvha->ql2xiniexchg -= (temp - max_cnt)/2;\n\t\t\tvha->ql2xexchoffld -= (((temp - max_cnt)/2) + 1);\n\t\t\ttemp = max_cnt;\n\t\t\ticb->exchange_count = cpu_to_le16(vha->ql2xexchoffld);\n\t\t}\n\n\t\tif (temp > FW_DEF_EXCHANGES_CNT)\n\t\t\t*ret_cnt = temp;\n\t}\n}\n\nint\nqla2x00_set_exchoffld_buffer(scsi_qla_host_t *vha)\n{\n\tint rval;\n\tu16\tsize, max_cnt;\n\tu32 actual_cnt, totsz;\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->flags.exchoffld_enabled)\n\t\treturn QLA_SUCCESS;\n\n\tif (!IS_EXCHG_OFFLD_CAPABLE(ha))\n\t\treturn QLA_SUCCESS;\n\n\tmax_cnt = 0;\n\trval = qla_get_exchoffld_status(vha, &size, &max_cnt);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0xd012,\n\t\t    \"Failed to get exlogin status.\\n\");\n\t\treturn rval;\n\t}\n\n\tqla2x00_number_of_exch(vha, &actual_cnt, max_cnt);\n\tql_log(ql_log_info, vha, 0xd014,\n\t    \"Actual exchange offload count: %d.\\n\", actual_cnt);\n\n\ttotsz = actual_cnt * size;\n\n\tif (totsz != ha->exchoffld_size) {\n\t\tqla2x00_free_exchoffld_buffer(ha);\n\t\tif (actual_cnt <= FW_DEF_EXCHANGES_CNT) {\n\t\t\tha->exchoffld_size = 0;\n\t\t\tha->flags.exchoffld_enabled = 0;\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\n\t\tha->exchoffld_size = totsz;\n\n\t\tql_log(ql_log_info, vha, 0xd016,\n\t\t    \"Exchange offload: max_count=%d, actual count=%d entry sz=0x%x, total sz=0x%x\\n\",\n\t\t    max_cnt, actual_cnt, size, totsz);\n\n\t\tql_log(ql_log_info, vha, 0xd017,\n\t\t    \"Exchange Buffers requested size = 0x%x\\n\",\n\t\t    ha->exchoffld_size);\n\n\t\t \n\t\tha->exchoffld_buf = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\tha->exchoffld_size, &ha->exchoffld_buf_dma, GFP_KERNEL);\n\t\tif (!ha->exchoffld_buf) {\n\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0xd013,\n\t\t\t\"Failed to allocate memory for Exchange Offload.\\n\");\n\n\t\t\tif (ha->max_exchg >\n\t\t\t    (FW_DEF_EXCHANGES_CNT + REDUCE_EXCHANGES_CNT)) {\n\t\t\t\tha->max_exchg -= REDUCE_EXCHANGES_CNT;\n\t\t\t} else if (ha->max_exchg >\n\t\t\t    (FW_DEF_EXCHANGES_CNT + 512)) {\n\t\t\t\tha->max_exchg -= 512;\n\t\t\t} else {\n\t\t\t\tha->flags.exchoffld_enabled = 0;\n\t\t\t\tql_log_pci(ql_log_fatal, ha->pdev, 0xd013,\n\t\t\t\t    \"Disabling Exchange offload due to lack of memory\\n\");\n\t\t\t}\n\t\t\tha->exchoffld_size = 0;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else if (!ha->exchoffld_buf || (actual_cnt <= FW_DEF_EXCHANGES_CNT)) {\n\t\t \n\t\tqla2x00_free_exchoffld_buffer(ha);\n\t\tha->exchoffld_size = 0;\n\t\tha->flags.exchoffld_enabled = 0;\n\t\tql_log(ql_log_info, vha, 0xd016,\n\t\t    \"Exchange offload not enable: offld size=%d, actual count=%d entry sz=0x%x, total sz=0x%x.\\n\",\n\t\t    ha->exchoffld_size, actual_cnt, size, totsz);\n\t\treturn 0;\n\t}\n\n\t \n\trval = qla_set_exchoffld_mem_cfg(vha);\n\tif (rval) {\n\t\tql_log(ql_log_fatal, vha, 0xd02e,\n\t\t    \"Setup exchange offload buffer ****FAILED****.\\n\");\n\t\tqla2x00_free_exchoffld_buffer(ha);\n\t} else {\n\t\t \n\t\tstruct init_cb_81xx *icb = (struct init_cb_81xx *)ha->init_cb;\n\n\t\tif (qla_ini_mode_enabled(vha))\n\t\t\ticb->exchange_count = 0;\n\t\telse\n\t\t\ticb->exchange_count = cpu_to_le16(vha->ql2xexchoffld);\n\t}\n\n\treturn rval;\n}\n\n \nvoid\nqla2x00_free_exchoffld_buffer(struct qla_hw_data *ha)\n{\n\tif (ha->exchoffld_buf) {\n\t\tdma_free_coherent(&ha->pdev->dev, ha->exchoffld_size,\n\t\t    ha->exchoffld_buf, ha->exchoffld_buf_dma);\n\t\tha->exchoffld_buf = NULL;\n\t\tha->exchoffld_size = 0;\n\t}\n}\n\n \nstatic void\nqla2x00_free_fw_dump(struct qla_hw_data *ha)\n{\n\tstruct fwdt *fwdt = ha->fwdt;\n\tuint j;\n\n\tif (ha->fce)\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t    FCE_SIZE, ha->fce, ha->fce_dma);\n\n\tif (ha->eft)\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t    EFT_SIZE, ha->eft, ha->eft_dma);\n\n\tvfree(ha->fw_dump);\n\n\tha->fce = NULL;\n\tha->fce_dma = 0;\n\tha->flags.fce_enabled = 0;\n\tha->eft = NULL;\n\tha->eft_dma = 0;\n\tha->fw_dumped = false;\n\tha->fw_dump_cap_flags = 0;\n\tha->fw_dump_reading = 0;\n\tha->fw_dump = NULL;\n\tha->fw_dump_len = 0;\n\n\tfor (j = 0; j < 2; j++, fwdt++) {\n\t\tvfree(fwdt->template);\n\t\tfwdt->template = NULL;\n\t\tfwdt->length = 0;\n\t}\n}\n\n \nstatic void\nqla2x00_mem_free(struct qla_hw_data *ha)\n{\n\tqla2x00_free_fw_dump(ha);\n\n\tif (ha->mctp_dump)\n\t\tdma_free_coherent(&ha->pdev->dev, MCTP_DUMP_SIZE, ha->mctp_dump,\n\t\t    ha->mctp_dump_dma);\n\tha->mctp_dump = NULL;\n\n\tmempool_destroy(ha->srb_mempool);\n\tha->srb_mempool = NULL;\n\n\tif (ha->dcbx_tlv)\n\t\tdma_free_coherent(&ha->pdev->dev, DCBX_TLV_DATA_SIZE,\n\t\t    ha->dcbx_tlv, ha->dcbx_tlv_dma);\n\tha->dcbx_tlv = NULL;\n\n\tif (ha->xgmac_data)\n\t\tdma_free_coherent(&ha->pdev->dev, XGMAC_DATA_SIZE,\n\t\t    ha->xgmac_data, ha->xgmac_data_dma);\n\tha->xgmac_data = NULL;\n\n\tif (ha->sns_cmd)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(struct sns_cmd_pkt),\n\t\tha->sns_cmd, ha->sns_cmd_dma);\n\tha->sns_cmd = NULL;\n\tha->sns_cmd_dma = 0;\n\n\tif (ha->ct_sns)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(struct ct_sns_pkt),\n\t\tha->ct_sns, ha->ct_sns_dma);\n\tha->ct_sns = NULL;\n\tha->ct_sns_dma = 0;\n\n\tif (ha->sfp_data)\n\t\tdma_free_coherent(&ha->pdev->dev, SFP_DEV_SIZE, ha->sfp_data,\n\t\t    ha->sfp_data_dma);\n\tha->sfp_data = NULL;\n\n\tif (ha->flt)\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t    sizeof(struct qla_flt_header) + FLT_REGIONS_SIZE,\n\t\t    ha->flt, ha->flt_dma);\n\tha->flt = NULL;\n\tha->flt_dma = 0;\n\n\tif (ha->ms_iocb)\n\t\tdma_pool_free(ha->s_dma_pool, ha->ms_iocb, ha->ms_iocb_dma);\n\tha->ms_iocb = NULL;\n\tha->ms_iocb_dma = 0;\n\n\tif (ha->sf_init_cb)\n\t\tdma_pool_free(ha->s_dma_pool,\n\t\t\t      ha->sf_init_cb, ha->sf_init_cb_dma);\n\n\tif (ha->ex_init_cb)\n\t\tdma_pool_free(ha->s_dma_pool,\n\t\t\tha->ex_init_cb, ha->ex_init_cb_dma);\n\tha->ex_init_cb = NULL;\n\tha->ex_init_cb_dma = 0;\n\n\tif (ha->async_pd)\n\t\tdma_pool_free(ha->s_dma_pool, ha->async_pd, ha->async_pd_dma);\n\tha->async_pd = NULL;\n\tha->async_pd_dma = 0;\n\n\tdma_pool_destroy(ha->s_dma_pool);\n\tha->s_dma_pool = NULL;\n\n\tif (ha->gid_list)\n\t\tdma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),\n\t\tha->gid_list, ha->gid_list_dma);\n\tha->gid_list = NULL;\n\tha->gid_list_dma = 0;\n\n\tif (ha->base_qpair && !list_empty(&ha->base_qpair->dsd_list)) {\n\t\tstruct dsd_dma *dsd_ptr, *tdsd_ptr;\n\n\t\t \n\t\tlist_for_each_entry_safe(dsd_ptr, tdsd_ptr,\n\t\t\t\t\t &ha->base_qpair->dsd_list, list) {\n\t\t\tdma_pool_free(ha->dl_dma_pool, dsd_ptr->dsd_addr,\n\t\t\t\t      dsd_ptr->dsd_list_dma);\n\t\t\tlist_del(&dsd_ptr->list);\n\t\t\tkfree(dsd_ptr);\n\t\t}\n\t}\n\n\tdma_pool_destroy(ha->dl_dma_pool);\n\tha->dl_dma_pool = NULL;\n\n\tdma_pool_destroy(ha->fcp_cmnd_dma_pool);\n\tha->fcp_cmnd_dma_pool = NULL;\n\n\tmempool_destroy(ha->ctx_mempool);\n\tha->ctx_mempool = NULL;\n\n\tif (ql2xenabledif && ha->dif_bundl_pool) {\n\t\tstruct dsd_dma *dsd, *nxt;\n\n\t\tlist_for_each_entry_safe(dsd, nxt, &ha->pool.unusable.head,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&dsd->list);\n\t\t\tdma_pool_free(ha->dif_bundl_pool, dsd->dsd_addr,\n\t\t\t\t      dsd->dsd_list_dma);\n\t\t\tha->dif_bundle_dma_allocs--;\n\t\t\tkfree(dsd);\n\t\t\tha->dif_bundle_kallocs--;\n\t\t\tha->pool.unusable.count--;\n\t\t}\n\t\tlist_for_each_entry_safe(dsd, nxt, &ha->pool.good.head, list) {\n\t\t\tlist_del(&dsd->list);\n\t\t\tdma_pool_free(ha->dif_bundl_pool, dsd->dsd_addr,\n\t\t\t\t      dsd->dsd_list_dma);\n\t\t\tha->dif_bundle_dma_allocs--;\n\t\t\tkfree(dsd);\n\t\t\tha->dif_bundle_kallocs--;\n\t\t}\n\t}\n\n\tdma_pool_destroy(ha->dif_bundl_pool);\n\tha->dif_bundl_pool = NULL;\n\n\tqlt_mem_free(ha);\n\tqla_remove_hostmap(ha);\n\n\tif (ha->init_cb)\n\t\tdma_free_coherent(&ha->pdev->dev, ha->init_cb_size,\n\t\t\tha->init_cb, ha->init_cb_dma);\n\n\tdma_pool_destroy(ha->purex_dma_pool);\n\tha->purex_dma_pool = NULL;\n\n\tif (ha->elsrej.c) {\n\t\tdma_free_coherent(&ha->pdev->dev, ha->elsrej.size,\n\t\t    ha->elsrej.c, ha->elsrej.cdma);\n\t\tha->elsrej.c = NULL;\n\t}\n\n\tif (ha->lsrjt.c) {\n\t\tdma_free_coherent(&ha->pdev->dev, ha->lsrjt.size, ha->lsrjt.c,\n\t\t\t\t  ha->lsrjt.cdma);\n\t\tha->lsrjt.c = NULL;\n\t}\n\n\tha->init_cb = NULL;\n\tha->init_cb_dma = 0;\n\n\tvfree(ha->optrom_buffer);\n\tha->optrom_buffer = NULL;\n\tkfree(ha->nvram);\n\tha->nvram = NULL;\n\tkfree(ha->npiv_info);\n\tha->npiv_info = NULL;\n\tkfree(ha->swl);\n\tha->swl = NULL;\n\tkfree(ha->loop_id_map);\n\tha->sf_init_cb = NULL;\n\tha->sf_init_cb_dma = 0;\n\tha->loop_id_map = NULL;\n\n\tkfree(ha->vp_map);\n\tha->vp_map = NULL;\n}\n\nstruct scsi_qla_host *qla2x00_create_host(const struct scsi_host_template *sht,\n\t\t\t\t\t  struct qla_hw_data *ha)\n{\n\tstruct Scsi_Host *host;\n\tstruct scsi_qla_host *vha = NULL;\n\n\thost = scsi_host_alloc(sht, sizeof(scsi_qla_host_t));\n\tif (!host) {\n\t\tql_log_pci(ql_log_fatal, ha->pdev, 0x0107,\n\t\t    \"Failed to allocate host from the scsi layer, aborting.\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tvha = shost_priv(host);\n\tmemset(vha, 0, sizeof(scsi_qla_host_t));\n\n\tvha->host = host;\n\tvha->host_no = host->host_no;\n\tvha->hw = ha;\n\n\tvha->qlini_mode = ql2x_ini_mode;\n\tvha->ql2xexchoffld = ql2xexchoffld;\n\tvha->ql2xiniexchg = ql2xiniexchg;\n\n\tINIT_LIST_HEAD(&vha->vp_fcports);\n\tINIT_LIST_HEAD(&vha->work_list);\n\tINIT_LIST_HEAD(&vha->list);\n\tINIT_LIST_HEAD(&vha->qla_cmd_list);\n\tINIT_LIST_HEAD(&vha->logo_list);\n\tINIT_LIST_HEAD(&vha->plogi_ack_list);\n\tINIT_LIST_HEAD(&vha->qp_list);\n\tINIT_LIST_HEAD(&vha->gnl.fcports);\n\tINIT_WORK(&vha->iocb_work, qla2x00_iocb_work_fn);\n\n\tINIT_LIST_HEAD(&vha->purex_list.head);\n\tspin_lock_init(&vha->purex_list.lock);\n\n\tspin_lock_init(&vha->work_lock);\n\tspin_lock_init(&vha->cmd_list_lock);\n\tinit_waitqueue_head(&vha->fcport_waitQ);\n\tinit_waitqueue_head(&vha->vref_waitq);\n\tqla_enode_init(vha);\n\tqla_edb_init(vha);\n\n\n\tvha->gnl.size = sizeof(struct get_name_list_extended) *\n\t\t\t(ha->max_loop_id + 1);\n\tvha->gnl.l = dma_alloc_coherent(&ha->pdev->dev,\n\t    vha->gnl.size, &vha->gnl.ldma, GFP_KERNEL);\n\tif (!vha->gnl.l) {\n\t\tql_log(ql_log_fatal, vha, 0xd04a,\n\t\t    \"Alloc failed for name list.\\n\");\n\t\tscsi_host_put(vha->host);\n\t\treturn NULL;\n\t}\n\n\t \n\tvha->scan.size = ha->max_fibre_devices * sizeof(struct fab_scan_rp);\n\tvha->scan.l = vmalloc(vha->scan.size);\n\tif (!vha->scan.l) {\n\t\tql_log(ql_log_fatal, vha, 0xd04a,\n\t\t    \"Alloc failed for scan database.\\n\");\n\t\tdma_free_coherent(&ha->pdev->dev, vha->gnl.size,\n\t\t    vha->gnl.l, vha->gnl.ldma);\n\t\tvha->gnl.l = NULL;\n\t\tscsi_host_put(vha->host);\n\t\treturn NULL;\n\t}\n\tINIT_DELAYED_WORK(&vha->scan.scan_work, qla_scan_work_fn);\n\n\tsnprintf(vha->host_str, sizeof(vha->host_str), \"%s_%lu\",\n\t\t QLA2XXX_DRIVER_NAME, vha->host_no);\n\tql_dbg(ql_dbg_init, vha, 0x0041,\n\t    \"Allocated the host=%p hw=%p vha=%p dev_name=%s\",\n\t    vha->host, vha->hw, vha,\n\t    dev_name(&(ha->pdev->dev)));\n\n\treturn vha;\n}\n\nstruct qla_work_evt *\nqla2x00_alloc_work(struct scsi_qla_host *vha, enum qla_work_type type)\n{\n\tstruct qla_work_evt *e;\n\n\tif (test_bit(UNLOADING, &vha->dpc_flags))\n\t\treturn NULL;\n\n\tif (qla_vha_mark_busy(vha))\n\t\treturn NULL;\n\n\te = kzalloc(sizeof(struct qla_work_evt), GFP_ATOMIC);\n\tif (!e) {\n\t\tQLA_VHA_MARK_NOT_BUSY(vha);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&e->list);\n\te->type = type;\n\te->flags = QLA_EVT_FLAG_FREE;\n\treturn e;\n}\n\nint\nqla2x00_post_work(struct scsi_qla_host *vha, struct qla_work_evt *e)\n{\n\tunsigned long flags;\n\tbool q = false;\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tlist_add_tail(&e->list, &vha->work_list);\n\n\tif (!test_and_set_bit(IOCB_WORK_ACTIVE, &vha->dpc_flags))\n\t\tq = true;\n\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\tif (q)\n\t\tqueue_work(vha->hw->wq, &vha->iocb_work);\n\n\treturn QLA_SUCCESS;\n}\n\nint\nqla2x00_post_aen_work(struct scsi_qla_host *vha, enum fc_host_event_code code,\n    u32 data)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_AEN);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.aen.code = code;\n\te->u.aen.data = data;\n\treturn qla2x00_post_work(vha, e);\n}\n\nint\nqla2x00_post_idc_ack_work(struct scsi_qla_host *vha, uint16_t *mb)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_IDC_ACK);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\tmemcpy(e->u.idc_ack.mb, mb, QLA_IDC_ACK_REGS * sizeof(uint16_t));\n\treturn qla2x00_post_work(vha, e);\n}\n\n#define qla2x00_post_async_work(name, type)\t\\\nint qla2x00_post_async_##name##_work(\t\t\\\n    struct scsi_qla_host *vha,\t\t\t\\\n    fc_port_t *fcport, uint16_t *data)\t\t\\\n{\t\t\t\t\t\t\\\n\tstruct qla_work_evt *e;\t\t\t\\\n\t\t\t\t\t\t\\\n\te = qla2x00_alloc_work(vha, type);\t\\\n\tif (!e)\t\t\t\t\t\\\n\t\treturn QLA_FUNCTION_FAILED;\t\\\n\t\t\t\t\t\t\\\n\te->u.logio.fcport = fcport;\t\t\\\n\tif (data) {\t\t\t\t\\\n\t\te->u.logio.data[0] = data[0];\t\\\n\t\te->u.logio.data[1] = data[1];\t\\\n\t}\t\t\t\t\t\\\n\tfcport->flags |= FCF_ASYNC_ACTIVE;\t\\\n\treturn qla2x00_post_work(vha, e);\t\\\n}\n\nqla2x00_post_async_work(login, QLA_EVT_ASYNC_LOGIN);\nqla2x00_post_async_work(logout, QLA_EVT_ASYNC_LOGOUT);\nqla2x00_post_async_work(adisc, QLA_EVT_ASYNC_ADISC);\nqla2x00_post_async_work(prlo, QLA_EVT_ASYNC_PRLO);\nqla2x00_post_async_work(prlo_done, QLA_EVT_ASYNC_PRLO_DONE);\n\nint\nqla2x00_post_uevent_work(struct scsi_qla_host *vha, u32 code)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_UEVENT);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.uevent.code = code;\n\treturn qla2x00_post_work(vha, e);\n}\n\nstatic void\nqla2x00_uevent_emit(struct scsi_qla_host *vha, u32 code)\n{\n\tchar event_string[40];\n\tchar *envp[] = { event_string, NULL };\n\n\tswitch (code) {\n\tcase QLA_UEVENT_CODE_FW_DUMP:\n\t\tsnprintf(event_string, sizeof(event_string), \"FW_DUMP=%lu\",\n\t\t    vha->host_no);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\tkobject_uevent_env(&vha->hw->pdev->dev.kobj, KOBJ_CHANGE, envp);\n}\n\nint\nqlafx00_post_aenfx_work(struct scsi_qla_host *vha,  uint32_t evtcode,\n\t\t\tuint32_t *data, int cnt)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_AENFX);\n\tif (!e)\n\t\treturn QLA_FUNCTION_FAILED;\n\n\te->u.aenfx.evtcode = evtcode;\n\te->u.aenfx.count = cnt;\n\tmemcpy(e->u.aenfx.mbx, data, sizeof(*data) * cnt);\n\treturn qla2x00_post_work(vha, e);\n}\n\nvoid qla24xx_sched_upd_fcport(fc_port_t *fcport)\n{\n\tunsigned long flags;\n\n\tif (IS_SW_RESV_ADDR(fcport->d_id))\n\t\treturn;\n\n\tspin_lock_irqsave(&fcport->vha->work_lock, flags);\n\tif (fcport->disc_state == DSC_UPD_FCPORT) {\n\t\tspin_unlock_irqrestore(&fcport->vha->work_lock, flags);\n\t\treturn;\n\t}\n\tfcport->jiffies_at_registration = jiffies;\n\tfcport->sec_since_registration = 0;\n\tfcport->next_disc_state = DSC_DELETED;\n\tqla2x00_set_fcport_disc_state(fcport, DSC_UPD_FCPORT);\n\tspin_unlock_irqrestore(&fcport->vha->work_lock, flags);\n\n\tqueue_work(system_unbound_wq, &fcport->reg_work);\n}\n\nstatic\nvoid qla24xx_create_new_sess(struct scsi_qla_host *vha, struct qla_work_evt *e)\n{\n\tunsigned long flags;\n\tfc_port_t *fcport =  NULL, *tfcp;\n\tstruct qlt_plogi_ack_t *pla =\n\t    (struct qlt_plogi_ack_t *)e->u.new_sess.pla;\n\tuint8_t free_fcport = 0;\n\n\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t    \"%s %d %8phC enter\\n\",\n\t    __func__, __LINE__, e->u.new_sess.port_name);\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tfcport = qla2x00_find_fcport_by_wwpn(vha, e->u.new_sess.port_name, 1);\n\tif (fcport) {\n\t\tfcport->d_id = e->u.new_sess.id;\n\t\tif (pla) {\n\t\t\tfcport->fw_login_state = DSC_LS_PLOGI_PEND;\n\t\t\tmemcpy(fcport->node_name,\n\t\t\t    pla->iocb.u.isp24.u.plogi.node_name,\n\t\t\t    WWN_SIZE);\n\t\t\tqlt_plogi_ack_link(vha, pla, fcport, QLT_PLOGI_LINK_SAME_WWN);\n\t\t\t \n\t\t\tpla->ref_count--;\n\t\t}\n\t} else {\n\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\tfcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\n\t\tif (fcport) {\n\t\t\tfcport->d_id = e->u.new_sess.id;\n\t\t\tfcport->flags |= FCF_FABRIC_DEVICE;\n\t\t\tfcport->fw_login_state = DSC_LS_PLOGI_PEND;\n\t\t\tfcport->tgt_short_link_down_cnt = 0;\n\n\t\t\tmemcpy(fcport->port_name, e->u.new_sess.port_name,\n\t\t\t    WWN_SIZE);\n\n\t\t\tfcport->fc4_type = e->u.new_sess.fc4_type;\n\t\t\tif (NVME_PRIORITY(vha->hw, fcport))\n\t\t\t\tfcport->do_prli_nvme = 1;\n\t\t\telse\n\t\t\t\tfcport->do_prli_nvme = 0;\n\n\t\t\tif (e->u.new_sess.fc4_type & FS_FCP_IS_N2N) {\n\t\t\t\tfcport->dm_login_expire = jiffies +\n\t\t\t\t\tQLA_N2N_WAIT_TIME * HZ;\n\t\t\t\tfcport->fc4_type = FS_FC4TYPE_FCP;\n\t\t\t\tfcport->n2n_flag = 1;\n\t\t\t\tif (vha->flags.nvme_enabled)\n\t\t\t\t\tfcport->fc4_type |= FS_FC4TYPE_NVME;\n\t\t\t}\n\n\t\t} else {\n\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t\t   \"%s %8phC mem alloc fail.\\n\",\n\t\t\t\t   __func__, e->u.new_sess.port_name);\n\n\t\t\tif (pla) {\n\t\t\t\tlist_del(&pla->list);\n\t\t\t\tkmem_cache_free(qla_tgt_plogi_cachep, pla);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t \n\t\ttfcp = qla2x00_find_fcport_by_wwpn(vha,\n\t\t    e->u.new_sess.port_name, 1);\n\t\tif (tfcp) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t    \"%s %8phC found existing fcport b4 add. DS %d LS %d\\n\",\n\t\t\t    __func__, tfcp->port_name, tfcp->disc_state,\n\t\t\t    tfcp->fw_login_state);\n\n\t\t\tfree_fcport = 1;\n\t\t} else {\n\t\t\tlist_add_tail(&fcport->list, &vha->vp_fcports);\n\n\t\t}\n\t\tif (pla) {\n\t\t\tqlt_plogi_ack_link(vha, pla, fcport,\n\t\t\t    QLT_PLOGI_LINK_SAME_WWN);\n\t\t\tpla->ref_count--;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\tif (fcport) {\n\t\tfcport->id_changed = 1;\n\t\tfcport->scan_state = QLA_FCPORT_FOUND;\n\t\tfcport->chip_reset = vha->hw->base_qpair->chip_reset;\n\t\tmemcpy(fcport->node_name, e->u.new_sess.node_name, WWN_SIZE);\n\n\t\tif (pla) {\n\t\t\tif (pla->iocb.u.isp24.status_subcode == ELS_PRLI) {\n\t\t\t\tu16 wd3_lo;\n\n\t\t\t\tfcport->fw_login_state = DSC_LS_PRLI_PEND;\n\t\t\t\tfcport->local = 0;\n\t\t\t\tfcport->loop_id =\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\t    pla->iocb.u.isp24.nport_handle);\n\t\t\t\tfcport->fw_login_state = DSC_LS_PRLI_PEND;\n\t\t\t\twd3_lo =\n\t\t\t\t    le16_to_cpu(\n\t\t\t\t\tpla->iocb.u.isp24.u.prli.wd3_lo);\n\n\t\t\t\tif (wd3_lo & BIT_7)\n\t\t\t\t\tfcport->conf_compl_supported = 1;\n\n\t\t\t\tif ((wd3_lo & BIT_4) == 0)\n\t\t\t\t\tfcport->port_type = FCT_INITIATOR;\n\t\t\t\telse\n\t\t\t\t\tfcport->port_type = FCT_TARGET;\n\t\t\t}\n\t\t\tqlt_plogi_ack_unref(vha, pla);\n\t\t} else {\n\t\t\tfc_port_t *dfcp = NULL;\n\n\t\t\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\t\t\ttfcp = qla2x00_find_fcport_by_nportid(vha,\n\t\t\t    &e->u.new_sess.id, 1);\n\t\t\tif (tfcp && (tfcp != fcport)) {\n\t\t\t\t \n\t\t\t\tql_dbg(ql_dbg_disc, vha, 0xffff,\n\t\t\t\t    \"%s %8phC found conflict b4 add. DS %d LS %d\\n\",\n\t\t\t\t    __func__, tfcp->port_name, tfcp->disc_state,\n\t\t\t\t    tfcp->fw_login_state);\n\n\t\t\t\tswitch (tfcp->disc_state) {\n\t\t\t\tcase DSC_DELETED:\n\t\t\t\t\tbreak;\n\t\t\t\tcase DSC_DELETE_PEND:\n\t\t\t\t\tfcport->login_pause = 1;\n\t\t\t\t\ttfcp->conflict = fcport;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfcport->login_pause = 1;\n\t\t\t\t\ttfcp->conflict = fcport;\n\t\t\t\t\tdfcp = tfcp;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\t\t\tif (dfcp)\n\t\t\t\tqlt_schedule_sess_for_deletion(tfcp);\n\n\t\t\tif (N2N_TOPO(vha->hw)) {\n\t\t\t\tfcport->flags &= ~FCF_FABRIC_DEVICE;\n\t\t\t\tfcport->keep_nport_handle = 1;\n\t\t\t\tif (vha->flags.nvme_enabled) {\n\t\t\t\t\tfcport->fc4_type =\n\t\t\t\t\t    (FS_FC4TYPE_NVME | FS_FC4TYPE_FCP);\n\t\t\t\t\tfcport->n2n_flag = 1;\n\t\t\t\t}\n\t\t\t\tfcport->fw_login_state = 0;\n\n\t\t\t\tschedule_delayed_work(&vha->scan.scan_work, 5);\n\t\t\t} else {\n\t\t\t\tqla24xx_fcport_handle_login(vha, fcport);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (free_fcport) {\n\t\tqla2x00_free_fcport(fcport);\n\t\tif (pla) {\n\t\t\tlist_del(&pla->list);\n\t\t\tkmem_cache_free(qla_tgt_plogi_cachep, pla);\n\t\t}\n\t}\n}\n\nstatic void qla_sp_retry(struct scsi_qla_host *vha, struct qla_work_evt *e)\n{\n\tstruct srb *sp = e->u.iosb.sp;\n\tint rval;\n\n\trval = qla2x00_start_sp(sp);\n\tif (rval != QLA_SUCCESS) {\n\t\tql_dbg(ql_dbg_disc, vha, 0x2043,\n\t\t    \"%s: %s: Re-issue IOCB failed (%d).\\n\",\n\t\t    __func__, sp->name, rval);\n\t\tqla24xx_sp_unmap(vha, sp);\n\t}\n}\n\nvoid\nqla2x00_do_work(struct scsi_qla_host *vha)\n{\n\tstruct qla_work_evt *e, *tmp;\n\tunsigned long flags;\n\tLIST_HEAD(work);\n\tint rc;\n\n\tspin_lock_irqsave(&vha->work_lock, flags);\n\tlist_splice_init(&vha->work_list, &work);\n\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\n\tlist_for_each_entry_safe(e, tmp, &work, list) {\n\t\trc = QLA_SUCCESS;\n\t\tswitch (e->type) {\n\t\tcase QLA_EVT_AEN:\n\t\t\tfc_host_post_event(vha->host, fc_get_event_number(),\n\t\t\t    e->u.aen.code, e->u.aen.data);\n\t\t\tbreak;\n\t\tcase QLA_EVT_IDC_ACK:\n\t\t\tqla81xx_idc_ack(vha, e->u.idc_ack.mb);\n\t\t\tbreak;\n\t\tcase QLA_EVT_ASYNC_LOGIN:\n\t\t\tqla2x00_async_login(vha, e->u.logio.fcport,\n\t\t\t    e->u.logio.data);\n\t\t\tbreak;\n\t\tcase QLA_EVT_ASYNC_LOGOUT:\n\t\t\trc = qla2x00_async_logout(vha, e->u.logio.fcport);\n\t\t\tbreak;\n\t\tcase QLA_EVT_ASYNC_ADISC:\n\t\t\tqla2x00_async_adisc(vha, e->u.logio.fcport,\n\t\t\t    e->u.logio.data);\n\t\t\tbreak;\n\t\tcase QLA_EVT_UEVENT:\n\t\t\tqla2x00_uevent_emit(vha, e->u.uevent.code);\n\t\t\tbreak;\n\t\tcase QLA_EVT_AENFX:\n\t\t\tqlafx00_process_aen(vha, e);\n\t\t\tbreak;\n\t\tcase QLA_EVT_UNMAP:\n\t\t\tqla24xx_sp_unmap(vha, e->u.iosb.sp);\n\t\t\tbreak;\n\t\tcase QLA_EVT_RELOGIN:\n\t\t\tqla2x00_relogin(vha);\n\t\t\tbreak;\n\t\tcase QLA_EVT_NEW_SESS:\n\t\t\tqla24xx_create_new_sess(vha, e);\n\t\t\tbreak;\n\t\tcase QLA_EVT_GPDB:\n\t\t\tqla24xx_async_gpdb(vha, e->u.fcport.fcport,\n\t\t\t    e->u.fcport.opt);\n\t\t\tbreak;\n\t\tcase QLA_EVT_PRLI:\n\t\t\tqla24xx_async_prli(vha, e->u.fcport.fcport);\n\t\t\tbreak;\n\t\tcase QLA_EVT_GPSC:\n\t\t\tqla24xx_async_gpsc(vha, e->u.fcport.fcport);\n\t\t\tbreak;\n\t\tcase QLA_EVT_GNL:\n\t\t\tqla24xx_async_gnl(vha, e->u.fcport.fcport);\n\t\t\tbreak;\n\t\tcase QLA_EVT_NACK:\n\t\t\tqla24xx_do_nack_work(vha, e);\n\t\t\tbreak;\n\t\tcase QLA_EVT_ASYNC_PRLO:\n\t\t\trc = qla2x00_async_prlo(vha, e->u.logio.fcport);\n\t\t\tbreak;\n\t\tcase QLA_EVT_ASYNC_PRLO_DONE:\n\t\t\tqla2x00_async_prlo_done(vha, e->u.logio.fcport,\n\t\t\t    e->u.logio.data);\n\t\t\tbreak;\n\t\tcase QLA_EVT_GPNFT:\n\t\t\tqla24xx_async_gpnft(vha, e->u.gpnft.fc4_type,\n\t\t\t    e->u.gpnft.sp);\n\t\t\tbreak;\n\t\tcase QLA_EVT_GPNFT_DONE:\n\t\t\tqla24xx_async_gpnft_done(vha, e->u.iosb.sp);\n\t\t\tbreak;\n\t\tcase QLA_EVT_GNNFT_DONE:\n\t\t\tqla24xx_async_gnnft_done(vha, e->u.iosb.sp);\n\t\t\tbreak;\n\t\tcase QLA_EVT_GFPNID:\n\t\t\tqla24xx_async_gfpnid(vha, e->u.fcport.fcport);\n\t\t\tbreak;\n\t\tcase QLA_EVT_SP_RETRY:\n\t\t\tqla_sp_retry(vha, e);\n\t\t\tbreak;\n\t\tcase QLA_EVT_IIDMA:\n\t\t\tqla_do_iidma_work(vha, e->u.fcport.fcport);\n\t\t\tbreak;\n\t\tcase QLA_EVT_ELS_PLOGI:\n\t\t\tqla24xx_els_dcmd2_iocb(vha, ELS_DCMD_PLOGI,\n\t\t\t    e->u.fcport.fcport, false);\n\t\t\tbreak;\n\t\tcase QLA_EVT_SA_REPLACE:\n\t\t\trc = qla24xx_issue_sa_replace_iocb(vha, e);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rc == EAGAIN) {\n\t\t\t \n\t\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\t\tlist_splice(&work, &vha->work_list);\n\t\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&e->list);\n\t\tif (e->flags & QLA_EVT_FLAG_FREE)\n\t\t\tkfree(e);\n\n\t\t \n\t\tQLA_VHA_MARK_NOT_BUSY(vha);\n\t}\n}\n\nint qla24xx_post_relogin_work(struct scsi_qla_host *vha)\n{\n\tstruct qla_work_evt *e;\n\n\te = qla2x00_alloc_work(vha, QLA_EVT_RELOGIN);\n\n\tif (!e) {\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\treturn qla2x00_post_work(vha, e);\n}\n\n \nvoid qla2x00_relogin(struct scsi_qla_host *vha)\n{\n\tfc_port_t       *fcport;\n\tint status, relogin_needed = 0;\n\tstruct event_arg ea;\n\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\t \n\t\tif (atomic_read(&fcport->state) != FCS_ONLINE &&\n\t\t    fcport->login_retry) {\n\t\t\tif (fcport->scan_state != QLA_FCPORT_FOUND ||\n\t\t\t    fcport->disc_state == DSC_LOGIN_AUTH_PEND ||\n\t\t\t    fcport->disc_state == DSC_LOGIN_COMPLETE)\n\t\t\t\tcontinue;\n\n\t\t\tif (fcport->flags & (FCF_ASYNC_SENT|FCF_ASYNC_ACTIVE) ||\n\t\t\t\tfcport->disc_state == DSC_DELETE_PEND) {\n\t\t\t\trelogin_needed = 1;\n\t\t\t} else {\n\t\t\t\tif (vha->hw->current_topology != ISP_CFG_NL) {\n\t\t\t\t\tmemset(&ea, 0, sizeof(ea));\n\t\t\t\t\tea.fcport = fcport;\n\t\t\t\t\tqla24xx_handle_relogin_event(vha, &ea);\n\t\t\t\t} else if (vha->hw->current_topology ==\n\t\t\t\t\t ISP_CFG_NL &&\n\t\t\t\t\tIS_QLA2XXX_MIDTYPE(vha->hw)) {\n\t\t\t\t\t(void)qla24xx_fcport_handle_login(vha,\n\t\t\t\t\t\t\t\t\tfcport);\n\t\t\t\t} else if (vha->hw->current_topology ==\n\t\t\t\t    ISP_CFG_NL) {\n\t\t\t\t\tfcport->login_retry--;\n\t\t\t\t\tstatus =\n\t\t\t\t\t    qla2x00_local_device_login(vha,\n\t\t\t\t\t\tfcport);\n\t\t\t\t\tif (status == QLA_SUCCESS) {\n\t\t\t\t\t\tfcport->old_loop_id =\n\t\t\t\t\t\t    fcport->loop_id;\n\t\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2003,\n\t\t\t\t\t\t    \"Port login OK: logged in ID 0x%x.\\n\",\n\t\t\t\t\t\t    fcport->loop_id);\n\t\t\t\t\t\tqla2x00_update_fcport\n\t\t\t\t\t\t\t(vha, fcport);\n\t\t\t\t\t} else if (status == 1) {\n\t\t\t\t\t\tset_bit(RELOGIN_NEEDED,\n\t\t\t\t\t\t    &vha->dpc_flags);\n\t\t\t\t\t\t \n\t\t\t\t\t\tql_dbg(ql_dbg_disc, vha, 0x2007,\n\t\t\t\t\t\t    \"Retrying %d login again loop_id 0x%x.\\n\",\n\t\t\t\t\t\t    fcport->login_retry,\n\t\t\t\t\t\t    fcport->loop_id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfcport->login_retry = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fcport->login_retry == 0 &&\n\t\t\t\t\t    status != QLA_SUCCESS)\n\t\t\t\t\t\tqla2x00_clear_loop_id(fcport);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\n\t\t\tbreak;\n\t}\n\n\tif (relogin_needed)\n\t\tset_bit(RELOGIN_NEEDED, &vha->dpc_flags);\n\n\tql_dbg(ql_dbg_disc, vha, 0x400e,\n\t    \"Relogin end.\\n\");\n}\n\n \nvoid\nqla83xx_schedule_work(scsi_qla_host_t *base_vha, int work_code)\n{\n\tstruct qla_hw_data *ha = base_vha->hw;\n\n\tswitch (work_code) {\n\tcase MBA_IDC_AEN:  \n\t\tif (ha->dpc_lp_wq)\n\t\t\tqueue_work(ha->dpc_lp_wq, &ha->idc_aen);\n\t\tbreak;\n\n\tcase QLA83XX_NIC_CORE_RESET:  \n\t\tif (!ha->flags.nic_core_reset_hdlr_active) {\n\t\t\tif (ha->dpc_hp_wq)\n\t\t\t\tqueue_work(ha->dpc_hp_wq, &ha->nic_core_reset);\n\t\t} else\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb05e,\n\t\t\t    \"NIC Core reset is already active. Skip \"\n\t\t\t    \"scheduling it again.\\n\");\n\t\tbreak;\n\tcase QLA83XX_IDC_STATE_HANDLER:  \n\t\tif (ha->dpc_hp_wq)\n\t\t\tqueue_work(ha->dpc_hp_wq, &ha->idc_state_handler);\n\t\tbreak;\n\tcase QLA83XX_NIC_CORE_UNRECOVERABLE:  \n\t\tif (ha->dpc_hp_wq)\n\t\t\tqueue_work(ha->dpc_hp_wq, &ha->nic_core_unrecoverable);\n\t\tbreak;\n\tdefault:\n\t\tql_log(ql_log_warn, base_vha, 0xb05f,\n\t\t    \"Unknown work-code=0x%x.\\n\", work_code);\n\t}\n\n\treturn;\n}\n\n \nvoid\nqla83xx_nic_core_unrecoverable_work(struct work_struct *work)\n{\n\tstruct qla_hw_data *ha =\n\t\tcontainer_of(work, struct qla_hw_data, nic_core_unrecoverable);\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tuint32_t dev_state = 0;\n\n\tqla83xx_idc_lock(base_vha, 0);\n\tqla83xx_rd_reg(base_vha, QLA83XX_IDC_DEV_STATE, &dev_state);\n\tqla83xx_reset_ownership(base_vha);\n\tif (ha->flags.nic_core_reset_owner) {\n\t\tha->flags.nic_core_reset_owner = 0;\n\t\tqla83xx_wr_reg(base_vha, QLA83XX_IDC_DEV_STATE,\n\t\t    QLA8XXX_DEV_FAILED);\n\t\tql_log(ql_log_info, base_vha, 0xb060, \"HW State: FAILED.\\n\");\n\t\tqla83xx_schedule_work(base_vha, QLA83XX_IDC_STATE_HANDLER);\n\t}\n\tqla83xx_idc_unlock(base_vha, 0);\n}\n\n \nvoid\nqla83xx_idc_state_handler_work(struct work_struct *work)\n{\n\tstruct qla_hw_data *ha =\n\t\tcontainer_of(work, struct qla_hw_data, idc_state_handler);\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tuint32_t dev_state = 0;\n\n\tqla83xx_idc_lock(base_vha, 0);\n\tqla83xx_rd_reg(base_vha, QLA83XX_IDC_DEV_STATE, &dev_state);\n\tif (dev_state == QLA8XXX_DEV_FAILED ||\n\t\t\tdev_state == QLA8XXX_DEV_NEED_QUIESCENT)\n\t\tqla83xx_idc_state_handler(base_vha);\n\tqla83xx_idc_unlock(base_vha, 0);\n}\n\nstatic int\nqla83xx_check_nic_core_fw_alive(scsi_qla_host_t *base_vha)\n{\n\tint rval = QLA_SUCCESS;\n\tunsigned long heart_beat_wait = jiffies + (1 * HZ);\n\tuint32_t heart_beat_counter1, heart_beat_counter2;\n\n\tdo {\n\t\tif (time_after(jiffies, heart_beat_wait)) {\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb07c,\n\t\t\t    \"Nic Core f/w is not alive.\\n\");\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\tqla83xx_idc_lock(base_vha, 0);\n\t\tqla83xx_rd_reg(base_vha, QLA83XX_FW_HEARTBEAT,\n\t\t    &heart_beat_counter1);\n\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\tmsleep(100);\n\t\tqla83xx_idc_lock(base_vha, 0);\n\t\tqla83xx_rd_reg(base_vha, QLA83XX_FW_HEARTBEAT,\n\t\t    &heart_beat_counter2);\n\t\tqla83xx_idc_unlock(base_vha, 0);\n\t} while (heart_beat_counter1 == heart_beat_counter2);\n\n\treturn rval;\n}\n\n \nvoid\nqla83xx_nic_core_reset_work(struct work_struct *work)\n{\n\tstruct qla_hw_data *ha =\n\t\tcontainer_of(work, struct qla_hw_data, nic_core_reset);\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tuint32_t dev_state = 0;\n\n\tif (IS_QLA2031(ha)) {\n\t\tif (qla2xxx_mctp_dump(base_vha) != QLA_SUCCESS)\n\t\t\tql_log(ql_log_warn, base_vha, 0xb081,\n\t\t\t    \"Failed to dump mctp\\n\");\n\t\treturn;\n\t}\n\n\tif (!ha->flags.nic_core_reset_hdlr_active) {\n\t\tif (qla83xx_check_nic_core_fw_alive(base_vha) == QLA_SUCCESS) {\n\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\tqla83xx_rd_reg(base_vha, QLA83XX_IDC_DEV_STATE,\n\t\t\t    &dev_state);\n\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\tif (dev_state != QLA8XXX_DEV_NEED_RESET) {\n\t\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb07a,\n\t\t\t\t    \"Nic Core f/w is alive.\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tha->flags.nic_core_reset_hdlr_active = 1;\n\t\tif (qla83xx_nic_core_reset(base_vha)) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb061,\n\t\t\t    \"NIC Core reset failed.\\n\");\n\t\t}\n\t\tha->flags.nic_core_reset_hdlr_active = 0;\n\t}\n}\n\n \nvoid\nqla83xx_service_idc_aen(struct work_struct *work)\n{\n\tstruct qla_hw_data *ha =\n\t\tcontainer_of(work, struct qla_hw_data, idc_aen);\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tuint32_t dev_state, idc_control;\n\n\tqla83xx_idc_lock(base_vha, 0);\n\tqla83xx_rd_reg(base_vha, QLA83XX_IDC_DEV_STATE, &dev_state);\n\tqla83xx_rd_reg(base_vha, QLA83XX_IDC_CONTROL, &idc_control);\n\tqla83xx_idc_unlock(base_vha, 0);\n\tif (dev_state == QLA8XXX_DEV_NEED_RESET) {\n\t\tif (idc_control & QLA83XX_IDC_GRACEFUL_RESET) {\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb062,\n\t\t\t    \"Application requested NIC Core Reset.\\n\");\n\t\t\tqla83xx_schedule_work(base_vha, QLA83XX_NIC_CORE_RESET);\n\t\t} else if (qla83xx_check_nic_core_fw_alive(base_vha) ==\n\t\t    QLA_SUCCESS) {\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb07b,\n\t\t\t    \"Other protocol driver requested NIC Core Reset.\\n\");\n\t\t\tqla83xx_schedule_work(base_vha, QLA83XX_NIC_CORE_RESET);\n\t\t}\n\t} else if (dev_state == QLA8XXX_DEV_FAILED ||\n\t\t\tdev_state == QLA8XXX_DEV_NEED_QUIESCENT) {\n\t\tqla83xx_schedule_work(base_vha, QLA83XX_IDC_STATE_HANDLER);\n\t}\n}\n\n \n#define QLA83XX_WAIT_LOGIC_MS\t100\n\nstatic int\nqla83xx_force_lock_recovery(scsi_qla_host_t *base_vha)\n{\n\tint rval;\n\tuint32_t data;\n\tuint32_t idc_lck_rcvry_stage_mask = 0x3;\n\tuint32_t idc_lck_rcvry_owner_mask = 0x3c;\n\tstruct qla_hw_data *ha = base_vha->hw;\n\n\tql_dbg(ql_dbg_p3p, base_vha, 0xb086,\n\t    \"Trying force recovery of the IDC lock.\\n\");\n\n\trval = qla83xx_rd_reg(base_vha, QLA83XX_IDC_LOCK_RECOVERY, &data);\n\tif (rval)\n\t\treturn rval;\n\n\tif ((data & idc_lck_rcvry_stage_mask) > 0) {\n\t\treturn QLA_SUCCESS;\n\t} else {\n\t\tdata = (IDC_LOCK_RECOVERY_STAGE1) | (ha->portnum << 2);\n\t\trval = qla83xx_wr_reg(base_vha, QLA83XX_IDC_LOCK_RECOVERY,\n\t\t    data);\n\t\tif (rval)\n\t\t\treturn rval;\n\n\t\tmsleep(200);\n\n\t\trval = qla83xx_rd_reg(base_vha, QLA83XX_IDC_LOCK_RECOVERY,\n\t\t    &data);\n\t\tif (rval)\n\t\t\treturn rval;\n\n\t\tif (((data & idc_lck_rcvry_owner_mask) >> 2) == ha->portnum) {\n\t\t\tdata &= (IDC_LOCK_RECOVERY_STAGE2 |\n\t\t\t\t\t~(idc_lck_rcvry_stage_mask));\n\t\t\trval = qla83xx_wr_reg(base_vha,\n\t\t\t    QLA83XX_IDC_LOCK_RECOVERY, data);\n\t\t\tif (rval)\n\t\t\t\treturn rval;\n\n\t\t\t \n\t\t\trval = qla83xx_rd_reg(base_vha, QLA83XX_DRIVER_UNLOCK,\n\t\t\t    &data);\n\t\t\tif (rval)\n\t\t\t\treturn rval;\n\t\t\t \n\t\t\trval = qla83xx_wr_reg(base_vha, QLA83XX_DRIVER_LOCKID,\n\t\t\t    0xff);\n\t\t\tif (rval)\n\t\t\t\treturn rval;\n\t\t\t \n\t\t\trval = qla83xx_wr_reg(base_vha,\n\t\t\t    QLA83XX_IDC_LOCK_RECOVERY, 0x0);\n\t\t\tif (rval)\n\t\t\t\treturn rval;\n\t\t} else\n\t\t\treturn QLA_SUCCESS;\n\t}\n\n\treturn rval;\n}\n\nstatic int\nqla83xx_idc_lock_recovery(scsi_qla_host_t *base_vha)\n{\n\tint rval = QLA_SUCCESS;\n\tuint32_t o_drv_lockid, n_drv_lockid;\n\tunsigned long lock_recovery_timeout;\n\n\tlock_recovery_timeout = jiffies + QLA83XX_MAX_LOCK_RECOVERY_WAIT;\nretry_lockid:\n\trval = qla83xx_rd_reg(base_vha, QLA83XX_DRIVER_LOCKID, &o_drv_lockid);\n\tif (rval)\n\t\tgoto exit;\n\n\t \n\tif (time_after_eq(jiffies, lock_recovery_timeout)) {\n\t\tif (qla83xx_force_lock_recovery(base_vha) == QLA_SUCCESS)\n\t\t\treturn QLA_SUCCESS;\n\t\telse\n\t\t\treturn QLA_FUNCTION_FAILED;\n\t}\n\n\trval = qla83xx_rd_reg(base_vha, QLA83XX_DRIVER_LOCKID, &n_drv_lockid);\n\tif (rval)\n\t\tgoto exit;\n\n\tif (o_drv_lockid == n_drv_lockid) {\n\t\tmsleep(QLA83XX_WAIT_LOGIC_MS);\n\t\tgoto retry_lockid;\n\t} else\n\t\treturn QLA_SUCCESS;\n\nexit:\n\treturn rval;\n}\n\n \nvoid\nqla83xx_idc_lock(scsi_qla_host_t *base_vha, uint16_t requester_id)\n{\n\tuint32_t data;\n\tuint32_t lock_owner;\n\tstruct qla_hw_data *ha = base_vha->hw;\n\n\tmight_sleep();\n\n\t \nretry_lock:\n\tif (qla83xx_rd_reg(base_vha, QLA83XX_DRIVER_LOCK, &data)\n\t    == QLA_SUCCESS) {\n\t\tif (data) {\n\t\t\t \n\t\t\tqla83xx_wr_reg(base_vha, QLA83XX_DRIVER_LOCKID,\n\t\t\t    ha->portnum);\n\t\t} else {\n\t\t\tqla83xx_rd_reg(base_vha, QLA83XX_DRIVER_LOCKID,\n\t\t\t    &lock_owner);\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb063,\n\t\t\t    \"Failed to acquire IDC lock, acquired by %d, \"\n\t\t\t    \"retrying...\\n\", lock_owner);\n\n\t\t\t \n\t\t\tif (qla83xx_idc_lock_recovery(base_vha)\n\t\t\t    == QLA_SUCCESS) {\n\t\t\t\tmsleep(QLA83XX_WAIT_LOGIC_MS);\n\t\t\t\tgoto retry_lock;\n\t\t\t} else\n\t\t\t\tql_log(ql_log_warn, base_vha, 0xb075,\n\t\t\t\t    \"IDC Lock recovery FAILED.\\n\");\n\t\t}\n\n\t}\n\n\treturn;\n}\n\nstatic bool\nqla25xx_rdp_rsp_reduce_size(struct scsi_qla_host *vha,\n\tstruct purex_entry_24xx *purex)\n{\n\tchar fwstr[16];\n\tu32 sid = purex->s_id[2] << 16 | purex->s_id[1] << 8 | purex->s_id[0];\n\tstruct port_database_24xx *pdb;\n\n\t \n\t \n\tif (sid != 0xfffc01)\n\t\treturn false;\n\n\tql_dbg(ql_dbg_init, vha, 0x0181, \"%s: s_id=%#x\\n\", __func__, sid);\n\n\tpdb = kzalloc(sizeof(*pdb), GFP_KERNEL);\n\tif (!pdb) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0181,\n\t\t    \"%s: Failed allocate pdb\\n\", __func__);\n\t} else if (qla24xx_get_port_database(vha,\n\t\t\t\tle16_to_cpu(purex->nport_handle), pdb)) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0181,\n\t\t    \"%s: Failed get pdb sid=%x\\n\", __func__, sid);\n\t} else if (pdb->current_login_state != PDS_PLOGI_COMPLETE &&\n\t    pdb->current_login_state != PDS_PRLI_COMPLETE) {\n\t\tql_dbg(ql_dbg_init, vha, 0x0181,\n\t\t    \"%s: Port not logged in sid=%#x\\n\", __func__, sid);\n\t} else {\n\t\t \n\t\tkfree(pdb);\n\t\treturn false;\n\t}\n\tkfree(pdb);\n\n\tvha->hw->isp_ops->fw_version_str(vha, fwstr, sizeof(fwstr));\n\tfwstr[strcspn(fwstr, \" \")] = 0;\n\t \n\tif (strcmp(fwstr, \"8.09.00\") > 0 || strcmp(fwstr, \"8.05.65\") == 0)\n\t\treturn false;\n\n\tql_dbg(ql_dbg_init, vha, 0x0181, \"%s: fw=%s\\n\", __func__, fwstr);\n\n\t \n\treturn true;\n}\n\n \nvoid qla24xx_process_purex_rdp(struct scsi_qla_host *vha,\n\t\t\t       struct purex_item *item)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct purex_entry_24xx *purex =\n\t    (struct purex_entry_24xx *)&item->iocb;\n\tdma_addr_t rsp_els_dma;\n\tdma_addr_t rsp_payload_dma;\n\tdma_addr_t stat_dma;\n\tdma_addr_t sfp_dma;\n\tstruct els_entry_24xx *rsp_els = NULL;\n\tstruct rdp_rsp_payload *rsp_payload = NULL;\n\tstruct link_statistics *stat = NULL;\n\tuint8_t *sfp = NULL;\n\tuint16_t sfp_flags = 0;\n\tuint rsp_payload_length = sizeof(*rsp_payload);\n\tint rval;\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0180,\n\t    \"%s: Enter\\n\", __func__);\n\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0181,\n\t    \"-------- ELS REQ -------\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0182,\n\t    purex, sizeof(*purex));\n\n\tif (qla25xx_rdp_rsp_reduce_size(vha, purex)) {\n\t\trsp_payload_length =\n\t\t    offsetof(typeof(*rsp_payload), optical_elmt_desc);\n\t\tql_dbg(ql_dbg_init, vha, 0x0181,\n\t\t    \"Reducing RSP payload length to %u bytes...\\n\",\n\t\t    rsp_payload_length);\n\t}\n\n\trsp_els = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_els),\n\t    &rsp_els_dma, GFP_KERNEL);\n\tif (!rsp_els) {\n\t\tql_log(ql_log_warn, vha, 0x0183,\n\t\t    \"Failed allocate dma buffer ELS RSP.\\n\");\n\t\tgoto dealloc;\n\t}\n\n\trsp_payload = dma_alloc_coherent(&ha->pdev->dev, sizeof(*rsp_payload),\n\t    &rsp_payload_dma, GFP_KERNEL);\n\tif (!rsp_payload) {\n\t\tql_log(ql_log_warn, vha, 0x0184,\n\t\t    \"Failed allocate dma buffer ELS RSP payload.\\n\");\n\t\tgoto dealloc;\n\t}\n\n\tsfp = dma_alloc_coherent(&ha->pdev->dev, SFP_RTDI_LEN,\n\t    &sfp_dma, GFP_KERNEL);\n\n\tstat = dma_alloc_coherent(&ha->pdev->dev, sizeof(*stat),\n\t    &stat_dma, GFP_KERNEL);\n\n\t \n\trsp_els->entry_type = ELS_IOCB_TYPE;\n\trsp_els->entry_count = 1;\n\trsp_els->sys_define = 0;\n\trsp_els->entry_status = 0;\n\trsp_els->handle = 0;\n\trsp_els->nport_handle = purex->nport_handle;\n\trsp_els->tx_dsd_count = cpu_to_le16(1);\n\trsp_els->vp_index = purex->vp_idx;\n\trsp_els->sof_type = EST_SOFI3;\n\trsp_els->rx_xchg_address = purex->rx_xchg_addr;\n\trsp_els->rx_dsd_count = 0;\n\trsp_els->opcode = purex->els_frame_payload[0];\n\n\trsp_els->d_id[0] = purex->s_id[0];\n\trsp_els->d_id[1] = purex->s_id[1];\n\trsp_els->d_id[2] = purex->s_id[2];\n\n\trsp_els->control_flags = cpu_to_le16(EPD_ELS_ACC);\n\trsp_els->rx_byte_count = 0;\n\trsp_els->tx_byte_count = cpu_to_le32(rsp_payload_length);\n\n\tput_unaligned_le64(rsp_payload_dma, &rsp_els->tx_address);\n\trsp_els->tx_len = rsp_els->tx_byte_count;\n\n\trsp_els->rx_address = 0;\n\trsp_els->rx_len = 0;\n\n\t \n\trsp_payload->hdr.cmd = cpu_to_be32(0x2 << 24);  \n\trsp_payload->hdr.len = cpu_to_be32(le32_to_cpu(rsp_els->tx_byte_count) -\n\t\t\t\t\t   sizeof(rsp_payload->hdr));\n\n\t \n\trsp_payload->ls_req_info_desc.desc_tag = cpu_to_be32(0x1);\n\trsp_payload->ls_req_info_desc.desc_len =\n\t    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc));\n\trsp_payload->ls_req_info_desc.req_payload_word_0 =\n\t    cpu_to_be32p((uint32_t *)purex->els_frame_payload);\n\n\t \n\trsp_payload->ls_req_info_desc2.desc_tag = cpu_to_be32(0x1);\n\trsp_payload->ls_req_info_desc2.desc_len =\n\t    cpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_req_info_desc2));\n\trsp_payload->ls_req_info_desc2.req_payload_word_0 =\n\t    cpu_to_be32p((uint32_t *)purex->els_frame_payload);\n\n\n\trsp_payload->sfp_diag_desc.desc_tag = cpu_to_be32(0x10000);\n\trsp_payload->sfp_diag_desc.desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(rsp_payload->sfp_diag_desc));\n\n\tif (sfp) {\n\t\t \n\t\tmemset(sfp, 0, SFP_RTDI_LEN);\n\t\trval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x7, 2, 0);\n\t\tif (!rval) {\n\t\t\t \n\t\t\tif (sfp[0] & BIT_2 || sfp[1] & (BIT_6|BIT_5))\n\t\t\t\tsfp_flags |= BIT_0;  \n\t\t\telse if (sfp[0] & BIT_1)\n\t\t\t\tsfp_flags |= BIT_1;  \n\t\t\telse if (sfp[1] & BIT_4)\n\t\t\t\tsfp_flags |= BIT_1|BIT_0;  \n\t\t}\n\n\t\t \n\t\tmemset(sfp, 0, SFP_RTDI_LEN);\n\t\trval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 0x0, 1, 0);\n\t\tif (!rval) {\n\t\t\tsfp_flags |= BIT_4;  \n\t\t\tif (sfp[0] == 0x3)\n\t\t\t\tsfp_flags |= BIT_6;  \n\t\t}\n\n\t\trsp_payload->sfp_diag_desc.sfp_flags = cpu_to_be16(sfp_flags);\n\n\t\t \n\t\tmemset(sfp, 0, SFP_RTDI_LEN);\n\t\trval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0x60, 10, 0);\n\t\tif (!rval) {\n\t\t\t__be16 *trx = (__force __be16 *)sfp;  \n\t\t\trsp_payload->sfp_diag_desc.temperature = trx[0];\n\t\t\trsp_payload->sfp_diag_desc.vcc = trx[1];\n\t\t\trsp_payload->sfp_diag_desc.tx_bias = trx[2];\n\t\t\trsp_payload->sfp_diag_desc.tx_power = trx[3];\n\t\t\trsp_payload->sfp_diag_desc.rx_power = trx[4];\n\t\t}\n\t}\n\n\t \n\trsp_payload->port_speed_desc.desc_tag = cpu_to_be32(0x10001);\n\trsp_payload->port_speed_desc.desc_len =\n\t    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_speed_desc));\n\trsp_payload->port_speed_desc.speed_capab = cpu_to_be16(\n\t    qla25xx_fdmi_port_speed_capability(ha));\n\trsp_payload->port_speed_desc.operating_speed = cpu_to_be16(\n\t    qla25xx_fdmi_port_speed_currently(ha));\n\n\t \n\trsp_payload->ls_err_desc.desc_tag = cpu_to_be32(0x10002);\n\trsp_payload->ls_err_desc.desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(rsp_payload->ls_err_desc));\n\n\tif (stat) {\n\t\trval = qla24xx_get_isp_stats(vha, stat, stat_dma, 0);\n\t\tif (!rval) {\n\t\t\trsp_payload->ls_err_desc.link_fail_cnt =\n\t\t\t    cpu_to_be32(le32_to_cpu(stat->link_fail_cnt));\n\t\t\trsp_payload->ls_err_desc.loss_sync_cnt =\n\t\t\t    cpu_to_be32(le32_to_cpu(stat->loss_sync_cnt));\n\t\t\trsp_payload->ls_err_desc.loss_sig_cnt =\n\t\t\t    cpu_to_be32(le32_to_cpu(stat->loss_sig_cnt));\n\t\t\trsp_payload->ls_err_desc.prim_seq_err_cnt =\n\t\t\t    cpu_to_be32(le32_to_cpu(stat->prim_seq_err_cnt));\n\t\t\trsp_payload->ls_err_desc.inval_xmit_word_cnt =\n\t\t\t    cpu_to_be32(le32_to_cpu(stat->inval_xmit_word_cnt));\n\t\t\trsp_payload->ls_err_desc.inval_crc_cnt =\n\t\t\t    cpu_to_be32(le32_to_cpu(stat->inval_crc_cnt));\n\t\t\trsp_payload->ls_err_desc.pn_port_phy_type |= BIT_6;\n\t\t}\n\t}\n\n\t \n\trsp_payload->port_name_diag_desc.desc_tag = cpu_to_be32(0x10003);\n\trsp_payload->port_name_diag_desc.desc_len =\n\t    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_diag_desc));\n\tmemcpy(rsp_payload->port_name_diag_desc.WWNN,\n\t    vha->node_name,\n\t    sizeof(rsp_payload->port_name_diag_desc.WWNN));\n\tmemcpy(rsp_payload->port_name_diag_desc.WWPN,\n\t    vha->port_name,\n\t    sizeof(rsp_payload->port_name_diag_desc.WWPN));\n\n\t \n\trsp_payload->port_name_direct_desc.desc_tag = cpu_to_be32(0x10003);\n\trsp_payload->port_name_direct_desc.desc_len =\n\t    cpu_to_be32(RDP_DESC_LEN(rsp_payload->port_name_direct_desc));\n\tmemcpy(rsp_payload->port_name_direct_desc.WWNN,\n\t    vha->fabric_node_name,\n\t    sizeof(rsp_payload->port_name_direct_desc.WWNN));\n\tmemcpy(rsp_payload->port_name_direct_desc.WWPN,\n\t    vha->fabric_port_name,\n\t    sizeof(rsp_payload->port_name_direct_desc.WWPN));\n\n\t \n\trsp_payload->buffer_credit_desc.desc_tag = cpu_to_be32(0x10006);\n\trsp_payload->buffer_credit_desc.desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(rsp_payload->buffer_credit_desc));\n\trsp_payload->buffer_credit_desc.fcport_b2b = 0;\n\trsp_payload->buffer_credit_desc.attached_fcport_b2b = cpu_to_be32(0);\n\trsp_payload->buffer_credit_desc.fcport_rtt = cpu_to_be32(0);\n\n\tif (ha->flags.plogi_template_valid) {\n\t\tuint32_t tmp =\n\t\tbe16_to_cpu(ha->plogi_els_payld.fl_csp.sp_bb_cred);\n\t\trsp_payload->buffer_credit_desc.fcport_b2b = cpu_to_be32(tmp);\n\t}\n\n\tif (rsp_payload_length < sizeof(*rsp_payload))\n\t\tgoto send;\n\n\t \n\trsp_payload->optical_elmt_desc[0].desc_tag = cpu_to_be32(0x10007);\n\trsp_payload->optical_elmt_desc[0].desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));\n\t \n\trsp_payload->optical_elmt_desc[1].desc_tag = cpu_to_be32(0x10007);\n\trsp_payload->optical_elmt_desc[1].desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));\n\t \n\trsp_payload->optical_elmt_desc[2].desc_tag = cpu_to_be32(0x10007);\n\trsp_payload->optical_elmt_desc[2].desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));\n\t \n\trsp_payload->optical_elmt_desc[3].desc_tag = cpu_to_be32(0x10007);\n\trsp_payload->optical_elmt_desc[3].desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));\n\t \n\trsp_payload->optical_elmt_desc[4].desc_tag = cpu_to_be32(0x10007);\n\trsp_payload->optical_elmt_desc[4].desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(*rsp_payload->optical_elmt_desc));\n\n\tif (sfp) {\n\t\tmemset(sfp, 0, SFP_RTDI_LEN);\n\t\trval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 0, 64, 0);\n\t\tif (!rval) {\n\t\t\t__be16 *trx = (__force __be16 *)sfp;  \n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[0].high_alarm = trx[0];\n\t\t\trsp_payload->optical_elmt_desc[0].low_alarm = trx[1];\n\t\t\trsp_payload->optical_elmt_desc[0].high_warn = trx[2];\n\t\t\trsp_payload->optical_elmt_desc[0].low_warn = trx[3];\n\t\t\trsp_payload->optical_elmt_desc[0].element_flags =\n\t\t\t    cpu_to_be32(1 << 28);\n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[1].high_alarm = trx[4];\n\t\t\trsp_payload->optical_elmt_desc[1].low_alarm = trx[5];\n\t\t\trsp_payload->optical_elmt_desc[1].high_warn = trx[6];\n\t\t\trsp_payload->optical_elmt_desc[1].low_warn = trx[7];\n\t\t\trsp_payload->optical_elmt_desc[1].element_flags =\n\t\t\t    cpu_to_be32(2 << 28);\n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[2].high_alarm = trx[8];\n\t\t\trsp_payload->optical_elmt_desc[2].low_alarm = trx[9];\n\t\t\trsp_payload->optical_elmt_desc[2].high_warn = trx[10];\n\t\t\trsp_payload->optical_elmt_desc[2].low_warn = trx[11];\n\t\t\trsp_payload->optical_elmt_desc[2].element_flags =\n\t\t\t    cpu_to_be32(3 << 28);\n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[3].high_alarm = trx[12];\n\t\t\trsp_payload->optical_elmt_desc[3].low_alarm = trx[13];\n\t\t\trsp_payload->optical_elmt_desc[3].high_warn = trx[14];\n\t\t\trsp_payload->optical_elmt_desc[3].low_warn = trx[15];\n\t\t\trsp_payload->optical_elmt_desc[3].element_flags =\n\t\t\t    cpu_to_be32(4 << 28);\n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[4].high_alarm = trx[16];\n\t\t\trsp_payload->optical_elmt_desc[4].low_alarm = trx[17];\n\t\t\trsp_payload->optical_elmt_desc[4].high_warn = trx[18];\n\t\t\trsp_payload->optical_elmt_desc[4].low_warn = trx[19];\n\t\t\trsp_payload->optical_elmt_desc[4].element_flags =\n\t\t\t    cpu_to_be32(5 << 28);\n\t\t}\n\n\t\tmemset(sfp, 0, SFP_RTDI_LEN);\n\t\trval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa2, 112, 64, 0);\n\t\tif (!rval) {\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[0].element_flags |=\n\t\t\t    cpu_to_be32(\n\t\t\t\t(sfp[0] >> 7 & 1) << 3 |\n\t\t\t\t(sfp[0] >> 6 & 1) << 2 |\n\t\t\t\t(sfp[4] >> 7 & 1) << 1 |\n\t\t\t\t(sfp[4] >> 6 & 1) << 0);\n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[1].element_flags |=\n\t\t\t    cpu_to_be32(\n\t\t\t\t(sfp[0] >> 5 & 1) << 3 |\n\t\t\t\t(sfp[0] >> 4 & 1) << 2 |\n\t\t\t\t(sfp[4] >> 5 & 1) << 1 |\n\t\t\t\t(sfp[4] >> 4 & 1) << 0);\n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[2].element_flags |=\n\t\t\t    cpu_to_be32(\n\t\t\t\t(sfp[0] >> 3 & 1) << 3 |\n\t\t\t\t(sfp[0] >> 2 & 1) << 2 |\n\t\t\t\t(sfp[4] >> 3 & 1) << 1 |\n\t\t\t\t(sfp[4] >> 2 & 1) << 0);\n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[3].element_flags |=\n\t\t\t    cpu_to_be32(\n\t\t\t\t(sfp[0] >> 1 & 1) << 3 |\n\t\t\t\t(sfp[0] >> 0 & 1) << 2 |\n\t\t\t\t(sfp[4] >> 1 & 1) << 1 |\n\t\t\t\t(sfp[4] >> 0 & 1) << 0);\n\n\t\t\t \n\t\t\trsp_payload->optical_elmt_desc[4].element_flags |=\n\t\t\t    cpu_to_be32(\n\t\t\t\t(sfp[1] >> 7 & 1) << 3 |\n\t\t\t\t(sfp[1] >> 6 & 1) << 2 |\n\t\t\t\t(sfp[5] >> 7 & 1) << 1 |\n\t\t\t\t(sfp[5] >> 6 & 1) << 0);\n\t\t}\n\t}\n\n\t \n\trsp_payload->optical_prod_desc.desc_tag = cpu_to_be32(0x10008);\n\trsp_payload->optical_prod_desc.desc_len =\n\t\tcpu_to_be32(RDP_DESC_LEN(rsp_payload->optical_prod_desc));\n\n\tif (sfp) {\n\t\tmemset(sfp, 0, SFP_RTDI_LEN);\n\t\trval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 20, 64, 0);\n\t\tif (!rval) {\n\t\t\tmemcpy(rsp_payload->optical_prod_desc.vendor_name,\n\t\t\t    sfp + 0,\n\t\t\t    sizeof(rsp_payload->optical_prod_desc.vendor_name));\n\t\t\tmemcpy(rsp_payload->optical_prod_desc.part_number,\n\t\t\t    sfp + 20,\n\t\t\t    sizeof(rsp_payload->optical_prod_desc.part_number));\n\t\t\tmemcpy(rsp_payload->optical_prod_desc.revision,\n\t\t\t    sfp + 36,\n\t\t\t    sizeof(rsp_payload->optical_prod_desc.revision));\n\t\t\tmemcpy(rsp_payload->optical_prod_desc.serial_number,\n\t\t\t    sfp + 48,\n\t\t\t    sizeof(rsp_payload->optical_prod_desc.serial_number));\n\t\t}\n\n\t\tmemset(sfp, 0, SFP_RTDI_LEN);\n\t\trval = qla2x00_read_sfp(vha, sfp_dma, sfp, 0xa0, 84, 8, 0);\n\t\tif (!rval) {\n\t\t\tmemcpy(rsp_payload->optical_prod_desc.date,\n\t\t\t    sfp + 0,\n\t\t\t    sizeof(rsp_payload->optical_prod_desc.date));\n\t\t}\n\t}\n\nsend:\n\tql_dbg(ql_dbg_init, vha, 0x0183,\n\t    \"Sending ELS Response to RDP Request...\\n\");\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0184,\n\t    \"-------- ELS RSP -------\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0185,\n\t    rsp_els, sizeof(*rsp_els));\n\tql_dbg(ql_dbg_init + ql_dbg_verbose, vha, 0x0186,\n\t    \"-------- ELS RSP PAYLOAD -------\\n\");\n\tql_dump_buffer(ql_dbg_init + ql_dbg_verbose, vha, 0x0187,\n\t    rsp_payload, rsp_payload_length);\n\n\trval = qla2x00_issue_iocb(vha, rsp_els, rsp_els_dma, 0);\n\n\tif (rval) {\n\t\tql_log(ql_log_warn, vha, 0x0188,\n\t\t    \"%s: iocb failed to execute -> %x\\n\", __func__, rval);\n\t} else if (rsp_els->comp_status) {\n\t\tql_log(ql_log_warn, vha, 0x0189,\n\t\t    \"%s: iocb failed to complete -> completion=%#x subcode=(%#x,%#x)\\n\",\n\t\t    __func__, rsp_els->comp_status,\n\t\t    rsp_els->error_subcode_1, rsp_els->error_subcode_2);\n\t} else {\n\t\tql_dbg(ql_dbg_init, vha, 0x018a, \"%s: done.\\n\", __func__);\n\t}\n\ndealloc:\n\tif (stat)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*stat),\n\t\t    stat, stat_dma);\n\tif (sfp)\n\t\tdma_free_coherent(&ha->pdev->dev, SFP_RTDI_LEN,\n\t\t    sfp, sfp_dma);\n\tif (rsp_payload)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*rsp_payload),\n\t\t    rsp_payload, rsp_payload_dma);\n\tif (rsp_els)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*rsp_els),\n\t\t    rsp_els, rsp_els_dma);\n}\n\nvoid\nqla24xx_free_purex_item(struct purex_item *item)\n{\n\tif (item == &item->vha->default_item)\n\t\tmemset(&item->vha->default_item, 0, sizeof(struct purex_item));\n\telse\n\t\tkfree(item);\n}\n\nvoid qla24xx_process_purex_list(struct purex_list *list)\n{\n\tstruct list_head head = LIST_HEAD_INIT(head);\n\tstruct purex_item *item, *next;\n\tulong flags;\n\n\tspin_lock_irqsave(&list->lock, flags);\n\tlist_splice_init(&list->head, &head);\n\tspin_unlock_irqrestore(&list->lock, flags);\n\n\tlist_for_each_entry_safe(item, next, &head, list) {\n\t\tlist_del(&item->list);\n\t\titem->process_item(item->vha, item);\n\t\tqla24xx_free_purex_item(item);\n\t}\n}\n\n \nvoid\nqla83xx_idc_unlock(scsi_qla_host_t *base_vha, uint16_t requester_id)\n{\n#if 0\n\tuint16_t options = (requester_id << 15) | BIT_7;\n#endif\n\tuint16_t retry;\n\tuint32_t data;\n\tstruct qla_hw_data *ha = base_vha->hw;\n\n\tmight_sleep();\n\n\t \n\tretry = 0;\nretry_unlock:\n\tif (qla83xx_rd_reg(base_vha, QLA83XX_DRIVER_LOCKID, &data)\n\t    == QLA_SUCCESS) {\n\t\tif (data == ha->portnum) {\n\t\t\tqla83xx_rd_reg(base_vha, QLA83XX_DRIVER_UNLOCK, &data);\n\t\t\t \n\t\t\tqla83xx_wr_reg(base_vha, QLA83XX_DRIVER_LOCKID, 0xff);\n\t\t} else if (retry < 10) {\n\t\t\t \n\n\t\t\t \n\t\t\tmsleep(QLA83XX_WAIT_LOGIC_MS);\n\t\t\tretry++;\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb064,\n\t\t\t    \"Failed to release IDC lock, retrying=%d\\n\", retry);\n\t\t\tgoto retry_unlock;\n\t\t}\n\t} else if (retry < 10) {\n\t\t \n\t\tmsleep(QLA83XX_WAIT_LOGIC_MS);\n\t\tretry++;\n\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb065,\n\t\t    \"Failed to read drv-lockid, retrying=%d\\n\", retry);\n\t\tgoto retry_unlock;\n\t}\n\n\treturn;\n\n#if 0\n\t \n\tretry = 0;\nretry_unlock2:\n\tif (qla83xx_access_control(base_vha, options, 0, 0, NULL)) {\n\t\tif (retry < 10) {\n\t\t\t \n\t\t\tmsleep(QLA83XX_WAIT_LOGIC_MS);\n\t\t\tretry++;\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb066,\n\t\t\t    \"Failed to release IDC lock, retrying=%d\\n\", retry);\n\t\t\tgoto retry_unlock2;\n\t\t}\n\t}\n\n\treturn;\n#endif\n}\n\nint\n__qla83xx_set_drv_presence(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_presence;\n\n\trval = qla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\n\tif (rval == QLA_SUCCESS) {\n\t\tdrv_presence |= (1 << ha->portnum);\n\t\trval = qla83xx_wr_reg(vha, QLA83XX_IDC_DRV_PRESENCE,\n\t\t    drv_presence);\n\t}\n\n\treturn rval;\n}\n\nint\nqla83xx_set_drv_presence(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\n\tqla83xx_idc_lock(vha, 0);\n\trval = __qla83xx_set_drv_presence(vha);\n\tqla83xx_idc_unlock(vha, 0);\n\n\treturn rval;\n}\n\nint\n__qla83xx_clear_drv_presence(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_presence;\n\n\trval = qla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\n\tif (rval == QLA_SUCCESS) {\n\t\tdrv_presence &= ~(1 << ha->portnum);\n\t\trval = qla83xx_wr_reg(vha, QLA83XX_IDC_DRV_PRESENCE,\n\t\t    drv_presence);\n\t}\n\n\treturn rval;\n}\n\nint\nqla83xx_clear_drv_presence(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\n\tqla83xx_idc_lock(vha, 0);\n\trval = __qla83xx_clear_drv_presence(vha);\n\tqla83xx_idc_unlock(vha, 0);\n\n\treturn rval;\n}\n\nstatic void\nqla83xx_need_reset_handler(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tuint32_t drv_ack, drv_presence;\n\tunsigned long ack_timeout;\n\n\t \n\tack_timeout = jiffies + (ha->fcoe_reset_timeout * HZ);\n\twhile (1) {\n\t\tqla83xx_rd_reg(vha, QLA83XX_IDC_DRIVER_ACK, &drv_ack);\n\t\tqla83xx_rd_reg(vha, QLA83XX_IDC_DRV_PRESENCE, &drv_presence);\n\t\tif ((drv_ack & drv_presence) == drv_presence)\n\t\t\tbreak;\n\n\t\tif (time_after_eq(jiffies, ack_timeout)) {\n\t\t\tql_log(ql_log_warn, vha, 0xb067,\n\t\t\t    \"RESET ACK TIMEOUT! drv_presence=0x%x \"\n\t\t\t    \"drv_ack=0x%x\\n\", drv_presence, drv_ack);\n\t\t\t \n\t\t\tif (drv_ack != drv_presence)\n\t\t\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_DRV_PRESENCE,\n\t\t\t\t    drv_ack);\n\t\t\tbreak;\n\t\t}\n\n\t\tqla83xx_idc_unlock(vha, 0);\n\t\tmsleep(1000);\n\t\tqla83xx_idc_lock(vha, 0);\n\t}\n\n\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE, QLA8XXX_DEV_COLD);\n\tql_log(ql_log_info, vha, 0xb068, \"HW State: COLD/RE-INIT.\\n\");\n}\n\nstatic int\nqla83xx_device_bootstrap(scsi_qla_host_t *vha)\n{\n\tint rval = QLA_SUCCESS;\n\tuint32_t idc_control;\n\n\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE, QLA8XXX_DEV_INITIALIZING);\n\tql_log(ql_log_info, vha, 0xb069, \"HW State: INITIALIZING.\\n\");\n\n\t \n\t__qla83xx_get_idc_control(vha, &idc_control);\n\tidc_control &= ~QLA83XX_IDC_GRACEFUL_RESET;\n\t__qla83xx_set_idc_control(vha, 0);\n\n\tqla83xx_idc_unlock(vha, 0);\n\trval = qla83xx_restart_nic_firmware(vha);\n\tqla83xx_idc_lock(vha, 0);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, vha, 0xb06a,\n\t\t    \"Failed to restart NIC f/w.\\n\");\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE, QLA8XXX_DEV_FAILED);\n\t\tql_log(ql_log_info, vha, 0xb06b, \"HW State: FAILED.\\n\");\n\t} else {\n\t\tql_dbg(ql_dbg_p3p, vha, 0xb06c,\n\t\t    \"Success in restarting nic f/w.\\n\");\n\t\tqla83xx_wr_reg(vha, QLA83XX_IDC_DEV_STATE, QLA8XXX_DEV_READY);\n\t\tql_log(ql_log_info, vha, 0xb06d, \"HW State: READY.\\n\");\n\t}\n\n\treturn rval;\n}\n\n \nint\nqla83xx_idc_state_handler(scsi_qla_host_t *base_vha)\n{\n\tstruct qla_hw_data *ha = base_vha->hw;\n\tint rval = QLA_SUCCESS;\n\tunsigned long dev_init_timeout;\n\tuint32_t dev_state;\n\n\t \n\tdev_init_timeout = jiffies + (ha->fcoe_dev_init_timeout * HZ);\n\n\twhile (1) {\n\n\t\tif (time_after_eq(jiffies, dev_init_timeout)) {\n\t\t\tql_log(ql_log_warn, base_vha, 0xb06e,\n\t\t\t    \"Initialization TIMEOUT!\\n\");\n\t\t\t \n\t\t\tqla83xx_wr_reg(base_vha, QLA83XX_IDC_DEV_STATE,\n\t\t\t\tQLA8XXX_DEV_FAILED);\n\t\t\tql_log(ql_log_info, base_vha, 0xb06f,\n\t\t\t    \"HW State: FAILED.\\n\");\n\t\t}\n\n\t\tqla83xx_rd_reg(base_vha, QLA83XX_IDC_DEV_STATE, &dev_state);\n\t\tswitch (dev_state) {\n\t\tcase QLA8XXX_DEV_READY:\n\t\t\tif (ha->flags.nic_core_reset_owner)\n\t\t\t\tqla83xx_idc_audit(base_vha,\n\t\t\t\t    IDC_AUDIT_COMPLETION);\n\t\t\tha->flags.nic_core_reset_owner = 0;\n\t\t\tql_dbg(ql_dbg_p3p, base_vha, 0xb070,\n\t\t\t    \"Reset_owner reset by 0x%x.\\n\",\n\t\t\t    ha->portnum);\n\t\t\tgoto exit;\n\t\tcase QLA8XXX_DEV_COLD:\n\t\t\tif (ha->flags.nic_core_reset_owner)\n\t\t\t\trval = qla83xx_device_bootstrap(base_vha);\n\t\t\telse {\n\t\t\t \n\t\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\t\tmsleep(1000);\n\t\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_INITIALIZING:\n\t\t\t \n\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\tmsleep(1000);\n\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_NEED_RESET:\n\t\t\tif (!ql2xdontresethba && ha->flags.nic_core_reset_owner)\n\t\t\t\tqla83xx_need_reset_handler(base_vha);\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\t\tmsleep(1000);\n\t\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\t}\n\t\t\t \n\t\t\tdev_init_timeout = jiffies +\n\t\t\t    (ha->fcoe_dev_init_timeout * HZ);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_NEED_QUIESCENT:\n\t\t\t \n\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\tmsleep(1000);\n\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_QUIESCENT:\n\t\t\t \n\t\t\tif (ha->flags.quiesce_owner)\n\t\t\t\tgoto exit;\n\n\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\tmsleep(1000);\n\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\tdev_init_timeout = jiffies +\n\t\t\t    (ha->fcoe_dev_init_timeout * HZ);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_FAILED:\n\t\t\tif (ha->flags.nic_core_reset_owner)\n\t\t\t\tqla83xx_idc_audit(base_vha,\n\t\t\t\t    IDC_AUDIT_COMPLETION);\n\t\t\tha->flags.nic_core_reset_owner = 0;\n\t\t\t__qla83xx_clear_drv_presence(base_vha);\n\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\tqla8xxx_dev_failed_handler(base_vha);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\tgoto exit;\n\t\tcase QLA8XXX_BAD_VALUE:\n\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\tmsleep(1000);\n\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql_log(ql_log_warn, base_vha, 0xb071,\n\t\t\t    \"Unknown Device State: %x.\\n\", dev_state);\n\t\t\tqla83xx_idc_unlock(base_vha, 0);\n\t\t\tqla8xxx_dev_failed_handler(base_vha);\n\t\t\trval = QLA_FUNCTION_FAILED;\n\t\t\tqla83xx_idc_lock(base_vha, 0);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\treturn rval;\n}\n\nvoid\nqla2x00_disable_board_on_pci_error(struct work_struct *work)\n{\n\tstruct qla_hw_data *ha = container_of(work, struct qla_hw_data,\n\t    board_disable);\n\tstruct pci_dev *pdev = ha->pdev;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\n\tql_log(ql_log_warn, base_vha, 0x015b,\n\t    \"Disabling adapter.\\n\");\n\n\tif (!atomic_read(&pdev->enable_cnt)) {\n\t\tql_log(ql_log_info, base_vha, 0xfffc,\n\t\t    \"PCI device disabled, no action req for PCI error=%lx\\n\",\n\t\t    base_vha->pci_flags);\n\t\treturn;\n\t}\n\n\t \n\tif (test_and_set_bit(UNLOADING, &base_vha->dpc_flags))\n\t\treturn;\n\n\tqla2x00_wait_for_sess_deletion(base_vha);\n\n\tqla2x00_delete_all_vps(ha, base_vha);\n\n\tqla2x00_abort_all_cmds(base_vha, DID_NO_CONNECT << 16);\n\n\tqla2x00_dfs_remove(base_vha);\n\n\tqla84xx_put_chip(base_vha);\n\n\tif (base_vha->timer_active)\n\t\tqla2x00_stop_timer(base_vha);\n\n\tbase_vha->flags.online = 0;\n\n\tqla2x00_destroy_deferred_work(ha);\n\n\t \n\tqla2x00_free_sysfs_attr(base_vha, false);\n\n\tfc_remove_host(base_vha->host);\n\n\tscsi_remove_host(base_vha->host);\n\n\tbase_vha->flags.init_done = 0;\n\tqla25xx_delete_queues(base_vha);\n\tqla2x00_free_fcports(base_vha);\n\tqla2x00_free_irqs(base_vha);\n\tqla2x00_mem_free(ha);\n\tqla82xx_md_free(base_vha);\n\tqla2x00_free_queues(ha);\n\n\tqla2x00_unmap_iobases(ha);\n\n\tpci_release_selected_regions(ha->pdev, ha->bars);\n\tpci_disable_device(pdev);\n\n\t \n}\n\n \nstatic int\nqla2x00_do_dpc(void *data)\n{\n\tscsi_qla_host_t *base_vha;\n\tstruct qla_hw_data *ha;\n\tuint32_t online;\n\tstruct qla_qpair *qpair;\n\n\tha = (struct qla_hw_data *)data;\n\tbase_vha = pci_get_drvdata(ha->pdev);\n\n\tset_user_nice(current, MIN_NICE);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!kthread_should_stop()) {\n\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4000,\n\t\t    \"DPC handler sleeping.\\n\");\n\n\t\tschedule();\n\n\t\tif (test_and_clear_bit(DO_EEH_RECOVERY, &base_vha->dpc_flags))\n\t\t\tqla_pci_set_eeh_busy(base_vha);\n\n\t\tif (!base_vha->flags.init_done || ha->flags.mbox_busy)\n\t\t\tgoto end_loop;\n\n\t\tif (ha->flags.eeh_busy) {\n\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4003,\n\t\t\t    \"eeh_busy=%d.\\n\", ha->flags.eeh_busy);\n\t\t\tgoto end_loop;\n\t\t}\n\n\t\tha->dpc_active = 1;\n\n\t\tql_dbg(ql_dbg_dpc + ql_dbg_verbose, base_vha, 0x4001,\n\t\t    \"DPC handler waking up, dpc_flags=0x%lx.\\n\",\n\t\t    base_vha->dpc_flags);\n\n\t\tif (test_bit(UNLOADING, &base_vha->dpc_flags))\n\t\t\tbreak;\n\n\t\tif (IS_P3P_TYPE(ha)) {\n\t\t\tif (IS_QLA8044(ha)) {\n\t\t\t\tif (test_and_clear_bit(ISP_UNRECOVERABLE,\n\t\t\t\t\t&base_vha->dpc_flags)) {\n\t\t\t\t\tqla8044_idc_lock(ha);\n\t\t\t\t\tqla8044_wr_direct(base_vha,\n\t\t\t\t\t\tQLA8044_CRB_DEV_STATE_INDEX,\n\t\t\t\t\t\tQLA8XXX_DEV_FAILED);\n\t\t\t\t\tqla8044_idc_unlock(ha);\n\t\t\t\t\tql_log(ql_log_info, base_vha, 0x4004,\n\t\t\t\t\t\t\"HW State: FAILED.\\n\");\n\t\t\t\t\tqla8044_device_state_handler(base_vha);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (test_and_clear_bit(ISP_UNRECOVERABLE,\n\t\t\t\t\t&base_vha->dpc_flags)) {\n\t\t\t\t\tqla82xx_idc_lock(ha);\n\t\t\t\t\tqla82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\n\t\t\t\t\t\tQLA8XXX_DEV_FAILED);\n\t\t\t\t\tqla82xx_idc_unlock(ha);\n\t\t\t\t\tql_log(ql_log_info, base_vha, 0x0151,\n\t\t\t\t\t\t\"HW State: FAILED.\\n\");\n\t\t\t\t\tqla82xx_device_state_handler(base_vha);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (test_and_clear_bit(FCOE_CTX_RESET_NEEDED,\n\t\t\t\t&base_vha->dpc_flags)) {\n\n\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4005,\n\t\t\t\t    \"FCoE context reset scheduled.\\n\");\n\t\t\t\tif (!(test_and_set_bit(ABORT_ISP_ACTIVE,\n\t\t\t\t\t&base_vha->dpc_flags))) {\n\t\t\t\t\tif (qla82xx_fcoe_ctx_reset(base_vha)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t\t\t&base_vha->dpc_flags);\n\t\t\t\t\t}\n\t\t\t\t\tclear_bit(ABORT_ISP_ACTIVE,\n\t\t\t\t\t\t&base_vha->dpc_flags);\n\t\t\t\t}\n\n\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4006,\n\t\t\t\t    \"FCoE context reset end.\\n\");\n\t\t\t}\n\t\t} else if (IS_QLAFX00(ha)) {\n\t\t\tif (test_and_clear_bit(ISP_UNRECOVERABLE,\n\t\t\t\t&base_vha->dpc_flags)) {\n\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4020,\n\t\t\t\t    \"Firmware Reset Recovery\\n\");\n\t\t\t\tif (qlafx00_reset_initialize(base_vha)) {\n\t\t\t\t\t \n\t\t\t\t\tif (!test_bit(UNLOADING,\n\t\t\t\t\t    &base_vha->dpc_flags)) {\n\t\t\t\t\t\tset_bit(ISP_UNRECOVERABLE,\n\t\t\t\t\t\t    &base_vha->dpc_flags);\n\t\t\t\t\t\tql_dbg(ql_dbg_dpc, base_vha,\n\t\t\t\t\t\t    0x4021,\n\t\t\t\t\t\t    \"Reset Recovery Failed\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (test_and_clear_bit(FX00_TARGET_SCAN,\n\t\t\t\t&base_vha->dpc_flags)) {\n\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4022,\n\t\t\t\t    \"ISPFx00 Target Scan scheduled\\n\");\n\t\t\t\tif (qlafx00_rescan_isp(base_vha)) {\n\t\t\t\t\tif (!test_bit(UNLOADING,\n\t\t\t\t\t    &base_vha->dpc_flags))\n\t\t\t\t\t\tset_bit(ISP_UNRECOVERABLE,\n\t\t\t\t\t\t    &base_vha->dpc_flags);\n\t\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x401e,\n\t\t\t\t\t    \"ISPFx00 Target Scan Failed\\n\");\n\t\t\t\t}\n\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x401f,\n\t\t\t\t    \"ISPFx00 Target Scan End\\n\");\n\t\t\t}\n\t\t\tif (test_and_clear_bit(FX00_HOST_INFO_RESEND,\n\t\t\t\t&base_vha->dpc_flags)) {\n\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4023,\n\t\t\t\t    \"ISPFx00 Host Info resend scheduled\\n\");\n\t\t\t\tqlafx00_fx_disc(base_vha,\n\t\t\t\t    &base_vha->hw->mr.fcport,\n\t\t\t\t    FXDISC_REG_HOST_INFO);\n\t\t\t}\n\t\t}\n\n\t\tif (test_and_clear_bit(DETECT_SFP_CHANGE,\n\t\t    &base_vha->dpc_flags)) {\n\t\t\t \n\t\t\t \n\t\t}\n\n\t\tif (test_and_clear_bit\n\t\t    (ISP_ABORT_NEEDED, &base_vha->dpc_flags) &&\n\t\t    !test_bit(UNLOADING, &base_vha->dpc_flags)) {\n\t\t\tbool do_reset = true;\n\n\t\t\tswitch (base_vha->qlini_mode) {\n\t\t\tcase QLA2XXX_INI_MODE_ENABLED:\n\t\t\t\tbreak;\n\t\t\tcase QLA2XXX_INI_MODE_DISABLED:\n\t\t\t\tif (!qla_tgt_mode_enabled(base_vha) &&\n\t\t\t\t    !ha->flags.fw_started)\n\t\t\t\t\tdo_reset = false;\n\t\t\t\tbreak;\n\t\t\tcase QLA2XXX_INI_MODE_DUAL:\n\t\t\t\tif (!qla_dual_mode_enabled(base_vha) &&\n\t\t\t\t    !ha->flags.fw_started)\n\t\t\t\t\tdo_reset = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (do_reset && !(test_and_set_bit(ABORT_ISP_ACTIVE,\n\t\t\t    &base_vha->dpc_flags))) {\n\t\t\t\tbase_vha->flags.online = 1;\n\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4007,\n\t\t\t\t    \"ISP abort scheduled.\\n\");\n\t\t\t\tif (ha->isp_ops->abort_isp(base_vha)) {\n\t\t\t\t\t \n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t    &base_vha->dpc_flags);\n\t\t\t\t}\n\t\t\t\tclear_bit(ABORT_ISP_ACTIVE,\n\t\t\t\t\t\t&base_vha->dpc_flags);\n\t\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4008,\n\t\t\t\t    \"ISP abort end.\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (test_bit(PROCESS_PUREX_IOCB, &base_vha->dpc_flags)) {\n\t\t\tif (atomic_read(&base_vha->loop_state) == LOOP_READY) {\n\t\t\t\tqla24xx_process_purex_list\n\t\t\t\t\t(&base_vha->purex_list);\n\t\t\t\tclear_bit(PROCESS_PUREX_IOCB,\n\t\t\t\t    &base_vha->dpc_flags);\n\t\t\t}\n\t\t}\n\n\t\tif (IS_QLAFX00(ha))\n\t\t\tgoto loop_resync_check;\n\n\t\tif (test_bit(ISP_QUIESCE_NEEDED, &base_vha->dpc_flags)) {\n\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4009,\n\t\t\t    \"Quiescence mode scheduled.\\n\");\n\t\t\tif (IS_P3P_TYPE(ha)) {\n\t\t\t\tif (IS_QLA82XX(ha))\n\t\t\t\t\tqla82xx_device_state_handler(base_vha);\n\t\t\t\tif (IS_QLA8044(ha))\n\t\t\t\t\tqla8044_device_state_handler(base_vha);\n\t\t\t\tclear_bit(ISP_QUIESCE_NEEDED,\n\t\t\t\t    &base_vha->dpc_flags);\n\t\t\t\tif (!ha->flags.quiesce_owner) {\n\t\t\t\t\tqla2x00_perform_loop_resync(base_vha);\n\t\t\t\t\tif (IS_QLA82XX(ha)) {\n\t\t\t\t\t\tqla82xx_idc_lock(ha);\n\t\t\t\t\t\tqla82xx_clear_qsnt_ready(\n\t\t\t\t\t\t    base_vha);\n\t\t\t\t\t\tqla82xx_idc_unlock(ha);\n\t\t\t\t\t} else if (IS_QLA8044(ha)) {\n\t\t\t\t\t\tqla8044_idc_lock(ha);\n\t\t\t\t\t\tqla8044_clear_qsnt_ready(\n\t\t\t\t\t\t    base_vha);\n\t\t\t\t\t\tqla8044_idc_unlock(ha);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tclear_bit(ISP_QUIESCE_NEEDED,\n\t\t\t\t    &base_vha->dpc_flags);\n\t\t\t\tqla2x00_quiesce_io(base_vha);\n\t\t\t}\n\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x400a,\n\t\t\t    \"Quiescence mode end.\\n\");\n\t\t}\n\n\t\tif (test_and_clear_bit(RESET_MARKER_NEEDED,\n\t\t\t\t&base_vha->dpc_flags) &&\n\t\t    (!(test_and_set_bit(RESET_ACTIVE, &base_vha->dpc_flags)))) {\n\n\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x400b,\n\t\t\t    \"Reset marker scheduled.\\n\");\n\t\t\tqla2x00_rst_aen(base_vha);\n\t\t\tclear_bit(RESET_ACTIVE, &base_vha->dpc_flags);\n\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x400c,\n\t\t\t    \"Reset marker end.\\n\");\n\t\t}\n\n\t\t \n\t\tif (test_bit(RELOGIN_NEEDED, &base_vha->dpc_flags) &&\n\t\t    !test_bit(LOOP_RESYNC_NEEDED, &base_vha->dpc_flags) &&\n\t\t    atomic_read(&base_vha->loop_state) != LOOP_DOWN) {\n\n\t\t\tif (!base_vha->relogin_jif ||\n\t\t\t    time_after_eq(jiffies, base_vha->relogin_jif)) {\n\t\t\t\tbase_vha->relogin_jif = jiffies + HZ;\n\t\t\t\tclear_bit(RELOGIN_NEEDED, &base_vha->dpc_flags);\n\n\t\t\t\tql_dbg(ql_dbg_disc, base_vha, 0x400d,\n\t\t\t\t    \"Relogin scheduled.\\n\");\n\t\t\t\tqla24xx_post_relogin_work(base_vha);\n\t\t\t}\n\t\t}\nloop_resync_check:\n\t\tif (!qla2x00_reset_active(base_vha) &&\n\t\t    test_and_clear_bit(LOOP_RESYNC_NEEDED,\n\t\t    &base_vha->dpc_flags)) {\n\t\t\t \n\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x400f,\n\t\t\t    \"Loop resync scheduled.\\n\");\n\n\t\t\tif (!(test_and_set_bit(LOOP_RESYNC_ACTIVE,\n\t\t\t    &base_vha->dpc_flags))) {\n\n\t\t\t\tqla2x00_loop_resync(base_vha);\n\n\t\t\t\tclear_bit(LOOP_RESYNC_ACTIVE,\n\t\t\t\t\t\t&base_vha->dpc_flags);\n\t\t\t}\n\n\t\t\tql_dbg(ql_dbg_dpc, base_vha, 0x4010,\n\t\t\t    \"Loop resync end.\\n\");\n\t\t}\n\n\t\tif (IS_QLAFX00(ha))\n\t\t\tgoto intr_on_check;\n\n\t\tif (test_bit(NPIV_CONFIG_NEEDED, &base_vha->dpc_flags) &&\n\t\t    atomic_read(&base_vha->loop_state) == LOOP_READY) {\n\t\t\tclear_bit(NPIV_CONFIG_NEEDED, &base_vha->dpc_flags);\n\t\t\tqla2xxx_flash_npiv_conf(base_vha);\n\t\t}\n\nintr_on_check:\n\t\tif (!ha->interrupts_on)\n\t\t\tha->isp_ops->enable_intrs(ha);\n\n\t\tif (test_and_clear_bit(BEACON_BLINK_NEEDED,\n\t\t\t\t\t&base_vha->dpc_flags)) {\n\t\t\tif (ha->beacon_blink_led == 1)\n\t\t\t\tha->isp_ops->beacon_blink(base_vha);\n\t\t}\n\n\t\t \n\t\tif (test_and_clear_bit(QPAIR_ONLINE_CHECK_NEEDED,\n\t\t    &base_vha->dpc_flags)) {\n\t\t\tif (ha->flags.eeh_busy ||\n\t\t\t    ha->flags.pci_channel_io_perm_failure)\n\t\t\t\tonline = 0;\n\t\t\telse\n\t\t\t\tonline = 1;\n\n\t\t\tmutex_lock(&ha->mq_lock);\n\t\t\tlist_for_each_entry(qpair, &base_vha->qp_list,\n\t\t\t    qp_list_elem)\n\t\t\tqpair->online = online;\n\t\t\tmutex_unlock(&ha->mq_lock);\n\t\t}\n\n\t\tif (test_and_clear_bit(SET_ZIO_THRESHOLD_NEEDED,\n\t\t\t\t       &base_vha->dpc_flags)) {\n\t\t\tu16 threshold = ha->nvme_last_rptd_aen + ha->last_zio_threshold;\n\n\t\t\tif (threshold > ha->orig_fw_xcb_count)\n\t\t\t\tthreshold = ha->orig_fw_xcb_count;\n\n\t\t\tql_log(ql_log_info, base_vha, 0xffffff,\n\t\t\t       \"SET ZIO Activity exchange threshold to %d.\\n\",\n\t\t\t       threshold);\n\t\t\tif (qla27xx_set_zio_threshold(base_vha, threshold)) {\n\t\t\t\tql_log(ql_log_info, base_vha, 0xffffff,\n\t\t\t\t       \"Unable to SET ZIO Activity exchange threshold to %d.\\n\",\n\t\t\t\t       threshold);\n\t\t\t}\n\t\t}\n\n\t\tif (!IS_QLAFX00(ha))\n\t\t\tqla2x00_do_dpc_all_vps(base_vha);\n\n\t\tif (test_and_clear_bit(N2N_LINK_RESET,\n\t\t\t&base_vha->dpc_flags)) {\n\t\t\tqla2x00_lip_reset(base_vha);\n\t\t}\n\n\t\tha->dpc_active = 0;\nend_loop:\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}  \n\t__set_current_state(TASK_RUNNING);\n\n\tql_dbg(ql_dbg_dpc, base_vha, 0x4011,\n\t    \"DPC handler exiting.\\n\");\n\n\t \n\tha->dpc_active = 0;\n\n\t \n\tqla2x00_abort_all_cmds(base_vha, DID_NO_CONNECT << 16);\n\n\treturn 0;\n}\n\nvoid\nqla2xxx_wake_dpc(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct task_struct *t = ha->dpc_thread;\n\n\tif (!test_bit(UNLOADING, &vha->dpc_flags) && t)\n\t\twake_up_process(t);\n}\n\n \nstatic void\nqla2x00_rst_aen(scsi_qla_host_t *vha)\n{\n\tif (vha->flags.online && !vha->flags.reset_active &&\n\t    !atomic_read(&vha->loop_down_timer) &&\n\t    !(test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags))) {\n\t\tdo {\n\t\t\tclear_bit(RESET_MARKER_NEEDED, &vha->dpc_flags);\n\n\t\t\t \n\t\t\tvha->marker_needed = 1;\n\t\t} while (!atomic_read(&vha->loop_down_timer) &&\n\t\t    (test_bit(RESET_MARKER_NEEDED, &vha->dpc_flags)));\n\t}\n}\n\nstatic bool qla_do_heartbeat(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tu32 cmpl_cnt;\n\tu16 i;\n\tbool do_heartbeat = false;\n\n\t \n\tcmpl_cnt = ha->base_qpair->cmd_completion_cnt;\n\tif (cmpl_cnt == ha->base_qpair->prev_completion_cnt &&\n\t    cmpl_cnt != ha->base_qpair->cmd_cnt) {\n\t\tdo_heartbeat = true;\n\t\tgoto skip;\n\t}\n\tha->base_qpair->prev_completion_cnt = cmpl_cnt;\n\n\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\tif (ha->queue_pair_map[i]) {\n\t\t\tcmpl_cnt = ha->queue_pair_map[i]->cmd_completion_cnt;\n\t\t\tif (cmpl_cnt == ha->queue_pair_map[i]->prev_completion_cnt &&\n\t\t\t    cmpl_cnt != ha->queue_pair_map[i]->cmd_cnt) {\n\t\t\t\tdo_heartbeat = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tha->queue_pair_map[i]->prev_completion_cnt = cmpl_cnt;\n\t\t}\n\t}\n\nskip:\n\treturn do_heartbeat;\n}\n\nstatic void qla_heart_beat(struct scsi_qla_host *vha, u16 dpc_started)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (vha->vp_idx)\n\t\treturn;\n\n\tif (vha->hw->flags.eeh_busy || qla2x00_chip_is_down(vha))\n\t\treturn;\n\n\t \n\tif (dpc_started &&\n\t    time_before(jiffies, ha->last_heartbeat_run_jiffies + 5 * HZ))\n\t\treturn;\n\n\tif (qla_do_heartbeat(vha)) {\n\t\tha->last_heartbeat_run_jiffies = jiffies;\n\t\tqueue_work(ha->wq, &ha->heartbeat_work);\n\t}\n}\n\nstatic void qla_wind_down_chip(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\n\tif (!ha->flags.eeh_busy)\n\t\treturn;\n\tif (ha->pci_error_state)\n\t\t \n\t\treturn;\n\n\t \n\tif (time_after_eq(jiffies, ha->eeh_jif + ql2xdelay_before_pci_error_handling * HZ) &&\n\t    !ha->flags.eeh_flush) {\n\t\tql_log(ql_log_info, vha, 0x9009,\n\t\t    \"PCI Error detected, attempting to reset hardware.\\n\");\n\n\t\tha->isp_ops->reset_chip(vha);\n\t\tha->isp_ops->disable_intrs(ha);\n\n\t\tha->flags.eeh_flush = EEH_FLUSH_RDY;\n\t\tha->eeh_jif = jiffies;\n\n\t} else if (ha->flags.eeh_flush == EEH_FLUSH_RDY &&\n\t    time_after_eq(jiffies, ha->eeh_jif +  5 * HZ)) {\n\t\tpci_clear_master(ha->pdev);\n\n\t\t \n\t\tqla2x00_abort_isp_cleanup(vha);\n\t\tha->flags.eeh_flush = EEH_FLUSH_DONE;\n\n\t\tql_log(ql_log_info, vha, 0x900a,\n\t\t    \"PCI Error handling complete, all IOs aborted.\\n\");\n\t}\n}\n\n \nvoid\nqla2x00_timer(struct timer_list *t)\n{\n\tscsi_qla_host_t *vha = from_timer(vha, t, timer);\n\tunsigned long\tcpu_flags = 0;\n\tint\t\tstart_dpc = 0;\n\tint\t\tindex;\n\tsrb_t\t\t*sp;\n\tuint16_t        w;\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct req_que *req;\n\tunsigned long flags;\n\tfc_port_t *fcport = NULL;\n\n\tif (ha->flags.eeh_busy) {\n\t\tqla_wind_down_chip(vha);\n\n\t\tql_dbg(ql_dbg_timer, vha, 0x6000,\n\t\t    \"EEH = %d, restarting timer.\\n\",\n\t\t    ha->flags.eeh_busy);\n\t\tqla2x00_restart_timer(vha, WATCH_INTERVAL);\n\t\treturn;\n\t}\n\n\t \n\tif (!pci_channel_offline(ha->pdev)) {\n\t\tpci_read_config_word(ha->pdev, PCI_VENDOR_ID, &w);\n\t\tqla2x00_check_reg16_for_disconnect(vha, w);\n\t}\n\n\t \n\tif (!vha->vp_idx && IS_P3P_TYPE(ha)) {\n\t\tif (test_bit(ISP_QUIESCE_NEEDED, &vha->dpc_flags))\n\t\t\tstart_dpc++;\n\t\tif (IS_QLA82XX(ha))\n\t\t\tqla82xx_watchdog(vha);\n\t\telse if (IS_QLA8044(ha))\n\t\t\tqla8044_watchdog(vha);\n\t}\n\n\tif (!vha->vp_idx && IS_QLAFX00(ha))\n\t\tqlafx00_timer_routine(vha);\n\n\tif (vha->link_down_time < QLA2XX_MAX_LINK_DOWN_TIME)\n\t\tvha->link_down_time++;\n\n\tspin_lock_irqsave(&vha->hw->tgt.sess_lock, flags);\n\tlist_for_each_entry(fcport, &vha->vp_fcports, list) {\n\t\tif (fcport->tgt_link_down_time < QLA2XX_MAX_LINK_DOWN_TIME)\n\t\t\tfcport->tgt_link_down_time++;\n\t}\n\tspin_unlock_irqrestore(&vha->hw->tgt.sess_lock, flags);\n\n\t \n\tif (atomic_read(&vha->loop_down_timer) > 0 &&\n\t    !(test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)) &&\n\t    !(test_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags))\n\t\t&& vha->flags.online) {\n\n\t\tif (atomic_read(&vha->loop_down_timer) ==\n\t\t    vha->loop_down_abort_time) {\n\n\t\t\tql_log(ql_log_info, vha, 0x6008,\n\t\t\t    \"Loop down - aborting the queues before time expires.\\n\");\n\n\t\t\tif (!IS_QLA2100(ha) && vha->link_down_timeout)\n\t\t\t\tatomic_set(&vha->loop_state, LOOP_DEAD);\n\n\t\t\t \n\t\t\t \n\t\t\tif (!vha->vp_idx) {\n\t\t\t\tspin_lock_irqsave(&ha->hardware_lock,\n\t\t\t\t    cpu_flags);\n\t\t\t\treq = ha->req_q_map[0];\n\t\t\t\tfor (index = 1;\n\t\t\t\t    index < req->num_outstanding_cmds;\n\t\t\t\t    index++) {\n\t\t\t\t\tfc_port_t *sfcp;\n\n\t\t\t\t\tsp = req->outstanding_cmds[index];\n\t\t\t\t\tif (!sp)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (sp->cmd_type != TYPE_SRB)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (sp->type != SRB_SCSI_CMD)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsfcp = sp->fcport;\n\t\t\t\t\tif (!(sfcp->flags & FCF_FCP2_DEVICE))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (IS_QLA82XX(ha))\n\t\t\t\t\t\tset_bit(FCOE_CTX_RESET_NEEDED,\n\t\t\t\t\t\t\t&vha->dpc_flags);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t\t\t&vha->dpc_flags);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&ha->hardware_lock,\n\t\t\t\t\t\t\t\tcpu_flags);\n\t\t\t}\n\t\t\tstart_dpc++;\n\t\t}\n\n\t\t \n\t\tif (atomic_dec_and_test(&vha->loop_down_timer) != 0) {\n\t\t\tif (!(vha->device_flags & DFLG_NO_CABLE) && !vha->vp_idx) {\n\t\t\t\tql_log(ql_log_warn, vha, 0x6009,\n\t\t\t\t    \"Loop down - aborting ISP.\\n\");\n\n\t\t\t\tif (IS_QLA82XX(ha))\n\t\t\t\t\tset_bit(FCOE_CTX_RESET_NEEDED,\n\t\t\t\t\t\t&vha->dpc_flags);\n\t\t\t\telse\n\t\t\t\t\tset_bit(ISP_ABORT_NEEDED,\n\t\t\t\t\t\t&vha->dpc_flags);\n\t\t\t}\n\t\t}\n\t\tql_dbg(ql_dbg_timer, vha, 0x600a,\n\t\t    \"Loop down - seconds remaining %d.\\n\",\n\t\t    atomic_read(&vha->loop_down_timer));\n\t}\n\t \n\tif (!vha->vp_idx && (ha->beacon_blink_led == 1)) {\n\t\t \n\t\tif (!IS_P3P_TYPE(ha)) {\n\t\t\tset_bit(BEACON_BLINK_NEEDED, &vha->dpc_flags);\n\t\t\tstart_dpc++;\n\t\t}\n\t}\n\n\t \n\tif (vha->hw->flags.edif_enabled)\n\t\tqla_edif_timer(vha);\n\n\t \n\tif (!list_empty(&vha->work_list)) {\n\t\tunsigned long flags;\n\t\tbool q = false;\n\n\t\tspin_lock_irqsave(&vha->work_lock, flags);\n\t\tif (!test_and_set_bit(IOCB_WORK_ACTIVE, &vha->dpc_flags))\n\t\t\tq = true;\n\t\tspin_unlock_irqrestore(&vha->work_lock, flags);\n\t\tif (q)\n\t\t\tqueue_work(vha->hw->wq, &vha->iocb_work);\n\t}\n\n\t \n\tindex = atomic_read(&ha->nvme_active_aen_cnt);\n\tif (!vha->vp_idx &&\n\t    (index != ha->nvme_last_rptd_aen) &&\n\t    ha->zio_mode == QLA_ZIO_MODE_6 &&\n\t    !ha->flags.host_shutting_down) {\n\t\tha->nvme_last_rptd_aen = atomic_read(&ha->nvme_active_aen_cnt);\n\t\tql_log(ql_log_info, vha, 0x3002,\n\t\t    \"nvme: Sched: Set ZIO exchange threshold to %d.\\n\",\n\t\t    ha->nvme_last_rptd_aen);\n\t\tset_bit(SET_ZIO_THRESHOLD_NEEDED, &vha->dpc_flags);\n\t\tstart_dpc++;\n\t}\n\n\tif (!vha->vp_idx &&\n\t    atomic_read(&ha->zio_threshold) != ha->last_zio_threshold &&\n\t    IS_ZIO_THRESHOLD_CAPABLE(ha)) {\n\t\tql_log(ql_log_info, vha, 0x3002,\n\t\t    \"Sched: Set ZIO exchange threshold to %d.\\n\",\n\t\t    ha->last_zio_threshold);\n\t\tha->last_zio_threshold = atomic_read(&ha->zio_threshold);\n\t\tset_bit(SET_ZIO_THRESHOLD_NEEDED, &vha->dpc_flags);\n\t\tstart_dpc++;\n\t}\n\tqla_adjust_buf(vha);\n\n\t \n\tw = 0;\n\t \n\tif ((test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) ||\n\t    test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags) ||\n\t    start_dpc ||\n\t    test_bit(RESET_MARKER_NEEDED, &vha->dpc_flags) ||\n\t    test_bit(BEACON_BLINK_NEEDED, &vha->dpc_flags) ||\n\t    test_bit(ISP_UNRECOVERABLE, &vha->dpc_flags) ||\n\t    test_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags) ||\n\t    test_bit(VP_DPC_NEEDED, &vha->dpc_flags) ||\n\t    test_bit(RELOGIN_NEEDED, &vha->dpc_flags) ||\n\t    test_bit(PROCESS_PUREX_IOCB, &vha->dpc_flags))) {\n\t\tql_dbg(ql_dbg_timer, vha, 0x600b,\n\t\t    \"isp_abort_needed=%d loop_resync_needed=%d \"\n\t\t    \"start_dpc=%d reset_marker_needed=%d\",\n\t\t    test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags),\n\t\t    test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags),\n\t\t    start_dpc, test_bit(RESET_MARKER_NEEDED, &vha->dpc_flags));\n\t\tql_dbg(ql_dbg_timer, vha, 0x600c,\n\t\t    \"beacon_blink_needed=%d isp_unrecoverable=%d \"\n\t\t    \"fcoe_ctx_reset_needed=%d vp_dpc_needed=%d \"\n\t\t    \"relogin_needed=%d, Process_purex_iocb=%d.\\n\",\n\t\t    test_bit(BEACON_BLINK_NEEDED, &vha->dpc_flags),\n\t\t    test_bit(ISP_UNRECOVERABLE, &vha->dpc_flags),\n\t\t    test_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags),\n\t\t    test_bit(VP_DPC_NEEDED, &vha->dpc_flags),\n\t\t    test_bit(RELOGIN_NEEDED, &vha->dpc_flags),\n\t\t    test_bit(PROCESS_PUREX_IOCB, &vha->dpc_flags));\n\t\tqla2xxx_wake_dpc(vha);\n\t\tw = 1;\n\t}\n\n\tqla_heart_beat(vha, w);\n\n\tqla2x00_restart_timer(vha, WATCH_INTERVAL);\n}\n\n \n\n#define FW_ISP21XX\t0\n#define FW_ISP22XX\t1\n#define FW_ISP2300\t2\n#define FW_ISP2322\t3\n#define FW_ISP24XX\t4\n#define FW_ISP25XX\t5\n#define FW_ISP81XX\t6\n#define FW_ISP82XX\t7\n#define FW_ISP2031\t8\n#define FW_ISP8031\t9\n#define FW_ISP27XX\t10\n#define FW_ISP28XX\t11\n\n#define FW_FILE_ISP21XX\t\"ql2100_fw.bin\"\n#define FW_FILE_ISP22XX\t\"ql2200_fw.bin\"\n#define FW_FILE_ISP2300\t\"ql2300_fw.bin\"\n#define FW_FILE_ISP2322\t\"ql2322_fw.bin\"\n#define FW_FILE_ISP24XX\t\"ql2400_fw.bin\"\n#define FW_FILE_ISP25XX\t\"ql2500_fw.bin\"\n#define FW_FILE_ISP81XX\t\"ql8100_fw.bin\"\n#define FW_FILE_ISP82XX\t\"ql8200_fw.bin\"\n#define FW_FILE_ISP2031\t\"ql2600_fw.bin\"\n#define FW_FILE_ISP8031\t\"ql8300_fw.bin\"\n#define FW_FILE_ISP27XX\t\"ql2700_fw.bin\"\n#define FW_FILE_ISP28XX\t\"ql2800_fw.bin\"\n\n\nstatic DEFINE_MUTEX(qla_fw_lock);\n\nstatic struct fw_blob qla_fw_blobs[] = {\n\t{ .name = FW_FILE_ISP21XX, .segs = { 0x1000, 0 }, },\n\t{ .name = FW_FILE_ISP22XX, .segs = { 0x1000, 0 }, },\n\t{ .name = FW_FILE_ISP2300, .segs = { 0x800, 0 }, },\n\t{ .name = FW_FILE_ISP2322, .segs = { 0x800, 0x1c000, 0x1e000, 0 }, },\n\t{ .name = FW_FILE_ISP24XX, },\n\t{ .name = FW_FILE_ISP25XX, },\n\t{ .name = FW_FILE_ISP81XX, },\n\t{ .name = FW_FILE_ISP82XX, },\n\t{ .name = FW_FILE_ISP2031, },\n\t{ .name = FW_FILE_ISP8031, },\n\t{ .name = FW_FILE_ISP27XX, },\n\t{ .name = FW_FILE_ISP28XX, },\n\t{ .name = NULL, },\n};\n\nstruct fw_blob *\nqla2x00_request_firmware(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct fw_blob *blob;\n\n\tif (IS_QLA2100(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP21XX];\n\t} else if (IS_QLA2200(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP22XX];\n\t} else if (IS_QLA2300(ha) || IS_QLA2312(ha) || IS_QLA6312(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP2300];\n\t} else if (IS_QLA2322(ha) || IS_QLA6322(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP2322];\n\t} else if (IS_QLA24XX_TYPE(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP24XX];\n\t} else if (IS_QLA25XX(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP25XX];\n\t} else if (IS_QLA81XX(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP81XX];\n\t} else if (IS_QLA82XX(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP82XX];\n\t} else if (IS_QLA2031(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP2031];\n\t} else if (IS_QLA8031(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP8031];\n\t} else if (IS_QLA27XX(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP27XX];\n\t} else if (IS_QLA28XX(ha)) {\n\t\tblob = &qla_fw_blobs[FW_ISP28XX];\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tif (!blob->name)\n\t\treturn NULL;\n\n\tmutex_lock(&qla_fw_lock);\n\tif (blob->fw)\n\t\tgoto out;\n\n\tif (request_firmware(&blob->fw, blob->name, &ha->pdev->dev)) {\n\t\tql_log(ql_log_warn, vha, 0x0063,\n\t\t    \"Failed to load firmware image (%s).\\n\", blob->name);\n\t\tblob->fw = NULL;\n\t\tblob = NULL;\n\t}\n\nout:\n\tmutex_unlock(&qla_fw_lock);\n\treturn blob;\n}\n\nstatic void\nqla2x00_release_firmware(void)\n{\n\tstruct fw_blob *blob;\n\n\tmutex_lock(&qla_fw_lock);\n\tfor (blob = qla_fw_blobs; blob->name; blob++)\n\t\trelease_firmware(blob->fw);\n\tmutex_unlock(&qla_fw_lock);\n}\n\nstatic void qla_pci_error_cleanup(scsi_qla_host_t *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\n\tstruct qla_qpair *qpair = NULL;\n\tstruct scsi_qla_host *vp, *tvp;\n\tfc_port_t *fcport;\n\tint i;\n\tunsigned long flags;\n\n\tql_dbg(ql_dbg_aer, vha, 0x9000,\n\t       \"%s\\n\", __func__);\n\tha->chip_reset++;\n\n\tha->base_qpair->chip_reset = ha->chip_reset;\n\tfor (i = 0; i < ha->max_qpairs; i++) {\n\t\tif (ha->queue_pair_map[i])\n\t\t\tha->queue_pair_map[i]->chip_reset =\n\t\t\t    ha->base_qpair->chip_reset;\n\t}\n\n\t \n\n\tmutex_lock(&ha->mq_lock);\n\tha->base_qpair->online = 0;\n\tlist_for_each_entry(qpair, &base_vha->qp_list, qp_list_elem)\n\t\tqpair->online = 0;\n\twmb();\n\tmutex_unlock(&ha->mq_lock);\n\n\tqla2x00_mark_all_devices_lost(vha);\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tlist_for_each_entry_safe(vp, tvp, &ha->vp_list, list) {\n\t\tatomic_inc(&vp->vref_count);\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\t\tqla2x00_mark_all_devices_lost(vp);\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tatomic_dec(&vp->vref_count);\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\n\t \n\tlist_for_each_entry(fcport, &vha->vp_fcports, list)\n\t\tfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\n\n\tspin_lock_irqsave(&ha->vport_slock, flags);\n\tlist_for_each_entry_safe(vp, tvp, &ha->vp_list, list) {\n\t\tatomic_inc(&vp->vref_count);\n\t\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n\t\tlist_for_each_entry(fcport, &vp->vp_fcports, list)\n\t\t\tfcport->flags &= ~(FCF_LOGIN_NEEDED | FCF_ASYNC_SENT);\n\t\tspin_lock_irqsave(&ha->vport_slock, flags);\n\t\tatomic_dec(&vp->vref_count);\n\t}\n\tspin_unlock_irqrestore(&ha->vport_slock, flags);\n}\n\n\nstatic pci_ers_result_t\nqla2xxx_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tscsi_qla_host_t *vha = pci_get_drvdata(pdev);\n\tstruct qla_hw_data *ha = vha->hw;\n\tpci_ers_result_t ret = PCI_ERS_RESULT_NEED_RESET;\n\n\tql_log(ql_log_warn, vha, 0x9000,\n\t       \"PCI error detected, state %x.\\n\", state);\n\tha->pci_error_state = QLA_PCI_ERR_DETECTED;\n\n\tif (!atomic_read(&pdev->enable_cnt)) {\n\t\tql_log(ql_log_info, vha, 0xffff,\n\t\t\t\"PCI device is disabled,state %x\\n\", state);\n\t\tret = PCI_ERS_RESULT_NEED_RESET;\n\t\tgoto out;\n\t}\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\tqla_pci_set_eeh_busy(vha);\n\t\tif (ql2xmqsupport || ql2xnvmeenable) {\n\t\t\tset_bit(QPAIR_ONLINE_CHECK_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t}\n\t\tret = PCI_ERS_RESULT_CAN_RECOVER;\n\t\tbreak;\n\tcase pci_channel_io_frozen:\n\t\tqla_pci_set_eeh_busy(vha);\n\t\tret = PCI_ERS_RESULT_NEED_RESET;\n\t\tbreak;\n\tcase pci_channel_io_perm_failure:\n\t\tha->flags.pci_channel_io_perm_failure = 1;\n\t\tqla2x00_abort_all_cmds(vha, DID_NO_CONNECT << 16);\n\t\tif (ql2xmqsupport || ql2xnvmeenable) {\n\t\t\tset_bit(QPAIR_ONLINE_CHECK_NEEDED, &vha->dpc_flags);\n\t\t\tqla2xxx_wake_dpc(vha);\n\t\t}\n\t\tret = PCI_ERS_RESULT_DISCONNECT;\n\t}\nout:\n\tql_dbg(ql_dbg_aer, vha, 0x600d,\n\t       \"PCI error detected returning [%x].\\n\", ret);\n\treturn ret;\n}\n\nstatic pci_ers_result_t\nqla2xxx_pci_mmio_enabled(struct pci_dev *pdev)\n{\n\tint risc_paused = 0;\n\tuint32_t stat;\n\tunsigned long flags;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(pdev);\n\tstruct qla_hw_data *ha = base_vha->hw;\n\tstruct device_reg_2xxx __iomem *reg = &ha->iobase->isp;\n\tstruct device_reg_24xx __iomem *reg24 = &ha->iobase->isp24;\n\n\tql_log(ql_log_warn, base_vha, 0x9000,\n\t       \"mmio enabled\\n\");\n\n\tha->pci_error_state = QLA_PCI_MMIO_ENABLED;\n\n\tif (IS_QLA82XX(ha))\n\t\treturn PCI_ERS_RESULT_RECOVERED;\n\n\tif (qla2x00_isp_reg_stat(ha)) {\n\t\tql_log(ql_log_info, base_vha, 0x803f,\n\t\t    \"During mmio enabled, PCI/Register disconnect still detected.\\n\");\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tif (IS_QLA2100(ha) || IS_QLA2200(ha)){\n\t\tstat = rd_reg_word(&reg->hccr);\n\t\tif (stat & HCCR_RISC_PAUSE)\n\t\t\trisc_paused = 1;\n\t} else if (IS_QLA23XX(ha)) {\n\t\tstat = rd_reg_dword(&reg->u.isp2300.host_status);\n\t\tif (stat & HSR_RISC_PAUSED)\n\t\t\trisc_paused = 1;\n\t} else if (IS_FWI2_CAPABLE(ha)) {\n\t\tstat = rd_reg_dword(&reg24->host_status);\n\t\tif (stat & HSRX_RISC_PAUSED)\n\t\t\trisc_paused = 1;\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (risc_paused) {\n\t\tql_log(ql_log_info, base_vha, 0x9003,\n\t\t    \"RISC paused -- mmio_enabled, Dumping firmware.\\n\");\n\t\tqla2xxx_dump_fw(base_vha);\n\t}\nout:\n\t \n\tql_dbg(ql_dbg_aer, base_vha, 0x600d,\n\t       \"mmio enabled returning.\\n\");\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t\nqla2xxx_pci_slot_reset(struct pci_dev *pdev)\n{\n\tpci_ers_result_t ret = PCI_ERS_RESULT_DISCONNECT;\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(pdev);\n\tstruct qla_hw_data *ha = base_vha->hw;\n\tint rc;\n\tstruct qla_qpair *qpair = NULL;\n\n\tql_log(ql_log_warn, base_vha, 0x9004,\n\t       \"Slot Reset.\\n\");\n\n\tha->pci_error_state = QLA_PCI_SLOT_RESET;\n\t \n\tpdev->error_state = pci_channel_io_normal;\n\n\tpci_restore_state(pdev);\n\n\t \n\tpci_save_state(pdev);\n\n\tif (ha->mem_only)\n\t\trc = pci_enable_device_mem(pdev);\n\telse\n\t\trc = pci_enable_device(pdev);\n\n\tif (rc) {\n\t\tql_log(ql_log_warn, base_vha, 0x9005,\n\t\t    \"Can't re-enable PCI device after reset.\\n\");\n\t\tgoto exit_slot_reset;\n\t}\n\n\n\tif (ha->isp_ops->pci_config(base_vha))\n\t\tgoto exit_slot_reset;\n\n\tmutex_lock(&ha->mq_lock);\n\tlist_for_each_entry(qpair, &base_vha->qp_list, qp_list_elem)\n\t\tqpair->online = 1;\n\tmutex_unlock(&ha->mq_lock);\n\n\tha->flags.eeh_busy = 0;\n\tbase_vha->flags.online = 1;\n\tset_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n\tha->isp_ops->abort_isp(base_vha);\n\tclear_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n\n\tif (qla2x00_isp_reg_stat(ha)) {\n\t\tha->flags.eeh_busy = 1;\n\t\tqla_pci_error_cleanup(base_vha);\n\t\tql_log(ql_log_warn, base_vha, 0x9005,\n\t\t       \"Device unable to recover from PCI error.\\n\");\n\t} else {\n\t\tret =  PCI_ERS_RESULT_RECOVERED;\n\t}\n\nexit_slot_reset:\n\tql_dbg(ql_dbg_aer, base_vha, 0x900e,\n\t    \"Slot Reset returning %x.\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void\nqla2xxx_pci_resume(struct pci_dev *pdev)\n{\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(pdev);\n\tstruct qla_hw_data *ha = base_vha->hw;\n\tint ret;\n\n\tql_log(ql_log_warn, base_vha, 0x900f,\n\t       \"Pci Resume.\\n\");\n\n\n\tret = qla2x00_wait_for_hba_online(base_vha);\n\tif (ret != QLA_SUCCESS) {\n\t\tql_log(ql_log_fatal, base_vha, 0x9002,\n\t\t    \"The device failed to resume I/O from slot/link_reset.\\n\");\n\t}\n\tha->pci_error_state = QLA_PCI_RESUME;\n\tql_dbg(ql_dbg_aer, base_vha, 0x600d,\n\t       \"Pci Resume returning.\\n\");\n}\n\nvoid qla_pci_set_eeh_busy(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\tbool do_cleanup = false;\n\tunsigned long flags;\n\n\tif (ha->flags.eeh_busy)\n\t\treturn;\n\n\tspin_lock_irqsave(&base_vha->work_lock, flags);\n\tif (!ha->flags.eeh_busy) {\n\t\tha->eeh_jif = jiffies;\n\t\tha->flags.eeh_flush = 0;\n\n\t\tha->flags.eeh_busy = 1;\n\t\tdo_cleanup = true;\n\t}\n\tspin_unlock_irqrestore(&base_vha->work_lock, flags);\n\n\tif (do_cleanup)\n\t\tqla_pci_error_cleanup(base_vha);\n}\n\n \nvoid qla_schedule_eeh_work(struct scsi_qla_host *vha)\n{\n\tstruct qla_hw_data *ha = vha->hw;\n\tstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\n\n\tif (ha->flags.eeh_busy)\n\t\treturn;\n\n\tset_bit(DO_EEH_RECOVERY, &base_vha->dpc_flags);\n\tqla2xxx_wake_dpc(base_vha);\n}\n\nstatic void\nqla_pci_reset_prepare(struct pci_dev *pdev)\n{\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(pdev);\n\tstruct qla_hw_data *ha = base_vha->hw;\n\tstruct qla_qpair *qpair;\n\n\tql_log(ql_log_warn, base_vha, 0xffff,\n\t    \"%s.\\n\", __func__);\n\n\t \n\tha->flags.eeh_busy = 1;\n\tmutex_lock(&ha->mq_lock);\n\tlist_for_each_entry(qpair, &base_vha->qp_list, qp_list_elem)\n\t\tqpair->online = 0;\n\tmutex_unlock(&ha->mq_lock);\n\n\tset_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n\tqla2x00_abort_isp_cleanup(base_vha);\n\tqla2x00_abort_all_cmds(base_vha, DID_RESET << 16);\n}\n\nstatic void\nqla_pci_reset_done(struct pci_dev *pdev)\n{\n\tscsi_qla_host_t *base_vha = pci_get_drvdata(pdev);\n\tstruct qla_hw_data *ha = base_vha->hw;\n\tstruct qla_qpair *qpair;\n\n\tql_log(ql_log_warn, base_vha, 0xffff,\n\t    \"%s.\\n\", __func__);\n\n\t \n\tha->flags.eeh_busy = 0;\n\tmutex_lock(&ha->mq_lock);\n\tlist_for_each_entry(qpair, &base_vha->qp_list, qp_list_elem)\n\t\tqpair->online = 1;\n\tmutex_unlock(&ha->mq_lock);\n\n\tbase_vha->flags.online = 1;\n\tha->isp_ops->abort_isp(base_vha);\n\tclear_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\n}\n\nstatic void qla2xxx_map_queues(struct Scsi_Host *shost)\n{\n\tscsi_qla_host_t *vha = (scsi_qla_host_t *)shost->hostdata;\n\tstruct blk_mq_queue_map *qmap = &shost->tag_set.map[HCTX_TYPE_DEFAULT];\n\n\tif (USER_CTRL_IRQ(vha->hw) || !vha->hw->mqiobase)\n\t\tblk_mq_map_queues(qmap);\n\telse\n\t\tblk_mq_pci_map_queues(qmap, vha->hw->pdev, vha->irq_offset);\n}\n\nstruct scsi_host_template qla2xxx_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= QLA2XXX_DRIVER_NAME,\n\t.queuecommand\t\t= qla2xxx_queuecommand,\n\n\t.eh_timed_out\t\t= fc_eh_timed_out,\n\t.eh_abort_handler\t= qla2xxx_eh_abort,\n\t.eh_should_retry_cmd\t= fc_eh_should_retry_cmd,\n\t.eh_device_reset_handler = qla2xxx_eh_device_reset,\n\t.eh_target_reset_handler = qla2xxx_eh_target_reset,\n\t.eh_bus_reset_handler\t= qla2xxx_eh_bus_reset,\n\t.eh_host_reset_handler\t= qla2xxx_eh_host_reset,\n\n\t.slave_configure\t= qla2xxx_slave_configure,\n\n\t.slave_alloc\t\t= qla2xxx_slave_alloc,\n\t.slave_destroy\t\t= qla2xxx_slave_destroy,\n\t.scan_finished\t\t= qla2xxx_scan_finished,\n\t.scan_start\t\t= qla2xxx_scan_start,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.map_queues             = qla2xxx_map_queues,\n\t.this_id\t\t= -1,\n\t.cmd_per_lun\t\t= 3,\n\t.sg_tablesize\t\t= SG_ALL,\n\n\t.max_sectors\t\t= 0xFFFF,\n\t.shost_groups\t\t= qla2x00_host_groups,\n\n\t.supported_mode\t\t= MODE_INITIATOR,\n\t.track_queue_depth\t= 1,\n\t.cmd_size\t\t= sizeof(srb_t),\n};\n\nstatic const struct pci_error_handlers qla2xxx_err_handler = {\n\t.error_detected = qla2xxx_pci_error_detected,\n\t.mmio_enabled = qla2xxx_pci_mmio_enabled,\n\t.slot_reset = qla2xxx_pci_slot_reset,\n\t.resume = qla2xxx_pci_resume,\n\t.reset_prepare = qla_pci_reset_prepare,\n\t.reset_done = qla_pci_reset_done,\n};\n\nstatic struct pci_device_id qla2xxx_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2100) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2200) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2300) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2312) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2322) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP6312) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP6322) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2422) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2432) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP8432) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP5422) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP5432) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2532) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2031) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP8001) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP8021) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP8031) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISPF001) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP8044) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2071) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2271) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2261) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2061) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2081) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2281) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2089) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2289) },\n\t{ 0 },\n};\nMODULE_DEVICE_TABLE(pci, qla2xxx_pci_tbl);\n\nstatic struct pci_driver qla2xxx_pci_driver = {\n\t.name\t\t= QLA2XXX_DRIVER_NAME,\n\t.driver\t\t= {\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n\t.id_table\t= qla2xxx_pci_tbl,\n\t.probe\t\t= qla2x00_probe_one,\n\t.remove\t\t= qla2x00_remove_one,\n\t.shutdown\t= qla2x00_shutdown,\n\t.err_handler\t= &qla2xxx_err_handler,\n};\n\nstatic const struct file_operations apidev_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n};\n\n \nstatic int __init\nqla2x00_module_init(void)\n{\n\tint ret = 0;\n\n\tBUILD_BUG_ON(sizeof(cmd_a64_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(cmd_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(cont_a64_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(cont_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(init_cb_t) != 96);\n\tBUILD_BUG_ON(sizeof(mrk_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(ms_iocb_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(request_t) != 64);\n\tBUILD_BUG_ON(sizeof(struct abort_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct abort_iocb_entry_fx00) != 64);\n\tBUILD_BUG_ON(sizeof(struct abts_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct access_chip_84xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct access_chip_rsp_84xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct cmd_bidir) != 64);\n\tBUILD_BUG_ON(sizeof(struct cmd_nvme) != 64);\n\tBUILD_BUG_ON(sizeof(struct cmd_type_6) != 64);\n\tBUILD_BUG_ON(sizeof(struct cmd_type_7) != 64);\n\tBUILD_BUG_ON(sizeof(struct cmd_type_7_fx00) != 64);\n\tBUILD_BUG_ON(sizeof(struct cmd_type_crc_2) != 64);\n\tBUILD_BUG_ON(sizeof(struct ct_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct ct_fdmi1_hba_attributes) != 2604);\n\tBUILD_BUG_ON(sizeof(struct ct_fdmi2_hba_attributes) != 4424);\n\tBUILD_BUG_ON(sizeof(struct ct_fdmi2_port_attributes) != 4164);\n\tBUILD_BUG_ON(sizeof(struct ct_fdmi_hba_attr) != 260);\n\tBUILD_BUG_ON(sizeof(struct ct_fdmi_port_attr) != 260);\n\tBUILD_BUG_ON(sizeof(struct ct_rsp_hdr) != 16);\n\tBUILD_BUG_ON(sizeof(struct ctio_crc2_to_fw) != 64);\n\tBUILD_BUG_ON(sizeof(struct device_reg_24xx) != 256);\n\tBUILD_BUG_ON(sizeof(struct device_reg_25xxmq) != 24);\n\tBUILD_BUG_ON(sizeof(struct device_reg_2xxx) != 256);\n\tBUILD_BUG_ON(sizeof(struct device_reg_82xx) != 1288);\n\tBUILD_BUG_ON(sizeof(struct device_reg_fx00) != 216);\n\tBUILD_BUG_ON(sizeof(struct els_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct els_sts_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct fxdisc_entry_fx00) != 64);\n\tBUILD_BUG_ON(sizeof(struct imm_ntfy_from_isp) != 64);\n\tBUILD_BUG_ON(sizeof(struct init_cb_24xx) != 128);\n\tBUILD_BUG_ON(sizeof(struct init_cb_81xx) != 128);\n\tBUILD_BUG_ON(sizeof(struct logio_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct mbx_entry) != 64);\n\tBUILD_BUG_ON(sizeof(struct mid_init_cb_24xx) != 5252);\n\tBUILD_BUG_ON(sizeof(struct mrk_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct nvram_24xx) != 512);\n\tBUILD_BUG_ON(sizeof(struct nvram_81xx) != 512);\n\tBUILD_BUG_ON(sizeof(struct pt_ls4_request) != 64);\n\tBUILD_BUG_ON(sizeof(struct pt_ls4_rx_unsol) != 64);\n\tBUILD_BUG_ON(sizeof(struct purex_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct qla2100_fw_dump) != 123634);\n\tBUILD_BUG_ON(sizeof(struct qla2300_fw_dump) != 136100);\n\tBUILD_BUG_ON(sizeof(struct qla24xx_fw_dump) != 37976);\n\tBUILD_BUG_ON(sizeof(struct qla25xx_fw_dump) != 39228);\n\tBUILD_BUG_ON(sizeof(struct qla2xxx_fce_chain) != 52);\n\tBUILD_BUG_ON(sizeof(struct qla2xxx_fw_dump) != 136172);\n\tBUILD_BUG_ON(sizeof(struct qla2xxx_mq_chain) != 524);\n\tBUILD_BUG_ON(sizeof(struct qla2xxx_mqueue_chain) != 8);\n\tBUILD_BUG_ON(sizeof(struct qla2xxx_mqueue_header) != 12);\n\tBUILD_BUG_ON(sizeof(struct qla2xxx_offld_chain) != 24);\n\tBUILD_BUG_ON(sizeof(struct qla81xx_fw_dump) != 39420);\n\tBUILD_BUG_ON(sizeof(struct qla82xx_uri_data_desc) != 28);\n\tBUILD_BUG_ON(sizeof(struct qla82xx_uri_table_desc) != 32);\n\tBUILD_BUG_ON(sizeof(struct qla83xx_fw_dump) != 51196);\n\tBUILD_BUG_ON(sizeof(struct qla_fcp_prio_cfg) != FCP_PRIO_CFG_SIZE);\n\tBUILD_BUG_ON(sizeof(struct qla_fdt_layout) != 128);\n\tBUILD_BUG_ON(sizeof(struct qla_flt_header) != 8);\n\tBUILD_BUG_ON(sizeof(struct qla_flt_region) != 16);\n\tBUILD_BUG_ON(sizeof(struct qla_npiv_entry) != 24);\n\tBUILD_BUG_ON(sizeof(struct qla_npiv_header) != 16);\n\tBUILD_BUG_ON(sizeof(struct rdp_rsp_payload) != 336);\n\tBUILD_BUG_ON(sizeof(struct sns_cmd_pkt) != 2064);\n\tBUILD_BUG_ON(sizeof(struct sts_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct tsk_mgmt_entry) != 64);\n\tBUILD_BUG_ON(sizeof(struct tsk_mgmt_entry_fx00) != 64);\n\tBUILD_BUG_ON(sizeof(struct verify_chip_entry_84xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct verify_chip_rsp_84xx) != 52);\n\tBUILD_BUG_ON(sizeof(struct vf_evfp_entry_24xx) != 56);\n\tBUILD_BUG_ON(sizeof(struct vp_config_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct vp_ctrl_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(struct vp_rpt_id_entry_24xx) != 64);\n\tBUILD_BUG_ON(sizeof(sts21_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(sts22_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(sts_cont_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(sts_entry_t) != 64);\n\tBUILD_BUG_ON(sizeof(sw_info_t) != 32);\n\tBUILD_BUG_ON(sizeof(target_id_t) != 2);\n\n\tqla_trace_init();\n\n\t \n\tsrb_cachep = kmem_cache_create(\"qla2xxx_srbs\", sizeof(srb_t), 0,\n\t    SLAB_HWCACHE_ALIGN, NULL);\n\tif (srb_cachep == NULL) {\n\t\tql_log(ql_log_fatal, NULL, 0x0001,\n\t\t    \"Unable to allocate SRB cache...Failing load!.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = qlt_init();\n\tif (ret < 0) {\n\t\tgoto destroy_cache;\n\t} else if (ret > 0) {\n\t\t \n\t\tqla2xxx_transport_functions.disable_target_scan = 1;\n\t\tqla2xxx_transport_vport_functions.disable_target_scan = 1;\n\t}\n\n\t \n\tstrcpy(qla2x00_version_str, QLA2XXX_VERSION);\n\tif (ql2xextended_error_logging)\n\t\tstrcat(qla2x00_version_str, \"-debug\");\n\tif (ql2xextended_error_logging == 1)\n\t\tql2xextended_error_logging = QL_DBG_DEFAULT1_MASK;\n\n\tqla2xxx_transport_template =\n\t    fc_attach_transport(&qla2xxx_transport_functions);\n\tif (!qla2xxx_transport_template) {\n\t\tql_log(ql_log_fatal, NULL, 0x0002,\n\t\t    \"fc_attach_transport failed...Failing load!.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto qlt_exit;\n\t}\n\n\tapidev_major = register_chrdev(0, QLA2XXX_APIDEV, &apidev_fops);\n\tif (apidev_major < 0) {\n\t\tql_log(ql_log_fatal, NULL, 0x0003,\n\t\t    \"Unable to register char device %s.\\n\", QLA2XXX_APIDEV);\n\t}\n\n\tqla2xxx_transport_vport_template =\n\t    fc_attach_transport(&qla2xxx_transport_vport_functions);\n\tif (!qla2xxx_transport_vport_template) {\n\t\tql_log(ql_log_fatal, NULL, 0x0004,\n\t\t    \"fc_attach_transport vport failed...Failing load!.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto unreg_chrdev;\n\t}\n\tql_log(ql_log_info, NULL, 0x0005,\n\t    \"QLogic Fibre Channel HBA Driver: %s.\\n\",\n\t    qla2x00_version_str);\n\tret = pci_register_driver(&qla2xxx_pci_driver);\n\tif (ret) {\n\t\tql_log(ql_log_fatal, NULL, 0x0006,\n\t\t    \"pci_register_driver failed...ret=%d Failing load!.\\n\",\n\t\t    ret);\n\t\tgoto release_vport_transport;\n\t}\n\treturn ret;\n\nrelease_vport_transport:\n\tfc_release_transport(qla2xxx_transport_vport_template);\n\nunreg_chrdev:\n\tif (apidev_major >= 0)\n\t\tunregister_chrdev(apidev_major, QLA2XXX_APIDEV);\n\tfc_release_transport(qla2xxx_transport_template);\n\nqlt_exit:\n\tqlt_exit();\n\ndestroy_cache:\n\tkmem_cache_destroy(srb_cachep);\n\n\tqla_trace_uninit();\n\treturn ret;\n}\n\n \nstatic void __exit\nqla2x00_module_exit(void)\n{\n\tpci_unregister_driver(&qla2xxx_pci_driver);\n\tqla2x00_release_firmware();\n\tkmem_cache_destroy(ctx_cachep);\n\tfc_release_transport(qla2xxx_transport_vport_template);\n\tif (apidev_major >= 0)\n\t\tunregister_chrdev(apidev_major, QLA2XXX_APIDEV);\n\tfc_release_transport(qla2xxx_transport_template);\n\tqlt_exit();\n\tkmem_cache_destroy(srb_cachep);\n\tqla_trace_uninit();\n}\n\nmodule_init(qla2x00_module_init);\nmodule_exit(qla2x00_module_exit);\n\nMODULE_AUTHOR(\"QLogic Corporation\");\nMODULE_DESCRIPTION(\"QLogic Fibre Channel HBA Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FW_FILE_ISP21XX);\nMODULE_FIRMWARE(FW_FILE_ISP22XX);\nMODULE_FIRMWARE(FW_FILE_ISP2300);\nMODULE_FIRMWARE(FW_FILE_ISP2322);\nMODULE_FIRMWARE(FW_FILE_ISP24XX);\nMODULE_FIRMWARE(FW_FILE_ISP25XX);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}