{
  "module_name": "jazz_esp.c",
  "hash_id": "71f466579d79d340c63e7b69b394fc84e108a8d2866decd258330c130e1e6451",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/jazz_esp.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#include <asm/jazz.h>\n#include <asm/jazzdma.h>\n\n#include <scsi/scsi_host.h>\n\n#include \"esp_scsi.h\"\n\n#define DRV_MODULE_NAME\t\t\"jazz_esp\"\n#define PFX DRV_MODULE_NAME\t\": \"\n#define DRV_VERSION\t\t\"1.000\"\n#define DRV_MODULE_RELDATE\t\"May 19, 2007\"\n\nstatic void jazz_esp_write8(struct esp *esp, u8 val, unsigned long reg)\n{\n\t*(volatile u8 *)(esp->regs + reg) = val;\n}\n\nstatic u8 jazz_esp_read8(struct esp *esp, unsigned long reg)\n{\n\treturn *(volatile u8 *)(esp->regs + reg);\n}\n\nstatic int jazz_esp_irq_pending(struct esp *esp)\n{\n\tif (jazz_esp_read8(esp, ESP_STATUS) & ESP_STAT_INTR)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void jazz_esp_reset_dma(struct esp *esp)\n{\n\tvdma_disable ((int)esp->dma_regs);\n}\n\nstatic void jazz_esp_dma_drain(struct esp *esp)\n{\n\t \n}\n\nstatic void jazz_esp_dma_invalidate(struct esp *esp)\n{\n\tvdma_disable ((int)esp->dma_regs);\n}\n\nstatic void jazz_esp_send_dma_cmd(struct esp *esp, u32 addr, u32 esp_count,\n\t\t\t\t  u32 dma_count, int write, u8 cmd)\n{\n\tBUG_ON(!(cmd & ESP_CMD_DMA));\n\n\tjazz_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);\n\tjazz_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);\n\tvdma_disable ((int)esp->dma_regs);\n\tif (write)\n\t\tvdma_set_mode ((int)esp->dma_regs, DMA_MODE_READ);\n\telse\n\t\tvdma_set_mode ((int)esp->dma_regs, DMA_MODE_WRITE);\n\n\tvdma_set_addr ((int)esp->dma_regs, addr);\n\tvdma_set_count ((int)esp->dma_regs, dma_count);\n\tvdma_enable ((int)esp->dma_regs);\n\n\tscsi_esp_cmd(esp, cmd);\n}\n\nstatic int jazz_esp_dma_error(struct esp *esp)\n{\n\tu32 enable = vdma_get_enable((int)esp->dma_regs);\n\n\tif (enable & (R4030_MEM_INTR|R4030_ADDR_INTR))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic const struct esp_driver_ops jazz_esp_ops = {\n\t.esp_write8\t=\tjazz_esp_write8,\n\t.esp_read8\t=\tjazz_esp_read8,\n\t.irq_pending\t=\tjazz_esp_irq_pending,\n\t.reset_dma\t=\tjazz_esp_reset_dma,\n\t.dma_drain\t=\tjazz_esp_dma_drain,\n\t.dma_invalidate\t=\tjazz_esp_dma_invalidate,\n\t.send_dma_cmd\t=\tjazz_esp_send_dma_cmd,\n\t.dma_error\t=\tjazz_esp_dma_error,\n};\n\nstatic int esp_jazz_probe(struct platform_device *dev)\n{\n\tconst struct scsi_host_template *tpnt = &scsi_esp_template;\n\tstruct Scsi_Host *host;\n\tstruct esp *esp;\n\tstruct resource *res;\n\tint err;\n\n\thost = scsi_host_alloc(tpnt, sizeof(struct esp));\n\n\terr = -ENOMEM;\n\tif (!host)\n\t\tgoto fail;\n\n\thost->max_id = 8;\n\tesp = shost_priv(host);\n\n\tesp->host = host;\n\tesp->dev = &dev->dev;\n\tesp->ops = &jazz_esp_ops;\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\tgoto fail_unlink;\n\n\tesp->regs = (void __iomem *)res->start;\n\tif (!esp->regs)\n\t\tgoto fail_unlink;\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 1);\n\tif (!res)\n\t\tgoto fail_unlink;\n\n\tesp->dma_regs = (void __iomem *)res->start;\n\n\tesp->command_block = dma_alloc_coherent(esp->dev, 16,\n\t\t\t\t\t\t&esp->command_block_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!esp->command_block)\n\t\tgoto fail_unmap_regs;\n\n\thost->irq = err = platform_get_irq(dev, 0);\n\tif (err < 0)\n\t\tgoto fail_unmap_command_block;\n\terr = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED, \"ESP\", esp);\n\tif (err < 0)\n\t\tgoto fail_unmap_command_block;\n\n\tesp->scsi_id = 7;\n\tesp->host->this_id = esp->scsi_id;\n\tesp->scsi_id_mask = (1 << esp->scsi_id);\n\tesp->cfreq = 40000000;\n\n\tdev_set_drvdata(&dev->dev, esp);\n\n\terr = scsi_esp_register(esp);\n\tif (err)\n\t\tgoto fail_free_irq;\n\n\treturn 0;\n\nfail_free_irq:\n\tfree_irq(host->irq, esp);\nfail_unmap_command_block:\n\tdma_free_coherent(esp->dev, 16,\n\t\t\t  esp->command_block,\n\t\t\t  esp->command_block_dma);\nfail_unmap_regs:\nfail_unlink:\n\tscsi_host_put(host);\nfail:\n\treturn err;\n}\n\nstatic int esp_jazz_remove(struct platform_device *dev)\n{\n\tstruct esp *esp = dev_get_drvdata(&dev->dev);\n\tunsigned int irq = esp->host->irq;\n\n\tscsi_esp_unregister(esp);\n\n\tfree_irq(irq, esp);\n\tdma_free_coherent(esp->dev, 16,\n\t\t\t  esp->command_block,\n\t\t\t  esp->command_block_dma);\n\n\tscsi_host_put(esp->host);\n\n\treturn 0;\n}\n\n \nMODULE_ALIAS(\"platform:jazz_esp\");\n\nstatic struct platform_driver esp_jazz_driver = {\n\t.probe\t\t= esp_jazz_probe,\n\t.remove\t\t= esp_jazz_remove,\n\t.driver\t= {\n\t\t.name\t= \"jazz_esp\",\n\t},\n};\nmodule_platform_driver(esp_jazz_driver);\n\nMODULE_DESCRIPTION(\"JAZZ ESP SCSI driver\");\nMODULE_AUTHOR(\"Thomas Bogendoerfer (tsbogend@alpha.franken.de)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}