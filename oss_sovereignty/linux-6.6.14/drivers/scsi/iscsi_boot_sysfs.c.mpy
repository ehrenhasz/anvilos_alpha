{
  "module_name": "iscsi_boot_sysfs.c",
  "hash_id": "cdb1e6cf842af6c1d4bf26c1639d16c270b8314dcbfb29e2ffb983ddff099252",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/iscsi_boot_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/capability.h>\n#include <linux/iscsi_boot_sysfs.h>\n\n\nMODULE_AUTHOR(\"Mike Christie <michaelc@cs.wisc.edu>\");\nMODULE_DESCRIPTION(\"sysfs interface and helpers to export iSCSI boot information\");\nMODULE_LICENSE(\"GPL\");\n \nstruct iscsi_boot_attr {\n\tstruct attribute attr;\n\tint type;\n\tssize_t (*show) (void *data, int type, char *buf);\n};\n\n \nstatic ssize_t iscsi_boot_show_attribute(struct kobject *kobj,\n\t\t\t\t\t struct attribute *attr, char *buf)\n{\n\tstruct iscsi_boot_kobj *boot_kobj =\n\t\t\tcontainer_of(kobj, struct iscsi_boot_kobj, kobj);\n\tstruct iscsi_boot_attr *boot_attr =\n\t\t\tcontainer_of(attr, struct iscsi_boot_attr, attr);\n\tssize_t ret = -EIO;\n\tchar *str = buf;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tif (boot_kobj->show)\n\t\tret = boot_kobj->show(boot_kobj->data, boot_attr->type, str);\n\treturn ret;\n}\n\nstatic const struct sysfs_ops iscsi_boot_attr_ops = {\n\t.show = iscsi_boot_show_attribute,\n};\n\nstatic void iscsi_boot_kobj_release(struct kobject *kobj)\n{\n\tstruct iscsi_boot_kobj *boot_kobj =\n\t\t\tcontainer_of(kobj, struct iscsi_boot_kobj, kobj);\n\n\tif (boot_kobj->release)\n\t\tboot_kobj->release(boot_kobj->data);\n\tkfree(boot_kobj);\n}\n\nstatic struct kobj_type iscsi_boot_ktype = {\n\t.release = iscsi_boot_kobj_release,\n\t.sysfs_ops = &iscsi_boot_attr_ops,\n};\n\n#define iscsi_boot_rd_attr(fnname, sysfs_name, attr_type)\t\t\\\nstatic struct iscsi_boot_attr iscsi_boot_attr_##fnname = {\t\\\n\t.attr\t= { .name = __stringify(sysfs_name), .mode = 0444 },\t\\\n\t.type\t= attr_type,\t\t\t\t\t\t\\\n}\n\n \niscsi_boot_rd_attr(tgt_index, index, ISCSI_BOOT_TGT_INDEX);\niscsi_boot_rd_attr(tgt_flags, flags, ISCSI_BOOT_TGT_FLAGS);\niscsi_boot_rd_attr(tgt_ip, ip-addr, ISCSI_BOOT_TGT_IP_ADDR);\niscsi_boot_rd_attr(tgt_port, port, ISCSI_BOOT_TGT_PORT);\niscsi_boot_rd_attr(tgt_lun, lun, ISCSI_BOOT_TGT_LUN);\niscsi_boot_rd_attr(tgt_chap, chap-type, ISCSI_BOOT_TGT_CHAP_TYPE);\niscsi_boot_rd_attr(tgt_nic, nic-assoc, ISCSI_BOOT_TGT_NIC_ASSOC);\niscsi_boot_rd_attr(tgt_name, target-name, ISCSI_BOOT_TGT_NAME);\niscsi_boot_rd_attr(tgt_chap_name, chap-name, ISCSI_BOOT_TGT_CHAP_NAME);\niscsi_boot_rd_attr(tgt_chap_secret, chap-secret, ISCSI_BOOT_TGT_CHAP_SECRET);\niscsi_boot_rd_attr(tgt_chap_rev_name, rev-chap-name,\n\t\t   ISCSI_BOOT_TGT_REV_CHAP_NAME);\niscsi_boot_rd_attr(tgt_chap_rev_secret, rev-chap-name-secret,\n\t\t   ISCSI_BOOT_TGT_REV_CHAP_SECRET);\n\nstatic struct attribute *target_attrs[] = {\n\t&iscsi_boot_attr_tgt_index.attr,\n\t&iscsi_boot_attr_tgt_flags.attr,\n\t&iscsi_boot_attr_tgt_ip.attr,\n\t&iscsi_boot_attr_tgt_port.attr,\n\t&iscsi_boot_attr_tgt_lun.attr,\n\t&iscsi_boot_attr_tgt_chap.attr,\n\t&iscsi_boot_attr_tgt_nic.attr,\n\t&iscsi_boot_attr_tgt_name.attr,\n\t&iscsi_boot_attr_tgt_chap_name.attr,\n\t&iscsi_boot_attr_tgt_chap_secret.attr,\n\t&iscsi_boot_attr_tgt_chap_rev_name.attr,\n\t&iscsi_boot_attr_tgt_chap_rev_secret.attr,\n\tNULL\n};\n\nstatic umode_t iscsi_boot_tgt_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int i)\n{\n\tstruct iscsi_boot_kobj *boot_kobj =\n\t\t\tcontainer_of(kobj, struct iscsi_boot_kobj, kobj);\n\n\tif (attr ==  &iscsi_boot_attr_tgt_index.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_INDEX);\n\telse if (attr == &iscsi_boot_attr_tgt_flags.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_FLAGS);\n\telse if (attr == &iscsi_boot_attr_tgt_ip.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t      ISCSI_BOOT_TGT_IP_ADDR);\n\telse if (attr == &iscsi_boot_attr_tgt_port.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t      ISCSI_BOOT_TGT_PORT);\n\telse if (attr == &iscsi_boot_attr_tgt_lun.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t      ISCSI_BOOT_TGT_LUN);\n\telse if (attr == &iscsi_boot_attr_tgt_chap.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_CHAP_TYPE);\n\telse if (attr == &iscsi_boot_attr_tgt_nic.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_NIC_ASSOC);\n\telse if (attr == &iscsi_boot_attr_tgt_name.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_NAME);\n\telse if (attr == &iscsi_boot_attr_tgt_chap_name.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_CHAP_NAME);\n\telse if (attr == &iscsi_boot_attr_tgt_chap_secret.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_CHAP_SECRET);\n\telse if (attr == &iscsi_boot_attr_tgt_chap_rev_name.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_REV_CHAP_NAME);\n\telse if (attr == &iscsi_boot_attr_tgt_chap_rev_secret.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_TGT_REV_CHAP_SECRET);\n\treturn 0;\n}\n\nstatic struct attribute_group iscsi_boot_target_attr_group = {\n\t.attrs = target_attrs,\n\t.is_visible = iscsi_boot_tgt_attr_is_visible,\n};\n\n \niscsi_boot_rd_attr(eth_index, index, ISCSI_BOOT_ETH_INDEX);\niscsi_boot_rd_attr(eth_flags, flags, ISCSI_BOOT_ETH_FLAGS);\niscsi_boot_rd_attr(eth_ip, ip-addr, ISCSI_BOOT_ETH_IP_ADDR);\niscsi_boot_rd_attr(eth_prefix, prefix-len, ISCSI_BOOT_ETH_PREFIX_LEN);\niscsi_boot_rd_attr(eth_subnet, subnet-mask, ISCSI_BOOT_ETH_SUBNET_MASK);\niscsi_boot_rd_attr(eth_origin, origin, ISCSI_BOOT_ETH_ORIGIN);\niscsi_boot_rd_attr(eth_gateway, gateway, ISCSI_BOOT_ETH_GATEWAY);\niscsi_boot_rd_attr(eth_primary_dns, primary-dns, ISCSI_BOOT_ETH_PRIMARY_DNS);\niscsi_boot_rd_attr(eth_secondary_dns, secondary-dns,\n\t\t   ISCSI_BOOT_ETH_SECONDARY_DNS);\niscsi_boot_rd_attr(eth_dhcp, dhcp, ISCSI_BOOT_ETH_DHCP);\niscsi_boot_rd_attr(eth_vlan, vlan, ISCSI_BOOT_ETH_VLAN);\niscsi_boot_rd_attr(eth_mac, mac, ISCSI_BOOT_ETH_MAC);\niscsi_boot_rd_attr(eth_hostname, hostname, ISCSI_BOOT_ETH_HOSTNAME);\n\nstatic struct attribute *ethernet_attrs[] = {\n\t&iscsi_boot_attr_eth_index.attr,\n\t&iscsi_boot_attr_eth_flags.attr,\n\t&iscsi_boot_attr_eth_ip.attr,\n\t&iscsi_boot_attr_eth_prefix.attr,\n\t&iscsi_boot_attr_eth_subnet.attr,\n\t&iscsi_boot_attr_eth_origin.attr,\n\t&iscsi_boot_attr_eth_gateway.attr,\n\t&iscsi_boot_attr_eth_primary_dns.attr,\n\t&iscsi_boot_attr_eth_secondary_dns.attr,\n\t&iscsi_boot_attr_eth_dhcp.attr,\n\t&iscsi_boot_attr_eth_vlan.attr,\n\t&iscsi_boot_attr_eth_mac.attr,\n\t&iscsi_boot_attr_eth_hostname.attr,\n\tNULL\n};\n\nstatic umode_t iscsi_boot_eth_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int i)\n{\n\tstruct iscsi_boot_kobj *boot_kobj =\n\t\t\tcontainer_of(kobj, struct iscsi_boot_kobj, kobj);\n\n\tif (attr ==  &iscsi_boot_attr_eth_index.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_INDEX);\n\telse if (attr ==  &iscsi_boot_attr_eth_flags.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_FLAGS);\n\telse if (attr ==  &iscsi_boot_attr_eth_ip.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_IP_ADDR);\n\telse if (attr ==  &iscsi_boot_attr_eth_prefix.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_PREFIX_LEN);\n\telse if (attr ==  &iscsi_boot_attr_eth_subnet.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_SUBNET_MASK);\n\telse if (attr ==  &iscsi_boot_attr_eth_origin.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_ORIGIN);\n\telse if (attr ==  &iscsi_boot_attr_eth_gateway.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_GATEWAY);\n\telse if (attr ==  &iscsi_boot_attr_eth_primary_dns.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_PRIMARY_DNS);\n\telse if (attr ==  &iscsi_boot_attr_eth_secondary_dns.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_SECONDARY_DNS);\n\telse if (attr ==  &iscsi_boot_attr_eth_dhcp.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_DHCP);\n\telse if (attr ==  &iscsi_boot_attr_eth_vlan.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_VLAN);\n\telse if (attr ==  &iscsi_boot_attr_eth_mac.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_MAC);\n\telse if (attr ==  &iscsi_boot_attr_eth_hostname.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ETH_HOSTNAME);\n\treturn 0;\n}\n\nstatic struct attribute_group iscsi_boot_ethernet_attr_group = {\n\t.attrs = ethernet_attrs,\n\t.is_visible = iscsi_boot_eth_attr_is_visible,\n};\n\n \niscsi_boot_rd_attr(ini_index, index, ISCSI_BOOT_INI_INDEX);\niscsi_boot_rd_attr(ini_flags, flags, ISCSI_BOOT_INI_FLAGS);\niscsi_boot_rd_attr(ini_isns, isns-server, ISCSI_BOOT_INI_ISNS_SERVER);\niscsi_boot_rd_attr(ini_slp, slp-server, ISCSI_BOOT_INI_SLP_SERVER);\niscsi_boot_rd_attr(ini_primary_radius, pri-radius-server,\n\t\t   ISCSI_BOOT_INI_PRI_RADIUS_SERVER);\niscsi_boot_rd_attr(ini_secondary_radius, sec-radius-server,\n\t\t   ISCSI_BOOT_INI_SEC_RADIUS_SERVER);\niscsi_boot_rd_attr(ini_name, initiator-name, ISCSI_BOOT_INI_INITIATOR_NAME);\n\nstatic struct attribute *initiator_attrs[] = {\n\t&iscsi_boot_attr_ini_index.attr,\n\t&iscsi_boot_attr_ini_flags.attr,\n\t&iscsi_boot_attr_ini_isns.attr,\n\t&iscsi_boot_attr_ini_slp.attr,\n\t&iscsi_boot_attr_ini_primary_radius.attr,\n\t&iscsi_boot_attr_ini_secondary_radius.attr,\n\t&iscsi_boot_attr_ini_name.attr,\n\tNULL\n};\n\nstatic umode_t iscsi_boot_ini_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int i)\n{\n\tstruct iscsi_boot_kobj *boot_kobj =\n\t\t\tcontainer_of(kobj, struct iscsi_boot_kobj, kobj);\n\n\tif (attr ==  &iscsi_boot_attr_ini_index.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_INI_INDEX);\n\tif (attr ==  &iscsi_boot_attr_ini_flags.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_INI_FLAGS);\n\tif (attr ==  &iscsi_boot_attr_ini_isns.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_INI_ISNS_SERVER);\n\tif (attr ==  &iscsi_boot_attr_ini_slp.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_INI_SLP_SERVER);\n\tif (attr ==  &iscsi_boot_attr_ini_primary_radius.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_INI_PRI_RADIUS_SERVER);\n\tif (attr ==  &iscsi_boot_attr_ini_secondary_radius.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_INI_SEC_RADIUS_SERVER);\n\tif (attr ==  &iscsi_boot_attr_ini_name.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_INI_INITIATOR_NAME);\n\n\treturn 0;\n}\n\nstatic struct attribute_group iscsi_boot_initiator_attr_group = {\n\t.attrs = initiator_attrs,\n\t.is_visible = iscsi_boot_ini_attr_is_visible,\n};\n\n \niscsi_boot_rd_attr(acpitbl_signature, signature, ISCSI_BOOT_ACPITBL_SIGNATURE);\niscsi_boot_rd_attr(acpitbl_oem_id, oem_id, ISCSI_BOOT_ACPITBL_OEM_ID);\niscsi_boot_rd_attr(acpitbl_oem_table_id, oem_table_id,\n\t\t   ISCSI_BOOT_ACPITBL_OEM_TABLE_ID);\n\nstatic struct attribute *acpitbl_attrs[] = {\n\t&iscsi_boot_attr_acpitbl_signature.attr,\n\t&iscsi_boot_attr_acpitbl_oem_id.attr,\n\t&iscsi_boot_attr_acpitbl_oem_table_id.attr,\n\tNULL\n};\n\nstatic umode_t iscsi_boot_acpitbl_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int i)\n{\n\tstruct iscsi_boot_kobj *boot_kobj =\n\t\t\tcontainer_of(kobj, struct iscsi_boot_kobj, kobj);\n\n\tif (attr ==  &iscsi_boot_attr_acpitbl_signature.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ACPITBL_SIGNATURE);\n\tif (attr ==  &iscsi_boot_attr_acpitbl_oem_id.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ACPITBL_OEM_ID);\n\tif (attr ==  &iscsi_boot_attr_acpitbl_oem_table_id.attr)\n\t\treturn boot_kobj->is_visible(boot_kobj->data,\n\t\t\t\t\t     ISCSI_BOOT_ACPITBL_OEM_TABLE_ID);\n\treturn 0;\n}\n\nstatic struct attribute_group iscsi_boot_acpitbl_attr_group = {\n\t.attrs = acpitbl_attrs,\n\t.is_visible = iscsi_boot_acpitbl_attr_is_visible,\n};\n\nstatic struct iscsi_boot_kobj *\niscsi_boot_create_kobj(struct iscsi_boot_kset *boot_kset,\n\t\t       struct attribute_group *attr_group,\n\t\t       const char *name, int index, void *data,\n\t\t       ssize_t (*show) (void *data, int type, char *buf),\n\t\t       umode_t (*is_visible) (void *data, int type),\n\t\t       void (*release) (void *data))\n{\n\tstruct iscsi_boot_kobj *boot_kobj;\n\n\tboot_kobj = kzalloc(sizeof(*boot_kobj), GFP_KERNEL);\n\tif (!boot_kobj)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&boot_kobj->list);\n\n\tboot_kobj->kobj.kset = boot_kset->kset;\n\tif (kobject_init_and_add(&boot_kobj->kobj, &iscsi_boot_ktype,\n\t\t\t\t NULL, name, index)) {\n\t\tkobject_put(&boot_kobj->kobj);\n\t\treturn NULL;\n\t}\n\tboot_kobj->data = data;\n\tboot_kobj->show = show;\n\tboot_kobj->is_visible = is_visible;\n\tboot_kobj->release = release;\n\n\tif (sysfs_create_group(&boot_kobj->kobj, attr_group)) {\n\t\t \n\t\tboot_kobj->release = NULL;\n\t\tkobject_put(&boot_kobj->kobj);\n\t\treturn NULL;\n\t}\n\tboot_kobj->attr_group = attr_group;\n\n\tkobject_uevent(&boot_kobj->kobj, KOBJ_ADD);\n\t \n\tlist_add_tail(&boot_kobj->list, &boot_kset->kobj_list);\n\treturn boot_kobj;\n}\n\nstatic void iscsi_boot_remove_kobj(struct iscsi_boot_kobj *boot_kobj)\n{\n\tlist_del(&boot_kobj->list);\n\tsysfs_remove_group(&boot_kobj->kobj, boot_kobj->attr_group);\n\tkobject_put(&boot_kobj->kobj);\n}\n\n \nstruct iscsi_boot_kobj *\niscsi_boot_create_target(struct iscsi_boot_kset *boot_kset, int index,\n\t\t\t void *data,\n\t\t\t ssize_t (*show) (void *data, int type, char *buf),\n\t\t\t umode_t (*is_visible) (void *data, int type),\n\t\t\t void (*release) (void *data))\n{\n\treturn iscsi_boot_create_kobj(boot_kset, &iscsi_boot_target_attr_group,\n\t\t\t\t      \"target%d\", index, data, show, is_visible,\n\t\t\t\t      release);\n}\nEXPORT_SYMBOL_GPL(iscsi_boot_create_target);\n\n \nstruct iscsi_boot_kobj *\niscsi_boot_create_initiator(struct iscsi_boot_kset *boot_kset, int index,\n\t\t\t    void *data,\n\t\t\t    ssize_t (*show) (void *data, int type, char *buf),\n\t\t\t    umode_t (*is_visible) (void *data, int type),\n\t\t\t    void (*release) (void *data))\n{\n\treturn iscsi_boot_create_kobj(boot_kset,\n\t\t\t\t      &iscsi_boot_initiator_attr_group,\n\t\t\t\t      \"initiator\", index, data, show,\n\t\t\t\t      is_visible, release);\n}\nEXPORT_SYMBOL_GPL(iscsi_boot_create_initiator);\n\n \nstruct iscsi_boot_kobj *\niscsi_boot_create_ethernet(struct iscsi_boot_kset *boot_kset, int index,\n\t\t\t   void *data,\n\t\t\t   ssize_t (*show) (void *data, int type, char *buf),\n\t\t\t   umode_t (*is_visible) (void *data, int type),\n\t\t\t   void (*release) (void *data))\n{\n\treturn iscsi_boot_create_kobj(boot_kset,\n\t\t\t\t      &iscsi_boot_ethernet_attr_group,\n\t\t\t\t      \"ethernet%d\", index, data, show,\n\t\t\t\t      is_visible, release);\n}\nEXPORT_SYMBOL_GPL(iscsi_boot_create_ethernet);\n\n \nstruct iscsi_boot_kobj *\niscsi_boot_create_acpitbl(struct iscsi_boot_kset *boot_kset, int index,\n\t\t\t   void *data,\n\t\t\t   ssize_t (*show)(void *data, int type, char *buf),\n\t\t\t   umode_t (*is_visible)(void *data, int type),\n\t\t\t   void (*release)(void *data))\n{\n\treturn iscsi_boot_create_kobj(boot_kset,\n\t\t\t\t      &iscsi_boot_acpitbl_attr_group,\n\t\t\t\t      \"acpi_header\", index, data, show,\n\t\t\t\t      is_visible, release);\n}\nEXPORT_SYMBOL_GPL(iscsi_boot_create_acpitbl);\n\n \nstruct iscsi_boot_kset *iscsi_boot_create_kset(const char *set_name)\n{\n\tstruct iscsi_boot_kset *boot_kset;\n\n\tboot_kset = kzalloc(sizeof(*boot_kset), GFP_KERNEL);\n\tif (!boot_kset)\n\t\treturn NULL;\n\n\tboot_kset->kset = kset_create_and_add(set_name, NULL, firmware_kobj);\n\tif (!boot_kset->kset) {\n\t\tkfree(boot_kset);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&boot_kset->kobj_list);\n\treturn boot_kset;\n}\nEXPORT_SYMBOL_GPL(iscsi_boot_create_kset);\n\n \nstruct iscsi_boot_kset *iscsi_boot_create_host_kset(unsigned int hostno)\n{\n\tstruct iscsi_boot_kset *boot_kset;\n\tchar *set_name;\n\n\tset_name = kasprintf(GFP_KERNEL, \"iscsi_boot%u\", hostno);\n\tif (!set_name)\n\t\treturn NULL;\n\n\tboot_kset = iscsi_boot_create_kset(set_name);\n\tkfree(set_name);\n\treturn boot_kset;\n}\nEXPORT_SYMBOL_GPL(iscsi_boot_create_host_kset);\n\n \nvoid iscsi_boot_destroy_kset(struct iscsi_boot_kset *boot_kset)\n{\n\tstruct iscsi_boot_kobj *boot_kobj, *tmp_kobj;\n\n\tif (!boot_kset)\n\t\treturn;\n\n\tlist_for_each_entry_safe(boot_kobj, tmp_kobj,\n\t\t\t\t &boot_kset->kobj_list, list)\n\t\tiscsi_boot_remove_kobj(boot_kobj);\n\n\tkset_unregister(boot_kset->kset);\n\tkfree(boot_kset);\n}\nEXPORT_SYMBOL_GPL(iscsi_boot_destroy_kset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}