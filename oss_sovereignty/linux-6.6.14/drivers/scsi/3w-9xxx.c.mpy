{
  "module_name": "3w-9xxx.c",
  "hash_id": "a7b2fc00d503882ebf8fa762ce40d223cc98d027effb3ad105af44405b479abd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/3w-9xxx.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_cmnd.h>\n#include \"3w-9xxx.h\"\n\n \n#define TW_DRIVER_VERSION \"2.26.02.014\"\nstatic DEFINE_MUTEX(twa_chrdev_mutex);\nstatic TW_Device_Extension *twa_device_extension_list[TW_MAX_SLOT];\nstatic unsigned int twa_device_extension_count;\nstatic int twa_major = -1;\nextern struct timezone sys_tz;\n\n \nMODULE_AUTHOR (\"LSI\");\nMODULE_DESCRIPTION (\"3ware 9000 Storage Controller Linux Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(TW_DRIVER_VERSION);\n\nstatic int use_msi = 0;\nmodule_param(use_msi, int, S_IRUGO);\nMODULE_PARM_DESC(use_msi, \"Use Message Signaled Interrupts.  Default: 0\");\n\n \nstatic void twa_aen_queue_event(TW_Device_Extension *tw_dev, TW_Command_Apache_Header *header);\nstatic int twa_aen_read_queue(TW_Device_Extension *tw_dev, int request_id);\nstatic char *twa_aen_severity_lookup(unsigned char severity_code);\nstatic void twa_aen_sync_time(TW_Device_Extension *tw_dev, int request_id);\nstatic long twa_chrdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\nstatic int twa_chrdev_open(struct inode *inode, struct file *file);\nstatic int twa_fill_sense(TW_Device_Extension *tw_dev, int request_id, int copy_sense, int print_host);\nstatic void twa_free_request_id(TW_Device_Extension *tw_dev,int request_id);\nstatic void twa_get_request_id(TW_Device_Extension *tw_dev, int *request_id);\nstatic int twa_initconnection(TW_Device_Extension *tw_dev, int message_credits,\n\t\t\t      u32 set_features, unsigned short current_fw_srl,\n\t\t\t      unsigned short current_fw_arch_id,\n\t\t\t      unsigned short current_fw_branch,\n\t\t\t      unsigned short current_fw_build,\n\t\t\t      unsigned short *fw_on_ctlr_srl,\n\t\t\t      unsigned short *fw_on_ctlr_arch_id,\n\t\t\t      unsigned short *fw_on_ctlr_branch,\n\t\t\t      unsigned short *fw_on_ctlr_build,\n\t\t\t      u32 *init_connect_result);\nstatic void twa_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_command_packet, int request_id, dma_addr_t dma_handle, int length);\nstatic int twa_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds);\nstatic int twa_poll_status_gone(TW_Device_Extension *tw_dev, u32 flag, int seconds);\nstatic int twa_post_command_packet(TW_Device_Extension *tw_dev, int request_id, char internal);\nstatic int twa_reset_device_extension(TW_Device_Extension *tw_dev);\nstatic int twa_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset);\nstatic int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,\n\t\t\t\t   unsigned char *cdb, int use_sg,\n\t\t\t\t   TW_SG_Entry *sglistarg);\nstatic void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int request_id);\nstatic char *twa_string_lookup(twa_message_type *table, unsigned int aen_code);\n\n \n\n \nstatic ssize_t twa_show_stats(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\n\tunsigned long flags = 0;\n\tssize_t len;\n\n\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\tlen = snprintf(buf, PAGE_SIZE, \"3w-9xxx Driver version: %s\\n\"\n\t\t       \"Current commands posted:   %4d\\n\"\n\t\t       \"Max commands posted:       %4d\\n\"\n\t\t       \"Current pending commands:  %4d\\n\"\n\t\t       \"Max pending commands:      %4d\\n\"\n\t\t       \"Last sgl length:           %4d\\n\"\n\t\t       \"Max sgl length:            %4d\\n\"\n\t\t       \"Last sector count:         %4d\\n\"\n\t\t       \"Max sector count:          %4d\\n\"\n\t\t       \"SCSI Host Resets:          %4d\\n\"\n\t\t       \"AEN's:                     %4d\\n\",\n\t\t       TW_DRIVER_VERSION,\n\t\t       tw_dev->posted_request_count,\n\t\t       tw_dev->max_posted_request_count,\n\t\t       tw_dev->pending_request_count,\n\t\t       tw_dev->max_pending_request_count,\n\t\t       tw_dev->sgl_entries,\n\t\t       tw_dev->max_sgl_entries,\n\t\t       tw_dev->sector_count,\n\t\t       tw_dev->max_sector_count,\n\t\t       tw_dev->num_resets,\n\t\t       tw_dev->aen_count);\n\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\treturn len;\n}  \n\n \nstatic struct device_attribute twa_host_stats_attr = {\n\t.attr = {\n\t\t.name =\t\t\"stats\",\n\t\t.mode =\t\tS_IRUGO,\n\t},\n\t.show = twa_show_stats\n};\n\n \nstatic struct attribute *twa_host_attrs[] = {\n\t&twa_host_stats_attr.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(twa_host);\n\n \nstatic const struct file_operations twa_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= twa_chrdev_ioctl,\n\t.open\t\t= twa_chrdev_open,\n\t.release\t= NULL,\n\t.llseek\t\t= noop_llseek,\n};\n\n \nstatic bool twa_command_mapped(struct scsi_cmnd *cmd)\n{\n\treturn scsi_sg_count(cmd) != 1 ||\n\t\tscsi_bufflen(cmd) >= TW_MIN_SGL_LENGTH;\n}\n\n \nstatic int twa_aen_complete(TW_Device_Extension *tw_dev, int request_id)\n{\n\tTW_Command_Full *full_command_packet;\n\tTW_Command *command_packet;\n\tTW_Command_Apache_Header *header;\n\tunsigned short aen;\n\tint retval = 1;\n\n\theader = (TW_Command_Apache_Header *)tw_dev->generic_buffer_virt[request_id];\n\ttw_dev->posted_request_count--;\n\taen = le16_to_cpu(header->status_block.error);\n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tcommand_packet = &full_command_packet->command.oldcommand;\n\n\t \n\tif (TW_OP_OUT(command_packet->opcode__sgloffset) == TW_OP_SET_PARAM) {\n\t\t \n\t\tif (twa_aen_read_queue(tw_dev, request_id))\n\t\t\tgoto out2;\n\t\telse {\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (aen) {\n\tcase TW_AEN_QUEUE_EMPTY:\n\t\t \n\t\tbreak;\n\tcase TW_AEN_SYNC_TIME_WITH_HOST:\n\t\ttwa_aen_sync_time(tw_dev, request_id);\n\t\tretval = 0;\n\t\tgoto out;\n\tdefault:\n\t\ttwa_aen_queue_event(tw_dev, header);\n\n\t\t \n\t\tif (twa_aen_read_queue(tw_dev, request_id))\n\t\t\tgoto out2;\n\t\telse {\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tretval = 0;\nout2:\n\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\ttwa_free_request_id(tw_dev, request_id);\n\tclear_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags);\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_aen_drain_queue(TW_Device_Extension *tw_dev, int no_check_reset)\n{\n\tint request_id = 0;\n\tunsigned char cdb[TW_MAX_CDB_LEN];\n\tTW_SG_Entry sglist[1];\n\tint finished = 0, count = 0;\n\tTW_Command_Full *full_command_packet;\n\tTW_Command_Apache_Header *header;\n\tunsigned short aen;\n\tint first_reset = 0, queue = 0, retval = 1;\n\n\tif (no_check_reset)\n\t\tfirst_reset = 0;\n\telse\n\t\tfirst_reset = 1;\n\n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\n\t \n\tmemset(&cdb, 0, TW_MAX_CDB_LEN);\n\tcdb[0] = REQUEST_SENSE;  \n\tcdb[4] = TW_ALLOCATION_LENGTH;  \n\n\t \n\tmemset(&sglist, 0, sizeof(TW_SG_Entry));\n\tsglist[0].length = cpu_to_le32(TW_SECTOR_SIZE);\n\tsglist[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\n\n\tif (tw_dev->generic_buffer_phys[request_id] & TW_ALIGNMENT_9000_SGL) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1, \"Found unaligned address during AEN drain\");\n\t\tgoto out;\n\t}\n\n\t \n\ttw_dev->srb[request_id] = NULL;\n\n\tdo {\n\t\t \n\t\tif (twa_scsiop_execute_scsi(tw_dev, request_id, cdb, 1, sglist)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x2, \"Error posting request sense\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (twa_poll_response(tw_dev, request_id, 30)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x3, \"No valid response while draining AEN queue\");\n\t\t\ttw_dev->posted_request_count--;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttw_dev->posted_request_count--;\n\t\theader = (TW_Command_Apache_Header *)tw_dev->generic_buffer_virt[request_id];\n\t\taen = le16_to_cpu(header->status_block.error);\n\t\tqueue = 0;\n\t\tcount++;\n\n\t\tswitch (aen) {\n\t\tcase TW_AEN_QUEUE_EMPTY:\n\t\t\tif (first_reset != 1)\n\t\t\t\tgoto out;\n\t\t\telse\n\t\t\t\tfinished = 1;\n\t\t\tbreak;\n\t\tcase TW_AEN_SOFT_RESET:\n\t\t\tif (first_reset == 0)\n\t\t\t\tfirst_reset = 1;\n\t\t\telse\n\t\t\t\tqueue = 1;\n\t\t\tbreak;\n\t\tcase TW_AEN_SYNC_TIME_WITH_HOST:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tqueue = 1;\n\t\t}\n\n\t\t \n\t\tif (queue)\n\t\t\ttwa_aen_queue_event(tw_dev, header);\n\t} while ((finished == 0) && (count < TW_MAX_AEN_DRAIN));\n\n\tif (count == TW_MAX_AEN_DRAIN)\n\t\tgoto out;\n\n\tretval = 0;\nout:\n\ttw_dev->state[request_id] = TW_S_INITIAL;\n\treturn retval;\n}  \n\n \nstatic void twa_aen_queue_event(TW_Device_Extension *tw_dev, TW_Command_Apache_Header *header)\n{\n\tu32 local_time;\n\tTW_Event *event;\n\tunsigned short aen;\n\tchar host[16];\n\tchar *error_str;\n\n\ttw_dev->aen_count++;\n\n\t \n\tevent = tw_dev->event_queue[tw_dev->error_index];\n\n\t \n\thost[0] = '\\0';\n\tif (tw_dev->host) {\n\t\tsprintf(host, \" scsi%d:\", tw_dev->host->host_no);\n\t\tif (event->retrieved == TW_AEN_NOT_RETRIEVED)\n\t\t\ttw_dev->aen_clobber = 1;\n\t}\n\n\taen = le16_to_cpu(header->status_block.error);\n\tmemset(event, 0, sizeof(TW_Event));\n\n\tevent->severity = TW_SEV_OUT(header->status_block.severity__reserved);\n\t \n\tlocal_time = (u32)(ktime_get_real_seconds() - (sys_tz.tz_minuteswest * 60));\n\tevent->time_stamp_sec = local_time;\n\tevent->aen_code = aen;\n\tevent->retrieved = TW_AEN_NOT_RETRIEVED;\n\tevent->sequence_id = tw_dev->error_sequence_id;\n\ttw_dev->error_sequence_id++;\n\n\t \n\terror_str = &(header->err_specific_desc[strlen(header->err_specific_desc)+1]);\n\n\theader->err_specific_desc[sizeof(header->err_specific_desc) - 1] = '\\0';\n\tevent->parameter_len = strlen(header->err_specific_desc);\n\tmemcpy(event->parameter_data, header->err_specific_desc, event->parameter_len + (error_str[0] == '\\0' ? 0 : (1 + strlen(error_str))));\n\tif (event->severity != TW_AEN_SEVERITY_DEBUG)\n\t\tprintk(KERN_WARNING \"3w-9xxx:%s AEN: %s (0x%02X:0x%04X): %s:%s.\\n\",\n\t\t       host,\n\t\t       twa_aen_severity_lookup(TW_SEV_OUT(header->status_block.severity__reserved)),\n\t\t       TW_MESSAGE_SOURCE_CONTROLLER_EVENT, aen,\n\t\t       error_str[0] == '\\0' ? twa_string_lookup(twa_aen_table, aen) : error_str,\n\t\t       header->err_specific_desc);\n\telse\n\t\ttw_dev->aen_count--;\n\n\tif ((tw_dev->error_index + 1) == TW_Q_LENGTH)\n\t\ttw_dev->event_queue_wrapped = 1;\n\ttw_dev->error_index = (tw_dev->error_index + 1 ) % TW_Q_LENGTH;\n}  \n\n \nstatic int twa_aen_read_queue(TW_Device_Extension *tw_dev, int request_id)\n{\n\tunsigned char cdb[TW_MAX_CDB_LEN];\n\tTW_SG_Entry sglist[1];\n\tTW_Command_Full *full_command_packet;\n\tint retval = 1;\n\n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\n\t \n\tmemset(&cdb, 0, TW_MAX_CDB_LEN);\n\tcdb[0] = REQUEST_SENSE;  \n\tcdb[4] = TW_ALLOCATION_LENGTH;  \n\n\t \n\tmemset(&sglist, 0, sizeof(TW_SG_Entry));\n\tsglist[0].length = cpu_to_le32(TW_SECTOR_SIZE);\n\tsglist[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\n\n\t \n\ttw_dev->srb[request_id] = NULL;\n\n\t \n\tif (twa_scsiop_execute_scsi(tw_dev, request_id, cdb, 1, sglist)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x4, \"Post failed while reading AEN queue\");\n\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic char *twa_aen_severity_lookup(unsigned char severity_code)\n{\n\tchar *retval = NULL;\n\n\tif ((severity_code < (unsigned char) TW_AEN_SEVERITY_ERROR) ||\n\t    (severity_code > (unsigned char) TW_AEN_SEVERITY_DEBUG))\n\t\tgoto out;\n\n\tretval = twa_aen_severity_table[severity_code];\nout:\n\treturn retval;\n}  \n\n \nstatic void twa_aen_sync_time(TW_Device_Extension *tw_dev, int request_id)\n{\n\tu32 schedulertime;\n\tTW_Command_Full *full_command_packet;\n\tTW_Command *command_packet;\n\tTW_Param_Apache *param;\n\ttime64_t local_time;\n\n\t \n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\tcommand_packet = &full_command_packet->command.oldcommand;\n\tcommand_packet->opcode__sgloffset = TW_OPSGL_IN(2, TW_OP_SET_PARAM);\n\tcommand_packet->request_id = request_id;\n\tcommand_packet->byte8_offset.param.sgl[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\n\tcommand_packet->byte8_offset.param.sgl[0].length = cpu_to_le32(TW_SECTOR_SIZE);\n\tcommand_packet->size = TW_COMMAND_SIZE;\n\tcommand_packet->byte6_offset.parameter_count = cpu_to_le16(1);\n\n\t \n\tparam = (TW_Param_Apache *)tw_dev->generic_buffer_virt[request_id];\n\tmemset(param, 0, TW_SECTOR_SIZE);\n\tparam->table_id = cpu_to_le16(TW_TIMEKEEP_TABLE | 0x8000);  \n\tparam->parameter_id = cpu_to_le16(0x3);  \n\tparam->parameter_size_bytes = cpu_to_le16(4);\n\n\t \n\tlocal_time = (ktime_get_real_seconds() - (sys_tz.tz_minuteswest * 60));\n\tdiv_u64_rem(local_time - (3 * 86400), 604800, &schedulertime);\n\n\tmemcpy(param->data, &(__le32){cpu_to_le32(schedulertime)}, sizeof(__le32));\n\n\t \n\ttw_dev->srb[request_id] = NULL;\n\n\t \n\ttwa_post_command_packet(tw_dev, request_id, 1);\n}  \n\n \nstatic int twa_allocate_memory(TW_Device_Extension *tw_dev, int size, int which)\n{\n\tint i;\n\tdma_addr_t dma_handle;\n\tunsigned long *cpu_addr;\n\tint retval = 1;\n\n\tcpu_addr = dma_alloc_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\tsize * TW_Q_LENGTH, &dma_handle, GFP_KERNEL);\n\tif (!cpu_addr) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x5, \"Memory allocation failed\");\n\t\tgoto out;\n\t}\n\n\tif ((unsigned long)cpu_addr % (TW_ALIGNMENT_9000)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x6, \"Failed to allocate correctly aligned memory\");\n\t\tdma_free_coherent(&tw_dev->tw_pci_dev->dev, size * TW_Q_LENGTH,\n\t\t\t\tcpu_addr, dma_handle);\n\t\tgoto out;\n\t}\n\n\tmemset(cpu_addr, 0, size*TW_Q_LENGTH);\n\n\tfor (i = 0; i < TW_Q_LENGTH; i++) {\n\t\tswitch(which) {\n\t\tcase 0:\n\t\t\ttw_dev->command_packet_phys[i] = dma_handle+(i*size);\n\t\t\ttw_dev->command_packet_virt[i] = (TW_Command_Full *)((unsigned char *)cpu_addr + (i*size));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttw_dev->generic_buffer_phys[i] = dma_handle+(i*size);\n\t\t\ttw_dev->generic_buffer_virt[i] = (unsigned long *)((unsigned char *)cpu_addr + (i*size));\n\t\t\tbreak;\n\t\t}\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_check_bits(u32 status_reg_value)\n{\n\tint retval = 1;\n\n\tif ((status_reg_value & TW_STATUS_EXPECTED_BITS) != TW_STATUS_EXPECTED_BITS)\n\t\tgoto out;\n\tif ((status_reg_value & TW_STATUS_UNEXPECTED_BITS) != 0)\n\t\tgoto out;\n\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_check_srl(TW_Device_Extension *tw_dev, int *flashed)\n{\n\tint retval = 1;\n\tunsigned short fw_on_ctlr_srl = 0, fw_on_ctlr_arch_id = 0;\n\tunsigned short fw_on_ctlr_branch = 0, fw_on_ctlr_build = 0;\n\tu32 init_connect_result = 0;\n\n\tif (twa_initconnection(tw_dev, TW_INIT_MESSAGE_CREDITS,\n\t\t\t       TW_EXTENDED_INIT_CONNECT, TW_CURRENT_DRIVER_SRL,\n\t\t\t       TW_9000_ARCH_ID, TW_CURRENT_DRIVER_BRANCH,\n\t\t\t       TW_CURRENT_DRIVER_BUILD, &fw_on_ctlr_srl,\n\t\t\t       &fw_on_ctlr_arch_id, &fw_on_ctlr_branch,\n\t\t\t       &fw_on_ctlr_build, &init_connect_result)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x7, \"Initconnection failed while checking SRL\");\n\t\tgoto out;\n\t}\n\n\ttw_dev->tw_compat_info.working_srl = fw_on_ctlr_srl;\n\ttw_dev->tw_compat_info.working_branch = fw_on_ctlr_branch;\n\ttw_dev->tw_compat_info.working_build = fw_on_ctlr_build;\n\n\t \n\tif (!(init_connect_result & TW_CTLR_FW_COMPATIBLE)) {\n\t\tif (twa_initconnection(tw_dev, TW_INIT_MESSAGE_CREDITS,\n\t\t\t\t       TW_EXTENDED_INIT_CONNECT,\n\t\t\t\t       TW_BASE_FW_SRL, TW_9000_ARCH_ID,\n\t\t\t\t       TW_BASE_FW_BRANCH, TW_BASE_FW_BUILD,\n\t\t\t\t       &fw_on_ctlr_srl, &fw_on_ctlr_arch_id,\n\t\t\t\t       &fw_on_ctlr_branch, &fw_on_ctlr_build,\n\t\t\t\t       &init_connect_result)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xa, \"Initconnection (base mode) failed while checking SRL\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(init_connect_result & TW_CTLR_FW_COMPATIBLE)) {\n\t\t\tif (TW_CURRENT_DRIVER_SRL > fw_on_ctlr_srl) {\n\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x32, \"Firmware and driver incompatibility: please upgrade firmware\");\n\t\t\t} else {\n\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x33, \"Firmware and driver incompatibility: please upgrade driver\");\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\ttw_dev->tw_compat_info.working_srl = TW_BASE_FW_SRL;\n\t\ttw_dev->tw_compat_info.working_branch = TW_BASE_FW_BRANCH;\n\t\ttw_dev->tw_compat_info.working_build = TW_BASE_FW_BUILD;\n\t}\n\n\t \n\tstrscpy(tw_dev->tw_compat_info.driver_version, TW_DRIVER_VERSION,\n\t\tsizeof(tw_dev->tw_compat_info.driver_version));\n\ttw_dev->tw_compat_info.driver_srl_high = TW_CURRENT_DRIVER_SRL;\n\ttw_dev->tw_compat_info.driver_branch_high = TW_CURRENT_DRIVER_BRANCH;\n\ttw_dev->tw_compat_info.driver_build_high = TW_CURRENT_DRIVER_BUILD;\n\ttw_dev->tw_compat_info.driver_srl_low = TW_BASE_FW_SRL;\n\ttw_dev->tw_compat_info.driver_branch_low = TW_BASE_FW_BRANCH;\n\ttw_dev->tw_compat_info.driver_build_low = TW_BASE_FW_BUILD;\n\ttw_dev->tw_compat_info.fw_on_ctlr_srl = fw_on_ctlr_srl;\n\ttw_dev->tw_compat_info.fw_on_ctlr_branch = fw_on_ctlr_branch;\n\ttw_dev->tw_compat_info.fw_on_ctlr_build = fw_on_ctlr_build;\n\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic long twa_chrdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong timeout;\n\tunsigned long *cpu_addr, data_buffer_length_adjusted = 0, flags = 0;\n\tdma_addr_t dma_handle;\n\tint request_id = 0;\n\tunsigned int sequence_id = 0;\n\tunsigned char event_index, start_index;\n\tTW_Ioctl_Driver_Command driver_command;\n\tTW_Ioctl_Buf_Apache *tw_ioctl;\n\tTW_Lock *tw_lock;\n\tTW_Command_Full *full_command_packet;\n\tTW_Compatibility_Info *tw_compat_info;\n\tTW_Event *event;\n\tktime_t current_time;\n\tTW_Device_Extension *tw_dev = twa_device_extension_list[iminor(inode)];\n\tint retval = TW_IOCTL_ERROR_OS_EFAULT;\n\tvoid __user *argp = (void __user *)arg;\n\n\tmutex_lock(&twa_chrdev_mutex);\n\n\t \n\tif (mutex_lock_interruptible(&tw_dev->ioctl_lock)) {\n\t\tretval = TW_IOCTL_ERROR_OS_EINTR;\n\t\tgoto out;\n\t}\n\n\t \n\tif (copy_from_user(&driver_command, argp, sizeof(TW_Ioctl_Driver_Command)))\n\t\tgoto out2;\n\n\t \n\tif (driver_command.buffer_length > TW_MAX_SECTORS * 2048) {\n\t\tretval = TW_IOCTL_ERROR_OS_EINVAL;\n\t\tgoto out2;\n\t}\n\n\t \n\tdata_buffer_length_adjusted = (driver_command.buffer_length + 511) & ~511;\n\n\t \n\tcpu_addr = dma_alloc_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\t\t      sizeof(TW_Ioctl_Buf_Apache) + data_buffer_length_adjusted,\n\t\t\t\t      &dma_handle, GFP_KERNEL);\n\tif (!cpu_addr) {\n\t\tretval = TW_IOCTL_ERROR_OS_ENOMEM;\n\t\tgoto out2;\n\t}\n\n\ttw_ioctl = (TW_Ioctl_Buf_Apache *)cpu_addr;\n\n\t \n\tif (copy_from_user(tw_ioctl, argp, sizeof(TW_Ioctl_Buf_Apache) + driver_command.buffer_length))\n\t\tgoto out3;\n\n\t \n\tswitch (cmd) {\n\tcase TW_IOCTL_FIRMWARE_PASS_THROUGH:\n\t\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\t\ttwa_get_request_id(tw_dev, &request_id);\n\n\t\t \n\t\ttw_dev->srb[request_id] = NULL;\n\n\t\t \n\t\ttw_dev->chrdev_request_id = request_id;\n\n\t\tfull_command_packet = &tw_ioctl->firmware_command;\n\n\t\t \n\t\ttwa_load_sgl(tw_dev, full_command_packet, request_id, dma_handle, data_buffer_length_adjusted);\n\n\t\tmemcpy(tw_dev->command_packet_virt[request_id], &(tw_ioctl->firmware_command), sizeof(TW_Command_Full));\n\n\t\t \n\t\ttwa_post_command_packet(tw_dev, request_id, 1);\n\t\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\n\t\ttimeout = TW_IOCTL_CHRDEV_TIMEOUT*HZ;\n\n\t\t \n\t\ttimeout = wait_event_timeout(tw_dev->ioctl_wqueue, tw_dev->chrdev_request_id == TW_IOCTL_CHRDEV_FREE, timeout);\n\n\t\t \n\t\tif (tw_dev->chrdev_request_id != TW_IOCTL_CHRDEV_FREE) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING \"3w-9xxx: scsi%d: WARNING: (0x%02X:0x%04X): Character ioctl (0x%x) timed out, resetting card.\\n\",\n\t\t\t       tw_dev->host->host_no, TW_DRIVER, 0x37,\n\t\t\t       cmd);\n\t\t\tretval = TW_IOCTL_ERROR_OS_EIO;\n\t\t\ttwa_reset_device_extension(tw_dev);\n\t\t\tgoto out3;\n\t\t}\n\n\t\t \n\t\tmemcpy(&(tw_ioctl->firmware_command), tw_dev->command_packet_virt[request_id], sizeof(TW_Command_Full));\n\n\t\t \n\t\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\t\ttw_dev->posted_request_count--;\n\t\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\t\ttwa_free_request_id(tw_dev, request_id);\n\t\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\t\tbreak;\n\tcase TW_IOCTL_GET_COMPATIBILITY_INFO:\n\t\ttw_ioctl->driver_command.status = 0;\n\t\t \n\t\ttw_compat_info = (TW_Compatibility_Info *)tw_ioctl->data_buffer;\n\t\tmemcpy(tw_compat_info, &tw_dev->tw_compat_info, sizeof(TW_Compatibility_Info));\n\t\tbreak;\n\tcase TW_IOCTL_GET_LAST_EVENT:\n\t\tif (tw_dev->event_queue_wrapped) {\n\t\t\tif (tw_dev->aen_clobber) {\n\t\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_AEN_CLOBBER;\n\t\t\t\ttw_dev->aen_clobber = 0;\n\t\t\t} else\n\t\t\t\ttw_ioctl->driver_command.status = 0;\n\t\t} else {\n\t\t\tif (!tw_dev->error_index) {\n\t\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_NO_MORE_EVENTS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttw_ioctl->driver_command.status = 0;\n\t\t}\n\t\tevent_index = (tw_dev->error_index - 1 + TW_Q_LENGTH) % TW_Q_LENGTH;\n\t\tmemcpy(tw_ioctl->data_buffer, tw_dev->event_queue[event_index], sizeof(TW_Event));\n\t\ttw_dev->event_queue[event_index]->retrieved = TW_AEN_RETRIEVED;\n\t\tbreak;\n\tcase TW_IOCTL_GET_FIRST_EVENT:\n\t\tif (tw_dev->event_queue_wrapped) {\n\t\t\tif (tw_dev->aen_clobber) {\n\t\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_AEN_CLOBBER;\n\t\t\t\ttw_dev->aen_clobber = 0;\n\t\t\t} else\n\t\t\t\ttw_ioctl->driver_command.status = 0;\n\t\t\tevent_index = tw_dev->error_index;\n\t\t} else {\n\t\t\tif (!tw_dev->error_index) {\n\t\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_NO_MORE_EVENTS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttw_ioctl->driver_command.status = 0;\n\t\t\tevent_index = 0;\n\t\t}\n\t\tmemcpy(tw_ioctl->data_buffer, tw_dev->event_queue[event_index], sizeof(TW_Event));\n\t\ttw_dev->event_queue[event_index]->retrieved = TW_AEN_RETRIEVED;\n\t\tbreak;\n\tcase TW_IOCTL_GET_NEXT_EVENT:\n\t\tevent = (TW_Event *)tw_ioctl->data_buffer;\n\t\tsequence_id = event->sequence_id;\n\t\ttw_ioctl->driver_command.status = 0;\n\n\t\tif (tw_dev->event_queue_wrapped) {\n\t\t\tif (tw_dev->aen_clobber) {\n\t\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_AEN_CLOBBER;\n\t\t\t\ttw_dev->aen_clobber = 0;\n\t\t\t}\n\t\t\tstart_index = tw_dev->error_index;\n\t\t} else {\n\t\t\tif (!tw_dev->error_index) {\n\t\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_NO_MORE_EVENTS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart_index = 0;\n\t\t}\n\t\tevent_index = (start_index + sequence_id - tw_dev->event_queue[start_index]->sequence_id + 1) % TW_Q_LENGTH;\n\n\t\tif (!(tw_dev->event_queue[event_index]->sequence_id > sequence_id)) {\n\t\t\tif (tw_ioctl->driver_command.status == TW_IOCTL_ERROR_STATUS_AEN_CLOBBER)\n\t\t\t\ttw_dev->aen_clobber = 1;\n\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_NO_MORE_EVENTS;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(tw_ioctl->data_buffer, tw_dev->event_queue[event_index], sizeof(TW_Event));\n\t\ttw_dev->event_queue[event_index]->retrieved = TW_AEN_RETRIEVED;\n\t\tbreak;\n\tcase TW_IOCTL_GET_PREVIOUS_EVENT:\n\t\tevent = (TW_Event *)tw_ioctl->data_buffer;\n\t\tsequence_id = event->sequence_id;\n\t\ttw_ioctl->driver_command.status = 0;\n\n\t\tif (tw_dev->event_queue_wrapped) {\n\t\t\tif (tw_dev->aen_clobber) {\n\t\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_AEN_CLOBBER;\n\t\t\t\ttw_dev->aen_clobber = 0;\n\t\t\t}\n\t\t\tstart_index = tw_dev->error_index;\n\t\t} else {\n\t\t\tif (!tw_dev->error_index) {\n\t\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_NO_MORE_EVENTS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart_index = 0;\n\t\t}\n\t\tevent_index = (start_index + sequence_id - tw_dev->event_queue[start_index]->sequence_id - 1) % TW_Q_LENGTH;\n\n\t\tif (!(tw_dev->event_queue[event_index]->sequence_id < sequence_id)) {\n\t\t\tif (tw_ioctl->driver_command.status == TW_IOCTL_ERROR_STATUS_AEN_CLOBBER)\n\t\t\t\ttw_dev->aen_clobber = 1;\n\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_NO_MORE_EVENTS;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(tw_ioctl->data_buffer, tw_dev->event_queue[event_index], sizeof(TW_Event));\n\t\ttw_dev->event_queue[event_index]->retrieved = TW_AEN_RETRIEVED;\n\t\tbreak;\n\tcase TW_IOCTL_GET_LOCK:\n\t\ttw_lock = (TW_Lock *)tw_ioctl->data_buffer;\n\t\tcurrent_time = ktime_get();\n\n\t\tif ((tw_lock->force_flag == 1) || (tw_dev->ioctl_sem_lock == 0) ||\n\t\t    ktime_after(current_time, tw_dev->ioctl_time)) {\n\t\t\ttw_dev->ioctl_sem_lock = 1;\n\t\t\ttw_dev->ioctl_time = ktime_add_ms(current_time, tw_lock->timeout_msec);\n\t\t\ttw_ioctl->driver_command.status = 0;\n\t\t\ttw_lock->time_remaining_msec = tw_lock->timeout_msec;\n\t\t} else {\n\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_LOCKED;\n\t\t\ttw_lock->time_remaining_msec = ktime_ms_delta(tw_dev->ioctl_time, current_time);\n\t\t}\n\t\tbreak;\n\tcase TW_IOCTL_RELEASE_LOCK:\n\t\tif (tw_dev->ioctl_sem_lock == 1) {\n\t\t\ttw_dev->ioctl_sem_lock = 0;\n\t\t\ttw_ioctl->driver_command.status = 0;\n\t\t} else {\n\t\t\ttw_ioctl->driver_command.status = TW_IOCTL_ERROR_STATUS_NOT_LOCKED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tretval = TW_IOCTL_ERROR_OS_ENOTTY;\n\t\tgoto out3;\n\t}\n\n\t \n\tif (copy_to_user(argp, tw_ioctl, sizeof(TW_Ioctl_Buf_Apache) + driver_command.buffer_length) == 0)\n\t\tretval = 0;\nout3:\n\t \n\tdma_free_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\t  sizeof(TW_Ioctl_Buf_Apache) + data_buffer_length_adjusted,\n\t\t\t  cpu_addr, dma_handle);\nout2:\n\tmutex_unlock(&tw_dev->ioctl_lock);\nout:\n\tmutex_unlock(&twa_chrdev_mutex);\n\treturn retval;\n}  \n\n \n \nstatic int twa_chrdev_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor_number;\n\tint retval = TW_IOCTL_ERROR_OS_ENODEV;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tretval = -EACCES;\n\t\tgoto out;\n\t}\n\n\tminor_number = iminor(inode);\n\tif (minor_number >= twa_device_extension_count)\n\t\tgoto out;\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_decode_bits(TW_Device_Extension *tw_dev, u32 status_reg_value)\n{\n\tint retval = 1;\n\n\t \n\tif (status_reg_value & TW_STATUS_PCI_PARITY_ERROR) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xc, \"PCI Parity Error: clearing\");\n\t\twritel(TW_CONTROL_CLEAR_PARITY_ERROR, TW_CONTROL_REG_ADDR(tw_dev));\n\t}\n\n\tif (status_reg_value & TW_STATUS_PCI_ABORT) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xd, \"PCI Abort: clearing\");\n\t\twritel(TW_CONTROL_CLEAR_PCI_ABORT, TW_CONTROL_REG_ADDR(tw_dev));\n\t\tpci_write_config_word(tw_dev->tw_pci_dev, PCI_STATUS, TW_PCI_CLEAR_PCI_ABORT);\n\t}\n\n\tif (status_reg_value & TW_STATUS_QUEUE_ERROR) {\n\t\tif (((tw_dev->tw_pci_dev->device != PCI_DEVICE_ID_3WARE_9650SE) &&\n\t\t     (tw_dev->tw_pci_dev->device != PCI_DEVICE_ID_3WARE_9690SA)) ||\n\t\t    (!test_bit(TW_IN_RESET, &tw_dev->flags)))\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xe, \"Controller Queue Error: clearing\");\n\t\twritel(TW_CONTROL_CLEAR_QUEUE_ERROR, TW_CONTROL_REG_ADDR(tw_dev));\n\t}\n\n\tif (status_reg_value & TW_STATUS_MICROCONTROLLER_ERROR) {\n\t\tif (tw_dev->reset_print == 0) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x10, \"Microcontroller Error: clearing\");\n\t\t\ttw_dev->reset_print = 1;\n\t\t}\n\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_empty_response_queue(TW_Device_Extension *tw_dev)\n{\n\tu32 status_reg_value;\n\tint count = 0, retval = 1;\n\n\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\n\twhile (((status_reg_value & TW_STATUS_RESPONSE_QUEUE_EMPTY) == 0) && (count < TW_MAX_RESPONSE_DRAIN)) {\n\t\treadl(TW_RESPONSE_QUEUE_REG_ADDR(tw_dev));\n\t\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\t\tcount++;\n\t}\n\tif (count == TW_MAX_RESPONSE_DRAIN)\n\t\tgoto out;\n\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_empty_response_queue_large(TW_Device_Extension *tw_dev)\n{\n\tu32 response_que_value = 0;\n\tunsigned long before;\n\tint retval = 1;\n\n\tif (tw_dev->tw_pci_dev->device != PCI_DEVICE_ID_3WARE_9000) {\n\t\tbefore = jiffies;\n\t\twhile ((response_que_value & TW_9550SX_DRAIN_COMPLETED) != TW_9550SX_DRAIN_COMPLETED) {\n\t\t\tresponse_que_value = readl(TW_RESPONSE_QUEUE_REG_ADDR_LARGE(tw_dev));\n\t\t\tmsleep(1);\n\t\t\tif (time_after(jiffies, before + HZ * 30))\n\t\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tmsleep(500);\n\t\tretval = 0;\n\t} else\n\t\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_fill_sense(TW_Device_Extension *tw_dev, int request_id, int copy_sense, int print_host)\n{\n\tTW_Command_Full *full_command_packet;\n\tunsigned short error;\n\tint retval = 1;\n\tchar *error_str;\n\n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\n\t \n\terror_str = &(full_command_packet->header.err_specific_desc[strlen(full_command_packet->header.err_specific_desc) + 1]);\n\n\t \n\terror = le16_to_cpu(full_command_packet->header.status_block.error);\n\tif ((error != TW_ERROR_LOGICAL_UNIT_NOT_SUPPORTED) && (error != TW_ERROR_UNIT_OFFLINE)) {\n\t\tif (print_host)\n\t\t\tprintk(KERN_WARNING \"3w-9xxx: scsi%d: ERROR: (0x%02X:0x%04X): %s:%s.\\n\",\n\t\t\t       tw_dev->host->host_no,\n\t\t\t       TW_MESSAGE_SOURCE_CONTROLLER_ERROR, error,\n\t\t\t       error_str[0] ? error_str : twa_string_lookup(twa_error_table, error),\n\t\t\t       full_command_packet->header.err_specific_desc);\n\t\telse\n\t\t\tprintk(KERN_WARNING \"3w-9xxx: ERROR: (0x%02X:0x%04X): %s:%s.\\n\",\n\t\t\t       TW_MESSAGE_SOURCE_CONTROLLER_ERROR, error,\n\t\t\t       error_str[0] ? error_str : twa_string_lookup(twa_error_table, error),\n\t\t\t       full_command_packet->header.err_specific_desc);\n\t}\n\n\tif (copy_sense) {\n\t\tmemcpy(tw_dev->srb[request_id]->sense_buffer, full_command_packet->header.sense_data, TW_SENSE_DATA_LENGTH);\n\t\ttw_dev->srb[request_id]->result = (full_command_packet->command.newcommand.status << 1);\n\t\tretval = TW_ISR_DONT_RESULT;\n\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic void twa_free_device_extension(TW_Device_Extension *tw_dev)\n{\n\tif (tw_dev->command_packet_virt[0])\n\t\tdma_free_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\t\tsizeof(TW_Command_Full) * TW_Q_LENGTH,\n\t\t\t\ttw_dev->command_packet_virt[0],\n\t\t\t\ttw_dev->command_packet_phys[0]);\n\n\tif (tw_dev->generic_buffer_virt[0])\n\t\tdma_free_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\t\tTW_SECTOR_SIZE * TW_Q_LENGTH,\n\t\t\t\ttw_dev->generic_buffer_virt[0],\n\t\t\t\ttw_dev->generic_buffer_phys[0]);\n\n\tkfree(tw_dev->event_queue[0]);\n}  \n\n \nstatic void twa_free_request_id(TW_Device_Extension *tw_dev, int request_id)\n{\n\ttw_dev->free_queue[tw_dev->free_tail] = request_id;\n\ttw_dev->state[request_id] = TW_S_FINISHED;\n\ttw_dev->free_tail = (tw_dev->free_tail + 1) % TW_Q_LENGTH;\n}  \n\n \nstatic void *twa_get_param(TW_Device_Extension *tw_dev, int request_id, int table_id, int parameter_id, int parameter_size_bytes)\n{\n\tTW_Command_Full *full_command_packet;\n\tTW_Command *command_packet;\n\tTW_Param_Apache *param;\n\tvoid *retval = NULL;\n\n\t \n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\tcommand_packet = &full_command_packet->command.oldcommand;\n\n\tcommand_packet->opcode__sgloffset = TW_OPSGL_IN(2, TW_OP_GET_PARAM);\n\tcommand_packet->size\t\t  = TW_COMMAND_SIZE;\n\tcommand_packet->request_id\t  = request_id;\n\tcommand_packet->byte6_offset.block_count = cpu_to_le16(1);\n\n\t \n\tparam = (TW_Param_Apache *)tw_dev->generic_buffer_virt[request_id];\n\tmemset(param, 0, TW_SECTOR_SIZE);\n\tparam->table_id = cpu_to_le16(table_id | 0x8000);\n\tparam->parameter_id = cpu_to_le16(parameter_id);\n\tparam->parameter_size_bytes = cpu_to_le16(parameter_size_bytes);\n\n\tcommand_packet->byte8_offset.param.sgl[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\n\tcommand_packet->byte8_offset.param.sgl[0].length = cpu_to_le32(TW_SECTOR_SIZE);\n\n\t \n\ttwa_post_command_packet(tw_dev, request_id, 1);\n\n\t \n\tif (twa_poll_response(tw_dev, request_id, 30))\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x13, \"No valid response during get param\")\n\telse\n\t\tretval = (void *)&(param->data[0]);\n\n\ttw_dev->posted_request_count--;\n\ttw_dev->state[request_id] = TW_S_INITIAL;\n\n\treturn retval;\n}  \n\n \nstatic void twa_get_request_id(TW_Device_Extension *tw_dev, int *request_id)\n{\n\t*request_id = tw_dev->free_queue[tw_dev->free_head];\n\ttw_dev->free_head = (tw_dev->free_head + 1) % TW_Q_LENGTH;\n\ttw_dev->state[*request_id] = TW_S_STARTED;\n}  \n\n \nstatic int twa_initconnection(TW_Device_Extension *tw_dev, int message_credits,\n\t\t\t      u32 set_features, unsigned short current_fw_srl,\n\t\t\t      unsigned short current_fw_arch_id,\n\t\t\t      unsigned short current_fw_branch,\n\t\t\t      unsigned short current_fw_build,\n\t\t\t      unsigned short *fw_on_ctlr_srl,\n\t\t\t      unsigned short *fw_on_ctlr_arch_id,\n\t\t\t      unsigned short *fw_on_ctlr_branch,\n\t\t\t      unsigned short *fw_on_ctlr_build,\n\t\t\t      u32 *init_connect_result)\n{\n\tTW_Command_Full *full_command_packet;\n\tTW_Initconnect *tw_initconnect;\n\tint request_id = 0, retval = 1;\n\n\t \n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\tfull_command_packet->header.header_desc.size_header = 128;\n\n\ttw_initconnect = (TW_Initconnect *)&full_command_packet->command.oldcommand;\n\ttw_initconnect->opcode__reserved = TW_OPRES_IN(0, TW_OP_INIT_CONNECTION);\n\ttw_initconnect->request_id = request_id;\n\ttw_initconnect->message_credits = cpu_to_le16(message_credits);\n\n\t \n\tset_features |= sizeof(dma_addr_t) > 4 ? 1 : 0;\n\n\ttw_initconnect->features = cpu_to_le32(set_features);\n\n\tif (set_features & TW_EXTENDED_INIT_CONNECT) {\n\t\ttw_initconnect->size = TW_INIT_COMMAND_PACKET_SIZE_EXTENDED;\n\t\ttw_initconnect->fw_srl = cpu_to_le16(current_fw_srl);\n\t\ttw_initconnect->fw_arch_id = cpu_to_le16(current_fw_arch_id);\n\t\ttw_initconnect->fw_branch = cpu_to_le16(current_fw_branch);\n\t\ttw_initconnect->fw_build = cpu_to_le16(current_fw_build);\n\t} else\n\t\ttw_initconnect->size = TW_INIT_COMMAND_PACKET_SIZE;\n\n\t \n\ttwa_post_command_packet(tw_dev, request_id, 1);\n\n\t \n\tif (twa_poll_response(tw_dev, request_id, 30)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x15, \"No valid response during init connection\");\n\t} else {\n\t\tif (set_features & TW_EXTENDED_INIT_CONNECT) {\n\t\t\t*fw_on_ctlr_srl = le16_to_cpu(tw_initconnect->fw_srl);\n\t\t\t*fw_on_ctlr_arch_id = le16_to_cpu(tw_initconnect->fw_arch_id);\n\t\t\t*fw_on_ctlr_branch = le16_to_cpu(tw_initconnect->fw_branch);\n\t\t\t*fw_on_ctlr_build = le16_to_cpu(tw_initconnect->fw_build);\n\t\t\t*init_connect_result = le32_to_cpu(tw_initconnect->result);\n\t\t}\n\t\tretval = 0;\n\t}\n\n\ttw_dev->posted_request_count--;\n\ttw_dev->state[request_id] = TW_S_INITIAL;\n\n\treturn retval;\n}  \n\n \nstatic int twa_initialize_device_extension(TW_Device_Extension *tw_dev)\n{\n\tint i, retval = 1;\n\n\t \n\tif (twa_allocate_memory(tw_dev, sizeof(TW_Command_Full), 0)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x16, \"Command packet memory allocation failed\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (twa_allocate_memory(tw_dev, TW_SECTOR_SIZE, 1)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x17, \"Generic memory allocation failed\");\n\t\tgoto out;\n\t}\n\n\t \n\ttw_dev->event_queue[0] = kcalloc(TW_Q_LENGTH, sizeof(TW_Event), GFP_KERNEL);\n\tif (!tw_dev->event_queue[0]) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x18, \"Event info memory allocation failed\");\n\t\tgoto out;\n\t}\n\n\n\tfor (i = 0; i < TW_Q_LENGTH; i++) {\n\t\ttw_dev->event_queue[i] = (TW_Event *)((unsigned char *)tw_dev->event_queue[0] + (i * sizeof(TW_Event)));\n\t\ttw_dev->free_queue[i] = i;\n\t\ttw_dev->state[i] = TW_S_INITIAL;\n\t}\n\n\ttw_dev->pending_head = TW_Q_START;\n\ttw_dev->pending_tail = TW_Q_START;\n\ttw_dev->free_head = TW_Q_START;\n\ttw_dev->free_tail = TW_Q_START;\n\ttw_dev->error_sequence_id = 1;\n\ttw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\n\n\tmutex_init(&tw_dev->ioctl_lock);\n\tinit_waitqueue_head(&tw_dev->ioctl_wqueue);\n\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic irqreturn_t twa_interrupt(int irq, void *dev_instance)\n{\n\tint request_id, error = 0;\n\tu32 status_reg_value;\n\tTW_Response_Queue response_que;\n\tTW_Command_Full *full_command_packet;\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)dev_instance;\n\tint handled = 0;\n\n\t \n\tspin_lock(tw_dev->host->host_lock);\n\n\t \n\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\n\t \n\tif (!(status_reg_value & TW_STATUS_VALID_INTERRUPT))\n\t\tgoto twa_interrupt_bail;\n\n\thandled = 1;\n\n\t \n\tif (test_bit(TW_IN_RESET, &tw_dev->flags))\n\t\tgoto twa_interrupt_bail;\n\n\t \n\tif (twa_check_bits(status_reg_value)) {\n\t\tif (twa_decode_bits(tw_dev, status_reg_value)) {\n\t\t\tTW_CLEAR_ALL_INTERRUPTS(tw_dev);\n\t\t\tgoto twa_interrupt_bail;\n\t\t}\n\t}\n\n\t \n\tif (status_reg_value & TW_STATUS_HOST_INTERRUPT)\n\t\tTW_CLEAR_HOST_INTERRUPT(tw_dev);\n\n\t \n\tif (status_reg_value & TW_STATUS_ATTENTION_INTERRUPT) {\n\t\tTW_CLEAR_ATTENTION_INTERRUPT(tw_dev);\n\t\tif (!(test_and_set_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags))) {\n\t\t\ttwa_get_request_id(tw_dev, &request_id);\n\n\t\t\terror = twa_aen_read_queue(tw_dev, request_id);\n\t\t\tif (error) {\n\t\t\t\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\t\t\t\ttwa_free_request_id(tw_dev, request_id);\n\t\t\t\tclear_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (status_reg_value & TW_STATUS_COMMAND_INTERRUPT) {\n\t\tTW_MASK_COMMAND_INTERRUPT(tw_dev);\n\t\t \n\t\twhile (tw_dev->pending_request_count > 0) {\n\t\t\trequest_id = tw_dev->pending_queue[tw_dev->pending_head];\n\t\t\tif (tw_dev->state[request_id] != TW_S_PENDING) {\n\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x19, \"Found request id that wasn't pending\");\n\t\t\t\tTW_CLEAR_ALL_INTERRUPTS(tw_dev);\n\t\t\t\tgoto twa_interrupt_bail;\n\t\t\t}\n\t\t\tif (twa_post_command_packet(tw_dev, request_id, 1)==0) {\n\t\t\t\ttw_dev->pending_head = (tw_dev->pending_head + 1) % TW_Q_LENGTH;\n\t\t\t\ttw_dev->pending_request_count--;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (status_reg_value & TW_STATUS_RESPONSE_INTERRUPT) {\n\n\t\t \n\t\twhile ((status_reg_value & TW_STATUS_RESPONSE_QUEUE_EMPTY) == 0) {\n\t\t\t \n\t\t\tresponse_que.value = readl(TW_RESPONSE_QUEUE_REG_ADDR(tw_dev));\n\t\t\trequest_id = TW_RESID_OUT(response_que.response_id);\n\t\t\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\t\t\terror = 0;\n\t\t\t \n\t\t\tif (full_command_packet->command.newcommand.status != 0) {\n\t\t\t\tif (tw_dev->srb[request_id] != NULL) {\n\t\t\t\t\terror = twa_fill_sense(tw_dev, request_id, 1, 1);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tif (request_id != tw_dev->chrdev_request_id) {\n\t\t\t\t\t\terror = twa_fill_sense(tw_dev, request_id, 0, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (tw_dev->state[request_id] != TW_S_POSTED) {\n\t\t\t\tif (tw_dev->srb[request_id] != NULL) {\n\t\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1a, \"Received a request id that wasn't posted\");\n\t\t\t\t\tTW_CLEAR_ALL_INTERRUPTS(tw_dev);\n\t\t\t\t\tgoto twa_interrupt_bail;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (tw_dev->srb[request_id] == NULL) {\n\t\t\t\tif (request_id != tw_dev->chrdev_request_id) {\n\t\t\t\t\tif (twa_aen_complete(tw_dev, request_id))\n\t\t\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1b, \"Error completing AEN during attention interrupt\");\n\t\t\t\t} else {\n\t\t\t\t\ttw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\n\t\t\t\t\twake_up(&tw_dev->ioctl_wqueue);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstruct scsi_cmnd *cmd;\n\n\t\t\t\tcmd = tw_dev->srb[request_id];\n\n\t\t\t\ttwa_scsiop_execute_scsi_complete(tw_dev, request_id);\n\t\t\t\t \n\t\t\t\tif (error == 0) {\n\t\t\t\t\tcmd->result = (DID_OK << 16);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (error == 1) {\n\t\t\t\t\t \n\t\t\t\t\tcmd->result = (DID_OK << 16) | SAM_STAT_CHECK_CONDITION;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif ((scsi_sg_count(cmd) <= 1) && (full_command_packet->command.newcommand.status == 0)) {\n\t\t\t\t\tu32 length = le32_to_cpu(full_command_packet->command.newcommand.sg_list[0].length);\n\n\t\t\t\t\tif (length < scsi_bufflen(cmd))\n\t\t\t\t\t\tscsi_set_resid(cmd, scsi_bufflen(cmd) - length);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (twa_command_mapped(cmd))\n\t\t\t\t\tscsi_dma_unmap(cmd);\n\t\t\t\tscsi_done(cmd);\n\t\t\t\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\t\t\t\ttwa_free_request_id(tw_dev, request_id);\n\t\t\t\ttw_dev->posted_request_count--;\n\t\t\t}\n\n\t\t\t \n\t\t\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\t\t\tif (twa_check_bits(status_reg_value)) {\n\t\t\t\tif (twa_decode_bits(tw_dev, status_reg_value)) {\n\t\t\t\t\tTW_CLEAR_ALL_INTERRUPTS(tw_dev);\n\t\t\t\t\tgoto twa_interrupt_bail;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ntwa_interrupt_bail:\n\tspin_unlock(tw_dev->host->host_lock);\n\treturn IRQ_RETVAL(handled);\n}  \n\n \nstatic void twa_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_command_packet, int request_id, dma_addr_t dma_handle, int length)\n{\n\tTW_Command *oldcommand;\n\tTW_Command_Apache *newcommand;\n\tTW_SG_Entry *sgl;\n\tunsigned int pae = 0;\n\n\tif ((sizeof(long) < 8) && (sizeof(dma_addr_t) > 4))\n\t\tpae = 1;\n\n\tif (TW_OP_OUT(full_command_packet->command.newcommand.opcode__reserved) == TW_OP_EXECUTE_SCSI) {\n\t\tnewcommand = &full_command_packet->command.newcommand;\n\t\tnewcommand->request_id__lunl =\n\t\t\tTW_REQ_LUN_IN(TW_LUN_OUT(newcommand->request_id__lunl), request_id);\n\t\tif (length) {\n\t\t\tnewcommand->sg_list[0].address = TW_CPU_TO_SGL(dma_handle + sizeof(TW_Ioctl_Buf_Apache));\n\t\t\tnewcommand->sg_list[0].length = cpu_to_le32(length);\n\t\t}\n\t\tnewcommand->sgl_entries__lunh =\n\t\t\tTW_REQ_LUN_IN(TW_LUN_OUT(newcommand->sgl_entries__lunh), length ? 1 : 0);\n\t} else {\n\t\toldcommand = &full_command_packet->command.oldcommand;\n\t\toldcommand->request_id = request_id;\n\n\t\tif (TW_SGL_OUT(oldcommand->opcode__sgloffset)) {\n\t\t\t \n\t\t\tif (tw_dev->tw_pci_dev->device == PCI_DEVICE_ID_3WARE_9690SA)\n\t\t\t\tsgl = (TW_SG_Entry *)((u32 *)oldcommand+oldcommand->size - (sizeof(TW_SG_Entry)/4) + pae);\n\t\t\telse\n\t\t\t\tsgl = (TW_SG_Entry *)((u32 *)oldcommand+TW_SGL_OUT(oldcommand->opcode__sgloffset));\n\t\t\tsgl->address = TW_CPU_TO_SGL(dma_handle + sizeof(TW_Ioctl_Buf_Apache));\n\t\t\tsgl->length = cpu_to_le32(length);\n\n\t\t\toldcommand->size += pae;\n\t\t}\n\t}\n}  \n\n \nstatic int twa_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)\n{\n\tint retval = 1, found = 0, response_request_id;\n\tTW_Response_Queue response_queue;\n\tTW_Command_Full *full_command_packet = tw_dev->command_packet_virt[request_id];\n\n\tif (twa_poll_status_gone(tw_dev, TW_STATUS_RESPONSE_QUEUE_EMPTY, seconds) == 0) {\n\t\tresponse_queue.value = readl(TW_RESPONSE_QUEUE_REG_ADDR(tw_dev));\n\t\tresponse_request_id = TW_RESID_OUT(response_queue.response_id);\n\t\tif (request_id != response_request_id) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1e, \"Found unexpected request id while polling for response\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (TW_OP_OUT(full_command_packet->command.newcommand.opcode__reserved) == TW_OP_EXECUTE_SCSI) {\n\t\t\tif (full_command_packet->command.newcommand.status != 0) {\n\t\t\t\t \n\t\t\t\ttwa_fill_sense(tw_dev, request_id, 0, 0);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t} else {\n\t\t\tif (full_command_packet->command.oldcommand.status != 0) {\n\t\t\t\t \n\t\t\t\ttwa_fill_sense(tw_dev, request_id, 0, 0);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t}\n\n\tif (found)\n\t\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_poll_status(TW_Device_Extension *tw_dev, u32 flag, int seconds)\n{\n\tu32 status_reg_value;\n\tunsigned long before;\n\tint retval = 1;\n\n\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\tbefore = jiffies;\n\n\tif (twa_check_bits(status_reg_value))\n\t\ttwa_decode_bits(tw_dev, status_reg_value);\n\n\twhile ((status_reg_value & flag) != flag) {\n\t\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\n\t\tif (twa_check_bits(status_reg_value))\n\t\t\ttwa_decode_bits(tw_dev, status_reg_value);\n\n\t\tif (time_after(jiffies, before + HZ * seconds))\n\t\t\tgoto out;\n\n\t\tmsleep(50);\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_poll_status_gone(TW_Device_Extension *tw_dev, u32 flag, int seconds)\n{\n\tu32 status_reg_value;\n\tunsigned long before;\n\tint retval = 1;\n\n\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\tbefore = jiffies;\n\n\tif (twa_check_bits(status_reg_value))\n\t\ttwa_decode_bits(tw_dev, status_reg_value);\n\n\twhile ((status_reg_value & flag) != 0) {\n\t\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\t\tif (twa_check_bits(status_reg_value))\n\t\t\ttwa_decode_bits(tw_dev, status_reg_value);\n\n\t\tif (time_after(jiffies, before + HZ * seconds))\n\t\t\tgoto out;\n\n\t\tmsleep(50);\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_post_command_packet(TW_Device_Extension *tw_dev, int request_id, char internal)\n{\n\tu32 status_reg_value;\n\tdma_addr_t command_que_value;\n\tint retval = 1;\n\n\tcommand_que_value = tw_dev->command_packet_phys[request_id];\n\n\t \n\tif ((tw_dev->tw_pci_dev->device == PCI_DEVICE_ID_3WARE_9650SE) ||\n\t    (tw_dev->tw_pci_dev->device == PCI_DEVICE_ID_3WARE_9690SA)) {\n\t\tcommand_que_value += TW_COMMAND_OFFSET;\n\t\twritel((u32)command_que_value, TW_COMMAND_QUEUE_REG_ADDR_LARGE(tw_dev));\n\t}\n\n\tstatus_reg_value = readl(TW_STATUS_REG_ADDR(tw_dev));\n\n\tif (twa_check_bits(status_reg_value))\n\t\ttwa_decode_bits(tw_dev, status_reg_value);\n\n\tif (((tw_dev->pending_request_count > 0) && (tw_dev->state[request_id] != TW_S_PENDING)) || (status_reg_value & TW_STATUS_COMMAND_QUEUE_FULL)) {\n\n\t\t \n\t\tif (!internal) {\n\t\t\tretval = SCSI_MLQUEUE_HOST_BUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (tw_dev->state[request_id] != TW_S_PENDING) {\n\t\t\ttw_dev->state[request_id] = TW_S_PENDING;\n\t\t\ttw_dev->pending_request_count++;\n\t\t\tif (tw_dev->pending_request_count > tw_dev->max_pending_request_count) {\n\t\t\t\ttw_dev->max_pending_request_count = tw_dev->pending_request_count;\n\t\t\t}\n\t\t\ttw_dev->pending_queue[tw_dev->pending_tail] = request_id;\n\t\t\ttw_dev->pending_tail = (tw_dev->pending_tail + 1) % TW_Q_LENGTH;\n\t\t}\n\t\tTW_UNMASK_COMMAND_INTERRUPT(tw_dev);\n\t\tgoto out;\n\t} else {\n\t\tif ((tw_dev->tw_pci_dev->device == PCI_DEVICE_ID_3WARE_9650SE) ||\n\t\t    (tw_dev->tw_pci_dev->device == PCI_DEVICE_ID_3WARE_9690SA)) {\n\t\t\t \n\t\t\twritel((u32)((u64)command_que_value >> 32), TW_COMMAND_QUEUE_REG_ADDR_LARGE(tw_dev) + 0x4);\n\t\t} else {\n\t\t\tif (sizeof(dma_addr_t) > 4) {\n\t\t\t\tcommand_que_value += TW_COMMAND_OFFSET;\n\t\t\t\twritel((u32)command_que_value, TW_COMMAND_QUEUE_REG_ADDR(tw_dev));\n\t\t\t\twritel((u32)((u64)command_que_value >> 32), TW_COMMAND_QUEUE_REG_ADDR(tw_dev) + 0x4);\n\t\t\t} else {\n\t\t\t\twritel(TW_COMMAND_OFFSET + command_que_value, TW_COMMAND_QUEUE_REG_ADDR(tw_dev));\n\t\t\t}\n\t\t}\n\t\ttw_dev->state[request_id] = TW_S_POSTED;\n\t\ttw_dev->posted_request_count++;\n\t\tif (tw_dev->posted_request_count > tw_dev->max_posted_request_count) {\n\t\t\ttw_dev->max_posted_request_count = tw_dev->posted_request_count;\n\t\t}\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_reset_device_extension(TW_Device_Extension *tw_dev)\n{\n\tint i = 0;\n\tint retval = 1;\n\tunsigned long flags = 0;\n\n\tset_bit(TW_IN_RESET, &tw_dev->flags);\n\tTW_DISABLE_INTERRUPTS(tw_dev);\n\tTW_MASK_COMMAND_INTERRUPT(tw_dev);\n\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\n\t \n\tfor (i = 0; i < TW_Q_LENGTH; i++) {\n\t\tif ((tw_dev->state[i] != TW_S_FINISHED) &&\n\t\t    (tw_dev->state[i] != TW_S_INITIAL) &&\n\t\t    (tw_dev->state[i] != TW_S_COMPLETED)) {\n\t\t\tif (tw_dev->srb[i]) {\n\t\t\t\tstruct scsi_cmnd *cmd = tw_dev->srb[i];\n\n\t\t\t\tcmd->result = (DID_RESET << 16);\n\t\t\t\tif (twa_command_mapped(cmd))\n\t\t\t\t\tscsi_dma_unmap(cmd);\n\t\t\t\tscsi_done(cmd);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < TW_Q_LENGTH; i++) {\n\t\ttw_dev->free_queue[i] = i;\n\t\ttw_dev->state[i] = TW_S_INITIAL;\n\t}\n\ttw_dev->free_head = TW_Q_START;\n\ttw_dev->free_tail = TW_Q_START;\n\ttw_dev->posted_request_count = 0;\n\ttw_dev->pending_request_count = 0;\n\ttw_dev->pending_head = TW_Q_START;\n\ttw_dev->pending_tail = TW_Q_START;\n\ttw_dev->reset_print = 0;\n\n\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\n\tif (twa_reset_sequence(tw_dev, 1))\n\t\tgoto out;\n\n\tTW_ENABLE_AND_CLEAR_INTERRUPTS(tw_dev);\n\tclear_bit(TW_IN_RESET, &tw_dev->flags);\n\ttw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\n\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset)\n{\n\tint tries = 0, retval = 1, flashed = 0, do_soft_reset = soft_reset;\n\n\twhile (tries < TW_MAX_RESET_TRIES) {\n\t\tif (do_soft_reset) {\n\t\t\tTW_SOFT_RESET(tw_dev);\n\t\t\t \n\t\t\tif (twa_empty_response_queue_large(tw_dev)) {\n\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x36, \"Response queue (large) empty failed during reset sequence\");\n\t\t\t\tdo_soft_reset = 1;\n\t\t\t\ttries++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (twa_poll_status(tw_dev, TW_STATUS_MICROCONTROLLER_READY | (do_soft_reset == 1 ? TW_STATUS_ATTENTION_INTERRUPT : 0), 60)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1f, \"Microcontroller not ready during reset sequence\");\n\t\t\tdo_soft_reset = 1;\n\t\t\ttries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (twa_empty_response_queue(tw_dev)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x20, \"Response queue empty failed during reset sequence\");\n\t\t\tdo_soft_reset = 1;\n\t\t\ttries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tflashed = 0;\n\n\t\t \n\t\tif (twa_check_srl(tw_dev, &flashed)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x21, \"Compatibility check failed during reset sequence\");\n\t\t\tdo_soft_reset = 1;\n\t\t\ttries++;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (flashed) {\n\t\t\t\ttries++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (twa_aen_drain_queue(tw_dev, soft_reset)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x22, \"AEN drain failed during reset sequence\");\n\t\t\tdo_soft_reset = 1;\n\t\t\ttries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tretval = 0;\n\t\tgoto out;\n\t}\nout:\n\treturn retval;\n}  \n\n \nstatic int twa_scsi_biosparam(struct scsi_device *sdev, struct block_device *bdev, sector_t capacity, int geom[])\n{\n\tint heads, sectors, cylinders;\n\n\tif (capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\tcylinders = sector_div(capacity, heads * sectors);\n\t} else {\n\t\theads = 64;\n\t\tsectors = 32;\n\t\tcylinders = sector_div(capacity, heads * sectors);\n\t}\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\n\treturn 0;\n}  \n\n \nstatic int twa_scsi_eh_reset(struct scsi_cmnd *SCpnt)\n{\n\tTW_Device_Extension *tw_dev = NULL;\n\tint retval = FAILED;\n\n\ttw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;\n\n\ttw_dev->num_resets++;\n\n\tsdev_printk(KERN_WARNING, SCpnt->device,\n\t\t\"WARNING: (0x%02X:0x%04X): Command (0x%x) timed out, resetting card.\\n\",\n\t\tTW_DRIVER, 0x2c, SCpnt->cmnd[0]);\n\n\t \n\tmutex_lock(&tw_dev->ioctl_lock);\n\n\t \n\tif (twa_reset_device_extension(tw_dev)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x2b, \"Controller reset failed during scsi host reset\");\n\t\tgoto out;\n\t}\n\n\tretval = SUCCESS;\nout:\n\tmutex_unlock(&tw_dev->ioctl_lock);\n\treturn retval;\n}  \n\n \nstatic int twa_scsi_queue_lck(struct scsi_cmnd *SCpnt)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tint request_id, retval;\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;\n\n\t \n\tif (test_bit(TW_IN_RESET, &tw_dev->flags)) {\n\t\tretval = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((SCpnt->device->lun != 0) && (tw_dev->tw_compat_info.working_srl < TW_FW_SRL_LUNS_SUPPORTED)) {\n\t\tSCpnt->result = (DID_BAD_TARGET << 16);\n\t\tdone(SCpnt);\n\t\tretval = 0;\n\t\tgoto out;\n\t}\n\n\t \n\ttwa_get_request_id(tw_dev, &request_id);\n\n\t \n\ttw_dev->srb[request_id] = SCpnt;\n\n\tretval = twa_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);\n\tswitch (retval) {\n\tcase SCSI_MLQUEUE_HOST_BUSY:\n\t\tif (twa_command_mapped(SCpnt))\n\t\t\tscsi_dma_unmap(SCpnt);\n\t\ttwa_free_request_id(tw_dev, request_id);\n\t\tbreak;\n\tcase 1:\n\t\tSCpnt->result = (DID_ERROR << 16);\n\t\tif (twa_command_mapped(SCpnt))\n\t\t\tscsi_dma_unmap(SCpnt);\n\t\tdone(SCpnt);\n\t\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\t\ttwa_free_request_id(tw_dev, request_id);\n\t\tretval = 0;\n\t}\nout:\n\treturn retval;\n}  \n\nstatic DEF_SCSI_QCMD(twa_scsi_queue)\n\n \nstatic int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,\n\t\t\t\t   unsigned char *cdb, int use_sg,\n\t\t\t\t   TW_SG_Entry *sglistarg)\n{\n\tTW_Command_Full *full_command_packet;\n\tTW_Command_Apache *command_packet;\n\tu32 num_sectors = 0x0;\n\tint i, sg_count;\n\tstruct scsi_cmnd *srb = NULL;\n\tstruct scatterlist *sg;\n\tint retval = 1;\n\n\tif (tw_dev->srb[request_id])\n\t\tsrb = tw_dev->srb[request_id];\n\n\t \n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tfull_command_packet->header.header_desc.size_header = 128;\n\tfull_command_packet->header.status_block.error = 0;\n\tfull_command_packet->header.status_block.severity__reserved = 0;\n\n\tcommand_packet = &full_command_packet->command.newcommand;\n\tcommand_packet->status = 0;\n\tcommand_packet->opcode__reserved = TW_OPRES_IN(0, TW_OP_EXECUTE_SCSI);\n\n\t \n\tif (!cdb)\n\t\tmemcpy(command_packet->cdb, srb->cmnd, TW_MAX_CDB_LEN);\n\telse\n\t\tmemcpy(command_packet->cdb, cdb, TW_MAX_CDB_LEN);\n\n\tif (srb) {\n\t\tcommand_packet->unit = srb->device->id;\n\t\tcommand_packet->request_id__lunl =\n\t\t\tTW_REQ_LUN_IN(srb->device->lun, request_id);\n\t} else {\n\t\tcommand_packet->request_id__lunl =\n\t\t\tTW_REQ_LUN_IN(0, request_id);\n\t\tcommand_packet->unit = 0;\n\t}\n\n\tcommand_packet->sgl_offset = 16;\n\n\tif (!sglistarg) {\n\t\t \n\n\t\tif (scsi_sg_count(srb)) {\n\t\t\tif (!twa_command_mapped(srb)) {\n\t\t\t\tif (srb->sc_data_direction == DMA_TO_DEVICE ||\n\t\t\t\t    srb->sc_data_direction == DMA_BIDIRECTIONAL)\n\t\t\t\t\tscsi_sg_copy_to_buffer(srb,\n\t\t\t\t\t\t\t       tw_dev->generic_buffer_virt[request_id],\n\t\t\t\t\t\t\t       TW_SECTOR_SIZE);\n\t\t\t\tcommand_packet->sg_list[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\n\t\t\t\tcommand_packet->sg_list[0].length = cpu_to_le32(TW_MIN_SGL_LENGTH);\n\t\t\t} else {\n\t\t\t\tsg_count = scsi_dma_map(srb);\n\t\t\t\tif (sg_count < 0)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tscsi_for_each_sg(srb, sg, sg_count, i) {\n\t\t\t\t\tcommand_packet->sg_list[i].address = TW_CPU_TO_SGL(sg_dma_address(sg));\n\t\t\t\t\tcommand_packet->sg_list[i].length = cpu_to_le32(sg_dma_len(sg));\n\t\t\t\t\tif (command_packet->sg_list[i].address & TW_CPU_TO_SGL(TW_ALIGNMENT_9000_SGL)) {\n\t\t\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x2e, \"Found unaligned sgl address during execute scsi\");\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcommand_packet->sgl_entries__lunh = TW_REQ_LUN_IN((srb->device->lun >> 4), scsi_sg_count(tw_dev->srb[request_id]));\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < use_sg; i++) {\n\t\t\tcommand_packet->sg_list[i].address = sglistarg[i].address;\n\t\t\tcommand_packet->sg_list[i].length = sglistarg[i].length;\n\t\t\tif (command_packet->sg_list[i].address & TW_CPU_TO_SGL(TW_ALIGNMENT_9000_SGL)) {\n\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x2f, \"Found unaligned sgl address during internal post\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tcommand_packet->sgl_entries__lunh = TW_REQ_LUN_IN(0, use_sg);\n\t}\n\n\tif (srb) {\n\t\tif (srb->cmnd[0] == READ_6 || srb->cmnd[0] == WRITE_6)\n\t\t\tnum_sectors = (u32)srb->cmnd[4];\n\n\t\tif (srb->cmnd[0] == READ_10 || srb->cmnd[0] == WRITE_10)\n\t\t\tnum_sectors = (u32)srb->cmnd[8] | ((u32)srb->cmnd[7] << 8);\n\t}\n\n\t \n\ttw_dev->sector_count = num_sectors;\n\tif (tw_dev->sector_count > tw_dev->max_sector_count)\n\t\ttw_dev->max_sector_count = tw_dev->sector_count;\n\n\t \n\tif (srb) {\n\t\ttw_dev->sgl_entries = scsi_sg_count(tw_dev->srb[request_id]);\n\t\tif (tw_dev->sgl_entries > tw_dev->max_sgl_entries)\n\t\t\ttw_dev->max_sgl_entries = tw_dev->sgl_entries;\n\t}\n\n\t \n\tif (srb) {\n\t\tretval = twa_post_command_packet(tw_dev, request_id, 0);\n\t} else {\n\t\ttwa_post_command_packet(tw_dev, request_id, 1);\n\t\tretval = 0;\n\t}\nout:\n\treturn retval;\n}  \n\n \nstatic void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int request_id)\n{\n\tstruct scsi_cmnd *cmd = tw_dev->srb[request_id];\n\n\tif (!twa_command_mapped(cmd) &&\n\t    (cmd->sc_data_direction == DMA_FROM_DEVICE ||\n\t     cmd->sc_data_direction == DMA_BIDIRECTIONAL)) {\n\t\tif (scsi_sg_count(cmd) == 1) {\n\t\t\tvoid *buf = tw_dev->generic_buffer_virt[request_id];\n\n\t\t\tscsi_sg_copy_from_buffer(cmd, buf, TW_SECTOR_SIZE);\n\t\t}\n\t}\n}  \n\n \nstatic void __twa_shutdown(TW_Device_Extension *tw_dev)\n{\n\t \n\tTW_DISABLE_INTERRUPTS(tw_dev);\n\n\t \n\tfree_irq(tw_dev->tw_pci_dev->irq, tw_dev);\n\n\tprintk(KERN_WARNING \"3w-9xxx: Shutting down host %d.\\n\", tw_dev->host->host_no);\n\n\t \n\tif (twa_initconnection(tw_dev, 1, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x31, \"Connection shutdown failed\");\n\t} else {\n\t\tprintk(KERN_WARNING \"3w-9xxx: Shutdown complete.\\n\");\n\t}\n\n\t \n\tTW_CLEAR_ALL_INTERRUPTS(tw_dev);\n}  \n\n \nstatic void twa_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\n\n\t__twa_shutdown(tw_dev);\n}  \n\n \nstatic char *twa_string_lookup(twa_message_type *table, unsigned int code)\n{\n\tint index;\n\n\tfor (index = 0; ((code != table[index].code) &&\n\t\t      (table[index].text != (char *)0)); index++);\n\treturn(table[index].text);\n}  \n\n \nstatic int twa_slave_configure(struct scsi_device *sdev)\n{\n\t \n\tblk_queue_rq_timeout(sdev->request_queue, 60 * HZ);\n\n\treturn 0;\n}  \n\nstatic const struct scsi_host_template driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"3ware 9000 Storage Controller\",\n\t.queuecommand\t\t= twa_scsi_queue,\n\t.eh_host_reset_handler\t= twa_scsi_eh_reset,\n\t.bios_param\t\t= twa_scsi_biosparam,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.can_queue\t\t= TW_Q_LENGTH-2,\n\t.slave_configure\t= twa_slave_configure,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= TW_APACHE_MAX_SGL_LENGTH,\n\t.max_sectors\t\t= TW_MAX_SECTORS,\n\t.cmd_per_lun\t\t= TW_MAX_CMDS_PER_LUN,\n\t.shost_groups\t\t= twa_host_groups,\n\t.emulated\t\t= 1,\n\t.no_write_same\t\t= 1,\n};\n\n \nstatic int twa_probe(struct pci_dev *pdev, const struct pci_device_id *dev_id)\n{\n\tstruct Scsi_Host *host = NULL;\n\tTW_Device_Extension *tw_dev;\n\tunsigned long mem_addr, mem_len;\n\tint retval;\n\n\tretval = pci_enable_device(pdev);\n\tif (retval) {\n\t\tTW_PRINTK(host, TW_DRIVER, 0x34, \"Failed to enable pci device\");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\tretval = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (retval)\n\t\tretval = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (retval) {\n\t\tTW_PRINTK(host, TW_DRIVER, 0x23, \"Failed to set dma mask\");\n\t\tretval = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\n\thost = scsi_host_alloc(&driver_template, sizeof(TW_Device_Extension));\n\tif (!host) {\n\t\tTW_PRINTK(host, TW_DRIVER, 0x24, \"Failed to allocate memory for device extension\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\ttw_dev = (TW_Device_Extension *)host->hostdata;\n\n\t \n\ttw_dev->host = host;\n\ttw_dev->tw_pci_dev = pdev;\n\n\tif (twa_initialize_device_extension(tw_dev)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x25, \"Failed to initialize device extension\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_free_device_extension;\n\t}\n\n\t \n\tretval = pci_request_regions(pdev, \"3w-9xxx\");\n\tif (retval) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x26, \"Failed to get mem region\");\n\t\tgoto out_free_device_extension;\n\t}\n\n\tif (pdev->device == PCI_DEVICE_ID_3WARE_9000) {\n\t\tmem_addr = pci_resource_start(pdev, 1);\n\t\tmem_len = pci_resource_len(pdev, 1);\n\t} else {\n\t\tmem_addr = pci_resource_start(pdev, 2);\n\t\tmem_len = pci_resource_len(pdev, 2);\n\t}\n\n\t \n\ttw_dev->base_addr = ioremap(mem_addr, mem_len);\n\tif (!tw_dev->base_addr) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x35, \"Failed to ioremap\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_release_mem_region;\n\t}\n\n\t \n\tTW_DISABLE_INTERRUPTS(tw_dev);\n\n\t \n\tif (twa_reset_sequence(tw_dev, 0)) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_iounmap;\n\t}\n\n\t \n\tif ((pdev->device == PCI_DEVICE_ID_3WARE_9650SE) ||\n\t    (pdev->device == PCI_DEVICE_ID_3WARE_9690SA))\n\t\thost->max_id = TW_MAX_UNITS_9650SE;\n\telse\n\t\thost->max_id = TW_MAX_UNITS;\n\n\thost->max_cmd_len = TW_MAX_CDB_LEN;\n\n\t \n\thost->max_lun = TW_MAX_LUNS(tw_dev->tw_compat_info.working_srl);\n\thost->max_channel = 0;\n\n\t \n\tretval = scsi_add_host(host, &pdev->dev);\n\tif (retval) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x27, \"scsi add host failed\");\n\t\tgoto out_iounmap;\n\t}\n\n\tpci_set_drvdata(pdev, host);\n\n\tprintk(KERN_WARNING \"3w-9xxx: scsi%d: Found a 3ware 9000 Storage Controller at 0x%lx, IRQ: %d.\\n\",\n\t       host->host_no, mem_addr, pdev->irq);\n\tprintk(KERN_WARNING \"3w-9xxx: scsi%d: Firmware %s, BIOS %s, Ports: %d.\\n\",\n\t       host->host_no,\n\t       (char *)twa_get_param(tw_dev, 0, TW_VERSION_TABLE,\n\t\t\t\t     TW_PARAM_FWVER, TW_PARAM_FWVER_LENGTH),\n\t       (char *)twa_get_param(tw_dev, 1, TW_VERSION_TABLE,\n\t\t\t\t     TW_PARAM_BIOSVER, TW_PARAM_BIOSVER_LENGTH),\n\t       le32_to_cpu(*(__le32 *)twa_get_param(tw_dev, 2, TW_INFORMATION_TABLE,\n\t\t\t\t     TW_PARAM_PORTCOUNT, TW_PARAM_PORTCOUNT_LENGTH)));\n\n\t \n\tif (use_msi && (pdev->device != PCI_DEVICE_ID_3WARE_9000) &&\n\t    !pci_enable_msi(pdev))\n\t\tset_bit(TW_USING_MSI, &tw_dev->flags);\n\n\t \n\tretval = request_irq(pdev->irq, twa_interrupt, IRQF_SHARED, \"3w-9xxx\", tw_dev);\n\tif (retval) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x30, \"Error requesting IRQ\");\n\t\tgoto out_remove_host;\n\t}\n\n\ttwa_device_extension_list[twa_device_extension_count] = tw_dev;\n\ttwa_device_extension_count++;\n\n\t \n\tTW_ENABLE_AND_CLEAR_INTERRUPTS(tw_dev);\n\n\t \n\tscsi_scan_host(host);\n\n\tif (twa_major == -1) {\n\t\tif ((twa_major = register_chrdev (0, \"twa\", &twa_fops)) < 0)\n\t\t\tTW_PRINTK(host, TW_DRIVER, 0x29, \"Failed to register character device\");\n\t}\n\treturn 0;\n\nout_remove_host:\n\tif (test_bit(TW_USING_MSI, &tw_dev->flags))\n\t\tpci_disable_msi(pdev);\n\tscsi_remove_host(host);\nout_iounmap:\n\tiounmap(tw_dev->base_addr);\nout_release_mem_region:\n\tpci_release_regions(pdev);\nout_free_device_extension:\n\ttwa_free_device_extension(tw_dev);\n\tscsi_host_put(host);\nout_disable_device:\n\tpci_disable_device(pdev);\n\n\treturn retval;\n}  \n\n \nstatic void twa_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\n\n\tscsi_remove_host(tw_dev->host);\n\n\t \n\tif (twa_major >= 0) {\n\t\tunregister_chrdev(twa_major, \"twa\");\n\t\ttwa_major = -1;\n\t}\n\n\t \n\t__twa_shutdown(tw_dev);\n\n\t \n\tif (test_bit(TW_USING_MSI, &tw_dev->flags))\n\t\tpci_disable_msi(pdev);\n\n\t \n\tiounmap(tw_dev->base_addr);\n\n\t \n\tpci_release_regions(pdev);\n\n\t \n\ttwa_free_device_extension(tw_dev);\n\n\tscsi_host_put(tw_dev->host);\n\tpci_disable_device(pdev);\n\ttwa_device_extension_count--;\n}  \n\n \nstatic int __maybe_unused twa_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\n\n\tprintk(KERN_WARNING \"3w-9xxx: Suspending host %d.\\n\", tw_dev->host->host_no);\n\n\tTW_DISABLE_INTERRUPTS(tw_dev);\n\tfree_irq(tw_dev->tw_pci_dev->irq, tw_dev);\n\n\tif (test_bit(TW_USING_MSI, &tw_dev->flags))\n\t\tpci_disable_msi(pdev);\n\n\t \n\tif (twa_initconnection(tw_dev, 1, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x38, \"Connection shutdown failed during suspend\");\n\t} else {\n\t\tprintk(KERN_WARNING \"3w-9xxx: Suspend complete.\\n\");\n\t}\n\tTW_CLEAR_ALL_INTERRUPTS(tw_dev);\n\n\treturn 0;\n}  \n\n \nstatic int __maybe_unused twa_resume(struct device *dev)\n{\n\tint retval = 0;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\n\n\tprintk(KERN_WARNING \"3w-9xxx: Resuming host %d.\\n\", tw_dev->host->host_no);\n\n\tpci_try_set_mwi(pdev);\n\n\tretval = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (retval)\n\t\tretval = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (retval) {\n\t\tTW_PRINTK(host, TW_DRIVER, 0x40, \"Failed to set dma mask during resume\");\n\t\tretval = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\n\t \n\tif (twa_reset_sequence(tw_dev, 0)) {\n\t\tretval = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\n\t \n\tretval = request_irq(pdev->irq, twa_interrupt, IRQF_SHARED, \"3w-9xxx\", tw_dev);\n\tif (retval) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x42, \"Error requesting IRQ during resume\");\n\t\tretval = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\n\t \n\tif (test_bit(TW_USING_MSI, &tw_dev->flags))\n\t\tpci_enable_msi(pdev);\n\n\t \n\tTW_ENABLE_AND_CLEAR_INTERRUPTS(tw_dev);\n\n\tprintk(KERN_WARNING \"3w-9xxx: Resume complete.\\n\");\n\treturn 0;\n\nout_disable_device:\n\tscsi_remove_host(host);\n\n\treturn retval;\n}  \n\n \nstatic struct pci_device_id twa_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_3WARE, PCI_DEVICE_ID_3WARE_9000,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{ PCI_VENDOR_ID_3WARE, PCI_DEVICE_ID_3WARE_9550SX,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{ PCI_VENDOR_ID_3WARE, PCI_DEVICE_ID_3WARE_9650SE,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{ PCI_VENDOR_ID_3WARE, PCI_DEVICE_ID_3WARE_9690SA,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, twa_pci_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(twa_pm_ops, twa_suspend, twa_resume);\n\n \nstatic struct pci_driver twa_driver = {\n\t.name\t\t= \"3w-9xxx\",\n\t.id_table\t= twa_pci_tbl,\n\t.probe\t\t= twa_probe,\n\t.remove\t\t= twa_remove,\n\t.driver.pm\t= &twa_pm_ops,\n\t.shutdown\t= twa_shutdown\n};\n\n \nstatic int __init twa_init(void)\n{\n\tprintk(KERN_WARNING \"3ware 9000 Storage Controller device driver for Linux v%s.\\n\", TW_DRIVER_VERSION);\n\n\treturn pci_register_driver(&twa_driver);\n}  \n\n \nstatic void __exit twa_exit(void)\n{\n\tpci_unregister_driver(&twa_driver);\n}  \n\nmodule_init(twa_init);\nmodule_exit(twa_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}