{
  "module_name": "g_NCR5380.c",
  "hash_id": "5f9d580dfc502b783dc59650b320dbb68be662e3a0d7267445add87e4d478e3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/g_NCR5380.c",
  "human_readable_source": "\n \n\n#include <asm/io.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <scsi/scsi_host.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/isa.h>\n#include <linux/pnp.h>\n#include <linux/interrupt.h>\n\n \n\n#define NCR5380_read(reg) \\\n\tioread8(hostdata->io + hostdata->offset + (reg))\n#define NCR5380_write(reg, value) \\\n\tiowrite8(value, hostdata->io + hostdata->offset + (reg))\n\n#define NCR5380_implementation_fields \\\n\tint offset; \\\n\tint c400_ctl_status; \\\n\tint c400_blk_cnt; \\\n\tint c400_host_buf; \\\n\tint io_width; \\\n\tint pdma_residual; \\\n\tint board\n\n#define NCR5380_dma_xfer_len            generic_NCR5380_dma_xfer_len\n#define NCR5380_dma_recv_setup          generic_NCR5380_precv\n#define NCR5380_dma_send_setup          generic_NCR5380_psend\n#define NCR5380_dma_residual            generic_NCR5380_dma_residual\n\n#define NCR5380_intr                    generic_NCR5380_intr\n#define NCR5380_queue_command           generic_NCR5380_queue_command\n#define NCR5380_abort                   generic_NCR5380_abort\n#define NCR5380_host_reset              generic_NCR5380_host_reset\n#define NCR5380_info                    generic_NCR5380_info\n\n#define NCR5380_io_delay(x)             udelay(x)\n\n#include \"NCR5380.h\"\n\n#define DRV_MODULE_NAME \"g_NCR5380\"\n\n#define NCR53C400_mem_base 0x3880\n#define NCR53C400_host_buffer 0x3900\n#define NCR53C400_region_size 0x3a00\n\n#define BOARD_NCR5380 0\n#define BOARD_NCR53C400 1\n#define BOARD_NCR53C400A 2\n#define BOARD_DTC3181E 3\n#define BOARD_HP_C2502 4\n\n#define IRQ_AUTO 254\n\n#define MAX_CARDS 8\n#define DMA_MAX_SIZE 32768\n\n \nstatic int ncr_irq = -1;\nstatic int ncr_addr;\nstatic int ncr_5380;\nstatic int ncr_53c400;\nstatic int ncr_53c400a;\nstatic int dtc_3181e;\nstatic int hp_c2502;\nmodule_param_hw(ncr_irq, int, irq, 0);\nmodule_param_hw(ncr_addr, int, ioport, 0);\nmodule_param(ncr_5380, int, 0);\nmodule_param(ncr_53c400, int, 0);\nmodule_param(ncr_53c400a, int, 0);\nmodule_param(dtc_3181e, int, 0);\nmodule_param(hp_c2502, int, 0);\n\nstatic int irq[] = { -1, -1, -1, -1, -1, -1, -1, -1 };\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nMODULE_PARM_DESC(irq, \"IRQ number(s) (0=none, 254=auto [default])\");\n\nstatic int base[] = { 0, 0, 0, 0, 0, 0, 0, 0 };\nmodule_param_hw_array(base, int, ioport, NULL, 0);\nMODULE_PARM_DESC(base, \"base address(es)\");\n\nstatic int card[] = { -1, -1, -1, -1, -1, -1, -1, -1 };\nmodule_param_array(card, int, NULL, 0);\nMODULE_PARM_DESC(card, \"card type (0=NCR5380, 1=NCR53C400, 2=NCR53C400A, 3=DTC3181E, 4=HP C2502)\");\n\nMODULE_ALIAS(\"g_NCR5380_mmio\");\nMODULE_LICENSE(\"GPL\");\n\nstatic void g_NCR5380_trigger_irq(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\n\t \n\tNCR5380_write(TARGET_COMMAND_REG,\n\t              PHASE_SR_TO_TCR(NCR5380_read(STATUS_REG) & PHASE_MASK));\n\tNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\n\tNCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);\n\tNCR5380_write(INITIATOR_COMMAND_REG,\n\t              ICR_BASE | ICR_ASSERT_DATA | ICR_ASSERT_SEL);\n\n\tmsleep(1);\n\n\tNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\n\tNCR5380_write(SELECT_ENABLE_REG, 0);\n\tNCR5380_write(TARGET_COMMAND_REG, 0);\n}\n\n \n\nstatic int g_NCR5380_probe_irq(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tint irq_mask, irq;\n\n\tNCR5380_read(RESET_PARITY_INTERRUPT_REG);\n\tirq_mask = probe_irq_on();\n\tg_NCR5380_trigger_irq(instance);\n\tirq = probe_irq_off(irq_mask);\n\tNCR5380_read(RESET_PARITY_INTERRUPT_REG);\n\n\tif (irq <= 0)\n\t\treturn NO_IRQ;\n\treturn irq;\n}\n\n \nstatic void magic_configure(int idx, u8 irq, u8 magic[])\n{\n\tu8 cfg = 0;\n\n\toutb(magic[0], 0x779);\n\toutb(magic[1], 0x379);\n\toutb(magic[2], 0x379);\n\toutb(magic[3], 0x379);\n\toutb(magic[4], 0x379);\n\n\tif (irq == 9)\n\t\tirq = 2;\n\n\tif (idx >= 0 && idx <= 7)\n\t\tcfg = 0x80 | idx | (irq << 4);\n\toutb(cfg, 0x379);\n}\n\nstatic irqreturn_t legacy_empty_irq_handler(int irq, void *dev_id)\n{\n\treturn IRQ_HANDLED;\n}\n\nstatic int legacy_find_free_irq(int *irq_table)\n{\n\twhile (*irq_table != -1) {\n\t\tif (!request_irq(*irq_table, legacy_empty_irq_handler,\n\t\t                 IRQF_PROBE_SHARED, \"Test IRQ\",\n\t\t                 (void *)irq_table)) {\n\t\t\tfree_irq(*irq_table, (void *) irq_table);\n\t\t\treturn *irq_table;\n\t\t}\n\t\tirq_table++;\n\t}\n\treturn -1;\n}\n\nstatic unsigned int ncr_53c400a_ports[] = {\n\t0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0\n};\nstatic unsigned int dtc_3181e_ports[] = {\n\t0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0\n};\nstatic u8 ncr_53c400a_magic[] = {\t \n\t0x59, 0xb9, 0xc5, 0xae, 0xa6\n};\nstatic u8 hp_c2502_magic[] = {\t \n\t0x0f, 0x22, 0xf0, 0x20, 0x80\n};\nstatic int hp_c2502_irqs[] = {\n\t9, 5, 7, 3, 4, -1\n};\n\nstatic int generic_NCR5380_init_one(const struct scsi_host_template *tpnt,\n\t\t\tstruct device *pdev, int base, int irq, int board)\n{\n\tbool is_pmio = base <= 0xffff;\n\tint ret;\n\tint flags = 0;\n\tunsigned int *ports = NULL;\n\tu8 *magic = NULL;\n\tint i;\n\tint port_idx = -1;\n\tunsigned long region_size;\n\tstruct Scsi_Host *instance;\n\tstruct NCR5380_hostdata *hostdata;\n\tu8 __iomem *iomem;\n\n\tswitch (board) {\n\tcase BOARD_NCR5380:\n\t\tflags = FLAG_NO_PSEUDO_DMA | FLAG_DMA_FIXUP;\n\t\tbreak;\n\tcase BOARD_NCR53C400A:\n\t\tports = ncr_53c400a_ports;\n\t\tmagic = ncr_53c400a_magic;\n\t\tbreak;\n\tcase BOARD_HP_C2502:\n\t\tports = ncr_53c400a_ports;\n\t\tmagic = hp_c2502_magic;\n\t\tbreak;\n\tcase BOARD_DTC3181E:\n\t\tports = dtc_3181e_ports;\n\t\tmagic = ncr_53c400a_magic;\n\t\tbreak;\n\t}\n\n\tif (is_pmio && ports && magic) {\n\t\t \n\n\t\t \n\t\tmagic_configure(-1, 0, magic);\n\n\t\tregion_size = 16;\n\t\tif (base)\n\t\t\tfor (i = 0; ports[i]; i++) {\n\t\t\t\tif (base == ports[i]) {\t \n\t\t\t\t\tif (!request_region(ports[i],\n\t\t\t\t\t\t\t    region_size,\n\t\t\t\t\t\t\t    \"ncr53c80\"))\n\t\t\t\t\t\treturn -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\tfor (i = 0; ports[i]; i++) {\n\t\t\t\tif (!request_region(ports[i], region_size,\n\t\t\t\t\t\t    \"ncr53c80\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (inb(ports[i]) == 0xff)\n\t\t\t\t\tbreak;\n\t\t\t\trelease_region(ports[i], region_size);\n\t\t\t}\n\t\tif (ports[i]) {\n\t\t\t \n\t\t\tmagic_configure(i, 0, magic);  \n\t\t\tbase = ports[i];\n\t\t\toutb(0xc0, base + 9);\n\t\t\tif (inb(base + 9) != 0x80) {\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto out_release;\n\t\t\t}\n\t\t\tport_idx = i;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t} else if (is_pmio) {\n\t\t \n\t\tregion_size = 8;\n\t\tif (!base || !request_region(base, region_size, \"ncr5380\"))\n\t\t\treturn -EBUSY;\n\t} else {\t \n\t\tregion_size = NCR53C400_region_size;\n\t\tif (!request_mem_region(base, region_size, \"ncr5380\"))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (is_pmio)\n\t\tiomem = ioport_map(base, region_size);\n\telse\n\t\tiomem = ioremap(base, region_size);\n\n\tif (!iomem) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\n\tinstance = scsi_host_alloc(tpnt, sizeof(struct NCR5380_hostdata));\n\tif (instance == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\thostdata = shost_priv(instance);\n\n\thostdata->board = board;\n\thostdata->io = iomem;\n\thostdata->region_size = region_size;\n\n\tif (is_pmio) {\n\t\thostdata->io_port = base;\n\t\thostdata->io_width = 1;  \n\t\thostdata->offset = 0;\n\n\t\t \n\t\tswitch (board) {\n\t\tcase BOARD_NCR53C400:\n\t\t\thostdata->io_port += 8;\n\t\t\thostdata->c400_ctl_status = 0;\n\t\t\thostdata->c400_blk_cnt = 1;\n\t\t\thostdata->c400_host_buf = 4;\n\t\t\tbreak;\n\t\tcase BOARD_DTC3181E:\n\t\t\thostdata->io_width = 2;\t \n\t\t\tfallthrough;\n\t\tcase BOARD_NCR53C400A:\n\t\tcase BOARD_HP_C2502:\n\t\t\thostdata->c400_ctl_status = 9;\n\t\t\thostdata->c400_blk_cnt = 10;\n\t\t\thostdata->c400_host_buf = 8;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\thostdata->base = base;\n\t\thostdata->offset = NCR53C400_mem_base;\n\t\tswitch (board) {\n\t\tcase BOARD_NCR53C400:\n\t\t\thostdata->c400_ctl_status = 0x100;\n\t\t\thostdata->c400_blk_cnt = 0x101;\n\t\t\thostdata->c400_host_buf = 0x104;\n\t\t\tbreak;\n\t\tcase BOARD_DTC3181E:\n\t\tcase BOARD_NCR53C400A:\n\t\tcase BOARD_HP_C2502:\n\t\t\tpr_err(DRV_MODULE_NAME \": unknown register offsets\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unregister;\n\t\t}\n\t}\n\n\t \n\tNCR5380_write(MODE_REG, 0);\n\tif (NCR5380_read(MODE_REG) != 0) {\n\t\tret = -ENODEV;\n\t\tgoto out_unregister;\n\t}\n\n\tret = NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP);\n\tif (ret)\n\t\tgoto out_unregister;\n\n\tswitch (board) {\n\tcase BOARD_NCR53C400:\n\tcase BOARD_DTC3181E:\n\tcase BOARD_NCR53C400A:\n\tcase BOARD_HP_C2502:\n\t\tNCR5380_write(hostdata->c400_ctl_status, CSR_BASE);\n\t}\n\n\tNCR5380_maybe_reset_bus(instance);\n\n\t \n\tif (irq == 255 || irq == 0)\n\t\tirq = NO_IRQ;\n\telse if (irq == -1)\n\t\tirq = IRQ_AUTO;\n\n\tif (board == BOARD_HP_C2502) {\n\t\tint *irq_table = hp_c2502_irqs;\n\t\tint board_irq = -1;\n\n\t\tswitch (irq) {\n\t\tcase NO_IRQ:\n\t\t\tboard_irq = 0;\n\t\t\tbreak;\n\t\tcase IRQ_AUTO:\n\t\t\tboard_irq = legacy_find_free_irq(irq_table);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twhile (*irq_table != -1)\n\t\t\t\tif (*irq_table++ == irq)\n\t\t\t\t\tboard_irq = irq;\n\t\t}\n\n\t\tif (board_irq <= 0) {\n\t\t\tboard_irq = 0;\n\t\t\tirq = NO_IRQ;\n\t\t}\n\n\t\tmagic_configure(port_idx, board_irq, magic);\n\t}\n\n\tif (irq == IRQ_AUTO) {\n\t\tinstance->irq = g_NCR5380_probe_irq(instance);\n\t\tif (instance->irq == NO_IRQ)\n\t\t\tshost_printk(KERN_INFO, instance, \"no irq detected\\n\");\n\t} else {\n\t\tinstance->irq = irq;\n\t\tif (instance->irq == NO_IRQ)\n\t\t\tshost_printk(KERN_INFO, instance, \"no irq provided\\n\");\n\t}\n\n\tif (instance->irq != NO_IRQ) {\n\t\tif (request_irq(instance->irq, generic_NCR5380_intr,\n\t\t\t\t0, \"NCR5380\", instance)) {\n\t\t\tinstance->irq = NO_IRQ;\n\t\t\tshost_printk(KERN_INFO, instance,\n\t\t\t             \"irq %d denied\\n\", instance->irq);\n\t\t} else {\n\t\t\tshost_printk(KERN_INFO, instance,\n\t\t\t             \"irq %d acquired\\n\", instance->irq);\n\t\t}\n\t}\n\n\tret = scsi_add_host(instance, pdev);\n\tif (ret)\n\t\tgoto out_free_irq;\n\tscsi_scan_host(instance);\n\tdev_set_drvdata(pdev, instance);\n\treturn 0;\n\nout_free_irq:\n\tif (instance->irq != NO_IRQ)\n\t\tfree_irq(instance->irq, instance);\n\tNCR5380_exit(instance);\nout_unregister:\n\tscsi_host_put(instance);\nout_unmap:\n\tiounmap(iomem);\nout_release:\n\tif (is_pmio)\n\t\trelease_region(base, region_size);\n\telse\n\t\trelease_mem_region(base, region_size);\n\treturn ret;\n}\n\nstatic void generic_NCR5380_release_resources(struct Scsi_Host *instance)\n{\n\tstruct NCR5380_hostdata *hostdata = shost_priv(instance);\n\tvoid __iomem *iomem = hostdata->io;\n\tunsigned long io_port = hostdata->io_port;\n\tunsigned long base = hostdata->base;\n\tunsigned long region_size = hostdata->region_size;\n\n\tscsi_remove_host(instance);\n\tif (instance->irq != NO_IRQ)\n\t\tfree_irq(instance->irq, instance);\n\tNCR5380_exit(instance);\n\tscsi_host_put(instance);\n\tiounmap(iomem);\n\tif (io_port)\n\t\trelease_region(io_port, region_size);\n\telse\n\t\trelease_mem_region(base, region_size);\n}\n\n \n\nstatic void wait_for_53c80_access(struct NCR5380_hostdata *hostdata)\n{\n\tint count = 10000;\n\n\tdo {\n\t\tif (hostdata->board == BOARD_DTC3181E)\n\t\t\tudelay(4);  \n\t\tif (NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)\n\t\t\treturn;\n\t} while (--count > 0);\n\n\tscmd_printk(KERN_ERR, hostdata->connected,\n\t            \"53c80 registers not accessible, device will be reset\\n\");\n\tNCR5380_write(hostdata->c400_ctl_status, CSR_RESET);\n\tNCR5380_write(hostdata->c400_ctl_status, CSR_BASE);\n}\n\n \n\nstatic inline int generic_NCR5380_precv(struct NCR5380_hostdata *hostdata,\n                                        unsigned char *dst, int len)\n{\n\tint residual;\n\tint start = 0;\n\n\tNCR5380_write(hostdata->c400_ctl_status, CSR_BASE | CSR_TRANS_DIR);\n\tNCR5380_write(hostdata->c400_blk_cnt, len / 128);\n\n\tdo {\n\t\tif (start == len - 128) {\n\t\t\t \n\t\t\tif (NCR5380_poll_politely(hostdata, hostdata->c400_ctl_status,\n\t\t\t                          CSR_HOST_BUF_NOT_RDY, 0, 0) < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (NCR5380_poll_politely2(hostdata, hostdata->c400_ctl_status,\n\t\t\t                           CSR_HOST_BUF_NOT_RDY, 0,\n\t\t\t                           hostdata->c400_ctl_status,\n\t\t\t                           CSR_GATED_53C80_IRQ,\n\t\t\t                           CSR_GATED_53C80_IRQ, 0) < 0 ||\n\t\t\t    NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (hostdata->io_port && hostdata->io_width == 2)\n\t\t\tinsw(hostdata->io_port + hostdata->c400_host_buf,\n\t\t\t     dst + start, 64);\n\t\telse if (hostdata->io_port)\n\t\t\tinsb(hostdata->io_port + hostdata->c400_host_buf,\n\t\t\t     dst + start, 128);\n\t\telse\n\t\t\tmemcpy_fromio(dst + start,\n\t\t\t\thostdata->io + NCR53C400_host_buffer, 128);\n\t\tstart += 128;\n\t} while (start < len);\n\n\tresidual = len - start;\n\n\tif (residual != 0) {\n\t\t \n\t\tNCR5380_write(hostdata->c400_ctl_status, CSR_RESET);\n\t\tNCR5380_write(hostdata->c400_ctl_status, CSR_BASE);\n\t}\n\twait_for_53c80_access(hostdata);\n\n\tif (residual == 0 && NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,\n\t                                           BASR_END_DMA_TRANSFER,\n\t                                           BASR_END_DMA_TRANSFER,\n\t\t\t\t\t\t   0) < 0)\n\t\tscmd_printk(KERN_ERR, hostdata->connected, \"%s: End of DMA timeout\\n\",\n\t\t            __func__);\n\n\thostdata->pdma_residual = residual;\n\n\treturn 0;\n}\n\n \n\nstatic inline int generic_NCR5380_psend(struct NCR5380_hostdata *hostdata,\n                                        unsigned char *src, int len)\n{\n\tint residual;\n\tint start = 0;\n\n\tNCR5380_write(hostdata->c400_ctl_status, CSR_BASE);\n\tNCR5380_write(hostdata->c400_blk_cnt, len / 128);\n\n\tdo {\n\t\tif (NCR5380_poll_politely2(hostdata, hostdata->c400_ctl_status,\n\t\t                           CSR_HOST_BUF_NOT_RDY, 0,\n\t\t                           hostdata->c400_ctl_status,\n\t\t                           CSR_GATED_53C80_IRQ,\n\t\t                           CSR_GATED_53C80_IRQ, 0) < 0 ||\n\t\t    NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY) {\n\t\t\t \n\t\t\tif (start >= 128)\n\t\t\t\tstart -= 128;\n\t\t\tif (start >= 128)\n\t\t\t\tstart -= 128;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (start >= len && NCR5380_read(hostdata->c400_blk_cnt) == 0)\n\t\t\tbreak;\n\n\t\tif (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ) {\n\t\t\t \n\t\t\tif (start >= 128)\n\t\t\t\tstart -= 128;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (start >= len)\n\t\t\tcontinue;\n\n\t\tif (hostdata->io_port && hostdata->io_width == 2)\n\t\t\toutsw(hostdata->io_port + hostdata->c400_host_buf,\n\t\t\t      src + start, 64);\n\t\telse if (hostdata->io_port)\n\t\t\toutsb(hostdata->io_port + hostdata->c400_host_buf,\n\t\t\t      src + start, 128);\n\t\telse\n\t\t\tmemcpy_toio(hostdata->io + NCR53C400_host_buffer,\n\t\t\t            src + start, 128);\n\t\tstart += 128;\n\t} while (1);\n\n\tresidual = len - start;\n\n\tif (residual != 0) {\n\t\t \n\t\tNCR5380_write(hostdata->c400_ctl_status, CSR_RESET);\n\t\tNCR5380_write(hostdata->c400_ctl_status, CSR_BASE);\n\t}\n\twait_for_53c80_access(hostdata);\n\n\tif (residual == 0) {\n\t\tif (NCR5380_poll_politely(hostdata, TARGET_COMMAND_REG,\n\t\t                          TCR_LAST_BYTE_SENT, TCR_LAST_BYTE_SENT,\n\t\t\t\t\t  0) < 0)\n\t\t\tscmd_printk(KERN_ERR, hostdata->connected,\n\t\t\t            \"%s: Last Byte Sent timeout\\n\", __func__);\n\n\t\tif (NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,\n\t\t                          BASR_END_DMA_TRANSFER, BASR_END_DMA_TRANSFER,\n\t\t\t\t\t  0) < 0)\n\t\t\tscmd_printk(KERN_ERR, hostdata->connected, \"%s: End of DMA timeout\\n\",\n\t\t\t            __func__);\n\t}\n\n\thostdata->pdma_residual = residual;\n\n\treturn 0;\n}\n\nstatic int generic_NCR5380_dma_xfer_len(struct NCR5380_hostdata *hostdata,\n                                        struct scsi_cmnd *cmd)\n{\n\tint transfersize = NCR5380_to_ncmd(cmd)->this_residual;\n\n\tif (hostdata->flags & FLAG_NO_PSEUDO_DMA)\n\t\treturn 0;\n\n\t \n\tif (transfersize % 128)\n\t\treturn 0;\n\n\t \n\tif (hostdata->board == BOARD_DTC3181E &&\n\t    cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\ttransfersize = min(transfersize, 512);\n\n\treturn min(transfersize, DMA_MAX_SIZE);\n}\n\nstatic int generic_NCR5380_dma_residual(struct NCR5380_hostdata *hostdata)\n{\n\treturn hostdata->pdma_residual;\n}\n\n \n\n#include \"NCR5380.c\"\n\nstatic const struct scsi_host_template driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.proc_name\t\t= DRV_MODULE_NAME,\n\t.name\t\t\t= \"Generic NCR5380/NCR53C400 SCSI\",\n\t.info\t\t\t= generic_NCR5380_info,\n\t.queuecommand\t\t= generic_NCR5380_queue_command,\n\t.eh_abort_handler\t= generic_NCR5380_abort,\n\t.eh_host_reset_handler\t= generic_NCR5380_host_reset,\n\t.can_queue\t\t= 16,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= 2,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.cmd_size\t\t= sizeof(struct NCR5380_cmd),\n\t.max_sectors\t\t= 128,\n};\n\nstatic int generic_NCR5380_isa_match(struct device *pdev, unsigned int ndev)\n{\n\tint ret = generic_NCR5380_init_one(&driver_template, pdev, base[ndev],\n\t                                   irq[ndev], card[ndev]);\n\tif (ret) {\n\t\tif (base[ndev])\n\t\t\tprintk(KERN_WARNING \"Card not found at address 0x%03x\\n\",\n\t\t\t       base[ndev]);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void generic_NCR5380_isa_remove(struct device *pdev,\n\t\t\t\t       unsigned int ndev)\n{\n\tgeneric_NCR5380_release_resources(dev_get_drvdata(pdev));\n\tdev_set_drvdata(pdev, NULL);\n}\n\nstatic struct isa_driver generic_NCR5380_isa_driver = {\n\t.match\t\t= generic_NCR5380_isa_match,\n\t.remove\t\t= generic_NCR5380_isa_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRV_MODULE_NAME\n\t},\n};\n\n#ifdef CONFIG_PNP\nstatic const struct pnp_device_id generic_NCR5380_pnp_ids[] = {\n\t{ .id = \"DTC436e\", .driver_data = BOARD_DTC3181E },\n\t{ .id = \"\" }\n};\nMODULE_DEVICE_TABLE(pnp, generic_NCR5380_pnp_ids);\n\nstatic int generic_NCR5380_pnp_probe(struct pnp_dev *pdev,\n                                     const struct pnp_device_id *id)\n{\n\tint base, irq;\n\n\tif (pnp_activate_dev(pdev) < 0)\n\t\treturn -EBUSY;\n\n\tbase = pnp_port_start(pdev, 0);\n\tirq = pnp_irq(pdev, 0);\n\n\treturn generic_NCR5380_init_one(&driver_template, &pdev->dev, base, irq,\n\t                                id->driver_data);\n}\n\nstatic void generic_NCR5380_pnp_remove(struct pnp_dev *pdev)\n{\n\tgeneric_NCR5380_release_resources(pnp_get_drvdata(pdev));\n\tpnp_set_drvdata(pdev, NULL);\n}\n\nstatic struct pnp_driver generic_NCR5380_pnp_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= generic_NCR5380_pnp_ids,\n\t.probe\t\t= generic_NCR5380_pnp_probe,\n\t.remove\t\t= generic_NCR5380_pnp_remove,\n};\n#endif  \n\nstatic int pnp_registered, isa_registered;\n\nstatic int __init generic_NCR5380_init(void)\n{\n\tint ret = 0;\n\n\t \n\tif (irq[0] == -1 && base[0] == 0 && card[0] == -1) {\n\t\tirq[0] = ncr_irq;\n\t\tbase[0] = ncr_addr;\n\t\tif (ncr_5380)\n\t\t\tcard[0] = BOARD_NCR5380;\n\t\tif (ncr_53c400)\n\t\t\tcard[0] = BOARD_NCR53C400;\n\t\tif (ncr_53c400a)\n\t\t\tcard[0] = BOARD_NCR53C400A;\n\t\tif (dtc_3181e)\n\t\t\tcard[0] = BOARD_DTC3181E;\n\t\tif (hp_c2502)\n\t\t\tcard[0] = BOARD_HP_C2502;\n\t}\n\n#ifdef CONFIG_PNP\n\tif (!pnp_register_driver(&generic_NCR5380_pnp_driver))\n\t\tpnp_registered = 1;\n#endif\n\tret = isa_register_driver(&generic_NCR5380_isa_driver, MAX_CARDS);\n\tif (!ret)\n\t\tisa_registered = 1;\n\n\treturn (pnp_registered || isa_registered) ? 0 : ret;\n}\n\nstatic void __exit generic_NCR5380_exit(void)\n{\n#ifdef CONFIG_PNP\n\tif (pnp_registered)\n\t\tpnp_unregister_driver(&generic_NCR5380_pnp_driver);\n#endif\n\tif (isa_registered)\n\t\tisa_unregister_driver(&generic_NCR5380_isa_driver);\n}\n\nmodule_init(generic_NCR5380_init);\nmodule_exit(generic_NCR5380_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}