{
  "module_name": "scsi_scan.c",
  "hash_id": "4de46ec3a83f77649eef7731bd0bbcbfc5ae4a172efb9a12e8513332e940da84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_scan.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/async.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_driver.h>\n#include <scsi/scsi_devinfo.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_dh.h>\n#include <scsi/scsi_eh.h>\n\n#include \"scsi_priv.h\"\n#include \"scsi_logging.h\"\n\n#define ALLOC_FAILURE_MSG\tKERN_ERR \"%s: Allocation failure during\" \\\n\t\" SCSI scanning, some SCSI devices might not be configured\\n\"\n\n \n#define SCSI_TIMEOUT (2*HZ)\n#define SCSI_REPORT_LUNS_TIMEOUT (30*HZ)\n\n \n#define SCSI_UID_SER_NUM 'S'\n#define SCSI_UID_UNKNOWN 'Z'\n\n \n#define SCSI_SCAN_NO_RESPONSE\t\t0\n#define SCSI_SCAN_TARGET_PRESENT\t1\n#define SCSI_SCAN_LUN_PRESENT\t\t2\n\nstatic const char *scsi_null_device_strs = \"nullnullnullnull\";\n\n#define MAX_SCSI_LUNS\t512\n\nstatic u64 max_scsi_luns = MAX_SCSI_LUNS;\n\nmodule_param_named(max_luns, max_scsi_luns, ullong, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(max_luns,\n\t\t \"last scsi LUN (should be between 1 and 2^64-1)\");\n\n#ifdef CONFIG_SCSI_SCAN_ASYNC\n#define SCSI_SCAN_TYPE_DEFAULT \"async\"\n#else\n#define SCSI_SCAN_TYPE_DEFAULT \"sync\"\n#endif\n\nstatic char scsi_scan_type[7] = SCSI_SCAN_TYPE_DEFAULT;\n\nmodule_param_string(scan, scsi_scan_type, sizeof(scsi_scan_type),\n\t\t    S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(scan, \"sync, async, manual, or none. \"\n\t\t \"Setting to 'manual' disables automatic scanning, but allows \"\n\t\t \"for manual device scan via the 'scan' sysfs attribute.\");\n\nstatic unsigned int scsi_inq_timeout = SCSI_TIMEOUT/HZ + 18;\n\nmodule_param_named(inq_timeout, scsi_inq_timeout, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(inq_timeout, \n\t\t \"Timeout (in seconds) waiting for devices to answer INQUIRY.\"\n\t\t \" Default is 20. Some devices may need more; most need less.\");\n\n \nstatic DEFINE_SPINLOCK(async_scan_lock);\nstatic LIST_HEAD(scanning_hosts);\n\nstruct async_scan_data {\n\tstruct list_head list;\n\tstruct Scsi_Host *shost;\n\tstruct completion prev_finished;\n};\n\n \nvoid scsi_enable_async_suspend(struct device *dev)\n{\n\t \n\tif (strncmp(scsi_scan_type, \"async\", 5) != 0)\n\t\treturn;\n\t \n\tdevice_enable_async_suspend(dev);\n}\n\n \nint scsi_complete_async_scans(void)\n{\n\tstruct async_scan_data *data;\n\n\tdo {\n\t\tif (list_empty(&scanning_hosts))\n\t\t\treturn 0;\n\t\t \n\t\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (!data)\n\t\t\tmsleep(1);\n\t} while (!data);\n\n\tdata->shost = NULL;\n\tinit_completion(&data->prev_finished);\n\n\tspin_lock(&async_scan_lock);\n\t \n\tif (list_empty(&scanning_hosts))\n\t\tgoto done;\n\tlist_add_tail(&data->list, &scanning_hosts);\n\tspin_unlock(&async_scan_lock);\n\n\tprintk(KERN_INFO \"scsi: waiting for bus probes to complete ...\\n\");\n\twait_for_completion(&data->prev_finished);\n\n\tspin_lock(&async_scan_lock);\n\tlist_del(&data->list);\n\tif (!list_empty(&scanning_hosts)) {\n\t\tstruct async_scan_data *next = list_entry(scanning_hosts.next,\n\t\t\t\tstruct async_scan_data, list);\n\t\tcomplete(&next->prev_finished);\n\t}\n done:\n\tspin_unlock(&async_scan_lock);\n\n\tkfree(data);\n\treturn 0;\n}\n\n \nstatic void scsi_unlock_floptical(struct scsi_device *sdev,\n\t\t\t\t  unsigned char *result)\n{\n\tunsigned char scsi_cmd[MAX_COMMAND_SIZE];\n\n\tsdev_printk(KERN_NOTICE, sdev, \"unlocking floptical drive\\n\");\n\tscsi_cmd[0] = MODE_SENSE;\n\tscsi_cmd[1] = 0;\n\tscsi_cmd[2] = 0x2e;\n\tscsi_cmd[3] = 0;\n\tscsi_cmd[4] = 0x2a;      \n\tscsi_cmd[5] = 0;\n\tscsi_execute_cmd(sdev, scsi_cmd, REQ_OP_DRV_IN, result, 0x2a,\n\t\t\t SCSI_TIMEOUT, 3, NULL);\n}\n\nstatic int scsi_realloc_sdev_budget_map(struct scsi_device *sdev,\n\t\t\t\t\tunsigned int depth)\n{\n\tint new_shift = sbitmap_calculate_shift(depth);\n\tbool need_alloc = !sdev->budget_map.map;\n\tbool need_free = false;\n\tint ret;\n\tstruct sbitmap sb_backup;\n\n\tdepth = min_t(unsigned int, depth, scsi_device_max_queue_depth(sdev));\n\n\t \n\tif (!need_alloc && new_shift != sdev->budget_map.shift)\n\t\tneed_alloc = need_free = true;\n\n\tif (!need_alloc)\n\t\treturn 0;\n\n\t \n\tif (need_free) {\n\t\tblk_mq_freeze_queue(sdev->request_queue);\n\t\tsb_backup = sdev->budget_map;\n\t}\n\tret = sbitmap_init_node(&sdev->budget_map,\n\t\t\t\tscsi_device_max_queue_depth(sdev),\n\t\t\t\tnew_shift, GFP_KERNEL,\n\t\t\t\tsdev->request_queue->node, false, true);\n\tif (!ret)\n\t\tsbitmap_resize(&sdev->budget_map, depth);\n\n\tif (need_free) {\n\t\tif (ret)\n\t\t\tsdev->budget_map = sb_backup;\n\t\telse\n\t\t\tsbitmap_free(&sb_backup);\n\t\tret = 0;\n\t\tblk_mq_unfreeze_queue(sdev->request_queue);\n\t}\n\treturn ret;\n}\n\n \nstatic struct scsi_device *scsi_alloc_sdev(struct scsi_target *starget,\n\t\t\t\t\t   u64 lun, void *hostdata)\n{\n\tunsigned int depth;\n\tstruct scsi_device *sdev;\n\tstruct request_queue *q;\n\tint display_failure_msg = 1, ret;\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\n\tsdev = kzalloc(sizeof(*sdev) + shost->transportt->device_size,\n\t\t       GFP_KERNEL);\n\tif (!sdev)\n\t\tgoto out;\n\n\tsdev->vendor = scsi_null_device_strs;\n\tsdev->model = scsi_null_device_strs;\n\tsdev->rev = scsi_null_device_strs;\n\tsdev->host = shost;\n\tsdev->queue_ramp_up_period = SCSI_DEFAULT_RAMP_UP_PERIOD;\n\tsdev->id = starget->id;\n\tsdev->lun = lun;\n\tsdev->channel = starget->channel;\n\tmutex_init(&sdev->state_mutex);\n\tsdev->sdev_state = SDEV_CREATED;\n\tINIT_LIST_HEAD(&sdev->siblings);\n\tINIT_LIST_HEAD(&sdev->same_target_siblings);\n\tINIT_LIST_HEAD(&sdev->starved_entry);\n\tINIT_LIST_HEAD(&sdev->event_list);\n\tspin_lock_init(&sdev->list_lock);\n\tmutex_init(&sdev->inquiry_mutex);\n\tINIT_WORK(&sdev->event_work, scsi_evt_thread);\n\tINIT_WORK(&sdev->requeue_work, scsi_requeue_run_queue);\n\n\tsdev->sdev_gendev.parent = get_device(&starget->dev);\n\tsdev->sdev_target = starget;\n\n\t \n\tsdev->hostdata = hostdata;\n\n\t \n\tsdev->max_device_blocked = SCSI_DEFAULT_DEVICE_BLOCKED;\n\n\t \n\tsdev->type = -1;\n\n\t \n\tsdev->borken = 1;\n\n\tsdev->sg_reserved_size = INT_MAX;\n\n\tq = blk_mq_init_queue(&sdev->host->tag_set);\n\tif (IS_ERR(q)) {\n\t\t \n\t\tput_device(&starget->dev);\n\t\tkfree(sdev);\n\t\tgoto out;\n\t}\n\tkref_get(&sdev->host->tagset_refcnt);\n\tsdev->request_queue = q;\n\tq->queuedata = sdev;\n\t__scsi_init_queue(sdev->host, q);\n\n\tdepth = sdev->host->cmd_per_lun ?: 1;\n\n\t \n\tif (scsi_realloc_sdev_budget_map(sdev, depth)) {\n\t\tput_device(&starget->dev);\n\t\tkfree(sdev);\n\t\tgoto out;\n\t}\n\n\tscsi_change_queue_depth(sdev, depth);\n\n\tscsi_sysfs_device_initialize(sdev);\n\n\tif (shost->hostt->slave_alloc) {\n\t\tret = shost->hostt->slave_alloc(sdev);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (ret == -ENXIO)\n\t\t\t\tdisplay_failure_msg = 0;\n\t\t\tgoto out_device_destroy;\n\t\t}\n\t}\n\n\treturn sdev;\n\nout_device_destroy:\n\t__scsi_remove_device(sdev);\nout:\n\tif (display_failure_msg)\n\t\tprintk(ALLOC_FAILURE_MSG, __func__);\n\treturn NULL;\n}\n\nstatic void scsi_target_destroy(struct scsi_target *starget)\n{\n\tstruct device *dev = &starget->dev;\n\tstruct Scsi_Host *shost = dev_to_shost(dev->parent);\n\tunsigned long flags;\n\n\tBUG_ON(starget->state == STARGET_DEL);\n\tstarget->state = STARGET_DEL;\n\ttransport_destroy_device(dev);\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (shost->hostt->target_destroy)\n\t\tshost->hostt->target_destroy(starget);\n\tlist_del_init(&starget->siblings);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tput_device(dev);\n}\n\nstatic void scsi_target_dev_release(struct device *dev)\n{\n\tstruct device *parent = dev->parent;\n\tstruct scsi_target *starget = to_scsi_target(dev);\n\n\tkfree(starget);\n\tput_device(parent);\n}\n\nstatic struct device_type scsi_target_type = {\n\t.name =\t\t\"scsi_target\",\n\t.release =\tscsi_target_dev_release,\n};\n\nint scsi_is_target_device(const struct device *dev)\n{\n\treturn dev->type == &scsi_target_type;\n}\nEXPORT_SYMBOL(scsi_is_target_device);\n\nstatic struct scsi_target *__scsi_find_target(struct device *parent,\n\t\t\t\t\t      int channel, uint id)\n{\n\tstruct scsi_target *starget, *found_starget = NULL;\n\tstruct Scsi_Host *shost = dev_to_shost(parent);\n\t \n\tlist_for_each_entry(starget, &shost->__targets, siblings) {\n\t\tif (starget->id == id &&\n\t\t    starget->channel == channel) {\n\t\t\tfound_starget = starget;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found_starget)\n\t\tget_device(&found_starget->dev);\n\n\treturn found_starget;\n}\n\n \nstatic void scsi_target_reap_ref_release(struct kref *kref)\n{\n\tstruct scsi_target *starget\n\t\t= container_of(kref, struct scsi_target, reap_ref);\n\n\t \n\tif ((starget->state != STARGET_CREATED) &&\n\t    (starget->state != STARGET_CREATED_REMOVE)) {\n\t\ttransport_remove_device(&starget->dev);\n\t\tdevice_del(&starget->dev);\n\t}\n\tscsi_target_destroy(starget);\n}\n\nstatic void scsi_target_reap_ref_put(struct scsi_target *starget)\n{\n\tkref_put(&starget->reap_ref, scsi_target_reap_ref_release);\n}\n\n \nstatic struct scsi_target *scsi_alloc_target(struct device *parent,\n\t\t\t\t\t     int channel, uint id)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(parent);\n\tstruct device *dev = NULL;\n\tunsigned long flags;\n\tconst int size = sizeof(struct scsi_target)\n\t\t+ shost->transportt->target_size;\n\tstruct scsi_target *starget;\n\tstruct scsi_target *found_target;\n\tint error, ref_got;\n\n\tstarget = kzalloc(size, GFP_KERNEL);\n\tif (!starget) {\n\t\tprintk(KERN_ERR \"%s: allocation failure\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tdev = &starget->dev;\n\tdevice_initialize(dev);\n\tkref_init(&starget->reap_ref);\n\tdev->parent = get_device(parent);\n\tdev_set_name(dev, \"target%d:%d:%d\", shost->host_no, channel, id);\n\tdev->bus = &scsi_bus_type;\n\tdev->type = &scsi_target_type;\n\tscsi_enable_async_suspend(dev);\n\tstarget->id = id;\n\tstarget->channel = channel;\n\tstarget->can_queue = 0;\n\tINIT_LIST_HEAD(&starget->siblings);\n\tINIT_LIST_HEAD(&starget->devices);\n\tstarget->state = STARGET_CREATED;\n\tstarget->scsi_level = SCSI_2;\n\tstarget->max_target_blocked = SCSI_DEFAULT_TARGET_BLOCKED;\n retry:\n\tspin_lock_irqsave(shost->host_lock, flags);\n\n\tfound_target = __scsi_find_target(parent, channel, id);\n\tif (found_target)\n\t\tgoto found;\n\n\tlist_add_tail(&starget->siblings, &shost->__targets);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t \n\ttransport_setup_device(dev);\n\tif (shost->hostt->target_alloc) {\n\t\terror = shost->hostt->target_alloc(starget);\n\n\t\tif(error) {\n\t\t\tif (error != -ENXIO)\n\t\t\t\tdev_err(dev, \"target allocation failed, error %d\\n\", error);\n\t\t\t \n\t\t\tscsi_target_destroy(starget);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tget_device(dev);\n\n\treturn starget;\n\n found:\n\t \n\tref_got = kref_get_unless_zero(&found_target->reap_ref);\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tif (ref_got) {\n\t\tput_device(dev);\n\t\treturn found_target;\n\t}\n\t \n\tput_device(&found_target->dev);\n\t \n\tmsleep(1);\n\tgoto retry;\n}\n\n \nvoid scsi_target_reap(struct scsi_target *starget)\n{\n\t \n\tBUG_ON(starget->state == STARGET_DEL);\n\tscsi_target_reap_ref_put(starget);\n}\n\n \nvoid scsi_sanitize_inquiry_string(unsigned char *s, int len)\n{\n\tint terminated = 0;\n\n\tfor (; len > 0; (--len, ++s)) {\n\t\tif (*s == 0)\n\t\t\tterminated = 1;\n\t\tif (terminated || *s < 0x20 || *s > 0x7e)\n\t\t\t*s = ' ';\n\t}\n}\nEXPORT_SYMBOL(scsi_sanitize_inquiry_string);\n\n \nstatic int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,\n\t\t\t  int result_len, blist_flags_t *bflags)\n{\n\tunsigned char scsi_cmd[MAX_COMMAND_SIZE];\n\tint first_inquiry_len, try_inquiry_len, next_inquiry_len;\n\tint response_len = 0;\n\tint pass, count, result, resid;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t\t.resid = &resid,\n\t};\n\n\t*bflags = 0;\n\n\t \n\tfirst_inquiry_len = sdev->inquiry_len ? sdev->inquiry_len : 36;\n\ttry_inquiry_len = first_inquiry_len;\n\tpass = 1;\n\n next_pass:\n\tSCSI_LOG_SCAN_BUS(3, sdev_printk(KERN_INFO, sdev,\n\t\t\t\t\"scsi scan: INQUIRY pass %d length %d\\n\",\n\t\t\t\tpass, try_inquiry_len));\n\n\t \n\tfor (count = 0; count < 3; ++count) {\n\t\tmemset(scsi_cmd, 0, 6);\n\t\tscsi_cmd[0] = INQUIRY;\n\t\tscsi_cmd[4] = (unsigned char) try_inquiry_len;\n\n\t\tmemset(inq_result, 0, try_inquiry_len);\n\n\t\tresult = scsi_execute_cmd(sdev,  scsi_cmd, REQ_OP_DRV_IN,\n\t\t\t\t\t  inq_result, try_inquiry_len,\n\t\t\t\t\t  HZ / 2 + HZ * scsi_inq_timeout, 3,\n\t\t\t\t\t  &exec_args);\n\n\t\tSCSI_LOG_SCAN_BUS(3, sdev_printk(KERN_INFO, sdev,\n\t\t\t\t\"scsi scan: INQUIRY %s with code 0x%x\\n\",\n\t\t\t\tresult ? \"failed\" : \"successful\", result));\n\n\t\tif (result > 0) {\n\t\t\t \n\t\t\tif (scsi_status_is_check_condition(result) &&\n\t\t\t    scsi_sense_valid(&sshdr)) {\n\t\t\t\tif ((sshdr.sense_key == UNIT_ATTENTION) &&\n\t\t\t\t    ((sshdr.asc == 0x28) ||\n\t\t\t\t     (sshdr.asc == 0x29)) &&\n\t\t\t\t    (sshdr.ascq == 0))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (result == 0) {\n\t\t\t \n\t\t\tif (resid == try_inquiry_len)\n\t\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (result == 0) {\n\t\tscsi_sanitize_inquiry_string(&inq_result[8], 8);\n\t\tscsi_sanitize_inquiry_string(&inq_result[16], 16);\n\t\tscsi_sanitize_inquiry_string(&inq_result[32], 4);\n\n\t\tresponse_len = inq_result[4] + 5;\n\t\tif (response_len > 255)\n\t\t\tresponse_len = first_inquiry_len;\t \n\n\t\t \n\t\t*bflags = scsi_get_device_flags(sdev, &inq_result[8],\n\t\t\t\t&inq_result[16]);\n\n\t\t \n\t\tif (pass == 1) {\n\t\t\tif (BLIST_INQUIRY_36 & *bflags)\n\t\t\t\tnext_inquiry_len = 36;\n\t\t\t \n\t\t\telse if (sdev->inquiry_len &&\n\t\t\t\t response_len > sdev->inquiry_len &&\n\t\t\t\t (inq_result[2] & 0x7) < 6)  \n\t\t\t\tnext_inquiry_len = sdev->inquiry_len;\n\t\t\telse\n\t\t\t\tnext_inquiry_len = response_len;\n\n\t\t\t \n\t\t\tif (next_inquiry_len > try_inquiry_len) {\n\t\t\t\ttry_inquiry_len = next_inquiry_len;\n\t\t\t\tpass = 2;\n\t\t\t\tgoto next_pass;\n\t\t\t}\n\t\t}\n\n\t} else if (pass == 2) {\n\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t    \"scsi scan: %d byte inquiry failed.  \"\n\t\t\t    \"Consider BLIST_INQUIRY_36 for this device\\n\",\n\t\t\t    try_inquiry_len);\n\n\t\t \n\t\ttry_inquiry_len = first_inquiry_len;\n\t\tpass = 3;\n\t\tgoto next_pass;\n\t}\n\n\t \n\tif (result)\n\t\treturn -EIO;\n\n\t \n\tsdev->inquiry_len = min(try_inquiry_len, response_len);\n\n\t \n\tif (sdev->inquiry_len < 36) {\n\t\tif (!sdev->host->short_inquiry) {\n\t\t\tshost_printk(KERN_INFO, sdev->host,\n\t\t\t\t    \"scsi scan: INQUIRY result too short (%d),\"\n\t\t\t\t    \" using 36\\n\", sdev->inquiry_len);\n\t\t\tsdev->host->short_inquiry = 1;\n\t\t}\n\t\tsdev->inquiry_len = 36;\n\t}\n\n\t \n\n\t \n\tsdev->scsi_level = inq_result[2] & 0x0f;\n\tif (sdev->scsi_level >= 2 ||\n\t    (sdev->scsi_level == 1 && (inq_result[3] & 0x0f) == 1))\n\t\tsdev->scsi_level++;\n\tsdev->sdev_target->scsi_level = sdev->scsi_level;\n\n\t \n\tsdev->lun_in_cdb = 0;\n\tif (sdev->scsi_level <= SCSI_2 &&\n\t    sdev->scsi_level != SCSI_UNKNOWN &&\n\t    !sdev->host->no_scsi2_lun_in_cdb)\n\t\tsdev->lun_in_cdb = 1;\n\n\treturn 0;\n}\n\n \nstatic int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,\n\t\tblist_flags_t *bflags, int async)\n{\n\tint ret;\n\n\t \n\n\t \n\tsdev->inquiry = kmemdup(inq_result,\n\t\t\t\tmax_t(size_t, sdev->inquiry_len, 36),\n\t\t\t\tGFP_KERNEL);\n\tif (sdev->inquiry == NULL)\n\t\treturn SCSI_SCAN_NO_RESPONSE;\n\n\tsdev->vendor = (char *) (sdev->inquiry + 8);\n\tsdev->model = (char *) (sdev->inquiry + 16);\n\tsdev->rev = (char *) (sdev->inquiry + 32);\n\n\tif (strncmp(sdev->vendor, \"ATA     \", 8) == 0) {\n\t\t \n\t\tsdev->allow_restart = 1;\n\t}\n\n\tif (*bflags & BLIST_ISROM) {\n\t\tsdev->type = TYPE_ROM;\n\t\tsdev->removable = 1;\n\t} else {\n\t\tsdev->type = (inq_result[0] & 0x1f);\n\t\tsdev->removable = (inq_result[1] & 0x80) >> 7;\n\n\t\t \n\t\tif (scsi_is_wlun(sdev->lun) && sdev->type != TYPE_WLUN) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t\"%s: correcting incorrect peripheral device type 0x%x for W-LUN 0x%16xhN\\n\",\n\t\t\t\t__func__, sdev->type, (unsigned int)sdev->lun);\n\t\t\tsdev->type = TYPE_WLUN;\n\t\t}\n\n\t}\n\n\tif (sdev->type == TYPE_RBC || sdev->type == TYPE_ROM) {\n\t\t \n\t\tif ((*bflags & BLIST_REPORTLUN2) == 0)\n\t\t\t*bflags |= BLIST_NOREPORTLUN;\n\t}\n\n\t  \n\n\tsdev->inq_periph_qual = (inq_result[0] >> 5) & 7;\n\tsdev->lockable = sdev->removable;\n\tsdev->soft_reset = (inq_result[7] & 1) && ((inq_result[3] & 7) == 2);\n\n\tif (sdev->scsi_level >= SCSI_3 ||\n\t\t\t(sdev->inquiry_len > 56 && inq_result[56] & 0x04))\n\t\tsdev->ppr = 1;\n\tif (inq_result[7] & 0x60)\n\t\tsdev->wdtr = 1;\n\tif (inq_result[7] & 0x10)\n\t\tsdev->sdtr = 1;\n\n\tsdev_printk(KERN_NOTICE, sdev, \"%s %.8s %.16s %.4s PQ: %d \"\n\t\t\t\"ANSI: %d%s\\n\", scsi_device_type(sdev->type),\n\t\t\tsdev->vendor, sdev->model, sdev->rev,\n\t\t\tsdev->inq_periph_qual, inq_result[2] & 0x07,\n\t\t\t(inq_result[3] & 0x0f) == 1 ? \" CCS\" : \"\");\n\n\tif ((sdev->scsi_level >= SCSI_2) && (inq_result[7] & 2) &&\n\t    !(*bflags & BLIST_NOTQ)) {\n\t\tsdev->tagged_supported = 1;\n\t\tsdev->simple_tags = 1;\n\t}\n\n\t \n\tif ((*bflags & BLIST_BORKEN) == 0)\n\t\tsdev->borken = 0;\n\n\tif (*bflags & BLIST_NO_ULD_ATTACH)\n\t\tsdev->no_uld_attach = 1;\n\n\t \n\tif (*bflags & BLIST_SELECT_NO_ATN)\n\t\tsdev->select_no_atn = 1;\n\n\t \n\tif (*bflags & BLIST_MAX_512)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 512);\n\t \n\telse if (*bflags & BLIST_MAX_1024)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 1024);\n\n\t \n\tif (*bflags & BLIST_NOSTARTONADD)\n\t\tsdev->no_start_on_add = 1;\n\n\tif (*bflags & BLIST_SINGLELUN)\n\t\tscsi_target(sdev)->single_lun = 1;\n\n\tsdev->use_10_for_rw = 1;\n\n\t \n\tif (*bflags & BLIST_NO_RSOC)\n\t\tsdev->no_report_opcodes = 1;\n\n\t \n\tmutex_lock(&sdev->state_mutex);\n\tret = scsi_device_set_state(sdev, SDEV_RUNNING);\n\tif (ret)\n\t\tret = scsi_device_set_state(sdev, SDEV_BLOCK);\n\tmutex_unlock(&sdev->state_mutex);\n\n\tif (ret) {\n\t\tsdev_printk(KERN_ERR, sdev,\n\t\t\t    \"in wrong state %s to complete scan\\n\",\n\t\t\t    scsi_device_state_name(sdev->sdev_state));\n\t\treturn SCSI_SCAN_NO_RESPONSE;\n\t}\n\n\tif (*bflags & BLIST_NOT_LOCKABLE)\n\t\tsdev->lockable = 0;\n\n\tif (*bflags & BLIST_RETRY_HWERROR)\n\t\tsdev->retry_hwerror = 1;\n\n\tif (*bflags & BLIST_NO_DIF)\n\t\tsdev->no_dif = 1;\n\n\tif (*bflags & BLIST_UNMAP_LIMIT_WS)\n\t\tsdev->unmap_limit_for_ws = 1;\n\n\tif (*bflags & BLIST_IGN_MEDIA_CHANGE)\n\t\tsdev->ignore_media_change = 1;\n\n\tsdev->eh_timeout = SCSI_DEFAULT_EH_TIMEOUT;\n\n\tif (*bflags & BLIST_TRY_VPD_PAGES)\n\t\tsdev->try_vpd_pages = 1;\n\telse if (*bflags & BLIST_SKIP_VPD_PAGES)\n\t\tsdev->skip_vpd_pages = 1;\n\n\tif (*bflags & BLIST_NO_VPD_SIZE)\n\t\tsdev->no_vpd_size = 1;\n\n\ttransport_configure_device(&sdev->sdev_gendev);\n\n\tif (sdev->host->hostt->slave_configure) {\n\t\tret = sdev->host->hostt->slave_configure(sdev);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (ret != -ENXIO) {\n\t\t\t\tsdev_printk(KERN_ERR, sdev,\n\t\t\t\t\t\"failed to configure device\\n\");\n\t\t\t}\n\t\t\treturn SCSI_SCAN_NO_RESPONSE;\n\t\t}\n\n\t\t \n\t\tscsi_realloc_sdev_budget_map(sdev, sdev->queue_depth);\n\t}\n\n\tif (sdev->scsi_level >= SCSI_3)\n\t\tscsi_attach_vpd(sdev);\n\n\tscsi_cdl_check(sdev);\n\n\tsdev->max_queue_depth = sdev->queue_depth;\n\tWARN_ON_ONCE(sdev->max_queue_depth > sdev->budget_map.depth);\n\tsdev->sdev_bflags = *bflags;\n\n\t \n\tif (!async && scsi_sysfs_add_sdev(sdev) != 0)\n\t\treturn SCSI_SCAN_NO_RESPONSE;\n\n\treturn SCSI_SCAN_LUN_PRESENT;\n}\n\n#ifdef CONFIG_SCSI_LOGGING\n \nstatic unsigned char *scsi_inq_str(unsigned char *buf, unsigned char *inq,\n\t\t\t\t   unsigned first, unsigned end)\n{\n\tunsigned term = 0, idx;\n\n\tfor (idx = 0; idx + first < end && idx + first < inq[4] + 5; idx++) {\n\t\tif (inq[idx+first] > ' ') {\n\t\t\tbuf[idx] = inq[idx+first];\n\t\t\tterm = idx+1;\n\t\t} else {\n\t\t\tbuf[idx] = ' ';\n\t\t}\n\t}\n\tbuf[term] = 0;\n\treturn buf;\n}\n#endif\n\n \nstatic int scsi_probe_and_add_lun(struct scsi_target *starget,\n\t\t\t\t  u64 lun, blist_flags_t *bflagsp,\n\t\t\t\t  struct scsi_device **sdevp,\n\t\t\t\t  enum scsi_scan_mode rescan,\n\t\t\t\t  void *hostdata)\n{\n\tstruct scsi_device *sdev;\n\tunsigned char *result;\n\tblist_flags_t bflags;\n\tint res = SCSI_SCAN_NO_RESPONSE, result_len = 256;\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\n\t \n\tsdev = scsi_device_lookup_by_target(starget, lun);\n\tif (sdev) {\n\t\tif (rescan != SCSI_SCAN_INITIAL || !scsi_device_created(sdev)) {\n\t\t\tSCSI_LOG_SCAN_BUS(3, sdev_printk(KERN_INFO, sdev,\n\t\t\t\t\"scsi scan: device exists on %s\\n\",\n\t\t\t\tdev_name(&sdev->sdev_gendev)));\n\t\t\tif (sdevp)\n\t\t\t\t*sdevp = sdev;\n\t\t\telse\n\t\t\t\tscsi_device_put(sdev);\n\n\t\t\tif (bflagsp)\n\t\t\t\t*bflagsp = scsi_get_device_flags(sdev,\n\t\t\t\t\t\t\t\t sdev->vendor,\n\t\t\t\t\t\t\t\t sdev->model);\n\t\t\treturn SCSI_SCAN_LUN_PRESENT;\n\t\t}\n\t\tscsi_device_put(sdev);\n\t} else\n\t\tsdev = scsi_alloc_sdev(starget, lun, hostdata);\n\tif (!sdev)\n\t\tgoto out;\n\n\tresult = kmalloc(result_len, GFP_KERNEL);\n\tif (!result)\n\t\tgoto out_free_sdev;\n\n\tif (scsi_probe_lun(sdev, result, result_len, &bflags))\n\t\tgoto out_free_result;\n\n\tif (bflagsp)\n\t\t*bflagsp = bflags;\n\t \n\tif ((result[0] >> 5) == 3) {\n\t\t \n\t\tSCSI_LOG_SCAN_BUS(2, sdev_printk(KERN_INFO, sdev, \"scsi scan:\"\n\t\t\t\t   \" peripheral qualifier of 3, device not\"\n\t\t\t\t   \" added\\n\"))\n\t\tif (lun == 0) {\n\t\t\tSCSI_LOG_SCAN_BUS(1, {\n\t\t\t\tunsigned char vend[9];\n\t\t\t\tunsigned char mod[17];\n\n\t\t\t\tsdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t\"scsi scan: consider passing scsi_mod.\"\n\t\t\t\t\t\"dev_flags=%s:%s:0x240 or 0x1000240\\n\",\n\t\t\t\t\tscsi_inq_str(vend, result, 8, 16),\n\t\t\t\t\tscsi_inq_str(mod, result, 16, 32));\n\t\t\t});\n\n\t\t}\n\n\t\tres = SCSI_SCAN_TARGET_PRESENT;\n\t\tgoto out_free_result;\n\t}\n\n\t \n\tif (((result[0] >> 5) == 1 || starget->pdt_1f_for_no_lun) &&\n\t    (result[0] & 0x1f) == 0x1f &&\n\t    !scsi_is_wlun(lun)) {\n\t\tSCSI_LOG_SCAN_BUS(3, sdev_printk(KERN_INFO, sdev,\n\t\t\t\t\t\"scsi scan: peripheral device type\"\n\t\t\t\t\t\" of 31, no device added\\n\"));\n\t\tres = SCSI_SCAN_TARGET_PRESENT;\n\t\tgoto out_free_result;\n\t}\n\n\tres = scsi_add_lun(sdev, result, &bflags, shost->async_scan);\n\tif (res == SCSI_SCAN_LUN_PRESENT) {\n\t\tif (bflags & BLIST_KEY) {\n\t\t\tsdev->lockable = 0;\n\t\t\tscsi_unlock_floptical(sdev, result);\n\t\t}\n\t}\n\n out_free_result:\n\tkfree(result);\n out_free_sdev:\n\tif (res == SCSI_SCAN_LUN_PRESENT) {\n\t\tif (sdevp) {\n\t\t\tif (scsi_device_get(sdev) == 0) {\n\t\t\t\t*sdevp = sdev;\n\t\t\t} else {\n\t\t\t\t__scsi_remove_device(sdev);\n\t\t\t\tres = SCSI_SCAN_NO_RESPONSE;\n\t\t\t}\n\t\t}\n\t} else\n\t\t__scsi_remove_device(sdev);\n out:\n\treturn res;\n}\n\n \nstatic void scsi_sequential_lun_scan(struct scsi_target *starget,\n\t\t\t\t     blist_flags_t bflags, int scsi_level,\n\t\t\t\t     enum scsi_scan_mode rescan)\n{\n\tuint max_dev_lun;\n\tu64 sparse_lun, lun;\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\n\tSCSI_LOG_SCAN_BUS(3, starget_printk(KERN_INFO, starget,\n\t\t\"scsi scan: Sequential scan\\n\"));\n\n\tmax_dev_lun = min(max_scsi_luns, shost->max_lun);\n\t \n\tif (bflags & BLIST_SPARSELUN) {\n\t\tmax_dev_lun = shost->max_lun;\n\t\tsparse_lun = 1;\n\t} else\n\t\tsparse_lun = 0;\n\n\t \n\t \n\tif (bflags & BLIST_FORCELUN)\n\t\tmax_dev_lun = shost->max_lun;\n\t \n\tif (bflags & BLIST_MAX5LUN)\n\t\tmax_dev_lun = min(5U, max_dev_lun);\n\t \n\tif (scsi_level < SCSI_3 && !(bflags & BLIST_LARGELUN))\n\t\tmax_dev_lun = min(8U, max_dev_lun);\n\telse\n\t\tmax_dev_lun = min(256U, max_dev_lun);\n\n\t \n\tfor (lun = 1; lun < max_dev_lun; ++lun)\n\t\tif ((scsi_probe_and_add_lun(starget, lun, NULL, NULL, rescan,\n\t\t\t\t\t    NULL) != SCSI_SCAN_LUN_PRESENT) &&\n\t\t    !sparse_lun)\n\t\t\treturn;\n}\n\n \nstatic int scsi_report_lun_scan(struct scsi_target *starget, blist_flags_t bflags,\n\t\t\t\tenum scsi_scan_mode rescan)\n{\n\tunsigned char scsi_cmd[MAX_COMMAND_SIZE];\n\tunsigned int length;\n\tu64 lun;\n\tunsigned int num_luns;\n\tunsigned int retries;\n\tint result;\n\tstruct scsi_lun *lunp, *lun_data;\n\tstruct scsi_sense_hdr sshdr;\n\tstruct scsi_device *sdev;\n\tstruct Scsi_Host *shost = dev_to_shost(&starget->dev);\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tint ret = 0;\n\n\t \n\tif (bflags & BLIST_NOREPORTLUN)\n\t\treturn 1;\n\tif (starget->scsi_level < SCSI_2 &&\n\t    starget->scsi_level != SCSI_UNKNOWN)\n\t\treturn 1;\n\tif (starget->scsi_level < SCSI_3 &&\n\t    (!(bflags & BLIST_REPORTLUN2) || shost->max_lun <= 8))\n\t\treturn 1;\n\tif (bflags & BLIST_NOLUN)\n\t\treturn 0;\n\tif (starget->no_report_luns)\n\t\treturn 1;\n\n\tif (!(sdev = scsi_device_lookup_by_target(starget, 0))) {\n\t\tsdev = scsi_alloc_sdev(starget, 0, NULL);\n\t\tif (!sdev)\n\t\t\treturn 0;\n\t\tif (scsi_device_get(sdev)) {\n\t\t\t__scsi_remove_device(sdev);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tlength = (511 + 1) * sizeof(struct scsi_lun);\nretry:\n\tlun_data = kmalloc(length, GFP_KERNEL);\n\tif (!lun_data) {\n\t\tprintk(ALLOC_FAILURE_MSG, __func__);\n\t\tgoto out;\n\t}\n\n\tscsi_cmd[0] = REPORT_LUNS;\n\n\t \n\tmemset(&scsi_cmd[1], 0, 5);\n\n\t \n\tput_unaligned_be32(length, &scsi_cmd[6]);\n\n\tscsi_cmd[10] = 0;\t \n\tscsi_cmd[11] = 0;\t \n\n\t \n\tfor (retries = 0; retries < 3; retries++) {\n\t\tSCSI_LOG_SCAN_BUS(3, sdev_printk (KERN_INFO, sdev,\n\t\t\t\t\"scsi scan: Sending REPORT LUNS to (try %d)\\n\",\n\t\t\t\tretries));\n\n\t\tresult = scsi_execute_cmd(sdev, scsi_cmd, REQ_OP_DRV_IN,\n\t\t\t\t\t  lun_data, length,\n\t\t\t\t\t  SCSI_REPORT_LUNS_TIMEOUT, 3,\n\t\t\t\t\t  &exec_args);\n\n\t\tSCSI_LOG_SCAN_BUS(3, sdev_printk (KERN_INFO, sdev,\n\t\t\t\t\"scsi scan: REPORT LUNS\"\n\t\t\t\t\" %s (try %d) result 0x%x\\n\",\n\t\t\t\tresult ?  \"failed\" : \"successful\",\n\t\t\t\tretries, result));\n\t\tif (result == 0)\n\t\t\tbreak;\n\t\telse if (scsi_sense_valid(&sshdr)) {\n\t\t\tif (sshdr.sense_key != UNIT_ATTENTION)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (result) {\n\t\t \n\t\tret = 1;\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (get_unaligned_be32(lun_data->scsi_lun) +\n\t    sizeof(struct scsi_lun) > length) {\n\t\tlength = get_unaligned_be32(lun_data->scsi_lun) +\n\t\t\t sizeof(struct scsi_lun);\n\t\tkfree(lun_data);\n\t\tgoto retry;\n\t}\n\tlength = get_unaligned_be32(lun_data->scsi_lun);\n\n\tnum_luns = (length / sizeof(struct scsi_lun));\n\n\tSCSI_LOG_SCAN_BUS(3, sdev_printk (KERN_INFO, sdev,\n\t\t\"scsi scan: REPORT LUN scan\\n\"));\n\n\t \n\tfor (lunp = &lun_data[1]; lunp <= &lun_data[num_luns]; lunp++) {\n\t\tlun = scsilun_to_int(lunp);\n\n\t\tif (lun > sdev->host->max_lun) {\n\t\t\tsdev_printk(KERN_WARNING, sdev,\n\t\t\t\t    \"lun%llu has a LUN larger than\"\n\t\t\t\t    \" allowed by the host adapter\\n\", lun);\n\t\t} else {\n\t\t\tint res;\n\n\t\t\tres = scsi_probe_and_add_lun(starget,\n\t\t\t\tlun, NULL, NULL, rescan, NULL);\n\t\t\tif (res == SCSI_SCAN_NO_RESPONSE) {\n\t\t\t\t \n\t\t\t\tsdev_printk(KERN_ERR, sdev,\n\t\t\t\t\t\"Unexpected response\"\n\t\t\t\t\t\" from lun %llu while scanning, scan\"\n\t\t\t\t\t\" aborted\\n\", (unsigned long long)lun);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n out_err:\n\tkfree(lun_data);\n out:\n\tif (scsi_device_created(sdev))\n\t\t \n\t\t__scsi_remove_device(sdev);\n\tscsi_device_put(sdev);\n\treturn ret;\n}\n\nstruct scsi_device *__scsi_add_device(struct Scsi_Host *shost, uint channel,\n\t\t\t\t      uint id, u64 lun, void *hostdata)\n{\n\tstruct scsi_device *sdev = ERR_PTR(-ENODEV);\n\tstruct device *parent = &shost->shost_gendev;\n\tstruct scsi_target *starget;\n\n\tif (strncmp(scsi_scan_type, \"none\", 4) == 0)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tstarget = scsi_alloc_target(parent, channel, id);\n\tif (!starget)\n\t\treturn ERR_PTR(-ENOMEM);\n\tscsi_autopm_get_target(starget);\n\n\tmutex_lock(&shost->scan_mutex);\n\tif (!shost->async_scan)\n\t\tscsi_complete_async_scans();\n\n\tif (scsi_host_scan_allowed(shost) && scsi_autopm_get_host(shost) == 0) {\n\t\tscsi_probe_and_add_lun(starget, lun, NULL, &sdev,\n\t\t\t\t       SCSI_SCAN_RESCAN, hostdata);\n\t\tscsi_autopm_put_host(shost);\n\t}\n\tmutex_unlock(&shost->scan_mutex);\n\tscsi_autopm_put_target(starget);\n\t \n\tscsi_target_reap(starget);\n\tput_device(&starget->dev);\n\n\treturn sdev;\n}\nEXPORT_SYMBOL(__scsi_add_device);\n\nint scsi_add_device(struct Scsi_Host *host, uint channel,\n\t\t    uint target, u64 lun)\n{\n\tstruct scsi_device *sdev = \n\t\t__scsi_add_device(host, channel, target, lun, NULL);\n\tif (IS_ERR(sdev))\n\t\treturn PTR_ERR(sdev);\n\n\tscsi_device_put(sdev);\n\treturn 0;\n}\nEXPORT_SYMBOL(scsi_add_device);\n\nint scsi_rescan_device(struct scsi_device *sdev)\n{\n\tstruct device *dev = &sdev->sdev_gendev;\n\tint ret = 0;\n\n\tdevice_lock(dev);\n\n\t \n\tif (sdev->sdev_state != SDEV_RUNNING ||\n\t    blk_queue_pm_only(sdev->request_queue)) {\n\t\tret = -EWOULDBLOCK;\n\t\tgoto unlock;\n\t}\n\n\tscsi_attach_vpd(sdev);\n\tscsi_cdl_check(sdev);\n\n\tif (sdev->handler && sdev->handler->rescan)\n\t\tsdev->handler->rescan(sdev);\n\n\tif (dev->driver && try_module_get(dev->driver->owner)) {\n\t\tstruct scsi_driver *drv = to_scsi_driver(dev->driver);\n\n\t\tif (drv->rescan)\n\t\t\tdrv->rescan(dev);\n\t\tmodule_put(dev->driver->owner);\n\t}\n\nunlock:\n\tdevice_unlock(dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(scsi_rescan_device);\n\nstatic void __scsi_scan_target(struct device *parent, unsigned int channel,\n\t\tunsigned int id, u64 lun, enum scsi_scan_mode rescan)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(parent);\n\tblist_flags_t bflags = 0;\n\tint res;\n\tstruct scsi_target *starget;\n\n\tif (shost->this_id == id)\n\t\t \n\t\treturn;\n\n\tstarget = scsi_alloc_target(parent, channel, id);\n\tif (!starget)\n\t\treturn;\n\tscsi_autopm_get_target(starget);\n\n\tif (lun != SCAN_WILD_CARD) {\n\t\t \n\t\tscsi_probe_and_add_lun(starget, lun, NULL, NULL, rescan, NULL);\n\t\tgoto out_reap;\n\t}\n\n\t \n\tres = scsi_probe_and_add_lun(starget, 0, &bflags, NULL, rescan, NULL);\n\tif (res == SCSI_SCAN_LUN_PRESENT || res == SCSI_SCAN_TARGET_PRESENT) {\n\t\tif (scsi_report_lun_scan(starget, bflags, rescan) != 0)\n\t\t\t \n\t\t\tscsi_sequential_lun_scan(starget, bflags,\n\t\t\t\t\t\t starget->scsi_level, rescan);\n\t}\n\n out_reap:\n\tscsi_autopm_put_target(starget);\n\t \n\tscsi_target_reap(starget);\n\n\tput_device(&starget->dev);\n}\n\n \nvoid scsi_scan_target(struct device *parent, unsigned int channel,\n\t\t      unsigned int id, u64 lun, enum scsi_scan_mode rescan)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(parent);\n\n\tif (strncmp(scsi_scan_type, \"none\", 4) == 0)\n\t\treturn;\n\n\tif (rescan != SCSI_SCAN_MANUAL &&\n\t    strncmp(scsi_scan_type, \"manual\", 6) == 0)\n\t\treturn;\n\n\tmutex_lock(&shost->scan_mutex);\n\tif (!shost->async_scan)\n\t\tscsi_complete_async_scans();\n\n\tif (scsi_host_scan_allowed(shost) && scsi_autopm_get_host(shost) == 0) {\n\t\t__scsi_scan_target(parent, channel, id, lun, rescan);\n\t\tscsi_autopm_put_host(shost);\n\t}\n\tmutex_unlock(&shost->scan_mutex);\n}\nEXPORT_SYMBOL(scsi_scan_target);\n\nstatic void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,\n\t\t\t      unsigned int id, u64 lun,\n\t\t\t      enum scsi_scan_mode rescan)\n{\n\tuint order_id;\n\n\tif (id == SCAN_WILD_CARD)\n\t\tfor (id = 0; id < shost->max_id; ++id) {\n\t\t\t \n\t\t\tif (shost->reverse_ordering)\n\t\t\t\t \n\t\t\t\torder_id = shost->max_id - id - 1;\n\t\t\telse\n\t\t\t\torder_id = id;\n\t\t\t__scsi_scan_target(&shost->shost_gendev, channel,\n\t\t\t\t\torder_id, lun, rescan);\n\t\t}\n\telse\n\t\t__scsi_scan_target(&shost->shost_gendev, channel,\n\t\t\t\tid, lun, rescan);\n}\n\nint scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,\n\t\t\t    unsigned int id, u64 lun,\n\t\t\t    enum scsi_scan_mode rescan)\n{\n\tSCSI_LOG_SCAN_BUS(3, shost_printk (KERN_INFO, shost,\n\t\t\"%s: <%u:%u:%llu>\\n\",\n\t\t__func__, channel, id, lun));\n\n\tif (((channel != SCAN_WILD_CARD) && (channel > shost->max_channel)) ||\n\t    ((id != SCAN_WILD_CARD) && (id >= shost->max_id)) ||\n\t    ((lun != SCAN_WILD_CARD) && (lun >= shost->max_lun)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&shost->scan_mutex);\n\tif (!shost->async_scan)\n\t\tscsi_complete_async_scans();\n\n\tif (scsi_host_scan_allowed(shost) && scsi_autopm_get_host(shost) == 0) {\n\t\tif (channel == SCAN_WILD_CARD)\n\t\t\tfor (channel = 0; channel <= shost->max_channel;\n\t\t\t     channel++)\n\t\t\t\tscsi_scan_channel(shost, channel, id, lun,\n\t\t\t\t\t\t  rescan);\n\t\telse\n\t\t\tscsi_scan_channel(shost, channel, id, lun, rescan);\n\t\tscsi_autopm_put_host(shost);\n\t}\n\tmutex_unlock(&shost->scan_mutex);\n\n\treturn 0;\n}\n\nstatic void scsi_sysfs_add_devices(struct Scsi_Host *shost)\n{\n\tstruct scsi_device *sdev;\n\tshost_for_each_device(sdev, shost) {\n\t\t \n\t\tif (sdev->sdev_state == SDEV_DEL)\n\t\t\tcontinue;\n\t\t \n\t\tif (sdev->is_visible)\n\t\t\tcontinue;\n\t\tif (!scsi_host_scan_allowed(shost) ||\n\t\t    scsi_sysfs_add_sdev(sdev) != 0)\n\t\t\t__scsi_remove_device(sdev);\n\t}\n}\n\n \nstatic struct async_scan_data *scsi_prep_async_scan(struct Scsi_Host *shost)\n{\n\tstruct async_scan_data *data = NULL;\n\tunsigned long flags;\n\n\tif (strncmp(scsi_scan_type, \"sync\", 4) == 0)\n\t\treturn NULL;\n\n\tmutex_lock(&shost->scan_mutex);\n\tif (shost->async_scan) {\n\t\tshost_printk(KERN_DEBUG, shost, \"%s called twice\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto err;\n\tdata->shost = scsi_host_get(shost);\n\tif (!data->shost)\n\t\tgoto err;\n\tinit_completion(&data->prev_finished);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tshost->async_scan = 1;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tmutex_unlock(&shost->scan_mutex);\n\n\tspin_lock(&async_scan_lock);\n\tif (list_empty(&scanning_hosts))\n\t\tcomplete(&data->prev_finished);\n\tlist_add_tail(&data->list, &scanning_hosts);\n\tspin_unlock(&async_scan_lock);\n\n\treturn data;\n\n err:\n\tmutex_unlock(&shost->scan_mutex);\n\tkfree(data);\n\treturn NULL;\n}\n\n \nstatic void scsi_finish_async_scan(struct async_scan_data *data)\n{\n\tstruct Scsi_Host *shost;\n\tunsigned long flags;\n\n\tif (!data)\n\t\treturn;\n\n\tshost = data->shost;\n\n\tmutex_lock(&shost->scan_mutex);\n\n\tif (!shost->async_scan) {\n\t\tshost_printk(KERN_INFO, shost, \"%s called twice\\n\", __func__);\n\t\tdump_stack();\n\t\tmutex_unlock(&shost->scan_mutex);\n\t\treturn;\n\t}\n\n\twait_for_completion(&data->prev_finished);\n\n\tscsi_sysfs_add_devices(shost);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tshost->async_scan = 0;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tmutex_unlock(&shost->scan_mutex);\n\n\tspin_lock(&async_scan_lock);\n\tlist_del(&data->list);\n\tif (!list_empty(&scanning_hosts)) {\n\t\tstruct async_scan_data *next = list_entry(scanning_hosts.next,\n\t\t\t\tstruct async_scan_data, list);\n\t\tcomplete(&next->prev_finished);\n\t}\n\tspin_unlock(&async_scan_lock);\n\n\tscsi_autopm_put_host(shost);\n\tscsi_host_put(shost);\n\tkfree(data);\n}\n\nstatic void do_scsi_scan_host(struct Scsi_Host *shost)\n{\n\tif (shost->hostt->scan_finished) {\n\t\tunsigned long start = jiffies;\n\t\tif (shost->hostt->scan_start)\n\t\t\tshost->hostt->scan_start(shost);\n\n\t\twhile (!shost->hostt->scan_finished(shost, jiffies - start))\n\t\t\tmsleep(10);\n\t} else {\n\t\tscsi_scan_host_selected(shost, SCAN_WILD_CARD, SCAN_WILD_CARD,\n\t\t\t\tSCAN_WILD_CARD, SCSI_SCAN_INITIAL);\n\t}\n}\n\nstatic void do_scan_async(void *_data, async_cookie_t c)\n{\n\tstruct async_scan_data *data = _data;\n\tstruct Scsi_Host *shost = data->shost;\n\n\tdo_scsi_scan_host(shost);\n\tscsi_finish_async_scan(data);\n}\n\n \nvoid scsi_scan_host(struct Scsi_Host *shost)\n{\n\tstruct async_scan_data *data;\n\n\tif (strncmp(scsi_scan_type, \"none\", 4) == 0 ||\n\t    strncmp(scsi_scan_type, \"manual\", 6) == 0)\n\t\treturn;\n\tif (scsi_autopm_get_host(shost) < 0)\n\t\treturn;\n\n\tdata = scsi_prep_async_scan(shost);\n\tif (!data) {\n\t\tdo_scsi_scan_host(shost);\n\t\tscsi_autopm_put_host(shost);\n\t\treturn;\n\t}\n\n\t \n\tasync_schedule(do_scan_async, data);\n\n\t \n}\nEXPORT_SYMBOL(scsi_scan_host);\n\nvoid scsi_forget_host(struct Scsi_Host *shost)\n{\n\tstruct scsi_device *sdev;\n\tunsigned long flags;\n\n restart:\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlist_for_each_entry(sdev, &shost->__devices, siblings) {\n\t\tif (sdev->sdev_state == SDEV_DEL)\n\t\t\tcontinue;\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t\t__scsi_remove_device(sdev);\n\t\tgoto restart;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}