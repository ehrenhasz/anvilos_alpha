{
  "module_name": "megaraid.c",
  "hash_id": "4f847d3263c5f8b21aaecec212b1e8cc0885f4a48e27f77f2dd2452dcbe04459",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/megaraid.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/dma-mapping.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsicam.h>\n\n#include \"megaraid.h\"\n\n#define MEGARAID_MODULE_VERSION \"2.00.4\"\n\nMODULE_AUTHOR (\"sju@lsil.com\");\nMODULE_DESCRIPTION (\"LSI Logic MegaRAID legacy driver\");\nMODULE_LICENSE (\"GPL\");\nMODULE_VERSION(MEGARAID_MODULE_VERSION);\n\nstatic DEFINE_MUTEX(megadev_mutex);\nstatic unsigned int max_cmd_per_lun = DEF_CMD_PER_LUN;\nmodule_param(max_cmd_per_lun, uint, 0);\nMODULE_PARM_DESC(max_cmd_per_lun, \"Maximum number of commands which can be issued to a single LUN (default=DEF_CMD_PER_LUN=63)\");\n\nstatic unsigned short int max_sectors_per_io = MAX_SECTORS_PER_IO;\nmodule_param(max_sectors_per_io, ushort, 0);\nMODULE_PARM_DESC(max_sectors_per_io, \"Maximum number of sectors per I/O request (default=MAX_SECTORS_PER_IO=128)\");\n\n\nstatic unsigned short int max_mbox_busy_wait = MBOX_BUSY_WAIT;\nmodule_param(max_mbox_busy_wait, ushort, 0);\nMODULE_PARM_DESC(max_mbox_busy_wait, \"Maximum wait for mailbox in microseconds if busy (default=MBOX_BUSY_WAIT=10)\");\n\n#define RDINDOOR(adapter)\treadl((adapter)->mmio_base + 0x20)\n#define RDOUTDOOR(adapter)\treadl((adapter)->mmio_base + 0x2C)\n#define WRINDOOR(adapter,value)\t writel(value, (adapter)->mmio_base + 0x20)\n#define WROUTDOOR(adapter,value) writel(value, (adapter)->mmio_base + 0x2C)\n\n \n\nstatic int hba_count;\nstatic adapter_t *hba_soft_state[MAX_CONTROLLERS];\nstatic struct proc_dir_entry *mega_proc_dir_entry;\n\n \nstatic struct mega_hbas mega_hbas[MAX_CONTROLLERS];\n\nstatic long\nmegadev_unlocked_ioctl(struct file *filep, unsigned int cmd, unsigned long arg);\n\n \nstatic const struct file_operations megadev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= megadev_unlocked_ioctl,\n\t.open\t\t= megadev_open,\n\t.llseek\t\t= noop_llseek,\n};\n\n \nstatic struct mcontroller mcontroller[MAX_CONTROLLERS];\n\n \nstatic u32 driver_ver = 0x02000000;\n\n \nstatic int major;\n\n#define IS_RAID_CH(hba, ch)\t(((hba)->mega_ch_class >> (ch)) & 0x01)\n\n\n \nstatic int trace_level;\n\n \nstatic int\nmega_setup_mailbox(adapter_t *adapter)\n{\n\tunsigned long\talign;\n\n\tadapter->una_mbox64 = dma_alloc_coherent(&adapter->dev->dev,\n\t\t\t\t\t\t sizeof(mbox64_t),\n\t\t\t\t\t\t &adapter->una_mbox64_dma,\n\t\t\t\t\t\t GFP_KERNEL);\n\n\tif( !adapter->una_mbox64 ) return -1;\n\t\t\n\tadapter->mbox = &adapter->una_mbox64->mbox;\n\n\tadapter->mbox = (mbox_t *)((((unsigned long) adapter->mbox) + 15) &\n\t\t\t(~0UL ^ 0xFUL));\n\n\tadapter->mbox64 = (mbox64_t *)(((unsigned long)adapter->mbox) - 8);\n\n\talign = ((void *)adapter->mbox) - ((void *)&adapter->una_mbox64->mbox);\n\n\tadapter->mbox_dma = adapter->una_mbox64_dma + 8 + align;\n\n\t \n\tif( adapter->flag & BOARD_IOMAP ) {\n\n\t\toutb(adapter->mbox_dma & 0xFF,\n\t\t\t\tadapter->host->io_port + MBOX_PORT0);\n\n\t\toutb((adapter->mbox_dma >> 8) & 0xFF,\n\t\t\t\tadapter->host->io_port + MBOX_PORT1);\n\n\t\toutb((adapter->mbox_dma >> 16) & 0xFF,\n\t\t\t\tadapter->host->io_port + MBOX_PORT2);\n\n\t\toutb((adapter->mbox_dma >> 24) & 0xFF,\n\t\t\t\tadapter->host->io_port + MBOX_PORT3);\n\n\t\toutb(ENABLE_MBOX_BYTE,\n\t\t\t\tadapter->host->io_port + ENABLE_MBOX_REGION);\n\n\t\tirq_ack(adapter);\n\n\t\tirq_enable(adapter);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int\nmega_query_adapter(adapter_t *adapter)\n{\n\tdma_addr_t\tprod_info_dma_handle;\n\tmega_inquiry3\t*inquiry3;\n\tstruct mbox_out\tmbox;\n\tu8\t*raw_mbox = (u8 *)&mbox;\n\tint\tretval;\n\n\t \n\n\tmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\n\tmemset(&mbox, 0, sizeof(mbox));\n\n\t \n\tmbox.xferaddr = (u32)adapter->buf_dma_handle;\n\n\tinquiry3 = (mega_inquiry3 *)adapter->mega_buffer;\n\n\traw_mbox[0] = FC_NEW_CONFIG;\t\t \n\traw_mbox[2] = NC_SUBOP_ENQUIRY3;\t \n\traw_mbox[3] = ENQ3_GET_SOLICITED_FULL;\t \n\n\t \n\tif ((retval = issue_scb_block(adapter, raw_mbox))) {\n\t\t \n\n\t\tmraid_ext_inquiry\t*ext_inq;\n\t\tmraid_inquiry\t\t*inq;\n\t\tdma_addr_t\t\tdma_handle;\n\n\t\text_inq = dma_alloc_coherent(&adapter->dev->dev,\n\t\t\t\t\t     sizeof(mraid_ext_inquiry),\n\t\t\t\t\t     &dma_handle, GFP_KERNEL);\n\n\t\tif( ext_inq == NULL ) return -1;\n\n\t\tinq = &ext_inq->raid_inq;\n\n\t\tmbox.xferaddr = (u32)dma_handle;\n\n\t\t \n\t\tmbox.cmd = MEGA_MBOXCMD_ADPEXTINQ;\n\n\t\tissue_scb_block(adapter, raw_mbox);\n\n\t\t \n\t\tmega_8_to_40ld(inq, inquiry3,\n\t\t\t\t(mega_product_info *)&adapter->product_info);\n\n\t\tdma_free_coherent(&adapter->dev->dev,\n\t\t\t\t  sizeof(mraid_ext_inquiry), ext_inq,\n\t\t\t\t  dma_handle);\n\n\t} else {\t\t \n\t\tadapter->flag |= BOARD_40LD;\n\n\t\t \n\t\tprod_info_dma_handle = dma_map_single(&adapter->dev->dev,\n\t\t\t\t\t\t      (void *)&adapter->product_info,\n\t\t\t\t\t\t      sizeof(mega_product_info),\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\n\t\tmbox.xferaddr = prod_info_dma_handle;\n\n\t\traw_mbox[0] = FC_NEW_CONFIG;\t \n\t\traw_mbox[2] = NC_SUBOP_PRODUCT_INFO;\t \n\n\t\tif ((retval = issue_scb_block(adapter, raw_mbox)))\n\t\t\tdev_warn(&adapter->dev->dev,\n\t\t\t\t\"Product_info cmd failed with error: %d\\n\",\n\t\t\t\tretval);\n\n\t\tdma_unmap_single(&adapter->dev->dev, prod_info_dma_handle,\n\t\t\t\t sizeof(mega_product_info), DMA_FROM_DEVICE);\n\t}\n\n\n\t \n\tadapter->host->max_channel =\n\t\tadapter->product_info.nchannels + NVIRT_CHAN -1;\n\n\tadapter->host->max_id = 16;\t \n\n\tadapter->host->max_lun = 7;\t \n\n\tadapter->host->cmd_per_lun = max_cmd_per_lun;\n\n\tadapter->numldrv = inquiry3->num_ldrv;\n\n\tadapter->max_cmds = adapter->product_info.max_commands;\n\n\tif(adapter->max_cmds > MAX_COMMANDS)\n\t\tadapter->max_cmds = MAX_COMMANDS;\n\n\tadapter->host->can_queue = adapter->max_cmds - 1;\n\n\t \n\tmega_get_max_sgl(adapter);\n\n\tadapter->host->sg_tablesize = adapter->sglen;\n\n\t \n\tif (adapter->product_info.subsysvid == PCI_VENDOR_ID_HP) {\n\t\tsnprintf(adapter->fw_version, sizeof(adapter->fw_version),\n\t\t\t \"%c%d%d.%d%d\",\n\t\t\t adapter->product_info.fw_version[2],\n\t\t\t 0,\n\t\t\t adapter->product_info.fw_version[1] & 0x0f,\n\t\t\t 0,\n\t\t\t adapter->product_info.fw_version[0] & 0x0f);\n\t\tsnprintf(adapter->bios_version, sizeof(adapter->fw_version),\n\t\t\t \"%c%d%d.%d%d\",\n\t\t\t adapter->product_info.bios_version[2],\n\t\t\t 0,\n\t\t\t adapter->product_info.bios_version[1] & 0x0f,\n\t\t\t 0,\n\t\t\t adapter->product_info.bios_version[0] & 0x0f);\n\t} else {\n\t\tmemcpy(adapter->fw_version,\n\t\t\t\t(char *)adapter->product_info.fw_version, 4);\n\t\tadapter->fw_version[4] = 0;\n\n\t\tmemcpy(adapter->bios_version,\n\t\t\t\t(char *)adapter->product_info.bios_version, 4);\n\n\t\tadapter->bios_version[4] = 0;\n\t}\n\n\tdev_notice(&adapter->dev->dev, \"[%s:%s] detected %d logical drives\\n\",\n\t\tadapter->fw_version, adapter->bios_version, adapter->numldrv);\n\n\t \n\tadapter->support_ext_cdb = mega_support_ext_cdb(adapter);\n\tif (adapter->support_ext_cdb)\n\t\tdev_notice(&adapter->dev->dev, \"supports extended CDBs\\n\");\n\n\n\treturn 0;\n}\n\n \nstatic inline void\nmega_runpendq(adapter_t *adapter)\n{\n\tif(!list_empty(&adapter->pending_list))\n\t\t__mega_runpendq(adapter);\n}\n\n \nstatic int megaraid_queue_lck(struct scsi_cmnd *scmd)\n{\n\tadapter_t\t*adapter;\n\tscb_t\t*scb;\n\tint\tbusy=0;\n\tunsigned long flags;\n\n\tadapter = (adapter_t *)scmd->device->host->hostdata;\n\n\t \n\n\tspin_lock_irqsave(&adapter->lock, flags);\n\tscb = mega_build_cmd(adapter, scmd, &busy);\n\tif (!scb)\n\t\tgoto out;\n\n\tscb->state |= SCB_PENDQ;\n\tlist_add_tail(&scb->list, &adapter->pending_list);\n\n\t \n\tif (atomic_read(&adapter->quiescent) == 0)\n\t\tmega_runpendq(adapter);\n\n\tbusy = 0;\n out:\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n\treturn busy;\n}\n\nstatic DEF_SCSI_QCMD(megaraid_queue)\n\n \nstatic inline scb_t *\nmega_allocate_scb(adapter_t *adapter, struct scsi_cmnd *cmd)\n{\n\tstruct list_head *head = &adapter->free_list;\n\tscb_t\t*scb;\n\n\t \n\tif( !list_empty(head) ) {\n\n\t\tscb = list_entry(head->next, scb_t, list);\n\n\t\tlist_del_init(head->next);\n\n\t\tscb->state = SCB_ACTIVE;\n\t\tscb->cmd = cmd;\n\t\tscb->dma_type = MEGA_DMA_TYPE_NONE;\n\n\t\treturn scb;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline int\nmega_get_ldrv_num(adapter_t *adapter, struct scsi_cmnd *cmd, int channel)\n{\n\tint\t\ttgt;\n\tint\t\tldrv_num;\n\n\ttgt = cmd->device->id;\n\t\n\tif ( tgt > adapter->this_id )\n\t\ttgt--;\t \n\n\tldrv_num = (channel * 15) + tgt;\n\n\n\t \n\tif( adapter->boot_ldrv_enabled ) {\n\t\tif( ldrv_num == 0 ) {\n\t\t\tldrv_num = adapter->boot_ldrv;\n\t\t}\n\t\telse {\n\t\t\tif( ldrv_num <= adapter->boot_ldrv ) {\n\t\t\t\tldrv_num--;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tif (adapter->support_random_del && adapter->read_ldidmap )\n\t\tswitch (cmd->cmnd[0]) {\n\t\tcase READ_6:\n\t\tcase WRITE_6:\n\t\tcase READ_10:\n\t\tcase WRITE_10:\n\t\t\tldrv_num += 0x80;\n\t\t}\n\n\treturn ldrv_num;\n}\n\n \nstatic scb_t *\nmega_build_cmd(adapter_t *adapter, struct scsi_cmnd *cmd, int *busy)\n{\n\tmega_passthru\t*pthru;\n\tscb_t\t*scb;\n\tmbox_t\t*mbox;\n\tu32\tseg;\n\tchar\tislogical;\n\tint\tmax_ldrv_num;\n\tint\tchannel = 0;\n\tint\ttarget = 0;\n\tint\tldrv_num = 0;    \n\n\t \n\tislogical = adapter->logdrv_chan[cmd->device->channel];\n\n\t \n\tif( adapter->boot_pdrv_enabled ) {\n\t\tif( islogical ) {\n\t\t\t \n\t\t\tchannel = cmd->device->channel -\n\t\t\t\tadapter->product_info.nchannels;\n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tchannel = cmd->device->channel; \n\t\t\ttarget = cmd->device->id;\n\n\t\t\t \n\t\t\tif( target == 0 ) {\n\t\t\t\ttarget = adapter->boot_pdrv_tgt;\n\t\t\t}\n\t\t\telse if( target == adapter->boot_pdrv_tgt ) {\n\t\t\t\ttarget = 0;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif( islogical ) {\n\t\t\t \n\t\t\tchannel = cmd->device->channel;\t\n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tchannel = cmd->device->channel - NVIRT_CHAN;\t\n\t\t\ttarget = cmd->device->id;\n\t\t}\n\t}\n\n\n\tif(islogical) {\n\n\t\t \n\t\tif (cmd->device->lun) {\n\t\t\tcmd->result = (DID_BAD_TARGET << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tldrv_num = mega_get_ldrv_num(adapter, cmd, channel);\n\n\n\t\tmax_ldrv_num = (adapter->flag & BOARD_40LD) ?\n\t\t\tMAX_LOGICAL_DRIVES_40LD : MAX_LOGICAL_DRIVES_8LD;\n\n\t\t \n\t\tif(adapter->read_ldidmap)\n\t\t\tmax_ldrv_num += 0x80;\n\n\t\tif(ldrv_num > max_ldrv_num ) {\n\t\t\tcmd->result = (DID_BAD_TARGET << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn NULL;\n\t\t}\n\n\t}\n\telse {\n\t\tif( cmd->device->lun > 7) {\n\t\t\t \n\t\t\tcmd->result = (DID_BAD_TARGET << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\tif(islogical) {\n\t\tswitch (cmd->cmnd[0]) {\n\t\tcase TEST_UNIT_READY:\n#if MEGA_HAVE_CLUSTERING\n\t\t\t \n\t\t\tif( !adapter->has_cluster ) {\n\t\t\t\tcmd->result = (DID_OK << 16);\n\t\t\t\tscsi_done(cmd);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif(!(scb = mega_allocate_scb(adapter, cmd))) {\n\t\t\t\t*busy = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tscb->raw_mbox[0] = MEGA_CLUSTER_CMD;\n\t\t\tscb->raw_mbox[2] = MEGA_RESERVATION_STATUS;\n\t\t\tscb->raw_mbox[3] = ldrv_num;\n\n\t\t\tscb->dma_direction = DMA_NONE;\n\n\t\t\treturn scb;\n#else\n\t\t\tcmd->result = (DID_OK << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn NULL;\n#endif\n\n\t\tcase MODE_SENSE: {\n\t\t\tchar *buf;\n\t\t\tstruct scatterlist *sg;\n\n\t\t\tsg = scsi_sglist(cmd);\n\t\t\tbuf = kmap_atomic(sg_page(sg)) + sg->offset;\n\n\t\t\tmemset(buf, 0, cmd->cmnd[4]);\n\t\t\tkunmap_atomic(buf - sg->offset);\n\n\t\t\tcmd->result = (DID_OK << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tcase READ_CAPACITY:\n\t\tcase INQUIRY:\n\n\t\t\tif(!(adapter->flag & (1L << cmd->device->channel))) {\n\n\t\t\t\tdev_notice(&adapter->dev->dev,\n\t\t\t\t\t\"scsi%d: scanning scsi channel %d \"\n\t\t\t\t\t\"for logical drives\\n\",\n\t\t\t\t\t\tadapter->host->host_no,\n\t\t\t\t\t\tcmd->device->channel);\n\n\t\t\t\tadapter->flag |= (1L << cmd->device->channel);\n\t\t\t}\n\n\t\t\t \n\t\t\tif(!(scb = mega_allocate_scb(adapter, cmd))) {\n\t\t\t\t*busy = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpthru = scb->pthru;\n\n\t\t\tmbox = (mbox_t *)scb->raw_mbox;\n\t\t\tmemset(mbox, 0, sizeof(scb->raw_mbox));\n\t\t\tmemset(pthru, 0, sizeof(mega_passthru));\n\n\t\t\tpthru->timeout = 0;\n\t\t\tpthru->ars = 1;\n\t\t\tpthru->reqsenselen = 14;\n\t\t\tpthru->islogical = 1;\n\t\t\tpthru->logdrv = ldrv_num;\n\t\t\tpthru->cdblen = cmd->cmd_len;\n\t\t\tmemcpy(pthru->cdb, cmd->cmnd, cmd->cmd_len);\n\n\t\t\tif( adapter->has_64bit_addr ) {\n\t\t\t\tmbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU64;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU;\n\t\t\t}\n\n\t\t\tscb->dma_direction = DMA_FROM_DEVICE;\n\n\t\t\tpthru->numsgelements = mega_build_sglist(adapter, scb,\n\t\t\t\t&pthru->dataxferaddr, &pthru->dataxferlen);\n\n\t\t\tmbox->m_out.xferaddr = scb->pthru_dma_addr;\n\n\t\t\treturn scb;\n\n\t\tcase READ_6:\n\t\tcase WRITE_6:\n\t\tcase READ_10:\n\t\tcase WRITE_10:\n\t\tcase READ_12:\n\t\tcase WRITE_12:\n\n\t\t\t \n\t\t\tif(!(scb = mega_allocate_scb(adapter, cmd))) {\n\t\t\t\t*busy = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmbox = (mbox_t *)scb->raw_mbox;\n\n\t\t\tmemset(mbox, 0, sizeof(scb->raw_mbox));\n\t\t\tmbox->m_out.logdrv = ldrv_num;\n\n\t\t\t \n\t\t\tif( adapter->has_64bit_addr ) {\n\t\t\t\tmbox->m_out.cmd = (*cmd->cmnd & 0x02) ?\n\t\t\t\t\tMEGA_MBOXCMD_LWRITE64:\n\t\t\t\t\tMEGA_MBOXCMD_LREAD64 ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmbox->m_out.cmd = (*cmd->cmnd & 0x02) ?\n\t\t\t\t\tMEGA_MBOXCMD_LWRITE:\n\t\t\t\t\tMEGA_MBOXCMD_LREAD ;\n\t\t\t}\n\n\t\t\t \n\t\t\tif( cmd->cmd_len == 6 ) {\n\t\t\t\tmbox->m_out.numsectors = (u32) cmd->cmnd[4];\n\t\t\t\tmbox->m_out.lba =\n\t\t\t\t\t((u32)cmd->cmnd[1] << 16) |\n\t\t\t\t\t((u32)cmd->cmnd[2] << 8) |\n\t\t\t\t\t(u32)cmd->cmnd[3];\n\n\t\t\t\tmbox->m_out.lba &= 0x1FFFFF;\n\n#if MEGA_HAVE_STATS\n\t\t\t\t \n\t\t\t\tif (*cmd->cmnd == READ_6) {\n\t\t\t\t\tadapter->nreads[ldrv_num%0x80]++;\n\t\t\t\t\tadapter->nreadblocks[ldrv_num%0x80] +=\n\t\t\t\t\t\tmbox->m_out.numsectors;\n\t\t\t\t} else {\n\t\t\t\t\tadapter->nwrites[ldrv_num%0x80]++;\n\t\t\t\t\tadapter->nwriteblocks[ldrv_num%0x80] +=\n\t\t\t\t\t\tmbox->m_out.numsectors;\n\t\t\t\t}\n#endif\n\t\t\t}\n\n\t\t\t \n\t\t\tif( cmd->cmd_len == 10 ) {\n\t\t\t\tmbox->m_out.numsectors =\n\t\t\t\t\t(u32)cmd->cmnd[8] |\n\t\t\t\t\t((u32)cmd->cmnd[7] << 8);\n\t\t\t\tmbox->m_out.lba =\n\t\t\t\t\t((u32)cmd->cmnd[2] << 24) |\n\t\t\t\t\t((u32)cmd->cmnd[3] << 16) |\n\t\t\t\t\t((u32)cmd->cmnd[4] << 8) |\n\t\t\t\t\t(u32)cmd->cmnd[5];\n\n#if MEGA_HAVE_STATS\n\t\t\t\tif (*cmd->cmnd == READ_10) {\n\t\t\t\t\tadapter->nreads[ldrv_num%0x80]++;\n\t\t\t\t\tadapter->nreadblocks[ldrv_num%0x80] +=\n\t\t\t\t\t\tmbox->m_out.numsectors;\n\t\t\t\t} else {\n\t\t\t\t\tadapter->nwrites[ldrv_num%0x80]++;\n\t\t\t\t\tadapter->nwriteblocks[ldrv_num%0x80] +=\n\t\t\t\t\t\tmbox->m_out.numsectors;\n\t\t\t\t}\n#endif\n\t\t\t}\n\n\t\t\t \n\t\t\tif( cmd->cmd_len == 12 ) {\n\t\t\t\tmbox->m_out.lba =\n\t\t\t\t\t((u32)cmd->cmnd[2] << 24) |\n\t\t\t\t\t((u32)cmd->cmnd[3] << 16) |\n\t\t\t\t\t((u32)cmd->cmnd[4] << 8) |\n\t\t\t\t\t(u32)cmd->cmnd[5];\n\n\t\t\t\tmbox->m_out.numsectors =\n\t\t\t\t\t((u32)cmd->cmnd[6] << 24) |\n\t\t\t\t\t((u32)cmd->cmnd[7] << 16) |\n\t\t\t\t\t((u32)cmd->cmnd[8] << 8) |\n\t\t\t\t\t(u32)cmd->cmnd[9];\n\n#if MEGA_HAVE_STATS\n\t\t\t\tif (*cmd->cmnd == READ_12) {\n\t\t\t\t\tadapter->nreads[ldrv_num%0x80]++;\n\t\t\t\t\tadapter->nreadblocks[ldrv_num%0x80] +=\n\t\t\t\t\t\tmbox->m_out.numsectors;\n\t\t\t\t} else {\n\t\t\t\t\tadapter->nwrites[ldrv_num%0x80]++;\n\t\t\t\t\tadapter->nwriteblocks[ldrv_num%0x80] +=\n\t\t\t\t\t\tmbox->m_out.numsectors;\n\t\t\t\t}\n#endif\n\t\t\t}\n\n\t\t\t \n\t\t\tif( (*cmd->cmnd & 0x0F) == 0x08 ) {\n\t\t\t\tscb->dma_direction = DMA_FROM_DEVICE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscb->dma_direction = DMA_TO_DEVICE;\n\t\t\t}\n\n\t\t\t \n\t\t\tmbox->m_out.numsgelements = mega_build_sglist(adapter, scb,\n\t\t\t\t\t(u32 *)&mbox->m_out.xferaddr, &seg);\n\n\t\t\treturn scb;\n\n#if MEGA_HAVE_CLUSTERING\n\t\tcase RESERVE:\n\t\tcase RELEASE:\n\n\t\t\t \n\t\t\tif( ! adapter->has_cluster ) {\n\n\t\t\t\tcmd->result = (DID_BAD_TARGET << 16);\n\t\t\t\tscsi_done(cmd);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif(!(scb = mega_allocate_scb(adapter, cmd))) {\n\t\t\t\t*busy = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tscb->raw_mbox[0] = MEGA_CLUSTER_CMD;\n\t\t\tscb->raw_mbox[2] = ( *cmd->cmnd == RESERVE ) ?\n\t\t\t\tMEGA_RESERVE_LD : MEGA_RELEASE_LD;\n\n\t\t\tscb->raw_mbox[3] = ldrv_num;\n\n\t\t\tscb->dma_direction = DMA_NONE;\n\n\t\t\treturn scb;\n#endif\n\n\t\tdefault:\n\t\t\tcmd->result = (DID_BAD_TARGET << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t \n\telse {\n\t\t \n\t\tif(!(scb = mega_allocate_scb(adapter, cmd))) {\n\t\t\t*busy = 1;\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmbox = (mbox_t *)scb->raw_mbox;\n\t\tmemset(mbox, 0, sizeof(scb->raw_mbox));\n\n\t\tif( adapter->support_ext_cdb ) {\n\n\t\t\tmega_prepare_extpassthru(adapter, scb, cmd,\n\t\t\t\t\tchannel, target);\n\n\t\t\tmbox->m_out.cmd = MEGA_MBOXCMD_EXTPTHRU;\n\n\t\t\tmbox->m_out.xferaddr = scb->epthru_dma_addr;\n\n\t\t}\n\t\telse {\n\n\t\t\tpthru = mega_prepare_passthru(adapter, scb, cmd,\n\t\t\t\t\tchannel, target);\n\n\t\t\t \n\t\t\tif( adapter->has_64bit_addr ) {\n\t\t\t\tmbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU64;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU;\n\t\t\t}\n\n\t\t\tmbox->m_out.xferaddr = scb->pthru_dma_addr;\n\n\t\t}\n\t\treturn scb;\n\t}\n\treturn NULL;\n}\n\n\n \nstatic mega_passthru *\nmega_prepare_passthru(adapter_t *adapter, scb_t *scb, struct scsi_cmnd *cmd,\n\t\t      int channel, int target)\n{\n\tmega_passthru *pthru;\n\n\tpthru = scb->pthru;\n\tmemset(pthru, 0, sizeof (mega_passthru));\n\n\t \n\tpthru->timeout = 2;\n\n\tpthru->ars = 1;\n\tpthru->reqsenselen = 14;\n\tpthru->islogical = 0;\n\n\tpthru->channel = (adapter->flag & BOARD_40LD) ? 0 : channel;\n\n\tpthru->target = (adapter->flag & BOARD_40LD) ?\n\t\t(channel << 4) | target : target;\n\n\tpthru->cdblen = cmd->cmd_len;\n\tpthru->logdrv = cmd->device->lun;\n\n\tmemcpy(pthru->cdb, cmd->cmnd, cmd->cmd_len);\n\n\t \n\tscb->dma_direction = DMA_BIDIRECTIONAL;\n\n\t \n\tswitch (cmd->cmnd[0]) {\n\tcase INQUIRY:\n\tcase READ_CAPACITY:\n\t\tif(!(adapter->flag & (1L << cmd->device->channel))) {\n\n\t\t\tdev_notice(&adapter->dev->dev,\n\t\t\t\t\"scsi%d: scanning scsi channel %d [P%d] \"\n\t\t\t\t\"for physical devices\\n\",\n\t\t\t\t\tadapter->host->host_no,\n\t\t\t\t\tcmd->device->channel, channel);\n\n\t\t\tadapter->flag |= (1L << cmd->device->channel);\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tpthru->numsgelements = mega_build_sglist(adapter, scb,\n\t\t\t\t&pthru->dataxferaddr, &pthru->dataxferlen);\n\t\tbreak;\n\t}\n\treturn pthru;\n}\n\n\n \nstatic mega_ext_passthru *\nmega_prepare_extpassthru(adapter_t *adapter, scb_t *scb,\n\t\t\t struct scsi_cmnd *cmd,\n\t\t\t int channel, int target)\n{\n\tmega_ext_passthru\t*epthru;\n\n\tepthru = scb->epthru;\n\tmemset(epthru, 0, sizeof(mega_ext_passthru));\n\n\t \n\tepthru->timeout = 2;\n\n\tepthru->ars = 1;\n\tepthru->reqsenselen = 14;\n\tepthru->islogical = 0;\n\n\tepthru->channel = (adapter->flag & BOARD_40LD) ? 0 : channel;\n\tepthru->target = (adapter->flag & BOARD_40LD) ?\n\t\t(channel << 4) | target : target;\n\n\tepthru->cdblen = cmd->cmd_len;\n\tepthru->logdrv = cmd->device->lun;\n\n\tmemcpy(epthru->cdb, cmd->cmnd, cmd->cmd_len);\n\n\t \n\tscb->dma_direction = DMA_BIDIRECTIONAL;\n\n\tswitch(cmd->cmnd[0]) {\n\tcase INQUIRY:\n\tcase READ_CAPACITY:\n\t\tif(!(adapter->flag & (1L << cmd->device->channel))) {\n\n\t\t\tdev_notice(&adapter->dev->dev,\n\t\t\t\t\"scsi%d: scanning scsi channel %d [P%d] \"\n\t\t\t\t\"for physical devices\\n\",\n\t\t\t\t\tadapter->host->host_no,\n\t\t\t\t\tcmd->device->channel, channel);\n\n\t\t\tadapter->flag |= (1L << cmd->device->channel);\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tepthru->numsgelements = mega_build_sglist(adapter, scb,\n\t\t\t\t&epthru->dataxferaddr, &epthru->dataxferlen);\n\t\tbreak;\n\t}\n\n\treturn epthru;\n}\n\nstatic void\n__mega_runpendq(adapter_t *adapter)\n{\n\tscb_t *scb;\n\tstruct list_head *pos, *next;\n\n\t \n\tlist_for_each_safe(pos, next, &adapter->pending_list) {\n\n\t\tscb = list_entry(pos, scb_t, list);\n\n\t\tif( !(scb->state & SCB_ISSUED) ) {\n\n\t\t\tif( issue_scb(adapter, scb) != 0 )\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\treturn;\n}\n\n\n \nstatic int\nissue_scb(adapter_t *adapter, scb_t *scb)\n{\n\tvolatile mbox64_t\t*mbox64 = adapter->mbox64;\n\tvolatile mbox_t\t\t*mbox = adapter->mbox;\n\tunsigned int\ti = 0;\n\n\tif(unlikely(mbox->m_in.busy)) {\n\t\tdo {\n\t\t\tudelay(1);\n\t\t\ti++;\n\t\t} while( mbox->m_in.busy && (i < max_mbox_busy_wait) );\n\n\t\tif(mbox->m_in.busy) return -1;\n\t}\n\n\t \n\tmemcpy((char *)&mbox->m_out, (char *)scb->raw_mbox, \n\t\t\tsizeof(struct mbox_out));\n\n\tmbox->m_out.cmdid = scb->idx;\t \n\tmbox->m_in.busy = 1;\t\t \n\n\n\t \n\tatomic_inc(&adapter->pend_cmds);\n\n\tswitch (mbox->m_out.cmd) {\n\tcase MEGA_MBOXCMD_LREAD64:\n\tcase MEGA_MBOXCMD_LWRITE64:\n\tcase MEGA_MBOXCMD_PASSTHRU64:\n\tcase MEGA_MBOXCMD_EXTPTHRU:\n\t\tmbox64->xfer_segment_lo = mbox->m_out.xferaddr;\n\t\tmbox64->xfer_segment_hi = 0;\n\t\tmbox->m_out.xferaddr = 0xFFFFFFFF;\n\t\tbreak;\n\tdefault:\n\t\tmbox64->xfer_segment_lo = 0;\n\t\tmbox64->xfer_segment_hi = 0;\n\t}\n\n\t \n\tscb->state |= SCB_ISSUED;\n\n\tif( likely(adapter->flag & BOARD_MEMMAP) ) {\n\t\tmbox->m_in.poll = 0;\n\t\tmbox->m_in.ack = 0;\n\t\tWRINDOOR(adapter, adapter->mbox_dma | 0x1);\n\t}\n\telse {\n\t\tirq_enable(adapter);\n\t\tissue_command(adapter);\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int\nmega_busywait_mbox (adapter_t *adapter)\n{\n\tif (adapter->mbox->m_in.busy)\n\t\treturn __mega_busywait_mbox(adapter);\n\treturn 0;\n}\n\n \nstatic int\nissue_scb_block(adapter_t *adapter, u_char *raw_mbox)\n{\n\tvolatile mbox64_t *mbox64 = adapter->mbox64;\n\tvolatile mbox_t *mbox = adapter->mbox;\n\tu8\tbyte;\n\n\t \n\tif(mega_busywait_mbox (adapter))\n\t\tgoto bug_blocked_mailbox;\n\n\t \n\tmemcpy((char *) mbox, raw_mbox, sizeof(struct mbox_out));\n\tmbox->m_out.cmdid = 0xFE;\n\tmbox->m_in.busy = 1;\n\n\tswitch (raw_mbox[0]) {\n\tcase MEGA_MBOXCMD_LREAD64:\n\tcase MEGA_MBOXCMD_LWRITE64:\n\tcase MEGA_MBOXCMD_PASSTHRU64:\n\tcase MEGA_MBOXCMD_EXTPTHRU:\n\t\tmbox64->xfer_segment_lo = mbox->m_out.xferaddr;\n\t\tmbox64->xfer_segment_hi = 0;\n\t\tmbox->m_out.xferaddr = 0xFFFFFFFF;\n\t\tbreak;\n\tdefault:\n\t\tmbox64->xfer_segment_lo = 0;\n\t\tmbox64->xfer_segment_hi = 0;\n\t}\n\n\tif( likely(adapter->flag & BOARD_MEMMAP) ) {\n\t\tmbox->m_in.poll = 0;\n\t\tmbox->m_in.ack = 0;\n\t\tmbox->m_in.numstatus = 0xFF;\n\t\tmbox->m_in.status = 0xFF;\n\t\tWRINDOOR(adapter, adapter->mbox_dma | 0x1);\n\n\t\twhile((volatile u8)mbox->m_in.numstatus == 0xFF)\n\t\t\tcpu_relax();\n\n\t\tmbox->m_in.numstatus = 0xFF;\n\n\t\twhile( (volatile u8)mbox->m_in.poll != 0x77 )\n\t\t\tcpu_relax();\n\n\t\tmbox->m_in.poll = 0;\n\t\tmbox->m_in.ack = 0x77;\n\n\t\tWRINDOOR(adapter, adapter->mbox_dma | 0x2);\n\n\t\twhile(RDINDOOR(adapter) & 0x2)\n\t\t\tcpu_relax();\n\t}\n\telse {\n\t\tirq_disable(adapter);\n\t\tissue_command(adapter);\n\n\t\twhile (!((byte = irq_state(adapter)) & INTR_VALID))\n\t\t\tcpu_relax();\n\n\t\tset_irq_state(adapter, byte);\n\t\tirq_enable(adapter);\n\t\tirq_ack(adapter);\n\t}\n\n\treturn mbox->m_in.status;\n\nbug_blocked_mailbox:\n\tdev_warn(&adapter->dev->dev, \"Blocked mailbox......!!\\n\");\n\tudelay (1000);\n\treturn -1;\n}\n\n\n \nstatic irqreturn_t\nmegaraid_isr_iomapped(int irq, void *devp)\n{\n\tadapter_t\t*adapter = devp;\n\tunsigned long\tflags;\n\tu8\tstatus;\n\tu8\tnstatus;\n\tu8\tcompleted[MAX_FIRMWARE_STATUS];\n\tu8\tbyte;\n\tint\thandled = 0;\n\n\n\t \n\tspin_lock_irqsave(&adapter->lock, flags);\n\n\tdo {\n\t\t \n\t\tbyte = irq_state(adapter);\n\t\tif( (byte & VALID_INTR_BYTE) == 0 ) {\n\t\t\t \n\t\t\tgoto out_unlock;\n\t\t}\n\t\tset_irq_state(adapter, byte);\n\n\t\twhile((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)\n\t\t\t\t== 0xFF)\n\t\t\tcpu_relax();\n\t\tadapter->mbox->m_in.numstatus = 0xFF;\n\n\t\tstatus = adapter->mbox->m_in.status;\n\n\t\t \n\t\tatomic_sub(nstatus, &adapter->pend_cmds);\n\n\t\tmemcpy(completed, (void *)adapter->mbox->m_in.completed, \n\t\t\t\tnstatus);\n\n\t\t \n\t\tirq_ack(adapter);\n\n\t\tmega_cmd_done(adapter, completed, nstatus, status);\n\n\t\tmega_rundoneq(adapter);\n\n\t\thandled = 1;\n\n\t\t \n\t\tif(atomic_read(&adapter->quiescent) == 0) {\n\t\t\tmega_runpendq(adapter);\n\t\t}\n\n\t} while(1);\n\n out_unlock:\n\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n\n \nstatic irqreturn_t\nmegaraid_isr_memmapped(int irq, void *devp)\n{\n\tadapter_t\t*adapter = devp;\n\tunsigned long\tflags;\n\tu8\tstatus;\n\tu32\tdword = 0;\n\tu8\tnstatus;\n\tu8\tcompleted[MAX_FIRMWARE_STATUS];\n\tint\thandled = 0;\n\n\n\t \n\tspin_lock_irqsave(&adapter->lock, flags);\n\n\tdo {\n\t\t \n\t\tdword = RDOUTDOOR(adapter);\n\t\tif(dword != 0x10001234) {\n\t\t\t \n\t\t\tgoto out_unlock;\n\t\t}\n\t\tWROUTDOOR(adapter, 0x10001234);\n\n\t\twhile((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)\n\t\t\t\t== 0xFF) {\n\t\t\tcpu_relax();\n\t\t}\n\t\tadapter->mbox->m_in.numstatus = 0xFF;\n\n\t\tstatus = adapter->mbox->m_in.status;\n\n\t\t \n\t\tatomic_sub(nstatus, &adapter->pend_cmds);\n\n\t\tmemcpy(completed, (void *)adapter->mbox->m_in.completed, \n\t\t\t\tnstatus);\n\n\t\t \n\t\tWRINDOOR(adapter, 0x2);\n\n\t\thandled = 1;\n\n\t\twhile( RDINDOOR(adapter) & 0x02 )\n\t\t\tcpu_relax();\n\n\t\tmega_cmd_done(adapter, completed, nstatus, status);\n\n\t\tmega_rundoneq(adapter);\n\n\t\t \n\t\tif(atomic_read(&adapter->quiescent) == 0) {\n\t\t\tmega_runpendq(adapter);\n\t\t}\n\n\t} while(1);\n\n out_unlock:\n\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n \nstatic void\nmega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)\n{\n\tmega_ext_passthru\t*epthru = NULL;\n\tstruct scatterlist\t*sgl;\n\tstruct scsi_cmnd\t*cmd = NULL;\n\tmega_passthru\t*pthru = NULL;\n\tmbox_t\t*mbox = NULL;\n\tu8\tc;\n\tscb_t\t*scb;\n\tint\tislogical;\n\tint\tcmdid;\n\tint\ti;\n\n\t \n\tfor( i = 0; i < nstatus; i++ ) {\n\n\t\tcmdid = completed[i];\n\n\t\t \n\t\tif (cmdid == CMDID_INT_CMDS) {\n\t\t\tscb = &adapter->int_scb;\n\t\t\tcmd = scb->cmd;\n\n\t\t\tlist_del_init(&scb->list);\n\t\t\tscb->state = SCB_FREE;\n\n\t\t\tadapter->int_status = status;\n\t\t\tcomplete(&adapter->int_waitq);\n\t\t} else {\n\t\t\tscb = &adapter->scb_list[cmdid];\n\n\t\t\t \n\t\t\tif( !(scb->state & SCB_ISSUED) || scb->cmd == NULL ) {\n\t\t\t\tdev_crit(&adapter->dev->dev, \"invalid command \"\n\t\t\t\t\t\"Id %d, scb->state:%x, scsi cmd:%p\\n\",\n\t\t\t\t\tcmdid, scb->state, scb->cmd);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif( scb->state & SCB_ABORT ) {\n\n\t\t\t\tdev_warn(&adapter->dev->dev,\n\t\t\t\t\t\"aborted cmd [%x] complete\\n\",\n\t\t\t\t\tscb->idx);\n\n\t\t\t\tscb->cmd->result = (DID_ABORT << 16);\n\n\t\t\t\tlist_add_tail(SCSI_LIST(scb->cmd),\n\t\t\t\t\t\t&adapter->completed_list);\n\n\t\t\t\tmega_free_scb(adapter, scb);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif( scb->state & SCB_RESET ) {\n\n\t\t\t\tdev_warn(&adapter->dev->dev,\n\t\t\t\t\t\"reset cmd [%x] complete\\n\",\n\t\t\t\t\tscb->idx);\n\n\t\t\t\tscb->cmd->result = (DID_RESET << 16);\n\n\t\t\t\tlist_add_tail(SCSI_LIST(scb->cmd),\n\t\t\t\t\t\t&adapter->completed_list);\n\n\t\t\t\tmega_free_scb (adapter, scb);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcmd = scb->cmd;\n\t\t\tpthru = scb->pthru;\n\t\t\tepthru = scb->epthru;\n\t\t\tmbox = (mbox_t *)scb->raw_mbox;\n\n#if MEGA_HAVE_STATS\n\t\t\t{\n\n\t\t\tint\tlogdrv = mbox->m_out.logdrv;\n\n\t\t\tislogical = adapter->logdrv_chan[cmd->channel];\n\t\t\t \n\t\t\tif( status && islogical && (cmd->cmnd[0] == READ_6 ||\n\t\t\t\t\t\tcmd->cmnd[0] == READ_10 ||\n\t\t\t\t\t\tcmd->cmnd[0] == READ_12)) {\n\t\t\t\t \n\t\t\t\tadapter->rd_errors[logdrv%0x80]++;\n\t\t\t}\n\n\t\t\tif( status && islogical && (cmd->cmnd[0] == WRITE_6 ||\n\t\t\t\t\t\tcmd->cmnd[0] == WRITE_10 ||\n\t\t\t\t\t\tcmd->cmnd[0] == WRITE_12)) {\n\t\t\t\t \n\t\t\t\tadapter->wr_errors[logdrv%0x80]++;\n\t\t\t}\n\n\t\t\t}\n#endif\n\t\t}\n\n\t\t \n\t\tislogical = adapter->logdrv_chan[cmd->device->channel];\n\t\tif( cmd->cmnd[0] == INQUIRY && !islogical ) {\n\n\t\t\tsgl = scsi_sglist(cmd);\n\t\t\tif( sg_page(sgl) ) {\n\t\t\t\tc = *(unsigned char *) sg_virt(&sgl[0]);\n\t\t\t} else {\n\t\t\t\tdev_warn(&adapter->dev->dev, \"invalid sg\\n\");\n\t\t\t\tc = 0;\n\t\t\t}\n\n\t\t\tif(IS_RAID_CH(adapter, cmd->device->channel) &&\n\t\t\t\t\t((c & 0x1F ) == TYPE_DISK)) {\n\t\t\t\tstatus = 0xF0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tcmd->result = 0;\n\n\t\t \n\t\tswitch (status) {\n\t\tcase 0x00:\t \n\t\t\tcmd->result |= (DID_OK << 16);\n\t\t\tbreak;\n\n\t\tcase 0x02:\t \n\n\t\t\t \n\t\t\tif( mbox->m_out.cmd == MEGA_MBOXCMD_PASSTHRU ||\n\t\t\t\tmbox->m_out.cmd == MEGA_MBOXCMD_PASSTHRU64 ) {\n\n\t\t\t\tmemcpy(cmd->sense_buffer, pthru->reqsensearea,\n\t\t\t\t\t\t14);\n\n\t\t\t\tcmd->result = SAM_STAT_CHECK_CONDITION;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (mbox->m_out.cmd == MEGA_MBOXCMD_EXTPTHRU) {\n\n\t\t\t\t\tmemcpy(cmd->sense_buffer,\n\t\t\t\t\t\tepthru->reqsensearea, 14);\n\n\t\t\t\t\tcmd->result = SAM_STAT_CHECK_CONDITION;\n\t\t\t\t} else\n\t\t\t\t\tscsi_build_sense(cmd, 0,\n\t\t\t\t\t\t\t ABORTED_COMMAND, 0, 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x08:\t \n\t\t\tcmd->result |= (DID_BUS_BUSY << 16) | status;\n\t\t\tbreak;\n\n\t\tdefault:\n#if MEGA_HAVE_CLUSTERING\n\t\t\t \n\t\t\tif( cmd->cmnd[0] == TEST_UNIT_READY ) {\n\t\t\t\tcmd->result |= (DID_ERROR << 16) |\n\t\t\t\t\tSAM_STAT_RESERVATION_CONFLICT;\n\t\t\t}\n\t\t\telse\n\t\t\t \n\t\t\tif( status == 1 &&\n\t\t\t\t(cmd->cmnd[0] == RESERVE ||\n\t\t\t\t\t cmd->cmnd[0] == RELEASE) ) {\n\n\t\t\t\tcmd->result |= (DID_ERROR << 16) |\n\t\t\t\t\tSAM_STAT_RESERVATION_CONFLICT;\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t\tcmd->result |= (DID_BAD_TARGET << 16)|status;\n\t\t}\n\n\t\tmega_free_scb(adapter, scb);\n\n\t\t \n\t\tlist_add_tail(SCSI_LIST(cmd), &adapter->completed_list);\n\t}\n}\n\n\n \nstatic void\nmega_rundoneq (adapter_t *adapter)\n{\n\tstruct megaraid_cmd_priv *cmd_priv;\n\n\tlist_for_each_entry(cmd_priv, &adapter->completed_list, entry)\n\t\tscsi_done(megaraid_to_scsi_cmd(cmd_priv));\n\n\tINIT_LIST_HEAD(&adapter->completed_list);\n}\n\n\n \nstatic void\nmega_free_scb(adapter_t *adapter, scb_t *scb)\n{\n\tswitch( scb->dma_type ) {\n\n\tcase MEGA_DMA_TYPE_NONE:\n\t\tbreak;\n\n\tcase MEGA_SGLIST:\n\t\tscsi_dma_unmap(scb->cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tlist_del_init(&scb->list);\n\n\t \n\tscb->state = SCB_FREE;\n\tscb->cmd = NULL;\n\n\tlist_add(&scb->list, &adapter->free_list);\n}\n\n\nstatic int\n__mega_busywait_mbox (adapter_t *adapter)\n{\n\tvolatile mbox_t *mbox = adapter->mbox;\n\tlong counter;\n\n\tfor (counter = 0; counter < 10000; counter++) {\n\t\tif (!mbox->m_in.busy)\n\t\t\treturn 0;\n\t\tudelay(100);\n\t\tcond_resched();\n\t}\n\treturn -1;\t\t \n}\n\n \nstatic int\nmega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)\n{\n\tstruct scatterlist *sg;\n\tstruct scsi_cmnd\t*cmd;\n\tint\tsgcnt;\n\tint\tidx;\n\n\tcmd = scb->cmd;\n\n\t \n\tsgcnt = scsi_dma_map(cmd);\n\n\tscb->dma_type = MEGA_SGLIST;\n\n\tBUG_ON(sgcnt > adapter->sglen || sgcnt < 0);\n\n\t*len = 0;\n\n\tif (scsi_sg_count(cmd) == 1 && !adapter->has_64bit_addr) {\n\t\tsg = scsi_sglist(cmd);\n\t\tscb->dma_h_bulkdata = sg_dma_address(sg);\n\t\t*buf = (u32)scb->dma_h_bulkdata;\n\t\t*len = sg_dma_len(sg);\n\t\treturn 0;\n\t}\n\n\tscsi_for_each_sg(cmd, sg, sgcnt, idx) {\n\t\tif (adapter->has_64bit_addr) {\n\t\t\tscb->sgl64[idx].address = sg_dma_address(sg);\n\t\t\t*len += scb->sgl64[idx].length = sg_dma_len(sg);\n\t\t} else {\n\t\t\tscb->sgl[idx].address = sg_dma_address(sg);\n\t\t\t*len += scb->sgl[idx].length = sg_dma_len(sg);\n\t\t}\n\t}\n\n\t \n\t*buf = scb->sgl_dma_addr;\n\n\t \n\treturn sgcnt;\n}\n\n\n \nstatic void\nmega_8_to_40ld(mraid_inquiry *inquiry, mega_inquiry3 *enquiry3,\n\t\tmega_product_info *product_info)\n{\n\tint i;\n\n\tproduct_info->max_commands = inquiry->adapter_info.max_commands;\n\tenquiry3->rebuild_rate = inquiry->adapter_info.rebuild_rate;\n\tproduct_info->nchannels = inquiry->adapter_info.nchannels;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tproduct_info->fw_version[i] =\n\t\t\tinquiry->adapter_info.fw_version[i];\n\n\t\tproduct_info->bios_version[i] =\n\t\t\tinquiry->adapter_info.bios_version[i];\n\t}\n\tenquiry3->cache_flush_interval =\n\t\tinquiry->adapter_info.cache_flush_interval;\n\n\tproduct_info->dram_size = inquiry->adapter_info.dram_size;\n\n\tenquiry3->num_ldrv = inquiry->logdrv_info.num_ldrv;\n\n\tfor (i = 0; i < MAX_LOGICAL_DRIVES_8LD; i++) {\n\t\tenquiry3->ldrv_size[i] = inquiry->logdrv_info.ldrv_size[i];\n\t\tenquiry3->ldrv_prop[i] = inquiry->logdrv_info.ldrv_prop[i];\n\t\tenquiry3->ldrv_state[i] = inquiry->logdrv_info.ldrv_state[i];\n\t}\n\n\tfor (i = 0; i < (MAX_PHYSICAL_DRIVES); i++)\n\t\tenquiry3->pdrv_state[i] = inquiry->pdrv_info.pdrv_state[i];\n}\n\nstatic inline void\nmega_free_sgl(adapter_t *adapter)\n{\n\tscb_t\t*scb;\n\tint\ti;\n\n\tfor(i = 0; i < adapter->max_cmds; i++) {\n\n\t\tscb = &adapter->scb_list[i];\n\n\t\tif( scb->sgl64 ) {\n\t\t\tdma_free_coherent(&adapter->dev->dev,\n\t\t\t\t\t  sizeof(mega_sgl64) * adapter->sglen,\n\t\t\t\t\t  scb->sgl64, scb->sgl_dma_addr);\n\n\t\t\tscb->sgl64 = NULL;\n\t\t}\n\n\t\tif( scb->pthru ) {\n\t\t\tdma_free_coherent(&adapter->dev->dev,\n\t\t\t\t\t  sizeof(mega_passthru), scb->pthru,\n\t\t\t\t\t  scb->pthru_dma_addr);\n\n\t\t\tscb->pthru = NULL;\n\t\t}\n\n\t\tif( scb->epthru ) {\n\t\t\tdma_free_coherent(&adapter->dev->dev,\n\t\t\t\t\t  sizeof(mega_ext_passthru),\n\t\t\t\t\t  scb->epthru, scb->epthru_dma_addr);\n\n\t\t\tscb->epthru = NULL;\n\t\t}\n\n\t}\n}\n\n\n \nconst char *\nmegaraid_info(struct Scsi_Host *host)\n{\n\tstatic char buffer[512];\n\tadapter_t *adapter;\n\n\tadapter = (adapter_t *)host->hostdata;\n\n\tsprintf (buffer,\n\t\t \"LSI Logic MegaRAID %s %d commands %d targs %d chans %d luns\",\n\t\t adapter->fw_version, adapter->product_info.max_commands,\n\t\t adapter->host->max_id, adapter->host->max_channel,\n\t\t (u32)adapter->host->max_lun);\n\treturn buffer;\n}\n\n \nstatic int\nmegaraid_abort(struct scsi_cmnd *cmd)\n{\n\tadapter_t\t*adapter;\n\tint\t\trval;\n\n\tadapter = (adapter_t *)cmd->device->host->hostdata;\n\n\trval =  megaraid_abort_and_reset(adapter, cmd, SCB_ABORT);\n\n\t \n\tmega_rundoneq(adapter);\n\n\treturn rval;\n}\n\n\nstatic int\nmegaraid_reset(struct scsi_cmnd *cmd)\n{\n\tadapter_t\t*adapter;\n\tmegacmd_t\tmc;\n\tint\t\trval;\n\n\tadapter = (adapter_t *)cmd->device->host->hostdata;\n\n#if MEGA_HAVE_CLUSTERING\n\tmc.cmd = MEGA_CLUSTER_CMD;\n\tmc.opcode = MEGA_RESET_RESERVATIONS;\n\n\tif( mega_internal_command(adapter, &mc, NULL) != 0 ) {\n\t\tdev_warn(&adapter->dev->dev, \"reservation reset failed\\n\");\n\t}\n\telse {\n\t\tdev_info(&adapter->dev->dev, \"reservation reset\\n\");\n\t}\n#endif\n\n\tspin_lock_irq(&adapter->lock);\n\n\trval =  megaraid_abort_and_reset(adapter, cmd, SCB_RESET);\n\n\t \n\tmega_rundoneq(adapter);\n\tspin_unlock_irq(&adapter->lock);\n\n\treturn rval;\n}\n\n \nstatic int\nmegaraid_abort_and_reset(adapter_t *adapter, struct scsi_cmnd *cmd, int aor)\n{\n\tstruct list_head\t*pos, *next;\n\tscb_t\t\t\t*scb;\n\n\tdev_warn(&adapter->dev->dev, \"%s cmd=%x <c=%d t=%d l=%d>\\n\",\n\t     (aor == SCB_ABORT)? \"ABORTING\":\"RESET\",\n\t     cmd->cmnd[0], cmd->device->channel,\n\t     cmd->device->id, (u32)cmd->device->lun);\n\n\tif(list_empty(&adapter->pending_list))\n\t\treturn FAILED;\n\n\tlist_for_each_safe(pos, next, &adapter->pending_list) {\n\n\t\tscb = list_entry(pos, scb_t, list);\n\n\t\tif (scb->cmd == cmd) {  \n\n\t\t\tscb->state |= aor;\n\n\t\t\t \n\t\t\tif( scb->state & SCB_ISSUED ) {\n\n\t\t\t\tdev_warn(&adapter->dev->dev,\n\t\t\t\t\t\"%s[%x], fw owner\\n\",\n\t\t\t\t\t(aor==SCB_ABORT) ? \"ABORTING\":\"RESET\",\n\t\t\t\t\tscb->idx);\n\n\t\t\t\treturn FAILED;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t \n\t\t\t\tdev_warn(&adapter->dev->dev,\n\t\t\t\t\t\"%s-[%x], driver owner\\n\",\n\t\t\t\t\t(aor==SCB_ABORT) ? \"ABORTING\":\"RESET\",\n\t\t\t\t\tscb->idx);\n\n\t\t\t\tmega_free_scb(adapter, scb);\n\n\t\t\t\tif( aor == SCB_ABORT ) {\n\t\t\t\t\tcmd->result = (DID_ABORT << 16);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcmd->result = (DID_RESET << 16);\n\t\t\t\t}\n\n\t\t\t\tlist_add_tail(SCSI_LIST(cmd),\n\t\t\t\t\t\t&adapter->completed_list);\n\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn FAILED;\n}\n\nstatic inline int\nmake_local_pdev(adapter_t *adapter, struct pci_dev **pdev)\n{\n\t*pdev = pci_alloc_dev(NULL);\n\n\tif( *pdev == NULL ) return -1;\n\n\tmemcpy(*pdev, adapter->dev, sizeof(struct pci_dev));\n\n\tif (dma_set_mask(&(*pdev)->dev, DMA_BIT_MASK(32)) != 0) {\n\t\tkfree(*pdev);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void\nfree_local_pdev(struct pci_dev *pdev)\n{\n\tkfree(pdev);\n}\n\n \nstatic inline void *\nmega_allocate_inquiry(dma_addr_t *dma_handle, struct pci_dev *pdev)\n{\n\treturn dma_alloc_coherent(&pdev->dev, sizeof(mega_inquiry3),\n\t\t\t\t  dma_handle, GFP_KERNEL);\n}\n\n\nstatic inline void\nmega_free_inquiry(void *inquiry, dma_addr_t dma_handle, struct pci_dev *pdev)\n{\n\tdma_free_coherent(&pdev->dev, sizeof(mega_inquiry3), inquiry,\n\t\t\t  dma_handle);\n}\n\n\n#ifdef CONFIG_PROC_FS\n \n\n \nstatic int\nproc_show_config(struct seq_file *m, void *v)\n{\n\n\tadapter_t *adapter = m->private;\n\n\tseq_puts(m, MEGARAID_VERSION);\n\tif(adapter->product_info.product_name[0])\n\t\tseq_printf(m, \"%s\\n\", adapter->product_info.product_name);\n\n\tseq_puts(m, \"Controller Type: \");\n\n\tif( adapter->flag & BOARD_MEMMAP )\n\t\tseq_puts(m, \"438/466/467/471/493/518/520/531/532\\n\");\n\telse\n\t\tseq_puts(m, \"418/428/434\\n\");\n\n\tif(adapter->flag & BOARD_40LD)\n\t\tseq_puts(m, \"Controller Supports 40 Logical Drives\\n\");\n\n\tif(adapter->flag & BOARD_64BIT)\n\t\tseq_puts(m, \"Controller capable of 64-bit memory addressing\\n\");\n\tif( adapter->has_64bit_addr )\n\t\tseq_puts(m, \"Controller using 64-bit memory addressing\\n\");\n\telse\n\t\tseq_puts(m, \"Controller is not using 64-bit memory addressing\\n\");\n\n\tseq_printf(m, \"Base = %08lx, Irq = %d, \",\n\t\t   adapter->base, adapter->host->irq);\n\n\tseq_printf(m, \"Logical Drives = %d, Channels = %d\\n\",\n\t\t   adapter->numldrv, adapter->product_info.nchannels);\n\n\tseq_printf(m, \"Version =%s:%s, DRAM = %dMb\\n\",\n\t\t   adapter->fw_version, adapter->bios_version,\n\t\t   adapter->product_info.dram_size);\n\n\tseq_printf(m, \"Controller Queue Depth = %d, Driver Queue Depth = %d\\n\",\n\t\t   adapter->product_info.max_commands, adapter->max_cmds);\n\n\tseq_printf(m, \"support_ext_cdb    = %d\\n\", adapter->support_ext_cdb);\n\tseq_printf(m, \"support_random_del = %d\\n\", adapter->support_random_del);\n\tseq_printf(m, \"boot_ldrv_enabled  = %d\\n\", adapter->boot_ldrv_enabled);\n\tseq_printf(m, \"boot_ldrv          = %d\\n\", adapter->boot_ldrv);\n\tseq_printf(m, \"boot_pdrv_enabled  = %d\\n\", adapter->boot_pdrv_enabled);\n\tseq_printf(m, \"boot_pdrv_ch       = %d\\n\", adapter->boot_pdrv_ch);\n\tseq_printf(m, \"boot_pdrv_tgt      = %d\\n\", adapter->boot_pdrv_tgt);\n\tseq_printf(m, \"quiescent          = %d\\n\",\n\t\t   atomic_read(&adapter->quiescent));\n\tseq_printf(m, \"has_cluster        = %d\\n\", adapter->has_cluster);\n\n\tseq_puts(m, \"\\nModule Parameters:\\n\");\n\tseq_printf(m, \"max_cmd_per_lun    = %d\\n\", max_cmd_per_lun);\n\tseq_printf(m, \"max_sectors_per_io = %d\\n\", max_sectors_per_io);\n\treturn 0;\n}\n\n \nstatic int\nproc_show_stat(struct seq_file *m, void *v)\n{\n\tadapter_t *adapter = m->private;\n#if MEGA_HAVE_STATS\n\tint\ti;\n#endif\n\n\tseq_puts(m, \"Statistical Information for this controller\\n\");\n\tseq_printf(m, \"pend_cmds = %d\\n\", atomic_read(&adapter->pend_cmds));\n#if MEGA_HAVE_STATS\n\tfor(i = 0; i < adapter->numldrv; i++) {\n\t\tseq_printf(m, \"Logical Drive %d:\\n\", i);\n\t\tseq_printf(m, \"\\tReads Issued = %lu, Writes Issued = %lu\\n\",\n\t\t\t   adapter->nreads[i], adapter->nwrites[i]);\n\t\tseq_printf(m, \"\\tSectors Read = %lu, Sectors Written = %lu\\n\",\n\t\t\t   adapter->nreadblocks[i], adapter->nwriteblocks[i]);\n\t\tseq_printf(m, \"\\tRead errors = %lu, Write errors = %lu\\n\\n\",\n\t\t\t   adapter->rd_errors[i], adapter->wr_errors[i]);\n\t}\n#else\n\tseq_puts(m, \"IO and error counters not compiled in driver.\\n\");\n#endif\n\treturn 0;\n}\n\n\n \nstatic int\nproc_show_mbox(struct seq_file *m, void *v)\n{\n\tadapter_t\t*adapter = m->private;\n\tvolatile mbox_t\t*mbox = adapter->mbox;\n\n\tseq_puts(m, \"Contents of Mail Box Structure\\n\");\n\tseq_printf(m, \"  Fw Command   = 0x%02x\\n\", mbox->m_out.cmd);\n\tseq_printf(m, \"  Cmd Sequence = 0x%02x\\n\", mbox->m_out.cmdid);\n\tseq_printf(m, \"  No of Sectors= %04d\\n\", mbox->m_out.numsectors);\n\tseq_printf(m, \"  LBA          = 0x%02x\\n\", mbox->m_out.lba);\n\tseq_printf(m, \"  DTA          = 0x%08x\\n\", mbox->m_out.xferaddr);\n\tseq_printf(m, \"  Logical Drive= 0x%02x\\n\", mbox->m_out.logdrv);\n\tseq_printf(m, \"  No of SG Elmt= 0x%02x\\n\", mbox->m_out.numsgelements);\n\tseq_printf(m, \"  Busy         = %01x\\n\", mbox->m_in.busy);\n\tseq_printf(m, \"  Status       = 0x%02x\\n\", mbox->m_in.status);\n\treturn 0;\n}\n\n\n \nstatic int\nproc_show_rebuild_rate(struct seq_file *m, void *v)\n{\n\tadapter_t\t*adapter = m->private;\n\tdma_addr_t\tdma_handle;\n\tcaddr_t\t\tinquiry;\n\tstruct pci_dev\t*pdev;\n\n\tif( make_local_pdev(adapter, &pdev) != 0 )\n\t\treturn 0;\n\n\tif( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL )\n\t\tgoto free_pdev;\n\n\tif( mega_adapinq(adapter, dma_handle) != 0 ) {\n\t\tseq_puts(m, \"Adapter inquiry failed.\\n\");\n\t\tdev_warn(&adapter->dev->dev, \"inquiry failed\\n\");\n\t\tgoto free_inquiry;\n\t}\n\n\tif( adapter->flag & BOARD_40LD )\n\t\tseq_printf(m, \"Rebuild Rate: [%d%%]\\n\",\n\t\t\t   ((mega_inquiry3 *)inquiry)->rebuild_rate);\n\telse\n\t\tseq_printf(m, \"Rebuild Rate: [%d%%]\\n\",\n\t\t\t((mraid_ext_inquiry *)\n\t\t\t inquiry)->raid_inq.adapter_info.rebuild_rate);\n\nfree_inquiry:\n\tmega_free_inquiry(inquiry, dma_handle, pdev);\nfree_pdev:\n\tfree_local_pdev(pdev);\n\treturn 0;\n}\n\n\n \nstatic int\nproc_show_battery(struct seq_file *m, void *v)\n{\n\tadapter_t\t*adapter = m->private;\n\tdma_addr_t\tdma_handle;\n\tcaddr_t\t\tinquiry;\n\tstruct pci_dev\t*pdev;\n\tu8\tbattery_status;\n\n\tif( make_local_pdev(adapter, &pdev) != 0 )\n\t\treturn 0;\n\n\tif( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL )\n\t\tgoto free_pdev;\n\n\tif( mega_adapinq(adapter, dma_handle) != 0 ) {\n\t\tseq_puts(m, \"Adapter inquiry failed.\\n\");\n\t\tdev_warn(&adapter->dev->dev, \"inquiry failed\\n\");\n\t\tgoto free_inquiry;\n\t}\n\n\tif( adapter->flag & BOARD_40LD ) {\n\t\tbattery_status = ((mega_inquiry3 *)inquiry)->battery_status;\n\t}\n\telse {\n\t\tbattery_status = ((mraid_ext_inquiry *)inquiry)->\n\t\t\traid_inq.adapter_info.battery_status;\n\t}\n\n\t \n\tseq_printf(m, \"Battery Status:[%d]\", battery_status);\n\n\tif(battery_status == MEGA_BATT_CHARGE_DONE)\n\t\tseq_puts(m, \" Charge Done\");\n\n\tif(battery_status & MEGA_BATT_MODULE_MISSING)\n\t\tseq_puts(m, \" Module Missing\");\n\t\n\tif(battery_status & MEGA_BATT_LOW_VOLTAGE)\n\t\tseq_puts(m, \" Low Voltage\");\n\t\n\tif(battery_status & MEGA_BATT_TEMP_HIGH)\n\t\tseq_puts(m, \" Temperature High\");\n\t\n\tif(battery_status & MEGA_BATT_PACK_MISSING)\n\t\tseq_puts(m, \" Pack Missing\");\n\t\n\tif(battery_status & MEGA_BATT_CHARGE_INPROG)\n\t\tseq_puts(m, \" Charge In-progress\");\n\t\n\tif(battery_status & MEGA_BATT_CHARGE_FAIL)\n\t\tseq_puts(m, \" Charge Fail\");\n\t\n\tif(battery_status & MEGA_BATT_CYCLES_EXCEEDED)\n\t\tseq_puts(m, \" Cycles Exceeded\");\n\n\tseq_putc(m, '\\n');\n\nfree_inquiry:\n\tmega_free_inquiry(inquiry, dma_handle, pdev);\nfree_pdev:\n\tfree_local_pdev(pdev);\n\treturn 0;\n}\n\n\n \nstatic void\nmega_print_inquiry(struct seq_file *m, char *scsi_inq)\n{\n\tint\ti;\n\n\tseq_puts(m, \"  Vendor: \");\n\tseq_write(m, scsi_inq + 8, 8);\n\tseq_puts(m, \"  Model: \");\n\tseq_write(m, scsi_inq + 16, 16);\n\tseq_puts(m, \"  Rev: \");\n\tseq_write(m, scsi_inq + 32, 4);\n\tseq_putc(m, '\\n');\n\n\ti = scsi_inq[0] & 0x1f;\n\tseq_printf(m, \"  Type:   %s \", scsi_device_type(i));\n\n\tseq_printf(m, \"                 ANSI SCSI revision: %02x\",\n\t\t   scsi_inq[2] & 0x07);\n\n\tif( (scsi_inq[2] & 0x07) == 1 && (scsi_inq[3] & 0x0f) == 1 )\n\t\tseq_puts(m, \" CCS\\n\");\n\telse\n\t\tseq_putc(m, '\\n');\n}\n\n \nstatic int\nproc_show_pdrv(struct seq_file *m, adapter_t *adapter, int channel)\n{\n\tdma_addr_t\tdma_handle;\n\tchar\t\t*scsi_inq;\n\tdma_addr_t\tscsi_inq_dma_handle;\n\tcaddr_t\t\tinquiry;\n\tstruct pci_dev\t*pdev;\n\tu8\t*pdrv_state;\n\tu8\tstate;\n\tint\ttgt;\n\tint\tmax_channels;\n\tint\ti;\n\n\tif( make_local_pdev(adapter, &pdev) != 0 )\n\t\treturn 0;\n\n\tif( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL )\n\t\tgoto free_pdev;\n\n\tif( mega_adapinq(adapter, dma_handle) != 0 ) {\n\t\tseq_puts(m, \"Adapter inquiry failed.\\n\");\n\t\tdev_warn(&adapter->dev->dev, \"inquiry failed\\n\");\n\t\tgoto free_inquiry;\n\t}\n\n\n\tscsi_inq = dma_alloc_coherent(&pdev->dev, 256, &scsi_inq_dma_handle,\n\t\t\t\t      GFP_KERNEL);\n\tif( scsi_inq == NULL ) {\n\t\tseq_puts(m, \"memory not available for scsi inq.\\n\");\n\t\tgoto free_inquiry;\n\t}\n\n\tif( adapter->flag & BOARD_40LD ) {\n\t\tpdrv_state = ((mega_inquiry3 *)inquiry)->pdrv_state;\n\t}\n\telse {\n\t\tpdrv_state = ((mraid_ext_inquiry *)inquiry)->\n\t\t\traid_inq.pdrv_info.pdrv_state;\n\t}\n\n\tmax_channels = adapter->product_info.nchannels;\n\n\tif( channel >= max_channels ) {\n\t\tgoto free_pci;\n\t}\n\n\tfor( tgt = 0; tgt <= MAX_TARGET; tgt++ ) {\n\n\t\ti = channel*16 + tgt;\n\n\t\tstate = *(pdrv_state + i);\n\t\tswitch( state & 0x0F ) {\n\t\tcase PDRV_ONLINE:\n\t\t\tseq_printf(m, \"Channel:%2d Id:%2d State: Online\",\n\t\t\t\t   channel, tgt);\n\t\t\tbreak;\n\n\t\tcase PDRV_FAILED:\n\t\t\tseq_printf(m, \"Channel:%2d Id:%2d State: Failed\",\n\t\t\t\t   channel, tgt);\n\t\t\tbreak;\n\n\t\tcase PDRV_RBLD:\n\t\t\tseq_printf(m, \"Channel:%2d Id:%2d State: Rebuild\",\n\t\t\t\t   channel, tgt);\n\t\t\tbreak;\n\n\t\tcase PDRV_HOTSPARE:\n\t\t\tseq_printf(m, \"Channel:%2d Id:%2d State: Hot spare\",\n\t\t\t\t   channel, tgt);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tseq_printf(m, \"Channel:%2d Id:%2d State: Un-configured\",\n\t\t\t\t   channel, tgt);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmemset(scsi_inq, 0, 256);\n\t\tif( mega_internal_dev_inquiry(adapter, channel, tgt,\n\t\t\t\tscsi_inq_dma_handle) ||\n\t\t\t\t(scsi_inq[0] & 0x1F) != TYPE_DISK ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tseq_puts(m, \".\\n\");\n\t\tmega_print_inquiry(m, scsi_inq);\n\t}\n\nfree_pci:\n\tdma_free_coherent(&pdev->dev, 256, scsi_inq, scsi_inq_dma_handle);\nfree_inquiry:\n\tmega_free_inquiry(inquiry, dma_handle, pdev);\nfree_pdev:\n\tfree_local_pdev(pdev);\n\treturn 0;\n}\n\n \nstatic int\nproc_show_pdrv_ch0(struct seq_file *m, void *v)\n{\n\treturn proc_show_pdrv(m, m->private, 0);\n}\n\n\n \nstatic int\nproc_show_pdrv_ch1(struct seq_file *m, void *v)\n{\n\treturn proc_show_pdrv(m, m->private, 1);\n}\n\n\n \nstatic int\nproc_show_pdrv_ch2(struct seq_file *m, void *v)\n{\n\treturn proc_show_pdrv(m, m->private, 2);\n}\n\n\n \nstatic int\nproc_show_pdrv_ch3(struct seq_file *m, void *v)\n{\n\treturn proc_show_pdrv(m, m->private, 3);\n}\n\n\n \nstatic int\nproc_show_rdrv(struct seq_file *m, adapter_t *adapter, int start, int end )\n{\n\tdma_addr_t\tdma_handle;\n\tlogdrv_param\t*lparam;\n\tmegacmd_t\tmc;\n\tchar\t\t*disk_array;\n\tdma_addr_t\tdisk_array_dma_handle;\n\tcaddr_t\t\tinquiry;\n\tstruct pci_dev\t*pdev;\n\tu8\t*rdrv_state;\n\tint\tnum_ldrv;\n\tu32\tarray_sz;\n\tint\ti;\n\n\tif( make_local_pdev(adapter, &pdev) != 0 )\n\t\treturn 0;\n\n\tif( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL )\n\t\tgoto free_pdev;\n\n\tif( mega_adapinq(adapter, dma_handle) != 0 ) {\n\t\tseq_puts(m, \"Adapter inquiry failed.\\n\");\n\t\tdev_warn(&adapter->dev->dev, \"inquiry failed\\n\");\n\t\tgoto free_inquiry;\n\t}\n\n\tmemset(&mc, 0, sizeof(megacmd_t));\n\n\tif( adapter->flag & BOARD_40LD ) {\n\t\tarray_sz = sizeof(disk_array_40ld);\n\n\t\trdrv_state = ((mega_inquiry3 *)inquiry)->ldrv_state;\n\n\t\tnum_ldrv = ((mega_inquiry3 *)inquiry)->num_ldrv;\n\t}\n\telse {\n\t\tarray_sz = sizeof(disk_array_8ld);\n\n\t\trdrv_state = ((mraid_ext_inquiry *)inquiry)->\n\t\t\traid_inq.logdrv_info.ldrv_state;\n\n\t\tnum_ldrv = ((mraid_ext_inquiry *)inquiry)->\n\t\t\traid_inq.logdrv_info.num_ldrv;\n\t}\n\n\tdisk_array = dma_alloc_coherent(&pdev->dev, array_sz,\n\t\t\t\t\t&disk_array_dma_handle, GFP_KERNEL);\n\n\tif( disk_array == NULL ) {\n\t\tseq_puts(m, \"memory not available.\\n\");\n\t\tgoto free_inquiry;\n\t}\n\n\tmc.xferaddr = (u32)disk_array_dma_handle;\n\n\tif( adapter->flag & BOARD_40LD ) {\n\t\tmc.cmd = FC_NEW_CONFIG;\n\t\tmc.opcode = OP_DCMD_READ_CONFIG;\n\n\t\tif( mega_internal_command(adapter, &mc, NULL) ) {\n\t\t\tseq_puts(m, \"40LD read config failed.\\n\");\n\t\t\tgoto free_pci;\n\t\t}\n\n\t}\n\telse {\n\t\tmc.cmd = NEW_READ_CONFIG_8LD;\n\n\t\tif( mega_internal_command(adapter, &mc, NULL) ) {\n\t\t\tmc.cmd = READ_CONFIG_8LD;\n\t\t\tif( mega_internal_command(adapter, &mc, NULL) ) {\n\t\t\t\tseq_puts(m, \"8LD read config failed.\\n\");\n\t\t\t\tgoto free_pci;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( i = start; i < ( (end+1 < num_ldrv) ? end+1 : num_ldrv ); i++ ) {\n\n\t\tif( adapter->flag & BOARD_40LD ) {\n\t\t\tlparam =\n\t\t\t&((disk_array_40ld *)disk_array)->ldrv[i].lparam;\n\t\t}\n\t\telse {\n\t\t\tlparam =\n\t\t\t&((disk_array_8ld *)disk_array)->ldrv[i].lparam;\n\t\t}\n\n\t\t \n\t\tseq_printf(m, \"Logical drive:%2d:, \", i);\n\n\t\tswitch( rdrv_state[i] & 0x0F ) {\n\t\tcase RDRV_OFFLINE:\n\t\t\tseq_puts(m, \"state: offline\");\n\t\t\tbreak;\n\t\tcase RDRV_DEGRADED:\n\t\t\tseq_puts(m, \"state: degraded\");\n\t\t\tbreak;\n\t\tcase RDRV_OPTIMAL:\n\t\t\tseq_puts(m, \"state: optimal\");\n\t\t\tbreak;\n\t\tcase RDRV_DELETED:\n\t\t\tseq_puts(m, \"state: deleted\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_puts(m, \"state: unknown\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif( (rdrv_state[i] & 0xF0) == 0x20 )\n\t\t\tseq_puts(m, \", check-consistency in progress\");\n\t\telse if( (rdrv_state[i] & 0xF0) == 0x10 )\n\t\t\tseq_puts(m, \", initialization in progress\");\n\t\t\n\t\tseq_putc(m, '\\n');\n\n\t\tseq_printf(m, \"Span depth:%3d, \", lparam->span_depth);\n\t\tseq_printf(m, \"RAID level:%3d, \", lparam->level);\n\t\tseq_printf(m, \"Stripe size:%3d, \",\n\t\t\t   lparam->stripe_sz ? lparam->stripe_sz/2: 128);\n\t\tseq_printf(m, \"Row size:%3d\\n\", lparam->row_size);\n\n\t\tseq_puts(m, \"Read Policy: \");\n\t\tswitch(lparam->read_ahead) {\n\t\tcase NO_READ_AHEAD:\n\t\t\tseq_puts(m, \"No read ahead, \");\n\t\t\tbreak;\n\t\tcase READ_AHEAD:\n\t\t\tseq_puts(m, \"Read ahead, \");\n\t\t\tbreak;\n\t\tcase ADAP_READ_AHEAD:\n\t\t\tseq_puts(m, \"Adaptive, \");\n\t\t\tbreak;\n\n\t\t}\n\n\t\tseq_puts(m, \"Write Policy: \");\n\t\tswitch(lparam->write_mode) {\n\t\tcase WRMODE_WRITE_THRU:\n\t\t\tseq_puts(m, \"Write thru, \");\n\t\t\tbreak;\n\t\tcase WRMODE_WRITE_BACK:\n\t\t\tseq_puts(m, \"Write back, \");\n\t\t\tbreak;\n\t\t}\n\n\t\tseq_puts(m, \"Cache Policy: \");\n\t\tswitch(lparam->direct_io) {\n\t\tcase CACHED_IO:\n\t\t\tseq_puts(m, \"Cached IO\\n\\n\");\n\t\t\tbreak;\n\t\tcase DIRECT_IO:\n\t\t\tseq_puts(m, \"Direct IO\\n\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\nfree_pci:\n\tdma_free_coherent(&pdev->dev, array_sz, disk_array,\n\t\t\t  disk_array_dma_handle);\nfree_inquiry:\n\tmega_free_inquiry(inquiry, dma_handle, pdev);\nfree_pdev:\n\tfree_local_pdev(pdev);\n\treturn 0;\n}\n\n \nstatic int\nproc_show_rdrv_10(struct seq_file *m, void *v)\n{\n\treturn proc_show_rdrv(m, m->private, 0, 9);\n}\n\n\n \nstatic int\nproc_show_rdrv_20(struct seq_file *m, void *v)\n{\n\treturn proc_show_rdrv(m, m->private, 10, 19);\n}\n\n\n \nstatic int\nproc_show_rdrv_30(struct seq_file *m, void *v)\n{\n\treturn proc_show_rdrv(m, m->private, 20, 29);\n}\n\n\n \nstatic int\nproc_show_rdrv_40(struct seq_file *m, void *v)\n{\n\treturn proc_show_rdrv(m, m->private, 30, 39);\n}\n\n \nstatic void\nmega_create_proc_entry(int index, struct proc_dir_entry *parent)\n{\n\tadapter_t *adapter = hba_soft_state[index];\n\tstruct proc_dir_entry *dir;\n\tu8 string[16];\n\n\tsprintf(string, \"hba%d\", adapter->host->host_no);\n\tdir = proc_mkdir_data(string, 0, parent, adapter);\n\tif (!dir) {\n\t\tdev_warn(&adapter->dev->dev, \"proc_mkdir failed\\n\");\n\t\treturn;\n\t}\n\n\tproc_create_single_data(\"config\", S_IRUSR, dir,\n\t\t\tproc_show_config, adapter);\n\tproc_create_single_data(\"stat\", S_IRUSR, dir,\n\t\t\tproc_show_stat, adapter);\n\tproc_create_single_data(\"mailbox\", S_IRUSR, dir,\n\t\t\tproc_show_mbox, adapter);\n#if MEGA_HAVE_ENH_PROC\n\tproc_create_single_data(\"rebuild-rate\", S_IRUSR, dir,\n\t\t\tproc_show_rebuild_rate, adapter);\n\tproc_create_single_data(\"battery-status\", S_IRUSR, dir,\n\t\t\tproc_show_battery, adapter);\n\tproc_create_single_data(\"diskdrives-ch0\", S_IRUSR, dir,\n\t\t\tproc_show_pdrv_ch0, adapter);\n\tproc_create_single_data(\"diskdrives-ch1\", S_IRUSR, dir,\n\t\t\tproc_show_pdrv_ch1, adapter);\n\tproc_create_single_data(\"diskdrives-ch2\", S_IRUSR, dir,\n\t\t\tproc_show_pdrv_ch2, adapter);\n\tproc_create_single_data(\"diskdrives-ch3\", S_IRUSR, dir,\n\t\t\tproc_show_pdrv_ch3, adapter);\n\tproc_create_single_data(\"raiddrives-0-9\", S_IRUSR, dir,\n\t\t\tproc_show_rdrv_10, adapter);\n\tproc_create_single_data(\"raiddrives-10-19\", S_IRUSR, dir,\n\t\t\tproc_show_rdrv_20, adapter);\n\tproc_create_single_data(\"raiddrives-20-29\", S_IRUSR, dir,\n\t\t\tproc_show_rdrv_30, adapter);\n\tproc_create_single_data(\"raiddrives-30-39\", S_IRUSR, dir,\n\t\t\tproc_show_rdrv_40, adapter);\n#endif\n}\n\n#else\nstatic inline void mega_create_proc_entry(int index, struct proc_dir_entry *parent)\n{\n}\n#endif\n\n\n \nstatic int\nmegaraid_biosparam(struct scsi_device *sdev, struct block_device *bdev,\n\t\t    sector_t capacity, int geom[])\n{\n\tadapter_t\t*adapter;\n\tint\theads;\n\tint\tsectors;\n\tint\tcylinders;\n\n\t \n\tadapter = (adapter_t *)sdev->host->hostdata;\n\n\tif (IS_RAID_CH(adapter, sdev->channel)) {\n\t\t\t \n\t\t\theads = 64;\n\t\t\tsectors = 32;\n\t\t\tcylinders = (ulong)capacity / (heads * sectors);\n\n\t\t\t \n\t\t\tif ((ulong)capacity >= 0x200000) {\n\t\t\t\theads = 255;\n\t\t\t\tsectors = 63;\n\t\t\t\tcylinders = (ulong)capacity / (heads * sectors);\n\t\t\t}\n\n\t\t\t \n\t\t\tgeom[0] = heads;\n\t\t\tgeom[1] = sectors;\n\t\t\tgeom[2] = cylinders;\n\t}\n\telse {\n\t\tif (scsi_partsize(bdev, capacity, geom))\n\t\t\treturn 0;\n\n\t\tdev_info(&adapter->dev->dev,\n\t\t\t \"invalid partition on this disk on channel %d\\n\",\n\t\t\t sdev->channel);\n\n\t\t \n\t\theads = 64;\n\t\tsectors = 32;\n\t\tcylinders = (ulong)capacity / (heads * sectors);\n\n\t\t \n\t\tif ((ulong)capacity >= 0x200000) {\n\t\t\theads = 255;\n\t\t\tsectors = 63;\n\t\t\tcylinders = (ulong)capacity / (heads * sectors);\n\t\t}\n\n\t\t \n\t\tgeom[0] = heads;\n\t\tgeom[1] = sectors;\n\t\tgeom[2] = cylinders;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmega_init_scb(adapter_t *adapter)\n{\n\tscb_t\t*scb;\n\tint\ti;\n\n\tfor( i = 0; i < adapter->max_cmds; i++ ) {\n\n\t\tscb = &adapter->scb_list[i];\n\n\t\tscb->sgl64 = NULL;\n\t\tscb->sgl = NULL;\n\t\tscb->pthru = NULL;\n\t\tscb->epthru = NULL;\n\t}\n\n\tfor( i = 0; i < adapter->max_cmds; i++ ) {\n\n\t\tscb = &adapter->scb_list[i];\n\n\t\tscb->idx = i;\n\n\t\tscb->sgl64 = dma_alloc_coherent(&adapter->dev->dev,\n\t\t\t\t\t\tsizeof(mega_sgl64) * adapter->sglen,\n\t\t\t\t\t\t&scb->sgl_dma_addr, GFP_KERNEL);\n\n\t\tscb->sgl = (mega_sglist *)scb->sgl64;\n\n\t\tif( !scb->sgl ) {\n\t\t\tdev_warn(&adapter->dev->dev, \"RAID: Can't allocate sglist\\n\");\n\t\t\tmega_free_sgl(adapter);\n\t\t\treturn -1;\n\t\t}\n\n\t\tscb->pthru = dma_alloc_coherent(&adapter->dev->dev,\n\t\t\t\t\t\tsizeof(mega_passthru),\n\t\t\t\t\t\t&scb->pthru_dma_addr, GFP_KERNEL);\n\n\t\tif( !scb->pthru ) {\n\t\t\tdev_warn(&adapter->dev->dev, \"RAID: Can't allocate passthru\\n\");\n\t\t\tmega_free_sgl(adapter);\n\t\t\treturn -1;\n\t\t}\n\n\t\tscb->epthru = dma_alloc_coherent(&adapter->dev->dev,\n\t\t\t\t\t\t sizeof(mega_ext_passthru),\n\t\t\t\t\t\t &scb->epthru_dma_addr, GFP_KERNEL);\n\n\t\tif( !scb->epthru ) {\n\t\t\tdev_warn(&adapter->dev->dev,\n\t\t\t\t\"Can't allocate extended passthru\\n\");\n\t\t\tmega_free_sgl(adapter);\n\t\t\treturn -1;\n\t\t}\n\n\n\t\tscb->dma_type = MEGA_DMA_TYPE_NONE;\n\n\t\t \n\t\tscb->state = SCB_FREE;\n\t\tscb->cmd = NULL;\n\t\tlist_add(&scb->list, &adapter->free_list);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int\nmegadev_open (struct inode *inode, struct file *filep)\n{\n\t \n\tif( !capable(CAP_SYS_ADMIN) ) return -EACCES;\n\n\treturn 0;\n}\n\n\n \nstatic int\nmegadev_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tadapter_t\t*adapter;\n\tnitioctl_t\tuioc;\n\tint\t\tadapno;\n\tint\t\trval;\n\tmega_passthru\t__user *upthru;\t \n\tmega_passthru\t*pthru;\t\t \n\tdma_addr_t\tpthru_dma_hndl;\n\tvoid\t\t*data = NULL;\t \n\tdma_addr_t\tdata_dma_hndl;\t \n\tmegacmd_t\tmc;\n#if MEGA_HAVE_STATS\n\tmegastat_t\t__user *ustats = NULL;\n\tint\t\tnum_ldrv = 0;\n#endif\n\tu32\t\tuxferaddr = 0;\n\tstruct pci_dev\t*pdev;\n\n\t \n\tif( (_IOC_TYPE(cmd) != MEGAIOC_MAGIC) && (cmd != USCSICMD) ) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(&uioc, 0, sizeof(nitioctl_t));\n\tif( (rval = mega_m_to_n( (void __user *)arg, &uioc)) != 0 )\n\t\treturn rval;\n\n\n\tswitch( uioc.opcode ) {\n\n\tcase GET_DRIVER_VER:\n\t\tif( put_user(driver_ver, (u32 __user *)uioc.uioc_uaddr) )\n\t\t\treturn (-EFAULT);\n\n\t\tbreak;\n\n\tcase GET_N_ADAP:\n\t\tif( put_user(hba_count, (u32 __user *)uioc.uioc_uaddr) )\n\t\t\treturn (-EFAULT);\n\n\t\t \n\t\treturn hba_count;\n\n\tcase GET_ADAP_INFO:\n\n\t\t \n\t\tif( (adapno = GETADAP(uioc.adapno)) >= hba_count )\n\t\t\treturn (-ENODEV);\n\n\t\tif( copy_to_user(uioc.uioc_uaddr, mcontroller+adapno,\n\t\t\t\tsizeof(struct mcontroller)) )\n\t\t\treturn (-EFAULT);\n\t\tbreak;\n\n#if MEGA_HAVE_STATS\n\n\tcase GET_STATS:\n\t\t \n\t\tif( (adapno = GETADAP(uioc.adapno)) >= hba_count )\n\t\t\treturn (-ENODEV);\n\n\t\tadapter = hba_soft_state[adapno];\n\n\t\tustats = uioc.uioc_uaddr;\n\n\t\tif( copy_from_user(&num_ldrv, &ustats->num_ldrv, sizeof(int)) )\n\t\t\treturn (-EFAULT);\n\n\t\t \n\t\tif( num_ldrv >= MAX_LOGICAL_DRIVES_40LD ) return -EINVAL;\n\n\t\tif( copy_to_user(ustats->nreads, adapter->nreads,\n\t\t\t\t\tnum_ldrv*sizeof(u32)) )\n\t\t\treturn -EFAULT;\n\n\t\tif( copy_to_user(ustats->nreadblocks, adapter->nreadblocks,\n\t\t\t\t\tnum_ldrv*sizeof(u32)) )\n\t\t\treturn -EFAULT;\n\n\t\tif( copy_to_user(ustats->nwrites, adapter->nwrites,\n\t\t\t\t\tnum_ldrv*sizeof(u32)) )\n\t\t\treturn -EFAULT;\n\n\t\tif( copy_to_user(ustats->nwriteblocks, adapter->nwriteblocks,\n\t\t\t\t\tnum_ldrv*sizeof(u32)) )\n\t\t\treturn -EFAULT;\n\n\t\tif( copy_to_user(ustats->rd_errors, adapter->rd_errors,\n\t\t\t\t\tnum_ldrv*sizeof(u32)) )\n\t\t\treturn -EFAULT;\n\n\t\tif( copy_to_user(ustats->wr_errors, adapter->wr_errors,\n\t\t\t\t\tnum_ldrv*sizeof(u32)) )\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n#endif\n\tcase MBOX_CMD:\n\n\t\t \n\t\tif( (adapno = GETADAP(uioc.adapno)) >= hba_count )\n\t\t\treturn (-ENODEV);\n\n\t\tadapter = hba_soft_state[adapno];\n\n\t\t \n\t\tif( uioc.uioc_rmbox[0] == FC_DEL_LOGDRV &&\n\t\t\t\tuioc.uioc_rmbox[2] == OP_DEL_LOGDRV ) {\n\n\t\t\t \n\t\t\tif( !adapter->support_random_del ) {\n\t\t\t\tdev_warn(&adapter->dev->dev, \"logdrv \"\n\t\t\t\t\t\"delete on non-supporting F/W\\n\");\n\n\t\t\t\treturn (-EINVAL);\n\t\t\t}\n\n\t\t\trval = mega_del_logdrv( adapter, uioc.uioc_rmbox[3] );\n\n\t\t\tif( rval == 0 ) {\n\t\t\t\tmemset(&mc, 0, sizeof(megacmd_t));\n\n\t\t\t\tmc.status = rval;\n\n\t\t\t\trval = mega_n_to_m((void __user *)arg, &mc);\n\t\t\t}\n\n\t\t\treturn rval;\n\t\t}\n\t\t \n\t\tif( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU64 ||\n\t\t\tuioc.uioc_rmbox[0] == MEGA_MBOXCMD_EXTPTHRU ) {\n\n\t\t\tdev_warn(&adapter->dev->dev, \"rejected passthru\\n\");\n\n\t\t\treturn (-EINVAL);\n\t\t}\n\n\t\t \n\t\tif( make_local_pdev(adapter, &pdev) != 0 )\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU ) {\n\t\t\t \n\n\t\t\tpthru = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t   sizeof(mega_passthru),\n\t\t\t\t\t\t   &pthru_dma_hndl, GFP_KERNEL);\n\n\t\t\tif( pthru == NULL ) {\n\t\t\t\tfree_local_pdev(pdev);\n\t\t\t\treturn (-ENOMEM);\n\t\t\t}\n\n\t\t\t \n\t\t\tupthru = (mega_passthru __user *)(unsigned long)MBOX(uioc)->xferaddr;\n\n\t\t\t \n\t\t\tif( copy_from_user(pthru, upthru,\n\t\t\t\t\t\tsizeof(mega_passthru)) ) {\n\n\t\t\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t\t\t  sizeof(mega_passthru),\n\t\t\t\t\t\t  pthru, pthru_dma_hndl);\n\n\t\t\t\tfree_local_pdev(pdev);\n\n\t\t\t\treturn (-EFAULT);\n\t\t\t}\n\n\t\t\t \n\t\t\tif( pthru->dataxferlen ) {\n\t\t\t\tdata = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t\t  pthru->dataxferlen,\n\t\t\t\t\t\t\t  &data_dma_hndl,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\t\t\tif( data == NULL ) {\n\t\t\t\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t\t\t\t  sizeof(mega_passthru),\n\t\t\t\t\t\t\t  pthru,\n\t\t\t\t\t\t\t  pthru_dma_hndl);\n\n\t\t\t\t\tfree_local_pdev(pdev);\n\n\t\t\t\t\treturn (-ENOMEM);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tuxferaddr = pthru->dataxferaddr;\n\t\t\t\tpthru->dataxferaddr = data_dma_hndl;\n\t\t\t}\n\n\n\t\t\t \n\t\t\tif( pthru->dataxferlen && (uioc.flags & UIOC_WR) ) {\n\t\t\t\t \n\t\t\t\tif( copy_from_user(data, (char __user *)(unsigned long) uxferaddr,\n\t\t\t\t\t\t\tpthru->dataxferlen) ) {\n\t\t\t\t\trval = (-EFAULT);\n\t\t\t\t\tgoto freemem_and_return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(&mc, 0, sizeof(megacmd_t));\n\n\t\t\tmc.cmd = MEGA_MBOXCMD_PASSTHRU;\n\t\t\tmc.xferaddr = (u32)pthru_dma_hndl;\n\n\t\t\t \n\t\t\tmega_internal_command(adapter, &mc, pthru);\n\n\t\t\trval = mega_n_to_m((void __user *)arg, &mc);\n\n\t\t\tif( rval ) goto freemem_and_return;\n\n\n\t\t\t \n\t\t\tif( pthru->dataxferlen && (uioc.flags & UIOC_RD) ) {\n\t\t\t\tif( copy_to_user((char __user *)(unsigned long) uxferaddr, data,\n\t\t\t\t\t\t\tpthru->dataxferlen) ) {\n\t\t\t\t\trval = (-EFAULT);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (copy_to_user(upthru->reqsensearea,\n\t\t\t\t\tpthru->reqsensearea, 14))\n\t\t\t\trval = -EFAULT;\n\nfreemem_and_return:\n\t\t\tif( pthru->dataxferlen ) {\n\t\t\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t\t\t  pthru->dataxferlen, data,\n\t\t\t\t\t\t  data_dma_hndl);\n\t\t\t}\n\n\t\t\tdma_free_coherent(&pdev->dev, sizeof(mega_passthru),\n\t\t\t\t\t  pthru, pthru_dma_hndl);\n\n\t\t\tfree_local_pdev(pdev);\n\n\t\t\treturn rval;\n\t\t}\n\t\telse {\n\t\t\t \n\n\t\t\t \n\t\t\tif( uioc.xferlen ) {\n\t\t\t\tdata = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t\t  uioc.xferlen,\n\t\t\t\t\t\t\t  &data_dma_hndl,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\t\t\tif( data == NULL ) {\n\t\t\t\t\tfree_local_pdev(pdev);\n\t\t\t\t\treturn (-ENOMEM);\n\t\t\t\t}\n\n\t\t\t\tuxferaddr = MBOX(uioc)->xferaddr;\n\t\t\t}\n\n\t\t\t \n\t\t\tif( uioc.xferlen && (uioc.flags & UIOC_WR) ) {\n\t\t\t\t \n\t\t\t\tif( copy_from_user(data, (char __user *)(unsigned long) uxferaddr,\n\t\t\t\t\t\t\tuioc.xferlen) ) {\n\n\t\t\t\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t\t\t\t  uioc.xferlen, data,\n\t\t\t\t\t\t\t  data_dma_hndl);\n\n\t\t\t\t\tfree_local_pdev(pdev);\n\n\t\t\t\t\treturn (-EFAULT);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemcpy(&mc, MBOX(uioc), sizeof(megacmd_t));\n\n\t\t\tmc.xferaddr = (u32)data_dma_hndl;\n\n\t\t\t \n\t\t\tmega_internal_command(adapter, &mc, NULL);\n\n\t\t\trval = mega_n_to_m((void __user *)arg, &mc);\n\n\t\t\tif( rval ) {\n\t\t\t\tif( uioc.xferlen ) {\n\t\t\t\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t\t\t\t  uioc.xferlen, data,\n\t\t\t\t\t\t\t  data_dma_hndl);\n\t\t\t\t}\n\n\t\t\t\tfree_local_pdev(pdev);\n\n\t\t\t\treturn rval;\n\t\t\t}\n\n\t\t\t \n\t\t\tif( uioc.xferlen && (uioc.flags & UIOC_RD) ) {\n\t\t\t\tif( copy_to_user((char __user *)(unsigned long) uxferaddr, data,\n\t\t\t\t\t\t\tuioc.xferlen) ) {\n\n\t\t\t\t\trval = (-EFAULT);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( uioc.xferlen ) {\n\t\t\t\tdma_free_coherent(&pdev->dev, uioc.xferlen,\n\t\t\t\t\t\t  data, data_dma_hndl);\n\t\t\t}\n\n\t\t\tfree_local_pdev(pdev);\n\n\t\t\treturn rval;\n\t\t}\n\n\tdefault:\n\t\treturn (-EINVAL);\n\t}\n\n\treturn 0;\n}\n\nstatic long\nmegadev_unlocked_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\n\tmutex_lock(&megadev_mutex);\n\tret = megadev_ioctl(filep, cmd, arg);\n\tmutex_unlock(&megadev_mutex);\n\n\treturn ret;\n}\n\n \nstatic int\nmega_m_to_n(void __user *arg, nitioctl_t *uioc)\n{\n\tstruct uioctl_t\tuioc_mimd;\n\tchar\tsignature[8] = {0};\n\tu8\topcode;\n\tu8\tsubopcode;\n\n\n\t \n\n\tif( copy_from_user(signature, arg, 7) )\n\t\treturn (-EFAULT);\n\n\tif( memcmp(signature, \"MEGANIT\", 7) == 0 ) {\n\n\t\t \n\t\treturn -EINVAL;\n#if 0\n\t\tif( copy_from_user(uioc, arg, sizeof(nitioctl_t)) )\n\t\t\treturn (-EFAULT);\n\t\treturn 0;\n#endif\n\t}\n\n\t \n\tif( copy_from_user(&uioc_mimd, arg, sizeof(struct uioctl_t)) )\n\t\treturn (-EFAULT);\n\n\n\t \n\topcode = uioc_mimd.ui.fcs.opcode;\n\tsubopcode = uioc_mimd.ui.fcs.subopcode;\n\n\tswitch (opcode) {\n\tcase 0x82:\n\n\t\tswitch (subopcode) {\n\n\t\tcase MEGAIOC_QDRVRVER:\t \n\t\t\tuioc->opcode = GET_DRIVER_VER;\n\t\t\tuioc->uioc_uaddr = uioc_mimd.data;\n\t\t\tbreak;\n\n\t\tcase MEGAIOC_QNADAP:\t \n\t\t\tuioc->opcode = GET_N_ADAP;\n\t\t\tuioc->uioc_uaddr = uioc_mimd.data;\n\t\t\tbreak;\n\n\t\tcase MEGAIOC_QADAPINFO:\t \n\t\t\tuioc->opcode = GET_ADAP_INFO;\n\t\t\tuioc->adapno = uioc_mimd.ui.fcs.adapno;\n\t\t\tuioc->uioc_uaddr = uioc_mimd.data;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn(-EINVAL);\n\t\t}\n\n\t\tbreak;\n\n\n\tcase 0x81:\n\n\t\tuioc->opcode = MBOX_CMD;\n\t\tuioc->adapno = uioc_mimd.ui.fcs.adapno;\n\n\t\tmemcpy(uioc->uioc_rmbox, uioc_mimd.mbox, 18);\n\n\t\tuioc->xferlen = uioc_mimd.ui.fcs.length;\n\n\t\tif( uioc_mimd.outlen ) uioc->flags = UIOC_RD;\n\t\tif( uioc_mimd.inlen ) uioc->flags |= UIOC_WR;\n\n\t\tbreak;\n\n\tcase 0x80:\n\n\t\tuioc->opcode = MBOX_CMD;\n\t\tuioc->adapno = uioc_mimd.ui.fcs.adapno;\n\n\t\tmemcpy(uioc->uioc_rmbox, uioc_mimd.mbox, 18);\n\n\t\t \n\t\tuioc->xferlen = uioc_mimd.outlen > uioc_mimd.inlen ?\n\t\t\tuioc_mimd.outlen : uioc_mimd.inlen;\n\n\t\tif( uioc_mimd.outlen ) uioc->flags = UIOC_RD;\n\t\tif( uioc_mimd.inlen ) uioc->flags |= UIOC_WR;\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn (-EINVAL);\n\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmega_n_to_m(void __user *arg, megacmd_t *mc)\n{\n\tnitioctl_t\t__user *uiocp;\n\tmegacmd_t\t__user *umc;\n\tmega_passthru\t__user *upthru;\n\tstruct uioctl_t\t__user *uioc_mimd;\n\tchar\tsignature[8] = {0};\n\n\t \n\tif( copy_from_user(signature, arg, 7) )\n\t\treturn -EFAULT;\n\n\tif( memcmp(signature, \"MEGANIT\", 7) == 0 ) {\n\n\t\tuiocp = arg;\n\n\t\tif( put_user(mc->status, (u8 __user *)&MBOX_P(uiocp)->status) )\n\t\t\treturn (-EFAULT);\n\n\t\tif( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {\n\n\t\t\tumc = MBOX_P(uiocp);\n\n\t\t\tif (get_user(upthru, (mega_passthru __user * __user *)&umc->xferaddr))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif( put_user(mc->status, (u8 __user *)&upthru->scsistatus))\n\t\t\t\treturn (-EFAULT);\n\t\t}\n\t}\n\telse {\n\t\tuioc_mimd = arg;\n\n\t\tif( put_user(mc->status, (u8 __user *)&uioc_mimd->mbox[17]) )\n\t\t\treturn (-EFAULT);\n\n\t\tif( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {\n\n\t\t\tumc = (megacmd_t __user *)uioc_mimd->mbox;\n\n\t\t\tif (get_user(upthru, (mega_passthru __user * __user *)&umc->xferaddr))\n\t\t\t\treturn (-EFAULT);\n\n\t\t\tif( put_user(mc->status, (u8 __user *)&upthru->scsistatus) )\n\t\t\t\treturn (-EFAULT);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n \n\n \nstatic int\nmega_is_bios_enabled(adapter_t *adapter)\n{\n\tstruct mbox_out mbox;\n\tunsigned char\t*raw_mbox = (u8 *)&mbox;\n\n\tmemset(&mbox, 0, sizeof(mbox));\n\n\tmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\n\n\tmbox.xferaddr = (u32)adapter->buf_dma_handle;\n\n\traw_mbox[0] = IS_BIOS_ENABLED;\n\traw_mbox[2] = GET_BIOS;\n\n\tissue_scb_block(adapter, raw_mbox);\n\n\treturn *(char *)adapter->mega_buffer;\n}\n\n\n \nstatic void\nmega_enum_raid_scsi(adapter_t *adapter)\n{\n\tstruct mbox_out mbox;\n\tunsigned char\t*raw_mbox = (u8 *)&mbox;\n\tint i;\n\n\tmemset(&mbox, 0, sizeof(mbox));\n\n\t \n\traw_mbox[0] = CHNL_CLASS;\n\traw_mbox[2] = GET_CHNL_CLASS;\n\n\tmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\n\n\tmbox.xferaddr = (u32)adapter->buf_dma_handle;\n\n\t \n\tadapter->mega_ch_class = 0xFF;\n\n\tif(!issue_scb_block(adapter, raw_mbox)) {\n\t\tadapter->mega_ch_class = *((char *)adapter->mega_buffer);\n\n\t}\n\n\tfor( i = 0; i < adapter->product_info.nchannels; i++ ) { \n\t\tif( (adapter->mega_ch_class >> i) & 0x01 ) {\n\t\t\tdev_info(&adapter->dev->dev, \"channel[%d] is raid\\n\",\n\t\t\t\t\ti);\n\t\t}\n\t\telse {\n\t\t\tdev_info(&adapter->dev->dev, \"channel[%d] is scsi\\n\",\n\t\t\t\t\ti);\n\t\t}\n\t}\n\n\treturn;\n}\n\n\n \nstatic void\nmega_get_boot_drv(adapter_t *adapter)\n{\n\tstruct private_bios_data\t*prv_bios_data;\n\tstruct mbox_out mbox;\n\tunsigned char\t*raw_mbox = (u8 *)&mbox;\n\tu16\tcksum = 0;\n\tu8\t*cksum_p;\n\tu8\tboot_pdrv;\n\tint\ti;\n\n\tmemset(&mbox, 0, sizeof(mbox));\n\n\traw_mbox[0] = BIOS_PVT_DATA;\n\traw_mbox[2] = GET_BIOS_PVT_DATA;\n\n\tmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\n\n\tmbox.xferaddr = (u32)adapter->buf_dma_handle;\n\n\tadapter->boot_ldrv_enabled = 0;\n\tadapter->boot_ldrv = 0;\n\n\tadapter->boot_pdrv_enabled = 0;\n\tadapter->boot_pdrv_ch = 0;\n\tadapter->boot_pdrv_tgt = 0;\n\n\tif(issue_scb_block(adapter, raw_mbox) == 0) {\n\t\tprv_bios_data =\n\t\t\t(struct private_bios_data *)adapter->mega_buffer;\n\n\t\tcksum = 0;\n\t\tcksum_p = (char *)prv_bios_data;\n\t\tfor (i = 0; i < 14; i++ ) {\n\t\t\tcksum += (u16)(*cksum_p++);\n\t\t}\n\n\t\tif (prv_bios_data->cksum == (u16)(0-cksum) ) {\n\n\t\t\t \n\t\t\tif( prv_bios_data->boot_drv & 0x80 ) {\n\t\t\t\tadapter->boot_pdrv_enabled = 1;\n\t\t\t\tboot_pdrv = prv_bios_data->boot_drv & 0x7F;\n\t\t\t\tadapter->boot_pdrv_ch = boot_pdrv / 16;\n\t\t\t\tadapter->boot_pdrv_tgt = boot_pdrv % 16;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadapter->boot_ldrv_enabled = 1;\n\t\t\t\tadapter->boot_ldrv = prv_bios_data->boot_drv;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n \nstatic int\nmega_support_random_del(adapter_t *adapter)\n{\n\tstruct mbox_out mbox;\n\tunsigned char\t*raw_mbox = (u8 *)&mbox;\n\tint rval;\n\n\tmemset(&mbox, 0, sizeof(mbox));\n\n\t \n\traw_mbox[0] = FC_DEL_LOGDRV;\n\traw_mbox[2] = OP_SUP_DEL_LOGDRV;\n\n\trval = issue_scb_block(adapter, raw_mbox);\n\n\treturn !rval;\n}\n\n\n \nstatic int\nmega_support_ext_cdb(adapter_t *adapter)\n{\n\tstruct mbox_out mbox;\n\tunsigned char\t*raw_mbox = (u8 *)&mbox;\n\tint rval;\n\n\tmemset(&mbox, 0, sizeof(mbox));\n\t \n\traw_mbox[0] = 0xA4;\n\traw_mbox[2] = 0x16;\n\n\trval = issue_scb_block(adapter, raw_mbox);\n\n\treturn !rval;\n}\n\n\n \nstatic int\nmega_del_logdrv(adapter_t *adapter, int logdrv)\n{\n\tunsigned long flags;\n\tscb_t *scb;\n\tint rval;\n\n\t \n\tatomic_set(&adapter->quiescent, 1);\n\n\t \n\twhile (atomic_read(&adapter->pend_cmds) > 0 ||\n\t       !list_empty(&adapter->pending_list))\n\t\tmsleep(1000);\t \n\n\trval = mega_do_del_logdrv(adapter, logdrv);\n\n\tspin_lock_irqsave(&adapter->lock, flags);\n\n\t \n\tif (adapter->read_ldidmap) {\n\t\tstruct list_head *pos;\n\t\tlist_for_each(pos, &adapter->pending_list) {\n\t\t\tscb = list_entry(pos, scb_t, list);\n\t\t\tif (scb->pthru->logdrv < 0x80 )\n\t\t\t\tscb->pthru->logdrv += 0x80;\n\t\t}\n\t}\n\n\tatomic_set(&adapter->quiescent, 0);\n\n\tmega_runpendq(adapter);\n\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n\n\treturn rval;\n}\n\n\nstatic int\nmega_do_del_logdrv(adapter_t *adapter, int logdrv)\n{\n\tmegacmd_t\tmc;\n\tint\trval;\n\n\tmemset( &mc, 0, sizeof(megacmd_t));\n\n\tmc.cmd = FC_DEL_LOGDRV;\n\tmc.opcode = OP_DEL_LOGDRV;\n\tmc.subopcode = logdrv;\n\n\trval = mega_internal_command(adapter, &mc, NULL);\n\n\t \n\tif(rval) {\n\t\tdev_warn(&adapter->dev->dev, \"Delete LD-%d failed\", logdrv);\n\t\treturn rval;\n\t}\n\n\t \n\tadapter->read_ldidmap = 1;\n\n\treturn rval;\n}\n\n\n \nstatic void\nmega_get_max_sgl(adapter_t *adapter)\n{\n\tstruct mbox_out\tmbox;\n\tunsigned char\t*raw_mbox = (u8 *)&mbox;\n\n\tmemset(&mbox, 0, sizeof(mbox));\n\n\tmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\n\n\tmbox.xferaddr = (u32)adapter->buf_dma_handle;\n\n\traw_mbox[0] = MAIN_MISC_OPCODE;\n\traw_mbox[2] = GET_MAX_SG_SUPPORT;\n\n\n\tif( issue_scb_block(adapter, raw_mbox) ) {\n\t\t \n\t\tadapter->sglen = MIN_SGLIST;\n\t}\n\telse {\n\t\tadapter->sglen = *((char *)adapter->mega_buffer);\n\n\t\t \n\t\tif ( adapter->sglen > MAX_SGLIST )\n\t\t\tadapter->sglen = MAX_SGLIST;\n\t}\n\n\treturn;\n}\n\n\n \nstatic int\nmega_support_cluster(adapter_t *adapter)\n{\n\tstruct mbox_out\tmbox;\n\tunsigned char\t*raw_mbox = (u8 *)&mbox;\n\n\tmemset(&mbox, 0, sizeof(mbox));\n\n\tmemset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);\n\n\tmbox.xferaddr = (u32)adapter->buf_dma_handle;\n\n\t \n\traw_mbox[0] = MEGA_GET_TARGET_ID;\n\n\tif( issue_scb_block(adapter, raw_mbox) == 0 ) {\n\n\t\t \n\t\tadapter->this_id = *(u32 *)adapter->mega_buffer;\n\t\tadapter->host->this_id = adapter->this_id;\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\n \nstatic int\nmega_adapinq(adapter_t *adapter, dma_addr_t dma_handle)\n{\n\tmegacmd_t\tmc;\n\n\tmemset(&mc, 0, sizeof(megacmd_t));\n\n\tif( adapter->flag & BOARD_40LD ) {\n\t\tmc.cmd = FC_NEW_CONFIG;\n\t\tmc.opcode = NC_SUBOP_ENQUIRY3;\n\t\tmc.subopcode = ENQ3_GET_SOLICITED_FULL;\n\t}\n\telse {\n\t\tmc.cmd = MEGA_MBOXCMD_ADPEXTINQ;\n\t}\n\n\tmc.xferaddr = (u32)dma_handle;\n\n\tif ( mega_internal_command(adapter, &mc, NULL) != 0 ) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int\nmega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,\n\t\tdma_addr_t buf_dma_handle)\n{\n\tmega_passthru\t*pthru;\n\tdma_addr_t\tpthru_dma_handle;\n\tmegacmd_t\tmc;\n\tint\t\trval;\n\tstruct pci_dev\t*pdev;\n\n\n\t \n\tif( make_local_pdev(adapter, &pdev) != 0 ) return -1;\n\n\tpthru = dma_alloc_coherent(&pdev->dev, sizeof(mega_passthru),\n\t\t\t\t   &pthru_dma_handle, GFP_KERNEL);\n\n\tif( pthru == NULL ) {\n\t\tfree_local_pdev(pdev);\n\t\treturn -1;\n\t}\n\n\tpthru->timeout = 2;\n\tpthru->ars = 1;\n\tpthru->reqsenselen = 14;\n\tpthru->islogical = 0;\n\n\tpthru->channel = (adapter->flag & BOARD_40LD) ? 0 : ch;\n\n\tpthru->target = (adapter->flag & BOARD_40LD) ? (ch << 4)|tgt : tgt;\n\n\tpthru->cdblen = 6;\n\n\tpthru->cdb[0] = INQUIRY;\n\tpthru->cdb[1] = 0;\n\tpthru->cdb[2] = 0;\n\tpthru->cdb[3] = 0;\n\tpthru->cdb[4] = 255;\n\tpthru->cdb[5] = 0;\n\n\n\tpthru->dataxferaddr = (u32)buf_dma_handle;\n\tpthru->dataxferlen = 256;\n\n\tmemset(&mc, 0, sizeof(megacmd_t));\n\n\tmc.cmd = MEGA_MBOXCMD_PASSTHRU;\n\tmc.xferaddr = (u32)pthru_dma_handle;\n\n\trval = mega_internal_command(adapter, &mc, pthru);\n\n\tdma_free_coherent(&pdev->dev, sizeof(mega_passthru), pthru,\n\t\t\t  pthru_dma_handle);\n\n\tfree_local_pdev(pdev);\n\n\treturn rval;\n}\n#endif\n\n \nstatic int\nmega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)\n{\n\tunsigned long flags;\n\tscb_t\t*scb;\n\tint\trval;\n\n\t \n\tmutex_lock(&adapter->int_mtx);\n\n\tscb = &adapter->int_scb;\n\tmemset(scb, 0, sizeof(scb_t));\n\n\tscb->idx = CMDID_INT_CMDS;\n\tscb->state |= SCB_ACTIVE | SCB_PENDQ;\n\n\tmemcpy(scb->raw_mbox, mc, sizeof(megacmd_t));\n\n\t \n\tif (mc->cmd == MEGA_MBOXCMD_PASSTHRU)\n\t\tscb->pthru = pthru;\n\n\tspin_lock_irqsave(&adapter->lock, flags);\n\tlist_add_tail(&scb->list, &adapter->pending_list);\n\t \n\tif (atomic_read(&adapter->quiescent) == 0)\n\t\tmega_runpendq(adapter);\n\tspin_unlock_irqrestore(&adapter->lock, flags);\n\n\twait_for_completion(&adapter->int_waitq);\n\n\tmc->status = rval = adapter->int_status;\n\n\t \n\tif (rval && trace_level) {\n\t\tdev_info(&adapter->dev->dev, \"cmd [%x, %x, %x] status:[%x]\\n\",\n\t\t\tmc->cmd, mc->opcode, mc->subopcode, rval);\n\t}\n\n\tmutex_unlock(&adapter->int_mtx);\n\treturn rval;\n}\n\nstatic const struct scsi_host_template megaraid_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"MegaRAID\",\n\t.proc_name\t\t\t= \"megaraid_legacy\",\n\t.info\t\t\t\t= megaraid_info,\n\t.queuecommand\t\t\t= megaraid_queue,\t\n\t.bios_param\t\t\t= megaraid_biosparam,\n\t.max_sectors\t\t\t= MAX_SECTORS_PER_IO,\n\t.can_queue\t\t\t= MAX_COMMANDS,\n\t.this_id\t\t\t= DEFAULT_INITIATOR_ID,\n\t.sg_tablesize\t\t\t= MAX_SGLIST,\n\t.cmd_per_lun\t\t\t= DEF_CMD_PER_LUN,\n\t.eh_abort_handler\t\t= megaraid_abort,\n\t.eh_device_reset_handler\t= megaraid_reset,\n\t.eh_bus_reset_handler\t\t= megaraid_reset,\n\t.eh_host_reset_handler\t\t= megaraid_reset,\n\t.no_write_same\t\t\t= 1,\n\t.cmd_size\t\t\t= sizeof(struct megaraid_cmd_priv),\n};\n\nstatic int\nmegaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct Scsi_Host *host;\n\tadapter_t *adapter;\n\tunsigned long mega_baseport, tbase, flag = 0;\n\tu16 subsysid, subsysvid;\n\tu8 pci_bus, pci_dev_func;\n\tint irq, i, j;\n\tint error = -ENODEV;\n\n\tif (hba_count >= MAX_CONTROLLERS)\n\t\tgoto out;\n\n\tif (pci_enable_device(pdev))\n\t\tgoto out;\n\tpci_set_master(pdev);\n\n\tpci_bus = pdev->bus->number;\n\tpci_dev_func = pdev->devfn;\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL) {\n\t\tu16 magic;\n\t\t \n\t\tif (pdev->subsystem_vendor == PCI_VENDOR_ID_COMPAQ &&\n\t\t    pdev->subsystem_device == 0xC000)\n\t\t\tgoto out_disable_device;\n\t\t \n\t\tpci_read_config_word(pdev, PCI_CONF_AMISIG, &magic);\n\t\tif (magic != HBA_SIGNATURE_471 && magic != HBA_SIGNATURE)\n\t\t\tgoto out_disable_device;\n\t\t \n\t}\n\n\t \n\tif (id->driver_data & BOARD_64BIT)\n\t\tflag |= BOARD_64BIT;\n\telse {\n\t\tu32 magic64;\n\n\t\tpci_read_config_dword(pdev, PCI_CONF_AMISIG64, &magic64);\n\t\tif (magic64 == HBA_SIGNATURE_64BIT)\n\t\t\tflag |= BOARD_64BIT;\n\t}\n\n\tsubsysvid = pdev->subsystem_vendor;\n\tsubsysid = pdev->subsystem_device;\n\n\tdev_notice(&pdev->dev, \"found 0x%4.04x:0x%4.04x\\n\",\n\t\tid->vendor, id->device);\n\n\t \n\tmega_baseport = pci_resource_start(pdev, 0);\n\tirq = pdev->irq;\n\n\ttbase = mega_baseport;\n\tif (pci_resource_flags(pdev, 0) & IORESOURCE_MEM) {\n\t\tflag |= BOARD_MEMMAP;\n\n\t\tif (!request_mem_region(mega_baseport, 128, \"megaraid\")) {\n\t\t\tdev_warn(&pdev->dev, \"mem region busy!\\n\");\n\t\t\tgoto out_disable_device;\n\t\t}\n\n\t\tmega_baseport = (unsigned long)ioremap(mega_baseport, 128);\n\t\tif (!mega_baseport) {\n\t\t\tdev_warn(&pdev->dev, \"could not map hba memory\\n\");\n\t\t\tgoto out_release_region;\n\t\t}\n\t} else {\n\t\tflag |= BOARD_IOMAP;\n\t\tmega_baseport += 0x10;\n\n\t\tif (!request_region(mega_baseport, 16, \"megaraid\"))\n\t\t\tgoto out_disable_device;\n\t}\n\n\t \n\thost = scsi_host_alloc(&megaraid_template, sizeof(adapter_t));\n\tif (!host)\n\t\tgoto out_iounmap;\n\n\tadapter = (adapter_t *)host->hostdata;\n\tmemset(adapter, 0, sizeof(adapter_t));\n\n\tdev_notice(&pdev->dev,\n\t\t\"scsi%d:Found MegaRAID controller at 0x%lx, IRQ:%d\\n\",\n\t\thost->host_no, mega_baseport, irq);\n\n\tadapter->base = mega_baseport;\n\tif (flag & BOARD_MEMMAP)\n\t\tadapter->mmio_base = (void __iomem *) mega_baseport;\n\n\tINIT_LIST_HEAD(&adapter->free_list);\n\tINIT_LIST_HEAD(&adapter->pending_list);\n\tINIT_LIST_HEAD(&adapter->completed_list);\n\n\tadapter->flag = flag;\n\tspin_lock_init(&adapter->lock);\n\n\thost->cmd_per_lun = max_cmd_per_lun;\n\thost->max_sectors = max_sectors_per_io;\n\n\tadapter->dev = pdev;\n\tadapter->host = host;\n\n\tadapter->host->irq = irq;\n\n\tif (flag & BOARD_MEMMAP)\n\t\tadapter->host->base = tbase;\n\telse {\n\t\tadapter->host->io_port = tbase;\n\t\tadapter->host->n_io_port = 16;\n\t}\n\n\tadapter->host->unique_id = (pci_bus << 8) | pci_dev_func;\n\n\t \n\tadapter->mega_buffer = dma_alloc_coherent(&adapter->dev->dev,\n\t\t\t\t\t\t  MEGA_BUFFER_SIZE,\n\t\t\t\t\t\t  &adapter->buf_dma_handle,\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!adapter->mega_buffer) {\n\t\tdev_warn(&pdev->dev, \"out of RAM\\n\");\n\t\tgoto out_host_put;\n\t}\n\n\tadapter->scb_list = kmalloc_array(MAX_COMMANDS, sizeof(scb_t),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!adapter->scb_list) {\n\t\tdev_warn(&pdev->dev, \"out of RAM\\n\");\n\t\tgoto out_free_cmd_buffer;\n\t}\n\n\tif (request_irq(irq, (adapter->flag & BOARD_MEMMAP) ?\n\t\t\t\tmegaraid_isr_memmapped : megaraid_isr_iomapped,\n\t\t\t\t\tIRQF_SHARED, \"megaraid\", adapter)) {\n\t\tdev_warn(&pdev->dev, \"Couldn't register IRQ %d!\\n\", irq);\n\t\tgoto out_free_scb_list;\n\t}\n\n\tif (mega_setup_mailbox(adapter))\n\t\tgoto out_free_irq;\n\n\tif (mega_query_adapter(adapter))\n\t\tgoto out_free_mbox;\n\n\t \n\tif ((subsysid == 0x1111) && (subsysvid == 0x1111)) {\n\t\t \n\t\tif (!strcmp(adapter->fw_version, \"3.00\") ||\n\t\t\t\t!strcmp(adapter->fw_version, \"3.01\")) {\n\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"Your card is a Dell PERC \"\n\t\t\t\t\"2/SC RAID controller with \"\n\t\t\t\t\"firmware\\nmegaraid: 3.00 or 3.01.  \"\n\t\t\t\t\"This driver is known to have \"\n\t\t\t\t\"corruption issues\\nmegaraid: with \"\n\t\t\t\t\"those firmware versions on this \"\n\t\t\t\t\"specific card.  In order\\nmegaraid: \"\n\t\t\t\t\"to protect your data, please upgrade \"\n\t\t\t\t\"your firmware to version\\nmegaraid: \"\n\t\t\t\t\"3.10 or later, available from the \"\n\t\t\t\t\"Dell Technical Support web\\n\"\n\t\t\t\t\"megaraid: site at\\nhttp:\n\t\t\t\t\"dell.com/us/en/filelib/download/\"\n\t\t\t\t\"index.asp?fileid=2940\\n\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/*\n\t * If we have a HP 1M(0x60E7)/2M(0x60E8) controller with\n\t * firmware H.01.07, H.01.08, and H.01.09 disable 64 bit\n\t * support, since this firmware cannot handle 64 bit\n\t * addressing\n\t */\n\tif ((subsysvid == PCI_VENDOR_ID_HP) &&\n\t    ((subsysid == 0x60E7) || (subsysid == 0x60E8))) {\n\t\t/*\n\t\t * which firmware\n\t\t */\n\t\tif (!strcmp(adapter->fw_version, \"H01.07\") ||\n\t\t    !strcmp(adapter->fw_version, \"H01.08\") ||\n\t\t    !strcmp(adapter->fw_version, \"H01.09\") ) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"Firmware H.01.07, \"\n\t\t\t\t\"H.01.08, and H.01.09 on 1M/2M \"\n\t\t\t\t\"controllers\\n\"\n\t\t\t\t\"do not support 64 bit \"\n\t\t\t\t\"addressing.\\nDISABLING \"\n\t\t\t\t\"64 bit support.\\n\");\n\t\t\tadapter->flag &= ~BOARD_64BIT;\n\t\t}\n\t}\n\n\tif (mega_is_bios_enabled(adapter))\n\t\tmega_hbas[hba_count].is_bios_enabled = 1;\n\tmega_hbas[hba_count].hostdata_addr = adapter;\n\n\t/*\n\t * Find out which channel is raid and which is scsi. This is\n\t * for ROMB support.\n\t */\n\tmega_enum_raid_scsi(adapter);\n\n\t/*\n\t * Find out if a logical drive is set as the boot drive. If\n\t * there is one, will make that as the first logical drive.\n\t * ROMB: Do we have to boot from a physical drive. Then all\n\t * the physical drives would appear before the logical disks.\n\t * Else, all the physical drives would be exported to the mid\n\t * layer after logical drives.\n\t */\n\tmega_get_boot_drv(adapter);\n\n\tif (adapter->boot_pdrv_enabled) {\n\t\tj = adapter->product_info.nchannels;\n\t\tfor( i = 0; i < j; i++ )\n\t\t\tadapter->logdrv_chan[i] = 0;\n\t\tfor( i = j; i < NVIRT_CHAN + j; i++ )\n\t\t\tadapter->logdrv_chan[i] = 1;\n\t} else {\n\t\tfor (i = 0; i < NVIRT_CHAN; i++)\n\t\t\tadapter->logdrv_chan[i] = 1;\n\t\tfor (i = NVIRT_CHAN; i < MAX_CHANNELS+NVIRT_CHAN; i++)\n\t\t\tadapter->logdrv_chan[i] = 0;\n\t\tadapter->mega_ch_class <<= NVIRT_CHAN;\n\t}\n\n\t/*\n\t * Do we support random deletion and addition of logical\n\t * drives\n\t */\n\tadapter->read_ldidmap = 0;\t/* set it after first logdrv\n\t\t\t\t\t\t   delete cmd */\n\tadapter->support_random_del = mega_support_random_del(adapter);\n\n\t/* Initialize SCBs */\n\tif (mega_init_scb(adapter))\n\t\tgoto out_free_mbox;\n\n\t/*\n\t * Reset the pending commands counter\n\t */\n\tatomic_set(&adapter->pend_cmds, 0);\n\n\t/*\n\t * Reset the adapter quiescent flag\n\t */\n\tatomic_set(&adapter->quiescent, 0);\n\n\thba_soft_state[hba_count] = adapter;\n\n\t/*\n\t * Fill in the structure which needs to be passed back to the\n\t * application when it does an ioctl() for controller related\n\t * information.\n\t */\n\ti = hba_count;\n\n\tmcontroller[i].base = mega_baseport;\n\tmcontroller[i].irq = irq;\n\tmcontroller[i].numldrv = adapter->numldrv;\n\tmcontroller[i].pcibus = pci_bus;\n\tmcontroller[i].pcidev = id->device;\n\tmcontroller[i].pcifun = PCI_FUNC (pci_dev_func);\n\tmcontroller[i].pciid = -1;\n\tmcontroller[i].pcivendor = id->vendor;\n\tmcontroller[i].pcislot = PCI_SLOT(pci_dev_func);\n\tmcontroller[i].uid = (pci_bus << 8) | pci_dev_func;\n\n\n\t/* Set the Mode of addressing to 64 bit if we can */\n\tif ((adapter->flag & BOARD_64BIT) && (sizeof(dma_addr_t) == 8)) {\n\t\tdma_set_mask(&pdev->dev, DMA_BIT_MASK(64));\n\t\tadapter->has_64bit_addr = 1;\n\t} else  {\n\t\tdma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tadapter->has_64bit_addr = 0;\n\t}\n\t\t\n\tmutex_init(&adapter->int_mtx);\n\tinit_completion(&adapter->int_waitq);\n\n\tadapter->this_id = DEFAULT_INITIATOR_ID;\n\tadapter->host->this_id = DEFAULT_INITIATOR_ID;\n\n#if MEGA_HAVE_CLUSTERING\n\t/*\n\t * Is cluster support enabled on this controller\n\t * Note: In a cluster the HBAs ( the initiators ) will have\n\t * different target IDs and we cannot assume it to be 7. Call\n\t * to mega_support_cluster() will get the target ids also if\n\t * the cluster support is available\n\t */\n\tadapter->has_cluster = mega_support_cluster(adapter);\n\tif (adapter->has_cluster) {\n\t\tdev_notice(&pdev->dev,\n\t\t\t\"Cluster driver, initiator id:%d\\n\",\n\t\t\tadapter->this_id);\n\t}\n#endif\n\n\tpci_set_drvdata(pdev, host);\n\n\tmega_create_proc_entry(hba_count, mega_proc_dir_entry);\n\n\terror = scsi_add_host(host, &pdev->dev);\n\tif (error)\n\t\tgoto out_free_mbox;\n\n\tscsi_scan_host(host);\n\thba_count++;\n\treturn 0;\n\n out_free_mbox:\n\tdma_free_coherent(&adapter->dev->dev, sizeof(mbox64_t),\n\t\t\t  adapter->una_mbox64, adapter->una_mbox64_dma);\n out_free_irq:\n\tfree_irq(adapter->host->irq, adapter);\n out_free_scb_list:\n\tkfree(adapter->scb_list);\n out_free_cmd_buffer:\n\tdma_free_coherent(&adapter->dev->dev, MEGA_BUFFER_SIZE,\n\t\t\t  adapter->mega_buffer, adapter->buf_dma_handle);\n out_host_put:\n\tscsi_host_put(host);\n out_iounmap:\n\tif (flag & BOARD_MEMMAP)\n\t\tiounmap((void *)mega_baseport);\n out_release_region:\n\tif (flag & BOARD_MEMMAP)\n\t\trelease_mem_region(tbase, 128);\n\telse\n\t\trelease_region(mega_baseport, 16);\n out_disable_device:\n\tpci_disable_device(pdev);\n out:\n\treturn error;\n}\n\nstatic void\n__megaraid_shutdown(adapter_t *adapter)\n{\n\tu_char\traw_mbox[sizeof(struct mbox_out)];\n\tmbox_t\t*mbox = (mbox_t *)raw_mbox;\n\tint\ti;\n\n\t/* Flush adapter cache */\n\tmemset(&mbox->m_out, 0, sizeof(raw_mbox));\n\traw_mbox[0] = FLUSH_ADAPTER;\n\n\tfree_irq(adapter->host->irq, adapter);\n\n\t/* Issue a blocking (interrupts disabled) command to the card */\n\tissue_scb_block(adapter, raw_mbox);\n\n\t/* Flush disks cache */\n\tmemset(&mbox->m_out, 0, sizeof(raw_mbox));\n\traw_mbox[0] = FLUSH_SYSTEM;\n\n\t/* Issue a blocking (interrupts disabled) command to the card */\n\tissue_scb_block(adapter, raw_mbox);\n\t\n\tif (atomic_read(&adapter->pend_cmds) > 0)\n\t\tdev_warn(&adapter->dev->dev, \"pending commands!!\\n\");\n\n\t/*\n\t * Have a delibrate delay to make sure all the caches are\n\t * actually flushed.\n\t */\n\tfor (i = 0; i <= 10; i++)\n\t\tmdelay(1000);\n}\n\nstatic void\nmegaraid_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tadapter_t *adapter = (adapter_t *)host->hostdata;\n\tchar buf[12] = { 0 };\n\n\tscsi_remove_host(host);\n\n\t__megaraid_shutdown(adapter);\n\n\t/* Free our resources */\n\tif (adapter->flag & BOARD_MEMMAP) {\n\t\tiounmap((void *)adapter->base);\n\t\trelease_mem_region(adapter->host->base, 128);\n\t} else\n\t\trelease_region(adapter->base, 16);\n\n\tmega_free_sgl(adapter);\n\n\tsprintf(buf, \"hba%d\", adapter->host->host_no);\n\tremove_proc_subtree(buf, mega_proc_dir_entry);\n\n\tdma_free_coherent(&adapter->dev->dev, MEGA_BUFFER_SIZE,\n\t\t\t  adapter->mega_buffer, adapter->buf_dma_handle);\n\tkfree(adapter->scb_list);\n\tdma_free_coherent(&adapter->dev->dev, sizeof(mbox64_t),\n\t\t\t  adapter->una_mbox64, adapter->una_mbox64_dma);\n\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n\n\thba_count--;\n}\n\nstatic void\nmegaraid_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tadapter_t *adapter = (adapter_t *)host->hostdata;\n\n\t__megaraid_shutdown(adapter);\n}\n\nstatic struct pci_device_id megaraid_pci_tbl[] = {\n\t{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID2,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_AMI_MEGARAID3,\n\t\tPCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, megaraid_pci_tbl);\n\nstatic struct pci_driver megaraid_pci_driver = {\n\t.name\t\t= \"megaraid_legacy\",\n\t.id_table\t= megaraid_pci_tbl,\n\t.probe\t\t= megaraid_probe_one,\n\t.remove\t\t= megaraid_remove_one,\n\t.shutdown\t= megaraid_shutdown,\n};\n\nstatic int __init megaraid_init(void)\n{\n\tint error;\n\n\tif ((max_cmd_per_lun <= 0) || (max_cmd_per_lun > MAX_CMD_PER_LUN))\n\t\tmax_cmd_per_lun = MAX_CMD_PER_LUN;\n\tif (max_mbox_busy_wait > MBOX_BUSY_WAIT)\n\t\tmax_mbox_busy_wait = MBOX_BUSY_WAIT;\n\n#ifdef CONFIG_PROC_FS\n\tmega_proc_dir_entry = proc_mkdir(\"megaraid\", NULL);\n\tif (!mega_proc_dir_entry) {\n\t\tprintk(KERN_WARNING\n\t\t\t\t\"megaraid: failed to create megaraid root\\n\");\n\t}\n#endif\n\terror = pci_register_driver(&megaraid_pci_driver);\n\tif (error) {\n#ifdef CONFIG_PROC_FS\n\t\tremove_proc_entry(\"megaraid\", NULL);\n#endif\n\t\treturn error;\n\t}\n\n\t/*\n\t * Register the driver as a character device, for applications\n\t * to access it for ioctls.\n\t * First argument (major) to register_chrdev implies a dynamic\n\t * major number allocation.\n\t */\n\tmajor = register_chrdev(0, \"megadev_legacy\", &megadev_fops);\n\tif (major < 0) {\n\t\tprintk(KERN_WARNING\n\t\t\t\t\"megaraid: failed to register char device\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit megaraid_exit(void)\n{\n\t/*\n\t * Unregister the character device interface to the driver.\n\t */\n\tunregister_chrdev(major, \"megadev_legacy\");\n\n\tpci_unregister_driver(&megaraid_pci_driver);\n\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"megaraid\", NULL);\n#endif\n}\n\nmodule_init(megaraid_init);\nmodule_exit(megaraid_exit);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}