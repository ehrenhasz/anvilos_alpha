{
  "module_name": "scsi_logging.c",
  "hash_id": "5f18f7aec995b74b01ae6a671fdf53081f095c4debb40c3e195029034173f9db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_logging.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/atomic.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dbg.h>\n\nstatic char *scsi_log_reserve_buffer(size_t *len)\n{\n\t*len = 128;\n\treturn kmalloc(*len, GFP_ATOMIC);\n}\n\nstatic void scsi_log_release_buffer(char *bufptr)\n{\n\tkfree(bufptr);\n}\n\nstatic inline const char *scmd_name(const struct scsi_cmnd *scmd)\n{\n\tstruct request *rq = scsi_cmd_to_rq((struct scsi_cmnd *)scmd);\n\n\tif (!rq->q || !rq->q->disk)\n\t\treturn NULL;\n\treturn rq->q->disk->disk_name;\n}\n\nstatic size_t sdev_format_header(char *logbuf, size_t logbuf_len,\n\t\t\t\t const char *name, int tag)\n{\n\tsize_t off = 0;\n\n\tif (name)\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \"[%s] \", name);\n\n\tif (WARN_ON(off >= logbuf_len))\n\t\treturn off;\n\n\tif (tag >= 0)\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \"tag#%d \", tag);\n\treturn off;\n}\n\nvoid sdev_prefix_printk(const char *level, const struct scsi_device *sdev,\n\t\t\tconst char *name, const char *fmt, ...)\n{\n\tva_list args;\n\tchar *logbuf;\n\tsize_t off = 0, logbuf_len;\n\n\tif (!sdev)\n\t\treturn;\n\n\tlogbuf = scsi_log_reserve_buffer(&logbuf_len);\n\tif (!logbuf)\n\t\treturn;\n\n\tif (name)\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \"[%s] \", name);\n\tif (!WARN_ON(off >= logbuf_len)) {\n\t\tva_start(args, fmt);\n\t\toff += vscnprintf(logbuf + off, logbuf_len - off, fmt, args);\n\t\tva_end(args);\n\t}\n\tdev_printk(level, &sdev->sdev_gendev, \"%s\", logbuf);\n\tscsi_log_release_buffer(logbuf);\n}\nEXPORT_SYMBOL(sdev_prefix_printk);\n\nvoid scmd_printk(const char *level, const struct scsi_cmnd *scmd,\n\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar *logbuf;\n\tsize_t off = 0, logbuf_len;\n\n\tif (!scmd)\n\t\treturn;\n\n\tlogbuf = scsi_log_reserve_buffer(&logbuf_len);\n\tif (!logbuf)\n\t\treturn;\n\toff = sdev_format_header(logbuf, logbuf_len, scmd_name(scmd),\n\t\t\t\t scsi_cmd_to_rq((struct scsi_cmnd *)scmd)->tag);\n\tif (off < logbuf_len) {\n\t\tva_start(args, fmt);\n\t\toff += vscnprintf(logbuf + off, logbuf_len - off, fmt, args);\n\t\tva_end(args);\n\t}\n\tdev_printk(level, &scmd->device->sdev_gendev, \"%s\", logbuf);\n\tscsi_log_release_buffer(logbuf);\n}\nEXPORT_SYMBOL(scmd_printk);\n\nstatic size_t scsi_format_opcode_name(char *buffer, size_t buf_len,\n\t\t\t\t      const unsigned char *cdbp)\n{\n\tint sa, cdb0;\n\tconst char *cdb_name = NULL, *sa_name = NULL;\n\tsize_t off;\n\n\tcdb0 = cdbp[0];\n\tif (cdb0 == VARIABLE_LENGTH_CMD) {\n\t\tint len = scsi_varlen_cdb_length(cdbp);\n\n\t\tif (len < 10) {\n\t\t\toff = scnprintf(buffer, buf_len,\n\t\t\t\t\t\"short variable length command, len=%d\",\n\t\t\t\t\tlen);\n\t\t\treturn off;\n\t\t}\n\t\tsa = (cdbp[8] << 8) + cdbp[9];\n\t} else\n\t\tsa = cdbp[1] & 0x1f;\n\n\tif (!scsi_opcode_sa_name(cdb0, sa, &cdb_name, &sa_name)) {\n\t\tif (cdb_name)\n\t\t\toff = scnprintf(buffer, buf_len, \"%s\", cdb_name);\n\t\telse {\n\t\t\toff = scnprintf(buffer, buf_len, \"opcode=0x%x\", cdb0);\n\t\t\tif (WARN_ON(off >= buf_len))\n\t\t\t\treturn off;\n\t\t\tif (cdb0 >= VENDOR_SPECIFIC_CDB)\n\t\t\t\toff += scnprintf(buffer + off, buf_len - off,\n\t\t\t\t\t\t \" (vendor)\");\n\t\t\telse if (cdb0 >= 0x60 && cdb0 < 0x7e)\n\t\t\t\toff += scnprintf(buffer + off, buf_len - off,\n\t\t\t\t\t\t \" (reserved)\");\n\t\t}\n\t} else {\n\t\tif (sa_name)\n\t\t\toff = scnprintf(buffer, buf_len, \"%s\", sa_name);\n\t\telse if (cdb_name)\n\t\t\toff = scnprintf(buffer, buf_len, \"%s, sa=0x%x\",\n\t\t\t\t\tcdb_name, sa);\n\t\telse\n\t\t\toff = scnprintf(buffer, buf_len,\n\t\t\t\t\t\"opcode=0x%x, sa=0x%x\", cdb0, sa);\n\t}\n\tWARN_ON(off >= buf_len);\n\treturn off;\n}\n\nsize_t __scsi_format_command(char *logbuf, size_t logbuf_len,\n\t\t\t     const unsigned char *cdb, size_t cdb_len)\n{\n\tint len, k;\n\tsize_t off;\n\n\toff = scsi_format_opcode_name(logbuf, logbuf_len, cdb);\n\tif (off >= logbuf_len)\n\t\treturn off;\n\tlen = scsi_command_size(cdb);\n\tif (cdb_len < len)\n\t\tlen = cdb_len;\n\t \n\tfor (k = 0; k < len; ++k) {\n\t\tif (off > logbuf_len - 3)\n\t\t\tbreak;\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \" %02x\", cdb[k]);\n\t}\n\treturn off;\n}\nEXPORT_SYMBOL(__scsi_format_command);\n\nvoid scsi_print_command(struct scsi_cmnd *cmd)\n{\n\tint k;\n\tchar *logbuf;\n\tsize_t off, logbuf_len;\n\n\tlogbuf = scsi_log_reserve_buffer(&logbuf_len);\n\tif (!logbuf)\n\t\treturn;\n\n\toff = sdev_format_header(logbuf, logbuf_len,\n\t\t\t\t scmd_name(cmd), scsi_cmd_to_rq(cmd)->tag);\n\tif (off >= logbuf_len)\n\t\tgoto out_printk;\n\toff += scnprintf(logbuf + off, logbuf_len - off, \"CDB: \");\n\tif (WARN_ON(off >= logbuf_len))\n\t\tgoto out_printk;\n\n\toff += scsi_format_opcode_name(logbuf + off, logbuf_len - off,\n\t\t\t\t       cmd->cmnd);\n\tif (off >= logbuf_len)\n\t\tgoto out_printk;\n\n\t \n\tif (cmd->cmd_len > 16) {\n\t\t \n\t\toff += scnprintf(logbuf + off, logbuf_len - off, \"\\n\");\n\t\tdev_printk(KERN_INFO, &cmd->device->sdev_gendev, \"%s\", logbuf);\n\t\tfor (k = 0; k < cmd->cmd_len; k += 16) {\n\t\t\tsize_t linelen = min(cmd->cmd_len - k, 16);\n\n\t\t\toff = sdev_format_header(logbuf, logbuf_len,\n\t\t\t\t\t\t scmd_name(cmd),\n\t\t\t\t\t\t scsi_cmd_to_rq(cmd)->tag);\n\t\t\tif (!WARN_ON(off > logbuf_len - 58)) {\n\t\t\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t\t\t \"CDB[%02x]: \", k);\n\t\t\t\thex_dump_to_buffer(&cmd->cmnd[k], linelen,\n\t\t\t\t\t\t   16, 1, logbuf + off,\n\t\t\t\t\t\t   logbuf_len - off, false);\n\t\t\t}\n\t\t\tdev_printk(KERN_INFO, &cmd->device->sdev_gendev, \"%s\",\n\t\t\t\t   logbuf);\n\t\t}\n\t\tgoto out;\n\t}\n\tif (!WARN_ON(off > logbuf_len - 49)) {\n\t\toff += scnprintf(logbuf + off, logbuf_len - off, \" \");\n\t\thex_dump_to_buffer(cmd->cmnd, cmd->cmd_len, 16, 1,\n\t\t\t\t   logbuf + off, logbuf_len - off,\n\t\t\t\t   false);\n\t}\nout_printk:\n\tdev_printk(KERN_INFO, &cmd->device->sdev_gendev, \"%s\", logbuf);\nout:\n\tscsi_log_release_buffer(logbuf);\n}\nEXPORT_SYMBOL(scsi_print_command);\n\nstatic size_t\nscsi_format_extd_sense(char *buffer, size_t buf_len,\n\t\t       unsigned char asc, unsigned char ascq)\n{\n\tsize_t off = 0;\n\tconst char *extd_sense_fmt = NULL;\n\tconst char *extd_sense_str = scsi_extd_sense_format(asc, ascq,\n\t\t\t\t\t\t\t    &extd_sense_fmt);\n\n\tif (extd_sense_str) {\n\t\toff = scnprintf(buffer, buf_len, \"Add. Sense: %s\",\n\t\t\t\textd_sense_str);\n\t\tif (extd_sense_fmt)\n\t\t\toff += scnprintf(buffer + off, buf_len - off,\n\t\t\t\t\t \"(%s%x)\", extd_sense_fmt, ascq);\n\t} else {\n\t\tif (asc >= 0x80)\n\t\t\toff = scnprintf(buffer, buf_len, \"<<vendor>>\");\n\t\toff += scnprintf(buffer + off, buf_len - off,\n\t\t\t\t \"ASC=0x%x \", asc);\n\t\tif (ascq >= 0x80)\n\t\t\toff += scnprintf(buffer + off, buf_len - off,\n\t\t\t\t\t \"<<vendor>>\");\n\t\toff += scnprintf(buffer + off, buf_len - off,\n\t\t\t\t \"ASCQ=0x%x \", ascq);\n\t}\n\treturn off;\n}\n\nstatic size_t\nscsi_format_sense_hdr(char *buffer, size_t buf_len,\n\t\t      const struct scsi_sense_hdr *sshdr)\n{\n\tconst char *sense_txt;\n\tsize_t off;\n\n\toff = scnprintf(buffer, buf_len, \"Sense Key : \");\n\tsense_txt = scsi_sense_key_string(sshdr->sense_key);\n\tif (sense_txt)\n\t\toff += scnprintf(buffer + off, buf_len - off,\n\t\t\t\t \"%s \", sense_txt);\n\telse\n\t\toff += scnprintf(buffer + off, buf_len - off,\n\t\t\t\t \"0x%x \", sshdr->sense_key);\n\toff += scnprintf(buffer + off, buf_len - off,\n\t\tscsi_sense_is_deferred(sshdr) ? \"[deferred] \" : \"[current] \");\n\n\tif (sshdr->response_code >= 0x72)\n\t\toff += scnprintf(buffer + off, buf_len - off, \"[descriptor] \");\n\treturn off;\n}\n\nstatic void\nscsi_log_dump_sense(const struct scsi_device *sdev, const char *name, int tag,\n\t\t    const unsigned char *sense_buffer, int sense_len)\n{\n\tchar *logbuf;\n\tsize_t logbuf_len;\n\tint i;\n\n\tlogbuf = scsi_log_reserve_buffer(&logbuf_len);\n\tif (!logbuf)\n\t\treturn;\n\n\tfor (i = 0; i < sense_len; i += 16) {\n\t\tint len = min(sense_len - i, 16);\n\t\tsize_t off;\n\n\t\toff = sdev_format_header(logbuf, logbuf_len,\n\t\t\t\t\t name, tag);\n\t\thex_dump_to_buffer(&sense_buffer[i], len, 16, 1,\n\t\t\t\t   logbuf + off, logbuf_len - off,\n\t\t\t\t   false);\n\t\tdev_printk(KERN_INFO, &sdev->sdev_gendev, \"%s\", logbuf);\n\t}\n\tscsi_log_release_buffer(logbuf);\n}\n\nstatic void\nscsi_log_print_sense_hdr(const struct scsi_device *sdev, const char *name,\n\t\t\t int tag, const struct scsi_sense_hdr *sshdr)\n{\n\tchar *logbuf;\n\tsize_t off, logbuf_len;\n\n\tlogbuf = scsi_log_reserve_buffer(&logbuf_len);\n\tif (!logbuf)\n\t\treturn;\n\toff = sdev_format_header(logbuf, logbuf_len, name, tag);\n\toff += scsi_format_sense_hdr(logbuf + off, logbuf_len - off, sshdr);\n\tdev_printk(KERN_INFO, &sdev->sdev_gendev, \"%s\", logbuf);\n\tscsi_log_release_buffer(logbuf);\n\n\tlogbuf = scsi_log_reserve_buffer(&logbuf_len);\n\tif (!logbuf)\n\t\treturn;\n\toff = sdev_format_header(logbuf, logbuf_len, name, tag);\n\toff += scsi_format_extd_sense(logbuf + off, logbuf_len - off,\n\t\t\t\t      sshdr->asc, sshdr->ascq);\n\tdev_printk(KERN_INFO, &sdev->sdev_gendev, \"%s\", logbuf);\n\tscsi_log_release_buffer(logbuf);\n}\n\nstatic void\nscsi_log_print_sense(const struct scsi_device *sdev, const char *name, int tag,\n\t\t     const unsigned char *sense_buffer, int sense_len)\n{\n\tstruct scsi_sense_hdr sshdr;\n\n\tif (scsi_normalize_sense(sense_buffer, sense_len, &sshdr))\n\t\tscsi_log_print_sense_hdr(sdev, name, tag, &sshdr);\n\telse\n\t\tscsi_log_dump_sense(sdev, name, tag, sense_buffer, sense_len);\n}\n\n \nvoid\nscsi_print_sense_hdr(const struct scsi_device *sdev, const char *name,\n\t\t     const struct scsi_sense_hdr *sshdr)\n{\n\tscsi_log_print_sense_hdr(sdev, name, -1, sshdr);\n}\nEXPORT_SYMBOL(scsi_print_sense_hdr);\n\n \nvoid __scsi_print_sense(const struct scsi_device *sdev, const char *name,\n\t\t\tconst unsigned char *sense_buffer, int sense_len)\n{\n\tscsi_log_print_sense(sdev, name, -1, sense_buffer, sense_len);\n}\nEXPORT_SYMBOL(__scsi_print_sense);\n\n \nvoid scsi_print_sense(const struct scsi_cmnd *cmd)\n{\n\tscsi_log_print_sense(cmd->device, scmd_name(cmd),\n\t\t\t     scsi_cmd_to_rq((struct scsi_cmnd *)cmd)->tag,\n\t\t\t     cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE);\n}\nEXPORT_SYMBOL(scsi_print_sense);\n\nvoid scsi_print_result(const struct scsi_cmnd *cmd, const char *msg,\n\t\t       int disposition)\n{\n\tchar *logbuf;\n\tsize_t off, logbuf_len;\n\tconst char *mlret_string = scsi_mlreturn_string(disposition);\n\tconst char *hb_string = scsi_hostbyte_string(cmd->result);\n\tunsigned long cmd_age = (jiffies - cmd->jiffies_at_alloc) / HZ;\n\n\tlogbuf = scsi_log_reserve_buffer(&logbuf_len);\n\tif (!logbuf)\n\t\treturn;\n\n\toff = sdev_format_header(logbuf, logbuf_len, scmd_name(cmd),\n\t\t\t\t scsi_cmd_to_rq((struct scsi_cmnd *)cmd)->tag);\n\n\tif (off >= logbuf_len)\n\t\tgoto out_printk;\n\n\tif (msg) {\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \"%s: \", msg);\n\t\tif (WARN_ON(off >= logbuf_len))\n\t\t\tgoto out_printk;\n\t}\n\tif (mlret_string)\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \"%s \", mlret_string);\n\telse\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \"UNKNOWN(0x%02x) \", disposition);\n\tif (WARN_ON(off >= logbuf_len))\n\t\tgoto out_printk;\n\n\toff += scnprintf(logbuf + off, logbuf_len - off, \"Result: \");\n\tif (WARN_ON(off >= logbuf_len))\n\t\tgoto out_printk;\n\n\tif (hb_string)\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \"hostbyte=%s \", hb_string);\n\telse\n\t\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t\t \"hostbyte=0x%02x \", host_byte(cmd->result));\n\tif (WARN_ON(off >= logbuf_len))\n\t\tgoto out_printk;\n\n\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t \"driverbyte=DRIVER_OK \");\n\n\toff += scnprintf(logbuf + off, logbuf_len - off,\n\t\t\t \"cmd_age=%lus\", cmd_age);\n\nout_printk:\n\tdev_printk(KERN_INFO, &cmd->device->sdev_gendev, \"%s\", logbuf);\n\tscsi_log_release_buffer(logbuf);\n}\nEXPORT_SYMBOL(scsi_print_result);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}