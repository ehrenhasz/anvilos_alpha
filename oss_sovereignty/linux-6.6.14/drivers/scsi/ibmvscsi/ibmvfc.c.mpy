{
  "module_name": "ibmvfc.c",
  "hash_id": "79409780b9315070dbc1702ce10169d55c5202901eb7e1f42555f9ab0547afb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ibmvscsi/ibmvfc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/stringify.h>\n#include <linux/bsg-lib.h>\n#include <asm/firmware.h>\n#include <asm/irq.h>\n#include <asm/vio.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/scsi_bsg_fc.h>\n#include \"ibmvfc.h\"\n\nstatic unsigned int init_timeout = IBMVFC_INIT_TIMEOUT;\nstatic unsigned int default_timeout = IBMVFC_DEFAULT_TIMEOUT;\nstatic u64 max_lun = IBMVFC_MAX_LUN;\nstatic unsigned int max_targets = IBMVFC_MAX_TARGETS;\nstatic unsigned int max_requests = IBMVFC_MAX_REQUESTS_DEFAULT;\nstatic unsigned int disc_threads = IBMVFC_MAX_DISC_THREADS;\nstatic unsigned int ibmvfc_debug = IBMVFC_DEBUG;\nstatic unsigned int log_level = IBMVFC_DEFAULT_LOG_LEVEL;\nstatic unsigned int cls3_error = IBMVFC_CLS3_ERROR;\nstatic unsigned int mq_enabled = IBMVFC_MQ;\nstatic unsigned int nr_scsi_hw_queues = IBMVFC_SCSI_HW_QUEUES;\nstatic unsigned int nr_scsi_channels = IBMVFC_SCSI_CHANNELS;\nstatic unsigned int mig_channels_only = IBMVFC_MIG_NO_SUB_TO_CRQ;\nstatic unsigned int mig_no_less_channels = IBMVFC_MIG_NO_N_TO_M;\n\nstatic LIST_HEAD(ibmvfc_head);\nstatic DEFINE_SPINLOCK(ibmvfc_driver_lock);\nstatic struct scsi_transport_template *ibmvfc_transport_template;\n\nMODULE_DESCRIPTION(\"IBM Virtual Fibre Channel Driver\");\nMODULE_AUTHOR(\"Brian King <brking@linux.vnet.ibm.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(IBMVFC_DRIVER_VERSION);\n\nmodule_param_named(mq, mq_enabled, uint, S_IRUGO);\nMODULE_PARM_DESC(mq, \"Enable multiqueue support. \"\n\t\t \"[Default=\" __stringify(IBMVFC_MQ) \"]\");\nmodule_param_named(scsi_host_queues, nr_scsi_hw_queues, uint, S_IRUGO);\nMODULE_PARM_DESC(scsi_host_queues, \"Number of SCSI Host submission queues. \"\n\t\t \"[Default=\" __stringify(IBMVFC_SCSI_HW_QUEUES) \"]\");\nmodule_param_named(scsi_hw_channels, nr_scsi_channels, uint, S_IRUGO);\nMODULE_PARM_DESC(scsi_hw_channels, \"Number of hw scsi channels to request. \"\n\t\t \"[Default=\" __stringify(IBMVFC_SCSI_CHANNELS) \"]\");\nmodule_param_named(mig_channels_only, mig_channels_only, uint, S_IRUGO);\nMODULE_PARM_DESC(mig_channels_only, \"Prevent migration to non-channelized system. \"\n\t\t \"[Default=\" __stringify(IBMVFC_MIG_NO_SUB_TO_CRQ) \"]\");\nmodule_param_named(mig_no_less_channels, mig_no_less_channels, uint, S_IRUGO);\nMODULE_PARM_DESC(mig_no_less_channels, \"Prevent migration to system with less channels. \"\n\t\t \"[Default=\" __stringify(IBMVFC_MIG_NO_N_TO_M) \"]\");\n\nmodule_param_named(init_timeout, init_timeout, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(init_timeout, \"Initialization timeout in seconds. \"\n\t\t \"[Default=\" __stringify(IBMVFC_INIT_TIMEOUT) \"]\");\nmodule_param_named(default_timeout, default_timeout, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(default_timeout,\n\t\t \"Default timeout in seconds for initialization and EH commands. \"\n\t\t \"[Default=\" __stringify(IBMVFC_DEFAULT_TIMEOUT) \"]\");\nmodule_param_named(max_requests, max_requests, uint, S_IRUGO);\nMODULE_PARM_DESC(max_requests, \"Maximum requests for this adapter. \"\n\t\t \"[Default=\" __stringify(IBMVFC_MAX_REQUESTS_DEFAULT) \"]\");\nmodule_param_named(max_lun, max_lun, ullong, S_IRUGO);\nMODULE_PARM_DESC(max_lun, \"Maximum allowed LUN. \"\n\t\t \"[Default=\" __stringify(IBMVFC_MAX_LUN) \"]\");\nmodule_param_named(max_targets, max_targets, uint, S_IRUGO);\nMODULE_PARM_DESC(max_targets, \"Maximum allowed targets. \"\n\t\t \"[Default=\" __stringify(IBMVFC_MAX_TARGETS) \"]\");\nmodule_param_named(disc_threads, disc_threads, uint, S_IRUGO);\nMODULE_PARM_DESC(disc_threads, \"Number of device discovery threads to use. \"\n\t\t \"[Default=\" __stringify(IBMVFC_MAX_DISC_THREADS) \"]\");\nmodule_param_named(debug, ibmvfc_debug, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Enable driver debug information. \"\n\t\t \"[Default=\" __stringify(IBMVFC_DEBUG) \"]\");\nmodule_param_named(log_level, log_level, uint, 0);\nMODULE_PARM_DESC(log_level, \"Set to 0 - 4 for increasing verbosity of device driver. \"\n\t\t \"[Default=\" __stringify(IBMVFC_DEFAULT_LOG_LEVEL) \"]\");\nmodule_param_named(cls3_error, cls3_error, uint, 0);\nMODULE_PARM_DESC(cls3_error, \"Enable FC Class 3 Error Recovery. \"\n\t\t \"[Default=\" __stringify(IBMVFC_CLS3_ERROR) \"]\");\n\nstatic const struct {\n\tu16 status;\n\tu16 error;\n\tu8 result;\n\tu8 retry;\n\tint log;\n\tchar *name;\n} cmd_status [] = {\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_UNABLE_TO_ESTABLISH, DID_ERROR, 1, 1, \"unable to establish\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_XPORT_FAULT, DID_OK, 1, 0, \"transport fault\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_CMD_TIMEOUT, DID_TIME_OUT, 1, 1, \"command timeout\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_ENETDOWN, DID_TRANSPORT_DISRUPTED, 1, 1, \"network down\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_HW_FAILURE, DID_ERROR, 1, 1, \"hardware failure\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_LINK_DOWN_ERR, DID_REQUEUE, 0, 0, \"link down\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_LINK_DEAD_ERR, DID_ERROR, 0, 0, \"link dead\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_UNABLE_TO_REGISTER, DID_ERROR, 1, 1, \"unable to register\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_XPORT_BUSY, DID_BUS_BUSY, 1, 0, \"transport busy\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_XPORT_DEAD, DID_ERROR, 0, 1, \"transport dead\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_CONFIG_ERROR, DID_ERROR, 1, 1, \"configuration error\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_NAME_SERVER_FAIL, DID_ERROR, 1, 1, \"name server failure\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_LINK_HALTED, DID_REQUEUE, 1, 0, \"link halted\" },\n\t{ IBMVFC_FABRIC_MAPPED, IBMVFC_XPORT_GENERAL, DID_OK, 1, 0, \"general transport error\" },\n\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_CRQ_FAILURE, DID_REQUEUE, 1, 1, \"CRQ failure\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_SW_FAILURE, DID_ERROR, 0, 1, \"software failure\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_INVALID_PARAMETER, DID_ERROR, 0, 1, \"invalid parameter\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_MISSING_PARAMETER, DID_ERROR, 0, 1, \"missing parameter\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_HOST_IO_BUS, DID_ERROR, 1, 1, \"host I/O bus failure\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_TRANS_CANCELLED, DID_ERROR, 0, 1, \"transaction cancelled\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_TRANS_CANCELLED_IMPLICIT, DID_ERROR, 0, 1, \"transaction cancelled implicit\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_INSUFFICIENT_RESOURCE, DID_REQUEUE, 1, 1, \"insufficient resources\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_PLOGI_REQUIRED, DID_ERROR, 0, 1, \"port login required\" },\n\t{ IBMVFC_VIOS_FAILURE, IBMVFC_COMMAND_FAILED, DID_ERROR, 1, 1, \"command failed\" },\n\n\t{ IBMVFC_FC_FAILURE, IBMVFC_INVALID_ELS_CMD_CODE, DID_ERROR, 0, 1, \"invalid ELS command code\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_INVALID_VERSION, DID_ERROR, 0, 1, \"invalid version level\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_LOGICAL_ERROR, DID_ERROR, 1, 1, \"logical error\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_INVALID_CT_IU_SIZE, DID_ERROR, 0, 1, \"invalid CT_IU size\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_LOGICAL_BUSY, DID_REQUEUE, 1, 0, \"logical busy\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_PROTOCOL_ERROR, DID_ERROR, 1, 1, \"protocol error\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_UNABLE_TO_PERFORM_REQ, DID_ERROR, 1, 1, \"unable to perform request\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_CMD_NOT_SUPPORTED, DID_ERROR, 0, 0, \"command not supported\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_SERVER_NOT_AVAIL, DID_ERROR, 0, 1, \"server not available\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_CMD_IN_PROGRESS, DID_ERROR, 0, 1, \"command already in progress\" },\n\t{ IBMVFC_FC_FAILURE, IBMVFC_VENDOR_SPECIFIC, DID_ERROR, 1, 1, \"vendor specific\" },\n\n\t{ IBMVFC_FC_SCSI_ERROR, 0, DID_OK, 1, 0, \"SCSI error\" },\n\t{ IBMVFC_FC_SCSI_ERROR, IBMVFC_COMMAND_FAILED, DID_ERROR, 0, 1, \"PRLI to device failed.\" },\n};\n\nstatic void ibmvfc_npiv_login(struct ibmvfc_host *);\nstatic void ibmvfc_tgt_send_prli(struct ibmvfc_target *);\nstatic void ibmvfc_tgt_send_plogi(struct ibmvfc_target *);\nstatic void ibmvfc_tgt_query_target(struct ibmvfc_target *);\nstatic void ibmvfc_npiv_logout(struct ibmvfc_host *);\nstatic void ibmvfc_tgt_implicit_logout_and_del(struct ibmvfc_target *);\nstatic void ibmvfc_tgt_move_login(struct ibmvfc_target *);\n\nstatic void ibmvfc_dereg_sub_crqs(struct ibmvfc_host *);\nstatic void ibmvfc_reg_sub_crqs(struct ibmvfc_host *);\n\nstatic const char *unknown_error = \"unknown error\";\n\nstatic long h_reg_sub_crq(unsigned long unit_address, unsigned long ioba,\n\t\t\t  unsigned long length, unsigned long *cookie,\n\t\t\t  unsigned long *irq)\n{\n\tunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\n\tlong rc;\n\n\trc = plpar_hcall(H_REG_SUB_CRQ, retbuf, unit_address, ioba, length);\n\t*cookie = retbuf[0];\n\t*irq = retbuf[1];\n\n\treturn rc;\n}\n\nstatic int ibmvfc_check_caps(struct ibmvfc_host *vhost, unsigned long cap_flags)\n{\n\tu64 host_caps = be64_to_cpu(vhost->login_buf->resp.capabilities);\n\n\treturn (host_caps & cap_flags) ? 1 : 0;\n}\n\nstatic struct ibmvfc_fcp_cmd_iu *ibmvfc_get_fcp_iu(struct ibmvfc_host *vhost,\n\t\t\t\t\t\t   struct ibmvfc_cmd *vfc_cmd)\n{\n\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN))\n\t\treturn &vfc_cmd->v2.iu;\n\telse\n\t\treturn &vfc_cmd->v1.iu;\n}\n\nstatic struct ibmvfc_fcp_rsp *ibmvfc_get_fcp_rsp(struct ibmvfc_host *vhost,\n\t\t\t\t\t\t struct ibmvfc_cmd *vfc_cmd)\n{\n\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN))\n\t\treturn &vfc_cmd->v2.rsp;\n\telse\n\t\treturn &vfc_cmd->v1.rsp;\n}\n\n#ifdef CONFIG_SCSI_IBMVFC_TRACE\n \nstatic void ibmvfc_trc_start(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_cmd *vfc_cmd = &evt->iu.cmd;\n\tstruct ibmvfc_mad_common *mad = &evt->iu.mad_common;\n\tstruct ibmvfc_fcp_cmd_iu *iu = ibmvfc_get_fcp_iu(vhost, vfc_cmd);\n\tstruct ibmvfc_trace_entry *entry;\n\tint index = atomic_inc_return(&vhost->trace_index) & IBMVFC_TRACE_INDEX_MASK;\n\n\tentry = &vhost->trace[index];\n\tentry->evt = evt;\n\tentry->time = jiffies;\n\tentry->fmt = evt->crq.format;\n\tentry->type = IBMVFC_TRC_START;\n\n\tswitch (entry->fmt) {\n\tcase IBMVFC_CMD_FORMAT:\n\t\tentry->op_code = iu->cdb[0];\n\t\tentry->scsi_id = be64_to_cpu(vfc_cmd->tgt_scsi_id);\n\t\tentry->lun = scsilun_to_int(&iu->lun);\n\t\tentry->tmf_flags = iu->tmf_flags;\n\t\tentry->u.start.xfer_len = be32_to_cpu(iu->xfer_len);\n\t\tbreak;\n\tcase IBMVFC_MAD_FORMAT:\n\t\tentry->op_code = be32_to_cpu(mad->opcode);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void ibmvfc_trc_end(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_cmd *vfc_cmd = &evt->xfer_iu->cmd;\n\tstruct ibmvfc_mad_common *mad = &evt->xfer_iu->mad_common;\n\tstruct ibmvfc_fcp_cmd_iu *iu = ibmvfc_get_fcp_iu(vhost, vfc_cmd);\n\tstruct ibmvfc_fcp_rsp *rsp = ibmvfc_get_fcp_rsp(vhost, vfc_cmd);\n\tstruct ibmvfc_trace_entry *entry;\n\tint index = atomic_inc_return(&vhost->trace_index) & IBMVFC_TRACE_INDEX_MASK;\n\n\tentry = &vhost->trace[index];\n\tentry->evt = evt;\n\tentry->time = jiffies;\n\tentry->fmt = evt->crq.format;\n\tentry->type = IBMVFC_TRC_END;\n\n\tswitch (entry->fmt) {\n\tcase IBMVFC_CMD_FORMAT:\n\t\tentry->op_code = iu->cdb[0];\n\t\tentry->scsi_id = be64_to_cpu(vfc_cmd->tgt_scsi_id);\n\t\tentry->lun = scsilun_to_int(&iu->lun);\n\t\tentry->tmf_flags = iu->tmf_flags;\n\t\tentry->u.end.status = be16_to_cpu(vfc_cmd->status);\n\t\tentry->u.end.error = be16_to_cpu(vfc_cmd->error);\n\t\tentry->u.end.fcp_rsp_flags = rsp->flags;\n\t\tentry->u.end.rsp_code = rsp->data.info.rsp_code;\n\t\tentry->u.end.scsi_status = rsp->scsi_status;\n\t\tbreak;\n\tcase IBMVFC_MAD_FORMAT:\n\t\tentry->op_code = be32_to_cpu(mad->opcode);\n\t\tentry->u.end.status = be16_to_cpu(mad->status);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\n\t}\n}\n\n#else\n#define ibmvfc_trc_start(evt) do { } while (0)\n#define ibmvfc_trc_end(evt) do { } while (0)\n#endif\n\n \nstatic int ibmvfc_get_err_index(u16 status, u16 error)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cmd_status); i++)\n\t\tif ((cmd_status[i].status & status) == cmd_status[i].status &&\n\t\t    cmd_status[i].error == error)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\n \nstatic const char *ibmvfc_get_cmd_error(u16 status, u16 error)\n{\n\tint rc = ibmvfc_get_err_index(status, error);\n\tif (rc >= 0)\n\t\treturn cmd_status[rc].name;\n\treturn unknown_error;\n}\n\n \nstatic int ibmvfc_get_err_result(struct ibmvfc_host *vhost, struct ibmvfc_cmd *vfc_cmd)\n{\n\tint err;\n\tstruct ibmvfc_fcp_rsp *rsp = ibmvfc_get_fcp_rsp(vhost, vfc_cmd);\n\tint fc_rsp_len = be32_to_cpu(rsp->fcp_rsp_len);\n\n\tif ((rsp->flags & FCP_RSP_LEN_VALID) &&\n\t    ((fc_rsp_len && fc_rsp_len != 4 && fc_rsp_len != 8) ||\n\t     rsp->data.info.rsp_code))\n\t\treturn DID_ERROR << 16;\n\n\terr = ibmvfc_get_err_index(be16_to_cpu(vfc_cmd->status), be16_to_cpu(vfc_cmd->error));\n\tif (err >= 0)\n\t\treturn rsp->scsi_status | (cmd_status[err].result << 16);\n\treturn rsp->scsi_status | (DID_ERROR << 16);\n}\n\n \nstatic int ibmvfc_retry_cmd(u16 status, u16 error)\n{\n\tint rc = ibmvfc_get_err_index(status, error);\n\n\tif (rc >= 0)\n\t\treturn cmd_status[rc].retry;\n\treturn 1;\n}\n\nstatic const char *unknown_fc_explain = \"unknown fc explain\";\n\nstatic const struct {\n\tu16 fc_explain;\n\tchar *name;\n} ls_explain [] = {\n\t{ 0x00, \"no additional explanation\" },\n\t{ 0x01, \"service parameter error - options\" },\n\t{ 0x03, \"service parameter error - initiator control\" },\n\t{ 0x05, \"service parameter error - recipient control\" },\n\t{ 0x07, \"service parameter error - received data field size\" },\n\t{ 0x09, \"service parameter error - concurrent seq\" },\n\t{ 0x0B, \"service parameter error - credit\" },\n\t{ 0x0D, \"invalid N_Port/F_Port_Name\" },\n\t{ 0x0E, \"invalid node/Fabric Name\" },\n\t{ 0x0F, \"invalid common service parameters\" },\n\t{ 0x11, \"invalid association header\" },\n\t{ 0x13, \"association header required\" },\n\t{ 0x15, \"invalid originator S_ID\" },\n\t{ 0x17, \"invalid OX_ID-RX-ID combination\" },\n\t{ 0x19, \"command (request) already in progress\" },\n\t{ 0x1E, \"N_Port Login requested\" },\n\t{ 0x1F, \"Invalid N_Port_ID\" },\n};\n\nstatic const struct {\n\tu16 fc_explain;\n\tchar *name;\n} gs_explain [] = {\n\t{ 0x00, \"no additional explanation\" },\n\t{ 0x01, \"port identifier not registered\" },\n\t{ 0x02, \"port name not registered\" },\n\t{ 0x03, \"node name not registered\" },\n\t{ 0x04, \"class of service not registered\" },\n\t{ 0x06, \"initial process associator not registered\" },\n\t{ 0x07, \"FC-4 TYPEs not registered\" },\n\t{ 0x08, \"symbolic port name not registered\" },\n\t{ 0x09, \"symbolic node name not registered\" },\n\t{ 0x0A, \"port type not registered\" },\n\t{ 0xF0, \"authorization exception\" },\n\t{ 0xF1, \"authentication exception\" },\n\t{ 0xF2, \"data base full\" },\n\t{ 0xF3, \"data base empty\" },\n\t{ 0xF4, \"processing request\" },\n\t{ 0xF5, \"unable to verify connection\" },\n\t{ 0xF6, \"devices not in a common zone\" },\n};\n\n \nstatic const char *ibmvfc_get_ls_explain(u16 status)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ls_explain); i++)\n\t\tif (ls_explain[i].fc_explain == status)\n\t\t\treturn ls_explain[i].name;\n\n\treturn unknown_fc_explain;\n}\n\n \nstatic const char *ibmvfc_get_gs_explain(u16 status)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(gs_explain); i++)\n\t\tif (gs_explain[i].fc_explain == status)\n\t\t\treturn gs_explain[i].name;\n\n\treturn unknown_fc_explain;\n}\n\nstatic const struct {\n\tenum ibmvfc_fc_type fc_type;\n\tchar *name;\n} fc_type [] = {\n\t{ IBMVFC_FABRIC_REJECT, \"fabric reject\" },\n\t{ IBMVFC_PORT_REJECT, \"port reject\" },\n\t{ IBMVFC_LS_REJECT, \"ELS reject\" },\n\t{ IBMVFC_FABRIC_BUSY, \"fabric busy\" },\n\t{ IBMVFC_PORT_BUSY, \"port busy\" },\n\t{ IBMVFC_BASIC_REJECT, \"basic reject\" },\n};\n\nstatic const char *unknown_fc_type = \"unknown fc type\";\n\n \nstatic const char *ibmvfc_get_fc_type(u16 status)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fc_type); i++)\n\t\tif (fc_type[i].fc_type == status)\n\t\t\treturn fc_type[i].name;\n\n\treturn unknown_fc_type;\n}\n\n \nstatic int ibmvfc_set_tgt_action(struct ibmvfc_target *tgt,\n\t\t\t\t  enum ibmvfc_target_action action)\n{\n\tint rc = -EINVAL;\n\n\tswitch (tgt->action) {\n\tcase IBMVFC_TGT_ACTION_LOGOUT_RPORT:\n\t\tif (action == IBMVFC_TGT_ACTION_LOGOUT_RPORT_WAIT ||\n\t\t    action == IBMVFC_TGT_ACTION_DEL_RPORT) {\n\t\t\ttgt->action = action;\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_TGT_ACTION_LOGOUT_RPORT_WAIT:\n\t\tif (action == IBMVFC_TGT_ACTION_DEL_RPORT ||\n\t\t    action == IBMVFC_TGT_ACTION_DEL_AND_LOGOUT_RPORT) {\n\t\t\ttgt->action = action;\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_TGT_ACTION_LOGOUT_DELETED_RPORT:\n\t\tif (action == IBMVFC_TGT_ACTION_LOGOUT_RPORT) {\n\t\t\ttgt->action = action;\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_TGT_ACTION_DEL_AND_LOGOUT_RPORT:\n\t\tif (action == IBMVFC_TGT_ACTION_LOGOUT_DELETED_RPORT) {\n\t\t\ttgt->action = action;\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_TGT_ACTION_DEL_RPORT:\n\t\tif (action == IBMVFC_TGT_ACTION_DELETED_RPORT) {\n\t\t\ttgt->action = action;\n\t\t\trc = 0;\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_TGT_ACTION_DELETED_RPORT:\n\t\tbreak;\n\tdefault:\n\t\ttgt->action = action;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\tif (action >= IBMVFC_TGT_ACTION_LOGOUT_RPORT)\n\t\ttgt->add_rport = 0;\n\n\treturn rc;\n}\n\n \nstatic int ibmvfc_set_host_state(struct ibmvfc_host *vhost,\n\t\t\t\t  enum ibmvfc_host_state state)\n{\n\tint rc = 0;\n\n\tswitch (vhost->state) {\n\tcase IBMVFC_HOST_OFFLINE:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tvhost->state = state;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic void ibmvfc_set_host_action(struct ibmvfc_host *vhost,\n\t\t\t\t   enum ibmvfc_host_action action)\n{\n\tswitch (action) {\n\tcase IBMVFC_HOST_ACTION_ALLOC_TGTS:\n\t\tif (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT)\n\t\t\tvhost->action = action;\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_LOGO_WAIT:\n\t\tif (vhost->action == IBMVFC_HOST_ACTION_LOGO)\n\t\t\tvhost->action = action;\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_INIT_WAIT:\n\t\tif (vhost->action == IBMVFC_HOST_ACTION_INIT)\n\t\t\tvhost->action = action;\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_QUERY:\n\t\tswitch (vhost->action) {\n\t\tcase IBMVFC_HOST_ACTION_INIT_WAIT:\n\t\tcase IBMVFC_HOST_ACTION_NONE:\n\t\tcase IBMVFC_HOST_ACTION_TGT_DEL_FAILED:\n\t\t\tvhost->action = action;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_TGT_INIT:\n\t\tif (vhost->action == IBMVFC_HOST_ACTION_ALLOC_TGTS)\n\t\t\tvhost->action = action;\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_REENABLE:\n\tcase IBMVFC_HOST_ACTION_RESET:\n\t\tvhost->action = action;\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_INIT:\n\tcase IBMVFC_HOST_ACTION_TGT_DEL:\n\tcase IBMVFC_HOST_ACTION_LOGO:\n\tcase IBMVFC_HOST_ACTION_QUERY_TGTS:\n\tcase IBMVFC_HOST_ACTION_TGT_DEL_FAILED:\n\tcase IBMVFC_HOST_ACTION_NONE:\n\tdefault:\n\t\tswitch (vhost->action) {\n\t\tcase IBMVFC_HOST_ACTION_RESET:\n\t\tcase IBMVFC_HOST_ACTION_REENABLE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvhost->action = action;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void ibmvfc_reinit_host(struct ibmvfc_host *vhost)\n{\n\tif (vhost->action == IBMVFC_HOST_ACTION_NONE &&\n\t    vhost->state == IBMVFC_ACTIVE) {\n\t\tif (!ibmvfc_set_host_state(vhost, IBMVFC_INITIALIZING)) {\n\t\t\tscsi_block_requests(vhost->host);\n\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY);\n\t\t}\n\t} else\n\t\tvhost->reinit = 1;\n\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_del_tgt(struct ibmvfc_target *tgt)\n{\n\tif (!ibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_LOGOUT_RPORT)) {\n\t\ttgt->job_step = ibmvfc_tgt_implicit_logout_and_del;\n\t\ttgt->init_retries = 0;\n\t}\n\twake_up(&tgt->vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_link_down(struct ibmvfc_host *vhost,\n\t\t\t     enum ibmvfc_host_state state)\n{\n\tstruct ibmvfc_target *tgt;\n\n\tENTER;\n\tscsi_block_requests(vhost->host);\n\tlist_for_each_entry(tgt, &vhost->targets, queue)\n\t\tibmvfc_del_tgt(tgt);\n\tibmvfc_set_host_state(vhost, state);\n\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_TGT_DEL);\n\tvhost->events_to_log |= IBMVFC_AE_LINKDOWN;\n\twake_up(&vhost->work_wait_q);\n\tLEAVE;\n}\n\n \nstatic void ibmvfc_init_host(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_target *tgt;\n\n\tif (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT) {\n\t\tif (++vhost->init_retries > IBMVFC_MAX_HOST_INIT_RETRIES) {\n\t\t\tdev_err(vhost->dev,\n\t\t\t\t\"Host initialization retries exceeded. Taking adapter offline\\n\");\n\t\t\tibmvfc_link_down(vhost, IBMVFC_HOST_OFFLINE);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!ibmvfc_set_host_state(vhost, IBMVFC_INITIALIZING)) {\n\t\tmemset(vhost->async_crq.msgs.async, 0, PAGE_SIZE);\n\t\tvhost->async_crq.cur = 0;\n\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\t\tif (vhost->client_migrated)\n\t\t\t\ttgt->need_login = 1;\n\t\t\telse\n\t\t\t\tibmvfc_del_tgt(tgt);\n\t\t}\n\n\t\tscsi_block_requests(vhost->host);\n\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT);\n\t\tvhost->job_step = ibmvfc_npiv_login;\n\t\twake_up(&vhost->work_wait_q);\n\t}\n}\n\n \nstatic int ibmvfc_send_crq(struct ibmvfc_host *vhost, u64 word1, u64 word2)\n{\n\tstruct vio_dev *vdev = to_vio_dev(vhost->dev);\n\treturn plpar_hcall_norets(H_SEND_CRQ, vdev->unit_address, word1, word2);\n}\n\nstatic int ibmvfc_send_sub_crq(struct ibmvfc_host *vhost, u64 cookie, u64 word1,\n\t\t\t       u64 word2, u64 word3, u64 word4)\n{\n\tstruct vio_dev *vdev = to_vio_dev(vhost->dev);\n\n\treturn plpar_hcall_norets(H_SEND_SUB_CRQ, vdev->unit_address, cookie,\n\t\t\t\t  word1, word2, word3, word4);\n}\n\n \nstatic int ibmvfc_send_crq_init(struct ibmvfc_host *vhost)\n{\n\tibmvfc_dbg(vhost, \"Sending CRQ init\\n\");\n\treturn ibmvfc_send_crq(vhost, 0xC001000000000000LL, 0);\n}\n\n \nstatic int ibmvfc_send_crq_init_complete(struct ibmvfc_host *vhost)\n{\n\tibmvfc_dbg(vhost, \"Sending CRQ init complete\\n\");\n\treturn ibmvfc_send_crq(vhost, 0xC002000000000000LL, 0);\n}\n\n \nstatic int ibmvfc_init_event_pool(struct ibmvfc_host *vhost,\n\t\t\t\t  struct ibmvfc_queue *queue,\n\t\t\t\t  unsigned int size)\n{\n\tint i;\n\tstruct ibmvfc_event_pool *pool = &queue->evt_pool;\n\n\tENTER;\n\tif (!size)\n\t\treturn 0;\n\n\tpool->size = size;\n\tpool->events = kcalloc(size, sizeof(*pool->events), GFP_KERNEL);\n\tif (!pool->events)\n\t\treturn -ENOMEM;\n\n\tpool->iu_storage = dma_alloc_coherent(vhost->dev,\n\t\t\t\t\t      size * sizeof(*pool->iu_storage),\n\t\t\t\t\t      &pool->iu_token, 0);\n\n\tif (!pool->iu_storage) {\n\t\tkfree(pool->events);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&queue->sent);\n\tINIT_LIST_HEAD(&queue->free);\n\tspin_lock_init(&queue->l_lock);\n\n\tfor (i = 0; i < size; ++i) {\n\t\tstruct ibmvfc_event *evt = &pool->events[i];\n\n\t\t \n\t\tatomic_set(&evt->active, -1);\n\t\tatomic_set(&evt->free, 1);\n\t\tevt->crq.valid = 0x80;\n\t\tevt->crq.ioba = cpu_to_be64(pool->iu_token + (sizeof(*evt->xfer_iu) * i));\n\t\tevt->xfer_iu = pool->iu_storage + i;\n\t\tevt->vhost = vhost;\n\t\tevt->queue = queue;\n\t\tevt->ext_list = NULL;\n\t\tlist_add_tail(&evt->queue_list, &queue->free);\n\t}\n\n\tLEAVE;\n\treturn 0;\n}\n\n \nstatic void ibmvfc_free_event_pool(struct ibmvfc_host *vhost,\n\t\t\t\t   struct ibmvfc_queue *queue)\n{\n\tint i;\n\tstruct ibmvfc_event_pool *pool = &queue->evt_pool;\n\n\tENTER;\n\tfor (i = 0; i < pool->size; ++i) {\n\t\tlist_del(&pool->events[i].queue_list);\n\t\tBUG_ON(atomic_read(&pool->events[i].free) != 1);\n\t\tif (pool->events[i].ext_list)\n\t\t\tdma_pool_free(vhost->sg_pool,\n\t\t\t\t      pool->events[i].ext_list,\n\t\t\t\t      pool->events[i].ext_list_token);\n\t}\n\n\tkfree(pool->events);\n\tdma_free_coherent(vhost->dev,\n\t\t\t  pool->size * sizeof(*pool->iu_storage),\n\t\t\t  pool->iu_storage, pool->iu_token);\n\tLEAVE;\n}\n\n \nstatic void ibmvfc_free_queue(struct ibmvfc_host *vhost,\n\t\t\t      struct ibmvfc_queue *queue)\n{\n\tstruct device *dev = vhost->dev;\n\n\tdma_unmap_single(dev, queue->msg_token, PAGE_SIZE, DMA_BIDIRECTIONAL);\n\tfree_page((unsigned long)queue->msgs.handle);\n\tqueue->msgs.handle = NULL;\n\n\tibmvfc_free_event_pool(vhost, queue);\n}\n\n \nstatic void ibmvfc_release_crq_queue(struct ibmvfc_host *vhost)\n{\n\tlong rc = 0;\n\tstruct vio_dev *vdev = to_vio_dev(vhost->dev);\n\tstruct ibmvfc_queue *crq = &vhost->crq;\n\n\tibmvfc_dbg(vhost, \"Releasing CRQ\\n\");\n\tfree_irq(vdev->irq, vhost);\n\ttasklet_kill(&vhost->tasklet);\n\tdo {\n\t\tif (rc)\n\t\t\tmsleep(100);\n\t\trc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tvhost->state = IBMVFC_NO_CRQ;\n\tvhost->logged_in = 0;\n\n\tibmvfc_free_queue(vhost, crq);\n}\n\n \nstatic int ibmvfc_reenable_crq_queue(struct ibmvfc_host *vhost)\n{\n\tint rc = 0;\n\tstruct vio_dev *vdev = to_vio_dev(vhost->dev);\n\tunsigned long flags;\n\n\tibmvfc_dereg_sub_crqs(vhost);\n\n\t \n\tdo {\n\t\tif (rc)\n\t\t\tmsleep(100);\n\t\trc = plpar_hcall_norets(H_ENABLE_CRQ, vdev->unit_address);\n\t} while (rc == H_IN_PROGRESS || rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tif (rc)\n\t\tdev_err(vhost->dev, \"Error enabling adapter (rc=%d)\\n\", rc);\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tspin_lock(vhost->crq.q_lock);\n\tvhost->do_enquiry = 1;\n\tvhost->using_channels = 0;\n\tspin_unlock(vhost->crq.q_lock);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tibmvfc_reg_sub_crqs(vhost);\n\n\treturn rc;\n}\n\n \nstatic int ibmvfc_reset_crq(struct ibmvfc_host *vhost)\n{\n\tint rc = 0;\n\tunsigned long flags;\n\tstruct vio_dev *vdev = to_vio_dev(vhost->dev);\n\tstruct ibmvfc_queue *crq = &vhost->crq;\n\n\tibmvfc_dereg_sub_crqs(vhost);\n\n\t \n\tdo {\n\t\tif (rc)\n\t\t\tmsleep(100);\n\t\trc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tspin_lock(vhost->crq.q_lock);\n\tvhost->state = IBMVFC_NO_CRQ;\n\tvhost->logged_in = 0;\n\tvhost->do_enquiry = 1;\n\tvhost->using_channels = 0;\n\n\t \n\tmemset(crq->msgs.crq, 0, PAGE_SIZE);\n\tcrq->cur = 0;\n\n\t \n\trc = plpar_hcall_norets(H_REG_CRQ, vdev->unit_address,\n\t\t\t\tcrq->msg_token, PAGE_SIZE);\n\n\tif (rc == H_CLOSED)\n\t\t \n\t\tdev_warn(vhost->dev, \"Partner adapter not ready\\n\");\n\telse if (rc != 0)\n\t\tdev_warn(vhost->dev, \"Couldn't register crq (rc=%d)\\n\", rc);\n\n\tspin_unlock(vhost->crq.q_lock);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tibmvfc_reg_sub_crqs(vhost);\n\n\treturn rc;\n}\n\n \nstatic int ibmvfc_valid_event(struct ibmvfc_event_pool *pool,\n\t\t\t      struct ibmvfc_event *evt)\n{\n\tint index = evt - pool->events;\n\tif (index < 0 || index >= pool->size)\t \n\t\treturn 0;\n\tif (evt != pool->events + index)\t \n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic void ibmvfc_free_event(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_event_pool *pool = &evt->queue->evt_pool;\n\tunsigned long flags;\n\n\tBUG_ON(!ibmvfc_valid_event(pool, evt));\n\tBUG_ON(atomic_inc_return(&evt->free) != 1);\n\tBUG_ON(atomic_dec_and_test(&evt->active));\n\n\tspin_lock_irqsave(&evt->queue->l_lock, flags);\n\tlist_add_tail(&evt->queue_list, &evt->queue->free);\n\tif (evt->eh_comp)\n\t\tcomplete(evt->eh_comp);\n\tspin_unlock_irqrestore(&evt->queue->l_lock, flags);\n}\n\n \nstatic void ibmvfc_scsi_eh_done(struct ibmvfc_event *evt)\n{\n\tstruct scsi_cmnd *cmnd = evt->cmnd;\n\n\tif (cmnd) {\n\t\tscsi_dma_unmap(cmnd);\n\t\tscsi_done(cmnd);\n\t}\n\n\tibmvfc_free_event(evt);\n}\n\n \nstatic void ibmvfc_complete_purge(struct list_head *purge_list)\n{\n\tstruct ibmvfc_event *evt, *pos;\n\n\tlist_for_each_entry_safe(evt, pos, purge_list, queue_list) {\n\t\tlist_del(&evt->queue_list);\n\t\tibmvfc_trc_end(evt);\n\t\tevt->done(evt);\n\t}\n}\n\n \nstatic void ibmvfc_fail_request(struct ibmvfc_event *evt, int error_code)\n{\n\t \n\tBUG_ON(!atomic_dec_and_test(&evt->active));\n\tif (evt->cmnd) {\n\t\tevt->cmnd->result = (error_code << 16);\n\t\tevt->done = ibmvfc_scsi_eh_done;\n\t} else\n\t\tevt->xfer_iu->mad_common.status = cpu_to_be16(IBMVFC_MAD_DRIVER_FAILED);\n\n\tdel_timer(&evt->timer);\n}\n\n \nstatic void ibmvfc_purge_requests(struct ibmvfc_host *vhost, int error_code)\n{\n\tstruct ibmvfc_event *evt, *pos;\n\tstruct ibmvfc_queue *queues = vhost->scsi_scrqs.scrqs;\n\tunsigned long flags;\n\tint hwqs = 0;\n\tint i;\n\n\tif (vhost->using_channels)\n\t\thwqs = vhost->scsi_scrqs.active_queues;\n\n\tibmvfc_dbg(vhost, \"Purging all requests\\n\");\n\tspin_lock_irqsave(&vhost->crq.l_lock, flags);\n\tlist_for_each_entry_safe(evt, pos, &vhost->crq.sent, queue_list)\n\t\tibmvfc_fail_request(evt, error_code);\n\tlist_splice_init(&vhost->crq.sent, &vhost->purge);\n\tspin_unlock_irqrestore(&vhost->crq.l_lock, flags);\n\n\tfor (i = 0; i < hwqs; i++) {\n\t\tspin_lock_irqsave(queues[i].q_lock, flags);\n\t\tspin_lock(&queues[i].l_lock);\n\t\tlist_for_each_entry_safe(evt, pos, &queues[i].sent, queue_list)\n\t\t\tibmvfc_fail_request(evt, error_code);\n\t\tlist_splice_init(&queues[i].sent, &vhost->purge);\n\t\tspin_unlock(&queues[i].l_lock);\n\t\tspin_unlock_irqrestore(queues[i].q_lock, flags);\n\t}\n}\n\n \nstatic void ibmvfc_hard_reset_host(struct ibmvfc_host *vhost)\n{\n\tibmvfc_purge_requests(vhost, DID_ERROR);\n\tibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\n\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_RESET);\n}\n\n \nstatic void __ibmvfc_reset_host(struct ibmvfc_host *vhost)\n{\n\tif (vhost->logged_in && vhost->action != IBMVFC_HOST_ACTION_LOGO_WAIT &&\n\t    !ibmvfc_set_host_state(vhost, IBMVFC_INITIALIZING)) {\n\t\tscsi_block_requests(vhost->host);\n\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_LOGO);\n\t\tvhost->job_step = ibmvfc_npiv_logout;\n\t\twake_up(&vhost->work_wait_q);\n\t} else\n\t\tibmvfc_hard_reset_host(vhost);\n}\n\n \nstatic void ibmvfc_reset_host(struct ibmvfc_host *vhost)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\t__ibmvfc_reset_host(vhost);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n}\n\n \nstatic int ibmvfc_retry_host_init(struct ibmvfc_host *vhost)\n{\n\tint retry = 0;\n\n\tif (vhost->action == IBMVFC_HOST_ACTION_INIT_WAIT) {\n\t\tvhost->delay_init = 1;\n\t\tif (++vhost->init_retries > IBMVFC_MAX_HOST_INIT_RETRIES) {\n\t\t\tdev_err(vhost->dev,\n\t\t\t\t\"Host initialization retries exceeded. Taking adapter offline\\n\");\n\t\t\tibmvfc_link_down(vhost, IBMVFC_HOST_OFFLINE);\n\t\t} else if (vhost->init_retries == IBMVFC_MAX_HOST_INIT_RETRIES)\n\t\t\t__ibmvfc_reset_host(vhost);\n\t\telse {\n\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT);\n\t\t\tretry = 1;\n\t\t}\n\t}\n\n\twake_up(&vhost->work_wait_q);\n\treturn retry;\n}\n\n \nstatic struct ibmvfc_target *__ibmvfc_get_target(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tstruct ibmvfc_target *tgt;\n\n\tlist_for_each_entry(tgt, &vhost->targets, queue)\n\t\tif (tgt->target_id == starget->id) {\n\t\t\tkref_get(&tgt->kref);\n\t\t\treturn tgt;\n\t\t}\n\treturn NULL;\n}\n\n \nstatic struct ibmvfc_target *ibmvfc_get_target(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ibmvfc_target *tgt;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\ttgt = __ibmvfc_get_target(starget);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn tgt;\n}\n\n \nstatic void ibmvfc_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (vhost->state == IBMVFC_ACTIVE) {\n\t\tswitch (be64_to_cpu(vhost->login_buf->resp.link_speed) / 100) {\n\t\tcase 1:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tibmvfc_log(vhost, 3, \"Unknown port speed: %lld Gbit\\n\",\n\t\t\t\t   be64_to_cpu(vhost->login_buf->resp.link_speed) / 100);\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n \nstatic void ibmvfc_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tswitch (vhost->state) {\n\tcase IBMVFC_INITIALIZING:\n\tcase IBMVFC_ACTIVE:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\t\tbreak;\n\tcase IBMVFC_LINK_DOWN:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\t\tbreak;\n\tcase IBMVFC_LINK_DEAD:\n\tcase IBMVFC_HOST_OFFLINE:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n\t\tbreak;\n\tcase IBMVFC_HALTED:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_BLOCKED;\n\t\tbreak;\n\tcase IBMVFC_NO_CRQ:\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\t\tbreak;\n\tdefault:\n\t\tibmvfc_log(vhost, 3, \"Unknown port state: %d\\n\", vhost->state);\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n}\n\n \nstatic void ibmvfc_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)\n{\n\tif (timeout)\n\t\trport->dev_loss_tmo = timeout;\n\telse\n\t\trport->dev_loss_tmo = 1;\n}\n\n \nstatic void ibmvfc_release_tgt(struct kref *kref)\n{\n\tstruct ibmvfc_target *tgt = container_of(kref, struct ibmvfc_target, kref);\n\tkfree(tgt);\n}\n\n \nstatic void ibmvfc_get_starget_node_name(struct scsi_target *starget)\n{\n\tstruct ibmvfc_target *tgt = ibmvfc_get_target(starget);\n\tfc_starget_port_name(starget) = tgt ? tgt->ids.node_name : 0;\n\tif (tgt)\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n}\n\n \nstatic void ibmvfc_get_starget_port_name(struct scsi_target *starget)\n{\n\tstruct ibmvfc_target *tgt = ibmvfc_get_target(starget);\n\tfc_starget_port_name(starget) = tgt ? tgt->ids.port_name : 0;\n\tif (tgt)\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n}\n\n \nstatic void ibmvfc_get_starget_port_id(struct scsi_target *starget)\n{\n\tstruct ibmvfc_target *tgt = ibmvfc_get_target(starget);\n\tfc_starget_port_id(starget) = tgt ? tgt->scsi_id : -1;\n\tif (tgt)\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n}\n\n \nstatic int ibmvfc_wait_while_resetting(struct ibmvfc_host *vhost)\n{\n\tlong timeout = wait_event_timeout(vhost->init_wait_q,\n\t\t\t\t\t  ((vhost->state == IBMVFC_ACTIVE ||\n\t\t\t\t\t    vhost->state == IBMVFC_HOST_OFFLINE ||\n\t\t\t\t\t    vhost->state == IBMVFC_LINK_DEAD) &&\n\t\t\t\t\t   vhost->action == IBMVFC_HOST_ACTION_NONE),\n\t\t\t\t\t  (init_timeout * HZ));\n\n\treturn timeout ? 0 : -EIO;\n}\n\n \nstatic int ibmvfc_issue_fc_host_lip(struct Scsi_Host *shost)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\n\tdev_err(vhost->dev, \"Initiating host LIP. Resetting connection\\n\");\n\tibmvfc_reset_host(vhost);\n\treturn ibmvfc_wait_while_resetting(vhost);\n}\n\n \nstatic void ibmvfc_gather_partition_info(struct ibmvfc_host *vhost)\n{\n\tstruct device_node *rootdn;\n\tconst char *name;\n\tconst unsigned int *num;\n\n\trootdn = of_find_node_by_path(\"/\");\n\tif (!rootdn)\n\t\treturn;\n\n\tname = of_get_property(rootdn, \"ibm,partition-name\", NULL);\n\tif (name)\n\t\tstrncpy(vhost->partition_name, name, sizeof(vhost->partition_name));\n\tnum = of_get_property(rootdn, \"ibm,partition-no\", NULL);\n\tif (num)\n\t\tvhost->partition_number = *num;\n\tof_node_put(rootdn);\n}\n\n \nstatic void ibmvfc_set_login_info(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_npiv_login *login_info = &vhost->login_info;\n\tstruct ibmvfc_queue *async_crq = &vhost->async_crq;\n\tstruct device_node *of_node = vhost->dev->of_node;\n\tconst char *location;\n\n\tmemset(login_info, 0, sizeof(*login_info));\n\n\tlogin_info->ostype = cpu_to_be32(IBMVFC_OS_LINUX);\n\tlogin_info->max_dma_len = cpu_to_be64(IBMVFC_MAX_SECTORS << 9);\n\tlogin_info->max_payload = cpu_to_be32(sizeof(struct ibmvfc_fcp_cmd_iu));\n\tlogin_info->max_response = cpu_to_be32(sizeof(struct ibmvfc_fcp_rsp));\n\tlogin_info->partition_num = cpu_to_be32(vhost->partition_number);\n\tlogin_info->vfc_frame_version = cpu_to_be32(1);\n\tlogin_info->fcp_version = cpu_to_be16(3);\n\tlogin_info->flags = cpu_to_be16(IBMVFC_FLUSH_ON_HALT);\n\tif (vhost->client_migrated)\n\t\tlogin_info->flags |= cpu_to_be16(IBMVFC_CLIENT_MIGRATED);\n\n\tlogin_info->max_cmds = cpu_to_be32(max_requests + IBMVFC_NUM_INTERNAL_REQ);\n\tlogin_info->capabilities = cpu_to_be64(IBMVFC_CAN_MIGRATE | IBMVFC_CAN_SEND_VF_WWPN);\n\n\tif (vhost->mq_enabled || vhost->using_channels)\n\t\tlogin_info->capabilities |= cpu_to_be64(IBMVFC_CAN_USE_CHANNELS);\n\n\tlogin_info->async.va = cpu_to_be64(vhost->async_crq.msg_token);\n\tlogin_info->async.len = cpu_to_be32(async_crq->size *\n\t\t\t\t\t    sizeof(*async_crq->msgs.async));\n\tstrncpy(login_info->partition_name, vhost->partition_name, IBMVFC_MAX_NAME);\n\tstrncpy(login_info->device_name,\n\t\tdev_name(&vhost->host->shost_gendev), IBMVFC_MAX_NAME);\n\n\tlocation = of_get_property(of_node, \"ibm,loc-code\", NULL);\n\tlocation = location ? location : dev_name(vhost->dev);\n\tstrncpy(login_info->drc_name, location, IBMVFC_MAX_NAME);\n}\n\n \nstatic struct ibmvfc_event *ibmvfc_get_event(struct ibmvfc_queue *queue)\n{\n\tstruct ibmvfc_event *evt;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->l_lock, flags);\n\tif (list_empty(&queue->free)) {\n\t\tibmvfc_log(queue->vhost, 4, \"empty event pool on queue:%ld\\n\", queue->hwq_id);\n\t\tspin_unlock_irqrestore(&queue->l_lock, flags);\n\t\treturn NULL;\n\t}\n\tevt = list_entry(queue->free.next, struct ibmvfc_event, queue_list);\n\tatomic_set(&evt->free, 0);\n\tlist_del(&evt->queue_list);\n\tspin_unlock_irqrestore(&queue->l_lock, flags);\n\treturn evt;\n}\n\n \nstatic void ibmvfc_locked_done(struct ibmvfc_event *evt)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(evt->vhost->host->host_lock, flags);\n\tevt->_done(evt);\n\tspin_unlock_irqrestore(evt->vhost->host->host_lock, flags);\n}\n\n \nstatic void ibmvfc_init_event(struct ibmvfc_event *evt,\n\t\t\t      void (*done) (struct ibmvfc_event *), u8 format)\n{\n\tevt->cmnd = NULL;\n\tevt->sync_iu = NULL;\n\tevt->eh_comp = NULL;\n\tevt->crq.format = format;\n\tif (format == IBMVFC_CMD_FORMAT)\n\t\tevt->done = done;\n\telse {\n\t\tevt->_done = done;\n\t\tevt->done = ibmvfc_locked_done;\n\t}\n\tevt->hwq = 0;\n}\n\n \nstatic void ibmvfc_map_sg_list(struct scsi_cmnd *scmd, int nseg,\n\t\t\t       struct srp_direct_buf *md)\n{\n\tint i;\n\tstruct scatterlist *sg;\n\n\tscsi_for_each_sg(scmd, sg, nseg, i) {\n\t\tmd[i].va = cpu_to_be64(sg_dma_address(sg));\n\t\tmd[i].len = cpu_to_be32(sg_dma_len(sg));\n\t\tmd[i].key = 0;\n\t}\n}\n\n \nstatic int ibmvfc_map_sg_data(struct scsi_cmnd *scmd,\n\t\t\t      struct ibmvfc_event *evt,\n\t\t\t      struct ibmvfc_cmd *vfc_cmd, struct device *dev)\n{\n\n\tint sg_mapped;\n\tstruct srp_direct_buf *data = &vfc_cmd->ioba;\n\tstruct ibmvfc_host *vhost = dev_get_drvdata(dev);\n\tstruct ibmvfc_fcp_cmd_iu *iu = ibmvfc_get_fcp_iu(evt->vhost, vfc_cmd);\n\n\tif (cls3_error)\n\t\tvfc_cmd->flags |= cpu_to_be16(IBMVFC_CLASS_3_ERR);\n\n\tsg_mapped = scsi_dma_map(scmd);\n\tif (!sg_mapped) {\n\t\tvfc_cmd->flags |= cpu_to_be16(IBMVFC_NO_MEM_DESC);\n\t\treturn 0;\n\t} else if (unlikely(sg_mapped < 0)) {\n\t\tif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\n\t\t\tscmd_printk(KERN_ERR, scmd, \"Failed to map DMA buffer for command\\n\");\n\t\treturn sg_mapped;\n\t}\n\n\tif (scmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tvfc_cmd->flags |= cpu_to_be16(IBMVFC_WRITE);\n\t\tiu->add_cdb_len |= IBMVFC_WRDATA;\n\t} else {\n\t\tvfc_cmd->flags |= cpu_to_be16(IBMVFC_READ);\n\t\tiu->add_cdb_len |= IBMVFC_RDDATA;\n\t}\n\n\tif (sg_mapped == 1) {\n\t\tibmvfc_map_sg_list(scmd, sg_mapped, data);\n\t\treturn 0;\n\t}\n\n\tvfc_cmd->flags |= cpu_to_be16(IBMVFC_SCATTERLIST);\n\n\tif (!evt->ext_list) {\n\t\tevt->ext_list = dma_pool_alloc(vhost->sg_pool, GFP_ATOMIC,\n\t\t\t\t\t       &evt->ext_list_token);\n\n\t\tif (!evt->ext_list) {\n\t\t\tscsi_dma_unmap(scmd);\n\t\t\tif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\n\t\t\t\tscmd_printk(KERN_ERR, scmd, \"Can't allocate memory for scatterlist\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tibmvfc_map_sg_list(scmd, sg_mapped, evt->ext_list);\n\n\tdata->va = cpu_to_be64(evt->ext_list_token);\n\tdata->len = cpu_to_be32(sg_mapped * sizeof(struct srp_direct_buf));\n\tdata->key = 0;\n\treturn 0;\n}\n\n \nstatic void ibmvfc_timeout(struct timer_list *t)\n{\n\tstruct ibmvfc_event *evt = from_timer(evt, t, timer);\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tdev_err(vhost->dev, \"Command timed out (%p). Resetting connection\\n\", evt);\n\tibmvfc_reset_host(vhost);\n}\n\n \nstatic int ibmvfc_send_event(struct ibmvfc_event *evt,\n\t\t\t     struct ibmvfc_host *vhost, unsigned long timeout)\n{\n\t__be64 *crq_as_u64 = (__be64 *) &evt->crq;\n\tunsigned long flags;\n\tint rc;\n\n\t \n\t*evt->xfer_iu = evt->iu;\n\tif (evt->crq.format == IBMVFC_CMD_FORMAT)\n\t\tevt->xfer_iu->cmd.tag = cpu_to_be64((u64)evt);\n\telse if (evt->crq.format == IBMVFC_MAD_FORMAT)\n\t\tevt->xfer_iu->mad_common.tag = cpu_to_be64((u64)evt);\n\telse\n\t\tBUG();\n\n\ttimer_setup(&evt->timer, ibmvfc_timeout, 0);\n\n\tif (timeout) {\n\t\tevt->timer.expires = jiffies + (timeout * HZ);\n\t\tadd_timer(&evt->timer);\n\t}\n\n\tspin_lock_irqsave(&evt->queue->l_lock, flags);\n\tlist_add_tail(&evt->queue_list, &evt->queue->sent);\n\tatomic_set(&evt->active, 1);\n\n\tmb();\n\n\tif (evt->queue->fmt == IBMVFC_SUB_CRQ_FMT)\n\t\trc = ibmvfc_send_sub_crq(vhost,\n\t\t\t\t\t evt->queue->vios_cookie,\n\t\t\t\t\t be64_to_cpu(crq_as_u64[0]),\n\t\t\t\t\t be64_to_cpu(crq_as_u64[1]),\n\t\t\t\t\t 0, 0);\n\telse\n\t\trc = ibmvfc_send_crq(vhost, be64_to_cpu(crq_as_u64[0]),\n\t\t\t\t     be64_to_cpu(crq_as_u64[1]));\n\n\tif (rc) {\n\t\tatomic_set(&evt->active, 0);\n\t\tlist_del(&evt->queue_list);\n\t\tspin_unlock_irqrestore(&evt->queue->l_lock, flags);\n\t\tdel_timer(&evt->timer);\n\n\t\t \n\t\tif (rc == H_CLOSED) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_warn(vhost->dev, \"Send warning. Receive queue closed, will retry.\\n\");\n\t\t\tif (evt->cmnd)\n\t\t\t\tscsi_dma_unmap(evt->cmnd);\n\t\t\tibmvfc_free_event(evt);\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t}\n\n\t\tdev_err(vhost->dev, \"Send error (rc=%d)\\n\", rc);\n\t\tif (evt->cmnd) {\n\t\t\tevt->cmnd->result = DID_ERROR << 16;\n\t\t\tevt->done = ibmvfc_scsi_eh_done;\n\t\t} else\n\t\t\tevt->xfer_iu->mad_common.status = cpu_to_be16(IBMVFC_MAD_CRQ_ERROR);\n\n\t\tevt->done(evt);\n\t} else {\n\t\tspin_unlock_irqrestore(&evt->queue->l_lock, flags);\n\t\tibmvfc_trc_start(evt);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ibmvfc_log_error(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_cmd *vfc_cmd = &evt->xfer_iu->cmd;\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_fcp_rsp *rsp = ibmvfc_get_fcp_rsp(vhost, vfc_cmd);\n\tstruct scsi_cmnd *cmnd = evt->cmnd;\n\tconst char *err = unknown_error;\n\tint index = ibmvfc_get_err_index(be16_to_cpu(vfc_cmd->status), be16_to_cpu(vfc_cmd->error));\n\tint logerr = 0;\n\tint rsp_code = 0;\n\n\tif (index >= 0) {\n\t\tlogerr = cmd_status[index].log;\n\t\terr = cmd_status[index].name;\n\t}\n\n\tif (!logerr && (vhost->log_level <= (IBMVFC_DEFAULT_LOG_LEVEL + 1)))\n\t\treturn;\n\n\tif (rsp->flags & FCP_RSP_LEN_VALID)\n\t\trsp_code = rsp->data.info.rsp_code;\n\n\tscmd_printk(KERN_ERR, cmnd, \"Command (%02X) : %s (%x:%x) \"\n\t\t    \"flags: %x fcp_rsp: %x, resid=%d, scsi_status: %x\\n\",\n\t\t    cmnd->cmnd[0], err, be16_to_cpu(vfc_cmd->status), be16_to_cpu(vfc_cmd->error),\n\t\t    rsp->flags, rsp_code, scsi_get_resid(cmnd), rsp->scsi_status);\n}\n\n \nstatic void ibmvfc_relogin(struct scsi_device *sdev)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tstruct ibmvfc_target *tgt;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\tif (rport == tgt->rport) {\n\t\t\tibmvfc_del_tgt(tgt);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tibmvfc_reinit_host(vhost);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n}\n\n \nstatic void ibmvfc_scsi_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_cmd *vfc_cmd = &evt->xfer_iu->cmd;\n\tstruct ibmvfc_fcp_rsp *rsp = ibmvfc_get_fcp_rsp(evt->vhost, vfc_cmd);\n\tstruct scsi_cmnd *cmnd = evt->cmnd;\n\tu32 rsp_len = 0;\n\tu32 sense_len = be32_to_cpu(rsp->fcp_sense_len);\n\n\tif (cmnd) {\n\t\tif (be16_to_cpu(vfc_cmd->response_flags) & IBMVFC_ADAPTER_RESID_VALID)\n\t\t\tscsi_set_resid(cmnd, be32_to_cpu(vfc_cmd->adapter_resid));\n\t\telse if (rsp->flags & FCP_RESID_UNDER)\n\t\t\tscsi_set_resid(cmnd, be32_to_cpu(rsp->fcp_resid));\n\t\telse\n\t\t\tscsi_set_resid(cmnd, 0);\n\n\t\tif (vfc_cmd->status) {\n\t\t\tcmnd->result = ibmvfc_get_err_result(evt->vhost, vfc_cmd);\n\n\t\t\tif (rsp->flags & FCP_RSP_LEN_VALID)\n\t\t\t\trsp_len = be32_to_cpu(rsp->fcp_rsp_len);\n\t\t\tif ((sense_len + rsp_len) > SCSI_SENSE_BUFFERSIZE)\n\t\t\t\tsense_len = SCSI_SENSE_BUFFERSIZE - rsp_len;\n\t\t\tif ((rsp->flags & FCP_SNS_LEN_VALID) && rsp->fcp_sense_len && rsp_len <= 8)\n\t\t\t\tmemcpy(cmnd->sense_buffer, rsp->data.sense + rsp_len, sense_len);\n\t\t\tif ((be16_to_cpu(vfc_cmd->status) & IBMVFC_VIOS_FAILURE) &&\n\t\t\t    (be16_to_cpu(vfc_cmd->error) == IBMVFC_PLOGI_REQUIRED))\n\t\t\t\tibmvfc_relogin(cmnd->device);\n\n\t\t\tif (!cmnd->result && (!scsi_get_resid(cmnd) || (rsp->flags & FCP_RESID_OVER)))\n\t\t\t\tcmnd->result = (DID_ERROR << 16);\n\n\t\t\tibmvfc_log_error(evt);\n\t\t}\n\n\t\tif (!cmnd->result &&\n\t\t    (scsi_bufflen(cmnd) - scsi_get_resid(cmnd) < cmnd->underflow))\n\t\t\tcmnd->result = (DID_ERROR << 16);\n\n\t\tscsi_dma_unmap(cmnd);\n\t\tscsi_done(cmnd);\n\t}\n\n\tibmvfc_free_event(evt);\n}\n\n \nstatic inline int ibmvfc_host_chkready(struct ibmvfc_host *vhost)\n{\n\tint result = 0;\n\n\tswitch (vhost->state) {\n\tcase IBMVFC_LINK_DEAD:\n\tcase IBMVFC_HOST_OFFLINE:\n\t\tresult = DID_NO_CONNECT << 16;\n\t\tbreak;\n\tcase IBMVFC_NO_CRQ:\n\tcase IBMVFC_INITIALIZING:\n\tcase IBMVFC_HALTED:\n\tcase IBMVFC_LINK_DOWN:\n\t\tresult = DID_REQUEUE << 16;\n\t\tbreak;\n\tcase IBMVFC_ACTIVE:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic struct ibmvfc_cmd *ibmvfc_init_vfc_cmd(struct ibmvfc_event *evt, struct scsi_device *sdev)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_cmd *vfc_cmd = &evt->iu.cmd;\n\tstruct ibmvfc_fcp_cmd_iu *iu = ibmvfc_get_fcp_iu(vhost, vfc_cmd);\n\tstruct ibmvfc_fcp_rsp *rsp = ibmvfc_get_fcp_rsp(vhost, vfc_cmd);\n\tsize_t offset;\n\n\tmemset(vfc_cmd, 0, sizeof(*vfc_cmd));\n\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN)) {\n\t\toffset = offsetof(struct ibmvfc_cmd, v2.rsp);\n\t\tvfc_cmd->target_wwpn = cpu_to_be64(rport->port_name);\n\t} else\n\t\toffset = offsetof(struct ibmvfc_cmd, v1.rsp);\n\tvfc_cmd->resp.va = cpu_to_be64(be64_to_cpu(evt->crq.ioba) + offset);\n\tvfc_cmd->resp.len = cpu_to_be32(sizeof(*rsp));\n\tvfc_cmd->frame_type = cpu_to_be32(IBMVFC_SCSI_FCP_TYPE);\n\tvfc_cmd->payload_len = cpu_to_be32(sizeof(*iu));\n\tvfc_cmd->resp_len = cpu_to_be32(sizeof(*rsp));\n\tvfc_cmd->cancel_key = cpu_to_be32((unsigned long)sdev->hostdata);\n\tvfc_cmd->tgt_scsi_id = cpu_to_be64(rport->port_id);\n\tint_to_scsilun(sdev->lun, &iu->lun);\n\n\treturn vfc_cmd;\n}\n\n \nstatic int ibmvfc_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *cmnd)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\tstruct ibmvfc_cmd *vfc_cmd;\n\tstruct ibmvfc_fcp_cmd_iu *iu;\n\tstruct ibmvfc_event *evt;\n\tu32 tag_and_hwq = blk_mq_unique_tag(scsi_cmd_to_rq(cmnd));\n\tu16 hwq = blk_mq_unique_tag_to_hwq(tag_and_hwq);\n\tu16 scsi_channel;\n\tint rc;\n\n\tif (unlikely((rc = fc_remote_port_chkready(rport))) ||\n\t    unlikely((rc = ibmvfc_host_chkready(vhost)))) {\n\t\tcmnd->result = rc;\n\t\tscsi_done(cmnd);\n\t\treturn 0;\n\t}\n\n\tcmnd->result = (DID_OK << 16);\n\tif (vhost->using_channels) {\n\t\tscsi_channel = hwq % vhost->scsi_scrqs.active_queues;\n\t\tevt = ibmvfc_get_event(&vhost->scsi_scrqs.scrqs[scsi_channel]);\n\t\tif (!evt)\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t\tevt->hwq = hwq % vhost->scsi_scrqs.active_queues;\n\t} else {\n\t\tevt = ibmvfc_get_event(&vhost->crq);\n\t\tif (!evt)\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\tibmvfc_init_event(evt, ibmvfc_scsi_done, IBMVFC_CMD_FORMAT);\n\tevt->cmnd = cmnd;\n\n\tvfc_cmd = ibmvfc_init_vfc_cmd(evt, cmnd->device);\n\tiu = ibmvfc_get_fcp_iu(vhost, vfc_cmd);\n\n\tiu->xfer_len = cpu_to_be32(scsi_bufflen(cmnd));\n\tmemcpy(iu->cdb, cmnd->cmnd, cmnd->cmd_len);\n\n\tif (cmnd->flags & SCMD_TAGGED) {\n\t\tvfc_cmd->task_tag = cpu_to_be64(scsi_cmd_to_rq(cmnd)->tag);\n\t\tiu->pri_task_attr = IBMVFC_SIMPLE_TASK;\n\t}\n\n\tvfc_cmd->correlation = cpu_to_be64((u64)evt);\n\n\tif (likely(!(rc = ibmvfc_map_sg_data(cmnd, evt, vfc_cmd, vhost->dev))))\n\t\treturn ibmvfc_send_event(evt, vhost, 0);\n\n\tibmvfc_free_event(evt);\n\tif (rc == -ENOMEM)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\n\t\tscmd_printk(KERN_ERR, cmnd,\n\t\t\t    \"Failed to map DMA buffer for command. rc=%d\\n\", rc);\n\n\tcmnd->result = DID_ERROR << 16;\n\tscsi_done(cmnd);\n\treturn 0;\n}\n\n \nstatic void ibmvfc_sync_completion(struct ibmvfc_event *evt)\n{\n\t \n\tif (evt->sync_iu)\n\t\t*evt->sync_iu = *evt->xfer_iu;\n\n\tcomplete(&evt->comp);\n}\n\n \nstatic void ibmvfc_bsg_timeout_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\n\tibmvfc_free_event(evt);\n\tvhost->aborting_passthru = 0;\n\tdev_info(vhost->dev, \"Passthru command cancelled\\n\");\n}\n\n \nstatic int ibmvfc_bsg_timeout(struct bsg_job *job)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(fc_bsg_to_shost(job));\n\tunsigned long port_id = (unsigned long)job->dd_data;\n\tstruct ibmvfc_event *evt;\n\tstruct ibmvfc_tmf *tmf;\n\tunsigned long flags;\n\tint rc;\n\n\tENTER;\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tif (vhost->aborting_passthru || vhost->state != IBMVFC_ACTIVE) {\n\t\t__ibmvfc_reset_host(vhost);\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\treturn 0;\n\t}\n\n\tvhost->aborting_passthru = 1;\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tibmvfc_init_event(evt, ibmvfc_bsg_timeout_done, IBMVFC_MAD_FORMAT);\n\n\ttmf = &evt->iu.tmf;\n\tmemset(tmf, 0, sizeof(*tmf));\n\ttmf->common.version = cpu_to_be32(1);\n\ttmf->common.opcode = cpu_to_be32(IBMVFC_TMF_MAD);\n\ttmf->common.length = cpu_to_be16(sizeof(*tmf));\n\ttmf->scsi_id = cpu_to_be64(port_id);\n\ttmf->cancel_key = cpu_to_be32(IBMVFC_PASSTHRU_CANCEL_KEY);\n\ttmf->my_cancel_key = cpu_to_be32(IBMVFC_INTERNAL_CANCEL_KEY);\n\trc = ibmvfc_send_event(evt, vhost, default_timeout);\n\n\tif (rc != 0) {\n\t\tvhost->aborting_passthru = 0;\n\t\tdev_err(vhost->dev, \"Failed to send cancel event. rc=%d\\n\", rc);\n\t\trc = -EIO;\n\t} else\n\t\tdev_info(vhost->dev, \"Cancelling passthru command to port id 0x%lx\\n\",\n\t\t\t port_id);\n\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tLEAVE;\n\treturn rc;\n}\n\n \nstatic int ibmvfc_bsg_plogi(struct ibmvfc_host *vhost, unsigned int port_id)\n{\n\tstruct ibmvfc_port_login *plogi;\n\tstruct ibmvfc_target *tgt;\n\tstruct ibmvfc_event *evt;\n\tunion ibmvfc_iu rsp_iu;\n\tunsigned long flags;\n\tint rc = 0, issue_login = 1;\n\n\tENTER;\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\tif (tgt->scsi_id == port_id) {\n\t\t\tissue_login = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!issue_login)\n\t\tgoto unlock_out;\n\tif (unlikely((rc = ibmvfc_host_chkready(vhost))))\n\t\tgoto unlock_out;\n\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\trc = -ENOMEM;\n\t\tgoto unlock_out;\n\t}\n\tibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);\n\tplogi = &evt->iu.plogi;\n\tmemset(plogi, 0, sizeof(*plogi));\n\tplogi->common.version = cpu_to_be32(1);\n\tplogi->common.opcode = cpu_to_be32(IBMVFC_PORT_LOGIN);\n\tplogi->common.length = cpu_to_be16(sizeof(*plogi));\n\tplogi->scsi_id = cpu_to_be64(port_id);\n\tevt->sync_iu = &rsp_iu;\n\tinit_completion(&evt->comp);\n\n\trc = ibmvfc_send_event(evt, vhost, default_timeout);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tif (rc)\n\t\treturn -EIO;\n\n\twait_for_completion(&evt->comp);\n\n\tif (rsp_iu.plogi.common.status)\n\t\trc = -EIO;\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tibmvfc_free_event(evt);\nunlock_out:\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\tLEAVE;\n\treturn rc;\n}\n\n \nstatic int ibmvfc_bsg_request(struct bsg_job *job)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(fc_bsg_to_shost(job));\n\tstruct fc_rport *rport = fc_bsg_to_rport(job);\n\tstruct ibmvfc_passthru_mad *mad;\n\tstruct ibmvfc_event *evt;\n\tunion ibmvfc_iu rsp_iu;\n\tunsigned long flags, port_id = -1;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tunsigned int code = bsg_request->msgcode;\n\tint rc = 0, req_seg, rsp_seg, issue_login = 0;\n\tu32 fc_flags, rsp_len;\n\n\tENTER;\n\tbsg_reply->reply_payload_rcv_len = 0;\n\tif (rport)\n\t\tport_id = rport->port_id;\n\n\tswitch (code) {\n\tcase FC_BSG_HST_ELS_NOLOGIN:\n\t\tport_id = (bsg_request->rqst_data.h_els.port_id[0] << 16) |\n\t\t\t(bsg_request->rqst_data.h_els.port_id[1] << 8) |\n\t\t\tbsg_request->rqst_data.h_els.port_id[2];\n\t\tfallthrough;\n\tcase FC_BSG_RPT_ELS:\n\t\tfc_flags = IBMVFC_FC_ELS;\n\t\tbreak;\n\tcase FC_BSG_HST_CT:\n\t\tissue_login = 1;\n\t\tport_id = (bsg_request->rqst_data.h_ct.port_id[0] << 16) |\n\t\t\t(bsg_request->rqst_data.h_ct.port_id[1] << 8) |\n\t\t\tbsg_request->rqst_data.h_ct.port_id[2];\n\t\tfallthrough;\n\tcase FC_BSG_RPT_CT:\n\t\tfc_flags = IBMVFC_FC_CT_IU;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (port_id == -1)\n\t\treturn -EINVAL;\n\tif (!mutex_trylock(&vhost->passthru_mutex))\n\t\treturn -EBUSY;\n\n\tjob->dd_data = (void *)port_id;\n\treq_seg = dma_map_sg(vhost->dev, job->request_payload.sg_list,\n\t\t\t     job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\n\tif (!req_seg) {\n\t\tmutex_unlock(&vhost->passthru_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\trsp_seg = dma_map_sg(vhost->dev, job->reply_payload.sg_list,\n\t\t\t     job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\n\tif (!rsp_seg) {\n\t\tdma_unmap_sg(vhost->dev, job->request_payload.sg_list,\n\t\t\t     job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\t\tmutex_unlock(&vhost->passthru_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (req_seg > 1 || rsp_seg > 1) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (issue_login)\n\t\trc = ibmvfc_bsg_plogi(vhost, port_id);\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\n\tif (unlikely(rc || (rport && (rc = fc_remote_port_chkready(rport)))) ||\n\t    unlikely((rc = ibmvfc_host_chkready(vhost)))) {\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\tgoto out;\n\t}\n\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);\n\tmad = &evt->iu.passthru;\n\n\tmemset(mad, 0, sizeof(*mad));\n\tmad->common.version = cpu_to_be32(1);\n\tmad->common.opcode = cpu_to_be32(IBMVFC_PASSTHRU);\n\tmad->common.length = cpu_to_be16(sizeof(*mad) - sizeof(mad->fc_iu) - sizeof(mad->iu));\n\n\tmad->cmd_ioba.va = cpu_to_be64(be64_to_cpu(evt->crq.ioba) +\n\t\toffsetof(struct ibmvfc_passthru_mad, iu));\n\tmad->cmd_ioba.len = cpu_to_be32(sizeof(mad->iu));\n\n\tmad->iu.cmd_len = cpu_to_be32(job->request_payload.payload_len);\n\tmad->iu.rsp_len = cpu_to_be32(job->reply_payload.payload_len);\n\tmad->iu.flags = cpu_to_be32(fc_flags);\n\tmad->iu.cancel_key = cpu_to_be32(IBMVFC_PASSTHRU_CANCEL_KEY);\n\n\tmad->iu.cmd.va = cpu_to_be64(sg_dma_address(job->request_payload.sg_list));\n\tmad->iu.cmd.len = cpu_to_be32(sg_dma_len(job->request_payload.sg_list));\n\tmad->iu.rsp.va = cpu_to_be64(sg_dma_address(job->reply_payload.sg_list));\n\tmad->iu.rsp.len = cpu_to_be32(sg_dma_len(job->reply_payload.sg_list));\n\tmad->iu.scsi_id = cpu_to_be64(port_id);\n\tmad->iu.tag = cpu_to_be64((u64)evt);\n\trsp_len = be32_to_cpu(mad->iu.rsp.len);\n\n\tevt->sync_iu = &rsp_iu;\n\tinit_completion(&evt->comp);\n\trc = ibmvfc_send_event(evt, vhost, 0);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tif (rc) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\twait_for_completion(&evt->comp);\n\n\tif (rsp_iu.passthru.common.status)\n\t\trc = -EIO;\n\telse\n\t\tbsg_reply->reply_payload_rcv_len = rsp_len;\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tibmvfc_free_event(evt);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\tbsg_reply->result = rc;\n\tbsg_job_done(job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\trc = 0;\nout:\n\tdma_unmap_sg(vhost->dev, job->request_payload.sg_list,\n\t\t     job->request_payload.sg_cnt, DMA_TO_DEVICE);\n\tdma_unmap_sg(vhost->dev, job->reply_payload.sg_list,\n\t\t     job->reply_payload.sg_cnt, DMA_FROM_DEVICE);\n\tmutex_unlock(&vhost->passthru_mutex);\n\tLEAVE;\n\treturn rc;\n}\n\n \nstatic int ibmvfc_reset_device(struct scsi_device *sdev, int type, char *desc)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tstruct ibmvfc_cmd *tmf;\n\tstruct ibmvfc_event *evt = NULL;\n\tunion ibmvfc_iu rsp_iu;\n\tstruct ibmvfc_fcp_cmd_iu *iu;\n\tstruct ibmvfc_fcp_rsp *fc_rsp = ibmvfc_get_fcp_rsp(vhost, &rsp_iu.cmd);\n\tint rsp_rc = -EBUSY;\n\tunsigned long flags;\n\tint rsp_code = 0;\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tif (vhost->state == IBMVFC_ACTIVE) {\n\t\tif (vhost->using_channels)\n\t\t\tevt = ibmvfc_get_event(&vhost->scsi_scrqs.scrqs[0]);\n\t\telse\n\t\t\tevt = ibmvfc_get_event(&vhost->crq);\n\n\t\tif (!evt) {\n\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_CMD_FORMAT);\n\t\ttmf = ibmvfc_init_vfc_cmd(evt, sdev);\n\t\tiu = ibmvfc_get_fcp_iu(vhost, tmf);\n\n\t\ttmf->flags = cpu_to_be16((IBMVFC_NO_MEM_DESC | IBMVFC_TMF));\n\t\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN))\n\t\t\ttmf->target_wwpn = cpu_to_be64(rport->port_name);\n\t\tiu->tmf_flags = type;\n\t\tevt->sync_iu = &rsp_iu;\n\n\t\tinit_completion(&evt->comp);\n\t\trsp_rc = ibmvfc_send_event(evt, vhost, default_timeout);\n\t}\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tif (rsp_rc != 0) {\n\t\tsdev_printk(KERN_ERR, sdev, \"Failed to send %s reset event. rc=%d\\n\",\n\t\t\t    desc, rsp_rc);\n\t\treturn -EIO;\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"Resetting %s\\n\", desc);\n\twait_for_completion(&evt->comp);\n\n\tif (rsp_iu.cmd.status)\n\t\trsp_code = ibmvfc_get_err_result(vhost, &rsp_iu.cmd);\n\n\tif (rsp_code) {\n\t\tif (fc_rsp->flags & FCP_RSP_LEN_VALID)\n\t\t\trsp_code = fc_rsp->data.info.rsp_code;\n\n\t\tsdev_printk(KERN_ERR, sdev, \"%s reset failed: %s (%x:%x) \"\n\t\t\t    \"flags: %x fcp_rsp: %x, scsi_status: %x\\n\", desc,\n\t\t\t    ibmvfc_get_cmd_error(be16_to_cpu(rsp_iu.cmd.status), be16_to_cpu(rsp_iu.cmd.error)),\n\t\t\t    be16_to_cpu(rsp_iu.cmd.status), be16_to_cpu(rsp_iu.cmd.error), fc_rsp->flags, rsp_code,\n\t\t\t    fc_rsp->scsi_status);\n\t\trsp_rc = -EIO;\n\t} else\n\t\tsdev_printk(KERN_INFO, sdev, \"%s reset successful\\n\", desc);\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tibmvfc_free_event(evt);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\treturn rsp_rc;\n}\n\n \nstatic int ibmvfc_match_rport(struct ibmvfc_event *evt, void *rport)\n{\n\tstruct fc_rport *cmd_rport;\n\n\tif (evt->cmnd) {\n\t\tcmd_rport = starget_to_rport(scsi_target(evt->cmnd->device));\n\t\tif (cmd_rport == rport)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int ibmvfc_match_target(struct ibmvfc_event *evt, void *device)\n{\n\tif (evt->cmnd && scsi_target(evt->cmnd->device) == device)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int ibmvfc_match_lun(struct ibmvfc_event *evt, void *device)\n{\n\tif (evt->cmnd && evt->cmnd->device == device)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic bool ibmvfc_event_is_free(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_event *loop_evt;\n\n\tlist_for_each_entry(loop_evt, &evt->queue->free, queue_list)\n\t\tif (loop_evt == evt)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int ibmvfc_wait_for_ops(struct ibmvfc_host *vhost, void *device,\n\t\t\t       int (*match) (struct ibmvfc_event *, void *))\n{\n\tstruct ibmvfc_event *evt;\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tint wait, i, q_index, q_size;\n\tunsigned long flags;\n\tsigned long timeout = IBMVFC_ABORT_WAIT_TIMEOUT * HZ;\n\tstruct ibmvfc_queue *queues;\n\n\tENTER;\n\tif (vhost->mq_enabled && vhost->using_channels) {\n\t\tqueues = vhost->scsi_scrqs.scrqs;\n\t\tq_size = vhost->scsi_scrqs.active_queues;\n\t} else {\n\t\tqueues = &vhost->crq;\n\t\tq_size = 1;\n\t}\n\n\tdo {\n\t\twait = 0;\n\t\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\t\tfor (q_index = 0; q_index < q_size; q_index++) {\n\t\t\tspin_lock(&queues[q_index].l_lock);\n\t\t\tfor (i = 0; i < queues[q_index].evt_pool.size; i++) {\n\t\t\t\tevt = &queues[q_index].evt_pool.events[i];\n\t\t\t\tif (!ibmvfc_event_is_free(evt)) {\n\t\t\t\t\tif (match(evt, device)) {\n\t\t\t\t\t\tevt->eh_comp = &comp;\n\t\t\t\t\t\twait++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&queues[q_index].l_lock);\n\t\t}\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\t\tif (wait) {\n\t\t\ttimeout = wait_for_completion_timeout(&comp, timeout);\n\n\t\t\tif (!timeout) {\n\t\t\t\twait = 0;\n\t\t\t\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\t\t\t\tfor (q_index = 0; q_index < q_size; q_index++) {\n\t\t\t\t\tspin_lock(&queues[q_index].l_lock);\n\t\t\t\t\tfor (i = 0; i < queues[q_index].evt_pool.size; i++) {\n\t\t\t\t\t\tevt = &queues[q_index].evt_pool.events[i];\n\t\t\t\t\t\tif (!ibmvfc_event_is_free(evt)) {\n\t\t\t\t\t\t\tif (match(evt, device)) {\n\t\t\t\t\t\t\t\tevt->eh_comp = NULL;\n\t\t\t\t\t\t\t\twait++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tspin_unlock(&queues[q_index].l_lock);\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\tif (wait)\n\t\t\t\t\tdev_err(vhost->dev, \"Timed out waiting for aborted commands\\n\");\n\t\t\t\tLEAVE;\n\t\t\t\treturn wait ? FAILED : SUCCESS;\n\t\t\t}\n\t\t}\n\t} while (wait);\n\n\tLEAVE;\n\treturn SUCCESS;\n}\n\nstatic struct ibmvfc_event *ibmvfc_init_tmf(struct ibmvfc_queue *queue,\n\t\t\t\t\t    struct scsi_device *sdev,\n\t\t\t\t\t    int type)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tstruct scsi_target *starget = scsi_target(sdev);\n\tstruct fc_rport *rport = starget_to_rport(starget);\n\tstruct ibmvfc_event *evt;\n\tstruct ibmvfc_tmf *tmf;\n\n\tevt = ibmvfc_get_event(queue);\n\tif (!evt)\n\t\treturn NULL;\n\tibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_MAD_FORMAT);\n\n\ttmf = &evt->iu.tmf;\n\tmemset(tmf, 0, sizeof(*tmf));\n\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN)) {\n\t\ttmf->common.version = cpu_to_be32(2);\n\t\ttmf->target_wwpn = cpu_to_be64(rport->port_name);\n\t} else {\n\t\ttmf->common.version = cpu_to_be32(1);\n\t}\n\ttmf->common.opcode = cpu_to_be32(IBMVFC_TMF_MAD);\n\ttmf->common.length = cpu_to_be16(sizeof(*tmf));\n\ttmf->scsi_id = cpu_to_be64(rport->port_id);\n\tint_to_scsilun(sdev->lun, &tmf->lun);\n\tif (!ibmvfc_check_caps(vhost, IBMVFC_CAN_SUPPRESS_ABTS))\n\t\ttype &= ~IBMVFC_TMF_SUPPRESS_ABTS;\n\tif (vhost->state == IBMVFC_ACTIVE)\n\t\ttmf->flags = cpu_to_be32((type | IBMVFC_TMF_LUA_VALID));\n\telse\n\t\ttmf->flags = cpu_to_be32(((type & IBMVFC_TMF_SUPPRESS_ABTS) | IBMVFC_TMF_LUA_VALID));\n\ttmf->cancel_key = cpu_to_be32((unsigned long)sdev->hostdata);\n\ttmf->my_cancel_key = cpu_to_be32((unsigned long)starget->hostdata);\n\n\tinit_completion(&evt->comp);\n\n\treturn evt;\n}\n\nstatic int ibmvfc_cancel_all_mq(struct scsi_device *sdev, int type)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tstruct ibmvfc_event *evt, *found_evt, *temp;\n\tstruct ibmvfc_queue *queues = vhost->scsi_scrqs.scrqs;\n\tunsigned long flags;\n\tint num_hwq, i;\n\tint fail = 0;\n\tLIST_HEAD(cancelq);\n\tu16 status;\n\n\tENTER;\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tnum_hwq = vhost->scsi_scrqs.active_queues;\n\tfor (i = 0; i < num_hwq; i++) {\n\t\tspin_lock(queues[i].q_lock);\n\t\tspin_lock(&queues[i].l_lock);\n\t\tfound_evt = NULL;\n\t\tlist_for_each_entry(evt, &queues[i].sent, queue_list) {\n\t\t\tif (evt->cmnd && evt->cmnd->device == sdev) {\n\t\t\t\tfound_evt = evt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&queues[i].l_lock);\n\n\t\tif (found_evt && vhost->logged_in) {\n\t\t\tevt = ibmvfc_init_tmf(&queues[i], sdev, type);\n\t\t\tif (!evt) {\n\t\t\t\tspin_unlock(queues[i].q_lock);\n\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tevt->sync_iu = &queues[i].cancel_rsp;\n\t\t\tibmvfc_send_event(evt, vhost, default_timeout);\n\t\t\tlist_add_tail(&evt->cancel, &cancelq);\n\t\t}\n\n\t\tspin_unlock(queues[i].q_lock);\n\t}\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tif (list_empty(&cancelq)) {\n\t\tif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\n\t\t\tsdev_printk(KERN_INFO, sdev, \"No events found to cancel\\n\");\n\t\treturn 0;\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"Cancelling outstanding commands.\\n\");\n\n\tlist_for_each_entry_safe(evt, temp, &cancelq, cancel) {\n\t\twait_for_completion(&evt->comp);\n\t\tstatus = be16_to_cpu(evt->queue->cancel_rsp.mad_common.status);\n\t\tlist_del(&evt->cancel);\n\t\tibmvfc_free_event(evt);\n\n\t\tif (status != IBMVFC_MAD_SUCCESS) {\n\t\t\tsdev_printk(KERN_WARNING, sdev, \"Cancel failed with rc=%x\\n\", status);\n\t\t\tswitch (status) {\n\t\t\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\t\tcase IBMVFC_MAD_CRQ_ERROR:\n\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfail = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fail)\n\t\treturn -EIO;\n\n\tsdev_printk(KERN_INFO, sdev, \"Successfully cancelled outstanding commands\\n\");\n\tLEAVE;\n\treturn 0;\n}\n\nstatic int ibmvfc_cancel_all_sq(struct scsi_device *sdev, int type)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tstruct ibmvfc_event *evt, *found_evt;\n\tunion ibmvfc_iu rsp;\n\tint rsp_rc = -EBUSY;\n\tunsigned long flags;\n\tu16 status;\n\n\tENTER;\n\tfound_evt = NULL;\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tspin_lock(&vhost->crq.l_lock);\n\tlist_for_each_entry(evt, &vhost->crq.sent, queue_list) {\n\t\tif (evt->cmnd && evt->cmnd->device == sdev) {\n\t\t\tfound_evt = evt;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&vhost->crq.l_lock);\n\n\tif (!found_evt) {\n\t\tif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\n\t\t\tsdev_printk(KERN_INFO, sdev, \"No events found to cancel\\n\");\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (vhost->logged_in) {\n\t\tevt = ibmvfc_init_tmf(&vhost->crq, sdev, type);\n\t\tevt->sync_iu = &rsp;\n\t\trsp_rc = ibmvfc_send_event(evt, vhost, default_timeout);\n\t}\n\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tif (rsp_rc != 0) {\n\t\tsdev_printk(KERN_ERR, sdev, \"Failed to send cancel event. rc=%d\\n\", rsp_rc);\n\t\t \n\t\treturn 0;\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"Cancelling outstanding commands.\\n\");\n\n\twait_for_completion(&evt->comp);\n\tstatus = be16_to_cpu(rsp.mad_common.status);\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tibmvfc_free_event(evt);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tif (status != IBMVFC_MAD_SUCCESS) {\n\t\tsdev_printk(KERN_WARNING, sdev, \"Cancel failed with rc=%x\\n\", status);\n\t\tswitch (status) {\n\t\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tcase IBMVFC_MAD_CRQ_ERROR:\n\t\t\t \n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t};\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"Successfully cancelled outstanding commands\\n\");\n\treturn 0;\n}\n\n \nstatic int ibmvfc_cancel_all(struct scsi_device *sdev, int type)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\n\tif (vhost->mq_enabled && vhost->using_channels)\n\t\treturn ibmvfc_cancel_all_mq(sdev, type);\n\telse\n\t\treturn ibmvfc_cancel_all_sq(sdev, type);\n}\n\n \nstatic int ibmvfc_match_key(struct ibmvfc_event *evt, void *key)\n{\n\tunsigned long cancel_key = (unsigned long)key;\n\n\tif (evt->crq.format == IBMVFC_CMD_FORMAT &&\n\t    be32_to_cpu(evt->iu.cmd.cancel_key) == cancel_key)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int ibmvfc_match_evt(struct ibmvfc_event *evt, void *match)\n{\n\tif (evt == match)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int ibmvfc_abort_task_set(struct scsi_device *sdev)\n{\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tstruct ibmvfc_cmd *tmf;\n\tstruct ibmvfc_event *evt, *found_evt;\n\tunion ibmvfc_iu rsp_iu;\n\tstruct ibmvfc_fcp_cmd_iu *iu;\n\tstruct ibmvfc_fcp_rsp *fc_rsp = ibmvfc_get_fcp_rsp(vhost, &rsp_iu.cmd);\n\tint rc, rsp_rc = -EBUSY;\n\tunsigned long flags, timeout = IBMVFC_ABORT_TIMEOUT;\n\tint rsp_code = 0;\n\n\tfound_evt = NULL;\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tspin_lock(&vhost->crq.l_lock);\n\tlist_for_each_entry(evt, &vhost->crq.sent, queue_list) {\n\t\tif (evt->cmnd && evt->cmnd->device == sdev) {\n\t\t\tfound_evt = evt;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&vhost->crq.l_lock);\n\n\tif (!found_evt) {\n\t\tif (vhost->log_level > IBMVFC_DEFAULT_LOG_LEVEL)\n\t\t\tsdev_printk(KERN_INFO, sdev, \"No events found to abort\\n\");\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\treturn 0;\n\t}\n\n\tif (vhost->state == IBMVFC_ACTIVE) {\n\t\tevt = ibmvfc_get_event(&vhost->crq);\n\t\tif (!evt) {\n\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tibmvfc_init_event(evt, ibmvfc_sync_completion, IBMVFC_CMD_FORMAT);\n\t\ttmf = ibmvfc_init_vfc_cmd(evt, sdev);\n\t\tiu = ibmvfc_get_fcp_iu(vhost, tmf);\n\n\t\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN))\n\t\t\ttmf->target_wwpn = cpu_to_be64(rport->port_name);\n\t\tiu->tmf_flags = IBMVFC_ABORT_TASK_SET;\n\t\ttmf->flags = cpu_to_be16((IBMVFC_NO_MEM_DESC | IBMVFC_TMF));\n\t\tevt->sync_iu = &rsp_iu;\n\n\t\ttmf->correlation = cpu_to_be64((u64)evt);\n\n\t\tinit_completion(&evt->comp);\n\t\trsp_rc = ibmvfc_send_event(evt, vhost, default_timeout);\n\t}\n\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tif (rsp_rc != 0) {\n\t\tsdev_printk(KERN_ERR, sdev, \"Failed to send abort. rc=%d\\n\", rsp_rc);\n\t\treturn -EIO;\n\t}\n\n\tsdev_printk(KERN_INFO, sdev, \"Aborting outstanding commands\\n\");\n\ttimeout = wait_for_completion_timeout(&evt->comp, timeout);\n\n\tif (!timeout) {\n\t\trc = ibmvfc_cancel_all(sdev, 0);\n\t\tif (!rc) {\n\t\t\trc = ibmvfc_wait_for_ops(vhost, sdev->hostdata, ibmvfc_match_key);\n\t\t\tif (rc == SUCCESS)\n\t\t\t\trc = 0;\n\t\t}\n\n\t\tif (rc) {\n\t\t\tsdev_printk(KERN_INFO, sdev, \"Cancel failed, resetting host\\n\");\n\t\t\tibmvfc_reset_host(vhost);\n\t\t\trsp_rc = -EIO;\n\t\t\trc = ibmvfc_wait_for_ops(vhost, sdev->hostdata, ibmvfc_match_key);\n\n\t\t\tif (rc == SUCCESS)\n\t\t\t\trsp_rc = 0;\n\n\t\t\trc = ibmvfc_wait_for_ops(vhost, evt, ibmvfc_match_evt);\n\t\t\tif (rc != SUCCESS) {\n\t\t\t\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\t\t\t\tibmvfc_hard_reset_host(vhost);\n\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\trsp_rc = 0;\n\t\t\t}\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rsp_iu.cmd.status)\n\t\trsp_code = ibmvfc_get_err_result(vhost, &rsp_iu.cmd);\n\n\tif (rsp_code) {\n\t\tif (fc_rsp->flags & FCP_RSP_LEN_VALID)\n\t\t\trsp_code = fc_rsp->data.info.rsp_code;\n\n\t\tsdev_printk(KERN_ERR, sdev, \"Abort failed: %s (%x:%x) \"\n\t\t\t    \"flags: %x fcp_rsp: %x, scsi_status: %x\\n\",\n\t\t\t    ibmvfc_get_cmd_error(be16_to_cpu(rsp_iu.cmd.status), be16_to_cpu(rsp_iu.cmd.error)),\n\t\t\t    be16_to_cpu(rsp_iu.cmd.status), be16_to_cpu(rsp_iu.cmd.error), fc_rsp->flags, rsp_code,\n\t\t\t    fc_rsp->scsi_status);\n\t\trsp_rc = -EIO;\n\t} else\n\t\tsdev_printk(KERN_INFO, sdev, \"Abort successful\\n\");\n\nout:\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tibmvfc_free_event(evt);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\treturn rsp_rc;\n}\n\n \nstatic int ibmvfc_eh_abort_handler(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tint cancel_rc, block_rc;\n\tint rc = FAILED;\n\n\tENTER;\n\tblock_rc = fc_block_scsi_eh(cmd);\n\tibmvfc_wait_while_resetting(vhost);\n\tif (block_rc != FAST_IO_FAIL) {\n\t\tcancel_rc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_ABORT_TASK_SET);\n\t\tibmvfc_abort_task_set(sdev);\n\t} else\n\t\tcancel_rc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_SUPPRESS_ABTS);\n\n\tif (!cancel_rc)\n\t\trc = ibmvfc_wait_for_ops(vhost, sdev, ibmvfc_match_lun);\n\n\tif (block_rc == FAST_IO_FAIL && rc != FAILED)\n\t\trc = FAST_IO_FAIL;\n\n\tLEAVE;\n\treturn rc;\n}\n\n \nstatic int ibmvfc_eh_device_reset_handler(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tint cancel_rc, block_rc, reset_rc = 0;\n\tint rc = FAILED;\n\n\tENTER;\n\tblock_rc = fc_block_scsi_eh(cmd);\n\tibmvfc_wait_while_resetting(vhost);\n\tif (block_rc != FAST_IO_FAIL) {\n\t\tcancel_rc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_LUN_RESET);\n\t\treset_rc = ibmvfc_reset_device(sdev, IBMVFC_LUN_RESET, \"LUN\");\n\t} else\n\t\tcancel_rc = ibmvfc_cancel_all(sdev, IBMVFC_TMF_SUPPRESS_ABTS);\n\n\tif (!cancel_rc && !reset_rc)\n\t\trc = ibmvfc_wait_for_ops(vhost, sdev, ibmvfc_match_lun);\n\n\tif (block_rc == FAST_IO_FAIL && rc != FAILED)\n\t\trc = FAST_IO_FAIL;\n\n\tLEAVE;\n\treturn rc;\n}\n\n \nstatic void ibmvfc_dev_cancel_all_noreset(struct scsi_device *sdev, void *data)\n{\n\tunsigned long *rc = data;\n\t*rc |= ibmvfc_cancel_all(sdev, IBMVFC_TMF_SUPPRESS_ABTS);\n}\n\n \nstatic void ibmvfc_dev_cancel_all_reset(struct scsi_device *sdev, void *data)\n{\n\tunsigned long *rc = data;\n\t*rc |= ibmvfc_cancel_all(sdev, IBMVFC_TMF_TGT_RESET);\n}\n\n \nstatic int ibmvfc_eh_target_reset_handler(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct ibmvfc_host *vhost = shost_priv(sdev->host);\n\tstruct scsi_target *starget = scsi_target(sdev);\n\tint block_rc;\n\tint reset_rc = 0;\n\tint rc = FAILED;\n\tunsigned long cancel_rc = 0;\n\n\tENTER;\n\tblock_rc = fc_block_scsi_eh(cmd);\n\tibmvfc_wait_while_resetting(vhost);\n\tif (block_rc != FAST_IO_FAIL) {\n\t\tstarget_for_each_device(starget, &cancel_rc, ibmvfc_dev_cancel_all_reset);\n\t\treset_rc = ibmvfc_reset_device(sdev, IBMVFC_TARGET_RESET, \"target\");\n\t} else\n\t\tstarget_for_each_device(starget, &cancel_rc, ibmvfc_dev_cancel_all_noreset);\n\n\tif (!cancel_rc && !reset_rc)\n\t\trc = ibmvfc_wait_for_ops(vhost, starget, ibmvfc_match_target);\n\n\tif (block_rc == FAST_IO_FAIL && rc != FAILED)\n\t\trc = FAST_IO_FAIL;\n\n\tLEAVE;\n\treturn rc;\n}\n\n \nstatic int ibmvfc_eh_host_reset_handler(struct scsi_cmnd *cmd)\n{\n\tint rc;\n\tstruct ibmvfc_host *vhost = shost_priv(cmd->device->host);\n\n\tdev_err(vhost->dev, \"Resetting connection due to error recovery\\n\");\n\trc = ibmvfc_issue_fc_host_lip(vhost->host);\n\n\treturn rc ? FAILED : SUCCESS;\n}\n\n \nstatic void ibmvfc_terminate_rport_io(struct fc_rport *rport)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tstruct fc_rport *dev_rport;\n\tstruct scsi_device *sdev;\n\tstruct ibmvfc_target *tgt;\n\tunsigned long rc, flags;\n\tunsigned int found;\n\n\tENTER;\n\tshost_for_each_device(sdev, shost) {\n\t\tdev_rport = starget_to_rport(scsi_target(sdev));\n\t\tif (dev_rport != rport)\n\t\t\tcontinue;\n\t\tibmvfc_cancel_all(sdev, IBMVFC_TMF_SUPPRESS_ABTS);\n\t}\n\n\trc = ibmvfc_wait_for_ops(vhost, rport, ibmvfc_match_rport);\n\n\tif (rc == FAILED)\n\t\tibmvfc_issue_fc_host_lip(shost);\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tfound = 0;\n\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\tif (tgt->scsi_id == rport->port_id) {\n\t\t\tfound++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && tgt->action == IBMVFC_TGT_ACTION_LOGOUT_DELETED_RPORT) {\n\t\t \n\t\tibmvfc_del_tgt(tgt);\n\t\tibmvfc_reinit_host(vhost);\n\t}\n\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\tLEAVE;\n}\n\nstatic const struct ibmvfc_async_desc ae_desc [] = {\n\t{ \"PLOGI\",\tIBMVFC_AE_ELS_PLOGI,\tIBMVFC_DEFAULT_LOG_LEVEL + 1 },\n\t{ \"LOGO\",\tIBMVFC_AE_ELS_LOGO,\tIBMVFC_DEFAULT_LOG_LEVEL + 1 },\n\t{ \"PRLO\",\tIBMVFC_AE_ELS_PRLO,\tIBMVFC_DEFAULT_LOG_LEVEL + 1 },\n\t{ \"N-Port SCN\",\tIBMVFC_AE_SCN_NPORT,\tIBMVFC_DEFAULT_LOG_LEVEL + 1 },\n\t{ \"Group SCN\",\tIBMVFC_AE_SCN_GROUP,\tIBMVFC_DEFAULT_LOG_LEVEL + 1 },\n\t{ \"Domain SCN\",\tIBMVFC_AE_SCN_DOMAIN,\tIBMVFC_DEFAULT_LOG_LEVEL },\n\t{ \"Fabric SCN\",\tIBMVFC_AE_SCN_FABRIC,\tIBMVFC_DEFAULT_LOG_LEVEL },\n\t{ \"Link Up\",\tIBMVFC_AE_LINK_UP,\tIBMVFC_DEFAULT_LOG_LEVEL },\n\t{ \"Link Down\",\tIBMVFC_AE_LINK_DOWN,\tIBMVFC_DEFAULT_LOG_LEVEL },\n\t{ \"Link Dead\",\tIBMVFC_AE_LINK_DEAD,\tIBMVFC_DEFAULT_LOG_LEVEL },\n\t{ \"Halt\",\tIBMVFC_AE_HALT,\t\tIBMVFC_DEFAULT_LOG_LEVEL },\n\t{ \"Resume\",\tIBMVFC_AE_RESUME,\tIBMVFC_DEFAULT_LOG_LEVEL },\n\t{ \"Adapter Failed\", IBMVFC_AE_ADAPTER_FAILED, IBMVFC_DEFAULT_LOG_LEVEL },\n};\n\nstatic const struct ibmvfc_async_desc unknown_ae = {\n\t\"Unknown async\", 0, IBMVFC_DEFAULT_LOG_LEVEL\n};\n\n \nstatic const struct ibmvfc_async_desc *ibmvfc_get_ae_desc(u64 ae)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ae_desc); i++)\n\t\tif (ae_desc[i].ae == ae)\n\t\t\treturn &ae_desc[i];\n\n\treturn &unknown_ae;\n}\n\nstatic const struct {\n\tenum ibmvfc_ae_link_state state;\n\tconst char *desc;\n} link_desc [] = {\n\t{ IBMVFC_AE_LS_LINK_UP,\t\t\" link up\" },\n\t{ IBMVFC_AE_LS_LINK_BOUNCED,\t\" link bounced\" },\n\t{ IBMVFC_AE_LS_LINK_DOWN,\t\" link down\" },\n\t{ IBMVFC_AE_LS_LINK_DEAD,\t\" link dead\" },\n};\n\n \nstatic const char *ibmvfc_get_link_state(enum ibmvfc_ae_link_state state)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(link_desc); i++)\n\t\tif (link_desc[i].state == state)\n\t\t\treturn link_desc[i].desc;\n\n\treturn \"\";\n}\n\n \nstatic void ibmvfc_handle_async(struct ibmvfc_async_crq *crq,\n\t\t\t\tstruct ibmvfc_host *vhost)\n{\n\tconst struct ibmvfc_async_desc *desc = ibmvfc_get_ae_desc(be64_to_cpu(crq->event));\n\tstruct ibmvfc_target *tgt;\n\n\tibmvfc_log(vhost, desc->log_level, \"%s event received. scsi_id: %llx, wwpn: %llx,\"\n\t\t   \" node_name: %llx%s\\n\", desc->desc, be64_to_cpu(crq->scsi_id),\n\t\t   be64_to_cpu(crq->wwpn), be64_to_cpu(crq->node_name),\n\t\t   ibmvfc_get_link_state(crq->link_state));\n\n\tswitch (be64_to_cpu(crq->event)) {\n\tcase IBMVFC_AE_RESUME:\n\t\tswitch (crq->link_state) {\n\t\tcase IBMVFC_AE_LS_LINK_DOWN:\n\t\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\n\t\t\tbreak;\n\t\tcase IBMVFC_AE_LS_LINK_DEAD:\n\t\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\t\tbreak;\n\t\tcase IBMVFC_AE_LS_LINK_UP:\n\t\tcase IBMVFC_AE_LS_LINK_BOUNCED:\n\t\tdefault:\n\t\t\tvhost->events_to_log |= IBMVFC_AE_LINKUP;\n\t\t\tvhost->delay_init = 1;\n\t\t\t__ibmvfc_reset_host(vhost);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase IBMVFC_AE_LINK_UP:\n\t\tvhost->events_to_log |= IBMVFC_AE_LINKUP;\n\t\tvhost->delay_init = 1;\n\t\t__ibmvfc_reset_host(vhost);\n\t\tbreak;\n\tcase IBMVFC_AE_SCN_FABRIC:\n\tcase IBMVFC_AE_SCN_DOMAIN:\n\t\tvhost->events_to_log |= IBMVFC_AE_RSCN;\n\t\tif (vhost->state < IBMVFC_HALTED) {\n\t\t\tvhost->delay_init = 1;\n\t\t\t__ibmvfc_reset_host(vhost);\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_AE_SCN_NPORT:\n\tcase IBMVFC_AE_SCN_GROUP:\n\t\tvhost->events_to_log |= IBMVFC_AE_RSCN;\n\t\tibmvfc_reinit_host(vhost);\n\t\tbreak;\n\tcase IBMVFC_AE_ELS_LOGO:\n\tcase IBMVFC_AE_ELS_PRLO:\n\tcase IBMVFC_AE_ELS_PLOGI:\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\t\tif (!crq->scsi_id && !crq->wwpn && !crq->node_name)\n\t\t\t\tbreak;\n\t\t\tif (crq->scsi_id && cpu_to_be64(tgt->scsi_id) != crq->scsi_id)\n\t\t\t\tcontinue;\n\t\t\tif (crq->wwpn && cpu_to_be64(tgt->ids.port_name) != crq->wwpn)\n\t\t\t\tcontinue;\n\t\t\tif (crq->node_name && cpu_to_be64(tgt->ids.node_name) != crq->node_name)\n\t\t\t\tcontinue;\n\t\t\tif (tgt->need_login && be64_to_cpu(crq->event) == IBMVFC_AE_ELS_LOGO)\n\t\t\t\ttgt->logo_rcvd = 1;\n\t\t\tif (!tgt->need_login || be64_to_cpu(crq->event) == IBMVFC_AE_ELS_PLOGI) {\n\t\t\t\tibmvfc_del_tgt(tgt);\n\t\t\t\tibmvfc_reinit_host(vhost);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_AE_LINK_DOWN:\n\tcase IBMVFC_AE_ADAPTER_FAILED:\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\n\t\tbreak;\n\tcase IBMVFC_AE_LINK_DEAD:\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\tbreak;\n\tcase IBMVFC_AE_HALT:\n\t\tibmvfc_link_down(vhost, IBMVFC_HALTED);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(vhost->dev, \"Unknown async event received: %lld\\n\", crq->event);\n\t\tbreak;\n\t}\n}\n\n \nstatic void ibmvfc_handle_crq(struct ibmvfc_crq *crq, struct ibmvfc_host *vhost,\n\t\t\t      struct list_head *evt_doneq)\n{\n\tlong rc;\n\tstruct ibmvfc_event *evt = (struct ibmvfc_event *)be64_to_cpu(crq->ioba);\n\n\tswitch (crq->valid) {\n\tcase IBMVFC_CRQ_INIT_RSP:\n\t\tswitch (crq->format) {\n\t\tcase IBMVFC_CRQ_INIT:\n\t\t\tdev_info(vhost->dev, \"Partner initialized\\n\");\n\t\t\t \n\t\t\trc = ibmvfc_send_crq_init_complete(vhost);\n\t\t\tif (rc == 0)\n\t\t\t\tibmvfc_init_host(vhost);\n\t\t\telse\n\t\t\t\tdev_err(vhost->dev, \"Unable to send init rsp. rc=%ld\\n\", rc);\n\t\t\tbreak;\n\t\tcase IBMVFC_CRQ_INIT_COMPLETE:\n\t\t\tdev_info(vhost->dev, \"Partner initialization complete\\n\");\n\t\t\tibmvfc_init_host(vhost);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(vhost->dev, \"Unknown crq message type: %d\\n\", crq->format);\n\t\t}\n\t\treturn;\n\tcase IBMVFC_CRQ_XPORT_EVENT:\n\t\tvhost->state = IBMVFC_NO_CRQ;\n\t\tvhost->logged_in = 0;\n\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);\n\t\tif (crq->format == IBMVFC_PARTITION_MIGRATED) {\n\t\t\t \n\t\t\tdev_info(vhost->dev, \"Partition migrated, Re-enabling adapter\\n\");\n\t\t\tvhost->client_migrated = 1;\n\n\t\t\tscsi_block_requests(vhost->host);\n\t\t\tibmvfc_purge_requests(vhost, DID_REQUEUE);\n\t\t\tibmvfc_set_host_state(vhost, IBMVFC_LINK_DOWN);\n\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_REENABLE);\n\t\t\twake_up(&vhost->work_wait_q);\n\t\t} else if (crq->format == IBMVFC_PARTNER_FAILED || crq->format == IBMVFC_PARTNER_DEREGISTER) {\n\t\t\tdev_err(vhost->dev, \"Host partner adapter deregistered or failed (rc=%d)\\n\", crq->format);\n\t\t\tibmvfc_purge_requests(vhost, DID_ERROR);\n\t\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\n\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_RESET);\n\t\t} else {\n\t\t\tdev_err(vhost->dev, \"Received unknown transport event from partner (rc=%d)\\n\", crq->format);\n\t\t}\n\t\treturn;\n\tcase IBMVFC_CRQ_CMD_RSP:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(vhost->dev, \"Got an invalid message type 0x%02x\\n\", crq->valid);\n\t\treturn;\n\t}\n\n\tif (crq->format == IBMVFC_ASYNC_EVENT)\n\t\treturn;\n\n\t \n\tif (unlikely(!ibmvfc_valid_event(&vhost->crq.evt_pool, evt))) {\n\t\tdev_err(vhost->dev, \"Returned correlation_token 0x%08llx is invalid!\\n\",\n\t\t\tcrq->ioba);\n\t\treturn;\n\t}\n\n\tif (unlikely(atomic_dec_if_positive(&evt->active))) {\n\t\tdev_err(vhost->dev, \"Received duplicate correlation_token 0x%08llx!\\n\",\n\t\t\tcrq->ioba);\n\t\treturn;\n\t}\n\n\tspin_lock(&evt->queue->l_lock);\n\tlist_move_tail(&evt->queue_list, evt_doneq);\n\tspin_unlock(&evt->queue->l_lock);\n}\n\n \nstatic int ibmvfc_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\tunsigned long flags;\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tint done = 0;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (!vhost->scan_timeout)\n\t\tdone = 1;\n\telse if (time >= (vhost->scan_timeout * HZ)) {\n\t\tdev_info(vhost->dev, \"Scan taking longer than %d seconds, \"\n\t\t\t \"continuing initialization\\n\", vhost->scan_timeout);\n\t\tdone = 1;\n\t}\n\n\tif (vhost->scan_complete) {\n\t\tvhost->scan_timeout = init_timeout;\n\t\tdone = 1;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn done;\n}\n\n \nstatic int ibmvfc_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags = 0;\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tsdev->hostdata = (void *)(unsigned long)vhost->task_set++;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn 0;\n}\n\n \nstatic int ibmvfc_target_alloc(struct scsi_target *starget)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tstarget->hostdata = (void *)(unsigned long)vhost->task_set++;\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn 0;\n}\n\n \nstatic int ibmvfc_slave_configure(struct scsi_device *sdev)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tif (sdev->type == TYPE_DISK) {\n\t\tsdev->allow_restart = 1;\n\t\tblk_queue_rq_timeout(sdev->request_queue, 120 * HZ);\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn 0;\n}\n\n \nstatic int ibmvfc_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tif (qdepth > IBMVFC_MAX_CMDS_PER_LUN)\n\t\tqdepth = IBMVFC_MAX_CMDS_PER_LUN;\n\n\treturn scsi_change_queue_depth(sdev, qdepth);\n}\n\nstatic ssize_t ibmvfc_show_host_partition_name(struct device *dev,\n\t\t\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\tvhost->login_buf->resp.partition_name);\n}\n\nstatic ssize_t ibmvfc_show_host_device_name(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\tvhost->login_buf->resp.device_name);\n}\n\nstatic ssize_t ibmvfc_show_host_loc_code(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\tvhost->login_buf->resp.port_loc_code);\n}\n\nstatic ssize_t ibmvfc_show_host_drc_name(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\tvhost->login_buf->resp.drc_name);\n}\n\nstatic ssize_t ibmvfc_show_host_npiv_version(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", be32_to_cpu(vhost->login_buf->resp.version));\n}\n\nstatic ssize_t ibmvfc_show_host_capabilities(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\treturn snprintf(buf, PAGE_SIZE, \"%llx\\n\", be64_to_cpu(vhost->login_buf->resp.capabilities));\n}\n\n \nstatic ssize_t ibmvfc_show_log_level(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags = 0;\n\tint len;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d\\n\", vhost->log_level);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn len;\n}\n\n \nstatic ssize_t ibmvfc_store_log_level(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tvhost->log_level = simple_strtoul(buf, NULL, 10);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn strlen(buf);\n}\n\nstatic ssize_t ibmvfc_show_scsi_channels(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags = 0;\n\tint len;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d\\n\", vhost->client_scsi_channels);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn len;\n}\n\nstatic ssize_t ibmvfc_store_scsi_channels(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags = 0;\n\tunsigned int channels;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tchannels = simple_strtoul(buf, NULL, 10);\n\tvhost->client_scsi_channels = min(channels, nr_scsi_hw_queues);\n\tibmvfc_hard_reset_host(vhost);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn strlen(buf);\n}\n\nstatic DEVICE_ATTR(partition_name, S_IRUGO, ibmvfc_show_host_partition_name, NULL);\nstatic DEVICE_ATTR(device_name, S_IRUGO, ibmvfc_show_host_device_name, NULL);\nstatic DEVICE_ATTR(port_loc_code, S_IRUGO, ibmvfc_show_host_loc_code, NULL);\nstatic DEVICE_ATTR(drc_name, S_IRUGO, ibmvfc_show_host_drc_name, NULL);\nstatic DEVICE_ATTR(npiv_version, S_IRUGO, ibmvfc_show_host_npiv_version, NULL);\nstatic DEVICE_ATTR(capabilities, S_IRUGO, ibmvfc_show_host_capabilities, NULL);\nstatic DEVICE_ATTR(log_level, S_IRUGO | S_IWUSR,\n\t\t   ibmvfc_show_log_level, ibmvfc_store_log_level);\nstatic DEVICE_ATTR(nr_scsi_channels, S_IRUGO | S_IWUSR,\n\t\t   ibmvfc_show_scsi_channels, ibmvfc_store_scsi_channels);\n\n#ifdef CONFIG_SCSI_IBMVFC_TRACE\n \nstatic ssize_t ibmvfc_read_trace(struct file *filp, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *bin_attr,\n\t\t\t\t char *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct ibmvfc_host *vhost = shost_priv(shost);\n\tunsigned long flags = 0;\n\tint size = IBMVFC_TRACE_SIZE;\n\tchar *src = (char *)vhost->trace;\n\n\tif (off > size)\n\t\treturn 0;\n\tif (off + count > size) {\n\t\tsize -= off;\n\t\tcount = size;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tmemcpy(buf, &src[off], count);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn count;\n}\n\nstatic struct bin_attribute ibmvfc_trace_attr = {\n\t.attr =\t{\n\t\t.name = \"trace\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.size = 0,\n\t.read = ibmvfc_read_trace,\n};\n#endif\n\nstatic struct attribute *ibmvfc_host_attrs[] = {\n\t&dev_attr_partition_name.attr,\n\t&dev_attr_device_name.attr,\n\t&dev_attr_port_loc_code.attr,\n\t&dev_attr_drc_name.attr,\n\t&dev_attr_npiv_version.attr,\n\t&dev_attr_capabilities.attr,\n\t&dev_attr_log_level.attr,\n\t&dev_attr_nr_scsi_channels.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(ibmvfc_host);\n\nstatic const struct scsi_host_template driver_template = {\n\t.module = THIS_MODULE,\n\t.name = \"IBM POWER Virtual FC Adapter\",\n\t.proc_name = IBMVFC_NAME,\n\t.queuecommand = ibmvfc_queuecommand,\n\t.eh_timed_out = fc_eh_timed_out,\n\t.eh_abort_handler = ibmvfc_eh_abort_handler,\n\t.eh_device_reset_handler = ibmvfc_eh_device_reset_handler,\n\t.eh_target_reset_handler = ibmvfc_eh_target_reset_handler,\n\t.eh_host_reset_handler = ibmvfc_eh_host_reset_handler,\n\t.slave_alloc = ibmvfc_slave_alloc,\n\t.slave_configure = ibmvfc_slave_configure,\n\t.target_alloc = ibmvfc_target_alloc,\n\t.scan_finished = ibmvfc_scan_finished,\n\t.change_queue_depth = ibmvfc_change_queue_depth,\n\t.cmd_per_lun = 16,\n\t.can_queue = IBMVFC_MAX_REQUESTS_DEFAULT,\n\t.this_id = -1,\n\t.sg_tablesize = SG_ALL,\n\t.max_sectors = IBMVFC_MAX_SECTORS,\n\t.shost_groups = ibmvfc_host_groups,\n\t.track_queue_depth = 1,\n\t.host_tagset = 1,\n};\n\n \nstatic struct ibmvfc_async_crq *ibmvfc_next_async_crq(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_queue *async_crq = &vhost->async_crq;\n\tstruct ibmvfc_async_crq *crq;\n\n\tcrq = &async_crq->msgs.async[async_crq->cur];\n\tif (crq->valid & 0x80) {\n\t\tif (++async_crq->cur == async_crq->size)\n\t\t\tasync_crq->cur = 0;\n\t\trmb();\n\t} else\n\t\tcrq = NULL;\n\n\treturn crq;\n}\n\n \nstatic struct ibmvfc_crq *ibmvfc_next_crq(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_queue *queue = &vhost->crq;\n\tstruct ibmvfc_crq *crq;\n\n\tcrq = &queue->msgs.crq[queue->cur];\n\tif (crq->valid & 0x80) {\n\t\tif (++queue->cur == queue->size)\n\t\t\tqueue->cur = 0;\n\t\trmb();\n\t} else\n\t\tcrq = NULL;\n\n\treturn crq;\n}\n\n \nstatic irqreturn_t ibmvfc_interrupt(int irq, void *dev_instance)\n{\n\tstruct ibmvfc_host *vhost = (struct ibmvfc_host *)dev_instance;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tvio_disable_interrupts(to_vio_dev(vhost->dev));\n\ttasklet_schedule(&vhost->tasklet);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ibmvfc_tasklet(void *data)\n{\n\tstruct ibmvfc_host *vhost = data;\n\tstruct vio_dev *vdev = to_vio_dev(vhost->dev);\n\tstruct ibmvfc_crq *crq;\n\tstruct ibmvfc_async_crq *async;\n\tstruct ibmvfc_event *evt, *temp;\n\tunsigned long flags;\n\tint done = 0;\n\tLIST_HEAD(evt_doneq);\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tspin_lock(vhost->crq.q_lock);\n\twhile (!done) {\n\t\t \n\t\twhile ((async = ibmvfc_next_async_crq(vhost)) != NULL) {\n\t\t\tibmvfc_handle_async(async, vhost);\n\t\t\tasync->valid = 0;\n\t\t\twmb();\n\t\t}\n\n\t\t \n\t\twhile ((crq = ibmvfc_next_crq(vhost)) != NULL) {\n\t\t\tibmvfc_handle_crq(crq, vhost, &evt_doneq);\n\t\t\tcrq->valid = 0;\n\t\t\twmb();\n\t\t}\n\n\t\tvio_enable_interrupts(vdev);\n\t\tif ((async = ibmvfc_next_async_crq(vhost)) != NULL) {\n\t\t\tvio_disable_interrupts(vdev);\n\t\t\tibmvfc_handle_async(async, vhost);\n\t\t\tasync->valid = 0;\n\t\t\twmb();\n\t\t} else if ((crq = ibmvfc_next_crq(vhost)) != NULL) {\n\t\t\tvio_disable_interrupts(vdev);\n\t\t\tibmvfc_handle_crq(crq, vhost, &evt_doneq);\n\t\t\tcrq->valid = 0;\n\t\t\twmb();\n\t\t} else\n\t\t\tdone = 1;\n\t}\n\n\tspin_unlock(vhost->crq.q_lock);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tlist_for_each_entry_safe(evt, temp, &evt_doneq, queue_list) {\n\t\tdel_timer(&evt->timer);\n\t\tlist_del(&evt->queue_list);\n\t\tibmvfc_trc_end(evt);\n\t\tevt->done(evt);\n\t}\n}\n\nstatic int ibmvfc_toggle_scrq_irq(struct ibmvfc_queue *scrq, int enable)\n{\n\tstruct device *dev = scrq->vhost->dev;\n\tstruct vio_dev *vdev = to_vio_dev(dev);\n\tunsigned long rc;\n\tint irq_action = H_ENABLE_VIO_INTERRUPT;\n\n\tif (!enable)\n\t\tirq_action = H_DISABLE_VIO_INTERRUPT;\n\n\trc = plpar_hcall_norets(H_VIOCTL, vdev->unit_address, irq_action,\n\t\t\t\tscrq->hw_irq, 0, 0);\n\n\tif (rc)\n\t\tdev_err(dev, \"Couldn't %s sub-crq[%lu] irq. rc=%ld\\n\",\n\t\t\tenable ? \"enable\" : \"disable\", scrq->hwq_id, rc);\n\n\treturn rc;\n}\n\nstatic void ibmvfc_handle_scrq(struct ibmvfc_crq *crq, struct ibmvfc_host *vhost,\n\t\t\t       struct list_head *evt_doneq)\n{\n\tstruct ibmvfc_event *evt = (struct ibmvfc_event *)be64_to_cpu(crq->ioba);\n\n\tswitch (crq->valid) {\n\tcase IBMVFC_CRQ_CMD_RSP:\n\t\tbreak;\n\tcase IBMVFC_CRQ_XPORT_EVENT:\n\t\treturn;\n\tdefault:\n\t\tdev_err(vhost->dev, \"Got and invalid message type 0x%02x\\n\", crq->valid);\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(!ibmvfc_valid_event(&evt->queue->evt_pool, evt))) {\n\t\tdev_err(vhost->dev, \"Returned correlation_token 0x%08llx is invalid!\\n\",\n\t\t\tcrq->ioba);\n\t\treturn;\n\t}\n\n\tif (unlikely(atomic_dec_if_positive(&evt->active))) {\n\t\tdev_err(vhost->dev, \"Received duplicate correlation_token 0x%08llx!\\n\",\n\t\t\tcrq->ioba);\n\t\treturn;\n\t}\n\n\tspin_lock(&evt->queue->l_lock);\n\tlist_move_tail(&evt->queue_list, evt_doneq);\n\tspin_unlock(&evt->queue->l_lock);\n}\n\nstatic struct ibmvfc_crq *ibmvfc_next_scrq(struct ibmvfc_queue *scrq)\n{\n\tstruct ibmvfc_crq *crq;\n\n\tcrq = &scrq->msgs.scrq[scrq->cur].crq;\n\tif (crq->valid & 0x80) {\n\t\tif (++scrq->cur == scrq->size)\n\t\t\tscrq->cur = 0;\n\t\trmb();\n\t} else\n\t\tcrq = NULL;\n\n\treturn crq;\n}\n\nstatic void ibmvfc_drain_sub_crq(struct ibmvfc_queue *scrq)\n{\n\tstruct ibmvfc_crq *crq;\n\tstruct ibmvfc_event *evt, *temp;\n\tunsigned long flags;\n\tint done = 0;\n\tLIST_HEAD(evt_doneq);\n\n\tspin_lock_irqsave(scrq->q_lock, flags);\n\twhile (!done) {\n\t\twhile ((crq = ibmvfc_next_scrq(scrq)) != NULL) {\n\t\t\tibmvfc_handle_scrq(crq, scrq->vhost, &evt_doneq);\n\t\t\tcrq->valid = 0;\n\t\t\twmb();\n\t\t}\n\n\t\tibmvfc_toggle_scrq_irq(scrq, 1);\n\t\tif ((crq = ibmvfc_next_scrq(scrq)) != NULL) {\n\t\t\tibmvfc_toggle_scrq_irq(scrq, 0);\n\t\t\tibmvfc_handle_scrq(crq, scrq->vhost, &evt_doneq);\n\t\t\tcrq->valid = 0;\n\t\t\twmb();\n\t\t} else\n\t\t\tdone = 1;\n\t}\n\tspin_unlock_irqrestore(scrq->q_lock, flags);\n\n\tlist_for_each_entry_safe(evt, temp, &evt_doneq, queue_list) {\n\t\tdel_timer(&evt->timer);\n\t\tlist_del(&evt->queue_list);\n\t\tibmvfc_trc_end(evt);\n\t\tevt->done(evt);\n\t}\n}\n\nstatic irqreturn_t ibmvfc_interrupt_scsi(int irq, void *scrq_instance)\n{\n\tstruct ibmvfc_queue *scrq = (struct ibmvfc_queue *)scrq_instance;\n\n\tibmvfc_toggle_scrq_irq(scrq, 0);\n\tibmvfc_drain_sub_crq(scrq);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ibmvfc_init_tgt(struct ibmvfc_target *tgt,\n\t\t\t    void (*job_step) (struct ibmvfc_target *))\n{\n\tif (!ibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT))\n\t\ttgt->job_step = job_step;\n\twake_up(&tgt->vhost->work_wait_q);\n}\n\n \nstatic int ibmvfc_retry_tgt_init(struct ibmvfc_target *tgt,\n\t\t\t\t  void (*job_step) (struct ibmvfc_target *))\n{\n\tif (++tgt->init_retries > IBMVFC_MAX_TGT_INIT_RETRIES) {\n\t\tibmvfc_del_tgt(tgt);\n\t\twake_up(&tgt->vhost->work_wait_q);\n\t\treturn 0;\n\t} else\n\t\tibmvfc_init_tgt(tgt, job_step);\n\treturn 1;\n}\n\n \nstatic const struct {\n\tint code;\n\tint retry;\n\tint logged_in;\n} prli_rsp [] = {\n\t{ 0, 1, 0 },\n\t{ 1, 0, 1 },\n\t{ 2, 1, 0 },\n\t{ 3, 1, 0 },\n\t{ 4, 0, 0 },\n\t{ 5, 0, 0 },\n\t{ 6, 0, 1 },\n\t{ 7, 0, 0 },\n\t{ 8, 1, 0 },\n};\n\n \nstatic int ibmvfc_get_prli_rsp(u16 flags)\n{\n\tint i;\n\tint code = (flags & 0x0f00) >> 8;\n\n\tfor (i = 0; i < ARRAY_SIZE(prli_rsp); i++)\n\t\tif (prli_rsp[i].code == code)\n\t\t\treturn i;\n\n\treturn 0;\n}\n\n \nstatic void ibmvfc_tgt_prli_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_target *tgt = evt->tgt;\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_process_login *rsp = &evt->xfer_iu->prli;\n\tstruct ibmvfc_prli_svc_parms *parms = &rsp->parms;\n\tu32 status = be16_to_cpu(rsp->common.status);\n\tint index, level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tvhost->discovery_threads--;\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\tswitch (status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\ttgt_dbg(tgt, \"Process Login succeeded: %X %02X %04X\\n\",\n\t\t\tparms->type, parms->flags, parms->service_parms);\n\n\t\tif (parms->type == IBMVFC_SCSI_FCP_TYPE) {\n\t\t\tindex = ibmvfc_get_prli_rsp(be16_to_cpu(parms->flags));\n\t\t\tif (prli_rsp[index].logged_in) {\n\t\t\t\tif (be16_to_cpu(parms->flags) & IBMVFC_PRLI_EST_IMG_PAIR) {\n\t\t\t\t\ttgt->need_login = 0;\n\t\t\t\t\ttgt->ids.roles = 0;\n\t\t\t\t\tif (be32_to_cpu(parms->service_parms) & IBMVFC_PRLI_TARGET_FUNC)\n\t\t\t\t\t\ttgt->ids.roles |= FC_PORT_ROLE_FCP_TARGET;\n\t\t\t\t\tif (be32_to_cpu(parms->service_parms) & IBMVFC_PRLI_INITIATOR_FUNC)\n\t\t\t\t\t\ttgt->ids.roles |= FC_PORT_ROLE_FCP_INITIATOR;\n\t\t\t\t\ttgt->add_rport = 1;\n\t\t\t\t} else\n\t\t\t\t\tibmvfc_del_tgt(tgt);\n\t\t\t} else if (prli_rsp[index].retry)\n\t\t\t\tibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_prli);\n\t\t\telse\n\t\t\t\tibmvfc_del_tgt(tgt);\n\t\t} else\n\t\t\tibmvfc_del_tgt(tgt);\n\t\tbreak;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tbreak;\n\tcase IBMVFC_MAD_CRQ_ERROR:\n\t\tibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_prli);\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\tdefault:\n\t\tif ((be16_to_cpu(rsp->status) & IBMVFC_VIOS_FAILURE) &&\n\t\t     be16_to_cpu(rsp->error) == IBMVFC_PLOGI_REQUIRED)\n\t\t\tlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_plogi);\n\t\telse if (tgt->logo_rcvd)\n\t\t\tlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_plogi);\n\t\telse if (ibmvfc_retry_cmd(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)))\n\t\t\tlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_prli);\n\t\telse\n\t\t\tibmvfc_del_tgt(tgt);\n\n\t\ttgt_log(tgt, level, \"Process Login failed: %s (%x:%x) rc=0x%02X\\n\",\n\t\t\tibmvfc_get_cmd_error(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)),\n\t\t\tbe16_to_cpu(rsp->status), be16_to_cpu(rsp->error), status);\n\t\tbreak;\n\t}\n\n\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\tibmvfc_free_event(evt);\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_tgt_send_prli(struct ibmvfc_target *tgt)\n{\n\tstruct ibmvfc_process_login *prli;\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_event *evt;\n\n\tif (vhost->discovery_threads >= disc_threads)\n\t\treturn;\n\n\tkref_get(&tgt->kref);\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t__ibmvfc_reset_host(vhost);\n\t\treturn;\n\t}\n\tvhost->discovery_threads++;\n\tibmvfc_init_event(evt, ibmvfc_tgt_prli_done, IBMVFC_MAD_FORMAT);\n\tevt->tgt = tgt;\n\tprli = &evt->iu.prli;\n\tmemset(prli, 0, sizeof(*prli));\n\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN)) {\n\t\tprli->common.version = cpu_to_be32(2);\n\t\tprli->target_wwpn = cpu_to_be64(tgt->wwpn);\n\t} else {\n\t\tprli->common.version = cpu_to_be32(1);\n\t}\n\tprli->common.opcode = cpu_to_be32(IBMVFC_PROCESS_LOGIN);\n\tprli->common.length = cpu_to_be16(sizeof(*prli));\n\tprli->scsi_id = cpu_to_be64(tgt->scsi_id);\n\n\tprli->parms.type = IBMVFC_SCSI_FCP_TYPE;\n\tprli->parms.flags = cpu_to_be16(IBMVFC_PRLI_EST_IMG_PAIR);\n\tprli->parms.service_parms = cpu_to_be32(IBMVFC_PRLI_INITIATOR_FUNC);\n\tprli->parms.service_parms |= cpu_to_be32(IBMVFC_PRLI_READ_FCP_XFER_RDY_DISABLED);\n\n\tif (cls3_error)\n\t\tprli->parms.service_parms |= cpu_to_be32(IBMVFC_PRLI_RETRY);\n\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\n\tif (ibmvfc_send_event(evt, vhost, default_timeout)) {\n\t\tvhost->discovery_threads--;\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t} else\n\t\ttgt_dbg(tgt, \"Sent process login\\n\");\n}\n\n \nstatic void ibmvfc_tgt_plogi_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_target *tgt = evt->tgt;\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_port_login *rsp = &evt->xfer_iu->plogi;\n\tu32 status = be16_to_cpu(rsp->common.status);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tvhost->discovery_threads--;\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\tswitch (status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\ttgt_dbg(tgt, \"Port Login succeeded\\n\");\n\t\tif (tgt->ids.port_name &&\n\t\t    tgt->ids.port_name != wwn_to_u64(rsp->service_parms.port_name)) {\n\t\t\tvhost->reinit = 1;\n\t\t\ttgt_dbg(tgt, \"Port re-init required\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ttgt->ids.node_name = wwn_to_u64(rsp->service_parms.node_name);\n\t\ttgt->ids.port_name = wwn_to_u64(rsp->service_parms.port_name);\n\t\ttgt->ids.port_id = tgt->scsi_id;\n\t\tmemcpy(&tgt->service_parms, &rsp->service_parms,\n\t\t       sizeof(tgt->service_parms));\n\t\tmemcpy(&tgt->service_parms_change, &rsp->service_parms_change,\n\t\t       sizeof(tgt->service_parms_change));\n\t\tibmvfc_init_tgt(tgt, ibmvfc_tgt_send_prli);\n\t\tbreak;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tbreak;\n\tcase IBMVFC_MAD_CRQ_ERROR:\n\t\tibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_plogi);\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\tdefault:\n\t\tif (ibmvfc_retry_cmd(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)))\n\t\t\tlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_send_plogi);\n\t\telse\n\t\t\tibmvfc_del_tgt(tgt);\n\n\t\ttgt_log(tgt, level, \"Port Login failed: %s (%x:%x) %s (%x) %s (%x) rc=0x%02X\\n\",\n\t\t\tibmvfc_get_cmd_error(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)),\n\t\t\t\t\t     be16_to_cpu(rsp->status), be16_to_cpu(rsp->error),\n\t\t\tibmvfc_get_fc_type(be16_to_cpu(rsp->fc_type)), be16_to_cpu(rsp->fc_type),\n\t\t\tibmvfc_get_ls_explain(be16_to_cpu(rsp->fc_explain)), be16_to_cpu(rsp->fc_explain), status);\n\t\tbreak;\n\t}\n\n\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\tibmvfc_free_event(evt);\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_tgt_send_plogi(struct ibmvfc_target *tgt)\n{\n\tstruct ibmvfc_port_login *plogi;\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_event *evt;\n\n\tif (vhost->discovery_threads >= disc_threads)\n\t\treturn;\n\n\tkref_get(&tgt->kref);\n\ttgt->logo_rcvd = 0;\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t__ibmvfc_reset_host(vhost);\n\t\treturn;\n\t}\n\tvhost->discovery_threads++;\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\n\tibmvfc_init_event(evt, ibmvfc_tgt_plogi_done, IBMVFC_MAD_FORMAT);\n\tevt->tgt = tgt;\n\tplogi = &evt->iu.plogi;\n\tmemset(plogi, 0, sizeof(*plogi));\n\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN)) {\n\t\tplogi->common.version = cpu_to_be32(2);\n\t\tplogi->target_wwpn = cpu_to_be64(tgt->wwpn);\n\t} else {\n\t\tplogi->common.version = cpu_to_be32(1);\n\t}\n\tplogi->common.opcode = cpu_to_be32(IBMVFC_PORT_LOGIN);\n\tplogi->common.length = cpu_to_be16(sizeof(*plogi));\n\tplogi->scsi_id = cpu_to_be64(tgt->scsi_id);\n\n\tif (ibmvfc_send_event(evt, vhost, default_timeout)) {\n\t\tvhost->discovery_threads--;\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t} else\n\t\ttgt_dbg(tgt, \"Sent port login\\n\");\n}\n\n \nstatic void ibmvfc_tgt_implicit_logout_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_target *tgt = evt->tgt;\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_implicit_logout *rsp = &evt->xfer_iu->implicit_logout;\n\tu32 status = be16_to_cpu(rsp->common.status);\n\n\tvhost->discovery_threads--;\n\tibmvfc_free_event(evt);\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\n\tswitch (status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\ttgt_dbg(tgt, \"Implicit Logout succeeded\\n\");\n\t\tbreak;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\twake_up(&vhost->work_wait_q);\n\t\treturn;\n\tcase IBMVFC_MAD_FAILED:\n\tdefault:\n\t\ttgt_err(tgt, \"Implicit Logout failed: rc=0x%02X\\n\", status);\n\t\tbreak;\n\t}\n\n\tibmvfc_init_tgt(tgt, ibmvfc_tgt_send_plogi);\n\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic struct ibmvfc_event *__ibmvfc_tgt_get_implicit_logout_evt(struct ibmvfc_target *tgt,\n\t\t\t\t\t\t\t\t void (*done) (struct ibmvfc_event *))\n{\n\tstruct ibmvfc_implicit_logout *mad;\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_event *evt;\n\n\tkref_get(&tgt->kref);\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt)\n\t\treturn NULL;\n\tibmvfc_init_event(evt, done, IBMVFC_MAD_FORMAT);\n\tevt->tgt = tgt;\n\tmad = &evt->iu.implicit_logout;\n\tmemset(mad, 0, sizeof(*mad));\n\tmad->common.version = cpu_to_be32(1);\n\tmad->common.opcode = cpu_to_be32(IBMVFC_IMPLICIT_LOGOUT);\n\tmad->common.length = cpu_to_be16(sizeof(*mad));\n\tmad->old_scsi_id = cpu_to_be64(tgt->scsi_id);\n\treturn evt;\n}\n\n \nstatic void ibmvfc_tgt_implicit_logout(struct ibmvfc_target *tgt)\n{\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_event *evt;\n\n\tif (vhost->discovery_threads >= disc_threads)\n\t\treturn;\n\n\tvhost->discovery_threads++;\n\tevt = __ibmvfc_tgt_get_implicit_logout_evt(tgt,\n\t\t\t\t\t\t   ibmvfc_tgt_implicit_logout_done);\n\tif (!evt) {\n\t\tvhost->discovery_threads--;\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t__ibmvfc_reset_host(vhost);\n\t\treturn;\n\t}\n\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\n\tif (ibmvfc_send_event(evt, vhost, default_timeout)) {\n\t\tvhost->discovery_threads--;\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t} else\n\t\ttgt_dbg(tgt, \"Sent Implicit Logout\\n\");\n}\n\n \nstatic void ibmvfc_tgt_implicit_logout_and_del_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_target *tgt = evt->tgt;\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_passthru_mad *mad = &evt->xfer_iu->passthru;\n\tu32 status = be16_to_cpu(mad->common.status);\n\n\tvhost->discovery_threads--;\n\tibmvfc_free_event(evt);\n\n\t \n\tif (status == IBMVFC_MAD_SUCCESS || vhost->state == IBMVFC_HOST_OFFLINE)\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\n\telse\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_AND_LOGOUT_RPORT);\n\n\ttgt_dbg(tgt, \"Implicit Logout %s\\n\", (status == IBMVFC_MAD_SUCCESS) ? \"succeeded\" : \"failed\");\n\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_tgt_implicit_logout_and_del(struct ibmvfc_target *tgt)\n{\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_event *evt;\n\n\tif (!vhost->logged_in) {\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\n\t\treturn;\n\t}\n\n\tif (vhost->discovery_threads >= disc_threads)\n\t\treturn;\n\n\tvhost->discovery_threads++;\n\tevt = __ibmvfc_tgt_get_implicit_logout_evt(tgt,\n\t\t\t\t\t\t   ibmvfc_tgt_implicit_logout_and_del_done);\n\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_LOGOUT_RPORT_WAIT);\n\tif (ibmvfc_send_event(evt, vhost, default_timeout)) {\n\t\tvhost->discovery_threads--;\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t} else\n\t\ttgt_dbg(tgt, \"Sent Implicit Logout\\n\");\n}\n\n \nstatic void ibmvfc_tgt_move_login_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_target *tgt = evt->tgt;\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_move_login *rsp = &evt->xfer_iu->move_login;\n\tu32 status = be16_to_cpu(rsp->common.status);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tvhost->discovery_threads--;\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\tswitch (status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\ttgt_dbg(tgt, \"Move Login succeeded for new scsi_id: %llX\\n\", tgt->new_scsi_id);\n\t\ttgt->ids.node_name = wwn_to_u64(rsp->service_parms.node_name);\n\t\ttgt->ids.port_name = wwn_to_u64(rsp->service_parms.port_name);\n\t\ttgt->scsi_id = tgt->new_scsi_id;\n\t\ttgt->ids.port_id = tgt->scsi_id;\n\t\tmemcpy(&tgt->service_parms, &rsp->service_parms,\n\t\t       sizeof(tgt->service_parms));\n\t\tmemcpy(&tgt->service_parms_change, &rsp->service_parms_change,\n\t\t       sizeof(tgt->service_parms_change));\n\t\tibmvfc_init_tgt(tgt, ibmvfc_tgt_send_prli);\n\t\tbreak;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tbreak;\n\tcase IBMVFC_MAD_CRQ_ERROR:\n\t\tibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_move_login);\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\tdefault:\n\t\tlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_move_login);\n\n\t\ttgt_log(tgt, level,\n\t\t\t\"Move Login failed: new scsi_id: %llX, flags:%x, vios_flags:%x, rc=0x%02X\\n\",\n\t\t\ttgt->new_scsi_id, be32_to_cpu(rsp->flags), be16_to_cpu(rsp->vios_flags),\n\t\t\tstatus);\n\t\tbreak;\n\t}\n\n\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\tibmvfc_free_event(evt);\n\twake_up(&vhost->work_wait_q);\n}\n\n\n \nstatic void ibmvfc_tgt_move_login(struct ibmvfc_target *tgt)\n{\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_move_login *move;\n\tstruct ibmvfc_event *evt;\n\n\tif (vhost->discovery_threads >= disc_threads)\n\t\treturn;\n\n\tkref_get(&tgt->kref);\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t__ibmvfc_reset_host(vhost);\n\t\treturn;\n\t}\n\tvhost->discovery_threads++;\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\n\tibmvfc_init_event(evt, ibmvfc_tgt_move_login_done, IBMVFC_MAD_FORMAT);\n\tevt->tgt = tgt;\n\tmove = &evt->iu.move_login;\n\tmemset(move, 0, sizeof(*move));\n\tmove->common.version = cpu_to_be32(1);\n\tmove->common.opcode = cpu_to_be32(IBMVFC_MOVE_LOGIN);\n\tmove->common.length = cpu_to_be16(sizeof(*move));\n\n\tmove->old_scsi_id = cpu_to_be64(tgt->scsi_id);\n\tmove->new_scsi_id = cpu_to_be64(tgt->new_scsi_id);\n\tmove->wwpn = cpu_to_be64(tgt->wwpn);\n\tmove->node_name = cpu_to_be64(tgt->ids.node_name);\n\n\tif (ibmvfc_send_event(evt, vhost, default_timeout)) {\n\t\tvhost->discovery_threads--;\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DEL_RPORT);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t} else\n\t\ttgt_dbg(tgt, \"Sent Move Login for new scsi_id: %llX\\n\", tgt->new_scsi_id);\n}\n\n \nstatic int ibmvfc_adisc_needs_plogi(struct ibmvfc_passthru_mad *mad,\n\t\t\t\t    struct ibmvfc_target *tgt)\n{\n\tif (wwn_to_u64((u8 *)&mad->fc_iu.response[2]) != tgt->ids.port_name)\n\t\treturn 1;\n\tif (wwn_to_u64((u8 *)&mad->fc_iu.response[4]) != tgt->ids.node_name)\n\t\treturn 1;\n\tif (be32_to_cpu(mad->fc_iu.response[6]) != tgt->scsi_id)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void ibmvfc_tgt_adisc_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_target *tgt = evt->tgt;\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_passthru_mad *mad = &evt->xfer_iu->passthru;\n\tu32 status = be16_to_cpu(mad->common.status);\n\tu8 fc_reason, fc_explain;\n\n\tvhost->discovery_threads--;\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\tdel_timer(&tgt->timer);\n\n\tswitch (status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\ttgt_dbg(tgt, \"ADISC succeeded\\n\");\n\t\tif (ibmvfc_adisc_needs_plogi(mad, tgt))\n\t\t\tibmvfc_del_tgt(tgt);\n\t\tbreak;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\tdefault:\n\t\tibmvfc_del_tgt(tgt);\n\t\tfc_reason = (be32_to_cpu(mad->fc_iu.response[1]) & 0x00ff0000) >> 16;\n\t\tfc_explain = (be32_to_cpu(mad->fc_iu.response[1]) & 0x0000ff00) >> 8;\n\t\ttgt_info(tgt, \"ADISC failed: %s (%x:%x) %s (%x) %s (%x) rc=0x%02X\\n\",\n\t\t\t ibmvfc_get_cmd_error(be16_to_cpu(mad->iu.status), be16_to_cpu(mad->iu.error)),\n\t\t\t be16_to_cpu(mad->iu.status), be16_to_cpu(mad->iu.error),\n\t\t\t ibmvfc_get_fc_type(fc_reason), fc_reason,\n\t\t\t ibmvfc_get_ls_explain(fc_explain), fc_explain, status);\n\t\tbreak;\n\t}\n\n\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\tibmvfc_free_event(evt);\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_init_passthru(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_passthru_mad *mad = &evt->iu.passthru;\n\n\tmemset(mad, 0, sizeof(*mad));\n\tmad->common.version = cpu_to_be32(1);\n\tmad->common.opcode = cpu_to_be32(IBMVFC_PASSTHRU);\n\tmad->common.length = cpu_to_be16(sizeof(*mad) - sizeof(mad->fc_iu) - sizeof(mad->iu));\n\tmad->cmd_ioba.va = cpu_to_be64((u64)be64_to_cpu(evt->crq.ioba) +\n\t\toffsetof(struct ibmvfc_passthru_mad, iu));\n\tmad->cmd_ioba.len = cpu_to_be32(sizeof(mad->iu));\n\tmad->iu.cmd_len = cpu_to_be32(sizeof(mad->fc_iu.payload));\n\tmad->iu.rsp_len = cpu_to_be32(sizeof(mad->fc_iu.response));\n\tmad->iu.cmd.va = cpu_to_be64((u64)be64_to_cpu(evt->crq.ioba) +\n\t\toffsetof(struct ibmvfc_passthru_mad, fc_iu) +\n\t\toffsetof(struct ibmvfc_passthru_fc_iu, payload));\n\tmad->iu.cmd.len = cpu_to_be32(sizeof(mad->fc_iu.payload));\n\tmad->iu.rsp.va = cpu_to_be64((u64)be64_to_cpu(evt->crq.ioba) +\n\t\toffsetof(struct ibmvfc_passthru_mad, fc_iu) +\n\t\toffsetof(struct ibmvfc_passthru_fc_iu, response));\n\tmad->iu.rsp.len = cpu_to_be32(sizeof(mad->fc_iu.response));\n}\n\n \nstatic void ibmvfc_tgt_adisc_cancel_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_target *tgt = evt->tgt;\n\n\ttgt_dbg(tgt, \"ADISC cancel complete\\n\");\n\tvhost->abort_threads--;\n\tibmvfc_free_event(evt);\n\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_adisc_timeout(struct timer_list *t)\n{\n\tstruct ibmvfc_target *tgt = from_timer(tgt, t, timer);\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_event *evt;\n\tstruct ibmvfc_tmf *tmf;\n\tunsigned long flags;\n\tint rc;\n\n\ttgt_dbg(tgt, \"ADISC timeout\\n\");\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tif (vhost->abort_threads >= disc_threads ||\n\t    tgt->action != IBMVFC_TGT_ACTION_INIT_WAIT ||\n\t    vhost->state != IBMVFC_INITIALIZING ||\n\t    vhost->action != IBMVFC_HOST_ACTION_QUERY_TGTS) {\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\treturn;\n\t}\n\n\tvhost->abort_threads++;\n\tkref_get(&tgt->kref);\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\ttgt_err(tgt, \"Failed to get cancel event for ADISC.\\n\");\n\t\tvhost->abort_threads--;\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t__ibmvfc_reset_host(vhost);\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\treturn;\n\t}\n\tibmvfc_init_event(evt, ibmvfc_tgt_adisc_cancel_done, IBMVFC_MAD_FORMAT);\n\n\tevt->tgt = tgt;\n\ttmf = &evt->iu.tmf;\n\tmemset(tmf, 0, sizeof(*tmf));\n\tif (ibmvfc_check_caps(vhost, IBMVFC_HANDLE_VF_WWPN)) {\n\t\ttmf->common.version = cpu_to_be32(2);\n\t\ttmf->target_wwpn = cpu_to_be64(tgt->wwpn);\n\t} else {\n\t\ttmf->common.version = cpu_to_be32(1);\n\t}\n\ttmf->common.opcode = cpu_to_be32(IBMVFC_TMF_MAD);\n\ttmf->common.length = cpu_to_be16(sizeof(*tmf));\n\ttmf->scsi_id = cpu_to_be64(tgt->scsi_id);\n\ttmf->cancel_key = cpu_to_be32(tgt->cancel_key);\n\n\trc = ibmvfc_send_event(evt, vhost, default_timeout);\n\n\tif (rc) {\n\t\ttgt_err(tgt, \"Failed to send cancel event for ADISC. rc=%d\\n\", rc);\n\t\tvhost->abort_threads--;\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t__ibmvfc_reset_host(vhost);\n\t} else\n\t\ttgt_dbg(tgt, \"Attempting to cancel ADISC\\n\");\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n}\n\n \nstatic void ibmvfc_tgt_adisc(struct ibmvfc_target *tgt)\n{\n\tstruct ibmvfc_passthru_mad *mad;\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_event *evt;\n\n\tif (vhost->discovery_threads >= disc_threads)\n\t\treturn;\n\n\tkref_get(&tgt->kref);\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t__ibmvfc_reset_host(vhost);\n\t\treturn;\n\t}\n\tvhost->discovery_threads++;\n\tibmvfc_init_event(evt, ibmvfc_tgt_adisc_done, IBMVFC_MAD_FORMAT);\n\tevt->tgt = tgt;\n\n\tibmvfc_init_passthru(evt);\n\tmad = &evt->iu.passthru;\n\tmad->iu.flags = cpu_to_be32(IBMVFC_FC_ELS);\n\tmad->iu.scsi_id = cpu_to_be64(tgt->scsi_id);\n\tmad->iu.cancel_key = cpu_to_be32(tgt->cancel_key);\n\n\tmad->fc_iu.payload[0] = cpu_to_be32(IBMVFC_ADISC);\n\tmemcpy(&mad->fc_iu.payload[2], &vhost->login_buf->resp.port_name,\n\t       sizeof(vhost->login_buf->resp.port_name));\n\tmemcpy(&mad->fc_iu.payload[4], &vhost->login_buf->resp.node_name,\n\t       sizeof(vhost->login_buf->resp.node_name));\n\tmad->fc_iu.payload[6] = cpu_to_be32(be64_to_cpu(vhost->login_buf->resp.scsi_id) & 0x00ffffff);\n\n\tif (timer_pending(&tgt->timer))\n\t\tmod_timer(&tgt->timer, jiffies + (IBMVFC_ADISC_TIMEOUT * HZ));\n\telse {\n\t\ttgt->timer.expires = jiffies + (IBMVFC_ADISC_TIMEOUT * HZ);\n\t\tadd_timer(&tgt->timer);\n\t}\n\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\n\tif (ibmvfc_send_event(evt, vhost, IBMVFC_ADISC_PLUS_CANCEL_TIMEOUT)) {\n\t\tvhost->discovery_threads--;\n\t\tdel_timer(&tgt->timer);\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t} else\n\t\ttgt_dbg(tgt, \"Sent ADISC\\n\");\n}\n\n \nstatic void ibmvfc_tgt_query_target_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_target *tgt = evt->tgt;\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_query_tgt *rsp = &evt->xfer_iu->query_tgt;\n\tu32 status = be16_to_cpu(rsp->common.status);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tvhost->discovery_threads--;\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\tswitch (status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\ttgt_dbg(tgt, \"Query Target succeeded\\n\");\n\t\tif (be64_to_cpu(rsp->scsi_id) != tgt->scsi_id)\n\t\t\tibmvfc_del_tgt(tgt);\n\t\telse\n\t\t\tibmvfc_init_tgt(tgt, ibmvfc_tgt_adisc);\n\t\tbreak;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tbreak;\n\tcase IBMVFC_MAD_CRQ_ERROR:\n\t\tibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_query_target);\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\tdefault:\n\t\tif ((be16_to_cpu(rsp->status) & IBMVFC_FABRIC_MAPPED) == IBMVFC_FABRIC_MAPPED &&\n\t\t    be16_to_cpu(rsp->error) == IBMVFC_UNABLE_TO_PERFORM_REQ &&\n\t\t    be16_to_cpu(rsp->fc_explain) == IBMVFC_PORT_NAME_NOT_REG)\n\t\t\tibmvfc_del_tgt(tgt);\n\t\telse if (ibmvfc_retry_cmd(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)))\n\t\t\tlevel += ibmvfc_retry_tgt_init(tgt, ibmvfc_tgt_query_target);\n\t\telse\n\t\t\tibmvfc_del_tgt(tgt);\n\n\t\ttgt_log(tgt, level, \"Query Target failed: %s (%x:%x) %s (%x) %s (%x) rc=0x%02X\\n\",\n\t\t\tibmvfc_get_cmd_error(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)),\n\t\t\tbe16_to_cpu(rsp->status), be16_to_cpu(rsp->error),\n\t\t\tibmvfc_get_fc_type(be16_to_cpu(rsp->fc_type)), be16_to_cpu(rsp->fc_type),\n\t\t\tibmvfc_get_gs_explain(be16_to_cpu(rsp->fc_explain)), be16_to_cpu(rsp->fc_explain),\n\t\t\tstatus);\n\t\tbreak;\n\t}\n\n\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\tibmvfc_free_event(evt);\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_tgt_query_target(struct ibmvfc_target *tgt)\n{\n\tstruct ibmvfc_query_tgt *query_tgt;\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct ibmvfc_event *evt;\n\n\tif (vhost->discovery_threads >= disc_threads)\n\t\treturn;\n\n\tkref_get(&tgt->kref);\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t__ibmvfc_reset_host(vhost);\n\t\treturn;\n\t}\n\tvhost->discovery_threads++;\n\tevt->tgt = tgt;\n\tibmvfc_init_event(evt, ibmvfc_tgt_query_target_done, IBMVFC_MAD_FORMAT);\n\tquery_tgt = &evt->iu.query_tgt;\n\tmemset(query_tgt, 0, sizeof(*query_tgt));\n\tquery_tgt->common.version = cpu_to_be32(1);\n\tquery_tgt->common.opcode = cpu_to_be32(IBMVFC_QUERY_TARGET);\n\tquery_tgt->common.length = cpu_to_be16(sizeof(*query_tgt));\n\tquery_tgt->wwpn = cpu_to_be64(tgt->ids.port_name);\n\n\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_INIT_WAIT);\n\tif (ibmvfc_send_event(evt, vhost, default_timeout)) {\n\t\tvhost->discovery_threads--;\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_NONE);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t} else\n\t\ttgt_dbg(tgt, \"Sent Query Target\\n\");\n}\n\n \nstatic int ibmvfc_alloc_target(struct ibmvfc_host *vhost,\n\t\t\t       struct ibmvfc_discover_targets_entry *target)\n{\n\tstruct ibmvfc_target *stgt = NULL;\n\tstruct ibmvfc_target *wtgt = NULL;\n\tstruct ibmvfc_target *tgt;\n\tunsigned long flags;\n\tu64 scsi_id = be32_to_cpu(target->scsi_id) & IBMVFC_DISC_TGT_SCSI_ID_MASK;\n\tu64 wwpn = be64_to_cpu(target->wwpn);\n\n\t \n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\tif (tgt->wwpn == wwpn) {\n\t\t\twtgt = tgt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\tif (tgt->scsi_id == scsi_id) {\n\t\t\tstgt = tgt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (wtgt && !stgt) {\n\t\t \n\t\tif (wtgt->action == IBMVFC_TGT_ACTION_LOGOUT_DELETED_RPORT) {\n\t\t\tif (wtgt->move_login) {\n\t\t\t\t \n\t\t\t\twtgt->new_scsi_id = scsi_id;\n\t\t\t\twtgt->action = IBMVFC_TGT_ACTION_INIT;\n\t\t\t\twtgt->init_retries = 0;\n\t\t\t\tibmvfc_init_tgt(wtgt, ibmvfc_tgt_move_login);\n\t\t\t}\n\t\t\tgoto unlock_out;\n\t\t} else {\n\t\t\ttgt_err(wtgt, \"Unexpected target state: %d, %p\\n\",\n\t\t\t\twtgt->action, wtgt->rport);\n\t\t}\n\t} else if (stgt) {\n\t\tif (tgt->need_login)\n\t\t\tibmvfc_init_tgt(tgt, ibmvfc_tgt_implicit_logout);\n\t\tgoto unlock_out;\n\t}\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\ttgt = mempool_alloc(vhost->tgt_pool, GFP_NOIO);\n\tmemset(tgt, 0, sizeof(*tgt));\n\ttgt->scsi_id = scsi_id;\n\ttgt->wwpn = wwpn;\n\ttgt->vhost = vhost;\n\ttgt->need_login = 1;\n\ttimer_setup(&tgt->timer, ibmvfc_adisc_timeout, 0);\n\tkref_init(&tgt->kref);\n\tibmvfc_init_tgt(tgt, ibmvfc_tgt_implicit_logout);\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\ttgt->cancel_key = vhost->task_set++;\n\tlist_add_tail(&tgt->queue, &vhost->targets);\n\nunlock_out:\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\treturn 0;\n}\n\n \nstatic int ibmvfc_alloc_targets(struct ibmvfc_host *vhost)\n{\n\tint i, rc;\n\n\tfor (i = 0, rc = 0; !rc && i < vhost->num_targets; i++)\n\t\trc = ibmvfc_alloc_target(vhost, &vhost->disc_buf[i]);\n\n\treturn rc;\n}\n\n \nstatic void ibmvfc_discover_targets_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_discover_targets *rsp = &evt->xfer_iu->discover_targets;\n\tu32 mad_status = be16_to_cpu(rsp->common.status);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tswitch (mad_status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\tibmvfc_dbg(vhost, \"Discover Targets succeeded\\n\");\n\t\tvhost->num_targets = be32_to_cpu(rsp->num_written);\n\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_ALLOC_TGTS);\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\t\tlevel += ibmvfc_retry_host_init(vhost);\n\t\tibmvfc_log(vhost, level, \"Discover Targets failed: %s (%x:%x)\\n\",\n\t\t\t   ibmvfc_get_cmd_error(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)),\n\t\t\t   be16_to_cpu(rsp->status), be16_to_cpu(rsp->error));\n\t\tbreak;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(vhost->dev, \"Invalid Discover Targets response: 0x%x\\n\", mad_status);\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\tbreak;\n\t}\n\n\tibmvfc_free_event(evt);\n\twake_up(&vhost->work_wait_q);\n}\n\n \nstatic void ibmvfc_discover_targets(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_discover_targets *mad;\n\tstruct ibmvfc_event *evt = ibmvfc_get_event(&vhost->crq);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tif (!evt) {\n\t\tibmvfc_log(vhost, level, \"Discover Targets failed: no available events\\n\");\n\t\tibmvfc_hard_reset_host(vhost);\n\t\treturn;\n\t}\n\n\tibmvfc_init_event(evt, ibmvfc_discover_targets_done, IBMVFC_MAD_FORMAT);\n\tmad = &evt->iu.discover_targets;\n\tmemset(mad, 0, sizeof(*mad));\n\tmad->common.version = cpu_to_be32(1);\n\tmad->common.opcode = cpu_to_be32(IBMVFC_DISC_TARGETS);\n\tmad->common.length = cpu_to_be16(sizeof(*mad));\n\tmad->bufflen = cpu_to_be32(vhost->disc_buf_sz);\n\tmad->buffer.va = cpu_to_be64(vhost->disc_buf_dma);\n\tmad->buffer.len = cpu_to_be32(vhost->disc_buf_sz);\n\tmad->flags = cpu_to_be32(IBMVFC_DISC_TGT_PORT_ID_WWPN_LIST);\n\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT_WAIT);\n\n\tif (!ibmvfc_send_event(evt, vhost, default_timeout))\n\t\tibmvfc_dbg(vhost, \"Sent discover targets\\n\");\n\telse\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n}\n\nstatic void ibmvfc_channel_setup_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_channel_setup *setup = vhost->channel_setup_buf;\n\tstruct ibmvfc_scsi_channels *scrqs = &vhost->scsi_scrqs;\n\tu32 mad_status = be16_to_cpu(evt->xfer_iu->channel_setup.common.status);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\tint flags, active_queues, i;\n\n\tibmvfc_free_event(evt);\n\n\tswitch (mad_status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\tibmvfc_dbg(vhost, \"Channel Setup succeeded\\n\");\n\t\tflags = be32_to_cpu(setup->flags);\n\t\tvhost->do_enquiry = 0;\n\t\tactive_queues = be32_to_cpu(setup->num_scsi_subq_channels);\n\t\tscrqs->active_queues = active_queues;\n\n\t\tif (flags & IBMVFC_CHANNELS_CANCELED) {\n\t\t\tibmvfc_dbg(vhost, \"Channels Canceled\\n\");\n\t\t\tvhost->using_channels = 0;\n\t\t} else {\n\t\t\tif (active_queues)\n\t\t\t\tvhost->using_channels = 1;\n\t\t\tfor (i = 0; i < active_queues; i++)\n\t\t\t\tscrqs->scrqs[i].vios_cookie =\n\t\t\t\t\tbe64_to_cpu(setup->channel_handles[i]);\n\n\t\t\tibmvfc_dbg(vhost, \"Using %u channels\\n\",\n\t\t\t\t   vhost->scsi_scrqs.active_queues);\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\t\tlevel += ibmvfc_retry_host_init(vhost);\n\t\tibmvfc_log(vhost, level, \"Channel Setup failed\\n\");\n\t\tfallthrough;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\treturn;\n\tdefault:\n\t\tdev_err(vhost->dev, \"Invalid Channel Setup response: 0x%x\\n\",\n\t\t\tmad_status);\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\treturn;\n\t}\n\n\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY);\n\twake_up(&vhost->work_wait_q);\n}\n\nstatic void ibmvfc_channel_setup(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_channel_setup_mad *mad;\n\tstruct ibmvfc_channel_setup *setup_buf = vhost->channel_setup_buf;\n\tstruct ibmvfc_event *evt = ibmvfc_get_event(&vhost->crq);\n\tstruct ibmvfc_scsi_channels *scrqs = &vhost->scsi_scrqs;\n\tunsigned int num_channels =\n\t\tmin(vhost->client_scsi_channels, vhost->max_vios_scsi_channels);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\tint i;\n\n\tif (!evt) {\n\t\tibmvfc_log(vhost, level, \"Channel Setup failed: no available events\\n\");\n\t\tibmvfc_hard_reset_host(vhost);\n\t\treturn;\n\t}\n\n\tmemset(setup_buf, 0, sizeof(*setup_buf));\n\tif (num_channels == 0)\n\t\tsetup_buf->flags = cpu_to_be32(IBMVFC_CANCEL_CHANNELS);\n\telse {\n\t\tsetup_buf->num_scsi_subq_channels = cpu_to_be32(num_channels);\n\t\tfor (i = 0; i < num_channels; i++)\n\t\t\tsetup_buf->channel_handles[i] = cpu_to_be64(scrqs->scrqs[i].cookie);\n\t}\n\n\tibmvfc_init_event(evt, ibmvfc_channel_setup_done, IBMVFC_MAD_FORMAT);\n\tmad = &evt->iu.channel_setup;\n\tmemset(mad, 0, sizeof(*mad));\n\tmad->common.version = cpu_to_be32(1);\n\tmad->common.opcode = cpu_to_be32(IBMVFC_CHANNEL_SETUP);\n\tmad->common.length = cpu_to_be16(sizeof(*mad));\n\tmad->buffer.va = cpu_to_be64(vhost->channel_setup_dma);\n\tmad->buffer.len = cpu_to_be32(sizeof(*vhost->channel_setup_buf));\n\n\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT_WAIT);\n\n\tif (!ibmvfc_send_event(evt, vhost, default_timeout))\n\t\tibmvfc_dbg(vhost, \"Sent channel setup\\n\");\n\telse\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DOWN);\n}\n\nstatic void ibmvfc_channel_enquiry_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tstruct ibmvfc_channel_enquiry *rsp = &evt->xfer_iu->channel_enquiry;\n\tu32 mad_status = be16_to_cpu(rsp->common.status);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tswitch (mad_status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\tibmvfc_dbg(vhost, \"Channel Enquiry succeeded\\n\");\n\t\tvhost->max_vios_scsi_channels = be32_to_cpu(rsp->num_scsi_subq_channels);\n\t\tibmvfc_free_event(evt);\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\t\tlevel += ibmvfc_retry_host_init(vhost);\n\t\tibmvfc_log(vhost, level, \"Channel Enquiry failed\\n\");\n\t\tfallthrough;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tibmvfc_free_event(evt);\n\t\treturn;\n\tdefault:\n\t\tdev_err(vhost->dev, \"Invalid Channel Enquiry response: 0x%x\\n\",\n\t\t\tmad_status);\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\tibmvfc_free_event(evt);\n\t\treturn;\n\t}\n\n\tibmvfc_channel_setup(vhost);\n}\n\nstatic void ibmvfc_channel_enquiry(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_channel_enquiry *mad;\n\tstruct ibmvfc_event *evt = ibmvfc_get_event(&vhost->crq);\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tif (!evt) {\n\t\tibmvfc_log(vhost, level, \"Channel Enquiry failed: no available events\\n\");\n\t\tibmvfc_hard_reset_host(vhost);\n\t\treturn;\n\t}\n\n\tibmvfc_init_event(evt, ibmvfc_channel_enquiry_done, IBMVFC_MAD_FORMAT);\n\tmad = &evt->iu.channel_enquiry;\n\tmemset(mad, 0, sizeof(*mad));\n\tmad->common.version = cpu_to_be32(1);\n\tmad->common.opcode = cpu_to_be32(IBMVFC_CHANNEL_ENQUIRY);\n\tmad->common.length = cpu_to_be16(sizeof(*mad));\n\n\tif (mig_channels_only)\n\t\tmad->flags |= cpu_to_be32(IBMVFC_NO_CHANNELS_TO_CRQ_SUPPORT);\n\tif (mig_no_less_channels)\n\t\tmad->flags |= cpu_to_be32(IBMVFC_NO_N_TO_M_CHANNELS_SUPPORT);\n\n\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT_WAIT);\n\n\tif (!ibmvfc_send_event(evt, vhost, default_timeout))\n\t\tibmvfc_dbg(vhost, \"Send channel enquiry\\n\");\n\telse\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n}\n\n \nstatic void ibmvfc_npiv_login_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tu32 mad_status = be16_to_cpu(evt->xfer_iu->npiv_login.common.status);\n\tstruct ibmvfc_npiv_login_resp *rsp = &vhost->login_buf->resp;\n\tunsigned int npiv_max_sectors;\n\tint level = IBMVFC_DEFAULT_LOG_LEVEL;\n\n\tswitch (mad_status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\tibmvfc_free_event(evt);\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\t\tif (ibmvfc_retry_cmd(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)))\n\t\t\tlevel += ibmvfc_retry_host_init(vhost);\n\t\telse\n\t\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\tibmvfc_log(vhost, level, \"NPIV Login failed: %s (%x:%x)\\n\",\n\t\t\t   ibmvfc_get_cmd_error(be16_to_cpu(rsp->status), be16_to_cpu(rsp->error)),\n\t\t\t\t\t\tbe16_to_cpu(rsp->status), be16_to_cpu(rsp->error));\n\t\tibmvfc_free_event(evt);\n\t\treturn;\n\tcase IBMVFC_MAD_CRQ_ERROR:\n\t\tibmvfc_retry_host_init(vhost);\n\t\tfallthrough;\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\t\tibmvfc_free_event(evt);\n\t\treturn;\n\tdefault:\n\t\tdev_err(vhost->dev, \"Invalid NPIV Login response: 0x%x\\n\", mad_status);\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\tibmvfc_free_event(evt);\n\t\treturn;\n\t}\n\n\tvhost->client_migrated = 0;\n\n\tif (!(be32_to_cpu(rsp->flags) & IBMVFC_NATIVE_FC)) {\n\t\tdev_err(vhost->dev, \"Virtual adapter does not support FC. %x\\n\",\n\t\t\trsp->flags);\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\twake_up(&vhost->work_wait_q);\n\t\treturn;\n\t}\n\n\tif (be32_to_cpu(rsp->max_cmds) <= IBMVFC_NUM_INTERNAL_REQ) {\n\t\tdev_err(vhost->dev, \"Virtual adapter supported queue depth too small: %d\\n\",\n\t\t\trsp->max_cmds);\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\twake_up(&vhost->work_wait_q);\n\t\treturn;\n\t}\n\n\tvhost->logged_in = 1;\n\tnpiv_max_sectors = min((uint)(be64_to_cpu(rsp->max_dma_len) >> 9), IBMVFC_MAX_SECTORS);\n\tdev_info(vhost->dev, \"Host partition: %s, device: %s %s %s max sectors %u\\n\",\n\t\t rsp->partition_name, rsp->device_name, rsp->port_loc_code,\n\t\t rsp->drc_name, npiv_max_sectors);\n\n\tfc_host_fabric_name(vhost->host) = be64_to_cpu(rsp->node_name);\n\tfc_host_node_name(vhost->host) = be64_to_cpu(rsp->node_name);\n\tfc_host_port_name(vhost->host) = be64_to_cpu(rsp->port_name);\n\tfc_host_port_id(vhost->host) = be64_to_cpu(rsp->scsi_id);\n\tfc_host_port_type(vhost->host) = FC_PORTTYPE_NPIV;\n\tfc_host_supported_classes(vhost->host) = 0;\n\tif (be32_to_cpu(rsp->service_parms.class1_parms[0]) & 0x80000000)\n\t\tfc_host_supported_classes(vhost->host) |= FC_COS_CLASS1;\n\tif (be32_to_cpu(rsp->service_parms.class2_parms[0]) & 0x80000000)\n\t\tfc_host_supported_classes(vhost->host) |= FC_COS_CLASS2;\n\tif (be32_to_cpu(rsp->service_parms.class3_parms[0]) & 0x80000000)\n\t\tfc_host_supported_classes(vhost->host) |= FC_COS_CLASS3;\n\tfc_host_maxframe_size(vhost->host) =\n\t\tbe16_to_cpu(rsp->service_parms.common.bb_rcv_sz) & 0x0fff;\n\n\tvhost->host->can_queue = be32_to_cpu(rsp->max_cmds) - IBMVFC_NUM_INTERNAL_REQ;\n\tvhost->host->max_sectors = npiv_max_sectors;\n\n\tif (ibmvfc_check_caps(vhost, IBMVFC_CAN_SUPPORT_CHANNELS) && vhost->do_enquiry) {\n\t\tibmvfc_channel_enquiry(vhost);\n\t} else {\n\t\tvhost->do_enquiry = 0;\n\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY);\n\t\twake_up(&vhost->work_wait_q);\n\t}\n}\n\n \nstatic void ibmvfc_npiv_login(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_npiv_login_mad *mad;\n\tstruct ibmvfc_event *evt = ibmvfc_get_event(&vhost->crq);\n\n\tif (!evt) {\n\t\tibmvfc_dbg(vhost, \"NPIV Login failed: no available events\\n\");\n\t\tibmvfc_hard_reset_host(vhost);\n\t\treturn;\n\t}\n\n\tibmvfc_gather_partition_info(vhost);\n\tibmvfc_set_login_info(vhost);\n\tibmvfc_init_event(evt, ibmvfc_npiv_login_done, IBMVFC_MAD_FORMAT);\n\n\tmemcpy(vhost->login_buf, &vhost->login_info, sizeof(vhost->login_info));\n\tmad = &evt->iu.npiv_login;\n\tmemset(mad, 0, sizeof(struct ibmvfc_npiv_login_mad));\n\tmad->common.version = cpu_to_be32(1);\n\tmad->common.opcode = cpu_to_be32(IBMVFC_NPIV_LOGIN);\n\tmad->common.length = cpu_to_be16(sizeof(struct ibmvfc_npiv_login_mad));\n\tmad->buffer.va = cpu_to_be64(vhost->login_buf_dma);\n\tmad->buffer.len = cpu_to_be32(sizeof(*vhost->login_buf));\n\n\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT_WAIT);\n\n\tif (!ibmvfc_send_event(evt, vhost, default_timeout))\n\t\tibmvfc_dbg(vhost, \"Sent NPIV login\\n\");\n\telse\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n}\n\n \nstatic void ibmvfc_npiv_logout_done(struct ibmvfc_event *evt)\n{\n\tstruct ibmvfc_host *vhost = evt->vhost;\n\tu32 mad_status = be16_to_cpu(evt->xfer_iu->npiv_logout.common.status);\n\n\tibmvfc_free_event(evt);\n\n\tswitch (mad_status) {\n\tcase IBMVFC_MAD_SUCCESS:\n\t\tif (list_empty(&vhost->crq.sent) &&\n\t\t    vhost->action == IBMVFC_HOST_ACTION_LOGO_WAIT) {\n\t\t\tibmvfc_init_host(vhost);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_MAD_FAILED:\n\tcase IBMVFC_MAD_NOT_SUPPORTED:\n\tcase IBMVFC_MAD_CRQ_ERROR:\n\tcase IBMVFC_MAD_DRIVER_FAILED:\n\tdefault:\n\t\tibmvfc_dbg(vhost, \"NPIV Logout failed. 0x%X\\n\", mad_status);\n\t\tbreak;\n\t}\n\n\tibmvfc_hard_reset_host(vhost);\n}\n\n \nstatic void ibmvfc_npiv_logout(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_npiv_logout_mad *mad;\n\tstruct ibmvfc_event *evt;\n\n\tevt = ibmvfc_get_event(&vhost->crq);\n\tif (!evt) {\n\t\tibmvfc_dbg(vhost, \"NPIV Logout failed: no available events\\n\");\n\t\tibmvfc_hard_reset_host(vhost);\n\t\treturn;\n\t}\n\n\tibmvfc_init_event(evt, ibmvfc_npiv_logout_done, IBMVFC_MAD_FORMAT);\n\n\tmad = &evt->iu.npiv_logout;\n\tmemset(mad, 0, sizeof(*mad));\n\tmad->common.version = cpu_to_be32(1);\n\tmad->common.opcode = cpu_to_be32(IBMVFC_NPIV_LOGOUT);\n\tmad->common.length = cpu_to_be16(sizeof(struct ibmvfc_npiv_logout_mad));\n\n\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_LOGO_WAIT);\n\n\tif (!ibmvfc_send_event(evt, vhost, default_timeout))\n\t\tibmvfc_dbg(vhost, \"Sent NPIV logout\\n\");\n\telse\n\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n}\n\n \nstatic int ibmvfc_dev_init_to_do(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_target *tgt;\n\n\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\tif (tgt->action == IBMVFC_TGT_ACTION_INIT ||\n\t\t    tgt->action == IBMVFC_TGT_ACTION_INIT_WAIT)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ibmvfc_dev_logo_to_do(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_target *tgt;\n\n\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\tif (tgt->action == IBMVFC_TGT_ACTION_LOGOUT_RPORT ||\n\t\t    tgt->action == IBMVFC_TGT_ACTION_LOGOUT_RPORT_WAIT)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic int __ibmvfc_work_to_do(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_target *tgt;\n\n\tif (kthread_should_stop())\n\t\treturn 1;\n\tswitch (vhost->action) {\n\tcase IBMVFC_HOST_ACTION_NONE:\n\tcase IBMVFC_HOST_ACTION_INIT_WAIT:\n\tcase IBMVFC_HOST_ACTION_LOGO_WAIT:\n\t\treturn 0;\n\tcase IBMVFC_HOST_ACTION_TGT_INIT:\n\tcase IBMVFC_HOST_ACTION_QUERY_TGTS:\n\t\tif (vhost->discovery_threads == disc_threads)\n\t\t\treturn 0;\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue)\n\t\t\tif (tgt->action == IBMVFC_TGT_ACTION_INIT)\n\t\t\t\treturn 1;\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue)\n\t\t\tif (tgt->action == IBMVFC_TGT_ACTION_INIT_WAIT)\n\t\t\t\treturn 0;\n\t\treturn 1;\n\tcase IBMVFC_HOST_ACTION_TGT_DEL:\n\tcase IBMVFC_HOST_ACTION_TGT_DEL_FAILED:\n\t\tif (vhost->discovery_threads == disc_threads)\n\t\t\treturn 0;\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue)\n\t\t\tif (tgt->action == IBMVFC_TGT_ACTION_LOGOUT_RPORT)\n\t\t\t\treturn 1;\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue)\n\t\t\tif (tgt->action == IBMVFC_TGT_ACTION_LOGOUT_RPORT_WAIT)\n\t\t\t\treturn 0;\n\t\treturn 1;\n\tcase IBMVFC_HOST_ACTION_LOGO:\n\tcase IBMVFC_HOST_ACTION_INIT:\n\tcase IBMVFC_HOST_ACTION_ALLOC_TGTS:\n\tcase IBMVFC_HOST_ACTION_QUERY:\n\tcase IBMVFC_HOST_ACTION_RESET:\n\tcase IBMVFC_HOST_ACTION_REENABLE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int ibmvfc_work_to_do(struct ibmvfc_host *vhost)\n{\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\trc = __ibmvfc_work_to_do(vhost);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\treturn rc;\n}\n\n \nstatic void ibmvfc_log_ae(struct ibmvfc_host *vhost, int events)\n{\n\tif (events & IBMVFC_AE_RSCN)\n\t\tfc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_RSCN, 0);\n\tif ((events & IBMVFC_AE_LINKDOWN) &&\n\t    vhost->state >= IBMVFC_HALTED)\n\t\tfc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_LINKDOWN, 0);\n\tif ((events & IBMVFC_AE_LINKUP) &&\n\t    vhost->state == IBMVFC_INITIALIZING)\n\t\tfc_host_post_event(vhost->host, fc_get_event_number(), FCH_EVT_LINKUP, 0);\n}\n\n \nstatic void ibmvfc_tgt_add_rport(struct ibmvfc_target *tgt)\n{\n\tstruct ibmvfc_host *vhost = tgt->vhost;\n\tstruct fc_rport *rport;\n\tunsigned long flags;\n\n\ttgt_dbg(tgt, \"Adding rport\\n\");\n\trport = fc_remote_port_add(vhost->host, 0, &tgt->ids);\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\n\tif (rport && tgt->action == IBMVFC_TGT_ACTION_DEL_RPORT) {\n\t\ttgt_dbg(tgt, \"Deleting rport\\n\");\n\t\tlist_del(&tgt->queue);\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DELETED_RPORT);\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\tfc_remote_port_delete(rport);\n\t\tdel_timer_sync(&tgt->timer);\n\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\treturn;\n\t} else if (rport && tgt->action == IBMVFC_TGT_ACTION_DEL_AND_LOGOUT_RPORT) {\n\t\ttgt_dbg(tgt, \"Deleting rport with outstanding I/O\\n\");\n\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_LOGOUT_DELETED_RPORT);\n\t\ttgt->rport = NULL;\n\t\ttgt->init_retries = 0;\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\tfc_remote_port_delete(rport);\n\t\treturn;\n\t} else if (rport && tgt->action == IBMVFC_TGT_ACTION_DELETED_RPORT) {\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\treturn;\n\t}\n\n\tif (rport) {\n\t\ttgt_dbg(tgt, \"rport add succeeded\\n\");\n\t\ttgt->rport = rport;\n\t\trport->maxframe_size = be16_to_cpu(tgt->service_parms.common.bb_rcv_sz) & 0x0fff;\n\t\trport->supported_classes = 0;\n\t\ttgt->target_id = rport->scsi_target_id;\n\t\tif (be32_to_cpu(tgt->service_parms.class1_parms[0]) & 0x80000000)\n\t\t\trport->supported_classes |= FC_COS_CLASS1;\n\t\tif (be32_to_cpu(tgt->service_parms.class2_parms[0]) & 0x80000000)\n\t\t\trport->supported_classes |= FC_COS_CLASS2;\n\t\tif (be32_to_cpu(tgt->service_parms.class3_parms[0]) & 0x80000000)\n\t\t\trport->supported_classes |= FC_COS_CLASS3;\n\t\tif (rport->rqst_q)\n\t\t\tblk_queue_max_segments(rport->rqst_q, 1);\n\t} else\n\t\ttgt_dbg(tgt, \"rport add failed\\n\");\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n}\n\n \nstatic void ibmvfc_do_work(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_target *tgt;\n\tunsigned long flags;\n\tstruct fc_rport *rport;\n\tLIST_HEAD(purge);\n\tint rc;\n\n\tibmvfc_log_ae(vhost, vhost->events_to_log);\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tvhost->events_to_log = 0;\n\tswitch (vhost->action) {\n\tcase IBMVFC_HOST_ACTION_NONE:\n\tcase IBMVFC_HOST_ACTION_LOGO_WAIT:\n\tcase IBMVFC_HOST_ACTION_INIT_WAIT:\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_RESET:\n\t\tlist_splice_init(&vhost->purge, &purge);\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\tibmvfc_complete_purge(&purge);\n\t\trc = ibmvfc_reset_crq(vhost);\n\n\t\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\t\tif (!rc || rc == H_CLOSED)\n\t\t\tvio_enable_interrupts(to_vio_dev(vhost->dev));\n\t\tif (vhost->action == IBMVFC_HOST_ACTION_RESET) {\n\t\t\t \n\t\t\tvhost->action = IBMVFC_HOST_ACTION_TGT_DEL;\n\n\t\t\tif (rc || (rc = ibmvfc_send_crq_init(vhost)) ||\n\t\t\t    (rc = vio_enable_interrupts(to_vio_dev(vhost->dev)))) {\n\t\t\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\t\t\tdev_err(vhost->dev, \"Error after reset (rc=%d)\\n\", rc);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_REENABLE:\n\t\tlist_splice_init(&vhost->purge, &purge);\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\tibmvfc_complete_purge(&purge);\n\t\trc = ibmvfc_reenable_crq_queue(vhost);\n\n\t\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\t\tif (vhost->action == IBMVFC_HOST_ACTION_REENABLE) {\n\t\t\t \n\t\t\tvhost->action = IBMVFC_HOST_ACTION_TGT_DEL;\n\t\t\tif (rc || (rc = ibmvfc_send_crq_init(vhost))) {\n\t\t\t\tibmvfc_link_down(vhost, IBMVFC_LINK_DEAD);\n\t\t\t\tdev_err(vhost->dev, \"Error after enable (rc=%d)\\n\", rc);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_LOGO:\n\t\tvhost->job_step(vhost);\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_INIT:\n\t\tBUG_ON(vhost->state != IBMVFC_INITIALIZING);\n\t\tif (vhost->delay_init) {\n\t\t\tvhost->delay_init = 0;\n\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\tssleep(15);\n\t\t\treturn;\n\t\t} else\n\t\t\tvhost->job_step(vhost);\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_QUERY:\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue)\n\t\t\tibmvfc_init_tgt(tgt, ibmvfc_tgt_query_target);\n\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY_TGTS);\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_QUERY_TGTS:\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\t\tif (tgt->action == IBMVFC_TGT_ACTION_INIT) {\n\t\t\t\ttgt->job_step(tgt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!ibmvfc_dev_init_to_do(vhost))\n\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_TGT_DEL);\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_TGT_DEL:\n\tcase IBMVFC_HOST_ACTION_TGT_DEL_FAILED:\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\t\tif (tgt->action == IBMVFC_TGT_ACTION_LOGOUT_RPORT) {\n\t\t\t\ttgt->job_step(tgt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ibmvfc_dev_logo_to_do(vhost)) {\n\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\t\tif (tgt->action == IBMVFC_TGT_ACTION_DEL_RPORT) {\n\t\t\t\ttgt_dbg(tgt, \"Deleting rport\\n\");\n\t\t\t\trport = tgt->rport;\n\t\t\t\ttgt->rport = NULL;\n\t\t\t\tlist_del(&tgt->queue);\n\t\t\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_DELETED_RPORT);\n\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\tif (rport)\n\t\t\t\t\tfc_remote_port_delete(rport);\n\t\t\t\tdel_timer_sync(&tgt->timer);\n\t\t\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t\t\treturn;\n\t\t\t} else if (tgt->action == IBMVFC_TGT_ACTION_DEL_AND_LOGOUT_RPORT) {\n\t\t\t\ttgt_dbg(tgt, \"Deleting rport with I/O outstanding\\n\");\n\t\t\t\trport = tgt->rport;\n\t\t\t\ttgt->rport = NULL;\n\t\t\t\ttgt->init_retries = 0;\n\t\t\t\tibmvfc_set_tgt_action(tgt, IBMVFC_TGT_ACTION_LOGOUT_DELETED_RPORT);\n\n\t\t\t\t \n\t\t\t\tif (rport && rport->fast_io_fail_tmo == -1)\n\t\t\t\t\ttgt->move_login = 1;\n\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\tif (rport)\n\t\t\t\t\tfc_remote_port_delete(rport);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (vhost->state == IBMVFC_INITIALIZING) {\n\t\t\tif (vhost->action == IBMVFC_HOST_ACTION_TGT_DEL_FAILED) {\n\t\t\t\tif (vhost->reinit) {\n\t\t\t\t\tvhost->reinit = 0;\n\t\t\t\t\tscsi_block_requests(vhost->host);\n\t\t\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_QUERY);\n\t\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\t} else {\n\t\t\t\t\tibmvfc_set_host_state(vhost, IBMVFC_ACTIVE);\n\t\t\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);\n\t\t\t\t\twake_up(&vhost->init_wait_q);\n\t\t\t\t\tschedule_work(&vhost->rport_add_work_q);\n\t\t\t\t\tvhost->init_retries = 0;\n\t\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\t\tscsi_unblock_requests(vhost->host);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_INIT);\n\t\t\t\tvhost->job_step = ibmvfc_discover_targets;\n\t\t\t}\n\t\t} else {\n\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);\n\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\tscsi_unblock_requests(vhost->host);\n\t\t\twake_up(&vhost->init_wait_q);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_ALLOC_TGTS:\n\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_TGT_INIT);\n\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\tibmvfc_alloc_targets(vhost);\n\t\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\t\tbreak;\n\tcase IBMVFC_HOST_ACTION_TGT_INIT:\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\t\tif (tgt->action == IBMVFC_TGT_ACTION_INIT) {\n\t\t\t\ttgt->job_step(tgt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!ibmvfc_dev_init_to_do(vhost))\n\t\t\tibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_TGT_DEL_FAILED);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n}\n\n \nstatic int ibmvfc_work(void *data)\n{\n\tstruct ibmvfc_host *vhost = data;\n\tint rc;\n\n\tset_user_nice(current, MIN_NICE);\n\n\twhile (1) {\n\t\trc = wait_event_interruptible(vhost->work_wait_q,\n\t\t\t\t\t      ibmvfc_work_to_do(vhost));\n\n\t\tBUG_ON(rc);\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tibmvfc_do_work(vhost);\n\t}\n\n\tibmvfc_dbg(vhost, \"ibmvfc kthread exiting...\\n\");\n\treturn 0;\n}\n\n \nstatic int ibmvfc_alloc_queue(struct ibmvfc_host *vhost,\n\t\t\t      struct ibmvfc_queue *queue,\n\t\t\t      enum ibmvfc_msg_fmt fmt)\n{\n\tstruct device *dev = vhost->dev;\n\tsize_t fmt_size;\n\tunsigned int pool_size = 0;\n\n\tENTER;\n\tspin_lock_init(&queue->_lock);\n\tqueue->q_lock = &queue->_lock;\n\n\tswitch (fmt) {\n\tcase IBMVFC_CRQ_FMT:\n\t\tfmt_size = sizeof(*queue->msgs.crq);\n\t\tpool_size = max_requests + IBMVFC_NUM_INTERNAL_REQ;\n\t\tbreak;\n\tcase IBMVFC_ASYNC_FMT:\n\t\tfmt_size = sizeof(*queue->msgs.async);\n\t\tbreak;\n\tcase IBMVFC_SUB_CRQ_FMT:\n\t\tfmt_size = sizeof(*queue->msgs.scrq);\n\t\t \n\t\tpool_size = max_requests + 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Unknown command/response queue message format: %d\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ibmvfc_init_event_pool(vhost, queue, pool_size)) {\n\t\tdev_err(dev, \"Couldn't initialize event pool.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tqueue->msgs.handle = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!queue->msgs.handle)\n\t\treturn -ENOMEM;\n\n\tqueue->msg_token = dma_map_single(dev, queue->msgs.handle, PAGE_SIZE,\n\t\t\t\t\t  DMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(dev, queue->msg_token)) {\n\t\tfree_page((unsigned long)queue->msgs.handle);\n\t\tqueue->msgs.handle = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tqueue->cur = 0;\n\tqueue->fmt = fmt;\n\tqueue->size = PAGE_SIZE / fmt_size;\n\n\tqueue->vhost = vhost;\n\treturn 0;\n}\n\n \nstatic int ibmvfc_init_crq(struct ibmvfc_host *vhost)\n{\n\tint rc, retrc = -ENOMEM;\n\tstruct device *dev = vhost->dev;\n\tstruct vio_dev *vdev = to_vio_dev(dev);\n\tstruct ibmvfc_queue *crq = &vhost->crq;\n\n\tENTER;\n\tif (ibmvfc_alloc_queue(vhost, crq, IBMVFC_CRQ_FMT))\n\t\treturn -ENOMEM;\n\n\tretrc = rc = plpar_hcall_norets(H_REG_CRQ, vdev->unit_address,\n\t\t\t\t\tcrq->msg_token, PAGE_SIZE);\n\n\tif (rc == H_RESOURCE)\n\t\t \n\t\tretrc = rc = ibmvfc_reset_crq(vhost);\n\n\tif (rc == H_CLOSED)\n\t\tdev_warn(dev, \"Partner adapter not ready\\n\");\n\telse if (rc) {\n\t\tdev_warn(dev, \"Error %d opening adapter\\n\", rc);\n\t\tgoto reg_crq_failed;\n\t}\n\n\tretrc = 0;\n\n\ttasklet_init(&vhost->tasklet, (void *)ibmvfc_tasklet, (unsigned long)vhost);\n\n\tif ((rc = request_irq(vdev->irq, ibmvfc_interrupt, 0, IBMVFC_NAME, vhost))) {\n\t\tdev_err(dev, \"Couldn't register irq 0x%x. rc=%d\\n\", vdev->irq, rc);\n\t\tgoto req_irq_failed;\n\t}\n\n\tif ((rc = vio_enable_interrupts(vdev))) {\n\t\tdev_err(dev, \"Error %d enabling interrupts\\n\", rc);\n\t\tgoto req_irq_failed;\n\t}\n\n\tLEAVE;\n\treturn retrc;\n\nreq_irq_failed:\n\ttasklet_kill(&vhost->tasklet);\n\tdo {\n\t\trc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\nreg_crq_failed:\n\tibmvfc_free_queue(vhost, crq);\n\treturn retrc;\n}\n\nstatic int ibmvfc_register_scsi_channel(struct ibmvfc_host *vhost,\n\t\t\t\t  int index)\n{\n\tstruct device *dev = vhost->dev;\n\tstruct vio_dev *vdev = to_vio_dev(dev);\n\tstruct ibmvfc_queue *scrq = &vhost->scsi_scrqs.scrqs[index];\n\tint rc = -ENOMEM;\n\n\tENTER;\n\n\trc = h_reg_sub_crq(vdev->unit_address, scrq->msg_token, PAGE_SIZE,\n\t\t\t   &scrq->cookie, &scrq->hw_irq);\n\n\t \n\tif (rc && rc != H_CLOSED) {\n\t\tdev_warn(dev, \"Error registering sub-crq: %d\\n\", rc);\n\t\tif (rc == H_PARAMETER)\n\t\t\tdev_warn_once(dev, \"Firmware may not support MQ\\n\");\n\t\tgoto reg_failed;\n\t}\n\n\tscrq->irq = irq_create_mapping(NULL, scrq->hw_irq);\n\n\tif (!scrq->irq) {\n\t\trc = -EINVAL;\n\t\tdev_err(dev, \"Error mapping sub-crq[%d] irq\\n\", index);\n\t\tgoto irq_failed;\n\t}\n\n\tsnprintf(scrq->name, sizeof(scrq->name), \"ibmvfc-%x-scsi%d\",\n\t\t vdev->unit_address, index);\n\trc = request_irq(scrq->irq, ibmvfc_interrupt_scsi, 0, scrq->name, scrq);\n\n\tif (rc) {\n\t\tdev_err(dev, \"Couldn't register sub-crq[%d] irq\\n\", index);\n\t\tirq_dispose_mapping(scrq->irq);\n\t\tgoto irq_failed;\n\t}\n\n\tscrq->hwq_id = index;\n\n\tLEAVE;\n\treturn 0;\n\nirq_failed:\n\tdo {\n\t\trc = plpar_hcall_norets(H_FREE_SUB_CRQ, vdev->unit_address, scrq->cookie);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\nreg_failed:\n\tLEAVE;\n\treturn rc;\n}\n\nstatic void ibmvfc_deregister_scsi_channel(struct ibmvfc_host *vhost, int index)\n{\n\tstruct device *dev = vhost->dev;\n\tstruct vio_dev *vdev = to_vio_dev(dev);\n\tstruct ibmvfc_queue *scrq = &vhost->scsi_scrqs.scrqs[index];\n\tlong rc;\n\n\tENTER;\n\n\tfree_irq(scrq->irq, scrq);\n\tirq_dispose_mapping(scrq->irq);\n\tscrq->irq = 0;\n\n\tdo {\n\t\trc = plpar_hcall_norets(H_FREE_SUB_CRQ, vdev->unit_address,\n\t\t\t\t\tscrq->cookie);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tif (rc)\n\t\tdev_err(dev, \"Failed to free sub-crq[%d]: rc=%ld\\n\", index, rc);\n\n\t \n\tmemset(scrq->msgs.crq, 0, PAGE_SIZE);\n\tscrq->cur = 0;\n\n\tLEAVE;\n}\n\nstatic void ibmvfc_reg_sub_crqs(struct ibmvfc_host *vhost)\n{\n\tint i, j;\n\n\tENTER;\n\tif (!vhost->mq_enabled || !vhost->scsi_scrqs.scrqs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_scsi_hw_queues; i++) {\n\t\tif (ibmvfc_register_scsi_channel(vhost, i)) {\n\t\t\tfor (j = i; j > 0; j--)\n\t\t\t\tibmvfc_deregister_scsi_channel(vhost, j - 1);\n\t\t\tvhost->do_enquiry = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tLEAVE;\n}\n\nstatic void ibmvfc_dereg_sub_crqs(struct ibmvfc_host *vhost)\n{\n\tint i;\n\n\tENTER;\n\tif (!vhost->mq_enabled || !vhost->scsi_scrqs.scrqs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_scsi_hw_queues; i++)\n\t\tibmvfc_deregister_scsi_channel(vhost, i);\n\n\tLEAVE;\n}\n\nstatic void ibmvfc_init_sub_crqs(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_queue *scrq;\n\tint i, j;\n\n\tENTER;\n\tif (!vhost->mq_enabled)\n\t\treturn;\n\n\tvhost->scsi_scrqs.scrqs = kcalloc(nr_scsi_hw_queues,\n\t\t\t\t\t  sizeof(*vhost->scsi_scrqs.scrqs),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!vhost->scsi_scrqs.scrqs) {\n\t\tvhost->do_enquiry = 0;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_scsi_hw_queues; i++) {\n\t\tscrq = &vhost->scsi_scrqs.scrqs[i];\n\t\tif (ibmvfc_alloc_queue(vhost, scrq, IBMVFC_SUB_CRQ_FMT)) {\n\t\t\tfor (j = i; j > 0; j--) {\n\t\t\t\tscrq = &vhost->scsi_scrqs.scrqs[j - 1];\n\t\t\t\tibmvfc_free_queue(vhost, scrq);\n\t\t\t}\n\t\t\tkfree(vhost->scsi_scrqs.scrqs);\n\t\t\tvhost->scsi_scrqs.scrqs = NULL;\n\t\t\tvhost->scsi_scrqs.active_queues = 0;\n\t\t\tvhost->do_enquiry = 0;\n\t\t\tvhost->mq_enabled = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tibmvfc_reg_sub_crqs(vhost);\n\n\tLEAVE;\n}\n\nstatic void ibmvfc_release_sub_crqs(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_queue *scrq;\n\tint i;\n\n\tENTER;\n\tif (!vhost->scsi_scrqs.scrqs)\n\t\treturn;\n\n\tibmvfc_dereg_sub_crqs(vhost);\n\n\tfor (i = 0; i < nr_scsi_hw_queues; i++) {\n\t\tscrq = &vhost->scsi_scrqs.scrqs[i];\n\t\tibmvfc_free_queue(vhost, scrq);\n\t}\n\n\tkfree(vhost->scsi_scrqs.scrqs);\n\tvhost->scsi_scrqs.scrqs = NULL;\n\tvhost->scsi_scrqs.active_queues = 0;\n\tLEAVE;\n}\n\n \nstatic void ibmvfc_free_mem(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_queue *async_q = &vhost->async_crq;\n\n\tENTER;\n\tmempool_destroy(vhost->tgt_pool);\n\tkfree(vhost->trace);\n\tdma_free_coherent(vhost->dev, vhost->disc_buf_sz, vhost->disc_buf,\n\t\t\t  vhost->disc_buf_dma);\n\tdma_free_coherent(vhost->dev, sizeof(*vhost->login_buf),\n\t\t\t  vhost->login_buf, vhost->login_buf_dma);\n\tdma_free_coherent(vhost->dev, sizeof(*vhost->channel_setup_buf),\n\t\t\t  vhost->channel_setup_buf, vhost->channel_setup_dma);\n\tdma_pool_destroy(vhost->sg_pool);\n\tibmvfc_free_queue(vhost, async_q);\n\tLEAVE;\n}\n\n \nstatic int ibmvfc_alloc_mem(struct ibmvfc_host *vhost)\n{\n\tstruct ibmvfc_queue *async_q = &vhost->async_crq;\n\tstruct device *dev = vhost->dev;\n\n\tENTER;\n\tif (ibmvfc_alloc_queue(vhost, async_q, IBMVFC_ASYNC_FMT)) {\n\t\tdev_err(dev, \"Couldn't allocate/map async queue.\\n\");\n\t\tgoto nomem;\n\t}\n\n\tvhost->sg_pool = dma_pool_create(IBMVFC_NAME, dev,\n\t\t\t\t\t SG_ALL * sizeof(struct srp_direct_buf),\n\t\t\t\t\t sizeof(struct srp_direct_buf), 0);\n\n\tif (!vhost->sg_pool) {\n\t\tdev_err(dev, \"Failed to allocate sg pool\\n\");\n\t\tgoto unmap_async_crq;\n\t}\n\n\tvhost->login_buf = dma_alloc_coherent(dev, sizeof(*vhost->login_buf),\n\t\t\t\t\t      &vhost->login_buf_dma, GFP_KERNEL);\n\n\tif (!vhost->login_buf) {\n\t\tdev_err(dev, \"Couldn't allocate NPIV login buffer\\n\");\n\t\tgoto free_sg_pool;\n\t}\n\n\tvhost->disc_buf_sz = sizeof(*vhost->disc_buf) * max_targets;\n\tvhost->disc_buf = dma_alloc_coherent(dev, vhost->disc_buf_sz,\n\t\t\t\t\t     &vhost->disc_buf_dma, GFP_KERNEL);\n\n\tif (!vhost->disc_buf) {\n\t\tdev_err(dev, \"Couldn't allocate Discover Targets buffer\\n\");\n\t\tgoto free_login_buffer;\n\t}\n\n\tvhost->trace = kcalloc(IBMVFC_NUM_TRACE_ENTRIES,\n\t\t\t       sizeof(struct ibmvfc_trace_entry), GFP_KERNEL);\n\tatomic_set(&vhost->trace_index, -1);\n\n\tif (!vhost->trace)\n\t\tgoto free_disc_buffer;\n\n\tvhost->tgt_pool = mempool_create_kmalloc_pool(IBMVFC_TGT_MEMPOOL_SZ,\n\t\t\t\t\t\t      sizeof(struct ibmvfc_target));\n\n\tif (!vhost->tgt_pool) {\n\t\tdev_err(dev, \"Couldn't allocate target memory pool\\n\");\n\t\tgoto free_trace;\n\t}\n\n\tvhost->channel_setup_buf = dma_alloc_coherent(dev, sizeof(*vhost->channel_setup_buf),\n\t\t\t\t\t\t      &vhost->channel_setup_dma,\n\t\t\t\t\t\t      GFP_KERNEL);\n\n\tif (!vhost->channel_setup_buf) {\n\t\tdev_err(dev, \"Couldn't allocate Channel Setup buffer\\n\");\n\t\tgoto free_tgt_pool;\n\t}\n\n\tLEAVE;\n\treturn 0;\n\nfree_tgt_pool:\n\tmempool_destroy(vhost->tgt_pool);\nfree_trace:\n\tkfree(vhost->trace);\nfree_disc_buffer:\n\tdma_free_coherent(dev, vhost->disc_buf_sz, vhost->disc_buf,\n\t\t\t  vhost->disc_buf_dma);\nfree_login_buffer:\n\tdma_free_coherent(dev, sizeof(*vhost->login_buf),\n\t\t\t  vhost->login_buf, vhost->login_buf_dma);\nfree_sg_pool:\n\tdma_pool_destroy(vhost->sg_pool);\nunmap_async_crq:\n\tibmvfc_free_queue(vhost, async_q);\nnomem:\n\tLEAVE;\n\treturn -ENOMEM;\n}\n\n \nstatic void ibmvfc_rport_add_thread(struct work_struct *work)\n{\n\tstruct ibmvfc_host *vhost = container_of(work, struct ibmvfc_host,\n\t\t\t\t\t\t rport_add_work_q);\n\tstruct ibmvfc_target *tgt;\n\tstruct fc_rport *rport;\n\tunsigned long flags;\n\tint did_work;\n\n\tENTER;\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tdo {\n\t\tdid_work = 0;\n\t\tif (vhost->state != IBMVFC_ACTIVE)\n\t\t\tbreak;\n\n\t\tlist_for_each_entry(tgt, &vhost->targets, queue) {\n\t\t\tif (tgt->add_rport) {\n\t\t\t\tdid_work = 1;\n\t\t\t\ttgt->add_rport = 0;\n\t\t\t\tkref_get(&tgt->kref);\n\t\t\t\trport = tgt->rport;\n\t\t\t\tif (!rport) {\n\t\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\t\tibmvfc_tgt_add_rport(tgt);\n\t\t\t\t} else if (get_device(&rport->dev)) {\n\t\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\t\ttgt_dbg(tgt, \"Setting rport roles\\n\");\n\t\t\t\t\tfc_remote_port_rolechg(rport, tgt->ids.roles);\n\t\t\t\t\tput_device(&rport->dev);\n\t\t\t\t} else {\n\t\t\t\t\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\t\t\t\t}\n\n\t\t\t\tkref_put(&tgt->kref, ibmvfc_release_tgt);\n\t\t\t\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while(did_work);\n\n\tif (vhost->state == IBMVFC_ACTIVE)\n\t\tvhost->scan_complete = 1;\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\tLEAVE;\n}\n\n \nstatic int ibmvfc_probe(struct vio_dev *vdev, const struct vio_device_id *id)\n{\n\tstruct ibmvfc_host *vhost;\n\tstruct Scsi_Host *shost;\n\tstruct device *dev = &vdev->dev;\n\tint rc = -ENOMEM;\n\tunsigned int max_scsi_queues = IBMVFC_MAX_SCSI_QUEUES;\n\n\tENTER;\n\tshost = scsi_host_alloc(&driver_template, sizeof(*vhost));\n\tif (!shost) {\n\t\tdev_err(dev, \"Couldn't allocate host data\\n\");\n\t\tgoto out;\n\t}\n\n\tshost->transportt = ibmvfc_transport_template;\n\tshost->can_queue = max_requests;\n\tshost->max_lun = max_lun;\n\tshost->max_id = max_targets;\n\tshost->max_sectors = IBMVFC_MAX_SECTORS;\n\tshost->max_cmd_len = IBMVFC_MAX_CDB_LEN;\n\tshost->unique_id = shost->host_no;\n\tshost->nr_hw_queues = mq_enabled ? min(max_scsi_queues, nr_scsi_hw_queues) : 1;\n\n\tvhost = shost_priv(shost);\n\tINIT_LIST_HEAD(&vhost->targets);\n\tINIT_LIST_HEAD(&vhost->purge);\n\tsprintf(vhost->name, IBMVFC_NAME);\n\tvhost->host = shost;\n\tvhost->dev = dev;\n\tvhost->partition_number = -1;\n\tvhost->log_level = log_level;\n\tvhost->task_set = 1;\n\n\tvhost->mq_enabled = mq_enabled;\n\tvhost->client_scsi_channels = min(shost->nr_hw_queues, nr_scsi_channels);\n\tvhost->using_channels = 0;\n\tvhost->do_enquiry = 1;\n\tvhost->scan_timeout = 0;\n\n\tstrcpy(vhost->partition_name, \"UNKNOWN\");\n\tinit_waitqueue_head(&vhost->work_wait_q);\n\tinit_waitqueue_head(&vhost->init_wait_q);\n\tINIT_WORK(&vhost->rport_add_work_q, ibmvfc_rport_add_thread);\n\tmutex_init(&vhost->passthru_mutex);\n\n\tif ((rc = ibmvfc_alloc_mem(vhost)))\n\t\tgoto free_scsi_host;\n\n\tvhost->work_thread = kthread_run(ibmvfc_work, vhost, \"%s_%d\", IBMVFC_NAME,\n\t\t\t\t\t shost->host_no);\n\n\tif (IS_ERR(vhost->work_thread)) {\n\t\tdev_err(dev, \"Couldn't create kernel thread: %ld\\n\",\n\t\t\tPTR_ERR(vhost->work_thread));\n\t\trc = PTR_ERR(vhost->work_thread);\n\t\tgoto free_host_mem;\n\t}\n\n\tif ((rc = ibmvfc_init_crq(vhost))) {\n\t\tdev_err(dev, \"Couldn't initialize crq. rc=%d\\n\", rc);\n\t\tgoto kill_kthread;\n\t}\n\n\tif ((rc = scsi_add_host(shost, dev)))\n\t\tgoto release_crq;\n\n\tfc_host_dev_loss_tmo(shost) = IBMVFC_DEV_LOSS_TMO;\n\n\tif ((rc = ibmvfc_create_trace_file(&shost->shost_dev.kobj,\n\t\t\t\t\t   &ibmvfc_trace_attr))) {\n\t\tdev_err(dev, \"Failed to create trace file. rc=%d\\n\", rc);\n\t\tgoto remove_shost;\n\t}\n\n\tibmvfc_init_sub_crqs(vhost);\n\n\tif (shost_to_fc_host(shost)->rqst_q)\n\t\tblk_queue_max_segments(shost_to_fc_host(shost)->rqst_q, 1);\n\tdev_set_drvdata(dev, vhost);\n\tspin_lock(&ibmvfc_driver_lock);\n\tlist_add_tail(&vhost->queue, &ibmvfc_head);\n\tspin_unlock(&ibmvfc_driver_lock);\n\n\tibmvfc_send_crq_init(vhost);\n\tscsi_scan_host(shost);\n\treturn 0;\n\nremove_shost:\n\tscsi_remove_host(shost);\nrelease_crq:\n\tibmvfc_release_crq_queue(vhost);\nkill_kthread:\n\tkthread_stop(vhost->work_thread);\nfree_host_mem:\n\tibmvfc_free_mem(vhost);\nfree_scsi_host:\n\tscsi_host_put(shost);\nout:\n\tLEAVE;\n\treturn rc;\n}\n\n \nstatic void ibmvfc_remove(struct vio_dev *vdev)\n{\n\tstruct ibmvfc_host *vhost = dev_get_drvdata(&vdev->dev);\n\tLIST_HEAD(purge);\n\tunsigned long flags;\n\n\tENTER;\n\tibmvfc_remove_trace_file(&vhost->host->shost_dev.kobj, &ibmvfc_trace_attr);\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tibmvfc_link_down(vhost, IBMVFC_HOST_OFFLINE);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\n\tibmvfc_wait_while_resetting(vhost);\n\tkthread_stop(vhost->work_thread);\n\tfc_remove_host(vhost->host);\n\tscsi_remove_host(vhost->host);\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tibmvfc_purge_requests(vhost, DID_ERROR);\n\tlist_splice_init(&vhost->purge, &purge);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\tibmvfc_complete_purge(&purge);\n\tibmvfc_release_sub_crqs(vhost);\n\tibmvfc_release_crq_queue(vhost);\n\n\tibmvfc_free_mem(vhost);\n\tspin_lock(&ibmvfc_driver_lock);\n\tlist_del(&vhost->queue);\n\tspin_unlock(&ibmvfc_driver_lock);\n\tscsi_host_put(vhost->host);\n\tLEAVE;\n}\n\n \nstatic int ibmvfc_resume(struct device *dev)\n{\n\tunsigned long flags;\n\tstruct ibmvfc_host *vhost = dev_get_drvdata(dev);\n\tstruct vio_dev *vdev = to_vio_dev(dev);\n\n\tspin_lock_irqsave(vhost->host->host_lock, flags);\n\tvio_disable_interrupts(vdev);\n\ttasklet_schedule(&vhost->tasklet);\n\tspin_unlock_irqrestore(vhost->host->host_lock, flags);\n\treturn 0;\n}\n\n \nstatic unsigned long ibmvfc_get_desired_dma(struct vio_dev *vdev)\n{\n\tunsigned long pool_dma = max_requests * sizeof(union ibmvfc_iu);\n\treturn pool_dma + ((512 * 1024) * driver_template.cmd_per_lun);\n}\n\nstatic const struct vio_device_id ibmvfc_device_table[] = {\n\t{\"fcp\", \"IBM,vfc-client\"},\n\t{ \"\", \"\" }\n};\nMODULE_DEVICE_TABLE(vio, ibmvfc_device_table);\n\nstatic const struct dev_pm_ops ibmvfc_pm_ops = {\n\t.resume = ibmvfc_resume\n};\n\nstatic struct vio_driver ibmvfc_driver = {\n\t.id_table = ibmvfc_device_table,\n\t.probe = ibmvfc_probe,\n\t.remove = ibmvfc_remove,\n\t.get_desired_dma = ibmvfc_get_desired_dma,\n\t.name = IBMVFC_NAME,\n\t.pm = &ibmvfc_pm_ops,\n};\n\nstatic struct fc_function_template ibmvfc_transport_functions = {\n\t.show_host_fabric_name = 1,\n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_port_type = 1,\n\t.show_host_port_id = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.get_host_port_state = ibmvfc_get_host_port_state,\n\t.show_host_port_state = 1,\n\n\t.get_host_speed = ibmvfc_get_host_speed,\n\t.show_host_speed = 1,\n\n\t.issue_fc_host_lip = ibmvfc_issue_fc_host_lip,\n\t.terminate_rport_io = ibmvfc_terminate_rport_io,\n\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.set_rport_dev_loss_tmo = ibmvfc_set_rport_dev_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.get_starget_node_name = ibmvfc_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\n\t.get_starget_port_name = ibmvfc_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t.get_starget_port_id = ibmvfc_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\n\t.bsg_request = ibmvfc_bsg_request,\n\t.bsg_timeout = ibmvfc_bsg_timeout,\n};\n\n \nstatic int __init ibmvfc_module_init(void)\n{\n\tint rc;\n\n\tif (!firmware_has_feature(FW_FEATURE_VIO))\n\t\treturn -ENODEV;\n\n\tprintk(KERN_INFO IBMVFC_NAME\": IBM Virtual Fibre Channel Driver version: %s %s\\n\",\n\t       IBMVFC_DRIVER_VERSION, IBMVFC_DRIVER_DATE);\n\n\tibmvfc_transport_template = fc_attach_transport(&ibmvfc_transport_functions);\n\tif (!ibmvfc_transport_template)\n\t\treturn -ENOMEM;\n\n\trc = vio_register_driver(&ibmvfc_driver);\n\tif (rc)\n\t\tfc_release_transport(ibmvfc_transport_template);\n\treturn rc;\n}\n\n \nstatic void __exit ibmvfc_module_exit(void)\n{\n\tvio_unregister_driver(&ibmvfc_driver);\n\tfc_release_transport(ibmvfc_transport_template);\n}\n\nmodule_init(ibmvfc_module_init);\nmodule_exit(ibmvfc_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}