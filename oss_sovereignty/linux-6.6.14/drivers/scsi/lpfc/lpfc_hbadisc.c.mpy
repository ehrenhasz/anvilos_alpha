{
  "module_name": "lpfc_hbadisc.c",
  "hash_id": "6702f91a291c48a03e70dcb870801b381af9cc9caa8c58a55e64e2ae79c6af01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_hbadisc.c",
  "human_readable_source": " \n\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/lockdep.h>\n#include <linux/utsname.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_nvme.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_debugfs.h\"\n\n \nstatic uint8_t lpfcAlpaArray[] = {\n\t0xEF, 0xE8, 0xE4, 0xE2, 0xE1, 0xE0, 0xDC, 0xDA, 0xD9, 0xD6,\n\t0xD5, 0xD4, 0xD3, 0xD2, 0xD1, 0xCE, 0xCD, 0xCC, 0xCB, 0xCA,\n\t0xC9, 0xC7, 0xC6, 0xC5, 0xC3, 0xBC, 0xBA, 0xB9, 0xB6, 0xB5,\n\t0xB4, 0xB3, 0xB2, 0xB1, 0xAE, 0xAD, 0xAC, 0xAB, 0xAA, 0xA9,\n\t0xA7, 0xA6, 0xA5, 0xA3, 0x9F, 0x9E, 0x9D, 0x9B, 0x98, 0x97,\n\t0x90, 0x8F, 0x88, 0x84, 0x82, 0x81, 0x80, 0x7C, 0x7A, 0x79,\n\t0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x6E, 0x6D, 0x6C, 0x6B,\n\t0x6A, 0x69, 0x67, 0x66, 0x65, 0x63, 0x5C, 0x5A, 0x59, 0x56,\n\t0x55, 0x54, 0x53, 0x52, 0x51, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A,\n\t0x49, 0x47, 0x46, 0x45, 0x43, 0x3C, 0x3A, 0x39, 0x36, 0x35,\n\t0x34, 0x33, 0x32, 0x31, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29,\n\t0x27, 0x26, 0x25, 0x23, 0x1F, 0x1E, 0x1D, 0x1B, 0x18, 0x17,\n\t0x10, 0x0F, 0x08, 0x04, 0x02, 0x01\n};\n\nstatic void lpfc_disc_timeout_handler(struct lpfc_vport *);\nstatic void lpfc_disc_flush_list(struct lpfc_vport *vport);\nstatic void lpfc_unregister_fcfi_cmpl(struct lpfc_hba *, LPFC_MBOXQ_t *);\nstatic int lpfc_fcf_inuse(struct lpfc_hba *);\nstatic void lpfc_mbx_cmpl_read_sparam(struct lpfc_hba *, LPFC_MBOXQ_t *);\nstatic void lpfc_check_inactive_vmid(struct lpfc_hba *phba);\nstatic void lpfc_check_vmid_qfpa_issue(struct lpfc_hba *phba);\n\nstatic int\nlpfc_valid_xpt_node(struct lpfc_nodelist *ndlp)\n{\n\tif (ndlp->nlp_fc4_type ||\n\t    ndlp->nlp_type & NLP_FABRIC)\n\t\treturn 1;\n\treturn 0;\n}\n \nstatic int\nlpfc_rport_invalid(struct fc_rport *rport)\n{\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *ndlp;\n\n\tif (!rport) {\n\t\tpr_err(\"**** %s: NULL rport, exit.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\trdata = rport->dd_data;\n\tif (!rdata) {\n\t\tpr_err(\"**** %s: NULL dd_data on rport x%px SID x%x\\n\",\n\t\t       __func__, rport, rport->scsi_target_id);\n\t\treturn -EINVAL;\n\t}\n\n\tndlp = rdata->pnode;\n\tif (!rdata->pnode) {\n\t\tpr_info(\"**** %s: NULL ndlp on rport x%px SID x%x\\n\",\n\t\t\t__func__, rport, rport->scsi_target_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ndlp->vport) {\n\t\tpr_err(\"**** %s: Null vport on ndlp x%px, DID x%x rport x%px \"\n\t\t       \"SID x%x\\n\", __func__, ndlp, ndlp->nlp_DID, rport,\n\t\t       rport->scsi_target_id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid\nlpfc_terminate_rport_io(struct fc_rport *rport)\n{\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_vport *vport;\n\n\tif (lpfc_rport_invalid(rport))\n\t\treturn;\n\n\trdata = rport->dd_data;\n\tndlp = rdata->pnode;\n\tvport = ndlp->vport;\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_RPORT,\n\t\t\t      \"rport terminate: sid:x%x did:x%x flg:x%x\",\n\t\t\t      ndlp->nlp_sid, ndlp->nlp_DID, ndlp->nlp_flag);\n\n\tif (ndlp->nlp_sid != NLP_NO_SID)\n\t\tlpfc_sli_abort_iocb(vport, ndlp->nlp_sid, 0, LPFC_CTX_TGT);\n}\n\n \nvoid\nlpfc_dev_loss_tmo_callbk(struct fc_rport *rport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_hba   *phba;\n\tstruct lpfc_work_evt *evtp;\n\tunsigned long iflags;\n\n\tndlp = ((struct lpfc_rport_data *)rport->dd_data)->pnode;\n\tif (!ndlp)\n\t\treturn;\n\n\tvport = ndlp->vport;\n\tphba  = vport->phba;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_RPORT,\n\t\t\"rport devlosscb: sid:x%x did:x%x flg:x%x\",\n\t\tndlp->nlp_sid, ndlp->nlp_DID, ndlp->nlp_flag);\n\n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NODE,\n\t\t\t \"3181 dev_loss_callbk x%06x, rport x%px flg x%x \"\n\t\t\t \"load_flag x%x refcnt %u state %d xpt x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->rport, ndlp->nlp_flag,\n\t\t\t vport->load_flag, kref_read(&ndlp->kref),\n\t\t\t ndlp->nlp_state, ndlp->fc4_xpt_flags);\n\n\t \n\tif (vport->load_flag & FC_UNLOADING) {\n\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\t\tndlp->rport = NULL;\n\n\t\t \n\t\tif (ndlp->fc4_xpt_flags & (NLP_XPT_REGD | SCSI_XPT_REGD)) {\n\t\t\tndlp->fc4_xpt_flags &= ~SCSI_XPT_REGD;\n\n\t\t\t \n\t\t\tif (!(ndlp->fc4_xpt_flags & NVME_XPT_REGD))\n\t\t\t\tndlp->fc4_xpt_flags &= ~NLP_XPT_REGD;\n\t\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\t\t}\n\n\t\t \n\t\tif (!(ndlp->fc4_xpt_flags & NVME_XPT_REGD) &&\n\t\t    !(ndlp->nlp_flag & NLP_DROPPED)) {\n\t\t\tndlp->nlp_flag |= NLP_DROPPED;\n\t\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\treturn;\n\t}\n\n\tif (ndlp->nlp_state == NLP_STE_MAPPED_NODE)\n\t\treturn;\n\n\tif (rport->port_name != wwn_to_u64(ndlp->nlp_portname.u.wwn))\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6789 rport name %llx != node port name %llx\",\n\t\t\t\t rport->port_name,\n\t\t\t\t wwn_to_u64(ndlp->nlp_portname.u.wwn));\n\n\tevtp = &ndlp->dev_loss_evt;\n\n\tif (!list_empty(&evtp->evt_listp)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6790 rport name %llx dev_loss_evt pending\\n\",\n\t\t\t\t rport->port_name);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ndlp->lock, iflags);\n\tndlp->nlp_flag |= NLP_IN_DEV_LOSS;\n\n\t \n\tif (ndlp->nlp_state != NLP_STE_PLOGI_ISSUE)\n\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\n\t \n\tndlp->fc4_xpt_flags &= ~SCSI_XPT_REGD;\n\t((struct lpfc_rport_data *)rport->dd_data)->pnode = NULL;\n\tndlp->rport = NULL;\n\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\n\tif (phba->worker_thread) {\n\t\t \n\t\tevtp->evt_arg1 = lpfc_nlp_get(ndlp);\n\n\t\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t\tif (evtp->evt_arg1) {\n\t\t\tevtp->evt = LPFC_EVT_DEV_LOSS;\n\t\t\tlist_add_tail(&evtp->evt_listp, &phba->work_list);\n\t\t\tlpfc_worker_wake_up(phba);\n\t\t}\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t} else {\n\t\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NODE,\n\t\t\t\t \"3188 worker thread is stopped %s x%06x, \"\n\t\t\t\t \" rport x%px flg x%x load_flag x%x refcnt \"\n\t\t\t\t \"%d\\n\", __func__, ndlp->nlp_DID,\n\t\t\t\t ndlp->rport, ndlp->nlp_flag,\n\t\t\t\t vport->load_flag, kref_read(&ndlp->kref));\n\t\tif (!(ndlp->fc4_xpt_flags & NVME_XPT_REGD)) {\n\t\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\t\t\t \n\t\t\tndlp->nlp_flag &= ~NLP_IN_DEV_LOSS;\n\t\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\t}\n\n\t}\n\n\treturn;\n}\n\n \nstatic void lpfc_check_inactive_vmid_one(struct lpfc_vport *vport)\n{\n\tu16 keep;\n\tu32 difftime = 0, r, bucket;\n\tu64 *lta;\n\tint cpu;\n\tstruct lpfc_vmid *vmp;\n\n\twrite_lock(&vport->vmid_lock);\n\n\tif (!vport->cur_vmid_cnt)\n\t\tgoto out;\n\n\t \n\thash_for_each(vport->hash_table, bucket, vmp, hnode) {\n\t\tkeep = 0;\n\t\tif (vmp->flag & LPFC_VMID_REGISTERED) {\n\t\t\t \n\t\t\t \n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\t \n\t\t\t\tlta = per_cpu_ptr(vmp->last_io_time, cpu);\n\t\t\t\tif (!lta)\n\t\t\t\t\tcontinue;\n\t\t\t\tdifftime = (jiffies) - (*lta);\n\t\t\t\tif ((vport->vmid_inactivity_timeout *\n\t\t\t\t     JIFFIES_PER_HR) > difftime) {\n\t\t\t\t\tkeep = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tif (!keep) {\n\t\t\t\t \n\t\t\t\tvmp->flag = LPFC_VMID_DE_REGISTER;\n\t\t\t\twrite_unlock(&vport->vmid_lock);\n\t\t\t\tif (vport->vmid_priority_tagging)\n\t\t\t\t\tr = lpfc_vmid_uvem(vport, vmp, false);\n\t\t\t\telse\n\t\t\t\t\tr = lpfc_vmid_cmd(vport,\n\t\t\t\t\t\t\t  SLI_CTAS_DAPP_IDENT,\n\t\t\t\t\t\t\t  vmp);\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\twrite_lock(&vport->vmid_lock);\n\t\t\t\tif (!r) {\n\t\t\t\t\tstruct lpfc_vmid *ht = vmp;\n\n\t\t\t\t\tvport->cur_vmid_cnt--;\n\t\t\t\t\tht->flag = LPFC_VMID_SLOT_FREE;\n\t\t\t\t\tfree_percpu(ht->last_io_time);\n\t\t\t\t\tht->last_io_time = NULL;\n\t\t\t\t\thash_del(&ht->hnode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n out:\n\twrite_unlock(&vport->vmid_lock);\n}\n\n \n\nstatic void lpfc_check_inactive_vmid(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_vport **vports;\n\tint i;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (!vports)\n\t\treturn;\n\n\tfor (i = 0; i <= phba->max_vports; i++) {\n\t\tif ((!vports[i]) && (i == 0))\n\t\t\tvport = phba->pport;\n\t\telse\n\t\t\tvport = vports[i];\n\t\tif (!vport)\n\t\t\tbreak;\n\n\t\tlpfc_check_inactive_vmid_one(vport);\n\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\n \nvoid\nlpfc_check_nlp_post_devloss(struct lpfc_vport *vport,\n\t\t\t    struct lpfc_nodelist *ndlp)\n{\n\tunsigned long iflags;\n\n\tspin_lock_irqsave(&ndlp->lock, iflags);\n\tif (ndlp->save_flags & NLP_IN_RECOV_POST_DEV_LOSS) {\n\t\tndlp->save_flags &= ~NLP_IN_RECOV_POST_DEV_LOSS;\n\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\tlpfc_nlp_get(ndlp);\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY | LOG_NODE,\n\t\t\t\t \"8438 Devloss timeout reversed on DID x%x \"\n\t\t\t\t \"refcnt %d ndlp %p flag x%x \"\n\t\t\t\t \"port_state = x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, kref_read(&ndlp->kref), ndlp,\n\t\t\t\t ndlp->nlp_flag, vport->port_state);\n\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\t}\n\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n}\n\n \nstatic int\nlpfc_dev_loss_tmo_handler(struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_hba   *phba;\n\tuint8_t *name;\n\tint warn_on = 0;\n\tint fcf_inuse = 0;\n\tbool recovering = false;\n\tstruct fc_vport *fc_vport = NULL;\n\tunsigned long iflags;\n\n\tvport = ndlp->vport;\n\tname = (uint8_t *)&ndlp->nlp_portname;\n\tphba = vport->phba;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tfcf_inuse = lpfc_fcf_inuse(phba);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_RPORT,\n\t\t\t      \"rport devlosstmo:did:x%x type:x%x id:x%x\",\n\t\t\t      ndlp->nlp_DID, ndlp->nlp_type, ndlp->nlp_sid);\n\n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NODE,\n\t\t\t \"3182 %s x%06x, nflag x%x xflags x%x refcnt %d\\n\",\n\t\t\t __func__, ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t ndlp->fc4_xpt_flags, kref_read(&ndlp->kref));\n\n\t \n\tif (ndlp->nlp_state == NLP_STE_MAPPED_NODE) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"0284 Devloss timeout Ignored on \"\n\t\t\t\t \"WWPN %x:%x:%x:%x:%x:%x:%x:%x \"\n\t\t\t\t \"NPort x%x\\n\",\n\t\t\t\t *name, *(name+1), *(name+2), *(name+3),\n\t\t\t\t *(name+4), *(name+5), *(name+6), *(name+7),\n\t\t\t\t ndlp->nlp_DID);\n\n\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\t\tndlp->nlp_flag &= ~NLP_IN_DEV_LOSS;\n\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\treturn fcf_inuse;\n\t}\n\n\t \n\tif (ndlp->nlp_type & NLP_FABRIC) {\n\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\n\t\t \n\t\tswitch (ndlp->nlp_DID) {\n\t\tcase Fabric_DID:\n\t\t\tfc_vport = vport->fc_vport;\n\t\t\tif (fc_vport) {\n\t\t\t\t \n\t\t\t\tif (fc_vport->vport_state ==\n\t\t\t\t    FC_VPORT_INITIALIZING)\n\t\t\t\t\trecovering = true;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (phba->hba_flag & HBA_FLOGI_OUTSTANDING)\n\t\t\t\t\trecovering = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Fabric_Cntl_DID:\n\t\t\tif (ndlp->nlp_flag & NLP_REG_LOGIN_SEND)\n\t\t\t\trecovering = true;\n\t\t\tbreak;\n\t\tcase FDMI_DID:\n\t\t\tfallthrough;\n\t\tcase NameServer_DID:\n\t\t\tif (ndlp->nlp_state >= NLP_STE_PLOGI_ISSUE &&\n\t\t\t    ndlp->nlp_state <= NLP_STE_REG_LOGIN_ISSUE)\n\t\t\t\trecovering = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (ndlp->nlp_DID & Fabric_DID_MASK) {\n\t\t\t\tif (ndlp->nlp_state >= NLP_STE_PLOGI_ISSUE &&\n\t\t\t\t    ndlp->nlp_state <= NLP_STE_REG_LOGIN_ISSUE)\n\t\t\t\t\trecovering = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\n\t\t \n\t\tif (recovering) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_DISCOVERY | LOG_NODE,\n\t\t\t\t\t \"8436 Devloss timeout marked on \"\n\t\t\t\t\t \"DID x%x refcnt %d ndlp %p \"\n\t\t\t\t\t \"flag x%x port_state = x%x\\n\",\n\t\t\t\t\t ndlp->nlp_DID, kref_read(&ndlp->kref),\n\t\t\t\t\t ndlp, ndlp->nlp_flag,\n\t\t\t\t\t vport->port_state);\n\t\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\t\t\tndlp->save_flags |= NLP_IN_RECOV_POST_DEV_LOSS;\n\t\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\t} else if (ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_DISCOVERY | LOG_NODE,\n\t\t\t\t\t \"8437 Devloss timeout ignored on \"\n\t\t\t\t\t \"DID x%x refcnt %d ndlp %p \"\n\t\t\t\t\t \"flag x%x port_state = x%x\\n\",\n\t\t\t\t\t ndlp->nlp_DID, kref_read(&ndlp->kref),\n\t\t\t\t\t ndlp, ndlp->nlp_flag,\n\t\t\t\t\t vport->port_state);\n\t\t\treturn fcf_inuse;\n\t\t}\n\n\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\t\tndlp->nlp_flag &= ~NLP_IN_DEV_LOSS;\n\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn fcf_inuse;\n\t}\n\n\tif (ndlp->nlp_sid != NLP_NO_SID) {\n\t\twarn_on = 1;\n\t\tlpfc_sli_abort_iocb(vport, ndlp->nlp_sid, 0, LPFC_CTX_TGT);\n\t}\n\n\tif (warn_on) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0203 Devloss timeout on \"\n\t\t\t\t \"WWPN %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x \"\n\t\t\t\t \"NPort x%06x Data: x%x x%x x%x refcnt %d\\n\",\n\t\t\t\t *name, *(name+1), *(name+2), *(name+3),\n\t\t\t\t *(name+4), *(name+5), *(name+6), *(name+7),\n\t\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t ndlp->nlp_state, ndlp->nlp_rpi,\n\t\t\t\t kref_read(&ndlp->kref));\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_TRACE_EVENT,\n\t\t\t\t \"0204 Devloss timeout on \"\n\t\t\t\t \"WWPN %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x \"\n\t\t\t\t \"NPort x%06x Data: x%x x%x x%x\\n\",\n\t\t\t\t *name, *(name+1), *(name+2), *(name+3),\n\t\t\t\t *(name+4), *(name+5), *(name+6), *(name+7),\n\t\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t ndlp->nlp_state, ndlp->nlp_rpi);\n\t}\n\tspin_lock_irqsave(&ndlp->lock, iflags);\n\tndlp->nlp_flag &= ~NLP_IN_DEV_LOSS;\n\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\n\t \n\tif (ndlp->nlp_state >= NLP_STE_PLOGI_ISSUE &&\n\t    ndlp->nlp_state <= NLP_STE_PRLI_ISSUE) {\n\t\treturn fcf_inuse;\n\t}\n\n\tif (!(ndlp->fc4_xpt_flags & NVME_XPT_REGD))\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL, NLP_EVT_DEVICE_RM);\n\n\treturn fcf_inuse;\n}\n\nstatic void lpfc_check_vmid_qfpa_issue(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_vport **vports;\n\tint i;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (!vports)\n\t\treturn;\n\n\tfor (i = 0; i <= phba->max_vports; i++) {\n\t\tif ((!vports[i]) && (i == 0))\n\t\t\tvport = phba->pport;\n\t\telse\n\t\t\tvport = vports[i];\n\t\tif (!vport)\n\t\t\tbreak;\n\n\t\tif (vport->vmid_flag & LPFC_VMID_ISSUE_QFPA) {\n\t\t\tif (!lpfc_issue_els_qfpa(vport))\n\t\t\t\tvport->vmid_flag &= ~LPFC_VMID_ISSUE_QFPA;\n\t\t}\n\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\n \nstatic void\nlpfc_sli4_post_dev_loss_tmo_handler(struct lpfc_hba *phba, int fcf_inuse,\n\t\t\t\t    uint32_t nlp_did)\n{\n\t \n\tif (!fcf_inuse)\n\t\treturn;\n\n\tif ((phba->hba_flag & HBA_FIP_SUPPORT) && !lpfc_fcf_inuse(phba)) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tif (phba->fcf.fcf_flag & FCF_DISCOVERY) {\n\t\t\tif (phba->hba_flag & HBA_DEVLOSS_TMO) {\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tphba->hba_flag |= HBA_DEVLOSS_TMO;\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2847 Last remote node (x%x) using \"\n\t\t\t\t\t\"FCF devloss tmo\\n\", nlp_did);\n\t\t}\n\t\tif (phba->fcf.fcf_flag & FCF_REDISC_PROG) {\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2868 Devloss tmo to FCF rediscovery \"\n\t\t\t\t\t\"in progress\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (!(phba->hba_flag & (FCF_TS_INPROG | FCF_RR_INPROG))) {\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2869 Devloss tmo to idle FIP engine, \"\n\t\t\t\t\t\"unreg in-use FCF and rescan.\\n\");\n\t\t\t \n\t\t\tlpfc_unregister_fcf_rescan(phba);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tif (phba->hba_flag & FCF_TS_INPROG)\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2870 FCF table scan in progress\\n\");\n\t\tif (phba->hba_flag & FCF_RR_INPROG)\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2871 FLOGI roundrobin FCF failover \"\n\t\t\t\t\t\"in progress\\n\");\n\t}\n\tlpfc_unregister_unused_fcf(phba);\n}\n\n \nstruct lpfc_fast_path_event *\nlpfc_alloc_fast_evt(struct lpfc_hba *phba) {\n\tstruct lpfc_fast_path_event *ret;\n\n\t \n\tif (atomic_read(&phba->fast_event_count) > LPFC_MAX_EVT_COUNT)\n\t\treturn NULL;\n\n\tret = kzalloc(sizeof(struct lpfc_fast_path_event),\n\t\t\tGFP_ATOMIC);\n\tif (ret) {\n\t\tatomic_inc(&phba->fast_event_count);\n\t\tINIT_LIST_HEAD(&ret->work_evt.evt_listp);\n\t\tret->work_evt.evt = LPFC_EVT_FASTPATH_MGMT_EVT;\n\t}\n\treturn ret;\n}\n\n \nvoid\nlpfc_free_fast_evt(struct lpfc_hba *phba,\n\t\tstruct lpfc_fast_path_event *evt) {\n\n\tatomic_dec(&phba->fast_event_count);\n\tkfree(evt);\n}\n\n \nstatic void\nlpfc_send_fastpath_evt(struct lpfc_hba *phba,\n\t\tstruct lpfc_work_evt *evtp)\n{\n\tunsigned long evt_category, evt_sub_category;\n\tstruct lpfc_fast_path_event *fast_evt_data;\n\tchar *evt_data;\n\tuint32_t evt_data_size;\n\tstruct Scsi_Host *shost;\n\n\tfast_evt_data = container_of(evtp, struct lpfc_fast_path_event,\n\t\twork_evt);\n\n\tevt_category = (unsigned long) fast_evt_data->un.fabric_evt.event_type;\n\tevt_sub_category = (unsigned long) fast_evt_data->un.\n\t\t\tfabric_evt.subcategory;\n\tshost = lpfc_shost_from_vport(fast_evt_data->vport);\n\tif (evt_category == FC_REG_FABRIC_EVENT) {\n\t\tif (evt_sub_category == LPFC_EVENT_FCPRDCHKERR) {\n\t\t\tevt_data = (char *) &fast_evt_data->un.read_check_error;\n\t\t\tevt_data_size = sizeof(fast_evt_data->un.\n\t\t\t\tread_check_error);\n\t\t} else if ((evt_sub_category == LPFC_EVENT_FABRIC_BUSY) ||\n\t\t\t(evt_sub_category == LPFC_EVENT_PORT_BUSY)) {\n\t\t\tevt_data = (char *) &fast_evt_data->un.fabric_evt;\n\t\t\tevt_data_size = sizeof(fast_evt_data->un.fabric_evt);\n\t\t} else {\n\t\t\tlpfc_free_fast_evt(phba, fast_evt_data);\n\t\t\treturn;\n\t\t}\n\t} else if (evt_category == FC_REG_SCSI_EVENT) {\n\t\tswitch (evt_sub_category) {\n\t\tcase LPFC_EVENT_QFULL:\n\t\tcase LPFC_EVENT_DEVBSY:\n\t\t\tevt_data = (char *) &fast_evt_data->un.scsi_evt;\n\t\t\tevt_data_size = sizeof(fast_evt_data->un.scsi_evt);\n\t\t\tbreak;\n\t\tcase LPFC_EVENT_CHECK_COND:\n\t\t\tevt_data = (char *) &fast_evt_data->un.check_cond_evt;\n\t\t\tevt_data_size =  sizeof(fast_evt_data->un.\n\t\t\t\tcheck_cond_evt);\n\t\t\tbreak;\n\t\tcase LPFC_EVENT_VARQUEDEPTH:\n\t\t\tevt_data = (char *) &fast_evt_data->un.queue_depth_evt;\n\t\t\tevt_data_size = sizeof(fast_evt_data->un.\n\t\t\t\tqueue_depth_evt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlpfc_free_fast_evt(phba, fast_evt_data);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tlpfc_free_fast_evt(phba, fast_evt_data);\n\t\treturn;\n\t}\n\n\tif (phba->cfg_enable_fc4_type != LPFC_ENABLE_NVME)\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tevt_data_size,\n\t\t\tevt_data,\n\t\t\tLPFC_NL_VENDOR_ID);\n\n\tlpfc_free_fast_evt(phba, fast_evt_data);\n\treturn;\n}\n\nstatic void\nlpfc_work_list_done(struct lpfc_hba *phba)\n{\n\tstruct lpfc_work_evt  *evtp = NULL;\n\tstruct lpfc_nodelist  *ndlp;\n\tint free_evt;\n\tint fcf_inuse;\n\tuint32_t nlp_did;\n\tbool hba_pci_err;\n\n\tspin_lock_irq(&phba->hbalock);\n\twhile (!list_empty(&phba->work_list)) {\n\t\tlist_remove_head((&phba->work_list), evtp, typeof(*evtp),\n\t\t\t\t evt_listp);\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\thba_pci_err = test_bit(HBA_PCI_ERR, &phba->bit_flags);\n\t\tfree_evt = 1;\n\t\tswitch (evtp->evt) {\n\t\tcase LPFC_EVT_ELS_RETRY:\n\t\t\tndlp = (struct lpfc_nodelist *) (evtp->evt_arg1);\n\t\t\tif (!hba_pci_err) {\n\t\t\t\tlpfc_els_retry_delay_handler(ndlp);\n\t\t\t\tfree_evt = 0;  \n\t\t\t}\n\t\t\t \n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tbreak;\n\t\tcase LPFC_EVT_DEV_LOSS:\n\t\t\tndlp = (struct lpfc_nodelist *)(evtp->evt_arg1);\n\t\t\tfcf_inuse = lpfc_dev_loss_tmo_handler(ndlp);\n\t\t\tfree_evt = 0;\n\t\t\t \n\t\t\tnlp_did = ndlp->nlp_DID;\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\tlpfc_sli4_post_dev_loss_tmo_handler(phba,\n\t\t\t\t\t\t\t\t    fcf_inuse,\n\t\t\t\t\t\t\t\t    nlp_did);\n\t\t\tbreak;\n\t\tcase LPFC_EVT_RECOVER_PORT:\n\t\t\tndlp = (struct lpfc_nodelist *)(evtp->evt_arg1);\n\t\t\tif (!hba_pci_err) {\n\t\t\t\tlpfc_sli_abts_recover_port(ndlp->vport, ndlp);\n\t\t\t\tfree_evt = 0;\n\t\t\t}\n\t\t\t \n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tbreak;\n\t\tcase LPFC_EVT_ONLINE:\n\t\t\tif (phba->link_state < LPFC_LINK_DOWN)\n\t\t\t\t*(int *) (evtp->evt_arg1) = lpfc_online(phba);\n\t\t\telse\n\t\t\t\t*(int *) (evtp->evt_arg1) = 0;\n\t\t\tcomplete((struct completion *)(evtp->evt_arg2));\n\t\t\tbreak;\n\t\tcase LPFC_EVT_OFFLINE_PREP:\n\t\t\tif (phba->link_state >= LPFC_LINK_DOWN)\n\t\t\t\tlpfc_offline_prep(phba, LPFC_MBX_WAIT);\n\t\t\t*(int *)(evtp->evt_arg1) = 0;\n\t\t\tcomplete((struct completion *)(evtp->evt_arg2));\n\t\t\tbreak;\n\t\tcase LPFC_EVT_OFFLINE:\n\t\t\tlpfc_offline(phba);\n\t\t\tlpfc_sli_brdrestart(phba);\n\t\t\t*(int *)(evtp->evt_arg1) =\n\t\t\t\tlpfc_sli_brdready(phba, HS_FFRDY | HS_MBRDY);\n\t\t\tlpfc_unblock_mgmt_io(phba);\n\t\t\tcomplete((struct completion *)(evtp->evt_arg2));\n\t\t\tbreak;\n\t\tcase LPFC_EVT_WARM_START:\n\t\t\tlpfc_offline(phba);\n\t\t\tlpfc_reset_barrier(phba);\n\t\t\tlpfc_sli_brdreset(phba);\n\t\t\tlpfc_hba_down_post(phba);\n\t\t\t*(int *)(evtp->evt_arg1) =\n\t\t\t\tlpfc_sli_brdready(phba, HS_MBRDY);\n\t\t\tlpfc_unblock_mgmt_io(phba);\n\t\t\tcomplete((struct completion *)(evtp->evt_arg2));\n\t\t\tbreak;\n\t\tcase LPFC_EVT_KILL:\n\t\t\tlpfc_offline(phba);\n\t\t\t*(int *)(evtp->evt_arg1)\n\t\t\t\t= (phba->pport->stopped)\n\t\t\t\t        ? 0 : lpfc_sli_brdkill(phba);\n\t\t\tlpfc_unblock_mgmt_io(phba);\n\t\t\tcomplete((struct completion *)(evtp->evt_arg2));\n\t\t\tbreak;\n\t\tcase LPFC_EVT_FASTPATH_MGMT_EVT:\n\t\t\tlpfc_send_fastpath_evt(phba, evtp);\n\t\t\tfree_evt = 0;\n\t\t\tbreak;\n\t\tcase LPFC_EVT_RESET_HBA:\n\t\t\tif (!(phba->pport->load_flag & FC_UNLOADING))\n\t\t\t\tlpfc_reset_hba(phba);\n\t\t\tbreak;\n\t\t}\n\t\tif (free_evt)\n\t\t\tkfree(evtp);\n\t\tspin_lock_irq(&phba->hbalock);\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n}\n\nstatic void\nlpfc_work_done(struct lpfc_hba *phba)\n{\n\tstruct lpfc_sli_ring *pring;\n\tuint32_t ha_copy, status, control, work_port_events;\n\tstruct lpfc_vport **vports;\n\tstruct lpfc_vport *vport;\n\tint i;\n\tbool hba_pci_err;\n\n\thba_pci_err = test_bit(HBA_PCI_ERR, &phba->bit_flags);\n\tspin_lock_irq(&phba->hbalock);\n\tha_copy = phba->work_ha;\n\tphba->work_ha = 0;\n\tspin_unlock_irq(&phba->hbalock);\n\tif (hba_pci_err)\n\t\tha_copy = 0;\n\n\t \n\tif (phba->pci_dev_grp == LPFC_PCI_DEV_OC && !hba_pci_err)\n\t\tlpfc_sli4_post_async_mbox(phba);\n\n\tif (ha_copy & HA_ERATT) {\n\t\t \n\t\tlpfc_handle_eratt(phba);\n\n\t\tif (phba->fw_dump_cmpl) {\n\t\t\tcomplete(phba->fw_dump_cmpl);\n\t\t\tphba->fw_dump_cmpl = NULL;\n\t\t}\n\t}\n\n\tif (ha_copy & HA_MBATT)\n\t\tlpfc_sli_handle_mb_event(phba);\n\n\tif (ha_copy & HA_LATT)\n\t\tlpfc_handle_latt(phba);\n\n\t \n\tif (lpfc_is_vmid_enabled(phba) && !hba_pci_err) {\n\t\tif (phba->pport->work_port_events &\n\t\t    WORKER_CHECK_VMID_ISSUE_QFPA) {\n\t\t\tlpfc_check_vmid_qfpa_issue(phba);\n\t\t\tphba->pport->work_port_events &=\n\t\t\t\t~WORKER_CHECK_VMID_ISSUE_QFPA;\n\t\t}\n\t\tif (phba->pport->work_port_events &\n\t\t    WORKER_CHECK_INACTIVE_VMID) {\n\t\t\tlpfc_check_inactive_vmid(phba);\n\t\t\tphba->pport->work_port_events &=\n\t\t\t    ~WORKER_CHECK_INACTIVE_VMID;\n\t\t}\n\t}\n\n\t \n\tif (phba->pci_dev_grp == LPFC_PCI_DEV_OC) {\n\t\tif (phba->hba_flag & HBA_RRQ_ACTIVE)\n\t\t\tlpfc_handle_rrq_active(phba);\n\t\tif (phba->hba_flag & ELS_XRI_ABORT_EVENT)\n\t\t\tlpfc_sli4_els_xri_abort_event_proc(phba);\n\t\tif (phba->hba_flag & ASYNC_EVENT)\n\t\t\tlpfc_sli4_async_event_proc(phba);\n\t\tif (phba->hba_flag & HBA_POST_RECEIVE_BUFFER) {\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->hba_flag &= ~HBA_POST_RECEIVE_BUFFER;\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tlpfc_sli_hbqbuf_add_hbqs(phba, LPFC_ELS_HBQ);\n\t\t}\n\t\tif (phba->fcf.fcf_flag & FCF_REDISC_EVT)\n\t\t\tlpfc_sli4_fcf_redisc_event_proc(phba);\n\t}\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL)\n\t\tfor (i = 0; i <= phba->max_vports; i++) {\n\t\t\t \n\t\t\tif (vports[i] == NULL && i == 0)\n\t\t\t\tvport = phba->pport;\n\t\t\telse\n\t\t\t\tvport = vports[i];\n\t\t\tif (vport == NULL)\n\t\t\t\tbreak;\n\t\t\tspin_lock_irq(&vport->work_port_lock);\n\t\t\twork_port_events = vport->work_port_events;\n\t\t\tvport->work_port_events &= ~work_port_events;\n\t\t\tspin_unlock_irq(&vport->work_port_lock);\n\t\t\tif (hba_pci_err)\n\t\t\t\tcontinue;\n\t\t\tif (work_port_events & WORKER_DISC_TMO)\n\t\t\t\tlpfc_disc_timeout_handler(vport);\n\t\t\tif (work_port_events & WORKER_ELS_TMO)\n\t\t\t\tlpfc_els_timeout_handler(vport);\n\t\t\tif (work_port_events & WORKER_HB_TMO)\n\t\t\t\tlpfc_hb_timeout_handler(phba);\n\t\t\tif (work_port_events & WORKER_MBOX_TMO)\n\t\t\t\tlpfc_mbox_timeout_handler(phba);\n\t\t\tif (work_port_events & WORKER_FABRIC_BLOCK_TMO)\n\t\t\t\tlpfc_unblock_fabric_iocbs(phba);\n\t\t\tif (work_port_events & WORKER_RAMP_DOWN_QUEUE)\n\t\t\t\tlpfc_ramp_down_queue_handler(phba);\n\t\t\tif (work_port_events & WORKER_DELAYED_DISC_TMO)\n\t\t\t\tlpfc_delayed_disc_timeout_handler(vport);\n\t\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n\n\tpring = lpfc_phba_elsring(phba);\n\tstatus = (ha_copy & (HA_RXMASK  << (4*LPFC_ELS_RING)));\n\tstatus >>= (4*LPFC_ELS_RING);\n\tif (pring && (status & HA_RXMASK ||\n\t\t      pring->flag & LPFC_DEFERRED_RING_EVENT ||\n\t\t      phba->hba_flag & HBA_SP_QUEUE_EVT)) {\n\t\tif (pring->flag & LPFC_STOP_IOCB_EVENT) {\n\t\t\tpring->flag |= LPFC_DEFERRED_RING_EVENT;\n\t\t\t \n\t\t\tif (!(phba->hba_flag & HBA_SP_QUEUE_EVT))\n\t\t\t\tset_bit(LPFC_DATA_READY, &phba->data_flags);\n\t\t} else {\n\t\t\t \n\t\t\tif (phba->link_state >= LPFC_LINK_DOWN ||\n\t\t\t    phba->link_flag & LS_MDS_LOOPBACK) {\n\t\t\t\tpring->flag &= ~LPFC_DEFERRED_RING_EVENT;\n\t\t\t\tlpfc_sli_handle_slow_ring_event(phba, pring,\n\t\t\t\t\t\t\t\t(status &\n\t\t\t\t\t\t\t\tHA_RXMASK));\n\t\t\t}\n\t\t}\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_drain_txq(phba);\n\t\t \n\t\tif (phba->sli_rev <= LPFC_SLI_REV3) {\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tcontrol = readl(phba->HCregaddr);\n\t\t\tif (!(control & (HC_R0INT_ENA << LPFC_ELS_RING))) {\n\t\t\t\tlpfc_debugfs_slow_ring_trc(phba,\n\t\t\t\t\t\"WRK Enable ring: cntl:x%x hacopy:x%x\",\n\t\t\t\t\tcontrol, ha_copy, 0);\n\n\t\t\t\tcontrol |= (HC_R0INT_ENA << LPFC_ELS_RING);\n\t\t\t\twritel(control, phba->HCregaddr);\n\t\t\t\treadl(phba->HCregaddr);  \n\t\t\t} else {\n\t\t\t\tlpfc_debugfs_slow_ring_trc(phba,\n\t\t\t\t\t\"WRK Ring ok:     cntl:x%x hacopy:x%x\",\n\t\t\t\t\tcontrol, ha_copy, 0);\n\t\t\t}\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t}\n\t}\n\tlpfc_work_list_done(phba);\n}\n\nint\nlpfc_do_work(void *p)\n{\n\tstruct lpfc_hba *phba = p;\n\tint rc;\n\n\tset_user_nice(current, MIN_NICE);\n\tcurrent->flags |= PF_NOFREEZE;\n\tphba->data_flags = 0;\n\n\twhile (!kthread_should_stop()) {\n\t\t \n\t\trc = wait_event_interruptible(phba->work_waitq,\n\t\t\t\t\t(test_and_clear_bit(LPFC_DATA_READY,\n\t\t\t\t\t\t\t    &phba->data_flags)\n\t\t\t\t\t || kthread_should_stop()));\n\t\t \n\t\tif (rc) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0433 Wakeup on signal: rc=x%x\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlpfc_work_done(phba);\n\t}\n\tphba->worker_thread = NULL;\n\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\"0432 Worker thread stopped.\\n\");\n\treturn 0;\n}\n\n \nint\nlpfc_workq_post_event(struct lpfc_hba *phba, void *arg1, void *arg2,\n\t\t      uint32_t evt)\n{\n\tstruct lpfc_work_evt  *evtp;\n\tunsigned long flags;\n\n\t \n\tevtp = kmalloc(sizeof(struct lpfc_work_evt), GFP_ATOMIC);\n\tif (!evtp)\n\t\treturn 0;\n\n\tevtp->evt_arg1  = arg1;\n\tevtp->evt_arg2  = arg2;\n\tevtp->evt       = evt;\n\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tlist_add_tail(&evtp->evt_listp, &phba->work_list);\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\n\tlpfc_worker_wake_up(phba);\n\n\treturn 1;\n}\n\nvoid\nlpfc_cleanup_rpis(struct lpfc_vport *vport, int remove)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif ((phba->sli3_options & LPFC_SLI3_VPORT_TEARDOWN) ||\n\t\t    ((vport->port_type == LPFC_NPIV_PORT) &&\n\t\t     ((ndlp->nlp_DID == NameServer_DID) ||\n\t\t      (ndlp->nlp_DID == FDMI_DID) ||\n\t\t      (ndlp->nlp_DID == Fabric_Cntl_DID))))\n\t\t\tlpfc_unreg_rpi(vport, ndlp);\n\n\t\t \n\t\tif ((phba->sli_rev < LPFC_SLI_REV4) &&\n\t\t    (!remove && ndlp->nlp_type & NLP_FABRIC))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (phba->nvmet_support &&\n\t\t    ndlp->nlp_state == NLP_STE_UNMAPPED_NODE)\n\t\t\tlpfc_nvmet_invalidate_host(phba, ndlp);\n\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tremove\n\t\t\t\t\t? NLP_EVT_DEVICE_RM\n\t\t\t\t\t: NLP_EVT_DEVICE_RECOVERY);\n\t}\n\tif (phba->sli3_options & LPFC_SLI3_VPORT_TEARDOWN) {\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\t\tlpfc_mbx_unreg_vpi(vport);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n}\n\nvoid\nlpfc_port_link_failure(struct lpfc_vport *vport)\n{\n\tlpfc_vport_set_state(vport, FC_VPORT_LINKDOWN);\n\n\t \n\tlpfc_cleanup_rcv_buffers(vport);\n\n\t \n\tlpfc_els_flush_rscn(vport);\n\n\t \n\tlpfc_els_flush_cmd(vport);\n\n\tlpfc_cleanup_rpis(vport, 0);\n\n\t \n\tlpfc_can_disctmo(vport);\n}\n\nvoid\nlpfc_linkdown_port(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\n\tif (vport->cfg_enable_fc4_type != LPFC_ENABLE_NVME)\n\t\tfc_host_post_event(shost, fc_get_event_number(),\n\t\t\t\t   FCH_EVT_LINKDOWN, 0);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Link Down:       state:x%x rtry:x%x flg:x%x\",\n\t\tvport->port_state, vport->fc_ns_retry, vport->fc_flag);\n\n\tlpfc_port_link_failure(vport);\n\n\t \n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_DISC_DELAYED;\n\tspin_unlock_irq(shost->host_lock);\n\tdel_timer_sync(&vport->delayed_disc_tmo);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    vport->port_type == LPFC_PHYSICAL_PORT &&\n\t    phba->sli4_hba.fawwpn_flag & LPFC_FAWWPN_CONFIG) {\n\t\t \n\t\tphba->sli4_hba.fawwpn_flag |= LPFC_FAWWPN_FABRIC;\n\t}\n}\n\nint\nlpfc_linkdown(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport *vport = phba->pport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_vport **vports;\n\tLPFC_MBOXQ_t          *mb;\n\tint i;\n\tint offline;\n\n\tif (phba->link_state == LPFC_LINK_DOWN)\n\t\treturn 0;\n\n\t \n\tlpfc_scsi_dev_block(phba);\n\toffline = pci_channel_offline(phba->pcidev);\n\n\tphba->defer_flogi_acc_flag = false;\n\n\t \n\tphba->link_flag &= ~LS_EXTERNAL_LOOPBACK;\n\n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag &= ~(FCF_AVAILABLE | FCF_SCAN_DONE);\n\tspin_unlock_irq(&phba->hbalock);\n\tif (phba->link_state > LPFC_LINK_DOWN) {\n\t\tphba->link_state = LPFC_LINK_DOWN;\n\t\tif (phba->sli4_hba.conf_trunk) {\n\t\t\tphba->trunk_link.link0.state = 0;\n\t\t\tphba->trunk_link.link1.state = 0;\n\t\t\tphba->trunk_link.link2.state = 0;\n\t\t\tphba->trunk_link.link3.state = 0;\n\t\t\tphba->trunk_link.phy_lnk_speed =\n\t\t\t\t\t\tLPFC_LINK_SPEED_UNKNOWN;\n\t\t\tphba->sli4_hba.link_state.logical_speed =\n\t\t\t\t\t\tLPFC_LINK_SPEED_UNKNOWN;\n\t\t}\n\t\tspin_lock_irq(shost->host_lock);\n\t\tphba->pport->fc_flag &= ~FC_LBIT;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL) {\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\t \n\t\t\tlpfc_linkdown_port(vports[i]);\n\n\t\t\tvports[i]->fc_myDID = 0;\n\n\t\t\tif ((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t\t\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) {\n\t\t\t\tif (phba->nvmet_support)\n\t\t\t\t\tlpfc_nvmet_update_targetport(phba);\n\t\t\t\telse\n\t\t\t\t\tlpfc_nvme_update_localport(vports[i]);\n\t\t\t}\n\t\t}\n\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n\n\t \n\tif (phba->sli_rev > LPFC_SLI_REV3 || offline)\n\t\tgoto skip_unreg_did;\n\n\tmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (mb) {\n\t\tlpfc_unreg_did(phba, 0xffff, LPFC_UNREG_ALL_DFLT_RPIS, mb);\n\t\tmb->vport = vport;\n\t\tmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\tif (lpfc_sli_issue_mbox(phba, mb, MBX_NOWAIT)\n\t\t    == MBX_NOT_FINISHED) {\n\t\t\tmempool_free(mb, phba->mbox_mem_pool);\n\t\t}\n\t}\n\n skip_unreg_did:\n\t \n\tif (phba->pport->fc_flag & FC_PT2PT) {\n\t\tmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (mb) {\n\t\t\tlpfc_config_link(phba, mb);\n\t\t\tmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\t\tmb->vport = vport;\n\t\t\tif (lpfc_sli_issue_mbox(phba, mb, MBX_NOWAIT)\n\t\t\t    == MBX_NOT_FINISHED) {\n\t\t\t\tmempool_free(mb, phba->mbox_mem_pool);\n\t\t\t}\n\t\t}\n\t\tspin_lock_irq(shost->host_lock);\n\t\tphba->pport->fc_flag &= ~(FC_PT2PT | FC_PT2PT_PLOGI);\n\t\tphba->pport->rcv_flogi_cnt = 0;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\treturn 0;\n}\n\nstatic void\nlpfc_linkup_cleanup_nodes(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tndlp->nlp_fc4_type &= ~(NLP_FC4_FCP | NLP_FC4_NVME);\n\n\t\tif (ndlp->nlp_state == NLP_STE_UNUSED_NODE)\n\t\t\tcontinue;\n\t\tif (ndlp->nlp_type & NLP_FABRIC) {\n\t\t\t \n\t\t\tif (ndlp->nlp_DID != Fabric_DID)\n\t\t\t\tlpfc_unreg_rpi(vport, ndlp);\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\t} else if (!(ndlp->nlp_flag & NLP_NPR_ADISC)) {\n\t\t\t \n\t\t\tlpfc_unreg_rpi(vport, ndlp);\n\t\t}\n\t}\n}\n\nstatic void\nlpfc_linkup_port(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\n\tif ((vport->load_flag & FC_UNLOADING) != 0)\n\t\treturn;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Link Up:         top:x%x speed:x%x flg:x%x\",\n\t\tphba->fc_topology, phba->fc_linkspeed, phba->link_flag);\n\n\t \n\tif (!(phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t\t(vport != phba->pport))\n\t\treturn;\n\n\tif (vport->cfg_enable_fc4_type != LPFC_ENABLE_NVME)\n\t\tfc_host_post_event(shost, fc_get_event_number(),\n\t\t\t\t   FCH_EVT_LINKUP, 0);\n\n\tspin_lock_irq(shost->host_lock);\n\tif (phba->defer_flogi_acc_flag)\n\t\tvport->fc_flag &= ~(FC_ABORT_DISCOVERY | FC_RSCN_MODE |\n\t\t\t\t    FC_NLP_MORE | FC_RSCN_DISCOVERY);\n\telse\n\t\tvport->fc_flag &= ~(FC_PT2PT | FC_PT2PT_PLOGI |\n\t\t\t\t    FC_ABORT_DISCOVERY | FC_RSCN_MODE |\n\t\t\t\t    FC_NLP_MORE | FC_RSCN_DISCOVERY);\n\tvport->fc_flag |= FC_NDISC_ACTIVE;\n\tvport->fc_ns_retry = 0;\n\tspin_unlock_irq(shost->host_lock);\n\tlpfc_setup_fdmi_mask(vport);\n\n\tlpfc_linkup_cleanup_nodes(vport);\n}\n\nstatic int\nlpfc_linkup(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tint i;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(phba->pport);\n\n\tphba->link_state = LPFC_LINK_UP;\n\n\t \n\tclear_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\n\tdel_timer_sync(&phba->fabric_block_timer);\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL)\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++)\n\t\t\tlpfc_linkup_port(vports[i]);\n\tlpfc_destroy_vport_work_array(phba, vports);\n\n\t \n\tspin_lock_irq(shost->host_lock);\n\tphba->pport->rcv_flogi_cnt = 0;\n\tspin_unlock_irq(shost->host_lock);\n\n\t \n\tphba->hba_flag &= ~(HBA_FLOGI_ISSUED | HBA_RHBA_CMPL);\n\n\treturn 0;\n}\n\n \nstatic void\nlpfc_mbx_cmpl_clear_la(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport *vport = pmb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_sli   *psli = &phba->sli;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tuint32_t control;\n\n\t \n\tpsli->sli3_ring[LPFC_EXTRA_RING].flag &= ~LPFC_STOP_IOCB_EVENT;\n\tpsli->sli3_ring[LPFC_FCP_RING].flag &= ~LPFC_STOP_IOCB_EVENT;\n\n\t \n\tif ((mb->mbxStatus) && (mb->mbxStatus != 0x1601)) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0320 CLEAR_LA mbxStatus error x%x hba \"\n\t\t\t\t \"state x%x\\n\",\n\t\t\t\t mb->mbxStatus, vport->port_state);\n\t\tphba->link_state = LPFC_HBA_ERROR;\n\t\tgoto out;\n\t}\n\n\tif (vport->port_type == LPFC_PHYSICAL_PORT)\n\t\tphba->link_state = LPFC_HBA_READY;\n\n\tspin_lock_irq(&phba->hbalock);\n\tpsli->sli_flag |= LPFC_PROCESS_LA;\n\tcontrol = readl(phba->HCregaddr);\n\tcontrol |= HC_LAINT_ENA;\n\twritel(control, phba->HCregaddr);\n\treadl(phba->HCregaddr);  \n\tspin_unlock_irq(&phba->hbalock);\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\treturn;\n\nout:\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0225 Device Discovery completes\\n\");\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_ABORT_DISCOVERY;\n\tspin_unlock_irq(shost->host_lock);\n\n\tlpfc_can_disctmo(vport);\n\n\t \n\n\tspin_lock_irq(&phba->hbalock);\n\tpsli->sli_flag |= LPFC_PROCESS_LA;\n\tcontrol = readl(phba->HCregaddr);\n\tcontrol |= HC_LAINT_ENA;\n\twritel(control, phba->HCregaddr);\n\treadl(phba->HCregaddr);  \n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn;\n}\n\nvoid\nlpfc_mbx_cmpl_local_config_link(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport *vport = pmb->vport;\n\tLPFC_MBOXQ_t *sparam_mb;\n\tu16 status = pmb->u.mb.mbxStatus;\n\tint rc;\n\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\n\tif (status)\n\t\tgoto out;\n\n\t \n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    !(phba->hba_flag & HBA_FCOE_MODE) &&\n\t    (phba->link_flag & LS_LOOPBACK_MODE))\n\t\treturn;\n\n\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP &&\n\t    vport->fc_flag & FC_PUBLIC_LOOP &&\n\t    !(vport->fc_flag & FC_LBIT)) {\n\t\t\t \n\t\t\tlpfc_set_disctmo(vport);\n\t\t\treturn;\n\t}\n\n\t \n\tif (vport->port_state != LPFC_FLOGI) {\n\t\t \n\t\tif (phba->bbcredit_support && phba->cfg_enable_bbcr &&\n\t\t    !(phba->link_flag & LS_LOOPBACK_MODE)) {\n\t\t\tsparam_mb = mempool_alloc(phba->mbox_mem_pool,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!sparam_mb)\n\t\t\t\tgoto sparam_out;\n\n\t\t\trc = lpfc_read_sparam(phba, sparam_mb, 0);\n\t\t\tif (rc) {\n\t\t\t\tmempool_free(sparam_mb, phba->mbox_mem_pool);\n\t\t\t\tgoto sparam_out;\n\t\t\t}\n\t\t\tsparam_mb->vport = vport;\n\t\t\tsparam_mb->mbox_cmpl = lpfc_mbx_cmpl_read_sparam;\n\t\t\trc = lpfc_sli_issue_mbox(phba, sparam_mb, MBX_NOWAIT);\n\t\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\t\tlpfc_mbox_rsrc_cleanup(phba, sparam_mb,\n\t\t\t\t\t\t       MBOX_THD_UNLOCKED);\n\t\t\t\tgoto sparam_out;\n\t\t\t}\n\n\t\t\tphba->hba_flag |= HBA_DEFER_FLOGI;\n\t\t}  else {\n\t\t\tlpfc_initial_flogi(vport);\n\t\t}\n\t} else {\n\t\tif (vport->fc_flag & FC_PT2PT)\n\t\t\tlpfc_disc_start(vport);\n\t}\n\treturn;\n\nout:\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0306 CONFIG_LINK mbxStatus error x%x HBA state x%x\\n\",\n\t\t\t status, vport->port_state);\n\nsparam_out:\n\tlpfc_linkdown(phba);\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0200 CONFIG_LINK bad hba state x%x\\n\",\n\t\t\t vport->port_state);\n\n\tlpfc_issue_clear_la(phba, vport);\n\treturn;\n}\n\n \nvoid\nlpfc_sli4_clear_fcf_rr_bmask(struct lpfc_hba *phba)\n{\n\tstruct lpfc_fcf_pri *fcf_pri;\n\tstruct lpfc_fcf_pri *next_fcf_pri;\n\tmemset(phba->fcf.fcf_rr_bmask, 0, sizeof(*phba->fcf.fcf_rr_bmask));\n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(fcf_pri, next_fcf_pri,\n\t\t\t\t&phba->fcf.fcf_pri_list, list) {\n\t\tlist_del_init(&fcf_pri->list);\n\t\tfcf_pri->fcf_rec.flag = 0;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n}\nstatic void\nlpfc_mbx_cmpl_reg_fcfi(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct lpfc_vport *vport = mboxq->vport;\n\n\tif (mboxq->u.mb.mbxStatus) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2017 REG_FCFI mbxStatus error x%x \"\n\t\t\t\t \"HBA state x%x\\n\", mboxq->u.mb.mbxStatus,\n\t\t\t\t vport->port_state);\n\t\tgoto fail_out;\n\t}\n\n\t \n\tphba->fcf.fcfi = bf_get(lpfc_reg_fcfi_fcfi, &mboxq->u.mqe.un.reg_fcfi);\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag |= FCF_REGISTERED;\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tif ((!(phba->hba_flag & FCF_RR_INPROG)) &&\n\t\tlpfc_check_pending_fcoe_event(phba, LPFC_UNREG_FCF))\n\t\tgoto fail_out;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag |= (FCF_SCAN_DONE | FCF_IN_USE);\n\tphba->hba_flag &= ~FCF_TS_INPROG;\n\tif (vport->port_state != LPFC_FLOGI) {\n\t\tphba->hba_flag |= FCF_RR_INPROG;\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tlpfc_issue_init_vfi(vport);\n\t\tgoto out;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\tgoto out;\n\nfail_out:\n\tspin_lock_irq(&phba->hbalock);\n\tphba->hba_flag &= ~FCF_RR_INPROG;\n\tspin_unlock_irq(&phba->hbalock);\nout:\n\tmempool_free(mboxq, phba->mbox_mem_pool);\n}\n\n \nstatic uint32_t\nlpfc_fab_name_match(uint8_t *fab_name, struct fcf_record *new_fcf_record)\n{\n\tif (fab_name[0] != bf_get(lpfc_fcf_record_fab_name_0, new_fcf_record))\n\t\treturn 0;\n\tif (fab_name[1] != bf_get(lpfc_fcf_record_fab_name_1, new_fcf_record))\n\t\treturn 0;\n\tif (fab_name[2] != bf_get(lpfc_fcf_record_fab_name_2, new_fcf_record))\n\t\treturn 0;\n\tif (fab_name[3] != bf_get(lpfc_fcf_record_fab_name_3, new_fcf_record))\n\t\treturn 0;\n\tif (fab_name[4] != bf_get(lpfc_fcf_record_fab_name_4, new_fcf_record))\n\t\treturn 0;\n\tif (fab_name[5] != bf_get(lpfc_fcf_record_fab_name_5, new_fcf_record))\n\t\treturn 0;\n\tif (fab_name[6] != bf_get(lpfc_fcf_record_fab_name_6, new_fcf_record))\n\t\treturn 0;\n\tif (fab_name[7] != bf_get(lpfc_fcf_record_fab_name_7, new_fcf_record))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic uint32_t\nlpfc_sw_name_match(uint8_t *sw_name, struct fcf_record *new_fcf_record)\n{\n\tif (sw_name[0] != bf_get(lpfc_fcf_record_switch_name_0, new_fcf_record))\n\t\treturn 0;\n\tif (sw_name[1] != bf_get(lpfc_fcf_record_switch_name_1, new_fcf_record))\n\t\treturn 0;\n\tif (sw_name[2] != bf_get(lpfc_fcf_record_switch_name_2, new_fcf_record))\n\t\treturn 0;\n\tif (sw_name[3] != bf_get(lpfc_fcf_record_switch_name_3, new_fcf_record))\n\t\treturn 0;\n\tif (sw_name[4] != bf_get(lpfc_fcf_record_switch_name_4, new_fcf_record))\n\t\treturn 0;\n\tif (sw_name[5] != bf_get(lpfc_fcf_record_switch_name_5, new_fcf_record))\n\t\treturn 0;\n\tif (sw_name[6] != bf_get(lpfc_fcf_record_switch_name_6, new_fcf_record))\n\t\treturn 0;\n\tif (sw_name[7] != bf_get(lpfc_fcf_record_switch_name_7, new_fcf_record))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic uint32_t\nlpfc_mac_addr_match(uint8_t *mac_addr, struct fcf_record *new_fcf_record)\n{\n\tif (mac_addr[0] != bf_get(lpfc_fcf_record_mac_0, new_fcf_record))\n\t\treturn 0;\n\tif (mac_addr[1] != bf_get(lpfc_fcf_record_mac_1, new_fcf_record))\n\t\treturn 0;\n\tif (mac_addr[2] != bf_get(lpfc_fcf_record_mac_2, new_fcf_record))\n\t\treturn 0;\n\tif (mac_addr[3] != bf_get(lpfc_fcf_record_mac_3, new_fcf_record))\n\t\treturn 0;\n\tif (mac_addr[4] != bf_get(lpfc_fcf_record_mac_4, new_fcf_record))\n\t\treturn 0;\n\tif (mac_addr[5] != bf_get(lpfc_fcf_record_mac_5, new_fcf_record))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic bool\nlpfc_vlan_id_match(uint16_t curr_vlan_id, uint16_t new_vlan_id)\n{\n\treturn (curr_vlan_id == new_vlan_id);\n}\n\n \nstatic void\n__lpfc_update_fcf_record_pri(struct lpfc_hba *phba, uint16_t fcf_index,\n\t\t\t\t struct fcf_record *new_fcf_record\n\t\t\t\t )\n{\n\tstruct lpfc_fcf_pri *fcf_pri;\n\n\tfcf_pri = &phba->fcf.fcf_pri[fcf_index];\n\tfcf_pri->fcf_rec.fcf_index = fcf_index;\n\t \n\tfcf_pri->fcf_rec.priority = new_fcf_record->fip_priority;\n\n}\n\n \nstatic void\nlpfc_copy_fcf_record(struct lpfc_fcf_rec *fcf_rec,\n\t\t     struct fcf_record *new_fcf_record)\n{\n\t \n\tfcf_rec->fabric_name[0] =\n\t\tbf_get(lpfc_fcf_record_fab_name_0, new_fcf_record);\n\tfcf_rec->fabric_name[1] =\n\t\tbf_get(lpfc_fcf_record_fab_name_1, new_fcf_record);\n\tfcf_rec->fabric_name[2] =\n\t\tbf_get(lpfc_fcf_record_fab_name_2, new_fcf_record);\n\tfcf_rec->fabric_name[3] =\n\t\tbf_get(lpfc_fcf_record_fab_name_3, new_fcf_record);\n\tfcf_rec->fabric_name[4] =\n\t\tbf_get(lpfc_fcf_record_fab_name_4, new_fcf_record);\n\tfcf_rec->fabric_name[5] =\n\t\tbf_get(lpfc_fcf_record_fab_name_5, new_fcf_record);\n\tfcf_rec->fabric_name[6] =\n\t\tbf_get(lpfc_fcf_record_fab_name_6, new_fcf_record);\n\tfcf_rec->fabric_name[7] =\n\t\tbf_get(lpfc_fcf_record_fab_name_7, new_fcf_record);\n\t \n\tfcf_rec->mac_addr[0] = bf_get(lpfc_fcf_record_mac_0, new_fcf_record);\n\tfcf_rec->mac_addr[1] = bf_get(lpfc_fcf_record_mac_1, new_fcf_record);\n\tfcf_rec->mac_addr[2] = bf_get(lpfc_fcf_record_mac_2, new_fcf_record);\n\tfcf_rec->mac_addr[3] = bf_get(lpfc_fcf_record_mac_3, new_fcf_record);\n\tfcf_rec->mac_addr[4] = bf_get(lpfc_fcf_record_mac_4, new_fcf_record);\n\tfcf_rec->mac_addr[5] = bf_get(lpfc_fcf_record_mac_5, new_fcf_record);\n\t \n\tfcf_rec->fcf_indx = bf_get(lpfc_fcf_record_fcf_index, new_fcf_record);\n\t \n\tfcf_rec->priority = new_fcf_record->fip_priority;\n\t \n\tfcf_rec->switch_name[0] =\n\t\tbf_get(lpfc_fcf_record_switch_name_0, new_fcf_record);\n\tfcf_rec->switch_name[1] =\n\t\tbf_get(lpfc_fcf_record_switch_name_1, new_fcf_record);\n\tfcf_rec->switch_name[2] =\n\t\tbf_get(lpfc_fcf_record_switch_name_2, new_fcf_record);\n\tfcf_rec->switch_name[3] =\n\t\tbf_get(lpfc_fcf_record_switch_name_3, new_fcf_record);\n\tfcf_rec->switch_name[4] =\n\t\tbf_get(lpfc_fcf_record_switch_name_4, new_fcf_record);\n\tfcf_rec->switch_name[5] =\n\t\tbf_get(lpfc_fcf_record_switch_name_5, new_fcf_record);\n\tfcf_rec->switch_name[6] =\n\t\tbf_get(lpfc_fcf_record_switch_name_6, new_fcf_record);\n\tfcf_rec->switch_name[7] =\n\t\tbf_get(lpfc_fcf_record_switch_name_7, new_fcf_record);\n}\n\n \nstatic void\n__lpfc_update_fcf_record(struct lpfc_hba *phba, struct lpfc_fcf_rec *fcf_rec,\n\t\t       struct fcf_record *new_fcf_record, uint32_t addr_mode,\n\t\t       uint16_t vlan_id, uint32_t flag)\n{\n\tlockdep_assert_held(&phba->hbalock);\n\n\t \n\tlpfc_copy_fcf_record(fcf_rec, new_fcf_record);\n\t \n\tfcf_rec->addr_mode = addr_mode;\n\tfcf_rec->vlan_id = vlan_id;\n\tfcf_rec->flag |= (flag | RECORD_VALID);\n\t__lpfc_update_fcf_record_pri(phba,\n\t\tbf_get(lpfc_fcf_record_fcf_index, new_fcf_record),\n\t\t\t\t new_fcf_record);\n}\n\n \nstatic void\nlpfc_register_fcf(struct lpfc_hba *phba)\n{\n\tLPFC_MBOXQ_t *fcf_mbxq;\n\tint rc;\n\n\tspin_lock_irq(&phba->hbalock);\n\t \n\tif (!(phba->fcf.fcf_flag & FCF_AVAILABLE)) {\n\t\tphba->hba_flag &= ~(FCF_TS_INPROG | FCF_RR_INPROG);\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\treturn;\n\t}\n\n\t \n\tif (phba->fcf.fcf_flag & FCF_REGISTERED) {\n\t\tphba->fcf.fcf_flag |= (FCF_SCAN_DONE | FCF_IN_USE);\n\t\tphba->hba_flag &= ~FCF_TS_INPROG;\n\t\tif (phba->pport->port_state != LPFC_FLOGI &&\n\t\t    phba->pport->fc_flag & FC_FABRIC) {\n\t\t\tphba->hba_flag |= FCF_RR_INPROG;\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tlpfc_initial_flogi(phba->pport);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\treturn;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\tfcf_mbxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!fcf_mbxq) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->hba_flag &= ~(FCF_TS_INPROG | FCF_RR_INPROG);\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\treturn;\n\t}\n\n\tlpfc_reg_fcfi(phba, fcf_mbxq);\n\tfcf_mbxq->vport = phba->pport;\n\tfcf_mbxq->mbox_cmpl = lpfc_mbx_cmpl_reg_fcfi;\n\trc = lpfc_sli_issue_mbox(phba, fcf_mbxq, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->hba_flag &= ~(FCF_TS_INPROG | FCF_RR_INPROG);\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tmempool_free(fcf_mbxq, phba->mbox_mem_pool);\n\t}\n\n\treturn;\n}\n\n \nstatic int\nlpfc_match_fcf_conn_list(struct lpfc_hba *phba,\n\t\t\tstruct fcf_record *new_fcf_record,\n\t\t\tuint32_t *boot_flag, uint32_t *addr_mode,\n\t\t\tuint16_t *vlan_id)\n{\n\tstruct lpfc_fcf_conn_entry *conn_entry;\n\tint i, j, fcf_vlan_id = 0;\n\n\t \n\tfor (i = 0; i < 512; i++) {\n\t\tif (new_fcf_record->vlan_bitmap[i]) {\n\t\t\tfcf_vlan_id = i * 8;\n\t\t\tj = 0;\n\t\t\twhile (!((new_fcf_record->vlan_bitmap[i] >> j) & 1)) {\n\t\t\t\tj++;\n\t\t\t\tfcf_vlan_id++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!bf_get(lpfc_fcf_record_fcf_avail, new_fcf_record) ||\n\t    !bf_get(lpfc_fcf_record_fcf_valid, new_fcf_record) ||\n\t    bf_get(lpfc_fcf_record_fcf_sol, new_fcf_record))\n\t\treturn 0;\n\n\tif (!(phba->hba_flag & HBA_FIP_SUPPORT)) {\n\t\t*boot_flag = 0;\n\t\t*addr_mode = bf_get(lpfc_fcf_record_mac_addr_prov,\n\t\t\t\tnew_fcf_record);\n\t\tif (phba->valid_vlan)\n\t\t\t*vlan_id = phba->vlan_id;\n\t\telse\n\t\t\t*vlan_id = LPFC_FCOE_NULL_VID;\n\t\treturn 1;\n\t}\n\n\t \n\tif (list_empty(&phba->fcf_conn_rec_list)) {\n\t\t*boot_flag = 0;\n\t\t*addr_mode = bf_get(lpfc_fcf_record_mac_addr_prov,\n\t\t\tnew_fcf_record);\n\n\t\t \n\t\tif (*addr_mode & LPFC_FCF_FPMA)\n\t\t\t*addr_mode = LPFC_FCF_FPMA;\n\n\t\t \n\t\tif (fcf_vlan_id)\n\t\t\t*vlan_id = fcf_vlan_id;\n\t\telse\n\t\t\t*vlan_id = LPFC_FCOE_NULL_VID;\n\t\treturn 1;\n\t}\n\n\tlist_for_each_entry(conn_entry,\n\t\t\t    &phba->fcf_conn_rec_list, list) {\n\t\tif (!(conn_entry->conn_rec.flags & FCFCNCT_VALID))\n\t\t\tcontinue;\n\n\t\tif ((conn_entry->conn_rec.flags & FCFCNCT_FBNM_VALID) &&\n\t\t\t!lpfc_fab_name_match(conn_entry->conn_rec.fabric_name,\n\t\t\t\t\t     new_fcf_record))\n\t\t\tcontinue;\n\t\tif ((conn_entry->conn_rec.flags & FCFCNCT_SWNM_VALID) &&\n\t\t\t!lpfc_sw_name_match(conn_entry->conn_rec.switch_name,\n\t\t\t\t\t    new_fcf_record))\n\t\t\tcontinue;\n\t\tif (conn_entry->conn_rec.flags & FCFCNCT_VLAN_VALID) {\n\t\t\t \n\t\t\tif (!(new_fcf_record->vlan_bitmap\n\t\t\t\t[conn_entry->conn_rec.vlan_tag / 8] &\n\t\t\t\t(1 << (conn_entry->conn_rec.vlan_tag % 8))))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(bf_get(lpfc_fcf_record_mac_addr_prov, new_fcf_record)\n\t\t\t& (LPFC_FCF_FPMA | LPFC_FCF_SPMA)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((conn_entry->conn_rec.flags & FCFCNCT_AM_VALID) &&\n\t\t\t!(conn_entry->conn_rec.flags & FCFCNCT_AM_PREFERRED)) {\n\n\t\t\t \n\t\t\tif ((conn_entry->conn_rec.flags & FCFCNCT_AM_SPMA) &&\n\t\t\t\t!(bf_get(lpfc_fcf_record_mac_addr_prov,\n\t\t\t\t\tnew_fcf_record) & LPFC_FCF_SPMA))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!(conn_entry->conn_rec.flags & FCFCNCT_AM_SPMA) &&\n\t\t\t\t!(bf_get(lpfc_fcf_record_mac_addr_prov,\n\t\t\t\tnew_fcf_record) & LPFC_FCF_FPMA))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (conn_entry->conn_rec.flags & FCFCNCT_BOOT)\n\t\t\t*boot_flag = 1;\n\t\telse\n\t\t\t*boot_flag = 0;\n\n\t\t \n\t\t*addr_mode = bf_get(lpfc_fcf_record_mac_addr_prov,\n\t\t\t\tnew_fcf_record);\n\t\t \n\t\tif ((conn_entry->conn_rec.flags & FCFCNCT_AM_VALID) &&\n\t\t\t(!(conn_entry->conn_rec.flags & FCFCNCT_AM_PREFERRED)))\n\t\t\t*addr_mode = (conn_entry->conn_rec.flags &\n\t\t\t\tFCFCNCT_AM_SPMA) ?\n\t\t\t\tLPFC_FCF_SPMA : LPFC_FCF_FPMA;\n\t\t \n\t\telse if ((conn_entry->conn_rec.flags & FCFCNCT_AM_VALID) &&\n\t\t\t(conn_entry->conn_rec.flags & FCFCNCT_AM_PREFERRED) &&\n\t\t\t(conn_entry->conn_rec.flags & FCFCNCT_AM_SPMA) &&\n\t\t\t(*addr_mode & LPFC_FCF_SPMA))\n\t\t\t\t*addr_mode = LPFC_FCF_SPMA;\n\t\telse if ((conn_entry->conn_rec.flags & FCFCNCT_AM_VALID) &&\n\t\t\t(conn_entry->conn_rec.flags & FCFCNCT_AM_PREFERRED) &&\n\t\t\t!(conn_entry->conn_rec.flags & FCFCNCT_AM_SPMA) &&\n\t\t\t(*addr_mode & LPFC_FCF_FPMA))\n\t\t\t\t*addr_mode = LPFC_FCF_FPMA;\n\n\t\t \n\t\tif (conn_entry->conn_rec.flags & FCFCNCT_VLAN_VALID)\n\t\t\t*vlan_id = conn_entry->conn_rec.vlan_tag;\n\t\t \n\t\telse if (fcf_vlan_id)\n\t\t\t*vlan_id = fcf_vlan_id;\n\t\telse\n\t\t\t*vlan_id = LPFC_FCOE_NULL_VID;\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nint\nlpfc_check_pending_fcoe_event(struct lpfc_hba *phba, uint8_t unreg_fcf)\n{\n\t \n\tif ((phba->link_state  >= LPFC_LINK_UP) &&\n\t    (phba->fcoe_eventtag == phba->fcoe_eventtag_at_fcf_scan))\n\t\treturn 0;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\"2768 Pending link or FCF event during current \"\n\t\t\t\"handling of the previous event: link_state:x%x, \"\n\t\t\t\"evt_tag_at_scan:x%x, evt_tag_current:x%x\\n\",\n\t\t\tphba->link_state, phba->fcoe_eventtag_at_fcf_scan,\n\t\t\tphba->fcoe_eventtag);\n\n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag &= ~FCF_AVAILABLE;\n\tspin_unlock_irq(&phba->hbalock);\n\n\tif (phba->link_state >= LPFC_LINK_UP) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP | LOG_DISCOVERY,\n\t\t\t\t\"2780 Restart FCF table scan due to \"\n\t\t\t\t\"pending FCF event:evt_tag_at_scan:x%x, \"\n\t\t\t\t\"evt_tag_current:x%x\\n\",\n\t\t\t\tphba->fcoe_eventtag_at_fcf_scan,\n\t\t\t\tphba->fcoe_eventtag);\n\t\tlpfc_sli4_fcf_scan_read_fcf_rec(phba, LPFC_FCOE_FCF_GET_FIRST);\n\t} else {\n\t\t \n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP | LOG_DISCOVERY,\n\t\t\t\t\"2833 Stop FCF discovery process due to link \"\n\t\t\t\t\"state change (x%x)\\n\", phba->link_state);\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->hba_flag &= ~(FCF_TS_INPROG | FCF_RR_INPROG);\n\t\tphba->fcf.fcf_flag &= ~(FCF_REDISC_FOV | FCF_DISCOVERY);\n\t\tspin_unlock_irq(&phba->hbalock);\n\t}\n\n\t \n\tif (unreg_fcf) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->fcf.fcf_flag &= ~FCF_REGISTERED;\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tlpfc_sli4_unregister_fcf(phba);\n\t}\n\treturn 1;\n}\n\n \nstatic bool\nlpfc_sli4_new_fcf_random_select(struct lpfc_hba *phba, uint32_t fcf_cnt)\n{\n\tuint32_t rand_num;\n\n\t \n\trand_num = get_random_u16();\n\n\t \n\tif ((fcf_cnt * rand_num) < 0xFFFF)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic struct fcf_record *\nlpfc_sli4_fcf_rec_mbox_parse(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq,\n\t\t\t     uint16_t *next_fcf_index)\n{\n\tvoid *virt_addr;\n\tstruct lpfc_mbx_sge sge;\n\tstruct lpfc_mbx_read_fcf_tbl *read_fcf;\n\tuint32_t shdr_status, shdr_add_status, if_type;\n\tunion lpfc_sli4_cfg_shdr *shdr;\n\tstruct fcf_record *new_fcf_record;\n\n\t \n\tlpfc_sli4_mbx_sge_get(mboxq, 0, &sge);\n\tif (unlikely(!mboxq->sge_array)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2524 Failed to get the non-embedded SGE \"\n\t\t\t\t\"virtual address\\n\");\n\t\treturn NULL;\n\t}\n\tvirt_addr = mboxq->sge_array->addr[0];\n\n\tshdr = (union lpfc_sli4_cfg_shdr *)virt_addr;\n\tlpfc_sli_pcimem_bcopy(shdr, shdr,\n\t\t\t      sizeof(union lpfc_sli4_cfg_shdr));\n\tshdr_status = bf_get(lpfc_mbox_hdr_status, &shdr->response);\n\tif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\n\tshdr_add_status = bf_get(lpfc_mbox_hdr_add_status, &shdr->response);\n\tif (shdr_status || shdr_add_status) {\n\t\tif (shdr_status == STATUS_FCF_TABLE_EMPTY ||\n\t\t\t\t\tif_type == LPFC_SLI_INTF_IF_TYPE_2)\n\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"2726 READ_FCF_RECORD Indicates empty \"\n\t\t\t\t\t\"FCF table.\\n\");\n\t\telse\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"2521 READ_FCF_RECORD mailbox failed \"\n\t\t\t\t\t\"with status x%x add_status x%x, \"\n\t\t\t\t\t\"mbx\\n\", shdr_status, shdr_add_status);\n\t\treturn NULL;\n\t}\n\n\t \n\tread_fcf = (struct lpfc_mbx_read_fcf_tbl *)virt_addr;\n\tlpfc_sli_pcimem_bcopy(read_fcf, read_fcf,\n\t\t\t      sizeof(struct lpfc_mbx_read_fcf_tbl));\n\t*next_fcf_index = bf_get(lpfc_mbx_read_fcf_tbl_nxt_vindx, read_fcf);\n\tnew_fcf_record = (struct fcf_record *)(virt_addr +\n\t\t\t  sizeof(struct lpfc_mbx_read_fcf_tbl));\n\tlpfc_sli_pcimem_bcopy(new_fcf_record, new_fcf_record,\n\t\t\t\toffsetof(struct fcf_record, vlan_bitmap));\n\tnew_fcf_record->word137 = le32_to_cpu(new_fcf_record->word137);\n\tnew_fcf_record->word138 = le32_to_cpu(new_fcf_record->word138);\n\n\treturn new_fcf_record;\n}\n\n \nstatic void\nlpfc_sli4_log_fcf_record_info(struct lpfc_hba *phba,\n\t\t\t      struct fcf_record *fcf_record,\n\t\t\t      uint16_t vlan_id,\n\t\t\t      uint16_t next_fcf_index)\n{\n\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\"2764 READ_FCF_RECORD:\\n\"\n\t\t\t\"\\tFCF_Index     : x%x\\n\"\n\t\t\t\"\\tFCF_Avail     : x%x\\n\"\n\t\t\t\"\\tFCF_Valid     : x%x\\n\"\n\t\t\t\"\\tFCF_SOL       : x%x\\n\"\n\t\t\t\"\\tFIP_Priority  : x%x\\n\"\n\t\t\t\"\\tMAC_Provider  : x%x\\n\"\n\t\t\t\"\\tLowest VLANID : x%x\\n\"\n\t\t\t\"\\tFCF_MAC Addr  : x%x:%x:%x:%x:%x:%x\\n\"\n\t\t\t\"\\tFabric_Name   : x%x:%x:%x:%x:%x:%x:%x:%x\\n\"\n\t\t\t\"\\tSwitch_Name   : x%x:%x:%x:%x:%x:%x:%x:%x\\n\"\n\t\t\t\"\\tNext_FCF_Index: x%x\\n\",\n\t\t\tbf_get(lpfc_fcf_record_fcf_index, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fcf_avail, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fcf_valid, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fcf_sol, fcf_record),\n\t\t\tfcf_record->fip_priority,\n\t\t\tbf_get(lpfc_fcf_record_mac_addr_prov, fcf_record),\n\t\t\tvlan_id,\n\t\t\tbf_get(lpfc_fcf_record_mac_0, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_mac_1, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_mac_2, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_mac_3, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_mac_4, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_mac_5, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fab_name_0, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fab_name_1, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fab_name_2, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fab_name_3, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fab_name_4, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fab_name_5, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fab_name_6, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_fab_name_7, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_switch_name_0, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_switch_name_1, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_switch_name_2, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_switch_name_3, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_switch_name_4, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_switch_name_5, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_switch_name_6, fcf_record),\n\t\t\tbf_get(lpfc_fcf_record_switch_name_7, fcf_record),\n\t\t\tnext_fcf_index);\n}\n\n \nstatic bool\nlpfc_sli4_fcf_record_match(struct lpfc_hba *phba,\n\t\t\t   struct lpfc_fcf_rec *fcf_rec,\n\t\t\t   struct fcf_record *new_fcf_record,\n\t\t\t   uint16_t new_vlan_id)\n{\n\tif (new_vlan_id != LPFC_FCOE_IGNORE_VID)\n\t\tif (!lpfc_vlan_id_match(fcf_rec->vlan_id, new_vlan_id))\n\t\t\treturn false;\n\tif (!lpfc_mac_addr_match(fcf_rec->mac_addr, new_fcf_record))\n\t\treturn false;\n\tif (!lpfc_sw_name_match(fcf_rec->switch_name, new_fcf_record))\n\t\treturn false;\n\tif (!lpfc_fab_name_match(fcf_rec->fabric_name, new_fcf_record))\n\t\treturn false;\n\tif (fcf_rec->priority != new_fcf_record->fip_priority)\n\t\treturn false;\n\treturn true;\n}\n\n \nint lpfc_sli4_fcf_rr_next_proc(struct lpfc_vport *vport, uint16_t fcf_index)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tint rc;\n\n\tif (fcf_index == LPFC_FCOE_FCF_NEXT_NONE) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tif (phba->hba_flag & HBA_DEVLOSS_TMO) {\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2872 Devloss tmo with no eligible \"\n\t\t\t\t\t\"FCF, unregister in-use FCF (x%x) \"\n\t\t\t\t\t\"and rescan FCF table\\n\",\n\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t\tlpfc_unregister_fcf_rescan(phba);\n\t\t\tgoto stop_flogi_current_fcf;\n\t\t}\n\t\t \n\t\tphba->hba_flag &= ~FCF_RR_INPROG;\n\t\t \n\t\tphba->fcf.fcf_flag &= ~(FCF_AVAILABLE | FCF_SCAN_DONE);\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\"2865 No FCF available, stop roundrobin FCF \"\n\t\t\t\t\"failover and change port state:x%x/x%x\\n\",\n\t\t\t\tphba->pport->port_state, LPFC_VPORT_UNKNOWN);\n\t\tphba->pport->port_state = LPFC_VPORT_UNKNOWN;\n\n\t\tif (!phba->fcf.fcf_redisc_attempted) {\n\t\t\tlpfc_unregister_fcf(phba);\n\n\t\t\trc = lpfc_sli4_redisc_fcf_table(phba);\n\t\t\tif (!rc) {\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\t\"3195 Rediscover FCF table\\n\");\n\t\t\t\tphba->fcf.fcf_redisc_attempted = 1;\n\t\t\t\tlpfc_sli4_clear_fcf_rr_bmask(phba);\n\t\t\t} else {\n\t\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP,\n\t\t\t\t\t\t\"3196 Rediscover FCF table \"\n\t\t\t\t\t\t\"failed. Status:x%x\\n\", rc);\n\t\t\t}\n\t\t} else {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP,\n\t\t\t\t\t\"3197 Already rediscover FCF table \"\n\t\t\t\t\t\"attempted. No more retry\\n\");\n\t\t}\n\t\tgoto stop_flogi_current_fcf;\n\t} else {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP | LOG_ELS,\n\t\t\t\t\"2794 Try FLOGI roundrobin FCF failover to \"\n\t\t\t\t\"(x%x)\\n\", fcf_index);\n\t\trc = lpfc_sli4_fcf_rr_read_fcf_rec(phba, fcf_index);\n\t\tif (rc)\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP | LOG_ELS,\n\t\t\t\t\t\"2761 FLOGI roundrobin FCF failover \"\n\t\t\t\t\t\"failed (rc:x%x) to read FCF (x%x)\\n\",\n\t\t\t\t\trc, phba->fcf.current_rec.fcf_indx);\n\t\telse\n\t\t\tgoto stop_flogi_current_fcf;\n\t}\n\treturn 0;\n\nstop_flogi_current_fcf:\n\tlpfc_can_disctmo(vport);\n\treturn 1;\n}\n\n \nstatic void lpfc_sli4_fcf_pri_list_del(struct lpfc_hba *phba,\n\t\t\tuint16_t fcf_index)\n{\n\tstruct lpfc_fcf_pri *new_fcf_pri;\n\n\tnew_fcf_pri = &phba->fcf.fcf_pri[fcf_index];\n\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\"3058 deleting idx x%x pri x%x flg x%x\\n\",\n\t\tfcf_index, new_fcf_pri->fcf_rec.priority,\n\t\t new_fcf_pri->fcf_rec.flag);\n\tspin_lock_irq(&phba->hbalock);\n\tif (new_fcf_pri->fcf_rec.flag & LPFC_FCF_ON_PRI_LIST) {\n\t\tif (phba->fcf.current_rec.priority ==\n\t\t\t\tnew_fcf_pri->fcf_rec.priority)\n\t\t\tphba->fcf.eligible_fcf_cnt--;\n\t\tlist_del_init(&new_fcf_pri->list);\n\t\tnew_fcf_pri->fcf_rec.flag &= ~LPFC_FCF_ON_PRI_LIST;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n}\n\n \nvoid\nlpfc_sli4_set_fcf_flogi_fail(struct lpfc_hba *phba, uint16_t fcf_index)\n{\n\tstruct lpfc_fcf_pri *new_fcf_pri;\n\tnew_fcf_pri = &phba->fcf.fcf_pri[fcf_index];\n\tspin_lock_irq(&phba->hbalock);\n\tnew_fcf_pri->fcf_rec.flag |= LPFC_FCF_FLOGI_FAILED;\n\tspin_unlock_irq(&phba->hbalock);\n}\n\n \nstatic int lpfc_sli4_fcf_pri_list_add(struct lpfc_hba *phba,\n\tuint16_t fcf_index,\n\tstruct fcf_record *new_fcf_record)\n{\n\tuint16_t current_fcf_pri;\n\tuint16_t last_index;\n\tstruct lpfc_fcf_pri *fcf_pri;\n\tstruct lpfc_fcf_pri *next_fcf_pri;\n\tstruct lpfc_fcf_pri *new_fcf_pri;\n\tint ret;\n\n\tnew_fcf_pri = &phba->fcf.fcf_pri[fcf_index];\n\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\"3059 adding idx x%x pri x%x flg x%x\\n\",\n\t\tfcf_index, new_fcf_record->fip_priority,\n\t\t new_fcf_pri->fcf_rec.flag);\n\tspin_lock_irq(&phba->hbalock);\n\tif (new_fcf_pri->fcf_rec.flag & LPFC_FCF_ON_PRI_LIST)\n\t\tlist_del_init(&new_fcf_pri->list);\n\tnew_fcf_pri->fcf_rec.fcf_index = fcf_index;\n\tnew_fcf_pri->fcf_rec.priority = new_fcf_record->fip_priority;\n\tif (list_empty(&phba->fcf.fcf_pri_list)) {\n\t\tlist_add(&new_fcf_pri->list, &phba->fcf.fcf_pri_list);\n\t\tret = lpfc_sli4_fcf_rr_index_set(phba,\n\t\t\t\tnew_fcf_pri->fcf_rec.fcf_index);\n\t\tgoto out;\n\t}\n\n\tlast_index = find_first_bit(phba->fcf.fcf_rr_bmask,\n\t\t\t\tLPFC_SLI4_FCF_TBL_INDX_MAX);\n\tif (last_index >= LPFC_SLI4_FCF_TBL_INDX_MAX) {\n\t\tret = 0;  \n\t\tgoto out;\n\t}\n\tcurrent_fcf_pri = phba->fcf.fcf_pri[last_index].fcf_rec.priority;\n\tif (new_fcf_pri->fcf_rec.priority <=  current_fcf_pri) {\n\t\tlist_add(&new_fcf_pri->list, &phba->fcf.fcf_pri_list);\n\t\tif (new_fcf_pri->fcf_rec.priority <  current_fcf_pri) {\n\t\t\tmemset(phba->fcf.fcf_rr_bmask, 0,\n\t\t\t\tsizeof(*phba->fcf.fcf_rr_bmask));\n\t\t\t \n\t\t\tphba->fcf.eligible_fcf_cnt = 1;\n\t\t} else\n\t\t\t \n\t\t\tphba->fcf.eligible_fcf_cnt++;\n\t\tret = lpfc_sli4_fcf_rr_index_set(phba,\n\t\t\t\tnew_fcf_pri->fcf_rec.fcf_index);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(fcf_pri, next_fcf_pri,\n\t\t\t\t&phba->fcf.fcf_pri_list, list) {\n\t\tif (new_fcf_pri->fcf_rec.priority <=\n\t\t\t\tfcf_pri->fcf_rec.priority) {\n\t\t\tif (fcf_pri->list.prev == &phba->fcf.fcf_pri_list)\n\t\t\t\tlist_add(&new_fcf_pri->list,\n\t\t\t\t\t\t&phba->fcf.fcf_pri_list);\n\t\t\telse\n\t\t\t\tlist_add(&new_fcf_pri->list,\n\t\t\t\t\t &((struct lpfc_fcf_pri *)\n\t\t\t\t\tfcf_pri->list.prev)->list);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (fcf_pri->list.next == &phba->fcf.fcf_pri_list\n\t\t\t|| new_fcf_pri->fcf_rec.priority <\n\t\t\t\tnext_fcf_pri->fcf_rec.priority) {\n\t\t\tlist_add(&new_fcf_pri->list, &fcf_pri->list);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (new_fcf_pri->fcf_rec.priority > fcf_pri->fcf_rec.priority)\n\t\t\tcontinue;\n\n\t}\n\tret = 1;\nout:\n\t \n\tnew_fcf_pri->fcf_rec.flag = LPFC_FCF_ON_PRI_LIST;\n\tspin_unlock_irq(&phba->hbalock);\n\treturn ret;\n}\n\n \nvoid\nlpfc_mbx_cmpl_fcf_scan_read_fcf_rec(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct fcf_record *new_fcf_record;\n\tuint32_t boot_flag, addr_mode;\n\tuint16_t fcf_index, next_fcf_index;\n\tstruct lpfc_fcf_rec *fcf_rec = NULL;\n\tuint16_t vlan_id = LPFC_FCOE_NULL_VID;\n\tbool select_new_fcf;\n\tint rc;\n\n\t \n\tif (lpfc_check_pending_fcoe_event(phba, LPFC_SKIP_UNREG_FCF)) {\n\t\tlpfc_sli4_mbox_cmd_free(phba, mboxq);\n\t\treturn;\n\t}\n\n\t \n\tnew_fcf_record = lpfc_sli4_fcf_rec_mbox_parse(phba, mboxq,\n\t\t\t\t\t\t      &next_fcf_index);\n\tif (!new_fcf_record) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2765 Mailbox command READ_FCF_RECORD \"\n\t\t\t\t\"failed to retrieve a FCF record.\\n\");\n\t\t \n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->hba_flag &= ~FCF_TS_INPROG;\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tlpfc_sli4_mbox_cmd_free(phba, mboxq);\n\t\treturn;\n\t}\n\n\t \n\trc = lpfc_match_fcf_conn_list(phba, new_fcf_record, &boot_flag,\n\t\t\t\t      &addr_mode, &vlan_id);\n\n\t \n\tlpfc_sli4_log_fcf_record_info(phba, new_fcf_record, vlan_id,\n\t\t\t\t      next_fcf_index);\n\n\t \n\tif (!rc) {\n\t\tlpfc_sli4_fcf_pri_list_del(phba,\n\t\t\t\t\tbf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t\t       new_fcf_record));\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP,\n\t\t\t\t\"2781 FCF (x%x) failed connection \"\n\t\t\t\t\"list check: (x%x/x%x/%x)\\n\",\n\t\t\t\tbf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t       new_fcf_record),\n\t\t\t\tbf_get(lpfc_fcf_record_fcf_avail,\n\t\t\t\t       new_fcf_record),\n\t\t\t\tbf_get(lpfc_fcf_record_fcf_valid,\n\t\t\t\t       new_fcf_record),\n\t\t\t\tbf_get(lpfc_fcf_record_fcf_sol,\n\t\t\t\t       new_fcf_record));\n\t\tif ((phba->fcf.fcf_flag & FCF_IN_USE) &&\n\t\t    lpfc_sli4_fcf_record_match(phba, &phba->fcf.current_rec,\n\t\t    new_fcf_record, LPFC_FCOE_IGNORE_VID)) {\n\t\t\tif (bf_get(lpfc_fcf_record_fcf_index, new_fcf_record) !=\n\t\t\t    phba->fcf.current_rec.fcf_indx) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"2862 FCF (x%x) matches property \"\n\t\t\t\t\t\"of in-use FCF (x%x)\\n\",\n\t\t\t\t\tbf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t\t       new_fcf_record),\n\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t\t\tgoto read_next_fcf;\n\t\t\t}\n\t\t\t \n\t\t\tif (!(phba->fcf.fcf_flag & FCF_REDISC_PEND) &&\n\t\t\t    !(phba->fcf.fcf_flag & FCF_REDISC_FOV)) {\n\t\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP,\n\t\t\t\t\t\t\"2835 Invalid in-use FCF \"\n\t\t\t\t\t\t\"(x%x), enter FCF failover \"\n\t\t\t\t\t\t\"table scan.\\n\",\n\t\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\t\tphba->fcf.fcf_flag |= FCF_REDISC_FOV;\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\tlpfc_sli4_mbox_cmd_free(phba, mboxq);\n\t\t\t\tlpfc_sli4_fcf_scan_read_fcf_rec(phba,\n\t\t\t\t\t\tLPFC_FCOE_FCF_GET_FIRST);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tgoto read_next_fcf;\n\t} else {\n\t\tfcf_index = bf_get(lpfc_fcf_record_fcf_index, new_fcf_record);\n\t\trc = lpfc_sli4_fcf_pri_list_add(phba, fcf_index,\n\t\t\t\t\t\t\tnew_fcf_record);\n\t\tif (rc)\n\t\t\tgoto read_next_fcf;\n\t}\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tif (phba->fcf.fcf_flag & FCF_IN_USE) {\n\t\tif (phba->cfg_fcf_failover_policy == LPFC_FCF_FOV &&\n\t\t\tlpfc_sli4_fcf_record_match(phba, &phba->fcf.current_rec,\n\t\t    new_fcf_record, vlan_id)) {\n\t\t\tif (bf_get(lpfc_fcf_record_fcf_index, new_fcf_record) ==\n\t\t\t    phba->fcf.current_rec.fcf_indx) {\n\t\t\t\tphba->fcf.fcf_flag |= FCF_AVAILABLE;\n\t\t\t\tif (phba->fcf.fcf_flag & FCF_REDISC_PEND)\n\t\t\t\t\t \n\t\t\t\t\t__lpfc_sli4_stop_fcf_redisc_wait_timer(\n\t\t\t\t\t\t\t\t\tphba);\n\t\t\t\telse if (phba->fcf.fcf_flag & FCF_REDISC_FOV)\n\t\t\t\t\t \n\t\t\t\t\tphba->fcf.fcf_flag &= ~FCF_REDISC_FOV;\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\t\"2836 New FCF matches in-use \"\n\t\t\t\t\t\t\"FCF (x%x), port_state:x%x, \"\n\t\t\t\t\t\t\"fc_flag:x%x\\n\",\n\t\t\t\t\t\tphba->fcf.current_rec.fcf_indx,\n\t\t\t\t\t\tphba->pport->port_state,\n\t\t\t\t\t\tphba->pport->fc_flag);\n\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"2863 New FCF (x%x) matches \"\n\t\t\t\t\t\"property of in-use FCF (x%x)\\n\",\n\t\t\t\t\tbf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t\t       new_fcf_record),\n\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t}\n\t\t \n\t\tif (!(phba->fcf.fcf_flag & FCF_REDISC_FOV)) {\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tgoto read_next_fcf;\n\t\t}\n\t}\n\t \n\tif (phba->fcf.fcf_flag & FCF_REDISC_FOV)\n\t\tfcf_rec = &phba->fcf.failover_rec;\n\telse\n\t\tfcf_rec = &phba->fcf.current_rec;\n\n\tif (phba->fcf.fcf_flag & FCF_AVAILABLE) {\n\t\t \n\t\tif (boot_flag && !(fcf_rec->flag & BOOT_ENABLE)) {\n\t\t\t \n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2837 Update current FCF record \"\n\t\t\t\t\t\"(x%x) with new FCF record (x%x)\\n\",\n\t\t\t\t\tfcf_rec->fcf_indx,\n\t\t\t\t\tbf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t\tnew_fcf_record));\n\t\t\t__lpfc_update_fcf_record(phba, fcf_rec, new_fcf_record,\n\t\t\t\t\taddr_mode, vlan_id, BOOT_ENABLE);\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tgoto read_next_fcf;\n\t\t}\n\t\t \n\t\tif (!boot_flag && (fcf_rec->flag & BOOT_ENABLE)) {\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tgoto read_next_fcf;\n\t\t}\n\t\t \n\t\tif (new_fcf_record->fip_priority < fcf_rec->priority) {\n\t\t\t \n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2838 Update current FCF record \"\n\t\t\t\t\t\"(x%x) with new FCF record (x%x)\\n\",\n\t\t\t\t\tfcf_rec->fcf_indx,\n\t\t\t\t\tbf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t\t       new_fcf_record));\n\t\t\t__lpfc_update_fcf_record(phba, fcf_rec, new_fcf_record,\n\t\t\t\t\taddr_mode, vlan_id, 0);\n\t\t\t \n\t\t\tphba->fcf.eligible_fcf_cnt = 1;\n\t\t} else if (new_fcf_record->fip_priority == fcf_rec->priority) {\n\t\t\t \n\t\t\tphba->fcf.eligible_fcf_cnt++;\n\t\t\tselect_new_fcf = lpfc_sli4_new_fcf_random_select(phba,\n\t\t\t\t\t\tphba->fcf.eligible_fcf_cnt);\n\t\t\tif (select_new_fcf) {\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2839 Update current FCF record \"\n\t\t\t\t\t\"(x%x) with new FCF record (x%x)\\n\",\n\t\t\t\t\tfcf_rec->fcf_indx,\n\t\t\t\t\tbf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t\t       new_fcf_record));\n\t\t\t\t \n\t\t\t\t__lpfc_update_fcf_record(phba, fcf_rec,\n\t\t\t\t\t\t\t new_fcf_record,\n\t\t\t\t\t\t\t addr_mode, vlan_id, 0);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tgoto read_next_fcf;\n\t}\n\t \n\tif (fcf_rec) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\"2840 Update initial FCF candidate \"\n\t\t\t\t\"with FCF (x%x)\\n\",\n\t\t\t\tbf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t       new_fcf_record));\n\t\t__lpfc_update_fcf_record(phba, fcf_rec, new_fcf_record,\n\t\t\t\t\t addr_mode, vlan_id, (boot_flag ?\n\t\t\t\t\t BOOT_ENABLE : 0));\n\t\tphba->fcf.fcf_flag |= FCF_AVAILABLE;\n\t\t \n\t\tphba->fcf.eligible_fcf_cnt = 1;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\tgoto read_next_fcf;\n\nread_next_fcf:\n\tlpfc_sli4_mbox_cmd_free(phba, mboxq);\n\tif (next_fcf_index == LPFC_FCOE_FCF_NEXT_NONE || next_fcf_index == 0) {\n\t\tif (phba->fcf.fcf_flag & FCF_REDISC_FOV) {\n\t\t\t \n\n\t\t\t \n\t\t\tif (!(phba->fcf.failover_rec.flag & RECORD_VALID)) {\n\t\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP,\n\t\t\t\t\t       \"2782 No suitable FCF found: \"\n\t\t\t\t\t       \"(x%x/x%x)\\n\",\n\t\t\t\t\t       phba->fcoe_eventtag_at_fcf_scan,\n\t\t\t\t\t       bf_get(lpfc_fcf_record_fcf_index,\n\t\t\t\t\t\t      new_fcf_record));\n\t\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\t\tif (phba->hba_flag & HBA_DEVLOSS_TMO) {\n\t\t\t\t\tphba->hba_flag &= ~FCF_TS_INPROG;\n\t\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\t\t \n\t\t\t\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\t\t\t\tLOG_FIP,\n\t\t\t\t\t\t\t\"2864 On devloss tmo \"\n\t\t\t\t\t\t\t\"unreg in-use FCF and \"\n\t\t\t\t\t\t\t\"rescan FCF table\\n\");\n\t\t\t\t\tlpfc_unregister_fcf_rescan(phba);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tphba->hba_flag &= ~FCF_TS_INPROG;\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\n\t\t\t \n\t\t\tlpfc_unregister_fcf(phba);\n\n\t\t\t \n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\"2842 Replace in-use FCF (x%x) \"\n\t\t\t\t\t\"with failover FCF (x%x)\\n\",\n\t\t\t\t\tphba->fcf.current_rec.fcf_indx,\n\t\t\t\t\tphba->fcf.failover_rec.fcf_indx);\n\t\t\tmemcpy(&phba->fcf.current_rec,\n\t\t\t       &phba->fcf.failover_rec,\n\t\t\t       sizeof(struct lpfc_fcf_rec));\n\t\t\t \n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_flag &= ~FCF_REDISC_FOV;\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t \n\t\t\tlpfc_register_fcf(phba);\n\t\t} else {\n\t\t\t \n\t\t\tif ((phba->fcf.fcf_flag & FCF_REDISC_EVT) ||\n\t\t\t    (phba->fcf.fcf_flag & FCF_REDISC_PEND))\n\t\t\t\treturn;\n\n\t\t\tif (phba->cfg_fcf_failover_policy == LPFC_FCF_FOV &&\n\t\t\t\tphba->fcf.fcf_flag & FCF_IN_USE) {\n\t\t\t\t \n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\t\t\"2841 In-use FCF record (x%x) \"\n\t\t\t\t\t\t\"not reported, entering fast \"\n\t\t\t\t\t\t\"FCF failover mode scanning.\\n\",\n\t\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\t\tphba->fcf.fcf_flag |= FCF_REDISC_FOV;\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\tlpfc_sli4_fcf_scan_read_fcf_rec(phba,\n\t\t\t\t\t\tLPFC_FCOE_FCF_GET_FIRST);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tlpfc_register_fcf(phba);\n\t\t}\n\t} else\n\t\tlpfc_sli4_fcf_scan_read_fcf_rec(phba, next_fcf_index);\n\treturn;\n\nout:\n\tlpfc_sli4_mbox_cmd_free(phba, mboxq);\n\tlpfc_register_fcf(phba);\n\n\treturn;\n}\n\n \nvoid\nlpfc_mbx_cmpl_fcf_rr_read_fcf_rec(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct fcf_record *new_fcf_record;\n\tuint32_t boot_flag, addr_mode;\n\tuint16_t next_fcf_index, fcf_index;\n\tuint16_t current_fcf_index;\n\tuint16_t vlan_id = LPFC_FCOE_NULL_VID;\n\tint rc;\n\n\t \n\tif (phba->link_state < LPFC_LINK_UP) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\n\t\tphba->hba_flag &= ~FCF_RR_INPROG;\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tgoto out;\n\t}\n\n\t \n\tnew_fcf_record = lpfc_sli4_fcf_rec_mbox_parse(phba, mboxq,\n\t\t\t\t\t\t      &next_fcf_index);\n\tif (!new_fcf_record) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP,\n\t\t\t\t\"2766 Mailbox command READ_FCF_RECORD \"\n\t\t\t\t\"failed to retrieve a FCF record. \"\n\t\t\t\t\"hba_flg x%x fcf_flg x%x\\n\", phba->hba_flag,\n\t\t\t\tphba->fcf.fcf_flag);\n\t\tlpfc_unregister_fcf_rescan(phba);\n\t\tgoto out;\n\t}\n\n\t \n\trc = lpfc_match_fcf_conn_list(phba, new_fcf_record, &boot_flag,\n\t\t\t\t      &addr_mode, &vlan_id);\n\n\t \n\tlpfc_sli4_log_fcf_record_info(phba, new_fcf_record, vlan_id,\n\t\t\t\t      next_fcf_index);\n\n\tfcf_index = bf_get(lpfc_fcf_record_fcf_index, new_fcf_record);\n\tif (!rc) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\"2848 Remove ineligible FCF (x%x) from \"\n\t\t\t\t\"from roundrobin bmask\\n\", fcf_index);\n\t\t \n\t\tlpfc_sli4_fcf_rr_index_clear(phba, fcf_index);\n\t\t \n\t\tfcf_index = lpfc_sli4_fcf_rr_next_index_get(phba);\n\t\trc = lpfc_sli4_fcf_rr_next_proc(phba->pport, fcf_index);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tgoto error_out;\n\t}\n\n\tif (fcf_index == phba->fcf.current_rec.fcf_indx) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\"2760 Perform FLOGI roundrobin FCF failover: \"\n\t\t\t\t\"FCF (x%x) back to FCF (x%x)\\n\",\n\t\t\t\tphba->fcf.current_rec.fcf_indx, fcf_index);\n\t\t \n\t\tmsleep(500);\n\t\tlpfc_issue_init_vfi(phba->pport);\n\t\tgoto out;\n\t}\n\n\t \n\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\"2834 Update current FCF (x%x) with new FCF (x%x)\\n\",\n\t\t\tphba->fcf.failover_rec.fcf_indx, fcf_index);\n\tspin_lock_irq(&phba->hbalock);\n\t__lpfc_update_fcf_record(phba, &phba->fcf.failover_rec,\n\t\t\t\t new_fcf_record, addr_mode, vlan_id,\n\t\t\t\t (boot_flag ? BOOT_ENABLE : 0));\n\tspin_unlock_irq(&phba->hbalock);\n\n\tcurrent_fcf_index = phba->fcf.current_rec.fcf_indx;\n\n\t \n\tlpfc_unregister_fcf(phba);\n\n\t \n\tmemcpy(&phba->fcf.current_rec, &phba->fcf.failover_rec,\n\t       sizeof(struct lpfc_fcf_rec));\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\"2783 Perform FLOGI roundrobin FCF failover: FCF \"\n\t\t\t\"(x%x) to FCF (x%x)\\n\", current_fcf_index, fcf_index);\n\nerror_out:\n\tlpfc_register_fcf(phba);\nout:\n\tlpfc_sli4_mbox_cmd_free(phba, mboxq);\n}\n\n \nvoid\nlpfc_mbx_cmpl_read_fcf_rec(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct fcf_record *new_fcf_record;\n\tuint32_t boot_flag, addr_mode;\n\tuint16_t fcf_index, next_fcf_index;\n\tuint16_t vlan_id =  LPFC_FCOE_NULL_VID;\n\tint rc;\n\n\t \n\tif (phba->link_state < LPFC_LINK_UP)\n\t\tgoto out;\n\n\t \n\tif (!(phba->fcf.fcf_flag & FCF_DISCOVERY))\n\t\tgoto out;\n\n\t \n\tnew_fcf_record = lpfc_sli4_fcf_rec_mbox_parse(phba, mboxq,\n\t\t\t\t\t\t      &next_fcf_index);\n\tif (!new_fcf_record) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP,\n\t\t\t\t\"2767 Mailbox command READ_FCF_RECORD \"\n\t\t\t\t\"failed to retrieve a FCF record.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\trc = lpfc_match_fcf_conn_list(phba, new_fcf_record, &boot_flag,\n\t\t\t\t      &addr_mode, &vlan_id);\n\n\t \n\tlpfc_sli4_log_fcf_record_info(phba, new_fcf_record, vlan_id,\n\t\t\t\t      next_fcf_index);\n\n\tif (!rc)\n\t\tgoto out;\n\n\t \n\tfcf_index = bf_get(lpfc_fcf_record_fcf_index, new_fcf_record);\n\n\trc = lpfc_sli4_fcf_pri_list_add(phba, fcf_index, new_fcf_record);\n\nout:\n\tlpfc_sli4_mbox_cmd_free(phba, mboxq);\n}\n\n \nstatic void\nlpfc_init_vfi_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct lpfc_vport *vport = mboxq->vport;\n\n\t \n\tif (mboxq->u.mb.mbxStatus &&\n\t    (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\n\t\t\tLPFC_SLI_INTF_IF_TYPE_0) &&\n\t    mboxq->u.mb.mbxStatus != MBX_VFI_IN_USE) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2891 Init VFI mailbox failed 0x%x\\n\",\n\t\t\t\t mboxq->u.mb.mbxStatus);\n\t\tmempool_free(mboxq, phba->mbox_mem_pool);\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\treturn;\n\t}\n\n\tlpfc_initial_flogi(vport);\n\tmempool_free(mboxq, phba->mbox_mem_pool);\n\treturn;\n}\n\n \nvoid\nlpfc_issue_init_vfi(struct lpfc_vport *vport)\n{\n\tLPFC_MBOXQ_t *mboxq;\n\tint rc;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\tmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mboxq) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\tLOG_TRACE_EVENT, \"2892 Failed to allocate \"\n\t\t\t\"init_vfi mailbox\\n\");\n\t\treturn;\n\t}\n\tlpfc_init_vfi(mboxq, vport);\n\tmboxq->mbox_cmpl = lpfc_init_vfi_cmpl;\n\trc = lpfc_sli_issue_mbox(phba, mboxq, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2893 Failed to issue init_vfi mailbox\\n\");\n\t\tmempool_free(mboxq, vport->phba->mbox_mem_pool);\n\t}\n}\n\n \nvoid\nlpfc_init_vpi_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct lpfc_vport *vport = mboxq->vport;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif (mboxq->u.mb.mbxStatus) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2609 Init VPI mailbox failed 0x%x\\n\",\n\t\t\t\t mboxq->u.mb.mbxStatus);\n\t\tmempool_free(mboxq, phba->mbox_mem_pool);\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\treturn;\n\t}\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_NEEDS_INIT_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\n\t \n\tif ((phba->pport == vport) || (vport->port_state == LPFC_FDISC)) {\n\t\t\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\t\t\tif (!ndlp)\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"2731 Cannot find fabric \"\n\t\t\t\t\t\"controller node\\n\");\n\t\t\telse\n\t\t\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\t\t\tmempool_free(mboxq, phba->mbox_mem_pool);\n\t\t\treturn;\n\t}\n\n\tif (phba->link_flag & LS_NPIV_FAB_SUPPORTED)\n\t\tlpfc_initial_fdisc(vport);\n\telse {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_NO_FABRIC_SUPP);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2606 No NPIV Fabric support\\n\");\n\t}\n\tmempool_free(mboxq, phba->mbox_mem_pool);\n\treturn;\n}\n\n \nvoid\nlpfc_issue_init_vpi(struct lpfc_vport *vport)\n{\n\tLPFC_MBOXQ_t *mboxq;\n\tint rc, vpi;\n\n\tif ((vport->port_type != LPFC_PHYSICAL_PORT) && (!vport->vpi)) {\n\t\tvpi = lpfc_alloc_vpi(vport->phba);\n\t\tif (!vpi) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"3303 Failed to obtain vport vpi\\n\");\n\t\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\t\treturn;\n\t\t}\n\t\tvport->vpi = vpi;\n\t}\n\n\tmboxq = mempool_alloc(vport->phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mboxq) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\tLOG_TRACE_EVENT, \"2607 Failed to allocate \"\n\t\t\t\"init_vpi mailbox\\n\");\n\t\treturn;\n\t}\n\tlpfc_init_vpi(vport->phba, mboxq, vport->vpi);\n\tmboxq->vport = vport;\n\tmboxq->mbox_cmpl = lpfc_init_vpi_cmpl;\n\trc = lpfc_sli_issue_mbox(vport->phba, mboxq, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2608 Failed to issue init_vpi mailbox\\n\");\n\t\tmempool_free(mboxq, vport->phba->mbox_mem_pool);\n\t}\n}\n\n \nvoid\nlpfc_start_fdiscs(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tint i;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL) {\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tif (vports[i]->port_type == LPFC_PHYSICAL_PORT)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (vports[i]->vpi > phba->max_vpi) {\n\t\t\t\tlpfc_vport_set_state(vports[i],\n\t\t\t\t\t\t     FC_VPORT_FAILED);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\t\tlpfc_vport_set_state(vports[i],\n\t\t\t\t\t\t     FC_VPORT_LINKDOWN);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (vports[i]->fc_flag & FC_VPORT_NEEDS_INIT_VPI) {\n\t\t\t\tlpfc_issue_init_vpi(vports[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (phba->link_flag & LS_NPIV_FAB_SUPPORTED)\n\t\t\t\tlpfc_initial_fdisc(vports[i]);\n\t\t\telse {\n\t\t\t\tlpfc_vport_set_state(vports[i],\n\t\t\t\t\t\t     FC_VPORT_NO_FABRIC_SUPP);\n\t\t\t\tlpfc_printf_vlog(vports[i], KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\t \"0259 No NPIV \"\n\t\t\t\t\t\t \"Fabric support\\n\");\n\t\t\t}\n\t\t}\n\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\nvoid\nlpfc_mbx_cmpl_reg_vfi(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct lpfc_vport *vport = mboxq->vport;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\t \n\tif (mboxq->u.mb.mbxStatus &&\n\t    (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) !=\n\t\t\tLPFC_SLI_INTF_IF_TYPE_0) &&\n\t    mboxq->u.mb.mbxStatus != MBX_VFI_IN_USE) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2018 REG_VFI mbxStatus error x%x \"\n\t\t\t\t \"HBA state x%x\\n\",\n\t\t\t\t mboxq->u.mb.mbxStatus, vport->port_state);\n\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\t \n\t\t\tlpfc_disc_list_loopmap(vport);\n\t\t\t \n\t\t\tlpfc_disc_start(vport);\n\t\t\tgoto out_free_mem;\n\t\t}\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tgoto out_free_mem;\n\t}\n\n\t \n\tif (vport->fc_flag & FC_VFI_REGISTERED)\n\t\tif (!(phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t      vport->fc_flag & FC_PT2PT))\n\t\t\tgoto out_free_mem;\n\n\t \n\tspin_lock_irq(shost->host_lock);\n\tvport->vpi_state |= LPFC_VPI_REGISTERED;\n\tvport->fc_flag |= FC_VFI_REGISTERED;\n\tvport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;\n\tvport->fc_flag &= ~FC_VPORT_NEEDS_INIT_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\n\t \n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    (phba->link_flag & LS_LOOPBACK_MODE)) {\n\t\tphba->link_state = LPFC_HBA_READY;\n\t\tgoto out_free_mem;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_SLI,\n\t\t\t \"3313 cmpl reg vfi  port_state:%x fc_flag:%x myDid:%x \"\n\t\t\t \"alpacnt:%d LinkState:%x topology:%x\\n\",\n\t\t\t vport->port_state, vport->fc_flag, vport->fc_myDID,\n\t\t\t vport->phba->alpa_map[0],\n\t\t\t phba->link_state, phba->fc_topology);\n\n\tif (vport->port_state == LPFC_FABRIC_CFG_LINK) {\n\t\t \n\t\tif ((vport->fc_flag & FC_PT2PT) ||\n\t\t    ((phba->fc_topology == LPFC_TOPOLOGY_LOOP) &&\n\t\t    !(vport->fc_flag & FC_PUBLIC_LOOP))) {\n\n\t\t\t \n\t\t\tlpfc_disc_list_loopmap(vport);\n\t\t\t \n\t\t\tif (vport->fc_flag & FC_PT2PT)\n\t\t\t\tvport->port_state = LPFC_VPORT_READY;\n\t\t\telse\n\t\t\t\tlpfc_disc_start(vport);\n\t\t} else {\n\t\t\tlpfc_start_fdiscs(phba);\n\t\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\t\t}\n\t}\n\nout_free_mem:\n\tlpfc_mbox_rsrc_cleanup(phba, mboxq, MBOX_THD_UNLOCKED);\n}\n\nstatic void\nlpfc_mbx_cmpl_read_sparam(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_dmabuf *mp = (struct lpfc_dmabuf *)pmb->ctx_buf;\n\tstruct lpfc_vport  *vport = pmb->vport;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct serv_parm *sp = &vport->fc_sparam;\n\tuint32_t ed_tov;\n\n\t \n\tif (mb->mbxStatus) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0319 READ_SPARAM mbxStatus error x%x \"\n\t\t\t\t \"hba state x%x>\\n\",\n\t\t\t\t mb->mbxStatus, vport->port_state);\n\t\tlpfc_linkdown(phba);\n\t\tgoto out;\n\t}\n\n\tmemcpy((uint8_t *) &vport->fc_sparam, (uint8_t *) mp->virt,\n\t       sizeof (struct serv_parm));\n\n\ted_tov = be32_to_cpu(sp->cmn.e_d_tov);\n\tif (sp->cmn.edtovResolution)\t \n\t\ted_tov = (ed_tov + 999999) / 1000000;\n\n\tphba->fc_edtov = ed_tov;\n\tphba->fc_ratov = (2 * ed_tov) / 1000;\n\tif (phba->fc_ratov < FF_DEF_RATOV) {\n\t\t \n\t\tphba->fc_ratov = FF_DEF_RATOV;\n\t}\n\n\tlpfc_update_vport_wwn(vport);\n\tfc_host_port_name(shost) = wwn_to_u64(vport->fc_portname.u.wwn);\n\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\tmemcpy(&phba->wwnn, &vport->fc_nodename, sizeof(phba->wwnn));\n\t\tmemcpy(&phba->wwpn, &vport->fc_portname, sizeof(phba->wwnn));\n\t}\n\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\n\t \n\tif (phba->hba_flag & HBA_DEFER_FLOGI) {\n\t\tlpfc_initial_flogi(vport);\n\t\tphba->hba_flag &= ~HBA_DEFER_FLOGI;\n\t}\n\treturn;\n\nout:\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\tlpfc_issue_clear_la(phba, vport);\n}\n\nstatic void\nlpfc_mbx_process_link_up(struct lpfc_hba *phba, struct lpfc_mbx_read_top *la)\n{\n\tstruct lpfc_vport *vport = phba->pport;\n\tLPFC_MBOXQ_t *sparam_mbox, *cfglink_mbox = NULL;\n\tstruct Scsi_Host *shost;\n\tint i;\n\tint rc;\n\tstruct fcf_record *fcf_record;\n\tuint32_t fc_flags = 0;\n\tunsigned long iflags;\n\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\tphba->fc_linkspeed = bf_get(lpfc_mbx_read_top_link_spd, la);\n\n\tif (!(phba->hba_flag & HBA_FCOE_MODE)) {\n\t\tswitch (bf_get(lpfc_mbx_read_top_link_spd, la)) {\n\t\tcase LPFC_LINK_SPEED_1GHZ:\n\t\tcase LPFC_LINK_SPEED_2GHZ:\n\t\tcase LPFC_LINK_SPEED_4GHZ:\n\t\tcase LPFC_LINK_SPEED_8GHZ:\n\t\tcase LPFC_LINK_SPEED_10GHZ:\n\t\tcase LPFC_LINK_SPEED_16GHZ:\n\t\tcase LPFC_LINK_SPEED_32GHZ:\n\t\tcase LPFC_LINK_SPEED_64GHZ:\n\t\tcase LPFC_LINK_SPEED_128GHZ:\n\t\tcase LPFC_LINK_SPEED_256GHZ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphba->fc_linkspeed = LPFC_LINK_SPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (phba->fc_topology &&\n\t    phba->fc_topology != bf_get(lpfc_mbx_read_top_topology, la)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_SLI,\n\t\t\t\t\"3314 Toplogy changed was 0x%x is 0x%x\\n\",\n\t\t\t\tphba->fc_topology,\n\t\t\t\tbf_get(lpfc_mbx_read_top_topology, la));\n\t\tphba->fc_topology_changed = 1;\n\t}\n\n\tphba->fc_topology = bf_get(lpfc_mbx_read_top_topology, la);\n\tphba->link_flag &= ~(LS_NPIV_FAB_SUPPORTED | LS_CT_VEN_RPA);\n\n\tshost = lpfc_shost_from_vport(vport);\n\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\tphba->sli3_options &= ~LPFC_SLI3_NPIV_ENABLED;\n\n\t\t \n\t\tif (phba->cfg_enable_npiv && phba->max_vpi)\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LINK_EVENT,\n\t\t\t\t\"1309 Link Up Event npiv not supported in loop \"\n\t\t\t\t\"topology\\n\");\n\t\t\t\t \n\t\tif (bf_get(lpfc_mbx_read_top_il, la))\n\t\t\tfc_flags |= FC_LBIT;\n\n\t\tvport->fc_myDID = bf_get(lpfc_mbx_read_top_alpa_granted, la);\n\t\ti = la->lilpBde64.tus.f.bdeSize;\n\n\t\tif (i == 0) {\n\t\t\tphba->alpa_map[0] = 0;\n\t\t} else {\n\t\t\tif (vport->cfg_log_verbose & LOG_LINK_EVENT) {\n\t\t\t\tint numalpa, j, k;\n\t\t\t\tunion {\n\t\t\t\t\tuint8_t pamap[16];\n\t\t\t\t\tstruct {\n\t\t\t\t\t\tuint32_t wd1;\n\t\t\t\t\t\tuint32_t wd2;\n\t\t\t\t\t\tuint32_t wd3;\n\t\t\t\t\t\tuint32_t wd4;\n\t\t\t\t\t} pa;\n\t\t\t\t} un;\n\t\t\t\tnumalpa = phba->alpa_map[0];\n\t\t\t\tj = 0;\n\t\t\t\twhile (j < numalpa) {\n\t\t\t\t\tmemset(un.pamap, 0, 16);\n\t\t\t\t\tfor (k = 1; j < numalpa; k++) {\n\t\t\t\t\t\tun.pamap[k - 1] =\n\t\t\t\t\t\t\tphba->alpa_map[j + 1];\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tif (k == 16)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t \n\t\t\t\t\tlpfc_printf_log(phba,\n\t\t\t\t\t\t\tKERN_WARNING,\n\t\t\t\t\t\t\tLOG_LINK_EVENT,\n\t\t\t\t\t\t\t\"1304 Link Up Event \"\n\t\t\t\t\t\t\t\"ALPA map Data: x%x \"\n\t\t\t\t\t\t\t\"x%x x%x x%x\\n\",\n\t\t\t\t\t\t\tun.pa.wd1, un.pa.wd2,\n\t\t\t\t\t\t\tun.pa.wd3, un.pa.wd4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!(phba->sli3_options & LPFC_SLI3_NPIV_ENABLED)) {\n\t\t\tif (phba->max_vpi && phba->cfg_enable_npiv &&\n\t\t\t   (phba->sli_rev >= LPFC_SLI_REV3))\n\t\t\t\tphba->sli3_options |= LPFC_SLI3_NPIV_ENABLED;\n\t\t}\n\t\tvport->fc_myDID = phba->fc_pref_DID;\n\t\tfc_flags |= FC_LBIT;\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\n\tif (fc_flags) {\n\t\tspin_lock_irqsave(shost->host_lock, iflags);\n\t\tvport->fc_flag |= fc_flags;\n\t\tspin_unlock_irqrestore(shost->host_lock, iflags);\n\t}\n\n\tlpfc_linkup(phba);\n\tsparam_mbox = NULL;\n\n\tsparam_mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!sparam_mbox)\n\t\tgoto out;\n\n\trc = lpfc_read_sparam(phba, sparam_mbox, 0);\n\tif (rc) {\n\t\tmempool_free(sparam_mbox, phba->mbox_mem_pool);\n\t\tgoto out;\n\t}\n\tsparam_mbox->vport = vport;\n\tsparam_mbox->mbox_cmpl = lpfc_mbx_cmpl_read_sparam;\n\trc = lpfc_sli_issue_mbox(phba, sparam_mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_mbox_rsrc_cleanup(phba, sparam_mbox, MBOX_THD_UNLOCKED);\n\t\tgoto out;\n\t}\n\n\tif (!(phba->hba_flag & HBA_FCOE_MODE)) {\n\t\tcfglink_mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (!cfglink_mbox)\n\t\t\tgoto out;\n\t\tvport->port_state = LPFC_LOCAL_CFG_LINK;\n\t\tlpfc_config_link(phba, cfglink_mbox);\n\t\tcfglink_mbox->vport = vport;\n\t\tcfglink_mbox->mbox_cmpl = lpfc_mbx_cmpl_local_config_link;\n\t\trc = lpfc_sli_issue_mbox(phba, cfglink_mbox, MBX_NOWAIT);\n\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\tmempool_free(cfglink_mbox, phba->mbox_mem_pool);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tvport->port_state = LPFC_VPORT_UNKNOWN;\n\t\t \n\t\tif (!(phba->hba_flag & HBA_FIP_SUPPORT)) {\n\t\t\tfcf_record = kzalloc(sizeof(struct fcf_record),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(!fcf_record)) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"2554 Could not allocate memory for \"\n\t\t\t\t\t\"fcf record\\n\");\n\t\t\t\trc = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlpfc_sli4_build_dflt_fcf_record(phba, fcf_record,\n\t\t\t\t\t\tLPFC_FCOE_FCF_DEF_INDEX);\n\t\t\trc = lpfc_sli4_add_fcf_record(phba, fcf_record);\n\t\t\tif (unlikely(rc)) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"2013 Could not manually add FCF \"\n\t\t\t\t\t\"record 0, status %d\\n\", rc);\n\t\t\t\trc = -ENODEV;\n\t\t\t\tkfree(fcf_record);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tkfree(fcf_record);\n\t\t}\n\t\t \n\t\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t\tif (phba->hba_flag & FCF_TS_INPROG) {\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tphba->fcf.fcf_flag |= FCF_INIT_DISC;\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_FIP | LOG_DISCOVERY,\n\t\t\t\t\"2778 Start FCF table scan at linkup\\n\");\n\t\trc = lpfc_sli4_fcf_scan_read_fcf_rec(phba,\n\t\t\t\t\t\t     LPFC_FCOE_FCF_GET_FIRST);\n\t\tif (rc) {\n\t\t\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t\t\tphba->fcf.fcf_flag &= ~FCF_INIT_DISC;\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tlpfc_sli4_clear_fcf_rr_bmask(phba);\n\t}\n\n\t \n\tmemset(phba->os_host_name, 0, sizeof(phba->os_host_name));\n\tscnprintf(phba->os_host_name, sizeof(phba->os_host_name), \"%s\",\n\t\t  init_utsname()->nodename);\n\treturn;\nout:\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0263 Discovery Mailbox error: state: 0x%x : x%px x%px\\n\",\n\t\t\t vport->port_state, sparam_mbox, cfglink_mbox);\n\tlpfc_issue_clear_la(phba, vport);\n\treturn;\n}\n\nstatic void\nlpfc_enable_la(struct lpfc_hba *phba)\n{\n\tuint32_t control;\n\tstruct lpfc_sli *psli = &phba->sli;\n\tspin_lock_irq(&phba->hbalock);\n\tpsli->sli_flag |= LPFC_PROCESS_LA;\n\tif (phba->sli_rev <= LPFC_SLI_REV3) {\n\t\tcontrol = readl(phba->HCregaddr);\n\t\tcontrol |= HC_LAINT_ENA;\n\t\twritel(control, phba->HCregaddr);\n\t\treadl(phba->HCregaddr);  \n\t}\n\tspin_unlock_irq(&phba->hbalock);\n}\n\nstatic void\nlpfc_mbx_issue_link_down(struct lpfc_hba *phba)\n{\n\tlpfc_linkdown(phba);\n\tlpfc_enable_la(phba);\n\tlpfc_unregister_unused_fcf(phba);\n\t \n}\n\n\n \nvoid\nlpfc_mbx_cmpl_read_topology(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport *vport = pmb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_mbx_read_top *la;\n\tstruct lpfc_sli_ring *pring;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_dmabuf *mp = (struct lpfc_dmabuf *)(pmb->ctx_buf);\n\tuint8_t attn_type;\n\tunsigned long iflags;\n\n\t \n\tpring = lpfc_phba_elsring(phba);\n\tif (pring)\n\t\tpring->flag &= ~LPFC_STOP_IOCB_EVENT;\n\n\t \n\tif (mb->mbxStatus) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LINK_EVENT,\n\t\t\t\t\"1307 READ_LA mbox error x%x state x%x\\n\",\n\t\t\t\tmb->mbxStatus, vport->port_state);\n\t\tlpfc_mbx_issue_link_down(phba);\n\t\tphba->link_state = LPFC_HBA_ERROR;\n\t\tgoto lpfc_mbx_cmpl_read_topology_free_mbuf;\n\t}\n\n\tla = (struct lpfc_mbx_read_top *) &pmb->u.mb.un.varReadTop;\n\tattn_type = bf_get(lpfc_mbx_read_top_att_type, la);\n\n\tmemcpy(&phba->alpa_map[0], mp->virt, 128);\n\n\tspin_lock_irqsave(shost->host_lock, iflags);\n\tif (bf_get(lpfc_mbx_read_top_pb, la))\n\t\tvport->fc_flag |= FC_BYPASSED_MODE;\n\telse\n\t\tvport->fc_flag &= ~FC_BYPASSED_MODE;\n\tspin_unlock_irqrestore(shost->host_lock, iflags);\n\n\tif (phba->fc_eventTag <= la->eventTag) {\n\t\tphba->fc_stat.LinkMultiEvent++;\n\t\tif (attn_type == LPFC_ATT_LINK_UP)\n\t\t\tif (phba->fc_eventTag != 0)\n\t\t\t\tlpfc_linkdown(phba);\n\t}\n\n\tphba->fc_eventTag = la->eventTag;\n\tphba->link_events++;\n\tif (attn_type == LPFC_ATT_LINK_UP) {\n\t\tphba->fc_stat.LinkUp++;\n\t\tif (phba->link_flag & LS_LOOPBACK_MODE) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LINK_EVENT,\n\t\t\t\t\t\"1306 Link Up Event in loop back mode \"\n\t\t\t\t\t\"x%x received Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\tla->eventTag, phba->fc_eventTag,\n\t\t\t\t\tbf_get(lpfc_mbx_read_top_alpa_granted,\n\t\t\t\t\t       la),\n\t\t\t\t\tbf_get(lpfc_mbx_read_top_link_spd, la),\n\t\t\t\t\tphba->alpa_map[0]);\n\t\t} else {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LINK_EVENT,\n\t\t\t\t\t\"1303 Link Up Event x%x received \"\n\t\t\t\t\t\"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t\t\tla->eventTag, phba->fc_eventTag,\n\t\t\t\t\tbf_get(lpfc_mbx_read_top_alpa_granted,\n\t\t\t\t\t       la),\n\t\t\t\t\tbf_get(lpfc_mbx_read_top_link_spd, la),\n\t\t\t\t\tphba->alpa_map[0],\n\t\t\t\t\tbf_get(lpfc_mbx_read_top_fa, la));\n\t\t}\n\t\tlpfc_mbx_process_link_up(phba, la);\n\n\t\tif (phba->cmf_active_mode != LPFC_CFG_OFF)\n\t\t\tlpfc_cmf_signal_init(phba);\n\n\t\tif (phba->lmt & LMT_64Gb)\n\t\t\tlpfc_read_lds_params(phba);\n\n\t} else if (attn_type == LPFC_ATT_LINK_DOWN ||\n\t\t   attn_type == LPFC_ATT_UNEXP_WWPN) {\n\t\tphba->fc_stat.LinkDown++;\n\t\tif (phba->link_flag & LS_LOOPBACK_MODE)\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LINK_EVENT,\n\t\t\t\t\"1308 Link Down Event in loop back mode \"\n\t\t\t\t\"x%x received \"\n\t\t\t\t\"Data: x%x x%x x%x\\n\",\n\t\t\t\tla->eventTag, phba->fc_eventTag,\n\t\t\t\tphba->pport->port_state, vport->fc_flag);\n\t\telse if (attn_type == LPFC_ATT_UNEXP_WWPN)\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LINK_EVENT,\n\t\t\t\t\"1313 Link Down Unexpected FA WWPN Event x%x \"\n\t\t\t\t\"received Data: x%x x%x x%x x%x\\n\",\n\t\t\t\tla->eventTag, phba->fc_eventTag,\n\t\t\t\tphba->pport->port_state, vport->fc_flag,\n\t\t\t\tbf_get(lpfc_mbx_read_top_fa, la));\n\t\telse\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LINK_EVENT,\n\t\t\t\t\"1305 Link Down Event x%x received \"\n\t\t\t\t\"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\tla->eventTag, phba->fc_eventTag,\n\t\t\t\tphba->pport->port_state, vport->fc_flag,\n\t\t\t\tbf_get(lpfc_mbx_read_top_fa, la));\n\t\tlpfc_mbx_issue_link_down(phba);\n\t}\n\n\tif ((phba->sli_rev < LPFC_SLI_REV4) &&\n\t    bf_get(lpfc_mbx_read_top_fa, la))\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LINK_EVENT,\n\t\t\t\t\"1311 fa %d\\n\",\n\t\t\t\tbf_get(lpfc_mbx_read_top_fa, la));\n\nlpfc_mbx_cmpl_read_topology_free_mbuf:\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n}\n\n \nvoid\nlpfc_mbx_cmpl_reg_login(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport  *vport = pmb->vport;\n\tstruct lpfc_dmabuf *mp = (struct lpfc_dmabuf *)pmb->ctx_buf;\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *)pmb->ctx_ndlp;\n\n\t \n\tpmb->ctx_buf = NULL;\n\tpmb->ctx_ndlp = NULL;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_SLI | LOG_NODE | LOG_DISCOVERY,\n\t\t\t \"0002 rpi:%x DID:%x flg:%x %d x%px\\n\",\n\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t kref_read(&ndlp->kref),\n\t\t\t ndlp);\n\tif (ndlp->nlp_flag & NLP_REG_LOGIN_SEND)\n\t\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\n\tif (ndlp->nlp_flag & NLP_IGNR_REG_CMPL ||\n\t    ndlp->nlp_state != NLP_STE_REG_LOGIN_ISSUE) {\n\t\t \n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_IGNR_REG_CMPL;\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\t \n\t\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\t\tlpfc_unreg_rpi(vport, ndlp);\n\t}\n\n\t \n\tlpfc_disc_state_machine(vport, ndlp, pmb, NLP_EVT_CMPL_REG_LOGIN);\n\tpmb->ctx_buf = mp;\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\n\t \n\tlpfc_nlp_put(ndlp);\n\n\treturn;\n}\n\nstatic void\nlpfc_mbx_cmpl_unreg_vpi(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_vport *vport = pmb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\n\tswitch (mb->mbxStatus) {\n\tcase 0x0011:\n\tcase 0x0020:\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t\t \"0911 cmpl_unreg_vpi, mb status = 0x%x\\n\",\n\t\t\t\t mb->mbxStatus);\n\t\tbreak;\n\t \n\tcase 0x9700:\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"2798 Unreg_vpi failed vpi 0x%x, mb status = 0x%x\\n\",\n\t\t\tvport->vpi, mb->mbxStatus);\n\t\tif (!(phba->pport->load_flag & FC_UNLOADING))\n\t\t\tlpfc_workq_post_event(phba, NULL, NULL,\n\t\t\t\tLPFC_EVT_RESET_HBA);\n\t}\n\tspin_lock_irq(shost->host_lock);\n\tvport->vpi_state &= ~LPFC_VPI_REGISTERED;\n\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\tlpfc_cleanup_vports_rrqs(vport, NULL);\n\t \n\tif ((vport->load_flag & FC_UNLOADING) && (vport != phba->pport))\n\t\tscsi_host_put(shost);\n}\n\nint\nlpfc_mbx_unreg_vpi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tint rc;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox)\n\t\treturn 1;\n\n\tlpfc_unreg_vpi(phba, vport->vpi, mbox);\n\tmbox->vport = vport;\n\tmbox->mbox_cmpl = lpfc_mbx_cmpl_unreg_vpi;\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"1800 Could not issue unreg_vpi\\n\");\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void\nlpfc_mbx_cmpl_reg_vpi(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport *vport = pmb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tMAILBOX_t *mb = &pmb->u.mb;\n\n\tswitch (mb->mbxStatus) {\n\tcase 0x0011:\n\tcase 0x9601:\n\tcase 0x9602:\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t\t \"0912 cmpl_reg_vpi, mb status = 0x%x\\n\",\n\t\t\t\t mb->mbxStatus);\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tvport->fc_myDID = 0;\n\n\t\tif ((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) {\n\t\t\tif (phba->nvmet_support)\n\t\t\t\tlpfc_nvmet_update_targetport(phba);\n\t\t\telse\n\t\t\t\tlpfc_nvme_update_localport(vport);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->vpi_state |= LPFC_VPI_REGISTERED;\n\tvport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\tvport->num_disc_nodes = 0;\n\t \n\tif (vport->fc_npr_cnt)\n\t\tlpfc_els_disc_plogi(vport);\n\n\tif (!vport->num_disc_nodes) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tlpfc_can_disctmo(vport);\n\t}\n\tvport->port_state = LPFC_VPORT_READY;\n\nout:\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\treturn;\n}\n\n \nvoid\nlpfc_create_static_vport(struct lpfc_hba *phba)\n{\n\tLPFC_MBOXQ_t *pmb = NULL;\n\tMAILBOX_t *mb;\n\tstruct static_vport_info *vport_info;\n\tint mbx_wait_rc = 0, i;\n\tstruct fc_vport_identifiers vport_id;\n\tstruct fc_vport *new_fc_vport;\n\tstruct Scsi_Host *shost;\n\tstruct lpfc_vport *vport;\n\tuint16_t offset = 0;\n\tuint8_t *vport_buff;\n\tstruct lpfc_dmabuf *mp;\n\tuint32_t byte_count = 0;\n\n\tpmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmb) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0542 lpfc_create_static_vport failed to\"\n\t\t\t\t\" allocate mailbox memory\\n\");\n\t\treturn;\n\t}\n\tmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\n\tmb = &pmb->u.mb;\n\n\tvport_info = kzalloc(sizeof(struct static_vport_info), GFP_KERNEL);\n\tif (!vport_info) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0543 lpfc_create_static_vport failed to\"\n\t\t\t\t\" allocate vport_info\\n\");\n\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\n\tvport_buff = (uint8_t *) vport_info;\n\tdo {\n\t\t \n\t\tif (pmb->ctx_buf) {\n\t\t\tmp = (struct lpfc_dmabuf *)pmb->ctx_buf;\n\t\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\t\tkfree(mp);\n\t\t\tpmb->ctx_buf = NULL;\n\t\t}\n\t\tif (lpfc_dump_static_vport(phba, pmb, offset))\n\t\t\tgoto out;\n\n\t\tpmb->vport = phba->pport;\n\t\tmbx_wait_rc = lpfc_sli_issue_mbox_wait(phba, pmb,\n\t\t\t\t\t\t\tLPFC_MBOX_TMO);\n\n\t\tif ((mbx_wait_rc != MBX_SUCCESS) || mb->mbxStatus) {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\n\t\t\t\t\"0544 lpfc_create_static_vport failed to\"\n\t\t\t\t\" issue dump mailbox command ret 0x%x \"\n\t\t\t\t\"status 0x%x\\n\",\n\t\t\t\tmbx_wait_rc, mb->mbxStatus);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tbyte_count = pmb->u.mqe.un.mb_words[5];\n\t\t\tmp = (struct lpfc_dmabuf *)pmb->ctx_buf;\n\t\t\tif (byte_count > sizeof(struct static_vport_info) -\n\t\t\t\t\toffset)\n\t\t\t\tbyte_count = sizeof(struct static_vport_info)\n\t\t\t\t\t- offset;\n\t\t\tmemcpy(vport_buff + offset, mp->virt, byte_count);\n\t\t\toffset += byte_count;\n\t\t} else {\n\t\t\tif (mb->un.varDmp.word_cnt >\n\t\t\t\tsizeof(struct static_vport_info) - offset)\n\t\t\t\tmb->un.varDmp.word_cnt =\n\t\t\t\t\tsizeof(struct static_vport_info)\n\t\t\t\t\t\t- offset;\n\t\t\tbyte_count = mb->un.varDmp.word_cnt;\n\t\t\tlpfc_sli_pcimem_bcopy(((uint8_t *)mb) + DMP_RSP_OFFSET,\n\t\t\t\tvport_buff + offset,\n\t\t\t\tbyte_count);\n\n\t\t\toffset += byte_count;\n\t\t}\n\n\t} while (byte_count &&\n\t\toffset < sizeof(struct static_vport_info));\n\n\n\tif ((le32_to_cpu(vport_info->signature) != VPORT_INFO_SIG) ||\n\t\t((le32_to_cpu(vport_info->rev) & VPORT_INFO_REV_MASK)\n\t\t\t!= VPORT_INFO_REV)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0545 lpfc_create_static_vport bad\"\n\t\t\t\t\" information header 0x%x 0x%x\\n\",\n\t\t\t\tle32_to_cpu(vport_info->signature),\n\t\t\t\tle32_to_cpu(vport_info->rev) &\n\t\t\t\tVPORT_INFO_REV_MASK);\n\n\t\tgoto out;\n\t}\n\n\tshost = lpfc_shost_from_vport(phba->pport);\n\n\tfor (i = 0; i < MAX_STATIC_VPORT_COUNT; i++) {\n\t\tmemset(&vport_id, 0, sizeof(vport_id));\n\t\tvport_id.port_name = wwn_to_u64(vport_info->vport_list[i].wwpn);\n\t\tvport_id.node_name = wwn_to_u64(vport_info->vport_list[i].wwnn);\n\t\tif (!vport_id.port_name || !vport_id.node_name)\n\t\t\tcontinue;\n\n\t\tvport_id.roles = FC_PORT_ROLE_FCP_INITIATOR;\n\t\tvport_id.vport_type = FC_PORTTYPE_NPIV;\n\t\tvport_id.disable = false;\n\t\tnew_fc_vport = fc_vport_create(shost, 0, &vport_id);\n\n\t\tif (!new_fc_vport) {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\n\t\t\t\t\"0546 lpfc_create_static_vport failed to\"\n\t\t\t\t\" create vport\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tvport = *(struct lpfc_vport **)new_fc_vport->dd_data;\n\t\tvport->vport_flag |= STATIC_VPORT;\n\t}\n\nout:\n\tkfree(vport_info);\n\tif (mbx_wait_rc != MBX_TIMEOUT)\n\t\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n}\n\n \nvoid\nlpfc_mbx_cmpl_fabric_reg_login(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport *vport = pmb->vport;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *)pmb->ctx_ndlp;\n\tstruct Scsi_Host *shost;\n\n\tpmb->ctx_ndlp = NULL;\n\n\tif (mb->mbxStatus) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0258 Register Fabric login error: 0x%x\\n\",\n\t\t\t\t mb->mbxStatus);\n\t\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\t \n\t\t\tlpfc_disc_list_loopmap(vport);\n\n\t\t\t \n\t\t\tlpfc_disc_start(vport);\n\t\t\t \n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\treturn;\n\t\t}\n\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\t \n\t\tlpfc_nlp_put(ndlp);\n\t\treturn;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tndlp->nlp_rpi = mb->un.varWords[0];\n\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\tndlp->nlp_type |= NLP_FABRIC;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\n\tif (vport->port_state == LPFC_FABRIC_CFG_LINK) {\n\t\t \n\t\tif (!(vport->fc_flag & FC_LOGO_RCVD_DID_CHNG))\n\t\t\tlpfc_start_fdiscs(phba);\n\t\telse {\n\t\t\tshost = lpfc_shost_from_vport(vport);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag &= ~FC_LOGO_RCVD_DID_CHNG ;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t}\n\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\t}\n\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\n\t \n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n  \nint\nlpfc_issue_gidft(struct lpfc_vport *vport)\n{\n\t \n\tif ((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_FCP)) {\n\t\tif (lpfc_ns_cmd(vport, SLI_CTNS_GID_FT, 0, SLI_CTPT_FCP)) {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t \"0604 %s FC TYPE %x %s\\n\",\n\t\t\t\t\t \"Failed to issue GID_FT to \",\n\t\t\t\t\t FC_TYPE_FCP,\n\t\t\t\t\t \"Finishing discovery.\");\n\t\t\treturn 0;\n\t\t}\n\t\tvport->gidft_inp++;\n\t}\n\n\tif ((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) {\n\t\tif (lpfc_ns_cmd(vport, SLI_CTNS_GID_FT, 0, SLI_CTPT_NVME)) {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t \"0605 %s FC_TYPE %x %s %d\\n\",\n\t\t\t\t\t \"Failed to issue GID_FT to \",\n\t\t\t\t\t FC_TYPE_NVME,\n\t\t\t\t\t \"Finishing discovery: gidftinp \",\n\t\t\t\t\t vport->gidft_inp);\n\t\t\tif (vport->gidft_inp == 0)\n\t\t\t\treturn 0;\n\t\t} else\n\t\t\tvport->gidft_inp++;\n\t}\n\treturn vport->gidft_inp;\n}\n\n \nint\nlpfc_issue_gidpt(struct lpfc_vport *vport)\n{\n\t \n\tif (lpfc_ns_cmd(vport, SLI_CTNS_GID_PT, 0, GID_PT_N_PORT)) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0606 %s Port TYPE %x %s\\n\",\n\t\t\t\t \"Failed to issue GID_PT to \",\n\t\t\t\t GID_PT_N_PORT,\n\t\t\t\t \"Finishing discovery.\");\n\t\treturn 0;\n\t}\n\tvport->gidft_inp++;\n\treturn 1;\n}\n\n \nvoid\nlpfc_mbx_cmpl_ns_reg_login(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *)pmb->ctx_ndlp;\n\tstruct lpfc_vport *vport = pmb->vport;\n\tint rc;\n\n\tpmb->ctx_ndlp = NULL;\n\tvport->gidft_inp = 0;\n\n\tif (mb->mbxStatus) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0260 Register NameServer error: 0x%x\\n\",\n\t\t\t\t mb->mbxStatus);\n\nout:\n\t\t \n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\n\t\t \n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD))) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t}\n\n\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\t \n\t\t\tlpfc_disc_list_loopmap(vport);\n\n\t\t\t \n\t\t\tlpfc_disc_start(vport);\n\t\t\treturn;\n\t\t}\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\treturn;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tndlp->nlp_rpi = mb->un.varWords[0];\n\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\tndlp->nlp_type |= NLP_FABRIC;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE | LOG_DISCOVERY,\n\t\t\t \"0003 rpi:%x DID:%x flg:%x %d x%px\\n\",\n\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t kref_read(&ndlp->kref),\n\t\t\t ndlp);\n\n\tif (vport->port_state < LPFC_VPORT_READY) {\n\t\t \n\t\tlpfc_ns_cmd(vport, SLI_CTNS_RNN_ID, 0, 0);\n\t\tlpfc_ns_cmd(vport, SLI_CTNS_RSNN_NN, 0, 0);\n\t\tlpfc_ns_cmd(vport, SLI_CTNS_RSPN_ID, 0, 0);\n\t\tlpfc_ns_cmd(vport, SLI_CTNS_RFT_ID, 0, 0);\n\n\t\tif ((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_FCP))\n\t\t\tlpfc_ns_cmd(vport, SLI_CTNS_RFF_ID, 0, FC_TYPE_FCP);\n\n\t\tif ((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME))\n\t\t\tlpfc_ns_cmd(vport, SLI_CTNS_RFF_ID, 0,\n\t\t\t\t    FC_TYPE_NVME);\n\n\t\t \n\t\tlpfc_issue_els_scr(vport, 0);\n\n\t\t \n\t\tif (phba->cmf_active_mode != LPFC_CFG_OFF) {\n\t\t\tphba->cgn_reg_fpin = phba->cgn_init_reg_fpin;\n\t\t\tphba->cgn_reg_signal = phba->cgn_init_reg_signal;\n\t\t\trc = lpfc_issue_els_edc(vport, 0);\n\t\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\t\tLOG_INIT | LOG_ELS | LOG_DISCOVERY,\n\t\t\t\t\t\"4220 Issue EDC status x%x Data x%x\\n\",\n\t\t\t\t\trc, phba->cgn_init_reg_signal);\n\t\t} else if (phba->lmt & LMT_64Gb) {\n\t\t\t \n\t\t\tlpfc_issue_els_edc(vport, 0);\n\t\t} else {\n\t\t\tlpfc_issue_els_rdf(vport, 0);\n\t\t}\n\t}\n\n\tvport->fc_ns_retry = 0;\n\tif (lpfc_issue_gidft(vport) == 0)\n\t\tgoto out;\n\n\t \n\tlpfc_nlp_put(ndlp);\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\treturn;\n}\n\n \nvoid\nlpfc_mbx_cmpl_fc_reg_login(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport *vport = pmb->vport;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *)pmb->ctx_ndlp;\n\n\tpmb->ctx_ndlp = NULL;\n\tif (mb->mbxStatus) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0933 %s: Register FC login error: 0x%x\\n\",\n\t\t\t\t __func__, mb->mbxStatus);\n\t\tgoto out;\n\t}\n\n\tlpfc_check_nlp_post_devloss(vport, ndlp);\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tndlp->nlp_rpi = mb->un.varWords[0];\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"0934 %s: Complete FC x%x RegLogin rpi x%x ste x%x\\n\",\n\t\t\t __func__, ndlp->nlp_DID, ndlp->nlp_rpi,\n\t\t\t ndlp->nlp_state);\n\n\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\tndlp->nlp_type |= NLP_FABRIC;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\n out:\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\n\t \n\tlpfc_nlp_put(ndlp);\n}\n\nstatic void\nlpfc_register_remote_port(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct fc_rport  *rport;\n\tstruct lpfc_rport_data *rdata;\n\tstruct fc_rport_identifiers rport_ids;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tunsigned long flags;\n\n\tif (vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)\n\t\treturn;\n\n\t \n\trport_ids.node_name = wwn_to_u64(ndlp->nlp_nodename.u.wwn);\n\trport_ids.port_name = wwn_to_u64(ndlp->nlp_portname.u.wwn);\n\trport_ids.port_id = ndlp->nlp_DID;\n\trport_ids.roles = FC_RPORT_ROLE_UNKNOWN;\n\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_RPORT,\n\t\t\t      \"rport add:       did:x%x flg:x%x type x%x\",\n\t\t\t      ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_type);\n\n\t \n\tif (vport->load_flag & FC_UNLOADING)\n\t\treturn;\n\n\tndlp->rport = rport = fc_remote_port_add(shost, 0, &rport_ids);\n\tif (!rport) {\n\t\tdev_printk(KERN_WARNING, &phba->pcidev->dev,\n\t\t\t   \"Warning: fc_remote_port_add failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\trport->maxframe_size = ndlp->nlp_maxframe;\n\trport->supported_classes = ndlp->nlp_class_sup;\n\trdata = rport->dd_data;\n\trdata->pnode = lpfc_nlp_get(ndlp);\n\tif (!rdata->pnode) {\n\t\tdev_warn(&phba->pcidev->dev,\n\t\t\t \"Warning - node ref failed. Unreg rport\\n\");\n\t\tfc_remote_port_delete(rport);\n\t\tndlp->rport = NULL;\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ndlp->lock, flags);\n\tndlp->fc4_xpt_flags |= SCSI_XPT_REGD;\n\tspin_unlock_irqrestore(&ndlp->lock, flags);\n\n\tif (ndlp->nlp_type & NLP_FCP_TARGET)\n\t\trport_ids.roles |= FC_PORT_ROLE_FCP_TARGET;\n\tif (ndlp->nlp_type & NLP_FCP_INITIATOR)\n\t\trport_ids.roles |= FC_PORT_ROLE_FCP_INITIATOR;\n\tif (ndlp->nlp_type & NLP_NVME_INITIATOR)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_INITIATOR;\n\tif (ndlp->nlp_type & NLP_NVME_TARGET)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_TARGET;\n\tif (ndlp->nlp_type & NLP_NVME_DISCOVERY)\n\t\trport_ids.roles |= FC_PORT_ROLE_NVME_DISCOVERY;\n\n\tif (rport_ids.roles !=  FC_RPORT_ROLE_UNKNOWN)\n\t\tfc_remote_port_rolechg(rport, rport_ids.roles);\n\n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NODE,\n\t\t\t \"3183 %s rport x%px DID x%x, role x%x refcnt %d\\n\",\n\t\t\t __func__, rport, rport->port_id, rport->roles,\n\t\t\t kref_read(&ndlp->kref));\n\n\tif ((rport->scsi_target_id != -1) &&\n\t    (rport->scsi_target_id < LPFC_MAX_TARGET)) {\n\t\tndlp->nlp_sid = rport->scsi_target_id;\n\t}\n\n\treturn;\n}\n\nstatic void\nlpfc_unregister_remote_port(struct lpfc_nodelist *ndlp)\n{\n\tstruct fc_rport *rport = ndlp->rport;\n\tstruct lpfc_vport *vport = ndlp->vport;\n\n\tif (vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)\n\t\treturn;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_RPORT,\n\t\t\"rport delete:    did:x%x flg:x%x type x%x\",\n\t\tndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_type);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"3184 rport unregister x%06x, rport x%px \"\n\t\t\t \"xptflg x%x refcnt %d\\n\",\n\t\t\t ndlp->nlp_DID, rport, ndlp->fc4_xpt_flags,\n\t\t\t kref_read(&ndlp->kref));\n\n\tfc_remote_port_delete(rport);\n\tlpfc_nlp_put(ndlp);\n}\n\nstatic void\nlpfc_nlp_counters(struct lpfc_vport *vport, int state, int count)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tunsigned long iflags;\n\n\tspin_lock_irqsave(shost->host_lock, iflags);\n\tswitch (state) {\n\tcase NLP_STE_UNUSED_NODE:\n\t\tvport->fc_unused_cnt += count;\n\t\tbreak;\n\tcase NLP_STE_PLOGI_ISSUE:\n\t\tvport->fc_plogi_cnt += count;\n\t\tbreak;\n\tcase NLP_STE_ADISC_ISSUE:\n\t\tvport->fc_adisc_cnt += count;\n\t\tbreak;\n\tcase NLP_STE_REG_LOGIN_ISSUE:\n\t\tvport->fc_reglogin_cnt += count;\n\t\tbreak;\n\tcase NLP_STE_PRLI_ISSUE:\n\t\tvport->fc_prli_cnt += count;\n\t\tbreak;\n\tcase NLP_STE_UNMAPPED_NODE:\n\t\tvport->fc_unmap_cnt += count;\n\t\tbreak;\n\tcase NLP_STE_MAPPED_NODE:\n\t\tvport->fc_map_cnt += count;\n\t\tbreak;\n\tcase NLP_STE_NPR_NODE:\n\t\tif (vport->fc_npr_cnt == 0 && count == -1)\n\t\t\tvport->fc_npr_cnt = 0;\n\t\telse\n\t\t\tvport->fc_npr_cnt += count;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, iflags);\n}\n\n \nvoid\nlpfc_nlp_reg_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tunsigned long iflags;\n\n\tlpfc_check_nlp_post_devloss(vport, ndlp);\n\n\tspin_lock_irqsave(&ndlp->lock, iflags);\n\tif (ndlp->fc4_xpt_flags & NLP_XPT_REGD) {\n\t\t \n\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\n\t\tif (ndlp->fc4_xpt_flags & NVME_XPT_REGD &&\n\t\t    ndlp->nlp_type & (NLP_NVME_TARGET | NLP_NVME_DISCOVERY)) {\n\t\t\tlpfc_nvme_rescan_port(vport, ndlp);\n\t\t}\n\t\treturn;\n\t}\n\n\tndlp->fc4_xpt_flags |= NLP_XPT_REGD;\n\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\n\tif (lpfc_valid_xpt_node(ndlp)) {\n\t\tvport->phba->nport_event_cnt++;\n\t\t \n\t\tlpfc_register_remote_port(vport, ndlp);\n\t}\n\n\t \n\tif (!(ndlp->nlp_fc4_type & NLP_FC4_NVME))\n\t\treturn;\n\n\t \n\tif (vport->phba->sli_rev >= LPFC_SLI_REV4 &&\n\t\t\tndlp->nlp_fc4_type & NLP_FC4_NVME) {\n\t\tif (vport->phba->nvmet_support == 0) {\n\t\t\t \n\t\t\tif (ndlp->nlp_type & NLP_NVME_TARGET) {\n\t\t\t\tvport->phba->nport_event_cnt++;\n\t\t\t\tlpfc_nvme_register_port(vport, ndlp);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tlpfc_nlp_get(ndlp);\n\t\t}\n\t}\n}\n\n \nvoid\nlpfc_nlp_unreg_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tunsigned long iflags;\n\n\tspin_lock_irqsave(&ndlp->lock, iflags);\n\tif (!(ndlp->fc4_xpt_flags & NLP_XPT_REGD)) {\n\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t LOG_ELS | LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t \"0999 %s Not regd: ndlp x%px rport x%px DID \"\n\t\t\t\t \"x%x FLG x%x XPT x%x\\n\",\n\t\t\t\t  __func__, ndlp, ndlp->rport, ndlp->nlp_DID,\n\t\t\t\t  ndlp->nlp_flag, ndlp->fc4_xpt_flags);\n\t\treturn;\n\t}\n\n\tndlp->fc4_xpt_flags &= ~NLP_XPT_REGD;\n\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\n\tif (ndlp->rport &&\n\t    ndlp->fc4_xpt_flags & SCSI_XPT_REGD) {\n\t\tvport->phba->nport_event_cnt++;\n\t\tlpfc_unregister_remote_port(ndlp);\n\t} else if (!ndlp->rport) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t LOG_ELS | LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t \"1999 %s NDLP in devloss x%px DID x%x FLG x%x\"\n\t\t\t\t \" XPT x%x refcnt %u\\n\",\n\t\t\t\t __func__, ndlp, ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t ndlp->fc4_xpt_flags,\n\t\t\t\t kref_read(&ndlp->kref));\n\t}\n\n\tif (ndlp->fc4_xpt_flags & NVME_XPT_REGD) {\n\t\tvport->phba->nport_event_cnt++;\n\t\tif (vport->phba->nvmet_support == 0) {\n\t\t\t \n\t\t\tif (ndlp->nlp_type & NLP_NVME_TARGET)\n\t\t\t\tlpfc_nvme_unregister_port(vport, ndlp);\n\t\t} else {\n\t\t\t \n\t\t\tlpfc_nlp_put(ndlp);\n\t\t}\n\t}\n\n}\n\n \nstatic void\nlpfc_handle_adisc_state(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\tint new_state)\n{\n\tswitch (new_state) {\n\t \n\tcase NLP_STE_ADISC_ISSUE:\n\t\tbreak;\n\n\t \n\tcase NLP_STE_UNMAPPED_NODE:\n\t\tndlp->nlp_type |= NLP_FC_NODE;\n\t\tfallthrough;\n\tcase NLP_STE_MAPPED_NODE:\n\t\tndlp->nlp_flag &= ~NLP_NODEV_REMOVE;\n\t\tlpfc_nlp_reg_node(vport, ndlp);\n\t\tbreak;\n\n\t \n\tcase NLP_STE_NPR_NODE:\n\t\tndlp->nlp_flag &= ~NLP_RCV_PLOGI;\n\t\tfallthrough;\n\tdefault:\n\t\tlpfc_nlp_unreg_node(vport, ndlp);\n\t\tbreak;\n\t}\n\n}\n\nstatic void\nlpfc_nlp_state_cleanup(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t       int old_state, int new_state)\n{\n\t \n\tif (new_state == NLP_STE_ADISC_ISSUE ||\n\t    old_state == NLP_STE_ADISC_ISSUE) {\n\t\tlpfc_handle_adisc_state(vport, ndlp, new_state);\n\t\treturn;\n\t}\n\n\tif (new_state == NLP_STE_UNMAPPED_NODE) {\n\t\tndlp->nlp_flag &= ~NLP_NODEV_REMOVE;\n\t\tndlp->nlp_type |= NLP_FC_NODE;\n\t}\n\tif (new_state == NLP_STE_MAPPED_NODE)\n\t\tndlp->nlp_flag &= ~NLP_NODEV_REMOVE;\n\tif (new_state == NLP_STE_NPR_NODE)\n\t\tndlp->nlp_flag &= ~NLP_RCV_PLOGI;\n\n\t \n\tif ((old_state == NLP_STE_MAPPED_NODE ||\n\t     old_state == NLP_STE_UNMAPPED_NODE)) {\n\t\t \n\t\tif (!(ndlp->nlp_flag & NLP_NPR_ADISC) ||\n\t\t    !lpfc_is_link_up(vport->phba))\n\t\t\tlpfc_nlp_unreg_node(vport, ndlp);\n\t}\n\n\tif (new_state ==  NLP_STE_MAPPED_NODE ||\n\t    new_state == NLP_STE_UNMAPPED_NODE)\n\t\tlpfc_nlp_reg_node(vport, ndlp);\n\n\t \n\tif ((new_state == NLP_STE_MAPPED_NODE) &&\n\t    (ndlp->nlp_type & NLP_FCP_TARGET) &&\n\t    (!ndlp->rport ||\n\t     ndlp->rport->scsi_target_id == -1 ||\n\t     ndlp->rport->scsi_target_id >= LPFC_MAX_TARGET)) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_TGT_NO_SCSIID;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t}\n}\n\nstatic char *\nlpfc_nlp_state_name(char *buffer, size_t size, int state)\n{\n\tstatic char *states[] = {\n\t\t[NLP_STE_UNUSED_NODE] = \"UNUSED\",\n\t\t[NLP_STE_PLOGI_ISSUE] = \"PLOGI\",\n\t\t[NLP_STE_ADISC_ISSUE] = \"ADISC\",\n\t\t[NLP_STE_REG_LOGIN_ISSUE] = \"REGLOGIN\",\n\t\t[NLP_STE_PRLI_ISSUE] = \"PRLI\",\n\t\t[NLP_STE_LOGO_ISSUE] = \"LOGO\",\n\t\t[NLP_STE_UNMAPPED_NODE] = \"UNMAPPED\",\n\t\t[NLP_STE_MAPPED_NODE] = \"MAPPED\",\n\t\t[NLP_STE_NPR_NODE] = \"NPR\",\n\t};\n\n\tif (state < NLP_STE_MAX_STATE && states[state])\n\t\tstrscpy(buffer, states[state], size);\n\telse\n\t\tsnprintf(buffer, size, \"unknown (%d)\", state);\n\treturn buffer;\n}\n\nvoid\nlpfc_nlp_set_state(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t   int state)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tint  old_state = ndlp->nlp_state;\n\tint node_dropped = ndlp->nlp_flag & NLP_DROPPED;\n\tchar name1[16], name2[16];\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"0904 NPort state transition x%06x, %s -> %s\\n\",\n\t\t\t ndlp->nlp_DID,\n\t\t\t lpfc_nlp_state_name(name1, sizeof(name1), old_state),\n\t\t\t lpfc_nlp_state_name(name2, sizeof(name2), state));\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_NODE,\n\t\t\"node statechg    did:x%x old:%d ste:%d\",\n\t\tndlp->nlp_DID, old_state, state);\n\n\tif (node_dropped && old_state == NLP_STE_UNUSED_NODE &&\n\t    state != NLP_STE_UNUSED_NODE) {\n\t\tndlp->nlp_flag &= ~NLP_DROPPED;\n\t\tlpfc_nlp_get(ndlp);\n\t}\n\n\tif (old_state == NLP_STE_NPR_NODE &&\n\t    state != NLP_STE_NPR_NODE)\n\t\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\tif (old_state == NLP_STE_UNMAPPED_NODE) {\n\t\tndlp->nlp_flag &= ~NLP_TGT_NO_SCSIID;\n\t\tndlp->nlp_type &= ~NLP_FC_NODE;\n\t}\n\n\tif (list_empty(&ndlp->nlp_listp)) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tlist_add_tail(&ndlp->nlp_listp, &vport->fc_nodes);\n\t\tspin_unlock_irq(shost->host_lock);\n\t} else if (old_state)\n\t\tlpfc_nlp_counters(vport, old_state, -1);\n\n\tndlp->nlp_state = state;\n\tlpfc_nlp_counters(vport, state, 1);\n\tlpfc_nlp_state_cleanup(vport, ndlp, old_state, state);\n}\n\nvoid\nlpfc_enqueue_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif (list_empty(&ndlp->nlp_listp)) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tlist_add_tail(&ndlp->nlp_listp, &vport->fc_nodes);\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n}\n\nvoid\nlpfc_dequeue_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\tif (ndlp->nlp_state && !list_empty(&ndlp->nlp_listp))\n\t\tlpfc_nlp_counters(vport, ndlp->nlp_state, -1);\n\tspin_lock_irq(shost->host_lock);\n\tlist_del_init(&ndlp->nlp_listp);\n\tspin_unlock_irq(shost->host_lock);\n\tlpfc_nlp_state_cleanup(vport, ndlp, ndlp->nlp_state,\n\t\t\t\tNLP_STE_UNUSED_NODE);\n}\n\n \nstatic inline void\nlpfc_initialize_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\tuint32_t did)\n{\n\tINIT_LIST_HEAD(&ndlp->els_retry_evt.evt_listp);\n\tINIT_LIST_HEAD(&ndlp->dev_loss_evt.evt_listp);\n\ttimer_setup(&ndlp->nlp_delayfunc, lpfc_els_retry_delay, 0);\n\tINIT_LIST_HEAD(&ndlp->recovery_evt.evt_listp);\n\n\tndlp->nlp_DID = did;\n\tndlp->vport = vport;\n\tndlp->phba = vport->phba;\n\tndlp->nlp_sid = NLP_NO_SID;\n\tndlp->nlp_fc4_type = NLP_FC4_NONE;\n\tkref_init(&ndlp->kref);\n\tatomic_set(&ndlp->cmd_pending, 0);\n\tndlp->cmd_qdepth = vport->cfg_tgt_queue_depth;\n\tndlp->nlp_defer_did = NLP_EVT_NOTHING_PENDING;\n}\n\nvoid\nlpfc_drop_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\t \n\tif (ndlp->nlp_state == NLP_STE_UNUSED_NODE)\n\t\treturn;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNUSED_NODE);\n\tif (vport->phba->sli_rev == LPFC_SLI_REV4) {\n\t\tlpfc_cleanup_vports_rrqs(vport, ndlp);\n\t\tlpfc_unreg_rpi(vport, ndlp);\n\t}\n\n\t \n\tspin_lock_irq(&ndlp->lock);\n\tif (!(ndlp->nlp_flag & NLP_DROPPED)) {\n\t\tndlp->nlp_flag |= NLP_DROPPED;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn;\n\t}\n\tspin_unlock_irq(&ndlp->lock);\n}\n\n \nvoid\nlpfc_set_disctmo(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tuint32_t tmo;\n\n\tif (vport->port_state == LPFC_LOCAL_CFG_LINK) {\n\t\t \n\t\ttmo = (((phba->fc_edtov + 999) / 1000) + 1);\n\t} else {\n\t\t \n\t\ttmo = ((phba->fc_ratov * 3) + 3);\n\t}\n\n\n\tif (!timer_pending(&vport->fc_disctmo)) {\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t\"set disc timer:  tmo:x%x state:x%x flg:x%x\",\n\t\t\ttmo, vport->port_state, vport->fc_flag);\n\t}\n\n\tmod_timer(&vport->fc_disctmo, jiffies + msecs_to_jiffies(1000 * tmo));\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag |= FC_DISC_TMO;\n\tspin_unlock_irq(shost->host_lock);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0247 Start Discovery Timer state x%x \"\n\t\t\t \"Data: x%x x%lx x%x x%x\\n\",\n\t\t\t vport->port_state, tmo,\n\t\t\t (unsigned long)&vport->fc_disctmo, vport->fc_plogi_cnt,\n\t\t\t vport->fc_adisc_cnt);\n\n\treturn;\n}\n\n \nint\nlpfc_can_disctmo(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tunsigned long iflags;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"can disc timer:  state:x%x rtry:x%x flg:x%x\",\n\t\tvport->port_state, vport->fc_ns_retry, vport->fc_flag);\n\n\t \n\tif (vport->fc_flag & FC_DISC_TMO ||\n\t    timer_pending(&vport->fc_disctmo)) {\n\t\tspin_lock_irqsave(shost->host_lock, iflags);\n\t\tvport->fc_flag &= ~FC_DISC_TMO;\n\t\tspin_unlock_irqrestore(shost->host_lock, iflags);\n\t\tdel_timer_sync(&vport->fc_disctmo);\n\t\tspin_lock_irqsave(&vport->work_port_lock, iflags);\n\t\tvport->work_port_events &= ~WORKER_DISC_TMO;\n\t\tspin_unlock_irqrestore(&vport->work_port_lock, iflags);\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0248 Cancel Discovery Timer state x%x \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t vport->port_state, vport->fc_flag,\n\t\t\t vport->fc_plogi_cnt, vport->fc_adisc_cnt);\n\treturn 0;\n}\n\n \nint\nlpfc_check_sli_ndlp(struct lpfc_hba *phba,\n\t\t    struct lpfc_sli_ring *pring,\n\t\t    struct lpfc_iocbq *iocb,\n\t\t    struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tu8 ulp_command;\n\tu16 ulp_context;\n\tu32 remote_id;\n\n\tif (iocb->vport != vport)\n\t\treturn 0;\n\n\tulp_command = get_job_cmnd(phba, iocb);\n\tulp_context = get_job_ulpcontext(phba, iocb);\n\tremote_id = get_job_els_rsp64_did(phba, iocb);\n\n\tif (pring->ringno == LPFC_ELS_RING) {\n\t\tswitch (ulp_command) {\n\t\tcase CMD_GEN_REQUEST64_CR:\n\t\t\tif (iocb->ndlp == ndlp)\n\t\t\t\treturn 1;\n\t\t\tfallthrough;\n\t\tcase CMD_ELS_REQUEST64_CR:\n\t\t\tif (remote_id == ndlp->nlp_DID)\n\t\t\t\treturn 1;\n\t\t\tfallthrough;\n\t\tcase CMD_XMIT_ELS_RSP64_CX:\n\t\t\tif (iocb->ndlp == ndlp)\n\t\t\t\treturn 1;\n\t\t}\n\t} else if (pring->ringno == LPFC_FCP_RING) {\n\t\t \n\t\tif ((ndlp->nlp_type & NLP_FCP_TARGET) &&\n\t\t    (ndlp->nlp_flag & NLP_DELAY_TMO)) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (ulp_context == ndlp->nlp_rpi)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic void\n__lpfc_dequeue_nport_iocbs(struct lpfc_hba *phba,\n\t\tstruct lpfc_nodelist *ndlp, struct lpfc_sli_ring *pring,\n\t\tstruct list_head *dequeue_list)\n{\n\tstruct lpfc_iocbq *iocb, *next_iocb;\n\n\tlist_for_each_entry_safe(iocb, next_iocb, &pring->txq, list) {\n\t\t \n\t\tif (lpfc_check_sli_ndlp(phba, pring, iocb, ndlp))\n\t\t\t \n\t\t\tlist_move_tail(&iocb->list, dequeue_list);\n\t}\n}\n\nstatic void\nlpfc_sli3_dequeue_nport_iocbs(struct lpfc_hba *phba,\n\t\tstruct lpfc_nodelist *ndlp, struct list_head *dequeue_list)\n{\n\tstruct lpfc_sli *psli = &phba->sli;\n\tuint32_t i;\n\n\tspin_lock_irq(&phba->hbalock);\n\tfor (i = 0; i < psli->num_rings; i++)\n\t\t__lpfc_dequeue_nport_iocbs(phba, ndlp, &psli->sli3_ring[i],\n\t\t\t\t\t\tdequeue_list);\n\tspin_unlock_irq(&phba->hbalock);\n}\n\nstatic void\nlpfc_sli4_dequeue_nport_iocbs(struct lpfc_hba *phba,\n\t\tstruct lpfc_nodelist *ndlp, struct list_head *dequeue_list)\n{\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_queue *qp = NULL;\n\n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry(qp, &phba->sli4_hba.lpfc_wq_list, wq_list) {\n\t\tpring = qp->pring;\n\t\tif (!pring)\n\t\t\tcontinue;\n\t\tspin_lock(&pring->ring_lock);\n\t\t__lpfc_dequeue_nport_iocbs(phba, ndlp, pring, dequeue_list);\n\t\tspin_unlock(&pring->ring_lock);\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n}\n\n \nstatic int\nlpfc_no_rpi(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp)\n{\n\tLIST_HEAD(completions);\n\n\tlpfc_fabric_abort_nport(ndlp);\n\n\t \n\tif (ndlp->nlp_flag & NLP_RPI_REGISTERED) {\n\t\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\t\tlpfc_sli3_dequeue_nport_iocbs(phba, ndlp, &completions);\n\t\telse\n\t\t\tlpfc_sli4_dequeue_nport_iocbs(phba, ndlp, &completions);\n\t}\n\n\t \n\tlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\n\t\t\t      IOERR_SLI_ABORTED);\n\n\treturn 0;\n}\n\n \nstatic void\nlpfc_nlp_logo_unreg(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport  *vport = pmb->vport;\n\tstruct lpfc_nodelist *ndlp;\n\n\tndlp = (struct lpfc_nodelist *)(pmb->ctx_ndlp);\n\tif (!ndlp)\n\t\treturn;\n\tlpfc_issue_els_logo(vport, ndlp, 0);\n\n\t \n\tif ((ndlp->nlp_flag & NLP_UNREG_INP) &&\n\t    (ndlp->nlp_defer_did != NLP_EVT_NOTHING_PENDING)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"1434 UNREG cmpl deferred logo x%x \"\n\t\t\t\t \"on NPort x%x Data: x%x x%px\\n\",\n\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID,\n\t\t\t\t ndlp->nlp_defer_did, ndlp);\n\n\t\tndlp->nlp_flag &= ~NLP_UNREG_INP;\n\t\tndlp->nlp_defer_did = NLP_EVT_NOTHING_PENDING;\n\t\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\t} else {\n\t\t \n\t\tif (ndlp->nlp_flag & NLP_RELEASE_RPI) {\n\t\t\tlpfc_sli4_free_rpi(vport->phba, ndlp->nlp_rpi);\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_RELEASE_RPI;\n\t\t\tndlp->nlp_rpi = LPFC_RPI_ALLOC_ERROR;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t}\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_UNREG_INP;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t}\n\n\t \n\tlpfc_nlp_put(ndlp);\n\tmempool_free(pmb, phba->mbox_mem_pool);\n}\n\n \nstatic void\nlpfc_set_unreg_login_mbx_cmpl(struct lpfc_hba *phba, struct lpfc_vport *vport,\n\tstruct lpfc_nodelist *ndlp, LPFC_MBOXQ_t *mbox)\n{\n\tunsigned long iflags;\n\n\t \n\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\tif (!mbox->ctx_ndlp)\n\t\treturn;\n\n\tif (ndlp->nlp_flag & NLP_ISSUE_LOGO) {\n\t\tmbox->mbox_cmpl = lpfc_nlp_logo_unreg;\n\n\t} else if (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t   (!(vport->load_flag & FC_UNLOADING)) &&\n\t\t    (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) >=\n\t\t\t\t      LPFC_SLI_INTF_IF_TYPE_2) &&\n\t\t    (kref_read(&ndlp->kref) > 0)) {\n\t\tmbox->mbox_cmpl = lpfc_sli4_unreg_rpi_cmpl_clr;\n\t} else {\n\t\tif (vport->load_flag & FC_UNLOADING) {\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\t\tspin_lock_irqsave(&ndlp->lock, iflags);\n\t\t\t\tndlp->nlp_flag |= NLP_RELEASE_RPI;\n\t\t\t\tspin_unlock_irqrestore(&ndlp->lock, iflags);\n\t\t\t}\n\t\t}\n\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t}\n}\n\n \nint\nlpfc_unreg_rpi(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tLPFC_MBOXQ_t    *mbox;\n\tint rc, acc_plogi = 1;\n\tuint16_t rpi;\n\n\tif (ndlp->nlp_flag & NLP_RPI_REGISTERED ||\n\t    ndlp->nlp_flag & NLP_REG_LOGIN_SEND) {\n\t\tif (ndlp->nlp_flag & NLP_REG_LOGIN_SEND)\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t\t \"3366 RPI x%x needs to be \"\n\t\t\t\t\t \"unregistered nlp_flag x%x \"\n\t\t\t\t\t \"did x%x\\n\",\n\t\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_flag,\n\t\t\t\t\t ndlp->nlp_DID);\n\n\t\t \n\t\tif (ndlp->nlp_flag & NLP_UNREG_INP) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t\t \"1436 unreg_rpi SKIP UNREG x%x on \"\n\t\t\t\t\t \"NPort x%x deferred x%x  flg x%x \"\n\t\t\t\t\t \"Data: x%px\\n\",\n\t\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID,\n\t\t\t\t\t ndlp->nlp_defer_did,\n\t\t\t\t\t ndlp->nlp_flag, ndlp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (mbox) {\n\t\t\t \n\t\t\trpi = ndlp->nlp_rpi;\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\trpi = phba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\n\n\t\t\tlpfc_unreg_login(phba, vport->vpi, rpi, mbox);\n\t\t\tmbox->vport = vport;\n\t\t\tlpfc_set_unreg_login_mbx_cmpl(phba, vport, ndlp, mbox);\n\t\t\tif (!mbox->ctx_ndlp) {\n\t\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (mbox->mbox_cmpl == lpfc_sli4_unreg_rpi_cmpl_clr)\n\t\t\t\t \n\t\t\t\tacc_plogi = 0;\n\t\t\tif (((ndlp->nlp_DID & Fabric_DID_MASK) !=\n\t\t\t    Fabric_DID_MASK) &&\n\t\t\t    (!(vport->fc_flag & FC_OFFLINE_MODE)))\n\t\t\t\tndlp->nlp_flag |= NLP_UNREG_INP;\n\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t\t \"1433 unreg_rpi UNREG x%x on \"\n\t\t\t\t\t \"NPort x%x deferred flg x%x \"\n\t\t\t\t\t \"Data:x%px\\n\",\n\t\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID,\n\t\t\t\t\t ndlp->nlp_flag, ndlp);\n\n\t\t\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\t\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\t\tndlp->nlp_flag &= ~NLP_UNREG_INP;\n\t\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\t\tacc_plogi = 1;\n\t\t\t\tlpfc_nlp_put(ndlp);\n\t\t\t}\n\t\t} else {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t\t \"1444 Failed to allocate mempool \"\n\t\t\t\t\t \"unreg_rpi UNREG x%x, \"\n\t\t\t\t\t \"DID x%x, flag x%x, \"\n\t\t\t\t\t \"ndlp x%px\\n\",\n\t\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID,\n\t\t\t\t\t ndlp->nlp_flag, ndlp);\n\n\t\t\t \n\t\t\tif (!(vport->load_flag & FC_UNLOADING)) {\n\t\t\t\tndlp->nlp_flag &= ~NLP_UNREG_INP;\n\t\t\t\tlpfc_issue_els_logo(vport, ndlp, 0);\n\t\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t   NLP_STE_NPR_NODE);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t\tlpfc_no_rpi(phba, ndlp);\nout:\n\t\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\t\tndlp->nlp_rpi = 0;\n\t\tndlp->nlp_flag &= ~NLP_RPI_REGISTERED;\n\t\tndlp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\tif (acc_plogi)\n\t\t\tndlp->nlp_flag &= ~NLP_LOGO_ACC;\n\t\treturn 1;\n\t}\n\tndlp->nlp_flag &= ~NLP_LOGO_ACC;\n\treturn 0;\n}\n\n \nvoid\nlpfc_unreg_hba_rpis(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host *shost;\n\tint i;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (!vports) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2884 Vport array allocation failed \\n\");\n\t\treturn;\n\t}\n\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tlist_for_each_entry(ndlp, &vports[i]->fc_nodes, nlp_listp) {\n\t\t\tif (ndlp->nlp_flag & NLP_RPI_REGISTERED) {\n\t\t\t\t \n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tlpfc_unreg_rpi(vports[i], ndlp);\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\nvoid\nlpfc_unreg_all_rpis(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba  = vport->phba;\n\tLPFC_MBOXQ_t     *mbox;\n\tint rc;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tlpfc_sli4_unreg_all_rpis(vport);\n\t\treturn;\n\t}\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (mbox) {\n\t\tlpfc_unreg_login(phba, vport->vpi, LPFC_UNREG_ALL_RPIS_VPORT,\n\t\t\t\t mbox);\n\t\tmbox->vport = vport;\n\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\tmbox->ctx_ndlp = NULL;\n\t\trc = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_TMO);\n\t\tif (rc != MBX_TIMEOUT)\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\n\t\tif ((rc == MBX_TIMEOUT) || (rc == MBX_NOT_FINISHED))\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"1836 Could not issue \"\n\t\t\t\t\t \"unreg_login(all_rpis) status %d\\n\",\n\t\t\t\t\t rc);\n\t}\n}\n\nvoid\nlpfc_unreg_default_rpis(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba  = vport->phba;\n\tLPFC_MBOXQ_t     *mbox;\n\tint rc;\n\n\t \n\tif (phba->sli_rev > LPFC_SLI_REV3)\n\t\treturn;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (mbox) {\n\t\tlpfc_unreg_did(phba, vport->vpi, LPFC_UNREG_ALL_DFLT_RPIS,\n\t\t\t       mbox);\n\t\tmbox->vport = vport;\n\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\tmbox->ctx_ndlp = NULL;\n\t\trc = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_TMO);\n\t\tif (rc != MBX_TIMEOUT)\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\n\t\tif ((rc == MBX_TIMEOUT) || (rc == MBX_NOT_FINISHED))\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"1815 Could not issue \"\n\t\t\t\t\t \"unreg_did (default rpis) status %d\\n\",\n\t\t\t\t\t rc);\n\t}\n}\n\n \nstatic int\nlpfc_cleanup_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tLPFC_MBOXQ_t *mb, *nextmb;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"0900 Cleanup node for NPort x%x \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t ndlp->nlp_state, ndlp->nlp_rpi);\n\tlpfc_dequeue_node(vport, ndlp);\n\n\t \n\n\t \n\tif ((mb = phba->sli.mbox_active)) {\n\t\tif ((mb->u.mb.mbxCommand == MBX_REG_LOGIN64) &&\n\t\t   !(mb->mbox_flag & LPFC_MBX_IMED_UNREG) &&\n\t\t   (ndlp == (struct lpfc_nodelist *)mb->ctx_ndlp)) {\n\t\t\tmb->ctx_ndlp = NULL;\n\t\t\tmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\t}\n\t}\n\n\tspin_lock_irq(&phba->hbalock);\n\t \n\tlist_for_each_entry(mb, &phba->sli.mboxq_cmpl, list) {\n\t\tif ((mb->u.mb.mbxCommand != MBX_REG_LOGIN64) ||\n\t\t\t(mb->mbox_flag & LPFC_MBX_IMED_UNREG) ||\n\t\t\t(ndlp != (struct lpfc_nodelist *)mb->ctx_ndlp))\n\t\t\tcontinue;\n\n\t\tmb->ctx_ndlp = NULL;\n\t\tmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t}\n\n\tlist_for_each_entry_safe(mb, nextmb, &phba->sli.mboxq, list) {\n\t\tif ((mb->u.mb.mbxCommand == MBX_REG_LOGIN64) &&\n\t\t   !(mb->mbox_flag & LPFC_MBX_IMED_UNREG) &&\n\t\t    (ndlp == (struct lpfc_nodelist *)mb->ctx_ndlp)) {\n\t\t\tlist_del(&mb->list);\n\t\t\tlpfc_mbox_rsrc_cleanup(phba, mb, MBOX_THD_LOCKED);\n\n\t\t\t \n\t\t}\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\tlpfc_els_abort(phba, ndlp);\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_DELAY_TMO;\n\tspin_unlock_irq(&ndlp->lock);\n\n\tndlp->nlp_last_elscmd = 0;\n\tdel_timer_sync(&ndlp->nlp_delayfunc);\n\n\tlist_del_init(&ndlp->els_retry_evt.evt_listp);\n\tlist_del_init(&ndlp->dev_loss_evt.evt_listp);\n\tlist_del_init(&ndlp->recovery_evt.evt_listp);\n\tlpfc_cleanup_vports_rrqs(vport, ndlp);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tndlp->nlp_flag |= NLP_RELEASE_RPI;\n\n\treturn 0;\n}\n\nstatic int\nlpfc_matchdid(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t      uint32_t did)\n{\n\tD_ID mydid, ndlpdid, matchdid;\n\n\tif (did == Bcast_DID)\n\t\treturn 0;\n\n\t \n\tif (ndlp->nlp_DID == did)\n\t\treturn 1;\n\n\t \n\tmydid.un.word = vport->fc_myDID;\n\tif ((mydid.un.b.domain == 0) && (mydid.un.b.area == 0)) {\n\t\treturn 0;\n\t}\n\n\tmatchdid.un.word = did;\n\tndlpdid.un.word = ndlp->nlp_DID;\n\tif (matchdid.un.b.id == ndlpdid.un.b.id) {\n\t\tif ((mydid.un.b.domain == matchdid.un.b.domain) &&\n\t\t    (mydid.un.b.area == matchdid.un.b.area)) {\n\t\t\t \n\t\t\tif ((ndlpdid.un.b.domain == 0) &&\n\t\t\t    (ndlpdid.un.b.area == 0)) {\n\t\t\t\tif (ndlpdid.un.b.id &&\n\t\t\t\t    vport->phba->fc_topology ==\n\t\t\t\t    LPFC_TOPOLOGY_LOOP)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tmatchdid.un.word = ndlp->nlp_DID;\n\t\tif ((mydid.un.b.domain == ndlpdid.un.b.domain) &&\n\t\t    (mydid.un.b.area == ndlpdid.un.b.area)) {\n\t\t\tif ((matchdid.un.b.domain == 0) &&\n\t\t\t    (matchdid.un.b.area == 0)) {\n\t\t\t\tif (matchdid.un.b.id)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic struct lpfc_nodelist *\n__lpfc_findnode_did(struct lpfc_vport *vport, uint32_t did)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tuint32_t data1;\n\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (lpfc_matchdid(vport, ndlp, did)) {\n\t\t\tdata1 = (((uint32_t)ndlp->nlp_state << 24) |\n\t\t\t\t ((uint32_t)ndlp->nlp_xri << 16) |\n\t\t\t\t ((uint32_t)ndlp->nlp_type << 8)\n\t\t\t\t );\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t\t\t \"0929 FIND node DID \"\n\t\t\t\t\t \"Data: x%px x%x x%x x%x x%x x%px\\n\",\n\t\t\t\t\t ndlp, ndlp->nlp_DID,\n\t\t\t\t\t ndlp->nlp_flag, data1, ndlp->nlp_rpi,\n\t\t\t\t\t ndlp->active_rrqs_xri_bitmap);\n\t\t\treturn ndlp;\n\t\t}\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"0932 FIND node did x%x NOT FOUND.\\n\", did);\n\treturn NULL;\n}\n\nstruct lpfc_nodelist *\nlpfc_findnode_did(struct lpfc_vport *vport, uint32_t did)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp;\n\tunsigned long iflags;\n\n\tspin_lock_irqsave(shost->host_lock, iflags);\n\tndlp = __lpfc_findnode_did(vport, did);\n\tspin_unlock_irqrestore(shost->host_lock, iflags);\n\treturn ndlp;\n}\n\nstruct lpfc_nodelist *\nlpfc_findnode_mapped(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp;\n\tuint32_t data1;\n\tunsigned long iflags;\n\n\tspin_lock_irqsave(shost->host_lock, iflags);\n\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_state == NLP_STE_UNMAPPED_NODE ||\n\t\t    ndlp->nlp_state == NLP_STE_MAPPED_NODE) {\n\t\t\tdata1 = (((uint32_t)ndlp->nlp_state << 24) |\n\t\t\t\t ((uint32_t)ndlp->nlp_xri << 16) |\n\t\t\t\t ((uint32_t)ndlp->nlp_type << 8) |\n\t\t\t\t ((uint32_t)ndlp->nlp_rpi & 0xff));\n\t\t\tspin_unlock_irqrestore(shost->host_lock, iflags);\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t\t\t \"2025 FIND node DID \"\n\t\t\t\t\t \"Data: x%px x%x x%x x%x x%px\\n\",\n\t\t\t\t\t ndlp, ndlp->nlp_DID,\n\t\t\t\t\t ndlp->nlp_flag, data1,\n\t\t\t\t\t ndlp->active_rrqs_xri_bitmap);\n\t\t\treturn ndlp;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(shost->host_lock, iflags);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"2026 FIND mapped did NOT FOUND.\\n\");\n\treturn NULL;\n}\n\nstruct lpfc_nodelist *\nlpfc_setup_disc_node(struct lpfc_vport *vport, uint32_t did)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\tndlp = lpfc_findnode_did(vport, did);\n\tif (!ndlp) {\n\t\tif (vport->phba->nvmet_support)\n\t\t\treturn NULL;\n\t\tif ((vport->fc_flag & FC_RSCN_MODE) != 0 &&\n\t\t    lpfc_rscn_payload_check(vport, did) == 0)\n\t\t\treturn NULL;\n\t\tndlp = lpfc_nlp_init(vport, did);\n\t\tif (!ndlp)\n\t\t\treturn NULL;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"6453 Setup New Node 2B_DISC x%x \"\n\t\t\t\t \"Data:x%x x%x x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t ndlp->nlp_state, vport->fc_flag);\n\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn ndlp;\n\t}\n\n\t \n\tif ((vport->fc_flag & FC_RSCN_MODE) &&\n\t    !(vport->fc_flag & FC_NDISC_ACTIVE)) {\n\t\tif (lpfc_rscn_payload_check(vport, did)) {\n\n\t\t\t \n\t\t\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"6455 Setup RSCN Node 2B_DISC x%x \"\n\t\t\t\t\t \"Data:x%x x%x x%x\\n\",\n\t\t\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t\t ndlp->nlp_state, vport->fc_flag);\n\n\t\t\t \n\t\t\tif (vport->phba->nvmet_support)\n\t\t\t\treturn ndlp;\n\n\t\t\t \n\t\t\tif (ndlp->nlp_flag & NLP_RCV_PLOGI &&\n\t\t\t    !(ndlp->nlp_type &\n\t\t\t     (NLP_FCP_TARGET | NLP_NVME_TARGET)))\n\t\t\t\treturn NULL;\n\n\t\t\tif (ndlp->nlp_state > NLP_STE_UNUSED_NODE &&\n\t\t\t    ndlp->nlp_state < NLP_STE_PRLI_ISSUE) {\n\t\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\t\t\tNLP_EVT_DEVICE_RECOVERY);\n\t\t\t}\n\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t} else {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"6456 Skip Setup RSCN Node x%x \"\n\t\t\t\t\t \"Data:x%x x%x x%x\\n\",\n\t\t\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t\t ndlp->nlp_state, vport->fc_flag);\n\t\t\tndlp = NULL;\n\t\t}\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"6457 Setup Active Node 2B_DISC x%x \"\n\t\t\t\t \"Data:x%x x%x x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t ndlp->nlp_state, vport->fc_flag);\n\n\t\t \n\t\tif (ndlp->nlp_state == NLP_STE_ADISC_ISSUE ||\n\t\t    ndlp->nlp_state == NLP_STE_PLOGI_ISSUE ||\n\t\t    (!vport->phba->nvmet_support &&\n\t\t     ndlp->nlp_flag & NLP_RCV_PLOGI))\n\t\t\treturn NULL;\n\n\t\tif (vport->phba->nvmet_support)\n\t\t\treturn ndlp;\n\n\t\t \n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t}\n\treturn ndlp;\n}\n\n \nvoid\nlpfc_disc_list_loopmap(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tint j;\n\tuint32_t alpa, index;\n\n\tif (!lpfc_is_link_up(phba))\n\t\treturn;\n\n\tif (phba->fc_topology != LPFC_TOPOLOGY_LOOP)\n\t\treturn;\n\n\t \n\tif (phba->alpa_map[0]) {\n\t\tfor (j = 1; j <= phba->alpa_map[0]; j++) {\n\t\t\talpa = phba->alpa_map[j];\n\t\t\tif (((vport->fc_myDID & 0xff) == alpa) || (alpa == 0))\n\t\t\t\tcontinue;\n\t\t\tlpfc_setup_disc_node(vport, alpa);\n\t\t}\n\t} else {\n\t\t \n\t\tfor (j = 0; j < FC_MAXLOOP; j++) {\n\t\t\t \n\t\t\tif (vport->cfg_scan_down)\n\t\t\t\tindex = j;\n\t\t\telse\n\t\t\t\tindex = FC_MAXLOOP - j - 1;\n\t\t\talpa = lpfcAlpaArray[index];\n\t\t\tif ((vport->fc_myDID & 0xff) == alpa)\n\t\t\t\tcontinue;\n\t\t\tlpfc_setup_disc_node(vport, alpa);\n\t\t}\n\t}\n\treturn;\n}\n\n \nvoid\nlpfc_issue_clear_la(struct lpfc_hba *phba, struct lpfc_vport *vport)\n{\n\tLPFC_MBOXQ_t *mbox;\n\tstruct lpfc_sli *psli = &phba->sli;\n\tstruct lpfc_sli_ring *extra_ring = &psli->sli3_ring[LPFC_EXTRA_RING];\n\tstruct lpfc_sli_ring *fcp_ring   = &psli->sli3_ring[LPFC_FCP_RING];\n\tint  rc;\n\n\t \n\tif ((phba->link_state >= LPFC_CLEAR_LA) ||\n\t    (vport->port_type != LPFC_PHYSICAL_PORT) ||\n\t\t(phba->sli_rev == LPFC_SLI_REV4))\n\t\treturn;\n\n\t\t\t \n\tif ((mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL)) != NULL) {\n\t\tphba->link_state = LPFC_CLEAR_LA;\n\t\tlpfc_clear_la(phba, mbox);\n\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_clear_la;\n\t\tmbox->vport = vport;\n\t\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\tlpfc_disc_flush_list(vport);\n\t\t\textra_ring->flag &= ~LPFC_STOP_IOCB_EVENT;\n\t\t\tfcp_ring->flag &= ~LPFC_STOP_IOCB_EVENT;\n\t\t\tphba->link_state = LPFC_HBA_ERROR;\n\t\t}\n\t}\n}\n\n \nvoid\nlpfc_issue_reg_vpi(struct lpfc_hba *phba, struct lpfc_vport *vport)\n{\n\tLPFC_MBOXQ_t *regvpimbox;\n\n\tregvpimbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (regvpimbox) {\n\t\tlpfc_reg_vpi(vport, regvpimbox);\n\t\tregvpimbox->mbox_cmpl = lpfc_mbx_cmpl_reg_vpi;\n\t\tregvpimbox->vport = vport;\n\t\tif (lpfc_sli_issue_mbox(phba, regvpimbox, MBX_NOWAIT)\n\t\t\t\t\t== MBX_NOT_FINISHED) {\n\t\t\tmempool_free(regvpimbox, phba->mbox_mem_pool);\n\t\t}\n\t}\n}\n\n \nvoid\nlpfc_disc_start(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tuint32_t num_sent;\n\tuint32_t clear_la_pending;\n\n\tif (!lpfc_is_link_up(phba)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_SLI,\n\t\t\t\t \"3315 Link is not up %x\\n\",\n\t\t\t\t phba->link_state);\n\t\treturn;\n\t}\n\n\tif (phba->link_state == LPFC_CLEAR_LA)\n\t\tclear_la_pending = 1;\n\telse\n\t\tclear_la_pending = 0;\n\n\tif (vport->port_state < LPFC_VPORT_READY)\n\t\tvport->port_state = LPFC_DISC_AUTH;\n\n\tlpfc_set_disctmo(vport);\n\n\tvport->fc_prevDID = vport->fc_myDID;\n\tvport->num_disc_nodes = 0;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0202 Start Discovery port state x%x \"\n\t\t\t \"flg x%x Data: x%x x%x x%x\\n\",\n\t\t\t vport->port_state, vport->fc_flag, vport->fc_plogi_cnt,\n\t\t\t vport->fc_adisc_cnt, vport->fc_npr_cnt);\n\n\t \n\tnum_sent = lpfc_els_disc_adisc(vport);\n\n\tif (num_sent)\n\t\treturn;\n\n\t \n\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t    !(vport->fc_flag & FC_PT2PT) &&\n\t    !(vport->fc_flag & FC_RSCN_MODE) &&\n\t    (phba->sli_rev < LPFC_SLI_REV4)) {\n\t\tlpfc_issue_clear_la(phba, vport);\n\t\tlpfc_issue_reg_vpi(phba, vport);\n\t\treturn;\n\t}\n\n\t \n\tif (vport->port_state < LPFC_VPORT_READY && !clear_la_pending) {\n\t\t \n\t\tlpfc_issue_clear_la(phba, vport);\n\n\t\tif (!(vport->fc_flag & FC_ABORT_DISCOVERY)) {\n\t\t\tvport->num_disc_nodes = 0;\n\t\t\t \n\t\t\tif (vport->fc_npr_cnt)\n\t\t\t\tlpfc_els_disc_plogi(vport);\n\n\t\t\tif (!vport->num_disc_nodes) {\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tlpfc_can_disctmo(vport);\n\t\t\t}\n\t\t}\n\t\tvport->port_state = LPFC_VPORT_READY;\n\t} else {\n\t\t \n\t\tnum_sent = lpfc_els_disc_plogi(vport);\n\n\t\tif (num_sent)\n\t\t\treturn;\n\n\t\tif (vport->fc_flag & FC_RSCN_MODE) {\n\t\t\t \n\t\t\tif ((vport->fc_rscn_id_cnt == 0) &&\n\t\t\t    (!(vport->fc_flag & FC_RSCN_DISCOVERY))) {\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag &= ~FC_RSCN_MODE;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tlpfc_can_disctmo(vport);\n\t\t\t} else\n\t\t\t\tlpfc_els_handle_rscn(vport);\n\t\t}\n\t}\n\treturn;\n}\n\n \nstatic void\nlpfc_free_tx(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp)\n{\n\tLIST_HEAD(completions);\n\tstruct lpfc_iocbq    *iocb, *next_iocb;\n\tstruct lpfc_sli_ring *pring;\n\tu32 ulp_command;\n\n\tpring = lpfc_phba_elsring(phba);\n\tif (unlikely(!pring))\n\t\treturn;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(iocb, next_iocb, &pring->txq, list) {\n\t\tif (iocb->ndlp != ndlp)\n\t\t\tcontinue;\n\n\t\tulp_command = get_job_cmnd(phba, iocb);\n\n\t\tif (ulp_command == CMD_ELS_REQUEST64_CR ||\n\t\t    ulp_command == CMD_XMIT_ELS_RSP64_CX) {\n\n\t\t\tlist_move_tail(&iocb->list, &completions);\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(iocb, next_iocb, &pring->txcmplq, list) {\n\t\tif (iocb->ndlp != ndlp)\n\t\t\tcontinue;\n\n\t\tulp_command = get_job_cmnd(phba, iocb);\n\n\t\tif (ulp_command == CMD_ELS_REQUEST64_CR ||\n\t\t    ulp_command == CMD_XMIT_ELS_RSP64_CX) {\n\t\t\tlpfc_sli_issue_abort_iotag(phba, pring, iocb, NULL);\n\t\t}\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tlpfc_issue_hb_tmo(phba);\n\n\t \n\tlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\n\t\t\t      IOERR_SLI_ABORTED);\n}\n\nstatic void\nlpfc_disc_flush_list(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\tif (vport->fc_plogi_cnt || vport->fc_adisc_cnt) {\n\t\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes,\n\t\t\t\t\t nlp_listp) {\n\t\t\tif (ndlp->nlp_state == NLP_STE_PLOGI_ISSUE ||\n\t\t\t    ndlp->nlp_state == NLP_STE_ADISC_ISSUE) {\n\t\t\t\tlpfc_free_tx(phba, ndlp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void\nlpfc_notify_xport_npr(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes,\n\t\t\t\t nlp_listp) {\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t}\n}\nvoid\nlpfc_cleanup_discovery_resources(struct lpfc_vport *vport)\n{\n\tlpfc_els_flush_rscn(vport);\n\tlpfc_els_flush_cmd(vport);\n\tlpfc_disc_flush_list(vport);\n\tif (pci_channel_offline(vport->phba->pcidev))\n\t\tlpfc_notify_xport_npr(vport);\n}\n\n \n \n \nvoid\nlpfc_disc_timeout(struct timer_list *t)\n{\n\tstruct lpfc_vport *vport = from_timer(vport, t, fc_disctmo);\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t tmo_posted;\n\tunsigned long flags = 0;\n\n\tif (unlikely(!phba))\n\t\treturn;\n\n\tspin_lock_irqsave(&vport->work_port_lock, flags);\n\ttmo_posted = vport->work_port_events & WORKER_DISC_TMO;\n\tif (!tmo_posted)\n\t\tvport->work_port_events |= WORKER_DISC_TMO;\n\tspin_unlock_irqrestore(&vport->work_port_lock, flags);\n\n\tif (!tmo_posted)\n\t\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\nstatic void\nlpfc_disc_timeout_handler(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_sli  *psli = &phba->sli;\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\tLPFC_MBOXQ_t *initlinkmbox;\n\tint rc, clrlaerr = 0;\n\n\tif (!(vport->fc_flag & FC_DISC_TMO))\n\t\treturn;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_DISC_TMO;\n\tspin_unlock_irq(shost->host_lock);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"disc timeout:    state:x%x rtry:x%x flg:x%x\",\n\t\tvport->port_state, vport->fc_ns_retry, vport->fc_flag);\n\n\tswitch (vport->port_state) {\n\n\tcase LPFC_LOCAL_CFG_LINK:\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_DISCOVERY,\n\t\t\t\t \"0221 FAN timeout\\n\");\n\n\t\t \n\t\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes,\n\t\t\t\t\t nlp_listp) {\n\t\t\tif (ndlp->nlp_state != NLP_STE_NPR_NODE)\n\t\t\t\tcontinue;\n\t\t\tif (ndlp->nlp_type & NLP_FABRIC) {\n\t\t\t\t \n\t\t\t\tlpfc_drop_node(vport, ndlp);\n\n\t\t\t} else if (!(ndlp->nlp_flag & NLP_NPR_ADISC)) {\n\t\t\t\t \n\t\t\t\tlpfc_unreg_rpi(vport, ndlp);\n\t\t\t}\n\t\t}\n\t\tif (vport->port_state != LPFC_FLOGI) {\n\t\t\tif (phba->sli_rev <= LPFC_SLI_REV3)\n\t\t\t\tlpfc_initial_flogi(vport);\n\t\t\telse\n\t\t\t\tlpfc_issue_init_vfi(vport);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tcase LPFC_FDISC:\n\tcase LPFC_FLOGI:\n\t \n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t \"0222 Initial %s timeout\\n\",\n\t\t\t\t vport->vpi ? \"FDISC\" : \"FLOGI\");\n\n\t\t \n\n\t\t \n\t\tlpfc_disc_list_loopmap(vport);\n\n\t\t \n\t\tlpfc_disc_start(vport);\n\t\tbreak;\n\n\tcase LPFC_FABRIC_CFG_LINK:\n\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t \"0223 Timeout while waiting for \"\n\t\t\t\t \"NameServer login\\n\");\n\t\t \n\t\tndlp = lpfc_findnode_did(vport, NameServer_DID);\n\t\tif (ndlp)\n\t\t\tlpfc_els_abort(phba, ndlp);\n\n\t\t \n\t\tgoto restart_disc;\n\n\tcase LPFC_NS_QRY:\n\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t \"0224 NameServer Query timeout \"\n\t\t\t\t \"Data: x%x x%x\\n\",\n\t\t\t\t vport->fc_ns_retry, LPFC_MAX_NS_RETRY);\n\n\t\tif (vport->fc_ns_retry < LPFC_MAX_NS_RETRY) {\n\t\t\t \n\t\t\tvport->fc_ns_retry++;\n\t\t\tvport->gidft_inp = 0;\n\t\t\trc = lpfc_issue_gidft(vport);\n\t\t\tif (rc == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tvport->fc_ns_retry = 0;\n\nrestart_disc:\n\t\t \n\t\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\t\tif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED)\n\t\t\t\tlpfc_issue_reg_vpi(phba, vport);\n\t\t\telse  {\n\t\t\t\tlpfc_issue_clear_la(phba, vport);\n\t\t\t\tvport->port_state = LPFC_VPORT_READY;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tinitlinkmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (!initlinkmbox) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t \"0206 Device Discovery \"\n\t\t\t\t\t \"completion error\\n\");\n\t\t\tphba->link_state = LPFC_HBA_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tlpfc_linkdown(phba);\n\t\tlpfc_init_link(phba, initlinkmbox, phba->cfg_topology,\n\t\t\t       phba->cfg_link_speed);\n\t\tinitlinkmbox->u.mb.un.varInitLnk.lipsr_AL_PA = 0;\n\t\tinitlinkmbox->vport = vport;\n\t\tinitlinkmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\trc = lpfc_sli_issue_mbox(phba, initlinkmbox, MBX_NOWAIT);\n\t\tlpfc_set_loopback_flag(phba);\n\t\tif (rc == MBX_NOT_FINISHED)\n\t\t\tmempool_free(initlinkmbox, phba->mbox_mem_pool);\n\n\t\tbreak;\n\n\tcase LPFC_DISC_AUTH:\n\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t \"0227 Node Authentication timeout\\n\");\n\t\tlpfc_disc_flush_list(vport);\n\n\t\t \n\t\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\t\tif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED)\n\t\t\t\tlpfc_issue_reg_vpi(phba, vport);\n\t\t\telse  {\t \n\t\t\t\tlpfc_issue_clear_la(phba, vport);\n\t\t\t\tvport->port_state = LPFC_VPORT_READY;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase LPFC_VPORT_READY:\n\t\tif (vport->fc_flag & FC_RSCN_MODE) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t \"0231 RSCN timeout Data: x%x \"\n\t\t\t\t\t \"x%x x%x x%x\\n\",\n\t\t\t\t\t vport->fc_ns_retry, LPFC_MAX_NS_RETRY,\n\t\t\t\t\t vport->port_state, vport->gidft_inp);\n\n\t\t\t \n\t\t\tlpfc_els_flush_cmd(vport);\n\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\t\tlpfc_disc_flush_list(vport);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t \"0273 Unexpected discovery timeout, \"\n\t\t\t\t \"vport State x%x\\n\", vport->port_state);\n\t\tbreak;\n\t}\n\n\tswitch (phba->link_state) {\n\tcase LPFC_CLEAR_LA:\n\t\t\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t \"0228 CLEAR LA timeout\\n\");\n\t\tclrlaerr = 1;\n\t\tbreak;\n\n\tcase LPFC_LINK_UP:\n\t\tlpfc_issue_clear_la(phba, vport);\n\t\tfallthrough;\n\tcase LPFC_LINK_UNKNOWN:\n\tcase LPFC_WARM_START:\n\tcase LPFC_INIT_START:\n\tcase LPFC_INIT_MBX_CMDS:\n\tcase LPFC_LINK_DOWN:\n\tcase LPFC_HBA_ERROR:\n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t \"0230 Unexpected timeout, hba link \"\n\t\t\t\t \"state x%x\\n\", phba->link_state);\n\t\tclrlaerr = 1;\n\t\tbreak;\n\n\tcase LPFC_HBA_READY:\n\t\tbreak;\n\t}\n\n\tif (clrlaerr) {\n\t\tlpfc_disc_flush_list(vport);\n\t\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\t\tpsli->sli3_ring[(LPFC_EXTRA_RING)].flag &=\n\t\t\t\t~LPFC_STOP_IOCB_EVENT;\n\t\t\tpsli->sli3_ring[LPFC_FCP_RING].flag &=\n\t\t\t\t~LPFC_STOP_IOCB_EVENT;\n\t\t}\n\t\tvport->port_state = LPFC_VPORT_READY;\n\t}\n\treturn;\n}\n\n \nvoid\nlpfc_mbx_cmpl_fdmi_reg_login(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_nodelist *ndlp = (struct lpfc_nodelist *)pmb->ctx_ndlp;\n\tstruct lpfc_vport    *vport = pmb->vport;\n\n\tpmb->ctx_ndlp = NULL;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tndlp->nlp_rpi = mb->un.varWords[0];\n\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\tndlp->nlp_type |= NLP_FABRIC;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE | LOG_DISCOVERY,\n\t\t\t \"0004 rpi:%x DID:%x flg:%x %d x%px\\n\",\n\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t kref_read(&ndlp->kref),\n\t\t\t ndlp);\n\t \n\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\tphba->link_flag &= ~LS_CT_VEN_RPA;  \n\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DHBA, 0);\n\t} else {\n\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DPRT, 0);\n\t}\n\n\n\t \n\tlpfc_nlp_put(ndlp);\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\treturn;\n}\n\nstatic int\nlpfc_filter_by_rpi(struct lpfc_nodelist *ndlp, void *param)\n{\n\tuint16_t *rpi = param;\n\n\treturn ndlp->nlp_rpi == *rpi;\n}\n\nstatic int\nlpfc_filter_by_wwpn(struct lpfc_nodelist *ndlp, void *param)\n{\n\treturn memcmp(&ndlp->nlp_portname, param,\n\t\t      sizeof(ndlp->nlp_portname)) == 0;\n}\n\nstatic struct lpfc_nodelist *\n__lpfc_find_node(struct lpfc_vport *vport, node_filter filter, void *param)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (filter(ndlp, param)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t\t\t \"3185 FIND node filter %ps DID \"\n\t\t\t\t\t \"ndlp x%px did x%x flg x%x st x%x \"\n\t\t\t\t\t \"xri x%x type x%x rpi x%x\\n\",\n\t\t\t\t\t filter, ndlp, ndlp->nlp_DID,\n\t\t\t\t\t ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t\t\t ndlp->nlp_xri, ndlp->nlp_type,\n\t\t\t\t\t ndlp->nlp_rpi);\n\t\t\treturn ndlp;\n\t\t}\n\t}\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"3186 FIND node filter %ps NOT FOUND.\\n\", filter);\n\treturn NULL;\n}\n\n \nstruct lpfc_nodelist *\n__lpfc_findnode_rpi(struct lpfc_vport *vport, uint16_t rpi)\n{\n\treturn __lpfc_find_node(vport, lpfc_filter_by_rpi, &rpi);\n}\n\n \nstruct lpfc_nodelist *\nlpfc_findnode_wwpn(struct lpfc_vport *vport, struct lpfc_name *wwpn)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp;\n\n\tspin_lock_irq(shost->host_lock);\n\tndlp = __lpfc_find_node(vport, lpfc_filter_by_wwpn, wwpn);\n\tspin_unlock_irq(shost->host_lock);\n\treturn ndlp;\n}\n\n \nstruct lpfc_nodelist *\nlpfc_findnode_rpi(struct lpfc_vport *vport, uint16_t rpi)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tndlp = __lpfc_findnode_rpi(vport, rpi);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\treturn ndlp;\n}\n\n \nstruct lpfc_vport *\nlpfc_find_vport_by_vpid(struct lpfc_hba *phba, uint16_t vpi)\n{\n\tstruct lpfc_vport *vport;\n\tunsigned long flags;\n\tint i = 0;\n\n\t \n\tif (vpi > 0) {\n\t\t \n\t\tfor (i = 0; i <= phba->max_vpi; i++) {\n\t\t\tif (vpi == phba->vpi_ids[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i > phba->max_vpi) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"2936 Could not find Vport mapped \"\n\t\t\t\t\t\"to vpi %d\\n\", vpi);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&phba->port_list_lock, flags);\n\tlist_for_each_entry(vport, &phba->port_list, listentry) {\n\t\tif (vport->vpi == i) {\n\t\t\tspin_unlock_irqrestore(&phba->port_list_lock, flags);\n\t\t\treturn vport;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->port_list_lock, flags);\n\treturn NULL;\n}\n\nstruct lpfc_nodelist *\nlpfc_nlp_init(struct lpfc_vport *vport, uint32_t did)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tint rpi = LPFC_RPI_ALLOC_ERROR;\n\n\tif (vport->phba->sli_rev == LPFC_SLI_REV4) {\n\t\trpi = lpfc_sli4_alloc_rpi(vport->phba);\n\t\tif (rpi == LPFC_RPI_ALLOC_ERROR)\n\t\t\treturn NULL;\n\t}\n\n\tndlp = mempool_alloc(vport->phba->nlp_mem_pool, GFP_KERNEL);\n\tif (!ndlp) {\n\t\tif (vport->phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_sli4_free_rpi(vport->phba, rpi);\n\t\treturn NULL;\n\t}\n\n\tmemset(ndlp, 0, sizeof (struct lpfc_nodelist));\n\n\tspin_lock_init(&ndlp->lock);\n\n\tlpfc_initialize_node(vport, ndlp, did);\n\tINIT_LIST_HEAD(&ndlp->nlp_listp);\n\tif (vport->phba->sli_rev == LPFC_SLI_REV4) {\n\t\tndlp->nlp_rpi = rpi;\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t \"0007 Init New ndlp x%px, rpi:x%x DID:%x \"\n\t\t\t\t \"flg:x%x refcnt:%d\\n\",\n\t\t\t\t ndlp, ndlp->nlp_rpi, ndlp->nlp_DID,\n\t\t\t\t ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\t\tndlp->active_rrqs_xri_bitmap =\n\t\t\t\tmempool_alloc(vport->phba->active_rrq_pool,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (ndlp->active_rrqs_xri_bitmap)\n\t\t\tmemset(ndlp->active_rrqs_xri_bitmap, 0,\n\t\t\t       ndlp->phba->cfg_rrq_xri_bitmap_sz);\n\t}\n\n\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_NODE,\n\t\t\"node init:       did:x%x\",\n\t\tndlp->nlp_DID, 0, 0);\n\n\treturn ndlp;\n}\n\n \nstatic void\nlpfc_nlp_release(struct kref *kref)\n{\n\tstruct lpfc_nodelist *ndlp = container_of(kref, struct lpfc_nodelist,\n\t\t\t\t\t\t  kref);\n\tstruct lpfc_vport *vport = ndlp->vport;\n\n\tlpfc_debugfs_disc_trc(ndlp->vport, LPFC_DISC_TRC_NODE,\n\t\t\"node release:    did:x%x flg:x%x type:x%x\",\n\t\tndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_type);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"0279 %s: ndlp: x%px did %x refcnt:%d rpi:%x\\n\",\n\t\t\t __func__, ndlp, ndlp->nlp_DID,\n\t\t\t kref_read(&ndlp->kref), ndlp->nlp_rpi);\n\n\t \n\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\tlpfc_cleanup_node(vport, ndlp);\n\n\t \n\tif (ndlp->nlp_flag & NLP_RELEASE_RPI) {\n\t\tif (ndlp->nlp_rpi != LPFC_RPI_ALLOC_ERROR &&\n\t\t    !(ndlp->nlp_flag & (NLP_RPI_REGISTERED | NLP_UNREG_INP))) {\n\t\t\tlpfc_sli4_free_rpi(vport->phba, ndlp->nlp_rpi);\n\t\t\tndlp->nlp_rpi = LPFC_RPI_ALLOC_ERROR;\n\t\t}\n\t}\n\n\t \n\tndlp->vport = NULL;\n\tndlp->nlp_state = NLP_STE_FREED_NODE;\n\tndlp->nlp_flag = 0;\n\tndlp->fc4_xpt_flags = 0;\n\n\t \n\tif (ndlp->phba->sli_rev == LPFC_SLI_REV4)\n\t\tmempool_free(ndlp->active_rrqs_xri_bitmap,\n\t\t\t\tndlp->phba->active_rrq_pool);\n\tmempool_free(ndlp, ndlp->phba->nlp_mem_pool);\n}\n\n \nstruct lpfc_nodelist *\nlpfc_nlp_get(struct lpfc_nodelist *ndlp)\n{\n\tunsigned long flags;\n\n\tif (ndlp) {\n\t\tlpfc_debugfs_disc_trc(ndlp->vport, LPFC_DISC_TRC_NODE,\n\t\t\t\"node get:        did:x%x flg:x%x refcnt:x%x\",\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\tkref_read(&ndlp->kref));\n\n\t\t \n\t\tspin_lock_irqsave(&ndlp->lock, flags);\n\t\tif (!kref_get_unless_zero(&ndlp->kref)) {\n\t\t\tspin_unlock_irqrestore(&ndlp->lock, flags);\n\t\t\tlpfc_printf_vlog(ndlp->vport, KERN_WARNING, LOG_NODE,\n\t\t\t\t\"0276 %s: ndlp:x%px refcnt:%d\\n\",\n\t\t\t\t__func__, (void *)ndlp, kref_read(&ndlp->kref));\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock_irqrestore(&ndlp->lock, flags);\n\t} else {\n\t\tWARN_ONCE(!ndlp, \"**** %s, get ref on NULL ndlp!\", __func__);\n\t}\n\n\treturn ndlp;\n}\n\n \nint\nlpfc_nlp_put(struct lpfc_nodelist *ndlp)\n{\n\tif (ndlp) {\n\t\tlpfc_debugfs_disc_trc(ndlp->vport, LPFC_DISC_TRC_NODE,\n\t\t\t\t\"node put:        did:x%x flg:x%x refcnt:x%x\",\n\t\t\t\tndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\tkref_read(&ndlp->kref));\n\t} else {\n\t\tWARN_ONCE(!ndlp, \"**** %s, put ref on NULL ndlp!\", __func__);\n\t}\n\n\treturn ndlp ? kref_put(&ndlp->kref, lpfc_nlp_release) : 0;\n}\n\n \nstatic int\nlpfc_fcf_inuse(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tint i, ret = 0;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host  *shost;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\n\t \n\tif (!vports)\n\t\treturn 1;\n\n\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\tspin_lock_irq(shost->host_lock);\n\t\t \n\t\tif (!(vports[i]->fc_flag & FC_VPORT_CVL_RCVD)) {\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tret =  1;\n\t\t\tgoto out;\n\t\t}\n\t\tlist_for_each_entry(ndlp, &vports[i]->fc_nodes, nlp_listp) {\n\t\t\tif (ndlp->rport &&\n\t\t\t  (ndlp->rport->roles & FC_RPORT_ROLE_FCP_TARGET)) {\n\t\t\t\tret = 1;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tgoto out;\n\t\t\t} else if (ndlp->nlp_flag & NLP_RPI_REGISTERED) {\n\t\t\t\tret = 1;\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\t\t\tLOG_NODE | LOG_DISCOVERY,\n\t\t\t\t\t\t\"2624 RPI %x DID %x flag %x \"\n\t\t\t\t\t\t\"still logged in\\n\",\n\t\t\t\t\t\tndlp->nlp_rpi, ndlp->nlp_DID,\n\t\t\t\t\t\tndlp->nlp_flag);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\nout:\n\tlpfc_destroy_vport_work_array(phba, vports);\n\treturn ret;\n}\n\n \nvoid\nlpfc_unregister_vfi_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct lpfc_vport *vport = mboxq->vport;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif (mboxq->u.mb.mbxStatus) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2555 UNREG_VFI mbxStatus error x%x \"\n\t\t\t\t\"HBA state x%x\\n\",\n\t\t\t\tmboxq->u.mb.mbxStatus, vport->port_state);\n\t}\n\tspin_lock_irq(shost->host_lock);\n\tphba->pport->fc_flag &= ~FC_VFI_REGISTERED;\n\tspin_unlock_irq(shost->host_lock);\n\tmempool_free(mboxq, phba->mbox_mem_pool);\n\treturn;\n}\n\n \nstatic void\nlpfc_unregister_fcfi_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct lpfc_vport *vport = mboxq->vport;\n\n\tif (mboxq->u.mb.mbxStatus) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2550 UNREG_FCFI mbxStatus error x%x \"\n\t\t\t\t\"HBA state x%x\\n\",\n\t\t\t\tmboxq->u.mb.mbxStatus, vport->port_state);\n\t}\n\tmempool_free(mboxq, phba->mbox_mem_pool);\n\treturn;\n}\n\n \nint\nlpfc_unregister_fcf_prep(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host *shost;\n\tint i = 0, rc;\n\n\t \n\tif (lpfc_fcf_inuse(phba))\n\t\tlpfc_unreg_hba_rpis(phba);\n\n\t \n\tphba->pport->port_state = LPFC_VPORT_UNKNOWN;\n\n\t \n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports && (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED))\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\t \n\t\t\tndlp = lpfc_findnode_did(vports[i], Fabric_DID);\n\t\t\tif (ndlp)\n\t\t\t\tlpfc_cancel_retry_delay_tmo(vports[i], ndlp);\n\t\t\tlpfc_cleanup_pending_mbox(vports[i]);\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\tlpfc_sli4_unreg_all_rpis(vports[i]);\n\t\t\tlpfc_mbx_unreg_vpi(vports[i]);\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvports[i]->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\n\t\t\tvports[i]->vpi_state &= ~LPFC_VPI_REGISTERED;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n\tif (i == 0 && (!(phba->sli3_options & LPFC_SLI3_NPIV_ENABLED))) {\n\t\tndlp = lpfc_findnode_did(phba->pport, Fabric_DID);\n\t\tif (ndlp)\n\t\t\tlpfc_cancel_retry_delay_tmo(phba->pport, ndlp);\n\t\tlpfc_cleanup_pending_mbox(phba->pport);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_sli4_unreg_all_rpis(phba->pport);\n\t\tlpfc_mbx_unreg_vpi(phba->pport);\n\t\tshost = lpfc_shost_from_vport(phba->pport);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tphba->pport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\n\t\tphba->pport->vpi_state &= ~LPFC_VPI_REGISTERED;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\n\t \n\tlpfc_els_flush_all_cmd(phba);\n\n\t \n\trc = lpfc_issue_unreg_vfi(phba->pport);\n\treturn rc;\n}\n\n \nint\nlpfc_sli4_unregister_fcf(struct lpfc_hba *phba)\n{\n\tLPFC_MBOXQ_t *mbox;\n\tint rc;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2551 UNREG_FCFI mbox allocation failed\"\n\t\t\t\t\"HBA state x%x\\n\", phba->pport->port_state);\n\t\treturn -ENOMEM;\n\t}\n\tlpfc_unreg_fcfi(mbox, phba->fcf.fcfi);\n\tmbox->vport = phba->pport;\n\tmbox->mbox_cmpl = lpfc_unregister_fcfi_cmpl;\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2552 Unregister FCFI command failed rc x%x \"\n\t\t\t\t\"HBA state x%x\\n\",\n\t\t\t\trc, phba->pport->port_state);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nvoid\nlpfc_unregister_fcf_rescan(struct lpfc_hba *phba)\n{\n\tint rc;\n\n\t \n\trc = lpfc_unregister_fcf_prep(phba);\n\tif (rc) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2748 Failed to prepare for unregistering \"\n\t\t\t\t\"HBA's FCF record: rc=%d\\n\", rc);\n\t\treturn;\n\t}\n\n\t \n\trc = lpfc_sli4_unregister_fcf(phba);\n\tif (rc)\n\t\treturn;\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag = 0;\n\tspin_unlock_irq(&phba->hbalock);\n\tphba->fcf.current_rec.flag = 0;\n\n\t \n\tif ((phba->pport->load_flag & FC_UNLOADING) ||\n\t    (phba->link_state < LPFC_LINK_UP))\n\t\treturn;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag |= FCF_INIT_DISC;\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tlpfc_sli4_clear_fcf_rr_bmask(phba);\n\n\trc = lpfc_sli4_fcf_scan_read_fcf_rec(phba, LPFC_FCOE_FCF_GET_FIRST);\n\n\tif (rc) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->fcf.fcf_flag &= ~FCF_INIT_DISC;\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2553 lpfc_unregister_unused_fcf failed \"\n\t\t\t\t\"to read FCF record HBA state x%x\\n\",\n\t\t\t\tphba->pport->port_state);\n\t}\n}\n\n \nvoid\nlpfc_unregister_fcf(struct lpfc_hba *phba)\n{\n\tint rc;\n\n\t \n\trc = lpfc_unregister_fcf_prep(phba);\n\tif (rc) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2749 Failed to prepare for unregistering \"\n\t\t\t\t\"HBA's FCF record: rc=%d\\n\", rc);\n\t\treturn;\n\t}\n\n\t \n\trc = lpfc_sli4_unregister_fcf(phba);\n\tif (rc)\n\t\treturn;\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag &= ~FCF_REGISTERED;\n\tspin_unlock_irq(&phba->hbalock);\n}\n\n \nvoid\nlpfc_unregister_unused_fcf(struct lpfc_hba *phba)\n{\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tif (!(phba->hba_flag & HBA_FCOE_MODE) ||\n\t    !(phba->fcf.fcf_flag & FCF_REGISTERED) ||\n\t    !(phba->hba_flag & HBA_FIP_SUPPORT) ||\n\t    (phba->fcf.fcf_flag & FCF_DISCOVERY) ||\n\t    (phba->pport->port_state == LPFC_FLOGI)) {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\treturn;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\tif (lpfc_fcf_inuse(phba))\n\t\treturn;\n\n\tlpfc_unregister_fcf_rescan(phba);\n}\n\n \nstatic void\nlpfc_read_fcf_conn_tbl(struct lpfc_hba *phba,\n\tuint8_t *buff)\n{\n\tstruct lpfc_fcf_conn_entry *conn_entry, *next_conn_entry;\n\tstruct lpfc_fcf_conn_hdr *conn_hdr;\n\tstruct lpfc_fcf_conn_rec *conn_rec;\n\tuint32_t record_count;\n\tint i;\n\n\t \n\tlist_for_each_entry_safe(conn_entry, next_conn_entry,\n\t\t&phba->fcf_conn_rec_list, list) {\n\t\tlist_del_init(&conn_entry->list);\n\t\tkfree(conn_entry);\n\t}\n\n\tconn_hdr = (struct lpfc_fcf_conn_hdr *) buff;\n\trecord_count = conn_hdr->length * sizeof(uint32_t)/\n\t\tsizeof(struct lpfc_fcf_conn_rec);\n\n\tconn_rec = (struct lpfc_fcf_conn_rec *)\n\t\t(buff + sizeof(struct lpfc_fcf_conn_hdr));\n\n\tfor (i = 0; i < record_count; i++) {\n\t\tif (!(conn_rec[i].flags & FCFCNCT_VALID))\n\t\t\tcontinue;\n\t\tconn_entry = kzalloc(sizeof(struct lpfc_fcf_conn_entry),\n\t\t\tGFP_KERNEL);\n\t\tif (!conn_entry) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"2566 Failed to allocate connection\"\n\t\t\t\t\t\" table entry\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tmemcpy(&conn_entry->conn_rec, &conn_rec[i],\n\t\t\tsizeof(struct lpfc_fcf_conn_rec));\n\t\tlist_add_tail(&conn_entry->list,\n\t\t\t&phba->fcf_conn_rec_list);\n\t}\n\n\tif (!list_empty(&phba->fcf_conn_rec_list)) {\n\t\ti = 0;\n\t\tlist_for_each_entry(conn_entry, &phba->fcf_conn_rec_list,\n\t\t\t\t    list) {\n\t\t\tconn_rec = &conn_entry->conn_rec;\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"3345 FCF connection list rec[%02d]: \"\n\t\t\t\t\t\"flags:x%04x, vtag:x%04x, \"\n\t\t\t\t\t\"fabric_name:x%02x:%02x:%02x:%02x:\"\n\t\t\t\t\t\"%02x:%02x:%02x:%02x, \"\n\t\t\t\t\t\"switch_name:x%02x:%02x:%02x:%02x:\"\n\t\t\t\t\t\"%02x:%02x:%02x:%02x\\n\", i++,\n\t\t\t\t\tconn_rec->flags, conn_rec->vlan_tag,\n\t\t\t\t\tconn_rec->fabric_name[0],\n\t\t\t\t\tconn_rec->fabric_name[1],\n\t\t\t\t\tconn_rec->fabric_name[2],\n\t\t\t\t\tconn_rec->fabric_name[3],\n\t\t\t\t\tconn_rec->fabric_name[4],\n\t\t\t\t\tconn_rec->fabric_name[5],\n\t\t\t\t\tconn_rec->fabric_name[6],\n\t\t\t\t\tconn_rec->fabric_name[7],\n\t\t\t\t\tconn_rec->switch_name[0],\n\t\t\t\t\tconn_rec->switch_name[1],\n\t\t\t\t\tconn_rec->switch_name[2],\n\t\t\t\t\tconn_rec->switch_name[3],\n\t\t\t\t\tconn_rec->switch_name[4],\n\t\t\t\t\tconn_rec->switch_name[5],\n\t\t\t\t\tconn_rec->switch_name[6],\n\t\t\t\t\tconn_rec->switch_name[7]);\n\t\t}\n\t}\n}\n\n \nstatic void\nlpfc_read_fcoe_param(struct lpfc_hba *phba,\n\t\t\tuint8_t *buff)\n{\n\tstruct lpfc_fip_param_hdr *fcoe_param_hdr;\n\tstruct lpfc_fcoe_params *fcoe_param;\n\n\tfcoe_param_hdr = (struct lpfc_fip_param_hdr *)\n\t\tbuff;\n\tfcoe_param = (struct lpfc_fcoe_params *)\n\t\t(buff + sizeof(struct lpfc_fip_param_hdr));\n\n\tif ((fcoe_param_hdr->parm_version != FIPP_VERSION) ||\n\t\t(fcoe_param_hdr->length != FCOE_PARAM_LENGTH))\n\t\treturn;\n\n\tif (fcoe_param_hdr->parm_flags & FIPP_VLAN_VALID) {\n\t\tphba->valid_vlan = 1;\n\t\tphba->vlan_id = le16_to_cpu(fcoe_param->vlan_tag) &\n\t\t\t0xFFF;\n\t}\n\n\tphba->fc_map[0] = fcoe_param->fc_map[0];\n\tphba->fc_map[1] = fcoe_param->fc_map[1];\n\tphba->fc_map[2] = fcoe_param->fc_map[2];\n\treturn;\n}\n\n \nstatic uint8_t *\nlpfc_get_rec_conf23(uint8_t *buff, uint32_t size, uint8_t rec_type)\n{\n\tuint32_t offset = 0, rec_length;\n\n\tif ((buff[0] == LPFC_REGION23_LAST_REC) ||\n\t\t(size < sizeof(uint32_t)))\n\t\treturn NULL;\n\n\trec_length = buff[offset + 1];\n\n\t \n\twhile ((offset + rec_length * sizeof(uint32_t) + sizeof(uint32_t))\n\t\t<= size) {\n\t\tif (buff[offset] == rec_type)\n\t\t\treturn &buff[offset];\n\n\t\tif (buff[offset] == LPFC_REGION23_LAST_REC)\n\t\t\treturn NULL;\n\n\t\toffset += rec_length * sizeof(uint32_t) + sizeof(uint32_t);\n\t\trec_length = buff[offset + 1];\n\t}\n\treturn NULL;\n}\n\n \nvoid\nlpfc_parse_fcoe_conf(struct lpfc_hba *phba,\n\t\tuint8_t *buff,\n\t\tuint32_t size)\n{\n\tuint32_t offset = 0;\n\tuint8_t *rec_ptr;\n\n\t \n\tif (size < 2*sizeof(uint32_t))\n\t\treturn;\n\n\t \n\tif (memcmp(buff, LPFC_REGION23_SIGNATURE, 4)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"2567 Config region 23 has bad signature\\n\");\n\t\treturn;\n\t}\n\n\toffset += 4;\n\n\t \n\tif (buff[offset] != LPFC_REGION23_VERSION) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2568 Config region 23 has bad version\\n\");\n\t\treturn;\n\t}\n\toffset += 4;\n\n\t \n\trec_ptr = lpfc_get_rec_conf23(&buff[offset],\n\t\t\tsize - offset, FCOE_PARAM_TYPE);\n\tif (rec_ptr)\n\t\tlpfc_read_fcoe_param(phba, rec_ptr);\n\n\t \n\trec_ptr = lpfc_get_rec_conf23(&buff[offset],\n\t\tsize - offset, FCOE_CONN_TBL_TYPE);\n\tif (rec_ptr)\n\t\tlpfc_read_fcf_conn_tbl(phba, rec_ptr);\n\n}\n\n \nbool\nlpfc_error_lost_link(struct lpfc_vport *vport, u32 ulp_status, u32 ulp_word4)\n{\n\t \n\tu32 rsn_code = IOERR_PARAM_MASK & ulp_word4;\n\n\tif (ulp_status == IOSTAT_LOCAL_REJECT &&\n\t    (rsn_code == IOERR_SLI_ABORTED ||\n\t     rsn_code == IOERR_LINK_DOWN ||\n\t     rsn_code == IOERR_SLI_DOWN)) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_SLI | LOG_ELS,\n\t\t\t\t \"0408 Report link error true: <x%x:x%x>\\n\",\n\t\t\t\t ulp_status, ulp_word4);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}