{
  "module_name": "lpfc_mem.c",
  "hash_id": "7e21780b464178203c2bbfa23ac107dc86605883f017ba6dec39e6418d58478b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_mem.c",
  "human_readable_source": " \n\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_logmsg.h\"\n\n#define LPFC_MBUF_POOL_SIZE     64       \n#define LPFC_MEM_POOL_SIZE      64       \n#define LPFC_DEVICE_DATA_POOL_SIZE 64    \n#define LPFC_RRQ_POOL_SIZE\t256\t \n#define LPFC_MBX_POOL_SIZE\t256\t \n\nint\nlpfc_mem_alloc_active_rrq_pool_s4(struct lpfc_hba *phba) {\n\tsize_t bytes;\n\tint max_xri = phba->sli4_hba.max_cfg_param.max_xri;\n\n\tif (max_xri <= 0)\n\t\treturn -ENOMEM;\n\tbytes = ((BITS_PER_LONG - 1 + max_xri) / BITS_PER_LONG) *\n\t\t  sizeof(unsigned long);\n\tphba->cfg_rrq_xri_bitmap_sz = bytes;\n\tphba->active_rrq_pool = mempool_create_kmalloc_pool(LPFC_MEM_POOL_SIZE,\n\t\t\t\t\t\t\t    bytes);\n\tif (!phba->active_rrq_pool)\n\t\treturn -ENOMEM;\n\telse\n\t\treturn 0;\n}\n\n \nint\nlpfc_mem_alloc(struct lpfc_hba *phba, int align)\n{\n\tstruct lpfc_dma_pool *pool = &phba->lpfc_mbuf_safety_pool;\n\tint i;\n\n\n\tphba->lpfc_mbuf_pool = dma_pool_create(\"lpfc_mbuf_pool\", &phba->pcidev->dev,\n\t\t\t\t\t\t\tLPFC_BPL_SIZE,\n\t\t\t\t\t\t\talign, 0);\n\tif (!phba->lpfc_mbuf_pool)\n\t\tgoto fail;\n\n\tpool->elements = kmalloc_array(LPFC_MBUF_POOL_SIZE,\n\t\t\t\t       sizeof(struct lpfc_dmabuf),\n\t\t\t\t       GFP_KERNEL);\n\tif (!pool->elements)\n\t\tgoto fail_free_lpfc_mbuf_pool;\n\n\tpool->max_count = 0;\n\tpool->current_count = 0;\n\tfor ( i = 0; i < LPFC_MBUF_POOL_SIZE; i++) {\n\t\tpool->elements[i].virt = dma_pool_alloc(phba->lpfc_mbuf_pool,\n\t\t\t\t       GFP_KERNEL, &pool->elements[i].phys);\n\t\tif (!pool->elements[i].virt)\n\t\t\tgoto fail_free_mbuf_pool;\n\t\tpool->max_count++;\n\t\tpool->current_count++;\n\t}\n\n\tphba->mbox_mem_pool = mempool_create_kmalloc_pool(LPFC_MBX_POOL_SIZE,\n\t\t\t\t\t\t\t  sizeof(LPFC_MBOXQ_t));\n\tif (!phba->mbox_mem_pool)\n\t\tgoto fail_free_mbuf_pool;\n\n\tphba->nlp_mem_pool = mempool_create_kmalloc_pool(LPFC_MEM_POOL_SIZE,\n\t\t\t\t\t\tsizeof(struct lpfc_nodelist));\n\tif (!phba->nlp_mem_pool)\n\t\tgoto fail_free_mbox_pool;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tphba->rrq_pool =\n\t\t\tmempool_create_kmalloc_pool(LPFC_RRQ_POOL_SIZE,\n\t\t\t\t\t\tsizeof(struct lpfc_node_rrq));\n\t\tif (!phba->rrq_pool)\n\t\t\tgoto fail_free_nlp_mem_pool;\n\t\tphba->lpfc_hrb_pool = dma_pool_create(\"lpfc_hrb_pool\",\n\t\t\t\t\t      &phba->pcidev->dev,\n\t\t\t\t\t      LPFC_HDR_BUF_SIZE, align, 0);\n\t\tif (!phba->lpfc_hrb_pool)\n\t\t\tgoto fail_free_rrq_mem_pool;\n\n\t\tphba->lpfc_drb_pool = dma_pool_create(\"lpfc_drb_pool\",\n\t\t\t\t\t      &phba->pcidev->dev,\n\t\t\t\t\t      LPFC_DATA_BUF_SIZE, align, 0);\n\t\tif (!phba->lpfc_drb_pool)\n\t\t\tgoto fail_free_hrb_pool;\n\t\tphba->lpfc_hbq_pool = NULL;\n\t} else {\n\t\tphba->lpfc_hbq_pool = dma_pool_create(\"lpfc_hbq_pool\",\n\t\t\t&phba->pcidev->dev, LPFC_BPL_SIZE, align, 0);\n\t\tif (!phba->lpfc_hbq_pool)\n\t\t\tgoto fail_free_nlp_mem_pool;\n\t\tphba->lpfc_hrb_pool = NULL;\n\t\tphba->lpfc_drb_pool = NULL;\n\t}\n\n\tif (phba->cfg_EnableXLane) {\n\t\tphba->device_data_mem_pool = mempool_create_kmalloc_pool(\n\t\t\t\t\tLPFC_DEVICE_DATA_POOL_SIZE,\n\t\t\t\t\tsizeof(struct lpfc_device_data));\n\t\tif (!phba->device_data_mem_pool)\n\t\t\tgoto fail_free_drb_pool;\n\t} else {\n\t\tphba->device_data_mem_pool = NULL;\n\t}\n\n\treturn 0;\nfail_free_drb_pool:\n\tdma_pool_destroy(phba->lpfc_drb_pool);\n\tphba->lpfc_drb_pool = NULL;\n fail_free_hrb_pool:\n\tdma_pool_destroy(phba->lpfc_hrb_pool);\n\tphba->lpfc_hrb_pool = NULL;\n fail_free_rrq_mem_pool:\n\tmempool_destroy(phba->rrq_pool);\n\tphba->rrq_pool = NULL;\n fail_free_nlp_mem_pool:\n\tmempool_destroy(phba->nlp_mem_pool);\n\tphba->nlp_mem_pool = NULL;\n fail_free_mbox_pool:\n\tmempool_destroy(phba->mbox_mem_pool);\n\tphba->mbox_mem_pool = NULL;\n fail_free_mbuf_pool:\n\twhile (i--)\n\t\tdma_pool_free(phba->lpfc_mbuf_pool, pool->elements[i].virt,\n\t\t\t\t\t\t pool->elements[i].phys);\n\tkfree(pool->elements);\n fail_free_lpfc_mbuf_pool:\n\tdma_pool_destroy(phba->lpfc_mbuf_pool);\n\tphba->lpfc_mbuf_pool = NULL;\n fail:\n\treturn -ENOMEM;\n}\n\nint\nlpfc_nvmet_mem_alloc(struct lpfc_hba *phba)\n{\n\tphba->lpfc_nvmet_drb_pool =\n\t\tdma_pool_create(\"lpfc_nvmet_drb_pool\",\n\t\t\t\t&phba->pcidev->dev, LPFC_NVMET_DATA_BUF_SIZE,\n\t\t\t\tSGL_ALIGN_SZ, 0);\n\tif (!phba->lpfc_nvmet_drb_pool) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"6024 Can't enable NVME Target - no memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nvoid\nlpfc_mem_free(struct lpfc_hba *phba)\n{\n\tint i;\n\tstruct lpfc_dma_pool *pool = &phba->lpfc_mbuf_safety_pool;\n\tstruct lpfc_device_data *device_data;\n\n\t \n\tlpfc_sli_hbqbuf_free_all(phba);\n\tdma_pool_destroy(phba->lpfc_nvmet_drb_pool);\n\tphba->lpfc_nvmet_drb_pool = NULL;\n\n\tdma_pool_destroy(phba->lpfc_drb_pool);\n\tphba->lpfc_drb_pool = NULL;\n\n\tdma_pool_destroy(phba->lpfc_hrb_pool);\n\tphba->lpfc_hrb_pool = NULL;\n\n\tdma_pool_destroy(phba->lpfc_hbq_pool);\n\tphba->lpfc_hbq_pool = NULL;\n\n\tmempool_destroy(phba->rrq_pool);\n\tphba->rrq_pool = NULL;\n\n\t \n\tmempool_destroy(phba->nlp_mem_pool);\n\tphba->nlp_mem_pool = NULL;\n\tif (phba->sli_rev == LPFC_SLI_REV4 && phba->active_rrq_pool) {\n\t\tmempool_destroy(phba->active_rrq_pool);\n\t\tphba->active_rrq_pool = NULL;\n\t}\n\n\t \n\tmempool_destroy(phba->mbox_mem_pool);\n\tphba->mbox_mem_pool = NULL;\n\n\t \n\tfor (i = 0; i < pool->current_count; i++)\n\t\tdma_pool_free(phba->lpfc_mbuf_pool, pool->elements[i].virt,\n\t\t\t      pool->elements[i].phys);\n\tkfree(pool->elements);\n\n\tdma_pool_destroy(phba->lpfc_mbuf_pool);\n\tphba->lpfc_mbuf_pool = NULL;\n\n\t \n\tif (phba->device_data_mem_pool) {\n\t\t \n\t\twhile (!list_empty(&phba->luns)) {\n\t\t\tdevice_data = list_first_entry(&phba->luns,\n\t\t\t\t\t\t       struct lpfc_device_data,\n\t\t\t\t\t\t       listentry);\n\t\t\tlist_del(&device_data->listentry);\n\t\t\tmempool_free(device_data, phba->device_data_mem_pool);\n\t\t}\n\t\tmempool_destroy(phba->device_data_mem_pool);\n\t}\n\tphba->device_data_mem_pool = NULL;\n\treturn;\n}\n\n \nvoid\nlpfc_mem_free_all(struct lpfc_hba *phba)\n{\n\tstruct lpfc_sli *psli = &phba->sli;\n\tLPFC_MBOXQ_t *mbox, *next_mbox;\n\tstruct lpfc_dmabuf   *mp;\n\n\t \n\tlist_for_each_entry_safe(mbox, next_mbox, &psli->mboxq, list) {\n\t\tmp = (struct lpfc_dmabuf *)(mbox->ctx_buf);\n\t\tif (mp) {\n\t\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\t\tkfree(mp);\n\t\t}\n\t\tlist_del(&mbox->list);\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t}\n\t \n\tlist_for_each_entry_safe(mbox, next_mbox, &psli->mboxq_cmpl, list) {\n\t\tmp = (struct lpfc_dmabuf *)(mbox->ctx_buf);\n\t\tif (mp) {\n\t\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\t\tkfree(mp);\n\t\t}\n\t\tlist_del(&mbox->list);\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t}\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tpsli->sli_flag &= ~LPFC_SLI_MBOX_ACTIVE;\n\tspin_unlock_irq(&phba->hbalock);\n\tif (psli->mbox_active) {\n\t\tmbox = psli->mbox_active;\n\t\tmp = (struct lpfc_dmabuf *)(mbox->ctx_buf);\n\t\tif (mp) {\n\t\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\t\tkfree(mp);\n\t\t}\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\tpsli->mbox_active = NULL;\n\t}\n\n\t \n\tlpfc_mem_free(phba);\n\n\t \n\tdma_pool_destroy(phba->lpfc_sg_dma_buf_pool);\n\tphba->lpfc_sg_dma_buf_pool = NULL;\n\n\tdma_pool_destroy(phba->lpfc_cmd_rsp_buf_pool);\n\tphba->lpfc_cmd_rsp_buf_pool = NULL;\n\n\t \n\tif (phba->cgn_i) {\n\t\tdma_free_coherent(&phba->pcidev->dev,\n\t\t\t\t  sizeof(struct lpfc_cgn_info),\n\t\t\t\t  phba->cgn_i->virt, phba->cgn_i->phys);\n\t\tkfree(phba->cgn_i);\n\t\tphba->cgn_i = NULL;\n\t}\n\n\t \n\tif (phba->rx_monitor) {\n\t\tlpfc_rx_monitor_destroy_ring(phba->rx_monitor);\n\t\tkfree(phba->rx_monitor);\n\t\tphba->rx_monitor = NULL;\n\t}\n\n\t \n\tkfree(psli->iocbq_lookup);\n\tpsli->iocbq_lookup = NULL;\n\n\treturn;\n}\n\n \nvoid *\nlpfc_mbuf_alloc(struct lpfc_hba *phba, int mem_flags, dma_addr_t *handle)\n{\n\tstruct lpfc_dma_pool *pool = &phba->lpfc_mbuf_safety_pool;\n\tunsigned long iflags;\n\tvoid *ret;\n\n\tret = dma_pool_alloc(phba->lpfc_mbuf_pool, GFP_KERNEL, handle);\n\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\tif (!ret && (mem_flags & MEM_PRI) && pool->current_count) {\n\t\tpool->current_count--;\n\t\tret = pool->elements[pool->current_count].virt;\n\t\t*handle = pool->elements[pool->current_count].phys;\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\treturn ret;\n}\n\n \nvoid\n__lpfc_mbuf_free(struct lpfc_hba * phba, void *virt, dma_addr_t dma)\n{\n\tstruct lpfc_dma_pool *pool = &phba->lpfc_mbuf_safety_pool;\n\n\tif (pool->current_count < pool->max_count) {\n\t\tpool->elements[pool->current_count].virt = virt;\n\t\tpool->elements[pool->current_count].phys = dma;\n\t\tpool->current_count++;\n\t} else {\n\t\tdma_pool_free(phba->lpfc_mbuf_pool, virt, dma);\n\t}\n\treturn;\n}\n\n \nvoid\nlpfc_mbuf_free(struct lpfc_hba * phba, void *virt, dma_addr_t dma)\n{\n\tunsigned long iflags;\n\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t__lpfc_mbuf_free(phba, virt, dma);\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\treturn;\n}\n\n \nvoid *\nlpfc_nvmet_buf_alloc(struct lpfc_hba *phba, int mem_flags, dma_addr_t *handle)\n{\n\tvoid *ret;\n\n\tret = dma_pool_alloc(phba->lpfc_sg_dma_buf_pool, GFP_KERNEL, handle);\n\treturn ret;\n}\n\n \nvoid\nlpfc_nvmet_buf_free(struct lpfc_hba *phba, void *virt, dma_addr_t dma)\n{\n\tdma_pool_free(phba->lpfc_sg_dma_buf_pool, virt, dma);\n}\n\n \nstruct hbq_dmabuf *\nlpfc_els_hbq_alloc(struct lpfc_hba *phba)\n{\n\tstruct hbq_dmabuf *hbqbp;\n\n\thbqbp = kzalloc(sizeof(struct hbq_dmabuf), GFP_KERNEL);\n\tif (!hbqbp)\n\t\treturn NULL;\n\n\thbqbp->dbuf.virt = dma_pool_alloc(phba->lpfc_hbq_pool, GFP_KERNEL,\n\t\t\t\t\t  &hbqbp->dbuf.phys);\n\tif (!hbqbp->dbuf.virt) {\n\t\tkfree(hbqbp);\n\t\treturn NULL;\n\t}\n\thbqbp->total_size = LPFC_BPL_SIZE;\n\treturn hbqbp;\n}\n\n \nvoid\nlpfc_els_hbq_free(struct lpfc_hba *phba, struct hbq_dmabuf *hbqbp)\n{\n\tdma_pool_free(phba->lpfc_hbq_pool, hbqbp->dbuf.virt, hbqbp->dbuf.phys);\n\tkfree(hbqbp);\n\treturn;\n}\n\n \nstruct hbq_dmabuf *\nlpfc_sli4_rb_alloc(struct lpfc_hba *phba)\n{\n\tstruct hbq_dmabuf *dma_buf;\n\n\tdma_buf = kzalloc(sizeof(struct hbq_dmabuf), GFP_KERNEL);\n\tif (!dma_buf)\n\t\treturn NULL;\n\n\tdma_buf->hbuf.virt = dma_pool_alloc(phba->lpfc_hrb_pool, GFP_KERNEL,\n\t\t\t\t\t    &dma_buf->hbuf.phys);\n\tif (!dma_buf->hbuf.virt) {\n\t\tkfree(dma_buf);\n\t\treturn NULL;\n\t}\n\tdma_buf->dbuf.virt = dma_pool_alloc(phba->lpfc_drb_pool, GFP_KERNEL,\n\t\t\t\t\t    &dma_buf->dbuf.phys);\n\tif (!dma_buf->dbuf.virt) {\n\t\tdma_pool_free(phba->lpfc_hrb_pool, dma_buf->hbuf.virt,\n\t\t\t      dma_buf->hbuf.phys);\n\t\tkfree(dma_buf);\n\t\treturn NULL;\n\t}\n\tdma_buf->total_size = LPFC_DATA_BUF_SIZE;\n\treturn dma_buf;\n}\n\n \nvoid\nlpfc_sli4_rb_free(struct lpfc_hba *phba, struct hbq_dmabuf *dmab)\n{\n\tdma_pool_free(phba->lpfc_hrb_pool, dmab->hbuf.virt, dmab->hbuf.phys);\n\tdma_pool_free(phba->lpfc_drb_pool, dmab->dbuf.virt, dmab->dbuf.phys);\n\tkfree(dmab);\n}\n\n \nstruct rqb_dmabuf *\nlpfc_sli4_nvmet_alloc(struct lpfc_hba *phba)\n{\n\tstruct rqb_dmabuf *dma_buf;\n\n\tdma_buf = kzalloc(sizeof(*dma_buf), GFP_KERNEL);\n\tif (!dma_buf)\n\t\treturn NULL;\n\n\tdma_buf->hbuf.virt = dma_pool_alloc(phba->lpfc_hrb_pool, GFP_KERNEL,\n\t\t\t\t\t    &dma_buf->hbuf.phys);\n\tif (!dma_buf->hbuf.virt) {\n\t\tkfree(dma_buf);\n\t\treturn NULL;\n\t}\n\tdma_buf->dbuf.virt = dma_pool_alloc(phba->lpfc_nvmet_drb_pool,\n\t\t\t\t\t    GFP_KERNEL, &dma_buf->dbuf.phys);\n\tif (!dma_buf->dbuf.virt) {\n\t\tdma_pool_free(phba->lpfc_hrb_pool, dma_buf->hbuf.virt,\n\t\t\t      dma_buf->hbuf.phys);\n\t\tkfree(dma_buf);\n\t\treturn NULL;\n\t}\n\tdma_buf->total_size = LPFC_NVMET_DATA_BUF_SIZE;\n\treturn dma_buf;\n}\n\n \nvoid\nlpfc_sli4_nvmet_free(struct lpfc_hba *phba, struct rqb_dmabuf *dmab)\n{\n\tdma_pool_free(phba->lpfc_hrb_pool, dmab->hbuf.virt, dmab->hbuf.phys);\n\tdma_pool_free(phba->lpfc_nvmet_drb_pool,\n\t\t      dmab->dbuf.virt, dmab->dbuf.phys);\n\tkfree(dmab);\n}\n\n \nvoid\nlpfc_in_buf_free(struct lpfc_hba *phba, struct lpfc_dmabuf *mp)\n{\n\tstruct hbq_dmabuf *hbq_entry;\n\tunsigned long flags;\n\n\tif (!mp)\n\t\treturn;\n\n\tif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\n\t\thbq_entry = container_of(mp, struct hbq_dmabuf, dbuf);\n\t\t \n\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\tif (!phba->hbq_in_use) {\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\t\treturn;\n\t\t}\n\t\tlist_del(&hbq_entry->dbuf.list);\n\t\tif (hbq_entry->tag == -1) {\n\t\t\t(phba->hbqs[LPFC_ELS_HBQ].hbq_free_buffer)\n\t\t\t\t(phba, hbq_entry);\n\t\t} else {\n\t\t\tlpfc_sli_free_hbq(phba, hbq_entry);\n\t\t}\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t} else {\n\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\tkfree(mp);\n\t}\n\treturn;\n}\n\n \nvoid\nlpfc_rq_buf_free(struct lpfc_hba *phba, struct lpfc_dmabuf *mp)\n{\n\tstruct lpfc_rqb *rqbp;\n\tstruct lpfc_rqe hrqe;\n\tstruct lpfc_rqe drqe;\n\tstruct rqb_dmabuf *rqb_entry;\n\tunsigned long flags;\n\tint rc;\n\n\tif (!mp)\n\t\treturn;\n\n\trqb_entry = container_of(mp, struct rqb_dmabuf, hbuf);\n\trqbp = rqb_entry->hrq->rqbp;\n\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tlist_del(&rqb_entry->hbuf.list);\n\thrqe.address_lo = putPaddrLow(rqb_entry->hbuf.phys);\n\thrqe.address_hi = putPaddrHigh(rqb_entry->hbuf.phys);\n\tdrqe.address_lo = putPaddrLow(rqb_entry->dbuf.phys);\n\tdrqe.address_hi = putPaddrHigh(rqb_entry->dbuf.phys);\n\trc = lpfc_sli4_rq_put(rqb_entry->hrq, rqb_entry->drq, &hrqe, &drqe);\n\tif (rc < 0) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"6409 Cannot post to HRQ %d: %x %x %x \"\n\t\t\t\t\"DRQ %x %x\\n\",\n\t\t\t\trqb_entry->hrq->queue_id,\n\t\t\t\trqb_entry->hrq->host_index,\n\t\t\t\trqb_entry->hrq->hba_index,\n\t\t\t\trqb_entry->hrq->entry_count,\n\t\t\t\trqb_entry->drq->host_index,\n\t\t\t\trqb_entry->drq->hba_index);\n\t\t(rqbp->rqb_free_buffer)(phba, rqb_entry);\n\t} else {\n\t\tlist_add_tail(&rqb_entry->hbuf.list, &rqbp->rqb_buffer_list);\n\t\trqbp->buffer_count++;\n\t}\n\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}