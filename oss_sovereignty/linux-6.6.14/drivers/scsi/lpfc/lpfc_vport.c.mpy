{
  "module_name": "lpfc_vport.c",
  "hash_id": "58500cc3dbb0aecb10dfd1c9d068e3def7f9608321e7ffd5a4ce947216315f92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_vport.c",
  "human_readable_source": " \n\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/sched/signal.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_version.h\"\n#include \"lpfc_vport.h\"\n\ninline void lpfc_vport_set_state(struct lpfc_vport *vport,\n\t\t\t\t enum fc_vport_state new_state)\n{\n\tstruct fc_vport *fc_vport = vport->fc_vport;\n\n\tif (fc_vport) {\n\t\t \n\t\t \n\t\tif (new_state != FC_VPORT_INITIALIZING)\n\t\t\tfc_vport->vport_last_state = fc_vport->vport_state;\n\t\tfc_vport->vport_state = new_state;\n\t}\n\n\t \n\tswitch (new_state) {\n\tcase FC_VPORT_NO_FABRIC_SUPP:\n\tcase FC_VPORT_NO_FABRIC_RSCS:\n\tcase FC_VPORT_FABRIC_LOGOUT:\n\tcase FC_VPORT_FABRIC_REJ_WWN:\n\tcase FC_VPORT_FAILED:\n\t\tvport->port_state = LPFC_VPORT_FAILED;\n\t\tbreak;\n\tcase FC_VPORT_LINKDOWN:\n\t\tvport->port_state = LPFC_VPORT_UNKNOWN;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nint\nlpfc_alloc_vpi(struct lpfc_hba *phba)\n{\n\tunsigned long vpi;\n\n\tspin_lock_irq(&phba->hbalock);\n\t \n\tvpi = find_next_zero_bit(phba->vpi_bmask, (phba->max_vpi + 1), 1);\n\tif (vpi > phba->max_vpi)\n\t\tvpi = 0;\n\telse\n\t\tset_bit(vpi, phba->vpi_bmask);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tphba->sli4_hba.max_cfg_param.vpi_used++;\n\tspin_unlock_irq(&phba->hbalock);\n\treturn vpi;\n}\n\nstatic void\nlpfc_free_vpi(struct lpfc_hba *phba, int vpi)\n{\n\tif (vpi == 0)\n\t\treturn;\n\tspin_lock_irq(&phba->hbalock);\n\tclear_bit(vpi, phba->vpi_bmask);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tphba->sli4_hba.max_cfg_param.vpi_used--;\n\tspin_unlock_irq(&phba->hbalock);\n}\n\nstatic int\nlpfc_vport_sparm(struct lpfc_hba *phba, struct lpfc_vport *vport)\n{\n\tLPFC_MBOXQ_t *pmb;\n\tMAILBOX_t *mb;\n\tstruct lpfc_dmabuf *mp;\n\tint  rc;\n\n\tpmb = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmb) {\n\t\treturn -ENOMEM;\n\t}\n\tmb = &pmb->u.mb;\n\n\trc = lpfc_read_sparam(phba, pmb, vport->vpi);\n\tif (rc) {\n\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpmb->vport = vport;\n\trc = lpfc_sli_issue_mbox_wait(phba, pmb, phba->fc_ratov * 2);\n\tif (rc != MBX_SUCCESS) {\n\t\tif (signal_pending(current)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"1830 Signal aborted mbxCmd x%x\\n\",\n\t\t\t\t\t mb->mbxCommand);\n\t\t\tif (rc != MBX_TIMEOUT)\n\t\t\t\tlpfc_mbox_rsrc_cleanup(phba, pmb,\n\t\t\t\t\t\t       MBOX_THD_UNLOCKED);\n\t\t\treturn -EINTR;\n\t\t} else {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"1818 VPort failed init, mbxCmd x%x \"\n\t\t\t\t\t \"READ_SPARM mbxStatus x%x, rc = x%x\\n\",\n\t\t\t\t\t mb->mbxCommand, mb->mbxStatus, rc);\n\t\t\tif (rc != MBX_TIMEOUT)\n\t\t\t\tlpfc_mbox_rsrc_cleanup(phba, pmb,\n\t\t\t\t\t\t       MBOX_THD_UNLOCKED);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tmp = (struct lpfc_dmabuf *)pmb->ctx_buf;\n\tmemcpy(&vport->fc_sparam, mp->virt, sizeof (struct serv_parm));\n\tmemcpy(&vport->fc_nodename, &vport->fc_sparam.nodeName,\n\t       sizeof (struct lpfc_name));\n\tmemcpy(&vport->fc_portname, &vport->fc_sparam.portName,\n\t       sizeof (struct lpfc_name));\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n\treturn 0;\n}\n\nstatic int\nlpfc_valid_wwn_format(struct lpfc_hba *phba, struct lpfc_name *wwn,\n\t\t      const char *name_type)\n{\n\t\t\t\t \n\tif (!((wwn->u.wwn[0] >> 4) == 1 &&\n\t      ((wwn->u.wwn[0] & 0xf) != 0 || (wwn->u.wwn[1] & 0xf) != 0)))\n\t\treturn 1;\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_VPORT,\n\t\t\t\"1822 Invalid %s: %02x:%02x:%02x:%02x:\"\n\t\t\t\"%02x:%02x:%02x:%02x\\n\",\n\t\t\tname_type,\n\t\t\twwn->u.wwn[0], wwn->u.wwn[1],\n\t\t\twwn->u.wwn[2], wwn->u.wwn[3],\n\t\t\twwn->u.wwn[4], wwn->u.wwn[5],\n\t\t\twwn->u.wwn[6], wwn->u.wwn[7]);\n\treturn 0;\n}\n\nstatic int\nlpfc_unique_wwpn(struct lpfc_hba *phba, struct lpfc_vport *new_vport)\n{\n\tstruct lpfc_vport *vport;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phba->port_list_lock, flags);\n\tlist_for_each_entry(vport, &phba->port_list, listentry) {\n\t\tif (vport == new_vport)\n\t\t\tcontinue;\n\t\t \n\t\tif (memcmp(&vport->fc_sparam.portName,\n\t\t\t   &new_vport->fc_sparam.portName,\n\t\t\t   sizeof(struct lpfc_name)) == 0) {\n\t\t\tspin_unlock_irqrestore(&phba->port_list_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->port_list_lock, flags);\n\treturn 1;\n}\n\n \nstatic void lpfc_discovery_wait(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tuint32_t wait_flags = 0;\n\tunsigned long wait_time_max;\n\tunsigned long start_time;\n\n\twait_flags = FC_RSCN_MODE | FC_RSCN_DISCOVERY | FC_NLP_MORE |\n\t\t     FC_RSCN_DEFERRED | FC_NDISC_ACTIVE | FC_DISC_TMO;\n\n\t \n\twait_time_max = msecs_to_jiffies(((phba->fc_ratov * 3) + 3) * 1000);\n\twait_time_max += jiffies;\n\tstart_time = jiffies;\n\twhile (time_before(jiffies, wait_time_max)) {\n\t\tif ((vport->num_disc_nodes > 0)    ||\n\t\t    (vport->fc_flag & wait_flags)  ||\n\t\t    ((vport->port_state > LPFC_VPORT_FAILED) &&\n\t\t     (vport->port_state < LPFC_VPORT_READY))) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_VPORT,\n\t\t\t\t\t\"1833 Vport discovery quiesce Wait:\"\n\t\t\t\t\t\" state x%x fc_flags x%x\"\n\t\t\t\t\t\" num_nodes x%x, waiting 1000 msecs\"\n\t\t\t\t\t\" total wait msecs x%x\\n\",\n\t\t\t\t\tvport->port_state, vport->fc_flag,\n\t\t\t\t\tvport->num_disc_nodes,\n\t\t\t\t\tjiffies_to_msecs(jiffies - start_time));\n\t\t\tmsleep(1000);\n\t\t} else {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_VPORT,\n\t\t\t\t\t \"1834 Vport discovery quiesced:\"\n\t\t\t\t\t \" state x%x fc_flags x%x\"\n\t\t\t\t\t \" wait msecs x%x\\n\",\n\t\t\t\t\t vport->port_state, vport->fc_flag,\n\t\t\t\t\t jiffies_to_msecs(jiffies\n\t\t\t\t\t\t- start_time));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (time_after(jiffies, wait_time_max))\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"1835 Vport discovery quiesce failed:\"\n\t\t\t\t \" state x%x fc_flags x%x wait msecs x%x\\n\",\n\t\t\t\t vport->port_state, vport->fc_flag,\n\t\t\t\t jiffies_to_msecs(jiffies - start_time));\n}\n\nint\nlpfc_vport_create(struct fc_vport *fc_vport, bool disable)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host *shost = fc_vport->shost;\n\tstruct lpfc_vport *pport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = pport->phba;\n\tstruct lpfc_vport *vport = NULL;\n\tint instance;\n\tint vpi;\n\tint rc = VPORT_ERROR;\n\tint status;\n\n\tif ((phba->sli_rev < 3) || !(phba->cfg_enable_npiv)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"1808 Create VPORT failed: \"\n\t\t\t\t\"NPIV is not enabled: SLImode:%d\\n\",\n\t\t\t\tphba->sli_rev);\n\t\trc = VPORT_INVAL;\n\t\tgoto error_out;\n\t}\n\n\t \n\tif (phba->nvmet_support) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"3189 Create VPORT failed: \"\n\t\t\t\t\"NPIV is not supported on NVME Target\\n\");\n\t\trc = VPORT_INVAL;\n\t\tgoto error_out;\n\t}\n\n\tvpi = lpfc_alloc_vpi(phba);\n\tif (vpi == 0) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"1809 Create VPORT failed: \"\n\t\t\t\t\"Max VPORTs (%d) exceeded\\n\",\n\t\t\t\tphba->max_vpi);\n\t\trc = VPORT_NORESOURCES;\n\t\tgoto error_out;\n\t}\n\n\t \n\tif ((instance = lpfc_get_instance()) < 0) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"1810 Create VPORT failed: Cannot get \"\n\t\t\t\t\"instance number\\n\");\n\t\tlpfc_free_vpi(phba, vpi);\n\t\trc = VPORT_NORESOURCES;\n\t\tgoto error_out;\n\t}\n\n\tvport = lpfc_create_port(phba, instance, &fc_vport->dev);\n\tif (!vport) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"1811 Create VPORT failed: vpi x%x\\n\", vpi);\n\t\tlpfc_free_vpi(phba, vpi);\n\t\trc = VPORT_NORESOURCES;\n\t\tgoto error_out;\n\t}\n\n\tvport->vpi = vpi;\n\tlpfc_debugfs_initialize(vport);\n\n\tif ((status = lpfc_vport_sparm(phba, vport))) {\n\t\tif (status == -EINTR) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"1831 Create VPORT Interrupted.\\n\");\n\t\t\trc = VPORT_ERROR;\n\t\t} else {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"1813 Create VPORT failed. \"\n\t\t\t\t\t \"Cannot get sparam\\n\");\n\t\t\trc = VPORT_NORESOURCES;\n\t\t}\n\t\tlpfc_free_vpi(phba, vpi);\n\t\tdestroy_port(vport);\n\t\tgoto error_out;\n\t}\n\n\tu64_to_wwn(fc_vport->node_name, vport->fc_nodename.u.wwn);\n\tu64_to_wwn(fc_vport->port_name, vport->fc_portname.u.wwn);\n\n\tmemcpy(&vport->fc_sparam.portName, vport->fc_portname.u.wwn, 8);\n\tmemcpy(&vport->fc_sparam.nodeName, vport->fc_nodename.u.wwn, 8);\n\n\tif (!lpfc_valid_wwn_format(phba, &vport->fc_sparam.nodeName, \"WWNN\") ||\n\t    !lpfc_valid_wwn_format(phba, &vport->fc_sparam.portName, \"WWPN\")) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"1821 Create VPORT failed. \"\n\t\t\t\t \"Invalid WWN format\\n\");\n\t\tlpfc_free_vpi(phba, vpi);\n\t\tdestroy_port(vport);\n\t\trc = VPORT_INVAL;\n\t\tgoto error_out;\n\t}\n\n\tif (!lpfc_unique_wwpn(phba, vport)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"1823 Create VPORT failed. \"\n\t\t\t\t \"Duplicate WWN on HBA\\n\");\n\t\tlpfc_free_vpi(phba, vpi);\n\t\tdestroy_port(vport);\n\t\trc = VPORT_INVAL;\n\t\tgoto error_out;\n\t}\n\n\t \n\tlpfc_alloc_sysfs_attr(vport);\n\n\t \n\tvport->cfg_lun_queue_depth  = phba->pport->cfg_lun_queue_depth;\n\n\t \n\tvport->cfg_enable_fc4_type = LPFC_ENABLE_FCP;\n\n\t*(struct lpfc_vport **)fc_vport->dd_data = vport;\n\tvport->fc_vport = fc_vport;\n\n\t \n\tvport->load_flag |= FC_ALLOW_FDMI;\n\tif (phba->cfg_enable_SmartSAN ||\n\t    (phba->cfg_fdmi_on == LPFC_FDMI_SUPPORT)) {\n\t\t \n\t\tvport->fdmi_hba_mask = phba->pport->fdmi_hba_mask;\n\t\tvport->fdmi_port_mask = phba->pport->fdmi_port_mask;\n\t}\n\n\t \n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    (pport->fc_flag & FC_VFI_REGISTERED)) {\n\t\trc = lpfc_sli4_init_vpi(vport);\n\t\tif (rc) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"1838 Failed to INIT_VPI on vpi %d \"\n\t\t\t\t\t\"status %d\\n\", vpi, rc);\n\t\t\trc = VPORT_NORESOURCES;\n\t\t\tlpfc_free_vpi(phba, vpi);\n\t\t\tgoto error_out;\n\t\t}\n\t} else if (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t \n\t\tvport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\n\t\tlpfc_vport_set_state(vport, FC_VPORT_LINKDOWN);\n\t\trc = VPORT_OK;\n\t\tgoto out;\n\t}\n\n\tif ((phba->link_state < LPFC_LINK_UP) ||\n\t    (pport->port_state < LPFC_FABRIC_CFG_LINK) ||\n\t    (phba->fc_topology == LPFC_TOPOLOGY_LOOP)) {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_LINKDOWN);\n\t\trc = VPORT_OK;\n\t\tgoto out;\n\t}\n\n\tif (disable) {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_DISABLED);\n\t\trc = VPORT_OK;\n\t\tgoto out;\n\t}\n\n\t \n\tndlp = lpfc_findnode_did(phba->pport, Fabric_DID);\n\tif (ndlp &&\n\t    ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) {\n\t\tif (phba->link_flag & LS_NPIV_FAB_SUPPORTED) {\n\t\t\tlpfc_set_disctmo(vport);\n\t\t\tlpfc_initial_fdisc(vport);\n\t\t} else {\n\t\t\tlpfc_vport_set_state(vport, FC_VPORT_NO_FABRIC_SUPP);\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0262 No NPIV Fabric support\\n\");\n\t\t}\n\t} else {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t}\n\trc = VPORT_OK;\n\nout:\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_VPORT,\n\t\t\t \"1825 Vport Created.\\n\");\n\tlpfc_host_attrib_init(lpfc_shost_from_vport(vport));\nerror_out:\n\treturn rc;\n}\n\nstatic int\nlpfc_send_npiv_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tint rc;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waitq);\n\n\tspin_lock_irq(&ndlp->lock);\n\tif (!(ndlp->save_flags & NLP_WAIT_FOR_LOGO) &&\n\t    !ndlp->logo_waitq) {\n\t\tndlp->logo_waitq = &waitq;\n\t\tndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\t\tndlp->nlp_flag |= NLP_ISSUE_LOGO;\n\t\tndlp->save_flags |= NLP_WAIT_FOR_LOGO;\n\t}\n\tspin_unlock_irq(&ndlp->lock);\n\trc = lpfc_issue_els_npiv_logo(vport, ndlp);\n\tif (!rc) {\n\t\twait_event_timeout(waitq,\n\t\t\t\t   (!(ndlp->save_flags & NLP_WAIT_FOR_LOGO)),\n\t\t\t\t   msecs_to_jiffies(phba->fc_ratov * 2000));\n\n\t\tif (!(ndlp->save_flags & NLP_WAIT_FOR_LOGO))\n\t\t\tgoto logo_cmpl;\n\t\t \n\t\trc = -EINTR;\n\t} else {\n\t\trc = -EIO;\n\t}\n\n\t \n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_ISSUE_LOGO;\n\tndlp->save_flags &= ~NLP_WAIT_FOR_LOGO;\n\tspin_unlock_irq(&ndlp->lock);\n\n logo_cmpl:\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_VPORT,\n\t\t\t \"1824 Issue LOGO completes with status %d\\n\",\n\t\t\t rc);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->logo_waitq = NULL;\n\tspin_unlock_irq(&ndlp->lock);\n\treturn rc;\n}\n\nstatic int\ndisable_vport(struct fc_vport *fc_vport)\n{\n\tstruct lpfc_vport *vport = *(struct lpfc_vport **)fc_vport->dd_data;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\t \n\tif (vport->load_flag & FC_UNLOADING)\n\t\treturn 0;\n\n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (ndlp && phba->link_state >= LPFC_LINK_UP)\n\t\t(void)lpfc_send_npiv_logo(vport, ndlp);\n\n\tlpfc_sli_host_down(vport);\n\tlpfc_cleanup_rpis(vport, 0);\n\n\tlpfc_stop_vport_timers(vport);\n\tlpfc_unreg_all_rpis(vport);\n\tlpfc_unreg_default_rpis(vport);\n\t \n\tlpfc_mbx_unreg_vpi(vport);\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\n\tlpfc_vport_set_state(vport, FC_VPORT_DISABLED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_VPORT,\n\t\t\t \"1826 Vport Disabled.\\n\");\n\treturn VPORT_OK;\n}\n\nstatic int\nenable_vport(struct fc_vport *fc_vport)\n{\n\tstruct lpfc_vport *vport = *(struct lpfc_vport **)fc_vport->dd_data;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif ((phba->link_state < LPFC_LINK_UP) ||\n\t    (phba->fc_topology == LPFC_TOPOLOGY_LOOP)) {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_LINKDOWN);\n\t\treturn VPORT_OK;\n\t}\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->load_flag |= FC_LOADING;\n\tif (vport->fc_flag & FC_VPORT_NEEDS_INIT_VPI) {\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tlpfc_issue_init_vpi(vport);\n\t\tgoto out;\n\t}\n\n\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\n\t \n\tndlp = lpfc_findnode_did(phba->pport, Fabric_DID);\n\tif (ndlp && ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) {\n\t\tif (phba->link_flag & LS_NPIV_FAB_SUPPORTED) {\n\t\t\tlpfc_set_disctmo(vport);\n\t\t\tlpfc_initial_fdisc(vport);\n\t\t} else {\n\t\t\tlpfc_vport_set_state(vport, FC_VPORT_NO_FABRIC_SUPP);\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0264 No NPIV Fabric support\\n\");\n\t\t}\n\t} else {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t}\n\nout:\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_VPORT,\n\t\t\t \"1827 Vport Enabled.\\n\");\n\treturn VPORT_OK;\n}\n\nint\nlpfc_vport_disable(struct fc_vport *fc_vport, bool disable)\n{\n\tif (disable)\n\t\treturn disable_vport(fc_vport);\n\telse\n\t\treturn enable_vport(fc_vport);\n}\n\nint\nlpfc_vport_delete(struct fc_vport *fc_vport)\n{\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tstruct lpfc_vport *vport = *(struct lpfc_vport **)fc_vport->dd_data;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tint rc;\n\n\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"1812 vport_delete failed: Cannot delete \"\n\t\t\t\t \"physical host\\n\");\n\t\treturn VPORT_ERROR;\n\t}\n\n\t \n\tif ((vport->vport_flag & STATIC_VPORT) &&\n\t\t!(phba->pport->load_flag & FC_UNLOADING)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"1837 vport_delete failed: Cannot delete \"\n\t\t\t\t \"static vport.\\n\");\n\t\treturn VPORT_ERROR;\n\t}\n\n\tspin_lock_irq(&phba->hbalock);\n\tvport->load_flag |= FC_UNLOADING;\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tif (!(phba->pport->load_flag & FC_UNLOADING)) {\n\t\tint check_count = 0;\n\t\twhile (check_count < ((phba->fc_ratov * 3) + 3) &&\n\t\t       vport->port_state > LPFC_VPORT_FAILED &&\n\t\t       vport->port_state < LPFC_VPORT_READY) {\n\t\t\tcheck_count++;\n\t\t\tmsleep(1000);\n\t\t}\n\t\tif (vport->port_state > LPFC_VPORT_FAILED &&\n\t\t    vport->port_state < LPFC_VPORT_READY)\n\t\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (!scsi_host_get(shost))\n\t\treturn VPORT_INVAL;\n\n\tlpfc_free_sysfs_attr(vport);\n\tlpfc_debugfs_terminate(vport);\n\n\t \n\tfc_remove_host(shost);\n\tscsi_remove_host(shost);\n\n\t \n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp)\n\t\tgoto skip_logo;\n\n\tif (ndlp && ndlp->nlp_state == NLP_STE_UNMAPPED_NODE &&\n\t    phba->link_state >= LPFC_LINK_UP &&\n\t    phba->fc_topology != LPFC_TOPOLOGY_LOOP) {\n\t\tif (vport->cfg_enable_da_id) {\n\t\t\t \n\t\t\trc = lpfc_ns_cmd(vport, SLI_CTNS_DA_ID, 0, 0);\n\t\t\tif (rc) {\n\t\t\t\tlpfc_printf_log(vport->phba, KERN_WARNING,\n\t\t\t\t\t\tLOG_VPORT,\n\t\t\t\t\t\t\"1829 CT command failed to \"\n\t\t\t\t\t\t\"delete objects on fabric, \"\n\t\t\t\t\t\t\"rc %d\\n\", rc);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!(vport->vpi_state & LPFC_VPI_REGISTERED))\n\t\t\tgoto skip_logo;\n\n\t\t \n\t\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\t\tif (!ndlp)\n\t\t\tgoto skip_logo;\n\n\t\trc = lpfc_send_npiv_logo(vport, ndlp);\n\t\tif (rc)\n\t\t\tgoto skip_logo;\n\t}\n\n\tif (!(phba->pport->load_flag & FC_UNLOADING))\n\t\tlpfc_discovery_wait(vport);\n\nskip_logo:\n\n\tlpfc_cleanup(vport);\n\n\t \n\tlpfc_sli_host_down(vport);\n\tlpfc_stop_vport_timers(vport);\n\n\tif (!(phba->pport->load_flag & FC_UNLOADING)) {\n\t\tlpfc_unreg_all_rpis(vport);\n\t\tlpfc_unreg_default_rpis(vport);\n\t\t \n\t\tif (!(vport->vpi_state & LPFC_VPI_REGISTERED) ||\n\t\t\t\tlpfc_mbx_unreg_vpi(vport))\n\t\t\tscsi_host_put(shost);\n\t} else {\n\t\tscsi_host_put(shost);\n\t}\n\n\tlpfc_free_vpi(phba, vport->vpi);\n\tvport->work_port_events = 0;\n\tspin_lock_irq(&phba->port_list_lock);\n\tlist_del_init(&vport->listentry);\n\tspin_unlock_irq(&phba->port_list_lock);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_VPORT,\n\t\t\t \"1828 Vport Deleted.\\n\");\n\tscsi_host_put(shost);\n\treturn VPORT_OK;\n}\n\nstruct lpfc_vport **\nlpfc_create_vport_work_array(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport *port_iterator;\n\tstruct lpfc_vport **vports;\n\tint index = 0;\n\tvports = kcalloc(phba->max_vports + 1, sizeof(struct lpfc_vport *),\n\t\t\t GFP_KERNEL);\n\tif (vports == NULL)\n\t\treturn NULL;\n\tspin_lock_irq(&phba->port_list_lock);\n\tlist_for_each_entry(port_iterator, &phba->port_list, listentry) {\n\t\tif (port_iterator->load_flag & FC_UNLOADING)\n\t\t\tcontinue;\n\t\tif (!scsi_host_get(lpfc_shost_from_vport(port_iterator))) {\n\t\t\tlpfc_printf_vlog(port_iterator, KERN_ERR,\n\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t \"1801 Create vport work array FAILED: \"\n\t\t\t\t\t \"cannot do scsi_host_get\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tvports[index++] = port_iterator;\n\t}\n\tspin_unlock_irq(&phba->port_list_lock);\n\treturn vports;\n}\n\nvoid\nlpfc_destroy_vport_work_array(struct lpfc_hba *phba, struct lpfc_vport **vports)\n{\n\tint i;\n\tif (vports == NULL)\n\t\treturn;\n\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++)\n\t\tscsi_host_put(lpfc_shost_from_vport(vports[i]));\n\tkfree(vports);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}