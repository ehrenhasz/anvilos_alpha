{
  "module_name": "lpfc_mbox.c",
  "hash_id": "fad96dddaa48dd10f5b6f349864e1aaa58bb3e4ab663a4831231efcae7167710",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_mbox.c",
  "human_readable_source": " \n\n#include <linux/blkdev.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/scsi.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_compat.h\"\n\n \nint\nlpfc_mbox_rsrc_prep(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbox)\n{\n\tstruct lpfc_dmabuf *mp;\n\n\tmp = kmalloc(sizeof(*mp), GFP_KERNEL);\n\tif (!mp)\n\t\treturn -ENOMEM;\n\n\tmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\n\tif (!mp->virt) {\n\t\tkfree(mp);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(mp->virt, 0, LPFC_BPL_SIZE);\n\n\t \n\tINIT_LIST_HEAD(&mp->list);\n\tmbox->ctx_buf = mp;\n\treturn 0;\n}\n\n \nvoid\nlpfc_mbox_rsrc_cleanup(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbox,\n\t\t       enum lpfc_mbox_ctx locked)\n{\n\tstruct lpfc_dmabuf *mp;\n\n\tmp = (struct lpfc_dmabuf *)mbox->ctx_buf;\n\tmbox->ctx_buf = NULL;\n\n\t \n\tif (mp) {\n\t\tif (locked == MBOX_THD_LOCKED)\n\t\t\t__lpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\telse\n\t\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\tkfree(mp);\n\t}\n\n\tmempool_free(mbox, phba->mbox_mem_pool);\n}\n\n \nint\nlpfc_dump_static_vport(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb,\n\t\tuint16_t offset)\n{\n\tMAILBOX_t *mb;\n\tstruct lpfc_dmabuf *mp;\n\tint rc;\n\n\tmb = &pmb->u.mb;\n\n\t \n\tmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\n\tmb->mbxCommand = MBX_DUMP_MEMORY;\n\tmb->un.varDmp.type = DMP_NV_PARAMS;\n\tmb->un.varDmp.entry_index = offset;\n\tmb->un.varDmp.region_id = DMP_REGION_VPORT;\n\tmb->mbxOwner = OWN_HOST;\n\n\t \n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\tmb->un.varDmp.cv = 1;\n\t\tmb->un.varDmp.word_cnt = DMP_RSP_SIZE/sizeof(uint32_t);\n\t\treturn 0;\n\t}\n\n\trc = lpfc_mbox_rsrc_prep(phba, pmb);\n\tif (rc) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\n\t\t\t\t\"2605 %s: memory allocation failed\\n\",\n\t\t\t\t__func__);\n\t\treturn 1;\n\t}\n\n\tmp = pmb->ctx_buf;\n\tmb->un.varWords[3] = putPaddrLow(mp->phys);\n\tmb->un.varWords[4] = putPaddrHigh(mp->phys);\n\tmb->un.varDmp.sli4_length = sizeof(struct static_vport_info);\n\n\treturn 0;\n}\n\n \nvoid\nlpfc_down_link(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb;\n\tmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\n\tmb = &pmb->u.mb;\n\tmb->mbxCommand = MBX_DOWN_LINK;\n\tmb->mbxOwner = OWN_HOST;\n}\n\n \nvoid\nlpfc_dump_mem(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb, uint16_t offset,\n\t\tuint16_t region_id)\n{\n\tMAILBOX_t *mb;\n\tvoid *ctx;\n\n\tmb = &pmb->u.mb;\n\tctx = pmb->ctx_buf;\n\n\t \n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\tmb->mbxCommand = MBX_DUMP_MEMORY;\n\tmb->un.varDmp.cv = 1;\n\tmb->un.varDmp.type = DMP_NV_PARAMS;\n\tmb->un.varDmp.entry_index = offset;\n\tmb->un.varDmp.region_id = region_id;\n\tmb->un.varDmp.word_cnt = (DMP_RSP_SIZE / sizeof (uint32_t));\n\tmb->un.varDmp.co = 0;\n\tmb->un.varDmp.resp_offset = 0;\n\tpmb->ctx_buf = ctx;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nvoid\nlpfc_dump_wakeup_param(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb;\n\tvoid *ctx;\n\n\tmb = &pmb->u.mb;\n\t \n\tctx = pmb->ctx_buf;\n\n\t \n\tmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\n\tmb->mbxCommand = MBX_DUMP_MEMORY;\n\tmb->mbxOwner = OWN_HOST;\n\tmb->un.varDmp.cv = 1;\n\tmb->un.varDmp.type = DMP_NV_PARAMS;\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tmb->un.varDmp.entry_index = 0;\n\tmb->un.varDmp.region_id = WAKE_UP_PARMS_REGION_ID;\n\tmb->un.varDmp.word_cnt = WAKE_UP_PARMS_WORD_SIZE;\n\tmb->un.varDmp.co = 0;\n\tmb->un.varDmp.resp_offset = 0;\n\tpmb->ctx_buf = ctx;\n\treturn;\n}\n\n \nvoid\nlpfc_read_nv(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\tmb->mbxCommand = MBX_READ_NV;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nvoid\nlpfc_config_async(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb,\n\t\tuint32_t ring)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\tmb->mbxCommand = MBX_ASYNCEVT_ENABLE;\n\tmb->un.varCfgAsyncEvent.ring = ring;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nvoid\nlpfc_heart_beat(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\tmb->mbxCommand = MBX_HEARTBEAT;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nint\nlpfc_read_topology(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb,\n\t\t   struct lpfc_dmabuf *mp)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tINIT_LIST_HEAD(&mp->list);\n\tmb->mbxCommand = MBX_READ_TOPOLOGY;\n\tmb->un.varReadTop.lilpBde64.tus.f.bdeSize = LPFC_ALPA_MAP_SIZE;\n\tmb->un.varReadTop.lilpBde64.addrHigh = putPaddrHigh(mp->phys);\n\tmb->un.varReadTop.lilpBde64.addrLow = putPaddrLow(mp->phys);\n\n\t \n\tpmb->ctx_buf = (uint8_t *)mp;\n\tmb->mbxOwner = OWN_HOST;\n\treturn (0);\n}\n\n \nvoid\nlpfc_clear_la(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tmb->un.varClearLA.eventTag = phba->fc_eventTag;\n\tmb->mbxCommand = MBX_CLEAR_LA;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nvoid\nlpfc_config_link(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\n{\n\tstruct lpfc_vport  *vport = phba->pport;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\t \n\tif (phba->cfg_cr_delay && (phba->sli_rev < LPFC_SLI_REV4)) {\n\t\tmb->un.varCfgLnk.cr = 1;\n\t\tmb->un.varCfgLnk.ci = 1;\n\t\tmb->un.varCfgLnk.cr_delay = phba->cfg_cr_delay;\n\t\tmb->un.varCfgLnk.cr_count = phba->cfg_cr_count;\n\t}\n\n\tmb->un.varCfgLnk.myId = vport->fc_myDID;\n\tmb->un.varCfgLnk.edtov = phba->fc_edtov;\n\tmb->un.varCfgLnk.arbtov = phba->fc_arbtov;\n\tmb->un.varCfgLnk.ratov = phba->fc_ratov;\n\tmb->un.varCfgLnk.rttov = phba->fc_rttov;\n\tmb->un.varCfgLnk.altov = phba->fc_altov;\n\tmb->un.varCfgLnk.crtov = phba->fc_crtov;\n\tmb->un.varCfgLnk.cscn = 0;\n\tif (phba->bbcredit_support && phba->cfg_enable_bbcr) {\n\t\tmb->un.varCfgLnk.cscn = 1;\n\t\tmb->un.varCfgLnk.bbscn = bf_get(lpfc_bbscn_def,\n\t\t\t\t\t\t &phba->sli4_hba.bbscn_params);\n\t}\n\n\tif (phba->cfg_ack0 && (phba->sli_rev < LPFC_SLI_REV4))\n\t\tmb->un.varCfgLnk.ack0_enable = 1;\n\n\tmb->mbxCommand = MBX_CONFIG_LINK;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nint\nlpfc_config_msi(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tuint32_t attentionConditions[2];\n\n\t \n\tif (phba->cfg_use_msi != 2) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0475 Not configured for supporting MSI-X \"\n\t\t\t\t\"cfg_use_msi: 0x%x\\n\", phba->cfg_use_msi);\n\t\treturn -EINVAL;\n\t}\n\n\tif (phba->sli_rev < 3) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0476 HBA not supporting SLI-3 or later \"\n\t\t\t\t\"SLI Revision: 0x%x\\n\", phba->sli_rev);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\n\n\t \n\n\t \n\tattentionConditions[0] = (HA_R0ATT | HA_R1ATT | HA_R2ATT | HA_ERATT |\n\t\t\t\t  HA_LATT | HA_MBATT);\n\tattentionConditions[1] = 0;\n\n\tmb->un.varCfgMSI.attentionConditions[0] = attentionConditions[0];\n\tmb->un.varCfgMSI.attentionConditions[1] = attentionConditions[1];\n\n\t \n#ifdef __BIG_ENDIAN_BITFIELD\n\t \n\tmb->un.varCfgMSI.messageNumberByHA[HA_R0_POS] = 1;\n\t \n\tmb->un.varCfgMSI.messageNumberByHA[HA_R1_POS] = 1;\n#else    \n\t \n\tmb->un.varCfgMSI.messageNumberByHA[HA_R0_POS^3] = 1;\n\t \n\tmb->un.varCfgMSI.messageNumberByHA[HA_R1_POS^3] = 1;\n#endif\n\t \n\tmb->un.varCfgMSI.autoClearHA[0] = attentionConditions[0];\n\tmb->un.varCfgMSI.autoClearHA[1] = attentionConditions[1];\n\n\t \n\tmb->un.varCfgMSI.autoClearHA[0] = 0;\n\tmb->un.varCfgMSI.autoClearHA[1] = 0;\n\n\t \n\tmb->mbxCommand = MBX_CONFIG_MSI;\n\tmb->mbxOwner = OWN_HOST;\n\n\treturn 0;\n}\n\n \nvoid\nlpfc_init_link(struct lpfc_hba * phba,\n\t       LPFC_MBOXQ_t * pmb, uint32_t topology, uint32_t linkspeed)\n{\n\tlpfc_vpd_t *vpd;\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tswitch (topology) {\n\tcase FLAGS_TOPOLOGY_MODE_LOOP_PT:\n\t\tmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_LOOP;\n\t\tmb->un.varInitLnk.link_flags |= FLAGS_TOPOLOGY_FAILOVER;\n\t\tbreak;\n\tcase FLAGS_TOPOLOGY_MODE_PT_PT:\n\t\tmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_PT_PT;\n\t\tbreak;\n\tcase FLAGS_TOPOLOGY_MODE_LOOP:\n\t\tmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_LOOP;\n\t\tbreak;\n\tcase FLAGS_TOPOLOGY_MODE_PT_LOOP:\n\t\tmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_PT_PT;\n\t\tmb->un.varInitLnk.link_flags |= FLAGS_TOPOLOGY_FAILOVER;\n\t\tbreak;\n\tcase FLAGS_LOCAL_LB:\n\t\tmb->un.varInitLnk.link_flags = FLAGS_LOCAL_LB;\n\t\tbreak;\n\t}\n\n\t \n\tif ((phba->sli4_hba.pc_sli4_params.sli_family == LPFC_SLI_INTF_FAMILY_G6 ||\n\t     phba->sli4_hba.pc_sli4_params.if_type == LPFC_SLI_INTF_IF_TYPE_6) &&\n\t    !(phba->sli4_hba.pc_sli4_params.pls) &&\n\t    mb->un.varInitLnk.link_flags & FLAGS_TOPOLOGY_MODE_LOOP) {\n\t\tmb->un.varInitLnk.link_flags = FLAGS_TOPOLOGY_MODE_PT_PT;\n\t\tphba->cfg_topology = FLAGS_TOPOLOGY_MODE_PT_PT;\n\t}\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV3 && !phba->cfg_fcp_wait_abts_rsp)\n\t\tmb->un.varInitLnk.link_flags |= FLAGS_IMED_ABORT;\n\n\t \n\tvpd = &phba->vpd;\n\tif (vpd->rev.feaLevelHigh >= 0x02){\n\t\tswitch(linkspeed){\n\t\tcase LPFC_USER_LINK_SPEED_1G:\n\t\t\tmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_1G;\n\t\t\tbreak;\n\t\tcase LPFC_USER_LINK_SPEED_2G:\n\t\t\tmb->un.varInitLnk.link_flags |=\tFLAGS_LINK_SPEED;\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_2G;\n\t\t\tbreak;\n\t\tcase LPFC_USER_LINK_SPEED_4G:\n\t\t\tmb->un.varInitLnk.link_flags |=\tFLAGS_LINK_SPEED;\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_4G;\n\t\t\tbreak;\n\t\tcase LPFC_USER_LINK_SPEED_8G:\n\t\t\tmb->un.varInitLnk.link_flags |=\tFLAGS_LINK_SPEED;\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_8G;\n\t\t\tbreak;\n\t\tcase LPFC_USER_LINK_SPEED_10G:\n\t\t\tmb->un.varInitLnk.link_flags |=\tFLAGS_LINK_SPEED;\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_10G;\n\t\t\tbreak;\n\t\tcase LPFC_USER_LINK_SPEED_16G:\n\t\t\tmb->un.varInitLnk.link_flags |=\tFLAGS_LINK_SPEED;\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_16G;\n\t\t\tbreak;\n\t\tcase LPFC_USER_LINK_SPEED_32G:\n\t\t\tmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_32G;\n\t\t\tbreak;\n\t\tcase LPFC_USER_LINK_SPEED_64G:\n\t\t\tmb->un.varInitLnk.link_flags |= FLAGS_LINK_SPEED;\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_64G;\n\t\t\tbreak;\n\t\tcase LPFC_USER_LINK_SPEED_AUTO:\n\t\tdefault:\n\t\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_AUTO;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\telse\n\t\tmb->un.varInitLnk.link_speed = LINK_SPEED_AUTO;\n\n\tmb->mbxCommand = (volatile uint8_t)MBX_INIT_LINK;\n\tmb->mbxOwner = OWN_HOST;\n\tmb->un.varInitLnk.fabric_AL_PA = phba->fc_pref_ALPA;\n\treturn;\n}\n\n \nint\nlpfc_read_sparam(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb, int vpi)\n{\n\tstruct lpfc_dmabuf *mp;\n\tMAILBOX_t *mb;\n\tint rc;\n\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\t \n\trc = lpfc_mbox_rsrc_prep(phba, pmb);\n\tif (rc) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\n\t\t\t        \"0301 READ_SPARAM: no buffers\\n\");\n\t\treturn 1;\n\t}\n\n\tmp = pmb->ctx_buf;\n\tmb = &pmb->u.mb;\n\tmb->mbxOwner = OWN_HOST;\n\tmb->mbxCommand = MBX_READ_SPARM64;\n\tmb->un.varRdSparm.un.sp64.tus.f.bdeSize = sizeof (struct serv_parm);\n\tmb->un.varRdSparm.un.sp64.addrHigh = putPaddrHigh(mp->phys);\n\tmb->un.varRdSparm.un.sp64.addrLow = putPaddrLow(mp->phys);\n\tif (phba->sli_rev >= LPFC_SLI_REV3)\n\t\tmb->un.varRdSparm.vpi = phba->vpi_ids[vpi];\n\n\treturn (0);\n}\n\n \nvoid\nlpfc_unreg_did(struct lpfc_hba * phba, uint16_t vpi, uint32_t did,\n\t       LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tmb->un.varUnregDID.did = did;\n\tmb->un.varUnregDID.vpi = vpi;\n\tif ((vpi != 0xffff) &&\n\t    (phba->sli_rev == LPFC_SLI_REV4))\n\t\tmb->un.varUnregDID.vpi = phba->vpi_ids[vpi];\n\n\tmb->mbxCommand = MBX_UNREG_D_ID;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nvoid\nlpfc_read_config(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tmb->mbxCommand = MBX_READ_CONFIG;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nvoid\nlpfc_read_lnk_stat(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tmb->mbxCommand = MBX_READ_LNK_STAT;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nint\nlpfc_reg_rpi(struct lpfc_hba *phba, uint16_t vpi, uint32_t did,\n\t     uint8_t *param, LPFC_MBOXQ_t *pmb, uint16_t rpi)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tuint8_t *sparam;\n\tstruct lpfc_dmabuf *mp;\n\tint rc;\n\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tmb->un.varRegLogin.rpi = 0;\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tmb->un.varRegLogin.rpi = phba->sli4_hba.rpi_ids[rpi];\n\tif (phba->sli_rev >= LPFC_SLI_REV3)\n\t\tmb->un.varRegLogin.vpi = phba->vpi_ids[vpi];\n\tmb->un.varRegLogin.did = did;\n\tmb->mbxOwner = OWN_HOST;\n\n\t \n\trc = lpfc_mbox_rsrc_prep(phba, pmb);\n\tif (rc) {\n\t\tmb->mbxCommand = MBX_REG_LOGIN64;\n\t\t \n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\n\t\t\t\t\"0302 REG_LOGIN: no buffers, VPI:%d DID:x%x, \"\n\t\t\t\t\"rpi x%x\\n\", vpi, did, rpi);\n\t\treturn 1;\n\t}\n\n\t \n\tmp = pmb->ctx_buf;\n\tsparam = mp->virt;\n\tmemcpy(sparam, param, sizeof (struct serv_parm));\n\n\t \n\tmb->mbxCommand = MBX_REG_LOGIN64;\n\tmb->un.varRegLogin.un.sp64.tus.f.bdeSize = sizeof (struct serv_parm);\n\tmb->un.varRegLogin.un.sp64.addrHigh = putPaddrHigh(mp->phys);\n\tmb->un.varRegLogin.un.sp64.addrLow = putPaddrLow(mp->phys);\n\n\treturn 0;\n}\n\n \nvoid\nlpfc_unreg_login(struct lpfc_hba *phba, uint16_t vpi, uint32_t rpi,\n\t\t LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb;\n\n\tmb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tmb->un.varUnregLogin.rpi = rpi;\n\tmb->un.varUnregLogin.rsvd1 = 0;\n\tif (phba->sli_rev >= LPFC_SLI_REV3)\n\t\tmb->un.varUnregLogin.vpi = phba->vpi_ids[vpi];\n\n\tmb->mbxCommand = MBX_UNREG_LOGIN;\n\tmb->mbxOwner = OWN_HOST;\n\n\treturn;\n}\n\n \nvoid\nlpfc_sli4_unreg_all_rpis(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba  = vport->phba;\n\tLPFC_MBOXQ_t     *mbox;\n\tint rc;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (mbox) {\n\t\t \n\t\tlpfc_unreg_login(phba, vport->vpi, phba->vpi_ids[vport->vpi],\n\t\t\t\t mbox);\n\t\tmbox->u.mb.un.varUnregLogin.rsvd1 = 0x4000;\n\t\tmbox->vport = vport;\n\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\tmbox->ctx_ndlp = NULL;\n\t\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\t\tif (rc == MBX_NOT_FINISHED)\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t}\n}\n\n \nvoid\nlpfc_reg_vpi(struct lpfc_vport *vport, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\t \n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI))\n\t\tmb->un.varRegVpi.upd = 1;\n\n\tmb->un.varRegVpi.vpi = phba->vpi_ids[vport->vpi];\n\tmb->un.varRegVpi.sid = vport->fc_myDID;\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tmb->un.varRegVpi.vfi = phba->sli4_hba.vfi_ids[vport->vfi];\n\telse\n\t\tmb->un.varRegVpi.vfi = vport->vfi + vport->phba->vfi_base;\n\tmemcpy(mb->un.varRegVpi.wwn, &vport->fc_portname,\n\t       sizeof(struct lpfc_name));\n\tmb->un.varRegVpi.wwn[0] = cpu_to_le32(mb->un.varRegVpi.wwn[0]);\n\tmb->un.varRegVpi.wwn[1] = cpu_to_le32(mb->un.varRegVpi.wwn[1]);\n\n\tmb->mbxCommand = MBX_REG_VPI;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n\n}\n\n \nvoid\nlpfc_unreg_vpi(struct lpfc_hba *phba, uint16_t vpi, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tif (phba->sli_rev == LPFC_SLI_REV3)\n\t\tmb->un.varUnregVpi.vpi = phba->vpi_ids[vpi];\n\telse if (phba->sli_rev >= LPFC_SLI_REV4)\n\t\tmb->un.varUnregVpi.sli4_vpi = phba->vpi_ids[vpi];\n\n\tmb->mbxCommand = MBX_UNREG_VPI;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n\n}\n\n \nstatic void\nlpfc_config_pcb_setup(struct lpfc_hba * phba)\n{\n\tstruct lpfc_sli *psli = &phba->sli;\n\tstruct lpfc_sli_ring *pring;\n\tPCB_t *pcbp = phba->pcb;\n\tdma_addr_t pdma_addr;\n\tuint32_t offset;\n\tuint32_t iocbCnt = 0;\n\tint i;\n\n\tpcbp->maxRing = (psli->num_rings - 1);\n\n\tfor (i = 0; i < psli->num_rings; i++) {\n\t\tpring = &psli->sli3_ring[i];\n\n\t\tpring->sli.sli3.sizeCiocb =\n\t\t\tphba->sli_rev == 3 ? SLI3_IOCB_CMD_SIZE :\n\t\t\t\t\t\t\tSLI2_IOCB_CMD_SIZE;\n\t\tpring->sli.sli3.sizeRiocb =\n\t\t\tphba->sli_rev == 3 ? SLI3_IOCB_RSP_SIZE :\n\t\t\t\t\t\t\tSLI2_IOCB_RSP_SIZE;\n\t\t \n\t\tif ((pring->sli.sli3.numCiocb == 0) ||\n\t\t\t(pring->sli.sli3.numRiocb == 0)) {\n\t\t\tpcbp->rdsc[i].cmdEntries = 0;\n\t\t\tpcbp->rdsc[i].rspEntries = 0;\n\t\t\tpcbp->rdsc[i].cmdAddrHigh = 0;\n\t\t\tpcbp->rdsc[i].rspAddrHigh = 0;\n\t\t\tpcbp->rdsc[i].cmdAddrLow = 0;\n\t\t\tpcbp->rdsc[i].rspAddrLow = 0;\n\t\t\tpring->sli.sli3.cmdringaddr = NULL;\n\t\t\tpring->sli.sli3.rspringaddr = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tpring->sli.sli3.cmdringaddr = (void *)&phba->IOCBs[iocbCnt];\n\t\tpcbp->rdsc[i].cmdEntries = pring->sli.sli3.numCiocb;\n\n\t\toffset = (uint8_t *) &phba->IOCBs[iocbCnt] -\n\t\t\t (uint8_t *) phba->slim2p.virt;\n\t\tpdma_addr = phba->slim2p.phys + offset;\n\t\tpcbp->rdsc[i].cmdAddrHigh = putPaddrHigh(pdma_addr);\n\t\tpcbp->rdsc[i].cmdAddrLow = putPaddrLow(pdma_addr);\n\t\tiocbCnt += pring->sli.sli3.numCiocb;\n\n\t\t \n\t\tpring->sli.sli3.rspringaddr = (void *) &phba->IOCBs[iocbCnt];\n\n\t\tpcbp->rdsc[i].rspEntries = pring->sli.sli3.numRiocb;\n\t\toffset = (uint8_t *)&phba->IOCBs[iocbCnt] -\n\t\t\t (uint8_t *)phba->slim2p.virt;\n\t\tpdma_addr = phba->slim2p.phys + offset;\n\t\tpcbp->rdsc[i].rspAddrHigh = putPaddrHigh(pdma_addr);\n\t\tpcbp->rdsc[i].rspAddrLow = putPaddrLow(pdma_addr);\n\t\tiocbCnt += pring->sli.sli3.numRiocb;\n\t}\n}\n\n \nvoid\nlpfc_read_rev(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\tmb->un.varRdRev.cv = 1;\n\tmb->un.varRdRev.v3req = 1;  \n\tmb->mbxCommand = MBX_READ_REV;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\nvoid\nlpfc_sli4_swap_str(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_mqe *mqe;\n\n\tswitch (mb->mbxCommand) {\n\tcase  MBX_READ_REV:\n\t\t mqe = &pmb->u.mqe;\n\t\tlpfc_sli_pcimem_bcopy(mqe->un.read_rev.fw_name,\n\t\t\t\t mqe->un.read_rev.fw_name, 16);\n\t\tlpfc_sli_pcimem_bcopy(mqe->un.read_rev.ulp_fw_name,\n\t\t\t\t mqe->un.read_rev.ulp_fw_name, 16);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn;\n}\n\n \nstatic void\nlpfc_build_hbq_profile2(struct config_hbq_var *hbqmb,\n\t\t\tstruct lpfc_hbq_init  *hbq_desc)\n{\n\thbqmb->profiles.profile2.seqlenbcnt = hbq_desc->seqlenbcnt;\n\thbqmb->profiles.profile2.maxlen     = hbq_desc->maxlen;\n\thbqmb->profiles.profile2.seqlenoff  = hbq_desc->seqlenoff;\n}\n\n \nstatic void\nlpfc_build_hbq_profile3(struct config_hbq_var *hbqmb,\n\t\t\tstruct lpfc_hbq_init  *hbq_desc)\n{\n\thbqmb->profiles.profile3.seqlenbcnt = hbq_desc->seqlenbcnt;\n\thbqmb->profiles.profile3.maxlen     = hbq_desc->maxlen;\n\thbqmb->profiles.profile3.cmdcodeoff = hbq_desc->cmdcodeoff;\n\thbqmb->profiles.profile3.seqlenoff  = hbq_desc->seqlenoff;\n\tmemcpy(&hbqmb->profiles.profile3.cmdmatch, hbq_desc->cmdmatch,\n\t       sizeof(hbqmb->profiles.profile3.cmdmatch));\n}\n\n \nstatic void\nlpfc_build_hbq_profile5(struct config_hbq_var *hbqmb,\n\t\t\tstruct lpfc_hbq_init  *hbq_desc)\n{\n\thbqmb->profiles.profile5.seqlenbcnt = hbq_desc->seqlenbcnt;\n\thbqmb->profiles.profile5.maxlen     = hbq_desc->maxlen;\n\thbqmb->profiles.profile5.cmdcodeoff = hbq_desc->cmdcodeoff;\n\thbqmb->profiles.profile5.seqlenoff  = hbq_desc->seqlenoff;\n\tmemcpy(&hbqmb->profiles.profile5.cmdmatch, hbq_desc->cmdmatch,\n\t       sizeof(hbqmb->profiles.profile5.cmdmatch));\n}\n\n \nvoid\nlpfc_config_hbq(struct lpfc_hba *phba, uint32_t id,\n\t\t struct lpfc_hbq_init *hbq_desc,\n\t\tuint32_t hbq_entry_index, LPFC_MBOXQ_t *pmb)\n{\n\tint i;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct config_hbq_var *hbqmb = &mb->un.varCfgHbq;\n\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\thbqmb->hbqId = id;\n\thbqmb->entry_count = hbq_desc->entry_count;    \n\thbqmb->recvNotify = hbq_desc->rn;              \n\thbqmb->numMask    = hbq_desc->mask_count;      \n\thbqmb->profile    = hbq_desc->profile;\t       \n\thbqmb->ringMask   = hbq_desc->ring_mask;       \n\thbqmb->headerLen  = hbq_desc->headerLen;       \n\thbqmb->logEntry   = hbq_desc->logEntry;        \n\thbqmb->hbqaddrLow = putPaddrLow(phba->hbqslimp.phys) +\n\t\thbq_entry_index * sizeof(struct lpfc_hbq_entry);\n\thbqmb->hbqaddrHigh = putPaddrHigh(phba->hbqslimp.phys);\n\n\tmb->mbxCommand = MBX_CONFIG_HBQ;\n\tmb->mbxOwner = OWN_HOST;\n\n\t\t\t\t \n\tif (hbq_desc->profile == 2)\n\t\tlpfc_build_hbq_profile2(hbqmb, hbq_desc);\n\telse if (hbq_desc->profile == 3)\n\t\tlpfc_build_hbq_profile3(hbqmb, hbq_desc);\n\telse if (hbq_desc->profile == 5)\n\t\tlpfc_build_hbq_profile5(hbqmb, hbq_desc);\n\n\t \n\tif (!hbq_desc->mask_count)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < hbq_desc->mask_count; i++) {\n\t\thbqmb->hbqMasks[i].tmatch = hbq_desc->hbqMasks[i].tmatch;\n\t\thbqmb->hbqMasks[i].tmask  = hbq_desc->hbqMasks[i].tmask;\n\t\thbqmb->hbqMasks[i].rctlmatch = hbq_desc->hbqMasks[i].rctlmatch;\n\t\thbqmb->hbqMasks[i].rctlmask  = hbq_desc->hbqMasks[i].rctlmask;\n\t}\n\n\treturn;\n}\n\n \nvoid\nlpfc_config_ring(struct lpfc_hba * phba, int ring, LPFC_MBOXQ_t * pmb)\n{\n\tint i;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tstruct lpfc_sli *psli;\n\tstruct lpfc_sli_ring *pring;\n\n\tmemset(pmb, 0, sizeof (LPFC_MBOXQ_t));\n\n\tmb->un.varCfgRing.ring = ring;\n\tmb->un.varCfgRing.maxOrigXchg = 0;\n\tmb->un.varCfgRing.maxRespXchg = 0;\n\tmb->un.varCfgRing.recvNotify = 1;\n\n\tpsli = &phba->sli;\n\tpring = &psli->sli3_ring[ring];\n\tmb->un.varCfgRing.numMask = pring->num_mask;\n\tmb->mbxCommand = MBX_CONFIG_RING;\n\tmb->mbxOwner = OWN_HOST;\n\n\t \n\tif (pring->prt[0].profile) {\n\t\tmb->un.varCfgRing.profile = pring->prt[0].profile;\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < pring->num_mask; i++) {\n\t\tmb->un.varCfgRing.rrRegs[i].rval = pring->prt[i].rctl;\n\t\tif (mb->un.varCfgRing.rrRegs[i].rval != FC_RCTL_ELS_REQ)\n\t\t\tmb->un.varCfgRing.rrRegs[i].rmask = 0xff;\n\t\telse\n\t\t\tmb->un.varCfgRing.rrRegs[i].rmask = 0xfe;\n\t\tmb->un.varCfgRing.rrRegs[i].tval = pring->prt[i].type;\n\t\tmb->un.varCfgRing.rrRegs[i].tmask = 0xff;\n\t}\n\n\treturn;\n}\n\n \nvoid\nlpfc_config_port(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t __iomem *mb_slim = (MAILBOX_t __iomem *) phba->MBslimaddr;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tdma_addr_t pdma_addr;\n\tuint32_t bar_low, bar_high;\n\tsize_t offset;\n\tstruct lpfc_hgp hgp;\n\tint i;\n\tuint32_t pgp_offset;\n\n\tmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\n\tmb->mbxCommand = MBX_CONFIG_PORT;\n\tmb->mbxOwner = OWN_HOST;\n\n\tmb->un.varCfgPort.pcbLen = sizeof(PCB_t);\n\n\toffset = (uint8_t *)phba->pcb - (uint8_t *)phba->slim2p.virt;\n\tpdma_addr = phba->slim2p.phys + offset;\n\tmb->un.varCfgPort.pcbLow = putPaddrLow(pdma_addr);\n\tmb->un.varCfgPort.pcbHigh = putPaddrHigh(pdma_addr);\n\n\t \n\tmb->un.varCfgPort.hps = 1;\n\n\t \n\n\tif (phba->sli_rev == LPFC_SLI_REV3 && phba->vpd.sli3Feat.cerbm) {\n\t\tif (phba->cfg_enable_bg)\n\t\t\tmb->un.varCfgPort.cbg = 1;  \n\t\tmb->un.varCfgPort.cerbm = 1;  \n\t\tmb->un.varCfgPort.ccrp = 1;  \n\t\tmb->un.varCfgPort.max_hbq = lpfc_sli_hbq_count();\n\t\tif (phba->max_vpi && phba->cfg_enable_npiv &&\n\t\t    phba->vpd.sli3Feat.cmv) {\n\t\t\tmb->un.varCfgPort.max_vpi = LPFC_MAX_VPI;\n\t\t\tmb->un.varCfgPort.cmv = 1;\n\t\t} else\n\t\t\tmb->un.varCfgPort.max_vpi = phba->max_vpi = 0;\n\t} else\n\t\tphba->sli_rev = LPFC_SLI_REV2;\n\tmb->un.varCfgPort.sli_mode = phba->sli_rev;\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV3)\n\t\tmb->un.varCfgPort.casabt = 1;\n\n\t \n\tphba->pcb->type = TYPE_NATIVE_SLI2;\n\tphba->pcb->feature = FEATURE_INITIAL_SLI2;\n\n\t \n\tphba->pcb->mailBoxSize = sizeof(MAILBOX_t) + MAILBOX_EXT_SIZE;\n\toffset = (uint8_t *)phba->mbox - (uint8_t *)phba->slim2p.virt;\n\tpdma_addr = phba->slim2p.phys + offset;\n\tphba->pcb->mbAddrHigh = putPaddrHigh(pdma_addr);\n\tphba->pcb->mbAddrLow = putPaddrLow(pdma_addr);\n\n\t \n\n\n\tpci_read_config_dword(phba->pcidev, PCI_BASE_ADDRESS_0, &bar_low);\n\tpci_read_config_dword(phba->pcidev, PCI_BASE_ADDRESS_1, &bar_high);\n\n\t \n\n\tif (phba->cfg_hostmem_hgp && phba->sli_rev != 3) {\n\t\tphba->host_gp = (struct lpfc_hgp __iomem *)\n\t\t\t\t &phba->mbox->us.s2.host[0];\n\t\tphba->hbq_put = NULL;\n\t\toffset = (uint8_t *)&phba->mbox->us.s2.host -\n\t\t\t(uint8_t *)phba->slim2p.virt;\n\t\tpdma_addr = phba->slim2p.phys + offset;\n\t\tphba->pcb->hgpAddrHigh = putPaddrHigh(pdma_addr);\n\t\tphba->pcb->hgpAddrLow = putPaddrLow(pdma_addr);\n\t} else {\n\t\t \n\t\tmb->un.varCfgPort.hps = 1;\n\n\t\tif (phba->sli_rev == 3) {\n\t\t\tphba->host_gp = &mb_slim->us.s3.host[0];\n\t\t\tphba->hbq_put = &mb_slim->us.s3.hbq_put[0];\n\t\t} else {\n\t\t\tphba->host_gp = &mb_slim->us.s2.host[0];\n\t\t\tphba->hbq_put = NULL;\n\t\t}\n\n\t\t \n\t\tphba->pcb->hgpAddrLow = (bar_low & PCI_BASE_ADDRESS_MEM_MASK) +\n\t\t\t(void __iomem *)phba->host_gp -\n\t\t\t(void __iomem *)phba->MBslimaddr;\n\t\tif (bar_low & PCI_BASE_ADDRESS_MEM_TYPE_64)\n\t\t\tphba->pcb->hgpAddrHigh = bar_high;\n\t\telse\n\t\t\tphba->pcb->hgpAddrHigh = 0;\n\t\t \n\t\tmemset(&hgp, 0, sizeof(struct lpfc_hgp));\n\n\t\tfor (i = 0; i < phba->sli.num_rings; i++) {\n\t\t\tlpfc_memcpy_to_slim(phba->host_gp + i, &hgp,\n\t\t\t\t    sizeof(*phba->host_gp));\n\t\t}\n\t}\n\n\t \n\tif (phba->sli_rev == 3)\n\t\tpgp_offset = offsetof(struct lpfc_sli2_slim,\n\t\t\t\t      mbx.us.s3_pgp.port);\n\telse\n\t\tpgp_offset = offsetof(struct lpfc_sli2_slim, mbx.us.s2.port);\n\tpdma_addr = phba->slim2p.phys + pgp_offset;\n\tphba->pcb->pgpAddrHigh = putPaddrHigh(pdma_addr);\n\tphba->pcb->pgpAddrLow = putPaddrLow(pdma_addr);\n\n\t \n\tlpfc_config_pcb_setup(phba);\n\n\t \n\tif (lpfc_is_LC_HBA(phba->pcidev->device)) {\n\t\tuint32_t hbainit[5];\n\n\t\tlpfc_hba_init(phba, hbainit);\n\n\t\tmemcpy(&mb->un.varCfgPort.hbainit, hbainit, 20);\n\t}\n\n\t \n\tlpfc_sli_pcimem_bcopy(phba->pcb, phba->pcb, sizeof(PCB_t));\n}\n\n \nvoid\nlpfc_kill_board(struct lpfc_hba * phba, LPFC_MBOXQ_t * pmb)\n{\n\tMAILBOX_t *mb = &pmb->u.mb;\n\n\tmemset(pmb, 0, sizeof(LPFC_MBOXQ_t));\n\tmb->mbxCommand = MBX_KILL_BOARD;\n\tmb->mbxOwner = OWN_HOST;\n\treturn;\n}\n\n \nvoid\nlpfc_mbox_put(struct lpfc_hba * phba, LPFC_MBOXQ_t * mbq)\n{\n\tstruct lpfc_sli *psli;\n\n\tpsli = &phba->sli;\n\n\tlist_add_tail(&mbq->list, &psli->mboxq);\n\n\tpsli->mboxq_cnt++;\n\n\treturn;\n}\n\n \nLPFC_MBOXQ_t *\nlpfc_mbox_get(struct lpfc_hba * phba)\n{\n\tLPFC_MBOXQ_t *mbq = NULL;\n\tstruct lpfc_sli *psli = &phba->sli;\n\n\tlist_remove_head((&psli->mboxq), mbq, LPFC_MBOXQ_t, list);\n\tif (mbq)\n\t\tpsli->mboxq_cnt--;\n\n\treturn mbq;\n}\n\n \nvoid\n__lpfc_mbox_cmpl_put(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbq)\n{\n\tlist_add_tail(&mbq->list, &phba->sli.mboxq_cmpl);\n}\n\n \nvoid\nlpfc_mbox_cmpl_put(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbq)\n{\n\tunsigned long iflag;\n\n\t \n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\t__lpfc_mbox_cmpl_put(phba, mbq);\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\treturn;\n}\n\n \nint\nlpfc_mbox_cmd_check(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\t \n\tif (mboxq->mbox_cmpl && mboxq->mbox_cmpl != lpfc_sli_def_mbox_cmpl &&\n\t    mboxq->mbox_cmpl != lpfc_sli_wake_mbox_wait) {\n\t\tif (!mboxq->vport) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_VPORT,\n\t\t\t\t\t\"1814 Mbox x%x failed, no vport\\n\",\n\t\t\t\t\tmboxq->u.mb.mbxCommand);\n\t\t\tdump_stack();\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint\nlpfc_mbox_dev_check(struct lpfc_hba *phba)\n{\n\t \n\tif (unlikely(pci_channel_offline(phba->pcidev)))\n\t\treturn -ENODEV;\n\n\t \n\tif (phba->link_state == LPFC_HBA_ERROR)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nint\nlpfc_mbox_tmo_val(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tMAILBOX_t *mbox = &mboxq->u.mb;\n\tuint8_t subsys, opcode;\n\n\tswitch (mbox->mbxCommand) {\n\tcase MBX_WRITE_NV:\t \n\tcase MBX_DUMP_MEMORY:\t \n\tcase MBX_UPDATE_CFG:\t \n\tcase MBX_DOWN_LOAD:\t \n\tcase MBX_DEL_LD_ENTRY:\t \n\tcase MBX_WRITE_VPARMS:\t \n\tcase MBX_LOAD_AREA:\t \n\tcase MBX_WRITE_WWN:      \n\tcase MBX_LOAD_EXP_ROM:\t \n\tcase MBX_ACCESS_VDATA:\t \n\t\treturn LPFC_MBOX_TMO_FLASH_CMD;\n\tcase MBX_SLI4_CONFIG:\t \n\t\tsubsys = lpfc_sli_config_mbox_subsys_get(phba, mboxq);\n\t\topcode = lpfc_sli_config_mbox_opcode_get(phba, mboxq);\n\t\tif (subsys == LPFC_MBOX_SUBSYSTEM_COMMON) {\n\t\t\tswitch (opcode) {\n\t\t\tcase LPFC_MBOX_OPCODE_READ_OBJECT:\n\t\t\tcase LPFC_MBOX_OPCODE_WRITE_OBJECT:\n\t\t\tcase LPFC_MBOX_OPCODE_READ_OBJECT_LIST:\n\t\t\tcase LPFC_MBOX_OPCODE_DELETE_OBJECT:\n\t\t\tcase LPFC_MBOX_OPCODE_GET_PROFILE_LIST:\n\t\t\tcase LPFC_MBOX_OPCODE_SET_ACT_PROFILE:\n\t\t\tcase LPFC_MBOX_OPCODE_GET_PROFILE_CONFIG:\n\t\t\tcase LPFC_MBOX_OPCODE_SET_PROFILE_CONFIG:\n\t\t\tcase LPFC_MBOX_OPCODE_GET_FACTORY_PROFILE_CONFIG:\n\t\t\tcase LPFC_MBOX_OPCODE_GET_PROFILE_CAPACITIES:\n\t\t\tcase LPFC_MBOX_OPCODE_SEND_ACTIVATION:\n\t\t\tcase LPFC_MBOX_OPCODE_RESET_LICENSES:\n\t\t\tcase LPFC_MBOX_OPCODE_SET_BOOT_CONFIG:\n\t\t\tcase LPFC_MBOX_OPCODE_GET_VPD_DATA:\n\t\t\tcase LPFC_MBOX_OPCODE_SET_PHYSICAL_LINK_CONFIG:\n\t\t\t\treturn LPFC_MBOX_SLI4_CONFIG_EXTENDED_TMO;\n\t\t\t}\n\t\t}\n\t\tif (subsys == LPFC_MBOX_SUBSYSTEM_FCOE) {\n\t\t\tswitch (opcode) {\n\t\t\tcase LPFC_MBOX_OPCODE_FCOE_SET_FCLINK_SETTINGS:\n\t\t\t\treturn LPFC_MBOX_SLI4_CONFIG_EXTENDED_TMO;\n\t\t\t}\n\t\t}\n\t\treturn LPFC_MBOX_SLI4_CONFIG_TMO;\n\t}\n\treturn LPFC_MBOX_TMO;\n}\n\n \nvoid\nlpfc_sli4_mbx_sge_set(struct lpfcMboxq *mbox, uint32_t sgentry,\n\t\t      dma_addr_t phyaddr, uint32_t length)\n{\n\tstruct lpfc_mbx_nembed_cmd *nembed_sge;\n\n\tnembed_sge = (struct lpfc_mbx_nembed_cmd *)\n\t\t\t\t&mbox->u.mqe.un.nembed_cmd;\n\tnembed_sge->sge[sgentry].pa_lo = putPaddrLow(phyaddr);\n\tnembed_sge->sge[sgentry].pa_hi = putPaddrHigh(phyaddr);\n\tnembed_sge->sge[sgentry].length = length;\n}\n\n \nvoid\nlpfc_sli4_mbx_sge_get(struct lpfcMboxq *mbox, uint32_t sgentry,\n\t\t      struct lpfc_mbx_sge *sge)\n{\n\tstruct lpfc_mbx_nembed_cmd *nembed_sge;\n\n\tnembed_sge = (struct lpfc_mbx_nembed_cmd *)\n\t\t\t\t&mbox->u.mqe.un.nembed_cmd;\n\tsge->pa_lo = nembed_sge->sge[sgentry].pa_lo;\n\tsge->pa_hi = nembed_sge->sge[sgentry].pa_hi;\n\tsge->length = nembed_sge->sge[sgentry].length;\n}\n\n \nvoid\nlpfc_sli4_mbox_cmd_free(struct lpfc_hba *phba, struct lpfcMboxq *mbox)\n{\n\tstruct lpfc_mbx_sli4_config *sli4_cfg;\n\tstruct lpfc_mbx_sge sge;\n\tdma_addr_t phyaddr;\n\tuint32_t sgecount, sgentry;\n\n\tsli4_cfg = &mbox->u.mqe.un.sli4_config;\n\n\t \n\tif (bf_get(lpfc_mbox_hdr_emb, &sli4_cfg->header.cfg_mhdr)) {\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\n\t \n\tsgecount = bf_get(lpfc_mbox_hdr_sge_cnt, &sli4_cfg->header.cfg_mhdr);\n\t \n\tif (unlikely(!mbox->sge_array)) {\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\t \n\tfor (sgentry = 0; sgentry < sgecount; sgentry++) {\n\t\tlpfc_sli4_mbx_sge_get(mbox, sgentry, &sge);\n\t\tphyaddr = getPaddr(sge.pa_hi, sge.pa_lo);\n\t\tdma_free_coherent(&phba->pcidev->dev, SLI4_PAGE_SIZE,\n\t\t\t\t  mbox->sge_array->addr[sgentry], phyaddr);\n\t}\n\t \n\tkfree(mbox->sge_array);\n\t \n\tmempool_free(mbox, phba->mbox_mem_pool);\n}\n\n \nint\nlpfc_sli4_config(struct lpfc_hba *phba, struct lpfcMboxq *mbox,\n\t\t uint8_t subsystem, uint8_t opcode, uint32_t length, bool emb)\n{\n\tstruct lpfc_mbx_sli4_config *sli4_config;\n\tunion lpfc_sli4_cfg_shdr *cfg_shdr = NULL;\n\tuint32_t alloc_len;\n\tuint32_t resid_len;\n\tuint32_t pagen, pcount;\n\tvoid *viraddr;\n\tdma_addr_t phyaddr;\n\n\t \n\tmemset(mbox, 0, sizeof(*mbox));\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_SLI4_CONFIG);\n\n\t \n\tsli4_config = &mbox->u.mqe.un.sli4_config;\n\n\t \n\tif (emb) {\n\t\t \n\t\tbf_set(lpfc_mbox_hdr_emb, &sli4_config->header.cfg_mhdr, 1);\n\t\tsli4_config->header.cfg_mhdr.payload_length = length;\n\t\t \n\t\tbf_set(lpfc_mbox_hdr_opcode,\n\t\t\t&sli4_config->header.cfg_shdr.request, opcode);\n\t\tbf_set(lpfc_mbox_hdr_subsystem,\n\t\t\t&sli4_config->header.cfg_shdr.request, subsystem);\n\t\tsli4_config->header.cfg_shdr.request.request_length =\n\t\t\tlength - LPFC_MBX_CMD_HDR_LENGTH;\n\t\treturn length;\n\t}\n\n\t \n\tpcount = (SLI4_PAGE_ALIGN(length))/SLI4_PAGE_SIZE;\n\tpcount = (pcount > LPFC_SLI4_MBX_SGE_MAX_PAGES) ?\n\t\t\t\tLPFC_SLI4_MBX_SGE_MAX_PAGES : pcount;\n\t \n\tmbox->sge_array = kzalloc(sizeof(struct lpfc_mbx_nembed_sge_virt),\n\t\t\t\t  GFP_KERNEL);\n\tif (!mbox->sge_array) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\n\t\t\t\t\"2527 Failed to allocate non-embedded SGE \"\n\t\t\t\t\"array.\\n\");\n\t\treturn 0;\n\t}\n\tfor (pagen = 0, alloc_len = 0; pagen < pcount; pagen++) {\n\t\t \n\t\tviraddr = dma_alloc_coherent(&phba->pcidev->dev,\n\t\t\t\t\t     SLI4_PAGE_SIZE, &phyaddr,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t \n\t\tif (!viraddr)\n\t\t\tbreak;\n\t\tmbox->sge_array->addr[pagen] = viraddr;\n\t\t \n\t\tif (pagen == 0)\n\t\t\tcfg_shdr = (union lpfc_sli4_cfg_shdr *)viraddr;\n\t\tresid_len = length - alloc_len;\n\t\tif (resid_len > SLI4_PAGE_SIZE) {\n\t\t\tlpfc_sli4_mbx_sge_set(mbox, pagen, phyaddr,\n\t\t\t\t\t      SLI4_PAGE_SIZE);\n\t\t\talloc_len += SLI4_PAGE_SIZE;\n\t\t} else {\n\t\t\tlpfc_sli4_mbx_sge_set(mbox, pagen, phyaddr,\n\t\t\t\t\t      resid_len);\n\t\t\talloc_len = length;\n\t\t}\n\t}\n\n\t \n\tsli4_config->header.cfg_mhdr.payload_length = alloc_len;\n\tbf_set(lpfc_mbox_hdr_sge_cnt, &sli4_config->header.cfg_mhdr, pagen);\n\n\t \n\tif (pagen > 0) {\n\t\tbf_set(lpfc_mbox_hdr_opcode, &cfg_shdr->request, opcode);\n\t\tbf_set(lpfc_mbox_hdr_subsystem, &cfg_shdr->request, subsystem);\n\t\tcfg_shdr->request.request_length =\n\t\t\t\talloc_len - sizeof(union  lpfc_sli4_cfg_shdr);\n\t}\n\t \n\tif (cfg_shdr)\n\t\tlpfc_sli_pcimem_bcopy(cfg_shdr, cfg_shdr,\n\t\t\t\t      sizeof(union  lpfc_sli4_cfg_shdr));\n\treturn alloc_len;\n}\n\n \nint\nlpfc_sli4_mbox_rsrc_extent(struct lpfc_hba *phba, struct lpfcMboxq *mbox,\n\t\t\t   uint16_t exts_count, uint16_t rsrc_type, bool emb)\n{\n\tuint8_t opcode = 0;\n\tstruct lpfc_mbx_nembed_rsrc_extent *n_rsrc_extnt = NULL;\n\tvoid *virtaddr = NULL;\n\n\t \n\tif (emb == LPFC_SLI4_MBX_NEMBED) {\n\t\t \n\t\tvirtaddr = mbox->sge_array->addr[0];\n\t\tif (virtaddr == NULL)\n\t\t\treturn 1;\n\t\tn_rsrc_extnt = (struct lpfc_mbx_nembed_rsrc_extent *) virtaddr;\n\t}\n\n\t \n\tif (emb == LPFC_SLI4_MBX_EMBED)\n\t\tbf_set(lpfc_mbx_alloc_rsrc_extents_type,\n\t\t       &mbox->u.mqe.un.alloc_rsrc_extents.u.req,\n\t\t       rsrc_type);\n\telse {\n\t\t \n\t\tbf_set(lpfc_mbx_alloc_rsrc_extents_type,\n\t\t       n_rsrc_extnt, rsrc_type);\n\t\tlpfc_sli_pcimem_bcopy(&n_rsrc_extnt->word4,\n\t\t\t\t      &n_rsrc_extnt->word4,\n\t\t\t\t      sizeof(uint32_t));\n\t}\n\n\t \n\topcode = lpfc_sli_config_mbox_opcode_get(phba, mbox);\n\tswitch (opcode) {\n\tcase LPFC_MBOX_OPCODE_ALLOC_RSRC_EXTENT:\n\t\tif (emb == LPFC_SLI4_MBX_EMBED)\n\t\t\tbf_set(lpfc_mbx_alloc_rsrc_extents_cnt,\n\t\t\t       &mbox->u.mqe.un.alloc_rsrc_extents.u.req,\n\t\t\t       exts_count);\n\t\telse\n\t\t\tbf_set(lpfc_mbx_alloc_rsrc_extents_cnt,\n\t\t\t       n_rsrc_extnt, exts_count);\n\t\tbreak;\n\tcase LPFC_MBOX_OPCODE_GET_ALLOC_RSRC_EXTENT:\n\tcase LPFC_MBOX_OPCODE_GET_RSRC_EXTENT_INFO:\n\tcase LPFC_MBOX_OPCODE_DEALLOC_RSRC_EXTENT:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\n\t\t\t\t\"2929 Resource Extent Opcode x%x is \"\n\t\t\t\t\"unsupported\\n\", opcode);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nuint8_t\nlpfc_sli_config_mbox_subsys_get(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbox)\n{\n\tstruct lpfc_mbx_sli4_config *sli4_cfg;\n\tunion lpfc_sli4_cfg_shdr *cfg_shdr;\n\n\tif (mbox->u.mb.mbxCommand != MBX_SLI4_CONFIG)\n\t\treturn LPFC_MBOX_SUBSYSTEM_NA;\n\tsli4_cfg = &mbox->u.mqe.un.sli4_config;\n\n\t \n\tif (bf_get(lpfc_mbox_hdr_emb, &sli4_cfg->header.cfg_mhdr)) {\n\t\tcfg_shdr = &mbox->u.mqe.un.sli4_config.header.cfg_shdr;\n\t\treturn bf_get(lpfc_mbox_hdr_subsystem, &cfg_shdr->request);\n\t}\n\n\t \n\tif (unlikely(!mbox->sge_array))\n\t\treturn LPFC_MBOX_SUBSYSTEM_NA;\n\tcfg_shdr = (union lpfc_sli4_cfg_shdr *)mbox->sge_array->addr[0];\n\treturn bf_get(lpfc_mbox_hdr_subsystem, &cfg_shdr->request);\n}\n\n \nuint8_t\nlpfc_sli_config_mbox_opcode_get(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbox)\n{\n\tstruct lpfc_mbx_sli4_config *sli4_cfg;\n\tunion lpfc_sli4_cfg_shdr *cfg_shdr;\n\n\tif (mbox->u.mb.mbxCommand != MBX_SLI4_CONFIG)\n\t\treturn LPFC_MBOX_OPCODE_NA;\n\tsli4_cfg = &mbox->u.mqe.un.sli4_config;\n\n\t \n\tif (bf_get(lpfc_mbox_hdr_emb, &sli4_cfg->header.cfg_mhdr)) {\n\t\tcfg_shdr = &mbox->u.mqe.un.sli4_config.header.cfg_shdr;\n\t\treturn bf_get(lpfc_mbox_hdr_opcode, &cfg_shdr->request);\n\t}\n\n\t \n\tif (unlikely(!mbox->sge_array))\n\t\treturn LPFC_MBOX_OPCODE_NA;\n\tcfg_shdr = (union lpfc_sli4_cfg_shdr *)mbox->sge_array->addr[0];\n\treturn bf_get(lpfc_mbox_hdr_opcode, &cfg_shdr->request);\n}\n\n \nint\nlpfc_sli4_mbx_read_fcf_rec(struct lpfc_hba *phba,\n\t\t\t   struct lpfcMboxq *mboxq,\n\t\t\t   uint16_t fcf_index)\n{\n\tvoid *virt_addr;\n\tuint8_t *bytep;\n\tstruct lpfc_mbx_sge sge;\n\tuint32_t alloc_len, req_len;\n\tstruct lpfc_mbx_read_fcf_tbl *read_fcf;\n\n\tif (!mboxq)\n\t\treturn -ENOMEM;\n\n\treq_len = sizeof(struct fcf_record) +\n\t\t  sizeof(union lpfc_sli4_cfg_shdr) + 2 * sizeof(uint32_t);\n\n\t \n\talloc_len = lpfc_sli4_config(phba, mboxq, LPFC_MBOX_SUBSYSTEM_FCOE,\n\t\t\tLPFC_MBOX_OPCODE_FCOE_READ_FCF_TABLE, req_len,\n\t\t\tLPFC_SLI4_MBX_NEMBED);\n\n\tif (alloc_len < req_len) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\n\t\t\t\t\"0291 Allocated DMA memory size (x%x) is \"\n\t\t\t\t\"less than the requested DMA memory \"\n\t\t\t\t\"size (x%x)\\n\", alloc_len, req_len);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tlpfc_sli4_mbx_sge_get(mboxq, 0, &sge);\n\tvirt_addr = mboxq->sge_array->addr[0];\n\tread_fcf = (struct lpfc_mbx_read_fcf_tbl *)virt_addr;\n\n\t \n\tbf_set(lpfc_mbx_read_fcf_tbl_indx, &read_fcf->u.request, fcf_index);\n\t \n\tbytep = virt_addr + sizeof(union lpfc_sli4_cfg_shdr);\n\tlpfc_sli_pcimem_bcopy(bytep, bytep, sizeof(uint32_t));\n\n\treturn 0;\n}\n\n \nvoid\nlpfc_request_features(struct lpfc_hba *phba, struct lpfcMboxq *mboxq)\n{\n\t \n\tmemset(mboxq, 0, sizeof(LPFC_MBOXQ_t));\n\tbf_set(lpfc_mqe_command, &mboxq->u.mqe, MBX_SLI4_REQ_FTRS);\n\n\t \n\tbf_set(lpfc_mbx_rq_ftr_rq_fcpi, &mboxq->u.mqe.un.req_ftrs, 1);\n\tbf_set(lpfc_mbx_rq_ftr_rq_perfh, &mboxq->u.mqe.un.req_ftrs, 1);\n\n\t \n\tif (phba->cfg_enable_bg)\n\t\tbf_set(lpfc_mbx_rq_ftr_rq_dif, &mboxq->u.mqe.un.req_ftrs, 1);\n\n\t \n\tif (phba->max_vpi && phba->cfg_enable_npiv)\n\t\tbf_set(lpfc_mbx_rq_ftr_rq_npiv, &mboxq->u.mqe.un.req_ftrs, 1);\n\n\tif (phba->nvmet_support) {\n\t\tbf_set(lpfc_mbx_rq_ftr_rq_mrqp, &mboxq->u.mqe.un.req_ftrs, 1);\n\t\t \n\t\tbf_set(lpfc_mbx_rq_ftr_rq_iaab, &mboxq->u.mqe.un.req_ftrs, 0);\n\t\tbf_set(lpfc_mbx_rq_ftr_rq_iaar, &mboxq->u.mqe.un.req_ftrs, 0);\n\t}\n\n\t \n\tif (phba->cfg_vmid_app_header) {\n\t\tbf_set(lpfc_mbx_rq_ftr_rq_ashdr, &mboxq->u.mqe.un.req_ftrs, 1);\n\t\tbf_set(lpfc_ftr_ashdr, &phba->sli4_hba.sli4_flags, 1);\n\t}\n\treturn;\n}\n\n \nvoid\nlpfc_init_vfi(struct lpfcMboxq *mbox, struct lpfc_vport *vport)\n{\n\tstruct lpfc_mbx_init_vfi *init_vfi;\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\tmbox->vport = vport;\n\tinit_vfi = &mbox->u.mqe.un.init_vfi;\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_INIT_VFI);\n\tbf_set(lpfc_init_vfi_vr, init_vfi, 1);\n\tbf_set(lpfc_init_vfi_vt, init_vfi, 1);\n\tbf_set(lpfc_init_vfi_vp, init_vfi, 1);\n\tbf_set(lpfc_init_vfi_vfi, init_vfi,\n\t       vport->phba->sli4_hba.vfi_ids[vport->vfi]);\n\tbf_set(lpfc_init_vfi_vpi, init_vfi,\n\t       vport->phba->vpi_ids[vport->vpi]);\n\tbf_set(lpfc_init_vfi_fcfi, init_vfi,\n\t       vport->phba->fcf.fcfi);\n}\n\n \nvoid\nlpfc_reg_vfi(struct lpfcMboxq *mbox, struct lpfc_vport *vport, dma_addr_t phys)\n{\n\tstruct lpfc_mbx_reg_vfi *reg_vfi;\n\tstruct lpfc_hba *phba = vport->phba;\n\tuint8_t bbscn_fabric = 0, bbscn_max = 0, bbscn_def = 0;\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\treg_vfi = &mbox->u.mqe.un.reg_vfi;\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_REG_VFI);\n\tbf_set(lpfc_reg_vfi_vp, reg_vfi, 1);\n\tbf_set(lpfc_reg_vfi_vfi, reg_vfi,\n\t       phba->sli4_hba.vfi_ids[vport->vfi]);\n\tbf_set(lpfc_reg_vfi_fcfi, reg_vfi, phba->fcf.fcfi);\n\tbf_set(lpfc_reg_vfi_vpi, reg_vfi, phba->vpi_ids[vport->vpi]);\n\tmemcpy(reg_vfi->wwn, &vport->fc_portname, sizeof(struct lpfc_name));\n\treg_vfi->wwn[0] = cpu_to_le32(reg_vfi->wwn[0]);\n\treg_vfi->wwn[1] = cpu_to_le32(reg_vfi->wwn[1]);\n\treg_vfi->e_d_tov = phba->fc_edtov;\n\treg_vfi->r_a_tov = phba->fc_ratov;\n\tif (phys) {\n\t\treg_vfi->bde.addrHigh = putPaddrHigh(phys);\n\t\treg_vfi->bde.addrLow = putPaddrLow(phys);\n\t\treg_vfi->bde.tus.f.bdeSize = sizeof(vport->fc_sparam);\n\t\treg_vfi->bde.tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t}\n\tbf_set(lpfc_reg_vfi_nport_id, reg_vfi, vport->fc_myDID);\n\n\t \n\tif ((phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_FC) &&\n\t    (vport->fc_flag & FC_VFI_REGISTERED) &&\n\t    (!phba->fc_topology_changed))\n\t\tbf_set(lpfc_reg_vfi_upd, reg_vfi, 1);\n\n\tbf_set(lpfc_reg_vfi_bbcr, reg_vfi, 0);\n\tbf_set(lpfc_reg_vfi_bbscn, reg_vfi, 0);\n\tbbscn_fabric = (phba->fc_fabparam.cmn.bbRcvSizeMsb >> 4) & 0xF;\n\n\tif (phba->bbcredit_support && phba->cfg_enable_bbcr  &&\n\t    bbscn_fabric != 0) {\n\t\tbbscn_max = bf_get(lpfc_bbscn_max,\n\t\t\t\t   &phba->sli4_hba.bbscn_params);\n\t\tif (bbscn_fabric <= bbscn_max) {\n\t\t\tbbscn_def = bf_get(lpfc_bbscn_def,\n\t\t\t\t\t   &phba->sli4_hba.bbscn_params);\n\n\t\t\tif (bbscn_fabric > bbscn_def)\n\t\t\t\tbf_set(lpfc_reg_vfi_bbscn, reg_vfi,\n\t\t\t\t       bbscn_fabric);\n\t\t\telse\n\t\t\t\tbf_set(lpfc_reg_vfi_bbscn, reg_vfi, bbscn_def);\n\n\t\t\tbf_set(lpfc_reg_vfi_bbcr, reg_vfi, 1);\n\t\t}\n\t}\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_MBOX,\n\t\t\t\"3134 Register VFI, mydid:x%x, fcfi:%d, \"\n\t\t\t\" vfi:%d, vpi:%d, fc_pname:%x%x fc_flag:x%x\"\n\t\t\t\" port_state:x%x topology chg:%d bbscn_fabric :%d\\n\",\n\t\t\tvport->fc_myDID,\n\t\t\tphba->fcf.fcfi,\n\t\t\tphba->sli4_hba.vfi_ids[vport->vfi],\n\t\t\tphba->vpi_ids[vport->vpi],\n\t\t\treg_vfi->wwn[0], reg_vfi->wwn[1], vport->fc_flag,\n\t\t\tvport->port_state, phba->fc_topology_changed,\n\t\t\tbbscn_fabric);\n}\n\n \nvoid\nlpfc_init_vpi(struct lpfc_hba *phba, struct lpfcMboxq *mbox, uint16_t vpi)\n{\n\tmemset(mbox, 0, sizeof(*mbox));\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_INIT_VPI);\n\tbf_set(lpfc_init_vpi_vpi, &mbox->u.mqe.un.init_vpi,\n\t       phba->vpi_ids[vpi]);\n\tbf_set(lpfc_init_vpi_vfi, &mbox->u.mqe.un.init_vpi,\n\t       phba->sli4_hba.vfi_ids[phba->pport->vfi]);\n}\n\n \nvoid\nlpfc_unreg_vfi(struct lpfcMboxq *mbox, struct lpfc_vport *vport)\n{\n\tmemset(mbox, 0, sizeof(*mbox));\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_UNREG_VFI);\n\tbf_set(lpfc_unreg_vfi_vfi, &mbox->u.mqe.un.unreg_vfi,\n\t       vport->phba->sli4_hba.vfi_ids[vport->vfi]);\n}\n\n \nint\nlpfc_sli4_dump_cfg_rg23(struct lpfc_hba *phba, struct lpfcMboxq *mbox)\n{\n\tstruct lpfc_dmabuf *mp = NULL;\n\tMAILBOX_t *mb;\n\tint rc;\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\tmb = &mbox->u.mb;\n\n\trc = lpfc_mbox_rsrc_prep(phba, mbox);\n\tif (rc) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\n\t\t\t\t\"2569 %s: memory allocation failed\\n\",\n\t\t\t\t__func__);\n\t\treturn 1;\n\t}\n\n\tmb->mbxCommand = MBX_DUMP_MEMORY;\n\tmb->un.varDmp.type = DMP_NV_PARAMS;\n\tmb->un.varDmp.region_id = DMP_REGION_23;\n\tmb->un.varDmp.sli4_length = DMP_RGN23_SIZE;\n\tmp = mbox->ctx_buf;\n\tmb->un.varWords[3] = putPaddrLow(mp->phys);\n\tmb->un.varWords[4] = putPaddrHigh(mp->phys);\n\treturn 0;\n}\n\nstatic void\nlpfc_mbx_cmpl_rdp_link_stat(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tMAILBOX_t *mb;\n\tint rc = FAILURE;\n\tstruct lpfc_rdp_context *rdp_context =\n\t\t\t(struct lpfc_rdp_context *)(mboxq->ctx_ndlp);\n\n\tmb = &mboxq->u.mb;\n\tif (mb->mbxStatus)\n\t\tgoto mbx_failed;\n\n\tmemcpy(&rdp_context->link_stat, &mb->un.varRdLnk, sizeof(READ_LNK_VAR));\n\n\trc = SUCCESS;\n\nmbx_failed:\n\tlpfc_mbox_rsrc_cleanup(phba, mboxq, MBOX_THD_UNLOCKED);\n\trdp_context->cmpl(phba, rdp_context, rc);\n}\n\nstatic void\nlpfc_mbx_cmpl_rdp_page_a2(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbox)\n{\n\tstruct lpfc_dmabuf *mp = (struct lpfc_dmabuf *)mbox->ctx_buf;\n\tstruct lpfc_rdp_context *rdp_context =\n\t\t\t(struct lpfc_rdp_context *)(mbox->ctx_ndlp);\n\n\tif (bf_get(lpfc_mqe_status, &mbox->u.mqe))\n\t\tgoto error_mbox_free;\n\n\tlpfc_sli_bemem_bcopy(mp->virt, &rdp_context->page_a2,\n\t\t\t\tDMP_SFF_PAGE_A2_SIZE);\n\n\tlpfc_read_lnk_stat(phba, mbox);\n\tmbox->vport = rdp_context->ndlp->vport;\n\n\t \n\tmbox->ctx_buf = mp;\n\tmbox->mbox_cmpl = lpfc_mbx_cmpl_rdp_link_stat;\n\tmbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;\n\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT) == MBX_NOT_FINISHED)\n\t\tgoto error_mbox_free;\n\n\treturn;\n\nerror_mbox_free:\n\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\trdp_context->cmpl(phba, rdp_context, FAILURE);\n}\n\nvoid\nlpfc_mbx_cmpl_rdp_page_a0(struct lpfc_hba *phba, LPFC_MBOXQ_t *mbox)\n{\n\tint rc;\n\tstruct lpfc_dmabuf *mp = (struct lpfc_dmabuf *)(mbox->ctx_buf);\n\tstruct lpfc_rdp_context *rdp_context =\n\t\t\t(struct lpfc_rdp_context *)(mbox->ctx_ndlp);\n\n\tif (bf_get(lpfc_mqe_status, &mbox->u.mqe))\n\t\tgoto error;\n\n\tlpfc_sli_bemem_bcopy(mp->virt, &rdp_context->page_a0,\n\t\t\t\tDMP_SFF_PAGE_A0_SIZE);\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\n\tmemset(mp->virt, 0, DMP_SFF_PAGE_A2_SIZE);\n\tINIT_LIST_HEAD(&mp->list);\n\n\t \n\tmbox->ctx_buf = mp;\n\tmbox->vport = rdp_context->ndlp->vport;\n\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_DUMP_MEMORY);\n\tbf_set(lpfc_mbx_memory_dump_type3_type,\n\t\t&mbox->u.mqe.un.mem_dump_type3, DMP_LMSD);\n\tbf_set(lpfc_mbx_memory_dump_type3_link,\n\t\t&mbox->u.mqe.un.mem_dump_type3, phba->sli4_hba.physical_port);\n\tbf_set(lpfc_mbx_memory_dump_type3_page_no,\n\t\t&mbox->u.mqe.un.mem_dump_type3, DMP_PAGE_A2);\n\tbf_set(lpfc_mbx_memory_dump_type3_length,\n\t\t&mbox->u.mqe.un.mem_dump_type3, DMP_SFF_PAGE_A2_SIZE);\n\tmbox->u.mqe.un.mem_dump_type3.addr_lo = putPaddrLow(mp->phys);\n\tmbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);\n\n\tmbox->mbox_cmpl = lpfc_mbx_cmpl_rdp_page_a2;\n\tmbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED)\n\t\tgoto error;\n\n\treturn;\n\nerror:\n\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\trdp_context->cmpl(phba, rdp_context, FAILURE);\n}\n\n\n \nint\nlpfc_sli4_dump_page_a0(struct lpfc_hba *phba, struct lpfcMboxq *mbox)\n{\n\tint rc;\n\tstruct lpfc_dmabuf *mp = NULL;\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\n\trc = lpfc_mbox_rsrc_prep(phba, mbox);\n\tif (rc) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\n\t\t\t\"3569 dump type 3 page 0xA0 allocation failed\\n\");\n\t\treturn 1;\n\t}\n\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_DUMP_MEMORY);\n\tbf_set(lpfc_mbx_memory_dump_type3_type,\n\t\t&mbox->u.mqe.un.mem_dump_type3, DMP_LMSD);\n\tbf_set(lpfc_mbx_memory_dump_type3_link,\n\t\t&mbox->u.mqe.un.mem_dump_type3, phba->sli4_hba.physical_port);\n\tbf_set(lpfc_mbx_memory_dump_type3_page_no,\n\t\t&mbox->u.mqe.un.mem_dump_type3, DMP_PAGE_A0);\n\tbf_set(lpfc_mbx_memory_dump_type3_length,\n\t\t&mbox->u.mqe.un.mem_dump_type3, DMP_SFF_PAGE_A0_SIZE);\n\n\tmp = mbox->ctx_buf;\n\tmbox->u.mqe.un.mem_dump_type3.addr_lo = putPaddrLow(mp->phys);\n\tmbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);\n\n\treturn 0;\n}\n\n \nvoid\nlpfc_reg_fcfi(struct lpfc_hba *phba, struct lpfcMboxq *mbox)\n{\n\tstruct lpfc_mbx_reg_fcfi *reg_fcfi;\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\treg_fcfi = &mbox->u.mqe.un.reg_fcfi;\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_REG_FCFI);\n\tif (phba->nvmet_support == 0) {\n\t\tbf_set(lpfc_reg_fcfi_rq_id0, reg_fcfi,\n\t\t       phba->sli4_hba.hdr_rq->queue_id);\n\t\t \n\t\tbf_set(lpfc_reg_fcfi_type_match0, reg_fcfi, 0);\n\t\tbf_set(lpfc_reg_fcfi_type_mask0, reg_fcfi, 0);\n\t\tbf_set(lpfc_reg_fcfi_rctl_match0, reg_fcfi, 0);\n\t\tbf_set(lpfc_reg_fcfi_rctl_mask0, reg_fcfi, 0);\n\n\t\tbf_set(lpfc_reg_fcfi_rq_id1, reg_fcfi, REG_FCF_INVALID_QID);\n\n\t\t \n\t\tbf_set(lpfc_reg_fcfi_mam, reg_fcfi,\n\t\t       (~phba->fcf.addr_mode) & 0x3);\n\t} else {\n\t\t \n\t\tif (phba->cfg_nvmet_mrq != 1)\n\t\t\treturn;\n\n\t\tbf_set(lpfc_reg_fcfi_rq_id0, reg_fcfi,\n\t\t       phba->sli4_hba.nvmet_mrq_hdr[0]->queue_id);\n\t\t \n\t\tbf_set(lpfc_reg_fcfi_type_match0, reg_fcfi, FC_TYPE_FCP);\n\t\tbf_set(lpfc_reg_fcfi_type_mask0, reg_fcfi, 0xff);\n\t\tbf_set(lpfc_reg_fcfi_rctl_match0, reg_fcfi,\n\t\t       FC_RCTL_DD_UNSOL_CMD);\n\n\t\tbf_set(lpfc_reg_fcfi_rq_id1, reg_fcfi,\n\t\t       phba->sli4_hba.hdr_rq->queue_id);\n\t\t \n\t\tbf_set(lpfc_reg_fcfi_type_match1, reg_fcfi, 0);\n\t\tbf_set(lpfc_reg_fcfi_type_mask1, reg_fcfi, 0);\n\t\tbf_set(lpfc_reg_fcfi_rctl_match1, reg_fcfi, 0);\n\t\tbf_set(lpfc_reg_fcfi_rctl_mask1, reg_fcfi, 0);\n\t}\n\tbf_set(lpfc_reg_fcfi_rq_id2, reg_fcfi, REG_FCF_INVALID_QID);\n\tbf_set(lpfc_reg_fcfi_rq_id3, reg_fcfi, REG_FCF_INVALID_QID);\n\tbf_set(lpfc_reg_fcfi_info_index, reg_fcfi,\n\t       phba->fcf.current_rec.fcf_indx);\n\tif (phba->fcf.current_rec.vlan_id != LPFC_FCOE_NULL_VID) {\n\t\tbf_set(lpfc_reg_fcfi_vv, reg_fcfi, 1);\n\t\tbf_set(lpfc_reg_fcfi_vlan_tag, reg_fcfi,\n\t\t       phba->fcf.current_rec.vlan_id);\n\t}\n}\n\n \nvoid\nlpfc_reg_fcfi_mrq(struct lpfc_hba *phba, struct lpfcMboxq *mbox, int mode)\n{\n\tstruct lpfc_mbx_reg_fcfi_mrq *reg_fcfi;\n\n\t \n\tif (phba->cfg_nvmet_mrq <= 1)\n\t\treturn;\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\treg_fcfi = &mbox->u.mqe.un.reg_fcfi_mrq;\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_REG_FCFI_MRQ);\n\tif (mode == 0) {\n\t\tbf_set(lpfc_reg_fcfi_mrq_info_index, reg_fcfi,\n\t\t       phba->fcf.current_rec.fcf_indx);\n\t\tif (phba->fcf.current_rec.vlan_id != LPFC_FCOE_NULL_VID) {\n\t\t\tbf_set(lpfc_reg_fcfi_mrq_vv, reg_fcfi, 1);\n\t\t\tbf_set(lpfc_reg_fcfi_mrq_vlan_tag, reg_fcfi,\n\t\t\t       phba->fcf.current_rec.vlan_id);\n\t\t}\n\t\treturn;\n\t}\n\n\tbf_set(lpfc_reg_fcfi_mrq_rq_id0, reg_fcfi,\n\t       phba->sli4_hba.nvmet_mrq_hdr[0]->queue_id);\n\t \n\tbf_set(lpfc_reg_fcfi_mrq_type_match0, reg_fcfi, FC_TYPE_FCP);\n\tbf_set(lpfc_reg_fcfi_mrq_type_mask0, reg_fcfi, 0xff);\n\tbf_set(lpfc_reg_fcfi_mrq_rctl_match0, reg_fcfi, FC_RCTL_DD_UNSOL_CMD);\n\tbf_set(lpfc_reg_fcfi_mrq_rctl_mask0, reg_fcfi, 0xff);\n\tbf_set(lpfc_reg_fcfi_mrq_ptc0, reg_fcfi, 1);\n\tbf_set(lpfc_reg_fcfi_mrq_pt0, reg_fcfi, 1);\n\n\tbf_set(lpfc_reg_fcfi_mrq_policy, reg_fcfi, 3);  \n\tbf_set(lpfc_reg_fcfi_mrq_mode, reg_fcfi, 1);\n\tbf_set(lpfc_reg_fcfi_mrq_filter, reg_fcfi, 1);  \n\tbf_set(lpfc_reg_fcfi_mrq_npairs, reg_fcfi, phba->cfg_nvmet_mrq);\n\n\tbf_set(lpfc_reg_fcfi_mrq_rq_id1, reg_fcfi,\n\t       phba->sli4_hba.hdr_rq->queue_id);\n\t \n\tbf_set(lpfc_reg_fcfi_mrq_type_match1, reg_fcfi, 0);\n\tbf_set(lpfc_reg_fcfi_mrq_type_mask1, reg_fcfi, 0);\n\tbf_set(lpfc_reg_fcfi_mrq_rctl_match1, reg_fcfi, 0);\n\tbf_set(lpfc_reg_fcfi_mrq_rctl_mask1, reg_fcfi, 0);\n\n\tbf_set(lpfc_reg_fcfi_mrq_rq_id2, reg_fcfi, REG_FCF_INVALID_QID);\n\tbf_set(lpfc_reg_fcfi_mrq_rq_id3, reg_fcfi, REG_FCF_INVALID_QID);\n}\n\n \nvoid\nlpfc_unreg_fcfi(struct lpfcMboxq *mbox, uint16_t fcfi)\n{\n\tmemset(mbox, 0, sizeof(*mbox));\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_UNREG_FCFI);\n\tbf_set(lpfc_unreg_fcfi, &mbox->u.mqe.un.unreg_fcfi, fcfi);\n}\n\n \nvoid\nlpfc_resume_rpi(struct lpfcMboxq *mbox, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba *phba = ndlp->phba;\n\tstruct lpfc_mbx_resume_rpi *resume_rpi;\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\tresume_rpi = &mbox->u.mqe.un.resume_rpi;\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_RESUME_RPI);\n\tbf_set(lpfc_resume_rpi_index, resume_rpi,\n\t       phba->sli4_hba.rpi_ids[ndlp->nlp_rpi]);\n\tbf_set(lpfc_resume_rpi_ii, resume_rpi, RESUME_INDEX_RPI);\n\tresume_rpi->event_tag = ndlp->phba->fc_eventTag;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}