{
  "module_name": "lpfc_nportdisc.c",
  "hash_id": "ebba15c30890312d6481ae3f5560cd20f318ef585bdd4a4686e8de5ecc78f21b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_nportdisc.c",
  "human_readable_source": " \n\n#include <linux/blkdev.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_nvme.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_debugfs.h\"\n\n\n \nstatic int\nlpfc_check_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t struct lpfc_name *nn, struct lpfc_name *pn)\n{\n\t \n\tif (!(ndlp->nlp_flag & NLP_RPI_REGISTERED))\n\t\treturn 0;\n\n\t \n\tif (memcmp(nn, &ndlp->nlp_nodename, sizeof (struct lpfc_name)))\n\t\treturn 0;\n\n\tif (memcmp(pn, &ndlp->nlp_portname, sizeof (struct lpfc_name)))\n\t\treturn 0;\n\n\t \n\treturn 1;\n}\n\nint\nlpfc_check_sparm(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t struct serv_parm *sp, uint32_t class, int flogi)\n{\n\tvolatile struct serv_parm *hsp = &vport->fc_sparam;\n\tuint16_t hsp_value, ssp_value = 0;\n\n\t \n\tif (sp->cls1.classValid) {\n\t\tif (!flogi) {\n\t\t\thsp_value = ((hsp->cls1.rcvDataSizeMsb << 8) |\n\t\t\t\t     hsp->cls1.rcvDataSizeLsb);\n\t\t\tssp_value = ((sp->cls1.rcvDataSizeMsb << 8) |\n\t\t\t\t     sp->cls1.rcvDataSizeLsb);\n\t\t\tif (!ssp_value)\n\t\t\t\tgoto bad_service_param;\n\t\t\tif (ssp_value > hsp_value) {\n\t\t\t\tsp->cls1.rcvDataSizeLsb =\n\t\t\t\t\thsp->cls1.rcvDataSizeLsb;\n\t\t\t\tsp->cls1.rcvDataSizeMsb =\n\t\t\t\t\thsp->cls1.rcvDataSizeMsb;\n\t\t\t}\n\t\t}\n\t} else if (class == CLASS1)\n\t\tgoto bad_service_param;\n\tif (sp->cls2.classValid) {\n\t\tif (!flogi) {\n\t\t\thsp_value = ((hsp->cls2.rcvDataSizeMsb << 8) |\n\t\t\t\t     hsp->cls2.rcvDataSizeLsb);\n\t\t\tssp_value = ((sp->cls2.rcvDataSizeMsb << 8) |\n\t\t\t\t     sp->cls2.rcvDataSizeLsb);\n\t\t\tif (!ssp_value)\n\t\t\t\tgoto bad_service_param;\n\t\t\tif (ssp_value > hsp_value) {\n\t\t\t\tsp->cls2.rcvDataSizeLsb =\n\t\t\t\t\thsp->cls2.rcvDataSizeLsb;\n\t\t\t\tsp->cls2.rcvDataSizeMsb =\n\t\t\t\t\thsp->cls2.rcvDataSizeMsb;\n\t\t\t}\n\t\t}\n\t} else if (class == CLASS2)\n\t\tgoto bad_service_param;\n\tif (sp->cls3.classValid) {\n\t\tif (!flogi) {\n\t\t\thsp_value = ((hsp->cls3.rcvDataSizeMsb << 8) |\n\t\t\t\t     hsp->cls3.rcvDataSizeLsb);\n\t\t\tssp_value = ((sp->cls3.rcvDataSizeMsb << 8) |\n\t\t\t\t     sp->cls3.rcvDataSizeLsb);\n\t\t\tif (!ssp_value)\n\t\t\t\tgoto bad_service_param;\n\t\t\tif (ssp_value > hsp_value) {\n\t\t\t\tsp->cls3.rcvDataSizeLsb =\n\t\t\t\t\thsp->cls3.rcvDataSizeLsb;\n\t\t\t\tsp->cls3.rcvDataSizeMsb =\n\t\t\t\t\thsp->cls3.rcvDataSizeMsb;\n\t\t\t}\n\t\t}\n\t} else if (class == CLASS3)\n\t\tgoto bad_service_param;\n\n\t \n\thsp_value = (hsp->cmn.bbRcvSizeMsb << 8) | hsp->cmn.bbRcvSizeLsb;\n\tssp_value = (sp->cmn.bbRcvSizeMsb << 8) | sp->cmn.bbRcvSizeLsb;\n\tif (ssp_value > hsp_value) {\n\t\tsp->cmn.bbRcvSizeLsb = hsp->cmn.bbRcvSizeLsb;\n\t\tsp->cmn.bbRcvSizeMsb = (sp->cmn.bbRcvSizeMsb & 0xF0) |\n\t\t\t\t       (hsp->cmn.bbRcvSizeMsb & 0x0F);\n\t}\n\n\tmemcpy(&ndlp->nlp_nodename, &sp->nodeName, sizeof (struct lpfc_name));\n\tmemcpy(&ndlp->nlp_portname, &sp->portName, sizeof (struct lpfc_name));\n\treturn 1;\nbad_service_param:\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0207 Device %x \"\n\t\t\t \"(%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x) sent \"\n\t\t\t \"invalid service parameters.  Ignoring device.\\n\",\n\t\t\t ndlp->nlp_DID,\n\t\t\t sp->nodeName.u.wwn[0], sp->nodeName.u.wwn[1],\n\t\t\t sp->nodeName.u.wwn[2], sp->nodeName.u.wwn[3],\n\t\t\t sp->nodeName.u.wwn[4], sp->nodeName.u.wwn[5],\n\t\t\t sp->nodeName.u.wwn[6], sp->nodeName.u.wwn[7]);\n\treturn 0;\n}\n\nstatic void *\nlpfc_check_elscmpl_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_dmabuf *pcmd, *prsp;\n\tuint32_t *lp;\n\tvoid     *ptr = NULL;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\n\t \n\tif (pcmd) {\n\t\tprsp =  list_get_first(&pcmd->list, struct lpfc_dmabuf,\n\t\t\t\t       list);\n\t\tif (prsp) {\n\t\t\tlp = (uint32_t *) prsp->virt;\n\t\t\tptr = (void *)((uint8_t *)lp + sizeof(uint32_t));\n\t\t}\n\t} else {\n\t\t \n\t\tif (!(ulp_status)) {\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\t\tbf_set(lpfc_wcqe_c_status, &rspiocb->wcqe_cmpl,\n\t\t\t\t       IOSTAT_LOCAL_REJECT);\n\t\t\t\trspiocb->wcqe_cmpl.parameter = IOERR_SLI_ABORTED;\n\t\t\t} else {\n\t\t\t\trspiocb->iocb.ulpStatus = IOSTAT_LOCAL_REJECT;\n\t\t\t\trspiocb->iocb.un.ulpWord[4] = IOERR_SLI_ABORTED;\n\t\t\t}\n\t\t}\n\t\tptr = NULL;\n\t}\n\treturn ptr;\n}\n\n\n\n \nvoid\nlpfc_els_abort(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp)\n{\n\tLIST_HEAD(abort_list);\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *iocb, *next_iocb;\n\n\tpring = lpfc_phba_elsring(phba);\n\n\t \n\tif (unlikely(!pring))\n\t\treturn;\n\n\t \n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"2819 Abort outstanding I/O on NPort x%x \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\t \n\tlpfc_fabric_abort_nport(ndlp);\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_lock(&pring->ring_lock);\n\tlist_for_each_entry_safe(iocb, next_iocb, &pring->txcmplq, list) {\n\t \n\t\tif (lpfc_check_sli_ndlp(phba, pring, iocb, ndlp))\n\t\t\tlist_add_tail(&iocb->dlist, &abort_list);\n\t}\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring->ring_lock);\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tlist_for_each_entry_safe(iocb, next_iocb, &abort_list, dlist) {\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tlist_del_init(&iocb->dlist);\n\t\t\tlpfc_sli_issue_abort_iotag(phba, pring, iocb, NULL);\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t}\n\t \n\tlpfc_issue_hb_tmo(phba);\n\n\tINIT_LIST_HEAD(&abort_list);\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_lock(&pring->ring_lock);\n\n\tlist_for_each_entry_safe(iocb, next_iocb, &pring->txq, list) {\n\t\t \n\t\tif (lpfc_check_sli_ndlp(phba, pring, iocb, ndlp)) {\n\t\t\tlist_del_init(&iocb->list);\n\t\t\tlist_add_tail(&iocb->list, &abort_list);\n\t\t}\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring->ring_lock);\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tlpfc_sli_cancel_iocbs(phba, &abort_list,\n\t\t\t      IOSTAT_LOCAL_REJECT, IOERR_SLI_ABORTED);\n\n\tlpfc_cancel_retry_delay_tmo(phba->pport, ndlp);\n}\n\n \nstatic void\nlpfc_defer_plogi_acc(struct lpfc_hba *phba, LPFC_MBOXQ_t *login_mbox)\n{\n\tstruct lpfc_iocbq *save_iocb;\n\tstruct lpfc_nodelist *ndlp;\n\tMAILBOX_t *mb = &login_mbox->u.mb;\n\n\tint rc;\n\n\tndlp = login_mbox->ctx_ndlp;\n\tsave_iocb = login_mbox->context3;\n\n\tif (mb->mbxStatus == MBX_SUCCESS) {\n\t\t \n\t\trc = lpfc_els_rsp_acc(login_mbox->vport, ELS_CMD_PLOGI,\n\t\t\t\t      save_iocb, ndlp, NULL);\n\t\tif (rc) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"4576 PLOGI ACC fails pt2pt discovery: \"\n\t\t\t\t\t\"DID %x Data: %x\\n\", ndlp->nlp_DID, rc);\n\t\t}\n\t}\n\n\t \n\tlpfc_mbx_cmpl_reg_login(phba, login_mbox);\n\tndlp->nlp_flag &= ~NLP_ACC_REGLOGIN;\n\tkfree(save_iocb);\n}\n\nstatic int\nlpfc_rcv_plogi(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t       struct lpfc_iocbq *cmdiocb)\n{\n\tstruct lpfc_hba    *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint64_t nlp_portwwn = 0;\n\tuint32_t *lp;\n\tunion lpfc_wqe128 *wqe;\n\tIOCB_t *icmd;\n\tstruct serv_parm *sp;\n\tuint32_t ed_tov;\n\tLPFC_MBOXQ_t *link_mbox;\n\tLPFC_MBOXQ_t *login_mbox;\n\tstruct lpfc_iocbq *save_iocb;\n\tstruct ls_rjt stat;\n\tuint32_t vid, flag;\n\tint rc;\n\tu32 remote_did;\n\n\tmemset(&stat, 0, sizeof (struct ls_rjt));\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tlp = (uint32_t *) pcmd->virt;\n\tsp = (struct serv_parm *) ((uint8_t *) lp + sizeof (uint32_t));\n\tif (wwn_to_u64(sp->portName.u.wwn) == 0) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0140 PLOGI Reject: invalid pname\\n\");\n\t\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_INVALID_PNAME;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\n\t\t\tNULL);\n\t\treturn 0;\n\t}\n\tif (wwn_to_u64(sp->nodeName.u.wwn) == 0) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0141 PLOGI Reject: invalid nname\\n\");\n\t\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_INVALID_NNAME;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\n\t\t\tNULL);\n\t\treturn 0;\n\t}\n\n\tnlp_portwwn = wwn_to_u64(ndlp->nlp_portname.u.wwn);\n\tif ((lpfc_check_sparm(vport, ndlp, sp, CLASS3, 0) == 0)) {\n\t\t \n\t\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\n\t\t\tNULL);\n\t\treturn 0;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\twqe = &cmdiocb->wqe;\n\telse\n\t\ticmd = &cmdiocb->iocb;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0114 PLOGI chkparm OK Data: x%x x%x x%x \"\n\t\t\t \"x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_state, ndlp->nlp_flag,\n\t\t\t ndlp->nlp_rpi, vport->port_state,\n\t\t\t vport->fc_flag);\n\n\tif (vport->cfg_fcp_class == 2 && sp->cls2.classValid)\n\t\tndlp->nlp_fcp_info |= CLASS2;\n\telse\n\t\tndlp->nlp_fcp_info |= CLASS3;\n\n\tndlp->nlp_class_sup = 0;\n\tif (sp->cls1.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS1;\n\tif (sp->cls2.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS2;\n\tif (sp->cls3.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS3;\n\tif (sp->cls4.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS4;\n\tndlp->nlp_maxframe =\n\t\t((sp->cmn.bbRcvSizeMsb & 0x0F) << 8) | sp->cmn.bbRcvSizeLsb;\n\t \n\tswitch (ndlp->nlp_state) {\n\tcase  NLP_STE_NPR_NODE:\n\t\tif (!(ndlp->nlp_flag & NLP_NPR_ADISC))\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase  NLP_STE_REG_LOGIN_ISSUE:\n\tcase  NLP_STE_PRLI_ISSUE:\n\tcase  NLP_STE_UNMAPPED_NODE:\n\tcase  NLP_STE_MAPPED_NODE:\n\t\t \n\t\tif (!(ndlp->nlp_type & NLP_FABRIC) &&\n\t\t    !(phba->nvmet_support)) {\n\t\t\t \n\t\t\tndlp->nlp_type &= ~(NLP_FCP_TARGET | NLP_FCP_INITIATOR);\n\t\t\tndlp->nlp_type &= ~(NLP_NVME_TARGET | NLP_NVME_INITIATOR);\n\t\t\tndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\t\t\tndlp->nlp_nvme_info &= ~NLP_NVME_NSLER;\n\t\t\tndlp->nlp_flag &= ~NLP_FIRSTBURST;\n\n\t\t\tlpfc_els_rsp_acc(vport, ELS_CMD_PLOGI, cmdiocb,\n\t\t\t\t\t ndlp, NULL);\n\t\t\treturn 1;\n\t\t}\n\t\tif (nlp_portwwn != 0 &&\n\t\t    nlp_portwwn != wwn_to_u64(sp->portName.u.wwn))\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0143 PLOGI recv'd from DID: x%x \"\n\t\t\t\t\t \"WWPN changed: old %llx new %llx\\n\",\n\t\t\t\t\t ndlp->nlp_DID,\n\t\t\t\t\t (unsigned long long)nlp_portwwn,\n\t\t\t\t\t (unsigned long long)\n\t\t\t\t\t wwn_to_u64(sp->portName.u.wwn));\n\n\t\t \n\t\tif (phba->nvmet_support &&\n\t\t    ndlp->nlp_state == NLP_STE_UNMAPPED_NODE)\n\t\t\tlpfc_nvmet_invalidate_host(phba, ndlp);\n\n\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t \n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\tbreak;\n\t}\n\n\tndlp->nlp_type &= ~(NLP_FCP_TARGET | NLP_FCP_INITIATOR);\n\tndlp->nlp_type &= ~(NLP_NVME_TARGET | NLP_NVME_INITIATOR);\n\tndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\tndlp->nlp_nvme_info &= ~NLP_NVME_NSLER;\n\tndlp->nlp_flag &= ~NLP_FIRSTBURST;\n\n\tlogin_mbox = NULL;\n\tlink_mbox = NULL;\n\tsave_iocb = NULL;\n\n\t \n\tif ((vport->fc_flag & FC_PT2PT) &&\n\t    !(vport->fc_flag & FC_PT2PT_PLOGI)) {\n\t\t \n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tvport->fc_myDID = bf_get(els_rsp64_sid,\n\t\t\t\t\t\t &cmdiocb->wqe.xmit_els_rsp);\n\t\t} else {\n\t\t\tvport->fc_myDID = icmd->un.rcvels.parmRo;\n\t\t}\n\n\t\t \n\t\tif (phba->hba_flag & HBA_FLOGI_OUTSTANDING)\n\t\t\tlpfc_els_abort_flogi(phba);\n\n\t\ted_tov = be32_to_cpu(sp->cmn.e_d_tov);\n\t\tif (sp->cmn.edtovResolution) {\n\t\t\t \n\t\t\ted_tov = (phba->fc_edtov + 999999) / 1000000;\n\t\t}\n\n\t\t \n\t\tif (ed_tov > phba->fc_edtov)\n\t\t\tphba->fc_edtov = ed_tov;\n\t\tphba->fc_ratov = (2 * phba->fc_edtov) / 1000;\n\n\t\tmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\n\n\t\t \n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_issue_reg_vfi(vport);\n\t\telse {\n\t\t\tlink_mbox = mempool_alloc(phba->mbox_mem_pool,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!link_mbox)\n\t\t\t\tgoto out;\n\t\t\tlpfc_config_link(phba, link_mbox);\n\t\t\tlink_mbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\t\tlink_mbox->vport = vport;\n\n\t\t\t \n\t\t\tlink_mbox->ctx_ndlp = ndlp;\n\n\t\t\trc = lpfc_sli_issue_mbox(phba, link_mbox, MBX_NOWAIT);\n\t\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\t\tmempool_free(link_mbox, phba->mbox_mem_pool);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlpfc_can_disctmo(vport);\n\t}\n\n\tndlp->nlp_flag &= ~NLP_SUPPRESS_RSP;\n\tif ((phba->sli.sli_flag & LPFC_SLI_SUPPRESS_RSP) &&\n\t    sp->cmn.valid_vendor_ver_level) {\n\t\tvid = be32_to_cpu(sp->un.vv.vid);\n\t\tflag = be32_to_cpu(sp->un.vv.flags);\n\t\tif ((vid == LPFC_VV_EMLX_ID) && (flag & LPFC_VV_SUPPRESS_RSP))\n\t\t\tndlp->nlp_flag |= NLP_SUPPRESS_RSP;\n\t}\n\n\tlogin_mbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!login_mbox)\n\t\tgoto out;\n\n\tsave_iocb = kzalloc(sizeof(*save_iocb), GFP_KERNEL);\n\tif (!save_iocb)\n\t\tgoto out;\n\n\t \n\tmemcpy((uint8_t *)save_iocb, (uint8_t *)cmdiocb,\n\t       sizeof(struct lpfc_iocbq));\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tlpfc_unreg_rpi(vport, ndlp);\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tremote_did = bf_get(wqe_els_did, &wqe->xmit_els_rsp.wqe_dest);\n\telse\n\t\tremote_did = icmd->un.rcvels.remoteID;\n\trc = lpfc_reg_rpi(phba, vport->vpi, remote_did,\n\t\t\t    (uint8_t *)sp, login_mbox, ndlp->nlp_rpi);\n\tif (rc)\n\t\tgoto out;\n\n\tlogin_mbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;\n\tlogin_mbox->vport = vport;\n\n\t \n\tif ((ndlp->nlp_state == NLP_STE_PLOGI_ISSUE) &&\n\t    (vport->fc_flag & FC_FABRIC)) {\n\t\t \n\t\tlpfc_els_abort(phba, ndlp);\n\t}\n\n\tif ((vport->port_type == LPFC_NPIV_PORT &&\n\t     vport->cfg_restrict_login)) {\n\n\t\t \n\t\tkfree(save_iocb);\n\n\t\t \n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tlpfc_mbox_rsrc_cleanup(phba, login_mbox,\n\t\t\t\t\t       MBOX_THD_UNLOCKED);\n\t\t\tlogin_mbox = NULL;\n\t\t} else {\n\t\t\t \n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag |= (NLP_RM_DFLT_RPI | NLP_ACC_REGLOGIN |\n\t\t\t\t\t   NLP_RCV_PLOGI);\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t}\n\n\t\tstat.un.b.lsRjtRsnCode = LSRJT_INVALID_CMD;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\n\t\trc = lpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb,\n\t\t\t\t\t ndlp, login_mbox);\n\t\tif (rc && login_mbox)\n\t\t\tlpfc_mbox_rsrc_cleanup(phba, login_mbox,\n\t\t\t\t\t       MBOX_THD_UNLOCKED);\n\t\treturn 1;\n\t}\n\n\t \n\tlogin_mbox->mbox_cmpl = lpfc_defer_plogi_acc;\n\tlogin_mbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\tif (!login_mbox->ctx_ndlp)\n\t\tgoto out;\n\n\tlogin_mbox->context3 = save_iocb;  \n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= (NLP_ACC_REGLOGIN | NLP_RCV_PLOGI);\n\tspin_unlock_irq(&ndlp->lock);\n\n\t \n\trc = lpfc_sli_issue_mbox(phba, login_mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto out;\n\t}\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_REG_LOGIN_ISSUE);\n\n\treturn 1;\nout:\n\tkfree(save_iocb);\n\tif (login_mbox)\n\t\tmempool_free(login_mbox, phba->mbox_mem_pool);\n\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_OUT_OF_RESOURCE;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 0;\n}\n\n \nstatic void\nlpfc_mbx_cmpl_resume_rpi(struct lpfc_hba *phba, LPFC_MBOXQ_t *mboxq)\n{\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_nodelist *ndlp;\n\tuint32_t cmd;\n\n\telsiocb = (struct lpfc_iocbq *)mboxq->ctx_buf;\n\tndlp = (struct lpfc_nodelist *)mboxq->ctx_ndlp;\n\tvport = mboxq->vport;\n\tcmd = elsiocb->drvrTimeout;\n\n\tif (cmd == ELS_CMD_ADISC) {\n\t\tlpfc_els_rsp_adisc_acc(vport, elsiocb, ndlp);\n\t} else {\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_PLOGI, elsiocb,\n\t\t\tndlp, NULL);\n\t}\n\n\t \n\tlpfc_nlp_put(ndlp);\n\n\tkfree(elsiocb);\n\tmempool_free(mboxq, phba->mbox_mem_pool);\n}\n\nstatic int\nlpfc_rcv_padisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\tstruct lpfc_iocbq *cmdiocb)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq  *elsiocb;\n\tstruct lpfc_dmabuf *pcmd;\n\tstruct serv_parm   *sp;\n\tstruct lpfc_name   *pnn, *ppn;\n\tstruct ls_rjt stat;\n\tADISC *ap;\n\tuint32_t *lp;\n\tuint32_t cmd;\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tlp = (uint32_t *) pcmd->virt;\n\n\tcmd = *lp++;\n\tif (cmd == ELS_CMD_ADISC) {\n\t\tap = (ADISC *) lp;\n\t\tpnn = (struct lpfc_name *) & ap->nodeName;\n\t\tppn = (struct lpfc_name *) & ap->portName;\n\t} else {\n\t\tsp = (struct serv_parm *) lp;\n\t\tpnn = (struct lpfc_name *) & sp->nodeName;\n\t\tppn = (struct lpfc_name *) & sp->portName;\n\t}\n\n\tif (get_job_ulpstatus(phba, cmdiocb) == 0 &&\n\t    lpfc_check_adisc(vport, ndlp, pnn, ppn)) {\n\n\t\t \n\t\tif (vport->phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\telsiocb = kmalloc(sizeof(struct lpfc_iocbq),\n\t\t\t\tGFP_KERNEL);\n\t\t\tif (elsiocb) {\n\t\t\t\t \n\t\t\t\tmemcpy((uint8_t *)elsiocb, (uint8_t *)cmdiocb,\n\t\t\t\t\tsizeof(struct lpfc_iocbq));\n\n\t\t\t\t \n\t\t\t\telsiocb->drvrTimeout = cmd;\n\n\t\t\t\tlpfc_sli4_resume_rpi(ndlp,\n\t\t\t\t\tlpfc_mbx_cmpl_resume_rpi, elsiocb);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (cmd == ELS_CMD_ADISC) {\n\t\t\tlpfc_els_rsp_adisc_acc(vport, cmdiocb, ndlp);\n\t\t} else {\n\t\t\tlpfc_els_rsp_acc(vport, ELS_CMD_PLOGI, cmdiocb,\n\t\t\t\tndlp, NULL);\n\t\t}\nout:\n\t\t \n\t\tif (ndlp->nlp_type & (NLP_FCP_TARGET | NLP_NVME_TARGET)) {\n\t\t\tif ((ndlp->nlp_state != NLP_STE_MAPPED_NODE) &&\n\t\t\t    !(ndlp->nlp_flag & NLP_NPR_ADISC))\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t   NLP_STE_MAPPED_NODE);\n\t\t}\n\n\t\treturn 1;\n\t}\n\t \n\tstat.un.b.lsRjtRsvd0 = 0;\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_SPARM_OPTIONS;\n\tstat.un.b.vendorUnique = 0;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\n\t \n\tmod_timer(&ndlp->nlp_delayfunc, jiffies + msecs_to_jiffies(1000));\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\tspin_unlock_irq(&ndlp->lock);\n\tndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\n\tndlp->nlp_prev_state = ndlp->nlp_state;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\treturn 0;\n}\n\nstatic int\nlpfc_rcv_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t      struct lpfc_iocbq *cmdiocb, uint32_t els_cmd)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba    *phba = vport->phba;\n\tstruct lpfc_vport **vports;\n\tint i, active_vlink_present = 0 ;\n\n\t \n\t \n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_LOGO_ACC;\n\tspin_unlock_irq(&ndlp->lock);\n\tif (els_cmd == ELS_CMD_PRLO)\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);\n\telse\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\n\t \n\tif (ndlp->nlp_type & NLP_FABRIC &&\n\t    ((ndlp->nlp_DID & WELL_KNOWN_DID_MASK) != WELL_KNOWN_DID_MASK))\n\t\treturn 0;\n\n\t \n\tif (phba->nvmet_support &&\n\t    ndlp->nlp_state == NLP_STE_UNMAPPED_NODE)\n\t\tlpfc_nvmet_invalidate_host(phba, ndlp);\n\n\tif (ndlp->nlp_DID == Fabric_DID) {\n\t\tif (vport->port_state <= LPFC_FDISC ||\n\t\t    vport->fc_flag & FC_PT2PT)\n\t\t\tgoto out;\n\t\tlpfc_linkdown_port(vport);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_VPORT_LOGO_RCVD;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tvports = lpfc_create_vport_work_array(phba);\n\t\tif (vports) {\n\t\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL;\n\t\t\t\t\ti++) {\n\t\t\t\tif ((!(vports[i]->fc_flag &\n\t\t\t\t\tFC_VPORT_LOGO_RCVD)) &&\n\t\t\t\t\t(vports[i]->port_state > LPFC_FDISC)) {\n\t\t\t\t\tactive_vlink_present = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlpfc_destroy_vport_work_array(phba, vports);\n\t\t}\n\n\t\t \n\t\tif (!(vport->load_flag & FC_UNLOADING) &&\n\t\t\t\t\tactive_vlink_present) {\n\t\t\t \n\t\t\tmod_timer(&ndlp->nlp_delayfunc,\n\t\t\t\t  jiffies + msecs_to_jiffies(1000));\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_last_elscmd = ELS_CMD_FDISC;\n\t\t\tvport->port_state = LPFC_FDISC;\n\t\t} else {\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tphba->pport->fc_flag &= ~FC_LOGO_RCVD_DID_CHNG;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tlpfc_retry_pport_discovery(phba);\n\t\t}\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t LOG_NODE | LOG_ELS | LOG_DISCOVERY,\n\t\t\t\t \"3203 LOGO recover nport x%06x state x%x \"\n\t\t\t\t \"ntype x%x fc_flag x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ndlp->nlp_state,\n\t\t\t\t ndlp->nlp_type, vport->fc_flag);\n\n\t\t \n\t\tif ((!(ndlp->nlp_type == NLP_FABRIC) &&\n\t\t     (ndlp->nlp_type & (NLP_FCP_TARGET | NLP_NVME_TARGET) ||\n\t\t      vport->fc_flag & FC_PT2PT)) ||\n\t\t    (ndlp->nlp_state >= NLP_STE_ADISC_ISSUE ||\n\t\t     ndlp->nlp_state <= NLP_STE_PRLI_ISSUE)) {\n\t\t\tmod_timer(&ndlp->nlp_delayfunc,\n\t\t\t\t  jiffies + msecs_to_jiffies(1000 * 1));\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_NODE | LOG_ELS | LOG_DISCOVERY,\n\t\t\t\t\t \"3204 Start nlpdelay on DID x%06x \"\n\t\t\t\t\t \"nflag x%x lastels x%x ref cnt %u\",\n\t\t\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t\t ndlp->nlp_last_elscmd,\n\t\t\t\t\t kref_read(&ndlp->kref));\n\t\t}\n\t}\nout:\n\t \n\tlpfc_nlp_unreg_node(vport, ndlp);\n\n\tndlp->nlp_prev_state = ndlp->nlp_state;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_NPR_ADISC;\n\tspin_unlock_irq(&ndlp->lock);\n\t \n\treturn 0;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_support_check(struct lpfc_vport *vport,\n\t\t\t    struct lpfc_nodelist *ndlp,\n\t\t\t    struct lpfc_iocbq *cmdiocb)\n{\n\tstruct ls_rjt stat;\n\tuint32_t *payload;\n\tuint32_t cmd;\n\n\tpayload = cmdiocb->cmd_dmabuf->virt;\n\tcmd = *payload;\n\tif (vport->phba->nvmet_support) {\n\t\t \n\t\tif (cmd ==  ELS_CMD_PRLI)\n\t\t\tgoto out;\n\t} else {\n\t\t \n\t\tif (!vport->nvmei_support && (cmd == ELS_CMD_NVMEPRLI))\n\t\t\tgoto out;\n\t}\n\treturn 1;\nout:\n\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_NVME_DISC,\n\t\t\t \"6115 Rcv PRLI (%x) check failed: ndlp rpi %d \"\n\t\t\t \"state x%x flags x%x\\n\",\n\t\t\t cmd, ndlp->nlp_rpi, ndlp->nlp_state,\n\t\t\t ndlp->nlp_flag);\n\tmemset(&stat, 0, sizeof(struct ls_rjt));\n\tstat.un.b.lsRjtRsnCode = LSRJT_CMD_UNSUPPORTED;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_REQ_UNSUPPORTED;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb,\n\t\t\t    ndlp, NULL);\n\treturn 0;\n}\n\nstatic void\nlpfc_rcv_prli(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t      struct lpfc_iocbq *cmdiocb)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp;\n\tPRLI *npr;\n\tstruct fc_rport *rport = ndlp->rport;\n\tu32 roles;\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tlp = (uint32_t *)pcmd->virt;\n\tnpr = (PRLI *)((uint8_t *)lp + sizeof(uint32_t));\n\n\tif ((npr->prliType == PRLI_FCP_TYPE) ||\n\t    (npr->prliType == PRLI_NVME_TYPE)) {\n\t\tif (npr->initiatorFunc) {\n\t\t\tif (npr->prliType == PRLI_FCP_TYPE)\n\t\t\t\tndlp->nlp_type |= NLP_FCP_INITIATOR;\n\t\t\tif (npr->prliType == PRLI_NVME_TYPE)\n\t\t\t\tndlp->nlp_type |= NLP_NVME_INITIATOR;\n\t\t}\n\t\tif (npr->targetFunc) {\n\t\t\tif (npr->prliType == PRLI_FCP_TYPE)\n\t\t\t\tndlp->nlp_type |= NLP_FCP_TARGET;\n\t\t\tif (npr->prliType == PRLI_NVME_TYPE)\n\t\t\t\tndlp->nlp_type |= NLP_NVME_TARGET;\n\t\t\tif (npr->writeXferRdyDis)\n\t\t\t\tndlp->nlp_flag |= NLP_FIRSTBURST;\n\t\t}\n\t\tif (npr->Retry && ndlp->nlp_type &\n\t\t\t\t\t(NLP_FCP_INITIATOR | NLP_FCP_TARGET))\n\t\t\tndlp->nlp_fcp_info |= NLP_FCP_2_DEVICE;\n\n\t\tif (npr->Retry && phba->nsler &&\n\t\t    ndlp->nlp_type & (NLP_NVME_INITIATOR | NLP_NVME_TARGET))\n\t\t\tndlp->nlp_nvme_info |= NLP_NVME_NSLER;\n\n\n\t\t \n\t\tif (phba->nvmet_support && (npr->prliType == PRLI_NVME_TYPE)) {\n\t\t\tndlp->nlp_fc4_type |= NLP_FC4_NVME;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t\t}\n\n\t\t \n\t\tif (npr->prliType == PRLI_FCP_TYPE &&\n\t\t    !(ndlp->nlp_type & NLP_FABRIC))\n\t\t\tndlp->nlp_fc4_type |= NLP_FC4_FCP;\n\t}\n\tif (rport) {\n\t\t \n\t\troles = FC_RPORT_ROLE_UNKNOWN;\n\t\tif (ndlp->nlp_type & NLP_FCP_INITIATOR)\n\t\t\troles |= FC_RPORT_ROLE_FCP_INITIATOR;\n\t\tif (ndlp->nlp_type & NLP_FCP_TARGET)\n\t\t\troles |= FC_RPORT_ROLE_FCP_TARGET;\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_RPORT,\n\t\t\t\"rport rolechg:   role:x%x did:x%x flg:x%x\",\n\t\t\troles, ndlp->nlp_DID, ndlp->nlp_flag);\n\n\t\tif (vport->cfg_enable_fc4_type != LPFC_ENABLE_NVME)\n\t\t\tfc_remote_port_rolechg(rport, roles);\n\t}\n}\n\nstatic uint32_t\nlpfc_disc_set_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tif (!(ndlp->nlp_flag & NLP_RPI_REGISTERED)) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn 0;\n\t}\n\n\tif (!(vport->fc_flag & FC_PT2PT)) {\n\t\t \n\t\tif (vport->cfg_use_adisc && ((vport->fc_flag & FC_RSCN_MODE) ||\n\t\t    ((ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) &&\n\t\t     (ndlp->nlp_type & NLP_FCP_TARGET)))) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag |= NLP_NPR_ADISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_NPR_ADISC;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_unreg_rpi(vport, ndlp);\n\treturn 0;\n}\n\n \nstatic void\nlpfc_release_rpi(struct lpfc_hba *phba, struct lpfc_vport *vport,\n\t\t struct lpfc_nodelist *ndlp, uint16_t rpi)\n{\n\tLPFC_MBOXQ_t *pmb;\n\tint rc;\n\n\t \n\tif (ndlp->nlp_flag & NLP_UNREG_INP) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"1435 release_rpi SKIP UNREG x%x on \"\n\t\t\t\t \"NPort x%x deferred x%x  flg x%x \"\n\t\t\t\t \"Data: x%px\\n\",\n\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID,\n\t\t\t\t ndlp->nlp_defer_did,\n\t\t\t\t ndlp->nlp_flag, ndlp);\n\t\treturn;\n\t}\n\n\tpmb = (LPFC_MBOXQ_t *) mempool_alloc(phba->mbox_mem_pool,\n\t\t\tGFP_KERNEL);\n\tif (!pmb)\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2796 mailbox memory allocation failed \\n\");\n\telse {\n\t\tlpfc_unreg_login(phba, vport->vpi, rpi, pmb);\n\t\tpmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\tpmb->vport = vport;\n\t\tpmb->ctx_ndlp = lpfc_nlp_get(ndlp);\n\t\tif (!pmb->ctx_ndlp) {\n\t\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\t\treturn;\n\t\t}\n\n\t\tif (((ndlp->nlp_DID & Fabric_DID_MASK) != Fabric_DID_MASK) &&\n\t\t    (!(vport->fc_flag & FC_OFFLINE_MODE)))\n\t\t\tndlp->nlp_flag |= NLP_UNREG_INP;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"1437 release_rpi UNREG x%x \"\n\t\t\t\t \"on NPort x%x flg x%x\\n\",\n\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID, ndlp->nlp_flag);\n\n\t\trc = lpfc_sli_issue_mbox(phba, pmb, MBX_NOWAIT);\n\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\t}\n\t}\n}\n\nstatic uint32_t\nlpfc_disc_illegal(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_hba *phba;\n\tLPFC_MBOXQ_t *pmb = (LPFC_MBOXQ_t *) arg;\n\tuint16_t rpi;\n\n\tphba = vport->phba;\n\t \n\tif (!(phba->pport->load_flag & FC_UNLOADING) &&\n\t\t(evt == NLP_EVT_CMPL_REG_LOGIN) &&\n\t\t(!pmb->u.mb.mbxStatus)) {\n\t\trpi = pmb->u.mb.un.varWords[0];\n\t\tlpfc_release_rpi(phba, vport, ndlp, rpi);\n\t}\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0271 Illegal State Transition: node x%x \"\n\t\t\t \"event x%x, state x%x Data: x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, evt, ndlp->nlp_state, ndlp->nlp_rpi,\n\t\t\t ndlp->nlp_flag);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_plogi_illegal(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t  void *arg, uint32_t evt)\n{\n\t \n\tif (!(ndlp->nlp_flag & NLP_RCV_PLOGI)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0272 Illegal State Transition: node x%x \"\n\t\t\t\t \"event x%x, state x%x Data: x%x x%x\\n\",\n\t\t\t\t  ndlp->nlp_DID, evt, ndlp->nlp_state,\n\t\t\t\t  ndlp->nlp_rpi, ndlp->nlp_flag);\n\t}\n\treturn ndlp->nlp_state;\n}\n\n \n\nstatic uint32_t\nlpfc_rcv_plogi_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\n\tif (lpfc_rcv_plogi(vport, ndlp, cmdiocb)) {\n\t\treturn ndlp->nlp_state;\n\t}\n\treturn NLP_STE_FREED_NODE;\n}\n\nstatic uint32_t\nlpfc_rcv_els_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tlpfc_issue_els_logo(vport, ndlp, 0);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_LOGO_ACC;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_logo_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\treturn NLP_STE_FREED_NODE;\n}\n\nstatic uint32_t\nlpfc_device_rm_unused_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\treturn NLP_STE_FREED_NODE;\n}\n\nstatic uint32_t\nlpfc_device_recov_unused_node(struct lpfc_vport *vport,\n\t\t\tstruct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_plogi_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tstruct Scsi_Host   *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb = arg;\n\tstruct lpfc_dmabuf *pcmd = cmdiocb->cmd_dmabuf;\n\tuint32_t *lp = (uint32_t *) pcmd->virt;\n\tstruct serv_parm *sp = (struct serv_parm *) (lp + 1);\n\tstruct ls_rjt stat;\n\tint port_cmp;\n\n\tmemset(&stat, 0, sizeof (struct ls_rjt));\n\n\t \n\tphba->fc_stat.elsLogiCol++;\n\tport_cmp = memcmp(&vport->fc_portname, &sp->portName,\n\t\t\t  sizeof(struct lpfc_name));\n\n\tif (port_cmp >= 0) {\n\t\t \n\t\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CMD_IN_PROGRESS;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\n\t\t\tNULL);\n\t} else {\n\t\tif (lpfc_rcv_plogi(vport, ndlp, cmdiocb) &&\n\t\t    (ndlp->nlp_flag & NLP_NPR_2B_DISC) &&\n\t\t    (vport->num_disc_nodes)) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t \n\t\t\tlpfc_more_plogi(vport);\n\t\t\tif (vport->num_disc_nodes == 0) {\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tlpfc_can_disctmo(vport);\n\t\t\t\tlpfc_end_rscn(vport);\n\t\t\t}\n\t\t}\n\t}  \n\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\tstruct ls_rjt     stat;\n\n\tmemset(&stat, 0, sizeof (struct ls_rjt));\n\tstat.un.b.lsRjtRsnCode = LSRJT_LOGICAL_BSY;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\t \n\tif (vport->phba->sli_rev == LPFC_SLI_REV3)\n\t\tndlp->nlp_rpi = cmdiocb->iocb.ulpIoTag;\n\t\t\t\t \n\tlpfc_els_abort(vport->phba, ndlp);\n\n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_els_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\t \n\tlpfc_els_abort(phba, ndlp);\n\n\tif (evt == NLP_EVT_RCV_LOGO) {\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t} else {\n\t\tlpfc_issue_els_logo(vport, ndlp, 0);\n\t}\n\n\t \n\tmod_timer(&ndlp->nlp_delayfunc, jiffies + msecs_to_jiffies(1000 * 1));\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\tspin_unlock_irq(&ndlp->lock);\n\tndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\n\tndlp->nlp_prev_state = NLP_STE_PLOGI_ISSUE;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_plogi_plogi_issue(struct lpfc_vport *vport,\n\t\t\t    struct lpfc_nodelist *ndlp,\n\t\t\t    void *arg,\n\t\t\t    uint32_t evt)\n{\n\tstruct lpfc_hba    *phba = vport->phba;\n\tstruct lpfc_iocbq  *cmdiocb, *rspiocb;\n\tstruct lpfc_dmabuf *pcmd, *prsp;\n\tuint32_t *lp;\n\tuint32_t vid, flag;\n\tstruct serv_parm *sp;\n\tuint32_t ed_tov;\n\tLPFC_MBOXQ_t *mbox;\n\tint rc;\n\tu32 ulp_status;\n\tu32 did;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\trspiocb = cmdiocb->rsp_iocb;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ndlp->nlp_flag & NLP_ACC_REGLOGIN) {\n\t\t \n\t\treturn ndlp->nlp_state;\n\t}\n\n\tif (ulp_status)\n\t\tgoto out;\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\n\tprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\n\tif (!prsp)\n\t\tgoto out;\n\n\tlp = (uint32_t *) prsp->virt;\n\tsp = (struct serv_parm *) ((uint8_t *) lp + sizeof (uint32_t));\n\n\t \n\tif ((ndlp->nlp_DID != FDMI_DID) &&\n\t\t(wwn_to_u64(sp->portName.u.wwn) == 0 ||\n\t\twwn_to_u64(sp->nodeName.u.wwn) == 0)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0142 PLOGI RSP: Invalid WWN.\\n\");\n\t\tgoto out;\n\t}\n\tif (!lpfc_check_sparm(vport, ndlp, sp, CLASS3, 0))\n\t\tgoto out;\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0121 PLOGI chkparm OK Data: x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_state,\n\t\t\t ndlp->nlp_flag, ndlp->nlp_rpi);\n\tif (vport->cfg_fcp_class == 2 && (sp->cls2.classValid))\n\t\tndlp->nlp_fcp_info |= CLASS2;\n\telse\n\t\tndlp->nlp_fcp_info |= CLASS3;\n\n\tndlp->nlp_class_sup = 0;\n\tif (sp->cls1.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS1;\n\tif (sp->cls2.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS2;\n\tif (sp->cls3.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS3;\n\tif (sp->cls4.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS4;\n\tndlp->nlp_maxframe =\n\t\t((sp->cmn.bbRcvSizeMsb & 0x0F) << 8) | sp->cmn.bbRcvSizeLsb;\n\n\tif ((vport->fc_flag & FC_PT2PT) &&\n\t    (vport->fc_flag & FC_PT2PT_PLOGI)) {\n\t\ted_tov = be32_to_cpu(sp->cmn.e_d_tov);\n\t\tif (sp->cmn.edtovResolution) {\n\t\t\t \n\t\t\ted_tov = (phba->fc_edtov + 999999) / 1000000;\n\t\t}\n\n\t\tndlp->nlp_flag &= ~NLP_SUPPRESS_RSP;\n\t\tif ((phba->sli.sli_flag & LPFC_SLI_SUPPRESS_RSP) &&\n\t\t    sp->cmn.valid_vendor_ver_level) {\n\t\t\tvid = be32_to_cpu(sp->un.vv.vid);\n\t\t\tflag = be32_to_cpu(sp->un.vv.flags);\n\t\t\tif ((vid == LPFC_VV_EMLX_ID) &&\n\t\t\t    (flag & LPFC_VV_SUPPRESS_RSP))\n\t\t\t\tndlp->nlp_flag |= NLP_SUPPRESS_RSP;\n\t\t}\n\n\t\t \n\t\tif (ed_tov > phba->fc_edtov)\n\t\t\tphba->fc_edtov = ed_tov;\n\t\tphba->fc_ratov = (2 * phba->fc_edtov) / 1000;\n\n\t\tmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\n\n\t\t \n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tlpfc_issue_reg_vfi(vport);\n\t\t} else {\n\t\t\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\t\tif (!mbox) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\t \"0133 PLOGI: no memory \"\n\t\t\t\t\t\t \"for config_link \"\n\t\t\t\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\t\t ndlp->nlp_DID, ndlp->nlp_state,\n\t\t\t\t\t\t ndlp->nlp_flag, ndlp->nlp_rpi);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlpfc_config_link(phba, mbox);\n\n\t\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\t\tmbox->vport = vport;\n\t\t\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\t\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tlpfc_unreg_rpi(vport, ndlp);\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0018 PLOGI: no memory for reg_login \"\n\t\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ndlp->nlp_state,\n\t\t\t\t ndlp->nlp_flag, ndlp->nlp_rpi);\n\t\tgoto out;\n\t}\n\n\tdid = get_job_els_rsp64_did(phba, cmdiocb);\n\n\tif (lpfc_reg_rpi(phba, vport->vpi, did,\n\t\t\t (uint8_t *) sp, mbox, ndlp->nlp_rpi) == 0) {\n\t\tswitch (ndlp->nlp_DID) {\n\t\tcase NameServer_DID:\n\t\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_ns_reg_login;\n\t\t\t \n\t\t\tmemcpy(&ndlp->fc_sparam, sp, sizeof(struct serv_parm));\n\t\t\tbreak;\n\t\tcase FDMI_DID:\n\t\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_fdmi_reg_login;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tndlp->nlp_flag |= NLP_REG_LOGIN_SEND;\n\t\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;\n\t\t}\n\n\t\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\t\tif (!mbox->ctx_ndlp)\n\t\t\tgoto out;\n\n\t\tmbox->vport = vport;\n\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\n\t\t    != MBX_NOT_FINISHED) {\n\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t   NLP_STE_REG_LOGIN_ISSUE);\n\t\t\treturn ndlp->nlp_state;\n\t\t}\n\t\tif (ndlp->nlp_flag & NLP_REG_LOGIN_SEND)\n\t\t\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\t\t \n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0134 PLOGI: cannot issue reg_login \"\n\t\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ndlp->nlp_state,\n\t\t\t\t ndlp->nlp_flag, ndlp->nlp_rpi);\n\t} else {\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0135 PLOGI: cannot format reg_login \"\n\t\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ndlp->nlp_state,\n\t\t\t\t ndlp->nlp_flag, ndlp->nlp_rpi);\n\t}\n\n\nout:\n\tif (ndlp->nlp_DID == NameServer_DID) {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0261 Cannot Register NameServer login\\n\");\n\t}\n\n\t \n\n\tndlp->nlp_prev_state = ndlp->nlp_state;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\treturn NLP_STE_FREED_NODE;\n}\n\nstatic uint32_t\nlpfc_cmpl_logo_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_reglogin_plogi_issue(struct lpfc_vport *vport,\n\tstruct lpfc_nodelist *ndlp, void *arg, uint32_t evt)\n{\n\tstruct lpfc_hba *phba;\n\tLPFC_MBOXQ_t *pmb = (LPFC_MBOXQ_t *) arg;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tuint16_t rpi;\n\n\tphba = vport->phba;\n\t \n\tif (!(phba->pport->load_flag & FC_UNLOADING) &&\n\t\t!mb->mbxStatus) {\n\t\trpi = pmb->u.mb.un.varWords[0];\n\t\tlpfc_release_rpi(phba, vport, ndlp, rpi);\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_device_rm_plogi_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NODEV_REMOVE;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn ndlp->nlp_state;\n\t} else {\n\t\t \n\t\tlpfc_els_abort(vport->phba, ndlp);\n\n\t\tlpfc_drop_node(vport, ndlp);\n\t\treturn NLP_STE_FREED_NODE;\n\t}\n}\n\nstatic uint32_t\nlpfc_device_recov_plogi_issue(struct lpfc_vport *vport,\n\t\t\t      struct lpfc_nodelist *ndlp,\n\t\t\t      void *arg,\n\t\t\t      uint32_t evt)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\n\t \n\tif (vport->fc_flag & FC_RSCN_DEFERRED)\n\t\treturn ndlp->nlp_state;\n\n\t \n\tlpfc_els_abort(phba, ndlp);\n\n\tndlp->nlp_prev_state = NLP_STE_PLOGI_ISSUE;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\n\tspin_unlock_irq(&ndlp->lock);\n\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_plogi_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb;\n\n\t \n\tlpfc_els_abort(phba, ndlp);\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\n\tif (lpfc_rcv_plogi(vport, ndlp, cmdiocb)) {\n\t\tif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tif (vport->num_disc_nodes)\n\t\t\t\tlpfc_more_adisc(vport);\n\t\t}\n\t\treturn ndlp->nlp_state;\n\t}\n\tndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\n\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tif (lpfc_rcv_prli_support_check(vport, ndlp, cmdiocb))\n\t\tlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\n\t \n\tlpfc_els_abort(phba, ndlp);\n\n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_padisc_adisc_issue(struct lpfc_vport *vport,\n\t\t\t    struct lpfc_nodelist *ndlp,\n\t\t\t    void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_padisc(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prlo_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\n\t \n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_PRLO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_adisc_adisc_issue(struct lpfc_vport *vport,\n\t\t\t    struct lpfc_nodelist *ndlp,\n\t\t\t    void *arg, uint32_t evt)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb, *rspiocb;\n\tADISC *ap;\n\tint rc;\n\tu32 ulp_status;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\trspiocb = cmdiocb->rsp_iocb;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tap = (ADISC *)lpfc_check_elscmpl_iocb(phba, cmdiocb, rspiocb);\n\n\tif ((ulp_status) ||\n\t    (!lpfc_check_adisc(vport, ndlp, &ap->nodeName, &ap->portName))) {\n\t\t \n\t\tmod_timer(&ndlp->nlp_delayfunc,\n\t\t\t  jiffies + msecs_to_jiffies(1000));\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\n\n\t\tndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\tlpfc_unreg_rpi(vport, ndlp);\n\t\treturn ndlp->nlp_state;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\trc = lpfc_sli4_resume_rpi(ndlp, NULL, NULL);\n\t\tif (rc) {\n\t\t\t \n\t\t\tndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\n\t\t\treturn ndlp->nlp_state;\n\t\t}\n\t}\n\n\tif (ndlp->nlp_type & NLP_FCP_TARGET)\n\t\tndlp->nlp_fc4_type |= NLP_FC4_FCP;\n\n\tif (ndlp->nlp_type & NLP_NVME_TARGET)\n\t\tndlp->nlp_fc4_type |= NLP_FC4_NVME;\n\n\tif (ndlp->nlp_type & (NLP_FCP_TARGET | NLP_NVME_TARGET)) {\n\t\tndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_MAPPED_NODE);\n\t} else {\n\t\tndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t}\n\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_device_rm_adisc_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NODEV_REMOVE;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn ndlp->nlp_state;\n\t} else {\n\t\t \n\t\tlpfc_els_abort(vport->phba, ndlp);\n\n\t\tlpfc_drop_node(vport, ndlp);\n\t\treturn NLP_STE_FREED_NODE;\n\t}\n}\n\nstatic uint32_t\nlpfc_device_recov_adisc_issue(struct lpfc_vport *vport,\n\t\t\t      struct lpfc_nodelist *ndlp,\n\t\t\t      void *arg,\n\t\t\t      uint32_t evt)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\n\t \n\tif (vport->fc_flag & FC_RSCN_DEFERRED)\n\t\treturn ndlp->nlp_state;\n\n\t \n\tlpfc_els_abort(phba, ndlp);\n\n\tndlp->nlp_prev_state = NLP_STE_ADISC_ISSUE;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_disc_set_adisc(vport, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_plogi_reglogin_issue(struct lpfc_vport *vport,\n\t\t\t      struct lpfc_nodelist *ndlp,\n\t\t\t      void *arg,\n\t\t\t      uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_plogi(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_reglogin_issue(struct lpfc_vport *vport,\n\t\t\t     struct lpfc_nodelist *ndlp,\n\t\t\t     void *arg,\n\t\t\t     uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\tstruct ls_rjt     stat;\n\n\tif (!lpfc_rcv_prli_support_check(vport, ndlp, cmdiocb)) {\n\t\treturn ndlp->nlp_state;\n\t}\n\tif (vport->phba->nvmet_support) {\n\t\t \n\t\tif (ndlp->nlp_flag & NLP_RPI_REGISTERED) {\n\t\t\tlpfc_rcv_prli(vport, ndlp, cmdiocb);\n\t\t\tlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\n\t\t} else {\n\t\t\t \n\t\t\tmemset(&stat, 0, sizeof(struct ls_rjt));\n\t\t\tstat.un.b.lsRjtRsnCode = LSRJT_LOGICAL_BSY;\n\t\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\n\t\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb,\n\t\t\t\t\t    ndlp, NULL);\n\t\t\treturn ndlp->nlp_state;\n\t\t}\n\t} else {\n\t\t \n\t\tlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_reglogin_issue(struct lpfc_vport *vport,\n\t\t\t     struct lpfc_nodelist *ndlp,\n\t\t\t     void *arg,\n\t\t\t     uint32_t evt)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\tLPFC_MBOXQ_t\t  *mb;\n\tLPFC_MBOXQ_t\t  *nextmb;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\n\t \n\tif ((mb = phba->sli.mbox_active)) {\n\t\tif ((mb->u.mb.mbxCommand == MBX_REG_LOGIN64) &&\n\t\t   (ndlp == (struct lpfc_nodelist *)mb->ctx_ndlp)) {\n\t\t\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tmb->ctx_ndlp = NULL;\n\t\t\tmb->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\t}\n\t}\n\n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(mb, nextmb, &phba->sli.mboxq, list) {\n\t\tif ((mb->u.mb.mbxCommand == MBX_REG_LOGIN64) &&\n\t\t   (ndlp == (struct lpfc_nodelist *)mb->ctx_ndlp)) {\n\t\t\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tlist_del(&mb->list);\n\t\t\tphba->sli.mboxq_cnt--;\n\t\t\tlpfc_mbox_rsrc_cleanup(phba, mb, MBOX_THD_LOCKED);\n\t\t}\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_padisc_reglogin_issue(struct lpfc_vport *vport,\n\t\t\t       struct lpfc_nodelist *ndlp,\n\t\t\t       void *arg,\n\t\t\t       uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_padisc(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prlo_reglogin_issue(struct lpfc_vport *vport,\n\t\t\t     struct lpfc_nodelist *ndlp,\n\t\t\t     void *arg,\n\t\t\t     uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\tlpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_reglogin_reglogin_issue(struct lpfc_vport *vport,\n\t\t\t\t  struct lpfc_nodelist *ndlp,\n\t\t\t\t  void *arg,\n\t\t\t\t  uint32_t evt)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tLPFC_MBOXQ_t *pmb = (LPFC_MBOXQ_t *) arg;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tuint32_t did  = mb->un.varWords[1];\n\n\tif (mb->mbxStatus) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0246 RegLogin failed Data: x%x x%x x%x x%x \"\n\t\t\t\t \"x%x\\n\",\n\t\t\t\t did, mb->mbxStatus, vport->port_state,\n\t\t\t\t mb->un.varRegLogin.vpi,\n\t\t\t\t mb->un.varRegLogin.rpi);\n\t\t \n\t\tif (mb->mbxStatus == MBXERR_RPI_FULL) {\n\t\t\tndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\t\treturn ndlp->nlp_state;\n\t\t}\n\n\t\t \n\t\tmod_timer(&ndlp->nlp_delayfunc,\n\t\t\t  jiffies + msecs_to_jiffies(1000 * 1));\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\n\n\t\tlpfc_issue_els_logo(vport, ndlp, 0);\n\t\treturn ndlp->nlp_state;\n\t}\n\n\t \n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tndlp->nlp_rpi = mb->un.varWords[0];\n\n\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"3066 RegLogin Complete on x%x x%x x%x\\n\",\n\t\t\t did, ndlp->nlp_type, ndlp->nlp_fc4_type);\n\tif (!(ndlp->nlp_type & NLP_FABRIC) &&\n\t    (phba->nvmet_support == 0)) {\n\t\t \n\t\tif (vport->fc_flag & FC_PT2PT) {\n\t\t\t \n\t\t\tndlp->nlp_fc4_type |= NLP_FC4_FCP;\n\t\t\tif ((!(vport->fc_flag & FC_PT2PT_NO_NVME)) &&\n\t\t\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH ||\n\t\t\t    vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) {\n\t\t\t\tndlp->nlp_fc4_type |= NLP_FC4_NVME;\n\t\t\t\t \n\t\t\t\tlpfc_nvme_update_localport(vport);\n\t\t\t}\n\n\t\t} else if (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\tndlp->nlp_fc4_type |= NLP_FC4_FCP;\n\n\t\t} else if (ndlp->nlp_fc4_type == 0) {\n\t\t\t \n\t\t\tif (vport->cfg_enable_fc4_type != LPFC_ENABLE_FCP) {\n\t\t\t\tlpfc_ns_cmd(vport, SLI_CTNS_GFT_ID, 0,\n\t\t\t\t\t    ndlp->nlp_DID);\n\t\t\t\treturn ndlp->nlp_state;\n\t\t\t}\n\t\t\tndlp->nlp_fc4_type = NLP_FC4_FCP;\n\t\t}\n\n\t\tndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);\n\t\tif (lpfc_issue_els_prli(vport, ndlp, 0)) {\n\t\t\tlpfc_issue_els_logo(vport, ndlp, 0);\n\t\t\tndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\t}\n\t} else {\n\t\tif ((vport->fc_flag & FC_PT2PT) && phba->nvmet_support)\n\t\t\tphba->targetport->port_id = vport->fc_myDID;\n\n\t\t \n\t\tif (ndlp->nlp_type & NLP_FABRIC) {\n\t\t\tndlp->nlp_fc4_type &= ~NLP_FC4_FCP;\n\t\t\tndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t\t}\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_device_rm_reglogin_issue(struct lpfc_vport *vport,\n\t\t\t      struct lpfc_nodelist *ndlp,\n\t\t\t      void *arg,\n\t\t\t      uint32_t evt)\n{\n\tif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NODEV_REMOVE;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn ndlp->nlp_state;\n\t} else {\n\t\tlpfc_drop_node(vport, ndlp);\n\t\treturn NLP_STE_FREED_NODE;\n\t}\n}\n\nstatic uint32_t\nlpfc_device_recov_reglogin_issue(struct lpfc_vport *vport,\n\t\t\t\t struct lpfc_nodelist *ndlp,\n\t\t\t\t void *arg,\n\t\t\t\t uint32_t evt)\n{\n\t \n\tif (vport->fc_flag & FC_RSCN_DEFERRED)\n\t\treturn ndlp->nlp_state;\n\n\tndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\tspin_lock_irq(&ndlp->lock);\n\n\t \n\tif (!(ndlp->nlp_flag & NLP_RPI_REGISTERED) ||\n\t    !vport->phba->nvmet_support)\n\t\tndlp->nlp_flag |= NLP_IGNR_REG_CMPL;\n\n\tndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_disc_set_adisc(vport, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_plogi_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_plogi(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tif (!lpfc_rcv_prli_support_check(vport, ndlp, cmdiocb))\n\t\treturn ndlp->nlp_state;\n\tlpfc_rcv_prli(vport, ndlp, cmdiocb);\n\tlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\t \n\tlpfc_els_abort(vport->phba, ndlp);\n\n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_padisc_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_padisc(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\n \nstatic uint32_t\nlpfc_rcv_prlo_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_prli_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb, *rspiocb;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tPRLI *npr;\n\tstruct lpfc_nvme_prli *nvpr;\n\tvoid *temp_ptr;\n\tu32 ulp_status;\n\tbool acc_imode_sps = false;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\trspiocb = cmdiocb->rsp_iocb;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\t \n\tnpr = NULL;\n\tnvpr = NULL;\n\ttemp_ptr = lpfc_check_elscmpl_iocb(phba, cmdiocb, rspiocb);\n\tif (cmdiocb->cmd_flag & LPFC_PRLI_FCP_REQ)\n\t\tnpr = (PRLI *) temp_ptr;\n\telse if (cmdiocb->cmd_flag & LPFC_PRLI_NVME_REQ)\n\t\tnvpr = (struct lpfc_nvme_prli *) temp_ptr;\n\n\tif (ulp_status) {\n\t\tif ((vport->port_type == LPFC_NPIV_PORT) &&\n\t\t    vport->cfg_restrict_login) {\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (npr)\n\t\t\tndlp->nlp_fc4_type &= ~NLP_FC4_FCP;\n\t\tif (nvpr)\n\t\t\tndlp->nlp_fc4_type &= ~NLP_FC4_NVME;\n\n\t\t \n\t\tgoto out_err;\n\t}\n\n\tif (npr && npr->prliType == PRLI_FCP_TYPE) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t LOG_ELS | LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t \"6028 FCP NPR PRLI Cmpl Init %d Target %d \"\n\t\t\t\t \"EIP %d AccCode x%x\\n\",\n\t\t\t\t npr->initiatorFunc, npr->targetFunc,\n\t\t\t\t npr->estabImagePair, npr->acceptRspCode);\n\n\t\tif (npr->acceptRspCode == PRLI_INV_SRV_PARM) {\n\t\t\t \n\t\t\tif (npr->initiatorFunc && !npr->targetFunc &&\n\t\t\t    !npr->estabImagePair)\n\t\t\t\tacc_imode_sps = true;\n\t\t}\n\n\t\tif (npr->acceptRspCode == PRLI_REQ_EXECUTED || acc_imode_sps) {\n\t\t\tif (npr->initiatorFunc)\n\t\t\t\tndlp->nlp_type |= NLP_FCP_INITIATOR;\n\t\t\tif (npr->targetFunc) {\n\t\t\t\tndlp->nlp_type |= NLP_FCP_TARGET;\n\t\t\t\tif (npr->writeXferRdyDis)\n\t\t\t\t\tndlp->nlp_flag |= NLP_FIRSTBURST;\n\t\t\t}\n\t\t\tif (npr->Retry)\n\t\t\t\tndlp->nlp_fcp_info |= NLP_FCP_2_DEVICE;\n\t\t}\n\t} else if (nvpr &&\n\t\t   (bf_get_be32(prli_acc_rsp_code, nvpr) ==\n\t\t    PRLI_REQ_EXECUTED) &&\n\t\t   (bf_get_be32(prli_type_code, nvpr) ==\n\t\t    PRLI_NVME_TYPE)) {\n\n\t\t \n\t\tif (bf_get_be32(prli_init, nvpr))\n\t\t\tndlp->nlp_type |= NLP_NVME_INITIATOR;\n\n\t\tif (phba->nsler && bf_get_be32(prli_nsler, nvpr) &&\n\t\t    bf_get_be32(prli_conf, nvpr))\n\n\t\t\tndlp->nlp_nvme_info |= NLP_NVME_NSLER;\n\t\telse\n\t\t\tndlp->nlp_nvme_info &= ~NLP_NVME_NSLER;\n\n\t\t \n\t\tif (bf_get_be32(prli_tgt, nvpr)) {\n\t\t\t \n\t\t\tndlp->nlp_type |= NLP_NVME_TARGET;\n\t\t\tif (bf_get_be32(prli_disc, nvpr))\n\t\t\t\tndlp->nlp_type |= NLP_NVME_DISCOVERY;\n\n\t\t\t \n\t\t\tif ((bf_get_be32(prli_fba, nvpr) == 1) &&\n\t\t\t    (phba->cfg_nvme_enable_fb) &&\n\t\t\t    (!phba->nvmet_support)) {\n\t\t\t\t \n\t\t\t\tndlp->nlp_flag |= NLP_FIRSTBURST;\n\t\t\t\tndlp->nvme_fb_size = bf_get_be32(prli_fb_sz,\n\t\t\t\t\t\t\t\t nvpr);\n\n\t\t\t\t \n\t\t\t\tif (ndlp->nvme_fb_size)\n\t\t\t\t\tndlp->nvme_fb_size <<=\n\t\t\t\t\t\tLPFC_NVME_FB_SHIFT;\n\t\t\t\telse\n\t\t\t\t\tndlp->nvme_fb_size = LPFC_NVME_MAX_FB;\n\t\t\t}\n\t\t}\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t\t \"6029 NVME PRLI Cmpl w1 x%08x \"\n\t\t\t\t \"w4 x%08x w5 x%08x flag x%x, \"\n\t\t\t\t \"fcp_info x%x nlp_type x%x\\n\",\n\t\t\t\t be32_to_cpu(nvpr->word1),\n\t\t\t\t be32_to_cpu(nvpr->word4),\n\t\t\t\t be32_to_cpu(nvpr->word5),\n\t\t\t\t ndlp->nlp_flag, ndlp->nlp_fcp_info,\n\t\t\t\t ndlp->nlp_type);\n\t}\n\tif (!(ndlp->nlp_type & NLP_FCP_TARGET) &&\n\t    (vport->port_type == LPFC_NPIV_PORT) &&\n\t     vport->cfg_restrict_login) {\nout:\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_TARGET_REMOVE;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tlpfc_issue_els_logo(vport, ndlp, 0);\n\n\t\tndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\treturn ndlp->nlp_state;\n\t}\n\nout_err:\n\t \n\tif (ndlp->fc4_prli_sent == 0) {\n\t\tndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;\n\t\tif (ndlp->nlp_type & (NLP_FCP_TARGET | NLP_NVME_TARGET))\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_MAPPED_NODE);\n\t\telse if (ndlp->nlp_type &\n\t\t\t (NLP_FCP_INITIATOR | NLP_NVME_INITIATOR))\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t} else\n\t\tlpfc_printf_vlog(vport,\n\t\t\t\t KERN_INFO, LOG_ELS,\n\t\t\t\t \"3067 PRLI's still outstanding \"\n\t\t\t\t \"on x%06x - count %d, Pend Node Mode \"\n\t\t\t\t \"transition...\\n\",\n\t\t\t\t ndlp->nlp_DID, ndlp->fc4_prli_sent);\n\n\treturn ndlp->nlp_state;\n}\n\n \n\nstatic uint32_t\nlpfc_device_rm_prli_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NODEV_REMOVE;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn ndlp->nlp_state;\n\t} else {\n\t\t \n\t\tlpfc_els_abort(vport->phba, ndlp);\n\n\t\tlpfc_drop_node(vport, ndlp);\n\t\treturn NLP_STE_FREED_NODE;\n\t}\n}\n\n\n \nstatic uint32_t\nlpfc_device_recov_prli_issue(struct lpfc_vport *vport,\n\t\t\t     struct lpfc_nodelist *ndlp,\n\t\t\t     void *arg,\n\t\t\t     uint32_t evt)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\n\t \n\tif (vport->fc_flag & FC_RSCN_DEFERRED)\n\t\treturn ndlp->nlp_state;\n\n\t \n\tlpfc_els_abort(phba, ndlp);\n\n\tndlp->nlp_prev_state = NLP_STE_PRLI_ISSUE;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_disc_set_adisc(vport, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_plogi_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\n\tstruct ls_rjt     stat;\n\n\tmemset(&stat, 0, sizeof(struct ls_rjt));\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\n\tstruct ls_rjt     stat;\n\n\tmemset(&stat, 0, sizeof(struct ls_rjt));\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_LOGO_ACC;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_padisc_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\n\tstruct ls_rjt     stat;\n\n\tmemset(&stat, 0, sizeof(struct ls_rjt));\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prlo_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *)arg;\n\tstruct ls_rjt     stat;\n\n\tmemset(&stat, 0, sizeof(struct ls_rjt));\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_logo_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tndlp->nlp_prev_state = NLP_STE_LOGO_ISSUE;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_disc_set_adisc(vport, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_device_rm_logo_issue(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\t \n\n\tlpfc_unreg_rpi(vport, ndlp);\n\t \n\tlpfc_els_abort(vport->phba, ndlp);\n\tlpfc_drop_node(vport, ndlp);\n\treturn NLP_STE_FREED_NODE;\n}\n\nstatic uint32_t\nlpfc_device_recov_logo_issue(struct lpfc_vport *vport,\n\t\t\t     struct lpfc_nodelist *ndlp,\n\t\t\t     void *arg, uint32_t evt)\n{\n\t \n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_plogi_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_plogi(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tif (!lpfc_rcv_prli_support_check(vport, ndlp, cmdiocb))\n\t\treturn ndlp->nlp_state;\n\n\tlpfc_rcv_prli(vport, ndlp, cmdiocb);\n\tlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_padisc_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_padisc(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prlo_unmap_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_els_rsp_acc(vport, ELS_CMD_PRLO, cmdiocb, ndlp, NULL);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_device_rm_unmap_node(struct lpfc_vport *vport,\n\t\t\t  struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg,\n\t\t\t  uint32_t evt)\n{\n\tlpfc_drop_node(vport, ndlp);\n\treturn NLP_STE_FREED_NODE;\n}\n\nstatic uint32_t\nlpfc_device_recov_unmap_node(struct lpfc_vport *vport,\n\t\t\t     struct lpfc_nodelist *ndlp,\n\t\t\t     void *arg,\n\t\t\t     uint32_t evt)\n{\n\tndlp->nlp_prev_state = NLP_STE_UNMAPPED_NODE;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\n\tndlp->nlp_fc4_type &= ~(NLP_FC4_FCP | NLP_FC4_NVME);\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_disc_set_adisc(vport, ndlp);\n\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_plogi_mapped_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_plogi(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_mapped_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tif (!lpfc_rcv_prli_support_check(vport, ndlp, cmdiocb))\n\t\treturn ndlp->nlp_state;\n\tlpfc_els_rsp_prli_acc(vport, cmdiocb, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_mapped_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_padisc_mapped_node(struct lpfc_vport *vport,\n\t\t\t    struct lpfc_nodelist *ndlp,\n\t\t\t    void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_padisc(vport, ndlp, cmdiocb);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prlo_mapped_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\t \n\tlpfc_sli_abort_iocb(vport, ndlp->nlp_sid, 0, LPFC_CTX_TGT);\n\n\t \n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_PRLO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_device_recov_mapped_node(struct lpfc_vport *vport,\n\t\t\t      struct lpfc_nodelist *ndlp,\n\t\t\t      void *arg,\n\t\t\t      uint32_t evt)\n{\n\tlpfc_disc_set_adisc(vport, ndlp);\n\n\tndlp->nlp_prev_state = NLP_STE_MAPPED_NODE;\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\n\tndlp->nlp_fc4_type &= ~(NLP_FC4_FCP | NLP_FC4_NVME);\n\tspin_unlock_irq(&ndlp->lock);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_plogi_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\tvoid *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb  = (struct lpfc_iocbq *) arg;\n\n\t \n\tif (ndlp->nlp_flag & (NLP_LOGO_SND | NLP_LOGO_ACC))\n\t\treturn ndlp->nlp_state;\n\tif (lpfc_rcv_plogi(vport, ndlp, cmdiocb)) {\n\t\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~(NLP_NPR_ADISC | NLP_NPR_2B_DISC);\n\t\tspin_unlock_irq(&ndlp->lock);\n\t} else if (!(ndlp->nlp_flag & NLP_NPR_2B_DISC)) {\n\t\t \n\t\tif (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {\n\t\t\tndlp->nlp_prev_state = NLP_STE_NPR_NODE;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\t\t}\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prli_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t       void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\tstruct ls_rjt     stat;\n\n\tmemset(&stat, 0, sizeof (struct ls_rjt));\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_NOTHING_MORE;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\n\tif (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {\n\t\t \n\t\tif (!(ndlp->nlp_flag & NLP_NPR_ADISC)) {\n\t\t\tndlp->nlp_prev_state = NLP_STE_NPR_NODE;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\t\t}\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_logo_npr_node(struct lpfc_vport *vport,  struct lpfc_nodelist *ndlp,\n\t\t       void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_logo(vport, ndlp, cmdiocb, ELS_CMD_LOGO);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_padisc_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tlpfc_rcv_padisc(vport, ndlp, cmdiocb);\n\t \n\tif (!(ndlp->nlp_flag & NLP_DELAY_TMO) &&\n\t    !(ndlp->nlp_flag & NLP_NPR_2B_DISC)) {\n\t\t \n\t\tif (!(ndlp->nlp_flag & NLP_NPR_ADISC)) {\n\t\t\tndlp->nlp_prev_state = NLP_STE_NPR_NODE;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\t\t}\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_rcv_prlo_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t       void *arg, uint32_t evt)\n{\n\tstruct lpfc_iocbq *cmdiocb = (struct lpfc_iocbq *) arg;\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_LOGO_ACC;\n\tspin_unlock_irq(&ndlp->lock);\n\n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\n\tif ((ndlp->nlp_flag & NLP_DELAY_TMO) == 0) {\n\t\tmod_timer(&ndlp->nlp_delayfunc,\n\t\t\t  jiffies + msecs_to_jiffies(1000 * 1));\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\t\tndlp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tndlp->nlp_last_elscmd = ELS_CMD_PLOGI;\n\t} else {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_plogi_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb, *rspiocb;\n\tu32 ulp_status;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\trspiocb = cmdiocb->rsp_iocb;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ulp_status)\n\t\treturn NLP_STE_FREED_NODE;\n\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_prli_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\tvoid *arg, uint32_t evt)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb, *rspiocb;\n\tu32 ulp_status;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\trspiocb = cmdiocb->rsp_iocb;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ulp_status && (ndlp->nlp_flag & NLP_NODEV_REMOVE)) {\n\t\tlpfc_drop_node(vport, ndlp);\n\t\treturn NLP_STE_FREED_NODE;\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_logo_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\tvoid *arg, uint32_t evt)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\t \n\tif (ndlp->nlp_DID == Fabric_DID) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\tlpfc_unreg_rpi(vport, ndlp);\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_adisc_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t void *arg, uint32_t evt)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb, *rspiocb;\n\tu32 ulp_status;\n\n\tcmdiocb = (struct lpfc_iocbq *) arg;\n\trspiocb = cmdiocb->rsp_iocb;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ulp_status && (ndlp->nlp_flag & NLP_NODEV_REMOVE)) {\n\t\tlpfc_drop_node(vport, ndlp);\n\t\treturn NLP_STE_FREED_NODE;\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_cmpl_reglogin_npr_node(struct lpfc_vport *vport,\n\t\t\t    struct lpfc_nodelist *ndlp,\n\t\t\t    void *arg, uint32_t evt)\n{\n\tLPFC_MBOXQ_t *pmb = (LPFC_MBOXQ_t *) arg;\n\tMAILBOX_t    *mb = &pmb->u.mb;\n\n\tif (!mb->mbxStatus) {\n\t\t \n\t\tif (vport->phba->sli_rev < LPFC_SLI_REV4)\n\t\t\tndlp->nlp_rpi = mb->un.varWords[0];\n\t\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\t\tif (ndlp->nlp_flag & NLP_LOGO_ACC) {\n\t\t\tlpfc_unreg_rpi(vport, ndlp);\n\t\t}\n\t} else {\n\t\tif (ndlp->nlp_flag & NLP_NODEV_REMOVE) {\n\t\t\tlpfc_drop_node(vport, ndlp);\n\t\t\treturn NLP_STE_FREED_NODE;\n\t\t}\n\t}\n\treturn ndlp->nlp_state;\n}\n\nstatic uint32_t\nlpfc_device_rm_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\tvoid *arg, uint32_t evt)\n{\n\tif (ndlp->nlp_flag & NLP_NPR_2B_DISC) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NODEV_REMOVE;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn ndlp->nlp_state;\n\t}\n\tlpfc_drop_node(vport, ndlp);\n\treturn NLP_STE_FREED_NODE;\n}\n\nstatic uint32_t\nlpfc_device_recov_npr_node(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   void *arg, uint32_t evt)\n{\n\t \n\tif (vport->fc_flag & FC_RSCN_DEFERRED)\n\t\treturn ndlp->nlp_state;\n\n\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~(NLP_NODEV_REMOVE | NLP_NPR_2B_DISC);\n\tndlp->nlp_fc4_type &= ~(NLP_FC4_FCP | NLP_FC4_NVME);\n\tspin_unlock_irq(&ndlp->lock);\n\treturn ndlp->nlp_state;\n}\n\n\n \n\n \n \n \n \n \n\nstatic uint32_t (*lpfc_disc_action[NLP_STE_MAX_STATE * NLP_EVT_MAX_EVENT])\n     (struct lpfc_vport *, struct lpfc_nodelist *, void *, uint32_t) = {\n\t \n\tlpfc_rcv_plogi_unused_node,\t \n\tlpfc_rcv_els_unused_node,\t \n\tlpfc_rcv_logo_unused_node,\t \n\tlpfc_rcv_els_unused_node,\t \n\tlpfc_rcv_els_unused_node,\t \n\tlpfc_rcv_els_unused_node,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_cmpl_logo_unused_node,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_device_rm_unused_node,\t \n\tlpfc_device_recov_unused_node,\t \n\n\tlpfc_rcv_plogi_plogi_issue,\t \n\tlpfc_rcv_prli_plogi_issue,\t \n\tlpfc_rcv_logo_plogi_issue,\t \n\tlpfc_rcv_els_plogi_issue,\t \n\tlpfc_rcv_els_plogi_issue,\t \n\tlpfc_rcv_els_plogi_issue,\t \n\tlpfc_cmpl_plogi_plogi_issue,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_cmpl_logo_plogi_issue,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_cmpl_reglogin_plogi_issue, \n\tlpfc_device_rm_plogi_issue,\t \n\tlpfc_device_recov_plogi_issue,\t \n\n\tlpfc_rcv_plogi_adisc_issue,\t \n\tlpfc_rcv_prli_adisc_issue,\t \n\tlpfc_rcv_logo_adisc_issue,\t \n\tlpfc_rcv_padisc_adisc_issue,\t \n\tlpfc_rcv_padisc_adisc_issue,\t \n\tlpfc_rcv_prlo_adisc_issue,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_cmpl_adisc_adisc_issue,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_device_rm_adisc_issue,\t \n\tlpfc_device_recov_adisc_issue,\t \n\n\tlpfc_rcv_plogi_reglogin_issue,\t \n\tlpfc_rcv_prli_reglogin_issue,\t \n\tlpfc_rcv_logo_reglogin_issue,\t \n\tlpfc_rcv_padisc_reglogin_issue,\t \n\tlpfc_rcv_padisc_reglogin_issue,\t \n\tlpfc_rcv_prlo_reglogin_issue,\t \n\tlpfc_cmpl_plogi_illegal,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_cmpl_reglogin_reglogin_issue, \n\tlpfc_device_rm_reglogin_issue,\t \n\tlpfc_device_recov_reglogin_issue, \n\n\tlpfc_rcv_plogi_prli_issue,\t \n\tlpfc_rcv_prli_prli_issue,\t \n\tlpfc_rcv_logo_prli_issue,\t \n\tlpfc_rcv_padisc_prli_issue,\t \n\tlpfc_rcv_padisc_prli_issue,\t \n\tlpfc_rcv_prlo_prli_issue,\t \n\tlpfc_cmpl_plogi_illegal,\t \n\tlpfc_cmpl_prli_prli_issue,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_device_rm_prli_issue,\t \n\tlpfc_device_recov_prli_issue,\t \n\n\tlpfc_rcv_plogi_logo_issue,\t \n\tlpfc_rcv_prli_logo_issue,\t \n\tlpfc_rcv_logo_logo_issue,\t \n\tlpfc_rcv_padisc_logo_issue,\t \n\tlpfc_rcv_padisc_logo_issue,\t \n\tlpfc_rcv_prlo_logo_issue,\t \n\tlpfc_cmpl_plogi_illegal,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_cmpl_logo_logo_issue,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_device_rm_logo_issue,\t \n\tlpfc_device_recov_logo_issue,\t \n\n\tlpfc_rcv_plogi_unmap_node,\t \n\tlpfc_rcv_prli_unmap_node,\t \n\tlpfc_rcv_logo_unmap_node,\t \n\tlpfc_rcv_padisc_unmap_node,\t \n\tlpfc_rcv_padisc_unmap_node,\t \n\tlpfc_rcv_prlo_unmap_node,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_device_rm_unmap_node,\t \n\tlpfc_device_recov_unmap_node,\t \n\n\tlpfc_rcv_plogi_mapped_node,\t \n\tlpfc_rcv_prli_mapped_node,\t \n\tlpfc_rcv_logo_mapped_node,\t \n\tlpfc_rcv_padisc_mapped_node,\t \n\tlpfc_rcv_padisc_mapped_node,\t \n\tlpfc_rcv_prlo_mapped_node,\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_disc_illegal,\t\t \n\tlpfc_device_recov_mapped_node,\t \n\n\tlpfc_rcv_plogi_npr_node,         \n\tlpfc_rcv_prli_npr_node,          \n\tlpfc_rcv_logo_npr_node,          \n\tlpfc_rcv_padisc_npr_node,        \n\tlpfc_rcv_padisc_npr_node,        \n\tlpfc_rcv_prlo_npr_node,          \n\tlpfc_cmpl_plogi_npr_node,\t \n\tlpfc_cmpl_prli_npr_node,\t \n\tlpfc_cmpl_logo_npr_node,         \n\tlpfc_cmpl_adisc_npr_node,        \n\tlpfc_cmpl_reglogin_npr_node,     \n\tlpfc_device_rm_npr_node,         \n\tlpfc_device_recov_npr_node,      \n};\n\nint\nlpfc_disc_state_machine(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\tvoid *arg, uint32_t evt)\n{\n\tuint32_t cur_state, rc;\n\tuint32_t(*func) (struct lpfc_vport *, struct lpfc_nodelist *, void *,\n\t\t\t uint32_t);\n\tuint32_t got_ndlp = 0;\n\tuint32_t data1;\n\n\tif (lpfc_nlp_get(ndlp))\n\t\tgot_ndlp = 1;\n\n\tcur_state = ndlp->nlp_state;\n\n\tdata1 = (((uint32_t)ndlp->nlp_fc4_type << 16) |\n\t\t((uint32_t)ndlp->nlp_type));\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0211 DSM in event x%x on NPort x%x in \"\n\t\t\t \"state %d rpi x%x Data: x%x x%x\\n\",\n\t\t\t evt, ndlp->nlp_DID, cur_state, ndlp->nlp_rpi,\n\t\t\t ndlp->nlp_flag, data1);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_DSM,\n\t\t \"DSM in:          evt:%d ste:%d did:x%x\",\n\t\tevt, cur_state, ndlp->nlp_DID);\n\n\tfunc = lpfc_disc_action[(cur_state * NLP_EVT_MAX_EVENT) + evt];\n\trc = (func) (vport, ndlp, arg, evt);\n\n\t \n\tif (got_ndlp) {\n\t\tdata1 = (((uint32_t)ndlp->nlp_fc4_type << 16) |\n\t\t\t((uint32_t)ndlp->nlp_type));\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0212 DSM out state %d on NPort x%x \"\n\t\t\t \"rpi x%x Data: x%x x%x\\n\",\n\t\t\t rc, ndlp->nlp_DID, ndlp->nlp_rpi, ndlp->nlp_flag,\n\t\t\t data1);\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_DSM,\n\t\t\t\"DSM out:         ste:%d did:x%x flg:x%x\",\n\t\t\trc, ndlp->nlp_DID, ndlp->nlp_flag);\n\t\t \n\t\tlpfc_nlp_put(ndlp);\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\"0213 DSM out state %d on NPort free\\n\", rc);\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_DSM,\n\t\t\t\"DSM out:         ste:%d did:x%x flg:x%x\",\n\t\t\trc, 0, 0);\n\t}\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}