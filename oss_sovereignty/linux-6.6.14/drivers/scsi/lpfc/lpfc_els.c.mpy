{
  "module_name": "lpfc_els.c",
  "hash_id": "2a47b11d022b8c65a63b7ecf2c084e070983ed67fd7d3efeee6bbb1f864ce2c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_els.c",
  "human_readable_source": " \n \n#include <linux/blkdev.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n#include <uapi/scsi/fc/fc_fs.h>\n#include <uapi/scsi/fc/fc_els.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_debugfs.h\"\n\nstatic int lpfc_els_retry(struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t\t  struct lpfc_iocbq *);\nstatic void lpfc_cmpl_fabric_iocb(struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t\tstruct lpfc_iocbq *);\nstatic void lpfc_fabric_abort_vport(struct lpfc_vport *vport);\nstatic int lpfc_issue_els_fdisc(struct lpfc_vport *vport,\n\t\t\t\tstruct lpfc_nodelist *ndlp, uint8_t retry);\nstatic int lpfc_issue_fabric_iocb(struct lpfc_hba *phba,\n\t\t\t\t  struct lpfc_iocbq *iocb);\nstatic void lpfc_cmpl_els_edc(struct lpfc_hba *phba,\n\t\t\t      struct lpfc_iocbq *cmdiocb,\n\t\t\t      struct lpfc_iocbq *rspiocb);\nstatic void lpfc_cmpl_els_uvem(struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t\t       struct lpfc_iocbq *);\n\nstatic int lpfc_max_els_tries = 3;\n\nstatic void lpfc_init_cs_ctl_bitmap(struct lpfc_vport *vport);\nstatic void lpfc_vmid_set_cs_ctl_range(struct lpfc_vport *vport, u32 min, u32 max);\nstatic void lpfc_vmid_put_cs_ctl(struct lpfc_vport *vport, u32 ctcl_vmid);\n\n \nint\nlpfc_els_chk_latt(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tuint32_t ha_copy;\n\n\tif (vport->port_state >= LPFC_VPORT_READY ||\n\t    phba->link_state == LPFC_LINK_DOWN ||\n\t    phba->sli_rev > LPFC_SLI_REV3)\n\t\treturn 0;\n\n\t \n\tif (lpfc_readl(phba->HAregaddr, &ha_copy))\n\t\treturn 1;\n\n\tif (!(ha_copy & HA_LATT))\n\t\treturn 0;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0237 Pending Link Event during \"\n\t\t\t \"Discovery: State x%x\\n\",\n\t\t\t phba->pport->port_state);\n\n\t \n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag |= FC_ABORT_DISCOVERY;\n\tspin_unlock_irq(shost->host_lock);\n\n\tif (phba->link_state != LPFC_CLEAR_LA)\n\t\tlpfc_issue_clear_la(phba, vport);\n\n\treturn 1;\n}\n\n \nstruct lpfc_iocbq *\nlpfc_prep_els_iocb(struct lpfc_vport *vport, u8 expect_rsp,\n\t\t   u16 cmd_size, u8 retry,\n\t\t   struct lpfc_nodelist *ndlp, u32 did,\n\t\t   u32 elscmd)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_dmabuf *pcmd, *prsp, *pbuflist, *bmp;\n\tstruct ulp_bde64_le *bpl;\n\tu32 timeout = 0;\n\n\tif (!lpfc_is_link_up(phba))\n\t\treturn NULL;\n\n\t \n\telsiocb = lpfc_sli_get_iocbq(phba);\n\tif (!elsiocb)\n\t\treturn NULL;\n\n\t \n\tif ((did == Fabric_DID) &&\n\t    (phba->hba_flag & HBA_FIP_SUPPORT) &&\n\t    ((elscmd == ELS_CMD_FLOGI) ||\n\t     (elscmd == ELS_CMD_FDISC) ||\n\t     (elscmd == ELS_CMD_LOGO)))\n\t\tswitch (elscmd) {\n\t\tcase ELS_CMD_FLOGI:\n\t\t\telsiocb->cmd_flag |=\n\t\t\t\t((LPFC_ELS_ID_FLOGI << LPFC_FIP_ELS_ID_SHIFT)\n\t\t\t\t & LPFC_FIP_ELS_ID_MASK);\n\t\t\tbreak;\n\t\tcase ELS_CMD_FDISC:\n\t\t\telsiocb->cmd_flag |=\n\t\t\t\t((LPFC_ELS_ID_FDISC << LPFC_FIP_ELS_ID_SHIFT)\n\t\t\t\t & LPFC_FIP_ELS_ID_MASK);\n\t\t\tbreak;\n\t\tcase ELS_CMD_LOGO:\n\t\t\telsiocb->cmd_flag |=\n\t\t\t\t((LPFC_ELS_ID_LOGO << LPFC_FIP_ELS_ID_SHIFT)\n\t\t\t\t & LPFC_FIP_ELS_ID_MASK);\n\t\t\tbreak;\n\t\t}\n\telse\n\t\telsiocb->cmd_flag &= ~LPFC_FIP_ELS_ID_MASK;\n\n\t \n\t \n\tpcmd = kmalloc(sizeof(*pcmd), GFP_KERNEL);\n\tif (pcmd)\n\t\tpcmd->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &pcmd->phys);\n\tif (!pcmd || !pcmd->virt)\n\t\tgoto els_iocb_free_pcmb_exit;\n\n\tINIT_LIST_HEAD(&pcmd->list);\n\n\t \n\tif (expect_rsp) {\n\t\tprsp = kmalloc(sizeof(*prsp), GFP_KERNEL);\n\t\tif (prsp)\n\t\t\tprsp->virt = lpfc_mbuf_alloc(phba, MEM_PRI,\n\t\t\t\t\t\t     &prsp->phys);\n\t\tif (!prsp || !prsp->virt)\n\t\t\tgoto els_iocb_free_prsp_exit;\n\t\tINIT_LIST_HEAD(&prsp->list);\n\t} else {\n\t\tprsp = NULL;\n\t}\n\n\t \n\tpbuflist = kmalloc(sizeof(*pbuflist), GFP_KERNEL);\n\tif (pbuflist)\n\t\tpbuflist->virt = lpfc_mbuf_alloc(phba, MEM_PRI,\n\t\t\t\t\t\t &pbuflist->phys);\n\tif (!pbuflist || !pbuflist->virt)\n\t\tgoto els_iocb_free_pbuf_exit;\n\n\tINIT_LIST_HEAD(&pbuflist->list);\n\n\tif (expect_rsp) {\n\t\tswitch (elscmd) {\n\t\tcase ELS_CMD_FLOGI:\n\t\t\ttimeout = FF_DEF_RATOV * 2;\n\t\t\tbreak;\n\t\tcase ELS_CMD_LOGO:\n\t\t\ttimeout = phba->fc_ratov;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttimeout = phba->fc_ratov * 2;\n\t\t}\n\n\t\t \n\t\telsiocb->num_bdes = 2;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tbmp = pcmd;\n\telse\n\t\tbmp = pbuflist;\n\n\tlpfc_sli_prep_els_req_rsp(phba, elsiocb, vport, bmp, cmd_size, did,\n\t\t\t\t  elscmd, timeout, expect_rsp);\n\n\tbpl = (struct ulp_bde64_le *)pbuflist->virt;\n\tbpl->addr_low = cpu_to_le32(putPaddrLow(pcmd->phys));\n\tbpl->addr_high = cpu_to_le32(putPaddrHigh(pcmd->phys));\n\tbpl->type_size = cpu_to_le32(cmd_size);\n\tbpl->type_size |= cpu_to_le32(ULP_BDE64_TYPE_BDE_64);\n\n\tif (expect_rsp) {\n\t\tbpl++;\n\t\tbpl->addr_low = cpu_to_le32(putPaddrLow(prsp->phys));\n\t\tbpl->addr_high = cpu_to_le32(putPaddrHigh(prsp->phys));\n\t\tbpl->type_size = cpu_to_le32(FCELSSIZE);\n\t\tbpl->type_size |= cpu_to_le32(ULP_BDE64_TYPE_BDE_64);\n\t}\n\n\telsiocb->cmd_dmabuf = pcmd;\n\telsiocb->bpl_dmabuf = pbuflist;\n\telsiocb->retry = retry;\n\telsiocb->vport = vport;\n\telsiocb->drvrTimeout = (phba->fc_ratov << 1) + LPFC_DRVR_TIMEOUT;\n\n\tif (prsp)\n\t\tlist_add(&prsp->list, &pcmd->list);\n\tif (expect_rsp) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"0116 Xmit ELS command x%x to remote \"\n\t\t\t\t \"NPORT x%x I/O tag: x%x, port state:x%x \"\n\t\t\t\t \"rpi x%x fc_flag:x%x\\n\",\n\t\t\t\t elscmd, did, elsiocb->iotag,\n\t\t\t\t vport->port_state, ndlp->nlp_rpi,\n\t\t\t\t vport->fc_flag);\n\t} else {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"0117 Xmit ELS response x%x to remote \"\n\t\t\t\t \"NPORT x%x I/O tag: x%x, size: x%x \"\n\t\t\t\t \"port_state x%x  rpi x%x fc_flag x%x\\n\",\n\t\t\t\t elscmd, ndlp->nlp_DID, elsiocb->iotag,\n\t\t\t\t cmd_size, vport->port_state,\n\t\t\t\t ndlp->nlp_rpi, vport->fc_flag);\n\t}\n\n\treturn elsiocb;\n\nels_iocb_free_pbuf_exit:\n\tif (expect_rsp)\n\t\tlpfc_mbuf_free(phba, prsp->virt, prsp->phys);\n\tkfree(pbuflist);\n\nels_iocb_free_prsp_exit:\n\tlpfc_mbuf_free(phba, pcmd->virt, pcmd->phys);\n\tkfree(prsp);\n\nels_iocb_free_pcmb_exit:\n\tkfree(pcmd);\n\tlpfc_sli_release_iocbq(phba, elsiocb);\n\treturn NULL;\n}\n\n \nint\nlpfc_issue_fabric_reglogin(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct serv_parm *sp;\n\tint rc;\n\tint err = 0;\n\n\tsp = &phba->fc_fabparam;\n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp) {\n\t\terr = 1;\n\t\tgoto fail;\n\t}\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\terr = 2;\n\t\tgoto fail;\n\t}\n\n\tvport->port_state = LPFC_FABRIC_CFG_LINK;\n\tlpfc_config_link(phba, mbox);\n\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\tmbox->vport = vport;\n\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\terr = 3;\n\t\tgoto fail_free_mbox;\n\t}\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\terr = 4;\n\t\tgoto fail;\n\t}\n\trc = lpfc_reg_rpi(phba, vport->vpi, Fabric_DID, (uint8_t *)sp, mbox,\n\t\t\t  ndlp->nlp_rpi);\n\tif (rc) {\n\t\terr = 5;\n\t\tgoto fail_free_mbox;\n\t}\n\n\tmbox->mbox_cmpl = lpfc_mbx_cmpl_fabric_reg_login;\n\tmbox->vport = vport;\n\t \n\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\tif (!mbox->ctx_ndlp) {\n\t\terr = 6;\n\t\tgoto fail_free_mbox;\n\t}\n\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\terr = 7;\n\t\tgoto fail_issue_reg_login;\n\t}\n\n\treturn 0;\n\nfail_issue_reg_login:\n\t \n\tlpfc_nlp_put(ndlp);\nfail_free_mbox:\n\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\nfail:\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0249 Cannot issue Register Fabric login: Err %d\\n\",\n\t\t\t err);\n\treturn -ENXIO;\n}\n\n \nint\nlpfc_issue_reg_vfi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tLPFC_MBOXQ_t *mboxq = NULL;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_dmabuf *dmabuf = NULL;\n\tint rc = 0;\n\n\t \n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    !(phba->link_flag & LS_LOOPBACK_MODE) &&\n\t    !(vport->fc_flag & FC_PT2PT)) {\n\t\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\t\tif (!ndlp) {\n\t\t\trc = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mboxq) {\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tif ((vport->fc_flag & FC_FABRIC) || (vport->fc_flag & FC_PT2PT)) {\n\t\trc = lpfc_mbox_rsrc_prep(phba, mboxq);\n\t\tif (rc) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail_mbox;\n\t\t}\n\t\tdmabuf = mboxq->ctx_buf;\n\t\tmemcpy(dmabuf->virt, &phba->fc_fabparam,\n\t\t       sizeof(struct serv_parm));\n\t}\n\n\tvport->port_state = LPFC_FABRIC_CFG_LINK;\n\tif (dmabuf) {\n\t\tlpfc_reg_vfi(mboxq, vport, dmabuf->phys);\n\t\t \n\t\tmboxq->ctx_buf = dmabuf;\n\t} else {\n\t\tlpfc_reg_vfi(mboxq, vport, 0);\n\t}\n\n\tmboxq->mbox_cmpl = lpfc_mbx_cmpl_reg_vfi;\n\tmboxq->vport = vport;\n\trc = lpfc_sli_issue_mbox(phba, mboxq, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\trc = -ENXIO;\n\t\tgoto fail_mbox;\n\t}\n\treturn 0;\n\nfail_mbox:\n\tlpfc_mbox_rsrc_cleanup(phba, mboxq, MBOX_THD_UNLOCKED);\nfail:\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0289 Issue Register VFI failed: Err %d\\n\", rc);\n\treturn rc;\n}\n\n \nint\nlpfc_issue_unreg_vfi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct Scsi_Host *shost;\n\tLPFC_MBOXQ_t *mboxq;\n\tint rc;\n\n\tmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mboxq) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2556 UNREG_VFI mbox allocation failed\"\n\t\t\t\t\"HBA state x%x\\n\", phba->pport->port_state);\n\t\treturn -ENOMEM;\n\t}\n\n\tlpfc_unreg_vfi(mboxq, vport);\n\tmboxq->vport = vport;\n\tmboxq->mbox_cmpl = lpfc_unregister_vfi_cmpl;\n\n\trc = lpfc_sli_issue_mbox(phba, mboxq, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2557 UNREG_VFI issue mbox failed rc x%x \"\n\t\t\t\t\"HBA state x%x\\n\",\n\t\t\t\trc, phba->pport->port_state);\n\t\tmempool_free(mboxq, phba->mbox_mem_pool);\n\t\treturn -EIO;\n\t}\n\n\tshost = lpfc_shost_from_vport(vport);\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VFI_REGISTERED;\n\tspin_unlock_irq(shost->host_lock);\n\treturn 0;\n}\n\n \nstatic uint8_t\nlpfc_check_clean_addr_bit(struct lpfc_vport *vport,\n\t\tstruct serv_parm *sp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tuint8_t fabric_param_changed = 0;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif ((vport->fc_prevDID != vport->fc_myDID) ||\n\t\tmemcmp(&vport->fabric_portname, &sp->portName,\n\t\t\tsizeof(struct lpfc_name)) ||\n\t\tmemcmp(&vport->fabric_nodename, &sp->nodeName,\n\t\t\tsizeof(struct lpfc_name)) ||\n\t\t(vport->vport_flag & FAWWPN_PARAM_CHG)) {\n\t\tfabric_param_changed = 1;\n\t\tvport->vport_flag &= ~FAWWPN_PARAM_CHG;\n\t}\n\t \n\tif (fabric_param_changed && !sp->cmn.clean_address_bit &&\n\t    (vport->fc_prevDID || phba->cfg_delay_discovery)) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_DISC_DELAYED;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\n\treturn fabric_param_changed;\n}\n\n\n \nstatic int\nlpfc_cmpl_els_flogi_fabric(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t   struct serv_parm *sp, uint32_t ulp_word4)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_nodelist *np;\n\tstruct lpfc_nodelist *next_np;\n\tuint8_t fabric_param_changed;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag |= FC_FABRIC;\n\tspin_unlock_irq(shost->host_lock);\n\n\tphba->fc_edtov = be32_to_cpu(sp->cmn.e_d_tov);\n\tif (sp->cmn.edtovResolution)\t \n\t\tphba->fc_edtov = (phba->fc_edtov + 999999) / 1000000;\n\n\tphba->fc_edtovResol = sp->cmn.edtovResolution;\n\tphba->fc_ratov = (be32_to_cpu(sp->cmn.w2.r_a_tov) + 999) / 1000;\n\n\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_PUBLIC_LOOP;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\n\tvport->fc_myDID = ulp_word4 & Mask_DID;\n\tmemcpy(&ndlp->nlp_portname, &sp->portName, sizeof(struct lpfc_name));\n\tmemcpy(&ndlp->nlp_nodename, &sp->nodeName, sizeof(struct lpfc_name));\n\tndlp->nlp_class_sup = 0;\n\tif (sp->cls1.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS1;\n\tif (sp->cls2.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS2;\n\tif (sp->cls3.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS3;\n\tif (sp->cls4.classValid)\n\t\tndlp->nlp_class_sup |= FC_COS_CLASS4;\n\tndlp->nlp_maxframe = ((sp->cmn.bbRcvSizeMsb & 0x0F) << 8) |\n\t\t\t\tsp->cmn.bbRcvSizeLsb;\n\n\tfabric_param_changed = lpfc_check_clean_addr_bit(vport, sp);\n\tif (fabric_param_changed) {\n\t\t \n\t\tif (phba->cfg_enable_SmartSAN ||\n\t\t    (phba->cfg_fdmi_on == LPFC_FDMI_SUPPORT)) {\n\t\t\t \n\t\t\tvport->fdmi_hba_mask = LPFC_FDMI2_HBA_ATTR;\n\t\t\tif (phba->cfg_enable_SmartSAN)\n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI2_SMART_ATTR;\n\t\t\telse\n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI2_PORT_ATTR;\n\t\t} else {\n\t\t\tvport->fdmi_hba_mask = 0;\n\t\t\tvport->fdmi_port_mask = 0;\n\t\t}\n\n\t}\n\tmemcpy(&vport->fabric_portname, &sp->portName,\n\t\t\tsizeof(struct lpfc_name));\n\tmemcpy(&vport->fabric_nodename, &sp->nodeName,\n\t\t\tsizeof(struct lpfc_name));\n\tmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\n\n\tif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) {\n\t\tif (sp->cmn.response_multiple_NPort) {\n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING,\n\t\t\t\t\t LOG_ELS | LOG_VPORT,\n\t\t\t\t\t \"1816 FLOGI NPIV supported, \"\n\t\t\t\t\t \"response data 0x%x\\n\",\n\t\t\t\t\t sp->cmn.response_multiple_NPort);\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->link_flag |= LS_NPIV_FAB_SUPPORTED;\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t} else {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING,\n\t\t\t\t\t LOG_ELS | LOG_VPORT,\n\t\t\t\t\t \"1817 Fabric does not support NPIV \"\n\t\t\t\t\t \"- configuring single port mode.\\n\");\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->link_flag &= ~LS_NPIV_FAB_SUPPORTED;\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t}\n\t}\n\n\t \n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    (phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_FC)) {\n\t\t \n\t\tif (fabric_param_changed)\n\t\t\tlpfc_unregister_fcf_prep(phba);\n\n\t\t \n\t\tif (vport->fc_flag & FC_VFI_REGISTERED)\n\t\t\tlpfc_issue_reg_vfi(vport);\n\t}\n\n\tif (fabric_param_changed &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\n\n\t\t \n\t\tlist_for_each_entry_safe(np, next_np,\n\t\t\t\t\t&vport->fc_nodes, nlp_listp) {\n\t\t\tif ((np->nlp_state != NLP_STE_NPR_NODE) ||\n\t\t\t\t   !(np->nlp_flag & NLP_NPR_ADISC))\n\t\t\t\tcontinue;\n\t\t\tspin_lock_irq(&np->lock);\n\t\t\tnp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\t\tspin_unlock_irq(&np->lock);\n\t\t\tlpfc_unreg_rpi(vport, np);\n\t\t}\n\t\tlpfc_cleanup_pending_mbox(vport);\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\t\t\tlpfc_mbx_unreg_vpi(vport);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t}\n\n\t\t \n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\tspin_unlock_irq(shost->host_lock);\n\t} else if ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\n\t\t\t \n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\t\t\treturn 0;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_REG_LOGIN_ISSUE);\n\t\tif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED &&\n\t\t    vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)\n\t\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\t\telse\n\t\t\tlpfc_issue_fabric_reglogin(vport);\n\t} else {\n\t\tndlp->nlp_type |= NLP_FABRIC;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t\tif ((!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) &&\n\t\t\t(vport->vpi_state & LPFC_VPI_REGISTERED)) {\n\t\t\tlpfc_start_fdiscs(phba);\n\t\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\t\t} else if (vport->fc_flag & FC_VFI_REGISTERED)\n\t\t\tlpfc_issue_init_vpi(vport);\n\t\telse {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t\t\"3135 Need register VFI: (x%x/%x)\\n\",\n\t\t\t\t\tvport->fc_prevDID, vport->fc_myDID);\n\t\t\tlpfc_issue_reg_vfi(vport);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nlpfc_cmpl_els_flogi_nport(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\t  struct serv_parm *sp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tint rc;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\tvport->fc_flag |= FC_PT2PT;\n\tspin_unlock_irq(shost->host_lock);\n\n\t \n\tphba->sli3_options &= ~LPFC_SLI3_NPIV_ENABLED;\n\n\t \n\tif ((phba->sli_rev == LPFC_SLI_REV4) && phba->fc_topology_changed) {\n\t\tlpfc_unregister_fcf_prep(phba);\n\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_VFI_REGISTERED;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tphba->fc_topology_changed = 0;\n\t}\n\n\trc = memcmp(&vport->fc_portname, &sp->portName,\n\t\t    sizeof(vport->fc_portname));\n\n\tif (rc >= 0) {\n\t\t \n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_PT2PT_PLOGI;\n\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t \n\n\t\t \n\t\tif (rc)\n\t\t\tvport->fc_myDID = PT2PT_LocalID;\n\n\t\t \n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD)))\n\t\t\tlpfc_nlp_put(ndlp);\n\n\t\tndlp = lpfc_findnode_did(vport, PT2PT_RemoteID);\n\t\tif (!ndlp) {\n\t\t\t \n\t\t\tndlp = lpfc_nlp_init(vport, PT2PT_RemoteID);\n\t\t\tif (!ndlp)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tmemcpy(&ndlp->nlp_portname, &sp->portName,\n\t\t       sizeof(struct lpfc_name));\n\t\tmemcpy(&ndlp->nlp_nodename, &sp->nodeName,\n\t\t       sizeof(struct lpfc_name));\n\t\t \n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (!mbox)\n\t\t\tgoto fail;\n\n\t\tlpfc_config_link(phba, mbox);\n\n\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_local_config_link;\n\t\tmbox->vport = vport;\n\t\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD)))\n\t\t\tlpfc_nlp_put(ndlp);\n\n\t\t \n\t\tlpfc_disc_start(vport);\n\t}\n\n\treturn 0;\nfail:\n\treturn -ENXIO;\n}\n\n \nstatic void\nlpfc_cmpl_els_flogi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tIOCB_t *irsp;\n\tstruct lpfc_dmabuf *pcmd = cmdiocb->cmd_dmabuf, *prsp;\n\tstruct serv_parm *sp;\n\tuint16_t fcf_index;\n\tint rc;\n\tu32 ulp_status, ulp_word4, tmo;\n\tbool flogi_in_retry = false;\n\n\t \n\tif (lpfc_els_chk_latt(vport)) {\n\t\t \n\t\tif (!(ndlp->fc4_xpt_flags & SCSI_XPT_REGD))\n\t\t\tlpfc_nlp_put(ndlp);\n\t\tgoto out;\n\t}\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\ttmo = get_wqe_tmo(cmdiocb);\n\t} else {\n\t\tirsp = &rspiocb->iocb;\n\t\ttmo = irsp->ulpTimeout;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"FLOGI cmpl:      status:x%x/x%x state:x%x\",\n\t\tulp_status, ulp_word4,\n\t\tvport->port_state);\n\n\tif (ulp_status) {\n\t\t \n\t\tif ((phba->hba_flag & HBA_FIP_SUPPORT) &&\n\t\t    (phba->fcf.fcf_flag & FCF_DISCOVERY)) {\n\t\t\tif (phba->link_state < LPFC_LINK_UP)\n\t\t\t\tgoto stop_rr_fcf_flogi;\n\t\t\tif ((phba->fcoe_cvl_eventtag_attn ==\n\t\t\t     phba->fcoe_cvl_eventtag) &&\n\t\t\t    (ulp_status == IOSTAT_LOCAL_REJECT) &&\n\t\t\t    ((ulp_word4 & IOERR_PARAM_MASK) ==\n\t\t\t    IOERR_SLI_ABORTED))\n\t\t\t\tgoto stop_rr_fcf_flogi;\n\t\t\telse\n\t\t\t\tphba->fcoe_cvl_eventtag_attn =\n\t\t\t\t\tphba->fcoe_cvl_eventtag;\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FIP | LOG_ELS,\n\t\t\t\t\t\"2611 FLOGI failed on FCF (x%x), \"\n\t\t\t\t\t\"status:x%x/x%x, tmo:x%x, perform \"\n\t\t\t\t\t\"roundrobin FCF failover\\n\",\n\t\t\t\t\tphba->fcf.current_rec.fcf_indx,\n\t\t\t\t\tulp_status, ulp_word4, tmo);\n\t\t\tlpfc_sli4_set_fcf_flogi_fail(phba,\n\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t\tfcf_index = lpfc_sli4_fcf_rr_next_index_get(phba);\n\t\t\trc = lpfc_sli4_fcf_rr_next_proc(vport, fcf_index);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\nstop_rr_fcf_flogi:\n\t\t \n\t\tif (!(ulp_status == IOSTAT_LOCAL_REJECT &&\n\t\t      ((ulp_word4 & IOERR_PARAM_MASK) ==\n\t\t\t\t\tIOERR_LOOP_OPEN_FAILURE)))\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"2858 FLOGI failure Status:x%x/x%x TMO\"\n\t\t\t\t\t \":x%x Data x%x x%x\\n\",\n\t\t\t\t\t ulp_status, ulp_word4, tmo,\n\t\t\t\t\t phba->hba_flag, phba->fcf.fcf_flag);\n\n\t\t \n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\n\t\t\t \n\t\t\tlpfc_check_nlp_post_devloss(vport, ndlp);\n\t\t\tflogi_in_retry = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!(ndlp->nlp_flag & NLP_IN_DEV_LOSS) &&\n\t\t    !(ndlp->fc4_xpt_flags & SCSI_XPT_REGD))\n\t\t\tlpfc_nlp_put(ndlp);\n\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_ELS,\n\t\t\t\t \"0150 FLOGI failure Status:x%x/x%x \"\n\t\t\t\t \"xri x%x TMO:x%x refcnt %d\\n\",\n\t\t\t\t ulp_status, ulp_word4, cmdiocb->sli4_xritag,\n\t\t\t\t tmo, kref_read(&ndlp->kref));\n\n\t\t \n\t\tif (!(ulp_status == IOSTAT_LOCAL_REJECT &&\n\t\t      ((ulp_word4 & IOERR_PARAM_MASK) ==\n\t\t\t\t\tIOERR_LOOP_OPEN_FAILURE))) {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0100 FLOGI failure Status:x%x/x%x \"\n\t\t\t\t\t \"TMO:x%x\\n\",\n\t\t\t\t\t ulp_status, ulp_word4, tmo);\n\t\t\tgoto flogifail;\n\t\t}\n\n\t\t \n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP |\n\t\t\t\t    FC_PT2PT_NO_NVME);\n\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t \n\t\tif (phba->alpa_map[0] == 0)\n\t\t\tvport->cfg_discovery_threads = LPFC_MAX_DISC_THREADS;\n\t\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t\t    (!(vport->fc_flag & FC_VFI_REGISTERED) ||\n\t\t     (vport->fc_prevDID != vport->fc_myDID) ||\n\t\t\tphba->fc_topology_changed)) {\n\t\t\tif (vport->fc_flag & FC_VFI_REGISTERED) {\n\t\t\t\tif (phba->fc_topology_changed) {\n\t\t\t\t\tlpfc_unregister_fcf_prep(phba);\n\t\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\t\tvport->fc_flag &= ~FC_VFI_REGISTERED;\n\t\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\t\tphba->fc_topology_changed = 0;\n\t\t\t\t} else {\n\t\t\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!lpfc_error_lost_link(vport, ulp_status, ulp_word4))\n\t\t\t\tlpfc_issue_reg_vfi(vport);\n\n\t\t\tgoto out;\n\t\t}\n\t\tgoto flogifail;\n\t}\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_CVL_RCVD;\n\tvport->fc_flag &= ~FC_VPORT_LOGO_RCVD;\n\tspin_unlock_irq(shost->host_lock);\n\n\t \n\tprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\n\tif (!prsp)\n\t\tgoto out;\n\tsp = prsp->virt + sizeof(uint32_t);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0101 FLOGI completes successfully, I/O tag:x%x \"\n\t\t\t \"xri x%x Data: x%x x%x x%x x%x x%x x%x x%x %d\\n\",\n\t\t\t cmdiocb->iotag, cmdiocb->sli4_xritag,\n\t\t\t ulp_word4, sp->cmn.e_d_tov,\n\t\t\t sp->cmn.w2.r_a_tov, sp->cmn.edtovResolution,\n\t\t\t vport->port_state, vport->fc_flag,\n\t\t\t sp->cmn.priority_tagging, kref_read(&ndlp->kref));\n\n\tif (sp->cmn.priority_tagging)\n\t\tvport->phba->pport->vmid_flag |= (LPFC_VMID_ISSUE_QFPA |\n\t\t\t\t\t\t  LPFC_VMID_TYPE_PRIO);\n\t \n\tif (lpfc_is_vmid_enabled(phba))\n\t\tlpfc_reinit_vmid(vport);\n\n\t \n\tlpfc_check_nlp_post_devloss(vport, ndlp);\n\tif (vport->port_state == LPFC_FLOGI) {\n\t\t \n\t\tif (sp->cmn.fPort)\n\t\t\trc = lpfc_cmpl_els_flogi_fabric(vport, ndlp, sp,\n\t\t\t\t\t\t\tulp_word4);\n\t\telse if (!(phba->hba_flag & HBA_FCOE_MODE))\n\t\t\trc = lpfc_cmpl_els_flogi_nport(vport, ndlp, sp);\n\t\telse {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2831 FLOGI response with cleared Fabric \"\n\t\t\t\t\"bit fcf_index 0x%x \"\n\t\t\t\t\"Switch Name %02x%02x%02x%02x%02x%02x%02x%02x \"\n\t\t\t\t\"Fabric Name \"\n\t\t\t\t\"%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t\tphba->fcf.current_rec.fcf_indx,\n\t\t\t\tphba->fcf.current_rec.switch_name[0],\n\t\t\t\tphba->fcf.current_rec.switch_name[1],\n\t\t\t\tphba->fcf.current_rec.switch_name[2],\n\t\t\t\tphba->fcf.current_rec.switch_name[3],\n\t\t\t\tphba->fcf.current_rec.switch_name[4],\n\t\t\t\tphba->fcf.current_rec.switch_name[5],\n\t\t\t\tphba->fcf.current_rec.switch_name[6],\n\t\t\t\tphba->fcf.current_rec.switch_name[7],\n\t\t\t\tphba->fcf.current_rec.fabric_name[0],\n\t\t\t\tphba->fcf.current_rec.fabric_name[1],\n\t\t\t\tphba->fcf.current_rec.fabric_name[2],\n\t\t\t\tphba->fcf.current_rec.fabric_name[3],\n\t\t\t\tphba->fcf.current_rec.fabric_name[4],\n\t\t\t\tphba->fcf.current_rec.fabric_name[5],\n\t\t\t\tphba->fcf.current_rec.fabric_name[6],\n\t\t\t\tphba->fcf.current_rec.fabric_name[7]);\n\n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\n\t\t\tphba->hba_flag &= ~(FCF_RR_INPROG | HBA_DEVLOSS_TMO);\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_redisc_attempted = 0;  \n\t\t\tgoto out;\n\t\t}\n\t\tif (!rc) {\n\t\t\t \n\t\t\tif (phba->hba_flag & HBA_FIP_SUPPORT)\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FIP |\n\t\t\t\t\t\tLOG_ELS,\n\t\t\t\t\t\t\"2769 FLOGI to FCF (x%x) \"\n\t\t\t\t\t\t\"completed successfully\\n\",\n\t\t\t\t\t\tphba->fcf.current_rec.fcf_indx);\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\n\t\t\tphba->hba_flag &= ~(FCF_RR_INPROG | HBA_DEVLOSS_TMO);\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\tphba->fcf.fcf_redisc_attempted = 0;  \n\t\t\tgoto out;\n\t\t}\n\t} else if (vport->port_state > LPFC_FLOGI &&\n\t\t   vport->fc_flag & FC_PT2PT) {\n\t\t \n\t\tif (!sp->cmn.fPort)\n\t\t\tgoto out;\n\t}\n\nflogifail:\n\tspin_lock_irq(&phba->hbalock);\n\tphba->fcf.fcf_flag &= ~FCF_DISCOVERY;\n\tspin_unlock_irq(&phba->hbalock);\n\n\tif (!lpfc_error_lost_link(vport, ulp_status, ulp_word4)) {\n\t\t \n\t\tlpfc_disc_list_loopmap(vport);\n\n\t\t \n\t\tlpfc_disc_start(vport);\n\t} else if (((ulp_status != IOSTAT_LOCAL_REJECT) ||\n\t\t\t(((ulp_word4 & IOERR_PARAM_MASK) !=\n\t\t\t IOERR_SLI_ABORTED) &&\n\t\t\t((ulp_word4 & IOERR_PARAM_MASK) !=\n\t\t\t IOERR_SLI_DOWN))) &&\n\t\t\t(phba->link_state != LPFC_CLEAR_LA)) {\n\t\t \n\t\tlpfc_issue_clear_la(phba, vport);\n\t}\nout:\n\tif (!flogi_in_retry)\n\t\tphba->hba_flag &= ~HBA_FLOGI_OUTSTANDING;\n\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n \nstatic void\nlpfc_cmpl_els_link_down(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tuint32_t *pcmd;\n\tuint32_t cmd;\n\tu32 ulp_status, ulp_word4;\n\n\tpcmd = (uint32_t *)cmdiocb->cmd_dmabuf->virt;\n\tcmd = *pcmd;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\"6445 ELS completes after LINK_DOWN: \"\n\t\t\t\" Status %x/%x cmd x%x flg x%x\\n\",\n\t\t\tulp_status, ulp_word4, cmd,\n\t\t\tcmdiocb->cmd_flag);\n\n\tif (cmdiocb->cmd_flag & LPFC_IO_FABRIC) {\n\t\tcmdiocb->cmd_flag &= ~LPFC_IO_FABRIC;\n\t\tatomic_dec(&phba->fabric_iocb_count);\n\t}\n\tlpfc_els_free_iocb(phba, cmdiocb);\n}\n\n \nstatic int\nlpfc_issue_els_flogi(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t     uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct serv_parm *sp;\n\tunion lpfc_wqe128 *wqe = NULL;\n\tIOCB_t *icmd = NULL;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_iocbq defer_flogi_acc;\n\tu8 *pcmd, ct;\n\tuint16_t cmdsize;\n\tuint32_t tmo, did;\n\tint rc;\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_FLOGI);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\twqe = &elsiocb->wqe;\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\ticmd = &elsiocb->iocb;\n\n\t \n\t*((uint32_t *) (pcmd)) = ELS_CMD_FLOGI;\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, &vport->fc_sparam, sizeof(struct serv_parm));\n\tsp = (struct serv_parm *) pcmd;\n\n\t \n\tsp->cmn.e_d_tov = 0;\n\tsp->cmn.w2.r_a_tov = 0;\n\tsp->cmn.virtual_fabric_support = 0;\n\tsp->cls1.classValid = 0;\n\tif (sp->cmn.fcphLow < FC_PH3)\n\t\tsp->cmn.fcphLow = FC_PH3;\n\tif (sp->cmn.fcphHigh < FC_PH3)\n\t\tsp->cmn.fcphHigh = FC_PH3;\n\n\t \n\tif (phba->cfg_vmid_priority_tagging) {\n\t\tsp->cmn.priority_tagging = 1;\n\t\t \n\t\tif (!memchr_inv(vport->lpfc_vmid_host_uuid, 0,\n\t\t\t\tsizeof(vport->lpfc_vmid_host_uuid))) {\n\t\t\tmemcpy(vport->lpfc_vmid_host_uuid, phba->wwpn,\n\t\t\t       sizeof(phba->wwpn));\n\t\t\tmemcpy(&vport->lpfc_vmid_host_uuid[8], phba->wwnn,\n\t\t\t       sizeof(phba->wwnn));\n\t\t}\n\t}\n\n\tif  (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) ==\n\t\t    LPFC_SLI_INTF_IF_TYPE_0) {\n\t\t\t \n\t\t\tct = SLI4_CT_FCFI;\n\t\t\tbf_set(wqe_ct, &wqe->els_req.wqe_com, ct);\n\n\t\t\t \n\t\t\tbf_set(wqe_ctxt_tag, &wqe->els_req.wqe_com,\n\t\t\t       phba->fcf.fcfi);\n\t\t}\n\n\t\t \n\t\tsp->cls2.classValid = 0;\n\t\tsp->cls2.seqDelivery = 0;\n\t} else {\n\t\t \n\t\tsp->cls2.seqDelivery = (sp->cls2.classValid) ? 1 : 0;\n\t\tsp->cls3.seqDelivery = (sp->cls3.classValid) ? 1 : 0;\n\t\tif (phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) {\n\t\t\tsp->cmn.request_multiple_Nport = 1;\n\t\t\t \n\t\t\ticmd->ulpCt_h = 1;\n\t\t\ticmd->ulpCt_l = 0;\n\t\t} else {\n\t\t\tsp->cmn.request_multiple_Nport = 0;\n\t\t}\n\n\t\tif (phba->fc_topology != LPFC_TOPOLOGY_LOOP) {\n\t\t\ticmd->un.elsreq64.myID = 0;\n\t\t\ticmd->un.elsreq64.fl = 1;\n\t\t}\n\t}\n\n\ttmo = phba->fc_ratov;\n\tphba->fc_ratov = LPFC_DISC_FLOGI_TMO;\n\tlpfc_set_disctmo(vport);\n\tphba->fc_ratov = tmo;\n\n\tphba->fc_stat.elsXmitFLOGI++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_flogi;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue FLOGI:     opt:x%x\",\n\t\tphba->sli3_options, 0, 0);\n\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\t \n\tphba->hba_flag |= (HBA_FLOGI_ISSUED | HBA_FLOGI_OUTSTANDING);\n\n\trc = lpfc_issue_fabric_iocb(phba, elsiocb);\n\tif (rc == IOCB_ERROR) {\n\t\tphba->hba_flag &= ~(HBA_FLOGI_ISSUED | HBA_FLOGI_OUTSTANDING);\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\t \n\tphba->link_flag &= ~LS_EXTERNAL_LOOPBACK;\n\n\t \n\tif (phba->defer_flogi_acc_flag) {\n\t\t \n\t\tndlp = lpfc_findnode_did(vport, 0);\n\t\tif (!ndlp)\n\t\t\treturn 0;\n\n\t\tdid = vport->fc_myDID;\n\t\tvport->fc_myDID = Fabric_DID;\n\n\t\tmemset(&defer_flogi_acc, 0, sizeof(struct lpfc_iocbq));\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tbf_set(wqe_ctxt_tag,\n\t\t\t       &defer_flogi_acc.wqe.xmit_els_rsp.wqe_com,\n\t\t\t       phba->defer_flogi_acc_rx_id);\n\t\t\tbf_set(wqe_rcvoxid,\n\t\t\t       &defer_flogi_acc.wqe.xmit_els_rsp.wqe_com,\n\t\t\t       phba->defer_flogi_acc_ox_id);\n\t\t} else {\n\t\t\ticmd = &defer_flogi_acc.iocb;\n\t\t\ticmd->ulpContext = phba->defer_flogi_acc_rx_id;\n\t\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\t\tphba->defer_flogi_acc_ox_id;\n\t\t}\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"3354 Xmit deferred FLOGI ACC: rx_id: x%x,\"\n\t\t\t\t \" ox_id: x%x, hba_flag x%x\\n\",\n\t\t\t\t phba->defer_flogi_acc_rx_id,\n\t\t\t\t phba->defer_flogi_acc_ox_id, phba->hba_flag);\n\n\t\t \n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_FLOGI, &defer_flogi_acc,\n\t\t\t\t ndlp, NULL);\n\n\t\tphba->defer_flogi_acc_flag = false;\n\t\tvport->fc_myDID = did;\n\n\t\t \n\t\tlpfc_nlp_put(ndlp);\n\t}\n\n\treturn 0;\n}\n\n \nint\nlpfc_els_abort_flogi(struct lpfc_hba *phba)\n{\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *iocb, *next_iocb;\n\tstruct lpfc_nodelist *ndlp;\n\tu32 ulp_command;\n\n\t \n\tlpfc_printf_log(phba, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\"0201 Abort outstanding I/O on NPort x%x\\n\",\n\t\t\tFabric_DID);\n\n\tpring = lpfc_phba_elsring(phba);\n\tif (unlikely(!pring))\n\t\treturn -EIO;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(iocb, next_iocb, &pring->txcmplq, list) {\n\t\tulp_command = get_job_cmnd(phba, iocb);\n\t\tif (ulp_command == CMD_ELS_REQUEST64_CR) {\n\t\t\tndlp = iocb->ndlp;\n\t\t\tif (ndlp && ndlp->nlp_DID == Fabric_DID) {\n\t\t\t\tif ((phba->pport->fc_flag & FC_PT2PT) &&\n\t\t\t\t    !(phba->pport->fc_flag & FC_PT2PT_PLOGI))\n\t\t\t\t\tiocb->fabric_cmd_cmpl =\n\t\t\t\t\t\tlpfc_ignore_els_cmpl;\n\t\t\t\tlpfc_sli_issue_abort_iotag(phba, pring, iocb,\n\t\t\t\t\t\t\t   NULL);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tlpfc_issue_hb_tmo(phba);\n\n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn 0;\n}\n\n \nint\nlpfc_initial_flogi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\tvport->port_state = LPFC_FLOGI;\n\tlpfc_set_disctmo(vport);\n\n\t \n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp) {\n\t\t \n\t\tndlp = lpfc_nlp_init(vport, Fabric_DID);\n\t\tif (!ndlp)\n\t\t\treturn 0;\n\t\t \n\t\tndlp->nlp_type |= NLP_FABRIC;\n\n\t\t \n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\t \n\tvport->fc_flag &= ~FC_FABRIC;\n\tif (lpfc_issue_els_flogi(vport, ndlp, 0)) {\n\t\t \n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD)) &&\n\t\t    !(ndlp->nlp_flag & NLP_IN_DEV_LOSS))\n\t\t\tlpfc_nlp_put(ndlp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nint\nlpfc_initial_fdisc(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\t \n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp) {\n\t\t \n\t\tndlp = lpfc_nlp_init(vport, Fabric_DID);\n\t\tif (!ndlp)\n\t\t\treturn 0;\n\n\t\t \n\t\tndlp->nlp_type |= NLP_FABRIC;\n\n\t\t \n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\tif (lpfc_issue_els_fdisc(vport, ndlp, 0)) {\n\t\t \n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD)) &&\n\t\t    !(ndlp->nlp_flag & NLP_IN_DEV_LOSS))\n\t\t\tlpfc_nlp_put(ndlp);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nvoid\nlpfc_more_plogi(struct lpfc_vport *vport)\n{\n\tif (vport->num_disc_nodes)\n\t\tvport->num_disc_nodes--;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0232 Continue discovery with %d PLOGIs to go \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t vport->num_disc_nodes, vport->fc_plogi_cnt,\n\t\t\t vport->fc_flag, vport->port_state);\n\t \n\tif (vport->fc_flag & FC_NLP_MORE)\n\t\t \n\t\tlpfc_els_disc_plogi(vport);\n\n\treturn;\n}\n\n \nstatic struct lpfc_nodelist *\nlpfc_plogi_confirm_nport(struct lpfc_hba *phba, uint32_t *prsp,\n\t\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tstruct lpfc_nodelist *new_ndlp;\n\tstruct serv_parm *sp;\n\tuint8_t  name[sizeof(struct lpfc_name)];\n\tuint32_t keepDID = 0, keep_nlp_flag = 0;\n\tuint32_t keep_new_nlp_flag = 0;\n\tuint16_t keep_nlp_state;\n\tu32 keep_nlp_fc4_type = 0;\n\tstruct lpfc_nvme_rport *keep_nrport = NULL;\n\tunsigned long *active_rrqs_xri_bitmap = NULL;\n\n\t \n\tif (ndlp->nlp_type & NLP_FABRIC)\n\t\treturn ndlp;\n\n\tsp = (struct serv_parm *) ((uint8_t *) prsp + sizeof(uint32_t));\n\tmemset(name, 0, sizeof(struct lpfc_name));\n\n\t \n\tnew_ndlp = lpfc_findnode_wwpn(vport, &sp->portName);\n\n\t \n\tif (!new_ndlp || (new_ndlp == ndlp))\n\t\treturn ndlp;\n\n\t \n\tlpfc_nlp_unreg_node(vport, new_ndlp);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tactive_rrqs_xri_bitmap = mempool_alloc(phba->active_rrq_pool,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (active_rrqs_xri_bitmap)\n\t\t\tmemset(active_rrqs_xri_bitmap, 0,\n\t\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_NODE,\n\t\t\t \"3178 PLOGI confirm: ndlp x%x x%x x%x: \"\n\t\t\t \"new_ndlp x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag,  ndlp->nlp_fc4_type,\n\t\t\t (new_ndlp ? new_ndlp->nlp_DID : 0),\n\t\t\t (new_ndlp ? new_ndlp->nlp_flag : 0),\n\t\t\t (new_ndlp ? new_ndlp->nlp_fc4_type : 0));\n\n\tkeepDID = new_ndlp->nlp_DID;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4 && active_rrqs_xri_bitmap)\n\t\tmemcpy(active_rrqs_xri_bitmap, new_ndlp->active_rrqs_xri_bitmap,\n\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\n\t \n\tif (vport->fc_flag & FC_FABRIC) {\n\t\tkeep_nlp_fc4_type = new_ndlp->nlp_fc4_type;\n\t\tnew_ndlp->nlp_fc4_type = ndlp->nlp_fc4_type;\n\t}\n\n\tlpfc_unreg_rpi(vport, new_ndlp);\n\tnew_ndlp->nlp_DID = ndlp->nlp_DID;\n\tnew_ndlp->nlp_prev_state = ndlp->nlp_prev_state;\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tmemcpy(new_ndlp->active_rrqs_xri_bitmap,\n\t\t       ndlp->active_rrqs_xri_bitmap,\n\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\n\t \n\tspin_lock_irq(&ndlp->lock);\n\tspin_lock_irq(&new_ndlp->lock);\n\tkeep_new_nlp_flag = new_ndlp->nlp_flag;\n\tkeep_nlp_flag = ndlp->nlp_flag;\n\tnew_ndlp->nlp_flag = ndlp->nlp_flag;\n\n\t \n\tif (keep_new_nlp_flag & NLP_UNREG_INP)\n\t\tnew_ndlp->nlp_flag |= NLP_UNREG_INP;\n\telse\n\t\tnew_ndlp->nlp_flag &= ~NLP_UNREG_INP;\n\n\t \n\tif (keep_new_nlp_flag & NLP_RPI_REGISTERED)\n\t\tnew_ndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\telse\n\t\tnew_ndlp->nlp_flag &= ~NLP_RPI_REGISTERED;\n\n\t \n\tif (keep_new_nlp_flag & NLP_DROPPED)\n\t\tnew_ndlp->nlp_flag |= NLP_DROPPED;\n\telse\n\t\tnew_ndlp->nlp_flag &= ~NLP_DROPPED;\n\n\tndlp->nlp_flag = keep_new_nlp_flag;\n\n\t \n\tif (keep_nlp_flag & NLP_UNREG_INP)\n\t\tndlp->nlp_flag |= NLP_UNREG_INP;\n\telse\n\t\tndlp->nlp_flag &= ~NLP_UNREG_INP;\n\n\t \n\tif (keep_nlp_flag & NLP_RPI_REGISTERED)\n\t\tndlp->nlp_flag |= NLP_RPI_REGISTERED;\n\telse\n\t\tndlp->nlp_flag &= ~NLP_RPI_REGISTERED;\n\n\t \n\tif (keep_nlp_flag & NLP_DROPPED)\n\t\tndlp->nlp_flag |= NLP_DROPPED;\n\telse\n\t\tndlp->nlp_flag &= ~NLP_DROPPED;\n\n\tspin_unlock_irq(&new_ndlp->lock);\n\tspin_unlock_irq(&ndlp->lock);\n\n\t \n\tkeep_nlp_state = new_ndlp->nlp_state;\n\tlpfc_nlp_set_state(vport, new_ndlp, ndlp->nlp_state);\n\n\t \n\tkeep_nrport = new_ndlp->nrport;\n\tnew_ndlp->nrport = ndlp->nrport;\n\n\t \n\tif (memcmp(&ndlp->nlp_portname, name, sizeof(struct lpfc_name)) == 0) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"3179 PLOGI confirm NEW: %x %x\\n\",\n\t\t\t new_ndlp->nlp_DID, keepDID);\n\n\t\t \n\t\tndlp->nlp_DID = keepDID;\n\t\tndlp->nlp_fc4_type = keep_nlp_fc4_type;\n\t\tlpfc_nlp_set_state(vport, ndlp, keep_nlp_state);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t    active_rrqs_xri_bitmap)\n\t\t\tmemcpy(ndlp->active_rrqs_xri_bitmap,\n\t\t\t       active_rrqs_xri_bitmap,\n\t\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"3180 PLOGI confirm SWAP: %x %x\\n\",\n\t\t\t new_ndlp->nlp_DID, keepDID);\n\n\t\tlpfc_unreg_rpi(vport, ndlp);\n\n\t\t \n\t\tndlp->nlp_DID = keepDID;\n\t\tndlp->nlp_fc4_type = keep_nlp_fc4_type;\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t    active_rrqs_xri_bitmap)\n\t\t\tmemcpy(ndlp->active_rrqs_xri_bitmap,\n\t\t\t       active_rrqs_xri_bitmap,\n\t\t\t       phba->cfg_rrq_xri_bitmap_sz);\n\n\t\t \n\t\tif ((ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) ||\n\t\t    (ndlp->nlp_state == NLP_STE_MAPPED_NODE))\n\t\t\tkeep_nlp_state = NLP_STE_NPR_NODE;\n\t\tlpfc_nlp_set_state(vport, ndlp, keep_nlp_state);\n\t\tndlp->nrport = keep_nrport;\n\t}\n\n\t \n\tif (!ndlp->rport && (ndlp->nlp_state == NLP_STE_NPR_NODE))\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL, NLP_EVT_DEVICE_RM);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    active_rrqs_xri_bitmap)\n\t\tmempool_free(active_rrqs_xri_bitmap,\n\t\t\t     phba->active_rrq_pool);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_NODE,\n\t\t\t \"3173 PLOGI confirm exit: new_ndlp x%x x%x x%x\\n\",\n\t\t\t new_ndlp->nlp_DID, new_ndlp->nlp_flag,\n\t\t\t new_ndlp->nlp_fc4_type);\n\n\treturn new_ndlp;\n}\n\n \nvoid\nlpfc_end_rscn(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif (vport->fc_flag & FC_RSCN_MODE) {\n\t\t \n\t\tif (vport->fc_rscn_id_cnt ||\n\t\t    (vport->fc_flag & FC_RSCN_DISCOVERY) != 0)\n\t\t\tlpfc_els_handle_rscn(vport);\n\t\telse {\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag &= ~FC_RSCN_MODE;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t}\n\t}\n}\n\n \n\nstatic void\nlpfc_cmpl_els_rrq(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tstruct lpfc_node_rrq *rrq;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\n\t \n\trrq = cmdiocb->context_un.rrq;\n\tcmdiocb->rsp_iocb = rspiocb;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"RRQ cmpl:      status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4,\n\t\tget_job_els_rsp64_did(phba, cmdiocb));\n\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2880 RRQ completes to DID x%x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ulp_status, ulp_word4,\n\t\t\t get_wqe_tmo(cmdiocb), rrq->xritag, rrq->rxid);\n\n\tif (ulp_status) {\n\t\t \n\t\t \n\t\tif (ulp_status != IOSTAT_LS_RJT ||\n\t\t    (((ulp_word4) >> 16 != LSRJT_INVALID_CMD) &&\n\t\t     ((ulp_word4) >> 16 != LSRJT_UNABLE_TPC)) ||\n\t\t    (phba)->pport->cfg_log_verbose & LOG_ELS)\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"2881 RRQ failure DID:%06X Status:\"\n\t\t\t\t\t \"x%x/x%x\\n\",\n\t\t\t\t\t ndlp->nlp_DID, ulp_status,\n\t\t\t\t\t ulp_word4);\n\t}\n\n\tlpfc_clr_rrq_active(phba, rrq->xritag, rrq);\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n \nstatic void\nlpfc_cmpl_els_plogi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tIOCB_t *irsp;\n\tstruct lpfc_nodelist *ndlp, *free_ndlp;\n\tstruct lpfc_dmabuf *prsp;\n\tint disc;\n\tstruct serv_parm *sp = NULL;\n\tu32 ulp_status, ulp_word4, did, iotag;\n\tbool release_node = false;\n\n\t \n\tcmdiocb->rsp_iocb = rspiocb;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\tdid = get_job_els_rsp64_did(phba, cmdiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tiotag = get_wqe_reqtag(cmdiocb);\n\t} else {\n\t\tirsp = &rspiocb->iocb;\n\t\tiotag = irsp->ulpIoTag;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"PLOGI cmpl:      status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4, did);\n\n\tndlp = lpfc_findnode_did(vport, did);\n\tif (!ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0136 PLOGI completes to NPort x%x \"\n\t\t\t\t \"with no ndlp. Data: x%x x%x x%x\\n\",\n\t\t\t\t did, ulp_status, ulp_word4, iotag);\n\t\tgoto out_freeiocb;\n\t}\n\n\t \n\tspin_lock_irq(&ndlp->lock);\n\tdisc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);\n\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\tspin_unlock_irq(&ndlp->lock);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0102 PLOGI completes to NPort x%06x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_fc4_type,\n\t\t\t ulp_status, ulp_word4,\n\t\t\t disc, vport->num_disc_nodes);\n\n\t \n\tif (lpfc_els_chk_latt(vport)) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tgoto out;\n\t}\n\n\tif (ulp_status) {\n\t\t \n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\n\t\t\t \n\t\t\tif (disc) {\n\t\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (ulp_status != IOSTAT_LS_RJT ||\n\t\t    (((ulp_word4) >> 16 != LSRJT_INVALID_CMD) &&\n\t\t     ((ulp_word4) >> 16 != LSRJT_UNABLE_TPC)) ||\n\t\t    (phba)->pport->cfg_log_verbose & LOG_ELS)\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"2753 PLOGI failure DID:%06X \"\n\t\t\t\t\t \"Status:x%x/x%x\\n\",\n\t\t\t\t\t ndlp->nlp_DID, ulp_status,\n\t\t\t\t\t ulp_word4);\n\n\t\t \n\t\tif (!lpfc_error_lost_link(vport, ulp_status, ulp_word4))\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_CMPL_PLOGI);\n\n\t\t \n\t\tspin_lock_irq(&ndlp->lock);\n\t\tif ((ndlp->nlp_flag & (NLP_ACC_REGLOGIN | NLP_RCV_PLOGI)) &&\n\t\t    ndlp->nlp_state == NLP_STE_REG_LOGIN_ISSUE) {\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD))) {\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tif (!(ndlp->nlp_flag & NLP_IN_DEV_LOSS))\n\t\t\t\trelease_node = true;\n\t\t}\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\tif (release_node)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t} else {\n\t\t \n\t\tprsp = list_entry(cmdiocb->cmd_dmabuf->list.next,\n\t\t\t\t  struct lpfc_dmabuf, list);\n\t\tndlp = lpfc_plogi_confirm_nport(phba, prsp->virt, ndlp);\n\n\t\tsp = (struct serv_parm *)((u8 *)prsp->virt +\n\t\t\t\t\t  sizeof(u32));\n\n\t\tndlp->vmid_support = 0;\n\t\tif ((phba->cfg_vmid_app_header && sp->cmn.app_hdr_support) ||\n\t\t    (phba->cfg_vmid_priority_tagging &&\n\t\t     sp->cmn.priority_tagging)) {\n\t\t\tlpfc_printf_log(phba, KERN_DEBUG, LOG_ELS,\n\t\t\t\t\t\"4018 app_hdr_support %d tagging %d DID x%x\\n\",\n\t\t\t\t\tsp->cmn.app_hdr_support,\n\t\t\t\t\tsp->cmn.priority_tagging,\n\t\t\t\t\tndlp->nlp_DID);\n\t\t\t \n\t\t\tndlp->vmid_support = 1;\n\t\t}\n\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_CMPL_PLOGI);\n\t}\n\n\tif (disc && vport->num_disc_nodes) {\n\t\t \n\t\tlpfc_more_plogi(vport);\n\n\t\tif (vport->num_disc_nodes == 0) {\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t\tlpfc_can_disctmo(vport);\n\t\t\tlpfc_end_rscn(vport);\n\t\t}\n\t}\n\nout:\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_NODE,\n\t\t\t      \"PLOGI Cmpl PUT:     did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\nout_freeiocb:\n\t \n\tfree_ndlp = cmdiocb->ndlp;\n\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(free_ndlp);\n\treturn;\n}\n\n \nint\nlpfc_issue_els_plogi(struct lpfc_vport *vport, uint32_t did, uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct serv_parm *sp;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint ret;\n\n\tndlp = lpfc_findnode_did(vport, did);\n\tif (!ndlp)\n\t\treturn 1;\n\n\t \n\tif ((ndlp->nlp_flag & (NLP_IGNR_REG_CMPL | NLP_UNREG_INP)) &&\n\t    ((ndlp->nlp_DID & Fabric_DID_MASK) != Fabric_DID_MASK) &&\n\t    !(vport->fc_flag & FC_OFFLINE_MODE)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"4110 Issue PLOGI x%x deferred \"\n\t\t\t\t \"on NPort x%x rpi x%x flg x%x Data:\"\n\t\t\t\t \" x%px\\n\",\n\t\t\t\t ndlp->nlp_defer_did, ndlp->nlp_DID,\n\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_flag, ndlp);\n\n\t\t \n\t\tif (ndlp->nlp_defer_did == NLP_EVT_NOTHING_PENDING)\n\t\t\tndlp->nlp_defer_did = did;\n\t\treturn 0;\n\t}\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp, did,\n\t\t\t\t     ELS_CMD_PLOGI);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t \n\t*((uint32_t *) (pcmd)) = ELS_CMD_PLOGI;\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, &vport->fc_sparam, sizeof(struct serv_parm));\n\tsp = (struct serv_parm *) pcmd;\n\n\t \n\tif ((vport->fc_flag & FC_FABRIC) && !(vport->fc_flag & FC_PUBLIC_LOOP))\n\t\tsp->cmn.altBbCredit = 1;\n\n\tif (sp->cmn.fcphLow < FC_PH_4_3)\n\t\tsp->cmn.fcphLow = FC_PH_4_3;\n\n\tif (sp->cmn.fcphHigh < FC_PH3)\n\t\tsp->cmn.fcphHigh = FC_PH3;\n\n\tsp->cmn.valid_vendor_ver_level = 0;\n\tmemset(sp->un.vendorVersion, 0, sizeof(sp->un.vendorVersion));\n\tsp->cmn.bbRcvSizeMsb &= 0xF;\n\n\t \n\tndlp->vmid_support = 0;\n\tif (vport->vmid_priority_tagging)\n\t\tsp->cmn.priority_tagging = 1;\n\telse if (phba->cfg_vmid_app_header &&\n\t\t bf_get(lpfc_ftr_ashdr, &phba->sli4_hba.sli4_flags))\n\t\tsp->cmn.app_hdr_support = 1;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue PLOGI:     did:x%x\",\n\t\tdid, 0, 0);\n\n\t \n\tif (phba->sli.sli_flag & LPFC_SLI_SUPPRESS_RSP) {\n\t\tsp->cmn.valid_vendor_ver_level = 1;\n\t\tsp->un.vv.vid = cpu_to_be32(LPFC_VV_EMLX_ID);\n\t\tsp->un.vv.flags = cpu_to_be32(LPFC_VV_SUPPRESS_RSP);\n\t}\n\n\tphba->fc_stat.elsXmitPLOGI++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_plogi;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue PLOGI:     did:x%x refcnt %d\",\n\t\t\t      did, kref_read(&ndlp->kref), 0);\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (ret) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nlpfc_cmpl_els_prli(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct lpfc_nodelist *ndlp;\n\tchar *mode;\n\tu32 loglevel;\n\tu32 ulp_status;\n\tu32 ulp_word4;\n\tbool release_node = false;\n\n\t \n\tcmdiocb->rsp_iocb = rspiocb;\n\n\tndlp = cmdiocb->ndlp;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_PRLI_SND;\n\n\t \n\tvport->fc_prli_sent--;\n\tndlp->fc4_prli_sent--;\n\tspin_unlock_irq(&ndlp->lock);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"PRLI cmpl:       status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4,\n\t\tndlp->nlp_DID);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0103 PRLI completes to NPort x%06x \"\n\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ulp_status, ulp_word4,\n\t\t\t vport->num_disc_nodes, ndlp->fc4_prli_sent);\n\n\t \n\tif (lpfc_els_chk_latt(vport))\n\t\tgoto out;\n\n\tif (ulp_status) {\n\t\t \n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif ((vport->fc_flag & FC_FABRIC) ||\n\t\t    (vport->cfg_enable_fc4_type != LPFC_ENABLE_BOTH)) {\n\t\t\tmode = KERN_ERR;\n\t\t\tloglevel =  LOG_TRACE_EVENT;\n\t\t} else {\n\t\t\tmode = KERN_INFO;\n\t\t\tloglevel =  LOG_ELS;\n\t\t}\n\n\t\t \n\t\tlpfc_printf_vlog(vport, mode, loglevel,\n\t\t\t\t \"2754 PRLI failure DID:%06X Status:x%x/x%x, \"\n\t\t\t\t \"data: x%x x%x x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ulp_status,\n\t\t\t\t ulp_word4, ndlp->nlp_state,\n\t\t\t\t ndlp->fc4_prli_sent, ndlp->nlp_flag);\n\n\t\t \n\t\tif (!lpfc_error_lost_link(vport, ulp_status, ulp_word4))\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_CMPL_PRLI);\n\n\t\t \n\t\tif ((ndlp->nlp_state >= NLP_STE_PLOGI_ISSUE &&\n\t\t     ndlp->nlp_state <= NLP_STE_REG_LOGIN_ISSUE) ||\n\t\t    (ndlp->nlp_state == NLP_STE_NPR_NODE &&\n\t\t     ndlp->nlp_flag & NLP_DELAY_TMO)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_NODE,\n\t\t\t\t\t \"2784 PRLI cmpl: Allow Node recovery \"\n\t\t\t\t\t \"DID x%06x nstate x%x nflag x%x\\n\",\n\t\t\t\t\t ndlp->nlp_DID, ndlp->nlp_state,\n\t\t\t\t\t ndlp->nlp_flag);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (vport->fc_flag & FC_PT2PT)\n\t\t\tgoto out;\n\n\t\t \n\t\tspin_lock_irq(&ndlp->lock);\n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD)) &&\n\t\t    !ndlp->fc4_prli_sent) {\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tif (!(ndlp->nlp_flag & NLP_IN_DEV_LOSS))\n\t\t\t\trelease_node = true;\n\t\t}\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\tif (release_node)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t} else {\n\t\t \n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_CMPL_PRLI);\n\t}\n\nout:\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n \nint\nlpfc_issue_els_prli(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t    uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba *phba = vport->phba;\n\tPRLI *npr;\n\tstruct lpfc_nvme_prli *npr_nvme;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tu32 local_nlp_type, elscmd;\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    vport->fc_flag & FC_RSCN_MODE &&\n\t    vport->nvmei_support)\n\t\tndlp->nlp_fc4_type |= NLP_FC4_NVME;\n\tlocal_nlp_type = ndlp->nlp_fc4_type;\n\n\t \n\tndlp->nlp_type &= ~(NLP_FCP_TARGET | NLP_FCP_INITIATOR);\n\tndlp->nlp_type &= ~(NLP_NVME_TARGET | NLP_NVME_INITIATOR);\n\tndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\tndlp->nlp_flag &= ~(NLP_FIRSTBURST | NLP_NPR_2B_DISC);\n\tndlp->nvme_fb_size = 0;\n\n send_next_prli:\n\tif (local_nlp_type & NLP_FC4_FCP) {\n\t\t \n\t\tcmdsize = (sizeof(uint32_t) + sizeof(PRLI));\n\t\telscmd = ELS_CMD_PRLI;\n\t} else if (local_nlp_type & NLP_FC4_NVME) {\n\t\t \n\t\tcmdsize = (sizeof(uint32_t) + sizeof(struct lpfc_nvme_prli));\n\t\telscmd = ELS_CMD_NVMEPRLI;\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"3083 Unknown FC_TYPE x%x ndlp x%06x\\n\",\n\t\t\t\t ndlp->nlp_fc4_type, ndlp->nlp_DID);\n\t\treturn 1;\n\t}\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV3 &&\n\t    ndlp->nlp_fc4_type == NLP_FC4_NVME) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"3088 Rport fc4 type 0x%x not supported by SLI3 adapter\\n\",\n\t\t\t\t ndlp->nlp_type);\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL, NLP_EVT_DEVICE_RM);\n\t\treturn 1;\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, elscmd);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t \n\tmemset(pcmd, 0, cmdsize);\n\n\tif (local_nlp_type & NLP_FC4_FCP) {\n\t\t \n\t\t*((uint32_t *)(pcmd)) = ELS_CMD_PRLI;\n\t\tpcmd += sizeof(uint32_t);\n\t\tnpr = (PRLI *)pcmd;\n\n\t\t \n\t\tif (phba->vpd.rev.feaLevelHigh >= 0x02) {\n\t\t\tnpr->ConfmComplAllowed = 1;\n\t\t\tnpr->Retry = 1;\n\t\t\tnpr->TaskRetryIdReq = 1;\n\t\t}\n\t\tnpr->estabImagePair = 1;\n\t\tnpr->readXferRdyDis = 1;\n\t\tif (vport->cfg_first_burst_size)\n\t\t\tnpr->writeXferRdyDis = 1;\n\n\t\t \n\t\tnpr->prliType = PRLI_FCP_TYPE;\n\t\tnpr->initiatorFunc = 1;\n\t\telsiocb->cmd_flag |= LPFC_PRLI_FCP_REQ;\n\n\t\t \n\t\tlocal_nlp_type &= ~NLP_FC4_FCP;\n\t} else if (local_nlp_type & NLP_FC4_NVME) {\n\t\t \n\t\t*((uint32_t *)(pcmd)) = ELS_CMD_NVMEPRLI;\n\t\tpcmd += sizeof(uint32_t);\n\t\tnpr_nvme = (struct lpfc_nvme_prli *)pcmd;\n\t\tbf_set(prli_type_code, npr_nvme, PRLI_NVME_TYPE);\n\t\tbf_set(prli_estabImagePair, npr_nvme, 0);   \n\t\tif (phba->nsler) {\n\t\t\tbf_set(prli_nsler, npr_nvme, 1);\n\t\t\tbf_set(prli_conf, npr_nvme, 1);\n\t\t}\n\n\t\t \n\t\tif ((phba->cfg_nvme_enable_fb) &&\n\t\t    !phba->nvmet_support)\n\t\t\tbf_set(prli_fba, npr_nvme, 1);\n\n\t\tif (phba->nvmet_support) {\n\t\t\tbf_set(prli_tgt, npr_nvme, 1);\n\t\t\tbf_set(prli_disc, npr_nvme, 1);\n\t\t} else {\n\t\t\tbf_set(prli_init, npr_nvme, 1);\n\t\t\tbf_set(prli_conf, npr_nvme, 1);\n\t\t}\n\n\t\tnpr_nvme->word1 = cpu_to_be32(npr_nvme->word1);\n\t\tnpr_nvme->word4 = cpu_to_be32(npr_nvme->word4);\n\t\telsiocb->cmd_flag |= LPFC_PRLI_NVME_REQ;\n\n\t\t \n\t\tlocal_nlp_type &= ~NLP_FC4_NVME;\n\t}\n\n\tphba->fc_stat.elsXmitPRLI++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_prli;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue PRLI:  did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\t \n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_PRLI_SND;\n\tvport->fc_prli_sent++;\n\tndlp->fc4_prli_sent++;\n\tspin_unlock_irq(&ndlp->lock);\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    local_nlp_type & (NLP_FC4_FCP | NLP_FC4_NVME))\n\t\tgoto send_next_prli;\n\telse\n\t\treturn 0;\n}\n\n \nstatic void\nlpfc_rscn_disc(struct lpfc_vport *vport)\n{\n\tlpfc_can_disctmo(vport);\n\n\t \n\t \n\tif (vport->fc_npr_cnt)\n\t\tif (lpfc_els_disc_plogi(vport))\n\t\t\treturn;\n\n\tlpfc_end_rscn(vport);\n}\n\n \nstatic void\nlpfc_adisc_done(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host   *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\t \n\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t    !(vport->fc_flag & FC_RSCN_MODE) &&\n\t    (phba->sli_rev < LPFC_SLI_REV4)) {\n\n\t\t \n\t\tif (!lpfc_is_link_up(phba))\n\t\t\treturn;\n\n\t\t \n\t\tlpfc_issue_clear_la(phba, vport);\n\t\tlpfc_issue_reg_vpi(phba, vport);\n\t\treturn;\n\t}\n\t \n\tif (vport->port_state < LPFC_VPORT_READY) {\n\t\t \n\t\tlpfc_issue_clear_la(phba, vport);\n\t\tif (!(vport->fc_flag & FC_ABORT_DISCOVERY)) {\n\t\t\tvport->num_disc_nodes = 0;\n\t\t\t \n\t\t\tif (vport->fc_npr_cnt)\n\t\t\t\tlpfc_els_disc_plogi(vport);\n\t\t\tif (!vport->num_disc_nodes) {\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tlpfc_can_disctmo(vport);\n\t\t\t\tlpfc_end_rscn(vport);\n\t\t\t}\n\t\t}\n\t\tvport->port_state = LPFC_VPORT_READY;\n\t} else\n\t\tlpfc_rscn_disc(vport);\n}\n\n \nvoid\nlpfc_more_adisc(struct lpfc_vport *vport)\n{\n\tif (vport->num_disc_nodes)\n\t\tvport->num_disc_nodes--;\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0210 Continue discovery with %d ADISCs to go \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t vport->num_disc_nodes, vport->fc_adisc_cnt,\n\t\t\t vport->fc_flag, vport->port_state);\n\t \n\tif (vport->fc_flag & FC_NLP_MORE) {\n\t\tlpfc_set_disctmo(vport);\n\t\t \n\t\tlpfc_els_disc_adisc(vport);\n\t}\n\tif (!vport->num_disc_nodes)\n\t\tlpfc_adisc_done(vport);\n\treturn;\n}\n\n \nstatic void\nlpfc_cmpl_els_adisc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\tstruct lpfc_nodelist *ndlp;\n\tint  disc;\n\tu32 ulp_status, ulp_word4, tmo;\n\tbool release_node = false;\n\n\t \n\tcmdiocb->rsp_iocb = rspiocb;\n\n\tndlp = cmdiocb->ndlp;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\ttmo = get_wqe_tmo(cmdiocb);\n\t} else {\n\t\tirsp = &rspiocb->iocb;\n\t\ttmo = irsp->ulpTimeout;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"ADISC cmpl:      status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4,\n\t\tndlp->nlp_DID);\n\n\t \n\tspin_lock_irq(&ndlp->lock);\n\tdisc = (ndlp->nlp_flag & NLP_NPR_2B_DISC);\n\tndlp->nlp_flag &= ~(NLP_ADISC_SND | NLP_NPR_2B_DISC);\n\tspin_unlock_irq(&ndlp->lock);\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0104 ADISC completes to NPort x%x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ulp_status, ulp_word4,\n\t\t\t tmo, disc, vport->num_disc_nodes);\n\t \n\tif (lpfc_els_chk_latt(vport)) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tgoto out;\n\t}\n\n\tif (ulp_status) {\n\t\t \n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb)) {\n\t\t\t \n\t\t\tif (disc) {\n\t\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t\tlpfc_set_disctmo(vport);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2755 ADISC failure DID:%06X Status:x%x/x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ulp_status,\n\t\t\t\t ulp_word4);\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_CMPL_ADISC);\n\n\t\t \n\t\tspin_lock_irq(&ndlp->lock);\n\t\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD))) {\n\t\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\t\tif (!(ndlp->nlp_flag & NLP_IN_DEV_LOSS))\n\t\t\t\trelease_node = true;\n\t\t}\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\tif (release_node)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t} else\n\t\t \n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_CMPL_ADISC);\n\n\t \n\tif (disc && vport->num_disc_nodes)\n\t\tlpfc_more_adisc(vport);\nout:\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n \nint\nlpfc_issue_els_adisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t     uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tADISC *ap;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(ADISC));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ADISC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t \n\t*((uint32_t *) (pcmd)) = ELS_CMD_ADISC;\n\tpcmd += sizeof(uint32_t);\n\n\t \n\tap = (ADISC *) pcmd;\n\tap->hardAL_PA = phba->fc_pref_ALPA;\n\tmemcpy(&ap->portName, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(&ap->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\n\tap->DID = be32_to_cpu(vport->fc_myDID);\n\n\tphba->fc_stat.elsXmitADISC++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_adisc;\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_ADISC_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto err;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue ADISC:   did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_ADISC_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\treturn 1;\n}\n\n \nstatic void\nlpfc_cmpl_els_logo(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tIOCB_t *irsp;\n\tunsigned long flags;\n\tuint32_t skip_recovery = 0;\n\tint wake_up_waiter = 0;\n\tu32 ulp_status;\n\tu32 ulp_word4;\n\tu32 tmo;\n\n\t \n\tcmdiocb->rsp_iocb = rspiocb;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\ttmo = get_wqe_tmo(cmdiocb);\n\t} else {\n\t\tirsp = &rspiocb->iocb;\n\t\ttmo = irsp->ulpTimeout;\n\t}\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_LOGO_SND;\n\tif (ndlp->save_flags & NLP_WAIT_FOR_LOGO) {\n\t\twake_up_waiter = 1;\n\t\tndlp->save_flags &= ~NLP_WAIT_FOR_LOGO;\n\t}\n\tspin_unlock_irq(&ndlp->lock);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"LOGO cmpl:       status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4,\n\t\tndlp->nlp_DID);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0105 LOGO completes to NPort x%x \"\n\t\t\t \"refcnt %d nflags x%x Data: x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, kref_read(&ndlp->kref), ndlp->nlp_flag,\n\t\t\t ulp_status, ulp_word4,\n\t\t\t tmo, vport->num_disc_nodes);\n\n\tif (lpfc_els_chk_latt(vport)) {\n\t\tskip_recovery = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tif (ulp_status) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2756 LOGO failure, No Retry DID:%06X \"\n\t\t\t\t \"Status:x%x/x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ulp_status,\n\t\t\t\t ulp_word4);\n\n\t\tif (lpfc_error_lost_link(vport, ulp_status, ulp_word4))\n\t\t\tskip_recovery = 1;\n\t}\n\n\t \n\tlpfc_disc_state_machine(vport, ndlp, cmdiocb, NLP_EVT_CMPL_LOGO);\n\n\tif (skip_recovery)\n\t\tgoto out;\n\n\t \n\tif (ndlp->nlp_flag & NLP_TARGET_REMOVE) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tndlp->nlp_flag |= NLP_RELEASE_RPI;\n\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tgoto out_rsrc_free;\n\t}\n\nout:\n\t \n\n\tif (wake_up_waiter && ndlp->logo_waitq)\n\t\twake_up(ndlp->logo_waitq);\n\t \n\tif (ndlp->nlp_type & (NLP_FCP_TARGET | NLP_NVME_TARGET) &&\n\t    skip_recovery == 0) {\n\t\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\t\tspin_lock_irqsave(&ndlp->lock, flags);\n\t\tndlp->nlp_flag |= NLP_NPR_2B_DISC;\n\t\tspin_unlock_irqrestore(&ndlp->lock, flags);\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"3187 LOGO completes to NPort x%x: Start \"\n\t\t\t\t \"Recovery Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ulp_status,\n\t\t\t\t ulp_word4, tmo,\n\t\t\t\t vport->num_disc_nodes);\n\n\t\tlpfc_els_free_iocb(phba, cmdiocb);\n\t\tlpfc_nlp_put(ndlp);\n\n\t\tlpfc_disc_start(vport);\n\t\treturn;\n\t}\n\n\t \n\tif (!(ndlp->fc4_xpt_flags & (SCSI_XPT_REGD | NVME_XPT_REGD))) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tlpfc_disc_state_machine(vport, ndlp, cmdiocb,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t}\nout_rsrc_free:\n\t \n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n \nint\nlpfc_issue_els_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t    uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint rc;\n\n\tspin_lock_irq(&ndlp->lock);\n\tif (ndlp->nlp_flag & NLP_LOGO_SND) {\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn 0;\n\t}\n\tspin_unlock_irq(&ndlp->lock);\n\n\tcmdsize = (2 * sizeof(uint32_t)) + sizeof(struct lpfc_name);\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_LOGO);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *) (pcmd)) = ELS_CMD_LOGO;\n\tpcmd += sizeof(uint32_t);\n\n\t \n\t*((uint32_t *) (pcmd)) = be32_to_cpu(vport->fc_myDID);\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, &vport->fc_portname, sizeof(struct lpfc_name));\n\n\tphba->fc_stat.elsXmitLOGO++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_logo;\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_LOGO_SND;\n\tndlp->nlp_flag &= ~NLP_ISSUE_LOGO;\n\tspin_unlock_irq(&ndlp->lock);\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto err;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue LOGO:      did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_prev_state = ndlp->nlp_state;\n\tspin_unlock_irq(&ndlp->lock);\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_LOGO_ISSUE);\n\treturn 0;\n\nerr:\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_LOGO_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\treturn 1;\n}\n\n \nstatic void\nlpfc_cmpl_els_cmd(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct lpfc_nodelist *free_ndlp;\n\tIOCB_t *irsp;\n\tu32 ulp_status, ulp_word4, tmo, did, iotag;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\tdid = get_job_els_rsp64_did(phba, cmdiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\ttmo = get_wqe_tmo(cmdiocb);\n\t\tiotag = get_wqe_reqtag(cmdiocb);\n\t} else {\n\t\tirsp = &rspiocb->iocb;\n\t\ttmo = irsp->ulpTimeout;\n\t\tiotag = irsp->ulpIoTag;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"ELS cmd cmpl:    status:x%x/x%x did:x%x\",\n\t\t\t      ulp_status, ulp_word4, did);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0106 ELS cmd tag x%x completes Data: x%x x%x x%x\\n\",\n\t\t\t iotag, ulp_status, ulp_word4, tmo);\n\n\t \n\tlpfc_els_chk_latt(vport);\n\n\tfree_ndlp = cmdiocb->ndlp;\n\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(free_ndlp);\n}\n\n \nstatic int\nlpfc_reg_fab_ctrl_node(struct lpfc_vport *vport, struct lpfc_nodelist *fc_ndlp)\n{\n\tint rc = 0;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_nodelist *ns_ndlp;\n\tLPFC_MBOXQ_t *mbox;\n\n\tif (fc_ndlp->nlp_flag & NLP_RPI_REGISTERED)\n\t\treturn rc;\n\n\tns_ndlp = lpfc_findnode_did(vport, NameServer_DID);\n\tif (!ns_ndlp)\n\t\treturn -ENODEV;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE,\n\t\t\t \"0935 %s: Reg FC RPI x%x on FC DID x%x NSSte: x%x\\n\",\n\t\t\t __func__, fc_ndlp->nlp_rpi, fc_ndlp->nlp_DID,\n\t\t\t ns_ndlp->nlp_state);\n\tif (ns_ndlp->nlp_state != NLP_STE_UNMAPPED_NODE)\n\t\treturn -ENODEV;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_NODE,\n\t\t\t\t \"0936 %s: no memory for reg_login \"\n\t\t\t\t \"Data: x%x x%x x%x x%x\\n\", __func__,\n\t\t\t\t fc_ndlp->nlp_DID, fc_ndlp->nlp_state,\n\t\t\t\t fc_ndlp->nlp_flag, fc_ndlp->nlp_rpi);\n\t\treturn -ENOMEM;\n\t}\n\trc = lpfc_reg_rpi(phba, vport->vpi, fc_ndlp->nlp_DID,\n\t\t\t  (u8 *)&vport->fc_sparam, mbox, fc_ndlp->nlp_rpi);\n\tif (rc) {\n\t\trc = -EACCES;\n\t\tgoto out;\n\t}\n\n\tfc_ndlp->nlp_flag |= NLP_REG_LOGIN_SEND;\n\tmbox->mbox_cmpl = lpfc_mbx_cmpl_fc_reg_login;\n\tmbox->ctx_ndlp = lpfc_nlp_get(fc_ndlp);\n\tif (!mbox->ctx_ndlp) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmbox->vport = vport;\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\trc = -ENODEV;\n\t\tlpfc_nlp_put(fc_ndlp);\n\t\tgoto out;\n\t}\n\t \n\tlpfc_nlp_set_state(vport, fc_ndlp,\n\t\t\t   NLP_STE_REG_LOGIN_ISSUE);\n\treturn 0;\n\n out:\n\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_NODE,\n\t\t\t \"0938 %s: failed to format reg_login \"\n\t\t\t \"Data: x%x x%x x%x x%x\\n\", __func__,\n\t\t\t fc_ndlp->nlp_DID, fc_ndlp->nlp_state,\n\t\t\t fc_ndlp->nlp_flag, fc_ndlp->nlp_rpi);\n\treturn rc;\n}\n\n \nstatic void\nlpfc_cmpl_els_disc_cmd(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t       struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\tstruct lpfc_els_rdf_rsp *prdf;\n\tstruct lpfc_dmabuf *pcmd, *prsp;\n\tu32 *pdata;\n\tu32 cmd;\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tu32 ulp_status, ulp_word4, tmo, did, iotag;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\tdid = get_job_els_rsp64_did(phba, cmdiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\ttmo = get_wqe_tmo(cmdiocb);\n\t\tiotag = get_wqe_reqtag(cmdiocb);\n\t} else {\n\t\tirsp = &rspiocb->iocb;\n\t\ttmo = irsp->ulpTimeout;\n\t\tiotag = irsp->ulpIoTag;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"ELS cmd cmpl:    status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4, did);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t \"0217 ELS cmd tag x%x completes Data: x%x x%x x%x x%x\\n\",\n\t\t\t iotag, ulp_status, ulp_word4, tmo, cmdiocb->retry);\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tif (!pcmd)\n\t\tgoto out;\n\n\tpdata = (u32 *)pcmd->virt;\n\tif (!pdata)\n\t\tgoto out;\n\tcmd = *pdata;\n\n\t \n\tif (ulp_status == IOSTAT_LOCAL_REJECT &&\n\t    ((ulp_word4 & IOERR_PARAM_MASK) ==\n\t    IOERR_SEQUENCE_TIMEOUT)) {\n\t\tcmdiocb->retry++;\n\t\tif (cmdiocb->retry <= 1) {\n\t\t\tswitch (cmd) {\n\t\t\tcase ELS_CMD_SCR:\n\t\t\t\tlpfc_issue_els_scr(vport, cmdiocb->retry);\n\t\t\t\tbreak;\n\t\t\tcase ELS_CMD_EDC:\n\t\t\t\tlpfc_issue_els_edc(vport, cmdiocb->retry);\n\t\t\t\tbreak;\n\t\t\tcase ELS_CMD_RDF:\n\t\t\t\tlpfc_issue_els_rdf(vport, cmdiocb->retry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\tphba->fc_stat.elsRetryExceeded++;\n\t}\n\tif (cmd == ELS_CMD_EDC) {\n\t\t \n\t\tlpfc_cmpl_els_edc(phba, cmdiocb, rspiocb);\n\t\treturn;\n\t}\n\tif (ulp_status) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t\t \"4203 ELS cmd x%x error: x%x x%X\\n\", cmd,\n\t\t\t\t ulp_status, ulp_word4);\n\t\tgoto out;\n\t}\n\n\t \n\tif (cmd == ELS_CMD_RDF) {\n\t\tint i;\n\n\t\tprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\n\t\tif (!prsp)\n\t\t\tgoto out;\n\n\t\tprdf = (struct lpfc_els_rdf_rsp *)prsp->virt;\n\t\tif (!prdf)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < ELS_RDF_REG_TAG_CNT &&\n\t\t\t    i < be32_to_cpu(prdf->reg_d1.reg_desc.count); i++)\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_ELS | LOG_CGN_MGMT,\n\t\t\t\t\t \"4677 Fabric RDF Notification Grant \"\n\t\t\t\t\t \"Data: 0x%08x Reg: %x %x\\n\",\n\t\t\t\t\t be32_to_cpu(\n\t\t\t\t\t\t prdf->reg_d1.desc_tags[i]),\n\t\t\t\t\t phba->cgn_reg_signal,\n\t\t\t\t\t phba->cgn_reg_fpin);\n\t}\n\nout:\n\t \n\tlpfc_els_chk_latt(vport);\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n \nint\nlpfc_issue_els_scr(struct lpfc_vport *vport, uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tstruct lpfc_nodelist *ndlp;\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(SCR));\n\n\tndlp = lpfc_findnode_did(vport, Fabric_Cntl_DID);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, Fabric_Cntl_DID);\n\t\tif (!ndlp)\n\t\t\treturn 1;\n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_SCR);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\trc = lpfc_reg_fab_ctrl_node(vport, ndlp);\n\t\tif (rc) {\n\t\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_NODE,\n\t\t\t\t\t \"0937 %s: Failed to reg fc node, rc %d\\n\",\n\t\t\t\t\t __func__, rc);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_SCR;\n\tpcmd += sizeof(uint32_t);\n\n\t \n\tmemset(pcmd, 0, sizeof(SCR));\n\t((SCR *) pcmd)->Function = SCR_FUNC_FULL;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue SCR:       did:x%x\",\n\t\tndlp->nlp_DID, 0, 0);\n\n\tphba->fc_stat.elsXmitSCR++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_disc_cmd;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue SCR:     did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nint\nlpfc_issue_els_rscn(struct lpfc_vport *vport, uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct {\n\t\tstruct fc_els_rscn rscn;\n\t\tstruct fc_els_rscn_page portid;\n\t} *event;\n\tuint32_t nportid;\n\tuint16_t cmdsize = sizeof(*event);\n\n\t \n\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP &&\n\t    !(vport->fc_flag & FC_PUBLIC_LOOP))\n\t\treturn 1;\n\n\tif (vport->fc_flag & FC_PT2PT) {\n\t\t \n\t\tndlp = lpfc_findnode_mapped(vport);\n\t\tif (!ndlp)\n\t\t\treturn 1;\n\t} else {\n\t\tnportid = FC_FID_FCTRL;\n\t\t \n\t\tndlp = lpfc_findnode_did(vport, nportid);\n\t\tif (!ndlp) {\n\t\t\t \n\t\t\tndlp = lpfc_nlp_init(vport, nportid);\n\t\t\tif (!ndlp)\n\t\t\t\treturn 1;\n\t\t\tlpfc_enqueue_node(vport, ndlp);\n\t\t}\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_RSCN_XMT);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tevent = elsiocb->cmd_dmabuf->virt;\n\n\tevent->rscn.rscn_cmd = ELS_RSCN;\n\tevent->rscn.rscn_page_len = sizeof(struct fc_els_rscn_page);\n\tevent->rscn.rscn_plen = cpu_to_be16(cmdsize);\n\n\tnportid = vport->fc_myDID;\n\t \n\tevent->portid.rscn_page_flags = 0;\n\tevent->portid.rscn_fid[0] = (nportid & 0x00FF0000) >> 16;\n\tevent->portid.rscn_fid[1] = (nportid & 0x0000FF00) >> 8;\n\tevent->portid.rscn_fid[2] = nportid & 0x000000FF;\n\n\tphba->fc_stat.elsXmitRSCN++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_cmd;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue RSCN:       did:x%x\",\n\t\t\t      ndlp->nlp_DID, 0, 0);\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_issue_els_farpr(struct lpfc_vport *vport, uint32_t nportid, uint8_t retry)\n{\n\tint rc = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tFARP *fp;\n\tuint8_t *pcmd;\n\tuint32_t *lp;\n\tuint16_t cmdsize;\n\tstruct lpfc_nodelist *ondlp;\n\tstruct lpfc_nodelist *ndlp;\n\n\tcmdsize = (sizeof(uint32_t) + sizeof(FARP));\n\n\tndlp = lpfc_findnode_did(vport, nportid);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, nportid);\n\t\tif (!ndlp)\n\t\t\treturn 1;\n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_FARPR);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_FARPR;\n\tpcmd += sizeof(uint32_t);\n\n\t \n\tfp = (FARP *) (pcmd);\n\tmemset(fp, 0, sizeof(FARP));\n\tlp = (uint32_t *) pcmd;\n\t*lp++ = be32_to_cpu(nportid);\n\t*lp++ = be32_to_cpu(vport->fc_myDID);\n\tfp->Rflags = 0;\n\tfp->Mflags = (FARP_MATCH_PORT | FARP_MATCH_NODE);\n\n\tmemcpy(&fp->RportName, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(&fp->RnodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\n\tondlp = lpfc_findnode_did(vport, nportid);\n\tif (ondlp) {\n\t\tmemcpy(&fp->OportName, &ondlp->nlp_portname,\n\t\t       sizeof(struct lpfc_name));\n\t\tmemcpy(&fp->OnodeName, &ondlp->nlp_nodename,\n\t\t       sizeof(struct lpfc_name));\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue FARPR:     did:x%x\",\n\t\tndlp->nlp_DID, 0, 0);\n\n\tphba->fc_stat.elsXmitFARPR++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_cmd;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\t \n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\t \n\t \n\treturn 0;\n}\n\n \nint\nlpfc_issue_els_rdf(struct lpfc_vport *vport, uint8_t retry)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_els_rdf_req *prdf;\n\tstruct lpfc_nodelist *ndlp;\n\tuint16_t cmdsize;\n\tint rc;\n\n\tcmdsize = sizeof(*prdf);\n\n\tndlp = lpfc_findnode_did(vport, Fabric_Cntl_DID);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, Fabric_Cntl_DID);\n\t\tif (!ndlp)\n\t\t\treturn -ENODEV;\n\t\tlpfc_enqueue_node(vport, ndlp);\n\t}\n\n\t \n\tif (vport->port_type == LPFC_NPIV_PORT)\n\t\treturn -EACCES;\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_RDF);\n\tif (!elsiocb)\n\t\treturn -ENOMEM;\n\n\t \n\tprdf = (struct lpfc_els_rdf_req *)elsiocb->cmd_dmabuf->virt;\n\tmemset(prdf, 0, cmdsize);\n\tprdf->rdf.fpin_cmd = ELS_RDF;\n\tprdf->rdf.desc_len = cpu_to_be32(sizeof(struct lpfc_els_rdf_req) -\n\t\t\t\t\t sizeof(struct fc_els_rdf));\n\tprdf->reg_d1.reg_desc.desc_tag = cpu_to_be32(ELS_DTAG_FPIN_REGISTER);\n\tprdf->reg_d1.reg_desc.desc_len = cpu_to_be32(\n\t\t\t\tFC_TLV_DESC_LENGTH_FROM_SZ(prdf->reg_d1));\n\tprdf->reg_d1.reg_desc.count = cpu_to_be32(ELS_RDF_REG_TAG_CNT);\n\tprdf->reg_d1.desc_tags[0] = cpu_to_be32(ELS_DTAG_LNK_INTEGRITY);\n\tprdf->reg_d1.desc_tags[1] = cpu_to_be32(ELS_DTAG_DELIVERY);\n\tprdf->reg_d1.desc_tags[2] = cpu_to_be32(ELS_DTAG_PEER_CONGEST);\n\tprdf->reg_d1.desc_tags[3] = cpu_to_be32(ELS_DTAG_CONGESTION);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t \"6444 Xmit RDF to remote NPORT x%x Reg: %x %x\\n\",\n\t\t\t ndlp->nlp_DID, phba->cgn_reg_signal,\n\t\t\t phba->cgn_reg_fpin);\n\n\tphba->cgn_fpin_frequency = LPFC_FPIN_INIT_FREQ;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_disc_cmd;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn -EIO;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue RDF:     did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n  \nstatic int\nlpfc_els_rcv_rdf(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\t \n\tif (lpfc_els_rsp_acc(vport, ELS_CMD_RDF, cmdiocb, ndlp, NULL)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t\t \"1623 Failed to RDF_ACC from x%x for x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, vport->fc_myDID);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (lpfc_issue_els_rdf(vport, 0)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t\t \"2623 Failed to re register RDF for x%x\\n\",\n\t\t\t\t vport->fc_myDID);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nlpfc_least_capable_settings(struct lpfc_hba *phba,\n\t\t\t    struct fc_diag_cg_sig_desc *pcgd)\n{\n\tu32 rsp_sig_cap = 0, drv_sig_cap = 0;\n\tu32 rsp_sig_freq_cyc = 0, rsp_sig_freq_scale = 0;\n\n\t \n\trsp_sig_cap = be32_to_cpu(pcgd->xmt_signal_capability);\n\trsp_sig_freq_cyc = be16_to_cpu(pcgd->xmt_signal_frequency.count);\n\trsp_sig_freq_scale = be16_to_cpu(pcgd->xmt_signal_frequency.units);\n\n\t \n\tif (rsp_sig_cap == EDC_CG_SIG_NOTSUPPORTED)\n\t\tgoto out_no_support;\n\n\t \n\tswitch (rsp_sig_freq_scale) {\n\tcase EDC_CG_SIGFREQ_SEC:\n\t\trsp_sig_freq_cyc *= MSEC_PER_SEC;\n\t\tbreak;\n\tcase EDC_CG_SIGFREQ_MSEC:\n\t\trsp_sig_freq_cyc = 1;\n\t\tbreak;\n\tdefault:\n\t\tgoto out_no_support;\n\t}\n\n\t \n\tdrv_sig_cap = phba->cgn_reg_signal;\n\n\t \n\tif (rsp_sig_freq_cyc > phba->cgn_sig_freq)\n\t\tphba->cgn_sig_freq = rsp_sig_freq_cyc;\n\n\t \n\tphba->cgn_reg_fpin = LPFC_CGN_FPIN_WARN | LPFC_CGN_FPIN_ALARM;\n\tphba->cgn_reg_signal = EDC_CG_SIG_NOTSUPPORTED;\n\tif (rsp_sig_cap == EDC_CG_SIG_WARN_ONLY &&\n\t    (drv_sig_cap == EDC_CG_SIG_WARN_ONLY ||\n\t     drv_sig_cap == EDC_CG_SIG_WARN_ALARM)) {\n\t\tphba->cgn_reg_signal = EDC_CG_SIG_WARN_ONLY;\n\t\tphba->cgn_reg_fpin &= ~LPFC_CGN_FPIN_WARN;\n\t}\n\tif (rsp_sig_cap == EDC_CG_SIG_WARN_ALARM) {\n\t\tif (drv_sig_cap == EDC_CG_SIG_WARN_ALARM) {\n\t\t\tphba->cgn_reg_signal = EDC_CG_SIG_WARN_ALARM;\n\t\t\tphba->cgn_reg_fpin = LPFC_CGN_FPIN_NONE;\n\t\t}\n\t\tif (drv_sig_cap == EDC_CG_SIG_WARN_ONLY) {\n\t\t\tphba->cgn_reg_signal = EDC_CG_SIG_WARN_ONLY;\n\t\t\tphba->cgn_reg_fpin &= ~LPFC_CGN_FPIN_WARN;\n\t\t}\n\t}\n\n\t \n\treturn;\n\nout_no_support:\n\tphba->cgn_reg_signal = EDC_CG_SIG_NOTSUPPORTED;\n\tphba->cgn_sig_freq = 0;\n\tphba->cgn_reg_fpin = LPFC_CGN_FPIN_ALARM | LPFC_CGN_FPIN_WARN;\n}\n\nDECLARE_ENUM2STR_LOOKUP(lpfc_get_tlv_dtag_nm, fc_ls_tlv_dtag,\n\t\t\tFC_LS_TLV_DTAG_INIT);\n\n \nstatic void\nlpfc_cmpl_els_edc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_iocbq *rspiocb)\n{\n\tIOCB_t *irsp_iocb;\n\tstruct fc_els_edc_resp *edc_rsp;\n\tstruct fc_tlv_desc *tlv;\n\tstruct fc_diag_cg_sig_desc *pcgd;\n\tstruct fc_diag_lnkflt_desc *plnkflt;\n\tstruct lpfc_dmabuf *pcmd, *prsp;\n\tconst char *dtag_nm;\n\tu32 *pdata, dtag;\n\tint desc_cnt = 0, bytes_remain;\n\tbool rcv_cap_desc = false;\n\tstruct lpfc_nodelist *ndlp;\n\tu32 ulp_status, ulp_word4, tmo, did, iotag;\n\n\tndlp = cmdiocb->ndlp;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\tdid = get_job_els_rsp64_did(phba, rspiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\ttmo = get_wqe_tmo(rspiocb);\n\t\tiotag = get_wqe_reqtag(rspiocb);\n\t} else {\n\t\tirsp_iocb = &rspiocb->iocb;\n\t\ttmo = irsp_iocb->ulpTimeout;\n\t\tiotag = irsp_iocb->ulpIoTag;\n\t}\n\n\tlpfc_debugfs_disc_trc(phba->pport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"EDC cmpl:    status:x%x/x%x did:x%x\",\n\t\t\t      ulp_status, ulp_word4, did);\n\n\t \n\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t\"4201 EDC cmd tag x%x completes Data: x%x x%x x%x\\n\",\n\t\t\tiotag, ulp_status, ulp_word4, tmo);\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tif (!pcmd)\n\t\tgoto out;\n\n\tpdata = (u32 *)pcmd->virt;\n\tif (!pdata)\n\t\tgoto out;\n\n\t \n\tif (ulp_status)\n\t\tgoto out;\n\n\tprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\n\tif (!prsp)\n\t\tgoto out;\n\n\tedc_rsp = prsp->virt;\n\tif (!edc_rsp)\n\t\tgoto out;\n\n\t \n\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\tLOG_ELS | LOG_CGN_MGMT | LOG_LDS_EVENT,\n\t\t\t\"4676 Fabric EDC Rsp: \"\n\t\t\t\"0x%02x, 0x%08x\\n\",\n\t\t\tedc_rsp->acc_hdr.la_cmd,\n\t\t\tbe32_to_cpu(edc_rsp->desc_list_len));\n\n\t \n\tbytes_remain = be32_to_cpu(edc_rsp->desc_list_len) -\n\t\t\t\t   sizeof(struct fc_els_lsri_desc);\n\tif (bytes_remain <= 0)\n\t\tgoto out;\n\n\ttlv = edc_rsp->desc;\n\n\t \n\twhile (bytes_remain) {\n\t\tif (bytes_remain < FC_TLV_DESC_HDR_SZ) {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_CGN_MGMT,\n\t\t\t\t\t\"6461 Truncated TLV hdr on \"\n\t\t\t\t\t\"Diagnostic descriptor[%d]\\n\",\n\t\t\t\t\tdesc_cnt);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdtag = be32_to_cpu(tlv->desc_tag);\n\t\tswitch (dtag) {\n\t\tcase ELS_DTAG_LNK_FAULT_CAP:\n\t\t\tif (bytes_remain < FC_TLV_DESC_SZ_FROM_LENGTH(tlv) ||\n\t\t\t    FC_TLV_DESC_SZ_FROM_LENGTH(tlv) !=\n\t\t\t\t\tsizeof(struct fc_diag_lnkflt_desc)) {\n\t\t\t\tlpfc_printf_log(phba, KERN_WARNING,\n\t\t\t\t\tLOG_ELS | LOG_CGN_MGMT | LOG_LDS_EVENT,\n\t\t\t\t\t\"6462 Truncated Link Fault Diagnostic \"\n\t\t\t\t\t\"descriptor[%d]: %d vs 0x%zx 0x%zx\\n\",\n\t\t\t\t\tdesc_cnt, bytes_remain,\n\t\t\t\t\tFC_TLV_DESC_SZ_FROM_LENGTH(tlv),\n\t\t\t\t\tsizeof(struct fc_diag_lnkflt_desc));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tplnkflt = (struct fc_diag_lnkflt_desc *)tlv;\n\t\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\tLOG_ELS | LOG_LDS_EVENT,\n\t\t\t\t\"4617 Link Fault Desc Data: 0x%08x 0x%08x \"\n\t\t\t\t\"0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t\tbe32_to_cpu(plnkflt->desc_tag),\n\t\t\t\tbe32_to_cpu(plnkflt->desc_len),\n\t\t\t\tbe32_to_cpu(\n\t\t\t\t\tplnkflt->degrade_activate_threshold),\n\t\t\t\tbe32_to_cpu(\n\t\t\t\t\tplnkflt->degrade_deactivate_threshold),\n\t\t\t\tbe32_to_cpu(plnkflt->fec_degrade_interval));\n\t\t\tbreak;\n\t\tcase ELS_DTAG_CG_SIGNAL_CAP:\n\t\t\tif (bytes_remain < FC_TLV_DESC_SZ_FROM_LENGTH(tlv) ||\n\t\t\t    FC_TLV_DESC_SZ_FROM_LENGTH(tlv) !=\n\t\t\t\t\tsizeof(struct fc_diag_cg_sig_desc)) {\n\t\t\t\tlpfc_printf_log(\n\t\t\t\t\tphba, KERN_WARNING, LOG_CGN_MGMT,\n\t\t\t\t\t\"6463 Truncated Cgn Signal Diagnostic \"\n\t\t\t\t\t\"descriptor[%d]: %d vs 0x%zx 0x%zx\\n\",\n\t\t\t\t\tdesc_cnt, bytes_remain,\n\t\t\t\t\tFC_TLV_DESC_SZ_FROM_LENGTH(tlv),\n\t\t\t\t\tsizeof(struct fc_diag_cg_sig_desc));\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tpcgd = (struct fc_diag_cg_sig_desc *)tlv;\n\t\t\tlpfc_printf_log(\n\t\t\t\tphba, KERN_INFO, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t\t\"4616 CGN Desc Data: 0x%08x 0x%08x \"\n\t\t\t\t\"0x%08x 0x%04x 0x%04x 0x%08x 0x%04x 0x%04x\\n\",\n\t\t\t\tbe32_to_cpu(pcgd->desc_tag),\n\t\t\t\tbe32_to_cpu(pcgd->desc_len),\n\t\t\t\tbe32_to_cpu(pcgd->xmt_signal_capability),\n\t\t\t\tbe16_to_cpu(pcgd->xmt_signal_frequency.count),\n\t\t\t\tbe16_to_cpu(pcgd->xmt_signal_frequency.units),\n\t\t\t\tbe32_to_cpu(pcgd->rcv_signal_capability),\n\t\t\t\tbe16_to_cpu(pcgd->rcv_signal_frequency.count),\n\t\t\t\tbe16_to_cpu(pcgd->rcv_signal_frequency.units));\n\n\t\t\t \n\t\t\tlpfc_least_capable_settings(phba, pcgd);\n\t\t\trcv_cap_desc = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdtag_nm = lpfc_get_tlv_dtag_nm(dtag);\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_CGN_MGMT,\n\t\t\t\t\t\"4919 unknown Diagnostic \"\n\t\t\t\t\t\"Descriptor[%d]: tag x%x (%s)\\n\",\n\t\t\t\t\tdesc_cnt, dtag, dtag_nm);\n\t\t}\n\n\t\tbytes_remain -= FC_TLV_DESC_SZ_FROM_LENGTH(tlv);\n\t\ttlv = fc_tlv_next_desc(tlv);\n\t\tdesc_cnt++;\n\t}\n\nout:\n\tif (!rcv_cap_desc) {\n\t\tphba->cgn_reg_fpin = LPFC_CGN_FPIN_ALARM | LPFC_CGN_FPIN_WARN;\n\t\tphba->cgn_reg_signal = EDC_CG_SIG_NOTSUPPORTED;\n\t\tphba->cgn_sig_freq = 0;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t\t\"4202 EDC rsp error - sending RDF \"\n\t\t\t\t\"for FPIN only.\\n\");\n\t}\n\n\tlpfc_config_cgn_signal(phba);\n\n\t \n\tlpfc_els_chk_latt(phba->pport);\n\tlpfc_debugfs_disc_trc(phba->pport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"EDC Cmpl:     did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\nstatic void\nlpfc_format_edc_lft_desc(struct lpfc_hba *phba, struct fc_tlv_desc *tlv)\n{\n\tstruct fc_diag_lnkflt_desc *lft = (struct fc_diag_lnkflt_desc *)tlv;\n\n\tlft->desc_tag = cpu_to_be32(ELS_DTAG_LNK_FAULT_CAP);\n\tlft->desc_len = cpu_to_be32(\n\t\tFC_TLV_DESC_LENGTH_FROM_SZ(struct fc_diag_lnkflt_desc));\n\n\tlft->degrade_activate_threshold =\n\t\tcpu_to_be32(phba->degrade_activate_threshold);\n\tlft->degrade_deactivate_threshold =\n\t\tcpu_to_be32(phba->degrade_deactivate_threshold);\n\tlft->fec_degrade_interval = cpu_to_be32(phba->fec_degrade_interval);\n}\n\nstatic void\nlpfc_format_edc_cgn_desc(struct lpfc_hba *phba, struct fc_tlv_desc *tlv)\n{\n\tstruct fc_diag_cg_sig_desc *cgd = (struct fc_diag_cg_sig_desc *)tlv;\n\n\t \n\n\t \n\tcgd->desc_tag = cpu_to_be32(ELS_DTAG_CG_SIGNAL_CAP);\n\n\t \n\tcgd->desc_len = cpu_to_be32(\n\t\tFC_TLV_DESC_LENGTH_FROM_SZ(struct fc_diag_cg_sig_desc));\n\n\t \n\n\tif (phba->cmf_active_mode == LPFC_CFG_OFF) {\n\t\t \n\t\tphba->cgn_sig_freq = 0;\n\t\treturn;\n\t}\n\tswitch (phba->cgn_reg_signal) {\n\tcase EDC_CG_SIG_WARN_ONLY:\n\t\tcgd->rcv_signal_capability = cpu_to_be32(EDC_CG_SIG_WARN_ONLY);\n\t\tbreak;\n\tcase EDC_CG_SIG_WARN_ALARM:\n\t\tcgd->rcv_signal_capability = cpu_to_be32(EDC_CG_SIG_WARN_ALARM);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tcgd->rcv_signal_frequency.count =\n\t\tcpu_to_be16(lpfc_fabric_cgn_frequency);\n\tcgd->rcv_signal_frequency.units =\n\t\tcpu_to_be16(EDC_CG_SIGFREQ_MSEC);\n}\n\nstatic bool\nlpfc_link_is_lds_capable(struct lpfc_hba *phba)\n{\n\tif (!(phba->lmt & LMT_64Gb))\n\t\treturn false;\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn false;\n\n\tif (phba->sli4_hba.conf_trunk) {\n\t\tif (phba->trunk_link.phy_lnk_speed == LPFC_USER_LINK_SPEED_64G)\n\t\t\treturn true;\n\t} else if (phba->fc_linkspeed == LPFC_LINK_SPEED_64GHZ) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n  \nint\nlpfc_issue_els_edc(struct lpfc_vport *vport, uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct fc_els_edc *edc_req;\n\tstruct fc_tlv_desc *tlv;\n\tu16 cmdsize;\n\tstruct lpfc_nodelist *ndlp;\n\tu8 *pcmd = NULL;\n\tu32 cgn_desc_size, lft_desc_size;\n\tint rc;\n\n\tif (vport->port_type == LPFC_NPIV_PORT)\n\t\treturn -EACCES;\n\n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_UNMAPPED_NODE)\n\t\treturn -ENODEV;\n\n\tcgn_desc_size = (phba->cgn_init_reg_signal) ?\n\t\t\t\tsizeof(struct fc_diag_cg_sig_desc) : 0;\n\tlft_desc_size = (lpfc_link_is_lds_capable(phba)) ?\n\t\t\t\tsizeof(struct fc_diag_lnkflt_desc) : 0;\n\tcmdsize = cgn_desc_size + lft_desc_size;\n\n\t \n\tif (!cmdsize)\n\t\tgoto try_rdf;\n\n\tcmdsize += sizeof(struct fc_els_edc);\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_EDC);\n\tif (!elsiocb)\n\t\tgoto try_rdf;\n\n\t \n\tpcmd = (u8 *)elsiocb->cmd_dmabuf->virt;\n\tmemset(pcmd, 0, cmdsize);\n\tedc_req = (struct fc_els_edc *)pcmd;\n\tedc_req->desc_len = cpu_to_be32(cgn_desc_size + lft_desc_size);\n\tedc_req->edc_cmd = ELS_EDC;\n\ttlv = edc_req->desc;\n\n\tif (cgn_desc_size) {\n\t\tlpfc_format_edc_cgn_desc(phba, tlv);\n\t\tphba->cgn_sig_freq = lpfc_fabric_cgn_frequency;\n\t\ttlv = fc_tlv_next_desc(tlv);\n\t}\n\n\tif (lft_desc_size)\n\t\tlpfc_format_edc_lft_desc(phba, tlv);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_CGN_MGMT,\n\t\t\t \"4623 Xmit EDC to remote \"\n\t\t\t \"NPORT x%x reg_sig x%x reg_fpin:x%x\\n\",\n\t\t\t ndlp->nlp_DID, phba->cgn_reg_signal,\n\t\t\t phba->cgn_reg_fpin);\n\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_disc_cmd;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn -EIO;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t      \"Issue EDC:     did:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, kref_read(&ndlp->kref), 0);\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\t \n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto try_rdf;\n\t}\n\treturn 0;\ntry_rdf:\n\tphba->cgn_reg_fpin = LPFC_CGN_FPIN_WARN | LPFC_CGN_FPIN_ALARM;\n\tphba->cgn_reg_signal = EDC_CG_SIG_NOTSUPPORTED;\n\trc = lpfc_issue_els_rdf(vport, 0);\n\treturn rc;\n}\n\n \nvoid\nlpfc_cancel_retry_delay_tmo(struct lpfc_vport *vport, struct lpfc_nodelist *nlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_work_evt *evtp;\n\n\tif (!(nlp->nlp_flag & NLP_DELAY_TMO))\n\t\treturn;\n\tspin_lock_irq(&nlp->lock);\n\tnlp->nlp_flag &= ~NLP_DELAY_TMO;\n\tspin_unlock_irq(&nlp->lock);\n\tdel_timer_sync(&nlp->nlp_delayfunc);\n\tnlp->nlp_last_elscmd = 0;\n\tif (!list_empty(&nlp->els_retry_evt.evt_listp)) {\n\t\tlist_del_init(&nlp->els_retry_evt.evt_listp);\n\t\t \n\t\tevtp = &nlp->els_retry_evt;\n\t\tlpfc_nlp_put((struct lpfc_nodelist *)evtp->evt_arg1);\n\t}\n\tif (nlp->nlp_flag & NLP_NPR_2B_DISC) {\n\t\tspin_lock_irq(&nlp->lock);\n\t\tnlp->nlp_flag &= ~NLP_NPR_2B_DISC;\n\t\tspin_unlock_irq(&nlp->lock);\n\t\tif (vport->num_disc_nodes) {\n\t\t\tif (vport->port_state < LPFC_VPORT_READY) {\n\t\t\t\t \n\t\t\t\tlpfc_more_adisc(vport);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tlpfc_more_plogi(vport);\n\t\t\t\tif (vport->num_disc_nodes == 0) {\n\t\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\t\tlpfc_can_disctmo(vport);\n\t\t\t\t\tlpfc_end_rscn(vport);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\n \nvoid\nlpfc_els_retry_delay(struct timer_list *t)\n{\n\tstruct lpfc_nodelist *ndlp = from_timer(ndlp, t, nlp_delayfunc);\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tunsigned long flags;\n\tstruct lpfc_work_evt  *evtp = &ndlp->els_retry_evt;\n\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tif (!list_empty(&evtp->evt_listp)) {\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\treturn;\n\t}\n\n\t \n\tevtp->evt_arg1  = lpfc_nlp_get(ndlp);\n\tif (evtp->evt_arg1) {\n\t\tevtp->evt = LPFC_EVT_ELS_RETRY;\n\t\tlist_add_tail(&evtp->evt_listp, &phba->work_list);\n\t\tlpfc_worker_wake_up(phba);\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\treturn;\n}\n\n \nvoid\nlpfc_els_retry_delay_handler(struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tuint32_t cmd, retry;\n\n\tspin_lock_irq(&ndlp->lock);\n\tcmd = ndlp->nlp_last_elscmd;\n\tndlp->nlp_last_elscmd = 0;\n\n\tif (!(ndlp->nlp_flag & NLP_DELAY_TMO)) {\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\treturn;\n\t}\n\n\tndlp->nlp_flag &= ~NLP_DELAY_TMO;\n\tspin_unlock_irq(&ndlp->lock);\n\t \n\tdel_timer_sync(&ndlp->nlp_delayfunc);\n\tretry = ndlp->nlp_retry;\n\tndlp->nlp_retry = 0;\n\n\tswitch (cmd) {\n\tcase ELS_CMD_FLOGI:\n\t\tlpfc_issue_els_flogi(vport, ndlp, retry);\n\t\tbreak;\n\tcase ELS_CMD_PLOGI:\n\t\tif (!lpfc_issue_els_plogi(vport, ndlp->nlp_DID, retry)) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t}\n\t\tbreak;\n\tcase ELS_CMD_ADISC:\n\t\tif (!lpfc_issue_els_adisc(vport, ndlp, retry)) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\n\t\t}\n\t\tbreak;\n\tcase ELS_CMD_PRLI:\n\tcase ELS_CMD_NVMEPRLI:\n\t\tif (!lpfc_issue_els_prli(vport, ndlp, retry)) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);\n\t\t}\n\t\tbreak;\n\tcase ELS_CMD_LOGO:\n\t\tif (!lpfc_issue_els_logo(vport, ndlp, retry)) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_LOGO_ISSUE);\n\t\t}\n\t\tbreak;\n\tcase ELS_CMD_FDISC:\n\t\tif (!(vport->fc_flag & FC_VPORT_NEEDS_INIT_VPI))\n\t\t\tlpfc_issue_els_fdisc(vport, ndlp, retry);\n\t\tbreak;\n\t}\n\treturn;\n}\n\n \nint\nlpfc_link_reset(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tuint32_t control;\n\tint rc;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\n\t\t\t \"2851 Attempt link reset\\n\");\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2852 Failed to allocate mbox memory\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (phba->sli_rev <= LPFC_SLI_REV3) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->sli.sli_flag |= LPFC_PROCESS_LA;\n\t\tcontrol = readl(phba->HCregaddr);\n\t\tcontrol |= HC_LAINT_ENA;\n\t\twritel(control, phba->HCregaddr);\n\t\treadl(phba->HCregaddr);  \n\t\tspin_unlock_irq(&phba->hbalock);\n\t}\n\n\tlpfc_init_link(phba, mbox, phba->cfg_topology,\n\t\t       phba->cfg_link_speed);\n\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\tmbox->vport = vport;\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif ((rc != MBX_BUSY) && (rc != MBX_SUCCESS)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"2853 Failed to issue INIT_LINK \"\n\t\t\t\t\"mbox command, rc:x%x\\n\", rc);\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_retry(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t       struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tunion lpfc_wqe128 *irsp = &rspiocb->wqe;\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tstruct lpfc_dmabuf *pcmd = cmdiocb->cmd_dmabuf;\n\tuint32_t *elscmd;\n\tstruct ls_rjt stat;\n\tint retry = 0, maxretry = lpfc_max_els_tries, delay = 0;\n\tint logerr = 0;\n\tuint32_t cmd = 0;\n\tuint32_t did;\n\tint link_reset = 0, rc;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\n\n\t \n\n\tif (pcmd && pcmd->virt) {\n\t\telscmd = (uint32_t *) (pcmd->virt);\n\t\tcmd = *elscmd++;\n\t}\n\n\tif (ndlp)\n\t\tdid = ndlp->nlp_DID;\n\telse {\n\t\t \n\t\tdid = get_job_els_rsp64_did(phba, rspiocb);\n\t\tndlp = lpfc_findnode_did(vport, did);\n\t\tif (!ndlp && (cmd != ELS_CMD_PLOGI))\n\t\t\treturn 0;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Retry ELS:       wd7:x%x wd4:x%x did:x%x\",\n\t\t*(((uint32_t *)irsp) + 7), ulp_word4, did);\n\n\tswitch (ulp_status) {\n\tcase IOSTAT_FCP_RSP_ERROR:\n\t\tbreak;\n\tcase IOSTAT_REMOTE_STOP:\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\t \n\t\t\tlpfc_set_rrq_active(phba, ndlp,\n\t\t\t\t\t cmdiocb->sli4_lxritag, 0, 0);\n\t\t}\n\t\tbreak;\n\tcase IOSTAT_LOCAL_REJECT:\n\t\tswitch ((ulp_word4 & IOERR_PARAM_MASK)) {\n\t\tcase IOERR_LOOP_OPEN_FAILURE:\n\t\t\tif (cmd == ELS_CMD_PLOGI && cmdiocb->retry == 0)\n\t\t\t\tdelay = 1000;\n\t\t\tretry = 1;\n\t\t\tbreak;\n\n\t\tcase IOERR_ILLEGAL_COMMAND:\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0124 Retry illegal cmd x%x \"\n\t\t\t\t\t \"retry:x%x delay:x%x\\n\",\n\t\t\t\t\t cmd, cmdiocb->retry, delay);\n\t\t\tretry = 1;\n\t\t\t \n\t\t\tmaxretry = 8;\n\t\t\tif (cmdiocb->retry > 2)\n\t\t\t\tdelay = 1000;\n\t\t\tbreak;\n\n\t\tcase IOERR_NO_RESOURCES:\n\t\t\tlogerr = 1;  \n\t\t\tretry = 1;\n\t\t\tif (cmdiocb->retry > 100)\n\t\t\t\tdelay = 100;\n\t\t\tmaxretry = 250;\n\t\t\tbreak;\n\n\t\tcase IOERR_ILLEGAL_FRAME:\n\t\t\tdelay = 100;\n\t\t\tretry = 1;\n\t\t\tbreak;\n\n\t\tcase IOERR_INVALID_RPI:\n\t\t\tif (cmd == ELS_CMD_PLOGI &&\n\t\t\t    did == NameServer_DID) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tmaxretry = 0;\n\t\t\t\tdelay = 100;\n\t\t\t} else if (cmd == ELS_CMD_PRLI &&\n\t\t\t\t   ndlp->nlp_state != NLP_STE_PRLI_ISSUE) {\n\t\t\t\t \n\t\t\t\tmaxretry = 0;\n\t\t\t\tretry = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = 1;\n\t\t\tbreak;\n\n\t\tcase IOERR_SEQUENCE_TIMEOUT:\n\t\t\tif (cmd == ELS_CMD_PLOGI &&\n\t\t\t    did == NameServer_DID &&\n\t\t\t    (cmdiocb->retry + 1) == maxretry) {\n\t\t\t\t \n\t\t\t\tlink_reset = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = 1;\n\t\t\tdelay = 100;\n\t\t\tbreak;\n\t\tcase IOERR_SLI_ABORTED:\n\t\t\t \n\t\t\tif (cmd == ELS_CMD_PLOGI) {\n\t\t\t\t \n\t\t\t\tif (ndlp &&\n\t\t\t\t    ndlp->nlp_state != NLP_STE_PLOGI_ISSUE)\n\t\t\t\t\tgoto out_retry;\n\t\t\t\tretry = 1;\n\t\t\t\tmaxretry = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IOSTAT_NPORT_RJT:\n\tcase IOSTAT_FABRIC_RJT:\n\t\tif (ulp_word4 & RJT_UNAVAIL_TEMP) {\n\t\t\tretry = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IOSTAT_NPORT_BSY:\n\tcase IOSTAT_FABRIC_BSY:\n\t\tlogerr = 1;  \n\t\tretry = 1;\n\t\tbreak;\n\n\tcase IOSTAT_LS_RJT:\n\t\tstat.un.ls_rjt_error_be = cpu_to_be32(ulp_word4);\n\t\t \n\t\tif ((vport->fc_flag & FC_PT2PT) &&\n\t\t    cmd == ELS_CMD_NVMEPRLI) {\n\t\t\tswitch (stat.un.b.lsRjtRsnCode) {\n\t\t\tcase LSRJT_UNABLE_TPC:\n\t\t\tcase LSRJT_INVALID_CMD:\n\t\t\tcase LSRJT_LOGICAL_ERR:\n\t\t\tcase LSRJT_CMD_UNSUPPORTED:\n\t\t\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_ELS,\n\t\t\t\t\t\t \"0168 NVME PRLI LS_RJT \"\n\t\t\t\t\t\t \"reason %x port doesn't \"\n\t\t\t\t\t\t \"support NVME, disabling NVME\\n\",\n\t\t\t\t\t\t stat.un.b.lsRjtRsnCode);\n\t\t\t\tretry = 0;\n\t\t\t\tvport->fc_flag |= FC_PT2PT_NO_NVME;\n\t\t\t\tgoto out_retry;\n\t\t\t}\n\t\t}\n\t\tswitch (stat.un.b.lsRjtRsnCode) {\n\t\tcase LSRJT_UNABLE_TPC:\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_DISCOVERY | LOG_ELS | LOG_NODE,\n\t\t\t\t\t \"0153 ELS cmd x%x LS_RJT by x%x. \"\n\t\t\t\t\t \"RsnCode x%x RsnCodeExp x%x\\n\",\n\t\t\t\t\t cmd, did, stat.un.b.lsRjtRsnCode,\n\t\t\t\t\t stat.un.b.lsRjtRsnCodeExp);\n\n\t\t\tswitch (stat.un.b.lsRjtRsnCodeExp) {\n\t\t\tcase LSEXP_CANT_GIVE_DATA:\n\t\t\tcase LSEXP_CMD_IN_PROGRESS:\n\t\t\t\tif (cmd == ELS_CMD_PLOGI) {\n\t\t\t\t\tdelay = 1000;\n\t\t\t\t\tmaxretry = 48;\n\t\t\t\t}\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\tcase LSEXP_REQ_UNSUPPORTED:\n\t\t\tcase LSEXP_NO_RSRC_ASSIGN:\n\t\t\t\t \n\t\t\t\tif (cmd == ELS_CMD_PRLI ||\n\t\t\t\t    cmd == ELS_CMD_NVMEPRLI)\n\t\t\t\t\tbreak;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tif (cmd == ELS_CMD_PLOGI ||\n\t\t\t\t    cmd == ELS_CMD_PRLI ||\n\t\t\t\t    cmd == ELS_CMD_NVMEPRLI) {\n\t\t\t\t\tdelay = 1000;\n\t\t\t\t\tmaxretry = lpfc_max_els_tries + 1;\n\t\t\t\t\tretry = 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t\t\t  (cmd == ELS_CMD_FDISC) &&\n\t\t\t  (stat.un.b.lsRjtRsnCodeExp == LSEXP_OUT_OF_RESOURCE)){\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\t \"0125 FDISC Failed (x%x). \"\n\t\t\t\t\t\t \"Fabric out of resources\\n\",\n\t\t\t\t\t\t stat.un.lsRjtError);\n\t\t\t\tlpfc_vport_set_state(vport,\n\t\t\t\t\t\t     FC_VPORT_NO_FABRIC_RSCS);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LSRJT_LOGICAL_BSY:\n\t\t\tif ((cmd == ELS_CMD_PLOGI) ||\n\t\t\t    (cmd == ELS_CMD_PRLI) ||\n\t\t\t    (cmd == ELS_CMD_NVMEPRLI)) {\n\t\t\t\tdelay = 1000;\n\t\t\t\tmaxretry = 48;\n\t\t\t} else if (cmd == ELS_CMD_FDISC) {\n\t\t\t\t \n\t\t\t\tmaxretry = 48;\n\t\t\t\tif (cmdiocb->retry >= 32)\n\t\t\t\t\tdelay = 1000;\n\t\t\t}\n\t\t\tretry = 1;\n\t\t\tbreak;\n\n\t\tcase LSRJT_LOGICAL_ERR:\n\t\t\t \n\t\t\tif (cmd == ELS_CMD_FDISC &&\n\t\t\t    stat.un.b.lsRjtRsnCodeExp == LSEXP_PORT_LOGIN_REQ) {\n\t\t\t\tmaxretry = 3;\n\t\t\t\tdelay = 1000;\n\t\t\t\tretry = 1;\n\t\t\t} else if (cmd == ELS_CMD_FLOGI &&\n\t\t\t\t   stat.un.b.lsRjtRsnCodeExp ==\n\t\t\t\t\t\tLSEXP_NOTHING_MORE) {\n\t\t\t\tvport->fc_sparam.cmn.bbRcvSizeMsb &= 0xf;\n\t\t\t\tretry = 1;\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\t \"0820 FLOGI Failed (x%x). \"\n\t\t\t\t\t\t \"BBCredit Not Supported\\n\",\n\t\t\t\t\t\t stat.un.lsRjtError);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LSRJT_PROTOCOL_ERR:\n\t\t\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t\t\t  (cmd == ELS_CMD_FDISC) &&\n\t\t\t  ((stat.un.b.lsRjtRsnCodeExp == LSEXP_INVALID_PNAME) ||\n\t\t\t  (stat.un.b.lsRjtRsnCodeExp == LSEXP_INVALID_NPORT_ID))\n\t\t\t  ) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\t \"0122 FDISC Failed (x%x). \"\n\t\t\t\t\t\t \"Fabric Detected Bad WWN\\n\",\n\t\t\t\t\t\t stat.un.lsRjtError);\n\t\t\t\tlpfc_vport_set_state(vport,\n\t\t\t\t\t\t     FC_VPORT_FABRIC_REJ_WWN);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LSRJT_VENDOR_UNIQUE:\n\t\t\tif ((stat.un.b.vendorUnique == 0x45) &&\n\t\t\t    (cmd == ELS_CMD_FLOGI)) {\n\t\t\t\tgoto out_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LSRJT_CMD_UNSUPPORTED:\n\t\t\t \n\t\t\tif (stat.un.b.lsRjtRsnCodeExp ==\n\t\t\t    LSEXP_REQ_UNSUPPORTED) {\n\t\t\t\tif (cmd == ELS_CMD_PRLI)\n\t\t\t\t\tgoto out_retry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IOSTAT_INTERMED_RSP:\n\tcase IOSTAT_BA_RJT:\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (link_reset) {\n\t\trc = lpfc_link_reset(vport);\n\t\tif (rc) {\n\t\t\t \n\t\t\tretry = 1;\n\t\t\tdelay = 100;\n\t\t\tgoto out_retry;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (did == FDMI_DID)\n\t\tretry = 1;\n\n\tif ((cmd == ELS_CMD_FLOGI) &&\n\t    (phba->fc_topology != LPFC_TOPOLOGY_LOOP) &&\n\t    !lpfc_error_lost_link(vport, ulp_status, ulp_word4)) {\n\t\t \n\t\tretry = 1;\n\t\t \n\t\tif (phba->link_flag != LS_LOOPBACK_MODE)\n\t\t\tmaxretry = 0;\n\t\telse\n\t\t\tmaxretry = 2;\n\n\t\tif (cmdiocb->retry >= 100)\n\t\t\tdelay = 5000;\n\t\telse if (cmdiocb->retry >= 32)\n\t\t\tdelay = 1000;\n\t} else if ((cmd == ELS_CMD_FDISC) &&\n\t    !lpfc_error_lost_link(vport, ulp_status, ulp_word4)) {\n\t\t \n\t\tretry = 1;\n\t\tmaxretry = vport->cfg_devloss_tmo;\n\t\tdelay = 1000;\n\t}\n\n\tcmdiocb->retry++;\n\tif (maxretry && (cmdiocb->retry >= maxretry)) {\n\t\tphba->fc_stat.elsRetryExceeded++;\n\t\tretry = 0;\n\t}\n\n\tif ((vport->load_flag & FC_UNLOADING) != 0)\n\t\tretry = 0;\n\nout_retry:\n\tif (retry) {\n\t\tif ((cmd == ELS_CMD_PLOGI) || (cmd == ELS_CMD_FDISC)) {\n\t\t\t \n\t\t\tif (phba->fcf.fcf_flag & FCF_DISCOVERY) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t\t\t \"2849 Stop retry ELS command \"\n\t\t\t\t\t\t \"x%x to remote NPORT x%x, \"\n\t\t\t\t\t\t \"Data: x%x x%x\\n\", cmd, did,\n\t\t\t\t\t\t cmdiocb->retry, delay);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"0107 Retry ELS command x%x to remote \"\n\t\t\t\t \"NPORT x%x Data: x%x x%x\\n\",\n\t\t\t\t cmd, did, cmdiocb->retry, delay);\n\n\t\tif (((cmd == ELS_CMD_PLOGI) || (cmd == ELS_CMD_ADISC)) &&\n\t\t\t((ulp_status != IOSTAT_LOCAL_REJECT) ||\n\t\t\t((ulp_word4 & IOERR_PARAM_MASK) !=\n\t\t\tIOERR_NO_RESOURCES))) {\n\t\t\t \n\n\t\t\t \n\t\t\tif (timer_pending(&vport->fc_disctmo) ||\n\t\t\t    (vport->fc_flag & FC_RSCN_MODE))\n\t\t\t\tlpfc_set_disctmo(vport);\n\t\t}\n\n\t\tphba->fc_stat.elsXmitRetry++;\n\t\tif (ndlp && delay) {\n\t\t\tphba->fc_stat.elsDelayRetry++;\n\t\t\tndlp->nlp_retry = cmdiocb->retry;\n\n\t\t\t \n\t\t\tmod_timer(&ndlp->nlp_delayfunc,\n\t\t\t\tjiffies + msecs_to_jiffies(delay));\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tif ((cmd == ELS_CMD_PRLI) ||\n\t\t\t    (cmd == ELS_CMD_NVMEPRLI))\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\tNLP_STE_PRLI_ISSUE);\n\t\t\telse if (cmd != ELS_CMD_ADISC)\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\tNLP_STE_NPR_NODE);\n\t\t\tndlp->nlp_last_elscmd = cmd;\n\n\t\t\treturn 1;\n\t\t}\n\t\tswitch (cmd) {\n\t\tcase ELS_CMD_FLOGI:\n\t\t\tlpfc_issue_els_flogi(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_FDISC:\n\t\t\tlpfc_issue_els_fdisc(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_PLOGI:\n\t\t\tif (ndlp) {\n\t\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t   NLP_STE_PLOGI_ISSUE);\n\t\t\t}\n\t\t\tlpfc_issue_els_plogi(vport, did, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_ADISC:\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\n\t\t\tlpfc_issue_els_adisc(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_PRLI:\n\t\tcase ELS_CMD_NVMEPRLI:\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PRLI_ISSUE);\n\t\t\tlpfc_issue_els_prli(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\tcase ELS_CMD_LOGO:\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_LOGO_ISSUE);\n\t\t\tlpfc_issue_els_logo(vport, ndlp, cmdiocb->retry);\n\t\t\treturn 1;\n\t\t}\n\t}\n\t \n\tif (logerr) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0137 No retry ELS command x%x to remote \"\n\t\t\t \"NPORT x%x: Out of Resources: Error:x%x/%x\\n\",\n\t\t\t cmd, did, ulp_status,\n\t\t\t ulp_word4);\n\t}\n\telse {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0108 No retry ELS command x%x to remote \"\n\t\t\t \"NPORT x%x Retried:%d Error:x%x/%x\\n\",\n\t\t\t cmd, did, cmdiocb->retry, ulp_status,\n\t\t\t ulp_word4);\n\t}\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_free_data(struct lpfc_hba *phba, struct lpfc_dmabuf *buf_ptr1)\n{\n\tstruct lpfc_dmabuf *buf_ptr;\n\n\t \n\tif (!list_empty(&buf_ptr1->list)) {\n\t\tlist_remove_head(&buf_ptr1->list, buf_ptr,\n\t\t\t\t struct lpfc_dmabuf,\n\t\t\t\t list);\n\t\tlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\n\t\tkfree(buf_ptr);\n\t}\n\tlpfc_mbuf_free(phba, buf_ptr1->virt, buf_ptr1->phys);\n\tkfree(buf_ptr1);\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_free_bpl(struct lpfc_hba *phba, struct lpfc_dmabuf *buf_ptr)\n{\n\tlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\n\tkfree(buf_ptr);\n\treturn 0;\n}\n\n \nint\nlpfc_els_free_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *elsiocb)\n{\n\tstruct lpfc_dmabuf *buf_ptr, *buf_ptr1;\n\n\t \n\telsiocb->ndlp = NULL;\n\n\t \n\tif (elsiocb->cmd_dmabuf) {\n\t\tif (elsiocb->cmd_flag & LPFC_DELAY_MEM_FREE) {\n\t\t\t \n\t\t\telsiocb->cmd_flag &= ~LPFC_DELAY_MEM_FREE;\n\t\t\tbuf_ptr = elsiocb->cmd_dmabuf;\n\t\t\telsiocb->cmd_dmabuf = NULL;\n\t\t\tif (buf_ptr) {\n\t\t\t\tbuf_ptr1 = NULL;\n\t\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\t\tif (!list_empty(&buf_ptr->list)) {\n\t\t\t\t\tlist_remove_head(&buf_ptr->list,\n\t\t\t\t\t\tbuf_ptr1, struct lpfc_dmabuf,\n\t\t\t\t\t\tlist);\n\t\t\t\t\tINIT_LIST_HEAD(&buf_ptr1->list);\n\t\t\t\t\tlist_add_tail(&buf_ptr1->list,\n\t\t\t\t\t\t&phba->elsbuf);\n\t\t\t\t\tphba->elsbuf_cnt++;\n\t\t\t\t}\n\t\t\t\tINIT_LIST_HEAD(&buf_ptr->list);\n\t\t\t\tlist_add_tail(&buf_ptr->list, &phba->elsbuf);\n\t\t\t\tphba->elsbuf_cnt++;\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t}\n\t\t} else {\n\t\t\tbuf_ptr1 = elsiocb->cmd_dmabuf;\n\t\t\tlpfc_els_free_data(phba, buf_ptr1);\n\t\t\telsiocb->cmd_dmabuf = NULL;\n\t\t}\n\t}\n\n\tif (elsiocb->bpl_dmabuf) {\n\t\tbuf_ptr = elsiocb->bpl_dmabuf;\n\t\tlpfc_els_free_bpl(phba, buf_ptr);\n\t\telsiocb->bpl_dmabuf = NULL;\n\t}\n\tlpfc_sli_release_iocbq(phba, elsiocb);\n\treturn 0;\n}\n\n \nstatic void\nlpfc_cmpl_els_logo_acc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t       struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tu32 ulp_status, ulp_word4;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\"ACC LOGO cmpl:   status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4, ndlp->nlp_DID);\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0109 ACC to LOGO completes to NPort x%x refcnt %d \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, kref_read(&ndlp->kref), ndlp->nlp_flag,\n\t\t\t ndlp->nlp_state, ndlp->nlp_rpi);\n\n\t \n\tif (ndlp->nlp_type & NLP_FABRIC &&\n\t    ((ndlp->nlp_DID & WELL_KNOWN_DID_MASK) != WELL_KNOWN_DID_MASK))\n\t\tgoto out;\n\n\tif (ndlp->nlp_state == NLP_STE_NPR_NODE) {\n\t\t \n\t\tif ((ndlp->nlp_flag & NLP_DELAY_TMO) &&\n\t\t    (ndlp->nlp_last_elscmd == ELS_CMD_PLOGI))\n\t\t\tgoto out;\n\n\t\tif (ndlp->nlp_flag & NLP_RPI_REGISTERED)\n\t\t\tlpfc_unreg_rpi(vport, ndlp);\n\n\t}\n out:\n\t \n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n \nvoid\nlpfc_mbx_cmpl_dflt_rpi(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_nodelist *ndlp = pmb->ctx_ndlp;\n\tu32 mbx_flag = pmb->mbox_flag;\n\tu32 mbx_cmd = pmb->u.mb.mbxCommand;\n\n\tif (ndlp) {\n\t\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NODE,\n\t\t\t\t \"0006 rpi x%x DID:%x flg:%x %d x%px \"\n\t\t\t\t \"mbx_cmd x%x mbx_flag x%x x%px\\n\",\n\t\t\t\t ndlp->nlp_rpi, ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t\t kref_read(&ndlp->kref), ndlp, mbx_cmd,\n\t\t\t\t mbx_flag, pmb);\n\n\t\t \n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\t\tif (mbx_cmd == MBX_UNREG_LOGIN)\n\t\t\tndlp->nlp_flag &= ~NLP_UNREG_INP;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_drop_node(ndlp->vport, ndlp);\n\t}\n\n\tlpfc_mbox_rsrc_cleanup(phba, pmb, MBOX_THD_UNLOCKED);\n}\n\n \nstatic void\nlpfc_cmpl_els_rsp(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tstruct lpfc_vport *vport = ndlp ? ndlp->vport : NULL;\n\tstruct Scsi_Host  *shost = vport ? lpfc_shost_from_vport(vport) : NULL;\n\tIOCB_t  *irsp;\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tu32 ulp_status, ulp_word4, tmo, did, iotag;\n\n\tif (!vport) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"3177 ELS response failed\\n\");\n\t\tgoto out;\n\t}\n\tif (cmdiocb->context_un.mbox)\n\t\tmbox = cmdiocb->context_un.mbox;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\tdid = get_job_els_rsp64_did(phba, cmdiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\ttmo = get_wqe_tmo(cmdiocb);\n\t\tiotag = get_wqe_reqtag(cmdiocb);\n\t} else {\n\t\tirsp = &rspiocb->iocb;\n\t\ttmo = irsp->ulpTimeout;\n\t\tiotag = irsp->ulpIoTag;\n\t}\n\n\t \n\tif (!ndlp || lpfc_els_chk_latt(vport)) {\n\t\tif (mbox)\n\t\t\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\t\tgoto out;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\"ELS rsp cmpl:    status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4, did);\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0110 ELS response tag x%x completes \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x x%x x%x x%x %p %p\\n\",\n\t\t\t iotag, ulp_status, ulp_word4, tmo,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi, kref_read(&ndlp->kref), mbox, ndlp);\n\tif (mbox) {\n\t\tif (ulp_status == 0\n\t\t    && (ndlp->nlp_flag & NLP_ACC_REGLOGIN)) {\n\t\t\tif (!lpfc_unreg_rpi(vport, ndlp) &&\n\t\t\t    (!(vport->fc_flag & FC_PT2PT))) {\n\t\t\t\tif (ndlp->nlp_state ==  NLP_STE_PLOGI_ISSUE ||\n\t\t\t\t    ndlp->nlp_state ==\n\t\t\t\t     NLP_STE_REG_LOGIN_ISSUE) {\n\t\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t\t\t LOG_DISCOVERY,\n\t\t\t\t\t\t\t \"0314 PLOGI recov \"\n\t\t\t\t\t\t\t \"DID x%x \"\n\t\t\t\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t\t\t\t ndlp->nlp_DID,\n\t\t\t\t\t\t\t ndlp->nlp_state,\n\t\t\t\t\t\t\t ndlp->nlp_rpi,\n\t\t\t\t\t\t\t ndlp->nlp_flag);\n\t\t\t\t\tgoto out_free_mbox;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\t\t\tif (!mbox->ctx_ndlp)\n\t\t\t\tgoto out_free_mbox;\n\n\t\t\tmbox->vport = vport;\n\t\t\tif (ndlp->nlp_flag & NLP_RM_DFLT_RPI) {\n\t\t\t\tmbox->mbox_flag |= LPFC_MBX_IMED_UNREG;\n\t\t\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_dflt_rpi;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmbox->mbox_cmpl = lpfc_mbx_cmpl_reg_login;\n\t\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t   NLP_STE_REG_LOGIN_ISSUE);\n\t\t\t}\n\n\t\t\tndlp->nlp_flag |= NLP_REG_LOGIN_SEND;\n\t\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\n\t\t\t    != MBX_NOT_FINISHED)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tndlp->nlp_flag &= ~NLP_REG_LOGIN_SEND;\n\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0138 ELS rsp: Cannot issue reg_login for x%x \"\n\t\t\t\t\"Data: x%x x%x x%x\\n\",\n\t\t\t\tndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t\tndlp->nlp_rpi);\n\t\t}\nout_free_mbox:\n\t\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\t}\nout:\n\tif (ndlp && shost) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tif (mbox)\n\t\t\tndlp->nlp_flag &= ~NLP_ACC_REGLOGIN;\n\t\tndlp->nlp_flag &= ~NLP_RM_DFLT_RPI;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t}\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    vport && vport->port_type == LPFC_NPIV_PORT &&\n\t    !(ndlp->fc4_xpt_flags & SCSI_XPT_REGD)) {\n\t\tif (ndlp->nlp_flag & NLP_RELEASE_RPI) {\n\t\t\tif (ndlp->nlp_state != NLP_STE_PLOGI_ISSUE &&\n\t\t\t    ndlp->nlp_state != NLP_STE_REG_LOGIN_ISSUE) {\n\t\t\t\tlpfc_sli4_free_rpi(phba, ndlp->nlp_rpi);\n\t\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\t\tndlp->nlp_rpi = LPFC_RPI_ALLOC_ERROR;\n\t\t\t\tndlp->nlp_flag &= ~NLP_RELEASE_RPI;\n\t\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t}\n\t\t\tlpfc_drop_node(vport, ndlp);\n\t\t} else if (ndlp->nlp_state != NLP_STE_PLOGI_ISSUE &&\n\t\t\t   ndlp->nlp_state != NLP_STE_REG_LOGIN_ISSUE &&\n\t\t\t   ndlp->nlp_state != NLP_STE_PRLI_ISSUE) {\n\t\t\t \n\t\t\tlpfc_drop_node(vport, ndlp);\n\t\t}\n\t}\n\n\t \n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\n \nint\nlpfc_els_rsp_acc(struct lpfc_vport *vport, uint32_t flag,\n\t\t struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp,\n\t\t LPFC_MBOXQ_t *mbox)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tIOCB_t *icmd;\n\tIOCB_t *oldcmd;\n\tunion lpfc_wqe128 *wqe;\n\tunion lpfc_wqe128 *oldwqe = &oldiocb->wqe;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tstruct serv_parm *sp;\n\tuint16_t cmdsize;\n\tint rc;\n\tELS_PKT *els_pkt_ptr;\n\tstruct fc_els_rdf_resp *rdf_resp;\n\n\tswitch (flag) {\n\tcase ELS_CMD_ACC:\n\t\tcmdsize = sizeof(uint32_t);\n\t\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\n\t\t\t\t\t     ndlp, ndlp->nlp_DID, ELS_CMD_ACC);\n\t\tif (!elsiocb) {\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_LOGO_ACC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\twqe = &elsiocb->wqe;\n\t\t\t \n\t\t\tbf_set(wqe_ctxt_tag, &wqe->xmit_els_rsp.wqe_com,\n\t\t\t       bf_get(wqe_ctxt_tag,\n\t\t\t\t      &oldwqe->xmit_els_rsp.wqe_com));\n\n\t\t\t \n\t\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t\t       bf_get(wqe_rcvoxid,\n\t\t\t\t      &oldwqe->xmit_els_rsp.wqe_com));\n\t\t} else {\n\t\t\ticmd = &elsiocb->iocb;\n\t\t\toldcmd = &oldiocb->iocb;\n\t\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\t\toldcmd->unsli3.rcvsli3.ox_id;\n\t\t}\n\n\t\tpcmd = elsiocb->cmd_dmabuf->virt;\n\t\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\t\tpcmd += sizeof(uint32_t);\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\t\"Issue ACC:       did:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag, 0);\n\t\tbreak;\n\tcase ELS_CMD_FLOGI:\n\tcase ELS_CMD_PLOGI:\n\t\tcmdsize = (sizeof(struct serv_parm) + sizeof(uint32_t));\n\t\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\n\t\t\t\t\t     ndlp, ndlp->nlp_DID, ELS_CMD_ACC);\n\t\tif (!elsiocb)\n\t\t\treturn 1;\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\twqe = &elsiocb->wqe;\n\t\t\t \n\t\t\tbf_set(wqe_ctxt_tag, &wqe->xmit_els_rsp.wqe_com,\n\t\t\t       bf_get(wqe_ctxt_tag,\n\t\t\t\t      &oldwqe->xmit_els_rsp.wqe_com));\n\n\t\t\t \n\t\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t\t       bf_get(wqe_rcvoxid,\n\t\t\t\t      &oldwqe->xmit_els_rsp.wqe_com));\n\t\t} else {\n\t\t\ticmd = &elsiocb->iocb;\n\t\t\toldcmd = &oldiocb->iocb;\n\t\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\t\toldcmd->unsli3.rcvsli3.ox_id;\n\t\t}\n\n\t\tpcmd = (u8 *)elsiocb->cmd_dmabuf->virt;\n\n\t\tif (mbox)\n\t\t\telsiocb->context_un.mbox = mbox;\n\n\t\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\t\tpcmd += sizeof(uint32_t);\n\t\tsp = (struct serv_parm *)pcmd;\n\n\t\tif (flag == ELS_CMD_FLOGI) {\n\t\t\t \n\t\t\tmemcpy(sp, &phba->fc_fabparam,\n\t\t\t       sizeof(struct serv_parm));\n\n\t\t\t \n\t\t\tsp->cmn.fPort = 0;\n\n\t\t\t \n\t\t\tsp->cls1.classValid = 0;\n\t\t\tsp->cls2.classValid = 0;\n\t\t\tsp->cls3.classValid = 0;\n\t\t\tsp->cls4.classValid = 0;\n\n\t\t\t \n\t\t\tmemcpy(&sp->portName, &vport->fc_sparam.portName,\n\t\t\t       sizeof(struct lpfc_name));\n\t\t\tmemcpy(&sp->nodeName, &vport->fc_sparam.nodeName,\n\t\t\t       sizeof(struct lpfc_name));\n\t\t} else {\n\t\t\tmemcpy(pcmd, &vport->fc_sparam,\n\t\t\t       sizeof(struct serv_parm));\n\n\t\t\tsp->cmn.valid_vendor_ver_level = 0;\n\t\t\tmemset(sp->un.vendorVersion, 0,\n\t\t\t       sizeof(sp->un.vendorVersion));\n\t\t\tsp->cmn.bbRcvSizeMsb &= 0xF;\n\n\t\t\t \n\t\t\tif (phba->sli.sli_flag & LPFC_SLI_SUPPRESS_RSP) {\n\t\t\t\tsp->cmn.valid_vendor_ver_level = 1;\n\t\t\t\tsp->un.vv.vid = cpu_to_be32(LPFC_VV_EMLX_ID);\n\t\t\t\tsp->un.vv.flags =\n\t\t\t\t\tcpu_to_be32(LPFC_VV_SUPPRESS_RSP);\n\t\t\t}\n\t\t}\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\t\"Issue ACC FLOGI/PLOGI: did:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag, 0);\n\t\tbreak;\n\tcase ELS_CMD_PRLO:\n\t\tcmdsize = sizeof(uint32_t) + sizeof(PRLO);\n\t\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\n\t\t\t\t\t     ndlp, ndlp->nlp_DID, ELS_CMD_PRLO);\n\t\tif (!elsiocb)\n\t\t\treturn 1;\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\twqe = &elsiocb->wqe;\n\t\t\t \n\t\t\tbf_set(wqe_ctxt_tag, &wqe->xmit_els_rsp.wqe_com,\n\t\t\t       bf_get(wqe_ctxt_tag,\n\t\t\t\t      &oldwqe->xmit_els_rsp.wqe_com));\n\n\t\t\t \n\t\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t\t       bf_get(wqe_rcvoxid,\n\t\t\t\t      &oldwqe->xmit_els_rsp.wqe_com));\n\t\t} else {\n\t\t\ticmd = &elsiocb->iocb;\n\t\t\toldcmd = &oldiocb->iocb;\n\t\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\t\toldcmd->unsli3.rcvsli3.ox_id;\n\t\t}\n\n\t\tpcmd = (u8 *) elsiocb->cmd_dmabuf->virt;\n\n\t\tmemcpy(pcmd, oldiocb->cmd_dmabuf->virt,\n\t\t       sizeof(uint32_t) + sizeof(PRLO));\n\t\t*((uint32_t *) (pcmd)) = ELS_CMD_PRLO_ACC;\n\t\tels_pkt_ptr = (ELS_PKT *) pcmd;\n\t\tels_pkt_ptr->un.prlo.acceptRspCode = PRLO_REQ_EXECUTED;\n\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\t\"Issue ACC PRLO:  did:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag, 0);\n\t\tbreak;\n\tcase ELS_CMD_RDF:\n\t\tcmdsize = sizeof(*rdf_resp);\n\t\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry,\n\t\t\t\t\t     ndlp, ndlp->nlp_DID, ELS_CMD_ACC);\n\t\tif (!elsiocb)\n\t\t\treturn 1;\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\twqe = &elsiocb->wqe;\n\t\t\t \n\t\t\tbf_set(wqe_ctxt_tag, &wqe->xmit_els_rsp.wqe_com,\n\t\t\t       bf_get(wqe_ctxt_tag,\n\t\t\t\t      &oldwqe->xmit_els_rsp.wqe_com));\n\n\t\t\t \n\t\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t\t       bf_get(wqe_rcvoxid,\n\t\t\t\t      &oldwqe->xmit_els_rsp.wqe_com));\n\t\t} else {\n\t\t\ticmd = &elsiocb->iocb;\n\t\t\toldcmd = &oldiocb->iocb;\n\t\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\t\toldcmd->unsli3.rcvsli3.ox_id;\n\t\t}\n\n\t\tpcmd = (u8 *)elsiocb->cmd_dmabuf->virt;\n\t\trdf_resp = (struct fc_els_rdf_resp *)pcmd;\n\t\tmemset(rdf_resp, 0, sizeof(*rdf_resp));\n\t\trdf_resp->acc_hdr.la_cmd = ELS_LS_ACC;\n\n\t\t \n\t\trdf_resp->desc_list_len = cpu_to_be32(12);\n\n\t\t \n\t\trdf_resp->lsri.desc_tag = cpu_to_be32(1);\n\t\trdf_resp->lsri.desc_len = cpu_to_be32(sizeof(u32));\n\t\trdf_resp->lsri.rqst_w0.cmd = ELS_RDF;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\tif (ndlp->nlp_flag & NLP_LOGO_ACC) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tif (!(ndlp->nlp_flag & NLP_RPI_REGISTERED ||\n\t\t\tndlp->nlp_flag & NLP_REG_LOGIN_SEND))\n\t\t\tndlp->nlp_flag &= ~NLP_LOGO_ACC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\telsiocb->cmd_cmpl = lpfc_cmpl_els_logo_acc;\n\t} else {\n\t\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\t}\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0128 Xmit ELS ACC response Status: x%x, IoTag: x%x, \"\n\t\t\t \"XRI: x%x, DID: x%x, nlp_flag: x%x nlp_state: x%x \"\n\t\t\t \"RPI: x%x, fc_flag x%x refcnt %d\\n\",\n\t\t\t rc, elsiocb->iotag, elsiocb->sli4_xritag,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi, vport->fc_flag, kref_read(&ndlp->kref));\n\treturn 0;\n}\n\n \nint\nlpfc_els_rsp_reject(struct lpfc_vport *vport, uint32_t rejectError,\n\t\t    struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp,\n\t\t    LPFC_MBOXQ_t *mbox)\n{\n\tint rc;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tIOCB_t *icmd;\n\tIOCB_t *oldcmd;\n\tunion lpfc_wqe128 *wqe;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\n\tcmdsize = 2 * sizeof(uint32_t);\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_LS_RJT);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t\t       get_job_ulpcontext(phba, oldiocb));  \n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       get_job_rcvoxid(phba, oldiocb));\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\toldcmd = &oldiocb->iocb;\n\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\ticmd->unsli3.rcvsli3.ox_id = oldcmd->unsli3.rcvsli3.ox_id;\n\t}\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_LS_RJT;\n\tpcmd += sizeof(uint32_t);\n\t*((uint32_t *) (pcmd)) = rejectError;\n\n\tif (mbox)\n\t\telsiocb->context_un.mbox = mbox;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0129 Xmit ELS RJT x%x response tag x%x \"\n\t\t\t \"xri x%x, did x%x, nlp_flag x%x, nlp_state x%x, \"\n\t\t\t \"rpi x%x\\n\",\n\t\t\t rejectError, elsiocb->iotag,\n\t\t\t get_job_ulpcontext(phba, elsiocb), ndlp->nlp_DID,\n\t\t\t ndlp->nlp_flag, ndlp->nlp_state, ndlp->nlp_rpi);\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\"Issue LS_RJT:    did:x%x flg:x%x err:x%x\",\n\t\tndlp->nlp_DID, ndlp->nlp_flag, rejectError);\n\n\tphba->fc_stat.elsXmitLSRJT++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    vport->port_type == LPFC_NPIV_PORT &&\n\t    !(ndlp->fc4_xpt_flags & SCSI_XPT_REGD)) {\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag |= NLP_RELEASE_RPI;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n  \nstatic int\nlpfc_issue_els_edc_rsp(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t       struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct fc_els_edc_resp *edc_rsp;\n\tstruct fc_tlv_desc *tlv;\n\tstruct lpfc_iocbq *elsiocb;\n\tIOCB_t *icmd, *cmd;\n\tunion lpfc_wqe128 *wqe;\n\tu32 cgn_desc_size, lft_desc_size;\n\tu16 cmdsize;\n\tuint8_t *pcmd;\n\tint rc;\n\n\tcmdsize = sizeof(struct fc_els_edc_resp);\n\tcgn_desc_size = sizeof(struct fc_diag_cg_sig_desc);\n\tlft_desc_size = (lpfc_link_is_lds_capable(phba)) ?\n\t\t\t\tsizeof(struct fc_diag_lnkflt_desc) : 0;\n\tcmdsize += cgn_desc_size + lft_desc_size;\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, cmdiocb->retry,\n\t\t\t\t     ndlp, ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t\t       get_job_ulpcontext(phba, cmdiocb));  \n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       get_job_rcvoxid(phba, cmdiocb));\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\tcmd = &cmdiocb->iocb;\n\t\ticmd->ulpContext = cmd->ulpContext;  \n\t\ticmd->unsli3.rcvsli3.ox_id = cmd->unsli3.rcvsli3.ox_id;\n\t}\n\n\tpcmd = elsiocb->cmd_dmabuf->virt;\n\tmemset(pcmd, 0, cmdsize);\n\n\tedc_rsp = (struct fc_els_edc_resp *)pcmd;\n\tedc_rsp->acc_hdr.la_cmd = ELS_LS_ACC;\n\tedc_rsp->desc_list_len = cpu_to_be32(sizeof(struct fc_els_lsri_desc) +\n\t\t\t\t\t\tcgn_desc_size + lft_desc_size);\n\tedc_rsp->lsri.desc_tag = cpu_to_be32(ELS_DTAG_LS_REQ_INFO);\n\tedc_rsp->lsri.desc_len = cpu_to_be32(\n\t\tFC_TLV_DESC_LENGTH_FROM_SZ(struct fc_els_lsri_desc));\n\tedc_rsp->lsri.rqst_w0.cmd = ELS_EDC;\n\ttlv = edc_rsp->desc;\n\tlpfc_format_edc_cgn_desc(phba, tlv);\n\ttlv = fc_tlv_next_desc(tlv);\n\tif (lft_desc_size)\n\t\tlpfc_format_edc_lft_desc(phba, tlv);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\t      \"Issue EDC ACC:      did:x%x flg:x%x refcnt %d\",\n\t\t\t      ndlp->nlp_DID, ndlp->nlp_flag,\n\t\t\t      kref_read(&ndlp->kref));\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0152 Xmit EDC ACC response Status: x%x, IoTag: x%x, \"\n\t\t\t \"XRI: x%x, DID: x%x, nlp_flag: x%x nlp_state: x%x \"\n\t\t\t \"RPI: x%x, fc_flag x%x\\n\",\n\t\t\t rc, elsiocb->iotag, elsiocb->sli4_xritag,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi, vport->fc_flag);\n\n\treturn 0;\n}\n\n \nint\nlpfc_els_rsp_adisc_acc(struct lpfc_vport *vport, struct lpfc_iocbq *oldiocb,\n\t\t       struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tADISC *ap;\n\tIOCB_t *icmd, *oldcmd;\n\tunion lpfc_wqe128 *wqe;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint rc;\n\tu32 ulp_context;\n\n\tcmdsize = sizeof(uint32_t) + sizeof(ADISC);\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\t \n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t\t       get_job_ulpcontext(phba, oldiocb));\n\t\tulp_context = get_job_ulpcontext(phba, elsiocb);\n\t\t \n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       get_job_rcvoxid(phba, oldiocb));\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\toldcmd = &oldiocb->iocb;\n\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\tulp_context = elsiocb->iocb.ulpContext;\n\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\toldcmd->unsli3.rcvsli3.ox_id;\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0130 Xmit ADISC ACC response iotag x%x xri: \"\n\t\t\t \"x%x, did x%x, nlp_flag x%x, nlp_state x%x rpi x%x\\n\",\n\t\t\t elsiocb->iotag, ulp_context,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t);\n\n\tap = (ADISC *) (pcmd);\n\tap->hardAL_PA = phba->fc_pref_ALPA;\n\tmemcpy(&ap->portName, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(&ap->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\n\tap->DID = be32_to_cpu(vport->fc_myDID);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t      \"Issue ACC ADISC: did:x%x flg:x%x refcnt %d\",\n\t\t      ndlp->nlp_DID, ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nint\nlpfc_els_rsp_prli_acc(struct lpfc_vport *vport, struct lpfc_iocbq *oldiocb,\n\t\t      struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tPRLI *npr;\n\tstruct lpfc_nvme_prli *npr_nvme;\n\tlpfc_vpd_t *vpd;\n\tIOCB_t *icmd;\n\tIOCB_t *oldcmd;\n\tunion lpfc_wqe128 *wqe;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tuint32_t prli_fc4_req, *req_payload;\n\tstruct lpfc_dmabuf *req_buf;\n\tint rc;\n\tu32 elsrspcmd, ulp_context;\n\n\t \n\treq_buf = oldiocb->cmd_dmabuf;\n\treq_payload = (((uint32_t *)req_buf->virt) + 1);\n\n\t \n\tprli_fc4_req = be32_to_cpu(*req_payload);\n\tprli_fc4_req = (prli_fc4_req >> 24) & 0xff;\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"6127 PRLI_ACC:  Req Type x%x, Word1 x%08x\\n\",\n\t\t\t prli_fc4_req, *((uint32_t *)req_payload));\n\n\tif (prli_fc4_req == PRLI_FCP_TYPE) {\n\t\tcmdsize = sizeof(uint32_t) + sizeof(PRLI);\n\t\telsrspcmd = (ELS_CMD_ACC | (ELS_CMD_PRLI & ~ELS_RSP_MASK));\n\t} else if (prli_fc4_req == PRLI_NVME_TYPE) {\n\t\tcmdsize = sizeof(uint32_t) + sizeof(struct lpfc_nvme_prli);\n\t\telsrspcmd = (ELS_CMD_ACC | (ELS_CMD_NVMEPRLI & ~ELS_RSP_MASK));\n\t} else {\n\t\treturn 1;\n\t}\n\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, elsrspcmd);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t\t       get_job_ulpcontext(phba, oldiocb));  \n\t\tulp_context = get_job_ulpcontext(phba, elsiocb);\n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       get_job_rcvoxid(phba, oldiocb));\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\toldcmd = &oldiocb->iocb;\n\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\tulp_context = elsiocb->iocb.ulpContext;\n\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\toldcmd->unsli3.rcvsli3.ox_id;\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0131 Xmit PRLI ACC response tag x%x xri x%x, \"\n\t\t\t \"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\\n\",\n\t\t\t elsiocb->iotag, ulp_context,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\tmemset(pcmd, 0, cmdsize);\n\n\t*((uint32_t *)(pcmd)) = elsrspcmd;\n\tpcmd += sizeof(uint32_t);\n\n\t \n\tvpd = &phba->vpd;\n\n\tif (prli_fc4_req == PRLI_FCP_TYPE) {\n\t\t \n\t\tnpr = (PRLI *) pcmd;\n\t\tif ((ndlp->nlp_type & NLP_FCP_TARGET) &&\n\t\t    (vpd->rev.feaLevelHigh >= 0x02)) {\n\t\t\tnpr->ConfmComplAllowed = 1;\n\t\t\tnpr->Retry = 1;\n\t\t\tnpr->TaskRetryIdReq = 1;\n\t\t}\n\t\tnpr->acceptRspCode = PRLI_REQ_EXECUTED;\n\n\t\t \n\t\tif (ndlp->nlp_type & NLP_FCP_TARGET)\n\t\t\tnpr->estabImagePair = 1;\n\t\telse\n\t\t\tnpr->estabImagePair = 0;\n\t\tnpr->readXferRdyDis = 1;\n\t\tnpr->ConfmComplAllowed = 1;\n\t\tnpr->prliType = PRLI_FCP_TYPE;\n\t\tnpr->initiatorFunc = 1;\n\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t LOG_ELS | LOG_NODE | LOG_DISCOVERY,\n\t\t\t\t \"6014 FCP issue PRLI ACC imgpair %d \"\n\t\t\t\t \"retry %d task %d\\n\",\n\t\t\t\t npr->estabImagePair,\n\t\t\t\t npr->Retry, npr->TaskRetryIdReq);\n\n\t} else if (prli_fc4_req == PRLI_NVME_TYPE) {\n\t\t \n\t\tnpr_nvme = (struct lpfc_nvme_prli *) pcmd;\n\t\tbf_set(prli_type_code, npr_nvme, PRLI_NVME_TYPE);\n\t\tbf_set(prli_estabImagePair, npr_nvme, 0);   \n\t\tbf_set(prli_acc_rsp_code, npr_nvme, PRLI_REQ_EXECUTED);\n\t\tif (phba->nvmet_support) {\n\t\t\tbf_set(prli_tgt, npr_nvme, 1);\n\t\t\tbf_set(prli_disc, npr_nvme, 1);\n\t\t\tif (phba->cfg_nvme_enable_fb) {\n\t\t\t\tbf_set(prli_fba, npr_nvme, 1);\n\n\t\t\t\t \n\t\t\t\tbf_set(prli_fb_sz, npr_nvme,\n\t\t\t\t       phba->cfg_nvmet_fb_size);\n\t\t\t}\n\t\t} else {\n\t\t\tbf_set(prli_init, npr_nvme, 1);\n\t\t}\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t\t \"6015 NVME issue PRLI ACC word1 x%08x \"\n\t\t\t\t \"word4 x%08x word5 x%08x flag x%x, \"\n\t\t\t\t \"fcp_info x%x nlp_type x%x\\n\",\n\t\t\t\t npr_nvme->word1, npr_nvme->word4,\n\t\t\t\t npr_nvme->word5, ndlp->nlp_flag,\n\t\t\t\t ndlp->nlp_fcp_info, ndlp->nlp_type);\n\t\tnpr_nvme->word1 = cpu_to_be32(npr_nvme->word1);\n\t\tnpr_nvme->word4 = cpu_to_be32(npr_nvme->word4);\n\t\tnpr_nvme->word5 = cpu_to_be32(npr_nvme->word5);\n\t} else\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"6128 Unknown FC_TYPE x%x x%x ndlp x%06x\\n\",\n\t\t\t\t prli_fc4_req, ndlp->nlp_fc4_type,\n\t\t\t\t ndlp->nlp_DID);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t      \"Issue ACC PRLI:  did:x%x flg:x%x\",\n\t\t      ndlp->nlp_DID, ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->ndlp =  lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rsp_rnid_acc(struct lpfc_vport *vport, uint8_t format,\n\t\t      struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tRNID *rn;\n\tIOCB_t *icmd, *oldcmd;\n\tunion lpfc_wqe128 *wqe;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint rc;\n\tu32 ulp_context;\n\n\tcmdsize = sizeof(uint32_t) + sizeof(uint32_t)\n\t\t\t\t\t+ (2 * sizeof(struct lpfc_name));\n\tif (format)\n\t\tcmdsize += sizeof(RNID_TOP_DISC);\n\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t\t       get_job_ulpcontext(phba, oldiocb));  \n\t\tulp_context = get_job_ulpcontext(phba, elsiocb);\n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       get_job_rcvoxid(phba, oldiocb));\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\toldcmd = &oldiocb->iocb;\n\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\tulp_context = elsiocb->iocb.ulpContext;\n\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\toldcmd->unsli3.rcvsli3.ox_id;\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0132 Xmit RNID ACC response tag x%x xri x%x\\n\",\n\t\t\t elsiocb->iotag, ulp_context);\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t);\n\n\tmemset(pcmd, 0, sizeof(RNID));\n\trn = (RNID *) (pcmd);\n\trn->Format = format;\n\trn->CommonLen = (2 * sizeof(struct lpfc_name));\n\tmemcpy(&rn->portName, &vport->fc_portname, sizeof(struct lpfc_name));\n\tmemcpy(&rn->nodeName, &vport->fc_nodename, sizeof(struct lpfc_name));\n\tswitch (format) {\n\tcase 0:\n\t\trn->SpecificLen = 0;\n\t\tbreak;\n\tcase RNID_TOPOLOGY_DISC:\n\t\trn->SpecificLen = sizeof(RNID_TOP_DISC);\n\t\tmemcpy(&rn->un.topologyDisc.portName,\n\t\t       &vport->fc_portname, sizeof(struct lpfc_name));\n\t\trn->un.topologyDisc.unitType = RNID_HBA;\n\t\trn->un.topologyDisc.physPort = 0;\n\t\trn->un.topologyDisc.attachedNodes = 0;\n\t\tbreak;\n\tdefault:\n\t\trn->CommonLen = 0;\n\t\trn->SpecificLen = 0;\n\t\tbreak;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t      \"Issue ACC RNID:  did:x%x flg:x%x refcnt %d\",\n\t\t      ndlp->nlp_DID, ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nlpfc_els_clear_rrq(struct lpfc_vport *vport,\n\t\t   struct lpfc_iocbq *iocb, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tuint8_t *pcmd;\n\tstruct RRQ *rrq;\n\tuint16_t rxid;\n\tuint16_t xri;\n\tstruct lpfc_node_rrq *prrq;\n\n\n\tpcmd = (uint8_t *)iocb->cmd_dmabuf->virt;\n\tpcmd += sizeof(uint32_t);\n\trrq = (struct RRQ *)pcmd;\n\trrq->rrq_exchg = be32_to_cpu(rrq->rrq_exchg);\n\trxid = bf_get(rrq_rxid, rrq);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\"2883 Clear RRQ for SID:x%x OXID:x%x RXID:x%x\"\n\t\t\t\" x%x x%x\\n\",\n\t\t\tbe32_to_cpu(bf_get(rrq_did, rrq)),\n\t\t\tbf_get(rrq_oxid, rrq),\n\t\t\trxid,\n\t\t\tget_wqe_reqtag(iocb),\n\t\t\tget_job_ulpcontext(phba, iocb));\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t\"Clear RRQ:  did:x%x flg:x%x exchg:x%.08x\",\n\t\tndlp->nlp_DID, ndlp->nlp_flag, rrq->rrq_exchg);\n\tif (vport->fc_myDID == be32_to_cpu(bf_get(rrq_did, rrq)))\n\t\txri = bf_get(rrq_oxid, rrq);\n\telse\n\t\txri = rxid;\n\tprrq = lpfc_get_active_rrq(vport, xri, ndlp->nlp_DID);\n\tif (prrq)\n\t\tlpfc_clr_rrq_active(phba, xri, prrq);\n\treturn;\n}\n\n \nstatic int\nlpfc_els_rsp_echo_acc(struct lpfc_vport *vport, uint8_t *data,\n\t\t      struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tIOCB_t *icmd, *oldcmd;\n\tunion lpfc_wqe128 *wqe;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint rc;\n\tu32 ulp_context;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tcmdsize = oldiocb->wcqe_cmpl.total_data_placed;\n\telse\n\t\tcmdsize = oldiocb->iocb.unsli3.rcvsli3.acc_len;\n\n\t \n\tif (cmdsize > LPFC_BPL_SIZE)\n\t\tcmdsize = LPFC_BPL_SIZE;\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t\t       get_job_ulpcontext(phba, oldiocb));  \n\t\tulp_context = get_job_ulpcontext(phba, elsiocb);\n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       get_job_rcvoxid(phba, oldiocb));\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\toldcmd = &oldiocb->iocb;\n\t\ticmd->ulpContext = oldcmd->ulpContext;  \n\t\tulp_context = elsiocb->iocb.ulpContext;\n\t\ticmd->unsli3.rcvsli3.ox_id =\n\t\t\toldcmd->unsli3.rcvsli3.ox_id;\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2876 Xmit ECHO ACC response tag x%x xri x%x\\n\",\n\t\t\t elsiocb->iotag, ulp_context);\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, data, cmdsize - sizeof(uint32_t));\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_RSP,\n\t\t      \"Issue ACC ECHO:  did:x%x flg:x%x refcnt %d\",\n\t\t      ndlp->nlp_DID, ndlp->nlp_flag, kref_read(&ndlp->kref));\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->ndlp =  lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nint\nlpfc_els_disc_adisc(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\tint sentadisc = 0;\n\n\t \n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\n\n\t\tif (ndlp->nlp_state != NLP_STE_NPR_NODE ||\n\t\t    !(ndlp->nlp_flag & NLP_NPR_ADISC))\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\tif (!(ndlp->nlp_flag & NLP_NPR_2B_DISC)) {\n\t\t\t \n\t\t\tlpfc_nlp_unreg_node(vport, ndlp);\n\t\t\tlpfc_unreg_rpi(vport, ndlp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_ADISC_ISSUE);\n\t\tlpfc_issue_els_adisc(vport, ndlp, 0);\n\t\tsentadisc++;\n\t\tvport->num_disc_nodes++;\n\t\tif (vport->num_disc_nodes >=\n\t\t\t\tvport->cfg_discovery_threads) {\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag |= FC_NLP_MORE;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\tif (sentadisc == 0) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_NLP_MORE;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\treturn sentadisc;\n}\n\n \nint\nlpfc_els_disc_plogi(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\tint sentplogi = 0;\n\n\t \n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_state == NLP_STE_NPR_NODE &&\n\t\t\t\t(ndlp->nlp_flag & NLP_NPR_2B_DISC) != 0 &&\n\t\t\t\t(ndlp->nlp_flag & NLP_DELAY_TMO) == 0 &&\n\t\t\t\t(ndlp->nlp_flag & NLP_NPR_ADISC) == 0) {\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\t\t\tsentplogi++;\n\t\t\tvport->num_disc_nodes++;\n\t\t\tif (vport->num_disc_nodes >=\n\t\t\t\t\tvport->cfg_discovery_threads) {\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag |= FC_NLP_MORE;\n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"6452 Discover PLOGI %d flag x%x\\n\",\n\t\t\t sentplogi, vport->fc_flag);\n\n\tif (sentplogi) {\n\t\tlpfc_set_disctmo(vport);\n\t}\n\telse {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_NLP_MORE;\n\t\tspin_unlock_irq(shost->host_lock);\n\t}\n\treturn sentplogi;\n}\n\nstatic uint32_t\nlpfc_rdp_res_link_service(struct fc_rdp_link_service_desc *desc,\n\t\tuint32_t word0)\n{\n\n\tdesc->tag = cpu_to_be32(RDP_LINK_SERVICE_DESC_TAG);\n\tdesc->payload.els_req = word0;\n\tdesc->length = cpu_to_be32(sizeof(desc->payload));\n\n\treturn sizeof(struct fc_rdp_link_service_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_sfp_desc(struct fc_rdp_sfp_desc *desc,\n\t\tuint8_t *page_a0, uint8_t *page_a2)\n{\n\tuint16_t wavelength;\n\tuint16_t temperature;\n\tuint16_t rx_power;\n\tuint16_t tx_bias;\n\tuint16_t tx_power;\n\tuint16_t vcc;\n\tuint16_t flag = 0;\n\tstruct sff_trasnceiver_codes_byte4 *trasn_code_byte4;\n\tstruct sff_trasnceiver_codes_byte5 *trasn_code_byte5;\n\n\tdesc->tag = cpu_to_be32(RDP_SFP_DESC_TAG);\n\n\ttrasn_code_byte4 = (struct sff_trasnceiver_codes_byte4 *)\n\t\t\t&page_a0[SSF_TRANSCEIVER_CODE_B4];\n\ttrasn_code_byte5 = (struct sff_trasnceiver_codes_byte5 *)\n\t\t\t&page_a0[SSF_TRANSCEIVER_CODE_B5];\n\n\tif ((trasn_code_byte4->fc_sw_laser) ||\n\t    (trasn_code_byte5->fc_sw_laser_sl) ||\n\t    (trasn_code_byte5->fc_sw_laser_sn)) {   \n\t\tflag |= (SFP_FLAG_PT_SWLASER << SFP_FLAG_PT_SHIFT);\n\t} else if (trasn_code_byte4->fc_lw_laser) {\n\t\twavelength = (page_a0[SSF_WAVELENGTH_B1] << 8) |\n\t\t\tpage_a0[SSF_WAVELENGTH_B0];\n\t\tif (wavelength == SFP_WAVELENGTH_LC1310)\n\t\t\tflag |= SFP_FLAG_PT_LWLASER_LC1310 << SFP_FLAG_PT_SHIFT;\n\t\tif (wavelength == SFP_WAVELENGTH_LL1550)\n\t\t\tflag |= SFP_FLAG_PT_LWLASER_LL1550 << SFP_FLAG_PT_SHIFT;\n\t}\n\t \n\tflag |= ((page_a0[SSF_IDENTIFIER] == SFF_PG0_IDENT_SFP) ?\n\t\t\tSFP_FLAG_CT_SFP_PLUS : SFP_FLAG_CT_UNKNOWN)\n\t\t\t\t\t<< SFP_FLAG_CT_SHIFT;\n\n\t \n\tflag |= ((page_a0[SSF_CONNECTOR] == SFF_PG0_CONNECTOR_LC) ?\n\t\t\tSFP_FLAG_IS_OPTICAL_PORT : 0)\n\t\t\t\t\t<< SFP_FLAG_IS_OPTICAL_SHIFT;\n\n\ttemperature = (page_a2[SFF_TEMPERATURE_B1] << 8 |\n\t\tpage_a2[SFF_TEMPERATURE_B0]);\n\tvcc = (page_a2[SFF_VCC_B1] << 8 |\n\t\tpage_a2[SFF_VCC_B0]);\n\ttx_power = (page_a2[SFF_TXPOWER_B1] << 8 |\n\t\tpage_a2[SFF_TXPOWER_B0]);\n\ttx_bias = (page_a2[SFF_TX_BIAS_CURRENT_B1] << 8 |\n\t\tpage_a2[SFF_TX_BIAS_CURRENT_B0]);\n\trx_power = (page_a2[SFF_RXPOWER_B1] << 8 |\n\t\tpage_a2[SFF_RXPOWER_B0]);\n\tdesc->sfp_info.temperature = cpu_to_be16(temperature);\n\tdesc->sfp_info.rx_power = cpu_to_be16(rx_power);\n\tdesc->sfp_info.tx_bias = cpu_to_be16(tx_bias);\n\tdesc->sfp_info.tx_power = cpu_to_be16(tx_power);\n\tdesc->sfp_info.vcc = cpu_to_be16(vcc);\n\n\tdesc->sfp_info.flags = cpu_to_be16(flag);\n\tdesc->length = cpu_to_be32(sizeof(desc->sfp_info));\n\n\treturn sizeof(struct fc_rdp_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_link_error(struct fc_rdp_link_error_status_desc *desc,\n\t\tREAD_LNK_VAR *stat)\n{\n\tuint32_t type;\n\n\tdesc->tag = cpu_to_be32(RDP_LINK_ERROR_STATUS_DESC_TAG);\n\n\ttype = VN_PT_PHY_PF_PORT << VN_PT_PHY_SHIFT;\n\n\tdesc->info.port_type = cpu_to_be32(type);\n\n\tdesc->info.link_status.link_failure_cnt =\n\t\tcpu_to_be32(stat->linkFailureCnt);\n\tdesc->info.link_status.loss_of_synch_cnt =\n\t\tcpu_to_be32(stat->lossSyncCnt);\n\tdesc->info.link_status.loss_of_signal_cnt =\n\t\tcpu_to_be32(stat->lossSignalCnt);\n\tdesc->info.link_status.primitive_seq_proto_err =\n\t\tcpu_to_be32(stat->primSeqErrCnt);\n\tdesc->info.link_status.invalid_trans_word =\n\t\tcpu_to_be32(stat->invalidXmitWord);\n\tdesc->info.link_status.invalid_crc_cnt = cpu_to_be32(stat->crcCnt);\n\n\tdesc->length = cpu_to_be32(sizeof(desc->info));\n\n\treturn sizeof(struct fc_rdp_link_error_status_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_bbc_desc(struct fc_rdp_bbc_desc *desc, READ_LNK_VAR *stat,\n\t\t      struct lpfc_vport *vport)\n{\n\tuint32_t bbCredit;\n\n\tdesc->tag = cpu_to_be32(RDP_BBC_DESC_TAG);\n\n\tbbCredit = vport->fc_sparam.cmn.bbCreditLsb |\n\t\t\t(vport->fc_sparam.cmn.bbCreditMsb << 8);\n\tdesc->bbc_info.port_bbc = cpu_to_be32(bbCredit);\n\tif (vport->phba->fc_topology != LPFC_TOPOLOGY_LOOP) {\n\t\tbbCredit = vport->phba->fc_fabparam.cmn.bbCreditLsb |\n\t\t\t(vport->phba->fc_fabparam.cmn.bbCreditMsb << 8);\n\t\tdesc->bbc_info.attached_port_bbc = cpu_to_be32(bbCredit);\n\t} else {\n\t\tdesc->bbc_info.attached_port_bbc = 0;\n\t}\n\n\tdesc->bbc_info.rtt = 0;\n\tdesc->length = cpu_to_be32(sizeof(desc->bbc_info));\n\n\treturn sizeof(struct fc_rdp_bbc_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_oed_temp_desc(struct lpfc_hba *phba,\n\t\t\t   struct fc_rdp_oed_sfp_desc *desc, uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_TEMP_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_TEMP_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_TEMP_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_TEMP_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_TEMPERATURE)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_TEMPERATURE)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_TEMPERATURE)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_TEMPERATURE)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_TEMPERATURE) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_oed_voltage_desc(struct lpfc_hba *phba,\n\t\t\t      struct fc_rdp_oed_sfp_desc *desc,\n\t\t\t      uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_VOLTAGE_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_VOLTAGE_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_VOLTAGE_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_VOLTAGE_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_VOLTAGE)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_VOLTAGE)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_VOLTAGE)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_VOLTAGE)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_VOLTAGE) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_oed_txbias_desc(struct lpfc_hba *phba,\n\t\t\t     struct fc_rdp_oed_sfp_desc *desc,\n\t\t\t     uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_BIAS_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_BIAS_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_BIAS_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_BIAS_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_TXBIAS)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_TXBIAS)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_TXBIAS)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_TXBIAS)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_TXBIAS) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_oed_txpower_desc(struct lpfc_hba *phba,\n\t\t\t      struct fc_rdp_oed_sfp_desc *desc,\n\t\t\t      uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_TXPOWER_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_TXPOWER_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_TXPOWER_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_TXPOWER_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_TXPOWER)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_TXPOWER)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_TXPOWER)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_TXPOWER)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_TXPOWER) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\n\nstatic uint32_t\nlpfc_rdp_res_oed_rxpower_desc(struct lpfc_hba *phba,\n\t\t\t      struct fc_rdp_oed_sfp_desc *desc,\n\t\t\t      uint8_t *page_a2)\n{\n\tuint32_t flags = 0;\n\n\tdesc->tag = cpu_to_be32(RDP_OED_DESC_TAG);\n\n\tdesc->oed_info.hi_alarm = page_a2[SSF_RXPOWER_HIGH_ALARM];\n\tdesc->oed_info.lo_alarm = page_a2[SSF_RXPOWER_LOW_ALARM];\n\tdesc->oed_info.hi_warning = page_a2[SSF_RXPOWER_HIGH_WARNING];\n\tdesc->oed_info.lo_warning = page_a2[SSF_RXPOWER_LOW_WARNING];\n\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_HIGH_RXPOWER)\n\t\tflags |= RDP_OET_HIGH_ALARM;\n\tif (phba->sfp_alarm & LPFC_TRANSGRESSION_LOW_RXPOWER)\n\t\tflags |= RDP_OET_LOW_ALARM;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_HIGH_RXPOWER)\n\t\tflags |= RDP_OET_HIGH_WARNING;\n\tif (phba->sfp_warning & LPFC_TRANSGRESSION_LOW_RXPOWER)\n\t\tflags |= RDP_OET_LOW_WARNING;\n\n\tflags |= ((0xf & RDP_OED_RXPOWER) << RDP_OED_TYPE_SHIFT);\n\tdesc->oed_info.function_flags = cpu_to_be32(flags);\n\tdesc->length = cpu_to_be32(sizeof(desc->oed_info));\n\treturn sizeof(struct fc_rdp_oed_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_opd_desc(struct fc_rdp_opd_sfp_desc *desc,\n\t\t      uint8_t *page_a0, struct lpfc_vport *vport)\n{\n\tdesc->tag = cpu_to_be32(RDP_OPD_DESC_TAG);\n\tmemcpy(desc->opd_info.vendor_name, &page_a0[SSF_VENDOR_NAME], 16);\n\tmemcpy(desc->opd_info.model_number, &page_a0[SSF_VENDOR_PN], 16);\n\tmemcpy(desc->opd_info.serial_number, &page_a0[SSF_VENDOR_SN], 16);\n\tmemcpy(desc->opd_info.revision, &page_a0[SSF_VENDOR_REV], 4);\n\tmemcpy(desc->opd_info.date, &page_a0[SSF_DATE_CODE], 8);\n\tdesc->length = cpu_to_be32(sizeof(desc->opd_info));\n\treturn sizeof(struct fc_rdp_opd_sfp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_fec_desc(struct fc_fec_rdp_desc *desc, READ_LNK_VAR *stat)\n{\n\tif (bf_get(lpfc_read_link_stat_gec2, stat) == 0)\n\t\treturn 0;\n\tdesc->tag = cpu_to_be32(RDP_FEC_DESC_TAG);\n\n\tdesc->info.CorrectedBlocks =\n\t\tcpu_to_be32(stat->fecCorrBlkCount);\n\tdesc->info.UncorrectableBlocks =\n\t\tcpu_to_be32(stat->fecUncorrBlkCount);\n\n\tdesc->length = cpu_to_be32(sizeof(desc->info));\n\n\treturn sizeof(struct fc_fec_rdp_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_speed(struct fc_rdp_port_speed_desc *desc, struct lpfc_hba *phba)\n{\n\tuint16_t rdp_cap = 0;\n\tuint16_t rdp_speed;\n\n\tdesc->tag = cpu_to_be32(RDP_PORT_SPEED_DESC_TAG);\n\n\tswitch (phba->fc_linkspeed) {\n\tcase LPFC_LINK_SPEED_1GHZ:\n\t\trdp_speed = RDP_PS_1GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_2GHZ:\n\t\trdp_speed = RDP_PS_2GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_4GHZ:\n\t\trdp_speed = RDP_PS_4GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_8GHZ:\n\t\trdp_speed = RDP_PS_8GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_10GHZ:\n\t\trdp_speed = RDP_PS_10GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_16GHZ:\n\t\trdp_speed = RDP_PS_16GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_32GHZ:\n\t\trdp_speed = RDP_PS_32GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_64GHZ:\n\t\trdp_speed = RDP_PS_64GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_128GHZ:\n\t\trdp_speed = RDP_PS_128GB;\n\t\tbreak;\n\tcase LPFC_LINK_SPEED_256GHZ:\n\t\trdp_speed = RDP_PS_256GB;\n\t\tbreak;\n\tdefault:\n\t\trdp_speed = RDP_PS_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tdesc->info.port_speed.speed = cpu_to_be16(rdp_speed);\n\n\tif (phba->lmt & LMT_256Gb)\n\t\trdp_cap |= RDP_PS_256GB;\n\tif (phba->lmt & LMT_128Gb)\n\t\trdp_cap |= RDP_PS_128GB;\n\tif (phba->lmt & LMT_64Gb)\n\t\trdp_cap |= RDP_PS_64GB;\n\tif (phba->lmt & LMT_32Gb)\n\t\trdp_cap |= RDP_PS_32GB;\n\tif (phba->lmt & LMT_16Gb)\n\t\trdp_cap |= RDP_PS_16GB;\n\tif (phba->lmt & LMT_10Gb)\n\t\trdp_cap |= RDP_PS_10GB;\n\tif (phba->lmt & LMT_8Gb)\n\t\trdp_cap |= RDP_PS_8GB;\n\tif (phba->lmt & LMT_4Gb)\n\t\trdp_cap |= RDP_PS_4GB;\n\tif (phba->lmt & LMT_2Gb)\n\t\trdp_cap |= RDP_PS_2GB;\n\tif (phba->lmt & LMT_1Gb)\n\t\trdp_cap |= RDP_PS_1GB;\n\n\tif (rdp_cap == 0)\n\t\trdp_cap = RDP_CAP_UNKNOWN;\n\tif (phba->cfg_link_speed != LPFC_USER_LINK_SPEED_AUTO)\n\t\trdp_cap |= RDP_CAP_USER_CONFIGURED;\n\n\tdesc->info.port_speed.capabilities = cpu_to_be16(rdp_cap);\n\tdesc->length = cpu_to_be32(sizeof(desc->info));\n\treturn sizeof(struct fc_rdp_port_speed_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_diag_port_names(struct fc_rdp_port_name_desc *desc,\n\t\tstruct lpfc_vport *vport)\n{\n\n\tdesc->tag = cpu_to_be32(RDP_PORT_NAMES_DESC_TAG);\n\n\tmemcpy(desc->port_names.wwnn, &vport->fc_nodename,\n\t\t\tsizeof(desc->port_names.wwnn));\n\n\tmemcpy(desc->port_names.wwpn, &vport->fc_portname,\n\t\t\tsizeof(desc->port_names.wwpn));\n\n\tdesc->length = cpu_to_be32(sizeof(desc->port_names));\n\treturn sizeof(struct fc_rdp_port_name_desc);\n}\n\nstatic uint32_t\nlpfc_rdp_res_attach_port_names(struct fc_rdp_port_name_desc *desc,\n\t\tstruct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\n\tdesc->tag = cpu_to_be32(RDP_PORT_NAMES_DESC_TAG);\n\tif (vport->fc_flag & FC_FABRIC) {\n\t\tmemcpy(desc->port_names.wwnn, &vport->fabric_nodename,\n\t\t       sizeof(desc->port_names.wwnn));\n\n\t\tmemcpy(desc->port_names.wwpn, &vport->fabric_portname,\n\t\t       sizeof(desc->port_names.wwpn));\n\t} else {   \n\t\tmemcpy(desc->port_names.wwnn, &ndlp->nlp_nodename,\n\t\t       sizeof(desc->port_names.wwnn));\n\n\t\tmemcpy(desc->port_names.wwpn, &ndlp->nlp_portname,\n\t\t       sizeof(desc->port_names.wwpn));\n\t}\n\n\tdesc->length = cpu_to_be32(sizeof(desc->port_names));\n\treturn sizeof(struct fc_rdp_port_name_desc);\n}\n\nstatic void\nlpfc_els_rdp_cmpl(struct lpfc_hba *phba, struct lpfc_rdp_context *rdp_context,\n\t\tint status)\n{\n\tstruct lpfc_nodelist *ndlp = rdp_context->ndlp;\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct ulp_bde64 *bpl;\n\tIOCB_t *icmd;\n\tunion lpfc_wqe128 *wqe;\n\tuint8_t *pcmd;\n\tstruct ls_rjt *stat;\n\tstruct fc_rdp_res_frame *rdp_res;\n\tuint32_t cmdsize, len;\n\tuint16_t *flag_ptr;\n\tint rc;\n\tu32 ulp_context;\n\n\tif (status != SUCCESS)\n\t\tgoto error;\n\n\t \n\tcmdsize = sizeof(struct fc_rdp_res_frame);\n\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize,\n\t\t\t\tlpfc_max_els_tries, rdp_context->ndlp,\n\t\t\t\trdp_context->ndlp->nlp_DID, ELS_CMD_ACC);\n\tif (!elsiocb)\n\t\tgoto free_rdp_context;\n\n\tulp_context = get_job_ulpcontext(phba, elsiocb);\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\t \n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       rdp_context->ox_id);\n\t\tbf_set(wqe_ctxt_tag, &wqe->xmit_els_rsp.wqe_com,\n\t\t       rdp_context->rx_id);\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = rdp_context->rx_id;\n\t\ticmd->unsli3.rcvsli3.ox_id = rdp_context->ox_id;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\"2171 Xmit RDP response tag x%x xri x%x, \"\n\t\t\t\"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\",\n\t\t\telsiocb->iotag, ulp_context,\n\t\t\tndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\tndlp->nlp_rpi);\n\trdp_res = (struct fc_rdp_res_frame *)elsiocb->cmd_dmabuf->virt;\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\tmemset(pcmd, 0, sizeof(struct fc_rdp_res_frame));\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\n\t \n\tflag_ptr = (uint16_t *)(rdp_context->page_a2 + SSF_ALARM_FLAGS);\n\tphba->sfp_alarm |= *flag_ptr;\n\tflag_ptr = (uint16_t *)(rdp_context->page_a2 + SSF_WARNING_FLAGS);\n\tphba->sfp_warning |= *flag_ptr;\n\n\t \n\tlen = 8;\n\tlen += lpfc_rdp_res_link_service((struct fc_rdp_link_service_desc *)\n\t\t\t\t\t (len + pcmd), ELS_CMD_RDP);\n\n\tlen += lpfc_rdp_res_sfp_desc((struct fc_rdp_sfp_desc *)(len + pcmd),\n\t\t\trdp_context->page_a0, rdp_context->page_a2);\n\tlen += lpfc_rdp_res_speed((struct fc_rdp_port_speed_desc *)(len + pcmd),\n\t\t\t\t  phba);\n\tlen += lpfc_rdp_res_link_error((struct fc_rdp_link_error_status_desc *)\n\t\t\t\t       (len + pcmd), &rdp_context->link_stat);\n\tlen += lpfc_rdp_res_diag_port_names((struct fc_rdp_port_name_desc *)\n\t\t\t\t\t     (len + pcmd), vport);\n\tlen += lpfc_rdp_res_attach_port_names((struct fc_rdp_port_name_desc *)\n\t\t\t\t\t(len + pcmd), vport, ndlp);\n\tlen += lpfc_rdp_res_fec_desc((struct fc_fec_rdp_desc *)(len + pcmd),\n\t\t\t&rdp_context->link_stat);\n\tlen += lpfc_rdp_res_bbc_desc((struct fc_rdp_bbc_desc *)(len + pcmd),\n\t\t\t\t     &rdp_context->link_stat, vport);\n\tlen += lpfc_rdp_res_oed_temp_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_oed_voltage_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_oed_txbias_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_oed_txpower_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_oed_rxpower_desc(phba,\n\t\t\t\t(struct fc_rdp_oed_sfp_desc *)(len + pcmd),\n\t\t\t\trdp_context->page_a2);\n\tlen += lpfc_rdp_res_opd_desc((struct fc_rdp_opd_sfp_desc *)(len + pcmd),\n\t\t\t\t     rdp_context->page_a0, vport);\n\n\trdp_res->length = cpu_to_be32(len - 8);\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\n\t \n\tbpl = (struct ulp_bde64 *)elsiocb->bpl_dmabuf->virt;\n\tbpl->tus.f.bdeSize = len;\n\tbpl->tus.f.bdeFlags = 0;\n\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto free_rdp_context;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t}\n\n\tgoto free_rdp_context;\n\nerror:\n\tcmdsize = 2 * sizeof(uint32_t);\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, lpfc_max_els_tries,\n\t\t\tndlp, ndlp->nlp_DID, ELS_CMD_LS_RJT);\n\tif (!elsiocb)\n\t\tgoto free_rdp_context;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\t \n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       rdp_context->ox_id);\n\t\tbf_set(wqe_ctxt_tag,\n\t\t       &wqe->xmit_els_rsp.wqe_com,\n\t\t       rdp_context->rx_id);\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = rdp_context->rx_id;\n\t\ticmd->unsli3.rcvsli3.ox_id = rdp_context->ox_id;\n\t}\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t*((uint32_t *) (pcmd)) = ELS_CMD_LS_RJT;\n\tstat = (struct ls_rjt *)(pcmd + sizeof(uint32_t));\n\tstat->un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\n\tphba->fc_stat.elsXmitLSRJT++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto free_rdp_context;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t}\n\nfree_rdp_context:\n\t \n\tlpfc_nlp_put(ndlp);\n\tkfree(rdp_context);\n}\n\nstatic int\nlpfc_get_rdp_info(struct lpfc_hba *phba, struct lpfc_rdp_context *rdp_context)\n{\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tint rc;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX | LOG_ELS,\n\t\t\t\t\"7105 failed to allocate mailbox memory\");\n\t\treturn 1;\n\t}\n\n\tif (lpfc_sli4_dump_page_a0(phba, mbox))\n\t\tgoto rdp_fail;\n\tmbox->vport = rdp_context->ndlp->vport;\n\tmbox->mbox_cmpl = lpfc_mbx_cmpl_rdp_page_a0;\n\tmbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n\nrdp_fail:\n\tmempool_free(mbox, phba->mbox_mem_pool);\n\treturn 1;\n}\n\nint lpfc_get_sfp_info_wait(struct lpfc_hba *phba,\n\t\t\t   struct lpfc_rdp_context *rdp_context)\n{\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tint rc;\n\tstruct lpfc_dmabuf *mp;\n\tstruct lpfc_dmabuf *mpsave;\n\tvoid *virt;\n\tMAILBOX_t *mb;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX | LOG_ELS,\n\t\t\t\t\"7205 failed to allocate mailbox memory\");\n\t\treturn 1;\n\t}\n\n\tif (lpfc_sli4_dump_page_a0(phba, mbox))\n\t\tgoto sfp_fail;\n\tmp = mbox->ctx_buf;\n\tmpsave = mp;\n\tvirt = mp->virt;\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\tmb = &mbox->u.mb;\n\t\tmb->un.varDmp.cv = 1;\n\t\tmb->un.varDmp.co = 1;\n\t\tmb->un.varWords[2] = 0;\n\t\tmb->un.varWords[3] = DMP_SFF_PAGE_A0_SIZE / 4;\n\t\tmb->un.varWords[4] = 0;\n\t\tmb->un.varWords[5] = 0;\n\t\tmb->un.varWords[6] = 0;\n\t\tmb->un.varWords[7] = 0;\n\t\tmb->un.varWords[8] = 0;\n\t\tmb->un.varWords[9] = 0;\n\t\tmb->un.varWords[10] = 0;\n\t\tmbox->in_ext_byte_len = DMP_SFF_PAGE_A0_SIZE;\n\t\tmbox->out_ext_byte_len = DMP_SFF_PAGE_A0_SIZE;\n\t\tmbox->mbox_offset_word = 5;\n\t\tmbox->ctx_buf = virt;\n\t} else {\n\t\tbf_set(lpfc_mbx_memory_dump_type3_length,\n\t\t       &mbox->u.mqe.un.mem_dump_type3, DMP_SFF_PAGE_A0_SIZE);\n\t\tmbox->u.mqe.un.mem_dump_type3.addr_lo = putPaddrLow(mp->phys);\n\t\tmbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);\n\t}\n\tmbox->vport = phba->pport;\n\tmbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;\n\n\trc = lpfc_sli_issue_mbox_wait(phba, mbox, 30);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\trc = 1;\n\t\tgoto error;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tmp = (struct lpfc_dmabuf *)(mbox->ctx_buf);\n\telse\n\t\tmp = mpsave;\n\n\tif (bf_get(lpfc_mqe_status, &mbox->u.mqe)) {\n\t\trc = 1;\n\t\tgoto error;\n\t}\n\n\tlpfc_sli_bemem_bcopy(mp->virt, &rdp_context->page_a0,\n\t\t\t     DMP_SFF_PAGE_A0_SIZE);\n\n\tmemset(mbox, 0, sizeof(*mbox));\n\tmemset(mp->virt, 0, DMP_SFF_PAGE_A2_SIZE);\n\tINIT_LIST_HEAD(&mp->list);\n\n\t \n\tmbox->ctx_buf = mp;\n\tmbox->vport = phba->pport;\n\n\tbf_set(lpfc_mqe_command, &mbox->u.mqe, MBX_DUMP_MEMORY);\n\tbf_set(lpfc_mbx_memory_dump_type3_type,\n\t       &mbox->u.mqe.un.mem_dump_type3, DMP_LMSD);\n\tbf_set(lpfc_mbx_memory_dump_type3_link,\n\t       &mbox->u.mqe.un.mem_dump_type3, phba->sli4_hba.physical_port);\n\tbf_set(lpfc_mbx_memory_dump_type3_page_no,\n\t       &mbox->u.mqe.un.mem_dump_type3, DMP_PAGE_A2);\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\tmb = &mbox->u.mb;\n\t\tmb->un.varDmp.cv = 1;\n\t\tmb->un.varDmp.co = 1;\n\t\tmb->un.varWords[2] = 0;\n\t\tmb->un.varWords[3] = DMP_SFF_PAGE_A2_SIZE / 4;\n\t\tmb->un.varWords[4] = 0;\n\t\tmb->un.varWords[5] = 0;\n\t\tmb->un.varWords[6] = 0;\n\t\tmb->un.varWords[7] = 0;\n\t\tmb->un.varWords[8] = 0;\n\t\tmb->un.varWords[9] = 0;\n\t\tmb->un.varWords[10] = 0;\n\t\tmbox->in_ext_byte_len = DMP_SFF_PAGE_A2_SIZE;\n\t\tmbox->out_ext_byte_len = DMP_SFF_PAGE_A2_SIZE;\n\t\tmbox->mbox_offset_word = 5;\n\t\tmbox->ctx_buf = virt;\n\t} else {\n\t\tbf_set(lpfc_mbx_memory_dump_type3_length,\n\t\t       &mbox->u.mqe.un.mem_dump_type3, DMP_SFF_PAGE_A2_SIZE);\n\t\tmbox->u.mqe.un.mem_dump_type3.addr_lo = putPaddrLow(mp->phys);\n\t\tmbox->u.mqe.un.mem_dump_type3.addr_hi = putPaddrHigh(mp->phys);\n\t}\n\n\tmbox->ctx_ndlp = (struct lpfc_rdp_context *)rdp_context;\n\trc = lpfc_sli_issue_mbox_wait(phba, mbox, 30);\n\tif (bf_get(lpfc_mqe_status, &mbox->u.mqe)) {\n\t\trc = 1;\n\t\tgoto error;\n\t}\n\trc = 0;\n\n\tlpfc_sli_bemem_bcopy(mp->virt, &rdp_context->page_a2,\n\t\t\t     DMP_SFF_PAGE_A2_SIZE);\n\nerror:\n\tmbox->ctx_buf = mpsave;\n\tlpfc_mbox_rsrc_cleanup(phba, mbox, MBOX_THD_UNLOCKED);\n\n\treturn rc;\n\nsfp_fail:\n\tmempool_free(mbox, phba->mbox_mem_pool);\n\treturn 1;\n}\n\n \nstatic int\nlpfc_els_rcv_rdp(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\tstruct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint8_t rjt_err, rjt_expl = LSEXP_NOTHING_MORE;\n\tstruct fc_rdp_req_frame *rdp_req;\n\tstruct lpfc_rdp_context *rdp_context;\n\tunion lpfc_wqe128 *cmd = NULL;\n\tstruct ls_rjt stat;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4 ||\n\t    bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t\t\t\t\t\tLPFC_SLI_INTF_IF_TYPE_2) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\trjt_expl = LSEXP_REQ_UNSUPPORTED;\n\t\tgoto error;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4 || (phba->hba_flag & HBA_FCOE_MODE)) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\trjt_expl = LSEXP_REQ_UNSUPPORTED;\n\t\tgoto error;\n\t}\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\trdp_req = (struct fc_rdp_req_frame *) pcmd->virt;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2422 ELS RDP Request \"\n\t\t\t \"dec len %d tag x%x port_id %d len %d\\n\",\n\t\t\t be32_to_cpu(rdp_req->rdp_des_length),\n\t\t\t be32_to_cpu(rdp_req->nport_id_desc.tag),\n\t\t\t be32_to_cpu(rdp_req->nport_id_desc.nport_id),\n\t\t\t be32_to_cpu(rdp_req->nport_id_desc.length));\n\n\tif (sizeof(struct fc_rdp_nport_desc) !=\n\t\t\tbe32_to_cpu(rdp_req->rdp_des_length))\n\t\tgoto rjt_logerr;\n\tif (RDP_N_PORT_DESC_TAG != be32_to_cpu(rdp_req->nport_id_desc.tag))\n\t\tgoto rjt_logerr;\n\tif (RDP_NPORT_ID_SIZE !=\n\t\t\tbe32_to_cpu(rdp_req->nport_id_desc.length))\n\t\tgoto rjt_logerr;\n\trdp_context = kzalloc(sizeof(struct lpfc_rdp_context), GFP_KERNEL);\n\tif (!rdp_context) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto error;\n\t}\n\n\tcmd = &cmdiocb->wqe;\n\trdp_context->ndlp = lpfc_nlp_get(ndlp);\n\tif (!rdp_context->ndlp) {\n\t\tkfree(rdp_context);\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto error;\n\t}\n\trdp_context->ox_id = bf_get(wqe_rcvoxid,\n\t\t\t\t    &cmd->xmit_els_rsp.wqe_com);\n\trdp_context->rx_id = bf_get(wqe_ctxt_tag,\n\t\t\t\t    &cmd->xmit_els_rsp.wqe_com);\n\trdp_context->cmpl = lpfc_els_rdp_cmpl;\n\tif (lpfc_get_rdp_info(phba, rdp_context)) {\n\t\tlpfc_printf_vlog(ndlp->vport, KERN_WARNING, LOG_ELS,\n\t\t\t\t \"2423 Unable to send mailbox\");\n\t\tkfree(rdp_context);\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nrjt_logerr:\n\trjt_err = LSRJT_LOGICAL_ERR;\n\nerror:\n\tmemset(&stat, 0, sizeof(stat));\n\tstat.un.b.lsRjtRsnCode = rjt_err;\n\tstat.un.b.lsRjtRsnCodeExp = rjt_expl;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 1;\n}\n\n\nstatic void\nlpfc_els_lcb_rsp(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tMAILBOX_t *mb;\n\tIOCB_t *icmd;\n\tunion lpfc_wqe128 *wqe;\n\tuint8_t *pcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct ls_rjt *stat;\n\tunion lpfc_sli4_cfg_shdr *shdr;\n\tstruct lpfc_lcb_context *lcb_context;\n\tstruct fc_lcb_res_frame *lcb_res;\n\tuint32_t cmdsize, shdr_status, shdr_add_status;\n\tint rc;\n\n\tmb = &pmb->u.mb;\n\tlcb_context = (struct lpfc_lcb_context *)pmb->ctx_ndlp;\n\tndlp = lcb_context->ndlp;\n\tpmb->ctx_ndlp = NULL;\n\tpmb->ctx_buf = NULL;\n\n\tshdr = (union lpfc_sli4_cfg_shdr *)\n\t\t\t&pmb->u.mqe.un.beacon_config.header.cfg_shdr;\n\tshdr_status = bf_get(lpfc_mbox_hdr_status, &shdr->response);\n\tshdr_add_status = bf_get(lpfc_mbox_hdr_add_status, &shdr->response);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_MBOX,\n\t\t\t\t\"0194 SET_BEACON_CONFIG mailbox \"\n\t\t\t\t\"completed with status x%x add_status x%x,\"\n\t\t\t\t\" mbx status x%x\\n\",\n\t\t\t\tshdr_status, shdr_add_status, mb->mbxStatus);\n\n\tif ((mb->mbxStatus != MBX_SUCCESS) || shdr_status ||\n\t    (shdr_add_status == ADD_STATUS_OPERATION_ALREADY_ACTIVE) ||\n\t    (shdr_add_status == ADD_STATUS_INVALID_REQUEST)) {\n\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\tgoto error;\n\t}\n\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\tcmdsize = sizeof(struct fc_lcb_res_frame);\n\telsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\n\t\t\tlpfc_max_els_tries, ndlp,\n\t\t\tndlp->nlp_DID, ELS_CMD_ACC);\n\n\t \n\tlpfc_nlp_put(ndlp);\n\n\tif (!elsiocb)\n\t\tgoto free_lcb_context;\n\n\tlcb_res = (struct fc_lcb_res_frame *)elsiocb->cmd_dmabuf->virt;\n\n\tmemset(lcb_res, 0, sizeof(struct fc_lcb_res_frame));\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com, lcb_context->rx_id);\n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       lcb_context->ox_id);\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = lcb_context->rx_id;\n\t\ticmd->unsli3.rcvsli3.ox_id = lcb_context->ox_id;\n\t}\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *)(pcmd)) = ELS_CMD_ACC;\n\tlcb_res->lcb_sub_command = lcb_context->sub_command;\n\tlcb_res->lcb_type = lcb_context->type;\n\tlcb_res->capability = lcb_context->capability;\n\tlcb_res->lcb_frequency = lcb_context->frequency;\n\tlcb_res->lcb_duration = lcb_context->duration;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitACC++;\n\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto out;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t}\n out:\n\tkfree(lcb_context);\n\treturn;\n\nerror:\n\tcmdsize = sizeof(struct fc_lcb_res_frame);\n\telsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\n\t\t\t\t     lpfc_max_els_tries, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_LS_RJT);\n\tlpfc_nlp_put(ndlp);\n\tif (!elsiocb)\n\t\tgoto free_lcb_context;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com, lcb_context->rx_id);\n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       lcb_context->ox_id);\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = lcb_context->rx_id;\n\t\ticmd->unsli3.rcvsli3.ox_id = lcb_context->ox_id;\n\t}\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t*((uint32_t *)(pcmd)) = ELS_CMD_LS_RJT;\n\tstat = (struct ls_rjt *)(pcmd + sizeof(uint32_t));\n\tstat->un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\n\tif (shdr_add_status == ADD_STATUS_OPERATION_ALREADY_ACTIVE)\n\t\tstat->un.b.lsRjtRsnCodeExp = LSEXP_CMD_IN_PROGRESS;\n\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitLSRJT++;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto free_lcb_context;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t}\nfree_lcb_context:\n\tkfree(lcb_context);\n}\n\nstatic int\nlpfc_sli4_set_beacon(struct lpfc_vport *vport,\n\t\t     struct lpfc_lcb_context *lcb_context,\n\t\t     uint32_t beacon_state)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tunion lpfc_sli4_cfg_shdr *cfg_shdr;\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tuint32_t len;\n\tint rc;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox)\n\t\treturn 1;\n\n\tcfg_shdr = &mbox->u.mqe.un.sli4_config.header.cfg_shdr;\n\tlen = sizeof(struct lpfc_mbx_set_beacon_config) -\n\t\tsizeof(struct lpfc_sli4_cfg_mhdr);\n\tlpfc_sli4_config(phba, mbox, LPFC_MBOX_SUBSYSTEM_COMMON,\n\t\t\t LPFC_MBOX_OPCODE_SET_BEACON_CONFIG, len,\n\t\t\t LPFC_SLI4_MBX_EMBED);\n\tmbox->ctx_ndlp = (void *)lcb_context;\n\tmbox->vport = phba->pport;\n\tmbox->mbox_cmpl = lpfc_els_lcb_rsp;\n\tbf_set(lpfc_mbx_set_beacon_port_num, &mbox->u.mqe.un.beacon_config,\n\t       phba->sli4_hba.physical_port);\n\tbf_set(lpfc_mbx_set_beacon_state, &mbox->u.mqe.un.beacon_config,\n\t       beacon_state);\n\tmbox->u.mqe.un.beacon_config.word5 = 0;\t\t \n\n\t \n\n\tif (phba->sli4_hba.pc_sli4_params.bv1s) {\n\t\t \n\t\tcfg_shdr->request.word9 = BEACON_VERSION_V1;\n\t\tlcb_context->capability |= LCB_CAPABILITY_DURATION;\n\t\tbf_set(lpfc_mbx_set_beacon_port_type,\n\t\t       &mbox->u.mqe.un.beacon_config, 0);\n\t\tbf_set(lpfc_mbx_set_beacon_duration_v1,\n\t\t       &mbox->u.mqe.un.beacon_config,\n\t\t       be16_to_cpu(lcb_context->duration));\n\t} else {\n\t\t \n\t\tif (be16_to_cpu(lcb_context->duration) != 0) {\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\treturn 1;\n\t\t}\n\t\tcfg_shdr->request.word9 = BEACON_VERSION_V0;\n\t\tlcb_context->capability &=  ~(LCB_CAPABILITY_DURATION);\n\t\tbf_set(lpfc_mbx_set_beacon_state,\n\t\t       &mbox->u.mqe.un.beacon_config, beacon_state);\n\t\tbf_set(lpfc_mbx_set_beacon_port_type,\n\t\t       &mbox->u.mqe.un.beacon_config, 1);\n\t\tbf_set(lpfc_mbx_set_beacon_duration,\n\t\t       &mbox->u.mqe.un.beacon_config,\n\t\t       be16_to_cpu(lcb_context->duration));\n\t}\n\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT);\n\tif (rc == MBX_NOT_FINISHED) {\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int\nlpfc_els_rcv_lcb(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint8_t *lp;\n\tstruct fc_lcb_request_frame *beacon;\n\tstruct lpfc_lcb_context *lcb_context;\n\tu8 state, rjt_err = 0;\n\tstruct ls_rjt stat;\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tlp = (uint8_t *)pcmd->virt;\n\tbeacon = (struct fc_lcb_request_frame *)pcmd->virt;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\"0192 ELS LCB Data x%x x%x x%x x%x sub x%x \"\n\t\t\t\"type x%x frequency %x duration x%x\\n\",\n\t\t\tlp[0], lp[1], lp[2],\n\t\t\tbeacon->lcb_command,\n\t\t\tbeacon->lcb_sub_command,\n\t\t\tbeacon->lcb_type,\n\t\t\tbeacon->lcb_frequency,\n\t\t\tbe16_to_cpu(beacon->lcb_duration));\n\n\tif (beacon->lcb_sub_command != LPFC_LCB_ON &&\n\t    beacon->lcb_sub_command != LPFC_LCB_OFF) {\n\t\trjt_err = LSRJT_CMD_UNSUPPORTED;\n\t\tgoto rjt;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4  ||\n\t    phba->hba_flag & HBA_FCOE_MODE ||\n\t    (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t    LPFC_SLI_INTF_IF_TYPE_2)) {\n\t\trjt_err = LSRJT_CMD_UNSUPPORTED;\n\t\tgoto rjt;\n\t}\n\n\tlcb_context = kmalloc(sizeof(*lcb_context), GFP_KERNEL);\n\tif (!lcb_context) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto rjt;\n\t}\n\n\tstate = (beacon->lcb_sub_command == LPFC_LCB_ON) ? 1 : 0;\n\tlcb_context->sub_command = beacon->lcb_sub_command;\n\tlcb_context->capability\t= 0;\n\tlcb_context->type = beacon->lcb_type;\n\tlcb_context->frequency = beacon->lcb_frequency;\n\tlcb_context->duration = beacon->lcb_duration;\n\tlcb_context->ox_id = get_job_rcvoxid(phba, cmdiocb);\n\tlcb_context->rx_id = get_job_ulpcontext(phba, cmdiocb);\n\tlcb_context->ndlp = lpfc_nlp_get(ndlp);\n\tif (!lcb_context->ndlp) {\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto rjt_free;\n\t}\n\n\tif (lpfc_sli4_set_beacon(vport, lcb_context, state)) {\n\t\tlpfc_printf_vlog(ndlp->vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0193 failed to send mail box\");\n\t\tlpfc_nlp_put(ndlp);\n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\tgoto rjt_free;\n\t}\n\treturn 0;\n\nrjt_free:\n\tkfree(lcb_context);\nrjt:\n\tmemset(&stat, 0, sizeof(stat));\n\tstat.un.b.lsRjtRsnCode = rjt_err;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 1;\n}\n\n\n \nvoid\nlpfc_els_flush_rscn(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tint i;\n\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_rscn_flush) {\n\t\t \n\t\tspin_unlock_irq(shost->host_lock);\n\t\treturn;\n\t}\n\t \n\tvport->fc_rscn_flush = 1;\n\tspin_unlock_irq(shost->host_lock);\n\n\tfor (i = 0; i < vport->fc_rscn_id_cnt; i++) {\n\t\tlpfc_in_buf_free(phba, vport->fc_rscn_id_list[i]);\n\t\tvport->fc_rscn_id_list[i] = NULL;\n\t}\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_rscn_id_cnt = 0;\n\tvport->fc_flag &= ~(FC_RSCN_MODE | FC_RSCN_DISCOVERY);\n\tspin_unlock_irq(shost->host_lock);\n\tlpfc_can_disctmo(vport);\n\t \n\tvport->fc_rscn_flush = 0;\n}\n\n \nint\nlpfc_rscn_payload_check(struct lpfc_vport *vport, uint32_t did)\n{\n\tD_ID ns_did;\n\tD_ID rscn_did;\n\tuint32_t *lp;\n\tuint32_t payload_len, i;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tns_did.un.word = did;\n\n\t \n\tif ((did & Fabric_DID_MASK) == Fabric_DID_MASK)\n\t\treturn 0;\n\n\t \n\tif (vport->fc_flag & FC_RSCN_DISCOVERY)\n\t\treturn did;\n\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_rscn_flush) {\n\t\t \n\t\tspin_unlock_irq(shost->host_lock);\n\t\treturn 0;\n\t}\n\t \n\tvport->fc_rscn_flush = 1;\n\tspin_unlock_irq(shost->host_lock);\n\tfor (i = 0; i < vport->fc_rscn_id_cnt; i++) {\n\t\tlp = vport->fc_rscn_id_list[i]->virt;\n\t\tpayload_len = be32_to_cpu(*lp++ & ~ELS_CMD_MASK);\n\t\tpayload_len -= sizeof(uint32_t);\t \n\t\twhile (payload_len) {\n\t\t\trscn_did.un.word = be32_to_cpu(*lp++);\n\t\t\tpayload_len -= sizeof(uint32_t);\n\t\t\tswitch (rscn_did.un.b.resv & RSCN_ADDRESS_FORMAT_MASK) {\n\t\t\tcase RSCN_ADDRESS_FORMAT_PORT:\n\t\t\t\tif ((ns_did.un.b.domain == rscn_did.un.b.domain)\n\t\t\t\t    && (ns_did.un.b.area == rscn_did.un.b.area)\n\t\t\t\t    && (ns_did.un.b.id == rscn_did.un.b.id))\n\t\t\t\t\tgoto return_did_out;\n\t\t\t\tbreak;\n\t\t\tcase RSCN_ADDRESS_FORMAT_AREA:\n\t\t\t\tif ((ns_did.un.b.domain == rscn_did.un.b.domain)\n\t\t\t\t    && (ns_did.un.b.area == rscn_did.un.b.area))\n\t\t\t\t\tgoto return_did_out;\n\t\t\t\tbreak;\n\t\t\tcase RSCN_ADDRESS_FORMAT_DOMAIN:\n\t\t\t\tif (ns_did.un.b.domain == rscn_did.un.b.domain)\n\t\t\t\t\tgoto return_did_out;\n\t\t\t\tbreak;\n\t\t\tcase RSCN_ADDRESS_FORMAT_FABRIC:\n\t\t\t\tgoto return_did_out;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tvport->fc_rscn_flush = 0;\n\treturn 0;\nreturn_did_out:\n\t \n\tvport->fc_rscn_flush = 0;\n\treturn did;\n}\n\n \nstatic int\nlpfc_rscn_recovery_check(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp = NULL, *n;\n\n\t \n\tlist_for_each_entry_safe(ndlp, n, &vport->fc_nodes, nlp_listp) {\n\t\tif ((ndlp->nlp_state == NLP_STE_UNUSED_NODE) ||\n\t\t    !lpfc_rscn_payload_check(vport, ndlp->nlp_DID))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vport->phba->nvmet_support)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (ndlp->nlp_state) {\n\t\tcase  NLP_STE_PLOGI_ISSUE:\n\t\tcase  NLP_STE_ADISC_ISSUE:\n\t\tcase  NLP_STE_REG_LOGIN_ISSUE:\n\t\tcase  NLP_STE_PRLI_ISSUE:\n\t\tcase  NLP_STE_LOGO_ISSUE:\n\t\t\tcontinue;\n\t\t}\n\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RECOVERY);\n\t\tlpfc_cancel_retry_delay_tmo(vport, ndlp);\n\t}\n\treturn 0;\n}\n\n \nstatic void\nlpfc_send_rscn_event(struct lpfc_vport *vport,\n\t\tstruct lpfc_iocbq *cmdiocb)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tuint32_t *payload_ptr;\n\tuint32_t payload_len;\n\tstruct lpfc_rscn_event_header *rscn_event_data;\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tpayload_ptr = (uint32_t *) pcmd->virt;\n\tpayload_len = be32_to_cpu(*payload_ptr & ~ELS_CMD_MASK);\n\n\trscn_event_data = kmalloc(sizeof(struct lpfc_rscn_event_header) +\n\t\tpayload_len, GFP_KERNEL);\n\tif (!rscn_event_data) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0147 Failed to allocate memory for RSCN event\\n\");\n\t\treturn;\n\t}\n\trscn_event_data->event_type = FC_REG_RSCN_EVENT;\n\trscn_event_data->payload_length = payload_len;\n\tmemcpy(rscn_event_data->rscn_payload, payload_ptr,\n\t\tpayload_len);\n\n\tfc_host_post_vendor_event(shost,\n\t\tfc_get_event_number(),\n\t\tsizeof(struct lpfc_rscn_event_header) + payload_len,\n\t\t(char *)rscn_event_data,\n\t\tLPFC_NL_VENDOR_ID);\n\n\tkfree(rscn_event_data);\n}\n\n \nstatic int\nlpfc_els_rcv_rscn(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp, *datap;\n\tuint32_t payload_len, length, nportid, *cmd;\n\tint rscn_cnt;\n\tint rscn_id = 0, hba_id = 0;\n\tint i, tmo;\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tlp = (uint32_t *) pcmd->virt;\n\n\tpayload_len = be32_to_cpu(*lp++ & ~ELS_CMD_MASK);\n\tpayload_len -= sizeof(uint32_t);\t \n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0214 RSCN received Data: x%x x%x x%x x%x\\n\",\n\t\t\t vport->fc_flag, payload_len, *lp,\n\t\t\t vport->fc_rscn_id_cnt);\n\n\t \n\tlpfc_send_rscn_event(vport, cmdiocb);\n\n\tfor (i = 0; i < payload_len/sizeof(uint32_t); i++)\n\t\tfc_host_post_event(shost, fc_get_event_number(),\n\t\t\tFCH_EVT_RSCN, lp[i]);\n\n\t \n\tif (vport->fc_flag & FC_PT2PT) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"2024 pt2pt RSCN %08x Data: x%x x%x\\n\",\n\t\t\t\t *lp, vport->fc_flag, payload_len);\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\n\t\t \n\t\tif (ndlp->nlp_fc4_type & NLP_FC4_NVME &&\n\t\t    ndlp->nlp_type & (NLP_NVME_TARGET | NLP_NVME_DISCOVERY))\n\t\t\tlpfc_nvme_rescan_port(vport, ndlp);\n\t\treturn 0;\n\t}\n\n\t \n\tif (vport->port_state <= LPFC_NS_QRY) {\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RSCN ignore: did:x%x/ste:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\n\n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t\t!(vport->cfg_peer_port_login)) {\n\t\ti = payload_len;\n\t\tdatap = lp;\n\t\twhile (i > 0) {\n\t\t\tnportid = *datap++;\n\t\t\tnportid = ((be32_to_cpu(nportid)) & Mask_DID);\n\t\t\ti -= sizeof(uint32_t);\n\t\t\trscn_id++;\n\t\t\tif (lpfc_find_vport_by_did(phba, nportid))\n\t\t\t\thba_id++;\n\t\t}\n\t\tif (rscn_id == hba_id) {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0219 Ignore RSCN \"\n\t\t\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\t vport->fc_flag, payload_len,\n\t\t\t\t\t *lp, vport->fc_rscn_id_cnt);\n\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\t\"RCV RSCN vport:  did:x%x/ste:x%x flg:x%x\",\n\t\t\t\tndlp->nlp_DID, vport->port_state,\n\t\t\t\tndlp->nlp_flag);\n\n\t\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb,\n\t\t\t\tndlp, NULL);\n\t\t\t \n\t\t\tif (vport->fc_flag & FC_DISC_TMO) {\n\t\t\t\ttmo = ((phba->fc_ratov * 3) + 3);\n\t\t\t\tmod_timer(&vport->fc_disctmo,\n\t\t\t\t\t  jiffies +\n\t\t\t\t\t  msecs_to_jiffies(1000 * tmo));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_rscn_flush) {\n\t\t \n\t\tvport->fc_flag |= FC_RSCN_DISCOVERY;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\t \n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t\treturn 0;\n\t}\n\t \n\tvport->fc_rscn_flush = 1;\n\tspin_unlock_irq(shost->host_lock);\n\t \n\trscn_cnt = vport->fc_rscn_id_cnt;\n\t \n\tif (vport->fc_flag & (FC_RSCN_MODE | FC_NDISC_ACTIVE)) {\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RSCN defer:  did:x%x/ste:x%x flg:x%x\",\n\t\t\tndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\n\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_RSCN_DEFERRED;\n\n\t\t \n\t\tif (vport->fc_flag & FC_DISC_TMO) {\n\t\t\ttmo = ((phba->fc_ratov * 3) + 3);\n\t\t\tmod_timer(&vport->fc_disctmo,\n\t\t\t\t  jiffies + msecs_to_jiffies(1000 * tmo));\n\t\t}\n\t\tif ((rscn_cnt < FC_MAX_HOLD_RSCN) &&\n\t\t    !(vport->fc_flag & FC_RSCN_DISCOVERY)) {\n\t\t\tvport->fc_flag |= FC_RSCN_MODE;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tif (rscn_cnt) {\n\t\t\t\tcmd = vport->fc_rscn_id_list[rscn_cnt-1]->virt;\n\t\t\t\tlength = be32_to_cpu(*cmd & ~ELS_CMD_MASK);\n\t\t\t}\n\t\t\tif ((rscn_cnt) &&\n\t\t\t    (payload_len + length <= LPFC_BPL_SIZE)) {\n\t\t\t\t*cmd &= ELS_CMD_MASK;\n\t\t\t\t*cmd |= cpu_to_be32(payload_len + length);\n\t\t\t\tmemcpy(((uint8_t *)cmd) + length, lp,\n\t\t\t\t       payload_len);\n\t\t\t} else {\n\t\t\t\tvport->fc_rscn_id_list[rscn_cnt] = pcmd;\n\t\t\t\tvport->fc_rscn_id_cnt++;\n\t\t\t\t \n\t\t\t\tcmdiocb->cmd_dmabuf = NULL;\n\t\t\t}\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0235 Deferred RSCN \"\n\t\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t\t vport->fc_rscn_id_cnt, vport->fc_flag,\n\t\t\t\t\t vport->port_state);\n\t\t} else {\n\t\t\tvport->fc_flag |= FC_RSCN_DISCOVERY;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0234 ReDiscovery RSCN \"\n\t\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t\t vport->fc_rscn_id_cnt, vport->fc_flag,\n\t\t\t\t\t vport->port_state);\n\t\t}\n\t\t \n\t\tvport->fc_rscn_flush = 0;\n\t\t \n\t\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t\t \n\t\tlpfc_rscn_recovery_check(vport);\n\t\treturn 0;\n\t}\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\"RCV RSCN:        did:x%x/ste:x%x flg:x%x\",\n\t\tndlp->nlp_DID, vport->port_state, ndlp->nlp_flag);\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag |= FC_RSCN_MODE;\n\tspin_unlock_irq(shost->host_lock);\n\tvport->fc_rscn_id_list[vport->fc_rscn_id_cnt++] = pcmd;\n\t \n\tvport->fc_rscn_flush = 0;\n\t \n\tcmdiocb->cmd_dmabuf = NULL;\n\tlpfc_set_disctmo(vport);\n\t \n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\t \n\tlpfc_rscn_recovery_check(vport);\n\treturn lpfc_els_handle_rscn(vport);\n}\n\n \nint\nlpfc_els_handle_rscn(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_hba  *phba = vport->phba;\n\n\t \n\tif (vport->load_flag & FC_UNLOADING) {\n\t\tlpfc_els_flush_rscn(vport);\n\t\treturn 0;\n\t}\n\n\t \n\tlpfc_set_disctmo(vport);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0215 RSCN processed Data: x%x x%x x%x x%x x%x x%x\\n\",\n\t\t\t vport->fc_flag, 0, vport->fc_rscn_id_cnt,\n\t\t\t vport->port_state, vport->num_disc_nodes,\n\t\t\t vport->gidft_inp);\n\n\t \n\tvport->fc_ns_retry = 0;\n\tvport->num_disc_nodes = 0;\n\n\tndlp = lpfc_findnode_did(vport, NameServer_DID);\n\tif (ndlp && ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) {\n\t\t \n\t\tif (phba->cfg_ns_query == LPFC_NS_QUERY_GID_FT) {\n\t\t\tif (lpfc_issue_gidft(vport) > 0)\n\t\t\t\treturn 1;\n\t\t} else if (phba->cfg_ns_query == LPFC_NS_QUERY_GID_PT) {\n\t\t\tif (lpfc_issue_gidpt(vport) > 0)\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (ndlp) {\n\t\t\tndlp->nlp_prev_state = NLP_STE_UNUSED_NODE;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t} else {\n\t\t\tndlp = lpfc_nlp_init(vport, NameServer_DID);\n\t\t\tif (!ndlp) {\n\t\t\t\tlpfc_els_flush_rscn(vport);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\t\t}\n\t\tndlp->nlp_type |= NLP_FABRIC;\n\t\tlpfc_issue_els_plogi(vport, NameServer_DID, 0);\n\t\t \n\t\treturn 1;\n\t}\n\n\tlpfc_els_flush_rscn(vport);\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_flogi(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_dmabuf *pcmd = cmdiocb->cmd_dmabuf;\n\tuint32_t *lp = (uint32_t *) pcmd->virt;\n\tunion lpfc_wqe128 *wqe = &cmdiocb->wqe;\n\tstruct serv_parm *sp;\n\tLPFC_MBOXQ_t *mbox;\n\tuint32_t cmd, did;\n\tint rc;\n\tuint32_t fc_flag = 0;\n\tuint32_t port_state = 0;\n\n\t \n\tphba->link_flag &= ~LS_EXTERNAL_LOOPBACK;\n\n\tcmd = *lp++;\n\tsp = (struct serv_parm *) lp;\n\n\t \n\n\tlpfc_set_disctmo(vport);\n\n\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t \n\t\tdid =  bf_get(wqe_els_did, &wqe->xmit_els_rsp.wqe_dest);\n\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0113 An FLOGI ELS command x%x was \"\n\t\t\t\t \"received from DID x%x in Loop Mode\\n\",\n\t\t\t\t cmd, did);\n\t\treturn 1;\n\t}\n\n\t(void) lpfc_check_sparm(vport, ndlp, sp, CLASS3, 1);\n\n\t \n\n\trc = memcmp(&vport->fc_portname, &sp->portName,\n\t\t    sizeof(struct lpfc_name));\n\n\tif (!rc) {\n\t\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\t\tmbox = mempool_alloc(phba->mbox_mem_pool,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!mbox)\n\t\t\t\treturn 1;\n\t\t\tlpfc_linkdown(phba);\n\t\t\tlpfc_init_link(phba, mbox,\n\t\t\t\t       phba->cfg_topology,\n\t\t\t\t       phba->cfg_link_speed);\n\t\t\tmbox->u.mb.un.varInitLnk.lipsr_AL_PA = 0;\n\t\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\t\tmbox->vport = vport;\n\t\t\trc = lpfc_sli_issue_mbox(phba, mbox,\n\t\t\t\t\t\t MBX_NOWAIT);\n\t\t\tlpfc_set_loopback_flag(phba);\n\t\t\tif (rc == MBX_NOT_FINISHED)\n\t\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tphba->link_flag |= LS_EXTERNAL_LOOPBACK;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS | LOG_LIBDFC,\n\t\t\t\t \"1119 External Loopback plug detected\\n\");\n\n\t\t \n\t\tlpfc_els_abort_flogi(phba);\n\t\treturn 0;\n\n\t} else if (rc > 0) {\t \n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_PT2PT_PLOGI;\n\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t \n\t\tvport->fc_myDID = PT2PT_LocalID;\n\t} else {\n\t\tvport->fc_myDID = PT2PT_RemoteID;\n\t}\n\n\t \n\tspin_lock_irq(shost->host_lock);\n\tfc_flag = vport->fc_flag;\n\tport_state = vport->port_state;\n\tvport->fc_flag |= FC_PT2PT;\n\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\n\t \n\tvport->rcv_flogi_cnt++;\n\tspin_unlock_irq(shost->host_lock);\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"3311 Rcv Flogi PS x%x new PS x%x \"\n\t\t\t \"fc_flag x%x new fc_flag x%x\\n\",\n\t\t\t port_state, vport->port_state,\n\t\t\t fc_flag, vport->fc_flag);\n\n\t \n\tdid = vport->fc_myDID;\n\tvport->fc_myDID = Fabric_DID;\n\n\tmemcpy(&phba->fc_fabparam, sp, sizeof(struct serv_parm));\n\n\t \n\tif (!(phba->hba_flag & HBA_FLOGI_ISSUED)) {\n\t\tphba->defer_flogi_acc_rx_id = bf_get(wqe_ctxt_tag,\n\t\t\t\t\t\t     &wqe->xmit_els_rsp.wqe_com);\n\t\tphba->defer_flogi_acc_ox_id = bf_get(wqe_rcvoxid,\n\t\t\t\t\t\t     &wqe->xmit_els_rsp.wqe_com);\n\n\t\tvport->fc_myDID = did;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"3344 Deferring FLOGI ACC: rx_id: x%x,\"\n\t\t\t\t \" ox_id: x%x, hba_flag x%x\\n\",\n\t\t\t\t phba->defer_flogi_acc_rx_id,\n\t\t\t\t phba->defer_flogi_acc_ox_id, phba->hba_flag);\n\n\t\tphba->defer_flogi_acc_flag = true;\n\n\t\treturn 0;\n\t}\n\n\t \n\tlpfc_els_rsp_acc(vport, ELS_CMD_FLOGI, cmdiocb, ndlp, NULL);\n\n\t \n\tvport->fc_myDID = did;\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_rnid(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp;\n\tRNID *rn;\n\tstruct ls_rjt stat;\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tlp = (uint32_t *) pcmd->virt;\n\n\tlp++;\n\trn = (RNID *) lp;\n\n\t \n\n\tswitch (rn->Format) {\n\tcase 0:\n\tcase RNID_TOPOLOGY_DISC:\n\t\t \n\t\tlpfc_els_rsp_rnid_acc(vport, rn->Format, cmdiocb, ndlp);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tstat.un.b.lsRjtRsvd0 = 0;\n\t\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\t\tstat.un.b.vendorUnique = 0;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\n\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_echo(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tuint8_t *pcmd;\n\n\tpcmd = (uint8_t *)cmdiocb->cmd_dmabuf->virt;\n\n\t \n\tpcmd += sizeof(uint32_t);\n\n\tlpfc_els_rsp_echo_acc(vport, pcmd, cmdiocb, ndlp);\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_lirr(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tstruct ls_rjt stat;\n\n\t \n\tstat.un.b.lsRjtRsvd0 = 0;\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\tstat.un.b.vendorUnique = 0;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 0;\n}\n\n \nstatic void\nlpfc_els_rcv_rrq(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\tif (vport->phba->sli_rev == LPFC_SLI_REV4)\n\t\tlpfc_els_clear_rrq(vport, cmdiocb, ndlp);\n}\n\n \nstatic void\nlpfc_els_rsp_rls_acc(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tint rc = 0;\n\tMAILBOX_t *mb;\n\tIOCB_t *icmd;\n\tunion lpfc_wqe128 *wqe;\n\tstruct RLS_RSP *rls_rsp;\n\tuint8_t *pcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct lpfc_nodelist *ndlp;\n\tuint16_t oxid;\n\tuint16_t rxid;\n\tuint32_t cmdsize;\n\tu32 ulp_context;\n\n\tmb = &pmb->u.mb;\n\n\tndlp = pmb->ctx_ndlp;\n\trxid = (uint16_t)((unsigned long)(pmb->ctx_buf) & 0xffff);\n\toxid = (uint16_t)(((unsigned long)(pmb->ctx_buf) >> 16) & 0xffff);\n\tpmb->ctx_buf = NULL;\n\tpmb->ctx_ndlp = NULL;\n\n\tif (mb->mbxStatus) {\n\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\n\tcmdsize = sizeof(struct RLS_RSP) + sizeof(uint32_t);\n\telsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\n\t\t\t\t     lpfc_max_els_tries, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\n\t \n\tlpfc_nlp_put(ndlp);\n\n\tif (!elsiocb) {\n\t\tmempool_free(pmb, phba->mbox_mem_pool);\n\t\treturn;\n\t}\n\n\tulp_context = get_job_ulpcontext(phba, elsiocb);\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\t \n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com, rxid);\n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com, oxid);\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = rxid;\n\t\ticmd->unsli3.rcvsli3.ox_id = oxid;\n\t}\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t);  \n\trls_rsp = (struct RLS_RSP *)pcmd;\n\n\trls_rsp->linkFailureCnt = cpu_to_be32(mb->un.varRdLnk.linkFailureCnt);\n\trls_rsp->lossSyncCnt = cpu_to_be32(mb->un.varRdLnk.lossSyncCnt);\n\trls_rsp->lossSignalCnt = cpu_to_be32(mb->un.varRdLnk.lossSignalCnt);\n\trls_rsp->primSeqErrCnt = cpu_to_be32(mb->un.varRdLnk.primSeqErrCnt);\n\trls_rsp->invalidXmitWord = cpu_to_be32(mb->un.varRdLnk.invalidXmitWord);\n\trls_rsp->crcCnt = cpu_to_be32(mb->un.varRdLnk.crcCnt);\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\t \n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2874 Xmit ELS RLS ACC response tag x%x xri x%x, \"\n\t\t\t \"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x\\n\",\n\t\t\t elsiocb->iotag, ulp_context,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t}\n\treturn;\n}\n\n \nstatic int\nlpfc_els_rcv_rls(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tLPFC_MBOXQ_t *mbox;\n\tstruct ls_rjt stat;\n\tu32 ctx = get_job_ulpcontext(phba, cmdiocb);\n\tu32 ox_id = get_job_rcvoxid(phba, cmdiocb);\n\n\tif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\n\t    (ndlp->nlp_state != NLP_STE_MAPPED_NODE))\n\t\t \n\t\tgoto reject_out;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_ATOMIC);\n\tif (mbox) {\n\t\tlpfc_read_lnk_stat(phba, mbox);\n\t\tmbox->ctx_buf = (void *)((unsigned long)\n\t\t\t\t\t (ox_id << 16 | ctx));\n\t\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\t\tif (!mbox->ctx_ndlp)\n\t\t\tgoto node_err;\n\t\tmbox->vport = vport;\n\t\tmbox->mbox_cmpl = lpfc_els_rsp_rls_acc;\n\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\n\t\t\t!= MBX_NOT_FINISHED)\n\t\t\t \n\t\t\treturn 0;\n\t\t \n\t\tlpfc_nlp_put(ndlp);\nnode_err:\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t}\nreject_out:\n\t \n\tstat.un.b.lsRjtRsvd0 = 0;\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\tstat.un.b.vendorUnique = 0;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_rtv(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tint rc = 0;\n\tIOCB_t *icmd;\n\tunion lpfc_wqe128 *wqe;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct ls_rjt stat;\n\tstruct RTV_RSP *rtv_rsp;\n\tuint8_t *pcmd;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint32_t cmdsize;\n\tu32 ulp_context;\n\n\tif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\n\t    (ndlp->nlp_state != NLP_STE_MAPPED_NODE))\n\t\t \n\t\tgoto reject_out;\n\n\tcmdsize = sizeof(struct RTV_RSP) + sizeof(uint32_t);\n\telsiocb = lpfc_prep_els_iocb(phba->pport, 0, cmdsize,\n\t\t\t\t     lpfc_max_els_tries, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint32_t);  \n\n\tulp_context = get_job_ulpcontext(phba, elsiocb);\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t\t       get_job_ulpcontext(phba, cmdiocb));\n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       get_job_rcvoxid(phba, cmdiocb));\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = get_job_ulpcontext(phba, cmdiocb);\n\t\ticmd->unsli3.rcvsli3.ox_id = get_job_rcvoxid(phba, cmdiocb);\n\t}\n\n\trtv_rsp = (struct RTV_RSP *)pcmd;\n\n\t \n\trtv_rsp->ratov = cpu_to_be32(phba->fc_ratov * 1000);  \n\trtv_rsp->edtov = cpu_to_be32(phba->fc_edtov);\n\tbf_set(qtov_edtovres, rtv_rsp, phba->fc_edtovResol ? 1 : 0);\n\tbf_set(qtov_rttov, rtv_rsp, 0);  \n\trtv_rsp->qtov = cpu_to_be32(rtv_rsp->qtov);\n\n\t \n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2875 Xmit ELS RTV ACC response tag x%x xri x%x, \"\n\t\t\t \"did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x, \"\n\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t elsiocb->iotag, ulp_context,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi,\n\t\t\trtv_rsp->ratov, rtv_rsp->edtov, rtv_rsp->qtov);\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 0;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t}\n\treturn 0;\n\nreject_out:\n\t \n\tstat.un.b.lsRjtRsvd0 = 0;\n\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\tstat.un.b.vendorUnique = 0;\n\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp, NULL);\n\treturn 0;\n}\n\n \nstatic int\nlpfc_issue_els_rrq(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\tuint32_t did, struct lpfc_node_rrq *rrq)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct RRQ *els_rrq;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint ret;\n\n\tif (!ndlp)\n\t\treturn 1;\n\n\t \n\tcmdsize = (sizeof(uint32_t) + sizeof(struct RRQ));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp, did,\n\t\t\t\t     ELS_CMD_RRQ);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\n\t \n\t*((uint32_t *) (pcmd)) = ELS_CMD_RRQ;\n\tpcmd += sizeof(uint32_t);\n\tels_rrq = (struct RRQ *) pcmd;\n\n\tbf_set(rrq_oxid, els_rrq, phba->sli4_hba.xri_ids[rrq->xritag]);\n\tbf_set(rrq_rxid, els_rrq, rrq->rxid);\n\tbf_set(rrq_did, els_rrq, vport->fc_myDID);\n\tels_rrq->rrq = cpu_to_be32(els_rrq->rrq);\n\tels_rrq->rrq_exchg = cpu_to_be32(els_rrq->rrq_exchg);\n\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue RRQ:     did:x%x\",\n\t\tdid, rrq->xritag, rrq->rxid);\n\telsiocb->context_un.rrq = rrq;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rrq;\n\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp)\n\t\tgoto io_err;\n\n\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (ret == IOCB_ERROR) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto io_err;\n\t}\n\treturn 0;\n\n io_err:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\treturn 1;\n}\n\n \nint\nlpfc_send_rrq(struct lpfc_hba *phba, struct lpfc_node_rrq *rrq)\n{\n\tstruct lpfc_nodelist *ndlp = lpfc_findnode_did(rrq->vport,\n\t\t\t\t\t\t       rrq->nlp_DID);\n\tif (!ndlp)\n\t\treturn 1;\n\n\tif (lpfc_test_rrq_active(phba, ndlp, rrq->xritag))\n\t\treturn lpfc_issue_els_rrq(rrq->vport, ndlp,\n\t\t\t\t\t rrq->nlp_DID, rrq);\n\telse\n\t\treturn 1;\n}\n\n \nstatic int\nlpfc_els_rsp_rpl_acc(struct lpfc_vport *vport, uint16_t cmdsize,\n\t\t     struct lpfc_iocbq *oldiocb, struct lpfc_nodelist *ndlp)\n{\n\tint rc = 0;\n\tstruct lpfc_hba *phba = vport->phba;\n\tIOCB_t *icmd;\n\tunion lpfc_wqe128 *wqe;\n\tRPL_RSP rpl_rsp;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tu32 ulp_context;\n\n\telsiocb = lpfc_prep_els_iocb(vport, 0, cmdsize, oldiocb->retry, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_ACC);\n\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tulp_context = get_job_ulpcontext(phba, elsiocb);\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\t \n\t\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t\t       get_job_ulpcontext(phba, oldiocb));\n\t\tbf_set(wqe_rcvoxid, &wqe->xmit_els_rsp.wqe_com,\n\t\t       get_job_rcvoxid(phba, oldiocb));\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->ulpContext = get_job_ulpcontext(phba, oldiocb);\n\t\ticmd->unsli3.rcvsli3.ox_id = get_job_rcvoxid(phba, oldiocb);\n\t}\n\n\tpcmd = elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *) (pcmd)) = ELS_CMD_ACC;\n\tpcmd += sizeof(uint16_t);\n\t*((uint16_t *)(pcmd)) = be16_to_cpu(cmdsize);\n\tpcmd += sizeof(uint16_t);\n\n\t \n\trpl_rsp.listLen = be32_to_cpu(1);\n\trpl_rsp.index = 0;\n\trpl_rsp.port_num_blk.portNum = 0;\n\trpl_rsp.port_num_blk.portID = be32_to_cpu(vport->fc_myDID);\n\tmemcpy(&rpl_rsp.port_num_blk.portName, &vport->fc_portname,\n\t    sizeof(struct lpfc_name));\n\tmemcpy(pcmd, &rpl_rsp, cmdsize - sizeof(uint32_t));\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0120 Xmit ELS RPL ACC response tag x%x \"\n\t\t\t \"xri x%x, did x%x, nlp_flag x%x, nlp_state x%x, \"\n\t\t\t \"rpi x%x\\n\",\n\t\t\t elsiocb->iotag, ulp_context,\n\t\t\t ndlp->nlp_DID, ndlp->nlp_flag, ndlp->nlp_state,\n\t\t\t ndlp->nlp_rpi);\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_rsp;\n\tphba->fc_stat.elsXmitACC++;\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\treturn 1;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_rpl(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp;\n\tuint32_t maxsize;\n\tuint16_t cmdsize;\n\tRPL *rpl;\n\tstruct ls_rjt stat;\n\n\tif ((ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) &&\n\t    (ndlp->nlp_state != NLP_STE_MAPPED_NODE)) {\n\t\t \n\t\tstat.un.b.lsRjtRsvd0 = 0;\n\t\tstat.un.b.lsRjtRsnCode = LSRJT_UNABLE_TPC;\n\t\tstat.un.b.lsRjtRsnCodeExp = LSEXP_CANT_GIVE_DATA;\n\t\tstat.un.b.vendorUnique = 0;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, cmdiocb, ndlp,\n\t\t\tNULL);\n\t\t \n\t\treturn 0;\n\t}\n\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tlp = (uint32_t *) pcmd->virt;\n\trpl = (RPL *) (lp + 1);\n\tmaxsize = be32_to_cpu(rpl->maxsize);\n\n\t \n\tif ((rpl->index == 0) &&\n\t    ((maxsize == 0) ||\n\t     ((maxsize * sizeof(uint32_t)) >= sizeof(RPL_RSP)))) {\n\t\tcmdsize = sizeof(uint32_t) + sizeof(RPL_RSP);\n\t} else {\n\t\tcmdsize = sizeof(uint32_t) + maxsize * sizeof(uint32_t);\n\t}\n\tlpfc_els_rsp_rpl_acc(vport, cmdsize, cmdiocb, ndlp);\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_farp(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t  struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t *lp;\n\tFARP *fp;\n\tuint32_t cnt, did;\n\n\tdid = get_job_els_rsp64_did(vport->phba, cmdiocb);\n\tpcmd = cmdiocb->cmd_dmabuf;\n\tlp = (uint32_t *) pcmd->virt;\n\n\tlp++;\n\tfp = (FARP *) lp;\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0601 FARP-REQ received from DID x%x\\n\", did);\n\t \n\tif (fp->Mflags & ~(FARP_MATCH_NODE | FARP_MATCH_PORT)) {\n\t\treturn 0;\n\t}\n\n\tcnt = 0;\n\t \n\tif (fp->Mflags & FARP_MATCH_PORT) {\n\t\tif (memcmp(&fp->RportName, &vport->fc_portname,\n\t\t\t   sizeof(struct lpfc_name)) == 0)\n\t\t\tcnt = 1;\n\t}\n\n\t \n\tif (fp->Mflags & FARP_MATCH_NODE) {\n\t\tif (memcmp(&fp->RnodeName, &vport->fc_nodename,\n\t\t\t   sizeof(struct lpfc_name)) == 0)\n\t\t\tcnt = 1;\n\t}\n\n\tif (cnt) {\n\t\tif ((ndlp->nlp_state == NLP_STE_UNMAPPED_NODE) ||\n\t\t   (ndlp->nlp_state == NLP_STE_MAPPED_NODE)) {\n\t\t\t \n\t\t\tif (fp->Rflags & FARP_REQUEST_PLOGI) {\n\t\t\t\tndlp->nlp_prev_state = ndlp->nlp_state;\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t   NLP_STE_PLOGI_ISSUE);\n\t\t\t\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (fp->Rflags & FARP_REQUEST_FARPR)\n\t\t\t\tlpfc_issue_els_farpr(vport, did, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_farpr(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_nodelist  *ndlp)\n{\n\tuint32_t did;\n\n\tdid = get_job_els_rsp64_did(vport->phba, cmdiocb);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0600 FARP-RSP received from DID x%x\\n\", did);\n\t \n\tlpfc_els_rsp_acc(vport, ELS_CMD_ACC, cmdiocb, ndlp, NULL);\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_fan(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *fan_ndlp)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tuint32_t *lp;\n\tFAN *fp;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS, \"0265 FAN received\\n\");\n\tlp = (uint32_t *)cmdiocb->cmd_dmabuf->virt;\n\tfp = (FAN *) ++lp;\n\t \n\tif ((vport == phba->pport) &&\n\t    (vport->port_state == LPFC_LOCAL_CFG_LINK)) {\n\t\tif ((memcmp(&phba->fc_fabparam.nodeName, &fp->FnodeName,\n\t\t\t    sizeof(struct lpfc_name))) ||\n\t\t    (memcmp(&phba->fc_fabparam.portName, &fp->FportName,\n\t\t\t    sizeof(struct lpfc_name)))) {\n\t\t\t \n\t\t\tlpfc_issue_init_vfi(vport);\n\t\t} else {\n\t\t\t \n\t\t\tvport->fc_myDID = vport->fc_prevDID;\n\t\t\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\t\t\tlpfc_issue_fabric_reglogin(vport);\n\t\t\telse {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t\t\"3138 Need register VFI: (x%x/%x)\\n\",\n\t\t\t\t\tvport->fc_prevDID, vport->fc_myDID);\n\t\t\t\tlpfc_issue_reg_vfi(vport);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nlpfc_els_rcv_edc(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb,\n\t\t struct lpfc_nodelist *ndlp)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct fc_els_edc *edc_req;\n\tstruct fc_tlv_desc *tlv;\n\tuint8_t *payload;\n\tuint32_t *ptr, dtag;\n\tconst char *dtag_nm;\n\tint desc_cnt = 0, bytes_remain;\n\tstruct fc_diag_lnkflt_desc *plnkflt;\n\n\tpayload = cmdiocb->cmd_dmabuf->virt;\n\n\tedc_req = (struct fc_els_edc *)payload;\n\tbytes_remain = be32_to_cpu(edc_req->desc_len);\n\n\tptr = (uint32_t *)payload;\n\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t LOG_ELS | LOG_CGN_MGMT | LOG_LDS_EVENT,\n\t\t\t \"3319 Rcv EDC payload len %d: x%x x%x x%x\\n\",\n\t\t\t bytes_remain, be32_to_cpu(*ptr),\n\t\t\t be32_to_cpu(*(ptr + 1)), be32_to_cpu(*(ptr + 2)));\n\n\t \n\tphba->cgn_reg_signal = EDC_CG_SIG_NOTSUPPORTED;\n\tphba->cgn_sig_freq = 0;\n\tphba->cgn_reg_fpin = LPFC_CGN_FPIN_ALARM | LPFC_CGN_FPIN_WARN;\n\n\tif (bytes_remain <= 0)\n\t\tgoto out;\n\n\ttlv = edc_req->desc;\n\n\t \n\twhile (bytes_remain) {\n\t\tif (bytes_remain < FC_TLV_DESC_HDR_SZ) {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING,\n\t\t\t\t\tLOG_ELS | LOG_CGN_MGMT | LOG_LDS_EVENT,\n\t\t\t\t\t\"6464 Truncated TLV hdr on \"\n\t\t\t\t\t\"Diagnostic descriptor[%d]\\n\",\n\t\t\t\t\tdesc_cnt);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdtag = be32_to_cpu(tlv->desc_tag);\n\t\tswitch (dtag) {\n\t\tcase ELS_DTAG_LNK_FAULT_CAP:\n\t\t\tif (bytes_remain < FC_TLV_DESC_SZ_FROM_LENGTH(tlv) ||\n\t\t\t    FC_TLV_DESC_SZ_FROM_LENGTH(tlv) !=\n\t\t\t\tsizeof(struct fc_diag_lnkflt_desc)) {\n\t\t\t\tlpfc_printf_log(phba, KERN_WARNING,\n\t\t\t\t\tLOG_ELS | LOG_CGN_MGMT | LOG_LDS_EVENT,\n\t\t\t\t\t\"6465 Truncated Link Fault Diagnostic \"\n\t\t\t\t\t\"descriptor[%d]: %d vs 0x%zx 0x%zx\\n\",\n\t\t\t\t\tdesc_cnt, bytes_remain,\n\t\t\t\t\tFC_TLV_DESC_SZ_FROM_LENGTH(tlv),\n\t\t\t\t\tsizeof(struct fc_diag_lnkflt_desc));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tplnkflt = (struct fc_diag_lnkflt_desc *)tlv;\n\t\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\tLOG_ELS | LOG_LDS_EVENT,\n\t\t\t\t\"4626 Link Fault Desc Data: x%08x len x%x \"\n\t\t\t\t\"da x%x dd x%x interval x%x\\n\",\n\t\t\t\tbe32_to_cpu(plnkflt->desc_tag),\n\t\t\t\tbe32_to_cpu(plnkflt->desc_len),\n\t\t\t\tbe32_to_cpu(\n\t\t\t\t\tplnkflt->degrade_activate_threshold),\n\t\t\t\tbe32_to_cpu(\n\t\t\t\t\tplnkflt->degrade_deactivate_threshold),\n\t\t\t\tbe32_to_cpu(plnkflt->fec_degrade_interval));\n\t\t\tbreak;\n\t\tcase ELS_DTAG_CG_SIGNAL_CAP:\n\t\t\tif (bytes_remain < FC_TLV_DESC_SZ_FROM_LENGTH(tlv) ||\n\t\t\t    FC_TLV_DESC_SZ_FROM_LENGTH(tlv) !=\n\t\t\t\tsizeof(struct fc_diag_cg_sig_desc)) {\n\t\t\t\tlpfc_printf_log(\n\t\t\t\t\tphba, KERN_WARNING, LOG_CGN_MGMT,\n\t\t\t\t\t\"6466 Truncated cgn signal Diagnostic \"\n\t\t\t\t\t\"descriptor[%d]: %d vs 0x%zx 0x%zx\\n\",\n\t\t\t\t\tdesc_cnt, bytes_remain,\n\t\t\t\t\tFC_TLV_DESC_SZ_FROM_LENGTH(tlv),\n\t\t\t\t\tsizeof(struct fc_diag_cg_sig_desc));\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tphba->cgn_reg_fpin = phba->cgn_init_reg_fpin;\n\t\t\tphba->cgn_reg_signal = phba->cgn_init_reg_signal;\n\n\t\t\t \n\t\t\tphba->cgn_sig_freq = lpfc_fabric_cgn_frequency;\n\n\t\t\tlpfc_least_capable_settings(\n\t\t\t\tphba, (struct fc_diag_cg_sig_desc *)tlv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdtag_nm = lpfc_get_tlv_dtag_nm(dtag);\n\t\t\tlpfc_printf_log(phba, KERN_WARNING,\n\t\t\t\t\tLOG_ELS | LOG_CGN_MGMT | LOG_LDS_EVENT,\n\t\t\t\t\t\"6467 unknown Diagnostic \"\n\t\t\t\t\t\"Descriptor[%d]: tag x%x (%s)\\n\",\n\t\t\t\t\tdesc_cnt, dtag, dtag_nm);\n\t\t}\n\t\tbytes_remain -= FC_TLV_DESC_SZ_FROM_LENGTH(tlv);\n\t\ttlv = fc_tlv_next_desc(tlv);\n\t\tdesc_cnt++;\n\t}\nout:\n\t \n\tlpfc_issue_els_edc_rsp(vport, cmdiocb, ndlp);\n\n\tlpfc_config_cgn_signal(phba);\n\treturn 0;\n}\n\n \nvoid\nlpfc_els_timeout(struct timer_list *t)\n{\n\tstruct lpfc_vport *vport = from_timer(vport, t, els_tmofunc);\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t tmo_posted;\n\tunsigned long iflag;\n\n\tspin_lock_irqsave(&vport->work_port_lock, iflag);\n\ttmo_posted = vport->work_port_events & WORKER_ELS_TMO;\n\tif ((!tmo_posted) && (!(vport->load_flag & FC_UNLOADING)))\n\t\tvport->work_port_events |= WORKER_ELS_TMO;\n\tspin_unlock_irqrestore(&vport->work_port_lock, iflag);\n\n\tif ((!tmo_posted) && (!(vport->load_flag & FC_UNLOADING)))\n\t\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n\n \nvoid\nlpfc_els_timeout_handler(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *tmp_iocb, *piocb;\n\tIOCB_t *cmd = NULL;\n\tstruct lpfc_dmabuf *pcmd;\n\tuint32_t els_command = 0;\n\tuint32_t timeout;\n\tuint32_t remote_ID = 0xffffffff;\n\tLIST_HEAD(abort_list);\n\tu32 ulp_command = 0, ulp_context = 0, did = 0, iotag = 0;\n\n\n\ttimeout = (uint32_t)(phba->fc_ratov << 1);\n\n\tpring = lpfc_phba_elsring(phba);\n\tif (unlikely(!pring))\n\t\treturn;\n\n\tif (phba->pport->load_flag & FC_UNLOADING)\n\t\treturn;\n\n\tspin_lock_irq(&phba->hbalock);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_lock(&pring->ring_lock);\n\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txcmplq, list) {\n\t\tulp_command = get_job_cmnd(phba, piocb);\n\t\tulp_context = get_job_ulpcontext(phba, piocb);\n\t\tdid = get_job_els_rsp64_did(phba, piocb);\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tiotag = get_wqe_reqtag(piocb);\n\t\t} else {\n\t\t\tcmd = &piocb->iocb;\n\t\t\tiotag = cmd->ulpIoTag;\n\t\t}\n\n\t\tif ((piocb->cmd_flag & LPFC_IO_LIBDFC) != 0 ||\n\t\t    ulp_command == CMD_ABORT_XRI_CX ||\n\t\t    ulp_command == CMD_ABORT_XRI_CN ||\n\t\t    ulp_command == CMD_CLOSE_XRI_CN)\n\t\t\tcontinue;\n\n\t\tif (piocb->vport != vport)\n\t\t\tcontinue;\n\n\t\tpcmd = piocb->cmd_dmabuf;\n\t\tif (pcmd)\n\t\t\tels_command = *(uint32_t *) (pcmd->virt);\n\n\t\tif (els_command == ELS_CMD_FARP ||\n\t\t    els_command == ELS_CMD_FARPR ||\n\t\t    els_command == ELS_CMD_FDISC)\n\t\t\tcontinue;\n\n\t\tif (piocb->drvrTimeout > 0) {\n\t\t\tif (piocb->drvrTimeout >= timeout)\n\t\t\t\tpiocb->drvrTimeout -= timeout;\n\t\t\telse\n\t\t\t\tpiocb->drvrTimeout = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tremote_ID = 0xffffffff;\n\t\tif (ulp_command != CMD_GEN_REQUEST64_CR) {\n\t\t\tremote_ID = did;\n\t\t} else {\n\t\t\tstruct lpfc_nodelist *ndlp;\n\t\t\tndlp = __lpfc_findnode_rpi(vport, ulp_context);\n\t\t\tif (ndlp)\n\t\t\t\tremote_ID = ndlp->nlp_DID;\n\t\t}\n\t\tlist_add_tail(&piocb->dlist, &abort_list);\n\t}\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring->ring_lock);\n\tspin_unlock_irq(&phba->hbalock);\n\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &abort_list, dlist) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0127 ELS timeout Data: x%x x%x x%x \"\n\t\t\t \"x%x\\n\", els_command,\n\t\t\t remote_ID, ulp_command, iotag);\n\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tlist_del_init(&piocb->dlist);\n\t\tlpfc_sli_issue_abort_iotag(phba, pring, piocb, NULL);\n\t\tspin_unlock_irq(&phba->hbalock);\n\t}\n\n\t \n\tlpfc_issue_hb_tmo(phba);\n\n\tif (!list_empty(&pring->txcmplq))\n\t\tif (!(phba->pport->load_flag & FC_UNLOADING))\n\t\t\tmod_timer(&vport->els_tmofunc,\n\t\t\t\t  jiffies + msecs_to_jiffies(1000 * timeout));\n}\n\n \nvoid\nlpfc_els_flush_cmd(struct lpfc_vport *vport)\n{\n\tLIST_HEAD(abort_list);\n\tLIST_HEAD(cancel_list);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *tmp_iocb, *piocb;\n\tu32 ulp_command;\n\tunsigned long iflags = 0;\n\tbool mbx_tmo_err;\n\n\tlpfc_fabric_abort_vport(vport);\n\n\t \n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\tpring = lpfc_phba_elsring(phba);\n\n\t \n\tif (unlikely(!pring)) {\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t\treturn;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_lock(&pring->ring_lock);\n\n\tmbx_tmo_err = test_bit(MBX_TMO_ERR, &phba->bit_flags);\n\t \n\tlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txcmplq, list) {\n\t\tif (piocb->cmd_flag & LPFC_IO_LIBDFC && !mbx_tmo_err)\n\t\t\tcontinue;\n\n\t\tif (piocb->vport != vport)\n\t\t\tcontinue;\n\n\t\tif (piocb->cmd_flag & LPFC_DRIVER_ABORTED && !mbx_tmo_err)\n\t\t\tcontinue;\n\n\t\t \n\t\tulp_command = get_job_cmnd(phba, piocb);\n\t\tif (ulp_command == CMD_ELS_REQUEST64_CR) {\n\t\t\tlist_add_tail(&piocb->dlist, &abort_list);\n\n\t\t\t \n\t\t\tif (phba->link_state == LPFC_LINK_DOWN)\n\t\t\t\tpiocb->cmd_cmpl = lpfc_cmpl_els_link_down;\n\t\t} else if (ulp_command == CMD_GEN_REQUEST64_CR ||\n\t\t\t   mbx_tmo_err)\n\t\t\tlist_add_tail(&piocb->dlist, &abort_list);\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring->ring_lock);\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\n\t \n\tlist_for_each_entry_safe(piocb, tmp_iocb, &abort_list, dlist) {\n\t\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t\tlist_del_init(&piocb->dlist);\n\t\tif (mbx_tmo_err)\n\t\t\tlist_move_tail(&piocb->list, &cancel_list);\n\t\telse\n\t\t\tlpfc_sli_issue_abort_iotag(phba, pring, piocb, NULL);\n\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t}\n\tif (!list_empty(&cancel_list))\n\t\tlpfc_sli_cancel_iocbs(phba, &cancel_list, IOSTAT_LOCAL_REJECT,\n\t\t\t\t      IOERR_SLI_ABORTED);\n\telse\n\t\t \n\t\tlpfc_issue_hb_tmo(phba);\n\n\tif (!list_empty(&abort_list))\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"3387 abort list for txq not empty\\n\");\n\tINIT_LIST_HEAD(&abort_list);\n\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_lock(&pring->ring_lock);\n\n\t \n\tlist_for_each_entry_safe(piocb, tmp_iocb, &pring->txq, list) {\n\t\tulp_command = get_job_cmnd(phba, piocb);\n\n\t\tif (piocb->cmd_flag & LPFC_IO_LIBDFC)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ulp_command == CMD_QUE_RING_BUF_CN ||\n\t\t    ulp_command == CMD_QUE_RING_BUF64_CN ||\n\t\t    ulp_command == CMD_CLOSE_XRI_CN ||\n\t\t    ulp_command == CMD_ABORT_XRI_CN ||\n\t\t    ulp_command == CMD_ABORT_XRI_CX)\n\t\t\tcontinue;\n\n\t\tif (piocb->vport != vport)\n\t\t\tcontinue;\n\n\t\tlist_del_init(&piocb->list);\n\t\tlist_add_tail(&piocb->list, &abort_list);\n\t}\n\n\t \n\tif (vport == phba->pport) {\n\t\tlist_for_each_entry_safe(piocb, tmp_iocb,\n\t\t\t\t\t &phba->fabric_iocb_list, list) {\n\t\t\tlist_del_init(&piocb->list);\n\t\t\tlist_add_tail(&piocb->list, &abort_list);\n\t\t}\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring->ring_lock);\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\n\t \n\tlpfc_sli_cancel_iocbs(phba, &abort_list,\n\t\t\t      IOSTAT_LOCAL_REJECT, IOERR_SLI_ABORTED);\n\n\treturn;\n}\n\n \nvoid\nlpfc_els_flush_all_cmd(struct lpfc_hba  *phba)\n{\n\tstruct lpfc_vport *vport;\n\n\tspin_lock_irq(&phba->port_list_lock);\n\tlist_for_each_entry(vport, &phba->port_list, listentry)\n\t\tlpfc_els_flush_cmd(vport);\n\tspin_unlock_irq(&phba->port_list_lock);\n\n\treturn;\n}\n\n \nvoid\nlpfc_send_els_failure_event(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_iocbq *cmdiocbp,\n\t\t\tstruct lpfc_iocbq *rspiocbp)\n{\n\tstruct lpfc_vport *vport = cmdiocbp->vport;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_lsrjt_event lsrjt_event;\n\tstruct lpfc_fabric_event_header fabric_event;\n\tstruct ls_rjt stat;\n\tstruct lpfc_nodelist *ndlp;\n\tuint32_t *pcmd;\n\tu32 ulp_status, ulp_word4;\n\n\tndlp = cmdiocbp->ndlp;\n\tif (!ndlp)\n\t\treturn;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocbp);\n\tulp_word4 = get_job_word4(phba, rspiocbp);\n\n\tif (ulp_status == IOSTAT_LS_RJT) {\n\t\tlsrjt_event.header.event_type = FC_REG_ELS_EVENT;\n\t\tlsrjt_event.header.subcategory = LPFC_EVENT_LSRJT_RCV;\n\t\tmemcpy(lsrjt_event.header.wwpn, &ndlp->nlp_portname,\n\t\t\tsizeof(struct lpfc_name));\n\t\tmemcpy(lsrjt_event.header.wwnn, &ndlp->nlp_nodename,\n\t\t\tsizeof(struct lpfc_name));\n\t\tpcmd = (uint32_t *)cmdiocbp->cmd_dmabuf->virt;\n\t\tlsrjt_event.command = (pcmd != NULL) ? *pcmd : 0;\n\t\tstat.un.ls_rjt_error_be = cpu_to_be32(ulp_word4);\n\t\tlsrjt_event.reason_code = stat.un.b.lsRjtRsnCode;\n\t\tlsrjt_event.explanation = stat.un.b.lsRjtRsnCodeExp;\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tsizeof(lsrjt_event),\n\t\t\t(char *)&lsrjt_event,\n\t\t\tLPFC_NL_VENDOR_ID);\n\t\treturn;\n\t}\n\tif (ulp_status == IOSTAT_NPORT_BSY ||\n\t    ulp_status == IOSTAT_FABRIC_BSY) {\n\t\tfabric_event.event_type = FC_REG_FABRIC_EVENT;\n\t\tif (ulp_status == IOSTAT_NPORT_BSY)\n\t\t\tfabric_event.subcategory = LPFC_EVENT_PORT_BUSY;\n\t\telse\n\t\t\tfabric_event.subcategory = LPFC_EVENT_FABRIC_BUSY;\n\t\tmemcpy(fabric_event.wwpn, &ndlp->nlp_portname,\n\t\t\tsizeof(struct lpfc_name));\n\t\tmemcpy(fabric_event.wwnn, &ndlp->nlp_nodename,\n\t\t\tsizeof(struct lpfc_name));\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tsizeof(fabric_event),\n\t\t\t(char *)&fabric_event,\n\t\t\tLPFC_NL_VENDOR_ID);\n\t\treturn;\n\t}\n\n}\n\n \nstatic void\nlpfc_send_els_event(struct lpfc_vport *vport,\n\t\t    struct lpfc_nodelist *ndlp,\n\t\t    uint32_t *payload)\n{\n\tstruct lpfc_els_event_header *els_data = NULL;\n\tstruct lpfc_logo_event *logo_data = NULL;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tif (*payload == ELS_CMD_LOGO) {\n\t\tlogo_data = kmalloc(sizeof(struct lpfc_logo_event), GFP_KERNEL);\n\t\tif (!logo_data) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0148 Failed to allocate memory \"\n\t\t\t\t\"for LOGO event\\n\");\n\t\t\treturn;\n\t\t}\n\t\tels_data = &logo_data->header;\n\t} else {\n\t\tels_data = kmalloc(sizeof(struct lpfc_els_event_header),\n\t\t\tGFP_KERNEL);\n\t\tif (!els_data) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0149 Failed to allocate memory \"\n\t\t\t\t\"for ELS event\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tels_data->event_type = FC_REG_ELS_EVENT;\n\tswitch (*payload) {\n\tcase ELS_CMD_PLOGI:\n\t\tels_data->subcategory = LPFC_EVENT_PLOGI_RCV;\n\t\tbreak;\n\tcase ELS_CMD_PRLO:\n\t\tels_data->subcategory = LPFC_EVENT_PRLO_RCV;\n\t\tbreak;\n\tcase ELS_CMD_ADISC:\n\t\tels_data->subcategory = LPFC_EVENT_ADISC_RCV;\n\t\tbreak;\n\tcase ELS_CMD_LOGO:\n\t\tels_data->subcategory = LPFC_EVENT_LOGO_RCV;\n\t\t \n\t\tmemcpy(logo_data->logo_wwpn, &payload[2],\n\t\t\tsizeof(struct lpfc_name));\n\t\tbreak;\n\tdefault:\n\t\tkfree(els_data);\n\t\treturn;\n\t}\n\tmemcpy(els_data->wwpn, &ndlp->nlp_portname, sizeof(struct lpfc_name));\n\tmemcpy(els_data->wwnn, &ndlp->nlp_nodename, sizeof(struct lpfc_name));\n\tif (*payload == ELS_CMD_LOGO) {\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tsizeof(struct lpfc_logo_event),\n\t\t\t(char *)logo_data,\n\t\t\tLPFC_NL_VENDOR_ID);\n\t\tkfree(logo_data);\n\t} else {\n\t\tfc_host_post_vendor_event(shost,\n\t\t\tfc_get_event_number(),\n\t\t\tsizeof(struct lpfc_els_event_header),\n\t\t\t(char *)els_data,\n\t\t\tLPFC_NL_VENDOR_ID);\n\t\tkfree(els_data);\n\t}\n\n\treturn;\n}\n\n\nDECLARE_ENUM2STR_LOOKUP(lpfc_get_fpin_li_event_nm, fc_fpin_li_event_types,\n\t\t\tFC_FPIN_LI_EVT_TYPES_INIT);\n\nDECLARE_ENUM2STR_LOOKUP(lpfc_get_fpin_deli_event_nm, fc_fpin_deli_event_types,\n\t\t\tFC_FPIN_DELI_EVT_TYPES_INIT);\n\nDECLARE_ENUM2STR_LOOKUP(lpfc_get_fpin_congn_event_nm, fc_fpin_congn_event_types,\n\t\t\tFC_FPIN_CONGN_EVT_TYPES_INIT);\n\nDECLARE_ENUM2STR_LOOKUP(lpfc_get_fpin_congn_severity_nm,\n\t\t\tfc_fpin_congn_severity_types,\n\t\t\tFC_FPIN_CONGN_SEVERITY_INIT);\n\n\n \nstatic void\nlpfc_display_fpin_wwpn(struct lpfc_hba *phba, __be64 *wwnlist, u32 cnt)\n{\n\tchar buf[LPFC_FPIN_WWPN_LINE_SZ];\n\t__be64 wwn;\n\tu64 wwpn;\n\tint i, len;\n\tint line = 0;\n\tint wcnt = 0;\n\tbool endit = false;\n\n\tlen = scnprintf(buf, LPFC_FPIN_WWPN_LINE_SZ, \"Accessible WWPNs:\");\n\tfor (i = 0; i < cnt; i++) {\n\t\t \n\t\tif (i == (cnt - 1))\n\t\t\tendit = true;\n\n\t\t \n\t\twwn = *wwnlist++;\n\t\twwpn = be64_to_cpu(wwn);\n\t\tlen += scnprintf(buf + len, LPFC_FPIN_WWPN_LINE_SZ - len,\n\t\t\t\t \" %016llx\", wwpn);\n\n\t\t \n\t\twcnt++;\n\t\tif (wcnt == LPFC_FPIN_WWPN_LINE_CNT || endit) {\n\t\t\tbuf[len] = 0;\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\t\t\"4686 %s\\n\", buf);\n\n\t\t\t \n\t\t\tif (endit)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tline++;\n\t\t\tif (line == LPFC_FPIN_WWPN_NUM_LINE) {\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\t\t\t\"4687 %d WWPNs Truncated\\n\",\n\t\t\t\t\t\tcnt - i - 1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\twcnt = 0;\n\t\t\tlen = scnprintf(buf, LPFC_FPIN_WWPN_LINE_SZ,\n\t\t\t\t\t\"Additional WWPNs:\");\n\t\t}\n\t}\n}\n\n \nstatic void\nlpfc_els_rcv_fpin_li(struct lpfc_hba *phba, struct fc_tlv_desc *tlv)\n{\n\tstruct fc_fn_li_desc *li = (struct fc_fn_li_desc *)tlv;\n\tconst char *li_evt_str;\n\tu32 li_evt, cnt;\n\n\tli_evt = be16_to_cpu(li->event_type);\n\tli_evt_str = lpfc_get_fpin_li_event_nm(li_evt);\n\tcnt = be32_to_cpu(li->pname_count);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\"4680 FPIN Link Integrity %s (x%x) \"\n\t\t\t\"Detecting PN x%016llx Attached PN x%016llx \"\n\t\t\t\"Duration %d mSecs Count %d Port Cnt %d\\n\",\n\t\t\tli_evt_str, li_evt,\n\t\t\tbe64_to_cpu(li->detecting_wwpn),\n\t\t\tbe64_to_cpu(li->attached_wwpn),\n\t\t\tbe32_to_cpu(li->event_threshold),\n\t\t\tbe32_to_cpu(li->event_count), cnt);\n\n\tlpfc_display_fpin_wwpn(phba, (__be64 *)&li->pname_list, cnt);\n}\n\n \nstatic void\nlpfc_els_rcv_fpin_del(struct lpfc_hba *phba, struct fc_tlv_desc *tlv)\n{\n\tstruct fc_fn_deli_desc *del = (struct fc_fn_deli_desc *)tlv;\n\tconst char *del_rsn_str;\n\tu32 del_rsn;\n\t__be32 *frame;\n\n\tdel_rsn = be16_to_cpu(del->deli_reason_code);\n\tdel_rsn_str = lpfc_get_fpin_deli_event_nm(del_rsn);\n\n\t \n\tframe = (__be32 *)(del + 1);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\"4681 FPIN Delivery %s (x%x) \"\n\t\t\t\"Detecting PN x%016llx Attached PN x%016llx \"\n\t\t\t\"DiscHdr0  x%08x \"\n\t\t\t\"DiscHdr1 x%08x DiscHdr2 x%08x DiscHdr3 x%08x \"\n\t\t\t\"DiscHdr4 x%08x DiscHdr5 x%08x\\n\",\n\t\t\tdel_rsn_str, del_rsn,\n\t\t\tbe64_to_cpu(del->detecting_wwpn),\n\t\t\tbe64_to_cpu(del->attached_wwpn),\n\t\t\tbe32_to_cpu(frame[0]),\n\t\t\tbe32_to_cpu(frame[1]),\n\t\t\tbe32_to_cpu(frame[2]),\n\t\t\tbe32_to_cpu(frame[3]),\n\t\t\tbe32_to_cpu(frame[4]),\n\t\t\tbe32_to_cpu(frame[5]));\n}\n\n \nstatic void\nlpfc_els_rcv_fpin_peer_cgn(struct lpfc_hba *phba, struct fc_tlv_desc *tlv)\n{\n\tstruct fc_fn_peer_congn_desc *pc = (struct fc_fn_peer_congn_desc *)tlv;\n\tconst char *pc_evt_str;\n\tu32 pc_evt, cnt;\n\n\tpc_evt = be16_to_cpu(pc->event_type);\n\tpc_evt_str = lpfc_get_fpin_congn_event_nm(pc_evt);\n\tcnt = be32_to_cpu(pc->pname_count);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_CGN_MGMT | LOG_ELS,\n\t\t\t\"4684 FPIN Peer Congestion %s (x%x) \"\n\t\t\t\"Duration %d mSecs \"\n\t\t\t\"Detecting PN x%016llx Attached PN x%016llx \"\n\t\t\t\"Impacted Port Cnt %d\\n\",\n\t\t\tpc_evt_str, pc_evt,\n\t\t\tbe32_to_cpu(pc->event_period),\n\t\t\tbe64_to_cpu(pc->detecting_wwpn),\n\t\t\tbe64_to_cpu(pc->attached_wwpn),\n\t\t\tcnt);\n\n\tlpfc_display_fpin_wwpn(phba, (__be64 *)&pc->pname_list, cnt);\n}\n\n \nstatic int\nlpfc_els_rcv_fpin_cgn(struct lpfc_hba *phba, struct fc_tlv_desc *tlv)\n{\n\tstruct lpfc_cgn_info *cp;\n\tstruct fc_fn_congn_desc *cgn = (struct fc_fn_congn_desc *)tlv;\n\tconst char *cgn_evt_str;\n\tu32 cgn_evt;\n\tconst char *cgn_sev_str;\n\tu32 cgn_sev;\n\tuint16_t value;\n\tu32 crc;\n\tbool nm_log = false;\n\tint rc = 1;\n\n\tcgn_evt = be16_to_cpu(cgn->event_type);\n\tcgn_evt_str = lpfc_get_fpin_congn_event_nm(cgn_evt);\n\tcgn_sev = cgn->severity;\n\tcgn_sev_str = lpfc_get_fpin_congn_severity_nm(cgn_sev);\n\n\t \n\tswitch (cgn_evt) {\n\tcase FPIN_CONGN_LOST_CREDIT:\n\t\tnm_log = true;\n\t\tbreak;\n\tcase FPIN_CONGN_CREDIT_STALL:\n\t\tnm_log = true;\n\t\tfallthrough;\n\tcase FPIN_CONGN_OVERSUBSCRIPTION:\n\t\tif (cgn_evt == FPIN_CONGN_OVERSUBSCRIPTION)\n\t\t\tnm_log = false;\n\t\tswitch (cgn_sev) {\n\t\tcase FPIN_CONGN_SEVERITY_ERROR:\n\t\t\t \n\t\t\tif (phba->cmf_active_mode != LPFC_CFG_OFF) {\n\t\t\t\tif (phba->cgn_reg_fpin & LPFC_CGN_FPIN_ALARM) {\n\t\t\t\t\t \n\t\t\t\t\tatomic_inc(&phba->cgn_sync_alarm_cnt);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tatomic_inc(&phba->cgn_fabric_alarm_cnt);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FPIN_CONGN_SEVERITY_WARNING:\n\t\t\t \n\t\t\tif (phba->cmf_active_mode != LPFC_CFG_OFF) {\n\t\t\t\tif (phba->cgn_reg_fpin & LPFC_CGN_FPIN_WARN) {\n\t\t\t\t\t \n\t\t\t\t\tatomic_inc(&phba->cgn_sync_warn_cnt);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tatomic_inc(&phba->cgn_fabric_warn_cnt);\ncleanup:\n\t\t\t\t \n\t\t\t\tphba->cgn_fpin_frequency =\n\t\t\t\t\tbe32_to_cpu(cgn->event_period);\n\t\t\t\tvalue = phba->cgn_fpin_frequency;\n\t\t\t\tif (phba->cgn_i) {\n\t\t\t\t\tcp = (struct lpfc_cgn_info *)\n\t\t\t\t\t\tphba->cgn_i->virt;\n\t\t\t\t\tcp->cgn_alarm_freq =\n\t\t\t\t\t\tcpu_to_le16(value);\n\t\t\t\t\tcp->cgn_warn_freq =\n\t\t\t\t\t\tcpu_to_le16(value);\n\t\t\t\t\tcrc = lpfc_cgn_calc_crc32\n\t\t\t\t\t\t(cp,\n\t\t\t\t\t\tLPFC_CGN_INFO_SZ,\n\t\t\t\t\t\tLPFC_CGN_CRC32_SEED);\n\t\t\t\t\tcp->cgn_info_crc = cpu_to_le32(crc);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\trc = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tlpfc_printf_log(phba, (nm_log ? KERN_WARNING : KERN_INFO),\n\t\t\tLOG_CGN_MGMT | LOG_ELS,\n\t\t\t\"4683 FPIN CONGESTION %s type %s (x%x) Event \"\n\t\t\t\"Duration %d mSecs\\n\",\n\t\t\tcgn_sev_str, cgn_evt_str, cgn_evt,\n\t\t\tbe32_to_cpu(cgn->event_period));\n\treturn rc;\n}\n\nvoid\nlpfc_els_rcv_fpin(struct lpfc_vport *vport, void *p, u32 fpin_length)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct fc_els_fpin *fpin = (struct fc_els_fpin *)p;\n\tstruct fc_tlv_desc *tlv, *first_tlv, *current_tlv;\n\tconst char *dtag_nm;\n\tint desc_cnt = 0, bytes_remain, cnt;\n\tu32 dtag, deliver = 0;\n\tint len;\n\n\t \n\tif (vport->port_state < LPFC_DISC_AUTH)\n\t\treturn;\n\n\t \n\tif (fpin_length < sizeof(struct fc_els_fpin))\n\t\treturn;\n\n\t \n\tlen = be32_to_cpu(fpin->desc_len);\n\tif (fpin_length < len + sizeof(struct fc_els_fpin)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_CGN_MGMT,\n\t\t\t\t\"4671 Bad ELS FPIN length %d: %d\\n\",\n\t\t\t\tlen, fpin_length);\n\t\treturn;\n\t}\n\n\ttlv = (struct fc_tlv_desc *)&fpin->fpin_desc[0];\n\tfirst_tlv = tlv;\n\tbytes_remain = fpin_length - offsetof(struct fc_els_fpin, fpin_desc);\n\tbytes_remain = min_t(u32, bytes_remain, be32_to_cpu(fpin->desc_len));\n\n\t \n\twhile (bytes_remain >= FC_TLV_DESC_HDR_SZ &&\n\t       bytes_remain >= FC_TLV_DESC_SZ_FROM_LENGTH(tlv)) {\n\t\tdtag = be32_to_cpu(tlv->desc_tag);\n\t\tswitch (dtag) {\n\t\tcase ELS_DTAG_LNK_INTEGRITY:\n\t\t\tlpfc_els_rcv_fpin_li(phba, tlv);\n\t\t\tdeliver = 1;\n\t\t\tbreak;\n\t\tcase ELS_DTAG_DELIVERY:\n\t\t\tlpfc_els_rcv_fpin_del(phba, tlv);\n\t\t\tdeliver = 1;\n\t\t\tbreak;\n\t\tcase ELS_DTAG_PEER_CONGEST:\n\t\t\tlpfc_els_rcv_fpin_peer_cgn(phba, tlv);\n\t\t\tdeliver = 1;\n\t\t\tbreak;\n\t\tcase ELS_DTAG_CONGESTION:\n\t\t\tdeliver = lpfc_els_rcv_fpin_cgn(phba, tlv);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdtag_nm = lpfc_get_tlv_dtag_nm(dtag);\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_CGN_MGMT,\n\t\t\t\t\t\"4678 unknown FPIN descriptor[%d]: \"\n\t\t\t\t\t\"tag x%x (%s)\\n\",\n\t\t\t\t\tdesc_cnt, dtag, dtag_nm);\n\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tlpfc_cgn_update_stat(phba, dtag);\n\t\tcnt = be32_to_cpu(tlv->desc_len);\n\n\t\t \n\t\tlen -= (cnt + sizeof(struct fc_tlv_desc));\n\t\tif (len < 0) {\n\t\t\tdtag_nm = lpfc_get_tlv_dtag_nm(dtag);\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_CGN_MGMT,\n\t\t\t\t\t\"4672 Bad FPIN descriptor TLV length \"\n\t\t\t\t\t\"%d: %d %d %s\\n\",\n\t\t\t\t\tcnt, len, fpin_length, dtag_nm);\n\t\t\treturn;\n\t\t}\n\n\t\tcurrent_tlv = tlv;\n\t\tbytes_remain -= FC_TLV_DESC_SZ_FROM_LENGTH(tlv);\n\t\ttlv = fc_tlv_next_desc(tlv);\n\n\t\t \n\t\tif (desc_cnt)\n\t\t\tmemcpy(first_tlv, current_tlv,\n\t\t\t       (cnt + sizeof(struct fc_els_fpin)));\n\n\t\t \n\t\tfpin_length = cnt + sizeof(struct fc_els_fpin);\n\t\tfpin->desc_len = cpu_to_be32(fpin_length);\n\t\tfpin_length += sizeof(struct fc_els_fpin);  \n\n\t\t \n\t\tif (deliver)\n\t\t\tfc_host_fpin_rcv(lpfc_shost_from_vport(vport),\n\t\t\t\t\t fpin_length, (char *)fpin, 0);\n\t\tdesc_cnt++;\n\t}\n}\n\n \nstatic void\nlpfc_els_unsol_buffer(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\n\t\t      struct lpfc_vport *vport, struct lpfc_iocbq *elsiocb)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct ls_rjt stat;\n\tu32 *payload, payload_len;\n\tu32 cmd = 0, did = 0, newnode, status = 0;\n\tuint8_t rjt_exp, rjt_err = 0, init_link = 0;\n\tstruct lpfc_wcqe_complete *wcqe_cmpl = NULL;\n\tLPFC_MBOXQ_t *mbox;\n\n\tif (!vport || !elsiocb->cmd_dmabuf)\n\t\tgoto dropit;\n\n\tnewnode = 0;\n\twcqe_cmpl = &elsiocb->wcqe_cmpl;\n\tpayload = elsiocb->cmd_dmabuf->virt;\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tpayload_len = wcqe_cmpl->total_data_placed;\n\telse\n\t\tpayload_len = elsiocb->iocb.unsli3.rcvsli3.acc_len;\n\tstatus = get_job_ulpstatus(phba, elsiocb);\n\tcmd = *payload;\n\tif ((phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) == 0)\n\t\tlpfc_sli3_post_buffer(phba, pring, 1);\n\n\tdid = get_job_els_rsp64_did(phba, elsiocb);\n\tif (status) {\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV Unsol ELS:  status:x%x/x%x did:x%x\",\n\t\t\tstatus, get_job_word4(phba, elsiocb), did);\n\t\tgoto dropit;\n\t}\n\n\t \n\tif (lpfc_els_chk_latt(vport))\n\t\tgoto dropit;\n\n\t \n\tif (vport->load_flag & FC_UNLOADING)\n\t\tgoto dropit;\n\n\t \n\tif ((vport->fc_flag & FC_DISC_DELAYED) &&\n\t\t\t(cmd != ELS_CMD_PLOGI))\n\t\tgoto dropit;\n\n\tndlp = lpfc_findnode_did(vport, did);\n\tif (!ndlp) {\n\t\t \n\t\tndlp = lpfc_nlp_init(vport, did);\n\t\tif (!ndlp)\n\t\t\tgoto dropit;\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\tnewnode = 1;\n\t\tif ((did & Fabric_DID_MASK) == Fabric_DID_MASK)\n\t\t\tndlp->nlp_type |= NLP_FABRIC;\n\t} else if (ndlp->nlp_state == NLP_STE_UNUSED_NODE) {\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_NPR_NODE);\n\t\tnewnode = 1;\n\t}\n\n\tphba->fc_stat.elsRcvFrame++;\n\n\t \n\tspin_lock_irq(&ndlp->lock);\n\tif (ndlp->nlp_flag & NLP_IN_DEV_LOSS) {\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tif (newnode)\n\t\t\tlpfc_nlp_put(ndlp);\n\t\tgoto dropit;\n\t}\n\tspin_unlock_irq(&ndlp->lock);\n\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp)\n\t\tgoto dropit;\n\telsiocb->vport = vport;\n\n\tif ((cmd & ELS_CMD_MASK) == ELS_CMD_RSCN) {\n\t\tcmd &= ELS_CMD_MASK;\n\t}\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0112 ELS command x%x received from NPORT x%x \"\n\t\t\t \"refcnt %d Data: x%x x%x x%x x%x\\n\",\n\t\t\t cmd, did, kref_read(&ndlp->kref), vport->port_state,\n\t\t\t vport->fc_flag, vport->fc_myDID, vport->fc_prevDID);\n\n\t \n\tif ((vport->port_state < LPFC_FABRIC_CFG_LINK) &&\n\t    (cmd != ELS_CMD_FLOGI) &&\n\t    !((cmd == ELS_CMD_PLOGI) && (vport->fc_flag & FC_PT2PT))) {\n\t\trjt_err = LSRJT_LOGICAL_BSY;\n\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\tgoto lsrjt;\n\t}\n\n\tswitch (cmd) {\n\tcase ELS_CMD_PLOGI:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV PLOGI:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvPLOGI++;\n\t\tndlp = lpfc_plogi_confirm_nport(phba, payload, ndlp);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t    (phba->pport->fc_flag & FC_PT2PT)) {\n\t\t\tvport->fc_prevDID = vport->fc_myDID;\n\t\t\t \n\t\t\tvport->fc_myDID =\n\t\t\t\tbf_get(els_rsp64_sid,\n\t\t\t\t       &elsiocb->wqe.xmit_els_rsp);\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t\t \"3312 Remote port assigned DID x%x \"\n\t\t\t\t\t \"%x\\n\", vport->fc_myDID,\n\t\t\t\t\t vport->fc_prevDID);\n\t\t}\n\n\t\tlpfc_send_els_event(vport, ndlp, payload);\n\n\t\t \n\t\tif (vport->fc_flag & FC_DISC_DELAYED) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\tif (!(phba->pport->fc_flag & FC_PT2PT) ||\n\t\t\t\t(phba->pport->fc_flag & FC_PT2PT_PLOGI)) {\n\t\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~NLP_TARGET_REMOVE;\n\t\tspin_unlock_irq(&ndlp->lock);\n\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb,\n\t\t\t\t\tNLP_EVT_RCV_PLOGI);\n\n\t\tbreak;\n\tcase ELS_CMD_FLOGI:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV FLOGI:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvFLOGI++;\n\n\t\t \n\t\tif (vport->port_state >= LPFC_LOCAL_CFG_LINK &&\n\t\t    vport->fc_flag & FC_PT2PT &&\n\t\t    vport->rcv_flogi_cnt >= 1) {\n\t\t\trjt_err = LSRJT_LOGICAL_BSY;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tinit_link++;\n\t\t\tgoto lsrjt;\n\t\t}\n\n\t\tlpfc_els_rcv_flogi(vport, elsiocb, ndlp);\n\t\t \n\t\tif (phba->defer_flogi_acc_flag)\n\t\t\tbreak;\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_LOGO:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV LOGO:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvLOGO++;\n\t\tlpfc_send_els_event(vport, ndlp, payload);\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_LOGO);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_PRLO:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV PRLO:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvPRLO++;\n\t\tlpfc_send_els_event(vport, ndlp, payload);\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_PRLO);\n\t\tbreak;\n\tcase ELS_CMD_LCB:\n\t\tphba->fc_stat.elsRcvLCB++;\n\t\tlpfc_els_rcv_lcb(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_RDP:\n\t\tphba->fc_stat.elsRcvRDP++;\n\t\tlpfc_els_rcv_rdp(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_RSCN:\n\t\tphba->fc_stat.elsRcvRSCN++;\n\t\tlpfc_els_rcv_rscn(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_ADISC:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV ADISC:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tlpfc_send_els_event(vport, ndlp, payload);\n\t\tphba->fc_stat.elsRcvADISC++;\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb,\n\t\t\t\t\tNLP_EVT_RCV_ADISC);\n\t\tbreak;\n\tcase ELS_CMD_PDISC:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV PDISC:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvPDISC++;\n\t\tif (vport->port_state < LPFC_DISC_AUTH) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb,\n\t\t\t\t\tNLP_EVT_RCV_PDISC);\n\t\tbreak;\n\tcase ELS_CMD_FARPR:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV FARPR:       did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvFARPR++;\n\t\tlpfc_els_rcv_farpr(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_FARP:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV FARP:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvFARP++;\n\t\tlpfc_els_rcv_farp(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_FAN:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV FAN:         did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvFAN++;\n\t\tlpfc_els_rcv_fan(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_PRLI:\n\tcase ELS_CMD_NVMEPRLI:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV PRLI:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvPRLI++;\n\t\tif ((vport->port_state < LPFC_DISC_AUTH) &&\n\t\t    (vport->fc_flag & FC_FABRIC)) {\n\t\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_disc_state_machine(vport, ndlp, elsiocb, NLP_EVT_RCV_PRLI);\n\t\tbreak;\n\tcase ELS_CMD_LIRR:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV LIRR:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvLIRR++;\n\t\tlpfc_els_rcv_lirr(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RLS:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RLS:         did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvRLS++;\n\t\tlpfc_els_rcv_rls(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RPL:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RPL:         did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvRPL++;\n\t\tlpfc_els_rcv_rpl(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RNID:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RNID:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvRNID++;\n\t\tlpfc_els_rcv_rnid(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RTV:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RTV:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\t\tphba->fc_stat.elsRcvRTV++;\n\t\tlpfc_els_rcv_rtv(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_RRQ:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV RRQ:         did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvRRQ++;\n\t\tlpfc_els_rcv_rrq(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_ECHO:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV ECHO:        did:x%x/ste:x%x flg:x%x\",\n\t\t\tdid, vport->port_state, ndlp->nlp_flag);\n\n\t\tphba->fc_stat.elsRcvECHO++;\n\t\tlpfc_els_rcv_echo(vport, elsiocb, ndlp);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\tcase ELS_CMD_REC:\n\t\t \n\t\trjt_err = LSRJT_UNABLE_TPC;\n\t\trjt_exp = LSEXP_INVALID_OX_RX;\n\t\tbreak;\n\tcase ELS_CMD_FPIN:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\t      \"RCV FPIN:       did:x%x/ste:x%x flg:x%x\",\n\t\t\t\t      did, vport->port_state, ndlp->nlp_flag);\n\n\t\tlpfc_els_rcv_fpin(vport, (struct fc_els_fpin *)payload,\n\t\t\t\t  payload_len);\n\n\t\t \n\t\tbreak;\n\tcase ELS_CMD_EDC:\n\t\tlpfc_els_rcv_edc(vport, elsiocb, ndlp);\n\t\tbreak;\n\tcase ELS_CMD_RDF:\n\t\tphba->fc_stat.elsRcvRDF++;\n\t\t \n\t\tif (did != Fabric_Cntl_DID) {\n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_ELS,\n\t\t\t\t\t \"1115 Received RDF from invalid DID \"\n\t\t\t\t\t \"x%x\\n\", did);\n\t\t\trjt_err = LSRJT_PROTOCOL_ERR;\n\t\t\trjt_exp = LSEXP_NOTHING_MORE;\n\t\t\tgoto lsrjt;\n\t\t}\n\n\t\tlpfc_els_rcv_rdf(vport, elsiocb, ndlp);\n\t\tbreak;\n\tdefault:\n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_UNSOL,\n\t\t\t\"RCV ELS cmd:     cmd:x%x did:x%x/ste:x%x\",\n\t\t\tcmd, did, vport->port_state);\n\n\t\t \n\t\trjt_err = LSRJT_CMD_UNSUPPORTED;\n\t\trjt_exp = LSEXP_NOTHING_MORE;\n\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0115 Unknown ELS command x%x \"\n\t\t\t\t \"received from NPORT x%x\\n\", cmd, did);\n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t\tbreak;\n\t}\n\nlsrjt:\n\t \n\tif (rjt_err) {\n\t\tmemset(&stat, 0, sizeof(stat));\n\t\tstat.un.b.lsRjtRsnCode = rjt_err;\n\t\tstat.un.b.lsRjtRsnCodeExp = rjt_exp;\n\t\tlpfc_els_rsp_reject(vport, stat.un.lsRjtError, elsiocb, ndlp,\n\t\t\t\t    NULL);\n\t\t \n\t\tif (newnode)\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\tNLP_EVT_DEVICE_RM);\n\t}\n\n\t \n\tlpfc_nlp_put(elsiocb->ndlp);\n\telsiocb->ndlp = NULL;\n\n\t \n\tif (init_link) {\n\t\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (!mbox)\n\t\t\treturn;\n\t\tlpfc_linkdown(phba);\n\t\tlpfc_init_link(phba, mbox,\n\t\t\t       phba->cfg_topology,\n\t\t\t       phba->cfg_link_speed);\n\t\tmbox->u.mb.un.varInitLnk.lipsr_AL_PA = 0;\n\t\tmbox->mbox_cmpl = lpfc_sli_def_mbox_cmpl;\n\t\tmbox->vport = vport;\n\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT) ==\n\t\t    MBX_NOT_FINISHED)\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t}\n\n\treturn;\n\ndropit:\n\tif (vport && !(vport->load_flag & FC_UNLOADING))\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0111 Dropping received ELS cmd \"\n\t\t\t\"Data: x%x x%x x%x x%x\\n\",\n\t\t\tcmd, status, get_job_word4(phba, elsiocb), did);\n\n\tphba->fc_stat.elsRcvDrop++;\n}\n\n \nvoid\nlpfc_els_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\n\t\t     struct lpfc_iocbq *elsiocb)\n{\n\tstruct lpfc_vport *vport = elsiocb->vport;\n\tu32 ulp_command, status, parameter, bde_count = 0;\n\tIOCB_t *icmd;\n\tstruct lpfc_wcqe_complete *wcqe_cmpl = NULL;\n\tstruct lpfc_dmabuf *bdeBuf1 = elsiocb->cmd_dmabuf;\n\tstruct lpfc_dmabuf *bdeBuf2 = elsiocb->bpl_dmabuf;\n\tdma_addr_t paddr;\n\n\telsiocb->cmd_dmabuf = NULL;\n\telsiocb->rsp_dmabuf = NULL;\n\telsiocb->bpl_dmabuf = NULL;\n\n\twcqe_cmpl = &elsiocb->wcqe_cmpl;\n\tulp_command = get_job_cmnd(phba, elsiocb);\n\tstatus = get_job_ulpstatus(phba, elsiocb);\n\tparameter = get_job_word4(phba, elsiocb);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tbde_count = wcqe_cmpl->word3;\n\telse\n\t\tbde_count = elsiocb->iocb.ulpBdeCount;\n\n\tif (status == IOSTAT_NEED_BUFFER) {\n\t\tlpfc_sli_hbqbuf_add_hbqs(phba, LPFC_ELS_HBQ);\n\t} else if (status == IOSTAT_LOCAL_REJECT &&\n\t\t   (parameter & IOERR_PARAM_MASK) ==\n\t\t   IOERR_RCV_BUFFER_WAITING) {\n\t\tphba->fc_stat.NoRcvBuf++;\n\t\t \n\t\tif (!(phba->sli3_options & LPFC_SLI3_HBQ_ENABLED))\n\t\t\tlpfc_sli3_post_buffer(phba, pring, 0);\n\t\treturn;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV3) {\n\t\ticmd = &elsiocb->iocb;\n\t\tif ((phba->sli3_options & LPFC_SLI3_NPIV_ENABLED) &&\n\t\t    (ulp_command == CMD_IOCB_RCV_ELS64_CX ||\n\t\t     ulp_command == CMD_IOCB_RCV_SEQ64_CX)) {\n\t\t\tif (icmd->unsli3.rcvsli3.vpi == 0xffff)\n\t\t\t\tvport = phba->pport;\n\t\t\telse\n\t\t\t\tvport = lpfc_find_vport_by_vpid(phba,\n\t\t\t\t\t\ticmd->unsli3.rcvsli3.vpi);\n\t\t}\n\t}\n\n\t \n\tif (bde_count == 0)\n\t\treturn;\n\n\t \n\tif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\n\t\telsiocb->cmd_dmabuf = bdeBuf1;\n\t\tif (bde_count == 2)\n\t\t\telsiocb->bpl_dmabuf = bdeBuf2;\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\tpaddr = getPaddr(icmd->un.cont64[0].addrHigh,\n\t\t\t\t icmd->un.cont64[0].addrLow);\n\t\telsiocb->cmd_dmabuf = lpfc_sli_ringpostbuf_get(phba, pring,\n\t\t\t\t\t\t\t       paddr);\n\t\tif (bde_count == 2) {\n\t\t\tpaddr = getPaddr(icmd->un.cont64[1].addrHigh,\n\t\t\t\t\t icmd->un.cont64[1].addrLow);\n\t\t\telsiocb->bpl_dmabuf = lpfc_sli_ringpostbuf_get(phba,\n\t\t\t\t\t\t\t\t\tpring,\n\t\t\t\t\t\t\t\t\tpaddr);\n\t\t}\n\t}\n\n\tlpfc_els_unsol_buffer(phba, pring, vport, elsiocb);\n\t \n\tif (elsiocb->cmd_dmabuf) {\n\t\tlpfc_in_buf_free(phba, elsiocb->cmd_dmabuf);\n\t\telsiocb->cmd_dmabuf = NULL;\n\t}\n\n\tif (elsiocb->bpl_dmabuf) {\n\t\tlpfc_in_buf_free(phba, elsiocb->bpl_dmabuf);\n\t\telsiocb->bpl_dmabuf = NULL;\n\t}\n\n}\n\nstatic void\nlpfc_start_fdmi(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\t \n\tndlp = lpfc_findnode_did(vport, FDMI_DID);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, FDMI_DID);\n\t\tif (ndlp) {\n\t\t\tndlp->nlp_type |= NLP_FABRIC;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\tlpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0);\n}\n\n \nvoid\nlpfc_do_scr_ns_plogi(struct lpfc_hba *phba, struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\t \n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_flag & FC_DISC_DELAYED) {\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"3334 Delay fc port discovery for %d secs\\n\",\n\t\t\t\t phba->fc_ratov);\n\t\tmod_timer(&vport->delayed_disc_tmo,\n\t\t\tjiffies + msecs_to_jiffies(1000 * phba->fc_ratov));\n\t\treturn;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\n\tndlp = lpfc_findnode_did(vport, NameServer_DID);\n\tif (!ndlp) {\n\t\tndlp = lpfc_nlp_init(vport, NameServer_DID);\n\t\tif (!ndlp) {\n\t\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\t\tlpfc_disc_start(vport);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0251 NameServer login: no memory\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tndlp->nlp_type |= NLP_FABRIC;\n\n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_PLOGI_ISSUE);\n\n\tif (lpfc_issue_els_plogi(vport, ndlp->nlp_DID, 0)) {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0252 Cannot issue NameServer login\\n\");\n\t\treturn;\n\t}\n\n\tif ((phba->cfg_enable_SmartSAN ||\n\t     (phba->cfg_fdmi_on == LPFC_FDMI_SUPPORT)) &&\n\t     (vport->load_flag & FC_ALLOW_FDMI))\n\t\tlpfc_start_fdmi(vport);\n}\n\n \nstatic void\nlpfc_cmpl_reg_new_vport(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmb)\n{\n\tstruct lpfc_vport *vport = pmb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp = pmb->ctx_ndlp;\n\tMAILBOX_t *mb = &pmb->u.mb;\n\tint rc;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\n\tif (mb->mbxStatus) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0915 Register VPI failed : Status: x%x\"\n\t\t\t\t\" upd bit: x%x \\n\", mb->mbxStatus,\n\t\t\t\t mb->un.varRegVpi.upd);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t\tmb->un.varRegVpi.upd)\n\t\t\tgoto mbox_err_exit ;\n\n\t\tswitch (mb->mbxStatus) {\n\t\tcase 0x11:\t \n\t\tcase 0x9603:\t \n\t\tcase 0x9602:\t \n\t\t\t \n\t\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag &= ~(FC_FABRIC | FC_PUBLIC_LOOP);\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tlpfc_can_disctmo(vport);\n\t\t\tbreak;\n\t\t \n\t\tcase 0x20:\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tlpfc_init_vpi(phba, pmb, vport->vpi);\n\t\t\tpmb->vport = vport;\n\t\t\tpmb->mbox_cmpl = lpfc_init_vpi_cmpl;\n\t\t\trc = lpfc_sli_issue_mbox(phba, pmb,\n\t\t\t\tMBX_NOWAIT);\n\t\t\tif (rc == MBX_NOT_FINISHED) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t\t\"2732 Failed to issue INIT_VPI\"\n\t\t\t\t\t\" mailbox command\\n\");\n\t\t\t} else {\n\t\t\t\tlpfc_nlp_put(ndlp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\t \n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\t\t\tlpfc_mbx_unreg_vpi(vport);\n\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\tif (mb->mbxStatus == MBX_NOT_FINISHED)\n\t\t\t\tbreak;\n\t\t\tif ((vport->port_type == LPFC_PHYSICAL_PORT) &&\n\t\t\t    !(vport->fc_flag & FC_LOGO_RCVD_DID_CHNG)) {\n\t\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\t\tlpfc_issue_init_vfi(vport);\n\t\t\t\telse\n\t\t\t\t\tlpfc_initial_flogi(vport);\n\t\t\t} else {\n\t\t\t\tlpfc_initial_fdisc(vport);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->vpi_state |= LPFC_VPI_REGISTERED;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tif (vport == phba->pport) {\n\t\t\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\t\t\tlpfc_issue_fabric_reglogin(vport);\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tif (vport->port_state != LPFC_FDISC)\n\t\t\t\t\tlpfc_start_fdiscs(phba);\n\t\t\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\t\t\t}\n\t\t} else {\n\t\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\t\t}\n\t}\nmbox_err_exit:\n\t \n\tlpfc_nlp_put(ndlp);\n\n\tmempool_free(pmb, phba->mbox_mem_pool);\n\treturn;\n}\n\n \nvoid\nlpfc_register_new_vport(struct lpfc_hba *phba, struct lpfc_vport *vport,\n\t\t\tstruct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tLPFC_MBOXQ_t *mbox;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (mbox) {\n\t\tlpfc_reg_vpi(vport, mbox);\n\t\tmbox->vport = vport;\n\t\tmbox->ctx_ndlp = lpfc_nlp_get(ndlp);\n\t\tif (!mbox->ctx_ndlp) {\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\tgoto mbox_err_exit;\n\t\t}\n\n\t\tmbox->mbox_cmpl = lpfc_cmpl_reg_new_vport;\n\t\tif (lpfc_sli_issue_mbox(phba, mbox, MBX_NOWAIT)\n\t\t    == MBX_NOT_FINISHED) {\n\t\t\t \n\t\t\tlpfc_nlp_put(ndlp);\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"0253 Register VPI: Can't send mbox\\n\");\n\t\t\tgoto mbox_err_exit;\n\t\t}\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0254 Register VPI: no memory\\n\");\n\t\tgoto mbox_err_exit;\n\t}\n\treturn;\n\nmbox_err_exit:\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_NEEDS_REG_VPI;\n\tspin_unlock_irq(shost->host_lock);\n\treturn;\n}\n\n \nvoid\nlpfc_cancel_all_vport_retry_delay_timer(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct lpfc_nodelist *ndlp;\n\tuint32_t link_state;\n\tint i;\n\n\t \n\tlink_state = phba->link_state;\n\tlpfc_linkdown(phba);\n\tphba->link_state = link_state;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\n\tif (vports) {\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tndlp = lpfc_findnode_did(vports[i], Fabric_DID);\n\t\t\tif (ndlp)\n\t\t\t\tlpfc_cancel_retry_delay_tmo(vports[i], ndlp);\n\t\t\tlpfc_els_flush_cmd(vports[i]);\n\t\t}\n\t\tlpfc_destroy_vport_work_array(phba, vports);\n\t}\n}\n\n \nvoid\nlpfc_retry_pport_discovery(struct lpfc_hba *phba)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\t \n\tlpfc_cancel_all_vport_retry_delay_timer(phba);\n\n\t \n\tndlp = lpfc_findnode_did(phba->pport, Fabric_DID);\n\tif (!ndlp)\n\t\treturn;\n\n\tmod_timer(&ndlp->nlp_delayfunc, jiffies + msecs_to_jiffies(1000));\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_DELAY_TMO;\n\tspin_unlock_irq(&ndlp->lock);\n\tndlp->nlp_last_elscmd = ELS_CMD_FLOGI;\n\tphba->pport->port_state = LPFC_FLOGI;\n\treturn;\n}\n\n \nstatic int\nlpfc_fabric_login_reqd(struct lpfc_hba *phba,\n\t\tstruct lpfc_iocbq *cmdiocb,\n\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\n\tif (ulp_status != IOSTAT_FABRIC_RJT ||\n\t    ulp_word4 != RJT_LOGIN_REQUIRED)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\n \nstatic void\nlpfc_cmpl_els_fdisc(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t    struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host  *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tstruct lpfc_nodelist *np;\n\tstruct lpfc_nodelist *next_np;\n\tstruct lpfc_iocbq *piocb;\n\tstruct lpfc_dmabuf *pcmd = cmdiocb->cmd_dmabuf, *prsp;\n\tstruct serv_parm *sp;\n\tuint8_t fabric_param_changed;\n\tu32 ulp_status, ulp_word4;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0123 FDISC completes. x%x/x%x prevDID: x%x\\n\",\n\t\t\t ulp_status, ulp_word4,\n\t\t\t vport->fc_prevDID);\n\t \n\tlist_for_each_entry(piocb, &phba->fabric_iocb_list, list) {\n\t\tlpfc_set_disctmo(piocb->vport);\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"FDISC cmpl:      status:x%x/x%x prevdid:x%x\",\n\t\tulp_status, ulp_word4, vport->fc_prevDID);\n\n\tif (ulp_status) {\n\n\t\tif (lpfc_fabric_login_reqd(phba, cmdiocb, rspiocb)) {\n\t\t\tlpfc_retry_pport_discovery(phba);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (lpfc_els_retry(phba, cmdiocb, rspiocb))\n\t\t\tgoto out;\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0126 FDISC failed. (x%x/x%x)\\n\",\n\t\t\t\t ulp_status, ulp_word4);\n\t\tgoto fdisc_failed;\n\t}\n\n\tlpfc_check_nlp_post_devloss(vport, ndlp);\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->fc_flag &= ~FC_VPORT_CVL_RCVD;\n\tvport->fc_flag &= ~FC_VPORT_LOGO_RCVD;\n\tvport->fc_flag |= FC_FABRIC;\n\tif (vport->phba->fc_topology == LPFC_TOPOLOGY_LOOP)\n\t\tvport->fc_flag |=  FC_PUBLIC_LOOP;\n\tspin_unlock_irq(shost->host_lock);\n\n\tvport->fc_myDID = ulp_word4 & Mask_DID;\n\tlpfc_vport_set_state(vport, FC_VPORT_ACTIVE);\n\tprsp = list_get_first(&pcmd->list, struct lpfc_dmabuf, list);\n\tif (!prsp)\n\t\tgoto out;\n\tsp = prsp->virt + sizeof(uint32_t);\n\tfabric_param_changed = lpfc_check_clean_addr_bit(vport, sp);\n\tmemcpy(&vport->fabric_portname, &sp->portName,\n\t\tsizeof(struct lpfc_name));\n\tmemcpy(&vport->fabric_nodename, &sp->nodeName,\n\t\tsizeof(struct lpfc_name));\n\tif (fabric_param_changed &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\n\t\t \n\t\tlist_for_each_entry_safe(np, next_np,\n\t\t\t&vport->fc_nodes, nlp_listp) {\n\t\t\tif ((np->nlp_state != NLP_STE_NPR_NODE) ||\n\t\t\t    !(np->nlp_flag & NLP_NPR_ADISC))\n\t\t\t\tcontinue;\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tnp->nlp_flag &= ~NLP_NPR_ADISC;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\tlpfc_unreg_rpi(vport, np);\n\t\t}\n\t\tlpfc_cleanup_pending_mbox(vport);\n\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_sli4_unreg_all_rpis(vport);\n\n\t\tlpfc_mbx_unreg_vpi(vport);\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag |= FC_VPORT_NEEDS_REG_VPI;\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tvport->fc_flag |= FC_VPORT_NEEDS_INIT_VPI;\n\t\telse\n\t\t\tvport->fc_flag |= FC_LOGO_RCVD_DID_CHNG;\n\t\tspin_unlock_irq(shost->host_lock);\n\t} else if ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t\t!(vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)) {\n\t\t \n\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\t\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\t\tgoto out;\n\t}\n\n\tif (vport->fc_flag & FC_VPORT_NEEDS_INIT_VPI)\n\t\tlpfc_issue_init_vpi(vport);\n\telse if (vport->fc_flag & FC_VPORT_NEEDS_REG_VPI)\n\t\tlpfc_register_new_vport(phba, vport, ndlp);\n\telse\n\t\tlpfc_do_scr_ns_plogi(phba, vport);\n\n\t \n\tlpfc_nlp_set_state(vport, ndlp, NLP_STE_UNMAPPED_NODE);\n\tgoto out;\n\nfdisc_failed:\n\tif (vport->fc_vport &&\n\t    (vport->fc_vport->vport_state != FC_VPORT_NO_FABRIC_RSCS))\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t \n\tlpfc_can_disctmo(vport);\nout:\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n \nstatic int\nlpfc_issue_els_fdisc(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t     uint8_t retry)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tIOCB_t *icmd;\n\tunion lpfc_wqe128 *wqe = NULL;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct serv_parm *sp;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\tint did = ndlp->nlp_DID;\n\tint rc;\n\n\tvport->port_state = LPFC_FDISC;\n\tvport->fc_myDID = 0;\n\tcmdsize = (sizeof(uint32_t) + sizeof(struct serv_parm));\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, retry, ndlp, did,\n\t\t\t\t     ELS_CMD_FDISC);\n\tif (!elsiocb) {\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0255 Issue FDISC: no IOCB\\n\");\n\t\treturn 1;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twqe = &elsiocb->wqe;\n\t\tbf_set(els_req64_sid, &wqe->els_req, 0);\n\t\tbf_set(els_req64_sp, &wqe->els_req, 1);\n\t} else {\n\t\ticmd = &elsiocb->iocb;\n\t\ticmd->un.elsreq64.myID = 0;\n\t\ticmd->un.elsreq64.fl = 1;\n\t\ticmd->ulpCt_h = 1;\n\t\ticmd->ulpCt_l = 0;\n\t}\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *) (pcmd)) = ELS_CMD_FDISC;\n\tpcmd += sizeof(uint32_t);  \n\tmemcpy(pcmd, &vport->phba->pport->fc_sparam, sizeof(struct serv_parm));\n\tsp = (struct serv_parm *) pcmd;\n\t \n\tsp->cmn.e_d_tov = 0;\n\tsp->cmn.w2.r_a_tov = 0;\n\tsp->cmn.virtual_fabric_support = 0;\n\tsp->cls1.classValid = 0;\n\tsp->cls2.seqDelivery = 1;\n\tsp->cls3.seqDelivery = 1;\n\n\tpcmd += sizeof(uint32_t);  \n\tpcmd += sizeof(uint32_t);  \n\tpcmd += sizeof(uint32_t);  \n\tpcmd += sizeof(uint32_t);  \n\tmemcpy(pcmd, &vport->fc_portname, 8);\n\tpcmd += sizeof(uint32_t);  \n\tpcmd += sizeof(uint32_t);  \n\tmemcpy(pcmd, &vport->fc_nodename, 8);\n\tsp->cmn.valid_vendor_ver_level = 0;\n\tmemset(sp->un.vendorVersion, 0, sizeof(sp->un.vendorVersion));\n\tlpfc_set_disctmo(vport);\n\n\tphba->fc_stat.elsXmitFDISC++;\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_fdisc;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue FDISC:     did:x%x\",\n\t\tdid, 0, 0);\n\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp)\n\t\tgoto err_out;\n\n\trc = lpfc_issue_fabric_iocb(phba, elsiocb);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto err_out;\n\t}\n\n\tlpfc_vport_set_state(vport, FC_VPORT_INITIALIZING);\n\treturn 0;\n\n err_out:\n\tlpfc_els_free_iocb(phba, elsiocb);\n\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0256 Issue FDISC: Cannot send IOCB\\n\");\n\treturn 1;\n}\n\n \nstatic void\nlpfc_cmpl_els_npiv_logo(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tIOCB_t *irsp;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tu32 ulp_status, ulp_word4, did, tmo;\n\n\tndlp = cmdiocb->ndlp;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocb);\n\tulp_word4 = get_job_word4(phba, rspiocb);\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tdid = get_job_els_rsp64_did(phba, cmdiocb);\n\t\ttmo = get_wqe_tmo(cmdiocb);\n\t} else {\n\t\tirsp = &rspiocb->iocb;\n\t\tdid = get_job_els_rsp64_did(phba, rspiocb);\n\t\ttmo = irsp->ulpTimeout;\n\t}\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"LOGO npiv cmpl:  status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4, did);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"2928 NPIV LOGO completes to NPort x%x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, ulp_status, ulp_word4,\n\t\t\t tmo, vport->num_disc_nodes,\n\t\t\t kref_read(&ndlp->kref), ndlp->nlp_flag,\n\t\t\t ndlp->fc4_xpt_flags);\n\n\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\tspin_lock_irq(shost->host_lock);\n\t\tvport->fc_flag &= ~FC_NDISC_ACTIVE;\n\t\tvport->fc_flag &= ~FC_FABRIC;\n\t\tspin_unlock_irq(shost->host_lock);\n\t\tlpfc_can_disctmo(vport);\n\t}\n\n\tif (ndlp->save_flags & NLP_WAIT_FOR_LOGO) {\n\t\t \n\t\tif (ndlp->logo_waitq)\n\t\t\twake_up(ndlp->logo_waitq);\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nlp_flag &= ~(NLP_ISSUE_LOGO | NLP_LOGO_SND);\n\t\tndlp->save_flags &= ~NLP_WAIT_FOR_LOGO;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t}\n\n\t \n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n \nint\nlpfc_issue_els_npiv_logo(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n\tint rc = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *elsiocb;\n\tuint8_t *pcmd;\n\tuint16_t cmdsize;\n\n\tcmdsize = 2 * sizeof(uint32_t) + sizeof(struct lpfc_name);\n\telsiocb = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp, ndlp->nlp_DID,\n\t\t\t\t     ELS_CMD_LOGO);\n\tif (!elsiocb)\n\t\treturn 1;\n\n\tpcmd = (uint8_t *)elsiocb->cmd_dmabuf->virt;\n\t*((uint32_t *) (pcmd)) = ELS_CMD_LOGO;\n\tpcmd += sizeof(uint32_t);\n\n\t \n\t*((uint32_t *) (pcmd)) = be32_to_cpu(vport->fc_myDID);\n\tpcmd += sizeof(uint32_t);\n\tmemcpy(pcmd, &vport->fc_portname, sizeof(struct lpfc_name));\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\"Issue LOGO npiv  did:x%x flg:x%x\",\n\t\tndlp->nlp_DID, ndlp->nlp_flag, 0);\n\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_npiv_logo;\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag |= NLP_LOGO_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tgoto err;\n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto err;\n\t}\n\treturn 0;\n\nerr:\n\tspin_lock_irq(&ndlp->lock);\n\tndlp->nlp_flag &= ~NLP_LOGO_SND;\n\tspin_unlock_irq(&ndlp->lock);\n\treturn 1;\n}\n\n \nvoid\nlpfc_fabric_block_timeout(struct timer_list *t)\n{\n\tstruct lpfc_hba  *phba = from_timer(phba, t, fabric_block_timer);\n\tunsigned long iflags;\n\tuint32_t tmo_posted;\n\n\tspin_lock_irqsave(&phba->pport->work_port_lock, iflags);\n\ttmo_posted = phba->pport->work_port_events & WORKER_FABRIC_BLOCK_TMO;\n\tif (!tmo_posted)\n\t\tphba->pport->work_port_events |= WORKER_FABRIC_BLOCK_TMO;\n\tspin_unlock_irqrestore(&phba->pport->work_port_lock, iflags);\n\n\tif (!tmo_posted)\n\t\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n \nstatic void\nlpfc_resume_fabric_iocbs(struct lpfc_hba *phba)\n{\n\tstruct lpfc_iocbq *iocb;\n\tunsigned long iflags;\n\tint ret;\n\nrepeat:\n\tiocb = NULL;\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t \n\tif (atomic_read(&phba->fabric_iocb_count) == 0) {\n\t\tlist_remove_head(&phba->fabric_iocb_list, iocb, typeof(*iocb),\n\t\t\t\t list);\n\t\tif (iocb)\n\t\t\t \n\t\t\tatomic_inc(&phba->fabric_iocb_count);\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\tif (iocb) {\n\t\tiocb->fabric_cmd_cmpl = iocb->cmd_cmpl;\n\t\tiocb->cmd_cmpl = lpfc_cmpl_fabric_iocb;\n\t\tiocb->cmd_flag |= LPFC_IO_FABRIC;\n\n\t\tlpfc_debugfs_disc_trc(iocb->vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t\t      \"Fabric sched1:   ste:x%x\",\n\t\t\t\t      iocb->vport->port_state, 0, 0);\n\n\t\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, iocb, 0);\n\n\t\tif (ret == IOCB_ERROR) {\n\t\t\tiocb->cmd_cmpl = iocb->fabric_cmd_cmpl;\n\t\t\tiocb->fabric_cmd_cmpl = NULL;\n\t\t\tiocb->cmd_flag &= ~LPFC_IO_FABRIC;\n\t\t\tset_job_ulpstatus(iocb, IOSTAT_LOCAL_REJECT);\n\t\t\tiocb->wcqe_cmpl.parameter = IOERR_SLI_ABORTED;\n\t\t\tiocb->cmd_cmpl(phba, iocb, iocb);\n\n\t\t\tatomic_dec(&phba->fabric_iocb_count);\n\t\t\tgoto repeat;\n\t\t}\n\t}\n}\n\n \nvoid\nlpfc_unblock_fabric_iocbs(struct lpfc_hba *phba)\n{\n\tclear_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\n\n\tlpfc_resume_fabric_iocbs(phba);\n\treturn;\n}\n\n \nstatic void\nlpfc_block_fabric_iocbs(struct lpfc_hba *phba)\n{\n\tint blocked;\n\n\tblocked = test_and_set_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\n\t \n\tif (!blocked)\n\t\tmod_timer(&phba->fabric_block_timer,\n\t\t\t  jiffies + msecs_to_jiffies(100));\n\n\treturn;\n}\n\n \nstatic void\nlpfc_cmpl_fabric_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t      struct lpfc_iocbq *rspiocb)\n{\n\tstruct ls_rjt stat;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\n\tWARN_ON((cmdiocb->cmd_flag & LPFC_IO_FABRIC) != LPFC_IO_FABRIC);\n\n\tswitch (ulp_status) {\n\t\tcase IOSTAT_NPORT_RJT:\n\t\tcase IOSTAT_FABRIC_RJT:\n\t\t\tif (ulp_word4 & RJT_UNAVAIL_TEMP)\n\t\t\t\tlpfc_block_fabric_iocbs(phba);\n\t\t\tbreak;\n\n\t\tcase IOSTAT_NPORT_BSY:\n\t\tcase IOSTAT_FABRIC_BSY:\n\t\t\tlpfc_block_fabric_iocbs(phba);\n\t\t\tbreak;\n\n\t\tcase IOSTAT_LS_RJT:\n\t\t\tstat.un.ls_rjt_error_be =\n\t\t\t\tcpu_to_be32(ulp_word4);\n\t\t\tif ((stat.un.b.lsRjtRsnCode == LSRJT_UNABLE_TPC) ||\n\t\t\t\t(stat.un.b.lsRjtRsnCode == LSRJT_LOGICAL_BSY))\n\t\t\t\tlpfc_block_fabric_iocbs(phba);\n\t\t\tbreak;\n\t}\n\n\tBUG_ON(atomic_read(&phba->fabric_iocb_count) == 0);\n\n\tcmdiocb->cmd_cmpl = cmdiocb->fabric_cmd_cmpl;\n\tcmdiocb->fabric_cmd_cmpl = NULL;\n\tcmdiocb->cmd_flag &= ~LPFC_IO_FABRIC;\n\tcmdiocb->cmd_cmpl(phba, cmdiocb, rspiocb);\n\n\tatomic_dec(&phba->fabric_iocb_count);\n\tif (!test_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags)) {\n\t\t \n\t\tlpfc_resume_fabric_iocbs(phba);\n\t}\n}\n\n \nstatic int\nlpfc_issue_fabric_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *iocb)\n{\n\tunsigned long iflags;\n\tint ready;\n\tint ret;\n\n\tBUG_ON(atomic_read(&phba->fabric_iocb_count) > 1);\n\n\tspin_lock_irqsave(&phba->hbalock, iflags);\n\tready = atomic_read(&phba->fabric_iocb_count) == 0 &&\n\t\t!test_bit(FABRIC_COMANDS_BLOCKED, &phba->bit_flags);\n\n\tif (ready)\n\t\t \n\t\tatomic_inc(&phba->fabric_iocb_count);\n\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\tif (ready) {\n\t\tiocb->fabric_cmd_cmpl = iocb->cmd_cmpl;\n\t\tiocb->cmd_cmpl = lpfc_cmpl_fabric_iocb;\n\t\tiocb->cmd_flag |= LPFC_IO_FABRIC;\n\n\t\tlpfc_debugfs_disc_trc(iocb->vport, LPFC_DISC_TRC_ELS_CMD,\n\t\t\t\t      \"Fabric sched2:   ste:x%x\",\n\t\t\t\t      iocb->vport->port_state, 0, 0);\n\n\t\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, iocb, 0);\n\n\t\tif (ret == IOCB_ERROR) {\n\t\t\tiocb->cmd_cmpl = iocb->fabric_cmd_cmpl;\n\t\t\tiocb->fabric_cmd_cmpl = NULL;\n\t\t\tiocb->cmd_flag &= ~LPFC_IO_FABRIC;\n\t\t\tatomic_dec(&phba->fabric_iocb_count);\n\t\t}\n\t} else {\n\t\tspin_lock_irqsave(&phba->hbalock, iflags);\n\t\tlist_add_tail(&iocb->list, &phba->fabric_iocb_list);\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflags);\n\t\tret = IOCB_SUCCESS;\n\t}\n\treturn ret;\n}\n\n \nstatic void lpfc_fabric_abort_vport(struct lpfc_vport *vport)\n{\n\tLIST_HEAD(completions);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *tmp_iocb, *piocb;\n\n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &phba->fabric_iocb_list,\n\t\t\t\t list) {\n\n\t\tif (piocb->vport != vport)\n\t\t\tcontinue;\n\n\t\tlist_move_tail(&piocb->list, &completions);\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\n\t\t\t      IOERR_SLI_ABORTED);\n}\n\n \nvoid lpfc_fabric_abort_nport(struct lpfc_nodelist *ndlp)\n{\n\tLIST_HEAD(completions);\n\tstruct lpfc_hba  *phba = ndlp->phba;\n\tstruct lpfc_iocbq *tmp_iocb, *piocb;\n\tstruct lpfc_sli_ring *pring;\n\n\tpring = lpfc_phba_elsring(phba);\n\n\tif (unlikely(!pring))\n\t\treturn;\n\n\tspin_lock_irq(&phba->hbalock);\n\tlist_for_each_entry_safe(piocb, tmp_iocb, &phba->fabric_iocb_list,\n\t\t\t\t list) {\n\t\tif ((lpfc_check_sli_ndlp(phba, pring, piocb, ndlp))) {\n\n\t\t\tlist_move_tail(&piocb->list, &completions);\n\t\t}\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\n\t\t\t      IOERR_SLI_ABORTED);\n}\n\n \nvoid lpfc_fabric_abort_hba(struct lpfc_hba *phba)\n{\n\tLIST_HEAD(completions);\n\n\tspin_lock_irq(&phba->hbalock);\n\tlist_splice_init(&phba->fabric_iocb_list, &completions);\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tlpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,\n\t\t\t      IOERR_SLI_ABORTED);\n}\n\n \nvoid\nlpfc_sli4_vport_delete_els_xri_aborted(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_sglq *sglq_entry = NULL, *sglq_next = NULL;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tunsigned long iflag = 0;\n\n\tspin_lock_irqsave(&phba->sli4_hba.sgl_list_lock, iflag);\n\tlist_for_each_entry_safe(sglq_entry, sglq_next,\n\t\t\t&phba->sli4_hba.lpfc_abts_els_sgl_list, list) {\n\t\tif (sglq_entry->ndlp && sglq_entry->ndlp->vport == vport) {\n\t\t\tlpfc_nlp_put(sglq_entry->ndlp);\n\t\t\tndlp = sglq_entry->ndlp;\n\t\t\tsglq_entry->ndlp = NULL;\n\n\t\t\t \n\t\t\tif ((vport->load_flag & FC_UNLOADING) &&\n\t\t\t    ndlp->nlp_DID == Fabric_DID) {\n\t\t\t\tlist_del(&sglq_entry->list);\n\t\t\t\tsglq_entry->state = SGL_FREED;\n\t\t\t\tlist_add_tail(&sglq_entry->list,\n\t\t\t\t\t&phba->sli4_hba.lpfc_els_sgl_list);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->sli4_hba.sgl_list_lock, iflag);\n\treturn;\n}\n\n \nvoid\nlpfc_sli4_els_xri_aborted(struct lpfc_hba *phba,\n\t\t\t  struct sli4_wcqe_xri_aborted *axri)\n{\n\tuint16_t xri = bf_get(lpfc_wcqe_xa_xri, axri);\n\tuint16_t rxid = bf_get(lpfc_wcqe_xa_remote_xid, axri);\n\tuint16_t lxri = 0;\n\n\tstruct lpfc_sglq *sglq_entry = NULL, *sglq_next = NULL;\n\tunsigned long iflag = 0;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_sli_ring *pring;\n\n\tpring = lpfc_phba_elsring(phba);\n\n\tspin_lock_irqsave(&phba->sli4_hba.sgl_list_lock, iflag);\n\tlist_for_each_entry_safe(sglq_entry, sglq_next,\n\t\t\t&phba->sli4_hba.lpfc_abts_els_sgl_list, list) {\n\t\tif (sglq_entry->sli4_xritag == xri) {\n\t\t\tlist_del(&sglq_entry->list);\n\t\t\tndlp = sglq_entry->ndlp;\n\t\t\tsglq_entry->ndlp = NULL;\n\t\t\tlist_add_tail(&sglq_entry->list,\n\t\t\t\t&phba->sli4_hba.lpfc_els_sgl_list);\n\t\t\tsglq_entry->state = SGL_FREED;\n\t\t\tspin_unlock_irqrestore(&phba->sli4_hba.sgl_list_lock,\n\t\t\t\t\t       iflag);\n\n\t\t\tif (ndlp) {\n\t\t\t\tlpfc_set_rrq_active(phba, ndlp,\n\t\t\t\t\tsglq_entry->sli4_lxritag,\n\t\t\t\t\trxid, 1);\n\t\t\t\tlpfc_nlp_put(ndlp);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pring && !list_empty(&pring->txq))\n\t\t\t\tlpfc_worker_wake_up(phba);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->sli4_hba.sgl_list_lock, iflag);\n\tlxri = lpfc_sli4_xri_inrange(phba, xri);\n\tif (lxri == NO_XRI)\n\t\treturn;\n\n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\tsglq_entry = __lpfc_get_active_sglq(phba, lxri);\n\tif (!sglq_entry || (sglq_entry->sli4_xritag != xri)) {\n\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\treturn;\n\t}\n\tsglq_entry->state = SGL_XRI_ABORTED;\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\treturn;\n}\n\n \nvoid\nlpfc_sli_abts_recover_port(struct lpfc_vport *vport,\n\t\t\t   struct lpfc_nodelist *ndlp)\n{\n\tstruct Scsi_Host *shost;\n\tstruct lpfc_hba *phba;\n\tunsigned long flags = 0;\n\n\tshost = lpfc_shost_from_vport(vport);\n\tphba = vport->phba;\n\tif (ndlp->nlp_state != NLP_STE_MAPPED_NODE) {\n\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\tLOG_SLI, \"3093 No rport recovery needed. \"\n\t\t\t\t\"rport in state 0x%x\\n\", ndlp->nlp_state);\n\t\treturn;\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"3094 Start rport recovery on shost id 0x%x \"\n\t\t\t\"fc_id 0x%06x vpi 0x%x rpi 0x%x state 0x%x \"\n\t\t\t\"flags 0x%x\\n\",\n\t\t\tshost->host_no, ndlp->nlp_DID,\n\t\t\tvport->vpi, ndlp->nlp_rpi, ndlp->nlp_state,\n\t\t\tndlp->nlp_flag);\n\t \n\tspin_lock_irqsave(&ndlp->lock, flags);\n\tndlp->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\tndlp->nlp_flag |= NLP_ISSUE_LOGO;\n\tspin_unlock_irqrestore(&ndlp->lock, flags);\n\tlpfc_unreg_rpi(vport, ndlp);\n}\n\nstatic void lpfc_init_cs_ctl_bitmap(struct lpfc_vport *vport)\n{\n\tbitmap_zero(vport->vmid_priority_range, LPFC_VMID_MAX_PRIORITY_RANGE);\n}\n\nstatic void\nlpfc_vmid_set_cs_ctl_range(struct lpfc_vport *vport, u32 min, u32 max)\n{\n\tu32 i;\n\n\tif ((min > max) || (max > LPFC_VMID_MAX_PRIORITY_RANGE))\n\t\treturn;\n\n\tfor (i = min; i <= max; i++)\n\t\tset_bit(i, vport->vmid_priority_range);\n}\n\nstatic void lpfc_vmid_put_cs_ctl(struct lpfc_vport *vport, u32 ctcl_vmid)\n{\n\tset_bit(ctcl_vmid, vport->vmid_priority_range);\n}\n\nu32 lpfc_vmid_get_cs_ctl(struct lpfc_vport *vport)\n{\n\tu32 i;\n\n\ti = find_first_bit(vport->vmid_priority_range,\n\t\t\t   LPFC_VMID_MAX_PRIORITY_RANGE);\n\n\tif (i == LPFC_VMID_MAX_PRIORITY_RANGE)\n\t\treturn 0;\n\n\tclear_bit(i, vport->vmid_priority_range);\n\treturn i;\n}\n\n#define MAX_PRIORITY_DESC\t255\n\nstatic void\nlpfc_cmpl_els_qfpa(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct priority_range_desc *desc;\n\tstruct lpfc_dmabuf *prsp = NULL;\n\tstruct lpfc_vmid_priority_range *vmid_range = NULL;\n\tu32 *data;\n\tstruct lpfc_dmabuf *dmabuf = cmdiocb->cmd_dmabuf;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\tu8 *pcmd, max_desc;\n\tu32 len, i;\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\n\tprsp = list_get_first(&dmabuf->list, struct lpfc_dmabuf, list);\n\tif (!prsp)\n\t\tgoto out;\n\n\tpcmd = prsp->virt;\n\tdata = (u32 *)pcmd;\n\tif (data[0] == ELS_CMD_LS_RJT) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_SLI,\n\t\t\t\t \"3277 QFPA LS_RJT x%x  x%x\\n\",\n\t\t\t\t data[0], data[1]);\n\t\tgoto out;\n\t}\n\tif (ulp_status) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_SLI,\n\t\t\t\t \"6529 QFPA failed with status x%x  x%x\\n\",\n\t\t\t\t ulp_status, ulp_word4);\n\t\tgoto out;\n\t}\n\n\tif (!vport->qfpa_res) {\n\t\tmax_desc = FCELSSIZE / sizeof(*vport->qfpa_res);\n\t\tvport->qfpa_res = kcalloc(max_desc, sizeof(*vport->qfpa_res),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!vport->qfpa_res)\n\t\t\tgoto out;\n\t}\n\n\tlen = *((u32 *)(pcmd + 4));\n\tlen = be32_to_cpu(len);\n\tmemcpy(vport->qfpa_res, pcmd, len + 8);\n\tlen = len / LPFC_PRIORITY_RANGE_DESC_SIZE;\n\n\tdesc = (struct priority_range_desc *)(pcmd + 8);\n\tvmid_range = vport->vmid_priority.vmid_range;\n\tif (!vmid_range) {\n\t\tvmid_range = kcalloc(MAX_PRIORITY_DESC, sizeof(*vmid_range),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!vmid_range) {\n\t\t\tkfree(vport->qfpa_res);\n\t\t\tgoto out;\n\t\t}\n\t\tvport->vmid_priority.vmid_range = vmid_range;\n\t}\n\tvport->vmid_priority.num_descriptors = len;\n\n\tfor (i = 0; i < len; i++, vmid_range++, desc++) {\n\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_ELS,\n\t\t\t\t \"6539 vmid values low=%d, high=%d, qos=%d, \"\n\t\t\t\t \"local ve id=%d\\n\", desc->lo_range,\n\t\t\t\t desc->hi_range, desc->qos_priority,\n\t\t\t\t desc->local_ve_id);\n\n\t\tvmid_range->low = desc->lo_range << 1;\n\t\tif (desc->local_ve_id == QFPA_ODD_ONLY)\n\t\t\tvmid_range->low++;\n\t\tif (desc->qos_priority)\n\t\t\tvport->vmid_flag |= LPFC_VMID_QOS_ENABLED;\n\t\tvmid_range->qos = desc->qos_priority;\n\n\t\tvmid_range->high = desc->hi_range << 1;\n\t\tif ((desc->local_ve_id == QFPA_ODD_ONLY) ||\n\t\t    (desc->local_ve_id == QFPA_EVEN_ODD))\n\t\t\tvmid_range->high++;\n\t}\n\tlpfc_init_cs_ctl_bitmap(vport);\n\tfor (i = 0; i < vport->vmid_priority.num_descriptors; i++) {\n\t\tlpfc_vmid_set_cs_ctl_range(vport,\n\t\t\t\tvport->vmid_priority.vmid_range[i].low,\n\t\t\t\tvport->vmid_priority.vmid_range[i].high);\n\t}\n\n\tvport->vmid_flag |= LPFC_VMID_QFPA_CMPL;\n out:\n\tlpfc_els_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\nint lpfc_issue_els_qfpa(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_iocbq *elsiocb;\n\tu8 *pcmd;\n\tint ret;\n\n\tndlp = lpfc_findnode_did(phba->pport, Fabric_DID);\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_UNMAPPED_NODE)\n\t\treturn -ENXIO;\n\n\telsiocb = lpfc_prep_els_iocb(vport, 1, LPFC_QFPA_SIZE, 2, ndlp,\n\t\t\t\t     ndlp->nlp_DID, ELS_CMD_QFPA);\n\tif (!elsiocb)\n\t\treturn -ENOMEM;\n\n\tpcmd = (u8 *)elsiocb->cmd_dmabuf->virt;\n\n\t*((u32 *)(pcmd)) = ELS_CMD_QFPA;\n\tpcmd += 4;\n\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_qfpa;\n\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(vport->phba, elsiocb);\n\t\treturn -ENXIO;\n\t}\n\n\tret = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, elsiocb, 2);\n\tif (ret != IOCB_SUCCESS) {\n\t\tlpfc_els_free_iocb(phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\treturn -EIO;\n\t}\n\tvport->vmid_flag &= ~LPFC_VMID_QOS_ENABLED;\n\treturn 0;\n}\n\nint\nlpfc_vmid_uvem(struct lpfc_vport *vport,\n\t       struct lpfc_vmid *vmid, bool instantiated)\n{\n\tstruct lpfc_vem_id_desc *vem_id_desc;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_iocbq *elsiocb;\n\tstruct instantiated_ve_desc *inst_desc;\n\tstruct lpfc_vmid_context *vmid_context;\n\tu8 *pcmd;\n\tu32 *len;\n\tint ret = 0;\n\n\tndlp = lpfc_findnode_did(vport, Fabric_DID);\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_UNMAPPED_NODE)\n\t\treturn -ENXIO;\n\n\tvmid_context = kmalloc(sizeof(*vmid_context), GFP_KERNEL);\n\tif (!vmid_context)\n\t\treturn -ENOMEM;\n\telsiocb = lpfc_prep_els_iocb(vport, 1, LPFC_UVEM_SIZE, 2,\n\t\t\t\t     ndlp, Fabric_DID, ELS_CMD_UVEM);\n\tif (!elsiocb)\n\t\tgoto out;\n\n\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_ELS,\n\t\t\t \"3427 Host vmid %s %d\\n\",\n\t\t\t vmid->host_vmid, instantiated);\n\tvmid_context->vmp = vmid;\n\tvmid_context->nlp = ndlp;\n\tvmid_context->instantiated = instantiated;\n\telsiocb->vmid_tag.vmid_context = vmid_context;\n\tpcmd = (u8 *)elsiocb->cmd_dmabuf->virt;\n\n\tif (!memchr_inv(vport->lpfc_vmid_host_uuid, 0,\n\t\t\tsizeof(vport->lpfc_vmid_host_uuid)))\n\t\tmemcpy(vport->lpfc_vmid_host_uuid, vmid->host_vmid,\n\t\t       sizeof(vport->lpfc_vmid_host_uuid));\n\n\t*((u32 *)(pcmd)) = ELS_CMD_UVEM;\n\tlen = (u32 *)(pcmd + 4);\n\t*len = cpu_to_be32(LPFC_UVEM_SIZE - 8);\n\n\tvem_id_desc = (struct lpfc_vem_id_desc *)(pcmd + 8);\n\tvem_id_desc->tag = be32_to_cpu(VEM_ID_DESC_TAG);\n\tvem_id_desc->length = be32_to_cpu(LPFC_UVEM_VEM_ID_DESC_SIZE);\n\tmemcpy(vem_id_desc->vem_id, vport->lpfc_vmid_host_uuid,\n\t       sizeof(vem_id_desc->vem_id));\n\n\tinst_desc = (struct instantiated_ve_desc *)(pcmd + 32);\n\tinst_desc->tag = be32_to_cpu(INSTANTIATED_VE_DESC_TAG);\n\tinst_desc->length = be32_to_cpu(LPFC_UVEM_VE_MAP_DESC_SIZE);\n\tmemcpy(inst_desc->global_vem_id, vmid->host_vmid,\n\t       sizeof(inst_desc->global_vem_id));\n\n\tbf_set(lpfc_instantiated_nport_id, inst_desc, vport->fc_myDID);\n\tbf_set(lpfc_instantiated_local_id, inst_desc,\n\t       vmid->un.cs_ctl_vmid);\n\tif (instantiated) {\n\t\tinst_desc->tag = be32_to_cpu(INSTANTIATED_VE_DESC_TAG);\n\t} else {\n\t\tinst_desc->tag = be32_to_cpu(DEINSTANTIATED_VE_DESC_TAG);\n\t\tlpfc_vmid_put_cs_ctl(vport, vmid->un.cs_ctl_vmid);\n\t}\n\tinst_desc->word6 = cpu_to_be32(inst_desc->word6);\n\n\telsiocb->cmd_cmpl = lpfc_cmpl_els_uvem;\n\n\telsiocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!elsiocb->ndlp) {\n\t\tlpfc_els_free_iocb(vport->phba, elsiocb);\n\t\tgoto out;\n\t}\n\n\tret = lpfc_sli_issue_iocb(vport->phba, LPFC_ELS_RING, elsiocb, 0);\n\tif (ret != IOCB_SUCCESS) {\n\t\tlpfc_els_free_iocb(vport->phba, elsiocb);\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n out:\n\tkfree(vmid_context);\n\treturn -EIO;\n}\n\nstatic void\nlpfc_cmpl_els_uvem(struct lpfc_hba *phba, struct lpfc_iocbq *icmdiocb,\n\t\t   struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = icmdiocb->vport;\n\tstruct lpfc_dmabuf *prsp = NULL;\n\tstruct lpfc_vmid_context *vmid_context =\n\t    icmdiocb->vmid_tag.vmid_context;\n\tstruct lpfc_nodelist *ndlp = icmdiocb->ndlp;\n\tu8 *pcmd;\n\tu32 *data;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\tstruct lpfc_dmabuf *dmabuf = icmdiocb->cmd_dmabuf;\n\tstruct lpfc_vmid *vmid;\n\n\tvmid = vmid_context->vmp;\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_UNMAPPED_NODE)\n\t\tndlp = NULL;\n\n\tprsp = list_get_first(&dmabuf->list, struct lpfc_dmabuf, list);\n\tif (!prsp)\n\t\tgoto out;\n\tpcmd = prsp->virt;\n\tdata = (u32 *)pcmd;\n\tif (data[0] == ELS_CMD_LS_RJT) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_SLI,\n\t\t\t\t \"4532 UVEM LS_RJT %x %x\\n\", data[0], data[1]);\n\t\tgoto out;\n\t}\n\tif (ulp_status) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_SLI,\n\t\t\t\t \"4533 UVEM error status %x: %x\\n\",\n\t\t\t\t ulp_status, ulp_word4);\n\t\tgoto out;\n\t}\n\tspin_lock(&phba->hbalock);\n\t \n\tvport->vmid_flag |= LPFC_VMID_IN_USE;\n\tphba->pport->vmid_flag |= LPFC_VMID_IN_USE;\n\tspin_unlock(&phba->hbalock);\n\n\tif (vmid_context->instantiated) {\n\t\twrite_lock(&vport->vmid_lock);\n\t\tvmid->flag |= LPFC_VMID_REGISTERED;\n\t\tvmid->flag &= ~LPFC_VMID_REQ_REGISTER;\n\t\twrite_unlock(&vport->vmid_lock);\n\t}\n\n out:\n\tkfree(vmid_context);\n\tlpfc_els_free_iocb(phba, icmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}