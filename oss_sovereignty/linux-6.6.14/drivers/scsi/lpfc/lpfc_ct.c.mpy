{
  "module_name": "lpfc_ct.c",
  "hash_id": "7e96b2c084efb53020f848ca0b94e04c888a8305eb3d371f609ad12b3dfc2d14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_ct.c",
  "human_readable_source": " \n\n \n\n#include <linux/blkdev.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/utsname.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_version.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_debugfs.h\"\n\n \n#define HBA_PORTSPEED_1GFC\t\t0x00000001\t \n#define HBA_PORTSPEED_2GFC\t\t0x00000002\t \n#define HBA_PORTSPEED_4GFC\t\t0x00000008\t \n#define HBA_PORTSPEED_10GFC\t\t0x00000004\t \n#define HBA_PORTSPEED_8GFC\t\t0x00000010\t \n#define HBA_PORTSPEED_16GFC\t\t0x00000020\t \n#define HBA_PORTSPEED_32GFC\t\t0x00000040\t \n#define HBA_PORTSPEED_20GFC\t\t0x00000080\t \n#define HBA_PORTSPEED_40GFC\t\t0x00000100\t \n#define HBA_PORTSPEED_128GFC\t\t0x00000200\t \n#define HBA_PORTSPEED_64GFC\t\t0x00000400\t \n#define HBA_PORTSPEED_256GFC\t\t0x00000800\t \n#define HBA_PORTSPEED_UNKNOWN\t\t0x00008000\t \n#define HBA_PORTSPEED_10GE\t\t0x00010000\t \n#define HBA_PORTSPEED_40GE\t\t0x00020000\t \n#define HBA_PORTSPEED_100GE\t\t0x00040000\t \n#define HBA_PORTSPEED_25GE\t\t0x00080000\t \n#define HBA_PORTSPEED_50GE\t\t0x00100000\t \n#define HBA_PORTSPEED_400GE\t\t0x00200000\t \n\n#define FOURBYTES\t4\n\n\nstatic char *lpfc_release_version = LPFC_DRIVER_VERSION;\nstatic void\nlpfc_cmpl_ct_cmd_vmid(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t      struct lpfc_iocbq *rspiocb);\n\nstatic void\nlpfc_ct_ignore_hbq_buffer(struct lpfc_hba *phba, struct lpfc_iocbq *piocbq,\n\t\t\t  struct lpfc_dmabuf *mp, uint32_t size)\n{\n\tif (!mp) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\t\"0146 Ignoring unsolicited CT No HBQ \"\n\t\t\t\t\"status = x%x\\n\",\n\t\t\t\tget_job_ulpstatus(phba, piocbq));\n\t}\n\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\"0145 Ignoring unsolicited CT HBQ Size:%d \"\n\t\t\t\"status = x%x\\n\",\n\t\t\tsize, get_job_ulpstatus(phba, piocbq));\n}\n\nstatic void\nlpfc_ct_unsol_buffer(struct lpfc_hba *phba, struct lpfc_iocbq *piocbq,\n\t\t     struct lpfc_dmabuf *mp, uint32_t size)\n{\n\tlpfc_ct_ignore_hbq_buffer(phba, piocbq, mp, size);\n}\n\n \nstatic void\nlpfc_ct_unsol_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t   struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_dmabuf *mp, *bmp;\n\n\tndlp = cmdiocb->ndlp;\n\tif (ndlp)\n\t\tlpfc_nlp_put(ndlp);\n\n\tmp = cmdiocb->rsp_dmabuf;\n\tbmp = cmdiocb->bpl_dmabuf;\n\tif (mp) {\n\t\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n\t\tkfree(mp);\n\t\tcmdiocb->rsp_dmabuf = NULL;\n\t}\n\n\tif (bmp) {\n\t\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\n\t\tkfree(bmp);\n\t\tcmdiocb->bpl_dmabuf = NULL;\n\t}\n\n\tlpfc_sli_release_iocbq(phba, cmdiocb);\n}\n\n \nstatic void\nlpfc_ct_reject_event(struct lpfc_nodelist *ndlp,\n\t\t     struct lpfc_sli_ct_request *ct_req,\n\t\t     u16 ulp_context, u16 ox_id)\n{\n\tstruct lpfc_vport *vport = ndlp->vport;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_sli_ct_request *ct_rsp;\n\tstruct lpfc_iocbq *cmdiocbq = NULL;\n\tstruct lpfc_dmabuf *bmp = NULL;\n\tstruct lpfc_dmabuf *mp = NULL;\n\tstruct ulp_bde64 *bpl;\n\tu8 rc = 0;\n\tu32 tmo;\n\n\t \n\tmp = kmalloc(sizeof(*mp), GFP_KERNEL);\n\tif (!mp) {\n\t\trc = 1;\n\t\tgoto ct_exit;\n\t}\n\n\tmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &mp->phys);\n\tif (!mp->virt) {\n\t\trc = 2;\n\t\tgoto ct_free_mp;\n\t}\n\n\t \n\tbmp = kmalloc(sizeof(*bmp), GFP_KERNEL);\n\tif (!bmp) {\n\t\trc = 3;\n\t\tgoto ct_free_mpvirt;\n\t}\n\n\tbmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &bmp->phys);\n\tif (!bmp->virt) {\n\t\trc = 4;\n\t\tgoto ct_free_bmp;\n\t}\n\n\tINIT_LIST_HEAD(&mp->list);\n\tINIT_LIST_HEAD(&bmp->list);\n\n\tbpl = (struct ulp_bde64 *)bmp->virt;\n\tmemset(bpl, 0, sizeof(struct ulp_bde64));\n\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys));\n\tbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys));\n\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\tbpl->tus.f.bdeSize = (LPFC_CT_PREAMBLE - 4);\n\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\n\tct_rsp = (struct lpfc_sli_ct_request *)mp->virt;\n\tmemset(ct_rsp, 0, sizeof(struct lpfc_sli_ct_request));\n\n\tct_rsp->RevisionId.bits.Revision = SLI_CT_REVISION;\n\tct_rsp->RevisionId.bits.InId = 0;\n\tct_rsp->FsType = ct_req->FsType;\n\tct_rsp->FsSubType = ct_req->FsSubType;\n\tct_rsp->CommandResponse.bits.Size = 0;\n\tct_rsp->CommandResponse.bits.CmdRsp =\n\t\tcpu_to_be16(SLI_CT_RESPONSE_FS_RJT);\n\tct_rsp->ReasonCode = SLI_CT_REQ_NOT_SUPPORTED;\n\tct_rsp->Explanation = SLI_CT_NO_ADDITIONAL_EXPL;\n\n\tcmdiocbq = lpfc_sli_get_iocbq(phba);\n\tif (!cmdiocbq) {\n\t\trc = 5;\n\t\tgoto ct_free_bmpvirt;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tlpfc_sli_prep_xmit_seq64(phba, cmdiocbq, bmp,\n\t\t\t\t\t phba->sli4_hba.rpi_ids[ndlp->nlp_rpi],\n\t\t\t\t\t ox_id, 1, FC_RCTL_DD_SOL_CTL, 1,\n\t\t\t\t\t CMD_XMIT_SEQUENCE64_WQE);\n\t} else {\n\t\tlpfc_sli_prep_xmit_seq64(phba, cmdiocbq, bmp, 0, ulp_context, 1,\n\t\t\t\t\t FC_RCTL_DD_SOL_CTL, 1,\n\t\t\t\t\t CMD_XMIT_SEQUENCE64_CX);\n\t}\n\n\t \n\tcmdiocbq->rsp_dmabuf = mp;\n\tcmdiocbq->bpl_dmabuf = bmp;\n\tcmdiocbq->cmd_cmpl = lpfc_ct_unsol_cmpl;\n\ttmo = (3 * phba->fc_ratov);\n\n\tcmdiocbq->retry = 0;\n\tcmdiocbq->vport = vport;\n\tcmdiocbq->drvrTimeout = tmo + LPFC_DRVR_TIMEOUT;\n\n\tcmdiocbq->ndlp = lpfc_nlp_get(ndlp);\n\tif (!cmdiocbq->ndlp)\n\t\tgoto ct_no_ndlp;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq, 0);\n\tif (rc) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto ct_no_ndlp;\n\t}\n\treturn;\n\nct_no_ndlp:\n\trc = 6;\n\tlpfc_sli_release_iocbq(phba, cmdiocbq);\nct_free_bmpvirt:\n\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\nct_free_bmp:\n\tkfree(bmp);\nct_free_mpvirt:\n\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\nct_free_mp:\n\tkfree(mp);\nct_exit:\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_ELS,\n\t\t\t \"6440 Unsol CT: Rsp err %d Data: x%x\\n\",\n\t\t\t rc, vport->fc_flag);\n}\n\n \nstatic void\nlpfc_ct_handle_mibreq(struct lpfc_hba *phba, struct lpfc_iocbq *ctiocbq)\n{\n\tstruct lpfc_sli_ct_request *ct_req;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tstruct lpfc_vport *vport = ctiocbq->vport;\n\tu32 ulp_status = get_job_ulpstatus(phba, ctiocbq);\n\tu32 ulp_word4 = get_job_word4(phba, ctiocbq);\n\tu32 did;\n\tu16 mi_cmd;\n\n\tdid = bf_get(els_rsp64_sid, &ctiocbq->wqe.xmit_els_rsp);\n\tif (ulp_status) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"6438 Unsol CT: status:x%x/x%x did : x%x\\n\",\n\t\t\t\t ulp_status, ulp_word4, did);\n\t\treturn;\n\t}\n\n\t \n\tif (vport->fc_flag & FC_UNLOADING)\n\t\treturn;\n\n\tndlp = lpfc_findnode_did(vport, did);\n\tif (!ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"6439 Unsol CT: NDLP Not Found for DID : x%x\",\n\t\t\t\t did);\n\t\treturn;\n\t}\n\n\tct_req = (struct lpfc_sli_ct_request *)ctiocbq->cmd_dmabuf->virt;\n\n\tmi_cmd = be16_to_cpu(ct_req->CommandResponse.bits.CmdRsp);\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"6442 : MI Cmd : x%x Not Supported\\n\", mi_cmd);\n\tlpfc_ct_reject_event(ndlp, ct_req,\n\t\t\t     bf_get(wqe_ctxt_tag,\n\t\t\t\t    &ctiocbq->wqe.xmit_els_rsp.wqe_com),\n\t\t\t     bf_get(wqe_rcvoxid,\n\t\t\t\t    &ctiocbq->wqe.xmit_els_rsp.wqe_com));\n}\n\n \nvoid\nlpfc_ct_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\n\t\t    struct lpfc_iocbq *ctiocbq)\n{\n\tstruct lpfc_dmabuf *mp = NULL;\n\tIOCB_t *icmd = &ctiocbq->iocb;\n\tint i;\n\tstruct lpfc_iocbq *iocbq;\n\tstruct lpfc_iocbq *iocb;\n\tdma_addr_t dma_addr;\n\tuint32_t size;\n\tstruct list_head head;\n\tstruct lpfc_sli_ct_request *ct_req;\n\tstruct lpfc_dmabuf *bdeBuf1 = ctiocbq->cmd_dmabuf;\n\tstruct lpfc_dmabuf *bdeBuf2 = ctiocbq->bpl_dmabuf;\n\tu32 status, parameter, bde_count = 0;\n\tstruct lpfc_wcqe_complete *wcqe_cmpl = NULL;\n\n\tctiocbq->cmd_dmabuf = NULL;\n\tctiocbq->rsp_dmabuf = NULL;\n\tctiocbq->bpl_dmabuf = NULL;\n\n\twcqe_cmpl = &ctiocbq->wcqe_cmpl;\n\tstatus = get_job_ulpstatus(phba, ctiocbq);\n\tparameter = get_job_word4(phba, ctiocbq);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tbde_count = wcqe_cmpl->word3;\n\telse\n\t\tbde_count = icmd->ulpBdeCount;\n\n\tif (unlikely(status == IOSTAT_NEED_BUFFER)) {\n\t\tlpfc_sli_hbqbuf_add_hbqs(phba, LPFC_ELS_HBQ);\n\t} else if ((status == IOSTAT_LOCAL_REJECT) &&\n\t\t   ((parameter & IOERR_PARAM_MASK) ==\n\t\t   IOERR_RCV_BUFFER_WAITING)) {\n\t\t \n\t\tphba->fc_stat.NoRcvBuf++;\n\t\tif (!(phba->sli3_options & LPFC_SLI3_HBQ_ENABLED))\n\t\t\tlpfc_sli3_post_buffer(phba, pring, 2);\n\t\treturn;\n\t}\n\n\t \n\tif (bde_count == 0)\n\t\treturn;\n\n\tctiocbq->cmd_dmabuf = bdeBuf1;\n\tif (bde_count == 2)\n\t\tctiocbq->bpl_dmabuf = bdeBuf2;\n\n\tct_req = (struct lpfc_sli_ct_request *)ctiocbq->cmd_dmabuf->virt;\n\n\tif (ct_req->FsType == SLI_CT_MANAGEMENT_SERVICE &&\n\t    ct_req->FsSubType == SLI_CT_MIB_Subtypes) {\n\t\tlpfc_ct_handle_mibreq(phba, ctiocbq);\n\t} else {\n\t\tif (!lpfc_bsg_ct_unsol_event(phba, pring, ctiocbq))\n\t\t\treturn;\n\t}\n\n\tif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\n\t\tINIT_LIST_HEAD(&head);\n\t\tlist_add_tail(&head, &ctiocbq->list);\n\t\tlist_for_each_entry(iocb, &head, list) {\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\tbde_count = iocb->wcqe_cmpl.word3;\n\t\t\telse\n\t\t\t\tbde_count = iocb->iocb.ulpBdeCount;\n\n\t\t\tif (!bde_count)\n\t\t\t\tcontinue;\n\t\t\tbdeBuf1 = iocb->cmd_dmabuf;\n\t\t\tiocb->cmd_dmabuf = NULL;\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\tsize = iocb->wqe.gen_req.bde.tus.f.bdeSize;\n\t\t\telse\n\t\t\t\tsize  = iocb->iocb.un.cont64[0].tus.f.bdeSize;\n\t\t\tlpfc_ct_unsol_buffer(phba, ctiocbq, bdeBuf1, size);\n\t\t\tlpfc_in_buf_free(phba, bdeBuf1);\n\t\t\tif (bde_count == 2) {\n\t\t\t\tbdeBuf2 = iocb->bpl_dmabuf;\n\t\t\t\tiocb->bpl_dmabuf = NULL;\n\t\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\t\tsize = iocb->unsol_rcv_len;\n\t\t\t\telse\n\t\t\t\t\tsize = iocb->iocb.unsli3.rcvsli3.bde2.tus.f.bdeSize;\n\t\t\t\tlpfc_ct_unsol_buffer(phba, ctiocbq, bdeBuf2,\n\t\t\t\t\t\t     size);\n\t\t\t\tlpfc_in_buf_free(phba, bdeBuf2);\n\t\t\t}\n\t\t}\n\t\tlist_del(&head);\n\t} else {\n\t\tINIT_LIST_HEAD(&head);\n\t\tlist_add_tail(&head, &ctiocbq->list);\n\t\tlist_for_each_entry(iocbq, &head, list) {\n\t\t\ticmd = &iocbq->iocb;\n\t\t\tif (icmd->ulpBdeCount == 0)\n\t\t\t\tlpfc_ct_unsol_buffer(phba, iocbq, NULL, 0);\n\t\t\tfor (i = 0; i < icmd->ulpBdeCount; i++) {\n\t\t\t\tdma_addr = getPaddr(icmd->un.cont64[i].addrHigh,\n\t\t\t\t\t\t    icmd->un.cont64[i].addrLow);\n\t\t\t\tmp = lpfc_sli_ringpostbuf_get(phba, pring,\n\t\t\t\t\t\t\t      dma_addr);\n\t\t\t\tsize = icmd->un.cont64[i].tus.f.bdeSize;\n\t\t\t\tlpfc_ct_unsol_buffer(phba, iocbq, mp, size);\n\t\t\t\tlpfc_in_buf_free(phba, mp);\n\t\t\t}\n\t\t\tlpfc_sli3_post_buffer(phba, pring, i);\n\t\t}\n\t\tlist_del(&head);\n\t}\n}\n\n \nint\nlpfc_ct_handle_unsol_abort(struct lpfc_hba *phba, struct hbq_dmabuf *dmabuf)\n{\n\tint handled;\n\n\t \n\thandled = lpfc_bsg_ct_unsol_abort(phba, dmabuf);\n\n\treturn handled;\n}\n\nstatic void\nlpfc_free_ct_rsp(struct lpfc_hba *phba, struct lpfc_dmabuf *mlist)\n{\n\tstruct lpfc_dmabuf *mlast, *next_mlast;\n\n\tlist_for_each_entry_safe(mlast, next_mlast, &mlist->list, list) {\n\t\tlist_del(&mlast->list);\n\t\tlpfc_mbuf_free(phba, mlast->virt, mlast->phys);\n\t\tkfree(mlast);\n\t}\n\tlpfc_mbuf_free(phba, mlist->virt, mlist->phys);\n\tkfree(mlist);\n\treturn;\n}\n\nstatic struct lpfc_dmabuf *\nlpfc_alloc_ct_rsp(struct lpfc_hba *phba, __be16 cmdcode, struct ulp_bde64 *bpl,\n\t\t  uint32_t size, int *entries)\n{\n\tstruct lpfc_dmabuf *mlist = NULL;\n\tstruct lpfc_dmabuf *mp;\n\tint cnt, i = 0;\n\n\t \n\tcnt = size > FCELSSIZE ? FCELSSIZE: size;\n\n\twhile (size) {\n\t\t \n\t\tmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\t\tif (!mp) {\n\t\t\tif (mlist)\n\t\t\t\tlpfc_free_ct_rsp(phba, mlist);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&mp->list);\n\n\t\tif (be16_to_cpu(cmdcode) == SLI_CTNS_GID_FT ||\n\t\t    be16_to_cpu(cmdcode) == SLI_CTNS_GFF_ID)\n\t\t\tmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));\n\t\telse\n\t\t\tmp->virt = lpfc_mbuf_alloc(phba, 0, &(mp->phys));\n\n\t\tif (!mp->virt) {\n\t\t\tkfree(mp);\n\t\t\tif (mlist)\n\t\t\t\tlpfc_free_ct_rsp(phba, mlist);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (!mlist)\n\t\t\tmlist = mp;\n\t\telse\n\t\t\tlist_add_tail(&mp->list, &mlist->list);\n\n\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\n\t\t \n\t\tbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys) );\n\t\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys) );\n\t\tbpl->tus.f.bdeSize = (uint16_t) cnt;\n\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t\tbpl++;\n\n\t\ti++;\n\t\tsize -= cnt;\n\t}\n\n\t*entries = i;\n\treturn mlist;\n}\n\nint\nlpfc_ct_free_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *ctiocb)\n{\n\tstruct lpfc_dmabuf *buf_ptr;\n\n\t \n\tif (ctiocb->cmd_dmabuf) {\n\t\tbuf_ptr = ctiocb->cmd_dmabuf;\n\t\tlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\n\t\tkfree(buf_ptr);\n\t\tctiocb->cmd_dmabuf = NULL;\n\t}\n\tif (ctiocb->rsp_dmabuf) {\n\t\tlpfc_free_ct_rsp(phba, ctiocb->rsp_dmabuf);\n\t\tctiocb->rsp_dmabuf = NULL;\n\t}\n\n\tif (ctiocb->bpl_dmabuf) {\n\t\tbuf_ptr = ctiocb->bpl_dmabuf;\n\t\tlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\n\t\tkfree(buf_ptr);\n\t\tctiocb->bpl_dmabuf = NULL;\n\t}\n\tlpfc_sli_release_iocbq(phba, ctiocb);\n\treturn 0;\n}\n\n \nstatic int\nlpfc_gen_req(struct lpfc_vport *vport, struct lpfc_dmabuf *bmp,\n\t     struct lpfc_dmabuf *inp, struct lpfc_dmabuf *outp,\n\t     void (*cmpl)(struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t\t  struct lpfc_iocbq *),\n\t     struct lpfc_nodelist *ndlp, uint32_t event_tag, uint32_t num_entry,\n\t     uint32_t tmo, uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_iocbq *geniocb;\n\tint rc;\n\tu16 ulp_context;\n\n\t \n\tgeniocb = lpfc_sli_get_iocbq(phba);\n\n\tif (geniocb == NULL)\n\t\treturn 1;\n\n\t \n\tgeniocb->num_bdes = num_entry;\n\n\tgeniocb->bpl_dmabuf = bmp;\n\n\t \n\tgeniocb->cmd_dmabuf = inp;\n\tgeniocb->rsp_dmabuf = outp;\n\n\tgeniocb->event_tag = event_tag;\n\n\tif (!tmo) {\n\t\t  \n\t\ttmo = (3 * phba->fc_ratov);\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tulp_context = phba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\n\telse\n\t\tulp_context = ndlp->nlp_rpi;\n\n\tlpfc_sli_prep_gen_req(phba, geniocb, bmp, ulp_context, num_entry, tmo);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t \"0119 Issue GEN REQ IOCB to NPORT x%x \"\n\t\t\t \"Data: x%x x%x\\n\",\n\t\t\t ndlp->nlp_DID, geniocb->iotag,\n\t\t\t vport->port_state);\n\tgeniocb->cmd_cmpl = cmpl;\n\tgeniocb->drvrTimeout = tmo + LPFC_DRVR_TIMEOUT;\n\tgeniocb->vport = vport;\n\tgeniocb->retry = retry;\n\tgeniocb->ndlp = lpfc_nlp_get(ndlp);\n\tif (!geniocb->ndlp)\n\t\tgoto out;\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, geniocb, 0);\n\tif (rc == IOCB_ERROR) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\tlpfc_sli_release_iocbq(phba, geniocb);\n\treturn 1;\n}\n\n \nstatic int\nlpfc_ct_cmd(struct lpfc_vport *vport, struct lpfc_dmabuf *inmp,\n\t    struct lpfc_dmabuf *bmp, struct lpfc_nodelist *ndlp,\n\t    void (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t\t  struct lpfc_iocbq *),\n\t    uint32_t rsp_size, uint8_t retry)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct ulp_bde64 *bpl = (struct ulp_bde64 *) bmp->virt;\n\tstruct lpfc_dmabuf *outmp;\n\tint cnt = 0, status;\n\t__be16 cmdcode = ((struct lpfc_sli_ct_request *)inmp->virt)->\n\t\tCommandResponse.bits.CmdRsp;\n\n\tbpl++;\t\t\t \n\n\t \n\toutmp = lpfc_alloc_ct_rsp(phba, cmdcode, bpl, rsp_size, &cnt);\n\tif (!outmp)\n\t\treturn -ENOMEM;\n\t \n\tcnt += 1;\n\tstatus = lpfc_gen_req(vport, bmp, inmp, outmp, cmpl, ndlp,\n\t\t\tphba->fc_eventTag, cnt, 0, retry);\n\tif (status) {\n\t\tlpfc_free_ct_rsp(phba, outmp);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstruct lpfc_vport *\nlpfc_find_vport_by_did(struct lpfc_hba *phba, uint32_t did) {\n\tstruct lpfc_vport *vport_curr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phba->port_list_lock, flags);\n\tlist_for_each_entry(vport_curr, &phba->port_list, listentry) {\n\t\tif ((vport_curr->fc_myDID) && (vport_curr->fc_myDID == did)) {\n\t\t\tspin_unlock_irqrestore(&phba->port_list_lock, flags);\n\t\t\treturn vport_curr;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->port_list_lock, flags);\n\treturn NULL;\n}\n\nstatic void\nlpfc_prep_node_fc4type(struct lpfc_vport *vport, uint32_t Did, uint8_t fc4_type)\n{\n\tstruct lpfc_nodelist *ndlp;\n\n\tif ((vport->port_type != LPFC_NPIV_PORT) ||\n\t    !(vport->ct_flags & FC_CT_RFF_ID) || !vport->cfg_restrict_login) {\n\n\t\tndlp = lpfc_setup_disc_node(vport, Did);\n\n\t\tif (ndlp) {\n\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"Parse GID_FTrsp: did:x%x flg:x%x x%x\",\n\t\t\t\tDid, ndlp->nlp_flag, vport->fc_flag);\n\n\t\t\t \n\t\t\tif (fc4_type == FC_TYPE_FCP)\n\t\t\t\tndlp->nlp_fc4_type |= NLP_FC4_FCP;\n\n\t\t\tif (fc4_type == FC_TYPE_NVME)\n\t\t\t\tndlp->nlp_fc4_type |= NLP_FC4_NVME;\n\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0238 Process x%06x NameServer Rsp \"\n\t\t\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\", Did,\n\t\t\t\t\t ndlp->nlp_flag, ndlp->nlp_fc4_type,\n\t\t\t\t\t ndlp->nlp_state, vport->fc_flag,\n\t\t\t\t\t vport->fc_rscn_id_cnt);\n\n\t\t\t \n\t\t\tif (ndlp->nlp_flag & NLP_NPR_2B_DISC &&\n\t\t\t    ndlp->nlp_state == NLP_STE_UNUSED_NODE) {\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t   NLP_STE_NPR_NODE);\n\t\t\t}\n\t\t} else {\n\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"Skip1 GID_FTrsp: did:x%x flg:x%x cnt:%d\",\n\t\t\t\tDid, vport->fc_flag, vport->fc_rscn_id_cnt);\n\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0239 Skip x%06x NameServer Rsp \"\n\t\t\t\t\t \"Data: x%x x%x x%px\\n\",\n\t\t\t\t\t Did, vport->fc_flag,\n\t\t\t\t\t vport->fc_rscn_id_cnt, ndlp);\n\t\t}\n\t} else {\n\t\tif (!(vport->fc_flag & FC_RSCN_MODE) ||\n\t\t    lpfc_rscn_payload_check(vport, Did)) {\n\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"Query GID_FTrsp: did:x%x flg:x%x cnt:%d\",\n\t\t\t\tDid, vport->fc_flag, vport->fc_rscn_id_cnt);\n\n\t\t\t \n\t\t\tndlp = lpfc_findnode_did(vport, Did);\n\t\t\tif (ndlp &&\n\t\t\t    (ndlp->nlp_type &\n\t\t\t    (NLP_FCP_TARGET | NLP_NVME_TARGET))) {\n\t\t\t\tif (fc4_type == FC_TYPE_FCP)\n\t\t\t\t\tndlp->nlp_fc4_type |= NLP_FC4_FCP;\n\t\t\t\tif (fc4_type == FC_TYPE_NVME)\n\t\t\t\t\tndlp->nlp_fc4_type |= NLP_FC4_NVME;\n\t\t\t\tlpfc_setup_disc_node(vport, Did);\n\t\t\t} else if (lpfc_ns_cmd(vport, SLI_CTNS_GFF_ID,\n\t\t\t\t   0, Did) == 0)\n\t\t\t\tvport->num_disc_nodes++;\n\t\t\telse\n\t\t\t\tlpfc_setup_disc_node(vport, Did);\n\t\t} else {\n\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"Skip2 GID_FTrsp: did:x%x flg:x%x cnt:%d\",\n\t\t\t\tDid, vport->fc_flag, vport->fc_rscn_id_cnt);\n\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0245 Skip x%06x NameServer Rsp \"\n\t\t\t\t\t \"Data: x%x x%x\\n\", Did,\n\t\t\t\t\t vport->fc_flag,\n\t\t\t\t\t vport->fc_rscn_id_cnt);\n\t\t}\n\t}\n}\n\nstatic void\nlpfc_ns_rsp_audit_did(struct lpfc_vport *vport, uint32_t Did, uint8_t fc4_type)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tchar *str;\n\n\tif (phba->cfg_ns_query == LPFC_NS_QUERY_GID_FT)\n\t\tstr = \"GID_FT\";\n\telse\n\t\tstr = \"GID_PT\";\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"6430 Process %s rsp for %08x type %x %s %s\\n\",\n\t\t\t str, Did, fc4_type,\n\t\t\t (fc4_type == FC_TYPE_FCP) ?  \"FCP\" : \" \",\n\t\t\t (fc4_type == FC_TYPE_NVME) ?  \"NVME\" : \" \");\n\t \n\tif (Did != vport->fc_myDID &&\n\t    (!lpfc_find_vport_by_did(phba, Did) ||\n\t     vport->cfg_peer_port_login)) {\n\t\tif (!phba->nvmet_support) {\n\t\t\t \n\t\t\tlpfc_prep_node_fc4type(vport, Did, fc4_type);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\t\tif (ndlp->nlp_type != NLP_NVME_INITIATOR ||\n\t\t\t    ndlp->nlp_state != NLP_STE_UNMAPPED_NODE)\n\t\t\t\tcontinue;\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tif (ndlp->nlp_DID == Did)\n\t\t\t\tndlp->nlp_flag &= ~NLP_NVMET_RECOV;\n\t\t\telse\n\t\t\t\tndlp->nlp_flag |= NLP_NVMET_RECOV;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t}\n\t}\n}\n\nstatic int\nlpfc_ns_rsp(struct lpfc_vport *vport, struct lpfc_dmabuf *mp, uint8_t fc4_type,\n\t    uint32_t Size)\n{\n\tstruct lpfc_sli_ct_request *Response =\n\t\t(struct lpfc_sli_ct_request *) mp->virt;\n\tstruct lpfc_dmabuf *mlast, *next_mp;\n\tuint32_t *ctptr = (uint32_t *) & Response->un.gid.PortType;\n\tuint32_t Did, CTentry;\n\tint Cnt;\n\tstruct list_head head;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\n\tlpfc_set_disctmo(vport);\n\tvport->num_disc_nodes = 0;\n\tvport->fc_ns_retry = 0;\n\n\n\tlist_add_tail(&head, &mp->list);\n\tlist_for_each_entry_safe(mp, next_mp, &head, list) {\n\t\tmlast = mp;\n\n\t\tCnt = Size  > FCELSSIZE ? FCELSSIZE : Size;\n\n\t\tSize -= Cnt;\n\n\t\tif (!ctptr) {\n\t\t\tctptr = (uint32_t *) mlast->virt;\n\t\t} else\n\t\t\tCnt -= 16;\t \n\n\t\t \n\t\twhile (Cnt >= sizeof(uint32_t)) {\n\t\t\t \n\t\t\tCTentry = *ctptr++;\n\t\t\tDid = ((be32_to_cpu(CTentry)) & Mask_DID);\n\t\t\tlpfc_ns_rsp_audit_did(vport, Did, fc4_type);\n\t\t\tif (CTentry & (cpu_to_be32(SLI_CT_LAST_ENTRY)))\n\t\t\t\tgoto nsout1;\n\n\t\t\tCnt -= sizeof(uint32_t);\n\t\t}\n\t\tctptr = NULL;\n\n\t}\n\n\t \n\tif (vport->phba->nvmet_support) {\n\t\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\t\tif (!(ndlp->nlp_flag & NLP_NVMET_RECOV))\n\t\t\t\tcontinue;\n\t\t\tlpfc_disc_state_machine(vport, ndlp, NULL,\n\t\t\t\t\t\tNLP_EVT_DEVICE_RECOVERY);\n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nlp_flag &= ~NLP_NVMET_RECOV;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t}\n\t}\n\nnsout1:\n\tlist_del(&head);\n\treturn 0;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_gid_ft(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_dmabuf *outp;\n\tstruct lpfc_dmabuf *inp;\n\tstruct lpfc_sli_ct_request *CTrsp;\n\tstruct lpfc_sli_ct_request *CTreq;\n\tstruct lpfc_nodelist *ndlp;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\tint rc, type;\n\n\t \n\tndlp = cmdiocb->ndlp;\n\n\t \n\tcmdiocb->rsp_iocb = rspiocb;\n\tinp = cmdiocb->cmd_dmabuf;\n\toutp = cmdiocb->rsp_dmabuf;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t \"GID_FT cmpl:     status:x%x/x%x rtry:%d\",\n\t\tulp_status, ulp_word4, vport->fc_ns_retry);\n\n\t \n\tif (cmdiocb->event_tag != phba->fc_eventTag) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"9043 Event tag mismatch. Ignoring NS rsp\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (vport->load_flag & FC_UNLOADING) {\n\t\tif (vport->fc_flag & FC_RSCN_MODE)\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\tgoto out;\n\t}\n\n\tif (lpfc_els_chk_latt(vport)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"0216 Link event during NS query\\n\");\n\t\tif (vport->fc_flag & FC_RSCN_MODE)\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tgoto out;\n\t}\n\tif (lpfc_error_lost_link(vport, ulp_status, ulp_word4)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"0226 NS query failed due to link event: \"\n\t\t\t\t \"ulp_status x%x ulp_word4 x%x fc_flag x%x \"\n\t\t\t\t \"port_state x%x gidft_inp x%x\\n\",\n\t\t\t\t ulp_status, ulp_word4, vport->fc_flag,\n\t\t\t\t vport->port_state, vport->gidft_inp);\n\t\tif (vport->fc_flag & FC_RSCN_MODE)\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\tif (vport->gidft_inp)\n\t\t\tvport->gidft_inp--;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_flag & FC_RSCN_DEFERRED) {\n\t\tvport->fc_flag &= ~FC_RSCN_DEFERRED;\n\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t \n\t\tif (vport->gidft_inp)\n\t\t\tvport->gidft_inp--;\n\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"0151 Process Deferred RSCN Data: x%x x%x\\n\",\n\t\t\t\t vport->fc_flag, vport->fc_rscn_id_cnt);\n\t\tlpfc_els_handle_rscn(vport);\n\n\t\tgoto out;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\n\tif (ulp_status) {\n\t\t \n\t\tif (vport->fc_ns_retry < LPFC_MAX_NS_RETRY) {\n\t\t\tif (ulp_status != IOSTAT_LOCAL_REJECT ||\n\t\t\t    (ulp_word4 & IOERR_PARAM_MASK) !=\n\t\t\t    IOERR_NO_RESOURCES)\n\t\t\t\tvport->fc_ns_retry++;\n\n\t\t\ttype = lpfc_get_gidft_type(vport, cmdiocb);\n\t\t\tif (type == 0)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\trc = lpfc_ns_cmd(vport, SLI_CTNS_GID_FT,\n\t\t\t\t\t vport->fc_ns_retry, type);\n\t\t\tif (rc == 0)\n\t\t\t\tgoto out;\n\t\t\telse {  \n\t\t\t\tif (vport->gidft_inp)\n\t\t\t\t\tvport->gidft_inp--;\n\t\t\t}\n\t\t}\n\t\tif (vport->fc_flag & FC_RSCN_MODE)\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0257 GID_FT Query error: 0x%x 0x%x\\n\",\n\t\t\t\t ulp_status, vport->fc_ns_retry);\n\t} else {\n\t\t \n\t\tCTreq = (struct lpfc_sli_ct_request *) inp->virt;\n\t\tCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\n\t\tif (CTrsp->CommandResponse.bits.CmdRsp ==\n\t\t    cpu_to_be16(SLI_CT_RESPONSE_FS_ACC)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"0208 NameServer Rsp Data: x%x x%x \"\n\t\t\t\t\t \"x%x x%x sz x%x\\n\",\n\t\t\t\t\t vport->fc_flag,\n\t\t\t\t\t CTreq->un.gid.Fc4Type,\n\t\t\t\t\t vport->num_disc_nodes,\n\t\t\t\t\t vport->gidft_inp,\n\t\t\t\t\t get_job_data_placed(phba, rspiocb));\n\n\t\t\tlpfc_ns_rsp(vport,\n\t\t\t\t    outp,\n\t\t\t\t    CTreq->un.gid.Fc4Type,\n\t\t\t\t    get_job_data_placed(phba, rspiocb));\n\t\t} else if (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t\t   SLI_CT_RESPONSE_FS_RJT) {\n\t\t\t \n\t\t\tif ((CTrsp->ReasonCode == SLI_CT_UNABLE_TO_PERFORM_REQ)\n\t\t\t    && (CTrsp->Explanation == SLI_CT_NO_FC4_TYPES)) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\tLOG_DISCOVERY,\n\t\t\t\t\t\"0269 No NameServer Entries \"\n\t\t\t\t\t\"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t\t(uint32_t) CTrsp->ReasonCode,\n\t\t\t\t\t(uint32_t) CTrsp->Explanation,\n\t\t\t\t\tvport->fc_flag);\n\n\t\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"GID_FT no entry  cmd:x%x rsn:x%x exp:x%x\",\n\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t(uint32_t) CTrsp->ReasonCode,\n\t\t\t\t(uint32_t) CTrsp->Explanation);\n\t\t\t} else {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\tLOG_DISCOVERY,\n\t\t\t\t\t\"0240 NameServer Rsp Error \"\n\t\t\t\t\t\"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t\t(uint32_t) CTrsp->ReasonCode,\n\t\t\t\t\t(uint32_t) CTrsp->Explanation,\n\t\t\t\t\tvport->fc_flag);\n\n\t\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"GID_FT rsp err1  cmd:x%x rsn:x%x exp:x%x\",\n\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t(uint32_t) CTrsp->ReasonCode,\n\t\t\t\t(uint32_t) CTrsp->Explanation);\n\t\t\t}\n\n\n\t\t} else {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0241 NameServer Rsp Error \"\n\t\t\t\t\t\"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t\t(uint32_t) CTrsp->ReasonCode,\n\t\t\t\t\t(uint32_t) CTrsp->Explanation,\n\t\t\t\t\tvport->fc_flag);\n\n\t\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"GID_FT rsp err2  cmd:x%x rsn:x%x exp:x%x\",\n\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t(uint32_t) CTrsp->ReasonCode,\n\t\t\t\t(uint32_t) CTrsp->Explanation);\n\t\t}\n\t\tif (vport->gidft_inp)\n\t\t\tvport->gidft_inp--;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"4216 GID_FT cmpl inp %d disc %d\\n\",\n\t\t\t vport->gidft_inp, vport->num_disc_nodes);\n\n\t \n\tif ((vport->num_disc_nodes == 0) &&\n\t    (vport->gidft_inp == 0)) {\n\t\t \n\t\tif (vport->port_state >= LPFC_DISC_AUTH) {\n\t\t\tif (vport->fc_flag & FC_RSCN_MODE) {\n\t\t\t\tlpfc_els_flush_rscn(vport);\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag |= FC_RSCN_MODE;  \n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlpfc_els_flush_rscn(vport);\n\t\t}\n\n\t\tlpfc_disc_start(vport);\n\t}\nout:\n\tlpfc_ct_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_gid_pt(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_dmabuf *outp;\n\tstruct lpfc_dmabuf *inp;\n\tstruct lpfc_sli_ct_request *CTrsp;\n\tstruct lpfc_sli_ct_request *CTreq;\n\tstruct lpfc_nodelist *ndlp;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\tint rc;\n\n\t \n\tndlp = cmdiocb->ndlp;\n\n\t \n\tcmdiocb->rsp_iocb = rspiocb;\n\tinp = cmdiocb->cmd_dmabuf;\n\toutp = cmdiocb->rsp_dmabuf;\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t      \"GID_PT cmpl:     status:x%x/x%x rtry:%d\",\n\t\t\t      ulp_status, ulp_word4,\n\t\t\t      vport->fc_ns_retry);\n\n\t \n\tif (cmdiocb->event_tag != phba->fc_eventTag) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"9044 Event tag mismatch. Ignoring NS rsp\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (vport->load_flag & FC_UNLOADING) {\n\t\tif (vport->fc_flag & FC_RSCN_MODE)\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\tgoto out;\n\t}\n\n\tif (lpfc_els_chk_latt(vport)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"4108 Link event during NS query\\n\");\n\t\tif (vport->fc_flag & FC_RSCN_MODE)\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tgoto out;\n\t}\n\tif (lpfc_error_lost_link(vport, ulp_status, ulp_word4)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"4166 NS query failed due to link event: \"\n\t\t\t\t \"ulp_status x%x ulp_word4 x%x fc_flag x%x \"\n\t\t\t\t \"port_state x%x gidft_inp x%x\\n\",\n\t\t\t\t ulp_status, ulp_word4, vport->fc_flag,\n\t\t\t\t vport->port_state, vport->gidft_inp);\n\t\tif (vport->fc_flag & FC_RSCN_MODE)\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\tif (vport->gidft_inp)\n\t\t\tvport->gidft_inp--;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(shost->host_lock);\n\tif (vport->fc_flag & FC_RSCN_DEFERRED) {\n\t\tvport->fc_flag &= ~FC_RSCN_DEFERRED;\n\t\tspin_unlock_irq(shost->host_lock);\n\n\t\t \n\t\tif (vport->gidft_inp)\n\t\t\tvport->gidft_inp--;\n\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_ELS,\n\t\t\t\t \"4167 Process Deferred RSCN Data: x%x x%x\\n\",\n\t\t\t\t vport->fc_flag, vport->fc_rscn_id_cnt);\n\t\tlpfc_els_handle_rscn(vport);\n\n\t\tgoto out;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\n\tif (ulp_status) {\n\t\t \n\t\tif (vport->fc_ns_retry < LPFC_MAX_NS_RETRY) {\n\t\t\tif (ulp_status != IOSTAT_LOCAL_REJECT ||\n\t\t\t    (ulp_word4 & IOERR_PARAM_MASK) !=\n\t\t\t    IOERR_NO_RESOURCES)\n\t\t\t\tvport->fc_ns_retry++;\n\n\t\t\t \n\t\t\trc = lpfc_ns_cmd(vport, SLI_CTNS_GID_PT,\n\t\t\t\t\t vport->fc_ns_retry, GID_PT_N_PORT);\n\t\t\tif (rc == 0)\n\t\t\t\tgoto out;\n\t\t\telse {  \n\t\t\t\tif (vport->gidft_inp)\n\t\t\t\t\tvport->gidft_inp--;\n\t\t\t}\n\t\t}\n\t\tif (vport->fc_flag & FC_RSCN_MODE)\n\t\t\tlpfc_els_flush_rscn(vport);\n\t\tlpfc_vport_set_state(vport, FC_VPORT_FAILED);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"4103 GID_FT Query error: 0x%x 0x%x\\n\",\n\t\t\t\t ulp_status, vport->fc_ns_retry);\n\t} else {\n\t\t \n\t\tCTreq = (struct lpfc_sli_ct_request *)inp->virt;\n\t\tCTrsp = (struct lpfc_sli_ct_request *)outp->virt;\n\t\tif (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t    SLI_CT_RESPONSE_FS_ACC) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t \"4105 NameServer Rsp Data: x%x x%x \"\n\t\t\t\t\t \"x%x x%x sz x%x\\n\",\n\t\t\t\t\t vport->fc_flag,\n\t\t\t\t\t CTreq->un.gid.Fc4Type,\n\t\t\t\t\t vport->num_disc_nodes,\n\t\t\t\t\t vport->gidft_inp,\n\t\t\t\t\t get_job_data_placed(phba, rspiocb));\n\n\t\t\tlpfc_ns_rsp(vport,\n\t\t\t\t    outp,\n\t\t\t\t    CTreq->un.gid.Fc4Type,\n\t\t\t\t    get_job_data_placed(phba, rspiocb));\n\t\t} else if (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t\t   SLI_CT_RESPONSE_FS_RJT) {\n\t\t\t \n\t\t\tif ((CTrsp->ReasonCode == SLI_CT_UNABLE_TO_PERFORM_REQ)\n\t\t\t    && (CTrsp->Explanation == SLI_CT_NO_FC4_TYPES)) {\n\t\t\t\tlpfc_printf_vlog(\n\t\t\t\t\tvport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t\"4106 No NameServer Entries \"\n\t\t\t\t\t\"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t\t(uint32_t)CTrsp->ReasonCode,\n\t\t\t\t\t(uint32_t)CTrsp->Explanation,\n\t\t\t\t\tvport->fc_flag);\n\n\t\t\t\tlpfc_debugfs_disc_trc(\n\t\t\t\tvport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"GID_PT no entry  cmd:x%x rsn:x%x exp:x%x\",\n\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t(uint32_t)CTrsp->ReasonCode,\n\t\t\t\t(uint32_t)CTrsp->Explanation);\n\t\t\t} else {\n\t\t\t\tlpfc_printf_vlog(\n\t\t\t\t\tvport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t\t\"4107 NameServer Rsp Error \"\n\t\t\t\t\t\"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t\t(uint32_t)CTrsp->ReasonCode,\n\t\t\t\t\t(uint32_t)CTrsp->Explanation,\n\t\t\t\t\tvport->fc_flag);\n\n\t\t\t\tlpfc_debugfs_disc_trc(\n\t\t\t\tvport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"GID_PT rsp err1  cmd:x%x rsn:x%x exp:x%x\",\n\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t(uint32_t)CTrsp->ReasonCode,\n\t\t\t\t(uint32_t)CTrsp->Explanation);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"4109 NameServer Rsp Error \"\n\t\t\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\t be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t\t (uint32_t)CTrsp->ReasonCode,\n\t\t\t\t\t (uint32_t)CTrsp->Explanation,\n\t\t\t\t\t vport->fc_flag);\n\n\t\t\tlpfc_debugfs_disc_trc(\n\t\t\t\tvport, LPFC_DISC_TRC_CT,\n\t\t\t\t\"GID_PT rsp err2  cmd:x%x rsn:x%x exp:x%x\",\n\t\t\t\tbe16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t\t(uint32_t)CTrsp->ReasonCode,\n\t\t\t\t(uint32_t)CTrsp->Explanation);\n\t\t}\n\t\tif (vport->gidft_inp)\n\t\t\tvport->gidft_inp--;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"6450 GID_PT cmpl inp %d disc %d\\n\",\n\t\t\t vport->gidft_inp, vport->num_disc_nodes);\n\n\t \n\tif ((vport->num_disc_nodes == 0) &&\n\t    (vport->gidft_inp == 0)) {\n\t\t \n\t\tif (vport->port_state >= LPFC_DISC_AUTH) {\n\t\t\tif (vport->fc_flag & FC_RSCN_MODE) {\n\t\t\t\tlpfc_els_flush_rscn(vport);\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag |= FC_RSCN_MODE;  \n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t} else {\n\t\t\t\tlpfc_els_flush_rscn(vport);\n\t\t\t}\n\t\t}\n\n\t\tlpfc_disc_start(vport);\n\t}\nout:\n\tlpfc_ct_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_gff_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_dmabuf *inp = cmdiocb->cmd_dmabuf;\n\tstruct lpfc_dmabuf *outp = cmdiocb->rsp_dmabuf;\n\tstruct lpfc_sli_ct_request *CTrsp;\n\tint did, rc, retry;\n\tuint8_t fbits;\n\tstruct lpfc_nodelist *ndlp = NULL, *free_ndlp = NULL;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\n\tdid = ((struct lpfc_sli_ct_request *) inp->virt)->un.gff.PortId;\n\tdid = be32_to_cpu(did);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\"GFF_ID cmpl:     status:x%x/x%x did:x%x\",\n\t\tulp_status, ulp_word4, did);\n\n\t \n\tif (cmdiocb->event_tag != phba->fc_eventTag) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"9045 Event tag mismatch. Ignoring NS rsp\\n\");\n\t\tgoto iocb_free;\n\t}\n\n\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\t \n\t\tCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\n\t\tfbits = CTrsp->un.gff_acc.fbits[FCP_TYPE_FEATURE_OFFSET];\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"6431 Process GFF_ID rsp for %08x \"\n\t\t\t\t \"fbits %02x %s %s\\n\",\n\t\t\t\t did, fbits,\n\t\t\t\t (fbits & FC4_FEATURE_INIT) ? \"Initiator\" : \" \",\n\t\t\t\t (fbits & FC4_FEATURE_TARGET) ? \"Target\" : \" \");\n\n\t\tif (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t    SLI_CT_RESPONSE_FS_ACC) {\n\t\t\tif ((fbits & FC4_FEATURE_INIT) &&\n\t\t\t    !(fbits & FC4_FEATURE_TARGET)) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t\t LOG_DISCOVERY,\n\t\t\t\t\t\t \"0270 Skip x%x GFF \"\n\t\t\t\t\t\t \"NameServer Rsp Data: (init) \"\n\t\t\t\t\t\t \"x%x x%x\\n\", did, fbits,\n\t\t\t\t\t\t vport->fc_rscn_id_cnt);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t \n\t\tif (cmdiocb->retry < LPFC_MAX_NS_RETRY) {\n\t\t\tretry = 1;\n\t\t\tif (ulp_status == IOSTAT_LOCAL_REJECT) {\n\t\t\t\tswitch ((ulp_word4 &\n\t\t\t\t\tIOERR_PARAM_MASK)) {\n\n\t\t\t\tcase IOERR_NO_RESOURCES:\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\tcase IOERR_LINK_DOWN:\n\t\t\t\tcase IOERR_SLI_ABORTED:\n\t\t\t\tcase IOERR_SLI_DOWN:\n\t\t\t\t\tretry = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcmdiocb->retry++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tcmdiocb->retry++;\n\n\t\t\tif (retry) {\n\t\t\t\t \n\t\t\t\trc = lpfc_ns_cmd(vport, SLI_CTNS_GFF_ID,\n\t\t\t\t\t cmdiocb->retry, did);\n\t\t\t\tif (rc == 0) {\n\t\t\t\t\t \n\t\t\t\t\tfree_ndlp = cmdiocb->ndlp;\n\t\t\t\t\tlpfc_ct_free_iocb(phba, cmdiocb);\n\t\t\t\t\tlpfc_nlp_put(free_ndlp);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0267 NameServer GFF Rsp \"\n\t\t\t\t \"x%x Error (%d %d) Data: x%x x%x\\n\",\n\t\t\t\t did, ulp_status, ulp_word4,\n\t\t\t\t vport->fc_flag, vport->fc_rscn_id_cnt);\n\t}\n\n\t \n\tndlp = lpfc_setup_disc_node(vport, did);\n\tif (ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"0242 Process x%x GFF \"\n\t\t\t\t \"NameServer Rsp Data: x%x x%x x%x\\n\",\n\t\t\t\t did, ndlp->nlp_flag, vport->fc_flag,\n\t\t\t\t vport->fc_rscn_id_cnt);\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"0243 Skip x%x GFF \"\n\t\t\t\t \"NameServer Rsp Data: x%x x%x\\n\", did,\n\t\t\t\t vport->fc_flag, vport->fc_rscn_id_cnt);\n\t}\nout:\n\t \n\tif (vport->num_disc_nodes)\n\t\tvport->num_disc_nodes--;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"6451 GFF_ID cmpl inp %d disc %d\\n\",\n\t\t\t vport->gidft_inp, vport->num_disc_nodes);\n\n\tif (vport->num_disc_nodes == 0) {\n\t\t \n\t\tif (vport->port_state >= LPFC_DISC_AUTH) {\n\t\t\tif (vport->fc_flag & FC_RSCN_MODE) {\n\t\t\t\tlpfc_els_flush_rscn(vport);\n\t\t\t\tspin_lock_irq(shost->host_lock);\n\t\t\t\tvport->fc_flag |= FC_RSCN_MODE;  \n\t\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\t}\n\t\t\telse\n\t\t\t\tlpfc_els_flush_rscn(vport);\n\t\t}\n\t\tlpfc_disc_start(vport);\n\t}\n\niocb_free:\n\tfree_ndlp = cmdiocb->ndlp;\n\tlpfc_ct_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(free_ndlp);\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_gft_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct lpfc_dmabuf *inp = cmdiocb->cmd_dmabuf;\n\tstruct lpfc_dmabuf *outp = cmdiocb->rsp_dmabuf;\n\tstruct lpfc_sli_ct_request *CTrsp;\n\tint did;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tstruct lpfc_nodelist *ns_ndlp = cmdiocb->ndlp;\n\tuint32_t fc4_data_0, fc4_data_1;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\n\tdid = ((struct lpfc_sli_ct_request *)inp->virt)->un.gft.PortId;\n\tdid = be32_to_cpu(did);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t      \"GFT_ID cmpl: status:x%x/x%x did:x%x\",\n\t\t\t      ulp_status, ulp_word4, did);\n\n\t \n\tif ((uint32_t)cmdiocb->event_tag != phba->fc_eventTag) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"9046 Event tag mismatch. Ignoring NS rsp\\n\");\n\t\tgoto out;\n\t}\n\n\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\t \n\t\tCTrsp = (struct lpfc_sli_ct_request *)outp->virt;\n\t\tfc4_data_0 = be32_to_cpu(CTrsp->un.gft_acc.fc4_types[0]);\n\t\tfc4_data_1 = be32_to_cpu(CTrsp->un.gft_acc.fc4_types[1]);\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"6432 Process GFT_ID rsp for %08x \"\n\t\t\t\t \"Data %08x %08x %s %s\\n\",\n\t\t\t\t did, fc4_data_0, fc4_data_1,\n\t\t\t\t (fc4_data_0 & LPFC_FC4_TYPE_BITMASK) ?\n\t\t\t\t  \"FCP\" : \" \",\n\t\t\t\t (fc4_data_1 & LPFC_FC4_TYPE_BITMASK) ?\n\t\t\t\t  \"NVME\" : \" \");\n\n\t\t \n\t\tndlp = lpfc_findnode_did(vport, did);\n\t\tif (ndlp) {\n\t\t\t \n\t\t\tif (fc4_data_0 & LPFC_FC4_TYPE_BITMASK)\n\t\t\t\tndlp->nlp_fc4_type |= NLP_FC4_FCP;\n\t\t\tif (fc4_data_1 &  LPFC_FC4_TYPE_BITMASK)\n\t\t\t\tndlp->nlp_fc4_type |= NLP_FC4_NVME;\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_DISCOVERY | LOG_NODE,\n\t\t\t\t\t \"3064 Setting ndlp x%px, DID x%06x \"\n\t\t\t\t\t \"with FC4 x%08x, Data: x%08x x%08x \"\n\t\t\t\t\t \"%d\\n\",\n\t\t\t\t\t ndlp, did, ndlp->nlp_fc4_type,\n\t\t\t\t\t FC_TYPE_FCP, FC_TYPE_NVME,\n\t\t\t\t\t ndlp->nlp_state);\n\n\t\t\tif (ndlp->nlp_state == NLP_STE_REG_LOGIN_ISSUE &&\n\t\t\t    ndlp->nlp_fc4_type) {\n\t\t\t\tndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\n\t\t\t\t \n\t\t\t\tif (!(ndlp->nlp_flag & NLP_RCV_PLOGI)) {\n\t\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t\t   NLP_STE_PRLI_ISSUE);\n\t\t\t\t\tlpfc_issue_els_prli(vport, ndlp, 0);\n\t\t\t\t}\n\t\t\t} else if (!ndlp->nlp_fc4_type) {\n\t\t\t\t \n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t\t LOG_DISCOVERY | LOG_NODE,\n\t\t\t\t\t\t \"6443 Sending LOGO ndlp x%px,\"\n\t\t\t\t\t\t \"DID x%06x with fc4_type: \"\n\t\t\t\t\t\t \"x%08x, state: %d\\n\",\n\t\t\t\t\t\t ndlp, did, ndlp->nlp_fc4_type,\n\t\t\t\t\t\t ndlp->nlp_state);\n\t\t\t\tlpfc_issue_els_logo(vport, ndlp, 0);\n\t\t\t\tndlp->nlp_prev_state = NLP_STE_REG_LOGIN_ISSUE;\n\t\t\t\tlpfc_nlp_set_state(vport, ndlp,\n\t\t\t\t\t\t   NLP_STE_NPR_NODE);\n\t\t\t}\n\t\t}\n\t} else\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"3065 GFT_ID failed x%08x\\n\", ulp_status);\n\nout:\n\tlpfc_ct_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ns_ndlp);\n}\n\nstatic void\nlpfc_cmpl_ct(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t     struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct lpfc_dmabuf *inp;\n\tstruct lpfc_dmabuf *outp;\n\tstruct lpfc_sli_ct_request *CTrsp;\n\tstruct lpfc_nodelist *ndlp;\n\tint cmdcode, rc;\n\tuint8_t retry;\n\tuint32_t latt;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\n\t \n\tndlp = cmdiocb->ndlp;\n\n\t \n\tcmdiocb->rsp_iocb = rspiocb;\n\n\tinp = cmdiocb->cmd_dmabuf;\n\toutp = cmdiocb->rsp_dmabuf;\n\n\tcmdcode = be16_to_cpu(((struct lpfc_sli_ct_request *) inp->virt)->\n\t\t\t\t\tCommandResponse.bits.CmdRsp);\n\tCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\n\n\tlatt = lpfc_els_chk_latt(vport);\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0209 CT Request completes, latt %d, \"\n\t\t\t \"ulp_status x%x CmdRsp x%x, Context x%x, Tag x%x\\n\",\n\t\t\t latt, ulp_status,\n\t\t\t be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp),\n\t\t\t get_job_ulpcontext(phba, cmdiocb), cmdiocb->iotag);\n\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\"CT cmd cmpl:     status:x%x/x%x cmd:x%x\",\n\t\tulp_status, ulp_word4, cmdcode);\n\n\tif (ulp_status) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0268 NS cmd x%x Error (x%x x%x)\\n\",\n\t\t\t\t cmdcode, ulp_status, ulp_word4);\n\n\t\tif (ulp_status == IOSTAT_LOCAL_REJECT &&\n\t\t    (((ulp_word4 & IOERR_PARAM_MASK) ==\n\t\t      IOERR_SLI_DOWN) ||\n\t\t     ((ulp_word4 & IOERR_PARAM_MASK) ==\n\t\t      IOERR_SLI_ABORTED)))\n\t\t\tgoto out;\n\n\t\tretry = cmdiocb->retry;\n\t\tif (retry >= LPFC_MAX_NS_RETRY)\n\t\t\tgoto out;\n\n\t\tretry++;\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"0250 Retrying NS cmd %x\\n\", cmdcode);\n\t\trc = lpfc_ns_cmd(vport, cmdcode, retry, 0);\n\t\tif (rc == 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\tlpfc_ct_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_rft_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\tstruct lpfc_dmabuf *outp;\n\t\tstruct lpfc_sli_ct_request *CTrsp;\n\n\t\toutp = cmdiocb->rsp_dmabuf;\n\t\tCTrsp = (struct lpfc_sli_ct_request *)outp->virt;\n\t\tif (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t    SLI_CT_RESPONSE_FS_ACC)\n\t\t\tvport->ct_flags |= FC_CT_RFT_ID;\n\t}\n\tlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_rnn_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\tstruct lpfc_dmabuf *outp;\n\t\tstruct lpfc_sli_ct_request *CTrsp;\n\n\t\toutp = cmdiocb->rsp_dmabuf;\n\t\tCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\n\t\tif (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t    SLI_CT_RESPONSE_FS_ACC)\n\t\t\tvport->ct_flags |= FC_CT_RNN_ID;\n\t}\n\tlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_rspn_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\t struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\tstruct lpfc_dmabuf *outp;\n\t\tstruct lpfc_sli_ct_request *CTrsp;\n\n\t\toutp = cmdiocb->rsp_dmabuf;\n\t\tCTrsp = (struct lpfc_sli_ct_request *)outp->virt;\n\t\tif (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t    SLI_CT_RESPONSE_FS_ACC)\n\t\t\tvport->ct_flags |= FC_CT_RSPN_ID;\n\t}\n\tlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_rsnn_nn(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\t struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\tstruct lpfc_dmabuf *outp;\n\t\tstruct lpfc_sli_ct_request *CTrsp;\n\n\t\toutp = cmdiocb->rsp_dmabuf;\n\t\tCTrsp = (struct lpfc_sli_ct_request *) outp->virt;\n\t\tif (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t    SLI_CT_RESPONSE_FS_ACC)\n\t\t\tvport->ct_flags |= FC_CT_RSNN_NN;\n\t}\n\tlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_da_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\n\t \n\tvport->ct_flags = 0;\n\tlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_rff_id(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\tstruct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\n\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\tstruct lpfc_dmabuf *outp;\n\t\tstruct lpfc_sli_ct_request *CTrsp;\n\n\t\toutp = cmdiocb->rsp_dmabuf;\n\t\tCTrsp = (struct lpfc_sli_ct_request *)outp->virt;\n\t\tif (be16_to_cpu(CTrsp->CommandResponse.bits.CmdRsp) ==\n\t\t    SLI_CT_RESPONSE_FS_ACC)\n\t\t\tvport->ct_flags |= FC_CT_RFF_ID;\n\t}\n\tlpfc_cmpl_ct(phba, cmdiocb, rspiocb);\n\treturn;\n}\n\n \nint\nlpfc_vport_symbolic_port_name(struct lpfc_vport *vport, char *symbol,\n\tsize_t size)\n{\n\tint n;\n\n\t \n\tn = scnprintf(symbol, size, \"%d\", vport->phba->brd_no);\n\treturn n;\n}\n\n\nint\nlpfc_vport_symbolic_node_name(struct lpfc_vport *vport, char *symbol,\n\tsize_t size)\n{\n\tchar fwrev[FW_REV_STR_SIZE] = {0};\n\tchar tmp[MAXHOSTNAMELEN] = {0};\n\n\tmemset(symbol, 0, size);\n\n\tscnprintf(tmp, sizeof(tmp), \"Emulex %s\", vport->phba->ModelName);\n\tif (strlcat(symbol, tmp, size) >= size)\n\t\tgoto buffer_done;\n\n\tlpfc_decode_firmware_rev(vport->phba, fwrev, 0);\n\tscnprintf(tmp, sizeof(tmp), \" FV%s\", fwrev);\n\tif (strlcat(symbol, tmp, size) >= size)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp), \" DV%s\", lpfc_release_version);\n\tif (strlcat(symbol, tmp, size) >= size)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp), \" HN:%s\", vport->phba->os_host_name);\n\tif (strlcat(symbol, tmp, size) >= size)\n\t\tgoto buffer_done;\n\n\t \n\tscnprintf(tmp, sizeof(tmp), \" OS:%s\", init_utsname()->sysname);\n\tstrlcat(symbol, tmp, size);\n\nbuffer_done:\n\treturn strnlen(symbol, size);\n\n}\n\nstatic uint32_t\nlpfc_find_map_node(struct lpfc_vport *vport)\n{\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\tstruct Scsi_Host  *shost;\n\tuint32_t cnt = 0;\n\n\tshost = lpfc_shost_from_vport(vport);\n\tspin_lock_irq(shost->host_lock);\n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_type & NLP_FABRIC)\n\t\t\tcontinue;\n\t\tif ((ndlp->nlp_state == NLP_STE_MAPPED_NODE) ||\n\t\t    (ndlp->nlp_state == NLP_STE_UNMAPPED_NODE))\n\t\t\tcnt++;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\treturn cnt;\n}\n\n \nint\nlpfc_get_gidft_type(struct lpfc_vport *vport, struct lpfc_iocbq *cmdiocb)\n{\n\tstruct lpfc_sli_ct_request *CtReq;\n\tstruct lpfc_dmabuf *mp;\n\tuint32_t type;\n\n\tmp = cmdiocb->cmd_dmabuf;\n\tif (mp == NULL)\n\t\treturn 0;\n\tCtReq = (struct lpfc_sli_ct_request *)mp->virt;\n\ttype = (uint32_t)CtReq->un.gid.Fc4Type;\n\tif ((type != SLI_CTPT_FCP) && (type != SLI_CTPT_NVME))\n\t\treturn 0;\n\treturn type;\n}\n\n \nint\nlpfc_ns_cmd(struct lpfc_vport *vport, int cmdcode,\n\t    uint8_t retry, uint32_t context)\n{\n\tstruct lpfc_nodelist * ndlp;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_dmabuf *mp, *bmp;\n\tstruct lpfc_sli_ct_request *CtReq;\n\tstruct ulp_bde64 *bpl;\n\tvoid (*cmpl) (struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t      struct lpfc_iocbq *) = NULL;\n\tuint32_t *ptr;\n\tuint32_t rsp_size = 1024;\n\tsize_t   size;\n\tint rc = 0;\n\n\tndlp = lpfc_findnode_did(vport, NameServer_DID);\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_UNMAPPED_NODE) {\n\t\trc=1;\n\t\tgoto ns_cmd_exit;\n\t}\n\n\t \n\t \n\tmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (!mp) {\n\t\trc=2;\n\t\tgoto ns_cmd_exit;\n\t}\n\n\tINIT_LIST_HEAD(&mp->list);\n\tmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));\n\tif (!mp->virt) {\n\t\trc=3;\n\t\tgoto ns_cmd_free_mp;\n\t}\n\n\t \n\tbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (!bmp) {\n\t\trc=4;\n\t\tgoto ns_cmd_free_mpvirt;\n\t}\n\n\tINIT_LIST_HEAD(&bmp->list);\n\tbmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(bmp->phys));\n\tif (!bmp->virt) {\n\t\trc=5;\n\t\tgoto ns_cmd_free_bmp;\n\t}\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO ,LOG_DISCOVERY,\n\t\t\t \"0236 NameServer Req Data: x%x x%x x%x x%x\\n\",\n\t\t\t cmdcode, vport->fc_flag, vport->fc_rscn_id_cnt,\n\t\t\t context);\n\n\tbpl = (struct ulp_bde64 *) bmp->virt;\n\tmemset(bpl, 0, sizeof(struct ulp_bde64));\n\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys) );\n\tbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys) );\n\tbpl->tus.f.bdeFlags = 0;\n\tif (cmdcode == SLI_CTNS_GID_FT)\n\t\tbpl->tus.f.bdeSize = GID_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_GID_PT)\n\t\tbpl->tus.f.bdeSize = GID_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_GFF_ID)\n\t\tbpl->tus.f.bdeSize = GFF_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_GFT_ID)\n\t\tbpl->tus.f.bdeSize = GFT_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_RFT_ID)\n\t\tbpl->tus.f.bdeSize = RFT_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_RNN_ID)\n\t\tbpl->tus.f.bdeSize = RNN_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_RSPN_ID)\n\t\tbpl->tus.f.bdeSize = RSPN_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_RSNN_NN)\n\t\tbpl->tus.f.bdeSize = RSNN_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_DA_ID)\n\t\tbpl->tus.f.bdeSize = DA_ID_REQUEST_SZ;\n\telse if (cmdcode == SLI_CTNS_RFF_ID)\n\t\tbpl->tus.f.bdeSize = RFF_REQUEST_SZ;\n\telse\n\t\tbpl->tus.f.bdeSize = 0;\n\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\n\tCtReq = (struct lpfc_sli_ct_request *) mp->virt;\n\tmemset(CtReq, 0, sizeof(struct lpfc_sli_ct_request));\n\tCtReq->RevisionId.bits.Revision = SLI_CT_REVISION;\n\tCtReq->RevisionId.bits.InId = 0;\n\tCtReq->FsType = SLI_CT_DIRECTORY_SERVICE;\n\tCtReq->FsSubType = SLI_CT_DIRECTORY_NAME_SERVER;\n\tCtReq->CommandResponse.bits.Size = 0;\n\tswitch (cmdcode) {\n\tcase SLI_CTNS_GID_FT:\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t    cpu_to_be16(SLI_CTNS_GID_FT);\n\t\tCtReq->un.gid.Fc4Type = context;\n\n\t\tif (vport->port_state < LPFC_NS_QRY)\n\t\t\tvport->port_state = LPFC_NS_QRY;\n\t\tlpfc_set_disctmo(vport);\n\t\tcmpl = lpfc_cmpl_ct_cmd_gid_ft;\n\t\trsp_size = FC_MAX_NS_RSP;\n\t\tbreak;\n\n\tcase SLI_CTNS_GID_PT:\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t    cpu_to_be16(SLI_CTNS_GID_PT);\n\t\tCtReq->un.gid.PortType = context;\n\n\t\tif (vport->port_state < LPFC_NS_QRY)\n\t\t\tvport->port_state = LPFC_NS_QRY;\n\t\tlpfc_set_disctmo(vport);\n\t\tcmpl = lpfc_cmpl_ct_cmd_gid_pt;\n\t\trsp_size = FC_MAX_NS_RSP;\n\t\tbreak;\n\n\tcase SLI_CTNS_GFF_ID:\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t\tcpu_to_be16(SLI_CTNS_GFF_ID);\n\t\tCtReq->un.gff.PortId = cpu_to_be32(context);\n\t\tcmpl = lpfc_cmpl_ct_cmd_gff_id;\n\t\tbreak;\n\n\tcase SLI_CTNS_GFT_ID:\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t\tcpu_to_be16(SLI_CTNS_GFT_ID);\n\t\tCtReq->un.gft.PortId = cpu_to_be32(context);\n\t\tcmpl = lpfc_cmpl_ct_cmd_gft_id;\n\t\tbreak;\n\n\tcase SLI_CTNS_RFT_ID:\n\t\tvport->ct_flags &= ~FC_CT_RFT_ID;\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t    cpu_to_be16(SLI_CTNS_RFT_ID);\n\t\tCtReq->un.rft.port_id = cpu_to_be32(vport->fc_myDID);\n\n\t\t \n\t\tif (phba->cfg_vmid_app_header)\n\t\t\tCtReq->un.rft.app_serv_reg =\n\t\t\t\tcpu_to_be32(RFT_APP_SERV_REG);\n\n\t\t \n\t\tif (vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH ||\n\t\t    vport->cfg_enable_fc4_type == LPFC_ENABLE_FCP)\n\t\t\tCtReq->un.rft.fcp_reg = cpu_to_be32(RFT_FCP_REG);\n\n\t\t \n\t\tif (vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH ||\n\t\t    vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)\n\t\t\tCtReq->un.rft.nvme_reg = cpu_to_be32(RFT_NVME_REG);\n\n\t\tptr = (uint32_t *)CtReq;\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"6433 Issue RFT (%s %s %s): %08x %08x %08x \"\n\t\t\t\t \"%08x %08x %08x %08x %08x\\n\",\n\t\t\t\t CtReq->un.rft.fcp_reg ? \"FCP\" : \" \",\n\t\t\t\t CtReq->un.rft.nvme_reg ? \"NVME\" : \" \",\n\t\t\t\t CtReq->un.rft.app_serv_reg ? \"APPS\" : \" \",\n\t\t\t\t *ptr, *(ptr + 1), *(ptr + 2), *(ptr + 3),\n\t\t\t\t *(ptr + 4), *(ptr + 5),\n\t\t\t\t *(ptr + 6), *(ptr + 7));\n\t\tcmpl = lpfc_cmpl_ct_cmd_rft_id;\n\t\tbreak;\n\n\tcase SLI_CTNS_RNN_ID:\n\t\tvport->ct_flags &= ~FC_CT_RNN_ID;\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t    cpu_to_be16(SLI_CTNS_RNN_ID);\n\t\tCtReq->un.rnn.PortId = cpu_to_be32(vport->fc_myDID);\n\t\tmemcpy(CtReq->un.rnn.wwnn,  &vport->fc_nodename,\n\t\t       sizeof(struct lpfc_name));\n\t\tcmpl = lpfc_cmpl_ct_cmd_rnn_id;\n\t\tbreak;\n\n\tcase SLI_CTNS_RSPN_ID:\n\t\tvport->ct_flags &= ~FC_CT_RSPN_ID;\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t    cpu_to_be16(SLI_CTNS_RSPN_ID);\n\t\tCtReq->un.rspn.PortId = cpu_to_be32(vport->fc_myDID);\n\t\tsize = sizeof(CtReq->un.rspn.symbname);\n\t\tCtReq->un.rspn.len =\n\t\t\tlpfc_vport_symbolic_port_name(vport,\n\t\t\tCtReq->un.rspn.symbname, size);\n\t\tcmpl = lpfc_cmpl_ct_cmd_rspn_id;\n\t\tbreak;\n\tcase SLI_CTNS_RSNN_NN:\n\t\tvport->ct_flags &= ~FC_CT_RSNN_NN;\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t    cpu_to_be16(SLI_CTNS_RSNN_NN);\n\t\tmemcpy(CtReq->un.rsnn.wwnn, &vport->fc_nodename,\n\t\t       sizeof(struct lpfc_name));\n\t\tsize = sizeof(CtReq->un.rsnn.symbname);\n\t\tCtReq->un.rsnn.len =\n\t\t\tlpfc_vport_symbolic_node_name(vport,\n\t\t\tCtReq->un.rsnn.symbname, size);\n\t\tcmpl = lpfc_cmpl_ct_cmd_rsnn_nn;\n\t\tbreak;\n\tcase SLI_CTNS_DA_ID:\n\t\t \n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t\tcpu_to_be16(SLI_CTNS_DA_ID);\n\t\tCtReq->un.da_id.port_id = cpu_to_be32(vport->fc_myDID);\n\t\tcmpl = lpfc_cmpl_ct_cmd_da_id;\n\t\tbreak;\n\tcase SLI_CTNS_RFF_ID:\n\t\tvport->ct_flags &= ~FC_CT_RFF_ID;\n\t\tCtReq->CommandResponse.bits.CmdRsp =\n\t\t    cpu_to_be16(SLI_CTNS_RFF_ID);\n\t\tCtReq->un.rff.PortId = cpu_to_be32(vport->fc_myDID);\n\t\tCtReq->un.rff.fbits = FC4_FEATURE_INIT;\n\n\t\t \n\t\tif (((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t\t     (vport->cfg_enable_fc4_type == LPFC_ENABLE_NVME)) &&\n\t\t    (context == FC_TYPE_NVME)) {\n\t\t\tif ((vport == phba->pport) && phba->nvmet_support) {\n\t\t\t\tCtReq->un.rff.fbits = (FC4_FEATURE_TARGET |\n\t\t\t\t\tFC4_FEATURE_NVME_DISC);\n\t\t\t\tlpfc_nvmet_update_targetport(phba);\n\t\t\t} else {\n\t\t\t\tlpfc_nvme_update_localport(vport);\n\t\t\t}\n\t\t\tCtReq->un.rff.type_code = context;\n\n\t\t} else if (((vport->cfg_enable_fc4_type == LPFC_ENABLE_BOTH) ||\n\t\t\t    (vport->cfg_enable_fc4_type == LPFC_ENABLE_FCP)) &&\n\t\t\t   (context == FC_TYPE_FCP))\n\t\t\tCtReq->un.rff.type_code = context;\n\n\t\telse\n\t\t\tgoto ns_cmd_free_bmpvirt;\n\n\t\tptr = (uint32_t *)CtReq;\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"6434 Issue RFF (%s): %08x %08x %08x %08x \"\n\t\t\t\t \"%08x %08x %08x %08x\\n\",\n\t\t\t\t (context == FC_TYPE_NVME) ? \"NVME\" : \"FCP\",\n\t\t\t\t *ptr, *(ptr + 1), *(ptr + 2), *(ptr + 3),\n\t\t\t\t *(ptr + 4), *(ptr + 5),\n\t\t\t\t *(ptr + 6), *(ptr + 7));\n\t\tcmpl = lpfc_cmpl_ct_cmd_rff_id;\n\t\tbreak;\n\t}\n\t \n\tif (!lpfc_ct_cmd(vport, mp, bmp, ndlp, cmpl, rsp_size, retry)) {\n\t\t \n\t\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\t\"Issue CT cmd:    cmd:x%x did:x%x\",\n\t\t\tcmdcode, ndlp->nlp_DID, 0);\n\t\treturn 0;\n\t}\n\trc=6;\n\nns_cmd_free_bmpvirt:\n\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\nns_cmd_free_bmp:\n\tkfree(bmp);\nns_cmd_free_mpvirt:\n\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\nns_cmd_free_mp:\n\tkfree(mp);\nns_cmd_exit:\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"0266 Issue NameServer Req x%x err %d Data: x%x x%x\\n\",\n\t\t\t cmdcode, rc, vport->fc_flag, vport->fc_rscn_id_cnt);\n\treturn 1;\n}\n\n \nstatic void\nlpfc_fdmi_rprt_defer(struct lpfc_hba *phba, uint32_t mask)\n{\n\tstruct lpfc_vport **vports;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_nodelist *ndlp;\n\tint i;\n\n\tphba->hba_flag |= HBA_RHBA_CMPL;\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports) {\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tvport = vports[i];\n\t\t\tndlp = lpfc_findnode_did(phba->pport, FDMI_DID);\n\t\t\tif (!ndlp)\n\t\t\t\tcontinue;\n\t\t\tif (vport->ct_flags & FC_CT_RPRT_DEFER) {\n\t\t\t\tvport->ct_flags &= ~FC_CT_RPRT_DEFER;\n\t\t\t\tvport->fdmi_port_mask = mask;\n\t\t\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPRT, 0);\n\t\t\t}\n\t\t}\n\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\n \nstatic void\nlpfc_cmpl_ct_disc_fdmi(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t       struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct lpfc_dmabuf *inp = cmdiocb->cmd_dmabuf;\n\tstruct lpfc_dmabuf *outp = cmdiocb->rsp_dmabuf;\n\tstruct lpfc_sli_ct_request *CTcmd = inp->virt;\n\tstruct lpfc_sli_ct_request *CTrsp = outp->virt;\n\t__be16 fdmi_cmd = CTcmd->CommandResponse.bits.CmdRsp;\n\t__be16 fdmi_rsp = CTrsp->CommandResponse.bits.CmdRsp;\n\tstruct lpfc_nodelist *ndlp, *free_ndlp = NULL;\n\tuint32_t latt, cmd, err;\n\tu32 ulp_status = get_job_ulpstatus(phba, rspiocb);\n\tu32 ulp_word4 = get_job_word4(phba, rspiocb);\n\n\tlatt = lpfc_els_chk_latt(vport);\n\tlpfc_debugfs_disc_trc(vport, LPFC_DISC_TRC_CT,\n\t\t\"FDMI cmpl:       status:x%x/x%x latt:%d\",\n\t\tulp_status, ulp_word4, latt);\n\n\tif (latt || ulp_status) {\n\n\t\t \n\t\tif (ulp_status == IOSTAT_LOCAL_REJECT) {\n\t\t\tswitch ((ulp_word4 & IOERR_PARAM_MASK)) {\n\t\t\tcase IOERR_SLI_ABORTED:\n\t\t\tcase IOERR_SLI_DOWN:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase IOERR_ABORT_IN_PROGRESS:\n\t\t\tcase IOERR_SEQUENCE_TIMEOUT:\n\t\t\tcase IOERR_ILLEGAL_FRAME:\n\t\t\tcase IOERR_NO_RESOURCES:\n\t\t\tcase IOERR_ILLEGAL_COMMAND:\n\t\t\t\tcmdiocb->retry++;\n\t\t\t\tif (cmdiocb->retry >= LPFC_FDMI_MAX_RETRY)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\terr = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING,\n\t\t\t\t\t\t\t  cmdiocb, 0);\n\t\t\t\tif (err == IOCB_ERROR)\n\t\t\t\t\tbreak;\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t\t \"0229 FDMI cmd %04x failed, latt = %d \"\n\t\t\t\t \"ulp_status: x%x, rid x%x\\n\",\n\t\t\t\t be16_to_cpu(fdmi_cmd), latt, ulp_status,\n\t\t\t\t ulp_word4);\n\t}\n\n\tfree_ndlp = cmdiocb->ndlp;\n\tlpfc_ct_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(free_ndlp);\n\n\tndlp = lpfc_findnode_did(vport, FDMI_DID);\n\tif (!ndlp)\n\t\treturn;\n\n\t \n\tcmd =  be16_to_cpu(fdmi_cmd);\n\tif (be16_to_cpu(fdmi_rsp) == SLI_CT_RESPONSE_FS_RJT) {\n\t\t \n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY | LOG_ELS,\n\t\t\t\t \"0220 FDMI cmd failed FS_RJT Data: x%x\", cmd);\n\n\t\t \n\t\tswitch (cmd) {\n\t\tcase SLI_MGMT_RHBA:\n\t\t\tif (vport->fdmi_hba_mask == LPFC_FDMI2_HBA_ATTR) {\n\t\t\t\t \n\t\t\t\tvport->fdmi_hba_mask = LPFC_FDMI1_HBA_ATTR;\n\n\t\t\t\t \n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI1_PORT_ATTR;\n\t\t\t\t \n\t\t\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DHBA, 0);\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase SLI_MGMT_RPRT:\n\t\t\tif (vport->port_type != LPFC_PHYSICAL_PORT) {\n\t\t\t\tndlp = lpfc_findnode_did(phba->pport, FDMI_DID);\n\t\t\t\tif (!ndlp)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (vport->fdmi_port_mask == LPFC_FDMI2_PORT_ATTR) {\n\t\t\t\t \n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI1_PORT_ATTR;\n\t\t\t\t \n\t\t\t\tlpfc_fdmi_cmd(vport, ndlp, cmd, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (vport->fdmi_port_mask == LPFC_FDMI2_SMART_ATTR) {\n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI2_PORT_ATTR;\n\t\t\t\t \n\t\t\t\tlpfc_fdmi_cmd(vport, ndlp, cmd, 0);\n\t\t\t}\n\t\t\treturn;\n\n\t\tcase SLI_MGMT_RPA:\n\t\t\t \n\t\t\tif (phba->link_flag & LS_CT_VEN_RPA) {\n\t\t\t\tphba->link_flag &= ~LS_CT_VEN_RPA;\n\t\t\t\tif (phba->cmf_active_mode == LPFC_CFG_OFF)\n\t\t\t\t\treturn;\n\t\t\t\tlpfc_printf_log(phba, KERN_WARNING,\n\t\t\t\t\t\tLOG_DISCOVERY | LOG_ELS,\n\t\t\t\t\t\t\"6460 VEN FDMI RPA RJT\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (vport->fdmi_port_mask == LPFC_FDMI2_PORT_ATTR) {\n\t\t\t\t \n\t\t\t\tvport->fdmi_hba_mask = LPFC_FDMI1_HBA_ATTR;\n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI1_PORT_ATTR;\n\t\t\t\t \n\t\t\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DHBA, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (vport->fdmi_port_mask == LPFC_FDMI2_SMART_ATTR) {\n\t\t\t\tvport->fdmi_port_mask = LPFC_FDMI2_PORT_ATTR;\n\t\t\t\t \n\t\t\t\tlpfc_fdmi_cmd(vport, ndlp, cmd, 0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tswitch (cmd) {\n\tcase SLI_MGMT_RHBA:\n\t\t \n\t\tlpfc_fdmi_rprt_defer(phba, vport->fdmi_port_mask);\n\n\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPA, 0);\n\t\tbreak;\n\n\tcase SLI_MGMT_DHBA:\n\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DPRT, 0);\n\t\tbreak;\n\n\tcase SLI_MGMT_DPRT:\n\t\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RHBA, 0);\n\t\t} else {\n\t\t\tndlp = lpfc_findnode_did(phba->pport, FDMI_DID);\n\t\t\tif (!ndlp)\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tif (phba->hba_flag & HBA_RHBA_CMPL) {\n\t\t\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPRT, 0);\n\t\t\t} else {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t\t LOG_DISCOVERY,\n\t\t\t\t\t\t \"6078 RPRT deferred\\n\");\n\t\t\t\tvport->ct_flags |= FC_CT_RPRT_DEFER;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SLI_MGMT_RPA:\n\t\tif (vport->port_type == LPFC_PHYSICAL_PORT &&\n\t\t    phba->sli4_hba.pc_sli4_params.mi_ver) {\n\t\t\t \n\t\t\tif (phba->link_flag & LS_CT_VEN_RPA) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t\t LOG_DISCOVERY | LOG_ELS |\n\t\t\t\t\t\t LOG_CGN_MGMT,\n\t\t\t\t\t\t \"6449 VEN RPA FDMI Success\\n\");\n\t\t\t\tphba->link_flag &= ~LS_CT_VEN_RPA;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\t\tLOG_DISCOVERY | LOG_CGN_MGMT,\n\t\t\t\t\t\"6210 Issue Vendor MI FDMI %x\\n\",\n\t\t\t\t\tphba->sli4_hba.pc_sli4_params.mi_ver);\n\n\t\t\t \n\t\t\tif (lpfc_fdmi_cmd(vport, ndlp, cmd,\n\t\t\t\t\t  LPFC_FDMI_VENDOR_ATTR_mi) == 0)\n\t\t\t\tphba->link_flag |= LS_CT_VEN_RPA;\n\t\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\t\tLOG_DISCOVERY | LOG_ELS,\n\t\t\t\t\t\"6458 Send MI FDMI:%x Flag x%x\\n\",\n\t\t\t\t\tphba->sli4_hba.pc_sli4_params.mi_ver,\n\t\t\t\t\tphba->link_flag);\n\t\t} else {\n\t\t\tlpfc_printf_log(phba, KERN_INFO,\n\t\t\t\t\tLOG_DISCOVERY | LOG_ELS,\n\t\t\t\t\t\"6459 No FDMI VEN MI support - \"\n\t\t\t\t\t\"RPA Success\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\treturn;\n}\n\n\n \nvoid\nlpfc_fdmi_change_check(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_nodelist *ndlp;\n\tuint16_t cnt;\n\n\tif (!lpfc_is_link_up(phba))\n\t\treturn;\n\n\t \n\tif (!(vport->fc_flag & FC_FABRIC))\n\t\treturn;\n\n\tndlp = lpfc_findnode_did(vport, FDMI_DID);\n\tif (!ndlp)\n\t\treturn;\n\n\t \n\tif (strcmp(phba->os_host_name, init_utsname()->nodename)) {\n\t\tmemset(phba->os_host_name, 0, sizeof(phba->os_host_name));\n\t\tscnprintf(phba->os_host_name, sizeof(phba->os_host_name), \"%s\",\n\t\t\t  init_utsname()->nodename);\n\t\tlpfc_ns_cmd(vport, SLI_CTNS_RSNN_NN, 0, 0);\n\n\t\t \n\t\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\t\t \n\t\t\tphba->link_flag &= ~LS_CT_VEN_RPA;\n\t\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DHBA, 0);\n\t\t} else {\n\t\t\tndlp = lpfc_findnode_did(phba->pport, FDMI_DID);\n\t\t\tif (!ndlp)\n\t\t\t\treturn;\n\t\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_DPRT, 0);\n\t\t}\n\n\t\t \n\t\treturn;\n\t}\n\n\tif (!(vport->fdmi_port_mask & LPFC_FDMI_PORT_ATTR_num_disc))\n\t\treturn;\n\n\t \n\tcnt = lpfc_find_map_node(vport);\n\tif (cnt == vport->fdmi_num_disc)\n\t\treturn;\n\n\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPA,\n\t\t\t      LPFC_FDMI_PORT_ATTR_num_disc);\n\t} else {\n\t\tndlp = lpfc_findnode_did(phba->pport, FDMI_DID);\n\t\tif (!ndlp)\n\t\t\treturn;\n\t\tlpfc_fdmi_cmd(vport, ndlp, SLI_MGMT_RPRT,\n\t\t\t      LPFC_FDMI_PORT_ATTR_num_disc);\n\t}\n}\n\nstatic inline int\nlpfc_fdmi_set_attr_u32(void *attr, uint16_t attrtype, uint32_t attrval)\n{\n\tstruct lpfc_fdmi_attr_u32 *ae = attr;\n\tint size = sizeof(*ae);\n\n\tae->type = cpu_to_be16(attrtype);\n\tae->len = cpu_to_be16(size);\n\tae->value_u32 = cpu_to_be32(attrval);\n\n\treturn size;\n}\n\nstatic inline int\nlpfc_fdmi_set_attr_wwn(void *attr, uint16_t attrtype, struct lpfc_name *wwn)\n{\n\tstruct lpfc_fdmi_attr_wwn *ae = attr;\n\tint size = sizeof(*ae);\n\n\tae->type = cpu_to_be16(attrtype);\n\tae->len = cpu_to_be16(size);\n\t \n\tmemcpy(ae->name, wwn,\n\t       min_t(size_t, sizeof(struct lpfc_name), sizeof(__be64)));\n\n\treturn size;\n}\n\nstatic inline int\nlpfc_fdmi_set_attr_fullwwn(void *attr, uint16_t attrtype,\n\t\t\t   struct lpfc_name *wwnn, struct lpfc_name *wwpn)\n{\n\tstruct lpfc_fdmi_attr_fullwwn *ae = attr;\n\tu8 *nname = ae->nname;\n\tu8 *pname = ae->pname;\n\tint size = sizeof(*ae);\n\n\tae->type = cpu_to_be16(attrtype);\n\tae->len = cpu_to_be16(size);\n\t \n\tmemcpy(nname, wwnn,\n\t       min_t(size_t, sizeof(struct lpfc_name), sizeof(__be64)));\n\tmemcpy(pname, wwpn,\n\t       min_t(size_t, sizeof(struct lpfc_name), sizeof(__be64)));\n\n\treturn size;\n}\n\nstatic inline int\nlpfc_fdmi_set_attr_string(void *attr, uint16_t attrtype, char *attrstring)\n{\n\tstruct lpfc_fdmi_attr_string *ae = attr;\n\tint len, size;\n\n\t \n\n\tstrncpy(ae->value_string, attrstring, sizeof(ae->value_string));\n\tlen = strnlen(ae->value_string, sizeof(ae->value_string));\n\t \n\tlen += (len & 3) ? (4 - (len & 3)) : 4;\n\t \n\tsize = FOURBYTES + len;\n\n\tae->type = cpu_to_be16(attrtype);\n\tae->len = cpu_to_be16(size);\n\n\treturn size;\n}\n\n \n#define ATTR_FC4_CT\t0x00000001\n#define ATTR_FC4_FCP\t0x00000002\n#define ATTR_FC4_NVME\t0x00000004\n\nstatic inline int\nlpfc_fdmi_set_attr_fc4types(void *attr, uint16_t attrtype, uint32_t typemask)\n{\n\tstruct lpfc_fdmi_attr_fc4types *ae = attr;\n\tint size = sizeof(*ae);\n\n\tae->type = cpu_to_be16(attrtype);\n\tae->len = cpu_to_be16(size);\n\n\tif (typemask & ATTR_FC4_FCP)\n\t\tae->value_types[2] = 0x01;  \n\n\tif (typemask & ATTR_FC4_CT)\n\t\tae->value_types[7] = 0x01;  \n\n\tif (typemask & ATTR_FC4_NVME)\n\t\tae->value_types[6] = 0x01;  \n\n\treturn size;\n}\n\n \nstatic int\nlpfc_fdmi_hba_attr_wwnn(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_wwn(attr, RHBA_NODENAME,\n\t\t\t&vport->fc_sparam.nodeName);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_manufacturer(struct lpfc_vport *vport, void *attr)\n{\n\t \n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_MANUFACTURER,\n\t\t\t\"Emulex Corporation\");\n}\n\nstatic int\nlpfc_fdmi_hba_attr_sn(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_SERIAL_NUMBER,\n\t\t\tphba->SerialNumber);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_model(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_MODEL,\n\t\t\tphba->ModelName);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_description(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_MODEL_DESCRIPTION,\n\t\t\tphba->ModelDesc);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_hdw_ver(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tlpfc_vpd_t *vp = &phba->vpd;\n\tchar buf[16] = { 0 };\n\n\tsnprintf(buf, sizeof(buf), \"%08x\", vp->rev.biuRev);\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_HARDWARE_VERSION, buf);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_drvr_ver(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_DRIVER_VERSION,\n\t\t\tlpfc_release_version);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_rom_ver(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tchar buf[64] = { 0 };\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tlpfc_decode_firmware_rev(phba, buf, 1);\n\n\t\treturn lpfc_fdmi_set_attr_string(attr, RHBA_OPTION_ROM_VERSION,\n\t\t\t\tbuf);\n\t}\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_OPTION_ROM_VERSION,\n\t\t\tphba->OptionROMVersion);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_fmw_ver(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tchar buf[64] = { 0 };\n\n\tlpfc_decode_firmware_rev(phba, buf, 1);\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_FIRMWARE_VERSION, buf);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_os_ver(struct lpfc_vport *vport, void *attr)\n{\n\tchar buf[256] = { 0 };\n\n\tsnprintf(buf, sizeof(buf), \"%s %s %s\",\n\t\t init_utsname()->sysname,\n\t\t init_utsname()->release,\n\t\t init_utsname()->version);\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_OS_NAME_VERSION, buf);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_ct_len(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_u32(attr, RHBA_MAX_CT_PAYLOAD_LEN,\n\t\t\tLPFC_MAX_CT_SIZE);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_symbolic_name(struct lpfc_vport *vport, void *attr)\n{\n\tchar buf[256] = { 0 };\n\n\tlpfc_vport_symbolic_node_name(vport, buf, sizeof(buf));\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_SYM_NODENAME, buf);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_vendor_info(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_u32(attr, RHBA_VENDOR_INFO, 0);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_num_ports(struct lpfc_vport *vport, void *attr)\n{\n\t \n\treturn lpfc_fdmi_set_attr_u32(attr, RHBA_NUM_PORTS, 1);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_fabric_wwnn(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_wwn(attr, RHBA_FABRIC_WWNN,\n\t\t\t&vport->fabric_nodename);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_bios_ver(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_BIOS_VERSION,\n\t\t\tphba->BIOSVersion);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_bios_state(struct lpfc_vport *vport, void *attr)\n{\n\t \n\treturn lpfc_fdmi_set_attr_u32(attr, RHBA_BIOS_STATE, 0);\n}\n\nstatic int\nlpfc_fdmi_hba_attr_vendor_id(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_string(attr, RHBA_VENDOR_ID, \"EMULEX\");\n}\n\n \n\nstatic int\nlpfc_fdmi_port_attr_fc4type(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tu32 fc4types;\n\n\tfc4types = (ATTR_FC4_CT | ATTR_FC4_FCP);\n\n\t \n\tif ((phba->sli_rev == LPFC_SLI_REV4) && (vport == phba->pport) &&\n\t    phba->sli4_hba.pc_sli4_params.nvme)\n\t\tfc4types |= ATTR_FC4_NVME;\n\n\treturn lpfc_fdmi_set_attr_fc4types(attr, RPRT_SUPPORTED_FC4_TYPES,\n\t\t\tfc4types);\n}\n\nstatic int\nlpfc_fdmi_port_attr_support_speed(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tu32 speeds = 0;\n\tu32 tcfg;\n\tu8 i, cnt;\n\n\tif (!(phba->hba_flag & HBA_FCOE_MODE)) {\n\t\tcnt = 0;\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\ttcfg = phba->sli4_hba.conf_trunk;\n\t\t\tfor (i = 0; i < 4; i++, tcfg >>= 1)\n\t\t\t\tif (tcfg & 1)\n\t\t\t\t\tcnt++;\n\t\t}\n\n\t\tif (cnt > 2) {  \n\t\t\tif (phba->lmt & LMT_64Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_256GFC;\n\t\t\tif (phba->lmt & LMT_32Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_128GFC;\n\t\t\tif (phba->lmt & LMT_16Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_64GFC;\n\t\t} else if (cnt) {  \n\t\t\tif (phba->lmt & LMT_128Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_256GFC;\n\t\t\tif (phba->lmt & LMT_64Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_128GFC;\n\t\t\tif (phba->lmt & LMT_32Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_64GFC;\n\t\t\tif (phba->lmt & LMT_16Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_32GFC;\n\t\t} else {\n\t\t\tif (phba->lmt & LMT_256Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_256GFC;\n\t\t\tif (phba->lmt & LMT_128Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_128GFC;\n\t\t\tif (phba->lmt & LMT_64Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_64GFC;\n\t\t\tif (phba->lmt & LMT_32Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_32GFC;\n\t\t\tif (phba->lmt & LMT_16Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_16GFC;\n\t\t\tif (phba->lmt & LMT_10Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_10GFC;\n\t\t\tif (phba->lmt & LMT_8Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_8GFC;\n\t\t\tif (phba->lmt & LMT_4Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_4GFC;\n\t\t\tif (phba->lmt & LMT_2Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_2GFC;\n\t\t\tif (phba->lmt & LMT_1Gb)\n\t\t\t\tspeeds |= HBA_PORTSPEED_1GFC;\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (phba->fc_linkspeed) {\n\t\tcase LPFC_ASYNC_LINK_SPEED_10GBPS:\n\t\t\tspeeds = HBA_PORTSPEED_10GE;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_25GBPS:\n\t\t\tspeeds = HBA_PORTSPEED_25GE;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_40GBPS:\n\t\t\tspeeds = HBA_PORTSPEED_40GE;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_100GBPS:\n\t\t\tspeeds = HBA_PORTSPEED_100GE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_SUPPORTED_SPEED, speeds);\n}\n\nstatic int\nlpfc_fdmi_port_attr_speed(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tu32 speeds = 0;\n\n\tif (!(phba->hba_flag & HBA_FCOE_MODE)) {\n\t\tswitch (phba->fc_linkspeed) {\n\t\tcase LPFC_LINK_SPEED_1GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_1GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_2GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_2GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_4GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_4GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_8GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_8GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_10GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_10GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_16GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_16GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_32GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_32GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_64GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_64GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_128GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_128GFC;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_256GHZ:\n\t\t\tspeeds = HBA_PORTSPEED_256GFC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspeeds = HBA_PORTSPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (phba->fc_linkspeed) {\n\t\tcase LPFC_ASYNC_LINK_SPEED_10GBPS:\n\t\t\tspeeds = HBA_PORTSPEED_10GE;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_25GBPS:\n\t\t\tspeeds = HBA_PORTSPEED_25GE;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_40GBPS:\n\t\t\tspeeds = HBA_PORTSPEED_40GE;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_100GBPS:\n\t\t\tspeeds = HBA_PORTSPEED_100GE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspeeds = HBA_PORTSPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_PORT_SPEED, speeds);\n}\n\nstatic int\nlpfc_fdmi_port_attr_max_frame(struct lpfc_vport *vport, void *attr)\n{\n\tstruct serv_parm *hsp = (struct serv_parm *)&vport->fc_sparam;\n\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_MAX_FRAME_SIZE,\n\t\t\t(((uint32_t)hsp->cmn.bbRcvSizeMsb & 0x0F) << 8) |\n\t\t\t  (uint32_t)hsp->cmn.bbRcvSizeLsb);\n}\n\nstatic int\nlpfc_fdmi_port_attr_os_devname(struct lpfc_vport *vport, void *attr)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tchar buf[64] = { 0 };\n\n\tsnprintf(buf, sizeof(buf), \"/sys/class/scsi_host/host%d\",\n\t\t shost->host_no);\n\n\treturn lpfc_fdmi_set_attr_string(attr, RPRT_OS_DEVICE_NAME, buf);\n}\n\nstatic int\nlpfc_fdmi_port_attr_host_name(struct lpfc_vport *vport, void *attr)\n{\n\tchar buf[64] = { 0 };\n\n\tscnprintf(buf, sizeof(buf), \"%s\", vport->phba->os_host_name);\n\n\treturn lpfc_fdmi_set_attr_string(attr, RPRT_HOST_NAME, buf);\n}\n\nstatic int\nlpfc_fdmi_port_attr_wwnn(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_wwn(attr, RPRT_NODENAME,\n\t\t\t&vport->fc_sparam.nodeName);\n}\n\nstatic int\nlpfc_fdmi_port_attr_wwpn(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_wwn(attr, RPRT_PORTNAME,\n\t\t\t&vport->fc_sparam.portName);\n}\n\nstatic int\nlpfc_fdmi_port_attr_symbolic_name(struct lpfc_vport *vport, void *attr)\n{\n\tchar buf[256] = { 0 };\n\n\tlpfc_vport_symbolic_port_name(vport, buf, sizeof(buf));\n\n\treturn lpfc_fdmi_set_attr_string(attr, RPRT_SYM_PORTNAME, buf);\n}\n\nstatic int\nlpfc_fdmi_port_attr_port_type(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_PORT_TYPE,\n\t\t\t(phba->fc_topology == LPFC_TOPOLOGY_LOOP) ?\n\t\t\t\tLPFC_FDMI_PORTTYPE_NLPORT :\n\t\t\t\tLPFC_FDMI_PORTTYPE_NPORT);\n}\n\nstatic int\nlpfc_fdmi_port_attr_class(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_SUPPORTED_CLASS,\n\t\t\tFC_COS_CLASS2 | FC_COS_CLASS3);\n}\n\nstatic int\nlpfc_fdmi_port_attr_fabric_wwpn(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_wwn(attr, RPRT_FABRICNAME,\n\t\t\t&vport->fabric_portname);\n}\n\nstatic int\nlpfc_fdmi_port_attr_active_fc4type(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tu32 fc4types;\n\n\tfc4types = (ATTR_FC4_CT | ATTR_FC4_FCP);\n\n\t \n\tif (vport == phba->pport &&\n\t    phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME)\n\t\tfc4types |= ATTR_FC4_NVME;\n\n\treturn lpfc_fdmi_set_attr_fc4types(attr, RPRT_ACTIVE_FC4_TYPES,\n\t\t\tfc4types);\n}\n\nstatic int\nlpfc_fdmi_port_attr_port_state(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_PORT_STATE,\n\t\t\tLPFC_FDMI_PORTSTATE_ONLINE);\n}\n\nstatic int\nlpfc_fdmi_port_attr_num_disc(struct lpfc_vport *vport, void *attr)\n{\n\tvport->fdmi_num_disc = lpfc_find_map_node(vport);\n\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_DISC_PORT,\n\t\t\tvport->fdmi_num_disc);\n}\n\nstatic int\nlpfc_fdmi_port_attr_nportid(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_PORT_ID, vport->fc_myDID);\n}\n\nstatic int\nlpfc_fdmi_smart_attr_service(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_string(attr, RPRT_SMART_SERVICE,\n\t\t\t\"Smart SAN Initiator\");\n}\n\nstatic int\nlpfc_fdmi_smart_attr_guid(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_fullwwn(attr, RPRT_SMART_GUID,\n\t\t\t&vport->fc_sparam.nodeName,\n\t\t\t&vport->fc_sparam.portName);\n}\n\nstatic int\nlpfc_fdmi_smart_attr_version(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_string(attr, RPRT_SMART_VERSION,\n\t\t\t\"Smart SAN Version 2.0\");\n}\n\nstatic int\nlpfc_fdmi_smart_attr_model(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn lpfc_fdmi_set_attr_string(attr, RPRT_SMART_MODEL,\n\t\t\tphba->ModelName);\n}\n\nstatic int\nlpfc_fdmi_smart_attr_port_info(struct lpfc_vport *vport, void *attr)\n{\n\t \n\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_SMART_PORT_INFO,\n\t\t\t(vport->vpi) ?  2   : 1  );\n}\n\nstatic int\nlpfc_fdmi_smart_attr_qos(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_SMART_QOS, 0);\n}\n\nstatic int\nlpfc_fdmi_smart_attr_security(struct lpfc_vport *vport, void *attr)\n{\n\treturn lpfc_fdmi_set_attr_u32(attr, RPRT_SMART_SECURITY, 1);\n}\n\nstatic int\nlpfc_fdmi_vendor_attr_mi(struct lpfc_vport *vport, void *attr)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tchar buf[32] = { 0 };\n\n\tsprintf(buf, \"ELXE2EM:%04d\", phba->sli4_hba.pc_sli4_params.mi_ver);\n\n\treturn lpfc_fdmi_set_attr_string(attr, RPRT_VENDOR_MI, buf);\n}\n\n \nstatic int (*lpfc_fdmi_hba_action[])\n\t(struct lpfc_vport *vport, void *attrbuf) = {\n\t \n\tlpfc_fdmi_hba_attr_wwnn,\t   \n\tlpfc_fdmi_hba_attr_manufacturer,   \n\tlpfc_fdmi_hba_attr_sn,\t\t   \n\tlpfc_fdmi_hba_attr_model,\t   \n\tlpfc_fdmi_hba_attr_description,\t   \n\tlpfc_fdmi_hba_attr_hdw_ver,\t   \n\tlpfc_fdmi_hba_attr_drvr_ver,\t   \n\tlpfc_fdmi_hba_attr_rom_ver,\t   \n\tlpfc_fdmi_hba_attr_fmw_ver,\t   \n\tlpfc_fdmi_hba_attr_os_ver,\t   \n\tlpfc_fdmi_hba_attr_ct_len,\t   \n\tlpfc_fdmi_hba_attr_symbolic_name,  \n\tlpfc_fdmi_hba_attr_vendor_info,\t   \n\tlpfc_fdmi_hba_attr_num_ports,\t   \n\tlpfc_fdmi_hba_attr_fabric_wwnn,\t   \n\tlpfc_fdmi_hba_attr_bios_ver,\t   \n\tlpfc_fdmi_hba_attr_bios_state,\t   \n\tlpfc_fdmi_hba_attr_vendor_id,\t   \n};\n\n \nstatic int (*lpfc_fdmi_port_action[])\n\t(struct lpfc_vport *vport, void *attrbuf) = {\n\t \n\tlpfc_fdmi_port_attr_fc4type,         \n\tlpfc_fdmi_port_attr_support_speed,   \n\tlpfc_fdmi_port_attr_speed,           \n\tlpfc_fdmi_port_attr_max_frame,       \n\tlpfc_fdmi_port_attr_os_devname,      \n\tlpfc_fdmi_port_attr_host_name,       \n\tlpfc_fdmi_port_attr_wwnn,            \n\tlpfc_fdmi_port_attr_wwpn,            \n\tlpfc_fdmi_port_attr_symbolic_name,   \n\tlpfc_fdmi_port_attr_port_type,       \n\tlpfc_fdmi_port_attr_class,           \n\tlpfc_fdmi_port_attr_fabric_wwpn,     \n\tlpfc_fdmi_port_attr_active_fc4type,  \n\tlpfc_fdmi_port_attr_port_state,      \n\tlpfc_fdmi_port_attr_num_disc,        \n\tlpfc_fdmi_port_attr_nportid,         \n\tlpfc_fdmi_smart_attr_service,        \n\tlpfc_fdmi_smart_attr_guid,           \n\tlpfc_fdmi_smart_attr_version,        \n\tlpfc_fdmi_smart_attr_model,          \n\tlpfc_fdmi_smart_attr_port_info,      \n\tlpfc_fdmi_smart_attr_qos,            \n\tlpfc_fdmi_smart_attr_security,       \n\tlpfc_fdmi_vendor_attr_mi,            \n};\n\n \nint\nlpfc_fdmi_cmd(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t      int cmdcode, uint32_t new_mask)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_dmabuf *rq, *rsp;\n\tstruct lpfc_sli_ct_request *CtReq;\n\tstruct ulp_bde64_le *bde;\n\tuint32_t bit_pos;\n\tuint32_t size, addsz;\n\tuint32_t rsp_size;\n\tuint32_t mask;\n\tstruct lpfc_fdmi_reg_hba *rh;\n\tstruct lpfc_fdmi_port_entry *pe;\n\tstruct lpfc_fdmi_reg_portattr *pab = NULL, *base = NULL;\n\tstruct lpfc_fdmi_attr_block *ab = NULL;\n\tint  (*func)(struct lpfc_vport *vport, void *attrbuf);\n\tvoid (*cmpl)(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t     struct lpfc_iocbq *rspiocb);\n\n\tif (!ndlp)\n\t\treturn 0;\n\n\tcmpl = lpfc_cmpl_ct_disc_fdmi;  \n\n\t \n\t \n\trq = kmalloc(sizeof(*rq), GFP_KERNEL);\n\tif (!rq)\n\t\tgoto fdmi_cmd_exit;\n\n\trq->virt = lpfc_mbuf_alloc(phba, 0, &rq->phys);\n\tif (!rq->virt)\n\t\tgoto fdmi_cmd_free_rq;\n\n\t \n\trsp = kmalloc(sizeof(*rsp), GFP_KERNEL);\n\tif (!rsp)\n\t\tgoto fdmi_cmd_free_rqvirt;\n\n\trsp->virt = lpfc_mbuf_alloc(phba, 0, &rsp->phys);\n\tif (!rsp->virt)\n\t\tgoto fdmi_cmd_free_rsp;\n\n\tINIT_LIST_HEAD(&rq->list);\n\tINIT_LIST_HEAD(&rsp->list);\n\n\t \n\tmemset(rq->virt, 0, LPFC_BPL_SIZE);\n\trsp_size = LPFC_BPL_SIZE;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0218 FDMI Request x%x mask x%x Data: x%x x%x x%x\\n\",\n\t\t\t cmdcode, new_mask, vport->fdmi_port_mask,\n\t\t\t vport->fc_flag, vport->port_state);\n\n\tCtReq = (struct lpfc_sli_ct_request *)rq->virt;\n\n\t \n\tCtReq->RevisionId.bits.Revision = SLI_CT_REVISION;\n\tCtReq->RevisionId.bits.InId = 0;\n\n\tCtReq->FsType = SLI_CT_MANAGEMENT_SERVICE;\n\tCtReq->FsSubType = SLI_CT_FDMI_Subtypes;\n\n\tCtReq->CommandResponse.bits.CmdRsp = cpu_to_be16(cmdcode);\n\n\tsize = 0;\n\n\t \n\tswitch (cmdcode) {\n\tcase SLI_MGMT_RHAT:\n\tcase SLI_MGMT_RHBA:\n\t\trh = (struct lpfc_fdmi_reg_hba *)&CtReq->un;\n\t\t \n\t\tmemcpy(&rh->hi.PortName, &phba->pport->fc_sparam.portName,\n\t\t       sizeof(struct lpfc_name));\n\t\tsize += sizeof(struct lpfc_fdmi_hba_ident);\n\n\t\tif (cmdcode == SLI_MGMT_RHBA) {\n\t\t\t \n\t\t\t \n\t\t\trh->rpl.EntryCnt = cpu_to_be32(1);\n\t\t\tmemcpy(&rh->rpl.pe.PortName,\n\t\t\t       &phba->pport->fc_sparam.portName,\n\t\t\t       sizeof(struct lpfc_name));\n\t\t\tsize += sizeof(struct lpfc_fdmi_reg_port_list);\n\t\t}\n\n\t\tab = (struct lpfc_fdmi_attr_block *)((uint8_t *)rh + size);\n\t\tab->EntryCnt = 0;\n\t\tsize += FOURBYTES;\t \n\n\t\tbit_pos = 0;\n\t\tif (new_mask)\n\t\t\tmask = new_mask;\n\t\telse\n\t\t\tmask = vport->fdmi_hba_mask;\n\n\t\t \n\t\twhile (mask) {\n\t\t\tif (mask & 0x1) {\n\t\t\t\tfunc = lpfc_fdmi_hba_action[bit_pos];\n\t\t\t\taddsz = func(vport, ((uint8_t *)rh + size));\n\t\t\t\tif (addsz) {\n\t\t\t\t\tab->EntryCnt++;\n\t\t\t\t\tsize += addsz;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif ((size + FDMI_MAX_ATTRLEN) >\n\t\t\t\t    (LPFC_BPL_SIZE - LPFC_CT_PREAMBLE))\n\t\t\t\t\tgoto hba_out;\n\t\t\t}\n\t\t\tmask = mask >> 1;\n\t\t\tbit_pos++;\n\t\t}\nhba_out:\n\t\tab->EntryCnt = cpu_to_be32(ab->EntryCnt);\n\t\t \n\t\tsize += GID_REQUEST_SZ - 4;\n\t\tbreak;\n\n\tcase SLI_MGMT_RPRT:\n\t\tif (vport->port_type != LPFC_PHYSICAL_PORT) {\n\t\t\tndlp = lpfc_findnode_did(phba->pport, FDMI_DID);\n\t\t\tif (!ndlp)\n\t\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase SLI_MGMT_RPA:\n\t\t \n\t\tbase = (struct lpfc_fdmi_reg_portattr *)&CtReq->un;\n\n\t\tif (cmdcode == SLI_MGMT_RPRT) {\n\t\t\trh = (struct lpfc_fdmi_reg_hba *)base;\n\t\t\t \n\t\t\tmemcpy(&rh->hi.PortName,\n\t\t\t       &phba->pport->fc_sparam.portName,\n\t\t\t       sizeof(struct lpfc_name));\n\t\t\tpab = (struct lpfc_fdmi_reg_portattr *)\n\t\t\t\t((uint8_t *)base + sizeof(struct lpfc_name));\n\t\t\tsize += sizeof(struct lpfc_name);\n\t\t} else {\n\t\t\tpab = base;\n\t\t}\n\n\t\tmemcpy((uint8_t *)&pab->PortName,\n\t\t       (uint8_t *)&vport->fc_sparam.portName,\n\t\t       sizeof(struct lpfc_name));\n\t\tpab->ab.EntryCnt = 0;\n\t\t \n\t\tsize += sizeof(struct lpfc_name) + FOURBYTES;\n\n\t\tbit_pos = 0;\n\t\tif (new_mask)\n\t\t\tmask = new_mask;\n\t\telse\n\t\t\tmask = vport->fdmi_port_mask;\n\n\t\t \n\t\twhile (mask) {\n\t\t\tif (mask & 0x1) {\n\t\t\t\tfunc = lpfc_fdmi_port_action[bit_pos];\n\t\t\t\taddsz = func(vport, ((uint8_t *)base + size));\n\t\t\t\tif (addsz) {\n\t\t\t\t\tpab->ab.EntryCnt++;\n\t\t\t\t\tsize += addsz;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif ((size + FDMI_MAX_ATTRLEN) >\n\t\t\t\t    (LPFC_BPL_SIZE - LPFC_CT_PREAMBLE))\n\t\t\t\t\tgoto port_out;\n\t\t\t}\n\t\t\tmask = mask >> 1;\n\t\t\tbit_pos++;\n\t\t}\nport_out:\n\t\tpab->ab.EntryCnt = cpu_to_be32(pab->ab.EntryCnt);\n\t\tsize += GID_REQUEST_SZ - 4;\n\t\tbreak;\n\n\tcase SLI_MGMT_GHAT:\n\tcase SLI_MGMT_GRPL:\n\t\trsp_size = FC_MAX_NS_RSP;\n\t\tfallthrough;\n\tcase SLI_MGMT_DHBA:\n\tcase SLI_MGMT_DHAT:\n\t\tpe = (struct lpfc_fdmi_port_entry *)&CtReq->un;\n\t\tmemcpy((uint8_t *)&pe->PortName,\n\t\t       (uint8_t *)&vport->fc_sparam.portName,\n\t\t       sizeof(struct lpfc_name));\n\t\tsize = GID_REQUEST_SZ - 4 + sizeof(struct lpfc_name);\n\t\tbreak;\n\n\tcase SLI_MGMT_GPAT:\n\tcase SLI_MGMT_GPAS:\n\t\trsp_size = FC_MAX_NS_RSP;\n\t\tfallthrough;\n\tcase SLI_MGMT_DPRT:\n\t\tif (vport->port_type != LPFC_PHYSICAL_PORT) {\n\t\t\tndlp = lpfc_findnode_did(phba->pport, FDMI_DID);\n\t\t\tif (!ndlp)\n\t\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tcase SLI_MGMT_DPA:\n\t\tpe = (struct lpfc_fdmi_port_entry *)&CtReq->un;\n\t\tmemcpy((uint8_t *)&pe->PortName,\n\t\t       (uint8_t *)&vport->fc_sparam.portName,\n\t\t       sizeof(struct lpfc_name));\n\t\tsize = GID_REQUEST_SZ - 4 + sizeof(struct lpfc_name);\n\t\tbreak;\n\tcase SLI_MGMT_GRHL:\n\t\tsize = GID_REQUEST_SZ - 4;\n\t\tbreak;\n\tdefault:\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_DISCOVERY,\n\t\t\t\t \"0298 FDMI cmdcode x%x not supported\\n\",\n\t\t\t\t cmdcode);\n\t\tgoto fdmi_cmd_free_rspvirt;\n\t}\n\tCtReq->CommandResponse.bits.Size = cpu_to_be16(rsp_size);\n\n\tbde = (struct ulp_bde64_le *)rsp->virt;\n\tbde->addr_high = cpu_to_le32(putPaddrHigh(rq->phys));\n\tbde->addr_low = cpu_to_le32(putPaddrLow(rq->phys));\n\tbde->type_size = cpu_to_le32(ULP_BDE64_TYPE_BDE_64 <<\n\t\t\t\t     ULP_BDE64_TYPE_SHIFT);\n\tbde->type_size |= cpu_to_le32(size);\n\n\t \n\tif (!lpfc_ct_cmd(vport, rq, rsp, ndlp, cmpl, rsp_size, 0))\n\t\treturn 0;\n\nfdmi_cmd_free_rspvirt:\n\tlpfc_mbuf_free(phba, rsp->virt, rsp->phys);\nfdmi_cmd_free_rsp:\n\tkfree(rsp);\nfdmi_cmd_free_rqvirt:\n\tlpfc_mbuf_free(phba, rq->virt, rq->phys);\nfdmi_cmd_free_rq:\n\tkfree(rq);\nfdmi_cmd_exit:\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"0244 Issue FDMI request failed Data: x%x\\n\",\n\t\t\t cmdcode);\n\treturn 1;\n}\n\n \nvoid\nlpfc_delayed_disc_tmo(struct timer_list *t)\n{\n\tstruct lpfc_vport *vport = from_timer(vport, t, delayed_disc_tmo);\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t tmo_posted;\n\tunsigned long iflag;\n\n\tspin_lock_irqsave(&vport->work_port_lock, iflag);\n\ttmo_posted = vport->work_port_events & WORKER_DELAYED_DISC_TMO;\n\tif (!tmo_posted)\n\t\tvport->work_port_events |= WORKER_DELAYED_DISC_TMO;\n\tspin_unlock_irqrestore(&vport->work_port_lock, iflag);\n\n\tif (!tmo_posted)\n\t\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n \nvoid\nlpfc_delayed_disc_timeout_handler(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\tspin_lock_irq(shost->host_lock);\n\tif (!(vport->fc_flag & FC_DISC_DELAYED)) {\n\t\tspin_unlock_irq(shost->host_lock);\n\t\treturn;\n\t}\n\tvport->fc_flag &= ~FC_DISC_DELAYED;\n\tspin_unlock_irq(shost->host_lock);\n\n\tlpfc_do_scr_ns_plogi(vport->phba, vport);\n}\n\nvoid\nlpfc_decode_firmware_rev(struct lpfc_hba *phba, char *fwrevision, int flag)\n{\n\tstruct lpfc_sli *psli = &phba->sli;\n\tlpfc_vpd_t *vp = &phba->vpd;\n\tuint32_t b1, b2, b3, b4, i, rev;\n\tchar c;\n\tuint32_t *ptr, str[4];\n\tuint8_t *fwname;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tsnprintf(fwrevision, FW_REV_STR_SIZE, \"%s\", vp->rev.opFwName);\n\telse if (vp->rev.rBit) {\n\t\tif (psli->sli_flag & LPFC_SLI_ACTIVE)\n\t\t\trev = vp->rev.sli2FwRev;\n\t\telse\n\t\t\trev = vp->rev.sli1FwRev;\n\n\t\tb1 = (rev & 0x0000f000) >> 12;\n\t\tb2 = (rev & 0x00000f00) >> 8;\n\t\tb3 = (rev & 0x000000c0) >> 6;\n\t\tb4 = (rev & 0x00000030) >> 4;\n\n\t\tswitch (b4) {\n\t\tcase 0:\n\t\t\tc = 'N';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tc = 'A';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tc = 'B';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tc = 'X';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tc = 0;\n\t\t\tbreak;\n\t\t}\n\t\tb4 = (rev & 0x0000000f);\n\n\t\tif (psli->sli_flag & LPFC_SLI_ACTIVE)\n\t\t\tfwname = vp->rev.sli2FwName;\n\t\telse\n\t\t\tfwname = vp->rev.sli1FwName;\n\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tif (fwname[i] == 0x20)\n\t\t\t\tfwname[i] = 0;\n\n\t\tptr = (uint32_t*)fwname;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tstr[i] = be32_to_cpu(*ptr++);\n\n\t\tif (c == 0) {\n\t\t\tif (flag)\n\t\t\t\tsprintf(fwrevision, \"%d.%d%d (%s)\",\n\t\t\t\t\tb1, b2, b3, (char *)str);\n\t\t\telse\n\t\t\t\tsprintf(fwrevision, \"%d.%d%d\", b1,\n\t\t\t\t\tb2, b3);\n\t\t} else {\n\t\t\tif (flag)\n\t\t\t\tsprintf(fwrevision, \"%d.%d%d%c%d (%s)\",\n\t\t\t\t\tb1, b2, b3, c,\n\t\t\t\t\tb4, (char *)str);\n\t\t\telse\n\t\t\t\tsprintf(fwrevision, \"%d.%d%d%c%d\",\n\t\t\t\t\tb1, b2, b3, c, b4);\n\t\t}\n\t} else {\n\t\trev = vp->rev.smFwRev;\n\n\t\tb1 = (rev & 0xff000000) >> 24;\n\t\tb2 = (rev & 0x00f00000) >> 20;\n\t\tb3 = (rev & 0x000f0000) >> 16;\n\t\tc  = (rev & 0x0000ff00) >> 8;\n\t\tb4 = (rev & 0x000000ff);\n\n\t\tsprintf(fwrevision, \"%d.%d%d%c%d\", b1, b2, b3, c, b4);\n\t}\n\treturn;\n}\n\nstatic void\nlpfc_cmpl_ct_cmd_vmid(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t      struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_vport *vport = cmdiocb->vport;\n\tstruct lpfc_dmabuf *inp = cmdiocb->cmd_dmabuf;\n\tstruct lpfc_dmabuf *outp = cmdiocb->rsp_dmabuf;\n\tstruct lpfc_sli_ct_request *ctcmd = inp->virt;\n\tstruct lpfc_sli_ct_request *ctrsp = outp->virt;\n\t__be16 rsp = ctrsp->CommandResponse.bits.CmdRsp;\n\tstruct app_id_object *app;\n\tstruct lpfc_nodelist *ndlp = cmdiocb->ndlp;\n\tu32 cmd, hash, bucket;\n\tstruct lpfc_vmid *vmp, *cur;\n\tu8 *data = outp->virt;\n\tint i;\n\n\tcmd = be16_to_cpu(ctcmd->CommandResponse.bits.CmdRsp);\n\tif (cmd == SLI_CTAS_DALLAPP_ID)\n\t\tlpfc_ct_free_iocb(phba, cmdiocb);\n\n\tif (lpfc_els_chk_latt(vport) || get_job_ulpstatus(phba, rspiocb)) {\n\t\tif (cmd != SLI_CTAS_DALLAPP_ID)\n\t\t\tgoto free_res;\n\t}\n\t \n\tif (be16_to_cpu(rsp) == SLI_CT_RESPONSE_FS_RJT) {\n\t\tif (cmd != SLI_CTAS_DALLAPP_ID)\n\t\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t\t \"3306 VMID FS_RJT Data: x%x x%x x%x\\n\",\n\t\t\t\t\t cmd, ctrsp->ReasonCode,\n\t\t\t\t\t ctrsp->Explanation);\n\t\tif ((cmd != SLI_CTAS_DALLAPP_ID) ||\n\t\t    (ctrsp->ReasonCode != SLI_CT_UNABLE_TO_PERFORM_REQ) ||\n\t\t    (ctrsp->Explanation != SLI_CT_APP_ID_NOT_AVAILABLE)) {\n\t\t\t \n\t\t\tif (cmd == SLI_CTAS_DALLAPP_ID)\n\t\t\t\tvport->load_flag |= FC_DEREGISTER_ALL_APP_ID;\n\t\t\tgoto free_res;\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase SLI_CTAS_RAPP_IDENT:\n\t\tapp = (struct app_id_object *)(RAPP_IDENT_OFFSET + data);\n\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t \"6712 RAPP_IDENT app id %d  port id x%x id \"\n\t\t\t\t \"len %d\\n\", be32_to_cpu(app->app_id),\n\t\t\t\t be32_to_cpu(app->port_id),\n\t\t\t\t app->obj.entity_id_len);\n\n\t\tif (app->obj.entity_id_len == 0 || app->port_id == 0)\n\t\t\tgoto free_res;\n\n\t\thash = lpfc_vmid_hash_fn(app->obj.entity_id,\n\t\t\t\t\t app->obj.entity_id_len);\n\t\tvmp = lpfc_get_vmid_from_hashtable(vport, hash,\n\t\t\t\t\t\t  app->obj.entity_id);\n\t\tif (vmp) {\n\t\t\twrite_lock(&vport->vmid_lock);\n\t\t\tvmp->un.app_id = be32_to_cpu(app->app_id);\n\t\t\tvmp->flag |= LPFC_VMID_REGISTERED;\n\t\t\tvmp->flag &= ~LPFC_VMID_REQ_REGISTER;\n\t\t\twrite_unlock(&vport->vmid_lock);\n\t\t\t \n\t\t\tvport->vmid_flag |= LPFC_VMID_IN_USE;\n\t\t} else {\n\t\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t\t \"6901 No entry found %s hash %d\\n\",\n\t\t\t\t\t app->obj.entity_id, hash);\n\t\t}\n\t\tbreak;\n\tcase SLI_CTAS_DAPP_IDENT:\n\t\tapp = (struct app_id_object *)(DAPP_IDENT_OFFSET + data);\n\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t \"6713 DAPP_IDENT app id %d  port id x%x\\n\",\n\t\t\t\t be32_to_cpu(app->app_id),\n\t\t\t\t be32_to_cpu(app->port_id));\n\t\tbreak;\n\tcase SLI_CTAS_DALLAPP_ID:\n\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t \"8856 Deregistered all app ids\\n\");\n\t\tread_lock(&vport->vmid_lock);\n\t\tfor (i = 0; i < phba->cfg_max_vmid; i++) {\n\t\t\tvmp = &vport->vmid[i];\n\t\t\tif (vmp->flag != LPFC_VMID_SLOT_FREE)\n\t\t\t\tmemset(vmp, 0, sizeof(struct lpfc_vmid));\n\t\t}\n\t\tread_unlock(&vport->vmid_lock);\n\t\t \n\t\tif (!hash_empty(vport->hash_table))\n\t\t\thash_for_each(vport->hash_table, bucket, cur, hnode)\n\t\t\t\thash_del(&cur->hnode);\n\t\tvport->load_flag |= FC_ALLOW_VMID;\n\t\tbreak;\n\tdefault:\n\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t \"8857 Invalid command code\\n\");\n\t}\nfree_res:\n\tlpfc_ct_free_iocb(phba, cmdiocb);\n\tlpfc_nlp_put(ndlp);\n}\n\n \nint\nlpfc_vmid_cmd(struct lpfc_vport *vport,\n\t      int cmdcode, struct lpfc_vmid *vmid)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_dmabuf *mp, *bmp;\n\tstruct lpfc_sli_ct_request *ctreq;\n\tstruct ulp_bde64 *bpl;\n\tu32 size;\n\tu32 rsp_size;\n\tu8 *data;\n\tstruct lpfc_vmid_rapp_ident_list *rap;\n\tstruct lpfc_vmid_dapp_ident_list *dap;\n\tu8 retry = 0;\n\tstruct lpfc_nodelist *ndlp;\n\n\tvoid (*cmpl)(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t     struct lpfc_iocbq *rspiocb);\n\n\tndlp = lpfc_findnode_did(vport, FDMI_DID);\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_UNMAPPED_NODE)\n\t\treturn 0;\n\n\tcmpl = lpfc_cmpl_ct_cmd_vmid;\n\n\t \n\t \n\tmp = kmalloc(sizeof(*mp), GFP_KERNEL);\n\tif (!mp)\n\t\tgoto vmid_free_mp_exit;\n\n\tmp->virt = lpfc_mbuf_alloc(phba, 0, &mp->phys);\n\tif (!mp->virt)\n\t\tgoto vmid_free_mp_virt_exit;\n\n\t \n\tbmp = kmalloc(sizeof(*bmp), GFP_KERNEL);\n\tif (!bmp)\n\t\tgoto vmid_free_bmp_exit;\n\n\tbmp->virt = lpfc_mbuf_alloc(phba, 0, &bmp->phys);\n\tif (!bmp->virt)\n\t\tgoto vmid_free_bmp_virt_exit;\n\n\tINIT_LIST_HEAD(&mp->list);\n\tINIT_LIST_HEAD(&bmp->list);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_DISCOVERY,\n\t\t\t \"3275 VMID Request Data: x%x x%x x%x\\n\",\n\t\t\t vport->fc_flag, vport->port_state, cmdcode);\n\tctreq = (struct lpfc_sli_ct_request *)mp->virt;\n\tdata = mp->virt;\n\t \n\tmemset(data, 0, LPFC_BPL_SIZE);\n\tctreq->RevisionId.bits.Revision = SLI_CT_REVISION;\n\tctreq->RevisionId.bits.InId = 0;\n\n\tctreq->FsType = SLI_CT_MANAGEMENT_SERVICE;\n\tctreq->FsSubType = SLI_CT_APP_SEV_Subtypes;\n\n\tctreq->CommandResponse.bits.CmdRsp = cpu_to_be16(cmdcode);\n\trsp_size = LPFC_BPL_SIZE;\n\tsize = 0;\n\n\tswitch (cmdcode) {\n\tcase SLI_CTAS_RAPP_IDENT:\n\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t \"1329 RAPP_IDENT for %s\\n\", vmid->host_vmid);\n\t\tctreq->un.PortID = cpu_to_be32(vport->fc_myDID);\n\t\trap = (struct lpfc_vmid_rapp_ident_list *)\n\t\t\t(DAPP_IDENT_OFFSET + data);\n\t\trap->no_of_objects = cpu_to_be32(1);\n\t\trap->obj[0].entity_id_len = vmid->vmid_len;\n\t\tmemcpy(rap->obj[0].entity_id, vmid->host_vmid, vmid->vmid_len);\n\t\tsize = RAPP_IDENT_OFFSET +\n\t\t       struct_size(rap, obj, be32_to_cpu(rap->no_of_objects));\n\t\tretry = 1;\n\t\tbreak;\n\n\tcase SLI_CTAS_GALLAPPIA_ID:\n\t\tctreq->un.PortID = cpu_to_be32(vport->fc_myDID);\n\t\tsize = GALLAPPIA_ID_SIZE;\n\t\tbreak;\n\n\tcase SLI_CTAS_DAPP_IDENT:\n\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t \"1469 DAPP_IDENT for %s\\n\", vmid->host_vmid);\n\t\tctreq->un.PortID = cpu_to_be32(vport->fc_myDID);\n\t\tdap = (struct lpfc_vmid_dapp_ident_list *)\n\t\t\t(DAPP_IDENT_OFFSET + data);\n\t\tdap->no_of_objects = cpu_to_be32(1);\n\t\tdap->obj[0].entity_id_len = vmid->vmid_len;\n\t\tmemcpy(dap->obj[0].entity_id, vmid->host_vmid, vmid->vmid_len);\n\t\tsize = DAPP_IDENT_OFFSET +\n\t\t       struct_size(dap, obj, be32_to_cpu(dap->no_of_objects));\n\t\twrite_lock(&vport->vmid_lock);\n\t\tvmid->flag &= ~LPFC_VMID_REGISTERED;\n\t\twrite_unlock(&vport->vmid_lock);\n\t\tretry = 1;\n\t\tbreak;\n\n\tcase SLI_CTAS_DALLAPP_ID:\n\t\tctreq->un.PortID = cpu_to_be32(vport->fc_myDID);\n\t\tsize = DALLAPP_ID_SIZE;\n\t\tbreak;\n\n\tdefault:\n\t\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t\t \"7062 VMID cmdcode x%x not supported\\n\",\n\t\t\t\t cmdcode);\n\t\tgoto vmid_free_all_mem;\n\t}\n\n\tctreq->CommandResponse.bits.Size = cpu_to_be16(rsp_size);\n\n\tbpl = (struct ulp_bde64 *)bmp->virt;\n\tbpl->addrHigh = putPaddrHigh(mp->phys);\n\tbpl->addrLow = putPaddrLow(mp->phys);\n\tbpl->tus.f.bdeFlags = 0;\n\tbpl->tus.f.bdeSize = size;\n\n\t \n\tif (!lpfc_ct_cmd(vport, mp, bmp, ndlp, cmpl, rsp_size, retry))\n\t\treturn 0;\n\n vmid_free_all_mem:\n\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\n vmid_free_bmp_virt_exit:\n\tkfree(bmp);\n vmid_free_bmp_exit:\n\tlpfc_mbuf_free(phba, mp->virt, mp->phys);\n vmid_free_mp_virt_exit:\n\tkfree(mp);\n vmid_free_mp_exit:\n\n\t \n\tlpfc_printf_vlog(vport, KERN_DEBUG, LOG_DISCOVERY,\n\t\t\t \"3276 VMID CT request failed Data: x%x\\n\", cmdcode);\n\treturn -EIO;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}