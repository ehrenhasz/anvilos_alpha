{
  "module_name": "lpfc_vmid.c",
  "hash_id": "fe4f5d0111a86f2f16e4a04d1bf6552e53bfb416127bd383b874a87cf6e021af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_vmid.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/dma-direction.h>\n\n#include <scsi/scsi_transport_fc.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_crtn.h\"\n\n\n \nstruct lpfc_vmid *lpfc_get_vmid_from_hashtable(struct lpfc_vport *vport,\n\t\t\t\t\t       u32 hash, u8 *buf)\n{\n\tstruct lpfc_vmid *vmp;\n\n\thash_for_each_possible(vport->hash_table, vmp, hnode, hash) {\n\t\tif (memcmp(&vmp->host_vmid[0], buf, 16) == 0)\n\t\t\treturn vmp;\n\t}\n\treturn NULL;\n}\n\n \nstatic void\nlpfc_put_vmid_in_hashtable(struct lpfc_vport *vport, u32 hash,\n\t\t\t   struct lpfc_vmid *vmp)\n{\n\thash_add(vport->hash_table, &vmp->hnode, hash);\n}\n\n \nint lpfc_vmid_hash_fn(const char *vmid, int len)\n{\n\tint c;\n\tint hash = 0;\n\n\tif (len == 0)\n\t\treturn 0;\n\twhile (len--) {\n\t\tc = *vmid++;\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc += 'a' - 'A';\n\n\t\thash = (hash + (c << LPFC_VMID_HASH_SHIFT) +\n\t\t\t(c >> LPFC_VMID_HASH_SHIFT)) * 19;\n\t}\n\n\treturn hash & LPFC_VMID_HASH_MASK;\n}\n\n \nstatic void lpfc_vmid_update_entry(struct lpfc_vport *vport,\n\t\t\t\t   enum dma_data_direction iodir,\n\t\t\t\t   struct lpfc_vmid *vmp,\n\t\t\t\t   union lpfc_vmid_io_tag *tag)\n{\n\tu64 *lta;\n\n\tif (vport->phba->pport->vmid_flag & LPFC_VMID_TYPE_PRIO)\n\t\ttag->cs_ctl_vmid = vmp->un.cs_ctl_vmid;\n\telse if (vport->phba->cfg_vmid_app_header)\n\t\ttag->app_id = vmp->un.app_id;\n\n\tif (iodir == DMA_TO_DEVICE)\n\t\tvmp->io_wr_cnt++;\n\telse if (iodir == DMA_FROM_DEVICE)\n\t\tvmp->io_rd_cnt++;\n\n\t \n\tlta = per_cpu_ptr(vmp->last_io_time, raw_smp_processor_id());\n\t*lta = jiffies;\n}\n\nstatic void lpfc_vmid_assign_cs_ctl(struct lpfc_vport *vport,\n\t\t\t\t    struct lpfc_vmid *vmid)\n{\n\tu32 hash;\n\tstruct lpfc_vmid *pvmid;\n\n\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\tvmid->un.cs_ctl_vmid = lpfc_vmid_get_cs_ctl(vport);\n\t} else {\n\t\thash = lpfc_vmid_hash_fn(vmid->host_vmid, vmid->vmid_len);\n\t\tpvmid =\n\t\t    lpfc_get_vmid_from_hashtable(vport->phba->pport, hash,\n\t\t\t\t\t\t vmid->host_vmid);\n\t\tif (pvmid)\n\t\t\tvmid->un.cs_ctl_vmid = pvmid->un.cs_ctl_vmid;\n\t\telse\n\t\t\tvmid->un.cs_ctl_vmid = lpfc_vmid_get_cs_ctl(vport);\n\t}\n}\n\n \nint lpfc_vmid_get_appid(struct lpfc_vport *vport, char *uuid,\n\t\t\tenum dma_data_direction iodir,\n\t\t\tunion lpfc_vmid_io_tag *tag)\n{\n\tstruct lpfc_vmid *vmp = NULL;\n\tint hash, len, rc = -EPERM, i;\n\n\t \n\tif (lpfc_vmid_is_type_priority_tag(vport) &&\n\t    !(vport->vmid_flag & LPFC_VMID_QFPA_CMPL) &&\n\t    (vport->vmid_flag & LPFC_VMID_ISSUE_QFPA)) {\n\t\tvport->work_port_events |= WORKER_CHECK_VMID_ISSUE_QFPA;\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tlen = strlen(uuid);\n\thash = lpfc_vmid_hash_fn(uuid, len);\n\n\t \n\tread_lock(&vport->vmid_lock);\n\tvmp = lpfc_get_vmid_from_hashtable(vport, hash, uuid);\n\n\t \n\tif (vmp  && vmp->flag & LPFC_VMID_REGISTERED) {\n\t\tread_unlock(&vport->vmid_lock);\n\t\tlpfc_vmid_update_entry(vport, iodir, vmp, tag);\n\t\trc = 0;\n\t} else if (vmp && (vmp->flag & LPFC_VMID_REQ_REGISTER ||\n\t\t\t   vmp->flag & LPFC_VMID_DE_REGISTER)) {\n\t\t \n\t\t \n\t\tread_unlock(&vport->vmid_lock);\n\t\trc = -EBUSY;\n\t} else {\n\t\t \n\t\t \n\t\tread_unlock(&vport->vmid_lock);\n\t\t \n\t\t \n\t\twrite_lock(&vport->vmid_lock);\n\t\tvmp = lpfc_get_vmid_from_hashtable(vport, hash, uuid);\n\n\t\t \n\t\t \n\t\tif (vmp && vmp->flag & LPFC_VMID_REGISTERED) {\n\t\t\tlpfc_vmid_update_entry(vport, iodir, vmp, tag);\n\t\t\twrite_unlock(&vport->vmid_lock);\n\t\t\treturn 0;\n\t\t} else if (vmp && vmp->flag & LPFC_VMID_REQ_REGISTER) {\n\t\t\twrite_unlock(&vport->vmid_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tif (vport->cur_vmid_cnt < vport->max_vmid) {\n\t\t\tfor (i = 0; i < vport->max_vmid; i++) {\n\t\t\t\tvmp = vport->vmid + i;\n\t\t\t\tif (vmp->flag == LPFC_VMID_SLOT_FREE)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == vport->max_vmid)\n\t\t\t\tvmp = NULL;\n\t\t} else {\n\t\t\tvmp = NULL;\n\t\t}\n\n\t\tif (!vmp) {\n\t\t\twrite_unlock(&vport->vmid_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tlpfc_put_vmid_in_hashtable(vport, hash, vmp);\n\t\tvmp->vmid_len = len;\n\t\tmemcpy(vmp->host_vmid, uuid, vmp->vmid_len);\n\t\tvmp->io_rd_cnt = 0;\n\t\tvmp->io_wr_cnt = 0;\n\t\tvmp->flag = LPFC_VMID_SLOT_USED;\n\n\t\tvmp->delete_inactive =\n\t\t\tvport->vmid_inactivity_timeout ? 1 : 0;\n\n\t\t \n\t\tif (vport->phba->pport->vmid_flag & LPFC_VMID_TYPE_PRIO)\n\t\t\tlpfc_vmid_assign_cs_ctl(vport, vmp);\n\n\t\t \n\t\t \n\t\tif (!vmp->last_io_time)\n\t\t\tvmp->last_io_time = alloc_percpu_gfp(u64, GFP_ATOMIC);\n\t\tif (!vmp->last_io_time) {\n\t\t\thash_del(&vmp->hnode);\n\t\t\tvmp->flag = LPFC_VMID_SLOT_FREE;\n\t\t\twrite_unlock(&vport->vmid_lock);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\twrite_unlock(&vport->vmid_lock);\n\n\t\t \n\t\tif (vport->phba->pport->vmid_flag & LPFC_VMID_TYPE_PRIO)\n\t\t\trc = lpfc_vmid_uvem(vport, vmp, true);\n\t\telse if (vport->phba->cfg_vmid_app_header)\n\t\t\trc = lpfc_vmid_cmd(vport, SLI_CTAS_RAPP_IDENT, vmp);\n\t\tif (!rc) {\n\t\t\twrite_lock(&vport->vmid_lock);\n\t\t\tvport->cur_vmid_cnt++;\n\t\t\tvmp->flag |= LPFC_VMID_REQ_REGISTER;\n\t\t\twrite_unlock(&vport->vmid_lock);\n\t\t} else {\n\t\t\twrite_lock(&vport->vmid_lock);\n\t\t\thash_del(&vmp->hnode);\n\t\t\tvmp->flag = LPFC_VMID_SLOT_FREE;\n\t\t\tfree_percpu(vmp->last_io_time);\n\t\t\twrite_unlock(&vport->vmid_lock);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (!(vport->phba->pport->vmid_flag & LPFC_VMID_TIMER_ENBLD)) {\n\t\t\tmod_timer(&vport->phba->inactive_vmid_poll,\n\t\t\t\t  jiffies +\n\t\t\t\t  msecs_to_jiffies(1000 * LPFC_VMID_TIMER));\n\t\t\tvport->phba->pport->vmid_flag |= LPFC_VMID_TIMER_ENBLD;\n\t\t}\n\t}\n\treturn rc;\n}\n\n \nvoid\nlpfc_reinit_vmid(struct lpfc_vport *vport)\n{\n\tu32 bucket, i, cpu;\n\tstruct lpfc_vmid *cur;\n\tstruct lpfc_vmid *vmp = NULL;\n\tstruct hlist_node *tmp;\n\n\twrite_lock(&vport->vmid_lock);\n\tvport->cur_vmid_cnt = 0;\n\n\tfor (i = 0; i < vport->max_vmid; i++) {\n\t\tvmp = &vport->vmid[i];\n\t\tvmp->flag = LPFC_VMID_SLOT_FREE;\n\t\tmemset(vmp->host_vmid, 0, sizeof(vmp->host_vmid));\n\t\tvmp->io_rd_cnt = 0;\n\t\tvmp->io_wr_cnt = 0;\n\n\t\tif (vmp->last_io_time)\n\t\t\tfor_each_possible_cpu(cpu)\n\t\t\t\t*per_cpu_ptr(vmp->last_io_time, cpu) = 0;\n\t}\n\n\t \n\tif (!hash_empty(vport->hash_table))\n\t\thash_for_each_safe(vport->hash_table, bucket, tmp, cur, hnode)\n\t\t\thash_del(&cur->hnode);\n\twrite_unlock(&vport->vmid_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}