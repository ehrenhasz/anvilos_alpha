{
  "module_name": "lpfc_nvme.c",
  "hash_id": "33e091f703c9d01c021ce89eb86b292413073bf50d8928d8bd2902b9de5d7a98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_nvme.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <asm/unaligned.h>\n#include <linux/crc-t10dif.h>\n#include <net/checksum.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_version.h\"\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_nvme.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_debugfs.h\"\n\n \n\nstatic struct lpfc_io_buf *\nlpfc_get_nvme_buf(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,\n\t\t  int idx, int expedite);\n\nstatic void\nlpfc_release_nvme_buf(struct lpfc_hba *, struct lpfc_io_buf *);\n\nstatic struct nvme_fc_port_template lpfc_nvme_template;\n\n \nstatic int\nlpfc_nvme_create_queue(struct nvme_fc_local_port *pnvme_lport,\n\t\t       unsigned int qidx, u16 qsize,\n\t\t       void **handle)\n{\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_nvme_qhandle *qhandle;\n\tchar *str;\n\n\tif (!pnvme_lport->private)\n\t\treturn -ENOMEM;\n\n\tlport = (struct lpfc_nvme_lport *)pnvme_lport->private;\n\tvport = lport->vport;\n\n\tif (!vport || vport->load_flag & FC_UNLOADING ||\n\t    vport->phba->hba_flag & HBA_IOQ_FLUSH)\n\t\treturn -ENODEV;\n\n\tqhandle = kzalloc(sizeof(struct lpfc_nvme_qhandle), GFP_KERNEL);\n\tif (qhandle == NULL)\n\t\treturn -ENOMEM;\n\n\tqhandle->cpu_id = raw_smp_processor_id();\n\tqhandle->qidx = qidx;\n\t \n\tif (qidx) {\n\t\tstr = \"IO \";   \n\t\tqhandle->index = ((qidx - 1) %\n\t\t\tlpfc_nvme_template.max_hw_queues);\n\t} else {\n\t\tstr = \"ADM\";   \n\t\tqhandle->index = qidx;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME,\n\t\t\t \"6073 Binding %s HdwQueue %d  (cpu %d) to \"\n\t\t\t \"hdw_queue %d qhandle x%px\\n\", str,\n\t\t\t qidx, qhandle->cpu_id, qhandle->index, qhandle);\n\t*handle = (void *)qhandle;\n\treturn 0;\n}\n\n \nstatic void\nlpfc_nvme_delete_queue(struct nvme_fc_local_port *pnvme_lport,\n\t\t       unsigned int qidx,\n\t\t       void *handle)\n{\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_vport *vport;\n\n\tif (!pnvme_lport->private)\n\t\treturn;\n\n\tlport = (struct lpfc_nvme_lport *)pnvme_lport->private;\n\tvport = lport->vport;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME,\n\t\t\t\"6001 ENTER.  lpfc_pnvme x%px, qidx x%x qhandle x%px\\n\",\n\t\t\tlport, qidx, handle);\n\tkfree(handle);\n}\n\nstatic void\nlpfc_nvme_localport_delete(struct nvme_fc_local_port *localport)\n{\n\tstruct lpfc_nvme_lport *lport = localport->private;\n\n\tlpfc_printf_vlog(lport->vport, KERN_INFO, LOG_NVME,\n\t\t\t \"6173 localport x%px delete complete\\n\",\n\t\t\t lport);\n\n\t \n\tif (lport->vport->localport)\n\t\tcomplete(lport->lport_unreg_cmp);\n}\n\n \nstatic void\nlpfc_nvme_remoteport_delete(struct nvme_fc_remote_port *remoteport)\n{\n\tstruct lpfc_nvme_rport *rport = remoteport->private;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_nodelist *ndlp;\n\tu32 fc4_xpt_flags;\n\n\tndlp = rport->ndlp;\n\tif (!ndlp) {\n\t\tpr_err(\"**** %s: NULL ndlp on rport x%px remoteport x%px\\n\",\n\t\t       __func__, rport, remoteport);\n\t\tgoto rport_err;\n\t}\n\n\tvport = ndlp->vport;\n\tif (!vport) {\n\t\tpr_err(\"**** %s: Null vport on ndlp x%px, ste x%x rport x%px\\n\",\n\t\t       __func__, ndlp, ndlp->nlp_state, rport);\n\t\tgoto rport_err;\n\t}\n\n\tfc4_xpt_flags = NVME_XPT_REGD | SCSI_XPT_REGD;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t \"6146 remoteport delete of remoteport x%px, ndlp x%px \"\n\t\t\t \"DID x%x xflags x%x\\n\",\n\t\t\t remoteport, ndlp, ndlp->nlp_DID, ndlp->fc4_xpt_flags);\n\tspin_lock_irq(&ndlp->lock);\n\n\t \n\tif (ndlp->fc4_xpt_flags & NVME_XPT_UNREG_WAIT)\n\t\tndlp->fc4_xpt_flags &= ~(NVME_XPT_UNREG_WAIT | NVME_XPT_REGD);\n\n\tspin_unlock_irq(&ndlp->lock);\n\n\t \n\tif (!(ndlp->fc4_xpt_flags & fc4_xpt_flags))\n\t\tlpfc_disc_state_machine(vport, ndlp, NULL, NLP_EVT_DEVICE_RM);\n\n rport_err:\n\treturn;\n}\n\n \nint\nlpfc_nvme_handle_lsreq(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_async_xchg_ctx *axchg)\n{\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_nvme_rport *lpfc_rport;\n\tstruct nvme_fc_remote_port *remoteport;\n\tstruct lpfc_nvme_lport *lport;\n\tuint32_t *payload = axchg->payload;\n\tint rc;\n\n\tvport = axchg->ndlp->vport;\n\tlpfc_rport = axchg->ndlp->nrport;\n\tif (!lpfc_rport)\n\t\treturn -EINVAL;\n\n\tremoteport = lpfc_rport->remoteport;\n\tif (!vport->localport ||\n\t    vport->phba->hba_flag & HBA_IOQ_FLUSH)\n\t\treturn -EINVAL;\n\n\tlport = vport->localport->private;\n\tif (!lport)\n\t\treturn -EINVAL;\n\n\trc = nvme_fc_rcv_ls_req(remoteport, &axchg->ls_rsp, axchg->payload,\n\t\t\t\taxchg->size);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME_DISC,\n\t\t\t\"6205 NVME Unsol rcv: sz %d rc %d: %08x %08x %08x \"\n\t\t\t\"%08x %08x %08x\\n\",\n\t\t\taxchg->size, rc,\n\t\t\t*payload, *(payload+1), *(payload+2),\n\t\t\t*(payload+3), *(payload+4), *(payload+5));\n\n\tif (!rc)\n\t\treturn 0;\n#endif\n\treturn 1;\n}\n\n \nvoid\n__lpfc_nvme_ls_req_cmp(struct lpfc_hba *phba, struct lpfc_vport *vport,\n\t\t\tstruct lpfc_iocbq *cmdwqe,\n\t\t\tstruct lpfc_wcqe_complete *wcqe)\n{\n\tstruct nvmefc_ls_req *pnvme_lsreq;\n\tstruct lpfc_dmabuf *buf_ptr;\n\tstruct lpfc_nodelist *ndlp;\n\tint status;\n\n\tpnvme_lsreq = cmdwqe->context_un.nvme_lsreq;\n\tndlp = cmdwqe->ndlp;\n\tbuf_ptr = cmdwqe->bpl_dmabuf;\n\n\tstatus = bf_get(lpfc_wcqe_c_status, wcqe);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t \"6047 NVMEx LS REQ x%px cmpl DID %x Xri: %x \"\n\t\t\t \"status %x reason x%x cmd:x%px lsreg:x%px bmp:x%px \"\n\t\t\t \"ndlp:x%px\\n\",\n\t\t\t pnvme_lsreq, ndlp ? ndlp->nlp_DID : 0,\n\t\t\t cmdwqe->sli4_xritag, status,\n\t\t\t (wcqe->parameter & 0xffff),\n\t\t\t cmdwqe, pnvme_lsreq, cmdwqe->bpl_dmabuf,\n\t\t\t ndlp);\n\n\tlpfc_nvmeio_data(phba, \"NVMEx LS CMPL: xri x%x stat x%x parm x%x\\n\",\n\t\t\t cmdwqe->sli4_xritag, status, wcqe->parameter);\n\n\tif (buf_ptr) {\n\t\tlpfc_mbuf_free(phba, buf_ptr->virt, buf_ptr->phys);\n\t\tkfree(buf_ptr);\n\t\tcmdwqe->bpl_dmabuf = NULL;\n\t}\n\tif (pnvme_lsreq->done) {\n\t\tif (status != CQE_STATUS_SUCCESS)\n\t\t\tstatus = -ENXIO;\n\t\tpnvme_lsreq->done(pnvme_lsreq, status);\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6046 NVMEx cmpl without done call back? \"\n\t\t\t\t \"Data x%px DID %x Xri: %x status %x\\n\",\n\t\t\t\tpnvme_lsreq, ndlp ? ndlp->nlp_DID : 0,\n\t\t\t\tcmdwqe->sli4_xritag, status);\n\t}\n\tif (ndlp) {\n\t\tlpfc_nlp_put(ndlp);\n\t\tcmdwqe->ndlp = NULL;\n\t}\n\tlpfc_sli_release_iocbq(phba, cmdwqe);\n}\n\nstatic void\nlpfc_nvme_ls_req_cmp(struct lpfc_hba *phba, struct lpfc_iocbq *cmdwqe,\n\t\t     struct lpfc_iocbq *rspwqe)\n{\n\tstruct lpfc_vport *vport = cmdwqe->vport;\n\tstruct lpfc_nvme_lport *lport;\n\tuint32_t status;\n\tstruct lpfc_wcqe_complete *wcqe = &rspwqe->wcqe_cmpl;\n\n\tstatus = bf_get(lpfc_wcqe_c_status, wcqe);\n\n\tif (vport->localport) {\n\t\tlport = (struct lpfc_nvme_lport *)vport->localport->private;\n\t\tif (lport) {\n\t\t\tatomic_inc(&lport->fc4NvmeLsCmpls);\n\t\t\tif (status) {\n\t\t\t\tif (bf_get(lpfc_wcqe_c_xb, wcqe))\n\t\t\t\t\tatomic_inc(&lport->cmpl_ls_xb);\n\t\t\t\tatomic_inc(&lport->cmpl_ls_err);\n\t\t\t}\n\t\t}\n\t}\n\n\t__lpfc_nvme_ls_req_cmp(phba, vport, cmdwqe, wcqe);\n}\n\nstatic int\nlpfc_nvme_gen_req(struct lpfc_vport *vport, struct lpfc_dmabuf *bmp,\n\t\t  struct lpfc_dmabuf *inp,\n\t\t  struct nvmefc_ls_req *pnvme_lsreq,\n\t\t  void (*cmpl)(struct lpfc_hba *, struct lpfc_iocbq *,\n\t\t\t       struct lpfc_iocbq *),\n\t\t  struct lpfc_nodelist *ndlp, uint32_t num_entry,\n\t\t  uint32_t tmo, uint8_t retry)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tunion lpfc_wqe128 *wqe;\n\tstruct lpfc_iocbq *genwqe;\n\tstruct ulp_bde64 *bpl;\n\tstruct ulp_bde64 bde;\n\tint i, rc, xmit_len, first_len;\n\n\t \n\tgenwqe = lpfc_sli_get_iocbq(phba);\n\tif (genwqe == NULL)\n\t\treturn 1;\n\n\twqe = &genwqe->wqe;\n\t \n\tmemset(wqe, 0, sizeof(union lpfc_wqe));\n\n\tgenwqe->bpl_dmabuf = bmp;\n\tgenwqe->cmd_flag |= LPFC_IO_NVME_LS;\n\n\t \n\tgenwqe->ndlp = lpfc_nlp_get(ndlp);\n\tif (!genwqe->ndlp) {\n\t\tdev_warn(&phba->pcidev->dev,\n\t\t\t \"Warning: Failed node ref, not sending LS_REQ\\n\");\n\t\tlpfc_sli_release_iocbq(phba, genwqe);\n\t\treturn 1;\n\t}\n\n\tgenwqe->context_un.nvme_lsreq = pnvme_lsreq;\n\t \n\n\tif (!tmo)\n\t\t \n\t\ttmo = (3 * phba->fc_ratov);\n\n\t \n\txmit_len = 0;\n\tfirst_len = 0;\n\tbpl = (struct ulp_bde64 *)bmp->virt;\n\tfor (i = 0; i < num_entry; i++) {\n\t\tbde.tus.w = bpl[i].tus.w;\n\t\tif (bde.tus.f.bdeFlags != BUFF_TYPE_BDE_64)\n\t\t\tbreak;\n\t\txmit_len += bde.tus.f.bdeSize;\n\t\tif (i == 0)\n\t\t\tfirst_len = xmit_len;\n\t}\n\n\tgenwqe->num_bdes = num_entry;\n\tgenwqe->hba_wqidx = 0;\n\n\t \n\twqe->generic.bde.tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\twqe->generic.bde.tus.f.bdeSize = first_len;\n\twqe->generic.bde.addrLow = bpl[0].addrLow;\n\twqe->generic.bde.addrHigh = bpl[0].addrHigh;\n\n\t \n\twqe->gen_req.request_payload_len = first_len;\n\n\t \n\n\t \n\tbf_set(wqe_dfctl, &wqe->gen_req.wge_ctl, 0);\n\tbf_set(wqe_si, &wqe->gen_req.wge_ctl, 1);\n\tbf_set(wqe_la, &wqe->gen_req.wge_ctl, 1);\n\tbf_set(wqe_rctl, &wqe->gen_req.wge_ctl, FC_RCTL_ELS4_REQ);\n\tbf_set(wqe_type, &wqe->gen_req.wge_ctl, FC_TYPE_NVME);\n\n\t \n\tbf_set(wqe_ctxt_tag, &wqe->gen_req.wqe_com,\n\t       phba->sli4_hba.rpi_ids[ndlp->nlp_rpi]);\n\tbf_set(wqe_xri_tag, &wqe->gen_req.wqe_com, genwqe->sli4_xritag);\n\n\t \n\tbf_set(wqe_tmo, &wqe->gen_req.wqe_com, tmo);\n\tbf_set(wqe_class, &wqe->gen_req.wqe_com, CLASS3);\n\tbf_set(wqe_cmnd, &wqe->gen_req.wqe_com, CMD_GEN_REQUEST64_WQE);\n\tbf_set(wqe_ct, &wqe->gen_req.wqe_com, SLI4_CT_RPI);\n\n\t \n\twqe->gen_req.wqe_com.abort_tag = genwqe->iotag;\n\n\t \n\tbf_set(wqe_reqtag, &wqe->gen_req.wqe_com, genwqe->iotag);\n\n\t \n\tbf_set(wqe_dbde, &wqe->gen_req.wqe_com, 1);\n\tbf_set(wqe_iod, &wqe->gen_req.wqe_com, LPFC_WQE_IOD_READ);\n\tbf_set(wqe_qosd, &wqe->gen_req.wqe_com, 1);\n\tbf_set(wqe_lenloc, &wqe->gen_req.wqe_com, LPFC_WQE_LENLOC_NONE);\n\tbf_set(wqe_ebde_cnt, &wqe->gen_req.wqe_com, 0);\n\n\t \n\tbf_set(wqe_cqid, &wqe->gen_req.wqe_com, LPFC_WQE_CQ_ID_DEFAULT);\n\tbf_set(wqe_cmd_type, &wqe->gen_req.wqe_com, OTHER_COMMAND);\n\n\n\t \n\tgenwqe->cmd_cmpl = cmpl;\n\tgenwqe->drvrTimeout = tmo + LPFC_DRVR_TIMEOUT;\n\tgenwqe->vport = vport;\n\tgenwqe->retry = retry;\n\n\tlpfc_nvmeio_data(phba, \"NVME LS  XMIT: xri x%x iotag x%x to x%06x\\n\",\n\t\t\t genwqe->sli4_xritag, genwqe->iotag, ndlp->nlp_DID);\n\n\trc = lpfc_sli4_issue_wqe(phba, &phba->sli4_hba.hdwq[0], genwqe);\n\tif (rc) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6045 Issue GEN REQ WQE to NPORT x%x \"\n\t\t\t\t \"Data: x%x x%x  rc x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, genwqe->iotag,\n\t\t\t\t vport->port_state, rc);\n\t\tlpfc_nlp_put(ndlp);\n\t\tlpfc_sli_release_iocbq(phba, genwqe);\n\t\treturn 1;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC | LOG_ELS,\n\t\t\t \"6050 Issue GEN REQ WQE to NPORT x%x \"\n\t\t\t \"Data: oxid: x%x state: x%x wq:x%px lsreq:x%px \"\n\t\t\t \"bmp:x%px xmit:%d 1st:%d\\n\",\n\t\t\t ndlp->nlp_DID, genwqe->sli4_xritag,\n\t\t\t vport->port_state,\n\t\t\t genwqe, pnvme_lsreq, bmp, xmit_len, first_len);\n\treturn 0;\n}\n\n\n \nint\n__lpfc_nvme_ls_req(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t      struct nvmefc_ls_req *pnvme_lsreq,\n\t\t      void (*gen_req_cmp)(struct lpfc_hba *phba,\n\t\t\t\tstruct lpfc_iocbq *cmdwqe,\n\t\t\t\tstruct lpfc_iocbq *rspwqe))\n{\n\tstruct lpfc_dmabuf *bmp;\n\tstruct ulp_bde64 *bpl;\n\tint ret;\n\tuint16_t ntype, nstate;\n\n\tif (!ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6051 NVMEx LS REQ: Bad NDLP x%px, Failing \"\n\t\t\t\t \"LS Req\\n\",\n\t\t\t\t ndlp);\n\t\treturn -ENODEV;\n\t}\n\n\tntype = ndlp->nlp_type;\n\tnstate = ndlp->nlp_state;\n\tif ((ntype & NLP_NVME_TARGET && nstate != NLP_STE_MAPPED_NODE) ||\n\t    (ntype & NLP_NVME_INITIATOR && nstate != NLP_STE_UNMAPPED_NODE)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6088 NVMEx LS REQ: Fail DID x%06x not \"\n\t\t\t\t \"ready for IO. Type x%x, State x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, ntype, nstate);\n\t\treturn -ENODEV;\n\t}\n\tif (vport->phba->hba_flag & HBA_IOQ_FLUSH)\n\t\treturn -ENODEV;\n\n\tif (!vport->phba->sli4_hba.nvmels_wq)\n\t\treturn -ENOMEM;\n\n\t \n\n\tbmp = kmalloc(sizeof(*bmp), GFP_KERNEL);\n\tif (!bmp) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6044 NVMEx LS REQ: Could not alloc LS buf \"\n\t\t\t\t \"for DID %x\\n\",\n\t\t\t\t ndlp->nlp_DID);\n\t\treturn -ENOMEM;\n\t}\n\n\tbmp->virt = lpfc_mbuf_alloc(vport->phba, MEM_PRI, &(bmp->phys));\n\tif (!bmp->virt) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6042 NVMEx LS REQ: Could not alloc mbuf \"\n\t\t\t\t \"for DID %x\\n\",\n\t\t\t\t ndlp->nlp_DID);\n\t\tkfree(bmp);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&bmp->list);\n\n\tbpl = (struct ulp_bde64 *)bmp->virt;\n\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(pnvme_lsreq->rqstdma));\n\tbpl->addrLow = le32_to_cpu(putPaddrLow(pnvme_lsreq->rqstdma));\n\tbpl->tus.f.bdeFlags = 0;\n\tbpl->tus.f.bdeSize = pnvme_lsreq->rqstlen;\n\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\tbpl++;\n\n\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(pnvme_lsreq->rspdma));\n\tbpl->addrLow = le32_to_cpu(putPaddrLow(pnvme_lsreq->rspdma));\n\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\n\tbpl->tus.f.bdeSize = pnvme_lsreq->rsplen;\n\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t\"6149 NVMEx LS REQ: Issue to DID 0x%06x lsreq x%px, \"\n\t\t\t\"rqstlen:%d rsplen:%d %pad %pad\\n\",\n\t\t\tndlp->nlp_DID, pnvme_lsreq, pnvme_lsreq->rqstlen,\n\t\t\tpnvme_lsreq->rsplen, &pnvme_lsreq->rqstdma,\n\t\t\t&pnvme_lsreq->rspdma);\n\n\tret = lpfc_nvme_gen_req(vport, bmp, pnvme_lsreq->rqstaddr,\n\t\t\t\tpnvme_lsreq, gen_req_cmp, ndlp, 2,\n\t\t\t\tpnvme_lsreq->timeout, 0);\n\tif (ret != WQE_SUCCESS) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6052 NVMEx REQ: EXIT. issue ls wqe failed \"\n\t\t\t\t \"lsreq x%px Status %x DID %x\\n\",\n\t\t\t\t pnvme_lsreq, ret, ndlp->nlp_DID);\n\t\tlpfc_mbuf_free(vport->phba, bmp->virt, bmp->phys);\n\t\tkfree(bmp);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_nvme_ls_req(struct nvme_fc_local_port *pnvme_lport,\n\t\t struct nvme_fc_remote_port *pnvme_rport,\n\t\t struct nvmefc_ls_req *pnvme_lsreq)\n{\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_nvme_rport *rport;\n\tstruct lpfc_vport *vport;\n\tint ret;\n\n\tlport = (struct lpfc_nvme_lport *)pnvme_lport->private;\n\trport = (struct lpfc_nvme_rport *)pnvme_rport->private;\n\tif (unlikely(!lport) || unlikely(!rport))\n\t\treturn -EINVAL;\n\n\tvport = lport->vport;\n\tif (vport->load_flag & FC_UNLOADING ||\n\t    vport->phba->hba_flag & HBA_IOQ_FLUSH)\n\t\treturn -ENODEV;\n\n\tatomic_inc(&lport->fc4NvmeLsRequests);\n\n\tret = __lpfc_nvme_ls_req(vport, rport->ndlp, pnvme_lsreq,\n\t\t\t\t lpfc_nvme_ls_req_cmp);\n\tif (ret)\n\t\tatomic_inc(&lport->xmt_ls_err);\n\n\treturn ret;\n}\n\n \nint\n__lpfc_nvme_ls_abort(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp,\n\t\t\tstruct nvmefc_ls_req *pnvme_lsreq)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *wqe, *next_wqe;\n\tbool foundit = false;\n\n\tif (!ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"6049 NVMEx LS REQ Abort: Bad NDLP x%px DID \"\n\t\t\t\t\"x%06x, Failing LS Req\\n\",\n\t\t\t\tndlp, ndlp ? ndlp->nlp_DID : 0);\n\t\treturn -EINVAL;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC | LOG_NVME_ABTS,\n\t\t\t \"6040 NVMEx LS REQ Abort: Issue LS_ABORT for lsreq \"\n\t\t\t \"x%px rqstlen:%d rsplen:%d %pad %pad\\n\",\n\t\t\t pnvme_lsreq, pnvme_lsreq->rqstlen,\n\t\t\t pnvme_lsreq->rsplen, &pnvme_lsreq->rqstdma,\n\t\t\t &pnvme_lsreq->rspdma);\n\n\t \n\tpring = phba->sli4_hba.nvmels_wq->pring;\n\tspin_lock_irq(&phba->hbalock);\n\tspin_lock(&pring->ring_lock);\n\tlist_for_each_entry_safe(wqe, next_wqe, &pring->txcmplq, list) {\n\t\tif (wqe->context_un.nvme_lsreq == pnvme_lsreq) {\n\t\t\twqe->cmd_flag |= LPFC_DRIVER_ABORTED;\n\t\t\tfoundit = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&pring->ring_lock);\n\n\tif (foundit)\n\t\tlpfc_sli_issue_abort_iotag(phba, pring, wqe, NULL);\n\tspin_unlock_irq(&phba->hbalock);\n\n\tif (foundit)\n\t\treturn 0;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC | LOG_NVME_ABTS,\n\t\t\t \"6213 NVMEx LS REQ Abort: Unable to locate req x%px\\n\",\n\t\t\t pnvme_lsreq);\n\treturn -EINVAL;\n}\n\nstatic int\nlpfc_nvme_xmt_ls_rsp(struct nvme_fc_local_port *localport,\n\t\t     struct nvme_fc_remote_port *remoteport,\n\t\t     struct nvmefc_ls_rsp *ls_rsp)\n{\n\tstruct lpfc_async_xchg_ctx *axchg =\n\t\tcontainer_of(ls_rsp, struct lpfc_async_xchg_ctx, ls_rsp);\n\tstruct lpfc_nvme_lport *lport;\n\tint rc;\n\n\tif (axchg->phba->pport->load_flag & FC_UNLOADING)\n\t\treturn -ENODEV;\n\n\tlport = (struct lpfc_nvme_lport *)localport->private;\n\n\trc = __lpfc_nvme_xmt_ls_rsp(axchg, ls_rsp, __lpfc_nvme_xmt_ls_rsp_cmp);\n\n\tif (rc) {\n\t\t \n\t\tif (rc != -EALREADY)\n\t\t\tatomic_inc(&lport->xmt_ls_abort);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nlpfc_nvme_ls_abort(struct nvme_fc_local_port *pnvme_lport,\n\t\t   struct nvme_fc_remote_port *pnvme_rport,\n\t\t   struct nvmefc_ls_req *pnvme_lsreq)\n{\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_nodelist *ndlp;\n\tint ret;\n\n\tlport = (struct lpfc_nvme_lport *)pnvme_lport->private;\n\tif (unlikely(!lport))\n\t\treturn;\n\tvport = lport->vport;\n\n\tif (vport->load_flag & FC_UNLOADING)\n\t\treturn;\n\n\tndlp = lpfc_findnode_did(vport, pnvme_rport->port_id);\n\n\tret = __lpfc_nvme_ls_abort(vport, ndlp, pnvme_lsreq);\n\tif (!ret)\n\t\tatomic_inc(&lport->xmt_ls_abort);\n}\n\n \nstatic inline void\nlpfc_nvme_adj_fcp_sgls(struct lpfc_vport *vport,\n\t\t       struct lpfc_io_buf *lpfc_ncmd,\n\t\t       struct nvmefc_fcp_req *nCmd)\n{\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct sli4_sge *sgl;\n\tunion lpfc_wqe128 *wqe;\n\tuint32_t *wptr, *dptr;\n\n\t \n\n\twqe = &lpfc_ncmd->cur_iocbq.wqe;\n\n\t \n\tsgl = lpfc_ncmd->dma_sgl;\n\tsgl->sge_len = cpu_to_le32(nCmd->cmdlen);\n\tif (phba->cfg_nvme_embed_cmd) {\n\t\tsgl->addr_hi = 0;\n\t\tsgl->addr_lo = 0;\n\n\t\t \n\t\twqe->generic.bde.tus.f.bdeFlags = BUFF_TYPE_BDE_IMMED;\n\t\twqe->generic.bde.tus.f.bdeSize = 56;\n\t\twqe->generic.bde.addrHigh = 0;\n\t\twqe->generic.bde.addrLow =  64;   \n\n\t\t \n\n\t\t \n\t\twptr = &wqe->words[16];   \n\t\tdptr = (uint32_t *)nCmd->cmdaddr;   \n\t\tdptr++;\t\t\t \n\n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\tdptr++;\t\t\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\tdptr += 8;\t\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr++ = *dptr++;\t \n\t\t*wptr   = *dptr;\t \n\t} else {\n\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(nCmd->cmddma));\n\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(nCmd->cmddma));\n\n\t\t \n\t\twqe->generic.bde.tus.f.bdeFlags =  BUFF_TYPE_BDE_64;\n\t\twqe->generic.bde.tus.f.bdeSize = nCmd->cmdlen;\n\t\twqe->generic.bde.addrHigh = sgl->addr_hi;\n\t\twqe->generic.bde.addrLow =  sgl->addr_lo;\n\n\t\t \n\t\tbf_set(wqe_dbde, &wqe->generic.wqe_com, 1);\n\t\tbf_set(wqe_wqes, &wqe->generic.wqe_com, 0);\n\t}\n\n\tsgl++;\n\n\t \n\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(nCmd->rspdma));\n\tsgl->addr_lo = cpu_to_le32(putPaddrLow(nCmd->rspdma));\n\tsgl->word2 = le32_to_cpu(sgl->word2);\n\tif (nCmd->sg_cnt)\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\telse\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\tsgl->word2 = cpu_to_le32(sgl->word2);\n\tsgl->sge_len = cpu_to_le32(nCmd->rsplen);\n}\n\n\n \nstatic void\nlpfc_nvme_io_cmd_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *pwqeIn,\n\t\t      struct lpfc_iocbq *pwqeOut)\n{\n\tstruct lpfc_io_buf *lpfc_ncmd = pwqeIn->io_buf;\n\tstruct lpfc_wcqe_complete *wcqe = &pwqeOut->wcqe_cmpl;\n\tstruct lpfc_vport *vport = pwqeIn->vport;\n\tstruct nvmefc_fcp_req *nCmd;\n\tstruct nvme_fc_ersp_iu *ep;\n\tstruct nvme_fc_cmd_iu *cp;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_nvme_fcpreq_priv *freqpriv;\n\tstruct lpfc_nvme_lport *lport;\n\tuint32_t code, status, idx;\n\tuint16_t cid, sqhd, data;\n\tuint32_t *ptr;\n\tuint32_t lat;\n\tbool call_done = false;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tint cpu;\n#endif\n\tint offline = 0;\n\n\t \n\tif (!lpfc_ncmd) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6071 Null lpfc_ncmd pointer. No \"\n\t\t\t\t \"release, skip completion\\n\");\n\t\treturn;\n\t}\n\n\t \n\tspin_lock(&lpfc_ncmd->buf_lock);\n\n\tif (!lpfc_ncmd->nvmeCmd) {\n\t\tspin_unlock(&lpfc_ncmd->buf_lock);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6066 Missing cmpl ptrs: lpfc_ncmd x%px, \"\n\t\t\t\t \"nvmeCmd x%px\\n\",\n\t\t\t\t lpfc_ncmd, lpfc_ncmd->nvmeCmd);\n\n\t\t \n\t\tlpfc_release_nvme_buf(phba, lpfc_ncmd);\n\t\treturn;\n\t}\n\tnCmd = lpfc_ncmd->nvmeCmd;\n\tstatus = bf_get(lpfc_wcqe_c_status, wcqe);\n\n\tidx = lpfc_ncmd->cur_iocbq.hba_wqidx;\n\tphba->sli4_hba.hdwq[idx].nvme_cstat.io_cmpls++;\n\n\tif (unlikely(status && vport->localport)) {\n\t\tlport = (struct lpfc_nvme_lport *)vport->localport->private;\n\t\tif (lport) {\n\t\t\tif (bf_get(lpfc_wcqe_c_xb, wcqe))\n\t\t\t\tatomic_inc(&lport->cmpl_fcp_xb);\n\t\t\tatomic_inc(&lport->cmpl_fcp_err);\n\t\t}\n\t}\n\n\tlpfc_nvmeio_data(phba, \"NVME FCP CMPL: xri x%x stat x%x parm x%x\\n\",\n\t\t\t lpfc_ncmd->cur_iocbq.sli4_xritag,\n\t\t\t status, wcqe->parameter);\n\t \n\tndlp = lpfc_ncmd->ndlp;\n\tif (!ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6062 Ignoring NVME cmpl.  No ndlp\\n\");\n\t\tgoto out_err;\n\t}\n\n\tcode = bf_get(lpfc_wcqe_c_code, wcqe);\n\tif (code == CQE_CODE_NVME_ERSP) {\n\t\t \n\t\tep = (struct nvme_fc_ersp_iu *)nCmd->rspaddr;\n\n\t\t \n\t\tcp = (struct nvme_fc_cmd_iu *)nCmd->cmdaddr;\n\t\tcid = cp->sqe.common.command_id;\n\n\t\t \n\t\tsqhd = bf_get(lpfc_wcqe_c_sqhead, wcqe);\n\n\t\t \n\t\tep->iu_len = cpu_to_be16(8);\n\t\tep->rsn = wcqe->parameter;\n\t\tep->xfrd_len = cpu_to_be32(nCmd->payload_length);\n\t\tep->rsvd12 = 0;\n\t\tptr = (uint32_t *)&ep->cqe.result.u64;\n\t\t*ptr++ = wcqe->total_data_placed;\n\t\tdata = bf_get(lpfc_wcqe_c_ersp0, wcqe);\n\t\t*ptr = (uint32_t)data;\n\t\tep->cqe.sq_head = sqhd;\n\t\tep->cqe.sq_id =  nCmd->sqid;\n\t\tep->cqe.command_id = cid;\n\t\tep->cqe.status = 0;\n\n\t\tlpfc_ncmd->status = IOSTAT_SUCCESS;\n\t\tlpfc_ncmd->result = 0;\n\t\tnCmd->rcv_rsplen = LPFC_NVME_ERSP_LEN;\n\t\tnCmd->transferred_length = nCmd->payload_length;\n\t} else {\n\t\tlpfc_ncmd->status = status;\n\t\tlpfc_ncmd->result = (wcqe->parameter & IOERR_PARAM_MASK);\n\n\t\t \n\t\tswitch (lpfc_ncmd->status) {\n\t\tcase IOSTAT_SUCCESS:\n\t\t\tnCmd->transferred_length = wcqe->total_data_placed;\n\t\t\tnCmd->rcv_rsplen = 0;\n\t\t\tnCmd->status = 0;\n\t\t\tbreak;\n\t\tcase IOSTAT_FCP_RSP_ERROR:\n\t\t\tnCmd->transferred_length = wcqe->total_data_placed;\n\t\t\tnCmd->rcv_rsplen = wcqe->parameter;\n\t\t\tnCmd->status = 0;\n\n\t\t\t \n\t\t\tcp = (struct nvme_fc_cmd_iu *)nCmd->cmdaddr;\n\t\t\tep = (struct nvme_fc_ersp_iu *)nCmd->rspaddr;\n\n\t\t\t \n\t\t\tif (nCmd->rcv_rsplen == LPFC_NVME_ERSP_LEN) {\n\t\t\t\tlpfc_ncmd->status = IOSTAT_SUCCESS;\n\t\t\t\tlpfc_ncmd->result = 0;\n\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME,\n\t\t\t\t\t\"6084 NVME FCP_ERR ERSP: \"\n\t\t\t\t\t\"xri %x placed x%x opcode x%x cmd_id \"\n\t\t\t\t\t\"x%x cqe_status x%x\\n\",\n\t\t\t\t\tlpfc_ncmd->cur_iocbq.sli4_xritag,\n\t\t\t\t\twcqe->total_data_placed,\n\t\t\t\t\tcp->sqe.common.opcode,\n\t\t\t\t\tcp->sqe.common.command_id,\n\t\t\t\t\tep->cqe.status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"6081 NVME Completion Protocol Error: \"\n\t\t\t\t\t \"xri %x status x%x result x%x \"\n\t\t\t\t\t \"placed x%x opcode x%x cmd_id x%x, \"\n\t\t\t\t\t \"cqe_status x%x\\n\",\n\t\t\t\t\t lpfc_ncmd->cur_iocbq.sli4_xritag,\n\t\t\t\t\t lpfc_ncmd->status, lpfc_ncmd->result,\n\t\t\t\t\t wcqe->total_data_placed,\n\t\t\t\t\t cp->sqe.common.opcode,\n\t\t\t\t\t cp->sqe.common.command_id,\n\t\t\t\t\t ep->cqe.status);\n\t\t\tbreak;\n\t\tcase IOSTAT_LOCAL_REJECT:\n\t\t\t \n\t\t\tif (lpfc_ncmd->result == IOERR_ABORT_REQUESTED)\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t\t LOG_NVME_IOERR,\n\t\t\t\t\t \"6032 Delay Aborted cmd x%px \"\n\t\t\t\t\t \"nvme cmd x%px, xri x%x, \"\n\t\t\t\t\t \"xb %d\\n\",\n\t\t\t\t\t lpfc_ncmd, nCmd,\n\t\t\t\t\t lpfc_ncmd->cur_iocbq.sli4_xritag,\n\t\t\t\t\t bf_get(lpfc_wcqe_c_xb, wcqe));\n\t\t\tfallthrough;\n\t\tdefault:\nout_err:\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t\t \"6072 NVME Completion Error: xri %x \"\n\t\t\t\t\t \"status x%x result x%x [x%x] \"\n\t\t\t\t\t \"placed x%x\\n\",\n\t\t\t\t\t lpfc_ncmd->cur_iocbq.sli4_xritag,\n\t\t\t\t\t lpfc_ncmd->status, lpfc_ncmd->result,\n\t\t\t\t\t wcqe->parameter,\n\t\t\t\t\t wcqe->total_data_placed);\n\t\t\tnCmd->transferred_length = 0;\n\t\t\tnCmd->rcv_rsplen = 0;\n\t\t\tnCmd->status = NVME_SC_INTERNAL;\n\t\t\toffline = pci_channel_offline(vport->phba->pcidev);\n\t\t}\n\t}\n\n\t \n\tif (bf_get(lpfc_wcqe_c_xb, wcqe) && !offline)\n\t\tlpfc_ncmd->flags |= LPFC_SBUF_XBUSY;\n\telse\n\t\tlpfc_ncmd->flags &= ~LPFC_SBUF_XBUSY;\n\n\t \n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_ncmd->ts_cmd_start) {\n\t\tlpfc_ncmd->ts_isr_cmpl = pwqeIn->isr_timestamp;\n\t\tlpfc_ncmd->ts_data_io = ktime_get_ns();\n\t\tphba->ktime_last_cmd = lpfc_ncmd->ts_data_io;\n\t\tlpfc_io_ktime(phba, lpfc_ncmd);\n\t}\n\tif (unlikely(phba->hdwqstat_on & LPFC_CHECK_NVME_IO)) {\n\t\tcpu = raw_smp_processor_id();\n\t\tthis_cpu_inc(phba->sli4_hba.c_stat->cmpl_io);\n\t\tif (lpfc_ncmd->cpu != cpu)\n\t\t\tlpfc_printf_vlog(vport,\n\t\t\t\t\t KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t\t \"6701 CPU Check cmpl: \"\n\t\t\t\t\t \"cpu %d expect %d\\n\",\n\t\t\t\t\t cpu, lpfc_ncmd->cpu);\n\t}\n#endif\n\n\t \n\n\tif (!(lpfc_ncmd->flags & LPFC_SBUF_XBUSY)) {\n\t\tfreqpriv = nCmd->private;\n\t\tfreqpriv->nvme_buf = NULL;\n\t\tlpfc_ncmd->nvmeCmd = NULL;\n\t\tcall_done = true;\n\t}\n\tspin_unlock(&lpfc_ncmd->buf_lock);\n\n\t \n\tif (phba->cmf_active_mode != LPFC_CFG_OFF &&\n\t    nCmd->io_dir == NVMEFC_FCP_READ &&\n\t    nCmd->payload_length) {\n\t\t \n\t\tlat = ktime_get_ns() - lpfc_ncmd->rx_cmd_start;\n\t\tlpfc_update_cmf_cmpl(phba, lat, nCmd->payload_length, NULL);\n\t}\n\n\tif (call_done)\n\t\tnCmd->done(nCmd);\n\n\t \n\tlpfc_release_nvme_buf(phba, lpfc_ncmd);\n}\n\n\n \nstatic int\nlpfc_nvme_prep_io_cmd(struct lpfc_vport *vport,\n\t\t      struct lpfc_io_buf *lpfc_ncmd,\n\t\t      struct lpfc_nodelist *pnode,\n\t\t      struct lpfc_fc4_ctrl_stat *cstat)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct nvmefc_fcp_req *nCmd = lpfc_ncmd->nvmeCmd;\n\tstruct nvme_common_command *sqe;\n\tstruct lpfc_iocbq *pwqeq = &lpfc_ncmd->cur_iocbq;\n\tunion lpfc_wqe128 *wqe = &pwqeq->wqe;\n\tuint32_t req_len;\n\n\t \n\tif (nCmd->sg_cnt) {\n\t\tif (nCmd->io_dir == NVMEFC_FCP_WRITE) {\n\t\t\t \n\t\t\tmemcpy(&wqe->words[7],\n\t\t\t       &lpfc_iwrite_cmd_template.words[7],\n\t\t\t       sizeof(uint32_t) * 5);\n\n\t\t\t \n\t\t\twqe->fcp_iwrite.total_xfer_len = nCmd->payload_length;\n\n\t\t\t \n\t\t\tif ((phba->cfg_nvme_enable_fb) &&\n\t\t\t    (pnode->nlp_flag & NLP_FIRSTBURST)) {\n\t\t\t\treq_len = lpfc_ncmd->nvmeCmd->payload_length;\n\t\t\t\tif (req_len < pnode->nvme_fb_size)\n\t\t\t\t\twqe->fcp_iwrite.initial_xfer_len =\n\t\t\t\t\t\treq_len;\n\t\t\t\telse\n\t\t\t\t\twqe->fcp_iwrite.initial_xfer_len =\n\t\t\t\t\t\tpnode->nvme_fb_size;\n\t\t\t} else {\n\t\t\t\twqe->fcp_iwrite.initial_xfer_len = 0;\n\t\t\t}\n\t\t\tcstat->output_requests++;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(&wqe->words[7],\n\t\t\t       &lpfc_iread_cmd_template.words[7],\n\t\t\t       sizeof(uint32_t) * 5);\n\n\t\t\t \n\t\t\twqe->fcp_iread.total_xfer_len = nCmd->payload_length;\n\n\t\t\t \n\t\t\twqe->fcp_iread.rsrvd5 = 0;\n\n\t\t\t \n\t\t\tif (phba->cmf_active_mode == LPFC_CFG_MANAGED)\n\t\t\t\tbf_set(wqe_iod, &wqe->fcp_iread.wqe_com,\n\t\t\t\t       LPFC_WQE_IOD_NONE);\n\t\t\tcstat->input_requests++;\n\t\t}\n\t} else {\n\t\t \n\t\tmemcpy(&wqe->words[4], &lpfc_icmnd_cmd_template.words[4],\n\t\t       sizeof(uint32_t) * 8);\n\t\tcstat->control_requests++;\n\t}\n\n\tif (pnode->nlp_nvme_info & NLP_NVME_NSLER) {\n\t\tbf_set(wqe_erp, &wqe->generic.wqe_com, 1);\n\t\tsqe = &((struct nvme_fc_cmd_iu *)\n\t\t\tnCmd->cmdaddr)->sqe.common;\n\t\tif (sqe->opcode == nvme_admin_async_event)\n\t\t\tbf_set(wqe_ffrq, &wqe->generic.wqe_com, 1);\n\t}\n\n\t \n\n\t \n\tbf_set(payload_offset_len, &wqe->fcp_icmd,\n\t       (nCmd->rsplen + nCmd->cmdlen));\n\n\t \n\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t       phba->sli4_hba.rpi_ids[pnode->nlp_rpi]);\n\tbf_set(wqe_xri_tag, &wqe->generic.wqe_com, pwqeq->sli4_xritag);\n\n\t \n\twqe->generic.wqe_com.abort_tag = pwqeq->iotag;\n\n\t \n\tbf_set(wqe_reqtag, &wqe->generic.wqe_com, pwqeq->iotag);\n\n\t \n\tbf_set(wqe_xchg, &wqe->fcp_iwrite.wqe_com, LPFC_NVME_XCHG);\n\n\t \n\n\t \n\tif (unlikely(lpfc_ncmd->cur_iocbq.cmd_flag & LPFC_IO_VMID)) {\n\t\tif (phba->pport->vmid_priority_tagging) {\n\t\t\tbf_set(wqe_ccpe, &wqe->fcp_iwrite.wqe_com, 1);\n\t\t\tbf_set(wqe_ccp, &wqe->fcp_iwrite.wqe_com,\n\t\t\t       lpfc_ncmd->cur_iocbq.vmid_tag.cs_ctl_vmid);\n\t\t} else {\n\t\t\tbf_set(wqe_appid, &wqe->fcp_iwrite.wqe_com, 1);\n\t\t\tbf_set(wqe_wqes, &wqe->fcp_iwrite.wqe_com, 1);\n\t\t\twqe->words[31] = lpfc_ncmd->cur_iocbq.vmid_tag.app_id;\n\t\t}\n\t}\n\n\tpwqeq->vport = vport;\n\treturn 0;\n}\n\n\n \nstatic int\nlpfc_nvme_prep_io_dma(struct lpfc_vport *vport,\n\t\t      struct lpfc_io_buf *lpfc_ncmd)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct nvmefc_fcp_req *nCmd = lpfc_ncmd->nvmeCmd;\n\tunion lpfc_wqe128 *wqe = &lpfc_ncmd->cur_iocbq.wqe;\n\tstruct sli4_sge *sgl = lpfc_ncmd->dma_sgl;\n\tstruct sli4_hybrid_sgl *sgl_xtra = NULL;\n\tstruct scatterlist *data_sg;\n\tstruct sli4_sge *first_data_sgl;\n\tstruct ulp_bde64 *bde;\n\tdma_addr_t physaddr = 0;\n\tuint32_t dma_len = 0;\n\tuint32_t dma_offset = 0;\n\tint nseg, i, j;\n\tbool lsp_just_set = false;\n\n\t \n\tlpfc_nvme_adj_fcp_sgls(vport, lpfc_ncmd, nCmd);\n\n\t \n\tif (nCmd->sg_cnt) {\n\t\t \n\t\tsgl += 2;\n\n\t\tfirst_data_sgl = sgl;\n\t\tlpfc_ncmd->seg_cnt = nCmd->sg_cnt;\n\t\tif (lpfc_ncmd->seg_cnt > lpfc_nvme_template.max_sgl_segments) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"6058 Too many sg segments from \"\n\t\t\t\t\t\"NVME Transport.  Max %d, \"\n\t\t\t\t\t\"nvmeIO sg_cnt %d\\n\",\n\t\t\t\t\tphba->cfg_nvme_seg_cnt + 1,\n\t\t\t\t\tlpfc_ncmd->seg_cnt);\n\t\t\tlpfc_ncmd->seg_cnt = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tnseg = nCmd->sg_cnt;\n\t\tdata_sg = nCmd->first_sgl;\n\n\t\t \n\t\tj = 2;\n\t\tfor (i = 0; i < nseg; i++) {\n\t\t\tif (data_sg == NULL) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\t\"6059 dptr err %d, nseg %d\\n\",\n\t\t\t\t\t\ti, nseg);\n\t\t\t\tlpfc_ncmd->seg_cnt = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tsgl->word2 = 0;\n\t\t\tif (nseg == 1) {\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t       LPFC_SGE_TYPE_DATA);\n\t\t\t} else {\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\n\t\t\t\t \n\t\t\t\tif (!lsp_just_set &&\n\t\t\t\t    !((j + 1) % phba->border_sge_num) &&\n\t\t\t\t    ((nseg - 1) != i)) {\n\t\t\t\t\t \n\t\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t\t       LPFC_SGE_TYPE_LSP);\n\n\t\t\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(\n\t\t\t\t\t\t\tphba, lpfc_ncmd);\n\n\t\t\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\t\t\tlpfc_ncmd->seg_cnt = 0;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\t       sgl_xtra->dma_phys_sgl));\n\t\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t       sgl_xtra->dma_phys_sgl));\n\n\t\t\t\t} else {\n\t\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t\t       LPFC_SGE_TYPE_DATA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(bf_get(lpfc_sli4_sge_type, sgl) &\n\t\t\t\t     LPFC_SGE_TYPE_LSP)) {\n\t\t\t\tif ((nseg - 1) == i)\n\t\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\n\t\t\t\tphysaddr = sg_dma_address(data_sg);\n\t\t\t\tdma_len = sg_dma_len(data_sg);\n\t\t\t\tsgl->addr_lo = cpu_to_le32(\n\t\t\t\t\t\t\t putPaddrLow(physaddr));\n\t\t\t\tsgl->addr_hi = cpu_to_le32(\n\t\t\t\t\t\t\tputPaddrHigh(physaddr));\n\n\t\t\t\tbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\n\t\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\t\tsgl->sge_len = cpu_to_le32(dma_len);\n\n\t\t\t\tdma_offset += dma_len;\n\t\t\t\tdata_sg = sg_next(data_sg);\n\n\t\t\t\tsgl++;\n\n\t\t\t\tlsp_just_set = false;\n\t\t\t} else {\n\t\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\n\t\t\t\tsgl->sge_len = cpu_to_le32(\n\t\t\t\t\t\t     phba->cfg_sg_dma_buf_size);\n\n\t\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\t\ti = i - 1;\n\n\t\t\t\tlsp_just_set = true;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\n\t\t \n\t\tif (nseg == 1 && phba->cfg_enable_pbde) {\n\t\t\t \n\t\t\tbde = (struct ulp_bde64 *)\n\t\t\t\t&wqe->words[13];\n\t\t\tbde->addrLow = first_data_sgl->addr_lo;\n\t\t\tbde->addrHigh = first_data_sgl->addr_hi;\n\t\t\tbde->tus.f.bdeSize =\n\t\t\t\tle32_to_cpu(first_data_sgl->sge_len);\n\t\t\tbde->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\tbde->tus.w = cpu_to_le32(bde->tus.w);\n\n\t\t\t \n\t\t\tbf_set(wqe_pbde, &wqe->generic.wqe_com, 1);\n\t\t} else {\n\t\t\tmemset(&wqe->words[13], 0, (sizeof(uint32_t) * 3));\n\t\t\t \n\t\t}\n\n\t} else {\n\t\tlpfc_ncmd->seg_cnt = 0;\n\n\t\t \n\t\tif (nCmd->payload_length != 0) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"6063 NVME DMA Prep Err: sg_cnt %d \"\n\t\t\t\t\t\"payload_length x%x\\n\",\n\t\t\t\t\tnCmd->sg_cnt, nCmd->payload_length);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nlpfc_nvme_fcp_io_submit(struct nvme_fc_local_port *pnvme_lport,\n\t\t\tstruct nvme_fc_remote_port *pnvme_rport,\n\t\t\tvoid *hw_queue_handle,\n\t\t\tstruct nvmefc_fcp_req *pnvme_fcreq)\n{\n\tint ret = 0;\n\tint expedite = 0;\n\tint idx, cpu;\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_fc4_ctrl_stat *cstat;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_hba *phba;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_io_buf *lpfc_ncmd;\n\tstruct lpfc_nvme_rport *rport;\n\tstruct lpfc_nvme_qhandle *lpfc_queue_info;\n\tstruct lpfc_nvme_fcpreq_priv *freqpriv;\n\tstruct nvme_common_command *sqe;\n\tuint64_t start = 0;\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tu8 *uuid = NULL;\n\tint err;\n\tenum dma_data_direction iodir;\n#endif\n\n\t \n\tlport = (struct lpfc_nvme_lport *)pnvme_lport->private;\n\tif (unlikely(!lport)) {\n\t\tret = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\n\tvport = lport->vport;\n\n\tif (unlikely(!hw_queue_handle)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t \"6117 Fail IO, NULL hw_queue_handle\\n\");\n\t\tatomic_inc(&lport->xmt_fcp_err);\n\t\tret = -EBUSY;\n\t\tgoto out_fail;\n\t}\n\n\tphba = vport->phba;\n\n\tif ((unlikely(vport->load_flag & FC_UNLOADING)) ||\n\t    phba->hba_flag & HBA_IOQ_FLUSH) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t \"6124 Fail IO, Driver unload\\n\");\n\t\tatomic_inc(&lport->xmt_fcp_err);\n\t\tret = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n\tfreqpriv = pnvme_fcreq->private;\n\tif (unlikely(!freqpriv)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t \"6158 Fail IO, NULL request data\\n\");\n\t\tatomic_inc(&lport->xmt_fcp_err);\n\t\tret = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (phba->ktime_on)\n\t\tstart = ktime_get_ns();\n#endif\n\trport = (struct lpfc_nvme_rport *)pnvme_rport->private;\n\tlpfc_queue_info = (struct lpfc_nvme_qhandle *)hw_queue_handle;\n\n\t \n\tndlp = rport->ndlp;\n\tif (!ndlp) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE | LOG_NVME_IOERR,\n\t\t\t\t \"6053 Busy IO, ndlp not ready: rport x%px \"\n\t\t\t\t  \"ndlp x%px, DID x%06x\\n\",\n\t\t\t\t rport, ndlp, pnvme_rport->port_id);\n\t\tatomic_inc(&lport->xmt_fcp_err);\n\t\tret = -EBUSY;\n\t\tgoto out_fail;\n\t}\n\n\t \n\tif ((ndlp->nlp_type & NLP_NVME_TARGET) &&\n\t    (ndlp->nlp_state != NLP_STE_MAPPED_NODE)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NODE | LOG_NVME_IOERR,\n\t\t\t\t \"6036 Fail IO, DID x%06x not ready for \"\n\t\t\t\t \"IO. State x%x, Type x%x Flg x%x\\n\",\n\t\t\t\t pnvme_rport->port_id,\n\t\t\t\t ndlp->nlp_state, ndlp->nlp_type,\n\t\t\t\t ndlp->fc4_xpt_flags);\n\t\tatomic_inc(&lport->xmt_fcp_bad_ndlp);\n\t\tret = -EBUSY;\n\t\tgoto out_fail;\n\n\t}\n\n\t \n\tif (!lpfc_queue_info->qidx && !pnvme_fcreq->sg_cnt) {\n\t\tsqe = &((struct nvme_fc_cmd_iu *)\n\t\t\tpnvme_fcreq->cmdaddr)->sqe.common;\n\t\tif (sqe->opcode == nvme_admin_keep_alive)\n\t\t\texpedite = 1;\n\t}\n\n\t \n\tif (phba->cmf_active_mode != LPFC_CFG_OFF &&\n\t    pnvme_fcreq->io_dir == NVMEFC_FCP_READ &&\n\t    pnvme_fcreq->payload_length) {\n\t\tret = lpfc_update_cmf_cmd(phba, pnvme_fcreq->payload_length);\n\t\tif (ret) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_fail;\n\t\t}\n\t\t \n\t\tstart = ktime_get_ns();\n\t}\n\n\t \n\tif (lpfc_ndlp_check_qdepth(phba, ndlp)) {\n\t\tif ((atomic_read(&ndlp->cmd_pending) >= ndlp->cmd_qdepth) &&\n\t\t    !expedite) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t\t \"6174 Fail IO, ndlp qdepth exceeded: \"\n\t\t\t\t\t \"idx %d DID %x pend %d qdepth %d\\n\",\n\t\t\t\t\t lpfc_queue_info->index, ndlp->nlp_DID,\n\t\t\t\t\t atomic_read(&ndlp->cmd_pending),\n\t\t\t\t\t ndlp->cmd_qdepth);\n\t\t\tatomic_inc(&lport->xmt_fcp_qdepth);\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_fail1;\n\t\t}\n\t}\n\n\t \n\tif (phba->cfg_fcp_io_sched == LPFC_FCP_SCHED_BY_HDWQ) {\n\t\tidx = lpfc_queue_info->index;\n\t} else {\n\t\tcpu = raw_smp_processor_id();\n\t\tidx = phba->sli4_hba.cpu_map[cpu].hdwq;\n\t}\n\n\tlpfc_ncmd = lpfc_get_nvme_buf(phba, ndlp, idx, expedite);\n\tif (lpfc_ncmd == NULL) {\n\t\tatomic_inc(&lport->xmt_fcp_noxri);\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t \"6065 Fail IO, driver buffer pool is empty: \"\n\t\t\t\t \"idx %d DID %x\\n\",\n\t\t\t\t lpfc_queue_info->index, ndlp->nlp_DID);\n\t\tret = -EBUSY;\n\t\tgoto out_fail1;\n\t}\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (start) {\n\t\tlpfc_ncmd->ts_cmd_start = start;\n\t\tlpfc_ncmd->ts_last_cmd = phba->ktime_last_cmd;\n\t} else {\n\t\tlpfc_ncmd->ts_cmd_start = 0;\n\t}\n#endif\n\tlpfc_ncmd->rx_cmd_start = start;\n\n\t \n\tfreqpriv->nvme_buf = lpfc_ncmd;\n\tlpfc_ncmd->nvmeCmd = pnvme_fcreq;\n\tlpfc_ncmd->ndlp = ndlp;\n\tlpfc_ncmd->qidx = lpfc_queue_info->qidx;\n\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\t \n\tif (lpfc_is_vmid_enabled(phba) &&\n\t    (ndlp->vmid_support ||\n\t     phba->pport->vmid_priority_tagging ==\n\t     LPFC_VMID_PRIO_TAG_ALL_TARGETS)) {\n\t\t \n\t\t \n\t\tuuid = nvme_fc_io_getuuid(pnvme_fcreq);\n\n\t\tif (uuid) {\n\t\t\tif (pnvme_fcreq->io_dir == NVMEFC_FCP_WRITE)\n\t\t\t\tiodir = DMA_TO_DEVICE;\n\t\t\telse if (pnvme_fcreq->io_dir == NVMEFC_FCP_READ)\n\t\t\t\tiodir = DMA_FROM_DEVICE;\n\t\t\telse\n\t\t\t\tiodir = DMA_NONE;\n\n\t\t\terr = lpfc_vmid_get_appid(vport, uuid, iodir,\n\t\t\t\t\t(union lpfc_vmid_io_tag *)\n\t\t\t\t\t\t&lpfc_ncmd->cur_iocbq.vmid_tag);\n\t\t\tif (!err)\n\t\t\t\tlpfc_ncmd->cur_iocbq.cmd_flag |= LPFC_IO_VMID;\n\t\t}\n\t}\n#endif\n\n\t \n\tlpfc_ncmd->cur_iocbq.hba_wqidx = idx;\n\tcstat = &phba->sli4_hba.hdwq[idx].nvme_cstat;\n\n\tlpfc_nvme_prep_io_cmd(vport, lpfc_ncmd, ndlp, cstat);\n\tret = lpfc_nvme_prep_io_dma(vport, lpfc_ncmd);\n\tif (ret) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t \"6175 Fail IO, Prep DMA: \"\n\t\t\t\t \"idx %d DID %x\\n\",\n\t\t\t\t lpfc_queue_info->index, ndlp->nlp_DID);\n\t\tatomic_inc(&lport->xmt_fcp_err);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_nvme_buf;\n\t}\n\n\tlpfc_nvmeio_data(phba, \"NVME FCP XMIT: xri x%x idx %d to %06x\\n\",\n\t\t\t lpfc_ncmd->cur_iocbq.sli4_xritag,\n\t\t\t lpfc_queue_info->index, ndlp->nlp_DID);\n\n\tret = lpfc_sli4_issue_wqe(phba, lpfc_ncmd->hdwq, &lpfc_ncmd->cur_iocbq);\n\tif (ret) {\n\t\tatomic_inc(&lport->xmt_fcp_wqerr);\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t \"6113 Fail IO, Could not issue WQE err %x \"\n\t\t\t\t \"sid: x%x did: x%x oxid: x%x\\n\",\n\t\t\t\t ret, vport->fc_myDID, ndlp->nlp_DID,\n\t\t\t\t lpfc_ncmd->cur_iocbq.sli4_xritag);\n\t\tgoto out_free_nvme_buf;\n\t}\n\n\tif (phba->cfg_xri_rebalancing)\n\t\tlpfc_keep_pvt_pool_above_lowwm(phba, lpfc_ncmd->hdwq_no);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_ncmd->ts_cmd_start)\n\t\tlpfc_ncmd->ts_cmd_wqput = ktime_get_ns();\n\n\tif (phba->hdwqstat_on & LPFC_CHECK_NVME_IO) {\n\t\tcpu = raw_smp_processor_id();\n\t\tthis_cpu_inc(phba->sli4_hba.c_stat->xmt_io);\n\t\tlpfc_ncmd->cpu = cpu;\n\t\tif (idx != cpu)\n\t\t\tlpfc_printf_vlog(vport,\n\t\t\t\t\t KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\t\t\"6702 CPU Check cmd: \"\n\t\t\t\t\t\"cpu %d wq %d\\n\",\n\t\t\t\t\tlpfc_ncmd->cpu,\n\t\t\t\t\tlpfc_queue_info->index);\n\t}\n#endif\n\treturn 0;\n\n out_free_nvme_buf:\n\tif (lpfc_ncmd->nvmeCmd->sg_cnt) {\n\t\tif (lpfc_ncmd->nvmeCmd->io_dir == NVMEFC_FCP_WRITE)\n\t\t\tcstat->output_requests--;\n\t\telse\n\t\t\tcstat->input_requests--;\n\t} else\n\t\tcstat->control_requests--;\n\tlpfc_release_nvme_buf(phba, lpfc_ncmd);\n out_fail1:\n\tlpfc_update_cmf_cmpl(phba, LPFC_CGN_NOT_SENT,\n\t\t\t     pnvme_fcreq->payload_length, NULL);\n out_fail:\n\treturn ret;\n}\n\n \nvoid\nlpfc_nvme_abort_fcreq_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *cmdiocb,\n\t\t\t   struct lpfc_iocbq *rspiocb)\n{\n\tstruct lpfc_wcqe_complete *abts_cmpl = &rspiocb->wcqe_cmpl;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME,\n\t\t\t\"6145 ABORT_XRI_CN completing on rpi x%x \"\n\t\t\t\"original iotag x%x, abort cmd iotag x%x \"\n\t\t\t\"req_tag x%x, status x%x, hwstatus x%x\\n\",\n\t\t\tbf_get(wqe_ctxt_tag, &cmdiocb->wqe.generic.wqe_com),\n\t\t\tget_job_abtsiotag(phba, cmdiocb), cmdiocb->iotag,\n\t\t\tbf_get(lpfc_wcqe_c_request_tag, abts_cmpl),\n\t\t\tbf_get(lpfc_wcqe_c_status, abts_cmpl),\n\t\t\tbf_get(lpfc_wcqe_c_hw_status, abts_cmpl));\n\tlpfc_sli_release_iocbq(phba, cmdiocb);\n}\n\n \nstatic void\nlpfc_nvme_fcp_abort(struct nvme_fc_local_port *pnvme_lport,\n\t\t    struct nvme_fc_remote_port *pnvme_rport,\n\t\t    void *hw_queue_handle,\n\t\t    struct nvmefc_fcp_req *pnvme_fcreq)\n{\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_hba *phba;\n\tstruct lpfc_io_buf *lpfc_nbuf;\n\tstruct lpfc_iocbq *nvmereq_wqe;\n\tstruct lpfc_nvme_fcpreq_priv *freqpriv;\n\tunsigned long flags;\n\tint ret_val;\n\n\t \n\tlport = (struct lpfc_nvme_lport *)pnvme_lport->private;\n\tif (unlikely(!lport))\n\t\treturn;\n\n\tvport = lport->vport;\n\n\tif (unlikely(!hw_queue_handle)) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_ABTS,\n\t\t\t\t \"6129 Fail Abort, HW Queue Handle NULL.\\n\");\n\t\treturn;\n\t}\n\n\tphba = vport->phba;\n\tfreqpriv = pnvme_fcreq->private;\n\n\tif (unlikely(!freqpriv))\n\t\treturn;\n\tif (vport->load_flag & FC_UNLOADING)\n\t\treturn;\n\n\t \n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_ABTS,\n\t\t\t \"6002 Abort Request to rport DID x%06x \"\n\t\t\t \"for nvme_fc_req x%px\\n\",\n\t\t\t pnvme_rport->port_id,\n\t\t\t pnvme_fcreq);\n\n\tlpfc_nbuf = freqpriv->nvme_buf;\n\tif (!lpfc_nbuf) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6140 NVME IO req has no matching lpfc nvme \"\n\t\t\t\t \"io buffer.  Skipping abort req.\\n\");\n\t\treturn;\n\t} else if (!lpfc_nbuf->nvmeCmd) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6141 lpfc NVME IO req has no nvme_fcreq \"\n\t\t\t\t \"io buffer.  Skipping abort req.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&lpfc_nbuf->buf_lock, flags);\n\n\t \n\tspin_lock(&phba->hbalock);\n\t \n\tif (phba->hba_flag & HBA_IOQ_FLUSH) {\n\t\tspin_unlock(&phba->hbalock);\n\t\tspin_unlock_irqrestore(&lpfc_nbuf->buf_lock, flags);\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6139 Driver in reset cleanup - flushing \"\n\t\t\t\t \"NVME Req now.  hba_flag x%x\\n\",\n\t\t\t\t phba->hba_flag);\n\t\treturn;\n\t}\n\n\tnvmereq_wqe = &lpfc_nbuf->cur_iocbq;\n\n\t \n\tif (lpfc_nbuf->nvmeCmd != pnvme_fcreq) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6143 NVME req mismatch: \"\n\t\t\t\t \"lpfc_nbuf x%px nvmeCmd x%px, \"\n\t\t\t\t \"pnvme_fcreq x%px.  Skipping Abort xri x%x\\n\",\n\t\t\t\t lpfc_nbuf, lpfc_nbuf->nvmeCmd,\n\t\t\t\t pnvme_fcreq, nvmereq_wqe->sli4_xritag);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (!(nvmereq_wqe->cmd_flag & LPFC_IO_ON_TXCMPLQ)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6142 NVME IO req x%px not queued - skipping \"\n\t\t\t\t \"abort req xri x%x\\n\",\n\t\t\t\t pnvme_fcreq, nvmereq_wqe->sli4_xritag);\n\t\tgoto out_unlock;\n\t}\n\n\tatomic_inc(&lport->xmt_fcp_abort);\n\tlpfc_nvmeio_data(phba, \"NVME FCP ABORT: xri x%x idx %d to %06x\\n\",\n\t\t\t nvmereq_wqe->sli4_xritag,\n\t\t\t nvmereq_wqe->hba_wqidx, pnvme_rport->port_id);\n\n\t \n\tif (nvmereq_wqe->cmd_flag & LPFC_DRIVER_ABORTED) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6144 Outstanding NVME I/O Abort Request \"\n\t\t\t\t \"still pending on nvme_fcreq x%px, \"\n\t\t\t\t \"lpfc_ncmd x%px xri x%x\\n\",\n\t\t\t\t pnvme_fcreq, lpfc_nbuf,\n\t\t\t\t nvmereq_wqe->sli4_xritag);\n\t\tgoto out_unlock;\n\t}\n\n\tret_val = lpfc_sli4_issue_abort_iotag(phba, nvmereq_wqe,\n\t\t\t\t\t      lpfc_nvme_abort_fcreq_cmpl);\n\n\tspin_unlock(&phba->hbalock);\n\tspin_unlock_irqrestore(&lpfc_nbuf->buf_lock, flags);\n\n\t \n\tlpfc_issue_hb_tmo(phba);\n\n\tif (ret_val != WQE_SUCCESS) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"6137 Failed abts issue_wqe with status x%x \"\n\t\t\t\t \"for nvme_fcreq x%px.\\n\",\n\t\t\t\t ret_val, pnvme_fcreq);\n\t\treturn;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_ABTS,\n\t\t\t \"6138 Transport Abort NVME Request Issued for \"\n\t\t\t \"ox_id x%x\\n\",\n\t\t\t nvmereq_wqe->sli4_xritag);\n\treturn;\n\nout_unlock:\n\tspin_unlock(&phba->hbalock);\n\tspin_unlock_irqrestore(&lpfc_nbuf->buf_lock, flags);\n\treturn;\n}\n\n \nstatic struct nvme_fc_port_template lpfc_nvme_template = {\n\t \n\t.localport_delete  = lpfc_nvme_localport_delete,\n\t.remoteport_delete = lpfc_nvme_remoteport_delete,\n\t.create_queue = lpfc_nvme_create_queue,\n\t.delete_queue = lpfc_nvme_delete_queue,\n\t.ls_req       = lpfc_nvme_ls_req,\n\t.fcp_io       = lpfc_nvme_fcp_io_submit,\n\t.ls_abort     = lpfc_nvme_ls_abort,\n\t.fcp_abort    = lpfc_nvme_fcp_abort,\n\t.xmt_ls_rsp   = lpfc_nvme_xmt_ls_rsp,\n\n\t.max_hw_queues = 1,\n\t.max_sgl_segments = LPFC_NVME_DEFAULT_SEGS,\n\t.max_dif_sgl_segments = LPFC_NVME_DEFAULT_SEGS,\n\t.dma_boundary = 0xFFFFFFFF,\n\n\t \n\t.local_priv_sz = sizeof(struct lpfc_nvme_lport),\n\t.remote_priv_sz = sizeof(struct lpfc_nvme_rport),\n\t.lsrqst_priv_sz = 0,\n\t.fcprqst_priv_sz = sizeof(struct lpfc_nvme_fcpreq_priv),\n};\n\n \nstatic struct lpfc_io_buf *\nlpfc_get_nvme_buf(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,\n\t\t  int idx, int expedite)\n{\n\tstruct lpfc_io_buf *lpfc_ncmd;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tstruct sli4_sge *sgl;\n\tstruct lpfc_iocbq *pwqeq;\n\tunion lpfc_wqe128 *wqe;\n\n\tlpfc_ncmd = lpfc_get_io_buf(phba, NULL, idx, expedite);\n\n\tif (lpfc_ncmd) {\n\t\tpwqeq = &(lpfc_ncmd->cur_iocbq);\n\t\twqe = &pwqeq->wqe;\n\n\t\t \n\t\tpwqeq->cmd_flag = LPFC_IO_NVME;\n\t\tpwqeq->cmd_cmpl = lpfc_nvme_io_cmd_cmpl;\n\t\tlpfc_ncmd->start_time = jiffies;\n\t\tlpfc_ncmd->flags = 0;\n\n\t\t \n\t\tsgl = lpfc_ncmd->dma_sgl;\n\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_SKIP);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t \n\n\t\t \n\t\tmemset(wqe, 0, sizeof(union lpfc_wqe));\n\n\t\tif (lpfc_ndlp_check_qdepth(phba, ndlp)) {\n\t\t\tatomic_inc(&ndlp->cmd_pending);\n\t\t\tlpfc_ncmd->flags |= LPFC_SBUF_BUMP_QDEPTH;\n\t\t}\n\n\t} else {\n\t\tqp = &phba->sli4_hba.hdwq[idx];\n\t\tqp->empty_io_bufs++;\n\t}\n\n\treturn  lpfc_ncmd;\n}\n\n \nstatic void\nlpfc_release_nvme_buf(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_ncmd)\n{\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tunsigned long iflag = 0;\n\n\tif ((lpfc_ncmd->flags & LPFC_SBUF_BUMP_QDEPTH) && lpfc_ncmd->ndlp)\n\t\tatomic_dec(&lpfc_ncmd->ndlp->cmd_pending);\n\n\tlpfc_ncmd->ndlp = NULL;\n\tlpfc_ncmd->flags &= ~LPFC_SBUF_BUMP_QDEPTH;\n\n\tqp = lpfc_ncmd->hdwq;\n\tif (unlikely(lpfc_ncmd->flags & LPFC_SBUF_XBUSY)) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,\n\t\t\t\t\"6310 XB release deferred for \"\n\t\t\t\t\"ox_id x%x on reqtag x%x\\n\",\n\t\t\t\tlpfc_ncmd->cur_iocbq.sli4_xritag,\n\t\t\t\tlpfc_ncmd->cur_iocbq.iotag);\n\n\t\tspin_lock_irqsave(&qp->abts_io_buf_list_lock, iflag);\n\t\tlist_add_tail(&lpfc_ncmd->list,\n\t\t\t&qp->lpfc_abts_io_buf_list);\n\t\tqp->abts_nvme_io_bufs++;\n\t\tspin_unlock_irqrestore(&qp->abts_io_buf_list_lock, iflag);\n\t} else\n\t\tlpfc_release_io_buf(phba, (struct lpfc_io_buf *)lpfc_ncmd, qp);\n}\n\n \nint\nlpfc_nvme_create_localport(struct lpfc_vport *vport)\n{\n\tint ret = 0;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct nvme_fc_port_info nfcp_info;\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_nvme_lport *lport;\n\n\t \n\tmemset(&nfcp_info, 0, sizeof(struct nvme_fc_port_info));\n\tnfcp_info.port_role = FC_PORT_ROLE_NVME_INITIATOR;\n\tnfcp_info.node_name = wwn_to_u64(vport->fc_nodename.u.wwn);\n\tnfcp_info.port_name = wwn_to_u64(vport->fc_portname.u.wwn);\n\n\t \n\tlpfc_nvme_template.max_sgl_segments = phba->cfg_nvme_seg_cnt + 1;\n\n\t \n\tlpfc_nvme_template.max_hw_queues = phba->cfg_hdw_queue;\n\n\tif (!IS_ENABLED(CONFIG_NVME_FC))\n\t\treturn ret;\n\n\t \n\n\tret = nvme_fc_register_localport(&nfcp_info, &lpfc_nvme_template,\n\t\t\t\t\t &vport->phba->pcidev->dev, &localport);\n\tif (!ret) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME | LOG_NVME_DISC,\n\t\t\t\t \"6005 Successfully registered local \"\n\t\t\t\t \"NVME port num %d, localP x%px, private \"\n\t\t\t\t \"x%px, sg_seg %d\\n\",\n\t\t\t\t localport->port_num, localport,\n\t\t\t\t localport->private,\n\t\t\t\t lpfc_nvme_template.max_sgl_segments);\n\n\t\t \n\t\tlport = (struct lpfc_nvme_lport *)localport->private;\n\t\tvport->localport = localport;\n\t\tlport->vport = vport;\n\t\tvport->nvmei_support = 1;\n\n\t\tatomic_set(&lport->xmt_fcp_noxri, 0);\n\t\tatomic_set(&lport->xmt_fcp_bad_ndlp, 0);\n\t\tatomic_set(&lport->xmt_fcp_qdepth, 0);\n\t\tatomic_set(&lport->xmt_fcp_err, 0);\n\t\tatomic_set(&lport->xmt_fcp_wqerr, 0);\n\t\tatomic_set(&lport->xmt_fcp_abort, 0);\n\t\tatomic_set(&lport->xmt_ls_abort, 0);\n\t\tatomic_set(&lport->xmt_ls_err, 0);\n\t\tatomic_set(&lport->cmpl_fcp_xb, 0);\n\t\tatomic_set(&lport->cmpl_fcp_err, 0);\n\t\tatomic_set(&lport->cmpl_ls_xb, 0);\n\t\tatomic_set(&lport->cmpl_ls_err, 0);\n\n\t\tatomic_set(&lport->fc4NvmeLsRequests, 0);\n\t\tatomic_set(&lport->fc4NvmeLsCmpls, 0);\n\t}\n\n\treturn ret;\n}\n\n#if (IS_ENABLED(CONFIG_NVME_FC))\n \nstatic void\nlpfc_nvme_lport_unreg_wait(struct lpfc_vport *vport,\n\t\t\t   struct lpfc_nvme_lport *lport,\n\t\t\t   struct completion *lport_unreg_cmp)\n{\n\tu32 wait_tmo;\n\tint ret, i, pending = 0;\n\tstruct lpfc_sli_ring  *pring;\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tint abts_scsi, abts_nvme;\n\n\t \n\twait_tmo = msecs_to_jiffies(LPFC_NVME_WAIT_TMO * 1000);\n\twhile (true) {\n\t\tret = wait_for_completion_timeout(lport_unreg_cmp, wait_tmo);\n\t\tif (unlikely(!ret)) {\n\t\t\tpending = 0;\n\t\t\tabts_scsi = 0;\n\t\t\tabts_nvme = 0;\n\t\t\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\t\t\tqp = &phba->sli4_hba.hdwq[i];\n\t\t\t\tif (!vport->localport || !qp || !qp->io_wq)\n\t\t\t\t\treturn;\n\n\t\t\t\tpring = qp->io_wq->pring;\n\t\t\t\tif (!pring)\n\t\t\t\t\tcontinue;\n\t\t\t\tpending += pring->txcmplq_cnt;\n\t\t\t\tabts_scsi += qp->abts_scsi_io_bufs;\n\t\t\t\tabts_nvme += qp->abts_nvme_io_bufs;\n\t\t\t}\n\t\t\tif (!vport->localport ||\n\t\t\t    test_bit(HBA_PCI_ERR, &vport->phba->bit_flags) ||\n\t\t\t    phba->link_state == LPFC_HBA_ERROR ||\n\t\t\t    vport->load_flag & FC_UNLOADING)\n\t\t\t\treturn;\n\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"6176 Lport x%px Localport x%px wait \"\n\t\t\t\t\t \"timed out. Pending %d [%d:%d]. \"\n\t\t\t\t\t \"Renewing.\\n\",\n\t\t\t\t\t lport, vport->localport, pending,\n\t\t\t\t\t abts_scsi, abts_nvme);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t \"6177 Lport x%px Localport x%px Complete Success\\n\",\n\t\t\t lport, vport->localport);\n}\n#endif\n\n \nvoid\nlpfc_nvme_destroy_localport(struct lpfc_vport *vport)\n{\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_nvme_lport *lport;\n\tint ret;\n\tDECLARE_COMPLETION_ONSTACK(lport_unreg_cmp);\n\n\tif (vport->nvmei_support == 0)\n\t\treturn;\n\n\tlocalport = vport->localport;\n\tif (!localport)\n\t\treturn;\n\tlport = (struct lpfc_nvme_lport *)localport->private;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME,\n\t\t\t \"6011 Destroying NVME localport x%px\\n\",\n\t\t\t localport);\n\n\t \n\tlport->lport_unreg_cmp = &lport_unreg_cmp;\n\tret = nvme_fc_unregister_localport(localport);\n\n\t \n\tlpfc_nvme_lport_unreg_wait(vport, lport, &lport_unreg_cmp);\n\tvport->localport = NULL;\n\n\t \n\tvport->nvmei_support = 0;\n\tif (ret == 0) {\n\t\tlpfc_printf_vlog(vport,\n\t\t\t\t KERN_INFO, LOG_NVME_DISC,\n\t\t\t\t \"6009 Unregistered lport Success\\n\");\n\t} else {\n\t\tlpfc_printf_vlog(vport,\n\t\t\t\t KERN_INFO, LOG_NVME_DISC,\n\t\t\t\t \"6010 Unregistered lport \"\n\t\t\t\t \"Failed, status x%x\\n\",\n\t\t\t\t ret);\n\t}\n#endif\n}\n\nvoid\nlpfc_nvme_update_localport(struct lpfc_vport *vport)\n{\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_nvme_lport *lport;\n\n\tlocalport = vport->localport;\n\tif (!localport) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_NVME,\n\t\t\t\t \"6710 Update NVME fail. No localport\\n\");\n\t\treturn;\n\t}\n\tlport = (struct lpfc_nvme_lport *)localport->private;\n\tif (!lport) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_NVME,\n\t\t\t\t \"6171 Update NVME fail. localP x%px, No lport\\n\",\n\t\t\t\t localport);\n\t\treturn;\n\t}\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME,\n\t\t\t \"6012 Update NVME lport x%px did x%x\\n\",\n\t\t\t localport, vport->fc_myDID);\n\n\tlocalport->port_id = vport->fc_myDID;\n\tif (localport->port_id == 0)\n\t\tlocalport->port_role = FC_PORT_ROLE_NVME_DISCOVERY;\n\telse\n\t\tlocalport->port_role = FC_PORT_ROLE_NVME_INITIATOR;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t \"6030 bound lport x%px to DID x%06x\\n\",\n\t\t\t lport, localport->port_id);\n#endif\n}\n\nint\nlpfc_nvme_register_port(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tint ret = 0;\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_nvme_rport *rport;\n\tstruct lpfc_nvme_rport *oldrport;\n\tstruct nvme_fc_remote_port *remote_port;\n\tstruct nvme_fc_port_info rpinfo;\n\tstruct lpfc_nodelist *prev_ndlp = NULL;\n\tstruct fc_rport *srport = ndlp->rport;\n\n\tlpfc_printf_vlog(ndlp->vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t \"6006 Register NVME PORT. DID x%06x nlptype x%x\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_type);\n\n\tlocalport = vport->localport;\n\tif (!localport)\n\t\treturn 0;\n\n\tlport = (struct lpfc_nvme_lport *)localport->private;\n\n\t \n\tmemset(&rpinfo, 0, sizeof(struct nvme_fc_port_info));\n\trpinfo.port_id = ndlp->nlp_DID;\n\tif (ndlp->nlp_type & NLP_NVME_TARGET)\n\t\trpinfo.port_role |= FC_PORT_ROLE_NVME_TARGET;\n\tif (ndlp->nlp_type & NLP_NVME_INITIATOR)\n\t\trpinfo.port_role |= FC_PORT_ROLE_NVME_INITIATOR;\n\n\tif (ndlp->nlp_type & NLP_NVME_DISCOVERY)\n\t\trpinfo.port_role |= FC_PORT_ROLE_NVME_DISCOVERY;\n\n\trpinfo.port_name = wwn_to_u64(ndlp->nlp_portname.u.wwn);\n\trpinfo.node_name = wwn_to_u64(ndlp->nlp_nodename.u.wwn);\n\tif (srport)\n\t\trpinfo.dev_loss_tmo = srport->dev_loss_tmo;\n\telse\n\t\trpinfo.dev_loss_tmo = vport->cfg_devloss_tmo;\n\n\tspin_lock_irq(&ndlp->lock);\n\n\t \n\toldrport = lpfc_ndlp_get_nrport(ndlp);\n\tif (oldrport) {\n\t\tprev_ndlp = oldrport->ndlp;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t} else {\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tif (!lpfc_nlp_get(ndlp)) {\n\t\t\tdev_warn(&vport->phba->pcidev->dev,\n\t\t\t\t \"Warning - No node ref - exit register\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = nvme_fc_register_remoteport(localport, &rpinfo, &remote_port);\n\tif (!ret) {\n\t\t \n\t\t \n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->fc4_xpt_flags &= ~NVME_XPT_UNREG_WAIT;\n\t\tndlp->fc4_xpt_flags |= NVME_XPT_REGD;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\trport = remote_port->private;\n\t\tif (oldrport) {\n\n\t\t\t \n\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\tndlp->nrport = NULL;\n\t\t\tndlp->fc4_xpt_flags &= ~NVME_XPT_UNREG_WAIT;\n\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\trport->ndlp = NULL;\n\t\t\trport->remoteport = NULL;\n\n\t\t\t \n\t\t\tif (prev_ndlp && prev_ndlp != ndlp) {\n\t\t\t\tif (!prev_ndlp->nrport)\n\t\t\t\t\tlpfc_nlp_put(prev_ndlp);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\trport->remoteport = remote_port;\n\t\trport->lport = lport;\n\t\trport->ndlp = ndlp;\n\t\tspin_lock_irq(&ndlp->lock);\n\t\tndlp->nrport = rport;\n\t\tspin_unlock_irq(&ndlp->lock);\n\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t LOG_NVME_DISC | LOG_NODE,\n\t\t\t\t \"6022 Bind lport x%px to remoteport x%px \"\n\t\t\t\t \"rport x%px WWNN 0x%llx, \"\n\t\t\t\t \"Rport WWPN 0x%llx DID \"\n\t\t\t\t \"x%06x Role x%x, ndlp %p prev_ndlp x%px\\n\",\n\t\t\t\t lport, remote_port, rport,\n\t\t\t\t rpinfo.node_name, rpinfo.port_name,\n\t\t\t\t rpinfo.port_id, rpinfo.port_role,\n\t\t\t\t ndlp, prev_ndlp);\n\t} else {\n\t\tlpfc_printf_vlog(vport, KERN_ERR,\n\t\t\t\t LOG_TRACE_EVENT,\n\t\t\t\t \"6031 RemotePort Registration failed \"\n\t\t\t\t \"err: %d, DID x%06x ref %u\\n\",\n\t\t\t\t ret, ndlp->nlp_DID, kref_read(&ndlp->kref));\n\t\tlpfc_nlp_put(ndlp);\n\t}\n\n\treturn ret;\n#else\n\treturn 0;\n#endif\n}\n\n \nvoid\nlpfc_nvme_rescan_port(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct lpfc_nvme_rport *nrport;\n\tstruct nvme_fc_remote_port *remoteport = NULL;\n\n\tspin_lock_irq(&ndlp->lock);\n\tnrport = lpfc_ndlp_get_nrport(ndlp);\n\tif (nrport)\n\t\tremoteport = nrport->remoteport;\n\tspin_unlock_irq(&ndlp->lock);\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t \"6170 Rescan NPort DID x%06x type x%x \"\n\t\t\t \"state x%x nrport x%px remoteport x%px\\n\",\n\t\t\t ndlp->nlp_DID, ndlp->nlp_type, ndlp->nlp_state,\n\t\t\t nrport, remoteport);\n\n\tif (!nrport || !remoteport)\n\t\tgoto rescan_exit;\n\n\t \n\tif (remoteport->port_role & FC_PORT_ROLE_NVME_DISCOVERY &&\n\t    ndlp->nlp_state == NLP_STE_MAPPED_NODE) {\n\t\tnvme_fc_rescan_remoteport(remoteport);\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t\t \"6172 NVME rescanned DID x%06x \"\n\t\t\t\t \"port_state x%x\\n\",\n\t\t\t\t ndlp->nlp_DID, remoteport->port_state);\n\t}\n\treturn;\n rescan_exit:\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t \"6169 Skip NVME Rport Rescan, NVME remoteport \"\n\t\t\t \"unregistered\\n\");\n#endif\n}\n\n \nvoid\nlpfc_nvme_unregister_port(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)\n{\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tint ret;\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_nvme_rport *rport;\n\tstruct nvme_fc_remote_port *remoteport = NULL;\n\n\tlocalport = vport->localport;\n\n\t \n\tif (!localport)\n\t\treturn;\n\n\tlport = (struct lpfc_nvme_lport *)localport->private;\n\tif (!lport)\n\t\tgoto input_err;\n\n\tspin_lock_irq(&ndlp->lock);\n\trport = lpfc_ndlp_get_nrport(ndlp);\n\tif (rport)\n\t\tremoteport = rport->remoteport;\n\tspin_unlock_irq(&ndlp->lock);\n\tif (!remoteport)\n\t\tgoto input_err;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_NVME_DISC,\n\t\t\t \"6033 Unreg nvme remoteport x%px, portname x%llx, \"\n\t\t\t \"port_id x%06x, portstate x%x port type x%x \"\n\t\t\t \"refcnt %d\\n\",\n\t\t\t remoteport, remoteport->port_name,\n\t\t\t remoteport->port_id, remoteport->port_state,\n\t\t\t ndlp->nlp_type, kref_read(&ndlp->kref));\n\n\t \n\n\tif (ndlp->nlp_type & NLP_NVME_TARGET) {\n\t\t \n\t\tspin_lock_irq(&vport->phba->hbalock);\n\t\tndlp->fc4_xpt_flags |= NVME_XPT_UNREG_WAIT;\n\t\tspin_unlock_irq(&vport->phba->hbalock);\n\n\t\t \n\t\tif (vport->load_flag & FC_UNLOADING ||\n\t\t    unlikely(vport->phba->link_state == LPFC_HBA_ERROR))\n\t\t\t(void)nvme_fc_set_remoteport_devloss(remoteport, 0);\n\n\t\tret = nvme_fc_unregister_remoteport(remoteport);\n\n\t\t \n\t\tndlp->nrport = NULL;\n\t\tlpfc_nlp_put(ndlp);\n\t\tif (ret != 0) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"6167 NVME unregister failed %d \"\n\t\t\t\t\t \"port_state x%x\\n\",\n\t\t\t\t\t ret, remoteport->port_state);\n\n\t\t\tif (vport->load_flag & FC_UNLOADING) {\n\t\t\t\t \n\t\t\t\tspin_lock_irq(&ndlp->lock);\n\t\t\t\tif (!(ndlp->nlp_flag & NLP_DROPPED)) {\n\t\t\t\t\tndlp->nlp_flag |= NLP_DROPPED;\n\t\t\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t\t\tlpfc_nlp_put(ndlp);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irq(&ndlp->lock);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n\n input_err:\n#endif\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"6168 State error: lport x%px, rport x%px FCID x%06x\\n\",\n\t\t\t vport->localport, ndlp->rport, ndlp->nlp_DID);\n}\n\n \nvoid\nlpfc_sli4_nvme_pci_offline_aborted(struct lpfc_hba *phba,\n\t\t\t\t   struct lpfc_io_buf *lpfc_ncmd)\n{\n\tstruct nvmefc_fcp_req *nvme_cmd = NULL;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,\n\t\t\t\"6533 %s nvme_cmd %p tag x%x abort complete and \"\n\t\t\t\"xri released\\n\", __func__,\n\t\t\tlpfc_ncmd->nvmeCmd,\n\t\t\tlpfc_ncmd->cur_iocbq.iotag);\n\n\t \n\tif (lpfc_ncmd->nvmeCmd) {\n\t\tnvme_cmd = lpfc_ncmd->nvmeCmd;\n\t\tnvme_cmd->transferred_length = 0;\n\t\tnvme_cmd->rcv_rsplen = 0;\n\t\tnvme_cmd->status = NVME_SC_INTERNAL;\n\t\tnvme_cmd->done(nvme_cmd);\n\t\tlpfc_ncmd->nvmeCmd = NULL;\n\t}\n\tlpfc_release_nvme_buf(phba, lpfc_ncmd);\n}\n\n \nvoid\nlpfc_sli4_nvme_xri_aborted(struct lpfc_hba *phba,\n\t\t\t   struct sli4_wcqe_xri_aborted *axri,\n\t\t\t   struct lpfc_io_buf *lpfc_ncmd)\n{\n\tuint16_t xri = bf_get(lpfc_wcqe_xa_xri, axri);\n\tstruct nvmefc_fcp_req *nvme_cmd = NULL;\n\tstruct lpfc_nodelist *ndlp = lpfc_ncmd->ndlp;\n\n\n\tif (ndlp)\n\t\tlpfc_sli4_abts_err_handler(phba, ndlp, axri);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME_ABTS,\n\t\t\t\"6311 nvme_cmd %p xri x%x tag x%x abort complete and \"\n\t\t\t\"xri released\\n\",\n\t\t\tlpfc_ncmd->nvmeCmd, xri,\n\t\t\tlpfc_ncmd->cur_iocbq.iotag);\n\n\t \n\tif (lpfc_ncmd->nvmeCmd) {\n\t\tnvme_cmd = lpfc_ncmd->nvmeCmd;\n\t\tnvme_cmd->done(nvme_cmd);\n\t\tlpfc_ncmd->nvmeCmd = NULL;\n\t}\n\tlpfc_release_nvme_buf(phba, lpfc_ncmd);\n}\n\n \nvoid\nlpfc_nvme_wait_for_io_drain(struct lpfc_hba *phba)\n{\n\tstruct lpfc_sli_ring  *pring;\n\tu32 i, wait_cnt = 0;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4 || !phba->sli4_hba.hdwq)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\tif (!phba->sli4_hba.hdwq[i].io_wq)\n\t\t\tcontinue;\n\t\tpring = phba->sli4_hba.hdwq[i].io_wq->pring;\n\n\t\tif (!pring)\n\t\t\tcontinue;\n\n\t\t \n\t\twhile (!list_empty(&pring->txcmplq)) {\n\t\t\tmsleep(LPFC_XRI_EXCH_BUSY_WAIT_T1);\n\t\t\twait_cnt++;\n\n\t\t\t \n\t\t\tif ((wait_cnt % 1000) == 0) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\t\"6178 NVME IO not empty, \"\n\t\t\t\t\t\t\"cnt %d\\n\", wait_cnt);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlpfc_issue_hb_tmo(phba);\n\n}\n\nvoid\nlpfc_nvme_cancel_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *pwqeIn,\n\t\t      uint32_t stat, uint32_t param)\n{\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct lpfc_io_buf *lpfc_ncmd;\n\tstruct nvmefc_fcp_req *nCmd;\n\tstruct lpfc_wcqe_complete wcqe;\n\tstruct lpfc_wcqe_complete *wcqep = &wcqe;\n\n\tlpfc_ncmd = pwqeIn->io_buf;\n\tif (!lpfc_ncmd) {\n\t\tlpfc_sli_release_iocbq(phba, pwqeIn);\n\t\treturn;\n\t}\n\t \n\tif (bf_get(wqe_cmnd, &pwqeIn->wqe.gen_req.wqe_com) ==\n\t    CMD_ABORT_XRI_CX) {\n\t\tlpfc_sli_release_iocbq(phba, pwqeIn);\n\t\treturn;\n\t}\n\n\tspin_lock(&lpfc_ncmd->buf_lock);\n\tnCmd = lpfc_ncmd->nvmeCmd;\n\tif (!nCmd) {\n\t\tspin_unlock(&lpfc_ncmd->buf_lock);\n\t\tlpfc_release_nvme_buf(phba, lpfc_ncmd);\n\t\treturn;\n\t}\n\tspin_unlock(&lpfc_ncmd->buf_lock);\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME_IOERR,\n\t\t\t\"6194 NVME Cancel xri %x\\n\",\n\t\t\tlpfc_ncmd->cur_iocbq.sli4_xritag);\n\n\twcqep->word0 = 0;\n\tbf_set(lpfc_wcqe_c_status, wcqep, stat);\n\twcqep->parameter = param;\n\twcqep->total_data_placed = 0;\n\twcqep->word3 = 0;  \n\n\t \n\tif (phba->sli.sli_flag & LPFC_SLI_ACTIVE)\n\t\tbf_set(lpfc_wcqe_c_xb, wcqep, 1);\n\n\tmemcpy(&pwqeIn->wcqe_cmpl, wcqep, sizeof(*wcqep));\n\t(pwqeIn->cmd_cmpl)(phba, pwqeIn, pwqeIn);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}