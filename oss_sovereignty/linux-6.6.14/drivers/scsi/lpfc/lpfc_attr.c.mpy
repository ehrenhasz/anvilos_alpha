{
  "module_name": "lpfc_attr.c",
  "hash_id": "a0b9037daf5588614754216ae8563cc6e89bb31d359f6e64af7941132eae983b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_attr.c",
  "human_readable_source": " \n\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/aer.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_nvme.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_version.h\"\n#include \"lpfc_compat.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_attr.h\"\n\n#define LPFC_DEF_DEVLOSS_TMO\t30\n#define LPFC_MIN_DEVLOSS_TMO\t1\n#define LPFC_MAX_DEVLOSS_TMO\t255\n\n#define LPFC_MAX_INFO_TMP_LEN\t100\n#define LPFC_INFO_MORE_STR\t\"\\nCould be more info...\\n\"\n \n#define LPFC_REG_WRITE_KEY_SIZE\t4\n#define LPFC_REG_WRITE_KEY\t\"EMLX\"\n\nconst char *const trunk_errmsg[] = {\t \n\t\"\",\t \n\t\"link negotiated speed does not match existing\"\n\t\t\" trunk - link was \\\"low\\\" speed\",\n\t\"link negotiated speed does not match\"\n\t\t\" existing trunk - link was \\\"middle\\\" speed\",\n\t\"link negotiated speed does not match existing\"\n\t\t\" trunk - link was \\\"high\\\" speed\",\n\t\"Attached to non-trunking port - F_Port\",\n\t\"Attached to non-trunking port - N_Port\",\n\t\"FLOGI response timeout\",\n\t\"non-FLOGI frame received\",\n\t\"Invalid FLOGI response\",\n\t\"Trunking initialization protocol\",\n\t\"Trunk peer device mismatch\",\n};\n\n \nstatic void\nlpfc_jedec_to_ascii(int incr, char hdw[])\n{\n\tint i, j;\n\tfor (i = 0; i < 8; i++) {\n\t\tj = (incr & 0xf);\n\t\tif (j <= 9)\n\t\t\thdw[7 - i] = 0x30 +  j;\n\t\t else\n\t\t\thdw[7 - i] = 0x61 + j - 10;\n\t\tincr = (incr >> 4);\n\t}\n\thdw[8] = 0;\n\treturn;\n}\n\nstatic ssize_t\nlpfc_cmf_info_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_cgn_info *cp = NULL;\n\tstruct lpfc_cgn_stat *cgs;\n\tint  len = 0;\n\tint cpu;\n\tu64 rcv, total;\n\tchar tmp[LPFC_MAX_INFO_TMP_LEN] = {0};\n\n\tif (phba->cgn_i)\n\t\tcp = (struct lpfc_cgn_info *)phba->cgn_i->virt;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"Congestion Mgmt Info: E2Eattr %d Ver %d \"\n\t\t  \"CMF %d cnt %d\\n\",\n\t\t  phba->sli4_hba.pc_sli4_params.mi_cap,\n\t\t  cp ? cp->cgn_info_version : 0,\n\t\t  phba->sli4_hba.pc_sli4_params.cmf, phba->cmf_timer_cnt);\n\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tif (!phba->sli4_hba.pc_sli4_params.cmf)\n\t\tgoto buffer_done;\n\n\tswitch (phba->cgn_init_reg_signal) {\n\tcase EDC_CG_SIG_WARN_ONLY:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"Register: Init:  Signal:WARN  \");\n\t\tbreak;\n\tcase EDC_CG_SIG_WARN_ALARM:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"Register: Init:  Signal:WARN|ALARM  \");\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"Register: Init:  Signal:NONE  \");\n\t\tbreak;\n\t}\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tswitch (phba->cgn_init_reg_fpin) {\n\tcase LPFC_CGN_FPIN_WARN:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FPIN:WARN\\n\");\n\t\tbreak;\n\tcase LPFC_CGN_FPIN_ALARM:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FPIN:ALARM\\n\");\n\t\tbreak;\n\tcase LPFC_CGN_FPIN_BOTH:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FPIN:WARN|ALARM\\n\");\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FPIN:NONE\\n\");\n\t\tbreak;\n\t}\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tswitch (phba->cgn_reg_signal) {\n\tcase EDC_CG_SIG_WARN_ONLY:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"       Current:  Signal:WARN  \");\n\t\tbreak;\n\tcase EDC_CG_SIG_WARN_ALARM:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"       Current:  Signal:WARN|ALARM  \");\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"       Current:  Signal:NONE  \");\n\t\tbreak;\n\t}\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tswitch (phba->cgn_reg_fpin) {\n\tcase LPFC_CGN_FPIN_WARN:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FPIN:WARN  ACQEcnt:%d\\n\", phba->cgn_acqe_cnt);\n\t\tbreak;\n\tcase LPFC_CGN_FPIN_ALARM:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FPIN:ALARM  ACQEcnt:%d\\n\", phba->cgn_acqe_cnt);\n\t\tbreak;\n\tcase LPFC_CGN_FPIN_BOTH:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FPIN:WARN|ALARM  ACQEcnt:%d\\n\", phba->cgn_acqe_cnt);\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FPIN:NONE  ACQEcnt:%d\\n\", phba->cgn_acqe_cnt);\n\t\tbreak;\n\t}\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tif (phba->cmf_active_mode != phba->cgn_p.cgn_param_mode) {\n\t\tswitch (phba->cmf_active_mode) {\n\t\tcase LPFC_CFG_OFF:\n\t\t\tscnprintf(tmp, sizeof(tmp), \"Active: Mode:Off\\n\");\n\t\t\tbreak;\n\t\tcase LPFC_CFG_MANAGED:\n\t\t\tscnprintf(tmp, sizeof(tmp), \"Active: Mode:Managed\\n\");\n\t\t\tbreak;\n\t\tcase LPFC_CFG_MONITOR:\n\t\t\tscnprintf(tmp, sizeof(tmp), \"Active: Mode:Monitor\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscnprintf(tmp, sizeof(tmp), \"Active: Mode:Unknown\\n\");\n\t\t}\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\t}\n\n\tswitch (phba->cgn_p.cgn_param_mode) {\n\tcase LPFC_CFG_OFF:\n\t\tscnprintf(tmp, sizeof(tmp), \"Config: Mode:Off  \");\n\t\tbreak;\n\tcase LPFC_CFG_MANAGED:\n\t\tscnprintf(tmp, sizeof(tmp), \"Config: Mode:Managed \");\n\t\tbreak;\n\tcase LPFC_CFG_MONITOR:\n\t\tscnprintf(tmp, sizeof(tmp), \"Config: Mode:Monitor \");\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(tmp, sizeof(tmp), \"Config: Mode:Unknown \");\n\t}\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\ttotal = 0;\n\trcv = 0;\n\tfor_each_present_cpu(cpu) {\n\t\tcgs = per_cpu_ptr(phba->cmf_stat, cpu);\n\t\ttotal += atomic64_read(&cgs->total_bytes);\n\t\trcv += atomic64_read(&cgs->rcv_bytes);\n\t}\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"IObusy:%d Info:%d Bytes: Rcv:x%llx Total:x%llx\\n\",\n\t\t  atomic_read(&phba->cmf_busy),\n\t\t  phba->cmf_active_info, rcv, total);\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"Port_speed:%d  Link_byte_cnt:%ld  \"\n\t\t  \"Max_byte_per_interval:%ld\\n\",\n\t\t  lpfc_sli_port_speed_get(phba),\n\t\t  (unsigned long)phba->cmf_link_byte_count,\n\t\t  (unsigned long)phba->cmf_max_bytes_per_interval);\n\tstrlcat(buf, tmp, PAGE_SIZE);\n\nbuffer_done:\n\tlen = strnlen(buf, PAGE_SIZE);\n\n\tif (unlikely(len >= (PAGE_SIZE - 1))) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_CGN_MGMT,\n\t\t\t\t\"6312 Catching potential buffer \"\n\t\t\t\t\"overflow > PAGE_SIZE = %lu bytes\\n\",\n\t\t\t\tPAGE_SIZE);\n\t\tstrscpy(buf + PAGE_SIZE - 1 - sizeof(LPFC_INFO_MORE_STR),\n\t\t\tLPFC_INFO_MORE_STR, sizeof(LPFC_INFO_MORE_STR) + 1);\n\t}\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_drvr_version_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, LPFC_MODULE_DESC \"\\n\");\n}\n\n \nstatic ssize_t\nlpfc_enable_fip_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (phba->hba_flag & HBA_FIP_SUPPORT)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"1\\n\");\n\telse\n\t\treturn scnprintf(buf, PAGE_SIZE, \"0\\n\");\n}\n\nstatic ssize_t\nlpfc_nvme_info_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_nvmet_tgtport *tgtp;\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_nvme_lport *lport;\n\tstruct lpfc_nvme_rport *rport;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct nvme_fc_remote_port *nrport;\n\tstruct lpfc_fc4_ctrl_stat *cstat;\n\tuint64_t data1, data2, data3;\n\tuint64_t totin, totout, tot;\n\tchar *statep;\n\tint i;\n\tint len = 0;\n\tchar tmp[LPFC_MAX_INFO_TMP_LEN] = {0};\n\n\tif (!(vport->cfg_enable_fc4_type & LPFC_ENABLE_NVME)) {\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"NVME Disabled\\n\");\n\t\treturn len;\n\t}\n\tif (phba->nvmet_support) {\n\t\tif (!phba->targetport) {\n\t\t\tlen = scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\"NVME Target: x%llx is not allocated\\n\",\n\t\t\t\t\twwn_to_u64(vport->fc_portname.u.wwn));\n\t\t\treturn len;\n\t\t}\n\t\t \n\t\tif (phba->targetport->port_id)\n\t\t\tstatep = \"REGISTERED\";\n\t\telse\n\t\t\tstatep = \"INIT\";\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"NVME Target Enabled  State %s\\n\",\n\t\t\t  statep);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"%s%d WWPN x%llx WWNN x%llx DID x%06x\\n\",\n\t\t\t  \"NVME Target: lpfc\",\n\t\t\t  phba->brd_no,\n\t\t\t  wwn_to_u64(vport->fc_portname.u.wwn),\n\t\t\t  wwn_to_u64(vport->fc_nodename.u.wwn),\n\t\t\t  phba->targetport->port_id);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tif (strlcat(buf, \"\\nNVME Target: Statistics\\n\", PAGE_SIZE)\n\t\t    >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\ttgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"LS: Rcv %08x Drop %08x Abort %08x\\n\",\n\t\t\t  atomic_read(&tgtp->rcv_ls_req_in),\n\t\t\t  atomic_read(&tgtp->rcv_ls_req_drop),\n\t\t\t  atomic_read(&tgtp->xmt_ls_abort));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tif (atomic_read(&tgtp->rcv_ls_req_in) !=\n\t\t    atomic_read(&tgtp->rcv_ls_req_out)) {\n\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t  \"Rcv LS: in %08x != out %08x\\n\",\n\t\t\t\t  atomic_read(&tgtp->rcv_ls_req_in),\n\t\t\t\t  atomic_read(&tgtp->rcv_ls_req_out));\n\t\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto buffer_done;\n\t\t}\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"LS: Xmt %08x Drop %08x Cmpl %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp),\n\t\t\t  atomic_read(&tgtp->xmt_ls_drop),\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp_cmpl));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"LS: RSP Abort %08x xb %08x Err %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp_aborted),\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp_xb_set),\n\t\t\t  atomic_read(&tgtp->xmt_ls_rsp_error));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FCP: Rcv %08x Defer %08x Release %08x \"\n\t\t\t  \"Drop %08x\\n\",\n\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_in),\n\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_defer),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_release),\n\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_drop));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tif (atomic_read(&tgtp->rcv_fcp_cmd_in) !=\n\t\t    atomic_read(&tgtp->rcv_fcp_cmd_out)) {\n\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t  \"Rcv FCP: in %08x != out %08x\\n\",\n\t\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_in),\n\t\t\t\t  atomic_read(&tgtp->rcv_fcp_cmd_out));\n\t\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto buffer_done;\n\t\t}\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FCP Rsp: RD %08x rsp %08x WR %08x rsp %08x \"\n\t\t\t  \"drop %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_fcp_read),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_read_rsp),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_write),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_drop));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FCP Rsp Cmpl: %08x err %08x drop %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_cmpl),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_error),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_drop));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"FCP Rsp Abort: %08x xb %08x xricqe  %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_aborted),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_rsp_xb_set),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_xri_abort_cqe));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"ABORT: Xmt %08x Cmpl %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_fcp_abort),\n\t\t\t  atomic_read(&tgtp->xmt_fcp_abort_cmpl));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"ABORT: Sol %08x  Usol %08x Err %08x Cmpl %08x\\n\",\n\t\t\t  atomic_read(&tgtp->xmt_abort_sol),\n\t\t\t  atomic_read(&tgtp->xmt_abort_unsol),\n\t\t\t  atomic_read(&tgtp->xmt_abort_rsp),\n\t\t\t  atomic_read(&tgtp->xmt_abort_rsp_error));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"DELAY: ctx %08x  fod %08x wqfull %08x\\n\",\n\t\t\t  atomic_read(&tgtp->defer_ctx),\n\t\t\t  atomic_read(&tgtp->defer_fod),\n\t\t\t  atomic_read(&tgtp->defer_wqfull));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\t \n\t\ttot = atomic_read(&tgtp->rcv_fcp_cmd_drop);\n\t\ttot += atomic_read(&tgtp->xmt_fcp_release);\n\t\ttot = atomic_read(&tgtp->rcv_fcp_cmd_in) - tot;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"IO_CTX: %08x  WAIT: cur %08x tot %08x\\n\"\n\t\t\t  \"CTX Outstanding %08llx\\n\\n\",\n\t\t\t  phba->sli4_hba.nvmet_xri_cnt,\n\t\t\t  phba->sli4_hba.nvmet_io_wait_cnt,\n\t\t\t  phba->sli4_hba.nvmet_io_wait_total,\n\t\t\t  tot);\n\t\tstrlcat(buf, tmp, PAGE_SIZE);\n\t\tgoto buffer_done;\n\t}\n\n\tlocalport = vport->localport;\n\tif (!localport) {\n\t\tlen = scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\"NVME Initiator x%llx is not allocated\\n\",\n\t\t\t\twwn_to_u64(vport->fc_portname.u.wwn));\n\t\treturn len;\n\t}\n\tlport = (struct lpfc_nvme_lport *)localport->private;\n\tif (strlcat(buf, \"\\nNVME Initiator Enabled\\n\", PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"XRI Dist lpfc%d Total %d IO %d ELS %d\\n\",\n\t\t  phba->brd_no,\n\t\t  phba->sli4_hba.max_cfg_param.max_xri,\n\t\t  phba->sli4_hba.io_xri_max,\n\t\t  lpfc_sli4_get_els_iocb_cnt(phba));\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\t \n\tif (localport->port_id)\n\t\tstatep = \"ONLINE\";\n\telse\n\t\tstatep = \"UNKNOWN \";\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"%s%d WWPN x%llx WWNN x%llx DID x%06x %s\\n\",\n\t\t  \"NVME LPORT lpfc\",\n\t\t  phba->brd_no,\n\t\t  wwn_to_u64(vport->fc_portname.u.wwn),\n\t\t  wwn_to_u64(vport->fc_nodename.u.wwn),\n\t\t  localport->port_id, statep);\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tnrport = NULL;\n\t\tspin_lock(&ndlp->lock);\n\t\trport = lpfc_ndlp_get_nrport(ndlp);\n\t\tif (rport)\n\t\t\tnrport = rport->remoteport;\n\t\tspin_unlock(&ndlp->lock);\n\t\tif (!nrport)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (nrport->port_state) {\n\t\tcase FC_OBJSTATE_ONLINE:\n\t\t\tstatep = \"ONLINE\";\n\t\t\tbreak;\n\t\tcase FC_OBJSTATE_UNKNOWN:\n\t\t\tstatep = \"UNKNOWN \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatep = \"UNSUPPORTED\";\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (strlcat(buf, \"NVME RPORT       \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\t\tif (phba->brd_no >= 10) {\n\t\t\tif (strlcat(buf, \" \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\n\t\tscnprintf(tmp, sizeof(tmp), \"WWPN x%llx \",\n\t\t\t  nrport->port_name);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\n\t\tscnprintf(tmp, sizeof(tmp), \"WWNN x%llx \",\n\t\t\t  nrport->node_name);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\n\t\tscnprintf(tmp, sizeof(tmp), \"DID x%06x \",\n\t\t\t  nrport->port_id);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\n\t\t \n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_INITIATOR) {\n\t\t\tif (strlcat(buf, \"INITIATOR \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_TARGET) {\n\t\t\tif (strlcat(buf, \"TARGET \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_DISCOVERY) {\n\t\t\tif (strlcat(buf, \"DISCSRVC \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\t\tif (nrport->port_role & ~(FC_PORT_ROLE_NVME_INITIATOR |\n\t\t\t\t\t  FC_PORT_ROLE_NVME_TARGET |\n\t\t\t\t\t  FC_PORT_ROLE_NVME_DISCOVERY)) {\n\t\t\tscnprintf(tmp, sizeof(tmp), \"UNKNOWN ROLE x%x\",\n\t\t\t\t  nrport->port_role);\n\t\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tgoto unlock_buf_done;\n\t\t}\n\n\t\tscnprintf(tmp, sizeof(tmp), \"%s\\n\", statep);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto unlock_buf_done;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\n\tif (!lport)\n\t\tgoto buffer_done;\n\n\tif (strlcat(buf, \"\\nNVME Statistics\\n\", PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"LS: Xmt %010x Cmpl %010x Abort %08x\\n\",\n\t\t  atomic_read(&lport->fc4NvmeLsRequests),\n\t\t  atomic_read(&lport->fc4NvmeLsCmpls),\n\t\t  atomic_read(&lport->xmt_ls_abort));\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"LS XMIT: Err %08x  CMPL: xb %08x Err %08x\\n\",\n\t\t  atomic_read(&lport->xmt_ls_err),\n\t\t  atomic_read(&lport->cmpl_ls_xb),\n\t\t  atomic_read(&lport->cmpl_ls_err));\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\ttotin = 0;\n\ttotout = 0;\n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\tcstat = &phba->sli4_hba.hdwq[i].nvme_cstat;\n\t\ttot = cstat->io_cmpls;\n\t\ttotin += tot;\n\t\tdata1 = cstat->input_requests;\n\t\tdata2 = cstat->output_requests;\n\t\tdata3 = cstat->control_requests;\n\t\ttotout += (data1 + data2 + data3);\n\t}\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"Total FCP Cmpl %016llx Issue %016llx \"\n\t\t  \"OutIO %016llx\\n\",\n\t\t  totin, totout, totout - totin);\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"\\tabort %08x noxri %08x nondlp %08x qdepth %08x \"\n\t\t  \"wqerr %08x err %08x\\n\",\n\t\t  atomic_read(&lport->xmt_fcp_abort),\n\t\t  atomic_read(&lport->xmt_fcp_noxri),\n\t\t  atomic_read(&lport->xmt_fcp_bad_ndlp),\n\t\t  atomic_read(&lport->xmt_fcp_qdepth),\n\t\t  atomic_read(&lport->xmt_fcp_wqerr),\n\t\t  atomic_read(&lport->xmt_fcp_err));\n\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"FCP CMPL: xb %08x Err %08x\\n\",\n\t\t  atomic_read(&lport->cmpl_fcp_xb),\n\t\t  atomic_read(&lport->cmpl_fcp_err));\n\tstrlcat(buf, tmp, PAGE_SIZE);\n\n\t \n\tgoto buffer_done;\n\n unlock_buf_done:\n\tspin_unlock_irq(shost->host_lock);\n\n buffer_done:\n\tlen = strnlen(buf, PAGE_SIZE);\n\n\tif (unlikely(len >= (PAGE_SIZE - 1))) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME,\n\t\t\t\t\"6314 Catching potential buffer \"\n\t\t\t\t\"overflow > PAGE_SIZE = %lu bytes\\n\",\n\t\t\t\tPAGE_SIZE);\n\t\tstrscpy(buf + PAGE_SIZE - 1 - sizeof(LPFC_INFO_MORE_STR),\n\t\t\tLPFC_INFO_MORE_STR,\n\t\t\tsizeof(LPFC_INFO_MORE_STR) + 1);\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t\nlpfc_scsi_stat_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct lpfc_hba *phba = vport->phba;\n\tint len;\n\tstruct lpfc_fc4_ctrl_stat *cstat;\n\tu64 data1, data2, data3;\n\tu64 tot, totin, totout;\n\tint i;\n\tchar tmp[LPFC_MAX_SCSI_INFO_TMP_LEN] = {0};\n\n\tif (!(vport->cfg_enable_fc4_type & LPFC_ENABLE_FCP) ||\n\t    (phba->sli_rev != LPFC_SLI_REV4))\n\t\treturn 0;\n\n\tscnprintf(buf, PAGE_SIZE, \"SCSI HDWQ Statistics\\n\");\n\n\ttotin = 0;\n\ttotout = 0;\n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\tcstat = &phba->sli4_hba.hdwq[i].scsi_cstat;\n\t\ttot = cstat->io_cmpls;\n\t\ttotin += tot;\n\t\tdata1 = cstat->input_requests;\n\t\tdata2 = cstat->output_requests;\n\t\tdata3 = cstat->control_requests;\n\t\ttotout += (data1 + data2 + data3);\n\n\t\tscnprintf(tmp, sizeof(tmp), \"HDWQ (%d): Rd %016llx Wr %016llx \"\n\t\t\t  \"IO %016llx \", i, data1, data2, data3);\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp), \"Cmpl %016llx OutIO %016llx\\n\",\n\t\t\t  tot, ((data1 + data2 + data3) - tot));\n\t\tif (strlcat(buf, tmp, PAGE_SIZE) >= PAGE_SIZE)\n\t\t\tgoto buffer_done;\n\t}\n\tscnprintf(tmp, sizeof(tmp), \"Total FCP Cmpl %016llx Issue %016llx \"\n\t\t  \"OutIO %016llx\\n\", totin, totout, totout - totin);\n\tstrlcat(buf, tmp, PAGE_SIZE);\n\nbuffer_done:\n\tlen = strnlen(buf, PAGE_SIZE);\n\n\treturn len;\n}\n\nstatic ssize_t\nlpfc_bg_info_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (phba->cfg_enable_bg) {\n\t\tif (phba->sli3_options & LPFC_SLI3_BG_ENABLED)\n\t\t\treturn scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\"BlockGuard Enabled\\n\");\n\t\telse\n\t\t\treturn scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\"BlockGuard Not Supported\\n\");\n\t} else\n\t\treturn scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\"BlockGuard Disabled\\n\");\n}\n\nstatic ssize_t\nlpfc_bg_guard_err_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t(unsigned long long)phba->bg_guard_err_cnt);\n}\n\nstatic ssize_t\nlpfc_bg_apptag_err_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t(unsigned long long)phba->bg_apptag_err_cnt);\n}\n\nstatic ssize_t\nlpfc_bg_reftag_err_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t(unsigned long long)phba->bg_reftag_err_cnt);\n}\n\n \nstatic ssize_t\nlpfc_info_show(struct device *dev, struct device_attribute *attr,\n\t       char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", lpfc_info(host));\n}\n\n \nstatic ssize_t\nlpfc_serialnum_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->SerialNumber);\n}\n\n \nstatic ssize_t\nlpfc_temp_sensor_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->temp_sensor_support);\n}\n\n \nstatic ssize_t\nlpfc_modeldesc_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->ModelDesc);\n}\n\n \nstatic ssize_t\nlpfc_modelname_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->ModelName);\n}\n\n \nstatic ssize_t\nlpfc_programtype_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->ProgramType);\n}\n\n \nstatic ssize_t\nlpfc_vportnum_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", phba->Port);\n}\n\n \nstatic ssize_t\nlpfc_fwrev_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t if_type;\n\tuint8_t sli_family;\n\tchar fwrev[FW_REV_STR_SIZE];\n\tint len;\n\n\tlpfc_decode_firmware_rev(phba, fwrev, 1);\n\tif_type = phba->sli4_hba.pc_sli4_params.if_type;\n\tsli_family = phba->sli4_hba.pc_sli4_params.sli_family;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"%s, sli-%d\\n\",\n\t\t\t       fwrev, phba->sli_rev);\n\telse\n\t\tlen = scnprintf(buf, PAGE_SIZE, \"%s, sli-%d:%d:%x\\n\",\n\t\t\t       fwrev, phba->sli_rev, if_type, sli_family);\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_hdw_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tchar hdw[9];\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tlpfc_vpd_t *vp = &phba->vpd;\n\n\tlpfc_jedec_to_ascii(vp->rev.biuRev, hdw);\n\treturn scnprintf(buf, PAGE_SIZE, \"%s %08x %08x\\n\", hdw,\n\t\t\t vp->rev.smRev, vp->rev.smFwRev);\n}\n\n \nstatic ssize_t\nlpfc_option_rom_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tchar fwrev[FW_REV_STR_SIZE];\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\t\tphba->OptionROMVersion);\n\n\tlpfc_decode_firmware_rev(phba, fwrev, 1);\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", fwrev);\n}\n\n \nstatic ssize_t\nlpfc_link_state_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint  len = 0;\n\n\tswitch (phba->link_state) {\n\tcase LPFC_LINK_UNKNOWN:\n\tcase LPFC_WARM_START:\n\tcase LPFC_INIT_START:\n\tcase LPFC_INIT_MBX_CMDS:\n\tcase LPFC_LINK_DOWN:\n\tcase LPFC_HBA_ERROR:\n\t\tif (phba->hba_flag & LINK_DISABLED)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"Link Down - User disabled\\n\");\n\t\telse\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"Link Down\\n\");\n\t\tbreak;\n\tcase LPFC_LINK_UP:\n\tcase LPFC_CLEAR_LA:\n\tcase LPFC_HBA_READY:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"Link Up - \");\n\n\t\tswitch (vport->port_state) {\n\t\tcase LPFC_LOCAL_CFG_LINK:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\"Configuring Link\\n\");\n\t\t\tbreak;\n\t\tcase LPFC_FDISC:\n\t\tcase LPFC_FLOGI:\n\t\tcase LPFC_FABRIC_CFG_LINK:\n\t\tcase LPFC_NS_REG:\n\t\tcase LPFC_NS_QRY:\n\t\tcase LPFC_BUILD_DISC_LIST:\n\t\tcase LPFC_DISC_AUTH:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Discovery\\n\");\n\t\t\tbreak;\n\t\tcase LPFC_VPORT_READY:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Ready\\n\");\n\t\t\tbreak;\n\n\t\tcase LPFC_VPORT_FAILED:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Failed\\n\");\n\t\t\tbreak;\n\n\t\tcase LPFC_VPORT_UNKNOWN:\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Unknown\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\tif (vport->fc_flag & FC_PUBLIC_LOOP)\n\t\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\t\"   Public Loop\\n\");\n\t\t\telse\n\t\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\t\"   Private Loop\\n\");\n\t\t} else {\n\t\t\tif (vport->fc_flag & FC_FABRIC) {\n\t\t\t\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t\t\t\t    vport->port_type == LPFC_PHYSICAL_PORT &&\n\t\t\t\t    phba->sli4_hba.fawwpn_flag &\n\t\t\t\t\tLPFC_FAWWPN_FABRIC)\n\t\t\t\t\tlen += scnprintf(buf + len,\n\t\t\t\t\t\t\t PAGE_SIZE - len,\n\t\t\t\t\t\t\t \"   Fabric FA-PWWN\\n\");\n\t\t\t\telse\n\t\t\t\t\tlen += scnprintf(buf + len,\n\t\t\t\t\t\t\t PAGE_SIZE - len,\n\t\t\t\t\t\t\t \"   Fabric\\n\");\n\t\t\t} else {\n\t\t\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\t\t\"   Point-2-Point\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((phba->sli_rev == LPFC_SLI_REV4) &&\n\t    ((bf_get(lpfc_sli_intf_if_type,\n\t     &phba->sli4_hba.sli_intf) ==\n\t     LPFC_SLI_INTF_IF_TYPE_6))) {\n\t\tstruct lpfc_trunk_link link = phba->trunk_link;\n\n\t\tif (bf_get(lpfc_conf_trunk_port0, &phba->sli4_hba))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Trunk port 0: Link %s %s\\n\",\n\t\t\t\t(link.link0.state == LPFC_LINK_UP) ?\n\t\t\t\t \"Up\" : \"Down. \",\n\t\t\t\ttrunk_errmsg[link.link0.fault]);\n\n\t\tif (bf_get(lpfc_conf_trunk_port1, &phba->sli4_hba))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Trunk port 1: Link %s %s\\n\",\n\t\t\t\t(link.link1.state == LPFC_LINK_UP) ?\n\t\t\t\t \"Up\" : \"Down. \",\n\t\t\t\ttrunk_errmsg[link.link1.fault]);\n\n\t\tif (bf_get(lpfc_conf_trunk_port2, &phba->sli4_hba))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Trunk port 2: Link %s %s\\n\",\n\t\t\t\t(link.link2.state == LPFC_LINK_UP) ?\n\t\t\t\t \"Up\" : \"Down. \",\n\t\t\t\ttrunk_errmsg[link.link2.fault]);\n\n\t\tif (bf_get(lpfc_conf_trunk_port3, &phba->sli4_hba))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Trunk port 3: Link %s %s\\n\",\n\t\t\t\t(link.link3.state == LPFC_LINK_UP) ?\n\t\t\t\t \"Up\" : \"Down. \",\n\t\t\t\ttrunk_errmsg[link.link3.fault]);\n\n\t}\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_sli4_protocol_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"fc\\n\");\n\n\tif (phba->sli4_hba.lnk_info.lnk_dv == LPFC_LNK_DAT_VAL) {\n\t\tif (phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_GE)\n\t\t\treturn scnprintf(buf, PAGE_SIZE, \"fcoe\\n\");\n\t\tif (phba->sli4_hba.lnk_info.lnk_tp == LPFC_LNK_TYPE_FC)\n\t\t\treturn scnprintf(buf, PAGE_SIZE, \"fc\\n\");\n\t}\n\treturn scnprintf(buf, PAGE_SIZE, \"unknown\\n\");\n}\n\n \nstatic ssize_t\nlpfc_oas_supported_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tphba->sli4_hba.pc_sli4_params.oas_supported);\n}\n\n \nstatic ssize_t\nlpfc_link_state_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tint status = -EINVAL;\n\n\tif ((strncmp(buf, \"up\", sizeof(\"up\") - 1) == 0) &&\n\t\t\t(phba->link_state == LPFC_LINK_DOWN))\n\t\tstatus = phba->lpfc_hba_init_link(phba, MBX_NOWAIT);\n\telse if ((strncmp(buf, \"down\", sizeof(\"down\") - 1) == 0) &&\n\t\t\t(phba->link_state >= LPFC_LINK_UP))\n\t\tstatus = phba->lpfc_hba_down_link(phba, MBX_NOWAIT);\n\n\tif (status == 0)\n\t\treturn strlen(buf);\n\telse\n\t\treturn status;\n}\n\n \nstatic ssize_t\nlpfc_num_discovered_ports_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tvport->fc_map_cnt + vport->fc_unmap_cnt);\n}\n\n \nstatic int\nlpfc_issue_lip(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tLPFC_MBOXQ_t *pmboxq;\n\tint mbxstatus = MBXERR_ERROR;\n\n\t \n\tif ((vport->fc_flag & FC_OFFLINE_MODE) ||\n\t    (phba->hba_flag & LINK_DISABLED) ||\n\t    (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO))\n\t\treturn -EPERM;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool,GFP_KERNEL);\n\n\tif (!pmboxq)\n\t\treturn -ENOMEM;\n\n\tmemset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\tpmboxq->u.mb.mbxCommand = MBX_DOWN_LINK;\n\tpmboxq->u.mb.mbxOwner = OWN_HOST;\n\n\tif ((vport->fc_flag & FC_PT2PT) && (vport->fc_flag & FC_PT2PT_NO_NVME))\n\t\tvport->fc_flag &= ~FC_PT2PT_NO_NVME;\n\n\tmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO * 2);\n\n\tif ((mbxstatus == MBX_SUCCESS) &&\n\t    (pmboxq->u.mb.mbxStatus == 0 ||\n\t     pmboxq->u.mb.mbxStatus == MBXERR_LINK_DOWN)) {\n\t\tmemset((void *)pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\t\tlpfc_init_link(phba, pmboxq, phba->cfg_topology,\n\t\t\t       phba->cfg_link_speed);\n\t\tmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq,\n\t\t\t\t\t\t     phba->fc_ratov * 2);\n\t\tif ((mbxstatus == MBX_SUCCESS) &&\n\t\t    (pmboxq->u.mb.mbxStatus == MBXERR_SEC_NO_PERMISSION))\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX | LOG_SLI,\n\t\t\t\t\t\"2859 SLI authentication is required \"\n\t\t\t\t\t\"for INIT_LINK but has not done yet\\n\");\n\t}\n\n\tlpfc_set_loopback_flag(phba);\n\tif (mbxstatus != MBX_TIMEOUT)\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\tif (mbxstatus == MBXERR_ERROR)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint\nlpfc_emptyq_wait(struct lpfc_hba *phba, struct list_head *q, spinlock_t *lock)\n{\n\tint cnt = 0;\n\n\tspin_lock_irq(lock);\n\twhile (!list_empty(q)) {\n\t\tspin_unlock_irq(lock);\n\t\tmsleep(20);\n\t\tif (cnt++ > 250) {   \n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_INIT,\n\t\t\t\t\t\"0466 Outstanding IO when \"\n\t\t\t\t\t\"bringing Adapter offline\\n\");\n\t\t\t\treturn 0;\n\t\t}\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\treturn 1;\n}\n\n \nstatic int\nlpfc_do_offline(struct lpfc_hba *phba, uint32_t type)\n{\n\tstruct completion online_compl;\n\tstruct lpfc_queue *qp = NULL;\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_sli *psli;\n\tint status = 0;\n\tint i;\n\tint rc;\n\n\tinit_completion(&online_compl);\n\trc = lpfc_workq_post_event(phba, &status, &online_compl,\n\t\t\t      LPFC_EVT_OFFLINE_PREP);\n\tif (rc == 0)\n\t\treturn -ENOMEM;\n\n\twait_for_completion(&online_compl);\n\n\tif (status != 0)\n\t\treturn -EIO;\n\n\tpsli = &phba->sli;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tif (!(psli->sli_flag & LPFC_QUEUE_FREE_INIT)) {\n\t\tpsli->sli_flag |= LPFC_QUEUE_FREE_WAIT;\n\t} else {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tgoto skip_wait;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\tfor (i = 0; i < psli->num_rings; i++) {\n\t\t\tpring = &psli->sli3_ring[i];\n\t\t\tif (!lpfc_emptyq_wait(phba, &pring->txcmplq,\n\t\t\t\t\t      &phba->hbalock))\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry(qp, &phba->sli4_hba.lpfc_wq_list, wq_list) {\n\t\t\tpring = qp->pring;\n\t\t\tif (!pring)\n\t\t\t\tcontinue;\n\t\t\tif (!lpfc_emptyq_wait(phba, &pring->txcmplq,\n\t\t\t\t\t      &pring->ring_lock))\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tspin_lock_irq(&phba->hbalock);\n\tpsli->sli_flag &= ~LPFC_QUEUE_FREE_WAIT;\n\tspin_unlock_irq(&phba->hbalock);\n\nskip_wait:\n\tinit_completion(&online_compl);\n\trc = lpfc_workq_post_event(phba, &status, &online_compl, type);\n\tif (rc == 0)\n\t\treturn -ENOMEM;\n\n\twait_for_completion(&online_compl);\n\n\tif (status != 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_reset_pci_bus(struct lpfc_hba *phba)\n{\n\tstruct pci_dev *pdev = phba->pcidev;\n\tstruct Scsi_Host *shost = NULL;\n\tstruct lpfc_hba *phba_other = NULL;\n\tstruct pci_dev *ptr = NULL;\n\tint res;\n\n\tif (phba->cfg_enable_hba_reset != 2)\n\t\treturn -ENOTSUPP;\n\n\tif (!pdev) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT, \"8345 pdev NULL!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = lpfc_check_pci_resettable(phba);\n\tif (res)\n\t\treturn res;\n\n\t \n\tlist_for_each_entry(ptr, &pdev->bus->devices, bus_list) {\n\t\t \n\t\tshost = pci_get_drvdata(ptr);\n\t\tif (shost) {\n\t\t\tphba_other =\n\t\t\t\t((struct lpfc_vport *)shost->hostdata)->phba;\n\t\t\tif (!(phba_other->pport->fc_flag & FC_OFFLINE_MODE)) {\n\t\t\t\tlpfc_printf_log(phba_other, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\t\"8349 WWPN = 0x%02x%02x%02x%02x\"\n\t\t\t\t\t\t\"%02x%02x%02x%02x is not \"\n\t\t\t\t\t\t\"offline!\\n\",\n\t\t\t\t\t\tphba_other->wwpn[0],\n\t\t\t\t\t\tphba_other->wwpn[1],\n\t\t\t\t\t\tphba_other->wwpn[2],\n\t\t\t\t\t\tphba_other->wwpn[3],\n\t\t\t\t\t\tphba_other->wwpn[4],\n\t\t\t\t\t\tphba_other->wwpn[5],\n\t\t\t\t\t\tphba_other->wwpn[6],\n\t\t\t\t\t\tphba_other->wwpn[7]);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tres = pci_reset_bus(pdev);\n\tif (res) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"8350 PCI reset bus failed: %d\\n\", res);\n\t}\n\n\treturn res;\n}\n\n \nint\nlpfc_selective_reset(struct lpfc_hba *phba)\n{\n\tstruct completion online_compl;\n\tint status = 0;\n\tint rc;\n\n\tif (!phba->cfg_enable_hba_reset)\n\t\treturn -EACCES;\n\n\tif (!(phba->pport->fc_flag & FC_OFFLINE_MODE)) {\n\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\n\n\t\tif (status != 0)\n\t\t\treturn status;\n\t}\n\n\tinit_completion(&online_compl);\n\trc = lpfc_workq_post_event(phba, &status, &online_compl,\n\t\t\t      LPFC_EVT_ONLINE);\n\tif (rc == 0)\n\t\treturn -ENOMEM;\n\n\twait_for_completion(&online_compl);\n\n\tif (status != 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic ssize_t\nlpfc_issue_reset(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint status = -EINVAL;\n\n\tif (!phba->cfg_enable_hba_reset)\n\t\treturn -EACCES;\n\n\tif (strncmp(buf, \"selective\", sizeof(\"selective\") - 1) == 0)\n\t\tstatus = phba->lpfc_selective_reset(phba);\n\n\tif (status == 0)\n\t\treturn strlen(buf);\n\telse\n\t\treturn status;\n}\n\n \nint\nlpfc_sli4_pdev_status_reg_wait(struct lpfc_hba *phba)\n{\n\tstruct lpfc_register portstat_reg = {0};\n\tint i;\n\n\tmsleep(100);\n\tif (lpfc_readl(phba->sli4_hba.u.if_type2.STATUSregaddr,\n\t\t       &portstat_reg.word0))\n\t\treturn -EIO;\n\n\t \n\tif (!bf_get(lpfc_sliport_status_rn, &portstat_reg) &&\n\t    !bf_get(lpfc_sliport_status_err, &portstat_reg))\n\t\treturn -EPERM;\n\n\t \n\tif (lpfc_sli4_unrecoverable_port(&portstat_reg))\n\t\treturn -EIO;\n\n\t \n\tfor (i = 0; i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT; i++) {\n\t\tmsleep(10);\n\t\tif (lpfc_readl(phba->sli4_hba.u.if_type2.STATUSregaddr,\n\t\t\t       &portstat_reg.word0))\n\t\t\tcontinue;\n\t\tif (!bf_get(lpfc_sliport_status_err, &portstat_reg))\n\t\t\tcontinue;\n\t\tif (!bf_get(lpfc_sliport_status_rn, &portstat_reg))\n\t\t\tcontinue;\n\t\tif (!bf_get(lpfc_sliport_status_rdy, &portstat_reg))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (i < LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT)\n\t\treturn 0;\n\telse\n\t\treturn -EIO;\n}\n\n \nstatic ssize_t\nlpfc_sli4_pdev_reg_request(struct lpfc_hba *phba, uint32_t opcode)\n{\n\tstruct completion online_compl;\n\tstruct pci_dev *pdev = phba->pcidev;\n\tuint32_t before_fc_flag;\n\tuint32_t sriov_nr_virtfn;\n\tuint32_t reg_val;\n\tint status = 0, rc = 0;\n\tint job_posted = 1, sriov_err;\n\n\tif (!phba->cfg_enable_hba_reset)\n\t\treturn -EACCES;\n\n\tif ((phba->sli_rev < LPFC_SLI_REV4) ||\n\t    (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t     LPFC_SLI_INTF_IF_TYPE_2))\n\t\treturn -EPERM;\n\n\t \n\tbefore_fc_flag = phba->pport->fc_flag;\n\tsriov_nr_virtfn = phba->cfg_sriov_nr_virtfn;\n\n\tif (opcode == LPFC_FW_DUMP) {\n\t\tinit_completion(&online_compl);\n\t\tphba->fw_dump_cmpl = &online_compl;\n\t} else {\n\t\t \n\t\tif (phba->cfg_sriov_nr_virtfn) {\n\t\t\tpci_disable_sriov(pdev);\n\t\t\tphba->cfg_sriov_nr_virtfn = 0;\n\t\t}\n\n\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\n\n\t\tif (status != 0)\n\t\t\treturn status;\n\n\t\t \n\t\tmsleep(100);\n\t}\n\n\treg_val = readl(phba->sli4_hba.conf_regs_memmap_p +\n\t\t\tLPFC_CTL_PDEV_CTL_OFFSET);\n\n\tif (opcode == LPFC_FW_DUMP)\n\t\treg_val |= LPFC_FW_DUMP_REQUEST;\n\telse if (opcode == LPFC_FW_RESET)\n\t\treg_val |= LPFC_CTL_PDEV_CTL_FRST;\n\telse if (opcode == LPFC_DV_RESET)\n\t\treg_val |= LPFC_CTL_PDEV_CTL_DRST;\n\n\twritel(reg_val, phba->sli4_hba.conf_regs_memmap_p +\n\t       LPFC_CTL_PDEV_CTL_OFFSET);\n\t \n\treadl(phba->sli4_hba.conf_regs_memmap_p + LPFC_CTL_PDEV_CTL_OFFSET);\n\n\t \n\trc = lpfc_sli4_pdev_status_reg_wait(phba);\n\n\tif (rc == -EPERM) {\n\t\t \n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\n\t\t\t\t\"3150 No privilege to perform the requested \"\n\t\t\t\t\"access: x%x\\n\", reg_val);\n\t} else if (rc == -EIO) {\n\t\t \n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\n\t\t\t\t\"3153 Fail to perform the requested \"\n\t\t\t\t\"access: x%x\\n\", reg_val);\n\t\tif (phba->fw_dump_cmpl)\n\t\t\tphba->fw_dump_cmpl = NULL;\n\t\treturn rc;\n\t}\n\n\t \n\tif (before_fc_flag & FC_OFFLINE_MODE) {\n\t\tif (phba->fw_dump_cmpl)\n\t\t\tphba->fw_dump_cmpl = NULL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (opcode == LPFC_FW_DUMP) {\n\t\twait_for_completion(phba->fw_dump_cmpl);\n\t} else  {\n\t\tinit_completion(&online_compl);\n\t\tjob_posted = lpfc_workq_post_event(phba, &status, &online_compl,\n\t\t\t\t\t\t   LPFC_EVT_ONLINE);\n\t\tif (!job_posted)\n\t\t\tgoto out;\n\n\t\twait_for_completion(&online_compl);\n\t}\nout:\n\t \n\tif (sriov_nr_virtfn) {\n\t\t \n\t\tif (opcode == LPFC_FW_DUMP) {\n\t\t\tpci_disable_sriov(pdev);\n\t\t\tphba->cfg_sriov_nr_virtfn = 0;\n\t\t}\n\n\t\tsriov_err =\n\t\t\tlpfc_sli_probe_sriov_nr_virtfn(phba, sriov_nr_virtfn);\n\t\tif (!sriov_err)\n\t\t\tphba->cfg_sriov_nr_virtfn = sriov_nr_virtfn;\n\t}\n\n\t \n\tif (!rc) {\n\t\tif (!job_posted)\n\t\t\trc = -ENOMEM;\n\t\telse if (status)\n\t\t\trc = -EIO;\n\t}\n\treturn rc;\n}\n\n \nstatic ssize_t\nlpfc_nport_evt_cnt_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->nport_event_cnt);\n}\n\nstatic int\nlpfc_set_trunking(struct lpfc_hba *phba, char *buff_out)\n{\n\tLPFC_MBOXQ_t *mbox = NULL;\n\tunsigned long val = 0;\n\tchar *pval = NULL;\n\tint rc = 0;\n\n\tif (!strncmp(\"enable\", buff_out,\n\t\t\t\t strlen(\"enable\"))) {\n\t\tpval = buff_out + strlen(\"enable\") + 1;\n\t\trc = kstrtoul(pval, 0, &val);\n\t\tif (rc)\n\t\t\treturn rc;  \n\t} else if (!strncmp(\"disable\", buff_out,\n\t\t\t\t strlen(\"disable\"))) {\n\t\tval = 0;\n\t} else {\n\t\treturn -EINVAL;   \n\t}\n\n\tswitch (val) {\n\tcase 0:\n\t\tval = 0x0;  \n\t\tbreak;\n\tcase 2:\n\t\tval = 0x1;  \n\t\tbreak;\n\tcase 4:\n\t\tval = 0x2;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\n\t\t\t\"0070 Set trunk mode with val %ld \", val);\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\tlpfc_sli4_config(phba, mbox, LPFC_MBOX_SUBSYSTEM_FCOE,\n\t\t\t LPFC_MBOX_OPCODE_FCOE_FC_SET_TRUNK_MODE,\n\t\t\t 12, LPFC_SLI4_MBX_EMBED);\n\n\tbf_set(lpfc_mbx_set_trunk_mode,\n\t       &mbox->u.mqe.un.set_trunk_mode,\n\t       val);\n\trc = lpfc_sli_issue_mbox(phba, mbox, MBX_POLL);\n\tif (rc)\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_MBOX,\n\t\t\t\t\"0071 Set trunk mode failed with status: %d\",\n\t\t\t\trc);\n\tmempool_free(mbox, phba->mbox_mem_pool);\n\n\treturn 0;\n}\n\nstatic ssize_t\nlpfc_xcvr_data_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint rc;\n\tint len = 0;\n\tstruct lpfc_rdp_context\t*rdp_context;\n\tu16 temperature;\n\tu16 rx_power;\n\tu16 tx_bias;\n\tu16 tx_power;\n\tu16 vcc;\n\tchar chbuf[128];\n\tu16 wavelength = 0;\n\tstruct sff_trasnceiver_codes_byte7 *trasn_code_byte7;\n\n\t \n\trdp_context = kmalloc(sizeof(*rdp_context), GFP_KERNEL);\n\n\trc = lpfc_get_sfp_info_wait(phba, rdp_context);\n\tif (rc) {\n\t\tlen = scnprintf(buf, PAGE_SIZE - len, \"SFP info NA:\\n\");\n\t\tgoto out_free_rdp;\n\t}\n\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_VENDOR_NAME], 16);\n\n\tlen = scnprintf(buf, PAGE_SIZE - len, \"VendorName:\\t%s\\n\", chbuf);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t \"VendorOUI:\\t%02x-%02x-%02x\\n\",\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_VENDOR_OUI],\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_VENDOR_OUI + 1],\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_VENDOR_OUI + 2]);\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_VENDOR_PN], 16);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"VendorPN:\\t%s\\n\", chbuf);\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_VENDOR_SN], 16);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"VendorSN:\\t%s\\n\", chbuf);\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_VENDOR_REV], 4);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"VendorRev:\\t%s\\n\", chbuf);\n\tstrscpy(chbuf, &rdp_context->page_a0[SSF_DATE_CODE], 8);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"DateCode:\\t%s\\n\", chbuf);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Identifier:\\t%xh\\n\",\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_IDENTIFIER]);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"ExtIdentifier:\\t%xh\\n\",\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_EXT_IDENTIFIER]);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Connector:\\t%xh\\n\",\n\t\t\t (uint8_t)rdp_context->page_a0[SSF_CONNECTOR]);\n\twavelength = (rdp_context->page_a0[SSF_WAVELENGTH_B1] << 8) |\n\t\t      rdp_context->page_a0[SSF_WAVELENGTH_B0];\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Wavelength:\\t%d nm\\n\",\n\t\t\t wavelength);\n\ttrasn_code_byte7 = (struct sff_trasnceiver_codes_byte7 *)\n\t\t\t&rdp_context->page_a0[SSF_TRANSCEIVER_CODE_B7];\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Speeds: \\t\");\n\tif (*(uint8_t *)trasn_code_byte7 == 0) {\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Unknown\\n\");\n\t} else {\n\t\tif (trasn_code_byte7->fc_sp_100MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"1 \");\n\t\tif (trasn_code_byte7->fc_sp_200mb)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"2 \");\n\t\tif (trasn_code_byte7->fc_sp_400MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"4 \");\n\t\tif (trasn_code_byte7->fc_sp_800MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"8 \");\n\t\tif (trasn_code_byte7->fc_sp_1600MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"16 \");\n\t\tif (trasn_code_byte7->fc_sp_3200MB)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"32 \");\n\t\tif (trasn_code_byte7->speed_chk_ecc)\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"64 \");\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"GB\\n\");\n\t}\n\ttemperature = (rdp_context->page_a2[SFF_TEMPERATURE_B1] << 8 |\n\t\t       rdp_context->page_a2[SFF_TEMPERATURE_B0]);\n\tvcc = (rdp_context->page_a2[SFF_VCC_B1] << 8 |\n\t       rdp_context->page_a2[SFF_VCC_B0]);\n\ttx_power = (rdp_context->page_a2[SFF_TXPOWER_B1] << 8 |\n\t\t    rdp_context->page_a2[SFF_TXPOWER_B0]);\n\ttx_bias = (rdp_context->page_a2[SFF_TX_BIAS_CURRENT_B1] << 8 |\n\t\t   rdp_context->page_a2[SFF_TX_BIAS_CURRENT_B0]);\n\trx_power = (rdp_context->page_a2[SFF_RXPOWER_B1] << 8 |\n\t\t    rdp_context->page_a2[SFF_RXPOWER_B0]);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t \"Temperature:\\tx%04x C\\n\", temperature);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"Vcc:\\t\\tx%04x V\\n\", vcc);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t \"TxBiasCurrent:\\tx%04x mA\\n\", tx_bias);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"TxPower:\\tx%04x mW\\n\",\n\t\t\t tx_power);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"RxPower:\\tx%04x mW\\n\",\n\t\t\t rx_power);\nout_free_rdp:\n\tkfree(rdp_context);\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_board_mode_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tchar  * state;\n\n\tif (phba->link_state == LPFC_HBA_ERROR)\n\t\tstate = \"error\";\n\telse if (phba->link_state == LPFC_WARM_START)\n\t\tstate = \"warm start\";\n\telse if (phba->link_state == LPFC_INIT_START)\n\t\tstate = \"offline\";\n\telse\n\t\tstate = \"online\";\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}\n\n \nstatic ssize_t\nlpfc_board_mode_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct completion online_compl;\n\tchar *board_mode_str = NULL;\n\tint status = 0;\n\tint rc;\n\n\tif (!phba->cfg_enable_hba_reset) {\n\t\tstatus = -EACCES;\n\t\tgoto board_mode_out;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t \"3050 lpfc_board_mode set to %s\\n\", buf);\n\n\tinit_completion(&online_compl);\n\n\tif(strncmp(buf, \"online\", sizeof(\"online\") - 1) == 0) {\n\t\trc = lpfc_workq_post_event(phba, &status, &online_compl,\n\t\t\t\t      LPFC_EVT_ONLINE);\n\t\tif (rc == 0) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto board_mode_out;\n\t\t}\n\t\twait_for_completion(&online_compl);\n\t\tif (status)\n\t\t\tstatus = -EIO;\n\t} else if (strncmp(buf, \"offline\", sizeof(\"offline\") - 1) == 0)\n\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_OFFLINE);\n\telse if (strncmp(buf, \"warm\", sizeof(\"warm\") - 1) == 0)\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tstatus = -EINVAL;\n\t\telse\n\t\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_WARM_START);\n\telse if (strncmp(buf, \"error\", sizeof(\"error\") - 1) == 0)\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tstatus = -EINVAL;\n\t\telse\n\t\t\tstatus = lpfc_do_offline(phba, LPFC_EVT_KILL);\n\telse if (strncmp(buf, \"dump\", sizeof(\"dump\") - 1) == 0)\n\t\tstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_FW_DUMP);\n\telse if (strncmp(buf, \"fw_reset\", sizeof(\"fw_reset\") - 1) == 0)\n\t\tstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_FW_RESET);\n\telse if (strncmp(buf, \"dv_reset\", sizeof(\"dv_reset\") - 1) == 0)\n\t\tstatus = lpfc_sli4_pdev_reg_request(phba, LPFC_DV_RESET);\n\telse if (strncmp(buf, \"pci_bus_reset\", sizeof(\"pci_bus_reset\") - 1)\n\t\t == 0)\n\t\tstatus = lpfc_reset_pci_bus(phba);\n\telse if (strncmp(buf, \"heartbeat\", sizeof(\"heartbeat\") - 1) == 0)\n\t\tlpfc_issue_hb_tmo(phba);\n\telse if (strncmp(buf, \"trunk\", sizeof(\"trunk\") - 1) == 0)\n\t\tstatus = lpfc_set_trunking(phba, (char *)buf + sizeof(\"trunk\"));\n\telse\n\t\tstatus = -EINVAL;\n\nboard_mode_out:\n\tif (!status)\n\t\treturn strlen(buf);\n\telse {\n\t\tboard_mode_str = strchr(buf, '\\n');\n\t\tif (board_mode_str)\n\t\t\t*board_mode_str = '\\0';\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"3097 Failed \\\"%s\\\", status(%d), \"\n\t\t\t\t \"fc_flag(x%x)\\n\",\n\t\t\t\t buf, status, phba->pport->fc_flag);\n\t\treturn status;\n\t}\n}\n\n \nstatic int\nlpfc_get_hba_info(struct lpfc_hba *phba,\n\t\t  uint32_t *mxri, uint32_t *axri,\n\t\t  uint32_t *mrpi, uint32_t *arpi,\n\t\t  uint32_t *mvpi, uint32_t *avpi)\n{\n\tLPFC_MBOXQ_t *pmboxq;\n\tMAILBOX_t *pmb;\n\tint rc = 0;\n\tstruct lpfc_sli4_hba *sli4_hba;\n\tstruct lpfc_max_cfg_param *max_cfg_param;\n\tu16 rsrc_ext_cnt, rsrc_ext_size, max_vpi;\n\n\t \n\tif (phba->link_state < LPFC_LINK_DOWN ||\n\t    !phba->mbox_mem_pool ||\n\t    (phba->sli.sli_flag & LPFC_SLI_ACTIVE) == 0)\n\t\treturn 0;\n\n\tif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\n\t\treturn 0;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq)\n\t\treturn 0;\n\tmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\n\tpmb = &pmboxq->u.mb;\n\tpmb->mbxCommand = MBX_READ_CONFIG;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->ctx_buf = NULL;\n\n\tif (phba->pport->fc_flag & FC_OFFLINE_MODE)\n\t\trc = MBX_NOT_FINISHED;\n\telse\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\n\tif (rc != MBX_SUCCESS) {\n\t\tif (rc != MBX_TIMEOUT)\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\treturn 0;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tsli4_hba = &phba->sli4_hba;\n\t\tmax_cfg_param = &sli4_hba->max_cfg_param;\n\n\t\t \n\t\tif (!phba->sli4_hba.extents_in_use) {\n\t\t\tif (mrpi)\n\t\t\t\t*mrpi = max_cfg_param->max_rpi;\n\t\t\tif (mxri)\n\t\t\t\t*mxri = max_cfg_param->max_xri;\n\t\t\tif (mvpi) {\n\t\t\t\tmax_vpi = max_cfg_param->max_vpi;\n\n\t\t\t\t \n\t\t\t\tif (max_vpi > LPFC_MAX_VPI)\n\t\t\t\t\tmax_vpi = LPFC_MAX_VPI;\n\t\t\t\t*mvpi = max_vpi;\n\t\t\t}\n\t\t} else {  \n\t\t\tif (mrpi) {\n\t\t\t\tif (lpfc_sli4_get_avail_extnt_rsrc(phba,\n\t\t\t\t\t\t\t\t   LPFC_RSC_TYPE_FCOE_RPI,\n\t\t\t\t\t\t\t\t   &rsrc_ext_cnt,\n\t\t\t\t\t\t\t\t   &rsrc_ext_size)) {\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto free_pmboxq;\n\t\t\t\t}\n\n\t\t\t\t*mrpi = rsrc_ext_cnt * rsrc_ext_size;\n\t\t\t}\n\n\t\t\tif (mxri) {\n\t\t\t\tif (lpfc_sli4_get_avail_extnt_rsrc(phba,\n\t\t\t\t\t\t\t\t   LPFC_RSC_TYPE_FCOE_XRI,\n\t\t\t\t\t\t\t\t   &rsrc_ext_cnt,\n\t\t\t\t\t\t\t\t   &rsrc_ext_size)) {\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto free_pmboxq;\n\t\t\t\t}\n\n\t\t\t\t*mxri = rsrc_ext_cnt * rsrc_ext_size;\n\t\t\t}\n\n\t\t\tif (mvpi) {\n\t\t\t\tif (lpfc_sli4_get_avail_extnt_rsrc(phba,\n\t\t\t\t\t\t\t\t   LPFC_RSC_TYPE_FCOE_VPI,\n\t\t\t\t\t\t\t\t   &rsrc_ext_cnt,\n\t\t\t\t\t\t\t\t   &rsrc_ext_size)) {\n\t\t\t\t\trc = 0;\n\t\t\t\t\tgoto free_pmboxq;\n\t\t\t\t}\n\n\t\t\t\tmax_vpi = rsrc_ext_cnt * rsrc_ext_size;\n\n\t\t\t\t \n\t\t\t\tif (max_vpi > LPFC_MAX_VPI)\n\t\t\t\t\tmax_vpi = LPFC_MAX_VPI;\n\t\t\t\t*mvpi = max_vpi;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (mrpi)\n\t\t\t*mrpi = pmb->un.varRdConfig.max_rpi;\n\t\tif (arpi)\n\t\t\t*arpi = pmb->un.varRdConfig.avail_rpi;\n\t\tif (mxri)\n\t\t\t*mxri = pmb->un.varRdConfig.max_xri;\n\t\tif (axri)\n\t\t\t*axri = pmb->un.varRdConfig.avail_xri;\n\t\tif (mvpi)\n\t\t\t*mvpi = pmb->un.varRdConfig.max_vpi;\n\t\tif (avpi) {\n\t\t\t \n\t\t\tif (phba->link_state == LPFC_HBA_READY)\n\t\t\t\t*avpi = pmb->un.varRdConfig.avail_vpi;\n\t\t\telse\n\t\t\t\t*avpi = pmb->un.varRdConfig.max_vpi;\n\t\t}\n\t}\n\n\t \n\trc = 1;\n\nfree_pmboxq:\n\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\treturn rc;\n}\n\n \nstatic ssize_t\nlpfc_max_rpi_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt;\n\n\tif (lpfc_get_hba_info(phba, NULL, NULL, &cnt, NULL, NULL, NULL))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", cnt);\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n \nstatic ssize_t\nlpfc_used_rpi_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_sli4_hba *sli4_hba;\n\tstruct lpfc_max_cfg_param *max_cfg_param;\n\tu32 cnt = 0, acnt = 0;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tsli4_hba = &phba->sli4_hba;\n\t\tmax_cfg_param = &sli4_hba->max_cfg_param;\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t\t max_cfg_param->rpi_used);\n\t} else {\n\t\tif (lpfc_get_hba_info(phba, NULL, NULL, &cnt, &acnt, NULL, NULL))\n\t\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (cnt - acnt));\n\t}\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n \nstatic ssize_t\nlpfc_max_xri_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt;\n\n\tif (lpfc_get_hba_info(phba, &cnt, NULL, NULL, NULL, NULL, NULL))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", cnt);\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n \nstatic ssize_t\nlpfc_used_xri_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_sli4_hba *sli4_hba;\n\tstruct lpfc_max_cfg_param *max_cfg_param;\n\tu32 cnt = 0, acnt = 0;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tsli4_hba = &phba->sli4_hba;\n\t\tmax_cfg_param = &sli4_hba->max_cfg_param;\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t\t max_cfg_param->xri_used);\n\t} else {\n\t\tif (lpfc_get_hba_info(phba, &cnt, &acnt, NULL, NULL, NULL, NULL))\n\t\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (cnt - acnt));\n\t}\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n \nstatic ssize_t\nlpfc_max_vpi_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t cnt;\n\n\tif (lpfc_get_hba_info(phba, NULL, NULL, NULL, NULL, &cnt, NULL))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", cnt);\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n \nstatic ssize_t\nlpfc_used_vpi_show(struct device *dev, struct device_attribute *attr,\n\t\t   char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_sli4_hba *sli4_hba;\n\tstruct lpfc_max_cfg_param *max_cfg_param;\n\tu32 cnt = 0, acnt = 0;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tsli4_hba = &phba->sli4_hba;\n\t\tmax_cfg_param = &sli4_hba->max_cfg_param;\n\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t\t max_cfg_param->vpi_used);\n\t} else {\n\t\tif (lpfc_get_hba_info(phba, NULL, NULL, NULL, NULL, &cnt, &acnt))\n\t\t\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", (cnt - acnt));\n\t}\n\treturn scnprintf(buf, PAGE_SIZE, \"Unknown\\n\");\n}\n\n \nstatic ssize_t\nlpfc_npiv_info_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (!(phba->max_vpi))\n\t\treturn scnprintf(buf, PAGE_SIZE, \"NPIV Not Supported\\n\");\n\tif (vport->port_type == LPFC_PHYSICAL_PORT)\n\t\treturn scnprintf(buf, PAGE_SIZE, \"NPIV Physical\\n\");\n\treturn scnprintf(buf, PAGE_SIZE, \"NPIV Virtual (VPI %d)\\n\", vport->vpi);\n}\n\n \nstatic ssize_t\nlpfc_poll_show(struct device *dev, struct device_attribute *attr,\n\t       char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%#x\\n\", phba->cfg_poll);\n}\n\n \nstatic ssize_t\nlpfc_poll_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tuint32_t creg_val;\n\tuint32_t old_val;\n\tint val=0;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif ((val & 0x3) != val)\n\t\treturn -EINVAL;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tval = 0;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\"3051 lpfc_poll changed from %d to %d\\n\",\n\t\tphba->cfg_poll, val);\n\n\tspin_lock_irq(&phba->hbalock);\n\n\told_val = phba->cfg_poll;\n\n\tif (val & ENABLE_FCP_RING_POLLING) {\n\t\tif ((val & DISABLE_FCP_RING_INT) &&\n\t\t    !(old_val & DISABLE_FCP_RING_INT)) {\n\t\t\tif (lpfc_readl(phba->HCregaddr, &creg_val)) {\n\t\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcreg_val &= ~(HC_R0INT_ENA << LPFC_FCP_RING);\n\t\t\twritel(creg_val, phba->HCregaddr);\n\t\t\treadl(phba->HCregaddr);  \n\n\t\t\tlpfc_poll_start_timer(phba);\n\t\t}\n\t} else if (val != 0x0) {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(val & DISABLE_FCP_RING_INT) &&\n\t    (old_val & DISABLE_FCP_RING_INT))\n\t{\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\tdel_timer(&phba->fcp_poll_timer);\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tif (lpfc_readl(phba->HCregaddr, &creg_val)) {\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\n\t\twritel(creg_val, phba->HCregaddr);\n\t\treadl(phba->HCregaddr);  \n\t}\n\n\tphba->cfg_poll = val;\n\n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t\nlpfc_sriov_hw_max_virtfn_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tuint16_t max_nr_virtfn;\n\n\tmax_nr_virtfn = lpfc_sli_sriov_nr_virtfn_get(phba);\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", max_nr_virtfn);\n}\n\n \nstatic ssize_t\nlpfc_enable_bbcr_set(struct lpfc_hba *phba, uint val)\n{\n\tif (lpfc_rangecheck(val, 0, 1) && phba->sli_rev == LPFC_SLI_REV4) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3068 lpfc_enable_bbcr changed from %d to \"\n\t\t\t\t\"%d\\n\", phba->cfg_enable_bbcr, val);\n\t\tphba->cfg_enable_bbcr = val;\n\t\treturn 0;\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"0451 lpfc_enable_bbcr cannot set to %d, range is 0, \"\n\t\t\t\"1\\n\", val);\n\treturn -EINVAL;\n}\n\n \n#define lpfc_param_show(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t   char *buf) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\tstruct lpfc_hba   *phba = vport->phba;\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\\\n\t\t\tphba->cfg_##attr);\\\n}\n\n \n#define lpfc_param_hex_show(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t   char *buf) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\tstruct lpfc_hba   *phba = vport->phba;\\\n\tuint val = 0;\\\n\tval = phba->cfg_##attr;\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%#x\\n\",\\\n\t\t\tphba->cfg_##attr);\\\n}\n\n \n#define lpfc_param_init(attr, default, minval, maxval)\t\\\nstatic int \\\nlpfc_##attr##_init(struct lpfc_hba *phba, uint val) \\\n{ \\\n\tif (lpfc_rangecheck(val, minval, maxval)) {\\\n\t\tphba->cfg_##attr = val;\\\n\t\treturn 0;\\\n\t}\\\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT, \\\n\t\t\t\"0449 lpfc_\"#attr\" attribute cannot be set to %d, \"\\\n\t\t\t\"allowed range is [\"#minval\", \"#maxval\"]\\n\", val); \\\n\tphba->cfg_##attr = default;\\\n\treturn -EINVAL;\\\n}\n\n \n#define lpfc_param_set(attr, default, minval, maxval)\t\\\nstatic int \\\nlpfc_##attr##_set(struct lpfc_hba *phba, uint val) \\\n{ \\\n\tif (lpfc_rangecheck(val, minval, maxval)) {\\\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT, \\\n\t\t\t\"3052 lpfc_\" #attr \" changed from %d to %d\\n\", \\\n\t\t\tphba->cfg_##attr, val); \\\n\t\tphba->cfg_##attr = val;\\\n\t\treturn 0;\\\n\t}\\\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT, \\\n\t\t\t\"0450 lpfc_\"#attr\" attribute cannot be set to %d, \"\\\n\t\t\t\"allowed range is [\"#minval\", \"#maxval\"]\\n\", val); \\\n\treturn -EINVAL;\\\n}\n\n \n#define lpfc_param_store(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_store(struct device *dev, struct device_attribute *attr, \\\n\t\t    const char *buf, size_t count) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\tstruct lpfc_hba   *phba = vport->phba;\\\n\tuint val = 0;\\\n\tif (!isdigit(buf[0]))\\\n\t\treturn -EINVAL;\\\n\tif (sscanf(buf, \"%i\", &val) != 1)\\\n\t\treturn -EINVAL;\\\n\tif (lpfc_##attr##_set(phba, val) == 0) \\\n\t\treturn strlen(buf);\\\n\telse \\\n\t\treturn -EINVAL;\\\n}\n\n \n#define lpfc_vport_param_show(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t   char *buf) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", vport->cfg_##attr);\\\n}\n\n \n#define lpfc_vport_param_hex_show(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t   char *buf) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%#x\\n\", vport->cfg_##attr);\\\n}\n\n \n#define lpfc_vport_param_init(attr, default, minval, maxval)\t\\\nstatic int \\\nlpfc_##attr##_init(struct lpfc_vport *vport, uint val) \\\n{ \\\n\tif (lpfc_rangecheck(val, minval, maxval)) {\\\n\t\tvport->cfg_##attr = val;\\\n\t\treturn 0;\\\n\t}\\\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \\\n\t\t\t \"0423 lpfc_\"#attr\" attribute cannot be set to %d, \"\\\n\t\t\t \"allowed range is [\"#minval\", \"#maxval\"]\\n\", val); \\\n\tvport->cfg_##attr = default;\\\n\treturn -EINVAL;\\\n}\n\n \n#define lpfc_vport_param_set(attr, default, minval, maxval)\t\\\nstatic int \\\nlpfc_##attr##_set(struct lpfc_vport *vport, uint val) \\\n{ \\\n\tif (lpfc_rangecheck(val, minval, maxval)) {\\\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \\\n\t\t\t\"3053 lpfc_\" #attr \\\n\t\t\t\" changed from %d (x%x) to %d (x%x)\\n\", \\\n\t\t\tvport->cfg_##attr, vport->cfg_##attr, \\\n\t\t\tval, val); \\\n\t\tvport->cfg_##attr = val;\\\n\t\treturn 0;\\\n\t}\\\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \\\n\t\t\t \"0424 lpfc_\"#attr\" attribute cannot be set to %d, \"\\\n\t\t\t \"allowed range is [\"#minval\", \"#maxval\"]\\n\", val); \\\n\treturn -EINVAL;\\\n}\n\n \n#define lpfc_vport_param_store(attr)\t\\\nstatic ssize_t \\\nlpfc_##attr##_store(struct device *dev, struct device_attribute *attr, \\\n\t\t    const char *buf, size_t count) \\\n{ \\\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\\\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\\\n\tuint val = 0;\\\n\tif (!isdigit(buf[0]))\\\n\t\treturn -EINVAL;\\\n\tif (sscanf(buf, \"%i\", &val) != 1)\\\n\t\treturn -EINVAL;\\\n\tif (lpfc_##attr##_set(vport, val) == 0) \\\n\t\treturn strlen(buf);\\\n\telse \\\n\t\treturn -EINVAL;\\\n}\n\n\nstatic DEVICE_ATTR(nvme_info, 0444, lpfc_nvme_info_show, NULL);\nstatic DEVICE_ATTR(scsi_stat, 0444, lpfc_scsi_stat_show, NULL);\nstatic DEVICE_ATTR(bg_info, S_IRUGO, lpfc_bg_info_show, NULL);\nstatic DEVICE_ATTR(bg_guard_err, S_IRUGO, lpfc_bg_guard_err_show, NULL);\nstatic DEVICE_ATTR(bg_apptag_err, S_IRUGO, lpfc_bg_apptag_err_show, NULL);\nstatic DEVICE_ATTR(bg_reftag_err, S_IRUGO, lpfc_bg_reftag_err_show, NULL);\nstatic DEVICE_ATTR(info, S_IRUGO, lpfc_info_show, NULL);\nstatic DEVICE_ATTR(serialnum, S_IRUGO, lpfc_serialnum_show, NULL);\nstatic DEVICE_ATTR(modeldesc, S_IRUGO, lpfc_modeldesc_show, NULL);\nstatic DEVICE_ATTR(modelname, S_IRUGO, lpfc_modelname_show, NULL);\nstatic DEVICE_ATTR(programtype, S_IRUGO, lpfc_programtype_show, NULL);\nstatic DEVICE_ATTR(portnum, S_IRUGO, lpfc_vportnum_show, NULL);\nstatic DEVICE_ATTR(fwrev, S_IRUGO, lpfc_fwrev_show, NULL);\nstatic DEVICE_ATTR(hdw, S_IRUGO, lpfc_hdw_show, NULL);\nstatic DEVICE_ATTR(link_state, S_IRUGO | S_IWUSR, lpfc_link_state_show,\n\t\tlpfc_link_state_store);\nstatic DEVICE_ATTR(option_rom_version, S_IRUGO,\n\t\t   lpfc_option_rom_version_show, NULL);\nstatic DEVICE_ATTR(num_discovered_ports, S_IRUGO,\n\t\t   lpfc_num_discovered_ports_show, NULL);\nstatic DEVICE_ATTR(nport_evt_cnt, S_IRUGO, lpfc_nport_evt_cnt_show, NULL);\nstatic DEVICE_ATTR_RO(lpfc_drvr_version);\nstatic DEVICE_ATTR_RO(lpfc_enable_fip);\nstatic DEVICE_ATTR(board_mode, S_IRUGO | S_IWUSR,\n\t\t   lpfc_board_mode_show, lpfc_board_mode_store);\nstatic DEVICE_ATTR_RO(lpfc_xcvr_data);\nstatic DEVICE_ATTR(issue_reset, S_IWUSR, NULL, lpfc_issue_reset);\nstatic DEVICE_ATTR(max_vpi, S_IRUGO, lpfc_max_vpi_show, NULL);\nstatic DEVICE_ATTR(used_vpi, S_IRUGO, lpfc_used_vpi_show, NULL);\nstatic DEVICE_ATTR(max_rpi, S_IRUGO, lpfc_max_rpi_show, NULL);\nstatic DEVICE_ATTR(used_rpi, S_IRUGO, lpfc_used_rpi_show, NULL);\nstatic DEVICE_ATTR(max_xri, S_IRUGO, lpfc_max_xri_show, NULL);\nstatic DEVICE_ATTR(used_xri, S_IRUGO, lpfc_used_xri_show, NULL);\nstatic DEVICE_ATTR(npiv_info, S_IRUGO, lpfc_npiv_info_show, NULL);\nstatic DEVICE_ATTR_RO(lpfc_temp_sensor);\nstatic DEVICE_ATTR_RO(lpfc_sriov_hw_max_virtfn);\nstatic DEVICE_ATTR(protocol, S_IRUGO, lpfc_sli4_protocol_show, NULL);\nstatic DEVICE_ATTR(lpfc_xlane_supported, S_IRUGO, lpfc_oas_supported_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(cmf_info, 0444, lpfc_cmf_info_show, NULL);\n\n#define WWN_SZ 8\n \nstatic size_t\nlpfc_wwn_set(const char *buf, size_t cnt, char wwn[])\n{\n\tunsigned int i, j;\n\n\t \n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\tif ((cnt < 16) || (cnt > 18) || ((cnt == 17) && (*buf++ != 'x')) ||\n\t    ((cnt == 18) && ((*buf++ != '0') || (*buf++ != 'x'))))\n\t\treturn -EINVAL;\n\n\tmemset(wwn, 0, WWN_SZ);\n\n\t \n\tfor (i = 0, j = 0; i < 16; i++) {\n\t\tif ((*buf >= 'a') && (*buf <= 'f'))\n\t\t\tj = ((j << 4) | ((*buf++ - 'a') + 10));\n\t\telse if ((*buf >= 'A') && (*buf <= 'F'))\n\t\t\tj = ((j << 4) | ((*buf++ - 'A') + 10));\n\t\telse if ((*buf >= '0') && (*buf <= '9'))\n\t\t\tj = ((j << 4) | (*buf++ - '0'));\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tif (i % 2) {\n\t\t\twwn[i/2] = j & 0xff;\n\t\t\tj = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \nstatic ssize_t\nlpfc_oas_tgt_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%llx\\n\",\n\t\t\twwn_to_u64(phba->cfg_oas_tgt_wwpn));\n}\n\n \nstatic ssize_t\nlpfc_oas_tgt_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tunsigned int cnt = count;\n\tuint8_t wwpn[WWN_SZ];\n\tint rc;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\t \n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\trc = lpfc_wwn_set(buf, cnt, wwpn);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(phba->cfg_oas_tgt_wwpn, wwpn, (8 * sizeof(uint8_t)));\n\tmemcpy(phba->sli4_hba.oas_next_tgt_wwpn, wwpn, (8 * sizeof(uint8_t)));\n\tif (wwn_to_u64(wwpn) == 0)\n\t\tphba->cfg_oas_flags |= OAS_FIND_ANY_TARGET;\n\telse\n\t\tphba->cfg_oas_flags &= ~OAS_FIND_ANY_TARGET;\n\tphba->cfg_oas_flags &= ~OAS_LUN_VALID;\n\tphba->sli4_hba.oas_next_lun = FIND_FIRST_OAS_LUN;\n\treturn count;\n}\nstatic DEVICE_ATTR(lpfc_xlane_tgt, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_tgt_show, lpfc_oas_tgt_store);\n\n \nstatic ssize_t\nlpfc_oas_priority_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->cfg_oas_priority);\n}\n\n \nstatic ssize_t\nlpfc_oas_priority_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tunsigned int cnt = count;\n\tunsigned long val;\n\tint ret;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\t \n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret || (val > 0x7f))\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\tphba->cfg_oas_priority = (uint8_t)val;\n\telse\n\t\tphba->cfg_oas_priority = phba->cfg_XLanePriority;\n\treturn count;\n}\nstatic DEVICE_ATTR(lpfc_xlane_priority, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_priority_show, lpfc_oas_priority_store);\n\n \nstatic ssize_t\nlpfc_oas_vpt_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"0x%llx\\n\",\n\t\t\twwn_to_u64(phba->cfg_oas_vpt_wwpn));\n}\n\n \nstatic ssize_t\nlpfc_oas_vpt_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tunsigned int cnt = count;\n\tuint8_t wwpn[WWN_SZ];\n\tint rc;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\t \n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\n\trc = lpfc_wwn_set(buf, cnt, wwpn);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(phba->cfg_oas_vpt_wwpn, wwpn, (8 * sizeof(uint8_t)));\n\tmemcpy(phba->sli4_hba.oas_next_vpt_wwpn, wwpn, (8 * sizeof(uint8_t)));\n\tif (wwn_to_u64(wwpn) == 0)\n\t\tphba->cfg_oas_flags |= OAS_FIND_ANY_VPORT;\n\telse\n\t\tphba->cfg_oas_flags &= ~OAS_FIND_ANY_VPORT;\n\tphba->cfg_oas_flags &= ~OAS_LUN_VALID;\n\tif (phba->cfg_oas_priority == 0)\n\t\tphba->cfg_oas_priority = phba->cfg_XLanePriority;\n\tphba->sli4_hba.oas_next_lun = FIND_FIRST_OAS_LUN;\n\treturn count;\n}\nstatic DEVICE_ATTR(lpfc_xlane_vpt, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_vpt_show, lpfc_oas_vpt_store);\n\n \nstatic ssize_t\nlpfc_oas_lun_state_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->cfg_oas_lun_state);\n}\n\n \nstatic ssize_t\nlpfc_oas_lun_state_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tint val = 0;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif ((val != 0) && (val != 1))\n\t\treturn -EINVAL;\n\n\tphba->cfg_oas_lun_state = val;\n\treturn strlen(buf);\n}\nstatic DEVICE_ATTR(lpfc_xlane_lun_state, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_lun_state_show, lpfc_oas_lun_state_store);\n\n \nstatic ssize_t\nlpfc_oas_lun_status_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\tif (!(phba->cfg_oas_flags & OAS_LUN_VALID))\n\t\treturn -EFAULT;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->cfg_oas_lun_status);\n}\nstatic DEVICE_ATTR(lpfc_xlane_lun_status, S_IRUGO,\n\t\t   lpfc_oas_lun_status_show, NULL);\n\n\n \nstatic size_t\nlpfc_oas_lun_state_set(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\n\t\t       uint8_t tgt_wwpn[], uint64_t lun,\n\t\t       uint32_t oas_state, uint8_t pri)\n{\n\n\tint rc = 0;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\tif (oas_state) {\n\t\tif (!lpfc_enable_oas_lun(phba, (struct lpfc_name *)vpt_wwpn,\n\t\t\t\t\t (struct lpfc_name *)tgt_wwpn,\n\t\t\t\t\t lun, pri))\n\t\t\trc = -ENOMEM;\n\t} else {\n\t\tlpfc_disable_oas_lun(phba, (struct lpfc_name *)vpt_wwpn,\n\t\t\t\t     (struct lpfc_name *)tgt_wwpn, lun, pri);\n\t}\n\treturn rc;\n\n}\n\n \nstatic uint64_t\nlpfc_oas_lun_get_next(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\n\t\t      uint8_t tgt_wwpn[], uint32_t *lun_status,\n\t\t      uint32_t *lun_pri)\n{\n\tuint64_t found_lun;\n\n\tif (unlikely(!phba) || !vpt_wwpn || !tgt_wwpn)\n\t\treturn NOT_OAS_ENABLED_LUN;\n\tif (lpfc_find_next_oas_lun(phba, (struct lpfc_name *)\n\t\t\t\t   phba->sli4_hba.oas_next_vpt_wwpn,\n\t\t\t\t   (struct lpfc_name *)\n\t\t\t\t   phba->sli4_hba.oas_next_tgt_wwpn,\n\t\t\t\t   &phba->sli4_hba.oas_next_lun,\n\t\t\t\t   (struct lpfc_name *)vpt_wwpn,\n\t\t\t\t   (struct lpfc_name *)tgt_wwpn,\n\t\t\t\t   &found_lun, lun_status, lun_pri))\n\t\treturn found_lun;\n\telse\n\t\treturn NOT_OAS_ENABLED_LUN;\n}\n\n \nstatic ssize_t\nlpfc_oas_lun_state_change(struct lpfc_hba *phba, uint8_t vpt_wwpn[],\n\t\t\t  uint8_t tgt_wwpn[], uint64_t lun,\n\t\t\t  uint32_t oas_state, uint8_t pri)\n{\n\n\tint rc;\n\n\trc = lpfc_oas_lun_state_set(phba, vpt_wwpn, tgt_wwpn, lun,\n\t\t\t\t    oas_state, pri);\n\treturn rc;\n}\n\n \nstatic ssize_t\nlpfc_oas_lun_show(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\tuint64_t oas_lun;\n\tint len = 0;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\tif (wwn_to_u64(phba->cfg_oas_vpt_wwpn) == 0)\n\t\tif (!(phba->cfg_oas_flags & OAS_FIND_ANY_VPORT))\n\t\t\treturn -EFAULT;\n\n\tif (wwn_to_u64(phba->cfg_oas_tgt_wwpn) == 0)\n\t\tif (!(phba->cfg_oas_flags & OAS_FIND_ANY_TARGET))\n\t\t\treturn -EFAULT;\n\n\toas_lun = lpfc_oas_lun_get_next(phba, phba->cfg_oas_vpt_wwpn,\n\t\t\t\t\tphba->cfg_oas_tgt_wwpn,\n\t\t\t\t\t&phba->cfg_oas_lun_status,\n\t\t\t\t\t&phba->cfg_oas_priority);\n\tif (oas_lun != NOT_OAS_ENABLED_LUN)\n\t\tphba->cfg_oas_flags |= OAS_LUN_VALID;\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len, \"0x%llx\", oas_lun);\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_oas_lun_store(struct device *dev, struct device_attribute *attr,\n\t\t   const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_hba *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\tuint64_t scsi_lun;\n\tuint32_t pri;\n\tssize_t rc;\n\n\tif (!phba->cfg_fof)\n\t\treturn -EPERM;\n\n\tif (wwn_to_u64(phba->cfg_oas_vpt_wwpn) == 0)\n\t\treturn -EFAULT;\n\n\tif (wwn_to_u64(phba->cfg_oas_tgt_wwpn) == 0)\n\t\treturn -EFAULT;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, \"0x%llx\", &scsi_lun) != 1)\n\t\treturn -EINVAL;\n\n\tpri = phba->cfg_oas_priority;\n\tif (pri == 0)\n\t\tpri = phba->cfg_XLanePriority;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\"3372 Try to set vport 0x%llx target 0x%llx lun:0x%llx \"\n\t\t\t\"priority 0x%x with oas state %d\\n\",\n\t\t\twwn_to_u64(phba->cfg_oas_vpt_wwpn),\n\t\t\twwn_to_u64(phba->cfg_oas_tgt_wwpn), scsi_lun,\n\t\t\tpri, phba->cfg_oas_lun_state);\n\n\trc = lpfc_oas_lun_state_change(phba, phba->cfg_oas_vpt_wwpn,\n\t\t\t\t       phba->cfg_oas_tgt_wwpn, scsi_lun,\n\t\t\t\t       phba->cfg_oas_lun_state, pri);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\nstatic DEVICE_ATTR(lpfc_xlane_lun, S_IRUGO | S_IWUSR,\n\t\t   lpfc_oas_lun_show, lpfc_oas_lun_store);\n\nint lpfc_enable_nvmet_cnt;\nunsigned long long lpfc_enable_nvmet[LPFC_NVMET_MAX_PORTS] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\nmodule_param_array(lpfc_enable_nvmet, ullong, &lpfc_enable_nvmet_cnt, 0444);\nMODULE_PARM_DESC(lpfc_enable_nvmet, \"Enable HBA port(s) WWPN as a NVME Target\");\n\nstatic int lpfc_poll = 0;\nmodule_param(lpfc_poll, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_poll, \"FCP ring polling mode control:\"\n\t\t \" 0 - none,\"\n\t\t \" 1 - poll with interrupts enabled\"\n\t\t \" 3 - poll and disable FCP ring interrupts\");\n\nstatic DEVICE_ATTR_RW(lpfc_poll);\n\nint lpfc_no_hba_reset_cnt;\nunsigned long lpfc_no_hba_reset[MAX_HBAS_NO_RESET] = {\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\nmodule_param_array(lpfc_no_hba_reset, ulong, &lpfc_no_hba_reset_cnt, 0444);\nMODULE_PARM_DESC(lpfc_no_hba_reset, \"WWPN of HBAs that should not be reset\");\n\nLPFC_ATTR(sli_mode, 3, 3, 3,\n\t\"SLI mode selector: 3 - select SLI-3\");\n\nLPFC_ATTR_R(enable_npiv, 1, 0, 1,\n\t\"Enable NPIV functionality\");\n\nLPFC_ATTR_R(fcf_failover_policy, 1, 1, 2,\n\t\"FCF Fast failover=1 Priority failover=2\");\n\n \nLPFC_ATTR_R(fcp_wait_abts_rsp, 0, 0, 1, \"Wait for FCP ABTS completion\");\n\n \nLPFC_ATTR_R(enable_rrq, 2, 0, 2,\n\t\"Enable RRQ functionality\");\n\n \nLPFC_ATTR_R(suppress_link_up, LPFC_INITIALIZE_LINK, LPFC_INITIALIZE_LINK,\n\t\tLPFC_DELAY_INIT_LINK_INDEFINITELY,\n\t\t\"Suppress Link Up at initialization\");\n\nstatic ssize_t\nlpfc_pls_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t phba->sli4_hba.pc_sli4_params.pls);\n}\nstatic DEVICE_ATTR(pls, 0444,\n\t\t\t lpfc_pls_show, NULL);\n\nstatic ssize_t\nlpfc_pt_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *)shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t (phba->hba_flag & HBA_PERSISTENT_TOPO) ? 1 : 0);\n}\nstatic DEVICE_ATTR(pt, 0444,\n\t\t\t lpfc_pt_show, NULL);\n\n \nstatic ssize_t\nlpfc_iocb_hw_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", phba->iocb_max);\n}\n\nstatic DEVICE_ATTR(iocb_hw, S_IRUGO,\n\t\t\t lpfc_iocb_hw_show, NULL);\nstatic ssize_t\nlpfc_txq_hw_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\n\tstruct lpfc_sli_ring *pring = lpfc_phba_elsring(phba);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tpring ? pring->txq_max : 0);\n}\n\nstatic DEVICE_ATTR(txq_hw, S_IRUGO,\n\t\t\t lpfc_txq_hw_show, NULL);\nstatic ssize_t\nlpfc_txcmplq_hw_show(struct device *dev, struct device_attribute *attr,\n char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_hba   *phba = ((struct lpfc_vport *) shost->hostdata)->phba;\n\tstruct lpfc_sli_ring *pring = lpfc_phba_elsring(phba);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\tpring ? pring->txcmplq_max : 0);\n}\n\nstatic DEVICE_ATTR(txcmplq_hw, S_IRUGO,\n\t\t\t lpfc_txcmplq_hw_show, NULL);\n\n \nstatic int lpfc_nodev_tmo = LPFC_DEF_DEVLOSS_TMO;\nstatic int lpfc_devloss_tmo = LPFC_DEF_DEVLOSS_TMO;\nmodule_param(lpfc_nodev_tmo, int, 0);\nMODULE_PARM_DESC(lpfc_nodev_tmo,\n\t\t \"Seconds driver will hold I/O waiting \"\n\t\t \"for a device to come back\");\n\n \nstatic ssize_t\nlpfc_nodev_tmo_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\tvport->cfg_devloss_tmo);\n}\n\n \nstatic int\nlpfc_nodev_tmo_init(struct lpfc_vport *vport, int val)\n{\n\tif (vport->cfg_devloss_tmo != LPFC_DEF_DEVLOSS_TMO) {\n\t\tvport->cfg_nodev_tmo = vport->cfg_devloss_tmo;\n\t\tif (val != LPFC_DEF_DEVLOSS_TMO)\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\t \"0407 Ignoring lpfc_nodev_tmo module \"\n\t\t\t\t\t \"parameter because lpfc_devloss_tmo \"\n\t\t\t\t\t \"is set.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\n\t\tvport->cfg_nodev_tmo = val;\n\t\tvport->cfg_devloss_tmo = val;\n\t\treturn 0;\n\t}\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t \"0400 lpfc_nodev_tmo attribute cannot be set to\"\n\t\t\t \" %d, allowed range is [%d, %d]\\n\",\n\t\t\t val, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\n\tvport->cfg_nodev_tmo = LPFC_DEF_DEVLOSS_TMO;\n\treturn -EINVAL;\n}\n\n \nstatic void\nlpfc_update_rport_devloss_tmo(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host  *shost;\n\tstruct lpfc_nodelist  *ndlp;\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct lpfc_nvme_rport *rport;\n\tstruct nvme_fc_remote_port *remoteport = NULL;\n#endif\n\n\tshost = lpfc_shost_from_vport(vport);\n\tspin_lock_irq(shost->host_lock);\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->rport)\n\t\t\tndlp->rport->dev_loss_tmo = vport->cfg_devloss_tmo;\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\t\tspin_lock(&ndlp->lock);\n\t\trport = lpfc_ndlp_get_nrport(ndlp);\n\t\tif (rport)\n\t\t\tremoteport = rport->remoteport;\n\t\tspin_unlock(&ndlp->lock);\n\t\tif (rport && remoteport)\n\t\t\tnvme_fc_set_remoteport_devloss(remoteport,\n\t\t\t\t\t\t       vport->cfg_devloss_tmo);\n#endif\n\t}\n\tspin_unlock_irq(shost->host_lock);\n}\n\n \nstatic int\nlpfc_nodev_tmo_set(struct lpfc_vport *vport, int val)\n{\n\tif (vport->dev_loss_tmo_changed ||\n\t    (lpfc_devloss_tmo != LPFC_DEF_DEVLOSS_TMO)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0401 Ignoring change to lpfc_nodev_tmo \"\n\t\t\t\t \"because lpfc_devloss_tmo is set.\\n\");\n\t\treturn 0;\n\t}\n\tif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\n\t\tvport->cfg_nodev_tmo = val;\n\t\tvport->cfg_devloss_tmo = val;\n\t\t \n\t\tfc_host_dev_loss_tmo(lpfc_shost_from_vport(vport)) = val;\n\t\tlpfc_update_rport_devloss_tmo(vport);\n\t\treturn 0;\n\t}\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t \"0403 lpfc_nodev_tmo attribute cannot be set to \"\n\t\t\t \"%d, allowed range is [%d, %d]\\n\",\n\t\t\t val, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\n\treturn -EINVAL;\n}\n\nlpfc_vport_param_store(nodev_tmo)\n\nstatic DEVICE_ATTR_RW(lpfc_nodev_tmo);\n\n \nmodule_param(lpfc_devloss_tmo, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_devloss_tmo,\n\t\t \"Seconds driver will hold I/O waiting \"\n\t\t \"for a device to come back\");\nlpfc_vport_param_init(devloss_tmo, LPFC_DEF_DEVLOSS_TMO,\n\t\t      LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO)\nlpfc_vport_param_show(devloss_tmo)\n\n \nstatic int\nlpfc_devloss_tmo_set(struct lpfc_vport *vport, int val)\n{\n\tif (val >= LPFC_MIN_DEVLOSS_TMO && val <= LPFC_MAX_DEVLOSS_TMO) {\n\t\tvport->cfg_nodev_tmo = val;\n\t\tvport->cfg_devloss_tmo = val;\n\t\tvport->dev_loss_tmo_changed = 1;\n\t\tfc_host_dev_loss_tmo(lpfc_shost_from_vport(vport)) = val;\n\t\tlpfc_update_rport_devloss_tmo(vport);\n\t\treturn 0;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t \"0404 lpfc_devloss_tmo attribute cannot be set to \"\n\t\t\t \"%d, allowed range is [%d, %d]\\n\",\n\t\t\t val, LPFC_MIN_DEVLOSS_TMO, LPFC_MAX_DEVLOSS_TMO);\n\treturn -EINVAL;\n}\n\nlpfc_vport_param_store(devloss_tmo)\nstatic DEVICE_ATTR_RW(lpfc_devloss_tmo);\n\n \nLPFC_ATTR_R(suppress_rsp, 1, 0, 1,\n\t    \"Enable suppress rsp feature is firmware supports it\");\n\n \nLPFC_ATTR_R(nvmet_mrq,\n\t    LPFC_NVMET_MRQ_AUTO, LPFC_NVMET_MRQ_AUTO, LPFC_NVMET_MRQ_MAX,\n\t    \"Specify number of RQ pairs for processing NVMET cmds\");\n\n \nLPFC_ATTR_R(nvmet_mrq_post,\n\t    LPFC_NVMET_RQE_DEF_POST, LPFC_NVMET_RQE_MIN_POST,\n\t    LPFC_NVMET_RQE_DEF_COUNT,\n\t    \"Specify number of RQ buffers to initially post\");\n\n \nLPFC_ATTR_R(enable_fc4_type, LPFC_DEF_ENBL_FC4_TYPE,\n\t    LPFC_ENABLE_FCP, LPFC_MAX_ENBL_FC4_TYPE,\n\t    \"Enable FC4 Protocol support - FCP / NVME\");\n\n \nLPFC_VPORT_ATTR_HEX_RW(log_verbose, 0x0, 0x0, 0xffffffff,\n\t\t       \"Verbose logging bit-mask\");\n\n \nLPFC_VPORT_ATTR_R(enable_da_id, 1, 0, 1,\n\t\t  \"Deregister nameserver objects before LOGO\");\n\n \nLPFC_VPORT_ATTR_R(lun_queue_depth, 64, 1, 512,\n\t\t  \"Max number of FCP commands we can queue to a specific LUN\");\n\n \nstatic uint lpfc_tgt_queue_depth = LPFC_MAX_TGT_QDEPTH;\nmodule_param(lpfc_tgt_queue_depth, uint, 0444);\nMODULE_PARM_DESC(lpfc_tgt_queue_depth, \"Set max Target queue depth\");\nlpfc_vport_param_show(tgt_queue_depth);\nlpfc_vport_param_init(tgt_queue_depth, LPFC_MAX_TGT_QDEPTH,\n\t\t      LPFC_MIN_TGT_QDEPTH, LPFC_MAX_TGT_QDEPTH);\n\n \nstatic int\nlpfc_tgt_queue_depth_set(struct lpfc_vport *vport, uint val)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp;\n\n\tif (!lpfc_rangecheck(val, LPFC_MIN_TGT_QDEPTH, LPFC_MAX_TGT_QDEPTH))\n\t\treturn -EINVAL;\n\n\tif (val == vport->cfg_tgt_queue_depth)\n\t\treturn 0;\n\n\tspin_lock_irq(shost->host_lock);\n\tvport->cfg_tgt_queue_depth = val;\n\n\t \n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp)\n\t\tndlp->cmd_qdepth = vport->cfg_tgt_queue_depth;\n\n\tspin_unlock_irq(shost->host_lock);\n\treturn 0;\n}\n\nlpfc_vport_param_store(tgt_queue_depth);\nstatic DEVICE_ATTR_RW(lpfc_tgt_queue_depth);\n\n \nLPFC_ATTR_R(hba_queue_depth, 8192, 32, 8192,\n\t    \"Max number of FCP commands we can queue to a lpfc HBA\");\n\n \nLPFC_VPORT_ATTR_R(peer_port_login, 0, 0, 1,\n\t\t  \"Allow peer ports on the same physical port to login to each \"\n\t\t  \"other.\");\n\n \nstatic int lpfc_restrict_login = 1;\nmodule_param(lpfc_restrict_login, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_restrict_login,\n\t\t \"Restrict virtual ports login to remote initiators.\");\nlpfc_vport_param_show(restrict_login);\n\n \nstatic int\nlpfc_restrict_login_init(struct lpfc_vport *vport, int val)\n{\n\tif (val < 0 || val > 1) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0422 lpfc_restrict_login attribute cannot \"\n\t\t\t\t \"be set to %d, allowed range is [0, 1]\\n\",\n\t\t\t\t val);\n\t\tvport->cfg_restrict_login = 1;\n\t\treturn -EINVAL;\n\t}\n\tif (vport->port_type == LPFC_PHYSICAL_PORT) {\n\t\tvport->cfg_restrict_login = 0;\n\t\treturn 0;\n\t}\n\tvport->cfg_restrict_login = val;\n\treturn 0;\n}\n\n \nstatic int\nlpfc_restrict_login_set(struct lpfc_vport *vport, int val)\n{\n\tif (val < 0 || val > 1) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0425 lpfc_restrict_login attribute cannot \"\n\t\t\t\t \"be set to %d, allowed range is [0, 1]\\n\",\n\t\t\t\t val);\n\t\tvport->cfg_restrict_login = 1;\n\t\treturn -EINVAL;\n\t}\n\tif (vport->port_type == LPFC_PHYSICAL_PORT && val != 0) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0468 lpfc_restrict_login must be 0 for \"\n\t\t\t\t \"Physical ports.\\n\");\n\t\tvport->cfg_restrict_login = 0;\n\t\treturn 0;\n\t}\n\tvport->cfg_restrict_login = val;\n\treturn 0;\n}\nlpfc_vport_param_store(restrict_login);\nstatic DEVICE_ATTR_RW(lpfc_restrict_login);\n\n \nLPFC_VPORT_ATTR_R(scan_down, 1, 0, 1,\n\t\t  \"Start scanning for devices from highest ALPA to lowest\");\n\n \nLPFC_ATTR(topology, 0, 0, 6,\n\t\"Select Fibre Channel topology\");\n\n \nstatic ssize_t\nlpfc_topology_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint val = 0;\n\tint nolip = 0;\n\tconst char *val_buf = buf;\n\tint err;\n\tuint32_t prev_val;\n\tu8 sli_family, if_type;\n\n\tif (!strncmp(buf, \"nolip \", strlen(\"nolip \"))) {\n\t\tnolip = 1;\n\t\tval_buf = &buf[strlen(\"nolip \")];\n\t}\n\n\tif (!isdigit(val_buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(val_buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tif (val >= 0 && val <= 6) {\n\t\tprev_val = phba->cfg_topology;\n\t\tif (phba->cfg_link_speed == LPFC_USER_LINK_SPEED_16G &&\n\t\t\tval == 4) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3113 Loop mode not supported at speed %d\\n\",\n\t\t\t\tval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tsli_family = bf_get(lpfc_sli_intf_sli_family,\n\t\t\t\t    &phba->sli4_hba.sli_intf);\n\t\tif_type = bf_get(lpfc_sli_intf_if_type,\n\t\t\t\t &phba->sli4_hba.sli_intf);\n\t\tif ((phba->hba_flag & HBA_PERSISTENT_TOPO ||\n\t\t    (!phba->sli4_hba.pc_sli4_params.pls &&\n\t\t     (sli_family == LPFC_SLI_INTF_FAMILY_G6 ||\n\t\t      if_type == LPFC_SLI_INTF_IF_TYPE_6))) &&\n\t\t    val == 4) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3114 Loop mode not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphba->cfg_topology = val;\n\t\tif (nolip)\n\t\t\treturn strlen(buf);\n\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\"3054 lpfc_topology changed from %d to %d\\n\",\n\t\t\tprev_val, val);\n\t\tif (prev_val != val && phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tphba->fc_topology_changed = 1;\n\t\terr = lpfc_issue_lip(lpfc_shost_from_vport(phba->pport));\n\t\tif (err) {\n\t\t\tphba->cfg_topology = prev_val;\n\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\treturn strlen(buf);\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\"%d:0467 lpfc_topology attribute cannot be set to %d, \"\n\t\t\"allowed range is [0, 6]\\n\",\n\t\tphba->brd_no, val);\n\treturn -EINVAL;\n}\n\nlpfc_param_show(topology)\nstatic DEVICE_ATTR_RW(lpfc_topology);\n\n \nstatic ssize_t\nlpfc_static_vport_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tif (vport->vport_flag & STATIC_VPORT)\n\t\tsprintf(buf, \"1\\n\");\n\telse\n\t\tsprintf(buf, \"0\\n\");\n\n\treturn strlen(buf);\n}\n\n \nstatic DEVICE_ATTR_RO(lpfc_static_vport);\n\n \n \nstatic ssize_t\nlpfc_link_speed_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint val = LPFC_USER_LINK_SPEED_AUTO;\n\tint nolip = 0;\n\tconst char *val_buf = buf;\n\tint err;\n\tuint32_t prev_val, if_type;\n\n\tif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\n\tif (if_type >= LPFC_SLI_INTF_IF_TYPE_2 &&\n\t    phba->hba_flag & HBA_FORCED_LINK_SPEED)\n\t\treturn -EPERM;\n\n\tif (!strncmp(buf, \"nolip \", strlen(\"nolip \"))) {\n\t\tnolip = 1;\n\t\tval_buf = &buf[strlen(\"nolip \")];\n\t}\n\n\tif (!isdigit(val_buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(val_buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\"3055 lpfc_link_speed changed from %d to %d %s\\n\",\n\t\tphba->cfg_link_speed, val, nolip ? \"(nolip)\" : \"(lip)\");\n\n\tif (((val == LPFC_USER_LINK_SPEED_1G) && !(phba->lmt & LMT_1Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_2G) && !(phba->lmt & LMT_2Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_4G) && !(phba->lmt & LMT_4Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_8G) && !(phba->lmt & LMT_8Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_10G) && !(phba->lmt & LMT_10Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_16G) && !(phba->lmt & LMT_16Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_32G) && !(phba->lmt & LMT_32Gb)) ||\n\t    ((val == LPFC_USER_LINK_SPEED_64G) && !(phba->lmt & LMT_64Gb))) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"2879 lpfc_link_speed attribute cannot be set \"\n\t\t\t\t\"to %d. Speed is not supported by this port.\\n\",\n\t\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n\tif (val >= LPFC_USER_LINK_SPEED_16G &&\n\t    phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3112 lpfc_link_speed attribute cannot be set \"\n\t\t\t\t\"to %d. Speed is not supported in loop mode.\\n\",\n\t\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (val) {\n\tcase LPFC_USER_LINK_SPEED_AUTO:\n\tcase LPFC_USER_LINK_SPEED_1G:\n\tcase LPFC_USER_LINK_SPEED_2G:\n\tcase LPFC_USER_LINK_SPEED_4G:\n\tcase LPFC_USER_LINK_SPEED_8G:\n\tcase LPFC_USER_LINK_SPEED_16G:\n\tcase LPFC_USER_LINK_SPEED_32G:\n\tcase LPFC_USER_LINK_SPEED_64G:\n\t\tprev_val = phba->cfg_link_speed;\n\t\tphba->cfg_link_speed = val;\n\t\tif (nolip)\n\t\t\treturn strlen(buf);\n\n\t\terr = lpfc_issue_lip(lpfc_shost_from_vport(phba->pport));\n\t\tif (err) {\n\t\t\tphba->cfg_link_speed = prev_val;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn strlen(buf);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"0469 lpfc_link_speed attribute cannot be set to %d, \"\n\t\t\t\"allowed values are [%s]\\n\",\n\t\t\tval, LPFC_LINK_SPEED_STRING);\n\treturn -EINVAL;\n\n}\n\nstatic int lpfc_link_speed = 0;\nmodule_param(lpfc_link_speed, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_link_speed, \"Select link speed\");\nlpfc_param_show(link_speed)\n\n \nstatic int\nlpfc_link_speed_init(struct lpfc_hba *phba, int val)\n{\n\tif (val >= LPFC_USER_LINK_SPEED_16G && phba->cfg_topology == 4) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"3111 lpfc_link_speed of %d cannot \"\n\t\t\t\"support loop mode, setting topology to default.\\n\",\n\t\t\t val);\n\t\tphba->cfg_topology = 0;\n\t}\n\n\tswitch (val) {\n\tcase LPFC_USER_LINK_SPEED_AUTO:\n\tcase LPFC_USER_LINK_SPEED_1G:\n\tcase LPFC_USER_LINK_SPEED_2G:\n\tcase LPFC_USER_LINK_SPEED_4G:\n\tcase LPFC_USER_LINK_SPEED_8G:\n\tcase LPFC_USER_LINK_SPEED_16G:\n\tcase LPFC_USER_LINK_SPEED_32G:\n\tcase LPFC_USER_LINK_SPEED_64G:\n\t\tphba->cfg_link_speed = val;\n\t\treturn 0;\n\tdefault:\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0405 lpfc_link_speed attribute cannot \"\n\t\t\t\t\"be set to %d, allowed values are \"\n\t\t\t\t\"[\"LPFC_LINK_SPEED_STRING\"]\\n\", val);\n\t\tphba->cfg_link_speed = LPFC_USER_LINK_SPEED_AUTO;\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic DEVICE_ATTR_RW(lpfc_link_speed);\n\n \nstatic uint lpfc_aer_support = 1;\nmodule_param(lpfc_aer_support, uint, S_IRUGO);\nMODULE_PARM_DESC(lpfc_aer_support, \"Enable PCIe device AER support\");\nstatic ssize_t\nlpfc_aer_support_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", lpfc_aer_support);\n}\n\n \nstatic ssize_t\nlpfc_aer_support_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tint val = 0;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\tdev_info_once(dev, \"PCIe error reporting automatically enabled by the PCI core; sysfs write ignored\\n\");\n\treturn strlen(buf);\n}\n\nstatic DEVICE_ATTR_RW(lpfc_aer_support);\n\n \nstatic ssize_t\nlpfc_aer_cleanup_state(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint val, rc = -1;\n\n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\trc = pci_aer_clear_nonfatal_status(phba->pcidev);\n\n\tif (rc == 0)\n\t\treturn strlen(buf);\n\telse\n\t\treturn -EPERM;\n}\n\nstatic DEVICE_ATTR(lpfc_aer_state_cleanup, S_IWUSR, NULL,\n\t\t   lpfc_aer_cleanup_state);\n\n \nstatic ssize_t\nlpfc_sriov_nr_virtfn_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct pci_dev *pdev = phba->pcidev;\n\tint val = 0, rc = -EINVAL;\n\n\t \n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (val == 0) {\n\t\tif (phba->cfg_sriov_nr_virtfn > 0) {\n\t\t\tpci_disable_sriov(pdev);\n\t\t\tphba->cfg_sriov_nr_virtfn = 0;\n\t\t}\n\t\treturn strlen(buf);\n\t}\n\n\t \n\tif (phba->cfg_sriov_nr_virtfn > 0) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3018 There are %d virtual functions \"\n\t\t\t\t\"enabled on physical function.\\n\",\n\t\t\t\tphba->cfg_sriov_nr_virtfn);\n\t\treturn -EEXIST;\n\t}\n\n\tif (val <= LPFC_MAX_VFN_PER_PFN)\n\t\tphba->cfg_sriov_nr_virtfn = val;\n\telse {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"3019 Enabling %d virtual functions is not \"\n\t\t\t\t\"allowed.\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\trc = lpfc_sli_probe_sriov_nr_virtfn(phba, phba->cfg_sriov_nr_virtfn);\n\tif (rc) {\n\t\tphba->cfg_sriov_nr_virtfn = 0;\n\t\trc = -EPERM;\n\t} else\n\t\trc = strlen(buf);\n\n\treturn rc;\n}\n\nLPFC_ATTR(sriov_nr_virtfn, LPFC_DEF_VFN_PER_PFN, 0, LPFC_MAX_VFN_PER_PFN,\n\t\"Enable PCIe device SR-IOV virtual fn\");\n\nlpfc_param_show(sriov_nr_virtfn)\nstatic DEVICE_ATTR_RW(lpfc_sriov_nr_virtfn);\n\n \nstatic ssize_t\nlpfc_request_firmware_upgrade_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tint val = 0, rc;\n\n\t \n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\trc = lpfc_sli4_request_firmware_update(phba, RUN_FW_UPGRADE);\n\tif (rc)\n\t\trc = -EPERM;\n\telse\n\t\trc = strlen(buf);\n\treturn rc;\n}\n\nstatic int lpfc_req_fw_upgrade;\nmodule_param(lpfc_req_fw_upgrade, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(lpfc_req_fw_upgrade, \"Enable Linux generic firmware upgrade\");\nlpfc_param_show(request_firmware_upgrade)\n\n \nstatic int\nlpfc_request_firmware_upgrade_init(struct lpfc_hba *phba, int val)\n{\n\tif (val >= 0 && val <= 1) {\n\t\tphba->cfg_request_firmware_upgrade = val;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\nstatic DEVICE_ATTR(lpfc_req_fw_upgrade, S_IRUGO | S_IWUSR,\n\t\t   lpfc_request_firmware_upgrade_show,\n\t\t   lpfc_request_firmware_upgrade_store);\n\n \nstatic ssize_t\nlpfc_force_rscn_store(struct device *dev, struct device_attribute *attr,\n\t\t      const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tint i;\n\n\ti = lpfc_issue_els_rscn(vport, 0);\n\tif (i)\n\t\treturn -EIO;\n\treturn strlen(buf);\n}\n\n \nstatic int lpfc_force_rscn;\nmodule_param(lpfc_force_rscn, int, 0644);\nMODULE_PARM_DESC(lpfc_force_rscn,\n\t\t \"Force an RSCN to be sent to all remote NPorts\");\nlpfc_param_show(force_rscn)\n\n \nstatic int\nlpfc_force_rscn_init(struct lpfc_hba *phba, int val)\n{\n\treturn 0;\n}\nstatic DEVICE_ATTR_RW(lpfc_force_rscn);\n\n \nstatic ssize_t\nlpfc_fcp_imax_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_eq_intr_info *eqi;\n\tuint32_t usdelay;\n\tint val = 0, i;\n\n\t \n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn -EINVAL;\n\n\t \n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (sscanf(buf, \"%i\", &val) != 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (val && (val < LPFC_MIN_IMAX || val > LPFC_MAX_IMAX))\n\t\treturn -EINVAL;\n\n\tphba->cfg_auto_imax = (val) ? 0 : 1;\n\tif (phba->cfg_fcp_imax && !val) {\n\t\tqueue_delayed_work(phba->wq, &phba->eq_delay_work,\n\t\t\t\t   msecs_to_jiffies(LPFC_EQ_DELAY_MSECS));\n\n\t\tfor_each_present_cpu(i) {\n\t\t\teqi = per_cpu_ptr(phba->sli4_hba.eq_info, i);\n\t\t\teqi->icnt = 0;\n\t\t}\n\t}\n\n\tphba->cfg_fcp_imax = (uint32_t)val;\n\n\tif (phba->cfg_fcp_imax)\n\t\tusdelay = LPFC_SEC_TO_USEC / phba->cfg_fcp_imax;\n\telse\n\t\tusdelay = 0;\n\n\tfor (i = 0; i < phba->cfg_irq_chann; i += LPFC_MAX_EQ_DELAY_EQID_CNT)\n\t\tlpfc_modify_hba_eq_delay(phba, i, LPFC_MAX_EQ_DELAY_EQID_CNT,\n\t\t\t\t\t usdelay);\n\n\treturn strlen(buf);\n}\n\n \nstatic int lpfc_fcp_imax = LPFC_DEF_IMAX;\nmodule_param(lpfc_fcp_imax, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(lpfc_fcp_imax,\n\t    \"Set the maximum number of FCP interrupts per second per HBA\");\nlpfc_param_show(fcp_imax)\n\n \nstatic int\nlpfc_fcp_imax_init(struct lpfc_hba *phba, int val)\n{\n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\tphba->cfg_fcp_imax = 0;\n\t\treturn 0;\n\t}\n\n\tif ((val >= LPFC_MIN_IMAX && val <= LPFC_MAX_IMAX) ||\n\t    (val == 0)) {\n\t\tphba->cfg_fcp_imax = val;\n\t\treturn 0;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"3016 lpfc_fcp_imax: %d out of range, using default\\n\",\n\t\t\tval);\n\tphba->cfg_fcp_imax = LPFC_DEF_IMAX;\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RW(lpfc_fcp_imax);\n\n \nstatic ssize_t\nlpfc_cq_max_proc_limit_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_queue *eq, *cq;\n\tunsigned long val;\n\tint i;\n\n\t \n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn -EINVAL;\n\n\t \n\tif (!isdigit(buf[0]))\n\t\treturn -EINVAL;\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val < LPFC_CQ_MIN_PROC_LIMIT || val > LPFC_CQ_MAX_PROC_LIMIT)\n\t\treturn -ERANGE;\n\n\tphba->cfg_cq_max_proc_limit = (uint32_t)val;\n\n\t \n\tfor (i = 0; i < phba->cfg_irq_chann; i++) {\n\t\t \n\t\teq = phba->sli4_hba.hba_eq_hdl[i].eq;\n\t\tif (!eq)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(cq, &eq->child_list, list)\n\t\t\tcq->max_proc_limit = min(phba->cfg_cq_max_proc_limit,\n\t\t\t\t\t\t cq->entry_count);\n\t}\n\n\treturn strlen(buf);\n}\n\n \nstatic int lpfc_cq_max_proc_limit = LPFC_CQ_DEF_MAX_PROC_LIMIT;\nmodule_param(lpfc_cq_max_proc_limit, int, 0644);\nMODULE_PARM_DESC(lpfc_cq_max_proc_limit,\n\t    \"Set the maximum number CQEs processed in an iteration of \"\n\t    \"CQ processing\");\nlpfc_param_show(cq_max_proc_limit)\n\n \nLPFC_ATTR_RW(cq_poll_threshold, LPFC_CQ_DEF_THRESHOLD_TO_POLL,\n\t     LPFC_CQ_MIN_THRESHOLD_TO_POLL,\n\t     LPFC_CQ_MAX_THRESHOLD_TO_POLL,\n\t     \"CQE Processing Threshold to enable Polling\");\n\n \nstatic int\nlpfc_cq_max_proc_limit_init(struct lpfc_hba *phba, int val)\n{\n\tphba->cfg_cq_max_proc_limit = LPFC_CQ_DEF_MAX_PROC_LIMIT;\n\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn 0;\n\n\tif (val >= LPFC_CQ_MIN_PROC_LIMIT && val <= LPFC_CQ_MAX_PROC_LIMIT) {\n\t\tphba->cfg_cq_max_proc_limit = val;\n\t\treturn 0;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"0371 lpfc_cq_max_proc_limit: %d out of range, using \"\n\t\t\t\"default\\n\",\n\t\t\tphba->cfg_cq_max_proc_limit);\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RW(lpfc_cq_max_proc_limit);\n\n \nstatic ssize_t\nlpfc_fcp_cpu_map_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_vector_map_info *cpup;\n\tint  len = 0;\n\n\tif ((phba->sli_rev != LPFC_SLI_REV4) ||\n\t    (phba->intr_type != MSIX))\n\t\treturn len;\n\n\tswitch (phba->cfg_fcp_cpu_map) {\n\tcase 0:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"fcp_cpu_map: No mapping (%d)\\n\",\n\t\t\t\tphba->cfg_fcp_cpu_map);\n\t\treturn len;\n\tcase 1:\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"fcp_cpu_map: HBA centric mapping (%d): \"\n\t\t\t\t\"%d of %d CPUs online from %d possible CPUs\\n\",\n\t\t\t\tphba->cfg_fcp_cpu_map, num_online_cpus(),\n\t\t\t\tnum_present_cpus(),\n\t\t\t\tphba->sli4_hba.num_possible_cpu);\n\t\tbreak;\n\t}\n\n\twhile (phba->sli4_hba.curr_disp_cpu <\n\t       phba->sli4_hba.num_possible_cpu) {\n\t\tcpup = &phba->sli4_hba.cpu_map[phba->sli4_hba.curr_disp_cpu];\n\n\t\tif (!cpu_present(phba->sli4_hba.curr_disp_cpu))\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d not present\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu);\n\t\telse if (cpup->eq == LPFC_VECTOR_MAP_EMPTY) {\n\t\t\tif (cpup->hdwq == LPFC_VECTOR_MAP_EMPTY)\n\t\t\t\tlen += scnprintf(\n\t\t\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d hdwq None \"\n\t\t\t\t\t\"physid %d coreid %d ht %d ua %d\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu,\n\t\t\t\t\tcpup->phys_id, cpup->core_id,\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_HYPER),\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_UNASSIGN));\n\t\t\telse\n\t\t\t\tlen += scnprintf(\n\t\t\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d EQ None hdwq %04d \"\n\t\t\t\t\t\"physid %d coreid %d ht %d ua %d\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu,\n\t\t\t\t\tcpup->hdwq, cpup->phys_id,\n\t\t\t\t\tcpup->core_id,\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_HYPER),\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_UNASSIGN));\n\t\t} else {\n\t\t\tif (cpup->hdwq == LPFC_VECTOR_MAP_EMPTY)\n\t\t\t\tlen += scnprintf(\n\t\t\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d hdwq None \"\n\t\t\t\t\t\"physid %d coreid %d ht %d ua %d IRQ %d\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu,\n\t\t\t\t\tcpup->phys_id,\n\t\t\t\t\tcpup->core_id,\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_HYPER),\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_UNASSIGN),\n\t\t\t\t\tlpfc_get_irq(cpup->eq));\n\t\t\telse\n\t\t\t\tlen += scnprintf(\n\t\t\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"CPU %02d EQ %04d hdwq %04d \"\n\t\t\t\t\t\"physid %d coreid %d ht %d ua %d IRQ %d\\n\",\n\t\t\t\t\tphba->sli4_hba.curr_disp_cpu,\n\t\t\t\t\tcpup->eq, cpup->hdwq, cpup->phys_id,\n\t\t\t\t\tcpup->core_id,\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_HYPER),\n\t\t\t\t\t(cpup->flag & LPFC_CPU_MAP_UNASSIGN),\n\t\t\t\t\tlpfc_get_irq(cpup->eq));\n\t\t}\n\n\t\tphba->sli4_hba.curr_disp_cpu++;\n\n\t\t \n\t\tif (phba->sli4_hba.curr_disp_cpu <\n\t\t\t\tphba->sli4_hba.num_possible_cpu &&\n\t\t\t\t(len >= (PAGE_SIZE - 64))) {\n\t\t\tlen += scnprintf(buf + len,\n\t\t\t\t\tPAGE_SIZE - len, \"more...\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (phba->sli4_hba.curr_disp_cpu == phba->sli4_hba.num_possible_cpu)\n\t\tphba->sli4_hba.curr_disp_cpu = 0;\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_fcp_cpu_map_store(struct device *dev, struct device_attribute *attr,\n\t\t       const char *buf, size_t count)\n{\n\treturn -EINVAL;\n}\n\n \nstatic int lpfc_fcp_cpu_map = LPFC_HBA_CPU_MAP;\nmodule_param(lpfc_fcp_cpu_map, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(lpfc_fcp_cpu_map,\n\t\t \"Defines how to map CPUs to IRQ vectors per HBA\");\n\n \nstatic int\nlpfc_fcp_cpu_map_init(struct lpfc_hba *phba, int val)\n{\n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\tphba->cfg_fcp_cpu_map = 0;\n\t\treturn 0;\n\t}\n\n\tif (val >= LPFC_MIN_CPU_MAP && val <= LPFC_MAX_CPU_MAP) {\n\t\tphba->cfg_fcp_cpu_map = val;\n\t\treturn 0;\n\t}\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"3326 lpfc_fcp_cpu_map: %d out of range, using \"\n\t\t\t\"default\\n\", val);\n\tphba->cfg_fcp_cpu_map = LPFC_HBA_CPU_MAP;\n\n\treturn 0;\n}\n\nstatic DEVICE_ATTR_RW(lpfc_fcp_cpu_map);\n\n \nLPFC_VPORT_ATTR_R(fcp_class, 3, 2, 3,\n\t\t  \"Select Fibre Channel class of service for FCP sequences\");\n\n \nLPFC_VPORT_ATTR_RW(use_adisc, 1, 0, 1,\n\t\t   \"Use ADISC on rediscovery to authenticate FCP devices\");\n\n \nLPFC_VPORT_ATTR_RW(first_burst_size, 0, 0, 65536,\n\t\t   \"First burst size for Targets that support first burst\");\n\n \nLPFC_ATTR_RW(nvmet_fb_size, 0, 0, 65536,\n\t     \"NVME Target mode first burst size in 512B increments.\");\n\n \nLPFC_ATTR_RW(nvme_enable_fb, 0, 0, 1,\n\t     \"Enable First Burst feature for NVME Initiator.\");\n\n \nLPFC_VPORT_ATTR(max_scsicmpl_time, 0, 0, 60000,\n\t\"Use command completion time to control queue depth\");\n\nlpfc_vport_param_show(max_scsicmpl_time);\nstatic int\nlpfc_max_scsicmpl_time_set(struct lpfc_vport *vport, int val)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_nodelist *ndlp, *next_ndlp;\n\n\tif (val == vport->cfg_max_scsicmpl_time)\n\t\treturn 0;\n\tif ((val < 0) || (val > 60000))\n\t\treturn -EINVAL;\n\tvport->cfg_max_scsicmpl_time = val;\n\n\tspin_lock_irq(shost->host_lock);\n\tlist_for_each_entry_safe(ndlp, next_ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_state == NLP_STE_UNUSED_NODE)\n\t\t\tcontinue;\n\t\tndlp->cmd_qdepth = vport->cfg_tgt_queue_depth;\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\treturn 0;\n}\nlpfc_vport_param_store(max_scsicmpl_time);\nstatic DEVICE_ATTR_RW(lpfc_max_scsicmpl_time);\n\n \nLPFC_ATTR_R(ack0, 0, 0, 1, \"Enable ACK0 support\");\n\n \nLPFC_ATTR_R(xri_rebalancing, 1, 0, 1, \"Enable/Disable XRI rebalancing\");\n\n \nLPFC_ATTR_RW(fcp_io_sched, LPFC_FCP_SCHED_BY_CPU,\n\t     LPFC_FCP_SCHED_BY_HDWQ,\n\t     LPFC_FCP_SCHED_BY_CPU,\n\t     \"Determine scheduling algorithm for \"\n\t     \"issuing commands [0] - Hardware Queue, [1] - Current CPU\");\n\n \nLPFC_ATTR_RW(ns_query, LPFC_NS_QUERY_GID_FT,\n\t     LPFC_NS_QUERY_GID_FT, LPFC_NS_QUERY_GID_PT,\n\t     \"Determine algorithm NameServer queries after RSCN \"\n\t     \"[0] - GID_FT, [1] - GID_PT\");\n\n \nLPFC_ATTR_RW(fcp2_no_tgt_reset, 0, 0, 1, \"Determine bus reset behavior for \"\n\t     \"FCP2 devices [0] - issue tgt reset, [1] - no tgt reset\");\n\n\n \nLPFC_ATTR_RW(cr_delay, 0, 0, 63, \"A count of milliseconds after which an \"\n\t\t\"interrupt response is generated\");\n\nLPFC_ATTR_RW(cr_count, 1, 1, 255, \"A count of I/O completions after which an \"\n\t\t\"interrupt response is generated\");\n\n \nLPFC_ATTR_R(multi_ring_support, 1, 1, 2, \"Determines number of primary \"\n\t\t\"SLI rings to spread IOCB entries across\");\n\n \nLPFC_ATTR_R(multi_ring_rctl, FC_RCTL_DD_UNSOL_DATA, 1,\n\t     255, \"Identifies RCTL for additional ring configuration\");\n\n \nLPFC_ATTR_R(multi_ring_type, FC_TYPE_IP, 1,\n\t     255, \"Identifies TYPE for additional ring configuration\");\n\n \nLPFC_ATTR_R(enable_SmartSAN, 0, 0, 1, \"Enable SmartSAN functionality\");\n\n \nLPFC_ATTR_R(fdmi_on, 1, 0, 1, \"Enable FDMI support\");\n\n \nLPFC_VPORT_ATTR(discovery_threads, 32, 1, 64, \"Maximum number of ELS commands \"\n\t\t \"during discovery\");\n\n \nLPFC_VPORT_ULL_ATTR_R(max_luns, 255, 0, 65535, \"Maximum allowed LUN ID\");\n\n \nLPFC_ATTR_RW(poll_tmo, 10, 1, 255,\n\t     \"Milliseconds driver will wait between polling FCP ring\");\n\n \nLPFC_ATTR_RW(task_mgmt_tmo, 60, 5, 180,\n\t     \"Maximum time to wait for task management commands to complete\");\n \nLPFC_ATTR_R(use_msi, 2, 0, 2, \"Use Message Signaled Interrupts (1) or \"\n\t    \"MSI-X (2), if possible\");\n\n \nLPFC_ATTR_RW(nvme_oas, 0, 0, 1,\n\t     \"Use OAS bit on NVME IOs\");\n\n \nLPFC_ATTR_RW(nvme_embed_cmd, 1, 0, 2,\n\t     \"Embed NVME Command in WQE\");\n\n \nLPFC_ATTR_R(fcp_mq_threshold, LPFC_FCP_MQ_THRESHOLD_DEF,\n\t    LPFC_FCP_MQ_THRESHOLD_MIN, LPFC_FCP_MQ_THRESHOLD_MAX,\n\t    \"Set the number of SCSI Queues advertised\");\n\n \nLPFC_ATTR_R(hdw_queue,\n\t    LPFC_HBA_HDWQ_DEF,\n\t    LPFC_HBA_HDWQ_MIN, LPFC_HBA_HDWQ_MAX,\n\t    \"Set the number of I/O Hardware Queues\");\n\n#if IS_ENABLED(CONFIG_X86)\n \nstatic void\nlpfc_cpumask_irq_mode_init(struct lpfc_hba *phba)\n{\n\tunsigned int cpu, first_cpu, numa_node = NUMA_NO_NODE;\n\tconst struct cpumask *sibling_mask;\n\tstruct cpumask *aff_mask = &phba->sli4_hba.irq_aff_mask;\n\n\tcpumask_clear(aff_mask);\n\n\tif (phba->irq_chann_mode == NUMA_MODE) {\n\t\t \n\t\tnuma_node = dev_to_node(&phba->pcidev->dev);\n\t\tif (numa_node == NUMA_NO_NODE) {\n\t\t\tphba->irq_chann_mode = NORMAL_MODE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tswitch (phba->irq_chann_mode) {\n\t\tcase NUMA_MODE:\n\t\t\tif (cpu_to_node(cpu) == numa_node)\n\t\t\t\tcpumask_set_cpu(cpu, aff_mask);\n\t\t\tbreak;\n\t\tcase NHT_MODE:\n\t\t\tsibling_mask = topology_sibling_cpumask(cpu);\n\t\t\tfirst_cpu = cpumask_first(sibling_mask);\n\t\t\tif (first_cpu < nr_cpu_ids)\n\t\t\t\tcpumask_set_cpu(first_cpu, aff_mask);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n#endif\n\nstatic void\nlpfc_assign_default_irq_chann(struct lpfc_hba *phba)\n{\n#if IS_ENABLED(CONFIG_X86)\n\tswitch (boot_cpu_data.x86_vendor) {\n\tcase X86_VENDOR_AMD:\n\t\t \n\t\tphba->irq_chann_mode = NUMA_MODE;\n\t\tbreak;\n\tcase X86_VENDOR_INTEL:\n\t\t \n\t\tphba->irq_chann_mode = NHT_MODE;\n\t\tbreak;\n\tdefault:\n\t\tphba->irq_chann_mode = NORMAL_MODE;\n\t\tbreak;\n\t}\n\tlpfc_cpumask_irq_mode_init(phba);\n#else\n\tphba->irq_chann_mode = NORMAL_MODE;\n#endif\n}\n\n \nstatic uint lpfc_irq_chann = LPFC_IRQ_CHANN_DEF;\nmodule_param(lpfc_irq_chann, uint, 0444);\nMODULE_PARM_DESC(lpfc_irq_chann, \"Set number of interrupt vectors to allocate\");\n\n \nstatic int\nlpfc_irq_chann_init(struct lpfc_hba *phba, uint32_t val)\n{\n\tconst struct cpumask *aff_mask;\n\n\tif (phba->cfg_use_msi != 2) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\"8532 use_msi = %u ignoring cfg_irq_numa\\n\",\n\t\t\t\tphba->cfg_use_msi);\n\t\tphba->irq_chann_mode = NORMAL_MODE;\n\t\tphba->cfg_irq_chann = LPFC_IRQ_CHANN_DEF;\n\t\treturn 0;\n\t}\n\n\t \n\tif (val == LPFC_IRQ_CHANN_DEF &&\n\t    phba->cfg_hdw_queue == LPFC_HBA_HDWQ_DEF &&\n\t    phba->sli_rev == LPFC_SLI_REV4)\n\t\tlpfc_assign_default_irq_chann(phba);\n\n\tif (phba->irq_chann_mode != NORMAL_MODE) {\n\t\taff_mask = &phba->sli4_hba.irq_aff_mask;\n\n\t\tif (cpumask_empty(aff_mask)) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8533 Could not identify CPUS for \"\n\t\t\t\t\t\"mode %d, ignoring\\n\",\n\t\t\t\t\tphba->irq_chann_mode);\n\t\t\tphba->irq_chann_mode = NORMAL_MODE;\n\t\t\tphba->cfg_irq_chann = LPFC_IRQ_CHANN_DEF;\n\t\t} else {\n\t\t\tphba->cfg_irq_chann = cpumask_weight(aff_mask);\n\n\t\t\t \n\t\t\tif (phba->irq_chann_mode == NHT_MODE)\n\t\t\t\tphba->cfg_hdw_queue = phba->cfg_irq_chann;\n\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8543 lpfc_irq_chann set to %u \"\n\t\t\t\t\t\"(mode: %d)\\n\", phba->cfg_irq_chann,\n\t\t\t\t\tphba->irq_chann_mode);\n\t\t}\n\t} else {\n\t\tif (val > LPFC_IRQ_CHANN_MAX) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8545 lpfc_irq_chann attribute cannot \"\n\t\t\t\t\t\"be set to %u, allowed range is \"\n\t\t\t\t\t\"[%u,%u]\\n\",\n\t\t\t\t\tval,\n\t\t\t\t\tLPFC_IRQ_CHANN_MIN,\n\t\t\t\t\tLPFC_IRQ_CHANN_MAX);\n\t\t\tphba->cfg_irq_chann = LPFC_IRQ_CHANN_DEF;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tphba->cfg_irq_chann = val;\n\t\t} else {\n\t\t\tphba->cfg_irq_chann = 2;\n\t\t\tphba->cfg_hdw_queue = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic ssize_t\nlpfc_irq_chann_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%u\\n\", phba->cfg_irq_chann);\n}\n\nstatic DEVICE_ATTR_RO(lpfc_irq_chann);\n\n \nLPFC_ATTR_RW(enable_hba_reset, 1, 0, 2, \"Enable HBA resets from the driver.\");\n\n \nLPFC_ATTR_R(enable_hba_heartbeat, 0, 0, 1, \"Enable HBA Heartbeat.\");\n\n \nLPFC_ATTR_R(EnableXLane, 0, 0, 1, \"Enable Express Lane Feature.\");\n\n \nLPFC_ATTR_RW(XLanePriority, 0, 0x0, 0x7f, \"CS_CTL for Express Lane Feature.\");\n\n \nLPFC_ATTR_R(enable_bg, 0, 0, 1, \"Enable BlockGuard Support\");\n\n \nLPFC_ATTR(prot_mask,\n\t(SHOST_DIF_TYPE1_PROTECTION |\n\tSHOST_DIX_TYPE0_PROTECTION |\n\tSHOST_DIX_TYPE1_PROTECTION),\n\t0,\n\t(SHOST_DIF_TYPE1_PROTECTION |\n\tSHOST_DIX_TYPE0_PROTECTION |\n\tSHOST_DIX_TYPE1_PROTECTION),\n\t\"T10-DIF host protection capabilities mask\");\n\n \nLPFC_ATTR(prot_guard,\n\tSHOST_DIX_GUARD_IP, SHOST_DIX_GUARD_CRC, SHOST_DIX_GUARD_IP,\n\t\"T10-DIF host protection guard type\");\n\n \nLPFC_ATTR(delay_discovery, 0, 0, 1,\n\t\"Delay NPort discovery when Clean Address bit is cleared.\");\n\n \nstatic uint lpfc_sg_seg_cnt = LPFC_DEFAULT_SG_SEG_CNT;\nmodule_param(lpfc_sg_seg_cnt, uint, 0444);\nMODULE_PARM_DESC(lpfc_sg_seg_cnt, \"Max Scatter Gather Segment Count\");\n\n \nstatic ssize_t\nlpfc_sg_seg_cnt_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint len;\n\n\tlen = scnprintf(buf, PAGE_SIZE, \"SGL sz: %d  total SGEs: %d\\n\",\n\t\t       phba->cfg_sg_dma_buf_size, phba->cfg_total_seg_cnt);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"Cfg: %d  SCSI: %d  NVME: %d\\n\",\n\t\t\tphba->cfg_sg_seg_cnt, phba->cfg_scsi_seg_cnt,\n\t\t\tphba->cfg_nvme_seg_cnt);\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(lpfc_sg_seg_cnt);\n\n \nstatic int\nlpfc_sg_seg_cnt_init(struct lpfc_hba *phba, int val)\n{\n\tif (val >= LPFC_MIN_SG_SEG_CNT && val <= LPFC_MAX_SG_SEG_CNT) {\n\t\tphba->cfg_sg_seg_cnt = val;\n\t\treturn 0;\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\"0409 lpfc_sg_seg_cnt attribute cannot be set to %d, \"\n\t\t\t\"allowed range is [%d, %d]\\n\",\n\t\t\tval, LPFC_MIN_SG_SEG_CNT, LPFC_MAX_SG_SEG_CNT);\n\tphba->cfg_sg_seg_cnt = LPFC_DEFAULT_SG_SEG_CNT;\n\treturn -EINVAL;\n}\n\n \nLPFC_ATTR_RW(enable_mds_diags, 0, 0, 1, \"Enable MDS Diagnostics\");\n\n \nLPFC_ATTR(ras_fwlog_buffsize, 0, 0, 4, \"Host memory for FW logging\");\nlpfc_param_show(ras_fwlog_buffsize);\n\nstatic ssize_t\nlpfc_ras_fwlog_buffsize_set(struct lpfc_hba  *phba, uint val)\n{\n\tint ret = 0;\n\tenum ras_state state;\n\n\tif (!lpfc_rangecheck(val, 0, 4))\n\t\treturn -EINVAL;\n\n\tif (phba->cfg_ras_fwlog_buffsize == val)\n\t\treturn 0;\n\n\tif (phba->cfg_ras_fwlog_func != PCI_FUNC(phba->pcidev->devfn))\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&phba->hbalock);\n\tstate = phba->ras_fwlog.state;\n\tspin_unlock_irq(&phba->hbalock);\n\n\tif (state == REG_INPROGRESS) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_SLI, \"6147 RAS Logging \"\n\t\t\t\t\"registration is in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tphba->cfg_ras_fwlog_buffsize = val;\n\tif (state == ACTIVE) {\n\t\tlpfc_ras_stop_fwlog(phba);\n\t\tlpfc_sli4_ras_dma_free(phba);\n\t}\n\n\tlpfc_sli4_ras_init(phba);\n\tif (phba->ras_fwlog.ras_enabled)\n\t\tret = lpfc_sli4_ras_fwlog_init(phba, phba->cfg_ras_fwlog_level,\n\t\t\t\t\t       LPFC_RAS_ENABLE_LOGGING);\n\treturn ret;\n}\n\nlpfc_param_store(ras_fwlog_buffsize);\nstatic DEVICE_ATTR_RW(lpfc_ras_fwlog_buffsize);\n\n \nLPFC_ATTR_RW(ras_fwlog_level, 0, 0, 4, \"Firmware Logging Level\");\n\n \nLPFC_ATTR_RW(ras_fwlog_func, 0, 0, 7, \"Firmware Logging Enabled on Function\");\n\n \nLPFC_BBCR_ATTR_RW(enable_bbcr, 1, 0, 1, \"Enable BBC Recovery\");\n\n \nint lpfc_fabric_cgn_frequency = 100;  \nmodule_param(lpfc_fabric_cgn_frequency, int, 0444);\nMODULE_PARM_DESC(lpfc_fabric_cgn_frequency, \"Congestion signaling fabric freq\");\n\nunsigned char lpfc_acqe_cgn_frequency = 10;  \nmodule_param(lpfc_acqe_cgn_frequency, byte, 0444);\nMODULE_PARM_DESC(lpfc_acqe_cgn_frequency, \"Congestion signaling ACQE freq\");\n\nint lpfc_use_cgn_signal = 1;  \nmodule_param(lpfc_use_cgn_signal, int, 0444);\nMODULE_PARM_DESC(lpfc_use_cgn_signal, \"Use Congestion signaling if available\");\n\n \nLPFC_ATTR_RW(enable_dpp, 1, 0, 1, \"Enable Direct Packet Push\");\n\n \nLPFC_ATTR_R(enable_mi, 1, 0, 1, \"Enable MI\");\n\n \nLPFC_ATTR_RW(max_vmid, LPFC_MIN_VMID, LPFC_MIN_VMID, LPFC_MAX_VMID,\n\t     \"Maximum number of VMs supported\");\n\n \nLPFC_ATTR_RW(vmid_inactivity_timeout, 4, 0, 24,\n\t     \"Inactivity timeout in hours\");\n\n \nLPFC_ATTR_RW(vmid_app_header, LPFC_VMID_APP_HEADER_DISABLE,\n\t     LPFC_VMID_APP_HEADER_DISABLE, LPFC_VMID_APP_HEADER_ENABLE,\n\t     \"Enable App Header VMID support\");\n\n \nLPFC_ATTR_RW(vmid_priority_tagging, LPFC_VMID_PRIO_TAG_DISABLE,\n\t     LPFC_VMID_PRIO_TAG_DISABLE,\n\t     LPFC_VMID_PRIO_TAG_ALL_TARGETS,\n\t     \"Enable Priority Tagging VMID support\");\n\nstatic struct attribute *lpfc_hba_attrs[] = {\n\t&dev_attr_nvme_info.attr,\n\t&dev_attr_scsi_stat.attr,\n\t&dev_attr_bg_info.attr,\n\t&dev_attr_bg_guard_err.attr,\n\t&dev_attr_bg_apptag_err.attr,\n\t&dev_attr_bg_reftag_err.attr,\n\t&dev_attr_info.attr,\n\t&dev_attr_serialnum.attr,\n\t&dev_attr_modeldesc.attr,\n\t&dev_attr_modelname.attr,\n\t&dev_attr_programtype.attr,\n\t&dev_attr_portnum.attr,\n\t&dev_attr_fwrev.attr,\n\t&dev_attr_hdw.attr,\n\t&dev_attr_option_rom_version.attr,\n\t&dev_attr_link_state.attr,\n\t&dev_attr_num_discovered_ports.attr,\n\t&dev_attr_lpfc_drvr_version.attr,\n\t&dev_attr_lpfc_enable_fip.attr,\n\t&dev_attr_lpfc_temp_sensor.attr,\n\t&dev_attr_lpfc_log_verbose.attr,\n\t&dev_attr_lpfc_lun_queue_depth.attr,\n\t&dev_attr_lpfc_tgt_queue_depth.attr,\n\t&dev_attr_lpfc_hba_queue_depth.attr,\n\t&dev_attr_lpfc_peer_port_login.attr,\n\t&dev_attr_lpfc_nodev_tmo.attr,\n\t&dev_attr_lpfc_devloss_tmo.attr,\n\t&dev_attr_lpfc_enable_fc4_type.attr,\n\t&dev_attr_lpfc_fcp_class.attr,\n\t&dev_attr_lpfc_use_adisc.attr,\n\t&dev_attr_lpfc_first_burst_size.attr,\n\t&dev_attr_lpfc_ack0.attr,\n\t&dev_attr_lpfc_xri_rebalancing.attr,\n\t&dev_attr_lpfc_topology.attr,\n\t&dev_attr_lpfc_scan_down.attr,\n\t&dev_attr_lpfc_link_speed.attr,\n\t&dev_attr_lpfc_fcp_io_sched.attr,\n\t&dev_attr_lpfc_ns_query.attr,\n\t&dev_attr_lpfc_fcp2_no_tgt_reset.attr,\n\t&dev_attr_lpfc_cr_delay.attr,\n\t&dev_attr_lpfc_cr_count.attr,\n\t&dev_attr_lpfc_multi_ring_support.attr,\n\t&dev_attr_lpfc_multi_ring_rctl.attr,\n\t&dev_attr_lpfc_multi_ring_type.attr,\n\t&dev_attr_lpfc_fdmi_on.attr,\n\t&dev_attr_lpfc_enable_SmartSAN.attr,\n\t&dev_attr_lpfc_max_luns.attr,\n\t&dev_attr_lpfc_enable_npiv.attr,\n\t&dev_attr_lpfc_fcf_failover_policy.attr,\n\t&dev_attr_lpfc_enable_rrq.attr,\n\t&dev_attr_lpfc_fcp_wait_abts_rsp.attr,\n\t&dev_attr_nport_evt_cnt.attr,\n\t&dev_attr_board_mode.attr,\n\t&dev_attr_lpfc_xcvr_data.attr,\n\t&dev_attr_max_vpi.attr,\n\t&dev_attr_used_vpi.attr,\n\t&dev_attr_max_rpi.attr,\n\t&dev_attr_used_rpi.attr,\n\t&dev_attr_max_xri.attr,\n\t&dev_attr_used_xri.attr,\n\t&dev_attr_npiv_info.attr,\n\t&dev_attr_issue_reset.attr,\n\t&dev_attr_lpfc_poll.attr,\n\t&dev_attr_lpfc_poll_tmo.attr,\n\t&dev_attr_lpfc_task_mgmt_tmo.attr,\n\t&dev_attr_lpfc_use_msi.attr,\n\t&dev_attr_lpfc_nvme_oas.attr,\n\t&dev_attr_lpfc_nvme_embed_cmd.attr,\n\t&dev_attr_lpfc_fcp_imax.attr,\n\t&dev_attr_lpfc_force_rscn.attr,\n\t&dev_attr_lpfc_cq_poll_threshold.attr,\n\t&dev_attr_lpfc_cq_max_proc_limit.attr,\n\t&dev_attr_lpfc_fcp_cpu_map.attr,\n\t&dev_attr_lpfc_fcp_mq_threshold.attr,\n\t&dev_attr_lpfc_hdw_queue.attr,\n\t&dev_attr_lpfc_irq_chann.attr,\n\t&dev_attr_lpfc_suppress_rsp.attr,\n\t&dev_attr_lpfc_nvmet_mrq.attr,\n\t&dev_attr_lpfc_nvmet_mrq_post.attr,\n\t&dev_attr_lpfc_nvme_enable_fb.attr,\n\t&dev_attr_lpfc_nvmet_fb_size.attr,\n\t&dev_attr_lpfc_enable_bg.attr,\n\t&dev_attr_lpfc_enable_hba_reset.attr,\n\t&dev_attr_lpfc_enable_hba_heartbeat.attr,\n\t&dev_attr_lpfc_EnableXLane.attr,\n\t&dev_attr_lpfc_XLanePriority.attr,\n\t&dev_attr_lpfc_xlane_lun.attr,\n\t&dev_attr_lpfc_xlane_tgt.attr,\n\t&dev_attr_lpfc_xlane_vpt.attr,\n\t&dev_attr_lpfc_xlane_lun_state.attr,\n\t&dev_attr_lpfc_xlane_lun_status.attr,\n\t&dev_attr_lpfc_xlane_priority.attr,\n\t&dev_attr_lpfc_sg_seg_cnt.attr,\n\t&dev_attr_lpfc_max_scsicmpl_time.attr,\n\t&dev_attr_lpfc_aer_support.attr,\n\t&dev_attr_lpfc_aer_state_cleanup.attr,\n\t&dev_attr_lpfc_sriov_nr_virtfn.attr,\n\t&dev_attr_lpfc_req_fw_upgrade.attr,\n\t&dev_attr_lpfc_suppress_link_up.attr,\n\t&dev_attr_iocb_hw.attr,\n\t&dev_attr_pls.attr,\n\t&dev_attr_pt.attr,\n\t&dev_attr_txq_hw.attr,\n\t&dev_attr_txcmplq_hw.attr,\n\t&dev_attr_lpfc_sriov_hw_max_virtfn.attr,\n\t&dev_attr_protocol.attr,\n\t&dev_attr_lpfc_xlane_supported.attr,\n\t&dev_attr_lpfc_enable_mds_diags.attr,\n\t&dev_attr_lpfc_ras_fwlog_buffsize.attr,\n\t&dev_attr_lpfc_ras_fwlog_level.attr,\n\t&dev_attr_lpfc_ras_fwlog_func.attr,\n\t&dev_attr_lpfc_enable_bbcr.attr,\n\t&dev_attr_lpfc_enable_dpp.attr,\n\t&dev_attr_lpfc_enable_mi.attr,\n\t&dev_attr_cmf_info.attr,\n\t&dev_attr_lpfc_max_vmid.attr,\n\t&dev_attr_lpfc_vmid_inactivity_timeout.attr,\n\t&dev_attr_lpfc_vmid_app_header.attr,\n\t&dev_attr_lpfc_vmid_priority_tagging.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lpfc_hba_attr_group = {\n\t.attrs = lpfc_hba_attrs\n};\n\nconst struct attribute_group *lpfc_hba_groups[] = {\n\t&lpfc_hba_attr_group,\n\tNULL\n};\n\nstatic struct attribute *lpfc_vport_attrs[] = {\n\t&dev_attr_info.attr,\n\t&dev_attr_link_state.attr,\n\t&dev_attr_num_discovered_ports.attr,\n\t&dev_attr_lpfc_drvr_version.attr,\n\t&dev_attr_lpfc_log_verbose.attr,\n\t&dev_attr_lpfc_lun_queue_depth.attr,\n\t&dev_attr_lpfc_tgt_queue_depth.attr,\n\t&dev_attr_lpfc_nodev_tmo.attr,\n\t&dev_attr_lpfc_devloss_tmo.attr,\n\t&dev_attr_lpfc_hba_queue_depth.attr,\n\t&dev_attr_lpfc_peer_port_login.attr,\n\t&dev_attr_lpfc_restrict_login.attr,\n\t&dev_attr_lpfc_fcp_class.attr,\n\t&dev_attr_lpfc_use_adisc.attr,\n\t&dev_attr_lpfc_first_burst_size.attr,\n\t&dev_attr_lpfc_max_luns.attr,\n\t&dev_attr_nport_evt_cnt.attr,\n\t&dev_attr_npiv_info.attr,\n\t&dev_attr_lpfc_enable_da_id.attr,\n\t&dev_attr_lpfc_max_scsicmpl_time.attr,\n\t&dev_attr_lpfc_static_vport.attr,\n\t&dev_attr_cmf_info.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lpfc_vport_attr_group = {\n\t.attrs = lpfc_vport_attrs\n};\n\nconst struct attribute_group *lpfc_vport_groups[] = {\n\t&lpfc_vport_attr_group,\n\tNULL\n};\n\n \nstatic ssize_t\nsysfs_ctlreg_write(struct file *filp, struct kobject *kobj,\n\t\t   struct bin_attribute *bin_attr,\n\t\t   char *buf, loff_t off, size_t count)\n{\n\tsize_t buf_off;\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (phba->sli_rev >= LPFC_SLI_REV4)\n\t\treturn -EPERM;\n\n\tif ((off + count) > FF_REG_AREA_SIZE)\n\t\treturn -ERANGE;\n\n\tif (count <= LPFC_REG_WRITE_KEY_SIZE)\n\t\treturn 0;\n\n\tif (off % 4 || count % 4 || (unsigned long)buf % 4)\n\t\treturn -EINVAL;\n\n\t \n\tif (memcmp(buf, LPFC_REG_WRITE_KEY, LPFC_REG_WRITE_KEY_SIZE))\n\t\treturn -EINVAL;\n\n\tif (!(vport->fc_flag & FC_OFFLINE_MODE))\n\t\treturn -EPERM;\n\n\tspin_lock_irq(&phba->hbalock);\n\tfor (buf_off = 0; buf_off < count - LPFC_REG_WRITE_KEY_SIZE;\n\t\t\tbuf_off += sizeof(uint32_t))\n\t\twritel(*((uint32_t *)(buf + buf_off + LPFC_REG_WRITE_KEY_SIZE)),\n\t\t       phba->ctrl_regs_memmap_p + off + buf_off);\n\n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn count;\n}\n\n \nstatic ssize_t\nsysfs_ctlreg_read(struct file *filp, struct kobject *kobj,\n\t\t  struct bin_attribute *bin_attr,\n\t\t  char *buf, loff_t off, size_t count)\n{\n\tsize_t buf_off;\n\tuint32_t * tmp_ptr;\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host  *shost = class_to_shost(dev);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tif (phba->sli_rev >= LPFC_SLI_REV4)\n\t\treturn -EPERM;\n\n\tif (off > FF_REG_AREA_SIZE)\n\t\treturn -ERANGE;\n\n\tif ((off + count) > FF_REG_AREA_SIZE)\n\t\tcount = FF_REG_AREA_SIZE - off;\n\n\tif (count == 0) return 0;\n\n\tif (off % 4 || count % 4 || (unsigned long)buf % 4)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&phba->hbalock);\n\n\tfor (buf_off = 0; buf_off < count; buf_off += sizeof(uint32_t)) {\n\t\ttmp_ptr = (uint32_t *)(buf + buf_off);\n\t\t*tmp_ptr = readl(phba->ctrl_regs_memmap_p + off + buf_off);\n\t}\n\n\tspin_unlock_irq(&phba->hbalock);\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_ctlreg_attr = {\n\t.attr = {\n\t\t.name = \"ctlreg\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 256,\n\t.read = sysfs_ctlreg_read,\n\t.write = sysfs_ctlreg_write,\n};\n\n \nstatic ssize_t\nsysfs_mbox_write(struct file *filp, struct kobject *kobj,\n\t\t struct bin_attribute *bin_attr,\n\t\t char *buf, loff_t off, size_t count)\n{\n\treturn -EPERM;\n}\n\n \nstatic ssize_t\nsysfs_mbox_read(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *bin_attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\treturn -EPERM;\n}\n\nstatic struct bin_attribute sysfs_mbox_attr = {\n\t.attr = {\n\t\t.name = \"mbox\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = MAILBOX_SYSFS_MAX,\n\t.read = sysfs_mbox_read,\n\t.write = sysfs_mbox_write,\n};\n\n \nint\nlpfc_alloc_sysfs_attr(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tint error;\n\n\t \n\tif (vport->port_type == LPFC_NPIV_PORT)\n\t\treturn 0;\n\n\terror = sysfs_create_bin_file(&shost->shost_dev.kobj,\n\t\t\t\t      &sysfs_ctlreg_attr);\n\tif (error)\n\t\tgoto out;\n\n\terror = sysfs_create_bin_file(&shost->shost_dev.kobj,\n\t\t\t\t      &sysfs_mbox_attr);\n\tif (error)\n\t\tgoto out_remove_ctlreg_attr;\n\n\treturn 0;\nout_remove_ctlreg_attr:\n\tsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_ctlreg_attr);\nout:\n\treturn error;\n}\n\n \nvoid\nlpfc_free_sysfs_attr(struct lpfc_vport *vport)\n{\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\n\t \n\tif (vport->port_type == LPFC_NPIV_PORT)\n\t\treturn;\n\tsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_mbox_attr);\n\tsysfs_remove_bin_file(&shost->shost_dev.kobj, &sysfs_ctlreg_attr);\n}\n\n \n\n \nstatic void\nlpfc_get_host_symbolic_name(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)shost->hostdata;\n\n\tlpfc_vport_symbolic_node_name(vport, fc_host_symbolic_name(shost),\n\t\t\t\t      sizeof fc_host_symbolic_name(shost));\n}\n\n \nstatic void\nlpfc_get_host_port_id(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\n\t \n\tfc_host_port_id(shost) = vport->fc_myDID;\n}\n\n \nstatic void\nlpfc_get_host_port_type(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tif (vport->port_type == LPFC_NPIV_PORT) {\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\n\t} else if (lpfc_is_link_up(phba)) {\n\t\tif (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\t\tif (vport->fc_flag & FC_PUBLIC_LOOP)\n\t\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\n\t\t\telse\n\t\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_LPORT;\n\t\t} else {\n\t\t\tif (vport->fc_flag & FC_FABRIC)\n\t\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\n\t\t\telse\n\t\t\t\tfc_host_port_type(shost) = FC_PORTTYPE_PTP;\n\t\t}\n\t} else\n\t\tfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\n\n\tspin_unlock_irq(shost->host_lock);\n}\n\n \nstatic void\nlpfc_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tif (vport->fc_flag & FC_OFFLINE_MODE)\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n\telse {\n\t\tswitch (phba->link_state) {\n\t\tcase LPFC_LINK_UNKNOWN:\n\t\tcase LPFC_LINK_DOWN:\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_UP:\n\t\tcase LPFC_CLEAR_LA:\n\t\tcase LPFC_HBA_READY:\n\t\t\t \n\t\t\tif (vport->port_state < LPFC_VPORT_READY)\n\t\t\t\tfc_host_port_state(shost) =\n\t\t\t\t\t\t\tFC_PORTSTATE_BYPASSED;\n\t\t\telse\n\t\t\t\tfc_host_port_state(shost) =\n\t\t\t\t\t\t\tFC_PORTSTATE_ONLINE;\n\t\t\tbreak;\n\t\tcase LPFC_HBA_ERROR:\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irq(shost->host_lock);\n}\n\n \nstatic void\nlpfc_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tif ((lpfc_is_link_up(phba)) && (!(phba->hba_flag & HBA_FCOE_MODE))) {\n\t\tswitch(phba->fc_linkspeed) {\n\t\tcase LPFC_LINK_SPEED_1GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_2GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_2GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_4GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_4GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_8GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_8GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_10GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_16GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_16GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_32GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_32GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_64GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_64GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_128GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_128GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_LINK_SPEED_256GHZ:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_256GBIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else if (lpfc_is_link_up(phba) && (phba->hba_flag & HBA_FCOE_MODE)) {\n\t\tswitch (phba->fc_linkspeed) {\n\t\tcase LPFC_ASYNC_LINK_SPEED_1GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_1GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_10GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_10GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_20GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_20GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_25GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_25GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_40GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_40GBIT;\n\t\t\tbreak;\n\t\tcase LPFC_ASYNC_LINK_SPEED_100GBPS:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_100GBIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\n\n\tspin_unlock_irq(shost->host_lock);\n}\n\n \nstatic void\nlpfc_get_host_fabric_name (struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tu64 node_name;\n\n\tspin_lock_irq(shost->host_lock);\n\n\tif ((vport->port_state > LPFC_FLOGI) &&\n\t    ((vport->fc_flag & FC_FABRIC) ||\n\t     ((phba->fc_topology == LPFC_TOPOLOGY_LOOP) &&\n\t      (vport->fc_flag & FC_PUBLIC_LOOP))))\n\t\tnode_name = wwn_to_u64(phba->fc_fabparam.nodeName.u.wwn);\n\telse\n\t\t \n\t\tnode_name = 0;\n\n\tspin_unlock_irq(shost->host_lock);\n\n\tfc_host_fabric_name(shost) = node_name;\n}\n\n \nstatic struct fc_host_statistics *\nlpfc_get_stats(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_sli   *psli = &phba->sli;\n\tstruct fc_host_statistics *hs = &phba->link_stats;\n\tstruct lpfc_lnk_stat * lso = &psli->lnk_stat_offsets;\n\tLPFC_MBOXQ_t *pmboxq;\n\tMAILBOX_t *pmb;\n\tint rc = 0;\n\n\t \n\tif (phba->link_state < LPFC_LINK_DOWN ||\n\t    !phba->mbox_mem_pool ||\n\t    (phba->sli.sli_flag & LPFC_SLI_ACTIVE) == 0)\n\t\treturn NULL;\n\n\tif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\n\t\treturn NULL;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq)\n\t\treturn NULL;\n\tmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\n\tpmb = &pmboxq->u.mb;\n\tpmb->mbxCommand = MBX_READ_STATUS;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->ctx_buf = NULL;\n\tpmboxq->vport = vport;\n\n\tif (vport->fc_flag & FC_OFFLINE_MODE) {\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\tif (rc != MBX_TIMEOUT)\n\t\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tmemset(hs, 0, sizeof (struct fc_host_statistics));\n\n\ths->tx_frames = pmb->un.varRdStatus.xmitFrameCnt;\n\ths->rx_frames = pmb->un.varRdStatus.rcvFrameCnt;\n\n\t \n\tif (pmb->un.varRdStatus.xkb & RD_ST_XKB) {\n\t\ths->tx_words = (u64)\n\t\t\t       ((((u64)(pmb->un.varRdStatus.xmit_xkb &\n\t\t\t\t\tRD_ST_XMIT_XKB_MASK) << 32) |\n\t\t\t\t(u64)pmb->un.varRdStatus.xmitByteCnt) *\n\t\t\t\t(u64)256);\n\t\ths->rx_words = (u64)\n\t\t\t       ((((u64)(pmb->un.varRdStatus.rcv_xkb &\n\t\t\t\t\tRD_ST_RCV_XKB_MASK) << 32) |\n\t\t\t\t(u64)pmb->un.varRdStatus.rcvByteCnt) *\n\t\t\t\t(u64)256);\n\t} else {\n\t\ths->tx_words = (uint64_t)\n\t\t\t\t((uint64_t)pmb->un.varRdStatus.xmitByteCnt\n\t\t\t\t* (uint64_t)256);\n\t\ths->rx_words = (uint64_t)\n\t\t\t\t((uint64_t)pmb->un.varRdStatus.rcvByteCnt\n\t\t\t\t * (uint64_t)256);\n\t}\n\n\tmemset(pmboxq, 0, sizeof (LPFC_MBOXQ_t));\n\tpmb->mbxCommand = MBX_READ_LNK_STAT;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->ctx_buf = NULL;\n\tpmboxq->vport = vport;\n\n\tif (vport->fc_flag & FC_OFFLINE_MODE) {\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\tif (rc != MBX_TIMEOUT)\n\t\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\ths->link_failure_count = pmb->un.varRdLnk.linkFailureCnt;\n\ths->loss_of_sync_count = pmb->un.varRdLnk.lossSyncCnt;\n\ths->loss_of_signal_count = pmb->un.varRdLnk.lossSignalCnt;\n\ths->prim_seq_protocol_err_count = pmb->un.varRdLnk.primSeqErrCnt;\n\ths->invalid_tx_word_count = pmb->un.varRdLnk.invalidXmitWord;\n\ths->invalid_crc_count = pmb->un.varRdLnk.crcCnt;\n\ths->error_frames = pmb->un.varRdLnk.crcCnt;\n\n\ths->cn_sig_warn = atomic64_read(&phba->cgn_acqe_stat.warn);\n\ths->cn_sig_alarm = atomic64_read(&phba->cgn_acqe_stat.alarm);\n\n\ths->link_failure_count -= lso->link_failure_count;\n\ths->loss_of_sync_count -= lso->loss_of_sync_count;\n\ths->loss_of_signal_count -= lso->loss_of_signal_count;\n\ths->prim_seq_protocol_err_count -= lso->prim_seq_protocol_err_count;\n\ths->invalid_tx_word_count -= lso->invalid_tx_word_count;\n\ths->invalid_crc_count -= lso->invalid_crc_count;\n\ths->error_frames -= lso->error_frames;\n\n\tif (phba->hba_flag & HBA_FCOE_MODE) {\n\t\ths->lip_count = -1;\n\t\ths->nos_count = (phba->link_events >> 1);\n\t\ths->nos_count -= lso->link_events;\n\t} else if (phba->fc_topology == LPFC_TOPOLOGY_LOOP) {\n\t\ths->lip_count = (phba->fc_eventTag >> 1);\n\t\ths->lip_count -= lso->link_events;\n\t\ths->nos_count = -1;\n\t} else {\n\t\ths->lip_count = -1;\n\t\ths->nos_count = (phba->fc_eventTag >> 1);\n\t\ths->nos_count -= lso->link_events;\n\t}\n\n\ths->dumped_frames = -1;\n\n\ths->seconds_since_last_reset = ktime_get_seconds() - psli->stats_start;\n\n\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\treturn hs;\n}\n\n \nstatic void\nlpfc_reset_stats(struct Scsi_Host *shost)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_sli   *psli = &phba->sli;\n\tstruct lpfc_lnk_stat *lso = &psli->lnk_stat_offsets;\n\tLPFC_MBOXQ_t *pmboxq;\n\tMAILBOX_t *pmb;\n\tint rc = 0;\n\n\tif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO)\n\t\treturn;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq)\n\t\treturn;\n\tmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\n\tpmb = &pmboxq->u.mb;\n\tpmb->mbxCommand = MBX_READ_STATUS;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmb->un.varWords[0] = 0x1;  \n\tpmboxq->ctx_buf = NULL;\n\tpmboxq->vport = vport;\n\n\tif ((vport->fc_flag & FC_OFFLINE_MODE) ||\n\t\t(!(psli->sli_flag & LPFC_SLI_ACTIVE))) {\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\tif (rc != MBX_TIMEOUT)\n\t\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\tpmb->mbxCommand = MBX_READ_LNK_STAT;\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->ctx_buf = NULL;\n\tpmboxq->vport = vport;\n\n\tif ((vport->fc_flag & FC_OFFLINE_MODE) ||\n\t    (!(psli->sli_flag & LPFC_SLI_ACTIVE))) {\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\trc = lpfc_sli_issue_mbox_wait(phba, pmboxq, phba->fc_ratov * 2);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\tif (rc != MBX_TIMEOUT)\n\t\t\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlso->link_failure_count = pmb->un.varRdLnk.linkFailureCnt;\n\tlso->loss_of_sync_count = pmb->un.varRdLnk.lossSyncCnt;\n\tlso->loss_of_signal_count = pmb->un.varRdLnk.lossSignalCnt;\n\tlso->prim_seq_protocol_err_count = pmb->un.varRdLnk.primSeqErrCnt;\n\tlso->invalid_tx_word_count = pmb->un.varRdLnk.invalidXmitWord;\n\tlso->invalid_crc_count = pmb->un.varRdLnk.crcCnt;\n\tlso->error_frames = pmb->un.varRdLnk.crcCnt;\n\tif (phba->hba_flag & HBA_FCOE_MODE)\n\t\tlso->link_events = (phba->link_events >> 1);\n\telse\n\t\tlso->link_events = (phba->fc_eventTag >> 1);\n\n\tatomic64_set(&phba->cgn_acqe_stat.warn, 0);\n\tatomic64_set(&phba->cgn_acqe_stat.alarm, 0);\n\n\tmemset(&shost_to_fc_host(shost)->fpin_stats, 0,\n\t       sizeof(shost_to_fc_host(shost)->fpin_stats));\n\n\tpsli->stats_start = ktime_get_seconds();\n\n\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\treturn;\n}\n\n \n\n \nstatic struct lpfc_nodelist *\nlpfc_get_node_by_target(struct scsi_target *starget)\n{\n\tstruct Scsi_Host  *shost = dev_to_shost(starget->dev.parent);\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_nodelist *ndlp;\n\n\tspin_lock_irq(shost->host_lock);\n\t \n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tif (ndlp->nlp_state == NLP_STE_MAPPED_NODE &&\n\t\t    starget->id == ndlp->nlp_sid) {\n\t\t\tspin_unlock_irq(shost->host_lock);\n\t\t\treturn ndlp;\n\t\t}\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\treturn NULL;\n}\n\n \nstatic void\nlpfc_get_starget_port_id(struct scsi_target *starget)\n{\n\tstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\n\n\tfc_starget_port_id(starget) = ndlp ? ndlp->nlp_DID : -1;\n}\n\n \nstatic void\nlpfc_get_starget_node_name(struct scsi_target *starget)\n{\n\tstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\n\n\tfc_starget_node_name(starget) =\n\t\tndlp ? wwn_to_u64(ndlp->nlp_nodename.u.wwn) : 0;\n}\n\n \nstatic void\nlpfc_get_starget_port_name(struct scsi_target *starget)\n{\n\tstruct lpfc_nodelist *ndlp = lpfc_get_node_by_target(starget);\n\n\tfc_starget_port_name(starget) =\n\t\tndlp ? wwn_to_u64(ndlp->nlp_portname.u.wwn) : 0;\n}\n\n \nstatic void\nlpfc_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\n{\n\tstruct lpfc_rport_data *rdata = rport->dd_data;\n\tstruct lpfc_nodelist *ndlp = rdata->pnode;\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tstruct lpfc_nvme_rport *nrport = NULL;\n#endif\n\n\tif (timeout)\n\t\trport->dev_loss_tmo = timeout;\n\telse\n\t\trport->dev_loss_tmo = 1;\n\n\tif (!ndlp) {\n\t\tdev_info(&rport->dev, \"Cannot find remote node to \"\n\t\t\t\t      \"set rport dev loss tmo, port_id x%x\\n\",\n\t\t\t\t      rport->port_id);\n\t\treturn;\n\t}\n\n#if (IS_ENABLED(CONFIG_NVME_FC))\n\tnrport = lpfc_ndlp_get_nrport(ndlp);\n\n\tif (nrport && nrport->remoteport)\n\t\tnvme_fc_set_remoteport_devloss(nrport->remoteport,\n\t\t\t\t\t       rport->dev_loss_tmo);\n#endif\n}\n\n \n#define lpfc_rport_show_function(field, format_string, sz, cast)\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nlpfc_show_rport_##field (struct device *dev,\t\t\t\t\\\n\t\t\t struct device_attribute *attr,\t\t\t\\\n\t\t\t char *buf)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct fc_rport *rport = transport_class_to_rport(dev);\t\t\\\n\tstruct lpfc_rport_data *rdata = rport->hostdata;\t\t\\\n\treturn scnprintf(buf, sz, format_string,\t\t\t\\\n\t\t(rdata->target) ? cast rdata->target->field : 0);\t\\\n}\n\n#define lpfc_rport_rd_attr(field, format_string, sz)\t\t\t\\\n\tlpfc_rport_show_function(field, format_string, sz, )\t\t\\\nstatic FC_RPORT_ATTR(field, S_IRUGO, lpfc_show_rport_##field, NULL)\n\n \nstatic void\nlpfc_set_vport_symbolic_name(struct fc_vport *fc_vport)\n{\n\tstruct lpfc_vport *vport = *(struct lpfc_vport **)fc_vport->dd_data;\n\n\tif (vport->port_state == LPFC_VPORT_READY)\n\t\tlpfc_ns_cmd(vport, SLI_CTNS_RSPN_ID, 0, 0);\n}\n\n \nstatic void\nlpfc_hba_log_verbose_init(struct lpfc_hba *phba, uint32_t verbose)\n{\n\tphba->cfg_log_verbose = verbose;\n}\n\nstruct fc_function_template lpfc_transport_functions = {\n\t \n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.get_host_symbolic_name = lpfc_get_host_symbolic_name,\n\t.show_host_symbolic_name = 1,\n\n\t \n\t.get_host_port_id = lpfc_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t.get_host_port_type = lpfc_get_host_port_type,\n\t.show_host_port_type = 1,\n\n\t.get_host_port_state = lpfc_get_host_port_state,\n\t.show_host_port_state = 1,\n\n\t \n\t.show_host_active_fc4s = 1,\n\n\t.get_host_speed = lpfc_get_host_speed,\n\t.show_host_speed = 1,\n\n\t.get_host_fabric_name = lpfc_get_host_fabric_name,\n\t.show_host_fabric_name = 1,\n\n\t \n\n\t.get_fc_host_stats = lpfc_get_stats,\n\t.reset_fc_host_stats = lpfc_reset_stats,\n\n\t.dd_fcrport_size = sizeof(struct lpfc_rport_data),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.set_rport_dev_loss_tmo = lpfc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.get_starget_port_id  = lpfc_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\n\t.get_starget_node_name = lpfc_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\n\t.get_starget_port_name = lpfc_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t.issue_fc_host_lip = lpfc_issue_lip,\n\t.dev_loss_tmo_callbk = lpfc_dev_loss_tmo_callbk,\n\t.terminate_rport_io = lpfc_terminate_rport_io,\n\n\t.dd_fcvport_size = sizeof(struct lpfc_vport *),\n\n\t.vport_disable = lpfc_vport_disable,\n\n\t.set_vport_symbolic_name = lpfc_set_vport_symbolic_name,\n\n\t.bsg_request = lpfc_bsg_request,\n\t.bsg_timeout = lpfc_bsg_timeout,\n};\n\nstruct fc_function_template lpfc_vport_transport_functions = {\n\t \n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t.get_host_symbolic_name = lpfc_get_host_symbolic_name,\n\t.show_host_symbolic_name = 1,\n\n\t \n\t.get_host_port_id = lpfc_get_host_port_id,\n\t.show_host_port_id = 1,\n\n\t.get_host_port_type = lpfc_get_host_port_type,\n\t.show_host_port_type = 1,\n\n\t.get_host_port_state = lpfc_get_host_port_state,\n\t.show_host_port_state = 1,\n\n\t \n\t.show_host_active_fc4s = 1,\n\n\t.get_host_speed = lpfc_get_host_speed,\n\t.show_host_speed = 1,\n\n\t.get_host_fabric_name = lpfc_get_host_fabric_name,\n\t.show_host_fabric_name = 1,\n\n\t \n\n\t.get_fc_host_stats = lpfc_get_stats,\n\t.reset_fc_host_stats = lpfc_reset_stats,\n\n\t.dd_fcrport_size = sizeof(struct lpfc_rport_data),\n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\n\t.set_rport_dev_loss_tmo = lpfc_set_rport_loss_tmo,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t.get_starget_port_id  = lpfc_get_starget_port_id,\n\t.show_starget_port_id = 1,\n\n\t.get_starget_node_name = lpfc_get_starget_node_name,\n\t.show_starget_node_name = 1,\n\n\t.get_starget_port_name = lpfc_get_starget_port_name,\n\t.show_starget_port_name = 1,\n\n\t.dev_loss_tmo_callbk = lpfc_dev_loss_tmo_callbk,\n\t.terminate_rport_io = lpfc_terminate_rport_io,\n\n\t.vport_disable = lpfc_vport_disable,\n\n\t.set_vport_symbolic_name = lpfc_set_vport_symbolic_name,\n};\n\n \nstatic void\nlpfc_get_hba_function_mode(struct lpfc_hba *phba)\n{\n\t \n\tswitch (phba->pcidev->device) {\n\tcase PCI_DEVICE_ID_SKYHAWK:\n\tcase PCI_DEVICE_ID_SKYHAWK_VF:\n\tcase PCI_DEVICE_ID_LANCER_FCOE:\n\tcase PCI_DEVICE_ID_LANCER_FCOE_VF:\n\tcase PCI_DEVICE_ID_ZEPHYR_DCSP:\n\tcase PCI_DEVICE_ID_TIGERSHARK:\n\tcase PCI_DEVICE_ID_TOMCAT:\n\t\tphba->hba_flag |= HBA_FCOE_MODE;\n\t\tbreak;\n\tdefault:\n\t \n\t\tphba->hba_flag &= ~HBA_FCOE_MODE;\n\t}\n}\n\n \nvoid\nlpfc_get_cfgparam(struct lpfc_hba *phba)\n{\n\tlpfc_hba_log_verbose_init(phba, lpfc_log_verbose);\n\tlpfc_fcp_io_sched_init(phba, lpfc_fcp_io_sched);\n\tlpfc_ns_query_init(phba, lpfc_ns_query);\n\tlpfc_fcp2_no_tgt_reset_init(phba, lpfc_fcp2_no_tgt_reset);\n\tlpfc_cr_delay_init(phba, lpfc_cr_delay);\n\tlpfc_cr_count_init(phba, lpfc_cr_count);\n\tlpfc_multi_ring_support_init(phba, lpfc_multi_ring_support);\n\tlpfc_multi_ring_rctl_init(phba, lpfc_multi_ring_rctl);\n\tlpfc_multi_ring_type_init(phba, lpfc_multi_ring_type);\n\tlpfc_ack0_init(phba, lpfc_ack0);\n\tlpfc_xri_rebalancing_init(phba, lpfc_xri_rebalancing);\n\tlpfc_topology_init(phba, lpfc_topology);\n\tlpfc_link_speed_init(phba, lpfc_link_speed);\n\tlpfc_poll_tmo_init(phba, lpfc_poll_tmo);\n\tlpfc_task_mgmt_tmo_init(phba, lpfc_task_mgmt_tmo);\n\tlpfc_enable_npiv_init(phba, lpfc_enable_npiv);\n\tlpfc_fcf_failover_policy_init(phba, lpfc_fcf_failover_policy);\n\tlpfc_enable_rrq_init(phba, lpfc_enable_rrq);\n\tlpfc_fcp_wait_abts_rsp_init(phba, lpfc_fcp_wait_abts_rsp);\n\tlpfc_fdmi_on_init(phba, lpfc_fdmi_on);\n\tlpfc_enable_SmartSAN_init(phba, lpfc_enable_SmartSAN);\n\tlpfc_use_msi_init(phba, lpfc_use_msi);\n\tlpfc_nvme_oas_init(phba, lpfc_nvme_oas);\n\tlpfc_nvme_embed_cmd_init(phba, lpfc_nvme_embed_cmd);\n\tlpfc_fcp_imax_init(phba, lpfc_fcp_imax);\n\tlpfc_force_rscn_init(phba, lpfc_force_rscn);\n\tlpfc_cq_poll_threshold_init(phba, lpfc_cq_poll_threshold);\n\tlpfc_cq_max_proc_limit_init(phba, lpfc_cq_max_proc_limit);\n\tlpfc_fcp_cpu_map_init(phba, lpfc_fcp_cpu_map);\n\tlpfc_enable_hba_reset_init(phba, lpfc_enable_hba_reset);\n\tlpfc_enable_hba_heartbeat_init(phba, lpfc_enable_hba_heartbeat);\n\n\tlpfc_EnableXLane_init(phba, lpfc_EnableXLane);\n\t \n\tlpfc_max_vmid_init(phba, lpfc_max_vmid);\n\tlpfc_vmid_inactivity_timeout_init(phba, lpfc_vmid_inactivity_timeout);\n\tlpfc_vmid_app_header_init(phba, lpfc_vmid_app_header);\n\tlpfc_vmid_priority_tagging_init(phba, lpfc_vmid_priority_tagging);\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\tphba->cfg_EnableXLane = 0;\n\tlpfc_XLanePriority_init(phba, lpfc_XLanePriority);\n\n\tmemset(phba->cfg_oas_tgt_wwpn, 0, (8 * sizeof(uint8_t)));\n\tmemset(phba->cfg_oas_vpt_wwpn, 0, (8 * sizeof(uint8_t)));\n\tphba->cfg_oas_lun_state = 0;\n\tphba->cfg_oas_lun_status = 0;\n\tphba->cfg_oas_flags = 0;\n\tphba->cfg_oas_priority = 0;\n\tlpfc_enable_bg_init(phba, lpfc_enable_bg);\n\tlpfc_prot_mask_init(phba, lpfc_prot_mask);\n\tlpfc_prot_guard_init(phba, lpfc_prot_guard);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tphba->cfg_poll = 0;\n\telse\n\t\tphba->cfg_poll = lpfc_poll;\n\n\t \n\tlpfc_get_hba_function_mode(phba);\n\n\t \n\tif (phba->cfg_enable_bg && phba->hba_flag & HBA_FCOE_MODE) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\"0581 BlockGuard feature not supported\\n\");\n\t\t \n\t\tphba->cfg_enable_bg = 0;\n\t} else if (phba->cfg_enable_bg) {\n\t\tphba->sli3_options |= LPFC_SLI3_BG_ENABLED;\n\t}\n\n\tlpfc_suppress_rsp_init(phba, lpfc_suppress_rsp);\n\n\tlpfc_enable_fc4_type_init(phba, lpfc_enable_fc4_type);\n\tlpfc_nvmet_mrq_init(phba, lpfc_nvmet_mrq);\n\tlpfc_nvmet_mrq_post_init(phba, lpfc_nvmet_mrq_post);\n\n\t \n\tlpfc_nvme_enable_fb_init(phba, lpfc_nvme_enable_fb);\n\tlpfc_nvmet_fb_size_init(phba, lpfc_nvmet_fb_size);\n\tlpfc_fcp_mq_threshold_init(phba, lpfc_fcp_mq_threshold);\n\tlpfc_hdw_queue_init(phba, lpfc_hdw_queue);\n\tlpfc_irq_chann_init(phba, lpfc_irq_chann);\n\tlpfc_enable_bbcr_init(phba, lpfc_enable_bbcr);\n\tlpfc_enable_dpp_init(phba, lpfc_enable_dpp);\n\tlpfc_enable_mi_init(phba, lpfc_enable_mi);\n\n\tphba->cgn_p.cgn_param_mode = LPFC_CFG_OFF;\n\tphba->cmf_active_mode = LPFC_CFG_OFF;\n\tif (lpfc_fabric_cgn_frequency > EDC_CG_SIGFREQ_CNT_MAX ||\n\t   lpfc_fabric_cgn_frequency < EDC_CG_SIGFREQ_CNT_MIN)\n\t\tlpfc_fabric_cgn_frequency = 100;  \n\n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\t \n\t\tphba->nvmet_support = 0;\n\t\tphba->cfg_nvmet_mrq = 0;\n\t\tphba->cfg_enable_fc4_type = LPFC_ENABLE_FCP;\n\t\tphba->cfg_enable_bbcr = 0;\n\t\tphba->cfg_xri_rebalancing = 0;\n\t} else {\n\t\t \n\t\tif (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP))\n\t\t\tphba->cfg_enable_fc4_type |= LPFC_ENABLE_FCP;\n\t}\n\n\tphba->cfg_auto_imax = (phba->cfg_fcp_imax) ? 0 : 1;\n\n\tphba->cfg_enable_pbde = 0;\n\n\t \n\tif (phba->cfg_hdw_queue == 0)\n\t\tphba->cfg_hdw_queue = phba->sli4_hba.num_present_cpu;\n\tif (phba->cfg_irq_chann == 0)\n\t\tphba->cfg_irq_chann = phba->sli4_hba.num_present_cpu;\n\tif (phba->cfg_irq_chann > phba->cfg_hdw_queue &&\n\t    phba->sli_rev == LPFC_SLI_REV4)\n\t\tphba->cfg_irq_chann = phba->cfg_hdw_queue;\n\n\tlpfc_sg_seg_cnt_init(phba, lpfc_sg_seg_cnt);\n\tlpfc_hba_queue_depth_init(phba, lpfc_hba_queue_depth);\n\tlpfc_sriov_nr_virtfn_init(phba, lpfc_sriov_nr_virtfn);\n\tlpfc_request_firmware_upgrade_init(phba, lpfc_req_fw_upgrade);\n\tlpfc_suppress_link_up_init(phba, lpfc_suppress_link_up);\n\tlpfc_delay_discovery_init(phba, lpfc_delay_discovery);\n\tlpfc_sli_mode_init(phba, lpfc_sli_mode);\n\tlpfc_enable_mds_diags_init(phba, lpfc_enable_mds_diags);\n\tlpfc_ras_fwlog_buffsize_init(phba, lpfc_ras_fwlog_buffsize);\n\tlpfc_ras_fwlog_level_init(phba, lpfc_ras_fwlog_level);\n\tlpfc_ras_fwlog_func_init(phba, lpfc_ras_fwlog_func);\n\n\treturn;\n}\n\n \nvoid\nlpfc_nvme_mod_param_dep(struct lpfc_hba *phba)\n{\n\tint  logit = 0;\n\n\tif (phba->cfg_hdw_queue > phba->sli4_hba.num_present_cpu) {\n\t\tphba->cfg_hdw_queue = phba->sli4_hba.num_present_cpu;\n\t\tlogit = 1;\n\t}\n\tif (phba->cfg_irq_chann > phba->sli4_hba.num_present_cpu) {\n\t\tphba->cfg_irq_chann = phba->sli4_hba.num_present_cpu;\n\t\tlogit = 1;\n\t}\n\tif (phba->cfg_irq_chann > phba->cfg_hdw_queue) {\n\t\tphba->cfg_irq_chann = phba->cfg_hdw_queue;\n\t\tlogit = 1;\n\t}\n\tif (logit)\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_SLI,\n\t\t\t\t\"2006 Reducing Queues - CPU limitation: \"\n\t\t\t\t\"IRQ %d HDWQ %d\\n\",\n\t\t\t\tphba->cfg_irq_chann,\n\t\t\t\tphba->cfg_hdw_queue);\n\n\tif (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME &&\n\t    phba->nvmet_support) {\n\t\tphba->cfg_enable_fc4_type &= ~LPFC_ENABLE_FCP;\n\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_NVME_DISC,\n\t\t\t\t\"6013 %s x%x fb_size x%x, fb_max x%x\\n\",\n\t\t\t\t\"NVME Target PRLI ACC enable_fb \",\n\t\t\t\tphba->cfg_nvme_enable_fb,\n\t\t\t\tphba->cfg_nvmet_fb_size,\n\t\t\t\tLPFC_NVMET_FB_SZ_MAX);\n\n\t\tif (phba->cfg_nvme_enable_fb == 0)\n\t\t\tphba->cfg_nvmet_fb_size = 0;\n\t\telse {\n\t\t\tif (phba->cfg_nvmet_fb_size > LPFC_NVMET_FB_SZ_MAX)\n\t\t\t\tphba->cfg_nvmet_fb_size = LPFC_NVMET_FB_SZ_MAX;\n\t\t}\n\n\t\tif (!phba->cfg_nvmet_mrq)\n\t\t\tphba->cfg_nvmet_mrq = phba->cfg_hdw_queue;\n\n\t\t \n\t\tif (phba->cfg_nvmet_mrq > phba->cfg_hdw_queue) {\n\t\t\tphba->cfg_nvmet_mrq = phba->cfg_hdw_queue;\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_NVME_DISC,\n\t\t\t\t\t\"6018 Adjust lpfc_nvmet_mrq to %d\\n\",\n\t\t\t\t\tphba->cfg_nvmet_mrq);\n\t\t}\n\t\tif (phba->cfg_nvmet_mrq > LPFC_NVMET_MRQ_MAX)\n\t\t\tphba->cfg_nvmet_mrq = LPFC_NVMET_MRQ_MAX;\n\n\t} else {\n\t\t \n\t\tphba->nvmet_support = 0;\n\t\tphba->cfg_nvmet_mrq = 0;\n\t\tphba->cfg_nvmet_fb_size = 0;\n\t}\n}\n\n \nvoid\nlpfc_get_vport_cfgparam(struct lpfc_vport *vport)\n{\n\tlpfc_log_verbose_init(vport, lpfc_log_verbose);\n\tlpfc_lun_queue_depth_init(vport, lpfc_lun_queue_depth);\n\tlpfc_tgt_queue_depth_init(vport, lpfc_tgt_queue_depth);\n\tlpfc_devloss_tmo_init(vport, lpfc_devloss_tmo);\n\tlpfc_nodev_tmo_init(vport, lpfc_nodev_tmo);\n\tlpfc_peer_port_login_init(vport, lpfc_peer_port_login);\n\tlpfc_restrict_login_init(vport, lpfc_restrict_login);\n\tlpfc_fcp_class_init(vport, lpfc_fcp_class);\n\tlpfc_use_adisc_init(vport, lpfc_use_adisc);\n\tlpfc_first_burst_size_init(vport, lpfc_first_burst_size);\n\tlpfc_max_scsicmpl_time_init(vport, lpfc_max_scsicmpl_time);\n\tlpfc_discovery_threads_init(vport, lpfc_discovery_threads);\n\tlpfc_max_luns_init(vport, lpfc_max_luns);\n\tlpfc_scan_down_init(vport, lpfc_scan_down);\n\tlpfc_enable_da_id_init(vport, lpfc_enable_da_id);\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}