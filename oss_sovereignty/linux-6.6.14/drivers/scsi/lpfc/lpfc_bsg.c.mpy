{
  "module_name": "lpfc_bsg.c",
  "hash_id": "e6ec2acb8fe081518d8bd4aba9d69b20acc742f0d2944ff9c77805b225502f39",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_bsg.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/mempool.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/bsg-lib.h>\n#include <linux/vmalloc.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/scsi_bsg_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_bsg.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_debugfs.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_version.h\"\n\nstruct lpfc_bsg_event {\n\tstruct list_head node;\n\tstruct kref kref;\n\twait_queue_head_t wq;\n\n\t \n\tuint32_t type_mask;\n\tuint32_t req_id;\n\tuint32_t reg_id;\n\n\t \n\tunsigned long wait_time_stamp;\n\tint waiting;\n\n\t \n\tstruct list_head events_to_get;\n\tstruct list_head events_to_see;\n\n\t \n\tvoid *dd_data;\n};\n\nstruct lpfc_bsg_iocb {\n\tstruct lpfc_iocbq *cmdiocbq;\n\tstruct lpfc_dmabuf *rmp;\n\tstruct lpfc_nodelist *ndlp;\n};\n\nstruct lpfc_bsg_mbox {\n\tLPFC_MBOXQ_t *pmboxq;\n\tMAILBOX_t *mb;\n\tstruct lpfc_dmabuf *dmabuffers;  \n\tuint8_t *ext;  \n\tuint32_t mbOffset;  \n\tuint32_t inExtWLen;  \n\tuint32_t outExtWLen;  \n};\n\n#define TYPE_EVT \t1\n#define TYPE_IOCB\t2\n#define TYPE_MBOX\t3\nstruct bsg_job_data {\n\tuint32_t type;\n\tstruct bsg_job *set_job;  \n\tunion {\n\t\tstruct lpfc_bsg_event *evt;\n\t\tstruct lpfc_bsg_iocb iocb;\n\t\tstruct lpfc_bsg_mbox mbox;\n\t} context_un;\n};\n\nstruct event_data {\n\tstruct list_head node;\n\tuint32_t type;\n\tuint32_t immed_dat;\n\tvoid *data;\n\tuint32_t len;\n};\n\n#define BUF_SZ_4K 4096\n#define SLI_CT_ELX_LOOPBACK 0x10\n\nenum ELX_LOOPBACK_CMD {\n\tELX_LOOPBACK_XRI_SETUP,\n\tELX_LOOPBACK_DATA,\n};\n\n#define ELX_LOOPBACK_HEADER_SZ \\\n\t(size_t)(&((struct lpfc_sli_ct_request *)NULL)->un)\n\nstruct lpfc_dmabufext {\n\tstruct lpfc_dmabuf dma;\n\tuint32_t size;\n\tuint32_t flag;\n};\n\nstatic void\nlpfc_free_bsg_buffers(struct lpfc_hba *phba, struct lpfc_dmabuf *mlist)\n{\n\tstruct lpfc_dmabuf *mlast, *next_mlast;\n\n\tif (mlist) {\n\t\tlist_for_each_entry_safe(mlast, next_mlast, &mlist->list,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&mlast->list);\n\t\t\tlpfc_mbuf_free(phba, mlast->virt, mlast->phys);\n\t\t\tkfree(mlast);\n\t\t}\n\t\tlpfc_mbuf_free(phba, mlist->virt, mlist->phys);\n\t\tkfree(mlist);\n\t}\n\treturn;\n}\n\nstatic struct lpfc_dmabuf *\nlpfc_alloc_bsg_buffers(struct lpfc_hba *phba, unsigned int size,\n\t\t       int outbound_buffers, struct ulp_bde64 *bpl,\n\t\t       int *bpl_entries)\n{\n\tstruct lpfc_dmabuf *mlist = NULL;\n\tstruct lpfc_dmabuf *mp;\n\tunsigned int bytes_left = size;\n\n\t \n\tif (!size || (size > (*bpl_entries * LPFC_BPL_SIZE)))\n\t\treturn NULL;\n\n\t \n\t*bpl_entries = (size % LPFC_BPL_SIZE ? size/LPFC_BPL_SIZE + 1 :\n\t\t\tsize/LPFC_BPL_SIZE);\n\n\t \n\twhile (bytes_left) {\n\t\t \n\t\tmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\t\tif (!mp) {\n\t\t\tif (mlist)\n\t\t\t\tlpfc_free_bsg_buffers(phba, mlist);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&mp->list);\n\t\tmp->virt = lpfc_mbuf_alloc(phba, MEM_PRI, &(mp->phys));\n\n\t\tif (!mp->virt) {\n\t\t\tkfree(mp);\n\t\t\tif (mlist)\n\t\t\t\tlpfc_free_bsg_buffers(phba, mlist);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (!mlist)\n\t\t\tmlist = mp;\n\t\telse\n\t\t\tlist_add_tail(&mp->list, &mlist->list);\n\n\t\t \n\t\tif (outbound_buffers)\n\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\telse\n\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\n\t\tbpl->addrLow = le32_to_cpu(putPaddrLow(mp->phys));\n\t\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(mp->phys));\n\t\tbpl->tus.f.bdeSize = (uint16_t)\n\t\t\t(bytes_left >= LPFC_BPL_SIZE ? LPFC_BPL_SIZE :\n\t\t\t bytes_left);\n\t\tbytes_left -= bpl->tus.f.bdeSize;\n\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t\tbpl++;\n\t}\n\treturn mlist;\n}\n\nstatic unsigned int\nlpfc_bsg_copy_data(struct lpfc_dmabuf *dma_buffers,\n\t\t   struct bsg_buffer *bsg_buffers,\n\t\t   unsigned int bytes_to_transfer, int to_buffers)\n{\n\n\tstruct lpfc_dmabuf *mp;\n\tunsigned int transfer_bytes, bytes_copied = 0;\n\tunsigned int sg_offset, dma_offset;\n\tunsigned char *dma_address, *sg_address;\n\tLIST_HEAD(temp_list);\n\tstruct sg_mapping_iter miter;\n\tunsigned long flags;\n\tunsigned int sg_flags = SG_MITER_ATOMIC;\n\tbool sg_valid;\n\n\tlist_splice_init(&dma_buffers->list, &temp_list);\n\tlist_add(&dma_buffers->list, &temp_list);\n\tsg_offset = 0;\n\tif (to_buffers)\n\t\tsg_flags |= SG_MITER_FROM_SG;\n\telse\n\t\tsg_flags |= SG_MITER_TO_SG;\n\tsg_miter_start(&miter, bsg_buffers->sg_list, bsg_buffers->sg_cnt,\n\t\t       sg_flags);\n\tlocal_irq_save(flags);\n\tsg_valid = sg_miter_next(&miter);\n\tlist_for_each_entry(mp, &temp_list, list) {\n\t\tdma_offset = 0;\n\t\twhile (bytes_to_transfer && sg_valid &&\n\t\t       (dma_offset < LPFC_BPL_SIZE)) {\n\t\t\tdma_address = mp->virt + dma_offset;\n\t\t\tif (sg_offset) {\n\t\t\t\t \n\t\t\t\tsg_address = miter.addr + sg_offset;\n\t\t\t\ttransfer_bytes = miter.length - sg_offset;\n\t\t\t} else {\n\t\t\t\tsg_address = miter.addr;\n\t\t\t\ttransfer_bytes = miter.length;\n\t\t\t}\n\t\t\tif (bytes_to_transfer < transfer_bytes)\n\t\t\t\ttransfer_bytes = bytes_to_transfer;\n\t\t\tif (transfer_bytes > (LPFC_BPL_SIZE - dma_offset))\n\t\t\t\ttransfer_bytes = LPFC_BPL_SIZE - dma_offset;\n\t\t\tif (to_buffers)\n\t\t\t\tmemcpy(dma_address, sg_address, transfer_bytes);\n\t\t\telse\n\t\t\t\tmemcpy(sg_address, dma_address, transfer_bytes);\n\t\t\tdma_offset += transfer_bytes;\n\t\t\tsg_offset += transfer_bytes;\n\t\t\tbytes_to_transfer -= transfer_bytes;\n\t\t\tbytes_copied += transfer_bytes;\n\t\t\tif (sg_offset >= miter.length) {\n\t\t\t\tsg_offset = 0;\n\t\t\t\tsg_valid = sg_miter_next(&miter);\n\t\t\t}\n\t\t}\n\t}\n\tsg_miter_stop(&miter);\n\tlocal_irq_restore(flags);\n\tlist_del_init(&dma_buffers->list);\n\tlist_splice(&temp_list, &dma_buffers->list);\n\treturn bytes_copied;\n}\n\n \nstatic void\nlpfc_bsg_send_mgmt_cmd_cmp(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_iocbq *cmdiocbq,\n\t\t\tstruct lpfc_iocbq *rspiocbq)\n{\n\tstruct bsg_job_data *dd_data;\n\tstruct bsg_job *job;\n\tstruct fc_bsg_reply *bsg_reply;\n\tstruct lpfc_dmabuf *bmp, *cmp, *rmp;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_bsg_iocb *iocb;\n\tunsigned long flags;\n\tint rc = 0;\n\tu32 ulp_status, ulp_word4, total_data_placed;\n\n\tdd_data = cmdiocbq->context_un.dd_data;\n\n\t \n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tjob = dd_data->set_job;\n\tif (job) {\n\t\tbsg_reply = job->reply;\n\t\t \n\t\tjob->dd_data = NULL;\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\t \n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tcmdiocbq->cmd_flag &= ~LPFC_IO_CMD_OUTSTANDING;\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\n\tiocb = &dd_data->context_un.iocb;\n\tndlp = iocb->cmdiocbq->ndlp;\n\trmp = iocb->rmp;\n\tcmp = cmdiocbq->cmd_dmabuf;\n\tbmp = cmdiocbq->bpl_dmabuf;\n\tulp_status = get_job_ulpstatus(phba, rspiocbq);\n\tulp_word4 = get_job_word4(phba, rspiocbq);\n\ttotal_data_placed = get_job_data_placed(phba, rspiocbq);\n\n\t \n\n\tif (job) {\n\t\tif (ulp_status) {\n\t\t\tif (ulp_status == IOSTAT_LOCAL_REJECT) {\n\t\t\t\tswitch (ulp_word4 & IOERR_PARAM_MASK) {\n\t\t\t\tcase IOERR_SEQUENCE_TIMEOUT:\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IOERR_INVALID_RPI:\n\t\t\t\t\trc = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\trc = -EACCES;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = -EACCES;\n\t\t\t}\n\t\t} else {\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tlpfc_bsg_copy_data(rmp, &job->reply_payload,\n\t\t\t\t\t\t   total_data_placed, 0);\n\t\t}\n\t}\n\n\tlpfc_free_bsg_buffers(phba, cmp);\n\tlpfc_free_bsg_buffers(phba, rmp);\n\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\n\tkfree(bmp);\n\tlpfc_nlp_put(ndlp);\n\tlpfc_sli_release_iocbq(phba, cmdiocbq);\n\tkfree(dd_data);\n\n\t \n\n\tif (job) {\n\t\tbsg_reply->result = rc;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t}\n\treturn;\n}\n\n \nstatic int\nlpfc_bsg_send_mgmt_cmd(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_rport_data *rdata = fc_bsg_to_rport(job)->dd_data;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_nodelist *ndlp = rdata->pnode;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct ulp_bde64 *bpl = NULL;\n\tstruct lpfc_iocbq *cmdiocbq = NULL;\n\tstruct lpfc_dmabuf *bmp = NULL, *cmp = NULL, *rmp = NULL;\n\tint request_nseg, reply_nseg;\n\tu32 num_entry;\n\tstruct bsg_job_data *dd_data;\n\tunsigned long flags;\n\tuint32_t creg_val;\n\tint rc = 0;\n\tint iocb_stat;\n\tu16 ulp_context;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (ndlp->nlp_flag & NLP_ELS_SND_MASK)\n\t\treturn -ENODEV;\n\n\t \n\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\tif (!dd_data) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2733 Failed allocation of dd_data\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto no_dd_data;\n\t}\n\n\tcmdiocbq = lpfc_sli_get_iocbq(phba);\n\tif (!cmdiocbq) {\n\t\trc = -ENOMEM;\n\t\tgoto free_dd;\n\t}\n\n\tbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (!bmp) {\n\t\trc = -ENOMEM;\n\t\tgoto free_cmdiocbq;\n\t}\n\tbmp->virt = lpfc_mbuf_alloc(phba, 0, &bmp->phys);\n\tif (!bmp->virt) {\n\t\trc = -ENOMEM;\n\t\tgoto free_bmp;\n\t}\n\n\tINIT_LIST_HEAD(&bmp->list);\n\n\tbpl = (struct ulp_bde64 *) bmp->virt;\n\trequest_nseg = LPFC_BPL_SIZE/sizeof(struct ulp_bde64);\n\tcmp = lpfc_alloc_bsg_buffers(phba, job->request_payload.payload_len,\n\t\t\t\t     1, bpl, &request_nseg);\n\tif (!cmp) {\n\t\trc = -ENOMEM;\n\t\tgoto free_bmp;\n\t}\n\tlpfc_bsg_copy_data(cmp, &job->request_payload,\n\t\t\t   job->request_payload.payload_len, 1);\n\n\tbpl += request_nseg;\n\treply_nseg = LPFC_BPL_SIZE/sizeof(struct ulp_bde64) - request_nseg;\n\trmp = lpfc_alloc_bsg_buffers(phba, job->reply_payload.payload_len, 0,\n\t\t\t\t     bpl, &reply_nseg);\n\tif (!rmp) {\n\t\trc = -ENOMEM;\n\t\tgoto free_cmp;\n\t}\n\n\tnum_entry = request_nseg + reply_nseg;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tulp_context = phba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\n\telse\n\t\tulp_context = ndlp->nlp_rpi;\n\n\tlpfc_sli_prep_gen_req(phba, cmdiocbq, bmp, ulp_context, num_entry,\n\t\t\t      phba->fc_ratov * 2);\n\n\tcmdiocbq->num_bdes = num_entry;\n\tcmdiocbq->vport = phba->pport;\n\tcmdiocbq->cmd_dmabuf = cmp;\n\tcmdiocbq->bpl_dmabuf = bmp;\n\tcmdiocbq->cmd_flag |= LPFC_IO_LIBDFC;\n\n\tcmdiocbq->cmd_cmpl = lpfc_bsg_send_mgmt_cmd_cmp;\n\tcmdiocbq->context_un.dd_data = dd_data;\n\n\tdd_data->type = TYPE_IOCB;\n\tdd_data->set_job = job;\n\tdd_data->context_un.iocb.cmdiocbq = cmdiocbq;\n\tdd_data->context_un.iocb.rmp = rmp;\n\tjob->dd_data = dd_data;\n\n\tif (phba->cfg_poll & DISABLE_FCP_RING_INT) {\n\t\tif (lpfc_readl(phba->HCregaddr, &creg_val)) {\n\t\t\trc = -EIO ;\n\t\t\tgoto free_rmp;\n\t\t}\n\t\tcreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\n\t\twritel(creg_val, phba->HCregaddr);\n\t\treadl(phba->HCregaddr);  \n\t}\n\n\tcmdiocbq->ndlp = lpfc_nlp_get(ndlp);\n\tif (!cmdiocbq->ndlp) {\n\t\trc = -ENODEV;\n\t\tgoto free_rmp;\n\t}\n\n\tiocb_stat = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq, 0);\n\tif (iocb_stat == IOCB_SUCCESS) {\n\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\t \n\t\tif (cmdiocbq->cmd_flag & LPFC_IO_LIBDFC) {\n\t\t\t \n\t\t\tcmdiocbq->cmd_flag |= LPFC_IO_CMD_OUTSTANDING;\n\t\t}\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\treturn 0;  \n\t} else if (iocb_stat == IOCB_BUSY) {\n\t\trc = -EAGAIN;\n\t} else {\n\t\trc = -EIO;\n\t}\n\n\t \n\tlpfc_nlp_put(ndlp);\n\nfree_rmp:\n\tlpfc_free_bsg_buffers(phba, rmp);\nfree_cmp:\n\tlpfc_free_bsg_buffers(phba, cmp);\nfree_bmp:\n\tif (bmp->virt)\n\t\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\n\tkfree(bmp);\nfree_cmdiocbq:\n\tlpfc_sli_release_iocbq(phba, cmdiocbq);\nfree_dd:\n\tkfree(dd_data);\nno_dd_data:\n\t \n\tbsg_reply->result = rc;\n\tjob->dd_data = NULL;\n\treturn rc;\n}\n\n \nstatic void\nlpfc_bsg_rport_els_cmp(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_iocbq *cmdiocbq,\n\t\t\tstruct lpfc_iocbq *rspiocbq)\n{\n\tstruct bsg_job_data *dd_data;\n\tstruct bsg_job *job;\n\tstruct fc_bsg_reply *bsg_reply;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_dmabuf *pcmd = NULL, *prsp = NULL;\n\tstruct fc_bsg_ctels_reply *els_reply;\n\tuint8_t *rjt_data;\n\tunsigned long flags;\n\tunsigned int rsp_size;\n\tint rc = 0;\n\tu32 ulp_status, ulp_word4, total_data_placed;\n\n\tdd_data = cmdiocbq->context_un.dd_data;\n\tndlp = dd_data->context_un.iocb.ndlp;\n\tcmdiocbq->ndlp = ndlp;\n\n\t \n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tjob = dd_data->set_job;\n\tif (job) {\n\t\tbsg_reply = job->reply;\n\t\t \n\t\tjob->dd_data = NULL;\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\t \n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tcmdiocbq->cmd_flag &= ~LPFC_IO_CMD_OUTSTANDING;\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\n\tulp_status = get_job_ulpstatus(phba, rspiocbq);\n\tulp_word4 = get_job_word4(phba, rspiocbq);\n\ttotal_data_placed = get_job_data_placed(phba, rspiocbq);\n\tpcmd = cmdiocbq->cmd_dmabuf;\n\tprsp = (struct lpfc_dmabuf *)pcmd->list.next;\n\n\t \n\n\tif (job) {\n\t\tif (ulp_status == IOSTAT_SUCCESS) {\n\t\t\trsp_size = total_data_placed;\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t\t\t    prsp->virt,\n\t\t\t\t\t\t    rsp_size);\n\t\t} else if (ulp_status == IOSTAT_LS_RJT) {\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tsizeof(struct fc_bsg_ctels_reply);\n\t\t\t \n\t\t\trjt_data = (uint8_t *)&ulp_word4;\n\t\t\tels_reply = &bsg_reply->reply_data.ctels_reply;\n\t\t\tels_reply->status = FC_CTELS_STATUS_REJECT;\n\t\t\tels_reply->rjt_data.action = rjt_data[3];\n\t\t\tels_reply->rjt_data.reason_code = rjt_data[2];\n\t\t\tels_reply->rjt_data.reason_explanation = rjt_data[1];\n\t\t\tels_reply->rjt_data.vendor_unique = rjt_data[0];\n\t\t} else if (ulp_status == IOSTAT_LOCAL_REJECT &&\n\t\t\t   (ulp_word4 & IOERR_PARAM_MASK) ==\n\t\t\t   IOERR_SEQUENCE_TIMEOUT) {\n\t\t\trc = -ETIMEDOUT;\n\t\t} else {\n\t\t\trc = -EIO;\n\t\t}\n\t}\n\n\tlpfc_els_free_iocb(phba, cmdiocbq);\n\n\tlpfc_nlp_put(ndlp);\n\tkfree(dd_data);\n\n\t \n\n\tif (job) {\n\t\tbsg_reply->result = rc;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t}\n\treturn;\n}\n\n \nstatic int\nlpfc_bsg_rport_els(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_rport_data *rdata = fc_bsg_to_rport(job)->dd_data;\n\tstruct lpfc_nodelist *ndlp = rdata->pnode;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tuint32_t elscmd;\n\tuint32_t cmdsize;\n\tstruct lpfc_iocbq *cmdiocbq;\n\tuint16_t rpi = 0;\n\tstruct bsg_job_data *dd_data;\n\tunsigned long flags;\n\tuint32_t creg_val;\n\tint rc = 0;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\t \n\n\tif (job->request_payload.payload_len > FCELSSIZE) {\n\t\trc = -EINVAL;\n\t\tgoto no_dd_data;\n\t}\n\n\t \n\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\tif (!dd_data) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2735 Failed allocation of dd_data\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto no_dd_data;\n\t}\n\n\telscmd = bsg_request->rqst_data.r_els.els_code;\n\tcmdsize = job->request_payload.payload_len;\n\n\tif (!lpfc_nlp_get(ndlp)) {\n\t\trc = -ENODEV;\n\t\tgoto free_dd_data;\n\t}\n\n\t \n\tcmdiocbq = lpfc_prep_els_iocb(vport, 1, cmdsize, 0, ndlp,\n\t\t\t\t      ndlp->nlp_DID, elscmd);\n\tif (!cmdiocbq) {\n\t\trc = -EIO;\n\t\tgoto release_ndlp;\n\t}\n\n\t \n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt,\n\t\t\t  cmdiocbq->cmd_dmabuf->virt,\n\t\t\t  cmdsize);\n\n\trpi = ndlp->nlp_rpi;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tbf_set(wqe_ctxt_tag, &cmdiocbq->wqe.generic.wqe_com,\n\t\t       phba->sli4_hba.rpi_ids[rpi]);\n\telse\n\t\tcmdiocbq->iocb.ulpContext = rpi;\n\tcmdiocbq->cmd_flag |= LPFC_IO_LIBDFC;\n\tcmdiocbq->context_un.dd_data = dd_data;\n\tcmdiocbq->ndlp = ndlp;\n\tcmdiocbq->cmd_cmpl = lpfc_bsg_rport_els_cmp;\n\tdd_data->type = TYPE_IOCB;\n\tdd_data->set_job = job;\n\tdd_data->context_un.iocb.cmdiocbq = cmdiocbq;\n\tdd_data->context_un.iocb.ndlp = ndlp;\n\tdd_data->context_un.iocb.rmp = NULL;\n\tjob->dd_data = dd_data;\n\n\tif (phba->cfg_poll & DISABLE_FCP_RING_INT) {\n\t\tif (lpfc_readl(phba->HCregaddr, &creg_val)) {\n\t\t\trc = -EIO;\n\t\t\tgoto linkdown_err;\n\t\t}\n\t\tcreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\n\t\twritel(creg_val, phba->HCregaddr);\n\t\treadl(phba->HCregaddr);  \n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq, 0);\n\tif (rc == IOCB_SUCCESS) {\n\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\t \n\t\tif (cmdiocbq->cmd_flag & LPFC_IO_LIBDFC) {\n\t\t\t \n\t\t\tcmdiocbq->cmd_flag |= LPFC_IO_CMD_OUTSTANDING;\n\t\t}\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\treturn 0;  \n\t} else if (rc == IOCB_BUSY) {\n\t\trc = -EAGAIN;\n\t} else {\n\t\trc = -EIO;\n\t}\n\n\t \n\nlinkdown_err:\n\tlpfc_els_free_iocb(phba, cmdiocbq);\n\nrelease_ndlp:\n\tlpfc_nlp_put(ndlp);\n\nfree_dd_data:\n\tkfree(dd_data);\n\nno_dd_data:\n\t \n\tbsg_reply->result = rc;\n\tjob->dd_data = NULL;\n\treturn rc;\n}\n\n \nstatic void\nlpfc_bsg_event_free(struct kref *kref)\n{\n\tstruct lpfc_bsg_event *evt = container_of(kref, struct lpfc_bsg_event,\n\t\t\t\t\t\t  kref);\n\tstruct event_data *ed;\n\n\tlist_del(&evt->node);\n\n\twhile (!list_empty(&evt->events_to_get)) {\n\t\ted = list_entry(evt->events_to_get.next, typeof(*ed), node);\n\t\tlist_del(&ed->node);\n\t\tkfree(ed->data);\n\t\tkfree(ed);\n\t}\n\n\twhile (!list_empty(&evt->events_to_see)) {\n\t\ted = list_entry(evt->events_to_see.next, typeof(*ed), node);\n\t\tlist_del(&ed->node);\n\t\tkfree(ed->data);\n\t\tkfree(ed);\n\t}\n\n\tkfree(evt->dd_data);\n\tkfree(evt);\n}\n\n \nstatic inline void\nlpfc_bsg_event_ref(struct lpfc_bsg_event *evt)\n{\n\tkref_get(&evt->kref);\n}\n\n \nstatic inline void\nlpfc_bsg_event_unref(struct lpfc_bsg_event *evt)\n{\n\tkref_put(&evt->kref, lpfc_bsg_event_free);\n}\n\n \nstatic struct lpfc_bsg_event *\nlpfc_bsg_event_new(uint32_t ev_mask, int ev_reg_id, uint32_t ev_req_id)\n{\n\tstruct lpfc_bsg_event *evt = kzalloc(sizeof(*evt), GFP_KERNEL);\n\n\tif (!evt)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&evt->events_to_get);\n\tINIT_LIST_HEAD(&evt->events_to_see);\n\tevt->type_mask = ev_mask;\n\tevt->req_id = ev_req_id;\n\tevt->reg_id = ev_reg_id;\n\tevt->wait_time_stamp = jiffies;\n\tevt->dd_data = NULL;\n\tinit_waitqueue_head(&evt->wq);\n\tkref_init(&evt->kref);\n\treturn evt;\n}\n\n \nstatic int\ndiag_cmd_data_free(struct lpfc_hba *phba, struct lpfc_dmabufext *mlist)\n{\n\tstruct lpfc_dmabufext *mlast;\n\tstruct pci_dev *pcidev;\n\tstruct list_head head, *curr, *next;\n\n\tif ((!mlist) || (!lpfc_is_link_up(phba) &&\n\t\t(phba->link_flag & LS_LOOPBACK_MODE))) {\n\t\treturn 0;\n\t}\n\n\tpcidev = phba->pcidev;\n\tlist_add_tail(&head, &mlist->dma.list);\n\n\tlist_for_each_safe(curr, next, &head) {\n\t\tmlast = list_entry(curr, struct lpfc_dmabufext , dma.list);\n\t\tif (mlast->dma.virt)\n\t\t\tdma_free_coherent(&pcidev->dev,\n\t\t\t\t\t  mlast->size,\n\t\t\t\t\t  mlast->dma.virt,\n\t\t\t\t\t  mlast->dma.phys);\n\t\tkfree(mlast);\n\t}\n\treturn 0;\n}\n\n \nint\nlpfc_bsg_ct_unsol_event(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,\n\t\t\tstruct lpfc_iocbq *piocbq)\n{\n\tuint32_t evt_req_id = 0;\n\tu16 cmd;\n\tstruct lpfc_dmabuf *dmabuf = NULL;\n\tstruct lpfc_bsg_event *evt;\n\tstruct event_data *evt_dat = NULL;\n\tstruct lpfc_iocbq *iocbq;\n\tIOCB_t *iocb = NULL;\n\tsize_t offset = 0;\n\tstruct list_head head;\n\tstruct ulp_bde64 *bde;\n\tdma_addr_t dma_addr;\n\tint i;\n\tstruct lpfc_dmabuf *bdeBuf1 = piocbq->cmd_dmabuf;\n\tstruct lpfc_dmabuf *bdeBuf2 = piocbq->bpl_dmabuf;\n\tstruct lpfc_sli_ct_request *ct_req;\n\tstruct bsg_job *job = NULL;\n\tstruct fc_bsg_reply *bsg_reply;\n\tstruct bsg_job_data *dd_data = NULL;\n\tunsigned long flags;\n\tint size = 0;\n\tu32 bde_count = 0;\n\n\tINIT_LIST_HEAD(&head);\n\tlist_add_tail(&head, &piocbq->list);\n\n\tct_req = (struct lpfc_sli_ct_request *)bdeBuf1->virt;\n\tevt_req_id = ct_req->FsType;\n\tcmd = be16_to_cpu(ct_req->CommandResponse.bits.CmdRsp);\n\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tlist_for_each_entry(evt, &phba->ct_ev_waiters, node) {\n\t\tif (!(evt->type_mask & FC_REG_CT_EVENT) ||\n\t\t\tevt->req_id != evt_req_id)\n\t\t\tcontinue;\n\n\t\tlpfc_bsg_event_ref(evt);\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\tevt_dat = kzalloc(sizeof(*evt_dat), GFP_KERNEL);\n\t\tif (evt_dat == NULL) {\n\t\t\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\t\t\tlpfc_bsg_event_unref(evt);\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\t\"2614 Memory allocation failed for \"\n\t\t\t\t\t\"CT event\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\n\t\t\t \n\t\t\tiocbq = list_entry(head.prev, typeof(*iocbq), list);\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\tevt_dat->len = iocbq->wcqe_cmpl.total_data_placed;\n\t\t\telse\n\t\t\t\tevt_dat->len = iocbq->iocb.unsli3.rcvsli3.acc_len;\n\t\t} else {\n\t\t\tlist_for_each_entry(iocbq, &head, list) {\n\t\t\t\tiocb = &iocbq->iocb;\n\t\t\t\tfor (i = 0; i < iocb->ulpBdeCount;\n\t\t\t\t     i++)\n\t\t\t\t\tevt_dat->len +=\n\t\t\t\t\tiocb->un.cont64[i].tus.f.bdeSize;\n\t\t\t}\n\t\t}\n\n\t\tevt_dat->data = kzalloc(evt_dat->len, GFP_KERNEL);\n\t\tif (evt_dat->data == NULL) {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\t\"2615 Memory allocation failed for \"\n\t\t\t\t\t\"CT event data, size %d\\n\",\n\t\t\t\t\tevt_dat->len);\n\t\t\tkfree(evt_dat);\n\t\t\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\t\t\tlpfc_bsg_event_unref(evt);\n\t\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\t\tgoto error_ct_unsol_exit;\n\t\t}\n\n\t\tlist_for_each_entry(iocbq, &head, list) {\n\t\t\tsize = 0;\n\t\t\tif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\n\t\t\t\tbdeBuf1 = iocbq->cmd_dmabuf;\n\t\t\t\tbdeBuf2 = iocbq->bpl_dmabuf;\n\t\t\t}\n\t\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\tbde_count = iocbq->wcqe_cmpl.word3;\n\t\t\telse\n\t\t\t\tbde_count = iocbq->iocb.ulpBdeCount;\n\t\t\tfor (i = 0; i < bde_count; i++) {\n\t\t\t\tif (phba->sli3_options &\n\t\t\t\t    LPFC_SLI3_HBQ_ENABLED) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\tsize = iocbq->wqe.gen_req.bde.tus.f.bdeSize;\n\t\t\t\t\t\tdmabuf = bdeBuf1;\n\t\t\t\t\t} else if (i == 1) {\n\t\t\t\t\t\tsize = iocbq->unsol_rcv_len;\n\t\t\t\t\t\tdmabuf = bdeBuf2;\n\t\t\t\t\t}\n\t\t\t\t\tif ((offset + size) > evt_dat->len)\n\t\t\t\t\t\tsize = evt_dat->len - offset;\n\t\t\t\t} else {\n\t\t\t\t\tsize = iocbq->iocb.un.cont64[i].\n\t\t\t\t\t\ttus.f.bdeSize;\n\t\t\t\t\tbde = &iocbq->iocb.un.cont64[i];\n\t\t\t\t\tdma_addr = getPaddr(bde->addrHigh,\n\t\t\t\t\t\t\t    bde->addrLow);\n\t\t\t\t\tdmabuf = lpfc_sli_ringpostbuf_get(phba,\n\t\t\t\t\t\t\tpring, dma_addr);\n\t\t\t\t}\n\t\t\t\tif (!dmabuf) {\n\t\t\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\t\tLOG_LIBDFC, \"2616 No dmabuf \"\n\t\t\t\t\t\t\"found for iocbq x%px\\n\",\n\t\t\t\t\t\tiocbq);\n\t\t\t\t\tkfree(evt_dat->data);\n\t\t\t\t\tkfree(evt_dat);\n\t\t\t\t\tspin_lock_irqsave(&phba->ct_ev_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tlpfc_bsg_event_unref(evt);\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t&phba->ct_ev_lock, flags);\n\t\t\t\t\tgoto error_ct_unsol_exit;\n\t\t\t\t}\n\t\t\t\tmemcpy((char *)(evt_dat->data) + offset,\n\t\t\t\t       dmabuf->virt, size);\n\t\t\t\toffset += size;\n\t\t\t\tif (evt_req_id != SLI_CT_ELX_LOOPBACK &&\n\t\t\t\t    !(phba->sli3_options &\n\t\t\t\t      LPFC_SLI3_HBQ_ENABLED)) {\n\t\t\t\t\tlpfc_sli_ringpostbuf_put(phba, pring,\n\t\t\t\t\t\t\t\t dmabuf);\n\t\t\t\t} else {\n\t\t\t\t\tswitch (cmd) {\n\t\t\t\t\tcase ELX_LOOPBACK_DATA:\n\t\t\t\t\t\tif (phba->sli_rev <\n\t\t\t\t\t\t    LPFC_SLI_REV4)\n\t\t\t\t\t\t\tdiag_cmd_data_free(phba,\n\t\t\t\t\t\t\t(struct lpfc_dmabufext\n\t\t\t\t\t\t\t *)dmabuf);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ELX_LOOPBACK_XRI_SETUP:\n\t\t\t\t\t\tif ((phba->sli_rev ==\n\t\t\t\t\t\t\tLPFC_SLI_REV2) ||\n\t\t\t\t\t\t\t(phba->sli3_options &\n\t\t\t\t\t\t\tLPFC_SLI3_HBQ_ENABLED\n\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tlpfc_in_buf_free(phba,\n\t\t\t\t\t\t\t\t\tdmabuf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlpfc_sli3_post_buffer(phba,\n\t\t\t\t\t\t\t\t\t      pring,\n\t\t\t\t\t\t\t\t\t      1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (!(phba->sli3_options &\n\t\t\t\t\t\t      LPFC_SLI3_HBQ_ENABLED))\n\t\t\t\t\t\t\tlpfc_sli3_post_buffer(phba,\n\t\t\t\t\t\t\t\t\t      pring,\n\t\t\t\t\t\t\t\t\t      1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\tevt_dat->immed_dat = phba->ctx_idx;\n\t\t\tphba->ctx_idx = (phba->ctx_idx + 1) % LPFC_CT_CTX_MAX;\n\t\t\t \n\t\t\tif (phba->ct_ctx[evt_dat->immed_dat].valid ==\n\t\t\t    UNSOL_VALID)\n\t\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_ELS,\n\t\t\t\t\t\t\"2717 CT context array entry \"\n\t\t\t\t\t\t\"[%d] over-run: oxid:x%x, \"\n\t\t\t\t\t\t\"sid:x%x\\n\", phba->ctx_idx,\n\t\t\t\t\t\tphba->ct_ctx[\n\t\t\t\t\t\t    evt_dat->immed_dat].oxid,\n\t\t\t\t\t\tphba->ct_ctx[\n\t\t\t\t\t\t    evt_dat->immed_dat].SID);\n\t\t\tphba->ct_ctx[evt_dat->immed_dat].rxid =\n\t\t\t\tget_job_ulpcontext(phba, piocbq);\n\t\t\tphba->ct_ctx[evt_dat->immed_dat].oxid =\n\t\t\t\tget_job_rcvoxid(phba, piocbq);\n\t\t\tphba->ct_ctx[evt_dat->immed_dat].SID =\n\t\t\t\tbf_get(wqe_els_did,\n\t\t\t\t       &piocbq->wqe.xmit_els_rsp.wqe_dest);\n\t\t\tphba->ct_ctx[evt_dat->immed_dat].valid = UNSOL_VALID;\n\t\t} else\n\t\t\tevt_dat->immed_dat = get_job_ulpcontext(phba, piocbq);\n\n\t\tevt_dat->type = FC_REG_CT_EVENT;\n\t\tlist_add(&evt_dat->node, &evt->events_to_see);\n\t\tif (evt_req_id == SLI_CT_ELX_LOOPBACK) {\n\t\t\twake_up_interruptible(&evt->wq);\n\t\t\tlpfc_bsg_event_unref(evt);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_move(evt->events_to_see.prev, &evt->events_to_get);\n\n\t\tdd_data = (struct bsg_job_data *)evt->dd_data;\n\t\tjob = dd_data->set_job;\n\t\tdd_data->set_job = NULL;\n\t\tlpfc_bsg_event_unref(evt);\n\t\tif (job) {\n\t\t\tbsg_reply = job->reply;\n\t\t\tbsg_reply->reply_payload_rcv_len = size;\n\t\t\t \n\t\t\tbsg_reply->result = 0;\n\t\t\tjob->dd_data = NULL;\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t\t\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\nerror_ct_unsol_exit:\n\tif (!list_empty(&head))\n\t\tlist_del(&head);\n\tif ((phba->sli_rev < LPFC_SLI_REV4) &&\n\t    (evt_req_id == SLI_CT_ELX_LOOPBACK))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nint\nlpfc_bsg_ct_unsol_abort(struct lpfc_hba *phba, struct hbq_dmabuf *dmabuf)\n{\n\tstruct fc_frame_header fc_hdr;\n\tstruct fc_frame_header *fc_hdr_ptr = &fc_hdr;\n\tint ctx_idx, handled = 0;\n\tuint16_t oxid, rxid;\n\tuint32_t sid;\n\n\tmemcpy(fc_hdr_ptr, dmabuf->hbuf.virt, sizeof(struct fc_frame_header));\n\tsid = sli4_sid_from_fc_hdr(fc_hdr_ptr);\n\toxid = be16_to_cpu(fc_hdr_ptr->fh_ox_id);\n\trxid = be16_to_cpu(fc_hdr_ptr->fh_rx_id);\n\n\tfor (ctx_idx = 0; ctx_idx < LPFC_CT_CTX_MAX; ctx_idx++) {\n\t\tif (phba->ct_ctx[ctx_idx].valid != UNSOL_VALID)\n\t\t\tcontinue;\n\t\tif (phba->ct_ctx[ctx_idx].rxid != rxid)\n\t\t\tcontinue;\n\t\tif (phba->ct_ctx[ctx_idx].oxid != oxid)\n\t\t\tcontinue;\n\t\tif (phba->ct_ctx[ctx_idx].SID != sid)\n\t\t\tcontinue;\n\t\tphba->ct_ctx[ctx_idx].valid = UNSOL_INVALID;\n\t\thandled = 1;\n\t}\n\treturn handled;\n}\n\n \nstatic int\nlpfc_bsg_hba_set_event(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct set_ct_event *event_req;\n\tstruct lpfc_bsg_event *evt;\n\tint rc = 0;\n\tstruct bsg_job_data *dd_data = NULL;\n\tuint32_t ev_mask;\n\tunsigned long flags;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) + sizeof(struct set_ct_event)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2612 Received SET_CT_EVENT below minimum \"\n\t\t\t\t\"size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tevent_req = (struct set_ct_event *)\n\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\tev_mask = ((uint32_t)(unsigned long)event_req->type_mask &\n\t\t\t\tFC_REG_EVENT_MASK);\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tlist_for_each_entry(evt, &phba->ct_ev_waiters, node) {\n\t\tif (evt->reg_id == event_req->ev_reg_id) {\n\t\t\tlpfc_bsg_event_ref(evt);\n\t\t\tevt->wait_time_stamp = jiffies;\n\t\t\tdd_data = (struct bsg_job_data *)evt->dd_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\tif (&evt->node == &phba->ct_ev_waiters) {\n\t\t \n\t\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\t\tif (dd_data == NULL) {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\t\"2734 Failed allocation of dd_data\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto job_error;\n\t\t}\n\t\tevt = lpfc_bsg_event_new(ev_mask, event_req->ev_reg_id,\n\t\t\t\t\tevent_req->ev_req_id);\n\t\tif (!evt) {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\t\"2617 Failed allocation of event \"\n\t\t\t\t\t\"waiter\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto job_error;\n\t\t}\n\t\tdd_data->type = TYPE_EVT;\n\t\tdd_data->set_job = NULL;\n\t\tdd_data->context_un.evt = evt;\n\t\tevt->dd_data = (void *)dd_data;\n\t\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\t\tlist_add(&evt->node, &phba->ct_ev_waiters);\n\t\tlpfc_bsg_event_ref(evt);\n\t\tevt->wait_time_stamp = jiffies;\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t}\n\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tevt->waiting = 1;\n\tdd_data->set_job = job;  \n\tjob->dd_data = dd_data;  \n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\treturn 0;  \n\njob_error:\n\tkfree(dd_data);\n\tjob->dd_data = NULL;\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_hba_get_event(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct get_ct_event *event_req;\n\tstruct get_ct_event_reply *event_reply;\n\tstruct lpfc_bsg_event *evt, *evt_next;\n\tstruct event_data *evt_dat = NULL;\n\tunsigned long flags;\n\tuint32_t rc = 0;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) + sizeof(struct get_ct_event)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2613 Received GET_CT_EVENT request below \"\n\t\t\t\t\"minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tevent_req = (struct get_ct_event *)\n\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\n\tevent_reply = (struct get_ct_event_reply *)\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp;\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tlist_for_each_entry_safe(evt, evt_next, &phba->ct_ev_waiters, node) {\n\t\tif (evt->reg_id == event_req->ev_reg_id) {\n\t\t\tif (list_empty(&evt->events_to_get))\n\t\t\t\tbreak;\n\t\t\tlpfc_bsg_event_ref(evt);\n\t\t\tevt->wait_time_stamp = jiffies;\n\t\t\tevt_dat = list_entry(evt->events_to_get.prev,\n\t\t\t\t\t     struct event_data, node);\n\t\t\tlist_del(&evt_dat->node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\t \n\tif (evt_dat == NULL) {\n\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t\trc = -ENOENT;\n\t\tgoto job_error;\n\t}\n\n\tif (evt_dat->len > job->request_payload.payload_len) {\n\t\tevt_dat->len = job->request_payload.payload_len;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2618 Truncated event data at %d \"\n\t\t\t\t\"bytes\\n\",\n\t\t\t\tjob->request_payload.payload_len);\n\t}\n\n\tevent_reply->type = evt_dat->type;\n\tevent_reply->immed_data = evt_dat->immed_dat;\n\tif (evt_dat->len > 0)\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(job->request_payload.sg_list,\n\t\t\t\t\t    job->request_payload.sg_cnt,\n\t\t\t\t\t    evt_dat->data, evt_dat->len);\n\telse\n\t\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (evt_dat) {\n\t\tkfree(evt_dat->data);\n\t\tkfree(evt_dat);\n\t}\n\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tlpfc_bsg_event_unref(evt);\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\tjob->dd_data = NULL;\n\tbsg_reply->result = 0;\n\tbsg_job_done(job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn 0;\n\njob_error:\n\tjob->dd_data = NULL;\n\tbsg_reply->result = rc;\n\treturn rc;\n}\n\n \nstatic void\nlpfc_issue_ct_rsp_cmp(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_iocbq *cmdiocbq,\n\t\t\tstruct lpfc_iocbq *rspiocbq)\n{\n\tstruct bsg_job_data *dd_data;\n\tstruct bsg_job *job;\n\tstruct fc_bsg_reply *bsg_reply;\n\tstruct lpfc_dmabuf *bmp, *cmp;\n\tstruct lpfc_nodelist *ndlp;\n\tunsigned long flags;\n\tint rc = 0;\n\tu32 ulp_status, ulp_word4;\n\n\tdd_data = cmdiocbq->context_un.dd_data;\n\n\t \n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tjob = dd_data->set_job;\n\tif (job) {\n\t\t \n\t\tjob->dd_data = NULL;\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\t \n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tcmdiocbq->cmd_flag &= ~LPFC_IO_CMD_OUTSTANDING;\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\n\tndlp = dd_data->context_un.iocb.ndlp;\n\tcmp = cmdiocbq->cmd_dmabuf;\n\tbmp = cmdiocbq->bpl_dmabuf;\n\n\tulp_status = get_job_ulpstatus(phba, rspiocbq);\n\tulp_word4 = get_job_word4(phba, rspiocbq);\n\n\t \n\n\tif (job) {\n\t\tbsg_reply = job->reply;\n\t\tif (ulp_status) {\n\t\t\tif (ulp_status == IOSTAT_LOCAL_REJECT) {\n\t\t\t\tswitch (ulp_word4 & IOERR_PARAM_MASK) {\n\t\t\t\tcase IOERR_SEQUENCE_TIMEOUT:\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IOERR_INVALID_RPI:\n\t\t\t\t\trc = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\trc = -EACCES;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = -EACCES;\n\t\t\t}\n\t\t} else {\n\t\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t\t}\n\t}\n\n\tlpfc_free_bsg_buffers(phba, cmp);\n\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\n\tkfree(bmp);\n\tlpfc_sli_release_iocbq(phba, cmdiocbq);\n\tlpfc_nlp_put(ndlp);\n\tkfree(dd_data);\n\n\t \n\n\tif (job) {\n\t\tbsg_reply->result = rc;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t}\n\treturn;\n}\n\n \nstatic int\nlpfc_issue_ct_rsp(struct lpfc_hba *phba, struct bsg_job *job, uint32_t tag,\n\t\t  struct lpfc_dmabuf *cmp, struct lpfc_dmabuf *bmp,\n\t\t  int num_entry)\n{\n\tstruct lpfc_iocbq *ctiocb = NULL;\n\tint rc = 0;\n\tstruct lpfc_nodelist *ndlp = NULL;\n\tstruct bsg_job_data *dd_data;\n\tunsigned long flags;\n\tuint32_t creg_val;\n\tu16 ulp_context, iotag;\n\n\tndlp = lpfc_findnode_did(phba->pport, phba->ct_ctx[tag].SID);\n\tif (!ndlp) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_ELS,\n\t\t\t\t\"2721 ndlp null for oxid %x SID %x\\n\",\n\t\t\t\tphba->ct_ctx[tag].rxid,\n\t\t\t\tphba->ct_ctx[tag].SID);\n\t\treturn IOCB_ERROR;\n\t}\n\n\t \n\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\tif (!dd_data) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2736 Failed allocation of dd_data\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto no_dd_data;\n\t}\n\n\t \n\tctiocb = lpfc_sli_get_iocbq(phba);\n\tif (!ctiocb) {\n\t\trc = -ENOMEM;\n\t\tgoto no_ctiocb;\n\t}\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t \n\t\tif (phba->ct_ctx[tag].valid != UNSOL_VALID) {\n\t\t\trc = IOCB_ERROR;\n\t\t\tgoto issue_ct_rsp_exit;\n\t\t}\n\n\t\tlpfc_sli_prep_xmit_seq64(phba, ctiocb, bmp,\n\t\t\t\t\t phba->sli4_hba.rpi_ids[ndlp->nlp_rpi],\n\t\t\t\t\t phba->ct_ctx[tag].oxid, num_entry,\n\t\t\t\t\t FC_RCTL_DD_SOL_CTL, 1,\n\t\t\t\t\t CMD_XMIT_SEQUENCE64_WQE);\n\n\t\t \n\t\tphba->ct_ctx[tag].valid = UNSOL_INVALID;\n\t\tiotag = get_wqe_reqtag(ctiocb);\n\t} else {\n\t\tlpfc_sli_prep_xmit_seq64(phba, ctiocb, bmp, 0, tag, num_entry,\n\t\t\t\t\t FC_RCTL_DD_SOL_CTL, 1,\n\t\t\t\t\t CMD_XMIT_SEQUENCE64_CX);\n\t\tctiocb->num_bdes = num_entry;\n\t\tiotag = ctiocb->iocb.ulpIoTag;\n\t}\n\n\tulp_context = get_job_ulpcontext(phba, ctiocb);\n\n\t \n\tlpfc_printf_log(phba, KERN_INFO, LOG_ELS,\n\t\t\t\"2722 Xmit CT response on exchange x%x Data: x%x x%x x%x\\n\",\n\t\t\tulp_context, iotag, tag, phba->link_state);\n\n\tctiocb->cmd_flag |= LPFC_IO_LIBDFC;\n\tctiocb->vport = phba->pport;\n\tctiocb->context_un.dd_data = dd_data;\n\tctiocb->cmd_dmabuf = cmp;\n\tctiocb->bpl_dmabuf = bmp;\n\tctiocb->ndlp = ndlp;\n\tctiocb->cmd_cmpl = lpfc_issue_ct_rsp_cmp;\n\n\tdd_data->type = TYPE_IOCB;\n\tdd_data->set_job = job;\n\tdd_data->context_un.iocb.cmdiocbq = ctiocb;\n\tdd_data->context_un.iocb.ndlp = lpfc_nlp_get(ndlp);\n\tif (!dd_data->context_un.iocb.ndlp) {\n\t\trc = -IOCB_ERROR;\n\t\tgoto issue_ct_rsp_exit;\n\t}\n\tdd_data->context_un.iocb.rmp = NULL;\n\tjob->dd_data = dd_data;\n\n\tif (phba->cfg_poll & DISABLE_FCP_RING_INT) {\n\t\tif (lpfc_readl(phba->HCregaddr, &creg_val)) {\n\t\t\trc = -IOCB_ERROR;\n\t\t\tgoto issue_ct_rsp_exit;\n\t\t}\n\t\tcreg_val |= (HC_R0INT_ENA << LPFC_FCP_RING);\n\t\twritel(creg_val, phba->HCregaddr);\n\t\treadl(phba->HCregaddr);  \n\t}\n\n\trc = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, ctiocb, 0);\n\tif (rc == IOCB_SUCCESS) {\n\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\t \n\t\tif (ctiocb->cmd_flag & LPFC_IO_LIBDFC) {\n\t\t\t \n\t\t\tctiocb->cmd_flag |= LPFC_IO_CMD_OUTSTANDING;\n\t\t}\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\treturn 0;  \n\t}\n\n\t \n\tjob->dd_data = NULL;\n\tlpfc_nlp_put(ndlp);\n\nissue_ct_rsp_exit:\n\tlpfc_sli_release_iocbq(phba, ctiocb);\nno_ctiocb:\n\tkfree(dd_data);\nno_dd_data:\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_send_mgmt_rsp(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct send_mgmt_resp *mgmt_resp = (struct send_mgmt_resp *)\n\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\tstruct ulp_bde64 *bpl;\n\tstruct lpfc_dmabuf *bmp = NULL, *cmp = NULL;\n\tint bpl_entries;\n\tuint32_t tag = mgmt_resp->tag;\n\tunsigned long reqbfrcnt =\n\t\t\t(unsigned long)job->request_payload.payload_len;\n\tint rc = 0;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (!reqbfrcnt || (reqbfrcnt > (80 * BUF_SZ_4K))) {\n\t\trc = -ERANGE;\n\t\tgoto send_mgmt_rsp_exit;\n\t}\n\n\tbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (!bmp) {\n\t\trc = -ENOMEM;\n\t\tgoto send_mgmt_rsp_exit;\n\t}\n\n\tbmp->virt = lpfc_mbuf_alloc(phba, 0, &bmp->phys);\n\tif (!bmp->virt) {\n\t\trc = -ENOMEM;\n\t\tgoto send_mgmt_rsp_free_bmp;\n\t}\n\n\tINIT_LIST_HEAD(&bmp->list);\n\tbpl = (struct ulp_bde64 *) bmp->virt;\n\tbpl_entries = (LPFC_BPL_SIZE/sizeof(struct ulp_bde64));\n\tcmp = lpfc_alloc_bsg_buffers(phba, job->request_payload.payload_len,\n\t\t\t\t     1, bpl, &bpl_entries);\n\tif (!cmp) {\n\t\trc = -ENOMEM;\n\t\tgoto send_mgmt_rsp_free_bmp;\n\t}\n\tlpfc_bsg_copy_data(cmp, &job->request_payload,\n\t\t\t   job->request_payload.payload_len, 1);\n\n\trc = lpfc_issue_ct_rsp(phba, job, tag, cmp, bmp, bpl_entries);\n\n\tif (rc == IOCB_SUCCESS)\n\t\treturn 0;  \n\n\trc = -EACCES;\n\n\tlpfc_free_bsg_buffers(phba, cmp);\n\nsend_mgmt_rsp_free_bmp:\n\tif (bmp->virt)\n\t\tlpfc_mbuf_free(phba, bmp->virt, bmp->phys);\n\tkfree(bmp);\nsend_mgmt_rsp_exit:\n\t \n\tbsg_reply->result = rc;\n\tjob->dd_data = NULL;\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_diag_mode_enter(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct Scsi_Host *shost;\n\tstruct lpfc_sli *psli;\n\tstruct lpfc_queue *qp = NULL;\n\tstruct lpfc_sli_ring *pring;\n\tint i = 0;\n\n\tpsli = &phba->sli;\n\tif (!psli)\n\t\treturn -ENODEV;\n\n\n\tif ((phba->link_state == LPFC_HBA_ERROR) ||\n\t    (psli->sli_flag & LPFC_BLOCK_MGMT_IO) ||\n\t    (!(psli->sli_flag & LPFC_SLI_ACTIVE)))\n\t\treturn -EACCES;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports) {\n\t\tfor (i = 0; i <= phba->max_vpi && vports[i] != NULL; i++) {\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tscsi_block_requests(shost);\n\t\t}\n\t\tlpfc_destroy_vport_work_array(phba, vports);\n\t} else {\n\t\tshost = lpfc_shost_from_vport(phba->pport);\n\t\tscsi_block_requests(shost);\n\t}\n\n\tif (phba->sli_rev != LPFC_SLI_REV4) {\n\t\tpring = &psli->sli3_ring[LPFC_FCP_RING];\n\t\tlpfc_emptyq_wait(phba, &pring->txcmplq, &phba->hbalock);\n\t\treturn 0;\n\t}\n\tlist_for_each_entry(qp, &phba->sli4_hba.lpfc_wq_list, wq_list) {\n\t\tpring = qp->pring;\n\t\tif (!pring || (pring->ringno != LPFC_FCP_RING))\n\t\t\tcontinue;\n\t\tif (!lpfc_emptyq_wait(phba, &pring->txcmplq,\n\t\t\t\t      &pring->ring_lock))\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic void\nlpfc_bsg_diag_mode_exit(struct lpfc_hba *phba)\n{\n\tstruct Scsi_Host *shost;\n\tstruct lpfc_vport **vports;\n\tint i;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports) {\n\t\tfor (i = 0; i <= phba->max_vpi && vports[i] != NULL; i++) {\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tscsi_unblock_requests(shost);\n\t\t}\n\t\tlpfc_destroy_vport_work_array(phba, vports);\n\t} else {\n\t\tshost = lpfc_shost_from_vport(phba->pport);\n\t\tscsi_unblock_requests(shost);\n\t}\n\treturn;\n}\n\n \nstatic int\nlpfc_sli3_bsg_diag_loopback_mode(struct lpfc_hba *phba, struct bsg_job *job)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct diag_mode_set *loopback_mode;\n\tuint32_t link_flags;\n\tuint32_t timeout;\n\tLPFC_MBOXQ_t *pmboxq  = NULL;\n\tint mbxstatus = MBX_SUCCESS;\n\tint i = 0;\n\tint rc = 0;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (job->request_len < sizeof(struct fc_bsg_request) +\n\t    sizeof(struct diag_mode_set)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2738 Received DIAG MODE request size:%d \"\n\t\t\t\t\"below the minimum size:%d\\n\",\n\t\t\t\tjob->request_len,\n\t\t\t\t(int)(sizeof(struct fc_bsg_request) +\n\t\t\t\tsizeof(struct diag_mode_set)));\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\trc = lpfc_bsg_diag_mode_enter(phba);\n\tif (rc)\n\t\tgoto job_error;\n\n\t \n\tloopback_mode = (struct diag_mode_set *)\n\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\tlink_flags = loopback_mode->type;\n\ttimeout = loopback_mode->timeout * 100;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq) {\n\t\trc = -ENOMEM;\n\t\tgoto loopback_mode_exit;\n\t}\n\tmemset((void *)pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\tpmboxq->u.mb.mbxCommand = MBX_DOWN_LINK;\n\tpmboxq->u.mb.mbxOwner = OWN_HOST;\n\n\tmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO);\n\n\tif ((mbxstatus == MBX_SUCCESS) && (pmboxq->u.mb.mbxStatus == 0)) {\n\t\t \n\t\ti = 0;\n\t\twhile (phba->link_state != LPFC_LINK_DOWN) {\n\t\t\tif (i++ > timeout) {\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tgoto loopback_mode_exit;\n\t\t\t}\n\t\t\tmsleep(10);\n\t\t}\n\n\t\tmemset((void *)pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\t\tif (link_flags == INTERNAL_LOOP_BACK)\n\t\t\tpmboxq->u.mb.un.varInitLnk.link_flags = FLAGS_LOCAL_LB;\n\t\telse\n\t\t\tpmboxq->u.mb.un.varInitLnk.link_flags =\n\t\t\t\tFLAGS_TOPOLOGY_MODE_LOOP;\n\n\t\tpmboxq->u.mb.mbxCommand = MBX_INIT_LINK;\n\t\tpmboxq->u.mb.mbxOwner = OWN_HOST;\n\n\t\tmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq,\n\t\t\t\t\t\t     LPFC_MBOX_TMO);\n\n\t\tif ((mbxstatus != MBX_SUCCESS) || (pmboxq->u.mb.mbxStatus))\n\t\t\trc = -ENODEV;\n\t\telse {\n\t\t\tspin_lock_irq(&phba->hbalock);\n\t\t\tphba->link_flag |= LS_LOOPBACK_MODE;\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\t \n\t\t\tmsleep(100);\n\n\t\t\ti = 0;\n\t\t\twhile (phba->link_state != LPFC_HBA_READY) {\n\t\t\t\tif (i++ > timeout) {\n\t\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmsleep(10);\n\t\t\t}\n\t\t}\n\n\t} else\n\t\trc = -ENODEV;\n\nloopback_mode_exit:\n\tlpfc_bsg_diag_mode_exit(phba);\n\n\t \n\tif (pmboxq && mbxstatus != MBX_TIMEOUT)\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\njob_error:\n\t \n\tbsg_reply->result = rc;\n\t \n\tif (rc == 0)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n}\n\n \nstatic int\nlpfc_sli4_bsg_set_link_diag_state(struct lpfc_hba *phba, uint32_t diag)\n{\n\tLPFC_MBOXQ_t *pmboxq;\n\tstruct lpfc_mbx_set_link_diag_state *link_diag_state;\n\tuint32_t req_len, alloc_len;\n\tint mbxstatus = MBX_SUCCESS, rc;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq)\n\t\treturn -ENOMEM;\n\n\treq_len = (sizeof(struct lpfc_mbx_set_link_diag_state) -\n\t\t   sizeof(struct lpfc_sli4_cfg_mhdr));\n\talloc_len = lpfc_sli4_config(phba, pmboxq, LPFC_MBOX_SUBSYSTEM_FCOE,\n\t\t\t\tLPFC_MBOX_OPCODE_FCOE_LINK_DIAG_STATE,\n\t\t\t\treq_len, LPFC_SLI4_MBX_EMBED);\n\tif (alloc_len != req_len) {\n\t\trc = -ENOMEM;\n\t\tgoto link_diag_state_set_out;\n\t}\n\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\"3128 Set link to diagnostic state:x%x (x%x/x%x)\\n\",\n\t\t\tdiag, phba->sli4_hba.lnk_info.lnk_tp,\n\t\t\tphba->sli4_hba.lnk_info.lnk_no);\n\n\tlink_diag_state = &pmboxq->u.mqe.un.link_diag_state;\n\tbf_set(lpfc_mbx_set_diag_state_diag_bit_valid, &link_diag_state->u.req,\n\t       LPFC_DIAG_STATE_DIAG_BIT_VALID_CHANGE);\n\tbf_set(lpfc_mbx_set_diag_state_link_num, &link_diag_state->u.req,\n\t       phba->sli4_hba.lnk_info.lnk_no);\n\tbf_set(lpfc_mbx_set_diag_state_link_type, &link_diag_state->u.req,\n\t       phba->sli4_hba.lnk_info.lnk_tp);\n\tif (diag)\n\t\tbf_set(lpfc_mbx_set_diag_state_diag,\n\t\t       &link_diag_state->u.req, 1);\n\telse\n\t\tbf_set(lpfc_mbx_set_diag_state_diag,\n\t\t       &link_diag_state->u.req, 0);\n\n\tmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO);\n\n\tif ((mbxstatus == MBX_SUCCESS) && (pmboxq->u.mb.mbxStatus == 0))\n\t\trc = 0;\n\telse\n\t\trc = -ENODEV;\n\nlink_diag_state_set_out:\n\tif (pmboxq && (mbxstatus != MBX_TIMEOUT))\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\treturn rc;\n}\n\n \nstatic int\nlpfc_sli4_bsg_set_loopback_mode(struct lpfc_hba *phba, int mode,\n\t\t\t\tuint32_t link_no)\n{\n\tLPFC_MBOXQ_t *pmboxq;\n\tuint32_t req_len, alloc_len;\n\tstruct lpfc_mbx_set_link_diag_loopback *link_diag_loopback;\n\tint mbxstatus = MBX_SUCCESS, rc = 0;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq)\n\t\treturn -ENOMEM;\n\treq_len = (sizeof(struct lpfc_mbx_set_link_diag_loopback) -\n\t\t   sizeof(struct lpfc_sli4_cfg_mhdr));\n\talloc_len = lpfc_sli4_config(phba, pmboxq, LPFC_MBOX_SUBSYSTEM_FCOE,\n\t\t\t\tLPFC_MBOX_OPCODE_FCOE_LINK_DIAG_LOOPBACK,\n\t\t\t\treq_len, LPFC_SLI4_MBX_EMBED);\n\tif (alloc_len != req_len) {\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\t\treturn -ENOMEM;\n\t}\n\tlink_diag_loopback = &pmboxq->u.mqe.un.link_diag_loopback;\n\tbf_set(lpfc_mbx_set_diag_state_link_num,\n\t       &link_diag_loopback->u.req, link_no);\n\n\tif (phba->sli4_hba.conf_trunk & (1 << link_no)) {\n\t\tbf_set(lpfc_mbx_set_diag_state_link_type,\n\t\t       &link_diag_loopback->u.req, LPFC_LNK_FC_TRUNKED);\n\t} else {\n\t\tbf_set(lpfc_mbx_set_diag_state_link_type,\n\t\t       &link_diag_loopback->u.req,\n\t\t       phba->sli4_hba.lnk_info.lnk_tp);\n\t}\n\n\tbf_set(lpfc_mbx_set_diag_lpbk_type, &link_diag_loopback->u.req,\n\t       mode);\n\n\tmbxstatus = lpfc_sli_issue_mbox_wait(phba, pmboxq, LPFC_MBOX_TMO);\n\tif ((mbxstatus != MBX_SUCCESS) || (pmboxq->u.mb.mbxStatus)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"3127 Failed setup loopback mode mailbox \"\n\t\t\t\t\"command, rc:x%x, status:x%x\\n\", mbxstatus,\n\t\t\t\tpmboxq->u.mb.mbxStatus);\n\t\trc = -ENODEV;\n\t}\n\tif (pmboxq && (mbxstatus != MBX_TIMEOUT))\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\treturn rc;\n}\n\n \nstatic int\nlpfc_sli4_diag_fcport_reg_setup(struct lpfc_hba *phba)\n{\n\tif (phba->pport->fc_flag & FC_VFI_REGISTERED) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"3136 Port still had vfi registered: \"\n\t\t\t\t\"mydid:x%x, fcfi:%d, vfi:%d, vpi:%d\\n\",\n\t\t\t\tphba->pport->fc_myDID, phba->fcf.fcfi,\n\t\t\t\tphba->sli4_hba.vfi_ids[phba->pport->vfi],\n\t\t\t\tphba->vpi_ids[phba->pport->vpi]);\n\t\treturn -EINVAL;\n\t}\n\treturn lpfc_issue_reg_vfi(phba->pport);\n}\n\n \nstatic int\nlpfc_sli4_bsg_diag_loopback_mode(struct lpfc_hba *phba, struct bsg_job *job)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct diag_mode_set *loopback_mode;\n\tuint32_t link_flags, timeout, link_no;\n\tint i, rc = 0;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (job->request_len < sizeof(struct fc_bsg_request) +\n\t    sizeof(struct diag_mode_set)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"3011 Received DIAG MODE request size:%d \"\n\t\t\t\t\"below the minimum size:%d\\n\",\n\t\t\t\tjob->request_len,\n\t\t\t\t(int)(sizeof(struct fc_bsg_request) +\n\t\t\t\tsizeof(struct diag_mode_set)));\n\t\trc = -EINVAL;\n\t\tgoto job_done;\n\t}\n\n\tloopback_mode = (struct diag_mode_set *)\n\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\tlink_flags = loopback_mode->type;\n\ttimeout = loopback_mode->timeout * 100;\n\n\tif (loopback_mode->physical_link == -1)\n\t\tlink_no = phba->sli4_hba.lnk_info.lnk_no;\n\telse\n\t\tlink_no = loopback_mode->physical_link;\n\n\tif (link_flags == DISABLE_LOOP_BACK) {\n\t\trc = lpfc_sli4_bsg_set_loopback_mode(phba,\n\t\t\t\t\tLPFC_DIAG_LOOPBACK_TYPE_DISABLE,\n\t\t\t\t\tlink_no);\n\t\tif (!rc) {\n\t\t\t \n\t\t\tphba->sli4_hba.conf_trunk &= ~((1 << link_no) << 4);\n\t\t}\n\t\tgoto job_done;\n\t} else {\n\t\t \n\t\tif (phba->sli4_hba.conf_trunk & ((1 << link_no) << 4)) {\n\t\t\trc = -EPERM;\n\t\t\tgoto job_done;\n\t\t}\n\t}\n\n\trc = lpfc_bsg_diag_mode_enter(phba);\n\tif (rc)\n\t\tgoto job_done;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tphba->link_flag |= LS_LOOPBACK_MODE;\n\tspin_unlock_irq(&phba->hbalock);\n\n\t \n\trc = lpfc_selective_reset(phba);\n\tif (rc)\n\t\tgoto job_done;\n\n\t \n\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\"3129 Bring link to diagnostic state.\\n\");\n\n\trc = lpfc_sli4_bsg_set_link_diag_state(phba, 1);\n\tif (rc) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"3130 Failed to bring link to diagnostic \"\n\t\t\t\t\"state, rc:x%x\\n\", rc);\n\t\tgoto loopback_mode_exit;\n\t}\n\n\t \n\ti = 0;\n\twhile (phba->link_state != LPFC_LINK_DOWN) {\n\t\tif (i++ > timeout) {\n\t\t\trc = -ETIMEDOUT;\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"3131 Timeout waiting for link to \"\n\t\t\t\t\t\"diagnostic mode, timeout:%d ms\\n\",\n\t\t\t\t\ttimeout * 10);\n\t\t\tgoto loopback_mode_exit;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\t \n\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\"3132 Set up loopback mode:x%x\\n\", link_flags);\n\n\tswitch (link_flags) {\n\tcase INTERNAL_LOOP_BACK:\n\t\tif (phba->sli4_hba.conf_trunk & (1 << link_no)) {\n\t\t\trc = lpfc_sli4_bsg_set_loopback_mode(phba,\n\t\t\t\t\tLPFC_DIAG_LOOPBACK_TYPE_INTERNAL,\n\t\t\t\t\tlink_no);\n\t\t} else {\n\t\t\t \n\t\t\tif (phba->sli4_hba.conf_trunk) {\n\t\t\t\trc = -ELNRNG;\n\t\t\t\tgoto loopback_mode_exit;\n\t\t\t}\n\n\t\t\trc = lpfc_sli4_bsg_set_loopback_mode(phba,\n\t\t\t\t\tLPFC_DIAG_LOOPBACK_TYPE_INTERNAL,\n\t\t\t\t\tlink_no);\n\t\t}\n\n\t\tif (!rc) {\n\t\t\t \n\t\t\tphba->sli4_hba.conf_trunk |= (1 << link_no) << 4;\n\t\t}\n\n\t\tbreak;\n\tcase EXTERNAL_LOOP_BACK:\n\t\tif (phba->sli4_hba.conf_trunk & (1 << link_no)) {\n\t\t\trc = lpfc_sli4_bsg_set_loopback_mode(phba,\n\t\t\t\tLPFC_DIAG_LOOPBACK_TYPE_EXTERNAL_TRUNKED,\n\t\t\t\tlink_no);\n\t\t} else {\n\t\t\t \n\t\t\tif (phba->sli4_hba.conf_trunk) {\n\t\t\t\trc = -ELNRNG;\n\t\t\t\tgoto loopback_mode_exit;\n\t\t\t}\n\n\t\t\trc = lpfc_sli4_bsg_set_loopback_mode(phba,\n\t\t\t\t\t\tLPFC_DIAG_LOOPBACK_TYPE_SERDES,\n\t\t\t\t\t\tlink_no);\n\t\t}\n\n\t\tif (!rc) {\n\t\t\t \n\t\t\tphba->sli4_hba.conf_trunk |= (1 << link_no) << 4;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"3141 Loopback mode:x%x not supported\\n\",\n\t\t\t\tlink_flags);\n\t\tgoto loopback_mode_exit;\n\t}\n\n\tif (!rc) {\n\t\t \n\t\tmsleep(100);\n\t\ti = 0;\n\t\twhile (phba->link_state < LPFC_LINK_UP) {\n\t\t\tif (i++ > timeout) {\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"3137 Timeout waiting for link up \"\n\t\t\t\t\t\"in loopback mode, timeout:%d ms\\n\",\n\t\t\t\t\ttimeout * 10);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(10);\n\t\t}\n\t}\n\n\t \n\tif (!rc) {\n\t\t \n\t\tphba->pport->fc_myDID = 1;\n\t\trc = lpfc_sli4_diag_fcport_reg_setup(phba);\n\t} else\n\t\tgoto loopback_mode_exit;\n\n\tif (!rc) {\n\t\t \n\t\tmsleep(100);\n\t\ti = 0;\n\t\twhile (phba->link_state != LPFC_HBA_READY) {\n\t\t\tif (i++ > timeout) {\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"3133 Timeout waiting for port \"\n\t\t\t\t\t\"loopback mode ready, timeout:%d ms\\n\",\n\t\t\t\t\ttimeout * 10);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(10);\n\t\t}\n\t}\n\nloopback_mode_exit:\n\t \n\tif (rc) {\n\t\tspin_lock_irq(&phba->hbalock);\n\t\tphba->link_flag &= ~LS_LOOPBACK_MODE;\n\t\tspin_unlock_irq(&phba->hbalock);\n\t}\n\tlpfc_bsg_diag_mode_exit(phba);\n\njob_done:\n\t \n\tbsg_reply->result = rc;\n\t \n\tif (rc == 0)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_diag_loopback_mode(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_hba *phba;\n\tint rc;\n\n\tshost = fc_bsg_to_shost(job);\n\tif (!shost)\n\t\treturn -ENODEV;\n\tvport = shost_priv(shost);\n\tif (!vport)\n\t\treturn -ENODEV;\n\tphba = vport->phba;\n\tif (!phba)\n\t\treturn -ENODEV;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\trc = lpfc_sli3_bsg_diag_loopback_mode(phba, job);\n\telse if (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) >=\n\t\t LPFC_SLI_INTF_IF_TYPE_2)\n\t\trc = lpfc_sli4_bsg_diag_loopback_mode(phba, job);\n\telse\n\t\trc = -ENODEV;\n\n\treturn rc;\n}\n\n \nstatic int\nlpfc_sli4_bsg_diag_mode_end(struct bsg_job *job)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct Scsi_Host *shost;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_hba *phba;\n\tstruct diag_mode_set *loopback_mode_end_cmd;\n\tuint32_t timeout;\n\tint rc, i;\n\n\tshost = fc_bsg_to_shost(job);\n\tif (!shost)\n\t\treturn -ENODEV;\n\tvport = shost_priv(shost);\n\tif (!vport)\n\t\treturn -ENODEV;\n\tphba = vport->phba;\n\tif (!phba)\n\t\treturn -ENODEV;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\treturn -ENODEV;\n\tif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t    LPFC_SLI_INTF_IF_TYPE_2)\n\t\treturn -ENODEV;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tphba->link_flag &= ~LS_LOOPBACK_MODE;\n\tspin_unlock_irq(&phba->hbalock);\n\tloopback_mode_end_cmd = (struct diag_mode_set *)\n\t\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\ttimeout = loopback_mode_end_cmd->timeout * 100;\n\n\trc = lpfc_sli4_bsg_set_link_diag_state(phba, 0);\n\tif (rc) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"3139 Failed to bring link to diagnostic \"\n\t\t\t\t\"state, rc:x%x\\n\", rc);\n\t\tgoto loopback_mode_end_exit;\n\t}\n\n\t \n\ti = 0;\n\twhile (phba->link_state != LPFC_LINK_DOWN) {\n\t\tif (i++ > timeout) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"3140 Timeout waiting for link to \"\n\t\t\t\t\t\"diagnostic mode_end, timeout:%d ms\\n\",\n\t\t\t\t\ttimeout * 10);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\t \n\trc = lpfc_selective_reset(phba);\n\tphba->pport->fc_myDID = 0;\n\nloopback_mode_end_exit:\n\t \n\tbsg_reply->result = rc;\n\t \n\tif (rc == 0)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n}\n\n \nstatic int\nlpfc_sli4_bsg_link_diag_test(struct bsg_job *job)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct Scsi_Host *shost;\n\tstruct lpfc_vport *vport;\n\tstruct lpfc_hba *phba;\n\tLPFC_MBOXQ_t *pmboxq;\n\tstruct sli4_link_diag *link_diag_test_cmd;\n\tuint32_t req_len, alloc_len;\n\tstruct lpfc_mbx_run_link_diag_test *run_link_diag_test;\n\tunion lpfc_sli4_cfg_shdr *shdr;\n\tuint32_t shdr_status, shdr_add_status;\n\tstruct diag_status *diag_status_reply;\n\tint mbxstatus, rc = -ENODEV, rc1 = 0;\n\n\tshost = fc_bsg_to_shost(job);\n\tif (!shost)\n\t\tgoto job_error;\n\n\tvport = shost_priv(shost);\n\tif (!vport)\n\t\tgoto job_error;\n\n\tphba = vport->phba;\n\tif (!phba)\n\t\tgoto job_error;\n\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tgoto job_error;\n\n\tif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t    LPFC_SLI_INTF_IF_TYPE_2)\n\t\tgoto job_error;\n\n\tif (job->request_len < sizeof(struct fc_bsg_request) +\n\t    sizeof(struct sli4_link_diag)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"3013 Received LINK DIAG TEST request \"\n\t\t\t\t\" size:%d below the minimum size:%d\\n\",\n\t\t\t\tjob->request_len,\n\t\t\t\t(int)(sizeof(struct fc_bsg_request) +\n\t\t\t\tsizeof(struct sli4_link_diag)));\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\trc = lpfc_bsg_diag_mode_enter(phba);\n\tif (rc)\n\t\tgoto job_error;\n\n\tlink_diag_test_cmd = (struct sli4_link_diag *)\n\t\t\t bsg_request->rqst_data.h_vendor.vendor_cmd;\n\n\trc = lpfc_sli4_bsg_set_link_diag_state(phba, 1);\n\n\tif (rc)\n\t\tgoto job_error;\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq) {\n\t\trc = -ENOMEM;\n\t\tgoto link_diag_test_exit;\n\t}\n\n\treq_len = (sizeof(struct lpfc_mbx_set_link_diag_state) -\n\t\t   sizeof(struct lpfc_sli4_cfg_mhdr));\n\talloc_len = lpfc_sli4_config(phba, pmboxq, LPFC_MBOX_SUBSYSTEM_FCOE,\n\t\t\t\t     LPFC_MBOX_OPCODE_FCOE_LINK_DIAG_STATE,\n\t\t\t\t     req_len, LPFC_SLI4_MBX_EMBED);\n\tif (alloc_len != req_len) {\n\t\trc = -ENOMEM;\n\t\tgoto link_diag_test_exit;\n\t}\n\n\trun_link_diag_test = &pmboxq->u.mqe.un.link_diag_test;\n\tbf_set(lpfc_mbx_run_diag_test_link_num, &run_link_diag_test->u.req,\n\t       phba->sli4_hba.lnk_info.lnk_no);\n\tbf_set(lpfc_mbx_run_diag_test_link_type, &run_link_diag_test->u.req,\n\t       phba->sli4_hba.lnk_info.lnk_tp);\n\tbf_set(lpfc_mbx_run_diag_test_test_id, &run_link_diag_test->u.req,\n\t       link_diag_test_cmd->test_id);\n\tbf_set(lpfc_mbx_run_diag_test_loops, &run_link_diag_test->u.req,\n\t       link_diag_test_cmd->loops);\n\tbf_set(lpfc_mbx_run_diag_test_test_ver, &run_link_diag_test->u.req,\n\t       link_diag_test_cmd->test_version);\n\tbf_set(lpfc_mbx_run_diag_test_err_act, &run_link_diag_test->u.req,\n\t       link_diag_test_cmd->error_action);\n\n\tmbxstatus = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\n\tshdr = (union lpfc_sli4_cfg_shdr *)\n\t\t&pmboxq->u.mqe.un.sli4_config.header.cfg_shdr;\n\tshdr_status = bf_get(lpfc_mbox_hdr_status, &shdr->response);\n\tshdr_add_status = bf_get(lpfc_mbox_hdr_add_status, &shdr->response);\n\tif (shdr_status || shdr_add_status || mbxstatus) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"3010 Run link diag test mailbox failed with \"\n\t\t\t\t\"mbx_status x%x status x%x, add_status x%x\\n\",\n\t\t\t\tmbxstatus, shdr_status, shdr_add_status);\n\t}\n\n\tdiag_status_reply = (struct diag_status *)\n\t\t\t    bsg_reply->reply_data.vendor_reply.vendor_rsp;\n\n\tif (job->reply_len < sizeof(*bsg_reply) + sizeof(*diag_status_reply)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"3012 Received Run link diag test reply \"\n\t\t\t\t\"below minimum size (%d): reply_len:%d\\n\",\n\t\t\t\t(int)(sizeof(*bsg_reply) +\n\t\t\t\tsizeof(*diag_status_reply)),\n\t\t\t\tjob->reply_len);\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tdiag_status_reply->mbox_status = mbxstatus;\n\tdiag_status_reply->shdr_status = shdr_status;\n\tdiag_status_reply->shdr_add_status = shdr_add_status;\n\nlink_diag_test_exit:\n\trc1 = lpfc_sli4_bsg_set_link_diag_state(phba, 0);\n\n\tif (pmboxq)\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\tlpfc_bsg_diag_mode_exit(phba);\n\njob_error:\n\t \n\tif (rc1 && !rc)\n\t\trc = rc1;\n\tbsg_reply->result = rc;\n\t \n\tif (rc == 0)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n}\n\n \nstatic int lpfcdiag_loop_self_reg(struct lpfc_hba *phba, uint16_t *rpi)\n{\n\tLPFC_MBOXQ_t *mbox;\n\tstruct lpfc_dmabuf *dmabuff;\n\tint status;\n\n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!mbox)\n\t\treturn -ENOMEM;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tstatus = lpfc_reg_rpi(phba, 0, phba->pport->fc_myDID,\n\t\t\t\t(uint8_t *)&phba->pport->fc_sparam,\n\t\t\t\tmbox, *rpi);\n\telse {\n\t\t*rpi = lpfc_sli4_alloc_rpi(phba);\n\t\tif (*rpi == LPFC_RPI_ALLOC_ERROR) {\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tstatus = lpfc_reg_rpi(phba, phba->pport->vpi,\n\t\t\t\tphba->pport->fc_myDID,\n\t\t\t\t(uint8_t *)&phba->pport->fc_sparam,\n\t\t\t\tmbox, *rpi);\n\t}\n\n\tif (status) {\n\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_sli4_free_rpi(phba, *rpi);\n\t\treturn -ENOMEM;\n\t}\n\n\tdmabuff = (struct lpfc_dmabuf *)mbox->ctx_buf;\n\tmbox->ctx_buf = NULL;\n\tmbox->ctx_ndlp = NULL;\n\tstatus = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_TMO);\n\n\tif ((status != MBX_SUCCESS) || (mbox->u.mb.mbxStatus)) {\n\t\tlpfc_mbuf_free(phba, dmabuff->virt, dmabuff->phys);\n\t\tkfree(dmabuff);\n\t\tif (status != MBX_TIMEOUT)\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tlpfc_sli4_free_rpi(phba, *rpi);\n\t\treturn -ENODEV;\n\t}\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\t*rpi = mbox->u.mb.un.varWords[0];\n\n\tlpfc_mbuf_free(phba, dmabuff->virt, dmabuff->phys);\n\tkfree(dmabuff);\n\tmempool_free(mbox, phba->mbox_mem_pool);\n\treturn 0;\n}\n\n \nstatic int lpfcdiag_loop_self_unreg(struct lpfc_hba *phba, uint16_t rpi)\n{\n\tLPFC_MBOXQ_t *mbox;\n\tint status;\n\n\t \n\tmbox = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (mbox == NULL)\n\t\treturn -ENOMEM;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tlpfc_unreg_login(phba, 0, rpi, mbox);\n\telse\n\t\tlpfc_unreg_login(phba, phba->pport->vpi,\n\t\t\t\t phba->sli4_hba.rpi_ids[rpi], mbox);\n\n\tstatus = lpfc_sli_issue_mbox_wait(phba, mbox, LPFC_MBOX_TMO);\n\n\tif ((status != MBX_SUCCESS) || (mbox->u.mb.mbxStatus)) {\n\t\tif (status != MBX_TIMEOUT)\n\t\t\tmempool_free(mbox, phba->mbox_mem_pool);\n\t\treturn -EIO;\n\t}\n\tmempool_free(mbox, phba->mbox_mem_pool);\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tlpfc_sli4_free_rpi(phba, rpi);\n\treturn 0;\n}\n\n \nstatic int lpfcdiag_loop_get_xri(struct lpfc_hba *phba, uint16_t rpi,\n\t\t\t uint16_t *txxri, uint16_t * rxxri)\n{\n\tstruct lpfc_bsg_event *evt;\n\tstruct lpfc_iocbq *cmdiocbq, *rspiocbq;\n\tstruct lpfc_dmabuf *dmabuf;\n\tstruct ulp_bde64 *bpl = NULL;\n\tstruct lpfc_sli_ct_request *ctreq = NULL;\n\tint ret_val = 0;\n\tint time_left;\n\tint iocb_stat = IOCB_SUCCESS;\n\tunsigned long flags;\n\tu32 status;\n\n\t*txxri = 0;\n\t*rxxri = 0;\n\tevt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,\n\t\t\t\tSLI_CT_ELX_LOOPBACK);\n\tif (!evt)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tlist_add(&evt->node, &phba->ct_ev_waiters);\n\tlpfc_bsg_event_ref(evt);\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\tcmdiocbq = lpfc_sli_get_iocbq(phba);\n\trspiocbq = lpfc_sli_get_iocbq(phba);\n\n\tdmabuf = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (dmabuf) {\n\t\tdmabuf->virt = lpfc_mbuf_alloc(phba, 0, &dmabuf->phys);\n\t\tif (dmabuf->virt) {\n\t\t\tINIT_LIST_HEAD(&dmabuf->list);\n\t\t\tbpl = (struct ulp_bde64 *) dmabuf->virt;\n\t\t\tmemset(bpl, 0, sizeof(*bpl));\n\t\t\tctreq = (struct lpfc_sli_ct_request *)(bpl + 1);\n\t\t\tbpl->addrHigh =\n\t\t\t\tle32_to_cpu(putPaddrHigh(dmabuf->phys +\n\t\t\t\t\tsizeof(*bpl)));\n\t\t\tbpl->addrLow =\n\t\t\t\tle32_to_cpu(putPaddrLow(dmabuf->phys +\n\t\t\t\t\tsizeof(*bpl)));\n\t\t\tbpl->tus.f.bdeFlags = 0;\n\t\t\tbpl->tus.f.bdeSize = ELX_LOOPBACK_HEADER_SZ;\n\t\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t\t}\n\t}\n\n\tif (cmdiocbq == NULL || rspiocbq == NULL ||\n\t    dmabuf == NULL || bpl == NULL || ctreq == NULL ||\n\t\tdmabuf->virt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto err_get_xri_exit;\n\t}\n\n\tmemset(ctreq, 0, ELX_LOOPBACK_HEADER_SZ);\n\n\tctreq->RevisionId.bits.Revision = SLI_CT_REVISION;\n\tctreq->RevisionId.bits.InId = 0;\n\tctreq->FsType = SLI_CT_ELX_LOOPBACK;\n\tctreq->FsSubType = 0;\n\tctreq->CommandResponse.bits.CmdRsp = ELX_LOOPBACK_XRI_SETUP;\n\tctreq->CommandResponse.bits.Size = 0;\n\n\tcmdiocbq->bpl_dmabuf = dmabuf;\n\tcmdiocbq->cmd_flag |= LPFC_IO_LIBDFC;\n\tcmdiocbq->vport = phba->pport;\n\tcmdiocbq->cmd_cmpl = NULL;\n\n\tlpfc_sli_prep_xmit_seq64(phba, cmdiocbq, dmabuf, rpi, 0, 1,\n\t\t\t\t FC_RCTL_DD_SOL_CTL, 0, CMD_XMIT_SEQUENCE64_CR);\n\n\tiocb_stat = lpfc_sli_issue_iocb_wait(phba, LPFC_ELS_RING, cmdiocbq,\n\t\t\t\t\t     rspiocbq, (phba->fc_ratov * 2)\n\t\t\t\t\t     + LPFC_DRVR_TIMEOUT);\n\n\tstatus = get_job_ulpstatus(phba, rspiocbq);\n\tif (iocb_stat != IOCB_SUCCESS || status != IOCB_SUCCESS) {\n\t\tret_val = -EIO;\n\t\tgoto err_get_xri_exit;\n\t}\n\t*txxri = get_job_ulpcontext(phba, rspiocbq);\n\n\tevt->waiting = 1;\n\tevt->wait_time_stamp = jiffies;\n\ttime_left = wait_event_interruptible_timeout(\n\t\tevt->wq, !list_empty(&evt->events_to_see),\n\t\tmsecs_to_jiffies(1000 *\n\t\t\t((phba->fc_ratov * 2) + LPFC_DRVR_TIMEOUT)));\n\tif (list_empty(&evt->events_to_see))\n\t\tret_val = (time_left) ? -EINTR : -ETIMEDOUT;\n\telse {\n\t\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\t\tlist_move(evt->events_to_see.prev, &evt->events_to_get);\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\t*rxxri = (list_entry(evt->events_to_get.prev,\n\t\t\t\t     typeof(struct event_data),\n\t\t\t\t     node))->immed_dat;\n\t}\n\tevt->waiting = 0;\n\nerr_get_xri_exit:\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tlpfc_bsg_event_unref(evt);  \n\tlpfc_bsg_event_unref(evt);  \n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\tif (dmabuf) {\n\t\tif (dmabuf->virt)\n\t\t\tlpfc_mbuf_free(phba, dmabuf->virt, dmabuf->phys);\n\t\tkfree(dmabuf);\n\t}\n\n\tif (cmdiocbq && (iocb_stat != IOCB_TIMEDOUT))\n\t\tlpfc_sli_release_iocbq(phba, cmdiocbq);\n\tif (rspiocbq)\n\t\tlpfc_sli_release_iocbq(phba, rspiocbq);\n\treturn ret_val;\n}\n\n \nstatic struct lpfc_dmabuf *\nlpfc_bsg_dma_page_alloc(struct lpfc_hba *phba)\n{\n\tstruct lpfc_dmabuf *dmabuf;\n\tstruct pci_dev *pcidev = phba->pcidev;\n\n\t \n\tdmabuf = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (!dmabuf)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&dmabuf->list);\n\n\t \n\tdmabuf->virt = dma_alloc_coherent(&pcidev->dev, BSG_MBOX_SIZE,\n\t\t\t\t\t  &(dmabuf->phys), GFP_KERNEL);\n\n\tif (!dmabuf->virt) {\n\t\tkfree(dmabuf);\n\t\treturn NULL;\n\t}\n\n\treturn dmabuf;\n}\n\n \nstatic void\nlpfc_bsg_dma_page_free(struct lpfc_hba *phba, struct lpfc_dmabuf *dmabuf)\n{\n\tstruct pci_dev *pcidev = phba->pcidev;\n\n\tif (!dmabuf)\n\t\treturn;\n\n\tif (dmabuf->virt)\n\t\tdma_free_coherent(&pcidev->dev, BSG_MBOX_SIZE,\n\t\t\t\t  dmabuf->virt, dmabuf->phys);\n\tkfree(dmabuf);\n\treturn;\n}\n\n \nstatic void\nlpfc_bsg_dma_page_list_free(struct lpfc_hba *phba,\n\t\t\t    struct list_head *dmabuf_list)\n{\n\tstruct lpfc_dmabuf *dmabuf, *next_dmabuf;\n\n\tif (list_empty(dmabuf_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(dmabuf, next_dmabuf, dmabuf_list, list) {\n\t\tlist_del_init(&dmabuf->list);\n\t\tlpfc_bsg_dma_page_free(phba, dmabuf);\n\t}\n\treturn;\n}\n\n \nstatic struct lpfc_dmabufext *\ndiag_cmd_data_alloc(struct lpfc_hba *phba,\n\t\t   struct ulp_bde64 *bpl, uint32_t size,\n\t\t   int nocopydata)\n{\n\tstruct lpfc_dmabufext *mlist = NULL;\n\tstruct lpfc_dmabufext *dmp;\n\tint cnt, offset = 0, i = 0;\n\tstruct pci_dev *pcidev;\n\n\tpcidev = phba->pcidev;\n\n\twhile (size) {\n\t\t \n\t\tif (size > BUF_SZ_4K)\n\t\t\tcnt = BUF_SZ_4K;\n\t\telse\n\t\t\tcnt = size;\n\n\t\t \n\t\tdmp = kmalloc(sizeof(struct lpfc_dmabufext), GFP_KERNEL);\n\t\tif (!dmp)\n\t\t\tgoto out;\n\n\t\tINIT_LIST_HEAD(&dmp->dma.list);\n\n\t\t \n\t\tif (mlist)\n\t\t\tlist_add_tail(&dmp->dma.list, &mlist->dma.list);\n\t\telse\n\t\t\tmlist = dmp;\n\n\t\t \n\t\tdmp->dma.virt = dma_alloc_coherent(&pcidev->dev,\n\t\t\t\t\t\t   cnt,\n\t\t\t\t\t\t   &(dmp->dma.phys),\n\t\t\t\t\t\t   GFP_KERNEL);\n\n\t\tif (!dmp->dma.virt)\n\t\t\tgoto out;\n\n\t\tdmp->size = cnt;\n\n\t\tif (nocopydata) {\n\t\t\tbpl->tus.f.bdeFlags = 0;\n\t\t} else {\n\t\t\tmemset((uint8_t *)dmp->dma.virt, 0, cnt);\n\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\n\t\t}\n\n\t\t \n\t\tbpl->addrLow = le32_to_cpu(putPaddrLow(dmp->dma.phys));\n\t\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(dmp->dma.phys));\n\t\tbpl->tus.f.bdeSize = (ushort) cnt;\n\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t\tbpl++;\n\n\t\ti++;\n\t\toffset += cnt;\n\t\tsize -= cnt;\n\t}\n\n\tif (mlist) {\n\t\tmlist->flag = i;\n\t\treturn mlist;\n\t}\nout:\n\tdiag_cmd_data_free(phba, mlist);\n\treturn NULL;\n}\n\n \nstatic int lpfcdiag_sli3_loop_post_rxbufs(struct lpfc_hba *phba, uint16_t rxxri,\n\t\t\t\t\t  size_t len)\n{\n\tstruct lpfc_sli_ring *pring;\n\tstruct lpfc_iocbq *cmdiocbq;\n\tIOCB_t *cmd = NULL;\n\tstruct list_head head, *curr, *next;\n\tstruct lpfc_dmabuf *rxbmp;\n\tstruct lpfc_dmabuf *dmp;\n\tstruct lpfc_dmabuf *mp[2] = {NULL, NULL};\n\tstruct ulp_bde64 *rxbpl = NULL;\n\tuint32_t num_bde;\n\tstruct lpfc_dmabufext *rxbuffer = NULL;\n\tint ret_val = 0;\n\tint iocb_stat;\n\tint i = 0;\n\n\tpring = lpfc_phba_elsring(phba);\n\n\tcmdiocbq = lpfc_sli_get_iocbq(phba);\n\trxbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\tif (rxbmp != NULL) {\n\t\trxbmp->virt = lpfc_mbuf_alloc(phba, 0, &rxbmp->phys);\n\t\tif (rxbmp->virt) {\n\t\t\tINIT_LIST_HEAD(&rxbmp->list);\n\t\t\trxbpl = (struct ulp_bde64 *) rxbmp->virt;\n\t\t\trxbuffer = diag_cmd_data_alloc(phba, rxbpl, len, 0);\n\t\t}\n\t}\n\n\tif (!cmdiocbq || !rxbmp || !rxbpl || !rxbuffer || !pring) {\n\t\tret_val = -ENOMEM;\n\t\tgoto err_post_rxbufs_exit;\n\t}\n\n\t \n\tnum_bde = (uint32_t)rxbuffer->flag;\n\tdmp = &rxbuffer->dma;\n\tcmd = &cmdiocbq->iocb;\n\ti = 0;\n\n\tINIT_LIST_HEAD(&head);\n\tlist_add_tail(&head, &dmp->list);\n\tlist_for_each_safe(curr, next, &head) {\n\t\tmp[i] = list_entry(curr, struct lpfc_dmabuf, list);\n\t\tlist_del(curr);\n\n\t\tif (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED) {\n\t\t\tmp[i]->buffer_tag = lpfc_sli_get_buffer_tag(phba);\n\t\t\tcmd->un.quexri64cx.buff.bde.addrHigh =\n\t\t\t\tputPaddrHigh(mp[i]->phys);\n\t\t\tcmd->un.quexri64cx.buff.bde.addrLow =\n\t\t\t\tputPaddrLow(mp[i]->phys);\n\t\t\tcmd->un.quexri64cx.buff.bde.tus.f.bdeSize =\n\t\t\t\t((struct lpfc_dmabufext *)mp[i])->size;\n\t\t\tcmd->un.quexri64cx.buff.buffer_tag = mp[i]->buffer_tag;\n\t\t\tcmd->ulpCommand = CMD_QUE_XRI64_CX;\n\t\t\tcmd->ulpPU = 0;\n\t\t\tcmd->ulpLe = 1;\n\t\t\tcmd->ulpBdeCount = 1;\n\t\t\tcmd->unsli3.que_xri64cx_ext_words.ebde_count = 0;\n\n\t\t} else {\n\t\t\tcmd->un.cont64[i].addrHigh = putPaddrHigh(mp[i]->phys);\n\t\t\tcmd->un.cont64[i].addrLow = putPaddrLow(mp[i]->phys);\n\t\t\tcmd->un.cont64[i].tus.f.bdeSize =\n\t\t\t\t((struct lpfc_dmabufext *)mp[i])->size;\n\t\t\tcmd->ulpBdeCount = ++i;\n\n\t\t\tif ((--num_bde > 0) && (i < 2))\n\t\t\t\tcontinue;\n\n\t\t\tcmd->ulpCommand = CMD_QUE_XRI_BUF64_CX;\n\t\t\tcmd->ulpLe = 1;\n\t\t}\n\n\t\tcmd->ulpClass = CLASS3;\n\t\tcmd->ulpContext = rxxri;\n\n\t\tiocb_stat = lpfc_sli_issue_iocb(phba, LPFC_ELS_RING, cmdiocbq,\n\t\t\t\t\t\t0);\n\t\tif (iocb_stat == IOCB_ERROR) {\n\t\t\tdiag_cmd_data_free(phba,\n\t\t\t\t(struct lpfc_dmabufext *)mp[0]);\n\t\t\tif (mp[1])\n\t\t\t\tdiag_cmd_data_free(phba,\n\t\t\t\t\t  (struct lpfc_dmabufext *)mp[1]);\n\t\t\tdmp = list_entry(next, struct lpfc_dmabuf, list);\n\t\t\tret_val = -EIO;\n\t\t\tgoto err_post_rxbufs_exit;\n\t\t}\n\n\t\tlpfc_sli_ringpostbuf_put(phba, pring, mp[0]);\n\t\tif (mp[1]) {\n\t\t\tlpfc_sli_ringpostbuf_put(phba, pring, mp[1]);\n\t\t\tmp[1] = NULL;\n\t\t}\n\n\t\t \n\t\tcmdiocbq = lpfc_sli_get_iocbq(phba);\n\t\tif (!cmdiocbq) {\n\t\t\tdmp = list_entry(next, struct lpfc_dmabuf, list);\n\t\t\tret_val = -EIO;\n\t\t\tgoto err_post_rxbufs_exit;\n\t\t}\n\t\tcmd = &cmdiocbq->iocb;\n\t\ti = 0;\n\t}\n\tlist_del(&head);\n\nerr_post_rxbufs_exit:\n\n\tif (rxbmp) {\n\t\tif (rxbmp->virt)\n\t\t\tlpfc_mbuf_free(phba, rxbmp->virt, rxbmp->phys);\n\t\tkfree(rxbmp);\n\t}\n\n\tif (cmdiocbq)\n\t\tlpfc_sli_release_iocbq(phba, cmdiocbq);\n\treturn ret_val;\n}\n\n \nstatic int\nlpfc_bsg_diag_loopback_run(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_bsg_event *evt;\n\tstruct event_data *evdat;\n\tstruct lpfc_sli *psli = &phba->sli;\n\tuint32_t size;\n\tuint32_t full_size;\n\tsize_t segment_len = 0, segment_offset = 0, current_offset = 0;\n\tuint16_t rpi = 0;\n\tstruct lpfc_iocbq *cmdiocbq, *rspiocbq = NULL;\n\tunion lpfc_wqe128 *cmdwqe, *rspwqe;\n\tstruct lpfc_sli_ct_request *ctreq;\n\tstruct lpfc_dmabuf *txbmp;\n\tstruct ulp_bde64 *txbpl = NULL;\n\tstruct lpfc_dmabufext *txbuffer = NULL;\n\tstruct list_head head;\n\tstruct lpfc_dmabuf  *curr;\n\tuint16_t txxri = 0, rxxri;\n\tuint32_t num_bde;\n\tuint8_t *ptr = NULL, *rx_databuf = NULL;\n\tint rc = 0;\n\tint time_left;\n\tint iocb_stat = IOCB_SUCCESS;\n\tunsigned long flags;\n\tvoid *dataout = NULL;\n\tuint32_t total_mem;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) + sizeof(struct diag_mode_test)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2739 Received DIAG TEST request below minimum \"\n\t\t\t\t\"size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto loopback_test_exit;\n\t}\n\n\tif (job->request_payload.payload_len !=\n\t\tjob->reply_payload.payload_len) {\n\t\trc = -EINVAL;\n\t\tgoto loopback_test_exit;\n\t}\n\n\tif ((phba->link_state == LPFC_HBA_ERROR) ||\n\t    (psli->sli_flag & LPFC_BLOCK_MGMT_IO) ||\n\t    (!(psli->sli_flag & LPFC_SLI_ACTIVE))) {\n\t\trc = -EACCES;\n\t\tgoto loopback_test_exit;\n\t}\n\n\tif (!lpfc_is_link_up(phba) || !(phba->link_flag & LS_LOOPBACK_MODE)) {\n\t\trc = -EACCES;\n\t\tgoto loopback_test_exit;\n\t}\n\n\tsize = job->request_payload.payload_len;\n\tfull_size = size + ELX_LOOPBACK_HEADER_SZ;  \n\n\tif ((size == 0) || (size > 80 * BUF_SZ_4K)) {\n\t\trc = -ERANGE;\n\t\tgoto loopback_test_exit;\n\t}\n\n\tif (full_size >= BUF_SZ_4K) {\n\t\t \n\t\tif (size <= (64 * 1024))\n\t\t\ttotal_mem = full_size;\n\t\telse\n\t\t\ttotal_mem = 64 * 1024;\n\t} else\n\t\t \n\t\ttotal_mem = BUF_SZ_4K;\n\n\tdataout = kmalloc(total_mem, GFP_KERNEL);\n\tif (dataout == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto loopback_test_exit;\n\t}\n\n\tptr = dataout;\n\tptr += ELX_LOOPBACK_HEADER_SZ;\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t\tjob->request_payload.sg_cnt,\n\t\t\t\tptr, size);\n\trc = lpfcdiag_loop_self_reg(phba, &rpi);\n\tif (rc)\n\t\tgoto loopback_test_exit;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\trc = lpfcdiag_loop_get_xri(phba, rpi, &txxri, &rxxri);\n\t\tif (rc) {\n\t\t\tlpfcdiag_loop_self_unreg(phba, rpi);\n\t\t\tgoto loopback_test_exit;\n\t\t}\n\n\t\trc = lpfcdiag_sli3_loop_post_rxbufs(phba, rxxri, full_size);\n\t\tif (rc) {\n\t\t\tlpfcdiag_loop_self_unreg(phba, rpi);\n\t\t\tgoto loopback_test_exit;\n\t\t}\n\t}\n\tevt = lpfc_bsg_event_new(FC_REG_CT_EVENT, current->pid,\n\t\t\t\tSLI_CT_ELX_LOOPBACK);\n\tif (!evt) {\n\t\tlpfcdiag_loop_self_unreg(phba, rpi);\n\t\trc = -ENOMEM;\n\t\tgoto loopback_test_exit;\n\t}\n\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tlist_add(&evt->node, &phba->ct_ev_waiters);\n\tlpfc_bsg_event_ref(evt);\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\tcmdiocbq = lpfc_sli_get_iocbq(phba);\n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\trspiocbq = lpfc_sli_get_iocbq(phba);\n\ttxbmp = kmalloc(sizeof(struct lpfc_dmabuf), GFP_KERNEL);\n\n\tif (txbmp) {\n\t\ttxbmp->virt = lpfc_mbuf_alloc(phba, 0, &txbmp->phys);\n\t\tif (txbmp->virt) {\n\t\t\tINIT_LIST_HEAD(&txbmp->list);\n\t\t\ttxbpl = (struct ulp_bde64 *) txbmp->virt;\n\t\t\ttxbuffer = diag_cmd_data_alloc(phba,\n\t\t\t\t\t\t\ttxbpl, full_size, 0);\n\t\t}\n\t}\n\n\tif (!cmdiocbq || !txbmp || !txbpl || !txbuffer || !txbmp->virt) {\n\t\trc = -ENOMEM;\n\t\tgoto err_loopback_test_exit;\n\t}\n\tif ((phba->sli_rev < LPFC_SLI_REV4) && !rspiocbq) {\n\t\trc = -ENOMEM;\n\t\tgoto err_loopback_test_exit;\n\t}\n\n\tcmdwqe = &cmdiocbq->wqe;\n\tmemset(cmdwqe, 0, sizeof(union lpfc_wqe));\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\trspwqe = &rspiocbq->wqe;\n\t\tmemset(rspwqe, 0, sizeof(union lpfc_wqe));\n\t}\n\n\tINIT_LIST_HEAD(&head);\n\tlist_add_tail(&head, &txbuffer->dma.list);\n\tlist_for_each_entry(curr, &head, list) {\n\t\tsegment_len = ((struct lpfc_dmabufext *)curr)->size;\n\t\tif (current_offset == 0) {\n\t\t\tctreq = curr->virt;\n\t\t\tmemset(ctreq, 0, ELX_LOOPBACK_HEADER_SZ);\n\t\t\tctreq->RevisionId.bits.Revision = SLI_CT_REVISION;\n\t\t\tctreq->RevisionId.bits.InId = 0;\n\t\t\tctreq->FsType = SLI_CT_ELX_LOOPBACK;\n\t\t\tctreq->FsSubType = 0;\n\t\t\tctreq->CommandResponse.bits.CmdRsp = cpu_to_be16(ELX_LOOPBACK_DATA);\n\t\t\tctreq->CommandResponse.bits.Size   = cpu_to_be16(size);\n\t\t\tsegment_offset = ELX_LOOPBACK_HEADER_SZ;\n\t\t} else\n\t\t\tsegment_offset = 0;\n\n\t\tBUG_ON(segment_offset >= segment_len);\n\t\tmemcpy(curr->virt + segment_offset,\n\t\t\tptr + current_offset,\n\t\t\tsegment_len - segment_offset);\n\n\t\tcurrent_offset += segment_len - segment_offset;\n\t\tBUG_ON(current_offset > size);\n\t}\n\tlist_del(&head);\n\n\t \n\tnum_bde = (uint32_t)txbuffer->flag;\n\n\tcmdiocbq->num_bdes = num_bde;\n\tcmdiocbq->cmd_flag |= LPFC_IO_LIBDFC;\n\tcmdiocbq->cmd_flag |= LPFC_IO_LOOPBACK;\n\tcmdiocbq->vport = phba->pport;\n\tcmdiocbq->cmd_cmpl = NULL;\n\tcmdiocbq->bpl_dmabuf = txbmp;\n\n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\tlpfc_sli_prep_xmit_seq64(phba, cmdiocbq, txbmp, 0, txxri,\n\t\t\t\t\t num_bde, FC_RCTL_DD_UNSOL_CTL, 1,\n\t\t\t\t\t CMD_XMIT_SEQUENCE64_CX);\n\n\t} else {\n\t\tlpfc_sli_prep_xmit_seq64(phba, cmdiocbq, txbmp,\n\t\t\t\t\t phba->sli4_hba.rpi_ids[rpi], 0xffff,\n\t\t\t\t\t full_size, FC_RCTL_DD_UNSOL_CTL, 1,\n\t\t\t\t\t CMD_XMIT_SEQUENCE64_WQE);\n\t\tcmdiocbq->sli4_xritag = NO_XRI;\n\t}\n\n\tiocb_stat = lpfc_sli_issue_iocb_wait(phba, LPFC_ELS_RING, cmdiocbq,\n\t\t\t\t\t     rspiocbq, (phba->fc_ratov * 2) +\n\t\t\t\t\t     LPFC_DRVR_TIMEOUT);\n\tif (iocb_stat != IOCB_SUCCESS ||\n\t    (phba->sli_rev < LPFC_SLI_REV4 &&\n\t     (get_job_ulpstatus(phba, rspiocbq) != IOSTAT_SUCCESS))) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"3126 Failed loopback test issue iocb: \"\n\t\t\t\t\"iocb_stat:x%x\\n\", iocb_stat);\n\t\trc = -EIO;\n\t\tgoto err_loopback_test_exit;\n\t}\n\n\tevt->waiting = 1;\n\ttime_left = wait_event_interruptible_timeout(\n\t\tevt->wq, !list_empty(&evt->events_to_see),\n\t\tmsecs_to_jiffies(1000 *\n\t\t\t((phba->fc_ratov * 2) + LPFC_DRVR_TIMEOUT)));\n\tevt->waiting = 0;\n\tif (list_empty(&evt->events_to_see)) {\n\t\trc = (time_left) ? -EINTR : -ETIMEDOUT;\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"3125 Not receiving unsolicited event, \"\n\t\t\t\t\"rc:x%x\\n\", rc);\n\t} else {\n\t\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\t\tlist_move(evt->events_to_see.prev, &evt->events_to_get);\n\t\tevdat = list_entry(evt->events_to_get.prev,\n\t\t\t\t   typeof(*evdat), node);\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\trx_databuf = evdat->data;\n\t\tif (evdat->len != full_size) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"1603 Loopback test did not receive expected \"\n\t\t\t\t\"data length. actual length 0x%x expected \"\n\t\t\t\t\"length 0x%x\\n\",\n\t\t\t\tevdat->len, full_size);\n\t\t\trc = -EIO;\n\t\t} else if (rx_databuf == NULL)\n\t\t\trc = -EIO;\n\t\telse {\n\t\t\trc = IOCB_SUCCESS;\n\t\t\t \n\t\t\trx_databuf += ELX_LOOPBACK_HEADER_SZ;\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t\t\t    rx_databuf, size);\n\t\t\tbsg_reply->reply_payload_rcv_len = size;\n\t\t}\n\t}\n\nerr_loopback_test_exit:\n\tlpfcdiag_loop_self_unreg(phba, rpi);\n\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tlpfc_bsg_event_unref(evt);  \n\tlpfc_bsg_event_unref(evt);  \n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\tif ((cmdiocbq != NULL) && (iocb_stat != IOCB_TIMEDOUT))\n\t\tlpfc_sli_release_iocbq(phba, cmdiocbq);\n\n\tif (rspiocbq != NULL)\n\t\tlpfc_sli_release_iocbq(phba, rspiocbq);\n\n\tif (txbmp != NULL) {\n\t\tif (txbpl != NULL) {\n\t\t\tif (txbuffer != NULL)\n\t\t\t\tdiag_cmd_data_free(phba, txbuffer);\n\t\t\tlpfc_mbuf_free(phba, txbmp->virt, txbmp->phys);\n\t\t}\n\t\tkfree(txbmp);\n\t}\n\nloopback_test_exit:\n\tkfree(dataout);\n\t \n\tbsg_reply->result = rc;\n\tjob->dd_data = NULL;\n\t \n\tif (rc == IOCB_SUCCESS)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_get_dfc_rev(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct get_mgmt_rev_reply *event_reply;\n\tint rc = 0;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) + sizeof(struct get_mgmt_rev)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2740 Received GET_DFC_REV request below \"\n\t\t\t\t\"minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tevent_reply = (struct get_mgmt_rev_reply *)\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp;\n\n\tif (job->reply_len < sizeof(*bsg_reply) + sizeof(*event_reply)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2741 Received GET_DFC_REV reply below \"\n\t\t\t\t\"minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tevent_reply->info.a_Major = MANAGEMENT_MAJOR_REV;\n\tevent_reply->info.a_Minor = MANAGEMENT_MINOR_REV;\njob_error:\n\tbsg_reply->result = rc;\n\tif (rc == 0)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n}\n\n \nstatic void\nlpfc_bsg_issue_mbox_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\n{\n\tstruct bsg_job_data *dd_data;\n\tstruct fc_bsg_reply *bsg_reply;\n\tstruct bsg_job *job;\n\tuint32_t size;\n\tunsigned long flags;\n\tuint8_t *pmb, *pmb_buf;\n\n\tdd_data = pmboxq->ctx_ndlp;\n\n\t \n\tpmb = (uint8_t *)&pmboxq->u.mb;\n\tpmb_buf = (uint8_t *)dd_data->context_un.mbox.mb;\n\tmemcpy(pmb_buf, pmb, sizeof(MAILBOX_t));\n\n\t \n\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tjob = dd_data->set_job;\n\tif (job) {\n\t\t \n\t\tjob->dd_data = NULL;\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\t \n\n\tif (job) {\n\t\tbsg_reply = job->reply;\n\t\tsize = job->reply_payload.payload_len;\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t\t    pmb_buf, size);\n\t}\n\n\tdd_data->set_job = NULL;\n\tmempool_free(dd_data->context_un.mbox.pmboxq, phba->mbox_mem_pool);\n\tlpfc_bsg_dma_page_free(phba, dd_data->context_un.mbox.dmabuffers);\n\tkfree(dd_data);\n\n\t \n\n\tif (job) {\n\t\tbsg_reply->result = 0;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t}\n\treturn;\n}\n\n \nstatic int lpfc_bsg_check_cmd_access(struct lpfc_hba *phba,\n\tMAILBOX_t *mb, struct lpfc_vport *vport)\n{\n\t \n\tswitch (mb->mbxCommand) {\n\t \n\tcase MBX_INIT_LINK:\n\tcase MBX_DOWN_LINK:\n\tcase MBX_CONFIG_LINK:\n\tcase MBX_CONFIG_RING:\n\tcase MBX_RESET_RING:\n\tcase MBX_UNREG_LOGIN:\n\tcase MBX_CLEAR_LA:\n\tcase MBX_DUMP_CONTEXT:\n\tcase MBX_RUN_DIAGS:\n\tcase MBX_RESTART:\n\tcase MBX_SET_MASK:\n\t\tif (!(vport->fc_flag & FC_OFFLINE_MODE)) {\n\t\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2743 Command 0x%x is illegal in on-line \"\n\t\t\t\t\"state\\n\",\n\t\t\t\tmb->mbxCommand);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tbreak;\n\tcase MBX_WRITE_NV:\n\tcase MBX_WRITE_VPARMS:\n\tcase MBX_LOAD_SM:\n\tcase MBX_READ_NV:\n\tcase MBX_READ_CONFIG:\n\tcase MBX_READ_RCONFIG:\n\tcase MBX_READ_STATUS:\n\tcase MBX_READ_XRI:\n\tcase MBX_READ_REV:\n\tcase MBX_READ_LNK_STAT:\n\tcase MBX_DUMP_MEMORY:\n\tcase MBX_DOWN_LOAD:\n\tcase MBX_UPDATE_CFG:\n\tcase MBX_KILL_BOARD:\n\tcase MBX_READ_TOPOLOGY:\n\tcase MBX_LOAD_AREA:\n\tcase MBX_LOAD_EXP_ROM:\n\tcase MBX_BEACON:\n\tcase MBX_DEL_LD_ENTRY:\n\tcase MBX_SET_DEBUG:\n\tcase MBX_WRITE_WWN:\n\tcase MBX_SLI4_CONFIG:\n\tcase MBX_READ_EVENT_LOG:\n\tcase MBX_READ_EVENT_LOG_STATUS:\n\tcase MBX_WRITE_EVENT_LOG:\n\tcase MBX_PORT_CAPABILITIES:\n\tcase MBX_PORT_IOV_CONTROL:\n\tcase MBX_RUN_BIU_DIAG64:\n\t\tbreak;\n\tcase MBX_SET_VARIABLE:\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\"1226 mbox: set_variable 0x%x, 0x%x\\n\",\n\t\t\tmb->un.varWords[0],\n\t\t\tmb->un.varWords[1]);\n\t\tbreak;\n\tcase MBX_READ_SPARM64:\n\tcase MBX_REG_LOGIN:\n\tcase MBX_REG_LOGIN64:\n\tcase MBX_CONFIG_PORT:\n\tcase MBX_RUN_BIU_DIAG:\n\tdefault:\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\"2742 Unknown Command 0x%x\\n\",\n\t\t\tmb->mbxCommand);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;  \n}\n\n \nstatic void\nlpfc_bsg_mbox_ext_session_reset(struct lpfc_hba *phba)\n{\n\tif (phba->mbox_ext_buf_ctx.state == LPFC_BSG_MBOX_IDLE)\n\t\treturn;\n\n\t \n\tlpfc_bsg_dma_page_list_free(phba,\n\t\t\t\t    &phba->mbox_ext_buf_ctx.ext_dmabuf_list);\n\tlpfc_bsg_dma_page_free(phba, phba->mbox_ext_buf_ctx.mbx_dmabuf);\n\t \n\tmemset((char *)&phba->mbox_ext_buf_ctx, 0,\n\t       sizeof(struct lpfc_mbox_ext_buf_ctx));\n\tINIT_LIST_HEAD(&phba->mbox_ext_buf_ctx.ext_dmabuf_list);\n\n\treturn;\n}\n\n \nstatic struct bsg_job *\nlpfc_bsg_issue_mbox_ext_handle_job(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\n{\n\tstruct bsg_job_data *dd_data;\n\tstruct bsg_job *job;\n\tstruct fc_bsg_reply *bsg_reply;\n\tuint8_t *pmb, *pmb_buf;\n\tunsigned long flags;\n\tuint32_t size;\n\tint rc = 0;\n\tstruct lpfc_dmabuf *dmabuf;\n\tstruct lpfc_sli_config_mbox *sli_cfg_mbx;\n\tuint8_t *pmbx;\n\n\tdd_data = pmboxq->ctx_buf;\n\n\t \n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tjob = dd_data->set_job;\n\tif (job) {\n\t\tbsg_reply = job->reply;\n\t\t \n\t\tjob->dd_data = NULL;\n\t}\n\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\t \n\n\tpmb = (uint8_t *)&pmboxq->u.mb;\n\tpmb_buf = (uint8_t *)dd_data->context_un.mbox.mb;\n\t \n\tmemcpy(pmb_buf, pmb, sizeof(MAILBOX_t));\n\t \n\tdmabuf = phba->mbox_ext_buf_ctx.mbx_dmabuf;\n\tsli_cfg_mbx = (struct lpfc_sli_config_mbox *)dmabuf->virt;\n\tif (!bsg_bf_get(lpfc_mbox_hdr_emb,\n\t    &sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr)) {\n\t\tpmbx = (uint8_t *)dmabuf->virt;\n\t\t \n\t\tlpfc_sli_pcimem_bcopy(&pmbx[sizeof(MAILBOX_t)],\n\t\t\t&pmbx[sizeof(MAILBOX_t)],\n\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.mse[0].buf_len);\n\t}\n\n\t \n\n\tif (job) {\n\t\tsize = job->reply_payload.payload_len;\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t\t    pmb_buf, size);\n\n\t\t \n\t\tbsg_reply->result = 0;\n\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2937 SLI_CONFIG ext-buffer mailbox command \"\n\t\t\t\t\"(x%x/x%x) complete bsg job done, bsize:%d\\n\",\n\t\t\t\tphba->mbox_ext_buf_ctx.nembType,\n\t\t\t\tphba->mbox_ext_buf_ctx.mboxType, size);\n\t\tlpfc_idiag_mbxacc_dump_bsg_mbox(phba,\n\t\t\t\t\tphba->mbox_ext_buf_ctx.nembType,\n\t\t\t\t\tphba->mbox_ext_buf_ctx.mboxType,\n\t\t\t\t\tdma_ebuf, sta_pos_addr,\n\t\t\t\t\tphba->mbox_ext_buf_ctx.mbx_dmabuf, 0);\n\t} else {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"2938 SLI_CONFIG ext-buffer mailbox \"\n\t\t\t\t\"command (x%x/x%x) failure, rc:x%x\\n\",\n\t\t\t\tphba->mbox_ext_buf_ctx.nembType,\n\t\t\t\tphba->mbox_ext_buf_ctx.mboxType, rc);\n\t}\n\n\n\t \n\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_DONE;\n\tkfree(dd_data);\n\treturn job;\n}\n\n \nstatic void\nlpfc_bsg_issue_read_mbox_ext_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\n{\n\tstruct bsg_job *job;\n\tstruct fc_bsg_reply *bsg_reply;\n\n\tjob = lpfc_bsg_issue_mbox_ext_handle_job(phba, pmboxq);\n\n\t \n\tif (!job)\n\t\tpmboxq->u.mb.mbxStatus = MBXERR_ERROR;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\"2939 SLI_CONFIG ext-buffer rd mailbox command \"\n\t\t\t\"complete, ctxState:x%x, mbxStatus:x%x\\n\",\n\t\t\tphba->mbox_ext_buf_ctx.state, pmboxq->u.mb.mbxStatus);\n\n\tif (pmboxq->u.mb.mbxStatus || phba->mbox_ext_buf_ctx.numBuf == 1)\n\t\tlpfc_bsg_mbox_ext_session_reset(phba);\n\n\t \n\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\n\t \n\tif (job) {\n\t\tbsg_reply = job->reply;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t}\n\treturn;\n}\n\n \nstatic void\nlpfc_bsg_issue_write_mbox_ext_cmpl(struct lpfc_hba *phba, LPFC_MBOXQ_t *pmboxq)\n{\n\tstruct bsg_job *job;\n\tstruct fc_bsg_reply *bsg_reply;\n\n\tjob = lpfc_bsg_issue_mbox_ext_handle_job(phba, pmboxq);\n\n\t \n\tif (!job)\n\t\tpmboxq->u.mb.mbxStatus = MBXERR_ERROR;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\"2940 SLI_CONFIG ext-buffer wr mailbox command \"\n\t\t\t\"complete, ctxState:x%x, mbxStatus:x%x\\n\",\n\t\t\tphba->mbox_ext_buf_ctx.state, pmboxq->u.mb.mbxStatus);\n\n\t \n\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\tlpfc_bsg_mbox_ext_session_reset(phba);\n\n\t \n\tif (job) {\n\t\tbsg_reply = job->reply;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t}\n\n\treturn;\n}\n\nstatic void\nlpfc_bsg_sli_cfg_dma_desc_setup(struct lpfc_hba *phba, enum nemb_type nemb_tp,\n\t\t\t\tuint32_t index, struct lpfc_dmabuf *mbx_dmabuf,\n\t\t\t\tstruct lpfc_dmabuf *ext_dmabuf)\n{\n\tstruct lpfc_sli_config_mbox *sli_cfg_mbx;\n\n\t \n\tsli_cfg_mbx = (struct lpfc_sli_config_mbox *)mbx_dmabuf->virt;\n\n\tif (nemb_tp == nemb_mse) {\n\t\tif (index == 0) {\n\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\tmse[index].pa_hi =\n\t\t\t\tputPaddrHigh(mbx_dmabuf->phys +\n\t\t\t\t\t     sizeof(MAILBOX_t));\n\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\tmse[index].pa_lo =\n\t\t\t\tputPaddrLow(mbx_dmabuf->phys +\n\t\t\t\t\t    sizeof(MAILBOX_t));\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"2943 SLI_CONFIG(mse)[%d], \"\n\t\t\t\t\t\"bufLen:%d, addrHi:x%x, addrLo:x%x\\n\",\n\t\t\t\t\tindex,\n\t\t\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\t\tmse[index].buf_len,\n\t\t\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\t\tmse[index].pa_hi,\n\t\t\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\t\tmse[index].pa_lo);\n\t\t} else {\n\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\tmse[index].pa_hi =\n\t\t\t\tputPaddrHigh(ext_dmabuf->phys);\n\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\tmse[index].pa_lo =\n\t\t\t\tputPaddrLow(ext_dmabuf->phys);\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"2944 SLI_CONFIG(mse)[%d], \"\n\t\t\t\t\t\"bufLen:%d, addrHi:x%x, addrLo:x%x\\n\",\n\t\t\t\t\tindex,\n\t\t\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\t\tmse[index].buf_len,\n\t\t\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\t\tmse[index].pa_hi,\n\t\t\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\t\tmse[index].pa_lo);\n\t\t}\n\t} else {\n\t\tif (index == 0) {\n\t\t\tsli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[index].pa_hi =\n\t\t\t\tputPaddrHigh(mbx_dmabuf->phys +\n\t\t\t\t\t     sizeof(MAILBOX_t));\n\t\t\tsli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[index].pa_lo =\n\t\t\t\tputPaddrLow(mbx_dmabuf->phys +\n\t\t\t\t\t    sizeof(MAILBOX_t));\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"3007 SLI_CONFIG(hbd)[%d], \"\n\t\t\t\t\t\"bufLen:%d, addrHi:x%x, addrLo:x%x\\n\",\n\t\t\t\tindex,\n\t\t\t\tbsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,\n\t\t\t\t&sli_cfg_mbx->un.\n\t\t\t\tsli_config_emb1_subsys.hbd[index]),\n\t\t\t\tsli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[index].pa_hi,\n\t\t\t\tsli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[index].pa_lo);\n\n\t\t} else {\n\t\t\tsli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[index].pa_hi =\n\t\t\t\tputPaddrHigh(ext_dmabuf->phys);\n\t\t\tsli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[index].pa_lo =\n\t\t\t\tputPaddrLow(ext_dmabuf->phys);\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"3008 SLI_CONFIG(hbd)[%d], \"\n\t\t\t\t\t\"bufLen:%d, addrHi:x%x, addrLo:x%x\\n\",\n\t\t\t\tindex,\n\t\t\t\tbsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,\n\t\t\t\t&sli_cfg_mbx->un.\n\t\t\t\tsli_config_emb1_subsys.hbd[index]),\n\t\t\t\tsli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[index].pa_hi,\n\t\t\t\tsli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[index].pa_lo);\n\t\t}\n\t}\n\treturn;\n}\n\n \nstatic int\nlpfc_bsg_sli_cfg_read_cmd_ext(struct lpfc_hba *phba, struct bsg_job *job,\n\t\t\t      enum nemb_type nemb_tp,\n\t\t\t      struct lpfc_dmabuf *dmabuf)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct lpfc_sli_config_mbox *sli_cfg_mbx;\n\tstruct dfc_mbox_req *mbox_req;\n\tstruct lpfc_dmabuf *curr_dmabuf, *next_dmabuf;\n\tuint32_t ext_buf_cnt, ext_buf_index;\n\tstruct lpfc_dmabuf *ext_dmabuf = NULL;\n\tstruct bsg_job_data *dd_data = NULL;\n\tLPFC_MBOXQ_t *pmboxq = NULL;\n\tMAILBOX_t *pmb;\n\tuint8_t *pmbx;\n\tint rc, i;\n\n\tmbox_req =\n\t   (struct dfc_mbox_req *)bsg_request->rqst_data.h_vendor.vendor_cmd;\n\n\t \n\tsli_cfg_mbx = (struct lpfc_sli_config_mbox *)dmabuf->virt;\n\n\tif (nemb_tp == nemb_mse) {\n\t\text_buf_cnt = bsg_bf_get(lpfc_mbox_hdr_mse_cnt,\n\t\t\t&sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr);\n\t\tif (ext_buf_cnt > LPFC_MBX_SLI_CONFIG_MAX_MSE) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\t\"2945 Handled SLI_CONFIG(mse) rd, \"\n\t\t\t\t\t\"ext_buf_cnt(%d) out of range(%d)\\n\",\n\t\t\t\t\text_buf_cnt,\n\t\t\t\t\tLPFC_MBX_SLI_CONFIG_MAX_MSE);\n\t\t\trc = -ERANGE;\n\t\t\tgoto job_error;\n\t\t}\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2941 Handled SLI_CONFIG(mse) rd, \"\n\t\t\t\t\"ext_buf_cnt:%d\\n\", ext_buf_cnt);\n\t} else {\n\t\t \n\t\tif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t\t    LPFC_SLI_INTF_IF_TYPE_2) {\n\t\t\trc = -ENODEV;\n\t\t\tgoto job_error;\n\t\t}\n\t\t \n\t\text_buf_cnt = sli_cfg_mbx->un.sli_config_emb1_subsys.hbd_count;\n\t\tif (ext_buf_cnt > LPFC_MBX_SLI_CONFIG_MAX_HBD) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\t\"2946 Handled SLI_CONFIG(hbd) rd, \"\n\t\t\t\t\t\"ext_buf_cnt(%d) out of range(%d)\\n\",\n\t\t\t\t\text_buf_cnt,\n\t\t\t\t\tLPFC_MBX_SLI_CONFIG_MAX_HBD);\n\t\t\trc = -ERANGE;\n\t\t\tgoto job_error;\n\t\t}\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2942 Handled SLI_CONFIG(hbd) rd, \"\n\t\t\t\t\"ext_buf_cnt:%d\\n\", ext_buf_cnt);\n\t}\n\n\t \n\tlpfc_idiag_mbxacc_dump_bsg_mbox(phba, nemb_tp, mbox_rd, dma_mbox,\n\t\t\t\t\tsta_pre_addr, dmabuf, ext_buf_cnt);\n\n\t \n\tif (ext_buf_cnt == 0) {\n\t\trc = -EPERM;\n\t\tgoto job_error;\n\t} else if (ext_buf_cnt > 1) {\n\t\t \n\t\tfor (i = 1; i < ext_buf_cnt; i++) {\n\t\t\text_dmabuf = lpfc_bsg_dma_page_alloc(phba);\n\t\t\tif (!ext_dmabuf) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto job_error;\n\t\t\t}\n\t\t\tlist_add_tail(&ext_dmabuf->list,\n\t\t\t\t      &phba->mbox_ext_buf_ctx.ext_dmabuf_list);\n\t\t}\n\t}\n\n\t \n\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\tif (!dd_data) {\n\t\trc = -ENOMEM;\n\t\tgoto job_error;\n\t}\n\n\t \n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq) {\n\t\trc = -ENOMEM;\n\t\tgoto job_error;\n\t}\n\tmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\n\t \n\tlpfc_bsg_sli_cfg_dma_desc_setup(phba, nemb_tp, 0, dmabuf, dmabuf);\n\n\t \n\tif (ext_buf_cnt > 1) {\n\t\text_buf_index = 1;\n\t\tlist_for_each_entry_safe(curr_dmabuf, next_dmabuf,\n\t\t\t\t&phba->mbox_ext_buf_ctx.ext_dmabuf_list, list) {\n\t\t\tlpfc_bsg_sli_cfg_dma_desc_setup(phba, nemb_tp,\n\t\t\t\t\t\text_buf_index, dmabuf,\n\t\t\t\t\t\tcurr_dmabuf);\n\t\t\text_buf_index++;\n\t\t}\n\t}\n\n\t \n\tlpfc_idiag_mbxacc_dump_bsg_mbox(phba, nemb_tp, mbox_rd, dma_mbox,\n\t\t\t\t\tsta_pos_addr, dmabuf, ext_buf_cnt);\n\n\t \n\tpmb = &pmboxq->u.mb;\n\tpmbx = (uint8_t *)dmabuf->virt;\n\tmemcpy(pmb, pmbx, sizeof(*pmb));\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->vport = phba->pport;\n\n\t \n\tphba->mbox_ext_buf_ctx.nembType = nemb_tp;\n\tphba->mbox_ext_buf_ctx.mboxType = mbox_rd;\n\tphba->mbox_ext_buf_ctx.numBuf = ext_buf_cnt;\n\tphba->mbox_ext_buf_ctx.mbxTag = mbox_req->extMboxTag;\n\tphba->mbox_ext_buf_ctx.seqNum = mbox_req->extSeqNum;\n\tphba->mbox_ext_buf_ctx.mbx_dmabuf = dmabuf;\n\n\t \n\tpmboxq->mbox_cmpl = lpfc_bsg_issue_read_mbox_ext_cmpl;\n\n\t \n\tpmboxq->ctx_buf = dd_data;\n\tdd_data->type = TYPE_MBOX;\n\tdd_data->set_job = job;\n\tdd_data->context_un.mbox.pmboxq = pmboxq;\n\tdd_data->context_un.mbox.mb = (MAILBOX_t *)pmbx;\n\tjob->dd_data = dd_data;\n\n\t \n\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_PORT;\n\n\t \n\tif ((!bsg_bf_get(lpfc_mbox_hdr_emb,\n\t    &sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr)) &&\n\t\t(nemb_tp == nemb_mse))\n\t\tlpfc_sli_pcimem_bcopy(&pmbx[sizeof(MAILBOX_t)],\n\t\t\t&pmbx[sizeof(MAILBOX_t)],\n\t\t\t\tsli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\t\tmse[0].buf_len);\n\n\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);\n\tif ((rc == MBX_SUCCESS) || (rc == MBX_BUSY)) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2947 Issued SLI_CONFIG ext-buffer \"\n\t\t\t\t\"mailbox command, rc:x%x\\n\", rc);\n\t\treturn SLI_CONFIG_HANDLED;\n\t}\n\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\"2948 Failed to issue SLI_CONFIG ext-buffer \"\n\t\t\t\"mailbox command, rc:x%x\\n\", rc);\n\trc = -EPIPE;\n\njob_error:\n\tif (pmboxq)\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\tlpfc_bsg_dma_page_list_free(phba,\n\t\t\t\t    &phba->mbox_ext_buf_ctx.ext_dmabuf_list);\n\tkfree(dd_data);\n\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_IDLE;\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_sli_cfg_write_cmd_ext(struct lpfc_hba *phba, struct bsg_job *job,\n\t\t\t       enum nemb_type nemb_tp,\n\t\t\t       struct lpfc_dmabuf *dmabuf)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct dfc_mbox_req *mbox_req;\n\tstruct lpfc_sli_config_mbox *sli_cfg_mbx;\n\tuint32_t ext_buf_cnt;\n\tstruct bsg_job_data *dd_data = NULL;\n\tLPFC_MBOXQ_t *pmboxq = NULL;\n\tMAILBOX_t *pmb;\n\tuint8_t *mbx;\n\tint rc = SLI_CONFIG_NOT_HANDLED, i;\n\n\tmbox_req =\n\t   (struct dfc_mbox_req *)bsg_request->rqst_data.h_vendor.vendor_cmd;\n\n\t \n\tsli_cfg_mbx = (struct lpfc_sli_config_mbox *)dmabuf->virt;\n\n\tif (nemb_tp == nemb_mse) {\n\t\text_buf_cnt = bsg_bf_get(lpfc_mbox_hdr_mse_cnt,\n\t\t\t&sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr);\n\t\tif (ext_buf_cnt > LPFC_MBX_SLI_CONFIG_MAX_MSE) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\t\"2953 Failed SLI_CONFIG(mse) wr, \"\n\t\t\t\t\t\"ext_buf_cnt(%d) out of range(%d)\\n\",\n\t\t\t\t\text_buf_cnt,\n\t\t\t\t\tLPFC_MBX_SLI_CONFIG_MAX_MSE);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2949 Handled SLI_CONFIG(mse) wr, \"\n\t\t\t\t\"ext_buf_cnt:%d\\n\", ext_buf_cnt);\n\t} else {\n\t\t \n\t\tif (bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf) <\n\t\t    LPFC_SLI_INTF_IF_TYPE_2)\n\t\t\treturn -ENODEV;\n\t\t \n\t\text_buf_cnt = sli_cfg_mbx->un.sli_config_emb1_subsys.hbd_count;\n\t\tif (ext_buf_cnt > LPFC_MBX_SLI_CONFIG_MAX_HBD) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\t\"2954 Failed SLI_CONFIG(hbd) wr, \"\n\t\t\t\t\t\"ext_buf_cnt(%d) out of range(%d)\\n\",\n\t\t\t\t\text_buf_cnt,\n\t\t\t\t\tLPFC_MBX_SLI_CONFIG_MAX_HBD);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2950 Handled SLI_CONFIG(hbd) wr, \"\n\t\t\t\t\"ext_buf_cnt:%d\\n\", ext_buf_cnt);\n\t}\n\n\t \n\tlpfc_idiag_mbxacc_dump_bsg_mbox(phba, nemb_tp, mbox_wr, dma_mbox,\n\t\t\t\t\tsta_pre_addr, dmabuf, ext_buf_cnt);\n\n\tif (ext_buf_cnt == 0)\n\t\treturn -EPERM;\n\n\t \n\tlpfc_bsg_sli_cfg_dma_desc_setup(phba, nemb_tp, 0, dmabuf, dmabuf);\n\n\t \n\tlpfc_idiag_mbxacc_dump_bsg_mbox(phba, nemb_tp, mbox_wr, dma_mbox,\n\t\t\t\t\tsta_pos_addr, dmabuf, ext_buf_cnt);\n\n\t \n\tfor (i = 1; i < ext_buf_cnt; i++) {\n\t\tif (nemb_tp == nemb_mse)\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2951 SLI_CONFIG(mse), buf[%d]-length:%d\\n\",\n\t\t\t\ti, sli_cfg_mbx->un.sli_config_emb0_subsys.\n\t\t\t\tmse[i].buf_len);\n\t\telse\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2952 SLI_CONFIG(hbd), buf[%d]-length:%d\\n\",\n\t\t\t\ti, bsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,\n\t\t\t\t&sli_cfg_mbx->un.sli_config_emb1_subsys.\n\t\t\t\thbd[i]));\n\t}\n\n\t \n\tphba->mbox_ext_buf_ctx.nembType = nemb_tp;\n\tphba->mbox_ext_buf_ctx.mboxType = mbox_wr;\n\tphba->mbox_ext_buf_ctx.numBuf = ext_buf_cnt;\n\tphba->mbox_ext_buf_ctx.mbxTag = mbox_req->extMboxTag;\n\tphba->mbox_ext_buf_ctx.seqNum = mbox_req->extSeqNum;\n\tphba->mbox_ext_buf_ctx.mbx_dmabuf = dmabuf;\n\n\tif (ext_buf_cnt == 1) {\n\t\t \n\t\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\t\tif (!dd_data) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto job_error;\n\t\t}\n\n\t\t \n\t\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (!pmboxq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto job_error;\n\t\t}\n\t\tmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\t\tpmb = &pmboxq->u.mb;\n\t\tmbx = (uint8_t *)dmabuf->virt;\n\t\tmemcpy(pmb, mbx, sizeof(*pmb));\n\t\tpmb->mbxOwner = OWN_HOST;\n\t\tpmboxq->vport = phba->pport;\n\n\t\t \n\t\tpmboxq->mbox_cmpl = lpfc_bsg_issue_write_mbox_ext_cmpl;\n\n\t\t \n\t\tpmboxq->ctx_buf = dd_data;\n\t\tdd_data->type = TYPE_MBOX;\n\t\tdd_data->set_job = job;\n\t\tdd_data->context_un.mbox.pmboxq = pmboxq;\n\t\tdd_data->context_un.mbox.mb = (MAILBOX_t *)mbx;\n\t\tjob->dd_data = dd_data;\n\n\t\t \n\n\t\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_PORT;\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);\n\t\tif ((rc == MBX_SUCCESS) || (rc == MBX_BUSY)) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"2955 Issued SLI_CONFIG ext-buffer \"\n\t\t\t\t\t\"mailbox command, rc:x%x\\n\", rc);\n\t\t\treturn SLI_CONFIG_HANDLED;\n\t\t}\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"2956 Failed to issue SLI_CONFIG ext-buffer \"\n\t\t\t\t\"mailbox command, rc:x%x\\n\", rc);\n\t\trc = -EPIPE;\n\t\tgoto job_error;\n\t}\n\n\t \n\n\tbsg_reply->result = 0;\n\tbsg_job_done(job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn SLI_CONFIG_HANDLED;\n\njob_error:\n\tif (pmboxq)\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\tkfree(dd_data);\n\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_handle_sli_cfg_mbox(struct lpfc_hba *phba, struct bsg_job *job,\n\t\t\t     struct lpfc_dmabuf *dmabuf)\n{\n\tstruct lpfc_sli_config_mbox *sli_cfg_mbx;\n\tuint32_t subsys;\n\tuint32_t opcode;\n\tint rc = SLI_CONFIG_NOT_HANDLED;\n\n\t \n\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_HOST;\n\n\tsli_cfg_mbx = (struct lpfc_sli_config_mbox *)dmabuf->virt;\n\n\tif (!bsg_bf_get(lpfc_mbox_hdr_emb,\n\t    &sli_cfg_mbx->un.sli_config_emb0_subsys.sli_config_hdr)) {\n\t\tsubsys = bsg_bf_get(lpfc_emb0_subcmnd_subsys,\n\t\t\t\t    &sli_cfg_mbx->un.sli_config_emb0_subsys);\n\t\topcode = bsg_bf_get(lpfc_emb0_subcmnd_opcode,\n\t\t\t\t    &sli_cfg_mbx->un.sli_config_emb0_subsys);\n\t\tif (subsys == SLI_CONFIG_SUBSYS_FCOE) {\n\t\t\tswitch (opcode) {\n\t\t\tcase FCOE_OPCODE_READ_FCF:\n\t\t\tcase FCOE_OPCODE_GET_DPORT_RESULTS:\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\t\"2957 Handled SLI_CONFIG \"\n\t\t\t\t\t\t\"subsys_fcoe, opcode:x%x\\n\",\n\t\t\t\t\t\topcode);\n\t\t\t\trc = lpfc_bsg_sli_cfg_read_cmd_ext(phba, job,\n\t\t\t\t\t\t\tnemb_mse, dmabuf);\n\t\t\t\tbreak;\n\t\t\tcase FCOE_OPCODE_ADD_FCF:\n\t\t\tcase FCOE_OPCODE_SET_DPORT_MODE:\n\t\t\tcase LPFC_MBOX_OPCODE_FCOE_LINK_DIAG_STATE:\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\t\"2958 Handled SLI_CONFIG \"\n\t\t\t\t\t\t\"subsys_fcoe, opcode:x%x\\n\",\n\t\t\t\t\t\topcode);\n\t\t\t\trc = lpfc_bsg_sli_cfg_write_cmd_ext(phba, job,\n\t\t\t\t\t\t\tnemb_mse, dmabuf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\t\"2959 Reject SLI_CONFIG \"\n\t\t\t\t\t\t\"subsys_fcoe, opcode:x%x\\n\",\n\t\t\t\t\t\topcode);\n\t\t\t\trc = -EPERM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (subsys == SLI_CONFIG_SUBSYS_COMN) {\n\t\t\tswitch (opcode) {\n\t\t\tcase COMN_OPCODE_GET_CNTL_ADDL_ATTRIBUTES:\n\t\t\tcase COMN_OPCODE_GET_CNTL_ATTRIBUTES:\n\t\t\tcase COMN_OPCODE_GET_PROFILE_CONFIG:\n\t\t\tcase COMN_OPCODE_SET_FEATURES:\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\t\"3106 Handled SLI_CONFIG \"\n\t\t\t\t\t\t\"subsys_comn, opcode:x%x\\n\",\n\t\t\t\t\t\topcode);\n\t\t\t\trc = lpfc_bsg_sli_cfg_read_cmd_ext(phba, job,\n\t\t\t\t\t\t\tnemb_mse, dmabuf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\t\"3107 Reject SLI_CONFIG \"\n\t\t\t\t\t\t\"subsys_comn, opcode:x%x\\n\",\n\t\t\t\t\t\topcode);\n\t\t\t\trc = -EPERM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"2977 Reject SLI_CONFIG \"\n\t\t\t\t\t\"subsys:x%d, opcode:x%x\\n\",\n\t\t\t\t\tsubsys, opcode);\n\t\t\trc = -EPERM;\n\t\t}\n\t} else {\n\t\tsubsys = bsg_bf_get(lpfc_emb1_subcmnd_subsys,\n\t\t\t\t    &sli_cfg_mbx->un.sli_config_emb1_subsys);\n\t\topcode = bsg_bf_get(lpfc_emb1_subcmnd_opcode,\n\t\t\t\t    &sli_cfg_mbx->un.sli_config_emb1_subsys);\n\t\tif (subsys == SLI_CONFIG_SUBSYS_COMN) {\n\t\t\tswitch (opcode) {\n\t\t\tcase COMN_OPCODE_READ_OBJECT:\n\t\t\tcase COMN_OPCODE_READ_OBJECT_LIST:\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\t\"2960 Handled SLI_CONFIG \"\n\t\t\t\t\t\t\"subsys_comn, opcode:x%x\\n\",\n\t\t\t\t\t\topcode);\n\t\t\t\trc = lpfc_bsg_sli_cfg_read_cmd_ext(phba, job,\n\t\t\t\t\t\t\tnemb_hbd, dmabuf);\n\t\t\t\tbreak;\n\t\t\tcase COMN_OPCODE_WRITE_OBJECT:\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\t\"2961 Handled SLI_CONFIG \"\n\t\t\t\t\t\t\"subsys_comn, opcode:x%x\\n\",\n\t\t\t\t\t\topcode);\n\t\t\t\trc = lpfc_bsg_sli_cfg_write_cmd_ext(phba, job,\n\t\t\t\t\t\t\tnemb_hbd, dmabuf);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\t\"2962 Not handled SLI_CONFIG \"\n\t\t\t\t\t\t\"subsys_comn, opcode:x%x\\n\",\n\t\t\t\t\t\topcode);\n\t\t\t\trc = SLI_CONFIG_NOT_HANDLED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"2978 Not handled SLI_CONFIG \"\n\t\t\t\t\t\"subsys:x%d, opcode:x%x\\n\",\n\t\t\t\t\tsubsys, opcode);\n\t\t\trc = SLI_CONFIG_NOT_HANDLED;\n\t\t}\n\t}\n\n\t \n\tif (rc != SLI_CONFIG_HANDLED)\n\t\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_IDLE;\n\n\treturn rc;\n}\n\n \nstatic void\nlpfc_bsg_mbox_ext_abort(struct lpfc_hba *phba)\n{\n\tif (phba->mbox_ext_buf_ctx.state == LPFC_BSG_MBOX_PORT)\n\t\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_ABTS;\n\telse\n\t\tlpfc_bsg_mbox_ext_session_reset(phba);\n\treturn;\n}\n\n \nstatic int\nlpfc_bsg_read_ebuf_get(struct lpfc_hba *phba, struct bsg_job *job)\n{\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct lpfc_sli_config_mbox *sli_cfg_mbx;\n\tstruct lpfc_dmabuf *dmabuf;\n\tuint8_t *pbuf;\n\tuint32_t size;\n\tuint32_t index;\n\n\tindex = phba->mbox_ext_buf_ctx.seqNum;\n\tphba->mbox_ext_buf_ctx.seqNum++;\n\n\tsli_cfg_mbx = (struct lpfc_sli_config_mbox *)\n\t\t\tphba->mbox_ext_buf_ctx.mbx_dmabuf->virt;\n\n\tif (phba->mbox_ext_buf_ctx.nembType == nemb_mse) {\n\t\tsize = bsg_bf_get(lpfc_mbox_sli_config_mse_len,\n\t\t\t&sli_cfg_mbx->un.sli_config_emb0_subsys.mse[index]);\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2963 SLI_CONFIG (mse) ext-buffer rd get \"\n\t\t\t\t\"buffer[%d], size:%d\\n\", index, size);\n\t} else {\n\t\tsize = bsg_bf_get(lpfc_mbox_sli_config_ecmn_hbd_len,\n\t\t\t&sli_cfg_mbx->un.sli_config_emb1_subsys.hbd[index]);\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2964 SLI_CONFIG (hbd) ext-buffer rd get \"\n\t\t\t\t\"buffer[%d], size:%d\\n\", index, size);\n\t}\n\tif (list_empty(&phba->mbox_ext_buf_ctx.ext_dmabuf_list))\n\t\treturn -EPIPE;\n\tdmabuf = list_first_entry(&phba->mbox_ext_buf_ctx.ext_dmabuf_list,\n\t\t\t\t  struct lpfc_dmabuf, list);\n\tlist_del_init(&dmabuf->list);\n\n\t \n\tlpfc_idiag_mbxacc_dump_bsg_mbox(phba, phba->mbox_ext_buf_ctx.nembType,\n\t\t\t\t\tmbox_rd, dma_ebuf, sta_pos_addr,\n\t\t\t\t\tdmabuf, index);\n\n\tpbuf = (uint8_t *)dmabuf->virt;\n\tbsg_reply->reply_payload_rcv_len =\n\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t    pbuf, size);\n\n\tlpfc_bsg_dma_page_free(phba, dmabuf);\n\n\tif (phba->mbox_ext_buf_ctx.seqNum == phba->mbox_ext_buf_ctx.numBuf) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2965 SLI_CONFIG (hbd) ext-buffer rd mbox \"\n\t\t\t\t\"command session done\\n\");\n\t\tlpfc_bsg_mbox_ext_session_reset(phba);\n\t}\n\n\tbsg_reply->result = 0;\n\tbsg_job_done(job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\n\treturn SLI_CONFIG_HANDLED;\n}\n\n \nstatic int\nlpfc_bsg_write_ebuf_set(struct lpfc_hba *phba, struct bsg_job *job,\n\t\t\tstruct lpfc_dmabuf *dmabuf)\n{\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct bsg_job_data *dd_data = NULL;\n\tLPFC_MBOXQ_t *pmboxq = NULL;\n\tMAILBOX_t *pmb;\n\tenum nemb_type nemb_tp;\n\tuint8_t *pbuf;\n\tuint32_t size;\n\tuint32_t index;\n\tint rc;\n\n\tindex = phba->mbox_ext_buf_ctx.seqNum;\n\tphba->mbox_ext_buf_ctx.seqNum++;\n\tnemb_tp = phba->mbox_ext_buf_ctx.nembType;\n\n\tpbuf = (uint8_t *)dmabuf->virt;\n\tsize = job->request_payload.payload_len;\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt,\n\t\t\t  pbuf, size);\n\n\tif (phba->mbox_ext_buf_ctx.nembType == nemb_mse) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2966 SLI_CONFIG (mse) ext-buffer wr set \"\n\t\t\t\t\"buffer[%d], size:%d\\n\",\n\t\t\t\tphba->mbox_ext_buf_ctx.seqNum, size);\n\n\t} else {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2967 SLI_CONFIG (hbd) ext-buffer wr set \"\n\t\t\t\t\"buffer[%d], size:%d\\n\",\n\t\t\t\tphba->mbox_ext_buf_ctx.seqNum, size);\n\n\t}\n\n\t \n\tlpfc_bsg_sli_cfg_dma_desc_setup(phba, nemb_tp, index,\n\t\t\t\t\tphba->mbox_ext_buf_ctx.mbx_dmabuf,\n\t\t\t\t\tdmabuf);\n\tlist_add_tail(&dmabuf->list, &phba->mbox_ext_buf_ctx.ext_dmabuf_list);\n\n\t \n\tlpfc_idiag_mbxacc_dump_bsg_mbox(phba, phba->mbox_ext_buf_ctx.nembType,\n\t\t\t\t\tmbox_wr, dma_ebuf, sta_pos_addr,\n\t\t\t\t\tdmabuf, index);\n\n\tif (phba->mbox_ext_buf_ctx.seqNum == phba->mbox_ext_buf_ctx.numBuf) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2968 SLI_CONFIG ext-buffer wr all %d \"\n\t\t\t\t\"ebuffers received\\n\",\n\t\t\t\tphba->mbox_ext_buf_ctx.numBuf);\n\n\t\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\t\tif (!dd_data) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto job_error;\n\t\t}\n\n\t\t \n\t\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\t\tif (!pmboxq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto job_error;\n\t\t}\n\t\tmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\t\tpbuf = (uint8_t *)phba->mbox_ext_buf_ctx.mbx_dmabuf->virt;\n\t\tpmb = &pmboxq->u.mb;\n\t\tmemcpy(pmb, pbuf, sizeof(*pmb));\n\t\tpmb->mbxOwner = OWN_HOST;\n\t\tpmboxq->vport = phba->pport;\n\n\t\t \n\t\tpmboxq->mbox_cmpl = lpfc_bsg_issue_write_mbox_ext_cmpl;\n\n\t\t \n\t\tpmboxq->ctx_buf = dd_data;\n\t\tdd_data->type = TYPE_MBOX;\n\t\tdd_data->set_job = job;\n\t\tdd_data->context_un.mbox.pmboxq = pmboxq;\n\t\tdd_data->context_un.mbox.mb = (MAILBOX_t *)pbuf;\n\t\tjob->dd_data = dd_data;\n\n\t\t \n\t\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_PORT;\n\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);\n\t\tif ((rc == MBX_SUCCESS) || (rc == MBX_BUSY)) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"2969 Issued SLI_CONFIG ext-buffer \"\n\t\t\t\t\t\"mailbox command, rc:x%x\\n\", rc);\n\t\t\treturn SLI_CONFIG_HANDLED;\n\t\t}\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"2970 Failed to issue SLI_CONFIG ext-buffer \"\n\t\t\t\t\"mailbox command, rc:x%x\\n\", rc);\n\t\trc = -EPIPE;\n\t\tgoto job_error;\n\t}\n\n\t \n\tbsg_reply->result = 0;\n\tbsg_job_done(job, bsg_reply->result,\n\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn SLI_CONFIG_HANDLED;\n\njob_error:\n\tif (pmboxq)\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\tlpfc_bsg_dma_page_free(phba, dmabuf);\n\tkfree(dd_data);\n\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_handle_sli_cfg_ebuf(struct lpfc_hba *phba, struct bsg_job *job,\n\t\t\t     struct lpfc_dmabuf *dmabuf)\n{\n\tint rc;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\"2971 SLI_CONFIG buffer (type:x%x)\\n\",\n\t\t\tphba->mbox_ext_buf_ctx.mboxType);\n\n\tif (phba->mbox_ext_buf_ctx.mboxType == mbox_rd) {\n\t\tif (phba->mbox_ext_buf_ctx.state != LPFC_BSG_MBOX_DONE) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\t\"2972 SLI_CONFIG rd buffer state \"\n\t\t\t\t\t\"mismatch:x%x\\n\",\n\t\t\t\t\tphba->mbox_ext_buf_ctx.state);\n\t\t\tlpfc_bsg_mbox_ext_abort(phba);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\trc = lpfc_bsg_read_ebuf_get(phba, job);\n\t\tif (rc == SLI_CONFIG_HANDLED)\n\t\t\tlpfc_bsg_dma_page_free(phba, dmabuf);\n\t} else {  \n\t\tif (phba->mbox_ext_buf_ctx.state != LPFC_BSG_MBOX_HOST) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\t\"2973 SLI_CONFIG wr buffer state \"\n\t\t\t\t\t\"mismatch:x%x\\n\",\n\t\t\t\t\tphba->mbox_ext_buf_ctx.state);\n\t\t\tlpfc_bsg_mbox_ext_abort(phba);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\trc = lpfc_bsg_write_ebuf_set(phba, job, dmabuf);\n\t}\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_handle_sli_cfg_ext(struct lpfc_hba *phba, struct bsg_job *job,\n\t\t\t    struct lpfc_dmabuf *dmabuf)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct dfc_mbox_req *mbox_req;\n\tint rc = SLI_CONFIG_NOT_HANDLED;\n\n\tmbox_req =\n\t   (struct dfc_mbox_req *)bsg_request->rqst_data.h_vendor.vendor_cmd;\n\n\t \n\tif (mbox_req->extMboxTag == 0 && mbox_req->extSeqNum == 0)\n\t\treturn rc;\n\n\t \n\tif (phba->mbox_ext_buf_ctx.state == LPFC_BSG_MBOX_IDLE) {\n\t\tif (mbox_req->extSeqNum == 1) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\t\"2974 SLI_CONFIG mailbox: tag:%d, \"\n\t\t\t\t\t\"seq:%d\\n\", mbox_req->extMboxTag,\n\t\t\t\t\tmbox_req->extSeqNum);\n\t\t\trc = lpfc_bsg_handle_sli_cfg_mbox(phba, job, dmabuf);\n\t\t\treturn rc;\n\t\t} else\n\t\t\tgoto sli_cfg_ext_error;\n\t}\n\n\t \n\n\t \n\tif (mbox_req->extMboxTag != phba->mbox_ext_buf_ctx.mbxTag)\n\t\tgoto sli_cfg_ext_error;\n\tif (mbox_req->extSeqNum > phba->mbox_ext_buf_ctx.numBuf)\n\t\tgoto sli_cfg_ext_error;\n\tif (mbox_req->extSeqNum != phba->mbox_ext_buf_ctx.seqNum + 1)\n\t\tgoto sli_cfg_ext_error;\n\n\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\"2975 SLI_CONFIG mailbox external buffer: \"\n\t\t\t\"extSta:x%x, tag:%d, seq:%d\\n\",\n\t\t\tphba->mbox_ext_buf_ctx.state, mbox_req->extMboxTag,\n\t\t\tmbox_req->extSeqNum);\n\trc = lpfc_bsg_handle_sli_cfg_ebuf(phba, job, dmabuf);\n\treturn rc;\n\nsli_cfg_ext_error:\n\t \n\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\"2976 SLI_CONFIG mailbox broken pipe: \"\n\t\t\t\"ctxSta:x%x, ctxNumBuf:%d \"\n\t\t\t\"ctxTag:%d, ctxSeq:%d, tag:%d, seq:%d\\n\",\n\t\t\tphba->mbox_ext_buf_ctx.state,\n\t\t\tphba->mbox_ext_buf_ctx.numBuf,\n\t\t\tphba->mbox_ext_buf_ctx.mbxTag,\n\t\t\tphba->mbox_ext_buf_ctx.seqNum,\n\t\t\tmbox_req->extMboxTag, mbox_req->extSeqNum);\n\n\tlpfc_bsg_mbox_ext_session_reset(phba);\n\n\treturn -EPIPE;\n}\n\n \nstatic int\nlpfc_bsg_issue_mbox(struct lpfc_hba *phba, struct bsg_job *job,\n\tstruct lpfc_vport *vport)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tLPFC_MBOXQ_t *pmboxq = NULL;  \n\tMAILBOX_t *pmb;  \n\t \n\tuint8_t *pmbx = NULL;\n\tstruct bsg_job_data *dd_data = NULL;  \n\tstruct lpfc_dmabuf *dmabuf = NULL;\n\tstruct dfc_mbox_req *mbox_req;\n\tstruct READ_EVENT_LOG_VAR *rdEventLog;\n\tuint32_t transmit_length, receive_length, mode;\n\tstruct lpfc_mbx_sli4_config *sli4_config;\n\tstruct lpfc_mbx_nembed_cmd *nembed_sge;\n\tstruct ulp_bde64 *bde;\n\tuint8_t *ext = NULL;\n\tint rc = 0;\n\tuint8_t *from;\n\tuint32_t size;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\t \n\tif (job->reply_payload.payload_len > BSG_MBOX_SIZE ||\n\t    job->request_payload.payload_len > BSG_MBOX_SIZE) {\n\t\trc = -ERANGE;\n\t\tgoto job_done;\n\t}\n\n\t \n\tif (phba->sli.sli_flag & LPFC_BLOCK_MGMT_IO) {\n\t\trc = -EAGAIN;\n\t\tgoto job_done;\n\t}\n\n\tmbox_req =\n\t    (struct dfc_mbox_req *)bsg_request->rqst_data.h_vendor.vendor_cmd;\n\n\t \n\tif ((mbox_req->inExtWLen > BSG_MBOX_SIZE/sizeof(uint32_t)) ||\n\t    (mbox_req->outExtWLen > BSG_MBOX_SIZE/sizeof(uint32_t))) {\n\t\trc = -ERANGE;\n\t\tgoto job_done;\n\t}\n\n\tdmabuf = lpfc_bsg_dma_page_alloc(phba);\n\tif (!dmabuf || !dmabuf->virt) {\n\t\trc = -ENOMEM;\n\t\tgoto job_done;\n\t}\n\n\t \n\tpmbx = (uint8_t *)dmabuf->virt;\n\tsize = job->request_payload.payload_len;\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt, pmbx, size);\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\trc = lpfc_bsg_handle_sli_cfg_ext(phba, job, dmabuf);\n\t\tif (rc == SLI_CONFIG_HANDLED)\n\t\t\tgoto job_cont;\n\t\tif (rc)\n\t\t\tgoto job_done;\n\t\t \n\t}\n\n\trc = lpfc_bsg_check_cmd_access(phba, (MAILBOX_t *)pmbx, vport);\n\tif (rc != 0)\n\t\tgoto job_done;  \n\n\t \n\tdd_data = kmalloc(sizeof(struct bsg_job_data), GFP_KERNEL);\n\tif (!dd_data) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2727 Failed allocation of dd_data\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto job_done;\n\t}\n\n\tpmboxq = mempool_alloc(phba->mbox_mem_pool, GFP_KERNEL);\n\tif (!pmboxq) {\n\t\trc = -ENOMEM;\n\t\tgoto job_done;\n\t}\n\tmemset(pmboxq, 0, sizeof(LPFC_MBOXQ_t));\n\n\tpmb = &pmboxq->u.mb;\n\tmemcpy(pmb, pmbx, sizeof(*pmb));\n\tpmb->mbxOwner = OWN_HOST;\n\tpmboxq->vport = vport;\n\n\t \n\tif (phba->pport->stopped &&\n\t    pmb->mbxCommand != MBX_DUMP_MEMORY &&\n\t    pmb->mbxCommand != MBX_RESTART &&\n\t    pmb->mbxCommand != MBX_WRITE_VPARMS &&\n\t    pmb->mbxCommand != MBX_WRITE_WWN)\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_MBOX,\n\t\t\t\t\"2797 mbox: Issued mailbox cmd \"\n\t\t\t\t\"0x%x while in stopped state.\\n\",\n\t\t\t\tpmb->mbxCommand);\n\n\t \n\tif (mbox_req->inExtWLen || mbox_req->outExtWLen) {\n\t\tfrom = pmbx;\n\t\text = from + sizeof(MAILBOX_t);\n\t\tpmboxq->ctx_buf = ext;\n\t\tpmboxq->in_ext_byte_len =\n\t\t\tmbox_req->inExtWLen * sizeof(uint32_t);\n\t\tpmboxq->out_ext_byte_len =\n\t\t\tmbox_req->outExtWLen * sizeof(uint32_t);\n\t\tpmboxq->mbox_offset_word = mbox_req->mbOffset;\n\t}\n\n\t \n\tif (pmb->mbxCommand == MBX_RUN_BIU_DIAG64) {\n\t\ttransmit_length = pmb->un.varWords[1];\n\t\treceive_length = pmb->un.varWords[4];\n\t\t \n\t\tif ((transmit_length > receive_length) ||\n\t\t\t(transmit_length > BSG_MBOX_SIZE - sizeof(MAILBOX_t))) {\n\t\t\trc = -ERANGE;\n\t\t\tgoto job_done;\n\t\t}\n\t\tpmb->un.varBIUdiag.un.s2.xmit_bde64.addrHigh =\n\t\t\tputPaddrHigh(dmabuf->phys + sizeof(MAILBOX_t));\n\t\tpmb->un.varBIUdiag.un.s2.xmit_bde64.addrLow =\n\t\t\tputPaddrLow(dmabuf->phys + sizeof(MAILBOX_t));\n\n\t\tpmb->un.varBIUdiag.un.s2.rcv_bde64.addrHigh =\n\t\t\tputPaddrHigh(dmabuf->phys + sizeof(MAILBOX_t)\n\t\t\t  + pmb->un.varBIUdiag.un.s2.xmit_bde64.tus.f.bdeSize);\n\t\tpmb->un.varBIUdiag.un.s2.rcv_bde64.addrLow =\n\t\t\tputPaddrLow(dmabuf->phys + sizeof(MAILBOX_t)\n\t\t\t  + pmb->un.varBIUdiag.un.s2.xmit_bde64.tus.f.bdeSize);\n\t} else if (pmb->mbxCommand == MBX_READ_EVENT_LOG) {\n\t\trdEventLog = &pmb->un.varRdEventLog;\n\t\treceive_length = rdEventLog->rcv_bde64.tus.f.bdeSize;\n\t\tmode = bf_get(lpfc_event_log, rdEventLog);\n\n\t\t \n\t\tif (receive_length > BSG_MBOX_SIZE - sizeof(MAILBOX_t)) {\n\t\t\trc = -ERANGE;\n\t\t\tgoto job_done;\n\t\t}\n\n\t\t \n\t\tif (mode == 0) {\n\t\t\tpmb->un.varWords[3] = putPaddrLow(dmabuf->phys\n\t\t\t\t\t\t\t+ sizeof(MAILBOX_t));\n\t\t\tpmb->un.varWords[4] = putPaddrHigh(dmabuf->phys\n\t\t\t\t\t\t\t+ sizeof(MAILBOX_t));\n\t\t}\n\t} else if (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t \n\t\tif ((pmb->mbxCommand == MBX_DUMP_MEMORY) &&\n\t\t\t(pmb->un.varDmp.type != DMP_WELL_KNOWN)) {\n\t\t\t \n\t\t\treceive_length = pmb->un.varWords[2];\n\t\t\t \n\t\t\tif (receive_length == 0) {\n\t\t\t\trc = -ERANGE;\n\t\t\t\tgoto job_done;\n\t\t\t}\n\t\t\tpmb->un.varWords[3] = putPaddrLow(dmabuf->phys\n\t\t\t\t\t\t+ sizeof(MAILBOX_t));\n\t\t\tpmb->un.varWords[4] = putPaddrHigh(dmabuf->phys\n\t\t\t\t\t\t+ sizeof(MAILBOX_t));\n\t\t} else if ((pmb->mbxCommand == MBX_UPDATE_CFG) &&\n\t\t\tpmb->un.varUpdateCfg.co) {\n\t\t\tbde = (struct ulp_bde64 *)&pmb->un.varWords[4];\n\n\t\t\t \n\t\t\tif (bde->tus.f.bdeSize >\n\t\t\t    BSG_MBOX_SIZE - sizeof(MAILBOX_t)) {\n\t\t\t\trc = -ERANGE;\n\t\t\t\tgoto job_done;\n\t\t\t}\n\t\t\tbde->addrHigh = putPaddrHigh(dmabuf->phys\n\t\t\t\t\t\t+ sizeof(MAILBOX_t));\n\t\t\tbde->addrLow = putPaddrLow(dmabuf->phys\n\t\t\t\t\t\t+ sizeof(MAILBOX_t));\n\t\t} else if (pmb->mbxCommand == MBX_SLI4_CONFIG) {\n\t\t\t \n\t\t\tsli4_config = &pmboxq->u.mqe.un.sli4_config;\n\t\t\tif (!bf_get(lpfc_mbox_hdr_emb,\n\t\t\t    &sli4_config->header.cfg_mhdr)) {\n\t\t\t\t \n\t\t\t\tnembed_sge = (struct lpfc_mbx_nembed_cmd *)\n\t\t\t\t\t\t&pmb->un.varWords[0];\n\t\t\t\treceive_length = nembed_sge->sge[0].length;\n\n\t\t\t\t \n\t\t\t\tif ((receive_length == 0) ||\n\t\t\t\t    (receive_length >\n\t\t\t\t     BSG_MBOX_SIZE - sizeof(MAILBOX_t))) {\n\t\t\t\t\trc = -ERANGE;\n\t\t\t\t\tgoto job_done;\n\t\t\t\t}\n\n\t\t\t\tnembed_sge->sge[0].pa_hi =\n\t\t\t\t\t\tputPaddrHigh(dmabuf->phys\n\t\t\t\t\t\t   + sizeof(MAILBOX_t));\n\t\t\t\tnembed_sge->sge[0].pa_lo =\n\t\t\t\t\t\tputPaddrLow(dmabuf->phys\n\t\t\t\t\t\t   + sizeof(MAILBOX_t));\n\t\t\t}\n\t\t}\n\t}\n\n\tdd_data->context_un.mbox.dmabuffers = dmabuf;\n\n\t \n\tpmboxq->mbox_cmpl = lpfc_bsg_issue_mbox_cmpl;\n\n\t \n\tpmboxq->ctx_ndlp = dd_data;\n\tdd_data->type = TYPE_MBOX;\n\tdd_data->set_job = job;\n\tdd_data->context_un.mbox.pmboxq = pmboxq;\n\tdd_data->context_un.mbox.mb = (MAILBOX_t *)pmbx;\n\tdd_data->context_un.mbox.ext = ext;\n\tdd_data->context_un.mbox.mbOffset = mbox_req->mbOffset;\n\tdd_data->context_un.mbox.inExtWLen = mbox_req->inExtWLen;\n\tdd_data->context_un.mbox.outExtWLen = mbox_req->outExtWLen;\n\tjob->dd_data = dd_data;\n\n\tif ((vport->fc_flag & FC_OFFLINE_MODE) ||\n\t    (!(phba->sli.sli_flag & LPFC_SLI_ACTIVE))) {\n\t\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_POLL);\n\t\tif (rc != MBX_SUCCESS) {\n\t\t\trc = (rc == MBX_TIMEOUT) ? -ETIME : -ENODEV;\n\t\t\tgoto job_done;\n\t\t}\n\n\t\t \n\t\tmemcpy(pmbx, pmb, sizeof(*pmb));\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t\t    pmbx, size);\n\t\t \n\t\trc = 0;\n\t\tgoto job_done;\n\t}\n\n\trc = lpfc_sli_issue_mbox(phba, pmboxq, MBX_NOWAIT);\n\tif ((rc == MBX_SUCCESS) || (rc == MBX_BUSY))\n\t\treturn 1;  \n\njob_done:\n\t \n\tif (pmboxq)\n\t\tmempool_free(pmboxq, phba->mbox_mem_pool);\n\tlpfc_bsg_dma_page_free(phba, dmabuf);\n\tkfree(dd_data);\n\njob_cont:\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_mbox_cmd(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct dfc_mbox_req *mbox_req;\n\tint rc = 0;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) + sizeof(struct dfc_mbox_req)) {\n\t\tlpfc_printf_log(phba, KERN_INFO, LOG_LIBDFC,\n\t\t\t\t\"2737 Mix-and-match backward compatibility \"\n\t\t\t\t\"between MBOX_REQ old size:%d and \"\n\t\t\t\t\"new request size:%d\\n\",\n\t\t\t\t(int)(job->request_len -\n\t\t\t\t      sizeof(struct fc_bsg_request)),\n\t\t\t\t(int)sizeof(struct dfc_mbox_req));\n\t\tmbox_req = (struct dfc_mbox_req *)\n\t\t\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\t\tmbox_req->extMboxTag = 0;\n\t\tmbox_req->extSeqNum = 0;\n\t}\n\n\trc = lpfc_bsg_issue_mbox(phba, job, vport);\n\n\tif (rc == 0) {\n\t\t \n\t\tbsg_reply->result = 0;\n\t\tjob->dd_data = NULL;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t} else if (rc == 1)\n\t\t \n\t\trc = 0;  \n\telse {\n\t\t \n\t\tbsg_reply->result = rc;\n\t\tjob->dd_data = NULL;\n\t}\n\n\treturn rc;\n}\n\nstatic int\nlpfc_forced_link_speed(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost = fc_bsg_to_shost(job);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct forced_link_speed_support_reply *forced_reply;\n\tint rc = 0;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) +\n\t    sizeof(struct get_forced_link_speed_support)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"0048 Received FORCED_LINK_SPEED request \"\n\t\t\t\t\"below minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tforced_reply = (struct forced_link_speed_support_reply *)\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp;\n\n\tif (job->reply_len < sizeof(*bsg_reply) + sizeof(*forced_reply)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"0049 Received FORCED_LINK_SPEED reply below \"\n\t\t\t\t\"minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tforced_reply->supported = (phba->hba_flag & HBA_FORCED_LINK_SPEED)\n\t\t\t\t   ? LPFC_FORCED_LINK_SPEED_SUPPORTED\n\t\t\t\t   : LPFC_FORCED_LINK_SPEED_NOT_SUPPORTED;\njob_error:\n\tbsg_reply->result = rc;\n\tif (rc == 0)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n}\n\n \nint\nlpfc_check_fwlog_support(struct lpfc_hba *phba)\n{\n\tstruct lpfc_ras_fwlog *ras_fwlog = NULL;\n\n\tras_fwlog = &phba->ras_fwlog;\n\n\tif (!ras_fwlog->ras_hwsupport)\n\t\treturn -EACCES;\n\telse if (!ras_fwlog->ras_enabled)\n\t\treturn -EPERM;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int\nlpfc_bsg_get_ras_config(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost = fc_bsg_to_shost(job);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_bsg_get_ras_config_reply *ras_reply;\n\tstruct lpfc_ras_fwlog *ras_fwlog = &phba->ras_fwlog;\n\tint rc = 0;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) +\n\t    sizeof(struct lpfc_bsg_ras_req)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"6192 FW_LOG request received \"\n\t\t\t\t\"below minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto ras_job_error;\n\t}\n\n\t \n\trc = lpfc_check_fwlog_support(phba);\n\tif (rc)\n\t\tgoto ras_job_error;\n\n\tras_reply = (struct lpfc_bsg_get_ras_config_reply *)\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tif (ras_fwlog->state == ACTIVE)\n\t\tras_reply->state = LPFC_RASLOG_STATE_RUNNING;\n\telse\n\t\tras_reply->state = LPFC_RASLOG_STATE_STOPPED;\n\tspin_unlock_irq(&phba->hbalock);\n\n\tras_reply->log_level = phba->ras_fwlog.fw_loglevel;\n\tras_reply->log_buff_sz = phba->cfg_ras_fwlog_buffsize;\n\nras_job_error:\n\t \n\tbsg_reply->result = rc;\n\n\t \n\tif (!rc)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_set_ras_config(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost = fc_bsg_to_shost(job);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_bsg_set_ras_config_req *ras_req;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct lpfc_ras_fwlog *ras_fwlog = &phba->ras_fwlog;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tuint8_t action = 0, log_level = 0;\n\tint rc = 0, action_status = 0;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) +\n\t    sizeof(struct lpfc_bsg_set_ras_config_req)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"6182 Received RAS_LOG request \"\n\t\t\t\t\"below minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto ras_job_error;\n\t}\n\n\t \n\trc = lpfc_check_fwlog_support(phba);\n\tif (rc)\n\t\tgoto ras_job_error;\n\n\tras_req = (struct lpfc_bsg_set_ras_config_req *)\n\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\taction = ras_req->action;\n\tlog_level = ras_req->log_level;\n\n\tif (action == LPFC_RASACTION_STOP_LOGGING) {\n\t\t \n\t\tspin_lock_irq(&phba->hbalock);\n\t\tif (ras_fwlog->state != ACTIVE) {\n\t\t\tspin_unlock_irq(&phba->hbalock);\n\t\t\trc = -ESRCH;\n\t\t\tgoto ras_job_error;\n\t\t}\n\t\tspin_unlock_irq(&phba->hbalock);\n\n\t\t \n\t\tlpfc_ras_stop_fwlog(phba);\n\t} else {\n\t\t \n\n\t\t \n\t\tspin_lock_irq(&phba->hbalock);\n\t\tif (ras_fwlog->state != INACTIVE)\n\t\t\taction_status = -EINPROGRESS;\n\t\tspin_unlock_irq(&phba->hbalock);\n\n\t\t \n\t\trc = lpfc_sli4_ras_fwlog_init(phba, log_level,\n\t\t\t\t\t      LPFC_RAS_ENABLE_LOGGING);\n\t\tif (rc) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto ras_job_error;\n\t\t}\n\n\t\t \n\t\tif (action_status == -EINPROGRESS)\n\t\t\trc = action_status;\n\t}\nras_job_error:\n\t \n\tbsg_reply->result = rc;\n\n\t \n\tif (!rc)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_get_ras_lwpd(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost = fc_bsg_to_shost(job);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct lpfc_bsg_get_ras_lwpd *ras_reply;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_ras_fwlog *ras_fwlog = &phba->ras_fwlog;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tu32 *lwpd_ptr = NULL;\n\tint rc = 0;\n\n\trc = lpfc_check_fwlog_support(phba);\n\tif (rc)\n\t\tgoto ras_job_error;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) +\n\t    sizeof(struct lpfc_bsg_ras_req)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"6183 Received RAS_LOG request \"\n\t\t\t\t\"below minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto ras_job_error;\n\t}\n\n\tras_reply = (struct lpfc_bsg_get_ras_lwpd *)\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp;\n\n\tif (!ras_fwlog->lwpd.virt) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"6193 Restart FW Logging\\n\");\n\t\trc = -EINVAL;\n\t\tgoto ras_job_error;\n\t}\n\n\t \n\tlwpd_ptr = (uint32_t *)(ras_fwlog->lwpd.virt);\n\tras_reply->offset = be32_to_cpu(*lwpd_ptr & 0xffffffff);\n\n\t \n\tras_reply->wrap_count = be32_to_cpu(*(++lwpd_ptr) & 0xffffffff);\n\nras_job_error:\n\t \n\tbsg_reply->result = rc;\n\n\t \n\tif (!rc)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_get_ras_fwlog(struct bsg_job *job)\n{\n\tstruct Scsi_Host *shost = fc_bsg_to_shost(job);\n\tstruct lpfc_vport *vport = shost_priv(shost);\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct lpfc_bsg_get_fwlog_req *ras_req;\n\tu32 rd_offset, rd_index, offset;\n\tvoid *src, *fwlog_buff;\n\tstruct lpfc_ras_fwlog *ras_fwlog = NULL;\n\tstruct lpfc_dmabuf *dmabuf, *next;\n\tint rc = 0;\n\n\tras_fwlog = &phba->ras_fwlog;\n\n\trc = lpfc_check_fwlog_support(phba);\n\tif (rc)\n\t\tgoto ras_job_error;\n\n\t \n\tspin_lock_irq(&phba->hbalock);\n\tif (ras_fwlog->state == ACTIVE) {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\trc = -EINPROGRESS;\n\t\tgoto ras_job_error;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) +\n\t    sizeof(struct lpfc_bsg_get_fwlog_req)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"6184 Received RAS_LOG request \"\n\t\t\t\t\"below minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto ras_job_error;\n\t}\n\n\tras_req = (struct lpfc_bsg_get_fwlog_req *)\n\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\trd_offset = ras_req->read_offset;\n\n\t \n\tfwlog_buff = vmalloc(ras_req->read_size);\n\tif (!fwlog_buff) {\n\t\trc = -ENOMEM;\n\t\tgoto ras_job_error;\n\t}\n\n\trd_index = (rd_offset / LPFC_RAS_MAX_ENTRY_SIZE);\n\toffset = (rd_offset % LPFC_RAS_MAX_ENTRY_SIZE);\n\n\tlist_for_each_entry_safe(dmabuf, next,\n\t\t\t      &ras_fwlog->fwlog_buff_list, list) {\n\n\t\tif (dmabuf->buffer_tag < rd_index)\n\t\t\tcontinue;\n\n\t\tsrc = dmabuf->virt + offset;\n\t\tmemcpy(fwlog_buff, src, ras_req->read_size);\n\t\tbreak;\n\t}\n\n\tbsg_reply->reply_payload_rcv_len =\n\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t    fwlog_buff, ras_req->read_size);\n\n\tvfree(fwlog_buff);\n\nras_job_error:\n\tbsg_reply->result = rc;\n\tif (!rc)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\n\treturn rc;\n}\n\nstatic int\nlpfc_get_trunk_info(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct lpfc_trunk_info *event_reply;\n\tint rc = 0;\n\n\tif (job->request_len <\n\t    sizeof(struct fc_bsg_request) + sizeof(struct get_trunk_info_req)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"2744 Received GET TRUNK _INFO request below \"\n\t\t\t\t\"minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tevent_reply = (struct lpfc_trunk_info *)\n\t\tbsg_reply->reply_data.vendor_reply.vendor_rsp;\n\n\tif (job->reply_len < sizeof(*bsg_reply) + sizeof(*event_reply)) {\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_LIBDFC,\n\t\t\t\t\"2728 Received GET TRUNK _INFO reply below \"\n\t\t\t\t\"minimum size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\tif (event_reply == NULL) {\n\t\trc = -EINVAL;\n\t\tgoto job_error;\n\t}\n\n\tbsg_bf_set(lpfc_trunk_info_link_status, event_reply,\n\t\t   (phba->link_state >= LPFC_LINK_UP) ? 1 : 0);\n\n\tbsg_bf_set(lpfc_trunk_info_trunk_active0, event_reply,\n\t\t   (phba->trunk_link.link0.state == LPFC_LINK_UP) ? 1 : 0);\n\n\tbsg_bf_set(lpfc_trunk_info_trunk_active1, event_reply,\n\t\t   (phba->trunk_link.link1.state == LPFC_LINK_UP) ? 1 : 0);\n\n\tbsg_bf_set(lpfc_trunk_info_trunk_active2, event_reply,\n\t\t   (phba->trunk_link.link2.state == LPFC_LINK_UP) ? 1 : 0);\n\n\tbsg_bf_set(lpfc_trunk_info_trunk_active3, event_reply,\n\t\t   (phba->trunk_link.link3.state == LPFC_LINK_UP) ? 1 : 0);\n\n\tbsg_bf_set(lpfc_trunk_info_trunk_config0, event_reply,\n\t\t   bf_get(lpfc_conf_trunk_port0, &phba->sli4_hba));\n\n\tbsg_bf_set(lpfc_trunk_info_trunk_config1, event_reply,\n\t\t   bf_get(lpfc_conf_trunk_port1, &phba->sli4_hba));\n\n\tbsg_bf_set(lpfc_trunk_info_trunk_config2, event_reply,\n\t\t   bf_get(lpfc_conf_trunk_port2, &phba->sli4_hba));\n\n\tbsg_bf_set(lpfc_trunk_info_trunk_config3, event_reply,\n\t\t   bf_get(lpfc_conf_trunk_port3, &phba->sli4_hba));\n\n\tevent_reply->port_speed = phba->sli4_hba.link_state.speed / 1000;\n\tevent_reply->logical_speed =\n\t\t\t\tphba->sli4_hba.link_state.logical_speed / 1000;\njob_error:\n\tbsg_reply->result = rc;\n\tif (!rc)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\treturn rc;\n\n}\n\nstatic int\nlpfc_get_cgnbuf_info(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct get_cgnbuf_info_req *cgnbuf_req;\n\tstruct lpfc_cgn_info *cp;\n\tuint8_t *cgn_buff;\n\tint size, cinfosz;\n\tint  rc = 0;\n\n\tif (job->request_len < sizeof(struct fc_bsg_request) +\n\t    sizeof(struct get_cgnbuf_info_req)) {\n\t\trc = -ENOMEM;\n\t\tgoto job_exit;\n\t}\n\n\tif (!phba->sli4_hba.pc_sli4_params.cmf) {\n\t\trc = -ENOENT;\n\t\tgoto job_exit;\n\t}\n\n\tif (!phba->cgn_i || !phba->cgn_i->virt) {\n\t\trc = -ENOENT;\n\t\tgoto job_exit;\n\t}\n\n\tcp = phba->cgn_i->virt;\n\tif (cp->cgn_info_version < LPFC_CGN_INFO_V3) {\n\t\trc = -EPERM;\n\t\tgoto job_exit;\n\t}\n\n\tcgnbuf_req = (struct get_cgnbuf_info_req *)\n\t\tbsg_request->rqst_data.h_vendor.vendor_cmd;\n\n\t \n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (cgnbuf_req->reset == LPFC_BSG_CGN_RESET_STAT) {\n\t\tlpfc_init_congestion_stat(phba);\n\t\tgoto job_exit;\n\t}\n\n\t \n\tcinfosz = sizeof(struct lpfc_cgn_info) - sizeof(uint32_t);\n\n\tsize = cgnbuf_req->read_size;\n\tif (!size)\n\t\tgoto job_exit;\n\n\tif (size < cinfosz) {\n\t\t \n\t\tcinfosz = size;\n\t\trc = -E2BIG;\n\t}\n\n\t \n\tcgn_buff = vmalloc(cinfosz);\n\tif (!cgn_buff) {\n\t\trc = -ENOMEM;\n\t\tgoto job_exit;\n\t}\n\n\tmemcpy(cgn_buff, cp, cinfosz);\n\n\tbsg_reply->reply_payload_rcv_len =\n\t\tsg_copy_from_buffer(job->reply_payload.sg_list,\n\t\t\t\t    job->reply_payload.sg_cnt,\n\t\t\t\t    cgn_buff, cinfosz);\n\n\tvfree(cgn_buff);\n\njob_exit:\n\tbsg_reply->result = rc;\n\tif (!rc)\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\telse\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_LIBDFC,\n\t\t\t\t\"2724 GET CGNBUF error: %d\\n\", rc);\n\treturn rc;\n}\n\n \nstatic int\nlpfc_bsg_hst_vendor(struct bsg_job *job)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tint command = bsg_request->rqst_data.h_vendor.vendor_cmd[0];\n\tint rc;\n\n\tswitch (command) {\n\tcase LPFC_BSG_VENDOR_SET_CT_EVENT:\n\t\trc = lpfc_bsg_hba_set_event(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_GET_CT_EVENT:\n\t\trc = lpfc_bsg_hba_get_event(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_SEND_MGMT_RESP:\n\t\trc = lpfc_bsg_send_mgmt_rsp(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_DIAG_MODE:\n\t\trc = lpfc_bsg_diag_loopback_mode(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_DIAG_MODE_END:\n\t\trc = lpfc_sli4_bsg_diag_mode_end(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_DIAG_RUN_LOOPBACK:\n\t\trc = lpfc_bsg_diag_loopback_run(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_LINK_DIAG_TEST:\n\t\trc = lpfc_sli4_bsg_link_diag_test(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_GET_MGMT_REV:\n\t\trc = lpfc_bsg_get_dfc_rev(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_MBOX:\n\t\trc = lpfc_bsg_mbox_cmd(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_FORCED_LINK_SPEED:\n\t\trc = lpfc_forced_link_speed(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_RAS_GET_LWPD:\n\t\trc = lpfc_bsg_get_ras_lwpd(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_RAS_GET_FWLOG:\n\t\trc = lpfc_bsg_get_ras_fwlog(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_RAS_GET_CONFIG:\n\t\trc = lpfc_bsg_get_ras_config(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_RAS_SET_CONFIG:\n\t\trc = lpfc_bsg_set_ras_config(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_GET_TRUNK_INFO:\n\t\trc = lpfc_get_trunk_info(job);\n\t\tbreak;\n\tcase LPFC_BSG_VENDOR_GET_CGNBUF_INFO:\n\t\trc = lpfc_get_cgnbuf_info(job);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t\t \n\t\tbsg_reply->result = rc;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nint\nlpfc_bsg_request(struct bsg_job *job)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tuint32_t msgcode;\n\tint rc;\n\n\tmsgcode = bsg_request->msgcode;\n\tswitch (msgcode) {\n\tcase FC_BSG_HST_VENDOR:\n\t\trc = lpfc_bsg_hst_vendor(job);\n\t\tbreak;\n\tcase FC_BSG_RPT_ELS:\n\t\trc = lpfc_bsg_rport_els(job);\n\t\tbreak;\n\tcase FC_BSG_RPT_CT:\n\t\trc = lpfc_bsg_send_mgmt_cmd(job);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t\t \n\t\tbsg_reply->result = rc;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nint\nlpfc_bsg_timeout(struct bsg_job *job)\n{\n\tstruct lpfc_vport *vport = shost_priv(fc_bsg_to_shost(job));\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_iocbq *cmdiocb;\n\tstruct lpfc_sli_ring *pring;\n\tstruct bsg_job_data *dd_data;\n\tunsigned long flags;\n\tint rc = 0;\n\tLIST_HEAD(completions);\n\tstruct lpfc_iocbq *check_iocb, *next_iocb;\n\n\tpring = lpfc_phba_elsring(phba);\n\tif (unlikely(!pring))\n\t\treturn -EIO;\n\n\t \n\n\tspin_lock_irqsave(&phba->ct_ev_lock, flags);\n\tdd_data = (struct bsg_job_data *)job->dd_data;\n\tif (dd_data) {\n\t\tdd_data->set_job = NULL;\n\t\tjob->dd_data = NULL;\n\t} else {\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tswitch (dd_data->type) {\n\tcase TYPE_IOCB:\n\t\t \n\t\tcmdiocb = dd_data->context_un.iocb.cmdiocbq;\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\n\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\t \n\t\tif (!(cmdiocb->cmd_flag & LPFC_IO_CMD_OUTSTANDING)) {\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tlist_for_each_entry_safe(check_iocb, next_iocb, &pring->txq,\n\t\t\t\t\t list) {\n\t\t\tif (check_iocb == cmdiocb) {\n\t\t\t\tlist_move_tail(&check_iocb->list, &completions);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (list_empty(&completions))\n\t\t\tlpfc_sli_issue_abort_iotag(phba, pring, cmdiocb, NULL);\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\tif (!list_empty(&completions)) {\n\t\t\tlpfc_sli_cancel_iocbs(phba, &completions,\n\t\t\t\t\t      IOSTAT_LOCAL_REJECT,\n\t\t\t\t\t      IOERR_SLI_ABORTED);\n\t\t}\n\t\tbreak;\n\n\tcase TYPE_EVT:\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\tbreak;\n\n\tcase TYPE_MBOX:\n\t\t \n\n\t\tif (phba->mbox_ext_buf_ctx.state == LPFC_BSG_MBOX_PORT)\n\t\t\tphba->mbox_ext_buf_ctx.state = LPFC_BSG_MBOX_ABTS;\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock_irqrestore(&phba->ct_ev_lock, flags);\n\t\tbreak;\n\t}\n\n\t \n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}