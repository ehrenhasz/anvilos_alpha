{
  "module_name": "lpfc_debugfs.c",
  "hash_id": "7e61b5776fa9988f4551e78ec6091040fa159fdae9b24b71fc8f5f72d72fd9bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_debugfs.c",
  "human_readable_source": " \n\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/ctype.h>\n#include <linux/vmalloc.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport_fc.h>\n#include <scsi/fc/fc_fs.h>\n\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_nvme.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n#include \"lpfc_version.h\"\n#include \"lpfc_compat.h\"\n#include \"lpfc_debugfs.h\"\n#include \"lpfc_bsg.h\"\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n \nstatic int lpfc_debugfs_enable = 1;\nmodule_param(lpfc_debugfs_enable, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_debugfs_enable, \"Enable debugfs services\");\n\n \nstatic int lpfc_debugfs_max_disc_trc;\nmodule_param(lpfc_debugfs_max_disc_trc, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_debugfs_max_disc_trc,\n\t\"Set debugfs discovery trace depth\");\n\n \nstatic int lpfc_debugfs_max_slow_ring_trc;\nmodule_param(lpfc_debugfs_max_slow_ring_trc, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_debugfs_max_slow_ring_trc,\n\t\"Set debugfs slow ring trace depth\");\n\n \nstatic int lpfc_debugfs_max_nvmeio_trc;\nmodule_param(lpfc_debugfs_max_nvmeio_trc, int, 0444);\nMODULE_PARM_DESC(lpfc_debugfs_max_nvmeio_trc,\n\t\t \"Set debugfs NVME IO trace depth\");\n\nstatic int lpfc_debugfs_mask_disc_trc;\nmodule_param(lpfc_debugfs_mask_disc_trc, int, S_IRUGO);\nMODULE_PARM_DESC(lpfc_debugfs_mask_disc_trc,\n\t\"Set debugfs discovery trace mask\");\n\n#include <linux/debugfs.h>\n\nstatic atomic_t lpfc_debugfs_seq_trc_cnt = ATOMIC_INIT(0);\nstatic unsigned long lpfc_debugfs_start_time = 0L;\n\n \nstatic struct lpfc_idiag idiag;\n\n \nstatic int\nlpfc_debugfs_disc_trc_data(struct lpfc_vport *vport, char *buf, int size)\n{\n\tint i, index, len, enable;\n\tuint32_t ms;\n\tstruct lpfc_debugfs_trc *dtp;\n\tchar *buffer;\n\n\tbuffer = kmalloc(LPFC_DEBUG_TRC_ENTRY_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\tenable = lpfc_debugfs_enable;\n\tlpfc_debugfs_enable = 0;\n\n\tlen = 0;\n\tindex = (atomic_read(&vport->disc_trc_cnt) + 1) &\n\t\t(lpfc_debugfs_max_disc_trc - 1);\n\tfor (i = index; i < lpfc_debugfs_max_disc_trc; i++) {\n\t\tdtp = vport->disc_trc + i;\n\t\tif (!dtp->fmt)\n\t\t\tcontinue;\n\t\tms = jiffies_to_msecs(dtp->jif - lpfc_debugfs_start_time);\n\t\tsnprintf(buffer,\n\t\t\tLPFC_DEBUG_TRC_ENTRY_SIZE, \"%010d:%010d ms:%s\\n\",\n\t\t\tdtp->seq_cnt, ms, dtp->fmt);\n\t\tlen +=  scnprintf(buf+len, size-len, buffer,\n\t\t\tdtp->data1, dtp->data2, dtp->data3);\n\t}\n\tfor (i = 0; i < index; i++) {\n\t\tdtp = vport->disc_trc + i;\n\t\tif (!dtp->fmt)\n\t\t\tcontinue;\n\t\tms = jiffies_to_msecs(dtp->jif - lpfc_debugfs_start_time);\n\t\tsnprintf(buffer,\n\t\t\tLPFC_DEBUG_TRC_ENTRY_SIZE, \"%010d:%010d ms:%s\\n\",\n\t\t\tdtp->seq_cnt, ms, dtp->fmt);\n\t\tlen +=  scnprintf(buf+len, size-len, buffer,\n\t\t\tdtp->data1, dtp->data2, dtp->data3);\n\t}\n\n\tlpfc_debugfs_enable = enable;\n\tkfree(buffer);\n\n\treturn len;\n}\n\n \nstatic int\nlpfc_debugfs_slow_ring_trc_data(struct lpfc_hba *phba, char *buf, int size)\n{\n\tint i, index, len, enable;\n\tuint32_t ms;\n\tstruct lpfc_debugfs_trc *dtp;\n\tchar *buffer;\n\n\tbuffer = kmalloc(LPFC_DEBUG_TRC_ENTRY_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\tenable = lpfc_debugfs_enable;\n\tlpfc_debugfs_enable = 0;\n\n\tlen = 0;\n\tindex = (atomic_read(&phba->slow_ring_trc_cnt) + 1) &\n\t\t(lpfc_debugfs_max_slow_ring_trc - 1);\n\tfor (i = index; i < lpfc_debugfs_max_slow_ring_trc; i++) {\n\t\tdtp = phba->slow_ring_trc + i;\n\t\tif (!dtp->fmt)\n\t\t\tcontinue;\n\t\tms = jiffies_to_msecs(dtp->jif - lpfc_debugfs_start_time);\n\t\tsnprintf(buffer,\n\t\t\tLPFC_DEBUG_TRC_ENTRY_SIZE, \"%010d:%010d ms:%s\\n\",\n\t\t\tdtp->seq_cnt, ms, dtp->fmt);\n\t\tlen +=  scnprintf(buf+len, size-len, buffer,\n\t\t\tdtp->data1, dtp->data2, dtp->data3);\n\t}\n\tfor (i = 0; i < index; i++) {\n\t\tdtp = phba->slow_ring_trc + i;\n\t\tif (!dtp->fmt)\n\t\t\tcontinue;\n\t\tms = jiffies_to_msecs(dtp->jif - lpfc_debugfs_start_time);\n\t\tsnprintf(buffer,\n\t\t\tLPFC_DEBUG_TRC_ENTRY_SIZE, \"%010d:%010d ms:%s\\n\",\n\t\t\tdtp->seq_cnt, ms, dtp->fmt);\n\t\tlen +=  scnprintf(buf+len, size-len, buffer,\n\t\t\tdtp->data1, dtp->data2, dtp->data3);\n\t}\n\n\tlpfc_debugfs_enable = enable;\n\tkfree(buffer);\n\n\treturn len;\n}\n\nstatic int lpfc_debugfs_last_hbq = -1;\n\n \nstatic int\nlpfc_debugfs_hbqinfo_data(struct lpfc_hba *phba, char *buf, int size)\n{\n\tint len = 0;\n\tint i, j, found, posted, low;\n\tuint32_t phys, raw_index, getidx;\n\tstruct lpfc_hbq_init *hip;\n\tstruct hbq_s *hbqs;\n\tstruct lpfc_hbq_entry *hbqe;\n\tstruct lpfc_dmabuf *d_buf;\n\tstruct hbq_dmabuf *hbq_buf;\n\n\tif (phba->sli_rev != 3)\n\t\treturn 0;\n\n\tspin_lock_irq(&phba->hbalock);\n\n\t \n\ti = lpfc_sli_hbq_count();\n\tif (i > 1) {\n\t\t lpfc_debugfs_last_hbq++;\n\t\t if (lpfc_debugfs_last_hbq >= i)\n\t\t\tlpfc_debugfs_last_hbq = 0;\n\t}\n\telse\n\t\tlpfc_debugfs_last_hbq = 0;\n\n\ti = lpfc_debugfs_last_hbq;\n\n\tlen +=  scnprintf(buf+len, size-len, \"HBQ %d Info\\n\", i);\n\n\thbqs =  &phba->hbqs[i];\n\tposted = 0;\n\tlist_for_each_entry(d_buf, &hbqs->hbq_buffer_list, list)\n\t\tposted++;\n\n\thip =  lpfc_hbq_defs[i];\n\tlen +=  scnprintf(buf+len, size-len,\n\t\t\"idx:%d prof:%d rn:%d bufcnt:%d icnt:%d acnt:%d posted %d\\n\",\n\t\thip->hbq_index, hip->profile, hip->rn,\n\t\thip->buffer_count, hip->init_count, hip->add_count, posted);\n\n\traw_index = phba->hbq_get[i];\n\tgetidx = le32_to_cpu(raw_index);\n\tlen +=  scnprintf(buf+len, size-len,\n\t\t\"entries:%d bufcnt:%d Put:%d nPut:%d localGet:%d hbaGet:%d\\n\",\n\t\thbqs->entry_count, hbqs->buffer_count, hbqs->hbqPutIdx,\n\t\thbqs->next_hbqPutIdx, hbqs->local_hbqGetIdx, getidx);\n\n\thbqe = (struct lpfc_hbq_entry *) phba->hbqs[i].hbq_virt;\n\tfor (j=0; j<hbqs->entry_count; j++) {\n\t\tlen +=  scnprintf(buf+len, size-len,\n\t\t\t\"%03d: %08x %04x %05x \", j,\n\t\t\tle32_to_cpu(hbqe->bde.addrLow),\n\t\t\tle32_to_cpu(hbqe->bde.tus.w),\n\t\t\tle32_to_cpu(hbqe->buffer_tag));\n\t\ti = 0;\n\t\tfound = 0;\n\n\t\t \n\t\tlow = hbqs->hbqPutIdx - posted;\n\t\tif (low >= 0) {\n\t\t\tif ((j >= hbqs->hbqPutIdx) || (j < low)) {\n\t\t\t\tlen +=  scnprintf(buf + len, size - len,\n\t\t\t\t\t\t\"Unused\\n\");\n\t\t\t\tgoto skipit;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ((j >= hbqs->hbqPutIdx) &&\n\t\t\t\t(j < (hbqs->entry_count+low))) {\n\t\t\t\tlen +=  scnprintf(buf + len, size - len,\n\t\t\t\t\t\t\"Unused\\n\");\n\t\t\t\tgoto skipit;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry(d_buf, &hbqs->hbq_buffer_list, list) {\n\t\t\thbq_buf = container_of(d_buf, struct hbq_dmabuf, dbuf);\n\t\t\tphys = ((uint64_t)hbq_buf->dbuf.phys & 0xffffffff);\n\t\t\tif (phys == le32_to_cpu(hbqe->bde.addrLow)) {\n\t\t\t\tlen +=  scnprintf(buf+len, size-len,\n\t\t\t\t\t\"Buf%d: x%px %06x\\n\", i,\n\t\t\t\t\thbq_buf->dbuf.virt, hbq_buf->tag);\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (!found) {\n\t\t\tlen +=  scnprintf(buf+len, size-len, \"No DMAinfo?\\n\");\n\t\t}\nskipit:\n\t\thbqe++;\n\t\tif (len > LPFC_HBQINFO_SIZE - 54)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\treturn len;\n}\n\nstatic int lpfc_debugfs_last_xripool;\n\n \nstatic int\nlpfc_debugfs_commonxripools_data(struct lpfc_hba *phba, char *buf, int size)\n{\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tint len = 0;\n\tint i, out;\n\tunsigned long iflag;\n\n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\tif (len > (LPFC_DUMP_MULTIXRIPOOL_SIZE - 80))\n\t\t\tbreak;\n\t\tqp = &phba->sli4_hba.hdwq[lpfc_debugfs_last_xripool];\n\n\t\tlen += scnprintf(buf + len, size - len, \"HdwQ %d Info \", i);\n\t\tspin_lock_irqsave(&qp->abts_io_buf_list_lock, iflag);\n\t\tspin_lock(&qp->io_buf_list_get_lock);\n\t\tspin_lock(&qp->io_buf_list_put_lock);\n\t\tout = qp->total_io_bufs - (qp->get_io_bufs + qp->put_io_bufs +\n\t\t\tqp->abts_scsi_io_bufs + qp->abts_nvme_io_bufs);\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t \"tot:%d get:%d put:%d mt:%d \"\n\t\t\t\t \"ABTS scsi:%d nvme:%d Out:%d\\n\",\n\t\t\tqp->total_io_bufs, qp->get_io_bufs, qp->put_io_bufs,\n\t\t\tqp->empty_io_bufs, qp->abts_scsi_io_bufs,\n\t\t\tqp->abts_nvme_io_bufs, out);\n\t\tspin_unlock(&qp->io_buf_list_put_lock);\n\t\tspin_unlock(&qp->io_buf_list_get_lock);\n\t\tspin_unlock_irqrestore(&qp->abts_io_buf_list_lock, iflag);\n\n\t\tlpfc_debugfs_last_xripool++;\n\t\tif (lpfc_debugfs_last_xripool >= phba->cfg_hdw_queue)\n\t\t\tlpfc_debugfs_last_xripool = 0;\n\t}\n\n\treturn len;\n}\n\n \nstatic int\nlpfc_debugfs_multixripools_data(struct lpfc_hba *phba, char *buf, int size)\n{\n\tu32 i;\n\tu32 hwq_count;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tstruct lpfc_multixri_pool *multixri_pool;\n\tstruct lpfc_pvt_pool *pvt_pool;\n\tstruct lpfc_pbl_pool *pbl_pool;\n\tu32 txcmplq_cnt;\n\tchar tmp[LPFC_DEBUG_OUT_LINE_SZ] = {0};\n\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn 0;\n\n\tif (!phba->sli4_hba.hdwq)\n\t\treturn 0;\n\n\tif (!phba->cfg_xri_rebalancing) {\n\t\ti = lpfc_debugfs_commonxripools_data(phba, buf, size);\n\t\treturn i;\n\t}\n\n\t \n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"HWQ:  Pbl  Pvt Busy  HWM |  pvt_empty  pbl_empty \");\n\tif (strlcat(buf, tmp, size) >= size)\n\t\treturn strnlen(buf, size);\n\n#ifdef LPFC_MXP_STAT\n\t \n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \"MAXH  above_lmt  below_lmt locPbl_hit othPbl_hit\");\n\tif (strlcat(buf, tmp, size) >= size)\n\t\treturn strnlen(buf, size);\n\n\t \n\tscnprintf(tmp, sizeof(tmp),\n\t\t  \" | sPbl sPvt sBusy\");\n\tif (strlcat(buf, tmp, size) >= size)\n\t\treturn strnlen(buf, size);\n#endif\n\n\tscnprintf(tmp, sizeof(tmp), \"\\n\");\n\tif (strlcat(buf, tmp, size) >= size)\n\t\treturn strnlen(buf, size);\n\n\thwq_count = phba->cfg_hdw_queue;\n\tfor (i = 0; i < hwq_count; i++) {\n\t\tqp = &phba->sli4_hba.hdwq[i];\n\t\tmultixri_pool = qp->p_multixri_pool;\n\t\tif (!multixri_pool)\n\t\t\tcontinue;\n\t\tpbl_pool = &multixri_pool->pbl_pool;\n\t\tpvt_pool = &multixri_pool->pvt_pool;\n\t\ttxcmplq_cnt = qp->io_wq->pring->txcmplq_cnt;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"%03d: %4d %4d %4d %4d | %10d %10d \",\n\t\t\t  i, pbl_pool->count, pvt_pool->count,\n\t\t\t  txcmplq_cnt, pvt_pool->high_watermark,\n\t\t\t  qp->empty_io_bufs, multixri_pool->pbl_empty_count);\n\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\tbreak;\n\n#ifdef LPFC_MXP_STAT\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \"%4d %10d %10d %10d %10d\",\n\t\t\t  multixri_pool->stat_max_hwm,\n\t\t\t  multixri_pool->above_limit_count,\n\t\t\t  multixri_pool->below_limit_count,\n\t\t\t  multixri_pool->local_pbl_hit_count,\n\t\t\t  multixri_pool->other_pbl_hit_count);\n\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\tbreak;\n\n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \" | %4d %4d %5d\",\n\t\t\t  multixri_pool->stat_pbl_count,\n\t\t\t  multixri_pool->stat_pvt_count,\n\t\t\t  multixri_pool->stat_busy_count);\n\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\tbreak;\n#endif\n\n\t\tscnprintf(tmp, sizeof(tmp), \"\\n\");\n\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\tbreak;\n\t}\n\treturn strnlen(buf, size);\n}\n\n\n#ifdef LPFC_HDWQ_LOCK_STAT\nstatic int lpfc_debugfs_last_lock;\n\n \nstatic int\nlpfc_debugfs_lockstat_data(struct lpfc_hba *phba, char *buf, int size)\n{\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tint len = 0;\n\tint i;\n\n\tif (phba->sli_rev != LPFC_SLI_REV4)\n\t\treturn 0;\n\n\tif (!phba->sli4_hba.hdwq)\n\t\treturn 0;\n\n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\tif (len > (LPFC_HDWQINFO_SIZE - 100))\n\t\t\tbreak;\n\t\tqp = &phba->sli4_hba.hdwq[lpfc_debugfs_last_lock];\n\n\t\tlen += scnprintf(buf + len, size - len, \"HdwQ %03d Lock \", i);\n\t\tif (phba->cfg_xri_rebalancing) {\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \"get_pvt:%d mv_pvt:%d \"\n\t\t\t\t\t \"mv2pub:%d mv2pvt:%d \"\n\t\t\t\t\t \"put_pvt:%d put_pub:%d wq:%d\\n\",\n\t\t\t\t\t qp->lock_conflict.alloc_pvt_pool,\n\t\t\t\t\t qp->lock_conflict.mv_from_pvt_pool,\n\t\t\t\t\t qp->lock_conflict.mv_to_pub_pool,\n\t\t\t\t\t qp->lock_conflict.mv_to_pvt_pool,\n\t\t\t\t\t qp->lock_conflict.free_pvt_pool,\n\t\t\t\t\t qp->lock_conflict.free_pub_pool,\n\t\t\t\t\t qp->lock_conflict.wq_access);\n\t\t} else {\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \"get:%d put:%d free:%d wq:%d\\n\",\n\t\t\t\t\t qp->lock_conflict.alloc_xri_get,\n\t\t\t\t\t qp->lock_conflict.alloc_xri_put,\n\t\t\t\t\t qp->lock_conflict.free_xri,\n\t\t\t\t\t qp->lock_conflict.wq_access);\n\t\t}\n\n\t\tlpfc_debugfs_last_lock++;\n\t\tif (lpfc_debugfs_last_lock >= phba->cfg_hdw_queue)\n\t\t\tlpfc_debugfs_last_lock = 0;\n\t}\n\n\treturn len;\n}\n#endif\n\nstatic int lpfc_debugfs_last_hba_slim_off;\n\n \nstatic int\nlpfc_debugfs_dumpHBASlim_data(struct lpfc_hba *phba, char *buf, int size)\n{\n\tint len = 0;\n\tint i, off;\n\tuint32_t *ptr;\n\tchar *buffer;\n\n\tbuffer = kmalloc(1024, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\toff = 0;\n\tspin_lock_irq(&phba->hbalock);\n\n\tlen +=  scnprintf(buf+len, size-len, \"HBA SLIM\\n\");\n\tlpfc_memcpy_from_slim(buffer,\n\t\tphba->MBslimaddr + lpfc_debugfs_last_hba_slim_off, 1024);\n\n\tptr = (uint32_t *)&buffer[0];\n\toff = lpfc_debugfs_last_hba_slim_off;\n\n\t \n\tlpfc_debugfs_last_hba_slim_off += 1024;\n\tif (lpfc_debugfs_last_hba_slim_off >= 4096)\n\t\tlpfc_debugfs_last_hba_slim_off = 0;\n\n\ti = 1024;\n\twhile (i > 0) {\n\t\tlen +=  scnprintf(buf+len, size-len,\n\t\t\"%08x: %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\toff, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4),\n\t\t*(ptr+5), *(ptr+6), *(ptr+7));\n\t\tptr += 8;\n\t\ti -= (8 * sizeof(uint32_t));\n\t\toff += (8 * sizeof(uint32_t));\n\t}\n\n\tspin_unlock_irq(&phba->hbalock);\n\tkfree(buffer);\n\n\treturn len;\n}\n\n \nstatic int\nlpfc_debugfs_dumpHostSlim_data(struct lpfc_hba *phba, char *buf, int size)\n{\n\tint len = 0;\n\tint i, off;\n\tuint32_t word0, word1, word2, word3;\n\tuint32_t *ptr;\n\tstruct lpfc_pgp *pgpp;\n\tstruct lpfc_sli *psli = &phba->sli;\n\tstruct lpfc_sli_ring *pring;\n\n\toff = 0;\n\tspin_lock_irq(&phba->hbalock);\n\n\tlen +=  scnprintf(buf+len, size-len, \"SLIM Mailbox\\n\");\n\tptr = (uint32_t *)phba->slim2p.virt;\n\ti = sizeof(MAILBOX_t);\n\twhile (i > 0) {\n\t\tlen +=  scnprintf(buf+len, size-len,\n\t\t\"%08x: %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\toff, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4),\n\t\t*(ptr+5), *(ptr+6), *(ptr+7));\n\t\tptr += 8;\n\t\ti -= (8 * sizeof(uint32_t));\n\t\toff += (8 * sizeof(uint32_t));\n\t}\n\n\tlen +=  scnprintf(buf+len, size-len, \"SLIM PCB\\n\");\n\tptr = (uint32_t *)phba->pcb;\n\ti = sizeof(PCB_t);\n\twhile (i > 0) {\n\t\tlen +=  scnprintf(buf+len, size-len,\n\t\t\"%08x: %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\toff, *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4),\n\t\t*(ptr+5), *(ptr+6), *(ptr+7));\n\t\tptr += 8;\n\t\ti -= (8 * sizeof(uint32_t));\n\t\toff += (8 * sizeof(uint32_t));\n\t}\n\n\tif (phba->sli_rev <= LPFC_SLI_REV3) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tpgpp = &phba->port_gp[i];\n\t\t\tpring = &psli->sli3_ring[i];\n\t\t\tlen +=  scnprintf(buf+len, size-len,\n\t\t\t\t\t \"Ring %d: CMD GetInx:%d \"\n\t\t\t\t\t \"(Max:%d Next:%d \"\n\t\t\t\t\t \"Local:%d flg:x%x)  \"\n\t\t\t\t\t \"RSP PutInx:%d Max:%d\\n\",\n\t\t\t\t\t i, pgpp->cmdGetInx,\n\t\t\t\t\t pring->sli.sli3.numCiocb,\n\t\t\t\t\t pring->sli.sli3.next_cmdidx,\n\t\t\t\t\t pring->sli.sli3.local_getidx,\n\t\t\t\t\t pring->flag, pgpp->rspPutInx,\n\t\t\t\t\t pring->sli.sli3.numRiocb);\n\t\t}\n\n\t\tword0 = readl(phba->HAregaddr);\n\t\tword1 = readl(phba->CAregaddr);\n\t\tword2 = readl(phba->HSregaddr);\n\t\tword3 = readl(phba->HCregaddr);\n\t\tlen +=  scnprintf(buf+len, size-len, \"HA:%08x CA:%08x HS:%08x \"\n\t\t\t\t \"HC:%08x\\n\", word0, word1, word2, word3);\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\treturn len;\n}\n\n \nstatic int\nlpfc_debugfs_nodelist_data(struct lpfc_vport *vport, char *buf, int size)\n{\n\tint len = 0;\n\tint i, iocnt, outio, cnt;\n\tstruct Scsi_Host *shost = lpfc_shost_from_vport(vport);\n\tstruct lpfc_hba  *phba = vport->phba;\n\tstruct lpfc_nodelist *ndlp;\n\tunsigned char *statep;\n\tstruct nvme_fc_local_port *localport;\n\tstruct nvme_fc_remote_port *nrport = NULL;\n\tstruct lpfc_nvme_rport *rport;\n\n\tcnt = (LPFC_NODELIST_SIZE / LPFC_NODELIST_ENTRY_SIZE);\n\toutio = 0;\n\n\tlen += scnprintf(buf+len, size-len, \"\\nFCP Nodelist Entries ...\\n\");\n\tspin_lock_irq(shost->host_lock);\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\tiocnt = 0;\n\t\tif (!cnt) {\n\t\t\tlen +=  scnprintf(buf+len, size-len,\n\t\t\t\t\"Missing Nodelist Entries\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcnt--;\n\t\tswitch (ndlp->nlp_state) {\n\t\tcase NLP_STE_UNUSED_NODE:\n\t\t\tstatep = \"UNUSED\";\n\t\t\tbreak;\n\t\tcase NLP_STE_PLOGI_ISSUE:\n\t\t\tstatep = \"PLOGI \";\n\t\t\tbreak;\n\t\tcase NLP_STE_ADISC_ISSUE:\n\t\t\tstatep = \"ADISC \";\n\t\t\tbreak;\n\t\tcase NLP_STE_REG_LOGIN_ISSUE:\n\t\t\tstatep = \"REGLOG\";\n\t\t\tbreak;\n\t\tcase NLP_STE_PRLI_ISSUE:\n\t\t\tstatep = \"PRLI  \";\n\t\t\tbreak;\n\t\tcase NLP_STE_LOGO_ISSUE:\n\t\t\tstatep = \"LOGO  \";\n\t\t\tbreak;\n\t\tcase NLP_STE_UNMAPPED_NODE:\n\t\t\tstatep = \"UNMAP \";\n\t\t\tiocnt = 1;\n\t\t\tbreak;\n\t\tcase NLP_STE_MAPPED_NODE:\n\t\t\tstatep = \"MAPPED\";\n\t\t\tiocnt = 1;\n\t\t\tbreak;\n\t\tcase NLP_STE_NPR_NODE:\n\t\t\tstatep = \"NPR   \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatep = \"UNKNOWN\";\n\t\t}\n\t\tlen += scnprintf(buf+len, size-len, \"%s DID:x%06x \",\n\t\t\t\tstatep, ndlp->nlp_DID);\n\t\tlen += scnprintf(buf+len, size-len,\n\t\t\t\t\"WWPN x%016llx \",\n\t\t\t\twwn_to_u64(ndlp->nlp_portname.u.wwn));\n\t\tlen += scnprintf(buf+len, size-len,\n\t\t\t\t\"WWNN x%016llx \",\n\t\t\t\twwn_to_u64(ndlp->nlp_nodename.u.wwn));\n\t\tlen += scnprintf(buf+len, size-len, \"RPI:x%04x \",\n\t\t\t\t ndlp->nlp_rpi);\n\t\tlen +=  scnprintf(buf+len, size-len, \"flag:x%08x \",\n\t\t\tndlp->nlp_flag);\n\t\tif (!ndlp->nlp_type)\n\t\t\tlen += scnprintf(buf+len, size-len, \"UNKNOWN_TYPE \");\n\t\tif (ndlp->nlp_type & NLP_FC_NODE)\n\t\t\tlen += scnprintf(buf+len, size-len, \"FC_NODE \");\n\t\tif (ndlp->nlp_type & NLP_FABRIC) {\n\t\t\tlen += scnprintf(buf+len, size-len, \"FABRIC \");\n\t\t\tiocnt = 0;\n\t\t}\n\t\tif (ndlp->nlp_type & NLP_FCP_TARGET)\n\t\t\tlen += scnprintf(buf+len, size-len, \"FCP_TGT sid:%d \",\n\t\t\t\tndlp->nlp_sid);\n\t\tif (ndlp->nlp_type & NLP_FCP_INITIATOR)\n\t\t\tlen += scnprintf(buf+len, size-len, \"FCP_INITIATOR \");\n\t\tif (ndlp->nlp_type & NLP_NVME_TARGET)\n\t\t\tlen += scnprintf(buf + len,\n\t\t\t\t\tsize - len, \"NVME_TGT sid:%d \",\n\t\t\t\t\tNLP_NO_SID);\n\t\tif (ndlp->nlp_type & NLP_NVME_INITIATOR)\n\t\t\tlen += scnprintf(buf + len,\n\t\t\t\t\tsize - len, \"NVME_INITIATOR \");\n\t\tlen += scnprintf(buf+len, size-len, \"refcnt:%d\",\n\t\t\tkref_read(&ndlp->kref));\n\t\tif (iocnt) {\n\t\t\ti = atomic_read(&ndlp->cmd_pending);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\" OutIO:x%x Qdepth x%x\",\n\t\t\t\t\ti, ndlp->cmd_qdepth);\n\t\t\toutio += i;\n\t\t}\n\t\tlen += scnprintf(buf+len, size-len, \" xpt:x%x\",\n\t\t\t\t ndlp->fc4_xpt_flags);\n\t\tif (ndlp->nlp_defer_did != NLP_EVT_NOTHING_PENDING)\n\t\t\tlen += scnprintf(buf+len, size-len, \" defer:%x\",\n\t\t\t\t\t ndlp->nlp_defer_did);\n\t\tlen +=  scnprintf(buf+len, size-len, \"\\n\");\n\t}\n\tspin_unlock_irq(shost->host_lock);\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\"\\nOutstanding IO x%x\\n\",  outio);\n\n\tif (phba->nvmet_support && phba->targetport && (vport == phba->pport)) {\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"\\nNVME Targetport Entry ...\\n\");\n\n\t\t \n\t\tif (phba->targetport->port_id)\n\t\t\tstatep = \"REGISTERED\";\n\t\telse\n\t\t\tstatep = \"INIT\";\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"TGT WWNN x%llx WWPN x%llx State %s\\n\",\n\t\t\t\twwn_to_u64(vport->fc_nodename.u.wwn),\n\t\t\t\twwn_to_u64(vport->fc_portname.u.wwn),\n\t\t\t\tstatep);\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"    Targetport DID x%06x\\n\",\n\t\t\t\tphba->targetport->port_id);\n\t\tgoto out_exit;\n\t}\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"\\nNVME Lport/Rport Entries ...\\n\");\n\n\tlocalport = vport->localport;\n\tif (!localport)\n\t\tgoto out_exit;\n\n\tspin_lock_irq(shost->host_lock);\n\n\t \n\tif (localport->port_id)\n\t\tstatep = \"ONLINE\";\n\telse\n\t\tstatep = \"UNKNOWN \";\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\"Lport DID x%06x PortState %s\\n\",\n\t\t\tlocalport->port_id, statep);\n\n\tlen += scnprintf(buf + len, size - len, \"\\tRport List:\\n\");\n\tlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\n\t\t \n\t\tspin_lock(&ndlp->lock);\n\t\trport = lpfc_ndlp_get_nrport(ndlp);\n\t\tif (rport)\n\t\t\tnrport = rport->remoteport;\n\t\telse\n\t\t\tnrport = NULL;\n\t\tspin_unlock(&ndlp->lock);\n\t\tif (!nrport)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (nrport->port_state) {\n\t\tcase FC_OBJSTATE_ONLINE:\n\t\t\tstatep = \"ONLINE\";\n\t\t\tbreak;\n\t\tcase FC_OBJSTATE_UNKNOWN:\n\t\t\tstatep = \"UNKNOWN \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatep = \"UNSUPPORTED\";\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"\\t%s Port ID:x%06x \",\n\t\t\t\tstatep, nrport->port_id);\n\t\tlen += scnprintf(buf + len, size - len, \"WWPN x%llx \",\n\t\t\t\tnrport->port_name);\n\t\tlen += scnprintf(buf + len, size - len, \"WWNN x%llx \",\n\t\t\t\tnrport->node_name);\n\n\t\t \n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_INITIATOR)\n\t\t\tlen +=  scnprintf(buf + len, size - len,\n\t\t\t\t\t \"INITIATOR \");\n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_TARGET)\n\t\t\tlen +=  scnprintf(buf + len, size - len,\n\t\t\t\t\t \"TARGET \");\n\t\tif (nrport->port_role & FC_PORT_ROLE_NVME_DISCOVERY)\n\t\t\tlen +=  scnprintf(buf + len, size - len,\n\t\t\t\t\t \"DISCSRVC \");\n\t\tif (nrport->port_role & ~(FC_PORT_ROLE_NVME_INITIATOR |\n\t\t\t\t\t  FC_PORT_ROLE_NVME_TARGET |\n\t\t\t\t\t  FC_PORT_ROLE_NVME_DISCOVERY))\n\t\t\tlen +=  scnprintf(buf + len, size - len,\n\t\t\t\t\t \"UNKNOWN ROLE x%x\",\n\t\t\t\t\t nrport->port_role);\n\t\t \n\t\tlen +=  scnprintf(buf + len, size - len, \"\\n\");\n\t}\n\n\tspin_unlock_irq(shost->host_lock);\n out_exit:\n\treturn len;\n}\n\n \nstatic int\nlpfc_debugfs_nvmestat_data(struct lpfc_vport *vport, char *buf, int size)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_nvmet_tgtport *tgtp;\n\tstruct lpfc_async_xchg_ctx *ctxp, *next_ctxp;\n\tstruct nvme_fc_local_port *localport;\n\tstruct lpfc_fc4_ctrl_stat *cstat;\n\tstruct lpfc_nvme_lport *lport;\n\tuint64_t data1, data2, data3;\n\tuint64_t tot, totin, totout;\n\tint cnt, i;\n\tint len = 0;\n\n\tif (phba->nvmet_support) {\n\t\tif (!phba->targetport)\n\t\t\treturn len;\n\t\ttgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"\\nNVME Targetport Statistics\\n\");\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"LS: Rcv %08x Drop %08x Abort %08x\\n\",\n\t\t\t\tatomic_read(&tgtp->rcv_ls_req_in),\n\t\t\t\tatomic_read(&tgtp->rcv_ls_req_drop),\n\t\t\t\tatomic_read(&tgtp->xmt_ls_abort));\n\t\tif (atomic_read(&tgtp->rcv_ls_req_in) !=\n\t\t    atomic_read(&tgtp->rcv_ls_req_out)) {\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\"Rcv LS: in %08x != out %08x\\n\",\n\t\t\t\t\tatomic_read(&tgtp->rcv_ls_req_in),\n\t\t\t\t\tatomic_read(&tgtp->rcv_ls_req_out));\n\t\t}\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"LS: Xmt %08x Drop %08x Cmpl %08x\\n\",\n\t\t\t\tatomic_read(&tgtp->xmt_ls_rsp),\n\t\t\t\tatomic_read(&tgtp->xmt_ls_drop),\n\t\t\t\tatomic_read(&tgtp->xmt_ls_rsp_cmpl));\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"LS: RSP Abort %08x xb %08x Err %08x\\n\",\n\t\t\t\tatomic_read(&tgtp->xmt_ls_rsp_aborted),\n\t\t\t\tatomic_read(&tgtp->xmt_ls_rsp_xb_set),\n\t\t\t\tatomic_read(&tgtp->xmt_ls_rsp_error));\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"FCP: Rcv %08x Defer %08x Release %08x \"\n\t\t\t\t\"Drop %08x\\n\",\n\t\t\t\tatomic_read(&tgtp->rcv_fcp_cmd_in),\n\t\t\t\tatomic_read(&tgtp->rcv_fcp_cmd_defer),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_release),\n\t\t\t\tatomic_read(&tgtp->rcv_fcp_cmd_drop));\n\n\t\tif (atomic_read(&tgtp->rcv_fcp_cmd_in) !=\n\t\t    atomic_read(&tgtp->rcv_fcp_cmd_out)) {\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\"Rcv FCP: in %08x != out %08x\\n\",\n\t\t\t\t\tatomic_read(&tgtp->rcv_fcp_cmd_in),\n\t\t\t\t\tatomic_read(&tgtp->rcv_fcp_cmd_out));\n\t\t}\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"FCP Rsp: read %08x readrsp %08x \"\n\t\t\t\t\"write %08x rsp %08x\\n\",\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_read),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_read_rsp),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_write),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_rsp));\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"FCP Rsp Cmpl: %08x err %08x drop %08x\\n\",\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_rsp_cmpl),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_rsp_error),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_rsp_drop));\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"FCP Rsp Abort: %08x xb %08x xricqe  %08x\\n\",\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_rsp_aborted),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_rsp_xb_set),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_xri_abort_cqe));\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"ABORT: Xmt %08x Cmpl %08x\\n\",\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_abort),\n\t\t\t\tatomic_read(&tgtp->xmt_fcp_abort_cmpl));\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"ABORT: Sol %08x  Usol %08x Err %08x Cmpl %08x\",\n\t\t\t\tatomic_read(&tgtp->xmt_abort_sol),\n\t\t\t\tatomic_read(&tgtp->xmt_abort_unsol),\n\t\t\t\tatomic_read(&tgtp->xmt_abort_rsp),\n\t\t\t\tatomic_read(&tgtp->xmt_abort_rsp_error));\n\n\t\tlen +=  scnprintf(buf + len, size - len, \"\\n\");\n\n\t\tcnt = 0;\n\t\tspin_lock(&phba->sli4_hba.abts_nvmet_buf_list_lock);\n\t\tlist_for_each_entry_safe(ctxp, next_ctxp,\n\t\t\t\t&phba->sli4_hba.lpfc_abts_nvmet_ctx_list,\n\t\t\t\tlist) {\n\t\t\tcnt++;\n\t\t}\n\t\tspin_unlock(&phba->sli4_hba.abts_nvmet_buf_list_lock);\n\t\tif (cnt) {\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\"ABORT: %d ctx entries\\n\", cnt);\n\t\t\tspin_lock(&phba->sli4_hba.abts_nvmet_buf_list_lock);\n\t\t\tlist_for_each_entry_safe(ctxp, next_ctxp,\n\t\t\t\t    &phba->sli4_hba.lpfc_abts_nvmet_ctx_list,\n\t\t\t\t    list) {\n\t\t\t\tif (len >= (size - LPFC_DEBUG_OUT_LINE_SZ))\n\t\t\t\t\tbreak;\n\t\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\t\"Entry: oxid %x state %x \"\n\t\t\t\t\t\t\"flag %x\\n\",\n\t\t\t\t\t\tctxp->oxid, ctxp->state,\n\t\t\t\t\t\tctxp->flag);\n\t\t\t}\n\t\t\tspin_unlock(&phba->sli4_hba.abts_nvmet_buf_list_lock);\n\t\t}\n\n\t\t \n\t\ttot = atomic_read(&tgtp->rcv_fcp_cmd_drop);\n\t\ttot += atomic_read(&tgtp->xmt_fcp_release);\n\t\ttot = atomic_read(&tgtp->rcv_fcp_cmd_in) - tot;\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"IO_CTX: %08x  WAIT: cur %08x tot %08x\\n\"\n\t\t\t\t\"CTX Outstanding %08llx\\n\",\n\t\t\t\tphba->sli4_hba.nvmet_xri_cnt,\n\t\t\t\tphba->sli4_hba.nvmet_io_wait_cnt,\n\t\t\t\tphba->sli4_hba.nvmet_io_wait_total,\n\t\t\t\ttot);\n\t} else {\n\t\tif (!(vport->cfg_enable_fc4_type & LPFC_ENABLE_NVME))\n\t\t\treturn len;\n\n\t\tlocalport = vport->localport;\n\t\tif (!localport)\n\t\t\treturn len;\n\t\tlport = (struct lpfc_nvme_lport *)localport->private;\n\t\tif (!lport)\n\t\t\treturn len;\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"\\nNVME HDWQ Statistics\\n\");\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"LS: Xmt %016x Cmpl %016x\\n\",\n\t\t\t\tatomic_read(&lport->fc4NvmeLsRequests),\n\t\t\t\tatomic_read(&lport->fc4NvmeLsCmpls));\n\n\t\ttotin = 0;\n\t\ttotout = 0;\n\t\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\t\tcstat = &phba->sli4_hba.hdwq[i].nvme_cstat;\n\t\t\ttot = cstat->io_cmpls;\n\t\t\ttotin += tot;\n\t\t\tdata1 = cstat->input_requests;\n\t\t\tdata2 = cstat->output_requests;\n\t\t\tdata3 = cstat->control_requests;\n\t\t\ttotout += (data1 + data2 + data3);\n\n\t\t\t \n\t\t\tif (i >= 32)\n\t\t\t\tcontinue;\n\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"HDWQ (%d): Rd %016llx Wr %016llx \"\n\t\t\t\t\t\"IO %016llx \",\n\t\t\t\t\ti, data1, data2, data3);\n\t\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\t\"Cmpl %016llx OutIO %016llx\\n\",\n\t\t\t\t\ttot, ((data1 + data2 + data3) - tot));\n\t\t}\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"Total FCP Cmpl %016llx Issue %016llx \"\n\t\t\t\t\"OutIO %016llx\\n\",\n\t\t\t\ttotin, totout, totout - totin);\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"LS Xmt Err: Abrt %08x Err %08x  \"\n\t\t\t\t\"Cmpl Err: xb %08x Err %08x\\n\",\n\t\t\t\tatomic_read(&lport->xmt_ls_abort),\n\t\t\t\tatomic_read(&lport->xmt_ls_err),\n\t\t\t\tatomic_read(&lport->cmpl_ls_xb),\n\t\t\t\tatomic_read(&lport->cmpl_ls_err));\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"FCP Xmt Err: noxri %06x nondlp %06x \"\n\t\t\t\t\"qdepth %06x wqerr %06x err %06x Abrt %06x\\n\",\n\t\t\t\tatomic_read(&lport->xmt_fcp_noxri),\n\t\t\t\tatomic_read(&lport->xmt_fcp_bad_ndlp),\n\t\t\t\tatomic_read(&lport->xmt_fcp_qdepth),\n\t\t\t\tatomic_read(&lport->xmt_fcp_wqerr),\n\t\t\t\tatomic_read(&lport->xmt_fcp_err),\n\t\t\t\tatomic_read(&lport->xmt_fcp_abort));\n\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\"FCP Cmpl Err: xb %08x Err %08x\\n\",\n\t\t\t\tatomic_read(&lport->cmpl_fcp_xb),\n\t\t\t\tatomic_read(&lport->cmpl_fcp_err));\n\n\t}\n\n\treturn len;\n}\n\n \nstatic int\nlpfc_debugfs_scsistat_data(struct lpfc_vport *vport, char *buf, int size)\n{\n\tint len;\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_fc4_ctrl_stat *cstat;\n\tu64 data1, data2, data3;\n\tu64 tot, totin, totout;\n\tint i;\n\tchar tmp[LPFC_MAX_SCSI_INFO_TMP_LEN] = {0};\n\n\tif (!(vport->cfg_enable_fc4_type & LPFC_ENABLE_FCP) ||\n\t    (phba->sli_rev != LPFC_SLI_REV4))\n\t\treturn 0;\n\n\tscnprintf(buf, size, \"SCSI HDWQ Statistics\\n\");\n\n\ttotin = 0;\n\ttotout = 0;\n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\tcstat = &phba->sli4_hba.hdwq[i].scsi_cstat;\n\t\ttot = cstat->io_cmpls;\n\t\ttotin += tot;\n\t\tdata1 = cstat->input_requests;\n\t\tdata2 = cstat->output_requests;\n\t\tdata3 = cstat->control_requests;\n\t\ttotout += (data1 + data2 + data3);\n\n\t\tscnprintf(tmp, sizeof(tmp), \"HDWQ (%d): Rd %016llx Wr %016llx \"\n\t\t\t  \"IO %016llx \", i, data1, data2, data3);\n\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\tgoto buffer_done;\n\n\t\tscnprintf(tmp, sizeof(tmp), \"Cmpl %016llx OutIO %016llx\\n\",\n\t\t\t  tot, ((data1 + data2 + data3) - tot));\n\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\tgoto buffer_done;\n\t}\n\tscnprintf(tmp, sizeof(tmp), \"Total FCP Cmpl %016llx Issue %016llx \"\n\t\t  \"OutIO %016llx\\n\", totin, totout, totout - totin);\n\tstrlcat(buf, tmp, size);\n\nbuffer_done:\n\tlen = strnlen(buf, size);\n\n\treturn len;\n}\n\nvoid\nlpfc_io_ktime(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\tuint64_t seg1, seg2, seg3, seg4;\n\tuint64_t segsum;\n\n\tif (!lpfc_cmd->ts_last_cmd ||\n\t    !lpfc_cmd->ts_cmd_start ||\n\t    !lpfc_cmd->ts_cmd_wqput ||\n\t    !lpfc_cmd->ts_isr_cmpl ||\n\t    !lpfc_cmd->ts_data_io)\n\t\treturn;\n\n\tif (lpfc_cmd->ts_data_io < lpfc_cmd->ts_cmd_start)\n\t\treturn;\n\tif (lpfc_cmd->ts_cmd_start < lpfc_cmd->ts_last_cmd)\n\t\treturn;\n\tif (lpfc_cmd->ts_cmd_wqput < lpfc_cmd->ts_cmd_start)\n\t\treturn;\n\tif (lpfc_cmd->ts_isr_cmpl < lpfc_cmd->ts_cmd_wqput)\n\t\treturn;\n\tif (lpfc_cmd->ts_data_io < lpfc_cmd->ts_isr_cmpl)\n\t\treturn;\n\t \n\tseg1 = lpfc_cmd->ts_cmd_start - lpfc_cmd->ts_last_cmd;\n\tif (seg1 > 5000000)   \n\t\tseg1 = 0;\n\n\t \n\tseg2 = (lpfc_cmd->ts_cmd_wqput - lpfc_cmd->ts_cmd_start);\n\tsegsum = seg2;\n\tseg3 = lpfc_cmd->ts_isr_cmpl - lpfc_cmd->ts_cmd_start;\n\tif (segsum > seg3)\n\t\treturn;\n\tseg3 -= segsum;\n\tsegsum += seg3;\n\n\tseg4 = lpfc_cmd->ts_data_io - lpfc_cmd->ts_cmd_start;\n\tif (segsum > seg4)\n\t\treturn;\n\tseg4 -= segsum;\n\n\tphba->ktime_data_samples++;\n\tphba->ktime_seg1_total += seg1;\n\tif (seg1 < phba->ktime_seg1_min)\n\t\tphba->ktime_seg1_min = seg1;\n\telse if (seg1 > phba->ktime_seg1_max)\n\t\tphba->ktime_seg1_max = seg1;\n\tphba->ktime_seg2_total += seg2;\n\tif (seg2 < phba->ktime_seg2_min)\n\t\tphba->ktime_seg2_min = seg2;\n\telse if (seg2 > phba->ktime_seg2_max)\n\t\tphba->ktime_seg2_max = seg2;\n\tphba->ktime_seg3_total += seg3;\n\tif (seg3 < phba->ktime_seg3_min)\n\t\tphba->ktime_seg3_min = seg3;\n\telse if (seg3 > phba->ktime_seg3_max)\n\t\tphba->ktime_seg3_max = seg3;\n\tphba->ktime_seg4_total += seg4;\n\tif (seg4 < phba->ktime_seg4_min)\n\t\tphba->ktime_seg4_min = seg4;\n\telse if (seg4 > phba->ktime_seg4_max)\n\t\tphba->ktime_seg4_max = seg4;\n\n\tlpfc_cmd->ts_last_cmd = 0;\n\tlpfc_cmd->ts_cmd_start = 0;\n\tlpfc_cmd->ts_cmd_wqput  = 0;\n\tlpfc_cmd->ts_isr_cmpl = 0;\n\tlpfc_cmd->ts_data_io = 0;\n}\n\n \nstatic int\nlpfc_debugfs_ioktime_data(struct lpfc_vport *vport, char *buf, int size)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint len = 0;\n\n\tif (phba->nvmet_support == 0) {\n\t\t \n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"ktime %s: Total Samples: %lld\\n\",\n\t\t\t\t(phba->ktime_on ?  \"Enabled\" : \"Disabled\"),\n\t\t\t\tphba->ktime_data_samples);\n\t\tif (phba->ktime_data_samples == 0)\n\t\t\treturn len;\n\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"Segment 1: Last Cmd cmpl \"\n\t\t\t\"done -to- Start of next Cmd (in driver)\\n\");\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg1_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg1_min,\n\t\t\tphba->ktime_seg1_max);\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"Segment 2: Driver start of Cmd \"\n\t\t\t\"-to- Firmware WQ doorbell\\n\");\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg2_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg2_min,\n\t\t\tphba->ktime_seg2_max);\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"Segment 3: Firmware WQ doorbell -to- \"\n\t\t\t\"MSI-X ISR cmpl\\n\");\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg3_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg3_min,\n\t\t\tphba->ktime_seg3_max);\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"Segment 4: MSI-X ISR cmpl -to- \"\n\t\t\t\"Cmd cmpl done\\n\");\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg4_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg4_min,\n\t\t\tphba->ktime_seg4_max);\n\t\tlen += scnprintf(\n\t\t\tbuf + len, PAGE_SIZE - len,\n\t\t\t\"Total IO avg time: %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg1_total +\n\t\t\tphba->ktime_seg2_total  +\n\t\t\tphba->ktime_seg3_total +\n\t\t\tphba->ktime_seg4_total,\n\t\t\tphba->ktime_data_samples));\n\t\treturn len;\n\t}\n\n\t \n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"ktime %s: Total Samples: %lld %lld\\n\",\n\t\t\t(phba->ktime_on ? \"Enabled\" : \"Disabled\"),\n\t\t\tphba->ktime_data_samples,\n\t\t\tphba->ktime_status_samples);\n\tif (phba->ktime_data_samples == 0)\n\t\treturn len;\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 1: MSI-X ISR Rcv cmd -to- \"\n\t\t\t\"cmd pass to NVME Layer\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg1_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg1_min,\n\t\t\tphba->ktime_seg1_max);\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 2: cmd pass to NVME Layer- \"\n\t\t\t\"-to- Driver rcv cmd OP (action)\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg2_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg2_min,\n\t\t\tphba->ktime_seg2_max);\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 3: Driver rcv cmd OP -to- \"\n\t\t\t\"Firmware WQ doorbell: cmd\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg3_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg3_min,\n\t\t\tphba->ktime_seg3_max);\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 4: Firmware WQ doorbell: cmd \"\n\t\t\t\"-to- MSI-X ISR for cmd cmpl\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg4_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg4_min,\n\t\t\tphba->ktime_seg4_max);\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 5: MSI-X ISR for cmd cmpl \"\n\t\t\t\"-to- NVME layer passed cmd done\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg5_total,\n\t\t\t\tphba->ktime_data_samples),\n\t\t\tphba->ktime_seg5_min,\n\t\t\tphba->ktime_seg5_max);\n\n\tif (phba->ktime_status_samples == 0) {\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"Total: cmd received by MSI-X ISR \"\n\t\t\t\t\"-to- cmd completed on wire\\n\");\n\t\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\t\"avg:%08lld min:%08lld \"\n\t\t\t\t\"max %08lld\\n\",\n\t\t\t\tdiv_u64(phba->ktime_seg10_total,\n\t\t\t\t\tphba->ktime_data_samples),\n\t\t\t\tphba->ktime_seg10_min,\n\t\t\t\tphba->ktime_seg10_max);\n\t\treturn len;\n\t}\n\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 6: NVME layer passed cmd done \"\n\t\t\t\"-to- Driver rcv rsp status OP\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg6_total,\n\t\t\t\tphba->ktime_status_samples),\n\t\t\tphba->ktime_seg6_min,\n\t\t\tphba->ktime_seg6_max);\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 7: Driver rcv rsp status OP \"\n\t\t\t\"-to- Firmware WQ doorbell: status\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg7_total,\n\t\t\t\tphba->ktime_status_samples),\n\t\t\tphba->ktime_seg7_min,\n\t\t\tphba->ktime_seg7_max);\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 8: Firmware WQ doorbell: status\"\n\t\t\t\" -to- MSI-X ISR for status cmpl\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg8_total,\n\t\t\t\tphba->ktime_status_samples),\n\t\t\tphba->ktime_seg8_min,\n\t\t\tphba->ktime_seg8_max);\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Segment 9: MSI-X ISR for status cmpl  \"\n\t\t\t\"-to- NVME layer passed status done\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg9_total,\n\t\t\t\tphba->ktime_status_samples),\n\t\t\tphba->ktime_seg9_min,\n\t\t\tphba->ktime_seg9_max);\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"Total: cmd received by MSI-X ISR -to- \"\n\t\t\t\"cmd completed on wire\\n\");\n\tlen += scnprintf(buf + len, PAGE_SIZE-len,\n\t\t\t\"avg:%08lld min:%08lld max %08lld\\n\",\n\t\t\tdiv_u64(phba->ktime_seg10_total,\n\t\t\t\tphba->ktime_status_samples),\n\t\t\tphba->ktime_seg10_min,\n\t\t\tphba->ktime_seg10_max);\n\treturn len;\n}\n\n \nstatic int\nlpfc_debugfs_nvmeio_trc_data(struct lpfc_hba *phba, char *buf, int size)\n{\n\tstruct lpfc_debugfs_nvmeio_trc *dtp;\n\tint i, state, index, skip;\n\tint len = 0;\n\n\tstate = phba->nvmeio_trc_on;\n\n\tindex = (atomic_read(&phba->nvmeio_trc_cnt) + 1) &\n\t\t(phba->nvmeio_trc_size - 1);\n\tskip = phba->nvmeio_trc_output_idx;\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\"%s IO Trace %s: next_idx %d skip %d size %d\\n\",\n\t\t\t(phba->nvmet_support ? \"NVME\" : \"NVMET\"),\n\t\t\t(state ? \"Enabled\" : \"Disabled\"),\n\t\t\tindex, skip, phba->nvmeio_trc_size);\n\n\tif (!phba->nvmeio_trc || state)\n\t\treturn len;\n\n\t \n\n\tfor (i = index; i < phba->nvmeio_trc_size; i++) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tdtp = phba->nvmeio_trc + i;\n\t\tphba->nvmeio_trc_output_idx++;\n\n\t\tif (!dtp->fmt)\n\t\t\tcontinue;\n\n\t\tlen +=  scnprintf(buf + len, size - len, dtp->fmt,\n\t\t\tdtp->data1, dtp->data2, dtp->data3);\n\n\t\tif (phba->nvmeio_trc_output_idx >= phba->nvmeio_trc_size) {\n\t\t\tphba->nvmeio_trc_output_idx = 0;\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\"Trace Complete\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (len >= (size - LPFC_DEBUG_OUT_LINE_SZ)) {\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\"Trace Continue (%d of %d)\\n\",\n\t\t\t\t\tphba->nvmeio_trc_output_idx,\n\t\t\t\t\tphba->nvmeio_trc_size);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor (i = 0; i < index; i++) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tdtp = phba->nvmeio_trc + i;\n\t\tphba->nvmeio_trc_output_idx++;\n\n\t\tif (!dtp->fmt)\n\t\t\tcontinue;\n\n\t\tlen +=  scnprintf(buf + len, size - len, dtp->fmt,\n\t\t\tdtp->data1, dtp->data2, dtp->data3);\n\n\t\tif (phba->nvmeio_trc_output_idx >= phba->nvmeio_trc_size) {\n\t\t\tphba->nvmeio_trc_output_idx = 0;\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\"Trace Complete\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (len >= (size - LPFC_DEBUG_OUT_LINE_SZ)) {\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\"Trace Continue (%d of %d)\\n\",\n\t\t\t\t\tphba->nvmeio_trc_output_idx,\n\t\t\t\t\tphba->nvmeio_trc_size);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\"Trace Done\\n\");\nout:\n\treturn len;\n}\n\n \nstatic int\nlpfc_debugfs_hdwqstat_data(struct lpfc_vport *vport, char *buf, int size)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_hdwq_stat *c_stat;\n\tint i, j, len;\n\tuint32_t tot_xmt;\n\tuint32_t tot_rcv;\n\tuint32_t tot_cmpl;\n\tchar tmp[LPFC_MAX_SCSI_INFO_TMP_LEN] = {0};\n\n\tscnprintf(tmp, sizeof(tmp), \"HDWQ Stats:\\n\\n\");\n\tif (strlcat(buf, tmp, size) >= size)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp), \"(NVME Accounting: %s) \",\n\t\t  (phba->hdwqstat_on &\n\t\t  (LPFC_CHECK_NVME_IO | LPFC_CHECK_NVMET_IO) ?\n\t\t  \"Enabled\" : \"Disabled\"));\n\tif (strlcat(buf, tmp, size) >= size)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp), \"(SCSI Accounting: %s) \",\n\t\t  (phba->hdwqstat_on & LPFC_CHECK_SCSI_IO ?\n\t\t  \"Enabled\" : \"Disabled\"));\n\tif (strlcat(buf, tmp, size) >= size)\n\t\tgoto buffer_done;\n\n\tscnprintf(tmp, sizeof(tmp), \"\\n\\n\");\n\tif (strlcat(buf, tmp, size) >= size)\n\t\tgoto buffer_done;\n\n\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\ttot_rcv = 0;\n\t\ttot_xmt = 0;\n\t\ttot_cmpl = 0;\n\n\t\tfor_each_present_cpu(j) {\n\t\t\tc_stat = per_cpu_ptr(phba->sli4_hba.c_stat, j);\n\n\t\t\t \n\t\t\tif (i != c_stat->hdwq_no)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!c_stat->xmt_io && !c_stat->cmpl_io &&\n\t\t\t    !c_stat->rcv_io)\n\t\t\t\tcontinue;\n\n\t\t\tif (!tot_xmt && !tot_cmpl && !tot_rcv) {\n\t\t\t\t \n\t\t\t\tscnprintf(tmp, sizeof(tmp), \"[HDWQ %d]:\\t\", i);\n\t\t\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\t\t\tgoto buffer_done;\n\t\t\t}\n\n\t\t\ttot_xmt += c_stat->xmt_io;\n\t\t\ttot_cmpl += c_stat->cmpl_io;\n\t\t\tif (phba->nvmet_support)\n\t\t\t\ttot_rcv += c_stat->rcv_io;\n\n\t\t\tscnprintf(tmp, sizeof(tmp), \"| [CPU %d]: \", j);\n\t\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\t\tgoto buffer_done;\n\n\t\t\tif (phba->nvmet_support) {\n\t\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t\t  \"XMT 0x%x CMPL 0x%x RCV 0x%x |\",\n\t\t\t\t\t  c_stat->xmt_io, c_stat->cmpl_io,\n\t\t\t\t\t  c_stat->rcv_io);\n\t\t\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\t\t\tgoto buffer_done;\n\t\t\t} else {\n\t\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t\t  \"XMT 0x%x CMPL 0x%x |\",\n\t\t\t\t\t  c_stat->xmt_io, c_stat->cmpl_io);\n\t\t\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\t\t\tgoto buffer_done;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!tot_xmt && !tot_cmpl && !tot_rcv)\n\t\t\tcontinue;\n\n\t\tscnprintf(tmp, sizeof(tmp), \"\\t->\\t[HDWQ Total: \");\n\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\tgoto buffer_done;\n\n\t\tif (phba->nvmet_support) {\n\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t  \"XMT 0x%x CMPL 0x%x RCV 0x%x]\\n\\n\",\n\t\t\t\t  tot_xmt, tot_cmpl, tot_rcv);\n\t\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\t\tgoto buffer_done;\n\t\t} else {\n\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t  \"XMT 0x%x CMPL 0x%x]\\n\\n\",\n\t\t\t\t  tot_xmt, tot_cmpl);\n\t\t\tif (strlcat(buf, tmp, size) >= size)\n\t\t\t\tgoto buffer_done;\n\t\t}\n\t}\n\nbuffer_done:\n\tlen = strnlen(buf, size);\n\treturn len;\n}\n\n#endif\n\n \ninline void\nlpfc_debugfs_disc_trc(struct lpfc_vport *vport, int mask, char *fmt,\n\tuint32_t data1, uint32_t data2, uint32_t data3)\n{\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tstruct lpfc_debugfs_trc *dtp;\n\tint index;\n\n\tif (!(lpfc_debugfs_mask_disc_trc & mask))\n\t\treturn;\n\n\tif (!lpfc_debugfs_enable || !lpfc_debugfs_max_disc_trc ||\n\t\t!vport || !vport->disc_trc)\n\t\treturn;\n\n\tindex = atomic_inc_return(&vport->disc_trc_cnt) &\n\t\t(lpfc_debugfs_max_disc_trc - 1);\n\tdtp = vport->disc_trc + index;\n\tdtp->fmt = fmt;\n\tdtp->data1 = data1;\n\tdtp->data2 = data2;\n\tdtp->data3 = data3;\n\tdtp->seq_cnt = atomic_inc_return(&lpfc_debugfs_seq_trc_cnt);\n\tdtp->jif = jiffies;\n#endif\n\treturn;\n}\n\n \ninline void\nlpfc_debugfs_slow_ring_trc(struct lpfc_hba *phba, char *fmt,\n\tuint32_t data1, uint32_t data2, uint32_t data3)\n{\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tstruct lpfc_debugfs_trc *dtp;\n\tint index;\n\n\tif (!lpfc_debugfs_enable || !lpfc_debugfs_max_slow_ring_trc ||\n\t\t!phba || !phba->slow_ring_trc)\n\t\treturn;\n\n\tindex = atomic_inc_return(&phba->slow_ring_trc_cnt) &\n\t\t(lpfc_debugfs_max_slow_ring_trc - 1);\n\tdtp = phba->slow_ring_trc + index;\n\tdtp->fmt = fmt;\n\tdtp->data1 = data1;\n\tdtp->data2 = data2;\n\tdtp->data3 = data3;\n\tdtp->seq_cnt = atomic_inc_return(&lpfc_debugfs_seq_trc_cnt);\n\tdtp->jif = jiffies;\n#endif\n\treturn;\n}\n\n \ninline void\nlpfc_debugfs_nvme_trc(struct lpfc_hba *phba, char *fmt,\n\t\t      uint16_t data1, uint16_t data2, uint32_t data3)\n{\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tstruct lpfc_debugfs_nvmeio_trc *dtp;\n\tint index;\n\n\tif (!phba->nvmeio_trc_on || !phba->nvmeio_trc)\n\t\treturn;\n\n\tindex = atomic_inc_return(&phba->nvmeio_trc_cnt) &\n\t\t(phba->nvmeio_trc_size - 1);\n\tdtp = phba->nvmeio_trc + index;\n\tdtp->fmt = fmt;\n\tdtp->data1 = data1;\n\tdtp->data2 = data2;\n\tdtp->data3 = data3;\n#endif\n}\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n \nstatic int\nlpfc_debugfs_disc_trc_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_vport *vport = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint size;\n\tint rc = -ENOMEM;\n\n\tif (!lpfc_debugfs_max_disc_trc) {\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t \n\tsize =  (lpfc_debugfs_max_disc_trc * LPFC_DEBUG_TRC_ENTRY_SIZE);\n\tsize = PAGE_ALIGN(size);\n\n\tdebug->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_disc_trc_data(vport, debug->buffer, size);\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nstatic int\nlpfc_debugfs_slow_ring_trc_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_hba *phba = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint size;\n\tint rc = -ENOMEM;\n\n\tif (!lpfc_debugfs_max_slow_ring_trc) {\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t \n\tsize =  (lpfc_debugfs_max_slow_ring_trc * LPFC_DEBUG_TRC_ENTRY_SIZE);\n\tsize = PAGE_ALIGN(size);\n\n\tdebug->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_slow_ring_trc_data(phba, debug->buffer, size);\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nstatic int\nlpfc_debugfs_hbqinfo_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_hba *phba = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t \n\tdebug->buffer = kmalloc(LPFC_HBQINFO_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_hbqinfo_data(phba, debug->buffer,\n\t\tLPFC_HBQINFO_SIZE);\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nstatic int\nlpfc_debugfs_multixripools_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_hba *phba = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t \n\tdebug->buffer = kzalloc(LPFC_DUMP_MULTIXRIPOOL_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_multixripools_data(\n\t\tphba, debug->buffer, LPFC_DUMP_MULTIXRIPOOL_SIZE);\n\n\tdebug->i_private = inode->i_private;\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\n#ifdef LPFC_HDWQ_LOCK_STAT\n \nstatic int\nlpfc_debugfs_lockstat_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_hba *phba = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t \n\tdebug->buffer = kmalloc(LPFC_HDWQINFO_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_lockstat_data(phba, debug->buffer,\n\t\tLPFC_HBQINFO_SIZE);\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_debugfs_lockstat_write(struct file *file, const char __user *buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tchar mybuf[64];\n\tchar *pbuf;\n\tint i;\n\tsize_t bsize;\n\n\tmemset(mybuf, 0, sizeof(mybuf));\n\n\tbsize = min(nbytes, (sizeof(mybuf) - 1));\n\n\tif (copy_from_user(mybuf, buf, bsize))\n\t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"reset\", strlen(\"reset\")) == 0) ||\n\t    (strncmp(pbuf, \"zero\", strlen(\"zero\")) == 0)) {\n\t\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\t\tqp = &phba->sli4_hba.hdwq[i];\n\t\t\tqp->lock_conflict.alloc_xri_get = 0;\n\t\t\tqp->lock_conflict.alloc_xri_put = 0;\n\t\t\tqp->lock_conflict.free_xri = 0;\n\t\t\tqp->lock_conflict.wq_access = 0;\n\t\t\tqp->lock_conflict.alloc_pvt_pool = 0;\n\t\t\tqp->lock_conflict.mv_from_pvt_pool = 0;\n\t\t\tqp->lock_conflict.mv_to_pub_pool = 0;\n\t\t\tqp->lock_conflict.mv_to_pvt_pool = 0;\n\t\t\tqp->lock_conflict.free_pvt_pool = 0;\n\t\t\tqp->lock_conflict.free_pub_pool = 0;\n\t\t\tqp->lock_conflict.wq_access = 0;\n\t\t}\n\t}\n\treturn bsize;\n}\n#endif\n\nstatic int lpfc_debugfs_ras_log_data(struct lpfc_hba *phba,\n\t\t\t\t     char *buffer, int size)\n{\n\tint copied = 0;\n\tstruct lpfc_dmabuf *dmabuf, *next;\n\n\tmemset(buffer, 0, size);\n\n\tspin_lock_irq(&phba->hbalock);\n\tif (phba->ras_fwlog.state != ACTIVE) {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\tlist_for_each_entry_safe(dmabuf, next,\n\t\t\t\t &phba->ras_fwlog.fwlog_buff_list, list) {\n\t\t \n\t\tif ((copied + LPFC_RAS_MAX_ENTRY_SIZE) >= (size - 1)) {\n\t\t\tmemcpy(buffer + copied, dmabuf->virt,\n\t\t\t       size - copied - 1);\n\t\t\tcopied += size - copied - 1;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buffer + copied, dmabuf->virt, LPFC_RAS_MAX_ENTRY_SIZE);\n\t\tcopied += LPFC_RAS_MAX_ENTRY_SIZE;\n\t}\n\treturn copied;\n}\n\nstatic int\nlpfc_debugfs_ras_log_release(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\n\tvfree(debug->buffer);\n\tkfree(debug);\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_debugfs_ras_log_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_hba *phba = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint size;\n\tint rc = -ENOMEM;\n\n\tspin_lock_irq(&phba->hbalock);\n\tif (phba->ras_fwlog.state != ACTIVE) {\n\t\tspin_unlock_irq(&phba->hbalock);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tspin_unlock_irq(&phba->hbalock);\n\n\tif (check_mul_overflow(LPFC_RAS_MIN_BUFF_POST_SIZE,\n\t\t\t       phba->cfg_ras_fwlog_buffsize, &size))\n\t\tgoto out;\n\n\tdebug = kzalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\tdebug->buffer = vmalloc(size);\n\tif (!debug->buffer)\n\t\tgoto free_debug;\n\n\tdebug->len = lpfc_debugfs_ras_log_data(phba, debug->buffer, size);\n\tif (debug->len < 0) {\n\t\trc = -EINVAL;\n\t\tgoto free_buffer;\n\t}\n\tfile->private_data = debug;\n\n\treturn 0;\n\nfree_buffer:\n\tvfree(debug->buffer);\nfree_debug:\n\tkfree(debug);\nout:\n\treturn rc;\n}\n\n \nstatic int\nlpfc_debugfs_dumpHBASlim_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_hba *phba = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t \n\tdebug->buffer = kmalloc(LPFC_DUMPHBASLIM_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_dumpHBASlim_data(phba, debug->buffer,\n\t\tLPFC_DUMPHBASLIM_SIZE);\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nstatic int\nlpfc_debugfs_dumpHostSlim_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_hba *phba = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t \n\tdebug->buffer = kmalloc(LPFC_DUMPHOSTSLIM_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_dumpHostSlim_data(phba, debug->buffer,\n\t\tLPFC_DUMPHOSTSLIM_SIZE);\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_debugfs_dif_err_read(struct file *file, char __user *buf,\n\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tstruct lpfc_hba *phba = file->private_data;\n\tchar cbuf[32];\n\tuint64_t tmp = 0;\n\tint cnt = 0;\n\n\tif (dent == phba->debug_writeGuard)\n\t\tcnt = scnprintf(cbuf, 32, \"%u\\n\", phba->lpfc_injerr_wgrd_cnt);\n\telse if (dent == phba->debug_writeApp)\n\t\tcnt = scnprintf(cbuf, 32, \"%u\\n\", phba->lpfc_injerr_wapp_cnt);\n\telse if (dent == phba->debug_writeRef)\n\t\tcnt = scnprintf(cbuf, 32, \"%u\\n\", phba->lpfc_injerr_wref_cnt);\n\telse if (dent == phba->debug_readGuard)\n\t\tcnt = scnprintf(cbuf, 32, \"%u\\n\", phba->lpfc_injerr_rgrd_cnt);\n\telse if (dent == phba->debug_readApp)\n\t\tcnt = scnprintf(cbuf, 32, \"%u\\n\", phba->lpfc_injerr_rapp_cnt);\n\telse if (dent == phba->debug_readRef)\n\t\tcnt = scnprintf(cbuf, 32, \"%u\\n\", phba->lpfc_injerr_rref_cnt);\n\telse if (dent == phba->debug_InjErrNPortID)\n\t\tcnt = scnprintf(cbuf, 32, \"0x%06x\\n\",\n\t\t\t\tphba->lpfc_injerr_nportid);\n\telse if (dent == phba->debug_InjErrWWPN) {\n\t\tmemcpy(&tmp, &phba->lpfc_injerr_wwpn, sizeof(struct lpfc_name));\n\t\ttmp = cpu_to_be64(tmp);\n\t\tcnt = scnprintf(cbuf, 32, \"0x%016llx\\n\", tmp);\n\t} else if (dent == phba->debug_InjErrLBA) {\n\t\tif (phba->lpfc_injerr_lba == (sector_t)(-1))\n\t\t\tcnt = scnprintf(cbuf, 32, \"off\\n\");\n\t\telse\n\t\t\tcnt = scnprintf(cbuf, 32, \"0x%llx\\n\",\n\t\t\t\t (uint64_t) phba->lpfc_injerr_lba);\n\t} else\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t \"0547 Unknown debugfs error injection entry\\n\");\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, &cbuf, cnt);\n}\n\nstatic ssize_t\nlpfc_debugfs_dif_err_write(struct file *file, const char __user *buf,\n\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct dentry *dent = file->f_path.dentry;\n\tstruct lpfc_hba *phba = file->private_data;\n\tchar dstbuf[33];\n\tuint64_t tmp = 0;\n\tint size;\n\n\tmemset(dstbuf, 0, 33);\n\tsize = (nbytes < 32) ? nbytes : 32;\n\tif (copy_from_user(dstbuf, buf, size))\n\t\treturn -EFAULT;\n\n\tif (dent == phba->debug_InjErrLBA) {\n\t\tif ((dstbuf[0] == 'o') && (dstbuf[1] == 'f') &&\n\t\t    (dstbuf[2] == 'f'))\n\t\t\ttmp = (uint64_t)(-1);\n\t}\n\n\tif ((tmp == 0) && (kstrtoull(dstbuf, 0, &tmp)))\n\t\treturn -EINVAL;\n\n\tif (dent == phba->debug_writeGuard)\n\t\tphba->lpfc_injerr_wgrd_cnt = (uint32_t)tmp;\n\telse if (dent == phba->debug_writeApp)\n\t\tphba->lpfc_injerr_wapp_cnt = (uint32_t)tmp;\n\telse if (dent == phba->debug_writeRef)\n\t\tphba->lpfc_injerr_wref_cnt = (uint32_t)tmp;\n\telse if (dent == phba->debug_readGuard)\n\t\tphba->lpfc_injerr_rgrd_cnt = (uint32_t)tmp;\n\telse if (dent == phba->debug_readApp)\n\t\tphba->lpfc_injerr_rapp_cnt = (uint32_t)tmp;\n\telse if (dent == phba->debug_readRef)\n\t\tphba->lpfc_injerr_rref_cnt = (uint32_t)tmp;\n\telse if (dent == phba->debug_InjErrLBA)\n\t\tphba->lpfc_injerr_lba = (sector_t)tmp;\n\telse if (dent == phba->debug_InjErrNPortID)\n\t\tphba->lpfc_injerr_nportid = (uint32_t)(tmp & Mask_DID);\n\telse if (dent == phba->debug_InjErrWWPN) {\n\t\ttmp = cpu_to_be64(tmp);\n\t\tmemcpy(&phba->lpfc_injerr_wwpn, &tmp, sizeof(struct lpfc_name));\n\t} else\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t \"0548 Unknown debugfs error injection entry\\n\");\n\n\treturn nbytes;\n}\n\nstatic int\nlpfc_debugfs_dif_err_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\n \nstatic int\nlpfc_debugfs_nodelist_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_vport *vport = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t \n\tdebug->buffer = kmalloc(LPFC_NODELIST_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_nodelist_data(vport, debug->buffer,\n\t\tLPFC_NODELIST_SIZE);\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\n \nstatic loff_t\nlpfc_debugfs_lseek(struct file *file, loff_t off, int whence)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\treturn fixed_size_llseek(file, off, whence, debug->len);\n}\n\n \nstatic ssize_t\nlpfc_debugfs_read(struct file *file, char __user *buf,\n\t\t  size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, debug->buffer,\n\t\t\t\t       debug->len);\n}\n\n \nstatic int\nlpfc_debugfs_release(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\n\tkfree(debug->buffer);\n\tkfree(debug);\n\n\treturn 0;\n}\n\n \nstatic ssize_t\nlpfc_debugfs_multixripools_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tchar mybuf[64];\n\tchar *pbuf;\n\tu32 i;\n\tu32 hwq_count;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tstruct lpfc_multixri_pool *multixri_pool;\n\n\tif (nbytes > sizeof(mybuf) - 1)\n\t\tnbytes = sizeof(mybuf) - 1;\n\n\tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"clear\", strlen(\"clear\"))) == 0) {\n\t\thwq_count = phba->cfg_hdw_queue;\n\t\tfor (i = 0; i < hwq_count; i++) {\n\t\t\tqp = &phba->sli4_hba.hdwq[i];\n\t\t\tmultixri_pool = qp->p_multixri_pool;\n\t\t\tif (!multixri_pool)\n\t\t\t\tcontinue;\n\n\t\t\tqp->empty_io_bufs = 0;\n\t\t\tmultixri_pool->pbl_empty_count = 0;\n#ifdef LPFC_MXP_STAT\n\t\t\tmultixri_pool->above_limit_count = 0;\n\t\t\tmultixri_pool->below_limit_count = 0;\n\t\t\tmultixri_pool->stat_max_hwm = 0;\n\t\t\tmultixri_pool->local_pbl_hit_count = 0;\n\t\t\tmultixri_pool->other_pbl_hit_count = 0;\n\n\t\t\tmultixri_pool->stat_pbl_count = 0;\n\t\t\tmultixri_pool->stat_pvt_count = 0;\n\t\t\tmultixri_pool->stat_busy_count = 0;\n\t\t\tmultixri_pool->stat_snapshot_taken = 0;\n#endif\n\t\t}\n\t\treturn strlen(pbuf);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nlpfc_debugfs_nvmestat_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_vport *vport = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t  \n\tdebug->buffer = kmalloc(LPFC_NVMESTAT_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_nvmestat_data(vport, debug->buffer,\n\t\tLPFC_NVMESTAT_SIZE);\n\n\tdebug->i_private = inode->i_private;\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_debugfs_nvmestat_write(struct file *file, const char __user *buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_nvmet_tgtport *tgtp;\n\tchar mybuf[64];\n\tchar *pbuf;\n\n\tif (!phba->targetport)\n\t\treturn -ENXIO;\n\n\tif (nbytes > sizeof(mybuf) - 1)\n\t\tnbytes = sizeof(mybuf) - 1;\n\n\tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\ttgtp = (struct lpfc_nvmet_tgtport *)phba->targetport->private;\n\tif ((strncmp(pbuf, \"reset\", strlen(\"reset\")) == 0) ||\n\t    (strncmp(pbuf, \"zero\", strlen(\"zero\")) == 0)) {\n\t\tatomic_set(&tgtp->rcv_ls_req_in, 0);\n\t\tatomic_set(&tgtp->rcv_ls_req_out, 0);\n\t\tatomic_set(&tgtp->rcv_ls_req_drop, 0);\n\t\tatomic_set(&tgtp->xmt_ls_abort, 0);\n\t\tatomic_set(&tgtp->xmt_ls_abort_cmpl, 0);\n\t\tatomic_set(&tgtp->xmt_ls_rsp, 0);\n\t\tatomic_set(&tgtp->xmt_ls_drop, 0);\n\t\tatomic_set(&tgtp->xmt_ls_rsp_error, 0);\n\t\tatomic_set(&tgtp->xmt_ls_rsp_cmpl, 0);\n\n\t\tatomic_set(&tgtp->rcv_fcp_cmd_in, 0);\n\t\tatomic_set(&tgtp->rcv_fcp_cmd_out, 0);\n\t\tatomic_set(&tgtp->rcv_fcp_cmd_drop, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_drop, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_read_rsp, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_read, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_write, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_rsp, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_release, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_rsp_cmpl, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_rsp_error, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_rsp_drop, 0);\n\n\t\tatomic_set(&tgtp->xmt_fcp_abort, 0);\n\t\tatomic_set(&tgtp->xmt_fcp_abort_cmpl, 0);\n\t\tatomic_set(&tgtp->xmt_abort_sol, 0);\n\t\tatomic_set(&tgtp->xmt_abort_unsol, 0);\n\t\tatomic_set(&tgtp->xmt_abort_rsp, 0);\n\t\tatomic_set(&tgtp->xmt_abort_rsp_error, 0);\n\t}\n\treturn nbytes;\n}\n\nstatic int\nlpfc_debugfs_scsistat_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_vport *vport = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t  \n\tdebug->buffer = kzalloc(LPFC_SCSISTAT_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_scsistat_data(vport, debug->buffer,\n\t\tLPFC_SCSISTAT_SIZE);\n\n\tdebug->i_private = inode->i_private;\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_debugfs_scsistat_write(struct file *file, const char __user *buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;\n\tstruct lpfc_hba *phba = vport->phba;\n\tchar mybuf[6] = {0};\n\tint i;\n\n\tif (copy_from_user(mybuf, buf, (nbytes >= sizeof(mybuf)) ?\n\t\t\t\t       (sizeof(mybuf) - 1) : nbytes))\n\t\treturn -EFAULT;\n\n\tif ((strncmp(&mybuf[0], \"reset\", strlen(\"reset\")) == 0) ||\n\t    (strncmp(&mybuf[0], \"zero\", strlen(\"zero\")) == 0)) {\n\t\tfor (i = 0; i < phba->cfg_hdw_queue; i++) {\n\t\t\tmemset(&phba->sli4_hba.hdwq[i].scsi_cstat, 0,\n\t\t\t       sizeof(phba->sli4_hba.hdwq[i].scsi_cstat));\n\t\t}\n\t}\n\n\treturn nbytes;\n}\n\nstatic int\nlpfc_debugfs_ioktime_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_vport *vport = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t  \n\tdebug->buffer = kmalloc(LPFC_IOKTIME_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_ioktime_data(vport, debug->buffer,\n\t\tLPFC_IOKTIME_SIZE);\n\n\tdebug->i_private = inode->i_private;\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_debugfs_ioktime_write(struct file *file, const char __user *buf,\n\t\t\t   size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tchar mybuf[64];\n\tchar *pbuf;\n\n\tif (nbytes > sizeof(mybuf) - 1)\n\t\tnbytes = sizeof(mybuf) - 1;\n\n\tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"on\", sizeof(\"on\") - 1) == 0)) {\n\t\tphba->ktime_data_samples = 0;\n\t\tphba->ktime_status_samples = 0;\n\t\tphba->ktime_seg1_total = 0;\n\t\tphba->ktime_seg1_max = 0;\n\t\tphba->ktime_seg1_min = 0xffffffff;\n\t\tphba->ktime_seg2_total = 0;\n\t\tphba->ktime_seg2_max = 0;\n\t\tphba->ktime_seg2_min = 0xffffffff;\n\t\tphba->ktime_seg3_total = 0;\n\t\tphba->ktime_seg3_max = 0;\n\t\tphba->ktime_seg3_min = 0xffffffff;\n\t\tphba->ktime_seg4_total = 0;\n\t\tphba->ktime_seg4_max = 0;\n\t\tphba->ktime_seg4_min = 0xffffffff;\n\t\tphba->ktime_seg5_total = 0;\n\t\tphba->ktime_seg5_max = 0;\n\t\tphba->ktime_seg5_min = 0xffffffff;\n\t\tphba->ktime_seg6_total = 0;\n\t\tphba->ktime_seg6_max = 0;\n\t\tphba->ktime_seg6_min = 0xffffffff;\n\t\tphba->ktime_seg7_total = 0;\n\t\tphba->ktime_seg7_max = 0;\n\t\tphba->ktime_seg7_min = 0xffffffff;\n\t\tphba->ktime_seg8_total = 0;\n\t\tphba->ktime_seg8_max = 0;\n\t\tphba->ktime_seg8_min = 0xffffffff;\n\t\tphba->ktime_seg9_total = 0;\n\t\tphba->ktime_seg9_max = 0;\n\t\tphba->ktime_seg9_min = 0xffffffff;\n\t\tphba->ktime_seg10_total = 0;\n\t\tphba->ktime_seg10_max = 0;\n\t\tphba->ktime_seg10_min = 0xffffffff;\n\n\t\tphba->ktime_on = 1;\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"off\",\n\t\t   sizeof(\"off\") - 1) == 0)) {\n\t\tphba->ktime_on = 0;\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"zero\",\n\t\t   sizeof(\"zero\") - 1) == 0)) {\n\t\tphba->ktime_data_samples = 0;\n\t\tphba->ktime_status_samples = 0;\n\t\tphba->ktime_seg1_total = 0;\n\t\tphba->ktime_seg1_max = 0;\n\t\tphba->ktime_seg1_min = 0xffffffff;\n\t\tphba->ktime_seg2_total = 0;\n\t\tphba->ktime_seg2_max = 0;\n\t\tphba->ktime_seg2_min = 0xffffffff;\n\t\tphba->ktime_seg3_total = 0;\n\t\tphba->ktime_seg3_max = 0;\n\t\tphba->ktime_seg3_min = 0xffffffff;\n\t\tphba->ktime_seg4_total = 0;\n\t\tphba->ktime_seg4_max = 0;\n\t\tphba->ktime_seg4_min = 0xffffffff;\n\t\tphba->ktime_seg5_total = 0;\n\t\tphba->ktime_seg5_max = 0;\n\t\tphba->ktime_seg5_min = 0xffffffff;\n\t\tphba->ktime_seg6_total = 0;\n\t\tphba->ktime_seg6_max = 0;\n\t\tphba->ktime_seg6_min = 0xffffffff;\n\t\tphba->ktime_seg7_total = 0;\n\t\tphba->ktime_seg7_max = 0;\n\t\tphba->ktime_seg7_min = 0xffffffff;\n\t\tphba->ktime_seg8_total = 0;\n\t\tphba->ktime_seg8_max = 0;\n\t\tphba->ktime_seg8_min = 0xffffffff;\n\t\tphba->ktime_seg9_total = 0;\n\t\tphba->ktime_seg9_max = 0;\n\t\tphba->ktime_seg9_min = 0xffffffff;\n\t\tphba->ktime_seg10_total = 0;\n\t\tphba->ktime_seg10_max = 0;\n\t\tphba->ktime_seg10_min = 0xffffffff;\n\t\treturn strlen(pbuf);\n\t}\n\treturn -EINVAL;\n}\n\nstatic int\nlpfc_debugfs_nvmeio_trc_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_hba *phba = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t  \n\tdebug->buffer = kmalloc(LPFC_NVMEIO_TRC_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_nvmeio_trc_data(phba, debug->buffer,\n\t\tLPFC_NVMEIO_TRC_SIZE);\n\n\tdebug->i_private = inode->i_private;\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_debugfs_nvmeio_trc_write(struct file *file, const char __user *buf,\n\t\t\t      size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tint i;\n\tunsigned long sz;\n\tchar mybuf[64];\n\tchar *pbuf;\n\n\tif (nbytes > sizeof(mybuf) - 1)\n\t\tnbytes = sizeof(mybuf) - 1;\n\n\tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"off\", sizeof(\"off\") - 1) == 0)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0570 nvmeio_trc_off\\n\");\n\t\tphba->nvmeio_trc_output_idx = 0;\n\t\tphba->nvmeio_trc_on = 0;\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"on\", sizeof(\"on\") - 1) == 0)) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0571 nvmeio_trc_on\\n\");\n\t\tphba->nvmeio_trc_output_idx = 0;\n\t\tphba->nvmeio_trc_on = 1;\n\t\treturn strlen(pbuf);\n\t}\n\n\t \n\tif (phba->nvmeio_trc_on != 0)\n\t\treturn -EINVAL;\n\n\t \n\ti = kstrtoul(pbuf, 0, &sz);\n\tif (i)\n\t\treturn -EINVAL;\n\tphba->nvmeio_trc_size = (uint32_t)sz;\n\n\t \n\ti = 0;\n\twhile (sz > 1) {\n\t\tsz = sz >> 1;\n\t\ti++;\n\t}\n\tsz = (1 << i);\n\tif (phba->nvmeio_trc_size != sz)\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0572 nvmeio_trc_size changed to %ld\\n\",\n\t\t\t\tsz);\n\tphba->nvmeio_trc_size = (uint32_t)sz;\n\n\t \n\tkfree(phba->nvmeio_trc);\n\n\t \n\tphba->nvmeio_trc = kzalloc((sizeof(struct lpfc_debugfs_nvmeio_trc) *\n\t\t\t\t    sz), GFP_KERNEL);\n\tif (!phba->nvmeio_trc) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"0573 Cannot create debugfs \"\n\t\t\t\t\"nvmeio_trc buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&phba->nvmeio_trc_cnt, 0);\n\tphba->nvmeio_trc_on = 0;\n\tphba->nvmeio_trc_output_idx = 0;\n\n\treturn strlen(pbuf);\n}\n\nstatic int\nlpfc_debugfs_hdwqstat_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_vport *vport = inode->i_private;\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\t  \n\tdebug->buffer = kcalloc(1, LPFC_SCSISTAT_SIZE, GFP_KERNEL);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->len = lpfc_debugfs_hdwqstat_data(vport, debug->buffer,\n\t\t\t\t\t\tLPFC_SCSISTAT_SIZE);\n\n\tdebug->i_private = inode->i_private;\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_debugfs_hdwqstat_write(struct file *file, const char __user *buf,\n\t\t\t    size_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)debug->i_private;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_hdwq_stat *c_stat;\n\tchar mybuf[64];\n\tchar *pbuf;\n\tint i;\n\n\tif (nbytes > sizeof(mybuf) - 1)\n\t\tnbytes = sizeof(mybuf) - 1;\n\n\tmemset(mybuf, 0, sizeof(mybuf));\n\n\tif (copy_from_user(mybuf, buf, nbytes))\n\t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\n\tif ((strncmp(pbuf, \"on\", sizeof(\"on\") - 1) == 0)) {\n\t\tif (phba->nvmet_support)\n\t\t\tphba->hdwqstat_on |= LPFC_CHECK_NVMET_IO;\n\t\telse\n\t\t\tphba->hdwqstat_on |= (LPFC_CHECK_NVME_IO |\n\t\t\t\tLPFC_CHECK_SCSI_IO);\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"nvme_on\", sizeof(\"nvme_on\") - 1) == 0)) {\n\t\tif (phba->nvmet_support)\n\t\t\tphba->hdwqstat_on |= LPFC_CHECK_NVMET_IO;\n\t\telse\n\t\t\tphba->hdwqstat_on |= LPFC_CHECK_NVME_IO;\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"scsi_on\", sizeof(\"scsi_on\") - 1) == 0)) {\n\t\tif (!phba->nvmet_support)\n\t\t\tphba->hdwqstat_on |= LPFC_CHECK_SCSI_IO;\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"nvme_off\", sizeof(\"nvme_off\") - 1) == 0)) {\n\t\tphba->hdwqstat_on &= ~(LPFC_CHECK_NVME_IO |\n\t\t\t\t       LPFC_CHECK_NVMET_IO);\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"scsi_off\", sizeof(\"scsi_off\") - 1) == 0)) {\n\t\tphba->hdwqstat_on &= ~LPFC_CHECK_SCSI_IO;\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"off\",\n\t\t   sizeof(\"off\") - 1) == 0)) {\n\t\tphba->hdwqstat_on = LPFC_CHECK_OFF;\n\t\treturn strlen(pbuf);\n\t} else if ((strncmp(pbuf, \"zero\",\n\t\t   sizeof(\"zero\") - 1) == 0)) {\n\t\tfor_each_present_cpu(i) {\n\t\t\tc_stat = per_cpu_ptr(phba->sli4_hba.c_stat, i);\n\t\t\tc_stat->xmt_io = 0;\n\t\t\tc_stat->cmpl_io = 0;\n\t\t\tc_stat->rcv_io = 0;\n\t\t}\n\t\treturn strlen(pbuf);\n\t}\n\treturn -EINVAL;\n}\n\n \n\n \nstatic int lpfc_idiag_cmd_get(const char __user *buf, size_t nbytes,\n\t\t\t      struct lpfc_idiag_cmd *idiag_cmd)\n{\n\tchar mybuf[64];\n\tchar *pbuf, *step_str;\n\tint i;\n\tsize_t bsize;\n\n\tmemset(mybuf, 0, sizeof(mybuf));\n\tmemset(idiag_cmd, 0, sizeof(*idiag_cmd));\n\tbsize = min(nbytes, (sizeof(mybuf)-1));\n\n\tif (copy_from_user(mybuf, buf, bsize))\n\t\treturn -EFAULT;\n\tpbuf = &mybuf[0];\n\tstep_str = strsep(&pbuf, \"\\t \");\n\n\t \n\tif (!step_str)\n\t\treturn -EINVAL;\n\n\tidiag_cmd->opcode = simple_strtol(step_str, NULL, 0);\n\tif (idiag_cmd->opcode == 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < LPFC_IDIAG_CMD_DATA_SIZE; i++) {\n\t\tstep_str = strsep(&pbuf, \"\\t \");\n\t\tif (!step_str)\n\t\t\treturn i;\n\t\tidiag_cmd->data[i] = simple_strtol(step_str, NULL, 0);\n\t}\n\treturn i;\n}\n\n \nstatic int\nlpfc_idiag_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_debug *debug;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\treturn -ENOMEM;\n\n\tdebug->i_private = inode->i_private;\n\tdebug->buffer = NULL;\n\tfile->private_data = debug;\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_idiag_release(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\n\t \n\tkfree(debug->buffer);\n\tkfree(debug);\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_idiag_cmd_release(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\n\tif (debug->op == LPFC_IDIAG_OP_WR) {\n\t\tswitch (idiag.cmd.opcode) {\n\t\tcase LPFC_IDIAG_CMD_PCICFG_WR:\n\t\tcase LPFC_IDIAG_CMD_PCICFG_ST:\n\t\tcase LPFC_IDIAG_CMD_PCICFG_CL:\n\t\tcase LPFC_IDIAG_CMD_QUEACC_WR:\n\t\tcase LPFC_IDIAG_CMD_QUEACC_ST:\n\t\tcase LPFC_IDIAG_CMD_QUEACC_CL:\n\t\t\tmemset(&idiag, 0, sizeof(idiag));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tkfree(debug->buffer);\n\tkfree(debug);\n\n\treturn 0;\n}\n\n \nstatic ssize_t\nlpfc_idiag_pcicfg_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t       loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tint offset_label, offset, len = 0, index = LPFC_PCI_CFG_RD_SIZE;\n\tint where, count;\n\tchar *pbuffer;\n\tstruct pci_dev *pdev;\n\tuint32_t u32val;\n\tuint16_t u16val;\n\tuint8_t u8val;\n\n\tpdev = phba->pcidev;\n\tif (!pdev)\n\t\treturn 0;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_RD;\n\n\tif (!debug->buffer)\n\t\tdebug->buffer = kmalloc(LPFC_PCI_CFG_SIZE, GFP_KERNEL);\n\tif (!debug->buffer)\n\t\treturn 0;\n\tpbuffer = debug->buffer;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_RD) {\n\t\twhere = idiag.cmd.data[IDIAG_PCICFG_WHERE_INDX];\n\t\tcount = idiag.cmd.data[IDIAG_PCICFG_COUNT_INDX];\n\t} else\n\t\treturn 0;\n\n\t \n\tswitch (count) {\n\tcase SIZE_U8:  \n\t\tpci_read_config_byte(pdev, where, &u8val);\n\t\tlen += scnprintf(pbuffer+len, LPFC_PCI_CFG_SIZE-len,\n\t\t\t\t\"%03x: %02x\\n\", where, u8val);\n\t\tbreak;\n\tcase SIZE_U16:  \n\t\tpci_read_config_word(pdev, where, &u16val);\n\t\tlen += scnprintf(pbuffer+len, LPFC_PCI_CFG_SIZE-len,\n\t\t\t\t\"%03x: %04x\\n\", where, u16val);\n\t\tbreak;\n\tcase SIZE_U32:  \n\t\tpci_read_config_dword(pdev, where, &u32val);\n\t\tlen += scnprintf(pbuffer+len, LPFC_PCI_CFG_SIZE-len,\n\t\t\t\t\"%03x: %08x\\n\", where, u32val);\n\t\tbreak;\n\tcase LPFC_PCI_CFG_BROWSE:  \n\t\tgoto pcicfg_browse;\n\tdefault:\n\t\t \n\t\tlen = 0;\n\t\tbreak;\n\t}\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n\npcicfg_browse:\n\n\t \n\toffset_label = idiag.offset.last_rd;\n\toffset = offset_label;\n\n\t \n\tlen += scnprintf(pbuffer+len, LPFC_PCI_CFG_SIZE-len,\n\t\t\t\"%03x: \", offset_label);\n\twhile (index > 0) {\n\t\tpci_read_config_dword(pdev, offset, &u32val);\n\t\tlen += scnprintf(pbuffer+len, LPFC_PCI_CFG_SIZE-len,\n\t\t\t\t\"%08x \", u32val);\n\t\toffset += sizeof(uint32_t);\n\t\tif (offset >= LPFC_PCI_CFG_SIZE) {\n\t\t\tlen += scnprintf(pbuffer+len,\n\t\t\t\t\tLPFC_PCI_CFG_SIZE-len, \"\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tindex -= sizeof(uint32_t);\n\t\tif (!index)\n\t\t\tlen += scnprintf(pbuffer+len, LPFC_PCI_CFG_SIZE-len,\n\t\t\t\t\t\"\\n\");\n\t\telse if (!(index % (8 * sizeof(uint32_t)))) {\n\t\t\toffset_label += (8 * sizeof(uint32_t));\n\t\t\tlen += scnprintf(pbuffer+len, LPFC_PCI_CFG_SIZE-len,\n\t\t\t\t\t\"\\n%03x: \", offset_label);\n\t\t}\n\t}\n\n\t \n\tif (index == 0) {\n\t\tidiag.offset.last_rd += LPFC_PCI_CFG_RD_SIZE;\n\t\tif (idiag.offset.last_rd >= LPFC_PCI_CFG_SIZE)\n\t\t\tidiag.offset.last_rd = 0;\n\t} else\n\t\tidiag.offset.last_rd = 0;\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n}\n\n \nstatic ssize_t\nlpfc_idiag_pcicfg_write(struct file *file, const char __user *buf,\n\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tuint32_t where, value, count;\n\tuint32_t u32val;\n\tuint16_t u16val;\n\tuint8_t u8val;\n\tstruct pci_dev *pdev;\n\tint rc;\n\n\tpdev = phba->pcidev;\n\tif (!pdev)\n\t\treturn -EFAULT;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_WR;\n\n\trc = lpfc_idiag_cmd_get(buf, nbytes, &idiag.cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_RD) {\n\t\t \n\t\tif (rc != LPFC_PCI_CFG_RD_CMD_ARG)\n\t\t\tgoto error_out;\n\t\t \n\t\twhere = idiag.cmd.data[IDIAG_PCICFG_WHERE_INDX];\n\t\tcount = idiag.cmd.data[IDIAG_PCICFG_COUNT_INDX];\n\t\tif (count == LPFC_PCI_CFG_BROWSE) {\n\t\t\tif (where % sizeof(uint32_t))\n\t\t\t\tgoto error_out;\n\t\t\t \n\t\t\tidiag.offset.last_rd = where;\n\t\t} else if ((count != sizeof(uint8_t)) &&\n\t\t\t   (count != sizeof(uint16_t)) &&\n\t\t\t   (count != sizeof(uint32_t)))\n\t\t\tgoto error_out;\n\t\tif (count == sizeof(uint8_t)) {\n\t\t\tif (where > LPFC_PCI_CFG_SIZE - sizeof(uint8_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (where % sizeof(uint8_t))\n\t\t\t\tgoto error_out;\n\t\t}\n\t\tif (count == sizeof(uint16_t)) {\n\t\t\tif (where > LPFC_PCI_CFG_SIZE - sizeof(uint16_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (where % sizeof(uint16_t))\n\t\t\t\tgoto error_out;\n\t\t}\n\t\tif (count == sizeof(uint32_t)) {\n\t\t\tif (where > LPFC_PCI_CFG_SIZE - sizeof(uint32_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (where % sizeof(uint32_t))\n\t\t\t\tgoto error_out;\n\t\t}\n\t} else if (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_WR ||\n\t\t   idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_ST ||\n\t\t   idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_CL) {\n\t\t \n\t\tif (rc != LPFC_PCI_CFG_WR_CMD_ARG)\n\t\t\tgoto error_out;\n\t\t \n\t\twhere = idiag.cmd.data[IDIAG_PCICFG_WHERE_INDX];\n\t\tcount = idiag.cmd.data[IDIAG_PCICFG_COUNT_INDX];\n\t\tvalue = idiag.cmd.data[IDIAG_PCICFG_VALUE_INDX];\n\t\t \n\t\tif ((count != sizeof(uint8_t)) &&\n\t\t    (count != sizeof(uint16_t)) &&\n\t\t    (count != sizeof(uint32_t)))\n\t\t\tgoto error_out;\n\t\tif (count == sizeof(uint8_t)) {\n\t\t\tif (where > LPFC_PCI_CFG_SIZE - sizeof(uint8_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (where % sizeof(uint8_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_WR)\n\t\t\t\tpci_write_config_byte(pdev, where,\n\t\t\t\t\t\t      (uint8_t)value);\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_ST) {\n\t\t\t\trc = pci_read_config_byte(pdev, where, &u8val);\n\t\t\t\tif (!rc) {\n\t\t\t\t\tu8val |= (uint8_t)value;\n\t\t\t\t\tpci_write_config_byte(pdev, where,\n\t\t\t\t\t\t\t      u8val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_CL) {\n\t\t\t\trc = pci_read_config_byte(pdev, where, &u8val);\n\t\t\t\tif (!rc) {\n\t\t\t\t\tu8val &= (uint8_t)(~value);\n\t\t\t\t\tpci_write_config_byte(pdev, where,\n\t\t\t\t\t\t\t      u8val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count == sizeof(uint16_t)) {\n\t\t\tif (where > LPFC_PCI_CFG_SIZE - sizeof(uint16_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (where % sizeof(uint16_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_WR)\n\t\t\t\tpci_write_config_word(pdev, where,\n\t\t\t\t\t\t      (uint16_t)value);\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_ST) {\n\t\t\t\trc = pci_read_config_word(pdev, where, &u16val);\n\t\t\t\tif (!rc) {\n\t\t\t\t\tu16val |= (uint16_t)value;\n\t\t\t\t\tpci_write_config_word(pdev, where,\n\t\t\t\t\t\t\t      u16val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_CL) {\n\t\t\t\trc = pci_read_config_word(pdev, where, &u16val);\n\t\t\t\tif (!rc) {\n\t\t\t\t\tu16val &= (uint16_t)(~value);\n\t\t\t\t\tpci_write_config_word(pdev, where,\n\t\t\t\t\t\t\t      u16val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count == sizeof(uint32_t)) {\n\t\t\tif (where > LPFC_PCI_CFG_SIZE - sizeof(uint32_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (where % sizeof(uint32_t))\n\t\t\t\tgoto error_out;\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_WR)\n\t\t\t\tpci_write_config_dword(pdev, where, value);\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_ST) {\n\t\t\t\trc = pci_read_config_dword(pdev, where,\n\t\t\t\t\t\t\t   &u32val);\n\t\t\t\tif (!rc) {\n\t\t\t\t\tu32val |= value;\n\t\t\t\t\tpci_write_config_dword(pdev, where,\n\t\t\t\t\t\t\t       u32val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_PCICFG_CL) {\n\t\t\t\trc = pci_read_config_dword(pdev, where,\n\t\t\t\t\t\t\t   &u32val);\n\t\t\t\tif (!rc) {\n\t\t\t\t\tu32val &= ~value;\n\t\t\t\t\tpci_write_config_dword(pdev, where,\n\t\t\t\t\t\t\t       u32val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else\n\t\t \n\t\tgoto error_out;\n\n\treturn nbytes;\nerror_out:\n\tmemset(&idiag, 0, sizeof(idiag));\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t\nlpfc_idiag_baracc_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t       loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tint offset_label, offset, offset_run, len = 0, index;\n\tint bar_num, acc_range, bar_size;\n\tchar *pbuffer;\n\tvoid __iomem *mem_mapped_bar;\n\tuint32_t if_type;\n\tstruct pci_dev *pdev;\n\tuint32_t u32val;\n\n\tpdev = phba->pcidev;\n\tif (!pdev)\n\t\treturn 0;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_RD;\n\n\tif (!debug->buffer)\n\t\tdebug->buffer = kmalloc(LPFC_PCI_BAR_RD_BUF_SIZE, GFP_KERNEL);\n\tif (!debug->buffer)\n\t\treturn 0;\n\tpbuffer = debug->buffer;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_BARACC_RD) {\n\t\tbar_num   = idiag.cmd.data[IDIAG_BARACC_BAR_NUM_INDX];\n\t\toffset    = idiag.cmd.data[IDIAG_BARACC_OFF_SET_INDX];\n\t\tacc_range = idiag.cmd.data[IDIAG_BARACC_ACC_MOD_INDX];\n\t\tbar_size = idiag.cmd.data[IDIAG_BARACC_BAR_SZE_INDX];\n\t} else\n\t\treturn 0;\n\n\tif (acc_range == 0)\n\t\treturn 0;\n\n\tif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\n\tif (if_type == LPFC_SLI_INTF_IF_TYPE_0) {\n\t\tif (bar_num == IDIAG_BARACC_BAR_0)\n\t\t\tmem_mapped_bar = phba->sli4_hba.conf_regs_memmap_p;\n\t\telse if (bar_num == IDIAG_BARACC_BAR_1)\n\t\t\tmem_mapped_bar = phba->sli4_hba.ctrl_regs_memmap_p;\n\t\telse if (bar_num == IDIAG_BARACC_BAR_2)\n\t\t\tmem_mapped_bar = phba->sli4_hba.drbl_regs_memmap_p;\n\t\telse\n\t\t\treturn 0;\n\t} else if (if_type == LPFC_SLI_INTF_IF_TYPE_2) {\n\t\tif (bar_num == IDIAG_BARACC_BAR_0)\n\t\t\tmem_mapped_bar = phba->sli4_hba.conf_regs_memmap_p;\n\t\telse\n\t\t\treturn 0;\n\t} else\n\t\treturn 0;\n\n\t \n\tif (acc_range == SINGLE_WORD) {\n\t\toffset_run = offset;\n\t\tu32val = readl(mem_mapped_bar + offset_run);\n\t\tlen += scnprintf(pbuffer+len, LPFC_PCI_BAR_RD_BUF_SIZE-len,\n\t\t\t\t\"%05x: %08x\\n\", offset_run, u32val);\n\t} else\n\t\tgoto baracc_browse;\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n\nbaracc_browse:\n\n\t \n\toffset_label = idiag.offset.last_rd;\n\toffset_run = offset_label;\n\n\t \n\tlen += scnprintf(pbuffer+len, LPFC_PCI_BAR_RD_BUF_SIZE-len,\n\t\t\t\"%05x: \", offset_label);\n\tindex = LPFC_PCI_BAR_RD_SIZE;\n\twhile (index > 0) {\n\t\tu32val = readl(mem_mapped_bar + offset_run);\n\t\tlen += scnprintf(pbuffer+len, LPFC_PCI_BAR_RD_BUF_SIZE-len,\n\t\t\t\t\"%08x \", u32val);\n\t\toffset_run += sizeof(uint32_t);\n\t\tif (acc_range == LPFC_PCI_BAR_BROWSE) {\n\t\t\tif (offset_run >= bar_size) {\n\t\t\t\tlen += scnprintf(pbuffer+len,\n\t\t\t\t\tLPFC_PCI_BAR_RD_BUF_SIZE-len, \"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (offset_run >= offset +\n\t\t\t    (acc_range * sizeof(uint32_t))) {\n\t\t\t\tlen += scnprintf(pbuffer+len,\n\t\t\t\t\tLPFC_PCI_BAR_RD_BUF_SIZE-len, \"\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tindex -= sizeof(uint32_t);\n\t\tif (!index)\n\t\t\tlen += scnprintf(pbuffer+len,\n\t\t\t\t\tLPFC_PCI_BAR_RD_BUF_SIZE-len, \"\\n\");\n\t\telse if (!(index % (8 * sizeof(uint32_t)))) {\n\t\t\toffset_label += (8 * sizeof(uint32_t));\n\t\t\tlen += scnprintf(pbuffer+len,\n\t\t\t\t\tLPFC_PCI_BAR_RD_BUF_SIZE-len,\n\t\t\t\t\t\"\\n%05x: \", offset_label);\n\t\t}\n\t}\n\n\t \n\tif (index == 0) {\n\t\tidiag.offset.last_rd += LPFC_PCI_BAR_RD_SIZE;\n\t\tif (acc_range == LPFC_PCI_BAR_BROWSE) {\n\t\t\tif (idiag.offset.last_rd >= bar_size)\n\t\t\t\tidiag.offset.last_rd = 0;\n\t\t} else {\n\t\t\tif (offset_run >= offset +\n\t\t\t    (acc_range * sizeof(uint32_t)))\n\t\t\t\tidiag.offset.last_rd = offset;\n\t\t}\n\t} else {\n\t\tif (acc_range == LPFC_PCI_BAR_BROWSE)\n\t\t\tidiag.offset.last_rd = 0;\n\t\telse\n\t\t\tidiag.offset.last_rd = offset;\n\t}\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n}\n\n \nstatic ssize_t\nlpfc_idiag_baracc_write(struct file *file, const char __user *buf,\n\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tuint32_t bar_num, bar_size, offset, value, acc_range;\n\tstruct pci_dev *pdev;\n\tvoid __iomem *mem_mapped_bar;\n\tuint32_t if_type;\n\tuint32_t u32val;\n\tint rc;\n\n\tpdev = phba->pcidev;\n\tif (!pdev)\n\t\treturn -EFAULT;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_WR;\n\n\trc = lpfc_idiag_cmd_get(buf, nbytes, &idiag.cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif_type = bf_get(lpfc_sli_intf_if_type, &phba->sli4_hba.sli_intf);\n\tbar_num = idiag.cmd.data[IDIAG_BARACC_BAR_NUM_INDX];\n\n\tif (if_type == LPFC_SLI_INTF_IF_TYPE_0) {\n\t\tif ((bar_num != IDIAG_BARACC_BAR_0) &&\n\t\t    (bar_num != IDIAG_BARACC_BAR_1) &&\n\t\t    (bar_num != IDIAG_BARACC_BAR_2))\n\t\t\tgoto error_out;\n\t} else if (if_type == LPFC_SLI_INTF_IF_TYPE_2) {\n\t\tif (bar_num != IDIAG_BARACC_BAR_0)\n\t\t\tgoto error_out;\n\t} else\n\t\tgoto error_out;\n\n\tif (if_type == LPFC_SLI_INTF_IF_TYPE_0) {\n\t\tif (bar_num == IDIAG_BARACC_BAR_0) {\n\t\t\tidiag.cmd.data[IDIAG_BARACC_BAR_SZE_INDX] =\n\t\t\t\tLPFC_PCI_IF0_BAR0_SIZE;\n\t\t\tmem_mapped_bar = phba->sli4_hba.conf_regs_memmap_p;\n\t\t} else if (bar_num == IDIAG_BARACC_BAR_1) {\n\t\t\tidiag.cmd.data[IDIAG_BARACC_BAR_SZE_INDX] =\n\t\t\t\tLPFC_PCI_IF0_BAR1_SIZE;\n\t\t\tmem_mapped_bar = phba->sli4_hba.ctrl_regs_memmap_p;\n\t\t} else if (bar_num == IDIAG_BARACC_BAR_2) {\n\t\t\tidiag.cmd.data[IDIAG_BARACC_BAR_SZE_INDX] =\n\t\t\t\tLPFC_PCI_IF0_BAR2_SIZE;\n\t\t\tmem_mapped_bar = phba->sli4_hba.drbl_regs_memmap_p;\n\t\t} else\n\t\t\tgoto error_out;\n\t} else if (if_type == LPFC_SLI_INTF_IF_TYPE_2) {\n\t\tif (bar_num == IDIAG_BARACC_BAR_0) {\n\t\t\tidiag.cmd.data[IDIAG_BARACC_BAR_SZE_INDX] =\n\t\t\t\tLPFC_PCI_IF2_BAR0_SIZE;\n\t\t\tmem_mapped_bar = phba->sli4_hba.conf_regs_memmap_p;\n\t\t} else\n\t\t\tgoto error_out;\n\t} else\n\t\tgoto error_out;\n\n\toffset = idiag.cmd.data[IDIAG_BARACC_OFF_SET_INDX];\n\tif (offset % sizeof(uint32_t))\n\t\tgoto error_out;\n\n\tbar_size = idiag.cmd.data[IDIAG_BARACC_BAR_SZE_INDX];\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_BARACC_RD) {\n\t\t \n\t\tif (rc != LPFC_PCI_BAR_RD_CMD_ARG)\n\t\t\tgoto error_out;\n\t\tacc_range = idiag.cmd.data[IDIAG_BARACC_ACC_MOD_INDX];\n\t\tif (acc_range == LPFC_PCI_BAR_BROWSE) {\n\t\t\tif (offset > bar_size - sizeof(uint32_t))\n\t\t\t\tgoto error_out;\n\t\t\t \n\t\t\tidiag.offset.last_rd = offset;\n\t\t} else if (acc_range > SINGLE_WORD) {\n\t\t\tif (offset + acc_range * sizeof(uint32_t) > bar_size)\n\t\t\t\tgoto error_out;\n\t\t\t \n\t\t\tidiag.offset.last_rd = offset;\n\t\t} else if (acc_range != SINGLE_WORD)\n\t\t\tgoto error_out;\n\t} else if (idiag.cmd.opcode == LPFC_IDIAG_CMD_BARACC_WR ||\n\t\t   idiag.cmd.opcode == LPFC_IDIAG_CMD_BARACC_ST ||\n\t\t   idiag.cmd.opcode == LPFC_IDIAG_CMD_BARACC_CL) {\n\t\t \n\t\tif (rc != LPFC_PCI_BAR_WR_CMD_ARG)\n\t\t\tgoto error_out;\n\t\t \n\t\tacc_range = SINGLE_WORD;\n\t\tvalue = idiag.cmd.data[IDIAG_BARACC_REG_VAL_INDX];\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_BARACC_WR) {\n\t\t\twritel(value, mem_mapped_bar + offset);\n\t\t\treadl(mem_mapped_bar + offset);\n\t\t}\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_BARACC_ST) {\n\t\t\tu32val = readl(mem_mapped_bar + offset);\n\t\t\tu32val |= value;\n\t\t\twritel(u32val, mem_mapped_bar + offset);\n\t\t\treadl(mem_mapped_bar + offset);\n\t\t}\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_BARACC_CL) {\n\t\t\tu32val = readl(mem_mapped_bar + offset);\n\t\t\tu32val &= ~value;\n\t\t\twritel(u32val, mem_mapped_bar + offset);\n\t\t\treadl(mem_mapped_bar + offset);\n\t\t}\n\t} else\n\t\t \n\t\tgoto error_out;\n\n\treturn nbytes;\nerror_out:\n\tmemset(&idiag, 0, sizeof(idiag));\n\treturn -EINVAL;\n}\n\nstatic int\n__lpfc_idiag_print_wq(struct lpfc_queue *qp, char *wqtype,\n\t\t\tchar *pbuffer, int len)\n{\n\tif (!qp)\n\t\treturn len;\n\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\t\\t%s WQ info: \", wqtype);\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"AssocCQID[%04d]: WQ-STAT[oflow:x%x posted:x%llx]\\n\",\n\t\t\tqp->assoc_qid, qp->q_cnt_1,\n\t\t\t(unsigned long long)qp->q_cnt_4);\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\t\\tWQID[%02d], QE-CNT[%04d], QE-SZ[%04d], \"\n\t\t\t\"HST-IDX[%04d], PRT-IDX[%04d], NTFI[%03d]\",\n\t\t\tqp->queue_id, qp->entry_count,\n\t\t\tqp->entry_size, qp->host_index,\n\t\t\tqp->hba_index, qp->notify_interval);\n\tlen +=  scnprintf(pbuffer + len,\n\t\t\tLPFC_QUE_INFO_GET_BUF_SIZE - len, \"\\n\");\n\treturn len;\n}\n\nstatic int\nlpfc_idiag_wqs_for_cq(struct lpfc_hba *phba, char *wqtype, char *pbuffer,\n\t\tint *len, int max_cnt, int cq_id)\n{\n\tstruct lpfc_queue *qp;\n\tint qidx;\n\n\tfor (qidx = 0; qidx < phba->cfg_hdw_queue; qidx++) {\n\t\tqp = phba->sli4_hba.hdwq[qidx].io_wq;\n\t\tif (qp->assoc_qid != cq_id)\n\t\t\tcontinue;\n\t\t*len = __lpfc_idiag_print_wq(qp, wqtype, pbuffer, *len);\n\t\tif (*len >= max_cnt)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int\n__lpfc_idiag_print_cq(struct lpfc_queue *qp, char *cqtype,\n\t\t\tchar *pbuffer, int len)\n{\n\tif (!qp)\n\t\treturn len;\n\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\t%s CQ info: \", cqtype);\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"AssocEQID[%02d]: CQ STAT[max:x%x relw:x%x \"\n\t\t\t\"xabt:x%x wq:x%llx]\\n\",\n\t\t\tqp->assoc_qid, qp->q_cnt_1, qp->q_cnt_2,\n\t\t\tqp->q_cnt_3, (unsigned long long)qp->q_cnt_4);\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\tCQID[%02d], QE-CNT[%04d], QE-SZ[%04d], \"\n\t\t\t\"HST-IDX[%04d], NTFI[%03d], PLMT[%03d]\",\n\t\t\tqp->queue_id, qp->entry_count,\n\t\t\tqp->entry_size, qp->host_index,\n\t\t\tqp->notify_interval, qp->max_proc_limit);\n\n\tlen +=  scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\n\");\n\n\treturn len;\n}\n\nstatic int\n__lpfc_idiag_print_rqpair(struct lpfc_queue *qp, struct lpfc_queue *datqp,\n\t\t\tchar *rqtype, char *pbuffer, int len)\n{\n\tif (!qp || !datqp)\n\t\treturn len;\n\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\t\\t%s RQ info: \", rqtype);\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"AssocCQID[%02d]: RQ-STAT[nopost:x%x nobuf:x%x \"\n\t\t\t\"posted:x%x rcv:x%llx]\\n\",\n\t\t\tqp->assoc_qid, qp->q_cnt_1, qp->q_cnt_2,\n\t\t\tqp->q_cnt_3, (unsigned long long)qp->q_cnt_4);\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\t\\tHQID[%02d], QE-CNT[%04d], QE-SZ[%04d], \"\n\t\t\t\"HST-IDX[%04d], PRT-IDX[%04d], NTFI[%03d]\\n\",\n\t\t\tqp->queue_id, qp->entry_count, qp->entry_size,\n\t\t\tqp->host_index, qp->hba_index, qp->notify_interval);\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\t\\tDQID[%02d], QE-CNT[%04d], QE-SZ[%04d], \"\n\t\t\t\"HST-IDX[%04d], PRT-IDX[%04d], NTFI[%03d]\\n\",\n\t\t\tdatqp->queue_id, datqp->entry_count,\n\t\t\tdatqp->entry_size, datqp->host_index,\n\t\t\tdatqp->hba_index, datqp->notify_interval);\n\treturn len;\n}\n\nstatic int\nlpfc_idiag_cqs_for_eq(struct lpfc_hba *phba, char *pbuffer,\n\t\tint *len, int max_cnt, int eqidx, int eq_id)\n{\n\tstruct lpfc_queue *qp;\n\tint rc;\n\n\tqp = phba->sli4_hba.hdwq[eqidx].io_cq;\n\n\t*len = __lpfc_idiag_print_cq(qp, \"IO\", pbuffer, *len);\n\n\t \n\tqp->CQ_max_cqe = 0;\n\n\tif (*len >= max_cnt)\n\t\treturn 1;\n\n\trc = lpfc_idiag_wqs_for_cq(phba, \"IO\", pbuffer, len,\n\t\t\t\t   max_cnt, qp->queue_id);\n\tif (rc)\n\t\treturn 1;\n\n\tif ((eqidx < phba->cfg_nvmet_mrq) && phba->nvmet_support) {\n\t\t \n\t\tqp = phba->sli4_hba.nvmet_cqset[eqidx];\n\t\t*len = __lpfc_idiag_print_cq(qp, \"NVMET CQset\", pbuffer, *len);\n\n\t\t \n\t\tqp->CQ_max_cqe = 0;\n\n\t\tif (*len >= max_cnt)\n\t\t\treturn 1;\n\n\t\t \n\t\tqp = phba->sli4_hba.nvmet_mrq_hdr[eqidx];\n\t\t*len = __lpfc_idiag_print_rqpair(qp,\n\t\t\t\tphba->sli4_hba.nvmet_mrq_data[eqidx],\n\t\t\t\t\"NVMET MRQ\", pbuffer, *len);\n\n\t\tif (*len >= max_cnt)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\n__lpfc_idiag_print_eq(struct lpfc_queue *qp, char *eqtype,\n\t\t\tchar *pbuffer, int len)\n{\n\tif (!qp)\n\t\treturn len;\n\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\n%s EQ info: EQ-STAT[max:x%x noE:x%x \"\n\t\t\t\"cqe_proc:x%x eqe_proc:x%llx eqd %d]\\n\",\n\t\t\teqtype, qp->q_cnt_1, qp->q_cnt_2, qp->q_cnt_3,\n\t\t\t(unsigned long long)qp->q_cnt_4, qp->q_mode);\n\tlen += scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"EQID[%02d], QE-CNT[%04d], QE-SZ[%04d], \"\n\t\t\t\"HST-IDX[%04d], NTFI[%03d], PLMT[%03d], AFFIN[%03d]\",\n\t\t\tqp->queue_id, qp->entry_count, qp->entry_size,\n\t\t\tqp->host_index, qp->notify_interval,\n\t\t\tqp->max_proc_limit, qp->chann);\n\tlen +=  scnprintf(pbuffer + len, LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\"\\n\");\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_idiag_queinfo_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t\tloff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tchar *pbuffer;\n\tint max_cnt, rc, x, len = 0;\n\tstruct lpfc_queue *qp = NULL;\n\n\tif (!debug->buffer)\n\t\tdebug->buffer = kmalloc(LPFC_QUE_INFO_GET_BUF_SIZE, GFP_KERNEL);\n\tif (!debug->buffer)\n\t\treturn 0;\n\tpbuffer = debug->buffer;\n\tmax_cnt = LPFC_QUE_INFO_GET_BUF_SIZE - 256;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tspin_lock_irq(&phba->hbalock);\n\n\t \n\tif (phba->sli4_hba.hdwq && phba->cfg_hdw_queue) {\n\n\t\tx = phba->lpfc_idiag_last_eq;\n\t\tphba->lpfc_idiag_last_eq++;\n\t\tif (phba->lpfc_idiag_last_eq >= phba->cfg_hdw_queue)\n\t\t\tphba->lpfc_idiag_last_eq = 0;\n\n\t\tlen += scnprintf(pbuffer + len,\n\t\t\t\t LPFC_QUE_INFO_GET_BUF_SIZE - len,\n\t\t\t\t \"HDWQ %d out of %d HBA HDWQs\\n\",\n\t\t\t\t x, phba->cfg_hdw_queue);\n\n\t\t \n\t\tqp = phba->sli4_hba.hdwq[x].hba_eq;\n\t\tif (!qp)\n\t\t\tgoto out;\n\n\t\tlen = __lpfc_idiag_print_eq(qp, \"HBA\", pbuffer, len);\n\n\t\t \n\t\tqp->EQ_max_eqe = 0;\n\n\t\tif (len >= max_cnt)\n\t\t\tgoto too_big;\n\n\t\t \n\t\trc = lpfc_idiag_cqs_for_eq(phba, pbuffer, &len,\n\t\t\tmax_cnt, x, qp->queue_id);\n\t\tif (rc)\n\t\t\tgoto too_big;\n\n\t\t \n\t\tif (x)\n\t\t\tgoto out;\n\n\t\t \n\t\tqp = phba->sli4_hba.mbx_cq;\n\t\tlen = __lpfc_idiag_print_cq(qp, \"MBX\", pbuffer, len);\n\t\tif (len >= max_cnt)\n\t\t\tgoto too_big;\n\n\t\t \n\t\tqp = phba->sli4_hba.mbx_wq;\n\t\tlen = __lpfc_idiag_print_wq(qp, \"MBX\", pbuffer, len);\n\t\tif (len >= max_cnt)\n\t\t\tgoto too_big;\n\n\t\t \n\t\tqp = phba->sli4_hba.els_cq;\n\t\tlen = __lpfc_idiag_print_cq(qp, \"ELS\", pbuffer, len);\n\t\t \n\t\tif (qp)\n\t\t\tqp->CQ_max_cqe = 0;\n\t\tif (len >= max_cnt)\n\t\t\tgoto too_big;\n\n\t\t \n\t\tqp = phba->sli4_hba.els_wq;\n\t\tlen = __lpfc_idiag_print_wq(qp, \"ELS\", pbuffer, len);\n\t\tif (len >= max_cnt)\n\t\t\tgoto too_big;\n\n\t\tqp = phba->sli4_hba.hdr_rq;\n\t\tlen = __lpfc_idiag_print_rqpair(qp, phba->sli4_hba.dat_rq,\n\t\t\t\t\t\t\"ELS RQpair\", pbuffer, len);\n\t\tif (len >= max_cnt)\n\t\t\tgoto too_big;\n\n\t\t \n\t\tqp = phba->sli4_hba.nvmels_cq;\n\t\tlen = __lpfc_idiag_print_cq(qp, \"NVME LS\",\n\t\t\t\t\t\tpbuffer, len);\n\t\t \n\t\tif (qp)\n\t\t\tqp->CQ_max_cqe = 0;\n\t\tif (len >= max_cnt)\n\t\t\tgoto too_big;\n\n\t\t \n\t\tqp = phba->sli4_hba.nvmels_wq;\n\t\tlen = __lpfc_idiag_print_wq(qp, \"NVME LS\",\n\t\t\t\t\t\tpbuffer, len);\n\t\tif (len >= max_cnt)\n\t\t\tgoto too_big;\n\n\t\tgoto out;\n\t}\n\n\tspin_unlock_irq(&phba->hbalock);\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n\ntoo_big:\n\tlen +=  scnprintf(pbuffer + len,\n\t\tLPFC_QUE_INFO_GET_BUF_SIZE - len, \"Truncated ...\\n\");\nout:\n\tspin_unlock_irq(&phba->hbalock);\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n}\n\n \nstatic int\nlpfc_idiag_que_param_check(struct lpfc_queue *q, int index, int count)\n{\n\t \n\tif ((count != 1) && (count != LPFC_QUE_ACC_BROWSE))\n\t\treturn -EINVAL;\n\tif (index > q->entry_count - 1)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic int\nlpfc_idiag_queacc_read_qe(char *pbuffer, int len, struct lpfc_queue *pque,\n\t\t\t  uint32_t index)\n{\n\tint offset, esize;\n\tuint32_t *pentry;\n\n\tif (!pbuffer || !pque)\n\t\treturn 0;\n\n\tesize = pque->entry_size;\n\tlen += scnprintf(pbuffer+len, LPFC_QUE_ACC_BUF_SIZE-len,\n\t\t\t\"QE-INDEX[%04d]:\\n\", index);\n\n\toffset = 0;\n\tpentry = lpfc_sli4_qe(pque, index);\n\twhile (esize > 0) {\n\t\tlen += scnprintf(pbuffer+len, LPFC_QUE_ACC_BUF_SIZE-len,\n\t\t\t\t\"%08x \", *pentry);\n\t\tpentry++;\n\t\toffset += sizeof(uint32_t);\n\t\tesize -= sizeof(uint32_t);\n\t\tif (esize > 0 && !(offset % (4 * sizeof(uint32_t))))\n\t\t\tlen += scnprintf(pbuffer+len,\n\t\t\t\t\tLPFC_QUE_ACC_BUF_SIZE-len, \"\\n\");\n\t}\n\tlen += scnprintf(pbuffer+len, LPFC_QUE_ACC_BUF_SIZE-len, \"\\n\");\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_idiag_queacc_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t       loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tuint32_t last_index, index, count;\n\tstruct lpfc_queue *pque = NULL;\n\tchar *pbuffer;\n\tint len = 0;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_RD;\n\n\tif (!debug->buffer)\n\t\tdebug->buffer = kmalloc(LPFC_QUE_ACC_BUF_SIZE, GFP_KERNEL);\n\tif (!debug->buffer)\n\t\treturn 0;\n\tpbuffer = debug->buffer;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_RD) {\n\t\tindex = idiag.cmd.data[IDIAG_QUEACC_INDEX_INDX];\n\t\tcount = idiag.cmd.data[IDIAG_QUEACC_COUNT_INDX];\n\t\tpque = (struct lpfc_queue *)idiag.ptr_private;\n\t} else\n\t\treturn 0;\n\n\t \n\tif (count == LPFC_QUE_ACC_BROWSE)\n\t\tgoto que_browse;\n\n\t \n\tlen = lpfc_idiag_queacc_read_qe(pbuffer, len, pque, index);\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n\nque_browse:\n\n\t \n\tlast_index = idiag.offset.last_rd;\n\tindex = last_index;\n\n\twhile (len < LPFC_QUE_ACC_SIZE - pque->entry_size) {\n\t\tlen = lpfc_idiag_queacc_read_qe(pbuffer, len, pque, index);\n\t\tindex++;\n\t\tif (index > pque->entry_count - 1)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (index > pque->entry_count - 1)\n\t\tindex = 0;\n\tidiag.offset.last_rd = index;\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n}\n\n \nstatic ssize_t\nlpfc_idiag_queacc_write(struct file *file, const char __user *buf,\n\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tuint32_t qidx, quetp, queid, index, count, offset, value;\n\tuint32_t *pentry;\n\tstruct lpfc_queue *pque, *qp;\n\tint rc;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_WR;\n\n\trc = lpfc_idiag_cmd_get(buf, nbytes, &idiag.cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tquetp  = idiag.cmd.data[IDIAG_QUEACC_QUETP_INDX];\n\tqueid  = idiag.cmd.data[IDIAG_QUEACC_QUEID_INDX];\n\tindex  = idiag.cmd.data[IDIAG_QUEACC_INDEX_INDX];\n\tcount  = idiag.cmd.data[IDIAG_QUEACC_COUNT_INDX];\n\toffset = idiag.cmd.data[IDIAG_QUEACC_OFFST_INDX];\n\tvalue  = idiag.cmd.data[IDIAG_QUEACC_VALUE_INDX];\n\n\t \n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_WR ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_ST ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_CL) {\n\t\tif (rc != LPFC_QUE_ACC_WR_CMD_ARG)\n\t\t\tgoto error_out;\n\t\tif (count != 1)\n\t\t\tgoto error_out;\n\t} else if (idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_RD) {\n\t\tif (rc != LPFC_QUE_ACC_RD_CMD_ARG)\n\t\t\tgoto error_out;\n\t} else\n\t\tgoto error_out;\n\n\tswitch (quetp) {\n\tcase LPFC_IDIAG_EQ:\n\t\t \n\t\tif (phba->sli4_hba.hdwq) {\n\t\t\tfor (qidx = 0; qidx < phba->cfg_hdw_queue; qidx++) {\n\t\t\t\tqp = phba->sli4_hba.hdwq[qidx].hba_eq;\n\t\t\t\tif (qp && qp->queue_id == queid) {\n\t\t\t\t\t \n\t\t\t\t\trc = lpfc_idiag_que_param_check(qp,\n\t\t\t\t\t\tindex, count);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\tidiag.ptr_private = qp;\n\t\t\t\t\tgoto pass_check;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto error_out;\n\n\tcase LPFC_IDIAG_CQ:\n\t\t \n\t\tif (phba->sli4_hba.mbx_cq &&\n\t\t    phba->sli4_hba.mbx_cq->queue_id == queid) {\n\t\t\t \n\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\tphba->sli4_hba.mbx_cq, index, count);\n\t\t\tif (rc)\n\t\t\t\tgoto error_out;\n\t\t\tidiag.ptr_private = phba->sli4_hba.mbx_cq;\n\t\t\tgoto pass_check;\n\t\t}\n\t\t \n\t\tif (phba->sli4_hba.els_cq &&\n\t\t    phba->sli4_hba.els_cq->queue_id == queid) {\n\t\t\t \n\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\tphba->sli4_hba.els_cq, index, count);\n\t\t\tif (rc)\n\t\t\t\tgoto error_out;\n\t\t\tidiag.ptr_private = phba->sli4_hba.els_cq;\n\t\t\tgoto pass_check;\n\t\t}\n\t\t \n\t\tif (phba->sli4_hba.nvmels_cq &&\n\t\t    phba->sli4_hba.nvmels_cq->queue_id == queid) {\n\t\t\t \n\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\tphba->sli4_hba.nvmels_cq, index, count);\n\t\t\tif (rc)\n\t\t\t\tgoto error_out;\n\t\t\tidiag.ptr_private = phba->sli4_hba.nvmels_cq;\n\t\t\tgoto pass_check;\n\t\t}\n\t\t \n\t\tif (phba->sli4_hba.hdwq) {\n\t\t\tfor (qidx = 0; qidx < phba->cfg_hdw_queue;\n\t\t\t\t\t\t\t\tqidx++) {\n\t\t\t\tqp = phba->sli4_hba.hdwq[qidx].io_cq;\n\t\t\t\tif (qp && qp->queue_id == queid) {\n\t\t\t\t\t \n\t\t\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\t\tqp, index, count);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\tidiag.ptr_private = qp;\n\t\t\t\t\tgoto pass_check;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto error_out;\n\n\tcase LPFC_IDIAG_MQ:\n\t\t \n\t\tif (phba->sli4_hba.mbx_wq &&\n\t\t    phba->sli4_hba.mbx_wq->queue_id == queid) {\n\t\t\t \n\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\tphba->sli4_hba.mbx_wq, index, count);\n\t\t\tif (rc)\n\t\t\t\tgoto error_out;\n\t\t\tidiag.ptr_private = phba->sli4_hba.mbx_wq;\n\t\t\tgoto pass_check;\n\t\t}\n\t\tgoto error_out;\n\n\tcase LPFC_IDIAG_WQ:\n\t\t \n\t\tif (phba->sli4_hba.els_wq &&\n\t\t    phba->sli4_hba.els_wq->queue_id == queid) {\n\t\t\t \n\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\tphba->sli4_hba.els_wq, index, count);\n\t\t\tif (rc)\n\t\t\t\tgoto error_out;\n\t\t\tidiag.ptr_private = phba->sli4_hba.els_wq;\n\t\t\tgoto pass_check;\n\t\t}\n\t\t \n\t\tif (phba->sli4_hba.nvmels_wq &&\n\t\t    phba->sli4_hba.nvmels_wq->queue_id == queid) {\n\t\t\t \n\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\tphba->sli4_hba.nvmels_wq, index, count);\n\t\t\tif (rc)\n\t\t\t\tgoto error_out;\n\t\t\tidiag.ptr_private = phba->sli4_hba.nvmels_wq;\n\t\t\tgoto pass_check;\n\t\t}\n\n\t\tif (phba->sli4_hba.hdwq) {\n\t\t\t \n\t\t\tfor (qidx = 0; qidx < phba->cfg_hdw_queue; qidx++) {\n\t\t\t\tqp = phba->sli4_hba.hdwq[qidx].io_wq;\n\t\t\t\tif (qp && qp->queue_id == queid) {\n\t\t\t\t\t \n\t\t\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\t\tqp, index, count);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tgoto error_out;\n\t\t\t\t\tidiag.ptr_private = qp;\n\t\t\t\t\tgoto pass_check;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto error_out;\n\n\tcase LPFC_IDIAG_RQ:\n\t\t \n\t\tif (phba->sli4_hba.hdr_rq &&\n\t\t    phba->sli4_hba.hdr_rq->queue_id == queid) {\n\t\t\t \n\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\tphba->sli4_hba.hdr_rq, index, count);\n\t\t\tif (rc)\n\t\t\t\tgoto error_out;\n\t\t\tidiag.ptr_private = phba->sli4_hba.hdr_rq;\n\t\t\tgoto pass_check;\n\t\t}\n\t\t \n\t\tif (phba->sli4_hba.dat_rq &&\n\t\t    phba->sli4_hba.dat_rq->queue_id == queid) {\n\t\t\t \n\t\t\trc = lpfc_idiag_que_param_check(\n\t\t\t\t\tphba->sli4_hba.dat_rq, index, count);\n\t\t\tif (rc)\n\t\t\t\tgoto error_out;\n\t\t\tidiag.ptr_private = phba->sli4_hba.dat_rq;\n\t\t\tgoto pass_check;\n\t\t}\n\t\tgoto error_out;\n\tdefault:\n\t\tgoto error_out;\n\t}\n\npass_check:\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_RD) {\n\t\tif (count == LPFC_QUE_ACC_BROWSE)\n\t\t\tidiag.offset.last_rd = index;\n\t}\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_WR ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_ST ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_CL) {\n\t\t \n\t\tpque = (struct lpfc_queue *)idiag.ptr_private;\n\t\tif (offset > pque->entry_size/sizeof(uint32_t) - 1)\n\t\t\tgoto error_out;\n\t\tpentry = lpfc_sli4_qe(pque, index);\n\t\tpentry += offset;\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_WR)\n\t\t\t*pentry = value;\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_ST)\n\t\t\t*pentry |= value;\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_QUEACC_CL)\n\t\t\t*pentry &= ~value;\n\t}\n\treturn nbytes;\n\nerror_out:\n\t \n\tmemset(&idiag, 0, sizeof(idiag));\n\treturn -EINVAL;\n}\n\n \nstatic int\nlpfc_idiag_drbacc_read_reg(struct lpfc_hba *phba, char *pbuffer,\n\t\t\t   int len, uint32_t drbregid)\n{\n\n\tif (!pbuffer)\n\t\treturn 0;\n\n\tswitch (drbregid) {\n\tcase LPFC_DRB_EQ:\n\t\tlen += scnprintf(pbuffer + len, LPFC_DRB_ACC_BUF_SIZE-len,\n\t\t\t\t\"EQ-DRB-REG: 0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.EQDBregaddr));\n\t\tbreak;\n\tcase LPFC_DRB_CQ:\n\t\tlen += scnprintf(pbuffer + len, LPFC_DRB_ACC_BUF_SIZE - len,\n\t\t\t\t\"CQ-DRB-REG: 0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.CQDBregaddr));\n\t\tbreak;\n\tcase LPFC_DRB_MQ:\n\t\tlen += scnprintf(pbuffer+len, LPFC_DRB_ACC_BUF_SIZE-len,\n\t\t\t\t\"MQ-DRB-REG:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.MQDBregaddr));\n\t\tbreak;\n\tcase LPFC_DRB_WQ:\n\t\tlen += scnprintf(pbuffer+len, LPFC_DRB_ACC_BUF_SIZE-len,\n\t\t\t\t\"WQ-DRB-REG:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.WQDBregaddr));\n\t\tbreak;\n\tcase LPFC_DRB_RQ:\n\t\tlen += scnprintf(pbuffer+len, LPFC_DRB_ACC_BUF_SIZE-len,\n\t\t\t\t\"RQ-DRB-REG:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.RQDBregaddr));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_idiag_drbacc_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t       loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tuint32_t drb_reg_id, i;\n\tchar *pbuffer;\n\tint len = 0;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_RD;\n\n\tif (!debug->buffer)\n\t\tdebug->buffer = kmalloc(LPFC_DRB_ACC_BUF_SIZE, GFP_KERNEL);\n\tif (!debug->buffer)\n\t\treturn 0;\n\tpbuffer = debug->buffer;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_RD)\n\t\tdrb_reg_id = idiag.cmd.data[IDIAG_DRBACC_REGID_INDX];\n\telse\n\t\treturn 0;\n\n\tif (drb_reg_id == LPFC_DRB_ACC_ALL)\n\t\tfor (i = 1; i <= LPFC_DRB_MAX; i++)\n\t\t\tlen = lpfc_idiag_drbacc_read_reg(phba,\n\t\t\t\t\t\t\t pbuffer, len, i);\n\telse\n\t\tlen = lpfc_idiag_drbacc_read_reg(phba,\n\t\t\t\t\t\t pbuffer, len, drb_reg_id);\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n}\n\n \nstatic ssize_t\nlpfc_idiag_drbacc_write(struct file *file, const char __user *buf,\n\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tuint32_t drb_reg_id, value, reg_val = 0;\n\tvoid __iomem *drb_reg;\n\tint rc;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_WR;\n\n\trc = lpfc_idiag_cmd_get(buf, nbytes, &idiag.cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tdrb_reg_id = idiag.cmd.data[IDIAG_DRBACC_REGID_INDX];\n\tvalue = idiag.cmd.data[IDIAG_DRBACC_VALUE_INDX];\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_WR ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_ST ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_CL) {\n\t\tif (rc != LPFC_DRB_ACC_WR_CMD_ARG)\n\t\t\tgoto error_out;\n\t\tif (drb_reg_id > LPFC_DRB_MAX)\n\t\t\tgoto error_out;\n\t} else if (idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_RD) {\n\t\tif (rc != LPFC_DRB_ACC_RD_CMD_ARG)\n\t\t\tgoto error_out;\n\t\tif ((drb_reg_id > LPFC_DRB_MAX) &&\n\t\t    (drb_reg_id != LPFC_DRB_ACC_ALL))\n\t\t\tgoto error_out;\n\t} else\n\t\tgoto error_out;\n\n\t \n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_WR ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_ST ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_CL) {\n\t\tswitch (drb_reg_id) {\n\t\tcase LPFC_DRB_EQ:\n\t\t\tdrb_reg = phba->sli4_hba.EQDBregaddr;\n\t\t\tbreak;\n\t\tcase LPFC_DRB_CQ:\n\t\t\tdrb_reg = phba->sli4_hba.CQDBregaddr;\n\t\t\tbreak;\n\t\tcase LPFC_DRB_MQ:\n\t\t\tdrb_reg = phba->sli4_hba.MQDBregaddr;\n\t\t\tbreak;\n\t\tcase LPFC_DRB_WQ:\n\t\t\tdrb_reg = phba->sli4_hba.WQDBregaddr;\n\t\t\tbreak;\n\t\tcase LPFC_DRB_RQ:\n\t\t\tdrb_reg = phba->sli4_hba.RQDBregaddr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_WR)\n\t\t\treg_val = value;\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_ST) {\n\t\t\treg_val = readl(drb_reg);\n\t\t\treg_val |= value;\n\t\t}\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_DRBACC_CL) {\n\t\t\treg_val = readl(drb_reg);\n\t\t\treg_val &= ~value;\n\t\t}\n\t\twritel(reg_val, drb_reg);\n\t\treadl(drb_reg);  \n\t}\n\treturn nbytes;\n\nerror_out:\n\t \n\tmemset(&idiag, 0, sizeof(idiag));\n\treturn -EINVAL;\n}\n\n \nstatic int\nlpfc_idiag_ctlacc_read_reg(struct lpfc_hba *phba, char *pbuffer,\n\t\t\t   int len, uint32_t ctlregid)\n{\n\n\tif (!pbuffer)\n\t\treturn 0;\n\n\tswitch (ctlregid) {\n\tcase LPFC_CTL_PORT_SEM:\n\t\tlen += scnprintf(pbuffer+len, LPFC_CTL_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port SemReg:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t      LPFC_CTL_PORT_SEM_OFFSET));\n\t\tbreak;\n\tcase LPFC_CTL_PORT_STA:\n\t\tlen += scnprintf(pbuffer+len, LPFC_CTL_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port StaReg:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t      LPFC_CTL_PORT_STA_OFFSET));\n\t\tbreak;\n\tcase LPFC_CTL_PORT_CTL:\n\t\tlen += scnprintf(pbuffer+len, LPFC_CTL_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port CtlReg:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t      LPFC_CTL_PORT_CTL_OFFSET));\n\t\tbreak;\n\tcase LPFC_CTL_PORT_ER1:\n\t\tlen += scnprintf(pbuffer+len, LPFC_CTL_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port Er1Reg:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t      LPFC_CTL_PORT_ER1_OFFSET));\n\t\tbreak;\n\tcase LPFC_CTL_PORT_ER2:\n\t\tlen += scnprintf(pbuffer+len, LPFC_CTL_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port Er2Reg:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t      LPFC_CTL_PORT_ER2_OFFSET));\n\t\tbreak;\n\tcase LPFC_CTL_PDEV_CTL:\n\t\tlen += scnprintf(pbuffer+len, LPFC_CTL_ACC_BUF_SIZE-len,\n\t\t\t\t\"PDev CtlReg:   0x%08x\\n\",\n\t\t\t\treadl(phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t      LPFC_CTL_PDEV_CTL_OFFSET));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_idiag_ctlacc_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t       loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tuint32_t ctl_reg_id, i;\n\tchar *pbuffer;\n\tint len = 0;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_RD;\n\n\tif (!debug->buffer)\n\t\tdebug->buffer = kmalloc(LPFC_CTL_ACC_BUF_SIZE, GFP_KERNEL);\n\tif (!debug->buffer)\n\t\treturn 0;\n\tpbuffer = debug->buffer;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_RD)\n\t\tctl_reg_id = idiag.cmd.data[IDIAG_CTLACC_REGID_INDX];\n\telse\n\t\treturn 0;\n\n\tif (ctl_reg_id == LPFC_CTL_ACC_ALL)\n\t\tfor (i = 1; i <= LPFC_CTL_MAX; i++)\n\t\t\tlen = lpfc_idiag_ctlacc_read_reg(phba,\n\t\t\t\t\t\t\t pbuffer, len, i);\n\telse\n\t\tlen = lpfc_idiag_ctlacc_read_reg(phba,\n\t\t\t\t\t\t pbuffer, len, ctl_reg_id);\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n}\n\n \nstatic ssize_t\nlpfc_idiag_ctlacc_write(struct file *file, const char __user *buf,\n\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tuint32_t ctl_reg_id, value, reg_val = 0;\n\tvoid __iomem *ctl_reg;\n\tint rc;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_WR;\n\n\trc = lpfc_idiag_cmd_get(buf, nbytes, &idiag.cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tctl_reg_id = idiag.cmd.data[IDIAG_CTLACC_REGID_INDX];\n\tvalue = idiag.cmd.data[IDIAG_CTLACC_VALUE_INDX];\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_WR ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_ST ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_CL) {\n\t\tif (rc != LPFC_CTL_ACC_WR_CMD_ARG)\n\t\t\tgoto error_out;\n\t\tif (ctl_reg_id > LPFC_CTL_MAX)\n\t\t\tgoto error_out;\n\t} else if (idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_RD) {\n\t\tif (rc != LPFC_CTL_ACC_RD_CMD_ARG)\n\t\t\tgoto error_out;\n\t\tif ((ctl_reg_id > LPFC_CTL_MAX) &&\n\t\t    (ctl_reg_id != LPFC_CTL_ACC_ALL))\n\t\t\tgoto error_out;\n\t} else\n\t\tgoto error_out;\n\n\t \n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_WR ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_ST ||\n\t    idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_CL) {\n\t\tswitch (ctl_reg_id) {\n\t\tcase LPFC_CTL_PORT_SEM:\n\t\t\tctl_reg = phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t\tLPFC_CTL_PORT_SEM_OFFSET;\n\t\t\tbreak;\n\t\tcase LPFC_CTL_PORT_STA:\n\t\t\tctl_reg = phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t\tLPFC_CTL_PORT_STA_OFFSET;\n\t\t\tbreak;\n\t\tcase LPFC_CTL_PORT_CTL:\n\t\t\tctl_reg = phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t\tLPFC_CTL_PORT_CTL_OFFSET;\n\t\t\tbreak;\n\t\tcase LPFC_CTL_PORT_ER1:\n\t\t\tctl_reg = phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t\tLPFC_CTL_PORT_ER1_OFFSET;\n\t\t\tbreak;\n\t\tcase LPFC_CTL_PORT_ER2:\n\t\t\tctl_reg = phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t\tLPFC_CTL_PORT_ER2_OFFSET;\n\t\t\tbreak;\n\t\tcase LPFC_CTL_PDEV_CTL:\n\t\t\tctl_reg = phba->sli4_hba.conf_regs_memmap_p +\n\t\t\t\t\tLPFC_CTL_PDEV_CTL_OFFSET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error_out;\n\t\t}\n\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_WR)\n\t\t\treg_val = value;\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_ST) {\n\t\t\treg_val = readl(ctl_reg);\n\t\t\treg_val |= value;\n\t\t}\n\t\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_CTLACC_CL) {\n\t\t\treg_val = readl(ctl_reg);\n\t\t\treg_val &= ~value;\n\t\t}\n\t\twritel(reg_val, ctl_reg);\n\t\treadl(ctl_reg);  \n\t}\n\treturn nbytes;\n\nerror_out:\n\t \n\tmemset(&idiag, 0, sizeof(idiag));\n\treturn -EINVAL;\n}\n\n \nstatic int\nlpfc_idiag_mbxacc_get_setup(struct lpfc_hba *phba, char *pbuffer)\n{\n\tuint32_t mbx_dump_map, mbx_dump_cnt, mbx_word_cnt, mbx_mbox_cmd;\n\tint len = 0;\n\n\tmbx_mbox_cmd = idiag.cmd.data[IDIAG_MBXACC_MBCMD_INDX];\n\tmbx_dump_map = idiag.cmd.data[IDIAG_MBXACC_DPMAP_INDX];\n\tmbx_dump_cnt = idiag.cmd.data[IDIAG_MBXACC_DPCNT_INDX];\n\tmbx_word_cnt = idiag.cmd.data[IDIAG_MBXACC_WDCNT_INDX];\n\n\tlen += scnprintf(pbuffer+len, LPFC_MBX_ACC_BUF_SIZE-len,\n\t\t\t\"mbx_dump_map: 0x%08x\\n\", mbx_dump_map);\n\tlen += scnprintf(pbuffer+len, LPFC_MBX_ACC_BUF_SIZE-len,\n\t\t\t\"mbx_dump_cnt: %04d\\n\", mbx_dump_cnt);\n\tlen += scnprintf(pbuffer+len, LPFC_MBX_ACC_BUF_SIZE-len,\n\t\t\t\"mbx_word_cnt: %04d\\n\", mbx_word_cnt);\n\tlen += scnprintf(pbuffer+len, LPFC_MBX_ACC_BUF_SIZE-len,\n\t\t\t\"mbx_mbox_cmd: 0x%02x\\n\", mbx_mbox_cmd);\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_idiag_mbxacc_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t       loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tchar *pbuffer;\n\tint len = 0;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_RD;\n\n\tif (!debug->buffer)\n\t\tdebug->buffer = kmalloc(LPFC_MBX_ACC_BUF_SIZE, GFP_KERNEL);\n\tif (!debug->buffer)\n\t\treturn 0;\n\tpbuffer = debug->buffer;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif ((idiag.cmd.opcode != LPFC_IDIAG_CMD_MBXACC_DP) &&\n\t    (idiag.cmd.opcode != LPFC_IDIAG_BSG_MBXACC_DP))\n\t\treturn 0;\n\n\tlen = lpfc_idiag_mbxacc_get_setup(phba, pbuffer);\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n}\n\n \nstatic ssize_t\nlpfc_idiag_mbxacc_write(struct file *file, const char __user *buf,\n\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tuint32_t mbx_dump_map, mbx_dump_cnt, mbx_word_cnt, mbx_mbox_cmd;\n\tint rc;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_WR;\n\n\trc = lpfc_idiag_cmd_get(buf, nbytes, &idiag.cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tmbx_mbox_cmd = idiag.cmd.data[IDIAG_MBXACC_MBCMD_INDX];\n\tmbx_dump_map = idiag.cmd.data[IDIAG_MBXACC_DPMAP_INDX];\n\tmbx_dump_cnt = idiag.cmd.data[IDIAG_MBXACC_DPCNT_INDX];\n\tmbx_word_cnt = idiag.cmd.data[IDIAG_MBXACC_WDCNT_INDX];\n\n\tif (idiag.cmd.opcode == LPFC_IDIAG_CMD_MBXACC_DP) {\n\t\tif (!(mbx_dump_map & LPFC_MBX_DMP_MBX_ALL))\n\t\t\tgoto error_out;\n\t\tif ((mbx_dump_map & ~LPFC_MBX_DMP_MBX_ALL) &&\n\t\t    (mbx_dump_map != LPFC_MBX_DMP_ALL))\n\t\t\tgoto error_out;\n\t\tif (mbx_word_cnt > sizeof(MAILBOX_t))\n\t\t\tgoto error_out;\n\t} else if (idiag.cmd.opcode == LPFC_IDIAG_BSG_MBXACC_DP) {\n\t\tif (!(mbx_dump_map & LPFC_BSG_DMP_MBX_ALL))\n\t\t\tgoto error_out;\n\t\tif ((mbx_dump_map & ~LPFC_BSG_DMP_MBX_ALL) &&\n\t\t    (mbx_dump_map != LPFC_MBX_DMP_ALL))\n\t\t\tgoto error_out;\n\t\tif (mbx_word_cnt > (BSG_MBOX_SIZE)/4)\n\t\t\tgoto error_out;\n\t\tif (mbx_mbox_cmd != 0x9b)\n\t\t\tgoto error_out;\n\t} else\n\t\tgoto error_out;\n\n\tif (mbx_word_cnt == 0)\n\t\tgoto error_out;\n\tif (rc != LPFC_MBX_DMP_ARG)\n\t\tgoto error_out;\n\tif (mbx_mbox_cmd & ~0xff)\n\t\tgoto error_out;\n\n\t \n\tif (mbx_dump_cnt == 0)\n\t\tgoto reset_out;\n\n\treturn nbytes;\n\nreset_out:\n\t \n\tmemset(&idiag, 0, sizeof(idiag));\n\treturn nbytes;\n\nerror_out:\n\t \n\tmemset(&idiag, 0, sizeof(idiag));\n\treturn -EINVAL;\n}\n\n \nstatic int\nlpfc_idiag_extacc_avail_get(struct lpfc_hba *phba, char *pbuffer, int len)\n{\n\tuint16_t ext_cnt = 0, ext_size = 0;\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\nAvailable Extents Information:\\n\");\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tPort Available VPI extents: \");\n\tlpfc_sli4_get_avail_extnt_rsrc(phba, LPFC_RSC_TYPE_FCOE_VPI,\n\t\t\t\t       &ext_cnt, &ext_size);\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"Count %3d, Size %3d\\n\", ext_cnt, ext_size);\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tPort Available VFI extents: \");\n\tlpfc_sli4_get_avail_extnt_rsrc(phba, LPFC_RSC_TYPE_FCOE_VFI,\n\t\t\t\t       &ext_cnt, &ext_size);\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"Count %3d, Size %3d\\n\", ext_cnt, ext_size);\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tPort Available RPI extents: \");\n\tlpfc_sli4_get_avail_extnt_rsrc(phba, LPFC_RSC_TYPE_FCOE_RPI,\n\t\t\t\t       &ext_cnt, &ext_size);\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"Count %3d, Size %3d\\n\", ext_cnt, ext_size);\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tPort Available XRI extents: \");\n\tlpfc_sli4_get_avail_extnt_rsrc(phba, LPFC_RSC_TYPE_FCOE_XRI,\n\t\t\t\t       &ext_cnt, &ext_size);\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"Count %3d, Size %3d\\n\", ext_cnt, ext_size);\n\n\treturn len;\n}\n\n \nstatic int\nlpfc_idiag_extacc_alloc_get(struct lpfc_hba *phba, char *pbuffer, int len)\n{\n\tuint16_t ext_cnt, ext_size;\n\tint rc;\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\nAllocated Extents Information:\\n\");\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tHost Allocated VPI extents: \");\n\trc = lpfc_sli4_get_allocated_extnts(phba, LPFC_RSC_TYPE_FCOE_VPI,\n\t\t\t\t\t    &ext_cnt, &ext_size);\n\tif (!rc)\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port %d Extent %3d, Size %3d\\n\",\n\t\t\t\tphba->brd_no, ext_cnt, ext_size);\n\telse\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"N/A\\n\");\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tHost Allocated VFI extents: \");\n\trc = lpfc_sli4_get_allocated_extnts(phba, LPFC_RSC_TYPE_FCOE_VFI,\n\t\t\t\t\t    &ext_cnt, &ext_size);\n\tif (!rc)\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port %d Extent %3d, Size %3d\\n\",\n\t\t\t\tphba->brd_no, ext_cnt, ext_size);\n\telse\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"N/A\\n\");\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tHost Allocated RPI extents: \");\n\trc = lpfc_sli4_get_allocated_extnts(phba, LPFC_RSC_TYPE_FCOE_RPI,\n\t\t\t\t\t    &ext_cnt, &ext_size);\n\tif (!rc)\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port %d Extent %3d, Size %3d\\n\",\n\t\t\t\tphba->brd_no, ext_cnt, ext_size);\n\telse\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"N/A\\n\");\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tHost Allocated XRI extents: \");\n\trc = lpfc_sli4_get_allocated_extnts(phba, LPFC_RSC_TYPE_FCOE_XRI,\n\t\t\t\t\t    &ext_cnt, &ext_size);\n\tif (!rc)\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"Port %d Extent %3d, Size %3d\\n\",\n\t\t\t\tphba->brd_no, ext_cnt, ext_size);\n\telse\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"N/A\\n\");\n\n\treturn len;\n}\n\n \nstatic int\nlpfc_idiag_extacc_drivr_get(struct lpfc_hba *phba, char *pbuffer, int len)\n{\n\tstruct lpfc_rsrc_blks *rsrc_blks;\n\tint index;\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\nDriver Extents Information:\\n\");\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tVPI extents:\\n\");\n\tindex = 0;\n\tlist_for_each_entry(rsrc_blks, &phba->lpfc_vpi_blk_list, list) {\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"\\t\\tBlock %3d: Start %4d, Count %4d\\n\",\n\t\t\t\tindex, rsrc_blks->rsrc_start,\n\t\t\t\trsrc_blks->rsrc_size);\n\t\tindex++;\n\t}\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tVFI extents:\\n\");\n\tindex = 0;\n\tlist_for_each_entry(rsrc_blks, &phba->sli4_hba.lpfc_vfi_blk_list,\n\t\t\t    list) {\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"\\t\\tBlock %3d: Start %4d, Count %4d\\n\",\n\t\t\t\tindex, rsrc_blks->rsrc_start,\n\t\t\t\trsrc_blks->rsrc_size);\n\t\tindex++;\n\t}\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tRPI extents:\\n\");\n\tindex = 0;\n\tlist_for_each_entry(rsrc_blks, &phba->sli4_hba.lpfc_rpi_blk_list,\n\t\t\t    list) {\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"\\t\\tBlock %3d: Start %4d, Count %4d\\n\",\n\t\t\t\tindex, rsrc_blks->rsrc_start,\n\t\t\t\trsrc_blks->rsrc_size);\n\t\tindex++;\n\t}\n\n\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\"\\tXRI extents:\\n\");\n\tindex = 0;\n\tlist_for_each_entry(rsrc_blks, &phba->sli4_hba.lpfc_xri_blk_list,\n\t\t\t    list) {\n\t\tlen += scnprintf(pbuffer+len, LPFC_EXT_ACC_BUF_SIZE-len,\n\t\t\t\t\"\\t\\tBlock %3d: Start %4d, Count %4d\\n\",\n\t\t\t\tindex, rsrc_blks->rsrc_start,\n\t\t\t\trsrc_blks->rsrc_size);\n\t\tindex++;\n\t}\n\n\treturn len;\n}\n\n \nstatic ssize_t\nlpfc_idiag_extacc_write(struct file *file, const char __user *buf,\n\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tuint32_t ext_map;\n\tint rc;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_WR;\n\n\trc = lpfc_idiag_cmd_get(buf, nbytes, &idiag.cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\n\text_map = idiag.cmd.data[IDIAG_EXTACC_EXMAP_INDX];\n\n\tif (idiag.cmd.opcode != LPFC_IDIAG_CMD_EXTACC_RD)\n\t\tgoto error_out;\n\tif (rc != LPFC_EXT_ACC_CMD_ARG)\n\t\tgoto error_out;\n\tif (!(ext_map & LPFC_EXT_ACC_ALL))\n\t\tgoto error_out;\n\n\treturn nbytes;\nerror_out:\n\t \n\tmemset(&idiag, 0, sizeof(idiag));\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t\nlpfc_idiag_extacc_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t       loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tchar *pbuffer;\n\tuint32_t ext_map;\n\tint len = 0;\n\n\t \n\tdebug->op = LPFC_IDIAG_OP_RD;\n\n\tif (!debug->buffer)\n\t\tdebug->buffer = kmalloc(LPFC_EXT_ACC_BUF_SIZE, GFP_KERNEL);\n\tif (!debug->buffer)\n\t\treturn 0;\n\tpbuffer = debug->buffer;\n\tif (*ppos)\n\t\treturn 0;\n\tif (idiag.cmd.opcode != LPFC_IDIAG_CMD_EXTACC_RD)\n\t\treturn 0;\n\n\text_map = idiag.cmd.data[IDIAG_EXTACC_EXMAP_INDX];\n\tif (ext_map & LPFC_EXT_ACC_AVAIL)\n\t\tlen = lpfc_idiag_extacc_avail_get(phba, pbuffer, len);\n\tif (ext_map & LPFC_EXT_ACC_ALLOC)\n\t\tlen = lpfc_idiag_extacc_alloc_get(phba, pbuffer, len);\n\tif (ext_map & LPFC_EXT_ACC_DRIVR)\n\t\tlen = lpfc_idiag_extacc_drivr_get(phba, pbuffer, len);\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, pbuffer, len);\n}\n\nstatic int\nlpfc_cgn_buffer_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\tdebug->buffer = vmalloc(LPFC_CGN_BUF_SIZE);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->i_private = inode->i_private;\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_cgn_buffer_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t     loff_t *ppos)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tchar *buffer = debug->buffer;\n\tuint32_t *ptr;\n\tint cnt, len = 0;\n\n\tif (!phba->sli4_hba.pc_sli4_params.mi_ver || !phba->cgn_i) {\n\t\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t\t \"Congestion Mgmt is not supported\\n\");\n\t\tgoto out;\n\t}\n\tptr = (uint32_t *)phba->cgn_i->virt;\n\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t \"Congestion Buffer Header\\n\");\n\t \n\tcnt = 32;\n\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t \"000: %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\t\t *ptr, *(ptr + 1), *(ptr + 2), *(ptr + 3),\n\t\t\t *(ptr + 4), *(ptr + 5), *(ptr + 6), *(ptr + 7));\n\tptr += 8;\n\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t \"Congestion Buffer Data\\n\");\n\twhile (cnt < sizeof(struct lpfc_cgn_info)) {\n\t\tif (len > (LPFC_CGN_BUF_SIZE - LPFC_DEBUG_OUT_LINE_SZ)) {\n\t\t\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t\t\t \"Truncated . . .\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t\t \"%03x: %08x %08x %08x %08x \"\n\t\t\t\t \"%08x %08x %08x %08x\\n\",\n\t\t\t\t cnt, *ptr, *(ptr + 1), *(ptr + 2),\n\t\t\t\t *(ptr + 3), *(ptr + 4), *(ptr + 5),\n\t\t\t\t *(ptr + 6), *(ptr + 7));\n\t\tcnt += 32;\n\t\tptr += 8;\n\t}\n\tif (len > (LPFC_CGN_BUF_SIZE - LPFC_DEBUG_OUT_LINE_SZ)) {\n\t\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t\t \"Truncated . . .\\n\");\n\t\tgoto out;\n\t}\n\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t \"Parameter Data\\n\");\n\tptr = (uint32_t *)&phba->cgn_p;\n\tlen += scnprintf(buffer + len, LPFC_CGN_BUF_SIZE - len,\n\t\t\t \"%08x %08x %08x %08x\\n\",\n\t\t\t *ptr, *(ptr + 1), *(ptr + 2), *(ptr + 3));\nout:\n\treturn simple_read_from_buffer(buf, nbytes, ppos, buffer, len);\n}\n\nstatic int\nlpfc_cgn_buffer_release(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_debug *debug = file->private_data;\n\n\tvfree(debug->buffer);\n\tkfree(debug);\n\n\treturn 0;\n}\n\nstatic int\nlpfc_rx_monitor_open(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_rx_monitor_debug *debug;\n\tint rc = -ENOMEM;\n\n\tdebug = kmalloc(sizeof(*debug), GFP_KERNEL);\n\tif (!debug)\n\t\tgoto out;\n\n\tdebug->buffer = vmalloc(MAX_DEBUGFS_RX_INFO_SIZE);\n\tif (!debug->buffer) {\n\t\tkfree(debug);\n\t\tgoto out;\n\t}\n\n\tdebug->i_private = inode->i_private;\n\tfile->private_data = debug;\n\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic ssize_t\nlpfc_rx_monitor_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t     loff_t *ppos)\n{\n\tstruct lpfc_rx_monitor_debug *debug = file->private_data;\n\tstruct lpfc_hba *phba = (struct lpfc_hba *)debug->i_private;\n\tchar *buffer = debug->buffer;\n\n\tif (!phba->rx_monitor) {\n\t\tscnprintf(buffer, MAX_DEBUGFS_RX_INFO_SIZE,\n\t\t\t  \"Rx Monitor Info is empty.\\n\");\n\t} else {\n\t\tlpfc_rx_monitor_report(phba, phba->rx_monitor, buffer,\n\t\t\t\t       MAX_DEBUGFS_RX_INFO_SIZE,\n\t\t\t\t       LPFC_MAX_RXMONITOR_ENTRY);\n\t}\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, buffer,\n\t\t\t\t       strlen(buffer));\n}\n\nstatic int\nlpfc_rx_monitor_release(struct inode *inode, struct file *file)\n{\n\tstruct lpfc_rx_monitor_debug *debug = file->private_data;\n\n\tvfree(debug->buffer);\n\tkfree(debug);\n\n\treturn 0;\n}\n\n#undef lpfc_debugfs_op_disc_trc\nstatic const struct file_operations lpfc_debugfs_op_disc_trc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_disc_trc_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_nodelist\nstatic const struct file_operations lpfc_debugfs_op_nodelist = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_nodelist_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_multixripools\nstatic const struct file_operations lpfc_debugfs_op_multixripools = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_multixripools_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.write =\tlpfc_debugfs_multixripools_write,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_hbqinfo\nstatic const struct file_operations lpfc_debugfs_op_hbqinfo = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_hbqinfo_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.release =      lpfc_debugfs_release,\n};\n\n#ifdef LPFC_HDWQ_LOCK_STAT\n#undef lpfc_debugfs_op_lockstat\nstatic const struct file_operations lpfc_debugfs_op_lockstat = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_lockstat_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.write =        lpfc_debugfs_lockstat_write,\n\t.release =      lpfc_debugfs_release,\n};\n#endif\n\n#undef lpfc_debugfs_ras_log\nstatic const struct file_operations lpfc_debugfs_ras_log = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_ras_log_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.release =      lpfc_debugfs_ras_log_release,\n};\n\n#undef lpfc_debugfs_op_dumpHBASlim\nstatic const struct file_operations lpfc_debugfs_op_dumpHBASlim = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_dumpHBASlim_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_dumpHostSlim\nstatic const struct file_operations lpfc_debugfs_op_dumpHostSlim = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_dumpHostSlim_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_nvmestat\nstatic const struct file_operations lpfc_debugfs_op_nvmestat = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_nvmestat_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.write =\tlpfc_debugfs_nvmestat_write,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_scsistat\nstatic const struct file_operations lpfc_debugfs_op_scsistat = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_scsistat_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.write =\tlpfc_debugfs_scsistat_write,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_ioktime\nstatic const struct file_operations lpfc_debugfs_op_ioktime = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_ioktime_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.write =\tlpfc_debugfs_ioktime_write,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_nvmeio_trc\nstatic const struct file_operations lpfc_debugfs_op_nvmeio_trc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_nvmeio_trc_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.write =\tlpfc_debugfs_nvmeio_trc_write,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_hdwqstat\nstatic const struct file_operations lpfc_debugfs_op_hdwqstat = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_hdwqstat_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.write =\tlpfc_debugfs_hdwqstat_write,\n\t.release =      lpfc_debugfs_release,\n};\n\n#undef lpfc_debugfs_op_dif_err\nstatic const struct file_operations lpfc_debugfs_op_dif_err = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tsimple_open,\n\t.llseek =\tlpfc_debugfs_lseek,\n\t.read =\t\tlpfc_debugfs_dif_err_read,\n\t.write =\tlpfc_debugfs_dif_err_write,\n\t.release =\tlpfc_debugfs_dif_err_release,\n};\n\n#undef lpfc_debugfs_op_slow_ring_trc\nstatic const struct file_operations lpfc_debugfs_op_slow_ring_trc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_debugfs_slow_ring_trc_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_debugfs_read,\n\t.release =      lpfc_debugfs_release,\n};\n\nstatic struct dentry *lpfc_debugfs_root = NULL;\nstatic atomic_t lpfc_debugfs_hba_count;\n\n \n#undef lpfc_idiag_op_pciCfg\nstatic const struct file_operations lpfc_idiag_op_pciCfg = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_idiag_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_idiag_pcicfg_read,\n\t.write =        lpfc_idiag_pcicfg_write,\n\t.release =      lpfc_idiag_cmd_release,\n};\n\n#undef lpfc_idiag_op_barAcc\nstatic const struct file_operations lpfc_idiag_op_barAcc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_idiag_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_idiag_baracc_read,\n\t.write =        lpfc_idiag_baracc_write,\n\t.release =      lpfc_idiag_cmd_release,\n};\n\n#undef lpfc_idiag_op_queInfo\nstatic const struct file_operations lpfc_idiag_op_queInfo = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_idiag_open,\n\t.read =         lpfc_idiag_queinfo_read,\n\t.release =      lpfc_idiag_release,\n};\n\n#undef lpfc_idiag_op_queAcc\nstatic const struct file_operations lpfc_idiag_op_queAcc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_idiag_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_idiag_queacc_read,\n\t.write =        lpfc_idiag_queacc_write,\n\t.release =      lpfc_idiag_cmd_release,\n};\n\n#undef lpfc_idiag_op_drbAcc\nstatic const struct file_operations lpfc_idiag_op_drbAcc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_idiag_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_idiag_drbacc_read,\n\t.write =        lpfc_idiag_drbacc_write,\n\t.release =      lpfc_idiag_cmd_release,\n};\n\n#undef lpfc_idiag_op_ctlAcc\nstatic const struct file_operations lpfc_idiag_op_ctlAcc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_idiag_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_idiag_ctlacc_read,\n\t.write =        lpfc_idiag_ctlacc_write,\n\t.release =      lpfc_idiag_cmd_release,\n};\n\n#undef lpfc_idiag_op_mbxAcc\nstatic const struct file_operations lpfc_idiag_op_mbxAcc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_idiag_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_idiag_mbxacc_read,\n\t.write =        lpfc_idiag_mbxacc_write,\n\t.release =      lpfc_idiag_cmd_release,\n};\n\n#undef lpfc_idiag_op_extAcc\nstatic const struct file_operations lpfc_idiag_op_extAcc = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_idiag_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_idiag_extacc_read,\n\t.write =        lpfc_idiag_extacc_write,\n\t.release =      lpfc_idiag_cmd_release,\n};\n#undef lpfc_cgn_buffer_op\nstatic const struct file_operations lpfc_cgn_buffer_op = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_cgn_buffer_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_cgn_buffer_read,\n\t.release =      lpfc_cgn_buffer_release,\n};\n\n#undef lpfc_rx_monitor_op\nstatic const struct file_operations lpfc_rx_monitor_op = {\n\t.owner =        THIS_MODULE,\n\t.open =         lpfc_rx_monitor_open,\n\t.llseek =       lpfc_debugfs_lseek,\n\t.read =         lpfc_rx_monitor_read,\n\t.release =      lpfc_rx_monitor_release,\n};\n#endif\n\n \nvoid\nlpfc_idiag_mbxacc_dump_bsg_mbox(struct lpfc_hba *phba, enum nemb_type nemb_tp,\n\t\t\t\tenum mbox_type mbox_tp, enum dma_type dma_tp,\n\t\t\t\tenum sta_type sta_tp,\n\t\t\t\tstruct lpfc_dmabuf *dmabuf, uint32_t ext_buf)\n{\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t *mbx_mbox_cmd, *mbx_dump_map, *mbx_dump_cnt, *mbx_word_cnt;\n\tchar line_buf[LPFC_MBX_ACC_LBUF_SZ];\n\tint len = 0;\n\tuint32_t do_dump = 0;\n\tuint32_t *pword;\n\tuint32_t i;\n\n\tif (idiag.cmd.opcode != LPFC_IDIAG_BSG_MBXACC_DP)\n\t\treturn;\n\n\tmbx_mbox_cmd = &idiag.cmd.data[IDIAG_MBXACC_MBCMD_INDX];\n\tmbx_dump_map = &idiag.cmd.data[IDIAG_MBXACC_DPMAP_INDX];\n\tmbx_dump_cnt = &idiag.cmd.data[IDIAG_MBXACC_DPCNT_INDX];\n\tmbx_word_cnt = &idiag.cmd.data[IDIAG_MBXACC_WDCNT_INDX];\n\n\tif (!(*mbx_dump_map & LPFC_MBX_DMP_ALL) ||\n\t    (*mbx_dump_cnt == 0) ||\n\t    (*mbx_word_cnt == 0))\n\t\treturn;\n\n\tif (*mbx_mbox_cmd != 0x9B)\n\t\treturn;\n\n\tif ((mbox_tp == mbox_rd) && (dma_tp == dma_mbox)) {\n\t\tif (*mbx_dump_map & LPFC_BSG_DMP_MBX_RD_MBX) {\n\t\t\tdo_dump |= LPFC_BSG_DMP_MBX_RD_MBX;\n\t\t\tpr_err(\"\\nRead mbox command (x%x), \"\n\t\t\t       \"nemb:0x%x, extbuf_cnt:%d:\\n\",\n\t\t\t       sta_tp, nemb_tp, ext_buf);\n\t\t}\n\t}\n\tif ((mbox_tp == mbox_rd) && (dma_tp == dma_ebuf)) {\n\t\tif (*mbx_dump_map & LPFC_BSG_DMP_MBX_RD_BUF) {\n\t\t\tdo_dump |= LPFC_BSG_DMP_MBX_RD_BUF;\n\t\t\tpr_err(\"\\nRead mbox buffer (x%x), \"\n\t\t\t       \"nemb:0x%x, extbuf_seq:%d:\\n\",\n\t\t\t       sta_tp, nemb_tp, ext_buf);\n\t\t}\n\t}\n\tif ((mbox_tp == mbox_wr) && (dma_tp == dma_mbox)) {\n\t\tif (*mbx_dump_map & LPFC_BSG_DMP_MBX_WR_MBX) {\n\t\t\tdo_dump |= LPFC_BSG_DMP_MBX_WR_MBX;\n\t\t\tpr_err(\"\\nWrite mbox command (x%x), \"\n\t\t\t       \"nemb:0x%x, extbuf_cnt:%d:\\n\",\n\t\t\t       sta_tp, nemb_tp, ext_buf);\n\t\t}\n\t}\n\tif ((mbox_tp == mbox_wr) && (dma_tp == dma_ebuf)) {\n\t\tif (*mbx_dump_map & LPFC_BSG_DMP_MBX_WR_BUF) {\n\t\t\tdo_dump |= LPFC_BSG_DMP_MBX_WR_BUF;\n\t\t\tpr_err(\"\\nWrite mbox buffer (x%x), \"\n\t\t\t       \"nemb:0x%x, extbuf_seq:%d:\\n\",\n\t\t\t       sta_tp, nemb_tp, ext_buf);\n\t\t}\n\t}\n\n\t \n\tif (do_dump) {\n\t\tpword = (uint32_t *)dmabuf->virt;\n\t\tfor (i = 0; i < *mbx_word_cnt; i++) {\n\t\t\tif (!(i % 8)) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_err(\"%s\\n\", line_buf);\n\t\t\t\tlen = 0;\n\t\t\t\tlen += scnprintf(line_buf+len,\n\t\t\t\t\t\tLPFC_MBX_ACC_LBUF_SZ-len,\n\t\t\t\t\t\t\"%03d: \", i);\n\t\t\t}\n\t\t\tlen += scnprintf(line_buf+len, LPFC_MBX_ACC_LBUF_SZ-len,\n\t\t\t\t\t\"%08x \", (uint32_t)*pword);\n\t\t\tpword++;\n\t\t}\n\t\tif ((i - 1) % 8)\n\t\t\tpr_err(\"%s\\n\", line_buf);\n\t\t(*mbx_dump_cnt)--;\n\t}\n\n\t \n\tif (*mbx_dump_cnt == 0)\n\t\tmemset(&idiag, 0, sizeof(idiag));\n\treturn;\n#endif\n}\n\n \nvoid\nlpfc_idiag_mbxacc_dump_issue_mbox(struct lpfc_hba *phba, MAILBOX_t *pmbox)\n{\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t *mbx_dump_map, *mbx_dump_cnt, *mbx_word_cnt, *mbx_mbox_cmd;\n\tchar line_buf[LPFC_MBX_ACC_LBUF_SZ];\n\tint len = 0;\n\tuint32_t *pword;\n\tuint8_t *pbyte;\n\tuint32_t i, j;\n\n\tif (idiag.cmd.opcode != LPFC_IDIAG_CMD_MBXACC_DP)\n\t\treturn;\n\n\tmbx_mbox_cmd = &idiag.cmd.data[IDIAG_MBXACC_MBCMD_INDX];\n\tmbx_dump_map = &idiag.cmd.data[IDIAG_MBXACC_DPMAP_INDX];\n\tmbx_dump_cnt = &idiag.cmd.data[IDIAG_MBXACC_DPCNT_INDX];\n\tmbx_word_cnt = &idiag.cmd.data[IDIAG_MBXACC_WDCNT_INDX];\n\n\tif (!(*mbx_dump_map & LPFC_MBX_DMP_MBX_ALL) ||\n\t    (*mbx_dump_cnt == 0) ||\n\t    (*mbx_word_cnt == 0))\n\t\treturn;\n\n\tif ((*mbx_mbox_cmd != LPFC_MBX_ALL_CMD) &&\n\t    (*mbx_mbox_cmd != pmbox->mbxCommand))\n\t\treturn;\n\n\t \n\tif (*mbx_dump_map & LPFC_MBX_DMP_MBX_WORD) {\n\t\tpr_err(\"Mailbox command:0x%x dump by word:\\n\",\n\t\t       pmbox->mbxCommand);\n\t\tpword = (uint32_t *)pmbox;\n\t\tfor (i = 0; i < *mbx_word_cnt; i++) {\n\t\t\tif (!(i % 8)) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_err(\"%s\\n\", line_buf);\n\t\t\t\tlen = 0;\n\t\t\t\tmemset(line_buf, 0, LPFC_MBX_ACC_LBUF_SZ);\n\t\t\t\tlen += scnprintf(line_buf+len,\n\t\t\t\t\t\tLPFC_MBX_ACC_LBUF_SZ-len,\n\t\t\t\t\t\t\"%03d: \", i);\n\t\t\t}\n\t\t\tlen += scnprintf(line_buf+len, LPFC_MBX_ACC_LBUF_SZ-len,\n\t\t\t\t\t\"%08x \",\n\t\t\t\t\t((uint32_t)*pword) & 0xffffffff);\n\t\t\tpword++;\n\t\t}\n\t\tif ((i - 1) % 8)\n\t\t\tpr_err(\"%s\\n\", line_buf);\n\t\tpr_err(\"\\n\");\n\t}\n\tif (*mbx_dump_map & LPFC_MBX_DMP_MBX_BYTE) {\n\t\tpr_err(\"Mailbox command:0x%x dump by byte:\\n\",\n\t\t       pmbox->mbxCommand);\n\t\tpbyte = (uint8_t *)pmbox;\n\t\tfor (i = 0; i < *mbx_word_cnt; i++) {\n\t\t\tif (!(i % 8)) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tpr_err(\"%s\\n\", line_buf);\n\t\t\t\tlen = 0;\n\t\t\t\tmemset(line_buf, 0, LPFC_MBX_ACC_LBUF_SZ);\n\t\t\t\tlen += scnprintf(line_buf+len,\n\t\t\t\t\t\tLPFC_MBX_ACC_LBUF_SZ-len,\n\t\t\t\t\t\t\"%03d: \", i);\n\t\t\t}\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tlen += scnprintf(line_buf+len,\n\t\t\t\t\t\tLPFC_MBX_ACC_LBUF_SZ-len,\n\t\t\t\t\t\t\"%02x\",\n\t\t\t\t\t\t((uint8_t)*pbyte) & 0xff);\n\t\t\t\tpbyte++;\n\t\t\t}\n\t\t\tlen += scnprintf(line_buf+len,\n\t\t\t\t\tLPFC_MBX_ACC_LBUF_SZ-len, \" \");\n\t\t}\n\t\tif ((i - 1) % 8)\n\t\t\tpr_err(\"%s\\n\", line_buf);\n\t\tpr_err(\"\\n\");\n\t}\n\t(*mbx_dump_cnt)--;\n\n\t \n\tif (*mbx_dump_cnt == 0)\n\t\tmemset(&idiag, 0, sizeof(idiag));\n\treturn;\n#endif\n}\n\n \ninline void\nlpfc_debugfs_initialize(struct lpfc_vport *vport)\n{\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tstruct lpfc_hba   *phba = vport->phba;\n\tchar name[64];\n\tuint32_t num, i;\n\tbool pport_setup = false;\n\n\tif (!lpfc_debugfs_enable)\n\t\treturn;\n\n\t \n\tif (!lpfc_debugfs_root) {\n\t\tlpfc_debugfs_root = debugfs_create_dir(\"lpfc\", NULL);\n\t\tatomic_set(&lpfc_debugfs_hba_count, 0);\n\t}\n\tif (!lpfc_debugfs_start_time)\n\t\tlpfc_debugfs_start_time = jiffies;\n\n\t \n\tsnprintf(name, sizeof(name), \"fn%d\", phba->brd_no);\n\tif (!phba->hba_debugfs_root) {\n\t\tpport_setup = true;\n\t\tphba->hba_debugfs_root =\n\t\t\tdebugfs_create_dir(name, lpfc_debugfs_root);\n\t\tatomic_inc(&lpfc_debugfs_hba_count);\n\t\tatomic_set(&phba->debugfs_vport_count, 0);\n\n\t\t \n\t\tsnprintf(name, sizeof(name), \"multixripools\");\n\t\tphba->debug_multixri_pools =\n\t\t\tdebugfs_create_file(name, S_IFREG | 0644,\n\t\t\t\t\t    phba->hba_debugfs_root,\n\t\t\t\t\t    phba,\n\t\t\t\t\t    &lpfc_debugfs_op_multixripools);\n\t\tif (IS_ERR(phba->debug_multixri_pools)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\t \"0527 Cannot create debugfs multixripools\\n\");\n\t\t\tgoto debug_failed;\n\t\t}\n\n\t\t \n\t\tscnprintf(name, sizeof(name), \"cgn_buffer\");\n\t\tphba->debug_cgn_buffer =\n\t\t\tdebugfs_create_file(name, S_IFREG | 0644,\n\t\t\t\t\t    phba->hba_debugfs_root,\n\t\t\t\t\t    phba, &lpfc_cgn_buffer_op);\n\t\tif (IS_ERR(phba->debug_cgn_buffer)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\t \"6527 Cannot create debugfs \"\n\t\t\t\t\t \"cgn_buffer\\n\");\n\t\t\tgoto debug_failed;\n\t\t}\n\n\t\t \n\t\tscnprintf(name, sizeof(name), \"rx_monitor\");\n\t\tphba->debug_rx_monitor =\n\t\t\tdebugfs_create_file(name, S_IFREG | 0644,\n\t\t\t\t\t    phba->hba_debugfs_root,\n\t\t\t\t\t    phba, &lpfc_rx_monitor_op);\n\t\tif (IS_ERR(phba->debug_rx_monitor)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\t \"6528 Cannot create debugfs \"\n\t\t\t\t\t \"rx_monitor\\n\");\n\t\t\tgoto debug_failed;\n\t\t}\n\n\t\t \n\t\tsnprintf(name, sizeof(name), \"ras_log\");\n\t\tphba->debug_ras_log =\n\t\t\tdebugfs_create_file(name, 0644,\n\t\t\t\t\t    phba->hba_debugfs_root,\n\t\t\t\t\t    phba, &lpfc_debugfs_ras_log);\n\t\tif (IS_ERR(phba->debug_ras_log)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\t \"6148 Cannot create debugfs\"\n\t\t\t\t\t \" ras_log\\n\");\n\t\t\tgoto debug_failed;\n\t\t}\n\n\t\t \n\t\tsnprintf(name, sizeof(name), \"hbqinfo\");\n\t\tphba->debug_hbqinfo =\n\t\t\tdebugfs_create_file(name, S_IFREG | 0644,\n\t\t\t\t\t    phba->hba_debugfs_root,\n\t\t\t\t\t    phba, &lpfc_debugfs_op_hbqinfo);\n\n#ifdef LPFC_HDWQ_LOCK_STAT\n\t\t \n\t\tsnprintf(name, sizeof(name), \"lockstat\");\n\t\tphba->debug_lockstat =\n\t\t\tdebugfs_create_file(name, S_IFREG | 0644,\n\t\t\t\t\t    phba->hba_debugfs_root,\n\t\t\t\t\t    phba, &lpfc_debugfs_op_lockstat);\n\t\tif (IS_ERR(phba->debug_lockstat)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\t \"4610 Can't create debugfs lockstat\\n\");\n\t\t\tgoto debug_failed;\n\t\t}\n#endif\n\n\t\t \n\t\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\t\tsnprintf(name, sizeof(name), \"dumpHBASlim\");\n\t\t\tphba->debug_dumpHBASlim =\n\t\t\t\tdebugfs_create_file(name,\n\t\t\t\t\tS_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\tphba->hba_debugfs_root,\n\t\t\t\t\tphba, &lpfc_debugfs_op_dumpHBASlim);\n\t\t} else\n\t\t\tphba->debug_dumpHBASlim = NULL;\n\n\t\t \n\t\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\t\tsnprintf(name, sizeof(name), \"dumpHostSlim\");\n\t\t\tphba->debug_dumpHostSlim =\n\t\t\t\tdebugfs_create_file(name,\n\t\t\t\t\tS_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\tphba->hba_debugfs_root,\n\t\t\t\t\tphba, &lpfc_debugfs_op_dumpHostSlim);\n\t\t} else\n\t\t\tphba->debug_dumpHostSlim = NULL;\n\n\t\t \n\t\tsnprintf(name, sizeof(name), \"InjErrLBA\");\n\t\tphba->debug_InjErrLBA =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\t\tphba->lpfc_injerr_lba = LPFC_INJERR_LBA_OFF;\n\n\t\tsnprintf(name, sizeof(name), \"InjErrNPortID\");\n\t\tphba->debug_InjErrNPortID =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\n\t\tsnprintf(name, sizeof(name), \"InjErrWWPN\");\n\t\tphba->debug_InjErrWWPN =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\n\t\tsnprintf(name, sizeof(name), \"writeGuardInjErr\");\n\t\tphba->debug_writeGuard =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\n\t\tsnprintf(name, sizeof(name), \"writeAppInjErr\");\n\t\tphba->debug_writeApp =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\n\t\tsnprintf(name, sizeof(name), \"writeRefInjErr\");\n\t\tphba->debug_writeRef =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\n\t\tsnprintf(name, sizeof(name), \"readGuardInjErr\");\n\t\tphba->debug_readGuard =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\n\t\tsnprintf(name, sizeof(name), \"readAppInjErr\");\n\t\tphba->debug_readApp =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\n\t\tsnprintf(name, sizeof(name), \"readRefInjErr\");\n\t\tphba->debug_readRef =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\tphba->hba_debugfs_root,\n\t\t\tphba, &lpfc_debugfs_op_dif_err);\n\n\t\t \n\t\tif (lpfc_debugfs_max_slow_ring_trc) {\n\t\t\tnum = lpfc_debugfs_max_slow_ring_trc - 1;\n\t\t\tif (num & lpfc_debugfs_max_slow_ring_trc) {\n\t\t\t\t \n\t\t\t\tnum = lpfc_debugfs_max_slow_ring_trc;\n\t\t\t\ti = 0;\n\t\t\t\twhile (num > 1) {\n\t\t\t\t\tnum = num >> 1;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tlpfc_debugfs_max_slow_ring_trc = (1 << i);\n\t\t\t\tpr_err(\"lpfc_debugfs_max_disc_trc changed to \"\n\t\t\t\t       \"%d\\n\", lpfc_debugfs_max_disc_trc);\n\t\t\t}\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"slow_ring_trace\");\n\t\tphba->debug_slow_ring_trc =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t phba->hba_debugfs_root,\n\t\t\t\t phba, &lpfc_debugfs_op_slow_ring_trc);\n\t\tif (!phba->slow_ring_trc) {\n\t\t\tphba->slow_ring_trc = kcalloc(\n\t\t\t\tlpfc_debugfs_max_slow_ring_trc,\n\t\t\t\tsizeof(struct lpfc_debugfs_trc),\n\t\t\t\tGFP_KERNEL);\n\t\t\tif (!phba->slow_ring_trc) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t\t\t \"0416 Cannot create debugfs \"\n\t\t\t\t\t\t \"slow_ring buffer\\n\");\n\t\t\t\tgoto debug_failed;\n\t\t\t}\n\t\t\tatomic_set(&phba->slow_ring_trc_cnt, 0);\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"nvmeio_trc\");\n\t\tphba->debug_nvmeio_trc =\n\t\t\tdebugfs_create_file(name, 0644,\n\t\t\t\t\t    phba->hba_debugfs_root,\n\t\t\t\t\t    phba, &lpfc_debugfs_op_nvmeio_trc);\n\n\t\tatomic_set(&phba->nvmeio_trc_cnt, 0);\n\t\tif (lpfc_debugfs_max_nvmeio_trc) {\n\t\t\tnum = lpfc_debugfs_max_nvmeio_trc - 1;\n\t\t\tif (num & lpfc_debugfs_max_disc_trc) {\n\t\t\t\t \n\t\t\t\tnum = lpfc_debugfs_max_nvmeio_trc;\n\t\t\t\ti = 0;\n\t\t\t\twhile (num > 1) {\n\t\t\t\t\tnum = num >> 1;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tlpfc_debugfs_max_nvmeio_trc = (1 << i);\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\t\t\"0575 lpfc_debugfs_max_nvmeio_trc \"\n\t\t\t\t\t\t\"changed to %d\\n\",\n\t\t\t\t\t\tlpfc_debugfs_max_nvmeio_trc);\n\t\t\t}\n\t\t\tphba->nvmeio_trc_size = lpfc_debugfs_max_nvmeio_trc;\n\n\t\t\t \n\t\t\tphba->nvmeio_trc = kzalloc(\n\t\t\t\t(sizeof(struct lpfc_debugfs_nvmeio_trc) *\n\t\t\t\tphba->nvmeio_trc_size), GFP_KERNEL);\n\n\t\t\tif (!phba->nvmeio_trc) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\t\t\"0576 Cannot create debugfs \"\n\t\t\t\t\t\t\"nvmeio_trc buffer\\n\");\n\t\t\t\tgoto nvmeio_off;\n\t\t\t}\n\t\t\tphba->nvmeio_trc_on = 1;\n\t\t\tphba->nvmeio_trc_output_idx = 0;\n\t\t\tphba->nvmeio_trc = NULL;\n\t\t} else {\nnvmeio_off:\n\t\t\tphba->nvmeio_trc_size = 0;\n\t\t\tphba->nvmeio_trc_on = 0;\n\t\t\tphba->nvmeio_trc_output_idx = 0;\n\t\t\tphba->nvmeio_trc = NULL;\n\t\t}\n\t}\n\n\tsnprintf(name, sizeof(name), \"vport%d\", vport->vpi);\n\tif (!vport->vport_debugfs_root) {\n\t\tvport->vport_debugfs_root =\n\t\t\tdebugfs_create_dir(name, phba->hba_debugfs_root);\n\t\tatomic_inc(&phba->debugfs_vport_count);\n\t}\n\n\tif (lpfc_debugfs_max_disc_trc) {\n\t\tnum = lpfc_debugfs_max_disc_trc - 1;\n\t\tif (num & lpfc_debugfs_max_disc_trc) {\n\t\t\t \n\t\t\tnum = lpfc_debugfs_max_disc_trc;\n\t\t\ti = 0;\n\t\t\twhile (num > 1) {\n\t\t\t\tnum = num >> 1;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tlpfc_debugfs_max_disc_trc = (1 << i);\n\t\t\tpr_err(\"lpfc_debugfs_max_disc_trc changed to %d\\n\",\n\t\t\t       lpfc_debugfs_max_disc_trc);\n\t\t}\n\t}\n\n\tvport->disc_trc = kzalloc(\n\t\t(sizeof(struct lpfc_debugfs_trc) * lpfc_debugfs_max_disc_trc),\n\t\tGFP_KERNEL);\n\n\tif (!vport->disc_trc) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0418 Cannot create debugfs disc trace \"\n\t\t\t\t \"buffer\\n\");\n\t\tgoto debug_failed;\n\t}\n\tatomic_set(&vport->disc_trc_cnt, 0);\n\n\tsnprintf(name, sizeof(name), \"discovery_trace\");\n\tvport->debug_disc_trc =\n\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t vport->vport_debugfs_root,\n\t\t\t\t vport, &lpfc_debugfs_op_disc_trc);\n\tsnprintf(name, sizeof(name), \"nodelist\");\n\tvport->debug_nodelist =\n\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t vport->vport_debugfs_root,\n\t\t\t\t vport, &lpfc_debugfs_op_nodelist);\n\n\tsnprintf(name, sizeof(name), \"nvmestat\");\n\tvport->debug_nvmestat =\n\t\tdebugfs_create_file(name, 0644,\n\t\t\t\t    vport->vport_debugfs_root,\n\t\t\t\t    vport, &lpfc_debugfs_op_nvmestat);\n\n\tsnprintf(name, sizeof(name), \"scsistat\");\n\tvport->debug_scsistat =\n\t\tdebugfs_create_file(name, 0644,\n\t\t\t\t    vport->vport_debugfs_root,\n\t\t\t\t    vport, &lpfc_debugfs_op_scsistat);\n\tif (IS_ERR(vport->debug_scsistat)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"4611 Cannot create debugfs scsistat\\n\");\n\t\tgoto debug_failed;\n\t}\n\n\tsnprintf(name, sizeof(name), \"ioktime\");\n\tvport->debug_ioktime =\n\t\tdebugfs_create_file(name, 0644,\n\t\t\t\t    vport->vport_debugfs_root,\n\t\t\t\t    vport, &lpfc_debugfs_op_ioktime);\n\tif (IS_ERR(vport->debug_ioktime)) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_INIT,\n\t\t\t\t \"0815 Cannot create debugfs ioktime\\n\");\n\t\tgoto debug_failed;\n\t}\n\n\tsnprintf(name, sizeof(name), \"hdwqstat\");\n\tvport->debug_hdwqstat =\n\t\tdebugfs_create_file(name, 0644,\n\t\t\t\t    vport->vport_debugfs_root,\n\t\t\t\t    vport, &lpfc_debugfs_op_hdwqstat);\n\n\t \n\n\tif (!pport_setup)\n\t\tgoto debug_failed;\n\n\t \n\tif (phba->sli_rev < LPFC_SLI_REV4)\n\t\tgoto debug_failed;\n\n\tsnprintf(name, sizeof(name), \"iDiag\");\n\tif (!phba->idiag_root) {\n\t\tphba->idiag_root =\n\t\t\tdebugfs_create_dir(name, phba->hba_debugfs_root);\n\t\t \n\t\tmemset(&idiag, 0, sizeof(idiag));\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"pciCfg\");\n\tif (!phba->idiag_pci_cfg) {\n\t\tphba->idiag_pci_cfg =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\tphba->idiag_root, phba, &lpfc_idiag_op_pciCfg);\n\t\tidiag.offset.last_rd = 0;\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"barAcc\");\n\tif (!phba->idiag_bar_acc) {\n\t\tphba->idiag_bar_acc =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\tphba->idiag_root, phba, &lpfc_idiag_op_barAcc);\n\t\tidiag.offset.last_rd = 0;\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"queInfo\");\n\tif (!phba->idiag_que_info) {\n\t\tphba->idiag_que_info =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO,\n\t\t\tphba->idiag_root, phba, &lpfc_idiag_op_queInfo);\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"queAcc\");\n\tif (!phba->idiag_que_acc) {\n\t\tphba->idiag_que_acc =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\tphba->idiag_root, phba, &lpfc_idiag_op_queAcc);\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"drbAcc\");\n\tif (!phba->idiag_drb_acc) {\n\t\tphba->idiag_drb_acc =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\tphba->idiag_root, phba, &lpfc_idiag_op_drbAcc);\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"ctlAcc\");\n\tif (!phba->idiag_ctl_acc) {\n\t\tphba->idiag_ctl_acc =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\tphba->idiag_root, phba, &lpfc_idiag_op_ctlAcc);\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"mbxAcc\");\n\tif (!phba->idiag_mbx_acc) {\n\t\tphba->idiag_mbx_acc =\n\t\t\tdebugfs_create_file(name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\tphba->idiag_root, phba, &lpfc_idiag_op_mbxAcc);\n\t}\n\n\t \n\tif (phba->sli4_hba.extents_in_use) {\n\t\tsnprintf(name, sizeof(name), \"extAcc\");\n\t\tif (!phba->idiag_ext_acc) {\n\t\t\tphba->idiag_ext_acc =\n\t\t\t\tdebugfs_create_file(name,\n\t\t\t\t\t\t    S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t\t\t\t    phba->idiag_root, phba,\n\t\t\t\t\t\t    &lpfc_idiag_op_extAcc);\n\t\t}\n\t}\n\ndebug_failed:\n\treturn;\n#endif\n}\n\n \ninline void\nlpfc_debugfs_terminate(struct lpfc_vport *vport)\n{\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tkfree(vport->disc_trc);\n\tvport->disc_trc = NULL;\n\n\tdebugfs_remove(vport->debug_disc_trc);  \n\tvport->debug_disc_trc = NULL;\n\n\tdebugfs_remove(vport->debug_nodelist);  \n\tvport->debug_nodelist = NULL;\n\n\tdebugfs_remove(vport->debug_nvmestat);  \n\tvport->debug_nvmestat = NULL;\n\n\tdebugfs_remove(vport->debug_scsistat);  \n\tvport->debug_scsistat = NULL;\n\n\tdebugfs_remove(vport->debug_ioktime);  \n\tvport->debug_ioktime = NULL;\n\n\tdebugfs_remove(vport->debug_hdwqstat);  \n\tvport->debug_hdwqstat = NULL;\n\n\tif (vport->vport_debugfs_root) {\n\t\tdebugfs_remove(vport->vport_debugfs_root);  \n\t\tvport->vport_debugfs_root = NULL;\n\t\tatomic_dec(&phba->debugfs_vport_count);\n\t}\n\n\tif (atomic_read(&phba->debugfs_vport_count) == 0) {\n\n\t\tdebugfs_remove(phba->debug_multixri_pools);  \n\t\tphba->debug_multixri_pools = NULL;\n\n\t\tdebugfs_remove(phba->debug_hbqinfo);  \n\t\tphba->debug_hbqinfo = NULL;\n\n\t\tdebugfs_remove(phba->debug_cgn_buffer);\n\t\tphba->debug_cgn_buffer = NULL;\n\n\t\tdebugfs_remove(phba->debug_rx_monitor);\n\t\tphba->debug_rx_monitor = NULL;\n\n\t\tdebugfs_remove(phba->debug_ras_log);\n\t\tphba->debug_ras_log = NULL;\n\n#ifdef LPFC_HDWQ_LOCK_STAT\n\t\tdebugfs_remove(phba->debug_lockstat);  \n\t\tphba->debug_lockstat = NULL;\n#endif\n\t\tdebugfs_remove(phba->debug_dumpHBASlim);  \n\t\tphba->debug_dumpHBASlim = NULL;\n\n\t\tdebugfs_remove(phba->debug_dumpHostSlim);  \n\t\tphba->debug_dumpHostSlim = NULL;\n\n\t\tdebugfs_remove(phba->debug_InjErrLBA);  \n\t\tphba->debug_InjErrLBA = NULL;\n\n\t\tdebugfs_remove(phba->debug_InjErrNPortID);\n\t\tphba->debug_InjErrNPortID = NULL;\n\n\t\tdebugfs_remove(phba->debug_InjErrWWPN);  \n\t\tphba->debug_InjErrWWPN = NULL;\n\n\t\tdebugfs_remove(phba->debug_writeGuard);  \n\t\tphba->debug_writeGuard = NULL;\n\n\t\tdebugfs_remove(phba->debug_writeApp);  \n\t\tphba->debug_writeApp = NULL;\n\n\t\tdebugfs_remove(phba->debug_writeRef);  \n\t\tphba->debug_writeRef = NULL;\n\n\t\tdebugfs_remove(phba->debug_readGuard);  \n\t\tphba->debug_readGuard = NULL;\n\n\t\tdebugfs_remove(phba->debug_readApp);  \n\t\tphba->debug_readApp = NULL;\n\n\t\tdebugfs_remove(phba->debug_readRef);  \n\t\tphba->debug_readRef = NULL;\n\n\t\tkfree(phba->slow_ring_trc);\n\t\tphba->slow_ring_trc = NULL;\n\n\t\t \n\t\tdebugfs_remove(phba->debug_slow_ring_trc);\n\t\tphba->debug_slow_ring_trc = NULL;\n\n\t\tdebugfs_remove(phba->debug_nvmeio_trc);\n\t\tphba->debug_nvmeio_trc = NULL;\n\n\t\tkfree(phba->nvmeio_trc);\n\t\tphba->nvmeio_trc = NULL;\n\n\t\t \n\t\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_ext_acc);\n\t\t\tphba->idiag_ext_acc = NULL;\n\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_mbx_acc);\n\t\t\tphba->idiag_mbx_acc = NULL;\n\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_ctl_acc);\n\t\t\tphba->idiag_ctl_acc = NULL;\n\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_drb_acc);\n\t\t\tphba->idiag_drb_acc = NULL;\n\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_que_acc);\n\t\t\tphba->idiag_que_acc = NULL;\n\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_que_info);\n\t\t\tphba->idiag_que_info = NULL;\n\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_bar_acc);\n\t\t\tphba->idiag_bar_acc = NULL;\n\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_pci_cfg);\n\t\t\tphba->idiag_pci_cfg = NULL;\n\n\t\t\t \n\t\t\tdebugfs_remove(phba->idiag_root);\n\t\t\tphba->idiag_root = NULL;\n\t\t}\n\n\t\tif (phba->hba_debugfs_root) {\n\t\t\tdebugfs_remove(phba->hba_debugfs_root);  \n\t\t\tphba->hba_debugfs_root = NULL;\n\t\t\tatomic_dec(&lpfc_debugfs_hba_count);\n\t\t}\n\n\t\tif (atomic_read(&lpfc_debugfs_hba_count) == 0) {\n\t\t\tdebugfs_remove(lpfc_debugfs_root);  \n\t\t\tlpfc_debugfs_root = NULL;\n\t\t}\n\t}\n#endif\n\treturn;\n}\n\n \n\n \nvoid\nlpfc_debug_dump_all_queues(struct lpfc_hba *phba)\n{\n\tint idx;\n\n\t \n\tlpfc_debug_dump_wq(phba, DUMP_MBX, 0);\n\tlpfc_debug_dump_wq(phba, DUMP_ELS, 0);\n\tlpfc_debug_dump_wq(phba, DUMP_NVMELS, 0);\n\n\tfor (idx = 0; idx < phba->cfg_hdw_queue; idx++)\n\t\tlpfc_debug_dump_wq(phba, DUMP_IO, idx);\n\n\tlpfc_debug_dump_hdr_rq(phba);\n\tlpfc_debug_dump_dat_rq(phba);\n\t \n\tlpfc_debug_dump_cq(phba, DUMP_MBX, 0);\n\tlpfc_debug_dump_cq(phba, DUMP_ELS, 0);\n\tlpfc_debug_dump_cq(phba, DUMP_NVMELS, 0);\n\n\tfor (idx = 0; idx < phba->cfg_hdw_queue; idx++)\n\t\tlpfc_debug_dump_cq(phba, DUMP_IO, idx);\n\n\t \n\tfor (idx = 0; idx < phba->cfg_hdw_queue; idx++)\n\t\tlpfc_debug_dump_hba_eq(phba, idx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}