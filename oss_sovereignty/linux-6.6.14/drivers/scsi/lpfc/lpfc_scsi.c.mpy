{
  "module_name": "lpfc_scsi.c",
  "hash_id": "f0244548341e846cdb12985fe1dac0f63617f522d83bf27aaab95a0283f0e88c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/lpfc/lpfc_scsi.c",
  "human_readable_source": " \n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <asm/unaligned.h>\n#include <linux/t10-pi.h>\n#include <linux/crc-t10dif.h>\n#include <linux/blk-cgroup.h>\n#include <net/checksum.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport_fc.h>\n\n#include \"lpfc_version.h\"\n#include \"lpfc_hw4.h\"\n#include \"lpfc_hw.h\"\n#include \"lpfc_sli.h\"\n#include \"lpfc_sli4.h\"\n#include \"lpfc_nl.h\"\n#include \"lpfc_disc.h\"\n#include \"lpfc.h\"\n#include \"lpfc_scsi.h\"\n#include \"lpfc_logmsg.h\"\n#include \"lpfc_crtn.h\"\n#include \"lpfc_vport.h\"\n\n#define LPFC_RESET_WAIT  2\n#define LPFC_ABORT_WAIT  2\n\nstatic char *dif_op_str[] = {\n\t\"PROT_NORMAL\",\n\t\"PROT_READ_INSERT\",\n\t\"PROT_WRITE_STRIP\",\n\t\"PROT_READ_STRIP\",\n\t\"PROT_WRITE_INSERT\",\n\t\"PROT_READ_PASS\",\n\t\"PROT_WRITE_PASS\",\n};\n\nstruct scsi_dif_tuple {\n\t__be16 guard_tag;        \n\t__be16 app_tag;          \n\t__be32 ref_tag;          \n};\n\nstatic struct lpfc_rport_data *\nlpfc_rport_data_from_scsi_device(struct scsi_device *sdev)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *)sdev->host->hostdata;\n\n\tif (vport->phba->cfg_fof)\n\t\treturn ((struct lpfc_device_data *)sdev->hostdata)->rport_data;\n\telse\n\t\treturn (struct lpfc_rport_data *)sdev->hostdata;\n}\n\nstatic void\nlpfc_release_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_io_buf *psb);\nstatic void\nlpfc_release_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_io_buf *psb);\nstatic int\nlpfc_prot_group_type(struct lpfc_hba *phba, struct scsi_cmnd *sc);\n\n \nstatic void\nlpfc_sli4_set_rsp_sgl_last(struct lpfc_hba *phba,\n\t\t\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct sli4_sge *sgl = (struct sli4_sge *)lpfc_cmd->dma_sgl;\n\tif (sgl) {\n\t\tsgl += 1;\n\t\tsgl->word2 = le32_to_cpu(sgl->word2);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t}\n}\n\n \nvoid\nlpfc_rampdown_queue_depth(struct lpfc_hba *phba)\n{\n\tunsigned long flags;\n\tuint32_t evt_posted;\n\tunsigned long expires;\n\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tatomic_inc(&phba->num_rsrc_err);\n\tphba->last_rsrc_error_time = jiffies;\n\n\texpires = phba->last_ramp_down_time + QUEUE_RAMP_DOWN_INTERVAL;\n\tif (time_after(expires, jiffies)) {\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\treturn;\n\t}\n\n\tphba->last_ramp_down_time = jiffies;\n\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\n\tspin_lock_irqsave(&phba->pport->work_port_lock, flags);\n\tevt_posted = phba->pport->work_port_events & WORKER_RAMP_DOWN_QUEUE;\n\tif (!evt_posted)\n\t\tphba->pport->work_port_events |= WORKER_RAMP_DOWN_QUEUE;\n\tspin_unlock_irqrestore(&phba->pport->work_port_lock, flags);\n\n\tif (!evt_posted)\n\t\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n \nvoid\nlpfc_ramp_down_queue_handler(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct Scsi_Host  *shost;\n\tstruct scsi_device *sdev;\n\tunsigned long new_queue_depth;\n\tunsigned long num_rsrc_err, num_cmd_success;\n\tint i;\n\n\tnum_rsrc_err = atomic_read(&phba->num_rsrc_err);\n\tnum_cmd_success = atomic_read(&phba->num_cmd_success);\n\n\t \n\tif (num_rsrc_err == 0)\n\t\treturn;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL)\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tshost_for_each_device(sdev, shost) {\n\t\t\t\tnew_queue_depth =\n\t\t\t\t\tsdev->queue_depth * num_rsrc_err /\n\t\t\t\t\t(num_rsrc_err + num_cmd_success);\n\t\t\t\tif (!new_queue_depth)\n\t\t\t\t\tnew_queue_depth = sdev->queue_depth - 1;\n\t\t\t\telse\n\t\t\t\t\tnew_queue_depth = sdev->queue_depth -\n\t\t\t\t\t\t\t\tnew_queue_depth;\n\t\t\t\tscsi_change_queue_depth(sdev, new_queue_depth);\n\t\t\t}\n\t\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n\tatomic_set(&phba->num_rsrc_err, 0);\n\tatomic_set(&phba->num_cmd_success, 0);\n}\n\n \nvoid\nlpfc_scsi_dev_block(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct Scsi_Host  *shost;\n\tstruct scsi_device *sdev;\n\tstruct fc_rport *rport;\n\tint i;\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL)\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tshost_for_each_device(sdev, shost) {\n\t\t\t\trport = starget_to_rport(scsi_target(sdev));\n\t\t\t\tfc_remote_port_delete(rport);\n\t\t\t}\n\t\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\n \nstatic int\nlpfc_new_scsi_buf_s3(struct lpfc_vport *vport, int num_to_alloc)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_io_buf *psb;\n\tstruct ulp_bde64 *bpl;\n\tIOCB_t *iocb;\n\tdma_addr_t pdma_phys_fcp_cmd;\n\tdma_addr_t pdma_phys_fcp_rsp;\n\tdma_addr_t pdma_phys_sgl;\n\tuint16_t iotag;\n\tint bcnt, bpl_size;\n\n\tbpl_size = phba->cfg_sg_dma_buf_size -\n\t\t(sizeof(struct fcp_cmnd) + sizeof(struct fcp_rsp));\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t \"9067 ALLOC %d scsi_bufs: %d (%d + %d + %d)\\n\",\n\t\t\t num_to_alloc, phba->cfg_sg_dma_buf_size,\n\t\t\t (int)sizeof(struct fcp_cmnd),\n\t\t\t (int)sizeof(struct fcp_rsp), bpl_size);\n\n\tfor (bcnt = 0; bcnt < num_to_alloc; bcnt++) {\n\t\tpsb = kzalloc(sizeof(struct lpfc_io_buf), GFP_KERNEL);\n\t\tif (!psb)\n\t\t\tbreak;\n\n\t\t \n\t\tpsb->data = dma_pool_zalloc(phba->lpfc_sg_dma_buf_pool,\n\t\t\t\t\tGFP_KERNEL, &psb->dma_handle);\n\t\tif (!psb->data) {\n\t\t\tkfree(psb);\n\t\t\tbreak;\n\t\t}\n\n\n\t\t \n\t\tiotag = lpfc_sli_next_iotag(phba, &psb->cur_iocbq);\n\t\tif (iotag == 0) {\n\t\t\tdma_pool_free(phba->lpfc_sg_dma_buf_pool,\n\t\t\t\t      psb->data, psb->dma_handle);\n\t\t\tkfree(psb);\n\t\t\tbreak;\n\t\t}\n\t\tpsb->cur_iocbq.cmd_flag |= LPFC_IO_FCP;\n\n\t\tpsb->fcp_cmnd = psb->data;\n\t\tpsb->fcp_rsp = psb->data + sizeof(struct fcp_cmnd);\n\t\tpsb->dma_sgl = psb->data + sizeof(struct fcp_cmnd) +\n\t\t\tsizeof(struct fcp_rsp);\n\n\t\t \n\t\tbpl = (struct ulp_bde64 *)psb->dma_sgl;\n\t\tpdma_phys_fcp_cmd = psb->dma_handle;\n\t\tpdma_phys_fcp_rsp = psb->dma_handle + sizeof(struct fcp_cmnd);\n\t\tpdma_phys_sgl = psb->dma_handle + sizeof(struct fcp_cmnd) +\n\t\t\tsizeof(struct fcp_rsp);\n\n\t\t \n\t\tbpl[0].addrHigh = le32_to_cpu(putPaddrHigh(pdma_phys_fcp_cmd));\n\t\tbpl[0].addrLow = le32_to_cpu(putPaddrLow(pdma_phys_fcp_cmd));\n\t\tbpl[0].tus.f.bdeSize = sizeof(struct fcp_cmnd);\n\t\tbpl[0].tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\tbpl[0].tus.w = le32_to_cpu(bpl[0].tus.w);\n\n\t\t \n\t\tbpl[1].addrHigh = le32_to_cpu(putPaddrHigh(pdma_phys_fcp_rsp));\n\t\tbpl[1].addrLow = le32_to_cpu(putPaddrLow(pdma_phys_fcp_rsp));\n\t\tbpl[1].tus.f.bdeSize = sizeof(struct fcp_rsp);\n\t\tbpl[1].tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\tbpl[1].tus.w = le32_to_cpu(bpl[1].tus.w);\n\n\t\t \n\t\tiocb = &psb->cur_iocbq.iocb;\n\t\tiocb->un.fcpi64.bdl.ulpIoTag32 = 0;\n\t\tif ((phba->sli_rev == 3) &&\n\t\t\t\t!(phba->sli3_options & LPFC_SLI3_BG_ENABLED)) {\n\t\t\t \n\t\t\tiocb->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BDE_IMMED;\n\t\t\tiocb->un.fcpi64.bdl.bdeSize = sizeof(struct fcp_cmnd);\n\t\t\tiocb->un.fcpi64.bdl.addrLow = offsetof(IOCB_t,\n\t\t\t\t\tunsli3.fcp_ext.icd);\n\t\t\tiocb->un.fcpi64.bdl.addrHigh = 0;\n\t\t\tiocb->ulpBdeCount = 0;\n\t\t\tiocb->ulpLe = 0;\n\t\t\t \n\t\t\tiocb->unsli3.fcp_ext.rbde.tus.f.bdeFlags =\n\t\t\t\t\t\t\tBUFF_TYPE_BDE_64;\n\t\t\tiocb->unsli3.fcp_ext.rbde.tus.f.bdeSize =\n\t\t\t\tsizeof(struct fcp_rsp);\n\t\t\tiocb->unsli3.fcp_ext.rbde.addrLow =\n\t\t\t\tputPaddrLow(pdma_phys_fcp_rsp);\n\t\t\tiocb->unsli3.fcp_ext.rbde.addrHigh =\n\t\t\t\tputPaddrHigh(pdma_phys_fcp_rsp);\n\t\t} else {\n\t\t\tiocb->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\n\t\t\tiocb->un.fcpi64.bdl.bdeSize =\n\t\t\t\t\t(2 * sizeof(struct ulp_bde64));\n\t\t\tiocb->un.fcpi64.bdl.addrLow =\n\t\t\t\t\tputPaddrLow(pdma_phys_sgl);\n\t\t\tiocb->un.fcpi64.bdl.addrHigh =\n\t\t\t\t\tputPaddrHigh(pdma_phys_sgl);\n\t\t\tiocb->ulpBdeCount = 1;\n\t\t\tiocb->ulpLe = 1;\n\t\t}\n\t\tiocb->ulpClass = CLASS3;\n\t\tpsb->status = IOSTAT_SUCCESS;\n\t\t \n\t\tpsb->cur_iocbq.io_buf = psb;\n\t\tspin_lock_init(&psb->buf_lock);\n\t\tlpfc_release_scsi_buf_s3(phba, psb);\n\n\t}\n\n\treturn bcnt;\n}\n\n \nvoid\nlpfc_sli4_vport_delete_fcp_xri_aborted(struct lpfc_vport *vport)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct lpfc_io_buf *psb, *next_psb;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tunsigned long iflag = 0;\n\tint idx;\n\n\tif (!(vport->cfg_enable_fc4_type & LPFC_ENABLE_FCP))\n\t\treturn;\n\n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\tfor (idx = 0; idx < phba->cfg_hdw_queue; idx++) {\n\t\tqp = &phba->sli4_hba.hdwq[idx];\n\n\t\tspin_lock(&qp->abts_io_buf_list_lock);\n\t\tlist_for_each_entry_safe(psb, next_psb,\n\t\t\t\t\t &qp->lpfc_abts_io_buf_list, list) {\n\t\t\tif (psb->cur_iocbq.cmd_flag & LPFC_IO_NVME)\n\t\t\t\tcontinue;\n\n\t\t\tif (psb->rdata && psb->rdata->pnode &&\n\t\t\t    psb->rdata->pnode->vport == vport)\n\t\t\t\tpsb->rdata = NULL;\n\t\t}\n\t\tspin_unlock(&qp->abts_io_buf_list_lock);\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n}\n\n \nvoid\nlpfc_sli4_io_xri_aborted(struct lpfc_hba *phba,\n\t\t\t struct sli4_wcqe_xri_aborted *axri, int idx)\n{\n\tu16 xri = 0;\n\tu16 rxid = 0;\n\tstruct lpfc_io_buf *psb, *next_psb;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tunsigned long iflag = 0;\n\tstruct lpfc_iocbq *iocbq;\n\tint i;\n\tstruct lpfc_nodelist *ndlp;\n\tint rrq_empty = 0;\n\tstruct lpfc_sli_ring *pring = phba->sli4_hba.els_wq->pring;\n\tstruct scsi_cmnd *cmd;\n\tint offline = 0;\n\n\tif (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP))\n\t\treturn;\n\toffline = pci_channel_offline(phba->pcidev);\n\tif (!offline) {\n\t\txri = bf_get(lpfc_wcqe_xa_xri, axri);\n\t\trxid = bf_get(lpfc_wcqe_xa_remote_xid, axri);\n\t}\n\tqp = &phba->sli4_hba.hdwq[idx];\n\tspin_lock_irqsave(&phba->hbalock, iflag);\n\tspin_lock(&qp->abts_io_buf_list_lock);\n\tlist_for_each_entry_safe(psb, next_psb,\n\t\t&qp->lpfc_abts_io_buf_list, list) {\n\t\tif (offline)\n\t\t\txri = psb->cur_iocbq.sli4_xritag;\n\t\tif (psb->cur_iocbq.sli4_xritag == xri) {\n\t\t\tlist_del_init(&psb->list);\n\t\t\tpsb->flags &= ~LPFC_SBUF_XBUSY;\n\t\t\tpsb->status = IOSTAT_SUCCESS;\n\t\t\tif (psb->cur_iocbq.cmd_flag & LPFC_IO_NVME) {\n\t\t\t\tqp->abts_nvme_io_bufs--;\n\t\t\t\tspin_unlock(&qp->abts_io_buf_list_lock);\n\t\t\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\t\t\tif (!offline) {\n\t\t\t\t\tlpfc_sli4_nvme_xri_aborted(phba, axri,\n\t\t\t\t\t\t\t\t   psb);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlpfc_sli4_nvme_pci_offline_aborted(phba, psb);\n\t\t\t\tspin_lock_irqsave(&phba->hbalock, iflag);\n\t\t\t\tspin_lock(&qp->abts_io_buf_list_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqp->abts_scsi_io_bufs--;\n\t\t\tspin_unlock(&qp->abts_io_buf_list_lock);\n\n\t\t\tif (psb->rdata && psb->rdata->pnode)\n\t\t\t\tndlp = psb->rdata->pnode;\n\t\t\telse\n\t\t\t\tndlp = NULL;\n\n\t\t\trrq_empty = list_empty(&phba->active_rrq_list);\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\t\tif (ndlp && !offline) {\n\t\t\t\tlpfc_set_rrq_active(phba, ndlp,\n\t\t\t\t\tpsb->cur_iocbq.sli4_lxritag, rxid, 1);\n\t\t\t\tlpfc_sli4_abts_err_handler(phba, ndlp, axri);\n\t\t\t}\n\n\t\t\tif (phba->cfg_fcp_wait_abts_rsp || offline) {\n\t\t\t\tspin_lock_irqsave(&psb->buf_lock, iflag);\n\t\t\t\tcmd = psb->pCmd;\n\t\t\t\tpsb->pCmd = NULL;\n\t\t\t\tspin_unlock_irqrestore(&psb->buf_lock, iflag);\n\n\t\t\t\t \n\t\t\t\tif (cmd)\n\t\t\t\t\tscsi_done(cmd);\n\n\t\t\t\t \n\t\t\t\tspin_lock_irqsave(&psb->buf_lock, iflag);\n\t\t\t\tpsb->cur_iocbq.cmd_flag &=\n\t\t\t\t\t~LPFC_DRIVER_ABORTED;\n\t\t\t\tif (psb->waitq)\n\t\t\t\t\twake_up(psb->waitq);\n\t\t\t\tspin_unlock_irqrestore(&psb->buf_lock, iflag);\n\t\t\t}\n\n\t\t\tlpfc_release_scsi_buf_s4(phba, psb);\n\t\t\tif (rrq_empty)\n\t\t\t\tlpfc_worker_wake_up(phba);\n\t\t\tif (!offline)\n\t\t\t\treturn;\n\t\t\tspin_lock_irqsave(&phba->hbalock, iflag);\n\t\t\tspin_lock(&qp->abts_io_buf_list_lock);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tspin_unlock(&qp->abts_io_buf_list_lock);\n\tif (!offline) {\n\t\tfor (i = 1; i <= phba->sli.last_iotag; i++) {\n\t\t\tiocbq = phba->sli.iocbq_lookup[i];\n\n\t\t\tif (!(iocbq->cmd_flag & LPFC_IO_FCP) ||\n\t\t\t    (iocbq->cmd_flag & LPFC_IO_LIBDFC))\n\t\t\t\tcontinue;\n\t\t\tif (iocbq->sli4_xritag != xri)\n\t\t\t\tcontinue;\n\t\t\tpsb = container_of(iocbq, struct lpfc_io_buf, cur_iocbq);\n\t\t\tpsb->flags &= ~LPFC_SBUF_XBUSY;\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n\t\t\tif (!list_empty(&pring->txq))\n\t\t\t\tlpfc_worker_wake_up(phba);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->hbalock, iflag);\n}\n\n \nstatic struct lpfc_io_buf *\nlpfc_get_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,\n\t\t     struct scsi_cmnd *cmnd)\n{\n\tstruct lpfc_io_buf *lpfc_cmd = NULL;\n\tstruct list_head *scsi_buf_list_get = &phba->lpfc_scsi_buf_list_get;\n\tunsigned long iflag = 0;\n\n\tspin_lock_irqsave(&phba->scsi_buf_list_get_lock, iflag);\n\tlist_remove_head(scsi_buf_list_get, lpfc_cmd, struct lpfc_io_buf,\n\t\t\t list);\n\tif (!lpfc_cmd) {\n\t\tspin_lock(&phba->scsi_buf_list_put_lock);\n\t\tlist_splice(&phba->lpfc_scsi_buf_list_put,\n\t\t\t    &phba->lpfc_scsi_buf_list_get);\n\t\tINIT_LIST_HEAD(&phba->lpfc_scsi_buf_list_put);\n\t\tlist_remove_head(scsi_buf_list_get, lpfc_cmd,\n\t\t\t\t struct lpfc_io_buf, list);\n\t\tspin_unlock(&phba->scsi_buf_list_put_lock);\n\t}\n\tspin_unlock_irqrestore(&phba->scsi_buf_list_get_lock, iflag);\n\n\tif (lpfc_ndlp_check_qdepth(phba, ndlp) && lpfc_cmd) {\n\t\tatomic_inc(&ndlp->cmd_pending);\n\t\tlpfc_cmd->flags |= LPFC_SBUF_BUMP_QDEPTH;\n\t}\n\treturn  lpfc_cmd;\n}\n \nstatic struct lpfc_io_buf *\nlpfc_get_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,\n\t\t     struct scsi_cmnd *cmnd)\n{\n\tstruct lpfc_io_buf *lpfc_cmd;\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tstruct sli4_sge *sgl;\n\tdma_addr_t pdma_phys_fcp_rsp;\n\tdma_addr_t pdma_phys_fcp_cmd;\n\tuint32_t cpu, idx;\n\tint tag;\n\tstruct fcp_cmd_rsp_buf *tmp = NULL;\n\n\tcpu = raw_smp_processor_id();\n\tif (cmnd && phba->cfg_fcp_io_sched == LPFC_FCP_SCHED_BY_HDWQ) {\n\t\ttag = blk_mq_unique_tag(scsi_cmd_to_rq(cmnd));\n\t\tidx = blk_mq_unique_tag_to_hwq(tag);\n\t} else {\n\t\tidx = phba->sli4_hba.cpu_map[cpu].hdwq;\n\t}\n\n\tlpfc_cmd = lpfc_get_io_buf(phba, ndlp, idx,\n\t\t\t\t   !phba->cfg_xri_rebalancing);\n\tif (!lpfc_cmd) {\n\t\tqp = &phba->sli4_hba.hdwq[idx];\n\t\tqp->empty_io_bufs++;\n\t\treturn NULL;\n\t}\n\n\t \n\tlpfc_cmd->cur_iocbq.cmd_flag = LPFC_IO_FCP;\n\tlpfc_cmd->prot_seg_cnt = 0;\n\tlpfc_cmd->seg_cnt = 0;\n\tlpfc_cmd->timeout = 0;\n\tlpfc_cmd->flags = 0;\n\tlpfc_cmd->start_time = jiffies;\n\tlpfc_cmd->waitq = NULL;\n\tlpfc_cmd->cpu = cpu;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tlpfc_cmd->prot_data_type = 0;\n#endif\n\ttmp = lpfc_get_cmd_rsp_buf_per_hdwq(phba, lpfc_cmd);\n\tif (!tmp) {\n\t\tlpfc_release_io_buf(phba, lpfc_cmd, lpfc_cmd->hdwq);\n\t\treturn NULL;\n\t}\n\n\tlpfc_cmd->fcp_cmnd = tmp->fcp_cmnd;\n\tlpfc_cmd->fcp_rsp = tmp->fcp_rsp;\n\n\t \n\tsgl = (struct sli4_sge *)lpfc_cmd->dma_sgl;\n\tpdma_phys_fcp_cmd = tmp->fcp_cmd_rsp_dma_handle;\n\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(pdma_phys_fcp_cmd));\n\tsgl->addr_lo = cpu_to_le32(putPaddrLow(pdma_phys_fcp_cmd));\n\tsgl->word2 = le32_to_cpu(sgl->word2);\n\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\tsgl->word2 = cpu_to_le32(sgl->word2);\n\tsgl->sge_len = cpu_to_le32(sizeof(struct fcp_cmnd));\n\tsgl++;\n\n\t \n\tpdma_phys_fcp_rsp = pdma_phys_fcp_cmd + sizeof(struct fcp_cmnd);\n\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(pdma_phys_fcp_rsp));\n\tsgl->addr_lo = cpu_to_le32(putPaddrLow(pdma_phys_fcp_rsp));\n\tsgl->word2 = le32_to_cpu(sgl->word2);\n\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\tsgl->word2 = cpu_to_le32(sgl->word2);\n\tsgl->sge_len = cpu_to_le32(sizeof(struct fcp_rsp));\n\n\tif (lpfc_ndlp_check_qdepth(phba, ndlp)) {\n\t\tatomic_inc(&ndlp->cmd_pending);\n\t\tlpfc_cmd->flags |= LPFC_SBUF_BUMP_QDEPTH;\n\t}\n\treturn  lpfc_cmd;\n}\n \nstatic struct lpfc_io_buf*\nlpfc_get_scsi_buf(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp,\n\t\t  struct scsi_cmnd *cmnd)\n{\n\treturn  phba->lpfc_get_scsi_buf(phba, ndlp, cmnd);\n}\n\n \nstatic void\nlpfc_release_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_io_buf *psb)\n{\n\tunsigned long iflag = 0;\n\n\tpsb->seg_cnt = 0;\n\tpsb->prot_seg_cnt = 0;\n\n\tspin_lock_irqsave(&phba->scsi_buf_list_put_lock, iflag);\n\tpsb->pCmd = NULL;\n\tpsb->cur_iocbq.cmd_flag = LPFC_IO_FCP;\n\tlist_add_tail(&psb->list, &phba->lpfc_scsi_buf_list_put);\n\tspin_unlock_irqrestore(&phba->scsi_buf_list_put_lock, iflag);\n}\n\n \nstatic void\nlpfc_release_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_io_buf *psb)\n{\n\tstruct lpfc_sli4_hdw_queue *qp;\n\tunsigned long iflag = 0;\n\n\tpsb->seg_cnt = 0;\n\tpsb->prot_seg_cnt = 0;\n\n\tqp = psb->hdwq;\n\tif (psb->flags & LPFC_SBUF_XBUSY) {\n\t\tspin_lock_irqsave(&qp->abts_io_buf_list_lock, iflag);\n\t\tif (!phba->cfg_fcp_wait_abts_rsp)\n\t\t\tpsb->pCmd = NULL;\n\t\tlist_add_tail(&psb->list, &qp->lpfc_abts_io_buf_list);\n\t\tqp->abts_scsi_io_bufs++;\n\t\tspin_unlock_irqrestore(&qp->abts_io_buf_list_lock, iflag);\n\t} else {\n\t\tlpfc_release_io_buf(phba, (struct lpfc_io_buf *)psb, qp);\n\t}\n}\n\n \nstatic void\nlpfc_release_scsi_buf(struct lpfc_hba *phba, struct lpfc_io_buf *psb)\n{\n\tif ((psb->flags & LPFC_SBUF_BUMP_QDEPTH) && psb->ndlp)\n\t\tatomic_dec(&psb->ndlp->cmd_pending);\n\n\tpsb->flags &= ~LPFC_SBUF_BUMP_QDEPTH;\n\tphba->lpfc_release_scsi_buf(phba, psb);\n}\n\n \nstatic void\nlpfc_fcpcmd_to_iocb(u8 *data, struct fcp_cmnd *fcp_cmnd)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < sizeof(struct fcp_cmnd);\n\t     i += sizeof(uint32_t), j++) {\n\t\t((uint32_t *)data)[j] = cpu_to_be32(((uint32_t *)fcp_cmnd)[j]);\n\t}\n}\n\n \nstatic int\nlpfc_scsi_prep_dma_buf_s3(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct scatterlist *sgel = NULL;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct ulp_bde64 *bpl = (struct ulp_bde64 *)lpfc_cmd->dma_sgl;\n\tstruct lpfc_iocbq *iocbq = &lpfc_cmd->cur_iocbq;\n\tIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\n\tstruct ulp_bde64 *data_bde = iocb_cmd->unsli3.fcp_ext.dbde;\n\tdma_addr_t physaddr;\n\tuint32_t num_bde = 0;\n\tint nseg, datadir = scsi_cmnd->sc_data_direction;\n\n\t \n\tbpl += 2;\n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\t \n\n\t\tnseg = dma_map_sg(&phba->pcidev->dev, scsi_sglist(scsi_cmnd),\n\t\t\t\t  scsi_sg_count(scsi_cmnd), datadir);\n\t\tif (unlikely(!nseg))\n\t\t\treturn 1;\n\n\t\tlpfc_cmd->seg_cnt = nseg;\n\t\tif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9064 BLKGRD: %s: Too many sg segments\"\n\t\t\t\t\t\" from dma_map_sg.  Config %d, seg_cnt\"\n\t\t\t\t\t\" %d\\n\", __func__, phba->cfg_sg_seg_cnt,\n\t\t\t\t\tlpfc_cmd->seg_cnt);\n\t\t\tWARN_ON_ONCE(lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt);\n\t\t\tlpfc_cmd->seg_cnt = 0;\n\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\treturn 2;\n\t\t}\n\n\t\t \n\t\tscsi_for_each_sg(scsi_cmnd, sgel, nseg, num_bde) {\n\t\t\tphysaddr = sg_dma_address(sgel);\n\t\t\tif (phba->sli_rev == 3 &&\n\t\t\t    !(phba->sli3_options & LPFC_SLI3_BG_ENABLED) &&\n\t\t\t    !(iocbq->cmd_flag & DSS_SECURITY_OP) &&\n\t\t\t    nseg <= LPFC_EXT_DATA_BDE_COUNT) {\n\t\t\t\tdata_bde->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\t\tdata_bde->tus.f.bdeSize = sg_dma_len(sgel);\n\t\t\t\tdata_bde->addrLow = putPaddrLow(physaddr);\n\t\t\t\tdata_bde->addrHigh = putPaddrHigh(physaddr);\n\t\t\t\tdata_bde++;\n\t\t\t} else {\n\t\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\t\tbpl->tus.f.bdeSize = sg_dma_len(sgel);\n\t\t\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t\t\t\tbpl->addrLow =\n\t\t\t\t\tle32_to_cpu(putPaddrLow(physaddr));\n\t\t\t\tbpl->addrHigh =\n\t\t\t\t\tle32_to_cpu(putPaddrHigh(physaddr));\n\t\t\t\tbpl++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (phba->sli_rev == 3 &&\n\t    !(phba->sli3_options & LPFC_SLI3_BG_ENABLED) &&\n\t    !(iocbq->cmd_flag & DSS_SECURITY_OP)) {\n\t\tif (num_bde > LPFC_EXT_DATA_BDE_COUNT) {\n\t\t\t \n\t\t\tphysaddr = lpfc_cmd->dma_handle;\n\t\t\tdata_bde->tus.f.bdeFlags = BUFF_TYPE_BLP_64;\n\t\t\tdata_bde->tus.f.bdeSize = (num_bde *\n\t\t\t\t\t\t   sizeof(struct ulp_bde64));\n\t\t\tphysaddr += (sizeof(struct fcp_cmnd) +\n\t\t\t\t     sizeof(struct fcp_rsp) +\n\t\t\t\t     (2 * sizeof(struct ulp_bde64)));\n\t\t\tdata_bde->addrHigh = putPaddrHigh(physaddr);\n\t\t\tdata_bde->addrLow = putPaddrLow(physaddr);\n\t\t\t \n\t\t\tiocb_cmd->unsli3.fcp_ext.ebde_count = 2;\n\t\t} else {\n\t\t\t \n\t\t\tiocb_cmd->unsli3.fcp_ext.ebde_count = (num_bde + 1);\n\t\t}\n\t} else {\n\t\tiocb_cmd->un.fcpi64.bdl.bdeSize =\n\t\t\t((num_bde + 2) * sizeof(struct ulp_bde64));\n\t\tiocb_cmd->unsli3.fcp_ext.ebde_count = (num_bde + 1);\n\t}\n\tfcp_cmnd->fcpDl = cpu_to_be32(scsi_bufflen(scsi_cmnd));\n\n\t \n\tiocb_cmd->un.fcpi.fcpi_parm = scsi_bufflen(scsi_cmnd);\n\tlpfc_fcpcmd_to_iocb(iocb_cmd->unsli3.fcp_ext.icd, fcp_cmnd);\n\treturn 0;\n}\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\n \n#define BG_ERR_INIT\t0x1\n \n#define BG_ERR_TGT\t0x2\n \n#define BG_ERR_SWAP\t0x10\n \n#define BG_ERR_CHECK\t0x20\n\n \nstatic int\nlpfc_bg_err_inject(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tuint32_t *reftag, uint16_t *apptag, uint32_t new_guard)\n{\n\tstruct scatterlist *sgpe;  \n\tstruct lpfc_io_buf *lpfc_cmd = NULL;\n\tstruct scsi_dif_tuple *src = NULL;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_rport_data *rdata;\n\tuint32_t op = scsi_get_prot_op(sc);\n\tuint32_t blksize;\n\tuint32_t numblks;\n\tu32 lba;\n\tint rc = 0;\n\tint blockoff = 0;\n\n\tif (op == SCSI_PROT_NORMAL)\n\t\treturn 0;\n\n\tsgpe = scsi_prot_sglist(sc);\n\tlba = scsi_prot_ref_tag(sc);\n\n\t \n\tif (phba->lpfc_injerr_lba != LPFC_INJERR_LBA_OFF) {\n\t\tblksize = scsi_prot_interval(sc);\n\t\tnumblks = (scsi_bufflen(sc) + blksize - 1) / blksize;\n\n\t\t \n\t\tif (phba->lpfc_injerr_lba < (u64)lba ||\n\t\t    (phba->lpfc_injerr_lba >= (u64)(lba + numblks)))\n\t\t\treturn 0;\n\t\tif (sgpe) {\n\t\t\tblockoff = phba->lpfc_injerr_lba - (u64)lba;\n\t\t\tnumblks = sg_dma_len(sgpe) /\n\t\t\t\tsizeof(struct scsi_dif_tuple);\n\t\t\tif (numblks < blockoff)\n\t\t\t\tblockoff = numblks;\n\t\t}\n\t}\n\n\t \n\trdata = lpfc_rport_data_from_scsi_device(sc->device);\n\tif (rdata && rdata->pnode) {\n\t\tndlp = rdata->pnode;\n\n\t\t \n\t\tif (phba->lpfc_injerr_nportid  &&\n\t\t\t(phba->lpfc_injerr_nportid != ndlp->nlp_DID))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (phba->lpfc_injerr_wwpn.u.wwn[0]  &&\n\t\t\t(memcmp(&ndlp->nlp_portname, &phba->lpfc_injerr_wwpn,\n\t\t\t\tsizeof(struct lpfc_name)) != 0))\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (sgpe) {\n\t\tsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\n\t\tsrc += blockoff;\n\t\tlpfc_cmd = (struct lpfc_io_buf *)sc->host_scribble;\n\t}\n\n\t \n\tif (reftag) {\n\t\tif (phba->lpfc_injerr_wref_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t\tif (src) {\n\t\t\t\t\t \n\n\t\t\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"9076 BLKGRD: Injecting reftag error: \"\n\t\t\t\t\t\"write lba x%lx + x%x oldrefTag x%x\\n\",\n\t\t\t\t\t(unsigned long)lba, blockoff,\n\t\t\t\t\tbe32_to_cpu(src->ref_tag));\n\n\t\t\t\t\t \n\t\t\t\t\tif (lpfc_cmd) {\n\t\t\t\t\t\tlpfc_cmd->prot_data_type =\n\t\t\t\t\t\t\tLPFC_INJERR_REFTAG;\n\t\t\t\t\t\tlpfc_cmd->prot_data_segment =\n\t\t\t\t\t\t\tsrc;\n\t\t\t\t\t\tlpfc_cmd->prot_data =\n\t\t\t\t\t\t\tsrc->ref_tag;\n\t\t\t\t\t}\n\t\t\t\t\tsrc->ref_tag = cpu_to_be32(0xDEADBEEF);\n\t\t\t\t\tphba->lpfc_injerr_wref_cnt--;\n\t\t\t\t\tif (phba->lpfc_injerr_wref_cnt == 0) {\n\t\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t  0, sizeof(struct lpfc_name));\n\t\t\t\t\t}\n\t\t\t\t\trc = BG_ERR_TGT | BG_ERR_CHECK;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t*reftag = 0xDEADBEEF;\n\t\t\t\tphba->lpfc_injerr_wref_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wref_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_TGT | BG_ERR_CHECK;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9078 BLKGRD: Injecting reftag error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t\t \n\t\t\t\t*reftag = 0xDEADBEEF;\n\t\t\t\tphba->lpfc_injerr_wref_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wref_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_INIT;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9077 BLKGRD: Injecting reftag error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (phba->lpfc_injerr_rref_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_READ_INSERT:\n\t\t\tcase SCSI_PROT_READ_STRIP:\n\t\t\tcase SCSI_PROT_READ_PASS:\n\t\t\t\t \n\t\t\t\t*reftag = 0xDEADBEEF;\n\t\t\t\tphba->lpfc_injerr_rref_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_rref_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_INIT;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9079 BLKGRD: Injecting reftag error: \"\n\t\t\t\t\t\"read lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (apptag) {\n\t\tif (phba->lpfc_injerr_wapp_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t\tif (src) {\n\t\t\t\t\t \n\n\t\t\t\t\tlpfc_printf_log(phba, KERN_ERR,\n\t\t\t\t\t\t\tLOG_TRACE_EVENT,\n\t\t\t\t\t\"9080 BLKGRD: Injecting apptag error: \"\n\t\t\t\t\t\"write lba x%lx + x%x oldappTag x%x\\n\",\n\t\t\t\t\t(unsigned long)lba, blockoff,\n\t\t\t\t\tbe16_to_cpu(src->app_tag));\n\n\t\t\t\t\t \n\t\t\t\t\tif (lpfc_cmd) {\n\t\t\t\t\t\tlpfc_cmd->prot_data_type =\n\t\t\t\t\t\t\tLPFC_INJERR_APPTAG;\n\t\t\t\t\t\tlpfc_cmd->prot_data_segment =\n\t\t\t\t\t\t\tsrc;\n\t\t\t\t\t\tlpfc_cmd->prot_data =\n\t\t\t\t\t\t\tsrc->app_tag;\n\t\t\t\t\t}\n\t\t\t\t\tsrc->app_tag = cpu_to_be16(0xDEAD);\n\t\t\t\t\tphba->lpfc_injerr_wapp_cnt--;\n\t\t\t\t\tif (phba->lpfc_injerr_wapp_cnt == 0) {\n\t\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t  0, sizeof(struct lpfc_name));\n\t\t\t\t\t}\n\t\t\t\t\trc = BG_ERR_TGT | BG_ERR_CHECK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t*apptag = 0xDEAD;\n\t\t\t\tphba->lpfc_injerr_wapp_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wapp_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_TGT | BG_ERR_CHECK;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0813 BLKGRD: Injecting apptag error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t\t \n\t\t\t\t*apptag = 0xDEAD;\n\t\t\t\tphba->lpfc_injerr_wapp_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wapp_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_INIT;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0812 BLKGRD: Injecting apptag error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (phba->lpfc_injerr_rapp_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_READ_INSERT:\n\t\t\tcase SCSI_PROT_READ_STRIP:\n\t\t\tcase SCSI_PROT_READ_PASS:\n\t\t\t\t \n\t\t\t\t*apptag = 0xDEAD;\n\t\t\t\tphba->lpfc_injerr_rapp_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_rapp_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\t\t\t\trc = BG_ERR_INIT;\n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0814 BLKGRD: Injecting apptag error: \"\n\t\t\t\t\t\"read lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t \n\tif (new_guard) {\n\t\tif (phba->lpfc_injerr_wgrd_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t\trc = BG_ERR_CHECK;\n\t\t\t\tfallthrough;\n\n\t\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t\t \n\t\t\t\tphba->lpfc_injerr_wgrd_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wgrd_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\n\t\t\t\trc |= BG_ERR_TGT | BG_ERR_SWAP;\n\t\t\t\t \n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0817 BLKGRD: Injecting guard error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t\t \n\t\t\t\tphba->lpfc_injerr_wgrd_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_wgrd_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\n\t\t\t\trc = BG_ERR_INIT | BG_ERR_SWAP;\n\t\t\t\t \n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0816 BLKGRD: Injecting guard error: \"\n\t\t\t\t\t\"write lba x%lx\\n\", (unsigned long)lba);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (phba->lpfc_injerr_rgrd_cnt) {\n\t\t\tswitch (op) {\n\t\t\tcase SCSI_PROT_READ_INSERT:\n\t\t\tcase SCSI_PROT_READ_STRIP:\n\t\t\tcase SCSI_PROT_READ_PASS:\n\t\t\t\t \n\t\t\t\tphba->lpfc_injerr_rgrd_cnt--;\n\t\t\t\tif (phba->lpfc_injerr_rgrd_cnt == 0) {\n\t\t\t\t\tphba->lpfc_injerr_nportid = 0;\n\t\t\t\t\tphba->lpfc_injerr_lba =\n\t\t\t\t\t\tLPFC_INJERR_LBA_OFF;\n\t\t\t\t\tmemset(&phba->lpfc_injerr_wwpn,\n\t\t\t\t\t\t0, sizeof(struct lpfc_name));\n\t\t\t\t}\n\n\t\t\t\trc = BG_ERR_INIT | BG_ERR_SWAP;\n\t\t\t\t \n\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"0818 BLKGRD: Injecting guard error: \"\n\t\t\t\t\t\"read lba x%lx\\n\", (unsigned long)lba);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n#endif\n\n \nstatic int\nlpfc_sc_to_bg_opcodes(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tuint8_t *txop, uint8_t *rxop)\n{\n\tuint8_t ret = 0;\n\n\tif (sc->prot_flags & SCSI_PROT_IP_CHECKSUM) {\n\t\tswitch (scsi_get_prot_op(sc)) {\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t*rxop = BG_OP_IN_NODIF_OUT_CSUM;\n\t\t\t*txop = BG_OP_IN_CSUM_OUT_NODIF;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t*rxop = BG_OP_IN_CRC_OUT_NODIF;\n\t\t\t*txop = BG_OP_IN_NODIF_OUT_CRC;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t*rxop = BG_OP_IN_CRC_OUT_CSUM;\n\t\t\t*txop = BG_OP_IN_CSUM_OUT_CRC;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_NORMAL:\n\t\tdefault:\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9063 BLKGRD: Bad op/guard:%d/IP combination\\n\",\n\t\t\t\t\tscsi_get_prot_op(sc));\n\t\t\tret = 1;\n\t\t\tbreak;\n\n\t\t}\n\t} else {\n\t\tswitch (scsi_get_prot_op(sc)) {\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t*rxop = BG_OP_IN_CRC_OUT_NODIF;\n\t\t\t*txop = BG_OP_IN_NODIF_OUT_CRC;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t*rxop = BG_OP_IN_CRC_OUT_CRC;\n\t\t\t*txop = BG_OP_IN_CRC_OUT_CRC;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t*rxop = BG_OP_IN_NODIF_OUT_CRC;\n\t\t\t*txop = BG_OP_IN_CRC_OUT_NODIF;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_NORMAL:\n\t\tdefault:\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9075 BLKGRD: Bad op/guard:%d/CRC combination\\n\",\n\t\t\t\t\tscsi_get_prot_op(sc));\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n \nstatic int\nlpfc_bg_err_opcodes(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tuint8_t *txop, uint8_t *rxop)\n{\n\n\tif (sc->prot_flags & SCSI_PROT_IP_CHECKSUM) {\n\t\tswitch (scsi_get_prot_op(sc)) {\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t*rxop = BG_OP_IN_NODIF_OUT_CRC;\n\t\t\t*txop = BG_OP_IN_CRC_OUT_NODIF;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t*rxop = BG_OP_IN_CSUM_OUT_NODIF;\n\t\t\t*txop = BG_OP_IN_NODIF_OUT_CSUM;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t*rxop = BG_OP_IN_CSUM_OUT_CRC;\n\t\t\t*txop = BG_OP_IN_CRC_OUT_CSUM;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_NORMAL:\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\t} else {\n\t\tswitch (scsi_get_prot_op(sc)) {\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\t\t*rxop = BG_OP_IN_CSUM_OUT_NODIF;\n\t\t\t*txop = BG_OP_IN_NODIF_OUT_CSUM;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\t*rxop = BG_OP_IN_CSUM_OUT_CSUM;\n\t\t\t*txop = BG_OP_IN_CSUM_OUT_CSUM;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\t*rxop = BG_OP_IN_NODIF_OUT_CSUM;\n\t\t\t*txop = BG_OP_IN_CSUM_OUT_NODIF;\n\t\t\tbreak;\n\n\t\tcase SCSI_PROT_NORMAL:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\n \nstatic int\nlpfc_bg_setup_bpl(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tstruct ulp_bde64 *bpl, int datasegcnt)\n{\n\tstruct scatterlist *sgde = NULL;  \n\tstruct lpfc_pde5 *pde5 = NULL;\n\tstruct lpfc_pde6 *pde6 = NULL;\n\tdma_addr_t physaddr;\n\tint i = 0, num_bde = 0, status;\n\tint datadir = sc->sc_data_direction;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t rc;\n#endif\n\tuint32_t checking = 1;\n\tuint32_t reftag;\n\tuint8_t txop, rxop;\n\n\tstatus  = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\n\tif (status)\n\t\tgoto out;\n\n\t \n\treftag = scsi_prot_ref_tag(sc);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\trc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\n\tif (rc) {\n\t\tif (rc & BG_ERR_SWAP)\n\t\t\tlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\n\t\tif (rc & BG_ERR_CHECK)\n\t\t\tchecking = 0;\n\t}\n#endif\n\n\t \n\tpde5 = (struct lpfc_pde5 *) bpl;\n\tmemset(pde5, 0, sizeof(struct lpfc_pde5));\n\tbf_set(pde5_type, pde5, LPFC_PDE5_DESCRIPTOR);\n\n\t \n\tpde5->word0 = cpu_to_le32(pde5->word0);\n\tpde5->reftag = cpu_to_le32(reftag);\n\n\t \n\tnum_bde++;\n\tbpl++;\n\tpde6 = (struct lpfc_pde6 *) bpl;\n\n\t \n\tmemset(pde6, 0, sizeof(struct lpfc_pde6));\n\tbf_set(pde6_type, pde6, LPFC_PDE6_DESCRIPTOR);\n\tbf_set(pde6_optx, pde6, txop);\n\tbf_set(pde6_oprx, pde6, rxop);\n\n\t \n\tif (datadir == DMA_FROM_DEVICE) {\n\t\tif (sc->prot_flags & SCSI_PROT_GUARD_CHECK)\n\t\t\tbf_set(pde6_ce, pde6, checking);\n\t\telse\n\t\t\tbf_set(pde6_ce, pde6, 0);\n\n\t\tif (sc->prot_flags & SCSI_PROT_REF_CHECK)\n\t\t\tbf_set(pde6_re, pde6, checking);\n\t\telse\n\t\t\tbf_set(pde6_re, pde6, 0);\n\t}\n\tbf_set(pde6_ai, pde6, 1);\n\tbf_set(pde6_ae, pde6, 0);\n\tbf_set(pde6_apptagval, pde6, 0);\n\n\t \n\tpde6->word0 = cpu_to_le32(pde6->word0);\n\tpde6->word1 = cpu_to_le32(pde6->word1);\n\tpde6->word2 = cpu_to_le32(pde6->word2);\n\n\t \n\tnum_bde++;\n\tbpl++;\n\n\t \n\tscsi_for_each_sg(sc, sgde, datasegcnt, i) {\n\t\tphysaddr = sg_dma_address(sgde);\n\t\tbpl->addrLow = le32_to_cpu(putPaddrLow(physaddr));\n\t\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(physaddr));\n\t\tbpl->tus.f.bdeSize = sg_dma_len(sgde);\n\t\tif (datadir == DMA_TO_DEVICE)\n\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\telse\n\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\n\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\t\tbpl++;\n\t\tnum_bde++;\n\t}\n\nout:\n\treturn num_bde;\n}\n\n \nstatic int\nlpfc_bg_setup_bpl_prot(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tstruct ulp_bde64 *bpl, int datacnt, int protcnt)\n{\n\tstruct scatterlist *sgde = NULL;  \n\tstruct scatterlist *sgpe = NULL;  \n\tstruct lpfc_pde5 *pde5 = NULL;\n\tstruct lpfc_pde6 *pde6 = NULL;\n\tstruct lpfc_pde7 *pde7 = NULL;\n\tdma_addr_t dataphysaddr, protphysaddr;\n\tunsigned short curr_prot = 0;\n\tunsigned int split_offset;\n\tunsigned int protgroup_len, protgroup_offset = 0, protgroup_remainder;\n\tunsigned int protgrp_blks, protgrp_bytes;\n\tunsigned int remainder, subtotal;\n\tint status;\n\tint datadir = sc->sc_data_direction;\n\tunsigned char pgdone = 0, alldone = 0;\n\tunsigned blksize;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t rc;\n#endif\n\tuint32_t checking = 1;\n\tuint32_t reftag;\n\tuint8_t txop, rxop;\n\tint num_bde = 0;\n\n\tsgpe = scsi_prot_sglist(sc);\n\tsgde = scsi_sglist(sc);\n\n\tif (!sgpe || !sgde) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9020 Invalid s/g entry: data=x%px prot=x%px\\n\",\n\t\t\t\tsgpe, sgde);\n\t\treturn 0;\n\t}\n\n\tstatus = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tblksize = scsi_prot_interval(sc);\n\treftag = scsi_prot_ref_tag(sc);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\trc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\n\tif (rc) {\n\t\tif (rc & BG_ERR_SWAP)\n\t\t\tlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\n\t\tif (rc & BG_ERR_CHECK)\n\t\t\tchecking = 0;\n\t}\n#endif\n\n\tsplit_offset = 0;\n\tdo {\n\t\t \n\t\tif (num_bde >= (phba->cfg_total_seg_cnt - 2))\n\t\t\treturn num_bde + 3;\n\n\t\t \n\t\tpde5 = (struct lpfc_pde5 *) bpl;\n\t\tmemset(pde5, 0, sizeof(struct lpfc_pde5));\n\t\tbf_set(pde5_type, pde5, LPFC_PDE5_DESCRIPTOR);\n\n\t\t \n\t\tpde5->word0 = cpu_to_le32(pde5->word0);\n\t\tpde5->reftag = cpu_to_le32(reftag);\n\n\t\t \n\t\tnum_bde++;\n\t\tbpl++;\n\t\tpde6 = (struct lpfc_pde6 *) bpl;\n\n\t\t \n\t\tmemset(pde6, 0, sizeof(struct lpfc_pde6));\n\t\tbf_set(pde6_type, pde6, LPFC_PDE6_DESCRIPTOR);\n\t\tbf_set(pde6_optx, pde6, txop);\n\t\tbf_set(pde6_oprx, pde6, rxop);\n\n\t\tif (sc->prot_flags & SCSI_PROT_GUARD_CHECK)\n\t\t\tbf_set(pde6_ce, pde6, checking);\n\t\telse\n\t\t\tbf_set(pde6_ce, pde6, 0);\n\n\t\tif (sc->prot_flags & SCSI_PROT_REF_CHECK)\n\t\t\tbf_set(pde6_re, pde6, checking);\n\t\telse\n\t\t\tbf_set(pde6_re, pde6, 0);\n\n\t\tbf_set(pde6_ai, pde6, 1);\n\t\tbf_set(pde6_ae, pde6, 0);\n\t\tbf_set(pde6_apptagval, pde6, 0);\n\n\t\t \n\t\tpde6->word0 = cpu_to_le32(pde6->word0);\n\t\tpde6->word1 = cpu_to_le32(pde6->word1);\n\t\tpde6->word2 = cpu_to_le32(pde6->word2);\n\n\t\t \n\t\tnum_bde++;\n\t\tbpl++;\n\n\t\t \n\t\tprotphysaddr = sg_dma_address(sgpe) + protgroup_offset;\n\t\tprotgroup_len = sg_dma_len(sgpe) - protgroup_offset;\n\n\t\t \n\t\tBUG_ON(protgroup_len % 8);\n\n\t\tpde7 = (struct lpfc_pde7 *) bpl;\n\t\tmemset(pde7, 0, sizeof(struct lpfc_pde7));\n\t\tbf_set(pde7_type, pde7, LPFC_PDE7_DESCRIPTOR);\n\n\t\tpde7->addrHigh = le32_to_cpu(putPaddrHigh(protphysaddr));\n\t\tpde7->addrLow = le32_to_cpu(putPaddrLow(protphysaddr));\n\n\t\tprotgrp_blks = protgroup_len / 8;\n\t\tprotgrp_bytes = protgrp_blks * blksize;\n\n\t\t \n\t\tif ((pde7->addrLow & 0xfff) + protgroup_len > 0x1000) {\n\t\t\tprotgroup_remainder = 0x1000 - (pde7->addrLow & 0xfff);\n\t\t\tprotgroup_offset += protgroup_remainder;\n\t\t\tprotgrp_blks = protgroup_remainder / 8;\n\t\t\tprotgrp_bytes = protgrp_blks * blksize;\n\t\t} else {\n\t\t\tprotgroup_offset = 0;\n\t\t\tcurr_prot++;\n\t\t}\n\n\t\tnum_bde++;\n\n\t\t \n\t\tpgdone = 0;\n\t\tsubtotal = 0;  \n\t\twhile (!pgdone) {\n\t\t\t \n\t\t\tif (num_bde >= phba->cfg_total_seg_cnt)\n\t\t\t\treturn num_bde + 1;\n\n\t\t\tif (!sgde) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9065 BLKGRD:%s Invalid data segment\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbpl++;\n\t\t\tdataphysaddr = sg_dma_address(sgde) + split_offset;\n\t\t\tbpl->addrLow = le32_to_cpu(putPaddrLow(dataphysaddr));\n\t\t\tbpl->addrHigh = le32_to_cpu(putPaddrHigh(dataphysaddr));\n\n\t\t\tremainder = sg_dma_len(sgde) - split_offset;\n\n\t\t\tif ((subtotal + remainder) <= protgrp_bytes) {\n\t\t\t\t \n\t\t\t\tbpl->tus.f.bdeSize = remainder;\n\t\t\t\tsplit_offset = 0;\n\n\t\t\t\tif ((subtotal + remainder) == protgrp_bytes)\n\t\t\t\t\tpgdone = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbpl->tus.f.bdeSize = protgrp_bytes - subtotal;\n\t\t\t\tsplit_offset += bpl->tus.f.bdeSize;\n\t\t\t}\n\n\t\t\tsubtotal += bpl->tus.f.bdeSize;\n\n\t\t\tif (datadir == DMA_TO_DEVICE)\n\t\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\telse\n\t\t\t\tbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\n\t\t\tbpl->tus.w = le32_to_cpu(bpl->tus.w);\n\n\t\t\tnum_bde++;\n\n\t\t\tif (split_offset)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tsgde = sg_next(sgde);\n\n\t\t}\n\n\t\tif (protgroup_offset) {\n\t\t\t \n\t\t\treftag += protgrp_blks;\n\t\t\tbpl++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (curr_prot == protcnt) {\n\t\t\talldone = 1;\n\t\t} else if (curr_prot < protcnt) {\n\t\t\t \n\t\t\tsgpe = sg_next(sgpe);\n\t\t\tbpl++;\n\n\t\t\t \n\t\t\treftag += protgrp_blks;\n\t\t} else {\n\t\t\t \n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9054 BLKGRD: bug in %s\\n\", __func__);\n\t\t}\n\n\t} while (!alldone);\nout:\n\n\treturn num_bde;\n}\n\n \nstatic int\nlpfc_bg_setup_sgl(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tstruct sli4_sge *sgl, int datasegcnt,\n\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scatterlist *sgde = NULL;  \n\tstruct sli4_sge_diseed *diseed = NULL;\n\tdma_addr_t physaddr;\n\tint i = 0, num_sge = 0, status;\n\tuint32_t reftag;\n\tuint8_t txop, rxop;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t rc;\n#endif\n\tuint32_t checking = 1;\n\tuint32_t dma_len;\n\tuint32_t dma_offset = 0;\n\tstruct sli4_hybrid_sgl *sgl_xtra = NULL;\n\tint j;\n\tbool lsp_just_set = false;\n\n\tstatus  = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\n\tif (status)\n\t\tgoto out;\n\n\t \n\treftag = scsi_prot_ref_tag(sc);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\trc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\n\tif (rc) {\n\t\tif (rc & BG_ERR_SWAP)\n\t\t\tlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\n\t\tif (rc & BG_ERR_CHECK)\n\t\t\tchecking = 0;\n\t}\n#endif\n\n\t \n\tdiseed = (struct sli4_sge_diseed *) sgl;\n\tmemset(diseed, 0, sizeof(struct sli4_sge_diseed));\n\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DISEED);\n\n\t \n\tdiseed->ref_tag = cpu_to_le32(reftag);\n\tdiseed->ref_tag_tran = diseed->ref_tag;\n\n\t \n\tif (sc->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tif (sc->prot_flags & SCSI_PROT_GUARD_CHECK)\n\t\t\tbf_set(lpfc_sli4_sge_dif_ce, diseed, checking);\n\t\telse\n\t\t\tbf_set(lpfc_sli4_sge_dif_ce, diseed, 0);\n\n\t\tif (sc->prot_flags & SCSI_PROT_REF_CHECK)\n\t\t\tbf_set(lpfc_sli4_sge_dif_re, diseed, checking);\n\t\telse\n\t\t\tbf_set(lpfc_sli4_sge_dif_re, diseed, 0);\n\t}\n\n\t \n\tbf_set(lpfc_sli4_sge_dif_optx, diseed, txop);\n\tbf_set(lpfc_sli4_sge_dif_oprx, diseed, rxop);\n\n\tbf_set(lpfc_sli4_sge_dif_ai, diseed, 1);\n\tbf_set(lpfc_sli4_sge_dif_me, diseed, 0);\n\n\t \n\tdiseed->word2 = cpu_to_le32(diseed->word2);\n\tdiseed->word3 = cpu_to_le32(diseed->word3);\n\n\t \n\tnum_sge++;\n\tsgl++;\n\n\t \n\tsgde = scsi_sglist(sc);\n\tj = 3;\n\tfor (i = 0; i < datasegcnt; i++) {\n\t\t \n\t\tsgl->word2 = 0;\n\n\t\t \n\t\tif (!lsp_just_set && !((j + 1) % phba->border_sge_num) &&\n\t\t    ((datasegcnt - 1) != i)) {\n\t\t\t \n\t\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_LSP);\n\n\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(phba, lpfc_cmd);\n\n\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\tlpfc_cmd->seg_cnt = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\tsgl_xtra->dma_phys_sgl));\n\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\tsgl_xtra->dma_phys_sgl));\n\n\t\t} else {\n\t\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DATA);\n\t\t}\n\n\t\tif (!(bf_get(lpfc_sli4_sge_type, sgl) & LPFC_SGE_TYPE_LSP)) {\n\t\t\tif ((datasegcnt - 1) == i)\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\t\tphysaddr = sg_dma_address(sgde);\n\t\t\tdma_len = sg_dma_len(sgde);\n\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(physaddr));\n\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(physaddr));\n\n\t\t\tbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\n\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\tsgl->sge_len = cpu_to_le32(dma_len);\n\n\t\t\tdma_offset += dma_len;\n\t\t\tsgde = sg_next(sgde);\n\n\t\t\tsgl++;\n\t\t\tnum_sge++;\n\t\t\tlsp_just_set = false;\n\n\t\t} else {\n\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\tsgl->sge_len = cpu_to_le32(phba->cfg_sg_dma_buf_size);\n\n\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\ti = i - 1;\n\n\t\t\tlsp_just_set = true;\n\t\t}\n\n\t\tj++;\n\n\t}\n\nout:\n\treturn num_sge;\n}\n\n \nstatic int\nlpfc_bg_setup_sgl_prot(struct lpfc_hba *phba, struct scsi_cmnd *sc,\n\t\tstruct sli4_sge *sgl, int datacnt, int protcnt,\n\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scatterlist *sgde = NULL;  \n\tstruct scatterlist *sgpe = NULL;  \n\tstruct sli4_sge_diseed *diseed = NULL;\n\tdma_addr_t dataphysaddr, protphysaddr;\n\tunsigned short curr_prot = 0;\n\tunsigned int split_offset;\n\tunsigned int protgroup_len, protgroup_offset = 0, protgroup_remainder;\n\tunsigned int protgrp_blks, protgrp_bytes;\n\tunsigned int remainder, subtotal;\n\tint status;\n\tunsigned char pgdone = 0, alldone = 0;\n\tunsigned blksize;\n\tuint32_t reftag;\n\tuint8_t txop, rxop;\n\tuint32_t dma_len;\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tuint32_t rc;\n#endif\n\tuint32_t checking = 1;\n\tuint32_t dma_offset = 0;\n\tint num_sge = 0, j = 2;\n\tstruct sli4_hybrid_sgl *sgl_xtra = NULL;\n\n\tsgpe = scsi_prot_sglist(sc);\n\tsgde = scsi_sglist(sc);\n\n\tif (!sgpe || !sgde) {\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9082 Invalid s/g entry: data=x%px prot=x%px\\n\",\n\t\t\t\tsgpe, sgde);\n\t\treturn 0;\n\t}\n\n\tstatus = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\n\tif (status)\n\t\tgoto out;\n\n\t \n\tblksize = scsi_prot_interval(sc);\n\treftag = scsi_prot_ref_tag(sc);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\trc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\n\tif (rc) {\n\t\tif (rc & BG_ERR_SWAP)\n\t\t\tlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\n\t\tif (rc & BG_ERR_CHECK)\n\t\t\tchecking = 0;\n\t}\n#endif\n\n\tsplit_offset = 0;\n\tdo {\n\t\t \n\t\tif ((num_sge >= (phba->cfg_total_seg_cnt - 2)) &&\n\t\t    !(phba->cfg_xpsgl))\n\t\t\treturn num_sge + 3;\n\n\t\t \n\t\tif (!((j + 1) % phba->border_sge_num) ||\n\t\t    !((j + 2) % phba->border_sge_num) ||\n\t\t    !((j + 3) % phba->border_sge_num)) {\n\t\t\tsgl->word2 = 0;\n\n\t\t\t \n\t\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_LSP);\n\n\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(phba, lpfc_cmd);\n\n\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\tsgl_xtra->dma_phys_sgl));\n\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t       sgl_xtra->dma_phys_sgl));\n\t\t\t}\n\n\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\tsgl->sge_len = cpu_to_le32(phba->cfg_sg_dma_buf_size);\n\n\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\tj = 0;\n\t\t}\n\n\t\t \n\t\tdiseed = (struct sli4_sge_diseed *) sgl;\n\t\tmemset(diseed, 0, sizeof(struct sli4_sge_diseed));\n\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DISEED);\n\n\t\t \n\t\tdiseed->ref_tag = cpu_to_le32(reftag);\n\t\tdiseed->ref_tag_tran = diseed->ref_tag;\n\n\t\tif (sc->prot_flags & SCSI_PROT_GUARD_CHECK) {\n\t\t\tbf_set(lpfc_sli4_sge_dif_ce, diseed, checking);\n\t\t} else {\n\t\t\tbf_set(lpfc_sli4_sge_dif_ce, diseed, 0);\n\t\t\t \n\t\t\tif (txop == BG_OP_IN_CRC_OUT_CRC) {\n\t\t\t\ttxop = BG_OP_RAW_MODE;\n\t\t\t\trxop = BG_OP_RAW_MODE;\n\t\t\t}\n\t\t}\n\n\n\t\tif (sc->prot_flags & SCSI_PROT_REF_CHECK)\n\t\t\tbf_set(lpfc_sli4_sge_dif_re, diseed, checking);\n\t\telse\n\t\t\tbf_set(lpfc_sli4_sge_dif_re, diseed, 0);\n\n\t\t \n\t\tbf_set(lpfc_sli4_sge_dif_optx, diseed, txop);\n\t\tbf_set(lpfc_sli4_sge_dif_oprx, diseed, rxop);\n\n\t\tbf_set(lpfc_sli4_sge_dif_ai, diseed, 1);\n\t\tbf_set(lpfc_sli4_sge_dif_me, diseed, 0);\n\n\t\t \n\t\tdiseed->word2 = cpu_to_le32(diseed->word2);\n\t\tdiseed->word3 = cpu_to_le32(diseed->word3);\n\n\t\t \n\t\tnum_sge++;\n\n\t\tsgl++;\n\t\tj++;\n\n\t\t \n\t\tprotphysaddr = sg_dma_address(sgpe) + protgroup_offset;\n\t\tprotgroup_len = sg_dma_len(sgpe) - protgroup_offset;\n\n\t\t \n\t\tBUG_ON(protgroup_len % 8);\n\n\t\t \n\t\tsgl->word2 = 0;\n\t\tbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DIF);\n\t\tsgl->addr_hi = le32_to_cpu(putPaddrHigh(protphysaddr));\n\t\tsgl->addr_lo = le32_to_cpu(putPaddrLow(protphysaddr));\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\tsgl->sge_len = 0;\n\n\t\tprotgrp_blks = protgroup_len / 8;\n\t\tprotgrp_bytes = protgrp_blks * blksize;\n\n\t\t \n\t\tif ((sgl->addr_lo & 0xfff) + protgroup_len > 0x1000) {\n\t\t\tprotgroup_remainder = 0x1000 - (sgl->addr_lo & 0xfff);\n\t\t\tprotgroup_offset += protgroup_remainder;\n\t\t\tprotgrp_blks = protgroup_remainder / 8;\n\t\t\tprotgrp_bytes = protgrp_blks * blksize;\n\t\t} else {\n\t\t\tprotgroup_offset = 0;\n\t\t\tcurr_prot++;\n\t\t}\n\n\t\tnum_sge++;\n\n\t\t \n\t\tpgdone = 0;\n\t\tsubtotal = 0;  \n\n\t\tsgl++;\n\t\tj++;\n\n\t\twhile (!pgdone) {\n\t\t\t \n\t\t\tif ((num_sge >= phba->cfg_total_seg_cnt) &&\n\t\t\t    !phba->cfg_xpsgl)\n\t\t\t\treturn num_sge + 1;\n\n\t\t\tif (!sgde) {\n\t\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9086 BLKGRD:%s Invalid data segment\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!((j + 1) % phba->border_sge_num)) {\n\t\t\t\tsgl->word2 = 0;\n\n\t\t\t\t \n\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t       LPFC_SGE_TYPE_LSP);\n\n\t\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(phba,\n\t\t\t\t\t\t\t\t lpfc_cmd);\n\n\t\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\tsgl->addr_lo = cpu_to_le32(\n\t\t\t\t\t  putPaddrLow(sgl_xtra->dma_phys_sgl));\n\t\t\t\t\tsgl->addr_hi = cpu_to_le32(\n\t\t\t\t\t  putPaddrHigh(sgl_xtra->dma_phys_sgl));\n\t\t\t\t}\n\n\t\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\t\tsgl->sge_len = cpu_to_le32(\n\t\t\t\t\t\t     phba->cfg_sg_dma_buf_size);\n\n\t\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\t} else {\n\t\t\t\tdataphysaddr = sg_dma_address(sgde) +\n\t\t\t\t\t\t\t\t   split_offset;\n\n\t\t\t\tremainder = sg_dma_len(sgde) - split_offset;\n\n\t\t\t\tif ((subtotal + remainder) <= protgrp_bytes) {\n\t\t\t\t\t \n\t\t\t\t\tdma_len = remainder;\n\t\t\t\t\tsplit_offset = 0;\n\n\t\t\t\t\tif ((subtotal + remainder) ==\n\t\t\t\t\t\t\t\t  protgrp_bytes)\n\t\t\t\t\t\tpgdone = 1;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tdma_len = protgrp_bytes - subtotal;\n\t\t\t\t\tsplit_offset += dma_len;\n\t\t\t\t}\n\n\t\t\t\tsubtotal += dma_len;\n\n\t\t\t\tsgl->word2 = 0;\n\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\t\t\t dataphysaddr));\n\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t\t\t dataphysaddr));\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\t\t\t\tbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\n\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t       LPFC_SGE_TYPE_DATA);\n\n\t\t\t\tsgl->sge_len = cpu_to_le32(dma_len);\n\t\t\t\tdma_offset += dma_len;\n\n\t\t\t\tnum_sge++;\n\n\t\t\t\tif (split_offset) {\n\t\t\t\t\tsgl++;\n\t\t\t\t\tj++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tsgde = sg_next(sgde);\n\n\t\t\t\tsgl++;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\n\t\tif (protgroup_offset) {\n\t\t\t \n\t\t\treftag += protgrp_blks;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (curr_prot == protcnt) {\n\t\t\t \n\t\t\tsgl--;\n\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\t\talldone = 1;\n\t\t} else if (curr_prot < protcnt) {\n\t\t\t \n\t\t\tsgpe = sg_next(sgpe);\n\n\t\t\t \n\t\t\treftag += protgrp_blks;\n\t\t} else {\n\t\t\t \n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9085 BLKGRD: bug in %s\\n\", __func__);\n\t\t}\n\n\t} while (!alldone);\n\nout:\n\n\treturn num_sge;\n}\n\n \nstatic int\nlpfc_prot_group_type(struct lpfc_hba *phba, struct scsi_cmnd *sc)\n{\n\tint ret = LPFC_PG_TYPE_INVALID;\n\tunsigned char op = scsi_get_prot_op(sc);\n\n\tswitch (op) {\n\tcase SCSI_PROT_READ_STRIP:\n\tcase SCSI_PROT_WRITE_INSERT:\n\t\tret = LPFC_PG_TYPE_NO_DIF;\n\t\tbreak;\n\tcase SCSI_PROT_READ_INSERT:\n\tcase SCSI_PROT_WRITE_STRIP:\n\tcase SCSI_PROT_READ_PASS:\n\tcase SCSI_PROT_WRITE_PASS:\n\t\tret = LPFC_PG_TYPE_DIF_BUF;\n\t\tbreak;\n\tdefault:\n\t\tif (phba)\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9021 Unsupported protection op:%d\\n\",\n\t\t\t\t\top);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int\nlpfc_bg_scsi_adjust_dl(struct lpfc_hba *phba,\n\t\t       struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *sc = lpfc_cmd->pCmd;\n\tint fcpdl;\n\n\tfcpdl = scsi_bufflen(sc);\n\n\t \n\tif (sc->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t \n\t\tif (scsi_get_prot_op(sc) ==  SCSI_PROT_READ_INSERT)\n\t\t\treturn fcpdl;\n\n\t} else {\n\t\t \n\t\tif (scsi_get_prot_op(sc) ==  SCSI_PROT_WRITE_STRIP)\n\t\t\treturn fcpdl;\n\t}\n\n\t \n\tfcpdl += (fcpdl / scsi_prot_interval(sc)) * 8;\n\n\treturn fcpdl;\n}\n\n \nstatic int\nlpfc_bg_scsi_prep_dma_buf_s3(struct lpfc_hba *phba,\n\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct ulp_bde64 *bpl = (struct ulp_bde64 *)lpfc_cmd->dma_sgl;\n\tIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\n\tuint32_t num_bde = 0;\n\tint datasegcnt, protsegcnt, datadir = scsi_cmnd->sc_data_direction;\n\tint prot_group_type = 0;\n\tint fcpdl;\n\tint ret = 1;\n\tstruct lpfc_vport *vport = phba->pport;\n\n\t \n\tbpl += 2;\n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\t \n\t\tdatasegcnt = dma_map_sg(&phba->pcidev->dev,\n\t\t\t\t\tscsi_sglist(scsi_cmnd),\n\t\t\t\t\tscsi_sg_count(scsi_cmnd), datadir);\n\t\tif (unlikely(!datasegcnt))\n\t\t\treturn 1;\n\n\t\tlpfc_cmd->seg_cnt = datasegcnt;\n\n\t\t \n\t\tif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {\n\t\t\tWARN_ON_ONCE(lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt);\n\t\t\tret = 2;\n\t\t\tgoto err;\n\t\t}\n\n\t\tprot_group_type = lpfc_prot_group_type(phba, scsi_cmnd);\n\n\t\tswitch (prot_group_type) {\n\t\tcase LPFC_PG_TYPE_NO_DIF:\n\n\t\t\t \n\t\t\tif ((lpfc_cmd->seg_cnt + 2) > phba->cfg_total_seg_cnt) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnum_bde = lpfc_bg_setup_bpl(phba, scsi_cmnd, bpl,\n\t\t\t\t\tdatasegcnt);\n\t\t\t \n\t\t\tif (num_bde < 2) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LPFC_PG_TYPE_DIF_BUF:\n\t\t\t \n\t\t\tprotsegcnt = dma_map_sg(&phba->pcidev->dev,\n\t\t\t\t\tscsi_prot_sglist(scsi_cmnd),\n\t\t\t\t\tscsi_prot_sg_count(scsi_cmnd), datadir);\n\t\t\tif (unlikely(!protsegcnt)) {\n\t\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tlpfc_cmd->prot_seg_cnt = protsegcnt;\n\n\t\t\t \n\t\t\tif ((lpfc_cmd->prot_seg_cnt * 4) >\n\t\t\t    (phba->cfg_total_seg_cnt - 2)) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnum_bde = lpfc_bg_setup_bpl_prot(phba, scsi_cmnd, bpl,\n\t\t\t\t\tdatasegcnt, protsegcnt);\n\t\t\t \n\t\t\tif ((num_bde < 3) ||\n\t\t\t    (num_bde > phba->cfg_total_seg_cnt)) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LPFC_PG_TYPE_INVALID:\n\t\tdefault:\n\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\tlpfc_cmd->seg_cnt = 0;\n\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9022 Unexpected protection group %i\\n\",\n\t\t\t\t\tprot_group_type);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\t \n\tiocb_cmd->un.fcpi64.bdl.bdeSize = (2 * sizeof(struct ulp_bde64));\n\tiocb_cmd->un.fcpi64.bdl.bdeSize += (num_bde * sizeof(struct ulp_bde64));\n\tiocb_cmd->ulpBdeCount = 1;\n\tiocb_cmd->ulpLe = 1;\n\n\tfcpdl = lpfc_bg_scsi_adjust_dl(phba, lpfc_cmd);\n\tfcp_cmnd->fcpDl = be32_to_cpu(fcpdl);\n\n\t \n\tiocb_cmd->un.fcpi.fcpi_parm = fcpdl;\n\n\t \n\tif (iocb_cmd->un.fcpi.fcpi_XRdy &&\n\t    (fcpdl < vport->cfg_first_burst_size))\n\t\tiocb_cmd->un.fcpi.fcpi_XRdy = fcpdl;\n\n\treturn 0;\nerr:\n\tif (lpfc_cmd->seg_cnt)\n\t\tscsi_dma_unmap(scsi_cmnd);\n\tif (lpfc_cmd->prot_seg_cnt)\n\t\tdma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(scsi_cmnd),\n\t\t\t     scsi_prot_sg_count(scsi_cmnd),\n\t\t\t     scsi_cmnd->sc_data_direction);\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"9023 Cannot setup S/G List for HBA\"\n\t\t\t\"IO segs %d/%d BPL %d SCSI %d: %d %d\\n\",\n\t\t\tlpfc_cmd->seg_cnt, lpfc_cmd->prot_seg_cnt,\n\t\t\tphba->cfg_total_seg_cnt, phba->cfg_sg_seg_cnt,\n\t\t\tprot_group_type, num_bde);\n\n\tlpfc_cmd->seg_cnt = 0;\n\tlpfc_cmd->prot_seg_cnt = 0;\n\treturn ret;\n}\n\n \nstatic uint16_t\nlpfc_bg_crc(uint8_t *data, int count)\n{\n\tuint16_t crc = 0;\n\tuint16_t x;\n\n\tcrc = crc_t10dif(data, count);\n\tx = cpu_to_be16(crc);\n\treturn x;\n}\n\n \nstatic uint16_t\nlpfc_bg_csum(uint8_t *data, int count)\n{\n\tuint16_t ret;\n\n\tret = ip_compute_csum(data, count);\n\treturn ret;\n}\n\n \nstatic void\nlpfc_calc_bg_err(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scatterlist *sgpe;  \n\tstruct scatterlist *sgde;  \n\tstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\n\tstruct scsi_dif_tuple *src = NULL;\n\tuint8_t *data_src = NULL;\n\tuint16_t guard_tag;\n\tuint16_t start_app_tag, app_tag;\n\tuint32_t start_ref_tag, ref_tag;\n\tint prot, protsegcnt;\n\tint err_type, len, data_len;\n\tint chk_ref, chk_app, chk_guard;\n\tuint16_t sum;\n\tunsigned blksize;\n\n\terr_type = BGS_GUARD_ERR_MASK;\n\tsum = 0;\n\tguard_tag = 0;\n\n\t \n\tprot = scsi_get_prot_op(cmd);\n\tif ((prot == SCSI_PROT_READ_STRIP) ||\n\t    (prot == SCSI_PROT_WRITE_INSERT) ||\n\t    (prot == SCSI_PROT_NORMAL))\n\t\tgoto out;\n\n\t \n\tchk_ref = 1;\n\tchk_app = 0;\n\tchk_guard = 0;\n\n\t \n\tsgpe = scsi_prot_sglist(cmd);\n\tprotsegcnt = lpfc_cmd->prot_seg_cnt;\n\n\tif (sgpe && protsegcnt) {\n\n\t\t \n\t\tsgde = scsi_sglist(cmd);\n\t\tblksize = scsi_prot_interval(cmd);\n\t\tdata_src = (uint8_t *)sg_virt(sgde);\n\t\tdata_len = sgde->length;\n\t\tif ((data_len & (blksize - 1)) == 0)\n\t\t\tchk_guard = 1;\n\n\t\tsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\n\t\tstart_ref_tag = scsi_prot_ref_tag(cmd);\n\t\tstart_app_tag = src->app_tag;\n\t\tlen = sgpe->length;\n\t\twhile (src && protsegcnt) {\n\t\t\twhile (len) {\n\n\t\t\t\t \n\t\t\t\tif ((src->ref_tag == T10_PI_REF_ESCAPE) ||\n\t\t\t\t    (src->app_tag == T10_PI_APP_ESCAPE)) {\n\t\t\t\t\tstart_ref_tag++;\n\t\t\t\t\tgoto skipit;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (chk_guard) {\n\t\t\t\t\tguard_tag = src->guard_tag;\n\t\t\t\t\tif (cmd->prot_flags\n\t\t\t\t\t    & SCSI_PROT_IP_CHECKSUM)\n\t\t\t\t\t\tsum = lpfc_bg_csum(data_src,\n\t\t\t\t\t\t\t\t   blksize);\n\t\t\t\t\telse\n\t\t\t\t\t\tsum = lpfc_bg_crc(data_src,\n\t\t\t\t\t\t\t\t  blksize);\n\t\t\t\t\tif ((guard_tag != sum)) {\n\t\t\t\t\t\terr_type = BGS_GUARD_ERR_MASK;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tref_tag = be32_to_cpu(src->ref_tag);\n\t\t\t\tif (chk_ref && (ref_tag != start_ref_tag)) {\n\t\t\t\t\terr_type = BGS_REFTAG_ERR_MASK;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tstart_ref_tag++;\n\n\t\t\t\t \n\t\t\t\tapp_tag = src->app_tag;\n\t\t\t\tif (chk_app && (app_tag != start_app_tag)) {\n\t\t\t\t\terr_type = BGS_APPTAG_ERR_MASK;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\nskipit:\n\t\t\t\tlen -= sizeof(struct scsi_dif_tuple);\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = 0;\n\t\t\t\tsrc++;\n\n\t\t\t\tdata_src += blksize;\n\t\t\t\tdata_len -= blksize;\n\n\t\t\t\t \n\t\t\t\tif (chk_guard && (data_len == 0)) {\n\t\t\t\t\tchk_guard = 0;\n\t\t\t\t\tsgde = sg_next(sgde);\n\t\t\t\t\tif (!sgde)\n\t\t\t\t\t\tgoto out;\n\n\t\t\t\t\tdata_src = (uint8_t *)sg_virt(sgde);\n\t\t\t\t\tdata_len = sgde->length;\n\t\t\t\t\tif ((data_len & (blksize - 1)) == 0)\n\t\t\t\t\t\tchk_guard = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tsgpe = sg_next(sgpe);\n\t\t\tif (sgpe) {\n\t\t\t\tsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\n\t\t\t\tlen = sgpe->length;\n\t\t\t} else {\n\t\t\t\tsrc = NULL;\n\t\t\t}\n\t\t\tprotsegcnt--;\n\t\t}\n\t}\nout:\n\tif (err_type == BGS_GUARD_ERR_MASK) {\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x1);\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\tphba->bg_guard_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9069 BLKGRD: reftag %x grd_tag err %x != %x\\n\",\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tsum, guard_tag);\n\n\t} else if (err_type == BGS_REFTAG_ERR_MASK) {\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x3);\n\t\tset_host_byte(cmd, DID_ABORT);\n\n\t\tphba->bg_reftag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9066 BLKGRD: reftag %x ref_tag err %x != %x\\n\",\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tref_tag, start_ref_tag);\n\n\t} else if (err_type == BGS_APPTAG_ERR_MASK) {\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x2);\n\t\tset_host_byte(cmd, DID_ABORT);\n\n\t\tphba->bg_apptag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9041 BLKGRD: reftag %x app_tag err %x != %x\\n\",\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tapp_tag, start_app_tag);\n\t}\n}\n\n \nstatic int\nlpfc_parse_bg_err(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd,\n\t\t  struct lpfc_iocbq *pIocbOut)\n{\n\tstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\n\tstruct sli3_bg_fields *bgf;\n\tint ret = 0;\n\tstruct lpfc_wcqe_complete *wcqe;\n\tu32 status;\n\tu32 bghm = 0;\n\tu32 bgstat = 0;\n\tu64 failing_sector = 0;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\twcqe = &pIocbOut->wcqe_cmpl;\n\t\tstatus = bf_get(lpfc_wcqe_c_status, wcqe);\n\n\t\tif (status == CQE_STATUS_DI_ERROR) {\n\t\t\t \n\t\t\tif (bf_get(lpfc_wcqe_c_bg_ge, wcqe))\n\t\t\t\tbgstat |= BGS_GUARD_ERR_MASK;\n\n\t\t\t \n\t\t\tif (bf_get(lpfc_wcqe_c_bg_ae, wcqe))\n\t\t\t\tbgstat |= BGS_APPTAG_ERR_MASK;\n\n\t\t\t \n\t\t\tif (bf_get(lpfc_wcqe_c_bg_re, wcqe))\n\t\t\t\tbgstat |= BGS_REFTAG_ERR_MASK;\n\n\t\t\t \n\t\t\tif (bf_get(lpfc_wcqe_c_bg_tdpv, wcqe)) {\n\t\t\t\tbgstat |= BGS_HI_WATER_MARK_PRESENT_MASK;\n\t\t\t\tbghm = wcqe->total_data_placed;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!bgstat)\n\t\t\t\tbgstat |= (BGS_REFTAG_ERR_MASK |\n\t\t\t\t\t   BGS_APPTAG_ERR_MASK |\n\t\t\t\t\t   BGS_GUARD_ERR_MASK);\n\t\t}\n\n\t} else {\n\t\tbgf = &pIocbOut->iocb.unsli3.sli3_bg;\n\t\tbghm = bgf->bghm;\n\t\tbgstat = bgf->bgstat;\n\t}\n\n\tif (lpfc_bgs_get_invalid_prof(bgstat)) {\n\t\tcmd->result = DID_ERROR << 16;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9072 BLKGRD: Invalid BG Profile in cmd \"\n\t\t\t\t\"0x%x reftag 0x%x blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tscsi_logical_block_count(cmd), bgstat, bghm);\n\t\tret = (-1);\n\t\tgoto out;\n\t}\n\n\tif (lpfc_bgs_get_uninit_dif_block(bgstat)) {\n\t\tcmd->result = DID_ERROR << 16;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9073 BLKGRD: Invalid BG PDIF Block in cmd \"\n\t\t\t\t\"0x%x reftag 0x%x blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tscsi_logical_block_count(cmd), bgstat, bghm);\n\t\tret = (-1);\n\t\tgoto out;\n\t}\n\n\tif (lpfc_bgs_get_guard_err(bgstat)) {\n\t\tret = 1;\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x1);\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\tphba->bg_guard_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9055 BLKGRD: Guard Tag error in cmd \"\n\t\t\t\t\"0x%x reftag 0x%x blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tscsi_logical_block_count(cmd), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_reftag_err(bgstat)) {\n\t\tret = 1;\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x3);\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\tphba->bg_reftag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9056 BLKGRD: Ref Tag error in cmd \"\n\t\t\t\t\"0x%x reftag 0x%x blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tscsi_logical_block_count(cmd), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_apptag_err(bgstat)) {\n\t\tret = 1;\n\t\tscsi_build_sense(cmd, 1, ILLEGAL_REQUEST, 0x10, 0x2);\n\t\tset_host_byte(cmd, DID_ABORT);\n\t\tphba->bg_apptag_err_cnt++;\n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9061 BLKGRD: App Tag error in cmd \"\n\t\t\t\t\"0x%x reftag 0x%x blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tscsi_logical_block_count(cmd), bgstat, bghm);\n\t}\n\n\tif (lpfc_bgs_get_hi_water_mark_present(bgstat)) {\n\t\t \n\t\tcmd->sense_buffer[7] = 0xc;    \n\t\tcmd->sense_buffer[8] = 0;      \n\t\tcmd->sense_buffer[9] = 0xa;    \n\t\tcmd->sense_buffer[10] = 0x80;  \n\n\t\t \n\t\tswitch (scsi_get_prot_op(cmd)) {\n\t\tcase SCSI_PROT_READ_INSERT:\n\t\tcase SCSI_PROT_WRITE_STRIP:\n\t\t\tbghm /= cmd->device->sector_size;\n\t\t\tbreak;\n\t\tcase SCSI_PROT_READ_STRIP:\n\t\tcase SCSI_PROT_WRITE_INSERT:\n\t\tcase SCSI_PROT_READ_PASS:\n\t\tcase SCSI_PROT_WRITE_PASS:\n\t\t\tbghm /= (cmd->device->sector_size +\n\t\t\t\tsizeof(struct scsi_dif_tuple));\n\t\t\tbreak;\n\t\t}\n\n\t\tfailing_sector = scsi_get_lba(cmd);\n\t\tfailing_sector += bghm;\n\n\t\t \n\t\tput_unaligned_be64(failing_sector, &cmd->sense_buffer[12]);\n\t}\n\n\tif (!ret) {\n\t\t \n\t\tlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t\"9057 BLKGRD: Unknown error in cmd \"\n\t\t\t\t\"0x%x reftag 0x%x blk cnt 0x%x \"\n\t\t\t\t\"bgstat=x%x bghm=x%x\\n\", cmd->cmnd[0],\n\t\t\t\tscsi_prot_ref_tag(cmd),\n\t\t\t\tscsi_logical_block_count(cmd), bgstat, bghm);\n\n\t\t \n\t\tlpfc_calc_bg_err(phba, lpfc_cmd);\n\t}\nout:\n\treturn ret;\n}\n\n \nstatic int\nlpfc_scsi_prep_dma_buf_s4(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct scatterlist *sgel = NULL;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct sli4_sge *sgl = (struct sli4_sge *)lpfc_cmd->dma_sgl;\n\tstruct sli4_sge *first_data_sgl;\n\tstruct lpfc_iocbq *pwqeq = &lpfc_cmd->cur_iocbq;\n\tstruct lpfc_vport *vport = phba->pport;\n\tunion lpfc_wqe128 *wqe = &pwqeq->wqe;\n\tdma_addr_t physaddr;\n\tuint32_t dma_len;\n\tuint32_t dma_offset = 0;\n\tint nseg, i, j;\n\tstruct ulp_bde64 *bde;\n\tbool lsp_just_set = false;\n\tstruct sli4_hybrid_sgl *sgl_xtra = NULL;\n\n\t \n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\t \n\n\t\tnseg = scsi_dma_map(scsi_cmnd);\n\t\tif (unlikely(nseg <= 0))\n\t\t\treturn 1;\n\t\tsgl += 1;\n\t\t \n\t\tsgl->word2 = le32_to_cpu(sgl->word2);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\tsgl += 1;\n\t\tfirst_data_sgl = sgl;\n\t\tlpfc_cmd->seg_cnt = nseg;\n\t\tif (!phba->cfg_xpsgl &&\n\t\t    lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9074 BLKGRD:\"\n\t\t\t\t\t\" %s: Too many sg segments from \"\n\t\t\t\t\t\"dma_map_sg.  Config %d, seg_cnt %d\\n\",\n\t\t\t\t\t__func__, phba->cfg_sg_seg_cnt,\n\t\t\t\t\tlpfc_cmd->seg_cnt);\n\t\t\tWARN_ON_ONCE(lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt);\n\t\t\tlpfc_cmd->seg_cnt = 0;\n\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\treturn 2;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tsgel = scsi_sglist(scsi_cmnd);\n\t\tj = 2;\n\t\tfor (i = 0; i < nseg; i++) {\n\t\t\tsgl->word2 = 0;\n\t\t\tif (nseg == 1) {\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t       LPFC_SGE_TYPE_DATA);\n\t\t\t} else {\n\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\n\t\t\t\t \n\t\t\t\tif (!lsp_just_set &&\n\t\t\t\t    !((j + 1) % phba->border_sge_num) &&\n\t\t\t\t    ((nseg - 1) != i)) {\n\t\t\t\t\t \n\t\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t\t       LPFC_SGE_TYPE_LSP);\n\n\t\t\t\t\tsgl_xtra = lpfc_get_sgl_per_hdwq(\n\t\t\t\t\t\t\tphba, lpfc_cmd);\n\n\t\t\t\t\tif (unlikely(!sgl_xtra)) {\n\t\t\t\t\t\tlpfc_cmd->seg_cnt = 0;\n\t\t\t\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\t       sgl_xtra->dma_phys_sgl));\n\t\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t       sgl_xtra->dma_phys_sgl));\n\n\t\t\t\t} else {\n\t\t\t\t\tbf_set(lpfc_sli4_sge_type, sgl,\n\t\t\t\t\t       LPFC_SGE_TYPE_DATA);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(bf_get(lpfc_sli4_sge_type, sgl) &\n\t\t\t\t     LPFC_SGE_TYPE_LSP)) {\n\t\t\t\tif ((nseg - 1) == i)\n\t\t\t\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\n\t\t\t\tphysaddr = sg_dma_address(sgel);\n\t\t\t\tdma_len = sg_dma_len(sgel);\n\t\t\t\tsgl->addr_lo = cpu_to_le32(putPaddrLow(\n\t\t\t\t\t\t\t   physaddr));\n\t\t\t\tsgl->addr_hi = cpu_to_le32(putPaddrHigh(\n\t\t\t\t\t\t\t   physaddr));\n\n\t\t\t\tbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\n\t\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\t\tsgl->sge_len = cpu_to_le32(dma_len);\n\n\t\t\t\tdma_offset += dma_len;\n\t\t\t\tsgel = sg_next(sgel);\n\n\t\t\t\tsgl++;\n\t\t\t\tlsp_just_set = false;\n\n\t\t\t} else {\n\t\t\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\t\t\t\tsgl->sge_len = cpu_to_le32(\n\t\t\t\t\t\t     phba->cfg_sg_dma_buf_size);\n\n\t\t\t\tsgl = (struct sli4_sge *)sgl_xtra->dma_sgl;\n\t\t\t\ti = i - 1;\n\n\t\t\t\tlsp_just_set = true;\n\t\t\t}\n\n\t\t\tj++;\n\t\t}\n\n\t\t \n\t\tif (nseg == 1 &&\n\t\t    ((phba->sli3_options & LPFC_SLI4_PERFH_ENABLED) ||\n\t\t     phba->cfg_enable_pbde)) {\n\t\t\t \n\t\t\tbde = (struct ulp_bde64 *)\n\t\t\t\t&wqe->words[13];\n\t\t\tbde->addrLow = first_data_sgl->addr_lo;\n\t\t\tbde->addrHigh = first_data_sgl->addr_hi;\n\t\t\tbde->tus.f.bdeSize =\n\t\t\t\t\tle32_to_cpu(first_data_sgl->sge_len);\n\t\t\tbde->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\n\t\t\tbde->tus.w = cpu_to_le32(bde->tus.w);\n\n\t\t\t \n\t\t\tbf_set(wqe_pbde, &wqe->generic.wqe_com, 1);\n\t\t} else {\n\t\t\tmemset(&wqe->words[13], 0, (sizeof(uint32_t) * 3));\n\t\t\t \n\t\t}\n\t} else {\n\t\tsgl += 1;\n\t\t \n\t\tsgl->word2 = le32_to_cpu(sgl->word2);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 1);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\n\t\tif ((phba->sli3_options & LPFC_SLI4_PERFH_ENABLED) ||\n\t\t    phba->cfg_enable_pbde) {\n\t\t\tbde = (struct ulp_bde64 *)\n\t\t\t\t&wqe->words[13];\n\t\t\tmemset(bde, 0, (sizeof(uint32_t) * 3));\n\t\t}\n\t}\n\n\t \n\tfcp_cmnd->fcpDl = cpu_to_be32(scsi_bufflen(scsi_cmnd));\n\t \n\tif (!(phba->hba_flag & HBA_FCOE_MODE) &&\n\t    vport->cfg_first_burst_size &&\n\t    scsi_cmnd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tu32 init_len, total_len;\n\n\t\ttotal_len = be32_to_cpu(fcp_cmnd->fcpDl);\n\t\tinit_len = min(total_len, vport->cfg_first_burst_size);\n\n\t\t \n\t\twqe->fcp_iwrite.initial_xfer_len = init_len;\n\t\twqe->fcp_iwrite.total_xfer_len = total_len;\n\t} else {\n\t\t \n\t\twqe->fcp_iwrite.total_xfer_len =\n\t\t\tbe32_to_cpu(fcp_cmnd->fcpDl);\n\t}\n\n\t \n\tif ((phba->cfg_fof) && ((struct lpfc_device_data *)\n\t\tscsi_cmnd->device->hostdata)->oas_enabled) {\n\t\tlpfc_cmd->cur_iocbq.cmd_flag |= (LPFC_IO_OAS | LPFC_IO_FOF);\n\t\tlpfc_cmd->cur_iocbq.priority = ((struct lpfc_device_data *)\n\t\t\tscsi_cmnd->device->hostdata)->priority;\n\n\t\t \n\t\tbf_set(wqe_oas, &wqe->generic.wqe_com, 1);\n\t\tbf_set(wqe_ccpe, &wqe->generic.wqe_com, 1);\n\n\t\tif (lpfc_cmd->cur_iocbq.priority)\n\t\t\tbf_set(wqe_ccp, &wqe->generic.wqe_com,\n\t\t\t       (lpfc_cmd->cur_iocbq.priority << 1));\n\t\telse\n\t\t\tbf_set(wqe_ccp, &wqe->generic.wqe_com,\n\t\t\t       (phba->cfg_XLanePriority << 1));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_bg_scsi_prep_dma_buf_s4(struct lpfc_hba *phba,\n\t\tstruct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct sli4_sge *sgl = (struct sli4_sge *)(lpfc_cmd->dma_sgl);\n\tstruct lpfc_iocbq *pwqeq = &lpfc_cmd->cur_iocbq;\n\tunion lpfc_wqe128 *wqe = &pwqeq->wqe;\n\tuint32_t num_sge = 0;\n\tint datasegcnt, protsegcnt, datadir = scsi_cmnd->sc_data_direction;\n\tint prot_group_type = 0;\n\tint fcpdl;\n\tint ret = 1;\n\tstruct lpfc_vport *vport = phba->pport;\n\n\t \n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\t \n\t\tdatasegcnt = dma_map_sg(&phba->pcidev->dev,\n\t\t\t\t\tscsi_sglist(scsi_cmnd),\n\t\t\t\t\tscsi_sg_count(scsi_cmnd), datadir);\n\t\tif (unlikely(!datasegcnt))\n\t\t\treturn 1;\n\n\t\tsgl += 1;\n\t\t \n\t\tsgl->word2 = le32_to_cpu(sgl->word2);\n\t\tbf_set(lpfc_sli4_sge_last, sgl, 0);\n\t\tsgl->word2 = cpu_to_le32(sgl->word2);\n\n\t\tsgl += 1;\n\t\tlpfc_cmd->seg_cnt = datasegcnt;\n\n\t\t \n\t\tif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt &&\n\t\t    !phba->cfg_xpsgl) {\n\t\t\tWARN_ON_ONCE(lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt);\n\t\t\tret = 2;\n\t\t\tgoto err;\n\t\t}\n\n\t\tprot_group_type = lpfc_prot_group_type(phba, scsi_cmnd);\n\n\t\tswitch (prot_group_type) {\n\t\tcase LPFC_PG_TYPE_NO_DIF:\n\t\t\t \n\t\t\tif (((lpfc_cmd->seg_cnt + 1) >\n\t\t\t\t\tphba->cfg_total_seg_cnt) &&\n\t\t\t    !phba->cfg_xpsgl) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnum_sge = lpfc_bg_setup_sgl(phba, scsi_cmnd, sgl,\n\t\t\t\t\tdatasegcnt, lpfc_cmd);\n\n\t\t\t \n\t\t\tif (num_sge < 2) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LPFC_PG_TYPE_DIF_BUF:\n\t\t\t \n\t\t\tprotsegcnt = dma_map_sg(&phba->pcidev->dev,\n\t\t\t\t\tscsi_prot_sglist(scsi_cmnd),\n\t\t\t\t\tscsi_prot_sg_count(scsi_cmnd), datadir);\n\t\t\tif (unlikely(!protsegcnt)) {\n\t\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tlpfc_cmd->prot_seg_cnt = protsegcnt;\n\t\t\t \n\t\t\tif (((lpfc_cmd->prot_seg_cnt * 3) >\n\t\t\t\t\t(phba->cfg_total_seg_cnt - 2)) &&\n\t\t\t    !phba->cfg_xpsgl) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tnum_sge = lpfc_bg_setup_sgl_prot(phba, scsi_cmnd, sgl,\n\t\t\t\t\tdatasegcnt, protsegcnt, lpfc_cmd);\n\n\t\t\t \n\t\t\tif (num_sge < 3 ||\n\t\t\t    (num_sge > phba->cfg_total_seg_cnt &&\n\t\t\t     !phba->cfg_xpsgl)) {\n\t\t\t\tret = 2;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase LPFC_PG_TYPE_INVALID:\n\t\tdefault:\n\t\t\tscsi_dma_unmap(scsi_cmnd);\n\t\t\tlpfc_cmd->seg_cnt = 0;\n\n\t\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t\"9083 Unexpected protection group %i\\n\",\n\t\t\t\t\tprot_group_type);\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tswitch (scsi_get_prot_op(scsi_cmnd)) {\n\tcase SCSI_PROT_WRITE_STRIP:\n\tcase SCSI_PROT_READ_STRIP:\n\t\tlpfc_cmd->cur_iocbq.cmd_flag |= LPFC_IO_DIF_STRIP;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_INSERT:\n\tcase SCSI_PROT_READ_INSERT:\n\t\tlpfc_cmd->cur_iocbq.cmd_flag |= LPFC_IO_DIF_INSERT;\n\t\tbreak;\n\tcase SCSI_PROT_WRITE_PASS:\n\tcase SCSI_PROT_READ_PASS:\n\t\tlpfc_cmd->cur_iocbq.cmd_flag |= LPFC_IO_DIF_PASS;\n\t\tbreak;\n\t}\n\n\tfcpdl = lpfc_bg_scsi_adjust_dl(phba, lpfc_cmd);\n\tfcp_cmnd->fcpDl = be32_to_cpu(fcpdl);\n\n\t \n\tif (!(phba->hba_flag & HBA_FCOE_MODE) &&\n\t    vport->cfg_first_burst_size &&\n\t    scsi_cmnd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tu32 init_len, total_len;\n\n\t\ttotal_len = be32_to_cpu(fcp_cmnd->fcpDl);\n\t\tinit_len = min(total_len, vport->cfg_first_burst_size);\n\n\t\t \n\t\twqe->fcp_iwrite.initial_xfer_len = init_len;\n\t\twqe->fcp_iwrite.total_xfer_len = total_len;\n\t} else {\n\t\t \n\t\twqe->fcp_iwrite.total_xfer_len =\n\t\t\tbe32_to_cpu(fcp_cmnd->fcpDl);\n\t}\n\n\t \n\tif ((phba->cfg_fof) && ((struct lpfc_device_data *)\n\t\tscsi_cmnd->device->hostdata)->oas_enabled) {\n\t\tlpfc_cmd->cur_iocbq.cmd_flag |= (LPFC_IO_OAS | LPFC_IO_FOF);\n\n\t\t \n\t\tbf_set(wqe_oas, &wqe->generic.wqe_com, 1);\n\t\tbf_set(wqe_ccpe, &wqe->generic.wqe_com, 1);\n\t\tbf_set(wqe_ccp, &wqe->generic.wqe_com,\n\t\t       (phba->cfg_XLanePriority << 1));\n\t}\n\n\t \n\tif (lpfc_cmd->cur_iocbq.cmd_flag & LPFC_IO_DIF_PASS)\n\t\tbf_set(wqe_dif, &wqe->generic.wqe_com, LPFC_WQE_DIF_PASSTHRU);\n\telse if (lpfc_cmd->cur_iocbq.cmd_flag & LPFC_IO_DIF_STRIP)\n\t\tbf_set(wqe_dif, &wqe->generic.wqe_com, LPFC_WQE_DIF_STRIP);\n\telse if (lpfc_cmd->cur_iocbq.cmd_flag & LPFC_IO_DIF_INSERT)\n\t\tbf_set(wqe_dif, &wqe->generic.wqe_com, LPFC_WQE_DIF_INSERT);\n\n\tlpfc_cmd->cur_iocbq.cmd_flag &= ~(LPFC_IO_DIF_PASS |\n\t\t\t\t LPFC_IO_DIF_STRIP | LPFC_IO_DIF_INSERT);\n\n\treturn 0;\nerr:\n\tif (lpfc_cmd->seg_cnt)\n\t\tscsi_dma_unmap(scsi_cmnd);\n\tif (lpfc_cmd->prot_seg_cnt)\n\t\tdma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(scsi_cmnd),\n\t\t\t     scsi_prot_sg_count(scsi_cmnd),\n\t\t\t     scsi_cmnd->sc_data_direction);\n\n\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"9084 Cannot setup S/G List for HBA \"\n\t\t\t\"IO segs %d/%d SGL %d SCSI %d: %d %d %d\\n\",\n\t\t\tlpfc_cmd->seg_cnt, lpfc_cmd->prot_seg_cnt,\n\t\t\tphba->cfg_total_seg_cnt, phba->cfg_sg_seg_cnt,\n\t\t\tprot_group_type, num_sge, ret);\n\n\tlpfc_cmd->seg_cnt = 0;\n\tlpfc_cmd->prot_seg_cnt = 0;\n\treturn ret;\n}\n\n \nstatic inline int\nlpfc_scsi_prep_dma_buf(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\treturn phba->lpfc_scsi_prep_dma_buf(phba, lpfc_cmd);\n}\n\n \nstatic inline int\nlpfc_bg_scsi_prep_dma_buf(struct lpfc_hba *phba, struct lpfc_io_buf *lpfc_cmd)\n{\n\treturn phba->lpfc_bg_scsi_prep_dma_buf(phba, lpfc_cmd);\n}\n\n \nstatic inline int\nlpfc_scsi_prep_cmnd_buf(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd,\n\t\t\tuint8_t tmo)\n{\n\treturn vport->phba->lpfc_scsi_prep_cmnd_buf(vport, lpfc_cmd, tmo);\n}\n\n \nstatic void\nlpfc_send_scsi_error_event(struct lpfc_hba *phba, struct lpfc_vport *vport,\n\t\tstruct lpfc_io_buf *lpfc_cmd, uint32_t fcpi_parm) {\n\tstruct scsi_cmnd *cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\n\tuint32_t resp_info = fcprsp->rspStatus2;\n\tuint32_t scsi_status = fcprsp->rspStatus3;\n\tstruct lpfc_fast_path_event *fast_path_evt = NULL;\n\tstruct lpfc_nodelist *pnode = lpfc_cmd->rdata->pnode;\n\tunsigned long flags;\n\n\tif (!pnode)\n\t\treturn;\n\n\t \n\tif ((cmnd->result == SAM_STAT_TASK_SET_FULL) ||\n\t\t(cmnd->result == SAM_STAT_BUSY)) {\n\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\tif (!fast_path_evt)\n\t\t\treturn;\n\t\tfast_path_evt->un.scsi_evt.event_type =\n\t\t\tFC_REG_SCSI_EVENT;\n\t\tfast_path_evt->un.scsi_evt.subcategory =\n\t\t(cmnd->result == SAM_STAT_TASK_SET_FULL) ?\n\t\tLPFC_EVENT_QFULL : LPFC_EVENT_DEVBSY;\n\t\tfast_path_evt->un.scsi_evt.lun = cmnd->device->lun;\n\t\tmemcpy(&fast_path_evt->un.scsi_evt.wwpn,\n\t\t\t&pnode->nlp_portname, sizeof(struct lpfc_name));\n\t\tmemcpy(&fast_path_evt->un.scsi_evt.wwnn,\n\t\t\t&pnode->nlp_nodename, sizeof(struct lpfc_name));\n\t} else if ((resp_info & SNS_LEN_VALID) && fcprsp->rspSnsLen &&\n\t\t((cmnd->cmnd[0] == READ_10) || (cmnd->cmnd[0] == WRITE_10))) {\n\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\tif (!fast_path_evt)\n\t\t\treturn;\n\t\tfast_path_evt->un.check_cond_evt.scsi_event.event_type =\n\t\t\tFC_REG_SCSI_EVENT;\n\t\tfast_path_evt->un.check_cond_evt.scsi_event.subcategory =\n\t\t\tLPFC_EVENT_CHECK_COND;\n\t\tfast_path_evt->un.check_cond_evt.scsi_event.lun =\n\t\t\tcmnd->device->lun;\n\t\tmemcpy(&fast_path_evt->un.check_cond_evt.scsi_event.wwpn,\n\t\t\t&pnode->nlp_portname, sizeof(struct lpfc_name));\n\t\tmemcpy(&fast_path_evt->un.check_cond_evt.scsi_event.wwnn,\n\t\t\t&pnode->nlp_nodename, sizeof(struct lpfc_name));\n\t\tfast_path_evt->un.check_cond_evt.sense_key =\n\t\t\tcmnd->sense_buffer[2] & 0xf;\n\t\tfast_path_evt->un.check_cond_evt.asc = cmnd->sense_buffer[12];\n\t\tfast_path_evt->un.check_cond_evt.ascq = cmnd->sense_buffer[13];\n\t} else if ((cmnd->sc_data_direction == DMA_FROM_DEVICE) &&\n\t\t     fcpi_parm &&\n\t\t     ((be32_to_cpu(fcprsp->rspResId) != fcpi_parm) ||\n\t\t\t((scsi_status == SAM_STAT_GOOD) &&\n\t\t\t!(resp_info & (RESID_UNDER | RESID_OVER))))) {\n\t\t \n\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\tif (!fast_path_evt)\n\t\t\treturn;\n\t\tfast_path_evt->un.read_check_error.header.event_type =\n\t\t\tFC_REG_FABRIC_EVENT;\n\t\tfast_path_evt->un.read_check_error.header.subcategory =\n\t\t\tLPFC_EVENT_FCPRDCHKERR;\n\t\tmemcpy(&fast_path_evt->un.read_check_error.header.wwpn,\n\t\t\t&pnode->nlp_portname, sizeof(struct lpfc_name));\n\t\tmemcpy(&fast_path_evt->un.read_check_error.header.wwnn,\n\t\t\t&pnode->nlp_nodename, sizeof(struct lpfc_name));\n\t\tfast_path_evt->un.read_check_error.lun = cmnd->device->lun;\n\t\tfast_path_evt->un.read_check_error.opcode = cmnd->cmnd[0];\n\t\tfast_path_evt->un.read_check_error.fcpiparam =\n\t\t\tfcpi_parm;\n\t} else\n\t\treturn;\n\n\tfast_path_evt->vport = vport;\n\tspin_lock_irqsave(&phba->hbalock, flags);\n\tlist_add_tail(&fast_path_evt->work_evt.evt_listp, &phba->work_list);\n\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\tlpfc_worker_wake_up(phba);\n\treturn;\n}\n\n \nstatic void\nlpfc_scsi_unprep_dma_buf(struct lpfc_hba *phba, struct lpfc_io_buf *psb)\n{\n\t \n\tif (psb->seg_cnt > 0)\n\t\tscsi_dma_unmap(psb->pCmd);\n\tif (psb->prot_seg_cnt > 0)\n\t\tdma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(psb->pCmd),\n\t\t\t\tscsi_prot_sg_count(psb->pCmd),\n\t\t\t\tpsb->pCmd->sc_data_direction);\n}\n\n \nvoid\nlpfc_unblock_requests(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct Scsi_Host  *shost;\n\tint i;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    !phba->sli4_hba.max_cfg_param.vpi_used) {\n\t\tshost = lpfc_shost_from_vport(phba->pport);\n\t\tscsi_unblock_requests(shost);\n\t\treturn;\n\t}\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL)\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tscsi_unblock_requests(shost);\n\t\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\n \nvoid\nlpfc_block_requests(struct lpfc_hba *phba)\n{\n\tstruct lpfc_vport **vports;\n\tstruct Scsi_Host  *shost;\n\tint i;\n\n\tif (atomic_read(&phba->cmf_stop_io))\n\t\treturn;\n\n\tif (phba->sli_rev == LPFC_SLI_REV4 &&\n\t    !phba->sli4_hba.max_cfg_param.vpi_used) {\n\t\tshost = lpfc_shost_from_vport(phba->pport);\n\t\tscsi_block_requests(shost);\n\t\treturn;\n\t}\n\n\tvports = lpfc_create_vport_work_array(phba);\n\tif (vports != NULL)\n\t\tfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\n\t\t\tshost = lpfc_shost_from_vport(vports[i]);\n\t\t\tscsi_block_requests(shost);\n\t\t}\n\tlpfc_destroy_vport_work_array(phba, vports);\n}\n\n \nint\nlpfc_update_cmf_cmpl(struct lpfc_hba *phba,\n\t\t     uint64_t time, uint32_t size, struct Scsi_Host *shost)\n{\n\tstruct lpfc_cgn_stat *cgs;\n\n\tif (time != LPFC_CGN_NOT_SENT) {\n\t\t \n\t\tif (time < 1000)\n\t\t\ttime = 1;\n\t\telse\n\t\t\ttime = div_u64(time + 500, 1000);  \n\n\t\tcgs = per_cpu_ptr(phba->cmf_stat, raw_smp_processor_id());\n\t\tatomic64_add(size, &cgs->rcv_bytes);\n\t\tatomic64_add(time, &cgs->rx_latency);\n\t\tatomic_inc(&cgs->rx_io_cnt);\n\t}\n\treturn 0;\n}\n\n \nint\nlpfc_update_cmf_cmd(struct lpfc_hba *phba, uint32_t size)\n{\n\tuint64_t total;\n\tstruct lpfc_cgn_stat *cgs;\n\tint cpu;\n\n\t \n\tif (phba->cmf_active_mode == LPFC_CFG_MANAGED &&\n\t    phba->cmf_max_bytes_per_interval) {\n\t\ttotal = 0;\n\t\tfor_each_present_cpu(cpu) {\n\t\t\tcgs = per_cpu_ptr(phba->cmf_stat, cpu);\n\t\t\ttotal += atomic64_read(&cgs->total_bytes);\n\t\t}\n\t\tif (total >= phba->cmf_max_bytes_per_interval) {\n\t\t\tif (!atomic_xchg(&phba->cmf_bw_wait, 1)) {\n\t\t\t\tlpfc_block_requests(phba);\n\t\t\t\tphba->cmf_last_ts =\n\t\t\t\t\tlpfc_calc_cmf_latency(phba);\n\t\t\t}\n\t\t\tatomic_inc(&phba->cmf_busy);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (size > atomic_read(&phba->rx_max_read_cnt))\n\t\t\tatomic_set(&phba->rx_max_read_cnt, size);\n\t}\n\n\tcgs = per_cpu_ptr(phba->cmf_stat, raw_smp_processor_id());\n\tatomic64_add(size, &cgs->total_bytes);\n\treturn 0;\n}\n\n \nstatic void\nlpfc_handle_fcp_err(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd,\n\t\t    uint32_t fcpi_parm)\n{\n\tstruct scsi_cmnd *cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcpcmd = lpfc_cmd->fcp_cmnd;\n\tstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\n\tuint32_t resp_info = fcprsp->rspStatus2;\n\tuint32_t scsi_status = fcprsp->rspStatus3;\n\tuint32_t *lp;\n\tuint32_t host_status = DID_OK;\n\tuint32_t rsplen = 0;\n\tuint32_t fcpDl;\n\tuint32_t logit = LOG_FCP | LOG_FCP_ERROR;\n\n\n\t \n\tif (fcpcmd->fcpCntl2) {\n\t\tscsi_status = 0;\n\t\tgoto out;\n\t}\n\n\tif (resp_info & RSP_LEN_VALID) {\n\t\trsplen = be32_to_cpu(fcprsp->rspRspLen);\n\t\tif (rsplen != 0 && rsplen != 4 && rsplen != 8) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"2719 Invalid response length: \"\n\t\t\t\t\t \"tgt x%x lun x%llx cmnd x%x rsplen \"\n\t\t\t\t\t \"x%x\\n\", cmnd->device->id,\n\t\t\t\t\t cmnd->device->lun, cmnd->cmnd[0],\n\t\t\t\t\t rsplen);\n\t\t\thost_status = DID_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif (fcprsp->rspInfo3 != RSP_NO_FAILURE) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2757 Protocol failure detected during \"\n\t\t\t\t \"processing of FCP I/O op: \"\n\t\t\t\t \"tgt x%x lun x%llx cmnd x%x rspInfo3 x%x\\n\",\n\t\t\t\t cmnd->device->id,\n\t\t\t\t cmnd->device->lun, cmnd->cmnd[0],\n\t\t\t\t fcprsp->rspInfo3);\n\t\t\thost_status = DID_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif ((resp_info & SNS_LEN_VALID) && fcprsp->rspSnsLen) {\n\t\tuint32_t snslen = be32_to_cpu(fcprsp->rspSnsLen);\n\t\tif (snslen > SCSI_SENSE_BUFFERSIZE)\n\t\t\tsnslen = SCSI_SENSE_BUFFERSIZE;\n\n\t\tif (resp_info & RSP_LEN_VALID)\n\t\t  rsplen = be32_to_cpu(fcprsp->rspRspLen);\n\t\tmemcpy(cmnd->sense_buffer, &fcprsp->rspInfo0 + rsplen, snslen);\n\t}\n\tlp = (uint32_t *)cmnd->sense_buffer;\n\n\t \n\tif (!scsi_status && (resp_info & RESID_UNDER)) {\n\t\t \n\t\tif (vport->cfg_log_verbose & LOG_FCP)\n\t\t\tlogit = LOG_FCP_ERROR;\n\t\t \n\t\tif (vport->cfg_log_verbose & LOG_FCP_UNDER)\n\t\t\tlogit = LOG_FCP_UNDER;\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t \"9024 FCP command x%x failed: x%x SNS x%x x%x \"\n\t\t\t \"Data: x%x x%x x%x x%x x%x\\n\",\n\t\t\t cmnd->cmnd[0], scsi_status,\n\t\t\t be32_to_cpu(*lp), be32_to_cpu(*(lp + 3)), resp_info,\n\t\t\t be32_to_cpu(fcprsp->rspResId),\n\t\t\t be32_to_cpu(fcprsp->rspSnsLen),\n\t\t\t be32_to_cpu(fcprsp->rspRspLen),\n\t\t\t fcprsp->rspInfo3);\n\n\tscsi_set_resid(cmnd, 0);\n\tfcpDl = be32_to_cpu(fcpcmd->fcpDl);\n\tif (resp_info & RESID_UNDER) {\n\t\tscsi_set_resid(cmnd, be32_to_cpu(fcprsp->rspResId));\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP_UNDER,\n\t\t\t\t \"9025 FCP Underrun, expected %d, \"\n\t\t\t\t \"residual %d Data: x%x x%x x%x\\n\",\n\t\t\t\t fcpDl,\n\t\t\t\t scsi_get_resid(cmnd), fcpi_parm, cmnd->cmnd[0],\n\t\t\t\t cmnd->underflow);\n\n\t\t \n\t\tif (fcpi_parm && (scsi_get_resid(cmnd) != fcpi_parm)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_WARNING,\n\t\t\t\t\t LOG_FCP | LOG_FCP_ERROR,\n\t\t\t\t\t \"9026 FCP Read Check Error \"\n\t\t\t\t\t \"and Underrun Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t\t fcpDl,\n\t\t\t\t\t scsi_get_resid(cmnd), fcpi_parm,\n\t\t\t\t\t cmnd->cmnd[0]);\n\t\t\tscsi_set_resid(cmnd, scsi_bufflen(cmnd));\n\t\t\thost_status = DID_ERROR;\n\t\t}\n\t\t \n\t\tif (!(resp_info & SNS_LEN_VALID) &&\n\t\t    (scsi_status == SAM_STAT_GOOD) &&\n\t\t    (scsi_bufflen(cmnd) - scsi_get_resid(cmnd)\n\t\t     < cmnd->underflow)) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t \"9027 FCP command x%x residual \"\n\t\t\t\t\t \"underrun converted to error \"\n\t\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t\t cmnd->cmnd[0], scsi_bufflen(cmnd),\n\t\t\t\t\t scsi_get_resid(cmnd), cmnd->underflow);\n\t\t\thost_status = DID_ERROR;\n\t\t}\n\t} else if (resp_info & RESID_OVER) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\t \"9028 FCP command x%x residual overrun error. \"\n\t\t\t\t \"Data: x%x x%x\\n\", cmnd->cmnd[0],\n\t\t\t\t scsi_bufflen(cmnd), scsi_get_resid(cmnd));\n\t\thost_status = DID_ERROR;\n\n\t \n\t} else if (fcpi_parm) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP | LOG_FCP_ERROR,\n\t\t\t\t \"9029 FCP %s Check Error Data: \"\n\t\t\t\t \"x%x x%x x%x x%x x%x\\n\",\n\t\t\t\t ((cmnd->sc_data_direction == DMA_FROM_DEVICE) ?\n\t\t\t\t \"Read\" : \"Write\"),\n\t\t\t\t fcpDl, be32_to_cpu(fcprsp->rspResId),\n\t\t\t\t fcpi_parm, cmnd->cmnd[0], scsi_status);\n\n\t\t \n\t\tif (fcpi_parm > fcpDl)\n\t\t\tgoto out;\n\n\t\tswitch (scsi_status) {\n\t\tcase SAM_STAT_GOOD:\n\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\t\t \n\t\t\thost_status = DID_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tscsi_set_resid(cmnd, scsi_bufflen(cmnd));\n\t}\n\n out:\n\tcmnd->result = host_status << 16 | scsi_status;\n\tlpfc_send_scsi_error_event(vport->phba, vport, lpfc_cmd, fcpi_parm);\n}\n\n \nstatic void\nlpfc_fcp_io_cmd_wqe_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *pwqeIn,\n\t\t\t struct lpfc_iocbq *pwqeOut)\n{\n\tstruct lpfc_io_buf *lpfc_cmd = pwqeIn->io_buf;\n\tstruct lpfc_wcqe_complete *wcqe = &pwqeOut->wcqe_cmpl;\n\tstruct lpfc_vport *vport = pwqeIn->vport;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct scsi_cmnd *cmd;\n\tunsigned long flags;\n\tstruct lpfc_fast_path_event *fast_path_evt;\n\tstruct Scsi_Host *shost;\n\tu32 logit = LOG_FCP;\n\tu32 idx;\n\tu32 lat;\n\tu8 wait_xb_clr = 0;\n\n\t \n\tif (!lpfc_cmd) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"9032 Null lpfc_cmd pointer. No \"\n\t\t\t\t \"release, skip completion\\n\");\n\t\treturn;\n\t}\n\n\trdata = lpfc_cmd->rdata;\n\tndlp = rdata->pnode;\n\n\t \n\tcmd = lpfc_cmd->pCmd;\n\tif (!cmd) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"9042 I/O completion: Not an active IO\\n\");\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\t\treturn;\n\t}\n\t \n\tspin_lock(&lpfc_cmd->buf_lock);\n\tidx = lpfc_cmd->cur_iocbq.hba_wqidx;\n\tif (phba->sli4_hba.hdwq)\n\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.io_cmpls++;\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (unlikely(phba->hdwqstat_on & LPFC_CHECK_SCSI_IO))\n\t\tthis_cpu_inc(phba->sli4_hba.c_stat->cmpl_io);\n#endif\n\tshost = cmd->device->host;\n\n\tlpfc_cmd->status = bf_get(lpfc_wcqe_c_status, wcqe);\n\tlpfc_cmd->result = (wcqe->parameter & IOERR_PARAM_MASK);\n\n\tlpfc_cmd->flags &= ~LPFC_SBUF_XBUSY;\n\tif (bf_get(lpfc_wcqe_c_xb, wcqe)) {\n\t\tlpfc_cmd->flags |= LPFC_SBUF_XBUSY;\n\t\tif (phba->cfg_fcp_wait_abts_rsp)\n\t\t\twait_xb_clr = 1;\n\t}\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_cmd->prot_data_type) {\n\t\tstruct scsi_dif_tuple *src = NULL;\n\n\t\tsrc =  (struct scsi_dif_tuple *)lpfc_cmd->prot_data_segment;\n\t\t \n\t\tswitch (lpfc_cmd->prot_data_type) {\n\t\tcase LPFC_INJERR_REFTAG:\n\t\t\tsrc->ref_tag =\n\t\t\t\tlpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tcase LPFC_INJERR_APPTAG:\n\t\t\tsrc->app_tag =\n\t\t\t\t(uint16_t)lpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tcase LPFC_INJERR_GUARD:\n\t\t\tsrc->guard_tag =\n\t\t\t\t(uint16_t)lpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tlpfc_cmd->prot_data = 0;\n\t\tlpfc_cmd->prot_data_type = 0;\n\t\tlpfc_cmd->prot_data_segment = NULL;\n\t}\n#endif\n\tif (unlikely(lpfc_cmd->status)) {\n\t\tif (lpfc_cmd->status == IOSTAT_FCP_RSP_ERROR &&\n\t\t    !lpfc_cmd->fcp_rsp->rspStatus3 &&\n\t\t    (lpfc_cmd->fcp_rsp->rspStatus2 & RESID_UNDER) &&\n\t\t    !(vport->cfg_log_verbose & LOG_FCP_UNDER))\n\t\t\tlogit = 0;\n\t\telse\n\t\t\tlogit = LOG_FCP | LOG_FCP_UNDER;\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t\t \"9034 FCP cmd x%x failed <%d/%lld> \"\n\t\t\t\t \"status: x%x result: x%x \"\n\t\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t cmd->cmnd[0],\n\t\t\t\t cmd->device ? cmd->device->id : 0xffff,\n\t\t\t\t cmd->device ? cmd->device->lun : 0xffff,\n\t\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t\t vport->fc_myDID,\n\t\t\t\t (ndlp) ? ndlp->nlp_DID : 0,\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t wcqe->parameter, wcqe->total_data_placed,\n\t\t\t\t lpfc_cmd->cur_iocbq.iotag);\n\t}\n\n\tswitch (lpfc_cmd->status) {\n\tcase CQE_STATUS_SUCCESS:\n\t\tcmd->result = DID_OK << 16;\n\t\tbreak;\n\tcase CQE_STATUS_FCP_RSP_FAILURE:\n\t\tlpfc_handle_fcp_err(vport, lpfc_cmd,\n\t\t\t\t    pwqeIn->wqe.fcp_iread.total_xfer_len -\n\t\t\t\t    wcqe->total_data_placed);\n\t\tbreak;\n\tcase CQE_STATUS_NPORT_BSY:\n\tcase CQE_STATUS_FABRIC_BSY:\n\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\tif (!fast_path_evt)\n\t\t\tbreak;\n\t\tfast_path_evt->un.fabric_evt.event_type =\n\t\t\tFC_REG_FABRIC_EVENT;\n\t\tfast_path_evt->un.fabric_evt.subcategory =\n\t\t\t(lpfc_cmd->status == IOSTAT_NPORT_BSY) ?\n\t\t\tLPFC_EVENT_PORT_BUSY : LPFC_EVENT_FABRIC_BUSY;\n\t\tif (ndlp) {\n\t\t\tmemcpy(&fast_path_evt->un.fabric_evt.wwpn,\n\t\t\t       &ndlp->nlp_portname,\n\t\t\t\tsizeof(struct lpfc_name));\n\t\t\tmemcpy(&fast_path_evt->un.fabric_evt.wwnn,\n\t\t\t       &ndlp->nlp_nodename,\n\t\t\t\tsizeof(struct lpfc_name));\n\t\t}\n\t\tfast_path_evt->vport = vport;\n\t\tfast_path_evt->work_evt.evt =\n\t\t\tLPFC_EVT_FASTPATH_MGMT_EVT;\n\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\tlist_add_tail(&fast_path_evt->work_evt.evt_listp,\n\t\t\t      &phba->work_list);\n\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\tlpfc_worker_wake_up(phba);\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t\t \"9035 Fabric/Node busy FCP cmd x%x failed\"\n\t\t\t\t \" <%d/%lld> \"\n\t\t\t\t \"status: x%x result: x%x \"\n\t\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t cmd->cmnd[0],\n\t\t\t\t cmd->device ? cmd->device->id : 0xffff,\n\t\t\t\t cmd->device ? cmd->device->lun : 0xffff,\n\t\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t\t vport->fc_myDID,\n\t\t\t\t (ndlp) ? ndlp->nlp_DID : 0,\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t wcqe->parameter,\n\t\t\t\t wcqe->total_data_placed,\n\t\t\t\t lpfc_cmd->cur_iocbq.iocb.ulpIoTag);\n\t\tbreak;\n\tcase CQE_STATUS_DI_ERROR:\n\t\tif (bf_get(lpfc_wcqe_c_bg_edir, wcqe))\n\t\t\tlpfc_cmd->result = IOERR_RX_DMA_FAILED;\n\t\telse\n\t\t\tlpfc_cmd->result = IOERR_TX_DMA_FAILED;\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP | LOG_BG,\n\t\t\t\t \"9048 DI Error xri x%x status x%x DI ext \"\n\t\t\t\t \"status x%x data placed x%x\\n\",\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t lpfc_cmd->status, wcqe->parameter,\n\t\t\t\t wcqe->total_data_placed);\n\t\tif (scsi_get_prot_op(cmd) != SCSI_PROT_NORMAL) {\n\t\t\t \n\t\t\tlpfc_parse_bg_err(phba, lpfc_cmd, pwqeOut);\n\t\t\tbreak;\n\t\t}\n\t\tcmd->result = DID_ERROR << 16;\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_BG,\n\t\t\t\t \"9040 DI Error on unprotected cmd\\n\");\n\t\tbreak;\n\tcase CQE_STATUS_REMOTE_STOP:\n\t\tif (ndlp) {\n\t\t\t \n\t\t\tlpfc_set_rrq_active(phba, ndlp,\n\t\t\t\t\t    lpfc_cmd->cur_iocbq.sli4_lxritag,\n\t\t\t\t\t    0, 0);\n\t\t}\n\t\tfallthrough;\n\tcase CQE_STATUS_LOCAL_REJECT:\n\t\tif (lpfc_cmd->result & IOERR_DRVR_MASK)\n\t\t\tlpfc_cmd->status = IOSTAT_DRIVER_REJECT;\n\t\tif (lpfc_cmd->result == IOERR_ELXSEC_KEY_UNWRAP_ERROR ||\n\t\t    lpfc_cmd->result ==\n\t\t    IOERR_ELXSEC_KEY_UNWRAP_COMPARE_ERROR ||\n\t\t    lpfc_cmd->result == IOERR_ELXSEC_CRYPTO_ERROR ||\n\t\t    lpfc_cmd->result ==\n\t\t    IOERR_ELXSEC_CRYPTO_COMPARE_ERROR) {\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\tbreak;\n\t\t}\n\t\tif (lpfc_cmd->result == IOERR_INVALID_RPI ||\n\t\t    lpfc_cmd->result == IOERR_LINK_DOWN ||\n\t\t    lpfc_cmd->result == IOERR_NO_RESOURCES ||\n\t\t    lpfc_cmd->result == IOERR_ABORT_REQUESTED ||\n\t\t    lpfc_cmd->result == IOERR_RPI_SUSPENDED ||\n\t\t    lpfc_cmd->result == IOERR_SLER_CMD_RCV_FAILURE) {\n\t\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\t\tbreak;\n\t\t}\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t\t \"9036 Local Reject FCP cmd x%x failed\"\n\t\t\t\t \" <%d/%lld> \"\n\t\t\t\t \"status: x%x result: x%x \"\n\t\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t\t \"Data: x%x x%x x%x\\n\",\n\t\t\t\t cmd->cmnd[0],\n\t\t\t\t cmd->device ? cmd->device->id : 0xffff,\n\t\t\t\t cmd->device ? cmd->device->lun : 0xffff,\n\t\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t\t vport->fc_myDID,\n\t\t\t\t (ndlp) ? ndlp->nlp_DID : 0,\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t wcqe->parameter,\n\t\t\t\t wcqe->total_data_placed,\n\t\t\t\t lpfc_cmd->cur_iocbq.iocb.ulpIoTag);\n\t\tfallthrough;\n\tdefault:\n\t\tcmd->result = DID_ERROR << 16;\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t \"9037 FCP Completion Error: xri %x \"\n\t\t\t\t \"status x%x result x%x [x%x] \"\n\t\t\t\t \"placed x%x\\n\",\n\t\t\t\t lpfc_cmd->cur_iocbq.sli4_xritag,\n\t\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t\t wcqe->parameter,\n\t\t\t\t wcqe->total_data_placed);\n\t}\n\tif (cmd->result || lpfc_cmd->fcp_rsp->rspSnsLen) {\n\t\tu32 *lp = (u32 *)cmd->sense_buffer;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t \"9039 Iodone <%d/%llu> cmd x%px, error \"\n\t\t\t\t \"x%x SNS x%x x%x LBA x%llx Data: x%x x%x\\n\",\n\t\t\t\t cmd->device->id, cmd->device->lun, cmd,\n\t\t\t\t cmd->result, *lp, *(lp + 3),\n\t\t\t\t (cmd->device->sector_size) ?\n\t\t\t\t (u64)scsi_get_lba(cmd) : 0,\n\t\t\t\t cmd->retries, scsi_get_resid(cmd));\n\t}\n\n\tif (vport->cfg_max_scsicmpl_time &&\n\t    time_after(jiffies, lpfc_cmd->start_time +\n\t    msecs_to_jiffies(vport->cfg_max_scsicmpl_time))) {\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tif (ndlp) {\n\t\t\tif (ndlp->cmd_qdepth >\n\t\t\t\tatomic_read(&ndlp->cmd_pending) &&\n\t\t\t\t(atomic_read(&ndlp->cmd_pending) >\n\t\t\t\tLPFC_MIN_TGT_QDEPTH) &&\n\t\t\t\t(cmd->cmnd[0] == READ_10 ||\n\t\t\t\tcmd->cmnd[0] == WRITE_10))\n\t\t\t\tndlp->cmd_qdepth =\n\t\t\t\t\tatomic_read(&ndlp->cmd_pending);\n\n\t\t\tndlp->last_change_time = jiffies;\n\t\t}\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n\tlpfc_scsi_unprep_dma_buf(phba, lpfc_cmd);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_cmd->ts_cmd_start) {\n\t\tlpfc_cmd->ts_isr_cmpl = lpfc_cmd->cur_iocbq.isr_timestamp;\n\t\tlpfc_cmd->ts_data_io = ktime_get_ns();\n\t\tphba->ktime_last_cmd = lpfc_cmd->ts_data_io;\n\t\tlpfc_io_ktime(phba, lpfc_cmd);\n\t}\n#endif\n\tif (likely(!wait_xb_clr))\n\t\tlpfc_cmd->pCmd = NULL;\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\n\t \n\tif (phba->cmf_active_mode != LPFC_CFG_OFF &&\n\t    cmd->sc_data_direction == DMA_FROM_DEVICE &&\n\t    (scsi_sg_count(cmd))) {\n\t\t \n\t\tlat = ktime_get_ns() - lpfc_cmd->rx_cmd_start;\n\t\tlpfc_update_cmf_cmpl(phba, lat, scsi_bufflen(cmd), shost);\n\t}\n\n\tif (wait_xb_clr)\n\t\tgoto out;\n\n\t \n\tscsi_done(cmd);\n\n\t \n\tspin_lock(&lpfc_cmd->buf_lock);\n\tlpfc_cmd->cur_iocbq.cmd_flag &= ~LPFC_DRIVER_ABORTED;\n\tif (lpfc_cmd->waitq)\n\t\twake_up(lpfc_cmd->waitq);\n\tspin_unlock(&lpfc_cmd->buf_lock);\nout:\n\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n}\n\n \nstatic void\nlpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *pIocbIn,\n\t\t\tstruct lpfc_iocbq *pIocbOut)\n{\n\tstruct lpfc_io_buf *lpfc_cmd =\n\t\t(struct lpfc_io_buf *) pIocbIn->io_buf;\n\tstruct lpfc_vport      *vport = pIocbIn->vport;\n\tstruct lpfc_rport_data *rdata = lpfc_cmd->rdata;\n\tstruct lpfc_nodelist *pnode = rdata->pnode;\n\tstruct scsi_cmnd *cmd;\n\tunsigned long flags;\n\tstruct lpfc_fast_path_event *fast_path_evt;\n\tstruct Scsi_Host *shost;\n\tint idx;\n\tuint32_t logit = LOG_FCP;\n\n\t \n\tspin_lock(&lpfc_cmd->buf_lock);\n\n\t \n\tcmd = lpfc_cmd->pCmd;\n\tif (!cmd || !phba) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"2621 IO completion: Not an active IO\\n\");\n\t\tspin_unlock(&lpfc_cmd->buf_lock);\n\t\treturn;\n\t}\n\n\tidx = lpfc_cmd->cur_iocbq.hba_wqidx;\n\tif (phba->sli4_hba.hdwq)\n\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.io_cmpls++;\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (unlikely(phba->hdwqstat_on & LPFC_CHECK_SCSI_IO))\n\t\tthis_cpu_inc(phba->sli4_hba.c_stat->cmpl_io);\n#endif\n\tshost = cmd->device->host;\n\n\tlpfc_cmd->result = (pIocbOut->iocb.un.ulpWord[4] & IOERR_PARAM_MASK);\n\tlpfc_cmd->status = pIocbOut->iocb.ulpStatus;\n\t \n\tlpfc_cmd->flags &= ~LPFC_SBUF_XBUSY;\n\tif (pIocbOut->cmd_flag & LPFC_EXCHANGE_BUSY)\n\t\tlpfc_cmd->flags |= LPFC_SBUF_XBUSY;\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_cmd->prot_data_type) {\n\t\tstruct scsi_dif_tuple *src = NULL;\n\n\t\tsrc =  (struct scsi_dif_tuple *)lpfc_cmd->prot_data_segment;\n\t\t \n\t\tswitch (lpfc_cmd->prot_data_type) {\n\t\tcase LPFC_INJERR_REFTAG:\n\t\t\tsrc->ref_tag =\n\t\t\t\tlpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tcase LPFC_INJERR_APPTAG:\n\t\t\tsrc->app_tag =\n\t\t\t\t(uint16_t)lpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tcase LPFC_INJERR_GUARD:\n\t\t\tsrc->guard_tag =\n\t\t\t\t(uint16_t)lpfc_cmd->prot_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tlpfc_cmd->prot_data = 0;\n\t\tlpfc_cmd->prot_data_type = 0;\n\t\tlpfc_cmd->prot_data_segment = NULL;\n\t}\n#endif\n\n\tif (unlikely(lpfc_cmd->status)) {\n\t\tif (lpfc_cmd->status == IOSTAT_LOCAL_REJECT &&\n\t\t    (lpfc_cmd->result & IOERR_DRVR_MASK))\n\t\t\tlpfc_cmd->status = IOSTAT_DRIVER_REJECT;\n\t\telse if (lpfc_cmd->status >= IOSTAT_CNT)\n\t\t\tlpfc_cmd->status = IOSTAT_DEFAULT;\n\t\tif (lpfc_cmd->status == IOSTAT_FCP_RSP_ERROR &&\n\t\t    !lpfc_cmd->fcp_rsp->rspStatus3 &&\n\t\t    (lpfc_cmd->fcp_rsp->rspStatus2 & RESID_UNDER) &&\n\t\t    !(vport->cfg_log_verbose & LOG_FCP_UNDER))\n\t\t\tlogit = 0;\n\t\telse\n\t\t\tlogit = LOG_FCP | LOG_FCP_UNDER;\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, logit,\n\t\t\t \"9030 FCP cmd x%x failed <%d/%lld> \"\n\t\t\t \"status: x%x result: x%x \"\n\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t \"Data: x%x x%x\\n\",\n\t\t\t cmd->cmnd[0],\n\t\t\t cmd->device ? cmd->device->id : 0xffff,\n\t\t\t cmd->device ? cmd->device->lun : 0xffff,\n\t\t\t lpfc_cmd->status, lpfc_cmd->result,\n\t\t\t vport->fc_myDID,\n\t\t\t (pnode) ? pnode->nlp_DID : 0,\n\t\t\t phba->sli_rev == LPFC_SLI_REV4 ?\n\t\t\t     lpfc_cmd->cur_iocbq.sli4_xritag : 0xffff,\n\t\t\t pIocbOut->iocb.ulpContext,\n\t\t\t lpfc_cmd->cur_iocbq.iocb.ulpIoTag);\n\n\t\tswitch (lpfc_cmd->status) {\n\t\tcase IOSTAT_FCP_RSP_ERROR:\n\t\t\t \n\t\t\tlpfc_handle_fcp_err(vport, lpfc_cmd,\n\t\t\t\t\t    pIocbOut->iocb.un.fcpi.fcpi_parm);\n\t\t\tbreak;\n\t\tcase IOSTAT_NPORT_BSY:\n\t\tcase IOSTAT_FABRIC_BSY:\n\t\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\t\tfast_path_evt = lpfc_alloc_fast_evt(phba);\n\t\t\tif (!fast_path_evt)\n\t\t\t\tbreak;\n\t\t\tfast_path_evt->un.fabric_evt.event_type =\n\t\t\t\tFC_REG_FABRIC_EVENT;\n\t\t\tfast_path_evt->un.fabric_evt.subcategory =\n\t\t\t\t(lpfc_cmd->status == IOSTAT_NPORT_BSY) ?\n\t\t\t\tLPFC_EVENT_PORT_BUSY : LPFC_EVENT_FABRIC_BUSY;\n\t\t\tif (pnode) {\n\t\t\t\tmemcpy(&fast_path_evt->un.fabric_evt.wwpn,\n\t\t\t\t\t&pnode->nlp_portname,\n\t\t\t\t\tsizeof(struct lpfc_name));\n\t\t\t\tmemcpy(&fast_path_evt->un.fabric_evt.wwnn,\n\t\t\t\t\t&pnode->nlp_nodename,\n\t\t\t\t\tsizeof(struct lpfc_name));\n\t\t\t}\n\t\t\tfast_path_evt->vport = vport;\n\t\t\tfast_path_evt->work_evt.evt =\n\t\t\t\tLPFC_EVT_FASTPATH_MGMT_EVT;\n\t\t\tspin_lock_irqsave(&phba->hbalock, flags);\n\t\t\tlist_add_tail(&fast_path_evt->work_evt.evt_listp,\n\t\t\t\t&phba->work_list);\n\t\t\tspin_unlock_irqrestore(&phba->hbalock, flags);\n\t\t\tlpfc_worker_wake_up(phba);\n\t\t\tbreak;\n\t\tcase IOSTAT_LOCAL_REJECT:\n\t\tcase IOSTAT_REMOTE_STOP:\n\t\t\tif (lpfc_cmd->result == IOERR_ELXSEC_KEY_UNWRAP_ERROR ||\n\t\t\t    lpfc_cmd->result ==\n\t\t\t\t\tIOERR_ELXSEC_KEY_UNWRAP_COMPARE_ERROR ||\n\t\t\t    lpfc_cmd->result == IOERR_ELXSEC_CRYPTO_ERROR ||\n\t\t\t    lpfc_cmd->result ==\n\t\t\t\t\tIOERR_ELXSEC_CRYPTO_COMPARE_ERROR) {\n\t\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (lpfc_cmd->result == IOERR_INVALID_RPI ||\n\t\t\t    lpfc_cmd->result == IOERR_NO_RESOURCES ||\n\t\t\t    lpfc_cmd->result == IOERR_ABORT_REQUESTED ||\n\t\t\t    lpfc_cmd->result == IOERR_SLER_CMD_RCV_FAILURE) {\n\t\t\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((lpfc_cmd->result == IOERR_RX_DMA_FAILED ||\n\t\t\t     lpfc_cmd->result == IOERR_TX_DMA_FAILED) &&\n\t\t\t     pIocbOut->iocb.unsli3.sli3_bg.bgstat) {\n\t\t\t\tif (scsi_get_prot_op(cmd) != SCSI_PROT_NORMAL) {\n\t\t\t\t\t \n\t\t\t\t\tlpfc_parse_bg_err(phba, lpfc_cmd,\n\t\t\t\t\t\t\tpIocbOut);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tlpfc_printf_vlog(vport, KERN_WARNING,\n\t\t\t\t\t\t\tLOG_BG,\n\t\t\t\t\t\t\t\"9031 non-zero BGSTAT \"\n\t\t\t\t\t\t\t\"on unprotected cmd\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((lpfc_cmd->status == IOSTAT_REMOTE_STOP)\n\t\t\t\t&& (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\t\t&& pnode) {\n\t\t\t\t \n\t\t\t\tlpfc_set_rrq_active(phba, pnode,\n\t\t\t\t\tlpfc_cmd->cur_iocbq.sli4_lxritag,\n\t\t\t\t\t0, 0);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tcmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!pnode || (pnode->nlp_state != NLP_STE_MAPPED_NODE))\n\t\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16 |\n\t\t\t\t      SAM_STAT_BUSY;\n\t} else\n\t\tcmd->result = DID_OK << 16;\n\n\tif (cmd->result || lpfc_cmd->fcp_rsp->rspSnsLen) {\n\t\tuint32_t *lp = (uint32_t *)cmd->sense_buffer;\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t \"0710 Iodone <%d/%llu> cmd x%px, error \"\n\t\t\t\t \"x%x SNS x%x x%x Data: x%x x%x\\n\",\n\t\t\t\t cmd->device->id, cmd->device->lun, cmd,\n\t\t\t\t cmd->result, *lp, *(lp + 3), cmd->retries,\n\t\t\t\t scsi_get_resid(cmd));\n\t}\n\n\tif (vport->cfg_max_scsicmpl_time &&\n\t   time_after(jiffies, lpfc_cmd->start_time +\n\t\tmsecs_to_jiffies(vport->cfg_max_scsicmpl_time))) {\n\t\tspin_lock_irqsave(shost->host_lock, flags);\n\t\tif (pnode) {\n\t\t\tif (pnode->cmd_qdepth >\n\t\t\t\tatomic_read(&pnode->cmd_pending) &&\n\t\t\t\t(atomic_read(&pnode->cmd_pending) >\n\t\t\t\tLPFC_MIN_TGT_QDEPTH) &&\n\t\t\t\t((cmd->cmnd[0] == READ_10) ||\n\t\t\t\t(cmd->cmnd[0] == WRITE_10)))\n\t\t\t\tpnode->cmd_qdepth =\n\t\t\t\t\tatomic_read(&pnode->cmd_pending);\n\n\t\t\tpnode->last_change_time = jiffies;\n\t\t}\n\t\tspin_unlock_irqrestore(shost->host_lock, flags);\n\t}\n\tlpfc_scsi_unprep_dma_buf(phba, lpfc_cmd);\n\n\tlpfc_cmd->pCmd = NULL;\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (lpfc_cmd->ts_cmd_start) {\n\t\tlpfc_cmd->ts_isr_cmpl = pIocbIn->isr_timestamp;\n\t\tlpfc_cmd->ts_data_io = ktime_get_ns();\n\t\tphba->ktime_last_cmd = lpfc_cmd->ts_data_io;\n\t\tlpfc_io_ktime(phba, lpfc_cmd);\n\t}\n#endif\n\n\t \n\tscsi_done(cmd);\n\n\t \n\tspin_lock(&lpfc_cmd->buf_lock);\n\tlpfc_cmd->cur_iocbq.cmd_flag &= ~LPFC_DRIVER_ABORTED;\n\tif (lpfc_cmd->waitq)\n\t\twake_up(lpfc_cmd->waitq);\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\n\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n}\n\n \nstatic int lpfc_scsi_prep_cmnd_buf_s3(struct lpfc_vport *vport,\n\t\t\t\t      struct lpfc_io_buf *lpfc_cmd,\n\t\t\t\t      uint8_t tmo)\n{\n\tIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\n\tstruct lpfc_iocbq *piocbq = &lpfc_cmd->cur_iocbq;\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct lpfc_nodelist *pnode = lpfc_cmd->ndlp;\n\tint datadir = scsi_cmnd->sc_data_direction;\n\tu32 fcpdl;\n\n\tpiocbq->iocb.un.fcpi.fcpi_XRdy = 0;\n\n\t \n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\tif (datadir == DMA_TO_DEVICE) {\n\t\t\tiocb_cmd->ulpCommand = CMD_FCP_IWRITE64_CR;\n\t\t\tiocb_cmd->ulpPU = PARM_READ_CHECK;\n\t\t\tif (vport->cfg_first_burst_size &&\n\t\t\t    (pnode->nlp_flag & NLP_FIRSTBURST)) {\n\t\t\t\tu32 xrdy_len;\n\n\t\t\t\tfcpdl = scsi_bufflen(scsi_cmnd);\n\t\t\t\txrdy_len = min(fcpdl,\n\t\t\t\t\t       vport->cfg_first_burst_size);\n\t\t\t\tpiocbq->iocb.un.fcpi.fcpi_XRdy = xrdy_len;\n\t\t\t}\n\t\t\tfcp_cmnd->fcpCntl3 = WRITE_DATA;\n\t\t} else {\n\t\t\tiocb_cmd->ulpCommand = CMD_FCP_IREAD64_CR;\n\t\t\tiocb_cmd->ulpPU = PARM_READ_CHECK;\n\t\t\tfcp_cmnd->fcpCntl3 = READ_DATA;\n\t\t}\n\t} else {\n\t\tiocb_cmd->ulpCommand = CMD_FCP_ICMND64_CR;\n\t\tiocb_cmd->un.fcpi.fcpi_parm = 0;\n\t\tiocb_cmd->ulpPU = 0;\n\t\tfcp_cmnd->fcpCntl3 = 0;\n\t}\n\n\t \n\tpiocbq->iocb.ulpContext = pnode->nlp_rpi;\n\tif (pnode->nlp_fcp_info & NLP_FCP_2_DEVICE)\n\t\tpiocbq->iocb.ulpFCP2Rcvy = 1;\n\telse\n\t\tpiocbq->iocb.ulpFCP2Rcvy = 0;\n\n\tpiocbq->iocb.ulpClass = (pnode->nlp_fcp_info & 0x0f);\n\tpiocbq->io_buf  = lpfc_cmd;\n\tif (!piocbq->cmd_cmpl)\n\t\tpiocbq->cmd_cmpl = lpfc_scsi_cmd_iocb_cmpl;\n\tpiocbq->iocb.ulpTimeout = tmo;\n\tpiocbq->vport = vport;\n\treturn 0;\n}\n\n \nstatic int lpfc_scsi_prep_cmnd_buf_s4(struct lpfc_vport *vport,\n\t\t\t\t      struct lpfc_io_buf *lpfc_cmd,\n\t\t\t\t      uint8_t tmo)\n{\n\tstruct lpfc_hba *phba = vport->phba;\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tstruct lpfc_sli4_hdw_queue *hdwq = NULL;\n\tstruct lpfc_iocbq *pwqeq = &lpfc_cmd->cur_iocbq;\n\tstruct lpfc_nodelist *pnode = lpfc_cmd->ndlp;\n\tunion lpfc_wqe128 *wqe = &pwqeq->wqe;\n\tu16 idx = lpfc_cmd->hdwq_no;\n\tint datadir = scsi_cmnd->sc_data_direction;\n\n\thdwq = &phba->sli4_hba.hdwq[idx];\n\n\t \n\tmemset(wqe, 0, sizeof(union lpfc_wqe128));\n\n\t \n\tif (scsi_sg_count(scsi_cmnd)) {\n\t\tif (datadir == DMA_TO_DEVICE) {\n\t\t\t \n\t\t\tmemcpy(&wqe->words[7],\n\t\t\t       &lpfc_iwrite_cmd_template.words[7],\n\t\t\t       sizeof(uint32_t) * 5);\n\n\t\t\tfcp_cmnd->fcpCntl3 = WRITE_DATA;\n\t\t\tif (hdwq)\n\t\t\t\thdwq->scsi_cstat.output_requests++;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(&wqe->words[7],\n\t\t\t       &lpfc_iread_cmd_template.words[7],\n\t\t\t       sizeof(uint32_t) * 5);\n\n\t\t\t \n\t\t\tbf_set(wqe_tmo, &wqe->fcp_iread.wqe_com, tmo);\n\n\t\t\tfcp_cmnd->fcpCntl3 = READ_DATA;\n\t\t\tif (hdwq)\n\t\t\t\thdwq->scsi_cstat.input_requests++;\n\n\t\t\t \n\t\t\tif (phba->cmf_active_mode == LPFC_CFG_MANAGED)\n\t\t\t\tbf_set(wqe_iod, &wqe->fcp_iread.wqe_com,\n\t\t\t\t       LPFC_WQE_IOD_NONE);\n\t\t}\n\t} else {\n\t\t \n\t\tmemcpy(&wqe->words[4], &lpfc_icmnd_cmd_template.words[4],\n\t\t       sizeof(uint32_t) * 8);\n\n\t\t \n\t\tbf_set(wqe_tmo, &wqe->fcp_icmd.wqe_com, tmo);\n\n\t\tfcp_cmnd->fcpCntl3 = 0;\n\t\tif (hdwq)\n\t\t\thdwq->scsi_cstat.control_requests++;\n\t}\n\n\t \n\n\t  \n\tbf_set(payload_offset_len, &wqe->fcp_icmd,\n\t       sizeof(struct fcp_cmnd) + sizeof(struct fcp_rsp));\n\n\t \n\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,\n\t       phba->sli4_hba.rpi_ids[pnode->nlp_rpi]);\n\tbf_set(wqe_xri_tag, &wqe->generic.wqe_com, pwqeq->sli4_xritag);\n\n\t \n\tif (pnode->nlp_fcp_info & NLP_FCP_2_DEVICE)\n\t\tbf_set(wqe_erp, &wqe->generic.wqe_com, 1);\n\n\tbf_set(wqe_class, &wqe->generic.wqe_com,\n\t       (pnode->nlp_fcp_info & 0x0f));\n\n\t  \n\twqe->generic.wqe_com.abort_tag = pwqeq->iotag;\n\n\t \n\tbf_set(wqe_reqtag, &wqe->generic.wqe_com, pwqeq->iotag);\n\n\tpwqeq->vport = vport;\n\tpwqeq->io_buf = lpfc_cmd;\n\tpwqeq->hba_wqidx = lpfc_cmd->hdwq_no;\n\tpwqeq->cmd_cmpl = lpfc_fcp_io_cmd_wqe_cmpl;\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_scsi_prep_cmnd(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd,\n\t\t    struct lpfc_nodelist *pnode)\n{\n\tstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\n\tstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\n\tu8 *ptr;\n\n\tif (!pnode)\n\t\treturn 0;\n\n\tlpfc_cmd->fcp_rsp->rspSnsLen = 0;\n\t \n\tlpfc_cmd->fcp_cmnd->fcpCntl2 = 0;\n\n\tint_to_scsilun(lpfc_cmd->pCmd->device->lun,\n\t\t       &lpfc_cmd->fcp_cmnd->fcp_lun);\n\n\tptr = &fcp_cmnd->fcpCdb[0];\n\tmemcpy(ptr, scsi_cmnd->cmnd, scsi_cmnd->cmd_len);\n\tif (scsi_cmnd->cmd_len < LPFC_FCP_CDB_LEN) {\n\t\tptr += scsi_cmnd->cmd_len;\n\t\tmemset(ptr, 0, (LPFC_FCP_CDB_LEN - scsi_cmnd->cmd_len));\n\t}\n\n\tfcp_cmnd->fcpCntl1 = SIMPLE_Q;\n\n\tlpfc_scsi_prep_cmnd_buf(vport, lpfc_cmd, lpfc_cmd->timeout);\n\n\treturn 0;\n}\n\n \nstatic int\nlpfc_scsi_prep_task_mgmt_cmd_s3(struct lpfc_vport *vport,\n\t\t\t\tstruct lpfc_io_buf *lpfc_cmd,\n\t\t\t\tu64 lun, u8 task_mgmt_cmd)\n{\n\tstruct lpfc_iocbq *piocbq;\n\tIOCB_t *piocb;\n\tstruct fcp_cmnd *fcp_cmnd;\n\tstruct lpfc_rport_data *rdata = lpfc_cmd->rdata;\n\tstruct lpfc_nodelist *ndlp = rdata->pnode;\n\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_MAPPED_NODE)\n\t\treturn 0;\n\n\tpiocbq = &(lpfc_cmd->cur_iocbq);\n\tpiocbq->vport = vport;\n\n\tpiocb = &piocbq->iocb;\n\n\tfcp_cmnd = lpfc_cmd->fcp_cmnd;\n\t \n\tmemset(fcp_cmnd, 0, sizeof(struct fcp_cmnd));\n\tint_to_scsilun(lun, &fcp_cmnd->fcp_lun);\n\tfcp_cmnd->fcpCntl2 = task_mgmt_cmd;\n\tif (!(vport->phba->sli3_options & LPFC_SLI3_BG_ENABLED))\n\t\tlpfc_fcpcmd_to_iocb(piocb->unsli3.fcp_ext.icd, fcp_cmnd);\n\tpiocb->ulpCommand = CMD_FCP_ICMND64_CR;\n\tpiocb->ulpContext = ndlp->nlp_rpi;\n\tpiocb->ulpFCP2Rcvy = (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) ? 1 : 0;\n\tpiocb->ulpClass = (ndlp->nlp_fcp_info & 0x0f);\n\tpiocb->ulpPU = 0;\n\tpiocb->un.fcpi.fcpi_parm = 0;\n\n\t \n\tif (lpfc_cmd->timeout > 0xff) {\n\t\t \n\t\tpiocb->ulpTimeout = 0;\n\t} else\n\t\tpiocb->ulpTimeout = lpfc_cmd->timeout;\n\n\treturn 1;\n}\n\n \nstatic int\nlpfc_scsi_prep_task_mgmt_cmd_s4(struct lpfc_vport *vport,\n\t\t\t\tstruct lpfc_io_buf *lpfc_cmd,\n\t\t\t\tu64 lun, u8 task_mgmt_cmd)\n{\n\tstruct lpfc_iocbq *pwqeq = &lpfc_cmd->cur_iocbq;\n\tunion lpfc_wqe128 *wqe = &pwqeq->wqe;\n\tstruct fcp_cmnd *fcp_cmnd;\n\tstruct lpfc_rport_data *rdata = lpfc_cmd->rdata;\n\tstruct lpfc_nodelist *ndlp = rdata->pnode;\n\n\tif (!ndlp || ndlp->nlp_state != NLP_STE_MAPPED_NODE)\n\t\treturn 0;\n\n\tpwqeq->vport = vport;\n\t \n\tmemset(wqe, 0, sizeof(union lpfc_wqe128));\n\n\t \n\tmemcpy(&wqe->words[4], &lpfc_icmnd_cmd_template.words[4],\n\t       sizeof(uint32_t) * 8);\n\n\tfcp_cmnd = lpfc_cmd->fcp_cmnd;\n\t \n\tmemset(fcp_cmnd, 0, sizeof(struct fcp_cmnd));\n\tint_to_scsilun(lun, &fcp_cmnd->fcp_lun);\n\tfcp_cmnd->fcpCntl3 = 0;\n\tfcp_cmnd->fcpCntl2 = task_mgmt_cmd;\n\n\tbf_set(payload_offset_len, &wqe->fcp_icmd,\n\t       sizeof(struct fcp_cmnd) + sizeof(struct fcp_rsp));\n\tbf_set(cmd_buff_len, &wqe->fcp_icmd, 0);\n\tbf_set(wqe_ctxt_tag, &wqe->generic.wqe_com,   \n\t       vport->phba->sli4_hba.rpi_ids[ndlp->nlp_rpi]);\n\tbf_set(wqe_erp, &wqe->fcp_icmd.wqe_com,\n\t       ((ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) ? 1 : 0));\n\tbf_set(wqe_class, &wqe->fcp_icmd.wqe_com,\n\t       (ndlp->nlp_fcp_info & 0x0f));\n\n\t \n\tif (lpfc_cmd->timeout > 0xff) {\n\t\t \n\t\tbf_set(wqe_tmo, &wqe->fcp_icmd.wqe_com, 0);\n\t} else {\n\t\tbf_set(wqe_tmo, &wqe->fcp_icmd.wqe_com, lpfc_cmd->timeout);\n\t}\n\n\tlpfc_prep_embed_io(vport->phba, lpfc_cmd);\n\tbf_set(wqe_xri_tag, &wqe->generic.wqe_com, pwqeq->sli4_xritag);\n\twqe->generic.wqe_com.abort_tag = pwqeq->iotag;\n\tbf_set(wqe_reqtag, &wqe->generic.wqe_com, pwqeq->iotag);\n\n\tlpfc_sli4_set_rsp_sgl_last(vport->phba, lpfc_cmd);\n\n\treturn 1;\n}\n\n \nint\nlpfc_scsi_api_table_setup(struct lpfc_hba *phba, uint8_t dev_grp)\n{\n\n\tphba->lpfc_scsi_unprep_dma_buf = lpfc_scsi_unprep_dma_buf;\n\n\tswitch (dev_grp) {\n\tcase LPFC_PCI_DEV_LP:\n\t\tphba->lpfc_scsi_prep_dma_buf = lpfc_scsi_prep_dma_buf_s3;\n\t\tphba->lpfc_bg_scsi_prep_dma_buf = lpfc_bg_scsi_prep_dma_buf_s3;\n\t\tphba->lpfc_release_scsi_buf = lpfc_release_scsi_buf_s3;\n\t\tphba->lpfc_get_scsi_buf = lpfc_get_scsi_buf_s3;\n\t\tphba->lpfc_scsi_prep_cmnd_buf = lpfc_scsi_prep_cmnd_buf_s3;\n\t\tphba->lpfc_scsi_prep_task_mgmt_cmd =\n\t\t\t\t\tlpfc_scsi_prep_task_mgmt_cmd_s3;\n\t\tbreak;\n\tcase LPFC_PCI_DEV_OC:\n\t\tphba->lpfc_scsi_prep_dma_buf = lpfc_scsi_prep_dma_buf_s4;\n\t\tphba->lpfc_bg_scsi_prep_dma_buf = lpfc_bg_scsi_prep_dma_buf_s4;\n\t\tphba->lpfc_release_scsi_buf = lpfc_release_scsi_buf_s4;\n\t\tphba->lpfc_get_scsi_buf = lpfc_get_scsi_buf_s4;\n\t\tphba->lpfc_scsi_prep_cmnd_buf = lpfc_scsi_prep_cmnd_buf_s4;\n\t\tphba->lpfc_scsi_prep_task_mgmt_cmd =\n\t\t\t\t\tlpfc_scsi_prep_task_mgmt_cmd_s4;\n\t\tbreak;\n\tdefault:\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\n\t\t\t\t\"1418 Invalid HBA PCI-device group: 0x%x\\n\",\n\t\t\t\tdev_grp);\n\t\treturn -ENODEV;\n\t}\n\tphba->lpfc_rampdown_queue_depth = lpfc_rampdown_queue_depth;\n\treturn 0;\n}\n\n \nstatic void\nlpfc_tskmgmt_def_cmpl(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_iocbq *cmdiocbq,\n\t\t\tstruct lpfc_iocbq *rspiocbq)\n{\n\tstruct lpfc_io_buf *lpfc_cmd = cmdiocbq->io_buf;\n\tif (lpfc_cmd)\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\treturn;\n}\n\n \nint\nlpfc_check_pci_resettable(struct lpfc_hba *phba)\n{\n\tconst struct pci_dev *pdev = phba->pcidev;\n\tstruct pci_dev *ptr = NULL;\n\tu8 counter = 0;\n\n\t \n\tlist_for_each_entry(ptr, &pdev->bus->devices, bus_list) {\n\t\t \n\t\tif (ptr->vendor != PCI_VENDOR_ID_EMULEX) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8346 Non-Emulex vendor found: \"\n\t\t\t\t\t\"0x%04x\\n\", ptr->vendor);\n\t\t\treturn -EBADSLT;\n\t\t}\n\n\t\t \n\t\tif (phba->sli_rev != LPFC_SLI_REV4 ||\n\t\t    phba->hba_flag & HBA_FCOE_MODE) {\n\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\"8347 Incapable PCI reset device: \"\n\t\t\t\t\t\"0x%04x\\n\", ptr->device);\n\t\t\treturn -EBADSLT;\n\t\t}\n\n\t\t \n\t\tif (ptr->devfn == 0) {\n\t\t\tif (++counter > 1) {\n\t\t\t\tlpfc_printf_log(phba, KERN_INFO, LOG_INIT,\n\t\t\t\t\t\t\"8348 More than one device on \"\n\t\t\t\t\t\t\"secondary bus found\\n\");\n\t\t\t\treturn -EBADSLT;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nconst char *\nlpfc_info(struct Scsi_Host *host)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) host->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tint link_speed = 0;\n\tstatic char lpfcinfobuf[384];\n\tchar tmp[384] = {0};\n\n\tmemset(lpfcinfobuf, 0, sizeof(lpfcinfobuf));\n\tif (phba && phba->pcidev){\n\t\t \n\t\tscnprintf(tmp, sizeof(tmp), phba->ModelDesc);\n\t\tif (strlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf)) >=\n\t\t    sizeof(lpfcinfobuf))\n\t\t\tgoto buffer_done;\n\n\t\t \n\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t  \" on PCI bus %02x device %02x irq %d\",\n\t\t\t  phba->pcidev->bus->number, phba->pcidev->devfn,\n\t\t\t  phba->pcidev->irq);\n\t\tif (strlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf)) >=\n\t\t    sizeof(lpfcinfobuf))\n\t\t\tgoto buffer_done;\n\n\t\t \n\t\tif (phba->Port[0]) {\n\t\t\tscnprintf(tmp, sizeof(tmp), \" port %s\", phba->Port);\n\t\t\tif (strlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf)) >=\n\t\t\t    sizeof(lpfcinfobuf))\n\t\t\t\tgoto buffer_done;\n\t\t}\n\n\t\t \n\t\tlink_speed = lpfc_sli_port_speed_get(phba);\n\t\tif (link_speed != 0) {\n\t\t\tscnprintf(tmp, sizeof(tmp),\n\t\t\t\t  \" Logical Link Speed: %d Mbps\", link_speed);\n\t\t\tif (strlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf)) >=\n\t\t\t    sizeof(lpfcinfobuf))\n\t\t\t\tgoto buffer_done;\n\t\t}\n\n\t\t \n\t\tif (!lpfc_check_pci_resettable(phba)) {\n\t\t\tscnprintf(tmp, sizeof(tmp), \" PCI resettable\");\n\t\t\tstrlcat(lpfcinfobuf, tmp, sizeof(lpfcinfobuf));\n\t\t}\n\t}\n\nbuffer_done:\n\treturn lpfcinfobuf;\n}\n\n \nstatic __inline__ void lpfc_poll_rearm_timer(struct lpfc_hba * phba)\n{\n\tunsigned long  poll_tmo_expires =\n\t\t(jiffies + msecs_to_jiffies(phba->cfg_poll_tmo));\n\n\tif (!list_empty(&phba->sli.sli3_ring[LPFC_FCP_RING].txcmplq))\n\t\tmod_timer(&phba->fcp_poll_timer,\n\t\t\t  poll_tmo_expires);\n}\n\n \nvoid lpfc_poll_start_timer(struct lpfc_hba * phba)\n{\n\tlpfc_poll_rearm_timer(phba);\n}\n\n \nvoid lpfc_poll_timeout(struct timer_list *t)\n{\n\tstruct lpfc_hba *phba = from_timer(phba, t, fcp_poll_timer);\n\n\tif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\n\t\tlpfc_sli_handle_fast_ring_event(phba,\n\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\n\n\t\tif (phba->cfg_poll & DISABLE_FCP_RING_INT)\n\t\t\tlpfc_poll_rearm_timer(phba);\n\t}\n}\n\n \nstatic char *lpfc_is_command_vm_io(struct scsi_cmnd *cmd)\n{\n\tstruct bio *bio = scsi_cmd_to_rq(cmd)->bio;\n\n\tif (!IS_ENABLED(CONFIG_BLK_CGROUP_FC_APPID) || !bio)\n\t\treturn NULL;\n\treturn blkcg_get_fc_appid(bio);\n}\n\n \nstatic int\nlpfc_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *cmnd)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_iocbq *cur_iocbq = NULL;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *ndlp;\n\tstruct lpfc_io_buf *lpfc_cmd;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\tint err, idx;\n\tu8 *uuid = NULL;\n\tuint64_t start;\n\n\tstart = ktime_get_ns();\n\trdata = lpfc_rport_data_from_scsi_device(cmnd->device);\n\n\t \n\tif (unlikely(!rdata) || unlikely(!rport))\n\t\tgoto out_fail_command;\n\n\terr = fc_remote_port_chkready(rport);\n\tif (err) {\n\t\tcmnd->result = err;\n\t\tgoto out_fail_command;\n\t}\n\tndlp = rdata->pnode;\n\n\tif ((scsi_get_prot_op(cmnd) != SCSI_PROT_NORMAL) &&\n\t\t(!(phba->sli3_options & LPFC_SLI3_BG_ENABLED))) {\n\n\t\tlpfc_printf_log(phba, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\"9058 BLKGRD: ERROR: rcvd protected cmd:%02x\"\n\t\t\t\t\" op:%02x str=%s without registering for\"\n\t\t\t\t\" BlockGuard - Rejecting command\\n\",\n\t\t\t\tcmnd->cmnd[0], scsi_get_prot_op(cmnd),\n\t\t\t\tdif_op_str[scsi_get_prot_op(cmnd)]);\n\t\tgoto out_fail_command;\n\t}\n\n\t \n\tif (!ndlp)\n\t\tgoto out_tgt_busy1;\n\n\t \n\tif (phba->cmf_active_mode != LPFC_CFG_OFF &&\n\t    cmnd->sc_data_direction == DMA_FROM_DEVICE &&\n\t    (scsi_sg_count(cmnd))) {\n\t\t \n\t\terr = lpfc_update_cmf_cmd(phba, scsi_bufflen(cmnd));\n\t\tif (err)\n\t\t\tgoto out_tgt_busy1;\n\t}\n\n\tif (lpfc_ndlp_check_qdepth(phba, ndlp)) {\n\t\tif (atomic_read(&ndlp->cmd_pending) >= ndlp->cmd_qdepth) {\n\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP_ERROR,\n\t\t\t\t\t \"3377 Target Queue Full, scsi Id:%d \"\n\t\t\t\t\t \"Qdepth:%d Pending command:%d\"\n\t\t\t\t\t \" WWNN:%02x:%02x:%02x:%02x:\"\n\t\t\t\t\t \"%02x:%02x:%02x:%02x, \"\n\t\t\t\t\t \" WWPN:%02x:%02x:%02x:%02x:\"\n\t\t\t\t\t \"%02x:%02x:%02x:%02x\",\n\t\t\t\t\t ndlp->nlp_sid, ndlp->cmd_qdepth,\n\t\t\t\t\t atomic_read(&ndlp->cmd_pending),\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[0],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[1],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[2],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[3],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[4],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[5],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[6],\n\t\t\t\t\t ndlp->nlp_nodename.u.wwn[7],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[0],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[1],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[2],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[3],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[4],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[5],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[6],\n\t\t\t\t\t ndlp->nlp_portname.u.wwn[7]);\n\t\t\tgoto out_tgt_busy2;\n\t\t}\n\t}\n\n\tlpfc_cmd = lpfc_get_scsi_buf(phba, ndlp, cmnd);\n\tif (lpfc_cmd == NULL) {\n\t\tlpfc_rampdown_queue_depth(phba);\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP_ERROR,\n\t\t\t\t \"0707 driver's buffer pool is empty, \"\n\t\t\t\t \"IO busied\\n\");\n\t\tgoto out_host_busy;\n\t}\n\tlpfc_cmd->rx_cmd_start = start;\n\n\tcur_iocbq = &lpfc_cmd->cur_iocbq;\n\t \n\tlpfc_cmd->pCmd  = cmnd;\n\tlpfc_cmd->rdata = rdata;\n\tlpfc_cmd->ndlp = ndlp;\n\tcur_iocbq->cmd_cmpl = NULL;\n\tcmnd->host_scribble = (unsigned char *)lpfc_cmd;\n\n\terr = lpfc_scsi_prep_cmnd(vport, lpfc_cmd, ndlp);\n\tif (err)\n\t\tgoto out_host_busy_release_buf;\n\n\tif (scsi_get_prot_op(cmnd) != SCSI_PROT_NORMAL) {\n\t\tif (vport->phba->cfg_enable_bg) {\n\t\t\tlpfc_printf_vlog(vport,\n\t\t\t\t\t KERN_INFO, LOG_SCSI_CMD,\n\t\t\t\t\t \"9033 BLKGRD: rcvd %s cmd:x%x \"\n\t\t\t\t\t \"reftag x%x cnt %u pt %x\\n\",\n\t\t\t\t\t dif_op_str[scsi_get_prot_op(cmnd)],\n\t\t\t\t\t cmnd->cmnd[0],\n\t\t\t\t\t scsi_prot_ref_tag(cmnd),\n\t\t\t\t\t scsi_logical_block_count(cmnd),\n\t\t\t\t\t (cmnd->cmnd[1]>>5));\n\t\t}\n\t\terr = lpfc_bg_scsi_prep_dma_buf(phba, lpfc_cmd);\n\t} else {\n\t\tif (vport->phba->cfg_enable_bg) {\n\t\t\tlpfc_printf_vlog(vport,\n\t\t\t\t\t KERN_INFO, LOG_SCSI_CMD,\n\t\t\t\t\t \"9038 BLKGRD: rcvd PROT_NORMAL cmd: \"\n\t\t\t\t\t \"x%x reftag x%x cnt %u pt %x\\n\",\n\t\t\t\t\t cmnd->cmnd[0],\n\t\t\t\t\t scsi_prot_ref_tag(cmnd),\n\t\t\t\t\t scsi_logical_block_count(cmnd),\n\t\t\t\t\t (cmnd->cmnd[1]>>5));\n\t\t}\n\t\terr = lpfc_scsi_prep_dma_buf(phba, lpfc_cmd);\n\t}\n\n\tif (unlikely(err)) {\n\t\tif (err == 2) {\n\t\t\tcmnd->result = DID_ERROR << 16;\n\t\t\tgoto out_fail_command_release_buf;\n\t\t}\n\t\tgoto out_host_busy_free_buf;\n\t}\n\n\t \n\tif (lpfc_is_vmid_enabled(phba) &&\n\t    (ndlp->vmid_support ||\n\t     phba->pport->vmid_priority_tagging ==\n\t     LPFC_VMID_PRIO_TAG_ALL_TARGETS)) {\n\t\t \n\t\t \n\t\tuuid = lpfc_is_command_vm_io(cmnd);\n\n\t\tif (uuid) {\n\t\t\terr = lpfc_vmid_get_appid(vport, uuid,\n\t\t\t\t\tcmnd->sc_data_direction,\n\t\t\t\t\t(union lpfc_vmid_io_tag *)\n\t\t\t\t\t\t&cur_iocbq->vmid_tag);\n\t\t\tif (!err)\n\t\t\t\tcur_iocbq->cmd_flag |= LPFC_IO_VMID;\n\t\t}\n\t}\n\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (unlikely(phba->hdwqstat_on & LPFC_CHECK_SCSI_IO))\n\t\tthis_cpu_inc(phba->sli4_hba.c_stat->xmt_io);\n#endif\n\t \n\terr = lpfc_sli_issue_fcp_io(phba, LPFC_FCP_RING, cur_iocbq,\n\t\t\t\t    SLI_IOCB_RET_IOCB);\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\n\tif (start) {\n\t\tlpfc_cmd->ts_cmd_start = start;\n\t\tlpfc_cmd->ts_last_cmd = phba->ktime_last_cmd;\n\t\tlpfc_cmd->ts_cmd_wqput = ktime_get_ns();\n\t} else {\n\t\tlpfc_cmd->ts_cmd_start = 0;\n\t}\n#endif\n\tif (err) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t \"3376 FCP could not issue iocb err %x \"\n\t\t\t\t \"FCP cmd x%x <%d/%llu> \"\n\t\t\t\t \"sid: x%x did: x%x oxid: x%x \"\n\t\t\t\t \"Data: x%x x%x x%x x%x\\n\",\n\t\t\t\t err, cmnd->cmnd[0],\n\t\t\t\t cmnd->device ? cmnd->device->id : 0xffff,\n\t\t\t\t cmnd->device ? cmnd->device->lun : (u64)-1,\n\t\t\t\t vport->fc_myDID, ndlp->nlp_DID,\n\t\t\t\t phba->sli_rev == LPFC_SLI_REV4 ?\n\t\t\t\t cur_iocbq->sli4_xritag : 0xffff,\n\t\t\t\t phba->sli_rev == LPFC_SLI_REV4 ?\n\t\t\t\t phba->sli4_hba.rpi_ids[ndlp->nlp_rpi] :\n\t\t\t\t cur_iocbq->iocb.ulpContext,\n\t\t\t\t cur_iocbq->iotag,\n\t\t\t\t phba->sli_rev == LPFC_SLI_REV4 ?\n\t\t\t\t bf_get(wqe_tmo,\n\t\t\t\t\t&cur_iocbq->wqe.generic.wqe_com) :\n\t\t\t\t cur_iocbq->iocb.ulpTimeout,\n\t\t\t\t (uint32_t)(scsi_cmd_to_rq(cmnd)->timeout / 1000));\n\n\t\tgoto out_host_busy_free_buf;\n\t}\n\n\tif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\n\t\tlpfc_sli_handle_fast_ring_event(phba,\n\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\n\n\t\tif (phba->cfg_poll & DISABLE_FCP_RING_INT)\n\t\t\tlpfc_poll_rearm_timer(phba);\n\t}\n\n\tif (phba->cfg_xri_rebalancing)\n\t\tlpfc_keep_pvt_pool_above_lowwm(phba, lpfc_cmd->hdwq_no);\n\n\treturn 0;\n\n out_host_busy_free_buf:\n\tidx = lpfc_cmd->hdwq_no;\n\tlpfc_scsi_unprep_dma_buf(phba, lpfc_cmd);\n\tif (phba->sli4_hba.hdwq) {\n\t\tswitch (lpfc_cmd->fcp_cmnd->fcpCntl3) {\n\t\tcase WRITE_DATA:\n\t\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.output_requests--;\n\t\t\tbreak;\n\t\tcase READ_DATA:\n\t\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.input_requests--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphba->sli4_hba.hdwq[idx].scsi_cstat.control_requests--;\n\t\t}\n\t}\n out_host_busy_release_buf:\n\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n out_host_busy:\n\tlpfc_update_cmf_cmpl(phba, LPFC_CGN_NOT_SENT, scsi_bufflen(cmnd),\n\t\t\t     shost);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n out_tgt_busy2:\n\tlpfc_update_cmf_cmpl(phba, LPFC_CGN_NOT_SENT, scsi_bufflen(cmnd),\n\t\t\t     shost);\n out_tgt_busy1:\n\treturn SCSI_MLQUEUE_TARGET_BUSY;\n\n out_fail_command_release_buf:\n\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\tlpfc_update_cmf_cmpl(phba, LPFC_CGN_NOT_SENT, scsi_bufflen(cmnd),\n\t\t\t     shost);\n\n out_fail_command:\n\tscsi_done(cmnd);\n\treturn 0;\n}\n\n \nvoid lpfc_vmid_vport_cleanup(struct lpfc_vport *vport)\n{\n\tu32 bucket;\n\tstruct lpfc_vmid *cur;\n\n\tif (vport->port_type == LPFC_PHYSICAL_PORT)\n\t\tdel_timer_sync(&vport->phba->inactive_vmid_poll);\n\n\tkfree(vport->qfpa_res);\n\tkfree(vport->vmid_priority.vmid_range);\n\tkfree(vport->vmid);\n\n\tif (!hash_empty(vport->hash_table))\n\t\thash_for_each(vport->hash_table, bucket, cur, hnode)\n\t\t\thash_del(&cur->hnode);\n\n\tvport->qfpa_res = NULL;\n\tvport->vmid_priority.vmid_range = NULL;\n\tvport->vmid = NULL;\n\tvport->cur_vmid_cnt = 0;\n}\n\n \nstatic int\nlpfc_abort_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host  *shost = cmnd->device->host;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_iocbq *iocb;\n\tstruct lpfc_io_buf *lpfc_cmd;\n\tint ret = SUCCESS, status = 0;\n\tstruct lpfc_sli_ring *pring_s4 = NULL;\n\tstruct lpfc_sli_ring *pring = NULL;\n\tint ret_val;\n\tunsigned long flags;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waitq);\n\n\tstatus = fc_block_rport(rport);\n\tif (status != 0 && status != SUCCESS)\n\t\treturn status;\n\n\tlpfc_cmd = (struct lpfc_io_buf *)cmnd->host_scribble;\n\tif (!lpfc_cmd)\n\t\treturn ret;\n\n\t \n\tspin_lock_irqsave(&lpfc_cmd->buf_lock, flags);\n\n\tspin_lock(&phba->hbalock);\n\t \n\tif (phba->hba_flag & HBA_IOQ_FLUSH) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\"3168 SCSI Layer abort requested I/O has been \"\n\t\t\t\"flushed by LLD.\\n\");\n\t\tret = FAILED;\n\t\tgoto out_unlock_hba;\n\t}\n\n\tif (!lpfc_cmd->pCmd) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t \"2873 SCSI Layer I/O Abort Request IO CMPL Status \"\n\t\t\t \"x%x ID %d LUN %llu\\n\",\n\t\t\t SUCCESS, cmnd->device->id, cmnd->device->lun);\n\t\tgoto out_unlock_hba;\n\t}\n\n\tiocb = &lpfc_cmd->cur_iocbq;\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tpring_s4 = phba->sli4_hba.hdwq[iocb->hba_wqidx].io_wq->pring;\n\t\tif (!pring_s4) {\n\t\t\tret = FAILED;\n\t\t\tgoto out_unlock_hba;\n\t\t}\n\t\tspin_lock(&pring_s4->ring_lock);\n\t}\n\t \n\tif (!(iocb->cmd_flag & LPFC_IO_ON_TXCMPLQ)) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\"3169 SCSI Layer abort requested I/O has been \"\n\t\t\t\"cancelled by LLD.\\n\");\n\t\tret = FAILED;\n\t\tgoto out_unlock_ring;\n\t}\n\t \n\tif (lpfc_cmd->pCmd != cmnd) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\"3170 SCSI Layer abort requested I/O has been \"\n\t\t\t\"completed by LLD.\\n\");\n\t\tgoto out_unlock_ring;\n\t}\n\n\tWARN_ON(iocb->io_buf != lpfc_cmd);\n\n\t \n\tif (iocb->cmd_flag & LPFC_DRIVER_ABORTED) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t \"3389 SCSI Layer I/O Abort Request is pending\\n\");\n\t\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\t\tspin_unlock(&pring_s4->ring_lock);\n\t\tspin_unlock(&phba->hbalock);\n\t\tspin_unlock_irqrestore(&lpfc_cmd->buf_lock, flags);\n\t\tgoto wait_for_cmpl;\n\t}\n\n\tlpfc_cmd->waitq = &waitq;\n\tif (phba->sli_rev == LPFC_SLI_REV4) {\n\t\tspin_unlock(&pring_s4->ring_lock);\n\t\tret_val = lpfc_sli4_issue_abort_iotag(phba, iocb,\n\t\t\t\t\t\t      lpfc_sli_abort_fcp_cmpl);\n\t} else {\n\t\tpring = &phba->sli.sli3_ring[LPFC_FCP_RING];\n\t\tret_val = lpfc_sli_issue_abort_iotag(phba, pring, iocb,\n\t\t\t\t\t\t     lpfc_sli_abort_fcp_cmpl);\n\t}\n\n\t \n\tlpfc_issue_hb_tmo(phba);\n\n\tif (ret_val != IOCB_SUCCESS) {\n\t\t \n\t\tlpfc_cmd->waitq = NULL;\n\t\tret = FAILED;\n\t\tgoto out_unlock_hba;\n\t}\n\n\t \n\tspin_unlock(&phba->hbalock);\n\tspin_unlock_irqrestore(&lpfc_cmd->buf_lock, flags);\n\n\tif (phba->cfg_poll & DISABLE_FCP_RING_INT)\n\t\tlpfc_sli_handle_fast_ring_event(phba,\n\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\n\nwait_for_cmpl:\n\t \n\twait_event_timeout(waitq,\n\t\t\t  (lpfc_cmd->pCmd != cmnd),\n\t\t\t   msecs_to_jiffies(2*vport->cfg_devloss_tmo*1000));\n\n\tspin_lock(&lpfc_cmd->buf_lock);\n\n\tif (lpfc_cmd->pCmd == cmnd) {\n\t\tret = FAILED;\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0748 abort handler timed out waiting \"\n\t\t\t\t \"for aborting I/O (xri:x%x) to complete: \"\n\t\t\t\t \"ret %#x, ID %d, LUN %llu\\n\",\n\t\t\t\t iocb->sli4_xritag, ret,\n\t\t\t\t cmnd->device->id, cmnd->device->lun);\n\t}\n\n\tlpfc_cmd->waitq = NULL;\n\n\tspin_unlock(&lpfc_cmd->buf_lock);\n\tgoto out;\n\nout_unlock_ring:\n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\tspin_unlock(&pring_s4->ring_lock);\nout_unlock_hba:\n\tspin_unlock(&phba->hbalock);\n\tspin_unlock_irqrestore(&lpfc_cmd->buf_lock, flags);\nout:\n\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t \"0749 SCSI Layer I/O Abort Request Status x%x ID %d \"\n\t\t\t \"LUN %llu\\n\", ret, cmnd->device->id,\n\t\t\t cmnd->device->lun);\n\treturn ret;\n}\n\nstatic char *\nlpfc_taskmgmt_name(uint8_t task_mgmt_cmd)\n{\n\tswitch (task_mgmt_cmd) {\n\tcase FCP_ABORT_TASK_SET:\n\t\treturn \"ABORT_TASK_SET\";\n\tcase FCP_CLEAR_TASK_SET:\n\t\treturn \"FCP_CLEAR_TASK_SET\";\n\tcase FCP_BUS_RESET:\n\t\treturn \"FCP_BUS_RESET\";\n\tcase FCP_LUN_RESET:\n\t\treturn \"FCP_LUN_RESET\";\n\tcase FCP_TARGET_RESET:\n\t\treturn \"FCP_TARGET_RESET\";\n\tcase FCP_CLEAR_ACA:\n\t\treturn \"FCP_CLEAR_ACA\";\n\tcase FCP_TERMINATE_TASK:\n\t\treturn \"FCP_TERMINATE_TASK\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n\n \nstatic int\nlpfc_check_fcp_rsp(struct lpfc_vport *vport, struct lpfc_io_buf *lpfc_cmd)\n{\n\tstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\n\tuint32_t rsp_info;\n\tuint32_t rsp_len;\n\tuint8_t  rsp_info_code;\n\tint ret = FAILED;\n\n\n\tif (fcprsp == NULL)\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t \"0703 fcp_rsp is missing\\n\");\n\telse {\n\t\trsp_info = fcprsp->rspStatus2;\n\t\trsp_len = be32_to_cpu(fcprsp->rspRspLen);\n\t\trsp_info_code = fcprsp->rspInfo3;\n\n\n\t\tlpfc_printf_vlog(vport, KERN_INFO,\n\t\t\t\t LOG_FCP,\n\t\t\t\t \"0706 fcp_rsp valid 0x%x,\"\n\t\t\t\t \" rsp len=%d code 0x%x\\n\",\n\t\t\t\t rsp_info,\n\t\t\t\t rsp_len, rsp_info_code);\n\n\t\t \n\t\tif ((fcprsp->rspStatus2 & RSP_LEN_VALID) &&\n\t\t    ((rsp_len == 8) || (rsp_len == 4))) {\n\t\t\tswitch (rsp_info_code) {\n\t\t\tcase RSP_NO_FAILURE:\n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t\t \"0715 Task Mgmt No Failure\\n\");\n\t\t\t\tret = SUCCESS;\n\t\t\t\tbreak;\n\t\t\tcase RSP_TM_NOT_SUPPORTED:  \n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t\t \"0716 Task Mgmt Target \"\n\t\t\t\t\t\t\"reject\\n\");\n\t\t\t\tbreak;\n\t\t\tcase RSP_TM_NOT_COMPLETED:  \n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t\t \"0717 Task Mgmt Target \"\n\t\t\t\t\t\t\"failed TM\\n\");\n\t\t\t\tbreak;\n\t\t\tcase RSP_TM_INVALID_LU:  \n\t\t\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\t\t\t \"0718 Task Mgmt to invalid \"\n\t\t\t\t\t\t\"LUN\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n \nstatic int\nlpfc_send_taskmgmt(struct lpfc_vport *vport, struct fc_rport *rport,\n\t\t   unsigned int tgt_id, uint64_t lun_id,\n\t\t   uint8_t task_mgmt_cmd)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct lpfc_io_buf *lpfc_cmd;\n\tstruct lpfc_iocbq *iocbq;\n\tstruct lpfc_iocbq *iocbqrsp;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode;\n\tint ret;\n\tint status;\n\n\trdata = rport->dd_data;\n\tif (!rdata || !rdata->pnode)\n\t\treturn FAILED;\n\tpnode = rdata->pnode;\n\n\tlpfc_cmd = lpfc_get_scsi_buf(phba, rdata->pnode, NULL);\n\tif (lpfc_cmd == NULL)\n\t\treturn FAILED;\n\tlpfc_cmd->timeout = phba->cfg_task_mgmt_tmo;\n\tlpfc_cmd->rdata = rdata;\n\tlpfc_cmd->pCmd = NULL;\n\tlpfc_cmd->ndlp = pnode;\n\n\tstatus = phba->lpfc_scsi_prep_task_mgmt_cmd(vport, lpfc_cmd, lun_id,\n\t\t\t\t\t\t    task_mgmt_cmd);\n\tif (!status) {\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\t\treturn FAILED;\n\t}\n\n\tiocbq = &lpfc_cmd->cur_iocbq;\n\tiocbqrsp = lpfc_sli_get_iocbq(phba);\n\tif (iocbqrsp == NULL) {\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\t\treturn FAILED;\n\t}\n\tiocbq->cmd_cmpl = lpfc_tskmgmt_def_cmpl;\n\tiocbq->vport = vport;\n\n\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t \"0702 Issue %s to TGT %d LUN %llu \"\n\t\t\t \"rpi x%x nlp_flag x%x Data: x%x x%x\\n\",\n\t\t\t lpfc_taskmgmt_name(task_mgmt_cmd), tgt_id, lun_id,\n\t\t\t pnode->nlp_rpi, pnode->nlp_flag, iocbq->sli4_xritag,\n\t\t\t iocbq->cmd_flag);\n\n\tstatus = lpfc_sli_issue_iocb_wait(phba, LPFC_FCP_RING,\n\t\t\t\t\t  iocbq, iocbqrsp, lpfc_cmd->timeout);\n\tif ((status != IOCB_SUCCESS) ||\n\t    (get_job_ulpstatus(phba, iocbqrsp) != IOSTAT_SUCCESS)) {\n\t\tif (status != IOCB_SUCCESS ||\n\t\t    get_job_ulpstatus(phba, iocbqrsp) != IOSTAT_FCP_RSP_ERROR)\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0727 TMF %s to TGT %d LUN %llu \"\n\t\t\t\t\t \"failed (%d, %d) cmd_flag x%x\\n\",\n\t\t\t\t\t lpfc_taskmgmt_name(task_mgmt_cmd),\n\t\t\t\t\t tgt_id, lun_id,\n\t\t\t\t\t get_job_ulpstatus(phba, iocbqrsp),\n\t\t\t\t\t get_job_word4(phba, iocbqrsp),\n\t\t\t\t\t iocbq->cmd_flag);\n\t\t \n\t\tif (status == IOCB_SUCCESS) {\n\t\t\tif (get_job_ulpstatus(phba, iocbqrsp) ==\n\t\t\t    IOSTAT_FCP_RSP_ERROR)\n\t\t\t\t \n\t\t\t\tret = lpfc_check_fcp_rsp(vport, lpfc_cmd);\n\t\t\telse\n\t\t\t\tret = FAILED;\n\t\t} else if ((status == IOCB_TIMEDOUT) ||\n\t\t\t   (status == IOCB_ABORTED)) {\n\t\t\tret = TIMEOUT_ERROR;\n\t\t} else {\n\t\t\tret = FAILED;\n\t\t}\n\t} else\n\t\tret = SUCCESS;\n\n\tlpfc_sli_release_iocbq(phba, iocbqrsp);\n\n\tif (status != IOCB_TIMEDOUT)\n\t\tlpfc_release_scsi_buf(phba, lpfc_cmd);\n\n\treturn ret;\n}\n\n \nstatic int\nlpfc_chk_tgt_mapped(struct lpfc_vport *vport, struct fc_rport *rport)\n{\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode = NULL;\n\tunsigned long later;\n\n\trdata = rport->dd_data;\n\tif (!rdata) {\n\t\tlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\n\t\t\t\"0797 Tgt Map rport failure: rdata x%px\\n\", rdata);\n\t\treturn FAILED;\n\t}\n\tpnode = rdata->pnode;\n\n\t \n\tlater = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;\n\twhile (time_after(later, jiffies)) {\n\t\tif (!pnode)\n\t\t\treturn FAILED;\n\t\tif (pnode->nlp_state == NLP_STE_MAPPED_NODE)\n\t\t\treturn SUCCESS;\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(500));\n\t\trdata = rport->dd_data;\n\t\tif (!rdata)\n\t\t\treturn FAILED;\n\t\tpnode = rdata->pnode;\n\t}\n\tif (!pnode || (pnode->nlp_state != NLP_STE_MAPPED_NODE))\n\t\treturn FAILED;\n\treturn SUCCESS;\n}\n\n \nstatic int\nlpfc_reset_flush_io_context(struct lpfc_vport *vport, uint16_t tgt_id,\n\t\t\tuint64_t lun_id, lpfc_ctx_cmd context)\n{\n\tstruct lpfc_hba   *phba = vport->phba;\n\tunsigned long later;\n\tint cnt;\n\n\tcnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);\n\tif (cnt)\n\t\tlpfc_sli_abort_taskmgmt(vport,\n\t\t\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING],\n\t\t\t\t\ttgt_id, lun_id, context);\n\tlater = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;\n\twhile (time_after(later, jiffies) && cnt) {\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(20));\n\t\tcnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);\n\t}\n\tif (cnt) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0724 I/O flush failure for context %s : cnt x%x\\n\",\n\t\t\t((context == LPFC_CTX_LUN) ? \"LUN\" :\n\t\t\t ((context == LPFC_CTX_TGT) ? \"TGT\" :\n\t\t\t  ((context == LPFC_CTX_HOST) ? \"HOST\" : \"Unknown\"))),\n\t\t\tcnt);\n\t\treturn FAILED;\n\t}\n\treturn SUCCESS;\n}\n\n \nstatic int\nlpfc_device_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host  *shost = cmnd->device->host;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode;\n\tunsigned tgt_id = cmnd->device->id;\n\tuint64_t lun_id = cmnd->device->lun;\n\tstruct lpfc_scsi_event_header scsi_event;\n\tint status;\n\tu32 logit = LOG_FCP;\n\n\tif (!rport)\n\t\treturn FAILED;\n\n\trdata = rport->dd_data;\n\tif (!rdata || !rdata->pnode) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0798 Device Reset rdata failure: rdata x%px\\n\",\n\t\t\t\t rdata);\n\t\treturn FAILED;\n\t}\n\tpnode = rdata->pnode;\n\tstatus = fc_block_rport(rport);\n\tif (status != 0 && status != SUCCESS)\n\t\treturn status;\n\n\tstatus = lpfc_chk_tgt_mapped(vport, rport);\n\tif (status == FAILED) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0721 Device Reset rport failure: rdata x%px\\n\", rdata);\n\t\treturn FAILED;\n\t}\n\n\tscsi_event.event_type = FC_REG_SCSI_EVENT;\n\tscsi_event.subcategory = LPFC_EVENT_LUNRESET;\n\tscsi_event.lun = lun_id;\n\tmemcpy(scsi_event.wwpn, &pnode->nlp_portname, sizeof(struct lpfc_name));\n\tmemcpy(scsi_event.wwnn, &pnode->nlp_nodename, sizeof(struct lpfc_name));\n\n\tfc_host_post_vendor_event(shost, fc_get_event_number(),\n\t\tsizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);\n\n\tstatus = lpfc_send_taskmgmt(vport, rport, tgt_id, lun_id,\n\t\t\t\t\t\tFCP_LUN_RESET);\n\tif (status != SUCCESS)\n\t\tlogit =  LOG_TRACE_EVENT;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, logit,\n\t\t\t \"0713 SCSI layer issued Device Reset (%d, %llu) \"\n\t\t\t \"return x%x\\n\", tgt_id, lun_id, status);\n\n\t \n\tif (status == SUCCESS)\n\t\tstatus = lpfc_reset_flush_io_context(vport, tgt_id, lun_id,\n\t\t\t\t\t\tLPFC_CTX_LUN);\n\n\treturn status;\n}\n\n \nstatic int\nlpfc_target_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host  *shost = cmnd->device->host;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_rport_data *rdata;\n\tstruct lpfc_nodelist *pnode;\n\tunsigned tgt_id = cmnd->device->id;\n\tuint64_t lun_id = cmnd->device->lun;\n\tstruct lpfc_scsi_event_header scsi_event;\n\tint status;\n\tu32 logit = LOG_FCP;\n\tu32 dev_loss_tmo = vport->cfg_devloss_tmo;\n\tunsigned long flags;\n\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waitq);\n\n\tif (!rport)\n\t\treturn FAILED;\n\n\trdata = rport->dd_data;\n\tif (!rdata || !rdata->pnode) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t \"0799 Target Reset rdata failure: rdata x%px\\n\",\n\t\t\t\t rdata);\n\t\treturn FAILED;\n\t}\n\tpnode = rdata->pnode;\n\tstatus = fc_block_rport(rport);\n\tif (status != 0 && status != SUCCESS)\n\t\treturn status;\n\n\tstatus = lpfc_chk_tgt_mapped(vport, rport);\n\tif (status == FAILED) {\n\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\"0722 Target Reset rport failure: rdata x%px\\n\", rdata);\n\t\tif (pnode) {\n\t\t\tspin_lock_irqsave(&pnode->lock, flags);\n\t\t\tpnode->nlp_flag &= ~NLP_NPR_ADISC;\n\t\t\tpnode->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\t\t\tspin_unlock_irqrestore(&pnode->lock, flags);\n\t\t}\n\t\tlpfc_reset_flush_io_context(vport, tgt_id, lun_id,\n\t\t\t\t\t  LPFC_CTX_TGT);\n\t\treturn FAST_IO_FAIL;\n\t}\n\n\tscsi_event.event_type = FC_REG_SCSI_EVENT;\n\tscsi_event.subcategory = LPFC_EVENT_TGTRESET;\n\tscsi_event.lun = 0;\n\tmemcpy(scsi_event.wwpn, &pnode->nlp_portname, sizeof(struct lpfc_name));\n\tmemcpy(scsi_event.wwnn, &pnode->nlp_nodename, sizeof(struct lpfc_name));\n\n\tfc_host_post_vendor_event(shost, fc_get_event_number(),\n\t\tsizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);\n\n\tstatus = lpfc_send_taskmgmt(vport, rport, tgt_id, lun_id,\n\t\t\t\t\tFCP_TARGET_RESET);\n\tif (status != SUCCESS) {\n\t\tlogit = LOG_TRACE_EVENT;\n\n\t\t \n\t\tspin_lock_irqsave(&pnode->lock, flags);\n\t\tif (!(pnode->save_flags & NLP_WAIT_FOR_LOGO) &&\n\t\t    !pnode->logo_waitq) {\n\t\t\tpnode->logo_waitq = &waitq;\n\t\t\tpnode->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\n\t\t\tpnode->nlp_flag |= NLP_ISSUE_LOGO;\n\t\t\tpnode->save_flags |= NLP_WAIT_FOR_LOGO;\n\t\t\tspin_unlock_irqrestore(&pnode->lock, flags);\n\t\t\tlpfc_unreg_rpi(vport, pnode);\n\t\t\twait_event_timeout(waitq,\n\t\t\t\t\t   (!(pnode->save_flags &\n\t\t\t\t\t      NLP_WAIT_FOR_LOGO)),\n\t\t\t\t\t   msecs_to_jiffies(dev_loss_tmo *\n\t\t\t\t\t\t\t    1000));\n\n\t\t\tif (pnode->save_flags & NLP_WAIT_FOR_LOGO) {\n\t\t\t\tlpfc_printf_vlog(vport, KERN_ERR, logit,\n\t\t\t\t\t\t \"0725 SCSI layer TGTRST \"\n\t\t\t\t\t\t \"failed & LOGO TMO (%d, %llu) \"\n\t\t\t\t\t\t \"return x%x\\n\",\n\t\t\t\t\t\t tgt_id, lun_id, status);\n\t\t\t\tspin_lock_irqsave(&pnode->lock, flags);\n\t\t\t\tpnode->save_flags &= ~NLP_WAIT_FOR_LOGO;\n\t\t\t} else {\n\t\t\t\tspin_lock_irqsave(&pnode->lock, flags);\n\t\t\t}\n\t\t\tpnode->logo_waitq = NULL;\n\t\t\tspin_unlock_irqrestore(&pnode->lock, flags);\n\t\t\tstatus = SUCCESS;\n\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&pnode->lock, flags);\n\t\t\tstatus = FAILED;\n\t\t}\n\t}\n\n\tlpfc_printf_vlog(vport, KERN_ERR, logit,\n\t\t\t \"0723 SCSI layer issued Target Reset (%d, %llu) \"\n\t\t\t \"return x%x\\n\", tgt_id, lun_id, status);\n\n\t \n\tif (status == SUCCESS)\n\t\tstatus = lpfc_reset_flush_io_context(vport, tgt_id, lun_id,\n\t\t\t\t\t  LPFC_CTX_TGT);\n\treturn status;\n}\n\n \nstatic int\nlpfc_host_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct Scsi_Host *shost = cmnd->device->host;\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\n\tstruct lpfc_hba *phba = vport->phba;\n\tint rc, ret = SUCCESS;\n\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\n\t\t\t \"3172 SCSI layer issued Host Reset Data:\\n\");\n\n\tlpfc_offline_prep(phba, LPFC_MBX_WAIT);\n\tlpfc_offline(phba);\n\trc = lpfc_sli_brdrestart(phba);\n\tif (rc)\n\t\tgoto error;\n\n\t \n\tif (phba->sli_rev < LPFC_SLI_REV4) {\n\t\trc = lpfc_sli_chipset_init(phba);\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\trc = lpfc_online(phba);\n\tif (rc)\n\t\tgoto error;\n\n\tlpfc_unblock_mgmt_io(phba);\n\n\treturn ret;\nerror:\n\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t \"3323 Failed host reset\\n\");\n\tlpfc_unblock_mgmt_io(phba);\n\treturn FAILED;\n}\n\n \nstatic int\nlpfc_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\tuint32_t total = 0;\n\tuint32_t num_to_alloc = 0;\n\tint num_allocated = 0;\n\tuint32_t sdev_cnt;\n\tstruct lpfc_device_data *device_data;\n\tunsigned long flags;\n\tstruct lpfc_name target_wwpn;\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\tif (phba->cfg_fof) {\n\n\t\t \n\n\t\tu64_to_wwn(rport->port_name, target_wwpn.u.wwn);\n\t\tspin_lock_irqsave(&phba->devicelock, flags);\n\t\tdevice_data = __lpfc_get_device_data(phba,\n\t\t\t\t\t\t     &phba->luns,\n\t\t\t\t\t\t     &vport->fc_portname,\n\t\t\t\t\t\t     &target_wwpn,\n\t\t\t\t\t\t     sdev->lun);\n\t\tif (!device_data) {\n\t\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\t\tdevice_data = lpfc_create_device_data(phba,\n\t\t\t\t\t\t\t&vport->fc_portname,\n\t\t\t\t\t\t\t&target_wwpn,\n\t\t\t\t\t\t\tsdev->lun,\n\t\t\t\t\t\t\tphba->cfg_XLanePriority,\n\t\t\t\t\t\t\ttrue);\n\t\t\tif (!device_data)\n\t\t\t\treturn -ENOMEM;\n\t\t\tspin_lock_irqsave(&phba->devicelock, flags);\n\t\t\tlist_add_tail(&device_data->listentry, &phba->luns);\n\t\t}\n\t\tdevice_data->rport_data = rport->dd_data;\n\t\tdevice_data->available = true;\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\tsdev->hostdata = device_data;\n\t} else {\n\t\tsdev->hostdata = rport->dd_data;\n\t}\n\tsdev_cnt = atomic_inc_return(&phba->sdev_cnt);\n\n\t \n\tif (phba->sli_rev == LPFC_SLI_REV4)\n\t\treturn 0;\n\n\t \n\n\t \n\ttotal = phba->total_scsi_bufs;\n\tnum_to_alloc = vport->cfg_lun_queue_depth + 2;\n\n\t \n\tif ((sdev_cnt * (vport->cfg_lun_queue_depth + 2)) < total)\n\t\treturn 0;\n\n\t \n\tif (total >= phba->cfg_hba_queue_depth - LPFC_DISC_IOCB_BUFF_COUNT ) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\t \"0704 At limitation of %d preallocated \"\n\t\t\t\t \"command buffers\\n\", total);\n\t\treturn 0;\n\t \n\t} else if (total + num_to_alloc >\n\t\tphba->cfg_hba_queue_depth - LPFC_DISC_IOCB_BUFF_COUNT ) {\n\t\tlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\n\t\t\t\t \"0705 Allocation request of %d \"\n\t\t\t\t \"command buffers will exceed max of %d.  \"\n\t\t\t\t \"Reducing allocation request to %d.\\n\",\n\t\t\t\t num_to_alloc, phba->cfg_hba_queue_depth,\n\t\t\t\t (phba->cfg_hba_queue_depth - total));\n\t\tnum_to_alloc = phba->cfg_hba_queue_depth - total;\n\t}\n\tnum_allocated = lpfc_new_scsi_buf_s3(vport, num_to_alloc);\n\tif (num_to_alloc != num_allocated) {\n\t\t\tlpfc_printf_vlog(vport, KERN_ERR, LOG_TRACE_EVENT,\n\t\t\t\t\t \"0708 Allocation request of %d \"\n\t\t\t\t\t \"command buffers did not succeed.  \"\n\t\t\t\t\t \"Allocated %d buffers.\\n\",\n\t\t\t\t\t num_to_alloc, num_allocated);\n\t}\n\tif (num_allocated > 0)\n\t\tphba->total_scsi_bufs += num_allocated;\n\treturn 0;\n}\n\n \nstatic int\nlpfc_slave_configure(struct scsi_device *sdev)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\n\tscsi_change_queue_depth(sdev, vport->cfg_lun_queue_depth);\n\n\tif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\n\t\tlpfc_sli_handle_fast_ring_event(phba,\n\t\t\t&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\n\t\tif (phba->cfg_poll & DISABLE_FCP_RING_INT)\n\t\t\tlpfc_poll_rearm_timer(phba);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void\nlpfc_slave_destroy(struct scsi_device *sdev)\n{\n\tstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\n\tstruct lpfc_hba   *phba = vport->phba;\n\tunsigned long flags;\n\tstruct lpfc_device_data *device_data = sdev->hostdata;\n\n\tatomic_dec(&phba->sdev_cnt);\n\tif ((phba->cfg_fof) && (device_data)) {\n\t\tspin_lock_irqsave(&phba->devicelock, flags);\n\t\tdevice_data->available = false;\n\t\tif (!device_data->oas_enabled)\n\t\t\tlpfc_delete_device_data(phba, device_data);\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t}\n\tsdev->hostdata = NULL;\n\treturn;\n}\n\n \nstruct lpfc_device_data*\nlpfc_create_device_data(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\n\t\t\tstruct lpfc_name *target_wwpn, uint64_t lun,\n\t\t\tuint32_t pri, bool atomic_create)\n{\n\n\tstruct lpfc_device_data *lun_info;\n\tint memory_flags;\n\n\tif (unlikely(!phba) || !vport_wwpn || !target_wwpn  ||\n\t    !(phba->cfg_fof))\n\t\treturn NULL;\n\n\t \n\n\tif (atomic_create)\n\t\tmemory_flags = GFP_ATOMIC;\n\telse\n\t\tmemory_flags = GFP_KERNEL;\n\tlun_info = mempool_alloc(phba->device_data_mem_pool, memory_flags);\n\tif (!lun_info)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lun_info->listentry);\n\tlun_info->rport_data  = NULL;\n\tmemcpy(&lun_info->device_id.vport_wwpn, vport_wwpn,\n\t       sizeof(struct lpfc_name));\n\tmemcpy(&lun_info->device_id.target_wwpn, target_wwpn,\n\t       sizeof(struct lpfc_name));\n\tlun_info->device_id.lun = lun;\n\tlun_info->oas_enabled = false;\n\tlun_info->priority = pri;\n\tlun_info->available = false;\n\treturn lun_info;\n}\n\n \nvoid\nlpfc_delete_device_data(struct lpfc_hba *phba,\n\t\t\tstruct lpfc_device_data *lun_info)\n{\n\n\tif (unlikely(!phba) || !lun_info  ||\n\t    !(phba->cfg_fof))\n\t\treturn;\n\n\tif (!list_empty(&lun_info->listentry))\n\t\tlist_del(&lun_info->listentry);\n\tmempool_free(lun_info, phba->device_data_mem_pool);\n\treturn;\n}\n\n \nstruct lpfc_device_data*\n__lpfc_get_device_data(struct lpfc_hba *phba, struct list_head *list,\n\t\t       struct lpfc_name *vport_wwpn,\n\t\t       struct lpfc_name *target_wwpn, uint64_t lun)\n{\n\n\tstruct lpfc_device_data *lun_info;\n\n\tif (unlikely(!phba) || !list || !vport_wwpn || !target_wwpn ||\n\t    !phba->cfg_fof)\n\t\treturn NULL;\n\n\t \n\n\tlist_for_each_entry(lun_info, list, listentry) {\n\t\tif ((memcmp(&lun_info->device_id.vport_wwpn, vport_wwpn,\n\t\t\t    sizeof(struct lpfc_name)) == 0) &&\n\t\t    (memcmp(&lun_info->device_id.target_wwpn, target_wwpn,\n\t\t\t    sizeof(struct lpfc_name)) == 0) &&\n\t\t    (lun_info->device_id.lun == lun))\n\t\t\treturn lun_info;\n\t}\n\n\treturn NULL;\n}\n\n \nbool\nlpfc_find_next_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\n\t\t       struct lpfc_name *target_wwpn, uint64_t *starting_lun,\n\t\t       struct lpfc_name *found_vport_wwpn,\n\t\t       struct lpfc_name *found_target_wwpn,\n\t\t       uint64_t *found_lun,\n\t\t       uint32_t *found_lun_status,\n\t\t       uint32_t *found_lun_pri)\n{\n\n\tunsigned long flags;\n\tstruct lpfc_device_data *lun_info;\n\tstruct lpfc_device_id *device_id;\n\tuint64_t lun;\n\tbool found = false;\n\n\tif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\n\t    !starting_lun || !found_vport_wwpn ||\n\t    !found_target_wwpn || !found_lun || !found_lun_status ||\n\t    (*starting_lun == NO_MORE_OAS_LUN) ||\n\t    !phba->cfg_fof)\n\t\treturn false;\n\n\tlun = *starting_lun;\n\t*found_lun = NO_MORE_OAS_LUN;\n\t*starting_lun = NO_MORE_OAS_LUN;\n\n\t \n\n\tspin_lock_irqsave(&phba->devicelock, flags);\n\tlist_for_each_entry(lun_info, &phba->luns, listentry) {\n\t\tif (((wwn_to_u64(vport_wwpn->u.wwn) == 0) ||\n\t\t     (memcmp(&lun_info->device_id.vport_wwpn, vport_wwpn,\n\t\t\t    sizeof(struct lpfc_name)) == 0)) &&\n\t\t    ((wwn_to_u64(target_wwpn->u.wwn) == 0) ||\n\t\t     (memcmp(&lun_info->device_id.target_wwpn, target_wwpn,\n\t\t\t    sizeof(struct lpfc_name)) == 0)) &&\n\t\t    (lun_info->oas_enabled)) {\n\t\t\tdevice_id = &lun_info->device_id;\n\t\t\tif ((!found) &&\n\t\t\t    ((lun == FIND_FIRST_OAS_LUN) ||\n\t\t\t     (device_id->lun == lun))) {\n\t\t\t\t*found_lun = device_id->lun;\n\t\t\t\tmemcpy(found_vport_wwpn,\n\t\t\t\t       &device_id->vport_wwpn,\n\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tmemcpy(found_target_wwpn,\n\t\t\t\t       &device_id->target_wwpn,\n\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tif (lun_info->available)\n\t\t\t\t\t*found_lun_status =\n\t\t\t\t\t\tOAS_LUN_STATUS_EXISTS;\n\t\t\t\telse\n\t\t\t\t\t*found_lun_status = 0;\n\t\t\t\t*found_lun_pri = lun_info->priority;\n\t\t\t\tif (phba->cfg_oas_flags & OAS_FIND_ANY_VPORT)\n\t\t\t\t\tmemset(vport_wwpn, 0x0,\n\t\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tif (phba->cfg_oas_flags & OAS_FIND_ANY_TARGET)\n\t\t\t\t\tmemset(target_wwpn, 0x0,\n\t\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tfound = true;\n\t\t\t} else if (found) {\n\t\t\t\t*starting_lun = device_id->lun;\n\t\t\t\tmemcpy(vport_wwpn, &device_id->vport_wwpn,\n\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tmemcpy(target_wwpn, &device_id->target_wwpn,\n\t\t\t\t       sizeof(struct lpfc_name));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\treturn found;\n}\n\n \nbool\nlpfc_enable_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\n\t\t    struct lpfc_name *target_wwpn, uint64_t lun, uint8_t pri)\n{\n\n\tstruct lpfc_device_data *lun_info;\n\tunsigned long flags;\n\n\tif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\n\t    !phba->cfg_fof)\n\t\treturn false;\n\n\tspin_lock_irqsave(&phba->devicelock, flags);\n\n\t \n\tlun_info = __lpfc_get_device_data(phba, &phba->luns, vport_wwpn,\n\t\t\t\t\t  target_wwpn, lun);\n\tif (lun_info) {\n\t\tif (!lun_info->oas_enabled)\n\t\t\tlun_info->oas_enabled = true;\n\t\tlun_info->priority = pri;\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\treturn true;\n\t}\n\n\t \n\tlun_info = lpfc_create_device_data(phba, vport_wwpn, target_wwpn, lun,\n\t\t\t\t\t   pri, true);\n\tif (lun_info) {\n\t\tlun_info->oas_enabled = true;\n\t\tlun_info->priority = pri;\n\t\tlun_info->available = false;\n\t\tlist_add_tail(&lun_info->listentry, &phba->luns);\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\treturn true;\n\t}\n\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\treturn false;\n}\n\n \nbool\nlpfc_disable_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\n\t\t     struct lpfc_name *target_wwpn, uint64_t lun, uint8_t pri)\n{\n\n\tstruct lpfc_device_data *lun_info;\n\tunsigned long flags;\n\n\tif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\n\t    !phba->cfg_fof)\n\t\treturn false;\n\n\tspin_lock_irqsave(&phba->devicelock, flags);\n\n\t \n\tlun_info = __lpfc_get_device_data(phba,\n\t\t\t\t\t  &phba->luns, vport_wwpn,\n\t\t\t\t\t  target_wwpn, lun);\n\tif (lun_info) {\n\t\tlun_info->oas_enabled = false;\n\t\tlun_info->priority = pri;\n\t\tif (!lun_info->available)\n\t\t\tlpfc_delete_device_data(phba, lun_info);\n\t\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\t\treturn true;\n\t}\n\n\tspin_unlock_irqrestore(&phba->devicelock, flags);\n\treturn false;\n}\n\nstatic int\nlpfc_no_command(struct Scsi_Host *shost, struct scsi_cmnd *cmnd)\n{\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\nstatic int\nlpfc_no_slave(struct scsi_device *sdev)\n{\n\treturn -ENODEV;\n}\n\nstruct scsi_host_template lpfc_template_nvme = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= LPFC_DRIVER_NAME,\n\t.proc_name\t\t= LPFC_DRIVER_NAME,\n\t.info\t\t\t= lpfc_info,\n\t.queuecommand\t\t= lpfc_no_command,\n\t.slave_alloc\t\t= lpfc_no_slave,\n\t.slave_configure\t= lpfc_no_slave,\n\t.scan_finished\t\t= lpfc_scan_finished,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= 1,\n\t.cmd_per_lun\t\t= 1,\n\t.shost_groups\t\t= lpfc_hba_groups,\n\t.max_sectors\t\t= 0xFFFFFFFF,\n\t.vendor_id\t\t= LPFC_NL_VENDOR_ID,\n\t.track_queue_depth\t= 0,\n};\n\nstruct scsi_host_template lpfc_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= LPFC_DRIVER_NAME,\n\t.proc_name\t\t= LPFC_DRIVER_NAME,\n\t.info\t\t\t= lpfc_info,\n\t.queuecommand\t\t= lpfc_queuecommand,\n\t.eh_timed_out\t\t= fc_eh_timed_out,\n\t.eh_should_retry_cmd    = fc_eh_should_retry_cmd,\n\t.eh_abort_handler\t= lpfc_abort_handler,\n\t.eh_device_reset_handler = lpfc_device_reset_handler,\n\t.eh_target_reset_handler = lpfc_target_reset_handler,\n\t.eh_host_reset_handler  = lpfc_host_reset_handler,\n\t.slave_alloc\t\t= lpfc_slave_alloc,\n\t.slave_configure\t= lpfc_slave_configure,\n\t.slave_destroy\t\t= lpfc_slave_destroy,\n\t.scan_finished\t\t= lpfc_scan_finished,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= LPFC_DEFAULT_SG_SEG_CNT,\n\t.cmd_per_lun\t\t= LPFC_CMD_PER_LUN,\n\t.shost_groups\t\t= lpfc_hba_groups,\n\t.max_sectors\t\t= 0xFFFFFFFF,\n\t.vendor_id\t\t= LPFC_NL_VENDOR_ID,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.track_queue_depth\t= 1,\n};\n\nstruct scsi_host_template lpfc_vport_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= LPFC_DRIVER_NAME,\n\t.proc_name\t\t= LPFC_DRIVER_NAME,\n\t.info\t\t\t= lpfc_info,\n\t.queuecommand\t\t= lpfc_queuecommand,\n\t.eh_timed_out\t\t= fc_eh_timed_out,\n\t.eh_should_retry_cmd    = fc_eh_should_retry_cmd,\n\t.eh_abort_handler\t= lpfc_abort_handler,\n\t.eh_device_reset_handler = lpfc_device_reset_handler,\n\t.eh_target_reset_handler = lpfc_target_reset_handler,\n\t.eh_bus_reset_handler\t= NULL,\n\t.eh_host_reset_handler\t= NULL,\n\t.slave_alloc\t\t= lpfc_slave_alloc,\n\t.slave_configure\t= lpfc_slave_configure,\n\t.slave_destroy\t\t= lpfc_slave_destroy,\n\t.scan_finished\t\t= lpfc_scan_finished,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= LPFC_DEFAULT_SG_SEG_CNT,\n\t.cmd_per_lun\t\t= LPFC_CMD_PER_LUN,\n\t.shost_groups\t\t= lpfc_vport_groups,\n\t.max_sectors\t\t= 0xFFFFFFFF,\n\t.vendor_id\t\t= 0,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.track_queue_depth\t= 1,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}