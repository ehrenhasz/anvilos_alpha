{
  "module_name": "efct_io.c",
  "hash_id": "8bcdd2dddd63b9bdd54e4db5e434a567fe6ebbe0c2a37a2c9039a49582aa09a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/efct/efct_io.c",
  "human_readable_source": "\n \n\n#include \"efct_driver.h\"\n#include \"efct_hw.h\"\n#include \"efct_io.h\"\n\nstruct efct_io_pool {\n\tstruct efct *efct;\n\tspinlock_t lock;\t \n\tu32 io_num_ios;\t\t \n\tstruct efct_io *ios[EFCT_NUM_SCSI_IOS];\n\tstruct list_head freelist;\n\n};\n\nstruct efct_io_pool *\nefct_io_pool_create(struct efct *efct, u32 num_sgl)\n{\n\tu32 i = 0;\n\tstruct efct_io_pool *io_pool;\n\tstruct efct_io *io;\n\n\t \n\tio_pool = kzalloc(sizeof(*io_pool), GFP_KERNEL);\n\tif (!io_pool)\n\t\treturn NULL;\n\n\tio_pool->efct = efct;\n\tINIT_LIST_HEAD(&io_pool->freelist);\n\t \n\tspin_lock_init(&io_pool->lock);\n\n\tfor (i = 0; i < EFCT_NUM_SCSI_IOS; i++) {\n\t\tio = kzalloc(sizeof(*io), GFP_KERNEL);\n\t\tif (!io)\n\t\t\tbreak;\n\n\t\tio_pool->io_num_ios++;\n\t\tio_pool->ios[i] = io;\n\t\tio->tag = i;\n\t\tio->instance_index = i;\n\n\t\t \n\t\tio->rspbuf.size = SCSI_RSP_BUF_LENGTH;\n\t\tio->rspbuf.virt = dma_alloc_coherent(&efct->pci->dev,\n\t\t\t\t\t\t     io->rspbuf.size,\n\t\t\t\t\t\t     &io->rspbuf.phys, GFP_KERNEL);\n\t\tif (!io->rspbuf.virt) {\n\t\t\tefc_log_err(efct, \"dma_alloc rspbuf failed\\n\");\n\t\t\tefct_io_pool_free(io_pool);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tio->sgl = kzalloc(sizeof(*io->sgl) * num_sgl, GFP_KERNEL);\n\t\tif (!io->sgl) {\n\t\t\tefct_io_pool_free(io_pool);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tio->sgl_allocated = num_sgl;\n\t\tio->sgl_count = 0;\n\n\t\tINIT_LIST_HEAD(&io->list_entry);\n\t\tlist_add_tail(&io->list_entry, &io_pool->freelist);\n\t}\n\n\treturn io_pool;\n}\n\nint\nefct_io_pool_free(struct efct_io_pool *io_pool)\n{\n\tstruct efct *efct;\n\tu32 i;\n\tstruct efct_io *io;\n\n\tif (io_pool) {\n\t\tefct = io_pool->efct;\n\n\t\tfor (i = 0; i < io_pool->io_num_ios; i++) {\n\t\t\tio = io_pool->ios[i];\n\t\t\tif (!io)\n\t\t\t\tcontinue;\n\n\t\t\tkfree(io->sgl);\n\t\t\tdma_free_coherent(&efct->pci->dev,\n\t\t\t\t\t  io->rspbuf.size, io->rspbuf.virt,\n\t\t\t\t\t  io->rspbuf.phys);\n\t\t\tmemset(&io->rspbuf, 0, sizeof(struct efc_dma));\n\t\t}\n\n\t\tkfree(io_pool);\n\t\tefct->xport->io_pool = NULL;\n\t}\n\n\treturn 0;\n}\n\nstruct efct_io *\nefct_io_pool_io_alloc(struct efct_io_pool *io_pool)\n{\n\tstruct efct_io *io = NULL;\n\tstruct efct *efct;\n\tunsigned long flags = 0;\n\n\tefct = io_pool->efct;\n\n\tspin_lock_irqsave(&io_pool->lock, flags);\n\n\tif (!list_empty(&io_pool->freelist)) {\n\t\tio = list_first_entry(&io_pool->freelist, struct efct_io,\n\t\t\t\t      list_entry);\n\t\tlist_del_init(&io->list_entry);\n\t}\n\n\tspin_unlock_irqrestore(&io_pool->lock, flags);\n\n\tif (!io)\n\t\treturn NULL;\n\n\tio->io_type = EFCT_IO_TYPE_MAX;\n\tio->hio_type = EFCT_HW_IO_MAX;\n\tio->hio = NULL;\n\tio->transferred = 0;\n\tio->efct = efct;\n\tio->timeout = 0;\n\tio->sgl_count = 0;\n\tio->tgt_task_tag = 0;\n\tio->init_task_tag = 0;\n\tio->hw_tag = 0;\n\tio->display_name = \"pending\";\n\tio->seq_init = 0;\n\tio->io_free = 0;\n\tio->release = NULL;\n\tatomic_add_return(1, &efct->xport->io_active_count);\n\tatomic_add_return(1, &efct->xport->io_total_alloc);\n\treturn io;\n}\n\n \nvoid\nefct_io_pool_io_free(struct efct_io_pool *io_pool, struct efct_io *io)\n{\n\tstruct efct *efct;\n\tstruct efct_hw_io *hio = NULL;\n\tunsigned long flags = 0;\n\n\tefct = io_pool->efct;\n\n\tspin_lock_irqsave(&io_pool->lock, flags);\n\thio = io->hio;\n\tio->hio = NULL;\n\tio->io_free = 1;\n\tINIT_LIST_HEAD(&io->list_entry);\n\tlist_add(&io->list_entry, &io_pool->freelist);\n\tspin_unlock_irqrestore(&io_pool->lock, flags);\n\n\tif (hio)\n\t\tefct_hw_io_free(&efct->hw, hio);\n\n\tatomic_sub_return(1, &efct->xport->io_active_count);\n\tatomic_add_return(1, &efct->xport->io_total_free);\n}\n\n \nstruct efct_io *\nefct_io_find_tgt_io(struct efct *efct, struct efct_node *node,\n\t\t    u16 ox_id, u16 rx_id)\n{\n\tstruct efct_io\t*io = NULL;\n\tunsigned long flags = 0;\n\tu8 found = false;\n\n\tspin_lock_irqsave(&node->active_ios_lock, flags);\n\tlist_for_each_entry(io, &node->active_ios, list_entry) {\n\t\tif ((io->cmd_tgt && io->init_task_tag == ox_id) &&\n\t\t    (rx_id == 0xffff || io->tgt_task_tag == rx_id)) {\n\t\t\tif (kref_get_unless_zero(&io->ref))\n\t\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&node->active_ios_lock, flags);\n\treturn found ? io : NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}