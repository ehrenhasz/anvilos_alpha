{
  "module_name": "efct_driver.c",
  "hash_id": "8f879cde1b008e4e137144a527d069c2643e6a9a608a7473df7cb780eb334bc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/efct/efct_driver.c",
  "human_readable_source": "\n \n\n#include \"efct_driver.h\"\n\n#include \"efct_hw.h\"\n#include \"efct_unsol.h\"\n#include \"efct_scsi.h\"\n\nLIST_HEAD(efct_devices);\n\nstatic int logmask;\nmodule_param(logmask, int, 0444);\nMODULE_PARM_DESC(logmask, \"logging bitmask (default 0)\");\n\nstatic struct libefc_function_template efct_libefc_templ = {\n\t.issue_mbox_rqst = efct_issue_mbox_rqst,\n\t.send_els = efct_els_hw_srrs_send,\n\t.send_bls = efct_efc_bls_send,\n\n\t.new_nport = efct_scsi_tgt_new_nport,\n\t.del_nport = efct_scsi_tgt_del_nport,\n\t.scsi_new_node = efct_scsi_new_initiator,\n\t.scsi_del_node = efct_scsi_del_initiator,\n\t.hw_seq_free = efct_efc_hw_sequence_free,\n};\n\nstatic int\nefct_device_init(void)\n{\n\tint rc;\n\n\t \n\trc = efct_scsi_tgt_driver_init();\n\tif (rc) {\n\t\tpr_err(\"efct_scsi_tgt_init failed rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = efct_scsi_reg_fc_transport();\n\tif (rc) {\n\t\tefct_scsi_tgt_driver_exit();\n\t\tpr_err(\"failed to register to FC host\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nefct_device_shutdown(void)\n{\n\tefct_scsi_release_fc_transport();\n\n\tefct_scsi_tgt_driver_exit();\n}\n\nstatic void *\nefct_device_alloc(u32 nid)\n{\n\tstruct efct *efct = NULL;\n\n\tefct = kzalloc_node(sizeof(*efct), GFP_KERNEL, nid);\n\tif (!efct)\n\t\treturn efct;\n\n\tINIT_LIST_HEAD(&efct->list_entry);\n\tlist_add_tail(&efct->list_entry, &efct_devices);\n\n\treturn efct;\n}\n\nstatic void\nefct_teardown_msix(struct efct *efct)\n{\n\tu32 i;\n\n\tfor (i = 0; i < efct->n_msix_vec; i++) {\n\t\tfree_irq(pci_irq_vector(efct->pci, i),\n\t\t\t &efct->intr_context[i]);\n\t}\n\n\tpci_free_irq_vectors(efct->pci);\n}\n\nstatic int\nefct_efclib_config(struct efct *efct, struct libefc_function_template *tt)\n{\n\tstruct efc *efc;\n\tstruct sli4 *sli;\n\tint rc = 0;\n\n\tefc = kzalloc(sizeof(*efc), GFP_KERNEL);\n\tif (!efc)\n\t\treturn -ENOMEM;\n\n\tefct->efcport = efc;\n\n\tmemcpy(&efc->tt, tt, sizeof(*tt));\n\tefc->base = efct;\n\tefc->pci = efct->pci;\n\n\tefc->def_wwnn = efct_get_wwnn(&efct->hw);\n\tefc->def_wwpn = efct_get_wwpn(&efct->hw);\n\tefc->enable_tgt = 1;\n\tefc->log_level = EFC_LOG_LIB;\n\n\tsli = &efct->hw.sli;\n\tefc->max_xfer_size = sli->sge_supported_length *\n\t\t\t     sli_get_max_sgl(&efct->hw.sli);\n\tefc->sli = sli;\n\tefc->fcfi = efct->hw.fcf_indicator;\n\n\trc = efcport_init(efc);\n\tif (rc)\n\t\tefc_log_err(efc, \"efcport_init failed\\n\");\n\n\treturn rc;\n}\n\nstatic int efct_request_firmware_update(struct efct *efct);\n\nstatic const char*\nefct_pci_model(u16 device)\n{\n\tswitch (device) {\n\tcase EFCT_DEVICE_LANCER_G6:\treturn \"LPE31004\";\n\tcase EFCT_DEVICE_LANCER_G7:\treturn \"LPE36000\";\n\tdefault:\t\t\treturn \"unknown\";\n\t}\n}\n\nstatic int\nefct_device_attach(struct efct *efct)\n{\n\tu32 rc = 0, i = 0;\n\n\tif (efct->attached) {\n\t\tefc_log_err(efct, \"Device is already attached\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsnprintf(efct->name, sizeof(efct->name), \"[%s%d] \", \"fc\",\n\t\t efct->instance_index);\n\n\tefct->logmask = logmask;\n\tefct->filter_def = EFCT_DEFAULT_FILTER;\n\tefct->max_isr_time_msec = EFCT_OS_MAX_ISR_TIME_MSEC;\n\n\tefct->model = efct_pci_model(efct->pci->device);\n\n\tefct->efct_req_fw_upgrade = true;\n\n\t \n\tefct->xport = efct_xport_alloc(efct);\n\tif (!efct->xport) {\n\t\tefc_log_err(efct, \"failed to allocate transport object\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = efct_xport_attach(efct->xport);\n\tif (rc) {\n\t\tefc_log_err(efct, \"failed to attach transport object\\n\");\n\t\tgoto xport_out;\n\t}\n\n\trc = efct_xport_initialize(efct->xport);\n\tif (rc) {\n\t\tefc_log_err(efct, \"failed to initialize transport object\\n\");\n\t\tgoto xport_out;\n\t}\n\n\trc = efct_efclib_config(efct, &efct_libefc_templ);\n\tif (rc) {\n\t\tefc_log_err(efct, \"failed to init efclib\\n\");\n\t\tgoto efclib_out;\n\t}\n\n\tfor (i = 0; i < efct->n_msix_vec; i++) {\n\t\tefc_log_debug(efct, \"irq %d enabled\\n\", i);\n\t\tenable_irq(pci_irq_vector(efct->pci, i));\n\t}\n\n\tefct->attached = true;\n\n\tif (efct->efct_req_fw_upgrade)\n\t\tefct_request_firmware_update(efct);\n\n\treturn rc;\n\nefclib_out:\n\tefct_xport_detach(efct->xport);\nxport_out:\n\tefct_xport_free(efct->xport);\n\tefct->xport = NULL;\nout:\n\treturn rc;\n}\n\nstatic int\nefct_device_detach(struct efct *efct)\n{\n\tint i;\n\n\tif (!efct || !efct->attached) {\n\t\tpr_err(\"Device is not attached\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (efct_xport_control(efct->xport, EFCT_XPORT_SHUTDOWN))\n\t\tefc_log_err(efct, \"Transport Shutdown timed out\\n\");\n\n\tfor (i = 0; i < efct->n_msix_vec; i++)\n\t\tdisable_irq(pci_irq_vector(efct->pci, i));\n\n\tefct_xport_detach(efct->xport);\n\n\tefct_xport_free(efct->xport);\n\tefct->xport = NULL;\n\n\tefcport_destroy(efct->efcport);\n\tkfree(efct->efcport);\n\n\tefct->attached = false;\n\n\treturn 0;\n}\n\nstatic void\nefct_fw_write_cb(int status, u32 actual_write_length,\n\t\t u32 change_status, void *arg)\n{\n\tstruct efct_fw_write_result *result = arg;\n\n\tresult->status = status;\n\tresult->actual_xfer = actual_write_length;\n\tresult->change_status = change_status;\n\n\tcomplete(&result->done);\n}\n\nstatic int\nefct_firmware_write(struct efct *efct, const u8 *buf, size_t buf_len,\n\t\t    u8 *change_status)\n{\n\tint rc = 0;\n\tu32 bytes_left;\n\tu32 xfer_size;\n\tu32 offset;\n\tstruct efc_dma dma;\n\tint last = 0;\n\tstruct efct_fw_write_result result;\n\n\tinit_completion(&result.done);\n\n\tbytes_left = buf_len;\n\toffset = 0;\n\n\tdma.size = FW_WRITE_BUFSIZE;\n\tdma.virt = dma_alloc_coherent(&efct->pci->dev,\n\t\t\t\t      dma.size, &dma.phys, GFP_KERNEL);\n\tif (!dma.virt)\n\t\treturn -ENOMEM;\n\n\twhile (bytes_left > 0) {\n\t\tif (bytes_left > FW_WRITE_BUFSIZE)\n\t\t\txfer_size = FW_WRITE_BUFSIZE;\n\t\telse\n\t\t\txfer_size = bytes_left;\n\n\t\tmemcpy(dma.virt, buf + offset, xfer_size);\n\n\t\tif (bytes_left == xfer_size)\n\t\t\tlast = 1;\n\n\t\tefct_hw_firmware_write(&efct->hw, &dma, xfer_size, offset,\n\t\t\t\t       last, efct_fw_write_cb, &result);\n\n\t\tif (wait_for_completion_interruptible(&result.done) != 0) {\n\t\t\trc = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result.actual_xfer == 0 || result.status != 0) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (last)\n\t\t\t*change_status = result.change_status;\n\n\t\tbytes_left -= result.actual_xfer;\n\t\toffset += result.actual_xfer;\n\t}\n\n\tdma_free_coherent(&efct->pci->dev, dma.size, dma.virt, dma.phys);\n\treturn rc;\n}\n\nstatic int\nefct_fw_reset(struct efct *efct)\n{\n\t \n\tif (timer_pending(&efct->xport->stats_timer))\n\t\tdel_timer(&efct->xport->stats_timer);\n\n\tif (efct_hw_reset(&efct->hw, EFCT_HW_RESET_FIRMWARE)) {\n\t\tefc_log_info(efct, \"failed to reset firmware\\n\");\n\t\treturn -EIO;\n\t}\n\n\tefc_log_info(efct, \"successfully reset firmware.Now resetting port\\n\");\n\n\tefct_device_detach(efct);\n\treturn efct_device_attach(efct);\n}\n\nstatic int\nefct_request_firmware_update(struct efct *efct)\n{\n\tint rc = 0;\n\tu8 file_name[256], fw_change_status = 0;\n\tconst struct firmware *fw;\n\tstruct efct_hw_grp_hdr *fw_image;\n\n\tsnprintf(file_name, 256, \"%s.grp\", efct->model);\n\n\trc = request_firmware(&fw, file_name, &efct->pci->dev);\n\tif (rc) {\n\t\tefc_log_debug(efct, \"Firmware file(%s) not found.\\n\", file_name);\n\t\treturn rc;\n\t}\n\n\tfw_image = (struct efct_hw_grp_hdr *)fw->data;\n\n\tif (!strncmp(efct->hw.sli.fw_name[0], fw_image->revision,\n\t\t     strnlen(fw_image->revision, 16))) {\n\t\tefc_log_debug(efct,\n\t\t\t      \"Skip update. Firmware is already up to date.\\n\");\n\t\tgoto exit;\n\t}\n\n\tefc_log_info(efct, \"Firmware update is initiated. %s -> %s\\n\",\n\t\t     efct->hw.sli.fw_name[0], fw_image->revision);\n\n\trc = efct_firmware_write(efct, fw->data, fw->size, &fw_change_status);\n\tif (rc) {\n\t\tefc_log_err(efct, \"Firmware update failed. rc = %d\\n\", rc);\n\t\tgoto exit;\n\t}\n\n\tefc_log_info(efct, \"Firmware updated successfully\\n\");\n\tswitch (fw_change_status) {\n\tcase 0x00:\n\t\tefc_log_info(efct, \"New firmware is active.\\n\");\n\t\tbreak;\n\tcase 0x01:\n\t\tefc_log_info(efct,\n\t\t\t\"System reboot needed to activate the new firmware\\n\");\n\t\tbreak;\n\tcase 0x02:\n\tcase 0x03:\n\t\tefc_log_info(efct,\n\t\t\t     \"firmware reset to activate the new firmware\\n\");\n\t\tefct_fw_reset(efct);\n\t\tbreak;\n\tdefault:\n\t\tefc_log_info(efct, \"Unexpected value change_status:%d\\n\",\n\t\t\t     fw_change_status);\n\t\tbreak;\n\t}\n\nexit:\n\trelease_firmware(fw);\n\n\treturn rc;\n}\n\nstatic void\nefct_device_free(struct efct *efct)\n{\n\tif (efct) {\n\t\tlist_del(&efct->list_entry);\n\t\tkfree(efct);\n\t}\n}\n\nstatic int\nefct_device_interrupts_required(struct efct *efct)\n{\n\tint rc;\n\n\trc = efct_hw_setup(&efct->hw, efct, efct->pci);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn efct->hw.config.n_eq;\n}\n\nstatic irqreturn_t\nefct_intr_thread(int irq, void *handle)\n{\n\tstruct efct_intr_context *intr_ctx = handle;\n\tstruct efct *efct = intr_ctx->efct;\n\n\tefct_hw_process(&efct->hw, intr_ctx->index, efct->max_isr_time_msec);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t\nefct_intr_msix(int irq, void *handle)\n{\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int\nefct_setup_msix(struct efct *efct, u32 num_intrs)\n{\n\tint rc = 0, i;\n\n\tif (!pci_find_capability(efct->pci, PCI_CAP_ID_MSIX)) {\n\t\tdev_err(&efct->pci->dev,\n\t\t\t\"%s : MSI-X not available\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tefct->n_msix_vec = num_intrs;\n\n\trc = pci_alloc_irq_vectors(efct->pci, num_intrs, num_intrs,\n\t\t\t\t   PCI_IRQ_MSIX | PCI_IRQ_AFFINITY);\n\n\tif (rc < 0) {\n\t\tdev_err(&efct->pci->dev, \"Failed to alloc irq : %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tfor (i = 0; i < num_intrs; i++) {\n\t\tstruct efct_intr_context *intr_ctx = NULL;\n\n\t\tintr_ctx = &efct->intr_context[i];\n\t\tintr_ctx->efct = efct;\n\t\tintr_ctx->index = i;\n\n\t\trc = request_threaded_irq(pci_irq_vector(efct->pci, i),\n\t\t\t\t\t  efct_intr_msix, efct_intr_thread, 0,\n\t\t\t\t\t  EFCT_DRIVER_NAME, intr_ctx);\n\t\tif (rc) {\n\t\t\tdev_err(&efct->pci->dev,\n\t\t\t\t\"Failed to register %d vector: %d\\n\", i, rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn rc;\n\nout:\n\twhile (--i >= 0)\n\t\tfree_irq(pci_irq_vector(efct->pci, i),\n\t\t\t &efct->intr_context[i]);\n\n\tpci_free_irq_vectors(efct->pci);\n\treturn rc;\n}\n\nstatic struct pci_device_id efct_pci_table[] = {\n\t{PCI_DEVICE(EFCT_VENDOR_ID, EFCT_DEVICE_LANCER_G6), 0},\n\t{PCI_DEVICE(EFCT_VENDOR_ID, EFCT_DEVICE_LANCER_G7), 0},\n\t{}\t \n};\n\nstatic int\nefct_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct efct *efct = NULL;\n\tint rc;\n\tu32 i, r;\n\tint num_interrupts = 0;\n\tint nid;\n\n\tdev_info(&pdev->dev, \"%s\\n\", EFCT_DRIVER_NAME);\n\n\trc = pci_enable_device_mem(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_set_master(pdev);\n\n\trc = pci_set_mwi(pdev);\n\tif (rc) {\n\t\tdev_info(&pdev->dev, \"pci_set_mwi returned %d\\n\", rc);\n\t\tgoto mwi_out;\n\t}\n\n\trc = pci_request_regions(pdev, EFCT_DRIVER_NAME);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"pci_request_regions failed %d\\n\", rc);\n\t\tgoto req_regions_out;\n\t}\n\n\t \n\tnid = dev_to_node(&pdev->dev);\n\tif (nid < 0) {\n\t\tdev_err(&pdev->dev, \"Warning Numa node ID is %d\\n\", nid);\n\t\tnid = 0;\n\t}\n\n\t \n\tefct = efct_device_alloc(nid);\n\tif (!efct) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate efct\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto alloc_out;\n\t}\n\n\tefct->pci = pdev;\n\tefct->numa_node = nid;\n\n\t \n\tfor (i = 0, r = 0; i < EFCT_PCI_MAX_REGS; i++) {\n\t\tif (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {\n\t\t\tefct->reg[r] = ioremap(pci_resource_start(pdev, i),\n\t\t\t\t\t       pci_resource_len(pdev, i));\n\t\t\tr++;\n\t\t}\n\n\t\t \n\t\tif (pci_resource_flags(pdev, i) & IORESOURCE_MEM_64)\n\t\t\ti++;\n\t}\n\n\tpci_set_drvdata(pdev, efct);\n\n\trc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"setting DMA_BIT_MASK failed\\n\");\n\t\tgoto dma_mask_out;\n\t}\n\n\tnum_interrupts = efct_device_interrupts_required(efct);\n\tif (num_interrupts < 0) {\n\t\tefc_log_err(efct, \"efct_device_interrupts_required failed\\n\");\n\t\trc = -1;\n\t\tgoto dma_mask_out;\n\t}\n\n\t \n\trc = efct_setup_msix(efct, num_interrupts);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Can't setup msix\\n\");\n\t\tgoto dma_mask_out;\n\t}\n\t \n\tfor (i = 0; i < efct->n_msix_vec; i++) {\n\t\tefc_log_debug(efct, \"irq %d disabled\\n\", i);\n\t\tdisable_irq(pci_irq_vector(efct->pci, i));\n\t}\n\n\trc = efct_device_attach(efct);\n\tif (rc)\n\t\tgoto attach_out;\n\n\treturn 0;\n\nattach_out:\n\tefct_teardown_msix(efct);\ndma_mask_out:\n\tpci_set_drvdata(pdev, NULL);\n\n\tfor (i = 0; i < EFCT_PCI_MAX_REGS; i++) {\n\t\tif (efct->reg[i])\n\t\t\tiounmap(efct->reg[i]);\n\t}\n\tefct_device_free(efct);\nalloc_out:\n\tpci_release_regions(pdev);\nreq_regions_out:\n\tpci_clear_mwi(pdev);\nmwi_out:\n\tpci_disable_device(pdev);\n\treturn rc;\n}\n\nstatic void\nefct_pci_remove(struct pci_dev *pdev)\n{\n\tstruct efct *efct = pci_get_drvdata(pdev);\n\tu32 i;\n\n\tif (!efct)\n\t\treturn;\n\n\tefct_device_detach(efct);\n\n\tefct_teardown_msix(efct);\n\n\tfor (i = 0; i < EFCT_PCI_MAX_REGS; i++) {\n\t\tif (efct->reg[i])\n\t\t\tiounmap(efct->reg[i]);\n\t}\n\n\tpci_set_drvdata(pdev, NULL);\n\n\tefct_device_free(efct);\n\n\tpci_release_regions(pdev);\n\n\tpci_disable_device(pdev);\n}\n\nstatic void\nefct_device_prep_for_reset(struct efct *efct, struct pci_dev *pdev)\n{\n\tif (efct) {\n\t\tefc_log_debug(efct,\n\t\t\t      \"PCI channel disable preparing for reset\\n\");\n\t\tefct_device_detach(efct);\n\t\t \n\t\tefct_teardown_msix(efct);\n\t}\n\tpci_disable_device(pdev);\n}\n\nstatic void\nefct_device_prep_for_recover(struct efct *efct)\n{\n\tif (efct) {\n\t\tefc_log_debug(efct, \"PCI channel preparing for recovery\\n\");\n\t\tefct_hw_io_abort_all(&efct->hw);\n\t}\n}\n\n \nstatic pci_ers_result_t\nefct_pci_io_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct efct *efct = pci_get_drvdata(pdev);\n\tpci_ers_result_t rc;\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\tefct_device_prep_for_recover(efct);\n\t\trc = PCI_ERS_RESULT_CAN_RECOVER;\n\t\tbreak;\n\tcase pci_channel_io_frozen:\n\t\tefct_device_prep_for_reset(efct, pdev);\n\t\trc = PCI_ERS_RESULT_NEED_RESET;\n\t\tbreak;\n\tcase pci_channel_io_perm_failure:\n\t\tefct_device_detach(efct);\n\t\trc = PCI_ERS_RESULT_DISCONNECT;\n\t\tbreak;\n\tdefault:\n\t\tefc_log_debug(efct, \"Unknown PCI error state:0x%x\\n\", state);\n\t\tefct_device_prep_for_reset(efct, pdev);\n\t\trc = PCI_ERS_RESULT_NEED_RESET;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic pci_ers_result_t\nefct_pci_io_slot_reset(struct pci_dev *pdev)\n{\n\tint rc;\n\tstruct efct *efct = pci_get_drvdata(pdev);\n\n\trc = pci_enable_device_mem(pdev);\n\tif (rc) {\n\t\tefc_log_err(efct, \"failed to enable PCI device after reset\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\t \n\n\tpci_save_state(pdev);\n\n\tpci_set_master(pdev);\n\n\trc = efct_setup_msix(efct, efct->n_msix_vec);\n\tif (rc)\n\t\tefc_log_err(efct, \"rc %d returned, IRQ allocation failed\\n\",\n\t\t\t    rc);\n\n\t \n\tefct_device_detach(efct);\n\t \n\tefct_device_attach(efct);\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic void\nefct_pci_io_resume(struct pci_dev *pdev)\n{\n\tstruct efct *efct = pci_get_drvdata(pdev);\n\n\t \n\tefct_device_detach(efct);\n\t \n\tefct_device_attach(efct);\n}\n\nMODULE_DEVICE_TABLE(pci, efct_pci_table);\n\nstatic struct pci_error_handlers efct_pci_err_handler = {\n\t.error_detected = efct_pci_io_error_detected,\n\t.slot_reset = efct_pci_io_slot_reset,\n\t.resume = efct_pci_io_resume,\n};\n\nstatic struct pci_driver efct_pci_driver = {\n\t.name\t\t= EFCT_DRIVER_NAME,\n\t.id_table\t= efct_pci_table,\n\t.probe\t\t= efct_pci_probe,\n\t.remove\t\t= efct_pci_remove,\n\t.err_handler\t= &efct_pci_err_handler,\n};\n\nstatic\nint __init efct_init(void)\n{\n\tint rc;\n\n\trc = efct_device_init();\n\tif (rc) {\n\t\tpr_err(\"efct_device_init failed rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = pci_register_driver(&efct_pci_driver);\n\tif (rc) {\n\t\tpr_err(\"pci_register_driver failed rc=%d\\n\", rc);\n\t\tefct_device_shutdown();\n\t}\n\n\treturn rc;\n}\n\nstatic void __exit efct_exit(void)\n{\n\tpci_unregister_driver(&efct_pci_driver);\n\tefct_device_shutdown();\n}\n\nmodule_init(efct_init);\nmodule_exit(efct_exit);\nMODULE_VERSION(EFCT_DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Broadcom\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}