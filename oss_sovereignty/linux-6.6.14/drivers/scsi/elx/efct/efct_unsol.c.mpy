{
  "module_name": "efct_unsol.c",
  "hash_id": "23a0b8f4b7e05086ba8e854dce53b323fb2217b8173216ad640a01bafbfcd4a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/efct/efct_unsol.c",
  "human_readable_source": "\n \n\n#include \"efct_driver.h\"\n#include \"efct_unsol.h\"\n\n#define frame_printf(efct, hdr, fmt, ...) \\\n\tdo { \\\n\t\tchar s_id_text[16]; \\\n\t\tefc_node_fcid_display(ntoh24((hdr)->fh_s_id), \\\n\t\t\ts_id_text, sizeof(s_id_text)); \\\n\t\tefc_log_debug(efct, \"[%06x.%s] %02x/%04x/%04x: \" fmt, \\\n\t\t\tntoh24((hdr)->fh_d_id), s_id_text, \\\n\t\t\t(hdr)->fh_r_ctl, be16_to_cpu((hdr)->fh_ox_id), \\\n\t\t\tbe16_to_cpu((hdr)->fh_rx_id), ##__VA_ARGS__); \\\n\t} while (0)\n\nstatic struct efct_node *\nefct_node_find(struct efct *efct, u32 port_id, u32 node_id)\n{\n\tstruct efct_node *node;\n\tu64 id = (u64)port_id << 32 | node_id;\n\n\t \n\t \n\tnode = xa_load(&efct->lookup, id);\n\tif (node)\n\t\tkref_get(&node->ref);\n\n\treturn node;\n}\n\nstatic int\nefct_dispatch_frame(struct efct *efct, struct efc_hw_sequence *seq)\n{\n\tstruct efct_node *node;\n\tstruct fc_frame_header *hdr;\n\tu32 s_id, d_id;\n\n\thdr = seq->header->dma.virt;\n\n\t \n\ts_id = ntoh24(hdr->fh_s_id);\n\td_id = ntoh24(hdr->fh_d_id);\n\n\tif (!(hdr->fh_type == FC_TYPE_FCP || hdr->fh_type == FC_TYPE_BLS))\n\t\treturn -EIO;\n\n\tif (hdr->fh_type == FC_TYPE_FCP) {\n\t\tnode = efct_node_find(efct, d_id, s_id);\n\t\tif (!node) {\n\t\t\tefc_log_err(efct,\n\t\t\t\t    \"Node not found, drop cmd d_id:%x s_id:%x\\n\",\n\t\t\t\t    d_id, s_id);\n\t\t\tefct_hw_sequence_free(&efct->hw, seq);\n\t\t\treturn 0;\n\t\t}\n\n\t\tefct_dispatch_fcp_cmd(node, seq);\n\t} else {\n\t\tnode = efct_node_find(efct, d_id, s_id);\n\t\tif (!node) {\n\t\t\tefc_log_err(efct, \"ABTS: Node not found, d_id:%x s_id:%x\\n\",\n\t\t\t\t    d_id, s_id);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tefc_log_err(efct, \"Received ABTS for Node:%p\\n\", node);\n\t\tefct_node_recv_abts_frame(node, seq);\n\t}\n\n\tkref_put(&node->ref, node->release);\n\tefct_hw_sequence_free(&efct->hw, seq);\n\treturn 0;\n}\n\nint\nefct_unsolicited_cb(void *arg, struct efc_hw_sequence *seq)\n{\n\tstruct efct *efct = arg;\n\n\t \n\tif (!efct_dispatch_frame(efct, seq))\n\t\treturn 0;\n\n\t \n\tefc_dispatch_frame(efct->efcport, seq);\n\treturn 0;\n}\n\nstatic int\nefct_fc_tmf_rejected_cb(struct efct_io *io,\n\t\t\tenum efct_scsi_io_status scsi_status,\n\t\t\tu32 flags, void *arg)\n{\n\tefct_scsi_io_free(io);\n\treturn 0;\n}\n\nstatic void\nefct_dispatch_unsol_tmf(struct efct_io *io, u8 tm_flags, u32 lun)\n{\n\tu32 i;\n\tstruct {\n\t\tu32 mask;\n\t\tenum efct_scsi_tmf_cmd cmd;\n\t} tmflist[] = {\n\t{FCP_TMF_ABT_TASK_SET, EFCT_SCSI_TMF_ABORT_TASK_SET},\n\t{FCP_TMF_CLR_TASK_SET, EFCT_SCSI_TMF_CLEAR_TASK_SET},\n\t{FCP_TMF_LUN_RESET, EFCT_SCSI_TMF_LOGICAL_UNIT_RESET},\n\t{FCP_TMF_TGT_RESET, EFCT_SCSI_TMF_TARGET_RESET},\n\t{FCP_TMF_CLR_ACA, EFCT_SCSI_TMF_CLEAR_ACA} };\n\n\tio->exp_xfer_len = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(tmflist); i++) {\n\t\tif (tmflist[i].mask & tm_flags) {\n\t\t\tio->tmf_cmd = tmflist[i].cmd;\n\t\t\tefct_scsi_recv_tmf(io, lun, tmflist[i].cmd, NULL, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(tmflist)) {\n\t\t \n\t\tefc_log_err(io->node->efct, \"TMF x%x rejected\\n\", tm_flags);\n\t\tefct_scsi_send_tmf_resp(io, EFCT_SCSI_TMF_FUNCTION_REJECTED,\n\t\t\t\t\tNULL, efct_fc_tmf_rejected_cb, NULL);\n\t}\n}\n\nstatic int\nefct_validate_fcp_cmd(struct efct *efct, struct efc_hw_sequence *seq)\n{\n\t \n\tif (seq->payload->dma.len < sizeof(struct fcp_cmnd)) {\n\t\tstruct fc_frame_header\t*fchdr = seq->header->dma.virt;\n\n\t\tefc_log_debug(efct,\n\t\t\t      \"drop ox_id %04x payload (%zd) less than (%zd)\\n\",\n\t\t\t      be16_to_cpu(fchdr->fh_ox_id),\n\t\t\t      seq->payload->dma.len, sizeof(struct fcp_cmnd));\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void\nefct_populate_io_fcp_cmd(struct efct_io *io, struct fcp_cmnd *cmnd,\n\t\t\t struct fc_frame_header *fchdr, bool sit)\n{\n\tio->init_task_tag = be16_to_cpu(fchdr->fh_ox_id);\n\t \n\tio->exp_xfer_len = be32_to_cpu(cmnd->fc_dl);\n\tio->transferred = 0;\n\n\t \n\tif (ntoh24(fchdr->fh_f_ctl) & FC_FC_RES_B17)\n\t\tio->cs_ctl = fchdr->fh_cs_ctl;\n\telse\n\t\tio->cs_ctl = 0;\n\n\tio->seq_init = sit;\n}\n\nstatic u32\nefct_get_flags_fcp_cmd(struct fcp_cmnd *cmnd)\n{\n\tu32 flags = 0;\n\n\tswitch (cmnd->fc_pri_ta & FCP_PTA_MASK) {\n\tcase FCP_PTA_SIMPLE:\n\t\tflags |= EFCT_SCSI_CMD_SIMPLE;\n\t\tbreak;\n\tcase FCP_PTA_HEADQ:\n\t\tflags |= EFCT_SCSI_CMD_HEAD_OF_QUEUE;\n\t\tbreak;\n\tcase FCP_PTA_ORDERED:\n\t\tflags |= EFCT_SCSI_CMD_ORDERED;\n\t\tbreak;\n\tcase FCP_PTA_ACA:\n\t\tflags |= EFCT_SCSI_CMD_ACA;\n\t\tbreak;\n\t}\n\tif (cmnd->fc_flags & FCP_CFL_WRDATA)\n\t\tflags |= EFCT_SCSI_CMD_DIR_IN;\n\tif (cmnd->fc_flags & FCP_CFL_RDDATA)\n\t\tflags |= EFCT_SCSI_CMD_DIR_OUT;\n\n\treturn flags;\n}\n\nstatic void\nefct_sframe_common_send_cb(void *arg, u8 *cqe, int status)\n{\n\tstruct efct_hw_send_frame_context *ctx = arg;\n\tstruct efct_hw *hw = ctx->hw;\n\n\t \n\tefct_hw_reqtag_free(hw, ctx->wqcb);\n\n\t \n\tefct_hw_sequence_free(hw, ctx->seq);\n}\n\nstatic int\nefct_sframe_common_send(struct efct_node *node,\n\t\t\tstruct efc_hw_sequence *seq,\n\t\t\tenum fc_rctl r_ctl, u32 f_ctl,\n\t\t\tu8 type, void *payload, u32 payload_len)\n{\n\tstruct efct *efct = node->efct;\n\tstruct efct_hw *hw = &efct->hw;\n\tint rc = 0;\n\tstruct fc_frame_header *req_hdr = seq->header->dma.virt;\n\tstruct fc_frame_header hdr;\n\tstruct efct_hw_send_frame_context *ctx;\n\n\tu32 heap_size = seq->payload->dma.size;\n\tuintptr_t heap_phys_base = seq->payload->dma.phys;\n\tu8 *heap_virt_base = seq->payload->dma.virt;\n\tu32 heap_offset = 0;\n\n\t \n\tmemset(&hdr, 0, sizeof(hdr));\n\thdr.fh_r_ctl = r_ctl;\n\t \n\tmemcpy(hdr.fh_d_id, req_hdr->fh_s_id, sizeof(hdr.fh_d_id));\n\tmemcpy(hdr.fh_s_id, req_hdr->fh_d_id, sizeof(hdr.fh_s_id));\n\thdr.fh_type = type;\n\thton24(hdr.fh_f_ctl, f_ctl);\n\thdr.fh_ox_id = req_hdr->fh_ox_id;\n\thdr.fh_rx_id = req_hdr->fh_rx_id;\n\thdr.fh_cs_ctl = 0;\n\thdr.fh_df_ctl = 0;\n\thdr.fh_seq_cnt = 0;\n\thdr.fh_parm_offset = 0;\n\n\t \n\thdr.fh_seq_id = (u8)atomic_add_return(1, &hw->send_frame_seq_id);\n\thdr.fh_seq_id--;\n\n\t \n\tctx = (void *)(heap_virt_base + heap_offset);\n\theap_offset += sizeof(*ctx);\n\tif (heap_offset > heap_size) {\n\t\tefc_log_err(efct, \"Fill send frame failed offset %d size %d\\n\",\n\t\t\t    heap_offset, heap_size);\n\t\treturn -EIO;\n\t}\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\n\t \n\tctx->seq = seq;\n\n\t \n\tctx->payload.phys = heap_phys_base + heap_offset;\n\tctx->payload.virt = heap_virt_base + heap_offset;\n\tctx->payload.size = payload_len;\n\tctx->payload.len = payload_len;\n\theap_offset += payload_len;\n\tif (heap_offset > heap_size) {\n\t\tefc_log_err(efct, \"Fill send frame failed offset %d size %d\\n\",\n\t\t\t    heap_offset, heap_size);\n\t\treturn -EIO;\n\t}\n\n\t \n\tmemcpy(ctx->payload.virt, payload, payload_len);\n\n\t \n\trc = efct_hw_send_frame(&efct->hw, (void *)&hdr, FC_SOF_N3,\n\t\t\t\tFC_EOF_T, &ctx->payload, ctx,\n\t\t\t\tefct_sframe_common_send_cb, ctx);\n\tif (rc)\n\t\tefc_log_debug(efct, \"efct_hw_send_frame failed: %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int\nefct_sframe_send_fcp_rsp(struct efct_node *node, struct efc_hw_sequence *seq,\n\t\t\t void *rsp, u32 rsp_len)\n{\n\treturn efct_sframe_common_send(node, seq, FC_RCTL_DD_CMD_STATUS,\n\t\t\t\t      FC_FC_EX_CTX |\n\t\t\t\t      FC_FC_LAST_SEQ |\n\t\t\t\t      FC_FC_END_SEQ |\n\t\t\t\t      FC_FC_SEQ_INIT,\n\t\t\t\t      FC_TYPE_FCP,\n\t\t\t\t      rsp, rsp_len);\n}\n\nstatic int\nefct_sframe_send_task_set_full_or_busy(struct efct_node *node,\n\t\t\t\t       struct efc_hw_sequence *seq)\n{\n\tstruct fcp_resp_with_ext fcprsp;\n\tstruct fcp_cmnd *fcpcmd = seq->payload->dma.virt;\n\tint rc = 0;\n\tunsigned long flags = 0;\n\tstruct efct *efct = node->efct;\n\n\t \n\tmemset(&fcprsp, 0, sizeof(fcprsp));\n\tspin_lock_irqsave(&node->active_ios_lock, flags);\n\tfcprsp.resp.fr_status = list_empty(&node->active_ios) ?\n\t\t\t\tSAM_STAT_BUSY : SAM_STAT_TASK_SET_FULL;\n\tspin_unlock_irqrestore(&node->active_ios_lock, flags);\n\t*((u32 *)&fcprsp.ext.fr_resid) = be32_to_cpu(fcpcmd->fc_dl);\n\n\t \n\trc = efct_sframe_send_fcp_rsp(node, seq, &fcprsp, sizeof(fcprsp));\n\tif (rc)\n\t\tefc_log_debug(efct, \"efct_sframe_send_fcp_rsp failed %d\\n\", rc);\n\n\treturn rc;\n}\n\nint\nefct_dispatch_fcp_cmd(struct efct_node *node, struct efc_hw_sequence *seq)\n{\n\tstruct efct *efct = node->efct;\n\tstruct fc_frame_header *fchdr = seq->header->dma.virt;\n\tstruct fcp_cmnd\t*cmnd = NULL;\n\tstruct efct_io *io = NULL;\n\tu32 lun;\n\n\tif (!seq->payload) {\n\t\tefc_log_err(efct, \"Sequence payload is NULL.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tcmnd = seq->payload->dma.virt;\n\n\t \n\tif (efct_validate_fcp_cmd(efct, seq))\n\t\treturn -EIO;\n\n\tlun = scsilun_to_int(&cmnd->fc_lun);\n\tif (lun == U32_MAX)\n\t\treturn -EIO;\n\n\tio = efct_scsi_io_alloc(node);\n\tif (!io) {\n\t\tint rc;\n\n\t\t \n\t\trc = efct_sframe_send_task_set_full_or_busy(node, seq);\n\t\tif (rc)\n\t\t\tefc_log_err(efct, \"Failed to send busy task: %d\\n\", rc);\n\n\t\treturn rc;\n\t}\n\n\tio->hw_priv = seq->hw_priv;\n\n\tio->app_id = 0;\n\n\t \n\tefct_populate_io_fcp_cmd(io, cmnd, fchdr, true);\n\n\tif (cmnd->fc_tm_flags) {\n\t\tefct_dispatch_unsol_tmf(io, cmnd->fc_tm_flags, lun);\n\t} else {\n\t\tu32 flags = efct_get_flags_fcp_cmd(cmnd);\n\n\t\tif (cmnd->fc_flags & FCP_CFL_LEN_MASK) {\n\t\t\tefc_log_err(efct, \"Additional CDB not supported\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t \n\t\tefct_scsi_recv_cmd(io, lun, cmnd->fc_cdb,\n\t\t\t\t   sizeof(cmnd->fc_cdb), flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nefct_process_abts(struct efct_io *io, struct fc_frame_header *hdr)\n{\n\tstruct efct_node *node = io->node;\n\tstruct efct *efct = io->efct;\n\tu16 ox_id = be16_to_cpu(hdr->fh_ox_id);\n\tu16 rx_id = be16_to_cpu(hdr->fh_rx_id);\n\tstruct efct_io *abortio;\n\n\t \n\tabortio = efct_io_find_tgt_io(efct, node, ox_id, rx_id);\n\n\tif (abortio) {\n\t\t \n\t\tefc_log_info(node->efct, \"Abort ox_id [%04x] rx_id [%04x]\\n\",\n\t\t\t     ox_id, rx_id);\n\n\t\t \n\t\tio->display_name = \"abts\";\n\t\tio->init_task_tag = ox_id;\n\t\t \n\n\t\t \n\t\tio->abort_rx_id = rx_id;\n\n\t\t \n\t\tio->tmf_cmd = EFCT_SCSI_TMF_ABORT_TASK;\n\t\tefct_scsi_recv_tmf(io, abortio->tgt_io.lun,\n\t\t\t\t   EFCT_SCSI_TMF_ABORT_TASK, abortio, 0);\n\n\t\t \n\t\tkref_put(&abortio->ref, abortio->release);\n\t} else {\n\t\t \n\t\tefc_log_info(node->efct, \"Abort: ox_id [%04x], IO not found\\n\",\n\t\t\t     ox_id);\n\n\t\t \n\t\tefct_bls_send_rjt(io, hdr);\n\t}\n\treturn 0;\n}\n\nint\nefct_node_recv_abts_frame(struct efct_node *node, struct efc_hw_sequence *seq)\n{\n\tstruct efct *efct = node->efct;\n\tstruct fc_frame_header *hdr = seq->header->dma.virt;\n\tstruct efct_io *io = NULL;\n\n\tnode->abort_cnt++;\n\tio = efct_scsi_io_alloc(node);\n\tif (io) {\n\t\tio->hw_priv = seq->hw_priv;\n\t\t \n\t\tio->seq_init = 1;\n\n\t\t \n\t\tio->efct = efct;\n\t\tio->node = node;\n\t\tio->cmd_tgt = true;\n\n\t\tefct_process_abts(io, seq->header->dma.virt);\n\t} else {\n\t\tefc_log_err(efct,\n\t\t\t    \"SCSI IO allocation failed for ABTS received \");\n\t\tefc_log_err(efct, \"s_id %06x d_id %06x ox_id %04x rx_id %04x\\n\",\n\t\t\t    ntoh24(hdr->fh_s_id), ntoh24(hdr->fh_d_id),\n\t\t\t    be16_to_cpu(hdr->fh_ox_id),\n\t\t\t    be16_to_cpu(hdr->fh_rx_id));\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}