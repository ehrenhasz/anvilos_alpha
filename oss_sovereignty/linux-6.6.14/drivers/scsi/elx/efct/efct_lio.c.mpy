{
  "module_name": "efct_lio.c",
  "hash_id": "64f2c03fd3477ada267362b7726f0b3c4922cc7223f5de04923e14d665e0c159",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/efct/efct_lio.c",
  "human_readable_source": "\n \n\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include \"efct_driver.h\"\n#include \"efct_lio.h\"\n\n \nstatic struct workqueue_struct *lio_wq;\n\nstatic int\nefct_format_wwn(char *str, size_t len, const char *pre, u64 wwn)\n{\n\tu8 a[8];\n\n\tput_unaligned_be64(wwn, a);\n\treturn snprintf(str, len, \"%s%8phC\", pre, a);\n}\n\nstatic int\nefct_lio_parse_wwn(const char *name, u64 *wwp, u8 npiv)\n{\n\tint num;\n\tu8 b[8];\n\n\tif (npiv) {\n\t\tnum = sscanf(name,\n\t\t\t     \"%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\",\n\t\t\t     &b[0], &b[1], &b[2], &b[3], &b[4], &b[5], &b[6],\n\t\t\t     &b[7]);\n\t} else {\n\t\tnum = sscanf(name,\n\t\t      \"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx\",\n\t\t\t     &b[0], &b[1], &b[2], &b[3], &b[4], &b[5], &b[6],\n\t\t\t     &b[7]);\n\t}\n\n\tif (num != 8)\n\t\treturn -EINVAL;\n\n\t*wwp = get_unaligned_be64(b);\n\treturn 0;\n}\n\nstatic int\nefct_lio_parse_npiv_wwn(const char *name, size_t size, u64 *wwpn, u64 *wwnn)\n{\n\tunsigned int cnt = size;\n\tint rc;\n\n\t*wwpn = *wwnn = 0;\n\tif (name[cnt - 1] == '\\n' || name[cnt - 1] == 0)\n\t\tcnt--;\n\n\t \n\tif ((cnt != (16 + 1 + 16)) || (name[16] != ':'))\n\t\treturn -EINVAL;\n\n\trc = efct_lio_parse_wwn(&name[0], wwpn, 1);\n\tif (rc)\n\t\treturn rc;\n\n\trc = efct_lio_parse_wwn(&name[17], wwnn, 1);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic ssize_t\nefct_lio_tpg_enable_show(struct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", tpg->enabled);\n}\n\nstatic ssize_t\nefct_lio_tpg_enable_store(struct config_item *item, const char *page,\n\t\t\t  size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\tstruct efct *efct;\n\tstruct efc *efc;\n\tunsigned long op;\n\n\tif (!tpg->nport || !tpg->nport->efct) {\n\t\tpr_err(\"%s: Unable to find EFCT device\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tefct = tpg->nport->efct;\n\tefc = efct->efcport;\n\n\tif (kstrtoul(page, 0, &op) < 0)\n\t\treturn -EINVAL;\n\n\tif (op == 1) {\n\t\tint ret;\n\n\t\ttpg->enabled = true;\n\t\tefc_log_debug(efct, \"enable portal group %d\\n\", tpg->tpgt);\n\n\t\tret = efct_xport_control(efct->xport, EFCT_XPORT_PORT_ONLINE);\n\t\tif (ret) {\n\t\t\tefct->tgt_efct.lio_nport = NULL;\n\t\t\tefc_log_debug(efct, \"cannot bring port online\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else if (op == 0) {\n\t\tefc_log_debug(efct, \"disable portal group %d\\n\", tpg->tpgt);\n\n\t\tif (efc->domain && efc->domain->nport)\n\t\t\tefct_scsi_tgt_del_nport(efc, efc->domain->nport);\n\n\t\ttpg->enabled = false;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t\nefct_lio_npiv_tpg_enable_show(struct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", tpg->enabled);\n}\n\nstatic ssize_t\nefct_lio_npiv_tpg_enable_store(struct config_item *item, const char *page,\n\t\t\t       size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\tstruct efct_lio_vport *lio_vport = tpg->vport;\n\tstruct efct *efct;\n\tstruct efc *efc;\n\tunsigned long op;\n\n\tif (kstrtoul(page, 0, &op) < 0)\n\t\treturn -EINVAL;\n\n\tif (!lio_vport) {\n\t\tpr_err(\"Unable to find vport\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tefct = lio_vport->efct;\n\tefc = efct->efcport;\n\n\tif (op == 1) {\n\t\ttpg->enabled = true;\n\t\tefc_log_debug(efct, \"enable portal group %d\\n\", tpg->tpgt);\n\n\t\tif (efc->domain) {\n\t\t\tint ret;\n\n\t\t\tret = efc_nport_vport_new(efc->domain,\n\t\t\t\t\t\t  lio_vport->npiv_wwpn,\n\t\t\t\t\t\t  lio_vport->npiv_wwnn,\n\t\t\t\t\t\t  U32_MAX, false, true,\n\t\t\t\t\t\t  NULL, NULL);\n\t\t\tif (ret != 0) {\n\t\t\t\tefc_log_err(efct, \"Failed to create Vport\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tif (!(efc_vport_create_spec(efc, lio_vport->npiv_wwnn,\n\t\t\t\t\t    lio_vport->npiv_wwpn, U32_MAX,\n\t\t\t\t\t    false, true, NULL, NULL)))\n\t\t\treturn -ENOMEM;\n\n\t} else if (op == 0) {\n\t\tefc_log_debug(efct, \"disable portal group %d\\n\", tpg->tpgt);\n\n\t\ttpg->enabled = false;\n\t\t \n\t\tif (efc->domain) {\n\t\t\tefc_nport_vport_del(efct->efcport, efc->domain,\n\t\t\t\t\t    lio_vport->npiv_wwpn,\n\t\t\t\t\t    lio_vport->npiv_wwnn);\n\t\t\treturn count;\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n}\n\nstatic char *efct_lio_get_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->nport->wwpn_str;\n}\n\nstatic char *efct_lio_get_npiv_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->vport->wwpn_str;\n}\n\nstatic u16 efct_lio_get_tag(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->tpgt;\n}\n\nstatic u16 efct_lio_get_npiv_tag(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->tpgt;\n}\n\nstatic int efct_lio_check_demo_mode(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int efct_lio_check_demo_mode_cache(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic int efct_lio_check_demo_write_protect(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->tpg_attrib.demo_mode_write_protect;\n}\n\nstatic int\nefct_lio_npiv_check_demo_write_protect(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->tpg_attrib.demo_mode_write_protect;\n}\n\nstatic int efct_lio_check_prod_write_protect(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->tpg_attrib.prod_mode_write_protect;\n}\n\nstatic int\nefct_lio_npiv_check_prod_write_protect(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->tpg_attrib.prod_mode_write_protect;\n}\n\nstatic int efct_lio_check_stop_free(struct se_cmd *se_cmd)\n{\n\tstruct efct_scsi_tgt_io *ocp =\n\t\tcontainer_of(se_cmd, struct efct_scsi_tgt_io, cmd);\n\tstruct efct_io *io = container_of(ocp, struct efct_io, tgt_io);\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TFO_CHK_STOP_FREE);\n\treturn target_put_sess_cmd(se_cmd);\n}\n\nstatic int\nefct_lio_abort_tgt_cb(struct efct_io *io,\n\t\t      enum efct_scsi_io_status scsi_status,\n\t\t      u32 flags, void *arg)\n{\n\tefct_lio_io_printf(io, \"Abort done, status:%d\\n\", scsi_status);\n\treturn 0;\n}\n\nstatic void\nefct_lio_aborted_task(struct se_cmd *se_cmd)\n{\n\tstruct efct_scsi_tgt_io *ocp =\n\t\tcontainer_of(se_cmd, struct efct_scsi_tgt_io, cmd);\n\tstruct efct_io *io = container_of(ocp, struct efct_io, tgt_io);\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TFO_ABORTED_TASK);\n\n\tif (ocp->rsp_sent)\n\t\treturn;\n\n\t \n\tocp->aborting = true;\n\tocp->err = EFCT_SCSI_STATUS_ABORTED;\n\t \n\tefct_scsi_tgt_abort_io(io, efct_lio_abort_tgt_cb, NULL);\n}\n\nstatic void efct_lio_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct efct_scsi_tgt_io *ocp =\n\t\tcontainer_of(se_cmd, struct efct_scsi_tgt_io, cmd);\n\tstruct efct_io *io = container_of(ocp, struct efct_io, tgt_io);\n\tstruct efct *efct = io->efct;\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TFO_RELEASE_CMD);\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_SCSI_CMPL_CMD);\n\tefct_scsi_io_complete(io);\n\tatomic_sub_return(1, &efct->tgt_efct.ios_in_use);\n}\n\nstatic void efct_lio_close_session(struct se_session *se_sess)\n{\n\tstruct efc_node *node = se_sess->fabric_sess_ptr;\n\n\tpr_debug(\"se_sess=%p node=%p\", se_sess, node);\n\n\tif (!node) {\n\t\tpr_debug(\"node is NULL\");\n\t\treturn;\n\t}\n\n\tefc_node_post_shutdown(node, NULL);\n}\n\nstatic int efct_lio_get_cmd_state(struct se_cmd *cmd)\n{\n\tstruct efct_scsi_tgt_io *ocp =\n\t\tcontainer_of(cmd, struct efct_scsi_tgt_io, cmd);\n\tstruct efct_io *io = container_of(ocp, struct efct_io, tgt_io);\n\n\treturn io->tgt_io.state;\n}\n\nstatic int\nefct_lio_sg_map(struct efct_io *io)\n{\n\tstruct efct_scsi_tgt_io *ocp = &io->tgt_io;\n\tstruct se_cmd *cmd = &ocp->cmd;\n\n\tocp->seg_map_cnt = dma_map_sg(&io->efct->pci->dev, cmd->t_data_sg,\n\t\t\t\t      cmd->t_data_nents, cmd->data_direction);\n\tif (ocp->seg_map_cnt == 0)\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic void\nefct_lio_sg_unmap(struct efct_io *io)\n{\n\tstruct efct_scsi_tgt_io *ocp = &io->tgt_io;\n\tstruct se_cmd *cmd = &ocp->cmd;\n\n\tif (WARN_ON(!ocp->seg_map_cnt || !cmd->t_data_sg))\n\t\treturn;\n\n\tdma_unmap_sg(&io->efct->pci->dev, cmd->t_data_sg,\n\t\t     ocp->seg_map_cnt, cmd->data_direction);\n\tocp->seg_map_cnt = 0;\n}\n\nstatic int\nefct_lio_status_done(struct efct_io *io,\n\t\t     enum efct_scsi_io_status scsi_status,\n\t\t     u32 flags, void *arg)\n{\n\tstruct efct_scsi_tgt_io *ocp = &io->tgt_io;\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_SCSI_RSP_DONE);\n\tif (scsi_status != EFCT_SCSI_STATUS_GOOD) {\n\t\tefct_lio_io_printf(io, \"callback completed with error=%d\\n\",\n\t\t\t\t   scsi_status);\n\t\tocp->err = scsi_status;\n\t}\n\tif (ocp->seg_map_cnt)\n\t\tefct_lio_sg_unmap(io);\n\n\tefct_lio_io_printf(io, \"status=%d, err=%d flags=0x%x, dir=%d\\n\",\n\t\t\t   scsi_status, ocp->err, flags, ocp->ddir);\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TGT_GENERIC_FREE);\n\ttransport_generic_free_cmd(&io->tgt_io.cmd, 0);\n\treturn 0;\n}\n\nstatic int\nefct_lio_datamove_done(struct efct_io *io, enum efct_scsi_io_status scsi_status,\n\t\t       u32 flags, void *arg);\n\nstatic int\nefct_lio_write_pending(struct se_cmd *cmd)\n{\n\tstruct efct_scsi_tgt_io *ocp =\n\t\tcontainer_of(cmd, struct efct_scsi_tgt_io, cmd);\n\tstruct efct_io *io = container_of(ocp, struct efct_io, tgt_io);\n\tstruct efct_scsi_sgl *sgl = io->sgl;\n\tstruct scatterlist *sg;\n\tu32 flags = 0, cnt, curcnt;\n\tu64 length = 0;\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TFO_WRITE_PENDING);\n\tefct_lio_io_printf(io, \"trans_state=0x%x se_cmd_flags=0x%x\\n\",\n\t\t\t   cmd->transport_state, cmd->se_cmd_flags);\n\n\tif (ocp->seg_cnt == 0) {\n\t\tocp->seg_cnt = cmd->t_data_nents;\n\t\tocp->cur_seg = 0;\n\t\tif (efct_lio_sg_map(io)) {\n\t\t\tefct_lio_io_printf(io, \"efct_lio_sg_map failed\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tcurcnt = (ocp->seg_map_cnt - ocp->cur_seg);\n\tcurcnt = (curcnt < io->sgl_allocated) ? curcnt : io->sgl_allocated;\n\t \n\tfor (cnt = 0, sg = cmd->t_data_sg; cnt < ocp->cur_seg; cnt++,\n\t     sg = sg_next(sg))\n\t\t; \n\n\tfor (cnt = 0; cnt < curcnt; cnt++, sg = sg_next(sg)) {\n\t\tsgl[cnt].addr = sg_dma_address(sg);\n\t\tsgl[cnt].dif_addr = 0;\n\t\tsgl[cnt].len = sg_dma_len(sg);\n\t\tlength += sgl[cnt].len;\n\t\tocp->cur_seg++;\n\t}\n\n\tif (ocp->cur_seg == ocp->seg_cnt)\n\t\tflags = EFCT_SCSI_LAST_DATAPHASE;\n\n\treturn efct_scsi_recv_wr_data(io, flags, sgl, curcnt, length,\n\t\t\t\t    efct_lio_datamove_done, NULL);\n}\n\nstatic int\nefct_lio_queue_data_in(struct se_cmd *cmd)\n{\n\tstruct efct_scsi_tgt_io *ocp =\n\t\tcontainer_of(cmd, struct efct_scsi_tgt_io, cmd);\n\tstruct efct_io *io = container_of(ocp, struct efct_io, tgt_io);\n\tstruct efct_scsi_sgl *sgl = io->sgl;\n\tstruct scatterlist *sg = NULL;\n\tuint flags = 0, cnt = 0, curcnt = 0;\n\tu64 length = 0;\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TFO_QUEUE_DATA_IN);\n\n\tif (ocp->seg_cnt == 0) {\n\t\tif (cmd->data_length) {\n\t\t\tocp->seg_cnt = cmd->t_data_nents;\n\t\t\tocp->cur_seg = 0;\n\t\t\tif (efct_lio_sg_map(io)) {\n\t\t\t\tefct_lio_io_printf(io,\n\t\t\t\t\t\t   \"efct_lio_sg_map failed\\n\");\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tstruct efct_scsi_cmd_resp rsp;\n\n\t\t\tmemset(&rsp, 0, sizeof(rsp));\n\t\t\tefct_lio_io_printf(io,\n\t\t\t\t\t   \"cmd : %p length 0, send status\\n\",\n\t\t\t\t\t   cmd);\n\t\t\treturn efct_scsi_send_resp(io, 0, &rsp,\n\t\t\t\t\t\t   efct_lio_status_done, NULL);\n\t\t}\n\t}\n\tcurcnt = min(ocp->seg_map_cnt - ocp->cur_seg, io->sgl_allocated);\n\n\twhile (cnt < curcnt) {\n\t\tsg = &cmd->t_data_sg[ocp->cur_seg];\n\t\tsgl[cnt].addr = sg_dma_address(sg);\n\t\tsgl[cnt].dif_addr = 0;\n\t\tif (ocp->transferred_len + sg_dma_len(sg) >= cmd->data_length)\n\t\t\tsgl[cnt].len = cmd->data_length - ocp->transferred_len;\n\t\telse\n\t\t\tsgl[cnt].len = sg_dma_len(sg);\n\n\t\tocp->transferred_len += sgl[cnt].len;\n\t\tlength += sgl[cnt].len;\n\t\tocp->cur_seg++;\n\t\tcnt++;\n\t\tif (ocp->transferred_len == cmd->data_length)\n\t\t\tbreak;\n\t}\n\n\tif (ocp->transferred_len == cmd->data_length) {\n\t\tflags = EFCT_SCSI_LAST_DATAPHASE;\n\t\tocp->seg_cnt = ocp->cur_seg;\n\t}\n\n\t \n\tif (cmd->residual_count)\n\t\tflags |= EFCT_SCSI_NO_AUTO_RESPONSE;\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_SCSI_SEND_RD_DATA);\n\n\treturn efct_scsi_send_rd_data(io, flags, sgl, curcnt, length,\n\t\t\t\t    efct_lio_datamove_done, NULL);\n}\n\nstatic void\nefct_lio_send_resp(struct efct_io *io, enum efct_scsi_io_status scsi_status,\n\t\t   u32 flags)\n{\n\tstruct efct_scsi_cmd_resp rsp;\n\tstruct efct_scsi_tgt_io *ocp = &io->tgt_io;\n\tstruct se_cmd *cmd = &io->tgt_io.cmd;\n\tint rc;\n\n\tif (flags & EFCT_SCSI_IO_CMPL_RSP_SENT) {\n\t\tocp->rsp_sent = true;\n\t\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TGT_GENERIC_FREE);\n\t\ttransport_generic_free_cmd(&io->tgt_io.cmd, 0);\n\t\treturn;\n\t}\n\n\t \n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.scsi_status = cmd->scsi_status;\n\trsp.sense_data = (uint8_t *)io->tgt_io.sense_buffer;\n\trsp.sense_data_length = cmd->scsi_sense_length;\n\n\t \n\tif (cmd->se_cmd_flags & SCF_OVERFLOW_BIT)\n\t\trsp.residual = -cmd->residual_count;\n\telse if (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT)\n\t\trsp.residual = cmd->residual_count;\n\n\trc = efct_scsi_send_resp(io, 0, &rsp, efct_lio_status_done, NULL);\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_SCSI_SEND_RSP);\n\tif (rc != 0) {\n\t\tefct_lio_io_printf(io, \"Read done, send rsp failed %d\\n\", rc);\n\t\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TGT_GENERIC_FREE);\n\t\ttransport_generic_free_cmd(&io->tgt_io.cmd, 0);\n\t} else {\n\t\tocp->rsp_sent = true;\n\t}\n}\n\nstatic int\nefct_lio_datamove_done(struct efct_io *io, enum efct_scsi_io_status scsi_status,\n\t\t       u32 flags, void *arg)\n{\n\tstruct efct_scsi_tgt_io *ocp = &io->tgt_io;\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_SCSI_DATA_DONE);\n\tif (scsi_status != EFCT_SCSI_STATUS_GOOD) {\n\t\tefct_lio_io_printf(io, \"callback completed with error=%d\\n\",\n\t\t\t\t   scsi_status);\n\t\tocp->err = scsi_status;\n\t}\n\tefct_lio_io_printf(io, \"seg_map_cnt=%d\\n\", ocp->seg_map_cnt);\n\tif (ocp->seg_map_cnt) {\n\t\tif (ocp->err == EFCT_SCSI_STATUS_GOOD &&\n\t\t    ocp->cur_seg < ocp->seg_cnt) {\n\t\t\tint rc;\n\n\t\t\tefct_lio_io_printf(io, \"continuing cmd at segm=%d\\n\",\n\t\t\t\t\t   ocp->cur_seg);\n\t\t\tif (ocp->ddir == DMA_TO_DEVICE)\n\t\t\t\trc = efct_lio_write_pending(&ocp->cmd);\n\t\t\telse\n\t\t\t\trc = efct_lio_queue_data_in(&ocp->cmd);\n\t\t\tif (!rc)\n\t\t\t\treturn 0;\n\n\t\t\tocp->err = EFCT_SCSI_STATUS_ERROR;\n\t\t\tefct_lio_io_printf(io, \"could not continue command\\n\");\n\t\t}\n\t\tefct_lio_sg_unmap(io);\n\t}\n\n\tif (io->tgt_io.aborting) {\n\t\tefct_lio_io_printf(io, \"IO done aborted\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ocp->ddir == DMA_TO_DEVICE) {\n\t\tefct_lio_io_printf(io, \"Write done, trans_state=0x%x\\n\",\n\t\t\t\t   io->tgt_io.cmd.transport_state);\n\t\tif (scsi_status != EFCT_SCSI_STATUS_GOOD) {\n\t\t\ttransport_generic_request_failure(&io->tgt_io.cmd,\n\t\t\t\t\tTCM_CHECK_CONDITION_ABORT_CMD);\n\t\t\tefct_set_lio_io_state(io,\n\t\t\t\tEFCT_LIO_STATE_TGT_GENERIC_REQ_FAILURE);\n\t\t} else {\n\t\t\tefct_set_lio_io_state(io,\n\t\t\t\t\t\tEFCT_LIO_STATE_TGT_EXECUTE_CMD);\n\t\t\ttarget_execute_cmd(&io->tgt_io.cmd);\n\t\t}\n\t} else {\n\t\tefct_lio_send_resp(io, scsi_status, flags);\n\t}\n\treturn 0;\n}\n\nstatic int\nefct_lio_tmf_done(struct efct_io *io, enum efct_scsi_io_status scsi_status,\n\t\t  u32 flags, void *arg)\n{\n\tefct_lio_tmfio_printf(io, \"cmd=%p status=%d, flags=0x%x\\n\",\n\t\t\t      &io->tgt_io.cmd, scsi_status, flags);\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TGT_GENERIC_FREE);\n\ttransport_generic_free_cmd(&io->tgt_io.cmd, 0);\n\treturn 0;\n}\n\nstatic int\nefct_lio_null_tmf_done(struct efct_io *tmfio,\n\t\t       enum efct_scsi_io_status scsi_status,\n\t\t      u32 flags, void *arg)\n{\n\tefct_lio_tmfio_printf(tmfio, \"cmd=%p status=%d, flags=0x%x\\n\",\n\t\t\t      &tmfio->tgt_io.cmd, scsi_status, flags);\n\n\t \n\tefct_scsi_io_complete(tmfio);\n\treturn 0;\n}\n\nstatic int\nefct_lio_queue_status(struct se_cmd *cmd)\n{\n\tstruct efct_scsi_cmd_resp rsp;\n\tstruct efct_scsi_tgt_io *ocp =\n\t\tcontainer_of(cmd, struct efct_scsi_tgt_io, cmd);\n\tstruct efct_io *io = container_of(ocp, struct efct_io, tgt_io);\n\tint rc = 0;\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TFO_QUEUE_STATUS);\n\tefct_lio_io_printf(io,\n\t\t\"status=0x%x trans_state=0x%x se_cmd_flags=0x%x sns_len=%d\\n\",\n\t\tcmd->scsi_status, cmd->transport_state, cmd->se_cmd_flags,\n\t\tcmd->scsi_sense_length);\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.scsi_status = cmd->scsi_status;\n\trsp.sense_data = (u8 *)io->tgt_io.sense_buffer;\n\trsp.sense_data_length = cmd->scsi_sense_length;\n\n\t \n\tif (cmd->se_cmd_flags & SCF_OVERFLOW_BIT)\n\t\trsp.residual = -cmd->residual_count;\n\telse if (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT)\n\t\trsp.residual = cmd->residual_count;\n\n\trc = efct_scsi_send_resp(io, 0, &rsp, efct_lio_status_done, NULL);\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_SCSI_SEND_RSP);\n\tif (rc == 0)\n\t\tocp->rsp_sent = true;\n\treturn rc;\n}\n\nstatic void efct_lio_queue_tm_rsp(struct se_cmd *cmd)\n{\n\tstruct efct_scsi_tgt_io *ocp =\n\t\tcontainer_of(cmd, struct efct_scsi_tgt_io, cmd);\n\tstruct efct_io *tmfio = container_of(ocp, struct efct_io, tgt_io);\n\tstruct se_tmr_req *se_tmr = cmd->se_tmr_req;\n\tu8 rspcode;\n\n\tefct_lio_tmfio_printf(tmfio, \"cmd=%p function=0x%x tmr->response=%d\\n\",\n\t\t\t      cmd, se_tmr->function, se_tmr->response);\n\tswitch (se_tmr->response) {\n\tcase TMR_FUNCTION_COMPLETE:\n\t\trspcode = EFCT_SCSI_TMF_FUNCTION_COMPLETE;\n\t\tbreak;\n\tcase TMR_TASK_DOES_NOT_EXIST:\n\t\trspcode = EFCT_SCSI_TMF_FUNCTION_IO_NOT_FOUND;\n\t\tbreak;\n\tcase TMR_LUN_DOES_NOT_EXIST:\n\t\trspcode = EFCT_SCSI_TMF_INCORRECT_LOGICAL_UNIT_NUMBER;\n\t\tbreak;\n\tcase TMR_FUNCTION_REJECTED:\n\tdefault:\n\t\trspcode = EFCT_SCSI_TMF_FUNCTION_REJECTED;\n\t\tbreak;\n\t}\n\tefct_scsi_send_tmf_resp(tmfio, rspcode, NULL, efct_lio_tmf_done, NULL);\n}\n\nstatic struct efct *efct_find_wwpn(u64 wwpn)\n{\n\tstruct efct *efct;\n\n\t  \n\tlist_for_each_entry(efct, &efct_devices, list_entry) {\n\n\t\tif (wwpn == efct_get_wwpn(&efct->hw))\n\t\t\treturn efct;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct se_wwn *\nefct_lio_make_nport(struct target_fabric_configfs *tf,\n\t\t    struct config_group *group, const char *name)\n{\n\tstruct efct_lio_nport *lio_nport;\n\tstruct efct *efct;\n\tint ret;\n\tu64 wwpn;\n\n\tret = efct_lio_parse_wwn(name, &wwpn, 0);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tefct = efct_find_wwpn(wwpn);\n\tif (!efct) {\n\t\tpr_err(\"cannot find EFCT for base wwpn %s\\n\", name);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tlio_nport = kzalloc(sizeof(*lio_nport), GFP_KERNEL);\n\tif (!lio_nport)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlio_nport->efct = efct;\n\tlio_nport->wwpn = wwpn;\n\tefct_format_wwn(lio_nport->wwpn_str, sizeof(lio_nport->wwpn_str),\n\t\t\t\"naa.\", wwpn);\n\tefct->tgt_efct.lio_nport = lio_nport;\n\n\treturn &lio_nport->nport_wwn;\n}\n\nstatic struct se_wwn *\nefct_lio_npiv_make_nport(struct target_fabric_configfs *tf,\n\t\t\t struct config_group *group, const char *name)\n{\n\tstruct efct_lio_vport *lio_vport;\n\tstruct efct *efct;\n\tint ret;\n\tu64 p_wwpn, npiv_wwpn, npiv_wwnn;\n\tchar *p, *pbuf, tmp[128];\n\tstruct efct_lio_vport_list_t *vport_list;\n\tstruct fc_vport *new_fc_vport;\n\tstruct fc_vport_identifiers vport_id;\n\tunsigned long flags = 0;\n\n\tsnprintf(tmp, sizeof(tmp), \"%s\", name);\n\tpbuf = &tmp[0];\n\n\tp = strsep(&pbuf, \"@\");\n\n\tif (!p || !pbuf) {\n\t\tpr_err(\"Unable to find separator operator(@)\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = efct_lio_parse_wwn(p, &p_wwpn, 0);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = efct_lio_parse_npiv_wwn(pbuf, strlen(pbuf), &npiv_wwpn,\n\t\t\t\t      &npiv_wwnn);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tefct = efct_find_wwpn(p_wwpn);\n\tif (!efct) {\n\t\tpr_err(\"cannot find EFCT for base wwpn %s\\n\", name);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tlio_vport = kzalloc(sizeof(*lio_vport), GFP_KERNEL);\n\tif (!lio_vport)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlio_vport->efct = efct;\n\tlio_vport->wwpn = p_wwpn;\n\tlio_vport->npiv_wwpn = npiv_wwpn;\n\tlio_vport->npiv_wwnn = npiv_wwnn;\n\n\tefct_format_wwn(lio_vport->wwpn_str, sizeof(lio_vport->wwpn_str),\n\t\t\t\"naa.\", npiv_wwpn);\n\n\tvport_list = kzalloc(sizeof(*vport_list), GFP_KERNEL);\n\tif (!vport_list) {\n\t\tkfree(lio_vport);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tvport_list->lio_vport = lio_vport;\n\n\tmemset(&vport_id, 0, sizeof(vport_id));\n\tvport_id.port_name = npiv_wwpn;\n\tvport_id.node_name = npiv_wwnn;\n\tvport_id.roles = FC_PORT_ROLE_FCP_INITIATOR;\n\tvport_id.vport_type = FC_PORTTYPE_NPIV;\n\tvport_id.disable = false;\n\n\tnew_fc_vport = fc_vport_create(efct->shost, 0, &vport_id);\n\tif (!new_fc_vport) {\n\t\tefc_log_err(efct, \"fc_vport_create failed\\n\");\n\t\tkfree(lio_vport);\n\t\tkfree(vport_list);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tlio_vport->fc_vport = new_fc_vport;\n\tspin_lock_irqsave(&efct->tgt_efct.efct_lio_lock, flags);\n\tINIT_LIST_HEAD(&vport_list->list_entry);\n\tlist_add_tail(&vport_list->list_entry, &efct->tgt_efct.vport_list);\n\tspin_unlock_irqrestore(&efct->tgt_efct.efct_lio_lock, flags);\n\n\treturn &lio_vport->vport_wwn;\n}\n\nstatic void\nefct_lio_drop_nport(struct se_wwn *wwn)\n{\n\tstruct efct_lio_nport *lio_nport =\n\t\tcontainer_of(wwn, struct efct_lio_nport, nport_wwn);\n\tstruct efct *efct = lio_nport->efct;\n\n\t \n\tkfree(efct->tgt_efct.lio_nport);\n\tefct->tgt_efct.lio_nport = NULL;\n}\n\nstatic void\nefct_lio_npiv_drop_nport(struct se_wwn *wwn)\n{\n\tstruct efct_lio_vport *lio_vport =\n\t\tcontainer_of(wwn, struct efct_lio_vport, vport_wwn);\n\tstruct efct_lio_vport_list_t *vport, *next_vport;\n\tstruct efct *efct = lio_vport->efct;\n\tunsigned long flags = 0;\n\n\tif (lio_vport->fc_vport)\n\t\tfc_vport_terminate(lio_vport->fc_vport);\n\n\tspin_lock_irqsave(&efct->tgt_efct.efct_lio_lock, flags);\n\n\tlist_for_each_entry_safe(vport, next_vport, &efct->tgt_efct.vport_list,\n\t\t\t\t list_entry) {\n\t\tif (vport->lio_vport == lio_vport) {\n\t\t\tlist_del(&vport->list_entry);\n\t\t\tkfree(vport->lio_vport);\n\t\t\tkfree(vport);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&efct->tgt_efct.efct_lio_lock, flags);\n}\n\nstatic struct se_portal_group *\nefct_lio_make_tpg(struct se_wwn *wwn, const char *name)\n{\n\tstruct efct_lio_nport *lio_nport =\n\t\tcontainer_of(wwn, struct efct_lio_nport, nport_wwn);\n\tstruct efct_lio_tpg *tpg;\n\tstruct efct *efct;\n\tunsigned long n;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &n) || n > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(*tpg), GFP_KERNEL);\n\tif (!tpg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttpg->nport = lio_nport;\n\ttpg->tpgt = n;\n\ttpg->enabled = false;\n\n\ttpg->tpg_attrib.generate_node_acls = 1;\n\ttpg->tpg_attrib.demo_mode_write_protect = 1;\n\ttpg->tpg_attrib.cache_dynamic_acls = 1;\n\ttpg->tpg_attrib.demo_mode_login_only = 1;\n\ttpg->tpg_attrib.session_deletion_wait = 1;\n\n\tret = core_tpg_register(wwn, &tpg->tpg, SCSI_PROTOCOL_FCP);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tefct = lio_nport->efct;\n\tefct->tgt_efct.tpg = tpg;\n\tefc_log_debug(efct, \"create portal group %d\\n\", tpg->tpgt);\n\n\txa_init(&efct->lookup);\n\treturn &tpg->tpg;\n}\n\nstatic void\nefct_lio_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\tstruct efct *efct = tpg->nport->efct;\n\n\tefc_log_debug(efct, \"drop portal group %d\\n\", tpg->tpgt);\n\ttpg->nport->efct->tgt_efct.tpg = NULL;\n\tcore_tpg_deregister(se_tpg);\n\txa_destroy(&efct->lookup);\n\tkfree(tpg);\n}\n\nstatic struct se_portal_group *\nefct_lio_npiv_make_tpg(struct se_wwn *wwn, const char *name)\n{\n\tstruct efct_lio_vport *lio_vport =\n\t\tcontainer_of(wwn, struct efct_lio_vport, vport_wwn);\n\tstruct efct_lio_tpg *tpg;\n\tstruct efct *efct;\n\tunsigned long n;\n\tint ret;\n\n\tefct = lio_vport->efct;\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &n) || n > USHRT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (n != 1) {\n\t\tefc_log_err(efct, \"Invalid tpgt index: %ld provided\\n\", n);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\ttpg = kzalloc(sizeof(*tpg), GFP_KERNEL);\n\tif (!tpg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttpg->vport = lio_vport;\n\ttpg->tpgt = n;\n\ttpg->enabled = false;\n\n\ttpg->tpg_attrib.generate_node_acls = 1;\n\ttpg->tpg_attrib.demo_mode_write_protect = 1;\n\ttpg->tpg_attrib.cache_dynamic_acls = 1;\n\ttpg->tpg_attrib.demo_mode_login_only = 1;\n\ttpg->tpg_attrib.session_deletion_wait = 1;\n\n\tret = core_tpg_register(wwn, &tpg->tpg, SCSI_PROTOCOL_FCP);\n\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tlio_vport->tpg = tpg;\n\tefc_log_debug(efct, \"create vport portal group %d\\n\", tpg->tpgt);\n\n\treturn &tpg->tpg;\n}\n\nstatic void\nefct_lio_npiv_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct efct_lio_tpg *tpg =\n\t\tcontainer_of(se_tpg, struct efct_lio_tpg, tpg);\n\n\tefc_log_debug(tpg->vport->efct, \"drop npiv portal group %d\\n\",\n\t\t       tpg->tpgt);\n\tcore_tpg_deregister(se_tpg);\n\tkfree(tpg);\n}\n\nstatic int\nefct_lio_init_nodeacl(struct se_node_acl *se_nacl, const char *name)\n{\n\tstruct efct_lio_nacl *nacl;\n\tu64 wwnn;\n\n\tif (efct_lio_parse_wwn(name, &wwnn, 0) < 0)\n\t\treturn -EINVAL;\n\n\tnacl = container_of(se_nacl, struct efct_lio_nacl, se_node_acl);\n\tnacl->nport_wwnn = wwnn;\n\n\tefct_format_wwn(nacl->nport_name, sizeof(nacl->nport_name), \"\", wwnn);\n\treturn 0;\n}\n\nstatic int efct_lio_check_demo_mode_login_only(struct se_portal_group *stpg)\n{\n\tstruct efct_lio_tpg *tpg = container_of(stpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->tpg_attrib.demo_mode_login_only;\n}\n\nstatic int\nefct_lio_npiv_check_demo_mode_login_only(struct se_portal_group *stpg)\n{\n\tstruct efct_lio_tpg *tpg = container_of(stpg, struct efct_lio_tpg, tpg);\n\n\treturn tpg->tpg_attrib.demo_mode_login_only;\n}\n\nstatic struct efct_lio_tpg *\nefct_get_vport_tpg(struct efc_node *node)\n{\n\tstruct efct *efct;\n\tu64 wwpn = node->nport->wwpn;\n\tstruct efct_lio_vport_list_t *vport, *next;\n\tstruct efct_lio_vport *lio_vport = NULL;\n\tstruct efct_lio_tpg *tpg = NULL;\n\tunsigned long flags = 0;\n\n\tefct = node->efc->base;\n\tspin_lock_irqsave(&efct->tgt_efct.efct_lio_lock, flags);\n\tlist_for_each_entry_safe(vport, next, &efct->tgt_efct.vport_list,\n\t\t\t\t list_entry) {\n\t\tlio_vport = vport->lio_vport;\n\t\tif (wwpn && lio_vport && lio_vport->npiv_wwpn == wwpn) {\n\t\t\tefc_log_debug(efct, \"found tpg on vport\\n\");\n\t\t\ttpg = lio_vport->tpg;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&efct->tgt_efct.efct_lio_lock, flags);\n\treturn tpg;\n}\n\nstatic void\n_efct_tgt_node_free(struct kref *arg)\n{\n\tstruct efct_node *tgt_node = container_of(arg, struct efct_node, ref);\n\tstruct efc_node *node = tgt_node->node;\n\n\tefc_scsi_del_initiator_complete(node->efc, node);\n\tkfree(tgt_node);\n}\n\nstatic int efct_session_cb(struct se_portal_group *se_tpg,\n\t\t\t   struct se_session *se_sess, void *private)\n{\n\tstruct efc_node *node = private;\n\tstruct efct_node *tgt_node;\n\tstruct efct *efct = node->efc->base;\n\n\ttgt_node = kzalloc(sizeof(*tgt_node), GFP_KERNEL);\n\tif (!tgt_node)\n\t\treturn -ENOMEM;\n\n\tkref_init(&tgt_node->ref);\n\ttgt_node->release = _efct_tgt_node_free;\n\n\ttgt_node->session = se_sess;\n\tnode->tgt_node = tgt_node;\n\ttgt_node->efct = efct;\n\n\ttgt_node->node = node;\n\n\ttgt_node->node_fc_id = node->rnode.fc_id;\n\ttgt_node->port_fc_id = node->nport->fc_id;\n\ttgt_node->vpi = node->nport->indicator;\n\ttgt_node->rpi = node->rnode.indicator;\n\n\tspin_lock_init(&tgt_node->active_ios_lock);\n\tINIT_LIST_HEAD(&tgt_node->active_ios);\n\n\treturn 0;\n}\n\nint efct_scsi_tgt_new_device(struct efct *efct)\n{\n\tu32 total_ios;\n\n\t \n\tefct->tgt_efct.max_sge = sli_get_max_sge(&efct->hw.sli);\n\tefct->tgt_efct.max_sgl = sli_get_max_sgl(&efct->hw.sli);\n\n\t \n\tatomic_set(&efct->tgt_efct.ios_in_use, 0);\n\ttotal_ios = efct->hw.config.n_io;\n\tefc_log_debug(efct, \"total_ios=%d\\n\", total_ios);\n\tefct->tgt_efct.watermark_min =\n\t\t\t(total_ios * EFCT_WATERMARK_LOW_PCT) / 100;\n\tefct->tgt_efct.watermark_max =\n\t\t\t(total_ios * EFCT_WATERMARK_HIGH_PCT) / 100;\n\tatomic_set(&efct->tgt_efct.io_high_watermark,\n\t\t   efct->tgt_efct.watermark_max);\n\tatomic_set(&efct->tgt_efct.watermark_hit, 0);\n\tatomic_set(&efct->tgt_efct.initiator_count, 0);\n\n\tlio_wq = create_singlethread_workqueue(\"efct_lio_worker\");\n\tif (!lio_wq) {\n\t\tefc_log_err(efct, \"workqueue create failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_init(&efct->tgt_efct.efct_lio_lock);\n\tINIT_LIST_HEAD(&efct->tgt_efct.vport_list);\n\n\treturn 0;\n}\n\nint efct_scsi_tgt_del_device(struct efct *efct)\n{\n\tflush_workqueue(lio_wq);\n\n\treturn 0;\n}\n\nint\nefct_scsi_tgt_new_nport(struct efc *efc, struct efc_nport *nport)\n{\n\tstruct efct *efct = nport->efc->base;\n\n\tefc_log_debug(efct, \"New SPORT: %s bound to %s\\n\", nport->display_name,\n\t\t       efct->tgt_efct.lio_nport->wwpn_str);\n\n\treturn 0;\n}\n\nvoid\nefct_scsi_tgt_del_nport(struct efc *efc, struct efc_nport *nport)\n{\n\tefc_log_debug(efc, \"Del SPORT: %s\\n\", nport->display_name);\n}\n\nstatic void efct_lio_setup_session(struct work_struct *work)\n{\n\tstruct efct_lio_wq_data *wq_data =\n\t\tcontainer_of(work, struct efct_lio_wq_data, work);\n\tstruct efct *efct = wq_data->efct;\n\tstruct efc_node *node = wq_data->ptr;\n\tchar wwpn[WWN_NAME_LEN];\n\tstruct efct_lio_tpg *tpg;\n\tstruct efct_node *tgt_node;\n\tstruct se_portal_group *se_tpg;\n\tstruct se_session *se_sess;\n\tint watermark;\n\tint ini_count;\n\tu64 id;\n\n\t \n\ttpg = efct_get_vport_tpg(node);\n\tif (tpg) {\n\t\tse_tpg = &tpg->tpg;\n\t} else if (efct->tgt_efct.tpg) {\n\t\ttpg = efct->tgt_efct.tpg;\n\t\tse_tpg = &tpg->tpg;\n\t} else {\n\t\tefc_log_err(efct, \"failed to init session\\n\");\n\t\treturn;\n\t}\n\n\t \n\tefct_format_wwn(wwpn, sizeof(wwpn), \"\",\tefc_node_get_wwpn(node));\n\n\tse_sess = target_setup_session(se_tpg, 0, 0, TARGET_PROT_NORMAL, wwpn,\n\t\t\t\t       node, efct_session_cb);\n\tif (IS_ERR(se_sess)) {\n\t\tefc_log_err(efct, \"failed to setup session\\n\");\n\t\tkfree(wq_data);\n\t\tefc_scsi_sess_reg_complete(node, -EIO);\n\t\treturn;\n\t}\n\n\ttgt_node = node->tgt_node;\n\tid = (u64) tgt_node->port_fc_id << 32 | tgt_node->node_fc_id;\n\n\tefc_log_debug(efct, \"new initiator sess=%p node=%p id: %llx\\n\",\n\t\t      se_sess, node, id);\n\n\tif (xa_err(xa_store(&efct->lookup, id, tgt_node, GFP_KERNEL)))\n\t\tefc_log_err(efct, \"Node lookup store failed\\n\");\n\n\tefc_scsi_sess_reg_complete(node, 0);\n\n\t \n\tini_count = atomic_add_return(1, &efct->tgt_efct.initiator_count);\n\twatermark = efct->tgt_efct.watermark_max -\n\t\t    ini_count * EFCT_IO_WATERMARK_PER_INITIATOR;\n\twatermark = (efct->tgt_efct.watermark_min > watermark) ?\n\t\t\tefct->tgt_efct.watermark_min : watermark;\n\tatomic_set(&efct->tgt_efct.io_high_watermark, watermark);\n\n\tkfree(wq_data);\n}\n\nint efct_scsi_new_initiator(struct efc *efc, struct efc_node *node)\n{\n\tstruct efct *efct = node->efc->base;\n\tstruct efct_lio_wq_data *wq_data;\n\n\t \n\twq_data = kzalloc(sizeof(*wq_data), GFP_ATOMIC);\n\tif (!wq_data)\n\t\treturn -ENOMEM;\n\n\twq_data->ptr = node;\n\twq_data->efct = efct;\n\tINIT_WORK(&wq_data->work, efct_lio_setup_session);\n\tqueue_work(lio_wq, &wq_data->work);\n\treturn EFC_SCSI_CALL_ASYNC;\n}\n\nstatic void efct_lio_remove_session(struct work_struct *work)\n{\n\tstruct efct_lio_wq_data *wq_data =\n\t\tcontainer_of(work, struct efct_lio_wq_data, work);\n\tstruct efct *efct = wq_data->efct;\n\tstruct efc_node *node = wq_data->ptr;\n\tstruct efct_node *tgt_node;\n\tstruct se_session *se_sess;\n\n\ttgt_node = node->tgt_node;\n\tif (!tgt_node) {\n\t\t \n\t\tefc_log_err(efct, \"unreg session for NULL session\\n\");\n\t\tefc_scsi_del_initiator_complete(node->efc, node);\n\t\treturn;\n\t}\n\n\tse_sess = tgt_node->session;\n\tefc_log_debug(efct, \"unreg session se_sess=%p node=%p\\n\",\n\t\t       se_sess, node);\n\n\t \n\ttarget_stop_session(se_sess);\n\n\t \n\ttarget_wait_for_sess_cmds(se_sess);\n\ttarget_remove_session(se_sess);\n\ttgt_node->session = NULL;\n\tnode->tgt_node = NULL;\n\tkref_put(&tgt_node->ref, tgt_node->release);\n\n\tkfree(wq_data);\n}\n\nint efct_scsi_del_initiator(struct efc *efc, struct efc_node *node, int reason)\n{\n\tstruct efct *efct = node->efc->base;\n\tstruct efct_node *tgt_node = node->tgt_node;\n\tstruct efct_lio_wq_data *wq_data;\n\tint watermark;\n\tint ini_count;\n\tu64 id;\n\n\tif (reason == EFCT_SCSI_INITIATOR_MISSING)\n\t\treturn EFC_SCSI_CALL_COMPLETE;\n\n\tif (!tgt_node) {\n\t\tefc_log_err(efct, \"tgt_node is NULL\\n\");\n\t\treturn -EIO;\n\t}\n\n\twq_data = kzalloc(sizeof(*wq_data), GFP_ATOMIC);\n\tif (!wq_data)\n\t\treturn -ENOMEM;\n\n\tid = (u64) tgt_node->port_fc_id << 32 | tgt_node->node_fc_id;\n\txa_erase(&efct->lookup, id);\n\n\twq_data->ptr = node;\n\twq_data->efct = efct;\n\tINIT_WORK(&wq_data->work, efct_lio_remove_session);\n\tqueue_work(lio_wq, &wq_data->work);\n\n\t \n\tini_count = atomic_sub_return(1, &efct->tgt_efct.initiator_count);\n\n\twatermark = efct->tgt_efct.watermark_max -\n\t\t    ini_count * EFCT_IO_WATERMARK_PER_INITIATOR;\n\twatermark = (efct->tgt_efct.watermark_min > watermark) ?\n\t\t\tefct->tgt_efct.watermark_min : watermark;\n\tatomic_set(&efct->tgt_efct.io_high_watermark, watermark);\n\n\treturn EFC_SCSI_CALL_ASYNC;\n}\n\nvoid efct_scsi_recv_cmd(struct efct_io *io, uint64_t lun, u8 *cdb,\n\t\t       u32 cdb_len, u32 flags)\n{\n\tstruct efct_scsi_tgt_io *ocp = &io->tgt_io;\n\tstruct se_cmd *se_cmd = &io->tgt_io.cmd;\n\tstruct efct *efct = io->efct;\n\tchar *ddir;\n\tstruct efct_node *tgt_node;\n\tstruct se_session *se_sess;\n\tint rc = 0;\n\n\tmemset(ocp, 0, sizeof(struct efct_scsi_tgt_io));\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_SCSI_RECV_CMD);\n\tatomic_add_return(1, &efct->tgt_efct.ios_in_use);\n\n\t \n\tio->timeout = efct->target_io_timer_sec;\n\n\tif (flags & EFCT_SCSI_CMD_SIMPLE)\n\t\tocp->task_attr = TCM_SIMPLE_TAG;\n\telse if (flags & EFCT_SCSI_CMD_HEAD_OF_QUEUE)\n\t\tocp->task_attr = TCM_HEAD_TAG;\n\telse if (flags & EFCT_SCSI_CMD_ORDERED)\n\t\tocp->task_attr = TCM_ORDERED_TAG;\n\telse if (flags & EFCT_SCSI_CMD_ACA)\n\t\tocp->task_attr = TCM_ACA_TAG;\n\n\tswitch (flags & (EFCT_SCSI_CMD_DIR_IN | EFCT_SCSI_CMD_DIR_OUT)) {\n\tcase EFCT_SCSI_CMD_DIR_IN:\n\t\tddir = \"FROM_INITIATOR\";\n\t\tocp->ddir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase EFCT_SCSI_CMD_DIR_OUT:\n\t\tddir = \"TO_INITIATOR\";\n\t\tocp->ddir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tcase EFCT_SCSI_CMD_DIR_IN | EFCT_SCSI_CMD_DIR_OUT:\n\t\tddir = \"BIDIR\";\n\t\tocp->ddir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\tdefault:\n\t\tddir = \"NONE\";\n\t\tocp->ddir = DMA_NONE;\n\t\tbreak;\n\t}\n\n\tocp->lun = lun;\n\tefct_lio_io_printf(io, \"new cmd=0x%x ddir=%s dl=%u\\n\",\n\t\t\t   cdb[0], ddir, io->exp_xfer_len);\n\n\ttgt_node = io->node;\n\tse_sess = tgt_node->session;\n\tif (!se_sess) {\n\t\tefc_log_err(efct, \"No session found to submit IO se_cmd: %p\\n\",\n\t\t\t    &ocp->cmd);\n\t\tefct_scsi_io_free(io);\n\t\treturn;\n\t}\n\n\tefct_set_lio_io_state(io, EFCT_LIO_STATE_TGT_SUBMIT_CMD);\n\trc = target_init_cmd(se_cmd, se_sess, &io->tgt_io.sense_buffer[0],\n\t\t\t     ocp->lun, io->exp_xfer_len, ocp->task_attr,\n\t\t\t     ocp->ddir, TARGET_SCF_ACK_KREF);\n\tif (rc) {\n\t\tefc_log_err(efct, \"failed to init cmd se_cmd: %p\\n\", se_cmd);\n\t\tefct_scsi_io_free(io);\n\t\treturn;\n\t}\n\n\tif (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0,\n\t\t\t\tNULL, 0, GFP_ATOMIC))\n\t\treturn;\n\n\ttarget_submit(se_cmd);\n}\n\nint\nefct_scsi_recv_tmf(struct efct_io *tmfio, u32 lun, enum efct_scsi_tmf_cmd cmd,\n\t\t   struct efct_io *io_to_abort, u32 flags)\n{\n\tunsigned char tmr_func;\n\tstruct efct *efct = tmfio->efct;\n\tstruct efct_scsi_tgt_io *ocp = &tmfio->tgt_io;\n\tstruct efct_node *tgt_node;\n\tstruct se_session *se_sess;\n\tint rc;\n\n\tmemset(ocp, 0, sizeof(struct efct_scsi_tgt_io));\n\tefct_set_lio_io_state(tmfio, EFCT_LIO_STATE_SCSI_RECV_TMF);\n\tatomic_add_return(1, &efct->tgt_efct.ios_in_use);\n\tefct_lio_tmfio_printf(tmfio, \"%s: new tmf %x lun=%u\\n\",\n\t\t\t      tmfio->display_name, cmd, lun);\n\n\tswitch (cmd) {\n\tcase EFCT_SCSI_TMF_ABORT_TASK:\n\t\ttmr_func = TMR_ABORT_TASK;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_ABORT_TASK_SET:\n\t\ttmr_func = TMR_ABORT_TASK_SET;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_CLEAR_TASK_SET:\n\t\ttmr_func = TMR_CLEAR_TASK_SET;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_LOGICAL_UNIT_RESET:\n\t\ttmr_func = TMR_LUN_RESET;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_CLEAR_ACA:\n\t\ttmr_func = TMR_CLEAR_ACA;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_TARGET_RESET:\n\t\ttmr_func = TMR_TARGET_WARM_RESET;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_QUERY_ASYNCHRONOUS_EVENT:\n\tcase EFCT_SCSI_TMF_QUERY_TASK_SET:\n\tdefault:\n\t\tgoto tmf_fail;\n\t}\n\n\ttmfio->tgt_io.tmf = tmr_func;\n\ttmfio->tgt_io.lun = lun;\n\ttmfio->tgt_io.io_to_abort = io_to_abort;\n\n\ttgt_node = tmfio->node;\n\n\tse_sess = tgt_node->session;\n\tif (!se_sess)\n\t\treturn 0;\n\n\trc = target_submit_tmr(&ocp->cmd, se_sess, NULL, lun, ocp, tmr_func,\n\t\t\tGFP_ATOMIC, tmfio->init_task_tag, TARGET_SCF_ACK_KREF);\n\n\tefct_set_lio_io_state(tmfio, EFCT_LIO_STATE_TGT_SUBMIT_TMR);\n\tif (rc)\n\t\tgoto tmf_fail;\n\n\treturn 0;\n\ntmf_fail:\n\tefct_scsi_send_tmf_resp(tmfio, EFCT_SCSI_TMF_FUNCTION_REJECTED,\n\t\t\t\tNULL, efct_lio_null_tmf_done, NULL);\n\treturn 0;\n}\n\n \n\n#define DEF_EFCT_TPG_ATTRIB(name)\t\t\t\t\t  \\\n\t\t\t\t\t\t\t\t\t  \\\nstatic ssize_t efct_lio_tpg_attrib_##name##_show(\t\t\t  \\\n\t\tstruct config_item *item, char *page)\t\t\t  \\\n{\t\t\t\t\t\t\t\t\t  \\\n\tstruct se_portal_group *se_tpg = to_tpg(item);\t\t\t  \\\n\tstruct efct_lio_tpg *tpg = container_of(se_tpg,\t\t\t  \\\n\t\t\tstruct efct_lio_tpg, tpg);\t\t\t  \\\n\t\t\t\t\t\t\t\t\t  \\\n\treturn sprintf(page, \"%u\\n\", tpg->tpg_attrib.name);\t\t  \\\n}\t\t\t\t\t\t\t\t\t  \\\n\t\t\t\t\t\t\t\t\t  \\\nstatic ssize_t efct_lio_tpg_attrib_##name##_store(\t\t\t  \\\n\t\tstruct config_item *item, const char *page, size_t count) \\\n{\t\t\t\t\t\t\t\t\t  \\\n\tstruct se_portal_group *se_tpg = to_tpg(item);\t\t\t  \\\n\tstruct efct_lio_tpg *tpg = container_of(se_tpg,\t\t\t  \\\n\t\t\t\t\tstruct efct_lio_tpg, tpg);\t  \\\n\tstruct efct_lio_tpg_attrib *a = &tpg->tpg_attrib;\t\t  \\\n\tunsigned long val;\t\t\t\t\t\t  \\\n\tint ret;\t\t\t\t\t\t\t  \\\n\t\t\t\t\t\t\t\t\t  \\\n\tret = kstrtoul(page, 0, &val);\t\t\t\t\t  \\\n\tif (ret < 0) {\t\t\t\t\t\t\t  \\\n\t\tpr_err(\"kstrtoul() failed with ret: %d\\n\", ret);\t  \\\n\t\treturn ret;\t\t\t\t\t\t  \\\n\t}\t\t\t\t\t\t\t\t  \\\n\t\t\t\t\t\t\t\t\t  \\\n\tif (val != 0 && val != 1) {\t\t\t\t\t  \\\n\t\tpr_err(\"Illegal boolean value %lu\\n\", val);\t\t  \\\n\t\treturn -EINVAL;\t\t\t\t\t\t  \\\n\t}\t\t\t\t\t\t\t\t  \\\n\t\t\t\t\t\t\t\t\t  \\\n\ta->name = val;\t\t\t\t\t\t\t  \\\n\t\t\t\t\t\t\t\t\t  \\\n\treturn count;\t\t\t\t\t\t\t  \\\n}\t\t\t\t\t\t\t\t\t  \\\nCONFIGFS_ATTR(efct_lio_tpg_attrib_, name)\n\nDEF_EFCT_TPG_ATTRIB(generate_node_acls);\nDEF_EFCT_TPG_ATTRIB(cache_dynamic_acls);\nDEF_EFCT_TPG_ATTRIB(demo_mode_write_protect);\nDEF_EFCT_TPG_ATTRIB(prod_mode_write_protect);\nDEF_EFCT_TPG_ATTRIB(demo_mode_login_only);\nDEF_EFCT_TPG_ATTRIB(session_deletion_wait);\n\nstatic struct configfs_attribute *efct_lio_tpg_attrib_attrs[] = {\n\t&efct_lio_tpg_attrib_attr_generate_node_acls,\n\t&efct_lio_tpg_attrib_attr_cache_dynamic_acls,\n\t&efct_lio_tpg_attrib_attr_demo_mode_write_protect,\n\t&efct_lio_tpg_attrib_attr_prod_mode_write_protect,\n\t&efct_lio_tpg_attrib_attr_demo_mode_login_only,\n\t&efct_lio_tpg_attrib_attr_session_deletion_wait,\n\tNULL,\n};\n\n#define DEF_EFCT_NPIV_TPG_ATTRIB(name)\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic ssize_t efct_lio_npiv_tpg_attrib_##name##_show(\t\t\t   \\\n\t\tstruct config_item *item, char *page)\t\t\t   \\\n{\t\t\t\t\t\t\t\t\t   \\\n\tstruct se_portal_group *se_tpg = to_tpg(item);\t\t\t   \\\n\tstruct efct_lio_tpg *tpg = container_of(se_tpg,\t\t\t   \\\n\t\t\tstruct efct_lio_tpg, tpg);\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\treturn sprintf(page, \"%u\\n\", tpg->tpg_attrib.name);\t\t   \\\n}\t\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\nstatic ssize_t efct_lio_npiv_tpg_attrib_##name##_store(\t\t\t   \\\n\t\tstruct config_item *item, const char *page, size_t count)  \\\n{\t\t\t\t\t\t\t\t\t   \\\n\tstruct se_portal_group *se_tpg = to_tpg(item);\t\t\t   \\\n\tstruct efct_lio_tpg *tpg = container_of(se_tpg,\t\t\t   \\\n\t\t\tstruct efct_lio_tpg, tpg);\t\t\t   \\\n\tstruct efct_lio_tpg_attrib *a = &tpg->tpg_attrib;\t\t   \\\n\tunsigned long val;\t\t\t\t\t\t   \\\n\tint ret;\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\tret = kstrtoul(page, 0, &val);\t\t\t\t\t   \\\n\tif (ret < 0) {\t\t\t\t\t\t\t   \\\n\t\tpr_err(\"kstrtoul() failed with ret: %d\\n\", ret);\t   \\\n\t\treturn ret;\t\t\t\t\t\t   \\\n\t}\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\tif (val != 0 && val != 1) {\t\t\t\t\t   \\\n\t\tpr_err(\"Illegal boolean value %lu\\n\", val);\t\t   \\\n\t\treturn -EINVAL;\t\t\t\t\t\t   \\\n\t}\t\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\ta->name = val;\t\t\t\t\t\t\t   \\\n\t\t\t\t\t\t\t\t\t   \\\n\treturn count;\t\t\t\t\t\t\t   \\\n}\t\t\t\t\t\t\t\t\t   \\\nCONFIGFS_ATTR(efct_lio_npiv_tpg_attrib_, name)\n\nDEF_EFCT_NPIV_TPG_ATTRIB(generate_node_acls);\nDEF_EFCT_NPIV_TPG_ATTRIB(cache_dynamic_acls);\nDEF_EFCT_NPIV_TPG_ATTRIB(demo_mode_write_protect);\nDEF_EFCT_NPIV_TPG_ATTRIB(prod_mode_write_protect);\nDEF_EFCT_NPIV_TPG_ATTRIB(demo_mode_login_only);\nDEF_EFCT_NPIV_TPG_ATTRIB(session_deletion_wait);\n\nstatic struct configfs_attribute *efct_lio_npiv_tpg_attrib_attrs[] = {\n\t&efct_lio_npiv_tpg_attrib_attr_generate_node_acls,\n\t&efct_lio_npiv_tpg_attrib_attr_cache_dynamic_acls,\n\t&efct_lio_npiv_tpg_attrib_attr_demo_mode_write_protect,\n\t&efct_lio_npiv_tpg_attrib_attr_prod_mode_write_protect,\n\t&efct_lio_npiv_tpg_attrib_attr_demo_mode_login_only,\n\t&efct_lio_npiv_tpg_attrib_attr_session_deletion_wait,\n\tNULL,\n};\n\nCONFIGFS_ATTR(efct_lio_tpg_, enable);\nstatic struct configfs_attribute *efct_lio_tpg_attrs[] = {\n\t\t\t\t&efct_lio_tpg_attr_enable, NULL };\nCONFIGFS_ATTR(efct_lio_npiv_tpg_, enable);\nstatic struct configfs_attribute *efct_lio_npiv_tpg_attrs[] = {\n\t\t\t\t&efct_lio_npiv_tpg_attr_enable, NULL };\n\nstatic const struct target_core_fabric_ops efct_lio_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"efct\",\n\t.node_acl_size\t\t\t= sizeof(struct efct_lio_nacl),\n\t.max_data_sg_nents\t\t= 65535,\n\t.tpg_get_wwn\t\t\t= efct_lio_get_fabric_wwn,\n\t.tpg_get_tag\t\t\t= efct_lio_get_tag,\n\t.fabric_init_nodeacl\t\t= efct_lio_init_nodeacl,\n\t.tpg_check_demo_mode\t\t= efct_lio_check_demo_mode,\n\t.tpg_check_demo_mode_cache      = efct_lio_check_demo_mode_cache,\n\t.tpg_check_demo_mode_write_protect = efct_lio_check_demo_write_protect,\n\t.tpg_check_prod_mode_write_protect = efct_lio_check_prod_write_protect,\n\t.check_stop_free\t\t= efct_lio_check_stop_free,\n\t.aborted_task\t\t\t= efct_lio_aborted_task,\n\t.release_cmd\t\t\t= efct_lio_release_cmd,\n\t.close_session\t\t\t= efct_lio_close_session,\n\t.write_pending\t\t\t= efct_lio_write_pending,\n\t.get_cmd_state\t\t\t= efct_lio_get_cmd_state,\n\t.queue_data_in\t\t\t= efct_lio_queue_data_in,\n\t.queue_status\t\t\t= efct_lio_queue_status,\n\t.queue_tm_rsp\t\t\t= efct_lio_queue_tm_rsp,\n\t.fabric_make_wwn\t\t= efct_lio_make_nport,\n\t.fabric_drop_wwn\t\t= efct_lio_drop_nport,\n\t.fabric_make_tpg\t\t= efct_lio_make_tpg,\n\t.fabric_drop_tpg\t\t= efct_lio_drop_tpg,\n\t.tpg_check_demo_mode_login_only = efct_lio_check_demo_mode_login_only,\n\t.tpg_check_prot_fabric_only\t= NULL,\n\t.sess_get_initiator_sid\t\t= NULL,\n\t.tfc_tpg_base_attrs\t\t= efct_lio_tpg_attrs,\n\t.tfc_tpg_attrib_attrs           = efct_lio_tpg_attrib_attrs,\n};\n\nstatic const struct target_core_fabric_ops efct_lio_npiv_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"efct_npiv\",\n\t.node_acl_size\t\t\t= sizeof(struct efct_lio_nacl),\n\t.max_data_sg_nents\t\t= 65535,\n\t.tpg_get_wwn\t\t\t= efct_lio_get_npiv_fabric_wwn,\n\t.tpg_get_tag\t\t\t= efct_lio_get_npiv_tag,\n\t.fabric_init_nodeacl\t\t= efct_lio_init_nodeacl,\n\t.tpg_check_demo_mode\t\t= efct_lio_check_demo_mode,\n\t.tpg_check_demo_mode_cache      = efct_lio_check_demo_mode_cache,\n\t.tpg_check_demo_mode_write_protect =\n\t\t\t\t\tefct_lio_npiv_check_demo_write_protect,\n\t.tpg_check_prod_mode_write_protect =\n\t\t\t\t\tefct_lio_npiv_check_prod_write_protect,\n\t.check_stop_free\t\t= efct_lio_check_stop_free,\n\t.aborted_task\t\t\t= efct_lio_aborted_task,\n\t.release_cmd\t\t\t= efct_lio_release_cmd,\n\t.close_session\t\t\t= efct_lio_close_session,\n\t.write_pending\t\t\t= efct_lio_write_pending,\n\t.get_cmd_state\t\t\t= efct_lio_get_cmd_state,\n\t.queue_data_in\t\t\t= efct_lio_queue_data_in,\n\t.queue_status\t\t\t= efct_lio_queue_status,\n\t.queue_tm_rsp\t\t\t= efct_lio_queue_tm_rsp,\n\t.fabric_make_wwn\t\t= efct_lio_npiv_make_nport,\n\t.fabric_drop_wwn\t\t= efct_lio_npiv_drop_nport,\n\t.fabric_make_tpg\t\t= efct_lio_npiv_make_tpg,\n\t.fabric_drop_tpg\t\t= efct_lio_npiv_drop_tpg,\n\t.tpg_check_demo_mode_login_only =\n\t\t\t\tefct_lio_npiv_check_demo_mode_login_only,\n\t.tpg_check_prot_fabric_only\t= NULL,\n\t.sess_get_initiator_sid\t\t= NULL,\n\t.tfc_tpg_base_attrs\t\t= efct_lio_npiv_tpg_attrs,\n\t.tfc_tpg_attrib_attrs\t\t= efct_lio_npiv_tpg_attrib_attrs,\n};\n\nint efct_scsi_tgt_driver_init(void)\n{\n\tint rc;\n\n\t \n\trc = target_register_template(&efct_lio_ops);\n\tif (rc < 0) {\n\t\tpr_err(\"target_fabric_configfs_register failed with %d\\n\", rc);\n\t\treturn rc;\n\t}\n\trc = target_register_template(&efct_lio_npiv_ops);\n\tif (rc < 0) {\n\t\tpr_err(\"target_fabric_configfs_register failed with %d\\n\", rc);\n\t\ttarget_unregister_template(&efct_lio_ops);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nint efct_scsi_tgt_driver_exit(void)\n{\n\ttarget_unregister_template(&efct_lio_ops);\n\ttarget_unregister_template(&efct_lio_npiv_ops);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}