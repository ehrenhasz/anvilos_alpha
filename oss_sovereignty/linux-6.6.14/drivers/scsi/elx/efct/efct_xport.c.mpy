{
  "module_name": "efct_xport.c",
  "hash_id": "a8a0c126a53e29a6ebb6f00c0357f6f9c09f1f2398436c2b92e09a13e7509c3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/efct/efct_xport.c",
  "human_readable_source": "\n \n\n#include \"efct_driver.h\"\n#include \"efct_unsol.h\"\n\nstatic struct dentry *efct_debugfs_root;\nstatic atomic_t efct_debugfs_count;\n\nstatic const struct scsi_host_template efct_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= EFCT_DRIVER_NAME,\n\t.supported_mode\t\t= MODE_TARGET,\n};\n\n \nstatic struct fc_function_template efct_xport_functions;\nstatic struct fc_function_template efct_vport_functions;\n\nstatic struct scsi_transport_template *efct_xport_fc_tt;\nstatic struct scsi_transport_template *efct_vport_fc_tt;\n\nstruct efct_xport *\nefct_xport_alloc(struct efct *efct)\n{\n\tstruct efct_xport *xport;\n\n\txport = kzalloc(sizeof(*xport), GFP_KERNEL);\n\tif (!xport)\n\t\treturn xport;\n\n\txport->efct = efct;\n\treturn xport;\n}\n\nstatic int\nefct_xport_init_debugfs(struct efct *efct)\n{\n\t \n\tif (!efct_debugfs_root) {\n\t\tefct_debugfs_root = debugfs_create_dir(\"efct\", NULL);\n\t\tatomic_set(&efct_debugfs_count, 0);\n\t}\n\n\t \n\tif (!efct->sess_debugfs_dir) {\n\t\tefct->sess_debugfs_dir = debugfs_create_dir(\"sessions\",\n\t\t\t\t\t\t\tefct_debugfs_root);\n\t\tif (IS_ERR(efct->sess_debugfs_dir)) {\n\t\t\tefc_log_err(efct,\n\t\t\t\t    \"failed to create debugfs entry for sessions\\n\");\n\t\t\tgoto debugfs_fail;\n\t\t}\n\t\tatomic_inc(&efct_debugfs_count);\n\t}\n\n\treturn 0;\n\ndebugfs_fail:\n\treturn -EIO;\n}\n\nstatic void efct_xport_delete_debugfs(struct efct *efct)\n{\n\t \n\tdebugfs_remove(efct->sess_debugfs_dir);\n\tefct->sess_debugfs_dir = NULL;\n\tatomic_dec(&efct_debugfs_count);\n\n\tif (atomic_read(&efct_debugfs_count) == 0) {\n\t\t \n\t\tdebugfs_remove(efct_debugfs_root);\n\t\tefct_debugfs_root = NULL;\n\t}\n}\n\nint\nefct_xport_attach(struct efct_xport *xport)\n{\n\tstruct efct *efct = xport->efct;\n\tint rc;\n\n\trc = efct_hw_setup(&efct->hw, efct, efct->pci);\n\tif (rc) {\n\t\tefc_log_err(efct, \"%s: Can't setup hardware\\n\", efct->desc);\n\t\treturn rc;\n\t}\n\n\tefct_hw_parse_filter(&efct->hw, (void *)efct->filter_def);\n\n\txport->io_pool = efct_io_pool_create(efct, efct->hw.config.n_sgl);\n\tif (!xport->io_pool) {\n\t\tefc_log_err(efct, \"Can't allocate IO pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nefct_xport_link_stats_cb(int status, u32 num_counters,\n\t\t\t struct efct_hw_link_stat_counts *counters, void *arg)\n{\n\tunion efct_xport_stats_u *result = arg;\n\n\tresult->stats.link_stats.link_failure_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_LINK_FAILURE_COUNT].counter;\n\tresult->stats.link_stats.loss_of_sync_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_LOSS_OF_SYNC_COUNT].counter;\n\tresult->stats.link_stats.primitive_sequence_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_PRIMITIVE_SEQ_COUNT].counter;\n\tresult->stats.link_stats.invalid_transmission_word_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_INVALID_XMIT_WORD_COUNT].counter;\n\tresult->stats.link_stats.crc_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_CRC_COUNT].counter;\n\n\tcomplete(&result->stats.done);\n}\n\nstatic void\nefct_xport_host_stats_cb(int status, u32 num_counters,\n\t\t\t struct efct_hw_host_stat_counts *counters, void *arg)\n{\n\tunion efct_xport_stats_u *result = arg;\n\n\tresult->stats.host_stats.transmit_kbyte_count =\n\t\tcounters[EFCT_HW_HOST_STAT_TX_KBYTE_COUNT].counter;\n\tresult->stats.host_stats.receive_kbyte_count =\n\t\tcounters[EFCT_HW_HOST_STAT_RX_KBYTE_COUNT].counter;\n\tresult->stats.host_stats.transmit_frame_count =\n\t\tcounters[EFCT_HW_HOST_STAT_TX_FRAME_COUNT].counter;\n\tresult->stats.host_stats.receive_frame_count =\n\t\tcounters[EFCT_HW_HOST_STAT_RX_FRAME_COUNT].counter;\n\n\tcomplete(&result->stats.done);\n}\n\nstatic void\nefct_xport_async_link_stats_cb(int status, u32 num_counters,\n\t\t\t       struct efct_hw_link_stat_counts *counters,\n\t\t\t       void *arg)\n{\n\tunion efct_xport_stats_u *result = arg;\n\n\tresult->stats.link_stats.link_failure_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_LINK_FAILURE_COUNT].counter;\n\tresult->stats.link_stats.loss_of_sync_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_LOSS_OF_SYNC_COUNT].counter;\n\tresult->stats.link_stats.primitive_sequence_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_PRIMITIVE_SEQ_COUNT].counter;\n\tresult->stats.link_stats.invalid_transmission_word_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_INVALID_XMIT_WORD_COUNT].counter;\n\tresult->stats.link_stats.crc_error_count =\n\t\tcounters[EFCT_HW_LINK_STAT_CRC_COUNT].counter;\n}\n\nstatic void\nefct_xport_async_host_stats_cb(int status, u32 num_counters,\n\t\t\t       struct efct_hw_host_stat_counts *counters,\n\t\t\t       void *arg)\n{\n\tunion efct_xport_stats_u *result = arg;\n\n\tresult->stats.host_stats.transmit_kbyte_count =\n\t\tcounters[EFCT_HW_HOST_STAT_TX_KBYTE_COUNT].counter;\n\tresult->stats.host_stats.receive_kbyte_count =\n\t\tcounters[EFCT_HW_HOST_STAT_RX_KBYTE_COUNT].counter;\n\tresult->stats.host_stats.transmit_frame_count =\n\t\tcounters[EFCT_HW_HOST_STAT_TX_FRAME_COUNT].counter;\n\tresult->stats.host_stats.receive_frame_count =\n\t\tcounters[EFCT_HW_HOST_STAT_RX_FRAME_COUNT].counter;\n}\n\nstatic void\nefct_xport_config_stats_timer(struct efct *efct);\n\nstatic void\nefct_xport_stats_timer_cb(struct timer_list *t)\n{\n\tstruct efct_xport *xport = from_timer(xport, t, stats_timer);\n\tstruct efct *efct = xport->efct;\n\n\tefct_xport_config_stats_timer(efct);\n}\n\nstatic void\nefct_xport_config_stats_timer(struct efct *efct)\n{\n\tu32 timeout = 3 * 1000;\n\tstruct efct_xport *xport = NULL;\n\n\tif (!efct) {\n\t\tpr_err(\"%s: failed to locate EFCT device\\n\", __func__);\n\t\treturn;\n\t}\n\n\txport = efct->xport;\n\tefct_hw_get_link_stats(&efct->hw, 0, 0, 0,\n\t\t\t       efct_xport_async_link_stats_cb,\n\t\t\t       &xport->fc_xport_stats);\n\tefct_hw_get_host_stats(&efct->hw, 0, efct_xport_async_host_stats_cb,\n\t\t\t       &xport->fc_xport_stats);\n\n\ttimer_setup(&xport->stats_timer,\n\t\t    &efct_xport_stats_timer_cb, 0);\n\tmod_timer(&xport->stats_timer,\n\t\t  jiffies + msecs_to_jiffies(timeout));\n}\n\nint\nefct_xport_initialize(struct efct_xport *xport)\n{\n\tstruct efct *efct = xport->efct;\n\tint rc = 0;\n\n\t \n\tspin_lock_init(&xport->io_pending_lock);\n\tINIT_LIST_HEAD(&xport->io_pending_list);\n\tatomic_set(&xport->io_active_count, 0);\n\tatomic_set(&xport->io_pending_count, 0);\n\tatomic_set(&xport->io_total_free, 0);\n\tatomic_set(&xport->io_total_pending, 0);\n\tatomic_set(&xport->io_alloc_failed_count, 0);\n\tatomic_set(&xport->io_pending_recursing, 0);\n\n\trc = efct_hw_init(&efct->hw);\n\tif (rc) {\n\t\tefc_log_err(efct, \"efct_hw_init failure\\n\");\n\t\tgoto out;\n\t}\n\n\trc = efct_scsi_tgt_new_device(efct);\n\tif (rc) {\n\t\tefc_log_err(efct, \"failed to initialize target\\n\");\n\t\tgoto hw_init_out;\n\t}\n\n\trc = efct_scsi_new_device(efct);\n\tif (rc) {\n\t\tefc_log_err(efct, \"failed to initialize initiator\\n\");\n\t\tgoto tgt_dev_out;\n\t}\n\n\t \n\tefct_xport_config_stats_timer(efct);\n\n\tefct_xport_init_debugfs(efct);\n\n\treturn rc;\n\ntgt_dev_out:\n\tefct_scsi_tgt_del_device(efct);\n\nhw_init_out:\n\tefct_hw_teardown(&efct->hw);\nout:\n\treturn rc;\n}\n\nint\nefct_xport_status(struct efct_xport *xport, enum efct_xport_status cmd,\n\t\t  union efct_xport_stats_u *result)\n{\n\tint rc = 0;\n\tstruct efct *efct = NULL;\n\tunion efct_xport_stats_u value;\n\n\tefct = xport->efct;\n\n\tswitch (cmd) {\n\tcase EFCT_XPORT_CONFIG_PORT_STATUS:\n\t\tif (xport->configured_link_state == 0) {\n\t\t\t \n\t\t\txport->configured_link_state = EFCT_XPORT_PORT_OFFLINE;\n\t\t}\n\t\tresult->value = xport->configured_link_state;\n\t\tbreak;\n\n\tcase EFCT_XPORT_PORT_STATUS:\n\t\t \n\t\tvalue.value = efct_hw_get_link_speed(&efct->hw);\n\t\tif (value.value == 0)\n\t\t\tresult->value = EFCT_XPORT_PORT_OFFLINE;\n\t\telse\n\t\t\tresult->value = EFCT_XPORT_PORT_ONLINE;\n\t\tbreak;\n\n\tcase EFCT_XPORT_LINK_SPEED:\n\t\tresult->value = efct_hw_get_link_speed(&efct->hw);\n\t\tbreak;\n\n\tcase EFCT_XPORT_LINK_STATISTICS:\n\t\tmemcpy((void *)result, &efct->xport->fc_xport_stats,\n\t\t       sizeof(union efct_xport_stats_u));\n\t\tbreak;\n\tcase EFCT_XPORT_LINK_STAT_RESET: {\n\t\t \n\t\tinit_completion(&result->stats.done);\n\n\t\t \n\t\trc = efct_hw_get_link_stats(&efct->hw, 0, 1, 1,\n\t\t\t\t\t    efct_xport_link_stats_cb, result);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t \n\t\tif (wait_for_completion_interruptible(&result->stats.done)) {\n\t\t\t \n\t\t\tefc_log_debug(efct, \"sem wait failed\\n\");\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trc = efct_hw_get_host_stats(&efct->hw, 1,\n\t\t\t\t\t    efct_xport_host_stats_cb, result);\n\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\t \n\t\tif (wait_for_completion_interruptible(&result->stats.done)) {\n\t\t\t \n\t\t\tefc_log_debug(efct, \"sem wait failed\\n\");\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\trc = -EIO;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int\nefct_get_link_supported_speeds(struct efct *efct)\n{\n\tu32 supported_speeds = 0;\n\tu32 link_module_type, i;\n\tstruct {\n\t\tu32 lmt_speed;\n\t\tu32 speed;\n\t} supported_speed_list[] = {\n\t\t{SLI4_LINK_MODULE_TYPE_1GB, FC_PORTSPEED_1GBIT},\n\t\t{SLI4_LINK_MODULE_TYPE_2GB, FC_PORTSPEED_2GBIT},\n\t\t{SLI4_LINK_MODULE_TYPE_4GB, FC_PORTSPEED_4GBIT},\n\t\t{SLI4_LINK_MODULE_TYPE_8GB, FC_PORTSPEED_8GBIT},\n\t\t{SLI4_LINK_MODULE_TYPE_16GB, FC_PORTSPEED_16GBIT},\n\t\t{SLI4_LINK_MODULE_TYPE_32GB, FC_PORTSPEED_32GBIT},\n\t\t{SLI4_LINK_MODULE_TYPE_64GB, FC_PORTSPEED_64GBIT},\n\t\t{SLI4_LINK_MODULE_TYPE_128GB, FC_PORTSPEED_128GBIT},\n\t};\n\n\tlink_module_type = sli_get_lmt(&efct->hw.sli);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(supported_speed_list); i++) {\n\t\tif (link_module_type & supported_speed_list[i].lmt_speed)\n\t\t\tsupported_speeds |= supported_speed_list[i].speed;\n\t}\n\n\treturn supported_speeds;\n}\n\nint\nefct_scsi_new_device(struct efct *efct)\n{\n\tstruct Scsi_Host *shost = NULL;\n\tint error = 0;\n\tstruct efct_vport *vport = NULL;\n\n\tshost = scsi_host_alloc(&efct_template, sizeof(*vport));\n\tif (!shost) {\n\t\tefc_log_err(efct, \"failed to allocate Scsi_Host struct\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tefct->shost = shost;\n\n\t \n\tvport = (struct efct_vport *)shost->hostdata;\n\tvport->efct = efct;\n\n\t \n\tshost->can_queue = efct->hw.config.n_io;\n\tshost->max_cmd_len = 16;  \n\tshost->max_id = 0xffff;\n\tshost->max_lun = 0xffffffff;\n\n\t \n\tshost->sg_tablesize = sli_get_max_sgl(&efct->hw.sli);\n\n\t \n\tshost->transportt = efct_xport_fc_tt;\n\tefc_log_debug(efct, \"transport template=%p\\n\", efct_xport_fc_tt);\n\n\t \n\terror = scsi_add_host_with_dma(shost, &efct->pci->dev,\n\t\t\t\t       &efct->pci->dev);\n\tif (error) {\n\t\tefc_log_debug(efct, \"failed scsi_add_host_with_dma\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tsnprintf(fc_host_symbolic_name(shost),\n\t\t sizeof(fc_host_symbolic_name(shost)),\n\t\t     \"Emulex %s FV%s DV%s\", efct->model,\n\t\t     efct->hw.sli.fw_name[0], EFCT_DRIVER_VERSION);\n\n\t \n\tfc_host_supported_classes(shost) = FC_COS_CLASS3;\n\n\tfc_host_supported_speeds(shost) = efct_get_link_supported_speeds(efct);\n\n\tfc_host_node_name(shost) = efct_get_wwnn(&efct->hw);\n\tfc_host_port_name(shost) = efct_get_wwpn(&efct->hw);\n\tfc_host_max_npiv_vports(shost) = 128;\n\n\treturn 0;\n}\n\nstruct scsi_transport_template *\nefct_attach_fc_transport(void)\n{\n\tstruct scsi_transport_template *efct_fc_template = NULL;\n\n\tefct_fc_template = fc_attach_transport(&efct_xport_functions);\n\n\tif (!efct_fc_template)\n\t\tpr_err(\"failed to attach EFCT with fc transport\\n\");\n\n\treturn efct_fc_template;\n}\n\nstruct scsi_transport_template *\nefct_attach_vport_fc_transport(void)\n{\n\tstruct scsi_transport_template *efct_fc_template = NULL;\n\n\tefct_fc_template = fc_attach_transport(&efct_vport_functions);\n\n\tif (!efct_fc_template)\n\t\tpr_err(\"failed to attach EFCT with fc transport\\n\");\n\n\treturn efct_fc_template;\n}\n\nint\nefct_scsi_reg_fc_transport(void)\n{\n\t \n\tefct_xport_fc_tt = efct_attach_fc_transport();\n\tif (!efct_xport_fc_tt) {\n\t\tpr_err(\"%s: failed to attach to scsi_transport_*\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tefct_vport_fc_tt = efct_attach_vport_fc_transport();\n\tif (!efct_vport_fc_tt) {\n\t\tpr_err(\"%s: failed to attach to scsi_transport_*\", __func__);\n\t\tefct_release_fc_transport(efct_xport_fc_tt);\n\t\tefct_xport_fc_tt = NULL;\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nvoid\nefct_scsi_release_fc_transport(void)\n{\n\t \n\tefct_release_fc_transport(efct_xport_fc_tt);\n\tefct_xport_fc_tt = NULL;\n\tif (efct_vport_fc_tt)\n\t\tefct_release_fc_transport(efct_vport_fc_tt);\n\n\tefct_vport_fc_tt = NULL;\n}\n\nvoid\nefct_xport_detach(struct efct_xport *xport)\n{\n\tstruct efct *efct = xport->efct;\n\n\t \n\tefct_scsi_tgt_del_device(efct);\n\n\tefct_scsi_del_device(efct);\n\n\t \n\tif (timer_pending(&xport->stats_timer))\n\t\tdel_timer(&xport->stats_timer);\n\n\tefct_hw_teardown(&efct->hw);\n\n\tefct_xport_delete_debugfs(efct);\n}\n\nstatic void\nefct_xport_domain_free_cb(struct efc *efc, void *arg)\n{\n\tstruct completion *done = arg;\n\n\tcomplete(done);\n}\n\nint\nefct_xport_control(struct efct_xport *xport, enum efct_xport_ctrl cmd, ...)\n{\n\tu32 rc = 0;\n\tstruct efct *efct = NULL;\n\tva_list argp;\n\n\tefct = xport->efct;\n\n\tswitch (cmd) {\n\tcase EFCT_XPORT_PORT_ONLINE: {\n\t\t \n\t\trc = efct_hw_port_control(&efct->hw, EFCT_HW_PORT_INIT, 0,\n\t\t\t\t\t  NULL, NULL);\n\t\tif (rc)\n\t\t\tefc_log_err(efct,\n\t\t\t\t    \"%s: Can't init port\\n\", efct->desc);\n\t\telse\n\t\t\txport->configured_link_state = cmd;\n\t\tbreak;\n\t}\n\tcase EFCT_XPORT_PORT_OFFLINE: {\n\t\tif (efct_hw_port_control(&efct->hw, EFCT_HW_PORT_SHUTDOWN, 0,\n\t\t\t\t\t NULL, NULL))\n\t\t\tefc_log_err(efct, \"port shutdown failed\\n\");\n\t\telse\n\t\t\txport->configured_link_state = cmd;\n\t\tbreak;\n\t}\n\n\tcase EFCT_XPORT_SHUTDOWN: {\n\t\tstruct completion done;\n\t\tunsigned long timeout;\n\n\t\t \n\t\tif (sli_reset_required(&efct->hw.sli)) {\n\t\t\tstruct efc_domain *domain = efct->efcport->domain;\n\n\t\t\tif (domain)\n\t\t\t\tefc_domain_cb(efct->efcport, EFC_HW_DOMAIN_LOST,\n\t\t\t\t\t      domain);\n\t\t} else {\n\t\t\tefct_hw_port_control(&efct->hw, EFCT_HW_PORT_SHUTDOWN,\n\t\t\t\t\t     0, NULL, NULL);\n\t\t}\n\n\t\tinit_completion(&done);\n\n\t\tefc_register_domain_free_cb(efct->efcport,\n\t\t\t\t\t    efct_xport_domain_free_cb, &done);\n\n\t\tefc_log_debug(efct, \"Waiting %d seconds for domain shutdown\\n\",\n\t\t\t      (EFC_SHUTDOWN_TIMEOUT_USEC / 1000000));\n\n\t\ttimeout = usecs_to_jiffies(EFC_SHUTDOWN_TIMEOUT_USEC);\n\t\tif (!wait_for_completion_timeout(&done, timeout)) {\n\t\t\tefc_log_err(efct, \"Domain shutdown timed out!!\\n\");\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tefc_register_domain_free_cb(efct->efcport, NULL, NULL);\n\n\t\t \n\t\tefc_vport_del_all(efct->efcport);\n\t\tbreak;\n\t}\n\n\t \n\tcase EFCT_XPORT_WWNN_SET: {\n\t\tu64 wwnn;\n\n\t\t \n\t\tva_start(argp, cmd);\n\t\twwnn = va_arg(argp, uint64_t);\n\t\tva_end(argp);\n\n\t\tefc_log_debug(efct, \" WWNN %016llx\\n\", wwnn);\n\t\txport->req_wwnn = wwnn;\n\n\t\tbreak;\n\t}\n\t \n\tcase EFCT_XPORT_WWPN_SET: {\n\t\tu64 wwpn;\n\n\t\t \n\t\tva_start(argp, cmd);\n\t\twwpn = va_arg(argp, uint64_t);\n\t\tva_end(argp);\n\n\t\tefc_log_debug(efct, \" WWPN %016llx\\n\", wwpn);\n\t\txport->req_wwpn = wwpn;\n\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nvoid\nefct_xport_free(struct efct_xport *xport)\n{\n\tif (xport) {\n\t\tefct_io_pool_free(xport->io_pool);\n\n\t\tkfree(xport);\n\t}\n}\n\nvoid\nefct_release_fc_transport(struct scsi_transport_template *transport_template)\n{\n\tif (transport_template)\n\t\tpr_err(\"releasing transport layer\\n\");\n\n\t \n\tfc_release_transport(transport_template);\n}\n\nstatic void\nefct_xport_remove_host(struct Scsi_Host *shost)\n{\n\tfc_remove_host(shost);\n}\n\nvoid\nefct_scsi_del_device(struct efct *efct)\n{\n\tif (!efct->shost)\n\t\treturn;\n\n\tefc_log_debug(efct, \"Unregistering with Transport Layer\\n\");\n\tefct_xport_remove_host(efct->shost);\n\tefc_log_debug(efct, \"Unregistering with SCSI Midlayer\\n\");\n\tscsi_remove_host(efct->shost);\n\tscsi_host_put(efct->shost);\n\tefct->shost = NULL;\n}\n\nstatic void\nefct_get_host_port_id(struct Scsi_Host *shost)\n{\n\tstruct efct_vport *vport = (struct efct_vport *)shost->hostdata;\n\tstruct efct *efct = vport->efct;\n\tstruct efc *efc = efct->efcport;\n\tstruct efc_nport *nport;\n\n\tif (efc->domain && efc->domain->nport) {\n\t\tnport = efc->domain->nport;\n\t\tfc_host_port_id(shost) = nport->fc_id;\n\t}\n}\n\nstatic void\nefct_get_host_port_type(struct Scsi_Host *shost)\n{\n\tstruct efct_vport *vport = (struct efct_vport *)shost->hostdata;\n\tstruct efct *efct = vport->efct;\n\tstruct efc *efc = efct->efcport;\n\tint type = FC_PORTTYPE_UNKNOWN;\n\n\tif (efc->domain && efc->domain->nport) {\n\t\tif (efc->domain->is_loop) {\n\t\t\ttype = FC_PORTTYPE_LPORT;\n\t\t} else {\n\t\t\tstruct efc_nport *nport = efc->domain->nport;\n\n\t\t\tif (nport->is_vport)\n\t\t\t\ttype = FC_PORTTYPE_NPIV;\n\t\t\telse if (nport->topology == EFC_NPORT_TOPO_P2P)\n\t\t\t\ttype = FC_PORTTYPE_PTP;\n\t\t\telse if (nport->topology == EFC_NPORT_TOPO_UNKNOWN)\n\t\t\t\ttype = FC_PORTTYPE_UNKNOWN;\n\t\t\telse\n\t\t\t\ttype = FC_PORTTYPE_NPORT;\n\t\t}\n\t}\n\tfc_host_port_type(shost) = type;\n}\n\nstatic void\nefct_get_host_vport_type(struct Scsi_Host *shost)\n{\n\tfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\n}\n\nstatic void\nefct_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct efct_vport *vport = (struct efct_vport *)shost->hostdata;\n\tstruct efct *efct = vport->efct;\n\tunion efct_xport_stats_u status;\n\tint rc;\n\n\trc = efct_xport_status(efct->xport, EFCT_XPORT_PORT_STATUS, &status);\n\tif ((!rc) && (status.value == EFCT_XPORT_PORT_ONLINE))\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\telse\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n}\n\nstatic void\nefct_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct efct_vport *vport = (struct efct_vport *)shost->hostdata;\n\tstruct efct *efct = vport->efct;\n\tstruct efc *efc = efct->efcport;\n\tunion efct_xport_stats_u speed;\n\tu32 fc_speed = FC_PORTSPEED_UNKNOWN;\n\tint rc;\n\n\tif (!efc->domain || !efc->domain->nport) {\n\t\tfc_host_speed(shost) = fc_speed;\n\t\treturn;\n\t}\n\n\trc = efct_xport_status(efct->xport, EFCT_XPORT_LINK_SPEED, &speed);\n\tif (!rc) {\n\t\tswitch (speed.value) {\n\t\tcase 1000:\n\t\t\tfc_speed = FC_PORTSPEED_1GBIT;\n\t\t\tbreak;\n\t\tcase 2000:\n\t\t\tfc_speed = FC_PORTSPEED_2GBIT;\n\t\t\tbreak;\n\t\tcase 4000:\n\t\t\tfc_speed = FC_PORTSPEED_4GBIT;\n\t\t\tbreak;\n\t\tcase 8000:\n\t\t\tfc_speed = FC_PORTSPEED_8GBIT;\n\t\t\tbreak;\n\t\tcase 10000:\n\t\t\tfc_speed = FC_PORTSPEED_10GBIT;\n\t\t\tbreak;\n\t\tcase 16000:\n\t\t\tfc_speed = FC_PORTSPEED_16GBIT;\n\t\t\tbreak;\n\t\tcase 32000:\n\t\t\tfc_speed = FC_PORTSPEED_32GBIT;\n\t\t\tbreak;\n\t\tcase 64000:\n\t\t\tfc_speed = FC_PORTSPEED_64GBIT;\n\t\t\tbreak;\n\t\tcase 128000:\n\t\t\tfc_speed = FC_PORTSPEED_128GBIT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfc_host_speed(shost) = fc_speed;\n}\n\nstatic void\nefct_get_host_fabric_name(struct Scsi_Host *shost)\n{\n\tstruct efct_vport *vport = (struct efct_vport *)shost->hostdata;\n\tstruct efct *efct = vport->efct;\n\tstruct efc *efc = efct->efcport;\n\n\tif (efc->domain) {\n\t\tstruct fc_els_flogi  *sp =\n\t\t\t(struct fc_els_flogi  *)\n\t\t\t\tefc->domain->flogi_service_params;\n\n\t\tfc_host_fabric_name(shost) = be64_to_cpu(sp->fl_wwnn);\n\t}\n}\n\nstatic struct fc_host_statistics *\nefct_get_stats(struct Scsi_Host *shost)\n{\n\tstruct efct_vport *vport = (struct efct_vport *)shost->hostdata;\n\tstruct efct *efct = vport->efct;\n\tunion efct_xport_stats_u stats;\n\tstruct efct_xport *xport = efct->xport;\n\tint rc = 0;\n\n\trc = efct_xport_status(xport, EFCT_XPORT_LINK_STATISTICS, &stats);\n\tif (rc) {\n\t\tpr_err(\"efct_xport_status returned non 0 - %d\\n\", rc);\n\t\treturn NULL;\n\t}\n\n\tvport->fc_host_stats.loss_of_sync_count =\n\t\tstats.stats.link_stats.loss_of_sync_error_count;\n\tvport->fc_host_stats.link_failure_count =\n\t\tstats.stats.link_stats.link_failure_error_count;\n\tvport->fc_host_stats.prim_seq_protocol_err_count =\n\t\tstats.stats.link_stats.primitive_sequence_error_count;\n\tvport->fc_host_stats.invalid_tx_word_count =\n\t\tstats.stats.link_stats.invalid_transmission_word_error_count;\n\tvport->fc_host_stats.invalid_crc_count =\n\t\tstats.stats.link_stats.crc_error_count;\n\t \n\tvport->fc_host_stats.tx_words =\n\t\tstats.stats.host_stats.transmit_kbyte_count * 256;\n\t \n\tvport->fc_host_stats.rx_words =\n\t\tstats.stats.host_stats.receive_kbyte_count * 256;\n\tvport->fc_host_stats.tx_frames =\n\t\tstats.stats.host_stats.transmit_frame_count;\n\tvport->fc_host_stats.rx_frames =\n\t\tstats.stats.host_stats.receive_frame_count;\n\n\tvport->fc_host_stats.fcp_input_requests =\n\t\t\txport->fcp_stats.input_requests;\n\tvport->fc_host_stats.fcp_output_requests =\n\t\t\txport->fcp_stats.output_requests;\n\tvport->fc_host_stats.fcp_output_megabytes =\n\t\t\txport->fcp_stats.output_bytes >> 20;\n\tvport->fc_host_stats.fcp_input_megabytes =\n\t\t\txport->fcp_stats.input_bytes >> 20;\n\tvport->fc_host_stats.fcp_control_requests =\n\t\t\txport->fcp_stats.control_requests;\n\n\treturn &vport->fc_host_stats;\n}\n\nstatic void\nefct_reset_stats(struct Scsi_Host *shost)\n{\n\tstruct efct_vport *vport = (struct efct_vport *)shost->hostdata;\n\tstruct efct *efct = vport->efct;\n\t \n\tunion efct_xport_stats_u dummy;\n\tint rc;\n\n\trc = efct_xport_status(efct->xport, EFCT_XPORT_LINK_STAT_RESET, &dummy);\n\tif (rc)\n\t\tpr_err(\"efct_xport_status returned non 0 - %d\\n\", rc);\n}\n\nstatic int\nefct_issue_lip(struct Scsi_Host *shost)\n{\n\tstruct efct_vport *vport =\n\t\t\tshost ? (struct efct_vport *)shost->hostdata : NULL;\n\tstruct efct *efct = vport ? vport->efct : NULL;\n\n\tif (!shost || !vport || !efct) {\n\t\tpr_err(\"%s: shost=%p vport=%p efct=%p\\n\", __func__,\n\t\t       shost, vport, efct);\n\t\treturn -EPERM;\n\t}\n\n\t \n\n\tif (efct_xport_control(efct->xport, EFCT_XPORT_PORT_OFFLINE))\n\t\tefc_log_debug(efct, \"EFCT_XPORT_PORT_OFFLINE failed\\n\");\n\n\tif (efct_xport_control(efct->xport, EFCT_XPORT_PORT_ONLINE))\n\t\tefc_log_debug(efct, \"EFCT_XPORT_PORT_ONLINE failed\\n\");\n\n\treturn 0;\n}\n\nstruct efct_vport *\nefct_scsi_new_vport(struct efct *efct, struct device *dev)\n{\n\tstruct Scsi_Host *shost = NULL;\n\tint error = 0;\n\tstruct efct_vport *vport = NULL;\n\n\tshost = scsi_host_alloc(&efct_template, sizeof(*vport));\n\tif (!shost) {\n\t\tefc_log_err(efct, \"failed to allocate Scsi_Host struct\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tvport = (struct efct_vport *)shost->hostdata;\n\tvport->efct = efct;\n\tvport->is_vport = true;\n\n\tshost->can_queue = efct->hw.config.n_io;\n\tshost->max_cmd_len = 16;  \n\tshost->max_id = 0xffff;\n\tshost->max_lun = 0xffffffff;\n\n\t \n\tshost->sg_tablesize = sli_get_max_sgl(&efct->hw.sli);\n\n\t \n\tshost->transportt = efct_vport_fc_tt;\n\tefc_log_debug(efct, \"vport transport template=%p\\n\",\n\t\t      efct_vport_fc_tt);\n\n\t \n\terror = scsi_add_host_with_dma(shost, dev, &efct->pci->dev);\n\tif (error) {\n\t\tefc_log_debug(efct, \"failed scsi_add_host_with_dma\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tsnprintf(fc_host_symbolic_name(shost),\n\t\t sizeof(fc_host_symbolic_name(shost)),\n\t\t \"Emulex %s FV%s DV%s\", efct->model, efct->hw.sli.fw_name[0],\n\t\t EFCT_DRIVER_VERSION);\n\n\t \n\tfc_host_supported_classes(shost) = FC_COS_CLASS3;\n\n\tfc_host_supported_speeds(shost) = efct_get_link_supported_speeds(efct);\n\tvport->shost = shost;\n\n\treturn vport;\n}\n\nint efct_scsi_del_vport(struct efct *efct, struct Scsi_Host *shost)\n{\n\tif (shost) {\n\t\tefc_log_debug(efct,\n\t\t\t      \"Unregistering vport with Transport Layer\\n\");\n\t\tefct_xport_remove_host(shost);\n\t\tefc_log_debug(efct, \"Unregistering vport with SCSI Midlayer\\n\");\n\t\tscsi_remove_host(shost);\n\t\tscsi_host_put(shost);\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic int\nefct_vport_create(struct fc_vport *fc_vport, bool disable)\n{\n\tstruct Scsi_Host *shost = fc_vport ? fc_vport->shost : NULL;\n\tstruct efct_vport *pport = shost ?\n\t\t\t\t\t(struct efct_vport *)shost->hostdata :\n\t\t\t\t\tNULL;\n\tstruct efct *efct = pport ? pport->efct : NULL;\n\tstruct efct_vport *vport = NULL;\n\n\tif (!fc_vport || !shost || !efct)\n\t\tgoto fail;\n\n\tvport = efct_scsi_new_vport(efct, &fc_vport->dev);\n\tif (!vport) {\n\t\tefc_log_err(efct, \"failed to create vport\\n\");\n\t\tgoto fail;\n\t}\n\n\tvport->fc_vport = fc_vport;\n\tvport->npiv_wwpn = fc_vport->port_name;\n\tvport->npiv_wwnn = fc_vport->node_name;\n\tfc_host_node_name(vport->shost) = vport->npiv_wwnn;\n\tfc_host_port_name(vport->shost) = vport->npiv_wwpn;\n\t*(struct efct_vport **)fc_vport->dd_data = vport;\n\n\treturn 0;\n\nfail:\n\treturn -EIO;\n}\n\nstatic int\nefct_vport_delete(struct fc_vport *fc_vport)\n{\n\tstruct efct_vport *vport = *(struct efct_vport **)fc_vport->dd_data;\n\tstruct Scsi_Host *shost = vport ? vport->shost : NULL;\n\tstruct efct *efct = vport ? vport->efct : NULL;\n\tint rc;\n\n\trc = efct_scsi_del_vport(efct, shost);\n\n\tif (rc)\n\t\tpr_err(\"%s: vport delete failed\\n\", __func__);\n\n\treturn rc;\n}\n\nstatic int\nefct_vport_disable(struct fc_vport *fc_vport, bool disable)\n{\n\treturn 0;\n}\n\nstatic struct fc_function_template efct_xport_functions = {\n\t.get_host_port_id = efct_get_host_port_id,\n\t.get_host_port_type = efct_get_host_port_type,\n\t.get_host_port_state = efct_get_host_port_state,\n\t.get_host_speed = efct_get_host_speed,\n\t.get_host_fabric_name = efct_get_host_fabric_name,\n\n\t.get_fc_host_stats = efct_get_stats,\n\t.reset_fc_host_stats = efct_reset_stats,\n\n\t.issue_fc_host_lip = efct_issue_lip,\n\n\t.vport_disable = efct_vport_disable,\n\n\t \n\t.dd_fcrport_size = sizeof(struct efct_rport_data),\n\t.dd_fcvport_size = 128,  \n\n\t \n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t \n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_port_id = 1,\n\n\t \n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t \n\t.show_host_port_id = 1,\n\t.show_host_port_type = 1,\n\t.show_host_port_state = 1,\n\t \n\t.show_host_active_fc4s = 1,\n\t.show_host_speed = 1,\n\t.show_host_fabric_name = 1,\n\t.show_host_symbolic_name = 1,\n\t.vport_create = efct_vport_create,\n\t.vport_delete = efct_vport_delete,\n};\n\nstatic struct fc_function_template efct_vport_functions = {\n\t.get_host_port_id = efct_get_host_port_id,\n\t.get_host_port_type = efct_get_host_vport_type,\n\t.get_host_port_state = efct_get_host_port_state,\n\t.get_host_speed = efct_get_host_speed,\n\t.get_host_fabric_name = efct_get_host_fabric_name,\n\n\t.get_fc_host_stats = efct_get_stats,\n\t.reset_fc_host_stats = efct_reset_stats,\n\n\t.issue_fc_host_lip = efct_issue_lip,\n\n\t \n\t.dd_fcrport_size = sizeof(struct efct_rport_data),\n\t.dd_fcvport_size = 128,  \n\n\t \n\t.show_rport_maxframe_size = 1,\n\t.show_rport_supported_classes = 1,\n\t.show_rport_dev_loss_tmo = 1,\n\n\t \n\t.show_starget_node_name = 1,\n\t.show_starget_port_name = 1,\n\t.show_starget_port_id = 1,\n\n\t \n\t.show_host_node_name = 1,\n\t.show_host_port_name = 1,\n\t.show_host_supported_classes = 1,\n\t.show_host_supported_fc4s = 1,\n\t.show_host_supported_speeds = 1,\n\t.show_host_maxframe_size = 1,\n\n\t \n\t.show_host_port_id = 1,\n\t.show_host_port_type = 1,\n\t.show_host_port_state = 1,\n\t \n\t.show_host_active_fc4s = 1,\n\t.show_host_speed = 1,\n\t.show_host_fabric_name = 1,\n\t.show_host_symbolic_name = 1,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}