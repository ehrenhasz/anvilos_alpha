{
  "module_name": "efct_hw.h",
  "hash_id": "01349227280fb4a14472afc49e0a588984bf1dbbea31ba737dd392107efe91b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/efct/efct_hw.h",
  "human_readable_source": " \n \n\n#ifndef _EFCT_HW_H\n#define _EFCT_HW_H\n\n#include \"../libefc_sli/sli4.h\"\n\n \n#define EFCT_VENDOR_ID\t\t\t0x10df\n \n#define EFCT_DEVICE_LANCER_G6\t\t0xe307\n \n#define EFCT_DEVICE_LANCER_G7\t\t0xf407\n\n \n#define EFCT_HW_RQ_ENTRIES_MIN\t\t512\n#define EFCT_HW_RQ_ENTRIES_DEF\t\t1024\n#define EFCT_HW_RQ_ENTRIES_MAX\t\t4096\n\n \n#define EFCT_HW_RQ_SIZE_HDR             128\n#define EFCT_HW_RQ_SIZE_PAYLOAD         1024\n\n \n#define EFCT_HW_MAX_MRQS\t\t8\n\n \n#define EFCT_HW_WQEC_SET_COUNT\t\t32\n\n \n#define EFCT_HW_SEND_FRAME_TIMEOUT\t10\n\n \n#define EFCT_HW_FDT_XFER_HINT\t\t8192\n\n#define EFCT_HW_TIMECHECK_ITERATIONS\t100\n#define EFCT_HW_MAX_NUM_MQ\t\t1\n#define EFCT_HW_MAX_NUM_RQ\t\t32\n#define EFCT_HW_MAX_NUM_EQ\t\t16\n#define EFCT_HW_MAX_NUM_WQ\t\t32\n#define EFCT_HW_DEF_NUM_EQ\t\t1\n\n#define OCE_HW_MAX_NUM_MRQ_PAIRS\t16\n\n#define EFCT_HW_MQ_DEPTH\t\t128\n#define EFCT_HW_EQ_DEPTH\t\t1024\n\n \n#define EFCT_HW_MAX_NUM_CQ \\\n\t((EFCT_HW_MAX_NUM_WQ * 2) + 1 + (OCE_HW_MAX_NUM_MRQ_PAIRS * 2))\n\n#define EFCT_HW_Q_HASH_SIZE\t\t128\n#define EFCT_HW_RQ_HEADER_SIZE\t\t128\n#define EFCT_HW_RQ_HEADER_INDEX\t\t0\n\n#define EFCT_HW_REQUE_XRI_REGTAG\t65534\n\n \nenum efct_cmd_opts {\n\t \n\tEFCT_CMD_POLL,\n\t \n\tEFCT_CMD_NOWAIT,\n};\n\nenum efct_hw_reset {\n\tEFCT_HW_RESET_FUNCTION,\n\tEFCT_HW_RESET_FIRMWARE,\n\tEFCT_HW_RESET_MAX\n};\n\nenum efct_hw_topo {\n\tEFCT_HW_TOPOLOGY_AUTO,\n\tEFCT_HW_TOPOLOGY_NPORT,\n\tEFCT_HW_TOPOLOGY_LOOP,\n\tEFCT_HW_TOPOLOGY_NONE,\n\tEFCT_HW_TOPOLOGY_MAX\n};\n\n \n#define HW_FWREV(a, b, c, d) (((uint64_t)(a) << 48) | ((uint64_t)(b) << 32) \\\n\t\t\t| ((uint64_t)(c) << 16) | ((uint64_t)(d)))\n\n#define EFCT_FW_VER_STR(a, b, c, d) (#a \".\" #b \".\" #c \".\" #d)\n\nenum efct_hw_io_type {\n\tEFCT_HW_ELS_REQ,\n\tEFCT_HW_ELS_RSP,\n\tEFCT_HW_FC_CT,\n\tEFCT_HW_FC_CT_RSP,\n\tEFCT_HW_BLS_ACC,\n\tEFCT_HW_BLS_RJT,\n\tEFCT_HW_IO_TARGET_READ,\n\tEFCT_HW_IO_TARGET_WRITE,\n\tEFCT_HW_IO_TARGET_RSP,\n\tEFCT_HW_IO_DNRX_REQUEUE,\n\tEFCT_HW_IO_MAX,\n};\n\nenum efct_hw_io_state {\n\tEFCT_HW_IO_STATE_FREE,\n\tEFCT_HW_IO_STATE_INUSE,\n\tEFCT_HW_IO_STATE_WAIT_FREE,\n\tEFCT_HW_IO_STATE_WAIT_SEC_HIO,\n};\n\n#define EFCT_TARGET_WRITE_SKIPS\t1\n#define EFCT_TARGET_READ_SKIPS\t2\n\nstruct efct_hw;\nstruct efct_io;\n\n#define EFCT_CMD_CTX_POOL_SZ\t32\n \nstruct efct_command_ctx {\n\tstruct list_head\tlist_entry;\n\tint (*cb)(struct efct_hw *hw, int status, u8 *mqe, void *arg);\n\tvoid\t\t\t*arg;\t \n\t \n\tu8\t\t\tbuf[SLI4_BMBX_SIZE];\n\tvoid\t\t\t*ctx;\t \n};\n\nstruct efct_hw_sgl {\n\tuintptr_t\t\taddr;\n\tsize_t\t\t\tlen;\n};\n\nunion efct_hw_io_param_u {\n\tstruct sli_bls_params bls;\n\tstruct sli_els_params els;\n\tstruct sli_ct_params fc_ct;\n\tstruct sli_fcp_tgt_params fcp_tgt;\n};\n\n \nenum efct_hw_wq_steering {\n\tEFCT_HW_WQ_STEERING_CLASS,\n\tEFCT_HW_WQ_STEERING_REQUEST,\n\tEFCT_HW_WQ_STEERING_CPU,\n};\n\n \nstruct efct_hw_wqe {\n\tstruct list_head\tlist_entry;\n\tbool\t\t\tabort_wqe_submit_needed;\n\tbool\t\t\tsend_abts;\n\tu32\t\t\tid;\n\tu32\t\t\tabort_reqtag;\n\tu8\t\t\t*wqebuf;\n};\n\nstruct efct_hw_io;\n \ntypedef int (*efct_hw_done_t)(struct efct_hw_io *, u32 len, int status,\n\t\t\t      u32 ext, void *ul_arg);\n\n \nstruct efct_hw_io {\n\tstruct kref\t\tref;\n\tenum efct_hw_io_state\tstate;\n\tvoid\t\t\t(*release)(struct kref *arg);\n\tstruct list_head\tlist_entry;\n\tstruct efct_hw_wqe\twqe;\n\n\tstruct efct_hw\t\t*hw;\n\tstruct efc_dma\t\txfer_rdy;\n\tu16\t\t\ttype;\n\tbool\t\t\txbusy;\n\tint\t\t\tabort_in_progress;\n\tbool\t\t\tstatus_saved;\n\tu8\t\t\twq_class;\n\tu16\t\t\treqtag;\n\n\tstruct hw_wq\t\t*wq;\n\tefct_hw_done_t\t\tdone;\n\tvoid\t\t\t*arg;\n\tefct_hw_done_t\t\tabort_done;\n\tvoid\t\t\t*abort_arg;\n\n\tenum efct_hw_wq_steering wq_steering;\n\n\tu32\t\t\tsaved_status;\n\tu32\t\t\tsaved_len;\n\tu32\t\t\tsaved_ext;\n\n\tstruct hw_eq\t\t*eq;\n\tu32\t\t\tsge_offset;\n\tu32\t\t\tdef_sgl_count;\n\tu32\t\t\tabort_reqtag;\n\tu32\t\t\tindicator;\n\tstruct efc_dma\t\tdef_sgl;\n\tstruct efc_dma\t\t*sgl;\n\tu32\t\t\tsgl_count;\n\tu32\t\t\tfirst_data_sge;\n\tu32\t\t\tn_sge;\n};\n\nenum efct_hw_port {\n\tEFCT_HW_PORT_INIT,\n\tEFCT_HW_PORT_SHUTDOWN,\n};\n\n \nstruct efct_hw_rpi_ref {\n\tatomic_t rpi_count;\n\tatomic_t rpi_attached;\n};\n\nenum efct_hw_link_stat {\n\tEFCT_HW_LINK_STAT_LINK_FAILURE_COUNT,\n\tEFCT_HW_LINK_STAT_LOSS_OF_SYNC_COUNT,\n\tEFCT_HW_LINK_STAT_LOSS_OF_SIGNAL_COUNT,\n\tEFCT_HW_LINK_STAT_PRIMITIVE_SEQ_COUNT,\n\tEFCT_HW_LINK_STAT_INVALID_XMIT_WORD_COUNT,\n\tEFCT_HW_LINK_STAT_CRC_COUNT,\n\tEFCT_HW_LINK_STAT_PRIMITIVE_SEQ_TIMEOUT_COUNT,\n\tEFCT_HW_LINK_STAT_ELASTIC_BUFFER_OVERRUN_COUNT,\n\tEFCT_HW_LINK_STAT_ARB_TIMEOUT_COUNT,\n\tEFCT_HW_LINK_STAT_ADVERTISED_RCV_B2B_CREDIT,\n\tEFCT_HW_LINK_STAT_CURR_RCV_B2B_CREDIT,\n\tEFCT_HW_LINK_STAT_ADVERTISED_XMIT_B2B_CREDIT,\n\tEFCT_HW_LINK_STAT_CURR_XMIT_B2B_CREDIT,\n\tEFCT_HW_LINK_STAT_RCV_EOFA_COUNT,\n\tEFCT_HW_LINK_STAT_RCV_EOFDTI_COUNT,\n\tEFCT_HW_LINK_STAT_RCV_EOFNI_COUNT,\n\tEFCT_HW_LINK_STAT_RCV_SOFF_COUNT,\n\tEFCT_HW_LINK_STAT_RCV_DROPPED_NO_AER_COUNT,\n\tEFCT_HW_LINK_STAT_RCV_DROPPED_NO_RPI_COUNT,\n\tEFCT_HW_LINK_STAT_RCV_DROPPED_NO_XRI_COUNT,\n\tEFCT_HW_LINK_STAT_MAX,\n};\n\nenum efct_hw_host_stat {\n\tEFCT_HW_HOST_STAT_TX_KBYTE_COUNT,\n\tEFCT_HW_HOST_STAT_RX_KBYTE_COUNT,\n\tEFCT_HW_HOST_STAT_TX_FRAME_COUNT,\n\tEFCT_HW_HOST_STAT_RX_FRAME_COUNT,\n\tEFCT_HW_HOST_STAT_TX_SEQ_COUNT,\n\tEFCT_HW_HOST_STAT_RX_SEQ_COUNT,\n\tEFCT_HW_HOST_STAT_TOTAL_EXCH_ORIG,\n\tEFCT_HW_HOST_STAT_TOTAL_EXCH_RESP,\n\tEFCT_HW_HOSY_STAT_RX_P_BSY_COUNT,\n\tEFCT_HW_HOST_STAT_RX_F_BSY_COUNT,\n\tEFCT_HW_HOST_STAT_DROP_FRM_DUE_TO_NO_RQ_BUF_COUNT,\n\tEFCT_HW_HOST_STAT_EMPTY_RQ_TIMEOUT_COUNT,\n\tEFCT_HW_HOST_STAT_DROP_FRM_DUE_TO_NO_XRI_COUNT,\n\tEFCT_HW_HOST_STAT_EMPTY_XRI_POOL_COUNT,\n\tEFCT_HW_HOST_STAT_MAX,\n};\n\nenum efct_hw_state {\n\tEFCT_HW_STATE_UNINITIALIZED,\n\tEFCT_HW_STATE_QUEUES_ALLOCATED,\n\tEFCT_HW_STATE_ACTIVE,\n\tEFCT_HW_STATE_RESET_IN_PROGRESS,\n\tEFCT_HW_STATE_TEARDOWN_IN_PROGRESS,\n};\n\nstruct efct_hw_link_stat_counts {\n\tu8\t\toverflow;\n\tu32\t\tcounter;\n};\n\nstruct efct_hw_host_stat_counts {\n\tu32\t\tcounter;\n};\n\n \nstruct efct_queue_hash {\n\tbool\t\tin_use;\n\tu16\t\tid;\n\tu16\t\tindex;\n};\n\n \nstruct hw_wq_callback {\n\tu16\t\tinstance_index;\t \n\tvoid (*callback)(void *arg, u8 *cqe, int status);\n\tvoid\t\t*arg;\n\tstruct list_head list_entry;\n};\n\nstruct reqtag_pool {\n\tspinlock_t lock;\t \n\tstruct hw_wq_callback *tags[U16_MAX];\n\tstruct list_head freelist;\n};\n\nstruct efct_hw_config {\n\tu32\t\tn_eq;\n\tu32\t\tn_cq;\n\tu32\t\tn_mq;\n\tu32\t\tn_rq;\n\tu32\t\tn_wq;\n\tu32\t\tn_io;\n\tu32\t\tn_sgl;\n\tu32\t\tspeed;\n\tu32\t\ttopology;\n\t \n\tu32\t\trq_default_buffer_size;\n\tu8\t\tesoc;\n\t \n\tu8\t\trq_selection_policy;\n\t \n\tu8\t\trr_quanta;\n\tu32\t\tfilter_def[SLI4_CMD_REG_FCFI_NUM_RQ_CFG];\n};\n\nstruct efct_hw {\n\tstruct efct\t\t*os;\n\tstruct sli4\t\tsli;\n\tu16\t\t\tulp_start;\n\tu16\t\t\tulp_max;\n\tu32\t\t\tdump_size;\n\tenum efct_hw_state\tstate;\n\tbool\t\t\thw_setup_called;\n\tu8\t\t\tsliport_healthcheck;\n\tu16\t\t\tfcf_indicator;\n\n\t \n\tstruct efct_hw_config\tconfig;\n\n\t \n\tu32\t\t\tnum_qentries[SLI4_QTYPE_MAX];\n\n\t \n\tstruct sli4_queue\twq[EFCT_HW_MAX_NUM_WQ];\n\tstruct sli4_queue\trq[EFCT_HW_MAX_NUM_RQ];\n\tu16\t\t\thw_rq_lookup[EFCT_HW_MAX_NUM_RQ];\n\tstruct sli4_queue\tmq[EFCT_HW_MAX_NUM_MQ];\n\tstruct sli4_queue\tcq[EFCT_HW_MAX_NUM_CQ];\n\tstruct sli4_queue\teq[EFCT_HW_MAX_NUM_EQ];\n\n\t \n\tu32\t\t\teq_count;\n\tu32\t\t\tcq_count;\n\tu32\t\t\tmq_count;\n\tu32\t\t\twq_count;\n\tu32\t\t\trq_count;\n\tu32\t\t\tcmd_head_count;\n\tstruct list_head\teq_list;\n\n\tstruct efct_queue_hash\tcq_hash[EFCT_HW_Q_HASH_SIZE];\n\tstruct efct_queue_hash\trq_hash[EFCT_HW_Q_HASH_SIZE];\n\tstruct efct_queue_hash\twq_hash[EFCT_HW_Q_HASH_SIZE];\n\n\t \n\tstruct hw_wq\t\t*hw_wq[EFCT_HW_MAX_NUM_WQ];\n\tstruct hw_rq\t\t*hw_rq[EFCT_HW_MAX_NUM_RQ];\n\tstruct hw_mq\t\t*hw_mq[EFCT_HW_MAX_NUM_MQ];\n\tstruct hw_cq\t\t*hw_cq[EFCT_HW_MAX_NUM_CQ];\n\tstruct hw_eq\t\t*hw_eq[EFCT_HW_MAX_NUM_EQ];\n\t \n\tu32\t\t\thw_rq_count;\n\t \n\tu32\t\t\thw_mrq_count;\n\n\tstruct hw_wq\t\t**wq_cpu_array;\n\n\t \n\tstruct efc_hw_sequence\t*seq_pool;\n\n\t \n\tstruct mutex            bmbx_lock;\n\tspinlock_t\t\tcmd_lock;\n\tstruct list_head\tcmd_head;\n\tstruct list_head\tcmd_pending;\n\tmempool_t\t\t*cmd_ctx_pool;\n\tmempool_t\t\t*mbox_rqst_pool;\n\n\tstruct sli4_link_event\tlink;\n\n\t \n\tstruct efct_hw_io\t**io;\n\t \n\tu8\t\t\t*wqe_buffs;\n\n\t \n\tspinlock_t\t\tio_lock;\n\t \n\tstruct list_head\tio_inuse;\n\t \n\tstruct list_head\tio_wait_free;\n\t \n\tstruct list_head\tio_free;\n\n\tstruct efc_dma\t\tloop_map;\n\n\tstruct efc_dma\t\txfer_rdy;\n\n\tstruct efc_dma\t\trnode_mem;\n\n\tatomic_t\t\tio_alloc_failed_count;\n\n\t \n\tu32\t\t\ttcmd_wq_submit[EFCT_HW_MAX_NUM_WQ];\n\t \n\tu32\t\t\ttcmd_wq_complete[EFCT_HW_MAX_NUM_WQ];\n\n\tatomic_t\t\tsend_frame_seq_id;\n\tstruct reqtag_pool\t*wq_reqtag_pool;\n};\n\nenum efct_hw_io_count_type {\n\tEFCT_HW_IO_INUSE_COUNT,\n\tEFCT_HW_IO_FREE_COUNT,\n\tEFCT_HW_IO_WAIT_FREE_COUNT,\n\tEFCT_HW_IO_N_TOTAL_IO_COUNT,\n};\n\n \nstruct hw_eq {\n\tstruct list_head\tlist_entry;\n\tenum sli4_qtype\t\ttype;\n\tu32\t\t\tinstance;\n\tu32\t\t\tentry_count;\n\tu32\t\t\tentry_size;\n\tstruct efct_hw\t\t*hw;\n\tstruct sli4_queue\t*queue;\n\tstruct list_head\tcq_list;\n\tu32\t\t\tuse_count;\n};\n\nstruct hw_cq {\n\tstruct list_head\tlist_entry;\n\tenum sli4_qtype\t\ttype;\n\tu32\t\t\tinstance;\n\tu32\t\t\tentry_count;\n\tu32\t\t\tentry_size;\n\tstruct hw_eq\t\t*eq;\n\tstruct sli4_queue\t*queue;\n\tstruct list_head\tq_list;\n\tu32\t\t\tuse_count;\n};\n\nstruct hw_q {\n\tstruct list_head\tlist_entry;\n\tenum sli4_qtype\t\ttype;\n};\n\nstruct hw_mq {\n\tstruct list_head\tlist_entry;\n\tenum sli4_qtype\t\ttype;\n\tu32\t\t\tinstance;\n\n\tu32\t\t\tentry_count;\n\tu32\t\t\tentry_size;\n\tstruct hw_cq\t\t*cq;\n\tstruct sli4_queue\t*queue;\n\n\tu32\t\t\tuse_count;\n};\n\nstruct hw_wq {\n\tstruct list_head\tlist_entry;\n\tenum sli4_qtype\t\ttype;\n\tu32\t\t\tinstance;\n\tstruct efct_hw\t\t*hw;\n\n\tu32\t\t\tentry_count;\n\tu32\t\t\tentry_size;\n\tstruct hw_cq\t\t*cq;\n\tstruct sli4_queue\t*queue;\n\tu32\t\t\tclass;\n\n\t \n\tu32\t\t\twqec_set_count;\n\tu32\t\t\twqec_count;\n\tu32\t\t\tfree_count;\n\tu32\t\t\ttotal_submit_count;\n\tstruct list_head\tpending_list;\n\n\t \n\tstruct efct_hw_io\t*send_frame_io;\n\n\t \n\tu32\t\t\tuse_count;\n\tu32\t\t\twq_pending_count;\n};\n\nstruct hw_rq {\n\tstruct list_head\tlist_entry;\n\tenum sli4_qtype\t\ttype;\n\tu32\t\t\tinstance;\n\n\tu32\t\t\tentry_count;\n\tu32\t\t\tuse_count;\n\tu32\t\t\thdr_entry_size;\n\tu32\t\t\tfirst_burst_entry_size;\n\tu32\t\t\tdata_entry_size;\n\tbool\t\t\tis_mrq;\n\tu32\t\t\tbase_mrq_id;\n\n\tstruct hw_cq\t\t*cq;\n\n\tu8\t\t\tfilter_mask;\n\tstruct sli4_queue\t*hdr;\n\tstruct sli4_queue\t*first_burst;\n\tstruct sli4_queue\t*data;\n\n\tstruct efc_hw_rq_buffer\t*hdr_buf;\n\tstruct efc_hw_rq_buffer\t*fb_buf;\n\tstruct efc_hw_rq_buffer\t*payload_buf;\n\t \n\tstruct efc_hw_sequence\t**rq_tracker;\n};\n\nstruct efct_hw_send_frame_context {\n\tstruct efct_hw\t\t*hw;\n\tstruct hw_wq_callback\t*wqcb;\n\tstruct efct_hw_wqe\twqe;\n\tvoid (*callback)(int status, void *arg);\n\tvoid\t\t\t*arg;\n\n\t \n\tstruct efc_hw_sequence\t*seq;\n\tstruct efc_dma\t\tpayload;\n};\n\nstruct efct_hw_grp_hdr {\n\tu32\t\t\tsize;\n\t__be32\t\t\tmagic_number;\n\tu32\t\t\tword2;\n\tu8\t\t\trev_name[128];\n\tu8\t\t\tdate[12];\n\tu8\t\t\trevision[32];\n};\n\nstatic inline int\nefct_hw_get_link_speed(struct efct_hw *hw) {\n\treturn hw->link.speed;\n}\n\nint\nefct_hw_setup(struct efct_hw *hw, void *os, struct pci_dev *pdev);\nint efct_hw_init(struct efct_hw *hw);\nint\nefct_hw_parse_filter(struct efct_hw *hw, void *value);\nint\nefct_hw_init_queues(struct efct_hw *hw);\nint\nefct_hw_map_wq_cpu(struct efct_hw *hw);\nuint64_t\nefct_get_wwnn(struct efct_hw *hw);\nuint64_t\nefct_get_wwpn(struct efct_hw *hw);\n\nint efct_hw_rx_allocate(struct efct_hw *hw);\nint efct_hw_rx_post(struct efct_hw *hw);\nvoid efct_hw_rx_free(struct efct_hw *hw);\nint\nefct_hw_command(struct efct_hw *hw, u8 *cmd, u32 opts, void *cb,\n\t\tvoid *arg);\nint\nefct_issue_mbox_rqst(void *base, void *cmd, void *cb, void *arg);\n\nstruct efct_hw_io *efct_hw_io_alloc(struct efct_hw *hw);\nint efct_hw_io_free(struct efct_hw *hw, struct efct_hw_io *io);\nu8 efct_hw_io_inuse(struct efct_hw *hw, struct efct_hw_io *io);\nint\nefct_hw_io_send(struct efct_hw *hw, enum efct_hw_io_type type,\n\t\tstruct efct_hw_io *io, union efct_hw_io_param_u *iparam,\n\t\tvoid *cb, void *arg);\nint\nefct_hw_io_register_sgl(struct efct_hw *hw, struct efct_hw_io *io,\n\t\t\tstruct efc_dma *sgl,\n\t\t\tu32 sgl_count);\nint\nefct_hw_io_init_sges(struct efct_hw *hw,\n\t\t     struct efct_hw_io *io, enum efct_hw_io_type type);\n\nint\nefct_hw_io_add_sge(struct efct_hw *hw, struct efct_hw_io *io,\n\t\t   uintptr_t addr, u32 length);\nint\nefct_hw_io_abort(struct efct_hw *hw, struct efct_hw_io *io_to_abort,\n\t\t bool send_abts, void *cb, void *arg);\nu32\nefct_hw_io_get_count(struct efct_hw *hw,\n\t\t     enum efct_hw_io_count_type io_count_type);\nstruct efct_hw_io\n*efct_hw_io_lookup(struct efct_hw *hw, u32 indicator);\nvoid efct_hw_io_abort_all(struct efct_hw *hw);\nvoid efct_hw_io_free_internal(struct kref *arg);\n\n \nstruct reqtag_pool *efct_hw_reqtag_pool_alloc(struct efct_hw *hw);\nvoid efct_hw_reqtag_pool_free(struct efct_hw *hw);\nstruct hw_wq_callback\n*efct_hw_reqtag_alloc(struct efct_hw *hw,\n\t\t\tvoid (*callback)(void *arg, u8 *cqe,\n\t\t\t\t\t int status), void *arg);\nvoid\nefct_hw_reqtag_free(struct efct_hw *hw, struct hw_wq_callback *wqcb);\nstruct hw_wq_callback\n*efct_hw_reqtag_get_instance(struct efct_hw *hw, u32 instance_index);\n\n \nint\nefct_hw_rqpair_process_rq(struct efct_hw *hw,\n\t\t\t  struct hw_cq *cq, u8 *cqe);\nint\nefct_hw_rqpair_sequence_free(struct efct_hw *hw, struct efc_hw_sequence *seq);\nstatic inline void\nefct_hw_sequence_copy(struct efc_hw_sequence *dst,\n\t\t      struct efc_hw_sequence *src)\n{\n\t \n\t*dst = *src;\n}\n\nint\nefct_efc_hw_sequence_free(struct efc *efc, struct efc_hw_sequence *seq);\n\nstatic inline int\nefct_hw_sequence_free(struct efct_hw *hw, struct efc_hw_sequence *seq)\n{\n\t \n\treturn efct_hw_rqpair_sequence_free(hw, seq);\n}\n\nint\nefct_hw_eq_process(struct efct_hw *hw, struct hw_eq *eq,\n\t\t   u32 max_isr_time_msec);\nvoid efct_hw_cq_process(struct efct_hw *hw, struct hw_cq *cq);\nvoid\nefct_hw_wq_process(struct efct_hw *hw, struct hw_cq *cq,\n\t\t   u8 *cqe, int status, u16 rid);\nvoid\nefct_hw_xabt_process(struct efct_hw *hw, struct hw_cq *cq,\n\t\t     u8 *cqe, u16 rid);\nint\nefct_hw_process(struct efct_hw *hw, u32 vector, u32 max_isr_time_msec);\nint\nefct_hw_queue_hash_find(struct efct_queue_hash *hash, u16 id);\nint efct_hw_wq_write(struct hw_wq *wq, struct efct_hw_wqe *wqe);\nint\nefct_hw_send_frame(struct efct_hw *hw, struct fc_frame_header *hdr,\n\t\t   u8 sof, u8 eof, struct efc_dma *payload,\n\t\tstruct efct_hw_send_frame_context *ctx,\n\t\tvoid (*callback)(void *arg, u8 *cqe, int status),\n\t\tvoid *arg);\nint\nefct_els_hw_srrs_send(struct efc *efc, struct efc_disc_io *io);\nint\nefct_efc_bls_send(struct efc *efc, u32 type, struct sli_bls_params *bls);\nint\nefct_hw_bls_send(struct efct *efct, u32 type, struct sli_bls_params *bls_params,\n\t\t void *cb, void *arg);\n\n \nint\nefct_hw_get_link_stats(struct efct_hw *hw,\n\t\t       u8 req_ext_counters,\n\t\t       u8 clear_overflow_flags,\n\t\t       u8 clear_all_counters,\n\t\t       void (*efct_hw_link_stat_cb_t)(int status,\n\t\t\t\t\t\t      u32 num_counters,\n\t\t       struct efct_hw_link_stat_counts *counters, void *arg),\n\t\t       void *arg);\n \nint\nefct_hw_get_host_stats(struct efct_hw *hw,\n\t\t       u8 cc,\n\t\t       void (*efct_hw_host_stat_cb_t)(int status,\n\t\t\t\t\t\t      u32 num_counters,\n\t\t       struct efct_hw_host_stat_counts *counters, void *arg),\n\t\t       void *arg);\nint\nefct_hw_firmware_write(struct efct_hw *hw, struct efc_dma *dma,\n\t\t       u32 size, u32 offset, int last,\n\t\t       void (*cb)(int status, u32 bytes_written,\n\t\t\t\t  u32 change_status, void *arg),\n\t\t       void *arg);\ntypedef void (*efct_hw_async_cb_t)(struct efct_hw *hw, int status,\n\t\t\t\t  u8 *mqe, void *arg);\nint\nefct_hw_async_call(struct efct_hw *hw, efct_hw_async_cb_t callback, void *arg);\n\nstruct hw_eq *efct_hw_new_eq(struct efct_hw *hw, u32 entry_count);\nstruct hw_cq *efct_hw_new_cq(struct hw_eq *eq, u32 entry_count);\nu32\nefct_hw_new_cq_set(struct hw_eq *eqs[], struct hw_cq *cqs[],\n\t\t   u32 num_cqs, u32 entry_count);\nstruct hw_mq *efct_hw_new_mq(struct hw_cq *cq, u32 entry_count);\nstruct hw_wq\n*efct_hw_new_wq(struct hw_cq *cq, u32 entry_count);\nu32\nefct_hw_new_rq_set(struct hw_cq *cqs[], struct hw_rq *rqs[],\n\t\t   u32 num_rq_pairs, u32 entry_count);\nvoid efct_hw_del_eq(struct hw_eq *eq);\nvoid efct_hw_del_cq(struct hw_cq *cq);\nvoid efct_hw_del_mq(struct hw_mq *mq);\nvoid efct_hw_del_wq(struct hw_wq *wq);\nvoid efct_hw_del_rq(struct hw_rq *rq);\nvoid efct_hw_queue_teardown(struct efct_hw *hw);\nvoid efct_hw_teardown(struct efct_hw *hw);\nint\nefct_hw_reset(struct efct_hw *hw, enum efct_hw_reset reset);\n\nint\nefct_hw_port_control(struct efct_hw *hw, enum efct_hw_port ctrl,\n\t\t     uintptr_t value,\n\t\tvoid (*cb)(int status, uintptr_t value, void *arg),\n\t\tvoid *arg);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}