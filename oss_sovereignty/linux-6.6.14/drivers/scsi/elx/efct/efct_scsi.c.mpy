{
  "module_name": "efct_scsi.c",
  "hash_id": "719ed3fc8c70b5c9078d49ecf67e7ad523ea3b6b54f6c751e9de64118d84f653",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/efct/efct_scsi.c",
  "human_readable_source": "\n \n\n#include \"efct_driver.h\"\n#include \"efct_hw.h\"\n\n#define enable_tsend_auto_resp(efct)\t1\n#define enable_treceive_auto_resp(efct)\t0\n\n#define SCSI_IOFMT \"[%04x][i:%04x t:%04x h:%04x]\"\n\n#define scsi_io_printf(io, fmt, ...) \\\n\tefc_log_debug(io->efct, \"[%s]\" SCSI_IOFMT fmt, \\\n\t\tio->node->display_name, io->instance_index,\\\n\t\tio->init_task_tag, io->tgt_task_tag, io->hw_tag, ##__VA_ARGS__)\n\n#define EFCT_LOG_ENABLE_SCSI_TRACE(efct)                \\\n\t\t(((efct) != NULL) ? (((efct)->logmask & (1U << 2)) != 0) : 0)\n\n#define scsi_io_trace(io, fmt, ...) \\\n\tdo { \\\n\t\tif (EFCT_LOG_ENABLE_SCSI_TRACE(io->efct)) \\\n\t\t\tscsi_io_printf(io, fmt, ##__VA_ARGS__); \\\n\t} while (0)\n\nstruct efct_io *\nefct_scsi_io_alloc(struct efct_node *node)\n{\n\tstruct efct *efct;\n\tstruct efct_xport *xport;\n\tstruct efct_io *io;\n\tunsigned long flags;\n\n\tefct = node->efct;\n\n\txport = efct->xport;\n\n\tio = efct_io_pool_io_alloc(efct->xport->io_pool);\n\tif (!io) {\n\t\tefc_log_err(efct, \"IO alloc Failed\\n\");\n\t\tatomic_add_return(1, &xport->io_alloc_failed_count);\n\t\treturn NULL;\n\t}\n\n\t \n\tkref_init(&io->ref);\n\tio->release = _efct_scsi_io_free;\n\n\t \n\tio->efct = efct;\n\tio->node = node;\n\tkref_get(&node->ref);\n\n\t \n\tio->io_type = EFCT_IO_TYPE_IO;\n\tio->display_name = \"scsi_io\";\n\n\tio->cmd_ini = false;\n\tio->cmd_tgt = true;\n\n\t \n\tINIT_LIST_HEAD(&io->list_entry);\n\tspin_lock_irqsave(&node->active_ios_lock, flags);\n\tlist_add(&io->list_entry, &node->active_ios);\n\n\tspin_unlock_irqrestore(&node->active_ios_lock, flags);\n\n\treturn io;\n}\n\nvoid\n_efct_scsi_io_free(struct kref *arg)\n{\n\tstruct efct_io *io = container_of(arg, struct efct_io, ref);\n\tstruct efct *efct = io->efct;\n\tstruct efct_node *node = io->node;\n\tunsigned long flags = 0;\n\n\tscsi_io_trace(io, \"freeing io 0x%p %s\\n\", io, io->display_name);\n\n\tif (io->io_free) {\n\t\tefc_log_err(efct, \"IO already freed.\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&node->active_ios_lock, flags);\n\tlist_del_init(&io->list_entry);\n\tspin_unlock_irqrestore(&node->active_ios_lock, flags);\n\n\tkref_put(&node->ref, node->release);\n\tio->node = NULL;\n\tefct_io_pool_io_free(efct->xport->io_pool, io);\n}\n\nvoid\nefct_scsi_io_free(struct efct_io *io)\n{\n\tscsi_io_trace(io, \"freeing io 0x%p %s\\n\", io, io->display_name);\n\tWARN_ON(!refcount_read(&io->ref.refcount));\n\tkref_put(&io->ref, io->release);\n}\n\nstatic void\nefct_target_io_cb(struct efct_hw_io *hio, u32 length, int status,\n\t\t  u32 ext_status, void *app)\n{\n\tu32 flags = 0;\n\tstruct efct_io *io = app;\n\tstruct efct *efct;\n\tenum efct_scsi_io_status scsi_stat = EFCT_SCSI_STATUS_GOOD;\n\tefct_scsi_io_cb_t cb;\n\n\tif (!io || !io->efct) {\n\t\tpr_err(\"%s: IO can not be NULL\\n\", __func__);\n\t\treturn;\n\t}\n\n\tscsi_io_trace(io, \"status x%x ext_status x%x\\n\", status, ext_status);\n\n\tefct = io->efct;\n\n\tio->transferred += length;\n\n\tif (!io->scsi_tgt_cb) {\n\t\tefct_scsi_check_pending(efct);\n\t\treturn;\n\t}\n\n\t \n\tcb = io->scsi_tgt_cb;\n\n\t \n\tio->scsi_tgt_cb = NULL;\n\n\t \n\tif (status == 0 && io->auto_resp)\n\t\tflags |= EFCT_SCSI_IO_CMPL_RSP_SENT;\n\telse\n\t\tflags |= EFCT_SCSI_IO_CMPL;\n\n\tswitch (status) {\n\tcase SLI4_FC_WCQE_STATUS_SUCCESS:\n\t\tscsi_stat = EFCT_SCSI_STATUS_GOOD;\n\t\tbreak;\n\tcase SLI4_FC_WCQE_STATUS_DI_ERROR:\n\t\tif (ext_status & SLI4_FC_DI_ERROR_GE)\n\t\t\tscsi_stat = EFCT_SCSI_STATUS_DIF_GUARD_ERR;\n\t\telse if (ext_status & SLI4_FC_DI_ERROR_AE)\n\t\t\tscsi_stat = EFCT_SCSI_STATUS_DIF_APP_TAG_ERROR;\n\t\telse if (ext_status & SLI4_FC_DI_ERROR_RE)\n\t\t\tscsi_stat = EFCT_SCSI_STATUS_DIF_REF_TAG_ERROR;\n\t\telse\n\t\t\tscsi_stat = EFCT_SCSI_STATUS_DIF_UNKNOWN_ERROR;\n\t\tbreak;\n\tcase SLI4_FC_WCQE_STATUS_LOCAL_REJECT:\n\t\tswitch (ext_status) {\n\t\tcase SLI4_FC_LOCAL_REJECT_INVALID_RELOFFSET:\n\t\tcase SLI4_FC_LOCAL_REJECT_ABORT_REQUESTED:\n\t\t\tscsi_stat = EFCT_SCSI_STATUS_ABORTED;\n\t\t\tbreak;\n\t\tcase SLI4_FC_LOCAL_REJECT_INVALID_RPI:\n\t\t\tscsi_stat = EFCT_SCSI_STATUS_NEXUS_LOST;\n\t\t\tbreak;\n\t\tcase SLI4_FC_LOCAL_REJECT_NO_XRI:\n\t\t\tscsi_stat = EFCT_SCSI_STATUS_NO_IO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tscsi_stat = EFCT_SCSI_STATUS_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SLI4_FC_WCQE_STATUS_TARGET_WQE_TIMEOUT:\n\t\t \n\t\tscsi_stat = EFCT_SCSI_STATUS_TIMEDOUT_AND_ABORTED;\n\t\tbreak;\n\n\tcase SLI4_FC_WCQE_STATUS_SHUTDOWN:\n\t\t \n\t\tscsi_stat = EFCT_SCSI_STATUS_SHUTDOWN;\n\t\tbreak;\n\n\tdefault:\n\t\tscsi_stat = EFCT_SCSI_STATUS_ERROR;\n\t\tbreak;\n\t}\n\n\tcb(io, scsi_stat, flags, io->scsi_tgt_cb_arg);\n\n\tefct_scsi_check_pending(efct);\n}\n\nstatic int\nefct_scsi_build_sgls(struct efct_hw *hw, struct efct_hw_io *hio,\n\t\t     struct efct_scsi_sgl *sgl, u32 sgl_count,\n\t\t     enum efct_hw_io_type type)\n{\n\tint rc;\n\tu32 i;\n\tstruct efct *efct = hw->os;\n\n\t \n\trc = efct_hw_io_init_sges(hw, hio, type);\n\tif (rc) {\n\t\tefc_log_err(efct, \"efct_hw_io_init_sges failed: %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < sgl_count; i++) {\n\t\t \n\t\trc = efct_hw_io_add_sge(hw, hio, sgl[i].addr, sgl[i].len);\n\t\tif (rc) {\n\t\t\tefc_log_err(efct, \"add sge failed cnt=%d rc=%d\\n\",\n\t\t\t\t    sgl_count, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void efc_log_sgl(struct efct_io *io)\n{\n\tstruct efct_hw_io *hio = io->hio;\n\tstruct sli4_sge *data = NULL;\n\tu32 *dword = NULL;\n\tu32 i;\n\tu32 n_sge;\n\n\tscsi_io_trace(io, \"def_sgl at 0x%x 0x%08x\\n\",\n\t\t      upper_32_bits(hio->def_sgl.phys),\n\t\t      lower_32_bits(hio->def_sgl.phys));\n\tn_sge = (hio->sgl == &hio->def_sgl) ? hio->n_sge : hio->def_sgl_count;\n\tfor (i = 0, data = hio->def_sgl.virt; i < n_sge; i++, data++) {\n\t\tdword = (u32 *)data;\n\n\t\tscsi_io_trace(io, \"SGL %2d 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t      i, dword[0], dword[1], dword[2], dword[3]);\n\n\t\tif (dword[2] & (1U << 31))\n\t\t\tbreak;\n\t}\n}\n\nstatic void\nefct_scsi_check_pending_async_cb(struct efct_hw *hw, int status,\n\t\t\t\t u8 *mqe, void *arg)\n{\n\tstruct efct_io *io = arg;\n\n\tif (io) {\n\t\tefct_hw_done_t cb = io->hw_cb;\n\n\t\tif (!io->hw_cb)\n\t\t\treturn;\n\n\t\tio->hw_cb = NULL;\n\t\t(cb)(io->hio, 0, SLI4_FC_WCQE_STATUS_DISPATCH_ERROR, 0, io);\n\t}\n}\n\nstatic int\nefct_scsi_io_dispatch_hw_io(struct efct_io *io, struct efct_hw_io *hio)\n{\n\tint rc = 0;\n\tstruct efct *efct = io->efct;\n\n\t \n\tio->hio = hio;\n\tif (io->cmd_tgt)\n\t\tio->tgt_task_tag = hio->indicator;\n\telse if (io->cmd_ini)\n\t\tio->init_task_tag = hio->indicator;\n\tio->hw_tag = hio->reqtag;\n\n\thio->eq = io->hw_priv;\n\n\t \n\tswitch (io->wq_steering) {\n\tcase EFCT_SCSI_WQ_STEERING_CLASS >> EFCT_SCSI_WQ_STEERING_SHIFT:\n\t\thio->wq_steering = EFCT_HW_WQ_STEERING_CLASS;\n\t\tbreak;\n\tcase EFCT_SCSI_WQ_STEERING_REQUEST >> EFCT_SCSI_WQ_STEERING_SHIFT:\n\t\thio->wq_steering = EFCT_HW_WQ_STEERING_REQUEST;\n\t\tbreak;\n\tcase EFCT_SCSI_WQ_STEERING_CPU >> EFCT_SCSI_WQ_STEERING_SHIFT:\n\t\thio->wq_steering = EFCT_HW_WQ_STEERING_CPU;\n\t\tbreak;\n\t}\n\n\tswitch (io->io_type) {\n\tcase EFCT_IO_TYPE_IO:\n\t\trc = efct_scsi_build_sgls(&efct->hw, io->hio,\n\t\t\t\t\t  io->sgl, io->sgl_count, io->hio_type);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tif (EFCT_LOG_ENABLE_SCSI_TRACE(efct))\n\t\t\tefc_log_sgl(io);\n\n\t\tif (io->app_id)\n\t\t\tio->iparam.fcp_tgt.app_id = io->app_id;\n\n\t\tio->iparam.fcp_tgt.vpi = io->node->vpi;\n\t\tio->iparam.fcp_tgt.rpi = io->node->rpi;\n\t\tio->iparam.fcp_tgt.s_id = io->node->port_fc_id;\n\t\tio->iparam.fcp_tgt.d_id = io->node->node_fc_id;\n\t\tio->iparam.fcp_tgt.xmit_len = io->wire_len;\n\n\t\trc = efct_hw_io_send(&io->efct->hw, io->hio_type, io->hio,\n\t\t\t\t     &io->iparam, io->hw_cb, io);\n\t\tbreak;\n\tdefault:\n\t\tscsi_io_printf(io, \"Unknown IO type=%d\\n\", io->io_type);\n\t\trc = -EIO;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic int\nefct_scsi_io_dispatch_no_hw_io(struct efct_io *io)\n{\n\tint rc;\n\n\tswitch (io->io_type) {\n\tcase EFCT_IO_TYPE_ABORT: {\n\t\tstruct efct_hw_io *hio_to_abort = NULL;\n\n\t\thio_to_abort = io->io_to_abort->hio;\n\n\t\tif (!hio_to_abort) {\n\t\t\t \n\t\t\tscsi_io_printf(io, \"IO: not active\\n\");\n\t\t\t((efct_hw_done_t)io->hw_cb)(io->hio, 0,\n\t\t\t\t\tSLI4_FC_WCQE_STATUS_SUCCESS, 0, io);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tscsi_io_printf(io, \"aborting\\n\");\n\t\trc = efct_hw_io_abort(&io->efct->hw, hio_to_abort,\n\t\t\t\t      io->send_abts, io->hw_cb, io);\n\t\tif (rc) {\n\t\t\tint status = SLI4_FC_WCQE_STATUS_SUCCESS;\n\t\t\tefct_hw_done_t cb = io->hw_cb;\n\n\t\t\tif (rc != -ENOENT && rc != -EINPROGRESS) {\n\t\t\t\tstatus = -1;\n\t\t\t\tscsi_io_printf(io, \"Failed to abort IO rc=%d\\n\",\n\t\t\t\t\t       rc);\n\t\t\t}\n\t\t\tcb(io->hio, 0, status, 0, io);\n\t\t\trc = 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tscsi_io_printf(io, \"Unknown IO type=%d\\n\", io->io_type);\n\t\trc = -EIO;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic struct efct_io *\nefct_scsi_dispatch_pending(struct efct *efct)\n{\n\tstruct efct_xport *xport = efct->xport;\n\tstruct efct_io *io = NULL;\n\tstruct efct_hw_io *hio;\n\tunsigned long flags = 0;\n\tint status;\n\n\tspin_lock_irqsave(&xport->io_pending_lock, flags);\n\n\tif (!list_empty(&xport->io_pending_list)) {\n\t\tio = list_first_entry(&xport->io_pending_list, struct efct_io,\n\t\t\t\t      io_pending_link);\n\t\tlist_del_init(&io->io_pending_link);\n\t}\n\n\tif (!io) {\n\t\tspin_unlock_irqrestore(&xport->io_pending_lock, flags);\n\t\treturn NULL;\n\t}\n\n\tif (io->io_type == EFCT_IO_TYPE_ABORT) {\n\t\thio = NULL;\n\t} else {\n\t\thio = efct_hw_io_alloc(&efct->hw);\n\t\tif (!hio) {\n\t\t\t \n\t\t\tlist_add(&xport->io_pending_list, &io->io_pending_link);\n\t\t\tio = NULL;\n\t\t} else {\n\t\t\thio->eq = io->hw_priv;\n\t\t}\n\t}\n\n\t \n\tspin_unlock_irqrestore(&xport->io_pending_lock, flags);\n\n\tif (!io)\n\t\treturn NULL;\n\n\t \n\tatomic_sub_return(1, &xport->io_pending_count);\n\tif (!hio)\n\t\tstatus = efct_scsi_io_dispatch_no_hw_io(io);\n\telse\n\t\tstatus = efct_scsi_io_dispatch_hw_io(io, hio);\n\tif (status) {\n\t\t \n\t\tif (efct_hw_async_call(&efct->hw,\n\t\t\t\t       efct_scsi_check_pending_async_cb, io)) {\n\t\t\tefc_log_debug(efct, \"call hw async failed\\n\");\n\t\t}\n\t}\n\n\treturn io;\n}\n\nvoid\nefct_scsi_check_pending(struct efct *efct)\n{\n\tstruct efct_xport *xport = efct->xport;\n\tstruct efct_io *io = NULL;\n\tint count = 0;\n\tunsigned long flags = 0;\n\tint dispatch = 0;\n\n\t \n\tif (atomic_add_return(1, &xport->io_pending_recursing)) {\n\t\t \n\t\tatomic_sub_return(1, &xport->io_pending_recursing);\n\t\treturn;\n\t}\n\n\twhile (efct_scsi_dispatch_pending(efct))\n\t\tcount++;\n\n\tif (count) {\n\t\tatomic_sub_return(1, &xport->io_pending_recursing);\n\t\treturn;\n\t}\n\n\t \n\n\tspin_lock_irqsave(&xport->io_pending_lock, flags);\n\n\tlist_for_each_entry(io, &xport->io_pending_list, io_pending_link) {\n\t\tif (io->io_type == EFCT_IO_TYPE_ABORT && io->io_to_abort->hio) {\n\t\t\t \n\t\t\tdispatch = 1;\n\t\t\tlist_del_init(&io->io_pending_link);\n\t\t\tatomic_sub_return(1, &xport->io_pending_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&xport->io_pending_lock, flags);\n\n\tif (dispatch) {\n\t\tif (efct_scsi_io_dispatch_no_hw_io(io)) {\n\t\t\tif (efct_hw_async_call(&efct->hw,\n\t\t\t\tefct_scsi_check_pending_async_cb, io)) {\n\t\t\t\tefc_log_debug(efct, \"hw async failed\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tatomic_sub_return(1, &xport->io_pending_recursing);\n}\n\nint\nefct_scsi_io_dispatch(struct efct_io *io, void *cb)\n{\n\tstruct efct_hw_io *hio;\n\tstruct efct *efct = io->efct;\n\tstruct efct_xport *xport = efct->xport;\n\tunsigned long flags = 0;\n\n\tio->hw_cb = cb;\n\n\t \n\tif (io->hio)\n\t\treturn efct_scsi_io_dispatch_hw_io(io, io->hio);\n\n\t \n\tspin_lock_irqsave(&xport->io_pending_lock, flags);\n\tif (!list_empty(&xport->io_pending_list)) {\n\t\t \n\t\tif (io->low_latency) {\n\t\t\tINIT_LIST_HEAD(&io->io_pending_link);\n\t\t\tlist_add(&xport->io_pending_list, &io->io_pending_link);\n\t\t} else {\n\t\t\tINIT_LIST_HEAD(&io->io_pending_link);\n\t\t\tlist_add_tail(&io->io_pending_link,\n\t\t\t\t      &xport->io_pending_list);\n\t\t}\n\t\tspin_unlock_irqrestore(&xport->io_pending_lock, flags);\n\t\tatomic_add_return(1, &xport->io_pending_count);\n\t\tatomic_add_return(1, &xport->io_total_pending);\n\n\t\t \n\t\tefct_scsi_check_pending(efct);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&xport->io_pending_lock, flags);\n\n\t \n\thio = efct_hw_io_alloc(&io->efct->hw);\n\tif (!hio) {\n\t\t \n\t\tspin_lock_irqsave(&xport->io_pending_lock, flags);\n\t\tINIT_LIST_HEAD(&io->io_pending_link);\n\t\tlist_add_tail(&io->io_pending_link, &xport->io_pending_list);\n\t\tspin_unlock_irqrestore(&xport->io_pending_lock, flags);\n\n\t\tatomic_add_return(1, &xport->io_total_pending);\n\t\tatomic_add_return(1, &xport->io_pending_count);\n\t\treturn 0;\n\t}\n\n\t \n\treturn efct_scsi_io_dispatch_hw_io(io, hio);\n}\n\nint\nefct_scsi_io_dispatch_abort(struct efct_io *io, void *cb)\n{\n\tstruct efct *efct = io->efct;\n\tstruct efct_xport *xport = efct->xport;\n\tunsigned long flags = 0;\n\n\tio->hw_cb = cb;\n\n\t \n\tspin_lock_irqsave(&xport->io_pending_lock, flags);\n\tif (!list_empty(&xport->io_pending_list)) {\n\t\tINIT_LIST_HEAD(&io->io_pending_link);\n\t\tlist_add_tail(&io->io_pending_link, &xport->io_pending_list);\n\t\tspin_unlock_irqrestore(&xport->io_pending_lock, flags);\n\t\tatomic_add_return(1, &xport->io_pending_count);\n\t\tatomic_add_return(1, &xport->io_total_pending);\n\n\t\t \n\t\tefct_scsi_check_pending(efct);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&xport->io_pending_lock, flags);\n\n\t \n\treturn efct_scsi_io_dispatch_no_hw_io(io);\n}\n\nstatic inline int\nefct_scsi_xfer_data(struct efct_io *io, u32 flags,\n\t\t    struct efct_scsi_sgl *sgl, u32 sgl_count, u64 xwire_len,\n\t\t    enum efct_hw_io_type type, int enable_ar,\n\t\t    efct_scsi_io_cb_t cb, void *arg)\n{\n\tstruct efct *efct;\n\tsize_t residual = 0;\n\n\tio->sgl_count = sgl_count;\n\n\tefct = io->efct;\n\n\tscsi_io_trace(io, \"%s wire_len %llu\\n\",\n\t\t      (type == EFCT_HW_IO_TARGET_READ) ? \"send\" : \"recv\",\n\t\t      xwire_len);\n\n\tio->hio_type = type;\n\n\tio->scsi_tgt_cb = cb;\n\tio->scsi_tgt_cb_arg = arg;\n\n\tresidual = io->exp_xfer_len - io->transferred;\n\tio->wire_len = (xwire_len < residual) ? xwire_len : residual;\n\tresidual = (xwire_len - io->wire_len);\n\n\tmemset(&io->iparam, 0, sizeof(io->iparam));\n\tio->iparam.fcp_tgt.ox_id = io->init_task_tag;\n\tio->iparam.fcp_tgt.offset = io->transferred;\n\tio->iparam.fcp_tgt.cs_ctl = io->cs_ctl;\n\tio->iparam.fcp_tgt.timeout = io->timeout;\n\n\t \n\tif (enable_ar && (flags & EFCT_SCSI_LAST_DATAPHASE) && residual == 0 &&\n\t    ((io->transferred + io->wire_len) == io->exp_xfer_len) &&\n\t    (!(flags & EFCT_SCSI_NO_AUTO_RESPONSE))) {\n\t\tio->iparam.fcp_tgt.flags |= SLI4_IO_AUTO_GOOD_RESPONSE;\n\t\tio->auto_resp = true;\n\t} else {\n\t\tio->auto_resp = false;\n\t}\n\n\t \n\tio->xfer_req = io->wire_len;\n\n\t \n\tio->transferred += residual;\n\n\t \n\n\tif (residual) {\n\t\tstruct efct_scsi_sgl  *sgl_ptr = &io->sgl[sgl_count - 1];\n\n\t\twhile (residual) {\n\t\t\tsize_t len = sgl_ptr->len;\n\n\t\t\tif (len > residual) {\n\t\t\t\tsgl_ptr->len = len - residual;\n\t\t\t\tresidual = 0;\n\t\t\t} else {\n\t\t\t\tsgl_ptr->len = 0;\n\t\t\t\tresidual -= len;\n\t\t\t\tio->sgl_count--;\n\t\t\t}\n\t\t\tsgl_ptr--;\n\t\t}\n\t}\n\n\t \n\tio->low_latency = (flags & EFCT_SCSI_LOW_LATENCY) != 0;\n\tio->wq_steering = (flags & EFCT_SCSI_WQ_STEERING_MASK) >>\n\t\t\t\tEFCT_SCSI_WQ_STEERING_SHIFT;\n\tio->wq_class = (flags & EFCT_SCSI_WQ_CLASS_MASK) >>\n\t\t\t\tEFCT_SCSI_WQ_CLASS_SHIFT;\n\n\tif (efct->xport) {\n\t\tstruct efct_xport *xport = efct->xport;\n\n\t\tif (type == EFCT_HW_IO_TARGET_READ) {\n\t\t\txport->fcp_stats.input_requests++;\n\t\t\txport->fcp_stats.input_bytes += xwire_len;\n\t\t} else if (type == EFCT_HW_IO_TARGET_WRITE) {\n\t\t\txport->fcp_stats.output_requests++;\n\t\t\txport->fcp_stats.output_bytes += xwire_len;\n\t\t}\n\t}\n\treturn efct_scsi_io_dispatch(io, efct_target_io_cb);\n}\n\nint\nefct_scsi_send_rd_data(struct efct_io *io, u32 flags,\n\t\t       struct efct_scsi_sgl *sgl, u32 sgl_count, u64 len,\n\t\t       efct_scsi_io_cb_t cb, void *arg)\n{\n\treturn efct_scsi_xfer_data(io, flags, sgl, sgl_count,\n\t\t\t\t   len, EFCT_HW_IO_TARGET_READ,\n\t\t\t\t   enable_tsend_auto_resp(io->efct), cb, arg);\n}\n\nint\nefct_scsi_recv_wr_data(struct efct_io *io, u32 flags,\n\t\t       struct efct_scsi_sgl *sgl, u32 sgl_count, u64 len,\n\t\t       efct_scsi_io_cb_t cb, void *arg)\n{\n\treturn efct_scsi_xfer_data(io, flags, sgl, sgl_count, len,\n\t\t\t\t   EFCT_HW_IO_TARGET_WRITE,\n\t\t\t\t   enable_treceive_auto_resp(io->efct), cb, arg);\n}\n\nint\nefct_scsi_send_resp(struct efct_io *io, u32 flags,\n\t\t    struct efct_scsi_cmd_resp *rsp,\n\t\t    efct_scsi_io_cb_t cb, void *arg)\n{\n\tstruct efct *efct;\n\tint residual;\n\t \n\tbool auto_resp = true;\n\tu8 scsi_status = 0;\n\tu16 scsi_status_qualifier = 0;\n\tu8 *sense_data = NULL;\n\tu32 sense_data_length = 0;\n\n\tefct = io->efct;\n\n\tif (rsp) {\n\t\tscsi_status = rsp->scsi_status;\n\t\tscsi_status_qualifier = rsp->scsi_status_qualifier;\n\t\tsense_data = rsp->sense_data;\n\t\tsense_data_length = rsp->sense_data_length;\n\t\tresidual = rsp->residual;\n\t} else {\n\t\tresidual = io->exp_xfer_len - io->transferred;\n\t}\n\n\tio->wire_len = 0;\n\tio->hio_type = EFCT_HW_IO_TARGET_RSP;\n\n\tio->scsi_tgt_cb = cb;\n\tio->scsi_tgt_cb_arg = arg;\n\n\tmemset(&io->iparam, 0, sizeof(io->iparam));\n\tio->iparam.fcp_tgt.ox_id = io->init_task_tag;\n\tio->iparam.fcp_tgt.offset = 0;\n\tio->iparam.fcp_tgt.cs_ctl = io->cs_ctl;\n\tio->iparam.fcp_tgt.timeout = io->timeout;\n\n\t \n\tio->low_latency = (flags & EFCT_SCSI_LOW_LATENCY) != 0;\n\tio->wq_steering = (flags & EFCT_SCSI_WQ_STEERING_MASK) >>\n\t\t\t\tEFCT_SCSI_WQ_STEERING_SHIFT;\n\tio->wq_class = (flags & EFCT_SCSI_WQ_CLASS_MASK) >>\n\t\t\t\tEFCT_SCSI_WQ_CLASS_SHIFT;\n\n\tif (scsi_status != 0 || residual || sense_data_length) {\n\t\tstruct fcp_resp_with_ext *fcprsp = io->rspbuf.virt;\n\t\tu8 *sns_data;\n\n\t\tif (!fcprsp) {\n\t\t\tefc_log_err(efct, \"NULL response buffer\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tsns_data = (u8 *)io->rspbuf.virt + sizeof(*fcprsp);\n\n\t\tauto_resp = false;\n\n\t\tmemset(fcprsp, 0, sizeof(*fcprsp));\n\n\t\tio->wire_len += sizeof(*fcprsp);\n\n\t\tfcprsp->resp.fr_status = scsi_status;\n\t\tfcprsp->resp.fr_retry_delay =\n\t\t\tcpu_to_be16(scsi_status_qualifier);\n\n\t\t \n\t\tif (residual != 0) {\n\t\t\t \n\t\t\tif (residual > 0) {\n\t\t\t\tfcprsp->resp.fr_flags |= FCP_RESID_UNDER;\n\t\t\t\tfcprsp->ext.fr_resid =\tcpu_to_be32(residual);\n\t\t\t} else {\n\t\t\t\tfcprsp->resp.fr_flags |= FCP_RESID_OVER;\n\t\t\t\tfcprsp->ext.fr_resid = cpu_to_be32(-residual);\n\t\t\t}\n\t\t}\n\n\t\tif (EFCT_SCSI_SNS_BUF_VALID(sense_data) && sense_data_length) {\n\t\t\tif (sense_data_length > SCSI_SENSE_BUFFERSIZE) {\n\t\t\t\tefc_log_err(efct, \"Sense exceeds max size.\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tfcprsp->resp.fr_flags |= FCP_SNS_LEN_VAL;\n\t\t\tmemcpy(sns_data, sense_data, sense_data_length);\n\t\t\tfcprsp->ext.fr_sns_len = cpu_to_be32(sense_data_length);\n\t\t\tio->wire_len += sense_data_length;\n\t\t}\n\n\t\tio->sgl[0].addr = io->rspbuf.phys;\n\t\tio->sgl[0].dif_addr = 0;\n\t\tio->sgl[0].len = io->wire_len;\n\t\tio->sgl_count = 1;\n\t}\n\n\tif (auto_resp)\n\t\tio->iparam.fcp_tgt.flags |= SLI4_IO_AUTO_GOOD_RESPONSE;\n\n\treturn efct_scsi_io_dispatch(io, efct_target_io_cb);\n}\n\nstatic int\nefct_target_bls_resp_cb(struct efct_hw_io *hio,\tu32 length, int status,\n\t\t\tu32 ext_status, void *app)\n{\n\tstruct efct_io *io = app;\n\tstruct efct *efct;\n\tenum efct_scsi_io_status bls_status;\n\n\tefct = io->efct;\n\n\t \n\tif (status) {\n\t\tio_error_log(io, \"s=%#x x=%#x\\n\", status, ext_status);\n\t\tbls_status = EFCT_SCSI_STATUS_ERROR;\n\t} else {\n\t\tbls_status = EFCT_SCSI_STATUS_GOOD;\n\t}\n\n\tif (io->bls_cb) {\n\t\tefct_scsi_io_cb_t bls_cb = io->bls_cb;\n\t\tvoid *bls_cb_arg = io->bls_cb_arg;\n\n\t\tio->bls_cb = NULL;\n\t\tio->bls_cb_arg = NULL;\n\n\t\t \n\t\tbls_cb(io, bls_status, 0, bls_cb_arg);\n\t}\n\n\tefct_scsi_check_pending(efct);\n\treturn 0;\n}\n\nstatic int\nefct_target_send_bls_resp(struct efct_io *io,\n\t\t\t  efct_scsi_io_cb_t cb, void *arg)\n{\n\tstruct efct_node *node = io->node;\n\tstruct sli_bls_params *bls = &io->iparam.bls;\n\tstruct efct *efct = node->efct;\n\tstruct fc_ba_acc *acc;\n\tint rc;\n\n\t \n\tmemset(&io->iparam, 0, sizeof(io->iparam));\n\tbls->ox_id = io->init_task_tag;\n\tbls->rx_id = io->abort_rx_id;\n\tbls->vpi = io->node->vpi;\n\tbls->rpi = io->node->rpi;\n\tbls->s_id = U32_MAX;\n\tbls->d_id = io->node->node_fc_id;\n\tbls->rpi_registered = true;\n\n\tacc = (void *)bls->payload;\n\tacc->ba_ox_id = cpu_to_be16(bls->ox_id);\n\tacc->ba_rx_id = cpu_to_be16(bls->rx_id);\n\tacc->ba_high_seq_cnt = cpu_to_be16(U16_MAX);\n\n\t \n\n\t \n\tio->io_type = EFCT_IO_TYPE_BLS_RESP;\n\tio->display_name = \"bls_rsp\";\n\tio->hio_type = EFCT_HW_BLS_ACC;\n\tio->bls_cb = cb;\n\tio->bls_cb_arg = arg;\n\n\t \n\trc = efct_hw_bls_send(efct, FC_RCTL_BA_ACC, bls,\n\t\t\t      efct_target_bls_resp_cb, io);\n\treturn rc;\n}\n\nstatic int efct_bls_send_rjt_cb(struct efct_hw_io *hio, u32 length, int status,\n\t\t\t\tu32 ext_status, void *app)\n{\n\tstruct efct_io *io = app;\n\n\tefct_scsi_io_free(io);\n\treturn 0;\n}\n\nstruct efct_io *\nefct_bls_send_rjt(struct efct_io *io, struct fc_frame_header *hdr)\n{\n\tstruct efct_node *node = io->node;\n\tstruct sli_bls_params *bls = &io->iparam.bls;\n\tstruct efct *efct = node->efct;\n\tstruct fc_ba_rjt *acc;\n\tint rc;\n\n\t \n\tio->io_type = EFCT_IO_TYPE_BLS_RESP;\n\tio->display_name = \"ba_rjt\";\n\tio->hio_type = EFCT_HW_BLS_RJT;\n\tio->init_task_tag = be16_to_cpu(hdr->fh_ox_id);\n\n\t \n\tmemset(&io->iparam, 0, sizeof(io->iparam));\n\tbls->ox_id = be16_to_cpu(hdr->fh_ox_id);\n\tbls->rx_id = be16_to_cpu(hdr->fh_rx_id);\n\tbls->vpi = io->node->vpi;\n\tbls->rpi = io->node->rpi;\n\tbls->s_id = U32_MAX;\n\tbls->d_id = io->node->node_fc_id;\n\tbls->rpi_registered = true;\n\n\tacc = (void *)bls->payload;\n\tacc->br_reason = ELS_RJT_UNAB;\n\tacc->br_explan = ELS_EXPL_NONE;\n\n\trc = efct_hw_bls_send(efct, FC_RCTL_BA_RJT, bls, efct_bls_send_rjt_cb,\n\t\t\t      io);\n\tif (rc) {\n\t\tefc_log_err(efct, \"efct_scsi_io_dispatch() failed: %d\\n\", rc);\n\t\tefct_scsi_io_free(io);\n\t\tio = NULL;\n\t}\n\treturn io;\n}\n\nint\nefct_scsi_send_tmf_resp(struct efct_io *io,\n\t\t\tenum efct_scsi_tmf_resp rspcode,\n\t\t\tu8 addl_rsp_info[3],\n\t\t\tefct_scsi_io_cb_t cb, void *arg)\n{\n\tint rc;\n\tstruct {\n\t\tstruct fcp_resp_with_ext rsp_ext;\n\t\tstruct fcp_resp_rsp_info info;\n\t} *fcprsp;\n\tu8 fcp_rspcode;\n\n\tio->wire_len = 0;\n\n\tswitch (rspcode) {\n\tcase EFCT_SCSI_TMF_FUNCTION_COMPLETE:\n\t\tfcp_rspcode = FCP_TMF_CMPL;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_FUNCTION_SUCCEEDED:\n\tcase EFCT_SCSI_TMF_FUNCTION_IO_NOT_FOUND:\n\t\tfcp_rspcode = FCP_TMF_CMPL;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_FUNCTION_REJECTED:\n\t\tfcp_rspcode = FCP_TMF_REJECTED;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_INCORRECT_LOGICAL_UNIT_NUMBER:\n\t\tfcp_rspcode = FCP_TMF_INVALID_LUN;\n\t\tbreak;\n\tcase EFCT_SCSI_TMF_SERVICE_DELIVERY:\n\t\tfcp_rspcode = FCP_TMF_FAILED;\n\t\tbreak;\n\tdefault:\n\t\tfcp_rspcode = FCP_TMF_REJECTED;\n\t\tbreak;\n\t}\n\n\tio->hio_type = EFCT_HW_IO_TARGET_RSP;\n\n\tio->scsi_tgt_cb = cb;\n\tio->scsi_tgt_cb_arg = arg;\n\n\tif (io->tmf_cmd == EFCT_SCSI_TMF_ABORT_TASK) {\n\t\trc = efct_target_send_bls_resp(io, cb, arg);\n\t\treturn rc;\n\t}\n\n\t \n\tfcprsp = io->rspbuf.virt;\n\tmemset(fcprsp, 0, sizeof(*fcprsp));\n\n\tfcprsp->rsp_ext.resp.fr_flags |= FCP_SNS_LEN_VAL;\n\n\tif (addl_rsp_info) {\n\t\tmemcpy(fcprsp->info._fr_resvd, addl_rsp_info,\n\t\t       sizeof(fcprsp->info._fr_resvd));\n\t}\n\tfcprsp->info.rsp_code = fcp_rspcode;\n\n\tio->wire_len = sizeof(*fcprsp);\n\n\tfcprsp->rsp_ext.ext.fr_rsp_len =\n\t\t\tcpu_to_be32(sizeof(struct fcp_resp_rsp_info));\n\n\tio->sgl[0].addr = io->rspbuf.phys;\n\tio->sgl[0].dif_addr = 0;\n\tio->sgl[0].len = io->wire_len;\n\tio->sgl_count = 1;\n\n\tmemset(&io->iparam, 0, sizeof(io->iparam));\n\tio->iparam.fcp_tgt.ox_id = io->init_task_tag;\n\tio->iparam.fcp_tgt.offset = 0;\n\tio->iparam.fcp_tgt.cs_ctl = io->cs_ctl;\n\tio->iparam.fcp_tgt.timeout = io->timeout;\n\n\trc = efct_scsi_io_dispatch(io, efct_target_io_cb);\n\n\treturn rc;\n}\n\nstatic int\nefct_target_abort_cb(struct efct_hw_io *hio, u32 length, int status,\n\t\t     u32 ext_status, void *app)\n{\n\tstruct efct_io *io = app;\n\tstruct efct *efct;\n\tenum efct_scsi_io_status scsi_status;\n\tefct_scsi_io_cb_t abort_cb;\n\tvoid *abort_cb_arg;\n\n\tefct = io->efct;\n\n\tif (!io->abort_cb)\n\t\tgoto done;\n\n\tabort_cb = io->abort_cb;\n\tabort_cb_arg = io->abort_cb_arg;\n\n\tio->abort_cb = NULL;\n\tio->abort_cb_arg = NULL;\n\n\tswitch (status) {\n\tcase SLI4_FC_WCQE_STATUS_SUCCESS:\n\t\tscsi_status = EFCT_SCSI_STATUS_GOOD;\n\t\tbreak;\n\tcase SLI4_FC_WCQE_STATUS_LOCAL_REJECT:\n\t\tswitch (ext_status) {\n\t\tcase SLI4_FC_LOCAL_REJECT_NO_XRI:\n\t\t\tscsi_status = EFCT_SCSI_STATUS_NO_IO;\n\t\t\tbreak;\n\t\tcase SLI4_FC_LOCAL_REJECT_ABORT_IN_PROGRESS:\n\t\t\tscsi_status = EFCT_SCSI_STATUS_ABORT_IN_PROGRESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tscsi_status = EFCT_SCSI_STATUS_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SLI4_FC_WCQE_STATUS_FCP_RSP_FAILURE:\n\t\tscsi_status = EFCT_SCSI_STATUS_CHECK_RESPONSE;\n\t\tbreak;\n\tdefault:\n\t\tscsi_status = EFCT_SCSI_STATUS_ERROR;\n\t\tbreak;\n\t}\n\t \n\tabort_cb(io->io_to_abort, scsi_status, 0, abort_cb_arg);\n\ndone:\n\t \n\tkref_put(&io->io_to_abort->ref, io->io_to_abort->release);\n\n\tefct_io_pool_io_free(efct->xport->io_pool, io);\n\n\tefct_scsi_check_pending(efct);\n\treturn 0;\n}\n\nint\nefct_scsi_tgt_abort_io(struct efct_io *io, efct_scsi_io_cb_t cb, void *arg)\n{\n\tstruct efct *efct;\n\tstruct efct_xport *xport;\n\tint rc;\n\tstruct efct_io *abort_io = NULL;\n\n\tefct = io->efct;\n\txport = efct->xport;\n\n\t \n\tif (kref_get_unless_zero(&io->ref) == 0) {\n\t\t \n\t\tscsi_io_printf(io, \"command no longer active\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tabort_io = efct_io_pool_io_alloc(efct->xport->io_pool);\n\tif (!abort_io) {\n\t\tatomic_add_return(1, &xport->io_alloc_failed_count);\n\t\tkref_put(&io->ref, io->release);\n\t\treturn -EIO;\n\t}\n\n\t \n\t \n\tabort_io->cmd_tgt = true;\n\tabort_io->node = io->node;\n\n\t \n\tabort_io->io_type = EFCT_IO_TYPE_ABORT;\n\tabort_io->display_name = \"tgt_abort\";\n\tabort_io->io_to_abort = io;\n\tabort_io->send_abts = false;\n\tabort_io->abort_cb = cb;\n\tabort_io->abort_cb_arg = arg;\n\n\t \n\trc = efct_scsi_io_dispatch_abort(abort_io, efct_target_abort_cb);\n\tif (rc)\n\t\tkref_put(&io->ref, io->release);\n\treturn rc;\n}\n\nvoid\nefct_scsi_io_complete(struct efct_io *io)\n{\n\tif (io->io_free) {\n\t\tefc_log_debug(io->efct, \"completion for non-busy io tag 0x%x\\n\",\n\t\t\t      io->tag);\n\t\treturn;\n\t}\n\n\tscsi_io_trace(io, \"freeing io 0x%p %s\\n\", io, io->display_name);\n\tkref_put(&io->ref, io->release);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}