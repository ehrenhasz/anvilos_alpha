{
  "module_name": "efc_els.c",
  "hash_id": "00268522d217975cb597a680a3ae7cb1949398cb5bd377815729558adabc1cf1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/libefc/efc_els.c",
  "human_readable_source": "\n \n\n \n\n#include \"efc.h\"\n#include \"efc_els.h\"\n#include \"../libefc_sli/sli4.h\"\n\n#define EFC_LOG_ENABLE_ELS_TRACE(efc)\t\t\\\n\t\t(((efc) != NULL) ? (((efc)->logmask & (1U << 1)) != 0) : 0)\n\n#define node_els_trace()  \\\n\tdo { \\\n\t\tif (EFC_LOG_ENABLE_ELS_TRACE(efc)) \\\n\t\t\tefc_log_info(efc, \"[%s] %-20s\\n\", \\\n\t\t\t\tnode->display_name, __func__); \\\n\t} while (0)\n\n#define els_io_printf(els, fmt, ...) \\\n\tefc_log_err((struct efc *)els->node->efc,\\\n\t\t      \"[%s] %-8s \" fmt, \\\n\t\t      els->node->display_name,\\\n\t\t      els->display_name, ##__VA_ARGS__)\n\n#define EFC_ELS_RSP_LEN\t\t\t1024\n#define EFC_ELS_GID_PT_RSP_LEN\t\t8096\n\nstruct efc_els_io_req *\nefc_els_io_alloc(struct efc_node *node, u32 reqlen)\n{\n\treturn efc_els_io_alloc_size(node, reqlen, EFC_ELS_RSP_LEN);\n}\n\nstruct efc_els_io_req *\nefc_els_io_alloc_size(struct efc_node *node, u32 reqlen, u32 rsplen)\n{\n\tstruct efc *efc;\n\tstruct efc_els_io_req *els;\n\tunsigned long flags = 0;\n\n\tefc = node->efc;\n\n\tif (!node->els_io_enabled) {\n\t\tefc_log_err(efc, \"els io alloc disabled\\n\");\n\t\treturn NULL;\n\t}\n\n\tels = mempool_alloc(efc->els_io_pool, GFP_ATOMIC);\n\tif (!els) {\n\t\tatomic_add_return(1, &efc->els_io_alloc_failed_count);\n\t\treturn NULL;\n\t}\n\n\t \n\tkref_init(&els->ref);\n\tels->release = _efc_els_io_free;\n\n\t \n\tels->node = node;\n\n\t \n\tels->io.req.size = reqlen;\n\tels->io.req.virt = dma_alloc_coherent(&efc->pci->dev, els->io.req.size,\n\t\t\t\t\t      &els->io.req.phys, GFP_KERNEL);\n\tif (!els->io.req.virt) {\n\t\tmempool_free(els, efc->els_io_pool);\n\t\treturn NULL;\n\t}\n\n\tels->io.rsp.size = rsplen;\n\tels->io.rsp.virt = dma_alloc_coherent(&efc->pci->dev, els->io.rsp.size,\n\t\t\t\t\t      &els->io.rsp.phys, GFP_KERNEL);\n\tif (!els->io.rsp.virt) {\n\t\tdma_free_coherent(&efc->pci->dev, els->io.req.size,\n\t\t\t\t  els->io.req.virt, els->io.req.phys);\n\t\tmempool_free(els, efc->els_io_pool);\n\t\tels = NULL;\n\t}\n\n\tif (els) {\n\t\t \n\t\tels->els_retries_remaining = EFC_FC_ELS_DEFAULT_RETRIES;\n\n\t\t \n\t\tINIT_LIST_HEAD(&els->list_entry);\n\t\tspin_lock_irqsave(&node->els_ios_lock, flags);\n\t\tlist_add_tail(&els->list_entry, &node->els_ios_list);\n\t\tspin_unlock_irqrestore(&node->els_ios_lock, flags);\n\t}\n\n\treturn els;\n}\n\nvoid\nefc_els_io_free(struct efc_els_io_req *els)\n{\n\tkref_put(&els->ref, els->release);\n}\n\nvoid\n_efc_els_io_free(struct kref *arg)\n{\n\tstruct efc_els_io_req *els =\n\t\t\t\tcontainer_of(arg, struct efc_els_io_req, ref);\n\tstruct efc *efc;\n\tstruct efc_node *node;\n\tint send_empty_event = false;\n\tunsigned long flags = 0;\n\n\tnode = els->node;\n\tefc = node->efc;\n\n\tspin_lock_irqsave(&node->els_ios_lock, flags);\n\n\tlist_del(&els->list_entry);\n\t \n\tsend_empty_event = (!node->els_io_enabled &&\n\t\t\t   list_empty(&node->els_ios_list));\n\n\tspin_unlock_irqrestore(&node->els_ios_lock, flags);\n\n\t \n\tdma_free_coherent(&efc->pci->dev, els->io.rsp.size,\n\t\t\t  els->io.rsp.virt, els->io.rsp.phys);\n\tdma_free_coherent(&efc->pci->dev, els->io.req.size,\n\t\t\t  els->io.req.virt, els->io.req.phys);\n\n\tmempool_free(els, efc->els_io_pool);\n\n\tif (send_empty_event)\n\t\tefc_scsi_io_list_empty(node->efc, node);\n}\n\nstatic void\nefc_els_retry(struct efc_els_io_req *els);\n\nstatic void\nefc_els_delay_timer_cb(struct timer_list *t)\n{\n\tstruct efc_els_io_req *els = from_timer(els, t, delay_timer);\n\n\t \n\tefc_els_retry(els);\n}\n\nstatic int\nefc_els_req_cb(void *arg, u32 length, int status, u32 ext_status)\n{\n\tstruct efc_els_io_req *els;\n\tstruct efc_node *node;\n\tstruct efc *efc;\n\tstruct efc_node_cb cbdata;\n\tu32 reason_code;\n\n\tels = arg;\n\tnode = els->node;\n\tefc = node->efc;\n\n\tif (status)\n\t\tels_io_printf(els, \"status x%x ext x%x\\n\", status, ext_status);\n\n\t \n\tels->io.rsp.len = length;\n\n\tcbdata.status = status;\n\tcbdata.ext_status = ext_status;\n\tcbdata.header = NULL;\n\tcbdata.els_rsp = els->io.rsp;\n\n\t \n\tcbdata.rsp_len = length;\n\n\t \n\tif (length > els->io.rsp.size) {\n\t\tefc_log_warn(efc,\n\t\t\t     \"ELS response returned len=%d > buflen=%zu\\n\",\n\t\t\t     length, els->io.rsp.size);\n\t\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_REQ_FAIL, &cbdata);\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (status) {\n\tcase SLI4_FC_WCQE_STATUS_SUCCESS:\n\t\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_REQ_OK, &cbdata);\n\t\tbreak;\n\n\tcase SLI4_FC_WCQE_STATUS_LS_RJT:\n\t\treason_code = (ext_status >> 16) & 0xff;\n\n\t\t \n\t\tswitch (reason_code) {\n\t\tcase ELS_RJT_BUSY:\n\t\t\tels->node->els_req_cnt--;\n\t\t\tels_io_printf(els,\n\t\t\t\t      \"LS_RJT Logical Busy, delay and retry\\n\");\n\t\t\ttimer_setup(&els->delay_timer,\n\t\t\t\t    efc_els_delay_timer_cb, 0);\n\t\t\tmod_timer(&els->delay_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(5000));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_REQ_RJT,\n\t\t\t\t\t   &cbdata);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SLI4_FC_WCQE_STATUS_LOCAL_REJECT:\n\t\tswitch (ext_status) {\n\t\tcase SLI4_FC_LOCAL_REJECT_SEQUENCE_TIMEOUT:\n\t\t\tefc_els_retry(els);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tefc_log_err(efc, \"LOCAL_REJECT with ext status:%x\\n\",\n\t\t\t\t    ext_status);\n\t\t\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_REQ_FAIL,\n\t\t\t\t\t   &cbdata);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\t \n\t\tefc_log_warn(efc, \"els req failed status x%x, ext_status x%x\\n\",\n\t\t\t     status, ext_status);\n\t\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_REQ_FAIL, &cbdata);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid efc_disc_io_complete(struct efc_disc_io *io, u32 len, u32 status,\n\t\t\t  u32 ext_status)\n{\n\tstruct efc_els_io_req *els =\n\t\t\t\tcontainer_of(io, struct efc_els_io_req, io);\n\n\tWARN_ON_ONCE(!els->cb);\n\n\t((efc_hw_srrs_cb_t)els->cb) (els, len, status, ext_status);\n}\n\nstatic int efc_els_send_req(struct efc_node *node, struct efc_els_io_req *els,\n\t\t\t    enum efc_disc_io_type io_type)\n{\n\tint rc = 0;\n\tstruct efc *efc = node->efc;\n\tstruct efc_node_cb cbdata;\n\n\t \n\tels->node->els_req_cnt++;\n\n\t \n\tels->io.io_type = io_type;\n\tels->io.xmit_len = els->io.req.size;\n\tels->io.rsp_len = els->io.rsp.size;\n\tels->io.rpi = node->rnode.indicator;\n\tels->io.vpi = node->nport->indicator;\n\tels->io.s_id = node->nport->fc_id;\n\tels->io.d_id = node->rnode.fc_id;\n\n\tif (node->rnode.attached)\n\t\tels->io.rpi_registered = true;\n\n\tels->cb = efc_els_req_cb;\n\n\trc = efc->tt.send_els(efc, &els->io);\n\tif (!rc)\n\t\treturn rc;\n\n\tcbdata.status = EFC_STATUS_INVALID;\n\tcbdata.ext_status = EFC_STATUS_INVALID;\n\tcbdata.els_rsp = els->io.rsp;\n\tefc_log_err(efc, \"efc_els_send failed: %d\\n\", rc);\n\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_REQ_FAIL, &cbdata);\n\n\treturn rc;\n}\n\nstatic void\nefc_els_retry(struct efc_els_io_req *els)\n{\n\tstruct efc *efc;\n\tstruct efc_node_cb cbdata;\n\tu32 rc;\n\n\tefc = els->node->efc;\n\tcbdata.status = EFC_STATUS_INVALID;\n\tcbdata.ext_status = EFC_STATUS_INVALID;\n\tcbdata.els_rsp = els->io.rsp;\n\n\tif (els->els_retries_remaining) {\n\t\tels->els_retries_remaining--;\n\t\trc = efc->tt.send_els(efc, &els->io);\n\t} else {\n\t\trc = -EIO;\n\t}\n\n\tif (rc) {\n\t\tefc_log_err(efc, \"ELS retries exhausted\\n\");\n\t\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_REQ_FAIL, &cbdata);\n\t}\n}\n\nstatic int\nefc_els_acc_cb(void *arg, u32 length, int status, u32 ext_status)\n{\n\tstruct efc_els_io_req *els;\n\tstruct efc_node *node;\n\tstruct efc *efc;\n\tstruct efc_node_cb cbdata;\n\n\tels = arg;\n\tnode = els->node;\n\tefc = node->efc;\n\n\tcbdata.status = status;\n\tcbdata.ext_status = ext_status;\n\tcbdata.header = NULL;\n\tcbdata.els_rsp = els->io.rsp;\n\n\t \n\tswitch (status) {\n\tcase SLI4_FC_WCQE_STATUS_SUCCESS:\n\t\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_CMPL_OK, &cbdata);\n\t\tbreak;\n\n\tdefault:\t \n\t\tefc_log_warn(efc, \"[%s] %-8s failed status x%x, ext x%x\\n\",\n\t\t\t     node->display_name, els->display_name,\n\t\t\t     status, ext_status);\n\t\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_CMPL_FAIL, &cbdata);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nefc_els_send_rsp(struct efc_els_io_req *els, u32 rsplen)\n{\n\tint rc = 0;\n\tstruct efc_node_cb cbdata;\n\tstruct efc_node *node = els->node;\n\tstruct efc *efc = node->efc;\n\n\t \n\tnode->els_cmpl_cnt++;\n\n\tels->io.io_type = EFC_DISC_IO_ELS_RESP;\n\tels->cb = efc_els_acc_cb;\n\n\t \n\tels->io.xmit_len = rsplen;\n\tels->io.rsp_len = els->io.rsp.size;\n\tels->io.rpi = node->rnode.indicator;\n\tels->io.vpi = node->nport->indicator;\n\tif (node->nport->fc_id != U32_MAX)\n\t\tels->io.s_id = node->nport->fc_id;\n\telse\n\t\tels->io.s_id = els->io.iparam.els.s_id;\n\tels->io.d_id = node->rnode.fc_id;\n\n\tif (node->attached)\n\t\tels->io.rpi_registered = true;\n\n\trc = efc->tt.send_els(efc, &els->io);\n\tif (!rc)\n\t\treturn rc;\n\n\tcbdata.status = EFC_STATUS_INVALID;\n\tcbdata.ext_status = EFC_STATUS_INVALID;\n\tcbdata.els_rsp = els->io.rsp;\n\tefc_els_io_cleanup(els, EFC_EVT_SRRS_ELS_CMPL_FAIL, &cbdata);\n\n\treturn rc;\n}\n\nint\nefc_send_plogi(struct efc_node *node)\n{\n\tstruct efc_els_io_req *els;\n\tstruct efc *efc = node->efc;\n\tstruct fc_els_flogi  *plogi;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*plogi));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\tels->display_name = \"plogi\";\n\n\t \n\tplogi = els->io.req.virt;\n\n\tmemcpy(plogi, node->nport->service_params, sizeof(*plogi));\n\n\tplogi->fl_cmd = ELS_PLOGI;\n\tmemset(plogi->_fl_resvd, 0, sizeof(plogi->_fl_resvd));\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_ELS_REQ);\n}\n\nint\nefc_send_flogi(struct efc_node *node)\n{\n\tstruct efc_els_io_req *els;\n\tstruct efc *efc;\n\tstruct fc_els_flogi  *flogi;\n\n\tefc = node->efc;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*flogi));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"flogi\";\n\n\t \n\tflogi = els->io.req.virt;\n\n\tmemcpy(flogi, node->nport->service_params, sizeof(*flogi));\n\tflogi->fl_cmd = ELS_FLOGI;\n\tmemset(flogi->_fl_resvd, 0, sizeof(flogi->_fl_resvd));\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_ELS_REQ);\n}\n\nint\nefc_send_fdisc(struct efc_node *node)\n{\n\tstruct efc_els_io_req *els;\n\tstruct efc *efc;\n\tstruct fc_els_flogi *fdisc;\n\n\tefc = node->efc;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*fdisc));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"fdisc\";\n\n\t \n\tfdisc = els->io.req.virt;\n\n\tmemcpy(fdisc, node->nport->service_params, sizeof(*fdisc));\n\tfdisc->fl_cmd = ELS_FDISC;\n\tmemset(fdisc->_fl_resvd, 0, sizeof(fdisc->_fl_resvd));\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_ELS_REQ);\n}\n\nint\nefc_send_prli(struct efc_node *node)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els;\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*pp));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"prli\";\n\n\t \n\tpp = els->io.req.virt;\n\n\tmemset(pp, 0, sizeof(*pp));\n\n\tpp->prli.prli_cmd = ELS_PRLI;\n\tpp->prli.prli_spp_len = 16;\n\tpp->prli.prli_len = cpu_to_be16(sizeof(*pp));\n\tpp->spp.spp_type = FC_TYPE_FCP;\n\tpp->spp.spp_type_ext = 0;\n\tpp->spp.spp_flags = FC_SPP_EST_IMG_PAIR;\n\tpp->spp.spp_params = cpu_to_be32(FCP_SPPF_RD_XRDY_DIS |\n\t\t\t       (node->nport->enable_ini ?\n\t\t\t       FCP_SPPF_INIT_FCN : 0) |\n\t\t\t       (node->nport->enable_tgt ?\n\t\t\t       FCP_SPPF_TARG_FCN : 0));\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_ELS_REQ);\n}\n\nint\nefc_send_logo(struct efc_node *node)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els;\n\tstruct fc_els_logo *logo;\n\tstruct fc_els_flogi  *sparams;\n\n\tnode_els_trace();\n\n\tsparams = (struct fc_els_flogi *)node->nport->service_params;\n\n\tels = efc_els_io_alloc(node, sizeof(*logo));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"logo\";\n\n\t \n\n\tlogo = els->io.req.virt;\n\n\tmemset(logo, 0, sizeof(*logo));\n\tlogo->fl_cmd = ELS_LOGO;\n\thton24(logo->fl_n_port_id, node->rnode.nport->fc_id);\n\tlogo->fl_n_port_wwn = sparams->fl_wwpn;\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_ELS_REQ);\n}\n\nint\nefc_send_adisc(struct efc_node *node)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els;\n\tstruct fc_els_adisc *adisc;\n\tstruct fc_els_flogi  *sparams;\n\tstruct efc_nport *nport = node->nport;\n\n\tnode_els_trace();\n\n\tsparams = (struct fc_els_flogi *)node->nport->service_params;\n\n\tels = efc_els_io_alloc(node, sizeof(*adisc));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"adisc\";\n\n\t \n\n\tadisc = els->io.req.virt;\n\n\tmemset(adisc, 0, sizeof(*adisc));\n\tadisc->adisc_cmd = ELS_ADISC;\n\thton24(adisc->adisc_hard_addr, nport->fc_id);\n\tadisc->adisc_wwpn = sparams->fl_wwpn;\n\tadisc->adisc_wwnn = sparams->fl_wwnn;\n\thton24(adisc->adisc_port_id, node->rnode.nport->fc_id);\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_ELS_REQ);\n}\n\nint\nefc_send_scr(struct efc_node *node)\n{\n\tstruct efc_els_io_req *els;\n\tstruct efc *efc = node->efc;\n\tstruct fc_els_scr *req;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*req));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"scr\";\n\n\treq = els->io.req.virt;\n\n\tmemset(req, 0, sizeof(*req));\n\treq->scr_cmd = ELS_SCR;\n\treq->scr_reg_func = ELS_SCRF_FULL;\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_ELS_REQ);\n}\n\nint\nefc_send_ls_rjt(struct efc_node *node, u32 ox_id, u32 reason_code,\n\t\tu32 reason_code_expl, u32 vendor_unique)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els = NULL;\n\tstruct fc_els_ls_rjt *rjt;\n\n\tels = efc_els_io_alloc(node, sizeof(*rjt));\n\tif (!els) {\n\t\tefc_log_err(efc, \"els IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnode_els_trace();\n\n\tels->display_name = \"ls_rjt\";\n\n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\tels->io.iparam.els.ox_id = ox_id;\n\n\trjt = els->io.req.virt;\n\tmemset(rjt, 0, sizeof(*rjt));\n\n\trjt->er_cmd = ELS_LS_RJT;\n\trjt->er_reason = reason_code;\n\trjt->er_explan = reason_code_expl;\n\n\treturn efc_els_send_rsp(els, sizeof(*rjt));\n}\n\nint\nefc_send_plogi_acc(struct efc_node *node, u32 ox_id)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els = NULL;\n\tstruct fc_els_flogi  *plogi;\n\tstruct fc_els_flogi  *req = (struct fc_els_flogi *)node->service_params;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*plogi));\n\tif (!els) {\n\t\tefc_log_err(efc, \"els IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"plogi_acc\";\n\n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\tels->io.iparam.els.ox_id = ox_id;\n\n\tplogi = els->io.req.virt;\n\n\t \n\tmemcpy(plogi, node->nport->service_params, sizeof(*plogi));\n\tplogi->fl_cmd = ELS_LS_ACC;\n\tmemset(plogi->_fl_resvd, 0, sizeof(plogi->_fl_resvd));\n\n\t \n\tif (req->fl_csp.sp_features & cpu_to_be16(FC_SP_FT_BCAST))\n\t\tplogi->fl_csp.sp_features |= cpu_to_be16(FC_SP_FT_BCAST);\n\n\treturn efc_els_send_rsp(els, sizeof(*plogi));\n}\n\nint\nefc_send_flogi_p2p_acc(struct efc_node *node, u32 ox_id, u32 s_id)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els = NULL;\n\tstruct fc_els_flogi  *flogi;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*flogi));\n\tif (!els) {\n\t\tefc_log_err(efc, \"els IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"flogi_p2p_acc\";\n\n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\tels->io.iparam.els.ox_id = ox_id;\n\tels->io.iparam.els.s_id = s_id;\n\n\tflogi = els->io.req.virt;\n\n\t \n\tmemcpy(flogi, node->nport->service_params, sizeof(*flogi));\n\tflogi->fl_cmd = ELS_LS_ACC;\n\tmemset(flogi->_fl_resvd, 0, sizeof(flogi->_fl_resvd));\n\n\tmemset(flogi->fl_cssp, 0, sizeof(flogi->fl_cssp));\n\n\treturn efc_els_send_rsp(els, sizeof(*flogi));\n}\n\nint\nefc_send_prli_acc(struct efc_node *node, u32 ox_id)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els = NULL;\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*pp));\n\tif (!els) {\n\t\tefc_log_err(efc, \"els IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"prli_acc\";\n\n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\tels->io.iparam.els.ox_id = ox_id;\n\n\tpp = els->io.req.virt;\n\tmemset(pp, 0, sizeof(*pp));\n\n\tpp->prli.prli_cmd = ELS_LS_ACC;\n\tpp->prli.prli_spp_len = 0x10;\n\tpp->prli.prli_len = cpu_to_be16(sizeof(*pp));\n\tpp->spp.spp_type = FC_TYPE_FCP;\n\tpp->spp.spp_type_ext = 0;\n\tpp->spp.spp_flags = FC_SPP_EST_IMG_PAIR | FC_SPP_RESP_ACK;\n\n\tpp->spp.spp_params = cpu_to_be32(FCP_SPPF_RD_XRDY_DIS |\n\t\t\t\t\t(node->nport->enable_ini ?\n\t\t\t\t\t FCP_SPPF_INIT_FCN : 0) |\n\t\t\t\t\t(node->nport->enable_tgt ?\n\t\t\t\t\t FCP_SPPF_TARG_FCN : 0));\n\n\treturn efc_els_send_rsp(els, sizeof(*pp));\n}\n\nint\nefc_send_prlo_acc(struct efc_node *node, u32 ox_id)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els = NULL;\n\tstruct {\n\t\tstruct fc_els_prlo prlo;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*pp));\n\tif (!els) {\n\t\tefc_log_err(efc, \"els IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"prlo_acc\";\n\n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\tels->io.iparam.els.ox_id = ox_id;\n\n\tpp = els->io.req.virt;\n\tmemset(pp, 0, sizeof(*pp));\n\tpp->prlo.prlo_cmd = ELS_LS_ACC;\n\tpp->prlo.prlo_obs = 0x10;\n\tpp->prlo.prlo_len = cpu_to_be16(sizeof(*pp));\n\n\tpp->spp.spp_type = FC_TYPE_FCP;\n\tpp->spp.spp_type_ext = 0;\n\tpp->spp.spp_flags = FC_SPP_RESP_ACK;\n\n\treturn efc_els_send_rsp(els, sizeof(*pp));\n}\n\nint\nefc_send_ls_acc(struct efc_node *node, u32 ox_id)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els = NULL;\n\tstruct fc_els_ls_acc *acc;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*acc));\n\tif (!els) {\n\t\tefc_log_err(efc, \"els IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"ls_acc\";\n\n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\tels->io.iparam.els.ox_id = ox_id;\n\n\tacc = els->io.req.virt;\n\tmemset(acc, 0, sizeof(*acc));\n\n\tacc->la_cmd = ELS_LS_ACC;\n\n\treturn efc_els_send_rsp(els, sizeof(*acc));\n}\n\nint\nefc_send_logo_acc(struct efc_node *node, u32 ox_id)\n{\n\tstruct efc_els_io_req *els = NULL;\n\tstruct efc *efc = node->efc;\n\tstruct fc_els_ls_acc *logo;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*logo));\n\tif (!els) {\n\t\tefc_log_err(efc, \"els IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"logo_acc\";\n\n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\tels->io.iparam.els.ox_id = ox_id;\n\n\tlogo = els->io.req.virt;\n\tmemset(logo, 0, sizeof(*logo));\n\n\tlogo->la_cmd = ELS_LS_ACC;\n\n\treturn efc_els_send_rsp(els, sizeof(*logo));\n}\n\nint\nefc_send_adisc_acc(struct efc_node *node, u32 ox_id)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els = NULL;\n\tstruct fc_els_adisc *adisc;\n\tstruct fc_els_flogi  *sparams;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*adisc));\n\tif (!els) {\n\t\tefc_log_err(efc, \"els IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->display_name = \"adisc_acc\";\n\n\t \n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\tels->io.iparam.els.ox_id = ox_id;\n\n\tsparams = (struct fc_els_flogi  *)node->nport->service_params;\n\tadisc = els->io.req.virt;\n\tmemset(adisc, 0, sizeof(*adisc));\n\tadisc->adisc_cmd = ELS_LS_ACC;\n\tadisc->adisc_wwpn = sparams->fl_wwpn;\n\tadisc->adisc_wwnn = sparams->fl_wwnn;\n\thton24(adisc->adisc_port_id, node->rnode.nport->fc_id);\n\n\treturn efc_els_send_rsp(els, sizeof(*adisc));\n}\n\nstatic inline void\nfcct_build_req_header(struct fc_ct_hdr  *hdr, u16 cmd, u16 max_size)\n{\n\thdr->ct_rev = FC_CT_REV;\n\thdr->ct_fs_type = FC_FST_DIR;\n\thdr->ct_fs_subtype = FC_NS_SUBTYPE;\n\thdr->ct_options = 0;\n\thdr->ct_cmd = cpu_to_be16(cmd);\n\t \n\thdr->ct_mr_size = cpu_to_be16(max_size / (sizeof(u32)));\n\thdr->ct_reason = 0;\n\thdr->ct_explan = 0;\n\thdr->ct_vendor = 0;\n}\n\nint\nefc_ns_send_rftid(struct efc_node *node)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els;\n\tstruct {\n\t\tstruct fc_ct_hdr hdr;\n\t\tstruct fc_ns_rft_id rftid;\n\t} *ct;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*ct));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->io.iparam.ct.r_ctl = FC_RCTL_ELS_REQ;\n\tels->io.iparam.ct.type = FC_TYPE_CT;\n\tels->io.iparam.ct.df_ctl = 0;\n\tels->io.iparam.ct.timeout = EFC_FC_ELS_SEND_DEFAULT_TIMEOUT;\n\n\tels->display_name = \"rftid\";\n\n\tct = els->io.req.virt;\n\tmemset(ct, 0, sizeof(*ct));\n\tfcct_build_req_header(&ct->hdr, FC_NS_RFT_ID,\n\t\t\t      sizeof(struct fc_ns_rft_id));\n\n\thton24(ct->rftid.fr_fid.fp_fid, node->rnode.nport->fc_id);\n\tct->rftid.fr_fts.ff_type_map[FC_TYPE_FCP / FC_NS_BPW] =\n\t\tcpu_to_be32(1 << (FC_TYPE_FCP % FC_NS_BPW));\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_CT_REQ);\n}\n\nint\nefc_ns_send_rffid(struct efc_node *node)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_els_io_req *els;\n\tstruct {\n\t\tstruct fc_ct_hdr hdr;\n\t\tstruct fc_ns_rff_id rffid;\n\t} *ct;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc(node, sizeof(*ct));\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->io.iparam.ct.r_ctl = FC_RCTL_ELS_REQ;\n\tels->io.iparam.ct.type = FC_TYPE_CT;\n\tels->io.iparam.ct.df_ctl = 0;\n\tels->io.iparam.ct.timeout = EFC_FC_ELS_SEND_DEFAULT_TIMEOUT;\n\n\tels->display_name = \"rffid\";\n\tct = els->io.req.virt;\n\n\tmemset(ct, 0, sizeof(*ct));\n\tfcct_build_req_header(&ct->hdr, FC_NS_RFF_ID,\n\t\t\t      sizeof(struct fc_ns_rff_id));\n\n\thton24(ct->rffid.fr_fid.fp_fid, node->rnode.nport->fc_id);\n\tif (node->nport->enable_ini)\n\t\tct->rffid.fr_feat |= FCP_FEAT_INIT;\n\tif (node->nport->enable_tgt)\n\t\tct->rffid.fr_feat |= FCP_FEAT_TARG;\n\tct->rffid.fr_type = FC_TYPE_FCP;\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_CT_REQ);\n}\n\nint\nefc_ns_send_gidpt(struct efc_node *node)\n{\n\tstruct efc_els_io_req *els = NULL;\n\tstruct efc *efc = node->efc;\n\tstruct {\n\t\tstruct fc_ct_hdr hdr;\n\t\tstruct fc_ns_gid_pt gidpt;\n\t} *ct;\n\n\tnode_els_trace();\n\n\tels = efc_els_io_alloc_size(node, sizeof(*ct), EFC_ELS_GID_PT_RSP_LEN);\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tels->io.iparam.ct.r_ctl = FC_RCTL_ELS_REQ;\n\tels->io.iparam.ct.type = FC_TYPE_CT;\n\tels->io.iparam.ct.df_ctl = 0;\n\tels->io.iparam.ct.timeout = EFC_FC_ELS_SEND_DEFAULT_TIMEOUT;\n\n\tels->display_name = \"gidpt\";\n\n\tct = els->io.req.virt;\n\n\tmemset(ct, 0, sizeof(*ct));\n\tfcct_build_req_header(&ct->hdr, FC_NS_GID_PT,\n\t\t\t      sizeof(struct fc_ns_gid_pt));\n\n\tct->gidpt.fn_pt_type = FC_TYPE_FCP;\n\n\treturn efc_els_send_req(node, els, EFC_DISC_IO_CT_REQ);\n}\n\nvoid\nefc_els_io_cleanup(struct efc_els_io_req *els, int evt, void *arg)\n{\n\t \n\tels->els_req_free = true;\n\tefc_node_post_els_resp(els->node, evt, arg);\n\n\tefc_els_io_free(els);\n}\n\nstatic int\nefc_ct_acc_cb(void *arg, u32 length, int status, u32 ext_status)\n{\n\tstruct efc_els_io_req *els = arg;\n\n\tefc_els_io_free(els);\n\n\treturn 0;\n}\n\nint\nefc_send_ct_rsp(struct efc *efc, struct efc_node *node, u16 ox_id,\n\t\tstruct fc_ct_hdr *ct_hdr, u32 cmd_rsp_code,\n\t\tu32 reason_code, u32 reason_code_explanation)\n{\n\tstruct efc_els_io_req *els = NULL;\n\tstruct fc_ct_hdr  *rsp = NULL;\n\n\tels = efc_els_io_alloc(node, 256);\n\tif (!els) {\n\t\tefc_log_err(efc, \"IO alloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\trsp = els->io.rsp.virt;\n\n\t*rsp = *ct_hdr;\n\n\tfcct_build_req_header(rsp, cmd_rsp_code, 0);\n\trsp->ct_reason = reason_code;\n\trsp->ct_explan = reason_code_explanation;\n\n\tels->display_name = \"ct_rsp\";\n\tels->cb = efc_ct_acc_cb;\n\n\t \n\tels->io.io_type = EFC_DISC_IO_CT_RESP;\n\tels->io.xmit_len = sizeof(*rsp);\n\n\tels->io.rpi = node->rnode.indicator;\n\tels->io.d_id = node->rnode.fc_id;\n\n\tmemset(&els->io.iparam, 0, sizeof(els->io.iparam));\n\n\tels->io.iparam.ct.ox_id = ox_id;\n\tels->io.iparam.ct.r_ctl = 3;\n\tels->io.iparam.ct.type = FC_TYPE_CT;\n\tels->io.iparam.ct.df_ctl = 0;\n\tels->io.iparam.ct.timeout = 5;\n\n\tif (efc->tt.send_els(efc, &els->io)) {\n\t\tefc_els_io_free(els);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nint\nefc_send_bls_acc(struct efc_node *node, struct fc_frame_header *hdr)\n{\n\tstruct sli_bls_params bls;\n\tstruct fc_ba_acc *acc;\n\tstruct efc *efc = node->efc;\n\n\tmemset(&bls, 0, sizeof(bls));\n\tbls.ox_id = be16_to_cpu(hdr->fh_ox_id);\n\tbls.rx_id = be16_to_cpu(hdr->fh_rx_id);\n\tbls.s_id = ntoh24(hdr->fh_d_id);\n\tbls.d_id = node->rnode.fc_id;\n\tbls.rpi = node->rnode.indicator;\n\tbls.vpi = node->nport->indicator;\n\n\tacc = (void *)bls.payload;\n\tacc->ba_ox_id = cpu_to_be16(bls.ox_id);\n\tacc->ba_rx_id = cpu_to_be16(bls.rx_id);\n\tacc->ba_high_seq_cnt = cpu_to_be16(U16_MAX);\n\n\treturn efc->tt.send_bls(efc, FC_RCTL_BA_ACC, &bls);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}