{
  "module_name": "efc_cmds.c",
  "hash_id": "8ec52169f2ad624e3192d3217485f3d14eaf0f0d5671759f5a984a51314da685",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/libefc/efc_cmds.c",
  "human_readable_source": "\n \n\n#include \"efclib.h\"\n#include \"../libefc_sli/sli4.h\"\n#include \"efc_cmds.h\"\n#include \"efc_sm.h\"\n\nstatic void\nefc_nport_free_resources(struct efc_nport *nport, int evt, void *data)\n{\n\tstruct efc *efc = nport->efc;\n\n\t \n\tnport->attached = false;\n\n\t \n\tif (nport->dma.virt) {\n\t\tdma_free_coherent(&efc->pci->dev, nport->dma.size,\n\t\t\t\t  nport->dma.virt, nport->dma.phys);\n\t\tmemset(&nport->dma, 0, sizeof(struct efc_dma));\n\t}\n\n\t \n\tsli_resource_free(efc->sli, SLI4_RSRC_VPI, nport->indicator);\n\n\tefc_nport_cb(efc, evt, nport);\n}\n\nstatic int\nefc_nport_get_mbox_status(struct efc_nport *nport, u8 *mqe, int status)\n{\n\tstruct efc *efc = nport->efc;\n\tstruct sli4_mbox_command_header *hdr =\n\t\t\t(struct sli4_mbox_command_header *)mqe;\n\n\tif (status || le16_to_cpu(hdr->status)) {\n\t\tefc_log_debug(efc, \"bad status vpi=%#x st=%x hdr=%x\\n\",\n\t\t\t      nport->indicator, status, le16_to_cpu(hdr->status));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nefc_nport_free_unreg_vpi_cb(struct efc *efc, int status, u8 *mqe, void *arg)\n{\n\tstruct efc_nport *nport = arg;\n\tint evt = EFC_EVT_NPORT_FREE_OK;\n\tint rc;\n\n\trc = efc_nport_get_mbox_status(nport, mqe, status);\n\tif (rc)\n\t\tevt = EFC_EVT_NPORT_FREE_FAIL;\n\n\tefc_nport_free_resources(nport, evt, mqe);\n\treturn rc;\n}\n\nstatic void\nefc_nport_free_unreg_vpi(struct efc_nport *nport)\n{\n\tstruct efc *efc = nport->efc;\n\tint rc;\n\tu8 data[SLI4_BMBX_SIZE];\n\n\trc = sli_cmd_unreg_vpi(efc->sli, data, nport->indicator,\n\t\t\t       SLI4_UNREG_TYPE_PORT);\n\tif (rc) {\n\t\tefc_log_err(efc, \"UNREG_VPI format failure\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_FREE_FAIL, data);\n\t\treturn;\n\t}\n\n\trc = efc->tt.issue_mbox_rqst(efc->base, data,\n\t\t\t\t     efc_nport_free_unreg_vpi_cb, nport);\n\tif (rc) {\n\t\tefc_log_err(efc, \"UNREG_VPI command failure\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_FREE_FAIL, data);\n\t}\n}\n\nstatic void\nefc_nport_send_evt(struct efc_nport *nport, int evt, void *data)\n{\n\tstruct efc *efc = nport->efc;\n\n\t \n\tefc_nport_cb(efc, evt, nport);\n\n\t \n\tif (evt == EFC_EVT_NPORT_ATTACH_OK)\n\t\tnport->attached = true;\n\n\t \n\tif (nport->free_req_pending)\n\t\tefc_nport_free_unreg_vpi(nport);\n}\n\nstatic int\nefc_nport_alloc_init_vpi_cb(struct efc *efc, int status, u8 *mqe, void *arg)\n{\n\tstruct efc_nport *nport = arg;\n\n\tif (efc_nport_get_mbox_status(nport, mqe, status)) {\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ALLOC_FAIL, mqe);\n\t\treturn -EIO;\n\t}\n\n\tefc_nport_send_evt(nport, EFC_EVT_NPORT_ALLOC_OK, mqe);\n\treturn 0;\n}\n\nstatic void\nefc_nport_alloc_init_vpi(struct efc_nport *nport)\n{\n\tstruct efc *efc = nport->efc;\n\tu8 data[SLI4_BMBX_SIZE];\n\tint rc;\n\n\t \n\tif (nport->free_req_pending) {\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_FREE_OK, data);\n\t\treturn;\n\t}\n\n\trc = sli_cmd_init_vpi(efc->sli, data,\n\t\t\t      nport->indicator, nport->domain->indicator);\n\tif (rc) {\n\t\tefc_log_err(efc, \"INIT_VPI format failure\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ALLOC_FAIL, data);\n\t\treturn;\n\t}\n\n\trc = efc->tt.issue_mbox_rqst(efc->base, data,\n\t\t\tefc_nport_alloc_init_vpi_cb, nport);\n\tif (rc) {\n\t\tefc_log_err(efc, \"INIT_VPI command failure\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ALLOC_FAIL, data);\n\t}\n}\n\nstatic int\nefc_nport_alloc_read_sparm64_cb(struct efc *efc, int status, u8 *mqe, void *arg)\n{\n\tstruct efc_nport *nport = arg;\n\tu8 *payload = NULL;\n\n\tif (efc_nport_get_mbox_status(nport, mqe, status)) {\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ALLOC_FAIL, mqe);\n\t\treturn -EIO;\n\t}\n\n\tpayload = nport->dma.virt;\n\n\tmemcpy(&nport->sli_wwpn, payload + SLI4_READ_SPARM64_WWPN_OFFSET,\n\t       sizeof(nport->sli_wwpn));\n\tmemcpy(&nport->sli_wwnn, payload + SLI4_READ_SPARM64_WWNN_OFFSET,\n\t       sizeof(nport->sli_wwnn));\n\n\tdma_free_coherent(&efc->pci->dev, nport->dma.size, nport->dma.virt,\n\t\t\t  nport->dma.phys);\n\tmemset(&nport->dma, 0, sizeof(struct efc_dma));\n\tefc_nport_alloc_init_vpi(nport);\n\treturn 0;\n}\n\nstatic void\nefc_nport_alloc_read_sparm64(struct efc *efc, struct efc_nport *nport)\n{\n\tu8 data[SLI4_BMBX_SIZE];\n\tint rc;\n\n\t \n\tnport->dma.size = EFC_SPARAM_DMA_SZ;\n\tnport->dma.virt = dma_alloc_coherent(&efc->pci->dev,\n\t\t\t\t\t     nport->dma.size, &nport->dma.phys,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!nport->dma.virt) {\n\t\tefc_log_err(efc, \"Failed to allocate DMA memory\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ALLOC_FAIL, data);\n\t\treturn;\n\t}\n\n\trc = sli_cmd_read_sparm64(efc->sli, data,\n\t\t\t\t  &nport->dma, nport->indicator);\n\tif (rc) {\n\t\tefc_log_err(efc, \"READ_SPARM64 format failure\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ALLOC_FAIL, data);\n\t\treturn;\n\t}\n\n\trc = efc->tt.issue_mbox_rqst(efc->base, data,\n\t\t\t\t     efc_nport_alloc_read_sparm64_cb, nport);\n\tif (rc) {\n\t\tefc_log_err(efc, \"READ_SPARM64 command failure\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ALLOC_FAIL, data);\n\t}\n}\n\nint\nefc_cmd_nport_alloc(struct efc *efc, struct efc_nport *nport,\n\t\t    struct efc_domain *domain, u8 *wwpn)\n{\n\tu32 index;\n\n\tnport->indicator = U32_MAX;\n\tnport->free_req_pending = false;\n\n\tif (wwpn)\n\t\tmemcpy(&nport->sli_wwpn, wwpn, sizeof(nport->sli_wwpn));\n\n\t \n\tif (sli_resource_alloc(efc->sli, SLI4_RSRC_VPI,\n\t\t\t       &nport->indicator, &index)) {\n\t\tefc_log_err(efc, \"VPI allocation failure\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (domain) {\n\t\t \n\t\tif (!wwpn)\n\t\t\tefc_nport_alloc_read_sparm64(efc, nport);\n\t\telse\n\t\t\tefc_nport_alloc_init_vpi(nport);\n\t} else if (!wwpn) {\n\t\t \n\t\tefc_log_err(efc, \"need WWN for physical port\\n\");\n\t\tsli_resource_free(efc->sli, SLI4_RSRC_VPI, nport->indicator);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nefc_nport_attach_reg_vpi_cb(struct efc *efc, int status, u8 *mqe,\n\t\t\t    void *arg)\n{\n\tstruct efc_nport *nport = arg;\n\n\tnport->attaching = false;\n\tif (efc_nport_get_mbox_status(nport, mqe, status)) {\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ATTACH_FAIL, mqe);\n\t\treturn -EIO;\n\t}\n\n\tefc_nport_send_evt(nport, EFC_EVT_NPORT_ATTACH_OK, mqe);\n\treturn 0;\n}\n\nint\nefc_cmd_nport_attach(struct efc *efc, struct efc_nport *nport, u32 fc_id)\n{\n\tu8 buf[SLI4_BMBX_SIZE];\n\tint rc = 0;\n\n\tif (!nport) {\n\t\tefc_log_err(efc, \"bad param(s) nport=%p\\n\", nport);\n\t\treturn -EIO;\n\t}\n\n\tnport->fc_id = fc_id;\n\n\t \n\trc = sli_cmd_reg_vpi(efc->sli, buf, nport->fc_id,\n\t\t\t     nport->sli_wwpn, nport->indicator,\n\t\t\t    nport->domain->indicator, false);\n\tif (rc) {\n\t\tefc_log_err(efc, \"REG_VPI format failure\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ATTACH_FAIL, buf);\n\t\treturn rc;\n\t}\n\n\trc = efc->tt.issue_mbox_rqst(efc->base, buf,\n\t\t\t\t     efc_nport_attach_reg_vpi_cb, nport);\n\tif (rc) {\n\t\tefc_log_err(efc, \"REG_VPI command failure\\n\");\n\t\tefc_nport_free_resources(nport, EFC_EVT_NPORT_ATTACH_FAIL, buf);\n\t} else {\n\t\tnport->attaching = true;\n\t}\n\n\treturn rc;\n}\n\nint\nefc_cmd_nport_free(struct efc *efc, struct efc_nport *nport)\n{\n\tif (!nport) {\n\t\tefc_log_err(efc, \"bad parameter(s) nport=%p\\n\",\tnport);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (nport->attached)\n\t\tefc_nport_free_unreg_vpi(nport);\n\telse if (nport->attaching)\n\t\tnport->free_req_pending = true;\n\telse\n\t\tefc_sm_post_event(&nport->sm, EFC_EVT_NPORT_FREE_OK, NULL);\n\n\treturn 0;\n}\n\nstatic int\nefc_domain_get_mbox_status(struct efc_domain *domain, u8 *mqe, int status)\n{\n\tstruct efc *efc = domain->efc;\n\tstruct sli4_mbox_command_header *hdr =\n\t\t\t(struct sli4_mbox_command_header *)mqe;\n\n\tif (status || le16_to_cpu(hdr->status)) {\n\t\tefc_log_debug(efc, \"bad status vfi=%#x st=%x hdr=%x\\n\",\n\t\t\t      domain->indicator, status,\n\t\t\t      le16_to_cpu(hdr->status));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nefc_domain_free_resources(struct efc_domain *domain, int evt, void *data)\n{\n\tstruct efc *efc = domain->efc;\n\n\t \n\tif (domain->dma.virt) {\n\t\tdma_free_coherent(&efc->pci->dev,\n\t\t\t\t  domain->dma.size, domain->dma.virt,\n\t\t\t\t  domain->dma.phys);\n\t\tmemset(&domain->dma, 0, sizeof(struct efc_dma));\n\t}\n\n\t \n\tsli_resource_free(efc->sli, SLI4_RSRC_VFI, domain->indicator);\n\n\tefc_domain_cb(efc, evt, domain);\n}\n\nstatic void\nefc_domain_send_nport_evt(struct efc_domain *domain,\n\t\t\t  int port_evt, int domain_evt, void *data)\n{\n\tstruct efc *efc = domain->efc;\n\n\t \n\tefc_nport_send_evt(domain->nport, port_evt, NULL);\n\n\t \n\tefc_domain_cb(efc, domain_evt, domain);\n}\n\nstatic int\nefc_domain_alloc_read_sparm64_cb(struct efc *efc, int status, u8 *mqe,\n\t\t\t\t void *arg)\n{\n\tstruct efc_domain *domain = arg;\n\n\tif (efc_domain_get_mbox_status(domain, mqe, status)) {\n\t\tefc_domain_free_resources(domain,\n\t\t\t\t\t  EFC_HW_DOMAIN_ALLOC_FAIL, mqe);\n\t\treturn -EIO;\n\t}\n\n\tefc_domain_send_nport_evt(domain, EFC_EVT_NPORT_ALLOC_OK,\n\t\t\t\t  EFC_HW_DOMAIN_ALLOC_OK, mqe);\n\treturn 0;\n}\n\nstatic void\nefc_domain_alloc_read_sparm64(struct efc_domain *domain)\n{\n\tstruct efc *efc = domain->efc;\n\tu8 data[SLI4_BMBX_SIZE];\n\tint rc;\n\n\trc = sli_cmd_read_sparm64(efc->sli, data, &domain->dma, 0);\n\tif (rc) {\n\t\tefc_log_err(efc, \"READ_SPARM64 format failure\\n\");\n\t\tefc_domain_free_resources(domain,\n\t\t\t\t\t  EFC_HW_DOMAIN_ALLOC_FAIL, data);\n\t\treturn;\n\t}\n\n\trc = efc->tt.issue_mbox_rqst(efc->base, data,\n\t\t\t\t     efc_domain_alloc_read_sparm64_cb, domain);\n\tif (rc) {\n\t\tefc_log_err(efc, \"READ_SPARM64 command failure\\n\");\n\t\tefc_domain_free_resources(domain,\n\t\t\t\t\t  EFC_HW_DOMAIN_ALLOC_FAIL, data);\n\t}\n}\n\nstatic int\nefc_domain_alloc_init_vfi_cb(struct efc *efc, int status, u8 *mqe,\n\t\t\t     void *arg)\n{\n\tstruct efc_domain *domain = arg;\n\n\tif (efc_domain_get_mbox_status(domain, mqe, status)) {\n\t\tefc_domain_free_resources(domain,\n\t\t\t\t\t  EFC_HW_DOMAIN_ALLOC_FAIL, mqe);\n\t\treturn -EIO;\n\t}\n\n\tefc_domain_alloc_read_sparm64(domain);\n\treturn 0;\n}\n\nstatic void\nefc_domain_alloc_init_vfi(struct efc_domain *domain)\n{\n\tstruct efc *efc = domain->efc;\n\tstruct efc_nport *nport = domain->nport;\n\tu8 data[SLI4_BMBX_SIZE];\n\tint rc;\n\n\t \n\tdomain->fcf_indicator = efc->fcfi;\n\trc = sli_cmd_init_vfi(efc->sli, data, domain->indicator,\n\t\t\t      domain->fcf_indicator, nport->indicator);\n\tif (rc) {\n\t\tefc_log_err(efc, \"INIT_VFI format failure\\n\");\n\t\tefc_domain_free_resources(domain,\n\t\t\t\t\t  EFC_HW_DOMAIN_ALLOC_FAIL, data);\n\t\treturn;\n\t}\n\n\tefc_log_err(efc, \"%s issue mbox\\n\", __func__);\n\trc = efc->tt.issue_mbox_rqst(efc->base, data,\n\t\t\t\t     efc_domain_alloc_init_vfi_cb, domain);\n\tif (rc) {\n\t\tefc_log_err(efc, \"INIT_VFI command failure\\n\");\n\t\tefc_domain_free_resources(domain,\n\t\t\t\t\t  EFC_HW_DOMAIN_ALLOC_FAIL, data);\n\t}\n}\n\nint\nefc_cmd_domain_alloc(struct efc *efc, struct efc_domain *domain, u32 fcf)\n{\n\tu32 index;\n\n\tif (!domain || !domain->nport) {\n\t\tefc_log_err(efc, \"bad parameter(s) domain=%p nport=%p\\n\",\n\t\t\t    domain, domain ? domain->nport : NULL);\n\t\treturn -EIO;\n\t}\n\n\t \n\tdomain->dma.size = EFC_SPARAM_DMA_SZ;\n\tdomain->dma.virt = dma_alloc_coherent(&efc->pci->dev,\n\t\t\t\t\t      domain->dma.size,\n\t\t\t\t\t      &domain->dma.phys, GFP_KERNEL);\n\tif (!domain->dma.virt) {\n\t\tefc_log_err(efc, \"Failed to allocate DMA memory\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdomain->fcf = fcf;\n\tdomain->fcf_indicator = U32_MAX;\n\tdomain->indicator = U32_MAX;\n\n\tif (sli_resource_alloc(efc->sli, SLI4_RSRC_VFI, &domain->indicator,\n\t\t\t       &index)) {\n\t\tefc_log_err(efc, \"VFI allocation failure\\n\");\n\n\t\tdma_free_coherent(&efc->pci->dev,\n\t\t\t\t  domain->dma.size, domain->dma.virt,\n\t\t\t\t  domain->dma.phys);\n\t\tmemset(&domain->dma, 0, sizeof(struct efc_dma));\n\n\t\treturn -EIO;\n\t}\n\n\tefc_domain_alloc_init_vfi(domain);\n\treturn 0;\n}\n\nstatic int\nefc_domain_attach_reg_vfi_cb(struct efc *efc, int status, u8 *mqe,\n\t\t\t     void *arg)\n{\n\tstruct efc_domain *domain = arg;\n\n\tif (efc_domain_get_mbox_status(domain, mqe, status)) {\n\t\tefc_domain_free_resources(domain,\n\t\t\t\t\t  EFC_HW_DOMAIN_ATTACH_FAIL, mqe);\n\t\treturn -EIO;\n\t}\n\n\tefc_domain_send_nport_evt(domain, EFC_EVT_NPORT_ATTACH_OK,\n\t\t\t\t  EFC_HW_DOMAIN_ATTACH_OK, mqe);\n\treturn 0;\n}\n\nint\nefc_cmd_domain_attach(struct efc *efc, struct efc_domain *domain, u32 fc_id)\n{\n\tu8 buf[SLI4_BMBX_SIZE];\n\tint rc = 0;\n\n\tif (!domain) {\n\t\tefc_log_err(efc, \"bad param(s) domain=%p\\n\", domain);\n\t\treturn -EIO;\n\t}\n\n\tdomain->nport->fc_id = fc_id;\n\n\trc = sli_cmd_reg_vfi(efc->sli, buf, SLI4_BMBX_SIZE, domain->indicator,\n\t\t\t     domain->fcf_indicator, domain->dma,\n\t\t\t     domain->nport->indicator, domain->nport->sli_wwpn,\n\t\t\t     domain->nport->fc_id);\n\tif (rc) {\n\t\tefc_log_err(efc, \"REG_VFI format failure\\n\");\n\t\tgoto cleanup;\n\t}\n\n\trc = efc->tt.issue_mbox_rqst(efc->base, buf,\n\t\t\t\t     efc_domain_attach_reg_vfi_cb, domain);\n\tif (rc) {\n\t\tefc_log_err(efc, \"REG_VFI command failure\\n\");\n\t\tgoto cleanup;\n\t}\n\n\treturn rc;\n\ncleanup:\n\tefc_domain_free_resources(domain, EFC_HW_DOMAIN_ATTACH_FAIL, buf);\n\n\treturn rc;\n}\n\nstatic int\nefc_domain_free_unreg_vfi_cb(struct efc *efc, int status, u8 *mqe, void *arg)\n{\n\tstruct efc_domain *domain = arg;\n\tint evt = EFC_HW_DOMAIN_FREE_OK;\n\tint rc;\n\n\trc = efc_domain_get_mbox_status(domain, mqe, status);\n\tif (rc) {\n\t\tevt = EFC_HW_DOMAIN_FREE_FAIL;\n\t\trc = -EIO;\n\t}\n\n\tefc_domain_free_resources(domain, evt, mqe);\n\treturn rc;\n}\n\nstatic void\nefc_domain_free_unreg_vfi(struct efc_domain *domain)\n{\n\tstruct efc *efc = domain->efc;\n\tint rc;\n\tu8 data[SLI4_BMBX_SIZE];\n\n\trc = sli_cmd_unreg_vfi(efc->sli, data, domain->indicator,\n\t\t\t       SLI4_UNREG_TYPE_DOMAIN);\n\tif (rc) {\n\t\tefc_log_err(efc, \"UNREG_VFI format failure\\n\");\n\t\tgoto cleanup;\n\t}\n\n\trc = efc->tt.issue_mbox_rqst(efc->base, data,\n\t\t\t\t     efc_domain_free_unreg_vfi_cb, domain);\n\tif (rc) {\n\t\tefc_log_err(efc, \"UNREG_VFI command failure\\n\");\n\t\tgoto cleanup;\n\t}\n\n\treturn;\n\ncleanup:\n\tefc_domain_free_resources(domain, EFC_HW_DOMAIN_FREE_FAIL, data);\n}\n\nint\nefc_cmd_domain_free(struct efc *efc, struct efc_domain *domain)\n{\n\tif (!domain) {\n\t\tefc_log_err(efc, \"bad parameter(s) domain=%p\\n\", domain);\n\t\treturn -EIO;\n\t}\n\n\tefc_domain_free_unreg_vfi(domain);\n\treturn 0;\n}\n\nint\nefc_cmd_node_alloc(struct efc *efc, struct efc_remote_node *rnode, u32 fc_addr,\n\t\t   struct efc_nport *nport)\n{\n\t \n\tif (rnode->indicator != U32_MAX) {\n\t\tefc_log_err(efc,\n\t\t\t    \"RPI allocation failure addr=%#x rpi=%#x\\n\",\n\t\t\t    fc_addr, rnode->indicator);\n\t\treturn -EIO;\n\t}\n\n\t \n\trnode->nport = NULL;\n\n\tif (sli_resource_alloc(efc->sli, SLI4_RSRC_RPI,\n\t\t\t       &rnode->indicator, &rnode->index)) {\n\t\tefc_log_err(efc, \"RPI allocation failure addr=%#x\\n\",\n\t\t\t    fc_addr);\n\t\treturn -EIO;\n\t}\n\n\trnode->fc_id = fc_addr;\n\trnode->nport = nport;\n\n\treturn 0;\n}\n\nstatic int\nefc_cmd_node_attach_cb(struct efc *efc, int status, u8 *mqe, void *arg)\n{\n\tstruct efc_remote_node *rnode = arg;\n\tstruct sli4_mbox_command_header *hdr =\n\t\t\t\t(struct sli4_mbox_command_header *)mqe;\n\tint evt = 0;\n\n\tif (status || le16_to_cpu(hdr->status)) {\n\t\tefc_log_debug(efc, \"bad status cqe=%#x mqe=%#x\\n\", status,\n\t\t\t      le16_to_cpu(hdr->status));\n\t\trnode->attached = false;\n\t\tevt = EFC_EVT_NODE_ATTACH_FAIL;\n\t} else {\n\t\trnode->attached = true;\n\t\tevt = EFC_EVT_NODE_ATTACH_OK;\n\t}\n\n\tefc_remote_node_cb(efc, evt, rnode);\n\n\treturn 0;\n}\n\nint\nefc_cmd_node_attach(struct efc *efc, struct efc_remote_node *rnode,\n\t\t    struct efc_dma *sparms)\n{\n\tint rc = -EIO;\n\tu8 buf[SLI4_BMBX_SIZE];\n\n\tif (!rnode || !sparms) {\n\t\tefc_log_err(efc, \"bad parameter(s) rnode=%p sparms=%p\\n\",\n\t\t\t    rnode, sparms);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (rnode->index == U32_MAX) {\n\t\tefc_log_err(efc, \"bad parameter rnode->index invalid\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!sli_cmd_reg_rpi(efc->sli, buf, rnode->indicator,\n\t\t\t     rnode->nport->indicator, rnode->fc_id, sparms, 0, 0))\n\t\trc = efc->tt.issue_mbox_rqst(efc->base, buf,\n\t\t\t\t\t     efc_cmd_node_attach_cb, rnode);\n\n\treturn rc;\n}\n\nint\nefc_node_free_resources(struct efc *efc, struct efc_remote_node *rnode)\n{\n\tint rc = 0;\n\n\tif (!rnode) {\n\t\tefc_log_err(efc, \"bad parameter rnode=%p\\n\", rnode);\n\t\treturn -EIO;\n\t}\n\n\tif (rnode->nport) {\n\t\tif (rnode->attached) {\n\t\t\tefc_log_err(efc, \"rnode is still attached\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (rnode->indicator != U32_MAX) {\n\t\t\tif (sli_resource_free(efc->sli, SLI4_RSRC_RPI,\n\t\t\t\t\t      rnode->indicator)) {\n\t\t\t\tefc_log_err(efc,\n\t\t\t\t\t    \"RPI free fail RPI %d addr=%#x\\n\",\n\t\t\t\t\t    rnode->indicator, rnode->fc_id);\n\t\t\t\trc = -EIO;\n\t\t\t} else {\n\t\t\t\trnode->indicator = U32_MAX;\n\t\t\t\trnode->index = U32_MAX;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int\nefc_cmd_node_free_cb(struct efc *efc, int status, u8 *mqe, void *arg)\n{\n\tstruct efc_remote_node *rnode = arg;\n\tstruct sli4_mbox_command_header *hdr =\n\t\t\t\t(struct sli4_mbox_command_header *)mqe;\n\tint evt = EFC_EVT_NODE_FREE_FAIL;\n\tint rc = 0;\n\n\tif (status || le16_to_cpu(hdr->status)) {\n\t\tefc_log_debug(efc, \"bad status cqe=%#x mqe=%#x\\n\", status,\n\t\t\t      le16_to_cpu(hdr->status));\n\n\t\t \n\t\tif (!rnode->attached ||\n\t\t    (le16_to_cpu(hdr->status) != SLI4_MBX_STATUS_RPI_NOT_REG))\n\t\t\trc = -EIO;\n\t}\n\n\tif (!rc) {\n\t\trnode->attached = false;\n\t\tevt = EFC_EVT_NODE_FREE_OK;\n\t}\n\n\tefc_remote_node_cb(efc, evt, rnode);\n\n\treturn rc;\n}\n\nint\nefc_cmd_node_detach(struct efc *efc, struct efc_remote_node *rnode)\n{\n\tu8 buf[SLI4_BMBX_SIZE];\n\tint rc = -EIO;\n\n\tif (!rnode) {\n\t\tefc_log_err(efc, \"bad parameter rnode=%p\\n\", rnode);\n\t\treturn -EIO;\n\t}\n\n\tif (rnode->nport) {\n\t\tif (!rnode->attached)\n\t\t\treturn -EIO;\n\n\t\trc = -EIO;\n\n\t\tif (!sli_cmd_unreg_rpi(efc->sli, buf, rnode->indicator,\n\t\t\t\t       SLI4_RSRC_RPI, U32_MAX))\n\t\t\trc = efc->tt.issue_mbox_rqst(efc->base, buf,\n\t\t\t\t\tefc_cmd_node_free_cb, rnode);\n\n\t\tif (rc != 0) {\n\t\t\tefc_log_err(efc, \"UNREG_RPI failed\\n\");\n\t\t\trc = -EIO;\n\t\t}\n\t}\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}