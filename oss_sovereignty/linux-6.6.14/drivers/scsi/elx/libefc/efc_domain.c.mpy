{
  "module_name": "efc_domain.c",
  "hash_id": "87e3076b06eb2e5fd5a79c93ca74166f5ccb16450ec6f77109bafd2aea386e1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/libefc/efc_domain.c",
  "human_readable_source": "\n \n\n \n\n#include \"efc.h\"\n\nint\nefc_domain_cb(void *arg, int event, void *data)\n{\n\tstruct efc *efc = arg;\n\tstruct efc_domain *domain = NULL;\n\tint rc = 0;\n\tunsigned long flags = 0;\n\n\tif (event != EFC_HW_DOMAIN_FOUND)\n\t\tdomain = data;\n\n\t \n\tspin_lock_irqsave(&efc->lock, flags);\n\tswitch (event) {\n\tcase EFC_HW_DOMAIN_FOUND: {\n\t\tu64 fcf_wwn = 0;\n\t\tstruct efc_domain_record *drec = data;\n\n\t\t \n\t\tfcf_wwn = be64_to_cpu(*((__be64 *)drec->wwn));\n\n\t\tefc_log_debug(efc, \"Domain found: wwn %016llX\\n\", fcf_wwn);\n\n\t\t \n\t\tdomain = efc->domain;\n\t\tif (!domain) {\n\t\t\tdomain = efc_domain_alloc(efc, fcf_wwn);\n\t\t\tif (!domain) {\n\t\t\t\tefc_log_err(efc, \"efc_domain_alloc() failed\\n\");\n\t\t\t\trc = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tefc_sm_transition(&domain->drvsm, __efc_domain_init,\n\t\t\t\t\t  NULL);\n\t\t}\n\t\tefc_domain_post_event(domain, EFC_EVT_DOMAIN_FOUND, drec);\n\t\tbreak;\n\t}\n\n\tcase EFC_HW_DOMAIN_LOST:\n\t\tdomain_trace(domain, \"EFC_HW_DOMAIN_LOST:\\n\");\n\t\tefc->hold_frames = true;\n\t\tefc_domain_post_event(domain, EFC_EVT_DOMAIN_LOST, NULL);\n\t\tbreak;\n\n\tcase EFC_HW_DOMAIN_ALLOC_OK:\n\t\tdomain_trace(domain, \"EFC_HW_DOMAIN_ALLOC_OK:\\n\");\n\t\tefc_domain_post_event(domain, EFC_EVT_DOMAIN_ALLOC_OK, NULL);\n\t\tbreak;\n\n\tcase EFC_HW_DOMAIN_ALLOC_FAIL:\n\t\tdomain_trace(domain, \"EFC_HW_DOMAIN_ALLOC_FAIL:\\n\");\n\t\tefc_domain_post_event(domain, EFC_EVT_DOMAIN_ALLOC_FAIL,\n\t\t\t\t      NULL);\n\t\tbreak;\n\n\tcase EFC_HW_DOMAIN_ATTACH_OK:\n\t\tdomain_trace(domain, \"EFC_HW_DOMAIN_ATTACH_OK:\\n\");\n\t\tefc_domain_post_event(domain, EFC_EVT_DOMAIN_ATTACH_OK, NULL);\n\t\tbreak;\n\n\tcase EFC_HW_DOMAIN_ATTACH_FAIL:\n\t\tdomain_trace(domain, \"EFC_HW_DOMAIN_ATTACH_FAIL:\\n\");\n\t\tefc_domain_post_event(domain,\n\t\t\t\t      EFC_EVT_DOMAIN_ATTACH_FAIL, NULL);\n\t\tbreak;\n\n\tcase EFC_HW_DOMAIN_FREE_OK:\n\t\tdomain_trace(domain, \"EFC_HW_DOMAIN_FREE_OK:\\n\");\n\t\tefc_domain_post_event(domain, EFC_EVT_DOMAIN_FREE_OK, NULL);\n\t\tbreak;\n\n\tcase EFC_HW_DOMAIN_FREE_FAIL:\n\t\tdomain_trace(domain, \"EFC_HW_DOMAIN_FREE_FAIL:\\n\");\n\t\tefc_domain_post_event(domain, EFC_EVT_DOMAIN_FREE_FAIL, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tefc_log_warn(efc, \"unsupported event %#x\\n\", event);\n\t}\n\tspin_unlock_irqrestore(&efc->lock, flags);\n\n\tif (efc->domain && domain->req_accept_frames) {\n\t\tdomain->req_accept_frames = false;\n\t\tefc->hold_frames = false;\n\t}\n\n\treturn rc;\n}\n\nstatic void\n_efc_domain_free(struct kref *arg)\n{\n\tstruct efc_domain *domain = container_of(arg, struct efc_domain, ref);\n\tstruct efc *efc = domain->efc;\n\n\tif (efc->domain_free_cb)\n\t\t(*efc->domain_free_cb)(efc, efc->domain_free_cb_arg);\n\n\tkfree(domain);\n}\n\nvoid\nefc_domain_free(struct efc_domain *domain)\n{\n\tstruct efc *efc;\n\n\tefc = domain->efc;\n\n\t \n\tefc->hold_frames = false;\n\n\tefc_log_debug(efc, \"Domain free: wwn %016llX\\n\", domain->fcf_wwn);\n\n\txa_destroy(&domain->lookup);\n\tefc->domain = NULL;\n\tkref_put(&domain->ref, domain->release);\n}\n\nstruct efc_domain *\nefc_domain_alloc(struct efc *efc, uint64_t fcf_wwn)\n{\n\tstruct efc_domain *domain;\n\n\tdomain = kzalloc(sizeof(*domain), GFP_ATOMIC);\n\tif (!domain)\n\t\treturn NULL;\n\n\tdomain->efc = efc;\n\tdomain->drvsm.app = domain;\n\n\t \n\tkref_init(&domain->ref);\n\tdomain->release = _efc_domain_free;\n\n\txa_init(&domain->lookup);\n\n\tINIT_LIST_HEAD(&domain->nport_list);\n\tefc->domain = domain;\n\tdomain->fcf_wwn = fcf_wwn;\n\tefc_log_debug(efc, \"Domain allocated: wwn %016llX\\n\", domain->fcf_wwn);\n\n\treturn domain;\n}\n\nvoid\nefc_register_domain_free_cb(struct efc *efc,\n\t\t\t    void (*callback)(struct efc *efc, void *arg),\n\t\t\t    void *arg)\n{\n\t \n\tefc->domain_free_cb = callback;\n\tefc->domain_free_cb_arg = arg;\n\tif (!efc->domain && callback)\n\t\t(*callback)(efc, arg);\n}\n\nstatic void\n__efc_domain_common(const char *funcname, struct efc_sm_ctx *ctx,\n\t\t    enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_domain *domain = ctx->app;\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\tcase EFC_EVT_REENTER:\n\tcase EFC_EVT_EXIT:\n\tcase EFC_EVT_ALL_CHILD_NODES_FREE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tefc_log_warn(domain->efc, \"%-20s %-20s not handled\\n\",\n\t\t\t     funcname, efc_sm_event_name(evt));\n\t}\n}\n\nstatic void\n__efc_domain_common_shutdown(const char *funcname, struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_domain *domain = ctx->app;\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\tcase EFC_EVT_REENTER:\n\tcase EFC_EVT_EXIT:\n\t\tbreak;\n\tcase EFC_EVT_DOMAIN_FOUND:\n\t\t \n\t\tmemcpy(&domain->pending_drec, arg,\n\t\t       sizeof(domain->pending_drec));\n\t\tdomain->domain_found_pending = true;\n\t\tbreak;\n\tcase EFC_EVT_DOMAIN_LOST:\n\t\t \n\t\tdomain->domain_found_pending = false;\n\t\tbreak;\n\n\tdefault:\n\t\tefc_log_warn(domain->efc, \"%-20s %-20s not handled\\n\",\n\t\t\t     funcname, efc_sm_event_name(evt));\n\t}\n}\n\n#define std_domain_state_decl(...)\\\n\tstruct efc_domain *domain = NULL;\\\n\tstruct efc *efc = NULL;\\\n\t\\\n\tWARN_ON(!ctx || !ctx->app);\\\n\tdomain = ctx->app;\\\n\tWARN_ON(!domain->efc);\\\n\tefc = domain->efc\n\nvoid\n__efc_domain_init(struct efc_sm_ctx *ctx, enum efc_sm_event evt,\n\t\t  void *arg)\n{\n\tstd_domain_state_decl();\n\n\tdomain_sm_trace(domain);\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tdomain->attached = false;\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_FOUND: {\n\t\tu32\ti;\n\t\tstruct efc_domain_record *drec = arg;\n\t\tstruct efc_nport *nport;\n\n\t\tu64 my_wwnn = efc->req_wwnn;\n\t\tu64 my_wwpn = efc->req_wwpn;\n\t\t__be64 bewwpn;\n\n\t\tif (my_wwpn == 0 || my_wwnn == 0) {\n\t\t\tefc_log_debug(efc, \"using default hardware WWN config\\n\");\n\t\t\tmy_wwpn = efc->def_wwpn;\n\t\t\tmy_wwnn = efc->def_wwnn;\n\t\t}\n\n\t\tefc_log_debug(efc, \"Create nport WWPN %016llX WWNN %016llX\\n\",\n\t\t\t      my_wwpn, my_wwnn);\n\n\t\t \n\t\tnport = efc_nport_alloc(domain, my_wwpn, my_wwnn, U32_MAX,\n\t\t\t\t\tefc->enable_ini, efc->enable_tgt);\n\n\t\tif (!nport) {\n\t\t\tefc_log_err(efc, \"efc_nport_alloc() failed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tefc_sm_transition(&nport->sm, __efc_nport_allocated, NULL);\n\n\t\tbewwpn = cpu_to_be64(nport->wwpn);\n\n\t\t \n\t\tif (efc_cmd_nport_alloc(efc, nport, NULL, (uint8_t *)&bewwpn)) {\n\t\t\tefc_log_err(efc, \"Can't allocate port\\n\");\n\t\t\tefc_nport_free(nport);\n\t\t\tbreak;\n\t\t}\n\n\t\tdomain->is_loop = drec->is_loop;\n\n\t\t \n\t\tdomain->is_nlport = drec->map.loop[1] == 0x00;\n\n\t\tif (!domain->is_loop) {\n\t\t\t \n\t\t\tif (efc_cmd_domain_alloc(efc, domain, drec->index)) {\n\t\t\t\tefc_log_err(efc,\n\t\t\t\t\t    \"Failed to initiate HW domain allocation\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tefc_sm_transition(ctx, __efc_domain_wait_alloc, arg);\n\t\t\tbreak;\n\t\t}\n\n\t\tefc_log_debug(efc, \"%s fc_id=%#x speed=%d\\n\",\n\t\t\t      drec->is_loop ?\n\t\t\t      (domain->is_nlport ?\n\t\t\t      \"public-loop\" : \"loop\") : \"other\",\n\t\t\t      drec->fc_id, drec->speed);\n\n\t\tnport->fc_id = drec->fc_id;\n\t\tnport->topology = EFC_NPORT_TOPO_FC_AL;\n\t\tsnprintf(nport->display_name, sizeof(nport->display_name),\n\t\t\t \"s%06x\", drec->fc_id);\n\n\t\tif (efc->enable_ini) {\n\t\t\tu32 count = drec->map.loop[0];\n\n\t\t\tefc_log_debug(efc, \"%d position map entries\\n\",\n\t\t\t\t      count);\n\t\t\tfor (i = 1; i <= count; i++) {\n\t\t\t\tif (drec->map.loop[i] != drec->fc_id) {\n\t\t\t\t\tstruct efc_node *node;\n\n\t\t\t\t\tefc_log_debug(efc, \"%#x -> %#x\\n\",\n\t\t\t\t\t\t      drec->fc_id,\n\t\t\t\t\t\t      drec->map.loop[i]);\n\t\t\t\t\tnode = efc_node_alloc(nport,\n\t\t\t\t\t\t\t      drec->map.loop[i],\n\t\t\t\t\t\t\t      false, true);\n\t\t\t\t\tif (!node) {\n\t\t\t\t\t\tefc_log_err(efc,\n\t\t\t\t\t\t\t    \"efc_node_alloc() failed\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tefc_node_transition(node,\n\t\t\t\t\t\t\t    __efc_d_wait_loop,\n\t\t\t\t\t\t\t    NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (efc_cmd_domain_alloc(efc, domain, drec->index)) {\n\t\t\tefc_log_err(efc,\n\t\t\t\t    \"Failed to initiate HW domain allocation\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tefc_sm_transition(ctx, __efc_domain_wait_alloc, arg);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_domain_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_domain_wait_alloc(struct efc_sm_ctx *ctx,\n\t\t\tenum efc_sm_event evt, void *arg)\n{\n\tstd_domain_state_decl();\n\n\tdomain_sm_trace(domain);\n\n\tswitch (evt) {\n\tcase EFC_EVT_DOMAIN_ALLOC_OK: {\n\t\tstruct fc_els_flogi  *sp;\n\t\tstruct efc_nport *nport;\n\n\t\tnport = domain->nport;\n\t\tif (WARN_ON(!nport))\n\t\t\treturn;\n\n\t\tsp = (struct fc_els_flogi  *)nport->service_params;\n\n\t\t \n\t\tmemcpy(domain->service_params + 4, domain->dma.virt,\n\t\t       sizeof(struct fc_els_flogi) - 4);\n\t\tmemcpy(nport->service_params + 4, domain->dma.virt,\n\t\t       sizeof(struct fc_els_flogi) - 4);\n\n\t\t \n\t\tsp->fl_wwpn = cpu_to_be64(nport->wwpn);\n\t\tsp->fl_wwnn = cpu_to_be64(nport->wwnn);\n\n\t\t \n\t\tif (domain->is_loop && !domain->is_nlport) {\n\t\t\t \n\t\t\t \n\t\t\tefc_sm_transition(ctx, __efc_domain_allocated, NULL);\n\t\t\t__efc_domain_attach_internal(domain, nport->fc_id);\n\t\t\tbreak;\n\t\t}\n\t\t{\n\t\t\tstruct efc_node *node;\n\n\t\t\t \n\t\t\tnode = efc_node_find(nport, FC_FID_FLOGI);\n\t\t\tif (node) {\n\t\t\t\tefc_log_err(efc,\n\t\t\t\t\t    \"Fabric Controller node already exists\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnode = efc_node_alloc(nport, FC_FID_FLOGI,\n\t\t\t\t\t      false, false);\n\t\t\tif (!node) {\n\t\t\t\tefc_log_err(efc,\n\t\t\t\t\t    \"Error: efc_node_alloc() failed\\n\");\n\t\t\t} else {\n\t\t\t\tefc_node_transition(node,\n\t\t\t\t\t\t    __efc_fabric_init, NULL);\n\t\t\t}\n\t\t\t \n\t\t\tdomain->req_accept_frames = true;\n\t\t}\n\t\t \n\t\tefc_sm_transition(ctx, __efc_domain_allocated, NULL);\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_DOMAIN_ALLOC_FAIL:\n\t\tefc_log_err(efc, \"%s recv'd waiting for DOMAIN_ALLOC_OK;\",\n\t\t\t    efc_sm_event_name(evt));\n\t\tefc_log_err(efc, \"shutting down domain\\n\");\n\t\tdomain->req_domain_free = true;\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_FOUND:\n\t\t \n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_LOST:\n\t\tefc_log_debug(efc,\n\t\t\t      \"%s received while waiting for hw_domain_alloc()\\n\",\n\t\t\tefc_sm_event_name(evt));\n\t\tefc_sm_transition(ctx, __efc_domain_wait_domain_lost, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_domain_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_domain_allocated(struct efc_sm_ctx *ctx,\n\t\t       enum efc_sm_event evt, void *arg)\n{\n\tstd_domain_state_decl();\n\n\tdomain_sm_trace(domain);\n\n\tswitch (evt) {\n\tcase EFC_EVT_DOMAIN_REQ_ATTACH: {\n\t\tint rc = 0;\n\t\tu32 fc_id;\n\n\t\tif (WARN_ON(!arg))\n\t\t\treturn;\n\n\t\tfc_id = *((u32 *)arg);\n\t\tefc_log_debug(efc, \"Requesting hw domain attach fc_id x%x\\n\",\n\t\t\t      fc_id);\n\t\t \n\t\trc = xa_err(xa_store(&domain->lookup, fc_id, domain->nport,\n\t\t\t\t     GFP_ATOMIC));\n\t\tif (rc) {\n\t\t\tefc_log_err(efc, \"Sport lookup store failed: %d\\n\", rc);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tefc_node_fcid_display(fc_id, domain->nport->display_name,\n\t\t\t\t      sizeof(domain->nport->display_name));\n\n\t\t \n\t\trc = efc_cmd_domain_attach(efc, domain, fc_id);\n\t\tif (rc) {\n\t\t\tefc_log_err(efc, \"efc_hw_domain_attach failed: %d\\n\",\n\t\t\t\t    rc);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tefc_sm_transition(ctx, __efc_domain_wait_attach, NULL);\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_DOMAIN_FOUND:\n\t\t \n\t\tefc_log_err(efc, \"%s: evt: %d should not happen\\n\",\n\t\t\t    __func__, evt);\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_LOST: {\n\t\tefc_log_debug(efc,\n\t\t\t      \"%s received while in EFC_EVT_DOMAIN_REQ_ATTACH\\n\",\n\t\t\tefc_sm_event_name(evt));\n\t\tif (!list_empty(&domain->nport_list)) {\n\t\t\t \n\t\t\tstruct efc_nport *nport = NULL, *nport_next = NULL;\n\n\t\t\tefc_sm_transition(ctx, __efc_domain_wait_nports_free,\n\t\t\t\t\t  NULL);\n\t\t\tlist_for_each_entry_safe(nport, nport_next,\n\t\t\t\t\t\t &domain->nport_list,\n\t\t\t\t\t\t list_entry) {\n\t\t\t\tefc_sm_post_event(&nport->sm,\n\t\t\t\t\t\t  EFC_EVT_SHUTDOWN, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tefc_sm_transition(ctx, __efc_domain_wait_shutdown,\n\t\t\t\t\t  NULL);\n\t\t\tif (efc_cmd_domain_free(efc, domain))\n\t\t\t\tefc_log_err(efc, \"hw_domain_free failed\\n\");\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_domain_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_domain_wait_attach(struct efc_sm_ctx *ctx,\n\t\t\t enum efc_sm_event evt, void *arg)\n{\n\tstd_domain_state_decl();\n\n\tdomain_sm_trace(domain);\n\n\tswitch (evt) {\n\tcase EFC_EVT_DOMAIN_ATTACH_OK: {\n\t\tstruct efc_node *node = NULL;\n\t\tstruct efc_nport *nport, *next_nport;\n\t\tunsigned long index;\n\n\t\t \n\t\tdomain->domain_notify_pend = true;\n\n\t\t \n\t\tdomain->attached = true;\n\n\t\t \n\t\t \n\t\tefc_sm_transition(ctx, __efc_domain_ready, NULL);\n\n\t\t \n\t\tdomain->req_accept_frames = true;\n\n\t\t \n\t\tlist_for_each_entry_safe(nport, next_nport,\n\t\t\t\t\t &domain->nport_list, list_entry) {\n\t\t\txa_for_each(&nport->lookup, index, node) {\n\t\t\t\tefc_node_post_event(node,\n\t\t\t\t\t\t    EFC_EVT_DOMAIN_ATTACH_OK,\n\t\t\t\t\t\t    NULL);\n\t\t\t}\n\t\t}\n\t\tdomain->domain_notify_pend = false;\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_DOMAIN_ATTACH_FAIL:\n\t\tefc_log_debug(efc,\n\t\t\t      \"%s received while waiting for hw attach\\n\",\n\t\t\t      efc_sm_event_name(evt));\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_FOUND:\n\t\t \n\t\tefc_log_err(efc, \"%s: evt: %d should not happen\\n\",\n\t\t\t    __func__, evt);\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_LOST:\n\t\t \n\t\tefc_sm_transition(ctx, __efc_domain_wait_domain_lost, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_REQ_ATTACH:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\t__efc_domain_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_domain_ready(struct efc_sm_ctx *ctx, enum efc_sm_event evt, void *arg)\n{\n\tstd_domain_state_decl();\n\n\tdomain_sm_trace(domain);\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER: {\n\t\t \n\t\tif (efc_vport_start(domain)) {\n\t\t\tefc_log_debug(domain->efc,\n\t\t\t\t      \"efc_vport_start didn't start vports\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase EFC_EVT_DOMAIN_LOST: {\n\t\tif (!list_empty(&domain->nport_list)) {\n\t\t\t \n\t\t\tstruct efc_nport *nport = NULL, *nport_next = NULL;\n\n\t\t\tefc_sm_transition(ctx, __efc_domain_wait_nports_free,\n\t\t\t\t\t  NULL);\n\t\t\tlist_for_each_entry_safe(nport, nport_next,\n\t\t\t\t\t\t &domain->nport_list,\n\t\t\t\t\t\t list_entry) {\n\t\t\t\tefc_sm_post_event(&nport->sm,\n\t\t\t\t\t\t  EFC_EVT_SHUTDOWN, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tefc_sm_transition(ctx, __efc_domain_wait_shutdown,\n\t\t\t\t\t  NULL);\n\t\t\tif (efc_cmd_domain_free(efc, domain))\n\t\t\t\tefc_log_err(efc, \"hw_domain_free failed\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_DOMAIN_FOUND:\n\t\t \n\t\tefc_log_err(efc, \"%s: evt: %d should not happen\\n\",\n\t\t\t    __func__, evt);\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_REQ_ATTACH: {\n\t\t \n\t\tu32 fc_id;\n\n\t\tfc_id = *((u32 *)arg);\n\n\t\t \n\t\tWARN_ON(!domain->attached);\n\n\t\t \n\t\tWARN_ON(domain->nport->fc_id != fc_id);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_domain_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_domain_wait_nports_free(struct efc_sm_ctx *ctx, enum efc_sm_event evt,\n\t\t\t      void *arg)\n{\n\tstd_domain_state_decl();\n\n\tdomain_sm_trace(domain);\n\n\t \n\tswitch (evt) {\n\tcase EFC_EVT_ALL_CHILD_NODES_FREE: {\n\t\tint rc;\n\n\t\t \n\t\tefc_sm_transition(ctx, __efc_domain_wait_shutdown, NULL);\n\n\t\t \n\t\trc = efc_cmd_domain_free(efc, domain);\n\t\tif (rc) {\n\t\t\tefc_log_err(efc, \"efc_hw_domain_free() failed: %d\\n\",\n\t\t\t\t    rc);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_domain_common_shutdown(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_domain_wait_shutdown(struct efc_sm_ctx *ctx,\n\t\t\t   enum efc_sm_event evt, void *arg)\n{\n\tstd_domain_state_decl();\n\n\tdomain_sm_trace(domain);\n\n\tswitch (evt) {\n\tcase EFC_EVT_DOMAIN_FREE_OK:\n\t\t \n\t\tif (domain->domain_found_pending) {\n\t\t\t \n\t\t\tu64 fcf_wwn = domain->fcf_wwn;\n\t\t\tstruct efc_domain_record drec = domain->pending_drec;\n\n\t\t\tefc_log_debug(efc, \"Reallocating domain\\n\");\n\t\t\tdomain->req_domain_free = true;\n\t\t\tdomain = efc_domain_alloc(efc, fcf_wwn);\n\n\t\t\tif (!domain) {\n\t\t\t\tefc_log_err(efc,\n\t\t\t\t\t    \"efc_domain_alloc() failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tefc_sm_transition(&domain->drvsm, __efc_domain_init,\n\t\t\t\t\t  NULL);\n\t\t\tefc_sm_post_event(&domain->drvsm,\n\t\t\t\t\t  EFC_EVT_DOMAIN_FOUND, &drec);\n\t\t} else {\n\t\t\tdomain->req_domain_free = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t__efc_domain_common_shutdown(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_domain_wait_domain_lost(struct efc_sm_ctx *ctx,\n\t\t\t      enum efc_sm_event evt, void *arg)\n{\n\tstd_domain_state_decl();\n\n\tdomain_sm_trace(domain);\n\n\t \n\tswitch (evt) {\n\tcase EFC_EVT_DOMAIN_ALLOC_OK:\n\tcase EFC_EVT_DOMAIN_ATTACH_OK: {\n\t\tif (!list_empty(&domain->nport_list)) {\n\t\t\t \n\t\t\tstruct efc_nport *nport = NULL, *nport_next = NULL;\n\n\t\t\tefc_sm_transition(ctx, __efc_domain_wait_nports_free,\n\t\t\t\t\t  NULL);\n\t\t\tlist_for_each_entry_safe(nport, nport_next,\n\t\t\t\t\t\t &domain->nport_list,\n\t\t\t\t\t\t list_entry) {\n\t\t\t\tefc_sm_post_event(&nport->sm,\n\t\t\t\t\t\t  EFC_EVT_SHUTDOWN, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tefc_sm_transition(ctx, __efc_domain_wait_shutdown,\n\t\t\t\t\t  NULL);\n\t\t\tif (efc_cmd_domain_free(efc, domain))\n\t\t\t\tefc_log_err(efc, \"hw_domain_free() failed\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase EFC_EVT_DOMAIN_ALLOC_FAIL:\n\tcase EFC_EVT_DOMAIN_ATTACH_FAIL:\n\t\tefc_log_err(efc, \"[domain] %-20s: failed\\n\",\n\t\t\t    efc_sm_event_name(evt));\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_domain_common_shutdown(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_domain_attach_internal(struct efc_domain *domain, u32 s_id)\n{\n\tmemcpy(domain->dma.virt,\n\t       ((uint8_t *)domain->flogi_service_params) + 4,\n\t\t   sizeof(struct fc_els_flogi) - 4);\n\t(void)efc_sm_post_event(&domain->drvsm, EFC_EVT_DOMAIN_REQ_ATTACH,\n\t\t\t\t &s_id);\n}\n\nvoid\nefc_domain_attach(struct efc_domain *domain, u32 s_id)\n{\n\t__efc_domain_attach_internal(domain, s_id);\n}\n\nint\nefc_domain_post_event(struct efc_domain *domain,\n\t\t      enum efc_sm_event event, void *arg)\n{\n\tint rc;\n\tbool req_domain_free;\n\n\trc = efc_sm_post_event(&domain->drvsm, event, arg);\n\n\treq_domain_free = domain->req_domain_free;\n\tdomain->req_domain_free = false;\n\n\tif (req_domain_free)\n\t\tefc_domain_free(domain);\n\n\treturn rc;\n}\n\nstatic void\nefct_domain_process_pending(struct efc_domain *domain)\n{\n\tstruct efc *efc = domain->efc;\n\tstruct efc_hw_sequence *seq = NULL;\n\tu32 processed = 0;\n\tunsigned long flags = 0;\n\n\tfor (;;) {\n\t\t \n\t\tif (efc->hold_frames)\n\t\t\tbreak;\n\n\t\t \n\t\tspin_lock_irqsave(&efc->pend_frames_lock, flags);\n\n\t\tif (!list_empty(&efc->pend_frames)) {\n\t\t\tseq = list_first_entry(&efc->pend_frames,\n\t\t\t\t\tstruct efc_hw_sequence, list_entry);\n\t\t\tlist_del(&seq->list_entry);\n\t\t}\n\n\t\tif (!seq) {\n\t\t\tprocessed = efc->pend_frames_processed;\n\t\t\tefc->pend_frames_processed = 0;\n\t\t\tspin_unlock_irqrestore(&efc->pend_frames_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tefc->pend_frames_processed++;\n\n\t\tspin_unlock_irqrestore(&efc->pend_frames_lock, flags);\n\n\t\t \n\t\tif (efc_domain_dispatch_frame(domain, seq))\n\t\t\tefc->tt.hw_seq_free(efc, seq);\n\n\t\tseq = NULL;\n\t}\n\n\tif (processed != 0)\n\t\tefc_log_debug(efc, \"%u domain frames held and processed\\n\",\n\t\t\t      processed);\n}\n\nvoid\nefc_dispatch_frame(struct efc *efc, struct efc_hw_sequence *seq)\n{\n\tstruct efc_domain *domain = efc->domain;\n\n\t \n\tif (!domain || efc->hold_frames || !list_empty(&efc->pend_frames)) {\n\t\tunsigned long flags = 0;\n\n\t\tspin_lock_irqsave(&efc->pend_frames_lock, flags);\n\t\tINIT_LIST_HEAD(&seq->list_entry);\n\t\tlist_add_tail(&seq->list_entry, &efc->pend_frames);\n\t\tspin_unlock_irqrestore(&efc->pend_frames_lock, flags);\n\n\t\tif (domain) {\n\t\t\t \n\t\t\tefct_domain_process_pending(domain);\n\t\t}\n\t} else {\n\t\t \n\t\tif (efc_domain_dispatch_frame(domain, seq))\n\t\t\tefc->tt.hw_seq_free(efc, seq);\n\t}\n}\n\nint\nefc_domain_dispatch_frame(void *arg, struct efc_hw_sequence *seq)\n{\n\tstruct efc_domain *domain = (struct efc_domain *)arg;\n\tstruct efc *efc = domain->efc;\n\tstruct fc_frame_header *hdr;\n\tstruct efc_node *node = NULL;\n\tstruct efc_nport *nport = NULL;\n\tunsigned long flags = 0;\n\tu32 s_id, d_id, rc = EFC_HW_SEQ_FREE;\n\n\tif (!seq->header || !seq->header->dma.virt || !seq->payload->dma.virt) {\n\t\tefc_log_err(efc, \"Sequence header or payload is null\\n\");\n\t\treturn rc;\n\t}\n\n\thdr = seq->header->dma.virt;\n\n\t \n\ts_id = ntoh24(hdr->fh_s_id);\n\td_id = ntoh24(hdr->fh_d_id);\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\n\tnport = efc_nport_find(domain, d_id);\n\tif (!nport) {\n\t\tif (hdr->fh_type == FC_TYPE_FCP) {\n\t\t\t \n\t\t\tefc_log_warn(efc, \"FCP frame with invalid d_id x%x\\n\",\n\t\t\t\t     d_id);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tnport = domain->nport;\n\t\tif (!nport || !kref_get_unless_zero(&nport->ref)) {\n\t\t\tefc_log_err(efc, \"Physical nport is NULL\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tnode = efc_node_find(nport, s_id);\n\n\t \n\tif (!node) {\n\t\t \n\t\tif ((hdr->fh_r_ctl == FC_RCTL_DD_SOL_DATA) ||\n\t\t    (hdr->fh_r_ctl == FC_RCTL_DD_SOL_CTL)) {\n\t\t\tefc_log_debug(efc, \"sol data/ctrl frame without node\\n\");\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tnode = efc_node_alloc(nport, s_id, false, false);\n\t\tif (!node) {\n\t\t\tefc_log_err(efc, \"efc_node_alloc() failed\\n\");\n\t\t\tgoto out_release;\n\t\t}\n\t\t \n\t\tefc_node_init_device(node, false);\n\t}\n\n\tif (node->hold_frames || !list_empty(&node->pend_frames)) {\n\t\t \n\t\tspin_lock(&node->pend_frames_lock);\n\t\tINIT_LIST_HEAD(&seq->list_entry);\n\t\tlist_add_tail(&seq->list_entry, &node->pend_frames);\n\t\tspin_unlock(&node->pend_frames_lock);\n\t\trc = EFC_HW_SEQ_HOLD;\n\t\tgoto out_release;\n\t}\n\n\t \n\tefc_node_dispatch_frame(node, seq);\n\nout_release:\n\tkref_put(&nport->ref, nport->release);\nout:\n\tspin_unlock_irqrestore(&efc->lock, flags);\n\treturn rc;\n}\n\nvoid\nefc_node_dispatch_frame(void *arg, struct efc_hw_sequence *seq)\n{\n\tstruct fc_frame_header *hdr = seq->header->dma.virt;\n\tu32 port_id;\n\tstruct efc_node *node = (struct efc_node *)arg;\n\tstruct efc *efc = node->efc;\n\n\tport_id = ntoh24(hdr->fh_s_id);\n\n\tif (WARN_ON(port_id != node->rnode.fc_id))\n\t\treturn;\n\n\tif ((!(ntoh24(hdr->fh_f_ctl) & FC_FC_END_SEQ)) ||\n\t    !(ntoh24(hdr->fh_f_ctl) & FC_FC_SEQ_INIT)) {\n\t\tnode_printf(node,\n\t\t\t    \"Drop frame hdr = %08x %08x %08x %08x %08x %08x\\n\",\n\t\t\t    cpu_to_be32(((u32 *)hdr)[0]),\n\t\t\t    cpu_to_be32(((u32 *)hdr)[1]),\n\t\t\t    cpu_to_be32(((u32 *)hdr)[2]),\n\t\t\t    cpu_to_be32(((u32 *)hdr)[3]),\n\t\t\t    cpu_to_be32(((u32 *)hdr)[4]),\n\t\t\t    cpu_to_be32(((u32 *)hdr)[5]));\n\t\treturn;\n\t}\n\n\tswitch (hdr->fh_r_ctl) {\n\tcase FC_RCTL_ELS_REQ:\n\tcase FC_RCTL_ELS_REP:\n\t\tefc_node_recv_els_frame(node, seq);\n\t\tbreak;\n\n\tcase FC_RCTL_BA_ABTS:\n\tcase FC_RCTL_BA_ACC:\n\tcase FC_RCTL_BA_RJT:\n\tcase FC_RCTL_BA_NOP:\n\t\tefc_log_err(efc, \"Received ABTS:\\n\");\n\t\tbreak;\n\n\tcase FC_RCTL_DD_UNSOL_CMD:\n\tcase FC_RCTL_DD_UNSOL_CTL:\n\t\tswitch (hdr->fh_type) {\n\t\tcase FC_TYPE_FCP:\n\t\t\tif ((hdr->fh_r_ctl & 0xf) == FC_RCTL_DD_UNSOL_CMD) {\n\t\t\t\tif (!node->fcp_enabled) {\n\t\t\t\t\tefc_node_recv_fcp_cmd(node, seq);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tefc_log_err(efc, \"Recvd FCP CMD. Drop IO\\n\");\n\t\t\t} else if ((hdr->fh_r_ctl & 0xf) ==\n\t\t\t\t\t\t\tFC_RCTL_DD_SOL_DATA) {\n\t\t\t\tnode_printf(node,\n\t\t\t\t\t    \"solicited data recvd. Drop IO\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FC_TYPE_CT:\n\t\t\tefc_node_recv_ct_frame(node, seq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tefc_log_err(efc, \"Unhandled frame rctl: %02x\\n\", hdr->fh_r_ctl);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}