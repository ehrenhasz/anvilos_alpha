{
  "module_name": "efc_fabric.c",
  "hash_id": "38eab8058d2df62f07606bf5cb69a74f161fa78329e560390a4182a29a5cf6c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/libefc/efc_fabric.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"efc.h\"\n\nstatic void\nefc_fabric_initiate_shutdown(struct efc_node *node)\n{\n\tstruct efc *efc = node->efc;\n\n\tnode->els_io_enabled = false;\n\n\tif (node->attached) {\n\t\tint rc;\n\n\t\t \n\t\trc = efc_cmd_node_detach(efc, &node->rnode);\n\t\tif (rc < 0) {\n\t\t\tnode_printf(node, \"Failed freeing HW node, rc=%d\\n\",\n\t\t\t\t    rc);\n\t\t}\n\t}\n\t \n\tefc_node_initiate_cleanup(node);\n}\n\nstatic void\n__efc_fabric_common(const char *funcname, struct efc_sm_ctx *ctx,\n\t\t    enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = NULL;\n\n\tnode = ctx->app;\n\n\tswitch (evt) {\n\tcase EFC_EVT_DOMAIN_ATTACH_OK:\n\t\tbreak;\n\tcase EFC_EVT_SHUTDOWN:\n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tefc_fabric_initiate_shutdown(node);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\t__efc_node_common(funcname, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_fabric_init(struct efc_sm_ctx *ctx, enum efc_sm_event evt,\n\t\t  void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\tstruct efc *efc = node->efc;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_REENTER:\n\t\tefc_log_debug(efc, \">>> reenter !!\\n\");\n\t\tfallthrough;\n\n\tcase EFC_EVT_ENTER:\n\t\t \n\t\tefc_send_flogi(node);\n\t\tefc_node_transition(node, __efc_fabric_flogi_wait_rsp, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\nefc_fabric_set_topology(struct efc_node *node,\n\t\t\tenum efc_nport_topology topology)\n{\n\tnode->nport->topology = topology;\n}\n\nvoid\nefc_fabric_notify_topology(struct efc_node *node)\n{\n\tstruct efc_node *tmp_node;\n\tunsigned long index;\n\n\t \n\txa_for_each(&node->nport->lookup, index, tmp_node) {\n\t\tif (tmp_node != node) {\n\t\t\tefc_node_post_event(tmp_node,\n\t\t\t\t\t    EFC_EVT_NPORT_TOPOLOGY_NOTIFY,\n\t\t\t\t\t    &node->nport->topology);\n\t\t}\n\t}\n}\n\nstatic bool efc_rnode_is_nport(struct fc_els_flogi *rsp)\n{\n\treturn !(ntohs(rsp->fl_csp.sp_features) & FC_SP_FT_FPORT);\n}\n\nvoid\n__efc_fabric_flogi_wait_rsp(struct efc_sm_ctx *ctx,\n\t\t\t    enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_SRRS_ELS_REQ_OK: {\n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_FLOGI,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\n\t\tmemcpy(node->nport->domain->flogi_service_params,\n\t\t       cbdata->els_rsp.virt,\n\t\t       sizeof(struct fc_els_flogi));\n\n\t\t \n\t\tif (!efc_rnode_is_nport(cbdata->els_rsp.virt)) {\n\t\t\t \n\t\t\t \n\t\t\tefc_fabric_set_topology(node, EFC_NPORT_TOPO_FABRIC);\n\t\t\tefc_fabric_notify_topology(node);\n\t\t\tWARN_ON(node->nport->domain->attached);\n\t\t\tefc_domain_attach(node->nport->domain,\n\t\t\t\t\t  cbdata->ext_status);\n\t\t\tefc_node_transition(node,\n\t\t\t\t\t    __efc_fabric_wait_domain_attach,\n\t\t\t\t\t    NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tefc_fabric_set_topology(node, EFC_NPORT_TOPO_P2P);\n\t\tif (efc_p2p_setup(node->nport)) {\n\t\t\tnode_printf(node,\n\t\t\t\t    \"p2p setup failed, shutting down node\\n\");\n\t\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\t\tefc_fabric_initiate_shutdown(node);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (node->nport->p2p_winner) {\n\t\t\tefc_node_transition(node,\n\t\t\t\t\t    __efc_p2p_wait_domain_attach,\n\t\t\t\t\t     NULL);\n\t\t\tif (node->nport->domain->attached &&\n\t\t\t    !node->nport->domain->domain_notify_pend) {\n\t\t\t\t \n\t\t\t\tnode_printf(node,\n\t\t\t\t\t    \"p2p winner, domain already attached\\n\");\n\t\t\t\tefc_node_post_event(node,\n\t\t\t\t\t\t    EFC_EVT_DOMAIN_ATTACH_OK,\n\t\t\t\t\t\t    NULL);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\t\tefc_fabric_initiate_shutdown(node);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_ELS_REQ_ABORTED:\n\tcase EFC_EVT_SRRS_ELS_REQ_RJT:\n\tcase EFC_EVT_SRRS_ELS_REQ_FAIL: {\n\t\tstruct efc_nport *nport = node->nport;\n\t\t \n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_FLOGI,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tnode_printf(node,\n\t\t\t    \"FLOGI failed evt=%s, shutting down nport [%s]\\n\",\n\t\t\t    efc_sm_event_name(evt), nport->display_name);\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\tefc_sm_post_event(&nport->sm, EFC_EVT_SHUTDOWN, NULL);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_vport_fabric_init(struct efc_sm_ctx *ctx,\n\t\t\tenum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\t \n\t\tefc_send_fdisc(node);\n\t\tefc_node_transition(node, __efc_fabric_fdisc_wait_rsp, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_fabric_fdisc_wait_rsp(struct efc_sm_ctx *ctx,\n\t\t\t    enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_SRRS_ELS_REQ_OK: {\n\t\t \n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_FDISC,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\t \n\t\tefc_nport_attach(node->nport, cbdata->ext_status);\n\t\tefc_node_transition(node, __efc_fabric_wait_domain_attach,\n\t\t\t\t    NULL);\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_SRRS_ELS_REQ_RJT:\n\tcase EFC_EVT_SRRS_ELS_REQ_FAIL: {\n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_FDISC,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\tefc_log_err(node->efc, \"FDISC failed, shutting down nport\\n\");\n\t\t \n\t\tefc_sm_post_event(&node->nport->sm, EFC_EVT_SHUTDOWN, NULL);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nstatic int\nefc_start_ns_node(struct efc_nport *nport)\n{\n\tstruct efc_node *ns;\n\n\t \n\tns = efc_node_find(nport, FC_FID_DIR_SERV);\n\tif (!ns) {\n\t\tns = efc_node_alloc(nport, FC_FID_DIR_SERV, false, false);\n\t\tif (!ns)\n\t\t\treturn -EIO;\n\t}\n\t \n\tif (ns->efc->nodedb_mask & EFC_NODEDB_PAUSE_NAMESERVER)\n\t\tefc_node_pause(ns, __efc_ns_init);\n\telse\n\t\tefc_node_transition(ns, __efc_ns_init, NULL);\n\treturn 0;\n}\n\nstatic int\nefc_start_fabctl_node(struct efc_nport *nport)\n{\n\tstruct efc_node *fabctl;\n\n\tfabctl = efc_node_find(nport, FC_FID_FCTRL);\n\tif (!fabctl) {\n\t\tfabctl = efc_node_alloc(nport, FC_FID_FCTRL,\n\t\t\t\t\tfalse, false);\n\t\tif (!fabctl)\n\t\t\treturn -EIO;\n\t}\n\t \n\tefc_node_transition(fabctl, __efc_fabctl_init, NULL);\n\treturn 0;\n}\n\nvoid\n__efc_fabric_wait_domain_attach(struct efc_sm_ctx *ctx,\n\t\t\t\tenum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\tcase EFC_EVT_DOMAIN_ATTACH_OK:\n\tcase EFC_EVT_NPORT_ATTACH_OK: {\n\t\tint rc;\n\n\t\trc = efc_start_ns_node(node->nport);\n\t\tif (rc)\n\t\t\treturn;\n\n\t\t \n\t\t \n\t\tif (node->nport->enable_rscn) {\n\t\t\trc = efc_start_fabctl_node(node->nport);\n\t\t\tif (rc)\n\t\t\t\treturn;\n\t\t}\n\t\tefc_node_transition(node, __efc_fabric_idle, NULL);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_fabric_idle(struct efc_sm_ctx *ctx, enum efc_sm_event evt,\n\t\t  void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_DOMAIN_ATTACH_OK:\n\t\tbreak;\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_ns_init(struct efc_sm_ctx *ctx, enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\t \n\t\tefc_send_plogi(node);\n\t\tefc_node_transition(node, __efc_ns_plogi_wait_rsp, NULL);\n\t\tbreak;\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_ns_plogi_wait_rsp(struct efc_sm_ctx *ctx,\n\t\t\tenum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_SRRS_ELS_REQ_OK: {\n\t\tint rc;\n\n\t\t \n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_PLOGI,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\t \n\t\tefc_node_save_sparms(node, cbdata->els_rsp.virt);\n\t\trc = efc_node_attach(node);\n\t\tefc_node_transition(node, __efc_ns_wait_node_attach, NULL);\n\t\tif (rc < 0)\n\t\t\tefc_node_post_event(node, EFC_EVT_NODE_ATTACH_FAIL,\n\t\t\t\t\t    NULL);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_ns_wait_node_attach(struct efc_sm_ctx *ctx,\n\t\t\t  enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_ATTACH_OK:\n\t\tnode->attached = true;\n\t\t \n\t\tefc_ns_send_rftid(node);\n\t\tefc_node_transition(node, __efc_ns_rftid_wait_rsp, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_ATTACH_FAIL:\n\t\t \n\t\tnode->attached = false;\n\t\tnode_printf(node, \"Node attach failed\\n\");\n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tefc_fabric_initiate_shutdown(node);\n\t\tbreak;\n\n\tcase EFC_EVT_SHUTDOWN:\n\t\tnode_printf(node, \"Shutdown event received\\n\");\n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tefc_node_transition(node,\n\t\t\t\t    __efc_fabric_wait_attach_evt_shutdown,\n\t\t\t\t     NULL);\n\t\tbreak;\n\n\t \n\tcase EFC_EVT_RSCN_RCVD:\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_fabric_wait_attach_evt_shutdown(struct efc_sm_ctx *ctx,\n\t\t\t\t      enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\t \n\tcase EFC_EVT_NODE_ATTACH_OK:\n\t\tnode->attached = true;\n\t\tnode_printf(node, \"Attach evt=%s, proceed to shutdown\\n\",\n\t\t\t    efc_sm_event_name(evt));\n\t\tefc_fabric_initiate_shutdown(node);\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_ATTACH_FAIL:\n\t\tnode->attached = false;\n\t\tnode_printf(node, \"Attach evt=%s, proceed to shutdown\\n\",\n\t\t\t    efc_sm_event_name(evt));\n\t\tefc_fabric_initiate_shutdown(node);\n\t\tbreak;\n\n\t \n\tcase EFC_EVT_SHUTDOWN:\n\t\tnode_printf(node, \"Shutdown event received\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_ns_rftid_wait_rsp(struct efc_sm_ctx *ctx,\n\t\t\tenum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_SRRS_ELS_REQ_OK:\n\t\tif (efc_node_check_ns_req(ctx, evt, arg, FC_NS_RFT_ID,\n\t\t\t\t\t  __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\t \n\t\tefc_ns_send_rffid(node);\n\t\tefc_node_transition(node, __efc_ns_rffid_wait_rsp, NULL);\n\t\tbreak;\n\n\t \n\tcase EFC_EVT_RSCN_RCVD:\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_ns_rffid_wait_rsp(struct efc_sm_ctx *ctx,\n\t\t\tenum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\t \n\tswitch (evt) {\n\tcase EFC_EVT_SRRS_ELS_REQ_OK:\t{\n\t\tif (efc_node_check_ns_req(ctx, evt, arg, FC_NS_RFF_ID,\n\t\t\t\t\t  __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\tif (node->nport->enable_rscn) {\n\t\t\t \n\t\t\tefc_ns_send_gidpt(node);\n\n\t\t\tefc_node_transition(node, __efc_ns_gidpt_wait_rsp,\n\t\t\t\t\t    NULL);\n\t\t} else {\n\t\t\t \n\t\t\tefc_node_transition(node, __efc_ns_idle, NULL);\n\t\t}\n\t\tbreak;\n\t}\n\t \n\tcase EFC_EVT_RSCN_RCVD:\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nstatic int\nefc_process_gidpt_payload(struct efc_node *node,\n\t\t\t  void *data, u32 gidpt_len)\n{\n\tu32 i, j;\n\tstruct efc_node *newnode;\n\tstruct efc_nport *nport = node->nport;\n\tstruct efc *efc = node->efc;\n\tu32 port_id = 0, port_count, plist_count;\n\tstruct efc_node *n;\n\tstruct efc_node **active_nodes;\n\tint residual;\n\tstruct {\n\t\tstruct fc_ct_hdr hdr;\n\t\tstruct fc_gid_pn_resp pn_rsp;\n\t} *rsp;\n\tstruct fc_gid_pn_resp *gidpt;\n\tunsigned long index;\n\n\trsp = data;\n\tgidpt = &rsp->pn_rsp;\n\tresidual = be16_to_cpu(rsp->hdr.ct_mr_size);\n\n\tif (residual != 0)\n\t\tefc_log_debug(node->efc, \"residual is %u words\\n\", residual);\n\n\tif (be16_to_cpu(rsp->hdr.ct_cmd) == FC_FS_RJT) {\n\t\tnode_printf(node,\n\t\t\t    \"GIDPT request failed: rsn x%x rsn_expl x%x\\n\",\n\t\t\t    rsp->hdr.ct_reason, rsp->hdr.ct_explan);\n\t\treturn -EIO;\n\t}\n\n\tplist_count = (gidpt_len - sizeof(struct fc_ct_hdr)) / sizeof(*gidpt);\n\n\t \n\tport_count = 0;\n\txa_for_each(&nport->lookup, index, n) {\n\t\tport_count++;\n\t}\n\n\t \n\tactive_nodes = kcalloc(port_count, sizeof(*active_nodes), GFP_ATOMIC);\n\tif (!active_nodes) {\n\t\tnode_printf(node, \"efc_malloc failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\ti = 0;\n\txa_for_each(&nport->lookup, index, n) {\n\t\tport_id = n->rnode.fc_id;\n\t\tswitch (port_id) {\n\t\tcase FC_FID_FLOGI:\n\t\tcase FC_FID_FCTRL:\n\t\tcase FC_FID_DIR_SERV:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (port_id != FC_FID_DOM_MGR)\n\t\t\t\tactive_nodes[i++] = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < plist_count; i++) {\n\t\thton24(gidpt[i].fp_fid, port_id);\n\n\t\tfor (j = 0; j < port_count; j++) {\n\t\t\tif (active_nodes[j] &&\n\t\t\t    port_id == active_nodes[j]->rnode.fc_id) {\n\t\t\t\tactive_nodes[j] = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (gidpt[i].fp_resvd & FC_NS_FID_LAST)\n\t\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < port_count; i++) {\n\t\t \n\t\tif (!active_nodes[i])\n\t\t\tcontinue;\n\n\t\tif ((node->nport->enable_ini && active_nodes[i]->targ) ||\n\t\t    (node->nport->enable_tgt && enable_target_rscn(efc))) {\n\t\t\tefc_node_post_event(active_nodes[i],\n\t\t\t\t\t    EFC_EVT_NODE_MISSING, NULL);\n\t\t} else {\n\t\t\tnode_printf(node,\n\t\t\t\t    \"GID_PT: skipping non-tgt port_id x%06x\\n\",\n\t\t\t\t    active_nodes[i]->rnode.fc_id);\n\t\t}\n\t}\n\tkfree(active_nodes);\n\n\tfor (i = 0; i < plist_count; i++) {\n\t\thton24(gidpt[i].fp_fid, port_id);\n\n\t\t \n\t\tif (port_id == node->rnode.nport->fc_id) {\n\t\t\tif (gidpt[i].fp_resvd & FC_NS_FID_LAST)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnewnode = efc_node_find(nport, port_id);\n\t\tif (!newnode) {\n\t\t\tif (!node->nport->enable_ini)\n\t\t\t\tcontinue;\n\n\t\t\tnewnode = efc_node_alloc(nport, port_id, false, false);\n\t\t\tif (!newnode) {\n\t\t\t\tefc_log_err(efc, \"efc_node_alloc() failed\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\t \n\t\t\tefc_node_init_device(newnode, true);\n\t\t}\n\n\t\tif (node->nport->enable_ini && newnode->targ) {\n\t\t\tefc_node_post_event(newnode, EFC_EVT_NODE_REFOUND,\n\t\t\t\t\t    NULL);\n\t\t}\n\n\t\tif (gidpt[i].fp_resvd & FC_NS_FID_LAST)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\nvoid\n__efc_ns_gidpt_wait_rsp(struct efc_sm_ctx *ctx,\n\t\t\tenum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\t \n\n\tswitch (evt) {\n\tcase EFC_EVT_SRRS_ELS_REQ_OK:\t{\n\t\tif (efc_node_check_ns_req(ctx, evt, arg, FC_NS_GID_PT,\n\t\t\t\t\t  __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\t \n\t\tefc_process_gidpt_payload(node, cbdata->els_rsp.virt,\n\t\t\t\t\t  cbdata->els_rsp.len);\n\t\tefc_node_transition(node, __efc_ns_idle, NULL);\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_SRRS_ELS_REQ_FAIL:\t{\n\t\t \n\t\tnode_printf(node, \"GID_PT failed to complete\\n\");\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\tefc_node_transition(node, __efc_ns_idle, NULL);\n\t\tbreak;\n\t}\n\n\t \n\tcase EFC_EVT_RSCN_RCVD: {\n\t\tnode_printf(node, \"RSCN received during GID_PT processing\\n\");\n\t\tnode->rscn_pending = true;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_ns_idle(struct efc_sm_ctx *ctx, enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\tstruct efc *efc = node->efc;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\t \n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tif (!node->rscn_pending)\n\t\t\tbreak;\n\n\t\tnode_printf(node, \"RSCN pending, restart discovery\\n\");\n\t\tnode->rscn_pending = false;\n\t\tfallthrough;\n\n\tcase EFC_EVT_RSCN_RCVD: {\n\t\t \n\t\t \n\t\tif (efc->tgt_rscn_delay_msec != 0 &&\n\t\t    !node->nport->enable_ini && node->nport->enable_tgt &&\n\t\t    enable_target_rscn(efc)) {\n\t\t\tefc_node_transition(node, __efc_ns_gidpt_delay, NULL);\n\t\t} else {\n\t\t\tefc_ns_send_gidpt(node);\n\t\t\tefc_node_transition(node, __efc_ns_gidpt_wait_rsp,\n\t\t\t\t\t    NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nstatic void\ngidpt_delay_timer_cb(struct timer_list *t)\n{\n\tstruct efc_node *node = from_timer(node, t, gidpt_delay_timer);\n\n\tdel_timer(&node->gidpt_delay_timer);\n\n\tefc_node_post_event(node, EFC_EVT_GIDPT_DELAY_EXPIRED, NULL);\n}\n\nvoid\n__efc_ns_gidpt_delay(struct efc_sm_ctx *ctx,\n\t\t     enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\tstruct efc *efc = node->efc;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER: {\n\t\tu64 delay_msec, tmp;\n\n\t\t \n\t\tdelay_msec = efc->tgt_rscn_delay_msec;\n\t\ttmp = jiffies_to_msecs(jiffies) - node->time_last_gidpt_msec;\n\t\tif (tmp < efc->tgt_rscn_period_msec)\n\t\t\tdelay_msec = efc->tgt_rscn_period_msec;\n\n\t\ttimer_setup(&node->gidpt_delay_timer, &gidpt_delay_timer_cb,\n\t\t\t    0);\n\t\tmod_timer(&node->gidpt_delay_timer,\n\t\t\t  jiffies + msecs_to_jiffies(delay_msec));\n\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_GIDPT_DELAY_EXPIRED:\n\t\tnode->time_last_gidpt_msec = jiffies_to_msecs(jiffies);\n\n\t\tefc_ns_send_gidpt(node);\n\t\tefc_node_transition(node, __efc_ns_gidpt_wait_rsp, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_RSCN_RCVD: {\n\t\tefc_log_debug(efc,\n\t\t\t      \"RSCN received while in GIDPT delay - no action\\n\");\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_fabctl_init(struct efc_sm_ctx *ctx,\n\t\t  enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\t \n\t\tefc_send_scr(node);\n\t\tefc_node_transition(node, __efc_fabctl_wait_scr_rsp, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_ATTACH_OK:\n\t\tnode->attached = true;\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_fabctl_wait_scr_rsp(struct efc_sm_ctx *ctx,\n\t\t\t  enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\t \n\tswitch (evt) {\n\tcase EFC_EVT_SRRS_ELS_REQ_OK:\n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_SCR,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\tefc_node_transition(node, __efc_fabctl_ready, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nstatic void\nefc_process_rscn(struct efc_node *node, struct efc_node_cb *cbdata)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_nport *nport = node->nport;\n\tstruct efc_node *ns;\n\n\t \n\tns = efc_node_find(nport, FC_FID_DIR_SERV);\n\tif (ns)\n\t\tefc_node_post_event(ns, EFC_EVT_RSCN_RCVD, cbdata);\n\telse\n\t\tefc_log_warn(efc, \"can't find name server node\\n\");\n}\n\nvoid\n__efc_fabctl_ready(struct efc_sm_ctx *ctx,\n\t\t   enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\t \n\tswitch (evt) {\n\tcase EFC_EVT_RSCN_RCVD: {\n\t\tstruct fc_frame_header *hdr = cbdata->header->dma.virt;\n\n\t\t \n\t\tefc_process_rscn(node, cbdata);\n\t\tefc_send_ls_acc(node, be16_to_cpu(hdr->fh_ox_id));\n\t\tefc_node_transition(node, __efc_fabctl_wait_ls_acc_cmpl,\n\t\t\t\t    NULL);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_fabctl_wait_ls_acc_cmpl(struct efc_sm_ctx *ctx,\n\t\t\t      enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_SRRS_ELS_CMPL_OK:\n\t\tWARN_ON(!node->els_cmpl_cnt);\n\t\tnode->els_cmpl_cnt--;\n\t\tefc_node_transition(node, __efc_fabctl_ready, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nstatic uint64_t\nefc_get_wwpn(struct fc_els_flogi *sp)\n{\n\treturn be64_to_cpu(sp->fl_wwnn);\n}\n\nstatic int\nefc_rnode_is_winner(struct efc_nport *nport)\n{\n\tstruct fc_els_flogi *remote_sp;\n\tu64 remote_wwpn;\n\tu64 local_wwpn = nport->wwpn;\n\tu64 wwn_bump = 0;\n\n\tremote_sp = (struct fc_els_flogi *)nport->domain->flogi_service_params;\n\tremote_wwpn = efc_get_wwpn(remote_sp);\n\n\tlocal_wwpn ^= wwn_bump;\n\n\tefc_log_debug(nport->efc, \"r: %llx\\n\",\n\t\t      be64_to_cpu(remote_sp->fl_wwpn));\n\tefc_log_debug(nport->efc, \"l: %llx\\n\", local_wwpn);\n\n\tif (remote_wwpn == local_wwpn) {\n\t\tefc_log_warn(nport->efc,\n\t\t\t     \"WWPN of remote node [%08x %08x] matches local WWPN\\n\",\n\t\t\t     (u32)(local_wwpn >> 32ll),\n\t\t\t     (u32)local_wwpn);\n\t\treturn -1;\n\t}\n\n\treturn (remote_wwpn > local_wwpn);\n}\n\nvoid\n__efc_p2p_wait_domain_attach(struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\tstruct efc *efc = node->efc;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_ATTACH_OK: {\n\t\tstruct efc_nport *nport = node->nport;\n\t\tstruct efc_node *rnode;\n\n\t\t \n\t\tWARN_ON(!node->nport->p2p_winner);\n\n\t\trnode = efc_node_find(nport, node->nport->p2p_remote_port_id);\n\t\tif (rnode) {\n\t\t\t \n\t\t\tnode_printf(node,\n\t\t\t\t    \"Node with fc_id x%x already exists\\n\",\n\t\t\t\t    rnode->rnode.fc_id);\n\t\t} else {\n\t\t\t \n\t\t\trnode = efc_node_alloc(nport,\n\t\t\t\t\t       nport->p2p_remote_port_id,\n\t\t\t\t\t\tfalse, false);\n\t\t\tif (!rnode) {\n\t\t\t\tefc_log_err(efc, \"node alloc failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tefc_fabric_notify_topology(node);\n\t\t\t \n\t\t\tefc_node_transition(rnode, __efc_p2p_rnode_init,\n\t\t\t\t\t    NULL);\n\t\t}\n\n\t\t \n\t\tif (node->rnode.fc_id == 0) {\n\t\t\t \n\t\t\t \n\t\t\tefc_node_init_device(node, false);\n\t\t} else {\n\t\t\t \n\t\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\t\tefc_fabric_initiate_shutdown(node);\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_p2p_rnode_init(struct efc_sm_ctx *ctx,\n\t\t     enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\t \n\t\tefc_send_plogi(node);\n\t\tefc_node_transition(node, __efc_p2p_wait_plogi_rsp, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_ABTS_RCVD:\n\t\t \n\t\tefc_send_bls_acc(node, cbdata->header->dma.virt);\n\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_p2p_wait_flogi_acc_cmpl(struct efc_sm_ctx *ctx,\n\t\t\t      enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_SRRS_ELS_CMPL_OK:\n\t\tWARN_ON(!node->els_cmpl_cnt);\n\t\tnode->els_cmpl_cnt--;\n\n\t\t \n\t\tif (node->nport->p2p_winner) {\n\t\t\tefc_node_transition(node,\n\t\t\t\t\t    __efc_p2p_wait_domain_attach,\n\t\t\t\t\tNULL);\n\t\t\tif (!node->nport->domain->attached) {\n\t\t\t\tnode_printf(node, \"Domain not attached\\n\");\n\t\t\t\tefc_domain_attach(node->nport->domain,\n\t\t\t\t\t\t  node->nport->p2p_port_id);\n\t\t\t} else {\n\t\t\t\tnode_printf(node, \"Domain already attached\\n\");\n\t\t\t\tefc_node_post_event(node,\n\t\t\t\t\t\t    EFC_EVT_DOMAIN_ATTACH_OK,\n\t\t\t\t\t\t    NULL);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tefc_node_init_device(node, false);\n\t\t}\n\t\tbreak;\n\n\tcase EFC_EVT_SRRS_ELS_CMPL_FAIL:\n\t\t \n\t\tnode_printf(node, \"FLOGI LS_ACC failed, shutting down\\n\");\n\t\tWARN_ON(!node->els_cmpl_cnt);\n\t\tnode->els_cmpl_cnt--;\n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tefc_fabric_initiate_shutdown(node);\n\t\tbreak;\n\n\tcase EFC_EVT_ABTS_RCVD: {\n\t\t \n\t\tefc_send_bls_acc(node, cbdata->header->dma.virt);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_p2p_wait_plogi_rsp(struct efc_sm_ctx *ctx,\n\t\t\t enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_SRRS_ELS_REQ_OK: {\n\t\tint rc;\n\n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_PLOGI,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\t \n\t\tefc_node_save_sparms(node, cbdata->els_rsp.virt);\n\t\trc = efc_node_attach(node);\n\t\tefc_node_transition(node, __efc_p2p_wait_node_attach, NULL);\n\t\tif (rc < 0)\n\t\t\tefc_node_post_event(node, EFC_EVT_NODE_ATTACH_FAIL,\n\t\t\t\t\t    NULL);\n\t\tbreak;\n\t}\n\tcase EFC_EVT_SRRS_ELS_REQ_FAIL: {\n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_PLOGI,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tnode_printf(node, \"PLOGI failed, shutting down\\n\");\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tefc_fabric_initiate_shutdown(node);\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_PLOGI_RCVD: {\n\t\tstruct fc_frame_header *hdr = cbdata->header->dma.virt;\n\t\t \n\t\tif (node->efc->external_loopback) {\n\t\t\tefc_send_plogi_acc(node, be16_to_cpu(hdr->fh_ox_id));\n\t\t} else {\n\t\t\t \n\t\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t\t}\n\t\tbreak;\n\t}\n\tcase EFC_EVT_PRLI_RCVD:\n\t\t \n\t\t \n\t\tefc_process_prli_payload(node, cbdata->payload->dma.virt);\n\t\tefc_send_ls_acc_after_attach(node,\n\t\t\t\t\t     cbdata->header->dma.virt,\n\t\t\t\t\t     EFC_NODE_SEND_LS_ACC_PRLI);\n\t\tefc_node_transition(node, __efc_p2p_wait_plogi_rsp_recvd_prli,\n\t\t\t\t    NULL);\n\t\tbreak;\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_p2p_wait_plogi_rsp_recvd_prli(struct efc_sm_ctx *ctx,\n\t\t\t\t    enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\t \n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_SRRS_ELS_REQ_OK: {\t \n\t\tint rc;\n\n\t\t \n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_PLOGI,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\t \n\t\tefc_node_save_sparms(node, cbdata->els_rsp.virt);\n\t\trc = efc_node_attach(node);\n\t\tefc_node_transition(node, __efc_p2p_wait_node_attach, NULL);\n\t\tif (rc < 0)\n\t\t\tefc_node_post_event(node, EFC_EVT_NODE_ATTACH_FAIL,\n\t\t\t\t\t    NULL);\n\t\tbreak;\n\t}\n\tcase EFC_EVT_SRRS_ELS_REQ_FAIL:\t \n\tcase EFC_EVT_SRRS_ELS_REQ_RJT:\n\t\t \n\t\tif (efc_node_check_els_req(ctx, evt, arg, ELS_PLOGI,\n\t\t\t\t\t   __efc_fabric_common, __func__)) {\n\t\t\treturn;\n\t\t}\n\t\tWARN_ON(!node->els_req_cnt);\n\t\tnode->els_req_cnt--;\n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tefc_fabric_initiate_shutdown(node);\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_p2p_wait_node_attach(struct efc_sm_ctx *ctx,\n\t\t\t   enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node_cb *cbdata = arg;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_ATTACH_OK:\n\t\tnode->attached = true;\n\t\tswitch (node->send_ls_acc) {\n\t\tcase EFC_NODE_SEND_LS_ACC_PRLI: {\n\t\t\tefc_d_send_prli_rsp(node->ls_acc_io,\n\t\t\t\t\t    node->ls_acc_oxid);\n\t\t\tnode->send_ls_acc = EFC_NODE_SEND_LS_ACC_NONE;\n\t\t\tnode->ls_acc_io = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tcase EFC_NODE_SEND_LS_ACC_PLOGI:  \n\t\tcase EFC_NODE_SEND_LS_ACC_NONE:\n\t\tdefault:\n\t\t\t \n\t\t\t \n\t\t\tefc_node_transition(node, __efc_d_port_logged_in,\n\t\t\t\t\t    NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_ATTACH_FAIL:\n\t\t \n\t\tnode->attached = false;\n\t\tnode_printf(node, \"Node attach failed\\n\");\n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tefc_fabric_initiate_shutdown(node);\n\t\tbreak;\n\n\tcase EFC_EVT_SHUTDOWN:\n\t\tnode_printf(node, \"%s received\\n\", efc_sm_event_name(evt));\n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tefc_node_transition(node,\n\t\t\t\t    __efc_fabric_wait_attach_evt_shutdown,\n\t\t\t\t     NULL);\n\t\tbreak;\n\tcase EFC_EVT_PRLI_RCVD:\n\t\tnode_printf(node, \"%s: PRLI received before node is attached\\n\",\n\t\t\t    efc_sm_event_name(evt));\n\t\tefc_process_prli_payload(node, cbdata->payload->dma.virt);\n\t\tefc_send_ls_acc_after_attach(node,\n\t\t\t\t\t     cbdata->header->dma.virt,\n\t\t\t\tEFC_NODE_SEND_LS_ACC_PRLI);\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_fabric_common(__func__, ctx, evt, arg);\n\t}\n}\n\nint\nefc_p2p_setup(struct efc_nport *nport)\n{\n\tstruct efc *efc = nport->efc;\n\tint rnode_winner;\n\n\trnode_winner = efc_rnode_is_winner(nport);\n\n\t \n\tif (rnode_winner == 1) {\n\t\tnport->p2p_remote_port_id = 0;\n\t\tnport->p2p_port_id = 0;\n\t\tnport->p2p_winner = false;\n\t} else if (rnode_winner == 0) {\n\t\tnport->p2p_remote_port_id = 2;\n\t\tnport->p2p_port_id = 1;\n\t\tnport->p2p_winner = true;\n\t} else {\n\t\t \n\t\tif (nport->efc->external_loopback) {\n\t\t\t \n\t\t\tefc_log_debug(efc,\n\t\t\t\t      \"External loopback mode enabled\\n\");\n\t\t\tnport->p2p_remote_port_id = 1;\n\t\t\tnport->p2p_port_id = 1;\n\t\t\tnport->p2p_winner = true;\n\t\t} else {\n\t\t\tefc_log_warn(efc,\n\t\t\t\t     \"failed to determine p2p winner\\n\");\n\t\t\treturn rnode_winner;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}