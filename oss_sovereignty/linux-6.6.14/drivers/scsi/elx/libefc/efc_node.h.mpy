{
  "module_name": "efc_node.h",
  "hash_id": "993b4bb202a08684a5c3c37907d7ba8348fae287ff92a6c02578147bc3d0a79f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/libefc/efc_node.h",
  "human_readable_source": " \n \n\n#if !defined(__EFC_NODE_H__)\n#define __EFC_NODE_H__\n#include \"scsi/fc/fc_ns.h\"\n\n#define EFC_NODEDB_PAUSE_FABRIC_LOGIN\t(1 << 0)\n#define EFC_NODEDB_PAUSE_NAMESERVER\t(1 << 1)\n#define EFC_NODEDB_PAUSE_NEW_NODES\t(1 << 2)\n\n#define MAX_ACC_REJECT_PAYLOAD\tsizeof(struct fc_els_ls_rjt)\n\n#define scsi_io_printf(io, fmt, ...) \\\n\tefc_log_debug(io->efc, \"[%s] [%04x][i:%04x t:%04x h:%04x]\" fmt, \\\n\tio->node->display_name, io->instance_index, io->init_task_tag, \\\n\tio->tgt_task_tag, io->hw_tag, ##__VA_ARGS__)\n\nstatic inline void\nefc_node_evt_set(struct efc_sm_ctx *ctx, enum efc_sm_event evt,\n\t\t const char *handler)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tif (evt == EFC_EVT_ENTER) {\n\t\tstrncpy(node->current_state_name, handler,\n\t\t\tsizeof(node->current_state_name));\n\t} else if (evt == EFC_EVT_EXIT) {\n\t\tstrncpy(node->prev_state_name, node->current_state_name,\n\t\t\tsizeof(node->prev_state_name));\n\t\tstrncpy(node->current_state_name, \"invalid\",\n\t\t\tsizeof(node->current_state_name));\n\t}\n\tnode->prev_evt = node->current_evt;\n\tnode->current_evt = evt;\n}\n\n \n\nstatic inline void\nefc_node_hold_frames(struct efc_node *node)\n{\n\tnode->hold_frames = true;\n}\n\n \n\nstatic inline void\nefc_node_accept_frames(struct efc_node *node)\n{\n\tnode->hold_frames = false;\n}\n\n \nenum efc_node_enable {\n\tEFC_NODE_ENABLE_x_TO_x,\n\tEFC_NODE_ENABLE_x_TO_T,\n\tEFC_NODE_ENABLE_x_TO_I,\n\tEFC_NODE_ENABLE_x_TO_IT,\n\tEFC_NODE_ENABLE_T_TO_x,\n\tEFC_NODE_ENABLE_T_TO_T,\n\tEFC_NODE_ENABLE_T_TO_I,\n\tEFC_NODE_ENABLE_T_TO_IT,\n\tEFC_NODE_ENABLE_I_TO_x,\n\tEFC_NODE_ENABLE_I_TO_T,\n\tEFC_NODE_ENABLE_I_TO_I,\n\tEFC_NODE_ENABLE_I_TO_IT,\n\tEFC_NODE_ENABLE_IT_TO_x,\n\tEFC_NODE_ENABLE_IT_TO_T,\n\tEFC_NODE_ENABLE_IT_TO_I,\n\tEFC_NODE_ENABLE_IT_TO_IT,\n};\n\nstatic inline enum efc_node_enable\nefc_node_get_enable(struct efc_node *node)\n{\n\tu32 retval = 0;\n\n\tif (node->nport->enable_ini)\n\t\tretval |= (1U << 3);\n\tif (node->nport->enable_tgt)\n\t\tretval |= (1U << 2);\n\tif (node->init)\n\t\tretval |= (1U << 1);\n\tif (node->targ)\n\t\tretval |= (1U << 0);\n\treturn (enum efc_node_enable)retval;\n}\n\nint\nefc_node_check_els_req(struct efc_sm_ctx *ctx,\n\t\t       enum efc_sm_event evt, void *arg,\n\t\t       u8 cmd, void (*efc_node_common_func)(const char *,\n\t\t       struct efc_sm_ctx *, enum efc_sm_event, void *),\n\t\t       const char *funcname);\nint\nefc_node_check_ns_req(struct efc_sm_ctx *ctx,\n\t\t      enum efc_sm_event evt, void *arg,\n\t\t      u16 cmd, void (*efc_node_common_func)(const char *,\n\t\t      struct efc_sm_ctx *, enum efc_sm_event, void *),\n\t\t      const char *funcname);\nint\nefc_node_attach(struct efc_node *node);\nstruct efc_node *\nefc_node_alloc(struct efc_nport *nport, u32 port_id,\n\t       bool init, bool targ);\nvoid\nefc_node_free(struct efc_node *efc);\nvoid\nefc_node_update_display_name(struct efc_node *node);\nvoid efc_node_post_event(struct efc_node *node, enum efc_sm_event evt,\n\t\t\t void *arg);\n\nvoid\n__efc_node_shutdown(struct efc_sm_ctx *ctx,\n\t\t    enum efc_sm_event evt, void *arg);\nvoid\n__efc_node_wait_node_free(struct efc_sm_ctx *ctx,\n\t\t\t  enum efc_sm_event evt, void *arg);\nvoid\n__efc_node_wait_els_shutdown(struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg);\nvoid\n__efc_node_wait_ios_shutdown(struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg);\nvoid\nefc_node_save_sparms(struct efc_node *node, void *payload);\nvoid\nefc_node_transition(struct efc_node *node,\n\t\t    void (*state)(struct efc_sm_ctx *, enum efc_sm_event,\n\t\t\t\t  void *), void *data);\nvoid\n__efc_node_common(const char *funcname, struct efc_sm_ctx *ctx,\n\t\t  enum efc_sm_event evt, void *arg);\n\nvoid\nefc_node_initiate_cleanup(struct efc_node *node);\n\nvoid\nefc_node_build_eui_name(char *buf, u32 buf_len, uint64_t eui_name);\n\nvoid\nefc_node_pause(struct efc_node *node,\n\t       void (*state)(struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg));\nvoid\n__efc_node_paused(struct efc_sm_ctx *ctx,\n\t\t  enum efc_sm_event evt, void *arg);\nint\nefc_node_active_ios_empty(struct efc_node *node);\nvoid\nefc_node_send_ls_io_cleanup(struct efc_node *node);\n\nint\nefc_els_io_list_empty(struct efc_node *node, struct list_head *list);\n\nvoid\nefc_process_node_pending(struct efc_node *domain);\n\nu64 efc_node_get_wwnn(struct efc_node *node);\nstruct efc_node *\nefc_node_find(struct efc_nport *nport, u32 id);\nvoid\nefc_node_post_els_resp(struct efc_node *node, u32 evt, void *arg);\nvoid\nefc_node_recv_els_frame(struct efc_node *node, struct efc_hw_sequence *s);\nvoid\nefc_node_recv_ct_frame(struct efc_node *node, struct efc_hw_sequence *seq);\nvoid\nefc_node_recv_fcp_cmd(struct efc_node *node, struct efc_hw_sequence *seq);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}