{
  "module_name": "efclib.h",
  "hash_id": "71354fc025ef5d8189005d29d6cea64f594453ca9f85b48b67ff903339c39abe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/libefc/efclib.h",
  "human_readable_source": " \n \n\n#ifndef __EFCLIB_H__\n#define __EFCLIB_H__\n\n#include \"scsi/fc/fc_els.h\"\n#include \"scsi/fc/fc_fs.h\"\n#include \"scsi/fc/fc_ns.h\"\n#include \"scsi/fc/fc_gs.h\"\n#include \"scsi/fc_frame.h\"\n#include \"../include/efc_common.h\"\n#include \"../libefc_sli/sli4.h\"\n\n#define EFC_SERVICE_PARMS_LENGTH\t120\n#define EFC_NAME_LENGTH\t\t\t32\n#define EFC_SM_NAME_LENGTH\t\t64\n#define EFC_DISPLAY_BUS_INFO_LENGTH\t16\n\n#define EFC_WWN_LENGTH\t\t\t32\n\n#define EFC_FC_ELS_DEFAULT_RETRIES\t3\n\n \n#define EFC_FC_ELS_SEND_DEFAULT_TIMEOUT\t0\n#define EFC_FC_FLOGI_TIMEOUT_SEC\t5\n#define EFC_SHUTDOWN_TIMEOUT_USEC\t30000000\n\n \n#define EFC_SCSI_CALL_COMPLETE\t\t0\n#define EFC_SCSI_CALL_ASYNC\t\t1\n\n \nenum efc_nport_topology {\n\tEFC_NPORT_TOPO_UNKNOWN = 0,\n\tEFC_NPORT_TOPO_FABRIC,\n\tEFC_NPORT_TOPO_P2P,\n\tEFC_NPORT_TOPO_FC_AL,\n};\n\n#define enable_target_rscn(efc)\t\t1\n\nenum efc_node_shutd_rsn {\n\tEFC_NODE_SHUTDOWN_DEFAULT = 0,\n\tEFC_NODE_SHUTDOWN_EXPLICIT_LOGO,\n\tEFC_NODE_SHUTDOWN_IMPLICIT_LOGO,\n};\n\nenum efc_node_send_ls_acc {\n\tEFC_NODE_SEND_LS_ACC_NONE = 0,\n\tEFC_NODE_SEND_LS_ACC_PLOGI,\n\tEFC_NODE_SEND_LS_ACC_PRLI,\n};\n\n#define EFC_LINK_STATUS_UP\t\t0\n#define EFC_LINK_STATUS_DOWN\t\t1\n\nenum efc_sm_event;\n\n \nstruct efc_sm_ctx {\n\tvoid (*current_state)(struct efc_sm_ctx *ctx,\n\t\t\t      enum efc_sm_event evt, void *arg);\n\n\tconst char\t*description;\n\tvoid\t\t*app;\n};\n\n \nstruct efc_domain_record {\n\tu32\t\tindex;\n\tu32\t\tpriority;\n\tu8\t\taddress[6];\n\tu8\t\twwn[8];\n\tunion {\n\t\tu8\tvlan[512];\n\t\tu8\tloop[128];\n\t} map;\n\tu32\t\tspeed;\n\tu32\t\tfc_id;\n\tbool\t\tis_loop;\n\tbool\t\tis_nport;\n};\n\n \nenum efc_hw_domain_event {\n\tEFC_HW_DOMAIN_ALLOC_OK,\n\tEFC_HW_DOMAIN_ALLOC_FAIL,\n\tEFC_HW_DOMAIN_ATTACH_OK,\n\tEFC_HW_DOMAIN_ATTACH_FAIL,\n\tEFC_HW_DOMAIN_FREE_OK,\n\tEFC_HW_DOMAIN_FREE_FAIL,\n\tEFC_HW_DOMAIN_LOST,\n\tEFC_HW_DOMAIN_FOUND,\n\tEFC_HW_DOMAIN_CHANGED,\n};\n\n \n\nstruct efc_nport {\n\tstruct list_head\tlist_entry;\n\tstruct kref\t\tref;\n\tvoid\t\t\t(*release)(struct kref *arg);\n\tstruct efc\t\t*efc;\n\tu32\t\t\tinstance_index;\n\tchar\t\t\tdisplay_name[EFC_NAME_LENGTH];\n\tbool\t\t\tis_vport;\n\tbool\t\t\tfree_req_pending;\n\tbool\t\t\tattached;\n\tbool\t\t\tattaching;\n\tbool\t\t\tp2p_winner;\n\tstruct efc_domain\t*domain;\n\tu64\t\t\twwpn;\n\tu64\t\t\twwnn;\n\tvoid\t\t\t*tgt_data;\n\tvoid\t\t\t*ini_data;\n\n\tu32\t\t\tindicator;\n\tu32\t\t\tfc_id;\n\tstruct efc_dma\t\tdma;\n\n\tu8\t\t\twwnn_str[EFC_WWN_LENGTH];\n\t__be64\t\t\tsli_wwpn;\n\t__be64\t\t\tsli_wwnn;\n\n\tstruct efc_sm_ctx\tsm;\n\tstruct xarray\t\tlookup;\n\tbool\t\t\tenable_ini;\n\tbool\t\t\tenable_tgt;\n\tbool\t\t\tenable_rscn;\n\tbool\t\t\tshutting_down;\n\tu32\t\t\tp2p_port_id;\n\tenum efc_nport_topology topology;\n\tu8\t\t\tservice_params[EFC_SERVICE_PARMS_LENGTH];\n\tu32\t\t\tp2p_remote_port_id;\n};\n\n \nstruct efc_domain {\n\tstruct efc\t\t*efc;\n\tchar\t\t\tdisplay_name[EFC_NAME_LENGTH];\n\tstruct list_head\tnport_list;\n\tstruct kref\t\tref;\n\tvoid\t\t\t(*release)(struct kref *arg);\n\tvoid\t\t\t*ini_domain;\n\tvoid\t\t\t*tgt_domain;\n\n\t \n\tu32\t\t\tfcf;\n\tu32\t\t\tfcf_indicator;\n\tu32\t\t\tindicator;\n\tu32\t\t\tnport_count;\n\tstruct efc_dma\t\tdma;\n\n\t \n\tu64\t\t\tfcf_wwn;\n\tstruct efc_sm_ctx\tdrvsm;\n\tbool\t\t\tattached;\n\tbool\t\t\tis_fc;\n\tbool\t\t\tis_loop;\n\tbool\t\t\tis_nlport;\n\tbool\t\t\tdomain_found_pending;\n\tbool\t\t\treq_domain_free;\n\tbool\t\t\treq_accept_frames;\n\tbool\t\t\tdomain_notify_pend;\n\n\tstruct efc_domain_record pending_drec;\n\tu8\t\t\tservice_params[EFC_SERVICE_PARMS_LENGTH];\n\tu8\t\t\tflogi_service_params[EFC_SERVICE_PARMS_LENGTH];\n\n\tstruct xarray\t\tlookup;\n\n\tstruct efc_nport\t*nport;\n};\n\n \nstruct efc_remote_node {\n\tu32\t\t\tindicator;\n\tu32\t\t\tindex;\n\tu32\t\t\tfc_id;\n\n\tbool\t\t\tattached;\n\n\tstruct efc_nport\t*nport;\n\tvoid\t\t\t*node;\n};\n\n \nstruct efc_node {\n\tstruct efc\t\t*efc;\n\tchar\t\t\tdisplay_name[EFC_NAME_LENGTH];\n\tstruct efc_nport\t*nport;\n\tstruct kref\t\tref;\n\tvoid\t\t\t(*release)(struct kref *arg);\n\tbool\t\t\thold_frames;\n\tbool\t\t\tels_io_enabled;\n\tbool\t\t\tsend_plogi_acc;\n\tbool\t\t\tsend_plogi;\n\tbool\t\t\trscn_pending;\n\tbool\t\t\tfcp_enabled;\n\tbool\t\t\tattached;\n\tbool\t\t\treq_free;\n\n\tspinlock_t\t\tels_ios_lock;\n\tstruct list_head\tels_ios_list;\n\tvoid\t\t\t*ini_node;\n\tvoid\t\t\t*tgt_node;\n\n\tstruct efc_remote_node\trnode;\n\t \n\tstruct efc_sm_ctx\tsm;\n\tu32\t\t\tevtdepth;\n\n\tenum efc_node_send_ls_acc send_ls_acc;\n\tvoid\t\t\t*ls_acc_io;\n\tu32\t\t\tls_acc_oxid;\n\tu32\t\t\tls_acc_did;\n\tenum efc_node_shutd_rsn\tshutdown_reason;\n\tbool\t\t\ttarg;\n\tbool\t\t\tinit;\n\tbool\t\t\trefound;\n\tstruct efc_dma\t\tsparm_dma_buf;\n\tu8\t\t\tservice_params[EFC_SERVICE_PARMS_LENGTH];\n\tspinlock_t\t\tpend_frames_lock;\n\tstruct list_head\tpend_frames;\n\tu32\t\t\tpend_frames_processed;\n\tu32\t\t\tox_id_in_use;\n\tu32\t\t\tels_retries_remaining;\n\tu32\t\t\tels_req_cnt;\n\tu32\t\t\tels_cmpl_cnt;\n\tu32\t\t\tabort_cnt;\n\n\tchar\t\t\tcurrent_state_name[EFC_SM_NAME_LENGTH];\n\tchar\t\t\tprev_state_name[EFC_SM_NAME_LENGTH];\n\tint\t\t\tcurrent_evt;\n\tint\t\t\tprev_evt;\n\n\tvoid (*nodedb_state)(struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg);\n\tstruct timer_list\tgidpt_delay_timer;\n\tu64\t\t\ttime_last_gidpt_msec;\n\n\tchar\t\t\twwnn[EFC_WWN_LENGTH];\n\tchar\t\t\twwpn[EFC_WWN_LENGTH];\n};\n\n \n\nstruct efc_vport {\n\tstruct list_head\tlist_entry;\n\tu64\t\t\twwnn;\n\tu64\t\t\twwpn;\n\tu32\t\t\tfc_id;\n\tbool\t\t\tenable_tgt;\n\tbool\t\t\tenable_ini;\n\tvoid\t\t\t*tgt_data;\n\tvoid\t\t\t*ini_data;\n\tstruct efc_nport\t*nport;\n};\n\n#define node_printf(node, fmt, args...) \\\n\tefc_log_info(node->efc, \"[%s] \" fmt, node->display_name, ##args)\n\n \nstruct efc_node_cb {\n\tint\t\t\tstatus;\n\tint\t\t\text_status;\n\tstruct efc_hw_rq_buffer *header;\n\tstruct efc_hw_rq_buffer *payload;\n\tstruct efc_dma\t\tels_rsp;\n\n\t \n\tint\t\t\trsp_len;\n};\n\nstruct efc_hw_rq_buffer {\n\tu16\t\t\trqindex;\n\tstruct efc_dma\t\tdma;\n};\n\n \nstruct efc_hw_sequence {\n\tstruct list_head\tlist_entry;\n\tvoid\t\t\t*hw;\n\tu8\t\t\tfcfi;\n\tstruct efc_hw_rq_buffer *header;\n\tstruct efc_hw_rq_buffer *payload;\n\tvoid\t\t\t*hw_priv;\n};\n\nenum efc_disc_io_type {\n\tEFC_DISC_IO_ELS_REQ,\n\tEFC_DISC_IO_ELS_RESP,\n\tEFC_DISC_IO_CT_REQ,\n\tEFC_DISC_IO_CT_RESP\n};\n\nstruct efc_io_els_params {\n\tu32             s_id;\n\tu16             ox_id;\n\tu8              timeout;\n};\n\nstruct efc_io_ct_params {\n\tu8              r_ctl;\n\tu8              type;\n\tu8              df_ctl;\n\tu8              timeout;\n\tu16             ox_id;\n};\n\nunion efc_disc_io_param {\n\tstruct efc_io_els_params els;\n\tstruct efc_io_ct_params ct;\n};\n\nstruct efc_disc_io {\n\tstruct efc_dma\t\treq;          \n\tstruct efc_dma\t\trsp;          \n\tenum efc_disc_io_type\tio_type;      \n\tu16\t\t\txmit_len;     \n\tu16\t\t\trsp_len;      \n\tu32\t\t\trpi;          \n\tu32\t\t\tvpi;          \n\tu32\t\t\ts_id;\n\tu32\t\t\td_id;\n\tbool\t\t\trpi_registered;  \n\tunion efc_disc_io_param iparam;\n};\n\n \n#define EFC_HW_SEQ_HOLD\t\t0\n \n#define EFC_HW_SEQ_FREE\t\t1\n\nstruct libefc_function_template {\n\t \n\tint (*new_nport)(struct efc *efc, struct efc_nport *sp);\n\tvoid (*del_nport)(struct efc *efc, struct efc_nport *sp);\n\n\t \n\tint (*scsi_new_node)(struct efc *efc, struct efc_node *n);\n\tint (*scsi_del_node)(struct efc *efc, struct efc_node *n, int reason);\n\n\tint (*issue_mbox_rqst)(void *efct, void *buf, void *cb, void *arg);\n\t \n\tint (*send_els)(struct efc *efc, struct efc_disc_io *io);\n\t \n\tint (*send_bls)(struct efc *efc, u32 type, struct sli_bls_params *bls);\n\t \n\tint (*hw_seq_free)(struct efc *efc, struct efc_hw_sequence *seq);\n};\n\n#define EFC_LOG_LIB\t\t0x01\n#define EFC_LOG_NODE\t\t0x02\n#define EFC_LOG_PORT\t\t0x04\n#define EFC_LOG_DOMAIN\t\t0x08\n#define EFC_LOG_ELS\t\t0x10\n#define EFC_LOG_DOMAIN_SM\t0x20\n#define EFC_LOG_SM\t\t0x40\n\n \nstruct efc {\n\tvoid\t\t\t*base;\n\tstruct pci_dev\t\t*pci;\n\tstruct sli4\t\t*sli;\n\tu32\t\t\tfcfi;\n\tu64\t\t\treq_wwpn;\n\tu64\t\t\treq_wwnn;\n\n\tu64\t\t\tdef_wwpn;\n\tu64\t\t\tdef_wwnn;\n\tu64\t\t\tmax_xfer_size;\n\tmempool_t\t\t*node_pool;\n\tstruct dma_pool\t\t*node_dma_pool;\n\tu32\t\t\tnodes_count;\n\n\tu32\t\t\tlink_status;\n\n\tstruct list_head\tvport_list;\n\t \n\tspinlock_t\t\tvport_lock;\n\n\tstruct libefc_function_template tt;\n\t \n\tspinlock_t\t\tlock;\n\n\tbool\t\t\tenable_ini;\n\tbool\t\t\tenable_tgt;\n\n\tu32\t\t\tlog_level;\n\n\tstruct efc_domain\t*domain;\n\tvoid (*domain_free_cb)(struct efc *efc, void *arg);\n\tvoid\t\t\t*domain_free_cb_arg;\n\n\tu64\t\t\ttgt_rscn_delay_msec;\n\tu64\t\t\ttgt_rscn_period_msec;\n\n\tbool\t\t\texternal_loopback;\n\tu32\t\t\tnodedb_mask;\n\tu32\t\t\tlogmask;\n\tmempool_t\t\t*els_io_pool;\n\tatomic_t\t\tels_io_alloc_failed_count;\n\n\t \n\tbool\t\t\thold_frames;\n\t \n\tspinlock_t\t\tpend_frames_lock;\n\tstruct list_head\tpend_frames;\n\t \n\tu32\t\t\tpend_frames_processed;\n\n};\n\n \nint efcport_init(struct efc *efc);\nvoid efcport_destroy(struct efc *efc);\n \nint efc_domain_cb(void *arg, int event, void *data);\nvoid\nefc_register_domain_free_cb(struct efc *efc,\n\t\t\t    void (*callback)(struct efc *efc, void *arg),\n\t\t\t    void *arg);\n\n \nvoid efc_nport_cb(void *arg, int event, void *data);\nstruct efc_vport *\nefc_vport_create_spec(struct efc *efc, u64 wwnn, u64 wwpn, u32 fc_id,\n\t\t      bool enable_ini, bool enable_tgt,\n\t\t      void *tgt_data, void *ini_data);\nint efc_nport_vport_new(struct efc_domain *domain, u64 wwpn,\n\t\t\tu64 wwnn, u32 fc_id, bool ini, bool tgt,\n\t\t\tvoid *tgt_data, void *ini_data);\nint efc_nport_vport_del(struct efc *efc, struct efc_domain *domain,\n\t\t\tu64 wwpn, u64 wwnn);\n\nvoid efc_vport_del_all(struct efc *efc);\n\n \nint efc_remote_node_cb(void *arg, int event, void *data);\nvoid efc_node_fcid_display(u32 fc_id, char *buffer, u32 buf_len);\nvoid efc_node_post_shutdown(struct efc_node *node, void *arg);\nu64 efc_node_get_wwpn(struct efc_node *node);\n\n \nvoid efc_dispatch_frame(struct efc *efc, struct efc_hw_sequence *seq);\nvoid efc_disc_io_complete(struct efc_disc_io *io, u32 len, u32 status,\n\t\t\t  u32 ext_status);\n\n \nvoid efc_scsi_sess_reg_complete(struct efc_node *node, u32 status);\nvoid efc_scsi_del_initiator_complete(struct efc *efc, struct efc_node *node);\nvoid efc_scsi_del_target_complete(struct efc *efc, struct efc_node *node);\nvoid efc_scsi_io_list_empty(struct efc *efc, struct efc_node *node);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}