{
  "module_name": "efc_node.c",
  "hash_id": "310f420ddbcc5a16d487f25ebfadf95cefe7b7410cee890075f8ea72bf02d3c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/libefc/efc_node.c",
  "human_readable_source": "\n \n\n#include \"efc.h\"\n\nint\nefc_remote_node_cb(void *arg, int event, void *data)\n{\n\tstruct efc *efc = arg;\n\tstruct efc_remote_node *rnode = data;\n\tstruct efc_node *node = rnode->node;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\tefc_node_post_event(node, event, NULL);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n\n\treturn 0;\n}\n\nstruct efc_node *\nefc_node_find(struct efc_nport *nport, u32 port_id)\n{\n\t \n\treturn xa_load(&nport->lookup, port_id);\n}\n\nstatic void\n_efc_node_free(struct kref *arg)\n{\n\tstruct efc_node *node = container_of(arg, struct efc_node, ref);\n\tstruct efc *efc = node->efc;\n\tstruct efc_dma *dma;\n\n\tdma = &node->sparm_dma_buf;\n\tdma_pool_free(efc->node_dma_pool, dma->virt, dma->phys);\n\tmemset(dma, 0, sizeof(struct efc_dma));\n\tmempool_free(node, efc->node_pool);\n}\n\nstruct efc_node *efc_node_alloc(struct efc_nport *nport,\n\t\t\t\tu32 port_id, bool init, bool targ)\n{\n\tint rc;\n\tstruct efc_node *node = NULL;\n\tstruct efc *efc = nport->efc;\n\tstruct efc_dma *dma;\n\n\tif (nport->shutting_down) {\n\t\tefc_log_debug(efc, \"node allocation when shutting down %06x\",\n\t\t\t      port_id);\n\t\treturn NULL;\n\t}\n\n\tnode = mempool_alloc(efc->node_pool, GFP_ATOMIC);\n\tif (!node) {\n\t\tefc_log_err(efc, \"node allocation failed %06x\", port_id);\n\t\treturn NULL;\n\t}\n\tmemset(node, 0, sizeof(*node));\n\n\tdma = &node->sparm_dma_buf;\n\tdma->size = NODE_SPARAMS_SIZE;\n\tdma->virt = dma_pool_zalloc(efc->node_dma_pool, GFP_ATOMIC, &dma->phys);\n\tif (!dma->virt) {\n\t\tefc_log_err(efc, \"node dma alloc failed\\n\");\n\t\tgoto dma_fail;\n\t}\n\tnode->rnode.indicator = U32_MAX;\n\tnode->nport = nport;\n\n\tnode->efc = efc;\n\tnode->init = init;\n\tnode->targ = targ;\n\n\tspin_lock_init(&node->pend_frames_lock);\n\tINIT_LIST_HEAD(&node->pend_frames);\n\tspin_lock_init(&node->els_ios_lock);\n\tINIT_LIST_HEAD(&node->els_ios_list);\n\tnode->els_io_enabled = true;\n\n\trc = efc_cmd_node_alloc(efc, &node->rnode, port_id, nport);\n\tif (rc) {\n\t\tefc_log_err(efc, \"efc_hw_node_alloc failed: %d\\n\", rc);\n\t\tgoto hw_alloc_fail;\n\t}\n\n\tnode->rnode.node = node;\n\tnode->sm.app = node;\n\tnode->evtdepth = 0;\n\n\tefc_node_update_display_name(node);\n\n\trc = xa_err(xa_store(&nport->lookup, port_id, node, GFP_ATOMIC));\n\tif (rc) {\n\t\tefc_log_err(efc, \"Node lookup store failed: %d\\n\", rc);\n\t\tgoto xa_fail;\n\t}\n\n\t \n\tkref_init(&node->ref);\n\tnode->release = _efc_node_free;\n\tkref_get(&nport->ref);\n\n\treturn node;\n\nxa_fail:\n\tefc_node_free_resources(efc, &node->rnode);\nhw_alloc_fail:\n\tdma_pool_free(efc->node_dma_pool, dma->virt, dma->phys);\ndma_fail:\n\tmempool_free(node, efc->node_pool);\n\treturn NULL;\n}\n\nvoid\nefc_node_free(struct efc_node *node)\n{\n\tstruct efc_nport *nport;\n\tstruct efc *efc;\n\tint rc = 0;\n\tstruct efc_node *ns = NULL;\n\n\tnport = node->nport;\n\tefc = node->efc;\n\n\tnode_printf(node, \"Free'd\\n\");\n\n\tif (node->refound) {\n\t\t \n\t\tns = efc_node_find(node->nport, FC_FID_DIR_SERV);\n\t}\n\n\tif (!node->nport) {\n\t\tefc_log_err(efc, \"Node already Freed\\n\");\n\t\treturn;\n\t}\n\n\t \n\trc = efc_node_free_resources(efc, &node->rnode);\n\tif (rc < 0)\n\t\tefc_log_err(efc, \"efc_hw_node_free failed: %d\\n\", rc);\n\n\t \n\tif (timer_pending(&node->gidpt_delay_timer))\n\t\tdel_timer(&node->gidpt_delay_timer);\n\n\txa_erase(&nport->lookup, node->rnode.fc_id);\n\n\t \n\tif (xa_empty(&nport->lookup))\n\t\tefc_sm_post_event(&nport->sm, EFC_EVT_ALL_CHILD_NODES_FREE,\n\t\t\t\t  NULL);\n\n\tnode->nport = NULL;\n\tnode->sm.current_state = NULL;\n\n\tkref_put(&nport->ref, nport->release);\n\tkref_put(&node->ref, node->release);\n\n\tif (ns) {\n\t\t \n\t\tefc_node_post_event(ns, EFC_EVT_RSCN_RCVD, NULL);\n\t}\n}\n\nstatic void\nefc_dma_copy_in(struct efc_dma *dma, void *buffer, u32 buffer_length)\n{\n\tif (!dma || !buffer || !buffer_length)\n\t\treturn;\n\n\tif (buffer_length > dma->size)\n\t\tbuffer_length = dma->size;\n\n\tmemcpy(dma->virt, buffer, buffer_length);\n\tdma->len = buffer_length;\n}\n\nint\nefc_node_attach(struct efc_node *node)\n{\n\tint rc = 0;\n\tstruct efc_nport *nport = node->nport;\n\tstruct efc_domain *domain = nport->domain;\n\tstruct efc *efc = node->efc;\n\n\tif (!domain->attached) {\n\t\tefc_log_err(efc, \"Warning: unattached domain\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\n\tefc_node_build_eui_name(node->wwpn, sizeof(node->wwpn),\n\t\t\t\tefc_node_get_wwpn(node));\n\tefc_node_build_eui_name(node->wwnn, sizeof(node->wwnn),\n\t\t\t\tefc_node_get_wwnn(node));\n\n\tefc_dma_copy_in(&node->sparm_dma_buf, node->service_params + 4,\n\t\t\tsizeof(node->service_params) - 4);\n\n\t \n\trc = efc_cmd_node_attach(efc, &node->rnode, &node->sparm_dma_buf);\n\tif (rc < 0)\n\t\tefc_log_debug(efc, \"efc_hw_node_attach failed: %d\\n\", rc);\n\n\treturn rc;\n}\n\nvoid\nefc_node_fcid_display(u32 fc_id, char *buffer, u32 buffer_length)\n{\n\tswitch (fc_id) {\n\tcase FC_FID_FLOGI:\n\t\tsnprintf(buffer, buffer_length, \"fabric\");\n\t\tbreak;\n\tcase FC_FID_FCTRL:\n\t\tsnprintf(buffer, buffer_length, \"fabctl\");\n\t\tbreak;\n\tcase FC_FID_DIR_SERV:\n\t\tsnprintf(buffer, buffer_length, \"nserve\");\n\t\tbreak;\n\tdefault:\n\t\tif (fc_id == FC_FID_DOM_MGR) {\n\t\t\tsnprintf(buffer, buffer_length, \"dctl%02x\",\n\t\t\t\t (fc_id & 0x0000ff));\n\t\t} else {\n\t\t\tsnprintf(buffer, buffer_length, \"%06x\", fc_id);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid\nefc_node_update_display_name(struct efc_node *node)\n{\n\tu32 port_id = node->rnode.fc_id;\n\tstruct efc_nport *nport = node->nport;\n\tchar portid_display[16];\n\n\tefc_node_fcid_display(port_id, portid_display, sizeof(portid_display));\n\n\tsnprintf(node->display_name, sizeof(node->display_name), \"%s.%s\",\n\t\t nport->display_name, portid_display);\n}\n\nvoid\nefc_node_send_ls_io_cleanup(struct efc_node *node)\n{\n\tif (node->send_ls_acc != EFC_NODE_SEND_LS_ACC_NONE) {\n\t\tefc_log_debug(node->efc, \"[%s] cleaning up LS_ACC oxid=0x%x\\n\",\n\t\t\t      node->display_name, node->ls_acc_oxid);\n\n\t\tnode->send_ls_acc = EFC_NODE_SEND_LS_ACC_NONE;\n\t\tnode->ls_acc_io = NULL;\n\t}\n}\n\nstatic void efc_node_handle_implicit_logo(struct efc_node *node)\n{\n\tint rc;\n\n\t \n\tWARN_ON(node->send_ls_acc != EFC_NODE_SEND_LS_ACC_PLOGI);\n\tnode_printf(node, \"Reason: implicit logout, re-authenticate\\n\");\n\n\t \n\tnode->req_free = false;\n\trc = efc_node_attach(node);\n\tefc_node_transition(node, __efc_d_wait_node_attach, NULL);\n\tnode->els_io_enabled = true;\n\n\tif (rc < 0)\n\t\tefc_node_post_event(node, EFC_EVT_NODE_ATTACH_FAIL, NULL);\n}\n\nstatic void efc_node_handle_explicit_logo(struct efc_node *node)\n{\n\ts8 pend_frames_empty;\n\tunsigned long flags = 0;\n\n\t \n\tefc_node_send_ls_io_cleanup(node);\n\n\tspin_lock_irqsave(&node->pend_frames_lock, flags);\n\tpend_frames_empty = list_empty(&node->pend_frames);\n\tspin_unlock_irqrestore(&node->pend_frames_lock, flags);\n\n\t \n\tnode_printf(node, \"Shutdown: explicit logo pend=%d \", !pend_frames_empty);\n\tnode_printf(node, \"nport.ini=%d node.tgt=%d\\n\",\n\t\t    node->nport->enable_ini, node->targ);\n\tif (!pend_frames_empty || (node->nport->enable_ini && node->targ)) {\n\t\tu8 send_plogi = false;\n\n\t\tif (node->nport->enable_ini && node->targ) {\n\t\t\t \n\t\t\tsend_plogi = true;\n\t\t}\n\n\t\t \n\t\tnode->els_io_enabled = true;\n\t\tnode->req_free = false;\n\n\t\t \n\t\tefc_node_init_device(node, send_plogi);\n\t}\n\t \n}\n\nstatic void\nefc_node_purge_pending(struct efc_node *node)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_hw_sequence *frame, *next;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&node->pend_frames_lock, flags);\n\n\tlist_for_each_entry_safe(frame, next, &node->pend_frames, list_entry) {\n\t\tlist_del(&frame->list_entry);\n\t\tefc->tt.hw_seq_free(efc, frame);\n\t}\n\n\tspin_unlock_irqrestore(&node->pend_frames_lock, flags);\n}\n\nvoid\n__efc_node_shutdown(struct efc_sm_ctx *ctx,\n\t\t    enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER: {\n\t\tefc_node_hold_frames(node);\n\t\tWARN_ON(!efc_els_io_list_empty(node, &node->els_ios_list));\n\t\t \n\t\tnode->req_free = true;\n\n\t\tswitch (node->shutdown_reason) {\n\t\tcase EFC_NODE_SHUTDOWN_IMPLICIT_LOGO:\n\t\t\t \n\n\t\t\tefc_node_handle_implicit_logo(node);\n\t\t\tbreak;\n\n\t\tcase EFC_NODE_SHUTDOWN_EXPLICIT_LOGO:\n\t\t\tefc_node_handle_explicit_logo(node);\n\t\t\tbreak;\n\n\t\tcase EFC_NODE_SHUTDOWN_DEFAULT:\n\t\tdefault: {\n\t\t\t \n\n\t\t\t \n\t\t\tefc_node_send_ls_io_cleanup(node);\n\n\t\t\tnode_printf(node,\n\t\t\t\t    \"Shutdown reason: default, purge pending\\n\");\n\t\t\tefc_node_purge_pending(node);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_node_common(__func__, ctx, evt, arg);\n\t}\n}\n\nstatic bool\nefc_node_check_els_quiesced(struct efc_node *node)\n{\n\t \n\tif (node->els_req_cnt == 0 && node->els_cmpl_cnt == 0 &&\n\t    efc_els_io_list_empty(node, &node->els_ios_list)) {\n\t\tif (!node->attached) {\n\t\t\t \n\t\t\tnode_printf(node, \"HW node not attached\\n\");\n\t\t\tefc_node_transition(node,\n\t\t\t\t\t    __efc_node_wait_ios_shutdown,\n\t\t\t\t\t     NULL);\n\t\t} else {\n\t\t\t \n\t\t\tnode_printf(node, \"HW node still attached\\n\");\n\t\t\tefc_node_transition(node, __efc_node_wait_node_free,\n\t\t\t\t\t    NULL);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid\nefc_node_initiate_cleanup(struct efc_node *node)\n{\n\t \n\tif (!efc_node_check_els_quiesced(node)) {\n\t\tefc_node_hold_frames(node);\n\t\tefc_node_transition(node, __efc_node_wait_els_shutdown, NULL);\n\t}\n}\n\nvoid\n__efc_node_wait_els_shutdown(struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg)\n{\n\tbool check_quiesce = false;\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\t \n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tif (efc_els_io_list_empty(node, &node->els_ios_list)) {\n\t\t\tnode_printf(node, \"All ELS IOs complete\\n\");\n\t\t\tcheck_quiesce = true;\n\t\t}\n\t\tbreak;\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_SRRS_ELS_REQ_OK:\n\tcase EFC_EVT_SRRS_ELS_REQ_FAIL:\n\tcase EFC_EVT_SRRS_ELS_REQ_RJT:\n\tcase EFC_EVT_ELS_REQ_ABORTED:\n\t\tif (WARN_ON(!node->els_req_cnt))\n\t\t\tbreak;\n\t\tnode->els_req_cnt--;\n\t\tcheck_quiesce = true;\n\t\tbreak;\n\n\tcase EFC_EVT_SRRS_ELS_CMPL_OK:\n\tcase EFC_EVT_SRRS_ELS_CMPL_FAIL:\n\t\tif (WARN_ON(!node->els_cmpl_cnt))\n\t\t\tbreak;\n\t\tnode->els_cmpl_cnt--;\n\t\tcheck_quiesce = true;\n\t\tbreak;\n\n\tcase EFC_EVT_ALL_CHILD_NODES_FREE:\n\t\t \n\t\tnode_printf(node, \"All ELS IOs complete\\n\");\n\t\tWARN_ON(!efc_els_io_list_empty(node, &node->els_ios_list));\n\t\tcheck_quiesce = true;\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_ACTIVE_IO_LIST_EMPTY:\n\t\tcheck_quiesce = true;\n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_ATTACH_OK:\n\t\t \n\t\tbreak;\n\n\t \n\tcase EFC_EVT_SHUTDOWN:\n\t\t \n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tfallthrough;\n\n\tcase EFC_EVT_SHUTDOWN_EXPLICIT_LOGO:\n\tcase EFC_EVT_SHUTDOWN_IMPLICIT_LOGO:\n\t\tnode_printf(node, \"%s received\\n\", efc_sm_event_name(evt));\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_node_common(__func__, ctx, evt, arg);\n\t}\n\n\tif (check_quiesce)\n\t\tefc_node_check_els_quiesced(node);\n}\n\nvoid\n__efc_node_wait_node_free(struct efc_sm_ctx *ctx,\n\t\t\t  enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_FREE_OK:\n\t\t \n\t\tnode->attached = false;\n\t\tefc_node_transition(node, __efc_node_wait_ios_shutdown, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_ALL_CHILD_NODES_FREE:\n\tcase EFC_EVT_NODE_ACTIVE_IO_LIST_EMPTY:\n\t\t \n\t\tbreak;\n\n\tcase EFC_EVT_DOMAIN_ATTACH_OK:\n\t\t \n\t\tbreak;\n\n\t \n\tcase EFC_EVT_SHUTDOWN:\n\t\t \n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tfallthrough;\n\n\tcase EFC_EVT_SHUTDOWN_EXPLICIT_LOGO:\n\tcase EFC_EVT_SHUTDOWN_IMPLICIT_LOGO:\n\t\tnode_printf(node, \"%s received\\n\", efc_sm_event_name(evt));\n\t\tbreak;\n\tdefault:\n\t\t__efc_node_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_node_wait_ios_shutdown(struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\tstruct efc *efc = node->efc;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tefc_node_hold_frames(node);\n\n\t\t \n\t\tif (efc_els_io_list_empty(node, &node->els_ios_list))\n\t\t\t \n\t\t\tefc_node_transition(node, __efc_node_shutdown, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_ACTIVE_IO_LIST_EMPTY:\n\tcase EFC_EVT_ALL_CHILD_NODES_FREE:\n\t\tif (efc_els_io_list_empty(node, &node->els_ios_list))\n\t\t\tefc_node_transition(node, __efc_node_shutdown, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_node_accept_frames(node);\n\t\tbreak;\n\n\tcase EFC_EVT_SRRS_ELS_REQ_FAIL:\n\t\t \n\t\tif (WARN_ON(!node->els_req_cnt))\n\t\t\tbreak;\n\t\tnode->els_req_cnt--;\n\t\tbreak;\n\n\t \n\tcase EFC_EVT_SHUTDOWN:\n\t\t \n\t\tnode->shutdown_reason = EFC_NODE_SHUTDOWN_DEFAULT;\n\t\tfallthrough;\n\n\tcase EFC_EVT_SHUTDOWN_EXPLICIT_LOGO:\n\tcase EFC_EVT_SHUTDOWN_IMPLICIT_LOGO:\n\t\tefc_log_debug(efc, \"[%s] %-20s\\n\", node->display_name,\n\t\t\t      efc_sm_event_name(evt));\n\t\tbreak;\n\tcase EFC_EVT_DOMAIN_ATTACH_OK:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t__efc_node_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_node_common(const char *funcname, struct efc_sm_ctx *ctx,\n\t\t  enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = NULL;\n\tstruct efc *efc = NULL;\n\tstruct efc_node_cb *cbdata = arg;\n\n\tnode = ctx->app;\n\tefc = node->efc;\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\tcase EFC_EVT_REENTER:\n\tcase EFC_EVT_EXIT:\n\tcase EFC_EVT_NPORT_TOPOLOGY_NOTIFY:\n\tcase EFC_EVT_NODE_MISSING:\n\tcase EFC_EVT_FCP_CMD_RCVD:\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_REFOUND:\n\t\tnode->refound = true;\n\t\tbreak;\n\n\t \n\tcase EFC_EVT_NODE_ATTACH_OK:\n\t\tnode->attached = true;\n\t\tbreak;\n\n\tcase EFC_EVT_NODE_FREE_OK:\n\tcase EFC_EVT_NODE_ATTACH_FAIL:\n\t\tnode->attached = false;\n\t\tbreak;\n\n\t \n\tcase EFC_EVT_SRRS_ELS_CMPL_OK:\n\tcase EFC_EVT_SRRS_ELS_CMPL_FAIL:\n\t\tif (WARN_ON(!node->els_cmpl_cnt))\n\t\t\tbreak;\n\t\tnode->els_cmpl_cnt--;\n\t\tbreak;\n\n\t \n\tcase EFC_EVT_SRRS_ELS_REQ_OK:\n\tcase EFC_EVT_SRRS_ELS_REQ_FAIL:\n\tcase EFC_EVT_SRRS_ELS_REQ_RJT:\n\tcase EFC_EVT_ELS_REQ_ABORTED:\n\t\tif (WARN_ON(!node->els_req_cnt))\n\t\t\tbreak;\n\t\tnode->els_req_cnt--;\n\t\tbreak;\n\n\tcase EFC_EVT_ELS_RCVD: {\n\t\tstruct fc_frame_header *hdr = cbdata->header->dma.virt;\n\n\t\t \n\t\tefc_log_debug(efc,\n\t\t\t      \"[%s] (%s) ELS x%02x, LS_RJT not supported\\n\",\n\t\t\t      node->display_name, funcname,\n\t\t\t      ((u8 *)cbdata->payload->dma.virt)[0]);\n\n\t\tefc_send_ls_rjt(node, be16_to_cpu(hdr->fh_ox_id),\n\t\t\t\tELS_RJT_UNSUP, ELS_EXPL_NONE, 0);\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_PLOGI_RCVD:\n\tcase EFC_EVT_FLOGI_RCVD:\n\tcase EFC_EVT_LOGO_RCVD:\n\tcase EFC_EVT_PRLI_RCVD:\n\tcase EFC_EVT_PRLO_RCVD:\n\tcase EFC_EVT_PDISC_RCVD:\n\tcase EFC_EVT_FDISC_RCVD:\n\tcase EFC_EVT_ADISC_RCVD:\n\tcase EFC_EVT_RSCN_RCVD:\n\tcase EFC_EVT_SCR_RCVD: {\n\t\tstruct fc_frame_header *hdr = cbdata->header->dma.virt;\n\n\t\t \n\t\tefc_log_debug(efc, \"[%s] (%s) %s sending ELS_RJT\\n\",\n\t\t\t      node->display_name, funcname,\n\t\t\t      efc_sm_event_name(evt));\n\t\t \n\t\tefc_send_ls_rjt(node, be16_to_cpu(hdr->fh_ox_id),\n\t\t\t\tELS_RJT_UNAB, ELS_EXPL_NONE, 0);\n\t\tbreak;\n\t}\n\tcase EFC_EVT_ABTS_RCVD: {\n\t\tefc_log_debug(efc, \"[%s] (%s) %s sending BA_ACC\\n\",\n\t\t\t      node->display_name, funcname,\n\t\t\t      efc_sm_event_name(evt));\n\n\t\t \n\t\tefc_send_bls_acc(node, cbdata->header->dma.virt);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tefc_log_debug(node->efc, \"[%s] %-20s %-20s not handled\\n\",\n\t\t\t      node->display_name, funcname,\n\t\t\t      efc_sm_event_name(evt));\n\t}\n}\n\nvoid\nefc_node_save_sparms(struct efc_node *node, void *payload)\n{\n\tmemcpy(node->service_params, payload, sizeof(node->service_params));\n}\n\nvoid\nefc_node_post_event(struct efc_node *node,\n\t\t    enum efc_sm_event evt, void *arg)\n{\n\tbool free_node = false;\n\n\tnode->evtdepth++;\n\n\tefc_sm_post_event(&node->sm, evt, arg);\n\n\t \n\tif (!node->hold_frames && node->evtdepth == 1)\n\t\tefc_process_node_pending(node);\n\n\tnode->evtdepth--;\n\n\t \n\tif (node->evtdepth == 0 && node->req_free)\n\t\tfree_node = true;\n\n\tif (free_node)\n\t\tefc_node_free(node);\n}\n\nvoid\nefc_node_transition(struct efc_node *node,\n\t\t    void (*state)(struct efc_sm_ctx *,\n\t\t\t\t  enum efc_sm_event, void *), void *data)\n{\n\tstruct efc_sm_ctx *ctx = &node->sm;\n\n\tif (ctx->current_state == state) {\n\t\tefc_node_post_event(node, EFC_EVT_REENTER, data);\n\t} else {\n\t\tefc_node_post_event(node, EFC_EVT_EXIT, data);\n\t\tctx->current_state = state;\n\t\tefc_node_post_event(node, EFC_EVT_ENTER, data);\n\t}\n}\n\nvoid\nefc_node_build_eui_name(char *buf, u32 buf_len, uint64_t eui_name)\n{\n\tmemset(buf, 0, buf_len);\n\n\tsnprintf(buf, buf_len, \"eui.%016llX\", (unsigned long long)eui_name);\n}\n\nu64\nefc_node_get_wwpn(struct efc_node *node)\n{\n\tstruct fc_els_flogi *sp =\n\t\t\t(struct fc_els_flogi *)node->service_params;\n\n\treturn be64_to_cpu(sp->fl_wwpn);\n}\n\nu64\nefc_node_get_wwnn(struct efc_node *node)\n{\n\tstruct fc_els_flogi *sp =\n\t\t\t(struct fc_els_flogi *)node->service_params;\n\n\treturn be64_to_cpu(sp->fl_wwnn);\n}\n\nint\nefc_node_check_els_req(struct efc_sm_ctx *ctx, enum efc_sm_event evt, void *arg,\n\t\tu8 cmd, void (*efc_node_common_func)(const char *,\n\t\t\t\tstruct efc_sm_ctx *, enum efc_sm_event, void *),\n\t\tconst char *funcname)\n{\n\treturn 0;\n}\n\nint\nefc_node_check_ns_req(struct efc_sm_ctx *ctx, enum efc_sm_event evt, void *arg,\n\t\tu16 cmd, void (*efc_node_common_func)(const char *,\n\t\t\t\tstruct efc_sm_ctx *, enum efc_sm_event, void *),\n\t\tconst char *funcname)\n{\n\treturn 0;\n}\n\nint\nefc_els_io_list_empty(struct efc_node *node, struct list_head *list)\n{\n\tint empty;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&node->els_ios_lock, flags);\n\tempty = list_empty(list);\n\tspin_unlock_irqrestore(&node->els_ios_lock, flags);\n\treturn empty;\n}\n\nvoid\nefc_node_pause(struct efc_node *node,\n\t       void (*state)(struct efc_sm_ctx *,\n\t\t\t     enum efc_sm_event, void *))\n\n{\n\tnode->nodedb_state = state;\n\tefc_node_transition(node, __efc_node_paused, NULL);\n}\n\nvoid\n__efc_node_paused(struct efc_sm_ctx *ctx,\n\t\t  enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_node *node = ctx->app;\n\n\tefc_node_evt_set(ctx, evt, __func__);\n\n\tnode_sm_trace();\n\n\t \n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\t\tnode_printf(node, \"Paused\\n\");\n\t\tbreak;\n\n\tcase EFC_EVT_RESUME: {\n\t\tvoid (*pf)(struct efc_sm_ctx *ctx,\n\t\t\t   enum efc_sm_event evt, void *arg);\n\n\t\tpf = node->nodedb_state;\n\n\t\tnode->nodedb_state = NULL;\n\t\tefc_node_transition(node, pf, NULL);\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_DOMAIN_ATTACH_OK:\n\t\tbreak;\n\n\tcase EFC_EVT_SHUTDOWN:\n\t\tnode->req_free = true;\n\t\tbreak;\n\n\tdefault:\n\t\t__efc_node_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\nefc_node_recv_els_frame(struct efc_node *node,\n\t\t\tstruct efc_hw_sequence *seq)\n{\n\tu32 prli_size = sizeof(struct fc_els_prli) + sizeof(struct fc_els_spp);\n\tstruct {\n\t\tu32 cmd;\n\t\tenum efc_sm_event evt;\n\t\tu32 payload_size;\n\t} els_cmd_list[] = {\n\t\t{ELS_PLOGI, EFC_EVT_PLOGI_RCVD,\tsizeof(struct fc_els_flogi)},\n\t\t{ELS_FLOGI, EFC_EVT_FLOGI_RCVD,\tsizeof(struct fc_els_flogi)},\n\t\t{ELS_LOGO, EFC_EVT_LOGO_RCVD, sizeof(struct fc_els_ls_acc)},\n\t\t{ELS_PRLI, EFC_EVT_PRLI_RCVD, prli_size},\n\t\t{ELS_PRLO, EFC_EVT_PRLO_RCVD, prli_size},\n\t\t{ELS_PDISC, EFC_EVT_PDISC_RCVD,\tMAX_ACC_REJECT_PAYLOAD},\n\t\t{ELS_FDISC, EFC_EVT_FDISC_RCVD,\tMAX_ACC_REJECT_PAYLOAD},\n\t\t{ELS_ADISC, EFC_EVT_ADISC_RCVD,\tsizeof(struct fc_els_adisc)},\n\t\t{ELS_RSCN, EFC_EVT_RSCN_RCVD, MAX_ACC_REJECT_PAYLOAD},\n\t\t{ELS_SCR, EFC_EVT_SCR_RCVD, MAX_ACC_REJECT_PAYLOAD},\n\t};\n\tstruct efc_node_cb cbdata;\n\tu8 *buf = seq->payload->dma.virt;\n\tenum efc_sm_event evt = EFC_EVT_ELS_RCVD;\n\tu32 i;\n\n\tmemset(&cbdata, 0, sizeof(cbdata));\n\tcbdata.header = seq->header;\n\tcbdata.payload = seq->payload;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(els_cmd_list); i++) {\n\t\tif (els_cmd_list[i].cmd == buf[0]) {\n\t\t\tevt = els_cmd_list[i].evt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tefc_node_post_event(node, evt, &cbdata);\n}\n\nvoid\nefc_node_recv_ct_frame(struct efc_node *node,\n\t\t       struct efc_hw_sequence *seq)\n{\n\tstruct fc_ct_hdr *iu = seq->payload->dma.virt;\n\tstruct fc_frame_header *hdr = seq->header->dma.virt;\n\tstruct efc *efc = node->efc;\n\tu16 gscmd = be16_to_cpu(iu->ct_cmd);\n\n\tefc_log_err(efc, \"[%s] Received cmd :%x sending CT_REJECT\\n\",\n\t\t    node->display_name, gscmd);\n\tefc_send_ct_rsp(efc, node, be16_to_cpu(hdr->fh_ox_id), iu,\n\t\t\tFC_FS_RJT, FC_FS_RJT_UNSUP, 0);\n}\n\nvoid\nefc_node_recv_fcp_cmd(struct efc_node *node, struct efc_hw_sequence *seq)\n{\n\tstruct efc_node_cb cbdata;\n\n\tmemset(&cbdata, 0, sizeof(cbdata));\n\tcbdata.header = seq->header;\n\tcbdata.payload = seq->payload;\n\n\tefc_node_post_event(node, EFC_EVT_FCP_CMD_RCVD, &cbdata);\n}\n\nvoid\nefc_process_node_pending(struct efc_node *node)\n{\n\tstruct efc *efc = node->efc;\n\tstruct efc_hw_sequence *seq = NULL;\n\tu32 pend_frames_processed = 0;\n\tunsigned long flags = 0;\n\n\tfor (;;) {\n\t\t \n\t\tif (node->hold_frames)\n\t\t\tbreak;\n\n\t\tseq = NULL;\n\t\t \n\t\tspin_lock_irqsave(&node->pend_frames_lock, flags);\n\n\t\tif (!list_empty(&node->pend_frames)) {\n\t\t\tseq = list_first_entry(&node->pend_frames,\n\t\t\t\t\tstruct efc_hw_sequence, list_entry);\n\t\t\tlist_del(&seq->list_entry);\n\t\t}\n\t\tspin_unlock_irqrestore(&node->pend_frames_lock, flags);\n\n\t\tif (!seq) {\n\t\t\tpend_frames_processed =\tnode->pend_frames_processed;\n\t\t\tnode->pend_frames_processed = 0;\n\t\t\tbreak;\n\t\t}\n\t\tnode->pend_frames_processed++;\n\n\t\t \n\t\tefc_node_dispatch_frame(node, seq);\n\t\tefc->tt.hw_seq_free(efc, seq);\n\t}\n\n\tif (pend_frames_processed != 0)\n\t\tefc_log_debug(efc, \"%u node frames held and processed\\n\",\n\t\t\t      pend_frames_processed);\n}\n\nvoid\nefc_scsi_sess_reg_complete(struct efc_node *node, u32 status)\n{\n\tunsigned long flags = 0;\n\tenum efc_sm_event evt = EFC_EVT_NODE_SESS_REG_OK;\n\tstruct efc *efc = node->efc;\n\n\tif (status)\n\t\tevt = EFC_EVT_NODE_SESS_REG_FAIL;\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\t \n\tefc_node_post_event(node, evt, NULL);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n}\n\nvoid\nefc_scsi_del_initiator_complete(struct efc *efc, struct efc_node *node)\n{\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\t \n\tefc_node_post_event(node, EFC_EVT_NODE_DEL_INI_COMPLETE, NULL);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n}\n\nvoid\nefc_scsi_del_target_complete(struct efc *efc, struct efc_node *node)\n{\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\t \n\tefc_node_post_event(node, EFC_EVT_NODE_DEL_TGT_COMPLETE, NULL);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n}\n\nvoid\nefc_scsi_io_list_empty(struct efc *efc, struct efc_node *node)\n{\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\tefc_node_post_event(node, EFC_EVT_NODE_ACTIVE_IO_LIST_EMPTY, NULL);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n}\n\nvoid efc_node_post_els_resp(struct efc_node *node, u32 evt, void *arg)\n{\n\tstruct efc *efc = node->efc;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\tefc_node_post_event(node, evt, arg);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n}\n\nvoid efc_node_post_shutdown(struct efc_node *node, void *arg)\n{\n\tunsigned long flags = 0;\n\tstruct efc *efc = node->efc;\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\tefc_node_post_event(node, EFC_EVT_SHUTDOWN, arg);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}