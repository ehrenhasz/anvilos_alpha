{
  "module_name": "efc_nport.c",
  "hash_id": "24c2ae1402692c83851890f931428273711930ad637418a8a7d3be1819f2fc05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/elx/libefc/efc_nport.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"efc.h\"\n\nvoid\nefc_nport_cb(void *arg, int event, void *data)\n{\n\tstruct efc *efc = arg;\n\tstruct efc_nport *nport = data;\n\tunsigned long flags = 0;\n\n\tefc_log_debug(efc, \"nport event: %s\\n\", efc_sm_event_name(event));\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\tefc_sm_post_event(&nport->sm, event, NULL);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n}\n\nstatic struct efc_nport *\nefc_nport_find_wwn(struct efc_domain *domain, uint64_t wwnn, uint64_t wwpn)\n{\n\tstruct efc_nport *nport = NULL;\n\n\t \n\tlist_for_each_entry(nport, &domain->nport_list, list_entry) {\n\t\tif (nport->wwnn == wwnn && nport->wwpn == wwpn)\n\t\t\treturn nport;\n\t}\n\treturn NULL;\n}\n\nstatic void\n_efc_nport_free(struct kref *arg)\n{\n\tstruct efc_nport *nport = container_of(arg, struct efc_nport, ref);\n\n\tkfree(nport);\n}\n\nstruct efc_nport *\nefc_nport_alloc(struct efc_domain *domain, uint64_t wwpn, uint64_t wwnn,\n\t\tu32 fc_id, bool enable_ini, bool enable_tgt)\n{\n\tstruct efc_nport *nport;\n\n\tif (domain->efc->enable_ini)\n\t\tenable_ini = 0;\n\n\t \n\tif ((wwpn != 0) || (wwnn != 0)) {\n\t\tnport = efc_nport_find_wwn(domain, wwnn, wwpn);\n\t\tif (nport) {\n\t\t\tefc_log_err(domain->efc,\n\t\t\t\t    \"NPORT %016llX %016llX already allocated\\n\",\n\t\t\t\t    wwnn, wwpn);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tnport = kzalloc(sizeof(*nport), GFP_ATOMIC);\n\tif (!nport)\n\t\treturn nport;\n\n\t \n\tkref_init(&nport->ref);\n\tnport->release = _efc_nport_free;\n\n\tnport->efc = domain->efc;\n\tsnprintf(nport->display_name, sizeof(nport->display_name), \"------\");\n\tnport->domain = domain;\n\txa_init(&nport->lookup);\n\tnport->instance_index = domain->nport_count++;\n\tnport->sm.app = nport;\n\tnport->enable_ini = enable_ini;\n\tnport->enable_tgt = enable_tgt;\n\tnport->enable_rscn = (nport->enable_ini ||\n\t\t\t(nport->enable_tgt && enable_target_rscn(nport->efc)));\n\n\t \n\tmemcpy(nport->service_params, domain->service_params,\n\t       sizeof(struct fc_els_flogi));\n\n\t \n\tnport->fc_id = fc_id;\n\n\t \n\tnport->wwpn = wwpn;\n\tnport->wwnn = wwnn;\n\tsnprintf(nport->wwnn_str, sizeof(nport->wwnn_str), \"%016llX\",\n\t\t (unsigned long long)wwnn);\n\n\t \n\tif (list_empty(&domain->nport_list))\n\t\tdomain->nport = nport;\n\n\tINIT_LIST_HEAD(&nport->list_entry);\n\tlist_add_tail(&nport->list_entry, &domain->nport_list);\n\n\tkref_get(&domain->ref);\n\n\tefc_log_debug(domain->efc, \"New Nport [%s]\\n\", nport->display_name);\n\n\treturn nport;\n}\n\nvoid\nefc_nport_free(struct efc_nport *nport)\n{\n\tstruct efc_domain *domain;\n\n\tif (!nport)\n\t\treturn;\n\n\tdomain = nport->domain;\n\tefc_log_debug(domain->efc, \"[%s] free nport\\n\", nport->display_name);\n\tlist_del(&nport->list_entry);\n\t \n\tif (nport == domain->nport)\n\t\tdomain->nport = NULL;\n\n\txa_destroy(&nport->lookup);\n\txa_erase(&domain->lookup, nport->fc_id);\n\n\tif (list_empty(&domain->nport_list))\n\t\tefc_domain_post_event(domain, EFC_EVT_ALL_CHILD_NODES_FREE,\n\t\t\t\t      NULL);\n\n\tkref_put(&domain->ref, domain->release);\n\tkref_put(&nport->ref, nport->release);\n}\n\nstruct efc_nport *\nefc_nport_find(struct efc_domain *domain, u32 d_id)\n{\n\tstruct efc_nport *nport;\n\n\t \n\tnport = xa_load(&domain->lookup, d_id);\n\tif (!nport || !kref_get_unless_zero(&nport->ref))\n\t\treturn NULL;\n\n\treturn nport;\n}\n\nint\nefc_nport_attach(struct efc_nport *nport, u32 fc_id)\n{\n\tint rc;\n\tstruct efc_node *node;\n\tstruct efc *efc = nport->efc;\n\tunsigned long index;\n\n\t \n\trc = xa_err(xa_store(&nport->domain->lookup, fc_id, nport, GFP_ATOMIC));\n\tif (rc) {\n\t\tefc_log_err(efc, \"Sport lookup store failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tefc_node_fcid_display(fc_id, nport->display_name,\n\t\t\t      sizeof(nport->display_name));\n\n\txa_for_each(&nport->lookup, index, node) {\n\t\tefc_node_update_display_name(node);\n\t}\n\n\tefc_log_debug(nport->efc, \"[%s] attach nport: fc_id x%06x\\n\",\n\t\t      nport->display_name, fc_id);\n\n\t \n\trc = efc_cmd_nport_attach(efc, nport, fc_id);\n\tif (rc < 0) {\n\t\tefc_log_err(nport->efc,\n\t\t\t    \"efc_hw_port_attach failed: %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void\nefc_nport_shutdown(struct efc_nport *nport)\n{\n\tstruct efc *efc = nport->efc;\n\tstruct efc_node *node;\n\tunsigned long index;\n\n\txa_for_each(&nport->lookup, index, node) {\n\t\tif (!(node->rnode.fc_id == FC_FID_FLOGI && nport->is_vport)) {\n\t\t\tefc_node_post_event(node, EFC_EVT_SHUTDOWN, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\t \n\t\tif (efc->link_status == EFC_LINK_STATUS_DOWN) {\n\t\t\tefc_node_post_event(node, EFC_EVT_SHUTDOWN, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tefc_log_debug(efc, \"[%s] nport shutdown vport, send logo\\n\",\n\t\t\t      node->display_name);\n\n\t\tif (!efc_send_logo(node)) {\n\t\t\t \n\t\t\tefc_node_transition(node, __efc_d_wait_logo_rsp, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnode_printf(node, \"Failed to send LOGO\\n\");\n\t\tefc_node_post_event(node, EFC_EVT_SHUTDOWN_EXPLICIT_LOGO, NULL);\n\t}\n}\n\nstatic void\nefc_vport_link_down(struct efc_nport *nport)\n{\n\tstruct efc *efc = nport->efc;\n\tstruct efc_vport *vport;\n\n\t \n\tlist_for_each_entry(vport, &efc->vport_list, list_entry) {\n\t\tif (vport->nport == nport) {\n\t\t\tkref_put(&nport->ref, nport->release);\n\t\t\tvport->nport = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\n__efc_nport_common(const char *funcname, struct efc_sm_ctx *ctx,\n\t\t   enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_nport *nport = ctx->app;\n\tstruct efc_domain *domain = nport->domain;\n\tstruct efc *efc = nport->efc;\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER:\n\tcase EFC_EVT_REENTER:\n\tcase EFC_EVT_EXIT:\n\tcase EFC_EVT_ALL_CHILD_NODES_FREE:\n\t\tbreak;\n\tcase EFC_EVT_NPORT_ATTACH_OK:\n\t\t\tefc_sm_transition(ctx, __efc_nport_attached, NULL);\n\t\tbreak;\n\tcase EFC_EVT_SHUTDOWN:\n\t\t \n\t\tnport->shutting_down = true;\n\n\t\tif (nport->is_vport)\n\t\t\tefc_vport_link_down(nport);\n\n\t\tif (xa_empty(&nport->lookup)) {\n\t\t\t \n\t\t\txa_erase(&domain->lookup, nport->fc_id);\n\t\t\tefc_sm_transition(ctx, __efc_nport_wait_port_free,\n\t\t\t\t\t  NULL);\n\t\t\tif (efc_cmd_nport_free(efc, nport)) {\n\t\t\t\tefc_log_debug(nport->efc,\n\t\t\t\t\t      \"efc_hw_port_free failed\\n\");\n\t\t\t\t \n\t\t\t\tefc_nport_free(nport);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tefc_sm_transition(ctx,\n\t\t\t\t\t  __efc_nport_wait_shutdown, NULL);\n\t\t\tefc_nport_shutdown(nport);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tefc_log_debug(nport->efc, \"[%s] %-20s %-20s not handled\\n\",\n\t\t\t      nport->display_name, funcname,\n\t\t\t      efc_sm_event_name(evt));\n\t}\n}\n\nvoid\n__efc_nport_allocated(struct efc_sm_ctx *ctx,\n\t\t      enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_nport *nport = ctx->app;\n\tstruct efc_domain *domain = nport->domain;\n\n\tnport_sm_trace(nport);\n\n\tswitch (evt) {\n\t \n\tcase EFC_EVT_NPORT_ATTACH_OK:\n\t\tWARN_ON(nport != domain->nport);\n\t\tefc_sm_transition(ctx, __efc_nport_attached, NULL);\n\t\tbreak;\n\n\tcase EFC_EVT_NPORT_ALLOC_OK:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t__efc_nport_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_nport_vport_init(struct efc_sm_ctx *ctx,\n\t\t       enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_nport *nport = ctx->app;\n\tstruct efc *efc = nport->efc;\n\n\tnport_sm_trace(nport);\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER: {\n\t\t__be64 be_wwpn = cpu_to_be64(nport->wwpn);\n\n\t\tif (nport->wwpn == 0)\n\t\t\tefc_log_debug(efc, \"vport: letting f/w select WWN\\n\");\n\n\t\tif (nport->fc_id != U32_MAX) {\n\t\t\tefc_log_debug(efc, \"vport: hard coding port id: %x\\n\",\n\t\t\t\t      nport->fc_id);\n\t\t}\n\n\t\tefc_sm_transition(ctx, __efc_nport_vport_wait_alloc, NULL);\n\t\t \n\t\tif (efc_cmd_nport_alloc(efc, nport, nport->domain,\n\t\t\t\t\tnport->wwpn == 0 ? NULL :\n\t\t\t\t\t(uint8_t *)&be_wwpn)) {\n\t\t\tefc_log_err(efc, \"Can't allocate port\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_nport_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_nport_vport_wait_alloc(struct efc_sm_ctx *ctx,\n\t\t\t     enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_nport *nport = ctx->app;\n\tstruct efc *efc = nport->efc;\n\n\tnport_sm_trace(nport);\n\n\tswitch (evt) {\n\tcase EFC_EVT_NPORT_ALLOC_OK: {\n\t\tstruct fc_els_flogi *sp;\n\n\t\tsp = (struct fc_els_flogi *)nport->service_params;\n\n\t\tif (nport->wwnn == 0) {\n\t\t\tnport->wwnn = be64_to_cpu(nport->sli_wwnn);\n\t\t\tnport->wwpn = be64_to_cpu(nport->sli_wwpn);\n\t\t\tsnprintf(nport->wwnn_str, sizeof(nport->wwnn_str),\n\t\t\t\t \"%016llX\", nport->wwpn);\n\t\t}\n\n\t\t \n\t\tsp->fl_wwpn = cpu_to_be64(nport->wwpn);\n\t\tsp->fl_wwnn = cpu_to_be64(nport->wwnn);\n\n\t\t \n\t\tif (nport->fc_id == U32_MAX) {\n\t\t\tstruct efc_node *fabric;\n\n\t\t\tfabric = efc_node_alloc(nport, FC_FID_FLOGI, false,\n\t\t\t\t\t\tfalse);\n\t\t\tif (!fabric) {\n\t\t\t\tefc_log_err(efc, \"efc_node_alloc() failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tefc_node_transition(fabric, __efc_vport_fabric_init,\n\t\t\t\t\t    NULL);\n\t\t} else {\n\t\t\tsnprintf(nport->wwnn_str, sizeof(nport->wwnn_str),\n\t\t\t\t \"%016llX\", nport->wwpn);\n\t\t\tefc_nport_attach(nport, nport->fc_id);\n\t\t}\n\t\tefc_sm_transition(ctx, __efc_nport_vport_allocated, NULL);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_nport_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_nport_vport_allocated(struct efc_sm_ctx *ctx,\n\t\t\t    enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_nport *nport = ctx->app;\n\tstruct efc *efc = nport->efc;\n\n\tnport_sm_trace(nport);\n\n\t \n\tswitch (evt) {\n\tcase EFC_EVT_NPORT_ATTACH_OK: {\n\t\tstruct efc_node *node;\n\n\t\t \n\t\tnode = efc_node_find(nport, FC_FID_FLOGI);\n\t\tif (!node) {\n\t\t\tefc_log_debug(efc, \"can't find node %06x\\n\", FC_FID_FLOGI);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tefc_node_post_event(node, evt, NULL);\n\t\tefc_sm_transition(ctx, __efc_nport_attached, NULL);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_nport_common(__func__, ctx, evt, arg);\n\t}\n}\n\nstatic void\nefc_vport_update_spec(struct efc_nport *nport)\n{\n\tstruct efc *efc = nport->efc;\n\tstruct efc_vport *vport;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->vport_lock, flags);\n\tlist_for_each_entry(vport, &efc->vport_list, list_entry) {\n\t\tif (vport->nport == nport) {\n\t\t\tvport->wwnn = nport->wwnn;\n\t\t\tvport->wwpn = nport->wwpn;\n\t\t\tvport->tgt_data = nport->tgt_data;\n\t\t\tvport->ini_data = nport->ini_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&efc->vport_lock, flags);\n}\n\nvoid\n__efc_nport_attached(struct efc_sm_ctx *ctx,\n\t\t     enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_nport *nport = ctx->app;\n\tstruct efc *efc = nport->efc;\n\n\tnport_sm_trace(nport);\n\n\tswitch (evt) {\n\tcase EFC_EVT_ENTER: {\n\t\tstruct efc_node *node;\n\t\tunsigned long index;\n\n\t\tefc_log_debug(efc,\n\t\t\t      \"[%s] NPORT attached WWPN %016llX WWNN %016llX\\n\",\n\t\t\t      nport->display_name,\n\t\t\t      nport->wwpn, nport->wwnn);\n\n\t\txa_for_each(&nport->lookup, index, node)\n\t\t\tefc_node_update_display_name(node);\n\n\t\tefc->tt.new_nport(efc, nport);\n\n\t\t \n\t\tif (nport->is_vport)\n\t\t\tefc_vport_update_spec(nport);\n\t\tbreak;\n\t}\n\n\tcase EFC_EVT_EXIT:\n\t\tefc_log_debug(efc,\n\t\t\t      \"[%s] NPORT deattached WWPN %016llX WWNN %016llX\\n\",\n\t\t\t      nport->display_name,\n\t\t\t      nport->wwpn, nport->wwnn);\n\n\t\tefc->tt.del_nport(efc, nport);\n\t\tbreak;\n\tdefault:\n\t\t__efc_nport_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_nport_wait_shutdown(struct efc_sm_ctx *ctx,\n\t\t\t  enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_nport *nport = ctx->app;\n\tstruct efc_domain *domain = nport->domain;\n\tstruct efc *efc = nport->efc;\n\n\tnport_sm_trace(nport);\n\n\tswitch (evt) {\n\tcase EFC_EVT_NPORT_ALLOC_OK:\n\tcase EFC_EVT_NPORT_ALLOC_FAIL:\n\tcase EFC_EVT_NPORT_ATTACH_OK:\n\tcase EFC_EVT_NPORT_ATTACH_FAIL:\n\t\t \n\t\tbreak;\n\n\tcase EFC_EVT_ALL_CHILD_NODES_FREE: {\n\t\t \n\t\txa_erase(&domain->lookup, nport->fc_id);\n\t\tefc_sm_transition(ctx, __efc_nport_wait_port_free, NULL);\n\t\tif (efc_cmd_nport_free(efc, nport)) {\n\t\t\tefc_log_err(nport->efc, \"efc_hw_port_free failed\\n\");\n\t\t\t \n\t\t\tefc_nport_free(nport);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_nport_common(__func__, ctx, evt, arg);\n\t}\n}\n\nvoid\n__efc_nport_wait_port_free(struct efc_sm_ctx *ctx,\n\t\t\t   enum efc_sm_event evt, void *arg)\n{\n\tstruct efc_nport *nport = ctx->app;\n\n\tnport_sm_trace(nport);\n\n\tswitch (evt) {\n\tcase EFC_EVT_NPORT_ATTACH_OK:\n\t\t \n\t\tbreak;\n\tcase EFC_EVT_NPORT_FREE_OK: {\n\t\t \n\t\tefc_nport_free(nport);\n\t\tbreak;\n\t}\n\tdefault:\n\t\t__efc_nport_common(__func__, ctx, evt, arg);\n\t}\n}\n\nstatic int\nefc_vport_nport_alloc(struct efc_domain *domain, struct efc_vport *vport)\n{\n\tstruct efc_nport *nport;\n\n\tlockdep_assert_held(&domain->efc->lock);\n\n\tnport = efc_nport_alloc(domain, vport->wwpn, vport->wwnn, vport->fc_id,\n\t\t\t\tvport->enable_ini, vport->enable_tgt);\n\tvport->nport = nport;\n\tif (!nport)\n\t\treturn -EIO;\n\n\tkref_get(&nport->ref);\n\tnport->is_vport = true;\n\tnport->tgt_data = vport->tgt_data;\n\tnport->ini_data = vport->ini_data;\n\n\tefc_sm_transition(&nport->sm, __efc_nport_vport_init, NULL);\n\n\treturn 0;\n}\n\nint\nefc_vport_start(struct efc_domain *domain)\n{\n\tstruct efc *efc = domain->efc;\n\tstruct efc_vport *vport;\n\tstruct efc_vport *next;\n\tint rc = 0;\n\tunsigned long flags = 0;\n\n\t \n\tspin_lock_irqsave(&efc->vport_lock, flags);\n\tlist_for_each_entry_safe(vport, next, &efc->vport_list, list_entry) {\n\t\tif (!vport->nport) {\n\t\t\tif (efc_vport_nport_alloc(domain, vport))\n\t\t\t\trc = -EIO;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&efc->vport_lock, flags);\n\n\treturn rc;\n}\n\nint\nefc_nport_vport_new(struct efc_domain *domain, uint64_t wwpn, uint64_t wwnn,\n\t\t    u32 fc_id, bool ini, bool tgt, void *tgt_data,\n\t\t    void *ini_data)\n{\n\tstruct efc *efc = domain->efc;\n\tstruct efc_vport *vport;\n\tint rc = 0;\n\tunsigned long flags = 0;\n\n\tif (ini && domain->efc->enable_ini == 0) {\n\t\tefc_log_debug(efc, \"driver initiator mode not enabled\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (tgt && domain->efc->enable_tgt == 0) {\n\t\tefc_log_debug(efc, \"driver target mode not enabled\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tvport = efc_vport_create_spec(domain->efc, wwnn, wwpn, fc_id, ini, tgt,\n\t\t\t\t      tgt_data, ini_data);\n\tif (!vport) {\n\t\tefc_log_err(efc, \"failed to create vport object entry\\n\");\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\trc = efc_vport_nport_alloc(domain, vport);\n\tspin_unlock_irqrestore(&efc->lock, flags);\n\n\treturn rc;\n}\n\nint\nefc_nport_vport_del(struct efc *efc, struct efc_domain *domain,\n\t\t    u64 wwpn, uint64_t wwnn)\n{\n\tstruct efc_nport *nport;\n\tstruct efc_vport *vport;\n\tstruct efc_vport *next;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->vport_lock, flags);\n\t \n\tlist_for_each_entry_safe(vport, next, &efc->vport_list, list_entry) {\n\t\tif (vport->wwpn == wwpn && vport->wwnn == wwnn) {\n\t\t\tlist_del(&vport->list_entry);\n\t\t\tkfree(vport);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&efc->vport_lock, flags);\n\n\tif (!domain) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&efc->lock, flags);\n\tlist_for_each_entry(nport, &domain->nport_list, list_entry) {\n\t\tif (nport->wwpn == wwpn && nport->wwnn == wwnn) {\n\t\t\tkref_put(&nport->ref, nport->release);\n\t\t\t \n\t\t\tefc_sm_post_event(&nport->sm, EFC_EVT_SHUTDOWN, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&efc->lock, flags);\n\treturn 0;\n}\n\nvoid\nefc_vport_del_all(struct efc *efc)\n{\n\tstruct efc_vport *vport;\n\tstruct efc_vport *next;\n\tunsigned long flags = 0;\n\n\tspin_lock_irqsave(&efc->vport_lock, flags);\n\tlist_for_each_entry_safe(vport, next, &efc->vport_list, list_entry) {\n\t\tlist_del(&vport->list_entry);\n\t\tkfree(vport);\n\t}\n\tspin_unlock_irqrestore(&efc->vport_lock, flags);\n}\n\nstruct efc_vport *\nefc_vport_create_spec(struct efc *efc, uint64_t wwnn, uint64_t wwpn,\n\t\t      u32 fc_id, bool enable_ini,\n\t\t      bool enable_tgt, void *tgt_data, void *ini_data)\n{\n\tstruct efc_vport *vport;\n\tunsigned long flags = 0;\n\n\t \n\tspin_lock_irqsave(&efc->vport_lock, flags);\n\tlist_for_each_entry(vport, &efc->vport_list, list_entry) {\n\t\tif ((wwpn && vport->wwpn == wwpn) &&\n\t\t    (wwnn && vport->wwnn == wwnn)) {\n\t\t\tefc_log_err(efc,\n\t\t\t\t    \"VPORT %016llX %016llX already allocated\\n\",\n\t\t\t\t    wwnn, wwpn);\n\t\t\tspin_unlock_irqrestore(&efc->vport_lock, flags);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tvport = kzalloc(sizeof(*vport), GFP_ATOMIC);\n\tif (!vport) {\n\t\tspin_unlock_irqrestore(&efc->vport_lock, flags);\n\t\treturn NULL;\n\t}\n\n\tvport->wwnn = wwnn;\n\tvport->wwpn = wwpn;\n\tvport->fc_id = fc_id;\n\tvport->enable_tgt = enable_tgt;\n\tvport->enable_ini = enable_ini;\n\tvport->tgt_data = tgt_data;\n\tvport->ini_data = ini_data;\n\n\tINIT_LIST_HEAD(&vport->list_entry);\n\tlist_add_tail(&vport->list_entry, &efc->vport_list);\n\tspin_unlock_irqrestore(&efc->vport_lock, flags);\n\treturn vport;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}