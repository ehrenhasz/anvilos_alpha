{
  "module_name": "virtio_scsi.c",
  "hash_id": "a91f8368fbb1b84766b8a44a3380214a7d0ae9134a7acbecfa41f468294d4be6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/virtio_scsi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mempool.h>\n#include <linux/interrupt.h>\n#include <linux/virtio.h>\n#include <linux/virtio_ids.h>\n#include <linux/virtio_config.h>\n#include <linux/virtio_scsi.h>\n#include <linux/cpu.h>\n#include <linux/blkdev.h>\n#include <linux/blk-integrity.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_devinfo.h>\n#include <linux/seqlock.h>\n#include <linux/blk-mq-virtio.h>\n\n#include \"sd.h\"\n\n#define VIRTIO_SCSI_MEMPOOL_SZ 64\n#define VIRTIO_SCSI_EVENT_LEN 8\n#define VIRTIO_SCSI_VQ_BASE 2\n\n \nstruct virtio_scsi_cmd {\n\tstruct scsi_cmnd *sc;\n\tstruct completion *comp;\n\tunion {\n\t\tstruct virtio_scsi_cmd_req       cmd;\n\t\tstruct virtio_scsi_cmd_req_pi    cmd_pi;\n\t\tstruct virtio_scsi_ctrl_tmf_req  tmf;\n\t\tstruct virtio_scsi_ctrl_an_req   an;\n\t} req;\n\tunion {\n\t\tstruct virtio_scsi_cmd_resp      cmd;\n\t\tstruct virtio_scsi_ctrl_tmf_resp tmf;\n\t\tstruct virtio_scsi_ctrl_an_resp  an;\n\t\tstruct virtio_scsi_event         evt;\n\t} resp;\n} ____cacheline_aligned_in_smp;\n\nstruct virtio_scsi_event_node {\n\tstruct virtio_scsi *vscsi;\n\tstruct virtio_scsi_event event;\n\tstruct work_struct work;\n};\n\nstruct virtio_scsi_vq {\n\t \n\tspinlock_t vq_lock;\n\n\tstruct virtqueue *vq;\n};\n\n \nstruct virtio_scsi {\n\tstruct virtio_device *vdev;\n\n\t \n\tstruct virtio_scsi_event_node event_list[VIRTIO_SCSI_EVENT_LEN];\n\n\tu32 num_queues;\n\n\tstruct hlist_node node;\n\n\t \n\tbool stop_events;\n\n\tstruct virtio_scsi_vq ctrl_vq;\n\tstruct virtio_scsi_vq event_vq;\n\tstruct virtio_scsi_vq req_vqs[];\n};\n\nstatic struct kmem_cache *virtscsi_cmd_cache;\nstatic mempool_t *virtscsi_cmd_pool;\n\nstatic inline struct Scsi_Host *virtio_scsi_host(struct virtio_device *vdev)\n{\n\treturn vdev->priv;\n}\n\nstatic void virtscsi_compute_resid(struct scsi_cmnd *sc, u32 resid)\n{\n\tif (resid)\n\t\tscsi_set_resid(sc, min(resid, scsi_bufflen(sc)));\n}\n\n \nstatic void virtscsi_complete_cmd(struct virtio_scsi *vscsi, void *buf)\n{\n\tstruct virtio_scsi_cmd *cmd = buf;\n\tstruct scsi_cmnd *sc = cmd->sc;\n\tstruct virtio_scsi_cmd_resp *resp = &cmd->resp.cmd;\n\n\tdev_dbg(&sc->device->sdev_gendev,\n\t\t\"cmd %p response %u status %#02x sense_len %u\\n\",\n\t\tsc, resp->response, resp->status, resp->sense_len);\n\n\tsc->result = resp->status;\n\tvirtscsi_compute_resid(sc, virtio32_to_cpu(vscsi->vdev, resp->resid));\n\tswitch (resp->response) {\n\tcase VIRTIO_SCSI_S_OK:\n\t\tset_host_byte(sc, DID_OK);\n\t\tbreak;\n\tcase VIRTIO_SCSI_S_OVERRUN:\n\t\tset_host_byte(sc, DID_ERROR);\n\t\tbreak;\n\tcase VIRTIO_SCSI_S_ABORTED:\n\t\tset_host_byte(sc, DID_ABORT);\n\t\tbreak;\n\tcase VIRTIO_SCSI_S_BAD_TARGET:\n\t\tset_host_byte(sc, DID_BAD_TARGET);\n\t\tbreak;\n\tcase VIRTIO_SCSI_S_RESET:\n\t\tset_host_byte(sc, DID_RESET);\n\t\tbreak;\n\tcase VIRTIO_SCSI_S_BUSY:\n\t\tset_host_byte(sc, DID_BUS_BUSY);\n\t\tbreak;\n\tcase VIRTIO_SCSI_S_TRANSPORT_FAILURE:\n\t\tset_host_byte(sc, DID_TRANSPORT_DISRUPTED);\n\t\tbreak;\n\tcase VIRTIO_SCSI_S_TARGET_FAILURE:\n\t\tset_host_byte(sc, DID_BAD_TARGET);\n\t\tbreak;\n\tcase VIRTIO_SCSI_S_NEXUS_FAILURE:\n\t\tset_status_byte(sc, SAM_STAT_RESERVATION_CONFLICT);\n\t\tbreak;\n\tdefault:\n\t\tscmd_printk(KERN_WARNING, sc, \"Unknown response %d\",\n\t\t\t    resp->response);\n\t\tfallthrough;\n\tcase VIRTIO_SCSI_S_FAILURE:\n\t\tset_host_byte(sc, DID_ERROR);\n\t\tbreak;\n\t}\n\n\tWARN_ON(virtio32_to_cpu(vscsi->vdev, resp->sense_len) >\n\t\tVIRTIO_SCSI_SENSE_SIZE);\n\tif (resp->sense_len) {\n\t\tmemcpy(sc->sense_buffer, resp->sense,\n\t\t       min_t(u32,\n\t\t\t     virtio32_to_cpu(vscsi->vdev, resp->sense_len),\n\t\t\t     VIRTIO_SCSI_SENSE_SIZE));\n\t}\n\n\tscsi_done(sc);\n}\n\nstatic void virtscsi_vq_done(struct virtio_scsi *vscsi,\n\t\t\t     struct virtio_scsi_vq *virtscsi_vq,\n\t\t\t     void (*fn)(struct virtio_scsi *vscsi, void *buf))\n{\n\tvoid *buf;\n\tunsigned int len;\n\tunsigned long flags;\n\tstruct virtqueue *vq = virtscsi_vq->vq;\n\n\tspin_lock_irqsave(&virtscsi_vq->vq_lock, flags);\n\tdo {\n\t\tvirtqueue_disable_cb(vq);\n\t\twhile ((buf = virtqueue_get_buf(vq, &len)) != NULL)\n\t\t\tfn(vscsi, buf);\n\n\t\tif (unlikely(virtqueue_is_broken(vq)))\n\t\t\tbreak;\n\t} while (!virtqueue_enable_cb(vq));\n\tspin_unlock_irqrestore(&virtscsi_vq->vq_lock, flags);\n}\n\nstatic void virtscsi_req_done(struct virtqueue *vq)\n{\n\tstruct Scsi_Host *sh = virtio_scsi_host(vq->vdev);\n\tstruct virtio_scsi *vscsi = shost_priv(sh);\n\tint index = vq->index - VIRTIO_SCSI_VQ_BASE;\n\tstruct virtio_scsi_vq *req_vq = &vscsi->req_vqs[index];\n\n\tvirtscsi_vq_done(vscsi, req_vq, virtscsi_complete_cmd);\n};\n\nstatic void virtscsi_poll_requests(struct virtio_scsi *vscsi)\n{\n\tint i, num_vqs;\n\n\tnum_vqs = vscsi->num_queues;\n\tfor (i = 0; i < num_vqs; i++)\n\t\tvirtscsi_vq_done(vscsi, &vscsi->req_vqs[i],\n\t\t\t\t virtscsi_complete_cmd);\n}\n\nstatic void virtscsi_complete_free(struct virtio_scsi *vscsi, void *buf)\n{\n\tstruct virtio_scsi_cmd *cmd = buf;\n\n\tif (cmd->comp)\n\t\tcomplete(cmd->comp);\n}\n\nstatic void virtscsi_ctrl_done(struct virtqueue *vq)\n{\n\tstruct Scsi_Host *sh = virtio_scsi_host(vq->vdev);\n\tstruct virtio_scsi *vscsi = shost_priv(sh);\n\n\tvirtscsi_vq_done(vscsi, &vscsi->ctrl_vq, virtscsi_complete_free);\n};\n\nstatic void virtscsi_handle_event(struct work_struct *work);\n\nstatic int virtscsi_kick_event(struct virtio_scsi *vscsi,\n\t\t\t       struct virtio_scsi_event_node *event_node)\n{\n\tint err;\n\tstruct scatterlist sg;\n\tunsigned long flags;\n\n\tINIT_WORK(&event_node->work, virtscsi_handle_event);\n\tsg_init_one(&sg, &event_node->event, sizeof(struct virtio_scsi_event));\n\n\tspin_lock_irqsave(&vscsi->event_vq.vq_lock, flags);\n\n\terr = virtqueue_add_inbuf(vscsi->event_vq.vq, &sg, 1, event_node,\n\t\t\t\t  GFP_ATOMIC);\n\tif (!err)\n\t\tvirtqueue_kick(vscsi->event_vq.vq);\n\n\tspin_unlock_irqrestore(&vscsi->event_vq.vq_lock, flags);\n\n\treturn err;\n}\n\nstatic int virtscsi_kick_event_all(struct virtio_scsi *vscsi)\n{\n\tint i;\n\n\tfor (i = 0; i < VIRTIO_SCSI_EVENT_LEN; i++) {\n\t\tvscsi->event_list[i].vscsi = vscsi;\n\t\tvirtscsi_kick_event(vscsi, &vscsi->event_list[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void virtscsi_cancel_event_work(struct virtio_scsi *vscsi)\n{\n\tint i;\n\n\t \n\tspin_lock_irq(&vscsi->event_vq.vq_lock);\n\tvscsi->stop_events = true;\n\tspin_unlock_irq(&vscsi->event_vq.vq_lock);\n\n\tfor (i = 0; i < VIRTIO_SCSI_EVENT_LEN; i++)\n\t\tcancel_work_sync(&vscsi->event_list[i].work);\n}\n\nstatic void virtscsi_handle_transport_reset(struct virtio_scsi *vscsi,\n\t\t\t\t\t    struct virtio_scsi_event *event)\n{\n\tstruct scsi_device *sdev;\n\tstruct Scsi_Host *shost = virtio_scsi_host(vscsi->vdev);\n\tunsigned int target = event->lun[1];\n\tunsigned int lun = (event->lun[2] << 8) | event->lun[3];\n\n\tswitch (virtio32_to_cpu(vscsi->vdev, event->reason)) {\n\tcase VIRTIO_SCSI_EVT_RESET_RESCAN:\n\t\tif (lun == 0) {\n\t\t\tscsi_scan_target(&shost->shost_gendev, 0, target,\n\t\t\t\t\t SCAN_WILD_CARD, SCSI_SCAN_INITIAL);\n\t\t} else {\n\t\t\tscsi_add_device(shost, 0, target, lun);\n\t\t}\n\t\tbreak;\n\tcase VIRTIO_SCSI_EVT_RESET_REMOVED:\n\t\tsdev = scsi_device_lookup(shost, 0, target, lun);\n\t\tif (sdev) {\n\t\t\tscsi_remove_device(sdev);\n\t\t\tscsi_device_put(sdev);\n\t\t} else {\n\t\t\tpr_err(\"SCSI device %d 0 %d %d not found\\n\",\n\t\t\t\tshost->host_no, target, lun);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Unsupported virtio scsi event reason %x\\n\", event->reason);\n\t}\n}\n\nstatic void virtscsi_handle_param_change(struct virtio_scsi *vscsi,\n\t\t\t\t\t struct virtio_scsi_event *event)\n{\n\tstruct scsi_device *sdev;\n\tstruct Scsi_Host *shost = virtio_scsi_host(vscsi->vdev);\n\tunsigned int target = event->lun[1];\n\tunsigned int lun = (event->lun[2] << 8) | event->lun[3];\n\tu8 asc = virtio32_to_cpu(vscsi->vdev, event->reason) & 255;\n\tu8 ascq = virtio32_to_cpu(vscsi->vdev, event->reason) >> 8;\n\n\tsdev = scsi_device_lookup(shost, 0, target, lun);\n\tif (!sdev) {\n\t\tpr_err(\"SCSI device %d 0 %d %d not found\\n\",\n\t\t\tshost->host_no, target, lun);\n\t\treturn;\n\t}\n\n\t \n\tif (asc == 0x2a && (ascq == 0x00 || ascq == 0x01 || ascq == 0x09))\n\t\tscsi_rescan_device(sdev);\n\n\tscsi_device_put(sdev);\n}\n\nstatic int virtscsi_rescan_hotunplug(struct virtio_scsi *vscsi)\n{\n\tstruct scsi_device *sdev;\n\tstruct Scsi_Host *shost = virtio_scsi_host(vscsi->vdev);\n\tunsigned char scsi_cmd[MAX_COMMAND_SIZE];\n\tint result, inquiry_len, inq_result_len = 256;\n\tchar *inq_result = kmalloc(inq_result_len, GFP_KERNEL);\n\n\tif (!inq_result)\n\t\treturn -ENOMEM;\n\n\tshost_for_each_device(sdev, shost) {\n\t\tinquiry_len = sdev->inquiry_len ? sdev->inquiry_len : 36;\n\n\t\tmemset(scsi_cmd, 0, sizeof(scsi_cmd));\n\t\tscsi_cmd[0] = INQUIRY;\n\t\tscsi_cmd[4] = (unsigned char) inquiry_len;\n\n\t\tmemset(inq_result, 0, inq_result_len);\n\n\t\tresult = scsi_execute_cmd(sdev, scsi_cmd, REQ_OP_DRV_IN,\n\t\t\t\t\t  inq_result, inquiry_len,\n\t\t\t\t\t  SD_TIMEOUT, SD_MAX_RETRIES, NULL);\n\n\t\tif (result == 0 && inq_result[0] >> 5) {\n\t\t\t \n\t\t\tscsi_remove_device(sdev);\n\t\t} else if (result > 0 && host_byte(result) == DID_BAD_TARGET) {\n\t\t\t \n\t\t\tscsi_remove_device(sdev);\n\t\t}\n\t}\n\n\tkfree(inq_result);\n\treturn 0;\n}\n\nstatic void virtscsi_handle_event(struct work_struct *work)\n{\n\tstruct virtio_scsi_event_node *event_node =\n\t\tcontainer_of(work, struct virtio_scsi_event_node, work);\n\tstruct virtio_scsi *vscsi = event_node->vscsi;\n\tstruct virtio_scsi_event *event = &event_node->event;\n\n\tif (event->event &\n\t    cpu_to_virtio32(vscsi->vdev, VIRTIO_SCSI_T_EVENTS_MISSED)) {\n\t\tint ret;\n\n\t\tevent->event &= ~cpu_to_virtio32(vscsi->vdev,\n\t\t\t\t\t\t   VIRTIO_SCSI_T_EVENTS_MISSED);\n\t\tret = virtscsi_rescan_hotunplug(vscsi);\n\t\tif (ret)\n\t\t\treturn;\n\t\tscsi_scan_host(virtio_scsi_host(vscsi->vdev));\n\t}\n\n\tswitch (virtio32_to_cpu(vscsi->vdev, event->event)) {\n\tcase VIRTIO_SCSI_T_NO_EVENT:\n\t\tbreak;\n\tcase VIRTIO_SCSI_T_TRANSPORT_RESET:\n\t\tvirtscsi_handle_transport_reset(vscsi, event);\n\t\tbreak;\n\tcase VIRTIO_SCSI_T_PARAM_CHANGE:\n\t\tvirtscsi_handle_param_change(vscsi, event);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unsupported virtio scsi event %x\\n\", event->event);\n\t}\n\tvirtscsi_kick_event(vscsi, event_node);\n}\n\nstatic void virtscsi_complete_event(struct virtio_scsi *vscsi, void *buf)\n{\n\tstruct virtio_scsi_event_node *event_node = buf;\n\n\tif (!vscsi->stop_events)\n\t\tqueue_work(system_freezable_wq, &event_node->work);\n}\n\nstatic void virtscsi_event_done(struct virtqueue *vq)\n{\n\tstruct Scsi_Host *sh = virtio_scsi_host(vq->vdev);\n\tstruct virtio_scsi *vscsi = shost_priv(sh);\n\n\tvirtscsi_vq_done(vscsi, &vscsi->event_vq, virtscsi_complete_event);\n};\n\nstatic int __virtscsi_add_cmd(struct virtqueue *vq,\n\t\t\t    struct virtio_scsi_cmd *cmd,\n\t\t\t    size_t req_size, size_t resp_size)\n{\n\tstruct scsi_cmnd *sc = cmd->sc;\n\tstruct scatterlist *sgs[6], req, resp;\n\tstruct sg_table *out, *in;\n\tunsigned out_num = 0, in_num = 0;\n\n\tout = in = NULL;\n\n\tif (sc && sc->sc_data_direction != DMA_NONE) {\n\t\tif (sc->sc_data_direction != DMA_FROM_DEVICE)\n\t\t\tout = &sc->sdb.table;\n\t\tif (sc->sc_data_direction != DMA_TO_DEVICE)\n\t\t\tin = &sc->sdb.table;\n\t}\n\n\t \n\tsg_init_one(&req, &cmd->req, req_size);\n\tsgs[out_num++] = &req;\n\n\t \n\tif (out) {\n\t\t \n\t\tif (scsi_prot_sg_count(sc))\n\t\t\tsgs[out_num++] = scsi_prot_sglist(sc);\n\t\tsgs[out_num++] = out->sgl;\n\t}\n\n\t \n\tsg_init_one(&resp, &cmd->resp, resp_size);\n\tsgs[out_num + in_num++] = &resp;\n\n\t \n\tif (in) {\n\t\t \n\t\tif (scsi_prot_sg_count(sc))\n\t\t\tsgs[out_num + in_num++] = scsi_prot_sglist(sc);\n\t\tsgs[out_num + in_num++] = in->sgl;\n\t}\n\n\treturn virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_ATOMIC);\n}\n\nstatic void virtscsi_kick_vq(struct virtio_scsi_vq *vq)\n{\n\tbool needs_kick;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vq->vq_lock, flags);\n\tneeds_kick = virtqueue_kick_prepare(vq->vq);\n\tspin_unlock_irqrestore(&vq->vq_lock, flags);\n\n\tif (needs_kick)\n\t\tvirtqueue_notify(vq->vq);\n}\n\n \nstatic int virtscsi_add_cmd(struct virtio_scsi_vq *vq,\n\t\t\t     struct virtio_scsi_cmd *cmd,\n\t\t\t     size_t req_size, size_t resp_size,\n\t\t\t     bool kick)\n{\n\tunsigned long flags;\n\tint err;\n\tbool needs_kick = false;\n\n\tspin_lock_irqsave(&vq->vq_lock, flags);\n\terr = __virtscsi_add_cmd(vq->vq, cmd, req_size, resp_size);\n\tif (!err && kick)\n\t\tneeds_kick = virtqueue_kick_prepare(vq->vq);\n\n\tspin_unlock_irqrestore(&vq->vq_lock, flags);\n\n\tif (needs_kick)\n\t\tvirtqueue_notify(vq->vq);\n\treturn err;\n}\n\nstatic void virtio_scsi_init_hdr(struct virtio_device *vdev,\n\t\t\t\t struct virtio_scsi_cmd_req *cmd,\n\t\t\t\t struct scsi_cmnd *sc)\n{\n\tcmd->lun[0] = 1;\n\tcmd->lun[1] = sc->device->id;\n\tcmd->lun[2] = (sc->device->lun >> 8) | 0x40;\n\tcmd->lun[3] = sc->device->lun & 0xff;\n\tcmd->tag = cpu_to_virtio64(vdev, (unsigned long)sc);\n\tcmd->task_attr = VIRTIO_SCSI_S_SIMPLE;\n\tcmd->prio = 0;\n\tcmd->crn = 0;\n}\n\n#ifdef CONFIG_BLK_DEV_INTEGRITY\nstatic void virtio_scsi_init_hdr_pi(struct virtio_device *vdev,\n\t\t\t\t    struct virtio_scsi_cmd_req_pi *cmd_pi,\n\t\t\t\t    struct scsi_cmnd *sc)\n{\n\tstruct request *rq = scsi_cmd_to_rq(sc);\n\tstruct blk_integrity *bi;\n\n\tvirtio_scsi_init_hdr(vdev, (struct virtio_scsi_cmd_req *)cmd_pi, sc);\n\n\tif (!rq || !scsi_prot_sg_count(sc))\n\t\treturn;\n\n\tbi = blk_get_integrity(rq->q->disk);\n\n\tif (sc->sc_data_direction == DMA_TO_DEVICE)\n\t\tcmd_pi->pi_bytesout = cpu_to_virtio32(vdev,\n\t\t\t\t\t\t      bio_integrity_bytes(bi,\n\t\t\t\t\t\t\tblk_rq_sectors(rq)));\n\telse if (sc->sc_data_direction == DMA_FROM_DEVICE)\n\t\tcmd_pi->pi_bytesin = cpu_to_virtio32(vdev,\n\t\t\t\t\t\t     bio_integrity_bytes(bi,\n\t\t\t\t\t\t\tblk_rq_sectors(rq)));\n}\n#endif\n\nstatic struct virtio_scsi_vq *virtscsi_pick_vq_mq(struct virtio_scsi *vscsi,\n\t\t\t\t\t\t  struct scsi_cmnd *sc)\n{\n\tu32 tag = blk_mq_unique_tag(scsi_cmd_to_rq(sc));\n\tu16 hwq = blk_mq_unique_tag_to_hwq(tag);\n\n\treturn &vscsi->req_vqs[hwq];\n}\n\nstatic int virtscsi_queuecommand(struct Scsi_Host *shost,\n\t\t\t\t struct scsi_cmnd *sc)\n{\n\tstruct virtio_scsi *vscsi = shost_priv(shost);\n\tstruct virtio_scsi_vq *req_vq = virtscsi_pick_vq_mq(vscsi, sc);\n\tstruct virtio_scsi_cmd *cmd = scsi_cmd_priv(sc);\n\tbool kick;\n\tunsigned long flags;\n\tint req_size;\n\tint ret;\n\n\tBUG_ON(scsi_sg_count(sc) > shost->sg_tablesize);\n\n\t \n\tBUG_ON(sc->sc_data_direction == DMA_BIDIRECTIONAL);\n\n\tdev_dbg(&sc->device->sdev_gendev,\n\t\t\"cmd %p CDB: %#02x\\n\", sc, sc->cmnd[0]);\n\n\tcmd->sc = sc;\n\n\tBUG_ON(sc->cmd_len > VIRTIO_SCSI_CDB_SIZE);\n\n#ifdef CONFIG_BLK_DEV_INTEGRITY\n\tif (virtio_has_feature(vscsi->vdev, VIRTIO_SCSI_F_T10_PI)) {\n\t\tvirtio_scsi_init_hdr_pi(vscsi->vdev, &cmd->req.cmd_pi, sc);\n\t\tmemcpy(cmd->req.cmd_pi.cdb, sc->cmnd, sc->cmd_len);\n\t\treq_size = sizeof(cmd->req.cmd_pi);\n\t} else\n#endif\n\t{\n\t\tvirtio_scsi_init_hdr(vscsi->vdev, &cmd->req.cmd, sc);\n\t\tmemcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);\n\t\treq_size = sizeof(cmd->req.cmd);\n\t}\n\n\tkick = (sc->flags & SCMD_LAST) != 0;\n\tret = virtscsi_add_cmd(req_vq, cmd, req_size, sizeof(cmd->resp.cmd), kick);\n\tif (ret == -EIO) {\n\t\tcmd->resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;\n\t\tspin_lock_irqsave(&req_vq->vq_lock, flags);\n\t\tvirtscsi_complete_cmd(vscsi, cmd);\n\t\tspin_unlock_irqrestore(&req_vq->vq_lock, flags);\n\t} else if (ret != 0) {\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\treturn 0;\n}\n\nstatic int virtscsi_tmf(struct virtio_scsi *vscsi, struct virtio_scsi_cmd *cmd)\n{\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tint ret = FAILED;\n\n\tcmd->comp = &comp;\n\tif (virtscsi_add_cmd(&vscsi->ctrl_vq, cmd,\n\t\t\t      sizeof cmd->req.tmf, sizeof cmd->resp.tmf, true) < 0)\n\t\tgoto out;\n\n\twait_for_completion(&comp);\n\tif (cmd->resp.tmf.response == VIRTIO_SCSI_S_OK ||\n\t    cmd->resp.tmf.response == VIRTIO_SCSI_S_FUNCTION_SUCCEEDED)\n\t\tret = SUCCESS;\n\n\t \n\tvirtscsi_poll_requests(vscsi);\n\nout:\n\tmempool_free(cmd, virtscsi_cmd_pool);\n\treturn ret;\n}\n\nstatic int virtscsi_device_reset(struct scsi_cmnd *sc)\n{\n\tstruct virtio_scsi *vscsi = shost_priv(sc->device->host);\n\tstruct virtio_scsi_cmd *cmd;\n\n\tsdev_printk(KERN_INFO, sc->device, \"device reset\\n\");\n\tcmd = mempool_alloc(virtscsi_cmd_pool, GFP_NOIO);\n\tif (!cmd)\n\t\treturn FAILED;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->req.tmf = (struct virtio_scsi_ctrl_tmf_req){\n\t\t.type = VIRTIO_SCSI_T_TMF,\n\t\t.subtype = cpu_to_virtio32(vscsi->vdev,\n\t\t\t\t\t     VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET),\n\t\t.lun[0] = 1,\n\t\t.lun[1] = sc->device->id,\n\t\t.lun[2] = (sc->device->lun >> 8) | 0x40,\n\t\t.lun[3] = sc->device->lun & 0xff,\n\t};\n\treturn virtscsi_tmf(vscsi, cmd);\n}\n\nstatic int virtscsi_device_alloc(struct scsi_device *sdevice)\n{\n\t \n\tsdevice->sdev_bflags = BLIST_TRY_VPD_PAGES;\n\n\treturn 0;\n}\n\n\n \nstatic int virtscsi_change_queue_depth(struct scsi_device *sdev, int qdepth)\n{\n\tstruct Scsi_Host *shost = sdev->host;\n\tint max_depth = shost->cmd_per_lun;\n\n\treturn scsi_change_queue_depth(sdev, min(max_depth, qdepth));\n}\n\nstatic int virtscsi_abort(struct scsi_cmnd *sc)\n{\n\tstruct virtio_scsi *vscsi = shost_priv(sc->device->host);\n\tstruct virtio_scsi_cmd *cmd;\n\n\tscmd_printk(KERN_INFO, sc, \"abort\\n\");\n\tcmd = mempool_alloc(virtscsi_cmd_pool, GFP_NOIO);\n\tif (!cmd)\n\t\treturn FAILED;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->req.tmf = (struct virtio_scsi_ctrl_tmf_req){\n\t\t.type = VIRTIO_SCSI_T_TMF,\n\t\t.subtype = VIRTIO_SCSI_T_TMF_ABORT_TASK,\n\t\t.lun[0] = 1,\n\t\t.lun[1] = sc->device->id,\n\t\t.lun[2] = (sc->device->lun >> 8) | 0x40,\n\t\t.lun[3] = sc->device->lun & 0xff,\n\t\t.tag = cpu_to_virtio64(vscsi->vdev, (unsigned long)sc),\n\t};\n\treturn virtscsi_tmf(vscsi, cmd);\n}\n\nstatic void virtscsi_map_queues(struct Scsi_Host *shost)\n{\n\tstruct virtio_scsi *vscsi = shost_priv(shost);\n\tstruct blk_mq_queue_map *qmap = &shost->tag_set.map[HCTX_TYPE_DEFAULT];\n\n\tblk_mq_virtio_map_queues(qmap, vscsi->vdev, 2);\n}\n\nstatic void virtscsi_commit_rqs(struct Scsi_Host *shost, u16 hwq)\n{\n\tstruct virtio_scsi *vscsi = shost_priv(shost);\n\n\tvirtscsi_kick_vq(&vscsi->req_vqs[hwq]);\n}\n\n \nstatic enum scsi_timeout_action virtscsi_eh_timed_out(struct scsi_cmnd *scmnd)\n{\n\treturn SCSI_EH_RESET_TIMER;\n}\n\nstatic const struct scsi_host_template virtscsi_host_template = {\n\t.module = THIS_MODULE,\n\t.name = \"Virtio SCSI HBA\",\n\t.proc_name = \"virtio_scsi\",\n\t.this_id = -1,\n\t.cmd_size = sizeof(struct virtio_scsi_cmd),\n\t.queuecommand = virtscsi_queuecommand,\n\t.commit_rqs = virtscsi_commit_rqs,\n\t.change_queue_depth = virtscsi_change_queue_depth,\n\t.eh_abort_handler = virtscsi_abort,\n\t.eh_device_reset_handler = virtscsi_device_reset,\n\t.eh_timed_out = virtscsi_eh_timed_out,\n\t.slave_alloc = virtscsi_device_alloc,\n\n\t.dma_boundary = UINT_MAX,\n\t.map_queues = virtscsi_map_queues,\n\t.track_queue_depth = 1,\n};\n\n#define virtscsi_config_get(vdev, fld) \\\n\t({ \\\n\t\t__virtio_native_type(struct virtio_scsi_config, fld) __val; \\\n\t\tvirtio_cread(vdev, struct virtio_scsi_config, fld, &__val); \\\n\t\t__val; \\\n\t})\n\n#define virtscsi_config_set(vdev, fld, val) \\\n\tdo { \\\n\t\t__virtio_native_type(struct virtio_scsi_config, fld) __val = (val); \\\n\t\tvirtio_cwrite(vdev, struct virtio_scsi_config, fld, &__val); \\\n\t} while(0)\n\nstatic void virtscsi_init_vq(struct virtio_scsi_vq *virtscsi_vq,\n\t\t\t     struct virtqueue *vq)\n{\n\tspin_lock_init(&virtscsi_vq->vq_lock);\n\tvirtscsi_vq->vq = vq;\n}\n\nstatic void virtscsi_remove_vqs(struct virtio_device *vdev)\n{\n\t \n\tvirtio_reset_device(vdev);\n\tvdev->config->del_vqs(vdev);\n}\n\nstatic int virtscsi_init(struct virtio_device *vdev,\n\t\t\t struct virtio_scsi *vscsi)\n{\n\tint err;\n\tu32 i;\n\tu32 num_vqs;\n\tvq_callback_t **callbacks;\n\tconst char **names;\n\tstruct virtqueue **vqs;\n\tstruct irq_affinity desc = { .pre_vectors = 2 };\n\n\tnum_vqs = vscsi->num_queues + VIRTIO_SCSI_VQ_BASE;\n\tvqs = kmalloc_array(num_vqs, sizeof(struct virtqueue *), GFP_KERNEL);\n\tcallbacks = kmalloc_array(num_vqs, sizeof(vq_callback_t *),\n\t\t\t\t  GFP_KERNEL);\n\tnames = kmalloc_array(num_vqs, sizeof(char *), GFP_KERNEL);\n\n\tif (!callbacks || !vqs || !names) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcallbacks[0] = virtscsi_ctrl_done;\n\tcallbacks[1] = virtscsi_event_done;\n\tnames[0] = \"control\";\n\tnames[1] = \"event\";\n\tfor (i = VIRTIO_SCSI_VQ_BASE; i < num_vqs; i++) {\n\t\tcallbacks[i] = virtscsi_req_done;\n\t\tnames[i] = \"request\";\n\t}\n\n\t \n\terr = virtio_find_vqs(vdev, num_vqs, vqs, callbacks, names, &desc);\n\tif (err)\n\t\tgoto out;\n\n\tvirtscsi_init_vq(&vscsi->ctrl_vq, vqs[0]);\n\tvirtscsi_init_vq(&vscsi->event_vq, vqs[1]);\n\tfor (i = VIRTIO_SCSI_VQ_BASE; i < num_vqs; i++)\n\t\tvirtscsi_init_vq(&vscsi->req_vqs[i - VIRTIO_SCSI_VQ_BASE],\n\t\t\t\t vqs[i]);\n\n\tvirtscsi_config_set(vdev, cdb_size, VIRTIO_SCSI_CDB_SIZE);\n\tvirtscsi_config_set(vdev, sense_size, VIRTIO_SCSI_SENSE_SIZE);\n\n\terr = 0;\n\nout:\n\tkfree(names);\n\tkfree(callbacks);\n\tkfree(vqs);\n\tif (err)\n\t\tvirtscsi_remove_vqs(vdev);\n\treturn err;\n}\n\nstatic int virtscsi_probe(struct virtio_device *vdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct virtio_scsi *vscsi;\n\tint err;\n\tu32 sg_elems, num_targets;\n\tu32 cmd_per_lun;\n\tu32 num_queues;\n\n\tif (!vdev->config->get) {\n\t\tdev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnum_queues = virtscsi_config_get(vdev, num_queues) ? : 1;\n\tnum_queues = min_t(unsigned int, nr_cpu_ids, num_queues);\n\n\tnum_targets = virtscsi_config_get(vdev, max_target) + 1;\n\n\tshost = scsi_host_alloc(&virtscsi_host_template,\n\t\t\t\tstruct_size(vscsi, req_vqs, num_queues));\n\tif (!shost)\n\t\treturn -ENOMEM;\n\n\tsg_elems = virtscsi_config_get(vdev, seg_max) ?: 1;\n\tshost->sg_tablesize = sg_elems;\n\tvscsi = shost_priv(shost);\n\tvscsi->vdev = vdev;\n\tvscsi->num_queues = num_queues;\n\tvdev->priv = shost;\n\n\terr = virtscsi_init(vdev, vscsi);\n\tif (err)\n\t\tgoto virtscsi_init_failed;\n\n\tshost->can_queue = virtqueue_get_vring_size(vscsi->req_vqs[0].vq);\n\n\tcmd_per_lun = virtscsi_config_get(vdev, cmd_per_lun) ?: 1;\n\tshost->cmd_per_lun = min_t(u32, cmd_per_lun, shost->can_queue);\n\tshost->max_sectors = virtscsi_config_get(vdev, max_sectors) ?: 0xFFFF;\n\n\t \n\tshost->max_lun = virtscsi_config_get(vdev, max_lun) + 1 + 0x4000;\n\tshost->max_id = num_targets;\n\tshost->max_channel = 0;\n\tshost->max_cmd_len = VIRTIO_SCSI_CDB_SIZE;\n\tshost->nr_hw_queues = num_queues;\n\n#ifdef CONFIG_BLK_DEV_INTEGRITY\n\tif (virtio_has_feature(vdev, VIRTIO_SCSI_F_T10_PI)) {\n\t\tint host_prot;\n\n\t\thost_prot = SHOST_DIF_TYPE1_PROTECTION | SHOST_DIF_TYPE2_PROTECTION |\n\t\t\t    SHOST_DIF_TYPE3_PROTECTION | SHOST_DIX_TYPE1_PROTECTION |\n\t\t\t    SHOST_DIX_TYPE2_PROTECTION | SHOST_DIX_TYPE3_PROTECTION;\n\n\t\tscsi_host_set_prot(shost, host_prot);\n\t\tscsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);\n\t}\n#endif\n\n\terr = scsi_add_host(shost, &vdev->dev);\n\tif (err)\n\t\tgoto scsi_add_host_failed;\n\n\tvirtio_device_ready(vdev);\n\n\tif (virtio_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG))\n\t\tvirtscsi_kick_event_all(vscsi);\n\n\tscsi_scan_host(shost);\n\treturn 0;\n\nscsi_add_host_failed:\n\tvdev->config->del_vqs(vdev);\nvirtscsi_init_failed:\n\tscsi_host_put(shost);\n\treturn err;\n}\n\nstatic void virtscsi_remove(struct virtio_device *vdev)\n{\n\tstruct Scsi_Host *shost = virtio_scsi_host(vdev);\n\tstruct virtio_scsi *vscsi = shost_priv(shost);\n\n\tif (virtio_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG))\n\t\tvirtscsi_cancel_event_work(vscsi);\n\n\tscsi_remove_host(shost);\n\tvirtscsi_remove_vqs(vdev);\n\tscsi_host_put(shost);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int virtscsi_freeze(struct virtio_device *vdev)\n{\n\tvirtscsi_remove_vqs(vdev);\n\treturn 0;\n}\n\nstatic int virtscsi_restore(struct virtio_device *vdev)\n{\n\tstruct Scsi_Host *sh = virtio_scsi_host(vdev);\n\tstruct virtio_scsi *vscsi = shost_priv(sh);\n\tint err;\n\n\terr = virtscsi_init(vdev, vscsi);\n\tif (err)\n\t\treturn err;\n\n\tvirtio_device_ready(vdev);\n\n\tif (virtio_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG))\n\t\tvirtscsi_kick_event_all(vscsi);\n\n\treturn err;\n}\n#endif\n\nstatic struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_SCSI, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic unsigned int features[] = {\n\tVIRTIO_SCSI_F_HOTPLUG,\n\tVIRTIO_SCSI_F_CHANGE,\n#ifdef CONFIG_BLK_DEV_INTEGRITY\n\tVIRTIO_SCSI_F_T10_PI,\n#endif\n};\n\nstatic struct virtio_driver virtio_scsi_driver = {\n\t.feature_table = features,\n\t.feature_table_size = ARRAY_SIZE(features),\n\t.driver.name = KBUILD_MODNAME,\n\t.driver.owner = THIS_MODULE,\n\t.id_table = id_table,\n\t.probe = virtscsi_probe,\n#ifdef CONFIG_PM_SLEEP\n\t.freeze = virtscsi_freeze,\n\t.restore = virtscsi_restore,\n#endif\n\t.remove = virtscsi_remove,\n};\n\nstatic int __init virtio_scsi_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tvirtscsi_cmd_cache = KMEM_CACHE(virtio_scsi_cmd, 0);\n\tif (!virtscsi_cmd_cache) {\n\t\tpr_err(\"kmem_cache_create() for virtscsi_cmd_cache failed\\n\");\n\t\tgoto error;\n\t}\n\n\n\tvirtscsi_cmd_pool =\n\t\tmempool_create_slab_pool(VIRTIO_SCSI_MEMPOOL_SZ,\n\t\t\t\t\t virtscsi_cmd_cache);\n\tif (!virtscsi_cmd_pool) {\n\t\tpr_err(\"mempool_create() for virtscsi_cmd_pool failed\\n\");\n\t\tgoto error;\n\t}\n\tret = register_virtio_driver(&virtio_scsi_driver);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tmempool_destroy(virtscsi_cmd_pool);\n\tvirtscsi_cmd_pool = NULL;\n\tkmem_cache_destroy(virtscsi_cmd_cache);\n\tvirtscsi_cmd_cache = NULL;\n\treturn ret;\n}\n\nstatic void __exit virtio_scsi_fini(void)\n{\n\tunregister_virtio_driver(&virtio_scsi_driver);\n\tmempool_destroy(virtscsi_cmd_pool);\n\tkmem_cache_destroy(virtscsi_cmd_cache);\n}\nmodule_init(virtio_scsi_init);\nmodule_exit(virtio_scsi_fini);\n\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_DESCRIPTION(\"Virtio SCSI HBA driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}