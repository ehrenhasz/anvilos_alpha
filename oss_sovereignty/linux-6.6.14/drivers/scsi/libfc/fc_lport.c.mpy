{
  "module_name": "fc_lport.c",
  "hash_id": "579692818b8b1b124e078c630a400b92b3ae4f6aa98393b07f827d2c24caf498",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libfc/fc_lport.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include <scsi/fc/fc_gs.h>\n\n#include <scsi/libfc.h>\n#include <linux/scatterlist.h>\n\n#include \"fc_encode.h\"\n#include \"fc_libfc.h\"\n\n \n#define FC_LOCAL_PTP_FID_LO   0x010101\n#define FC_LOCAL_PTP_FID_HI   0x010102\n\n#define\tDNS_DELAY\t\t3  \n#define\tMAX_CT_PAYLOAD\t\t2048\n#define\tDISCOVERED_PORTS\t4\n#define\tNUMBER_OF_PORTS\t\t1\n\nstatic void fc_lport_error(struct fc_lport *, struct fc_frame *);\n\nstatic void fc_lport_enter_reset(struct fc_lport *);\nstatic void fc_lport_enter_flogi(struct fc_lport *);\nstatic void fc_lport_enter_dns(struct fc_lport *);\nstatic void fc_lport_enter_ns(struct fc_lport *, enum fc_lport_state);\nstatic void fc_lport_enter_scr(struct fc_lport *);\nstatic void fc_lport_enter_ready(struct fc_lport *);\nstatic void fc_lport_enter_logo(struct fc_lport *);\nstatic void fc_lport_enter_fdmi(struct fc_lport *lport);\nstatic void fc_lport_enter_ms(struct fc_lport *, enum fc_lport_state);\n\nstatic const char *fc_lport_state_names[] = {\n\t[LPORT_ST_DISABLED] = \"disabled\",\n\t[LPORT_ST_FLOGI] =    \"FLOGI\",\n\t[LPORT_ST_DNS] =      \"dNS\",\n\t[LPORT_ST_RNN_ID] =   \"RNN_ID\",\n\t[LPORT_ST_RSNN_NN] =  \"RSNN_NN\",\n\t[LPORT_ST_RSPN_ID] =  \"RSPN_ID\",\n\t[LPORT_ST_RFT_ID] =   \"RFT_ID\",\n\t[LPORT_ST_RFF_ID] =   \"RFF_ID\",\n\t[LPORT_ST_FDMI] =     \"FDMI\",\n\t[LPORT_ST_RHBA] =     \"RHBA\",\n\t[LPORT_ST_RPA] =      \"RPA\",\n\t[LPORT_ST_DHBA] =     \"DHBA\",\n\t[LPORT_ST_DPRT] =     \"DPRT\",\n\t[LPORT_ST_SCR] =      \"SCR\",\n\t[LPORT_ST_READY] =    \"Ready\",\n\t[LPORT_ST_LOGO] =     \"LOGO\",\n\t[LPORT_ST_RESET] =    \"reset\",\n};\n\n \nstruct fc_bsg_info {\n\tstruct bsg_job *job;\n\tstruct fc_lport *lport;\n\tu16 rsp_code;\n\tstruct scatterlist *sg;\n\tu32 nents;\n\tsize_t offset;\n};\n\n \nstatic int fc_frame_drop(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tfc_frame_free(fp);\n\treturn 0;\n}\n\n \nstatic void fc_lport_rport_callback(struct fc_lport *lport,\n\t\t\t\t    struct fc_rport_priv *rdata,\n\t\t\t\t    enum fc_rport_event event)\n{\n\tFC_LPORT_DBG(lport, \"Received a %d event for port (%6.6x)\\n\", event,\n\t\t     rdata->ids.port_id);\n\n\tmutex_lock(&lport->lp_mutex);\n\tswitch (event) {\n\tcase RPORT_EV_READY:\n\t\tif (lport->state == LPORT_ST_DNS) {\n\t\t\tlport->dns_rdata = rdata;\n\t\t\tfc_lport_enter_ns(lport, LPORT_ST_RNN_ID);\n\t\t} else if (lport->state == LPORT_ST_FDMI) {\n\t\t\tlport->ms_rdata = rdata;\n\t\t\tfc_lport_enter_ms(lport, LPORT_ST_DHBA);\n\t\t} else {\n\t\t\tFC_LPORT_DBG(lport, \"Received an READY event \"\n\t\t\t\t     \"on port (%6.6x) for the directory \"\n\t\t\t\t     \"server, but the lport is not \"\n\t\t\t\t     \"in the DNS or FDMI state, it's in the \"\n\t\t\t\t     \"%d state\", rdata->ids.port_id,\n\t\t\t\t     lport->state);\n\t\t\tfc_rport_logoff(rdata);\n\t\t}\n\t\tbreak;\n\tcase RPORT_EV_LOGO:\n\tcase RPORT_EV_FAILED:\n\tcase RPORT_EV_STOP:\n\t\tif (rdata->ids.port_id == FC_FID_DIR_SERV)\n\t\t\tlport->dns_rdata = NULL;\n\t\telse if (rdata->ids.port_id == FC_FID_MGMT_SERV)\n\t\t\tlport->ms_rdata = NULL;\n\t\tbreak;\n\tcase RPORT_EV_NONE:\n\t\tbreak;\n\t}\n\tmutex_unlock(&lport->lp_mutex);\n}\n\n \nstatic const char *fc_lport_state(struct fc_lport *lport)\n{\n\tconst char *cp;\n\n\tcp = fc_lport_state_names[lport->state];\n\tif (!cp)\n\t\tcp = \"unknown\";\n\treturn cp;\n}\n\n \nstatic void fc_lport_ptp_setup(struct fc_lport *lport,\n\t\t\t       u32 remote_fid, u64 remote_wwpn,\n\t\t\t       u64 remote_wwnn)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tif (lport->ptp_rdata) {\n\t\tfc_rport_logoff(lport->ptp_rdata);\n\t\tkref_put(&lport->ptp_rdata->kref, fc_rport_destroy);\n\t}\n\tmutex_lock(&lport->disc.disc_mutex);\n\tlport->ptp_rdata = fc_rport_create(lport, remote_fid);\n\tif (!lport->ptp_rdata) {\n\t\tprintk(KERN_WARNING \"libfc: Failed to setup lport 0x%x\\n\",\n\t\t\tlport->port_id);\n\t\tmutex_unlock(&lport->disc.disc_mutex);\n\t\treturn;\n\t}\n\tkref_get(&lport->ptp_rdata->kref);\n\tlport->ptp_rdata->ids.port_name = remote_wwpn;\n\tlport->ptp_rdata->ids.node_name = remote_wwnn;\n\tmutex_unlock(&lport->disc.disc_mutex);\n\n\tfc_rport_login(lport->ptp_rdata);\n\n\tfc_lport_enter_ready(lport);\n}\n\n \nvoid fc_get_host_port_state(struct Scsi_Host *shost)\n{\n\tstruct fc_lport *lport = shost_priv(shost);\n\n\tmutex_lock(&lport->lp_mutex);\n\tif (!lport->link_up)\n\t\tfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\n\telse\n\t\tswitch (lport->state) {\n\t\tcase LPORT_ST_READY:\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfc_host_port_state(shost) = FC_PORTSTATE_OFFLINE;\n\t\t}\n\tmutex_unlock(&lport->lp_mutex);\n}\nEXPORT_SYMBOL(fc_get_host_port_state);\n\n \nvoid fc_get_host_speed(struct Scsi_Host *shost)\n{\n\tstruct fc_lport *lport = shost_priv(shost);\n\n\tfc_host_speed(shost) = lport->link_speed;\n}\nEXPORT_SYMBOL(fc_get_host_speed);\n\n \nstruct fc_host_statistics *fc_get_host_stats(struct Scsi_Host *shost)\n{\n\tstruct fc_host_statistics *fc_stats;\n\tstruct fc_lport *lport = shost_priv(shost);\n\tunsigned int cpu;\n\tu64 fcp_in_bytes = 0;\n\tu64 fcp_out_bytes = 0;\n\n\tfc_stats = &lport->host_stats;\n\tmemset(fc_stats, 0, sizeof(struct fc_host_statistics));\n\n\tfc_stats->seconds_since_last_reset = (jiffies - lport->boot_time) / HZ;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct fc_stats *stats;\n\n\t\tstats = per_cpu_ptr(lport->stats, cpu);\n\n\t\tfc_stats->tx_frames += READ_ONCE(stats->TxFrames);\n\t\tfc_stats->tx_words += READ_ONCE(stats->TxWords);\n\t\tfc_stats->rx_frames += READ_ONCE(stats->RxFrames);\n\t\tfc_stats->rx_words += READ_ONCE(stats->RxWords);\n\t\tfc_stats->error_frames += READ_ONCE(stats->ErrorFrames);\n\t\tfc_stats->invalid_crc_count += READ_ONCE(stats->InvalidCRCCount);\n\t\tfc_stats->fcp_input_requests += READ_ONCE(stats->InputRequests);\n\t\tfc_stats->fcp_output_requests += READ_ONCE(stats->OutputRequests);\n\t\tfc_stats->fcp_control_requests += READ_ONCE(stats->ControlRequests);\n\t\tfcp_in_bytes += READ_ONCE(stats->InputBytes);\n\t\tfcp_out_bytes += READ_ONCE(stats->OutputBytes);\n\t\tfc_stats->fcp_packet_alloc_failures += READ_ONCE(stats->FcpPktAllocFails);\n\t\tfc_stats->fcp_packet_aborts += READ_ONCE(stats->FcpPktAborts);\n\t\tfc_stats->fcp_frame_alloc_failures += READ_ONCE(stats->FcpFrameAllocFails);\n\t\tfc_stats->link_failure_count += READ_ONCE(stats->LinkFailureCount);\n\t}\n\tfc_stats->fcp_input_megabytes = div_u64(fcp_in_bytes, 1000000);\n\tfc_stats->fcp_output_megabytes = div_u64(fcp_out_bytes, 1000000);\n\tfc_stats->lip_count = -1;\n\tfc_stats->nos_count = -1;\n\tfc_stats->loss_of_sync_count = -1;\n\tfc_stats->loss_of_signal_count = -1;\n\tfc_stats->prim_seq_protocol_err_count = -1;\n\tfc_stats->dumped_frames = -1;\n\n\t \n\tfc_exch_update_stats(lport);\n\n\treturn fc_stats;\n}\nEXPORT_SYMBOL(fc_get_host_stats);\n\n \nstatic void fc_lport_flogi_fill(struct fc_lport *lport,\n\t\t\t\tstruct fc_els_flogi *flogi,\n\t\t\t\tunsigned int op)\n{\n\tstruct fc_els_csp *sp;\n\tstruct fc_els_cssp *cp;\n\n\tmemset(flogi, 0, sizeof(*flogi));\n\tflogi->fl_cmd = (u8) op;\n\tput_unaligned_be64(lport->wwpn, &flogi->fl_wwpn);\n\tput_unaligned_be64(lport->wwnn, &flogi->fl_wwnn);\n\tsp = &flogi->fl_csp;\n\tsp->sp_hi_ver = 0x20;\n\tsp->sp_lo_ver = 0x20;\n\tsp->sp_bb_cred = htons(10);\t \n\tsp->sp_bb_data = htons((u16) lport->mfs);\n\tcp = &flogi->fl_cssp[3 - 1];\t \n\tcp->cp_class = htons(FC_CPC_VALID | FC_CPC_SEQ);\n\tif (op != ELS_FLOGI) {\n\t\tsp->sp_features = htons(FC_SP_FT_CIRO);\n\t\tsp->sp_tot_seq = htons(255);\t \n\t\tsp->sp_rel_off = htons(0x1f);\n\t\tsp->sp_e_d_tov = htonl(lport->e_d_tov);\n\n\t\tcp->cp_rdfs = htons((u16) lport->mfs);\n\t\tcp->cp_con_seq = htons(255);\n\t\tcp->cp_open_seq = 1;\n\t}\n}\n\n \nstatic void fc_lport_add_fc4_type(struct fc_lport *lport, enum fc_fh_type type)\n{\n\t__be32 *mp;\n\n\tmp = &lport->fcts.ff_type_map[type / FC_NS_BPW];\n\t*mp = htonl(ntohl(*mp) | 1UL << (type % FC_NS_BPW));\n}\n\n \nstatic void fc_lport_recv_rlir_req(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Received RLIR request while in state %s\\n\",\n\t\t     fc_lport_state(lport));\n\n\tfc_seq_els_rsp_send(fp, ELS_LS_ACC, NULL);\n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_lport_recv_echo_req(struct fc_lport *lport,\n\t\t\t\t   struct fc_frame *in_fp)\n{\n\tstruct fc_frame *fp;\n\tunsigned int len;\n\tvoid *pp;\n\tvoid *dp;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Received ECHO request while in state %s\\n\",\n\t\t     fc_lport_state(lport));\n\n\tlen = fr_len(in_fp) - sizeof(struct fc_frame_header);\n\tpp = fc_frame_payload_get(in_fp, len);\n\n\tif (len < sizeof(__be32))\n\t\tlen = sizeof(__be32);\n\n\tfp = fc_frame_alloc(lport, len);\n\tif (fp) {\n\t\tdp = fc_frame_payload_get(fp, len);\n\t\tmemcpy(dp, pp, len);\n\t\t*((__be32 *)dp) = htonl(ELS_LS_ACC << 24);\n\t\tfc_fill_reply_hdr(fp, in_fp, FC_RCTL_ELS_REP, 0);\n\t\tlport->tt.frame_send(lport, fp);\n\t}\n\tfc_frame_free(in_fp);\n}\n\n \nstatic void fc_lport_recv_rnid_req(struct fc_lport *lport,\n\t\t\t\t   struct fc_frame *in_fp)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_els_rnid *req;\n\tstruct {\n\t\tstruct fc_els_rnid_resp rnid;\n\t\tstruct fc_els_rnid_cid cid;\n\t\tstruct fc_els_rnid_gen gen;\n\t} *rp;\n\tstruct fc_seq_els_data rjt_data;\n\tu8 fmt;\n\tsize_t len;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Received RNID request while in state %s\\n\",\n\t\t     fc_lport_state(lport));\n\n\treq = fc_frame_payload_get(in_fp, sizeof(*req));\n\tif (!req) {\n\t\trjt_data.reason = ELS_RJT_LOGIC;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tfc_seq_els_rsp_send(in_fp, ELS_LS_RJT, &rjt_data);\n\t} else {\n\t\tfmt = req->rnid_fmt;\n\t\tlen = sizeof(*rp);\n\t\tif (fmt != ELS_RNIDF_GEN ||\n\t\t    ntohl(lport->rnid_gen.rnid_atype) == 0) {\n\t\t\tfmt = ELS_RNIDF_NONE;\t \n\t\t\tlen -= sizeof(rp->gen);\n\t\t}\n\t\tfp = fc_frame_alloc(lport, len);\n\t\tif (fp) {\n\t\t\trp = fc_frame_payload_get(fp, len);\n\t\t\tmemset(rp, 0, len);\n\t\t\trp->rnid.rnid_cmd = ELS_LS_ACC;\n\t\t\trp->rnid.rnid_fmt = fmt;\n\t\t\trp->rnid.rnid_cid_len = sizeof(rp->cid);\n\t\t\trp->cid.rnid_wwpn = htonll(lport->wwpn);\n\t\t\trp->cid.rnid_wwnn = htonll(lport->wwnn);\n\t\t\tif (fmt == ELS_RNIDF_GEN) {\n\t\t\t\trp->rnid.rnid_sid_len = sizeof(rp->gen);\n\t\t\t\tmemcpy(&rp->gen, &lport->rnid_gen,\n\t\t\t\t       sizeof(rp->gen));\n\t\t\t}\n\t\t\tfc_fill_reply_hdr(fp, in_fp, FC_RCTL_ELS_REP, 0);\n\t\t\tlport->tt.frame_send(lport, fp);\n\t\t}\n\t}\n\tfc_frame_free(in_fp);\n}\n\n \nstatic void fc_lport_recv_logo_req(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tfc_seq_els_rsp_send(fp, ELS_LS_ACC, NULL);\n\tfc_lport_enter_reset(lport);\n\tfc_frame_free(fp);\n}\n\n \nint fc_fabric_login(struct fc_lport *lport)\n{\n\tint rc = -1;\n\n\tmutex_lock(&lport->lp_mutex);\n\tif (lport->state == LPORT_ST_DISABLED ||\n\t    lport->state == LPORT_ST_LOGO) {\n\t\tfc_lport_state_enter(lport, LPORT_ST_RESET);\n\t\tfc_lport_enter_reset(lport);\n\t\trc = 0;\n\t}\n\tmutex_unlock(&lport->lp_mutex);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(fc_fabric_login);\n\n \nvoid __fc_linkup(struct fc_lport *lport)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tif (!lport->link_up) {\n\t\tlport->link_up = 1;\n\n\t\tif (lport->state == LPORT_ST_RESET)\n\t\t\tfc_lport_enter_flogi(lport);\n\t}\n}\n\n \nvoid fc_linkup(struct fc_lport *lport)\n{\n\tprintk(KERN_INFO \"host%d: libfc: Link up on port (%6.6x)\\n\",\n\t       lport->host->host_no, lport->port_id);\n\n\tmutex_lock(&lport->lp_mutex);\n\t__fc_linkup(lport);\n\tmutex_unlock(&lport->lp_mutex);\n}\nEXPORT_SYMBOL(fc_linkup);\n\n \nvoid __fc_linkdown(struct fc_lport *lport)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tif (lport->link_up) {\n\t\tlport->link_up = 0;\n\t\tfc_lport_enter_reset(lport);\n\t\tlport->tt.fcp_cleanup(lport);\n\t}\n}\n\n \nvoid fc_linkdown(struct fc_lport *lport)\n{\n\tprintk(KERN_INFO \"host%d: libfc: Link down on port (%6.6x)\\n\",\n\t       lport->host->host_no, lport->port_id);\n\n\tmutex_lock(&lport->lp_mutex);\n\t__fc_linkdown(lport);\n\tmutex_unlock(&lport->lp_mutex);\n}\nEXPORT_SYMBOL(fc_linkdown);\n\n \nint fc_fabric_logoff(struct fc_lport *lport)\n{\n\tlport->tt.disc_stop_final(lport);\n\tmutex_lock(&lport->lp_mutex);\n\tif (lport->dns_rdata)\n\t\tfc_rport_logoff(lport->dns_rdata);\n\tmutex_unlock(&lport->lp_mutex);\n\tfc_rport_flush_queue();\n\tmutex_lock(&lport->lp_mutex);\n\tfc_lport_enter_logo(lport);\n\tmutex_unlock(&lport->lp_mutex);\n\tcancel_delayed_work_sync(&lport->retry_work);\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_fabric_logoff);\n\n \nint fc_lport_destroy(struct fc_lport *lport)\n{\n\tmutex_lock(&lport->lp_mutex);\n\tlport->state = LPORT_ST_DISABLED;\n\tlport->link_up = 0;\n\tlport->tt.frame_send = fc_frame_drop;\n\tmutex_unlock(&lport->lp_mutex);\n\n\tlport->tt.fcp_abort_io(lport);\n\tlport->tt.disc_stop_final(lport);\n\tlport->tt.exch_mgr_reset(lport, 0, 0);\n\tcancel_delayed_work_sync(&lport->retry_work);\n\tfc_fc4_del_lport(lport);\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_lport_destroy);\n\n \nint fc_set_mfs(struct fc_lport *lport, u32 mfs)\n{\n\tunsigned int old_mfs;\n\tint rc = -EINVAL;\n\n\tmutex_lock(&lport->lp_mutex);\n\n\told_mfs = lport->mfs;\n\n\tif (mfs >= FC_MIN_MAX_FRAME) {\n\t\tmfs &= ~3;\n\t\tif (mfs > FC_MAX_FRAME)\n\t\t\tmfs = FC_MAX_FRAME;\n\t\tmfs -= sizeof(struct fc_frame_header);\n\t\tlport->mfs = mfs;\n\t\trc = 0;\n\t}\n\n\tif (!rc && mfs < old_mfs)\n\t\tfc_lport_enter_reset(lport);\n\n\tmutex_unlock(&lport->lp_mutex);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(fc_set_mfs);\n\n \nstatic void fc_lport_disc_callback(struct fc_lport *lport,\n\t\t\t\t   enum fc_disc_event event)\n{\n\tswitch (event) {\n\tcase DISC_EV_SUCCESS:\n\t\tFC_LPORT_DBG(lport, \"Discovery succeeded\\n\");\n\t\tbreak;\n\tcase DISC_EV_FAILED:\n\t\tprintk(KERN_ERR \"host%d: libfc: \"\n\t\t       \"Discovery failed for port (%6.6x)\\n\",\n\t\t       lport->host->host_no, lport->port_id);\n\t\tmutex_lock(&lport->lp_mutex);\n\t\tfc_lport_enter_reset(lport);\n\t\tmutex_unlock(&lport->lp_mutex);\n\t\tbreak;\n\tcase DISC_EV_NONE:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\n \nstatic void fc_lport_enter_ready(struct fc_lport *lport)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered READY from state %s\\n\",\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, LPORT_ST_READY);\n\tif (lport->vport)\n\t\tfc_vport_set_state(lport->vport, FC_VPORT_ACTIVE);\n\tfc_vports_linkchange(lport);\n\n\tif (!lport->ptp_rdata)\n\t\tlport->tt.disc_start(fc_lport_disc_callback, lport);\n}\n\n \nstatic void fc_lport_set_port_id(struct fc_lport *lport, u32 port_id,\n\t\t\t\t struct fc_frame *fp)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tif (port_id)\n\t\tprintk(KERN_INFO \"host%d: Assigned Port ID %6.6x\\n\",\n\t\t       lport->host->host_no, port_id);\n\n\tlport->port_id = port_id;\n\n\t \n\tfc_host_port_id(lport->host) = port_id;\n\n\tif (lport->tt.lport_set_port_id)\n\t\tlport->tt.lport_set_port_id(lport, port_id, fp);\n}\n\n \nvoid fc_lport_set_local_id(struct fc_lport *lport, u32 port_id)\n{\n\tmutex_lock(&lport->lp_mutex);\n\n\tfc_lport_set_port_id(lport, port_id, NULL);\n\n\tswitch (lport->state) {\n\tcase LPORT_ST_RESET:\n\tcase LPORT_ST_FLOGI:\n\t\tif (port_id)\n\t\t\tfc_lport_enter_ready(lport);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&lport->lp_mutex);\n}\nEXPORT_SYMBOL(fc_lport_set_local_id);\n\n \nstatic void fc_lport_recv_flogi_req(struct fc_lport *lport,\n\t\t\t\t    struct fc_frame *rx_fp)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_frame_header *fh;\n\tstruct fc_els_flogi *flp;\n\tstruct fc_els_flogi *new_flp;\n\tu64 remote_wwpn;\n\tu32 remote_fid;\n\tu32 local_fid;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Received FLOGI request while in state %s\\n\",\n\t\t     fc_lport_state(lport));\n\n\tremote_fid = fc_frame_sid(rx_fp);\n\tflp = fc_frame_payload_get(rx_fp, sizeof(*flp));\n\tif (!flp)\n\t\tgoto out;\n\tremote_wwpn = get_unaligned_be64(&flp->fl_wwpn);\n\tif (remote_wwpn == lport->wwpn) {\n\t\tprintk(KERN_WARNING \"host%d: libfc: Received FLOGI from port \"\n\t\t       \"with same WWPN %16.16llx\\n\",\n\t\t       lport->host->host_no, remote_wwpn);\n\t\tgoto out;\n\t}\n\tFC_LPORT_DBG(lport, \"FLOGI from port WWPN %16.16llx\\n\", remote_wwpn);\n\n\t \n\tlocal_fid = FC_LOCAL_PTP_FID_LO;\n\tif (remote_wwpn < lport->wwpn) {\n\t\tlocal_fid = FC_LOCAL_PTP_FID_HI;\n\t\tif (!remote_fid || remote_fid == local_fid)\n\t\t\tremote_fid = FC_LOCAL_PTP_FID_LO;\n\t} else if (!remote_fid) {\n\t\tremote_fid = FC_LOCAL_PTP_FID_HI;\n\t}\n\n\tfc_lport_set_port_id(lport, local_fid, rx_fp);\n\n\tfp = fc_frame_alloc(lport, sizeof(*flp));\n\tif (fp) {\n\t\tnew_flp = fc_frame_payload_get(fp, sizeof(*flp));\n\t\tfc_lport_flogi_fill(lport, new_flp, ELS_FLOGI);\n\t\tnew_flp->fl_cmd = (u8) ELS_LS_ACC;\n\n\t\t \n\t\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\n\t\tfh = fc_frame_header_get(fp);\n\t\thton24(fh->fh_s_id, local_fid);\n\t\thton24(fh->fh_d_id, remote_fid);\n\t\tlport->tt.frame_send(lport, fp);\n\n\t} else {\n\t\tfc_lport_error(lport, fp);\n\t}\n\tfc_lport_ptp_setup(lport, remote_fid, remote_wwpn,\n\t\t\t   get_unaligned_be64(&flp->fl_wwnn));\nout:\n\tfc_frame_free(rx_fp);\n}\n\n \nstatic void fc_lport_recv_els_req(struct fc_lport *lport,\n\t\t\t\t  struct fc_frame *fp)\n{\n\tmutex_lock(&lport->lp_mutex);\n\n\t \n\tif (!lport->link_up)\n\t\tfc_frame_free(fp);\n\telse {\n\t\t \n\t\tswitch (fc_frame_payload_op(fp)) {\n\t\tcase ELS_FLOGI:\n\t\t\tif (!lport->point_to_multipoint)\n\t\t\t\tfc_lport_recv_flogi_req(lport, fp);\n\t\t\telse\n\t\t\t\tfc_rport_recv_req(lport, fp);\n\t\t\tbreak;\n\t\tcase ELS_LOGO:\n\t\t\tif (fc_frame_sid(fp) == FC_FID_FLOGI)\n\t\t\t\tfc_lport_recv_logo_req(lport, fp);\n\t\t\telse\n\t\t\t\tfc_rport_recv_req(lport, fp);\n\t\t\tbreak;\n\t\tcase ELS_RSCN:\n\t\t\tlport->tt.disc_recv_req(lport, fp);\n\t\t\tbreak;\n\t\tcase ELS_ECHO:\n\t\t\tfc_lport_recv_echo_req(lport, fp);\n\t\t\tbreak;\n\t\tcase ELS_RLIR:\n\t\t\tfc_lport_recv_rlir_req(lport, fp);\n\t\t\tbreak;\n\t\tcase ELS_RNID:\n\t\t\tfc_lport_recv_rnid_req(lport, fp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfc_rport_recv_req(lport, fp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&lport->lp_mutex);\n}\n\nstatic int fc_lport_els_prli(struct fc_rport_priv *rdata, u32 spp_len,\n\t\t\t     const struct fc_els_spp *spp_in,\n\t\t\t     struct fc_els_spp *spp_out)\n{\n\treturn FC_SPP_RESP_INVL;\n}\n\nstruct fc4_prov fc_lport_els_prov = {\n\t.prli = fc_lport_els_prli,\n\t.recv = fc_lport_recv_els_req,\n};\n\n \nvoid fc_lport_recv(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tstruct fc_seq *sp = fr_seq(fp);\n\tstruct fc4_prov *prov;\n\n\t \n\n\trcu_read_lock();\n\tif (fh->fh_type >= FC_FC4_PROV_SIZE)\n\t\tgoto drop;\n\tprov = rcu_dereference(fc_passive_prov[fh->fh_type]);\n\tif (!prov || !try_module_get(prov->module))\n\t\tgoto drop;\n\trcu_read_unlock();\n\tprov->recv(lport, fp);\n\tmodule_put(prov->module);\n\treturn;\ndrop:\n\trcu_read_unlock();\n\tFC_LPORT_DBG(lport, \"dropping unexpected frame type %x\\n\", fh->fh_type);\n\tfc_frame_free(fp);\n\tif (sp)\n\t\tfc_exch_done(sp);\n}\nEXPORT_SYMBOL(fc_lport_recv);\n\n \nint fc_lport_reset(struct fc_lport *lport)\n{\n\tcancel_delayed_work_sync(&lport->retry_work);\n\tmutex_lock(&lport->lp_mutex);\n\tfc_lport_enter_reset(lport);\n\tmutex_unlock(&lport->lp_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_lport_reset);\n\n \nstatic void fc_lport_reset_locked(struct fc_lport *lport)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tif (lport->dns_rdata) {\n\t\tfc_rport_logoff(lport->dns_rdata);\n\t\tlport->dns_rdata = NULL;\n\t}\n\n\tif (lport->ptp_rdata) {\n\t\tfc_rport_logoff(lport->ptp_rdata);\n\t\tkref_put(&lport->ptp_rdata->kref, fc_rport_destroy);\n\t\tlport->ptp_rdata = NULL;\n\t}\n\n\tlport->tt.disc_stop(lport);\n\n\tlport->tt.exch_mgr_reset(lport, 0, 0);\n\tfc_host_fabric_name(lport->host) = 0;\n\n\tif (lport->port_id && (!lport->point_to_multipoint || !lport->link_up))\n\t\tfc_lport_set_port_id(lport, 0, NULL);\n}\n\n \nstatic void fc_lport_enter_reset(struct fc_lport *lport)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered RESET state from %s state\\n\",\n\t\t     fc_lport_state(lport));\n\n\tif (lport->state == LPORT_ST_DISABLED || lport->state == LPORT_ST_LOGO)\n\t\treturn;\n\n\tif (lport->vport) {\n\t\tif (lport->link_up)\n\t\t\tfc_vport_set_state(lport->vport, FC_VPORT_INITIALIZING);\n\t\telse\n\t\t\tfc_vport_set_state(lport->vport, FC_VPORT_LINKDOWN);\n\t}\n\tfc_lport_state_enter(lport, LPORT_ST_RESET);\n\tfc_host_post_event(lport->host, fc_get_event_number(),\n\t\t\t   FCH_EVT_LIPRESET, 0);\n\tfc_vports_linkchange(lport);\n\tfc_lport_reset_locked(lport);\n\tif (lport->link_up)\n\t\tfc_lport_enter_flogi(lport);\n}\n\n \nstatic void fc_lport_enter_disabled(struct fc_lport *lport)\n{\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered disabled state from %s state\\n\",\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, LPORT_ST_DISABLED);\n\tfc_vports_linkchange(lport);\n\tfc_lport_reset_locked(lport);\n}\n\n \nstatic void fc_lport_error(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tunsigned long delay = 0;\n\tFC_LPORT_DBG(lport, \"Error %ld in state %s, retries %d\\n\",\n\t\t     IS_ERR(fp) ? -PTR_ERR(fp) : 0, fc_lport_state(lport),\n\t\t     lport->retry_count);\n\n\tif (PTR_ERR(fp) == -FC_EX_CLOSED)\n\t\treturn;\n\n\t \n\tif (lport->retry_count < lport->max_retry_count) {\n\t\tlport->retry_count++;\n\t\tif (!fp)\n\t\t\tdelay = msecs_to_jiffies(500);\n\t\telse\n\t\t\tdelay =\tmsecs_to_jiffies(lport->e_d_tov);\n\n\t\tschedule_delayed_work(&lport->retry_work, delay);\n\t} else\n\t\tfc_lport_enter_reset(lport);\n}\n\n \nstatic void fc_lport_ns_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t     void *lp_arg)\n{\n\tstruct fc_lport *lport = lp_arg;\n\tstruct fc_frame_header *fh;\n\tstruct fc_ct_hdr *ct;\n\n\tFC_LPORT_DBG(lport, \"Received a ns %s\\n\", fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\treturn;\n\n\tmutex_lock(&lport->lp_mutex);\n\n\tif (lport->state < LPORT_ST_RNN_ID || lport->state > LPORT_ST_RFF_ID) {\n\t\tFC_LPORT_DBG(lport, \"Received a name server response, \"\n\t\t\t     \"but in state %s\\n\", fc_lport_state(lport));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_lport_error(lport, fp);\n\t\tgoto err;\n\t}\n\n\tfh = fc_frame_header_get(fp);\n\tct = fc_frame_payload_get(fp, sizeof(*ct));\n\n\tif (fh && ct && fh->fh_type == FC_TYPE_CT &&\n\t    ct->ct_fs_type == FC_FST_DIR &&\n\t    ct->ct_fs_subtype == FC_NS_SUBTYPE &&\n\t    ntohs(ct->ct_cmd) == FC_FS_ACC)\n\t\tswitch (lport->state) {\n\t\tcase LPORT_ST_RNN_ID:\n\t\t\tfc_lport_enter_ns(lport, LPORT_ST_RSNN_NN);\n\t\t\tbreak;\n\t\tcase LPORT_ST_RSNN_NN:\n\t\t\tfc_lport_enter_ns(lport, LPORT_ST_RSPN_ID);\n\t\t\tbreak;\n\t\tcase LPORT_ST_RSPN_ID:\n\t\t\tfc_lport_enter_ns(lport, LPORT_ST_RFT_ID);\n\t\t\tbreak;\n\t\tcase LPORT_ST_RFT_ID:\n\t\t\tfc_lport_enter_ns(lport, LPORT_ST_RFF_ID);\n\t\t\tbreak;\n\t\tcase LPORT_ST_RFF_ID:\n\t\t\tif (lport->fdmi_enabled)\n\t\t\t\tfc_lport_enter_fdmi(lport);\n\t\t\telse\n\t\t\t\tfc_lport_enter_scr(lport);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\telse\n\t\tfc_lport_error(lport, fp);\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&lport->lp_mutex);\n}\n\n \nstatic void fc_lport_ms_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t     void *lp_arg)\n{\n\tstruct fc_lport *lport = lp_arg;\n\tstruct fc_frame_header *fh;\n\tstruct fc_ct_hdr *ct;\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(lport->host);\n\tFC_LPORT_DBG(lport, \"Received a ms %s\\n\", fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\treturn;\n\n\tmutex_lock(&lport->lp_mutex);\n\n\tif (lport->state < LPORT_ST_RHBA || lport->state > LPORT_ST_DPRT) {\n\t\tFC_LPORT_DBG(lport, \"Received a management server response, \"\n\t\t\t     \"but in state %s\\n\", fc_lport_state(lport));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_lport_error(lport, fp);\n\t\tgoto err;\n\t}\n\n\tfh = fc_frame_header_get(fp);\n\tct = fc_frame_payload_get(fp, sizeof(*ct));\n\n\tif (fh && ct && fh->fh_type == FC_TYPE_CT &&\n\t    ct->ct_fs_type == FC_FST_MGMT &&\n\t    ct->ct_fs_subtype == FC_FDMI_SUBTYPE) {\n\t\tFC_LPORT_DBG(lport, \"Received a management server response, \"\n\t\t\t\t    \"reason=%d explain=%d\\n\",\n\t\t\t\t    ct->ct_reason,\n\t\t\t\t    ct->ct_explan);\n\n\t\tswitch (lport->state) {\n\t\tcase LPORT_ST_RHBA:\n\t\t\tif ((ntohs(ct->ct_cmd) == FC_FS_RJT) && fc_host->fdmi_version == FDMI_V2) {\n\t\t\t\tFC_LPORT_DBG(lport, \"Error for FDMI-V2, fall back to FDMI-V1\\n\");\n\t\t\t\tfc_host->fdmi_version = FDMI_V1;\n\n\t\t\t\tfc_lport_enter_ms(lport, LPORT_ST_RHBA);\n\n\t\t\t} else if (ntohs(ct->ct_cmd) == FC_FS_ACC)\n\t\t\t\tfc_lport_enter_ms(lport, LPORT_ST_RPA);\n\t\t\telse  \n\t\t\t\tfc_lport_enter_scr(lport);\n\t\t\tbreak;\n\t\tcase LPORT_ST_RPA:\n\t\t\tfc_lport_enter_scr(lport);\n\t\t\tbreak;\n\t\tcase LPORT_ST_DPRT:\n\t\t\tfc_lport_enter_ms(lport, LPORT_ST_RHBA);\n\t\t\tbreak;\n\t\tcase LPORT_ST_DHBA:\n\t\t\tfc_lport_enter_ms(lport, LPORT_ST_DPRT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tfc_lport_error(lport, fp);\n\t}\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&lport->lp_mutex);\n}\n\n \nstatic void fc_lport_scr_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t      void *lp_arg)\n{\n\tstruct fc_lport *lport = lp_arg;\n\tu8 op;\n\n\tFC_LPORT_DBG(lport, \"Received a SCR %s\\n\", fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\treturn;\n\n\tmutex_lock(&lport->lp_mutex);\n\n\tif (lport->state != LPORT_ST_SCR) {\n\t\tFC_LPORT_DBG(lport, \"Received a SCR response, but in state \"\n\t\t\t     \"%s\\n\", fc_lport_state(lport));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_lport_error(lport, fp);\n\t\tgoto err;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC)\n\t\tfc_lport_enter_ready(lport);\n\telse\n\t\tfc_lport_error(lport, fp);\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&lport->lp_mutex);\n}\n\n \nstatic void fc_lport_enter_scr(struct fc_lport *lport)\n{\n\tstruct fc_frame *fp;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered SCR state from %s state\\n\",\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, LPORT_ST_SCR);\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_scr));\n\tif (!fp) {\n\t\tfc_lport_error(lport, fp);\n\t\treturn;\n\t}\n\n\tif (!lport->tt.elsct_send(lport, FC_FID_FCTRL, fp, ELS_SCR,\n\t\t\t\t  fc_lport_scr_resp, lport,\n\t\t\t\t  2 * lport->r_a_tov))\n\t\tfc_lport_error(lport, NULL);\n}\n\n \nstatic void fc_lport_enter_ns(struct fc_lport *lport, enum fc_lport_state state)\n{\n\tstruct fc_frame *fp;\n\tenum fc_ns_req cmd;\n\tint size = sizeof(struct fc_ct_hdr);\n\tsize_t len;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered %s state from %s state\\n\",\n\t\t     fc_lport_state_names[state],\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, state);\n\n\tswitch (state) {\n\tcase LPORT_ST_RNN_ID:\n\t\tcmd = FC_NS_RNN_ID;\n\t\tsize += sizeof(struct fc_ns_rn_id);\n\t\tbreak;\n\tcase LPORT_ST_RSNN_NN:\n\t\tlen = strnlen(fc_host_symbolic_name(lport->host), 255);\n\t\t \n\t\tif (!len)\n\t\t\treturn fc_lport_enter_ns(lport, LPORT_ST_RFT_ID);\n\t\tcmd = FC_NS_RSNN_NN;\n\t\tsize += sizeof(struct fc_ns_rsnn) + len;\n\t\tbreak;\n\tcase LPORT_ST_RSPN_ID:\n\t\tlen = strnlen(fc_host_symbolic_name(lport->host), 255);\n\t\t \n\t\tif (!len)\n\t\t\treturn fc_lport_enter_ns(lport, LPORT_ST_RFT_ID);\n\t\tcmd = FC_NS_RSPN_ID;\n\t\tsize += sizeof(struct fc_ns_rspn) + len;\n\t\tbreak;\n\tcase LPORT_ST_RFT_ID:\n\t\tcmd = FC_NS_RFT_ID;\n\t\tsize += sizeof(struct fc_ns_rft);\n\t\tbreak;\n\tcase LPORT_ST_RFF_ID:\n\t\tcmd = FC_NS_RFF_ID;\n\t\tsize += sizeof(struct fc_ns_rff_id);\n\t\tbreak;\n\tdefault:\n\t\tfc_lport_error(lport, NULL);\n\t\treturn;\n\t}\n\n\tfp = fc_frame_alloc(lport, size);\n\tif (!fp) {\n\t\tfc_lport_error(lport, fp);\n\t\treturn;\n\t}\n\n\tif (!lport->tt.elsct_send(lport, FC_FID_DIR_SERV, fp, cmd,\n\t\t\t\t  fc_lport_ns_resp,\n\t\t\t\t  lport, 3 * lport->r_a_tov))\n\t\tfc_lport_error(lport, fp);\n}\n\nstatic struct fc_rport_operations fc_lport_rport_ops = {\n\t.event_callback = fc_lport_rport_callback,\n};\n\n \nstatic void fc_lport_enter_dns(struct fc_lport *lport)\n{\n\tstruct fc_rport_priv *rdata;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered DNS state from %s state\\n\",\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, LPORT_ST_DNS);\n\n\tmutex_lock(&lport->disc.disc_mutex);\n\trdata = fc_rport_create(lport, FC_FID_DIR_SERV);\n\tmutex_unlock(&lport->disc.disc_mutex);\n\tif (!rdata)\n\t\tgoto err;\n\n\trdata->ops = &fc_lport_rport_ops;\n\tfc_rport_login(rdata);\n\treturn;\n\nerr:\n\tfc_lport_error(lport, NULL);\n}\n\n \nstatic void fc_lport_enter_ms(struct fc_lport *lport, enum fc_lport_state state)\n{\n\tstruct fc_frame *fp;\n\tenum fc_fdmi_req cmd;\n\tint size = sizeof(struct fc_ct_hdr);\n\tsize_t len;\n\tint numattrs;\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(lport->host);\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered %s state from %s state\\n\",\n\t\t     fc_lport_state_names[state],\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, state);\n\n\tswitch (state) {\n\tcase LPORT_ST_RHBA:\n\t\tcmd = FC_FDMI_RHBA;\n\t\t \n\t\tnumattrs = 11;\n\t\tlen = sizeof(struct fc_fdmi_rhba);\n\t\tlen -= sizeof(struct fc_fdmi_attr_entry);\n\n\t\tlen += FC_FDMI_HBA_ATTR_NODENAME_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MANUFACTURER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_SERIALNUMBER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MODEL_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MODELDESCR_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_HARDWAREVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_DRIVERVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_OPTIONROMVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_FIRMWAREVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_OSNAMEVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MAXCTPAYLOAD_LEN;\n\n\n\t\tif (fc_host->fdmi_version == FDMI_V2) {\n\t\t\tnumattrs += 7;\n\t\t\tlen += FC_FDMI_HBA_ATTR_NODESYMBLNAME_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_VENDORSPECIFICINFO_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_NUMBEROFPORTS_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_FABRICNAME_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_BIOSVERSION_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_BIOSSTATE_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_VENDORIDENTIFIER_LEN;\n\t\t}\n\n\t\tlen += (numattrs * FC_FDMI_ATTR_ENTRY_HEADER_LEN);\n\n\t\tsize += len;\n\t\tbreak;\n\tcase LPORT_ST_RPA:\n\t\tcmd = FC_FDMI_RPA;\n\t\t \n\t\tnumattrs = 6;\n\t\tlen = sizeof(struct fc_fdmi_rpa);\n\t\tlen -= sizeof(struct fc_fdmi_attr_entry);\n\t\tlen += FC_FDMI_PORT_ATTR_FC4TYPES_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_SUPPORTEDSPEED_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_CURRENTPORTSPEED_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_MAXFRAMESIZE_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_OSDEVICENAME_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_HOSTNAME_LEN;\n\n\t\tif (fc_host->fdmi_version == FDMI_V2) {\n\t\t\tnumattrs += 10;\n\t\t\tlen += FC_FDMI_PORT_ATTR_NODENAME_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTNAME_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_SYMBOLICNAME_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTTYPE_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_SUPPORTEDCLASSSRVC_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_FABRICNAME_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_CURRENTFC4TYPE_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTSTATE_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_DISCOVEREDPORTS_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTID_LEN;\n\t\t}\n\n\t\tlen += (numattrs * FC_FDMI_ATTR_ENTRY_HEADER_LEN);\n\n\t\tsize += len;\n\t\tbreak;\n\tcase LPORT_ST_DPRT:\n\t\tcmd = FC_FDMI_DPRT;\n\t\tlen = sizeof(struct fc_fdmi_dprt);\n\t\tsize += len;\n\t\tbreak;\n\tcase LPORT_ST_DHBA:\n\t\tcmd = FC_FDMI_DHBA;\n\t\tlen = sizeof(struct fc_fdmi_dhba);\n\t\tsize += len;\n\t\tbreak;\n\tdefault:\n\t\tfc_lport_error(lport, NULL);\n\t\treturn;\n\t}\n\n\tFC_LPORT_DBG(lport, \"Cmd=0x%x Len %d size %d\\n\",\n\t\t\t     cmd, (int)len, size);\n\tfp = fc_frame_alloc(lport, size);\n\tif (!fp) {\n\t\tfc_lport_error(lport, fp);\n\t\treturn;\n\t}\n\n\tif (!lport->tt.elsct_send(lport, FC_FID_MGMT_SERV, fp, cmd,\n\t\t\t\t  fc_lport_ms_resp,\n\t\t\t\t  lport, 3 * lport->r_a_tov))\n\t\tfc_lport_error(lport, fp);\n}\n\n \nstatic void fc_lport_enter_fdmi(struct fc_lport *lport)\n{\n\tstruct fc_rport_priv *rdata;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered FDMI state from %s state\\n\",\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, LPORT_ST_FDMI);\n\n\tmutex_lock(&lport->disc.disc_mutex);\n\trdata = fc_rport_create(lport, FC_FID_MGMT_SERV);\n\tmutex_unlock(&lport->disc.disc_mutex);\n\tif (!rdata)\n\t\tgoto err;\n\n\trdata->ops = &fc_lport_rport_ops;\n\tfc_rport_login(rdata);\n\treturn;\n\nerr:\n\tfc_lport_error(lport, NULL);\n}\n\n \nstatic void fc_lport_timeout(struct work_struct *work)\n{\n\tstruct fc_lport *lport =\n\t\tcontainer_of(work, struct fc_lport,\n\t\t\t     retry_work.work);\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(lport->host);\n\n\tmutex_lock(&lport->lp_mutex);\n\n\tswitch (lport->state) {\n\tcase LPORT_ST_DISABLED:\n\t\tbreak;\n\tcase LPORT_ST_READY:\n\t\tbreak;\n\tcase LPORT_ST_RESET:\n\t\tbreak;\n\tcase LPORT_ST_FLOGI:\n\t\tfc_lport_enter_flogi(lport);\n\t\tbreak;\n\tcase LPORT_ST_DNS:\n\t\tfc_lport_enter_dns(lport);\n\t\tbreak;\n\tcase LPORT_ST_RNN_ID:\n\tcase LPORT_ST_RSNN_NN:\n\tcase LPORT_ST_RSPN_ID:\n\tcase LPORT_ST_RFT_ID:\n\tcase LPORT_ST_RFF_ID:\n\t\tfc_lport_enter_ns(lport, lport->state);\n\t\tbreak;\n\tcase LPORT_ST_FDMI:\n\t\tfc_lport_enter_fdmi(lport);\n\t\tbreak;\n\tcase LPORT_ST_RHBA:\n\t\tif (fc_host->fdmi_version == FDMI_V2) {\n\t\t\tFC_LPORT_DBG(lport, \"timeout for FDMI-V2 RHBA,fall back to FDMI-V1\\n\");\n\t\t\tfc_host->fdmi_version = FDMI_V1;\n\t\t\tfc_lport_enter_ms(lport, LPORT_ST_RHBA);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase LPORT_ST_RPA:\n\tcase LPORT_ST_DHBA:\n\tcase LPORT_ST_DPRT:\n\t\tFC_LPORT_DBG(lport, \"Skipping lport state %s to SCR\\n\",\n\t\t\t     fc_lport_state(lport));\n\t\tfallthrough;\n\tcase LPORT_ST_SCR:\n\t\tfc_lport_enter_scr(lport);\n\t\tbreak;\n\tcase LPORT_ST_LOGO:\n\t\tfc_lport_enter_logo(lport);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&lport->lp_mutex);\n}\n\n \nvoid fc_lport_logo_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\tvoid *lp_arg)\n{\n\tstruct fc_lport *lport = lp_arg;\n\tu8 op;\n\n\tFC_LPORT_DBG(lport, \"Received a LOGO %s\\n\", fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\treturn;\n\n\tmutex_lock(&lport->lp_mutex);\n\n\tif (lport->state != LPORT_ST_LOGO) {\n\t\tFC_LPORT_DBG(lport, \"Received a LOGO response, but in state \"\n\t\t\t     \"%s\\n\", fc_lport_state(lport));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_lport_error(lport, fp);\n\t\tgoto err;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC)\n\t\tfc_lport_enter_disabled(lport);\n\telse\n\t\tfc_lport_error(lport, fp);\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&lport->lp_mutex);\n}\nEXPORT_SYMBOL(fc_lport_logo_resp);\n\n \nstatic void fc_lport_enter_logo(struct fc_lport *lport)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_els_logo *logo;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered LOGO state from %s state\\n\",\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, LPORT_ST_LOGO);\n\tfc_vports_linkchange(lport);\n\n\tfp = fc_frame_alloc(lport, sizeof(*logo));\n\tif (!fp) {\n\t\tfc_lport_error(lport, fp);\n\t\treturn;\n\t}\n\n\tif (!lport->tt.elsct_send(lport, FC_FID_FLOGI, fp, ELS_LOGO,\n\t\t\t\t  fc_lport_logo_resp, lport,\n\t\t\t\t  2 * lport->r_a_tov))\n\t\tfc_lport_error(lport, NULL);\n}\n\n \nvoid fc_lport_flogi_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t void *lp_arg)\n{\n\tstruct fc_lport *lport = lp_arg;\n\tstruct fc_frame_header *fh;\n\tstruct fc_els_flogi *flp;\n\tu32 did;\n\tu16 csp_flags;\n\tunsigned int r_a_tov;\n\tunsigned int e_d_tov;\n\tu16 mfs;\n\n\tFC_LPORT_DBG(lport, \"Received a FLOGI %s\\n\", fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\treturn;\n\n\tmutex_lock(&lport->lp_mutex);\n\n\tif (lport->state != LPORT_ST_FLOGI) {\n\t\tFC_LPORT_DBG(lport, \"Received a FLOGI response, but in state \"\n\t\t\t     \"%s\\n\", fc_lport_state(lport));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_lport_error(lport, fp);\n\t\tgoto err;\n\t}\n\n\tfh = fc_frame_header_get(fp);\n\tdid = fc_frame_did(fp);\n\tif (fh->fh_r_ctl != FC_RCTL_ELS_REP || did == 0 ||\n\t    fc_frame_payload_op(fp) != ELS_LS_ACC) {\n\t\tFC_LPORT_DBG(lport, \"FLOGI not accepted or bad response\\n\");\n\t\tfc_lport_error(lport, fp);\n\t\tgoto out;\n\t}\n\n\tflp = fc_frame_payload_get(fp, sizeof(*flp));\n\tif (!flp) {\n\t\tFC_LPORT_DBG(lport, \"FLOGI bad response\\n\");\n\t\tfc_lport_error(lport, fp);\n\t\tgoto out;\n\t}\n\n\tmfs = ntohs(flp->fl_csp.sp_bb_data) &\n\t\tFC_SP_BB_DATA_MASK;\n\n\tif (mfs < FC_SP_MIN_MAX_PAYLOAD || mfs > FC_SP_MAX_MAX_PAYLOAD) {\n\t\tFC_LPORT_DBG(lport, \"FLOGI bad mfs:%hu response, \"\n\t\t\t     \"lport->mfs:%u\\n\", mfs, lport->mfs);\n\t\tfc_lport_error(lport, fp);\n\t\tgoto out;\n\t}\n\n\tif (mfs <= lport->mfs) {\n\t\tlport->mfs = mfs;\n\t\tfc_host_maxframe_size(lport->host) = mfs;\n\t}\n\n\tcsp_flags = ntohs(flp->fl_csp.sp_features);\n\tr_a_tov = ntohl(flp->fl_csp.sp_r_a_tov);\n\te_d_tov = ntohl(flp->fl_csp.sp_e_d_tov);\n\tif (csp_flags & FC_SP_FT_EDTR)\n\t\te_d_tov /= 1000000;\n\n\tlport->npiv_enabled = !!(csp_flags & FC_SP_FT_NPIV_ACC);\n\n\tif ((csp_flags & FC_SP_FT_FPORT) == 0) {\n\t\tif (e_d_tov > lport->e_d_tov)\n\t\t\tlport->e_d_tov = e_d_tov;\n\t\tlport->r_a_tov = 2 * lport->e_d_tov;\n\t\tfc_lport_set_port_id(lport, did, fp);\n\t\tprintk(KERN_INFO \"host%d: libfc: \"\n\t\t       \"Port (%6.6x) entered \"\n\t\t       \"point-to-point mode\\n\",\n\t\t       lport->host->host_no, did);\n\t\tfc_lport_ptp_setup(lport, fc_frame_sid(fp),\n\t\t\t\t   get_unaligned_be64(\n\t\t\t\t\t   &flp->fl_wwpn),\n\t\t\t\t   get_unaligned_be64(\n\t\t\t\t\t   &flp->fl_wwnn));\n\t} else {\n\t\tif (e_d_tov > lport->e_d_tov)\n\t\t\tlport->e_d_tov = e_d_tov;\n\t\tif (r_a_tov > lport->r_a_tov)\n\t\t\tlport->r_a_tov = r_a_tov;\n\t\tfc_host_fabric_name(lport->host) =\n\t\t\tget_unaligned_be64(&flp->fl_wwnn);\n\t\tfc_lport_set_port_id(lport, did, fp);\n\t\tfc_lport_enter_dns(lport);\n\t}\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&lport->lp_mutex);\n}\nEXPORT_SYMBOL(fc_lport_flogi_resp);\n\n \nstatic void fc_lport_enter_flogi(struct fc_lport *lport)\n{\n\tstruct fc_frame *fp;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_LPORT_DBG(lport, \"Entered FLOGI state from %s state\\n\",\n\t\t     fc_lport_state(lport));\n\n\tfc_lport_state_enter(lport, LPORT_ST_FLOGI);\n\n\tif (lport->point_to_multipoint) {\n\t\tif (lport->port_id)\n\t\t\tfc_lport_enter_ready(lport);\n\t\treturn;\n\t}\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_flogi));\n\tif (!fp)\n\t\treturn fc_lport_error(lport, fp);\n\n\tif (!lport->tt.elsct_send(lport, FC_FID_FLOGI, fp,\n\t\t\t\t  lport->vport ? ELS_FDISC : ELS_FLOGI,\n\t\t\t\t  fc_lport_flogi_resp, lport,\n\t\t\t\t  lport->vport ? 2 * lport->r_a_tov :\n\t\t\t\t  lport->e_d_tov))\n\t\tfc_lport_error(lport, NULL);\n}\n\n \nint fc_lport_config(struct fc_lport *lport)\n{\n\tINIT_DELAYED_WORK(&lport->retry_work, fc_lport_timeout);\n\tmutex_init(&lport->lp_mutex);\n\n\tfc_lport_state_enter(lport, LPORT_ST_DISABLED);\n\n\tfc_lport_add_fc4_type(lport, FC_TYPE_FCP);\n\tfc_lport_add_fc4_type(lport, FC_TYPE_CT);\n\tfc_fc4_conf_lport_params(lport, FC_TYPE_FCP);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_lport_config);\n\n \nint fc_lport_init(struct fc_lport *lport)\n{\n\tstruct fc_host_attrs *fc_host;\n\n\tfc_host = shost_to_fc_host(lport->host);\n\n\t \n\tfc_host->fdmi_version = FDMI_V2;\n\n\tfc_host_port_type(lport->host) = FC_PORTTYPE_NPORT;\n\tfc_host_node_name(lport->host) = lport->wwnn;\n\tfc_host_port_name(lport->host) = lport->wwpn;\n\tfc_host_supported_classes(lport->host) = FC_COS_CLASS3;\n\tmemset(fc_host_supported_fc4s(lport->host), 0,\n\t       sizeof(fc_host_supported_fc4s(lport->host)));\n\tfc_host_supported_fc4s(lport->host)[2] = 1;\n\tfc_host_supported_fc4s(lport->host)[7] = 1;\n\tfc_host_num_discovered_ports(lport->host) = 4;\n\n\t \n\tmemset(fc_host_active_fc4s(lport->host), 0,\n\t       sizeof(fc_host_active_fc4s(lport->host)));\n\tfc_host_active_fc4s(lport->host)[2] = 1;\n\tfc_host_active_fc4s(lport->host)[7] = 1;\n\tfc_host_maxframe_size(lport->host) = lport->mfs;\n\tfc_host_supported_speeds(lport->host) = 0;\n\tif (lport->link_supported_speeds & FC_PORTSPEED_1GBIT)\n\t\tfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_1GBIT;\n\tif (lport->link_supported_speeds & FC_PORTSPEED_10GBIT)\n\t\tfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_10GBIT;\n\tif (lport->link_supported_speeds & FC_PORTSPEED_40GBIT)\n\t\tfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_40GBIT;\n\tif (lport->link_supported_speeds & FC_PORTSPEED_100GBIT)\n\t\tfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_100GBIT;\n\tif (lport->link_supported_speeds & FC_PORTSPEED_25GBIT)\n\t\tfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_25GBIT;\n\tif (lport->link_supported_speeds & FC_PORTSPEED_50GBIT)\n\t\tfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_50GBIT;\n\tif (lport->link_supported_speeds & FC_PORTSPEED_100GBIT)\n\t\tfc_host_supported_speeds(lport->host) |= FC_PORTSPEED_100GBIT;\n\n\tfc_fc4_add_lport(lport);\n\n\tfc_host_num_discovered_ports(lport->host) = DISCOVERED_PORTS;\n\tfc_host_port_state(lport->host) = FC_PORTSTATE_ONLINE;\n\tfc_host_max_ct_payload(lport->host) = MAX_CT_PAYLOAD;\n\tfc_host_num_ports(lport->host) = NUMBER_OF_PORTS;\n\tfc_host_bootbios_state(lport->host) = 0X00000000;\n\tsnprintf(fc_host_bootbios_version(lport->host),\n\t\tFC_SYMBOLIC_NAME_SIZE, \"%s\", \"Unknown\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_lport_init);\n\n \nstatic void fc_lport_bsg_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t      void *info_arg)\n{\n\tstruct fc_bsg_info *info = info_arg;\n\tstruct bsg_job *job = info->job;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct fc_lport *lport = info->lport;\n\tstruct fc_frame_header *fh;\n\tsize_t len;\n\tvoid *buf;\n\n\tif (IS_ERR(fp)) {\n\t\tbsg_reply->result = (PTR_ERR(fp) == -FC_EX_CLOSED) ?\n\t\t\t-ECONNABORTED : -ETIMEDOUT;\n\t\tjob->reply_len = sizeof(uint32_t);\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t\tkfree(info);\n\t\treturn;\n\t}\n\n\tmutex_lock(&lport->lp_mutex);\n\tfh = fc_frame_header_get(fp);\n\tlen = fr_len(fp) - sizeof(*fh);\n\tbuf = fc_frame_payload_get(fp, 0);\n\n\tif (fr_sof(fp) == FC_SOF_I3 && !ntohs(fh->fh_seq_cnt)) {\n\t\t \n\t\tunsigned short cmd = (info->rsp_code == FC_FS_ACC) ?\n\t\t\tntohs(((struct fc_ct_hdr *)buf)->ct_cmd) :\n\t\t\t(unsigned short)fc_frame_payload_op(fp);\n\n\t\t \n\t\tbsg_reply->reply_data.ctels_reply.status =\n\t\t\t(cmd == info->rsp_code) ?\n\t\t\tFC_CTELS_STATUS_OK : FC_CTELS_STATUS_REJECT;\n\t}\n\n\tbsg_reply->reply_payload_rcv_len +=\n\t\tfc_copy_buffer_to_sglist(buf, len, info->sg, &info->nents,\n\t\t\t\t\t &info->offset, NULL);\n\n\tif (fr_eof(fp) == FC_EOF_T &&\n\t    (ntoh24(fh->fh_f_ctl) & (FC_FC_LAST_SEQ | FC_FC_END_SEQ)) ==\n\t    (FC_FC_LAST_SEQ | FC_FC_END_SEQ)) {\n\t\tif (bsg_reply->reply_payload_rcv_len >\n\t\t    job->reply_payload.payload_len)\n\t\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\t\tjob->reply_payload.payload_len;\n\t\tbsg_reply->result = 0;\n\t\tbsg_job_done(job, bsg_reply->result,\n\t\t\t       bsg_reply->reply_payload_rcv_len);\n\t\tkfree(info);\n\t}\n\tfc_frame_free(fp);\n\tmutex_unlock(&lport->lp_mutex);\n}\n\n \nstatic int fc_lport_els_request(struct bsg_job *job,\n\t\t\t\tstruct fc_lport *lport,\n\t\t\t\tu32 did, u32 tov)\n{\n\tstruct fc_bsg_info *info;\n\tstruct fc_frame *fp;\n\tstruct fc_frame_header *fh;\n\tchar *pp;\n\tint len;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tfp = fc_frame_alloc(lport, job->request_payload.payload_len);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tlen = job->request_payload.payload_len;\n\tpp = fc_frame_payload_get(fp, len);\n\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt,\n\t\t\t  pp, len);\n\n\tfh = fc_frame_header_get(fp);\n\tfh->fh_r_ctl = FC_RCTL_ELS_REQ;\n\thton24(fh->fh_d_id, did);\n\thton24(fh->fh_s_id, lport->port_id);\n\tfh->fh_type = FC_TYPE_ELS;\n\thton24(fh->fh_f_ctl, FC_FCTL_REQ);\n\tfh->fh_cs_ctl = 0;\n\tfh->fh_df_ctl = 0;\n\tfh->fh_parm_offset = 0;\n\n\tinfo = kzalloc(sizeof(struct fc_bsg_info), GFP_KERNEL);\n\tif (!info) {\n\t\tfc_frame_free(fp);\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->job = job;\n\tinfo->lport = lport;\n\tinfo->rsp_code = ELS_LS_ACC;\n\tinfo->nents = job->reply_payload.sg_cnt;\n\tinfo->sg = job->reply_payload.sg_list;\n\n\tif (!fc_exch_seq_send(lport, fp, fc_lport_bsg_resp,\n\t\t\t      NULL, info, tov)) {\n\t\tkfree(info);\n\t\treturn -ECOMM;\n\t}\n\treturn 0;\n}\n\n \nstatic int fc_lport_ct_request(struct bsg_job *job,\n\t\t\t       struct fc_lport *lport, u32 did, u32 tov)\n{\n\tstruct fc_bsg_info *info;\n\tstruct fc_frame *fp;\n\tstruct fc_frame_header *fh;\n\tstruct fc_ct_req *ct;\n\tsize_t len;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_ct_hdr) +\n\t\t\t    job->request_payload.payload_len);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tlen = job->request_payload.payload_len;\n\tct = fc_frame_payload_get(fp, len);\n\n\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t  job->request_payload.sg_cnt,\n\t\t\t  ct, len);\n\n\tfh = fc_frame_header_get(fp);\n\tfh->fh_r_ctl = FC_RCTL_DD_UNSOL_CTL;\n\thton24(fh->fh_d_id, did);\n\thton24(fh->fh_s_id, lport->port_id);\n\tfh->fh_type = FC_TYPE_CT;\n\thton24(fh->fh_f_ctl, FC_FCTL_REQ);\n\tfh->fh_cs_ctl = 0;\n\tfh->fh_df_ctl = 0;\n\tfh->fh_parm_offset = 0;\n\n\tinfo = kzalloc(sizeof(struct fc_bsg_info), GFP_KERNEL);\n\tif (!info) {\n\t\tfc_frame_free(fp);\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->job = job;\n\tinfo->lport = lport;\n\tinfo->rsp_code = FC_FS_ACC;\n\tinfo->nents = job->reply_payload.sg_cnt;\n\tinfo->sg = job->reply_payload.sg_list;\n\n\tif (!fc_exch_seq_send(lport, fp, fc_lport_bsg_resp,\n\t\t\t      NULL, info, tov)) {\n\t\tkfree(info);\n\t\treturn -ECOMM;\n\t}\n\treturn 0;\n}\n\n \nint fc_lport_bsg_request(struct bsg_job *job)\n{\n\tstruct fc_bsg_request *bsg_request = job->request;\n\tstruct fc_bsg_reply *bsg_reply = job->reply;\n\tstruct Scsi_Host *shost = fc_bsg_to_shost(job);\n\tstruct fc_lport *lport = shost_priv(shost);\n\tstruct fc_rport *rport;\n\tstruct fc_rport_priv *rdata;\n\tint rc = -EINVAL;\n\tu32 did, tov;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tmutex_lock(&lport->lp_mutex);\n\n\tswitch (bsg_request->msgcode) {\n\tcase FC_BSG_RPT_ELS:\n\t\trport = fc_bsg_to_rport(job);\n\t\tif (!rport)\n\t\t\tbreak;\n\n\t\trdata = rport->dd_data;\n\t\trc = fc_lport_els_request(job, lport, rport->port_id,\n\t\t\t\t\t  rdata->e_d_tov);\n\t\tbreak;\n\n\tcase FC_BSG_RPT_CT:\n\t\trport = fc_bsg_to_rport(job);\n\t\tif (!rport)\n\t\t\tbreak;\n\n\t\trdata = rport->dd_data;\n\t\trc = fc_lport_ct_request(job, lport, rport->port_id,\n\t\t\t\t\t rdata->e_d_tov);\n\t\tbreak;\n\n\tcase FC_BSG_HST_CT:\n\t\tdid = ntoh24(bsg_request->rqst_data.h_ct.port_id);\n\t\tif (did == FC_FID_DIR_SERV) {\n\t\t\trdata = lport->dns_rdata;\n\t\t\tif (!rdata)\n\t\t\t\tbreak;\n\t\t\ttov = rdata->e_d_tov;\n\t\t} else {\n\t\t\trdata = fc_rport_lookup(lport, did);\n\t\t\tif (!rdata)\n\t\t\t\tbreak;\n\t\t\ttov = rdata->e_d_tov;\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\t}\n\n\t\trc = fc_lport_ct_request(job, lport, did, tov);\n\t\tbreak;\n\n\tcase FC_BSG_HST_ELS_NOLOGIN:\n\t\tdid = ntoh24(bsg_request->rqst_data.h_els.port_id);\n\t\trc = fc_lport_els_request(job, lport, did, lport->e_d_tov);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&lport->lp_mutex);\n\treturn rc;\n}\nEXPORT_SYMBOL(fc_lport_bsg_request);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}