{
  "module_name": "fc_disc.c",
  "hash_id": "ab269143911502d7f2a40c62ff36b15a4ba504366ff463e46355e0834c3f31a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libfc/fc_disc.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/list.h>\n\n#include <asm/unaligned.h>\n\n#include <scsi/fc/fc_gs.h>\n\n#include <scsi/libfc.h>\n\n#include \"fc_libfc.h\"\n\n#define FC_DISC_RETRY_LIMIT\t3\t \n#define FC_DISC_RETRY_DELAY\t500UL\t \n\nstatic void fc_disc_gpn_ft_req(struct fc_disc *);\nstatic void fc_disc_gpn_ft_resp(struct fc_seq *, struct fc_frame *, void *);\nstatic void fc_disc_done(struct fc_disc *, enum fc_disc_event);\nstatic void fc_disc_timeout(struct work_struct *);\nstatic int fc_disc_single(struct fc_lport *, struct fc_disc_port *);\nstatic void fc_disc_restart(struct fc_disc *);\n\n \nstatic void fc_disc_stop_rports(struct fc_disc *disc)\n{\n\tstruct fc_rport_priv *rdata;\n\n\tlockdep_assert_held(&disc->disc_mutex);\n\n\tlist_for_each_entry(rdata, &disc->rports, peers) {\n\t\tif (kref_get_unless_zero(&rdata->kref)) {\n\t\t\tfc_rport_logoff(rdata);\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\t}\n\t}\n}\n\n \nstatic void fc_disc_recv_rscn_req(struct fc_disc *disc, struct fc_frame *fp)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_els_rscn *rp;\n\tstruct fc_els_rscn_page *pp;\n\tstruct fc_seq_els_data rjt_data;\n\tunsigned int len;\n\tint redisc = 0;\n\tenum fc_els_rscn_addr_fmt fmt;\n\tLIST_HEAD(disc_ports);\n\tstruct fc_disc_port *dp, *next;\n\n\tlockdep_assert_held(&disc->disc_mutex);\n\n\tlport = fc_disc_lport(disc);\n\n\tFC_DISC_DBG(disc, \"Received an RSCN event\\n\");\n\n\t \n\trp = fc_frame_payload_get(fp, sizeof(*rp));\n\tif (!rp)\n\t\tgoto reject;\n\t \n\tif (rp->rscn_page_len != sizeof(*pp))\n\t\tgoto reject;\n\t \n\tlen = ntohs(rp->rscn_plen);\n\tif (len < sizeof(*rp))\n\t\tgoto reject;\n\t \n\trp = fc_frame_payload_get(fp, len);\n\tif (!rp)\n\t\tgoto reject;\n\t \n\tlen -= sizeof(*rp);\n\tif (len % sizeof(*pp))\n\t\tgoto reject;\n\n\tfor (pp = (void *)(rp + 1); len > 0; len -= sizeof(*pp), pp++) {\n\t\tfmt = pp->rscn_page_flags >> ELS_RSCN_ADDR_FMT_BIT;\n\t\tfmt &= ELS_RSCN_ADDR_FMT_MASK;\n\t\t \n\t\tswitch (fmt) {\n\t\tcase ELS_ADDR_FMT_PORT:\n\t\t\tFC_DISC_DBG(disc, \"Port address format for port \"\n\t\t\t\t    \"(%6.6x)\\n\", ntoh24(pp->rscn_fid));\n\t\t\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\t\t\tif (!dp) {\n\t\t\t\tredisc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdp->lp = lport;\n\t\t\tdp->port_id = ntoh24(pp->rscn_fid);\n\t\t\tlist_add_tail(&dp->peers, &disc_ports);\n\t\t\tbreak;\n\t\tcase ELS_ADDR_FMT_AREA:\n\t\tcase ELS_ADDR_FMT_DOM:\n\t\tcase ELS_ADDR_FMT_FAB:\n\t\tdefault:\n\t\t\tFC_DISC_DBG(disc, \"Address format is (%d)\\n\", fmt);\n\t\t\tredisc = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfc_seq_els_rsp_send(fp, ELS_LS_ACC, NULL);\n\n\t \n\tlist_for_each_entry_safe(dp, next, &disc_ports, peers) {\n\t\tlist_del(&dp->peers);\n\t\tif (!redisc)\n\t\t\tredisc = fc_disc_single(lport, dp);\n\t\tkfree(dp);\n\t}\n\tif (redisc) {\n\t\tFC_DISC_DBG(disc, \"RSCN received: rediscovering\\n\");\n\t\tfc_disc_restart(disc);\n\t} else {\n\t\tFC_DISC_DBG(disc, \"RSCN received: not rediscovering. \"\n\t\t\t    \"redisc %d state %d in_prog %d\\n\",\n\t\t\t    redisc, lport->state, disc->pending);\n\t}\n\tfc_frame_free(fp);\n\treturn;\nreject:\n\tFC_DISC_DBG(disc, \"Received a bad RSCN frame\\n\");\n\trjt_data.reason = ELS_RJT_LOGIC;\n\trjt_data.explan = ELS_EXPL_NONE;\n\tfc_seq_els_rsp_send(fp, ELS_LS_RJT, &rjt_data);\n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_disc_recv_req(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tu8 op;\n\tstruct fc_disc *disc = &lport->disc;\n\n\top = fc_frame_payload_op(fp);\n\tswitch (op) {\n\tcase ELS_RSCN:\n\t\tmutex_lock(&disc->disc_mutex);\n\t\tfc_disc_recv_rscn_req(disc, fp);\n\t\tmutex_unlock(&disc->disc_mutex);\n\t\tbreak;\n\tdefault:\n\t\tFC_DISC_DBG(disc, \"Received an unsupported request, \"\n\t\t\t    \"the opcode is (%x)\\n\", op);\n\t\tfc_frame_free(fp);\n\t\tbreak;\n\t}\n}\n\n \nstatic void fc_disc_restart(struct fc_disc *disc)\n{\n\tlockdep_assert_held(&disc->disc_mutex);\n\n\tif (!disc->disc_callback)\n\t\treturn;\n\n\tFC_DISC_DBG(disc, \"Restarting discovery\\n\");\n\n\tdisc->requested = 1;\n\tif (disc->pending)\n\t\treturn;\n\n\t \n\tdisc->disc_id = (disc->disc_id + 2) | 1;\n\tdisc->retry_count = 0;\n\tfc_disc_gpn_ft_req(disc);\n}\n\n \nstatic void fc_disc_start(void (*disc_callback)(struct fc_lport *,\n\t\t\t\t\t\tenum fc_disc_event),\n\t\t\t  struct fc_lport *lport)\n{\n\tstruct fc_disc *disc = &lport->disc;\n\n\t \n\tmutex_lock(&disc->disc_mutex);\n\tdisc->disc_callback = disc_callback;\n\tfc_disc_restart(disc);\n\tmutex_unlock(&disc->disc_mutex);\n}\n\n \nstatic void fc_disc_done(struct fc_disc *disc, enum fc_disc_event event)\n{\n\tstruct fc_lport *lport = fc_disc_lport(disc);\n\tstruct fc_rport_priv *rdata;\n\n\tlockdep_assert_held(&disc->disc_mutex);\n\tFC_DISC_DBG(disc, \"Discovery complete\\n\");\n\n\tdisc->pending = 0;\n\tif (disc->requested) {\n\t\tfc_disc_restart(disc);\n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry(rdata, &disc->rports, peers) {\n\t\tif (!kref_get_unless_zero(&rdata->kref))\n\t\t\tcontinue;\n\t\tif (rdata->disc_id) {\n\t\t\tif (rdata->disc_id == disc->disc_id)\n\t\t\t\tfc_rport_login(rdata);\n\t\t\telse\n\t\t\t\tfc_rport_logoff(rdata);\n\t\t}\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n\tmutex_unlock(&disc->disc_mutex);\n\tdisc->disc_callback(lport, event);\n\tmutex_lock(&disc->disc_mutex);\n}\n\n \nstatic void fc_disc_error(struct fc_disc *disc, struct fc_frame *fp)\n{\n\tstruct fc_lport *lport = fc_disc_lport(disc);\n\tunsigned long delay = 0;\n\n\tFC_DISC_DBG(disc, \"Error %d, retries %d/%d\\n\",\n\t\t    PTR_ERR_OR_ZERO(fp), disc->retry_count,\n\t\t    FC_DISC_RETRY_LIMIT);\n\n\tif (!fp || PTR_ERR(fp) == -FC_EX_TIMEOUT) {\n\t\t \n\t\tif (disc->retry_count < FC_DISC_RETRY_LIMIT) {\n\t\t\t \n\t\t\tif (!fp)\n\t\t\t\tdelay = msecs_to_jiffies(FC_DISC_RETRY_DELAY);\n\t\t\telse {\n\t\t\t\tdelay = msecs_to_jiffies(lport->e_d_tov);\n\n\t\t\t\t \n\t\t\t\tif (!disc->retry_count)\n\t\t\t\t\tdelay /= 4;\n\t\t\t}\n\t\t\tdisc->retry_count++;\n\t\t\tschedule_delayed_work(&disc->disc_work, delay);\n\t\t} else\n\t\t\tfc_disc_done(disc, DISC_EV_FAILED);\n\t} else if (PTR_ERR(fp) == -FC_EX_CLOSED) {\n\t\t \n\t\tdisc->pending = 0;\n\t}\n}\n\n \nstatic void fc_disc_gpn_ft_req(struct fc_disc *disc)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_lport *lport = fc_disc_lport(disc);\n\n\tlockdep_assert_held(&disc->disc_mutex);\n\n\tWARN_ON(!fc_lport_test_ready(lport));\n\n\tdisc->pending = 1;\n\tdisc->requested = 0;\n\n\tdisc->buf_len = 0;\n\tdisc->seq_count = 0;\n\tfp = fc_frame_alloc(lport,\n\t\t\t    sizeof(struct fc_ct_hdr) +\n\t\t\t    sizeof(struct fc_ns_gid_ft));\n\tif (!fp)\n\t\tgoto err;\n\n\tif (lport->tt.elsct_send(lport, 0, fp,\n\t\t\t\t FC_NS_GPN_FT,\n\t\t\t\t fc_disc_gpn_ft_resp,\n\t\t\t\t disc, 3 * lport->r_a_tov))\n\t\treturn;\nerr:\n\tfc_disc_error(disc, NULL);\n}\n\n \nstatic int fc_disc_gpn_ft_parse(struct fc_disc *disc, void *buf, size_t len)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_gpn_ft_resp *np;\n\tchar *bp;\n\tsize_t plen;\n\tsize_t tlen;\n\tint error = 0;\n\tstruct fc_rport_identifiers ids;\n\tstruct fc_rport_priv *rdata;\n\n\tlport = fc_disc_lport(disc);\n\tdisc->seq_count++;\n\n\t \n\tbp = buf;\n\tplen = len;\n\tnp = (struct fc_gpn_ft_resp *)bp;\n\ttlen = disc->buf_len;\n\tdisc->buf_len = 0;\n\tif (tlen) {\n\t\tWARN_ON(tlen >= sizeof(*np));\n\t\tplen = sizeof(*np) - tlen;\n\t\tWARN_ON(plen <= 0);\n\t\tWARN_ON(plen >= sizeof(*np));\n\t\tif (plen > len)\n\t\t\tplen = len;\n\t\tnp = &disc->partial_buf;\n\t\tmemcpy((char *)np + tlen, bp, plen);\n\n\t\t \n\t\tbp -= tlen;\n\t\tlen += tlen;\n\t\tplen += tlen;\n\t\tdisc->buf_len = (unsigned char) plen;\n\t\tif (plen == sizeof(*np))\n\t\t\tdisc->buf_len = 0;\n\t}\n\n\t \n\twhile (plen >= sizeof(*np)) {\n\t\tids.port_id = ntoh24(np->fp_fid);\n\t\tids.port_name = ntohll(np->fp_wwpn);\n\n\t\tif (ids.port_id != lport->port_id &&\n\t\t    ids.port_name != lport->wwpn) {\n\t\t\trdata = fc_rport_create(lport, ids.port_id);\n\t\t\tif (rdata) {\n\t\t\t\trdata->ids.port_name = ids.port_name;\n\t\t\t\trdata->disc_id = disc->disc_id;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"libfc: Failed to allocate \"\n\t\t\t\t       \"memory for the newly discovered port \"\n\t\t\t\t       \"(%6.6x)\\n\", ids.port_id);\n\t\t\t\terror = -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tif (np->fp_flags & FC_NS_FID_LAST) {\n\t\t\tfc_disc_done(disc, DISC_EV_SUCCESS);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\t}\n\t\tlen -= sizeof(*np);\n\t\tbp += sizeof(*np);\n\t\tnp = (struct fc_gpn_ft_resp *)bp;\n\t\tplen = len;\n\t}\n\n\t \n\tif (error == 0 && len > 0 && len < sizeof(*np)) {\n\t\tif (np != &disc->partial_buf) {\n\t\t\tFC_DISC_DBG(disc, \"Partial buffer remains \"\n\t\t\t\t    \"for discovery\\n\");\n\t\t\tmemcpy(&disc->partial_buf, np, len);\n\t\t}\n\t\tdisc->buf_len = (unsigned char) len;\n\t}\n\treturn error;\n}\n\n \nstatic void fc_disc_timeout(struct work_struct *work)\n{\n\tstruct fc_disc *disc = container_of(work,\n\t\t\t\t\t    struct fc_disc,\n\t\t\t\t\t    disc_work.work);\n\tmutex_lock(&disc->disc_mutex);\n\tfc_disc_gpn_ft_req(disc);\n\tmutex_unlock(&disc->disc_mutex);\n}\n\n \nstatic void fc_disc_gpn_ft_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t\tvoid *disc_arg)\n{\n\tstruct fc_disc *disc = disc_arg;\n\tstruct fc_ct_hdr *cp;\n\tstruct fc_frame_header *fh;\n\tenum fc_disc_event event = DISC_EV_NONE;\n\tunsigned int seq_cnt;\n\tunsigned int len;\n\tint error = 0;\n\n\tmutex_lock(&disc->disc_mutex);\n\tFC_DISC_DBG(disc, \"Received a GPN_FT response\\n\");\n\n\tif (IS_ERR(fp)) {\n\t\tfc_disc_error(disc, fp);\n\t\tmutex_unlock(&disc->disc_mutex);\n\t\treturn;\n\t}\n\n\tWARN_ON(!fc_frame_is_linear(fp));\t \n\tfh = fc_frame_header_get(fp);\n\tlen = fr_len(fp) - sizeof(*fh);\n\tseq_cnt = ntohs(fh->fh_seq_cnt);\n\tif (fr_sof(fp) == FC_SOF_I3 && seq_cnt == 0 && disc->seq_count == 0) {\n\t\tcp = fc_frame_payload_get(fp, sizeof(*cp));\n\t\tif (!cp) {\n\t\t\tFC_DISC_DBG(disc, \"GPN_FT response too short, len %d\\n\",\n\t\t\t\t    fr_len(fp));\n\t\t\tevent = DISC_EV_FAILED;\n\t\t} else if (ntohs(cp->ct_cmd) == FC_FS_ACC) {\n\n\t\t\t \n\t\t\tlen -= sizeof(*cp);\n\t\t\terror = fc_disc_gpn_ft_parse(disc, cp + 1, len);\n\t\t} else if (ntohs(cp->ct_cmd) == FC_FS_RJT) {\n\t\t\tFC_DISC_DBG(disc, \"GPN_FT rejected reason %x exp %x \"\n\t\t\t\t    \"(check zoning)\\n\", cp->ct_reason,\n\t\t\t\t    cp->ct_explan);\n\t\t\tevent = DISC_EV_FAILED;\n\t\t\tif (cp->ct_reason == FC_FS_RJT_UNABL &&\n\t\t\t    cp->ct_explan == FC_FS_EXP_FTNR)\n\t\t\t\tevent = DISC_EV_SUCCESS;\n\t\t} else {\n\t\t\tFC_DISC_DBG(disc, \"GPN_FT unexpected response code \"\n\t\t\t\t    \"%x\\n\", ntohs(cp->ct_cmd));\n\t\t\tevent = DISC_EV_FAILED;\n\t\t}\n\t} else if (fr_sof(fp) == FC_SOF_N3 && seq_cnt == disc->seq_count) {\n\t\terror = fc_disc_gpn_ft_parse(disc, fh + 1, len);\n\t} else {\n\t\tFC_DISC_DBG(disc, \"GPN_FT unexpected frame - out of sequence? \"\n\t\t\t    \"seq_cnt %x expected %x sof %x eof %x\\n\",\n\t\t\t    seq_cnt, disc->seq_count, fr_sof(fp), fr_eof(fp));\n\t\tevent = DISC_EV_FAILED;\n\t}\n\tif (error)\n\t\tfc_disc_error(disc, ERR_PTR(error));\n\telse if (event != DISC_EV_NONE)\n\t\tfc_disc_done(disc, event);\n\tfc_frame_free(fp);\n\tmutex_unlock(&disc->disc_mutex);\n}\n\n \nstatic void fc_disc_gpn_id_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t\tvoid *rdata_arg)\n{\n\tstruct fc_rport_priv *rdata = rdata_arg;\n\tstruct fc_rport_priv *new_rdata;\n\tstruct fc_lport *lport;\n\tstruct fc_disc *disc;\n\tstruct fc_ct_hdr *cp;\n\tstruct fc_ns_gid_pn *pn;\n\tu64 port_name;\n\n\tlport = rdata->local_port;\n\tdisc = &lport->disc;\n\n\tif (PTR_ERR(fp) == -FC_EX_CLOSED)\n\t\tgoto out;\n\tif (IS_ERR(fp)) {\n\t\tmutex_lock(&disc->disc_mutex);\n\t\tfc_disc_restart(disc);\n\t\tmutex_unlock(&disc->disc_mutex);\n\t\tgoto out;\n\t}\n\n\tcp = fc_frame_payload_get(fp, sizeof(*cp));\n\tif (!cp)\n\t\tgoto redisc;\n\tif (ntohs(cp->ct_cmd) == FC_FS_ACC) {\n\t\tif (fr_len(fp) < sizeof(struct fc_frame_header) +\n\t\t    sizeof(*cp) + sizeof(*pn))\n\t\t\tgoto redisc;\n\t\tpn = (struct fc_ns_gid_pn *)(cp + 1);\n\t\tport_name = get_unaligned_be64(&pn->fn_wwpn);\n\t\tmutex_lock(&rdata->rp_mutex);\n\t\tif (rdata->ids.port_name == -1)\n\t\t\trdata->ids.port_name = port_name;\n\t\telse if (rdata->ids.port_name != port_name) {\n\t\t\tFC_DISC_DBG(disc, \"GPN_ID accepted.  WWPN changed. \"\n\t\t\t\t    \"Port-id %6.6x wwpn %16.16llx\\n\",\n\t\t\t\t    rdata->ids.port_id, port_name);\n\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t\tfc_rport_logoff(rdata);\n\t\t\tmutex_lock(&lport->disc.disc_mutex);\n\t\t\tnew_rdata = fc_rport_create(lport, rdata->ids.port_id);\n\t\t\tmutex_unlock(&lport->disc.disc_mutex);\n\t\t\tif (new_rdata) {\n\t\t\t\tnew_rdata->disc_id = disc->disc_id;\n\t\t\t\tfc_rport_login(new_rdata);\n\t\t\t}\n\t\t\tgoto free_fp;\n\t\t}\n\t\trdata->disc_id = disc->disc_id;\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\tfc_rport_login(rdata);\n\t} else if (ntohs(cp->ct_cmd) == FC_FS_RJT) {\n\t\tFC_DISC_DBG(disc, \"GPN_ID rejected reason %x exp %x\\n\",\n\t\t\t    cp->ct_reason, cp->ct_explan);\n\t\tfc_rport_logoff(rdata);\n\t} else {\n\t\tFC_DISC_DBG(disc, \"GPN_ID unexpected response code %x\\n\",\n\t\t\t    ntohs(cp->ct_cmd));\nredisc:\n\t\tmutex_lock(&disc->disc_mutex);\n\t\tfc_disc_restart(disc);\n\t\tmutex_unlock(&disc->disc_mutex);\n\t}\nfree_fp:\n\tfc_frame_free(fp);\nout:\n\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\n \nstatic int fc_disc_gpn_id_req(struct fc_lport *lport,\n\t\t\t      struct fc_rport_priv *rdata)\n{\n\tstruct fc_frame *fp;\n\n\tlockdep_assert_held(&lport->disc.disc_mutex);\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_ct_hdr) +\n\t\t\t    sizeof(struct fc_ns_fid));\n\tif (!fp)\n\t\treturn -ENOMEM;\n\tif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, FC_NS_GPN_ID,\n\t\t\t\t  fc_disc_gpn_id_resp, rdata,\n\t\t\t\t  3 * lport->r_a_tov))\n\t\treturn -ENOMEM;\n\tkref_get(&rdata->kref);\n\treturn 0;\n}\n\n \nstatic int fc_disc_single(struct fc_lport *lport, struct fc_disc_port *dp)\n{\n\tstruct fc_rport_priv *rdata;\n\n\tlockdep_assert_held(&lport->disc.disc_mutex);\n\n\trdata = fc_rport_create(lport, dp->port_id);\n\tif (!rdata)\n\t\treturn -ENOMEM;\n\trdata->disc_id = 0;\n\treturn fc_disc_gpn_id_req(lport, rdata);\n}\n\n \nstatic void fc_disc_stop(struct fc_lport *lport)\n{\n\tstruct fc_disc *disc = &lport->disc;\n\n\tif (disc->pending)\n\t\tcancel_delayed_work_sync(&disc->disc_work);\n\tmutex_lock(&disc->disc_mutex);\n\tfc_disc_stop_rports(disc);\n\tmutex_unlock(&disc->disc_mutex);\n}\n\n \nstatic void fc_disc_stop_final(struct fc_lport *lport)\n{\n\tfc_disc_stop(lport);\n\tfc_rport_flush_queue();\n}\n\n \nvoid fc_disc_config(struct fc_lport *lport, void *priv)\n{\n\tstruct fc_disc *disc;\n\n\tif (!lport->tt.disc_start)\n\t\tlport->tt.disc_start = fc_disc_start;\n\n\tif (!lport->tt.disc_stop)\n\t\tlport->tt.disc_stop = fc_disc_stop;\n\n\tif (!lport->tt.disc_stop_final)\n\t\tlport->tt.disc_stop_final = fc_disc_stop_final;\n\n\tif (!lport->tt.disc_recv_req)\n\t\tlport->tt.disc_recv_req = fc_disc_recv_req;\n\n\tdisc = &lport->disc;\n\n\tdisc->priv = priv;\n}\nEXPORT_SYMBOL(fc_disc_config);\n\n \nvoid fc_disc_init(struct fc_lport *lport)\n{\n\tstruct fc_disc *disc = &lport->disc;\n\n\tINIT_DELAYED_WORK(&disc->disc_work, fc_disc_timeout);\n\tmutex_init(&disc->disc_mutex);\n\tINIT_LIST_HEAD(&disc->rports);\n}\nEXPORT_SYMBOL(fc_disc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}