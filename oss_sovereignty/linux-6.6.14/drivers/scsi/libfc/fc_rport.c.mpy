{
  "module_name": "fc_rport.c",
  "hash_id": "6b040c19c4f191a4291a24594fa8f9821133bdc4bbec85c406da682737c7e4da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libfc/fc_rport.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/rcupdate.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/export.h>\n#include <linux/rculist.h>\n\n#include <asm/unaligned.h>\n\n#include <scsi/libfc.h>\n\n#include \"fc_encode.h\"\n#include \"fc_libfc.h\"\n\nstatic struct workqueue_struct *rport_event_queue;\n\nstatic void fc_rport_enter_flogi(struct fc_rport_priv *);\nstatic void fc_rport_enter_plogi(struct fc_rport_priv *);\nstatic void fc_rport_enter_prli(struct fc_rport_priv *);\nstatic void fc_rport_enter_rtv(struct fc_rport_priv *);\nstatic void fc_rport_enter_ready(struct fc_rport_priv *);\nstatic void fc_rport_enter_logo(struct fc_rport_priv *);\nstatic void fc_rport_enter_adisc(struct fc_rport_priv *);\n\nstatic void fc_rport_recv_plogi_req(struct fc_lport *, struct fc_frame *);\nstatic void fc_rport_recv_prli_req(struct fc_rport_priv *, struct fc_frame *);\nstatic void fc_rport_recv_prlo_req(struct fc_rport_priv *, struct fc_frame *);\nstatic void fc_rport_recv_logo_req(struct fc_lport *, struct fc_frame *);\nstatic void fc_rport_timeout(struct work_struct *);\nstatic void fc_rport_error(struct fc_rport_priv *, int);\nstatic void fc_rport_error_retry(struct fc_rport_priv *, int);\nstatic void fc_rport_work(struct work_struct *);\n\nstatic const char *fc_rport_state_names[] = {\n\t[RPORT_ST_INIT] = \"Init\",\n\t[RPORT_ST_FLOGI] = \"FLOGI\",\n\t[RPORT_ST_PLOGI_WAIT] = \"PLOGI_WAIT\",\n\t[RPORT_ST_PLOGI] = \"PLOGI\",\n\t[RPORT_ST_PRLI] = \"PRLI\",\n\t[RPORT_ST_RTV] = \"RTV\",\n\t[RPORT_ST_READY] = \"Ready\",\n\t[RPORT_ST_ADISC] = \"ADISC\",\n\t[RPORT_ST_DELETE] = \"Delete\",\n};\n\n \nstruct fc_rport_priv *fc_rport_lookup(const struct fc_lport *lport,\n\t\t\t\t      u32 port_id)\n{\n\tstruct fc_rport_priv *rdata = NULL, *tmp_rdata;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(tmp_rdata, &lport->disc.rports, peers)\n\t\tif (tmp_rdata->ids.port_id == port_id &&\n\t\t    kref_get_unless_zero(&tmp_rdata->kref)) {\n\t\t\trdata = tmp_rdata;\n\t\t\tbreak;\n\t\t}\n\trcu_read_unlock();\n\treturn rdata;\n}\nEXPORT_SYMBOL(fc_rport_lookup);\n\n \nstruct fc_rport_priv *fc_rport_create(struct fc_lport *lport, u32 port_id)\n{\n\tstruct fc_rport_priv *rdata;\n\tsize_t rport_priv_size = sizeof(*rdata);\n\n\tlockdep_assert_held(&lport->disc.disc_mutex);\n\n\trdata = fc_rport_lookup(lport, port_id);\n\tif (rdata) {\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\treturn rdata;\n\t}\n\n\tif (lport->rport_priv_size > 0)\n\t\trport_priv_size = lport->rport_priv_size;\n\trdata = kzalloc(rport_priv_size, GFP_KERNEL);\n\tif (!rdata)\n\t\treturn NULL;\n\n\trdata->ids.node_name = -1;\n\trdata->ids.port_name = -1;\n\trdata->ids.port_id = port_id;\n\trdata->ids.roles = FC_RPORT_ROLE_UNKNOWN;\n\n\tkref_init(&rdata->kref);\n\tmutex_init(&rdata->rp_mutex);\n\trdata->local_port = lport;\n\trdata->rp_state = RPORT_ST_INIT;\n\trdata->event = RPORT_EV_NONE;\n\trdata->flags = FC_RP_FLAGS_REC_SUPPORTED;\n\trdata->e_d_tov = lport->e_d_tov;\n\trdata->r_a_tov = lport->r_a_tov;\n\trdata->maxframe_size = FC_MIN_MAX_PAYLOAD;\n\tINIT_DELAYED_WORK(&rdata->retry_work, fc_rport_timeout);\n\tINIT_WORK(&rdata->event_work, fc_rport_work);\n\tif (port_id != FC_FID_DIR_SERV) {\n\t\trdata->lld_event_callback = lport->tt.rport_event_callback;\n\t\tlist_add_rcu(&rdata->peers, &lport->disc.rports);\n\t}\n\treturn rdata;\n}\nEXPORT_SYMBOL(fc_rport_create);\n\n \nvoid fc_rport_destroy(struct kref *kref)\n{\n\tstruct fc_rport_priv *rdata;\n\n\trdata = container_of(kref, struct fc_rport_priv, kref);\n\tkfree_rcu(rdata, rcu);\n}\nEXPORT_SYMBOL(fc_rport_destroy);\n\n \nstatic const char *fc_rport_state(struct fc_rport_priv *rdata)\n{\n\tconst char *cp;\n\n\tcp = fc_rport_state_names[rdata->rp_state];\n\tif (!cp)\n\t\tcp = \"Unknown\";\n\treturn cp;\n}\n\n \nvoid fc_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout)\n{\n\tif (timeout)\n\t\trport->dev_loss_tmo = timeout;\n\telse\n\t\trport->dev_loss_tmo = 1;\n}\nEXPORT_SYMBOL(fc_set_rport_loss_tmo);\n\n \nstatic unsigned int fc_plogi_get_maxframe(struct fc_els_flogi *flp,\n\t\t\t\t\t  unsigned int maxval)\n{\n\tunsigned int mfs;\n\n\t \n\tmfs = ntohs(flp->fl_csp.sp_bb_data) & FC_SP_BB_DATA_MASK;\n\tif (mfs >= FC_SP_MIN_MAX_PAYLOAD && mfs < maxval)\n\t\tmaxval = mfs;\n\tmfs = ntohs(flp->fl_cssp[3 - 1].cp_rdfs);\n\tif (mfs >= FC_SP_MIN_MAX_PAYLOAD && mfs < maxval)\n\t\tmaxval = mfs;\n\treturn maxval;\n}\n\n \nstatic void fc_rport_state_enter(struct fc_rport_priv *rdata,\n\t\t\t\t enum fc_rport_state new)\n{\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tif (rdata->rp_state != new)\n\t\trdata->retries = 0;\n\trdata->rp_state = new;\n}\n\n \nstatic void fc_rport_work(struct work_struct *work)\n{\n\tu32 port_id;\n\tstruct fc_rport_priv *rdata =\n\t\tcontainer_of(work, struct fc_rport_priv, event_work);\n\tstruct fc_rport_libfc_priv *rpriv;\n\tenum fc_rport_event event;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_rport_operations *rport_ops;\n\tstruct fc_rport_identifiers ids;\n\tstruct fc_rport *rport;\n\tstruct fc4_prov *prov;\n\tu8 type;\n\n\tmutex_lock(&rdata->rp_mutex);\n\tevent = rdata->event;\n\trport_ops = rdata->ops;\n\trport = rdata->rport;\n\n\tFC_RPORT_DBG(rdata, \"work event %u\\n\", event);\n\n\tswitch (event) {\n\tcase RPORT_EV_READY:\n\t\tids = rdata->ids;\n\t\trdata->event = RPORT_EV_NONE;\n\t\trdata->major_retries = 0;\n\t\tkref_get(&rdata->kref);\n\t\tmutex_unlock(&rdata->rp_mutex);\n\n\t\tif (!rport) {\n\t\t\tFC_RPORT_DBG(rdata, \"No rport!\\n\");\n\t\t\trport = fc_remote_port_add(lport->host, 0, &ids);\n\t\t}\n\t\tif (!rport) {\n\t\t\tFC_RPORT_DBG(rdata, \"Failed to add the rport\\n\");\n\t\t\tfc_rport_logoff(rdata);\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\t\treturn;\n\t\t}\n\t\tmutex_lock(&rdata->rp_mutex);\n\t\tif (rdata->rport)\n\t\t\tFC_RPORT_DBG(rdata, \"rport already allocated\\n\");\n\t\trdata->rport = rport;\n\t\trport->maxframe_size = rdata->maxframe_size;\n\t\trport->supported_classes = rdata->supported_classes;\n\n\t\trpriv = rport->dd_data;\n\t\trpriv->local_port = lport;\n\t\trpriv->rp_state = rdata->rp_state;\n\t\trpriv->flags = rdata->flags;\n\t\trpriv->e_d_tov = rdata->e_d_tov;\n\t\trpriv->r_a_tov = rdata->r_a_tov;\n\t\tmutex_unlock(&rdata->rp_mutex);\n\n\t\tif (rport_ops && rport_ops->event_callback) {\n\t\t\tFC_RPORT_DBG(rdata, \"callback ev %d\\n\", event);\n\t\t\trport_ops->event_callback(lport, rdata, event);\n\t\t}\n\t\tif (rdata->lld_event_callback) {\n\t\t\tFC_RPORT_DBG(rdata, \"lld callback ev %d\\n\", event);\n\t\t\trdata->lld_event_callback(lport, rdata, event);\n\t\t}\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\tbreak;\n\n\tcase RPORT_EV_FAILED:\n\tcase RPORT_EV_LOGO:\n\tcase RPORT_EV_STOP:\n\t\tif (rdata->prli_count) {\n\t\t\tmutex_lock(&fc_prov_mutex);\n\t\t\tfor (type = 1; type < FC_FC4_PROV_SIZE; type++) {\n\t\t\t\tprov = fc_passive_prov[type];\n\t\t\t\tif (prov && prov->prlo)\n\t\t\t\t\tprov->prlo(rdata);\n\t\t\t}\n\t\t\tmutex_unlock(&fc_prov_mutex);\n\t\t}\n\t\tport_id = rdata->ids.port_id;\n\t\tmutex_unlock(&rdata->rp_mutex);\n\n\t\tif (rport_ops && rport_ops->event_callback) {\n\t\t\tFC_RPORT_DBG(rdata, \"callback ev %d\\n\", event);\n\t\t\trport_ops->event_callback(lport, rdata, event);\n\t\t}\n\t\tif (rdata->lld_event_callback) {\n\t\t\tFC_RPORT_DBG(rdata, \"lld callback ev %d\\n\", event);\n\t\t\trdata->lld_event_callback(lport, rdata, event);\n\t\t}\n\t\tif (cancel_delayed_work_sync(&rdata->retry_work))\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\n\t\t \n\t\tlport->tt.exch_mgr_reset(lport, 0, port_id);\n\t\tlport->tt.exch_mgr_reset(lport, port_id, 0);\n\n\t\tif (rport) {\n\t\t\trpriv = rport->dd_data;\n\t\t\trpriv->rp_state = RPORT_ST_DELETE;\n\t\t\tmutex_lock(&rdata->rp_mutex);\n\t\t\trdata->rport = NULL;\n\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t\tfc_remote_port_delete(rport);\n\t\t}\n\n\t\tmutex_lock(&rdata->rp_mutex);\n\t\tif (rdata->rp_state == RPORT_ST_DELETE) {\n\t\t\tif (port_id == FC_FID_DIR_SERV) {\n\t\t\t\trdata->event = RPORT_EV_NONE;\n\t\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\t\t} else if ((rdata->flags & FC_RP_STARTED) &&\n\t\t\t\t   rdata->major_retries <\n\t\t\t\t   lport->max_rport_retry_count) {\n\t\t\t\trdata->major_retries++;\n\t\t\t\trdata->event = RPORT_EV_NONE;\n\t\t\t\tFC_RPORT_DBG(rdata, \"work restart\\n\");\n\t\t\t\tfc_rport_enter_flogi(rdata);\n\t\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t\t} else {\n\t\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t\t\tFC_RPORT_DBG(rdata, \"work delete\\n\");\n\t\t\t\tmutex_lock(&lport->disc.disc_mutex);\n\t\t\t\tlist_del_rcu(&rdata->peers);\n\t\t\t\tmutex_unlock(&lport->disc.disc_mutex);\n\t\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trdata->event = RPORT_EV_NONE;\n\t\t\tif (rdata->rp_state == RPORT_ST_READY) {\n\t\t\t\tFC_RPORT_DBG(rdata, \"work reopen\\n\");\n\t\t\t\tfc_rport_enter_ready(rdata);\n\t\t\t}\n\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\tbreak;\n\t}\n\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\n \nint fc_rport_login(struct fc_rport_priv *rdata)\n{\n\tmutex_lock(&rdata->rp_mutex);\n\n\tif (rdata->flags & FC_RP_STARTED) {\n\t\tFC_RPORT_DBG(rdata, \"port already started\\n\");\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\treturn 0;\n\t}\n\n\trdata->flags |= FC_RP_STARTED;\n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_READY:\n\t\tFC_RPORT_DBG(rdata, \"ADISC port\\n\");\n\t\tfc_rport_enter_adisc(rdata);\n\t\tbreak;\n\tcase RPORT_ST_DELETE:\n\t\tFC_RPORT_DBG(rdata, \"Restart deleted port\\n\");\n\t\tbreak;\n\tcase RPORT_ST_INIT:\n\t\tFC_RPORT_DBG(rdata, \"Login to port\\n\");\n\t\tfc_rport_enter_flogi(rdata);\n\t\tbreak;\n\tdefault:\n\t\tFC_RPORT_DBG(rdata, \"Login in progress, state %s\\n\",\n\t\t\t     fc_rport_state(rdata));\n\t\tbreak;\n\t}\n\tmutex_unlock(&rdata->rp_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_rport_login);\n\n \nstatic void fc_rport_enter_delete(struct fc_rport_priv *rdata,\n\t\t\t\t  enum fc_rport_event event)\n{\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tif (rdata->rp_state == RPORT_ST_DELETE)\n\t\treturn;\n\n\tFC_RPORT_DBG(rdata, \"Delete port\\n\");\n\n\tfc_rport_state_enter(rdata, RPORT_ST_DELETE);\n\n\tif (rdata->event == RPORT_EV_NONE) {\n\t\tkref_get(&rdata->kref);\n\t\tif (!queue_work(rport_event_queue, &rdata->event_work))\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n\n\trdata->event = event;\n}\n\n \nint fc_rport_logoff(struct fc_rport_priv *rdata)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tu32 port_id = rdata->ids.port_id;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Remove port\\n\");\n\n\trdata->flags &= ~FC_RP_STARTED;\n\tif (rdata->rp_state == RPORT_ST_DELETE) {\n\t\tFC_RPORT_DBG(rdata, \"Port in Delete state, not removing\\n\");\n\t\tgoto out;\n\t}\n\t \n\tlport->tt.exch_mgr_reset(lport, 0, port_id);\n\tlport->tt.exch_mgr_reset(lport, port_id, 0);\n\n\tfc_rport_enter_logo(rdata);\n\n\t \n\tfc_rport_enter_delete(rdata, RPORT_EV_STOP);\nout:\n\tmutex_unlock(&rdata->rp_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_rport_logoff);\n\n \nstatic void fc_rport_enter_ready(struct fc_rport_priv *rdata)\n{\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tfc_rport_state_enter(rdata, RPORT_ST_READY);\n\n\tFC_RPORT_DBG(rdata, \"Port is Ready\\n\");\n\n\tkref_get(&rdata->kref);\n\tif (rdata->event == RPORT_EV_NONE &&\n\t    !queue_work(rport_event_queue, &rdata->event_work))\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\n\trdata->event = RPORT_EV_READY;\n}\n\n \nstatic void fc_rport_timeout(struct work_struct *work)\n{\n\tstruct fc_rport_priv *rdata =\n\t\tcontainer_of(work, struct fc_rport_priv, retry_work.work);\n\n\tmutex_lock(&rdata->rp_mutex);\n\tFC_RPORT_DBG(rdata, \"Port timeout, state %s\\n\", fc_rport_state(rdata));\n\n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_FLOGI:\n\t\tfc_rport_enter_flogi(rdata);\n\t\tbreak;\n\tcase RPORT_ST_PLOGI:\n\t\tfc_rport_enter_plogi(rdata);\n\t\tbreak;\n\tcase RPORT_ST_PRLI:\n\t\tfc_rport_enter_prli(rdata);\n\t\tbreak;\n\tcase RPORT_ST_RTV:\n\t\tfc_rport_enter_rtv(rdata);\n\t\tbreak;\n\tcase RPORT_ST_ADISC:\n\t\tfc_rport_enter_adisc(rdata);\n\t\tbreak;\n\tcase RPORT_ST_PLOGI_WAIT:\n\tcase RPORT_ST_READY:\n\tcase RPORT_ST_INIT:\n\tcase RPORT_ST_DELETE:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&rdata->rp_mutex);\n\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\n \nstatic void fc_rport_error(struct fc_rport_priv *rdata, int err)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Error %d in state %s, retries %d\\n\",\n\t\t     -err, fc_rport_state(rdata), rdata->retries);\n\n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_FLOGI:\n\t\trdata->flags &= ~FC_RP_STARTED;\n\t\tfc_rport_enter_delete(rdata, RPORT_EV_FAILED);\n\t\tbreak;\n\tcase RPORT_ST_PLOGI:\n\t\tif (lport->point_to_multipoint) {\n\t\t\trdata->flags &= ~FC_RP_STARTED;\n\t\t\tfc_rport_enter_delete(rdata, RPORT_EV_FAILED);\n\t\t} else\n\t\t\tfc_rport_enter_logo(rdata);\n\t\tbreak;\n\tcase RPORT_ST_RTV:\n\t\tfc_rport_enter_ready(rdata);\n\t\tbreak;\n\tcase RPORT_ST_PRLI:\n\t\tfc_rport_enter_plogi(rdata);\n\t\tbreak;\n\tcase RPORT_ST_ADISC:\n\t\tfc_rport_enter_logo(rdata);\n\t\tbreak;\n\tcase RPORT_ST_PLOGI_WAIT:\n\tcase RPORT_ST_DELETE:\n\tcase RPORT_ST_READY:\n\tcase RPORT_ST_INIT:\n\t\tbreak;\n\t}\n}\n\n \nstatic void fc_rport_error_retry(struct fc_rport_priv *rdata, int err)\n{\n\tunsigned long delay = msecs_to_jiffies(rdata->e_d_tov);\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\t \n\tif (err == -FC_EX_CLOSED)\n\t\tgoto out;\n\n\tif (rdata->retries < rdata->local_port->max_rport_retry_count) {\n\t\tFC_RPORT_DBG(rdata, \"Error %d in state %s, retrying\\n\",\n\t\t\t     err, fc_rport_state(rdata));\n\t\trdata->retries++;\n\t\t \n\t\tif (err == -FC_EX_TIMEOUT)\n\t\t\tdelay = 0;\n\t\tkref_get(&rdata->kref);\n\t\tif (!schedule_delayed_work(&rdata->retry_work, delay))\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\treturn;\n\t}\n\nout:\n\tfc_rport_error(rdata, err);\n}\n\n \nstatic int fc_rport_login_complete(struct fc_rport_priv *rdata,\n\t\t\t\t   struct fc_frame *fp)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_els_flogi *flogi;\n\tunsigned int e_d_tov;\n\tu16 csp_flags;\n\n\tflogi = fc_frame_payload_get(fp, sizeof(*flogi));\n\tif (!flogi)\n\t\treturn -EINVAL;\n\n\tcsp_flags = ntohs(flogi->fl_csp.sp_features);\n\n\tif (fc_frame_payload_op(fp) == ELS_FLOGI) {\n\t\tif (csp_flags & FC_SP_FT_FPORT) {\n\t\t\tFC_RPORT_DBG(rdata, \"Fabric bit set in FLOGI\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\n\t\t \n\t\te_d_tov = ntohl(flogi->fl_csp.sp_e_d_tov);\n\t\tif (csp_flags & FC_SP_FT_EDTR)\n\t\t\te_d_tov /= 1000000;\n\t\tif (e_d_tov > rdata->e_d_tov)\n\t\t\trdata->e_d_tov = e_d_tov;\n\t}\n\trdata->maxframe_size = fc_plogi_get_maxframe(flogi, lport->mfs);\n\treturn 0;\n}\n\n \nstatic void fc_rport_flogi_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t\tvoid *rp_arg)\n{\n\tstruct fc_rport_priv *rdata = rp_arg;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_els_flogi *flogi;\n\tunsigned int r_a_tov;\n\tu8 opcode;\n\tint err = 0;\n\n\tFC_RPORT_DBG(rdata, \"Received a FLOGI %s\\n\",\n\t\t     IS_ERR(fp) ? \"error\" : fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\tgoto put;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tif (rdata->rp_state != RPORT_ST_FLOGI) {\n\t\tFC_RPORT_DBG(rdata, \"Received a FLOGI response, but in state \"\n\t\t\t     \"%s\\n\", fc_rport_state(rdata));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error(rdata, PTR_ERR(fp));\n\t\tgoto err;\n\t}\n\topcode = fc_frame_payload_op(fp);\n\tif (opcode == ELS_LS_RJT) {\n\t\tstruct fc_els_ls_rjt *rjt;\n\n\t\trjt = fc_frame_payload_get(fp, sizeof(*rjt));\n\t\tFC_RPORT_DBG(rdata, \"FLOGI ELS rejected, reason %x expl %x\\n\",\n\t\t\t     rjt->er_reason, rjt->er_explan);\n\t\terr = -FC_EX_ELS_RJT;\n\t\tgoto bad;\n\t} else if (opcode != ELS_LS_ACC) {\n\t\tFC_RPORT_DBG(rdata, \"FLOGI ELS invalid opcode %x\\n\", opcode);\n\t\terr = -FC_EX_ELS_RJT;\n\t\tgoto bad;\n\t}\n\tif (fc_rport_login_complete(rdata, fp)) {\n\t\tFC_RPORT_DBG(rdata, \"FLOGI failed, no login\\n\");\n\t\terr = -FC_EX_INV_LOGIN;\n\t\tgoto bad;\n\t}\n\n\tflogi = fc_frame_payload_get(fp, sizeof(*flogi));\n\tif (!flogi) {\n\t\terr = -FC_EX_ALLOC_ERR;\n\t\tgoto bad;\n\t}\n\tr_a_tov = ntohl(flogi->fl_csp.sp_r_a_tov);\n\tif (r_a_tov > rdata->r_a_tov)\n\t\trdata->r_a_tov = r_a_tov;\n\n\tif (rdata->ids.port_name < lport->wwpn)\n\t\tfc_rport_enter_plogi(rdata);\n\telse\n\t\tfc_rport_state_enter(rdata, RPORT_ST_PLOGI_WAIT);\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\nput:\n\tkref_put(&rdata->kref, fc_rport_destroy);\n\treturn;\nbad:\n\tFC_RPORT_DBG(rdata, \"Bad FLOGI response\\n\");\n\tfc_rport_error_retry(rdata, err);\n\tgoto out;\n}\n\n \nstatic void fc_rport_enter_flogi(struct fc_rport_priv *rdata)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tif (!lport->point_to_multipoint)\n\t\treturn fc_rport_enter_plogi(rdata);\n\n\tFC_RPORT_DBG(rdata, \"Entered FLOGI state from %s state\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tfc_rport_state_enter(rdata, RPORT_ST_FLOGI);\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_flogi));\n\tif (!fp)\n\t\treturn fc_rport_error_retry(rdata, -FC_EX_ALLOC_ERR);\n\n\tkref_get(&rdata->kref);\n\tif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_FLOGI,\n\t\t\t\t  fc_rport_flogi_resp, rdata,\n\t\t\t\t  2 * lport->r_a_tov)) {\n\t\tfc_rport_error_retry(rdata, -FC_EX_XMIT_ERR);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n}\n\n \nstatic void fc_rport_recv_flogi_req(struct fc_lport *lport,\n\t\t\t\t    struct fc_frame *rx_fp)\n{\n\tstruct fc_els_flogi *flp;\n\tstruct fc_rport_priv *rdata;\n\tstruct fc_frame *fp = rx_fp;\n\tstruct fc_seq_els_data rjt_data;\n\tu32 sid;\n\n\tsid = fc_frame_sid(fp);\n\n\tFC_RPORT_ID_DBG(lport, sid, \"Received FLOGI request\\n\");\n\n\tif (!lport->point_to_multipoint) {\n\t\trjt_data.reason = ELS_RJT_UNSUP;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tgoto reject;\n\t}\n\n\tflp = fc_frame_payload_get(fp, sizeof(*flp));\n\tif (!flp) {\n\t\trjt_data.reason = ELS_RJT_LOGIC;\n\t\trjt_data.explan = ELS_EXPL_INV_LEN;\n\t\tgoto reject;\n\t}\n\n\trdata = fc_rport_lookup(lport, sid);\n\tif (!rdata) {\n\t\trjt_data.reason = ELS_RJT_FIP;\n\t\trjt_data.explan = ELS_EXPL_NOT_NEIGHBOR;\n\t\tgoto reject;\n\t}\n\tmutex_lock(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Received FLOGI in %s state\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_INIT:\n\t\t \n\t\tbreak;\n\tcase RPORT_ST_DELETE:\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\trjt_data.reason = ELS_RJT_FIP;\n\t\trjt_data.explan = ELS_EXPL_NOT_NEIGHBOR;\n\t\tgoto reject_put;\n\tcase RPORT_ST_FLOGI:\n\tcase RPORT_ST_PLOGI_WAIT:\n\tcase RPORT_ST_PLOGI:\n\t\tbreak;\n\tcase RPORT_ST_PRLI:\n\tcase RPORT_ST_RTV:\n\tcase RPORT_ST_READY:\n\tcase RPORT_ST_ADISC:\n\t\t \n\t\tfc_rport_enter_delete(rdata, RPORT_EV_LOGO);\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\trjt_data.reason = ELS_RJT_BUSY;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tgoto reject_put;\n\t}\n\tif (fc_rport_login_complete(rdata, fp)) {\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\trjt_data.reason = ELS_RJT_LOGIC;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tgoto reject_put;\n\t}\n\n\tfp = fc_frame_alloc(lport, sizeof(*flp));\n\tif (!fp)\n\t\tgoto out;\n\n\tfc_flogi_fill(lport, fp);\n\tflp = fc_frame_payload_get(fp, sizeof(*flp));\n\tflp->fl_cmd = ELS_LS_ACC;\n\n\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\n\n\t \n\tif (rdata->rp_state != RPORT_ST_FLOGI) {\n\t\tif (rdata->ids.port_name < lport->wwpn)\n\t\t\tfc_rport_enter_plogi(rdata);\n\t\telse\n\t\t\tfc_rport_state_enter(rdata, RPORT_ST_PLOGI_WAIT);\n\t}\nout:\n\tmutex_unlock(&rdata->rp_mutex);\n\tkref_put(&rdata->kref, fc_rport_destroy);\n\tfc_frame_free(rx_fp);\n\treturn;\n\nreject_put:\n\tkref_put(&rdata->kref, fc_rport_destroy);\nreject:\n\tfc_seq_els_rsp_send(rx_fp, ELS_LS_RJT, &rjt_data);\n\tfc_frame_free(rx_fp);\n}\n\n \nstatic void fc_rport_plogi_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t\tvoid *rdata_arg)\n{\n\tstruct fc_rport_priv *rdata = rdata_arg;\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_els_flogi *plp = NULL;\n\tu16 csp_seq;\n\tu16 cssp_seq;\n\tu8 op;\n\n\tFC_RPORT_DBG(rdata, \"Received a PLOGI %s\\n\", fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\tgoto put;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tif (rdata->rp_state != RPORT_ST_PLOGI) {\n\t\tFC_RPORT_DBG(rdata, \"Received a PLOGI response, but in state \"\n\t\t\t     \"%s\\n\", fc_rport_state(rdata));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error_retry(rdata, PTR_ERR(fp));\n\t\tgoto err;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC &&\n\t    (plp = fc_frame_payload_get(fp, sizeof(*plp))) != NULL) {\n\t\trdata->ids.port_name = get_unaligned_be64(&plp->fl_wwpn);\n\t\trdata->ids.node_name = get_unaligned_be64(&plp->fl_wwnn);\n\n\t\t \n\t\trdata->sp_features = ntohs(plp->fl_csp.sp_features);\n\n\t\tif (lport->point_to_multipoint)\n\t\t\tfc_rport_login_complete(rdata, fp);\n\t\tcsp_seq = ntohs(plp->fl_csp.sp_tot_seq);\n\t\tcssp_seq = ntohs(plp->fl_cssp[3 - 1].cp_con_seq);\n\t\tif (cssp_seq < csp_seq)\n\t\t\tcsp_seq = cssp_seq;\n\t\trdata->max_seq = csp_seq;\n\t\trdata->maxframe_size = fc_plogi_get_maxframe(plp, lport->mfs);\n\t\tfc_rport_enter_prli(rdata);\n\t} else {\n\t\tstruct fc_els_ls_rjt *rjt;\n\n\t\trjt = fc_frame_payload_get(fp, sizeof(*rjt));\n\t\tif (!rjt)\n\t\t\tFC_RPORT_DBG(rdata, \"PLOGI bad response\\n\");\n\t\telse\n\t\t\tFC_RPORT_DBG(rdata, \"PLOGI ELS rejected, reason %x expl %x\\n\",\n\t\t\t\t     rjt->er_reason, rjt->er_explan);\n\t\tfc_rport_error_retry(rdata, -FC_EX_ELS_RJT);\n\t}\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\nput:\n\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\nstatic bool\nfc_rport_compatible_roles(struct fc_lport *lport, struct fc_rport_priv *rdata)\n{\n\tif (rdata->ids.roles == FC_PORT_ROLE_UNKNOWN)\n\t\treturn true;\n\tif ((rdata->ids.roles & FC_PORT_ROLE_FCP_TARGET) &&\n\t    (lport->service_params & FCP_SPPF_INIT_FCN))\n\t\treturn true;\n\tif ((rdata->ids.roles & FC_PORT_ROLE_FCP_INITIATOR) &&\n\t    (lport->service_params & FCP_SPPF_TARG_FCN))\n\t\treturn true;\n\treturn false;\n}\n\n \nstatic void fc_rport_enter_plogi(struct fc_rport_priv *rdata)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tif (!fc_rport_compatible_roles(lport, rdata)) {\n\t\tFC_RPORT_DBG(rdata, \"PLOGI suppressed for incompatible role\\n\");\n\t\tfc_rport_state_enter(rdata, RPORT_ST_PLOGI_WAIT);\n\t\treturn;\n\t}\n\n\tFC_RPORT_DBG(rdata, \"Port entered PLOGI state from %s state\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tfc_rport_state_enter(rdata, RPORT_ST_PLOGI);\n\n\trdata->maxframe_size = FC_MIN_MAX_PAYLOAD;\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_flogi));\n\tif (!fp) {\n\t\tFC_RPORT_DBG(rdata, \"%s frame alloc failed\\n\", __func__);\n\t\tfc_rport_error_retry(rdata, -FC_EX_ALLOC_ERR);\n\t\treturn;\n\t}\n\trdata->e_d_tov = lport->e_d_tov;\n\n\tkref_get(&rdata->kref);\n\tif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_PLOGI,\n\t\t\t\t  fc_rport_plogi_resp, rdata,\n\t\t\t\t  2 * lport->r_a_tov)) {\n\t\tfc_rport_error_retry(rdata, -FC_EX_XMIT_ERR);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n}\n\n \nstatic void fc_rport_prli_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t       void *rdata_arg)\n{\n\tstruct fc_rport_priv *rdata = rdata_arg;\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\tstruct fc_els_spp temp_spp;\n\tstruct fc_els_ls_rjt *rjt;\n\tstruct fc4_prov *prov;\n\tu32 roles = FC_RPORT_ROLE_UNKNOWN;\n\tu32 fcp_parm = 0;\n\tu8 op;\n\tenum fc_els_spp_resp resp_code;\n\n\tFC_RPORT_DBG(rdata, \"Received a PRLI %s\\n\", fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\tgoto put;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tif (rdata->rp_state != RPORT_ST_PRLI) {\n\t\tFC_RPORT_DBG(rdata, \"Received a PRLI response, but in state \"\n\t\t\t     \"%s\\n\", fc_rport_state(rdata));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error_retry(rdata, PTR_ERR(fp));\n\t\tgoto err;\n\t}\n\n\t \n\trdata->ids.roles = FC_RPORT_ROLE_UNKNOWN;\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC) {\n\t\tpp = fc_frame_payload_get(fp, sizeof(*pp));\n\t\tif (!pp) {\n\t\t\tfc_rport_error_retry(rdata, -FC_EX_SEQ_ERR);\n\t\t\tgoto out;\n\t\t}\n\n\t\tresp_code = (pp->spp.spp_flags & FC_SPP_RESP_MASK);\n\t\tFC_RPORT_DBG(rdata, \"PRLI spp_flags = 0x%x spp_type 0x%x\\n\",\n\t\t\t     pp->spp.spp_flags, pp->spp.spp_type);\n\n\t\trdata->spp_type = pp->spp.spp_type;\n\t\tif (resp_code != FC_SPP_RESP_ACK) {\n\t\t\tif (resp_code == FC_SPP_RESP_CONF)\n\t\t\t\tfc_rport_error(rdata, -FC_EX_SEQ_ERR);\n\t\t\telse\n\t\t\t\tfc_rport_error_retry(rdata, -FC_EX_SEQ_ERR);\n\t\t\tgoto out;\n\t\t}\n\t\tif (pp->prli.prli_spp_len < sizeof(pp->spp)) {\n\t\t\tfc_rport_error_retry(rdata, -FC_EX_SEQ_ERR);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfcp_parm = ntohl(pp->spp.spp_params);\n\t\tif (fcp_parm & FCP_SPPF_RETRY)\n\t\t\trdata->flags |= FC_RP_FLAGS_RETRY;\n\t\tif (fcp_parm & FCP_SPPF_CONF_COMPL)\n\t\t\trdata->flags |= FC_RP_FLAGS_CONF_REQ;\n\n\t\t \n\t\tif (rdata->spp_type < FC_FC4_PROV_SIZE) {\n\t\t\tprov = fc_passive_prov[rdata->spp_type];\n\t\t\tif (prov) {\n\t\t\t\tmemset(&temp_spp, 0, sizeof(temp_spp));\n\t\t\t\tprov->prli(rdata, pp->prli.prli_spp_len,\n\t\t\t\t\t   &pp->spp, &temp_spp);\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (rdata->spp_type != FC_TYPE_FCP ||\n\t\t    !(pp->spp.spp_flags & FC_SPP_EST_IMG_PAIR)) {\n\t\t\t \n\t\t\tfcp_parm &= ~FCP_SPPF_TARG_FCN;\n\t\t}\n\t\trdata->supported_classes = FC_COS_CLASS3;\n\t\tif (fcp_parm & FCP_SPPF_INIT_FCN)\n\t\t\troles |= FC_RPORT_ROLE_FCP_INITIATOR;\n\t\tif (fcp_parm & FCP_SPPF_TARG_FCN)\n\t\t\troles |= FC_RPORT_ROLE_FCP_TARGET;\n\n\t\trdata->ids.roles = roles;\n\t\tfc_rport_enter_rtv(rdata);\n\n\t} else {\n\t\trjt = fc_frame_payload_get(fp, sizeof(*rjt));\n\t\tif (!rjt)\n\t\t\tFC_RPORT_DBG(rdata, \"PRLI bad response\\n\");\n\t\telse {\n\t\t\tFC_RPORT_DBG(rdata, \"PRLI ELS rejected, reason %x expl %x\\n\",\n\t\t\t\t     rjt->er_reason, rjt->er_explan);\n\t\t\tif (rjt->er_reason == ELS_RJT_UNAB &&\n\t\t\t    rjt->er_explan == ELS_EXPL_PLOGI_REQD) {\n\t\t\t\tfc_rport_enter_plogi(rdata);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfc_rport_error_retry(rdata, FC_EX_ELS_RJT);\n\t}\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\nput:\n\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\n \nstatic void fc_rport_enter_prli(struct fc_rport_priv *rdata)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\tstruct fc_frame *fp;\n\tstruct fc4_prov *prov;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\t \n\tif (rdata->ids.port_id >= FC_FID_DOM_MGR) {\n\t\tfc_rport_enter_ready(rdata);\n\t\treturn;\n\t}\n\n\t \n\tif (!(lport->service_params & FCP_SPPF_INIT_FCN)) {\n\t\t    fc_rport_enter_ready(rdata);\n\t\t    return;\n\t}\n\n\tFC_RPORT_DBG(rdata, \"Port entered PRLI state from %s state\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tfc_rport_state_enter(rdata, RPORT_ST_PRLI);\n\n\tfp = fc_frame_alloc(lport, sizeof(*pp));\n\tif (!fp) {\n\t\tfc_rport_error_retry(rdata, -FC_EX_ALLOC_ERR);\n\t\treturn;\n\t}\n\n\tfc_prli_fill(lport, fp);\n\n\tprov = fc_passive_prov[FC_TYPE_FCP];\n\tif (prov) {\n\t\tpp = fc_frame_payload_get(fp, sizeof(*pp));\n\t\tprov->prli(rdata, sizeof(pp->spp), NULL, &pp->spp);\n\t}\n\n\tfc_fill_fc_hdr(fp, FC_RCTL_ELS_REQ, rdata->ids.port_id,\n\t\t       fc_host_port_id(lport->host), FC_TYPE_ELS,\n\t\t       FC_FC_FIRST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\n\n\tkref_get(&rdata->kref);\n\tif (!fc_exch_seq_send(lport, fp, fc_rport_prli_resp,\n\t\t\t      NULL, rdata, 2 * lport->r_a_tov)) {\n\t\tfc_rport_error_retry(rdata, -FC_EX_XMIT_ERR);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n}\n\n \nstatic void fc_rport_rtv_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t      void *rdata_arg)\n{\n\tstruct fc_rport_priv *rdata = rdata_arg;\n\tu8 op;\n\n\tFC_RPORT_DBG(rdata, \"Received a RTV %s\\n\", fc_els_resp_type(fp));\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\tgoto put;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tif (rdata->rp_state != RPORT_ST_RTV) {\n\t\tFC_RPORT_DBG(rdata, \"Received a RTV response, but in state \"\n\t\t\t     \"%s\\n\", fc_rport_state(rdata));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error(rdata, PTR_ERR(fp));\n\t\tgoto err;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tif (op == ELS_LS_ACC) {\n\t\tstruct fc_els_rtv_acc *rtv;\n\t\tu32 toq;\n\t\tu32 tov;\n\n\t\trtv = fc_frame_payload_get(fp, sizeof(*rtv));\n\t\tif (rtv) {\n\t\t\ttoq = ntohl(rtv->rtv_toq);\n\t\t\ttov = ntohl(rtv->rtv_r_a_tov);\n\t\t\tif (tov == 0)\n\t\t\t\ttov = 1;\n\t\t\tif (tov > rdata->r_a_tov)\n\t\t\t\trdata->r_a_tov = tov;\n\t\t\ttov = ntohl(rtv->rtv_e_d_tov);\n\t\t\tif (toq & FC_ELS_RTV_EDRES)\n\t\t\t\ttov /= 1000000;\n\t\t\tif (tov == 0)\n\t\t\t\ttov = 1;\n\t\t\tif (tov > rdata->e_d_tov)\n\t\t\t\trdata->e_d_tov = tov;\n\t\t}\n\t}\n\n\tfc_rport_enter_ready(rdata);\n\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\nput:\n\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\n \nstatic void fc_rport_enter_rtv(struct fc_rport_priv *rdata)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_lport *lport = rdata->local_port;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Port entered RTV state from %s state\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tfc_rport_state_enter(rdata, RPORT_ST_RTV);\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_rtv));\n\tif (!fp) {\n\t\tfc_rport_error_retry(rdata, -FC_EX_ALLOC_ERR);\n\t\treturn;\n\t}\n\n\tkref_get(&rdata->kref);\n\tif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_RTV,\n\t\t\t\t  fc_rport_rtv_resp, rdata,\n\t\t\t\t  2 * lport->r_a_tov)) {\n\t\tfc_rport_error_retry(rdata, -FC_EX_XMIT_ERR);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n}\n\n \nstatic void fc_rport_recv_rtv_req(struct fc_rport_priv *rdata,\n\t\t\t\t  struct fc_frame *in_fp)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\tstruct fc_els_rtv_acc *rtv;\n\tstruct fc_seq_els_data rjt_data;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Received RTV request\\n\");\n\n\tfp = fc_frame_alloc(lport, sizeof(*rtv));\n\tif (!fp) {\n\t\trjt_data.reason = ELS_RJT_UNAB;\n\t\trjt_data.explan = ELS_EXPL_INSUF_RES;\n\t\tfc_seq_els_rsp_send(in_fp, ELS_LS_RJT, &rjt_data);\n\t\tgoto drop;\n\t}\n\trtv = fc_frame_payload_get(fp, sizeof(*rtv));\n\trtv->rtv_cmd = ELS_LS_ACC;\n\trtv->rtv_r_a_tov = htonl(lport->r_a_tov);\n\trtv->rtv_e_d_tov = htonl(lport->e_d_tov);\n\trtv->rtv_toq = 0;\n\tfc_fill_reply_hdr(fp, in_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\ndrop:\n\tfc_frame_free(in_fp);\n}\n\n \nstatic void fc_rport_logo_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t       void *rdata_arg)\n{\n\tstruct fc_rport_priv *rdata = rdata_arg;\n\tstruct fc_lport *lport = rdata->local_port;\n\n\tFC_RPORT_ID_DBG(lport, fc_seq_exch(sp)->did,\n\t\t\t\"Received a LOGO %s\\n\", fc_els_resp_type(fp));\n\tif (!IS_ERR(fp))\n\t\tfc_frame_free(fp);\n\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\n \nstatic void fc_rport_enter_logo(struct fc_rport_priv *rdata)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Port sending LOGO from %s state\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_logo));\n\tif (!fp)\n\t\treturn;\n\tkref_get(&rdata->kref);\n\tif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_LOGO,\n\t\t\t\t  fc_rport_logo_resp, rdata, 0))\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\n \nstatic void fc_rport_adisc_resp(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t\tvoid *rdata_arg)\n{\n\tstruct fc_rport_priv *rdata = rdata_arg;\n\tstruct fc_els_adisc *adisc;\n\tu8 op;\n\n\tFC_RPORT_DBG(rdata, \"Received a ADISC response\\n\");\n\n\tif (fp == ERR_PTR(-FC_EX_CLOSED))\n\t\tgoto put;\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tif (rdata->rp_state != RPORT_ST_ADISC) {\n\t\tFC_RPORT_DBG(rdata, \"Received a ADISC resp but in state %s\\n\",\n\t\t\t     fc_rport_state(rdata));\n\t\tif (IS_ERR(fp))\n\t\t\tgoto err;\n\t\tgoto out;\n\t}\n\n\tif (IS_ERR(fp)) {\n\t\tfc_rport_error(rdata, PTR_ERR(fp));\n\t\tgoto err;\n\t}\n\n\t \n\top = fc_frame_payload_op(fp);\n\tadisc = fc_frame_payload_get(fp, sizeof(*adisc));\n\tif (op != ELS_LS_ACC || !adisc ||\n\t    ntoh24(adisc->adisc_port_id) != rdata->ids.port_id ||\n\t    get_unaligned_be64(&adisc->adisc_wwpn) != rdata->ids.port_name ||\n\t    get_unaligned_be64(&adisc->adisc_wwnn) != rdata->ids.node_name) {\n\t\tFC_RPORT_DBG(rdata, \"ADISC error or mismatch\\n\");\n\t\tfc_rport_enter_flogi(rdata);\n\t} else {\n\t\tFC_RPORT_DBG(rdata, \"ADISC OK\\n\");\n\t\tfc_rport_enter_ready(rdata);\n\t}\nout:\n\tfc_frame_free(fp);\nerr:\n\tmutex_unlock(&rdata->rp_mutex);\nput:\n\tkref_put(&rdata->kref, fc_rport_destroy);\n}\n\n \nstatic void fc_rport_enter_adisc(struct fc_rport_priv *rdata)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"sending ADISC from %s state\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tfc_rport_state_enter(rdata, RPORT_ST_ADISC);\n\n\tfp = fc_frame_alloc(lport, sizeof(struct fc_els_adisc));\n\tif (!fp) {\n\t\tfc_rport_error_retry(rdata, -FC_EX_ALLOC_ERR);\n\t\treturn;\n\t}\n\tkref_get(&rdata->kref);\n\tif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, ELS_ADISC,\n\t\t\t\t  fc_rport_adisc_resp, rdata,\n\t\t\t\t  2 * lport->r_a_tov)) {\n\t\tfc_rport_error_retry(rdata, -FC_EX_XMIT_ERR);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t}\n}\n\n \nstatic void fc_rport_recv_adisc_req(struct fc_rport_priv *rdata,\n\t\t\t\t    struct fc_frame *in_fp)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\tstruct fc_els_adisc *adisc;\n\tstruct fc_seq_els_data rjt_data;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Received ADISC request\\n\");\n\n\tadisc = fc_frame_payload_get(in_fp, sizeof(*adisc));\n\tif (!adisc) {\n\t\trjt_data.reason = ELS_RJT_PROT;\n\t\trjt_data.explan = ELS_EXPL_INV_LEN;\n\t\tfc_seq_els_rsp_send(in_fp, ELS_LS_RJT, &rjt_data);\n\t\tgoto drop;\n\t}\n\n\tfp = fc_frame_alloc(lport, sizeof(*adisc));\n\tif (!fp)\n\t\tgoto drop;\n\tfc_adisc_fill(lport, fp);\n\tadisc = fc_frame_payload_get(fp, sizeof(*adisc));\n\tadisc->adisc_cmd = ELS_LS_ACC;\n\tfc_fill_reply_hdr(fp, in_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\ndrop:\n\tfc_frame_free(in_fp);\n}\n\n \nstatic void fc_rport_recv_rls_req(struct fc_rport_priv *rdata,\n\t\t\t\t  struct fc_frame *rx_fp)\n\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\tstruct fc_els_rls *rls;\n\tstruct fc_els_rls_resp *rsp;\n\tstruct fc_els_lesb *lesb;\n\tstruct fc_seq_els_data rjt_data;\n\tstruct fc_host_statistics *hst;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Received RLS request while in state %s\\n\",\n\t\t     fc_rport_state(rdata));\n\n\trls = fc_frame_payload_get(rx_fp, sizeof(*rls));\n\tif (!rls) {\n\t\trjt_data.reason = ELS_RJT_PROT;\n\t\trjt_data.explan = ELS_EXPL_INV_LEN;\n\t\tgoto out_rjt;\n\t}\n\n\tfp = fc_frame_alloc(lport, sizeof(*rsp));\n\tif (!fp) {\n\t\trjt_data.reason = ELS_RJT_UNAB;\n\t\trjt_data.explan = ELS_EXPL_INSUF_RES;\n\t\tgoto out_rjt;\n\t}\n\n\trsp = fc_frame_payload_get(fp, sizeof(*rsp));\n\tmemset(rsp, 0, sizeof(*rsp));\n\trsp->rls_cmd = ELS_LS_ACC;\n\tlesb = &rsp->rls_lesb;\n\tif (lport->tt.get_lesb) {\n\t\t \n\t\tlport->tt.get_lesb(lport, lesb);\n\t} else {\n\t\tfc_get_host_stats(lport->host);\n\t\thst = &lport->host_stats;\n\t\tlesb->lesb_link_fail = htonl(hst->link_failure_count);\n\t\tlesb->lesb_sync_loss = htonl(hst->loss_of_sync_count);\n\t\tlesb->lesb_sig_loss = htonl(hst->loss_of_signal_count);\n\t\tlesb->lesb_prim_err = htonl(hst->prim_seq_protocol_err_count);\n\t\tlesb->lesb_inv_word = htonl(hst->invalid_tx_word_count);\n\t\tlesb->lesb_inv_crc = htonl(hst->invalid_crc_count);\n\t}\n\n\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\n\tgoto out;\n\nout_rjt:\n\tfc_seq_els_rsp_send(rx_fp, ELS_LS_RJT, &rjt_data);\nout:\n\tfc_frame_free(rx_fp);\n}\n\n \nstatic void fc_rport_recv_els_req(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_rport_priv *rdata;\n\tstruct fc_seq_els_data els_data;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\trdata = fc_rport_lookup(lport, fc_frame_sid(fp));\n\tif (!rdata) {\n\t\tFC_RPORT_ID_DBG(lport, fc_frame_sid(fp),\n\t\t\t\t\"Received ELS 0x%02x from non-logged-in port\\n\",\n\t\t\t\tfc_frame_payload_op(fp));\n\t\tgoto reject;\n\t}\n\n\tmutex_lock(&rdata->rp_mutex);\n\n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_PRLI:\n\tcase RPORT_ST_RTV:\n\tcase RPORT_ST_READY:\n\tcase RPORT_ST_ADISC:\n\t\tbreak;\n\tcase RPORT_ST_PLOGI:\n\t\tif (fc_frame_payload_op(fp) == ELS_PRLI) {\n\t\t\tFC_RPORT_DBG(rdata, \"Reject ELS PRLI \"\n\t\t\t\t     \"while in state %s\\n\",\n\t\t\t\t     fc_rport_state(rdata));\n\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\t\tgoto busy;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tFC_RPORT_DBG(rdata,\n\t\t\t     \"Reject ELS 0x%02x while in state %s\\n\",\n\t\t\t     fc_frame_payload_op(fp), fc_rport_state(rdata));\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t\tgoto reject;\n\t}\n\n\tswitch (fc_frame_payload_op(fp)) {\n\tcase ELS_PRLI:\n\t\tfc_rport_recv_prli_req(rdata, fp);\n\t\tbreak;\n\tcase ELS_PRLO:\n\t\tfc_rport_recv_prlo_req(rdata, fp);\n\t\tbreak;\n\tcase ELS_ADISC:\n\t\tfc_rport_recv_adisc_req(rdata, fp);\n\t\tbreak;\n\tcase ELS_RRQ:\n\t\tfc_seq_els_rsp_send(fp, ELS_RRQ, NULL);\n\t\tfc_frame_free(fp);\n\t\tbreak;\n\tcase ELS_REC:\n\t\tfc_seq_els_rsp_send(fp, ELS_REC, NULL);\n\t\tfc_frame_free(fp);\n\t\tbreak;\n\tcase ELS_RLS:\n\t\tfc_rport_recv_rls_req(rdata, fp);\n\t\tbreak;\n\tcase ELS_RTV:\n\t\tfc_rport_recv_rtv_req(rdata, fp);\n\t\tbreak;\n\tdefault:\n\t\tfc_frame_free(fp);\t \n\t\tbreak;\n\t}\n\n\tmutex_unlock(&rdata->rp_mutex);\n\tkref_put(&rdata->kref, fc_rport_destroy);\n\treturn;\n\nreject:\n\tels_data.reason = ELS_RJT_UNAB;\n\tels_data.explan = ELS_EXPL_PLOGI_REQD;\n\tfc_seq_els_rsp_send(fp, ELS_LS_RJT, &els_data);\n\tfc_frame_free(fp);\n\treturn;\n\nbusy:\n\tels_data.reason = ELS_RJT_BUSY;\n\tels_data.explan = ELS_EXPL_NONE;\n\tfc_seq_els_rsp_send(fp, ELS_LS_RJT, &els_data);\n\tfc_frame_free(fp);\n\treturn;\n}\n\n \nvoid fc_rport_recv_req(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_seq_els_data els_data;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\t \n\tswitch (fc_frame_payload_op(fp)) {\n\tcase ELS_FLOGI:\n\t\tfc_rport_recv_flogi_req(lport, fp);\n\t\tbreak;\n\tcase ELS_PLOGI:\n\t\tfc_rport_recv_plogi_req(lport, fp);\n\t\tbreak;\n\tcase ELS_LOGO:\n\t\tfc_rport_recv_logo_req(lport, fp);\n\t\tbreak;\n\tcase ELS_PRLI:\n\tcase ELS_PRLO:\n\tcase ELS_ADISC:\n\tcase ELS_RRQ:\n\tcase ELS_REC:\n\tcase ELS_RLS:\n\tcase ELS_RTV:\n\t\tfc_rport_recv_els_req(lport, fp);\n\t\tbreak;\n\tdefault:\n\t\tels_data.reason = ELS_RJT_UNSUP;\n\t\tels_data.explan = ELS_EXPL_NONE;\n\t\tfc_seq_els_rsp_send(fp, ELS_LS_RJT, &els_data);\n\t\tfc_frame_free(fp);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(fc_rport_recv_req);\n\n \nstatic void fc_rport_recv_plogi_req(struct fc_lport *lport,\n\t\t\t\t    struct fc_frame *rx_fp)\n{\n\tstruct fc_disc *disc;\n\tstruct fc_rport_priv *rdata;\n\tstruct fc_frame *fp = rx_fp;\n\tstruct fc_els_flogi *pl;\n\tstruct fc_seq_els_data rjt_data;\n\tu32 sid;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tsid = fc_frame_sid(fp);\n\n\tFC_RPORT_ID_DBG(lport, sid, \"Received PLOGI request\\n\");\n\n\tpl = fc_frame_payload_get(fp, sizeof(*pl));\n\tif (!pl) {\n\t\tFC_RPORT_ID_DBG(lport, sid, \"Received PLOGI too short\\n\");\n\t\trjt_data.reason = ELS_RJT_PROT;\n\t\trjt_data.explan = ELS_EXPL_INV_LEN;\n\t\tgoto reject;\n\t}\n\n\tdisc = &lport->disc;\n\tmutex_lock(&disc->disc_mutex);\n\trdata = fc_rport_create(lport, sid);\n\tif (!rdata) {\n\t\tmutex_unlock(&disc->disc_mutex);\n\t\trjt_data.reason = ELS_RJT_UNAB;\n\t\trjt_data.explan = ELS_EXPL_INSUF_RES;\n\t\tgoto reject;\n\t}\n\n\tmutex_lock(&rdata->rp_mutex);\n\tmutex_unlock(&disc->disc_mutex);\n\n\trdata->ids.port_name = get_unaligned_be64(&pl->fl_wwpn);\n\trdata->ids.node_name = get_unaligned_be64(&pl->fl_wwnn);\n\n\t \n\tswitch (rdata->rp_state) {\n\tcase RPORT_ST_INIT:\n\t\tFC_RPORT_DBG(rdata, \"Received PLOGI in INIT state\\n\");\n\t\tbreak;\n\tcase RPORT_ST_PLOGI_WAIT:\n\t\tFC_RPORT_DBG(rdata, \"Received PLOGI in PLOGI_WAIT state\\n\");\n\t\tbreak;\n\tcase RPORT_ST_PLOGI:\n\t\tFC_RPORT_DBG(rdata, \"Received PLOGI in PLOGI state\\n\");\n\t\tif (rdata->ids.port_name < lport->wwpn) {\n\t\t\tmutex_unlock(&rdata->rp_mutex);\n\t\t\trjt_data.reason = ELS_RJT_INPROG;\n\t\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\t\tgoto reject;\n\t\t}\n\t\tbreak;\n\tcase RPORT_ST_PRLI:\n\tcase RPORT_ST_RTV:\n\tcase RPORT_ST_READY:\n\tcase RPORT_ST_ADISC:\n\t\tFC_RPORT_DBG(rdata, \"Received PLOGI in logged-in state %d \"\n\t\t\t     \"- ignored for now\\n\", rdata->rp_state);\n\t\t \n\t\tbreak;\n\tcase RPORT_ST_FLOGI:\n\tcase RPORT_ST_DELETE:\n\t\tFC_RPORT_DBG(rdata, \"Received PLOGI in state %s - send busy\\n\",\n\t\t\t     fc_rport_state(rdata));\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\trjt_data.reason = ELS_RJT_BUSY;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tgoto reject;\n\t}\n\tif (!fc_rport_compatible_roles(lport, rdata)) {\n\t\tFC_RPORT_DBG(rdata, \"Received PLOGI for incompatible role\\n\");\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\trjt_data.reason = ELS_RJT_LOGIC;\n\t\trjt_data.explan = ELS_EXPL_NONE;\n\t\tgoto reject;\n\t}\n\n\t \n\trdata->maxframe_size = fc_plogi_get_maxframe(pl, lport->mfs);\n\n\t \n\tfp = fc_frame_alloc(lport, sizeof(*pl));\n\tif (!fp)\n\t\tgoto out;\n\n\tfc_plogi_fill(lport, fp, ELS_LS_ACC);\n\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\n\tfc_rport_enter_prli(rdata);\nout:\n\tmutex_unlock(&rdata->rp_mutex);\n\tfc_frame_free(rx_fp);\n\treturn;\n\nreject:\n\tfc_seq_els_rsp_send(fp, ELS_LS_RJT, &rjt_data);\n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_rport_recv_prli_req(struct fc_rport_priv *rdata,\n\t\t\t\t   struct fc_frame *rx_fp)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\tstruct fc_els_spp *rspp;\t \n\tstruct fc_els_spp *spp;\t \n\tunsigned int len;\n\tunsigned int plen;\n\tenum fc_els_spp_resp resp;\n\tstruct fc_seq_els_data rjt_data;\n\tstruct fc4_prov *prov;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Received PRLI request while in state %s\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tlen = fr_len(rx_fp) - sizeof(struct fc_frame_header);\n\tpp = fc_frame_payload_get(rx_fp, sizeof(*pp));\n\tif (!pp)\n\t\tgoto reject_len;\n\tplen = ntohs(pp->prli.prli_len);\n\tif ((plen % 4) != 0 || plen > len || plen < 16)\n\t\tgoto reject_len;\n\tif (plen < len)\n\t\tlen = plen;\n\tplen = pp->prli.prli_spp_len;\n\tif ((plen % 4) != 0 || plen < sizeof(*spp) ||\n\t    plen > len || len < sizeof(*pp) || plen < 12)\n\t\tgoto reject_len;\n\trspp = &pp->spp;\n\n\tfp = fc_frame_alloc(lport, len);\n\tif (!fp) {\n\t\trjt_data.reason = ELS_RJT_UNAB;\n\t\trjt_data.explan = ELS_EXPL_INSUF_RES;\n\t\tgoto reject;\n\t}\n\tpp = fc_frame_payload_get(fp, len);\n\tWARN_ON(!pp);\n\tmemset(pp, 0, len);\n\tpp->prli.prli_cmd = ELS_LS_ACC;\n\tpp->prli.prli_spp_len = plen;\n\tpp->prli.prli_len = htons(len);\n\tlen -= sizeof(struct fc_els_prli);\n\n\t \n\tspp = &pp->spp;\n\tmutex_lock(&fc_prov_mutex);\n\twhile (len >= plen) {\n\t\trdata->spp_type = rspp->spp_type;\n\t\tspp->spp_type = rspp->spp_type;\n\t\tspp->spp_type_ext = rspp->spp_type_ext;\n\t\tresp = 0;\n\n\t\tif (rspp->spp_type < FC_FC4_PROV_SIZE) {\n\t\t\tenum fc_els_spp_resp active = 0, passive = 0;\n\n\t\t\tprov = fc_active_prov[rspp->spp_type];\n\t\t\tif (prov)\n\t\t\t\tactive = prov->prli(rdata, plen, rspp, spp);\n\t\t\tprov = fc_passive_prov[rspp->spp_type];\n\t\t\tif (prov)\n\t\t\t\tpassive = prov->prli(rdata, plen, rspp, spp);\n\t\t\tif (!active || passive == FC_SPP_RESP_ACK)\n\t\t\t\tresp = passive;\n\t\t\telse\n\t\t\t\tresp = active;\n\t\t\tFC_RPORT_DBG(rdata, \"PRLI rspp type %x \"\n\t\t\t\t     \"active %x passive %x\\n\",\n\t\t\t\t     rspp->spp_type, active, passive);\n\t\t}\n\t\tif (!resp) {\n\t\t\tif (spp->spp_flags & FC_SPP_EST_IMG_PAIR)\n\t\t\t\tresp |= FC_SPP_RESP_CONF;\n\t\t\telse\n\t\t\t\tresp |= FC_SPP_RESP_INVL;\n\t\t}\n\t\tspp->spp_flags |= resp;\n\t\tlen -= plen;\n\t\trspp = (struct fc_els_spp *)((char *)rspp + plen);\n\t\tspp = (struct fc_els_spp *)((char *)spp + plen);\n\t}\n\tmutex_unlock(&fc_prov_mutex);\n\n\t \n\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\n\n\tgoto drop;\n\nreject_len:\n\trjt_data.reason = ELS_RJT_PROT;\n\trjt_data.explan = ELS_EXPL_INV_LEN;\nreject:\n\tfc_seq_els_rsp_send(rx_fp, ELS_LS_RJT, &rjt_data);\ndrop:\n\tfc_frame_free(rx_fp);\n}\n\n \nstatic void fc_rport_recv_prlo_req(struct fc_rport_priv *rdata,\n\t\t\t\t   struct fc_frame *rx_fp)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tstruct fc_frame *fp;\n\tstruct {\n\t\tstruct fc_els_prlo prlo;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\tstruct fc_els_spp *rspp;\t \n\tstruct fc_els_spp *spp;\t\t \n\tunsigned int len;\n\tunsigned int plen;\n\tstruct fc_seq_els_data rjt_data;\n\n\tlockdep_assert_held(&rdata->rp_mutex);\n\n\tFC_RPORT_DBG(rdata, \"Received PRLO request while in state %s\\n\",\n\t\t     fc_rport_state(rdata));\n\n\tlen = fr_len(rx_fp) - sizeof(struct fc_frame_header);\n\tpp = fc_frame_payload_get(rx_fp, sizeof(*pp));\n\tif (!pp)\n\t\tgoto reject_len;\n\tplen = ntohs(pp->prlo.prlo_len);\n\tif (plen != 20)\n\t\tgoto reject_len;\n\tif (plen < len)\n\t\tlen = plen;\n\n\trspp = &pp->spp;\n\n\tfp = fc_frame_alloc(lport, len);\n\tif (!fp) {\n\t\trjt_data.reason = ELS_RJT_UNAB;\n\t\trjt_data.explan = ELS_EXPL_INSUF_RES;\n\t\tgoto reject;\n\t}\n\n\tpp = fc_frame_payload_get(fp, len);\n\tWARN_ON(!pp);\n\tmemset(pp, 0, len);\n\tpp->prlo.prlo_cmd = ELS_LS_ACC;\n\tpp->prlo.prlo_obs = 0x10;\n\tpp->prlo.prlo_len = htons(len);\n\tspp = &pp->spp;\n\tspp->spp_type = rspp->spp_type;\n\tspp->spp_type_ext = rspp->spp_type_ext;\n\tspp->spp_flags = FC_SPP_RESP_ACK;\n\n\tfc_rport_enter_prli(rdata);\n\n\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\n\tgoto drop;\n\nreject_len:\n\trjt_data.reason = ELS_RJT_PROT;\n\trjt_data.explan = ELS_EXPL_INV_LEN;\nreject:\n\tfc_seq_els_rsp_send(rx_fp, ELS_LS_RJT, &rjt_data);\ndrop:\n\tfc_frame_free(rx_fp);\n}\n\n \nstatic void fc_rport_recv_logo_req(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_rport_priv *rdata;\n\tu32 sid;\n\n\tlockdep_assert_held(&lport->lp_mutex);\n\n\tfc_seq_els_rsp_send(fp, ELS_LS_ACC, NULL);\n\n\tsid = fc_frame_sid(fp);\n\n\trdata = fc_rport_lookup(lport, sid);\n\tif (rdata) {\n\t\tmutex_lock(&rdata->rp_mutex);\n\t\tFC_RPORT_DBG(rdata, \"Received LOGO request while in state %s\\n\",\n\t\t\t     fc_rport_state(rdata));\n\n\t\tfc_rport_enter_delete(rdata, RPORT_EV_STOP);\n\t\tmutex_unlock(&rdata->rp_mutex);\n\t\tkref_put(&rdata->kref, fc_rport_destroy);\n\t} else\n\t\tFC_RPORT_ID_DBG(lport, sid,\n\t\t\t\t\"Received LOGO from non-logged-in port\\n\");\n\tfc_frame_free(fp);\n}\n\n \nvoid fc_rport_flush_queue(void)\n{\n\tflush_workqueue(rport_event_queue);\n}\nEXPORT_SYMBOL(fc_rport_flush_queue);\n\n \nstatic int fc_rport_fcp_prli(struct fc_rport_priv *rdata, u32 spp_len,\n\t\t\t     const struct fc_els_spp *rspp,\n\t\t\t     struct fc_els_spp *spp)\n{\n\tstruct fc_lport *lport = rdata->local_port;\n\tu32 fcp_parm;\n\n\tfcp_parm = ntohl(rspp->spp_params);\n\trdata->ids.roles = FC_RPORT_ROLE_UNKNOWN;\n\tif (fcp_parm & FCP_SPPF_INIT_FCN)\n\t\trdata->ids.roles |= FC_RPORT_ROLE_FCP_INITIATOR;\n\tif (fcp_parm & FCP_SPPF_TARG_FCN)\n\t\trdata->ids.roles |= FC_RPORT_ROLE_FCP_TARGET;\n\tif (fcp_parm & FCP_SPPF_RETRY)\n\t\trdata->flags |= FC_RP_FLAGS_RETRY;\n\trdata->supported_classes = FC_COS_CLASS3;\n\n\tif (!(lport->service_params & FCP_SPPF_INIT_FCN))\n\t\treturn 0;\n\n\tspp->spp_flags |= rspp->spp_flags & FC_SPP_EST_IMG_PAIR;\n\n\t \n\tfcp_parm = ntohl(spp->spp_params);\n\tspp->spp_params = htonl(fcp_parm | lport->service_params);\n\treturn FC_SPP_RESP_ACK;\n}\n\n \nstruct fc4_prov fc_rport_fcp_init = {\n\t.prli = fc_rport_fcp_prli,\n};\n\n \nstatic int fc_rport_t0_prli(struct fc_rport_priv *rdata, u32 spp_len,\n\t\t\t    const struct fc_els_spp *rspp,\n\t\t\t    struct fc_els_spp *spp)\n{\n\tif (rspp->spp_flags & FC_SPP_EST_IMG_PAIR)\n\t\treturn FC_SPP_RESP_INVL;\n\treturn FC_SPP_RESP_ACK;\n}\n\n \nstruct fc4_prov fc_rport_t0_prov = {\n\t.prli = fc_rport_t0_prli,\n};\n\n \nint fc_setup_rport(void)\n{\n\trport_event_queue = create_singlethread_workqueue(\"fc_rport_eq\");\n\tif (!rport_event_queue)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\n \nvoid fc_destroy_rport(void)\n{\n\tdestroy_workqueue(rport_event_queue);\n}\n\n \nvoid fc_rport_terminate_io(struct fc_rport *rport)\n{\n\tstruct fc_rport_libfc_priv *rpriv = rport->dd_data;\n\tstruct fc_lport *lport = rpriv->local_port;\n\n\tlport->tt.exch_mgr_reset(lport, 0, rport->port_id);\n\tlport->tt.exch_mgr_reset(lport, rport->port_id, 0);\n}\nEXPORT_SYMBOL(fc_rport_terminate_io);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}