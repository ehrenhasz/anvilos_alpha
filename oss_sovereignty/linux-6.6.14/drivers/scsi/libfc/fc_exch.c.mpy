{
  "module_name": "fc_exch.c",
  "hash_id": "7294a8608a85a3b74e0f772a653d4e8ebccabd0397348abdffe4d64bc0fb210c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libfc/fc_exch.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/log2.h>\n\n#include <scsi/fc/fc_fc2.h>\n\n#include <scsi/libfc.h>\n\n#include \"fc_libfc.h\"\n\nu16\tfc_cpu_mask;\t\t \nEXPORT_SYMBOL(fc_cpu_mask);\nstatic u16\tfc_cpu_order;\t \nstatic struct kmem_cache *fc_em_cachep;\t        \nstatic struct workqueue_struct *fc_exch_workqueue;\n\n \n\n \nstruct fc_exch_pool {\n\tspinlock_t\t lock;\n\tstruct list_head ex_list;\n\tu16\t\t next_index;\n\tu16\t\t total_exches;\n\n\tu16\t\t left;\n\tu16\t\t right;\n} ____cacheline_aligned_in_smp;\n\n \nstruct fc_exch_mgr {\n\tstruct fc_exch_pool __percpu *pool;\n\tmempool_t\t*ep_pool;\n\tstruct fc_lport\t*lport;\n\tenum fc_class\tclass;\n\tstruct kref\tkref;\n\tu16\t\tmin_xid;\n\tu16\t\tmax_xid;\n\tu16\t\tpool_max_index;\n\n\tstruct {\n\t\tatomic_t no_free_exch;\n\t\tatomic_t no_free_exch_xid;\n\t\tatomic_t xid_not_found;\n\t\tatomic_t xid_busy;\n\t\tatomic_t seq_not_found;\n\t\tatomic_t non_bls_resp;\n\t} stats;\n};\n\n \nstruct fc_exch_mgr_anchor {\n\tstruct list_head ema_list;\n\tstruct fc_exch_mgr *mp;\n\tbool (*match)(struct fc_frame *);\n};\n\nstatic void fc_exch_rrq(struct fc_exch *);\nstatic void fc_seq_ls_acc(struct fc_frame *);\nstatic void fc_seq_ls_rjt(struct fc_frame *, enum fc_els_rjt_reason,\n\t\t\t  enum fc_els_rjt_explan);\nstatic void fc_exch_els_rec(struct fc_frame *);\nstatic void fc_exch_els_rrq(struct fc_frame *);\n\n \n\n \n\n \nstatic char *fc_exch_rctl_names[] = FC_RCTL_NAMES_INIT;\n\n \nstatic inline const char *fc_exch_name_lookup(unsigned int op, char **table,\n\t\t\t\t\t      unsigned int max_index)\n{\n\tconst char *name = NULL;\n\n\tif (op < max_index)\n\t\tname = table[op];\n\tif (!name)\n\t\tname = \"unknown\";\n\treturn name;\n}\n\n \nstatic const char *fc_exch_rctl_name(unsigned int op)\n{\n\treturn fc_exch_name_lookup(op, fc_exch_rctl_names,\n\t\t\t\t   ARRAY_SIZE(fc_exch_rctl_names));\n}\n\n \nstatic inline void fc_exch_hold(struct fc_exch *ep)\n{\n\tatomic_inc(&ep->ex_refcnt);\n}\n\n \nstatic void fc_exch_setup_hdr(struct fc_exch *ep, struct fc_frame *fp,\n\t\t\t      u32 f_ctl)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tu16 fill;\n\n\tfr_sof(fp) = ep->class;\n\tif (ep->seq.cnt)\n\t\tfr_sof(fp) = fc_sof_normal(ep->class);\n\n\tif (f_ctl & FC_FC_END_SEQ) {\n\t\tfr_eof(fp) = FC_EOF_T;\n\t\tif (fc_sof_needs_ack((enum fc_sof)ep->class))\n\t\t\tfr_eof(fp) = FC_EOF_N;\n\t\t \n\t\tfill = fr_len(fp) & 3;\n\t\tif (fill) {\n\t\t\tfill = 4 - fill;\n\t\t\t \n\t\t\tskb_put(fp_skb(fp), fill);\n\t\t\thton24(fh->fh_f_ctl, f_ctl | fill);\n\t\t}\n\t} else {\n\t\tWARN_ON(fr_len(fp) % 4 != 0);\t \n\t\tfr_eof(fp) = FC_EOF_N;\n\t}\n\n\t \n\tfh->fh_ox_id = htons(ep->oxid);\n\tfh->fh_rx_id = htons(ep->rxid);\n\tfh->fh_seq_id = ep->seq.id;\n\tfh->fh_seq_cnt = htons(ep->seq.cnt);\n}\n\n \nstatic void fc_exch_release(struct fc_exch *ep)\n{\n\tstruct fc_exch_mgr *mp;\n\n\tif (atomic_dec_and_test(&ep->ex_refcnt)) {\n\t\tmp = ep->em;\n\t\tif (ep->destructor)\n\t\t\tep->destructor(&ep->seq, ep->arg);\n\t\tWARN_ON(!(ep->esb_stat & ESB_ST_COMPLETE));\n\t\tmempool_free(ep, mp->ep_pool);\n\t}\n}\n\n \nstatic inline void fc_exch_timer_cancel(struct fc_exch *ep)\n{\n\tif (cancel_delayed_work(&ep->timeout_work)) {\n\t\tFC_EXCH_DBG(ep, \"Exchange timer canceled\\n\");\n\t\tatomic_dec(&ep->ex_refcnt);  \n\t}\n}\n\n \nstatic inline void fc_exch_timer_set_locked(struct fc_exch *ep,\n\t\t\t\t\t    unsigned int timer_msec)\n{\n\tif (ep->state & (FC_EX_RST_CLEANUP | FC_EX_DONE))\n\t\treturn;\n\n\tFC_EXCH_DBG(ep, \"Exchange timer armed : %d msecs\\n\", timer_msec);\n\n\tfc_exch_hold(ep);\t\t \n\tif (!queue_delayed_work(fc_exch_workqueue, &ep->timeout_work,\n\t\t\t\tmsecs_to_jiffies(timer_msec))) {\n\t\tFC_EXCH_DBG(ep, \"Exchange already queued\\n\");\n\t\tfc_exch_release(ep);\n\t}\n}\n\n \nstatic void fc_exch_timer_set(struct fc_exch *ep, unsigned int timer_msec)\n{\n\tspin_lock_bh(&ep->ex_lock);\n\tfc_exch_timer_set_locked(ep, timer_msec);\n\tspin_unlock_bh(&ep->ex_lock);\n}\n\n \nstatic int fc_exch_done_locked(struct fc_exch *ep)\n{\n\tint rc = 1;\n\n\t \n\tif (ep->state & FC_EX_DONE)\n\t\treturn rc;\n\tep->esb_stat |= ESB_ST_COMPLETE;\n\n\tif (!(ep->esb_stat & ESB_ST_REC_QUAL)) {\n\t\tep->state |= FC_EX_DONE;\n\t\tfc_exch_timer_cancel(ep);\n\t\trc = 0;\n\t}\n\treturn rc;\n}\n\nstatic struct fc_exch fc_quarantine_exch;\n\n \nstatic inline struct fc_exch *fc_exch_ptr_get(struct fc_exch_pool *pool,\n\t\t\t\t\t      u16 index)\n{\n\tstruct fc_exch **exches = (struct fc_exch **)(pool + 1);\n\treturn exches[index];\n}\n\n \nstatic inline void fc_exch_ptr_set(struct fc_exch_pool *pool, u16 index,\n\t\t\t\t   struct fc_exch *ep)\n{\n\t((struct fc_exch **)(pool + 1))[index] = ep;\n}\n\n \nstatic void fc_exch_delete(struct fc_exch *ep)\n{\n\tstruct fc_exch_pool *pool;\n\tu16 index;\n\n\tpool = ep->pool;\n\tspin_lock_bh(&pool->lock);\n\tWARN_ON(pool->total_exches <= 0);\n\tpool->total_exches--;\n\n\t \n\tindex = (ep->xid - ep->em->min_xid) >> fc_cpu_order;\n\tif (!(ep->state & FC_EX_QUARANTINE)) {\n\t\tif (pool->left == FC_XID_UNKNOWN)\n\t\t\tpool->left = index;\n\t\telse if (pool->right == FC_XID_UNKNOWN)\n\t\t\tpool->right = index;\n\t\telse\n\t\t\tpool->next_index = index;\n\t\tfc_exch_ptr_set(pool, index, NULL);\n\t} else {\n\t\tfc_exch_ptr_set(pool, index, &fc_quarantine_exch);\n\t}\n\tlist_del(&ep->ex_list);\n\tspin_unlock_bh(&pool->lock);\n\tfc_exch_release(ep);\t \n}\n\nstatic int fc_seq_send_locked(struct fc_lport *lport, struct fc_seq *sp,\n\t\t\t      struct fc_frame *fp)\n{\n\tstruct fc_exch *ep;\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tint error = -ENXIO;\n\tu32 f_ctl;\n\tu8 fh_type = fh->fh_type;\n\n\tep = fc_seq_exch(sp);\n\n\tif (ep->esb_stat & (ESB_ST_COMPLETE | ESB_ST_ABNORMAL)) {\n\t\tfc_frame_free(fp);\n\t\tgoto out;\n\t}\n\n\tWARN_ON(!(ep->esb_stat & ESB_ST_SEQ_INIT));\n\n\tf_ctl = ntoh24(fh->fh_f_ctl);\n\tfc_exch_setup_hdr(ep, fp, f_ctl);\n\tfr_encaps(fp) = ep->encaps;\n\n\t \n\tif (fr_max_payload(fp))\n\t\tsp->cnt += DIV_ROUND_UP((fr_len(fp) - sizeof(*fh)),\n\t\t\t\t\tfr_max_payload(fp));\n\telse\n\t\tsp->cnt++;\n\n\t \n\terror = lport->tt.frame_send(lport, fp);\n\n\tif (fh_type == FC_TYPE_BLS)\n\t\tgoto out;\n\n\t \n\tep->f_ctl = f_ctl & ~FC_FC_FIRST_SEQ;\t \n\tif (f_ctl & FC_FC_SEQ_INIT)\n\t\tep->esb_stat &= ~ESB_ST_SEQ_INIT;\nout:\n\treturn error;\n}\n\n \nint fc_seq_send(struct fc_lport *lport, struct fc_seq *sp, struct fc_frame *fp)\n{\n\tstruct fc_exch *ep;\n\tint error;\n\tep = fc_seq_exch(sp);\n\tspin_lock_bh(&ep->ex_lock);\n\terror = fc_seq_send_locked(lport, sp, fp);\n\tspin_unlock_bh(&ep->ex_lock);\n\treturn error;\n}\nEXPORT_SYMBOL(fc_seq_send);\n\n \nstatic struct fc_seq *fc_seq_alloc(struct fc_exch *ep, u8 seq_id)\n{\n\tstruct fc_seq *sp;\n\n\tsp = &ep->seq;\n\tsp->ssb_stat = 0;\n\tsp->cnt = 0;\n\tsp->id = seq_id;\n\treturn sp;\n}\n\n \nstatic struct fc_seq *fc_seq_start_next_locked(struct fc_seq *sp)\n{\n\tstruct fc_exch *ep = fc_seq_exch(sp);\n\n\tsp = fc_seq_alloc(ep, ep->seq_id++);\n\tFC_EXCH_DBG(ep, \"f_ctl %6x seq %2x\\n\",\n\t\t    ep->f_ctl, sp->id);\n\treturn sp;\n}\n\n \nstruct fc_seq *fc_seq_start_next(struct fc_seq *sp)\n{\n\tstruct fc_exch *ep = fc_seq_exch(sp);\n\n\tspin_lock_bh(&ep->ex_lock);\n\tsp = fc_seq_start_next_locked(sp);\n\tspin_unlock_bh(&ep->ex_lock);\n\n\treturn sp;\n}\nEXPORT_SYMBOL(fc_seq_start_next);\n\n \nvoid fc_seq_set_resp(struct fc_seq *sp,\n\t\t     void (*resp)(struct fc_seq *, struct fc_frame *, void *),\n\t\t     void *arg)\n{\n\tstruct fc_exch *ep = fc_seq_exch(sp);\n\tDEFINE_WAIT(wait);\n\n\tspin_lock_bh(&ep->ex_lock);\n\twhile (ep->resp_active && ep->resp_task != current) {\n\t\tprepare_to_wait(&ep->resp_wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_bh(&ep->ex_lock);\n\n\t\tschedule();\n\n\t\tspin_lock_bh(&ep->ex_lock);\n\t}\n\tfinish_wait(&ep->resp_wq, &wait);\n\tep->resp = resp;\n\tep->arg = arg;\n\tspin_unlock_bh(&ep->ex_lock);\n}\nEXPORT_SYMBOL(fc_seq_set_resp);\n\n \nstatic int fc_exch_abort_locked(struct fc_exch *ep,\n\t\t\t\tunsigned int timer_msec)\n{\n\tstruct fc_seq *sp;\n\tstruct fc_frame *fp;\n\tint error;\n\n\tFC_EXCH_DBG(ep, \"exch: abort, time %d msecs\\n\", timer_msec);\n\tif (ep->esb_stat & (ESB_ST_COMPLETE | ESB_ST_ABNORMAL) ||\n\t    ep->state & (FC_EX_DONE | FC_EX_RST_CLEANUP)) {\n\t\tFC_EXCH_DBG(ep, \"exch: already completed esb %x state %x\\n\",\n\t\t\t    ep->esb_stat, ep->state);\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tsp = fc_seq_start_next_locked(&ep->seq);\n\tif (!sp)\n\t\treturn -ENOMEM;\n\n\tif (timer_msec)\n\t\tfc_exch_timer_set_locked(ep, timer_msec);\n\n\tif (ep->sid) {\n\t\t \n\t\tfp = fc_frame_alloc(ep->lp, 0);\n\t\tif (fp) {\n\t\t\tep->esb_stat |= ESB_ST_SEQ_INIT;\n\t\t\tfc_fill_fc_hdr(fp, FC_RCTL_BA_ABTS, ep->did, ep->sid,\n\t\t\t\t       FC_TYPE_BLS, FC_FC_END_SEQ |\n\t\t\t\t       FC_FC_SEQ_INIT, 0);\n\t\t\terror = fc_seq_send_locked(ep->lp, sp, fp);\n\t\t} else {\n\t\t\terror = -ENOBUFS;\n\t\t}\n\t} else {\n\t\t \n\t\terror = 0;\n\t}\n\tep->esb_stat |= ESB_ST_ABNORMAL;\n\treturn error;\n}\n\n \nint fc_seq_exch_abort(const struct fc_seq *req_sp, unsigned int timer_msec)\n{\n\tstruct fc_exch *ep;\n\tint error;\n\n\tep = fc_seq_exch(req_sp);\n\tspin_lock_bh(&ep->ex_lock);\n\terror = fc_exch_abort_locked(ep, timer_msec);\n\tspin_unlock_bh(&ep->ex_lock);\n\treturn error;\n}\n\n \nstatic bool fc_invoke_resp(struct fc_exch *ep, struct fc_seq *sp,\n\t\t\t   struct fc_frame *fp)\n{\n\tvoid (*resp)(struct fc_seq *, struct fc_frame *fp, void *arg);\n\tvoid *arg;\n\tbool res = false;\n\n\tspin_lock_bh(&ep->ex_lock);\n\tep->resp_active++;\n\tif (ep->resp_task != current)\n\t\tep->resp_task = !ep->resp_task ? current : NULL;\n\tresp = ep->resp;\n\targ = ep->arg;\n\tspin_unlock_bh(&ep->ex_lock);\n\n\tif (resp) {\n\t\tresp(sp, fp, arg);\n\t\tres = true;\n\t}\n\n\tspin_lock_bh(&ep->ex_lock);\n\tif (--ep->resp_active == 0)\n\t\tep->resp_task = NULL;\n\tspin_unlock_bh(&ep->ex_lock);\n\n\tif (ep->resp_active == 0)\n\t\twake_up(&ep->resp_wq);\n\n\treturn res;\n}\n\n \nstatic void fc_exch_timeout(struct work_struct *work)\n{\n\tstruct fc_exch *ep = container_of(work, struct fc_exch,\n\t\t\t\t\t  timeout_work.work);\n\tstruct fc_seq *sp = &ep->seq;\n\tu32 e_stat;\n\tint rc = 1;\n\n\tFC_EXCH_DBG(ep, \"Exchange timed out state %x\\n\", ep->state);\n\n\tspin_lock_bh(&ep->ex_lock);\n\tif (ep->state & (FC_EX_RST_CLEANUP | FC_EX_DONE))\n\t\tgoto unlock;\n\n\te_stat = ep->esb_stat;\n\tif (e_stat & ESB_ST_COMPLETE) {\n\t\tep->esb_stat = e_stat & ~ESB_ST_REC_QUAL;\n\t\tspin_unlock_bh(&ep->ex_lock);\n\t\tif (e_stat & ESB_ST_REC_QUAL)\n\t\t\tfc_exch_rrq(ep);\n\t\tgoto done;\n\t} else {\n\t\tif (e_stat & ESB_ST_ABNORMAL)\n\t\t\trc = fc_exch_done_locked(ep);\n\t\tspin_unlock_bh(&ep->ex_lock);\n\t\tif (!rc)\n\t\t\tfc_exch_delete(ep);\n\t\tfc_invoke_resp(ep, sp, ERR_PTR(-FC_EX_TIMEOUT));\n\t\tfc_seq_set_resp(sp, NULL, ep->arg);\n\t\tfc_seq_exch_abort(sp, 2 * ep->r_a_tov);\n\t\tgoto done;\n\t}\nunlock:\n\tspin_unlock_bh(&ep->ex_lock);\ndone:\n\t \n\tfc_exch_release(ep);\n}\n\n \nstatic struct fc_exch *fc_exch_em_alloc(struct fc_lport *lport,\n\t\t\t\t\tstruct fc_exch_mgr *mp)\n{\n\tstruct fc_exch *ep;\n\tunsigned int cpu;\n\tu16 index;\n\tstruct fc_exch_pool *pool;\n\n\t \n\tep = mempool_alloc(mp->ep_pool, GFP_ATOMIC);\n\tif (!ep) {\n\t\tatomic_inc(&mp->stats.no_free_exch);\n\t\tgoto out;\n\t}\n\tmemset(ep, 0, sizeof(*ep));\n\n\tcpu = raw_smp_processor_id();\n\tpool = per_cpu_ptr(mp->pool, cpu);\n\tspin_lock_bh(&pool->lock);\n\n\t \n\tif (pool->left != FC_XID_UNKNOWN) {\n\t\tif (!WARN_ON(fc_exch_ptr_get(pool, pool->left))) {\n\t\t\tindex = pool->left;\n\t\t\tpool->left = FC_XID_UNKNOWN;\n\t\t\tgoto hit;\n\t\t}\n\t}\n\tif (pool->right != FC_XID_UNKNOWN) {\n\t\tif (!WARN_ON(fc_exch_ptr_get(pool, pool->right))) {\n\t\t\tindex = pool->right;\n\t\t\tpool->right = FC_XID_UNKNOWN;\n\t\t\tgoto hit;\n\t\t}\n\t}\n\n\tindex = pool->next_index;\n\t \n\twhile (fc_exch_ptr_get(pool, index)) {\n\t\tindex = index == mp->pool_max_index ? 0 : index + 1;\n\t\tif (index == pool->next_index)\n\t\t\tgoto err;\n\t}\n\tpool->next_index = index == mp->pool_max_index ? 0 : index + 1;\nhit:\n\tfc_exch_hold(ep);\t \n\tspin_lock_init(&ep->ex_lock);\n\t \n\tspin_lock_bh(&ep->ex_lock);\n\n\tfc_exch_ptr_set(pool, index, ep);\n\tlist_add_tail(&ep->ex_list, &pool->ex_list);\n\tfc_seq_alloc(ep, ep->seq_id++);\n\tpool->total_exches++;\n\tspin_unlock_bh(&pool->lock);\n\n\t \n\tep->oxid = ep->xid = (index << fc_cpu_order | cpu) + mp->min_xid;\n\tep->em = mp;\n\tep->pool = pool;\n\tep->lp = lport;\n\tep->f_ctl = FC_FC_FIRST_SEQ;\t \n\tep->rxid = FC_XID_UNKNOWN;\n\tep->class = mp->class;\n\tep->resp_active = 0;\n\tinit_waitqueue_head(&ep->resp_wq);\n\tINIT_DELAYED_WORK(&ep->timeout_work, fc_exch_timeout);\nout:\n\treturn ep;\nerr:\n\tspin_unlock_bh(&pool->lock);\n\tatomic_inc(&mp->stats.no_free_exch_xid);\n\tmempool_free(ep, mp->ep_pool);\n\treturn NULL;\n}\n\n \nstatic struct fc_exch *fc_exch_alloc(struct fc_lport *lport,\n\t\t\t\t     struct fc_frame *fp)\n{\n\tstruct fc_exch_mgr_anchor *ema;\n\tstruct fc_exch *ep;\n\n\tlist_for_each_entry(ema, &lport->ema_list, ema_list) {\n\t\tif (!ema->match || ema->match(fp)) {\n\t\t\tep = fc_exch_em_alloc(lport, ema->mp);\n\t\t\tif (ep)\n\t\t\t\treturn ep;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n \nstatic struct fc_exch *fc_exch_find(struct fc_exch_mgr *mp, u16 xid)\n{\n\tstruct fc_lport *lport = mp->lport;\n\tstruct fc_exch_pool *pool;\n\tstruct fc_exch *ep = NULL;\n\tu16 cpu = xid & fc_cpu_mask;\n\n\tif (xid == FC_XID_UNKNOWN)\n\t\treturn NULL;\n\n\tif (cpu >= nr_cpu_ids || !cpu_possible(cpu)) {\n\t\tpr_err(\"host%u: lport %6.6x: xid %d invalid CPU %d\\n:\",\n\t\t       lport->host->host_no, lport->port_id, xid, cpu);\n\t\treturn NULL;\n\t}\n\n\tif ((xid >= mp->min_xid) && (xid <= mp->max_xid)) {\n\t\tpool = per_cpu_ptr(mp->pool, cpu);\n\t\tspin_lock_bh(&pool->lock);\n\t\tep = fc_exch_ptr_get(pool, (xid - mp->min_xid) >> fc_cpu_order);\n\t\tif (ep == &fc_quarantine_exch) {\n\t\t\tFC_LPORT_DBG(lport, \"xid %x quarantined\\n\", xid);\n\t\t\tep = NULL;\n\t\t}\n\t\tif (ep) {\n\t\t\tWARN_ON(ep->xid != xid);\n\t\t\tfc_exch_hold(ep);\n\t\t}\n\t\tspin_unlock_bh(&pool->lock);\n\t}\n\treturn ep;\n}\n\n\n \nvoid fc_exch_done(struct fc_seq *sp)\n{\n\tstruct fc_exch *ep = fc_seq_exch(sp);\n\tint rc;\n\n\tspin_lock_bh(&ep->ex_lock);\n\trc = fc_exch_done_locked(ep);\n\tspin_unlock_bh(&ep->ex_lock);\n\n\tfc_seq_set_resp(sp, NULL, ep->arg);\n\tif (!rc)\n\t\tfc_exch_delete(ep);\n}\nEXPORT_SYMBOL(fc_exch_done);\n\n \nstatic struct fc_exch *fc_exch_resp(struct fc_lport *lport,\n\t\t\t\t    struct fc_exch_mgr *mp,\n\t\t\t\t    struct fc_frame *fp)\n{\n\tstruct fc_exch *ep;\n\tstruct fc_frame_header *fh;\n\n\tep = fc_exch_alloc(lport, fp);\n\tif (ep) {\n\t\tep->class = fc_frame_class(fp);\n\n\t\t \n\t\tep->f_ctl |= FC_FC_EX_CTX;\t \n\t\tep->f_ctl &= ~FC_FC_FIRST_SEQ;\t \n\t\tfh = fc_frame_header_get(fp);\n\t\tep->sid = ntoh24(fh->fh_d_id);\n\t\tep->did = ntoh24(fh->fh_s_id);\n\t\tep->oid = ep->did;\n\n\t\t \n\t\tep->rxid = ep->xid;\n\t\tep->oxid = ntohs(fh->fh_ox_id);\n\t\tep->esb_stat |= ESB_ST_RESP | ESB_ST_SEQ_INIT;\n\t\tif ((ntoh24(fh->fh_f_ctl) & FC_FC_SEQ_INIT) == 0)\n\t\t\tep->esb_stat &= ~ESB_ST_SEQ_INIT;\n\n\t\tfc_exch_hold(ep);\t \n\t\tspin_unlock_bh(&ep->ex_lock);\t \n\t}\n\treturn ep;\n}\n\n \nstatic enum fc_pf_rjt_reason fc_seq_lookup_recip(struct fc_lport *lport,\n\t\t\t\t\t\t struct fc_exch_mgr *mp,\n\t\t\t\t\t\t struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tstruct fc_exch *ep = NULL;\n\tstruct fc_seq *sp = NULL;\n\tenum fc_pf_rjt_reason reject = FC_RJT_NONE;\n\tu32 f_ctl;\n\tu16 xid;\n\n\tf_ctl = ntoh24(fh->fh_f_ctl);\n\tWARN_ON((f_ctl & FC_FC_SEQ_CTX) != 0);\n\n\t \n\tif (f_ctl & FC_FC_EX_CTX) {\n\t\txid = ntohs(fh->fh_ox_id);\t \n\t\tep = fc_exch_find(mp, xid);\n\t\tif (!ep) {\n\t\t\tatomic_inc(&mp->stats.xid_not_found);\n\t\t\treject = FC_RJT_OX_ID;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ep->rxid == FC_XID_UNKNOWN)\n\t\t\tep->rxid = ntohs(fh->fh_rx_id);\n\t\telse if (ep->rxid != ntohs(fh->fh_rx_id)) {\n\t\t\treject = FC_RJT_OX_ID;\n\t\t\tgoto rel;\n\t\t}\n\t} else {\n\t\txid = ntohs(fh->fh_rx_id);\t \n\n\t\t \n\t\tif (xid == 0 && fh->fh_r_ctl == FC_RCTL_ELS_REQ &&\n\t\t    fc_frame_payload_op(fp) == ELS_TEST) {\n\t\t\tfh->fh_rx_id = htons(FC_XID_UNKNOWN);\n\t\t\txid = FC_XID_UNKNOWN;\n\t\t}\n\n\t\t \n\t\tep = fc_exch_find(mp, xid);\n\t\tif ((f_ctl & FC_FC_FIRST_SEQ) && fc_sof_is_init(fr_sof(fp))) {\n\t\t\tif (ep) {\n\t\t\t\tatomic_inc(&mp->stats.xid_busy);\n\t\t\t\treject = FC_RJT_RX_ID;\n\t\t\t\tgoto rel;\n\t\t\t}\n\t\t\tep = fc_exch_resp(lport, mp, fp);\n\t\t\tif (!ep) {\n\t\t\t\treject = FC_RJT_EXCH_EST;\t \n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\txid = ep->xid;\t \n\t\t} else if (!ep) {\n\t\t\tatomic_inc(&mp->stats.xid_not_found);\n\t\t\treject = FC_RJT_RX_ID;\t \n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tspin_lock_bh(&ep->ex_lock);\n\t \n\tif (fc_sof_is_init(fr_sof(fp))) {\n\t\tsp = &ep->seq;\n\t\tsp->ssb_stat |= SSB_ST_RESP;\n\t\tsp->id = fh->fh_seq_id;\n\t} else {\n\t\tsp = &ep->seq;\n\t\tif (sp->id != fh->fh_seq_id) {\n\t\t\tatomic_inc(&mp->stats.seq_not_found);\n\t\t\tif (f_ctl & FC_FC_END_SEQ) {\n\t\t\t\t \n\t\t\t\tsp->ssb_stat |= SSB_ST_RESP;\n\t\t\t\tsp->id = fh->fh_seq_id;\n\t\t\t} else {\n\t\t\t\tspin_unlock_bh(&ep->ex_lock);\n\n\t\t\t\t \n\t\t\t\treject = FC_RJT_SEQ_ID;\n\t\t\t\tgoto rel;\n\t\t\t}\n\t\t}\n\t}\n\tWARN_ON(ep != fc_seq_exch(sp));\n\n\tif (f_ctl & FC_FC_SEQ_INIT)\n\t\tep->esb_stat |= ESB_ST_SEQ_INIT;\n\tspin_unlock_bh(&ep->ex_lock);\n\n\tfr_seq(fp) = sp;\nout:\n\treturn reject;\nrel:\n\tfc_exch_done(&ep->seq);\n\tfc_exch_release(ep);\t \n\treturn reject;\n}\n\n \nstatic struct fc_seq *fc_seq_lookup_orig(struct fc_exch_mgr *mp,\n\t\t\t\t\t struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tstruct fc_exch *ep;\n\tstruct fc_seq *sp = NULL;\n\tu32 f_ctl;\n\tu16 xid;\n\n\tf_ctl = ntoh24(fh->fh_f_ctl);\n\tWARN_ON((f_ctl & FC_FC_SEQ_CTX) != FC_FC_SEQ_CTX);\n\txid = ntohs((f_ctl & FC_FC_EX_CTX) ? fh->fh_ox_id : fh->fh_rx_id);\n\tep = fc_exch_find(mp, xid);\n\tif (!ep)\n\t\treturn NULL;\n\tif (ep->seq.id == fh->fh_seq_id) {\n\t\t \n\t\tsp = &ep->seq;\n\t\tif ((f_ctl & FC_FC_EX_CTX) != 0 &&\n\t\t    ep->rxid == FC_XID_UNKNOWN) {\n\t\t\tep->rxid = ntohs(fh->fh_rx_id);\n\t\t}\n\t}\n\tfc_exch_release(ep);\n\treturn sp;\n}\n\n \nstatic void fc_exch_set_addr(struct fc_exch *ep,\n\t\t\t     u32 orig_id, u32 resp_id)\n{\n\tep->oid = orig_id;\n\tif (ep->esb_stat & ESB_ST_RESP) {\n\t\tep->sid = resp_id;\n\t\tep->did = orig_id;\n\t} else {\n\t\tep->sid = orig_id;\n\t\tep->did = resp_id;\n\t}\n}\n\n \nvoid fc_seq_els_rsp_send(struct fc_frame *fp, enum fc_els_cmd els_cmd,\n\t\t\t struct fc_seq_els_data *els_data)\n{\n\tswitch (els_cmd) {\n\tcase ELS_LS_RJT:\n\t\tfc_seq_ls_rjt(fp, els_data->reason, els_data->explan);\n\t\tbreak;\n\tcase ELS_LS_ACC:\n\t\tfc_seq_ls_acc(fp);\n\t\tbreak;\n\tcase ELS_RRQ:\n\t\tfc_exch_els_rrq(fp);\n\t\tbreak;\n\tcase ELS_REC:\n\t\tfc_exch_els_rec(fp);\n\t\tbreak;\n\tdefault:\n\t\tFC_LPORT_DBG(fr_dev(fp), \"Invalid ELS CMD:%x\\n\", els_cmd);\n\t}\n}\nEXPORT_SYMBOL_GPL(fc_seq_els_rsp_send);\n\n \nstatic void fc_seq_send_last(struct fc_seq *sp, struct fc_frame *fp,\n\t\t\t     enum fc_rctl rctl, enum fc_fh_type fh_type)\n{\n\tu32 f_ctl;\n\tstruct fc_exch *ep = fc_seq_exch(sp);\n\n\tf_ctl = FC_FC_LAST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT;\n\tf_ctl |= ep->f_ctl;\n\tfc_fill_fc_hdr(fp, rctl, ep->did, ep->sid, fh_type, f_ctl, 0);\n\tfc_seq_send_locked(ep->lp, sp, fp);\n}\n\n \nstatic void fc_seq_send_ack(struct fc_seq *sp, const struct fc_frame *rx_fp)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_frame_header *rx_fh;\n\tstruct fc_frame_header *fh;\n\tstruct fc_exch *ep = fc_seq_exch(sp);\n\tstruct fc_lport *lport = ep->lp;\n\tunsigned int f_ctl;\n\n\t \n\tif (fc_sof_needs_ack(fr_sof(rx_fp))) {\n\t\tfp = fc_frame_alloc(lport, 0);\n\t\tif (!fp) {\n\t\t\tFC_EXCH_DBG(ep, \"Drop ACK request, out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tfh = fc_frame_header_get(fp);\n\t\tfh->fh_r_ctl = FC_RCTL_ACK_1;\n\t\tfh->fh_type = FC_TYPE_BLS;\n\n\t\t \n\t\trx_fh = fc_frame_header_get(rx_fp);\n\t\tf_ctl = ntoh24(rx_fh->fh_f_ctl);\n\t\tf_ctl &= FC_FC_EX_CTX | FC_FC_SEQ_CTX |\n\t\t\tFC_FC_FIRST_SEQ | FC_FC_LAST_SEQ |\n\t\t\tFC_FC_END_SEQ | FC_FC_END_CONN | FC_FC_SEQ_INIT |\n\t\t\tFC_FC_RETX_SEQ | FC_FC_UNI_TX;\n\t\tf_ctl ^= FC_FC_EX_CTX | FC_FC_SEQ_CTX;\n\t\thton24(fh->fh_f_ctl, f_ctl);\n\n\t\tfc_exch_setup_hdr(ep, fp, f_ctl);\n\t\tfh->fh_seq_id = rx_fh->fh_seq_id;\n\t\tfh->fh_seq_cnt = rx_fh->fh_seq_cnt;\n\t\tfh->fh_parm_offset = htonl(1);\t \n\n\t\tfr_sof(fp) = fr_sof(rx_fp);\n\t\tif (f_ctl & FC_FC_END_SEQ)\n\t\t\tfr_eof(fp) = FC_EOF_T;\n\t\telse\n\t\t\tfr_eof(fp) = FC_EOF_N;\n\n\t\tlport->tt.frame_send(lport, fp);\n\t}\n}\n\n \nstatic void fc_exch_send_ba_rjt(struct fc_frame *rx_fp,\n\t\t\t\tenum fc_ba_rjt_reason reason,\n\t\t\t\tenum fc_ba_rjt_explan explan)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_frame_header *rx_fh;\n\tstruct fc_frame_header *fh;\n\tstruct fc_ba_rjt *rp;\n\tstruct fc_seq *sp;\n\tstruct fc_lport *lport;\n\tunsigned int f_ctl;\n\n\tlport = fr_dev(rx_fp);\n\tsp = fr_seq(rx_fp);\n\tfp = fc_frame_alloc(lport, sizeof(*rp));\n\tif (!fp) {\n\t\tFC_EXCH_DBG(fc_seq_exch(sp),\n\t\t\t     \"Drop BA_RJT request, out of memory\\n\");\n\t\treturn;\n\t}\n\tfh = fc_frame_header_get(fp);\n\trx_fh = fc_frame_header_get(rx_fp);\n\n\tmemset(fh, 0, sizeof(*fh) + sizeof(*rp));\n\n\trp = fc_frame_payload_get(fp, sizeof(*rp));\n\trp->br_reason = reason;\n\trp->br_explan = explan;\n\n\t \n\tmemcpy(fh->fh_s_id, rx_fh->fh_d_id, 3);\n\tmemcpy(fh->fh_d_id, rx_fh->fh_s_id, 3);\n\tfh->fh_ox_id = rx_fh->fh_ox_id;\n\tfh->fh_rx_id = rx_fh->fh_rx_id;\n\tfh->fh_seq_cnt = rx_fh->fh_seq_cnt;\n\tfh->fh_r_ctl = FC_RCTL_BA_RJT;\n\tfh->fh_type = FC_TYPE_BLS;\n\n\t \n\tf_ctl = ntoh24(rx_fh->fh_f_ctl);\n\tf_ctl &= FC_FC_EX_CTX | FC_FC_SEQ_CTX |\n\t\tFC_FC_END_CONN | FC_FC_SEQ_INIT |\n\t\tFC_FC_RETX_SEQ | FC_FC_UNI_TX;\n\tf_ctl ^= FC_FC_EX_CTX | FC_FC_SEQ_CTX;\n\tf_ctl |= FC_FC_LAST_SEQ | FC_FC_END_SEQ;\n\tf_ctl &= ~FC_FC_FIRST_SEQ;\n\thton24(fh->fh_f_ctl, f_ctl);\n\n\tfr_sof(fp) = fc_sof_class(fr_sof(rx_fp));\n\tfr_eof(fp) = FC_EOF_T;\n\tif (fc_sof_needs_ack(fr_sof(fp)))\n\t\tfr_eof(fp) = FC_EOF_N;\n\n\tlport->tt.frame_send(lport, fp);\n}\n\n \nstatic void fc_exch_recv_abts(struct fc_exch *ep, struct fc_frame *rx_fp)\n{\n\tstruct fc_frame *fp;\n\tstruct fc_ba_acc *ap;\n\tstruct fc_frame_header *fh;\n\tstruct fc_seq *sp;\n\n\tif (!ep)\n\t\tgoto reject;\n\n\tFC_EXCH_DBG(ep, \"exch: ABTS received\\n\");\n\tfp = fc_frame_alloc(ep->lp, sizeof(*ap));\n\tif (!fp) {\n\t\tFC_EXCH_DBG(ep, \"Drop ABTS request, out of memory\\n\");\n\t\tgoto free;\n\t}\n\n\tspin_lock_bh(&ep->ex_lock);\n\tif (ep->esb_stat & ESB_ST_COMPLETE) {\n\t\tspin_unlock_bh(&ep->ex_lock);\n\t\tFC_EXCH_DBG(ep, \"exch: ABTS rejected, exchange complete\\n\");\n\t\tfc_frame_free(fp);\n\t\tgoto reject;\n\t}\n\tif (!(ep->esb_stat & ESB_ST_REC_QUAL)) {\n\t\tep->esb_stat |= ESB_ST_REC_QUAL;\n\t\tfc_exch_hold(ep);\t\t \n\t}\n\tfc_exch_timer_set_locked(ep, ep->r_a_tov);\n\tfh = fc_frame_header_get(fp);\n\tap = fc_frame_payload_get(fp, sizeof(*ap));\n\tmemset(ap, 0, sizeof(*ap));\n\tsp = &ep->seq;\n\tap->ba_high_seq_cnt = htons(0xffff);\n\tif (sp->ssb_stat & SSB_ST_RESP) {\n\t\tap->ba_seq_id = sp->id;\n\t\tap->ba_seq_id_val = FC_BA_SEQ_ID_VAL;\n\t\tap->ba_high_seq_cnt = fh->fh_seq_cnt;\n\t\tap->ba_low_seq_cnt = htons(sp->cnt);\n\t}\n\tsp = fc_seq_start_next_locked(sp);\n\tfc_seq_send_last(sp, fp, FC_RCTL_BA_ACC, FC_TYPE_BLS);\n\tep->esb_stat |= ESB_ST_ABNORMAL;\n\tspin_unlock_bh(&ep->ex_lock);\n\nfree:\n\tfc_frame_free(rx_fp);\n\treturn;\n\nreject:\n\tfc_exch_send_ba_rjt(rx_fp, FC_BA_RJT_UNABLE, FC_BA_RJT_INV_XID);\n\tgoto free;\n}\n\n \nstruct fc_seq *fc_seq_assign(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_exch_mgr_anchor *ema;\n\n\tWARN_ON(lport != fr_dev(fp));\n\tWARN_ON(fr_seq(fp));\n\tfr_seq(fp) = NULL;\n\n\tlist_for_each_entry(ema, &lport->ema_list, ema_list)\n\t\tif ((!ema->match || ema->match(fp)) &&\n\t\t    fc_seq_lookup_recip(lport, ema->mp, fp) == FC_RJT_NONE)\n\t\t\tbreak;\n\treturn fr_seq(fp);\n}\nEXPORT_SYMBOL(fc_seq_assign);\n\n \nvoid fc_seq_release(struct fc_seq *sp)\n{\n\tfc_exch_release(fc_seq_exch(sp));\n}\nEXPORT_SYMBOL(fc_seq_release);\n\n \nstatic void fc_exch_recv_req(struct fc_lport *lport, struct fc_exch_mgr *mp,\n\t\t\t     struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tstruct fc_seq *sp = NULL;\n\tstruct fc_exch *ep = NULL;\n\tenum fc_pf_rjt_reason reject;\n\n\t \n\tlport = fc_vport_id_lookup(lport, ntoh24(fh->fh_d_id));\n\tif (!lport) {\n\t\tfc_frame_free(fp);\n\t\treturn;\n\t}\n\tfr_dev(fp) = lport;\n\n\tBUG_ON(fr_seq(fp));\t\t \n\n\t \n\tif (fh->fh_rx_id == htons(FC_XID_UNKNOWN))\n\t\treturn fc_lport_recv(lport, fp);\n\n\treject = fc_seq_lookup_recip(lport, mp, fp);\n\tif (reject == FC_RJT_NONE) {\n\t\tsp = fr_seq(fp);\t \n\t\tep = fc_seq_exch(sp);\n\t\tfc_seq_send_ack(sp, fp);\n\t\tep->encaps = fr_encaps(fp);\n\n\t\t \n\t\tif (!fc_invoke_resp(ep, sp, fp))\n\t\t\tfc_lport_recv(lport, fp);\n\t\tfc_exch_release(ep);\t \n\t} else {\n\t\tFC_LPORT_DBG(lport, \"exch/seq lookup failed: reject %x\\n\",\n\t\t\t     reject);\n\t\tfc_frame_free(fp);\n\t}\n}\n\n \nstatic void fc_exch_recv_seq_resp(struct fc_exch_mgr *mp, struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tstruct fc_seq *sp;\n\tstruct fc_exch *ep;\n\tenum fc_sof sof;\n\tu32 f_ctl;\n\tint rc;\n\n\tep = fc_exch_find(mp, ntohs(fh->fh_ox_id));\n\tif (!ep) {\n\t\tatomic_inc(&mp->stats.xid_not_found);\n\t\tgoto out;\n\t}\n\tif (ep->esb_stat & ESB_ST_COMPLETE) {\n\t\tatomic_inc(&mp->stats.xid_not_found);\n\t\tgoto rel;\n\t}\n\tif (ep->rxid == FC_XID_UNKNOWN)\n\t\tep->rxid = ntohs(fh->fh_rx_id);\n\tif (ep->sid != 0 && ep->sid != ntoh24(fh->fh_d_id)) {\n\t\tatomic_inc(&mp->stats.xid_not_found);\n\t\tgoto rel;\n\t}\n\tif (ep->did != ntoh24(fh->fh_s_id) &&\n\t    ep->did != FC_FID_FLOGI) {\n\t\tatomic_inc(&mp->stats.xid_not_found);\n\t\tgoto rel;\n\t}\n\tsof = fr_sof(fp);\n\tsp = &ep->seq;\n\tif (fc_sof_is_init(sof)) {\n\t\tsp->ssb_stat |= SSB_ST_RESP;\n\t\tsp->id = fh->fh_seq_id;\n\t}\n\n\tf_ctl = ntoh24(fh->fh_f_ctl);\n\tfr_seq(fp) = sp;\n\n\tspin_lock_bh(&ep->ex_lock);\n\tif (f_ctl & FC_FC_SEQ_INIT)\n\t\tep->esb_stat |= ESB_ST_SEQ_INIT;\n\tspin_unlock_bh(&ep->ex_lock);\n\n\tif (fc_sof_needs_ack(sof))\n\t\tfc_seq_send_ack(sp, fp);\n\n\tif (fh->fh_type != FC_TYPE_FCP && fr_eof(fp) == FC_EOF_T &&\n\t    (f_ctl & (FC_FC_LAST_SEQ | FC_FC_END_SEQ)) ==\n\t    (FC_FC_LAST_SEQ | FC_FC_END_SEQ)) {\n\t\tspin_lock_bh(&ep->ex_lock);\n\t\trc = fc_exch_done_locked(ep);\n\t\tWARN_ON(fc_seq_exch(sp) != ep);\n\t\tspin_unlock_bh(&ep->ex_lock);\n\t\tif (!rc) {\n\t\t\tfc_exch_delete(ep);\n\t\t} else {\n\t\t\tFC_EXCH_DBG(ep, \"ep is completed already,\"\n\t\t\t\t\t\"hence skip calling the resp\\n\");\n\t\t\tgoto skip_resp;\n\t\t}\n\t}\n\n\t \n\tif (!fc_invoke_resp(ep, sp, fp))\n\t\tfc_frame_free(fp);\n\nskip_resp:\n\tfc_exch_release(ep);\n\treturn;\nrel:\n\tfc_exch_release(ep);\nout:\n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_exch_recv_resp(struct fc_exch_mgr *mp, struct fc_frame *fp)\n{\n\tstruct fc_seq *sp;\n\n\tsp = fc_seq_lookup_orig(mp, fp);\t \n\n\tif (!sp)\n\t\tatomic_inc(&mp->stats.xid_not_found);\n\telse\n\t\tatomic_inc(&mp->stats.non_bls_resp);\n\n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_exch_abts_resp(struct fc_exch *ep, struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh;\n\tstruct fc_ba_acc *ap;\n\tstruct fc_seq *sp;\n\tu16 low;\n\tu16 high;\n\tint rc = 1, has_rec = 0;\n\n\tfh = fc_frame_header_get(fp);\n\tFC_EXCH_DBG(ep, \"exch: BLS rctl %x - %s\\n\", fh->fh_r_ctl,\n\t\t    fc_exch_rctl_name(fh->fh_r_ctl));\n\n\tif (cancel_delayed_work_sync(&ep->timeout_work)) {\n\t\tFC_EXCH_DBG(ep, \"Exchange timer canceled due to ABTS response\\n\");\n\t\tfc_exch_release(ep);\t \n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ep->ex_lock);\n\tswitch (fh->fh_r_ctl) {\n\tcase FC_RCTL_BA_ACC:\n\t\tap = fc_frame_payload_get(fp, sizeof(*ap));\n\t\tif (!ap)\n\t\t\tbreak;\n\n\t\t \n\t\tlow = ntohs(ap->ba_low_seq_cnt);\n\t\thigh = ntohs(ap->ba_high_seq_cnt);\n\t\tif ((ep->esb_stat & ESB_ST_REC_QUAL) == 0 &&\n\t\t    (ap->ba_seq_id_val != FC_BA_SEQ_ID_VAL ||\n\t\t     ap->ba_seq_id == ep->seq_id) && low != high) {\n\t\t\tep->esb_stat |= ESB_ST_REC_QUAL;\n\t\t\tfc_exch_hold(ep);   \n\t\t\thas_rec = 1;\n\t\t}\n\t\tbreak;\n\tcase FC_RCTL_BA_RJT:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tsp = &ep->seq;\n\t \n\tif (ep->fh_type != FC_TYPE_FCP &&\n\t    ntoh24(fh->fh_f_ctl) & FC_FC_LAST_SEQ)\n\t\trc = fc_exch_done_locked(ep);\n\tspin_unlock_bh(&ep->ex_lock);\n\n\tfc_exch_hold(ep);\n\tif (!rc)\n\t\tfc_exch_delete(ep);\n\tif (!fc_invoke_resp(ep, sp, fp))\n\t\tfc_frame_free(fp);\n\tif (has_rec)\n\t\tfc_exch_timer_set(ep, ep->r_a_tov);\n\tfc_exch_release(ep);\n}\n\n \nstatic void fc_exch_recv_bls(struct fc_exch_mgr *mp, struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh;\n\tstruct fc_exch *ep;\n\tu32 f_ctl;\n\n\tfh = fc_frame_header_get(fp);\n\tf_ctl = ntoh24(fh->fh_f_ctl);\n\tfr_seq(fp) = NULL;\n\n\tep = fc_exch_find(mp, (f_ctl & FC_FC_EX_CTX) ?\n\t\t\t  ntohs(fh->fh_ox_id) : ntohs(fh->fh_rx_id));\n\tif (ep && (f_ctl & FC_FC_SEQ_INIT)) {\n\t\tspin_lock_bh(&ep->ex_lock);\n\t\tep->esb_stat |= ESB_ST_SEQ_INIT;\n\t\tspin_unlock_bh(&ep->ex_lock);\n\t}\n\tif (f_ctl & FC_FC_SEQ_CTX) {\n\t\t \n\t\tswitch (fh->fh_r_ctl) {\n\t\tcase FC_RCTL_ACK_1:\n\t\tcase FC_RCTL_ACK_0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ep)\n\t\t\t\tFC_EXCH_DBG(ep, \"BLS rctl %x - %s received\\n\",\n\t\t\t\t\t    fh->fh_r_ctl,\n\t\t\t\t\t    fc_exch_rctl_name(fh->fh_r_ctl));\n\t\t\tbreak;\n\t\t}\n\t\tfc_frame_free(fp);\n\t} else {\n\t\tswitch (fh->fh_r_ctl) {\n\t\tcase FC_RCTL_BA_RJT:\n\t\tcase FC_RCTL_BA_ACC:\n\t\t\tif (ep)\n\t\t\t\tfc_exch_abts_resp(ep, fp);\n\t\t\telse\n\t\t\t\tfc_frame_free(fp);\n\t\t\tbreak;\n\t\tcase FC_RCTL_BA_ABTS:\n\t\t\tif (ep)\n\t\t\t\tfc_exch_recv_abts(ep, fp);\n\t\t\telse\n\t\t\t\tfc_frame_free(fp);\n\t\t\tbreak;\n\t\tdefault:\t\t\t \n\t\t\tfc_frame_free(fp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ep)\n\t\tfc_exch_release(ep);\t \n}\n\n \nstatic void fc_seq_ls_acc(struct fc_frame *rx_fp)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_els_ls_acc *acc;\n\tstruct fc_frame *fp;\n\tstruct fc_seq *sp;\n\n\tlport = fr_dev(rx_fp);\n\tsp = fr_seq(rx_fp);\n\tfp = fc_frame_alloc(lport, sizeof(*acc));\n\tif (!fp) {\n\t\tFC_EXCH_DBG(fc_seq_exch(sp),\n\t\t\t    \"exch: drop LS_ACC, out of memory\\n\");\n\t\treturn;\n\t}\n\tacc = fc_frame_payload_get(fp, sizeof(*acc));\n\tmemset(acc, 0, sizeof(*acc));\n\tacc->la_cmd = ELS_LS_ACC;\n\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\n}\n\n \nstatic void fc_seq_ls_rjt(struct fc_frame *rx_fp, enum fc_els_rjt_reason reason,\n\t\t\t  enum fc_els_rjt_explan explan)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_els_ls_rjt *rjt;\n\tstruct fc_frame *fp;\n\tstruct fc_seq *sp;\n\n\tlport = fr_dev(rx_fp);\n\tsp = fr_seq(rx_fp);\n\tfp = fc_frame_alloc(lport, sizeof(*rjt));\n\tif (!fp) {\n\t\tFC_EXCH_DBG(fc_seq_exch(sp),\n\t\t\t    \"exch: drop LS_ACC, out of memory\\n\");\n\t\treturn;\n\t}\n\trjt = fc_frame_payload_get(fp, sizeof(*rjt));\n\tmemset(rjt, 0, sizeof(*rjt));\n\trjt->er_cmd = ELS_LS_RJT;\n\trjt->er_reason = reason;\n\trjt->er_explan = explan;\n\tfc_fill_reply_hdr(fp, rx_fp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\n}\n\n \nstatic void fc_exch_reset(struct fc_exch *ep)\n{\n\tstruct fc_seq *sp;\n\tint rc = 1;\n\n\tspin_lock_bh(&ep->ex_lock);\n\tep->state |= FC_EX_RST_CLEANUP;\n\tfc_exch_timer_cancel(ep);\n\tif (ep->esb_stat & ESB_ST_REC_QUAL)\n\t\tatomic_dec(&ep->ex_refcnt);\t \n\tep->esb_stat &= ~ESB_ST_REC_QUAL;\n\tsp = &ep->seq;\n\trc = fc_exch_done_locked(ep);\n\tspin_unlock_bh(&ep->ex_lock);\n\n\tfc_exch_hold(ep);\n\n\tif (!rc) {\n\t\tfc_exch_delete(ep);\n\t} else {\n\t\tFC_EXCH_DBG(ep, \"ep is completed already,\"\n\t\t\t\t\"hence skip calling the resp\\n\");\n\t\tgoto skip_resp;\n\t}\n\n\tfc_invoke_resp(ep, sp, ERR_PTR(-FC_EX_CLOSED));\nskip_resp:\n\tfc_seq_set_resp(sp, NULL, ep->arg);\n\tfc_exch_release(ep);\n}\n\n \nstatic void fc_exch_pool_reset(struct fc_lport *lport,\n\t\t\t       struct fc_exch_pool *pool,\n\t\t\t       u32 sid, u32 did)\n{\n\tstruct fc_exch *ep;\n\tstruct fc_exch *next;\n\n\tspin_lock_bh(&pool->lock);\nrestart:\n\tlist_for_each_entry_safe(ep, next, &pool->ex_list, ex_list) {\n\t\tif ((lport == ep->lp) &&\n\t\t    (sid == 0 || sid == ep->sid) &&\n\t\t    (did == 0 || did == ep->did)) {\n\t\t\tfc_exch_hold(ep);\n\t\t\tspin_unlock_bh(&pool->lock);\n\n\t\t\tfc_exch_reset(ep);\n\n\t\t\tfc_exch_release(ep);\n\t\t\tspin_lock_bh(&pool->lock);\n\n\t\t\t \n\t\t\tgoto restart;\n\t\t}\n\t}\n\tpool->next_index = 0;\n\tpool->left = FC_XID_UNKNOWN;\n\tpool->right = FC_XID_UNKNOWN;\n\tspin_unlock_bh(&pool->lock);\n}\n\n \nvoid fc_exch_mgr_reset(struct fc_lport *lport, u32 sid, u32 did)\n{\n\tstruct fc_exch_mgr_anchor *ema;\n\tunsigned int cpu;\n\n\tlist_for_each_entry(ema, &lport->ema_list, ema_list) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfc_exch_pool_reset(lport,\n\t\t\t\t\t   per_cpu_ptr(ema->mp->pool, cpu),\n\t\t\t\t\t   sid, did);\n\t}\n}\nEXPORT_SYMBOL(fc_exch_mgr_reset);\n\n \nstatic struct fc_exch *fc_exch_lookup(struct fc_lport *lport, u32 xid)\n{\n\tstruct fc_exch_mgr_anchor *ema;\n\n\tlist_for_each_entry(ema, &lport->ema_list, ema_list)\n\t\tif (ema->mp->min_xid <= xid && xid <= ema->mp->max_xid)\n\t\t\treturn fc_exch_find(ema->mp, xid);\n\treturn NULL;\n}\n\n \nstatic void fc_exch_els_rec(struct fc_frame *rfp)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_frame *fp;\n\tstruct fc_exch *ep;\n\tstruct fc_els_rec *rp;\n\tstruct fc_els_rec_acc *acc;\n\tenum fc_els_rjt_reason reason = ELS_RJT_LOGIC;\n\tenum fc_els_rjt_explan explan;\n\tu32 sid;\n\tu16 xid, rxid, oxid;\n\n\tlport = fr_dev(rfp);\n\trp = fc_frame_payload_get(rfp, sizeof(*rp));\n\texplan = ELS_EXPL_INV_LEN;\n\tif (!rp)\n\t\tgoto reject;\n\tsid = ntoh24(rp->rec_s_id);\n\trxid = ntohs(rp->rec_rx_id);\n\toxid = ntohs(rp->rec_ox_id);\n\n\texplan = ELS_EXPL_OXID_RXID;\n\tif (sid == fc_host_port_id(lport->host))\n\t\txid = oxid;\n\telse\n\t\txid = rxid;\n\tif (xid == FC_XID_UNKNOWN) {\n\t\tFC_LPORT_DBG(lport,\n\t\t\t     \"REC request from %x: invalid rxid %x oxid %x\\n\",\n\t\t\t     sid, rxid, oxid);\n\t\tgoto reject;\n\t}\n\tep = fc_exch_lookup(lport, xid);\n\tif (!ep) {\n\t\tFC_LPORT_DBG(lport,\n\t\t\t     \"REC request from %x: rxid %x oxid %x not found\\n\",\n\t\t\t     sid, rxid, oxid);\n\t\tgoto reject;\n\t}\n\tFC_EXCH_DBG(ep, \"REC request from %x: rxid %x oxid %x\\n\",\n\t\t    sid, rxid, oxid);\n\tif (ep->oid != sid || oxid != ep->oxid)\n\t\tgoto rel;\n\tif (rxid != FC_XID_UNKNOWN && rxid != ep->rxid)\n\t\tgoto rel;\n\tfp = fc_frame_alloc(lport, sizeof(*acc));\n\tif (!fp) {\n\t\tFC_EXCH_DBG(ep, \"Drop REC request, out of memory\\n\");\n\t\tgoto out;\n\t}\n\n\tacc = fc_frame_payload_get(fp, sizeof(*acc));\n\tmemset(acc, 0, sizeof(*acc));\n\tacc->reca_cmd = ELS_LS_ACC;\n\tacc->reca_ox_id = rp->rec_ox_id;\n\tmemcpy(acc->reca_ofid, rp->rec_s_id, 3);\n\tacc->reca_rx_id = htons(ep->rxid);\n\tif (ep->sid == ep->oid)\n\t\thton24(acc->reca_rfid, ep->did);\n\telse\n\t\thton24(acc->reca_rfid, ep->sid);\n\tacc->reca_fc4value = htonl(ep->seq.rec_data);\n\tacc->reca_e_stat = htonl(ep->esb_stat & (ESB_ST_RESP |\n\t\t\t\t\t\t ESB_ST_SEQ_INIT |\n\t\t\t\t\t\t ESB_ST_COMPLETE));\n\tfc_fill_reply_hdr(fp, rfp, FC_RCTL_ELS_REP, 0);\n\tlport->tt.frame_send(lport, fp);\nout:\n\tfc_exch_release(ep);\n\treturn;\n\nrel:\n\tfc_exch_release(ep);\nreject:\n\tfc_seq_ls_rjt(rfp, reason, explan);\n}\n\n \nstatic void fc_exch_rrq_resp(struct fc_seq *sp, struct fc_frame *fp, void *arg)\n{\n\tstruct fc_exch *aborted_ep = arg;\n\tunsigned int op;\n\n\tif (IS_ERR(fp)) {\n\t\tint err = PTR_ERR(fp);\n\n\t\tif (err == -FC_EX_CLOSED || err == -FC_EX_TIMEOUT)\n\t\t\tgoto cleanup;\n\t\tFC_EXCH_DBG(aborted_ep, \"Cannot process RRQ, \"\n\t\t\t    \"frame error %d\\n\", err);\n\t\treturn;\n\t}\n\n\top = fc_frame_payload_op(fp);\n\tfc_frame_free(fp);\n\n\tswitch (op) {\n\tcase ELS_LS_RJT:\n\t\tFC_EXCH_DBG(aborted_ep, \"LS_RJT for RRQ\\n\");\n\t\tfallthrough;\n\tcase ELS_LS_ACC:\n\t\tgoto cleanup;\n\tdefault:\n\t\tFC_EXCH_DBG(aborted_ep, \"unexpected response op %x for RRQ\\n\",\n\t\t\t    op);\n\t\treturn;\n\t}\n\ncleanup:\n\tfc_exch_done(&aborted_ep->seq);\n\t \n\tfc_exch_release(aborted_ep);\n}\n\n\n \nstruct fc_seq *fc_exch_seq_send(struct fc_lport *lport,\n\t\t\t\tstruct fc_frame *fp,\n\t\t\t\tvoid (*resp)(struct fc_seq *,\n\t\t\t\t\t     struct fc_frame *fp,\n\t\t\t\t\t     void *arg),\n\t\t\t\tvoid (*destructor)(struct fc_seq *, void *),\n\t\t\t\tvoid *arg, u32 timer_msec)\n{\n\tstruct fc_exch *ep;\n\tstruct fc_seq *sp = NULL;\n\tstruct fc_frame_header *fh;\n\tstruct fc_fcp_pkt *fsp = NULL;\n\tint rc = 1;\n\n\tep = fc_exch_alloc(lport, fp);\n\tif (!ep) {\n\t\tfc_frame_free(fp);\n\t\treturn NULL;\n\t}\n\tep->esb_stat |= ESB_ST_SEQ_INIT;\n\tfh = fc_frame_header_get(fp);\n\tfc_exch_set_addr(ep, ntoh24(fh->fh_s_id), ntoh24(fh->fh_d_id));\n\tep->resp = resp;\n\tep->destructor = destructor;\n\tep->arg = arg;\n\tep->r_a_tov = lport->r_a_tov;\n\tep->lp = lport;\n\tsp = &ep->seq;\n\n\tep->fh_type = fh->fh_type;  \n\tep->f_ctl = ntoh24(fh->fh_f_ctl);\n\tfc_exch_setup_hdr(ep, fp, ep->f_ctl);\n\tsp->cnt++;\n\n\tif (ep->xid <= lport->lro_xid && fh->fh_r_ctl == FC_RCTL_DD_UNSOL_CMD) {\n\t\tfsp = fr_fsp(fp);\n\t\tfc_fcp_ddp_setup(fr_fsp(fp), ep->xid);\n\t}\n\n\tif (unlikely(lport->tt.frame_send(lport, fp)))\n\t\tgoto err;\n\n\tif (timer_msec)\n\t\tfc_exch_timer_set_locked(ep, timer_msec);\n\tep->f_ctl &= ~FC_FC_FIRST_SEQ;\t \n\n\tif (ep->f_ctl & FC_FC_SEQ_INIT)\n\t\tep->esb_stat &= ~ESB_ST_SEQ_INIT;\n\tspin_unlock_bh(&ep->ex_lock);\n\treturn sp;\nerr:\n\tif (fsp)\n\t\tfc_fcp_ddp_done(fsp);\n\trc = fc_exch_done_locked(ep);\n\tspin_unlock_bh(&ep->ex_lock);\n\tif (!rc)\n\t\tfc_exch_delete(ep);\n\treturn NULL;\n}\nEXPORT_SYMBOL(fc_exch_seq_send);\n\n \nstatic void fc_exch_rrq(struct fc_exch *ep)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_els_rrq *rrq;\n\tstruct fc_frame *fp;\n\tu32 did;\n\n\tlport = ep->lp;\n\n\tfp = fc_frame_alloc(lport, sizeof(*rrq));\n\tif (!fp)\n\t\tgoto retry;\n\n\trrq = fc_frame_payload_get(fp, sizeof(*rrq));\n\tmemset(rrq, 0, sizeof(*rrq));\n\trrq->rrq_cmd = ELS_RRQ;\n\thton24(rrq->rrq_s_id, ep->sid);\n\trrq->rrq_ox_id = htons(ep->oxid);\n\trrq->rrq_rx_id = htons(ep->rxid);\n\n\tdid = ep->did;\n\tif (ep->esb_stat & ESB_ST_RESP)\n\t\tdid = ep->sid;\n\n\tfc_fill_fc_hdr(fp, FC_RCTL_ELS_REQ, did,\n\t\t       lport->port_id, FC_TYPE_ELS,\n\t\t       FC_FC_FIRST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT, 0);\n\n\tif (fc_exch_seq_send(lport, fp, fc_exch_rrq_resp, NULL, ep,\n\t\t\t     lport->e_d_tov))\n\t\treturn;\n\nretry:\n\tFC_EXCH_DBG(ep, \"exch: RRQ send failed\\n\");\n\tspin_lock_bh(&ep->ex_lock);\n\tif (ep->state & (FC_EX_RST_CLEANUP | FC_EX_DONE)) {\n\t\tspin_unlock_bh(&ep->ex_lock);\n\t\t \n\t\tfc_exch_release(ep);\n\t\treturn;\n\t}\n\tep->esb_stat |= ESB_ST_REC_QUAL;\n\tfc_exch_timer_set_locked(ep, ep->r_a_tov);\n\tspin_unlock_bh(&ep->ex_lock);\n}\n\n \nstatic void fc_exch_els_rrq(struct fc_frame *fp)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_exch *ep = NULL;\t \n\tstruct fc_els_rrq *rp;\n\tu32 sid;\n\tu16 xid;\n\tenum fc_els_rjt_explan explan;\n\n\tlport = fr_dev(fp);\n\trp = fc_frame_payload_get(fp, sizeof(*rp));\n\texplan = ELS_EXPL_INV_LEN;\n\tif (!rp)\n\t\tgoto reject;\n\n\t \n\tsid = ntoh24(rp->rrq_s_id);\t\t \n\txid = fc_host_port_id(lport->host) == sid ?\n\t\t\tntohs(rp->rrq_ox_id) : ntohs(rp->rrq_rx_id);\n\tep = fc_exch_lookup(lport, xid);\n\texplan = ELS_EXPL_OXID_RXID;\n\tif (!ep)\n\t\tgoto reject;\n\tspin_lock_bh(&ep->ex_lock);\n\tFC_EXCH_DBG(ep, \"RRQ request from %x: xid %x rxid %x oxid %x\\n\",\n\t\t    sid, xid, ntohs(rp->rrq_rx_id), ntohs(rp->rrq_ox_id));\n\tif (ep->oxid != ntohs(rp->rrq_ox_id))\n\t\tgoto unlock_reject;\n\tif (ep->rxid != ntohs(rp->rrq_rx_id) &&\n\t    ep->rxid != FC_XID_UNKNOWN)\n\t\tgoto unlock_reject;\n\texplan = ELS_EXPL_SID;\n\tif (ep->sid != sid)\n\t\tgoto unlock_reject;\n\n\t \n\tif (ep->esb_stat & ESB_ST_REC_QUAL) {\n\t\tep->esb_stat &= ~ESB_ST_REC_QUAL;\n\t\tatomic_dec(&ep->ex_refcnt);\t \n\t}\n\tif (ep->esb_stat & ESB_ST_COMPLETE)\n\t\tfc_exch_timer_cancel(ep);\n\n\tspin_unlock_bh(&ep->ex_lock);\n\n\t \n\tfc_seq_ls_acc(fp);\n\tgoto out;\n\nunlock_reject:\n\tspin_unlock_bh(&ep->ex_lock);\nreject:\n\tfc_seq_ls_rjt(fp, ELS_RJT_LOGIC, explan);\nout:\n\tif (ep)\n\t\tfc_exch_release(ep);\t \n}\n\n \nvoid fc_exch_update_stats(struct fc_lport *lport)\n{\n\tstruct fc_host_statistics *st;\n\tstruct fc_exch_mgr_anchor *ema;\n\tstruct fc_exch_mgr *mp;\n\n\tst = &lport->host_stats;\n\n\tlist_for_each_entry(ema, &lport->ema_list, ema_list) {\n\t\tmp = ema->mp;\n\t\tst->fc_no_free_exch += atomic_read(&mp->stats.no_free_exch);\n\t\tst->fc_no_free_exch_xid +=\n\t\t\t\tatomic_read(&mp->stats.no_free_exch_xid);\n\t\tst->fc_xid_not_found += atomic_read(&mp->stats.xid_not_found);\n\t\tst->fc_xid_busy += atomic_read(&mp->stats.xid_busy);\n\t\tst->fc_seq_not_found += atomic_read(&mp->stats.seq_not_found);\n\t\tst->fc_non_bls_resp += atomic_read(&mp->stats.non_bls_resp);\n\t}\n}\nEXPORT_SYMBOL(fc_exch_update_stats);\n\n \nstruct fc_exch_mgr_anchor *fc_exch_mgr_add(struct fc_lport *lport,\n\t\t\t\t\t   struct fc_exch_mgr *mp,\n\t\t\t\t\t   bool (*match)(struct fc_frame *))\n{\n\tstruct fc_exch_mgr_anchor *ema;\n\n\tema = kmalloc(sizeof(*ema), GFP_ATOMIC);\n\tif (!ema)\n\t\treturn ema;\n\n\tema->mp = mp;\n\tema->match = match;\n\t \n\tlist_add_tail(&ema->ema_list, &lport->ema_list);\n\tkref_get(&mp->kref);\n\treturn ema;\n}\nEXPORT_SYMBOL(fc_exch_mgr_add);\n\n \nstatic void fc_exch_mgr_destroy(struct kref *kref)\n{\n\tstruct fc_exch_mgr *mp = container_of(kref, struct fc_exch_mgr, kref);\n\n\tmempool_destroy(mp->ep_pool);\n\tfree_percpu(mp->pool);\n\tkfree(mp);\n}\n\n \nvoid fc_exch_mgr_del(struct fc_exch_mgr_anchor *ema)\n{\n\t \n\tlist_del(&ema->ema_list);\n\tkref_put(&ema->mp->kref, fc_exch_mgr_destroy);\n\tkfree(ema);\n}\nEXPORT_SYMBOL(fc_exch_mgr_del);\n\n \nint fc_exch_mgr_list_clone(struct fc_lport *src, struct fc_lport *dst)\n{\n\tstruct fc_exch_mgr_anchor *ema, *tmp;\n\n\tlist_for_each_entry(ema, &src->ema_list, ema_list) {\n\t\tif (!fc_exch_mgr_add(dst, ema->mp, ema->match))\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tlist_for_each_entry_safe(ema, tmp, &dst->ema_list, ema_list)\n\t\tfc_exch_mgr_del(ema);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL(fc_exch_mgr_list_clone);\n\n \nstruct fc_exch_mgr *fc_exch_mgr_alloc(struct fc_lport *lport,\n\t\t\t\t      enum fc_class class,\n\t\t\t\t      u16 min_xid, u16 max_xid,\n\t\t\t\t      bool (*match)(struct fc_frame *))\n{\n\tstruct fc_exch_mgr *mp;\n\tu16 pool_exch_range;\n\tsize_t pool_size;\n\tunsigned int cpu;\n\tstruct fc_exch_pool *pool;\n\n\tif (max_xid <= min_xid || max_xid == FC_XID_UNKNOWN ||\n\t    (min_xid & fc_cpu_mask) != 0) {\n\t\tFC_LPORT_DBG(lport, \"Invalid min_xid 0x:%x and max_xid 0x:%x\\n\",\n\t\t\t     min_xid, max_xid);\n\t\treturn NULL;\n\t}\n\n\t \n\tmp = kzalloc(sizeof(struct fc_exch_mgr), GFP_ATOMIC);\n\tif (!mp)\n\t\treturn NULL;\n\n\tmp->class = class;\n\tmp->lport = lport;\n\t \n\tmp->min_xid = min_xid;\n\n        \n\tpool_exch_range = (PCPU_MIN_UNIT_SIZE - sizeof(*pool)) /\n\t\tsizeof(struct fc_exch *);\n\tif ((max_xid - min_xid + 1) / (fc_cpu_mask + 1) > pool_exch_range) {\n\t\tmp->max_xid = pool_exch_range * (fc_cpu_mask + 1) +\n\t\t\tmin_xid - 1;\n\t} else {\n\t\tmp->max_xid = max_xid;\n\t\tpool_exch_range = (mp->max_xid - mp->min_xid + 1) /\n\t\t\t(fc_cpu_mask + 1);\n\t}\n\n\tmp->ep_pool = mempool_create_slab_pool(2, fc_em_cachep);\n\tif (!mp->ep_pool)\n\t\tgoto free_mp;\n\n\t \n\tmp->pool_max_index = pool_exch_range - 1;\n\n\t \n\tpool_size = sizeof(*pool) + pool_exch_range * sizeof(struct fc_exch *);\n\tmp->pool = __alloc_percpu(pool_size, __alignof__(struct fc_exch_pool));\n\tif (!mp->pool)\n\t\tgoto free_mempool;\n\tfor_each_possible_cpu(cpu) {\n\t\tpool = per_cpu_ptr(mp->pool, cpu);\n\t\tpool->next_index = 0;\n\t\tpool->left = FC_XID_UNKNOWN;\n\t\tpool->right = FC_XID_UNKNOWN;\n\t\tspin_lock_init(&pool->lock);\n\t\tINIT_LIST_HEAD(&pool->ex_list);\n\t}\n\n\tkref_init(&mp->kref);\n\tif (!fc_exch_mgr_add(lport, mp, match)) {\n\t\tfree_percpu(mp->pool);\n\t\tgoto free_mempool;\n\t}\n\n\t \n\tkref_put(&mp->kref, fc_exch_mgr_destroy);\n\treturn mp;\n\nfree_mempool:\n\tmempool_destroy(mp->ep_pool);\nfree_mp:\n\tkfree(mp);\n\treturn NULL;\n}\nEXPORT_SYMBOL(fc_exch_mgr_alloc);\n\n \nvoid fc_exch_mgr_free(struct fc_lport *lport)\n{\n\tstruct fc_exch_mgr_anchor *ema, *next;\n\n\tflush_workqueue(fc_exch_workqueue);\n\tlist_for_each_entry_safe(ema, next, &lport->ema_list, ema_list)\n\t\tfc_exch_mgr_del(ema);\n}\nEXPORT_SYMBOL(fc_exch_mgr_free);\n\n \nstatic struct fc_exch_mgr_anchor *fc_find_ema(u32 f_ctl,\n\t\t\t\t\t      struct fc_lport *lport,\n\t\t\t\t\t      struct fc_frame_header *fh)\n{\n\tstruct fc_exch_mgr_anchor *ema;\n\tu16 xid;\n\n\tif (f_ctl & FC_FC_EX_CTX)\n\t\txid = ntohs(fh->fh_ox_id);\n\telse {\n\t\txid = ntohs(fh->fh_rx_id);\n\t\tif (xid == FC_XID_UNKNOWN)\n\t\t\treturn list_entry(lport->ema_list.prev,\n\t\t\t\t\t  typeof(*ema), ema_list);\n\t}\n\n\tlist_for_each_entry(ema, &lport->ema_list, ema_list) {\n\t\tif ((xid >= ema->mp->min_xid) &&\n\t\t    (xid <= ema->mp->max_xid))\n\t\t\treturn ema;\n\t}\n\treturn NULL;\n}\n \nvoid fc_exch_recv(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh = fc_frame_header_get(fp);\n\tstruct fc_exch_mgr_anchor *ema;\n\tu32 f_ctl;\n\n\t \n\tif (!lport || lport->state == LPORT_ST_DISABLED) {\n\t\tFC_LIBFC_DBG(\"Receiving frames for an lport that \"\n\t\t\t     \"has not been initialized correctly\\n\");\n\t\tfc_frame_free(fp);\n\t\treturn;\n\t}\n\n\tf_ctl = ntoh24(fh->fh_f_ctl);\n\tema = fc_find_ema(f_ctl, lport, fh);\n\tif (!ema) {\n\t\tFC_LPORT_DBG(lport, \"Unable to find Exchange Manager Anchor,\"\n\t\t\t\t    \"fc_ctl <0x%x>, xid <0x%x>\\n\",\n\t\t\t\t     f_ctl,\n\t\t\t\t     (f_ctl & FC_FC_EX_CTX) ?\n\t\t\t\t     ntohs(fh->fh_ox_id) :\n\t\t\t\t     ntohs(fh->fh_rx_id));\n\t\tfc_frame_free(fp);\n\t\treturn;\n\t}\n\n\t \n\tswitch (fr_eof(fp)) {\n\tcase FC_EOF_T:\n\t\tif (f_ctl & FC_FC_END_SEQ)\n\t\t\tskb_trim(fp_skb(fp), fr_len(fp) - FC_FC_FILL(f_ctl));\n\t\tfallthrough;\n\tcase FC_EOF_N:\n\t\tif (fh->fh_type == FC_TYPE_BLS)\n\t\t\tfc_exch_recv_bls(ema->mp, fp);\n\t\telse if ((f_ctl & (FC_FC_EX_CTX | FC_FC_SEQ_CTX)) ==\n\t\t\t FC_FC_EX_CTX)\n\t\t\tfc_exch_recv_seq_resp(ema->mp, fp);\n\t\telse if (f_ctl & FC_FC_SEQ_CTX)\n\t\t\tfc_exch_recv_resp(ema->mp, fp);\n\t\telse\t \n\t\t\tfc_exch_recv_req(lport, ema->mp, fp);\n\t\tbreak;\n\tdefault:\n\t\tFC_LPORT_DBG(lport, \"dropping invalid frame (eof %x)\",\n\t\t\t     fr_eof(fp));\n\t\tfc_frame_free(fp);\n\t}\n}\nEXPORT_SYMBOL(fc_exch_recv);\n\n \nint fc_exch_init(struct fc_lport *lport)\n{\n\tif (!lport->tt.exch_mgr_reset)\n\t\tlport->tt.exch_mgr_reset = fc_exch_mgr_reset;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_exch_init);\n\n \nint fc_setup_exch_mgr(void)\n{\n\tfc_em_cachep = kmem_cache_create(\"libfc_em\", sizeof(struct fc_exch),\n\t\t\t\t\t 0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!fc_em_cachep)\n\t\treturn -ENOMEM;\n\n\t \n\tfc_cpu_order = ilog2(roundup_pow_of_two(nr_cpu_ids));\n\tfc_cpu_mask = (1 << fc_cpu_order) - 1;\n\n\tfc_exch_workqueue = create_singlethread_workqueue(\"fc_exch_workqueue\");\n\tif (!fc_exch_workqueue)\n\t\tgoto err;\n\treturn 0;\nerr:\n\tkmem_cache_destroy(fc_em_cachep);\n\treturn -ENOMEM;\n}\n\n \nvoid fc_destroy_exch_mgr(void)\n{\n\tdestroy_workqueue(fc_exch_workqueue);\n\tkmem_cache_destroy(fc_em_cachep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}