{
  "module_name": "fc_fcp.c",
  "hash_id": "7e2e9ea17091695604f04fb707e5eaf869ab54c3c606dfdd21c477d24fa63bc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libfc/fc_fcp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n\n#include <scsi/fc/fc_fc2.h>\n\n#include <scsi/libfc.h>\n\n#include \"fc_encode.h\"\n#include \"fc_libfc.h\"\n\nstatic struct kmem_cache *scsi_pkt_cachep;\n\n \n#define FC_SRB_FREE\t\t0\t\t \n#define FC_SRB_CMD_SENT\t\t(1 << 0)\t \n#define FC_SRB_RCV_STATUS\t(1 << 1)\t \n#define FC_SRB_ABORT_PENDING\t(1 << 2)\t \n#define FC_SRB_ABORTED\t\t(1 << 3)\t \n#define FC_SRB_DISCONTIG\t(1 << 4)\t \n#define FC_SRB_COMPL\t\t(1 << 5)\t \n#define FC_SRB_FCP_PROCESSING_TMO (1 << 6)\t \n\n#define FC_SRB_READ\t\t(1 << 1)\n#define FC_SRB_WRITE\t\t(1 << 0)\n\nstatic struct libfc_cmd_priv *libfc_priv(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\n \nstruct fc_fcp_internal {\n\tmempool_t\t\t*scsi_pkt_pool;\n\tspinlock_t\t\tscsi_queue_lock;\n\tstruct list_head\tscsi_pkt_queue;\n\tunsigned long\t\tlast_can_queue_ramp_down_time;\n\tunsigned long\t\tlast_can_queue_ramp_up_time;\n\tint\t\t\tmax_can_queue;\n};\n\n#define fc_get_scsi_internal(x)\t((struct fc_fcp_internal *)(x)->scsi_priv)\n\n \nstatic void fc_fcp_recv_data(struct fc_fcp_pkt *, struct fc_frame *);\nstatic void fc_fcp_recv(struct fc_seq *, struct fc_frame *, void *);\nstatic void fc_fcp_resp(struct fc_fcp_pkt *, struct fc_frame *);\nstatic void fc_fcp_complete_locked(struct fc_fcp_pkt *);\nstatic void fc_tm_done(struct fc_seq *, struct fc_frame *, void *);\nstatic void fc_fcp_error(struct fc_fcp_pkt *, struct fc_frame *);\nstatic void fc_fcp_recovery(struct fc_fcp_pkt *, u8 code);\nstatic void fc_fcp_timeout(struct timer_list *);\nstatic void fc_fcp_rec(struct fc_fcp_pkt *);\nstatic void fc_fcp_rec_error(struct fc_fcp_pkt *, struct fc_frame *);\nstatic void fc_fcp_rec_resp(struct fc_seq *, struct fc_frame *, void *);\nstatic void fc_io_compl(struct fc_fcp_pkt *);\n\nstatic void fc_fcp_srr(struct fc_fcp_pkt *, enum fc_rctl, u32);\nstatic void fc_fcp_srr_resp(struct fc_seq *, struct fc_frame *, void *);\nstatic void fc_fcp_srr_error(struct fc_fcp_pkt *, struct fc_frame *);\n\n \n#define FC_COMPLETE\t\t0\n#define FC_CMD_ABORTED\t\t1\n#define FC_CMD_RESET\t\t2\n#define FC_CMD_PLOGO\t\t3\n#define FC_SNS_RCV\t\t4\n#define FC_TRANS_ERR\t\t5\n#define FC_DATA_OVRRUN\t\t6\n#define FC_DATA_UNDRUN\t\t7\n#define FC_ERROR\t\t8\n#define FC_HRD_ERROR\t\t9\n#define FC_CRC_ERROR\t\t10\n#define FC_TIMED_OUT\t\t11\n#define FC_TRANS_RESET\t\t12\n\n \n#define FC_SCSI_TM_TOV\t\t(10 * HZ)\n#define FC_HOST_RESET_TIMEOUT\t(30 * HZ)\n#define FC_CAN_QUEUE_PERIOD\t(60 * HZ)\n\n#define FC_MAX_ERROR_CNT\t5\n#define FC_MAX_RECOV_RETRY\t3\n\n#define FC_FCP_DFLT_QUEUE_DEPTH 32\n\n \nstatic struct fc_fcp_pkt *fc_fcp_pkt_alloc(struct fc_lport *lport, gfp_t gfp)\n{\n\tstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\n\tstruct fc_fcp_pkt *fsp;\n\n\tfsp = mempool_alloc(si->scsi_pkt_pool, gfp);\n\tif (fsp) {\n\t\tmemset(fsp, 0, sizeof(*fsp));\n\t\tfsp->lp = lport;\n\t\tfsp->xfer_ddp = FC_XID_UNKNOWN;\n\t\trefcount_set(&fsp->ref_cnt, 1);\n\t\ttimer_setup(&fsp->timer, NULL, 0);\n\t\tINIT_LIST_HEAD(&fsp->list);\n\t\tspin_lock_init(&fsp->scsi_pkt_lock);\n\t} else {\n\t\tthis_cpu_inc(lport->stats->FcpPktAllocFails);\n\t}\n\treturn fsp;\n}\n\n \nstatic void fc_fcp_pkt_release(struct fc_fcp_pkt *fsp)\n{\n\tif (refcount_dec_and_test(&fsp->ref_cnt)) {\n\t\tstruct fc_fcp_internal *si = fc_get_scsi_internal(fsp->lp);\n\n\t\tmempool_free(fsp, si->scsi_pkt_pool);\n\t}\n}\n\n \nstatic void fc_fcp_pkt_hold(struct fc_fcp_pkt *fsp)\n{\n\trefcount_inc(&fsp->ref_cnt);\n}\n\n \nstatic void fc_fcp_pkt_destroy(struct fc_seq *seq, void *fsp)\n{\n\tfc_fcp_pkt_release(fsp);\n}\n\n \nstatic inline int fc_fcp_lock_pkt(struct fc_fcp_pkt *fsp)\n{\n\tspin_lock_bh(&fsp->scsi_pkt_lock);\n\tif (fsp->state & FC_SRB_COMPL) {\n\t\tspin_unlock_bh(&fsp->scsi_pkt_lock);\n\t\treturn -EPERM;\n\t}\n\n\tfc_fcp_pkt_hold(fsp);\n\treturn 0;\n}\n\n \nstatic inline void fc_fcp_unlock_pkt(struct fc_fcp_pkt *fsp)\n{\n\tspin_unlock_bh(&fsp->scsi_pkt_lock);\n\tfc_fcp_pkt_release(fsp);\n}\n\n \nstatic void fc_fcp_timer_set(struct fc_fcp_pkt *fsp, unsigned long delay)\n{\n\tif (!(fsp->state & FC_SRB_COMPL)) {\n\t\tmod_timer(&fsp->timer, jiffies + delay);\n\t\tfsp->timer_delay = delay;\n\t}\n}\n\nstatic void fc_fcp_abort_done(struct fc_fcp_pkt *fsp)\n{\n\tfsp->state |= FC_SRB_ABORTED;\n\tfsp->state &= ~FC_SRB_ABORT_PENDING;\n\n\tif (fsp->wait_for_comp)\n\t\tcomplete(&fsp->tm_done);\n\telse\n\t\tfc_fcp_complete_locked(fsp);\n}\n\n \nstatic int fc_fcp_send_abort(struct fc_fcp_pkt *fsp)\n{\n\tint rc;\n\n\tif (!fsp->seq_ptr)\n\t\treturn -EINVAL;\n\n\tthis_cpu_inc(fsp->lp->stats->FcpPktAborts);\n\n\tfsp->state |= FC_SRB_ABORT_PENDING;\n\trc = fc_seq_exch_abort(fsp->seq_ptr, 0);\n\t \n\tif (rc == -ENXIO) {\n\t\tfc_fcp_abort_done(fsp);\n\t\trc = 0;\n\t}\n\treturn rc;\n}\n\n \nstatic void fc_fcp_retry_cmd(struct fc_fcp_pkt *fsp, int status_code)\n{\n\tif (fsp->seq_ptr) {\n\t\tfc_exch_done(fsp->seq_ptr);\n\t\tfsp->seq_ptr = NULL;\n\t}\n\n\tfsp->state &= ~FC_SRB_ABORT_PENDING;\n\tfsp->io_status = 0;\n\tfsp->status_code = status_code;\n\tfc_fcp_complete_locked(fsp);\n}\n\n \nvoid fc_fcp_ddp_setup(struct fc_fcp_pkt *fsp, u16 xid)\n{\n\tstruct fc_lport *lport;\n\n\tlport = fsp->lp;\n\tif ((fsp->req_flags & FC_SRB_READ) &&\n\t    (lport->lro_enabled) && (lport->tt.ddp_setup)) {\n\t\tif (lport->tt.ddp_setup(lport, xid, scsi_sglist(fsp->cmd),\n\t\t\t\t\tscsi_sg_count(fsp->cmd)))\n\t\t\tfsp->xfer_ddp = xid;\n\t}\n}\n\n \nvoid fc_fcp_ddp_done(struct fc_fcp_pkt *fsp)\n{\n\tstruct fc_lport *lport;\n\n\tif (!fsp)\n\t\treturn;\n\n\tif (fsp->xfer_ddp == FC_XID_UNKNOWN)\n\t\treturn;\n\n\tlport = fsp->lp;\n\tif (lport->tt.ddp_done) {\n\t\tfsp->xfer_len = lport->tt.ddp_done(lport, fsp->xfer_ddp);\n\t\tfsp->xfer_ddp = FC_XID_UNKNOWN;\n\t}\n}\n\n \nstatic void fc_fcp_can_queue_ramp_up(struct fc_lport *lport)\n{\n\tstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\n\tunsigned long flags;\n\tint can_queue;\n\n\tspin_lock_irqsave(lport->host->host_lock, flags);\n\n\tif (si->last_can_queue_ramp_up_time &&\n\t    (time_before(jiffies, si->last_can_queue_ramp_up_time +\n\t\t\t FC_CAN_QUEUE_PERIOD)))\n\t\tgoto unlock;\n\n\tif (time_before(jiffies, si->last_can_queue_ramp_down_time +\n\t\t\tFC_CAN_QUEUE_PERIOD))\n\t\tgoto unlock;\n\n\tsi->last_can_queue_ramp_up_time = jiffies;\n\n\tcan_queue = lport->host->can_queue << 1;\n\tif (can_queue >= si->max_can_queue) {\n\t\tcan_queue = si->max_can_queue;\n\t\tsi->last_can_queue_ramp_down_time = 0;\n\t}\n\tlport->host->can_queue = can_queue;\n\tshost_printk(KERN_ERR, lport->host, \"libfc: increased \"\n\t\t     \"can_queue to %d.\\n\", can_queue);\n\nunlock:\n\tspin_unlock_irqrestore(lport->host->host_lock, flags);\n}\n\n \nstatic bool fc_fcp_can_queue_ramp_down(struct fc_lport *lport)\n{\n\tstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\n\tunsigned long flags;\n\tint can_queue;\n\tbool changed = false;\n\n\tspin_lock_irqsave(lport->host->host_lock, flags);\n\n\tif (si->last_can_queue_ramp_down_time &&\n\t    (time_before(jiffies, si->last_can_queue_ramp_down_time +\n\t\t\t FC_CAN_QUEUE_PERIOD)))\n\t\tgoto unlock;\n\n\tsi->last_can_queue_ramp_down_time = jiffies;\n\n\tcan_queue = lport->host->can_queue;\n\tcan_queue >>= 1;\n\tif (!can_queue)\n\t\tcan_queue = 1;\n\tlport->host->can_queue = can_queue;\n\tchanged = true;\n\nunlock:\n\tspin_unlock_irqrestore(lport->host->host_lock, flags);\n\treturn changed;\n}\n\n \nstatic inline struct fc_frame *fc_fcp_frame_alloc(struct fc_lport *lport,\n\t\t\t\t\t\t  size_t len)\n{\n\tstruct fc_frame *fp;\n\n\tfp = fc_frame_alloc(lport, len);\n\tif (likely(fp))\n\t\treturn fp;\n\n\tthis_cpu_inc(lport->stats->FcpFrameAllocFails);\n\t \n\tfc_fcp_can_queue_ramp_down(lport);\n\tshost_printk(KERN_ERR, lport->host,\n\t\t     \"libfc: Could not allocate frame, \"\n\t\t     \"reducing can_queue to %d.\\n\", lport->host->can_queue);\n\treturn NULL;\n}\n\n \nstatic inline unsigned int get_fsp_rec_tov(struct fc_fcp_pkt *fsp)\n{\n\tstruct fc_rport_libfc_priv *rpriv = fsp->rport->dd_data;\n\tunsigned int e_d_tov = FC_DEF_E_D_TOV;\n\n\tif (rpriv && rpriv->e_d_tov > e_d_tov)\n\t\te_d_tov = rpriv->e_d_tov;\n\treturn msecs_to_jiffies(e_d_tov) + HZ;\n}\n\n \nstatic void fc_fcp_recv_data(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\n{\n\tstruct scsi_cmnd *sc = fsp->cmd;\n\tstruct fc_lport *lport = fsp->lp;\n\tstruct fc_frame_header *fh;\n\tsize_t start_offset;\n\tsize_t offset;\n\tu32 crc;\n\tu32 copy_len = 0;\n\tsize_t len;\n\tvoid *buf;\n\tstruct scatterlist *sg;\n\tu32 nents;\n\tu8 host_bcode = FC_COMPLETE;\n\n\tfh = fc_frame_header_get(fp);\n\toffset = ntohl(fh->fh_parm_offset);\n\tstart_offset = offset;\n\tlen = fr_len(fp) - sizeof(*fh);\n\tbuf = fc_frame_payload_get(fp, 0);\n\n\t \n\tif (fsp->xfer_ddp != FC_XID_UNKNOWN) {\n\t\tfc_fcp_ddp_done(fsp);\n\t\tFC_FCP_DBG(fsp, \"DDP I/O in fc_fcp_recv_data set ERROR\\n\");\n\t\thost_bcode = FC_ERROR;\n\t\tgoto err;\n\t}\n\tif (offset + len > fsp->data_len) {\n\t\t \n\t\tif ((fr_flags(fp) & FCPHF_CRC_UNCHECKED) &&\n\t\t    fc_frame_crc_check(fp))\n\t\t\tgoto crc_err;\n\t\tFC_FCP_DBG(fsp, \"data received past end. len %zx offset %zx \"\n\t\t\t   \"data_len %x\\n\", len, offset, fsp->data_len);\n\n\t\t \n\t\thost_bcode = FC_DATA_OVRRUN;\n\t\tgoto err;\n\t}\n\tif (offset != fsp->xfer_len)\n\t\tfsp->state |= FC_SRB_DISCONTIG;\n\n\tsg = scsi_sglist(sc);\n\tnents = scsi_sg_count(sc);\n\n\tif (!(fr_flags(fp) & FCPHF_CRC_UNCHECKED)) {\n\t\tcopy_len = fc_copy_buffer_to_sglist(buf, len, sg, &nents,\n\t\t\t\t\t\t    &offset, NULL);\n\t} else {\n\t\tcrc = crc32(~0, (u8 *) fh, sizeof(*fh));\n\t\tcopy_len = fc_copy_buffer_to_sglist(buf, len, sg, &nents,\n\t\t\t\t\t\t    &offset, &crc);\n\t\tbuf = fc_frame_payload_get(fp, 0);\n\t\tif (len % 4)\n\t\t\tcrc = crc32(crc, buf + len, 4 - (len % 4));\n\n\t\tif (~crc != le32_to_cpu(fr_crc(fp))) {\ncrc_err:\n\t\t\tthis_cpu_inc(lport->stats->ErrorFrames);\n\t\t\t \n\t\t\tif (this_cpu_inc_return(lport->stats->InvalidCRCCount) < FC_MAX_ERROR_CNT)\n\t\t\t\tprintk(KERN_WARNING \"libfc: CRC error on data \"\n\t\t\t\t       \"frame for port (%6.6x)\\n\",\n\t\t\t\t       lport->port_id);\n\t\t\t \n\t\t\tif (fsp->state & FC_SRB_DISCONTIG) {\n\t\t\t\thost_bcode = FC_CRC_ERROR;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (fsp->xfer_contig_end == start_offset)\n\t\tfsp->xfer_contig_end += copy_len;\n\tfsp->xfer_len += copy_len;\n\n\t \n\tif (unlikely(fsp->state & FC_SRB_RCV_STATUS) &&\n\t    fsp->xfer_len == fsp->data_len - fsp->scsi_resid) {\n\t\tFC_FCP_DBG( fsp, \"complete out-of-order sequence\\n\" );\n\t\tfc_fcp_complete_locked(fsp);\n\t}\n\treturn;\nerr:\n\tfc_fcp_recovery(fsp, host_bcode);\n}\n\n \nstatic int fc_fcp_send_data(struct fc_fcp_pkt *fsp, struct fc_seq *seq,\n\t\t\t    size_t offset, size_t seq_blen)\n{\n\tstruct fc_exch *ep;\n\tstruct scsi_cmnd *sc;\n\tstruct scatterlist *sg;\n\tstruct fc_frame *fp = NULL;\n\tstruct fc_lport *lport = fsp->lp;\n\tstruct page *page;\n\tsize_t remaining;\n\tsize_t t_blen;\n\tsize_t tlen;\n\tsize_t sg_bytes;\n\tsize_t frame_offset, fh_parm_offset;\n\tsize_t off;\n\tint error;\n\tvoid *data = NULL;\n\tvoid *page_addr;\n\tint using_sg = lport->sg_supp;\n\tu32 f_ctl;\n\n\tWARN_ON(seq_blen <= 0);\n\tif (unlikely(offset + seq_blen > fsp->data_len)) {\n\t\t \n\t\tFC_FCP_DBG(fsp, \"xfer-ready past end. seq_blen %zx \"\n\t\t\t   \"offset %zx\\n\", seq_blen, offset);\n\t\tfc_fcp_send_abort(fsp);\n\t\treturn 0;\n\t} else if (offset != fsp->xfer_len) {\n\t\t \n\t\tFC_FCP_DBG(fsp, \"xfer-ready non-contiguous. \"\n\t\t\t   \"seq_blen %zx offset %zx\\n\", seq_blen, offset);\n\t}\n\n\t \n\tt_blen = fsp->max_payload;\n\tif (lport->seq_offload) {\n\t\tt_blen = min(seq_blen, (size_t)lport->lso_max);\n\t\tFC_FCP_DBG(fsp, \"fsp=%p:lso:blen=%zx lso_max=0x%x t_blen=%zx\\n\",\n\t\t\t   fsp, seq_blen, lport->lso_max, t_blen);\n\t}\n\n\tif (t_blen > 512)\n\t\tt_blen &= ~(512 - 1);\t \n\tsc = fsp->cmd;\n\n\tremaining = seq_blen;\n\tfh_parm_offset = frame_offset = offset;\n\ttlen = 0;\n\tseq = fc_seq_start_next(seq);\n\tf_ctl = FC_FC_REL_OFF;\n\tWARN_ON(!seq);\n\n\tsg = scsi_sglist(sc);\n\n\twhile (remaining > 0 && sg) {\n\t\tif (offset >= sg->length) {\n\t\t\toffset -= sg->length;\n\t\t\tsg = sg_next(sg);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!fp) {\n\t\t\ttlen = min(t_blen, remaining);\n\n\t\t\t \n\t\t\tif (tlen % 4)\n\t\t\t\tusing_sg = 0;\n\t\t\tfp = fc_frame_alloc(lport, using_sg ? 0 : tlen);\n\t\t\tif (!fp)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tdata = fc_frame_header_get(fp) + 1;\n\t\t\tfh_parm_offset = frame_offset;\n\t\t\tfr_max_payload(fp) = fsp->max_payload;\n\t\t}\n\n\t\toff = offset + sg->offset;\n\t\tsg_bytes = min(tlen, sg->length - offset);\n\t\tsg_bytes = min(sg_bytes,\n\t\t\t       (size_t) (PAGE_SIZE - (off & ~PAGE_MASK)));\n\t\tpage = sg_page(sg) + (off >> PAGE_SHIFT);\n\t\tif (using_sg) {\n\t\t\tget_page(page);\n\t\t\tskb_fill_page_desc(fp_skb(fp),\n\t\t\t\t\t   skb_shinfo(fp_skb(fp))->nr_frags,\n\t\t\t\t\t   page, off & ~PAGE_MASK, sg_bytes);\n\t\t\tfp_skb(fp)->data_len += sg_bytes;\n\t\t\tfr_len(fp) += sg_bytes;\n\t\t\tfp_skb(fp)->truesize += PAGE_SIZE;\n\t\t} else {\n\t\t\t \n\t\t\tpage_addr = kmap_atomic(page);\n\t\t\tmemcpy(data, (char *)page_addr + (off & ~PAGE_MASK),\n\t\t\t       sg_bytes);\n\t\t\tkunmap_atomic(page_addr);\n\t\t\tdata += sg_bytes;\n\t\t}\n\t\toffset += sg_bytes;\n\t\tframe_offset += sg_bytes;\n\t\ttlen -= sg_bytes;\n\t\tremaining -= sg_bytes;\n\n\t\tif ((skb_shinfo(fp_skb(fp))->nr_frags < FC_FRAME_SG_LEN) &&\n\t\t    (tlen))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (remaining == 0)\n\t\t\tf_ctl |= FC_FC_SEQ_INIT | FC_FC_END_SEQ;\n\n\t\tep = fc_seq_exch(seq);\n\t\tfc_fill_fc_hdr(fp, FC_RCTL_DD_SOL_DATA, ep->did, ep->sid,\n\t\t\t       FC_TYPE_FCP, f_ctl, fh_parm_offset);\n\n\t\t \n\t\terror = fc_seq_send(lport, seq, fp);\n\t\tif (error) {\n\t\t\tWARN_ON(1);\t\t \n\t\t\treturn error;\n\t\t}\n\t\tfp = NULL;\n\t}\n\tfsp->xfer_len += seq_blen;\t \n\treturn 0;\n}\n\n \nstatic void fc_fcp_abts_resp(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\n{\n\tint ba_done = 1;\n\tstruct fc_ba_rjt *brp;\n\tstruct fc_frame_header *fh;\n\n\tfh = fc_frame_header_get(fp);\n\tswitch (fh->fh_r_ctl) {\n\tcase FC_RCTL_BA_ACC:\n\t\tbreak;\n\tcase FC_RCTL_BA_RJT:\n\t\tbrp = fc_frame_payload_get(fp, sizeof(*brp));\n\t\tif (brp && brp->br_reason == FC_BA_RJT_LOG_ERR)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tba_done = 0;\n\t}\n\n\tif (ba_done)\n\t\tfc_fcp_abort_done(fsp);\n}\n\n \nstatic void fc_fcp_recv(struct fc_seq *seq, struct fc_frame *fp, void *arg)\n{\n\tstruct fc_fcp_pkt *fsp = (struct fc_fcp_pkt *)arg;\n\tstruct fc_lport *lport = fsp->lp;\n\tstruct fc_frame_header *fh;\n\tstruct fcp_txrdy *dd;\n\tu8 r_ctl;\n\tint rc = 0;\n\n\tif (IS_ERR(fp)) {\n\t\tfc_fcp_error(fsp, fp);\n\t\treturn;\n\t}\n\n\tfh = fc_frame_header_get(fp);\n\tr_ctl = fh->fh_r_ctl;\n\n\tif (lport->state != LPORT_ST_READY) {\n\t\tFC_FCP_DBG(fsp, \"lport state %d, ignoring r_ctl %x\\n\",\n\t\t\t   lport->state, r_ctl);\n\t\tgoto out;\n\t}\n\tif (fc_fcp_lock_pkt(fsp))\n\t\tgoto out;\n\n\tif (fh->fh_type == FC_TYPE_BLS) {\n\t\tfc_fcp_abts_resp(fsp, fp);\n\t\tgoto unlock;\n\t}\n\n\tif (fsp->state & (FC_SRB_ABORTED | FC_SRB_ABORT_PENDING)) {\n\t\tFC_FCP_DBG(fsp, \"command aborted, ignoring r_ctl %x\\n\", r_ctl);\n\t\tgoto unlock;\n\t}\n\n\tif (r_ctl == FC_RCTL_DD_DATA_DESC) {\n\t\t \n\t\tWARN_ON(fr_flags(fp) & FCPHF_CRC_UNCHECKED);\n\t\tdd = fc_frame_payload_get(fp, sizeof(*dd));\n\t\tWARN_ON(!dd);\n\n\t\trc = fc_fcp_send_data(fsp, seq,\n\t\t\t\t      (size_t) ntohl(dd->ft_data_ro),\n\t\t\t\t      (size_t) ntohl(dd->ft_burst_len));\n\t\tif (!rc)\n\t\t\tseq->rec_data = fsp->xfer_len;\n\t} else if (r_ctl == FC_RCTL_DD_SOL_DATA) {\n\t\t \n\t\tWARN_ON(fr_len(fp) < sizeof(*fh));\t \n\t\tfc_fcp_recv_data(fsp, fp);\n\t\tseq->rec_data = fsp->xfer_contig_end;\n\t} else if (r_ctl == FC_RCTL_DD_CMD_STATUS) {\n\t\tWARN_ON(fr_flags(fp) & FCPHF_CRC_UNCHECKED);\n\n\t\tfc_fcp_resp(fsp, fp);\n\t} else {\n\t\tFC_FCP_DBG(fsp, \"unexpected frame.  r_ctl %x\\n\", r_ctl);\n\t}\nunlock:\n\tfc_fcp_unlock_pkt(fsp);\nout:\n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_fcp_resp(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\n{\n\tstruct fc_frame_header *fh;\n\tstruct fcp_resp *fc_rp;\n\tstruct fcp_resp_ext *rp_ex;\n\tstruct fcp_resp_rsp_info *fc_rp_info;\n\tu32 plen;\n\tu32 expected_len;\n\tu32 respl = 0;\n\tu32 snsl = 0;\n\tu8 flags = 0;\n\n\tplen = fr_len(fp);\n\tfh = (struct fc_frame_header *)fr_hdr(fp);\n\tif (unlikely(plen < sizeof(*fh) + sizeof(*fc_rp)))\n\t\tgoto len_err;\n\tplen -= sizeof(*fh);\n\tfc_rp = (struct fcp_resp *)(fh + 1);\n\tfsp->cdb_status = fc_rp->fr_status;\n\tflags = fc_rp->fr_flags;\n\tfsp->scsi_comp_flags = flags;\n\texpected_len = fsp->data_len;\n\n\t \n\tfc_fcp_ddp_done(fsp);\n\n\tif (unlikely((flags & ~FCP_CONF_REQ) || fc_rp->fr_status)) {\n\t\trp_ex = (void *)(fc_rp + 1);\n\t\tif (flags & (FCP_RSP_LEN_VAL | FCP_SNS_LEN_VAL)) {\n\t\t\tif (plen < sizeof(*fc_rp) + sizeof(*rp_ex))\n\t\t\t\tgoto len_err;\n\t\t\tfc_rp_info = (struct fcp_resp_rsp_info *)(rp_ex + 1);\n\t\t\tif (flags & FCP_RSP_LEN_VAL) {\n\t\t\t\trespl = ntohl(rp_ex->fr_rsp_len);\n\t\t\t\tif ((respl != FCP_RESP_RSP_INFO_LEN4) &&\n\t\t\t\t    (respl != FCP_RESP_RSP_INFO_LEN8))\n\t\t\t\t\tgoto len_err;\n\t\t\t\tif (fsp->wait_for_comp) {\n\t\t\t\t\t \n\t\t\t\t\tfsp->cdb_status = fc_rp_info->rsp_code;\n\t\t\t\t\tcomplete(&fsp->tm_done);\n\t\t\t\t\t \n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flags & FCP_SNS_LEN_VAL) {\n\t\t\t\tsnsl = ntohl(rp_ex->fr_sns_len);\n\t\t\t\tif (snsl > SCSI_SENSE_BUFFERSIZE)\n\t\t\t\t\tsnsl = SCSI_SENSE_BUFFERSIZE;\n\t\t\t\tmemcpy(fsp->cmd->sense_buffer,\n\t\t\t\t       (char *)fc_rp_info + respl, snsl);\n\t\t\t}\n\t\t}\n\t\tif (flags & (FCP_RESID_UNDER | FCP_RESID_OVER)) {\n\t\t\tif (plen < sizeof(*fc_rp) + sizeof(rp_ex->fr_resid))\n\t\t\t\tgoto len_err;\n\t\t\tif (flags & FCP_RESID_UNDER) {\n\t\t\t\tfsp->scsi_resid = ntohl(rp_ex->fr_resid);\n\t\t\t\t \n\t\t\t\tif (!(flags & FCP_SNS_LEN_VAL) &&\n\t\t\t\t    (fc_rp->fr_status == 0) &&\n\t\t\t\t    (scsi_bufflen(fsp->cmd) -\n\t\t\t\t     fsp->scsi_resid) < fsp->cmd->underflow)\n\t\t\t\t\tgoto err;\n\t\t\t\texpected_len -= fsp->scsi_resid;\n\t\t\t} else {\n\t\t\t\tfsp->status_code = FC_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\tfsp->state |= FC_SRB_RCV_STATUS;\n\n\t \n\tif (unlikely(fsp->cdb_status == SAM_STAT_GOOD &&\n\t\t     fsp->xfer_len != expected_len)) {\n\t\tif (fsp->xfer_len < expected_len) {\n\t\t\t \n\t\t\tif (fsp->lp->qfull) {\n\t\t\t\tFC_FCP_DBG(fsp, \"tgt %6.6x queue busy retry\\n\",\n\t\t\t\t\t   fsp->rport->port_id);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tFC_FCP_DBG(fsp, \"tgt %6.6x xfer len %zx data underrun \"\n\t\t\t\t   \"len %x, data len %x\\n\",\n\t\t\t\t   fsp->rport->port_id,\n\t\t\t\t   fsp->xfer_len, expected_len, fsp->data_len);\n\t\t\tfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\n\t\t\treturn;\n\t\t}\n\t\tfsp->status_code = FC_DATA_OVRRUN;\n\t\tFC_FCP_DBG(fsp, \"tgt %6.6x xfer len %zx greater than expected, \"\n\t\t\t   \"len %x, data len %x\\n\",\n\t\t\t   fsp->rport->port_id,\n\t\t\t   fsp->xfer_len, expected_len, fsp->data_len);\n\t}\n\tfc_fcp_complete_locked(fsp);\n\treturn;\n\nlen_err:\n\tFC_FCP_DBG(fsp, \"short FCP response. flags 0x%x len %u respl %u \"\n\t\t   \"snsl %u\\n\", flags, fr_len(fp), respl, snsl);\nerr:\n\tfsp->status_code = FC_ERROR;\n\tfc_fcp_complete_locked(fsp);\n}\n\n \nstatic void fc_fcp_complete_locked(struct fc_fcp_pkt *fsp)\n{\n\tstruct fc_lport *lport = fsp->lp;\n\tstruct fc_seq *seq;\n\tstruct fc_exch *ep;\n\tu32 f_ctl;\n\n\tif (fsp->state & FC_SRB_ABORT_PENDING)\n\t\treturn;\n\n\tif (fsp->state & FC_SRB_ABORTED) {\n\t\tif (!fsp->status_code)\n\t\t\tfsp->status_code = FC_CMD_ABORTED;\n\t} else {\n\t\t \n\t\tif (fsp->cdb_status == SAM_STAT_GOOD &&\n\t\t    fsp->xfer_len < fsp->data_len && !fsp->io_status &&\n\t\t    (!(fsp->scsi_comp_flags & FCP_RESID_UNDER) ||\n\t\t     fsp->xfer_len < fsp->data_len - fsp->scsi_resid)) {\n\t\t\tFC_FCP_DBG(fsp, \"data underrun, xfer %zx data %x\\n\",\n\t\t\t\t    fsp->xfer_len, fsp->data_len);\n\t\t\tfsp->status_code = FC_DATA_UNDRUN;\n\t\t}\n\t}\n\n\tseq = fsp->seq_ptr;\n\tif (seq) {\n\t\tfsp->seq_ptr = NULL;\n\t\tif (unlikely(fsp->scsi_comp_flags & FCP_CONF_REQ)) {\n\t\t\tstruct fc_frame *conf_frame;\n\t\t\tstruct fc_seq *csp;\n\n\t\t\tcsp = fc_seq_start_next(seq);\n\t\t\tconf_frame = fc_fcp_frame_alloc(fsp->lp, 0);\n\t\t\tif (conf_frame) {\n\t\t\t\tf_ctl = FC_FC_SEQ_INIT;\n\t\t\t\tf_ctl |= FC_FC_LAST_SEQ | FC_FC_END_SEQ;\n\t\t\t\tep = fc_seq_exch(seq);\n\t\t\t\tfc_fill_fc_hdr(conf_frame, FC_RCTL_DD_SOL_CTL,\n\t\t\t\t\t       ep->did, ep->sid,\n\t\t\t\t\t       FC_TYPE_FCP, f_ctl, 0);\n\t\t\t\tfc_seq_send(lport, csp, conf_frame);\n\t\t\t}\n\t\t}\n\t\tfc_exch_done(seq);\n\t}\n\t \n\tif (fsp->cmd)\n\t\tfc_io_compl(fsp);\n}\n\n \nstatic void fc_fcp_cleanup_cmd(struct fc_fcp_pkt *fsp, int error)\n{\n\tif (fsp->seq_ptr) {\n\t\tfc_exch_done(fsp->seq_ptr);\n\t\tfsp->seq_ptr = NULL;\n\t}\n\tfsp->status_code = error;\n}\n\n \nstatic void fc_fcp_cleanup_each_cmd(struct fc_lport *lport, unsigned int id,\n\t\t\t\t    unsigned int lun, int error)\n{\n\tstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\n\tstruct fc_fcp_pkt *fsp;\n\tstruct scsi_cmnd *sc_cmd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&si->scsi_queue_lock, flags);\nrestart:\n\tlist_for_each_entry(fsp, &si->scsi_pkt_queue, list) {\n\t\tsc_cmd = fsp->cmd;\n\t\tif (id != -1 && scmd_id(sc_cmd) != id)\n\t\t\tcontinue;\n\n\t\tif (lun != -1 && sc_cmd->device->lun != lun)\n\t\t\tcontinue;\n\n\t\tfc_fcp_pkt_hold(fsp);\n\t\tspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\n\n\t\tspin_lock_bh(&fsp->scsi_pkt_lock);\n\t\tif (!(fsp->state & FC_SRB_COMPL)) {\n\t\t\tfsp->state |= FC_SRB_COMPL;\n\t\t\t \n\t\t\tspin_unlock_bh(&fsp->scsi_pkt_lock);\n\n\t\t\tfc_fcp_cleanup_cmd(fsp, error);\n\n\t\t\tspin_lock_bh(&fsp->scsi_pkt_lock);\n\t\t\tfc_io_compl(fsp);\n\t\t}\n\t\tspin_unlock_bh(&fsp->scsi_pkt_lock);\n\n\t\tfc_fcp_pkt_release(fsp);\n\t\tspin_lock_irqsave(&si->scsi_queue_lock, flags);\n\t\t \n\t\tgoto restart;\n\t}\n\tspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\n}\n\n \nstatic void fc_fcp_abort_io(struct fc_lport *lport)\n{\n\tfc_fcp_cleanup_each_cmd(lport, -1, -1, FC_HRD_ERROR);\n}\n\n \nstatic int fc_fcp_pkt_send(struct fc_lport *lport, struct fc_fcp_pkt *fsp)\n{\n\tstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\n\tunsigned long flags;\n\tint rc;\n\n\tlibfc_priv(fsp->cmd)->fsp = fsp;\n\tfsp->cdb_cmd.fc_dl = htonl(fsp->data_len);\n\tfsp->cdb_cmd.fc_flags = fsp->req_flags & ~FCP_CFL_LEN_MASK;\n\n\tint_to_scsilun(fsp->cmd->device->lun, &fsp->cdb_cmd.fc_lun);\n\tmemcpy(fsp->cdb_cmd.fc_cdb, fsp->cmd->cmnd, fsp->cmd->cmd_len);\n\n\tspin_lock_irqsave(&si->scsi_queue_lock, flags);\n\tlist_add_tail(&fsp->list, &si->scsi_pkt_queue);\n\tspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\n\trc = lport->tt.fcp_cmd_send(lport, fsp, fc_fcp_recv);\n\tif (unlikely(rc)) {\n\t\tspin_lock_irqsave(&si->scsi_queue_lock, flags);\n\t\tlibfc_priv(fsp->cmd)->fsp = NULL;\n\t\tlist_del(&fsp->list);\n\t\tspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int fc_fcp_cmd_send(struct fc_lport *lport, struct fc_fcp_pkt *fsp,\n\t\t\t   void (*resp)(struct fc_seq *,\n\t\t\t\t\tstruct fc_frame *fp,\n\t\t\t\t\tvoid *arg))\n{\n\tstruct fc_frame *fp;\n\tstruct fc_seq *seq;\n\tstruct fc_rport *rport;\n\tstruct fc_rport_libfc_priv *rpriv;\n\tconst size_t len = sizeof(fsp->cdb_cmd);\n\tint rc = 0;\n\n\tif (fc_fcp_lock_pkt(fsp))\n\t\treturn 0;\n\n\tfp = fc_fcp_frame_alloc(lport, sizeof(fsp->cdb_cmd));\n\tif (!fp) {\n\t\trc = -1;\n\t\tgoto unlock;\n\t}\n\n\tmemcpy(fc_frame_payload_get(fp, len), &fsp->cdb_cmd, len);\n\tfr_fsp(fp) = fsp;\n\trport = fsp->rport;\n\tfsp->max_payload = rport->maxframe_size;\n\trpriv = rport->dd_data;\n\n\tfc_fill_fc_hdr(fp, FC_RCTL_DD_UNSOL_CMD, rport->port_id,\n\t\t       rpriv->local_port->port_id, FC_TYPE_FCP,\n\t\t       FC_FCTL_REQ, 0);\n\n\tseq = fc_exch_seq_send(lport, fp, resp, fc_fcp_pkt_destroy, fsp, 0);\n\tif (!seq) {\n\t\trc = -1;\n\t\tgoto unlock;\n\t}\n\tfsp->seq_ptr = seq;\n\tfc_fcp_pkt_hold(fsp);\t \n\n\tfsp->timer.function = fc_fcp_timeout;\n\tif (rpriv->flags & FC_RP_FLAGS_REC_SUPPORTED)\n\t\tfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\n\nunlock:\n\tfc_fcp_unlock_pkt(fsp);\n\treturn rc;\n}\n\n \nstatic void fc_fcp_error(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\n{\n\tint error = PTR_ERR(fp);\n\n\tif (fc_fcp_lock_pkt(fsp))\n\t\treturn;\n\n\tif (error == -FC_EX_CLOSED) {\n\t\tfc_fcp_retry_cmd(fsp, FC_ERROR);\n\t\tgoto unlock;\n\t}\n\n\t \n\tfsp->state &= ~FC_SRB_ABORT_PENDING;\n\tfsp->status_code = FC_CMD_PLOGO;\n\tfc_fcp_complete_locked(fsp);\nunlock:\n\tfc_fcp_unlock_pkt(fsp);\n}\n\n \nstatic int fc_fcp_pkt_abort(struct fc_fcp_pkt *fsp)\n{\n\tint rc = FAILED;\n\tunsigned long ticks_left;\n\n\tFC_FCP_DBG(fsp, \"pkt abort state %x\\n\", fsp->state);\n\tif (fc_fcp_send_abort(fsp)) {\n\t\tFC_FCP_DBG(fsp, \"failed to send abort\\n\");\n\t\treturn FAILED;\n\t}\n\n\tif (fsp->state & FC_SRB_ABORTED) {\n\t\tFC_FCP_DBG(fsp, \"target abort cmd  completed\\n\");\n\t\treturn SUCCESS;\n\t}\n\n\tinit_completion(&fsp->tm_done);\n\tfsp->wait_for_comp = 1;\n\n\tspin_unlock_bh(&fsp->scsi_pkt_lock);\n\tticks_left = wait_for_completion_timeout(&fsp->tm_done,\n\t\t\t\t\t\t\tFC_SCSI_TM_TOV);\n\tspin_lock_bh(&fsp->scsi_pkt_lock);\n\tfsp->wait_for_comp = 0;\n\n\tif (!ticks_left) {\n\t\tFC_FCP_DBG(fsp, \"target abort cmd  failed\\n\");\n\t} else if (fsp->state & FC_SRB_ABORTED) {\n\t\tFC_FCP_DBG(fsp, \"target abort cmd  passed\\n\");\n\t\trc = SUCCESS;\n\t\tfc_fcp_complete_locked(fsp);\n\t}\n\n\treturn rc;\n}\n\n \nstatic void fc_lun_reset_send(struct timer_list *t)\n{\n\tstruct fc_fcp_pkt *fsp = from_timer(fsp, t, timer);\n\tstruct fc_lport *lport = fsp->lp;\n\n\tif (lport->tt.fcp_cmd_send(lport, fsp, fc_tm_done)) {\n\t\tif (fsp->recov_retry++ >= FC_MAX_RECOV_RETRY)\n\t\t\treturn;\n\t\tif (fc_fcp_lock_pkt(fsp))\n\t\t\treturn;\n\t\tfsp->timer.function = fc_lun_reset_send;\n\t\tfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\n\t\tfc_fcp_unlock_pkt(fsp);\n\t}\n}\n\n \nstatic int fc_lun_reset(struct fc_lport *lport, struct fc_fcp_pkt *fsp,\n\t\t\tunsigned int id, unsigned int lun)\n{\n\tint rc;\n\n\tfsp->cdb_cmd.fc_dl = htonl(fsp->data_len);\n\tfsp->cdb_cmd.fc_tm_flags = FCP_TMF_LUN_RESET;\n\tint_to_scsilun(lun, &fsp->cdb_cmd.fc_lun);\n\n\tfsp->wait_for_comp = 1;\n\tinit_completion(&fsp->tm_done);\n\n\tfc_lun_reset_send(&fsp->timer);\n\n\t \n\trc = wait_for_completion_timeout(&fsp->tm_done, FC_SCSI_TM_TOV);\n\n\tspin_lock_bh(&fsp->scsi_pkt_lock);\n\tfsp->state |= FC_SRB_COMPL;\n\tspin_unlock_bh(&fsp->scsi_pkt_lock);\n\n\tdel_timer_sync(&fsp->timer);\n\n\tspin_lock_bh(&fsp->scsi_pkt_lock);\n\tif (fsp->seq_ptr) {\n\t\tfc_exch_done(fsp->seq_ptr);\n\t\tfsp->seq_ptr = NULL;\n\t}\n\tfsp->wait_for_comp = 0;\n\tspin_unlock_bh(&fsp->scsi_pkt_lock);\n\n\tif (!rc) {\n\t\tFC_SCSI_DBG(lport, \"lun reset failed\\n\");\n\t\treturn FAILED;\n\t}\n\n\t \n\tif (fsp->cdb_status != FCP_TMF_CMPL)\n\t\treturn FAILED;\n\n\tFC_SCSI_DBG(lport, \"lun reset to lun %u completed\\n\", lun);\n\tfc_fcp_cleanup_each_cmd(lport, id, lun, FC_CMD_ABORTED);\n\treturn SUCCESS;\n}\n\n \nstatic void fc_tm_done(struct fc_seq *seq, struct fc_frame *fp, void *arg)\n{\n\tstruct fc_fcp_pkt *fsp = arg;\n\tstruct fc_frame_header *fh;\n\n\tif (IS_ERR(fp)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (fc_fcp_lock_pkt(fsp))\n\t\tgoto out;\n\n\t \n\tif (!fsp->seq_ptr || !fsp->wait_for_comp)\n\t\tgoto out_unlock;\n\n\tfh = fc_frame_header_get(fp);\n\tif (fh->fh_type != FC_TYPE_BLS)\n\t\tfc_fcp_resp(fsp, fp);\n\tfsp->seq_ptr = NULL;\n\tfc_exch_done(seq);\nout_unlock:\n\tfc_fcp_unlock_pkt(fsp);\nout:\n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_fcp_cleanup(struct fc_lport *lport)\n{\n\tfc_fcp_cleanup_each_cmd(lport, -1, -1, FC_ERROR);\n}\n\n \nstatic void fc_fcp_timeout(struct timer_list *t)\n{\n\tstruct fc_fcp_pkt *fsp = from_timer(fsp, t, timer);\n\tstruct fc_rport *rport = fsp->rport;\n\tstruct fc_rport_libfc_priv *rpriv = rport->dd_data;\n\n\tif (fc_fcp_lock_pkt(fsp))\n\t\treturn;\n\n\tif (fsp->cdb_cmd.fc_tm_flags)\n\t\tgoto unlock;\n\n\tif (fsp->lp->qfull) {\n\t\tFC_FCP_DBG(fsp, \"fcp timeout, resetting timer delay %d\\n\",\n\t\t\t   fsp->timer_delay);\n\t\tfsp->timer.function = fc_fcp_timeout;\n\t\tfc_fcp_timer_set(fsp, fsp->timer_delay);\n\t\tgoto unlock;\n\t}\n\tFC_FCP_DBG(fsp, \"fcp timeout, delay %d flags %x state %x\\n\",\n\t\t   fsp->timer_delay, rpriv->flags, fsp->state);\n\tfsp->state |= FC_SRB_FCP_PROCESSING_TMO;\n\n\tif (rpriv->flags & FC_RP_FLAGS_REC_SUPPORTED)\n\t\tfc_fcp_rec(fsp);\n\telse if (fsp->state & FC_SRB_RCV_STATUS)\n\t\tfc_fcp_complete_locked(fsp);\n\telse\n\t\tfc_fcp_recovery(fsp, FC_TIMED_OUT);\n\tfsp->state &= ~FC_SRB_FCP_PROCESSING_TMO;\nunlock:\n\tfc_fcp_unlock_pkt(fsp);\n}\n\n \nstatic void fc_fcp_rec(struct fc_fcp_pkt *fsp)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_frame *fp;\n\tstruct fc_rport *rport;\n\tstruct fc_rport_libfc_priv *rpriv;\n\n\tlport = fsp->lp;\n\trport = fsp->rport;\n\trpriv = rport->dd_data;\n\tif (!fsp->seq_ptr || rpriv->rp_state != RPORT_ST_READY) {\n\t\tfsp->status_code = FC_HRD_ERROR;\n\t\tfsp->io_status = 0;\n\t\tfc_fcp_complete_locked(fsp);\n\t\treturn;\n\t}\n\n\tfp = fc_fcp_frame_alloc(lport, sizeof(struct fc_els_rec));\n\tif (!fp)\n\t\tgoto retry;\n\n\tfr_seq(fp) = fsp->seq_ptr;\n\tfc_fill_fc_hdr(fp, FC_RCTL_ELS_REQ, rport->port_id,\n\t\t       rpriv->local_port->port_id, FC_TYPE_ELS,\n\t\t       FC_FCTL_REQ, 0);\n\tif (lport->tt.elsct_send(lport, rport->port_id, fp, ELS_REC,\n\t\t\t\t fc_fcp_rec_resp, fsp,\n\t\t\t\t 2 * lport->r_a_tov)) {\n\t\tfc_fcp_pkt_hold(fsp);\t\t \n\t\treturn;\n\t}\nretry:\n\tif (fsp->recov_retry++ < FC_MAX_RECOV_RETRY)\n\t\tfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\n\telse\n\t\tfc_fcp_recovery(fsp, FC_TIMED_OUT);\n}\n\n \nstatic void fc_fcp_rec_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)\n{\n\tstruct fc_fcp_pkt *fsp = (struct fc_fcp_pkt *)arg;\n\tstruct fc_els_rec_acc *recp;\n\tstruct fc_els_ls_rjt *rjt;\n\tu32 e_stat;\n\tu8 opcode;\n\tu32 offset;\n\tenum dma_data_direction data_dir;\n\tenum fc_rctl r_ctl;\n\tstruct fc_rport_libfc_priv *rpriv;\n\n\tif (IS_ERR(fp)) {\n\t\tfc_fcp_rec_error(fsp, fp);\n\t\treturn;\n\t}\n\n\tif (fc_fcp_lock_pkt(fsp))\n\t\tgoto out;\n\n\tfsp->recov_retry = 0;\n\topcode = fc_frame_payload_op(fp);\n\tif (opcode == ELS_LS_RJT) {\n\t\trjt = fc_frame_payload_get(fp, sizeof(*rjt));\n\t\tswitch (rjt->er_reason) {\n\t\tdefault:\n\t\t\tFC_FCP_DBG(fsp,\n\t\t\t\t   \"device %x invalid REC reject %d/%d\\n\",\n\t\t\t\t   fsp->rport->port_id, rjt->er_reason,\n\t\t\t\t   rjt->er_explan);\n\t\t\tfallthrough;\n\t\tcase ELS_RJT_UNSUP:\n\t\t\tFC_FCP_DBG(fsp, \"device does not support REC\\n\");\n\t\t\trpriv = fsp->rport->dd_data;\n\t\t\t \n\t\t\trpriv->flags &= ~FC_RP_FLAGS_REC_SUPPORTED;\n\t\t\tbreak;\n\t\tcase ELS_RJT_LOGIC:\n\t\tcase ELS_RJT_UNAB:\n\t\t\tFC_FCP_DBG(fsp, \"device %x REC reject %d/%d\\n\",\n\t\t\t\t   fsp->rport->port_id, rjt->er_reason,\n\t\t\t\t   rjt->er_explan);\n\t\t\t \n\t\t\tif (rjt->er_explan == ELS_EXPL_OXID_RXID) {\n\t\t\t\tstruct fc_exch *ep = fc_seq_exch(fsp->seq_ptr);\n\t\t\t\tep->state |= FC_EX_QUARANTINE;\n\t\t\t\tfsp->state |= FC_SRB_ABORTED;\n\t\t\t\tfc_fcp_retry_cmd(fsp, FC_TRANS_RESET);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfc_fcp_recovery(fsp, FC_TRANS_RESET);\n\t\t\tbreak;\n\t\t}\n\t} else if (opcode == ELS_LS_ACC) {\n\t\tif (fsp->state & FC_SRB_ABORTED)\n\t\t\tgoto unlock_out;\n\n\t\tdata_dir = fsp->cmd->sc_data_direction;\n\t\trecp = fc_frame_payload_get(fp, sizeof(*recp));\n\t\toffset = ntohl(recp->reca_fc4value);\n\t\te_stat = ntohl(recp->reca_e_stat);\n\n\t\tif (e_stat & ESB_ST_COMPLETE) {\n\n\t\t\t \n\t\t\tif (data_dir == DMA_TO_DEVICE) {\n\t\t\t\tr_ctl = FC_RCTL_DD_CMD_STATUS;\n\t\t\t} else if (fsp->xfer_contig_end == offset) {\n\t\t\t\tr_ctl = FC_RCTL_DD_CMD_STATUS;\n\t\t\t} else {\n\t\t\t\toffset = fsp->xfer_contig_end;\n\t\t\t\tr_ctl = FC_RCTL_DD_SOL_DATA;\n\t\t\t}\n\t\t\tfc_fcp_srr(fsp, r_ctl, offset);\n\t\t} else if (e_stat & ESB_ST_SEQ_INIT) {\n\t\t\t \n\t\t\tfc_fcp_timer_set(fsp,  get_fsp_rec_tov(fsp));\n\t\t} else {\n\n\t\t\t \n\t\t\tr_ctl = FC_RCTL_DD_SOL_DATA;\n\t\t\tif (data_dir == DMA_TO_DEVICE) {\n\t\t\t\tr_ctl = FC_RCTL_DD_CMD_STATUS;\n\t\t\t\tif (offset < fsp->data_len)\n\t\t\t\t\tr_ctl = FC_RCTL_DD_DATA_DESC;\n\t\t\t} else if (offset == fsp->xfer_contig_end) {\n\t\t\t\tr_ctl = FC_RCTL_DD_CMD_STATUS;\n\t\t\t} else if (fsp->xfer_contig_end < offset) {\n\t\t\t\toffset = fsp->xfer_contig_end;\n\t\t\t}\n\t\t\tfc_fcp_srr(fsp, r_ctl, offset);\n\t\t}\n\t}\nunlock_out:\n\tfc_fcp_unlock_pkt(fsp);\nout:\n\tfc_fcp_pkt_release(fsp);\t \n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_fcp_rec_error(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\n{\n\tint error = PTR_ERR(fp);\n\n\tif (fc_fcp_lock_pkt(fsp))\n\t\tgoto out;\n\n\tswitch (error) {\n\tcase -FC_EX_CLOSED:\n\t\tFC_FCP_DBG(fsp, \"REC %p fid %6.6x exchange closed\\n\",\n\t\t\t   fsp, fsp->rport->port_id);\n\t\tfc_fcp_retry_cmd(fsp, FC_ERROR);\n\t\tbreak;\n\n\tdefault:\n\t\tFC_FCP_DBG(fsp, \"REC %p fid %6.6x error unexpected error %d\\n\",\n\t\t\t   fsp, fsp->rport->port_id, error);\n\t\tfsp->status_code = FC_CMD_PLOGO;\n\t\tfallthrough;\n\n\tcase -FC_EX_TIMEOUT:\n\t\t \n\t\tFC_FCP_DBG(fsp, \"REC %p fid %6.6x exchange timeout retry %d/%d\\n\",\n\t\t\t   fsp, fsp->rport->port_id, fsp->recov_retry,\n\t\t\t   FC_MAX_RECOV_RETRY);\n\t\tif (fsp->recov_retry++ < FC_MAX_RECOV_RETRY)\n\t\t\tfc_fcp_rec(fsp);\n\t\telse\n\t\t\tfc_fcp_recovery(fsp, FC_ERROR);\n\t\tbreak;\n\t}\n\tfc_fcp_unlock_pkt(fsp);\nout:\n\tfc_fcp_pkt_release(fsp);\t \n}\n\n \nstatic void fc_fcp_recovery(struct fc_fcp_pkt *fsp, u8 code)\n{\n\tFC_FCP_DBG(fsp, \"start recovery code %x\\n\", code);\n\tfsp->status_code = code;\n\tfsp->cdb_status = 0;\n\tfsp->io_status = 0;\n\t \n\tfc_fcp_send_abort(fsp);\n}\n\n \nstatic void fc_fcp_srr(struct fc_fcp_pkt *fsp, enum fc_rctl r_ctl, u32 offset)\n{\n\tstruct fc_lport *lport = fsp->lp;\n\tstruct fc_rport *rport;\n\tstruct fc_rport_libfc_priv *rpriv;\n\tstruct fc_exch *ep = fc_seq_exch(fsp->seq_ptr);\n\tstruct fc_seq *seq;\n\tstruct fcp_srr *srr;\n\tstruct fc_frame *fp;\n\n\trport = fsp->rport;\n\trpriv = rport->dd_data;\n\n\tif (!(rpriv->flags & FC_RP_FLAGS_RETRY) ||\n\t    rpriv->rp_state != RPORT_ST_READY)\n\t\tgoto retry;\t\t\t \n\tfp = fc_fcp_frame_alloc(lport, sizeof(*srr));\n\tif (!fp)\n\t\tgoto retry;\n\n\tsrr = fc_frame_payload_get(fp, sizeof(*srr));\n\tmemset(srr, 0, sizeof(*srr));\n\tsrr->srr_op = ELS_SRR;\n\tsrr->srr_ox_id = htons(ep->oxid);\n\tsrr->srr_rx_id = htons(ep->rxid);\n\tsrr->srr_r_ctl = r_ctl;\n\tsrr->srr_rel_off = htonl(offset);\n\n\tfc_fill_fc_hdr(fp, FC_RCTL_ELS4_REQ, rport->port_id,\n\t\t       rpriv->local_port->port_id, FC_TYPE_FCP,\n\t\t       FC_FCTL_REQ, 0);\n\n\tseq = fc_exch_seq_send(lport, fp, fc_fcp_srr_resp,\n\t\t\t       fc_fcp_pkt_destroy,\n\t\t\t       fsp, get_fsp_rec_tov(fsp));\n\tif (!seq)\n\t\tgoto retry;\n\n\tfsp->recov_seq = seq;\n\tfsp->xfer_len = offset;\n\tfsp->xfer_contig_end = offset;\n\tfsp->state &= ~FC_SRB_RCV_STATUS;\n\tfc_fcp_pkt_hold(fsp);\t\t \n\treturn;\nretry:\n\tfc_fcp_retry_cmd(fsp, FC_TRANS_RESET);\n}\n\n \nstatic void fc_fcp_srr_resp(struct fc_seq *seq, struct fc_frame *fp, void *arg)\n{\n\tstruct fc_fcp_pkt *fsp = arg;\n\tstruct fc_frame_header *fh;\n\n\tif (IS_ERR(fp)) {\n\t\tfc_fcp_srr_error(fsp, fp);\n\t\treturn;\n\t}\n\n\tif (fc_fcp_lock_pkt(fsp))\n\t\tgoto out;\n\n\tfh = fc_frame_header_get(fp);\n\t \n\tif (fh->fh_type == FC_TYPE_BLS) {\n\t\tfc_fcp_unlock_pkt(fsp);\n\t\treturn;\n\t}\n\n\tswitch (fc_frame_payload_op(fp)) {\n\tcase ELS_LS_ACC:\n\t\tfsp->recov_retry = 0;\n\t\tfc_fcp_timer_set(fsp, get_fsp_rec_tov(fsp));\n\t\tbreak;\n\tcase ELS_LS_RJT:\n\tdefault:\n\t\tfc_fcp_recovery(fsp, FC_ERROR);\n\t\tbreak;\n\t}\n\tfc_fcp_unlock_pkt(fsp);\nout:\n\tfc_exch_done(seq);\n\tfc_frame_free(fp);\n}\n\n \nstatic void fc_fcp_srr_error(struct fc_fcp_pkt *fsp, struct fc_frame *fp)\n{\n\tif (fc_fcp_lock_pkt(fsp))\n\t\tgoto out;\n\tswitch (PTR_ERR(fp)) {\n\tcase -FC_EX_TIMEOUT:\n\t\tFC_FCP_DBG(fsp, \"SRR timeout, retries %d\\n\", fsp->recov_retry);\n\t\tif (fsp->recov_retry++ < FC_MAX_RECOV_RETRY)\n\t\t\tfc_fcp_rec(fsp);\n\t\telse\n\t\t\tfc_fcp_recovery(fsp, FC_TIMED_OUT);\n\t\tbreak;\n\tcase -FC_EX_CLOSED:\t\t\t \n\t\tFC_FCP_DBG(fsp, \"SRR error, exchange closed\\n\");\n\t\tfallthrough;\n\tdefault:\n\t\tfc_fcp_retry_cmd(fsp, FC_ERROR);\n\t\tbreak;\n\t}\n\tfc_fcp_unlock_pkt(fsp);\nout:\n\tfc_exch_done(fsp->recov_seq);\n}\n\n \nstatic inline int fc_fcp_lport_queue_ready(struct fc_lport *lport)\n{\n\t \n\treturn (lport->state == LPORT_ST_READY) &&\n\t\tlport->link_up && !lport->qfull;\n}\n\n \nint fc_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *sc_cmd)\n{\n\tstruct fc_lport *lport = shost_priv(shost);\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\n\tstruct fc_fcp_pkt *fsp;\n\tint rval;\n\tint rc = 0;\n\n\trval = fc_remote_port_chkready(rport);\n\tif (rval) {\n\t\tsc_cmd->result = rval;\n\t\tscsi_done(sc_cmd);\n\t\treturn 0;\n\t}\n\n\tif (!*(struct fc_remote_port **)rport->dd_data) {\n\t\t \n\t\tsc_cmd->result = DID_IMM_RETRY << 16;\n\t\tscsi_done(sc_cmd);\n\t\tgoto out;\n\t}\n\n\tif (!fc_fcp_lport_queue_ready(lport)) {\n\t\tif (lport->qfull) {\n\t\t\tif (fc_fcp_can_queue_ramp_down(lport))\n\t\t\t\tshost_printk(KERN_ERR, lport->host,\n\t\t\t\t\t     \"libfc: queue full, \"\n\t\t\t\t\t     \"reducing can_queue to %d.\\n\",\n\t\t\t\t\t     lport->host->can_queue);\n\t\t}\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\n\tfsp = fc_fcp_pkt_alloc(lport, GFP_ATOMIC);\n\tif (fsp == NULL) {\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tfsp->cmd = sc_cmd;\t \n\tfsp->rport = rport;\t \n\n\t \n\tfsp->data_len = scsi_bufflen(sc_cmd);\n\tfsp->xfer_len = 0;\n\n\t \n\tif (sc_cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tfsp->req_flags = FC_SRB_READ;\n\t\tthis_cpu_inc(lport->stats->InputRequests);\n\t\tthis_cpu_add(lport->stats->InputBytes, fsp->data_len);\n\t} else if (sc_cmd->sc_data_direction == DMA_TO_DEVICE) {\n\t\tfsp->req_flags = FC_SRB_WRITE;\n\t\tthis_cpu_inc(lport->stats->OutputRequests);\n\t\tthis_cpu_add(lport->stats->OutputBytes, fsp->data_len);\n\t} else {\n\t\tfsp->req_flags = 0;\n\t\tthis_cpu_inc(lport->stats->ControlRequests);\n\t}\n\n\t \n\trval = fc_fcp_pkt_send(lport, fsp);\n\tif (rval != 0) {\n\t\tfsp->state = FC_SRB_FREE;\n\t\tfc_fcp_pkt_release(fsp);\n\t\trc = SCSI_MLQUEUE_HOST_BUSY;\n\t}\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(fc_queuecommand);\n\n \nstatic void fc_io_compl(struct fc_fcp_pkt *fsp)\n{\n\tstruct fc_fcp_internal *si;\n\tstruct scsi_cmnd *sc_cmd;\n\tstruct fc_lport *lport;\n\tunsigned long flags;\n\n\t \n\tfc_fcp_ddp_done(fsp);\n\n\tfsp->state |= FC_SRB_COMPL;\n\tif (!(fsp->state & FC_SRB_FCP_PROCESSING_TMO)) {\n\t\tspin_unlock_bh(&fsp->scsi_pkt_lock);\n\t\tdel_timer_sync(&fsp->timer);\n\t\tspin_lock_bh(&fsp->scsi_pkt_lock);\n\t}\n\n\tlport = fsp->lp;\n\tsi = fc_get_scsi_internal(lport);\n\n\t \n\tif (si->last_can_queue_ramp_down_time)\n\t\tfc_fcp_can_queue_ramp_up(lport);\n\n\tsc_cmd = fsp->cmd;\n\tlibfc_priv(sc_cmd)->status = fsp->cdb_status;\n\tswitch (fsp->status_code) {\n\tcase FC_COMPLETE:\n\t\tif (fsp->cdb_status == 0) {\n\t\t\t \n\t\t\tsc_cmd->result = DID_OK << 16;\n\t\t\tif (fsp->scsi_resid)\n\t\t\t\tlibfc_priv(sc_cmd)->resid_len = fsp->scsi_resid;\n\t\t} else {\n\t\t\t \n\t\t\tsc_cmd->result = (DID_OK << 16) | fsp->cdb_status;\n\t\t}\n\t\tbreak;\n\tcase FC_ERROR:\n\t\tFC_FCP_DBG(fsp, \"Returning DID_ERROR to scsi-ml \"\n\t\t\t   \"due to FC_ERROR\\n\");\n\t\tsc_cmd->result = DID_ERROR << 16;\n\t\tbreak;\n\tcase FC_DATA_UNDRUN:\n\t\tif ((fsp->cdb_status == 0) && !(fsp->req_flags & FC_SRB_READ)) {\n\t\t\t \n\t\t\tif (fsp->state & FC_SRB_RCV_STATUS) {\n\t\t\t\tsc_cmd->result = DID_OK << 16;\n\t\t\t} else {\n\t\t\t\tFC_FCP_DBG(fsp, \"Returning DID_ERROR to scsi-ml\"\n\t\t\t\t\t   \" due to FC_DATA_UNDRUN (trans)\\n\");\n\t\t\t\tsc_cmd->result = DID_ERROR << 16;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tFC_FCP_DBG(fsp, \"Returning DID_ERROR to scsi-ml \"\n\t\t\t\t   \"due to FC_DATA_UNDRUN (scsi)\\n\");\n\t\t\tlibfc_priv(sc_cmd)->resid_len = fsp->scsi_resid;\n\t\t\tsc_cmd->result = (DID_ERROR << 16) | fsp->cdb_status;\n\t\t}\n\t\tbreak;\n\tcase FC_DATA_OVRRUN:\n\t\t \n\t\tFC_FCP_DBG(fsp, \"Returning DID_ERROR to scsi-ml \"\n\t\t\t   \"due to FC_DATA_OVRRUN\\n\");\n\t\tsc_cmd->result = (DID_ERROR << 16) | fsp->cdb_status;\n\t\tbreak;\n\tcase FC_CMD_ABORTED:\n\t\tif (host_byte(sc_cmd->result) == DID_TIME_OUT)\n\t\t\tFC_FCP_DBG(fsp, \"Returning DID_TIME_OUT to scsi-ml \"\n\t\t\t\t   \"due to FC_CMD_ABORTED\\n\");\n\t\telse {\n\t\t\tFC_FCP_DBG(fsp, \"Returning DID_ERROR to scsi-ml \"\n\t\t\t\t   \"due to FC_CMD_ABORTED\\n\");\n\t\t\tset_host_byte(sc_cmd, DID_ERROR);\n\t\t}\n\t\tsc_cmd->result |= fsp->io_status;\n\t\tbreak;\n\tcase FC_CMD_RESET:\n\t\tFC_FCP_DBG(fsp, \"Returning DID_RESET to scsi-ml \"\n\t\t\t   \"due to FC_CMD_RESET\\n\");\n\t\tsc_cmd->result = (DID_RESET << 16);\n\t\tbreak;\n\tcase FC_TRANS_RESET:\n\t\tFC_FCP_DBG(fsp, \"Returning DID_SOFT_ERROR to scsi-ml \"\n\t\t\t   \"due to FC_TRANS_RESET\\n\");\n\t\tsc_cmd->result = (DID_SOFT_ERROR << 16);\n\t\tbreak;\n\tcase FC_HRD_ERROR:\n\t\tFC_FCP_DBG(fsp, \"Returning DID_NO_CONNECT to scsi-ml \"\n\t\t\t   \"due to FC_HRD_ERROR\\n\");\n\t\tsc_cmd->result = (DID_NO_CONNECT << 16);\n\t\tbreak;\n\tcase FC_CRC_ERROR:\n\t\tFC_FCP_DBG(fsp, \"Returning DID_PARITY to scsi-ml \"\n\t\t\t   \"due to FC_CRC_ERROR\\n\");\n\t\tsc_cmd->result = (DID_PARITY << 16);\n\t\tbreak;\n\tcase FC_TIMED_OUT:\n\t\tFC_FCP_DBG(fsp, \"Returning DID_BUS_BUSY to scsi-ml \"\n\t\t\t   \"due to FC_TIMED_OUT\\n\");\n\t\tsc_cmd->result = (DID_BUS_BUSY << 16) | fsp->io_status;\n\t\tbreak;\n\tdefault:\n\t\tFC_FCP_DBG(fsp, \"Returning DID_ERROR to scsi-ml \"\n\t\t\t   \"due to unknown error\\n\");\n\t\tsc_cmd->result = (DID_ERROR << 16);\n\t\tbreak;\n\t}\n\n\tif (lport->state != LPORT_ST_READY && fsp->status_code != FC_COMPLETE)\n\t\tsc_cmd->result = (DID_TRANSPORT_DISRUPTED << 16);\n\n\tspin_lock_irqsave(&si->scsi_queue_lock, flags);\n\tlist_del(&fsp->list);\n\tlibfc_priv(sc_cmd)->fsp = NULL;\n\tspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\n\tscsi_done(sc_cmd);\n\n\t \n\tfc_fcp_pkt_release(fsp);\n}\n\n \nint fc_eh_abort(struct scsi_cmnd *sc_cmd)\n{\n\tstruct fc_fcp_pkt *fsp;\n\tstruct fc_lport *lport;\n\tstruct fc_fcp_internal *si;\n\tint rc = FAILED;\n\tunsigned long flags;\n\tint rval;\n\n\trval = fc_block_scsi_eh(sc_cmd);\n\tif (rval)\n\t\treturn rval;\n\n\tlport = shost_priv(sc_cmd->device->host);\n\tif (lport->state != LPORT_ST_READY)\n\t\treturn rc;\n\telse if (!lport->link_up)\n\t\treturn rc;\n\n\tsi = fc_get_scsi_internal(lport);\n\tspin_lock_irqsave(&si->scsi_queue_lock, flags);\n\tfsp = libfc_priv(sc_cmd)->fsp;\n\tif (!fsp) {\n\t\t \n\t\tspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\n\t\treturn SUCCESS;\n\t}\n\t \n\tfc_fcp_pkt_hold(fsp);\n\tspin_unlock_irqrestore(&si->scsi_queue_lock, flags);\n\n\tif (fc_fcp_lock_pkt(fsp)) {\n\t\t \n\t\trc = SUCCESS;\n\t\tgoto release_pkt;\n\t}\n\n\trc = fc_fcp_pkt_abort(fsp);\n\tfc_fcp_unlock_pkt(fsp);\n\nrelease_pkt:\n\tfc_fcp_pkt_release(fsp);\n\treturn rc;\n}\nEXPORT_SYMBOL(fc_eh_abort);\n\n \nint fc_eh_device_reset(struct scsi_cmnd *sc_cmd)\n{\n\tstruct fc_lport *lport;\n\tstruct fc_fcp_pkt *fsp;\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sc_cmd->device));\n\tint rc = FAILED;\n\tint rval;\n\n\trval = fc_block_scsi_eh(sc_cmd);\n\tif (rval)\n\t\treturn rval;\n\n\tlport = shost_priv(sc_cmd->device->host);\n\n\tif (lport->state != LPORT_ST_READY)\n\t\treturn rc;\n\n\tFC_SCSI_DBG(lport, \"Resetting rport (%6.6x)\\n\", rport->port_id);\n\n\tfsp = fc_fcp_pkt_alloc(lport, GFP_NOIO);\n\tif (fsp == NULL) {\n\t\tprintk(KERN_WARNING \"libfc: could not allocate scsi_pkt\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tfsp->rport = rport;\t \n\n\t \n\trc = fc_lun_reset(lport, fsp, scmd_id(sc_cmd), sc_cmd->device->lun);\n\tfsp->state = FC_SRB_FREE;\n\tfc_fcp_pkt_release(fsp);\n\nout:\n\treturn rc;\n}\nEXPORT_SYMBOL(fc_eh_device_reset);\n\n \nint fc_eh_host_reset(struct scsi_cmnd *sc_cmd)\n{\n\tstruct Scsi_Host *shost = sc_cmd->device->host;\n\tstruct fc_lport *lport = shost_priv(shost);\n\tunsigned long wait_tmo;\n\n\tFC_SCSI_DBG(lport, \"Resetting host\\n\");\n\n\tfc_lport_reset(lport);\n\twait_tmo = jiffies + FC_HOST_RESET_TIMEOUT;\n\twhile (!fc_fcp_lport_queue_ready(lport) && time_before(jiffies,\n\t\t\t\t\t\t\t       wait_tmo))\n\t\tmsleep(1000);\n\n\tif (fc_fcp_lport_queue_ready(lport)) {\n\t\tshost_printk(KERN_INFO, shost, \"libfc: Host reset succeeded \"\n\t\t\t     \"on port (%6.6x)\\n\", lport->port_id);\n\t\treturn SUCCESS;\n\t} else {\n\t\tshost_printk(KERN_INFO, shost, \"libfc: Host reset failed, \"\n\t\t\t     \"port (%6.6x) is not ready.\\n\",\n\t\t\t     lport->port_id);\n\t\treturn FAILED;\n\t}\n}\nEXPORT_SYMBOL(fc_eh_host_reset);\n\n \nint fc_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\n\n\tif (!rport || fc_remote_port_chkready(rport))\n\t\treturn -ENXIO;\n\n\tscsi_change_queue_depth(sdev, FC_FCP_DFLT_QUEUE_DEPTH);\n\treturn 0;\n}\nEXPORT_SYMBOL(fc_slave_alloc);\n\n \nvoid fc_fcp_destroy(struct fc_lport *lport)\n{\n\tstruct fc_fcp_internal *si = fc_get_scsi_internal(lport);\n\n\tif (!list_empty(&si->scsi_pkt_queue))\n\t\tprintk(KERN_ERR \"libfc: Leaked SCSI packets when destroying \"\n\t\t       \"port (%6.6x)\\n\", lport->port_id);\n\n\tmempool_destroy(si->scsi_pkt_pool);\n\tkfree(si);\n\tlport->scsi_priv = NULL;\n}\nEXPORT_SYMBOL(fc_fcp_destroy);\n\nint fc_setup_fcp(void)\n{\n\tint rc = 0;\n\n\tscsi_pkt_cachep = kmem_cache_create(\"libfc_fcp_pkt\",\n\t\t\t\t\t    sizeof(struct fc_fcp_pkt),\n\t\t\t\t\t    0, SLAB_HWCACHE_ALIGN, NULL);\n\tif (!scsi_pkt_cachep) {\n\t\tprintk(KERN_ERR \"libfc: Unable to allocate SRB cache, \"\n\t\t       \"module load failed!\");\n\t\trc = -ENOMEM;\n\t}\n\n\treturn rc;\n}\n\nvoid fc_destroy_fcp(void)\n{\n\tkmem_cache_destroy(scsi_pkt_cachep);\n}\n\n \nint fc_fcp_init(struct fc_lport *lport)\n{\n\tint rc;\n\tstruct fc_fcp_internal *si;\n\n\tif (!lport->tt.fcp_cmd_send)\n\t\tlport->tt.fcp_cmd_send = fc_fcp_cmd_send;\n\n\tif (!lport->tt.fcp_cleanup)\n\t\tlport->tt.fcp_cleanup = fc_fcp_cleanup;\n\n\tif (!lport->tt.fcp_abort_io)\n\t\tlport->tt.fcp_abort_io = fc_fcp_abort_io;\n\n\tsi = kzalloc(sizeof(struct fc_fcp_internal), GFP_KERNEL);\n\tif (!si)\n\t\treturn -ENOMEM;\n\tlport->scsi_priv = si;\n\tsi->max_can_queue = lport->host->can_queue;\n\tINIT_LIST_HEAD(&si->scsi_pkt_queue);\n\tspin_lock_init(&si->scsi_queue_lock);\n\n\tsi->scsi_pkt_pool = mempool_create_slab_pool(2, scsi_pkt_cachep);\n\tif (!si->scsi_pkt_pool) {\n\t\trc = -ENOMEM;\n\t\tgoto free_internal;\n\t}\n\treturn 0;\n\nfree_internal:\n\tkfree(si);\n\treturn rc;\n}\nEXPORT_SYMBOL(fc_fcp_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}