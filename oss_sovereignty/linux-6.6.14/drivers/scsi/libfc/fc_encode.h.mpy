{
  "module_name": "fc_encode.h",
  "hash_id": "8c5926d97dfe3e83e5fa38972b2cebc3ef3e587ad003ce774e2c020342b0bca5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libfc/fc_encode.h",
  "human_readable_source": " \n \n\n#ifndef _FC_ENCODE_H_\n#define _FC_ENCODE_H_\n#include <asm/unaligned.h>\n#include <linux/utsname.h>\n#include <scsi/fc/fc_ms.h>\n\n \n#define FC_FCTL_REQ\t(FC_FC_FIRST_SEQ | FC_FC_END_SEQ | FC_FC_SEQ_INIT)\n#define FC_FCTL_RESP\t(FC_FC_EX_CTX | FC_FC_LAST_SEQ | \\\n\t\t\tFC_FC_END_SEQ | FC_FC_SEQ_INIT)\n\nstruct fc_ns_rft {\n\tstruct fc_ns_fid fid;\t \n\tstruct fc_ns_fts fts;\t \n};\n\nstruct fc_ct_req {\n\tstruct fc_ct_hdr hdr;\n\tunion {\n\t\tstruct fc_ns_gid_ft gid;\n\t\tstruct fc_ns_rn_id  rn;\n\t\tstruct fc_ns_rft rft;\n\t\tstruct fc_ns_rff_id rff;\n\t\tstruct fc_ns_fid fid;\n\t\tstruct fc_ns_rsnn snn;\n\t\tstruct fc_ns_rspn spn;\n\t\tstruct fc_fdmi_rhba rhba;\n\t\tstruct fc_fdmi_rpa  rpa;\n\t\tstruct fc_fdmi_dprt dprt;\n\t\tstruct fc_fdmi_dhba dhba;\n\t} payload;\n};\n\n \nstatic inline void fc_adisc_fill(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_els_adisc *adisc;\n\n\tadisc = fc_frame_payload_get(fp, sizeof(*adisc));\n\tmemset(adisc, 0, sizeof(*adisc));\n\tadisc->adisc_cmd = ELS_ADISC;\n\tput_unaligned_be64(lport->wwpn, &adisc->adisc_wwpn);\n\tput_unaligned_be64(lport->wwnn, &adisc->adisc_wwnn);\n\thton24(adisc->adisc_port_id, lport->port_id);\n}\n\n \nstatic inline struct fc_ct_req *fc_ct_hdr_fill(const struct fc_frame *fp,\n\t\t\t\t\t       unsigned int op, size_t req_size,\n\t\t\t\t\t       enum fc_ct_fs_type fs_type,\n\t\t\t\t\t       u8 subtype)\n{\n\tstruct fc_ct_req *ct;\n\tsize_t ct_plen;\n\n\tct_plen  = sizeof(struct fc_ct_hdr) + req_size;\n\tct = fc_frame_payload_get(fp, ct_plen);\n\tmemset(ct, 0, ct_plen);\n\tct->hdr.ct_rev = FC_CT_REV;\n\tct->hdr.ct_fs_type = fs_type;\n\tct->hdr.ct_fs_subtype = subtype;\n\tct->hdr.ct_cmd = htons((u16) op);\n\treturn ct;\n}\n\n \nstatic inline int fc_ct_ns_fill(struct fc_lport *lport,\n\t\t      u32 fc_id, struct fc_frame *fp,\n\t\t      unsigned int op, enum fc_rctl *r_ctl,\n\t\t      enum fc_fh_type *fh_type)\n{\n\tstruct fc_ct_req *ct;\n\tsize_t len;\n\n\tswitch (op) {\n\tcase FC_NS_GPN_FT:\n\t\tct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_gid_ft),\n\t\t\t\t    FC_FST_DIR, FC_NS_SUBTYPE);\n\t\tct->payload.gid.fn_fc4_type = FC_TYPE_FCP;\n\t\tbreak;\n\n\tcase FC_NS_GPN_ID:\n\t\tct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_fid),\n\t\t\t\t    FC_FST_DIR, FC_NS_SUBTYPE);\n\t\tct->payload.gid.fn_fc4_type = FC_TYPE_FCP;\n\t\thton24(ct->payload.fid.fp_fid, fc_id);\n\t\tbreak;\n\n\tcase FC_NS_RFT_ID:\n\t\tct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_rft),\n\t\t\t\t    FC_FST_DIR, FC_NS_SUBTYPE);\n\t\thton24(ct->payload.rft.fid.fp_fid, lport->port_id);\n\t\tct->payload.rft.fts = lport->fcts;\n\t\tbreak;\n\n\tcase FC_NS_RFF_ID:\n\t\tct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_rff_id),\n\t\t\t\t    FC_FST_DIR, FC_NS_SUBTYPE);\n\t\thton24(ct->payload.rff.fr_fid.fp_fid, lport->port_id);\n\t\tct->payload.rff.fr_type = FC_TYPE_FCP;\n\t\tif (lport->service_params & FCP_SPPF_INIT_FCN)\n\t\t\tct->payload.rff.fr_feat = FCP_FEAT_INIT;\n\t\tif (lport->service_params & FCP_SPPF_TARG_FCN)\n\t\t\tct->payload.rff.fr_feat |= FCP_FEAT_TARG;\n\t\tbreak;\n\n\tcase FC_NS_RNN_ID:\n\t\tct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_rn_id),\n\t\t\t\t    FC_FST_DIR, FC_NS_SUBTYPE);\n\t\thton24(ct->payload.rn.fr_fid.fp_fid, lport->port_id);\n\t\tput_unaligned_be64(lport->wwnn, &ct->payload.rn.fr_wwn);\n\t\tbreak;\n\n\tcase FC_NS_RSPN_ID:\n\t\tlen = strnlen(fc_host_symbolic_name(lport->host), 255);\n\t\tct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_rspn) + len,\n\t\t\t\t    FC_FST_DIR, FC_NS_SUBTYPE);\n\t\thton24(ct->payload.spn.fr_fid.fp_fid, lport->port_id);\n\t\tstrncpy(ct->payload.spn.fr_name,\n\t\t\tfc_host_symbolic_name(lport->host), len);\n\t\tct->payload.spn.fr_name_len = len;\n\t\tbreak;\n\n\tcase FC_NS_RSNN_NN:\n\t\tlen = strnlen(fc_host_symbolic_name(lport->host), 255);\n\t\tct = fc_ct_hdr_fill(fp, op, sizeof(struct fc_ns_rsnn) + len,\n\t\t\t\t    FC_FST_DIR, FC_NS_SUBTYPE);\n\t\tput_unaligned_be64(lport->wwnn, &ct->payload.snn.fr_wwn);\n\t\tstrncpy(ct->payload.snn.fr_name,\n\t\t\tfc_host_symbolic_name(lport->host), len);\n\t\tct->payload.snn.fr_name_len = len;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t*r_ctl = FC_RCTL_DD_UNSOL_CTL;\n\t*fh_type = FC_TYPE_CT;\n\treturn 0;\n}\n\nstatic inline void fc_ct_ms_fill_attr(struct fc_fdmi_attr_entry *entry,\n\t\t\t\t    const char *in, size_t len)\n{\n\tint copied;\n\n\tcopied = strscpy(entry->value, in, len);\n\tif (copied > 0 && copied + 1 < len)\n\t\tmemset(entry->value + copied + 1, 0, len - copied - 1);\n}\n\n \nstatic inline int fc_ct_ms_fill(struct fc_lport *lport,\n\t\t      u32 fc_id, struct fc_frame *fp,\n\t\t      unsigned int op, enum fc_rctl *r_ctl,\n\t\t      enum fc_fh_type *fh_type)\n{\n\tstruct fc_ct_req *ct;\n\tsize_t len;\n\tstruct fc_fdmi_attr_entry *entry;\n\tstruct fs_fdmi_attrs *hba_attrs;\n\tint numattrs = 0;\n\tstruct fc_host_attrs *fc_host = shost_to_fc_host(lport->host);\n\n\tswitch (op) {\n\tcase FC_FDMI_RHBA:\n\t\tnumattrs = 11;\n\t\tlen = sizeof(struct fc_fdmi_rhba);\n\t\tlen -= sizeof(struct fc_fdmi_attr_entry);\n\t\tlen += (numattrs * FC_FDMI_ATTR_ENTRY_HEADER_LEN);\n\t\tlen += FC_FDMI_HBA_ATTR_NODENAME_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MANUFACTURER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_SERIALNUMBER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MODEL_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MODELDESCR_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_HARDWAREVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_DRIVERVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_OPTIONROMVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_FIRMWAREVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_OSNAMEVERSION_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MAXCTPAYLOAD_LEN;\n\n\t\tif (fc_host->fdmi_version == FDMI_V2) {\n\t\t\tnumattrs += 7;\n\t\t\tlen += FC_FDMI_HBA_ATTR_NODESYMBLNAME_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_VENDORSPECIFICINFO_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_NUMBEROFPORTS_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_FABRICNAME_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_BIOSVERSION_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_BIOSSTATE_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_VENDORIDENTIFIER_LEN;\n\t\t}\n\n\t\tct = fc_ct_hdr_fill(fp, op, len, FC_FST_MGMT,\n\t\t\t\tFC_FDMI_SUBTYPE);\n\n\t\t \n\t\tput_unaligned_be64(lport->wwpn, &ct->payload.rhba.hbaid.id);\n\t\t \n\t\tput_unaligned_be32(1, &ct->payload.rhba.port.numport);\n\t\t \n\t\tput_unaligned_be64(lport->wwpn,\n\t\t\t\t   &ct->payload.rhba.port.port[0].portname);\n\n\t\t \n\t\tput_unaligned_be32(numattrs,\n\t\t\t\t   &ct->payload.rhba.hba_attrs.numattrs);\n\t\thba_attrs = &ct->payload.rhba.hba_attrs;\n\t\tentry = (struct fc_fdmi_attr_entry *)hba_attrs->attr;\n\t\t \n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_NODENAME_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_NODENAME,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tput_unaligned_be64(lport->wwnn,\n\t\t\t\t   (__be64 *)&entry->value);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_NODENAME_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MANUFACTURER_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_MANUFACTURER,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\tfc_host_manufacturer(lport->host),\n\t\t\tFC_FDMI_HBA_ATTR_MANUFACTURER_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_MANUFACTURER_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_SERIALNUMBER_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_SERIALNUMBER,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\tfc_host_serial_number(lport->host),\n\t\t\tFC_FDMI_HBA_ATTR_SERIALNUMBER_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_SERIALNUMBER_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MODEL_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_MODEL,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\tfc_host_model(lport->host),\n\t\t\tFC_FDMI_HBA_ATTR_MODEL_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_MODEL_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MODELDESCR_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_MODELDESCRIPTION,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\tfc_host_model_description(lport->host),\n\t\t\tFC_FDMI_HBA_ATTR_MODELDESCR_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_MODELDESCR_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_HARDWAREVERSION_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_HARDWAREVERSION,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\tfc_host_hardware_version(lport->host),\n\t\t\tFC_FDMI_HBA_ATTR_HARDWAREVERSION_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_HARDWAREVERSION_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_DRIVERVERSION_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_DRIVERVERSION,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\tfc_host_driver_version(lport->host),\n\t\t\tFC_FDMI_HBA_ATTR_DRIVERVERSION_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_DRIVERVERSION_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_OPTIONROMVERSION_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_OPTIONROMVERSION,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\t\"unknown\",\n\t\t\tFC_FDMI_HBA_ATTR_OPTIONROMVERSION_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_OPTIONROMVERSION_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_FIRMWAREVERSION_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_FIRMWAREVERSION,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\tfc_host_firmware_version(lport->host),\n\t\t\tFC_FDMI_HBA_ATTR_FIRMWAREVERSION_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_FIRMWAREVERSION_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_OSNAMEVERSION_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_OSNAMEVERSION,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tsnprintf((char *)&entry->value,\n\t\t\tFC_FDMI_HBA_ATTR_OSNAMEVERSION_LEN,\n\t\t\t\"%s v%s\",\n\t\t\tinit_utsname()->sysname,\n\t\t\tinit_utsname()->release);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_OSNAMEVERSION_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_HBA_ATTR_MAXCTPAYLOAD_LEN;\n\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_MAXCTPAYLOAD,\n\t\t\t\t&entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tput_unaligned_be32(fc_host_max_ct_payload(lport->host),\n\t\t\t\t&entry->value);\n\n\t\tif (fc_host->fdmi_version == FDMI_V2) {\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_MAXCTPAYLOAD_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_NODESYMBLNAME_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_NODESYMBLNAME,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tfc_ct_ms_fill_attr(entry,\n\t\t\t\t\tfc_host_symbolic_name(lport->host),\n\t\t\t\t\tFC_FDMI_HBA_ATTR_NODESYMBLNAME_LEN);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_NODESYMBLNAME_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_VENDORSPECIFICINFO_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_VENDORSPECIFICINFO,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be32(0,\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_VENDORSPECIFICINFO_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_NUMBEROFPORTS_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_NUMBEROFPORTS,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be32(fc_host_num_ports(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_NUMBEROFPORTS_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_FABRICNAME_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_FABRICNAME,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be64(fc_host_fabric_name(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_FABRICNAME_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_BIOSVERSION_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_BIOSVERSION,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tfc_ct_ms_fill_attr(entry,\n\t\t\t\t\tfc_host_bootbios_version(lport->host),\n\t\t\t\t\tFC_FDMI_HBA_ATTR_BIOSVERSION_LEN);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_BIOSVERSION_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_BIOSSTATE_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_BIOSSTATE,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be32(fc_host_bootbios_state(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_HBA_ATTR_BIOSSTATE_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_HBA_ATTR_VENDORIDENTIFIER_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_HBA_ATTR_VENDORIDENTIFIER,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tfc_ct_ms_fill_attr(entry,\n\t\t\t\t\tfc_host_vendor_identifier(lport->host),\n\t\t\t\t\tFC_FDMI_HBA_ATTR_VENDORIDENTIFIER_LEN);\n\t\t}\n\n\t\tbreak;\n\tcase FC_FDMI_RPA:\n\t\tnumattrs = 6;\n\t\tlen = sizeof(struct fc_fdmi_rpa);\n\t\tlen -= sizeof(struct fc_fdmi_attr_entry);\n\t\tlen += (numattrs * FC_FDMI_ATTR_ENTRY_HEADER_LEN);\n\t\tlen += FC_FDMI_PORT_ATTR_FC4TYPES_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_SUPPORTEDSPEED_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_CURRENTPORTSPEED_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_MAXFRAMESIZE_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_OSDEVICENAME_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_HOSTNAME_LEN;\n\n\n\t\tif (fc_host->fdmi_version == FDMI_V2) {\n\t\t\tnumattrs += 10;\n\n\t\t\tlen += FC_FDMI_PORT_ATTR_NODENAME_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTNAME_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_SYMBOLICNAME_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTTYPE_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_SUPPORTEDCLASSSRVC_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_FABRICNAME_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_CURRENTFC4TYPE_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTSTATE_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_DISCOVEREDPORTS_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTID_LEN;\n\n\t\t}\n\n\t\tct = fc_ct_hdr_fill(fp, op, len, FC_FST_MGMT,\n\t\t\t\t    FC_FDMI_SUBTYPE);\n\n\t\t \n\t\tput_unaligned_be64(lport->wwpn,\n\t\t\t\t   &ct->payload.rpa.port.portname);\n\n\t\t \n\t\tput_unaligned_be32(numattrs,\n\t\t\t\t   &ct->payload.rpa.hba_attrs.numattrs);\n\n\t\thba_attrs = &ct->payload.rpa.hba_attrs;\n\t\tentry = (struct fc_fdmi_attr_entry *)hba_attrs->attr;\n\n\t\t \n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_FC4TYPES_LEN;\n\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_FC4TYPES,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tmemcpy(&entry->value, fc_host_supported_fc4s(lport->host),\n\t\t       FC_FDMI_PORT_ATTR_FC4TYPES_LEN);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_FC4TYPES_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_SUPPORTEDSPEED_LEN;\n\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_SUPPORTEDSPEED,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\n\t\tput_unaligned_be32(fc_host_supported_speeds(lport->host),\n\t\t\t\t   &entry->value);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_SUPPORTEDSPEED_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_CURRENTPORTSPEED_LEN;\n\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_CURRENTPORTSPEED,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tput_unaligned_be32(lport->link_speed,\n\t\t\t\t   &entry->value);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_CURRENTPORTSPEED_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_MAXFRAMESIZE_LEN;\n\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_MAXFRAMESIZE,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tput_unaligned_be32(fc_host_maxframe_size(lport->host),\n\t\t\t\t   &entry->value);\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_MAXFRAMESIZE_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_OSDEVICENAME_LEN;\n\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_OSDEVICENAME,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\t \n\t\tfc_ct_ms_fill_attr(entry,\n\t\t\tdev_name(&lport->host->shost_gendev),\n\t\t\tstrnlen(dev_name(&lport->host->shost_gendev),\n\t\t\t\tFC_FDMI_PORT_ATTR_HOSTNAME_LEN));\n\n\t\t \n\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_OSDEVICENAME_LEN);\n\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\tlen += FC_FDMI_PORT_ATTR_HOSTNAME_LEN;\n\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_HOSTNAME,\n\t\t\t\t   &entry->type);\n\t\tput_unaligned_be16(len, &entry->len);\n\t\tif (strlen(fc_host_system_hostname(lport->host)))\n\t\t\tfc_ct_ms_fill_attr(entry,\n\t\t\t\tfc_host_system_hostname(lport->host),\n\t\t\t\tstrnlen(fc_host_system_hostname(lport->host),\n\t\t\t\t\tFC_FDMI_PORT_ATTR_HOSTNAME_LEN));\n\t\telse\n\t\t\tfc_ct_ms_fill_attr(entry,\n\t\t\t\tinit_utsname()->nodename,\n\t\t\t\tFC_FDMI_PORT_ATTR_HOSTNAME_LEN);\n\n\n\t\tif (fc_host->fdmi_version == FDMI_V2) {\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_HOSTNAME_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_NODENAME_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_NODENAME,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be64(fc_host_node_name(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_NODENAME_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTNAME_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_PORTNAME,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be64(lport->wwpn,\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_PORTNAME_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_SYMBOLICNAME_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_SYMBOLICNAME,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tfc_ct_ms_fill_attr(entry,\n\t\t\t\t\tfc_host_symbolic_name(lport->host),\n\t\t\t\t\tFC_FDMI_PORT_ATTR_SYMBOLICNAME_LEN);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_SYMBOLICNAME_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTTYPE_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_PORTTYPE,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be32(fc_host_port_type(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_PORTTYPE_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_SUPPORTEDCLASSSRVC_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_SUPPORTEDCLASSSRVC,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be32(fc_host_supported_classes(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_SUPPORTEDCLASSSRVC_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_FABRICNAME_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_FABRICNAME,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be64(fc_host_fabric_name(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_FABRICNAME_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_CURRENTFC4TYPE_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_CURRENTFC4TYPE,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tmemcpy(&entry->value, fc_host_active_fc4s(lport->host),\n\t\t\t\t\tFC_FDMI_PORT_ATTR_CURRENTFC4TYPE_LEN);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_CURRENTFC4TYPE_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTSTATE_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_PORTSTATE,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be32(fc_host_port_state(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_PORTSTATE_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_DISCOVEREDPORTS_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_DISCOVEREDPORTS,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be32(fc_host_num_discovered_ports(lport->host),\n\t\t\t\t\t&entry->value);\n\n\t\t\t \n\t\t\tentry = (struct fc_fdmi_attr_entry *)((char *)entry->value +\n\t\t\t\t\tFC_FDMI_PORT_ATTR_DISCOVEREDPORTS_LEN);\n\t\t\tlen = FC_FDMI_ATTR_ENTRY_HEADER_LEN;\n\t\t\tlen += FC_FDMI_PORT_ATTR_PORTID_LEN;\n\t\t\tput_unaligned_be16(FC_FDMI_PORT_ATTR_PORTID,\n\t\t\t\t\t&entry->type);\n\t\t\tput_unaligned_be16(len, &entry->len);\n\t\t\tput_unaligned_be32(fc_host_port_id(lport->host),\n\t\t\t\t\t&entry->value);\n\t\t}\n\n\t\tbreak;\n\tcase FC_FDMI_DPRT:\n\t\tlen = sizeof(struct fc_fdmi_dprt);\n\t\tct = fc_ct_hdr_fill(fp, op, len, FC_FST_MGMT,\n\t\t\t\t    FC_FDMI_SUBTYPE);\n\t\t \n\t\tput_unaligned_be64(lport->wwpn,\n\t\t\t\t   &ct->payload.dprt.port.portname);\n\t\tbreak;\n\tcase FC_FDMI_DHBA:\n\t\tlen = sizeof(struct fc_fdmi_dhba);\n\t\tct = fc_ct_hdr_fill(fp, op, len, FC_FST_MGMT,\n\t\t\t\t    FC_FDMI_SUBTYPE);\n\t\t \n\t\tput_unaligned_be64(lport->wwpn, &ct->payload.dhba.hbaid.id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t*r_ctl = FC_RCTL_DD_UNSOL_CTL;\n\t*fh_type = FC_TYPE_CT;\n\treturn 0;\n}\n\n \nstatic inline int fc_ct_fill(struct fc_lport *lport,\n\t\t      u32 fc_id, struct fc_frame *fp,\n\t\t      unsigned int op, enum fc_rctl *r_ctl,\n\t\t      enum fc_fh_type *fh_type, u32 *did)\n{\n\tint rc = -EINVAL;\n\n\tswitch (fc_id) {\n\tcase FC_FID_MGMT_SERV:\n\t\trc = fc_ct_ms_fill(lport, fc_id, fp, op, r_ctl, fh_type);\n\t\t*did = FC_FID_MGMT_SERV;\n\t\tbreak;\n\tcase FC_FID_DIR_SERV:\n\tdefault:\n\t\trc = fc_ct_ns_fill(lport, fc_id, fp, op, r_ctl, fh_type);\n\t\t*did = FC_FID_DIR_SERV;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n \nstatic inline void fc_plogi_fill(struct fc_lport *lport, struct fc_frame *fp,\n\t\t\t\t unsigned int op)\n{\n\tstruct fc_els_flogi *plogi;\n\tstruct fc_els_csp *csp;\n\tstruct fc_els_cssp *cp;\n\n\tplogi = fc_frame_payload_get(fp, sizeof(*plogi));\n\tmemset(plogi, 0, sizeof(*plogi));\n\tplogi->fl_cmd = (u8) op;\n\tput_unaligned_be64(lport->wwpn, &plogi->fl_wwpn);\n\tput_unaligned_be64(lport->wwnn, &plogi->fl_wwnn);\n\n\tcsp = &plogi->fl_csp;\n\tcsp->sp_hi_ver = 0x20;\n\tcsp->sp_lo_ver = 0x20;\n\tcsp->sp_bb_cred = htons(10);\t \n\tcsp->sp_bb_data = htons((u16) lport->mfs);\n\tcp = &plogi->fl_cssp[3 - 1];\t \n\tcp->cp_class = htons(FC_CPC_VALID | FC_CPC_SEQ);\n\tcsp->sp_features = htons(FC_SP_FT_CIRO);\n\tcsp->sp_tot_seq = htons(255);\t \n\tcsp->sp_rel_off = htons(0x1f);\n\tcsp->sp_e_d_tov = htonl(lport->e_d_tov);\n\n\tcp->cp_rdfs = htons((u16) lport->mfs);\n\tcp->cp_con_seq = htons(255);\n\tcp->cp_open_seq = 1;\n}\n\n \nstatic inline void fc_flogi_fill(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_els_csp *sp;\n\tstruct fc_els_cssp *cp;\n\tstruct fc_els_flogi *flogi;\n\n\tflogi = fc_frame_payload_get(fp, sizeof(*flogi));\n\tmemset(flogi, 0, sizeof(*flogi));\n\tflogi->fl_cmd = (u8) ELS_FLOGI;\n\tput_unaligned_be64(lport->wwpn, &flogi->fl_wwpn);\n\tput_unaligned_be64(lport->wwnn, &flogi->fl_wwnn);\n\tsp = &flogi->fl_csp;\n\tsp->sp_hi_ver = 0x20;\n\tsp->sp_lo_ver = 0x20;\n\tsp->sp_bb_cred = htons(10);\t \n\tsp->sp_bb_data = htons((u16) lport->mfs);\n\tcp = &flogi->fl_cssp[3 - 1];\t \n\tcp->cp_class = htons(FC_CPC_VALID | FC_CPC_SEQ);\n\tif (lport->does_npiv)\n\t\tsp->sp_features = htons(FC_SP_FT_NPIV);\n}\n\n \nstatic inline void fc_fdisc_fill(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_els_csp *sp;\n\tstruct fc_els_cssp *cp;\n\tstruct fc_els_flogi *fdisc;\n\n\tfdisc = fc_frame_payload_get(fp, sizeof(*fdisc));\n\tmemset(fdisc, 0, sizeof(*fdisc));\n\tfdisc->fl_cmd = (u8) ELS_FDISC;\n\tput_unaligned_be64(lport->wwpn, &fdisc->fl_wwpn);\n\tput_unaligned_be64(lport->wwnn, &fdisc->fl_wwnn);\n\tsp = &fdisc->fl_csp;\n\tsp->sp_hi_ver = 0x20;\n\tsp->sp_lo_ver = 0x20;\n\tsp->sp_bb_cred = htons(10);\t \n\tsp->sp_bb_data = htons((u16) lport->mfs);\n\tcp = &fdisc->fl_cssp[3 - 1];\t \n\tcp->cp_class = htons(FC_CPC_VALID | FC_CPC_SEQ);\n}\n\n \nstatic inline void fc_logo_fill(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_els_logo *logo;\n\n\tlogo = fc_frame_payload_get(fp, sizeof(*logo));\n\tmemset(logo, 0, sizeof(*logo));\n\tlogo->fl_cmd = ELS_LOGO;\n\thton24(logo->fl_n_port_id, lport->port_id);\n\tlogo->fl_n_port_wwn = htonll(lport->wwpn);\n}\n\n \nstatic inline void fc_rtv_fill(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_els_rtv *rtv;\n\n\trtv = fc_frame_payload_get(fp, sizeof(*rtv));\n\tmemset(rtv, 0, sizeof(*rtv));\n\trtv->rtv_cmd = ELS_RTV;\n}\n\n \nstatic inline void fc_rec_fill(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_els_rec *rec;\n\tstruct fc_exch *ep = fc_seq_exch(fr_seq(fp));\n\n\trec = fc_frame_payload_get(fp, sizeof(*rec));\n\tmemset(rec, 0, sizeof(*rec));\n\trec->rec_cmd = ELS_REC;\n\thton24(rec->rec_s_id, lport->port_id);\n\trec->rec_ox_id = htons(ep->oxid);\n\trec->rec_rx_id = htons(ep->rxid);\n}\n\n \nstatic inline void fc_prli_fill(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct {\n\t\tstruct fc_els_prli prli;\n\t\tstruct fc_els_spp spp;\n\t} *pp;\n\n\tpp = fc_frame_payload_get(fp, sizeof(*pp));\n\tmemset(pp, 0, sizeof(*pp));\n\tpp->prli.prli_cmd = ELS_PRLI;\n\tpp->prli.prli_spp_len = sizeof(struct fc_els_spp);\n\tpp->prli.prli_len = htons(sizeof(*pp));\n\tpp->spp.spp_type = FC_TYPE_FCP;\n\tpp->spp.spp_flags = FC_SPP_EST_IMG_PAIR;\n\tpp->spp.spp_params = htonl(lport->service_params);\n}\n\n \nstatic inline void fc_scr_fill(struct fc_lport *lport, struct fc_frame *fp)\n{\n\tstruct fc_els_scr *scr;\n\n\tscr = fc_frame_payload_get(fp, sizeof(*scr));\n\tmemset(scr, 0, sizeof(*scr));\n\tscr->scr_cmd = ELS_SCR;\n\tscr->scr_reg_func = ELS_SCRF_FULL;\n}\n\n \nstatic inline int fc_els_fill(struct fc_lport *lport,\n\t\t       u32 did,\n\t\t       struct fc_frame *fp, unsigned int op,\n\t\t       enum fc_rctl *r_ctl, enum fc_fh_type *fh_type)\n{\n\tswitch (op) {\n\tcase ELS_ADISC:\n\t\tfc_adisc_fill(lport, fp);\n\t\tbreak;\n\n\tcase ELS_PLOGI:\n\t\tfc_plogi_fill(lport, fp, ELS_PLOGI);\n\t\tbreak;\n\n\tcase ELS_FLOGI:\n\t\tfc_flogi_fill(lport, fp);\n\t\tbreak;\n\n\tcase ELS_FDISC:\n\t\tfc_fdisc_fill(lport, fp);\n\t\tbreak;\n\n\tcase ELS_LOGO:\n\t\tfc_logo_fill(lport, fp);\n\t\tbreak;\n\n\tcase ELS_RTV:\n\t\tfc_rtv_fill(lport, fp);\n\t\tbreak;\n\n\tcase ELS_REC:\n\t\tfc_rec_fill(lport, fp);\n\t\tbreak;\n\n\tcase ELS_PRLI:\n\t\tfc_prli_fill(lport, fp);\n\t\tbreak;\n\n\tcase ELS_SCR:\n\t\tfc_scr_fill(lport, fp);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*r_ctl = FC_RCTL_ELS_REQ;\n\t*fh_type = FC_TYPE_ELS;\n\treturn 0;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}