{
  "module_name": "fc_libfc.c",
  "hash_id": "94adbf161b6e8dbde43b4a2c3229027c3f87a4ed2d912cbf590ffd8dd48fd6a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/libfc/fc_libfc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/scatterlist.h>\n#include <linux/crc32.h>\n#include <linux/module.h>\n\n#include <scsi/libfc.h>\n\n#include \"fc_encode.h\"\n#include \"fc_libfc.h\"\n\nMODULE_AUTHOR(\"Open-FCoE.org\");\nMODULE_DESCRIPTION(\"libfc\");\nMODULE_LICENSE(\"GPL v2\");\n\nunsigned int fc_debug_logging;\nmodule_param_named(debug_logging, fc_debug_logging, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(debug_logging, \"a bit mask of logging levels\");\n\nDEFINE_MUTEX(fc_prov_mutex);\nstatic LIST_HEAD(fc_local_ports);\nstruct blocking_notifier_head fc_lport_notifier_head =\n\t\tBLOCKING_NOTIFIER_INIT(fc_lport_notifier_head);\nEXPORT_SYMBOL(fc_lport_notifier_head);\n\n \nstruct fc4_prov *fc_active_prov[FC_FC4_PROV_SIZE] = {\n\t[0] = &fc_rport_t0_prov,\n\t[FC_TYPE_FCP] = &fc_rport_fcp_init,\n};\n\n \nstruct fc4_prov *fc_passive_prov[FC_FC4_PROV_SIZE] = {\n\t[FC_TYPE_ELS] = &fc_lport_els_prov,\n};\n\n \nstatic int __init libfc_init(void)\n{\n\tint rc = 0;\n\n\trc = fc_setup_fcp();\n\tif (rc)\n\t\treturn rc;\n\n\trc = fc_setup_exch_mgr();\n\tif (rc)\n\t\tgoto destroy_pkt_cache;\n\n\trc = fc_setup_rport();\n\tif (rc)\n\t\tgoto destroy_em;\n\n\treturn rc;\ndestroy_em:\n\tfc_destroy_exch_mgr();\ndestroy_pkt_cache:\n\tfc_destroy_fcp();\n\treturn rc;\n}\nmodule_init(libfc_init);\n\n \nstatic void __exit libfc_exit(void)\n{\n\tfc_destroy_fcp();\n\tfc_destroy_exch_mgr();\n\tfc_destroy_rport();\n}\nmodule_exit(libfc_exit);\n\n \nu32 fc_copy_buffer_to_sglist(void *buf, size_t len,\n\t\t\t     struct scatterlist *sg,\n\t\t\t     u32 *nents, size_t *offset,\n\t\t\t     u32 *crc)\n{\n\tsize_t remaining = len;\n\tu32 copy_len = 0;\n\n\twhile (remaining > 0 && sg) {\n\t\tsize_t off, sg_bytes;\n\t\tvoid *page_addr;\n\n\t\tif (*offset >= sg->length) {\n\t\t\t \n\t\t\tif (!(*nents))\n\t\t\t\tbreak;\n\t\t\t--(*nents);\n\t\t\t*offset -= sg->length;\n\t\t\tsg = sg_next(sg);\n\t\t\tcontinue;\n\t\t}\n\t\tsg_bytes = min(remaining, sg->length - *offset);\n\n\t\t \n\t\toff = *offset + sg->offset;\n\t\tsg_bytes = min(sg_bytes,\n\t\t\t       (size_t)(PAGE_SIZE - (off & ~PAGE_MASK)));\n\t\tpage_addr = kmap_atomic(sg_page(sg) + (off >> PAGE_SHIFT));\n\t\tif (crc)\n\t\t\t*crc = crc32(*crc, buf, sg_bytes);\n\t\tmemcpy((char *)page_addr + (off & ~PAGE_MASK), buf, sg_bytes);\n\t\tkunmap_atomic(page_addr);\n\t\tbuf += sg_bytes;\n\t\t*offset += sg_bytes;\n\t\tremaining -= sg_bytes;\n\t\tcopy_len += sg_bytes;\n\t}\n\treturn copy_len;\n}\n\n \nvoid fc_fill_hdr(struct fc_frame *fp, const struct fc_frame *in_fp,\n\t\t enum fc_rctl r_ctl, u32 f_ctl, u16 seq_cnt, u32 parm_offset)\n{\n\tstruct fc_frame_header *fh;\n\tstruct fc_frame_header *in_fh;\n\tstruct fc_seq *sp;\n\tu32 fill;\n\n\tfh = __fc_frame_header_get(fp);\n\tin_fh = __fc_frame_header_get(in_fp);\n\n\tif (f_ctl & FC_FC_END_SEQ) {\n\t\tfill = -fr_len(fp) & 3;\n\t\tif (fill) {\n\t\t\t \n\t\t\tskb_put_zero(fp_skb(fp), fill);\n\t\t\tf_ctl |= fill;\n\t\t}\n\t\tfr_eof(fp) = FC_EOF_T;\n\t} else {\n\t\tWARN_ON(fr_len(fp) % 4 != 0);\t \n\t\tfr_eof(fp) = FC_EOF_N;\n\t}\n\n\tfh->fh_r_ctl = r_ctl;\n\tmemcpy(fh->fh_d_id, in_fh->fh_s_id, sizeof(fh->fh_d_id));\n\tmemcpy(fh->fh_s_id, in_fh->fh_d_id, sizeof(fh->fh_s_id));\n\tfh->fh_type = in_fh->fh_type;\n\thton24(fh->fh_f_ctl, f_ctl);\n\tfh->fh_ox_id = in_fh->fh_ox_id;\n\tfh->fh_rx_id = in_fh->fh_rx_id;\n\tfh->fh_cs_ctl = 0;\n\tfh->fh_df_ctl = 0;\n\tfh->fh_parm_offset = htonl(parm_offset);\n\n\tsp = fr_seq(in_fp);\n\tif (sp) {\n\t\tfr_seq(fp) = sp;\n\t\tfh->fh_seq_id = sp->id;\n\t\tseq_cnt = sp->cnt;\n\t} else {\n\t\tfh->fh_seq_id = 0;\n\t}\n\tfh->fh_seq_cnt = ntohs(seq_cnt);\n\tfr_sof(fp) = seq_cnt ? FC_SOF_N3 : FC_SOF_I3;\n\tfr_encaps(fp) = fr_encaps(in_fp);\n}\nEXPORT_SYMBOL(fc_fill_hdr);\n\n \nvoid fc_fill_reply_hdr(struct fc_frame *fp, const struct fc_frame *in_fp,\n\t\t       enum fc_rctl r_ctl, u32 parm_offset)\n{\n\tstruct fc_seq *sp;\n\n\tsp = fr_seq(in_fp);\n\tif (sp)\n\t\tfr_seq(fp) = fc_seq_start_next(sp);\n\tfc_fill_hdr(fp, in_fp, r_ctl, FC_FCTL_RESP, 0, parm_offset);\n}\nEXPORT_SYMBOL(fc_fill_reply_hdr);\n\n \nvoid fc_fc4_conf_lport_params(struct fc_lport *lport, enum fc_fh_type type)\n{\n\tstruct fc4_prov *prov_entry;\n\tBUG_ON(type >= FC_FC4_PROV_SIZE);\n\tBUG_ON(!lport);\n\tprov_entry = fc_passive_prov[type];\n\tif (type == FC_TYPE_FCP) {\n\t\tif (prov_entry && prov_entry->recv)\n\t\t\tlport->service_params |= FCP_SPPF_TARG_FCN;\n\t}\n}\n\nvoid fc_lport_iterate(void (*notify)(struct fc_lport *, void *), void *arg)\n{\n\tstruct fc_lport *lport;\n\n\tmutex_lock(&fc_prov_mutex);\n\tlist_for_each_entry(lport, &fc_local_ports, lport_list)\n\t\tnotify(lport, arg);\n\tmutex_unlock(&fc_prov_mutex);\n}\nEXPORT_SYMBOL(fc_lport_iterate);\n\n \nint fc_fc4_register_provider(enum fc_fh_type type, struct fc4_prov *prov)\n{\n\tstruct fc4_prov **prov_entry;\n\tint ret = 0;\n\n\tif (type >= FC_FC4_PROV_SIZE)\n\t\treturn -EINVAL;\n\tmutex_lock(&fc_prov_mutex);\n\tprov_entry = (prov->recv ? fc_passive_prov : fc_active_prov) + type;\n\tif (*prov_entry)\n\t\tret = -EBUSY;\n\telse\n\t\t*prov_entry = prov;\n\tmutex_unlock(&fc_prov_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(fc_fc4_register_provider);\n\n \nvoid fc_fc4_deregister_provider(enum fc_fh_type type, struct fc4_prov *prov)\n{\n\tBUG_ON(type >= FC_FC4_PROV_SIZE);\n\tmutex_lock(&fc_prov_mutex);\n\tif (prov->recv)\n\t\tRCU_INIT_POINTER(fc_passive_prov[type], NULL);\n\telse\n\t\tRCU_INIT_POINTER(fc_active_prov[type], NULL);\n\tmutex_unlock(&fc_prov_mutex);\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL(fc_fc4_deregister_provider);\n\n \nvoid fc_fc4_add_lport(struct fc_lport *lport)\n{\n\tmutex_lock(&fc_prov_mutex);\n\tlist_add_tail(&lport->lport_list, &fc_local_ports);\n\tblocking_notifier_call_chain(&fc_lport_notifier_head,\n\t\t\t\t     FC_LPORT_EV_ADD, lport);\n\tmutex_unlock(&fc_prov_mutex);\n}\n\n \nvoid fc_fc4_del_lport(struct fc_lport *lport)\n{\n\tmutex_lock(&fc_prov_mutex);\n\tlist_del(&lport->lport_list);\n\tblocking_notifier_call_chain(&fc_lport_notifier_head,\n\t\t\t\t     FC_LPORT_EV_DEL, lport);\n\tmutex_unlock(&fc_prov_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}