{
  "module_name": "stex.c",
  "hash_id": "d76903bb1ba769e7f18c33d0d9b1f36df7fa7aabf8b9585fbc929a34a30b39c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/stex.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/pci.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/ktime.h>\n#include <linux/reboot.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/byteorder.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_eh.h>\n\n#define DRV_NAME \"stex\"\n#define ST_DRIVER_VERSION\t\"6.02.0000.01\"\n#define ST_VER_MAJOR\t\t6\n#define ST_VER_MINOR\t\t02\n#define ST_OEM\t\t\t\t0000\n#define ST_BUILD_VER\t\t01\n\nenum {\n\t \n\tIMR0\t= 0x10,\t \n\tIMR1\t= 0x14,\t \n\tOMR0\t= 0x18,\t \n\tOMR1\t= 0x1c,\t \n\tIDBL\t= 0x20,\t \n\tIIS\t= 0x24,\t \n\tIIM\t= 0x28,\t \n\tODBL\t= 0x2c,\t \n\tOIS\t= 0x30,\t \n\tOIM\t= 0x3c,\t \n\n\tYIOA_STATUS\t\t\t\t= 0x00,\n\tYH2I_INT\t\t\t\t= 0x20,\n\tYINT_EN\t\t\t\t\t= 0x34,\n\tYI2H_INT\t\t\t\t= 0x9c,\n\tYI2H_INT_C\t\t\t\t= 0xa0,\n\tYH2I_REQ\t\t\t\t= 0xc0,\n\tYH2I_REQ_HI\t\t\t\t= 0xc4,\n\tPSCRATCH0\t\t\t\t= 0xb0,\n\tPSCRATCH1\t\t\t\t= 0xb4,\n\tPSCRATCH2\t\t\t\t= 0xb8,\n\tPSCRATCH3\t\t\t\t= 0xbc,\n\tPSCRATCH4\t\t\t\t= 0xc8,\n\tMAILBOX_BASE\t\t\t= 0x1000,\n\tMAILBOX_HNDSHK_STS\t\t= 0x0,\n\n\t \n\tMU_INBOUND_DOORBELL_HANDSHAKE\t\t= (1 << 0),\n\tMU_INBOUND_DOORBELL_REQHEADCHANGED\t= (1 << 1),\n\tMU_INBOUND_DOORBELL_STATUSTAILCHANGED\t= (1 << 2),\n\tMU_INBOUND_DOORBELL_HMUSTOPPED\t\t= (1 << 3),\n\tMU_INBOUND_DOORBELL_RESET\t\t= (1 << 4),\n\n\tMU_OUTBOUND_DOORBELL_HANDSHAKE\t\t= (1 << 0),\n\tMU_OUTBOUND_DOORBELL_REQUESTTAILCHANGED\t= (1 << 1),\n\tMU_OUTBOUND_DOORBELL_STATUSHEADCHANGED\t= (1 << 2),\n\tMU_OUTBOUND_DOORBELL_BUSCHANGE\t\t= (1 << 3),\n\tMU_OUTBOUND_DOORBELL_HASEVENT\t\t= (1 << 4),\n\tMU_OUTBOUND_DOORBELL_REQUEST_RESET\t= (1 << 27),\n\n\t \n\tMU_STATE_STARTING\t\t\t= 1,\n\tMU_STATE_STARTED\t\t\t= 2,\n\tMU_STATE_RESETTING\t\t\t= 3,\n\tMU_STATE_FAILED\t\t\t\t= 4,\n\tMU_STATE_STOP\t\t\t\t= 5,\n\tMU_STATE_NOCONNECT\t\t\t= 6,\n\n\tMU_MAX_DELAY\t\t\t\t= 50,\n\tMU_HANDSHAKE_SIGNATURE\t\t\t= 0x55aaaa55,\n\tMU_HANDSHAKE_SIGNATURE_HALF\t\t= 0x5a5a0000,\n\tMU_HARD_RESET_WAIT\t\t\t= 30000,\n\tHMU_PARTNER_TYPE\t\t\t= 2,\n\n\t \n\tSRB_STATUS_SUCCESS\t\t\t= 0x01,\n\tSRB_STATUS_ERROR\t\t\t= 0x04,\n\tSRB_STATUS_BUSY\t\t\t\t= 0x05,\n\tSRB_STATUS_INVALID_REQUEST\t\t= 0x06,\n\tSRB_STATUS_SELECTION_TIMEOUT\t\t= 0x0A,\n\tSRB_SEE_SENSE \t\t\t\t= 0x80,\n\n\t \n\tTASK_ATTRIBUTE_SIMPLE\t\t\t= 0x0,\n\tTASK_ATTRIBUTE_HEADOFQUEUE\t\t= 0x1,\n\tTASK_ATTRIBUTE_ORDERED\t\t\t= 0x2,\n\tTASK_ATTRIBUTE_ACA\t\t\t= 0x4,\n};\n\nenum {\n\tSS_STS_NORMAL\t\t\t\t= 0x80000000,\n\tSS_STS_DONE\t\t\t\t= 0x40000000,\n\tSS_STS_HANDSHAKE\t\t\t= 0x20000000,\n\n\tSS_HEAD_HANDSHAKE\t\t\t= 0x80,\n\n\tSS_H2I_INT_RESET\t\t\t= 0x100,\n\n\tSS_I2H_REQUEST_RESET\t\t\t= 0x2000,\n\n\tSS_MU_OPERATIONAL\t\t\t= 0x80000000,\n};\n\nenum {\n\tSTEX_CDB_LENGTH\t\t\t\t= 16,\n\tSTATUS_VAR_LEN\t\t\t\t= 128,\n\n\t \n\tSG_CF_EOT\t\t\t\t= 0x80,\t \n\tSG_CF_64B\t\t\t\t= 0x40,\t \n\tSG_CF_HOST\t\t\t\t= 0x20,\t \n\tMSG_DATA_DIR_ND\t\t\t\t= 0,\n\tMSG_DATA_DIR_IN\t\t\t\t= 1,\n\tMSG_DATA_DIR_OUT\t\t\t= 2,\n\n\tst_shasta\t\t\t\t= 0,\n\tst_vsc\t\t\t\t\t= 1,\n\tst_yosemite\t\t\t\t= 2,\n\tst_seq\t\t\t\t\t= 3,\n\tst_yel\t\t\t\t\t= 4,\n\tst_P3\t\t\t\t\t= 5,\n\n\tPASSTHRU_REQ_TYPE\t\t\t= 0x00000001,\n\tPASSTHRU_REQ_NO_WAKEUP\t\t\t= 0x00000100,\n\tST_INTERNAL_TIMEOUT\t\t\t= 180,\n\n\tST_TO_CMD\t\t\t\t= 0,\n\tST_FROM_CMD\t\t\t\t= 1,\n\n\t \n\tMGT_CMD\t\t\t\t\t= 0xd8,\n\tSINBAND_MGT_CMD\t\t\t\t= 0xd9,\n\tARRAY_CMD\t\t\t\t= 0xe0,\n\tCONTROLLER_CMD\t\t\t\t= 0xe1,\n\tDEBUGGING_CMD\t\t\t\t= 0xe2,\n\tPASSTHRU_CMD\t\t\t\t= 0xe3,\n\n\tPASSTHRU_GET_ADAPTER\t\t\t= 0x05,\n\tPASSTHRU_GET_DRVVER\t\t\t= 0x10,\n\n\tCTLR_CONFIG_CMD\t\t\t\t= 0x03,\n\tCTLR_SHUTDOWN\t\t\t\t= 0x0d,\n\n\tCTLR_POWER_STATE_CHANGE\t\t\t= 0x0e,\n\tCTLR_POWER_SAVING\t\t\t= 0x01,\n\n\tPASSTHRU_SIGNATURE\t\t\t= 0x4e415041,\n\tMGT_CMD_SIGNATURE\t\t\t= 0xba,\n\n\tINQUIRY_EVPD\t\t\t\t= 0x01,\n\n\tST_ADDITIONAL_MEM\t\t\t= 0x200000,\n\tST_ADDITIONAL_MEM_MIN\t\t\t= 0x80000,\n\tPMIC_SHUTDOWN\t\t\t\t= 0x0D,\n\tPMIC_REUMSE\t\t\t\t\t= 0x10,\n\tST_IGNORED\t\t\t\t\t= -1,\n\tST_NOTHANDLED\t\t\t\t= 7,\n\tST_S3\t\t\t\t\t\t= 3,\n\tST_S4\t\t\t\t\t\t= 4,\n\tST_S5\t\t\t\t\t\t= 5,\n\tST_S6\t\t\t\t\t\t= 6,\n};\n\nstruct st_sgitem {\n\tu8 ctrl;\t \n\tu8 reserved[3];\n\t__le32 count;\n\t__le64 addr;\n};\n\nstruct st_ss_sgitem {\n\t__le32 addr;\n\t__le32 addr_hi;\n\t__le32 count;\n};\n\nstruct st_sgtable {\n\t__le16 sg_count;\n\t__le16 max_sg_count;\n\t__le32 sz_in_byte;\n};\n\nstruct st_msg_header {\n\t__le64 handle;\n\tu8 flag;\n\tu8 channel;\n\t__le16 timeout;\n\tu32 reserved;\n};\n\nstruct handshake_frame {\n\t__le64 rb_phy;\t\t \n\t__le16 req_sz;\t\t \n\t__le16 req_cnt;\t\t \n\t__le16 status_sz;\t \n\t__le16 status_cnt;\t \n\t__le64 hosttime;\t \n\tu8 partner_type;\t \n\tu8 reserved0[7];\n\t__le32 partner_ver_major;\n\t__le32 partner_ver_minor;\n\t__le32 partner_ver_oem;\n\t__le32 partner_ver_build;\n\t__le32 extra_offset;\t \n\t__le32 extra_size;\t \n\t__le32 scratch_size;\n\tu32 reserved1;\n};\n\nstruct req_msg {\n\t__le16 tag;\n\tu8 lun;\n\tu8 target;\n\tu8 task_attr;\n\tu8 task_manage;\n\tu8 data_dir;\n\tu8 payload_sz;\t\t \n\tu8 cdb[STEX_CDB_LENGTH];\n\tu32 variable[];\n};\n\nstruct status_msg {\n\t__le16 tag;\n\tu8 lun;\n\tu8 target;\n\tu8 srb_status;\n\tu8 scsi_status;\n\tu8 reserved;\n\tu8 payload_sz;\t\t \n\tu8 variable[STATUS_VAR_LEN];\n};\n\nstruct ver_info {\n\tu32 major;\n\tu32 minor;\n\tu32 oem;\n\tu32 build;\n\tu32 reserved[2];\n};\n\nstruct st_frame {\n\tu32 base[6];\n\tu32 rom_addr;\n\n\tstruct ver_info drv_ver;\n\tstruct ver_info bios_ver;\n\n\tu32 bus;\n\tu32 slot;\n\tu32 irq_level;\n\tu32 irq_vec;\n\tu32 id;\n\tu32 subid;\n\n\tu32 dimm_size;\n\tu8 dimm_type;\n\tu8 reserved[3];\n\n\tu32 channel;\n\tu32 reserved1;\n};\n\nstruct st_drvver {\n\tu32 major;\n\tu32 minor;\n\tu32 oem;\n\tu32 build;\n\tu32 signature[2];\n\tu8 console_id;\n\tu8 host_no;\n\tu8 reserved0[2];\n\tu32 reserved[3];\n};\n\nstruct st_ccb {\n\tstruct req_msg *req;\n\tstruct scsi_cmnd *cmd;\n\n\tvoid *sense_buffer;\n\tunsigned int sense_bufflen;\n\tint sg_count;\n\n\tu32 req_type;\n\tu8 srb_status;\n\tu8 scsi_status;\n\tu8 reserved[2];\n};\n\nstruct st_hba {\n\tvoid __iomem *mmio_base;\t \n\tvoid *dma_mem;\n\tdma_addr_t dma_handle;\n\tsize_t dma_size;\n\n\tstruct Scsi_Host *host;\n\tstruct pci_dev *pdev;\n\n\tstruct req_msg * (*alloc_rq) (struct st_hba *);\n\tint (*map_sg)(struct st_hba *, struct req_msg *, struct st_ccb *);\n\tvoid (*send) (struct st_hba *, struct req_msg *, u16);\n\n\tu32 req_head;\n\tu32 req_tail;\n\tu32 status_head;\n\tu32 status_tail;\n\n\tstruct status_msg *status_buffer;\n\tvoid *copy_buffer;  \n\tstruct st_ccb *ccb;\n\tstruct st_ccb *wait_ccb;\n\t__le32 *scratch;\n\n\tchar work_q_name[20];\n\tstruct workqueue_struct *work_q;\n\tstruct work_struct reset_work;\n\twait_queue_head_t reset_waitq;\n\tunsigned int mu_status;\n\tunsigned int cardtype;\n\tint msi_enabled;\n\tint out_req_cnt;\n\tu32 extra_offset;\n\tu16 rq_count;\n\tu16 rq_size;\n\tu16 sts_count;\n\tu8  supports_pm;\n\tint msi_lock;\n};\n\nstruct st_card_info {\n\tstruct req_msg * (*alloc_rq) (struct st_hba *);\n\tint (*map_sg)(struct st_hba *, struct req_msg *, struct st_ccb *);\n\tvoid (*send) (struct st_hba *, struct req_msg *, u16);\n\tunsigned int max_id;\n\tunsigned int max_lun;\n\tunsigned int max_channel;\n\tu16 rq_count;\n\tu16 rq_size;\n\tu16 sts_count;\n};\n\nstatic int S6flag;\nstatic int stex_halt(struct notifier_block *nb, ulong event, void *buf);\nstatic struct notifier_block stex_notifier = {\n\tstex_halt, NULL, 0\n};\n\nstatic int msi;\nmodule_param(msi, int, 0);\nMODULE_PARM_DESC(msi, \"Enable Message Signaled Interrupts(0=off, 1=on)\");\n\nstatic const char console_inq_page[] =\n{\n\t0x03,0x00,0x03,0x03,0xFA,0x00,0x00,0x30,\n\t0x50,0x72,0x6F,0x6D,0x69,0x73,0x65,0x20,\t \n\t0x52,0x41,0x49,0x44,0x20,0x43,0x6F,0x6E,\t \n\t0x73,0x6F,0x6C,0x65,0x20,0x20,0x20,0x20,\t \n\t0x31,0x2E,0x30,0x30,0x20,0x20,0x20,0x20,\t \n\t0x53,0x58,0x2F,0x52,0x53,0x41,0x46,0x2D,\t \n\t0x54,0x45,0x31,0x2E,0x30,0x30,0x20,0x20,\t \n\t0x0C,0x20,0x20,0x20,0x20,0x20,0x20,0x20\n};\n\nMODULE_AUTHOR(\"Ed Lin\");\nMODULE_DESCRIPTION(\"Promise Technology SuperTrak EX Controllers\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(ST_DRIVER_VERSION);\n\nstatic struct status_msg *stex_get_status(struct st_hba *hba)\n{\n\tstruct status_msg *status = hba->status_buffer + hba->status_tail;\n\n\t++hba->status_tail;\n\thba->status_tail %= hba->sts_count+1;\n\n\treturn status;\n}\n\nstatic void stex_invalid_field(struct scsi_cmnd *cmd,\n\t\t\t       void (*done)(struct scsi_cmnd *))\n{\n\t \n\tscsi_build_sense(cmd, 0, ILLEGAL_REQUEST, 0x24, 0x0);\n\tdone(cmd);\n}\n\nstatic struct req_msg *stex_alloc_req(struct st_hba *hba)\n{\n\tstruct req_msg *req = hba->dma_mem + hba->req_head * hba->rq_size;\n\n\t++hba->req_head;\n\thba->req_head %= hba->rq_count+1;\n\n\treturn req;\n}\n\nstatic struct req_msg *stex_ss_alloc_req(struct st_hba *hba)\n{\n\treturn (struct req_msg *)(hba->dma_mem +\n\t\thba->req_head * hba->rq_size + sizeof(struct st_msg_header));\n}\n\nstatic int stex_map_sg(struct st_hba *hba,\n\tstruct req_msg *req, struct st_ccb *ccb)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct scatterlist *sg;\n\tstruct st_sgtable *dst;\n\tstruct st_sgitem *table;\n\tint i, nseg;\n\n\tcmd = ccb->cmd;\n\tnseg = scsi_dma_map(cmd);\n\tBUG_ON(nseg < 0);\n\tif (nseg) {\n\t\tdst = (struct st_sgtable *)req->variable;\n\n\t\tccb->sg_count = nseg;\n\t\tdst->sg_count = cpu_to_le16((u16)nseg);\n\t\tdst->max_sg_count = cpu_to_le16(hba->host->sg_tablesize);\n\t\tdst->sz_in_byte = cpu_to_le32(scsi_bufflen(cmd));\n\n\t\ttable = (struct st_sgitem *)(dst + 1);\n\t\tscsi_for_each_sg(cmd, sg, nseg, i) {\n\t\t\ttable[i].count = cpu_to_le32((u32)sg_dma_len(sg));\n\t\t\ttable[i].addr = cpu_to_le64(sg_dma_address(sg));\n\t\t\ttable[i].ctrl = SG_CF_64B | SG_CF_HOST;\n\t\t}\n\t\ttable[--i].ctrl |= SG_CF_EOT;\n\t}\n\n\treturn nseg;\n}\n\nstatic int stex_ss_map_sg(struct st_hba *hba,\n\tstruct req_msg *req, struct st_ccb *ccb)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct scatterlist *sg;\n\tstruct st_sgtable *dst;\n\tstruct st_ss_sgitem *table;\n\tint i, nseg;\n\n\tcmd = ccb->cmd;\n\tnseg = scsi_dma_map(cmd);\n\tBUG_ON(nseg < 0);\n\tif (nseg) {\n\t\tdst = (struct st_sgtable *)req->variable;\n\n\t\tccb->sg_count = nseg;\n\t\tdst->sg_count = cpu_to_le16((u16)nseg);\n\t\tdst->max_sg_count = cpu_to_le16(hba->host->sg_tablesize);\n\t\tdst->sz_in_byte = cpu_to_le32(scsi_bufflen(cmd));\n\n\t\ttable = (struct st_ss_sgitem *)(dst + 1);\n\t\tscsi_for_each_sg(cmd, sg, nseg, i) {\n\t\t\ttable[i].count = cpu_to_le32((u32)sg_dma_len(sg));\n\t\t\ttable[i].addr =\n\t\t\t\tcpu_to_le32(sg_dma_address(sg) & 0xffffffff);\n\t\t\ttable[i].addr_hi =\n\t\t\t\tcpu_to_le32((sg_dma_address(sg) >> 16) >> 16);\n\t\t}\n\t}\n\n\treturn nseg;\n}\n\nstatic void stex_controller_info(struct st_hba *hba, struct st_ccb *ccb)\n{\n\tstruct st_frame *p;\n\tsize_t count = sizeof(struct st_frame);\n\n\tp = hba->copy_buffer;\n\tscsi_sg_copy_to_buffer(ccb->cmd, p, count);\n\tmemset(p->base, 0, sizeof(u32)*6);\n\t*(unsigned long *)(p->base) = pci_resource_start(hba->pdev, 0);\n\tp->rom_addr = 0;\n\n\tp->drv_ver.major = ST_VER_MAJOR;\n\tp->drv_ver.minor = ST_VER_MINOR;\n\tp->drv_ver.oem = ST_OEM;\n\tp->drv_ver.build = ST_BUILD_VER;\n\n\tp->bus = hba->pdev->bus->number;\n\tp->slot = hba->pdev->devfn;\n\tp->irq_level = 0;\n\tp->irq_vec = hba->pdev->irq;\n\tp->id = hba->pdev->vendor << 16 | hba->pdev->device;\n\tp->subid =\n\t\thba->pdev->subsystem_vendor << 16 | hba->pdev->subsystem_device;\n\n\tscsi_sg_copy_from_buffer(ccb->cmd, p, count);\n}\n\nstatic void\nstex_send_cmd(struct st_hba *hba, struct req_msg *req, u16 tag)\n{\n\treq->tag = cpu_to_le16(tag);\n\n\thba->ccb[tag].req = req;\n\thba->out_req_cnt++;\n\n\twritel(hba->req_head, hba->mmio_base + IMR0);\n\twritel(MU_INBOUND_DOORBELL_REQHEADCHANGED, hba->mmio_base + IDBL);\n\treadl(hba->mmio_base + IDBL);  \n}\n\nstatic void\nstex_ss_send_cmd(struct st_hba *hba, struct req_msg *req, u16 tag)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct st_msg_header *msg_h;\n\tdma_addr_t addr;\n\n\treq->tag = cpu_to_le16(tag);\n\n\thba->ccb[tag].req = req;\n\thba->out_req_cnt++;\n\n\tcmd = hba->ccb[tag].cmd;\n\tmsg_h = (struct st_msg_header *)req - 1;\n\tif (likely(cmd)) {\n\t\tmsg_h->channel = (u8)cmd->device->channel;\n\t\tmsg_h->timeout = cpu_to_le16(scsi_cmd_to_rq(cmd)->timeout / HZ);\n\t}\n\taddr = hba->dma_handle + hba->req_head * hba->rq_size;\n\taddr += (hba->ccb[tag].sg_count+4)/11;\n\tmsg_h->handle = cpu_to_le64(addr);\n\n\t++hba->req_head;\n\thba->req_head %= hba->rq_count+1;\n\tif (hba->cardtype == st_P3) {\n\t\twritel((addr >> 16) >> 16, hba->mmio_base + YH2I_REQ_HI);\n\t\twritel(addr, hba->mmio_base + YH2I_REQ);\n\t} else {\n\t\twritel((addr >> 16) >> 16, hba->mmio_base + YH2I_REQ_HI);\n\t\treadl(hba->mmio_base + YH2I_REQ_HI);  \n\t\twritel(addr, hba->mmio_base + YH2I_REQ);\n\t\treadl(hba->mmio_base + YH2I_REQ);  \n\t}\n}\n\nstatic void return_abnormal_state(struct st_hba *hba, int status)\n{\n\tstruct st_ccb *ccb;\n\tunsigned long flags;\n\tu16 tag;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tfor (tag = 0; tag < hba->host->can_queue; tag++) {\n\t\tccb = &hba->ccb[tag];\n\t\tif (ccb->req == NULL)\n\t\t\tcontinue;\n\t\tccb->req = NULL;\n\t\tif (ccb->cmd) {\n\t\t\tscsi_dma_unmap(ccb->cmd);\n\t\t\tccb->cmd->result = status << 16;\n\t\t\tscsi_done(ccb->cmd);\n\t\t\tccb->cmd = NULL;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n}\nstatic int\nstex_slave_config(struct scsi_device *sdev)\n{\n\tsdev->use_10_for_rw = 1;\n\tsdev->use_10_for_ms = 1;\n\tblk_queue_rq_timeout(sdev->request_queue, 60 * HZ);\n\n\treturn 0;\n}\n\nstatic int stex_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tstruct st_hba *hba;\n\tstruct Scsi_Host *host;\n\tunsigned int id, lun;\n\tstruct req_msg *req;\n\tu16 tag;\n\n\thost = cmd->device->host;\n\tid = cmd->device->id;\n\tlun = cmd->device->lun;\n\thba = (struct st_hba *) &host->hostdata[0];\n\tif (hba->mu_status == MU_STATE_NOCONNECT) {\n\t\tcmd->result = DID_NO_CONNECT;\n\t\tdone(cmd);\n\t\treturn 0;\n\t}\n\tif (unlikely(hba->mu_status != MU_STATE_STARTED))\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tswitch (cmd->cmnd[0]) {\n\tcase MODE_SENSE_10:\n\t{\n\t\tstatic char ms10_caching_page[12] =\n\t\t\t{ 0, 0x12, 0, 0, 0, 0, 0, 0, 0x8, 0xa, 0x4, 0 };\n\t\tunsigned char page;\n\n\t\tpage = cmd->cmnd[2] & 0x3f;\n\t\tif (page == 0x8 || page == 0x3f) {\n\t\t\tscsi_sg_copy_from_buffer(cmd, ms10_caching_page,\n\t\t\t\t\t\t sizeof(ms10_caching_page));\n\t\t\tcmd->result = DID_OK << 16;\n\t\t\tdone(cmd);\n\t\t} else\n\t\t\tstex_invalid_field(cmd, done);\n\t\treturn 0;\n\t}\n\tcase REPORT_LUNS:\n\t\t \n\t\tif (hba->cardtype == st_shasta || id == host->max_id - 1) {\n\t\t\tstex_invalid_field(cmd, done);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase TEST_UNIT_READY:\n\t\tif (id == host->max_id - 1) {\n\t\t\tcmd->result = DID_OK << 16;\n\t\t\tdone(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase INQUIRY:\n\t\tif (lun >= host->max_lun) {\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\t\tdone(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tif (id != host->max_id - 1)\n\t\t\tbreak;\n\t\tif (!lun && !cmd->device->channel &&\n\t\t\t(cmd->cmnd[1] & INQUIRY_EVPD) == 0) {\n\t\t\tscsi_sg_copy_from_buffer(cmd, (void *)console_inq_page,\n\t\t\t\t\t\t sizeof(console_inq_page));\n\t\t\tcmd->result = DID_OK << 16;\n\t\t\tdone(cmd);\n\t\t} else\n\t\t\tstex_invalid_field(cmd, done);\n\t\treturn 0;\n\tcase PASSTHRU_CMD:\n\t\tif (cmd->cmnd[1] == PASSTHRU_GET_DRVVER) {\n\t\t\tconst struct st_drvver ver = {\n\t\t\t\t.major = ST_VER_MAJOR,\n\t\t\t\t.minor = ST_VER_MINOR,\n\t\t\t\t.oem = ST_OEM,\n\t\t\t\t.build = ST_BUILD_VER,\n\t\t\t\t.signature[0] = PASSTHRU_SIGNATURE,\n\t\t\t\t.console_id = host->max_id - 1,\n\t\t\t\t.host_no = hba->host->host_no,\n\t\t\t};\n\t\t\tsize_t cp_len = sizeof(ver);\n\n\t\t\tcp_len = scsi_sg_copy_from_buffer(cmd, &ver, cp_len);\n\t\t\tif (sizeof(ver) == cp_len)\n\t\t\t\tcmd->result = DID_OK << 16;\n\t\t\telse\n\t\t\t\tcmd->result = DID_ERROR << 16;\n\t\t\tdone(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttag = scsi_cmd_to_rq(cmd)->tag;\n\n\tif (unlikely(tag >= host->can_queue))\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\treq = hba->alloc_rq(hba);\n\n\treq->lun = lun;\n\treq->target = id;\n\n\t \n\tmemcpy(req->cdb, cmd->cmnd, STEX_CDB_LENGTH);\n\n\tif (cmd->sc_data_direction == DMA_FROM_DEVICE)\n\t\treq->data_dir = MSG_DATA_DIR_IN;\n\telse if (cmd->sc_data_direction == DMA_TO_DEVICE)\n\t\treq->data_dir = MSG_DATA_DIR_OUT;\n\telse\n\t\treq->data_dir = MSG_DATA_DIR_ND;\n\n\thba->ccb[tag].cmd = cmd;\n\thba->ccb[tag].sense_bufflen = SCSI_SENSE_BUFFERSIZE;\n\thba->ccb[tag].sense_buffer = cmd->sense_buffer;\n\n\tif (!hba->map_sg(hba, req, &hba->ccb[tag])) {\n\t\thba->ccb[tag].sg_count = 0;\n\t\tmemset(&req->variable[0], 0, 8);\n\t}\n\n\thba->send(hba, req, tag);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(stex_queuecommand)\n\nstatic void stex_scsi_done(struct st_ccb *ccb)\n{\n\tstruct scsi_cmnd *cmd = ccb->cmd;\n\tint result;\n\n\tif (ccb->srb_status == SRB_STATUS_SUCCESS || ccb->srb_status == 0) {\n\t\tresult = ccb->scsi_status;\n\t\tswitch (ccb->scsi_status) {\n\t\tcase SAM_STAT_GOOD:\n\t\t\tresult |= DID_OK << 16;\n\t\t\tbreak;\n\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\t\tresult |= DID_OK << 16;\n\t\t\tbreak;\n\t\tcase SAM_STAT_BUSY:\n\t\t\tresult |= DID_BUS_BUSY << 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult |= DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\t}\n\telse if (ccb->srb_status & SRB_SEE_SENSE)\n\t\tresult = SAM_STAT_CHECK_CONDITION;\n\telse switch (ccb->srb_status) {\n\t\tcase SRB_STATUS_SELECTION_TIMEOUT:\n\t\t\tresult = DID_NO_CONNECT << 16;\n\t\t\tbreak;\n\t\tcase SRB_STATUS_BUSY:\n\t\t\tresult = DID_BUS_BUSY << 16;\n\t\t\tbreak;\n\t\tcase SRB_STATUS_INVALID_REQUEST:\n\t\tcase SRB_STATUS_ERROR:\n\t\tdefault:\n\t\t\tresult = DID_ERROR << 16;\n\t\t\tbreak;\n\t}\n\n\tcmd->result = result;\n\tscsi_done(cmd);\n}\n\nstatic void stex_copy_data(struct st_ccb *ccb,\n\tstruct status_msg *resp, unsigned int variable)\n{\n\tif (resp->scsi_status != SAM_STAT_GOOD) {\n\t\tif (ccb->sense_buffer != NULL)\n\t\t\tmemcpy(ccb->sense_buffer, resp->variable,\n\t\t\t\tmin(variable, ccb->sense_bufflen));\n\t\treturn;\n\t}\n\n\tif (ccb->cmd == NULL)\n\t\treturn;\n\tscsi_sg_copy_from_buffer(ccb->cmd, resp->variable, variable);\n}\n\nstatic void stex_check_cmd(struct st_hba *hba,\n\tstruct st_ccb *ccb, struct status_msg *resp)\n{\n\tif (ccb->cmd->cmnd[0] == MGT_CMD &&\n\t\tresp->scsi_status != SAM_STAT_CHECK_CONDITION)\n\t\tscsi_set_resid(ccb->cmd, scsi_bufflen(ccb->cmd) -\n\t\t\tle32_to_cpu(*(__le32 *)&resp->variable[0]));\n}\n\nstatic void stex_mu_intr(struct st_hba *hba, u32 doorbell)\n{\n\tvoid __iomem *base = hba->mmio_base;\n\tstruct status_msg *resp;\n\tstruct st_ccb *ccb;\n\tunsigned int size;\n\tu16 tag;\n\n\tif (unlikely(!(doorbell & MU_OUTBOUND_DOORBELL_STATUSHEADCHANGED)))\n\t\treturn;\n\n\t \n\thba->status_head = readl(base + OMR1);\n\tif (unlikely(hba->status_head > hba->sts_count)) {\n\t\tprintk(KERN_WARNING DRV_NAME \"(%s): invalid status head\\n\",\n\t\t\tpci_name(hba->pdev));\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(hba->out_req_cnt <= 0 ||\n\t\t\t(hba->mu_status == MU_STATE_RESETTING &&\n\t\t\t hba->cardtype != st_yosemite))) {\n\t\thba->status_tail = hba->status_head;\n\t\tgoto update_status;\n\t}\n\n\twhile (hba->status_tail != hba->status_head) {\n\t\tresp = stex_get_status(hba);\n\t\ttag = le16_to_cpu(resp->tag);\n\t\tif (unlikely(tag >= hba->host->can_queue)) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\t\"(%s): invalid tag\\n\", pci_name(hba->pdev));\n\t\t\tcontinue;\n\t\t}\n\n\t\thba->out_req_cnt--;\n\t\tccb = &hba->ccb[tag];\n\t\tif (unlikely(hba->wait_ccb == ccb))\n\t\t\thba->wait_ccb = NULL;\n\t\tif (unlikely(ccb->req == NULL)) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\t\"(%s): lagging req\\n\", pci_name(hba->pdev));\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize = resp->payload_sz * sizeof(u32);  \n\t\tif (unlikely(size < sizeof(*resp) - STATUS_VAR_LEN ||\n\t\t\tsize > sizeof(*resp))) {\n\t\t\tprintk(KERN_WARNING DRV_NAME \"(%s): bad status size\\n\",\n\t\t\t\tpci_name(hba->pdev));\n\t\t} else {\n\t\t\tsize -= sizeof(*resp) - STATUS_VAR_LEN;  \n\t\t\tif (size)\n\t\t\t\tstex_copy_data(ccb, resp, size);\n\t\t}\n\n\t\tccb->req = NULL;\n\t\tccb->srb_status = resp->srb_status;\n\t\tccb->scsi_status = resp->scsi_status;\n\n\t\tif (likely(ccb->cmd != NULL)) {\n\t\t\tif (hba->cardtype == st_yosemite)\n\t\t\t\tstex_check_cmd(hba, ccb, resp);\n\n\t\t\tif (unlikely(ccb->cmd->cmnd[0] == PASSTHRU_CMD &&\n\t\t\t\tccb->cmd->cmnd[1] == PASSTHRU_GET_ADAPTER))\n\t\t\t\tstex_controller_info(hba, ccb);\n\n\t\t\tscsi_dma_unmap(ccb->cmd);\n\t\t\tstex_scsi_done(ccb);\n\t\t} else\n\t\t\tccb->req_type = 0;\n\t}\n\nupdate_status:\n\twritel(hba->status_head, base + IMR1);\n\treadl(base + IMR1);  \n}\n\nstatic irqreturn_t stex_intr(int irq, void *__hba)\n{\n\tstruct st_hba *hba = __hba;\n\tvoid __iomem *base = hba->mmio_base;\n\tu32 data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\n\tdata = readl(base + ODBL);\n\n\tif (data && data != 0xffffffff) {\n\t\t \n\t\twritel(data, base + ODBL);\n\t\treadl(base + ODBL);  \n\t\tstex_mu_intr(hba, data);\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\tif (unlikely(data & MU_OUTBOUND_DOORBELL_REQUEST_RESET &&\n\t\t\thba->cardtype == st_shasta))\n\t\t\tqueue_work(hba->work_q, &hba->reset_work);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\treturn IRQ_NONE;\n}\n\nstatic void stex_ss_mu_intr(struct st_hba *hba)\n{\n\tstruct status_msg *resp;\n\tstruct st_ccb *ccb;\n\t__le32 *scratch;\n\tunsigned int size;\n\tint count = 0;\n\tu32 value;\n\tu16 tag;\n\n\tif (unlikely(hba->out_req_cnt <= 0 ||\n\t\t\thba->mu_status == MU_STATE_RESETTING))\n\t\treturn;\n\n\twhile (count < hba->sts_count) {\n\t\tscratch = hba->scratch + hba->status_tail;\n\t\tvalue = le32_to_cpu(*scratch);\n\t\tif (unlikely(!(value & SS_STS_NORMAL)))\n\t\t\treturn;\n\n\t\tresp = hba->status_buffer + hba->status_tail;\n\t\t*scratch = 0;\n\t\t++count;\n\t\t++hba->status_tail;\n\t\thba->status_tail %= hba->sts_count+1;\n\n\t\ttag = (u16)value;\n\t\tif (unlikely(tag >= hba->host->can_queue)) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\t\"(%s): invalid tag\\n\", pci_name(hba->pdev));\n\t\t\tcontinue;\n\t\t}\n\n\t\thba->out_req_cnt--;\n\t\tccb = &hba->ccb[tag];\n\t\tif (unlikely(hba->wait_ccb == ccb))\n\t\t\thba->wait_ccb = NULL;\n\t\tif (unlikely(ccb->req == NULL)) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\t\"(%s): lagging req\\n\", pci_name(hba->pdev));\n\t\t\tcontinue;\n\t\t}\n\n\t\tccb->req = NULL;\n\t\tif (likely(value & SS_STS_DONE)) {  \n\t\t\tccb->srb_status = SRB_STATUS_SUCCESS;\n\t\t\tccb->scsi_status = SAM_STAT_GOOD;\n\t\t} else {\n\t\t\tccb->srb_status = resp->srb_status;\n\t\t\tccb->scsi_status = resp->scsi_status;\n\t\t\tsize = resp->payload_sz * sizeof(u32);\n\t\t\tif (unlikely(size < sizeof(*resp) - STATUS_VAR_LEN ||\n\t\t\t\tsize > sizeof(*resp))) {\n\t\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\t\t\"(%s): bad status size\\n\",\n\t\t\t\t\tpci_name(hba->pdev));\n\t\t\t} else {\n\t\t\t\tsize -= sizeof(*resp) - STATUS_VAR_LEN;\n\t\t\t\tif (size)\n\t\t\t\t\tstex_copy_data(ccb, resp, size);\n\t\t\t}\n\t\t\tif (likely(ccb->cmd != NULL))\n\t\t\t\tstex_check_cmd(hba, ccb, resp);\n\t\t}\n\n\t\tif (likely(ccb->cmd != NULL)) {\n\t\t\tscsi_dma_unmap(ccb->cmd);\n\t\t\tstex_scsi_done(ccb);\n\t\t} else\n\t\t\tccb->req_type = 0;\n\t}\n}\n\nstatic irqreturn_t stex_ss_intr(int irq, void *__hba)\n{\n\tstruct st_hba *hba = __hba;\n\tvoid __iomem *base = hba->mmio_base;\n\tu32 data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\n\tif (hba->cardtype == st_yel) {\n\t\tdata = readl(base + YI2H_INT);\n\t\tif (data && data != 0xffffffff) {\n\t\t\t \n\t\t\twritel(data, base + YI2H_INT_C);\n\t\t\tstex_ss_mu_intr(hba);\n\t\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\t\tif (unlikely(data & SS_I2H_REQUEST_RESET))\n\t\t\t\tqueue_work(hba->work_q, &hba->reset_work);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t} else {\n\t\tdata = readl(base + PSCRATCH4);\n\t\tif (data != 0xffffffff) {\n\t\t\tif (data != 0) {\n\t\t\t\t \n\t\t\t\twritel(data, base + PSCRATCH1);\n\t\t\t\twritel((1 << 22), base + YH2I_INT);\n\t\t\t}\n\t\t\tstex_ss_mu_intr(hba);\n\t\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\t\tif (unlikely(data & SS_I2H_REQUEST_RESET))\n\t\t\t\tqueue_work(hba->work_q, &hba->reset_work);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\treturn IRQ_NONE;\n}\n\nstatic int stex_common_handshake(struct st_hba *hba)\n{\n\tvoid __iomem *base = hba->mmio_base;\n\tstruct handshake_frame *h;\n\tdma_addr_t status_phys;\n\tu32 data;\n\tunsigned long before;\n\n\tif (readl(base + OMR0) != MU_HANDSHAKE_SIGNATURE) {\n\t\twritel(MU_INBOUND_DOORBELL_HANDSHAKE, base + IDBL);\n\t\treadl(base + IDBL);\n\t\tbefore = jiffies;\n\t\twhile (readl(base + OMR0) != MU_HANDSHAKE_SIGNATURE) {\n\t\t\tif (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {\n\t\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t\t\t\"(%s): no handshake signature\\n\",\n\t\t\t\t\tpci_name(hba->pdev));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\trmb();\n\t\t\tmsleep(1);\n\t\t}\n\t}\n\n\tudelay(10);\n\n\tdata = readl(base + OMR1);\n\tif ((data & 0xffff0000) == MU_HANDSHAKE_SIGNATURE_HALF) {\n\t\tdata &= 0x0000ffff;\n\t\tif (hba->host->can_queue > data) {\n\t\t\thba->host->can_queue = data;\n\t\t\thba->host->cmd_per_lun = data;\n\t\t}\n\t}\n\n\th = (struct handshake_frame *)hba->status_buffer;\n\th->rb_phy = cpu_to_le64(hba->dma_handle);\n\th->req_sz = cpu_to_le16(hba->rq_size);\n\th->req_cnt = cpu_to_le16(hba->rq_count+1);\n\th->status_sz = cpu_to_le16(sizeof(struct status_msg));\n\th->status_cnt = cpu_to_le16(hba->sts_count+1);\n\th->hosttime = cpu_to_le64(ktime_get_real_seconds());\n\th->partner_type = HMU_PARTNER_TYPE;\n\tif (hba->extra_offset) {\n\t\th->extra_offset = cpu_to_le32(hba->extra_offset);\n\t\th->extra_size = cpu_to_le32(hba->dma_size - hba->extra_offset);\n\t} else\n\t\th->extra_offset = h->extra_size = 0;\n\n\tstatus_phys = hba->dma_handle + (hba->rq_count+1) * hba->rq_size;\n\twritel(status_phys, base + IMR0);\n\treadl(base + IMR0);\n\twritel((status_phys >> 16) >> 16, base + IMR1);\n\treadl(base + IMR1);\n\n\twritel((status_phys >> 16) >> 16, base + OMR0);  \n\treadl(base + OMR0);\n\twritel(MU_INBOUND_DOORBELL_HANDSHAKE, base + IDBL);\n\treadl(base + IDBL);  \n\n\tudelay(10);\n\tbefore = jiffies;\n\twhile (readl(base + OMR0) != MU_HANDSHAKE_SIGNATURE) {\n\t\tif (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t\t\"(%s): no signature after handshake frame\\n\",\n\t\t\t\tpci_name(hba->pdev));\n\t\t\treturn -1;\n\t\t}\n\t\trmb();\n\t\tmsleep(1);\n\t}\n\n\twritel(0, base + IMR0);\n\treadl(base + IMR0);\n\twritel(0, base + OMR0);\n\treadl(base + OMR0);\n\twritel(0, base + IMR1);\n\treadl(base + IMR1);\n\twritel(0, base + OMR1);\n\treadl(base + OMR1);  \n\treturn 0;\n}\n\nstatic int stex_ss_handshake(struct st_hba *hba)\n{\n\tvoid __iomem *base = hba->mmio_base;\n\tstruct st_msg_header *msg_h;\n\tstruct handshake_frame *h;\n\t__le32 *scratch;\n\tu32 data, scratch_size, mailboxdata, operationaldata;\n\tunsigned long before;\n\tint ret = 0;\n\n\tbefore = jiffies;\n\n\tif (hba->cardtype == st_yel) {\n\t\toperationaldata = readl(base + YIOA_STATUS);\n\t\twhile (operationaldata != SS_MU_OPERATIONAL) {\n\t\t\tif (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {\n\t\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t\t\t\"(%s): firmware not operational\\n\",\n\t\t\t\t\tpci_name(hba->pdev));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmsleep(1);\n\t\t\toperationaldata = readl(base + YIOA_STATUS);\n\t\t}\n\t} else {\n\t\toperationaldata = readl(base + PSCRATCH3);\n\t\twhile (operationaldata != SS_MU_OPERATIONAL) {\n\t\t\tif (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {\n\t\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t\t\t\"(%s): firmware not operational\\n\",\n\t\t\t\t\tpci_name(hba->pdev));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmsleep(1);\n\t\t\toperationaldata = readl(base + PSCRATCH3);\n\t\t}\n\t}\n\n\tmsg_h = (struct st_msg_header *)hba->dma_mem;\n\tmsg_h->handle = cpu_to_le64(hba->dma_handle);\n\tmsg_h->flag = SS_HEAD_HANDSHAKE;\n\n\th = (struct handshake_frame *)(msg_h + 1);\n\th->rb_phy = cpu_to_le64(hba->dma_handle);\n\th->req_sz = cpu_to_le16(hba->rq_size);\n\th->req_cnt = cpu_to_le16(hba->rq_count+1);\n\th->status_sz = cpu_to_le16(sizeof(struct status_msg));\n\th->status_cnt = cpu_to_le16(hba->sts_count+1);\n\th->hosttime = cpu_to_le64(ktime_get_real_seconds());\n\th->partner_type = HMU_PARTNER_TYPE;\n\th->extra_offset = h->extra_size = 0;\n\tscratch_size = (hba->sts_count+1)*sizeof(u32);\n\th->scratch_size = cpu_to_le32(scratch_size);\n\n\tif (hba->cardtype == st_yel) {\n\t\tdata = readl(base + YINT_EN);\n\t\tdata &= ~4;\n\t\twritel(data, base + YINT_EN);\n\t\twritel((hba->dma_handle >> 16) >> 16, base + YH2I_REQ_HI);\n\t\treadl(base + YH2I_REQ_HI);\n\t\twritel(hba->dma_handle, base + YH2I_REQ);\n\t\treadl(base + YH2I_REQ);  \n\t} else {\n\t\tdata = readl(base + YINT_EN);\n\t\tdata &= ~(1 << 0);\n\t\tdata &= ~(1 << 2);\n\t\twritel(data, base + YINT_EN);\n\t\tif (hba->msi_lock == 0) {\n\t\t\t \n\t\t\twritel((1 << 6), base + YH2I_INT);\n\t\t\thba->msi_lock  = 1;\n\t\t}\n\t\twritel((hba->dma_handle >> 16) >> 16, base + YH2I_REQ_HI);\n\t\twritel(hba->dma_handle, base + YH2I_REQ);\n\t}\n\n\tbefore = jiffies;\n\tscratch = hba->scratch;\n\tif (hba->cardtype == st_yel) {\n\t\twhile (!(le32_to_cpu(*scratch) & SS_STS_HANDSHAKE)) {\n\t\t\tif (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {\n\t\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t\t\t\"(%s): no signature after handshake frame\\n\",\n\t\t\t\t\tpci_name(hba->pdev));\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trmb();\n\t\t\tmsleep(1);\n\t\t}\n\t} else {\n\t\tmailboxdata = readl(base + MAILBOX_BASE + MAILBOX_HNDSHK_STS);\n\t\twhile (mailboxdata != SS_STS_HANDSHAKE) {\n\t\t\tif (time_after(jiffies, before + MU_MAX_DELAY * HZ)) {\n\t\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t\t\t\"(%s): no signature after handshake frame\\n\",\n\t\t\t\t\tpci_name(hba->pdev));\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trmb();\n\t\t\tmsleep(1);\n\t\t\tmailboxdata = readl(base + MAILBOX_BASE + MAILBOX_HNDSHK_STS);\n\t\t}\n\t}\n\tmemset(scratch, 0, scratch_size);\n\tmsg_h->flag = 0;\n\n\treturn ret;\n}\n\nstatic int stex_handshake(struct st_hba *hba)\n{\n\tint err;\n\tunsigned long flags;\n\tunsigned int mu_status;\n\n\tif (hba->cardtype == st_yel || hba->cardtype == st_P3)\n\t\terr = stex_ss_handshake(hba);\n\telse\n\t\terr = stex_common_handshake(hba);\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tmu_status = hba->mu_status;\n\tif (err == 0) {\n\t\thba->req_head = 0;\n\t\thba->req_tail = 0;\n\t\thba->status_head = 0;\n\t\thba->status_tail = 0;\n\t\thba->out_req_cnt = 0;\n\t\thba->mu_status = MU_STATE_STARTED;\n\t} else\n\t\thba->mu_status = MU_STATE_FAILED;\n\tif (mu_status == MU_STATE_RESETTING)\n\t\twake_up_all(&hba->reset_waitq);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\treturn err;\n}\n\nstatic int stex_abort(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct st_hba *hba = (struct st_hba *)host->hostdata;\n\tu16 tag = scsi_cmd_to_rq(cmd)->tag;\n\tvoid __iomem *base;\n\tu32 data;\n\tint result = SUCCESS;\n\tunsigned long flags;\n\n\tscmd_printk(KERN_INFO, cmd, \"aborting command\\n\");\n\n\tbase = hba->mmio_base;\n\tspin_lock_irqsave(host->host_lock, flags);\n\tif (tag < host->can_queue &&\n\t\thba->ccb[tag].req && hba->ccb[tag].cmd == cmd)\n\t\thba->wait_ccb = &hba->ccb[tag];\n\telse\n\t\tgoto out;\n\n\tif (hba->cardtype == st_yel) {\n\t\tdata = readl(base + YI2H_INT);\n\t\tif (data == 0 || data == 0xffffffff)\n\t\t\tgoto fail_out;\n\n\t\twritel(data, base + YI2H_INT_C);\n\t\tstex_ss_mu_intr(hba);\n\t} else if (hba->cardtype == st_P3) {\n\t\tdata = readl(base + PSCRATCH4);\n\t\tif (data == 0xffffffff)\n\t\t\tgoto fail_out;\n\t\tif (data != 0) {\n\t\t\twritel(data, base + PSCRATCH1);\n\t\t\twritel((1 << 22), base + YH2I_INT);\n\t\t}\n\t\tstex_ss_mu_intr(hba);\n\t} else {\n\t\tdata = readl(base + ODBL);\n\t\tif (data == 0 || data == 0xffffffff)\n\t\t\tgoto fail_out;\n\n\t\twritel(data, base + ODBL);\n\t\treadl(base + ODBL);  \n\t\tstex_mu_intr(hba, data);\n\t}\n\tif (hba->wait_ccb == NULL) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\"(%s): lost interrupt\\n\", pci_name(hba->pdev));\n\t\tgoto out;\n\t}\n\nfail_out:\n\tscsi_dma_unmap(cmd);\n\thba->wait_ccb->req = NULL;  \n\thba->wait_ccb = NULL;\n\tresult = FAILED;\nout:\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\treturn result;\n}\n\nstatic void stex_hard_reset(struct st_hba *hba)\n{\n\tstruct pci_bus *bus;\n\tint i;\n\tu16 pci_cmd;\n\tu8 pci_bctl;\n\n\tfor (i = 0; i < 16; i++)\n\t\tpci_read_config_dword(hba->pdev, i * 4,\n\t\t\t&hba->pdev->saved_config_space[i]);\n\n\t \n\tbus = hba->pdev->bus;\n\tpci_read_config_byte(bus->self, PCI_BRIDGE_CONTROL, &pci_bctl);\n\tpci_bctl |= PCI_BRIDGE_CTL_BUS_RESET;\n\tpci_write_config_byte(bus->self, PCI_BRIDGE_CONTROL, pci_bctl);\n\n\t \n\tmsleep(100);\n\tpci_bctl &= ~PCI_BRIDGE_CTL_BUS_RESET;\n\tpci_write_config_byte(bus->self, PCI_BRIDGE_CONTROL, pci_bctl);\n\n\tfor (i = 0; i < MU_HARD_RESET_WAIT; i++) {\n\t\tpci_read_config_word(hba->pdev, PCI_COMMAND, &pci_cmd);\n\t\tif (pci_cmd != 0xffff && (pci_cmd & PCI_COMMAND_MASTER))\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tssleep(5);\n\tfor (i = 0; i < 16; i++)\n\t\tpci_write_config_dword(hba->pdev, i * 4,\n\t\t\thba->pdev->saved_config_space[i]);\n}\n\nstatic int stex_yos_reset(struct st_hba *hba)\n{\n\tvoid __iomem *base;\n\tunsigned long flags, before;\n\tint ret = 0;\n\n\tbase = hba->mmio_base;\n\twritel(MU_INBOUND_DOORBELL_RESET, base + IDBL);\n\treadl(base + IDBL);  \n\tbefore = jiffies;\n\twhile (hba->out_req_cnt > 0) {\n\t\tif (time_after(jiffies, before + ST_INTERNAL_TIMEOUT * HZ)) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\t\"(%s): reset timeout\\n\", pci_name(hba->pdev));\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (ret == -1)\n\t\thba->mu_status = MU_STATE_FAILED;\n\telse\n\t\thba->mu_status = MU_STATE_STARTED;\n\twake_up_all(&hba->reset_waitq);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\treturn ret;\n}\n\nstatic void stex_ss_reset(struct st_hba *hba)\n{\n\twritel(SS_H2I_INT_RESET, hba->mmio_base + YH2I_INT);\n\treadl(hba->mmio_base + YH2I_INT);\n\tssleep(5);\n}\n\nstatic void stex_p3_reset(struct st_hba *hba)\n{\n\twritel(SS_H2I_INT_RESET, hba->mmio_base + YH2I_INT);\n\tssleep(5);\n}\n\nstatic int stex_do_reset(struct st_hba *hba)\n{\n\tunsigned long flags;\n\tunsigned int mu_status = MU_STATE_RESETTING;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\tif (hba->mu_status == MU_STATE_STARTING) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\tprintk(KERN_INFO DRV_NAME \"(%s): request reset during init\\n\",\n\t\t\tpci_name(hba->pdev));\n\t\treturn 0;\n\t}\n\twhile (hba->mu_status == MU_STATE_RESETTING) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\twait_event_timeout(hba->reset_waitq,\n\t\t\t\t   hba->mu_status != MU_STATE_RESETTING,\n\t\t\t\t   MU_MAX_DELAY * HZ);\n\t\tspin_lock_irqsave(hba->host->host_lock, flags);\n\t\tmu_status = hba->mu_status;\n\t}\n\n\tif (mu_status != MU_STATE_RESETTING) {\n\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\treturn (mu_status == MU_STATE_STARTED) ? 0 : -1;\n\t}\n\n\thba->mu_status = MU_STATE_RESETTING;\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\n\tif (hba->cardtype == st_yosemite)\n\t\treturn stex_yos_reset(hba);\n\n\tif (hba->cardtype == st_shasta)\n\t\tstex_hard_reset(hba);\n\telse if (hba->cardtype == st_yel)\n\t\tstex_ss_reset(hba);\n\telse if (hba->cardtype == st_P3)\n\t\tstex_p3_reset(hba);\n\n\treturn_abnormal_state(hba, DID_RESET);\n\n\tif (stex_handshake(hba) == 0)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING DRV_NAME \"(%s): resetting: handshake failed\\n\",\n\t\tpci_name(hba->pdev));\n\treturn -1;\n}\n\nstatic int stex_reset(struct scsi_cmnd *cmd)\n{\n\tstruct st_hba *hba;\n\n\thba = (struct st_hba *) &cmd->device->host->hostdata[0];\n\n\tshost_printk(KERN_INFO, cmd->device->host,\n\t\t     \"resetting host\\n\");\n\n\treturn stex_do_reset(hba) ? FAILED : SUCCESS;\n}\n\nstatic void stex_reset_work(struct work_struct *work)\n{\n\tstruct st_hba *hba = container_of(work, struct st_hba, reset_work);\n\n\tstex_do_reset(hba);\n}\n\nstatic int stex_biosparam(struct scsi_device *sdev,\n\tstruct block_device *bdev, sector_t capacity, int geom[])\n{\n\tint heads = 255, sectors = 63;\n\n\tif (capacity < 0x200000) {\n\t\theads = 64;\n\t\tsectors = 32;\n\t}\n\n\tsector_div(capacity, heads * sectors);\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = capacity;\n\n\treturn 0;\n}\n\nstatic const struct scsi_host_template driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= DRV_NAME,\n\t.proc_name\t\t\t= DRV_NAME,\n\t.bios_param\t\t\t= stex_biosparam,\n\t.queuecommand\t\t\t= stex_queuecommand,\n\t.slave_configure\t\t= stex_slave_config,\n\t.eh_abort_handler\t\t= stex_abort,\n\t.eh_host_reset_handler\t\t= stex_reset,\n\t.this_id\t\t\t= -1,\n\t.dma_boundary\t\t\t= PAGE_SIZE - 1,\n};\n\nstatic struct pci_device_id stex_pci_tbl[] = {\n\t \n\t{ 0x105a, 0x8350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\tst_shasta },  \n\t{ 0x105a, 0xc350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\tst_shasta },  \n\t{ 0x105a, 0x4302, PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\tst_shasta },  \n\t{ 0x105a, 0xe350, PCI_ANY_ID, PCI_ANY_ID, 0, 0,\n\t\tst_shasta },  \n\n\t \n\t{ 0x105a, 0x7250, PCI_ANY_ID, PCI_ANY_ID, 0, 0, st_vsc },\n\n\t \n\t{ 0x105a, 0x8650, 0x105a, PCI_ANY_ID, 0, 0, st_yosemite },\n\n\t \n\t{ 0x105a, 0x3360, PCI_ANY_ID, PCI_ANY_ID, 0, 0, st_seq },\n\n\t \n\t{ 0x105a, 0x8650, 0x1033, PCI_ANY_ID, 0, 0, st_yel },\n\t{ 0x105a, 0x8760, PCI_ANY_ID, PCI_ANY_ID, 0, 0, st_yel },\n\n\t \n\t{ PCI_VENDOR_ID_PROMISE, 0x8870, PCI_VENDOR_ID_PROMISE,\n\t\t0x8870, 0, 0, st_P3 },\n\t \n\t{ PCI_VENDOR_ID_PROMISE, 0x8870, PCI_VENDOR_ID_PROMISE,\n\t\t0x4300, 0, 0, st_P3 },\n\n\t \n\t{ PCI_VENDOR_ID_PROMISE, 0x8871, PCI_VENDOR_ID_PROMISE,\n\t\t0x4311, 0, 0, st_P3 },\n\t \n\t{ PCI_VENDOR_ID_PROMISE, 0x8871, PCI_VENDOR_ID_PROMISE,\n\t\t0x4312, 0, 0, st_P3 },\n\t \n\t{ PCI_VENDOR_ID_PROMISE, 0x8871, PCI_VENDOR_ID_PROMISE,\n\t\t0x4321, 0, 0, st_P3 },\n\t \n\t{ PCI_VENDOR_ID_PROMISE, 0x8871, PCI_VENDOR_ID_PROMISE,\n\t\t0x4322, 0, 0, st_P3 },\n\t{ }\t \n};\n\nstatic struct st_card_info stex_card_info[] = {\n\t \n\t{\n\t\t.max_id\t\t= 17,\n\t\t.max_lun\t= 8,\n\t\t.max_channel\t= 0,\n\t\t.rq_count\t= 32,\n\t\t.rq_size\t= 1048,\n\t\t.sts_count\t= 32,\n\t\t.alloc_rq\t= stex_alloc_req,\n\t\t.map_sg\t\t= stex_map_sg,\n\t\t.send\t\t= stex_send_cmd,\n\t},\n\n\t \n\t{\n\t\t.max_id\t\t= 129,\n\t\t.max_lun\t= 1,\n\t\t.max_channel\t= 0,\n\t\t.rq_count\t= 32,\n\t\t.rq_size\t= 1048,\n\t\t.sts_count\t= 32,\n\t\t.alloc_rq\t= stex_alloc_req,\n\t\t.map_sg\t\t= stex_map_sg,\n\t\t.send\t\t= stex_send_cmd,\n\t},\n\n\t \n\t{\n\t\t.max_id\t\t= 2,\n\t\t.max_lun\t= 256,\n\t\t.max_channel\t= 0,\n\t\t.rq_count\t= 256,\n\t\t.rq_size\t= 1048,\n\t\t.sts_count\t= 256,\n\t\t.alloc_rq\t= stex_alloc_req,\n\t\t.map_sg\t\t= stex_map_sg,\n\t\t.send\t\t= stex_send_cmd,\n\t},\n\n\t \n\t{\n\t\t.max_id\t\t= 129,\n\t\t.max_lun\t= 1,\n\t\t.max_channel\t= 0,\n\t\t.rq_count\t= 32,\n\t\t.rq_size\t= 1048,\n\t\t.sts_count\t= 32,\n\t\t.alloc_rq\t= stex_alloc_req,\n\t\t.map_sg\t\t= stex_map_sg,\n\t\t.send\t\t= stex_send_cmd,\n\t},\n\n\t \n\t{\n\t\t.max_id\t\t= 129,\n\t\t.max_lun\t= 256,\n\t\t.max_channel\t= 3,\n\t\t.rq_count\t= 801,\n\t\t.rq_size\t= 512,\n\t\t.sts_count\t= 801,\n\t\t.alloc_rq\t= stex_ss_alloc_req,\n\t\t.map_sg\t\t= stex_ss_map_sg,\n\t\t.send\t\t= stex_ss_send_cmd,\n\t},\n\n\t \n\t{\n\t\t.max_id\t\t= 129,\n\t\t.max_lun\t= 256,\n\t\t.max_channel\t= 0,\n\t\t.rq_count\t= 801,\n\t\t.rq_size\t= 512,\n\t\t.sts_count\t= 801,\n\t\t.alloc_rq\t= stex_ss_alloc_req,\n\t\t.map_sg\t\t= stex_ss_map_sg,\n\t\t.send\t\t= stex_ss_send_cmd,\n\t},\n};\n\nstatic int stex_request_irq(struct st_hba *hba)\n{\n\tstruct pci_dev *pdev = hba->pdev;\n\tint status;\n\n\tif (msi || hba->cardtype == st_P3) {\n\t\tstatus = pci_enable_msi(pdev);\n\t\tif (status != 0)\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t\t\"(%s): error %d setting up MSI\\n\",\n\t\t\t\tpci_name(pdev), status);\n\t\telse\n\t\t\thba->msi_enabled = 1;\n\t} else\n\t\thba->msi_enabled = 0;\n\n\tstatus = request_irq(pdev->irq,\n\t\t(hba->cardtype == st_yel || hba->cardtype == st_P3) ?\n\t\tstex_ss_intr : stex_intr, IRQF_SHARED, DRV_NAME, hba);\n\n\tif (status != 0) {\n\t\tif (hba->msi_enabled)\n\t\t\tpci_disable_msi(pdev);\n\t}\n\treturn status;\n}\n\nstatic void stex_free_irq(struct st_hba *hba)\n{\n\tstruct pci_dev *pdev = hba->pdev;\n\n\tfree_irq(pdev->irq, hba);\n\tif (hba->msi_enabled)\n\t\tpci_disable_msi(pdev);\n}\n\nstatic int stex_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct st_hba *hba;\n\tstruct Scsi_Host *host;\n\tconst struct st_card_info *ci = NULL;\n\tu32 sts_offset, cp_offset, scratch_offset;\n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\tpci_set_master(pdev);\n\n\tS6flag = 0;\n\tregister_reboot_notifier(&stex_notifier);\n\n\thost = scsi_host_alloc(&driver_template, sizeof(struct st_hba));\n\n\tif (!host) {\n\t\tprintk(KERN_ERR DRV_NAME \"(%s): scsi_host_alloc failed\\n\",\n\t\t\tpci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto out_disable;\n\t}\n\n\thba = (struct st_hba *)host->hostdata;\n\tmemset(hba, 0, sizeof(struct st_hba));\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR DRV_NAME \"(%s): request regions failed\\n\",\n\t\t\tpci_name(pdev));\n\t\tgoto out_scsi_host_put;\n\t}\n\n\thba->mmio_base = pci_ioremap_bar(pdev, 0);\n\tif ( !hba->mmio_base) {\n\t\tprintk(KERN_ERR DRV_NAME \"(%s): memory map failed\\n\",\n\t\t\tpci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err)\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \"(%s): set dma mask failed\\n\",\n\t\t\tpci_name(pdev));\n\t\tgoto out_iounmap;\n\t}\n\n\thba->cardtype = (unsigned int) id->driver_data;\n\tci = &stex_card_info[hba->cardtype];\n\tswitch (id->subdevice) {\n\tcase 0x4221:\n\tcase 0x4222:\n\tcase 0x4223:\n\tcase 0x4224:\n\tcase 0x4225:\n\tcase 0x4226:\n\tcase 0x4227:\n\tcase 0x4261:\n\tcase 0x4262:\n\tcase 0x4263:\n\tcase 0x4264:\n\tcase 0x4265:\n\t\tbreak;\n\tdefault:\n\t\tif (hba->cardtype == st_yel || hba->cardtype == st_P3)\n\t\t\thba->supports_pm = 1;\n\t}\n\n\tsts_offset = scratch_offset = (ci->rq_count+1) * ci->rq_size;\n\tif (hba->cardtype == st_yel || hba->cardtype == st_P3)\n\t\tsts_offset += (ci->sts_count+1) * sizeof(u32);\n\tcp_offset = sts_offset + (ci->sts_count+1) * sizeof(struct status_msg);\n\thba->dma_size = cp_offset + sizeof(struct st_frame);\n\tif (hba->cardtype == st_seq ||\n\t\t(hba->cardtype == st_vsc && (pdev->subsystem_device & 1))) {\n\t\thba->extra_offset = hba->dma_size;\n\t\thba->dma_size += ST_ADDITIONAL_MEM;\n\t}\n\thba->dma_mem = dma_alloc_coherent(&pdev->dev,\n\t\thba->dma_size, &hba->dma_handle, GFP_KERNEL);\n\tif (!hba->dma_mem) {\n\t\t \n\t\tif (hba->cardtype == st_seq ||\n\t\t    (hba->cardtype == st_vsc && (pdev->subsystem_device & 1))) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t\t\"(%s): allocating min buffer for controller\\n\",\n\t\t\t\tpci_name(pdev));\n\t\t\thba->dma_size = hba->extra_offset\n\t\t\t\t+ ST_ADDITIONAL_MEM_MIN;\n\t\t\thba->dma_mem = dma_alloc_coherent(&pdev->dev,\n\t\t\t\thba->dma_size, &hba->dma_handle, GFP_KERNEL);\n\t\t}\n\n\t\tif (!hba->dma_mem) {\n\t\t\terr = -ENOMEM;\n\t\t\tprintk(KERN_ERR DRV_NAME \"(%s): dma mem alloc failed\\n\",\n\t\t\t\tpci_name(pdev));\n\t\t\tgoto out_iounmap;\n\t\t}\n\t}\n\n\thba->ccb = kcalloc(ci->rq_count, sizeof(struct st_ccb), GFP_KERNEL);\n\tif (!hba->ccb) {\n\t\terr = -ENOMEM;\n\t\tprintk(KERN_ERR DRV_NAME \"(%s): ccb alloc failed\\n\",\n\t\t\tpci_name(pdev));\n\t\tgoto out_pci_free;\n\t}\n\n\tif (hba->cardtype == st_yel || hba->cardtype == st_P3)\n\t\thba->scratch = (__le32 *)(hba->dma_mem + scratch_offset);\n\thba->status_buffer = (struct status_msg *)(hba->dma_mem + sts_offset);\n\thba->copy_buffer = hba->dma_mem + cp_offset;\n\thba->rq_count = ci->rq_count;\n\thba->rq_size = ci->rq_size;\n\thba->sts_count = ci->sts_count;\n\thba->alloc_rq = ci->alloc_rq;\n\thba->map_sg = ci->map_sg;\n\thba->send = ci->send;\n\thba->mu_status = MU_STATE_STARTING;\n\thba->msi_lock = 0;\n\n\tif (hba->cardtype == st_yel || hba->cardtype == st_P3)\n\t\thost->sg_tablesize = 38;\n\telse\n\t\thost->sg_tablesize = 32;\n\thost->can_queue = ci->rq_count;\n\thost->cmd_per_lun = ci->rq_count;\n\thost->max_id = ci->max_id;\n\thost->max_lun = ci->max_lun;\n\thost->max_channel = ci->max_channel;\n\thost->unique_id = host->host_no;\n\thost->max_cmd_len = STEX_CDB_LENGTH;\n\n\thba->host = host;\n\thba->pdev = pdev;\n\tinit_waitqueue_head(&hba->reset_waitq);\n\n\tsnprintf(hba->work_q_name, sizeof(hba->work_q_name),\n\t\t \"stex_wq_%d\", host->host_no);\n\thba->work_q = create_singlethread_workqueue(hba->work_q_name);\n\tif (!hba->work_q) {\n\t\tprintk(KERN_ERR DRV_NAME \"(%s): create workqueue failed\\n\",\n\t\t\tpci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto out_ccb_free;\n\t}\n\tINIT_WORK(&hba->reset_work, stex_reset_work);\n\n\terr = stex_request_irq(hba);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \"(%s): request irq failed\\n\",\n\t\t\tpci_name(pdev));\n\t\tgoto out_free_wq;\n\t}\n\n\terr = stex_handshake(hba);\n\tif (err)\n\t\tgoto out_free_irq;\n\n\tpci_set_drvdata(pdev, hba);\n\n\terr = scsi_add_host(host, &pdev->dev);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \"(%s): scsi_add_host failed\\n\",\n\t\t\tpci_name(pdev));\n\t\tgoto out_free_irq;\n\t}\n\n\tscsi_scan_host(host);\n\n\treturn 0;\n\nout_free_irq:\n\tstex_free_irq(hba);\nout_free_wq:\n\tdestroy_workqueue(hba->work_q);\nout_ccb_free:\n\tkfree(hba->ccb);\nout_pci_free:\n\tdma_free_coherent(&pdev->dev, hba->dma_size,\n\t\t\t  hba->dma_mem, hba->dma_handle);\nout_iounmap:\n\tiounmap(hba->mmio_base);\nout_release_regions:\n\tpci_release_regions(pdev);\nout_scsi_host_put:\n\tscsi_host_put(host);\nout_disable:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void stex_hba_stop(struct st_hba *hba, int st_sleep_mic)\n{\n\tstruct req_msg *req;\n\tstruct st_msg_header *msg_h;\n\tunsigned long flags;\n\tunsigned long before;\n\tu16 tag = 0;\n\n\tspin_lock_irqsave(hba->host->host_lock, flags);\n\n\tif ((hba->cardtype == st_yel || hba->cardtype == st_P3) &&\n\t\thba->supports_pm == 1) {\n\t\tif (st_sleep_mic == ST_NOTHANDLED) {\n\t\t\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\treq = hba->alloc_rq(hba);\n\tif (hba->cardtype == st_yel || hba->cardtype == st_P3) {\n\t\tmsg_h = (struct st_msg_header *)req - 1;\n\t\tmemset(msg_h, 0, hba->rq_size);\n\t} else\n\t\tmemset(req, 0, hba->rq_size);\n\n\tif ((hba->cardtype == st_yosemite || hba->cardtype == st_yel\n\t\t|| hba->cardtype == st_P3)\n\t\t&& st_sleep_mic == ST_IGNORED) {\n\t\treq->cdb[0] = MGT_CMD;\n\t\treq->cdb[1] = MGT_CMD_SIGNATURE;\n\t\treq->cdb[2] = CTLR_CONFIG_CMD;\n\t\treq->cdb[3] = CTLR_SHUTDOWN;\n\t} else if ((hba->cardtype == st_yel || hba->cardtype == st_P3)\n\t\t&& st_sleep_mic != ST_IGNORED) {\n\t\treq->cdb[0] = MGT_CMD;\n\t\treq->cdb[1] = MGT_CMD_SIGNATURE;\n\t\treq->cdb[2] = CTLR_CONFIG_CMD;\n\t\treq->cdb[3] = PMIC_SHUTDOWN;\n\t\treq->cdb[4] = st_sleep_mic;\n\t} else {\n\t\treq->cdb[0] = CONTROLLER_CMD;\n\t\treq->cdb[1] = CTLR_POWER_STATE_CHANGE;\n\t\treq->cdb[2] = CTLR_POWER_SAVING;\n\t}\n\thba->ccb[tag].cmd = NULL;\n\thba->ccb[tag].sg_count = 0;\n\thba->ccb[tag].sense_bufflen = 0;\n\thba->ccb[tag].sense_buffer = NULL;\n\thba->ccb[tag].req_type = PASSTHRU_REQ_TYPE;\n\thba->send(hba, req, tag);\n\tspin_unlock_irqrestore(hba->host->host_lock, flags);\n\tbefore = jiffies;\n\twhile (hba->ccb[tag].req_type & PASSTHRU_REQ_TYPE) {\n\t\tif (time_after(jiffies, before + ST_INTERNAL_TIMEOUT * HZ)) {\n\t\t\thba->ccb[tag].req_type = 0;\n\t\t\thba->mu_status = MU_STATE_STOP;\n\t\t\treturn;\n\t\t}\n\t\tmsleep(1);\n\t}\n\thba->mu_status = MU_STATE_STOP;\n}\n\nstatic void stex_hba_free(struct st_hba *hba)\n{\n\tstex_free_irq(hba);\n\n\tdestroy_workqueue(hba->work_q);\n\n\tiounmap(hba->mmio_base);\n\n\tpci_release_regions(hba->pdev);\n\n\tkfree(hba->ccb);\n\n\tdma_free_coherent(&hba->pdev->dev, hba->dma_size,\n\t\t\t  hba->dma_mem, hba->dma_handle);\n}\n\nstatic void stex_remove(struct pci_dev *pdev)\n{\n\tstruct st_hba *hba = pci_get_drvdata(pdev);\n\n\thba->mu_status = MU_STATE_NOCONNECT;\n\treturn_abnormal_state(hba, DID_NO_CONNECT);\n\tscsi_remove_host(hba->host);\n\n\tscsi_block_requests(hba->host);\n\n\tstex_hba_free(hba);\n\n\tscsi_host_put(hba->host);\n\n\tpci_disable_device(pdev);\n\n\tunregister_reboot_notifier(&stex_notifier);\n}\n\nstatic void stex_shutdown(struct pci_dev *pdev)\n{\n\tstruct st_hba *hba = pci_get_drvdata(pdev);\n\n\tif (hba->supports_pm == 0) {\n\t\tstex_hba_stop(hba, ST_IGNORED);\n\t} else if (hba->supports_pm == 1 && S6flag) {\n\t\tunregister_reboot_notifier(&stex_notifier);\n\t\tstex_hba_stop(hba, ST_S6);\n\t} else\n\t\tstex_hba_stop(hba, ST_S5);\n}\n\nstatic int stex_choice_sleep_mic(struct st_hba *hba, pm_message_t state)\n{\n\tswitch (state.event) {\n\tcase PM_EVENT_SUSPEND:\n\t\treturn ST_S3;\n\tcase PM_EVENT_HIBERNATE:\n\t\thba->msi_lock = 0;\n\t\treturn ST_S4;\n\tdefault:\n\t\treturn ST_NOTHANDLED;\n\t}\n}\n\nstatic int stex_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct st_hba *hba = pci_get_drvdata(pdev);\n\n\tif ((hba->cardtype == st_yel || hba->cardtype == st_P3)\n\t\t&& hba->supports_pm == 1)\n\t\tstex_hba_stop(hba, stex_choice_sleep_mic(hba, state));\n\telse\n\t\tstex_hba_stop(hba, ST_IGNORED);\n\treturn 0;\n}\n\nstatic int stex_resume(struct pci_dev *pdev)\n{\n\tstruct st_hba *hba = pci_get_drvdata(pdev);\n\n\thba->mu_status = MU_STATE_STARTING;\n\tstex_handshake(hba);\n\treturn 0;\n}\n\nstatic int stex_halt(struct notifier_block *nb, unsigned long event, void *buf)\n{\n\tS6flag = 1;\n\treturn NOTIFY_OK;\n}\nMODULE_DEVICE_TABLE(pci, stex_pci_tbl);\n\nstatic struct pci_driver stex_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= stex_pci_tbl,\n\t.probe\t\t= stex_probe,\n\t.remove\t\t= stex_remove,\n\t.shutdown\t= stex_shutdown,\n\t.suspend\t= stex_suspend,\n\t.resume\t\t= stex_resume,\n};\n\nstatic int __init stex_init(void)\n{\n\tprintk(KERN_INFO DRV_NAME\n\t\t\": Promise SuperTrak EX Driver version: %s\\n\",\n\t\t ST_DRIVER_VERSION);\n\n\treturn pci_register_driver(&stex_pci_driver);\n}\n\nstatic void __exit stex_exit(void)\n{\n\tpci_unregister_driver(&stex_pci_driver);\n}\n\nmodule_init(stex_init);\nmodule_exit(stex_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}