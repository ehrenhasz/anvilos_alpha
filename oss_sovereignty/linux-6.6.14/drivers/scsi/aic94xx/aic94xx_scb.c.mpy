{
  "module_name": "aic94xx_scb.c",
  "hash_id": "30d69dcb88df25898bbbc13d54d207a4c739ea62244d7a53588925607ddef77c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_scb.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <scsi/scsi_host.h>\n\n#include \"aic94xx.h\"\n#include \"aic94xx_reg.h\"\n#include \"aic94xx_hwi.h\"\n#include \"aic94xx_seq.h\"\n\n#include \"aic94xx_dump.h\"\n\n \n\n#define DL_PHY_MASK      7\n#define BYTES_DMAED      0\n#define PRIMITIVE_RECVD  0x08\n#define PHY_EVENT        0x10\n#define LINK_RESET_ERROR 0x18\n#define TIMER_EVENT      0x20\n#define REQ_TASK_ABORT   0xF0\n#define REQ_DEVICE_RESET 0xF1\n#define SIGNAL_NCQ_ERROR 0xF2\n#define CLEAR_NCQ_ERROR  0xF3\n\n#define PHY_EVENTS_STATUS (CURRENT_LOSS_OF_SIGNAL | CURRENT_OOB_DONE   \\\n\t\t\t   | CURRENT_SPINUP_HOLD | CURRENT_GTO_TIMEOUT \\\n\t\t\t   | CURRENT_OOB_ERROR)\n\nstatic void get_lrate_mode(struct asd_phy *phy, u8 oob_mode)\n{\n\tstruct sas_phy *sas_phy = phy->sas_phy.phy;\n\n\tswitch (oob_mode & 7) {\n\tcase PHY_SPEED_60:\n\t\t \n\t\tphy->sas_phy.linkrate = SAS_LINK_RATE_6_0_GBPS;\n\t\tphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_6_0_GBPS;\n\t\tbreak;\n\tcase PHY_SPEED_30:\n\t\tphy->sas_phy.linkrate = SAS_LINK_RATE_3_0_GBPS;\n\t\tphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_3_0_GBPS;\n\t\tbreak;\n\tcase PHY_SPEED_15:\n\t\tphy->sas_phy.linkrate = SAS_LINK_RATE_1_5_GBPS;\n\t\tphy->sas_phy.phy->negotiated_linkrate = SAS_LINK_RATE_1_5_GBPS;\n\t\tbreak;\n\t}\n\tsas_phy->negotiated_linkrate = phy->sas_phy.linkrate;\n\tsas_phy->maximum_linkrate_hw = SAS_LINK_RATE_3_0_GBPS;\n\tsas_phy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\n\tsas_phy->maximum_linkrate = phy->phy_desc->max_sas_lrate;\n\tsas_phy->minimum_linkrate = phy->phy_desc->min_sas_lrate;\n\n\tif (oob_mode & SAS_MODE)\n\t\tphy->sas_phy.oob_mode = SAS_OOB_MODE;\n\telse if (oob_mode & SATA_MODE)\n\t\tphy->sas_phy.oob_mode = SATA_OOB_MODE;\n}\n\nstatic void asd_phy_event_tasklet(struct asd_ascb *ascb,\n\t\t\t\t\t struct done_list_struct *dl)\n{\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tint phy_id = dl->status_block[0] & DL_PHY_MASK;\n\tstruct asd_phy *phy = &asd_ha->phys[phy_id];\n\n\tu8 oob_status = dl->status_block[1] & PHY_EVENTS_STATUS;\n\tu8 oob_mode   = dl->status_block[2];\n\n\tswitch (oob_status) {\n\tcase CURRENT_LOSS_OF_SIGNAL:\n\t\t \n\t\tASD_DPRINTK(\"phy%d: device unplugged\\n\", phy_id);\n\t\tasd_turn_led(asd_ha, phy_id, 0);\n\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_LOSS_OF_SIGNAL,\n\t\t\t\t     GFP_ATOMIC);\n\t\tbreak;\n\tcase CURRENT_OOB_DONE:\n\t\t \n\t\tasd_turn_led(asd_ha, phy_id, 1);\n\t\tget_lrate_mode(phy, oob_mode);\n\t\tASD_DPRINTK(\"phy%d device plugged: lrate:0x%x, proto:0x%x\\n\",\n\t\t\t    phy_id, phy->sas_phy.linkrate, phy->sas_phy.iproto);\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_OOB_DONE, GFP_ATOMIC);\n\t\tbreak;\n\tcase CURRENT_SPINUP_HOLD:\n\t\t \n\t\tasd_turn_led(asd_ha, phy_id, 1);\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_SPINUP_HOLD,\n\t\t\t\t     GFP_ATOMIC);\n\t\tbreak;\n\tcase CURRENT_GTO_TIMEOUT:\n\tcase CURRENT_OOB_ERROR:\n\t\tASD_DPRINTK(\"phy%d error while OOB: oob status:0x%x\\n\", phy_id,\n\t\t\t    dl->status_block[1]);\n\t\tasd_turn_led(asd_ha, phy_id, 0);\n\t\tsas_phy_disconnected(&phy->sas_phy);\n\t\tsas_notify_phy_event(&phy->sas_phy, PHYE_OOB_ERROR, GFP_ATOMIC);\n\t\tbreak;\n\t}\n}\n\n \nstatic unsigned ord_phy(struct asd_ha_struct *asd_ha, struct asd_phy *phy)\n{\n\tu8 enabled_mask = asd_ha->hw_prof.enabled_phys;\n\tint i, k = 0;\n\n\tfor_each_phy(enabled_mask, enabled_mask, i) {\n\t\tif (&asd_ha->phys[i] == phy)\n\t\t\treturn k;\n\t\tk++;\n\t}\n\treturn 0;\n}\n\n \nstatic void asd_get_attached_sas_addr(struct asd_phy *phy, u8 *sas_addr)\n{\n\tif (phy->sas_phy.frame_rcvd[0] == 0x34\n\t    && phy->sas_phy.oob_mode == SATA_OOB_MODE) {\n\t\tstruct asd_ha_struct *asd_ha = phy->sas_phy.ha->lldd_ha;\n\t\t \n\t\tu64 addr = be64_to_cpu(*(__be64 *)phy->phy_desc->sas_addr);\n\n\t\taddr += asd_ha->hw_prof.sata_name_base + ord_phy(asd_ha, phy);\n\t\t*(__be64 *)sas_addr = cpu_to_be64(addr);\n\t} else {\n\t\tstruct sas_identify_frame *idframe =\n\t\t\t(void *) phy->sas_phy.frame_rcvd;\n\t\tmemcpy(sas_addr, idframe->sas_addr, SAS_ADDR_SIZE);\n\t}\n}\n\nstatic void asd_form_port(struct asd_ha_struct *asd_ha, struct asd_phy *phy)\n{\n\tint i;\n\tstruct asd_port *free_port = NULL;\n\tstruct asd_port *port;\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->asd_ports_lock, flags);\n\tif (!phy->asd_port) {\n\t\tfor (i = 0; i < ASD_MAX_PHYS; i++) {\n\t\t\tport = &asd_ha->asd_ports[i];\n\n\t\t\t \n\t\t\tif (port->num_phys > 0 &&\n\t\t\t    memcmp(port->sas_addr, sas_phy->sas_addr,\n\t\t\t\t   SAS_ADDR_SIZE) == 0 &&\n\t\t\t    memcmp(port->attached_sas_addr,\n\t\t\t\t   sas_phy->attached_sas_addr,\n\t\t\t\t   SAS_ADDR_SIZE) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (port->num_phys == 0 && free_port == NULL) {\n\t\t\t\tfree_port = port;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i >= ASD_MAX_PHYS) {\n\t\t\tport = free_port;\n\t\t\tBUG_ON(!port);\n\t\t\tmemcpy(port->sas_addr, sas_phy->sas_addr,\n\t\t\t       SAS_ADDR_SIZE);\n\t\t\tmemcpy(port->attached_sas_addr,\n\t\t\t       sas_phy->attached_sas_addr,\n\t\t\t       SAS_ADDR_SIZE);\n\t\t}\n\t\tport->num_phys++;\n\t\tport->phy_mask |= (1U << sas_phy->id);\n\t\tphy->asd_port = port;\n\t}\n\tASD_DPRINTK(\"%s: updating phy_mask 0x%x for phy%d\\n\",\n\t\t    __func__, phy->asd_port->phy_mask, sas_phy->id);\n\tasd_update_port_links(asd_ha, phy);\n\tspin_unlock_irqrestore(&asd_ha->asd_ports_lock, flags);\n}\n\nstatic void asd_deform_port(struct asd_ha_struct *asd_ha, struct asd_phy *phy)\n{\n\tstruct asd_port *port = phy->asd_port;\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->asd_ports_lock, flags);\n\tif (port) {\n\t\tport->num_phys--;\n\t\tport->phy_mask &= ~(1U << sas_phy->id);\n\t\tphy->asd_port = NULL;\n\t}\n\tspin_unlock_irqrestore(&asd_ha->asd_ports_lock, flags);\n}\n\nstatic void asd_bytes_dmaed_tasklet(struct asd_ascb *ascb,\n\t\t\t\t    struct done_list_struct *dl,\n\t\t\t\t    int edb_id, int phy_id)\n{\n\tunsigned long flags;\n\tint edb_el = edb_id + ascb->edb_index;\n\tstruct asd_dma_tok *edb = ascb->ha->seq.edb_arr[edb_el];\n\tstruct asd_phy *phy = &ascb->ha->phys[phy_id];\n\tu16 size = ((dl->status_block[3] & 7) << 8) | dl->status_block[2];\n\n\tsize = min(size, (u16) sizeof(phy->frame_rcvd));\n\n\tspin_lock_irqsave(&phy->sas_phy.frame_rcvd_lock, flags);\n\tmemcpy(phy->sas_phy.frame_rcvd, edb->vaddr, size);\n\tphy->sas_phy.frame_rcvd_size = size;\n\tasd_get_attached_sas_addr(phy, phy->sas_phy.attached_sas_addr);\n\tspin_unlock_irqrestore(&phy->sas_phy.frame_rcvd_lock, flags);\n\tasd_dump_frame_rcvd(phy, dl);\n\tasd_form_port(ascb->ha, phy);\n\tsas_notify_port_event(&phy->sas_phy, PORTE_BYTES_DMAED, GFP_ATOMIC);\n}\n\nstatic void asd_link_reset_err_tasklet(struct asd_ascb *ascb,\n\t\t\t\t       struct done_list_struct *dl,\n\t\t\t\t       int phy_id)\n{\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tstruct sas_ha_struct *sas_ha = &asd_ha->sas_ha;\n\tstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\n\tstruct asd_phy *phy = &asd_ha->phys[phy_id];\n\tu8 lr_error = dl->status_block[1];\n\tu8 retries_left = dl->status_block[2];\n\n\tswitch (lr_error) {\n\tcase 0:\n\t\tASD_DPRINTK(\"phy%d: Receive ID timer expired\\n\", phy_id);\n\t\tbreak;\n\tcase 1:\n\t\tASD_DPRINTK(\"phy%d: Loss of signal\\n\", phy_id);\n\t\tbreak;\n\tcase 2:\n\t\tASD_DPRINTK(\"phy%d: Loss of dword sync\\n\", phy_id);\n\t\tbreak;\n\tcase 3:\n\t\tASD_DPRINTK(\"phy%d: Receive FIS timeout\\n\", phy_id);\n\t\tbreak;\n\tdefault:\n\t\tASD_DPRINTK(\"phy%d: unknown link reset error code: 0x%x\\n\",\n\t\t\t    phy_id, lr_error);\n\t\tbreak;\n\t}\n\n\tasd_turn_led(asd_ha, phy_id, 0);\n\tsas_phy_disconnected(sas_phy);\n\tasd_deform_port(asd_ha, phy);\n\tsas_notify_port_event(sas_phy, PORTE_LINK_RESET_ERR, GFP_ATOMIC);\n\n\tif (retries_left == 0) {\n\t\tint num = 1;\n\t\tstruct asd_ascb *cp = asd_ascb_alloc_list(ascb->ha, &num,\n\t\t\t\t\t\t\t  GFP_ATOMIC);\n\t\tif (!cp) {\n\t\t\tasd_printk(\"%s: out of memory\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tASD_DPRINTK(\"phy%d: retries:0 performing link reset seq\\n\",\n\t\t\t    phy_id);\n\t\tasd_build_control_phy(cp, phy_id, ENABLE_PHY);\n\t\tif (asd_post_ascb_list(ascb->ha, cp, 1) != 0)\n\t\t\tasd_ascb_free(cp);\n\t}\nout:\n\t;\n}\n\nstatic void asd_primitive_rcvd_tasklet(struct asd_ascb *ascb,\n\t\t\t\t       struct done_list_struct *dl,\n\t\t\t\t       int phy_id)\n{\n\tunsigned long flags;\n\tstruct sas_ha_struct *sas_ha = &ascb->ha->sas_ha;\n\tstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tstruct asd_phy *phy = &asd_ha->phys[phy_id];\n\tu8  reg  = dl->status_block[1];\n\tu32 cont = dl->status_block[2] << ((reg & 3)*8);\n\n\treg &= ~3;\n\tswitch (reg) {\n\tcase LmPRMSTAT0BYTE0:\n\t\tswitch (cont) {\n\t\tcase LmBROADCH:\n\t\tcase LmBROADRVCH0:\n\t\tcase LmBROADRVCH1:\n\t\tcase LmBROADSES:\n\t\t\tASD_DPRINTK(\"phy%d: BROADCAST change received:%d\\n\",\n\t\t\t\t    phy_id, cont);\n\t\t\tspin_lock_irqsave(&sas_phy->sas_prim_lock, flags);\n\t\t\tsas_phy->sas_prim = ffs(cont);\n\t\t\tspin_unlock_irqrestore(&sas_phy->sas_prim_lock, flags);\n\t\t\tsas_notify_port_event(sas_phy, PORTE_BROADCAST_RCVD,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tcase LmUNKNOWNP:\n\t\t\tASD_DPRINTK(\"phy%d: unknown BREAK\\n\", phy_id);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tASD_DPRINTK(\"phy%d: primitive reg:0x%x, cont:0x%04x\\n\",\n\t\t\t\t    phy_id, reg, cont);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase LmPRMSTAT1BYTE0:\n\t\tswitch (cont) {\n\t\tcase LmHARDRST:\n\t\t\tASD_DPRINTK(\"phy%d: HARD_RESET primitive rcvd\\n\",\n\t\t\t\t    phy_id);\n\t\t\t \n\t\t\tasd_deform_port(asd_ha, phy);\n\t\t\tsas_notify_port_event(sas_phy, PORTE_HARD_RESET,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tASD_DPRINTK(\"phy%d: primitive reg:0x%x, cont:0x%04x\\n\",\n\t\t\t\t    phy_id, reg, cont);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASD_DPRINTK(\"unknown primitive register:0x%x\\n\",\n\t\t\t    dl->status_block[1]);\n\t\tbreak;\n\t}\n}\n\n \nvoid asd_invalidate_edb(struct asd_ascb *ascb, int edb_id)\n{\n\tstruct asd_seq_data *seq = &ascb->ha->seq;\n\tstruct empty_scb *escb = &ascb->scb->escb;\n\tstruct sg_el     *eb   = &escb->eb[edb_id];\n\tstruct asd_dma_tok *edb = seq->edb_arr[ascb->edb_index + edb_id];\n\n\tmemset(edb->vaddr, 0, ASD_EDB_SIZE);\n\teb->flags |= ELEMENT_NOT_VALID;\n\tescb->num_valid--;\n\n\tif (escb->num_valid == 0) {\n\t\tint i;\n\t\t \n\t\tescb->num_valid = ASD_EDBS_PER_SCB;\n\t\tfor (i = 0; i < ASD_EDBS_PER_SCB; i++)\n\t\t\tescb->eb[i].flags = 0;\n\t\tif (!list_empty(&ascb->list))\n\t\t\tlist_del_init(&ascb->list);\n\t\ti = asd_post_escb_list(ascb->ha, ascb, 1);\n\t\tif (i)\n\t\t\tasd_printk(\"couldn't post escb, err:%d\\n\", i);\n\t}\n}\n\nstatic void escb_tasklet_complete(struct asd_ascb *ascb,\n\t\t\t\t  struct done_list_struct *dl)\n{\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tstruct sas_ha_struct *sas_ha = &asd_ha->sas_ha;\n\tint edb = (dl->opcode & DL_PHY_MASK) - 1;  \n\tu8  sb_opcode = dl->status_block[0];\n\tint phy_id = sb_opcode & DL_PHY_MASK;\n\tstruct asd_sas_phy *sas_phy = sas_ha->sas_phy[phy_id];\n\tstruct asd_phy *phy = &asd_ha->phys[phy_id];\n\n\tif (edb > 6 || edb < 0) {\n\t\tASD_DPRINTK(\"edb is 0x%x! dl->opcode is 0x%x\\n\",\n\t\t\t    edb, dl->opcode);\n\t\tASD_DPRINTK(\"sb_opcode : 0x%x, phy_id: 0x%x\\n\",\n\t\t\t    sb_opcode, phy_id);\n\t\tASD_DPRINTK(\"escb: vaddr: 0x%p, \"\n\t\t\t    \"dma_handle: 0x%llx, next: 0x%llx, \"\n\t\t\t    \"index:%d, opcode:0x%02x\\n\",\n\t\t\t    ascb->dma_scb.vaddr,\n\t\t\t    (unsigned long long)ascb->dma_scb.dma_handle,\n\t\t\t    (unsigned long long)\n\t\t\t    le64_to_cpu(ascb->scb->header.next_scb),\n\t\t\t    le16_to_cpu(ascb->scb->header.index),\n\t\t\t    ascb->scb->header.opcode);\n\t}\n\n\t \n\tswitch (sb_opcode) {\n\tcase REQ_TASK_ABORT: {\n\t\tstruct asd_ascb *a, *b;\n\t\tu16 tc_abort;\n\t\tstruct domain_device *failed_dev = NULL;\n\n\t\tASD_DPRINTK(\"%s: REQ_TASK_ABORT, reason=0x%X\\n\",\n\t\t\t    __func__, dl->status_block[3]);\n\n\t\t \n\t\ttc_abort = *((u16*)(&dl->status_block[1]));\n\t\ttc_abort = le16_to_cpu(tc_abort);\n\n\t\tlist_for_each_entry_safe(a, b, &asd_ha->seq.pend_q, list) {\n\t\t\tstruct sas_task *task = a->uldd_task;\n\n\t\t\tif (a->tc_index != tc_abort)\n\t\t\t\tcontinue;\n\n\t\t\tif (task) {\n\t\t\t\tfailed_dev = task->dev;\n\t\t\t\tsas_task_abort(task);\n\t\t\t} else {\n\t\t\t\tASD_DPRINTK(\"R_T_A for non TASK scb 0x%x\\n\",\n\t\t\t\t\t    a->scb->header.opcode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!failed_dev) {\n\t\t\tASD_DPRINTK(\"%s: Can't find task (tc=%d) to abort!\\n\",\n\t\t\t\t    __func__, tc_abort);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry_safe(a, b, &asd_ha->seq.pend_q, list) {\n\t\t\tstruct sas_task *task = a->uldd_task;\n\n\t\t\tif (task &&\n\t\t\t    task->dev == failed_dev &&\n\t\t\t    a->tc_index != tc_abort)\n\t\t\t\tsas_task_abort(task);\n\t\t}\n\n\t\tgoto out;\n\t}\n\tcase REQ_DEVICE_RESET: {\n\t\tstruct asd_ascb *a;\n\t\tu16 conn_handle;\n\t\tunsigned long flags;\n\t\tstruct sas_task *last_dev_task = NULL;\n\n\t\tconn_handle = *((u16*)(&dl->status_block[1]));\n\t\tconn_handle = le16_to_cpu(conn_handle);\n\n\t\tASD_DPRINTK(\"%s: REQ_DEVICE_RESET, reason=0x%X\\n\", __func__,\n\t\t\t    dl->status_block[3]);\n\n\t\t \n\t\tlist_for_each_entry(a, &asd_ha->seq.pend_q, list) {\n\t\t\tu16 x;\n\t\t\tstruct domain_device *dev;\n\t\t\tstruct sas_task *task = a->uldd_task;\n\n\t\t\tif (!task)\n\t\t\t\tcontinue;\n\t\t\tdev = task->dev;\n\n\t\t\tx = (unsigned long)dev->lldd_dev;\n\t\t\tif (x == conn_handle)\n\t\t\t\tlast_dev_task = task;\n\t\t}\n\n\t\tif (!last_dev_task) {\n\t\t\tASD_DPRINTK(\"%s: Device reset for idle device %d?\\n\",\n\t\t\t\t    __func__, conn_handle);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tspin_lock_irqsave(&last_dev_task->task_state_lock, flags);\n\t\tlast_dev_task->task_state_flags |= SAS_TASK_NEED_DEV_RESET;\n\t\tspin_unlock_irqrestore(&last_dev_task->task_state_lock, flags);\n\n\t\t \n\t\tlist_for_each_entry(a, &asd_ha->seq.pend_q, list) {\n\t\t\tu16 x;\n\t\t\tstruct domain_device *dev;\n\t\t\tstruct sas_task *task = a->uldd_task;\n\n\t\t\tif (!task)\n\t\t\t\tcontinue;\n\t\t\tdev = task->dev;\n\n\t\t\tx = (unsigned long)dev->lldd_dev;\n\t\t\tif (x == conn_handle)\n\t\t\t\tsas_task_abort(task);\n\t\t}\n\n\t\tgoto out;\n\t}\n\tcase SIGNAL_NCQ_ERROR:\n\t\tASD_DPRINTK(\"%s: SIGNAL_NCQ_ERROR\\n\", __func__);\n\t\tgoto out;\n\tcase CLEAR_NCQ_ERROR:\n\t\tASD_DPRINTK(\"%s: CLEAR_NCQ_ERROR\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tsb_opcode &= ~DL_PHY_MASK;\n\n\tswitch (sb_opcode) {\n\tcase BYTES_DMAED:\n\t\tASD_DPRINTK(\"%s: phy%d: BYTES_DMAED\\n\", __func__, phy_id);\n\t\tasd_bytes_dmaed_tasklet(ascb, dl, edb, phy_id);\n\t\tbreak;\n\tcase PRIMITIVE_RECVD:\n\t\tASD_DPRINTK(\"%s: phy%d: PRIMITIVE_RECVD\\n\", __func__,\n\t\t\t    phy_id);\n\t\tasd_primitive_rcvd_tasklet(ascb, dl, phy_id);\n\t\tbreak;\n\tcase PHY_EVENT:\n\t\tASD_DPRINTK(\"%s: phy%d: PHY_EVENT\\n\", __func__, phy_id);\n\t\tasd_phy_event_tasklet(ascb, dl);\n\t\tbreak;\n\tcase LINK_RESET_ERROR:\n\t\tASD_DPRINTK(\"%s: phy%d: LINK_RESET_ERROR\\n\", __func__,\n\t\t\t    phy_id);\n\t\tasd_link_reset_err_tasklet(ascb, dl, phy_id);\n\t\tbreak;\n\tcase TIMER_EVENT:\n\t\tASD_DPRINTK(\"%s: phy%d: TIMER_EVENT, lost dw sync\\n\",\n\t\t\t    __func__, phy_id);\n\t\tasd_turn_led(asd_ha, phy_id, 0);\n\t\t \n\t\tsas_phy_disconnected(sas_phy);\n\t\tasd_deform_port(asd_ha, phy);\n\t\tsas_notify_port_event(sas_phy, PORTE_TIMER_EVENT, GFP_ATOMIC);\n\t\tbreak;\n\tdefault:\n\t\tASD_DPRINTK(\"%s: phy%d: unknown event:0x%x\\n\", __func__,\n\t\t\t    phy_id, sb_opcode);\n\t\tASD_DPRINTK(\"edb is 0x%x! dl->opcode is 0x%x\\n\",\n\t\t\t    edb, dl->opcode);\n\t\tASD_DPRINTK(\"sb_opcode : 0x%x, phy_id: 0x%x\\n\",\n\t\t\t    sb_opcode, phy_id);\n\t\tASD_DPRINTK(\"escb: vaddr: 0x%p, \"\n\t\t\t    \"dma_handle: 0x%llx, next: 0x%llx, \"\n\t\t\t    \"index:%d, opcode:0x%02x\\n\",\n\t\t\t    ascb->dma_scb.vaddr,\n\t\t\t    (unsigned long long)ascb->dma_scb.dma_handle,\n\t\t\t    (unsigned long long)\n\t\t\t    le64_to_cpu(ascb->scb->header.next_scb),\n\t\t\t    le16_to_cpu(ascb->scb->header.index),\n\t\t\t    ascb->scb->header.opcode);\n\n\t\tbreak;\n\t}\nout:\n\tasd_invalidate_edb(ascb, edb);\n}\n\nint asd_init_post_escbs(struct asd_ha_struct *asd_ha)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tint i;\n\n\tfor (i = 0; i < seq->num_escbs; i++)\n\t\tseq->escb_arr[i]->tasklet_complete = escb_tasklet_complete;\n\n\tASD_DPRINTK(\"posting %d escbs\\n\", i);\n\treturn asd_post_escb_list(asd_ha, seq->escb_arr[0], seq->num_escbs);\n}\n\n \n\n#define CONTROL_PHY_STATUS (CURRENT_DEVICE_PRESENT | CURRENT_OOB_DONE   \\\n\t\t\t    | CURRENT_SPINUP_HOLD | CURRENT_GTO_TIMEOUT \\\n\t\t\t    | CURRENT_OOB_ERROR)\n\n \nstatic void control_phy_tasklet_complete(struct asd_ascb *ascb,\n\t\t\t\t\t struct done_list_struct *dl)\n{\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tstruct scb *scb = ascb->scb;\n\tstruct control_phy *control_phy = &scb->control_phy;\n\tu8 phy_id = control_phy->phy_id;\n\tstruct asd_phy *phy = &ascb->ha->phys[phy_id];\n\n\tu8 status     = dl->status_block[0];\n\tu8 oob_status = dl->status_block[1];\n\tu8 oob_mode   = dl->status_block[2];\n\t \n\n\tif (status != 0) {\n\t\tASD_DPRINTK(\"%s: phy%d status block opcode:0x%x\\n\",\n\t\t\t    __func__, phy_id, status);\n\t\tgoto out;\n\t}\n\n\tswitch (control_phy->sub_func) {\n\tcase DISABLE_PHY:\n\t\tasd_ha->hw_prof.enabled_phys &= ~(1 << phy_id);\n\t\tasd_turn_led(asd_ha, phy_id, 0);\n\t\tasd_control_led(asd_ha, phy_id, 0);\n\t\tASD_DPRINTK(\"%s: disable phy%d\\n\", __func__, phy_id);\n\t\tbreak;\n\n\tcase ENABLE_PHY:\n\t\tasd_control_led(asd_ha, phy_id, 1);\n\t\tif (oob_status & CURRENT_OOB_DONE) {\n\t\t\tasd_ha->hw_prof.enabled_phys |= (1 << phy_id);\n\t\t\tget_lrate_mode(phy, oob_mode);\n\t\t\tasd_turn_led(asd_ha, phy_id, 1);\n\t\t\tASD_DPRINTK(\"%s: phy%d, lrate:0x%x, proto:0x%x\\n\",\n\t\t\t\t    __func__, phy_id,phy->sas_phy.linkrate,\n\t\t\t\t    phy->sas_phy.iproto);\n\t\t} else if (oob_status & CURRENT_SPINUP_HOLD) {\n\t\t\tasd_ha->hw_prof.enabled_phys |= (1 << phy_id);\n\t\t\tasd_turn_led(asd_ha, phy_id, 1);\n\t\t\tASD_DPRINTK(\"%s: phy%d, spinup hold\\n\", __func__,\n\t\t\t\t    phy_id);\n\t\t} else if (oob_status & CURRENT_ERR_MASK) {\n\t\t\tasd_turn_led(asd_ha, phy_id, 0);\n\t\t\tASD_DPRINTK(\"%s: phy%d: error: oob status:0x%02x\\n\",\n\t\t\t\t    __func__, phy_id, oob_status);\n\t\t} else if (oob_status & (CURRENT_HOT_PLUG_CNCT\n\t\t\t\t\t | CURRENT_DEVICE_PRESENT))  {\n\t\t\tasd_ha->hw_prof.enabled_phys |= (1 << phy_id);\n\t\t\tasd_turn_led(asd_ha, phy_id, 1);\n\t\t\tASD_DPRINTK(\"%s: phy%d: hot plug or device present\\n\",\n\t\t\t\t    __func__, phy_id);\n\t\t} else {\n\t\t\tasd_ha->hw_prof.enabled_phys |= (1 << phy_id);\n\t\t\tasd_turn_led(asd_ha, phy_id, 0);\n\t\t\tASD_DPRINTK(\"%s: phy%d: no device present: \"\n\t\t\t\t    \"oob_status:0x%x\\n\",\n\t\t\t\t    __func__, phy_id, oob_status);\n\t\t}\n\t\tbreak;\n\tcase RELEASE_SPINUP_HOLD:\n\tcase PHY_NO_OP:\n\tcase EXECUTE_HARD_RESET:\n\t\tASD_DPRINTK(\"%s: phy%d: sub_func:0x%x\\n\", __func__,\n\t\t\t    phy_id, control_phy->sub_func);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tASD_DPRINTK(\"%s: phy%d: sub_func:0x%x?\\n\", __func__,\n\t\t\t    phy_id, control_phy->sub_func);\n\t\tbreak;\n\t}\nout:\n\tasd_ascb_free(ascb);\n}\n\nstatic void set_speed_mask(u8 *speed_mask, struct asd_phy_desc *pd)\n{\n\t \n\t*speed_mask = SAS_SPEED_60_DIS | SAS_SPEED_30_DIS | SAS_SPEED_15_DIS\n\t\t| SATA_SPEED_30_DIS | SATA_SPEED_15_DIS;\n\n\tswitch (pd->max_sas_lrate) {\n\tcase SAS_LINK_RATE_6_0_GBPS:\n\t\t*speed_mask &= ~SAS_SPEED_60_DIS;\n\t\tfallthrough;\n\tdefault:\n\tcase SAS_LINK_RATE_3_0_GBPS:\n\t\t*speed_mask &= ~SAS_SPEED_30_DIS;\n\t\tfallthrough;\n\tcase SAS_LINK_RATE_1_5_GBPS:\n\t\t*speed_mask &= ~SAS_SPEED_15_DIS;\n\t}\n\n\tswitch (pd->min_sas_lrate) {\n\tcase SAS_LINK_RATE_6_0_GBPS:\n\t\t*speed_mask |= SAS_SPEED_30_DIS;\n\t\tfallthrough;\n\tcase SAS_LINK_RATE_3_0_GBPS:\n\t\t*speed_mask |= SAS_SPEED_15_DIS;\n\t\tfallthrough;\n\tdefault:\n\tcase SAS_LINK_RATE_1_5_GBPS:\n\t\t \n\t\t;\n\t}\n\n\tswitch (pd->max_sata_lrate) {\n\tcase SAS_LINK_RATE_3_0_GBPS:\n\t\t*speed_mask &= ~SATA_SPEED_30_DIS;\n\t\tfallthrough;\n\tdefault:\n\tcase SAS_LINK_RATE_1_5_GBPS:\n\t\t*speed_mask &= ~SATA_SPEED_15_DIS;\n\t}\n\n\tswitch (pd->min_sata_lrate) {\n\tcase SAS_LINK_RATE_3_0_GBPS:\n\t\t*speed_mask |= SATA_SPEED_15_DIS;\n\t\tfallthrough;\n\tdefault:\n\tcase SAS_LINK_RATE_1_5_GBPS:\n\t\t \n\t\t;\n\t}\n}\n\n \nvoid asd_build_control_phy(struct asd_ascb *ascb, int phy_id, u8 subfunc)\n{\n\tstruct asd_phy *phy = &ascb->ha->phys[phy_id];\n\tstruct scb *scb = ascb->scb;\n\tstruct control_phy *control_phy = &scb->control_phy;\n\n\tscb->header.opcode = CONTROL_PHY;\n\tcontrol_phy->phy_id = (u8) phy_id;\n\tcontrol_phy->sub_func = subfunc;\n\n\tswitch (subfunc) {\n\tcase EXECUTE_HARD_RESET:   \n\tcase ENABLE_PHY:           \n\t\t \n\t\tcontrol_phy->hot_plug_delay = HOTPLUG_DELAY_TIMEOUT;\n\n\t\t \n\t\tset_speed_mask(&control_phy->speed_mask, phy->phy_desc);\n\n\t\t \n\t\tif (phy->sas_phy.role == PHY_ROLE_INITIATOR)\n\t\t\tcontrol_phy->port_type = SAS_PROTOCOL_ALL << 4;\n\t\telse if (phy->sas_phy.role == PHY_ROLE_TARGET)\n\t\t\tcontrol_phy->port_type = SAS_PROTOCOL_ALL;\n\t\telse\n\t\t\tcontrol_phy->port_type =\n\t\t\t\t(SAS_PROTOCOL_ALL << 4) | SAS_PROTOCOL_ALL;\n\n\t\t \n\t\tcontrol_phy->link_reset_retries = 10;\n\t\tfallthrough;\n\n\tcase RELEASE_SPINUP_HOLD:  \n\t\t \n\t\tcontrol_phy->func_mask = FUNCTION_MASK_DEFAULT;\n\t\tif (phy->phy_desc->flags & ASD_SATA_SPINUP_HOLD)\n\t\t\tcontrol_phy->func_mask &= ~SPINUP_HOLD_DIS;\n\t\telse\n\t\t\tcontrol_phy->func_mask |= SPINUP_HOLD_DIS;\n\t}\n\n\tcontrol_phy->conn_handle = cpu_to_le16(0xFFFF);\n\n\tascb->tasklet_complete = control_phy_tasklet_complete;\n}\n\n \n\n#if 0\n\nstatic void link_adm_tasklet_complete(struct asd_ascb *ascb,\n\t\t\t\t      struct done_list_struct *dl)\n{\n\tu8 opcode = dl->opcode;\n\tstruct initiate_link_adm *link_adm = &ascb->scb->link_adm;\n\tu8 phy_id = link_adm->phy_id;\n\n\tif (opcode != TC_NO_ERROR) {\n\t\tasd_printk(\"phy%d: link adm task 0x%x completed with error \"\n\t\t\t   \"0x%x\\n\", phy_id, link_adm->sub_func, opcode);\n\t}\n\tASD_DPRINTK(\"phy%d: link adm task 0x%x: 0x%x\\n\",\n\t\t    phy_id, link_adm->sub_func, opcode);\n\n\tasd_ascb_free(ascb);\n}\n\nvoid asd_build_initiate_link_adm_task(struct asd_ascb *ascb, int phy_id,\n\t\t\t\t      u8 subfunc)\n{\n\tstruct scb *scb = ascb->scb;\n\tstruct initiate_link_adm *link_adm = &scb->link_adm;\n\n\tscb->header.opcode = INITIATE_LINK_ADM_TASK;\n\n\tlink_adm->phy_id = phy_id;\n\tlink_adm->sub_func = subfunc;\n\tlink_adm->conn_handle = cpu_to_le16(0xFFFF);\n\n\tascb->tasklet_complete = link_adm_tasklet_complete;\n}\n\n#endif   \n\n \n\n \nvoid asd_ascb_timedout(struct timer_list *t)\n{\n\tstruct asd_ascb *ascb = from_timer(ascb, t, timer);\n\tstruct asd_seq_data *seq = &ascb->ha->seq;\n\tunsigned long flags;\n\n\tASD_DPRINTK(\"scb:0x%x timed out\\n\", ascb->scb->header.opcode);\n\n\tspin_lock_irqsave(&seq->pend_q_lock, flags);\n\tseq->pending--;\n\tlist_del_init(&ascb->list);\n\tspin_unlock_irqrestore(&seq->pend_q_lock, flags);\n\n\tasd_ascb_free(ascb);\n}\n\n \n\n \nstatic const int phy_func_table[] = {\n\t[PHY_FUNC_NOP]        = PHY_NO_OP,\n\t[PHY_FUNC_LINK_RESET] = ENABLE_PHY,\n\t[PHY_FUNC_HARD_RESET] = EXECUTE_HARD_RESET,\n\t[PHY_FUNC_DISABLE]    = DISABLE_PHY,\n\t[PHY_FUNC_RELEASE_SPINUP_HOLD] = RELEASE_SPINUP_HOLD,\n};\n\nint asd_control_phy(struct asd_sas_phy *phy, enum phy_func func, void *arg)\n{\n\tstruct asd_ha_struct *asd_ha = phy->ha->lldd_ha;\n\tstruct asd_phy_desc *pd = asd_ha->phys[phy->id].phy_desc;\n\tstruct asd_ascb *ascb;\n\tstruct sas_phy_linkrates *rates;\n\tint res = 1;\n\n\tswitch (func) {\n\tcase PHY_FUNC_CLEAR_ERROR_LOG:\n\tcase PHY_FUNC_GET_EVENTS:\n\t\treturn -ENOSYS;\n\tcase PHY_FUNC_SET_LINK_RATE:\n\t\trates = arg;\n\t\tif (rates->minimum_linkrate) {\n\t\t\tpd->min_sas_lrate = rates->minimum_linkrate;\n\t\t\tpd->min_sata_lrate = rates->minimum_linkrate;\n\t\t}\n\t\tif (rates->maximum_linkrate) {\n\t\t\tpd->max_sas_lrate = rates->maximum_linkrate;\n\t\t\tpd->max_sata_lrate = rates->maximum_linkrate;\n\t\t}\n\t\tfunc = PHY_FUNC_LINK_RESET;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tascb = asd_ascb_alloc_list(asd_ha, &res, GFP_KERNEL);\n\tif (!ascb)\n\t\treturn -ENOMEM;\n\n\tasd_build_control_phy(ascb, phy->id, phy_func_table[func]);\n\tres = asd_post_ascb_list(asd_ha, ascb , 1);\n\tif (res)\n\t\tasd_ascb_free(ascb);\n\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}