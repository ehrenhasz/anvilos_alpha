{
  "module_name": "aic94xx_tmf.c",
  "hash_id": "91317f17e6ffa3ec1634628be8d914d00a818adac2f2b347068afcffb6b05e9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_tmf.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/gfp.h>\n#include \"aic94xx.h\"\n#include \"aic94xx_sas.h\"\n#include \"aic94xx_hwi.h\"\n\n \n\nstatic int asd_enqueue_internal(struct asd_ascb *ascb,\n\t\tvoid (*tasklet_complete)(struct asd_ascb *,\n\t\t\t\t\t struct done_list_struct *),\n\t\t\t\tvoid (*timed_out)(struct timer_list *t))\n{\n\tint res;\n\n\tascb->tasklet_complete = tasklet_complete;\n\tascb->uldd_timer = 1;\n\n\tascb->timer.function = timed_out;\n\tascb->timer.expires = jiffies + AIC94XX_SCB_TIMEOUT;\n\n\tadd_timer(&ascb->timer);\n\n\tres = asd_post_ascb_list(ascb->ha, ascb, 1);\n\tif (unlikely(res))\n\t\tdel_timer(&ascb->timer);\n\treturn res;\n}\n\n \n\nstruct tasklet_completion_status {\n\tint\tdl_opcode;\n\tint\ttmf_state;\n\tu8\ttag_valid:1;\n\t__be16\ttag;\n};\n\n#define DECLARE_TCS(tcs) \\\n\tstruct tasklet_completion_status tcs = { \\\n\t\t.dl_opcode = 0, \\\n\t\t.tmf_state = 0, \\\n\t\t.tag_valid = 0, \\\n\t\t.tag = 0, \\\n\t}\n\n\nstatic void asd_clear_nexus_tasklet_complete(struct asd_ascb *ascb,\n\t\t\t\t\t     struct done_list_struct *dl)\n{\n\tstruct tasklet_completion_status *tcs = ascb->uldd_task;\n\tASD_DPRINTK(\"%s: here\\n\", __func__);\n\tif (!del_timer(&ascb->timer)) {\n\t\tASD_DPRINTK(\"%s: couldn't delete timer\\n\", __func__);\n\t\treturn;\n\t}\n\tASD_DPRINTK(\"%s: opcode: 0x%x\\n\", __func__, dl->opcode);\n\ttcs->dl_opcode = dl->opcode;\n\tcomplete(ascb->completion);\n\tasd_ascb_free(ascb);\n}\n\nstatic void asd_clear_nexus_timedout(struct timer_list *t)\n{\n\tstruct asd_ascb *ascb = from_timer(ascb, t, timer);\n\tstruct tasklet_completion_status *tcs = ascb->uldd_task;\n\n\tASD_DPRINTK(\"%s: here\\n\", __func__);\n\ttcs->dl_opcode = TMF_RESP_FUNC_FAILED;\n\tcomplete(ascb->completion);\n}\n\n#define CLEAR_NEXUS_PRE         \\\n\tstruct asd_ascb *ascb; \\\n\tstruct scb *scb; \\\n\tint res; \\\n\tDECLARE_COMPLETION_ONSTACK(completion); \\\n\tDECLARE_TCS(tcs); \\\n\t\t\\\n\tASD_DPRINTK(\"%s: PRE\\n\", __func__); \\\n        res = 1;                \\\n\tascb = asd_ascb_alloc_list(asd_ha, &res, GFP_KERNEL); \\\n\tif (!ascb)              \\\n\t\treturn -ENOMEM; \\\n                                \\\n\tascb->completion = &completion; \\\n\tascb->uldd_task = &tcs; \\\n\tscb = ascb->scb;        \\\n\tscb->header.opcode = CLEAR_NEXUS\n\n#define CLEAR_NEXUS_POST        \\\n\tASD_DPRINTK(\"%s: POST\\n\", __func__); \\\n\tres = asd_enqueue_internal(ascb, asd_clear_nexus_tasklet_complete, \\\n\t\t\t\t   asd_clear_nexus_timedout);              \\\n\tif (res)                \\\n\t\tgoto out_err;   \\\n\tASD_DPRINTK(\"%s: clear nexus posted, waiting...\\n\", __func__); \\\n\twait_for_completion(&completion); \\\n\tres = tcs.dl_opcode; \\\n\tif (res == TC_NO_ERROR) \\\n\t\tres = TMF_RESP_FUNC_COMPLETE;   \\\n\treturn res; \\\nout_err:                        \\\n\tasd_ascb_free(ascb);    \\\n\treturn res\n\nint asd_clear_nexus_ha(struct sas_ha_struct *sas_ha)\n{\n\tstruct asd_ha_struct *asd_ha = sas_ha->lldd_ha;\n\n\tCLEAR_NEXUS_PRE;\n\tscb->clear_nexus.nexus = NEXUS_ADAPTER;\n\tCLEAR_NEXUS_POST;\n}\n\nint asd_clear_nexus_port(struct asd_sas_port *port)\n{\n\tstruct asd_ha_struct *asd_ha = port->ha->lldd_ha;\n\n\tCLEAR_NEXUS_PRE;\n\tscb->clear_nexus.nexus = NEXUS_PORT;\n\tscb->clear_nexus.conn_mask = port->phy_mask;\n\tCLEAR_NEXUS_POST;\n}\n\nenum clear_nexus_phase {\n\tNEXUS_PHASE_PRE,\n\tNEXUS_PHASE_POST,\n\tNEXUS_PHASE_RESUME,\n};\n\nstatic int asd_clear_nexus_I_T(struct domain_device *dev,\n\t\t\t       enum clear_nexus_phase phase)\n{\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\n\tCLEAR_NEXUS_PRE;\n\tscb->clear_nexus.nexus = NEXUS_I_T;\n\tswitch (phase) {\n\tcase NEXUS_PHASE_PRE:\n\t\tscb->clear_nexus.flags = EXEC_Q | SUSPEND_TX;\n\t\tbreak;\n\tcase NEXUS_PHASE_POST:\n\t\tscb->clear_nexus.flags = SEND_Q | NOTINQ;\n\t\tbreak;\n\tcase NEXUS_PHASE_RESUME:\n\t\tscb->clear_nexus.flags = RESUME_TX;\n\t}\n\tscb->clear_nexus.conn_handle = cpu_to_le16((u16)(unsigned long)\n\t\t\t\t\t\t   dev->lldd_dev);\n\tCLEAR_NEXUS_POST;\n}\n\nint asd_I_T_nexus_reset(struct domain_device *dev)\n{\n\tint res, tmp_res, i;\n\tstruct sas_phy *phy = sas_get_local_phy(dev);\n\t \n\tint reset_type = (dev->dev_type == SAS_SATA_DEV ||\n\t\t\t  (dev->tproto & SAS_PROTOCOL_STP)) ? 0 : 1;\n\n\tasd_clear_nexus_I_T(dev, NEXUS_PHASE_PRE);\n\t \n\tASD_DPRINTK(\"sending %s reset to %s\\n\",\n\t\t    reset_type ? \"hard\" : \"soft\", dev_name(&phy->dev));\n\tres = sas_phy_reset(phy, reset_type);\n\tif (res == TMF_RESP_FUNC_COMPLETE || res == -ENODEV) {\n\t\t \n\t\tmsleep(500);\n\t\t \n\t\tasd_clear_nexus_I_T(dev, NEXUS_PHASE_POST);\n\t}\n\tfor (i = 0 ; i < 3; i++) {\n\t\ttmp_res = asd_clear_nexus_I_T(dev, NEXUS_PHASE_RESUME);\n\t\tif (tmp_res == TC_RESUME)\n\t\t\tgoto out;\n\t\tmsleep(500);\n\t}\n\n\t \n\tdev_printk(KERN_ERR, &phy->dev,\n\t\t   \"Failed to resume nexus after reset 0x%x\\n\", tmp_res);\n\n\tres = TMF_RESP_FUNC_FAILED;\n out:\n\tsas_put_local_phy(phy);\n\treturn res;\n}\n\nstatic int asd_clear_nexus_I_T_L(struct domain_device *dev, u8 *lun)\n{\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\n\tCLEAR_NEXUS_PRE;\n\tscb->clear_nexus.nexus = NEXUS_I_T_L;\n\tscb->clear_nexus.flags = SEND_Q | EXEC_Q | NOTINQ;\n\tmemcpy(scb->clear_nexus.ssp_task.lun, lun, 8);\n\tscb->clear_nexus.conn_handle = cpu_to_le16((u16)(unsigned long)\n\t\t\t\t\t\t   dev->lldd_dev);\n\tCLEAR_NEXUS_POST;\n}\n\nstatic int asd_clear_nexus_tag(struct sas_task *task)\n{\n\tstruct asd_ha_struct *asd_ha = task->dev->port->ha->lldd_ha;\n\tstruct asd_ascb *tascb = task->lldd_task;\n\n\tCLEAR_NEXUS_PRE;\n\tscb->clear_nexus.nexus = NEXUS_TAG;\n\tmemcpy(scb->clear_nexus.ssp_task.lun, task->ssp_task.LUN, 8);\n\tscb->clear_nexus.ssp_task.tag = tascb->tag;\n\tif (task->dev->tproto)\n\t\tscb->clear_nexus.conn_handle = cpu_to_le16((u16)(unsigned long)\n\t\t\t\t\t\t\t  task->dev->lldd_dev);\n\tCLEAR_NEXUS_POST;\n}\n\nstatic int asd_clear_nexus_index(struct sas_task *task)\n{\n\tstruct asd_ha_struct *asd_ha = task->dev->port->ha->lldd_ha;\n\tstruct asd_ascb *tascb = task->lldd_task;\n\n\tCLEAR_NEXUS_PRE;\n\tscb->clear_nexus.nexus = NEXUS_TRANS_CX;\n\tif (task->dev->tproto)\n\t\tscb->clear_nexus.conn_handle = cpu_to_le16((u16)(unsigned long)\n\t\t\t\t\t\t\t  task->dev->lldd_dev);\n\tscb->clear_nexus.index = cpu_to_le16(tascb->tc_index);\n\tCLEAR_NEXUS_POST;\n}\n\n \n\nstatic void asd_tmf_timedout(struct timer_list *t)\n{\n\tstruct asd_ascb *ascb = from_timer(ascb, t, timer);\n\tstruct tasklet_completion_status *tcs = ascb->uldd_task;\n\n\tASD_DPRINTK(\"tmf timed out\\n\");\n\ttcs->tmf_state = TMF_RESP_FUNC_FAILED;\n\tcomplete(ascb->completion);\n}\n\nstatic int asd_get_tmf_resp_tasklet(struct asd_ascb *ascb,\n\t\t\t\t    struct done_list_struct *dl)\n{\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tunsigned long flags;\n\tstruct tc_resp_sb_struct {\n\t\t__le16 index_escb;\n\t\tu8     len_lsb;\n\t\tu8     flags;\n\t} __attribute__ ((packed)) *resp_sb = (void *) dl->status_block;\n\n\tint  edb_id = ((resp_sb->flags & 0x70) >> 4)-1;\n\tstruct asd_ascb *escb;\n\tstruct asd_dma_tok *edb;\n\tstruct ssp_frame_hdr *fh;\n\tstruct ssp_response_iu   *ru;\n\tint res = TMF_RESP_FUNC_FAILED;\n\n\tASD_DPRINTK(\"tmf resp tasklet\\n\");\n\n\tspin_lock_irqsave(&asd_ha->seq.tc_index_lock, flags);\n\tescb = asd_tc_index_find(&asd_ha->seq,\n\t\t\t\t (int)le16_to_cpu(resp_sb->index_escb));\n\tspin_unlock_irqrestore(&asd_ha->seq.tc_index_lock, flags);\n\n\tif (!escb) {\n\t\tASD_DPRINTK(\"Uh-oh! No escb for this dl?!\\n\");\n\t\treturn res;\n\t}\n\n\tedb = asd_ha->seq.edb_arr[edb_id + escb->edb_index];\n\tascb->tag = *(__be16 *)(edb->vaddr+4);\n\tfh = edb->vaddr + 16;\n\tru = edb->vaddr + 16 + sizeof(*fh);\n\tres = ru->status;\n\tif (ru->datapres == SAS_DATAPRES_RESPONSE_DATA)\n\t\tres = ru->resp_data[3];\n#if 0\n\tascb->tag = fh->tag;\n#endif\n\tascb->tag_valid = 1;\n\n\tasd_invalidate_edb(escb, edb_id);\n\treturn res;\n}\n\nstatic void asd_tmf_tasklet_complete(struct asd_ascb *ascb,\n\t\t\t\t     struct done_list_struct *dl)\n{\n\tstruct tasklet_completion_status *tcs;\n\n\tif (!del_timer(&ascb->timer))\n\t\treturn;\n\n\ttcs = ascb->uldd_task;\n\tASD_DPRINTK(\"tmf tasklet complete\\n\");\n\n\ttcs->dl_opcode = dl->opcode;\n\n\tif (dl->opcode == TC_SSP_RESP) {\n\t\ttcs->tmf_state = asd_get_tmf_resp_tasklet(ascb, dl);\n\t\ttcs->tag_valid = ascb->tag_valid;\n\t\ttcs->tag = ascb->tag;\n\t}\n\n\tcomplete(ascb->completion);\n\tasd_ascb_free(ascb);\n}\n\nstatic int asd_clear_nexus(struct sas_task *task)\n{\n\tint res = TMF_RESP_FUNC_FAILED;\n\tint leftover;\n\tstruct asd_ascb *tascb = task->lldd_task;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tunsigned long flags;\n\n\ttascb->completion = &completion;\n\n\tASD_DPRINTK(\"task not done, clearing nexus\\n\");\n\tif (tascb->tag_valid)\n\t\tres = asd_clear_nexus_tag(task);\n\telse\n\t\tres = asd_clear_nexus_index(task);\n\tleftover = wait_for_completion_timeout(&completion,\n\t\t\t\t\t       AIC94XX_SCB_TIMEOUT);\n\ttascb->completion = NULL;\n\tASD_DPRINTK(\"came back from clear nexus\\n\");\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (leftover < 1)\n\t\tres = TMF_RESP_FUNC_FAILED;\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE)\n\t\tres = TMF_RESP_FUNC_COMPLETE;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\treturn res;\n}\n\n \nint asd_abort_task(struct sas_task *task)\n{\n\tstruct asd_ascb *tascb = task->lldd_task;\n\tstruct asd_ha_struct *asd_ha = tascb->ha;\n\tint res = 1;\n\tunsigned long flags;\n\tstruct asd_ascb *ascb = NULL;\n\tstruct scb *scb;\n\tint leftover;\n\tDECLARE_TCS(tcs);\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tDECLARE_COMPLETION_ONSTACK(tascb_completion);\n\n\ttascb->completion = &tascb_completion;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tres = TMF_RESP_FUNC_COMPLETE;\n\t\tASD_DPRINTK(\"%s: task 0x%p done\\n\", __func__, task);\n\t\tgoto out_done;\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tascb = asd_ascb_alloc_list(asd_ha, &res, GFP_KERNEL);\n\tif (!ascb)\n\t\treturn -ENOMEM;\n\n\tascb->uldd_task = &tcs;\n\tascb->completion = &completion;\n\tscb = ascb->scb;\n\tscb->header.opcode = SCB_ABORT_TASK;\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\t\tscb->abort_task.proto_conn_rate = (1 << 5);  \n\t\tbreak;\n\tcase SAS_PROTOCOL_SSP:\n\t\tscb->abort_task.proto_conn_rate  = (1 << 4);  \n\t\tscb->abort_task.proto_conn_rate |= task->dev->linkrate;\n\t\tbreak;\n\tcase SAS_PROTOCOL_SMP:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (task->task_proto == SAS_PROTOCOL_SSP) {\n\t\tscb->abort_task.ssp_frame.frame_type = SSP_TASK;\n\t\tmemcpy(scb->abort_task.ssp_frame.hashed_dest_addr,\n\t\t       task->dev->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\n\t\tmemcpy(scb->abort_task.ssp_frame.hashed_src_addr,\n\t\t       task->dev->port->ha->hashed_sas_addr,\n\t\t       HASHED_SAS_ADDR_SIZE);\n\t\tscb->abort_task.ssp_frame.tptt = cpu_to_be16(0xFFFF);\n\n\t\tmemcpy(scb->abort_task.ssp_task.lun, task->ssp_task.LUN, 8);\n\t\tscb->abort_task.ssp_task.tmf = TMF_ABORT_TASK;\n\t\tscb->abort_task.ssp_task.tag = cpu_to_be16(0xFFFF);\n\t}\n\n\tscb->abort_task.sister_scb = cpu_to_le16(0xFFFF);\n\tscb->abort_task.conn_handle = cpu_to_le16(\n\t\t(u16)(unsigned long)task->dev->lldd_dev);\n\tscb->abort_task.retry_count = 1;\n\tscb->abort_task.index = cpu_to_le16((u16)tascb->tc_index);\n\tscb->abort_task.itnl_to = cpu_to_le16(ITNL_TIMEOUT_CONST);\n\n\tres = asd_enqueue_internal(ascb, asd_tmf_tasklet_complete,\n\t\t\t\t   asd_tmf_timedout);\n\tif (res)\n\t\tgoto out_free;\n\twait_for_completion(&completion);\n\tASD_DPRINTK(\"tmf came back\\n\");\n\n\ttascb->tag = tcs.tag;\n\ttascb->tag_valid = tcs.tag_valid;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (task->task_state_flags & SAS_TASK_STATE_DONE) {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tres = TMF_RESP_FUNC_COMPLETE;\n\t\tASD_DPRINTK(\"%s: task 0x%p done\\n\", __func__, task);\n\t\tgoto out_done;\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tif (tcs.dl_opcode == TC_SSP_RESP) {\n\t\t \n\t\tif (tcs.tmf_state == TMF_RESP_FUNC_COMPLETE)\n\t\t\tres = asd_clear_nexus(task);\n\t\telse\n\t\t\tres = tcs.tmf_state;\n\t} else if (tcs.dl_opcode == TC_NO_ERROR &&\n\t\t   tcs.tmf_state == TMF_RESP_FUNC_FAILED) {\n\t\t \n\t\tres = TMF_RESP_FUNC_FAILED;\n\t} else {\n\t\t \n\t\tswitch (tcs.dl_opcode) {\n\t\tdefault:\n\t\t\tres = asd_clear_nexus(task);\n\t\t\tfallthrough;\n\t\tcase TC_NO_ERROR:\n\t\t\tbreak;\n\t\t\t \n\t\tcase TF_NAK_RECV:\n\t\t\tres = TMF_RESP_INVALID_FRAME;\n\t\t\tbreak;\n\t\tcase TF_TMF_TASK_DONE:\t \n\t\t\tres = TMF_RESP_FUNC_FAILED;\n\t\t\tleftover =\n\t\t\t\twait_for_completion_timeout(&tascb_completion,\n\t\t\t\t\t\t\t  AIC94XX_SCB_TIMEOUT);\n\t\t\tspin_lock_irqsave(&task->task_state_lock, flags);\n\t\t\tif (leftover < 1)\n\t\t\t\tres = TMF_RESP_FUNC_FAILED;\n\t\t\tif (task->task_state_flags & SAS_TASK_STATE_DONE)\n\t\t\t\tres = TMF_RESP_FUNC_COMPLETE;\n\t\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\t\tbreak;\n\t\tcase TF_TMF_NO_TAG:\n\t\tcase TF_TMF_TAG_FREE:  \n\t\tcase TF_TMF_NO_CONN_HANDLE:  \n\t\t\tres = TMF_RESP_FUNC_COMPLETE;\n\t\t\tbreak;\n\t\tcase TF_TMF_NO_CTX:  \n\t\t\tres = TMF_RESP_FUNC_ESUPP;\n\t\t\tbreak;\n\t\t}\n\t}\n out_done:\n\ttascb->completion = NULL;\n\tif (res == TMF_RESP_FUNC_COMPLETE) {\n\t\ttask->lldd_task = NULL;\n\t\tmb();\n\t\tasd_ascb_free(tascb);\n\t}\n\tASD_DPRINTK(\"task 0x%p aborted, res: 0x%x\\n\", task, res);\n\treturn res;\n\n out_free:\n\tasd_ascb_free(ascb);\n\tASD_DPRINTK(\"task 0x%p aborted, res: 0x%x\\n\", task, res);\n\treturn res;\n}\n\n \nstatic int asd_initiate_ssp_tmf(struct domain_device *dev, u8 *lun,\n\t\t\t\tint tmf, int index)\n{\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\tstruct asd_ascb *ascb;\n\tint res = 1;\n\tstruct scb *scb;\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tDECLARE_TCS(tcs);\n\n\tif (!(dev->tproto & SAS_PROTOCOL_SSP))\n\t\treturn TMF_RESP_FUNC_ESUPP;\n\n\tascb = asd_ascb_alloc_list(asd_ha, &res, GFP_KERNEL);\n\tif (!ascb)\n\t\treturn -ENOMEM;\n\n\tascb->completion = &completion;\n\tascb->uldd_task = &tcs;\n\tscb = ascb->scb;\n\n\tif (tmf == TMF_QUERY_TASK)\n\t\tscb->header.opcode = QUERY_SSP_TASK;\n\telse\n\t\tscb->header.opcode = INITIATE_SSP_TMF;\n\n\tscb->ssp_tmf.proto_conn_rate  = (1 << 4);  \n\tscb->ssp_tmf.proto_conn_rate |= dev->linkrate;\n\t \n\tscb->ssp_tmf.ssp_frame.frame_type = SSP_TASK;\n\tmemcpy(scb->ssp_tmf.ssp_frame.hashed_dest_addr,\n\t       dev->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\n\tmemcpy(scb->ssp_tmf.ssp_frame.hashed_src_addr,\n\t       dev->port->ha->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\n\tscb->ssp_tmf.ssp_frame.tptt = cpu_to_be16(0xFFFF);\n\t \n\tmemcpy(scb->ssp_tmf.ssp_task.lun, lun, 8);\n\tscb->ssp_tmf.ssp_task.tmf = tmf;\n\n\tscb->ssp_tmf.sister_scb = cpu_to_le16(0xFFFF);\n\tscb->ssp_tmf.conn_handle= cpu_to_le16((u16)(unsigned long)\n\t\t\t\t\t      dev->lldd_dev);\n\tscb->ssp_tmf.retry_count = 1;\n\tscb->ssp_tmf.itnl_to = cpu_to_le16(ITNL_TIMEOUT_CONST);\n\tif (tmf == TMF_QUERY_TASK)\n\t\tscb->ssp_tmf.index = cpu_to_le16(index);\n\n\tres = asd_enqueue_internal(ascb, asd_tmf_tasklet_complete,\n\t\t\t\t   asd_tmf_timedout);\n\tif (res)\n\t\tgoto out_err;\n\twait_for_completion(&completion);\n\n\tswitch (tcs.dl_opcode) {\n\tcase TC_NO_ERROR:\n\t\tres = TMF_RESP_FUNC_COMPLETE;\n\t\tbreak;\n\tcase TF_NAK_RECV:\n\t\tres = TMF_RESP_INVALID_FRAME;\n\t\tbreak;\n\tcase TF_TMF_TASK_DONE:\n\t\tres = TMF_RESP_FUNC_FAILED;\n\t\tbreak;\n\tcase TF_TMF_NO_TAG:\n\tcase TF_TMF_TAG_FREE:  \n\tcase TF_TMF_NO_CONN_HANDLE:  \n\t\tres = TMF_RESP_FUNC_COMPLETE;\n\t\tbreak;\n\tcase TF_TMF_NO_CTX:  \n\t\tres = TMF_RESP_FUNC_ESUPP;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tres = tcs.dl_opcode;\n\t\tbreak;\n\t}\n\treturn res;\nout_err:\n\tasd_ascb_free(ascb);\n\treturn res;\n}\n\nint asd_abort_task_set(struct domain_device *dev, u8 *lun)\n{\n\tint res = asd_initiate_ssp_tmf(dev, lun, TMF_ABORT_TASK_SET, 0);\n\n\tif (res == TMF_RESP_FUNC_COMPLETE)\n\t\tasd_clear_nexus_I_T_L(dev, lun);\n\treturn res;\n}\n\nint asd_clear_task_set(struct domain_device *dev, u8 *lun)\n{\n\tint res = asd_initiate_ssp_tmf(dev, lun, TMF_CLEAR_TASK_SET, 0);\n\n\tif (res == TMF_RESP_FUNC_COMPLETE)\n\t\tasd_clear_nexus_I_T_L(dev, lun);\n\treturn res;\n}\n\nint asd_lu_reset(struct domain_device *dev, u8 *lun)\n{\n\tint res = asd_initiate_ssp_tmf(dev, lun, TMF_LU_RESET, 0);\n\n\tif (res == TMF_RESP_FUNC_COMPLETE)\n\t\tasd_clear_nexus_I_T_L(dev, lun);\n\treturn res;\n}\n\n \nint asd_query_task(struct sas_task *task)\n{\n\tstruct asd_ascb *ascb = task->lldd_task;\n\tint index;\n\n\tif (ascb) {\n\t\tindex = ascb->tc_index;\n\t\treturn asd_initiate_ssp_tmf(task->dev, task->ssp_task.LUN,\n\t\t\t\t\t    TMF_QUERY_TASK, index);\n\t}\n\treturn TMF_RESP_FUNC_COMPLETE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}