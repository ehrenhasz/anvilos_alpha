{
  "module_name": "aic94xx_hwi.c",
  "hash_id": "17960a13096165754d0bce70fcc7ed092100ca0372856e26001c391b004ceec2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_hwi.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n\n#include \"aic94xx.h\"\n#include \"aic94xx_reg.h\"\n#include \"aic94xx_hwi.h\"\n#include \"aic94xx_seq.h\"\n#include \"aic94xx_dump.h\"\n\nu32 MBAR0_SWB_SIZE;\n\n \n\nstatic int asd_get_user_sas_addr(struct asd_ha_struct *asd_ha)\n{\n\t \n\tif (asd_ha->hw_prof.sas_addr[0])\n\t\treturn 0;\n\n\treturn sas_request_addr(asd_ha->sas_ha.shost,\n\t\t\t\tasd_ha->hw_prof.sas_addr);\n}\n\nstatic void asd_propagate_sas_addr(struct asd_ha_struct *asd_ha)\n{\n\tint i;\n\n\tfor (i = 0; i < ASD_MAX_PHYS; i++) {\n\t\tif (asd_ha->hw_prof.phy_desc[i].sas_addr[0] == 0)\n\t\t\tcontinue;\n\t\t \n\t\tASD_DPRINTK(\"setting phy%d addr to %llx\\n\", i,\n\t\t\t    SAS_ADDR(asd_ha->hw_prof.sas_addr));\n\t\tmemcpy(asd_ha->hw_prof.phy_desc[i].sas_addr,\n\t\t       asd_ha->hw_prof.sas_addr, SAS_ADDR_SIZE);\n\t}\n}\n\n \n\nstatic void asd_init_phy_identify(struct asd_phy *phy)\n{\n\tphy->identify_frame = phy->id_frm_tok->vaddr;\n\n\tmemset(phy->identify_frame, 0, sizeof(*phy->identify_frame));\n\n\tphy->identify_frame->dev_type = SAS_END_DEVICE;\n\tif (phy->sas_phy.role & PHY_ROLE_INITIATOR)\n\t\tphy->identify_frame->initiator_bits = phy->sas_phy.iproto;\n\tif (phy->sas_phy.role & PHY_ROLE_TARGET)\n\t\tphy->identify_frame->target_bits = phy->sas_phy.tproto;\n\tmemcpy(phy->identify_frame->sas_addr, phy->phy_desc->sas_addr,\n\t       SAS_ADDR_SIZE);\n\tphy->identify_frame->phy_id = phy->sas_phy.id;\n}\n\nstatic int asd_init_phy(struct asd_phy *phy)\n{\n\tstruct asd_ha_struct *asd_ha = phy->sas_phy.ha->lldd_ha;\n\tstruct asd_sas_phy *sas_phy = &phy->sas_phy;\n\n\tsas_phy->enabled = 1;\n\tsas_phy->iproto = SAS_PROTOCOL_ALL;\n\tsas_phy->tproto = 0;\n\tsas_phy->role = PHY_ROLE_INITIATOR;\n\tsas_phy->oob_mode = OOB_NOT_CONNECTED;\n\tsas_phy->linkrate = SAS_LINK_RATE_UNKNOWN;\n\n\tphy->id_frm_tok = asd_alloc_coherent(asd_ha,\n\t\t\t\t\t     sizeof(*phy->identify_frame),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!phy->id_frm_tok) {\n\t\tasd_printk(\"no mem for IDENTIFY for phy%d\\n\", sas_phy->id);\n\t\treturn -ENOMEM;\n\t} else\n\t\tasd_init_phy_identify(phy);\n\n\tmemset(phy->frame_rcvd, 0, sizeof(phy->frame_rcvd));\n\n\treturn 0;\n}\n\nstatic void asd_init_ports(struct asd_ha_struct *asd_ha)\n{\n\tint i;\n\n\tspin_lock_init(&asd_ha->asd_ports_lock);\n\tfor (i = 0; i < ASD_MAX_PHYS; i++) {\n\t\tstruct asd_port *asd_port = &asd_ha->asd_ports[i];\n\n\t\tmemset(asd_port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(asd_port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tasd_port->phy_mask = 0;\n\t\tasd_port->num_phys = 0;\n\t}\n}\n\nstatic int asd_init_phys(struct asd_ha_struct *asd_ha)\n{\n\tu8 i;\n\tu8 phy_mask = asd_ha->hw_prof.enabled_phys;\n\n\tfor (i = 0; i < ASD_MAX_PHYS; i++) {\n\t\tstruct asd_phy *phy = &asd_ha->phys[i];\n\n\t\tphy->phy_desc = &asd_ha->hw_prof.phy_desc[i];\n\t\tphy->asd_port = NULL;\n\n\t\tphy->sas_phy.enabled = 0;\n\t\tphy->sas_phy.id = i;\n\t\tphy->sas_phy.sas_addr = &phy->phy_desc->sas_addr[0];\n\t\tphy->sas_phy.frame_rcvd = &phy->frame_rcvd[0];\n\t\tphy->sas_phy.ha = &asd_ha->sas_ha;\n\t\tphy->sas_phy.lldd_phy = phy;\n\t}\n\n\t \n\tfor_each_phy(phy_mask, phy_mask, i) {\n\t\tint err = asd_init_phy(&asd_ha->phys[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int asd_init_sw(struct asd_ha_struct *asd_ha)\n{\n\tstruct pci_dev *pcidev = asd_ha->pcidev;\n\tint err;\n\tu32 v;\n\n\t \n\terr = pci_read_config_dword(pcidev, PCI_CONF_MBAR_KEY, &v);\n\tif (err) {\n\t\tasd_printk(\"couldn't access conf. space of %s\\n\",\n\t\t\t   pci_name(pcidev));\n\t\tgoto Err;\n\t}\n\tif (v)\n\t\terr = pci_write_config_dword(pcidev, PCI_CONF_MBAR_KEY, v);\n\tif (err) {\n\t\tasd_printk(\"couldn't write to MBAR_KEY of %s\\n\",\n\t\t\t   pci_name(pcidev));\n\t\tgoto Err;\n\t}\n\n\t \n\tpci_write_config_dword(pcidev, PCI_CONF_MBAR0_SWA, REG_BASE_ADDR);\n\tpci_write_config_dword(pcidev, PCI_CONF_MBAR0_SWB,\n\t\t\t       REG_BASE_ADDR_CSEQCIO);\n\tpci_write_config_dword(pcidev, PCI_CONF_MBAR0_SWC, REG_BASE_ADDR_EXSI);\n\tasd_ha->io_handle[0].swa_base = REG_BASE_ADDR;\n\tasd_ha->io_handle[0].swb_base = REG_BASE_ADDR_CSEQCIO;\n\tasd_ha->io_handle[0].swc_base = REG_BASE_ADDR_EXSI;\n\tMBAR0_SWB_SIZE = asd_ha->io_handle[0].len - 0x80;\n\tif (!asd_ha->iospace) {\n\t\t \n\t\tpci_write_config_dword(pcidev, PCI_CONF_MBAR1, OCM_BASE_ADDR);\n\t\tasd_ha->io_handle[1].swa_base = OCM_BASE_ADDR;\n\t}\n\tspin_lock_init(&asd_ha->iolock);\nErr:\n\treturn err;\n}\n\n \n\n \nstatic int asd_init_scbs(struct asd_ha_struct *asd_ha)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tint bitmap_bytes;\n\n\t \n\tasd_ha->seq.tc_index_bitmap_bits = asd_ha->hw_prof.max_scbs;\n\tasd_ha->seq.tc_index_array = kcalloc(asd_ha->seq.tc_index_bitmap_bits,\n\t\t\t\t\t     sizeof(void *),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!asd_ha->seq.tc_index_array)\n\t\treturn -ENOMEM;\n\n\tbitmap_bytes = (asd_ha->seq.tc_index_bitmap_bits+7)/8;\n\tbitmap_bytes = BITS_TO_LONGS(bitmap_bytes*8)*sizeof(unsigned long);\n\tasd_ha->seq.tc_index_bitmap = kzalloc(bitmap_bytes, GFP_KERNEL);\n\tif (!asd_ha->seq.tc_index_bitmap) {\n\t\tkfree(asd_ha->seq.tc_index_array);\n\t\tasd_ha->seq.tc_index_array = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&seq->tc_index_lock);\n\n\tseq->next_scb.size = sizeof(struct scb);\n\tseq->next_scb.vaddr = dma_pool_alloc(asd_ha->scb_pool, GFP_KERNEL,\n\t\t\t\t\t     &seq->next_scb.dma_handle);\n\tif (!seq->next_scb.vaddr) {\n\t\tkfree(asd_ha->seq.tc_index_bitmap);\n\t\tkfree(asd_ha->seq.tc_index_array);\n\t\tasd_ha->seq.tc_index_bitmap = NULL;\n\t\tasd_ha->seq.tc_index_array = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tseq->pending = 0;\n\tspin_lock_init(&seq->pend_q_lock);\n\tINIT_LIST_HEAD(&seq->pend_q);\n\n\treturn 0;\n}\n\nstatic void asd_get_max_scb_ddb(struct asd_ha_struct *asd_ha)\n{\n\tasd_ha->hw_prof.max_scbs = asd_get_cmdctx_size(asd_ha)/ASD_SCB_SIZE;\n\tasd_ha->hw_prof.max_ddbs = asd_get_devctx_size(asd_ha)/ASD_DDB_SIZE;\n\tASD_DPRINTK(\"max_scbs:%d, max_ddbs:%d\\n\",\n\t\t    asd_ha->hw_prof.max_scbs,\n\t\t    asd_ha->hw_prof.max_ddbs);\n}\n\n \n\nstatic void asd_dl_tasklet_handler(unsigned long);\n\nstatic int asd_init_dl(struct asd_ha_struct *asd_ha)\n{\n\tasd_ha->seq.actual_dl\n\t\t= asd_alloc_coherent(asd_ha,\n\t\t\t     ASD_DL_SIZE * sizeof(struct done_list_struct),\n\t\t\t\t     GFP_KERNEL);\n\tif (!asd_ha->seq.actual_dl)\n\t\treturn -ENOMEM;\n\tasd_ha->seq.dl = asd_ha->seq.actual_dl->vaddr;\n\tasd_ha->seq.dl_toggle = ASD_DEF_DL_TOGGLE;\n\tasd_ha->seq.dl_next = 0;\n\ttasklet_init(&asd_ha->seq.dl_tasklet, asd_dl_tasklet_handler,\n\t\t     (unsigned long) asd_ha);\n\n\treturn 0;\n}\n\n \n\nstatic int asd_alloc_edbs(struct asd_ha_struct *asd_ha, gfp_t gfp_flags)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tint i;\n\n\tseq->edb_arr = kmalloc_array(seq->num_edbs, sizeof(*seq->edb_arr),\n\t\t\t\t     gfp_flags);\n\tif (!seq->edb_arr)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < seq->num_edbs; i++) {\n\t\tseq->edb_arr[i] = asd_alloc_coherent(asd_ha, ASD_EDB_SIZE,\n\t\t\t\t\t\t     gfp_flags);\n\t\tif (!seq->edb_arr[i])\n\t\t\tgoto Err_unroll;\n\t\tmemset(seq->edb_arr[i]->vaddr, 0, ASD_EDB_SIZE);\n\t}\n\n\tASD_DPRINTK(\"num_edbs:%d\\n\", seq->num_edbs);\n\n\treturn 0;\n\nErr_unroll:\n\tfor (i-- ; i >= 0; i--)\n\t\tasd_free_coherent(asd_ha, seq->edb_arr[i]);\n\tkfree(seq->edb_arr);\n\tseq->edb_arr = NULL;\n\n\treturn -ENOMEM;\n}\n\nstatic int asd_alloc_escbs(struct asd_ha_struct *asd_ha,\n\t\t\t   gfp_t gfp_flags)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tstruct asd_ascb *escb;\n\tint i, escbs;\n\n\tseq->escb_arr = kmalloc_array(seq->num_escbs, sizeof(*seq->escb_arr),\n\t\t\t\t      gfp_flags);\n\tif (!seq->escb_arr)\n\t\treturn -ENOMEM;\n\n\tescbs = seq->num_escbs;\n\tescb = asd_ascb_alloc_list(asd_ha, &escbs, gfp_flags);\n\tif (!escb) {\n\t\tasd_printk(\"couldn't allocate list of escbs\\n\");\n\t\tgoto Err;\n\t}\n\tseq->num_escbs -= escbs;   \n\tASD_DPRINTK(\"num_escbs:%d\\n\", seq->num_escbs);\n\n\tfor (i = 0; i < seq->num_escbs; i++, escb = list_entry(escb->list.next,\n\t\t\t\t\t\t\t       struct asd_ascb,\n\t\t\t\t\t\t\t       list)) {\n\t\tseq->escb_arr[i] = escb;\n\t\tescb->scb->header.opcode = EMPTY_SCB;\n\t}\n\n\treturn 0;\nErr:\n\tkfree(seq->escb_arr);\n\tseq->escb_arr = NULL;\n\treturn -ENOMEM;\n\n}\n\nstatic void asd_assign_edbs2escbs(struct asd_ha_struct *asd_ha)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tint i, k, z = 0;\n\n\tfor (i = 0; i < seq->num_escbs; i++) {\n\t\tstruct asd_ascb *ascb = seq->escb_arr[i];\n\t\tstruct empty_scb *escb = &ascb->scb->escb;\n\n\t\tascb->edb_index = z;\n\n\t\tescb->num_valid = ASD_EDBS_PER_SCB;\n\n\t\tfor (k = 0; k < ASD_EDBS_PER_SCB; k++) {\n\t\t\tstruct sg_el *eb = &escb->eb[k];\n\t\t\tstruct asd_dma_tok *edb = seq->edb_arr[z++];\n\n\t\t\tmemset(eb, 0, sizeof(*eb));\n\t\t\teb->bus_addr = cpu_to_le64(((u64) edb->dma_handle));\n\t\t\teb->size = cpu_to_le32(((u32) edb->size));\n\t\t}\n\t}\n}\n\n \nstatic int asd_init_escbs(struct asd_ha_struct *asd_ha)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tint err = 0;\n\n\t \n\tint edbs = 2*(1+asd_ha->hw_prof.num_phys);\n\n\tseq->num_escbs = (edbs+ASD_EDBS_PER_SCB-1)/ASD_EDBS_PER_SCB;\n\tseq->num_edbs = seq->num_escbs * ASD_EDBS_PER_SCB;\n\n\terr = asd_alloc_edbs(asd_ha, GFP_KERNEL);\n\tif (err) {\n\t\tasd_printk(\"couldn't allocate edbs\\n\");\n\t\treturn err;\n\t}\n\n\terr = asd_alloc_escbs(asd_ha, GFP_KERNEL);\n\tif (err) {\n\t\tasd_printk(\"couldn't allocate escbs\\n\");\n\t\treturn err;\n\t}\n\n\tasd_assign_edbs2escbs(asd_ha);\n\t \n\tseq->pending   = seq->num_escbs;\n\tseq->can_queue = 1 + (asd_ha->hw_prof.max_scbs - seq->pending)/2;\n\n\treturn 0;\n}\n\n \n\n \nint asd_chip_hardrst(struct asd_ha_struct *asd_ha)\n{\n\tint i;\n\tint count = 100;\n\tu32 reg;\n\n\tfor (i = 0 ; i < 4 ; i++) {\n\t\tasd_write_reg_dword(asd_ha, COMBIST, HARDRST);\n\t}\n\n\tdo {\n\t\tudelay(1);\n\t\treg = asd_read_reg_dword(asd_ha, CHIMINT);\n\t\tif (reg & HARDRSTDET) {\n\t\t\tasd_write_reg_dword(asd_ha, CHIMINT,\n\t\t\t\t\t    HARDRSTDET|PORRSTDET);\n\t\t\treturn 0;\n\t\t}\n\t} while (--count > 0);\n\n\treturn -ENODEV;\n}\n\n \nstatic int asd_init_chip(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\n\terr = asd_chip_hardrst(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't hard reset %s\\n\",\n\t\t\t    pci_name(asd_ha->pcidev));\n\t\tgoto out;\n\t}\n\n\tasd_disable_ints(asd_ha);\n\n\terr = asd_init_seqs(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't init seqs for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\tgoto out;\n\t}\n\n\terr = asd_start_seqs(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't start seqs for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\tgoto out;\n\t}\nout:\n\treturn err;\n}\n\n#define MAX_DEVS ((OCM_MAX_SIZE) / (ASD_DDB_SIZE))\n\nstatic int max_devs = 0;\nmodule_param_named(max_devs, max_devs, int, S_IRUGO);\nMODULE_PARM_DESC(max_devs, \"\\n\"\n\t\"\\tMaximum number of SAS devices to support (not LUs).\\n\"\n\t\"\\tDefault: 2176, Maximum: 65663.\\n\");\n\nstatic int max_cmnds = 0;\nmodule_param_named(max_cmnds, max_cmnds, int, S_IRUGO);\nMODULE_PARM_DESC(max_cmnds, \"\\n\"\n\t\"\\tMaximum number of commands queuable.\\n\"\n\t\"\\tDefault: 512, Maximum: 66047.\\n\");\n\nstatic void asd_extend_devctx_ocm(struct asd_ha_struct *asd_ha)\n{\n\tunsigned long dma_addr = OCM_BASE_ADDR;\n\tu32 d;\n\n\tdma_addr -= asd_ha->hw_prof.max_ddbs * ASD_DDB_SIZE;\n\tasd_write_reg_addr(asd_ha, DEVCTXBASE, (dma_addr_t) dma_addr);\n\td = asd_read_reg_dword(asd_ha, CTXDOMAIN);\n\td |= 4;\n\tasd_write_reg_dword(asd_ha, CTXDOMAIN, d);\n\tasd_ha->hw_prof.max_ddbs += MAX_DEVS;\n}\n\nstatic int asd_extend_devctx(struct asd_ha_struct *asd_ha)\n{\n\tdma_addr_t dma_handle;\n\tunsigned long dma_addr;\n\tu32 d;\n\tint size;\n\n\tasd_extend_devctx_ocm(asd_ha);\n\n\tasd_ha->hw_prof.ddb_ext = NULL;\n\tif (max_devs <= asd_ha->hw_prof.max_ddbs || max_devs > 0xFFFF) {\n\t\tmax_devs = asd_ha->hw_prof.max_ddbs;\n\t\treturn 0;\n\t}\n\n\tsize = (max_devs - asd_ha->hw_prof.max_ddbs + 1) * ASD_DDB_SIZE;\n\n\tasd_ha->hw_prof.ddb_ext = asd_alloc_coherent(asd_ha, size, GFP_KERNEL);\n\tif (!asd_ha->hw_prof.ddb_ext) {\n\t\tasd_printk(\"couldn't allocate memory for %d devices\\n\",\n\t\t\t   max_devs);\n\t\tmax_devs = asd_ha->hw_prof.max_ddbs;\n\t\treturn -ENOMEM;\n\t}\n\tdma_handle = asd_ha->hw_prof.ddb_ext->dma_handle;\n\tdma_addr = ALIGN((unsigned long) dma_handle, ASD_DDB_SIZE);\n\tdma_addr -= asd_ha->hw_prof.max_ddbs * ASD_DDB_SIZE;\n\tdma_handle = (dma_addr_t) dma_addr;\n\tasd_write_reg_addr(asd_ha, DEVCTXBASE, dma_handle);\n\td = asd_read_reg_dword(asd_ha, CTXDOMAIN);\n\td &= ~4;\n\tasd_write_reg_dword(asd_ha, CTXDOMAIN, d);\n\n\tasd_ha->hw_prof.max_ddbs = max_devs;\n\n\treturn 0;\n}\n\nstatic int asd_extend_cmdctx(struct asd_ha_struct *asd_ha)\n{\n\tdma_addr_t dma_handle;\n\tunsigned long dma_addr;\n\tu32 d;\n\tint size;\n\n\tasd_ha->hw_prof.scb_ext = NULL;\n\tif (max_cmnds <= asd_ha->hw_prof.max_scbs || max_cmnds > 0xFFFF) {\n\t\tmax_cmnds = asd_ha->hw_prof.max_scbs;\n\t\treturn 0;\n\t}\n\n\tsize = (max_cmnds - asd_ha->hw_prof.max_scbs + 1) * ASD_SCB_SIZE;\n\n\tasd_ha->hw_prof.scb_ext = asd_alloc_coherent(asd_ha, size, GFP_KERNEL);\n\tif (!asd_ha->hw_prof.scb_ext) {\n\t\tasd_printk(\"couldn't allocate memory for %d commands\\n\",\n\t\t\t   max_cmnds);\n\t\tmax_cmnds = asd_ha->hw_prof.max_scbs;\n\t\treturn -ENOMEM;\n\t}\n\tdma_handle = asd_ha->hw_prof.scb_ext->dma_handle;\n\tdma_addr = ALIGN((unsigned long) dma_handle, ASD_SCB_SIZE);\n\tdma_addr -= asd_ha->hw_prof.max_scbs * ASD_SCB_SIZE;\n\tdma_handle = (dma_addr_t) dma_addr;\n\tasd_write_reg_addr(asd_ha, CMDCTXBASE, dma_handle);\n\td = asd_read_reg_dword(asd_ha, CTXDOMAIN);\n\td &= ~1;\n\tasd_write_reg_dword(asd_ha, CTXDOMAIN, d);\n\n\tasd_ha->hw_prof.max_scbs = max_cmnds;\n\n\treturn 0;\n}\n\n \nstatic int asd_init_ctxmem(struct asd_ha_struct *asd_ha)\n{\n\tint bitmap_bytes;\n\n\tasd_get_max_scb_ddb(asd_ha);\n\tasd_extend_devctx(asd_ha);\n\tasd_extend_cmdctx(asd_ha);\n\n\t \n\tbitmap_bytes = (asd_ha->hw_prof.max_ddbs+7)/8;\n\tbitmap_bytes = BITS_TO_LONGS(bitmap_bytes*8)*sizeof(unsigned long);\n\tasd_ha->hw_prof.ddb_bitmap = kzalloc(bitmap_bytes, GFP_KERNEL);\n\tif (!asd_ha->hw_prof.ddb_bitmap)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&asd_ha->hw_prof.ddb_lock);\n\n\treturn 0;\n}\n\nint asd_init_hw(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\tu32 v;\n\n\terr = asd_init_sw(asd_ha);\n\tif (err)\n\t\treturn err;\n\n\terr = pci_read_config_dword(asd_ha->pcidev, PCIC_HSTPCIX_CNTRL, &v);\n\tif (err) {\n\t\tasd_printk(\"couldn't read PCIC_HSTPCIX_CNTRL of %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\treturn err;\n\t}\n\terr = pci_write_config_dword(asd_ha->pcidev, PCIC_HSTPCIX_CNTRL,\n\t\t\t\t\tv | SC_TMR_DIS);\n\tif (err) {\n\t\tasd_printk(\"couldn't disable split completion timer of %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\treturn err;\n\t}\n\n\terr = asd_read_ocm(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't read ocm(%d)\\n\", err);\n\t\t \n\t}\n\n\terr = asd_read_flash(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't read flash(%d)\\n\", err);\n\t\t \n\t}\n\n\tasd_init_ctxmem(asd_ha);\n\n\tif (asd_get_user_sas_addr(asd_ha)) {\n\t\tasd_printk(\"No SAS Address provided for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\terr = -ENODEV;\n\t\tgoto Out;\n\t}\n\n\tasd_propagate_sas_addr(asd_ha);\n\n\terr = asd_init_phys(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't initialize phys for %s\\n\",\n\t\t\t    pci_name(asd_ha->pcidev));\n\t\tgoto Out;\n\t}\n\n\tasd_init_ports(asd_ha);\n\n\terr = asd_init_scbs(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't initialize scbs for %s\\n\",\n\t\t\t    pci_name(asd_ha->pcidev));\n\t\tgoto Out;\n\t}\n\n\terr = asd_init_dl(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't initialize the done list:%d\\n\",\n\t\t\t    err);\n\t\tgoto Out;\n\t}\n\n\terr = asd_init_escbs(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't initialize escbs\\n\");\n\t\tgoto Out;\n\t}\n\n\terr = asd_init_chip(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't init the chip\\n\");\n\t\tgoto Out;\n\t}\nOut:\n\treturn err;\n}\n\n \n\n \nstatic void asd_chip_reset(struct asd_ha_struct *asd_ha)\n{\n\tASD_DPRINTK(\"chip reset for %s\\n\", pci_name(asd_ha->pcidev));\n\tasd_chip_hardrst(asd_ha);\n}\n\n \n\nstatic void asd_dl_tasklet_handler(unsigned long data)\n{\n\tstruct asd_ha_struct *asd_ha = (struct asd_ha_struct *) data;\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tstruct done_list_struct *dl = &seq->dl[seq->dl_next];\n\t\tstruct asd_ascb *ascb;\n\n\t\tif ((dl->toggle & DL_TOGGLE_MASK) != seq->dl_toggle)\n\t\t\tbreak;\n\n\t\t \n\t\tspin_lock_irqsave(&seq->tc_index_lock, flags);\n\t\tascb = asd_tc_index_find(seq, (int)le16_to_cpu(dl->index));\n\t\tspin_unlock_irqrestore(&seq->tc_index_lock, flags);\n\t\tif (unlikely(!ascb)) {\n\t\t\tASD_DPRINTK(\"BUG:sequencer:dl:no ascb?!\\n\");\n\t\t\tgoto next_1;\n\t\t} else if (ascb->scb->header.opcode == EMPTY_SCB) {\n\t\t\tgoto out;\n\t\t} else if (!ascb->uldd_timer && !del_timer(&ascb->timer)) {\n\t\t\tgoto next_1;\n\t\t}\n\t\tspin_lock_irqsave(&seq->pend_q_lock, flags);\n\t\tlist_del_init(&ascb->list);\n\t\tseq->pending--;\n\t\tspin_unlock_irqrestore(&seq->pend_q_lock, flags);\n\tout:\n\t\tascb->tasklet_complete(ascb, dl);\n\n\tnext_1:\n\t\tseq->dl_next = (seq->dl_next + 1) & (ASD_DL_SIZE-1);\n\t\tif (!seq->dl_next)\n\t\t\tseq->dl_toggle ^= DL_TOGGLE_MASK;\n\t}\n}\n\n \n\n \nstatic void asd_process_donelist_isr(struct asd_ha_struct *asd_ha)\n{\n\ttasklet_schedule(&asd_ha->seq.dl_tasklet);\n}\n\n \nstatic void asd_com_sas_isr(struct asd_ha_struct *asd_ha)\n{\n\tu32 comstat = asd_read_reg_dword(asd_ha, COMSTAT);\n\n\t \n\tasd_write_reg_dword(asd_ha, COMSTAT, 0xFFFFFFFF);\n\n\tif (comstat & CSBUFPERR) {\n\t\tasd_printk(\"%s: command/status buffer dma parity error\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t} else if (comstat & CSERR) {\n\t\tint i;\n\t\tu32 dmaerr = asd_read_reg_dword(asd_ha, DMAERR);\n\t\tdmaerr &= 0xFF;\n\t\tasd_printk(\"%s: command/status dma error, DMAERR: 0x%02x, \"\n\t\t\t   \"CSDMAADR: 0x%04x, CSDMAADR+4: 0x%04x\\n\",\n\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t   dmaerr,\n\t\t\t   asd_read_reg_dword(asd_ha, CSDMAADR),\n\t\t\t   asd_read_reg_dword(asd_ha, CSDMAADR+4));\n\t\tasd_printk(\"CSBUFFER:\\n\");\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tasd_printk(\"%08x %08x %08x %08x\\n\",\n\t\t\t\t   asd_read_reg_dword(asd_ha, CSBUFFER),\n\t\t\t\t   asd_read_reg_dword(asd_ha, CSBUFFER+4),\n\t\t\t\t   asd_read_reg_dword(asd_ha, CSBUFFER+8),\n\t\t\t\t   asd_read_reg_dword(asd_ha, CSBUFFER+12));\n\t\t}\n\t\tasd_dump_seq_state(asd_ha, 0);\n\t} else if (comstat & OVLYERR) {\n\t\tu32 dmaerr = asd_read_reg_dword(asd_ha, DMAERR);\n\t\tdmaerr = (dmaerr >> 8) & 0xFF;\n\t\tasd_printk(\"%s: overlay dma error:0x%x\\n\",\n\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t   dmaerr);\n\t}\n\tasd_chip_reset(asd_ha);\n}\n\nstatic void asd_arp2_err(struct asd_ha_struct *asd_ha, u32 dchstatus)\n{\n\tstatic const char *halt_code[256] = {\n\t\t\"UNEXPECTED_INTERRUPT0\",\n\t\t\"UNEXPECTED_INTERRUPT1\",\n\t\t\"UNEXPECTED_INTERRUPT2\",\n\t\t\"UNEXPECTED_INTERRUPT3\",\n\t\t\"UNEXPECTED_INTERRUPT4\",\n\t\t\"UNEXPECTED_INTERRUPT5\",\n\t\t\"UNEXPECTED_INTERRUPT6\",\n\t\t\"UNEXPECTED_INTERRUPT7\",\n\t\t\"UNEXPECTED_INTERRUPT8\",\n\t\t\"UNEXPECTED_INTERRUPT9\",\n\t\t\"UNEXPECTED_INTERRUPT10\",\n\t\t[11 ... 19] = \"unknown[11,19]\",\n\t\t\"NO_FREE_SCB_AVAILABLE\",\n\t\t\"INVALID_SCB_OPCODE\",\n\t\t\"INVALID_MBX_OPCODE\",\n\t\t\"INVALID_ATA_STATE\",\n\t\t\"ATA_QUEUE_FULL\",\n\t\t\"ATA_TAG_TABLE_FAULT\",\n\t\t\"ATA_TAG_MASK_FAULT\",\n\t\t\"BAD_LINK_QUEUE_STATE\",\n\t\t\"DMA2CHIM_QUEUE_ERROR\",\n\t\t\"EMPTY_SCB_LIST_FULL\",\n\t\t\"unknown[30]\",\n\t\t\"IN_USE_SCB_ON_FREE_LIST\",\n\t\t\"BAD_OPEN_WAIT_STATE\",\n\t\t\"INVALID_STP_AFFILIATION\",\n\t\t\"unknown[34]\",\n\t\t\"EXEC_QUEUE_ERROR\",\n\t\t\"TOO_MANY_EMPTIES_NEEDED\",\n\t\t\"EMPTY_REQ_QUEUE_ERROR\",\n\t\t\"Q_MONIRTT_MGMT_ERROR\",\n\t\t\"TARGET_MODE_FLOW_ERROR\",\n\t\t\"DEVICE_QUEUE_NOT_FOUND\",\n\t\t\"START_IRTT_TIMER_ERROR\",\n\t\t\"ABORT_TASK_ILLEGAL_REQ\",\n\t\t[43 ... 255] = \"unknown[43,255]\"\n\t};\n\n\tif (dchstatus & CSEQINT) {\n\t\tu32 arp2int = asd_read_reg_dword(asd_ha, CARP2INT);\n\n\t\tif (arp2int & (ARP2WAITTO|ARP2ILLOPC|ARP2PERR|ARP2CIOPERR)) {\n\t\t\tasd_printk(\"%s: CSEQ arp2int:0x%x\\n\",\n\t\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t\t   arp2int);\n\t\t} else if (arp2int & ARP2HALTC)\n\t\t\tasd_printk(\"%s: CSEQ halted: %s\\n\",\n\t\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t\t   halt_code[(arp2int>>16)&0xFF]);\n\t\telse\n\t\t\tasd_printk(\"%s: CARP2INT:0x%x\\n\",\n\t\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t\t   arp2int);\n\t}\n\tif (dchstatus & LSEQINT_MASK) {\n\t\tint lseq;\n\t\tu8  lseq_mask = dchstatus & LSEQINT_MASK;\n\n\t\tfor_each_sequencer(lseq_mask, lseq_mask, lseq) {\n\t\t\tu32 arp2int = asd_read_reg_dword(asd_ha,\n\t\t\t\t\t\t\t LmARP2INT(lseq));\n\t\t\tif (arp2int & (ARP2WAITTO | ARP2ILLOPC | ARP2PERR\n\t\t\t\t       | ARP2CIOPERR)) {\n\t\t\t\tasd_printk(\"%s: LSEQ%d arp2int:0x%x\\n\",\n\t\t\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t\t\t   lseq, arp2int);\n\t\t\t\t \n\t\t\t} else if (arp2int & ARP2HALTC)\n\t\t\t\tasd_printk(\"%s: LSEQ%d halted: %s\\n\",\n\t\t\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t\t\t   lseq,halt_code[(arp2int>>16)&0xFF]);\n\t\t\telse\n\t\t\t\tasd_printk(\"%s: LSEQ%d ARP2INT:0x%x\\n\",\n\t\t\t\t\t   pci_name(asd_ha->pcidev), lseq,\n\t\t\t\t\t   arp2int);\n\t\t}\n\t}\n\tasd_chip_reset(asd_ha);\n}\n\n \nstatic void asd_dch_sas_isr(struct asd_ha_struct *asd_ha)\n{\n\tu32 dchstatus = asd_read_reg_dword(asd_ha, DCHSTATUS);\n\n\tif (dchstatus & CFIFTOERR) {\n\t\tasd_printk(\"%s: CFIFTOERR\\n\", pci_name(asd_ha->pcidev));\n\t\tasd_chip_reset(asd_ha);\n\t} else\n\t\tasd_arp2_err(asd_ha, dchstatus);\n}\n\n \nstatic void asd_rbi_exsi_isr(struct asd_ha_struct *asd_ha)\n{\n\tu32 stat0r = asd_read_reg_dword(asd_ha, ASISTAT0R);\n\n\tif (!(stat0r & ASIERR)) {\n\t\tasd_printk(\"hmm, EXSI interrupted but no error?\\n\");\n\t\treturn;\n\t}\n\n\tif (stat0r & ASIFMTERR) {\n\t\tasd_printk(\"ASI SEEPROM format error for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t} else if (stat0r & ASISEECHKERR) {\n\t\tu32 stat1r = asd_read_reg_dword(asd_ha, ASISTAT1R);\n\t\tasd_printk(\"ASI SEEPROM checksum 0x%x error for %s\\n\",\n\t\t\t   stat1r & CHECKSUM_MASK,\n\t\t\t   pci_name(asd_ha->pcidev));\n\t} else {\n\t\tu32 statr = asd_read_reg_dword(asd_ha, ASIERRSTATR);\n\n\t\tif (!(statr & CPI2ASIMSTERR_MASK)) {\n\t\t\tASD_DPRINTK(\"hmm, ASIERR?\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tu32 addr = asd_read_reg_dword(asd_ha, ASIERRADDR);\n\t\t\tu32 data = asd_read_reg_dword(asd_ha, ASIERRDATAR);\n\n\t\t\tasd_printk(\"%s: CPI2 xfer err: addr: 0x%x, wdata: 0x%x, \"\n\t\t\t\t   \"count: 0x%x, byteen: 0x%x, targerr: 0x%x \"\n\t\t\t\t   \"master id: 0x%x, master err: 0x%x\\n\",\n\t\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t\t   addr, data,\n\t\t\t\t   (statr & CPI2ASIBYTECNT_MASK) >> 16,\n\t\t\t\t   (statr & CPI2ASIBYTEEN_MASK) >> 12,\n\t\t\t\t   (statr & CPI2ASITARGERR_MASK) >> 8,\n\t\t\t\t   (statr & CPI2ASITARGMID_MASK) >> 4,\n\t\t\t\t   (statr & CPI2ASIMSTERR_MASK));\n\t\t}\n\t}\n\tasd_chip_reset(asd_ha);\n}\n\n \nstatic void asd_hst_pcix_isr(struct asd_ha_struct *asd_ha)\n{\n\tu16 status;\n\tu32 pcix_status;\n\tu32 ecc_status;\n\n\tpci_read_config_word(asd_ha->pcidev, PCI_STATUS, &status);\n\tpci_read_config_dword(asd_ha->pcidev, PCIX_STATUS, &pcix_status);\n\tpci_read_config_dword(asd_ha->pcidev, ECC_CTRL_STAT, &ecc_status);\n\n\tif (status & PCI_STATUS_DETECTED_PARITY)\n\t\tasd_printk(\"parity error for %s\\n\", pci_name(asd_ha->pcidev));\n\telse if (status & PCI_STATUS_REC_MASTER_ABORT)\n\t\tasd_printk(\"master abort for %s\\n\", pci_name(asd_ha->pcidev));\n\telse if (status & PCI_STATUS_REC_TARGET_ABORT)\n\t\tasd_printk(\"target abort for %s\\n\", pci_name(asd_ha->pcidev));\n\telse if (status & PCI_STATUS_PARITY)\n\t\tasd_printk(\"data parity for %s\\n\", pci_name(asd_ha->pcidev));\n\telse if (pcix_status & RCV_SCE) {\n\t\tasd_printk(\"received split completion error for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\tpci_write_config_dword(asd_ha->pcidev,PCIX_STATUS,pcix_status);\n\t\t \n\t\treturn;\n\t} else if (pcix_status & UNEXP_SC) {\n\t\tasd_printk(\"unexpected split completion for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\tpci_write_config_dword(asd_ha->pcidev,PCIX_STATUS,pcix_status);\n\t\t \n\t\treturn;\n\t} else if (pcix_status & SC_DISCARD)\n\t\tasd_printk(\"split completion discarded for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\telse if (ecc_status & UNCOR_ECCERR)\n\t\tasd_printk(\"uncorrectable ECC error for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\tasd_chip_reset(asd_ha);\n}\n\n \nirqreturn_t asd_hw_isr(int irq, void *dev_id)\n{\n\tstruct asd_ha_struct *asd_ha = dev_id;\n\tu32 chimint = asd_read_reg_dword(asd_ha, CHIMINT);\n\n\tif (!chimint)\n\t\treturn IRQ_NONE;\n\n\tasd_write_reg_dword(asd_ha, CHIMINT, chimint);\n\t(void) asd_read_reg_dword(asd_ha, CHIMINT);\n\n\tif (chimint & DLAVAIL)\n\t\tasd_process_donelist_isr(asd_ha);\n\tif (chimint & COMINT)\n\t\tasd_com_sas_isr(asd_ha);\n\tif (chimint & DEVINT)\n\t\tasd_dch_sas_isr(asd_ha);\n\tif (chimint & INITERR)\n\t\tasd_rbi_exsi_isr(asd_ha);\n\tif (chimint & HOSTERR)\n\t\tasd_hst_pcix_isr(asd_ha);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic struct asd_ascb *asd_ascb_alloc(struct asd_ha_struct *asd_ha,\n\t\t\t\t       gfp_t gfp_flags)\n{\n\textern struct kmem_cache *asd_ascb_cache;\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tstruct asd_ascb *ascb;\n\tunsigned long flags;\n\n\tascb = kmem_cache_zalloc(asd_ascb_cache, gfp_flags);\n\n\tif (ascb) {\n\t\tascb->dma_scb.size = sizeof(struct scb);\n\t\tascb->dma_scb.vaddr = dma_pool_zalloc(asd_ha->scb_pool,\n\t\t\t\t\t\t     gfp_flags,\n\t\t\t\t\t\t    &ascb->dma_scb.dma_handle);\n\t\tif (!ascb->dma_scb.vaddr) {\n\t\t\tkmem_cache_free(asd_ascb_cache, ascb);\n\t\t\treturn NULL;\n\t\t}\n\t\tasd_init_ascb(asd_ha, ascb);\n\n\t\tspin_lock_irqsave(&seq->tc_index_lock, flags);\n\t\tascb->tc_index = asd_tc_index_get(seq, ascb);\n\t\tspin_unlock_irqrestore(&seq->tc_index_lock, flags);\n\t\tif (ascb->tc_index == -1)\n\t\t\tgoto undo;\n\n\t\tascb->scb->header.index = cpu_to_le16((u16)ascb->tc_index);\n\t}\n\n\treturn ascb;\nundo:\n\tdma_pool_free(asd_ha->scb_pool, ascb->dma_scb.vaddr,\n\t\t      ascb->dma_scb.dma_handle);\n\tkmem_cache_free(asd_ascb_cache, ascb);\n\tASD_DPRINTK(\"no index for ascb\\n\");\n\treturn NULL;\n}\n\n \nstruct asd_ascb *asd_ascb_alloc_list(struct asd_ha_struct\n\t\t\t\t     *asd_ha, int *num,\n\t\t\t\t     gfp_t gfp_flags)\n{\n\tstruct asd_ascb *first = NULL;\n\n\tfor ( ; *num > 0; --*num) {\n\t\tstruct asd_ascb *ascb = asd_ascb_alloc(asd_ha, gfp_flags);\n\n\t\tif (!ascb)\n\t\t\tbreak;\n\t\telse if (!first)\n\t\t\tfirst = ascb;\n\t\telse {\n\t\t\tstruct asd_ascb *last = list_entry(first->list.prev,\n\t\t\t\t\t\t\t   struct asd_ascb,\n\t\t\t\t\t\t\t   list);\n\t\t\tlist_add_tail(&ascb->list, &first->list);\n\t\t\tlast->scb->header.next_scb =\n\t\t\t\tcpu_to_le64(((u64)ascb->dma_scb.dma_handle));\n\t\t}\n\t}\n\n\treturn first;\n}\n\n \nstatic void asd_swap_head_scb(struct asd_ha_struct *asd_ha,\n\t\t\t      struct asd_ascb *ascb)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tstruct asd_ascb *last = list_entry(ascb->list.prev,\n\t\t\t\t\t   struct asd_ascb,\n\t\t\t\t\t   list);\n\tstruct asd_dma_tok t = ascb->dma_scb;\n\n\tmemcpy(seq->next_scb.vaddr, ascb->scb, sizeof(*ascb->scb));\n\tascb->dma_scb = seq->next_scb;\n\tascb->scb = ascb->dma_scb.vaddr;\n\tseq->next_scb = t;\n\tlast->scb->header.next_scb =\n\t\tcpu_to_le64(((u64)seq->next_scb.dma_handle));\n}\n\n \nstatic void asd_start_scb_timers(struct list_head *list)\n{\n\tstruct asd_ascb *ascb;\n\tlist_for_each_entry(ascb, list, list) {\n\t\tif (!ascb->uldd_timer) {\n\t\t\tascb->timer.function = asd_ascb_timedout;\n\t\t\tascb->timer.expires = jiffies + AIC94XX_SCB_TIMEOUT;\n\t\t\tadd_timer(&ascb->timer);\n\t\t}\n\t}\n}\n\n \nint asd_post_ascb_list(struct asd_ha_struct *asd_ha, struct asd_ascb *ascb,\n\t\t       int num)\n{\n\tunsigned long flags;\n\tLIST_HEAD(list);\n\tint can_queue;\n\n\tspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\n\tcan_queue = asd_ha->hw_prof.max_scbs - asd_ha->seq.pending;\n\tif (can_queue >= num)\n\t\tasd_ha->seq.pending += num;\n\telse\n\t\tcan_queue = 0;\n\n\tif (!can_queue) {\n\t\tspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\n\t\tasd_printk(\"%s: scb queue full\\n\", pci_name(asd_ha->pcidev));\n\t\treturn -SAS_QUEUE_FULL;\n\t}\n\n\tasd_swap_head_scb(asd_ha, ascb);\n\n\t__list_add(&list, ascb->list.prev, &ascb->list);\n\n\tasd_start_scb_timers(&list);\n\n\tasd_ha->seq.scbpro += num;\n\tlist_splice_init(&list, asd_ha->seq.pend_q.prev);\n\tasd_write_reg_dword(asd_ha, SCBPRO, (u32)asd_ha->seq.scbpro);\n\tspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\n\n\treturn 0;\n}\n\n \nint asd_post_escb_list(struct asd_ha_struct *asd_ha, struct asd_ascb *ascb,\n\t\t       int num)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\n\tasd_swap_head_scb(asd_ha, ascb);\n\tasd_ha->seq.scbpro += num;\n\tasd_write_reg_dword(asd_ha, SCBPRO, (u32)asd_ha->seq.scbpro);\n\tspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\n\n\treturn 0;\n}\n\n \n\n \nvoid asd_turn_led(struct asd_ha_struct *asd_ha, int phy_id, int op)\n{\n\tif (phy_id < ASD_MAX_PHYS) {\n\t\tu32 v = asd_read_reg_dword(asd_ha, LmCONTROL(phy_id));\n\t\tif (op)\n\t\t\tv |= LEDPOL;\n\t\telse\n\t\t\tv &= ~LEDPOL;\n\t\tasd_write_reg_dword(asd_ha, LmCONTROL(phy_id), v);\n\t}\n}\n\n \nvoid asd_control_led(struct asd_ha_struct *asd_ha, int phy_id, int op)\n{\n\tif (phy_id < ASD_MAX_PHYS) {\n\t\tu32 v;\n\n\t\tv = asd_read_reg_dword(asd_ha, GPIOOER);\n\t\tif (op)\n\t\t\tv |= (1 << phy_id);\n\t\telse\n\t\t\tv &= ~(1 << phy_id);\n\t\tasd_write_reg_dword(asd_ha, GPIOOER, v);\n\n\t\tv = asd_read_reg_dword(asd_ha, GPIOCNFGR);\n\t\tif (op)\n\t\t\tv |= (1 << phy_id);\n\t\telse\n\t\t\tv &= ~(1 << phy_id);\n\t\tasd_write_reg_dword(asd_ha, GPIOCNFGR, v);\n\t}\n}\n\n \n\nstatic int asd_enable_phy(struct asd_ha_struct *asd_ha, int phy_id)\n{\n\tstruct asd_phy *phy = &asd_ha->phys[phy_id];\n\n\tasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, INT_ENABLE_2), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, HOT_PLUG_DELAY),\n\t\t\t   HOTPLUG_DELAY_TIMEOUT);\n\n\t \n\t \n\tasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_0),\n\t\t\t   phy->phy_desc->phy_control_0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_1),\n\t\t\t   phy->phy_desc->phy_control_1);\n\tasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_2),\n\t\t\t   phy->phy_desc->phy_control_2);\n\tasd_write_reg_byte(asd_ha, LmSEQ_OOB_REG(phy_id, PHY_CONTROL_3),\n\t\t\t   phy->phy_desc->phy_control_3);\n\n\tasd_write_reg_dword(asd_ha, LmSEQ_TEN_MS_COMINIT_TIMEOUT(phy_id),\n\t\t\t    ASD_COMINIT_TIMEOUT);\n\n\tasd_write_reg_addr(asd_ha, LmSEQ_TX_ID_ADDR_FRAME(phy_id),\n\t\t\t   phy->id_frm_tok->dma_handle);\n\n\tasd_control_led(asd_ha, phy_id, 1);\n\n\treturn 0;\n}\n\nint asd_enable_phys(struct asd_ha_struct *asd_ha, const u8 phy_mask)\n{\n\tu8  phy_m;\n\tu8  i;\n\tint num = 0, k;\n\tstruct asd_ascb *ascb;\n\tstruct asd_ascb *ascb_list;\n\n\tif (!phy_mask) {\n\t\tasd_printk(\"%s called with phy_mask of 0!?\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tfor_each_phy(phy_mask, phy_m, i) {\n\t\tnum++;\n\t\tasd_enable_phy(asd_ha, i);\n\t}\n\n\tk = num;\n\tascb_list = asd_ascb_alloc_list(asd_ha, &k, GFP_KERNEL);\n\tif (!ascb_list) {\n\t\tasd_printk(\"no memory for control phy ascb list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tnum -= k;\n\n\tascb = ascb_list;\n\tfor_each_phy(phy_mask, phy_m, i) {\n\t\tasd_build_control_phy(ascb, i, ENABLE_PHY);\n\t\tascb = list_entry(ascb->list.next, struct asd_ascb, list);\n\t}\n\tASD_DPRINTK(\"posting %d control phy scbs\\n\", num);\n\tk = asd_post_ascb_list(asd_ha, ascb_list, num);\n\tif (k)\n\t\tasd_ascb_free_list(ascb_list);\n\n\treturn k;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}