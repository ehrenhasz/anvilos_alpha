{
  "module_name": "aic94xx_init.c",
  "hash_id": "4bf95d93262ce9eb60a92fe44dbfb61d8fd47e407936a477afcef0e49cc5317d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_init.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi_host.h>\n\n#include \"aic94xx.h\"\n#include \"aic94xx_reg.h\"\n#include \"aic94xx_hwi.h\"\n#include \"aic94xx_seq.h\"\n#include \"aic94xx_sds.h\"\n\n \n#define ASD_DRIVER_VERSION \"1.0.3\"\n\nstatic int use_msi = 0;\nmodule_param_named(use_msi, use_msi, int, S_IRUGO);\nMODULE_PARM_DESC(use_msi, \"\\n\"\n\t\"\\tEnable(1) or disable(0) using PCI MSI.\\n\"\n\t\"\\tDefault: 0\");\n\nstatic struct scsi_transport_template *aic94xx_transport_template;\nstatic int asd_scan_finished(struct Scsi_Host *, unsigned long);\nstatic void asd_scan_start(struct Scsi_Host *);\n\nstatic const struct scsi_host_template aic94xx_sht = {\n\t.module\t\t\t= THIS_MODULE,\n\t \n\t.name\t\t\t= \"aic94xx\",\n\t.queuecommand\t\t= sas_queuecommand,\n\t.dma_need_drain\t\t= ata_scsi_dma_need_drain,\n\t.target_alloc\t\t= sas_target_alloc,\n\t.slave_configure\t= sas_slave_configure,\n\t.scan_finished\t\t= asd_scan_finished,\n\t.scan_start\t\t= asd_scan_start,\n\t.change_queue_depth\t= sas_change_queue_depth,\n\t.bios_param\t\t= sas_bios_param,\n\t.can_queue\t\t= 1,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.max_sectors\t\t= SCSI_DEFAULT_MAX_SECTORS,\n\t.eh_device_reset_handler\t= sas_eh_device_reset_handler,\n\t.eh_target_reset_handler\t= sas_eh_target_reset_handler,\n\t.slave_alloc\t\t= sas_slave_alloc,\n\t.target_destroy\t\t= sas_target_destroy,\n\t.ioctl\t\t\t= sas_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= sas_ioctl,\n#endif\n\t.track_queue_depth\t= 1,\n};\n\nstatic int asd_map_memio(struct asd_ha_struct *asd_ha)\n{\n\tint err, i;\n\tstruct asd_ha_addrspace *io_handle;\n\n\tasd_ha->iospace = 0;\n\tfor (i = 0; i < 3; i += 2) {\n\t\tio_handle = &asd_ha->io_handle[i==0?0:1];\n\t\tio_handle->start = pci_resource_start(asd_ha->pcidev, i);\n\t\tio_handle->len   = pci_resource_len(asd_ha->pcidev, i);\n\t\tio_handle->flags = pci_resource_flags(asd_ha->pcidev, i);\n\t\terr = -ENODEV;\n\t\tif (!io_handle->start || !io_handle->len) {\n\t\t\tasd_printk(\"MBAR%d start or length for %s is 0.\\n\",\n\t\t\t\t   i==0?0:1, pci_name(asd_ha->pcidev));\n\t\t\tgoto Err;\n\t\t}\n\t\terr = pci_request_region(asd_ha->pcidev, i, ASD_DRIVER_NAME);\n\t\tif (err) {\n\t\t\tasd_printk(\"couldn't reserve memory region for %s\\n\",\n\t\t\t\t   pci_name(asd_ha->pcidev));\n\t\t\tgoto Err;\n\t\t}\n\t\tio_handle->addr = ioremap(io_handle->start, io_handle->len);\n\t\tif (!io_handle->addr) {\n\t\t\tasd_printk(\"couldn't map MBAR%d of %s\\n\", i==0?0:1,\n\t\t\t\t   pci_name(asd_ha->pcidev));\n\t\t\terr = -ENOMEM;\n\t\t\tgoto Err_unreq;\n\t\t}\n\t}\n\n\treturn 0;\nErr_unreq:\n\tpci_release_region(asd_ha->pcidev, i);\nErr:\n\tif (i > 0) {\n\t\tio_handle = &asd_ha->io_handle[0];\n\t\tiounmap(io_handle->addr);\n\t\tpci_release_region(asd_ha->pcidev, 0);\n\t}\n\treturn err;\n}\n\nstatic void asd_unmap_memio(struct asd_ha_struct *asd_ha)\n{\n\tstruct asd_ha_addrspace *io_handle;\n\n\tio_handle = &asd_ha->io_handle[1];\n\tiounmap(io_handle->addr);\n\tpci_release_region(asd_ha->pcidev, 2);\n\n\tio_handle = &asd_ha->io_handle[0];\n\tiounmap(io_handle->addr);\n\tpci_release_region(asd_ha->pcidev, 0);\n}\n\nstatic int asd_map_ioport(struct asd_ha_struct *asd_ha)\n{\n\tint i = PCI_IOBAR_OFFSET, err;\n\tstruct asd_ha_addrspace *io_handle = &asd_ha->io_handle[0];\n\n\tasd_ha->iospace = 1;\n\tio_handle->start = pci_resource_start(asd_ha->pcidev, i);\n\tio_handle->len   = pci_resource_len(asd_ha->pcidev, i);\n\tio_handle->flags = pci_resource_flags(asd_ha->pcidev, i);\n\tio_handle->addr  = (void __iomem *) io_handle->start;\n\tif (!io_handle->start || !io_handle->len) {\n\t\tasd_printk(\"couldn't get IO ports for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\treturn -ENODEV;\n\t}\n\terr = pci_request_region(asd_ha->pcidev, i, ASD_DRIVER_NAME);\n\tif (err) {\n\t\tasd_printk(\"couldn't reserve io space for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t}\n\n\treturn err;\n}\n\nstatic void asd_unmap_ioport(struct asd_ha_struct *asd_ha)\n{\n\tpci_release_region(asd_ha->pcidev, PCI_IOBAR_OFFSET);\n}\n\nstatic int asd_map_ha(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\tu16 cmd_reg;\n\n\terr = pci_read_config_word(asd_ha->pcidev, PCI_COMMAND, &cmd_reg);\n\tif (err) {\n\t\tasd_printk(\"couldn't read command register of %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\tgoto Err;\n\t}\n\n\terr = -ENODEV;\n\tif (cmd_reg & PCI_COMMAND_MEMORY) {\n\t\tif ((err = asd_map_memio(asd_ha)))\n\t\t\tgoto Err;\n\t} else if (cmd_reg & PCI_COMMAND_IO) {\n\t\tif ((err = asd_map_ioport(asd_ha)))\n\t\t\tgoto Err;\n\t\tasd_printk(\"%s ioport mapped -- upgrade your hardware\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t} else {\n\t\tasd_printk(\"no proper device access to %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\tgoto Err;\n\t}\n\n\treturn 0;\nErr:\n\treturn err;\n}\n\nstatic void asd_unmap_ha(struct asd_ha_struct *asd_ha)\n{\n\tif (asd_ha->iospace)\n\t\tasd_unmap_ioport(asd_ha);\n\telse\n\t\tasd_unmap_memio(asd_ha);\n}\n\nstatic const char *asd_dev_rev[30] = {\n\t[0] = \"A0\",\n\t[1] = \"A1\",\n\t[8] = \"B0\",\n};\n\nstatic int asd_common_setup(struct asd_ha_struct *asd_ha)\n{\n\tint err, i;\n\n\tasd_ha->revision_id = asd_ha->pcidev->revision;\n\n\terr = -ENODEV;\n\tif (asd_ha->revision_id < AIC9410_DEV_REV_B0) {\n\t\tasd_printk(\"%s is revision %s (%X), which is not supported\\n\",\n\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t   asd_dev_rev[asd_ha->revision_id],\n\t\t\t   asd_ha->revision_id);\n\t\tgoto Err;\n\t}\n\t \n\tasd_ha->hw_prof.max_scbs = 512;\n\tasd_ha->hw_prof.max_ddbs = ASD_MAX_DDBS;\n\tasd_ha->hw_prof.num_phys = ASD_MAX_PHYS;\n\t \n\tasd_ha->hw_prof.enabled_phys = 0xFF;\n\tfor (i = 0; i < ASD_MAX_PHYS; i++) {\n\t\tasd_ha->hw_prof.phy_desc[i].max_sas_lrate =\n\t\t\tSAS_LINK_RATE_3_0_GBPS;\n\t\tasd_ha->hw_prof.phy_desc[i].min_sas_lrate =\n\t\t\tSAS_LINK_RATE_1_5_GBPS;\n\t\tasd_ha->hw_prof.phy_desc[i].max_sata_lrate =\n\t\t\tSAS_LINK_RATE_1_5_GBPS;\n\t\tasd_ha->hw_prof.phy_desc[i].min_sata_lrate =\n\t\t\tSAS_LINK_RATE_1_5_GBPS;\n\t}\n\n\treturn 0;\nErr:\n\treturn err;\n}\n\nstatic int asd_aic9410_setup(struct asd_ha_struct *asd_ha)\n{\n\tint err = asd_common_setup(asd_ha);\n\n\tif (err)\n\t\treturn err;\n\n\tasd_ha->hw_prof.addr_range = 8;\n\tasd_ha->hw_prof.port_name_base = 0;\n\tasd_ha->hw_prof.dev_name_base = 8;\n\tasd_ha->hw_prof.sata_name_base = 16;\n\n\treturn 0;\n}\n\nstatic int asd_aic9405_setup(struct asd_ha_struct *asd_ha)\n{\n\tint err = asd_common_setup(asd_ha);\n\n\tif (err)\n\t\treturn err;\n\n\tasd_ha->hw_prof.addr_range = 4;\n\tasd_ha->hw_prof.port_name_base = 0;\n\tasd_ha->hw_prof.dev_name_base = 4;\n\tasd_ha->hw_prof.sata_name_base = 8;\n\n\treturn 0;\n}\n\nstatic ssize_t asd_show_dev_rev(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\tasd_dev_rev[asd_ha->revision_id]);\n}\nstatic DEVICE_ATTR(aic_revision, S_IRUGO, asd_show_dev_rev, NULL);\n\nstatic ssize_t asd_show_dev_bios_build(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,char *buf)\n{\n\tstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", asd_ha->hw_prof.bios.bld);\n}\nstatic DEVICE_ATTR(bios_build, S_IRUGO, asd_show_dev_bios_build, NULL);\n\nstatic ssize_t asd_show_dev_pcba_sn(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", asd_ha->hw_prof.pcba_sn);\n}\nstatic DEVICE_ATTR(pcba_sn, S_IRUGO, asd_show_dev_pcba_sn, NULL);\n\n#define FLASH_CMD_NONE      0x00\n#define FLASH_CMD_UPDATE    0x01\n#define FLASH_CMD_VERIFY    0x02\n\nstruct flash_command {\n     u8      command[8];\n     int     code;\n};\n\nstatic struct flash_command flash_command_table[] =\n{\n     {\"verify\",      FLASH_CMD_VERIFY},\n     {\"update\",      FLASH_CMD_UPDATE},\n     {\"\",            FLASH_CMD_NONE}       \n};\n\nstruct error_bios {\n     char    *reason;\n     int     err_code;\n};\n\nstatic struct error_bios flash_error_table[] =\n{\n     {\"Failed to open bios image file\",      FAIL_OPEN_BIOS_FILE},\n     {\"PCI ID mismatch\",                     FAIL_CHECK_PCI_ID},\n     {\"Checksum mismatch\",                   FAIL_CHECK_SUM},\n     {\"Unknown Error\",                       FAIL_UNKNOWN},\n     {\"Failed to verify.\",                   FAIL_VERIFY},\n     {\"Failed to reset flash chip.\",         FAIL_RESET_FLASH},\n     {\"Failed to find flash chip type.\",     FAIL_FIND_FLASH_ID},\n     {\"Failed to erash flash chip.\",         FAIL_ERASE_FLASH},\n     {\"Failed to program flash chip.\",       FAIL_WRITE_FLASH},\n     {\"Flash in progress\",                   FLASH_IN_PROGRESS},\n     {\"Image file size Error\",               FAIL_FILE_SIZE},\n     {\"Input parameter error\",               FAIL_PARAMETERS},\n     {\"Out of memory\",                       FAIL_OUT_MEMORY},\n     {\"OK\", 0}\t \n};\n\nstatic ssize_t asd_store_update_bios(struct device *dev,\n\tstruct device_attribute *attr,\n\tconst char *buf, size_t count)\n{\n\tstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\n\tchar *cmd_ptr, *filename_ptr;\n\tstruct bios_file_header header, *hdr_ptr;\n\tint res, i;\n\tu32 csum = 0;\n\tint flash_command = FLASH_CMD_NONE;\n\tint err = 0;\n\n\tcmd_ptr = kcalloc(count, 2, GFP_KERNEL);\n\n\tif (!cmd_ptr) {\n\t\terr = FAIL_OUT_MEMORY;\n\t\tgoto out;\n\t}\n\n\tfilename_ptr = cmd_ptr + count;\n\tres = sscanf(buf, \"%s %s\", cmd_ptr, filename_ptr);\n\tif (res != 2) {\n\t\terr = FAIL_PARAMETERS;\n\t\tgoto out1;\n\t}\n\n\tfor (i = 0; flash_command_table[i].code != FLASH_CMD_NONE; i++) {\n\t\tif (!memcmp(flash_command_table[i].command,\n\t\t\t\t cmd_ptr, strlen(cmd_ptr))) {\n\t\t\tflash_command = flash_command_table[i].code;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (flash_command == FLASH_CMD_NONE) {\n\t\terr = FAIL_PARAMETERS;\n\t\tgoto out1;\n\t}\n\n\tif (asd_ha->bios_status == FLASH_IN_PROGRESS) {\n\t\terr = FLASH_IN_PROGRESS;\n\t\tgoto out1;\n\t}\n\terr = request_firmware(&asd_ha->bios_image,\n\t\t\t\t   filename_ptr,\n\t\t\t\t   &asd_ha->pcidev->dev);\n\tif (err) {\n\t\tasd_printk(\"Failed to load bios image file %s, error %d\\n\",\n\t\t\t   filename_ptr, err);\n\t\terr = FAIL_OPEN_BIOS_FILE;\n\t\tgoto out1;\n\t}\n\n\thdr_ptr = (struct bios_file_header *)asd_ha->bios_image->data;\n\n\tif ((hdr_ptr->contrl_id.vendor != asd_ha->pcidev->vendor ||\n\t\thdr_ptr->contrl_id.device != asd_ha->pcidev->device) &&\n\t\t(hdr_ptr->contrl_id.sub_vendor != asd_ha->pcidev->vendor ||\n\t\thdr_ptr->contrl_id.sub_device != asd_ha->pcidev->device)) {\n\n\t\tASD_DPRINTK(\"The PCI vendor or device id does not match\\n\");\n\t\tASD_DPRINTK(\"vendor=%x dev=%x sub_vendor=%x sub_dev=%x\"\n\t\t\" pci vendor=%x pci dev=%x\\n\",\n\t\thdr_ptr->contrl_id.vendor,\n\t\thdr_ptr->contrl_id.device,\n\t\thdr_ptr->contrl_id.sub_vendor,\n\t\thdr_ptr->contrl_id.sub_device,\n\t\tasd_ha->pcidev->vendor,\n\t\tasd_ha->pcidev->device);\n\t\terr = FAIL_CHECK_PCI_ID;\n\t\tgoto out2;\n\t}\n\n\tif (hdr_ptr->filelen != asd_ha->bios_image->size) {\n\t\terr = FAIL_FILE_SIZE;\n\t\tgoto out2;\n\t}\n\n\t \n\tfor (i = 0; i < hdr_ptr->filelen; i++)\n\t\tcsum += asd_ha->bios_image->data[i];\n\n\tif ((csum & 0x0000ffff) != hdr_ptr->checksum) {\n\t\tASD_DPRINTK(\"BIOS file checksum mismatch\\n\");\n\t\terr = FAIL_CHECK_SUM;\n\t\tgoto out2;\n\t}\n\tif (flash_command == FLASH_CMD_UPDATE) {\n\t\tasd_ha->bios_status = FLASH_IN_PROGRESS;\n\t\terr = asd_write_flash_seg(asd_ha,\n\t\t\t&asd_ha->bios_image->data[sizeof(*hdr_ptr)],\n\t\t\t0, hdr_ptr->filelen-sizeof(*hdr_ptr));\n\t\tif (!err)\n\t\t\terr = asd_verify_flash_seg(asd_ha,\n\t\t\t\t&asd_ha->bios_image->data[sizeof(*hdr_ptr)],\n\t\t\t\t0, hdr_ptr->filelen-sizeof(*hdr_ptr));\n\t} else {\n\t\tasd_ha->bios_status = FLASH_IN_PROGRESS;\n\t\terr = asd_verify_flash_seg(asd_ha,\n\t\t\t&asd_ha->bios_image->data[sizeof(header)],\n\t\t\t0, hdr_ptr->filelen-sizeof(header));\n\t}\n\nout2:\n\trelease_firmware(asd_ha->bios_image);\nout1:\n\tkfree(cmd_ptr);\nout:\n\tasd_ha->bios_status = err;\n\n\tif (!err)\n\t\treturn count;\n\telse\n\t\treturn -err;\n}\n\nstatic ssize_t asd_show_update_bios(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tint i;\n\tstruct asd_ha_struct *asd_ha = dev_to_asd_ha(dev);\n\n\tfor (i = 0; flash_error_table[i].err_code != 0; i++) {\n\t\tif (flash_error_table[i].err_code == asd_ha->bios_status)\n\t\t\tbreak;\n\t}\n\tif (asd_ha->bios_status != FLASH_IN_PROGRESS)\n\t\tasd_ha->bios_status = FLASH_OK;\n\n\treturn snprintf(buf, PAGE_SIZE, \"status=%x %s\\n\",\n\t\t\tflash_error_table[i].err_code,\n\t\t\tflash_error_table[i].reason);\n}\n\nstatic DEVICE_ATTR(update_bios, S_IRUGO|S_IWUSR,\n\tasd_show_update_bios, asd_store_update_bios);\n\nstatic int asd_create_dev_attrs(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\n\terr = device_create_file(&asd_ha->pcidev->dev, &dev_attr_aic_revision);\n\tif (err)\n\t\treturn err;\n\n\terr = device_create_file(&asd_ha->pcidev->dev, &dev_attr_bios_build);\n\tif (err)\n\t\tgoto err_rev;\n\n\terr = device_create_file(&asd_ha->pcidev->dev, &dev_attr_pcba_sn);\n\tif (err)\n\t\tgoto err_biosb;\n\terr = device_create_file(&asd_ha->pcidev->dev, &dev_attr_update_bios);\n\tif (err)\n\t\tgoto err_update_bios;\n\n\treturn 0;\n\nerr_update_bios:\n\tdevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_pcba_sn);\nerr_biosb:\n\tdevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_bios_build);\nerr_rev:\n\tdevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_aic_revision);\n\treturn err;\n}\n\nstatic void asd_remove_dev_attrs(struct asd_ha_struct *asd_ha)\n{\n\tdevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_aic_revision);\n\tdevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_bios_build);\n\tdevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_pcba_sn);\n\tdevice_remove_file(&asd_ha->pcidev->dev, &dev_attr_update_bios);\n}\n\n \nstatic const struct asd_pcidev_struct {\n\tconst char * name;\n\tint (*setup)(struct asd_ha_struct *asd_ha);\n} asd_pcidev_data[] = {\n\t \n\t{ .name  = \"Adaptec AIC-94xx SAS/SATA Host Adapter\",\n\t  .setup = asd_aic9410_setup\n\t},\n\t{ .name  = \"Adaptec AIC-9410W SAS/SATA Host Adapter\",\n\t  .setup = asd_aic9410_setup\n\t},\n\t{ .name  = \"Adaptec AIC-9405W SAS/SATA Host Adapter\",\n\t  .setup = asd_aic9405_setup\n\t},\n};\n\nstatic int asd_create_ha_caches(struct asd_ha_struct *asd_ha)\n{\n\tasd_ha->scb_pool = dma_pool_create(ASD_DRIVER_NAME \"_scb_pool\",\n\t\t\t\t\t   &asd_ha->pcidev->dev,\n\t\t\t\t\t   sizeof(struct scb),\n\t\t\t\t\t   8, 0);\n\tif (!asd_ha->scb_pool) {\n\t\tasd_printk(\"couldn't create scb pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void asd_free_edbs(struct asd_ha_struct *asd_ha)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tint i;\n\n\tfor (i = 0; i < seq->num_edbs; i++)\n\t\tasd_free_coherent(asd_ha, seq->edb_arr[i]);\n\tkfree(seq->edb_arr);\n\tseq->edb_arr = NULL;\n}\n\nstatic void asd_free_escbs(struct asd_ha_struct *asd_ha)\n{\n\tstruct asd_seq_data *seq = &asd_ha->seq;\n\tint i;\n\n\tfor (i = 0; i < seq->num_escbs; i++) {\n\t\tif (!list_empty(&seq->escb_arr[i]->list))\n\t\t\tlist_del_init(&seq->escb_arr[i]->list);\n\n\t\tasd_ascb_free(seq->escb_arr[i]);\n\t}\n\tkfree(seq->escb_arr);\n\tseq->escb_arr = NULL;\n}\n\nstatic void asd_destroy_ha_caches(struct asd_ha_struct *asd_ha)\n{\n\tint i;\n\n\tif (asd_ha->hw_prof.ddb_ext)\n\t\tasd_free_coherent(asd_ha, asd_ha->hw_prof.ddb_ext);\n\tif (asd_ha->hw_prof.scb_ext)\n\t\tasd_free_coherent(asd_ha, asd_ha->hw_prof.scb_ext);\n\n\tkfree(asd_ha->hw_prof.ddb_bitmap);\n\tasd_ha->hw_prof.ddb_bitmap = NULL;\n\n\tfor (i = 0; i < ASD_MAX_PHYS; i++) {\n\t\tstruct asd_phy *phy = &asd_ha->phys[i];\n\n\t\tasd_free_coherent(asd_ha, phy->id_frm_tok);\n\t}\n\tif (asd_ha->seq.escb_arr)\n\t\tasd_free_escbs(asd_ha);\n\tif (asd_ha->seq.edb_arr)\n\t\tasd_free_edbs(asd_ha);\n\tif (asd_ha->hw_prof.ue.area) {\n\t\tkfree(asd_ha->hw_prof.ue.area);\n\t\tasd_ha->hw_prof.ue.area = NULL;\n\t}\n\tif (asd_ha->seq.tc_index_array) {\n\t\tkfree(asd_ha->seq.tc_index_array);\n\t\tkfree(asd_ha->seq.tc_index_bitmap);\n\t\tasd_ha->seq.tc_index_array = NULL;\n\t\tasd_ha->seq.tc_index_bitmap = NULL;\n\t}\n\tif (asd_ha->seq.actual_dl) {\n\t\t\tasd_free_coherent(asd_ha, asd_ha->seq.actual_dl);\n\t\t\tasd_ha->seq.actual_dl = NULL;\n\t\t\tasd_ha->seq.dl = NULL;\n\t}\n\tif (asd_ha->seq.next_scb.vaddr) {\n\t\tdma_pool_free(asd_ha->scb_pool, asd_ha->seq.next_scb.vaddr,\n\t\t\t      asd_ha->seq.next_scb.dma_handle);\n\t\tasd_ha->seq.next_scb.vaddr = NULL;\n\t}\n\tdma_pool_destroy(asd_ha->scb_pool);\n\tasd_ha->scb_pool = NULL;\n}\n\nstruct kmem_cache *asd_dma_token_cache;\nstruct kmem_cache *asd_ascb_cache;\n\nstatic int asd_create_global_caches(void)\n{\n\tif (!asd_dma_token_cache) {\n\t\tasd_dma_token_cache\n\t\t\t= kmem_cache_create(ASD_DRIVER_NAME \"_dma_token\",\n\t\t\t\t\t    sizeof(struct asd_dma_tok),\n\t\t\t\t\t    0,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t    NULL);\n\t\tif (!asd_dma_token_cache) {\n\t\t\tasd_printk(\"couldn't create dma token cache\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (!asd_ascb_cache) {\n\t\tasd_ascb_cache = kmem_cache_create(ASD_DRIVER_NAME \"_ascb\",\n\t\t\t\t\t\t   sizeof(struct asd_ascb),\n\t\t\t\t\t\t   0,\n\t\t\t\t\t\t   SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t   NULL);\n\t\tif (!asd_ascb_cache) {\n\t\t\tasd_printk(\"couldn't create ascb cache\\n\");\n\t\t\tgoto Err;\n\t\t}\n\t}\n\n\treturn 0;\nErr:\n\tkmem_cache_destroy(asd_dma_token_cache);\n\tasd_dma_token_cache = NULL;\n\treturn -ENOMEM;\n}\n\nstatic void asd_destroy_global_caches(void)\n{\n\tkmem_cache_destroy(asd_dma_token_cache);\n\tasd_dma_token_cache = NULL;\n\n\tkmem_cache_destroy(asd_ascb_cache);\n\tasd_ascb_cache = NULL;\n}\n\nstatic int asd_register_sas_ha(struct asd_ha_struct *asd_ha)\n{\n\tint i;\n\tstruct asd_sas_phy   **sas_phys =\n\t\tkcalloc(ASD_MAX_PHYS, sizeof(*sas_phys), GFP_KERNEL);\n\tstruct asd_sas_port  **sas_ports =\n\t\tkcalloc(ASD_MAX_PHYS, sizeof(*sas_ports), GFP_KERNEL);\n\n\tif (!sas_phys || !sas_ports) {\n\t\tkfree(sas_phys);\n\t\tkfree(sas_ports);\n\t\treturn -ENOMEM;\n\t}\n\n\tasd_ha->sas_ha.sas_ha_name = (char *) asd_ha->name;\n\tasd_ha->sas_ha.sas_addr = &asd_ha->hw_prof.sas_addr[0];\n\n\tfor (i = 0; i < ASD_MAX_PHYS; i++) {\n\t\tsas_phys[i] = &asd_ha->phys[i].sas_phy;\n\t\tsas_ports[i] = &asd_ha->ports[i];\n\t}\n\n\tasd_ha->sas_ha.sas_phy = sas_phys;\n\tasd_ha->sas_ha.sas_port= sas_ports;\n\tasd_ha->sas_ha.num_phys= ASD_MAX_PHYS;\n\n\treturn sas_register_ha(&asd_ha->sas_ha);\n}\n\nstatic int asd_unregister_sas_ha(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\n\terr = sas_unregister_ha(&asd_ha->sas_ha);\n\n\tsas_remove_host(asd_ha->sas_ha.shost);\n\tscsi_host_put(asd_ha->sas_ha.shost);\n\n\tkfree(asd_ha->sas_ha.sas_phy);\n\tkfree(asd_ha->sas_ha.sas_port);\n\n\treturn err;\n}\n\nstatic int asd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tconst struct asd_pcidev_struct *asd_dev;\n\tunsigned asd_id = (unsigned) id->driver_data;\n\tstruct asd_ha_struct *asd_ha;\n\tstruct Scsi_Host *shost;\n\tint err;\n\n\tif (asd_id >= ARRAY_SIZE(asd_pcidev_data)) {\n\t\tasd_printk(\"wrong driver_data in PCI table\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((err = pci_enable_device(dev))) {\n\t\tasd_printk(\"couldn't enable device %s\\n\", pci_name(dev));\n\t\treturn err;\n\t}\n\n\tpci_set_master(dev);\n\n\terr = -ENOMEM;\n\n\tshost = scsi_host_alloc(&aic94xx_sht, sizeof(void *));\n\tif (!shost)\n\t\tgoto Err;\n\n\tasd_dev = &asd_pcidev_data[asd_id];\n\n\tasd_ha = kzalloc(sizeof(*asd_ha), GFP_KERNEL);\n\tif (!asd_ha) {\n\t\tasd_printk(\"out of memory\\n\");\n\t\tgoto Err_put;\n\t}\n\tasd_ha->pcidev = dev;\n\tasd_ha->sas_ha.dev = &asd_ha->pcidev->dev;\n\tasd_ha->sas_ha.lldd_ha = asd_ha;\n\n\tasd_ha->bios_status = FLASH_OK;\n\tasd_ha->name = asd_dev->name;\n\tasd_printk(\"found %s, device %s\\n\", asd_ha->name, pci_name(dev));\n\n\tSHOST_TO_SAS_HA(shost) = &asd_ha->sas_ha;\n\tasd_ha->sas_ha.shost = shost;\n\tshost->transportt = aic94xx_transport_template;\n\tshost->max_id = ~0;\n\tshost->max_lun = ~0;\n\tshost->max_cmd_len = 16;\n\n\terr = scsi_add_host(shost, &dev->dev);\n\tif (err)\n\t\tgoto Err_free;\n\n\terr = asd_dev->setup(asd_ha);\n\tif (err)\n\t\tgoto Err_remove;\n\n\terr = dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(64));\n\tif (err)\n\t\terr = dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\terr = -ENODEV;\n\t\tasd_printk(\"no suitable DMA mask for %s\\n\", pci_name(dev));\n\t\tgoto Err_remove;\n\t}\n\n\tpci_set_drvdata(dev, asd_ha);\n\n\terr = asd_map_ha(asd_ha);\n\tif (err)\n\t\tgoto Err_remove;\n\n\terr = asd_create_ha_caches(asd_ha);\n        if (err)\n\t\tgoto Err_unmap;\n\n\terr = asd_init_hw(asd_ha);\n\tif (err)\n\t\tgoto Err_free_cache;\n\n\tasd_printk(\"device %s: SAS addr %llx, PCBA SN %s, %d phys, %d enabled \"\n\t\t   \"phys, flash %s, BIOS %s%d\\n\",\n\t\t   pci_name(dev), SAS_ADDR(asd_ha->hw_prof.sas_addr),\n\t\t   asd_ha->hw_prof.pcba_sn, asd_ha->hw_prof.max_phys,\n\t\t   asd_ha->hw_prof.num_phys,\n\t\t   asd_ha->hw_prof.flash.present ? \"present\" : \"not present\",\n\t\t   asd_ha->hw_prof.bios.present ? \"build \" : \"not present\",\n\t\t   asd_ha->hw_prof.bios.bld);\n\n\tshost->can_queue = asd_ha->seq.can_queue;\n\n\tif (use_msi)\n\t\tpci_enable_msi(asd_ha->pcidev);\n\n\terr = request_irq(asd_ha->pcidev->irq, asd_hw_isr, IRQF_SHARED,\n\t\t\t  ASD_DRIVER_NAME, asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't get irq %d for %s\\n\",\n\t\t\t   asd_ha->pcidev->irq, pci_name(asd_ha->pcidev));\n\t\tgoto Err_irq;\n\t}\n\tasd_enable_ints(asd_ha);\n\n\terr = asd_init_post_escbs(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't post escbs for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\tgoto Err_escbs;\n\t}\n\tASD_DPRINTK(\"escbs posted\\n\");\n\n\terr = asd_create_dev_attrs(asd_ha);\n\tif (err)\n\t\tgoto Err_dev_attrs;\n\n\terr = asd_register_sas_ha(asd_ha);\n\tif (err)\n\t\tgoto Err_reg_sas;\n\n\tscsi_scan_host(shost);\n\n\treturn 0;\n\nErr_reg_sas:\n\tasd_remove_dev_attrs(asd_ha);\nErr_dev_attrs:\nErr_escbs:\n\tasd_disable_ints(asd_ha);\n\tfree_irq(dev->irq, asd_ha);\nErr_irq:\n\tif (use_msi)\n\t\tpci_disable_msi(dev);\n\tasd_chip_hardrst(asd_ha);\nErr_free_cache:\n\tasd_destroy_ha_caches(asd_ha);\nErr_unmap:\n\tasd_unmap_ha(asd_ha);\nErr_remove:\n\tscsi_remove_host(shost);\nErr_free:\n\tkfree(asd_ha);\nErr_put:\n\tscsi_host_put(shost);\nErr:\n\tpci_disable_device(dev);\n\treturn err;\n}\n\nstatic void asd_free_queues(struct asd_ha_struct *asd_ha)\n{\n\tunsigned long flags;\n\tLIST_HEAD(pending);\n\tstruct list_head *n, *pos;\n\n\tspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\n\tasd_ha->seq.pending = 0;\n\tlist_splice_init(&asd_ha->seq.pend_q, &pending);\n\tspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\n\n\tif (!list_empty(&pending))\n\t\tASD_DPRINTK(\"Uh-oh! Pending is not empty!\\n\");\n\n\tlist_for_each_safe(pos, n, &pending) {\n\t\tstruct asd_ascb *ascb = list_entry(pos, struct asd_ascb, list);\n\t\t \n\t\tdel_timer_sync(&ascb->timer);\n\t\tWARN_ON(ascb->scb->header.opcode != CONTROL_PHY);\n\n\t\tlist_del_init(pos);\n\t\tASD_DPRINTK(\"freeing from pending\\n\");\n\t\tasd_ascb_free(ascb);\n\t}\n}\n\nstatic void asd_turn_off_leds(struct asd_ha_struct *asd_ha)\n{\n\tu8 phy_mask = asd_ha->hw_prof.enabled_phys;\n\tu8 i;\n\n\tfor_each_phy(phy_mask, phy_mask, i) {\n\t\tasd_turn_led(asd_ha, i, 0);\n\t\tasd_control_led(asd_ha, i, 0);\n\t}\n}\n\nstatic void asd_pci_remove(struct pci_dev *dev)\n{\n\tstruct asd_ha_struct *asd_ha = pci_get_drvdata(dev);\n\n\tif (!asd_ha)\n\t\treturn;\n\n\tasd_unregister_sas_ha(asd_ha);\n\n\tasd_disable_ints(asd_ha);\n\n\tasd_remove_dev_attrs(asd_ha);\n\n\t \n\n\tfree_irq(dev->irq, asd_ha);\n\tif (use_msi)\n\t\tpci_disable_msi(asd_ha->pcidev);\n\tasd_turn_off_leds(asd_ha);\n\tasd_chip_hardrst(asd_ha);\n\tasd_free_queues(asd_ha);\n\tasd_destroy_ha_caches(asd_ha);\n\tasd_unmap_ha(asd_ha);\n\tkfree(asd_ha);\n\tpci_disable_device(dev);\n\treturn;\n}\n\nstatic void asd_scan_start(struct Scsi_Host *shost)\n{\n\tstruct asd_ha_struct *asd_ha;\n\tint err;\n\n\tasd_ha = SHOST_TO_SAS_HA(shost)->lldd_ha;\n\terr = asd_enable_phys(asd_ha, asd_ha->hw_prof.enabled_phys);\n\tif (err)\n\t\tasd_printk(\"Couldn't enable phys, err:%d\\n\", err);\n}\n\nstatic int asd_scan_finished(struct Scsi_Host *shost, unsigned long time)\n{\n\t \n\tif (time < HZ)\n\t\treturn 0;\n\t \n\tsas_drain_work(SHOST_TO_SAS_HA(shost));\n\treturn 1;\n}\n\nstatic ssize_t version_show(struct device_driver *driver, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ASD_DRIVER_VERSION);\n}\nstatic DRIVER_ATTR_RO(version);\n\nstatic int asd_create_driver_attrs(struct device_driver *driver)\n{\n\treturn driver_create_file(driver, &driver_attr_version);\n}\n\nstatic void asd_remove_driver_attrs(struct device_driver *driver)\n{\n\tdriver_remove_file(driver, &driver_attr_version);\n}\n\nstatic struct sas_domain_function_template aic94xx_transport_functions = {\n\t.lldd_dev_found\t\t= asd_dev_found,\n\t.lldd_dev_gone\t\t= asd_dev_gone,\n\n\t.lldd_execute_task\t= asd_execute_task,\n\n\t.lldd_abort_task\t= asd_abort_task,\n\t.lldd_abort_task_set\t= asd_abort_task_set,\n\t.lldd_clear_task_set\t= asd_clear_task_set,\n\t.lldd_I_T_nexus_reset\t= asd_I_T_nexus_reset,\n\t.lldd_lu_reset\t\t= asd_lu_reset,\n\t.lldd_query_task\t= asd_query_task,\n\n\t.lldd_clear_nexus_port\t= asd_clear_nexus_port,\n\t.lldd_clear_nexus_ha\t= asd_clear_nexus_ha,\n\n\t.lldd_control_phy\t= asd_control_phy,\n\n\t.lldd_ata_set_dmamode\t= asd_set_dmamode,\n};\n\nstatic const struct pci_device_id aic94xx_pci_table[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x410),0, 0, 1},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x412),0, 0, 1},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x416),0, 0, 1},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x41E),0, 0, 1},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x41F),0, 0, 1},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x430),0, 0, 2},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x432),0, 0, 2},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x43E),0, 0, 2},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ADAPTEC2, 0x43F),0, 0, 2},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, aic94xx_pci_table);\n\nstatic struct pci_driver aic94xx_pci_driver = {\n\t.name\t\t= ASD_DRIVER_NAME,\n\t.id_table\t= aic94xx_pci_table,\n\t.probe\t\t= asd_pci_probe,\n\t.remove\t\t= asd_pci_remove,\n};\n\nstatic int __init aic94xx_init(void)\n{\n\tint err;\n\n\n\tasd_printk(\"%s version %s loaded\\n\", ASD_DRIVER_DESCRIPTION,\n\t\t   ASD_DRIVER_VERSION);\n\n\terr = asd_create_global_caches();\n\tif (err)\n\t\treturn err;\n\n\taic94xx_transport_template =\n\t\tsas_domain_attach_transport(&aic94xx_transport_functions);\n\tif (!aic94xx_transport_template) {\n\t\terr = -ENOMEM;\n\t\tgoto out_destroy_caches;\n\t}\n\n\terr = pci_register_driver(&aic94xx_pci_driver);\n\tif (err)\n\t\tgoto out_release_transport;\n\n\terr = asd_create_driver_attrs(&aic94xx_pci_driver.driver);\n\tif (err)\n\t\tgoto out_unregister_pcidrv;\n\n\treturn err;\n\n out_unregister_pcidrv:\n\tpci_unregister_driver(&aic94xx_pci_driver);\n out_release_transport:\n\tsas_release_transport(aic94xx_transport_template);\n out_destroy_caches:\n\tasd_destroy_global_caches();\n\n\treturn err;\n}\n\nstatic void __exit aic94xx_exit(void)\n{\n\tasd_remove_driver_attrs(&aic94xx_pci_driver.driver);\n\tpci_unregister_driver(&aic94xx_pci_driver);\n\tsas_release_transport(aic94xx_transport_template);\n\tasd_release_firmware();\n\tasd_destroy_global_caches();\n\tasd_printk(\"%s version %s unloaded\\n\", ASD_DRIVER_DESCRIPTION,\n\t\t   ASD_DRIVER_VERSION);\n}\n\nmodule_init(aic94xx_init);\nmodule_exit(aic94xx_exit);\n\nMODULE_AUTHOR(\"Luben Tuikov <luben_tuikov@adaptec.com>\");\nMODULE_DESCRIPTION(ASD_DRIVER_DESCRIPTION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(ASD_DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}