{
  "module_name": "aic94xx_hwi.h",
  "hash_id": "652f87952fdb30c965878c5726098ef041b58cc83e47b0323b5fe3566d2d9df2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_hwi.h",
  "human_readable_source": " \n \n\n#ifndef _AIC94XX_HWI_H_\n#define _AIC94XX_HWI_H_\n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n\n#include <scsi/libsas.h>\n\n#include \"aic94xx.h\"\n#include \"aic94xx_sas.h\"\n\n \n#define ASD_MAX_PHYS       8\n#define ASD_PCBA_SN_SIZE   12\n\nstruct asd_ha_addrspace {\n\tvoid __iomem  *addr;\n\tunsigned long  start;        \n\tunsigned long  len;          \n\tunsigned long  flags;        \n\n\t \n\tu32 swa_base;  \n\tu32 swb_base;\n\tu32 swc_base;\n};\n\nstruct bios_struct {\n\tint    present;\n\tu8     maj;\n\tu8     min;\n\tu32    bld;\n};\n\nstruct unit_element_struct {\n\tu16    num;\n\tu16    size;\n\tvoid   *area;\n};\n\nstruct flash_struct {\n\tu32    bar;\n\tint    present;\n\tint    wide;\n\tu8     manuf;\n\tu8     dev_id;\n\tu8     sec_prot;\n\tu8     method;\n\n\tu32    dir_offs;\n};\n\nstruct asd_phy_desc {\n\t \n\tu8     sas_addr[SAS_ADDR_SIZE];\n\tu8     max_sas_lrate;\n\tu8     min_sas_lrate;\n\tu8     max_sata_lrate;\n\tu8     min_sata_lrate;\n\tu8     flags;\n#define ASD_CRC_DIS  1\n#define ASD_SATA_SPINUP_HOLD 2\n\n\tu8     phy_control_0;  \n\tu8     phy_control_1;  \n\tu8     phy_control_2;  \n\tu8     phy_control_3;  \n};\n\nstruct asd_dma_tok {\n\tvoid *vaddr;\n\tdma_addr_t dma_handle;\n\tsize_t size;\n};\n\nstruct hw_profile {\n\tstruct bios_struct bios;\n\tstruct unit_element_struct ue;\n\tstruct flash_struct flash;\n\n\tu8     sas_addr[SAS_ADDR_SIZE];\n\tchar   pcba_sn[ASD_PCBA_SN_SIZE+1];\n\n\tu8     enabled_phys;\t   \n\tstruct asd_phy_desc phy_desc[ASD_MAX_PHYS];\n\tu32    max_scbs;\t   \n\tstruct asd_dma_tok *scb_ext;\n\tu32    max_ddbs;\n\tstruct asd_dma_tok *ddb_ext;\n\n\tspinlock_t ddb_lock;\n\tvoid  *ddb_bitmap;\n\n\tint    num_phys;\t   \n\tint    max_phys;\t   \n\n\tunsigned addr_range;\t   \n\tunsigned port_name_base;\n\tunsigned dev_name_base;\n\tunsigned sata_name_base;\n};\n\nstruct asd_ascb {\n\tstruct list_head list;\n\tstruct asd_ha_struct *ha;\n\n\tstruct scb *scb;\t   \n\tstruct asd_dma_tok dma_scb;\n\tstruct asd_dma_tok *sg_arr;\n\n\tvoid (*tasklet_complete)(struct asd_ascb *, struct done_list_struct *);\n\tu8     uldd_timer:1;\n\n\t \n\tstruct timer_list timer;\n\tstruct completion *completion;\n\tu8        tag_valid:1;\n\t__be16    tag;\t\t   \n\n\t \n\tint    edb_index;\n\n\t \n\tint    tc_index;\n\n\tvoid   *uldd_task;\n};\n\n#define ASD_DL_SIZE_BITS   0x8\n#define ASD_DL_SIZE        (1<<(2+ASD_DL_SIZE_BITS))\n#define ASD_DEF_DL_TOGGLE  0x01\n\nstruct asd_seq_data {\n\tspinlock_t pend_q_lock;\n\tu16    scbpro;\n\tint    pending;\n\tstruct list_head pend_q;\n\tint    can_queue;\t   \n\tstruct asd_dma_tok next_scb;  \n\n\tspinlock_t tc_index_lock;\n\tvoid **tc_index_array;\n\tvoid *tc_index_bitmap;\n\tint   tc_index_bitmap_bits;\n\n\tstruct tasklet_struct dl_tasklet;\n\tstruct done_list_struct *dl;  \n\tstruct asd_dma_tok *actual_dl;  \n\tint    dl_toggle;\n\tint    dl_next;\n\n\tint    num_edbs;\n\tstruct asd_dma_tok **edb_arr;\n\tint    num_escbs;\n\tstruct asd_ascb **escb_arr;  \n};\n\n \nstruct asd_port {\n\tu8  sas_addr[SAS_ADDR_SIZE];\n\tu8  attached_sas_addr[SAS_ADDR_SIZE];\n\tu32 phy_mask;\n\tint num_phys;\n};\n\n \nstruct asd_ha_struct {\n\tstruct pci_dev   *pcidev;\n\tconst char       *name;\n\n\tstruct sas_ha_struct sas_ha;\n\n\tu8                revision_id;\n\n\tint               iospace;\n\tspinlock_t        iolock;\n\tstruct asd_ha_addrspace io_handle[2];\n\n\tstruct hw_profile hw_prof;\n\n\tstruct asd_phy    phys[ASD_MAX_PHYS];\n\tspinlock_t        asd_ports_lock;\n\tstruct asd_port   asd_ports[ASD_MAX_PHYS];\n\tstruct asd_sas_port   ports[ASD_MAX_PHYS];\n\n\tstruct dma_pool  *scb_pool;\n\n\tstruct asd_seq_data  seq;  \n\tu32    bios_status;\n\tconst struct firmware *bios_image;\n};\n\n \n\n#define ASD_BUSADDR_LO(__dma_handle) ((u32)(__dma_handle))\n#define ASD_BUSADDR_HI(__dma_handle) (((sizeof(dma_addr_t))==8)     \\\n                                    ? ((u32)((__dma_handle) >> 32)) \\\n                                    : ((u32)0))\n\n#define dev_to_asd_ha(__dev)  pci_get_drvdata(to_pci_dev(__dev))\n#define SCB_SITE_VALID(__site_no) (((__site_no) & 0xF0FF) != 0x00FF   \\\n\t\t\t\t && ((__site_no) & 0xF0FF) > 0x001F)\n \n#define for_each_sequencer(__lseq_mask, __mc, __lseq)                        \\\n\tfor ((__mc)=(__lseq_mask),(__lseq)=0;(__mc)!=0;(__lseq++),(__mc)>>=1)\\\n\t\tif (((__mc) & 1))\n#define for_each_phy(__lseq_mask, __mc, __lseq)                              \\\n\tfor ((__mc)=(__lseq_mask),(__lseq)=0;(__mc)!=0;(__lseq++),(__mc)>>=1)\\\n\t\tif (((__mc) & 1))\n\n#define PHY_ENABLED(_HA, _I) ((_HA)->hw_prof.enabled_phys & (1<<(_I)))\n\n \n\nstatic inline struct asd_dma_tok *asd_dmatok_alloc(gfp_t flags)\n{\n\treturn kmem_cache_alloc(asd_dma_token_cache, flags);\n}\n\nstatic inline void asd_dmatok_free(struct asd_dma_tok *token)\n{\n\tkmem_cache_free(asd_dma_token_cache, token);\n}\n\nstatic inline struct asd_dma_tok *asd_alloc_coherent(struct asd_ha_struct *\n\t\t\t\t\t\t     asd_ha, size_t size,\n\t\t\t\t\t\t     gfp_t flags)\n{\n\tstruct asd_dma_tok *token = asd_dmatok_alloc(flags);\n\tif (token) {\n\t\ttoken->size = size;\n\t\ttoken->vaddr = dma_alloc_coherent(&asd_ha->pcidev->dev,\n\t\t\t\t\t\t  token->size,\n\t\t\t\t\t\t  &token->dma_handle,\n\t\t\t\t\t\t  flags);\n\t\tif (!token->vaddr) {\n\t\t\tasd_dmatok_free(token);\n\t\t\ttoken = NULL;\n\t\t}\n\t}\n\treturn token;\n}\n\nstatic inline void asd_free_coherent(struct asd_ha_struct *asd_ha,\n\t\t\t\t     struct asd_dma_tok *token)\n{\n\tif (token) {\n\t\tdma_free_coherent(&asd_ha->pcidev->dev, token->size,\n\t\t\t\t  token->vaddr, token->dma_handle);\n\t\tasd_dmatok_free(token);\n\t}\n}\n\nstatic inline void asd_init_ascb(struct asd_ha_struct *asd_ha,\n\t\t\t\t struct asd_ascb *ascb)\n{\n\tINIT_LIST_HEAD(&ascb->list);\n\tascb->scb = ascb->dma_scb.vaddr;\n\tascb->ha = asd_ha;\n\ttimer_setup(&ascb->timer, NULL, 0);\n\tascb->tc_index = -1;\n}\n\n \nstatic inline void asd_tc_index_release(struct asd_seq_data *seq, int index)\n{\n\tseq->tc_index_array[index] = NULL;\n\tclear_bit(index, seq->tc_index_bitmap);\n}\n\n \nstatic inline int asd_tc_index_get(struct asd_seq_data *seq, void *ptr)\n{\n\tint index;\n\n\tindex = find_first_zero_bit(seq->tc_index_bitmap,\n\t\t\t\t    seq->tc_index_bitmap_bits);\n\tif (index == seq->tc_index_bitmap_bits)\n\t\treturn -1;\n\n\tseq->tc_index_array[index] = ptr;\n\tset_bit(index, seq->tc_index_bitmap);\n\n\treturn index;\n}\n\n \nstatic inline void *asd_tc_index_find(struct asd_seq_data *seq, int index)\n{\n\treturn seq->tc_index_array[index];\n}\n\n \nstatic inline void asd_ascb_free(struct asd_ascb *ascb)\n{\n\tif (ascb) {\n\t\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\t\tunsigned long flags;\n\n\t\tBUG_ON(!list_empty(&ascb->list));\n\t\tspin_lock_irqsave(&ascb->ha->seq.tc_index_lock, flags);\n\t\tasd_tc_index_release(&ascb->ha->seq, ascb->tc_index);\n\t\tspin_unlock_irqrestore(&ascb->ha->seq.tc_index_lock, flags);\n\t\tdma_pool_free(asd_ha->scb_pool, ascb->dma_scb.vaddr,\n\t\t\t      ascb->dma_scb.dma_handle);\n\t\tkmem_cache_free(asd_ascb_cache, ascb);\n\t}\n}\n\n \nstatic inline void asd_ascb_free_list(struct asd_ascb *ascb_list)\n{\n\tLIST_HEAD(list);\n\tstruct list_head *n, *pos;\n\n\t__list_add(&list, ascb_list->list.prev, &ascb_list->list);\n\tlist_for_each_safe(pos, n, &list) {\n\t\tlist_del_init(pos);\n\t\tasd_ascb_free(list_entry(pos, struct asd_ascb, list));\n\t}\n}\n\n \n\nint  asd_init_hw(struct asd_ha_struct *asd_ha);\nirqreturn_t asd_hw_isr(int irq, void *dev_id);\n\n\nstruct asd_ascb *asd_ascb_alloc_list(struct asd_ha_struct\n\t\t\t\t     *asd_ha, int *num,\n\t\t\t\t     gfp_t gfp_mask);\n\nint  asd_post_ascb_list(struct asd_ha_struct *asd_ha, struct asd_ascb *ascb,\n\t\t\tint num);\nint  asd_post_escb_list(struct asd_ha_struct *asd_ha, struct asd_ascb *ascb,\n\t\t\tint num);\n\nint  asd_init_post_escbs(struct asd_ha_struct *asd_ha);\nvoid asd_build_control_phy(struct asd_ascb *ascb, int phy_id, u8 subfunc);\nvoid asd_control_led(struct asd_ha_struct *asd_ha, int phy_id, int op);\nvoid asd_turn_led(struct asd_ha_struct *asd_ha, int phy_id, int op);\nint  asd_enable_phys(struct asd_ha_struct *asd_ha, const u8 phy_mask);\n\nvoid asd_ascb_timedout(struct timer_list *t);\nint  asd_chip_hardrst(struct asd_ha_struct *asd_ha);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}