{
  "module_name": "aic94xx_seq.c",
  "hash_id": "1f351abbae836eaa7628ed8c0a617ca6ba62fe10c448e34f04eaf0533914d7be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_seq.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include \"aic94xx_reg.h\"\n#include \"aic94xx_hwi.h\"\n\n#include \"aic94xx_seq.h\"\n#include \"aic94xx_dump.h\"\n\n \n#define PAUSE_DELAY 1\n#define PAUSE_TRIES 1000\n\nstatic const struct firmware *sequencer_fw;\nstatic u16 cseq_vecs[CSEQ_NUM_VECS], lseq_vecs[LSEQ_NUM_VECS], mode2_task,\n\tcseq_idle_loop, lseq_idle_loop;\nstatic const u8 *cseq_code, *lseq_code;\nstatic u32 cseq_code_size, lseq_code_size;\n\nstatic u16 first_scb_site_no = 0xFFFF;\nstatic u16 last_scb_site_no;\n\n \n\n \nstatic int asd_pause_cseq(struct asd_ha_struct *asd_ha)\n{\n\tint\tcount = PAUSE_TRIES;\n\tu32\tarp2ctl;\n\n\tarp2ctl = asd_read_reg_dword(asd_ha, CARP2CTL);\n\tif (arp2ctl & PAUSED)\n\t\treturn 0;\n\n\tasd_write_reg_dword(asd_ha, CARP2CTL, arp2ctl | EPAUSE);\n\tdo {\n\t\tarp2ctl = asd_read_reg_dword(asd_ha, CARP2CTL);\n\t\tif (arp2ctl & PAUSED)\n\t\t\treturn 0;\n\t\tudelay(PAUSE_DELAY);\n\t} while (--count > 0);\n\n\tASD_DPRINTK(\"couldn't pause CSEQ\\n\");\n\treturn -1;\n}\n\n \nstatic int asd_unpause_cseq(struct asd_ha_struct *asd_ha)\n{\n\tu32\tarp2ctl;\n\tint\tcount = PAUSE_TRIES;\n\n\tarp2ctl = asd_read_reg_dword(asd_ha, CARP2CTL);\n\tif (!(arp2ctl & PAUSED))\n\t\treturn 0;\n\n\tasd_write_reg_dword(asd_ha, CARP2CTL, arp2ctl & ~EPAUSE);\n\tdo {\n\t\tarp2ctl = asd_read_reg_dword(asd_ha, CARP2CTL);\n\t\tif (!(arp2ctl & PAUSED))\n\t\t\treturn 0;\n\t\tudelay(PAUSE_DELAY);\n\t} while (--count > 0);\n\n\tASD_DPRINTK(\"couldn't unpause the CSEQ\\n\");\n\treturn -1;\n}\n\n \nstatic int asd_seq_pause_lseq(struct asd_ha_struct *asd_ha, int lseq)\n{\n\tu32    arp2ctl;\n\tint    count = PAUSE_TRIES;\n\n\tarp2ctl = asd_read_reg_dword(asd_ha, LmARP2CTL(lseq));\n\tif (arp2ctl & PAUSED)\n\t\treturn 0;\n\n\tasd_write_reg_dword(asd_ha, LmARP2CTL(lseq), arp2ctl | EPAUSE);\n\tdo {\n\t\tarp2ctl = asd_read_reg_dword(asd_ha, LmARP2CTL(lseq));\n\t\tif (arp2ctl & PAUSED)\n\t\t\treturn 0;\n\t\tudelay(PAUSE_DELAY);\n\t} while (--count > 0);\n\n\tASD_DPRINTK(\"couldn't pause LSEQ %d\\n\", lseq);\n\treturn -1;\n}\n\n \nstatic int asd_pause_lseq(struct asd_ha_struct *asd_ha, u8 lseq_mask)\n{\n\tint lseq;\n\tint err = 0;\n\n\tfor_each_sequencer(lseq_mask, lseq_mask, lseq) {\n\t\terr = asd_seq_pause_lseq(asd_ha, lseq);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\n\n \nstatic int asd_seq_unpause_lseq(struct asd_ha_struct *asd_ha, int lseq)\n{\n\tu32 arp2ctl;\n\tint count = PAUSE_TRIES;\n\n\tarp2ctl = asd_read_reg_dword(asd_ha, LmARP2CTL(lseq));\n\tif (!(arp2ctl & PAUSED))\n\t\treturn 0;\n\n\tasd_write_reg_dword(asd_ha, LmARP2CTL(lseq), arp2ctl & ~EPAUSE);\n\tdo {\n\t\tarp2ctl = asd_read_reg_dword(asd_ha, LmARP2CTL(lseq));\n\t\tif (!(arp2ctl & PAUSED))\n\t\t\treturn 0;\n\t\tudelay(PAUSE_DELAY);\n\t} while (--count > 0);\n\n\tASD_DPRINTK(\"couldn't unpause LSEQ %d\\n\", lseq);\n\treturn 0;\n}\n\n\n \n\nstatic int asd_verify_cseq(struct asd_ha_struct *asd_ha, const u8 *_prog,\n\t\t\t   u32 size)\n{\n\tu32 addr = CSEQ_RAM_REG_BASE_ADR;\n\tconst u32 *prog = (u32 *) _prog;\n\tu32 i;\n\n\tfor (i = 0; i < size; i += 4, prog++, addr += 4) {\n\t\tu32 val = asd_read_reg_dword(asd_ha, addr);\n\n\t\tif (le32_to_cpu(*prog) != val) {\n\t\t\tasd_printk(\"%s: cseq verify failed at %u \"\n\t\t\t\t   \"read:0x%x, wanted:0x%x\\n\",\n\t\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t\t   i, val, le32_to_cpu(*prog));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tASD_DPRINTK(\"verified %d bytes, passed\\n\", size);\n\treturn 0;\n}\n\n \nstatic int asd_verify_lseq(struct asd_ha_struct *asd_ha, const u8 *_prog,\n\t\t\t   u32 size, int lseq)\n{\n#define LSEQ_CODEPAGE_SIZE 4096\n\tint pages =  (size + LSEQ_CODEPAGE_SIZE - 1) / LSEQ_CODEPAGE_SIZE;\n\tu32 page;\n\tconst u32 *prog = (u32 *) _prog;\n\n\tfor (page = 0; page < pages; page++) {\n\t\tu32 i;\n\n\t\tasd_write_reg_dword(asd_ha, LmBISTCTL1(lseq),\n\t\t\t\t    page << LmRAMPAGE_LSHIFT);\n\t\tfor (i = 0; size > 0 && i < LSEQ_CODEPAGE_SIZE;\n\t\t     i += 4, prog++, size-=4) {\n\n\t\t\tu32 val = asd_read_reg_dword(asd_ha, LmSEQRAM(lseq)+i);\n\n\t\t\tif (le32_to_cpu(*prog) != val) {\n\t\t\t\tasd_printk(\"%s: LSEQ%d verify failed \"\n\t\t\t\t\t   \"page:%d, offs:%d\\n\",\n\t\t\t\t\t   pci_name(asd_ha->pcidev),\n\t\t\t\t\t   lseq, page, i);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tASD_DPRINTK(\"LSEQ%d verified %d bytes, passed\\n\", lseq,\n\t\t    (int)((u8 *)prog-_prog));\n\treturn 0;\n}\n\n \nstatic int asd_verify_seq(struct asd_ha_struct *asd_ha, const u8 *prog,\n\t\t\t      u32 size, u8 lseq_mask)\n{\n\tif (lseq_mask == 0)\n\t\treturn asd_verify_cseq(asd_ha, prog, size);\n\telse {\n\t\tint lseq, err;\n\n\t\tfor_each_sequencer(lseq_mask, lseq_mask, lseq) {\n\t\t\terr = asd_verify_lseq(asd_ha, prog, size, lseq);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#define ASD_DMA_MODE_DOWNLOAD\n#ifdef ASD_DMA_MODE_DOWNLOAD\n \n#define MAX_DMA_OVLY_COUNT ((1U << 14)-1)\nstatic int asd_download_seq(struct asd_ha_struct *asd_ha,\n\t\t\t    const u8 * const prog, u32 size, u8 lseq_mask)\n{\n\tu32 comstaten;\n\tu32 reg;\n\tint page;\n\tconst int pages = (size + MAX_DMA_OVLY_COUNT - 1) / MAX_DMA_OVLY_COUNT;\n\tstruct asd_dma_tok *token;\n\tint err = 0;\n\n\tif (size % 4) {\n\t\tasd_printk(\"sequencer program not multiple of 4\\n\");\n\t\treturn -1;\n\t}\n\n\tasd_pause_cseq(asd_ha);\n\tasd_pause_lseq(asd_ha, 0xFF);\n\n\t \n\tcomstaten = asd_read_reg_dword(asd_ha, COMSTATEN);\n\tasd_write_reg_dword(asd_ha, COMSTATEN, 0);\n\tasd_write_reg_dword(asd_ha, COMSTAT, COMSTAT_MASK);\n\n\tasd_write_reg_dword(asd_ha, CHIMINTEN, RST_CHIMINTEN);\n\tasd_write_reg_dword(asd_ha, CHIMINT, CHIMINT_MASK);\n\n\ttoken = asd_alloc_coherent(asd_ha, MAX_DMA_OVLY_COUNT, GFP_KERNEL);\n\tif (!token) {\n\t\tasd_printk(\"out of memory for dma SEQ download\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tASD_DPRINTK(\"dma-ing %d bytes\\n\", size);\n\n\tfor (page = 0; page < pages; page++) {\n\t\tint i;\n\t\tu32 left = min(size-page*MAX_DMA_OVLY_COUNT,\n\t\t\t       (u32)MAX_DMA_OVLY_COUNT);\n\n\t\tmemcpy(token->vaddr, prog + page*MAX_DMA_OVLY_COUNT, left);\n\t\tasd_write_reg_addr(asd_ha, OVLYDMAADR, token->dma_handle);\n\t\tasd_write_reg_dword(asd_ha, OVLYDMACNT, left);\n\t\treg = !page ? RESETOVLYDMA : 0;\n\t\treg |= (STARTOVLYDMA | OVLYHALTERR);\n\t\treg |= (lseq_mask ? (((u32)lseq_mask) << 8) : OVLYCSEQ);\n\t\t \n\t\tasd_write_reg_dword(asd_ha, OVLYDMACTL, reg);\n\n\t\tfor (i = PAUSE_TRIES*100; i > 0; i--) {\n\t\t\tu32 dmadone = asd_read_reg_dword(asd_ha, OVLYDMACTL);\n\t\t\tif (!(dmadone & OVLYDMAACT))\n\t\t\t\tbreak;\n\t\t\tudelay(PAUSE_DELAY);\n\t\t}\n\t}\n\n\treg = asd_read_reg_dword(asd_ha, COMSTAT);\n\tif (!(reg & OVLYDMADONE) || (reg & OVLYERR)\n\t    || (asd_read_reg_dword(asd_ha, CHIMINT) & DEVEXCEPT_MASK)){\n\t\tasd_printk(\"%s: error DMA-ing sequencer code\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\terr = -ENODEV;\n\t}\n\n\tasd_free_coherent(asd_ha, token);\n out:\n\tasd_write_reg_dword(asd_ha, COMSTATEN, comstaten);\n\n\treturn err ? : asd_verify_seq(asd_ha, prog, size, lseq_mask);\n}\n#else  \nstatic int asd_download_seq(struct asd_ha_struct *asd_ha, const u8 *_prog,\n\t\t\t    u32 size, u8 lseq_mask)\n{\n\tint i;\n\tu32 reg = 0;\n\tconst u32 *prog = (u32 *) _prog;\n\n\tif (size % 4) {\n\t\tasd_printk(\"sequencer program not multiple of 4\\n\");\n\t\treturn -1;\n\t}\n\n\tasd_pause_cseq(asd_ha);\n\tasd_pause_lseq(asd_ha, 0xFF);\n\n\treg |= (lseq_mask ? (((u32)lseq_mask) << 8) : OVLYCSEQ);\n\treg |= PIOCMODE;\n\n\tasd_write_reg_dword(asd_ha, OVLYDMACNT, size);\n\tasd_write_reg_dword(asd_ha, OVLYDMACTL, reg);\n\n\tASD_DPRINTK(\"downloading %s sequencer%s in PIO mode...\\n\",\n\t\t    lseq_mask ? \"LSEQ\" : \"CSEQ\", lseq_mask ? \"s\" : \"\");\n\n\tfor (i = 0; i < size; i += 4, prog++)\n\t\tasd_write_reg_dword(asd_ha, SPIODATA, *prog);\n\n\treg = (reg & ~PIOCMODE) | OVLYHALTERR;\n\tasd_write_reg_dword(asd_ha, OVLYDMACTL, reg);\n\n\treturn asd_verify_seq(asd_ha, _prog, size, lseq_mask);\n}\n#endif  \n\n \nstatic int asd_seq_download_seqs(struct asd_ha_struct *asd_ha)\n{\n\tint \terr;\n\n\tif (!asd_ha->hw_prof.enabled_phys) {\n\t\tasd_printk(\"%s: no enabled phys!\\n\", pci_name(asd_ha->pcidev));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tASD_DPRINTK(\"downloading CSEQ...\\n\");\n\terr = asd_download_seq(asd_ha, cseq_code, cseq_code_size, 0);\n\tif (err) {\n\t\tasd_printk(\"CSEQ download failed:%d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tASD_DPRINTK(\"downloading LSEQs...\\n\");\n\terr = asd_download_seq(asd_ha, lseq_code, lseq_code_size,\n\t\t\t       asd_ha->hw_prof.enabled_phys);\n\tif (err) {\n\t\t \n\t\tu8 lseq;\n\t\tu8 lseq_mask = asd_ha->hw_prof.enabled_phys;\n\n\t\tfor_each_sequencer(lseq_mask, lseq_mask, lseq) {\n\t\t\terr = asd_download_seq(asd_ha, lseq_code,\n\t\t\t\t\t       lseq_code_size, 1<<lseq);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (err)\n\t\tasd_printk(\"LSEQs download failed:%d\\n\", err);\n\n\treturn err;\n}\n\n \n\n \nstatic void asd_init_cseq_mip(struct asd_ha_struct *asd_ha)\n{\n\t \n\tasd_write_reg_word(asd_ha, CSEQ_Q_EXE_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_EXE_TAIL, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_DONE_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_DONE_TAIL, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_SEND_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_SEND_TAIL, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_DMA2CHIM_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_DMA2CHIM_TAIL, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_COPY_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_COPY_TAIL, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_REG0, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_REG1, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_REG2, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_LINK_CTL_Q_MAP, 0);\n\t{\n\t\tu8 con = asd_read_reg_byte(asd_ha, CCONEXIST);\n\t\tu8 val = hweight8(con);\n\t\tasd_write_reg_byte(asd_ha, CSEQ_MAX_CSEQ_MODE, (val<<4)|val);\n\t}\n\tasd_write_reg_word(asd_ha, CSEQ_FREE_LIST_HACK_COUNT, 0);\n\n\t \n\tasd_write_reg_dword(asd_ha, CSEQ_EST_NEXUS_REQ_QUEUE, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_EST_NEXUS_REQ_QUEUE+4, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_EST_NEXUS_REQ_COUNT, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_EST_NEXUS_REQ_COUNT+4, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_EST_NEXUS_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_EST_NEXUS_TAIL, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_NEED_EST_NEXUS_SCB, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_EST_NEXUS_REQ_HEAD, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_EST_NEXUS_REQ_TAIL, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_EST_NEXUS_SCB_OFFSET, 0);\n\n\t \n\tasd_write_reg_word(asd_ha, CSEQ_INT_ROUT_RET_ADDR0, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_INT_ROUT_RET_ADDR1, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_INT_ROUT_SCBPTR, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_INT_ROUT_MODE, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_ISR_SCRATCH_FLAGS, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_ISR_SAVE_SINDEX, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_ISR_SAVE_DINDEX, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_MONIRTT_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_MONIRTT_TAIL, 0xFFFF);\n\t \n\t{\n\t\tu16 cmdctx = asd_get_cmdctx_size(asd_ha);\n\t\tcmdctx = (~((cmdctx/128)-1)) >> 8;\n\t\tasd_write_reg_byte(asd_ha, CSEQ_FREE_SCB_MASK, (u8)cmdctx);\n\t}\n\tasd_write_reg_word(asd_ha, CSEQ_BUILTIN_FREE_SCB_HEAD,\n\t\t\t   first_scb_site_no);\n\tasd_write_reg_word(asd_ha, CSEQ_BUILTIN_FREE_SCB_TAIL,\n\t\t\t   last_scb_site_no);\n\tasd_write_reg_word(asd_ha, CSEQ_EXTENDED_FREE_SCB_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_EXTENDED_FREE_SCB_TAIL, 0xFFFF);\n\n\t \n\tasd_write_reg_dword(asd_ha, CSEQ_EMPTY_REQ_QUEUE, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_EMPTY_REQ_QUEUE+4, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_EMPTY_REQ_COUNT, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_EMPTY_REQ_COUNT+4, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_EMPTY_HEAD, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_Q_EMPTY_TAIL, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_NEED_EMPTY_SCB, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_EMPTY_REQ_HEAD, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_EMPTY_REQ_TAIL, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_EMPTY_SCB_OFFSET, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_PRIMITIVE_DATA, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_TIMEOUT_CONST, 0);\n}\n\n \nstatic void asd_init_cseq_mdp(struct asd_ha_struct *asd_ha)\n{\n\tint\ti;\n\tint\tmoffs;\n\n\tmoffs = CSEQ_PAGE_SIZE * 2;\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tasd_write_reg_word(asd_ha, i*moffs+CSEQ_LRM_SAVE_SINDEX, 0);\n\t\tasd_write_reg_word(asd_ha, i*moffs+CSEQ_LRM_SAVE_SCBPTR, 0);\n\t\tasd_write_reg_word(asd_ha, i*moffs+CSEQ_Q_LINK_HEAD, 0xFFFF);\n\t\tasd_write_reg_word(asd_ha, i*moffs+CSEQ_Q_LINK_TAIL, 0xFFFF);\n\t\tasd_write_reg_byte(asd_ha, i*moffs+CSEQ_LRM_SAVE_SCRPAGE, 0);\n\t}\n\n\t \n\n\t \n\tasd_write_reg_word(asd_ha, CSEQ_RET_ADDR, 0xFFFF);\n\tasd_write_reg_word(asd_ha, CSEQ_RET_SCBPTR, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_SAVE_SCBPTR, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_EMPTY_TRANS_CTX, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_RESP_LEN, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_TMF_SCBPTR, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_GLOBAL_PREV_SCB, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_GLOBAL_HEAD, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_CLEAR_LU_HEAD, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_TMF_OPCODE, 0);\n\tasd_write_reg_byte(asd_ha, CSEQ_SCRATCH_FLAGS, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_HSB_SITE, 0);\n\tasd_write_reg_word(asd_ha, CSEQ_FIRST_INV_SCB_SITE,\n\t\t\t   (u16)last_scb_site_no+1);\n\tasd_write_reg_word(asd_ha, CSEQ_FIRST_INV_DDB_SITE,\n\t\t\t   (u16)asd_ha->hw_prof.max_ddbs);\n\n\t \n\tasd_write_reg_dword(asd_ha, CSEQ_LUN_TO_CLEAR, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_LUN_TO_CLEAR + 4, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_LUN_TO_CHECK, 0);\n\tasd_write_reg_dword(asd_ha, CSEQ_LUN_TO_CHECK + 4, 0);\n\n\t \n\t \n\tasd_write_reg_addr(asd_ha, CSEQ_HQ_NEW_POINTER,\n\t\t\t   asd_ha->seq.next_scb.dma_handle);\n\tASD_DPRINTK(\"First SCB dma_handle: 0x%llx\\n\",\n\t\t    (unsigned long long)asd_ha->seq.next_scb.dma_handle);\n\n\t \n\tasd_write_reg_addr(asd_ha, CSEQ_HQ_DONE_BASE,\n\t\t\t   asd_ha->seq.actual_dl->dma_handle);\n\n\t \n\tasd_write_reg_dword(asd_ha, CSEQ_HQ_DONE_POINTER,\n\t\t\t    ASD_BUSADDR_LO(asd_ha->seq.actual_dl->dma_handle));\n\n\tasd_write_reg_byte(asd_ha, CSEQ_HQ_DONE_PASS, ASD_DEF_DL_TOGGLE);\n\n\t \n}\n\n \nstatic void asd_init_cseq_scratch(struct asd_ha_struct *asd_ha)\n{\n\tasd_init_cseq_mip(asd_ha);\n\tasd_init_cseq_mdp(asd_ha);\n}\n\n \nstatic void asd_init_lseq_mip(struct asd_ha_struct *asd_ha, u8 lseq)\n{\n\tint i;\n\n\t \n\tasd_write_reg_word(asd_ha, LmSEQ_Q_TGTXFR_HEAD(lseq), 0xFFFF);\n\tasd_write_reg_word(asd_ha, LmSEQ_Q_TGTXFR_TAIL(lseq), 0xFFFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_LINK_NUMBER(lseq), lseq);\n\tasd_write_reg_byte(asd_ha, LmSEQ_SCRATCH_FLAGS(lseq),\n\t\t\t   ASD_NOTIFY_ENABLE_SPINUP);\n\tasd_write_reg_dword(asd_ha, LmSEQ_CONNECTION_STATE(lseq),0x08000000);\n\tasd_write_reg_word(asd_ha, LmSEQ_CONCTL(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_CONSTAT(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_CONNECTION_MODES(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_REG1_ISR(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_REG2_ISR(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_REG3_ISR(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_REG0_ISR(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_REG0_ISR(lseq)+4, 0);\n\n\t \n\tasd_write_reg_word(asd_ha, LmSEQ_EST_NEXUS_SCBPTR0(lseq), 0xFFFF);\n\tasd_write_reg_word(asd_ha, LmSEQ_EST_NEXUS_SCBPTR1(lseq), 0xFFFF);\n\tasd_write_reg_word(asd_ha, LmSEQ_EST_NEXUS_SCBPTR2(lseq), 0xFFFF);\n\tasd_write_reg_word(asd_ha, LmSEQ_EST_NEXUS_SCBPTR3(lseq), 0xFFFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EST_NEXUS_SCB_OPCODE0(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EST_NEXUS_SCB_OPCODE1(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EST_NEXUS_SCB_OPCODE2(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EST_NEXUS_SCB_OPCODE3(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EST_NEXUS_SCB_HEAD(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EST_NEXUS_SCB_TAIL(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EST_NEXUS_BUF_AVAIL(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_TIMEOUT_CONST(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_ISR_SAVE_SINDEX(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_ISR_SAVE_DINDEX(lseq), 0);\n\n\t \n\tasd_write_reg_word(asd_ha, LmSEQ_EMPTY_SCB_PTR0(lseq), 0xFFFF);\n\tasd_write_reg_word(asd_ha, LmSEQ_EMPTY_SCB_PTR1(lseq), 0xFFFF);\n\tasd_write_reg_word(asd_ha, LmSEQ_EMPTY_SCB_PTR2(lseq), 0xFFFF);\n\tasd_write_reg_word(asd_ha, LmSEQ_EMPTY_SCB_PTR3(lseq), 0xFFFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EMPTY_SCB_OPCD0(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EMPTY_SCB_OPCD1(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EMPTY_SCB_OPCD2(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EMPTY_SCB_OPCD3(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EMPTY_SCB_HEAD(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EMPTY_SCB_TAIL(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_EMPTY_BUFS_AVAIL(lseq), 0);\n\tfor (i = 0; i < 12; i += 4)\n\t\tasd_write_reg_dword(asd_ha, LmSEQ_ATA_SCR_REGS(lseq) + i, 0);\n\n\t \n\n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_DEV_PRES_TMR_TOUT_CONST(lseq),\n\t\t\t    ASD_DEV_PRESENT_TIMEOUT);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_SATA_INTERLOCK_TIMEOUT(lseq),\n\t\t\t    ASD_SATA_INTERLOCK_TIMEOUT);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_STP_SHUTDOWN_TIMEOUT(lseq),\n\t\t\t    ASD_STP_SHUTDOWN_TIMEOUT);\n\n\tasd_write_reg_dword(asd_ha, LmSEQ_SRST_ASSERT_TIMEOUT(lseq),\n\t\t\t    ASD_SRST_ASSERT_TIMEOUT);\n\n\tasd_write_reg_dword(asd_ha, LmSEQ_RCV_FIS_TIMEOUT(lseq),\n\t\t\t    ASD_RCV_FIS_TIMEOUT);\n\n\tasd_write_reg_dword(asd_ha, LmSEQ_ONE_MILLISEC_TIMEOUT(lseq),\n\t\t\t    ASD_ONE_MILLISEC_TIMEOUT);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_TEN_MS_COMINIT_TIMEOUT(lseq),\n\t\t\t    ASD_TEN_MILLISEC_TIMEOUT);\n\n\tasd_write_reg_dword(asd_ha, LmSEQ_SMP_RCV_TIMEOUT(lseq),\n\t\t\t    ASD_SMP_RCV_TIMEOUT);\n}\n\n \nstatic void asd_init_lseq_mdp(struct asd_ha_struct *asd_ha,  int lseq)\n{\n\tint    i;\n\tu32    moffs;\n\tu16 ret_addr[] = {\n\t\t0xFFFF,\t\t   \n\t\t0xFFFF,\t\t   \n\t\tmode2_task,\t   \n\t\t0,\n\t\t0xFFFF,\t\t   \n\t\t0xFFFF,\t\t   \n\t};\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tmoffs = i * LSEQ_MODE_SCRATCH_SIZE;\n\t\tasd_write_reg_word(asd_ha, LmSEQ_RET_ADDR(lseq)+moffs,\n\t\t\t\t   ret_addr[i]);\n\t\tasd_write_reg_word(asd_ha, LmSEQ_REG0_MODE(lseq)+moffs, 0);\n\t\tasd_write_reg_word(asd_ha, LmSEQ_MODE_FLAGS(lseq)+moffs, 0);\n\t\tasd_write_reg_word(asd_ha, LmSEQ_RET_ADDR2(lseq)+moffs,0xFFFF);\n\t\tasd_write_reg_word(asd_ha, LmSEQ_RET_ADDR1(lseq)+moffs,0xFFFF);\n\t\tasd_write_reg_byte(asd_ha, LmSEQ_OPCODE_TO_CSEQ(lseq)+moffs,0);\n\t\tasd_write_reg_word(asd_ha, LmSEQ_DATA_TO_CSEQ(lseq)+moffs,0);\n\t}\n\t \n\tasd_write_reg_word(asd_ha,\n\t\t\t LmSEQ_RET_ADDR(lseq)+LSEQ_MODE5_PAGE0_OFFSET,\n\t\t\t   ret_addr[5]);\n\tasd_write_reg_word(asd_ha,\n\t\t\t LmSEQ_REG0_MODE(lseq)+LSEQ_MODE5_PAGE0_OFFSET,0);\n\tasd_write_reg_word(asd_ha,\n\t\t\t LmSEQ_MODE_FLAGS(lseq)+LSEQ_MODE5_PAGE0_OFFSET, 0);\n\tasd_write_reg_word(asd_ha,\n\t\t\t LmSEQ_RET_ADDR2(lseq)+LSEQ_MODE5_PAGE0_OFFSET,0xFFFF);\n\tasd_write_reg_word(asd_ha,\n\t\t\t LmSEQ_RET_ADDR1(lseq)+LSEQ_MODE5_PAGE0_OFFSET,0xFFFF);\n\tasd_write_reg_byte(asd_ha,\n\t\t         LmSEQ_OPCODE_TO_CSEQ(lseq)+LSEQ_MODE5_PAGE0_OFFSET,0);\n\tasd_write_reg_word(asd_ha,\n\t\t         LmSEQ_DATA_TO_CSEQ(lseq)+LSEQ_MODE5_PAGE0_OFFSET, 0);\n\n\t \n\tasd_write_reg_word(asd_ha, LmSEQ_FIRST_INV_DDB_SITE(lseq),\n\t\t\t   (u16)asd_ha->hw_prof.max_ddbs);\n\tasd_write_reg_word(asd_ha, LmSEQ_EMPTY_TRANS_CTX(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_RESP_LEN(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_FIRST_INV_SCB_SITE(lseq),\n\t\t\t   (u16)last_scb_site_no+1);\n\tasd_write_reg_word(asd_ha, LmSEQ_INTEN_SAVE(lseq),\n\t\t\t    (u16) ((LmM0INTEN_MASK & 0xFFFF0000) >> 16));\n\tasd_write_reg_word(asd_ha, LmSEQ_INTEN_SAVE(lseq) + 2,\n\t\t\t    (u16) LmM0INTEN_MASK & 0xFFFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_LINK_RST_FRM_LEN(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_LINK_RST_PROTOCOL(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_RESP_STATUS(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_LAST_LOADED_SGE(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_SAVE_SCBPTR(lseq), 0);\n\n\t \n\tasd_write_reg_word(asd_ha, LmSEQ_Q_XMIT_HEAD(lseq), 0xFFFF);\n\tasd_write_reg_word(asd_ha, LmSEQ_M1_EMPTY_TRANS_CTX(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_INI_CONN_TAG(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_FAILED_OPEN_STATUS(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_XMIT_REQUEST_TYPE(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_M1_RESP_STATUS(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_M1_LAST_LOADED_SGE(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_M1_SAVE_SCBPTR(lseq), 0);\n\n\t \n\tasd_write_reg_word(asd_ha, LmSEQ_PORT_COUNTER(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_PM_TABLE_PTR(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_SATA_INTERLOCK_TMR_SAVE(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_IP_BITL(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_COPY_SMP_CONN_TAG(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_P0M2_OFFS1AH(lseq), 0);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmSEQ_SAVED_OOB_STATUS(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_SAVED_OOB_MODE(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_Q_LINK_HEAD(lseq), 0xFFFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_LINK_RST_ERR(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_SAVED_OOB_SIGNALS(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_SAS_RESET_MODE(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_LINK_RESET_RETRY_COUNT(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_NUM_LINK_RESET_RETRIES(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_OOB_INT_ENABLES(lseq), 0);\n\t \n\tasd_write_reg_word(asd_ha, LmSEQ_NOTIFY_TIMER_TIMEOUT(lseq),\n\t\t\t   ASD_NOTIFY_TIMEOUT - 1);\n\t \n\tasd_write_reg_word(asd_ha, LmSEQ_NOTIFY_TIMER_DOWN_COUNT(lseq),\n\t\t\t   ASD_NOTIFY_DOWN_COUNT);\n\tasd_write_reg_word(asd_ha, LmSEQ_NOTIFY_TIMER_INITIAL_COUNT(lseq),\n\t\t\t   ASD_NOTIFY_DOWN_COUNT);\n\n\t \n\tfor (i = 0; i < 2; i++)\t{\n\t\tint j;\n\t\t \n\t\tmoffs = LSEQ_PAGE_SIZE + i*LSEQ_MODE_SCRATCH_SIZE;\n\t\t \n\t\tfor (j = 0; j < LSEQ_PAGE_SIZE; j += 4)\n\t\t\tasd_write_reg_dword(asd_ha, LmSCRATCH(lseq)+moffs+j,0);\n\t}\n\n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_INVALID_DWORD_COUNT(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_DISPARITY_ERROR_COUNT(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_LOSS_OF_SYNC_COUNT(lseq), 0);\n\n\t \n\tfor (i = 0; i < LSEQ_PAGE_SIZE; i+=4)\n\t\tasd_write_reg_dword(asd_ha, LmSEQ_FRAME_TYPE_MASK(lseq)+i, 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_FRAME_TYPE_MASK(lseq), 0xFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_HASHED_DEST_ADDR_MASK(lseq), 0xFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_HASHED_DEST_ADDR_MASK(lseq)+1,0xFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_HASHED_DEST_ADDR_MASK(lseq)+2,0xFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_HASHED_SRC_ADDR_MASK(lseq), 0xFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_HASHED_SRC_ADDR_MASK(lseq)+1, 0xFF);\n\tasd_write_reg_byte(asd_ha, LmSEQ_HASHED_SRC_ADDR_MASK(lseq)+2, 0xFF);\n\tasd_write_reg_dword(asd_ha, LmSEQ_DATA_OFFSET(lseq), 0xFFFFFFFF);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_SMP_RCV_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_DEVICE_BITS(lseq), 0);\n\tasd_write_reg_word(asd_ha, LmSEQ_SDB_DDB(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_SDB_NUM_TAGS(lseq), 0);\n\tasd_write_reg_byte(asd_ha, LmSEQ_SDB_CURR_TAG(lseq), 0);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_TX_ID_ADDR_FRAME(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_TX_ID_ADDR_FRAME(lseq)+4, 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_OPEN_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_SRST_AS_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_LAST_LOADED_SG_EL(lseq), 0);\n\n\t \n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_STP_SHUTDOWN_TIMER_TERM_TS(lseq),0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_CLOSE_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_BREAK_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_DWS_RESET_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_dword(asd_ha,LmSEQ_SATA_INTERLOCK_TIMER_TERM_TS(lseq),0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_MCTL_TIMER_TERM_TS(lseq), 0);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmSEQ_COMINIT_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_RCV_ID_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_RCV_FIS_TIMER_TERM_TS(lseq), 0);\n\tasd_write_reg_dword(asd_ha, LmSEQ_DEV_PRES_TIMER_TERM_TS(lseq),\t0);\n}\n\n \nstatic void asd_init_lseq_scratch(struct asd_ha_struct *asd_ha)\n{\n\tu8 lseq;\n\tu8 lseq_mask;\n\n\tlseq_mask = asd_ha->hw_prof.enabled_phys;\n\tfor_each_sequencer(lseq_mask, lseq_mask, lseq) {\n\t\tasd_init_lseq_mip(asd_ha, lseq);\n\t\tasd_init_lseq_mdp(asd_ha, lseq);\n\t}\n}\n\n \nstatic void asd_init_scb_sites(struct asd_ha_struct *asd_ha)\n{\n\tu16\tsite_no;\n\tu16     max_scbs = 0;\n\n\tfor (site_no = asd_ha->hw_prof.max_scbs-1;\n\t     site_no != (u16) -1;\n\t     site_no--) {\n\t\tu16\ti;\n\n\t\t \n\t\tfor (i = 0; i < ASD_SCB_SIZE; i += 4)\n\t\t\tasd_scbsite_write_dword(asd_ha, site_no, i, 0);\n\n\t\t \n\t\tasd_scbsite_write_byte(asd_ha, site_no,\n\t\t\t\t       offsetof(struct scb_header, opcode),\n\t\t\t\t       0xFF);\n\n\t\t \n\t\tasd_scbsite_write_byte(asd_ha, site_no, 0x49, 0x01);\n\n\t\t \n\t\tif (!SCB_SITE_VALID(site_no))\n\t\t\tcontinue;\n\n\t\tif (last_scb_site_no == 0)\n\t\t\tlast_scb_site_no = site_no;\n\n\t\t \n\n\t\t \n\t\tasd_scbsite_write_word(asd_ha, site_no, 0, first_scb_site_no);\n\n\t\tfirst_scb_site_no = site_no;\n\t\tmax_scbs++;\n\t}\n\tasd_ha->hw_prof.max_scbs = max_scbs;\n\tASD_DPRINTK(\"max_scbs:%d\\n\", asd_ha->hw_prof.max_scbs);\n\tASD_DPRINTK(\"first_scb_site_no:0x%x\\n\", first_scb_site_no);\n\tASD_DPRINTK(\"last_scb_site_no:0x%x\\n\", last_scb_site_no);\n}\n\n \nstatic void asd_init_cseq_cio(struct asd_ha_struct *asd_ha)\n{\n\tint i;\n\n\tasd_write_reg_byte(asd_ha, CSEQCOMINTEN, 0);\n\tasd_write_reg_byte(asd_ha, CSEQDLCTL, ASD_DL_SIZE_BITS);\n\tasd_write_reg_byte(asd_ha, CSEQDLOFFS, 0);\n\tasd_write_reg_byte(asd_ha, CSEQDLOFFS+1, 0);\n\tasd_ha->seq.scbpro = 0;\n\tasd_write_reg_dword(asd_ha, SCBPRO, 0);\n\tasd_write_reg_dword(asd_ha, CSEQCON, 0);\n\n\t \n\tasd_write_reg_word(asd_ha, CM11INTVEC0, cseq_vecs[0]);\n\tasd_write_reg_word(asd_ha, CM11INTVEC1, cseq_vecs[1]);\n\tasd_write_reg_word(asd_ha, CM11INTVEC2, cseq_vecs[2]);\n\n\t \n\tasd_write_reg_byte(asd_ha, CARP2INTEN, EN_ARP2HALTC);\n\n\t \n\tasd_write_reg_byte(asd_ha, CSCRATCHPAGE, 0x04);\n\n\t \n\t \n\tfor (i = 0; i < 9; i++)\n\t\tasd_write_reg_byte(asd_ha, CMnSCRATCHPAGE(i), 0);\n\n\t \n\tasd_write_reg_word(asd_ha, CPRGMCNT, cseq_idle_loop);\n\n\tfor (i = 0; i < 8; i++) {\n\t\t \n\t\tasd_write_reg_dword(asd_ha, CMnINTEN(i), EN_CMnRSPMBXF);\n\t\t \n\t\tasd_write_reg_dword(asd_ha, CMnREQMBX(i), 0);\n\t}\n}\n\n \nstatic void asd_init_lseq_cio(struct asd_ha_struct *asd_ha, int lseq)\n{\n\tu8  *sas_addr;\n\tint  i;\n\n\t \n\tasd_write_reg_dword(asd_ha, LmARP2INTEN(lseq), EN_ARP2HALTC);\n\n\tasd_write_reg_byte(asd_ha, LmSCRATCHPAGE(lseq), 0);\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tasd_write_reg_byte(asd_ha, LmMnSCRATCHPAGE(lseq, i), 0);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmMnSCRATCHPAGE(lseq, 5), 0);\n\n\tasd_write_reg_dword(asd_ha, LmRSPMBX(lseq), 0);\n\t \n\tasd_write_reg_dword(asd_ha, LmMnINTEN(lseq, 0), LmM0INTEN_MASK);\n\tasd_write_reg_dword(asd_ha, LmMnINT(lseq, 0), 0xFFFFFFFF);\n\t \n\tasd_write_reg_dword(asd_ha, LmMnINTEN(lseq, 1), LmM1INTEN_MASK);\n\tasd_write_reg_dword(asd_ha, LmMnINT(lseq, 1), 0xFFFFFFFF);\n\t \n\tasd_write_reg_dword(asd_ha, LmMnINTEN(lseq, 2), LmM2INTEN_MASK);\n\tasd_write_reg_dword(asd_ha, LmMnINT(lseq, 2), 0xFFFFFFFF);\n\t \n\tasd_write_reg_dword(asd_ha, LmMnINTEN(lseq, 5), LmM5INTEN_MASK);\n\tasd_write_reg_dword(asd_ha, LmMnINT(lseq, 5), 0xFFFFFFFF);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmHWTSTATEN(lseq), LmHWTSTATEN_MASK);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmPRIMSTAT0EN(lseq), LmPRIMSTAT0EN_MASK);\n\tasd_write_reg_dword(asd_ha, LmPRIMSTAT1EN(lseq), LmPRIMSTAT1EN_MASK);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmFRMERREN(lseq), LmFRMERREN_MASK);\n\tasd_write_reg_byte(asd_ha, LmMnHOLDLVL(lseq, 0), 0x50);\n\n\t \n\tasd_write_reg_byte(asd_ha,  LmMnXFRLVL(lseq, 0), LmMnXFRLVL_512);\n\t \n\tasd_write_reg_byte(asd_ha, LmMnXFRLVL(lseq, 1), LmMnXFRLVL_256);\n\n\t \n\tasd_write_reg_word(asd_ha, LmPRGMCNT(lseq), lseq_idle_loop);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmMODECTL(lseq), LmBLIND48);\n\tasd_write_reg_word(asd_ha, LmM3SATATIMER(lseq),\n\t\t\t   ASD_SATA_INTERLOCK_TIMEOUT);\n\n\t(void) asd_read_reg_dword(asd_ha, LmREQMBX(lseq));\n\n\t \n\tasd_write_reg_dword(asd_ha, LmPRMSTAT0(lseq), 0xFFFFFFFF);\n\tasd_write_reg_dword(asd_ha, LmPRMSTAT1(lseq), 0xFFFFFFFF);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmHWTSTAT(lseq), 0xFF);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmMnDMAERRS(lseq, 0), 0xFF);\n\tasd_write_reg_byte(asd_ha, LmMnDMAERRS(lseq, 1), 0xFF);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmMnSGDMAERRS(lseq, 0), 0xFF);\n\tasd_write_reg_byte(asd_ha, LmMnSGDMAERRS(lseq, 1), 0xFF);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmMnBUFSTAT(lseq, 0), LmMnBUFPERR);\n\n\t \n\tasd_write_reg_dword(asd_ha, LmMnFRMERR(lseq, 0), 0xFFFFFFFF);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmARP2INTCTL(lseq), RSTINTCTL);\n\n\t \n\tsas_addr = asd_ha->phys[lseq].phy_desc->sas_addr;\n\tfor (i = 0; i < SAS_ADDR_SIZE; i++)\n\t\tasd_write_reg_byte(asd_ha, LmWWN(lseq) + i, sas_addr[i]);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmMnXMTSIZE(lseq, 1), 0);\n\n\t \n\tasd_write_reg_word(asd_ha, LmBITL_TIMER(lseq), 9);\n\n\t \n\tasd_write_reg_byte(asd_ha, LmMnSATAFS(lseq, 1), 0x80);\n\n\t \n\tasd_write_reg_word(asd_ha, LmM3INTVEC0(lseq), lseq_vecs[0]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC1(lseq), lseq_vecs[1]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC2(lseq), lseq_vecs[2]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC3(lseq), lseq_vecs[3]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC4(lseq), lseq_vecs[4]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC5(lseq), lseq_vecs[5]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC6(lseq), lseq_vecs[6]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC7(lseq), lseq_vecs[7]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC8(lseq), lseq_vecs[8]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC9(lseq), lseq_vecs[9]);\n\tasd_write_reg_word(asd_ha, LmM3INTVEC10(lseq), lseq_vecs[10]);\n\t \n\tasd_write_reg_dword(asd_ha, LmCONTROL(lseq),\n\t\t\t    (LEDTIMER | LEDMODE_TXRX | LEDTIMERS_100ms));\n\n\t \n\tasd_write_reg_byte(asd_ha, LmM1SASALIGN(lseq), SAS_ALIGN_DEFAULT);\n\tasd_write_reg_byte(asd_ha, LmM1STPALIGN(lseq), STP_ALIGN_DEFAULT);\n}\n\n\n \nstatic void asd_post_init_cseq(struct asd_ha_struct *asd_ha)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tasd_write_reg_dword(asd_ha, CMnINT(i), 0xFFFFFFFF);\n\tfor (i = 0; i < 8; i++)\n\t\tasd_read_reg_dword(asd_ha, CMnRSPMBX(i));\n\t \n\tasd_write_reg_byte(asd_ha, CARP2INTCTL, RSTINTCTL);\n}\n\n \nstatic void asd_init_ddb_0(struct asd_ha_struct *asd_ha)\n{\n\tint\ti;\n\n\t \n\tfor (i = 0; i < sizeof(struct asd_ddb_seq_shared); i+=4)\n\t\tasd_ddbsite_write_dword(asd_ha, 0, i, 0);\n\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, q_free_ddb_head), 0);\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, q_free_ddb_tail),\n\t\t\t       asd_ha->hw_prof.max_ddbs-1);\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, q_free_ddb_cnt), 0);\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, q_used_ddb_head), 0xFFFF);\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, q_used_ddb_tail), 0xFFFF);\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, shared_mem_lock), 0);\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, smp_conn_tag), 0);\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, est_nexus_buf_cnt), 0);\n\tasd_ddbsite_write_word(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, est_nexus_buf_thresh),\n\t\t\t       asd_ha->hw_prof.num_phys * 2);\n\tasd_ddbsite_write_byte(asd_ha, 0,\n\t\t offsetof(struct asd_ddb_seq_shared, settable_max_contexts),0);\n\tasd_ddbsite_write_byte(asd_ha, 0,\n\t       offsetof(struct asd_ddb_seq_shared, conn_not_active), 0xFF);\n\tasd_ddbsite_write_byte(asd_ha, 0,\n\t       offsetof(struct asd_ddb_seq_shared, phy_is_up), 0x00);\n\t \n\tset_bit(0, asd_ha->hw_prof.ddb_bitmap);\n}\n\nstatic void asd_seq_init_ddb_sites(struct asd_ha_struct *asd_ha)\n{\n\tunsigned int i;\n\tunsigned int ddb_site;\n\n\tfor (ddb_site = 0 ; ddb_site < ASD_MAX_DDBS; ddb_site++)\n\t\tfor (i = 0; i < sizeof(struct asd_ddb_ssp_smp_target_port); i+= 4)\n\t\t\tasd_ddbsite_write_dword(asd_ha, ddb_site, i, 0);\n}\n\n \nstatic void asd_seq_setup_seqs(struct asd_ha_struct *asd_ha)\n{\n\tint \t\tlseq;\n\tu8\t\tlseq_mask;\n\n\t \n\tasd_seq_init_ddb_sites(asd_ha);\n\n\t \n\tasd_init_scb_sites(asd_ha);\n\n\t \n\tasd_init_cseq_scratch(asd_ha);\n\n\t \n\tasd_init_lseq_scratch(asd_ha);\n\n\t \n\tasd_init_cseq_cio(asd_ha);\n\n\tasd_init_ddb_0(asd_ha);\n\n\t \n\tlseq_mask = asd_ha->hw_prof.enabled_phys;\n\tfor_each_sequencer(lseq_mask, lseq_mask, lseq)\n\t\tasd_init_lseq_cio(asd_ha, lseq);\n\tasd_post_init_cseq(asd_ha);\n}\n\n\n \nstatic int asd_seq_start_cseq(struct asd_ha_struct *asd_ha)\n{\n\t \n\tasd_write_reg_word(asd_ha, CPRGMCNT, cseq_idle_loop);\n\n\t \n\treturn asd_unpause_cseq(asd_ha);\n}\n\n \nstatic int asd_seq_start_lseq(struct asd_ha_struct *asd_ha, int lseq)\n{\n\t \n\tasd_write_reg_word(asd_ha, LmPRGMCNT(lseq), lseq_idle_loop);\n\n\t \n\treturn asd_seq_unpause_lseq(asd_ha, lseq);\n}\n\nint asd_release_firmware(void)\n{\n\trelease_firmware(sequencer_fw);\n\treturn 0;\n}\n\nstatic int asd_request_firmware(struct asd_ha_struct *asd_ha)\n{\n\tint err, i;\n\tstruct sequencer_file_header header;\n\tconst struct sequencer_file_header *hdr_ptr;\n\tu32 csum = 0;\n\tu16 *ptr_cseq_vecs, *ptr_lseq_vecs;\n\n\tif (sequencer_fw)\n\t\t \n\t\treturn 0;\n\n\terr = request_firmware(&sequencer_fw,\n\t\t\t       SAS_RAZOR_SEQUENCER_FW_FILE,\n\t\t\t       &asd_ha->pcidev->dev);\n\tif (err)\n\t\treturn err;\n\n\thdr_ptr = (const struct sequencer_file_header *)sequencer_fw->data;\n\n\theader.csum = le32_to_cpu(hdr_ptr->csum);\n\theader.major = le32_to_cpu(hdr_ptr->major);\n\theader.minor = le32_to_cpu(hdr_ptr->minor);\n\theader.cseq_table_offset = le32_to_cpu(hdr_ptr->cseq_table_offset);\n\theader.cseq_table_size = le32_to_cpu(hdr_ptr->cseq_table_size);\n\theader.lseq_table_offset = le32_to_cpu(hdr_ptr->lseq_table_offset);\n\theader.lseq_table_size = le32_to_cpu(hdr_ptr->lseq_table_size);\n\theader.cseq_code_offset = le32_to_cpu(hdr_ptr->cseq_code_offset);\n\theader.cseq_code_size = le32_to_cpu(hdr_ptr->cseq_code_size);\n\theader.lseq_code_offset = le32_to_cpu(hdr_ptr->lseq_code_offset);\n\theader.lseq_code_size = le32_to_cpu(hdr_ptr->lseq_code_size);\n\theader.mode2_task = le16_to_cpu(hdr_ptr->mode2_task);\n\theader.cseq_idle_loop = le16_to_cpu(hdr_ptr->cseq_idle_loop);\n\theader.lseq_idle_loop = le16_to_cpu(hdr_ptr->lseq_idle_loop);\n\n\tfor (i = sizeof(header.csum); i < sequencer_fw->size; i++)\n\t\tcsum += sequencer_fw->data[i];\n\n\tif (csum != header.csum) {\n\t\tasd_printk(\"Firmware file checksum mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (header.cseq_table_size != CSEQ_NUM_VECS ||\n\t    header.lseq_table_size != LSEQ_NUM_VECS) {\n\t\tasd_printk(\"Firmware file table size mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tasd_printk(\"Found sequencer Firmware version %d.%d (%s)\\n\",\n\t\t   header.major, header.minor, hdr_ptr->version);\n\n\tif (header.major != SAS_RAZOR_SEQUENCER_FW_MAJOR) {\n\t\tasd_printk(\"Firmware Major Version Mismatch;\"\n\t\t\t   \"driver requires version %d.X\",\n\t\t\t   SAS_RAZOR_SEQUENCER_FW_MAJOR);\n\t\treturn -EINVAL;\n\t}\n\n\tptr_cseq_vecs = (u16 *)&sequencer_fw->data[header.cseq_table_offset];\n\tptr_lseq_vecs = (u16 *)&sequencer_fw->data[header.lseq_table_offset];\n\tmode2_task = header.mode2_task;\n\tcseq_idle_loop = header.cseq_idle_loop;\n\tlseq_idle_loop = header.lseq_idle_loop;\n\n\tfor (i = 0; i < CSEQ_NUM_VECS; i++)\n\t\tcseq_vecs[i] = le16_to_cpu(ptr_cseq_vecs[i]);\n\n\tfor (i = 0; i < LSEQ_NUM_VECS; i++)\n\t\tlseq_vecs[i] = le16_to_cpu(ptr_lseq_vecs[i]);\n\n\tcseq_code = &sequencer_fw->data[header.cseq_code_offset];\n\tcseq_code_size = header.cseq_code_size;\n\tlseq_code = &sequencer_fw->data[header.lseq_code_offset];\n\tlseq_code_size = header.lseq_code_size;\n\n\treturn 0;\n}\n\nint asd_init_seqs(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\n\terr = asd_request_firmware(asd_ha);\n\n\tif (err) {\n\t\tasd_printk(\"Failed to load sequencer firmware file %s, error %d\\n\",\n\t\t\t   SAS_RAZOR_SEQUENCER_FW_FILE, err);\n\t\treturn err;\n\t}\n\n\terr = asd_seq_download_seqs(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't download sequencers for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\treturn err;\n\t}\n\n\tasd_seq_setup_seqs(asd_ha);\n\n\treturn 0;\n}\n\nint asd_start_seqs(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\tu8  lseq_mask;\n\tint lseq;\n\n\terr = asd_seq_start_cseq(asd_ha);\n\tif (err) {\n\t\tasd_printk(\"couldn't start CSEQ for %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\treturn err;\n\t}\n\n\tlseq_mask = asd_ha->hw_prof.enabled_phys;\n\tfor_each_sequencer(lseq_mask, lseq_mask, lseq) {\n\t\terr = asd_seq_start_lseq(asd_ha, lseq);\n\t\tif (err) {\n\t\t\tasd_printk(\"couldn't start LSEQ %d for %s\\n\", lseq,\n\t\t\t\t   pci_name(asd_ha->pcidev));\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nvoid asd_update_port_links(struct asd_ha_struct *asd_ha, struct asd_phy *phy)\n{\n\tconst u8 phy_mask = (u8) phy->asd_port->phy_mask;\n\tu8  phy_is_up;\n\tu8  mask;\n\tint i, err;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->hw_prof.ddb_lock, flags);\n\tfor_each_phy(phy_mask, mask, i)\n\t\tasd_ddbsite_write_byte(asd_ha, 0,\n\t\t\t\t       offsetof(struct asd_ddb_seq_shared,\n\t\t\t\t\t\tport_map_by_links)+i,phy_mask);\n\n\tfor (i = 0; i < 12; i++) {\n\t\tphy_is_up = asd_ddbsite_read_byte(asd_ha, 0,\n\t\t\t  offsetof(struct asd_ddb_seq_shared, phy_is_up));\n\t\terr = asd_ddbsite_update_byte(asd_ha, 0,\n\t\t\t\toffsetof(struct asd_ddb_seq_shared, phy_is_up),\n\t\t\t\tphy_is_up,\n\t\t\t\tphy_is_up | phy_mask);\n\t\tif (!err)\n\t\t\tbreak;\n\t\telse if (err == -EFAULT) {\n\t\t\tasd_printk(\"phy_is_up: parity error in DDB 0\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&asd_ha->hw_prof.ddb_lock, flags);\n\n\tif (err)\n\t\tasd_printk(\"couldn't update DDB 0:error:%d\\n\", err);\n}\n\nMODULE_FIRMWARE(SAS_RAZOR_SEQUENCER_FW_FILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}