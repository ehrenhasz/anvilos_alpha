{
  "module_name": "aic94xx_sds.c",
  "hash_id": "7f2a7a816d7df1c8c3cb707da4b33d9b7a99cd8e471dc4bc250ece4b18b3f2ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_sds.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n#include \"aic94xx.h\"\n#include \"aic94xx_reg.h\"\n#include \"aic94xx_sds.h\"\n\n \n\nstruct asd_ocm_dir_ent {\n\tu8 type;\n\tu8 offs[3];\n\tu8 _r1;\n\tu8 size[3];\n} __attribute__ ((packed));\n\nstruct asd_ocm_dir {\n\tchar sig[2];\n\tu8   _r1[2];\n\tu8   major;           \n\tu8   minor;           \n\tu8   _r2;\n\tu8   num_de;\n\tstruct asd_ocm_dir_ent entry[15];\n} __attribute__ ((packed));\n\n#define\tOCM_DE_OCM_DIR\t\t\t0x00\n#define\tOCM_DE_WIN_DRVR\t\t\t0x01\n#define\tOCM_DE_BIOS_CHIM\t\t0x02\n#define\tOCM_DE_RAID_ENGN\t\t0x03\n#define\tOCM_DE_BIOS_INTL\t\t0x04\n#define\tOCM_DE_BIOS_CHIM_OSM\t\t0x05\n#define\tOCM_DE_BIOS_CHIM_DYNAMIC\t0x06\n#define\tOCM_DE_ADDC2C_RES0\t\t0x07\n#define\tOCM_DE_ADDC2C_RES1\t\t0x08\n#define\tOCM_DE_ADDC2C_RES2\t\t0x09\n#define\tOCM_DE_ADDC2C_RES3\t\t0x0A\n\n#define OCM_INIT_DIR_ENTRIES\t5\n \nstatic struct asd_ocm_dir OCMDirInit =\n{\n\t.sig = {0x4D, 0x4F},\t \n\t.num_de = OCM_INIT_DIR_ENTRIES,\t \n};\n\n \nstatic struct asd_ocm_dir_ent OCMDirEntriesInit[OCM_INIT_DIR_ENTRIES] =\n{\n\t{\n\t\t.type = (OCM_DE_ADDC2C_RES0),\t \n\t\t.offs = {128},\t\t\t \n\t\t.size = {0, 4},\t\t\t \n\t},\n\t{\n\t\t.type = (OCM_DE_ADDC2C_RES1),\t \n\t\t.offs = {128, 4},\t\t \n\t\t.size = {0, 4},\t\t\t \n\t},\n\t{\n\t\t.type = (OCM_DE_ADDC2C_RES2),\t \n\t\t.offs = {128, 8},\t\t \n\t\t.size = {0, 4},\t\t\t \n\t},\n\t{\n\t\t.type = (OCM_DE_ADDC2C_RES3),\t \n\t\t.offs = {128, 12},\t\t \n\t\t.size = {0, 4},\t\t\t \n\t},\n\t{\n\t\t.type = (OCM_DE_WIN_DRVR),\t \n\t\t.offs = {128, 16},\t\t \n\t\t.size = {128, 235, 1},\t\t \n\t},\n};\n\nstruct asd_bios_chim_struct {\n\tchar sig[4];\n\tu8   major;           \n\tu8   minor;           \n\tu8   bios_major;\n\tu8   bios_minor;\n\t__le32  bios_build;\n\tu8   flags;\n\tu8   pci_slot;\n\t__le16  ue_num;\n\t__le16  ue_size;\n\tu8  _r[14];\n\t \n} __attribute__ ((packed));\n\n \nstatic int asd_read_ocm_seg(struct asd_ha_struct *asd_ha, void *buffer,\n\t\t\t    u32 offs, int size)\n{\n\tu8 *p = buffer;\n\tif (unlikely(asd_ha->iospace))\n\t\tasd_read_reg_string(asd_ha, buffer, offs+OCM_BASE_ADDR, size);\n\telse {\n\t\tfor ( ; size > 0; size--, offs++, p++)\n\t\t\t*p = asd_read_ocm_byte(asd_ha, offs);\n\t}\n\treturn size;\n}\n\nstatic int asd_read_ocm_dir(struct asd_ha_struct *asd_ha,\n\t\t\t    struct asd_ocm_dir *dir, u32 offs)\n{\n\tint err = asd_read_ocm_seg(asd_ha, dir, offs, sizeof(*dir));\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't read ocm segment\\n\");\n\t\treturn err;\n\t}\n\n\tif (dir->sig[0] != 'M' || dir->sig[1] != 'O') {\n\t\tASD_DPRINTK(\"no valid dir signature(%c%c) at start of OCM\\n\",\n\t\t\t    dir->sig[0], dir->sig[1]);\n\t\treturn -ENOENT;\n\t}\n\tif (dir->major != 0) {\n\t\tasd_printk(\"unsupported major version of ocm dir:0x%x\\n\",\n\t\t\t   dir->major);\n\t\treturn -ENOENT;\n\t}\n\tdir->num_de &= 0xf;\n\treturn 0;\n}\n\n \nstatic void asd_write_ocm_seg(struct asd_ha_struct *asd_ha, void *buffer,\n\t\t\t    u32 offs, int size)\n{\n\tu8 *p = buffer;\n\tif (unlikely(asd_ha->iospace))\n\t\tasd_write_reg_string(asd_ha, buffer, offs+OCM_BASE_ADDR, size);\n\telse {\n\t\tfor ( ; size > 0; size--, offs++, p++)\n\t\t\tasd_write_ocm_byte(asd_ha, offs, *p);\n\t}\n\treturn;\n}\n\n#define THREE_TO_NUM(X) ((X)[0] | ((X)[1] << 8) | ((X)[2] << 16))\n\nstatic int asd_find_dir_entry(struct asd_ocm_dir *dir, u8 type,\n\t\t\t      u32 *offs, u32 *size)\n{\n\tint i;\n\tstruct asd_ocm_dir_ent *ent;\n\n\tfor (i = 0; i < dir->num_de; i++) {\n\t\tif (dir->entry[i].type == type)\n\t\t\tbreak;\n\t}\n\tif (i >= dir->num_de)\n\t\treturn -ENOENT;\n\tent = &dir->entry[i];\n\t*offs = (u32) THREE_TO_NUM(ent->offs);\n\t*size = (u32) THREE_TO_NUM(ent->size);\n\treturn 0;\n}\n\n#define OCM_BIOS_CHIM_DE  2\n#define BC_BIOS_PRESENT   1\n\nstatic int asd_get_bios_chim(struct asd_ha_struct *asd_ha,\n\t\t\t     struct asd_ocm_dir *dir)\n{\n\tint err;\n\tstruct asd_bios_chim_struct *bc_struct;\n\tu32 offs, size;\n\n\terr = asd_find_dir_entry(dir, OCM_BIOS_CHIM_DE, &offs, &size);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't find BIOS_CHIM dir ent\\n\");\n\t\tgoto out;\n\t}\n\terr = -ENOMEM;\n\tbc_struct = kmalloc(sizeof(*bc_struct), GFP_KERNEL);\n\tif (!bc_struct) {\n\t\tasd_printk(\"no memory for bios_chim struct\\n\");\n\t\tgoto out;\n\t}\n\terr = asd_read_ocm_seg(asd_ha, (void *)bc_struct, offs,\n\t\t\t       sizeof(*bc_struct));\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't read ocm segment\\n\");\n\t\tgoto out2;\n\t}\n\tif (strncmp(bc_struct->sig, \"SOIB\", 4)\n\t    && strncmp(bc_struct->sig, \"IPSA\", 4)) {\n\t\tASD_DPRINTK(\"BIOS_CHIM entry has no valid sig(%c%c%c%c)\\n\",\n\t\t\t    bc_struct->sig[0], bc_struct->sig[1],\n\t\t\t    bc_struct->sig[2], bc_struct->sig[3]);\n\t\terr = -ENOENT;\n\t\tgoto out2;\n\t}\n\tif (bc_struct->major != 1) {\n\t\tasd_printk(\"BIOS_CHIM unsupported major version:0x%x\\n\",\n\t\t\t   bc_struct->major);\n\t\terr = -ENOENT;\n\t\tgoto out2;\n\t}\n\tif (bc_struct->flags & BC_BIOS_PRESENT) {\n\t\tasd_ha->hw_prof.bios.present = 1;\n\t\tasd_ha->hw_prof.bios.maj = bc_struct->bios_major;\n\t\tasd_ha->hw_prof.bios.min = bc_struct->bios_minor;\n\t\tasd_ha->hw_prof.bios.bld = le32_to_cpu(bc_struct->bios_build);\n\t\tASD_DPRINTK(\"BIOS present (%d,%d), %d\\n\",\n\t\t\t    asd_ha->hw_prof.bios.maj,\n\t\t\t    asd_ha->hw_prof.bios.min,\n\t\t\t    asd_ha->hw_prof.bios.bld);\n\t}\n\tasd_ha->hw_prof.ue.num = le16_to_cpu(bc_struct->ue_num);\n\tasd_ha->hw_prof.ue.size= le16_to_cpu(bc_struct->ue_size);\n\tASD_DPRINTK(\"ue num:%d, ue size:%d\\n\", asd_ha->hw_prof.ue.num,\n\t\t    asd_ha->hw_prof.ue.size);\n\tsize = asd_ha->hw_prof.ue.num * asd_ha->hw_prof.ue.size;\n\tif (size > 0) {\n\t\terr = -ENOMEM;\n\t\tasd_ha->hw_prof.ue.area = kmalloc(size, GFP_KERNEL);\n\t\tif (!asd_ha->hw_prof.ue.area)\n\t\t\tgoto out2;\n\t\terr = asd_read_ocm_seg(asd_ha, (void *)asd_ha->hw_prof.ue.area,\n\t\t\t\t       offs + sizeof(*bc_struct), size);\n\t\tif (err) {\n\t\t\tkfree(asd_ha->hw_prof.ue.area);\n\t\t\tasd_ha->hw_prof.ue.area = NULL;\n\t\t\tasd_ha->hw_prof.ue.num  = 0;\n\t\t\tasd_ha->hw_prof.ue.size = 0;\n\t\t\tASD_DPRINTK(\"couldn't read ue entries(%d)\\n\", err);\n\t\t}\n\t}\nout2:\n\tkfree(bc_struct);\nout:\n\treturn err;\n}\n\nstatic void\nasd_hwi_initialize_ocm_dir (struct asd_ha_struct *asd_ha)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < OCM_MAX_SIZE; i += 4)\n\t\tasd_write_ocm_dword(asd_ha, i, 0);\n\n\t \n\tasd_write_ocm_seg(asd_ha, &OCMDirInit, 0,\n\t\t\t  sizeof(struct asd_ocm_dir));\n\n\t \n\tfor (i = 0; i < OCM_INIT_DIR_ENTRIES; i++)\n\t\tasd_write_ocm_seg(asd_ha, &OCMDirEntriesInit[i],\n\t\t\t\t  sizeof(struct asd_ocm_dir) +\n\t\t\t\t  (i * sizeof(struct asd_ocm_dir_ent))\n\t\t\t\t  , sizeof(struct asd_ocm_dir_ent));\n\n}\n\nstatic int\nasd_hwi_check_ocm_access (struct asd_ha_struct *asd_ha)\n{\n\tstruct pci_dev *pcidev = asd_ha->pcidev;\n\tu32 reg;\n\tint err = 0;\n\tu32 v;\n\n\t \n\treg = asd_read_reg_dword(asd_ha, EXSICNFGR);\n\n\tif (!(reg & OCMINITIALIZED)) {\n\t\terr = pci_read_config_dword(pcidev, PCIC_INTRPT_STAT, &v);\n\t\tif (err) {\n\t\t\tasd_printk(\"couldn't access PCIC_INTRPT_STAT of %s\\n\",\n\t\t\t\t\tpci_name(pcidev));\n\t\t\tgoto out;\n\t\t}\n\n\t\tprintk(KERN_INFO \"OCM is not initialized by BIOS,\"\n\t\t       \"reinitialize it and ignore it, current IntrptStatus\"\n\t\t       \"is 0x%x\\n\", v);\n\n\t\tif (v)\n\t\t\terr = pci_write_config_dword(pcidev,\n\t\t\t\t\t\t     PCIC_INTRPT_STAT, v);\n\t\tif (err) {\n\t\t\tasd_printk(\"couldn't write PCIC_INTRPT_STAT of %s\\n\",\n\t\t\t\t\tpci_name(pcidev));\n\t\t\tgoto out;\n\t\t}\n\n\t\tasd_hwi_initialize_ocm_dir(asd_ha);\n\n\t}\nout:\n\treturn err;\n}\n\n \nint asd_read_ocm(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\tstruct asd_ocm_dir *dir;\n\n\tif (asd_hwi_check_ocm_access(asd_ha))\n\t\treturn -1;\n\n\tdir = kmalloc(sizeof(*dir), GFP_KERNEL);\n\tif (!dir) {\n\t\tasd_printk(\"no memory for ocm dir\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = asd_read_ocm_dir(asd_ha, dir, 0);\n\tif (err)\n\t\tgoto out;\n\n\terr = asd_get_bios_chim(asd_ha, dir);\nout:\n\tkfree(dir);\n\treturn err;\n}\n\n \n\n#define FLASH_RESET\t\t\t0xF0\n\n#define ASD_FLASH_SIZE                  0x200000\n#define FLASH_DIR_COOKIE                \"*** ADAPTEC FLASH DIRECTORY *** \"\n#define FLASH_NEXT_ENTRY_OFFS\t\t0x2000\n#define FLASH_MAX_DIR_ENTRIES\t\t32\n\n#define FLASH_DE_TYPE_MASK              0x3FFFFFFF\n#define FLASH_DE_MS                     0x120\n#define FLASH_DE_CTRL_A_USER            0xE0\n\nstruct asd_flash_de {\n\t__le32   type;\n\t__le32   offs;\n\t__le32   pad_size;\n\t__le32   image_size;\n\t__le32   chksum;\n\tu8       _r[12];\n\tu8       version[32];\n} __attribute__ ((packed));\n\nstruct asd_flash_dir {\n\tu8    cookie[32];\n\t__le32   rev;\t\t   \n\t__le32   chksum;\n\t__le32   chksum_antidote;\n\t__le32   bld;\n\tu8    bld_id[32];\t   \n\tu8    ver_data[32];\t   \n\t__le32   ae_mask;\n\t__le32   v_mask;\n\t__le32   oc_mask;\n\tu8    _r[20];\n\tstruct asd_flash_de dir_entry[FLASH_MAX_DIR_ENTRIES];\n} __attribute__ ((packed));\n\nstruct asd_manuf_sec {\n\tchar  sig[2];\t\t   \n\tu16   offs_next;\n\tu8    maj;            \n\tu8    min;            \n\tu16   chksum;\n\tu16   size;\n\tu8    _r[6];\n\tu8    sas_addr[SAS_ADDR_SIZE];\n\tu8    pcba_sn[ASD_PCBA_SN_SIZE];\n\t \n\tu8    linked_list[];\n} __attribute__ ((packed));\n\nstruct asd_manuf_phy_desc {\n\tu8    state;          \n#define MS_PHY_STATE_ENABLED    0\n#define MS_PHY_STATE_REPORTED   1\n#define MS_PHY_STATE_HIDDEN     2\n\tu8    phy_id;\n\tu16   _r;\n\tu8    phy_control_0;  \n\tu8    phy_control_1;  \n\tu8    phy_control_2;  \n\tu8    phy_control_3;  \n} __attribute__ ((packed));\n\nstruct asd_manuf_phy_param {\n\tchar  sig[2];\t\t   \n\tu16   next;\n\tu8    maj;            \n\tu8    min;            \n\tu8    num_phy_desc;   \n\tu8    phy_desc_size;  \n\tu8    _r[3];\n\tu8    usage_model_id;\n\tu32   _r2;\n\tstruct asd_manuf_phy_desc phy_desc[ASD_MAX_PHYS];\n} __attribute__ ((packed));\n\n#if 0\nstatic const char *asd_sb_type[] = {\n\t\"unknown\",\n\t\"SGPIO\",\n\t[2 ... 0x7F] = \"unknown\",\n\t[0x80] = \"ADPT_I2C\",\n\t[0x81 ... 0xFF] = \"VENDOR_UNIQUExx\"\n};\n#endif\n\nstruct asd_ms_sb_desc {\n\tu8    type;\n\tu8    node_desc_index;\n\tu8    conn_desc_index;\n\tu8    _recvd[];\n} __attribute__ ((packed));\n\n#if 0\nstatic const char *asd_conn_type[] = {\n\t[0 ... 7] = \"unknown\",\n\t\"SFF8470\",\n\t\"SFF8482\",\n\t\"SFF8484\",\n\t[0x80] = \"PCIX_DAUGHTER0\",\n\t[0x81] = \"SAS_DAUGHTER0\",\n\t[0x82 ... 0xFF] = \"VENDOR_UNIQUExx\"\n};\n\nstatic const char *asd_conn_location[] = {\n\t\"unknown\",\n\t\"internal\",\n\t\"external\",\n\t\"board_to_board\",\n};\n#endif\n\nstruct asd_ms_conn_desc {\n\tu8    type;\n\tu8    location;\n\tu8    num_sideband_desc;\n\tu8    size_sideband_desc;\n\tu32   _resvd;\n\tu8    name[16];\n\tstruct asd_ms_sb_desc sb_desc[];\n} __attribute__ ((packed));\n\nstruct asd_nd_phy_desc {\n\tu8    vp_attch_type;\n\tu8    attch_specific[];\n} __attribute__ ((packed));\n\n#if 0\nstatic const char *asd_node_type[] = {\n\t\"IOP\",\n\t\"IO_CONTROLLER\",\n\t\"EXPANDER\",\n\t\"PORT_MULTIPLIER\",\n\t\"PORT_MULTIPLEXER\",\n\t\"MULTI_DROP_I2C_BUS\",\n};\n#endif\n\nstruct asd_ms_node_desc {\n\tu8    type;\n\tu8    num_phy_desc;\n\tu8    size_phy_desc;\n\tu8    _resvd;\n\tu8    name[16];\n\tstruct asd_nd_phy_desc phy_desc[];\n} __attribute__ ((packed));\n\nstruct asd_ms_conn_map {\n\tchar  sig[2];\t\t   \n\t__le16 next;\n\tu8    maj;\t\t   \n\tu8    min;\t\t   \n\t__le16 cm_size;\t\t   \n\tu8    num_conn;\n\tu8    conn_size;\n\tu8    num_nodes;\n\tu8    usage_model_id;\n\tu32   _resvd;\n\tunion {\n\t\tDECLARE_FLEX_ARRAY(struct asd_ms_conn_desc, conn_desc);\n\t\tDECLARE_FLEX_ARRAY(struct asd_ms_node_desc, node_desc);\n\t};\n} __attribute__ ((packed));\n\nstruct asd_ctrla_phy_entry {\n\tu8    sas_addr[SAS_ADDR_SIZE];\n\tu8    sas_link_rates;   \n\tu8    flags;\n\tu8    sata_link_rates;\n\tu8    _r[5];\n} __attribute__ ((packed));\n\nstruct asd_ctrla_phy_settings {\n\tu8    id0;\t\t   \n\tu8    _r;\n\tu16   next;\n\tu8    num_phys;\t       \n\tu8    _r2[3];\n\tstruct asd_ctrla_phy_entry phy_ent[ASD_MAX_PHYS];\n} __attribute__ ((packed));\n\nstruct asd_ll_el {\n\tu8   id0;\n\tu8   id1;\n\t__le16  next;\n\tu8   something_here[];\n} __attribute__ ((packed));\n\nstatic int asd_poll_flash(struct asd_ha_struct *asd_ha)\n{\n\tint c;\n\tu8 d;\n\n\tfor (c = 5000; c > 0; c--) {\n\t\td  = asd_read_reg_byte(asd_ha, asd_ha->hw_prof.flash.bar);\n\t\td ^= asd_read_reg_byte(asd_ha, asd_ha->hw_prof.flash.bar);\n\t\tif (!d)\n\t\t\treturn 0;\n\t\tudelay(5);\n\t}\n\treturn -ENOENT;\n}\n\nstatic int asd_reset_flash(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\n\terr = asd_poll_flash(asd_ha);\n\tif (err)\n\t\treturn err;\n\tasd_write_reg_byte(asd_ha, asd_ha->hw_prof.flash.bar, FLASH_RESET);\n\terr = asd_poll_flash(asd_ha);\n\n\treturn err;\n}\n\nstatic int asd_read_flash_seg(struct asd_ha_struct *asd_ha,\n\t\t\t      void *buffer, u32 offs, int size)\n{\n\tasd_read_reg_string(asd_ha, buffer, asd_ha->hw_prof.flash.bar+offs,\n\t\t\t    size);\n\treturn 0;\n}\n\n \nstatic int asd_find_flash_dir(struct asd_ha_struct *asd_ha,\n\t\t\t      struct asd_flash_dir *flash_dir)\n{\n\tu32 v;\n\tfor (v = 0; v < ASD_FLASH_SIZE; v += FLASH_NEXT_ENTRY_OFFS) {\n\t\tasd_read_flash_seg(asd_ha, flash_dir, v,\n\t\t\t\t   sizeof(FLASH_DIR_COOKIE)-1);\n\t\tif (memcmp(flash_dir->cookie, FLASH_DIR_COOKIE,\n\t\t\t   sizeof(FLASH_DIR_COOKIE)-1) == 0) {\n\t\t\tasd_ha->hw_prof.flash.dir_offs = v;\n\t\t\tasd_read_flash_seg(asd_ha, flash_dir, v,\n\t\t\t\t\t   sizeof(*flash_dir));\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int asd_flash_getid(struct asd_ha_struct *asd_ha)\n{\n\tint err = 0;\n\tu32 reg;\n\n\treg = asd_read_reg_dword(asd_ha, EXSICNFGR);\n\n\tif (pci_read_config_dword(asd_ha->pcidev, PCI_CONF_FLSH_BAR,\n\t\t\t\t  &asd_ha->hw_prof.flash.bar)) {\n\t\tasd_printk(\"couldn't read PCI_CONF_FLSH_BAR of %s\\n\",\n\t\t\t   pci_name(asd_ha->pcidev));\n\t\treturn -ENOENT;\n\t}\n\tasd_ha->hw_prof.flash.present = 1;\n\tasd_ha->hw_prof.flash.wide = reg & FLASHW ? 1 : 0;\n\terr = asd_reset_flash(asd_ha);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't reset flash(%d)\\n\", err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic u16 asd_calc_flash_chksum(u16 *p, int size)\n{\n\tu16 chksum = 0;\n\n\twhile (size-- > 0)\n\t\tchksum += *p++;\n\n\treturn chksum;\n}\n\n\nstatic int asd_find_flash_de(struct asd_flash_dir *flash_dir, u32 entry_type,\n\t\t\t     u32 *offs, u32 *size)\n{\n\tint i;\n\tstruct asd_flash_de *de;\n\n\tfor (i = 0; i < FLASH_MAX_DIR_ENTRIES; i++) {\n\t\tu32 type = le32_to_cpu(flash_dir->dir_entry[i].type);\n\n\t\ttype &= FLASH_DE_TYPE_MASK;\n\t\tif (type == entry_type)\n\t\t\tbreak;\n\t}\n\tif (i >= FLASH_MAX_DIR_ENTRIES)\n\t\treturn -ENOENT;\n\tde = &flash_dir->dir_entry[i];\n\t*offs = le32_to_cpu(de->offs);\n\t*size = le32_to_cpu(de->pad_size);\n\treturn 0;\n}\n\nstatic int asd_validate_ms(struct asd_manuf_sec *ms)\n{\n\tif (ms->sig[0] != 'S' || ms->sig[1] != 'M') {\n\t\tASD_DPRINTK(\"manuf sec: no valid sig(%c%c)\\n\",\n\t\t\t    ms->sig[0], ms->sig[1]);\n\t\treturn -ENOENT;\n\t}\n\tif (ms->maj != 0) {\n\t\tasd_printk(\"unsupported manuf. sector. major version:%x\\n\",\n\t\t\t   ms->maj);\n\t\treturn -ENOENT;\n\t}\n\tms->offs_next = le16_to_cpu((__force __le16) ms->offs_next);\n\tms->chksum = le16_to_cpu((__force __le16) ms->chksum);\n\tms->size = le16_to_cpu((__force __le16) ms->size);\n\n\tif (asd_calc_flash_chksum((u16 *)ms, ms->size/2)) {\n\t\tasd_printk(\"failed manuf sector checksum\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int asd_ms_get_sas_addr(struct asd_ha_struct *asd_ha,\n\t\t\t       struct asd_manuf_sec *ms)\n{\n\tmemcpy(asd_ha->hw_prof.sas_addr, ms->sas_addr, SAS_ADDR_SIZE);\n\treturn 0;\n}\n\nstatic int asd_ms_get_pcba_sn(struct asd_ha_struct *asd_ha,\n\t\t\t      struct asd_manuf_sec *ms)\n{\n\tmemcpy(asd_ha->hw_prof.pcba_sn, ms->pcba_sn, ASD_PCBA_SN_SIZE);\n\tasd_ha->hw_prof.pcba_sn[ASD_PCBA_SN_SIZE] = '\\0';\n\treturn 0;\n}\n\n \nstatic void *asd_find_ll_by_id(void * const start, const u8 id0, const u8 id1)\n{\n\tstruct asd_ll_el *el = start;\n\n\tdo {\n\t\tswitch (id1) {\n\t\tdefault:\n\t\t\tif (el->id1 == id1) {\n\t\t\tfallthrough;\n\t\tcase 0xFF:\n\t\t\t\tif (el->id0 == id0)\n\t\t\t\t\treturn el;\n\t\t\t}\n\t\t}\n\t\tel = start + le16_to_cpu(el->next);\n\t} while (el != start);\n\n\treturn NULL;\n}\n\n \nstatic int asd_ms_get_phy_params(struct asd_ha_struct *asd_ha,\n\t\t\t\t struct asd_manuf_sec *manuf_sec)\n{\n\tint i;\n\tint en_phys = 0;\n\tint rep_phys = 0;\n\tstruct asd_manuf_phy_param *phy_param;\n\tstruct asd_manuf_phy_param dflt_phy_param;\n\n\tphy_param = asd_find_ll_by_id(manuf_sec, 'P', 'M');\n\tif (!phy_param) {\n\t\tASD_DPRINTK(\"ms: no phy parameters found\\n\");\n\t\tASD_DPRINTK(\"ms: Creating default phy parameters\\n\");\n\t\tdflt_phy_param.sig[0] = 'P';\n\t\tdflt_phy_param.sig[1] = 'M';\n\t\tdflt_phy_param.maj = 0;\n\t\tdflt_phy_param.min = 2;\n\t\tdflt_phy_param.num_phy_desc = 8;\n\t\tdflt_phy_param.phy_desc_size = sizeof(struct asd_manuf_phy_desc);\n\t\tfor (i =0; i < ASD_MAX_PHYS; i++) {\n\t\t\tdflt_phy_param.phy_desc[i].state = 0;\n\t\t\tdflt_phy_param.phy_desc[i].phy_id = i;\n\t\t\tdflt_phy_param.phy_desc[i].phy_control_0 = 0xf6;\n\t\t\tdflt_phy_param.phy_desc[i].phy_control_1 = 0x10;\n\t\t\tdflt_phy_param.phy_desc[i].phy_control_2 = 0x43;\n\t\t\tdflt_phy_param.phy_desc[i].phy_control_3 = 0xeb;\n\t\t}\n\n\t\tphy_param = &dflt_phy_param;\n\n\t}\n\n\tif (phy_param->maj != 0) {\n\t\tasd_printk(\"unsupported manuf. phy param major version:0x%x\\n\",\n\t\t\t   phy_param->maj);\n\t\treturn -ENOENT;\n\t}\n\n\tASD_DPRINTK(\"ms: num_phy_desc: %d\\n\", phy_param->num_phy_desc);\n\tasd_ha->hw_prof.enabled_phys = 0;\n\tfor (i = 0; i < phy_param->num_phy_desc; i++) {\n\t\tstruct asd_manuf_phy_desc *pd = &phy_param->phy_desc[i];\n\t\tswitch (pd->state & 0xF) {\n\t\tcase MS_PHY_STATE_HIDDEN:\n\t\t\tASD_DPRINTK(\"ms: phy%d: HIDDEN\\n\", i);\n\t\t\tcontinue;\n\t\tcase MS_PHY_STATE_REPORTED:\n\t\t\tASD_DPRINTK(\"ms: phy%d: REPORTED\\n\", i);\n\t\t\tasd_ha->hw_prof.enabled_phys &= ~(1 << i);\n\t\t\trep_phys++;\n\t\t\tcontinue;\n\t\tcase MS_PHY_STATE_ENABLED:\n\t\t\tASD_DPRINTK(\"ms: phy%d: ENABLED\\n\", i);\n\t\t\tasd_ha->hw_prof.enabled_phys |= (1 << i);\n\t\t\ten_phys++;\n\t\t\tbreak;\n\t\t}\n\t\tasd_ha->hw_prof.phy_desc[i].phy_control_0 = pd->phy_control_0;\n\t\tasd_ha->hw_prof.phy_desc[i].phy_control_1 = pd->phy_control_1;\n\t\tasd_ha->hw_prof.phy_desc[i].phy_control_2 = pd->phy_control_2;\n\t\tasd_ha->hw_prof.phy_desc[i].phy_control_3 = pd->phy_control_3;\n\t}\n\tasd_ha->hw_prof.max_phys = rep_phys + en_phys;\n\tasd_ha->hw_prof.num_phys = en_phys;\n\tASD_DPRINTK(\"ms: max_phys:0x%x, num_phys:0x%x\\n\",\n\t\t    asd_ha->hw_prof.max_phys, asd_ha->hw_prof.num_phys);\n\tASD_DPRINTK(\"ms: enabled_phys:0x%x\\n\", asd_ha->hw_prof.enabled_phys);\n\treturn 0;\n}\n\nstatic int asd_ms_get_connector_map(struct asd_ha_struct *asd_ha,\n\t\t\t\t    struct asd_manuf_sec *manuf_sec)\n{\n\tstruct asd_ms_conn_map *cm;\n\n\tcm = asd_find_ll_by_id(manuf_sec, 'M', 'C');\n\tif (!cm) {\n\t\tASD_DPRINTK(\"ms: no connector map found\\n\");\n\t\treturn 0;\n\t}\n\n\tif (cm->maj != 0) {\n\t\tASD_DPRINTK(\"ms: unsupported: connector map major version 0x%x\"\n\t\t\t    \"\\n\", cm->maj);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\n\treturn 0;\n}\n\n\n \nstatic int asd_process_ms(struct asd_ha_struct *asd_ha,\n\t\t\t  struct asd_flash_dir *flash_dir)\n{\n\tint err;\n\tstruct asd_manuf_sec *manuf_sec;\n\tu32 offs, size;\n\n\terr = asd_find_flash_de(flash_dir, FLASH_DE_MS, &offs, &size);\n\tif (err) {\n\t\tASD_DPRINTK(\"Couldn't find the manuf. sector\\n\");\n\t\tgoto out;\n\t}\n\n\tif (size == 0)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmanuf_sec = kmalloc(size, GFP_KERNEL);\n\tif (!manuf_sec) {\n\t\tASD_DPRINTK(\"no mem for manuf sector\\n\");\n\t\tgoto out;\n\t}\n\n\terr = asd_read_flash_seg(asd_ha, (void *)manuf_sec, offs, size);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't read manuf sector at 0x%x, size 0x%x\\n\",\n\t\t\t    offs, size);\n\t\tgoto out2;\n\t}\n\n\terr = asd_validate_ms(manuf_sec);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't validate manuf sector\\n\");\n\t\tgoto out2;\n\t}\n\n\terr = asd_ms_get_sas_addr(asd_ha, manuf_sec);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't read the SAS_ADDR\\n\");\n\t\tgoto out2;\n\t}\n\tASD_DPRINTK(\"manuf sect SAS_ADDR %llx\\n\",\n\t\t    SAS_ADDR(asd_ha->hw_prof.sas_addr));\n\n\terr = asd_ms_get_pcba_sn(asd_ha, manuf_sec);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't read the PCBA SN\\n\");\n\t\tgoto out2;\n\t}\n\tASD_DPRINTK(\"manuf sect PCBA SN %s\\n\", asd_ha->hw_prof.pcba_sn);\n\n\terr = asd_ms_get_phy_params(asd_ha, manuf_sec);\n\tif (err) {\n\t\tASD_DPRINTK(\"ms: couldn't get phy parameters\\n\");\n\t\tgoto out2;\n\t}\n\n\terr = asd_ms_get_connector_map(asd_ha, manuf_sec);\n\tif (err) {\n\t\tASD_DPRINTK(\"ms: couldn't get connector map\\n\");\n\t\tgoto out2;\n\t}\n\nout2:\n\tkfree(manuf_sec);\nout:\n\treturn err;\n}\n\nstatic int asd_process_ctrla_phy_settings(struct asd_ha_struct *asd_ha,\n\t\t\t\t\t  struct asd_ctrla_phy_settings *ps)\n{\n\tint i;\n\tfor (i = 0; i < ps->num_phys; i++) {\n\t\tstruct asd_ctrla_phy_entry *pe = &ps->phy_ent[i];\n\n\t\tif (!PHY_ENABLED(asd_ha, i))\n\t\t\tcontinue;\n\t\tif (*(u64 *)pe->sas_addr == 0) {\n\t\t\tasd_ha->hw_prof.enabled_phys &= ~(1 << i);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tmemcpy(asd_ha->hw_prof.phy_desc[i].sas_addr, pe->sas_addr,\n\t\t       SAS_ADDR_SIZE);\n\t\tasd_ha->hw_prof.phy_desc[i].max_sas_lrate =\n\t\t\t(pe->sas_link_rates & 0xF0) >> 4;\n\t\tasd_ha->hw_prof.phy_desc[i].min_sas_lrate =\n\t\t\t(pe->sas_link_rates & 0x0F);\n\t\tasd_ha->hw_prof.phy_desc[i].max_sata_lrate =\n\t\t\t(pe->sata_link_rates & 0xF0) >> 4;\n\t\tasd_ha->hw_prof.phy_desc[i].min_sata_lrate =\n\t\t\t(pe->sata_link_rates & 0x0F);\n\t\tasd_ha->hw_prof.phy_desc[i].flags = pe->flags;\n\t\tASD_DPRINTK(\"ctrla: phy%d: sas_addr: %llx, sas rate:0x%x-0x%x,\"\n\t\t\t    \" sata rate:0x%x-0x%x, flags:0x%x\\n\",\n\t\t\t    i,\n\t\t\t    SAS_ADDR(asd_ha->hw_prof.phy_desc[i].sas_addr),\n\t\t\t    asd_ha->hw_prof.phy_desc[i].max_sas_lrate,\n\t\t\t    asd_ha->hw_prof.phy_desc[i].min_sas_lrate,\n\t\t\t    asd_ha->hw_prof.phy_desc[i].max_sata_lrate,\n\t\t\t    asd_ha->hw_prof.phy_desc[i].min_sata_lrate,\n\t\t\t    asd_ha->hw_prof.phy_desc[i].flags);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int asd_process_ctrl_a_user(struct asd_ha_struct *asd_ha,\n\t\t\t\t   struct asd_flash_dir *flash_dir)\n{\n\tint err, i;\n\tu32 offs, size;\n\tstruct asd_ll_el *el = NULL;\n\tstruct asd_ctrla_phy_settings *ps;\n\tstruct asd_ctrla_phy_settings dflt_ps;\n\n\terr = asd_find_flash_de(flash_dir, FLASH_DE_CTRL_A_USER, &offs, &size);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't find CTRL-A user settings section\\n\");\n\t\tASD_DPRINTK(\"Creating default CTRL-A user settings section\\n\");\n\n\t\tdflt_ps.id0 = 'h';\n\t\tdflt_ps.num_phys = 8;\n\t\tfor (i =0; i < ASD_MAX_PHYS; i++) {\n\t\t\tmemcpy(dflt_ps.phy_ent[i].sas_addr,\n\t\t\t       asd_ha->hw_prof.sas_addr, SAS_ADDR_SIZE);\n\t\t\tdflt_ps.phy_ent[i].sas_link_rates = 0x98;\n\t\t\tdflt_ps.phy_ent[i].flags = 0x0;\n\t\t\tdflt_ps.phy_ent[i].sata_link_rates = 0x0;\n\t\t}\n\n\t\tsize = sizeof(struct asd_ctrla_phy_settings);\n\t\tps = &dflt_ps;\n\t\tgoto out_process;\n\t}\n\n\tif (size == 0)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tel = kmalloc(size, GFP_KERNEL);\n\tif (!el) {\n\t\tASD_DPRINTK(\"no mem for ctrla user settings section\\n\");\n\t\tgoto out;\n\t}\n\n\terr = asd_read_flash_seg(asd_ha, (void *)el, offs, size);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't read ctrla phy settings section\\n\");\n\t\tgoto out2;\n\t}\n\n\terr = -ENOENT;\n\tps = asd_find_ll_by_id(el, 'h', 0xFF);\n\tif (!ps) {\n\t\tASD_DPRINTK(\"couldn't find ctrla phy settings struct\\n\");\n\t\tgoto out2;\n\t}\nout_process:\n\terr = asd_process_ctrla_phy_settings(asd_ha, ps);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't process ctrla phy settings\\n\");\n\t\tgoto out2;\n\t}\nout2:\n\tkfree(el);\nout:\n\treturn err;\n}\n\n \nint asd_read_flash(struct asd_ha_struct *asd_ha)\n{\n\tint err;\n\tstruct asd_flash_dir *flash_dir;\n\n\terr = asd_flash_getid(asd_ha);\n\tif (err)\n\t\treturn err;\n\n\tflash_dir = kmalloc(sizeof(*flash_dir), GFP_KERNEL);\n\tif (!flash_dir)\n\t\treturn -ENOMEM;\n\n\terr = -ENOENT;\n\tif (!asd_find_flash_dir(asd_ha, flash_dir)) {\n\t\tASD_DPRINTK(\"couldn't find flash directory\\n\");\n\t\tgoto out;\n\t}\n\n\tif (le32_to_cpu(flash_dir->rev) != 2) {\n\t\tasd_printk(\"unsupported flash dir version:0x%x\\n\",\n\t\t\t   le32_to_cpu(flash_dir->rev));\n\t\tgoto out;\n\t}\n\n\terr = asd_process_ms(asd_ha, flash_dir);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't process manuf sector settings\\n\");\n\t\tgoto out;\n\t}\n\n\terr = asd_process_ctrl_a_user(asd_ha, flash_dir);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't process CTRL-A user settings\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(flash_dir);\n\treturn err;\n}\n\n \nint asd_verify_flash_seg(struct asd_ha_struct *asd_ha,\n\t\t\t const void *src, u32 dest_offset, u32 bytes_to_verify)\n{\n\tconst u8 *src_buf;\n\tu8 flash_char;\n\tint err;\n\tu32 nv_offset, reg, i;\n\n\treg = asd_ha->hw_prof.flash.bar;\n\tsrc_buf = NULL;\n\n\terr = FLASH_OK;\n\tnv_offset = dest_offset;\n\tsrc_buf = (const u8 *)src;\n\tfor (i = 0; i < bytes_to_verify; i++) {\n\t\tflash_char = asd_read_reg_byte(asd_ha, reg + nv_offset + i);\n\t\tif (flash_char != src_buf[i]) {\n\t\t\terr = FAIL_VERIFY;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\n \nint asd_write_flash_seg(struct asd_ha_struct *asd_ha,\n\t\t\tconst void *src, u32 dest_offset, u32 bytes_to_write)\n{\n\tconst u8 *src_buf;\n\tu32 nv_offset, reg, i;\n\tint err;\n\n\treg = asd_ha->hw_prof.flash.bar;\n\tsrc_buf = NULL;\n\n\terr = asd_check_flash_type(asd_ha);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't find the type of flash. err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\tnv_offset = dest_offset;\n\terr = asd_erase_nv_sector(asd_ha, nv_offset, bytes_to_write);\n\tif (err) {\n\t\tASD_DPRINTK(\"Erase failed at offset:0x%x\\n\",\n\t\t\tnv_offset);\n\t\treturn err;\n\t}\n\n\terr = asd_reset_flash(asd_ha);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't reset flash. err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\tsrc_buf = (const u8 *)src;\n\tfor (i = 0; i < bytes_to_write; i++) {\n\t\t \n\t\tswitch (asd_ha->hw_prof.flash.method) {\n\t\tcase FLASH_METHOD_A:\n\t\t{\n\t\t\tasd_write_reg_byte(asd_ha,\n\t\t\t\t\t(reg + 0xAAA), 0xAA);\n\t\t\tasd_write_reg_byte(asd_ha,\n\t\t\t\t\t(reg + 0x555), 0x55);\n\t\t\tasd_write_reg_byte(asd_ha,\n\t\t\t\t\t(reg + 0xAAA), 0xA0);\n\t\t\tasd_write_reg_byte(asd_ha,\n\t\t\t\t\t(reg + nv_offset + i),\n\t\t\t\t\t(*(src_buf + i)));\n\t\t\tbreak;\n\t\t}\n\t\tcase FLASH_METHOD_B:\n\t\t{\n\t\t\tasd_write_reg_byte(asd_ha,\n\t\t\t\t\t(reg + 0x555), 0xAA);\n\t\t\tasd_write_reg_byte(asd_ha,\n\t\t\t\t\t(reg + 0x2AA), 0x55);\n\t\t\tasd_write_reg_byte(asd_ha,\n\t\t\t\t\t(reg + 0x555), 0xA0);\n\t\t\tasd_write_reg_byte(asd_ha,\n\t\t\t\t\t(reg + nv_offset + i),\n\t\t\t\t\t(*(src_buf + i)));\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (asd_chk_write_status(asd_ha,\n\t\t\t\t(nv_offset + i), 0) != 0) {\n\t\t\tASD_DPRINTK(\"aicx: Write failed at offset:0x%x\\n\",\n\t\t\t\treg + nv_offset + i);\n\t\t\treturn FAIL_WRITE_FLASH;\n\t\t}\n\t}\n\n\terr = asd_reset_flash(asd_ha);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't reset flash. err=%d\\n\", err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nint asd_chk_write_status(struct asd_ha_struct *asd_ha,\n\t u32 sector_addr, u8 erase_flag)\n{\n\tu32 reg;\n\tu32 loop_cnt;\n\tu8  nv_data1, nv_data2;\n\tu8  toggle_bit1;\n\n\t \n\treg = asd_ha->hw_prof.flash.bar;\n\n\tfor (loop_cnt = 0; loop_cnt < 50000; loop_cnt++) {\n\t\tnv_data1 = asd_read_reg_byte(asd_ha, reg);\n\t\tnv_data2 = asd_read_reg_byte(asd_ha, reg);\n\n\t\ttoggle_bit1 = ((nv_data1 & FLASH_STATUS_BIT_MASK_DQ6)\n\t\t\t\t ^ (nv_data2 & FLASH_STATUS_BIT_MASK_DQ6));\n\n\t\tif (toggle_bit1 == 0) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (nv_data2 & FLASH_STATUS_BIT_MASK_DQ5) {\n\t\t\t\tnv_data1 = asd_read_reg_byte(asd_ha,\n\t\t\t\t\t\t\t\treg);\n\t\t\t\tnv_data2 = asd_read_reg_byte(asd_ha,\n\t\t\t\t\t\t\t\treg);\n\t\t\t\ttoggle_bit1 =\n\t\t\t\t((nv_data1 & FLASH_STATUS_BIT_MASK_DQ6)\n\t\t\t\t^ (nv_data2 & FLASH_STATUS_BIT_MASK_DQ6));\n\n\t\t\t\tif (toggle_bit1 == 0)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (erase_flag) {\n\t\t\tudelay(FLASH_STATUS_ERASE_DELAY_COUNT);\n\t\t} else {\n\t\t\tudelay(FLASH_STATUS_WRITE_DELAY_COUNT);\n\t\t}\n\t}\n\treturn -1;\n}\n\n \nint asd_erase_nv_sector(struct asd_ha_struct *asd_ha, u32 flash_addr, u32 size)\n{\n\tu32 reg;\n\tu32 sector_addr;\n\n\treg = asd_ha->hw_prof.flash.bar;\n\n\t \n\tsector_addr = flash_addr & FLASH_SECTOR_SIZE_MASK;\n\n\t \n\twhile (sector_addr < flash_addr+size) {\n\t\tswitch (asd_ha->hw_prof.flash.method) {\n\t\tcase FLASH_METHOD_A:\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0xAAA), 0xAA);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0x555), 0x55);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0xAAA), 0x80);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0xAAA), 0xAA);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0x555), 0x55);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + sector_addr), 0x30);\n\t\t\tbreak;\n\t\tcase FLASH_METHOD_B:\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0x555), 0xAA);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0x2AA), 0x55);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0x555), 0x80);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0x555), 0xAA);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + 0x2AA), 0x55);\n\t\t\tasd_write_reg_byte(asd_ha, (reg + sector_addr), 0x30);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (asd_chk_write_status(asd_ha, sector_addr, 1) != 0)\n\t\t\treturn FAIL_ERASE_FLASH;\n\n\t\tsector_addr += FLASH_SECTOR_SIZE;\n\t}\n\n\treturn 0;\n}\n\nint asd_check_flash_type(struct asd_ha_struct *asd_ha)\n{\n\tu8 manuf_id;\n\tu8 dev_id;\n\tu8 sec_prot;\n\tu32 inc;\n\tu32 reg;\n\tint err;\n\n\t \n\treg = asd_ha->hw_prof.flash.bar;\n\n\t \n\terr = asd_reset_flash(asd_ha);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't reset flash. err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\tasd_ha->hw_prof.flash.method = FLASH_METHOD_UNKNOWN;\n\tasd_ha->hw_prof.flash.manuf = FLASH_MANUF_ID_UNKNOWN;\n\tasd_ha->hw_prof.flash.dev_id = FLASH_DEV_ID_UNKNOWN;\n\n\t \n\tinc = asd_ha->hw_prof.flash.wide ? 2 : 1;\n\tasd_write_reg_byte(asd_ha, reg + 0xAAA, 0xAA);\n\tasd_write_reg_byte(asd_ha, reg + 0x555, 0x55);\n\tasd_write_reg_byte(asd_ha, reg + 0xAAA, 0x90);\n\tmanuf_id = asd_read_reg_byte(asd_ha, reg);\n\tdev_id = asd_read_reg_byte(asd_ha, reg + inc);\n\tsec_prot = asd_read_reg_byte(asd_ha, reg + inc + inc);\n\t \n\terr = asd_reset_flash(asd_ha);\n\tif (err) {\n\t\tASD_DPRINTK(\"couldn't reset flash. err=%d\\n\", err);\n\t\treturn err;\n\t}\n\tASD_DPRINTK(\"Flash MethodA manuf_id(0x%x) dev_id(0x%x) \"\n\t\t\"sec_prot(0x%x)\\n\", manuf_id, dev_id, sec_prot);\n\terr = asd_reset_flash(asd_ha);\n\tif (err != 0)\n\t\treturn err;\n\n\tswitch (manuf_id) {\n\tcase FLASH_MANUF_ID_AMD:\n\t\tswitch (sec_prot) {\n\t\tcase FLASH_DEV_ID_AM29LV800DT:\n\t\tcase FLASH_DEV_ID_AM29LV640MT:\n\t\tcase FLASH_DEV_ID_AM29F800B:\n\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FLASH_MANUF_ID_ST:\n\t\tswitch (sec_prot) {\n\t\tcase FLASH_DEV_ID_STM29W800DT:\n\t\tcase FLASH_DEV_ID_STM29LV640:\n\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_A;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FLASH_MANUF_ID_FUJITSU:\n\t\tswitch (sec_prot) {\n\t\tcase FLASH_DEV_ID_MBM29LV800TE:\n\t\tcase FLASH_DEV_ID_MBM29DL800TA:\n\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_A;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FLASH_MANUF_ID_MACRONIX:\n\t\tswitch (sec_prot) {\n\t\tcase FLASH_DEV_ID_MX29LV800BT:\n\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_A;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (asd_ha->hw_prof.flash.method == FLASH_METHOD_UNKNOWN) {\n\t\terr = asd_reset_flash(asd_ha);\n\t\tif (err) {\n\t\t\tASD_DPRINTK(\"couldn't reset flash. err=%d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tasd_write_reg_byte(asd_ha, (reg + 0x555), 0xAA);\n\t\tasd_write_reg_byte(asd_ha, (reg + 0x2AA), 0x55);\n\t\tasd_write_reg_byte(asd_ha, (reg + 0x555), 0x90);\n\t\tmanuf_id = asd_read_reg_byte(asd_ha, reg);\n\t\tdev_id = asd_read_reg_byte(asd_ha, reg + inc);\n\t\tsec_prot = asd_read_reg_byte(asd_ha, reg + inc + inc);\n\n\t\tASD_DPRINTK(\"Flash MethodB manuf_id(0x%x) dev_id(0x%x) sec_prot\"\n\t\t\t\"(0x%x)\\n\", manuf_id, dev_id, sec_prot);\n\n\t\terr = asd_reset_flash(asd_ha);\n\t\tif (err != 0) {\n\t\t\tASD_DPRINTK(\"couldn't reset flash. err=%d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tswitch (manuf_id) {\n\t\tcase FLASH_MANUF_ID_AMD:\n\t\t\tswitch (dev_id) {\n\t\t\tcase FLASH_DEV_ID_AM29LV008BT:\n\t\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLASH_MANUF_ID_ST:\n\t\t\tswitch (dev_id) {\n\t\t\tcase FLASH_DEV_ID_STM29008:\n\t\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLASH_MANUF_ID_FUJITSU:\n\t\t\tswitch (dev_id) {\n\t\t\tcase FLASH_DEV_ID_MBM29LV008TA:\n\t\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLASH_MANUF_ID_INTEL:\n\t\t\tswitch (dev_id) {\n\t\t\tcase FLASH_DEV_ID_I28LV00TAT:\n\t\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FLASH_MANUF_ID_MACRONIX:\n\t\t\tswitch (dev_id) {\n\t\t\tcase FLASH_DEV_ID_I28LV00TAT:\n\t\t\t\tasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn FAIL_FIND_FLASH_ID;\n\t\t}\n\t}\n\n\tif (asd_ha->hw_prof.flash.method == FLASH_METHOD_UNKNOWN)\n\t      return FAIL_FIND_FLASH_ID;\n\n\tasd_ha->hw_prof.flash.manuf = manuf_id;\n\tasd_ha->hw_prof.flash.dev_id = dev_id;\n\tasd_ha->hw_prof.flash.sec_prot = sec_prot;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}