{
  "module_name": "aic94xx_reg.c",
  "hash_id": "db8048de0c5214c226b2f6bfaf9bd3a0971825a74ec89c4897fec9f4ec241897",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_reg.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include \"aic94xx_reg.h\"\n#include \"aic94xx.h\"\n\n \nstatic void asd_write_byte(struct asd_ha_struct *asd_ha,\n\t\t\t   unsigned long offs, u8 val)\n{\n\tif (unlikely(asd_ha->iospace))\n\t\toutb(val,\n\t\t     (unsigned long)asd_ha->io_handle[0].addr + (offs & 0xFF));\n\telse\n\t\twriteb(val, asd_ha->io_handle[0].addr + offs);\n\twmb();\n}\n\nstatic void asd_write_word(struct asd_ha_struct *asd_ha,\n\t\t\t   unsigned long offs, u16 val)\n{\n\tif (unlikely(asd_ha->iospace))\n\t\toutw(val,\n\t\t     (unsigned long)asd_ha->io_handle[0].addr + (offs & 0xFF));\n\telse\n\t\twritew(val, asd_ha->io_handle[0].addr + offs);\n\twmb();\n}\n\nstatic void asd_write_dword(struct asd_ha_struct *asd_ha,\n\t\t\t    unsigned long offs, u32 val)\n{\n\tif (unlikely(asd_ha->iospace))\n\t\toutl(val,\n\t\t     (unsigned long)asd_ha->io_handle[0].addr + (offs & 0xFF));\n\telse\n\t\twritel(val, asd_ha->io_handle[0].addr + offs);\n\twmb();\n}\n\n \nstatic u8 asd_read_byte(struct asd_ha_struct *asd_ha, unsigned long offs)\n{\n\tu8 val;\n\tif (unlikely(asd_ha->iospace))\n\t\tval = inb((unsigned long) asd_ha->io_handle[0].addr\n\t\t\t  + (offs & 0xFF));\n\telse\n\t\tval = readb(asd_ha->io_handle[0].addr + offs);\n\trmb();\n\treturn val;\n}\n\nstatic u16 asd_read_word(struct asd_ha_struct *asd_ha,\n\t\t\t unsigned long offs)\n{\n\tu16 val;\n\tif (unlikely(asd_ha->iospace))\n\t\tval = inw((unsigned long)asd_ha->io_handle[0].addr\n\t\t\t  + (offs & 0xFF));\n\telse\n\t\tval = readw(asd_ha->io_handle[0].addr + offs);\n\trmb();\n\treturn val;\n}\n\nstatic u32 asd_read_dword(struct asd_ha_struct *asd_ha,\n\t\t\t  unsigned long offs)\n{\n\tu32 val;\n\tif (unlikely(asd_ha->iospace))\n\t\tval = inl((unsigned long) asd_ha->io_handle[0].addr\n\t\t\t  + (offs & 0xFF));\n\telse\n\t\tval = readl(asd_ha->io_handle[0].addr + offs);\n\trmb();\n\treturn val;\n}\n\nstatic inline u32 asd_mem_offs_swa(void)\n{\n\treturn 0;\n}\n\nstatic inline u32 asd_mem_offs_swc(void)\n{\n\treturn asd_mem_offs_swa() + MBAR0_SWA_SIZE;\n}\n\nstatic inline u32 asd_mem_offs_swb(void)\n{\n\treturn asd_mem_offs_swc() + MBAR0_SWC_SIZE + 0x20;\n}\n\n \n#define ASD_READ_SW(ww, type, ord)\t\t\t\t\t\\\nstatic type asd_read_##ww##_##ord(struct asd_ha_struct *asd_ha,\t\t\\\n\t\t\t\t   u32 reg)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct asd_ha_addrspace *io_handle = &asd_ha->io_handle[0];\t\\\n\tu32 map_offs = (reg - io_handle->ww##_base) + asd_mem_offs_##ww();\\\n\treturn asd_read_##ord(asd_ha, (unsigned long)map_offs);\t\\\n}\n\n#define ASD_WRITE_SW(ww, type, ord)\t\t\t\t\t\\\nstatic void asd_write_##ww##_##ord(struct asd_ha_struct *asd_ha,\t\\\n\t\t\t\t    u32 reg, type val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct asd_ha_addrspace *io_handle = &asd_ha->io_handle[0];\t\\\n\tu32 map_offs = (reg - io_handle->ww##_base) + asd_mem_offs_##ww();\\\n\tasd_write_##ord(asd_ha, (unsigned long)map_offs, val);\t\t\\\n}\n\nASD_READ_SW(swa, u8,  byte);\nASD_READ_SW(swa, u16, word);\nASD_READ_SW(swa, u32, dword);\n\nASD_READ_SW(swb, u8,  byte);\nASD_READ_SW(swb, u16, word);\nASD_READ_SW(swb, u32, dword);\n\nASD_READ_SW(swc, u8,  byte);\nASD_READ_SW(swc, u16, word);\nASD_READ_SW(swc, u32, dword);\n\nASD_WRITE_SW(swa, u8,  byte);\nASD_WRITE_SW(swa, u16, word);\nASD_WRITE_SW(swa, u32, dword);\n\nASD_WRITE_SW(swb, u8,  byte);\nASD_WRITE_SW(swb, u16, word);\nASD_WRITE_SW(swb, u32, dword);\n\nASD_WRITE_SW(swc, u8,  byte);\nASD_WRITE_SW(swc, u16, word);\nASD_WRITE_SW(swc, u32, dword);\n\n \n\n \nstatic void asd_move_swb(struct asd_ha_struct *asd_ha, u32 reg)\n{\n\tu32 base = reg & ~(MBAR0_SWB_SIZE-1);\n\tpci_write_config_dword(asd_ha->pcidev, PCI_CONF_MBAR0_SWB, base);\n\tasd_ha->io_handle[0].swb_base = base;\n}\n\nstatic void __asd_write_reg_byte(struct asd_ha_struct *asd_ha, u32 reg, u8 val)\n{\n\tstruct asd_ha_addrspace *io_handle=&asd_ha->io_handle[0];\n\tBUG_ON(reg >= 0xC0000000 || reg < ALL_BASE_ADDR);\n\tif (io_handle->swa_base <= reg\n\t    && reg < io_handle->swa_base + MBAR0_SWA_SIZE)\n\t\tasd_write_swa_byte (asd_ha, reg,val);\n\telse if (io_handle->swb_base <= reg\n\t\t && reg < io_handle->swb_base + MBAR0_SWB_SIZE)\n\t\tasd_write_swb_byte (asd_ha, reg, val);\n\telse if (io_handle->swc_base <= reg\n\t\t && reg < io_handle->swc_base + MBAR0_SWC_SIZE)\n\t\tasd_write_swc_byte (asd_ha, reg, val);\n\telse {\n\t\t \n\t\tasd_move_swb(asd_ha, reg);\n\t\tasd_write_swb_byte (asd_ha, reg, val);\n\t}\n}\n\n#define ASD_WRITE_REG(type, ord)                                  \\\nvoid asd_write_reg_##ord (struct asd_ha_struct *asd_ha, u32 reg, type val)\\\n{                                                                 \\\n\tstruct asd_ha_addrspace *io_handle=&asd_ha->io_handle[0]; \\\n\tunsigned long flags;                                      \\\n\tBUG_ON(reg >= 0xC0000000 || reg < ALL_BASE_ADDR);         \\\n\tspin_lock_irqsave(&asd_ha->iolock, flags);                \\\n\tif (io_handle->swa_base <= reg                            \\\n\t    && reg < io_handle->swa_base + MBAR0_SWA_SIZE)        \\\n\t\tasd_write_swa_##ord (asd_ha, reg,val);            \\\n\telse if (io_handle->swb_base <= reg                       \\\n\t\t && reg < io_handle->swb_base + MBAR0_SWB_SIZE)   \\\n\t\tasd_write_swb_##ord (asd_ha, reg, val);           \\\n\telse if (io_handle->swc_base <= reg                       \\\n\t\t && reg < io_handle->swc_base + MBAR0_SWC_SIZE)   \\\n\t\tasd_write_swc_##ord (asd_ha, reg, val);           \\\n\telse {                                                    \\\n\t\t                      \\\n\t\tasd_move_swb(asd_ha, reg);                        \\\n\t\tasd_write_swb_##ord (asd_ha, reg, val);           \\\n\t}                                                         \\\n\tspin_unlock_irqrestore(&asd_ha->iolock, flags);           \\\n}\n\nASD_WRITE_REG(u8, byte);\nASD_WRITE_REG(u16,word);\nASD_WRITE_REG(u32,dword);\n\nstatic u8 __asd_read_reg_byte(struct asd_ha_struct *asd_ha, u32 reg)\n{\n\tstruct asd_ha_addrspace *io_handle=&asd_ha->io_handle[0];\n\tu8 val;\n\tBUG_ON(reg >= 0xC0000000 || reg < ALL_BASE_ADDR);\n\tif (io_handle->swa_base <= reg\n\t    && reg < io_handle->swa_base + MBAR0_SWA_SIZE)\n\t\tval = asd_read_swa_byte (asd_ha, reg);\n\telse if (io_handle->swb_base <= reg\n\t\t && reg < io_handle->swb_base + MBAR0_SWB_SIZE)\n\t\tval = asd_read_swb_byte (asd_ha, reg);\n\telse if (io_handle->swc_base <= reg\n\t\t && reg < io_handle->swc_base + MBAR0_SWC_SIZE)\n\t\tval = asd_read_swc_byte (asd_ha, reg);\n\telse {\n\t\t \n\t\tasd_move_swb(asd_ha, reg);\n\t\tval = asd_read_swb_byte (asd_ha, reg);\n\t}\n\treturn val;\n}\n\n#define ASD_READ_REG(type, ord)                                   \\\ntype asd_read_reg_##ord (struct asd_ha_struct *asd_ha, u32 reg)   \\\n{                                                                 \\\n\tstruct asd_ha_addrspace *io_handle=&asd_ha->io_handle[0]; \\\n\ttype val;                                                 \\\n\tunsigned long flags;                                      \\\n\tBUG_ON(reg >= 0xC0000000 || reg < ALL_BASE_ADDR);         \\\n\tspin_lock_irqsave(&asd_ha->iolock, flags);                \\\n\tif (io_handle->swa_base <= reg                            \\\n\t    && reg < io_handle->swa_base + MBAR0_SWA_SIZE)        \\\n\t\tval = asd_read_swa_##ord (asd_ha, reg);           \\\n\telse if (io_handle->swb_base <= reg                       \\\n\t\t && reg < io_handle->swb_base + MBAR0_SWB_SIZE)   \\\n\t\tval = asd_read_swb_##ord (asd_ha, reg);           \\\n\telse if (io_handle->swc_base <= reg                       \\\n\t\t && reg < io_handle->swc_base + MBAR0_SWC_SIZE)   \\\n\t\tval = asd_read_swc_##ord (asd_ha, reg);           \\\n\telse {                                                    \\\n\t\t                      \\\n\t\tasd_move_swb(asd_ha, reg);                        \\\n\t\tval = asd_read_swb_##ord (asd_ha, reg);           \\\n\t}                                                         \\\n\tspin_unlock_irqrestore(&asd_ha->iolock, flags);           \\\n\treturn val;                                               \\\n}\n\nASD_READ_REG(u8, byte);\nASD_READ_REG(u16,word);\nASD_READ_REG(u32,dword);\n\n \nvoid asd_read_reg_string(struct asd_ha_struct *asd_ha, void *dst,\n\t\t\t u32 offs, int count)\n{\n\tu8 *p = dst;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->iolock, flags);\n\tfor ( ; count > 0; count--, offs++, p++)\n\t\t*p = __asd_read_reg_byte(asd_ha, offs);\n\tspin_unlock_irqrestore(&asd_ha->iolock, flags);\n}\n\n \nvoid asd_write_reg_string(struct asd_ha_struct *asd_ha, void *src,\n\t\t\t  u32 offs, int count)\n{\n\tu8 *p = src;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->iolock, flags);\n\tfor ( ; count > 0; count--, offs++, p++)\n\t\t__asd_write_reg_byte(asd_ha, offs, *p);\n\tspin_unlock_irqrestore(&asd_ha->iolock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}