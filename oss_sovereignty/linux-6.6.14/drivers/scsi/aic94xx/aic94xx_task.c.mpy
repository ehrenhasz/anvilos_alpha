{
  "module_name": "aic94xx_task.c",
  "hash_id": "62796ec8710f401a474aa5eedb27975bdf4a3e44872ddde12a3029e1caae4823",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_task.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include \"aic94xx.h\"\n#include \"aic94xx_sas.h\"\n#include \"aic94xx_hwi.h\"\n\nstatic void asd_unbuild_ata_ascb(struct asd_ascb *a);\nstatic void asd_unbuild_smp_ascb(struct asd_ascb *a);\nstatic void asd_unbuild_ssp_ascb(struct asd_ascb *a);\n\nstatic void asd_can_dequeue(struct asd_ha_struct *asd_ha, int num)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\n\tasd_ha->seq.can_queue += num;\n\tspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\n}\n\n \nstatic const u8 data_dir_flags[] = {\n\t[DMA_BIDIRECTIONAL]\t= DATA_DIR_BYRECIPIENT,\t \n\t[DMA_TO_DEVICE]\t\t= DATA_DIR_OUT,\t\t \n\t[DMA_FROM_DEVICE]\t= DATA_DIR_IN,\t\t \n\t[DMA_NONE]\t\t= DATA_DIR_NONE,\t \n};\n\nstatic int asd_map_scatterlist(struct sas_task *task,\n\t\t\t       struct sg_el *sg_arr,\n\t\t\t       gfp_t gfp_flags)\n{\n\tstruct asd_ascb *ascb = task->lldd_task;\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tstruct scatterlist *sc;\n\tint num_sg, res;\n\n\tif (task->data_dir == DMA_NONE)\n\t\treturn 0;\n\n\tif (task->num_scatter == 0) {\n\t\tvoid *p = task->scatter;\n\t\tdma_addr_t dma = dma_map_single(&asd_ha->pcidev->dev, p,\n\t\t\t\t\t\ttask->total_xfer_len,\n\t\t\t\t\t\ttask->data_dir);\n\t\tif (dma_mapping_error(&asd_ha->pcidev->dev, dma))\n\t\t\treturn -ENOMEM;\n\n\t\tsg_arr[0].bus_addr = cpu_to_le64((u64)dma);\n\t\tsg_arr[0].size = cpu_to_le32(task->total_xfer_len);\n\t\tsg_arr[0].flags |= ASD_SG_EL_LIST_EOL;\n\t\treturn 0;\n\t}\n\n\t \n\tif (sas_protocol_ata(task->task_proto))\n\t\tnum_sg = task->num_scatter;\n\telse\n\t\tnum_sg = dma_map_sg(&asd_ha->pcidev->dev, task->scatter,\n\t\t\t\t    task->num_scatter, task->data_dir);\n\tif (num_sg == 0)\n\t\treturn -ENOMEM;\n\n\tif (num_sg > 3) {\n\t\tint i;\n\n\t\tascb->sg_arr = asd_alloc_coherent(asd_ha,\n\t\t\t\t\t\t  num_sg*sizeof(struct sg_el),\n\t\t\t\t\t\t  gfp_flags);\n\t\tif (!ascb->sg_arr) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto err_unmap;\n\t\t}\n\t\tfor_each_sg(task->scatter, sc, num_sg, i) {\n\t\t\tstruct sg_el *sg =\n\t\t\t\t&((struct sg_el *)ascb->sg_arr->vaddr)[i];\n\t\t\tsg->bus_addr = cpu_to_le64((u64)sg_dma_address(sc));\n\t\t\tsg->size = cpu_to_le32((u32)sg_dma_len(sc));\n\t\t\tif (i == num_sg-1)\n\t\t\t\tsg->flags |= ASD_SG_EL_LIST_EOL;\n\t\t}\n\n\t\tfor_each_sg(task->scatter, sc, 2, i) {\n\t\t\tsg_arr[i].bus_addr =\n\t\t\t\tcpu_to_le64((u64)sg_dma_address(sc));\n\t\t\tsg_arr[i].size = cpu_to_le32((u32)sg_dma_len(sc));\n\t\t}\n\t\tsg_arr[1].next_sg_offs = 2 * sizeof(*sg_arr);\n\t\tsg_arr[1].flags |= ASD_SG_EL_LIST_EOS;\n\n\t\tmemset(&sg_arr[2], 0, sizeof(*sg_arr));\n\t\tsg_arr[2].bus_addr=cpu_to_le64((u64)ascb->sg_arr->dma_handle);\n\t} else {\n\t\tint i;\n\t\tfor_each_sg(task->scatter, sc, num_sg, i) {\n\t\t\tsg_arr[i].bus_addr =\n\t\t\t\tcpu_to_le64((u64)sg_dma_address(sc));\n\t\t\tsg_arr[i].size = cpu_to_le32((u32)sg_dma_len(sc));\n\t\t}\n\t\tsg_arr[i-1].flags |= ASD_SG_EL_LIST_EOL;\n\t}\n\n\treturn 0;\nerr_unmap:\n\tif (sas_protocol_ata(task->task_proto))\n\t\tdma_unmap_sg(&asd_ha->pcidev->dev, task->scatter,\n\t\t\t     task->num_scatter, task->data_dir);\n\treturn res;\n}\n\nstatic void asd_unmap_scatterlist(struct asd_ascb *ascb)\n{\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tstruct sas_task *task = ascb->uldd_task;\n\n\tif (task->data_dir == DMA_NONE)\n\t\treturn;\n\n\tif (task->num_scatter == 0) {\n\t\tdma_addr_t dma = (dma_addr_t)\n\t\t       le64_to_cpu(ascb->scb->ssp_task.sg_element[0].bus_addr);\n\t\tdma_unmap_single(&ascb->ha->pcidev->dev, dma,\n\t\t\t\t task->total_xfer_len, task->data_dir);\n\t\treturn;\n\t}\n\n\tasd_free_coherent(asd_ha, ascb->sg_arr);\n\tif (task->task_proto != SAS_PROTOCOL_STP)\n\t\tdma_unmap_sg(&asd_ha->pcidev->dev, task->scatter,\n\t\t\t     task->num_scatter, task->data_dir);\n}\n\n \n\nstatic void asd_get_response_tasklet(struct asd_ascb *ascb,\n\t\t\t\t     struct done_list_struct *dl)\n{\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tstruct sas_task *task = ascb->uldd_task;\n\tstruct task_status_struct *ts = &task->task_status;\n\tunsigned long flags;\n\tstruct tc_resp_sb_struct {\n\t\t__le16 index_escb;\n\t\tu8     len_lsb;\n\t\tu8     flags;\n\t} __attribute__ ((packed)) *resp_sb = (void *) dl->status_block;\n\n \n\tint  edb_id = ((resp_sb->flags & 0x70) >> 4)-1;\n\tstruct asd_ascb *escb;\n\tstruct asd_dma_tok *edb;\n\tvoid *r;\n\n\tspin_lock_irqsave(&asd_ha->seq.tc_index_lock, flags);\n\tescb = asd_tc_index_find(&asd_ha->seq,\n\t\t\t\t (int)le16_to_cpu(resp_sb->index_escb));\n\tspin_unlock_irqrestore(&asd_ha->seq.tc_index_lock, flags);\n\n\tif (!escb) {\n\t\tASD_DPRINTK(\"Uh-oh! No escb for this dl?!\\n\");\n\t\treturn;\n\t}\n\n\tts->buf_valid_size = 0;\n\tedb = asd_ha->seq.edb_arr[edb_id + escb->edb_index];\n\tr = edb->vaddr;\n\tif (task->task_proto == SAS_PROTOCOL_SSP) {\n\t\tstruct ssp_response_iu *iu =\n\t\t\tr + 16 + sizeof(struct ssp_frame_hdr);\n\n\t\tts->residual = le32_to_cpu(*(__le32 *)r);\n\n\t\tsas_ssp_task_response(&asd_ha->pcidev->dev, task, iu);\n\t}  else {\n\t\tstruct ata_task_resp *resp = (void *) &ts->buf[0];\n\n\t\tts->residual = le32_to_cpu(*(__le32 *)r);\n\n\t\tif (SAS_STATUS_BUF_SIZE >= sizeof(*resp)) {\n\t\t\tresp->frame_len = le16_to_cpu(*(__le16 *)(r+6));\n\t\t\tmemcpy(&resp->ending_fis[0], r+16, ATA_RESP_FIS_SIZE);\n\t\t\tts->buf_valid_size = sizeof(*resp);\n\t\t}\n\t}\n\n\tasd_invalidate_edb(escb, edb_id);\n}\n\nstatic void asd_task_tasklet_complete(struct asd_ascb *ascb,\n\t\t\t\t      struct done_list_struct *dl)\n{\n\tstruct sas_task *task = ascb->uldd_task;\n\tstruct task_status_struct *ts = &task->task_status;\n\tunsigned long flags;\n\tu8 opcode = dl->opcode;\n\n\tasd_can_dequeue(ascb->ha, 1);\n\nAgain:\n\tswitch (opcode) {\n\tcase TC_NO_ERROR:\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_SAM_STAT_GOOD;\n\t\tbreak;\n\tcase TC_UNDERRUN:\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_UNDERRUN;\n\t\tts->residual = le32_to_cpu(*(__le32 *)dl->status_block);\n\t\tbreak;\n\tcase TC_OVERRUN:\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_DATA_OVERRUN;\n\t\tts->residual = 0;\n\t\tbreak;\n\tcase TC_SSP_RESP:\n\tcase TC_ATA_RESP:\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_PROTO_RESPONSE;\n\t\tasd_get_response_tasklet(ascb, dl);\n\t\tbreak;\n\tcase TF_OPEN_REJECT:\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_OPEN_REJECT;\n\t\tif (dl->status_block[1] & 2)\n\t\t\tts->open_rej_reason = 1 + dl->status_block[2];\n\t\telse if (dl->status_block[1] & 1)\n\t\t\tts->open_rej_reason = (dl->status_block[2] >> 4)+10;\n\t\telse\n\t\t\tts->open_rej_reason = SAS_OREJ_UNKNOWN;\n\t\tbreak;\n\tcase TF_OPEN_TO:\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_OPEN_TO;\n\t\tbreak;\n\tcase TF_PHY_DOWN:\n\tcase TU_PHY_DOWN:\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tbreak;\n\tcase TI_PHY_DOWN:\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_PHY_DOWN;\n\t\tbreak;\n\tcase TI_BREAK:\n\tcase TI_PROTO_ERR:\n\tcase TI_NAK:\n\tcase TI_ACK_NAK_TO:\n\tcase TF_SMP_XMIT_RCV_ERR:\n\tcase TC_ATA_R_ERR_RECV:\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_INTERRUPTED;\n\t\tbreak;\n\tcase TF_BREAK:\n\tcase TU_BREAK:\n\tcase TU_ACK_NAK_TO:\n\tcase TF_SMPRSP_TO:\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tbreak;\n\tcase TF_NAK_RECV:\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_NAK_R_ERR;\n\t\tbreak;\n\tcase TA_I_T_NEXUS_LOSS:\n\t\topcode = dl->status_block[0];\n\t\tgoto Again;\n\tcase TF_INV_CONN_HANDLE:\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_DEVICE_UNKNOWN;\n\t\tbreak;\n\tcase TF_REQUESTED_N_PENDING:\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_PENDING;\n\t\tbreak;\n\tcase TC_TASK_CLEARED:\n\tcase TA_ON_REQ:\n\t\tts->resp = SAS_TASK_COMPLETE;\n\t\tts->stat = SAS_ABORTED_TASK;\n\t\tbreak;\n\n\tcase TF_NO_SMP_CONN:\n\tcase TF_TMF_NO_CTX:\n\tcase TF_TMF_NO_TAG:\n\tcase TF_TMF_TAG_FREE:\n\tcase TF_TMF_TASK_DONE:\n\tcase TF_TMF_NO_CONN_HANDLE:\n\tcase TF_IRTT_TO:\n\tcase TF_IU_SHORT:\n\tcase TF_DATA_OFFS_ERR:\n\t\tts->resp = SAS_TASK_UNDELIVERED;\n\t\tts->stat = SAS_DEV_NO_RESPONSE;\n\t\tbreak;\n\n\tcase TC_LINK_ADM_RESP:\n\tcase TC_CONTROL_PHY:\n\tcase TC_RESUME:\n\tcase TC_PARTIAL_SG_LIST:\n\tdefault:\n\t\tASD_DPRINTK(\"%s: dl opcode: 0x%x?\\n\", __func__, opcode);\n\t\tbreak;\n\t}\n\n\tswitch (task->task_proto) {\n\tcase SAS_PROTOCOL_SATA:\n\tcase SAS_PROTOCOL_STP:\n\t\tasd_unbuild_ata_ascb(ascb);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SMP:\n\t\tasd_unbuild_smp_ascb(ascb);\n\t\tbreak;\n\tcase SAS_PROTOCOL_SSP:\n\t\tasd_unbuild_ssp_ascb(ascb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\ttask->task_state_flags &= ~SAS_TASK_STATE_PENDING;\n\ttask->task_state_flags |= SAS_TASK_STATE_DONE;\n\tif (unlikely((task->task_state_flags & SAS_TASK_STATE_ABORTED))) {\n\t\tstruct completion *completion = ascb->completion;\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\tASD_DPRINTK(\"task 0x%p done with opcode 0x%x resp 0x%x \"\n\t\t\t    \"stat 0x%x but aborted by upper layer!\\n\",\n\t\t\t    task, opcode, ts->resp, ts->stat);\n\t\tif (completion)\n\t\t\tcomplete(completion);\n\t} else {\n\t\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\t\ttask->lldd_task = NULL;\n\t\tasd_ascb_free(ascb);\n\t\tmb();\n\t\ttask->task_done(task);\n\t}\n}\n\n \n\nstatic int asd_build_ata_ascb(struct asd_ascb *ascb, struct sas_task *task,\n\t\t\t      gfp_t gfp_flags)\n{\n\tstruct domain_device *dev = task->dev;\n\tstruct scb *scb;\n\tu8     flags;\n\tint    res = 0;\n\n\tscb = ascb->scb;\n\n\tif (unlikely(task->ata_task.device_control_reg_update))\n\t\tscb->header.opcode = CONTROL_ATA_DEV;\n\telse if (dev->sata_dev.class == ATA_DEV_ATAPI)\n\t\tscb->header.opcode = INITIATE_ATAPI_TASK;\n\telse\n\t\tscb->header.opcode = INITIATE_ATA_TASK;\n\n\tscb->ata_task.proto_conn_rate = (1 << 5);  \n\tif (dev->port->oob_mode == SAS_OOB_MODE)\n\t\tscb->ata_task.proto_conn_rate |= dev->linkrate;\n\n\tscb->ata_task.total_xfer_len = cpu_to_le32(task->total_xfer_len);\n\tscb->ata_task.fis = task->ata_task.fis;\n\tif (likely(!task->ata_task.device_control_reg_update))\n\t\tscb->ata_task.fis.flags |= 0x80;  \n\tscb->ata_task.fis.flags &= 0xF0;  \n\tif (dev->sata_dev.class == ATA_DEV_ATAPI)\n\t\tmemcpy(scb->ata_task.atapi_packet, task->ata_task.atapi_packet,\n\t\t       16);\n\tscb->ata_task.sister_scb = cpu_to_le16(0xFFFF);\n\tscb->ata_task.conn_handle = cpu_to_le16(\n\t\t(u16)(unsigned long)dev->lldd_dev);\n\n\tif (likely(!task->ata_task.device_control_reg_update)) {\n\t\tflags = 0;\n\t\tif (task->ata_task.dma_xfer)\n\t\t\tflags |= DATA_XFER_MODE_DMA;\n\t\tif (task->ata_task.use_ncq &&\n\t\t    dev->sata_dev.class != ATA_DEV_ATAPI)\n\t\t\tflags |= ATA_Q_TYPE_NCQ;\n\t\tflags |= data_dir_flags[task->data_dir];\n\t\tscb->ata_task.ata_flags = flags;\n\n\t\tscb->ata_task.retry_count = 0;\n\n\t\tscb->ata_task.flags = 0;\n\t}\n\tascb->tasklet_complete = asd_task_tasklet_complete;\n\n\tif (likely(!task->ata_task.device_control_reg_update))\n\t\tres = asd_map_scatterlist(task, scb->ata_task.sg_element,\n\t\t\t\t\t  gfp_flags);\n\n\treturn res;\n}\n\nstatic void asd_unbuild_ata_ascb(struct asd_ascb *a)\n{\n\tasd_unmap_scatterlist(a);\n}\n\n \n\nstatic int asd_build_smp_ascb(struct asd_ascb *ascb, struct sas_task *task,\n\t\t\t      gfp_t gfp_flags)\n{\n\tstruct asd_ha_struct *asd_ha = ascb->ha;\n\tstruct domain_device *dev = task->dev;\n\tstruct scb *scb;\n\n\tdma_map_sg(&asd_ha->pcidev->dev, &task->smp_task.smp_req, 1,\n\t\t   DMA_TO_DEVICE);\n\tdma_map_sg(&asd_ha->pcidev->dev, &task->smp_task.smp_resp, 1,\n\t\t   DMA_FROM_DEVICE);\n\n\tscb = ascb->scb;\n\n\tscb->header.opcode = INITIATE_SMP_TASK;\n\n\tscb->smp_task.proto_conn_rate = dev->linkrate;\n\n\tscb->smp_task.smp_req.bus_addr =\n\t\tcpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_req));\n\tscb->smp_task.smp_req.size =\n\t\tcpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_req)-4);\n\n\tscb->smp_task.smp_resp.bus_addr =\n\t\tcpu_to_le64((u64)sg_dma_address(&task->smp_task.smp_resp));\n\tscb->smp_task.smp_resp.size =\n\t\tcpu_to_le32((u32)sg_dma_len(&task->smp_task.smp_resp)-4);\n\n\tscb->smp_task.sister_scb = cpu_to_le16(0xFFFF);\n\tscb->smp_task.conn_handle = cpu_to_le16((u16)\n\t\t\t\t\t\t(unsigned long)dev->lldd_dev);\n\n\tascb->tasklet_complete = asd_task_tasklet_complete;\n\n\treturn 0;\n}\n\nstatic void asd_unbuild_smp_ascb(struct asd_ascb *a)\n{\n\tstruct sas_task *task = a->uldd_task;\n\n\tBUG_ON(!task);\n\tdma_unmap_sg(&a->ha->pcidev->dev, &task->smp_task.smp_req, 1,\n\t\t     DMA_TO_DEVICE);\n\tdma_unmap_sg(&a->ha->pcidev->dev, &task->smp_task.smp_resp, 1,\n\t\t     DMA_FROM_DEVICE);\n}\n\n \n\nstatic int asd_build_ssp_ascb(struct asd_ascb *ascb, struct sas_task *task,\n\t\t\t      gfp_t gfp_flags)\n{\n\tstruct domain_device *dev = task->dev;\n\tstruct scb *scb;\n\tint    res = 0;\n\n\tscb = ascb->scb;\n\n\tscb->header.opcode = INITIATE_SSP_TASK;\n\n\tscb->ssp_task.proto_conn_rate  = (1 << 4);  \n\tscb->ssp_task.proto_conn_rate |= dev->linkrate;\n\tscb->ssp_task.total_xfer_len = cpu_to_le32(task->total_xfer_len);\n\tscb->ssp_task.ssp_frame.frame_type = SSP_DATA;\n\tmemcpy(scb->ssp_task.ssp_frame.hashed_dest_addr, dev->hashed_sas_addr,\n\t       HASHED_SAS_ADDR_SIZE);\n\tmemcpy(scb->ssp_task.ssp_frame.hashed_src_addr,\n\t       dev->port->ha->hashed_sas_addr, HASHED_SAS_ADDR_SIZE);\n\tscb->ssp_task.ssp_frame.tptt = cpu_to_be16(0xFFFF);\n\n\tmemcpy(scb->ssp_task.ssp_cmd.lun, task->ssp_task.LUN, 8);\n\tscb->ssp_task.ssp_cmd.efb_prio_attr |= (task->ssp_task.task_attr & 7);\n\tmemcpy(scb->ssp_task.ssp_cmd.cdb, task->ssp_task.cmd->cmnd,\n\t       task->ssp_task.cmd->cmd_len);\n\n\tscb->ssp_task.sister_scb = cpu_to_le16(0xFFFF);\n\tscb->ssp_task.conn_handle = cpu_to_le16(\n\t\t(u16)(unsigned long)dev->lldd_dev);\n\tscb->ssp_task.data_dir = data_dir_flags[task->data_dir];\n\tscb->ssp_task.retry_count = scb->ssp_task.retry_count;\n\n\tascb->tasklet_complete = asd_task_tasklet_complete;\n\n\tres = asd_map_scatterlist(task, scb->ssp_task.sg_element, gfp_flags);\n\n\treturn res;\n}\n\nstatic void asd_unbuild_ssp_ascb(struct asd_ascb *a)\n{\n\tasd_unmap_scatterlist(a);\n}\n\n \n\nstatic int asd_can_queue(struct asd_ha_struct *asd_ha, int num)\n{\n\tint res = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&asd_ha->seq.pend_q_lock, flags);\n\tif ((asd_ha->seq.can_queue - num) < 0)\n\t\tres = -SAS_QUEUE_FULL;\n\telse\n\t\tasd_ha->seq.can_queue -= num;\n\tspin_unlock_irqrestore(&asd_ha->seq.pend_q_lock, flags);\n\n\treturn res;\n}\n\nint asd_execute_task(struct sas_task *task, gfp_t gfp_flags)\n{\n\tint res = 0;\n\tLIST_HEAD(alist);\n\tstruct sas_task *t = task;\n\tstruct asd_ascb *ascb = NULL, *a;\n\tstruct asd_ha_struct *asd_ha = task->dev->port->ha->lldd_ha;\n\n\tres = asd_can_queue(asd_ha, 1);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tascb = asd_ascb_alloc_list(asd_ha, &res, gfp_flags);\n\tif (res) {\n\t\tres = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\t__list_add(&alist, ascb->list.prev, &ascb->list);\n\tlist_for_each_entry(a, &alist, list) {\n\t\ta->uldd_task = t;\n\t\tt->lldd_task = a;\n\t\tbreak;\n\t}\n\tlist_for_each_entry(a, &alist, list) {\n\t\tt = a->uldd_task;\n\t\ta->uldd_timer = 1;\n\t\tif (t->task_proto & SAS_PROTOCOL_STP)\n\t\t\tt->task_proto = SAS_PROTOCOL_STP;\n\t\tswitch (t->task_proto) {\n\t\tcase SAS_PROTOCOL_SATA:\n\t\tcase SAS_PROTOCOL_STP:\n\t\t\tres = asd_build_ata_ascb(a, t, gfp_flags);\n\t\t\tbreak;\n\t\tcase SAS_PROTOCOL_SMP:\n\t\t\tres = asd_build_smp_ascb(a, t, gfp_flags);\n\t\t\tbreak;\n\t\tcase SAS_PROTOCOL_SSP:\n\t\t\tres = asd_build_ssp_ascb(a, t, gfp_flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tasd_printk(\"unknown sas_task proto: 0x%x\\n\",\n\t\t\t\t   t->task_proto);\n\t\t\tres = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tif (res)\n\t\t\tgoto out_err_unmap;\n\t}\n\tlist_del_init(&alist);\n\n\tres = asd_post_ascb_list(asd_ha, ascb, 1);\n\tif (unlikely(res)) {\n\t\ta = NULL;\n\t\t__list_add(&alist, ascb->list.prev, &ascb->list);\n\t\tgoto out_err_unmap;\n\t}\n\n\treturn 0;\nout_err_unmap:\n\t{\n\t\tstruct asd_ascb *b = a;\n\t\tlist_for_each_entry(a, &alist, list) {\n\t\t\tif (a == b)\n\t\t\t\tbreak;\n\t\t\tt = a->uldd_task;\n\t\t\tswitch (t->task_proto) {\n\t\t\tcase SAS_PROTOCOL_SATA:\n\t\t\tcase SAS_PROTOCOL_STP:\n\t\t\t\tasd_unbuild_ata_ascb(a);\n\t\t\t\tbreak;\n\t\t\tcase SAS_PROTOCOL_SMP:\n\t\t\t\tasd_unbuild_smp_ascb(a);\n\t\t\t\tbreak;\n\t\t\tcase SAS_PROTOCOL_SSP:\n\t\t\t\tasd_unbuild_ssp_ascb(a);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt->lldd_task = NULL;\n\t\t}\n\t}\n\tlist_del_init(&alist);\nout_err:\n\tif (ascb)\n\t\tasd_ascb_free_list(ascb);\n\tasd_can_dequeue(asd_ha, 1);\n\treturn res;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}