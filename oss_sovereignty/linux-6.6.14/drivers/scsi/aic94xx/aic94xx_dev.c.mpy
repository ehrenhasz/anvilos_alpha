{
  "module_name": "aic94xx_dev.c",
  "hash_id": "5e7a7f5daab9eedad2a20b519936f3b352f2f02a66db48f928f48c2a0fc55b4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aic94xx/aic94xx_dev.c",
  "human_readable_source": "\n \n\n#include \"aic94xx.h\"\n#include \"aic94xx_hwi.h\"\n#include \"aic94xx_reg.h\"\n#include \"aic94xx_sas.h\"\n\n#define FIND_FREE_DDB(_ha) find_first_zero_bit((_ha)->hw_prof.ddb_bitmap, \\\n\t\t\t\t\t       (_ha)->hw_prof.max_ddbs)\n#define SET_DDB(_ddb, _ha) set_bit(_ddb, (_ha)->hw_prof.ddb_bitmap)\n#define CLEAR_DDB(_ddb, _ha) clear_bit(_ddb, (_ha)->hw_prof.ddb_bitmap)\n\nstatic int asd_get_ddb(struct asd_ha_struct *asd_ha)\n{\n\tint ddb, i;\n\n\tddb = FIND_FREE_DDB(asd_ha);\n\tif (ddb >= asd_ha->hw_prof.max_ddbs) {\n\t\tddb = -ENOMEM;\n\t\tgoto out;\n\t}\n\tSET_DDB(ddb, asd_ha);\n\n\tfor (i = 0; i < sizeof(struct asd_ddb_ssp_smp_target_port); i+= 4)\n\t\tasd_ddbsite_write_dword(asd_ha, ddb, i, 0);\nout:\n\treturn ddb;\n}\n\n#define INIT_CONN_TAG   offsetof(struct asd_ddb_ssp_smp_target_port, init_conn_tag)\n#define DEST_SAS_ADDR   offsetof(struct asd_ddb_ssp_smp_target_port, dest_sas_addr)\n#define SEND_QUEUE_HEAD offsetof(struct asd_ddb_ssp_smp_target_port, send_queue_head)\n#define DDB_TYPE        offsetof(struct asd_ddb_ssp_smp_target_port, ddb_type)\n#define CONN_MASK       offsetof(struct asd_ddb_ssp_smp_target_port, conn_mask)\n#define DDB_TARG_FLAGS  offsetof(struct asd_ddb_ssp_smp_target_port, flags)\n#define DDB_TARG_FLAGS2 offsetof(struct asd_ddb_stp_sata_target_port, flags2)\n#define EXEC_QUEUE_TAIL offsetof(struct asd_ddb_ssp_smp_target_port, exec_queue_tail)\n#define SEND_QUEUE_TAIL offsetof(struct asd_ddb_ssp_smp_target_port, send_queue_tail)\n#define SISTER_DDB      offsetof(struct asd_ddb_ssp_smp_target_port, sister_ddb)\n#define MAX_CCONN       offsetof(struct asd_ddb_ssp_smp_target_port, max_concurrent_conn)\n#define NUM_CTX         offsetof(struct asd_ddb_ssp_smp_target_port, num_contexts)\n#define ATA_CMD_SCBPTR  offsetof(struct asd_ddb_stp_sata_target_port, ata_cmd_scbptr)\n#define SATA_TAG_ALLOC_MASK offsetof(struct asd_ddb_stp_sata_target_port, sata_tag_alloc_mask)\n#define NUM_SATA_TAGS   offsetof(struct asd_ddb_stp_sata_target_port, num_sata_tags)\n#define SATA_STATUS     offsetof(struct asd_ddb_stp_sata_target_port, sata_status)\n#define NCQ_DATA_SCB_PTR offsetof(struct asd_ddb_stp_sata_target_port, ncq_data_scb_ptr)\n#define ITNL_TIMEOUT    offsetof(struct asd_ddb_ssp_smp_target_port, itnl_timeout)\n\nstatic void asd_free_ddb(struct asd_ha_struct *asd_ha, int ddb)\n{\n\tif (!ddb || ddb >= 0xFFFF)\n\t\treturn;\n\tasd_ddbsite_write_byte(asd_ha, ddb, DDB_TYPE, DDB_TYPE_UNUSED);\n\tCLEAR_DDB(ddb, asd_ha);\n}\n\nstatic void asd_set_ddb_type(struct domain_device *dev)\n{\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\tint ddb = (int) (unsigned long) dev->lldd_dev;\n\n\tif (dev->dev_type == SAS_SATA_PM_PORT)\n\t\tasd_ddbsite_write_byte(asd_ha,ddb, DDB_TYPE, DDB_TYPE_PM_PORT);\n\telse if (dev->tproto)\n\t\tasd_ddbsite_write_byte(asd_ha,ddb, DDB_TYPE, DDB_TYPE_TARGET);\n\telse\n\t\tasd_ddbsite_write_byte(asd_ha,ddb,DDB_TYPE,DDB_TYPE_INITIATOR);\n}\n\nstatic int asd_init_sata_tag_ddb(struct domain_device *dev)\n{\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\tint ddb, i;\n\n\tddb = asd_get_ddb(asd_ha);\n\tif (ddb < 0)\n\t\treturn ddb;\n\n\tfor (i = 0; i < sizeof(struct asd_ddb_sata_tag); i += 2)\n\t\tasd_ddbsite_write_word(asd_ha, ddb, i, 0xFFFF);\n\n\tasd_ddbsite_write_word(asd_ha, (int) (unsigned long) dev->lldd_dev,\n\t\t\t       SISTER_DDB, ddb);\n\treturn 0;\n}\n\nvoid asd_set_dmamode(struct domain_device *dev)\n{\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\tstruct ata_device *ata_dev = sas_to_ata_dev(dev);\n\tint ddb = (int) (unsigned long) dev->lldd_dev;\n\tu32 qdepth = 0;\n\n\tif (dev->dev_type == SAS_SATA_DEV || dev->dev_type == SAS_SATA_PM_PORT) {\n\t\tif (ata_id_has_ncq(ata_dev->id))\n\t\t\tqdepth = ata_id_queue_depth(ata_dev->id);\n\t\tasd_ddbsite_write_dword(asd_ha, ddb, SATA_TAG_ALLOC_MASK,\n\t\t\t\t\t(1ULL<<qdepth)-1);\n\t\tasd_ddbsite_write_byte(asd_ha, ddb, NUM_SATA_TAGS, qdepth);\n\t}\n\n\tif (qdepth > 0)\n\t\tif (asd_init_sata_tag_ddb(dev) != 0) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(dev->sata_dev.ap->lock, flags);\n\t\t\tata_dev->flags |= ATA_DFLAG_NCQ_OFF;\n\t\t\tspin_unlock_irqrestore(dev->sata_dev.ap->lock, flags);\n\t\t}\n}\n\nstatic int asd_init_sata(struct domain_device *dev)\n{\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\tint ddb = (int) (unsigned long) dev->lldd_dev;\n\n\tasd_ddbsite_write_word(asd_ha, ddb, ATA_CMD_SCBPTR, 0xFFFF);\n\tif (dev->dev_type == SAS_SATA_DEV || dev->dev_type == SAS_SATA_PM ||\n\t    dev->dev_type == SAS_SATA_PM_PORT) {\n\t\tstruct dev_to_host_fis *fis = (struct dev_to_host_fis *)\n\t\t\tdev->frame_rcvd;\n\t\tasd_ddbsite_write_byte(asd_ha, ddb, SATA_STATUS, fis->status);\n\t}\n\tasd_ddbsite_write_word(asd_ha, ddb, NCQ_DATA_SCB_PTR, 0xFFFF);\n\n\treturn 0;\n}\n\nstatic int asd_init_target_ddb(struct domain_device *dev)\n{\n\tint ddb, i;\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\tu8 flags = 0;\n\n\tddb = asd_get_ddb(asd_ha);\n\tif (ddb < 0)\n\t\treturn ddb;\n\n\tdev->lldd_dev = (void *) (unsigned long) ddb;\n\n\tasd_ddbsite_write_byte(asd_ha, ddb, 0, DDB_TP_CONN_TYPE);\n\tasd_ddbsite_write_byte(asd_ha, ddb, 1, 0);\n\tasd_ddbsite_write_word(asd_ha, ddb, INIT_CONN_TAG, 0xFFFF);\n\tfor (i = 0; i < SAS_ADDR_SIZE; i++)\n\t\tasd_ddbsite_write_byte(asd_ha, ddb, DEST_SAS_ADDR+i,\n\t\t\t\t       dev->sas_addr[i]);\n\tasd_ddbsite_write_word(asd_ha, ddb, SEND_QUEUE_HEAD, 0xFFFF);\n\tasd_set_ddb_type(dev);\n\tasd_ddbsite_write_byte(asd_ha, ddb, CONN_MASK, dev->port->phy_mask);\n\tif (dev->port->oob_mode != SATA_OOB_MODE) {\n\t\tflags |= OPEN_REQUIRED;\n\t\tif ((dev->dev_type == SAS_SATA_DEV) ||\n\t\t    (dev->tproto & SAS_PROTOCOL_STP)) {\n\t\t\tstruct smp_rps_resp *rps_resp = &dev->sata_dev.rps_resp;\n\t\t\tif (rps_resp->frame_type == SMP_RESPONSE &&\n\t\t\t    rps_resp->function == SMP_REPORT_PHY_SATA &&\n\t\t\t    rps_resp->result == SMP_RESP_FUNC_ACC) {\n\t\t\t\tif (rps_resp->rps.affil_valid)\n\t\t\t\t\tflags |= STP_AFFIL_POL;\n\t\t\t\tif (rps_resp->rps.affil_supp)\n\t\t\t\t\tflags |= SUPPORTS_AFFIL;\n\t\t\t}\n\t\t} else {\n\t\t\tflags |= CONCURRENT_CONN_SUPP;\n\t\t\tif (!dev->parent && dev_is_expander(dev->dev_type))\n\t\t\t\tasd_ddbsite_write_byte(asd_ha, ddb, MAX_CCONN,\n\t\t\t\t\t\t       4);\n\t\t\telse\n\t\t\t\tasd_ddbsite_write_byte(asd_ha, ddb, MAX_CCONN,\n\t\t\t\t\t\t       dev->pathways);\n\t\t\tasd_ddbsite_write_byte(asd_ha, ddb, NUM_CTX, 1);\n\t\t}\n\t}\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\tflags |= SATA_MULTIPORT;\n\tasd_ddbsite_write_byte(asd_ha, ddb, DDB_TARG_FLAGS, flags);\n\n\tflags = 0;\n\tif (dev->tproto & SAS_PROTOCOL_STP)\n\t\tflags |= STP_CL_POL_NO_TX;\n\tasd_ddbsite_write_byte(asd_ha, ddb, DDB_TARG_FLAGS2, flags);\n\n\tasd_ddbsite_write_word(asd_ha, ddb, EXEC_QUEUE_TAIL, 0xFFFF);\n\tasd_ddbsite_write_word(asd_ha, ddb, SEND_QUEUE_TAIL, 0xFFFF);\n\tasd_ddbsite_write_word(asd_ha, ddb, SISTER_DDB, 0xFFFF);\n\n\tif (dev->dev_type == SAS_SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {\n\t\ti = asd_init_sata(dev);\n\t\tif (i < 0) {\n\t\t\tasd_free_ddb(asd_ha, ddb);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (dev->dev_type == SAS_END_DEVICE) {\n\t\tstruct sas_end_device *rdev = rphy_to_end_device(dev->rphy);\n\t\tif (rdev->I_T_nexus_loss_timeout > 0)\n\t\t\tasd_ddbsite_write_word(asd_ha, ddb, ITNL_TIMEOUT,\n\t\t\t\t\t       min(rdev->I_T_nexus_loss_timeout,\n\t\t\t\t\t\t   (u16)ITNL_TIMEOUT_CONST));\n\t\telse\n\t\t\tasd_ddbsite_write_word(asd_ha, ddb, ITNL_TIMEOUT,\n\t\t\t\t\t       (u16)ITNL_TIMEOUT_CONST);\n\t}\n\treturn 0;\n}\n\nstatic int asd_init_sata_pm_table_ddb(struct domain_device *dev)\n{\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\tint ddb, i;\n\n\tddb = asd_get_ddb(asd_ha);\n\tif (ddb < 0)\n\t\treturn ddb;\n\n\tfor (i = 0; i < 32; i += 2)\n\t\tasd_ddbsite_write_word(asd_ha, ddb, i, 0xFFFF);\n\n\tasd_ddbsite_write_word(asd_ha, (int) (unsigned long) dev->lldd_dev,\n\t\t\t       SISTER_DDB, ddb);\n\n\treturn 0;\n}\n\n#define PM_PORT_FLAGS offsetof(struct asd_ddb_sata_pm_port, pm_port_flags)\n#define PARENT_DDB    offsetof(struct asd_ddb_sata_pm_port, parent_ddb)\n\n \nstatic int asd_init_sata_pm_port_ddb(struct domain_device *dev)\n{\n\tint ddb, i, parent_ddb, pmtable_ddb;\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\tu8  flags;\n\n\tddb = asd_get_ddb(asd_ha);\n\tif (ddb < 0)\n\t\treturn ddb;\n\n\tasd_set_ddb_type(dev);\n\tflags = (dev->sata_dev.port_no << 4) | PM_PORT_SET;\n\tasd_ddbsite_write_byte(asd_ha, ddb, PM_PORT_FLAGS, flags);\n\tasd_ddbsite_write_word(asd_ha, ddb, SISTER_DDB, 0xFFFF);\n\tasd_ddbsite_write_word(asd_ha, ddb, ATA_CMD_SCBPTR, 0xFFFF);\n\tasd_init_sata(dev);\n\n\tparent_ddb = (int) (unsigned long) dev->parent->lldd_dev;\n\tasd_ddbsite_write_word(asd_ha, ddb, PARENT_DDB, parent_ddb);\n\tpmtable_ddb = asd_ddbsite_read_word(asd_ha, parent_ddb, SISTER_DDB);\n\tasd_ddbsite_write_word(asd_ha, pmtable_ddb, dev->sata_dev.port_no,ddb);\n\n\tif (asd_ddbsite_read_byte(asd_ha, ddb, NUM_SATA_TAGS) > 0) {\n\t\ti = asd_init_sata_tag_ddb(dev);\n\t\tif (i < 0) {\n\t\t\tasd_free_ddb(asd_ha, ddb);\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int asd_init_initiator_ddb(struct domain_device *dev)\n{\n\treturn -ENODEV;\n}\n\n \nstatic int asd_init_sata_pm_ddb(struct domain_device *dev)\n{\n\tint res = 0;\n\n\tres = asd_init_target_ddb(dev);\n\tif (res)\n\t\tgoto out;\n\tres = asd_init_sata_pm_table_ddb(dev);\n\tif (res)\n\t\tasd_free_ddb(dev->port->ha->lldd_ha,\n\t\t\t     (int) (unsigned long) dev->lldd_dev);\nout:\n\treturn res;\n}\n\nint asd_dev_found(struct domain_device *dev)\n{\n\tunsigned long flags;\n\tint res = 0;\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\n\tspin_lock_irqsave(&asd_ha->hw_prof.ddb_lock, flags);\n\tswitch (dev->dev_type) {\n\tcase SAS_SATA_PM:\n\t\tres = asd_init_sata_pm_ddb(dev);\n\t\tbreak;\n\tcase SAS_SATA_PM_PORT:\n\t\tres = asd_init_sata_pm_port_ddb(dev);\n\t\tbreak;\n\tdefault:\n\t\tif (dev->tproto)\n\t\t\tres = asd_init_target_ddb(dev);\n\t\telse\n\t\t\tres = asd_init_initiator_ddb(dev);\n\t}\n\tspin_unlock_irqrestore(&asd_ha->hw_prof.ddb_lock, flags);\n\n\treturn res;\n}\n\nvoid asd_dev_gone(struct domain_device *dev)\n{\n\tint ddb, sister_ddb;\n\tunsigned long flags;\n\tstruct asd_ha_struct *asd_ha = dev->port->ha->lldd_ha;\n\n\tspin_lock_irqsave(&asd_ha->hw_prof.ddb_lock, flags);\n\tddb = (int) (unsigned long) dev->lldd_dev;\n\tsister_ddb = asd_ddbsite_read_word(asd_ha, ddb, SISTER_DDB);\n\n\tif (sister_ddb != 0xFFFF)\n\t\tasd_free_ddb(asd_ha, sister_ddb);\n\tasd_free_ddb(asd_ha, ddb);\n\tdev->lldd_dev = NULL;\n\tspin_unlock_irqrestore(&asd_ha->hw_prof.ddb_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}