{
  "module_name": "mesh.c",
  "hash_id": "aec4e0632d53c9e736b086ea85ab5705d5d81b2571ca68b582daad4075e673c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/mesh.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/blkdev.h>\n#include <linux/proc_fs.h>\n#include <linux/stat.h>\n#include <linux/interrupt.h>\n#include <linux/reboot.h>\n#include <linux/spinlock.h>\n#include <linux/pci.h>\n#include <linux/pgtable.h>\n#include <asm/dbdma.h>\n#include <asm/io.h>\n#include <asm/prom.h>\n#include <asm/irq.h>\n#include <asm/hydra.h>\n#include <asm/processor.h>\n#include <asm/setup.h>\n#include <asm/pmac_feature.h>\n#include <asm/macio.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n#include \"mesh.h\"\n\n#if 1\n#undef KERN_DEBUG\n#define KERN_DEBUG KERN_WARNING\n#endif\n\nMODULE_AUTHOR(\"Paul Mackerras (paulus@samba.org)\");\nMODULE_DESCRIPTION(\"PowerMac MESH SCSI driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int sync_rate = CONFIG_SCSI_MESH_SYNC_RATE;\nstatic int sync_targets = 0xff;\nstatic int resel_targets = 0xff;\nstatic int debug_targets = 0;\t \nstatic int init_reset_delay = CONFIG_SCSI_MESH_RESET_DELAY_MS;\n\nmodule_param(sync_rate, int, 0);\nMODULE_PARM_DESC(sync_rate, \"Synchronous rate (0..10, 0=async)\");\nmodule_param(sync_targets, int, 0);\nMODULE_PARM_DESC(sync_targets, \"Bitmask of targets allowed to set synchronous\");\nmodule_param(resel_targets, int, 0);\nMODULE_PARM_DESC(resel_targets, \"Bitmask of targets allowed to set disconnect\");\nmodule_param(debug_targets, int, 0644);\nMODULE_PARM_DESC(debug_targets, \"Bitmask of debugged targets\");\nmodule_param(init_reset_delay, int, 0);\nMODULE_PARM_DESC(init_reset_delay, \"Initial bus reset delay (0=no reset)\");\n\nstatic int mesh_sync_period = 100;\nstatic int mesh_sync_offset = 0;\nstatic unsigned char use_active_neg = 0;   \n\n#define ALLOW_SYNC(tgt)\t\t((sync_targets >> (tgt)) & 1)\n#define ALLOW_RESEL(tgt)\t((resel_targets >> (tgt)) & 1)\n#define ALLOW_DEBUG(tgt)\t((debug_targets >> (tgt)) & 1)\n#define DEBUG_TARGET(cmd)\t((cmd) && ALLOW_DEBUG((cmd)->device->id))\n\n#undef MESH_DBG\n#define N_DBG_LOG\t50\n#define N_DBG_SLOG\t20\n#define NUM_DBG_EVENTS\t13\n#undef\tDBG_USE_TB\t\t \n\nstruct dbglog {\n\tchar\t*fmt;\n\tu32\ttb;\n\tu8\tphase;\n\tu8\tbs0;\n\tu8\tbs1;\n\tu8\ttgt;\n\tint\td;\n};\n\nenum mesh_phase {\n\tidle,\n\tarbitrating,\n\tselecting,\n\tcommanding,\n\tdataing,\n\tstatusing,\n\tbusfreeing,\n\tdisconnecting,\n\treselecting,\n\tsleeping\n};\n\nenum msg_phase {\n\tmsg_none,\n\tmsg_out,\n\tmsg_out_xxx,\n\tmsg_out_last,\n\tmsg_in,\n\tmsg_in_bad,\n};\n\nenum sdtr_phase {\n\tdo_sdtr,\n\tsdtr_sent,\n\tsdtr_done\n};\n\nstruct mesh_target {\n\tenum sdtr_phase sdtr_state;\n\tint\tsync_params;\n\tint\tdata_goes_out;\t\t \n\tstruct scsi_cmnd *current_req;\n\tu32\tsaved_ptr;\n#ifdef MESH_DBG\n\tint\tlog_ix;\n\tint\tn_log;\n\tstruct dbglog log[N_DBG_LOG];\n#endif\n};\n\nstruct mesh_state {\n\tvolatile struct\tmesh_regs __iomem *mesh;\n\tint\tmeshintr;\n\tvolatile struct\tdbdma_regs __iomem *dma;\n\tint\tdmaintr;\n\tstruct\tScsi_Host *host;\n\tstruct\tmesh_state *next;\n\tstruct scsi_cmnd *request_q;\n\tstruct scsi_cmnd *request_qtail;\n\tenum mesh_phase phase;\t\t \n\tenum msg_phase msgphase;\n\tint\tconn_tgt;\t\t \n\tstruct scsi_cmnd *current_req;\t\t \n\tint\tdata_ptr;\n\tint\tdma_started;\n\tint\tdma_count;\n\tint\tstat;\n\tint\taborting;\n\tint\texpect_reply;\n\tint\tn_msgin;\n\tu8\tmsgin[16];\n\tint\tn_msgout;\n\tint\tlast_n_msgout;\n\tu8\tmsgout[16];\n\tstruct dbdma_cmd *dma_cmds;\t \n\tdma_addr_t dma_cmd_bus;\n\tvoid\t*dma_cmd_space;\n\tint\tdma_cmd_size;\n\tint\tclk_freq;\n\tstruct mesh_target tgts[8];\n\tstruct macio_dev *mdev;\n\tstruct pci_dev* pdev;\n#ifdef MESH_DBG\n\tint\tlog_ix;\n\tint\tn_log;\n\tstruct dbglog log[N_DBG_SLOG];\n#endif\n};\n\n \nstatic void mesh_done(struct mesh_state *ms, int start_next);\nstatic void mesh_interrupt(struct mesh_state *ms);\nstatic void cmd_complete(struct mesh_state *ms);\nstatic void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd);\nstatic void halt_dma(struct mesh_state *ms);\nstatic void phase_mismatch(struct mesh_state *ms);\n\n\n \n\n#ifdef MESH_DBG\n\nstatic inline u32 readtb(void)\n{\n\tu32 tb;\n\n#ifdef DBG_USE_TB\n\t \n\tasm (\"mftb %0\" : \"=r\" (tb) : );\n#else\n\ttb = 0;\n#endif\n\treturn tb;\n}\n\nstatic void dlog(struct mesh_state *ms, char *fmt, int a)\n{\n\tstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\n\tstruct dbglog *tlp, *slp;\n\n\ttlp = &tp->log[tp->log_ix];\n\tslp = &ms->log[ms->log_ix];\n\ttlp->fmt = fmt;\n\ttlp->tb = readtb();\n\ttlp->phase = (ms->msgphase << 4) + ms->phase;\n\ttlp->bs0 = ms->mesh->bus_status0;\n\ttlp->bs1 = ms->mesh->bus_status1;\n\ttlp->tgt = ms->conn_tgt;\n\ttlp->d = a;\n\t*slp = *tlp;\n\tif (++tp->log_ix >= N_DBG_LOG)\n\t\ttp->log_ix = 0;\n\tif (tp->n_log < N_DBG_LOG)\n\t\t++tp->n_log;\n\tif (++ms->log_ix >= N_DBG_SLOG)\n\t\tms->log_ix = 0;\n\tif (ms->n_log < N_DBG_SLOG)\n\t\t++ms->n_log;\n}\n\nstatic void dumplog(struct mesh_state *ms, int t)\n{\n\tstruct mesh_target *tp = &ms->tgts[t];\n\tstruct dbglog *lp;\n\tint i;\n\n\tif (tp->n_log == 0)\n\t\treturn;\n\ti = tp->log_ix - tp->n_log;\n\tif (i < 0)\n\t\ti += N_DBG_LOG;\n\ttp->n_log = 0;\n\tdo {\n\t\tlp = &tp->log[i];\n\t\tprintk(KERN_DEBUG \"mesh log %d: bs=%.2x%.2x ph=%.2x \",\n\t\t       t, lp->bs1, lp->bs0, lp->phase);\n#ifdef DBG_USE_TB\n\t\tprintk(\"tb=%10u \", lp->tb);\n#endif\n\t\tprintk(lp->fmt, lp->d);\n\t\tprintk(\"\\n\");\n\t\tif (++i >= N_DBG_LOG)\n\t\t\ti = 0;\n\t} while (i != tp->log_ix);\n}\n\nstatic void dumpslog(struct mesh_state *ms)\n{\n\tstruct dbglog *lp;\n\tint i;\n\n\tif (ms->n_log == 0)\n\t\treturn;\n\ti = ms->log_ix - ms->n_log;\n\tif (i < 0)\n\t\ti += N_DBG_SLOG;\n\tms->n_log = 0;\n\tdo {\n\t\tlp = &ms->log[i];\n\t\tprintk(KERN_DEBUG \"mesh log: bs=%.2x%.2x ph=%.2x t%d \",\n\t\t       lp->bs1, lp->bs0, lp->phase, lp->tgt);\n#ifdef DBG_USE_TB\n\t\tprintk(\"tb=%10u \", lp->tb);\n#endif\n\t\tprintk(lp->fmt, lp->d);\n\t\tprintk(\"\\n\");\n\t\tif (++i >= N_DBG_SLOG)\n\t\t\ti = 0;\n\t} while (i != ms->log_ix);\n}\n\n#else\n\nstatic inline void dlog(struct mesh_state *ms, char *fmt, int a)\n{}\nstatic inline void dumplog(struct mesh_state *ms, int tgt)\n{}\nstatic inline void dumpslog(struct mesh_state *ms)\n{}\n\n#endif  \n\n#define MKWORD(a, b, c, d)\t(((a) << 24) + ((b) << 16) + ((c) << 8) + (d))\n\nstatic void\nmesh_dump_regs(struct mesh_state *ms)\n{\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tvolatile struct dbdma_regs __iomem *md = ms->dma;\n\tint t;\n\tstruct mesh_target *tp;\n\n\tprintk(KERN_DEBUG \"mesh: state at %p, regs at %p, dma at %p\\n\",\n\t       ms, mr, md);\n\tprintk(KERN_DEBUG \"    ct=%4x seq=%2x bs=%4x fc=%2x \"\n\t       \"exc=%2x err=%2x im=%2x int=%2x sp=%2x\\n\",\n\t       (mr->count_hi << 8) + mr->count_lo, mr->sequence,\n\t       (mr->bus_status1 << 8) + mr->bus_status0, mr->fifo_count,\n\t       mr->exception, mr->error, mr->intr_mask, mr->interrupt,\n\t       mr->sync_params);\n\twhile(in_8(&mr->fifo_count))\n\t\tprintk(KERN_DEBUG \" fifo data=%.2x\\n\",in_8(&mr->fifo));\n\tprintk(KERN_DEBUG \"    dma stat=%x cmdptr=%x\\n\",\n\t       in_le32(&md->status), in_le32(&md->cmdptr));\n\tprintk(KERN_DEBUG \"    phase=%d msgphase=%d conn_tgt=%d data_ptr=%d\\n\",\n\t       ms->phase, ms->msgphase, ms->conn_tgt, ms->data_ptr);\n\tprintk(KERN_DEBUG \"    dma_st=%d dma_ct=%d n_msgout=%d\\n\",\n\t       ms->dma_started, ms->dma_count, ms->n_msgout);\n\tfor (t = 0; t < 8; ++t) {\n\t\ttp = &ms->tgts[t];\n\t\tif (tp->current_req == NULL)\n\t\t\tcontinue;\n\t\tprintk(KERN_DEBUG \"    target %d: req=%p goes_out=%d saved_ptr=%d\\n\",\n\t\t       t, tp->current_req, tp->data_goes_out, tp->saved_ptr);\n\t}\n}\n\n\n \nstatic inline void mesh_flush_io(volatile struct mesh_regs __iomem *mr)\n{\n\t(void)in_8(&mr->mesh_id);\n}\n\n\n \nstatic void mesh_init(struct mesh_state *ms)\n{\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tvolatile struct dbdma_regs __iomem *md = ms->dma;\n\n\tmesh_flush_io(mr);\n\tudelay(100);\n\n\t \n\tout_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);\t \n\tout_8(&mr->exception, 0xff);\t \n\tout_8(&mr->error, 0xff);\t \n\tout_8(&mr->sequence, SEQ_RESETMESH);\n\tmesh_flush_io(mr);\n\tudelay(10);\n\tout_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\tout_8(&mr->source_id, ms->host->this_id);\n\tout_8(&mr->sel_timeout, 25);\t \n\tout_8(&mr->sync_params, ASYNC_PARAMS);\n\n\tif (init_reset_delay) {\n\t\tprintk(KERN_INFO \"mesh: performing initial bus reset...\\n\");\n\t\t\n\t\t \n\t\tout_8(&mr->bus_status1, BS1_RST);\t \n\t\tmesh_flush_io(mr);\n\t\tudelay(30);\t\t\t \n\t\tout_8(&mr->bus_status1, 0);\t \n\t\tmesh_flush_io(mr);\n\n\t\t \n\t\tmsleep(init_reset_delay);\n\t}\n\t\n\t \n\tout_8(&mr->interrupt, 0xff);\t \n\tout_8(&mr->sequence, SEQ_FLUSHFIFO);\n\tmesh_flush_io(mr);\n\tudelay(1);\n\tout_8(&mr->sync_params, ASYNC_PARAMS);\n\tout_8(&mr->sequence, SEQ_ENBRESEL);\n\n\tms->phase = idle;\n\tms->msgphase = msg_none;\n}\n\n\nstatic void mesh_start_cmd(struct mesh_state *ms, struct scsi_cmnd *cmd)\n{\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tint t, id;\n\n\tid = cmd->device->id;\n\tms->current_req = cmd;\n\tms->tgts[id].data_goes_out = cmd->sc_data_direction == DMA_TO_DEVICE;\n\tms->tgts[id].current_req = cmd;\n\n#if 1\n\tif (DEBUG_TARGET(cmd)) {\n\t\tint i;\n\t\tprintk(KERN_DEBUG \"mesh_start: %p tgt=%d cmd=\", cmd, id);\n\t\tfor (i = 0; i < cmd->cmd_len; ++i)\n\t\t\tprintk(\" %x\", cmd->cmnd[i]);\n\t\tprintk(\" use_sg=%d buffer=%p bufflen=%u\\n\",\n\t\t       scsi_sg_count(cmd), scsi_sglist(cmd), scsi_bufflen(cmd));\n\t}\n#endif\n\tif (ms->dma_started)\n\t\tpanic(\"mesh: double DMA start !\\n\");\n\n\tms->phase = arbitrating;\n\tms->msgphase = msg_none;\n\tms->data_ptr = 0;\n\tms->dma_started = 0;\n\tms->n_msgout = 0;\n\tms->last_n_msgout = 0;\n\tms->expect_reply = 0;\n\tms->conn_tgt = id;\n\tms->tgts[id].saved_ptr = 0;\n\tms->stat = DID_OK;\n\tms->aborting = 0;\n#ifdef MESH_DBG\n\tms->tgts[id].n_log = 0;\n\tdlog(ms, \"start cmd=%x\", (int) cmd);\n#endif\n\n\t \n\tdlog(ms, \"about to arb, intr/exc/err/fc=%.8x\",\n\t     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));\n\tout_8(&mr->interrupt, INT_CMDDONE);\n\tout_8(&mr->sequence, SEQ_ENBRESEL);\n\tmesh_flush_io(mr);\n\tudelay(1);\n\n\tif (in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) {\n\t\t \n\t\tdlog(ms, \"busy b4 arb, intr/exc/err/fc=%.8x\",\n\t\t     MKWORD(mr->interrupt, mr->exception,\n\t\t\t    mr->error, mr->fifo_count));\n\t\tfor (t = 100; t > 0; --t) {\n\t\t\tif ((in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) == 0)\n\t\t\t\tbreak;\n\t\t\tif (in_8(&mr->interrupt) != 0) {\n\t\t\t\tdlog(ms, \"intr b4 arb, intr/exc/err/fc=%.8x\",\n\t\t\t\t     MKWORD(mr->interrupt, mr->exception,\n\t\t\t\t\t    mr->error, mr->fifo_count));\n\t\t\t\tmesh_interrupt(ms);\n\t\t\t\tif (ms->phase != arbitrating)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\t\tif (in_8(&mr->bus_status1) & (BS1_BSY | BS1_SEL)) {\n\t\t\t \n\t\t\tms->stat = DID_BUS_BUSY;\n\t\t\tms->phase = idle;\n\t\t\tmesh_done(ms, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tout_8(&mr->dest_id, mr->source_id);\n\n\t \n\tout_8(&mr->sequence, SEQ_DISRESEL);\n\tif (in_8(&mr->interrupt) != 0) {\n\t\tdlog(ms, \"intr after disresel, intr/exc/err/fc=%.8x\",\n\t\t     MKWORD(mr->interrupt, mr->exception,\n\t\t\t    mr->error, mr->fifo_count));\n\t\tmesh_interrupt(ms);\n\t\tif (ms->phase != arbitrating)\n\t\t\treturn;\n\t\tdlog(ms, \"after intr after disresel, intr/exc/err/fc=%.8x\",\n\t\t     MKWORD(mr->interrupt, mr->exception,\n\t\t\t    mr->error, mr->fifo_count));\n\t}\n\n\tout_8(&mr->sequence, SEQ_ARBITRATE);\n\n\tfor (t = 230; t > 0; --t) {\n\t\tif (in_8(&mr->interrupt) != 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tdlog(ms, \"after arb, intr/exc/err/fc=%.8x\",\n\t     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));\n\tif (in_8(&mr->interrupt) == 0 && (in_8(&mr->bus_status1) & BS1_SEL)\n\t    && (in_8(&mr->bus_status0) & BS0_IO)) {\n\t\t \n\t\tdlog(ms, \"resel? after arb, intr/exc/err/fc=%.8x\",\n\t\t     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));\n\t\tout_8(&mr->sequence, SEQ_RESETMESH);\n\t\tmesh_flush_io(mr);\n\t\tudelay(10);\n\t\tout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\t\tout_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\t\tout_8(&mr->sequence, SEQ_ENBRESEL);\n\t\tmesh_flush_io(mr);\n\t\tfor (t = 10; t > 0 && in_8(&mr->interrupt) == 0; --t)\n\t\t\tudelay(1);\n\t\tdlog(ms, \"tried reset after arb, intr/exc/err/fc=%.8x\",\n\t\t     MKWORD(mr->interrupt, mr->exception, mr->error, mr->fifo_count));\n#ifndef MESH_MULTIPLE_HOSTS\n\t\tif (in_8(&mr->interrupt) == 0 && (in_8(&mr->bus_status1) & BS1_SEL)\n\t\t    && (in_8(&mr->bus_status0) & BS0_IO)) {\n\t\t\tprintk(KERN_ERR \"mesh: controller not responding\"\n\t\t\t       \" to reselection!\\n\");\n\t\t\t \n\t\t}\n#endif\n\t}\n}\n\n \nstatic void mesh_start(struct mesh_state *ms)\n{\n\tstruct scsi_cmnd *cmd, *prev, *next;\n\n\tif (ms->phase != idle || ms->current_req != NULL) {\n\t\tprintk(KERN_ERR \"inappropriate mesh_start (phase=%d, ms=%p)\",\n\t\t       ms->phase, ms);\n\t\treturn;\n\t}\n\n\twhile (ms->phase == idle) {\n\t\tprev = NULL;\n\t\tfor (cmd = ms->request_q; ; cmd = (struct scsi_cmnd *) cmd->host_scribble) {\n\t\t\tif (cmd == NULL)\n\t\t\t\treturn;\n\t\t\tif (ms->tgts[cmd->device->id].current_req == NULL)\n\t\t\t\tbreak;\n\t\t\tprev = cmd;\n\t\t}\n\t\tnext = (struct scsi_cmnd *) cmd->host_scribble;\n\t\tif (prev == NULL)\n\t\t\tms->request_q = next;\n\t\telse\n\t\t\tprev->host_scribble = (void *) next;\n\t\tif (next == NULL)\n\t\t\tms->request_qtail = prev;\n\n\t\tmesh_start_cmd(ms, cmd);\n\t}\n}\n\nstatic void mesh_done(struct mesh_state *ms, int start_next)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\n\n\tcmd = ms->current_req;\n\tms->current_req = NULL;\n\ttp->current_req = NULL;\n\tif (cmd) {\n\t\tstruct mesh_cmd_priv *mcmd = mesh_priv(cmd);\n\n\t\tset_host_byte(cmd, ms->stat);\n\t\tset_status_byte(cmd, mcmd->status);\n\t\tif (ms->stat == DID_OK)\n\t\t\tscsi_msg_to_host_byte(cmd, mcmd->message);\n\t\tif (DEBUG_TARGET(cmd)) {\n\t\t\tprintk(KERN_DEBUG \"mesh_done: result = %x, data_ptr=%d, buflen=%d\\n\",\n\t\t\t       cmd->result, ms->data_ptr, scsi_bufflen(cmd));\n#if 0\n\t\t\t \n\t\t\tif ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12 || cmd->cmnd[0] == 3)\n\t\t\t    && cmd->request_buffer != 0) {\n\t\t\t\tunsigned char *b = cmd->request_buffer;\n\t\t\t\tprintk(KERN_DEBUG \"buffer = %x %x %x %x %x %x %x %x\\n\",\n\t\t\t\t       b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n\t\t\t}\n#endif\n\t\t}\n\t\tmcmd->this_residual -= ms->data_ptr;\n\t\tscsi_done(cmd);\n\t}\n\tif (start_next) {\n\t\tout_8(&ms->mesh->sequence, SEQ_ENBRESEL);\n\t\tmesh_flush_io(ms->mesh);\n\t\tudelay(1);\n\t\tms->phase = idle;\n\t\tmesh_start(ms);\n\t}\n}\n\nstatic inline void add_sdtr_msg(struct mesh_state *ms)\n{\n\tint i = ms->n_msgout;\n\n\tms->msgout[i] = EXTENDED_MESSAGE;\n\tms->msgout[i+1] = 3;\n\tms->msgout[i+2] = EXTENDED_SDTR;\n\tms->msgout[i+3] = mesh_sync_period/4;\n\tms->msgout[i+4] = (ALLOW_SYNC(ms->conn_tgt)? mesh_sync_offset: 0);\n\tms->n_msgout = i + 5;\n}\n\nstatic void set_sdtr(struct mesh_state *ms, int period, int offset)\n{\n\tstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tint v, tr;\n\n\ttp->sdtr_state = sdtr_done;\n\tif (offset == 0) {\n\t\t \n\t\tif (SYNC_OFF(tp->sync_params))\n\t\t\tprintk(KERN_INFO \"mesh: target %d now asynchronous\\n\",\n\t\t\t       ms->conn_tgt);\n\t\ttp->sync_params = ASYNC_PARAMS;\n\t\tout_8(&mr->sync_params, ASYNC_PARAMS);\n\t\treturn;\n\t}\n\t \n\tv = (ms->clk_freq / 5000) * period;\n\tif (v <= 250000) {\n\t\t \n\t\tv = 0;\n\t\t \n\t\ttr = (ms->clk_freq + 250000) / 500000;\n\t} else {\n\t\t \n\t\tv = (v + 99999) / 100000 - 2;\n\t\tif (v > 15)\n\t\t\tv = 15;\t \n\t\ttr = ((ms->clk_freq / (v + 2)) + 199999) / 200000;\n\t}\n\tif (offset > 15)\n\t\toffset = 15;\t \n\ttp->sync_params = SYNC_PARAMS(offset, v);\n\tout_8(&mr->sync_params, tp->sync_params);\n\tprintk(KERN_INFO \"mesh: target %d synchronous at %d.%d MB/s\\n\",\n\t       ms->conn_tgt, tr/10, tr%10);\n}\n\nstatic void start_phase(struct mesh_state *ms)\n{\n\tint i, seq, nb;\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tvolatile struct dbdma_regs __iomem *md = ms->dma;\n\tstruct scsi_cmnd *cmd = ms->current_req;\n\tstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\n\n\tdlog(ms, \"start_phase nmo/exc/fc/seq = %.8x\",\n\t     MKWORD(ms->n_msgout, mr->exception, mr->fifo_count, mr->sequence));\n\tout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\tseq = use_active_neg + (ms->n_msgout? SEQ_ATN: 0);\n\tswitch (ms->msgphase) {\n\tcase msg_none:\n\t\tbreak;\n\n\tcase msg_in:\n\t\tout_8(&mr->count_hi, 0);\n\t\tout_8(&mr->count_lo, 1);\n\t\tout_8(&mr->sequence, SEQ_MSGIN + seq);\n\t\tms->n_msgin = 0;\n\t\treturn;\n\n\tcase msg_out:\n\t\t \n\t\tif (ms->n_msgout <= 0) {\n\t\t\tprintk(KERN_ERR \"mesh: msg_out but n_msgout=%d\\n\",\n\t\t\t       ms->n_msgout);\n\t\t\tmesh_dump_regs(ms);\n\t\t\tms->msgphase = msg_none;\n\t\t\tbreak;\n\t\t}\n\t\tif (ALLOW_DEBUG(ms->conn_tgt)) {\n\t\t\tprintk(KERN_DEBUG \"mesh: sending %d msg bytes:\",\n\t\t\t       ms->n_msgout);\n\t\t\tfor (i = 0; i < ms->n_msgout; ++i)\n\t\t\t\tprintk(\" %x\", ms->msgout[i]);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tdlog(ms, \"msgout msg=%.8x\", MKWORD(ms->n_msgout, ms->msgout[0],\n\t\t\t\t\t\tms->msgout[1], ms->msgout[2]));\n\t\tout_8(&mr->count_hi, 0);\n\t\tout_8(&mr->sequence, SEQ_FLUSHFIFO);\n\t\tmesh_flush_io(mr);\n\t\tudelay(1);\n\t\t \n\t\tif ((in_8(&mr->bus_status0) & BS0_ATN) == 0) {\n\t\t\tdlog(ms, \"bus0 was %.2x explicitly asserting ATN\", mr->bus_status0);\n\t\t\tout_8(&mr->bus_status0, BS0_ATN);  \n\t\t\tmesh_flush_io(mr);\n\t\t\tudelay(1);\n\t\t\tout_8(&mr->count_lo, 1);\n\t\t\tout_8(&mr->sequence, SEQ_MSGOUT + seq);\n\t\t\tout_8(&mr->bus_status0, 0);  \n\t\t\tdlog(ms,\"hace: after explicit ATN bus0=%.2x\",mr->bus_status0);\n\t\t}\n\t\tif (ms->n_msgout == 1) {\n\t\t\t \n\t\t\tcmd_complete(ms);\n\t\t} else {\n\t\t\tout_8(&mr->count_lo, ms->n_msgout - 1);\n\t\t\tout_8(&mr->sequence, SEQ_MSGOUT + seq);\n\t\t\tfor (i = 0; i < ms->n_msgout - 1; ++i)\n\t\t\t\tout_8(&mr->fifo, ms->msgout[i]);\n\t\t}\n\t\treturn;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"mesh bug: start_phase msgphase=%d\\n\",\n\t\t       ms->msgphase);\n\t}\n\n\tswitch (ms->phase) {\n\tcase selecting:\n\t\tout_8(&mr->dest_id, ms->conn_tgt);\n\t\tout_8(&mr->sequence, SEQ_SELECT + SEQ_ATN);\n\t\tbreak;\n\tcase commanding:\n\t\tout_8(&mr->sync_params, tp->sync_params);\n\t\tout_8(&mr->count_hi, 0);\n\t\tif (cmd) {\n\t\t\tout_8(&mr->count_lo, cmd->cmd_len);\n\t\t\tout_8(&mr->sequence, SEQ_COMMAND + seq);\n\t\t\tfor (i = 0; i < cmd->cmd_len; ++i)\n\t\t\t\tout_8(&mr->fifo, cmd->cmnd[i]);\n\t\t} else {\n\t\t\tout_8(&mr->count_lo, 6);\n\t\t\tout_8(&mr->sequence, SEQ_COMMAND + seq);\n\t\t\tfor (i = 0; i < 6; ++i)\n\t\t\t\tout_8(&mr->fifo, 0);\n\t\t}\n\t\tbreak;\n\tcase dataing:\n\t\t \n\t\tif (!ms->dma_started) {\n\t\t\tset_dma_cmds(ms, cmd);\n\t\t\tout_le32(&md->cmdptr, virt_to_phys(ms->dma_cmds));\n\t\t\tout_le32(&md->control, (RUN << 16) | RUN);\n\t\t\tms->dma_started = 1;\n\t\t}\n\t\tnb = ms->dma_count;\n\t\tif (nb > 0xfff0)\n\t\t\tnb = 0xfff0;\n\t\tms->dma_count -= nb;\n\t\tms->data_ptr += nb;\n\t\tout_8(&mr->count_lo, nb);\n\t\tout_8(&mr->count_hi, nb >> 8);\n\t\tout_8(&mr->sequence, (tp->data_goes_out?\n\t\t\t\tSEQ_DATAOUT: SEQ_DATAIN) + SEQ_DMA_MODE + seq);\n\t\tbreak;\n\tcase statusing:\n\t\tout_8(&mr->count_hi, 0);\n\t\tout_8(&mr->count_lo, 1);\n\t\tout_8(&mr->sequence, SEQ_STATUS + seq);\n\t\tbreak;\n\tcase busfreeing:\n\tcase disconnecting:\n\t\tout_8(&mr->sequence, SEQ_ENBRESEL);\n\t\tmesh_flush_io(mr);\n\t\tudelay(1);\n\t\tdlog(ms, \"enbresel intr/exc/err/fc=%.8x\",\n\t\t     MKWORD(mr->interrupt, mr->exception, mr->error,\n\t\t\t    mr->fifo_count));\n\t\tout_8(&mr->sequence, SEQ_BUSFREE);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"mesh: start_phase called with phase=%d\\n\",\n\t\t       ms->phase);\n\t\tdumpslog(ms);\n\t}\n\n}\n\nstatic inline void get_msgin(struct mesh_state *ms)\n{\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tint i, n;\n\n\tn = mr->fifo_count;\n\tif (n != 0) {\n\t\ti = ms->n_msgin;\n\t\tms->n_msgin = i + n;\n\t\tfor (; n > 0; --n)\n\t\t\tms->msgin[i++] = in_8(&mr->fifo);\n\t}\n}\n\nstatic inline int msgin_length(struct mesh_state *ms)\n{\n\tint b, n;\n\n\tn = 1;\n\tif (ms->n_msgin > 0) {\n\t\tb = ms->msgin[0];\n\t\tif (b == 1) {\n\t\t\t \n\t\t\tn = ms->n_msgin < 2? 2: ms->msgin[1] + 2;\n\t\t} else if (0x20 <= b && b <= 0x2f) {\n\t\t\t \n\t\t\tn = 2;\n\t\t}\n\t}\n\treturn n;\n}\n\nstatic void reselected(struct mesh_state *ms)\n{\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tstruct scsi_cmnd *cmd;\n\tstruct mesh_target *tp;\n\tint b, t, prev;\n\n\tswitch (ms->phase) {\n\tcase idle:\n\t\tbreak;\n\tcase arbitrating:\n\t\tif ((cmd = ms->current_req) != NULL) {\n\t\t\t \n\t\t\tcmd->host_scribble = (void *) ms->request_q;\n\t\t\tif (ms->request_q == NULL)\n\t\t\t\tms->request_qtail = cmd;\n\t\t\tms->request_q = cmd;\n\t\t\ttp = &ms->tgts[cmd->device->id];\n\t\t\ttp->current_req = NULL;\n\t\t}\n\t\tbreak;\n\tcase busfreeing:\n\t\tms->phase = reselecting;\n\t\tmesh_done(ms, 0);\n\t\tbreak;\n\tcase disconnecting:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"mesh: reselected in phase %d/%d tgt %d\\n\",\n\t\t       ms->msgphase, ms->phase, ms->conn_tgt);\n\t\tdumplog(ms, ms->conn_tgt);\n\t\tdumpslog(ms);\n\t}\n\n\tif (ms->dma_started) {\n\t\tprintk(KERN_ERR \"mesh: reselected with DMA started !\\n\");\n\t\thalt_dma(ms);\n\t}\n\tms->current_req = NULL;\n\tms->phase = dataing;\n\tms->msgphase = msg_in;\n\tms->n_msgout = 0;\n\tms->last_n_msgout = 0;\n\tprev = ms->conn_tgt;\n\n\t \n\twhile ((in_8(&mr->bus_status1) & BS1_BSY) == 0) {\n\t\tstatic int mesh_aborted_resels;\n\t\tmesh_aborted_resels++;\n\t\tout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\t\tmesh_flush_io(mr);\n\t\tudelay(1);\n\t\tout_8(&mr->sequence, SEQ_ENBRESEL);\n\t\tmesh_flush_io(mr);\n\t\tudelay(5);\n\t\tdlog(ms, \"extra resel err/exc/fc = %.6x\",\n\t\t     MKWORD(0, mr->error, mr->exception, mr->fifo_count));\n\t}\n\tout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n       \tmesh_flush_io(mr);\n\tudelay(1);\n\tout_8(&mr->sequence, SEQ_ENBRESEL);\n       \tmesh_flush_io(mr);\n\tudelay(1);\n\tout_8(&mr->sync_params, ASYNC_PARAMS);\n\n\t \n\tif (in_8(&mr->fifo_count) == 0) {\n\t\tprintk(KERN_ERR \"mesh: reselection but nothing in fifo?\\n\");\n\t\tms->conn_tgt = ms->host->this_id;\n\t\tgoto bogus;\n\t}\n\t \n\tdo {\n\t\tb = in_8(&mr->fifo);\n\t\tdlog(ms, \"reseldata %x\", b);\n\t} while (in_8(&mr->fifo_count));\n\tfor (t = 0; t < 8; ++t)\n\t\tif ((b & (1 << t)) != 0 && t != ms->host->this_id)\n\t\t\tbreak;\n\tif (b != (1 << t) + (1 << ms->host->this_id)) {\n\t\tprintk(KERN_ERR \"mesh: bad reselection data %x\\n\", b);\n\t\tms->conn_tgt = ms->host->this_id;\n\t\tgoto bogus;\n\t}\n\n\n\t \n\tms->conn_tgt = t;\n\ttp = &ms->tgts[t];\n\tout_8(&mr->sync_params, tp->sync_params);\n\tif (ALLOW_DEBUG(t)) {\n\t\tprintk(KERN_DEBUG \"mesh: reselected by target %d\\n\", t);\n\t\tprintk(KERN_DEBUG \"mesh: saved_ptr=%x goes_out=%d cmd=%p\\n\",\n\t\t       tp->saved_ptr, tp->data_goes_out, tp->current_req);\n\t}\n\tms->current_req = tp->current_req;\n\tif (tp->current_req == NULL) {\n\t\tprintk(KERN_ERR \"mesh: reselected by tgt %d but no cmd!\\n\", t);\n\t\tgoto bogus;\n\t}\n\tms->data_ptr = tp->saved_ptr;\n\tdlog(ms, \"resel prev tgt=%d\", prev);\n\tdlog(ms, \"resel err/exc=%.4x\", MKWORD(0, 0, mr->error, mr->exception));\n\tstart_phase(ms);\n\treturn;\n\nbogus:\n\tdumplog(ms, ms->conn_tgt);\n\tdumpslog(ms);\n\tms->data_ptr = 0;\n\tms->aborting = 1;\n\tstart_phase(ms);\n}\n\nstatic void do_abort(struct mesh_state *ms)\n{\n\tms->msgout[0] = ABORT;\n\tms->n_msgout = 1;\n\tms->aborting = 1;\n\tms->stat = DID_ABORT;\n\tdlog(ms, \"abort\", 0);\n}\n\nstatic void handle_reset(struct mesh_state *ms)\n{\n\tint tgt;\n\tstruct mesh_target *tp;\n\tstruct scsi_cmnd *cmd;\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\n\tfor (tgt = 0; tgt < 8; ++tgt) {\n\t\ttp = &ms->tgts[tgt];\n\t\tif ((cmd = tp->current_req) != NULL) {\n\t\t\tset_host_byte(cmd, DID_RESET);\n\t\t\ttp->current_req = NULL;\n\t\t\tscsi_done(cmd);\n\t\t}\n\t\tms->tgts[tgt].sdtr_state = do_sdtr;\n\t\tms->tgts[tgt].sync_params = ASYNC_PARAMS;\n\t}\n\tms->current_req = NULL;\n\twhile ((cmd = ms->request_q) != NULL) {\n\t\tms->request_q = (struct scsi_cmnd *) cmd->host_scribble;\n\t\tset_host_byte(cmd, DID_RESET);\n\t\tscsi_done(cmd);\n\t}\n\tms->phase = idle;\n\tms->msgphase = msg_none;\n\tout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\tout_8(&mr->sequence, SEQ_FLUSHFIFO);\n       \tmesh_flush_io(mr);\n\tudelay(1);\n\tout_8(&mr->sync_params, ASYNC_PARAMS);\n\tout_8(&mr->sequence, SEQ_ENBRESEL);\n}\n\nstatic irqreturn_t do_mesh_interrupt(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tstruct mesh_state *ms = dev_id;\n\tstruct Scsi_Host *dev = ms->host;\n\t\n\tspin_lock_irqsave(dev->host_lock, flags);\n\tmesh_interrupt(ms);\n\tspin_unlock_irqrestore(dev->host_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic void handle_error(struct mesh_state *ms)\n{\n\tint err, exc, count;\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\n\terr = in_8(&mr->error);\n\texc = in_8(&mr->exception);\n\tout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\tdlog(ms, \"error err/exc/fc/cl=%.8x\",\n\t     MKWORD(err, exc, mr->fifo_count, mr->count_lo));\n\tif (err & ERR_SCSIRESET) {\n\t\t \n\t\tprintk(KERN_INFO \"mesh: SCSI bus reset detected: \"\n\t\t       \"waiting for end...\");\n\t\twhile ((in_8(&mr->bus_status1) & BS1_RST) != 0)\n\t\t\tudelay(1);\n\t\tprintk(\"done\\n\");\n\t\tif (ms->dma_started)\n\t\t\thalt_dma(ms);\n\t\thandle_reset(ms);\n\t\t \n\t\treturn;\n\t}\n\tif (err & ERR_UNEXPDISC) {\n\t\t \n\t\tif (exc & EXC_RESELECTED) {\n\t\t\treselected(ms);\n\t\t\treturn;\n\t\t}\n\t\tif (!ms->aborting) {\n\t\t\tprintk(KERN_WARNING \"mesh: target %d aborted\\n\",\n\t\t\t       ms->conn_tgt);\n\t\t\tdumplog(ms, ms->conn_tgt);\n\t\t\tdumpslog(ms);\n\t\t}\n\t\tout_8(&mr->interrupt, INT_CMDDONE);\n\t\tms->stat = DID_ABORT;\n\t\tmesh_done(ms, 1);\n\t\treturn;\n\t}\n\tif (err & ERR_PARITY) {\n\t\tif (ms->msgphase == msg_in) {\n\t\t\tprintk(KERN_ERR \"mesh: msg parity error, target %d\\n\",\n\t\t\t       ms->conn_tgt);\n\t\t\tms->msgout[0] = MSG_PARITY_ERROR;\n\t\t\tms->n_msgout = 1;\n\t\t\tms->msgphase = msg_in_bad;\n\t\t\tcmd_complete(ms);\n\t\t\treturn;\n\t\t}\n\t\tif (ms->stat == DID_OK) {\n\t\t\tprintk(KERN_ERR \"mesh: parity error, target %d\\n\",\n\t\t\t       ms->conn_tgt);\n\t\t\tms->stat = DID_PARITY;\n\t\t}\n\t\tcount = (mr->count_hi << 8) + mr->count_lo;\n\t\tif (count == 0) {\n\t\t\tcmd_complete(ms);\n\t\t} else {\n\t\t\t \n\t\t\tout_8(&mr->sequence, mr->sequence);\n\t\t}\n\t\treturn;\n\t}\n\tif (err & ERR_SEQERR) {\n\t\tif (exc & EXC_RESELECTED) {\n\t\t\t \n\t\t\tstatic int mesh_resel_seqerr;\n\t\t\tmesh_resel_seqerr++;\n\t\t\treselected(ms);\n\t\t\treturn;\n\t\t}\n\t\tif (exc == EXC_PHASEMM) {\n\t\t\tstatic int mesh_phasemm_seqerr;\n\t\t\tmesh_phasemm_seqerr++;\n\t\t\tphase_mismatch(ms);\n\t\t\treturn;\n\t\t}\n\t\tprintk(KERN_ERR \"mesh: sequence error (err=%x exc=%x)\\n\",\n\t\t       err, exc);\n\t} else {\n\t\tprintk(KERN_ERR \"mesh: unknown error %x (exc=%x)\\n\", err, exc);\n\t}\n\tmesh_dump_regs(ms);\n\tdumplog(ms, ms->conn_tgt);\n\tif (ms->phase > selecting && (in_8(&mr->bus_status1) & BS1_BSY)) {\n\t\t \n\t\tdo_abort(ms);\n\t\tphase_mismatch(ms);\n\t\treturn;\n\t}\n\tms->stat = DID_ERROR;\n\tmesh_done(ms, 1);\n}\n\nstatic void handle_exception(struct mesh_state *ms)\n{\n\tint exc;\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\n\texc = in_8(&mr->exception);\n\tout_8(&mr->interrupt, INT_EXCEPTION | INT_CMDDONE);\n\tif (exc & EXC_RESELECTED) {\n\t\tstatic int mesh_resel_exc;\n\t\tmesh_resel_exc++;\n\t\treselected(ms);\n\t} else if (exc == EXC_ARBLOST) {\n\t\tprintk(KERN_DEBUG \"mesh: lost arbitration\\n\");\n\t\tms->stat = DID_BUS_BUSY;\n\t\tmesh_done(ms, 1);\n\t} else if (exc == EXC_SELTO) {\n\t\t \n\t\tms->stat = DID_BAD_TARGET;\n\t\tmesh_done(ms, 1);\n\t} else if (exc == EXC_PHASEMM) {\n\t\t \n\t\tphase_mismatch(ms);\n\t} else {\n\t\tprintk(KERN_ERR \"mesh: can't cope with exception %x\\n\", exc);\n\t\tmesh_dump_regs(ms);\n\t\tdumplog(ms, ms->conn_tgt);\n\t\tdo_abort(ms);\n\t\tphase_mismatch(ms);\n\t}\n}\n\nstatic void handle_msgin(struct mesh_state *ms)\n{\n\tint i, code;\n\tstruct scsi_cmnd *cmd = ms->current_req;\n\tstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\n\n\tif (ms->n_msgin == 0)\n\t\treturn;\n\tcode = ms->msgin[0];\n\tif (ALLOW_DEBUG(ms->conn_tgt)) {\n\t\tprintk(KERN_DEBUG \"got %d message bytes:\", ms->n_msgin);\n\t\tfor (i = 0; i < ms->n_msgin; ++i)\n\t\t\tprintk(\" %x\", ms->msgin[i]);\n\t\tprintk(\"\\n\");\n\t}\n\tdlog(ms, \"msgin msg=%.8x\",\n\t     MKWORD(ms->n_msgin, code, ms->msgin[1], ms->msgin[2]));\n\n\tms->expect_reply = 0;\n\tms->n_msgout = 0;\n\tif (ms->n_msgin < msgin_length(ms))\n\t\tgoto reject;\n\tif (cmd)\n\t\tmesh_priv(cmd)->message = code;\n\tswitch (code) {\n\tcase COMMAND_COMPLETE:\n\t\tbreak;\n\tcase EXTENDED_MESSAGE:\n\t\tswitch (ms->msgin[2]) {\n\t\tcase EXTENDED_MODIFY_DATA_POINTER:\n\t\t\tms->data_ptr += (ms->msgin[3] << 24) + ms->msgin[6]\n\t\t\t\t+ (ms->msgin[4] << 16) + (ms->msgin[5] << 8);\n\t\t\tbreak;\n\t\tcase EXTENDED_SDTR:\n\t\t\tif (tp->sdtr_state != sdtr_sent) {\n\t\t\t\t \n\t\t\t\tadd_sdtr_msg(ms);\n\t\t\t\t \n\t\t\t\tif (ms->msgout[3] < ms->msgin[3])\n\t\t\t\t\tms->msgout[3] = ms->msgin[3];\n\t\t\t\tif (ms->msgout[4] > ms->msgin[4])\n\t\t\t\t\tms->msgout[4] = ms->msgin[4];\n\t\t\t\tset_sdtr(ms, ms->msgout[3], ms->msgout[4]);\n\t\t\t\tms->msgphase = msg_out;\n\t\t\t} else {\n\t\t\t\tset_sdtr(ms, ms->msgin[3], ms->msgin[4]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto reject;\n\t\t}\n\t\tbreak;\n\tcase SAVE_POINTERS:\n\t\ttp->saved_ptr = ms->data_ptr;\n\t\tbreak;\n\tcase RESTORE_POINTERS:\n\t\tms->data_ptr = tp->saved_ptr;\n\t\tbreak;\n\tcase DISCONNECT:\n\t\tms->phase = disconnecting;\n\t\tbreak;\n\tcase ABORT:\n\t\tbreak;\n\tcase MESSAGE_REJECT:\n\t\tif (tp->sdtr_state == sdtr_sent)\n\t\t\tset_sdtr(ms, 0, 0);\n\t\tbreak;\n\tcase NOP:\n\t\tbreak;\n\tdefault:\n\t\tif (IDENTIFY_BASE <= code && code <= IDENTIFY_BASE + 7) {\n\t\t\tif (cmd == NULL) {\n\t\t\t\tdo_abort(ms);\n\t\t\t\tms->msgphase = msg_out;\n\t\t\t} else if (code != cmd->device->lun + IDENTIFY_BASE) {\n\t\t\t\tprintk(KERN_WARNING \"mesh: lun mismatch \"\n\t\t\t\t       \"(%d != %llu) on reselection from \"\n\t\t\t\t       \"target %d\\n\", code - IDENTIFY_BASE,\n\t\t\t\t       cmd->device->lun, ms->conn_tgt);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgoto reject;\n\t}\n\treturn;\n\n reject:\n\tprintk(KERN_WARNING \"mesh: rejecting message from target %d:\",\n\t       ms->conn_tgt);\n\tfor (i = 0; i < ms->n_msgin; ++i)\n\t\tprintk(\" %x\", ms->msgin[i]);\n\tprintk(\"\\n\");\n\tms->msgout[0] = MESSAGE_REJECT;\n\tms->n_msgout = 1;\n\tms->msgphase = msg_out;\n}\n\n \nstatic void set_dma_cmds(struct mesh_state *ms, struct scsi_cmnd *cmd)\n{\n\tint i, dma_cmd, total, off, dtot;\n\tstruct scatterlist *scl;\n\tstruct dbdma_cmd *dcmds;\n\n\tdma_cmd = ms->tgts[ms->conn_tgt].data_goes_out?\n\t\tOUTPUT_MORE: INPUT_MORE;\n\tdcmds = ms->dma_cmds;\n\tdtot = 0;\n\tif (cmd) {\n\t\tint nseg;\n\n\t\tmesh_priv(cmd)->this_residual = scsi_bufflen(cmd);\n\n\t\tnseg = scsi_dma_map(cmd);\n\t\tBUG_ON(nseg < 0);\n\n\t\tif (nseg) {\n\t\t\ttotal = 0;\n\t\t\toff = ms->data_ptr;\n\n\t\t\tscsi_for_each_sg(cmd, scl, nseg, i) {\n\t\t\t\tu32 dma_addr = sg_dma_address(scl);\n\t\t\t\tu32 dma_len = sg_dma_len(scl);\n\t\t\t\t\n\t\t\t\ttotal += scl->length;\n\t\t\t\tif (off >= dma_len) {\n\t\t\t\t\toff -= dma_len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (dma_len > 0xffff)\n\t\t\t\t\tpanic(\"mesh: scatterlist element >= 64k\");\n\t\t\t\tdcmds->req_count = cpu_to_le16(dma_len - off);\n\t\t\t\tdcmds->command = cpu_to_le16(dma_cmd);\n\t\t\t\tdcmds->phy_addr = cpu_to_le32(dma_addr + off);\n\t\t\t\tdcmds->xfer_status = 0;\n\t\t\t\t++dcmds;\n\t\t\t\tdtot += dma_len - off;\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (dtot == 0) {\n\t\t \n\t\tstatic char mesh_extra_buf[64];\n\n\t\tdtot = sizeof(mesh_extra_buf);\n\t\tdcmds->req_count = cpu_to_le16(dtot);\n\t\tdcmds->phy_addr = cpu_to_le32(virt_to_phys(mesh_extra_buf));\n\t\tdcmds->xfer_status = 0;\n\t\t++dcmds;\n\t}\n\tdma_cmd += OUTPUT_LAST - OUTPUT_MORE;\n\tdcmds[-1].command = cpu_to_le16(dma_cmd);\n\tmemset(dcmds, 0, sizeof(*dcmds));\n\tdcmds->command = cpu_to_le16(DBDMA_STOP);\n\tms->dma_count = dtot;\n}\n\nstatic void halt_dma(struct mesh_state *ms)\n{\n\tvolatile struct dbdma_regs __iomem *md = ms->dma;\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tstruct scsi_cmnd *cmd = ms->current_req;\n\tint t, nb;\n\n\tif (!ms->tgts[ms->conn_tgt].data_goes_out) {\n\t\t \n\t\tt = 50;\n\t\twhile (t > 0 && in_8(&mr->fifo_count) != 0\n\t\t       && (in_le32(&md->status) & ACTIVE) != 0) {\n\t\t\t--t;\n\t\t\tudelay(1);\n\t\t}\n\t}\n\tout_le32(&md->control, RUN << 16);\t \n\tnb = (mr->count_hi << 8) + mr->count_lo;\n\tdlog(ms, \"halt_dma fc/count=%.6x\",\n\t     MKWORD(0, mr->fifo_count, 0, nb));\n\tif (ms->tgts[ms->conn_tgt].data_goes_out)\n\t\tnb += mr->fifo_count;\n\t \n\tms->data_ptr -= nb;\n\tdlog(ms, \"data_ptr %x\", ms->data_ptr);\n\tif (ms->data_ptr < 0) {\n\t\tprintk(KERN_ERR \"mesh: halt_dma: data_ptr=%d (nb=%d, ms=%p)\\n\",\n\t\t       ms->data_ptr, nb, ms);\n\t\tms->data_ptr = 0;\n#ifdef MESH_DBG\n\t\tdumplog(ms, ms->conn_tgt);\n\t\tdumpslog(ms);\n#endif  \n\t} else if (cmd && scsi_bufflen(cmd) &&\n\t\t   ms->data_ptr > scsi_bufflen(cmd)) {\n\t\tprintk(KERN_DEBUG \"mesh: target %d overrun, \"\n\t\t       \"data_ptr=%x total=%x goes_out=%d\\n\",\n\t\t       ms->conn_tgt, ms->data_ptr, scsi_bufflen(cmd),\n\t\t       ms->tgts[ms->conn_tgt].data_goes_out);\n\t}\n\tif (cmd)\n\t\tscsi_dma_unmap(cmd);\n\tms->dma_started = 0;\n}\n\nstatic void phase_mismatch(struct mesh_state *ms)\n{\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tint phase;\n\n\tdlog(ms, \"phasemm ch/cl/seq/fc=%.8x\",\n\t     MKWORD(mr->count_hi, mr->count_lo, mr->sequence, mr->fifo_count));\n\tphase = in_8(&mr->bus_status0) & BS0_PHASE;\n\tif (ms->msgphase == msg_out_xxx && phase == BP_MSGOUT) {\n\t\t \n\t\tout_8(&mr->count_lo, 1);\n\t\tout_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);\n\t\tmesh_flush_io(mr);\n\t\tudelay(1);\n\t\tout_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);\n\t\tms->msgphase = msg_out_last;\n\t\treturn;\n\t}\n\n\tif (ms->msgphase == msg_in) {\n\t\tget_msgin(ms);\n\t\tif (ms->n_msgin)\n\t\t\thandle_msgin(ms);\n\t}\n\n\tif (ms->dma_started)\n\t\thalt_dma(ms);\n\tif (mr->fifo_count) {\n\t\tout_8(&mr->sequence, SEQ_FLUSHFIFO);\n\t\tmesh_flush_io(mr);\n\t\tudelay(1);\n\t}\n\n\tms->msgphase = msg_none;\n\tswitch (phase) {\n\tcase BP_DATAIN:\n\t\tms->tgts[ms->conn_tgt].data_goes_out = 0;\n\t\tms->phase = dataing;\n\t\tbreak;\n\tcase BP_DATAOUT:\n\t\tms->tgts[ms->conn_tgt].data_goes_out = 1;\n\t\tms->phase = dataing;\n\t\tbreak;\n\tcase BP_COMMAND:\n\t\tms->phase = commanding;\n\t\tbreak;\n\tcase BP_STATUS:\n\t\tms->phase = statusing;\n\t\tbreak;\n\tcase BP_MSGIN:\n\t\tms->msgphase = msg_in;\n\t\tms->n_msgin = 0;\n\t\tbreak;\n\tcase BP_MSGOUT:\n\t\tms->msgphase = msg_out;\n\t\tif (ms->n_msgout == 0) {\n\t\t\tif (ms->aborting) {\n\t\t\t\tdo_abort(ms);\n\t\t\t} else {\n\t\t\t\tif (ms->last_n_msgout == 0) {\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"mesh: no msg to repeat\\n\");\n\t\t\t\t\tms->msgout[0] = NOP;\n\t\t\t\t\tms->last_n_msgout = 1;\n\t\t\t\t}\n\t\t\t\tms->n_msgout = ms->last_n_msgout;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_DEBUG \"mesh: unknown scsi phase %x\\n\", phase);\n\t\tms->stat = DID_ERROR;\n\t\tmesh_done(ms, 1);\n\t\treturn;\n\t}\n\n\tstart_phase(ms);\n}\n\nstatic void cmd_complete(struct mesh_state *ms)\n{\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tstruct scsi_cmnd *cmd = ms->current_req;\n\tstruct mesh_target *tp = &ms->tgts[ms->conn_tgt];\n\tint seq, n, t;\n\n\tdlog(ms, \"cmd_complete fc=%x\", mr->fifo_count);\n\tseq = use_active_neg + (ms->n_msgout? SEQ_ATN: 0);\n\tswitch (ms->msgphase) {\n\tcase msg_out_xxx:\n\t\t \n\t\tms->n_msgin = 0;\n\t\tms->msgphase = msg_in;\n\t\tfallthrough;\n\n\tcase msg_in:\n\t\t \n\t\tget_msgin(ms);\n\t\tn = msgin_length(ms);\n\t\tif (ms->n_msgin < n) {\n\t\t\tout_8(&mr->count_lo, n - ms->n_msgin);\n\t\t\tout_8(&mr->sequence, SEQ_MSGIN + seq);\n\t\t} else {\n\t\t\tms->msgphase = msg_none;\n\t\t\thandle_msgin(ms);\n\t\t\tstart_phase(ms);\n\t\t}\n\t\tbreak;\n\n\tcase msg_in_bad:\n\t\tout_8(&mr->sequence, SEQ_FLUSHFIFO);\n\t\tmesh_flush_io(mr);\n\t\tudelay(1);\n\t\tout_8(&mr->count_lo, 1);\n\t\tout_8(&mr->sequence, SEQ_MSGIN + SEQ_ATN + use_active_neg);\n\t\tbreak;\n\n\tcase msg_out:\n\t\t \n\t\tout_8(&mr->count_lo, 1);\n\t\tout_8(&mr->sequence, SEQ_MSGOUT + use_active_neg + SEQ_ATN);\n\t\tt = 30;\t\t \n\t\twhile ((in_8(&mr->bus_status0) & BS0_REQ) == 0 && --t >= 0)\n\t\t\tudelay(1);\n\t\tdlog(ms, \"last_mbyte err/exc/fc/cl=%.8x\",\n\t\t     MKWORD(mr->error, mr->exception,\n\t\t\t    mr->fifo_count, mr->count_lo));\n\t\tif (in_8(&mr->interrupt) & (INT_ERROR | INT_EXCEPTION)) {\n\t\t\t \n\t\t\tms->last_n_msgout = ms->n_msgout;\n\t\t\tms->n_msgout = 0;\n\t\t\tif (in_8(&mr->interrupt) & INT_ERROR) {\n\t\t\t\tprintk(KERN_ERR \"mesh: error %x in msg_out\\n\",\n\t\t\t\t       in_8(&mr->error));\n\t\t\t\thandle_error(ms);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (in_8(&mr->exception) != EXC_PHASEMM)\n\t\t\t\tprintk(KERN_ERR \"mesh: exc %x in msg_out\\n\",\n\t\t\t\t       in_8(&mr->exception));\n\t\t\telse\n\t\t\t\tprintk(KERN_DEBUG \"mesh: bs0=%x in msg_out\\n\",\n\t\t\t\t       in_8(&mr->bus_status0));\n\t\t\thandle_exception(ms);\n\t\t\treturn;\n\t\t}\n\t\tif (in_8(&mr->bus_status0) & BS0_REQ) {\n\t\t\tout_8(&mr->sequence, SEQ_MSGOUT + use_active_neg);\n\t\t\tmesh_flush_io(mr);\n\t\t\tudelay(1);\n\t\t\tout_8(&mr->fifo, ms->msgout[ms->n_msgout-1]);\n\t\t\tms->msgphase = msg_out_last;\n\t\t} else {\n\t\t\tout_8(&mr->sequence, SEQ_MSGIN + use_active_neg + SEQ_ATN);\n\t\t\tms->msgphase = msg_out_xxx;\n\t\t}\n\t\tbreak;\n\n\tcase msg_out_last:\n\t\tms->last_n_msgout = ms->n_msgout;\n\t\tms->n_msgout = 0;\n\t\tms->msgphase = ms->expect_reply? msg_in: msg_none;\n\t\tstart_phase(ms);\n\t\tbreak;\n\n\tcase msg_none:\n\t\tswitch (ms->phase) {\n\t\tcase idle:\n\t\t\tprintk(KERN_ERR \"mesh: interrupt in idle phase?\\n\");\n\t\t\tdumpslog(ms);\n\t\t\treturn;\n\t\tcase selecting:\n\t\t\tdlog(ms, \"Selecting phase at command completion\",0);\n\t\t\tms->msgout[0] = IDENTIFY(ALLOW_RESEL(ms->conn_tgt),\n\t\t\t\t\t\t (cmd? cmd->device->lun: 0));\n\t\t\tms->n_msgout = 1;\n\t\t\tms->expect_reply = 0;\n\t\t\tif (ms->aborting) {\n\t\t\t\tms->msgout[0] = ABORT;\n\t\t\t\tms->n_msgout++;\n\t\t\t} else if (tp->sdtr_state == do_sdtr) {\n\t\t\t\t \n\t\t\t\tadd_sdtr_msg(ms);\n\t\t\t\tms->expect_reply = 1;\n\t\t\t\ttp->sdtr_state = sdtr_sent;\n\t\t\t}\n\t\t\tms->msgphase = msg_out;\n\t\t\t \n\t\t\tt = 230;\t\t \n\t\t\twhile ((in_8(&mr->bus_status0) & BS0_REQ) == 0) {\n\t\t\t\tif (--t < 0) {\n\t\t\t\t\tdlog(ms, \"impatient for req\", ms->n_msgout);\n\t\t\t\t\tms->msgphase = msg_none;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase dataing:\n\t\t\tif (ms->dma_count != 0) {\n\t\t\t\tstart_phase(ms);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t \n\t\t\tout_8(&mr->sequence, 0);\n\t\t\tout_8(&mr->interrupt,\n\t\t\t      INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\t\t\thalt_dma(ms);\n\t\t\tbreak;\n\t\tcase statusing:\n\t\t\tif (cmd) {\n\t\t\t\tstruct mesh_cmd_priv *mcmd = mesh_priv(cmd);\n\n\t\t\t\tmcmd->status = mr->fifo;\n\t\t\t\tif (DEBUG_TARGET(cmd))\n\t\t\t\t\tprintk(KERN_DEBUG \"mesh: status is %x\\n\",\n\t\t\t\t\t       mcmd->status);\n\t\t\t}\n\t\t\tms->msgphase = msg_in;\n\t\t\tbreak;\n\t\tcase busfreeing:\n\t\t\tmesh_done(ms, 1);\n\t\t\treturn;\n\t\tcase disconnecting:\n\t\t\tms->current_req = NULL;\n\t\t\tms->phase = idle;\n\t\t\tmesh_start(ms);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t++ms->phase;\n\t\tstart_phase(ms);\n\t\tbreak;\n\t}\n}\n\n\n \nstatic int mesh_queue_lck(struct scsi_cmnd *cmd)\n{\n\tstruct mesh_state *ms;\n\n\tcmd->host_scribble = NULL;\n\n\tms = (struct mesh_state *) cmd->device->host->hostdata;\n\n\tif (ms->request_q == NULL)\n\t\tms->request_q = cmd;\n\telse\n\t\tms->request_qtail->host_scribble = (void *) cmd;\n\tms->request_qtail = cmd;\n\n\tif (ms->phase == idle)\n\t\tmesh_start(ms);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(mesh_queue)\n\n \nstatic void mesh_interrupt(struct mesh_state *ms)\n{\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tint intr;\n\n#if 0\n\tif (ALLOW_DEBUG(ms->conn_tgt))\n\t\tprintk(KERN_DEBUG \"mesh_intr, bs0=%x int=%x exc=%x err=%x \"\n\t\t       \"phase=%d msgphase=%d\\n\", mr->bus_status0,\n\t\t       mr->interrupt, mr->exception, mr->error,\n\t\t       ms->phase, ms->msgphase);\n#endif\n\twhile ((intr = in_8(&mr->interrupt)) != 0) {\n\t\tdlog(ms, \"interrupt intr/err/exc/seq=%.8x\", \n\t\t     MKWORD(intr, mr->error, mr->exception, mr->sequence));\n\t\tif (intr & INT_ERROR) {\n\t\t\thandle_error(ms);\n\t\t} else if (intr & INT_EXCEPTION) {\n\t\t\thandle_exception(ms);\n\t\t} else if (intr & INT_CMDDONE) {\n\t\t\tout_8(&mr->interrupt, INT_CMDDONE);\n\t\t\tcmd_complete(ms);\n\t\t}\n\t}\n}\n\n \nstatic int mesh_abort(struct scsi_cmnd *cmd)\n{\n\tstruct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;\n\n\tprintk(KERN_DEBUG \"mesh_abort(%p)\\n\", cmd);\n\tmesh_dump_regs(ms);\n\tdumplog(ms, cmd->device->id);\n\tdumpslog(ms);\n\treturn FAILED;\n}\n\n \nstatic int mesh_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct mesh_state *ms = (struct mesh_state *) cmd->device->host->hostdata;\n\tvolatile struct mesh_regs __iomem *mr = ms->mesh;\n\tvolatile struct dbdma_regs __iomem *md = ms->dma;\n\tunsigned long flags;\n\n\tprintk(KERN_DEBUG \"mesh_host_reset\\n\");\n\n\tspin_lock_irqsave(ms->host->host_lock, flags);\n\n\tif (ms->dma_started)\n\t\thalt_dma(ms);\n\n\t \n\tout_le32(&md->control, (RUN|PAUSE|FLUSH|WAKE) << 16);\t \n\tout_8(&mr->exception, 0xff);\t \n\tout_8(&mr->error, 0xff);\t \n\tout_8(&mr->sequence, SEQ_RESETMESH);\n       \tmesh_flush_io(mr);\n\tudelay(1);\n\tout_8(&mr->intr_mask, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\tout_8(&mr->source_id, ms->host->this_id);\n\tout_8(&mr->sel_timeout, 25);\t \n\tout_8(&mr->sync_params, ASYNC_PARAMS);\n\n\t \n\tout_8(&mr->bus_status1, BS1_RST);\t \n       \tmesh_flush_io(mr);\n\tudelay(30);\t\t\t \n\tout_8(&mr->bus_status1, 0);\t \n\n\t \n\thandle_reset(ms);\n\t\n\tspin_unlock_irqrestore(ms->host->host_lock, flags);\n\treturn SUCCESS;\n}\n\nstatic void set_mesh_power(struct mesh_state *ms, int state)\n{\n\tif (!machine_is(powermac))\n\t\treturn;\n\tif (state) {\n\t\tpmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 1);\n\t\tmsleep(200);\n\t} else {\n\t\tpmac_call_feature(PMAC_FTR_MESH_ENABLE, macio_get_of_node(ms->mdev), 0, 0);\n\t\tmsleep(10);\n\t}\n}\n\n\n#ifdef CONFIG_PM\nstatic int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)\n{\n\tstruct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);\n\tunsigned long flags;\n\n\tswitch (mesg.event) {\n\tcase PM_EVENT_SUSPEND:\n\tcase PM_EVENT_HIBERNATE:\n\tcase PM_EVENT_FREEZE:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (ms->phase == sleeping)\n\t\treturn 0;\n\n\tscsi_block_requests(ms->host);\n\tspin_lock_irqsave(ms->host->host_lock, flags);\n\twhile(ms->phase != idle) {\n\t\tspin_unlock_irqrestore(ms->host->host_lock, flags);\n\t\tmsleep(10);\n\t\tspin_lock_irqsave(ms->host->host_lock, flags);\n\t}\n\tms->phase = sleeping;\n\tspin_unlock_irqrestore(ms->host->host_lock, flags);\n\tdisable_irq(ms->meshintr);\n\tset_mesh_power(ms, 0);\n\n\treturn 0;\n}\n\nstatic int mesh_resume(struct macio_dev *mdev)\n{\n\tstruct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);\n\tunsigned long flags;\n\n\tif (ms->phase != sleeping)\n\t\treturn 0;\n\n\tset_mesh_power(ms, 1);\n\tmesh_init(ms);\n\tspin_lock_irqsave(ms->host->host_lock, flags);\n\tmesh_start(ms);\n\tspin_unlock_irqrestore(ms->host->host_lock, flags);\n\tenable_irq(ms->meshintr);\n\tscsi_unblock_requests(ms->host);\n\n\treturn 0;\n}\n\n#endif  \n\n \nstatic int mesh_shutdown(struct macio_dev *mdev)\n{\n\tstruct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);\n\tvolatile struct mesh_regs __iomem *mr;\n\tunsigned long flags;\n\n       \tprintk(KERN_INFO \"resetting MESH scsi bus(es)\\n\");\n\tspin_lock_irqsave(ms->host->host_lock, flags);\n       \tmr = ms->mesh;\n\tout_8(&mr->intr_mask, 0);\n\tout_8(&mr->interrupt, INT_ERROR | INT_EXCEPTION | INT_CMDDONE);\n\tout_8(&mr->bus_status1, BS1_RST);\n\tmesh_flush_io(mr);\n\tudelay(30);\n\tout_8(&mr->bus_status1, 0);\n\tspin_unlock_irqrestore(ms->host->host_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct scsi_host_template mesh_template = {\n\t.proc_name\t\t\t= \"mesh\",\n\t.name\t\t\t\t= \"MESH\",\n\t.queuecommand\t\t\t= mesh_queue,\n\t.eh_abort_handler\t\t= mesh_abort,\n\t.eh_host_reset_handler\t\t= mesh_host_reset,\n\t.can_queue\t\t\t= 20,\n\t.this_id\t\t\t= 7,\n\t.sg_tablesize\t\t\t= SG_ALL,\n\t.cmd_per_lun\t\t\t= 2,\n\t.max_segment_size\t\t= 65535,\n\t.cmd_size\t\t\t= sizeof(struct mesh_cmd_priv),\n};\n\nstatic int mesh_probe(struct macio_dev *mdev, const struct of_device_id *match)\n{\n\tstruct device_node *mesh = macio_get_of_node(mdev);\n\tstruct pci_dev* pdev = macio_get_pci_dev(mdev);\n\tint tgt, minper;\n\tconst int *cfp;\n\tstruct mesh_state *ms;\n\tstruct Scsi_Host *mesh_host;\n\tvoid *dma_cmd_space;\n\tdma_addr_t dma_cmd_bus;\n\n\tswitch (mdev->bus->chip->type) {\n\tcase macio_heathrow:\n\tcase macio_gatwick:\n\tcase macio_paddington:\n\t\tuse_active_neg = 0;\n\t\tbreak;\n\tdefault:\n\t\tuse_active_neg = SEQ_ACTIVE_NEG;\n\t}\n\n\tif (macio_resource_count(mdev) != 2 || macio_irq_count(mdev) != 2) {\n       \t\tprintk(KERN_ERR \"mesh: expected 2 addrs and 2 intrs\"\n\t       \t       \" (got %d,%d)\\n\", macio_resource_count(mdev),\n\t\t       macio_irq_count(mdev));\n\t\treturn -ENODEV;\n\t}\n\n\tif (macio_request_resources(mdev, \"mesh\") != 0) {\n       \t\tprintk(KERN_ERR \"mesh: unable to request memory resources\");\n\t\treturn -EBUSY;\n\t}\n       \tmesh_host = scsi_host_alloc(&mesh_template, sizeof(struct mesh_state));\n\tif (mesh_host == NULL) {\n\t\tprintk(KERN_ERR \"mesh: couldn't register host\");\n\t\tgoto out_release;\n\t}\n\t\n\tmesh_host->base = macio_resource_start(mdev, 0);\n\tmesh_host->irq = macio_irq(mdev, 0);\n       \tms = (struct mesh_state *) mesh_host->hostdata;\n\tmacio_set_drvdata(mdev, ms);\n\tms->host = mesh_host;\n\tms->mdev = mdev;\n\tms->pdev = pdev;\n\t\n\tms->mesh = ioremap(macio_resource_start(mdev, 0), 0x1000);\n\tif (ms->mesh == NULL) {\n\t\tprintk(KERN_ERR \"mesh: can't map registers\\n\");\n\t\tgoto out_free;\n\t}\t\t\n\tms->dma = ioremap(macio_resource_start(mdev, 1), 0x1000);\n\tif (ms->dma == NULL) {\n\t\tprintk(KERN_ERR \"mesh: can't map registers\\n\");\n\t\tiounmap(ms->mesh);\n\t\tgoto out_free;\n\t}\n\n       \tms->meshintr = macio_irq(mdev, 0);\n       \tms->dmaintr = macio_irq(mdev, 1);\n\n       \t \n\tms->dma_cmd_size = (mesh_host->sg_tablesize + 2) * sizeof(struct dbdma_cmd);\n\n\t \n\tdma_cmd_space = dma_alloc_coherent(&macio_get_pci_dev(mdev)->dev,\n\t\t\t\t\t   ms->dma_cmd_size, &dma_cmd_bus,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (dma_cmd_space == NULL) {\n\t\tprintk(KERN_ERR \"mesh: can't allocate DMA table\\n\");\n\t\tgoto out_unmap;\n\t}\n\n\tms->dma_cmds = (struct dbdma_cmd *) DBDMA_ALIGN(dma_cmd_space);\n       \tms->dma_cmd_space = dma_cmd_space;\n\tms->dma_cmd_bus = dma_cmd_bus + ((unsigned long)ms->dma_cmds)\n\t\t- (unsigned long)dma_cmd_space;\n\tms->current_req = NULL;\n       \tfor (tgt = 0; tgt < 8; ++tgt) {\n\t       \tms->tgts[tgt].sdtr_state = do_sdtr;\n\t       \tms->tgts[tgt].sync_params = ASYNC_PARAMS;\n\t       \tms->tgts[tgt].current_req = NULL;\n       \t}\n\n\tif ((cfp = of_get_property(mesh, \"clock-frequency\", NULL)))\n       \t\tms->clk_freq = *cfp;\n\telse {\n       \t\tprintk(KERN_INFO \"mesh: assuming 50MHz clock frequency\\n\");\n\t       \tms->clk_freq = 50000000;\n       \t}\n\n       \t \n\tminper = 1000000000 / (ms->clk_freq / 5);  \n\tif (mesh_sync_period < minper)\n\t\tmesh_sync_period = minper;\n\n\t \n\tset_mesh_power(ms, 1);\n\n\t \n       \tmesh_init(ms);\n\n\t \n       \tif (request_irq(ms->meshintr, do_mesh_interrupt, 0, \"MESH\", ms)) {\n\t       \tprintk(KERN_ERR \"MESH: can't get irq %d\\n\", ms->meshintr);\n\t\tgoto out_shutdown;\n\t}\n\n\t \n\tif (scsi_add_host(mesh_host, &mdev->ofdev.dev))\n\t\tgoto out_release_irq;\n\tscsi_scan_host(mesh_host);\n\n\treturn 0;\n\n out_release_irq:\n\tfree_irq(ms->meshintr, ms);\n out_shutdown:\n\t \n\tmesh_shutdown(mdev);\n\tset_mesh_power(ms, 0);\n\tdma_free_coherent(&macio_get_pci_dev(mdev)->dev, ms->dma_cmd_size,\n\t\t\t    ms->dma_cmd_space, ms->dma_cmd_bus);\n out_unmap:\n\tiounmap(ms->dma);\n\tiounmap(ms->mesh);\n out_free:\n\tscsi_host_put(mesh_host);\n out_release:\n\tmacio_release_resources(mdev);\n\n\treturn -ENODEV;\n}\n\nstatic int mesh_remove(struct macio_dev *mdev)\n{\n\tstruct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);\n\tstruct Scsi_Host *mesh_host = ms->host;\n\n\tscsi_remove_host(mesh_host);\n\n\tfree_irq(ms->meshintr, ms);\n\n\t \n\tmesh_shutdown(mdev);\n\n\t \n\tset_mesh_power(ms, 0);\n\n\t \n\tiounmap(ms->mesh);\n       \tiounmap(ms->dma);\n\n\t \n\tdma_free_coherent(&macio_get_pci_dev(mdev)->dev, ms->dma_cmd_size,\n\t\t\t    ms->dma_cmd_space, ms->dma_cmd_bus);\n\n\t \n\tmacio_release_resources(mdev);\n\n\tscsi_host_put(mesh_host);\n\n\treturn 0;\n}\n\n\nstatic struct of_device_id mesh_match[] = \n{\n\t{\n\t.name \t\t= \"mesh\",\n\t},\n\t{\n\t.type\t\t= \"scsi\",\n\t.compatible\t= \"chrp,mesh0\"\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE (of, mesh_match);\n\nstatic struct macio_driver mesh_driver = \n{\n\t.driver = {\n\t\t.name \t\t= \"mesh\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.of_match_table\t= mesh_match,\n\t},\n\t.probe\t\t= mesh_probe,\n\t.remove\t\t= mesh_remove,\n\t.shutdown\t= mesh_shutdown,\n#ifdef CONFIG_PM\n\t.suspend\t= mesh_suspend,\n\t.resume\t\t= mesh_resume,\n#endif\n};\n\n\nstatic int __init init_mesh(void)\n{\n\n\t \n\tif (sync_rate > 10)\n\t\tsync_rate = 10;\n\tif (sync_rate > 0) {\n\t\tprintk(KERN_INFO \"mesh: configured for synchronous %d MB/s\\n\", sync_rate);\n\t\tmesh_sync_period = 1000 / sync_rate;\t \n\t\tmesh_sync_offset = 15;\n\t} else\n\t\tprintk(KERN_INFO \"mesh: configured for asynchronous\\n\");\n\n\treturn macio_register_driver(&mesh_driver);\n}\n\nstatic void __exit exit_mesh(void)\n{\n\treturn macio_unregister_driver(&mesh_driver);\n}\n\nmodule_init(init_mesh);\nmodule_exit(exit_mesh);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}