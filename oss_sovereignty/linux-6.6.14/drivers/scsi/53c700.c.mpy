{
  "module_name": "53c700.c",
  "hash_id": "13729a488272ce97b177176623ca6b53ba6016ddf4121e6670dabf090ae7f462",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/53c700.c",
  "human_readable_source": "\n\n \n\n \n\n \n#define NCR_700_VERSION \"2.8\"\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/pgtable.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <asm/byteorder.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_spi.h>\n\n#include \"53c700.h\"\n\n \n#define to32bit(x)\t((__u32)((unsigned long)(x)))\n\n#ifdef NCR_700_DEBUG\n#define STATIC\n#else\n#define STATIC static\n#endif\n\nMODULE_AUTHOR(\"James Bottomley\");\nMODULE_DESCRIPTION(\"53c700 and 53c700-66 Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n#include \"53c700_d.h\"\n\n\nSTATIC int NCR_700_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *);\nSTATIC int NCR_700_abort(struct scsi_cmnd * SCpnt);\nSTATIC int NCR_700_host_reset(struct scsi_cmnd * SCpnt);\nSTATIC void NCR_700_chip_setup(struct Scsi_Host *host);\nSTATIC void NCR_700_chip_reset(struct Scsi_Host *host);\nSTATIC int NCR_700_slave_alloc(struct scsi_device *SDpnt);\nSTATIC int NCR_700_slave_configure(struct scsi_device *SDpnt);\nSTATIC void NCR_700_slave_destroy(struct scsi_device *SDpnt);\nstatic int NCR_700_change_queue_depth(struct scsi_device *SDpnt, int depth);\n\nSTATIC const struct attribute_group *NCR_700_dev_groups[];\n\nSTATIC struct scsi_transport_template *NCR_700_transport_template = NULL;\n\nstatic char *NCR_700_phase[] = {\n\t\"\",\n\t\"after selection\",\n\t\"before command phase\",\n\t\"after command phase\",\n\t\"after status phase\",\n\t\"after data in phase\",\n\t\"after data out phase\",\n\t\"during data phase\",\n};\n\nstatic char *NCR_700_condition[] = {\n\t\"\",\n\t\"NOT MSG_OUT\",\n\t\"UNEXPECTED PHASE\",\n\t\"NOT MSG_IN\",\n\t\"UNEXPECTED MSG\",\n\t\"MSG_IN\",\n\t\"SDTR_MSG RECEIVED\",\n\t\"REJECT_MSG RECEIVED\",\n\t\"DISCONNECT_MSG RECEIVED\",\n\t\"MSG_OUT\",\n\t\"DATA_IN\",\n\t\n};\n\nstatic char *NCR_700_fatal_messages[] = {\n\t\"unexpected message after reselection\",\n\t\"still MSG_OUT after message injection\",\n\t\"not MSG_IN after selection\",\n\t\"Illegal message length received\",\n};\n\nstatic char *NCR_700_SBCL_bits[] = {\n\t\"IO \",\n\t\"CD \",\n\t\"MSG \",\n\t\"ATN \",\n\t\"SEL \",\n\t\"BSY \",\n\t\"ACK \",\n\t\"REQ \",\n};\n\nstatic char *NCR_700_SBCL_to_phase[] = {\n\t\"DATA_OUT\",\n\t\"DATA_IN\",\n\t\"CMD_OUT\",\n\t\"STATE\",\n\t\"ILLEGAL PHASE\",\n\t\"ILLEGAL PHASE\",\n\t\"MSG OUT\",\n\t\"MSG IN\",\n};\n\n \nstatic inline __u8\nNCR_700_offset_period_to_sxfer(struct NCR_700_Host_Parameters *hostdata,\n\t\t\t       __u8 offset, __u8 period)\n{\n\tint XFERP;\n\n\t__u8 min_xferp = (hostdata->chip710\n\t\t\t  ? NCR_710_MIN_XFERP : NCR_700_MIN_XFERP);\n\t__u8 max_offset = (hostdata->chip710\n\t\t\t   ? NCR_710_MAX_OFFSET : NCR_700_MAX_OFFSET);\n\n\tif(offset == 0)\n\t\treturn 0;\n\n\tif(period < hostdata->min_period) {\n\t\tprintk(KERN_WARNING \"53c700: Period %dns is less than this chip's minimum, setting to %d\\n\", period*4, NCR_700_MIN_PERIOD*4);\n\t\tperiod = hostdata->min_period;\n\t}\n\tXFERP = (period*4 * hostdata->sync_clock)/1000 - 4;\n\tif(offset > max_offset) {\n\t\tprintk(KERN_WARNING \"53c700: Offset %d exceeds chip maximum, setting to %d\\n\",\n\t\t       offset, max_offset);\n\t\toffset = max_offset;\n\t}\n\tif(XFERP < min_xferp) {\n\t\tXFERP =  min_xferp;\n\t}\n\treturn (offset & 0x0f) | (XFERP & 0x07)<<4;\n}\n\nstatic inline __u8\nNCR_700_get_SXFER(struct scsi_device *SDp)\n{\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)SDp->host->hostdata[0];\n\n\treturn NCR_700_offset_period_to_sxfer(hostdata,\n\t\t\t\t\t      spi_offset(SDp->sdev_target),\n\t\t\t\t\t      spi_period(SDp->sdev_target));\n}\n\nstatic inline dma_addr_t virt_to_dma(struct NCR_700_Host_Parameters *h, void *p)\n{\n\treturn h->pScript + ((uintptr_t)p - (uintptr_t)h->script);\n}\n\nstatic inline void dma_sync_to_dev(struct NCR_700_Host_Parameters *h,\n\t\tvoid *addr, size_t size)\n{\n\tif (h->noncoherent)\n\t\tdma_sync_single_for_device(h->dev, virt_to_dma(h, addr),\n\t\t\t\t\t   size, DMA_BIDIRECTIONAL);\n}\n\nstatic inline void dma_sync_from_dev(struct NCR_700_Host_Parameters *h,\n\t\tvoid *addr, size_t size)\n{\n\tif (h->noncoherent)\n\t\tdma_sync_single_for_device(h->dev, virt_to_dma(h, addr), size,\n\t\t\t\t\t   DMA_BIDIRECTIONAL);\n}\n\nstruct Scsi_Host *\nNCR_700_detect(struct scsi_host_template *tpnt,\n\t       struct NCR_700_Host_Parameters *hostdata, struct device *dev)\n{\n\tdma_addr_t pScript, pSlots;\n\t__u8 *memory;\n\t__u32 *script;\n\tstruct Scsi_Host *host;\n\tstatic int banner = 0;\n\tint j;\n\n\tif (tpnt->sdev_groups == NULL)\n\t\ttpnt->sdev_groups = NCR_700_dev_groups;\n\n\tmemory = dma_alloc_coherent(dev, TOTAL_MEM_SIZE, &pScript, GFP_KERNEL);\n\tif (!memory) {\n\t\thostdata->noncoherent = 1;\n\t\tmemory = dma_alloc_noncoherent(dev, TOTAL_MEM_SIZE, &pScript,\n\t\t\t\t\t DMA_BIDIRECTIONAL, GFP_KERNEL);\n\t}\n\tif (!memory) {\n\t\tprintk(KERN_ERR \"53c700: Failed to allocate memory for driver, detaching\\n\");\n\t\treturn NULL;\n\t}\n\n\tscript = (__u32 *)memory;\n\thostdata->msgin = memory + MSGIN_OFFSET;\n\thostdata->msgout = memory + MSGOUT_OFFSET;\n\thostdata->status = memory + STATUS_OFFSET;\n\thostdata->slots = (struct NCR_700_command_slot *)(memory + SLOTS_OFFSET);\n\thostdata->dev = dev;\n\n\tpSlots = pScript + SLOTS_OFFSET;\n\n\t \n\ttpnt->queuecommand = NCR_700_queuecommand;\n\ttpnt->eh_abort_handler = NCR_700_abort;\n\ttpnt->eh_host_reset_handler = NCR_700_host_reset;\n\ttpnt->can_queue = NCR_700_COMMAND_SLOTS_PER_HOST;\n\ttpnt->sg_tablesize = NCR_700_SG_SEGMENTS;\n\ttpnt->cmd_per_lun = NCR_700_CMD_PER_LUN;\n\ttpnt->slave_configure = NCR_700_slave_configure;\n\ttpnt->slave_destroy = NCR_700_slave_destroy;\n\ttpnt->slave_alloc = NCR_700_slave_alloc;\n\ttpnt->change_queue_depth = NCR_700_change_queue_depth;\n\n\tif(tpnt->name == NULL)\n\t\ttpnt->name = \"53c700\";\n\tif(tpnt->proc_name == NULL)\n\t\ttpnt->proc_name = \"53c700\";\n\n\thost = scsi_host_alloc(tpnt, 4);\n\tif (!host)\n\t\treturn NULL;\n\tmemset(hostdata->slots, 0, sizeof(struct NCR_700_command_slot)\n\t       * NCR_700_COMMAND_SLOTS_PER_HOST);\n\tfor (j = 0; j < NCR_700_COMMAND_SLOTS_PER_HOST; j++) {\n\t\tdma_addr_t offset = (dma_addr_t)((unsigned long)&hostdata->slots[j].SG[0]\n\t\t\t\t\t  - (unsigned long)&hostdata->slots[0].SG[0]);\n\t\thostdata->slots[j].pSG = (struct NCR_700_SG_List *)((unsigned long)(pSlots + offset));\n\t\tif(j == 0)\n\t\t\thostdata->free_list = &hostdata->slots[j];\n\t\telse\n\t\t\thostdata->slots[j-1].ITL_forw = &hostdata->slots[j];\n\t\thostdata->slots[j].state = NCR_700_SLOT_FREE;\n\t}\n\n\tfor (j = 0; j < ARRAY_SIZE(SCRIPT); j++)\n\t\tscript[j] = bS_to_host(SCRIPT[j]);\n\n\t \n\tfor (j = 0; j < PATCHES; j++)\n\t\tscript[LABELPATCHES[j]] = bS_to_host(pScript + SCRIPT[LABELPATCHES[j]]);\n\t \n\tscript_patch_32(hostdata, script, MessageLocation,\n\t\t\tpScript + MSGOUT_OFFSET);\n\tscript_patch_32(hostdata, script, StatusAddress,\n\t\t\tpScript + STATUS_OFFSET);\n\tscript_patch_32(hostdata, script, ReceiveMsgAddress,\n\t\t\tpScript + MSGIN_OFFSET);\n\n\thostdata->script = script;\n\thostdata->pScript = pScript;\n\tdma_sync_single_for_device(hostdata->dev, pScript, sizeof(SCRIPT), DMA_TO_DEVICE);\n\thostdata->state = NCR_700_HOST_FREE;\n\thostdata->cmd = NULL;\n\thost->max_id = 8;\n\thost->max_lun = NCR_700_MAX_LUNS;\n\tBUG_ON(NCR_700_transport_template == NULL);\n\thost->transportt = NCR_700_transport_template;\n\thost->unique_id = (unsigned long)hostdata->base;\n\thostdata->eh_complete = NULL;\n\thost->hostdata[0] = (unsigned long)hostdata;\n\t \n\tNCR_700_writeb(0xff, host, CTEST9_REG);\n\tif (hostdata->chip710)\n\t\thostdata->rev = (NCR_700_readb(host, CTEST8_REG)>>4) & 0x0f;\n\telse\n\t\thostdata->rev = (NCR_700_readb(host, CTEST7_REG)>>4) & 0x0f;\n\thostdata->fast = (NCR_700_readb(host, CTEST9_REG) == 0);\n\tif (banner == 0) {\n\t\tprintk(KERN_NOTICE \"53c700: Version \" NCR_700_VERSION \" By James.Bottomley@HansenPartnership.com\\n\");\n\t\tbanner = 1;\n\t}\n\tprintk(KERN_NOTICE \"scsi%d: %s rev %d %s\\n\", host->host_no,\n\t       hostdata->chip710 ? \"53c710\" :\n\t       (hostdata->fast ? \"53c700-66\" : \"53c700\"),\n\t       hostdata->rev, hostdata->differential ?\n\t       \"(Differential)\" : \"\");\n\t \n\tNCR_700_chip_reset(host);\n\n\tif (scsi_add_host(host, dev)) {\n\t\tdev_printk(KERN_ERR, dev, \"53c700: scsi_add_host failed\\n\");\n\t\tscsi_host_put(host);\n\t\treturn NULL;\n\t}\n\n\tspi_signalling(host) = hostdata->differential ? SPI_SIGNAL_HVD :\n\t\tSPI_SIGNAL_SE;\n\n\treturn host;\n}\n\nint\nNCR_700_release(struct Scsi_Host *host)\n{\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)host->hostdata[0];\n\n\tif (hostdata->noncoherent)\n\t\tdma_free_noncoherent(hostdata->dev, TOTAL_MEM_SIZE,\n\t\t\t\thostdata->script, hostdata->pScript,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\telse\n\t\tdma_free_coherent(hostdata->dev, TOTAL_MEM_SIZE,\n\t\t\t\t  hostdata->script, hostdata->pScript);\n\treturn 1;\n}\n\nstatic inline __u8\nNCR_700_identify(int can_disconnect, __u8 lun)\n{\n\treturn IDENTIFY_BASE |\n\t\t((can_disconnect) ? 0x40 : 0) |\n\t\t(lun & NCR_700_LUN_MASK);\n}\n\n \nstatic inline int\nNCR_700_data_residual (struct Scsi_Host *host) {\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)host->hostdata[0];\n\tint count, synchronous = 0;\n\tunsigned int ddir;\n\n\tif(hostdata->chip710) {\n\t\tcount = ((NCR_700_readb(host, DFIFO_REG) & 0x7f) -\n\t\t\t (NCR_700_readl(host, DBC_REG) & 0x7f)) & 0x7f;\n\t} else {\n\t\tcount = ((NCR_700_readb(host, DFIFO_REG) & 0x3f) -\n\t\t\t (NCR_700_readl(host, DBC_REG) & 0x3f)) & 0x3f;\n\t}\n\t\n\tif(hostdata->fast)\n\t\tsynchronous = NCR_700_readb(host, SXFER_REG) & 0x0f;\n\t\n\t \n\tddir = NCR_700_readb(host, CTEST0_REG) & 0x01;\n\n\tif (ddir) {\n\t\t \n\t\tif (synchronous) \n\t\t\tcount += (NCR_700_readb(host, SSTAT2_REG) & 0xf0) >> 4;\n\t\telse\n\t\t\tif (NCR_700_readb(host, SSTAT1_REG) & SIDL_REG_FULL)\n\t\t\t\t++count;\n\t} else {\n\t\t \n\t\t__u8 sstat = NCR_700_readb(host, SSTAT1_REG);\n\t\tif (sstat & SODL_REG_FULL)\n\t\t\t++count;\n\t\tif (synchronous && (sstat & SODR_REG_FULL))\n\t\t\t++count;\n\t}\n#ifdef NCR_700_DEBUG\n\tif(count)\n\t\tprintk(\"RESIDUAL IS %d (ddir %d)\\n\", count, ddir);\n#endif\n\treturn count;\n}\n\n \nstatic inline char *\nsbcl_to_string(__u8 sbcl)\n{\n\tint i;\n\tstatic char ret[256];\n\n\tret[0]='\\0';\n\tfor(i=0; i<8; i++) {\n\t\tif((1<<i) & sbcl) \n\t\t\tstrcat(ret, NCR_700_SBCL_bits[i]);\n\t}\n\tstrcat(ret, NCR_700_SBCL_to_phase[sbcl & 0x07]);\n\treturn ret;\n}\n\nstatic inline __u8\nbitmap_to_number(__u8 bitmap)\n{\n\t__u8 i;\n\n\tfor(i=0; i<8 && !(bitmap &(1<<i)); i++)\n\t\t;\n\treturn i;\n}\n\n \nSTATIC struct NCR_700_command_slot *\nfind_empty_slot(struct NCR_700_Host_Parameters *hostdata)\n{\n\tstruct NCR_700_command_slot *slot = hostdata->free_list;\n\n\tif(slot == NULL) {\n\t\t \n\t\tif(hostdata->command_slot_count != NCR_700_COMMAND_SLOTS_PER_HOST)\n\t\t\tprintk(KERN_ERR \"SLOTS FULL, but count is %d, should be %d\\n\", hostdata->command_slot_count, NCR_700_COMMAND_SLOTS_PER_HOST);\n\t\treturn NULL;\n\t}\n\n\tif(slot->state != NCR_700_SLOT_FREE)\n\t\t \n\t\tprintk(KERN_ERR \"BUSY SLOT ON FREE LIST!!!\\n\");\n\t\t\n\n\thostdata->free_list = slot->ITL_forw;\n\tslot->ITL_forw = NULL;\n\n\n\t \n\tslot->state = NCR_700_SLOT_BUSY;\n\tslot->flags = 0;\n\thostdata->command_slot_count++;\n\t\n\treturn slot;\n}\n\nSTATIC void \nfree_slot(struct NCR_700_command_slot *slot,\n\t  struct NCR_700_Host_Parameters *hostdata)\n{\n\tif((slot->state & NCR_700_SLOT_MASK) != NCR_700_SLOT_MAGIC) {\n\t\tprintk(KERN_ERR \"53c700: SLOT %p is not MAGIC!!!\\n\", slot);\n\t}\n\tif(slot->state == NCR_700_SLOT_FREE) {\n\t\tprintk(KERN_ERR \"53c700: SLOT %p is FREE!!!\\n\", slot);\n\t}\n\t\n\tslot->resume_offset = 0;\n\tslot->cmnd = NULL;\n\tslot->state = NCR_700_SLOT_FREE;\n\tslot->ITL_forw = hostdata->free_list;\n\thostdata->free_list = slot;\n\thostdata->command_slot_count--;\n}\n\n\n \nSTATIC void\nsave_for_reselection(struct NCR_700_Host_Parameters *hostdata,\n\t\t     struct scsi_cmnd *SCp, __u32 dsp)\n{\n\t \n\tif(SCp != NULL) {\n\t\tstruct NCR_700_command_slot *slot =\n\t\t\t(struct NCR_700_command_slot *)SCp->host_scribble;\n\n\t\tslot->resume_offset = dsp;\n\t}\n\thostdata->state = NCR_700_HOST_FREE;\n\thostdata->cmd = NULL;\n}\n\nSTATIC inline void\nNCR_700_unmap(struct NCR_700_Host_Parameters *hostdata, struct scsi_cmnd *SCp,\n\t      struct NCR_700_command_slot *slot)\n{\n\tif(SCp->sc_data_direction != DMA_NONE &&\n\t   SCp->sc_data_direction != DMA_BIDIRECTIONAL)\n\t\tscsi_dma_unmap(SCp);\n}\n\nSTATIC inline void\nNCR_700_scsi_done(struct NCR_700_Host_Parameters *hostdata,\n\t       struct scsi_cmnd *SCp, int result)\n{\n\thostdata->state = NCR_700_HOST_FREE;\n\thostdata->cmd = NULL;\n\n\tif(SCp != NULL) {\n\t\tstruct NCR_700_command_slot *slot =\n\t\t\t(struct NCR_700_command_slot *)SCp->host_scribble;\n\n\t\tdma_unmap_single(hostdata->dev, slot->pCmd,\n\t\t\t\t MAX_COMMAND_SIZE, DMA_TO_DEVICE);\n\t\tif (slot->flags == NCR_700_FLAG_AUTOSENSE) {\n\t\t\tchar *cmnd = NCR_700_get_sense_cmnd(SCp->device);\n\n\t\t\tdma_unmap_single(hostdata->dev, slot->dma_handle,\n\t\t\t\t\t SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\t\t\t \n\t\t\tif (result == 0)\n\t\t\t\tresult = cmnd[7];\n\t\t\t \n\t\t\tSCp->cmd_len = cmnd[8];\n\t\t} else\n\t\t\tNCR_700_unmap(hostdata, SCp, slot);\n\n\t\tfree_slot(slot, hostdata);\n#ifdef NCR_700_DEBUG\n\t\tif(NCR_700_get_depth(SCp->device) == 0 ||\n\t\t   NCR_700_get_depth(SCp->device) > SCp->device->queue_depth)\n\t\t\tprintk(KERN_ERR \"Invalid depth in NCR_700_scsi_done(): %d\\n\",\n\t\t\t       NCR_700_get_depth(SCp->device));\n#endif  \n\t\tNCR_700_set_depth(SCp->device, NCR_700_get_depth(SCp->device) - 1);\n\n\t\tSCp->host_scribble = NULL;\n\t\tSCp->result = result;\n\t\tscsi_done(SCp);\n\t} else {\n\t\tprintk(KERN_ERR \"53c700: SCSI DONE HAS NULL SCp\\n\");\n\t}\n}\n\n\nSTATIC void\nNCR_700_internal_bus_reset(struct Scsi_Host *host)\n{\n\t \n\tNCR_700_writeb(ASSERT_RST, host, SCNTL1_REG);\n\tudelay(50);\n\tNCR_700_writeb(0, host, SCNTL1_REG);\n\n}\n\nSTATIC void\nNCR_700_chip_setup(struct Scsi_Host *host)\n{\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)host->hostdata[0];\n\t__u8 min_period;\n\t__u8 min_xferp = (hostdata->chip710 ? NCR_710_MIN_XFERP : NCR_700_MIN_XFERP);\n\n\tif(hostdata->chip710) {\n\t\t__u8 burst_disable = 0;\n\t\t__u8 burst_length = 0;\n\n\t\tswitch (hostdata->burst_length) {\n\t\t\tcase 1:\n\t\t\t        burst_length = BURST_LENGTH_1;\n\t\t\t        break;\n\t\t\tcase 2:\n\t\t\t        burst_length = BURST_LENGTH_2;\n\t\t\t        break;\n\t\t\tcase 4:\n\t\t\t        burst_length = BURST_LENGTH_4;\n\t\t\t        break;\n\t\t\tcase 8:\n\t\t\t        burst_length = BURST_LENGTH_8;\n\t\t\t        break;\n\t\t\tdefault:\n\t\t\t        burst_disable = BURST_DISABLE;\n\t\t\t        break;\n\t\t}\n\t\thostdata->dcntl_extra |= COMPAT_700_MODE;\n\n\t\tNCR_700_writeb(hostdata->dcntl_extra, host, DCNTL_REG);\n\t\tNCR_700_writeb(burst_length | hostdata->dmode_extra,\n\t\t\t       host, DMODE_710_REG);\n\t\tNCR_700_writeb(burst_disable | hostdata->ctest7_extra |\n\t\t\t       (hostdata->differential ? DIFF : 0),\n\t\t\t       host, CTEST7_REG);\n\t\tNCR_700_writeb(BTB_TIMER_DISABLE, host, CTEST0_REG);\n\t\tNCR_700_writeb(FULL_ARBITRATION | ENABLE_PARITY | PARITY\n\t\t\t       | AUTO_ATN, host, SCNTL0_REG);\n\t} else {\n\t\tNCR_700_writeb(BURST_LENGTH_8 | hostdata->dmode_extra,\n\t\t\t       host, DMODE_700_REG);\n\t\tNCR_700_writeb(hostdata->differential ? \n\t\t\t       DIFF : 0, host, CTEST7_REG);\n\t\tif(hostdata->fast) {\n\t\t\t \n\t\t\tNCR_700_writeb(LAST_DIS_ENBL | ENABLE_ACTIVE_NEGATION \n\t\t\t\t       | GENERATE_RECEIVE_PARITY, host,\n\t\t\t\t       CTEST8_REG);\n\t\t} else {\n\t\t\tNCR_700_writeb(FULL_ARBITRATION | ENABLE_PARITY\n\t\t\t\t       | PARITY | AUTO_ATN, host, SCNTL0_REG);\n\t\t}\n\t}\n\n\tNCR_700_writeb(1 << host->this_id, host, SCID_REG);\n\tNCR_700_writeb(0, host, SBCL_REG);\n\tNCR_700_writeb(ASYNC_OPERATION, host, SXFER_REG);\n\n\tNCR_700_writeb(PHASE_MM_INT | SEL_TIMEOUT_INT | GROSS_ERR_INT | UX_DISC_INT\n\t     | RST_INT | PAR_ERR_INT | SELECT_INT, host, SIEN_REG);\n\n\tNCR_700_writeb(ABORT_INT | INT_INST_INT | ILGL_INST_INT, host, DIEN_REG);\n\tNCR_700_writeb(ENABLE_SELECT, host, SCNTL1_REG);\n\tif(hostdata->clock > 75) {\n\t\tprintk(KERN_ERR \"53c700: Clock speed %dMHz is too high: 75Mhz is the maximum this chip can be driven at\\n\", hostdata->clock);\n\t\t \n\t\tDEBUG((\"53c700: sync 2 async 3\\n\"));\n\t\tNCR_700_writeb(SYNC_DIV_2_0, host, SBCL_REG);\n\t\tNCR_700_writeb(ASYNC_DIV_3_0 | hostdata->dcntl_extra, host, DCNTL_REG);\n\t\thostdata->sync_clock = hostdata->clock/2;\n\t} else\tif(hostdata->clock > 50  && hostdata->clock <= 75) {\n\t\t \n\t\tDEBUG((\"53c700: sync 1.5 async 3\\n\"));\n\t\tNCR_700_writeb(SYNC_DIV_1_5, host, SBCL_REG);\n\t\tNCR_700_writeb(ASYNC_DIV_3_0 | hostdata->dcntl_extra, host, DCNTL_REG);\n\t\thostdata->sync_clock = hostdata->clock*2;\n\t\thostdata->sync_clock /= 3;\n\t\t\n\t} else if(hostdata->clock > 37 && hostdata->clock <= 50) {\n\t\t \n\t\tDEBUG((\"53c700: sync 1 async 2\\n\"));\n\t\tNCR_700_writeb(SYNC_DIV_1_0, host, SBCL_REG);\n\t\tNCR_700_writeb(ASYNC_DIV_2_0 | hostdata->dcntl_extra, host, DCNTL_REG);\n\t\thostdata->sync_clock = hostdata->clock;\n\t} else if(hostdata->clock > 25 && hostdata->clock <=37) {\n\t\t \n\t\tDEBUG((\"53c700: sync 1 async 1.5\\n\"));\n\t\tNCR_700_writeb(SYNC_DIV_1_0, host, SBCL_REG);\n\t\tNCR_700_writeb(ASYNC_DIV_1_5 | hostdata->dcntl_extra, host, DCNTL_REG);\n\t\thostdata->sync_clock = hostdata->clock;\n\t} else {\n\t\tDEBUG((\"53c700: sync 1 async 1\\n\"));\n\t\tNCR_700_writeb(SYNC_DIV_1_0, host, SBCL_REG);\n\t\tNCR_700_writeb(ASYNC_DIV_1_0 | hostdata->dcntl_extra, host, DCNTL_REG);\n\t\t \n\t\thostdata->sync_clock = hostdata->clock;\n\t}\n\t \n\tmin_period = 1000*(4+min_xferp)/(4*hostdata->sync_clock);\n\thostdata->min_period = NCR_700_MIN_PERIOD;\n\tif(min_period > NCR_700_MIN_PERIOD)\n\t\thostdata->min_period = min_period;\n}\n\nSTATIC void\nNCR_700_chip_reset(struct Scsi_Host *host)\n{\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)host->hostdata[0];\n\tif(hostdata->chip710) {\n\t\tNCR_700_writeb(SOFTWARE_RESET_710, host, ISTAT_REG);\n\t\tudelay(100);\n\n\t\tNCR_700_writeb(0, host, ISTAT_REG);\n\t} else {\n\t\tNCR_700_writeb(SOFTWARE_RESET, host, DCNTL_REG);\n\t\tudelay(100);\n\t\t\n\t\tNCR_700_writeb(0, host, DCNTL_REG);\n\t}\n\n\tmdelay(1000);\n\n\tNCR_700_chip_setup(host);\n}\n\n \nSTATIC __u32\nprocess_extended_message(struct Scsi_Host *host, \n\t\t\t struct NCR_700_Host_Parameters *hostdata,\n\t\t\t struct scsi_cmnd *SCp, __u32 dsp, __u32 dsps)\n{\n\t__u32 resume_offset = dsp, temp = dsp + 8;\n\t__u8 pun = 0xff, lun = 0xff;\n\n\tif(SCp != NULL) {\n\t\tpun = SCp->device->id;\n\t\tlun = SCp->device->lun;\n\t}\n\n\tswitch(hostdata->msgin[2]) {\n\tcase A_SDTR_MSG:\n\t\tif(SCp != NULL && NCR_700_is_flag_set(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION)) {\n\t\t\tstruct scsi_target *starget = SCp->device->sdev_target;\n\t\t\t__u8 period = hostdata->msgin[3];\n\t\t\t__u8 offset = hostdata->msgin[4];\n\n\t\t\tif(offset == 0 || period == 0) {\n\t\t\t\toffset = 0;\n\t\t\t\tperiod = 0;\n\t\t\t}\n\n\t\t\tspi_offset(starget) = offset;\n\t\t\tspi_period(starget) = period;\n\t\t\t\n\t\t\tif(NCR_700_is_flag_set(SCp->device, NCR_700_DEV_PRINT_SYNC_NEGOTIATION)) {\n\t\t\t\tspi_display_xfer_agreement(starget);\n\t\t\t\tNCR_700_clear_flag(SCp->device, NCR_700_DEV_PRINT_SYNC_NEGOTIATION);\n\t\t\t}\n\t\t\t\n\t\t\tNCR_700_set_flag(SCp->device, NCR_700_DEV_NEGOTIATED_SYNC);\n\t\t\tNCR_700_clear_flag(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\n\t\t\t\n\t\t\tNCR_700_writeb(NCR_700_get_SXFER(SCp->device),\n\t\t\t\t       host, SXFER_REG);\n\n\t\t} else {\n\t\t\t \n\t\t\tshost_printk(KERN_WARNING, host,\n\t\t\t\t\"Unexpected SDTR msg\\n\");\n\t\t\thostdata->msgout[0] = A_REJECT_MSG;\n\t\t\tdma_sync_to_dev(hostdata, hostdata->msgout, 1);\n\t\t\tscript_patch_16(hostdata, hostdata->script,\n\t\t\t                MessageCount, 1);\n\t\t\t \n\t\t\tresume_offset = hostdata->pScript + Ent_SendMessageWithATN;\n\t\t}\n\t\tbreak;\n\t\n\tcase A_WDTR_MSG:\n\t\tprintk(KERN_INFO \"scsi%d: (%d:%d), Unsolicited WDTR after CMD, Rejecting\\n\",\n\t\t       host->host_no, pun, lun);\n\t\thostdata->msgout[0] = A_REJECT_MSG;\n\t\tdma_sync_to_dev(hostdata, hostdata->msgout, 1);\n\t\tscript_patch_16(hostdata, hostdata->script, MessageCount, 1);\n\t\tresume_offset = hostdata->pScript + Ent_SendMessageWithATN;\n\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_INFO \"scsi%d (%d:%d): Unexpected message %s: \",\n\t\t       host->host_no, pun, lun,\n\t\t       NCR_700_phase[(dsps & 0xf00) >> 8]);\n\t\tspi_print_msg(hostdata->msgin);\n\t\tprintk(\"\\n\");\n\t\t \n\t\thostdata->msgout[0] = A_REJECT_MSG;\n\t\tdma_sync_to_dev(hostdata, hostdata->msgout, 1);\n\t\tscript_patch_16(hostdata, hostdata->script, MessageCount, 1);\n\t\t \n\t\tresume_offset = hostdata->pScript + Ent_SendMessageWithATN;\n\t}\n\tNCR_700_writel(temp, host, TEMP_REG);\n\treturn resume_offset;\n}\n\nSTATIC __u32\nprocess_message(struct Scsi_Host *host,\tstruct NCR_700_Host_Parameters *hostdata,\n\t\tstruct scsi_cmnd *SCp, __u32 dsp, __u32 dsps)\n{\n\t \n\t__u32 temp = dsp + 8, resume_offset = dsp;\n\t__u8 pun = 0xff, lun = 0xff;\n\n\tif(SCp != NULL) {\n\t\tpun = SCp->device->id;\n\t\tlun = SCp->device->lun;\n\t}\n\n#ifdef NCR_700_DEBUG\n\tprintk(\"scsi%d (%d:%d): message %s: \", host->host_no, pun, lun,\n\t       NCR_700_phase[(dsps & 0xf00) >> 8]);\n\tspi_print_msg(hostdata->msgin);\n\tprintk(\"\\n\");\n#endif\n\n\tswitch(hostdata->msgin[0]) {\n\n\tcase A_EXTENDED_MSG:\n\t\tresume_offset =  process_extended_message(host, hostdata, SCp,\n\t\t\t\t\t\t\t  dsp, dsps);\n\t\tbreak;\n\n\tcase A_REJECT_MSG:\n\t\tif(SCp != NULL && NCR_700_is_flag_set(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION)) {\n\t\t\t \n\t\t\tspi_period(SCp->device->sdev_target) =\n\t\t\t\tspi_offset(SCp->device->sdev_target) = 0;\n\t\t\tNCR_700_set_flag(SCp->device, NCR_700_DEV_NEGOTIATED_SYNC);\n\t\t\tNCR_700_clear_flag(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\n\t\t} else if(SCp != NULL && NCR_700_get_tag_neg_state(SCp->device) == NCR_700_DURING_TAG_NEGOTIATION) {\n\t\t\t \n\t\t\tscmd_printk(KERN_WARNING, SCp,\n\t\t\t\t\"Rejected first tag queue attempt, turning off tag queueing\\n\");\n\t\t\t \n\t\t\tNCR_700_set_tag_neg_state(SCp->device, NCR_700_FINISHED_TAG_NEGOTIATION);\n\t\t\thostdata->tag_negotiated &= ~(1<<scmd_id(SCp));\n\n\t\t\tSCp->device->tagged_supported = 0;\n\t\t\tSCp->device->simple_tags = 0;\n\t\t\tscsi_change_queue_depth(SCp->device, host->cmd_per_lun);\n\t\t} else {\n\t\t\tshost_printk(KERN_WARNING, host,\n\t\t\t\t\"(%d:%d) Unexpected REJECT Message %s\\n\",\n\t\t\t       pun, lun,\n\t\t\t       NCR_700_phase[(dsps & 0xf00) >> 8]);\n\t\t\t \n\t\t}\n\t\tbreak;\n\n\tcase A_PARITY_ERROR_MSG:\n\t\tprintk(KERN_ERR \"scsi%d (%d:%d) Parity Error!\\n\", host->host_no,\n\t\t       pun, lun);\n\t\tNCR_700_internal_bus_reset(host);\n\t\tbreak;\n\tcase A_SIMPLE_TAG_MSG:\n\t\tprintk(KERN_INFO \"scsi%d (%d:%d) SIMPLE TAG %d %s\\n\", host->host_no,\n\t\t       pun, lun, hostdata->msgin[1],\n\t\t       NCR_700_phase[(dsps & 0xf00) >> 8]);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_INFO \"scsi%d (%d:%d): Unexpected message %s: \",\n\t\t       host->host_no, pun, lun,\n\t\t       NCR_700_phase[(dsps & 0xf00) >> 8]);\n\n\t\tspi_print_msg(hostdata->msgin);\n\t\tprintk(\"\\n\");\n\t\t \n\t\thostdata->msgout[0] = A_REJECT_MSG;\n\t\tdma_sync_to_dev(hostdata, hostdata->msgout, 1);\n\t\tscript_patch_16(hostdata, hostdata->script, MessageCount, 1);\n\t\t \n\t\tresume_offset = hostdata->pScript + Ent_SendMessageWithATN;\n\n\t\tbreak;\n\t}\n\tNCR_700_writel(temp, host, TEMP_REG);\n\t \n\tdma_sync_from_dev(hostdata, hostdata->msgin, MSG_ARRAY_SIZE);\n\treturn resume_offset;\n}\n\nSTATIC __u32\nprocess_script_interrupt(__u32 dsps, __u32 dsp, struct scsi_cmnd *SCp,\n\t\t\t struct Scsi_Host *host,\n\t\t\t struct NCR_700_Host_Parameters *hostdata)\n{\n\t__u32 resume_offset = 0;\n\t__u8 pun = 0xff, lun=0xff;\n\n\tif(SCp != NULL) {\n\t\tpun = SCp->device->id;\n\t\tlun = SCp->device->lun;\n\t}\n\n\tif(dsps == A_GOOD_STATUS_AFTER_STATUS) {\n\t\tDEBUG((\"  COMMAND COMPLETE, status=%02x\\n\",\n\t\t       hostdata->status[0]));\n\t\t \n\t\tif (NCR_700_get_tag_neg_state(SCp->device) == NCR_700_DURING_TAG_NEGOTIATION)\n\t\t\tNCR_700_set_tag_neg_state(SCp->device,\n\t\t\t\t\t\t  NCR_700_FINISHED_TAG_NEGOTIATION);\n\n\t\t \n\t\tif (hostdata->status[0] == SAM_STAT_CHECK_CONDITION ||\n\t\t    hostdata->status[0] == SAM_STAT_COMMAND_TERMINATED) {\n\t\t\tstruct NCR_700_command_slot *slot =\n\t\t\t\t(struct NCR_700_command_slot *)SCp->host_scribble;\n\t\t\tif(slot->flags == NCR_700_FLAG_AUTOSENSE) {\n\t\t\t\t \n\t\t\t\tscmd_printk(KERN_ERR, SCp,\n\t\t\t\t\t\"broken device is looping in contingent allegiance: ignoring\\n\");\n\t\t\t\tNCR_700_scsi_done(hostdata, SCp, hostdata->status[0]);\n\t\t\t} else {\n\t\t\t\tchar *cmnd =\n\t\t\t\t\tNCR_700_get_sense_cmnd(SCp->device);\n#ifdef NCR_DEBUG\n\t\t\t\tscsi_print_command(SCp);\n\t\t\t\tprintk(\"  cmd %p has status %d, requesting sense\\n\",\n\t\t\t\t       SCp, hostdata->status[0]);\n#endif\n\t\t\t\t \n\t\t\t\tNCR_700_unmap(hostdata, SCp, slot);\n\t\t\t\tdma_unmap_single(hostdata->dev, slot->pCmd,\n\t\t\t\t\t\t MAX_COMMAND_SIZE,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\t\t\tcmnd[0] = REQUEST_SENSE;\n\t\t\t\tcmnd[1] = (lun & 0x7) << 5;\n\t\t\t\tcmnd[2] = 0;\n\t\t\t\tcmnd[3] = 0;\n\t\t\t\tcmnd[4] = SCSI_SENSE_BUFFERSIZE;\n\t\t\t\tcmnd[5] = 0;\n\t\t\t\t \n\t\t\t\tcmnd[6] = NCR_700_INTERNAL_SENSE_MAGIC;\n\t\t\t\tcmnd[7] = hostdata->status[0];\n\t\t\t\tcmnd[8] = SCp->cmd_len;\n\t\t\t\tSCp->cmd_len = 6;  \n\t\t\t\tslot->pCmd = dma_map_single(hostdata->dev, cmnd, MAX_COMMAND_SIZE, DMA_TO_DEVICE);\n\t\t\t\tslot->dma_handle = dma_map_single(hostdata->dev, SCp->sense_buffer, SCSI_SENSE_BUFFERSIZE, DMA_FROM_DEVICE);\n\t\t\t\tslot->SG[0].ins = bS_to_host(SCRIPT_MOVE_DATA_IN | SCSI_SENSE_BUFFERSIZE);\n\t\t\t\tslot->SG[0].pAddr = bS_to_host(slot->dma_handle);\n\t\t\t\tslot->SG[1].ins = bS_to_host(SCRIPT_RETURN);\n\t\t\t\tslot->SG[1].pAddr = 0;\n\t\t\t\tslot->resume_offset = hostdata->pScript;\n\t\t\t\tdma_sync_to_dev(hostdata, slot->SG, sizeof(slot->SG[0])*2);\n\t\t\t\tdma_sync_from_dev(hostdata, SCp->sense_buffer, SCSI_SENSE_BUFFERSIZE);\n\n\t\t\t\t \n\t\t\t\tslot->state = NCR_700_SLOT_QUEUED;\n\t\t\t\tslot->flags = NCR_700_FLAG_AUTOSENSE;\n\t\t\t\thostdata->state = NCR_700_HOST_FREE;\n\t\t\t\thostdata->cmd = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tNCR_700_scsi_done(hostdata, SCp, hostdata->status[0]);\n\t\t}\n\t} else if((dsps & 0xfffff0f0) == A_UNEXPECTED_PHASE) {\n\t\t__u8 i = (dsps & 0xf00) >> 8;\n\n\t\tscmd_printk(KERN_ERR, SCp, \"UNEXPECTED PHASE %s (%s)\\n\",\n\t\t       NCR_700_phase[i],\n\t\t       sbcl_to_string(NCR_700_readb(host, SBCL_REG)));\n\t\tscmd_printk(KERN_ERR, SCp, \"         len = %d, cmd =\",\n\t\t\tSCp->cmd_len);\n\t\tscsi_print_command(SCp);\n\n\t\tNCR_700_internal_bus_reset(host);\n\t} else if((dsps & 0xfffff000) == A_FATAL) {\n\t\tint i = (dsps & 0xfff);\n\n\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) FATAL ERROR: %s\\n\",\n\t\t       host->host_no, pun, lun, NCR_700_fatal_messages[i]);\n\t\tif(dsps == A_FATAL_ILLEGAL_MSG_LENGTH) {\n\t\t\tprintk(KERN_ERR \"     msg begins %02x %02x\\n\",\n\t\t\t       hostdata->msgin[0], hostdata->msgin[1]);\n\t\t}\n\t\tNCR_700_internal_bus_reset(host);\n\t} else if((dsps & 0xfffff0f0) == A_DISCONNECT) {\n#ifdef NCR_700_DEBUG\n\t\t__u8 i = (dsps & 0xf00) >> 8;\n\n\t\tprintk(\"scsi%d: (%d:%d), DISCONNECTED (%d) %s\\n\",\n\t\t       host->host_no, pun, lun,\n\t\t       i, NCR_700_phase[i]);\n#endif\n\t\tsave_for_reselection(hostdata, SCp, dsp);\n\n\t} else if(dsps == A_RESELECTION_IDENTIFIED) {\n\t\t__u8 lun;\n\t\tstruct NCR_700_command_slot *slot;\n\t\t__u8 reselection_id = hostdata->reselection_id;\n\t\tstruct scsi_device *SDp;\n\n\t\tlun = hostdata->msgin[0] & 0x1f;\n\n\t\thostdata->reselection_id = 0xff;\n\t\tDEBUG((\"scsi%d: (%d:%d) RESELECTED!\\n\",\n\t\t       host->host_no, reselection_id, lun));\n\t\t \n\t\tSDp = __scsi_device_lookup(host, 0, reselection_id, lun);\n\t\tif(unlikely(SDp == NULL)) {\n\t\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) HAS NO device\\n\",\n\t\t\t       host->host_no, reselection_id, lun);\n\t\t\tBUG();\n\t\t}\n\t\tif(hostdata->msgin[1] == A_SIMPLE_TAG_MSG) {\n\t\t\tstruct scsi_cmnd *SCp;\n\n\t\t\tSCp = scsi_host_find_tag(SDp->host, hostdata->msgin[2]);\n\t\t\tif(unlikely(SCp == NULL)) {\n\t\t\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) no saved request for tag %d\\n\", \n\t\t\t\t       host->host_no, reselection_id, lun, hostdata->msgin[2]);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tslot = (struct NCR_700_command_slot *)SCp->host_scribble;\n\t\t\tDDEBUG(KERN_DEBUG, SDp,\n\t\t\t\t\"reselection is tag %d, slot %p(%d)\\n\",\n\t\t\t\thostdata->msgin[2], slot, slot->tag);\n\t\t} else {\n\t\t\tstruct NCR_700_Device_Parameters *p = SDp->hostdata;\n\t\t\tstruct scsi_cmnd *SCp = p->current_cmnd;\n\n\t\t\tif(unlikely(SCp == NULL)) {\n\t\t\t\tsdev_printk(KERN_ERR, SDp,\n\t\t\t\t\t\"no saved request for untagged cmd\\n\");\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tslot = (struct NCR_700_command_slot *)SCp->host_scribble;\n\t\t}\n\n\t\tif(slot == NULL) {\n\t\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) RESELECTED but no saved command (MSG = %02x %02x %02x)!!\\n\",\n\t\t\t       host->host_no, reselection_id, lun,\n\t\t\t       hostdata->msgin[0], hostdata->msgin[1],\n\t\t\t       hostdata->msgin[2]);\n\t\t} else {\n\t\t\tif(hostdata->state != NCR_700_HOST_BUSY)\n\t\t\t\tprintk(KERN_ERR \"scsi%d: FATAL, host not busy during valid reselection!\\n\",\n\t\t\t\t       host->host_no);\n\t\t\tresume_offset = slot->resume_offset;\n\t\t\thostdata->cmd = slot->cmnd;\n\n\t\t\t \n\t\t\tscript_patch_32_abs(hostdata, hostdata->script,\n\t\t\t                    CommandAddress, slot->pCmd);\n\t\t\tscript_patch_16(hostdata, hostdata->script,\n\t\t\t\t\tCommandCount, slot->cmnd->cmd_len);\n\t\t\tscript_patch_32_abs(hostdata, hostdata->script,\n\t\t\t                    SGScriptStartAddress,\n\t\t\t\t\t    to32bit(&slot->pSG[0].ins));\n\n\t\t\t \n\t\t\tNCR_700_writeb(NCR_700_get_SXFER(hostdata->cmd->device),\n\t\t\t\t       host, SXFER_REG);\n\t\t\tdma_sync_from_dev(hostdata, hostdata->msgin,\n\t\t\t\t       MSG_ARRAY_SIZE);\n\t\t\tdma_sync_to_dev(hostdata, hostdata->msgout,\n\t\t\t\t       MSG_ARRAY_SIZE);\n\t\t\t \n\t\t\tdma_sync_to_dev(hostdata, slot->cmnd->cmnd,\n\t\t\t\t       slot->cmnd->cmd_len);\n\n\n\t\t\t\n\t\t}\n\t} else if(dsps == A_RESELECTED_DURING_SELECTION) {\n\n\t\t \n\n\t\t__u8 reselection_id = NCR_700_readb(host, SFBR_REG);\n\t\tstruct NCR_700_command_slot *slot;\n\t\t\n\t\t \n\t\treselection_id &= ~(1<<host->this_id);\n\t\t\n\t\t \n\t\tprintk(KERN_INFO \"scsi%d: (%d:%d) RESELECTION DURING SELECTION, dsp=%08x[%04x] state=%d, count=%d\\n\",\n\t\t       host->host_no, reselection_id, lun, dsp, dsp - hostdata->pScript, hostdata->state, hostdata->command_slot_count);\n\n\t\t{\n\t\t\t \n\t\t\t__u32 SG = (__u32)bS_to_cpu(hostdata->script[A_SGScriptStartAddress_used[0]]);\n\t\t\tint i;\n\n\t\t\tfor(i=0; i< NCR_700_COMMAND_SLOTS_PER_HOST; i++) {\n\t\t\t\tif(SG >= to32bit(&hostdata->slots[i].pSG[0])\n\t\t\t\t   && SG <= to32bit(&hostdata->slots[i].pSG[NCR_700_SG_SEGMENTS]))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"IDENTIFIED SG segment as being %08x in slot %p, cmd %p, slot->resume_offset=%08x\\n\", SG, &hostdata->slots[i], hostdata->slots[i].cmnd, hostdata->slots[i].resume_offset);\n\t\t\tSCp =  hostdata->slots[i].cmnd;\n\t\t}\n\n\t\tif(SCp != NULL) {\n\t\t\tslot = (struct NCR_700_command_slot *)SCp->host_scribble;\n\t\t\t \n\t\t\tslot->state = NCR_700_SLOT_QUEUED;\n\t\t}\n\t\thostdata->cmd = NULL;\n\t\t\n\t\tif(reselection_id == 0) {\n\t\t\tif(hostdata->reselection_id == 0xff) {\n\t\t\t\tprintk(KERN_ERR \"scsi%d: Invalid reselection during selection!!\\n\", host->host_no);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"scsi%d: script reselected and we took a selection interrupt\\n\",\n\t\t\t\t       host->host_no);\n\t\t\t\treselection_id = hostdata->reselection_id;\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\t \n\t\t\treselection_id = bitmap_to_number(reselection_id);\n\t\t}\n\t\thostdata->reselection_id = reselection_id;\n\t\t \n\t\thostdata->msgin[1] = 0;\n\t\tdma_sync_to_dev(hostdata, hostdata->msgin, MSG_ARRAY_SIZE);\n\t\tif(hostdata->tag_negotiated & (1<<reselection_id)) {\n\t\t\tresume_offset = hostdata->pScript + Ent_GetReselectionWithTag;\n\t\t} else {\n\t\t\tresume_offset = hostdata->pScript + Ent_GetReselectionData;\n\t\t}\n\t} else if(dsps == A_COMPLETED_SELECTION_AS_TARGET) {\n\t\t \n\t\tDEBUG((\" SELECTION COMPLETED\\n\"));\n\t} else if((dsps & 0xfffff0f0) == A_MSG_IN) { \n\t\tresume_offset = process_message(host, hostdata, SCp,\n\t\t\t\t\t\tdsp, dsps);\n\t} else if((dsps &  0xfffff000) == 0) {\n\t\t__u8 i = (dsps & 0xf0) >> 4, j = (dsps & 0xf00) >> 8;\n\t\tprintk(KERN_ERR \"scsi%d: (%d:%d), unhandled script condition %s %s at %04x\\n\",\n\t\t       host->host_no, pun, lun, NCR_700_condition[i],\n\t\t       NCR_700_phase[j], dsp - hostdata->pScript);\n\t\tif(SCp != NULL) {\n\t\t\tstruct scatterlist *sg;\n\n\t\t\tscsi_print_command(SCp);\n\t\t\tscsi_for_each_sg(SCp, sg, scsi_sg_count(SCp) + 1, i) {\n\t\t\t\tprintk(KERN_INFO \" SG[%d].length = %d, move_insn=%08x, addr %08x\\n\", i, sg->length, ((struct NCR_700_command_slot *)SCp->host_scribble)->SG[i].ins, ((struct NCR_700_command_slot *)SCp->host_scribble)->SG[i].pAddr);\n\t\t\t}\n\t\t}\n\t\tNCR_700_internal_bus_reset(host);\n\t} else if((dsps & 0xfffff000) == A_DEBUG_INTERRUPT) {\n\t\tprintk(KERN_NOTICE \"scsi%d (%d:%d) DEBUG INTERRUPT %d AT %08x[%04x], continuing\\n\",\n\t\t       host->host_no, pun, lun, dsps & 0xfff, dsp, dsp - hostdata->pScript);\n\t\tresume_offset = dsp;\n\t} else {\n\t\tprintk(KERN_ERR \"scsi%d: (%d:%d), unidentified script interrupt 0x%x at %04x\\n\",\n\t\t       host->host_no, pun, lun, dsps, dsp - hostdata->pScript);\n\t\tNCR_700_internal_bus_reset(host);\n\t}\n\treturn resume_offset;\n}\n\n \nSTATIC inline __u32\nprocess_selection(struct Scsi_Host *host, __u32 dsp)\n{\n\t__u8 id = 0;\t \n\tint count = 0;\n\t__u32 resume_offset = 0;\n\tstruct NCR_700_Host_Parameters *hostdata =\n\t\t(struct NCR_700_Host_Parameters *)host->hostdata[0];\n\tstruct scsi_cmnd *SCp = hostdata->cmd;\n\t__u8 sbcl;\n\n\tfor(count = 0; count < 5; count++) {\n\t\tid = NCR_700_readb(host, hostdata->chip710 ?\n\t\t\t\t   CTEST9_REG : SFBR_REG);\n\n\t\t \n\t\tid &= ~(1<<host->this_id);\n\t\tif(id != 0) \n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\tsbcl = NCR_700_readb(host, SBCL_REG);\n\tif((sbcl & SBCL_IO) == 0) {\n\t\t \n\t\tid = 0xff;\n\t} else {\n\t\t \n\t\thostdata->reselection_id = id = bitmap_to_number(id);\n\t\tDEBUG((\"scsi%d:  Reselected by %d\\n\",\n\t\t       host->host_no, id));\n\t}\n\tif(hostdata->state == NCR_700_HOST_BUSY && SCp != NULL) {\n\t\tstruct NCR_700_command_slot *slot =\n\t\t\t(struct NCR_700_command_slot *)SCp->host_scribble;\n\t\tDEBUG((\"  ID %d WARNING: RESELECTION OF BUSY HOST, saving cmd %p, slot %p, addr %x [%04x], resume %x!\\n\", id, hostdata->cmd, slot, dsp, dsp - hostdata->pScript, resume_offset));\n\t\t\n\t\tswitch(dsp - hostdata->pScript) {\n\t\tcase Ent_Disconnect1:\n\t\tcase Ent_Disconnect2:\n\t\t\tsave_for_reselection(hostdata, SCp, Ent_Disconnect2 + hostdata->pScript);\n\t\t\tbreak;\n\t\tcase Ent_Disconnect3:\n\t\tcase Ent_Disconnect4:\n\t\t\tsave_for_reselection(hostdata, SCp, Ent_Disconnect4 + hostdata->pScript);\n\t\t\tbreak;\n\t\tcase Ent_Disconnect5:\n\t\tcase Ent_Disconnect6:\n\t\t\tsave_for_reselection(hostdata, SCp, Ent_Disconnect6 + hostdata->pScript);\n\t\t\tbreak;\n\t\tcase Ent_Disconnect7:\n\t\tcase Ent_Disconnect8:\n\t\t\tsave_for_reselection(hostdata, SCp, Ent_Disconnect8 + hostdata->pScript);\n\t\t\tbreak;\n\t\tcase Ent_Finish1:\n\t\tcase Ent_Finish2:\n\t\t\tprocess_script_interrupt(A_GOOD_STATUS_AFTER_STATUS, dsp, SCp, host, hostdata);\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tslot->state = NCR_700_SLOT_QUEUED;\n\t\t\tbreak;\n\t\t\t}\n\t}\n\thostdata->state = NCR_700_HOST_BUSY;\n\thostdata->cmd = NULL;\n\t \n\thostdata->msgin[1] = 0;\n\tdma_sync_to_dev(hostdata, hostdata->msgin, MSG_ARRAY_SIZE);\n\n\tif(id == 0xff) {\n\t\t \n\t\tresume_offset = hostdata->pScript + Ent_SelectedAsTarget;\n\t} else if(hostdata->tag_negotiated & (1<<id)) {\n\t\tresume_offset = hostdata->pScript + Ent_GetReselectionWithTag;\n\t} else {\n\t\tresume_offset = hostdata->pScript + Ent_GetReselectionData;\n\t}\n\treturn resume_offset;\n}\n\nstatic inline void\nNCR_700_clear_fifo(struct Scsi_Host *host) {\n\tconst struct NCR_700_Host_Parameters *hostdata\n\t\t= (struct NCR_700_Host_Parameters *)host->hostdata[0];\n\tif(hostdata->chip710) {\n\t\tNCR_700_writeb(CLR_FIFO_710, host, CTEST8_REG);\n\t} else {\n\t\tNCR_700_writeb(CLR_FIFO, host, DFIFO_REG);\n\t}\n}\n\nstatic inline void\nNCR_700_flush_fifo(struct Scsi_Host *host) {\n\tconst struct NCR_700_Host_Parameters *hostdata\n\t\t= (struct NCR_700_Host_Parameters *)host->hostdata[0];\n\tif(hostdata->chip710) {\n\t\tNCR_700_writeb(FLUSH_DMA_FIFO_710, host, CTEST8_REG);\n\t\tudelay(10);\n\t\tNCR_700_writeb(0, host, CTEST8_REG);\n\t} else {\n\t\tNCR_700_writeb(FLUSH_DMA_FIFO, host, DFIFO_REG);\n\t\tudelay(10);\n\t\tNCR_700_writeb(0, host, DFIFO_REG);\n\t}\n}\n\n\n \nSTATIC int\nNCR_700_start_command(struct scsi_cmnd *SCp)\n{\n\tstruct NCR_700_command_slot *slot =\n\t\t(struct NCR_700_command_slot *)SCp->host_scribble;\n\tstruct NCR_700_Host_Parameters *hostdata =\n\t\t(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];\n\t__u16 count = 1;\t \n\tu8 lun = SCp->device->lun;\n\n\tif(hostdata->state != NCR_700_HOST_FREE) {\n\t\t \n\t\tslot->state = NCR_700_SLOT_QUEUED;\n\n\t\tDEBUG((\"scsi%d: host busy, queueing command %p, slot %p\\n\",\n\t\t       SCp->device->host->host_no, slot->cmnd, slot));\n\t\treturn 0;\n\t}\n\thostdata->state = NCR_700_HOST_BUSY;\n\thostdata->cmd = SCp;\n\tslot->state = NCR_700_SLOT_BUSY;\n\t \n\n\thostdata->msgout[0] = NCR_700_identify((SCp->cmnd[0] != REQUEST_SENSE &&\n\t\t\t\t\t\tslot->flags != NCR_700_FLAG_AUTOSENSE),\n\t\t\t\t\t       lun);\n\t \n\tif(SCp->cmnd[0] == INQUIRY || SCp->cmnd[0] == REQUEST_SENSE ||\n\t   slot->flags == NCR_700_FLAG_AUTOSENSE) {\n\t\tNCR_700_clear_flag(SCp->device, NCR_700_DEV_NEGOTIATED_SYNC);\n\t}\n\n\t \n\tif((hostdata->tag_negotiated & (1<<scmd_id(SCp)))\n\t   && (slot->tag != SCSI_NO_TAG && SCp->cmnd[0] != REQUEST_SENSE &&\n\t       slot->flags != NCR_700_FLAG_AUTOSENSE)) {\n\t\tcount += spi_populate_tag_msg(&hostdata->msgout[count], SCp);\n\t}\n\n\tif(hostdata->fast &&\n\t   NCR_700_is_flag_clear(SCp->device, NCR_700_DEV_NEGOTIATED_SYNC)) {\n\t\tcount += spi_populate_sync_msg(&hostdata->msgout[count],\n\t\t\t\tspi_period(SCp->device->sdev_target),\n\t\t\t\tspi_offset(SCp->device->sdev_target));\n\t\tNCR_700_set_flag(SCp->device, NCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\n\t}\n\n\tscript_patch_16(hostdata, hostdata->script, MessageCount, count);\n\n\tscript_patch_ID(hostdata, hostdata->script, Device_ID, 1<<scmd_id(SCp));\n\n\tscript_patch_32_abs(hostdata, hostdata->script, CommandAddress,\n\t\t\t    slot->pCmd);\n\tscript_patch_16(hostdata, hostdata->script, CommandCount, SCp->cmd_len);\n\t \n\tscript_patch_32_abs(hostdata, hostdata->script,\n\t                    SGScriptStartAddress, to32bit(&slot->pSG[0].ins));\n\tNCR_700_clear_fifo(SCp->device->host);\n\n\tif(slot->resume_offset == 0)\n\t\tslot->resume_offset = hostdata->pScript;\n\t \n\tdma_sync_to_dev(hostdata, hostdata->msgout, count);\n\tdma_sync_from_dev(hostdata, hostdata->msgin, MSG_ARRAY_SIZE);\n\tdma_sync_to_dev(hostdata, SCp->cmnd, SCp->cmd_len);\n\tdma_sync_from_dev(hostdata, hostdata->status, 1);\n\n\t \n\tNCR_700_writeb(NCR_700_get_SXFER(SCp->device),\n\t\t       SCp->device->host, SXFER_REG);\n\tNCR_700_writel(slot->temp, SCp->device->host, TEMP_REG);\n\tNCR_700_writel(slot->resume_offset, SCp->device->host, DSP_REG);\n\n\treturn 1;\n}\n\nirqreturn_t\nNCR_700_intr(int irq, void *dev_id)\n{\n\tstruct Scsi_Host *host = (struct Scsi_Host *)dev_id;\n\tstruct NCR_700_Host_Parameters *hostdata =\n\t\t(struct NCR_700_Host_Parameters *)host->hostdata[0];\n\t__u8 istat;\n\t__u32 resume_offset = 0;\n\t__u8 pun = 0xff, lun = 0xff;\n\tunsigned long flags;\n\tint handled = 0;\n\n\t \n\tspin_lock_irqsave(host->host_lock, flags);\n\tif((istat = NCR_700_readb(host, ISTAT_REG))\n\t      & (SCSI_INT_PENDING | DMA_INT_PENDING)) {\n\t\t__u32 dsps;\n\t\t__u8 sstat0 = 0, dstat = 0;\n\t\t__u32 dsp;\n\t\tstruct scsi_cmnd *SCp = hostdata->cmd;\n\n\t\thandled = 1;\n\n\t\tif(istat & SCSI_INT_PENDING) {\n\t\t\tudelay(10);\n\n\t\t\tsstat0 = NCR_700_readb(host, SSTAT0_REG);\n\t\t}\n\n\t\tif(istat & DMA_INT_PENDING) {\n\t\t\tudelay(10);\n\n\t\t\tdstat = NCR_700_readb(host, DSTAT_REG);\n\t\t}\n\n\t\tdsps = NCR_700_readl(host, DSPS_REG);\n\t\tdsp = NCR_700_readl(host, DSP_REG);\n\n\t\tDEBUG((\"scsi%d: istat %02x sstat0 %02x dstat %02x dsp %04x[%08x] dsps 0x%x\\n\",\n\t\t       host->host_no, istat, sstat0, dstat,\n\t\t       (dsp - (__u32)(hostdata->pScript))/4,\n\t\t       dsp, dsps));\n\n\t\tif(SCp != NULL) {\n\t\t\tpun = SCp->device->id;\n\t\t\tlun = SCp->device->lun;\n\t\t}\n\n\t\tif(sstat0 & SCSI_RESET_DETECTED) {\n\t\t\tstruct scsi_device *SDp;\n\t\t\tint i;\n\n\t\t\thostdata->state = NCR_700_HOST_BUSY;\n\n\t\t\tprintk(KERN_ERR \"scsi%d: Bus Reset detected, executing command %p, slot %p, dsp %08x[%04x]\\n\",\n\t\t\t       host->host_no, SCp, SCp == NULL ? NULL : SCp->host_scribble, dsp, dsp - hostdata->pScript);\n\n\t\t\tscsi_report_bus_reset(host, 0);\n\n\t\t\t \n\t\t\t__shost_for_each_device(SDp, host)\n\t\t\t\tNCR_700_clear_flag(SDp, ~0);\n\t\t\t\n\t\t\t \n\t\t\tfor(i = 0; i < NCR_700_COMMAND_SLOTS_PER_HOST; i++) {\n\t\t\t\tstruct scsi_cmnd *SCp;\n\t\t\t\tstruct NCR_700_command_slot *slot =\n\t\t\t\t\t&hostdata->slots[i];\n\n\t\t\t\tif(slot->state == NCR_700_SLOT_FREE)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tSCp = slot->cmnd;\n\t\t\t\tprintk(KERN_ERR \" failing command because of reset, slot %p, cmnd %p\\n\",\n\t\t\t\t       slot, SCp);\n\t\t\t\tfree_slot(slot, hostdata);\n\t\t\t\tSCp->host_scribble = NULL;\n\t\t\t\tNCR_700_set_depth(SCp->device, 0);\n\t\t\t\t \n\t\t\t\tSCp->result = DID_RESET << 16;\n\t\t\t\tscsi_done(SCp);\n\t\t\t}\n\t\t\tmdelay(25);\n\t\t\tNCR_700_chip_setup(host);\n\n\t\t\thostdata->state = NCR_700_HOST_FREE;\n\t\t\thostdata->cmd = NULL;\n\t\t\t \n\t\t\tif(hostdata->eh_complete != NULL)\n\t\t\t\tcomplete(hostdata->eh_complete);\n\t\t\tgoto out_unlock;\n\t\t} else if(sstat0 & SELECTION_TIMEOUT) {\n\t\t\tDEBUG((\"scsi%d: (%d:%d) selection timeout\\n\",\n\t\t\t       host->host_no, pun, lun));\n\t\t\tNCR_700_scsi_done(hostdata, SCp, DID_NO_CONNECT<<16);\n\t\t} else if(sstat0 & PHASE_MISMATCH) {\n\t\t\tstruct NCR_700_command_slot *slot = (SCp == NULL) ? NULL :\n\t\t\t\t(struct NCR_700_command_slot *)SCp->host_scribble;\n\n\t\t\tif(dsp == Ent_SendMessage + 8 + hostdata->pScript) {\n\t\t\t\t \n#ifdef NCR_700_DEBUG\n\t\t\t\t__u32 temp = NCR_700_readl(host, TEMP_REG);\n\t\t\t\tint count = (hostdata->script[Ent_SendMessage/4] & 0xffffff) - ((NCR_700_readl(host, DBC_REG) & 0xffffff) + NCR_700_data_residual(host));\n\t\t\t\tprintk(\"scsi%d (%d:%d) PHASE MISMATCH IN SEND MESSAGE %d remain, return %p[%04x], phase %s\\n\", host->host_no, pun, lun, count, (void *)temp, temp - hostdata->pScript, sbcl_to_string(NCR_700_readb(host, SBCL_REG)));\n#endif\n\t\t\t\tresume_offset = hostdata->pScript + Ent_SendMessagePhaseMismatch;\n\t\t\t} else if (slot && dsp >= to32bit(&slot->pSG[0].ins) &&\n\t\t\t\t  dsp <= to32bit(&slot->pSG[NCR_700_SG_SEGMENTS].ins)) {\n\t\t\t\tint data_transfer = NCR_700_readl(host, DBC_REG) & 0xffffff;\n\t\t\t\tint SGcount = (dsp - to32bit(&slot->pSG[0].ins))/sizeof(struct NCR_700_SG_List);\n\t\t\t\tint residual = NCR_700_data_residual(host);\n\t\t\t\tint i;\n#ifdef NCR_700_DEBUG\n\t\t\t\t__u32 naddr = NCR_700_readl(host, DNAD_REG);\n\n\t\t\t\tprintk(\"scsi%d: (%d:%d) Expected phase mismatch in slot->SG[%d], transferred 0x%x\\n\",\n\t\t\t\t       host->host_no, pun, lun,\n\t\t\t\t       SGcount, data_transfer);\n\t\t\t\tscsi_print_command(SCp);\n\t\t\t\tif(residual) {\n\t\t\t\t\tprintk(\"scsi%d: (%d:%d) Expected phase mismatch in slot->SG[%d], transferred 0x%x, residual %d\\n\",\n\t\t\t\t       host->host_no, pun, lun,\n\t\t\t\t       SGcount, data_transfer, residual);\n\t\t\t\t}\n#endif\n\t\t\t\tdata_transfer += residual;\n\n\t\t\t\tif(data_transfer != 0) {\n\t\t\t\t\tint count; \n\t\t\t\t\t__u32 pAddr;\n\n\t\t\t\t\tSGcount--;\n\n\t\t\t\t\tcount = (bS_to_cpu(slot->SG[SGcount].ins) & 0x00ffffff);\n\t\t\t\t\tDEBUG((\"DATA TRANSFER MISMATCH, count = %d, transferred %d\\n\", count, count-data_transfer));\n\t\t\t\t\tslot->SG[SGcount].ins &= bS_to_host(0xff000000);\n\t\t\t\t\tslot->SG[SGcount].ins |= bS_to_host(data_transfer);\n\t\t\t\t\tpAddr = bS_to_cpu(slot->SG[SGcount].pAddr);\n\t\t\t\t\tpAddr += (count - data_transfer);\n#ifdef NCR_700_DEBUG\n\t\t\t\t\tif(pAddr != naddr) {\n\t\t\t\t\t\tprintk(\"scsi%d (%d:%d) transfer mismatch pAddr=%lx, naddr=%lx, data_transfer=%d, residual=%d\\n\", host->host_no, pun, lun, (unsigned long)pAddr, (unsigned long)naddr, data_transfer, residual);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tslot->SG[SGcount].pAddr = bS_to_host(pAddr);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tfor(i=0; i<SGcount; i++) {\n\t\t\t\t\tslot->SG[i].ins = bS_to_host(SCRIPT_NOP);\n\t\t\t\t\tslot->SG[i].pAddr = 0;\n\t\t\t\t}\n\t\t\t\tdma_sync_to_dev(hostdata, slot->SG, sizeof(slot->SG));\n\t\t\t\t \n\t\t\t\tresume_offset = hostdata->pScript + Ent_MsgInDuringData;\n\t\t\t\t \n\t\t\t\tNCR_700_flush_fifo(host);\n\t\t\t} else {\n\t\t\t\t__u8 sbcl = NCR_700_readb(host, SBCL_REG);\n\t\t\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) phase mismatch at %04x, phase %s\\n\",\n\t\t\t\t       host->host_no, pun, lun, dsp - hostdata->pScript, sbcl_to_string(sbcl));\n\t\t\t\tNCR_700_internal_bus_reset(host);\n\t\t\t}\n\n\t\t} else if(sstat0 & SCSI_GROSS_ERROR) {\n\t\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) GROSS ERROR\\n\",\n\t\t\t       host->host_no, pun, lun);\n\t\t\tNCR_700_scsi_done(hostdata, SCp, DID_ERROR<<16);\n\t\t} else if(sstat0 & PARITY_ERROR) {\n\t\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) PARITY ERROR\\n\",\n\t\t\t       host->host_no, pun, lun);\n\t\t\tNCR_700_scsi_done(hostdata, SCp, DID_ERROR<<16);\n\t\t} else if(dstat & SCRIPT_INT_RECEIVED) {\n\t\t\tDEBUG((\"scsi%d: (%d:%d) ====>SCRIPT INTERRUPT<====\\n\",\n\t\t\t       host->host_no, pun, lun));\n\t\t\tresume_offset = process_script_interrupt(dsps, dsp, SCp, host, hostdata);\n\t\t} else if(dstat & (ILGL_INST_DETECTED)) {\n\t\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) Illegal Instruction detected at 0x%08x[0x%x]!!!\\n\"\n\t\t\t       \"         Please email James.Bottomley@HansenPartnership.com with the details\\n\",\n\t\t\t       host->host_no, pun, lun,\n\t\t\t       dsp, dsp - hostdata->pScript);\n\t\t\tNCR_700_scsi_done(hostdata, SCp, DID_ERROR<<16);\n\t\t} else if(dstat & (WATCH_DOG_INTERRUPT|ABORTED)) {\n\t\t\tprintk(KERN_ERR \"scsi%d: (%d:%d) serious DMA problem, dstat=%02x\\n\",\n\t\t\t       host->host_no, pun, lun, dstat);\n\t\t\tNCR_700_scsi_done(hostdata, SCp, DID_ERROR<<16);\n\t\t}\n\n\t\t\n\t\t \n\t\tif(sstat0 & SELECTED) {\n\t\t\t \n\n\t\t\tresume_offset = process_selection(host, dsp);\n\n\t\t}\n\n\t}\n\n\tif(resume_offset) {\n\t\tif(hostdata->state != NCR_700_HOST_BUSY) {\n\t\t\tprintk(KERN_ERR \"scsi%d: Driver error: resume at 0x%08x [0x%04x] with non busy host!\\n\",\n\t\t\t       host->host_no, resume_offset, resume_offset - hostdata->pScript);\n\t\t\thostdata->state = NCR_700_HOST_BUSY;\n\t\t}\n\n\t\tDEBUG((\"Attempting to resume at %x\\n\", resume_offset));\n\t\tNCR_700_clear_fifo(host);\n\t\tNCR_700_writel(resume_offset, host, DSP_REG);\n\t} \n\t \n\tif(hostdata->state == NCR_700_HOST_FREE) {\n\t\tint i;\n\n\t\tfor(i = 0; i < NCR_700_COMMAND_SLOTS_PER_HOST; i++) {\n\t\t\t \n\t\t\tint j = (i + hostdata->saved_slot_position)\n\t\t\t\t% NCR_700_COMMAND_SLOTS_PER_HOST;\n\t\t\t\n\t\t\tif(hostdata->slots[j].state != NCR_700_SLOT_QUEUED)\n\t\t\t\tcontinue;\n\t\t\tif(NCR_700_start_command(hostdata->slots[j].cmnd)) {\n\t\t\t\tDEBUG((\"scsi%d: Issuing saved command slot %p, cmd %p\\t\\n\",\n\t\t\t\t       host->host_no, &hostdata->slots[j],\n\t\t\t\t       hostdata->slots[j].cmnd));\n\t\t\t\thostdata->saved_slot_position = j + 1;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n out_unlock:\n\tspin_unlock_irqrestore(host->host_lock, flags);\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic int NCR_700_queuecommand_lck(struct scsi_cmnd *SCp)\n{\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];\n\t__u32 move_ins;\n\tstruct NCR_700_command_slot *slot;\n\n\tif(hostdata->command_slot_count >= NCR_700_COMMAND_SLOTS_PER_HOST) {\n\t\t \n\t\tprintk(KERN_WARNING \"scsi%d: Command depth has gone over queue depth\\n\", SCp->device->host->host_no);\n\t\treturn 1;\n\t}\n\t \n\tif(NCR_700_get_depth(SCp->device) != 0\n\t   && (!(hostdata->tag_negotiated & (1<<scmd_id(SCp)))\n\t       || !(SCp->flags & SCMD_TAGGED))) {\n\t\tCDEBUG(KERN_ERR, SCp, \"has non zero depth %d\\n\",\n\t\t       NCR_700_get_depth(SCp->device));\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\tif(NCR_700_get_depth(SCp->device) >= SCp->device->queue_depth) {\n\t\tCDEBUG(KERN_ERR, SCp, \"has max tag depth %d\\n\",\n\t\t       NCR_700_get_depth(SCp->device));\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\tNCR_700_set_depth(SCp->device, NCR_700_get_depth(SCp->device) + 1);\n\n\t \n\t \n\tslot = find_empty_slot(hostdata);\n\n\tslot->cmnd = SCp;\n\n\tSCp->host_scribble = (unsigned char *)slot;\n\n#ifdef NCR_700_DEBUG\n\tprintk(\"53c700: scsi%d, command \", SCp->device->host->host_no);\n\tscsi_print_command(SCp);\n#endif\n\tif ((SCp->flags & SCMD_TAGGED)\n\t   && (hostdata->tag_negotiated &(1<<scmd_id(SCp))) == 0\n\t   && NCR_700_get_tag_neg_state(SCp->device) == NCR_700_START_TAG_NEGOTIATION) {\n\t\tscmd_printk(KERN_ERR, SCp, \"Enabling Tag Command Queuing\\n\");\n\t\thostdata->tag_negotiated |= (1<<scmd_id(SCp));\n\t\tNCR_700_set_tag_neg_state(SCp->device, NCR_700_DURING_TAG_NEGOTIATION);\n\t}\n\n\t \n\tif (!(SCp->flags & SCMD_TAGGED)\n\t   && (hostdata->tag_negotiated &(1<<scmd_id(SCp)))) {\n\t\tscmd_printk(KERN_INFO, SCp, \"Disabling Tag Command Queuing\\n\");\n\t\thostdata->tag_negotiated &= ~(1<<scmd_id(SCp));\n\t}\n\n\tif ((hostdata->tag_negotiated & (1<<scmd_id(SCp))) &&\n\t    SCp->device->simple_tags) {\n\t\tslot->tag = scsi_cmd_to_rq(SCp)->tag;\n\t\tCDEBUG(KERN_DEBUG, SCp, \"sending out tag %d, slot %p\\n\",\n\t\t       slot->tag, slot);\n\t} else {\n\t\tstruct NCR_700_Device_Parameters *p = SCp->device->hostdata;\n\n\t\tslot->tag = SCSI_NO_TAG;\n\t\t \n\t\tp->current_cmnd = SCp;\n\t}\n\t \n\tif(!scsi_sg_count(SCp) && !scsi_bufflen(SCp) &&\n\t   SCp->sc_data_direction != DMA_NONE) {\n#ifdef NCR_700_DEBUG\n\t\tprintk(\"53c700: Command\");\n\t\tscsi_print_command(SCp);\n\t\tprintk(\"Has wrong data direction %d\\n\", SCp->sc_data_direction);\n#endif\n\t\tSCp->sc_data_direction = DMA_NONE;\n\t}\n\n\tswitch (SCp->cmnd[0]) {\n\tcase REQUEST_SENSE:\n\t\t \n\t\tSCp->cmnd[6] = 0;\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tswitch(SCp->sc_data_direction) {\n\t\tcase DMA_BIDIRECTIONAL:\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"53c700: Unknown command for data direction \");\n\t\t\tscsi_print_command(SCp);\n\t\t\t\n\t\t\tmove_ins = 0;\n\t\t\tbreak;\n\t\tcase DMA_NONE:\n\t\t\tmove_ins = 0;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\t\tmove_ins = SCRIPT_MOVE_DATA_IN;\n\t\t\tbreak;\n\t\tcase DMA_TO_DEVICE:\n\t\t\tmove_ins = SCRIPT_MOVE_DATA_OUT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif(move_ins != 0) {\n\t\tint i;\n\t\tint sg_count;\n\t\tdma_addr_t vPtr = 0;\n\t\tstruct scatterlist *sg;\n\t\t__u32 count = 0;\n\n\t\tsg_count = scsi_dma_map(SCp);\n\t\tBUG_ON(sg_count < 0);\n\n\t\tscsi_for_each_sg(SCp, sg, sg_count, i) {\n\t\t\tvPtr = sg_dma_address(sg);\n\t\t\tcount = sg_dma_len(sg);\n\n\t\t\tslot->SG[i].ins = bS_to_host(move_ins | count);\n\t\t\tDEBUG((\" scatter block %d: move %d[%08x] from 0x%lx\\n\",\n\t\t\t       i, count, slot->SG[i].ins, (unsigned long)vPtr));\n\t\t\tslot->SG[i].pAddr = bS_to_host(vPtr);\n\t\t}\n\t\tslot->SG[i].ins = bS_to_host(SCRIPT_RETURN);\n\t\tslot->SG[i].pAddr = 0;\n\t\tdma_sync_to_dev(hostdata, slot->SG, sizeof(slot->SG));\n\t\tDEBUG((\" SETTING %p to %x\\n\",\n\t\t       (&slot->pSG[i].ins),\n\t\t       slot->SG[i].ins));\n\t}\n\tslot->resume_offset = 0;\n\tslot->pCmd = dma_map_single(hostdata->dev, SCp->cmnd,\n\t\t\t\t    MAX_COMMAND_SIZE, DMA_TO_DEVICE);\n\tNCR_700_start_command(SCp);\n\treturn 0;\n}\n\nSTATIC DEF_SCSI_QCMD(NCR_700_queuecommand)\n\nSTATIC int\nNCR_700_abort(struct scsi_cmnd * SCp)\n{\n\tstruct NCR_700_command_slot *slot;\n\n\tscmd_printk(KERN_INFO, SCp, \"abort command\\n\");\n\n\tslot = (struct NCR_700_command_slot *)SCp->host_scribble;\n\n\tif(slot == NULL)\n\t\t \n\t\treturn SUCCESS;\n\tif(SCp->cmnd[0] == TEST_UNIT_READY) {\n\t\t \n\t\tNCR_700_internal_bus_reset(SCp->device->host);\n\t\t \n\t}\n\treturn FAILED;\n\n}\n\nSTATIC int\nNCR_700_host_reset(struct scsi_cmnd * SCp)\n{\n\tDECLARE_COMPLETION_ONSTACK(complete);\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)SCp->device->host->hostdata[0];\n\n\tscmd_printk(KERN_INFO, SCp,\n\t\t\"New error handler wants HOST reset, cmd %p\\n\\t\", SCp);\n\tscsi_print_command(SCp);\n\n\t \n\tspin_lock_irq(SCp->device->host->host_lock);\n\twhile (hostdata->eh_complete != NULL) {\n\t\tspin_unlock_irq(SCp->device->host->host_lock);\n\t\tmsleep_interruptible(100);\n\t\tspin_lock_irq(SCp->device->host->host_lock);\n\t}\n\n\thostdata->eh_complete = &complete;\n\tNCR_700_internal_bus_reset(SCp->device->host);\n\tNCR_700_chip_reset(SCp->device->host);\n\n\tspin_unlock_irq(SCp->device->host->host_lock);\n\twait_for_completion(&complete);\n\tspin_lock_irq(SCp->device->host->host_lock);\n\n\thostdata->eh_complete = NULL;\n\t \n\tif(hostdata->fast)\n\t\tspi_schedule_dv_device(SCp->device);\n\n\tspin_unlock_irq(SCp->device->host->host_lock);\n\treturn SUCCESS;\n}\n\nSTATIC void\nNCR_700_set_period(struct scsi_target *STp, int period)\n{\n\tstruct Scsi_Host *SHp = dev_to_shost(STp->dev.parent);\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)SHp->hostdata[0];\n\t\n\tif(!hostdata->fast)\n\t\treturn;\n\n\tif(period < hostdata->min_period)\n\t\tperiod = hostdata->min_period;\n\n\tspi_period(STp) = period;\n\tspi_flags(STp) &= ~(NCR_700_DEV_NEGOTIATED_SYNC |\n\t\t\t    NCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\n\tspi_flags(STp) |= NCR_700_DEV_PRINT_SYNC_NEGOTIATION;\n}\n\nSTATIC void\nNCR_700_set_offset(struct scsi_target *STp, int offset)\n{\n\tstruct Scsi_Host *SHp = dev_to_shost(STp->dev.parent);\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)SHp->hostdata[0];\n\tint max_offset = hostdata->chip710\n\t\t? NCR_710_MAX_OFFSET : NCR_700_MAX_OFFSET;\n\t\n\tif(!hostdata->fast)\n\t\treturn;\n\n\tif(offset > max_offset)\n\t\toffset = max_offset;\n\n\t \n\tif(spi_offset(STp) == 0 && (spi_period(STp) < hostdata->min_period ||\n\t\t\t\t    spi_period(STp) > 0xff))\n\t\tspi_period(STp) = hostdata->min_period;\n\n\tspi_offset(STp) = offset;\n\tspi_flags(STp) &= ~(NCR_700_DEV_NEGOTIATED_SYNC |\n\t\t\t    NCR_700_DEV_BEGIN_SYNC_NEGOTIATION);\n\tspi_flags(STp) |= NCR_700_DEV_PRINT_SYNC_NEGOTIATION;\n}\n\nSTATIC int\nNCR_700_slave_alloc(struct scsi_device *SDp)\n{\n\tSDp->hostdata = kzalloc(sizeof(struct NCR_700_Device_Parameters),\n\t\t\t\tGFP_KERNEL);\n\n\tif (!SDp->hostdata)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nSTATIC int\nNCR_700_slave_configure(struct scsi_device *SDp)\n{\n\tstruct NCR_700_Host_Parameters *hostdata = \n\t\t(struct NCR_700_Host_Parameters *)SDp->host->hostdata[0];\n\n\t \n\tif(SDp->tagged_supported) {\n\t\tscsi_change_queue_depth(SDp, NCR_700_DEFAULT_TAGS);\n\t\tNCR_700_set_tag_neg_state(SDp, NCR_700_START_TAG_NEGOTIATION);\n\t}\n\n\tif(hostdata->fast) {\n\t\t \n\t\tif (!spi_initial_dv(SDp->sdev_target))\n\t\t\tspi_dv_device(SDp);\n\t} else {\n\t\tspi_offset(SDp->sdev_target) = 0;\n\t\tspi_period(SDp->sdev_target) = 0;\n\t}\n\treturn 0;\n}\n\nSTATIC void\nNCR_700_slave_destroy(struct scsi_device *SDp)\n{\n\tkfree(SDp->hostdata);\n\tSDp->hostdata = NULL;\n}\n\nstatic int\nNCR_700_change_queue_depth(struct scsi_device *SDp, int depth)\n{\n\tif (depth > NCR_700_MAX_TAGS)\n\t\tdepth = NCR_700_MAX_TAGS;\n\treturn scsi_change_queue_depth(SDp, depth);\n}\n\nstatic ssize_t\nNCR_700_show_active_tags(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *SDp = to_scsi_device(dev);\n\n\treturn snprintf(buf, 20, \"%d\\n\", NCR_700_get_depth(SDp));\n}\n\nstatic struct device_attribute NCR_700_active_tags_attr = {\n\t.attr = {\n\t\t.name =\t\t\"active_tags\",\n\t\t.mode =\t\tS_IRUGO,\n\t},\n\t.show = NCR_700_show_active_tags,\n};\n\nSTATIC struct attribute *NCR_700_dev_attrs[] = {\n\t&NCR_700_active_tags_attr.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(NCR_700_dev);\n\nEXPORT_SYMBOL(NCR_700_detect);\nEXPORT_SYMBOL(NCR_700_release);\nEXPORT_SYMBOL(NCR_700_intr);\n\nstatic struct spi_function_template NCR_700_transport_functions =  {\n\t.set_period\t= NCR_700_set_period,\n\t.show_period\t= 1,\n\t.set_offset\t= NCR_700_set_offset,\n\t.show_offset\t= 1,\n};\n\nstatic int __init NCR_700_init(void)\n{\n\tNCR_700_transport_template = spi_attach_transport(&NCR_700_transport_functions);\n\tif(!NCR_700_transport_template)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic void __exit NCR_700_exit(void)\n{\n\tspi_release_transport(NCR_700_transport_template);\n}\n\nmodule_init(NCR_700_init);\nmodule_exit(NCR_700_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}