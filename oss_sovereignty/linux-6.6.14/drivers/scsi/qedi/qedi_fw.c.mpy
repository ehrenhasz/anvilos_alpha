{
  "module_name": "qedi_fw.c",
  "hash_id": "8d3db224b5dcff66dcd92b9ad5b8c0e72de54cab8fbfb36685609f539f5e0a4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedi/qedi_fw.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <scsi/scsi_tcq.h>\n#include <linux/delay.h>\n\n#include \"qedi.h\"\n#include \"qedi_iscsi.h\"\n#include \"qedi_gbl.h\"\n#include \"qedi_fw_iscsi.h\"\n#include \"qedi_fw_scsi.h\"\n\nstatic int send_iscsi_tmf(struct qedi_conn *qedi_conn,\n\t\t\t  struct iscsi_task *mtask, struct iscsi_task *ctask);\n\nvoid qedi_iscsi_unmap_sg_list(struct qedi_cmd *cmd)\n{\n\tstruct scsi_cmnd *sc = cmd->scsi_cmd;\n\n\tif (cmd->io_tbl.sge_valid && sc) {\n\t\tcmd->io_tbl.sge_valid = 0;\n\t\tscsi_dma_unmap(sc);\n\t}\n}\n\nstatic void qedi_process_logout_resp(struct qedi_ctx *qedi,\n\t\t\t\t     union iscsi_cqe *cqe,\n\t\t\t\t     struct iscsi_task *task,\n\t\t\t\t     struct qedi_conn *qedi_conn)\n{\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_logout_rsp *resp_hdr;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_logout_response_hdr *cqe_logout_response;\n\tstruct qedi_cmd *cmd;\n\n\tcmd = (struct qedi_cmd *)task->dd_data;\n\tcqe_logout_response = &cqe->cqe_common.iscsi_hdr.logout_response;\n\tspin_lock(&session->back_lock);\n\tresp_hdr = (struct iscsi_logout_rsp *)&qedi_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr, 0, sizeof(struct iscsi_hdr));\n\tresp_hdr->opcode = cqe_logout_response->opcode;\n\tresp_hdr->flags = cqe_logout_response->flags;\n\tresp_hdr->hlength = 0;\n\n\tresp_hdr->itt = build_itt(cqe->cqe_solicited.itid, conn->session->age);\n\tresp_hdr->statsn = cpu_to_be32(cqe_logout_response->stat_sn);\n\tresp_hdr->exp_cmdsn = cpu_to_be32(cqe_logout_response->exp_cmd_sn);\n\tresp_hdr->max_cmdsn = cpu_to_be32(cqe_logout_response->max_cmd_sn);\n\n\tresp_hdr->t2wait = cpu_to_be32(cqe_logout_response->time_2_wait);\n\tresp_hdr->t2retain = cpu_to_be32(cqe_logout_response->time_2_retain);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_TID,\n\t\t  \"Freeing tid=0x%x for cid=0x%x\\n\",\n\t\t  cmd->task_id, qedi_conn->iscsi_conn_id);\n\n\tspin_lock(&qedi_conn->list_lock);\n\tif (likely(cmd->io_cmd_in_list)) {\n\t\tcmd->io_cmd_in_list = false;\n\t\tlist_del_init(&cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t} else {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"Active cmd list node already deleted, tid=0x%x, cid=0x%x, io_cmd_node=%p\\n\",\n\t\t\t  cmd->task_id, qedi_conn->iscsi_conn_id,\n\t\t\t  &cmd->io_cmd);\n\t}\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tcmd->state = RESPONSE_RECEIVED;\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr, NULL, 0);\n\n\tspin_unlock(&session->back_lock);\n}\n\nstatic void qedi_process_text_resp(struct qedi_ctx *qedi,\n\t\t\t\t   union iscsi_cqe *cqe,\n\t\t\t\t   struct iscsi_task *task,\n\t\t\t\t   struct qedi_conn *qedi_conn)\n{\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_task_context *task_ctx;\n\tstruct iscsi_text_rsp *resp_hdr_ptr;\n\tstruct iscsi_text_response_hdr *cqe_text_response;\n\tstruct qedi_cmd *cmd;\n\tint pld_len;\n\n\tcmd = (struct qedi_cmd *)task->dd_data;\n\ttask_ctx = qedi_get_task_mem(&qedi->tasks, cmd->task_id);\n\n\tcqe_text_response = &cqe->cqe_common.iscsi_hdr.text_response;\n\tspin_lock(&session->back_lock);\n\tresp_hdr_ptr =  (struct iscsi_text_rsp *)&qedi_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr_ptr, 0, sizeof(struct iscsi_hdr));\n\tresp_hdr_ptr->opcode = cqe_text_response->opcode;\n\tresp_hdr_ptr->flags = cqe_text_response->flags;\n\tresp_hdr_ptr->hlength = 0;\n\n\thton24(resp_hdr_ptr->dlength,\n\t       (cqe_text_response->hdr_second_dword &\n\t\tISCSI_TEXT_RESPONSE_HDR_DATA_SEG_LEN_MASK));\n\n\tresp_hdr_ptr->itt = build_itt(cqe->cqe_solicited.itid,\n\t\t\t\t      conn->session->age);\n\tresp_hdr_ptr->ttt = cqe_text_response->ttt;\n\tresp_hdr_ptr->statsn = cpu_to_be32(cqe_text_response->stat_sn);\n\tresp_hdr_ptr->exp_cmdsn = cpu_to_be32(cqe_text_response->exp_cmd_sn);\n\tresp_hdr_ptr->max_cmdsn = cpu_to_be32(cqe_text_response->max_cmd_sn);\n\n\tpld_len = cqe_text_response->hdr_second_dword &\n\t\t  ISCSI_TEXT_RESPONSE_HDR_DATA_SEG_LEN_MASK;\n\tqedi_conn->gen_pdu.resp_wr_ptr = qedi_conn->gen_pdu.resp_buf + pld_len;\n\n\tmemset(task_ctx, '\\0', sizeof(*task_ctx));\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_TID,\n\t\t  \"Freeing tid=0x%x for cid=0x%x\\n\",\n\t\t  cmd->task_id, qedi_conn->iscsi_conn_id);\n\n\tspin_lock(&qedi_conn->list_lock);\n\tif (likely(cmd->io_cmd_in_list)) {\n\t\tcmd->io_cmd_in_list = false;\n\t\tlist_del_init(&cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t} else {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"Active cmd list node already deleted, tid=0x%x, cid=0x%x, io_cmd_node=%p\\n\",\n\t\t\t  cmd->task_id, qedi_conn->iscsi_conn_id,\n\t\t\t  &cmd->io_cmd);\n\t}\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tcmd->state = RESPONSE_RECEIVED;\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr_ptr,\n\t\t\t     qedi_conn->gen_pdu.resp_buf,\n\t\t\t     (qedi_conn->gen_pdu.resp_wr_ptr -\n\t\t\t      qedi_conn->gen_pdu.resp_buf));\n\tspin_unlock(&session->back_lock);\n}\n\nstatic void qedi_tmf_resp_work(struct work_struct *work)\n{\n\tstruct qedi_cmd *qedi_cmd =\n\t\t\t\tcontainer_of(work, struct qedi_cmd, tmf_work);\n\tstruct qedi_conn *qedi_conn = qedi_cmd->conn;\n\tstruct qedi_ctx *qedi = qedi_conn->qedi;\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_tm_rsp *resp_hdr_ptr;\n\tint rval = 0;\n\n\tresp_hdr_ptr =  (struct iscsi_tm_rsp *)qedi_cmd->tmf_resp_buf;\n\n\trval = qedi_cleanup_all_io(qedi, qedi_conn, qedi_cmd->task, true);\n\tif (rval)\n\t\tgoto exit_tmf_resp;\n\n\tspin_lock(&session->back_lock);\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr_ptr, NULL, 0);\n\tspin_unlock(&session->back_lock);\n\nexit_tmf_resp:\n\tkfree(resp_hdr_ptr);\n\n\tspin_lock(&qedi_conn->tmf_work_lock);\n\tqedi_conn->fw_cleanup_works--;\n\tspin_unlock(&qedi_conn->tmf_work_lock);\n}\n\nstatic void qedi_process_tmf_resp(struct qedi_ctx *qedi,\n\t\t\t\t  union iscsi_cqe *cqe,\n\t\t\t\t  struct iscsi_task *task,\n\t\t\t\t  struct qedi_conn *qedi_conn)\n\n{\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_tmf_response_hdr *cqe_tmp_response;\n\tstruct iscsi_tm_rsp *resp_hdr_ptr;\n\tstruct iscsi_tm *tmf_hdr;\n\tstruct qedi_cmd *qedi_cmd = NULL;\n\n\tcqe_tmp_response = &cqe->cqe_common.iscsi_hdr.tmf_response;\n\n\tqedi_cmd = task->dd_data;\n\tqedi_cmd->tmf_resp_buf = kzalloc(sizeof(*resp_hdr_ptr), GFP_ATOMIC);\n\tif (!qedi_cmd->tmf_resp_buf) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Failed to allocate resp buf, cid=0x%x\\n\",\n\t\t\t  qedi_conn->iscsi_conn_id);\n\t\treturn;\n\t}\n\n\tspin_lock(&session->back_lock);\n\tresp_hdr_ptr =  (struct iscsi_tm_rsp *)qedi_cmd->tmf_resp_buf;\n\tmemset(resp_hdr_ptr, 0, sizeof(struct iscsi_tm_rsp));\n\n\t \n\tresp_hdr_ptr->opcode = cqe_tmp_response->opcode;\n\tresp_hdr_ptr->flags = cqe_tmp_response->hdr_flags;\n\tresp_hdr_ptr->response = cqe_tmp_response->hdr_response;\n\tresp_hdr_ptr->hlength = 0;\n\n\thton24(resp_hdr_ptr->dlength,\n\t       (cqe_tmp_response->hdr_second_dword &\n\t\tISCSI_TMF_RESPONSE_HDR_DATA_SEG_LEN_MASK));\n\tresp_hdr_ptr->itt = build_itt(cqe->cqe_solicited.itid,\n\t\t\t\t      conn->session->age);\n\tresp_hdr_ptr->statsn = cpu_to_be32(cqe_tmp_response->stat_sn);\n\tresp_hdr_ptr->exp_cmdsn  = cpu_to_be32(cqe_tmp_response->exp_cmd_sn);\n\tresp_hdr_ptr->max_cmdsn = cpu_to_be32(cqe_tmp_response->max_cmd_sn);\n\n\ttmf_hdr = (struct iscsi_tm *)qedi_cmd->task->hdr;\n\n\tspin_lock(&qedi_conn->list_lock);\n\tif (likely(qedi_cmd->io_cmd_in_list)) {\n\t\tqedi_cmd->io_cmd_in_list = false;\n\t\tlist_del_init(&qedi_cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t}\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tspin_lock(&qedi_conn->tmf_work_lock);\n\tswitch (tmf_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK) {\n\tcase ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:\n\tcase ISCSI_TM_FUNC_TARGET_WARM_RESET:\n\tcase ISCSI_TM_FUNC_TARGET_COLD_RESET:\n\t\tif (qedi_conn->ep_disconnect_starting) {\n\t\t\t \n\t\t\tspin_unlock(&qedi_conn->tmf_work_lock);\n\t\t\tgoto unblock_sess;\n\t\t}\n\n\t\tqedi_conn->fw_cleanup_works++;\n\t\tspin_unlock(&qedi_conn->tmf_work_lock);\n\n\t\tINIT_WORK(&qedi_cmd->tmf_work, qedi_tmf_resp_work);\n\t\tqueue_work(qedi->tmf_thread, &qedi_cmd->tmf_work);\n\t\tgoto unblock_sess;\n\t}\n\tspin_unlock(&qedi_conn->tmf_work_lock);\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr_ptr, NULL, 0);\n\tkfree(resp_hdr_ptr);\n\nunblock_sess:\n\tspin_unlock(&session->back_lock);\n}\n\nstatic void qedi_process_login_resp(struct qedi_ctx *qedi,\n\t\t\t\t    union iscsi_cqe *cqe,\n\t\t\t\t    struct iscsi_task *task,\n\t\t\t\t    struct qedi_conn *qedi_conn)\n{\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_task_context *task_ctx;\n\tstruct iscsi_login_rsp *resp_hdr_ptr;\n\tstruct iscsi_login_response_hdr *cqe_login_response;\n\tstruct qedi_cmd *cmd;\n\tint pld_len;\n\n\tcmd = (struct qedi_cmd *)task->dd_data;\n\n\tcqe_login_response = &cqe->cqe_common.iscsi_hdr.login_response;\n\ttask_ctx = qedi_get_task_mem(&qedi->tasks, cmd->task_id);\n\n\tspin_lock(&session->back_lock);\n\tresp_hdr_ptr =  (struct iscsi_login_rsp *)&qedi_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr_ptr, 0, sizeof(struct iscsi_login_rsp));\n\tresp_hdr_ptr->opcode = cqe_login_response->opcode;\n\tresp_hdr_ptr->flags = cqe_login_response->flags_attr;\n\tresp_hdr_ptr->hlength = 0;\n\n\thton24(resp_hdr_ptr->dlength,\n\t       (cqe_login_response->hdr_second_dword &\n\t\tISCSI_LOGIN_RESPONSE_HDR_DATA_SEG_LEN_MASK));\n\tresp_hdr_ptr->itt = build_itt(cqe->cqe_solicited.itid,\n\t\t\t\t      conn->session->age);\n\tresp_hdr_ptr->tsih = cqe_login_response->tsih;\n\tresp_hdr_ptr->statsn = cpu_to_be32(cqe_login_response->stat_sn);\n\tresp_hdr_ptr->exp_cmdsn = cpu_to_be32(cqe_login_response->exp_cmd_sn);\n\tresp_hdr_ptr->max_cmdsn = cpu_to_be32(cqe_login_response->max_cmd_sn);\n\tresp_hdr_ptr->status_class = cqe_login_response->status_class;\n\tresp_hdr_ptr->status_detail = cqe_login_response->status_detail;\n\tpld_len = cqe_login_response->hdr_second_dword &\n\t\t  ISCSI_LOGIN_RESPONSE_HDR_DATA_SEG_LEN_MASK;\n\tqedi_conn->gen_pdu.resp_wr_ptr = qedi_conn->gen_pdu.resp_buf + pld_len;\n\n\tspin_lock(&qedi_conn->list_lock);\n\tif (likely(cmd->io_cmd_in_list)) {\n\t\tcmd->io_cmd_in_list = false;\n\t\tlist_del_init(&cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t}\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tmemset(task_ctx, '\\0', sizeof(*task_ctx));\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr_ptr,\n\t\t\t     qedi_conn->gen_pdu.resp_buf,\n\t\t\t     (qedi_conn->gen_pdu.resp_wr_ptr -\n\t\t\t     qedi_conn->gen_pdu.resp_buf));\n\n\tspin_unlock(&session->back_lock);\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_TID,\n\t\t  \"Freeing tid=0x%x for cid=0x%x\\n\",\n\t\t  cmd->task_id, qedi_conn->iscsi_conn_id);\n\tcmd->state = RESPONSE_RECEIVED;\n}\n\nstatic void qedi_get_rq_bdq_buf(struct qedi_ctx *qedi,\n\t\t\t\tstruct iscsi_cqe_unsolicited *cqe,\n\t\t\t\tchar *ptr, int len)\n{\n\tu16 idx = 0;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t  \"pld_len [%d], bdq_prod_idx [%d], idx [%d]\\n\",\n\t\t  len, qedi->bdq_prod_idx,\n\t\t  (qedi->bdq_prod_idx % qedi->rq_num_entries));\n\n\t \n\tidx = cqe->rqe_opaque;\n\tif (idx > (QEDI_BDQ_NUM - 1)) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"wrong idx %d returned by FW, dropping the unsolicited pkt\\n\",\n\t\t\t  idx);\n\t\treturn;\n\t}\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t  \"rqe_opaque [0x%p], idx [%d]\\n\", cqe->rqe_opaque, idx);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t  \"unsol_cqe_type = %d\\n\", cqe->unsol_cqe_type);\n\tswitch (cqe->unsol_cqe_type) {\n\tcase ISCSI_CQE_UNSOLICITED_SINGLE:\n\tcase ISCSI_CQE_UNSOLICITED_FIRST:\n\t\tif (len)\n\t\t\tmemcpy(ptr, (void *)qedi->bdq[idx].buf_addr, len);\n\t\tbreak;\n\tcase ISCSI_CQE_UNSOLICITED_MIDDLE:\n\tcase ISCSI_CQE_UNSOLICITED_LAST:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void qedi_put_rq_bdq_buf(struct qedi_ctx *qedi,\n\t\t\t\tstruct iscsi_cqe_unsolicited *cqe,\n\t\t\t\tint count)\n{\n\tu16 idx = 0;\n\tstruct scsi_bd *pbl;\n\n\t \n\tidx = cqe->rqe_opaque;\n\tif (idx > (QEDI_BDQ_NUM - 1)) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"wrong idx %d returned by FW, dropping the unsolicited pkt\\n\",\n\t\t\t  idx);\n\t\treturn;\n\t}\n\n\tpbl = (struct scsi_bd *)qedi->bdq_pbl;\n\tpbl += (qedi->bdq_prod_idx % qedi->rq_num_entries);\n\tpbl->address.hi = cpu_to_le32(QEDI_U64_HI(qedi->bdq[idx].buf_dma));\n\tpbl->address.lo = cpu_to_le32(QEDI_U64_LO(qedi->bdq[idx].buf_dma));\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t  \"pbl [0x%p] pbl->address hi [0x%llx] lo [0x%llx] idx [%d]\\n\",\n\t\t  pbl, pbl->address.hi, pbl->address.lo, idx);\n\tpbl->opaque.iscsi_opaque.reserved_zero[0] = 0;\n\tpbl->opaque.iscsi_opaque.reserved_zero[1] = 0;\n\tpbl->opaque.iscsi_opaque.reserved_zero[2] = 0;\n\tpbl->opaque.iscsi_opaque.opaque = cpu_to_le32(idx);\n\n\t \n\tqedi->bdq_prod_idx += count;\n\n\twritew(qedi->bdq_prod_idx, qedi->bdq_primary_prod);\n\treadw(qedi->bdq_primary_prod);\n\n\twritew(qedi->bdq_prod_idx, qedi->bdq_secondary_prod);\n\treadw(qedi->bdq_secondary_prod);\n}\n\nstatic void qedi_unsol_pdu_adjust_bdq(struct qedi_ctx *qedi,\n\t\t\t\t      struct iscsi_cqe_unsolicited *cqe,\n\t\t\t\t      u32 pdu_len, u32 num_bdqs,\n\t\t\t\t      char *bdq_data)\n{\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t  \"num_bdqs [%d]\\n\", num_bdqs);\n\n\tqedi_get_rq_bdq_buf(qedi, cqe, bdq_data, pdu_len);\n\tqedi_put_rq_bdq_buf(qedi, cqe, (num_bdqs + 1));\n}\n\nstatic int qedi_process_nopin_mesg(struct qedi_ctx *qedi,\n\t\t\t\t   union iscsi_cqe *cqe,\n\t\t\t\t   struct iscsi_task *task,\n\t\t\t\t   struct qedi_conn *qedi_conn, u16 que_idx)\n{\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_nop_in_hdr *cqe_nop_in;\n\tstruct iscsi_nopin *hdr;\n\tstruct qedi_cmd *cmd;\n\tint tgt_async_nop = 0;\n\tu32 lun[2];\n\tu32 pdu_len, num_bdqs;\n\tchar bdq_data[QEDI_BDQ_BUF_SIZE];\n\tunsigned long flags;\n\n\tspin_lock_bh(&session->back_lock);\n\tcqe_nop_in = &cqe->cqe_common.iscsi_hdr.nop_in;\n\n\tpdu_len = cqe_nop_in->hdr_second_dword &\n\t\t  ISCSI_NOP_IN_HDR_DATA_SEG_LEN_MASK;\n\tnum_bdqs = pdu_len / QEDI_BDQ_BUF_SIZE;\n\n\thdr = (struct iscsi_nopin *)&qedi_conn->gen_pdu.resp_hdr;\n\tmemset(hdr, 0, sizeof(struct iscsi_hdr));\n\thdr->opcode = cqe_nop_in->opcode;\n\thdr->max_cmdsn = cpu_to_be32(cqe_nop_in->max_cmd_sn);\n\thdr->exp_cmdsn = cpu_to_be32(cqe_nop_in->exp_cmd_sn);\n\thdr->statsn = cpu_to_be32(cqe_nop_in->stat_sn);\n\thdr->ttt = cpu_to_be32(cqe_nop_in->ttt);\n\n\tif (cqe->cqe_common.cqe_type == ISCSI_CQE_TYPE_UNSOLICITED) {\n\t\tspin_lock_irqsave(&qedi->hba_lock, flags);\n\t\tqedi_unsol_pdu_adjust_bdq(qedi, &cqe->cqe_unsolicited,\n\t\t\t\t\t  pdu_len, num_bdqs, bdq_data);\n\t\thdr->itt = RESERVED_ITT;\n\t\ttgt_async_nop = 1;\n\t\tspin_unlock_irqrestore(&qedi->hba_lock, flags);\n\t\tgoto done;\n\t}\n\n\t \n\tif (task) {\n\t\tcmd = task->dd_data;\n\t\thdr->flags = ISCSI_FLAG_CMD_FINAL;\n\t\thdr->itt = build_itt(cqe->cqe_solicited.itid,\n\t\t\t\t     conn->session->age);\n\t\tlun[0] = 0xffffffff;\n\t\tlun[1] = 0xffffffff;\n\t\tmemcpy(&hdr->lun, lun, sizeof(struct scsi_lun));\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_TID,\n\t\t\t  \"Freeing tid=0x%x for cid=0x%x\\n\",\n\t\t\t  cmd->task_id, qedi_conn->iscsi_conn_id);\n\t\tcmd->state = RESPONSE_RECEIVED;\n\t\tspin_lock(&qedi_conn->list_lock);\n\t\tif (likely(cmd->io_cmd_in_list)) {\n\t\t\tcmd->io_cmd_in_list = false;\n\t\t\tlist_del_init(&cmd->io_cmd);\n\t\t\tqedi_conn->active_cmd_count--;\n\t\t}\n\n\t\tspin_unlock(&qedi_conn->list_lock);\n\t}\n\ndone:\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, bdq_data, pdu_len);\n\n\tspin_unlock_bh(&session->back_lock);\n\treturn tgt_async_nop;\n}\n\nstatic void qedi_process_async_mesg(struct qedi_ctx *qedi,\n\t\t\t\t    union iscsi_cqe *cqe,\n\t\t\t\t    struct iscsi_task *task,\n\t\t\t\t    struct qedi_conn *qedi_conn,\n\t\t\t\t    u16 que_idx)\n{\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_async_msg_hdr *cqe_async_msg;\n\tstruct iscsi_async *resp_hdr;\n\tu32 lun[2];\n\tu32 pdu_len, num_bdqs;\n\tchar bdq_data[QEDI_BDQ_BUF_SIZE];\n\tunsigned long flags;\n\n\tspin_lock_bh(&session->back_lock);\n\n\tcqe_async_msg = &cqe->cqe_common.iscsi_hdr.async_msg;\n\tpdu_len = cqe_async_msg->hdr_second_dword &\n\t\tISCSI_ASYNC_MSG_HDR_DATA_SEG_LEN_MASK;\n\tnum_bdqs = pdu_len / QEDI_BDQ_BUF_SIZE;\n\n\tif (cqe->cqe_common.cqe_type == ISCSI_CQE_TYPE_UNSOLICITED) {\n\t\tspin_lock_irqsave(&qedi->hba_lock, flags);\n\t\tqedi_unsol_pdu_adjust_bdq(qedi, &cqe->cqe_unsolicited,\n\t\t\t\t\t  pdu_len, num_bdqs, bdq_data);\n\t\tspin_unlock_irqrestore(&qedi->hba_lock, flags);\n\t}\n\n\tresp_hdr = (struct iscsi_async *)&qedi_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr, 0, sizeof(struct iscsi_hdr));\n\tresp_hdr->opcode = cqe_async_msg->opcode;\n\tresp_hdr->flags = 0x80;\n\n\tlun[0] = cpu_to_be32(cqe_async_msg->lun.lo);\n\tlun[1] = cpu_to_be32(cqe_async_msg->lun.hi);\n\tmemcpy(&resp_hdr->lun, lun, sizeof(struct scsi_lun));\n\tresp_hdr->exp_cmdsn = cpu_to_be32(cqe_async_msg->exp_cmd_sn);\n\tresp_hdr->max_cmdsn = cpu_to_be32(cqe_async_msg->max_cmd_sn);\n\tresp_hdr->statsn = cpu_to_be32(cqe_async_msg->stat_sn);\n\n\tresp_hdr->async_event = cqe_async_msg->async_event;\n\tresp_hdr->async_vcode = cqe_async_msg->async_vcode;\n\n\tresp_hdr->param1 = cpu_to_be16(cqe_async_msg->param1_rsrv);\n\tresp_hdr->param2 = cpu_to_be16(cqe_async_msg->param2_rsrv);\n\tresp_hdr->param3 = cpu_to_be16(cqe_async_msg->param3_rsrv);\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr, bdq_data,\n\t\t\t     pdu_len);\n\n\tspin_unlock_bh(&session->back_lock);\n}\n\nstatic void qedi_process_reject_mesg(struct qedi_ctx *qedi,\n\t\t\t\t     union iscsi_cqe *cqe,\n\t\t\t\t     struct iscsi_task *task,\n\t\t\t\t     struct qedi_conn *qedi_conn,\n\t\t\t\t     uint16_t que_idx)\n{\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_reject_hdr *cqe_reject;\n\tstruct iscsi_reject *hdr;\n\tu32 pld_len, num_bdqs;\n\tunsigned long flags;\n\n\tspin_lock_bh(&session->back_lock);\n\tcqe_reject = &cqe->cqe_common.iscsi_hdr.reject;\n\tpld_len = cqe_reject->hdr_second_dword &\n\t\t  ISCSI_REJECT_HDR_DATA_SEG_LEN_MASK;\n\tnum_bdqs = pld_len / QEDI_BDQ_BUF_SIZE;\n\n\tif (cqe->cqe_common.cqe_type == ISCSI_CQE_TYPE_UNSOLICITED) {\n\t\tspin_lock_irqsave(&qedi->hba_lock, flags);\n\t\tqedi_unsol_pdu_adjust_bdq(qedi, &cqe->cqe_unsolicited,\n\t\t\t\t\t  pld_len, num_bdqs, conn->data);\n\t\tspin_unlock_irqrestore(&qedi->hba_lock, flags);\n\t}\n\thdr = (struct iscsi_reject *)&qedi_conn->gen_pdu.resp_hdr;\n\tmemset(hdr, 0, sizeof(struct iscsi_hdr));\n\thdr->opcode = cqe_reject->opcode;\n\thdr->reason = cqe_reject->hdr_reason;\n\thdr->flags = cqe_reject->hdr_flags;\n\thton24(hdr->dlength, (cqe_reject->hdr_second_dword &\n\t\t\t      ISCSI_REJECT_HDR_DATA_SEG_LEN_MASK));\n\thdr->max_cmdsn = cpu_to_be32(cqe_reject->max_cmd_sn);\n\thdr->exp_cmdsn = cpu_to_be32(cqe_reject->exp_cmd_sn);\n\thdr->statsn = cpu_to_be32(cqe_reject->stat_sn);\n\thdr->ffffffff = cpu_to_be32(0xffffffff);\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr,\n\t\t\t     conn->data, pld_len);\n\tspin_unlock_bh(&session->back_lock);\n}\n\nstatic void qedi_scsi_completion(struct qedi_ctx *qedi,\n\t\t\t\t union iscsi_cqe *cqe,\n\t\t\t\t struct iscsi_task *task,\n\t\t\t\t struct iscsi_conn *conn)\n{\n\tstruct scsi_cmnd *sc_cmd;\n\tstruct qedi_cmd *cmd = task->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct iscsi_scsi_rsp *hdr;\n\tstruct iscsi_data_in_hdr *cqe_data_in;\n\tint datalen = 0;\n\tstruct qedi_conn *qedi_conn;\n\tu32 iscsi_cid;\n\tu8 cqe_err_bits = 0;\n\n\tiscsi_cid  = cqe->cqe_common.conn_id;\n\tqedi_conn = qedi->cid_que.conn_cid_tbl[iscsi_cid];\n\n\tcqe_data_in = &cqe->cqe_common.iscsi_hdr.data_in;\n\tcqe_err_bits =\n\t\tcqe->cqe_common.error_bitmap.error_bits.cqe_error_status_bits;\n\n\tspin_lock_bh(&session->back_lock);\n\t \n\tsc_cmd = cmd->scsi_cmd;\n\n\tif (!sc_cmd) {\n\t\tQEDI_WARN(&qedi->dbg_ctx, \"sc_cmd is NULL!\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!iscsi_cmd(sc_cmd)->task) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"NULL task pointer, returned in another context.\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!scsi_cmd_to_rq(sc_cmd)->q) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"request->q is NULL so request is not valid, sc_cmd=%p.\\n\",\n\t\t\t  sc_cmd);\n\t\tgoto error;\n\t}\n\n\tqedi_iscsi_unmap_sg_list(cmd);\n\n\thdr = (struct iscsi_scsi_rsp *)task->hdr;\n\thdr->opcode = cqe_data_in->opcode;\n\thdr->max_cmdsn = cpu_to_be32(cqe_data_in->max_cmd_sn);\n\thdr->exp_cmdsn = cpu_to_be32(cqe_data_in->exp_cmd_sn);\n\thdr->itt = build_itt(cqe->cqe_solicited.itid, conn->session->age);\n\thdr->response = cqe_data_in->reserved1;\n\thdr->cmd_status = cqe_data_in->status_rsvd;\n\thdr->flags = cqe_data_in->flags;\n\thdr->residual_count = cpu_to_be32(cqe_data_in->residual_count);\n\n\tif (hdr->cmd_status == SAM_STAT_CHECK_CONDITION) {\n\t\tdatalen = cqe_data_in->reserved2 &\n\t\t\t  ISCSI_COMMON_HDR_DATA_SEG_LEN_MASK;\n\t\tmemcpy((char *)conn->data, (char *)cmd->sense_buffer, datalen);\n\t}\n\n\t \n\tif (unlikely(cqe_err_bits &&\n\t\t     GET_FIELD(cqe_err_bits, CQE_ERROR_BITMAP_UNDER_RUN_ERR))) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"Under flow itt=0x%x proto flags=0x%x tid=0x%x cid 0x%x fw resid 0x%x sc dlen 0x%x\\n\",\n\t\t\t  hdr->itt, cqe_data_in->flags, cmd->task_id,\n\t\t\t  qedi_conn->iscsi_conn_id, hdr->residual_count,\n\t\t\t  scsi_bufflen(sc_cmd));\n\t\thdr->residual_count = cpu_to_be32(scsi_bufflen(sc_cmd));\n\t\thdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;\n\t\thdr->flags &= (~ISCSI_FLAG_CMD_OVERFLOW);\n\t}\n\n\tspin_lock(&qedi_conn->list_lock);\n\tif (likely(cmd->io_cmd_in_list)) {\n\t\tcmd->io_cmd_in_list = false;\n\t\tlist_del_init(&cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t}\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_TID,\n\t\t  \"Freeing tid=0x%x for cid=0x%x\\n\",\n\t\t  cmd->task_id, qedi_conn->iscsi_conn_id);\n\tcmd->state = RESPONSE_RECEIVED;\n\tif (qedi_io_tracing)\n\t\tqedi_trace_io(qedi, task, cmd->task_id, QEDI_IO_TRACE_RSP);\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr,\n\t\t\t     conn->data, datalen);\nerror:\n\tspin_unlock_bh(&session->back_lock);\n}\n\nstatic void qedi_mtask_completion(struct qedi_ctx *qedi,\n\t\t\t\t  union iscsi_cqe *cqe,\n\t\t\t\t  struct iscsi_task *task,\n\t\t\t\t  struct qedi_conn *conn, uint16_t que_idx)\n{\n\tstruct iscsi_conn *iscsi_conn;\n\tu32 hdr_opcode;\n\n\thdr_opcode = cqe->cqe_common.iscsi_hdr.common.hdr_first_byte;\n\tiscsi_conn = conn->cls_conn->dd_data;\n\n\tswitch (hdr_opcode) {\n\tcase ISCSI_OPCODE_SCSI_RESPONSE:\n\tcase ISCSI_OPCODE_DATA_IN:\n\t\tqedi_scsi_completion(qedi, cqe, task, iscsi_conn);\n\t\tbreak;\n\tcase ISCSI_OPCODE_LOGIN_RESPONSE:\n\t\tqedi_process_login_resp(qedi, cqe, task, conn);\n\t\tbreak;\n\tcase ISCSI_OPCODE_TMF_RESPONSE:\n\t\tqedi_process_tmf_resp(qedi, cqe, task, conn);\n\t\tbreak;\n\tcase ISCSI_OPCODE_TEXT_RESPONSE:\n\t\tqedi_process_text_resp(qedi, cqe, task, conn);\n\t\tbreak;\n\tcase ISCSI_OPCODE_LOGOUT_RESPONSE:\n\t\tqedi_process_logout_resp(qedi, cqe, task, conn);\n\t\tbreak;\n\tcase ISCSI_OPCODE_NOP_IN:\n\t\tqedi_process_nopin_mesg(qedi, cqe, task, conn, que_idx);\n\t\tbreak;\n\tdefault:\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"unknown opcode\\n\");\n\t}\n}\n\nstatic void qedi_process_nopin_local_cmpl(struct qedi_ctx *qedi,\n\t\t\t\t\t  struct iscsi_cqe_solicited *cqe,\n\t\t\t\t\t  struct iscsi_task *task,\n\t\t\t\t\t  struct qedi_conn *qedi_conn)\n{\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct qedi_cmd *cmd = task->dd_data;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_UNSOL,\n\t\t  \"itid=0x%x, cmd task id=0x%x\\n\",\n\t\t  cqe->itid, cmd->task_id);\n\n\tcmd->state = RESPONSE_RECEIVED;\n\n\tspin_lock_bh(&session->back_lock);\n\t__iscsi_put_task(task);\n\tspin_unlock_bh(&session->back_lock);\n}\n\nstatic void qedi_process_cmd_cleanup_resp(struct qedi_ctx *qedi,\n\t\t\t\t\t  struct iscsi_cqe_solicited *cqe,\n\t\t\t\t\t  struct iscsi_conn *conn)\n{\n\tstruct qedi_work_map *work, *work_tmp;\n\tu32 proto_itt = cqe->itid;\n\tint found = 0;\n\tstruct qedi_cmd *qedi_cmd = NULL;\n\tu32 iscsi_cid;\n\tstruct qedi_conn *qedi_conn;\n\tstruct qedi_cmd *dbg_cmd;\n\tstruct iscsi_task *mtask, *task;\n\tstruct iscsi_tm *tmf_hdr = NULL;\n\n\tiscsi_cid = cqe->conn_id;\n\tqedi_conn = qedi->cid_que.conn_cid_tbl[iscsi_cid];\n\tif (!qedi_conn) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"icid not found 0x%x\\n\", cqe->conn_id);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_bh(&qedi_conn->tmf_work_lock);\n\tlist_for_each_entry_safe(work, work_tmp, &qedi_conn->tmf_work_list,\n\t\t\t\t list) {\n\t\tif (work->rtid == proto_itt) {\n\t\t\t \n\t\t\tqedi_cmd = work->qedi_cmd;\n\t\t\tif (!qedi_cmd->list_tmf_work) {\n\t\t\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t\t\t\t  \"TMF work not found, cqe->tid=0x%x, cid=0x%x\\n\",\n\t\t\t\t\t  proto_itt, qedi_conn->iscsi_conn_id);\n\t\t\t\tWARN_ON(1);\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tmtask = qedi_cmd->task;\n\t\t\ttask = work->ctask;\n\t\t\ttmf_hdr = (struct iscsi_tm *)mtask->hdr;\n\n\t\t\tlist_del_init(&work->list);\n\t\t\tkfree(work);\n\t\t\tqedi_cmd->list_tmf_work = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&qedi_conn->tmf_work_lock);\n\n\tif (!found)\n\t\tgoto check_cleanup_reqs;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t  \"TMF work, cqe->tid=0x%x, tmf flags=0x%x, cid=0x%x\\n\",\n\t\t  proto_itt, tmf_hdr->flags, qedi_conn->iscsi_conn_id);\n\n\tspin_lock_bh(&conn->session->back_lock);\n\tif (iscsi_task_is_completed(task)) {\n\t\tQEDI_NOTICE(&qedi->dbg_ctx,\n\t\t\t    \"IO task completed, tmf rtt=0x%x, cid=0x%x\\n\",\n\t\t\t   get_itt(tmf_hdr->rtt), qedi_conn->iscsi_conn_id);\n\t\tgoto unlock;\n\t}\n\n\tdbg_cmd = task->dd_data;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t  \"Abort tmf rtt=0x%x, i/o itt=0x%x, i/o tid=0x%x, cid=0x%x\\n\",\n\t\t  get_itt(tmf_hdr->rtt), get_itt(task->itt), dbg_cmd->task_id,\n\t\t  qedi_conn->iscsi_conn_id);\n\n\tspin_lock(&qedi_conn->list_lock);\n\tif (likely(dbg_cmd->io_cmd_in_list)) {\n\t\tdbg_cmd->io_cmd_in_list = false;\n\t\tlist_del_init(&dbg_cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t}\n\tspin_unlock(&qedi_conn->list_lock);\n\tqedi_cmd->state = CLEANUP_RECV;\nunlock:\n\tspin_unlock_bh(&conn->session->back_lock);\n\twake_up_interruptible(&qedi_conn->wait_queue);\n\treturn;\n\ncheck_cleanup_reqs:\n\tif (atomic_inc_return(&qedi_conn->cmd_cleanup_cmpl) ==\n\t    qedi_conn->cmd_cleanup_req) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t\t  \"Freeing tid=0x%x for cid=0x%x\\n\",\n\t\t\t  cqe->itid, qedi_conn->iscsi_conn_id);\n\t\twake_up(&qedi_conn->wait_queue);\n\t}\n}\n\nvoid qedi_fp_process_cqes(struct qedi_work *work)\n{\n\tstruct qedi_ctx *qedi = work->qedi;\n\tunion iscsi_cqe *cqe = &work->cqe;\n\tstruct iscsi_task *task = NULL;\n\tstruct iscsi_nopout *nopout_hdr;\n\tstruct qedi_conn *q_conn;\n\tstruct iscsi_conn *conn;\n\tstruct qedi_cmd *qedi_cmd;\n\tu32 comp_type;\n\tu32 iscsi_cid;\n\tu32 hdr_opcode;\n\tu16 que_idx = work->que_idx;\n\tu8 cqe_err_bits = 0;\n\n\tcomp_type = cqe->cqe_common.cqe_type;\n\thdr_opcode = cqe->cqe_common.iscsi_hdr.common.hdr_first_byte;\n\tcqe_err_bits =\n\t\tcqe->cqe_common.error_bitmap.error_bits.cqe_error_status_bits;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t  \"fw_cid=0x%x, cqe type=0x%x, opcode=0x%x\\n\",\n\t\t  cqe->cqe_common.conn_id, comp_type, hdr_opcode);\n\n\tif (comp_type >= MAX_ISCSI_CQES_TYPE) {\n\t\tQEDI_WARN(&qedi->dbg_ctx, \"Invalid CqE type\\n\");\n\t\treturn;\n\t}\n\n\tiscsi_cid  = cqe->cqe_common.conn_id;\n\tq_conn = qedi->cid_que.conn_cid_tbl[iscsi_cid];\n\tif (!q_conn) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"Session no longer exists for cid=0x%x!!\\n\",\n\t\t\t  iscsi_cid);\n\t\treturn;\n\t}\n\n\tconn = q_conn->cls_conn->dd_data;\n\n\tif (unlikely(cqe_err_bits &&\n\t\t     GET_FIELD(cqe_err_bits,\n\t\t\t       CQE_ERROR_BITMAP_DATA_DIGEST_ERR))) {\n\t\tiscsi_conn_failure(conn, ISCSI_ERR_DATA_DGST);\n\t\treturn;\n\t}\n\n\tswitch (comp_type) {\n\tcase ISCSI_CQE_TYPE_SOLICITED:\n\tcase ISCSI_CQE_TYPE_SOLICITED_WITH_SENSE:\n\t\tqedi_cmd = container_of(work, struct qedi_cmd, cqe_work);\n\t\ttask = qedi_cmd->task;\n\t\tif (!task) {\n\t\t\tQEDI_WARN(&qedi->dbg_ctx, \"task is NULL\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tnopout_hdr = (struct iscsi_nopout *)task->hdr;\n\t\tif ((nopout_hdr->itt == RESERVED_ITT) &&\n\t\t    (cqe->cqe_solicited.itid != (u16)RESERVED_ITT)) {\n\t\t\tqedi_process_nopin_local_cmpl(qedi, &cqe->cqe_solicited,\n\t\t\t\t\t\t      task, q_conn);\n\t\t} else {\n\t\t\tcqe->cqe_solicited.itid =\n\t\t\t\t\t       qedi_get_itt(cqe->cqe_solicited);\n\t\t\t \n\t\t\tqedi_mtask_completion(qedi, cqe, task, q_conn, que_idx);\n\t\t}\n\t\tbreak;\n\tcase ISCSI_CQE_TYPE_UNSOLICITED:\n\t\tswitch (hdr_opcode) {\n\t\tcase ISCSI_OPCODE_NOP_IN:\n\t\t\tqedi_process_nopin_mesg(qedi, cqe, task, q_conn,\n\t\t\t\t\t\tque_idx);\n\t\t\tbreak;\n\t\tcase ISCSI_OPCODE_ASYNC_MSG:\n\t\t\tqedi_process_async_mesg(qedi, cqe, task, q_conn,\n\t\t\t\t\t\tque_idx);\n\t\t\tbreak;\n\t\tcase ISCSI_OPCODE_REJECT:\n\t\t\tqedi_process_reject_mesg(qedi, cqe, task, q_conn,\n\t\t\t\t\t\t que_idx);\n\t\t\tbreak;\n\t\t}\n\t\tgoto exit_fp_process;\n\tcase ISCSI_CQE_TYPE_DUMMY:\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM, \"Dummy CqE\\n\");\n\t\tgoto exit_fp_process;\n\tcase ISCSI_CQE_TYPE_TASK_CLEANUP:\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM, \"CleanUp CqE\\n\");\n\t\tqedi_process_cmd_cleanup_resp(qedi, &cqe->cqe_solicited, conn);\n\t\tgoto exit_fp_process;\n\tdefault:\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Error cqe.\\n\");\n\t\tbreak;\n\t}\n\nexit_fp_process:\n\treturn;\n}\n\nstatic void qedi_ring_doorbell(struct qedi_conn *qedi_conn)\n{\n\tqedi_conn->ep->db_data.sq_prod = qedi_conn->ep->fw_sq_prod_idx;\n\n\t \n\twmb();\n\twritel(*(u32 *)&qedi_conn->ep->db_data, qedi_conn->ep->p_doorbell);\n\n\t \n\twmb();\n\tQEDI_INFO(&qedi_conn->qedi->dbg_ctx, QEDI_LOG_MP_REQ,\n\t\t  \"prod_idx=0x%x, fw_prod_idx=0x%x, cid=0x%x\\n\",\n\t\t  qedi_conn->ep->sq_prod_idx, qedi_conn->ep->fw_sq_prod_idx,\n\t\t  qedi_conn->iscsi_conn_id);\n}\n\nstatic u16 qedi_get_wqe_idx(struct qedi_conn *qedi_conn)\n{\n\tstruct qedi_endpoint *ep;\n\tu16 rval;\n\n\tep = qedi_conn->ep;\n\trval = ep->sq_prod_idx;\n\n\t \n\tep->sq_prod_idx++;\n\tep->fw_sq_prod_idx++;\n\tif (ep->sq_prod_idx == QEDI_SQ_SIZE)\n\t\tep->sq_prod_idx = 0;\n\n\treturn rval;\n}\n\nint qedi_send_iscsi_login(struct qedi_conn *qedi_conn,\n\t\t\t  struct iscsi_task *task)\n{\n\tstruct iscsi_login_req_hdr login_req_pdu_header;\n\tstruct scsi_sgl_task_params tx_sgl_task_params;\n\tstruct scsi_sgl_task_params rx_sgl_task_params;\n\tstruct iscsi_task_params task_params;\n\tstruct iscsi_task_context *fw_task_ctx;\n\tstruct qedi_ctx *qedi = qedi_conn->qedi;\n\tstruct iscsi_login_req *login_hdr;\n\tstruct scsi_sge *resp_sge = NULL;\n\tstruct qedi_cmd *qedi_cmd;\n\tstruct qedi_endpoint *ep;\n\ts16 tid = 0;\n\tu16 sq_idx = 0;\n\tint rval = 0;\n\n\tresp_sge = (struct scsi_sge *)qedi_conn->gen_pdu.resp_bd_tbl;\n\tqedi_cmd = (struct qedi_cmd *)task->dd_data;\n\tep = qedi_conn->ep;\n\tlogin_hdr = (struct iscsi_login_req *)task->hdr;\n\n\ttid = qedi_get_task_idx(qedi);\n\tif (tid == -1)\n\t\treturn -ENOMEM;\n\n\tfw_task_ctx =\n\t     (struct iscsi_task_context *)qedi_get_task_mem(&qedi->tasks,\n\t\t\t\t\t\t\t       tid);\n\tmemset(fw_task_ctx, 0, sizeof(struct iscsi_task_context));\n\n\tqedi_cmd->task_id = tid;\n\n\tmemset(&task_params, 0, sizeof(task_params));\n\tmemset(&login_req_pdu_header, 0, sizeof(login_req_pdu_header));\n\tmemset(&tx_sgl_task_params, 0, sizeof(tx_sgl_task_params));\n\tmemset(&rx_sgl_task_params, 0, sizeof(rx_sgl_task_params));\n\t \n\tlogin_req_pdu_header.opcode = login_hdr->opcode;\n\tlogin_req_pdu_header.version_min = login_hdr->min_version;\n\tlogin_req_pdu_header.version_max = login_hdr->max_version;\n\tlogin_req_pdu_header.flags_attr = login_hdr->flags;\n\tlogin_req_pdu_header.isid_tabc = swab32p((u32 *)login_hdr->isid);\n\tlogin_req_pdu_header.isid_d = swab16p((u16 *)&login_hdr->isid[4]);\n\n\tlogin_req_pdu_header.tsih = login_hdr->tsih;\n\tlogin_req_pdu_header.hdr_second_dword = ntoh24(login_hdr->dlength);\n\n\tqedi_update_itt_map(qedi, tid, task->itt, qedi_cmd);\n\tlogin_req_pdu_header.itt = qedi_set_itt(tid, get_itt(task->itt));\n\tlogin_req_pdu_header.cid = qedi_conn->iscsi_conn_id;\n\tlogin_req_pdu_header.cmd_sn = be32_to_cpu(login_hdr->cmdsn);\n\tlogin_req_pdu_header.exp_stat_sn = be32_to_cpu(login_hdr->exp_statsn);\n\tlogin_req_pdu_header.exp_stat_sn = 0;\n\n\t \n\ttx_sgl_task_params.sgl =\n\t\t\t       (struct scsi_sge *)qedi_conn->gen_pdu.req_bd_tbl;\n\ttx_sgl_task_params.sgl_phys_addr.lo =\n\t\t\t\t\t (u32)(qedi_conn->gen_pdu.req_dma_addr);\n\ttx_sgl_task_params.sgl_phys_addr.hi =\n\t\t\t      (u32)((u64)qedi_conn->gen_pdu.req_dma_addr >> 32);\n\ttx_sgl_task_params.total_buffer_size = ntoh24(login_hdr->dlength);\n\ttx_sgl_task_params.num_sges = 1;\n\n\trx_sgl_task_params.sgl =\n\t\t\t      (struct scsi_sge *)qedi_conn->gen_pdu.resp_bd_tbl;\n\trx_sgl_task_params.sgl_phys_addr.lo =\n\t\t\t\t\t(u32)(qedi_conn->gen_pdu.resp_dma_addr);\n\trx_sgl_task_params.sgl_phys_addr.hi =\n\t\t\t     (u32)((u64)qedi_conn->gen_pdu.resp_dma_addr >> 32);\n\trx_sgl_task_params.total_buffer_size = resp_sge->sge_len;\n\trx_sgl_task_params.num_sges = 1;\n\n\t \n\ttask_params.context = fw_task_ctx;\n\ttask_params.conn_icid = (u16)qedi_conn->iscsi_conn_id;\n\ttask_params.itid = tid;\n\ttask_params.cq_rss_number = 0;\n\ttask_params.tx_io_size = ntoh24(login_hdr->dlength);\n\ttask_params.rx_io_size = resp_sge->sge_len;\n\n\tsq_idx = qedi_get_wqe_idx(qedi_conn);\n\ttask_params.sqe = &ep->sq[sq_idx];\n\n\tmemset(task_params.sqe, 0, sizeof(struct iscsi_wqe));\n\trval = init_initiator_login_request_task(&task_params,\n\t\t\t\t\t\t &login_req_pdu_header,\n\t\t\t\t\t\t &tx_sgl_task_params,\n\t\t\t\t\t\t &rx_sgl_task_params);\n\tif (rval)\n\t\treturn -1;\n\n\tspin_lock(&qedi_conn->list_lock);\n\tlist_add_tail(&qedi_cmd->io_cmd, &qedi_conn->active_cmd_list);\n\tqedi_cmd->io_cmd_in_list = true;\n\tqedi_conn->active_cmd_count++;\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tqedi_ring_doorbell(qedi_conn);\n\treturn 0;\n}\n\nint qedi_send_iscsi_logout(struct qedi_conn *qedi_conn,\n\t\t\t   struct iscsi_task *task)\n{\n\tstruct iscsi_logout_req_hdr logout_pdu_header;\n\tstruct scsi_sgl_task_params tx_sgl_task_params;\n\tstruct scsi_sgl_task_params rx_sgl_task_params;\n\tstruct iscsi_task_params task_params;\n\tstruct iscsi_task_context *fw_task_ctx;\n\tstruct iscsi_logout *logout_hdr = NULL;\n\tstruct qedi_ctx *qedi = qedi_conn->qedi;\n\tstruct qedi_cmd *qedi_cmd;\n\tstruct qedi_endpoint *ep;\n\ts16 tid = 0;\n\tu16 sq_idx = 0;\n\tint rval = 0;\n\n\tqedi_cmd = (struct qedi_cmd *)task->dd_data;\n\tlogout_hdr = (struct iscsi_logout *)task->hdr;\n\tep = qedi_conn->ep;\n\n\ttid = qedi_get_task_idx(qedi);\n\tif (tid == -1)\n\t\treturn -ENOMEM;\n\n\tfw_task_ctx =\n\t     (struct iscsi_task_context *)qedi_get_task_mem(&qedi->tasks,\n\t\t\t\t\t\t\t       tid);\n\tmemset(fw_task_ctx, 0, sizeof(struct iscsi_task_context));\n\n\tqedi_cmd->task_id = tid;\n\n\tmemset(&task_params, 0, sizeof(task_params));\n\tmemset(&logout_pdu_header, 0, sizeof(logout_pdu_header));\n\tmemset(&tx_sgl_task_params, 0, sizeof(tx_sgl_task_params));\n\tmemset(&rx_sgl_task_params, 0, sizeof(rx_sgl_task_params));\n\n\t \n\tlogout_pdu_header.opcode = logout_hdr->opcode;\n\tlogout_pdu_header.reason_code = 0x80 | logout_hdr->flags;\n\tqedi_update_itt_map(qedi, tid, task->itt, qedi_cmd);\n\tlogout_pdu_header.itt = qedi_set_itt(tid, get_itt(task->itt));\n\tlogout_pdu_header.exp_stat_sn = be32_to_cpu(logout_hdr->exp_statsn);\n\tlogout_pdu_header.cmd_sn = be32_to_cpu(logout_hdr->cmdsn);\n\tlogout_pdu_header.cid = qedi_conn->iscsi_conn_id;\n\n\t \n\ttask_params.context = fw_task_ctx;\n\ttask_params.conn_icid = (u16)qedi_conn->iscsi_conn_id;\n\ttask_params.itid = tid;\n\ttask_params.cq_rss_number = 0;\n\ttask_params.tx_io_size = 0;\n\ttask_params.rx_io_size = 0;\n\n\tsq_idx = qedi_get_wqe_idx(qedi_conn);\n\ttask_params.sqe = &ep->sq[sq_idx];\n\tmemset(task_params.sqe, 0, sizeof(struct iscsi_wqe));\n\n\trval = init_initiator_logout_request_task(&task_params,\n\t\t\t\t\t\t  &logout_pdu_header,\n\t\t\t\t\t\t  NULL, NULL);\n\tif (rval)\n\t\treturn -1;\n\n\tspin_lock(&qedi_conn->list_lock);\n\tlist_add_tail(&qedi_cmd->io_cmd, &qedi_conn->active_cmd_list);\n\tqedi_cmd->io_cmd_in_list = true;\n\tqedi_conn->active_cmd_count++;\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tqedi_ring_doorbell(qedi_conn);\n\treturn 0;\n}\n\nint qedi_cleanup_all_io(struct qedi_ctx *qedi, struct qedi_conn *qedi_conn,\n\t\t\tstruct iscsi_task *task, bool in_recovery)\n{\n\tint rval;\n\tstruct iscsi_task *ctask;\n\tstruct qedi_cmd *cmd, *cmd_tmp;\n\tstruct iscsi_tm *tmf_hdr;\n\tunsigned int lun = 0;\n\tbool lun_reset = false;\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\n\t \n\tif (task) {\n\t\ttmf_hdr = (struct iscsi_tm *)task->hdr;\n\n\t\tif ((tmf_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK) ==\n\t\t\tISCSI_TM_FUNC_LOGICAL_UNIT_RESET) {\n\t\t\tlun_reset = true;\n\t\t\tlun = scsilun_to_int(&tmf_hdr->lun);\n\t\t}\n\t}\n\n\tqedi_conn->cmd_cleanup_req = 0;\n\tatomic_set(&qedi_conn->cmd_cleanup_cmpl, 0);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t  \"active_cmd_count=%d, cid=0x%x, in_recovery=%d, lun_reset=%d\\n\",\n\t\t  qedi_conn->active_cmd_count, qedi_conn->iscsi_conn_id,\n\t\t  in_recovery, lun_reset);\n\n\tif (lun_reset)\n\t\tspin_lock_bh(&session->back_lock);\n\n\tspin_lock(&qedi_conn->list_lock);\n\n\tlist_for_each_entry_safe(cmd, cmd_tmp, &qedi_conn->active_cmd_list,\n\t\t\t\t io_cmd) {\n\t\tctask = cmd->task;\n\t\tif (ctask == task)\n\t\t\tcontinue;\n\n\t\tif (lun_reset) {\n\t\t\tif (cmd->scsi_cmd && cmd->scsi_cmd->device) {\n\t\t\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t\t\t\t  \"tid=0x%x itt=0x%x scsi_cmd_ptr=%p device=%p task_state=%d cmd_state=0%x cid=0x%x\\n\",\n\t\t\t\t\t  cmd->task_id, get_itt(ctask->itt),\n\t\t\t\t\t  cmd->scsi_cmd, cmd->scsi_cmd->device,\n\t\t\t\t\t  ctask->state, cmd->state,\n\t\t\t\t\t  qedi_conn->iscsi_conn_id);\n\t\t\t\tif (cmd->scsi_cmd->device->lun != lun)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tqedi_conn->cmd_cleanup_req++;\n\t\tqedi_iscsi_cleanup_task(ctask, true);\n\n\t\tcmd->io_cmd_in_list = false;\n\t\tlist_del_init(&cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"Deleted active cmd list node io_cmd=%p, cid=0x%x\\n\",\n\t\t\t  &cmd->io_cmd, qedi_conn->iscsi_conn_id);\n\t}\n\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tif (lun_reset)\n\t\tspin_unlock_bh(&session->back_lock);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t  \"cmd_cleanup_req=%d, cid=0x%x\\n\",\n\t\t  qedi_conn->cmd_cleanup_req,\n\t\t  qedi_conn->iscsi_conn_id);\n\n\trval  = wait_event_interruptible_timeout(qedi_conn->wait_queue,\n\t\t\t\t(qedi_conn->cmd_cleanup_req ==\n\t\t\t\t atomic_read(&qedi_conn->cmd_cleanup_cmpl)) ||\n\t\t\t\ttest_bit(QEDI_IN_RECOVERY, &qedi->flags),\n\t\t\t\t5 * HZ);\n\tif (rval) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t\t  \"i/o cmd_cleanup_req=%d, equal to cmd_cleanup_cmpl=%d, cid=0x%x\\n\",\n\t\t\t  qedi_conn->cmd_cleanup_req,\n\t\t\t  atomic_read(&qedi_conn->cmd_cleanup_cmpl),\n\t\t\t  qedi_conn->iscsi_conn_id);\n\n\t\treturn 0;\n\t}\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t  \"i/o cmd_cleanup_req=%d, not equal to cmd_cleanup_cmpl=%d, cid=0x%x\\n\",\n\t\t  qedi_conn->cmd_cleanup_req,\n\t\t  atomic_read(&qedi_conn->cmd_cleanup_cmpl),\n\t\t  qedi_conn->iscsi_conn_id);\n\n\tiscsi_host_for_each_session(qedi->shost,\n\t\t\t\t    qedi_mark_device_missing);\n\tqedi_ops->common->drain(qedi->cdev);\n\n\t \n\tif (!wait_event_interruptible_timeout(qedi_conn->wait_queue,\n\t\t\t\t(qedi_conn->cmd_cleanup_req ==\n\t\t\t\t atomic_read(&qedi_conn->cmd_cleanup_cmpl)) ||\n\t\t\t\ttest_bit(QEDI_IN_RECOVERY, &qedi->flags),\n\t\t\t\t5 * HZ)) {\n\t\tiscsi_host_for_each_session(qedi->shost,\n\t\t\t\t\t    qedi_mark_device_available);\n\t\treturn -1;\n\t}\n\n\tiscsi_host_for_each_session(qedi->shost,\n\t\t\t\t    qedi_mark_device_available);\n\n\treturn 0;\n}\n\nvoid qedi_clearsq(struct qedi_ctx *qedi, struct qedi_conn *qedi_conn,\n\t\t  struct iscsi_task *task)\n{\n\tstruct qedi_endpoint *qedi_ep;\n\tint rval;\n\n\tqedi_ep = qedi_conn->ep;\n\tqedi_conn->cmd_cleanup_req = 0;\n\tatomic_set(&qedi_conn->cmd_cleanup_cmpl, 0);\n\n\tif (!qedi_ep) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"Cannot proceed, ep already disconnected, cid=0x%x\\n\",\n\t\t\t  qedi_conn->iscsi_conn_id);\n\t\treturn;\n\t}\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"Clearing SQ for cid=0x%x, conn=%p, ep=%p\\n\",\n\t\t  qedi_conn->iscsi_conn_id, qedi_conn, qedi_ep);\n\n\tqedi_ops->clear_sq(qedi->cdev, qedi_ep->handle);\n\n\trval = qedi_cleanup_all_io(qedi, qedi_conn, task, true);\n\tif (rval) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"fatal error, need hard reset, cid=0x%x\\n\",\n\t\t\t qedi_conn->iscsi_conn_id);\n\t\tWARN_ON(1);\n\t}\n}\n\nstatic int qedi_wait_for_cleanup_request(struct qedi_ctx *qedi,\n\t\t\t\t\t struct qedi_conn *qedi_conn,\n\t\t\t\t\t struct iscsi_task *task,\n\t\t\t\t\t struct qedi_cmd *qedi_cmd,\n\t\t\t\t\t struct qedi_work_map *list_work)\n{\n\tstruct qedi_cmd *cmd = (struct qedi_cmd *)task->dd_data;\n\tint wait;\n\n\twait  = wait_event_interruptible_timeout(qedi_conn->wait_queue,\n\t\t\t\t\t\t ((qedi_cmd->state ==\n\t\t\t\t\t\t   CLEANUP_RECV) ||\n\t\t\t\t\t\t ((qedi_cmd->type == TYPEIO) &&\n\t\t\t\t\t\t  (cmd->state ==\n\t\t\t\t\t\t   RESPONSE_RECEIVED))),\n\t\t\t\t\t\t 5 * HZ);\n\tif (!wait) {\n\t\tqedi_cmd->state = CLEANUP_WAIT_FAILED;\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t\t  \"Cleanup timedout tid=0x%x, issue connection recovery, cid=0x%x\\n\",\n\t\t\t  cmd->task_id, qedi_conn->iscsi_conn_id);\n\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void qedi_abort_work(struct work_struct *work)\n{\n\tstruct qedi_cmd *qedi_cmd =\n\t\tcontainer_of(work, struct qedi_cmd, tmf_work);\n\tstruct qedi_conn *qedi_conn = qedi_cmd->conn;\n\tstruct qedi_ctx *qedi = qedi_conn->qedi;\n\tstruct iscsi_conn *conn = qedi_conn->cls_conn->dd_data;\n\tstruct qedi_work_map *list_work = NULL;\n\tstruct iscsi_task *mtask;\n\tstruct qedi_cmd *cmd;\n\tstruct iscsi_task *ctask;\n\tstruct iscsi_tm *tmf_hdr;\n\ts16 rval = 0;\n\n\tmtask = qedi_cmd->task;\n\ttmf_hdr = (struct iscsi_tm *)mtask->hdr;\n\n\tspin_lock_bh(&conn->session->back_lock);\n\tctask = iscsi_itt_to_ctask(conn, tmf_hdr->rtt);\n\tif (!ctask) {\n\t\tspin_unlock_bh(&conn->session->back_lock);\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Invalid RTT. Letting abort timeout.\\n\");\n\t\tgoto clear_cleanup;\n\t}\n\n\tif (iscsi_task_is_completed(ctask)) {\n\t\tspin_unlock_bh(&conn->session->back_lock);\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"Task already completed\\n\");\n\t\t \n\t\tgoto send_tmf;\n\t}\n\tspin_unlock_bh(&conn->session->back_lock);\n\n\tcmd = (struct qedi_cmd *)ctask->dd_data;\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"Abort tmf rtt=0x%x, cmd itt=0x%x, cmd tid=0x%x, cid=0x%x\\n\",\n\t\t  get_itt(tmf_hdr->rtt), get_itt(ctask->itt), cmd->task_id,\n\t\t  qedi_conn->iscsi_conn_id);\n\n\tif (qedi_do_not_recover) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"DONT SEND CLEANUP/ABORT %d\\n\",\n\t\t\t qedi_do_not_recover);\n\t\tgoto clear_cleanup;\n\t}\n\n\tlist_work = kzalloc(sizeof(*list_work), GFP_NOIO);\n\tif (!list_work) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Memory allocation failed\\n\");\n\t\tgoto clear_cleanup;\n\t}\n\n\tqedi_cmd->type = TYPEIO;\n\tqedi_cmd->state = CLEANUP_WAIT;\n\tlist_work->qedi_cmd = qedi_cmd;\n\tlist_work->rtid = cmd->task_id;\n\tlist_work->state = QEDI_WORK_SCHEDULED;\n\tlist_work->ctask = ctask;\n\tqedi_cmd->list_tmf_work = list_work;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t  \"Queue tmf work=%p, list node=%p, cid=0x%x, tmf flags=0x%x\\n\",\n\t\t  list_work->ptr_tmf_work, list_work, qedi_conn->iscsi_conn_id,\n\t\t  tmf_hdr->flags);\n\n\tspin_lock_bh(&qedi_conn->tmf_work_lock);\n\tlist_add_tail(&list_work->list, &qedi_conn->tmf_work_list);\n\tspin_unlock_bh(&qedi_conn->tmf_work_lock);\n\n\tqedi_iscsi_cleanup_task(ctask, false);\n\n\trval = qedi_wait_for_cleanup_request(qedi, qedi_conn, ctask, qedi_cmd,\n\t\t\t\t\t     list_work);\n\tif (rval == -1) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"FW cleanup got escalated, cid=0x%x\\n\",\n\t\t\t  qedi_conn->iscsi_conn_id);\n\t\tgoto ldel_exit;\n\t}\n\nsend_tmf:\n\tsend_iscsi_tmf(qedi_conn, qedi_cmd->task, ctask);\n\tgoto clear_cleanup;\n\nldel_exit:\n\tspin_lock_bh(&qedi_conn->tmf_work_lock);\n\tif (qedi_cmd->list_tmf_work) {\n\t\tlist_del_init(&list_work->list);\n\t\tqedi_cmd->list_tmf_work = NULL;\n\t\tkfree(list_work);\n\t}\n\tspin_unlock_bh(&qedi_conn->tmf_work_lock);\n\n\tspin_lock(&qedi_conn->list_lock);\n\tif (likely(cmd->io_cmd_in_list)) {\n\t\tcmd->io_cmd_in_list = false;\n\t\tlist_del_init(&cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t}\n\tspin_unlock(&qedi_conn->list_lock);\n\nclear_cleanup:\n\tspin_lock(&qedi_conn->tmf_work_lock);\n\tqedi_conn->fw_cleanup_works--;\n\tspin_unlock(&qedi_conn->tmf_work_lock);\n}\n\nstatic int send_iscsi_tmf(struct qedi_conn *qedi_conn, struct iscsi_task *mtask,\n\t\t\t  struct iscsi_task *ctask)\n{\n\tstruct iscsi_tmf_request_hdr tmf_pdu_header;\n\tstruct iscsi_task_params task_params;\n\tstruct qedi_ctx *qedi = qedi_conn->qedi;\n\tstruct iscsi_task_context *fw_task_ctx;\n\tstruct iscsi_tm *tmf_hdr;\n\tstruct qedi_cmd *qedi_cmd;\n\tstruct qedi_cmd *cmd;\n\tstruct qedi_endpoint *ep;\n\tu32 scsi_lun[2];\n\ts16 tid = 0;\n\tu16 sq_idx = 0;\n\n\ttmf_hdr = (struct iscsi_tm *)mtask->hdr;\n\tqedi_cmd = (struct qedi_cmd *)mtask->dd_data;\n\tep = qedi_conn->ep;\n\tif (!ep)\n\t\treturn -ENODEV;\n\n\ttid = qedi_get_task_idx(qedi);\n\tif (tid == -1)\n\t\treturn -ENOMEM;\n\n\tfw_task_ctx =\n\t     (struct iscsi_task_context *)qedi_get_task_mem(&qedi->tasks,\n\t\t\t\t\t\t\t       tid);\n\tmemset(fw_task_ctx, 0, sizeof(struct iscsi_task_context));\n\n\tqedi_cmd->task_id = tid;\n\n\tmemset(&task_params, 0, sizeof(task_params));\n\tmemset(&tmf_pdu_header, 0, sizeof(tmf_pdu_header));\n\n\t \n\tqedi_update_itt_map(qedi, tid, mtask->itt, qedi_cmd);\n\ttmf_pdu_header.itt = qedi_set_itt(tid, get_itt(mtask->itt));\n\ttmf_pdu_header.cmd_sn = be32_to_cpu(tmf_hdr->cmdsn);\n\n\tmemcpy(scsi_lun, &tmf_hdr->lun, sizeof(struct scsi_lun));\n\ttmf_pdu_header.lun.lo = be32_to_cpu(scsi_lun[0]);\n\ttmf_pdu_header.lun.hi = be32_to_cpu(scsi_lun[1]);\n\n\tif ((tmf_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK) ==\n\t     ISCSI_TM_FUNC_ABORT_TASK) {\n\t\tcmd = (struct qedi_cmd *)ctask->dd_data;\n\t\ttmf_pdu_header.rtt =\n\t\t\t\tqedi_set_itt(cmd->task_id,\n\t\t\t\t\t     get_itt(tmf_hdr->rtt));\n\t} else {\n\t\ttmf_pdu_header.rtt = ISCSI_RESERVED_TAG;\n\t}\n\n\ttmf_pdu_header.opcode = tmf_hdr->opcode;\n\ttmf_pdu_header.function = tmf_hdr->flags;\n\ttmf_pdu_header.hdr_second_dword = ntoh24(tmf_hdr->dlength);\n\ttmf_pdu_header.ref_cmd_sn = be32_to_cpu(tmf_hdr->refcmdsn);\n\n\t \n\ttask_params.context = fw_task_ctx;\n\ttask_params.conn_icid = (u16)qedi_conn->iscsi_conn_id;\n\ttask_params.itid = tid;\n\ttask_params.cq_rss_number = 0;\n\ttask_params.tx_io_size = 0;\n\ttask_params.rx_io_size = 0;\n\n\tsq_idx = qedi_get_wqe_idx(qedi_conn);\n\ttask_params.sqe = &ep->sq[sq_idx];\n\n\tmemset(task_params.sqe, 0, sizeof(struct iscsi_wqe));\n\tinit_initiator_tmf_request_task(&task_params, &tmf_pdu_header);\n\n\tspin_lock(&qedi_conn->list_lock);\n\tlist_add_tail(&qedi_cmd->io_cmd, &qedi_conn->active_cmd_list);\n\tqedi_cmd->io_cmd_in_list = true;\n\tqedi_conn->active_cmd_count++;\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tqedi_ring_doorbell(qedi_conn);\n\treturn 0;\n}\n\nint qedi_send_iscsi_tmf(struct qedi_conn *qedi_conn, struct iscsi_task *mtask)\n{\n\tstruct iscsi_tm *tmf_hdr = (struct iscsi_tm *)mtask->hdr;\n\tstruct qedi_cmd *qedi_cmd = mtask->dd_data;\n\tstruct qedi_ctx *qedi = qedi_conn->qedi;\n\tint rc = 0;\n\n\tswitch (tmf_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK) {\n\tcase ISCSI_TM_FUNC_ABORT_TASK:\n\t\tspin_lock(&qedi_conn->tmf_work_lock);\n\t\tqedi_conn->fw_cleanup_works++;\n\t\tspin_unlock(&qedi_conn->tmf_work_lock);\n\n\t\tINIT_WORK(&qedi_cmd->tmf_work, qedi_abort_work);\n\t\tqueue_work(qedi->tmf_thread, &qedi_cmd->tmf_work);\n\t\tbreak;\n\tcase ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:\n\tcase ISCSI_TM_FUNC_TARGET_WARM_RESET:\n\tcase ISCSI_TM_FUNC_TARGET_COLD_RESET:\n\t\trc = send_iscsi_tmf(qedi_conn, mtask, NULL);\n\t\tbreak;\n\tdefault:\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Invalid tmf, cid=0x%x\\n\",\n\t\t\t qedi_conn->iscsi_conn_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint qedi_send_iscsi_text(struct qedi_conn *qedi_conn,\n\t\t\t struct iscsi_task *task)\n{\n\tstruct iscsi_text_request_hdr text_request_pdu_header;\n\tstruct scsi_sgl_task_params tx_sgl_task_params;\n\tstruct scsi_sgl_task_params rx_sgl_task_params;\n\tstruct iscsi_task_params task_params;\n\tstruct iscsi_task_context *fw_task_ctx;\n\tstruct qedi_ctx *qedi = qedi_conn->qedi;\n\tstruct iscsi_text *text_hdr;\n\tstruct scsi_sge *req_sge = NULL;\n\tstruct scsi_sge *resp_sge = NULL;\n\tstruct qedi_cmd *qedi_cmd;\n\tstruct qedi_endpoint *ep;\n\ts16 tid = 0;\n\tu16 sq_idx = 0;\n\tint rval = 0;\n\n\treq_sge = (struct scsi_sge *)qedi_conn->gen_pdu.req_bd_tbl;\n\tresp_sge = (struct scsi_sge *)qedi_conn->gen_pdu.resp_bd_tbl;\n\tqedi_cmd = (struct qedi_cmd *)task->dd_data;\n\ttext_hdr = (struct iscsi_text *)task->hdr;\n\tep = qedi_conn->ep;\n\n\ttid = qedi_get_task_idx(qedi);\n\tif (tid == -1)\n\t\treturn -ENOMEM;\n\n\tfw_task_ctx =\n\t     (struct iscsi_task_context *)qedi_get_task_mem(&qedi->tasks,\n\t\t\t\t\t\t\t       tid);\n\tmemset(fw_task_ctx, 0, sizeof(struct iscsi_task_context));\n\n\tqedi_cmd->task_id = tid;\n\n\tmemset(&task_params, 0, sizeof(task_params));\n\tmemset(&text_request_pdu_header, 0, sizeof(text_request_pdu_header));\n\tmemset(&tx_sgl_task_params, 0, sizeof(tx_sgl_task_params));\n\tmemset(&rx_sgl_task_params, 0, sizeof(rx_sgl_task_params));\n\n\t \n\ttext_request_pdu_header.opcode = text_hdr->opcode;\n\ttext_request_pdu_header.flags_attr = text_hdr->flags;\n\n\tqedi_update_itt_map(qedi, tid, task->itt, qedi_cmd);\n\ttext_request_pdu_header.itt = qedi_set_itt(tid, get_itt(task->itt));\n\ttext_request_pdu_header.ttt = text_hdr->ttt;\n\ttext_request_pdu_header.cmd_sn = be32_to_cpu(text_hdr->cmdsn);\n\ttext_request_pdu_header.exp_stat_sn = be32_to_cpu(text_hdr->exp_statsn);\n\ttext_request_pdu_header.hdr_second_dword = ntoh24(text_hdr->dlength);\n\n\t \n\ttx_sgl_task_params.sgl =\n\t\t\t       (struct scsi_sge *)qedi_conn->gen_pdu.req_bd_tbl;\n\ttx_sgl_task_params.sgl_phys_addr.lo =\n\t\t\t\t\t (u32)(qedi_conn->gen_pdu.req_dma_addr);\n\ttx_sgl_task_params.sgl_phys_addr.hi =\n\t\t\t      (u32)((u64)qedi_conn->gen_pdu.req_dma_addr >> 32);\n\ttx_sgl_task_params.total_buffer_size = req_sge->sge_len;\n\ttx_sgl_task_params.num_sges = 1;\n\n\trx_sgl_task_params.sgl =\n\t\t\t      (struct scsi_sge *)qedi_conn->gen_pdu.resp_bd_tbl;\n\trx_sgl_task_params.sgl_phys_addr.lo =\n\t\t\t\t\t(u32)(qedi_conn->gen_pdu.resp_dma_addr);\n\trx_sgl_task_params.sgl_phys_addr.hi =\n\t\t\t     (u32)((u64)qedi_conn->gen_pdu.resp_dma_addr >> 32);\n\trx_sgl_task_params.total_buffer_size = resp_sge->sge_len;\n\trx_sgl_task_params.num_sges = 1;\n\n\t \n\ttask_params.context = fw_task_ctx;\n\ttask_params.conn_icid = (u16)qedi_conn->iscsi_conn_id;\n\ttask_params.itid = tid;\n\ttask_params.cq_rss_number = 0;\n\ttask_params.tx_io_size = ntoh24(text_hdr->dlength);\n\ttask_params.rx_io_size = resp_sge->sge_len;\n\n\tsq_idx = qedi_get_wqe_idx(qedi_conn);\n\ttask_params.sqe = &ep->sq[sq_idx];\n\n\tmemset(task_params.sqe, 0, sizeof(struct iscsi_wqe));\n\trval = init_initiator_text_request_task(&task_params,\n\t\t\t\t\t\t&text_request_pdu_header,\n\t\t\t\t\t\t&tx_sgl_task_params,\n\t\t\t\t\t\t&rx_sgl_task_params);\n\tif (rval)\n\t\treturn -1;\n\n\tspin_lock(&qedi_conn->list_lock);\n\tlist_add_tail(&qedi_cmd->io_cmd, &qedi_conn->active_cmd_list);\n\tqedi_cmd->io_cmd_in_list = true;\n\tqedi_conn->active_cmd_count++;\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tqedi_ring_doorbell(qedi_conn);\n\treturn 0;\n}\n\nint qedi_send_iscsi_nopout(struct qedi_conn *qedi_conn,\n\t\t\t   struct iscsi_task *task,\n\t\t\t   char *datap, int data_len, int unsol)\n{\n\tstruct iscsi_nop_out_hdr nop_out_pdu_header;\n\tstruct scsi_sgl_task_params tx_sgl_task_params;\n\tstruct scsi_sgl_task_params rx_sgl_task_params;\n\tstruct iscsi_task_params task_params;\n\tstruct qedi_ctx *qedi = qedi_conn->qedi;\n\tstruct iscsi_task_context *fw_task_ctx;\n\tstruct iscsi_nopout *nopout_hdr;\n\tstruct scsi_sge *resp_sge = NULL;\n\tstruct qedi_cmd *qedi_cmd;\n\tstruct qedi_endpoint *ep;\n\tu32 scsi_lun[2];\n\ts16 tid = 0;\n\tu16 sq_idx = 0;\n\tint rval = 0;\n\n\tresp_sge = (struct scsi_sge *)qedi_conn->gen_pdu.resp_bd_tbl;\n\tqedi_cmd = (struct qedi_cmd *)task->dd_data;\n\tnopout_hdr = (struct iscsi_nopout *)task->hdr;\n\tep = qedi_conn->ep;\n\n\ttid = qedi_get_task_idx(qedi);\n\tif (tid == -1)\n\t\treturn -ENOMEM;\n\n\tfw_task_ctx =\n\t     (struct iscsi_task_context *)qedi_get_task_mem(&qedi->tasks,\n\t\t\t\t\t\t\t       tid);\n\tmemset(fw_task_ctx, 0, sizeof(struct iscsi_task_context));\n\n\tqedi_cmd->task_id = tid;\n\n\tmemset(&task_params, 0, sizeof(task_params));\n\tmemset(&nop_out_pdu_header, 0, sizeof(nop_out_pdu_header));\n\tmemset(&tx_sgl_task_params, 0, sizeof(tx_sgl_task_params));\n\tmemset(&rx_sgl_task_params, 0, sizeof(rx_sgl_task_params));\n\n\t \n\tnop_out_pdu_header.opcode = nopout_hdr->opcode;\n\tSET_FIELD(nop_out_pdu_header.flags_attr, ISCSI_NOP_OUT_HDR_CONST1, 1);\n\tSET_FIELD(nop_out_pdu_header.flags_attr, ISCSI_NOP_OUT_HDR_RSRV, 0);\n\n\tmemcpy(scsi_lun, &nopout_hdr->lun, sizeof(struct scsi_lun));\n\tnop_out_pdu_header.lun.lo = be32_to_cpu(scsi_lun[0]);\n\tnop_out_pdu_header.lun.hi = be32_to_cpu(scsi_lun[1]);\n\tnop_out_pdu_header.cmd_sn = be32_to_cpu(nopout_hdr->cmdsn);\n\tnop_out_pdu_header.exp_stat_sn = be32_to_cpu(nopout_hdr->exp_statsn);\n\n\tqedi_update_itt_map(qedi, tid, task->itt, qedi_cmd);\n\n\tif (nopout_hdr->ttt != ISCSI_TTT_ALL_ONES) {\n\t\tnop_out_pdu_header.itt = be32_to_cpu(nopout_hdr->itt);\n\t\tnop_out_pdu_header.ttt = be32_to_cpu(nopout_hdr->ttt);\n\t} else {\n\t\tnop_out_pdu_header.itt = qedi_set_itt(tid, get_itt(task->itt));\n\t\tnop_out_pdu_header.ttt = ISCSI_TTT_ALL_ONES;\n\n\t\tspin_lock(&qedi_conn->list_lock);\n\t\tlist_add_tail(&qedi_cmd->io_cmd, &qedi_conn->active_cmd_list);\n\t\tqedi_cmd->io_cmd_in_list = true;\n\t\tqedi_conn->active_cmd_count++;\n\t\tspin_unlock(&qedi_conn->list_lock);\n\t}\n\n\t \n\tif (data_len) {\n\t\ttx_sgl_task_params.sgl =\n\t\t\t       (struct scsi_sge *)qedi_conn->gen_pdu.req_bd_tbl;\n\t\ttx_sgl_task_params.sgl_phys_addr.lo =\n\t\t\t\t\t (u32)(qedi_conn->gen_pdu.req_dma_addr);\n\t\ttx_sgl_task_params.sgl_phys_addr.hi =\n\t\t\t      (u32)((u64)qedi_conn->gen_pdu.req_dma_addr >> 32);\n\t\ttx_sgl_task_params.total_buffer_size = data_len;\n\t\ttx_sgl_task_params.num_sges = 1;\n\n\t\trx_sgl_task_params.sgl =\n\t\t\t      (struct scsi_sge *)qedi_conn->gen_pdu.resp_bd_tbl;\n\t\trx_sgl_task_params.sgl_phys_addr.lo =\n\t\t\t\t\t(u32)(qedi_conn->gen_pdu.resp_dma_addr);\n\t\trx_sgl_task_params.sgl_phys_addr.hi =\n\t\t\t     (u32)((u64)qedi_conn->gen_pdu.resp_dma_addr >> 32);\n\t\trx_sgl_task_params.total_buffer_size = resp_sge->sge_len;\n\t\trx_sgl_task_params.num_sges = 1;\n\t}\n\n\t \n\ttask_params.context = fw_task_ctx;\n\ttask_params.conn_icid = (u16)qedi_conn->iscsi_conn_id;\n\ttask_params.itid = tid;\n\ttask_params.cq_rss_number = 0;\n\ttask_params.tx_io_size = data_len;\n\ttask_params.rx_io_size = resp_sge->sge_len;\n\n\tsq_idx = qedi_get_wqe_idx(qedi_conn);\n\ttask_params.sqe = &ep->sq[sq_idx];\n\n\tmemset(task_params.sqe, 0, sizeof(struct iscsi_wqe));\n\trval = init_initiator_nop_out_task(&task_params,\n\t\t\t\t\t   &nop_out_pdu_header,\n\t\t\t\t\t   &tx_sgl_task_params,\n\t\t\t\t\t   &rx_sgl_task_params);\n\tif (rval)\n\t\treturn -1;\n\n\tqedi_ring_doorbell(qedi_conn);\n\treturn 0;\n}\n\nstatic int qedi_split_bd(struct qedi_cmd *cmd, u64 addr, int sg_len,\n\t\t\t int bd_index)\n{\n\tstruct scsi_sge *bd = cmd->io_tbl.sge_tbl;\n\tint frag_size, sg_frags;\n\n\tsg_frags = 0;\n\n\twhile (sg_len) {\n\t\tif (addr % QEDI_PAGE_SIZE)\n\t\t\tfrag_size =\n\t\t\t\t   (QEDI_PAGE_SIZE - (addr % QEDI_PAGE_SIZE));\n\t\telse\n\t\t\tfrag_size = (sg_len > QEDI_BD_SPLIT_SZ) ? 0 :\n\t\t\t\t    (sg_len % QEDI_BD_SPLIT_SZ);\n\n\t\tif (frag_size == 0)\n\t\t\tfrag_size = QEDI_BD_SPLIT_SZ;\n\n\t\tbd[bd_index + sg_frags].sge_addr.lo = (addr & 0xffffffff);\n\t\tbd[bd_index + sg_frags].sge_addr.hi = (addr >> 32);\n\t\tbd[bd_index + sg_frags].sge_len = (u16)frag_size;\n\t\tQEDI_INFO(&cmd->conn->qedi->dbg_ctx, QEDI_LOG_IO,\n\t\t\t  \"split sge %d: addr=%llx, len=%x\",\n\t\t\t  (bd_index + sg_frags), addr, frag_size);\n\n\t\taddr += (u64)frag_size;\n\t\tsg_frags++;\n\t\tsg_len -= frag_size;\n\t}\n\treturn sg_frags;\n}\n\nstatic int qedi_map_scsi_sg(struct qedi_ctx *qedi, struct qedi_cmd *cmd)\n{\n\tstruct scsi_cmnd *sc = cmd->scsi_cmd;\n\tstruct scsi_sge *bd = cmd->io_tbl.sge_tbl;\n\tstruct scatterlist *sg;\n\tint byte_count = 0;\n\tint bd_count = 0;\n\tint sg_count;\n\tint sg_len;\n\tint sg_frags;\n\tu64 addr, end_addr;\n\tint i;\n\n\tWARN_ON(scsi_sg_count(sc) > QEDI_ISCSI_MAX_BDS_PER_CMD);\n\n\tsg_count = dma_map_sg(&qedi->pdev->dev, scsi_sglist(sc),\n\t\t\t      scsi_sg_count(sc), sc->sc_data_direction);\n\n\t \n\tsg = scsi_sglist(sc);\n\tif ((sg_count == 1) && (sg_dma_len(sg) <= MAX_SGLEN_FOR_CACHESGL)) {\n\t\tsg_len = sg_dma_len(sg);\n\t\taddr = (u64)sg_dma_address(sg);\n\n\t\tbd[bd_count].sge_addr.lo = (addr & 0xffffffff);\n\t\tbd[bd_count].sge_addr.hi = (addr >> 32);\n\t\tbd[bd_count].sge_len = (u16)sg_len;\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_IO,\n\t\t\t  \"single-cached-sgl: bd_count:%d addr=%llx, len=%x\",\n\t\t\t  sg_count, addr, sg_len);\n\n\t\treturn ++bd_count;\n\t}\n\n\tscsi_for_each_sg(sc, sg, sg_count, i) {\n\t\tsg_len = sg_dma_len(sg);\n\t\taddr = (u64)sg_dma_address(sg);\n\t\tend_addr = (addr + sg_len);\n\n\t\t \n\t\tif ((i == 0) && (sg_count > 1) && (end_addr % QEDI_PAGE_SIZE))\n\t\t\tcmd->use_slowpath = true;\n\n\t\t \n\t\telse if ((i == (sg_count - 1)) &&\n\t\t\t (sg_count > 1) && (addr % QEDI_PAGE_SIZE))\n\t\t\tcmd->use_slowpath = true;\n\n\t\t \n\t\telse if ((i != 0) && (i != (sg_count - 1)) &&\n\t\t\t ((addr % QEDI_PAGE_SIZE) ||\n\t\t\t (end_addr % QEDI_PAGE_SIZE)))\n\t\t\tcmd->use_slowpath = true;\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_IO, \"sg[%d] size=0x%x\",\n\t\t\t  i, sg_len);\n\n\t\tif (sg_len > QEDI_BD_SPLIT_SZ) {\n\t\t\tsg_frags = qedi_split_bd(cmd, addr, sg_len, bd_count);\n\t\t} else {\n\t\t\tsg_frags = 1;\n\t\t\tbd[bd_count].sge_addr.lo = addr & 0xffffffff;\n\t\t\tbd[bd_count].sge_addr.hi = addr >> 32;\n\t\t\tbd[bd_count].sge_len = sg_len;\n\t\t}\n\t\tbyte_count += sg_len;\n\t\tbd_count += sg_frags;\n\t}\n\n\tif (byte_count != scsi_bufflen(sc))\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"byte_count = %d != scsi_bufflen = %d\\n\", byte_count,\n\t\t\t scsi_bufflen(sc));\n\telse\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_IO, \"byte_count = %d\\n\",\n\t\t\t  byte_count);\n\n\tWARN_ON(byte_count != scsi_bufflen(sc));\n\n\treturn bd_count;\n}\n\nstatic void qedi_iscsi_map_sg_list(struct qedi_cmd *cmd)\n{\n\tint bd_count;\n\tstruct scsi_cmnd *sc = cmd->scsi_cmd;\n\n\tif (scsi_sg_count(sc)) {\n\t\tbd_count  = qedi_map_scsi_sg(cmd->conn->qedi, cmd);\n\t\tif (bd_count == 0)\n\t\t\treturn;\n\t} else {\n\t\tstruct scsi_sge *bd = cmd->io_tbl.sge_tbl;\n\n\t\tbd[0].sge_addr.lo = 0;\n\t\tbd[0].sge_addr.hi = 0;\n\t\tbd[0].sge_len = 0;\n\t\tbd_count = 0;\n\t}\n\tcmd->io_tbl.sge_valid = bd_count;\n}\n\nstatic void qedi_cpy_scsi_cdb(struct scsi_cmnd *sc, u32 *dstp)\n{\n\tu32 dword;\n\tint lpcnt;\n\tu8 *srcp;\n\n\tlpcnt = sc->cmd_len / sizeof(dword);\n\tsrcp = (u8 *)sc->cmnd;\n\twhile (lpcnt--) {\n\t\tmemcpy(&dword, (const void *)srcp, 4);\n\t\t*dstp = cpu_to_be32(dword);\n\t\tsrcp += 4;\n\t\tdstp++;\n\t}\n\tif (sc->cmd_len & 0x3) {\n\t\tdword = (u32)srcp[0] | ((u32)srcp[1] << 8);\n\t\t*dstp = cpu_to_be32(dword);\n\t}\n}\n\nvoid qedi_trace_io(struct qedi_ctx *qedi, struct iscsi_task *task,\n\t\t   u16 tid, int8_t direction)\n{\n\tstruct qedi_io_log *io_log;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\tstruct scsi_cmnd *sc_cmd = task->sc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qedi->io_trace_lock, flags);\n\n\tio_log = &qedi->io_trace_buf[qedi->io_trace_idx];\n\tio_log->direction = direction;\n\tio_log->task_id = tid;\n\tio_log->cid = qedi_conn->iscsi_conn_id;\n\tio_log->lun = sc_cmd->device->lun;\n\tio_log->op = sc_cmd->cmnd[0];\n\tio_log->lba[0] = sc_cmd->cmnd[2];\n\tio_log->lba[1] = sc_cmd->cmnd[3];\n\tio_log->lba[2] = sc_cmd->cmnd[4];\n\tio_log->lba[3] = sc_cmd->cmnd[5];\n\tio_log->bufflen = scsi_bufflen(sc_cmd);\n\tio_log->sg_count = scsi_sg_count(sc_cmd);\n\tio_log->fast_sgs = qedi->fast_sgls;\n\tio_log->cached_sgs = qedi->cached_sgls;\n\tio_log->slow_sgs = qedi->slow_sgls;\n\tio_log->cached_sge = qedi->use_cached_sge;\n\tio_log->slow_sge = qedi->use_slow_sge;\n\tio_log->fast_sge = qedi->use_fast_sge;\n\tio_log->result = sc_cmd->result;\n\tio_log->jiffies = jiffies;\n\tio_log->blk_req_cpu = smp_processor_id();\n\n\tif (direction == QEDI_IO_TRACE_REQ) {\n\t\t \n\t\tio_log->req_cpu = smp_processor_id() % qedi->num_queues;\n\t\tio_log->intr_cpu = 0;\n\t\tio_log->blk_rsp_cpu = 0;\n\t} else if (direction == QEDI_IO_TRACE_RSP) {\n\t\tio_log->req_cpu = smp_processor_id() % qedi->num_queues;\n\t\tio_log->intr_cpu = qedi->intr_cpu;\n\t\tio_log->blk_rsp_cpu = smp_processor_id();\n\t}\n\n\tqedi->io_trace_idx++;\n\tif (qedi->io_trace_idx == QEDI_IO_TRACE_SIZE)\n\t\tqedi->io_trace_idx = 0;\n\n\tqedi->use_cached_sge = false;\n\tqedi->use_slow_sge = false;\n\tqedi->use_fast_sge = false;\n\n\tspin_unlock_irqrestore(&qedi->io_trace_lock, flags);\n}\n\nint qedi_iscsi_send_ioreq(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *session = conn->session;\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(session->cls_session);\n\tstruct qedi_ctx *qedi = iscsi_host_priv(shost);\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\tstruct qedi_cmd *cmd = task->dd_data;\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct iscsi_cmd_hdr cmd_pdu_header;\n\tstruct scsi_sgl_task_params tx_sgl_task_params;\n\tstruct scsi_sgl_task_params rx_sgl_task_params;\n\tstruct scsi_sgl_task_params *prx_sgl = NULL;\n\tstruct scsi_sgl_task_params *ptx_sgl = NULL;\n\tstruct iscsi_task_params task_params;\n\tstruct iscsi_conn_params conn_params;\n\tstruct scsi_initiator_cmd_params cmd_params;\n\tstruct iscsi_task_context *fw_task_ctx;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)task->hdr;\n\tenum iscsi_task_type task_type = MAX_ISCSI_TASK_TYPE;\n\tstruct qedi_endpoint *ep;\n\tu32 scsi_lun[2];\n\ts16 tid = 0;\n\tu16 sq_idx = 0;\n\tu16 cq_idx;\n\tint rval = 0;\n\n\tep = qedi_conn->ep;\n\tcls_conn = qedi_conn->cls_conn;\n\tconn = cls_conn->dd_data;\n\n\tqedi_iscsi_map_sg_list(cmd);\n\tint_to_scsilun(sc->device->lun, (struct scsi_lun *)scsi_lun);\n\n\ttid = qedi_get_task_idx(qedi);\n\tif (tid == -1)\n\t\treturn -ENOMEM;\n\n\tfw_task_ctx =\n\t     (struct iscsi_task_context *)qedi_get_task_mem(&qedi->tasks,\n\t\t\t\t\t\t\t       tid);\n\tmemset(fw_task_ctx, 0, sizeof(struct iscsi_task_context));\n\n\tcmd->task_id = tid;\n\n\tmemset(&task_params, 0, sizeof(task_params));\n\tmemset(&cmd_pdu_header, 0, sizeof(cmd_pdu_header));\n\tmemset(&tx_sgl_task_params, 0, sizeof(tx_sgl_task_params));\n\tmemset(&rx_sgl_task_params, 0, sizeof(rx_sgl_task_params));\n\tmemset(&conn_params, 0, sizeof(conn_params));\n\tmemset(&cmd_params, 0, sizeof(cmd_params));\n\n\tcq_idx = smp_processor_id() % qedi->num_queues;\n\t \n\tSET_FIELD(cmd_pdu_header.flags_attr, ISCSI_CMD_HDR_ATTR,\n\t\t  ISCSI_ATTR_SIMPLE);\n\tif (hdr->cdb[0] != TEST_UNIT_READY) {\n\t\tif (sc->sc_data_direction == DMA_TO_DEVICE) {\n\t\t\tSET_FIELD(cmd_pdu_header.flags_attr,\n\t\t\t\t  ISCSI_CMD_HDR_WRITE, 1);\n\t\t\ttask_type = ISCSI_TASK_TYPE_INITIATOR_WRITE;\n\t\t} else {\n\t\t\tSET_FIELD(cmd_pdu_header.flags_attr,\n\t\t\t\t  ISCSI_CMD_HDR_READ, 1);\n\t\t\ttask_type = ISCSI_TASK_TYPE_INITIATOR_READ;\n\t\t}\n\t}\n\n\tcmd_pdu_header.lun.lo = be32_to_cpu(scsi_lun[0]);\n\tcmd_pdu_header.lun.hi = be32_to_cpu(scsi_lun[1]);\n\n\tqedi_update_itt_map(qedi, tid, task->itt, cmd);\n\tcmd_pdu_header.itt = qedi_set_itt(tid, get_itt(task->itt));\n\tcmd_pdu_header.expected_transfer_length = cpu_to_be32(hdr->data_length);\n\tcmd_pdu_header.hdr_second_dword = ntoh24(hdr->dlength);\n\tcmd_pdu_header.cmd_sn = be32_to_cpu(hdr->cmdsn);\n\tcmd_pdu_header.hdr_first_byte = hdr->opcode;\n\tqedi_cpy_scsi_cdb(sc, (u32 *)cmd_pdu_header.cdb);\n\n\t \n\tif (task_type == ISCSI_TASK_TYPE_INITIATOR_WRITE) {\n\t\ttx_sgl_task_params.sgl = cmd->io_tbl.sge_tbl;\n\t\ttx_sgl_task_params.sgl_phys_addr.lo =\n\t\t\t\t\t\t (u32)(cmd->io_tbl.sge_tbl_dma);\n\t\ttx_sgl_task_params.sgl_phys_addr.hi =\n\t\t\t\t      (u32)((u64)cmd->io_tbl.sge_tbl_dma >> 32);\n\t\ttx_sgl_task_params.total_buffer_size = scsi_bufflen(sc);\n\t\ttx_sgl_task_params.num_sges = cmd->io_tbl.sge_valid;\n\t\tif (cmd->use_slowpath)\n\t\t\ttx_sgl_task_params.small_mid_sge = true;\n\t} else if (task_type == ISCSI_TASK_TYPE_INITIATOR_READ) {\n\t\trx_sgl_task_params.sgl = cmd->io_tbl.sge_tbl;\n\t\trx_sgl_task_params.sgl_phys_addr.lo =\n\t\t\t\t\t\t (u32)(cmd->io_tbl.sge_tbl_dma);\n\t\trx_sgl_task_params.sgl_phys_addr.hi =\n\t\t\t\t      (u32)((u64)cmd->io_tbl.sge_tbl_dma >> 32);\n\t\trx_sgl_task_params.total_buffer_size = scsi_bufflen(sc);\n\t\trx_sgl_task_params.num_sges = cmd->io_tbl.sge_valid;\n\t}\n\n\t \n\tconn_params.first_burst_length = conn->session->first_burst;\n\tconn_params.max_send_pdu_length = conn->max_xmit_dlength;\n\tconn_params.max_burst_length = conn->session->max_burst;\n\tif (conn->session->initial_r2t_en)\n\t\tconn_params.initial_r2t = true;\n\tif (conn->session->imm_data_en)\n\t\tconn_params.immediate_data = true;\n\n\t \n\tcmd_params.sense_data_buffer_phys_addr.lo = (u32)cmd->sense_buffer_dma;\n\tcmd_params.sense_data_buffer_phys_addr.hi =\n\t\t\t\t\t(u32)((u64)cmd->sense_buffer_dma >> 32);\n\t \n\ttask_params.context = fw_task_ctx;\n\ttask_params.conn_icid = (u16)qedi_conn->iscsi_conn_id;\n\ttask_params.itid = tid;\n\ttask_params.cq_rss_number = cq_idx;\n\tif (task_type == ISCSI_TASK_TYPE_INITIATOR_WRITE)\n\t\ttask_params.tx_io_size = scsi_bufflen(sc);\n\telse if (task_type == ISCSI_TASK_TYPE_INITIATOR_READ)\n\t\ttask_params.rx_io_size = scsi_bufflen(sc);\n\n\tsq_idx = qedi_get_wqe_idx(qedi_conn);\n\ttask_params.sqe = &ep->sq[sq_idx];\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_IO,\n\t\t  \"%s: %s-SGL: sg_len=0x%x num_sges=0x%x first-sge-lo=0x%x first-sge-hi=0x%x\\n\",\n\t\t  (task_type == ISCSI_TASK_TYPE_INITIATOR_WRITE) ?\n\t\t  \"Write \" : \"Read \", (cmd->io_tbl.sge_valid == 1) ?\n\t\t  \"Single\" : (cmd->use_slowpath ? \"SLOW\" : \"FAST\"),\n\t\t  (u16)cmd->io_tbl.sge_valid, scsi_bufflen(sc),\n\t\t  (u32)(cmd->io_tbl.sge_tbl_dma),\n\t\t  (u32)((u64)cmd->io_tbl.sge_tbl_dma >> 32));\n\n\tmemset(task_params.sqe, 0, sizeof(struct iscsi_wqe));\n\n\tif (task_params.tx_io_size != 0)\n\t\tptx_sgl = &tx_sgl_task_params;\n\tif (task_params.rx_io_size != 0)\n\t\tprx_sgl = &rx_sgl_task_params;\n\n\trval = init_initiator_rw_iscsi_task(&task_params, &conn_params,\n\t\t\t\t\t    &cmd_params, &cmd_pdu_header,\n\t\t\t\t\t    ptx_sgl, prx_sgl,\n\t\t\t\t\t    NULL);\n\tif (rval)\n\t\treturn -1;\n\n\tspin_lock(&qedi_conn->list_lock);\n\tlist_add_tail(&cmd->io_cmd, &qedi_conn->active_cmd_list);\n\tcmd->io_cmd_in_list = true;\n\tqedi_conn->active_cmd_count++;\n\tspin_unlock(&qedi_conn->list_lock);\n\n\tqedi_ring_doorbell(qedi_conn);\n\treturn 0;\n}\n\nint qedi_iscsi_cleanup_task(struct iscsi_task *task, bool mark_cmd_node_deleted)\n{\n\tstruct iscsi_task_params task_params;\n\tstruct qedi_endpoint *ep;\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\tstruct qedi_cmd *cmd = task->dd_data;\n\tu16 sq_idx = 0;\n\tint rval = 0;\n\n\tQEDI_INFO(&qedi_conn->qedi->dbg_ctx, QEDI_LOG_SCSI_TM,\n\t\t  \"issue cleanup tid=0x%x itt=0x%x task_state=%d cmd_state=0%x cid=0x%x\\n\",\n\t\t  cmd->task_id, get_itt(task->itt), task->state,\n\t\t  cmd->state, qedi_conn->iscsi_conn_id);\n\n\tmemset(&task_params, 0, sizeof(task_params));\n\tep = qedi_conn->ep;\n\n\tsq_idx = qedi_get_wqe_idx(qedi_conn);\n\n\ttask_params.sqe = &ep->sq[sq_idx];\n\tmemset(task_params.sqe, 0, sizeof(struct iscsi_wqe));\n\ttask_params.itid = cmd->task_id;\n\n\trval = init_cleanup_task(&task_params);\n\tif (rval)\n\t\treturn rval;\n\n\tqedi_ring_doorbell(qedi_conn);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}