{
  "module_name": "qedi_debugfs.c",
  "hash_id": "09bdcef835c1c3f8668bf532519837e3357cb2d6748d94e40a08d518c30c7c1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedi/qedi_debugfs.c",
  "human_readable_source": "\n \n\n#include \"qedi.h\"\n#include \"qedi_dbg.h\"\n\n#include <linux/uaccess.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n\nint qedi_do_not_recover;\nstatic struct dentry *qedi_dbg_root;\n\nvoid\nqedi_dbg_host_init(struct qedi_dbg_ctx *qedi,\n\t\t   const struct qedi_debugfs_ops *dops,\n\t\t   const struct file_operations *fops)\n{\n\tchar host_dirname[32];\n\n\tsprintf(host_dirname, \"host%u\", qedi->host_no);\n\tqedi->bdf_dentry = debugfs_create_dir(host_dirname, qedi_dbg_root);\n\n\twhile (dops) {\n\t\tif (!(dops->name))\n\t\t\tbreak;\n\n\t\tdebugfs_create_file(dops->name, 0600, qedi->bdf_dentry, qedi,\n\t\t\t\t    fops);\n\t\tdops++;\n\t\tfops++;\n\t}\n}\n\nvoid\nqedi_dbg_host_exit(struct qedi_dbg_ctx *qedi)\n{\n\tdebugfs_remove_recursive(qedi->bdf_dentry);\n\tqedi->bdf_dentry = NULL;\n}\n\nvoid\nqedi_dbg_init(char *drv_name)\n{\n\tqedi_dbg_root = debugfs_create_dir(drv_name, NULL);\n}\n\nvoid\nqedi_dbg_exit(void)\n{\n\tdebugfs_remove_recursive(qedi_dbg_root);\n\tqedi_dbg_root = NULL;\n}\n\nstatic ssize_t\nqedi_dbg_do_not_recover_enable(struct qedi_dbg_ctx *qedi_dbg)\n{\n\tif (!qedi_do_not_recover)\n\t\tqedi_do_not_recover = 1;\n\n\tQEDI_INFO(qedi_dbg, QEDI_LOG_DEBUGFS, \"do_not_recover=%d\\n\",\n\t\t  qedi_do_not_recover);\n\treturn 0;\n}\n\nstatic ssize_t\nqedi_dbg_do_not_recover_disable(struct qedi_dbg_ctx *qedi_dbg)\n{\n\tif (qedi_do_not_recover)\n\t\tqedi_do_not_recover = 0;\n\n\tQEDI_INFO(qedi_dbg, QEDI_LOG_DEBUGFS, \"do_not_recover=%d\\n\",\n\t\t  qedi_do_not_recover);\n\treturn 0;\n}\n\nstatic struct qedi_list_of_funcs qedi_dbg_do_not_recover_ops[] = {\n\t{ \"enable\", qedi_dbg_do_not_recover_enable },\n\t{ \"disable\", qedi_dbg_do_not_recover_disable },\n\t{ NULL, NULL }\n};\n\nconst struct qedi_debugfs_ops qedi_debugfs_ops[] = {\n\t{ \"gbl_ctx\", NULL },\n\t{ \"do_not_recover\", qedi_dbg_do_not_recover_ops},\n\t{ \"io_trace\", NULL },\n\t{ NULL, NULL }\n};\n\nstatic ssize_t\nqedi_dbg_do_not_recover_cmd_write(struct file *filp, const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tsize_t cnt = 0;\n\tstruct qedi_dbg_ctx *qedi_dbg =\n\t\t\t(struct qedi_dbg_ctx *)filp->private_data;\n\tstruct qedi_list_of_funcs *lof = qedi_dbg_do_not_recover_ops;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\twhile (lof) {\n\t\tif (!(lof->oper_str))\n\t\t\tbreak;\n\n\t\tif (!strncmp(lof->oper_str, buffer, strlen(lof->oper_str))) {\n\t\t\tcnt = lof->oper_func(qedi_dbg);\n\t\t\tbreak;\n\t\t}\n\n\t\tlof++;\n\t}\n\treturn (count - cnt);\n}\n\nstatic ssize_t\nqedi_dbg_do_not_recover_cmd_read(struct file *filp, char __user *buffer,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tsize_t cnt = 0;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tcnt = sprintf(buffer, \"do_not_recover=%d\\n\", qedi_do_not_recover);\n\tcnt = min_t(int, count, cnt - *ppos);\n\t*ppos += cnt;\n\treturn cnt;\n}\n\nstatic int\nqedi_gbl_ctx_show(struct seq_file *s, void *unused)\n{\n\tstruct qedi_fastpath *fp = NULL;\n\tstruct qed_sb_info *sb_info = NULL;\n\tstruct status_block *sb = NULL;\n\tstruct global_queue *que = NULL;\n\tint id;\n\tu16 prod_idx;\n\tstruct qedi_ctx *qedi = s->private;\n\tunsigned long flags;\n\n\tseq_puts(s, \" DUMP CQ CONTEXT:\\n\");\n\n\tfor (id = 0; id < MIN_NUM_CPUS_MSIX(qedi); id++) {\n\t\tspin_lock_irqsave(&qedi->hba_lock, flags);\n\t\tseq_printf(s, \"=========FAST CQ PATH [%d] ==========\\n\", id);\n\t\tfp = &qedi->fp_array[id];\n\t\tsb_info = fp->sb_info;\n\t\tsb = sb_info->sb_virt;\n\t\tprod_idx = (sb->pi_array[QEDI_PROTO_CQ_PROD_IDX] &\n\t\t\t    STATUS_BLOCK_PROD_INDEX_MASK);\n\t\tseq_printf(s, \"SB PROD IDX: %d\\n\", prod_idx);\n\t\tque = qedi->global_queues[fp->sb_id];\n\t\tseq_printf(s, \"DRV CONS IDX: %d\\n\", que->cq_cons_idx);\n\t\tseq_printf(s, \"CQ complete host memory: %d\\n\", fp->sb_id);\n\t\tseq_puts(s, \"=========== END ==================\\n\\n\\n\");\n\t\tspin_unlock_irqrestore(&qedi->hba_lock, flags);\n\t}\n\treturn 0;\n}\n\nstatic int\nqedi_dbg_gbl_ctx_open(struct inode *inode, struct file *file)\n{\n\tstruct qedi_dbg_ctx *qedi_dbg = inode->i_private;\n\tstruct qedi_ctx *qedi = container_of(qedi_dbg, struct qedi_ctx,\n\t\t\t\t\t     dbg_ctx);\n\n\treturn single_open(file, qedi_gbl_ctx_show, qedi);\n}\n\nstatic int\nqedi_io_trace_show(struct seq_file *s, void *unused)\n{\n\tint id, idx = 0;\n\tstruct qedi_ctx *qedi = s->private;\n\tstruct qedi_io_log *io_log;\n\tunsigned long flags;\n\n\tseq_puts(s, \" DUMP IO LOGS:\\n\");\n\tspin_lock_irqsave(&qedi->io_trace_lock, flags);\n\tidx = qedi->io_trace_idx;\n\tfor (id = 0; id < QEDI_IO_TRACE_SIZE; id++) {\n\t\tio_log = &qedi->io_trace_buf[idx];\n\t\tseq_printf(s, \"iodir-%d:\", io_log->direction);\n\t\tseq_printf(s, \"tid-0x%x:\", io_log->task_id);\n\t\tseq_printf(s, \"cid-0x%x:\", io_log->cid);\n\t\tseq_printf(s, \"lun-%d:\", io_log->lun);\n\t\tseq_printf(s, \"op-0x%02x:\", io_log->op);\n\t\tseq_printf(s, \"0x%02x%02x%02x%02x:\", io_log->lba[0],\n\t\t\t   io_log->lba[1], io_log->lba[2], io_log->lba[3]);\n\t\tseq_printf(s, \"buflen-%d:\", io_log->bufflen);\n\t\tseq_printf(s, \"sgcnt-%d:\", io_log->sg_count);\n\t\tseq_printf(s, \"res-0x%08x:\", io_log->result);\n\t\tseq_printf(s, \"jif-%lu:\", io_log->jiffies);\n\t\tseq_printf(s, \"blk_req_cpu-%d:\", io_log->blk_req_cpu);\n\t\tseq_printf(s, \"req_cpu-%d:\", io_log->req_cpu);\n\t\tseq_printf(s, \"intr_cpu-%d:\", io_log->intr_cpu);\n\t\tseq_printf(s, \"blk_rsp_cpu-%d\\n\", io_log->blk_rsp_cpu);\n\n\t\tidx++;\n\t\tif (idx == QEDI_IO_TRACE_SIZE)\n\t\t\tidx = 0;\n\t}\n\tspin_unlock_irqrestore(&qedi->io_trace_lock, flags);\n\treturn 0;\n}\n\nstatic int\nqedi_dbg_io_trace_open(struct inode *inode, struct file *file)\n{\n\tstruct qedi_dbg_ctx *qedi_dbg = inode->i_private;\n\tstruct qedi_ctx *qedi = container_of(qedi_dbg, struct qedi_ctx,\n\t\t\t\t\t     dbg_ctx);\n\n\treturn single_open(file, qedi_io_trace_show, qedi);\n}\n\nconst struct file_operations qedi_dbg_fops[] = {\n\tqedi_dbg_fileops_seq(qedi, gbl_ctx),\n\tqedi_dbg_fileops(qedi, do_not_recover),\n\tqedi_dbg_fileops_seq(qedi, io_trace),\n\t{ },\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}