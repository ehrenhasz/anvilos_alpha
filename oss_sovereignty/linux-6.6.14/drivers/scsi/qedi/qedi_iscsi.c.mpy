{
  "module_name": "qedi_iscsi.c",
  "hash_id": "55747fc3e6e7934d19419e59dde1a06f67eaec48e1c4c9d6ec85403db6c8000b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedi/qedi_iscsi.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/etherdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"qedi.h\"\n#include \"qedi_iscsi.h\"\n#include \"qedi_gbl.h\"\n\nint qedi_recover_all_conns(struct qedi_ctx *qedi)\n{\n\tstruct qedi_conn *qedi_conn;\n\tint i;\n\n\tfor (i = 0; i < qedi->max_active_conns; i++) {\n\t\tqedi_conn = qedi_get_conn_from_id(qedi, i);\n\t\tif (!qedi_conn)\n\t\t\tcontinue;\n\n\t\tqedi_start_conn_recovery(qedi, qedi_conn);\n\t}\n\n\treturn SUCCESS;\n}\n\nstatic int qedi_eh_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct Scsi_Host *shost = cmd->device->host;\n\tstruct qedi_ctx *qedi;\n\n\tqedi = iscsi_host_priv(shost);\n\n\treturn qedi_recover_all_conns(qedi);\n}\n\nconst struct scsi_host_template qedi_host_template = {\n\t.module = THIS_MODULE,\n\t.name = \"QLogic QEDI 25/40/100Gb iSCSI Initiator Driver\",\n\t.proc_name = QEDI_MODULE_NAME,\n\t.queuecommand = iscsi_queuecommand,\n\t.eh_timed_out = iscsi_eh_cmd_timed_out,\n\t.eh_abort_handler = iscsi_eh_abort,\n\t.eh_device_reset_handler = iscsi_eh_device_reset,\n\t.eh_target_reset_handler = iscsi_eh_recover_target,\n\t.eh_host_reset_handler = qedi_eh_host_reset,\n\t.target_alloc = iscsi_target_alloc,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.can_queue = QEDI_MAX_ISCSI_TASK,\n\t.this_id = -1,\n\t.sg_tablesize = QEDI_ISCSI_MAX_BDS_PER_CMD,\n\t.max_sectors = 0xffff,\n\t.dma_boundary = QEDI_HW_DMA_BOUNDARY,\n\t.cmd_per_lun = 128,\n\t.shost_groups = qedi_shost_groups,\n\t.cmd_size = sizeof(struct iscsi_cmd),\n};\n\nstatic void qedi_conn_free_login_resources(struct qedi_ctx *qedi,\n\t\t\t\t\t   struct qedi_conn *qedi_conn)\n{\n\tif (qedi_conn->gen_pdu.resp_bd_tbl) {\n\t\tdma_free_coherent(&qedi->pdev->dev, QEDI_PAGE_SIZE,\n\t\t\t\t  qedi_conn->gen_pdu.resp_bd_tbl,\n\t\t\t\t  qedi_conn->gen_pdu.resp_bd_dma);\n\t\tqedi_conn->gen_pdu.resp_bd_tbl = NULL;\n\t}\n\n\tif (qedi_conn->gen_pdu.req_bd_tbl) {\n\t\tdma_free_coherent(&qedi->pdev->dev, QEDI_PAGE_SIZE,\n\t\t\t\t  qedi_conn->gen_pdu.req_bd_tbl,\n\t\t\t\t  qedi_conn->gen_pdu.req_bd_dma);\n\t\tqedi_conn->gen_pdu.req_bd_tbl = NULL;\n\t}\n\n\tif (qedi_conn->gen_pdu.resp_buf) {\n\t\tdma_free_coherent(&qedi->pdev->dev,\n\t\t\t\t  ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t  qedi_conn->gen_pdu.resp_buf,\n\t\t\t\t  qedi_conn->gen_pdu.resp_dma_addr);\n\t\tqedi_conn->gen_pdu.resp_buf = NULL;\n\t}\n\n\tif (qedi_conn->gen_pdu.req_buf) {\n\t\tdma_free_coherent(&qedi->pdev->dev,\n\t\t\t\t  ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t  qedi_conn->gen_pdu.req_buf,\n\t\t\t\t  qedi_conn->gen_pdu.req_dma_addr);\n\t\tqedi_conn->gen_pdu.req_buf = NULL;\n\t}\n}\n\nstatic int qedi_conn_alloc_login_resources(struct qedi_ctx *qedi,\n\t\t\t\t\t   struct qedi_conn *qedi_conn)\n{\n\tqedi_conn->gen_pdu.req_buf =\n\t\tdma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t   ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t   &qedi_conn->gen_pdu.req_dma_addr,\n\t\t\t\t   GFP_KERNEL);\n\tif (!qedi_conn->gen_pdu.req_buf)\n\t\tgoto login_req_buf_failure;\n\n\tqedi_conn->gen_pdu.req_buf_size = 0;\n\tqedi_conn->gen_pdu.req_wr_ptr = qedi_conn->gen_pdu.req_buf;\n\n\tqedi_conn->gen_pdu.resp_buf =\n\t\tdma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t   ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t   &qedi_conn->gen_pdu.resp_dma_addr,\n\t\t\t\t   GFP_KERNEL);\n\tif (!qedi_conn->gen_pdu.resp_buf)\n\t\tgoto login_resp_buf_failure;\n\n\tqedi_conn->gen_pdu.resp_buf_size = ISCSI_DEF_MAX_RECV_SEG_LEN;\n\tqedi_conn->gen_pdu.resp_wr_ptr = qedi_conn->gen_pdu.resp_buf;\n\n\tqedi_conn->gen_pdu.req_bd_tbl =\n\t\tdma_alloc_coherent(&qedi->pdev->dev, QEDI_PAGE_SIZE,\n\t\t\t\t   &qedi_conn->gen_pdu.req_bd_dma, GFP_KERNEL);\n\tif (!qedi_conn->gen_pdu.req_bd_tbl)\n\t\tgoto login_req_bd_tbl_failure;\n\n\tqedi_conn->gen_pdu.resp_bd_tbl =\n\t\tdma_alloc_coherent(&qedi->pdev->dev, QEDI_PAGE_SIZE,\n\t\t\t\t   &qedi_conn->gen_pdu.resp_bd_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!qedi_conn->gen_pdu.resp_bd_tbl)\n\t\tgoto login_resp_bd_tbl_failure;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_SESS,\n\t\t  \"Allocation successful, cid=0x%x\\n\",\n\t\t  qedi_conn->iscsi_conn_id);\n\treturn 0;\n\nlogin_resp_bd_tbl_failure:\n\tdma_free_coherent(&qedi->pdev->dev, QEDI_PAGE_SIZE,\n\t\t\t  qedi_conn->gen_pdu.req_bd_tbl,\n\t\t\t  qedi_conn->gen_pdu.req_bd_dma);\n\tqedi_conn->gen_pdu.req_bd_tbl = NULL;\n\nlogin_req_bd_tbl_failure:\n\tdma_free_coherent(&qedi->pdev->dev, ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t  qedi_conn->gen_pdu.resp_buf,\n\t\t\t  qedi_conn->gen_pdu.resp_dma_addr);\n\tqedi_conn->gen_pdu.resp_buf = NULL;\nlogin_resp_buf_failure:\n\tdma_free_coherent(&qedi->pdev->dev, ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t  qedi_conn->gen_pdu.req_buf,\n\t\t\t  qedi_conn->gen_pdu.req_dma_addr);\n\tqedi_conn->gen_pdu.req_buf = NULL;\nlogin_req_buf_failure:\n\tiscsi_conn_printk(KERN_ERR, qedi_conn->cls_conn->dd_data,\n\t\t\t  \"login resource alloc failed!!\\n\");\n\treturn -ENOMEM;\n}\n\nstatic void qedi_destroy_cmd_pool(struct qedi_ctx *qedi,\n\t\t\t\t  struct iscsi_session *session)\n{\n\tint i;\n\n\tfor (i = 0; i < session->cmds_max; i++) {\n\t\tstruct iscsi_task *task = session->cmds[i];\n\t\tstruct qedi_cmd *cmd = task->dd_data;\n\n\t\tif (cmd->io_tbl.sge_tbl)\n\t\t\tdma_free_coherent(&qedi->pdev->dev,\n\t\t\t\t\t  QEDI_ISCSI_MAX_BDS_PER_CMD *\n\t\t\t\t\t  sizeof(struct scsi_sge),\n\t\t\t\t\t  cmd->io_tbl.sge_tbl,\n\t\t\t\t\t  cmd->io_tbl.sge_tbl_dma);\n\n\t\tif (cmd->sense_buffer)\n\t\t\tdma_free_coherent(&qedi->pdev->dev,\n\t\t\t\t\t  SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t  cmd->sense_buffer,\n\t\t\t\t\t  cmd->sense_buffer_dma);\n\t}\n}\n\nstatic int qedi_alloc_sget(struct qedi_ctx *qedi, struct iscsi_session *session,\n\t\t\t   struct qedi_cmd *cmd)\n{\n\tstruct qedi_io_bdt *io = &cmd->io_tbl;\n\tstruct scsi_sge *sge;\n\n\tio->sge_tbl = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t\t QEDI_ISCSI_MAX_BDS_PER_CMD *\n\t\t\t\t\t sizeof(*sge),\n\t\t\t\t\t &io->sge_tbl_dma, GFP_KERNEL);\n\tif (!io->sge_tbl) {\n\t\tiscsi_session_printk(KERN_ERR, session,\n\t\t\t\t     \"Could not allocate BD table.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tio->sge_valid = 0;\n\treturn 0;\n}\n\nstatic int qedi_setup_cmd_pool(struct qedi_ctx *qedi,\n\t\t\t       struct iscsi_session *session)\n{\n\tint i;\n\n\tfor (i = 0; i < session->cmds_max; i++) {\n\t\tstruct iscsi_task *task = session->cmds[i];\n\t\tstruct qedi_cmd *cmd = task->dd_data;\n\n\t\ttask->hdr = &cmd->hdr;\n\t\ttask->hdr_max = sizeof(struct iscsi_hdr);\n\n\t\tif (qedi_alloc_sget(qedi, session, cmd))\n\t\t\tgoto free_sgets;\n\n\t\tcmd->sense_buffer = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t\t\t       SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t\t\t       &cmd->sense_buffer_dma,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!cmd->sense_buffer)\n\t\t\tgoto free_sgets;\n\t}\n\n\treturn 0;\n\nfree_sgets:\n\tqedi_destroy_cmd_pool(qedi, session);\n\treturn -ENOMEM;\n}\n\nstatic struct iscsi_cls_session *\nqedi_session_create(struct iscsi_endpoint *ep, u16 cmds_max,\n\t\t    u16 qdepth, uint32_t initial_cmdsn)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct qedi_ctx *qedi;\n\tstruct qedi_endpoint *qedi_ep;\n\n\tif (!ep)\n\t\treturn NULL;\n\n\tqedi_ep = ep->dd_data;\n\tshost = qedi_ep->qedi->shost;\n\tqedi = iscsi_host_priv(shost);\n\n\tif (cmds_max > qedi->max_sqes)\n\t\tcmds_max = qedi->max_sqes;\n\telse if (cmds_max < QEDI_SQ_WQES_MIN)\n\t\tcmds_max = QEDI_SQ_WQES_MIN;\n\n\tcls_session = iscsi_session_setup(&qedi_iscsi_transport, shost,\n\t\t\t\t\t  cmds_max, 0, sizeof(struct qedi_cmd),\n\t\t\t\t\t  initial_cmdsn, ISCSI_MAX_TARGET);\n\tif (!cls_session) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Failed to setup session for ep=%p\\n\", qedi_ep);\n\t\treturn NULL;\n\t}\n\n\tif (qedi_setup_cmd_pool(qedi, cls_session->dd_data)) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Failed to setup cmd pool for ep=%p\\n\", qedi_ep);\n\t\tgoto session_teardown;\n\t}\n\n\treturn cls_session;\n\nsession_teardown:\n\tiscsi_session_teardown(cls_session);\n\treturn NULL;\n}\n\nstatic void qedi_session_destroy(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\tstruct qedi_ctx *qedi = iscsi_host_priv(shost);\n\n\tqedi_destroy_cmd_pool(qedi, session);\n\tiscsi_session_teardown(cls_session);\n}\n\nstatic struct iscsi_cls_conn *\nqedi_conn_create(struct iscsi_cls_session *cls_session, uint32_t cid)\n{\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\tstruct qedi_ctx *qedi = iscsi_host_priv(shost);\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct qedi_conn *qedi_conn;\n\tstruct iscsi_conn *conn;\n\n\tcls_conn = iscsi_conn_setup(cls_session, sizeof(*qedi_conn),\n\t\t\t\t    cid);\n\tif (!cls_conn) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"conn_new: iscsi conn setup failed, cid=0x%x, cls_sess=%p!\\n\",\n\t\t\t cid, cls_session);\n\t\treturn NULL;\n\t}\n\n\tconn = cls_conn->dd_data;\n\tqedi_conn = conn->dd_data;\n\tqedi_conn->cls_conn = cls_conn;\n\tqedi_conn->qedi = qedi;\n\tqedi_conn->ep = NULL;\n\tqedi_conn->active_cmd_count = 0;\n\tINIT_LIST_HEAD(&qedi_conn->active_cmd_list);\n\tspin_lock_init(&qedi_conn->list_lock);\n\n\tif (qedi_conn_alloc_login_resources(qedi, qedi_conn)) {\n\t\tiscsi_conn_printk(KERN_ALERT, conn,\n\t\t\t\t  \"conn_new: login resc alloc failed, cid=0x%x, cls_sess=%p!!\\n\",\n\t\t\t\t   cid, cls_session);\n\t\tgoto free_conn;\n\t}\n\n\treturn cls_conn;\n\nfree_conn:\n\tiscsi_conn_teardown(cls_conn);\n\treturn NULL;\n}\n\nvoid qedi_mark_device_missing(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct qedi_conn *qedi_conn = session->leadconn->dd_data;\n\n\tspin_lock_bh(&session->frwd_lock);\n\tset_bit(QEDI_BLOCK_IO, &qedi_conn->qedi->flags);\n\tspin_unlock_bh(&session->frwd_lock);\n}\n\nvoid qedi_mark_device_available(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct qedi_conn *qedi_conn = session->leadconn->dd_data;\n\n\tspin_lock_bh(&session->frwd_lock);\n\tclear_bit(QEDI_BLOCK_IO, &qedi_conn->qedi->flags);\n\tspin_unlock_bh(&session->frwd_lock);\n}\n\nstatic int qedi_bind_conn_to_iscsi_cid(struct qedi_ctx *qedi,\n\t\t\t\t       struct qedi_conn *qedi_conn)\n{\n\tu32 iscsi_cid = qedi_conn->iscsi_conn_id;\n\n\tif (qedi->cid_que.conn_cid_tbl[iscsi_cid]) {\n\t\tiscsi_conn_printk(KERN_ALERT, qedi_conn->cls_conn->dd_data,\n\t\t\t\t  \"conn bind - entry #%d not free\\n\",\n\t\t\t\t  iscsi_cid);\n\t\treturn -EBUSY;\n\t}\n\n\tqedi->cid_que.conn_cid_tbl[iscsi_cid] = qedi_conn;\n\treturn 0;\n}\n\nstruct qedi_conn *qedi_get_conn_from_id(struct qedi_ctx *qedi, u32 iscsi_cid)\n{\n\tif (!qedi->cid_que.conn_cid_tbl) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"missing conn<->cid table\\n\");\n\t\treturn NULL;\n\n\t} else if (iscsi_cid >= qedi->max_active_conns) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"wrong cid #%d\\n\", iscsi_cid);\n\t\treturn NULL;\n\t}\n\treturn qedi->cid_que.conn_cid_tbl[iscsi_cid];\n}\n\nstatic int qedi_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t\t  struct iscsi_cls_conn *cls_conn,\n\t\t\t  u64 transport_fd, int is_leading)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\tstruct qedi_ctx *qedi = iscsi_host_priv(shost);\n\tstruct qedi_endpoint *qedi_ep;\n\tstruct iscsi_endpoint *ep;\n\tint rc = 0;\n\n\tep = iscsi_lookup_endpoint(transport_fd);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tqedi_ep = ep->dd_data;\n\tif ((qedi_ep->state == EP_STATE_TCP_FIN_RCVD) ||\n\t    (qedi_ep->state == EP_STATE_TCP_RST_RCVD)) {\n\t\trc = -EINVAL;\n\t\tgoto put_ep;\n\t}\n\n\tif (iscsi_conn_bind(cls_session, cls_conn, is_leading)) {\n\t\trc = -EINVAL;\n\t\tgoto put_ep;\n\t}\n\n\n\tqedi_ep->conn = qedi_conn;\n\tqedi_conn->ep = qedi_ep;\n\tqedi_conn->iscsi_ep = ep;\n\tqedi_conn->iscsi_conn_id = qedi_ep->iscsi_cid;\n\tqedi_conn->fw_cid = qedi_ep->fw_cid;\n\tqedi_conn->cmd_cleanup_req = 0;\n\tatomic_set(&qedi_conn->cmd_cleanup_cmpl, 0);\n\n\tif (qedi_bind_conn_to_iscsi_cid(qedi, qedi_conn)) {\n\t\trc = -EINVAL;\n\t\tgoto put_ep;\n\t}\n\n\n\tspin_lock_init(&qedi_conn->tmf_work_lock);\n\tINIT_LIST_HEAD(&qedi_conn->tmf_work_list);\n\tinit_waitqueue_head(&qedi_conn->wait_queue);\nput_ep:\n\tiscsi_put_endpoint(ep);\n\treturn rc;\n}\n\nstatic int qedi_iscsi_update_conn(struct qedi_ctx *qedi,\n\t\t\t\t  struct qedi_conn *qedi_conn)\n{\n\tstruct qed_iscsi_params_update *conn_info;\n\tstruct iscsi_cls_conn *cls_conn = qedi_conn->cls_conn;\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct qedi_endpoint *qedi_ep;\n\tint rval;\n\n\tqedi_ep = qedi_conn->ep;\n\n\tconn_info = kzalloc(sizeof(*conn_info), GFP_KERNEL);\n\tif (!conn_info) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"memory alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tconn_info->update_flag = 0;\n\n\tif (conn->hdrdgst_en)\n\t\tSET_FIELD(conn_info->update_flag,\n\t\t\t  ISCSI_CONN_UPDATE_RAMROD_PARAMS_HD_EN, true);\n\tif (conn->datadgst_en)\n\t\tSET_FIELD(conn_info->update_flag,\n\t\t\t  ISCSI_CONN_UPDATE_RAMROD_PARAMS_DD_EN, true);\n\tif (conn->session->initial_r2t_en)\n\t\tSET_FIELD(conn_info->update_flag,\n\t\t\t  ISCSI_CONN_UPDATE_RAMROD_PARAMS_INITIAL_R2T,\n\t\t\t  true);\n\tif (conn->session->imm_data_en)\n\t\tSET_FIELD(conn_info->update_flag,\n\t\t\t  ISCSI_CONN_UPDATE_RAMROD_PARAMS_IMMEDIATE_DATA,\n\t\t\t  true);\n\n\tconn_info->max_seq_size = conn->session->max_burst;\n\tconn_info->max_recv_pdu_length = conn->max_recv_dlength;\n\tconn_info->max_send_pdu_length = conn->max_xmit_dlength;\n\tconn_info->first_seq_length = conn->session->first_burst;\n\tconn_info->exp_stat_sn = conn->exp_statsn;\n\n\trval = qedi_ops->update_conn(qedi->cdev, qedi_ep->handle,\n\t\t\t\t     conn_info);\n\tif (rval) {\n\t\trval = -ENXIO;\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Could not update connection\\n\");\n\t}\n\n\tkfree(conn_info);\n\treturn rval;\n}\n\nstatic u16 qedi_calc_mss(u16 pmtu, u8 is_ipv6, u8 tcp_ts_en, u8 vlan_en)\n{\n\tu16 mss = 0;\n\tu16 hdrs = TCP_HDR_LEN;\n\n\tif (is_ipv6)\n\t\thdrs += IPV6_HDR_LEN;\n\telse\n\t\thdrs += IPV4_HDR_LEN;\n\n\tmss = pmtu - hdrs;\n\n\tif (!mss)\n\t\tmss = DEF_MSS;\n\n\treturn mss;\n}\n\nstatic int qedi_iscsi_offload_conn(struct qedi_endpoint *qedi_ep)\n{\n\tstruct qed_iscsi_params_offload *conn_info;\n\tstruct qedi_ctx *qedi = qedi_ep->qedi;\n\tint rval;\n\tint i;\n\n\tconn_info = kzalloc(sizeof(*conn_info), GFP_KERNEL);\n\tif (!conn_info) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Failed to allocate memory ep=%p\\n\", qedi_ep);\n\t\treturn -ENOMEM;\n\t}\n\n\tether_addr_copy(conn_info->src.mac, qedi_ep->src_mac);\n\tether_addr_copy(conn_info->dst.mac, qedi_ep->dst_mac);\n\n\tconn_info->src.ip[0] = ntohl(qedi_ep->src_addr[0]);\n\tconn_info->dst.ip[0] = ntohl(qedi_ep->dst_addr[0]);\n\n\tif (qedi_ep->ip_type == TCP_IPV4) {\n\t\tconn_info->ip_version = 0;\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"After ntohl: src_addr=%pI4, dst_addr=%pI4\\n\",\n\t\t\t  qedi_ep->src_addr, qedi_ep->dst_addr);\n\t} else {\n\t\tfor (i = 1; i < 4; i++) {\n\t\t\tconn_info->src.ip[i] = ntohl(qedi_ep->src_addr[i]);\n\t\t\tconn_info->dst.ip[i] = ntohl(qedi_ep->dst_addr[i]);\n\t\t}\n\n\t\tconn_info->ip_version = 1;\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"After ntohl: src_addr=%pI6, dst_addr=%pI6\\n\",\n\t\t\t  qedi_ep->src_addr, qedi_ep->dst_addr);\n\t}\n\n\tconn_info->src.port = qedi_ep->src_port;\n\tconn_info->dst.port = qedi_ep->dst_port;\n\n\tconn_info->layer_code = ISCSI_SLOW_PATH_LAYER_CODE;\n\tconn_info->sq_pbl_addr = qedi_ep->sq_pbl_dma;\n\tconn_info->vlan_id = qedi_ep->vlan_id;\n\n\tSET_FIELD(conn_info->tcp_flags, TCP_OFFLOAD_PARAMS_TS_EN, 1);\n\tSET_FIELD(conn_info->tcp_flags, TCP_OFFLOAD_PARAMS_DA_EN, 1);\n\tSET_FIELD(conn_info->tcp_flags, TCP_OFFLOAD_PARAMS_DA_CNT_EN, 1);\n\tSET_FIELD(conn_info->tcp_flags, TCP_OFFLOAD_PARAMS_KA_EN, 1);\n\n\tconn_info->default_cq = (qedi_ep->fw_cid % qedi->num_queues);\n\n\tconn_info->ka_max_probe_cnt = DEF_KA_MAX_PROBE_COUNT;\n\tconn_info->dup_ack_theshold = 3;\n\tconn_info->rcv_wnd = 65535;\n\n\tconn_info->ss_thresh = 65535;\n\tconn_info->srtt = 300;\n\tconn_info->rtt_var = 150;\n\tconn_info->flow_label = 0;\n\tconn_info->ka_timeout = DEF_KA_TIMEOUT;\n\tconn_info->ka_interval = DEF_KA_INTERVAL;\n\tconn_info->max_rt_time = DEF_MAX_RT_TIME;\n\tconn_info->ttl = DEF_TTL;\n\tconn_info->tos_or_tc = DEF_TOS;\n\tconn_info->remote_port = qedi_ep->dst_port;\n\tconn_info->local_port = qedi_ep->src_port;\n\n\tconn_info->mss = qedi_calc_mss(qedi_ep->pmtu,\n\t\t\t\t       (qedi_ep->ip_type == TCP_IPV6),\n\t\t\t\t       1, (qedi_ep->vlan_id != 0));\n\n\tconn_info->cwnd = DEF_MAX_CWND * conn_info->mss;\n\tconn_info->rcv_wnd_scale = 4;\n\tconn_info->da_timeout_value = 200;\n\tconn_info->ack_frequency = 2;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"Default cq index [%d], mss [%d]\\n\",\n\t\t  conn_info->default_cq, conn_info->mss);\n\n\t \n\tqedi_ep->db_data.agg_flags = 0;\n\tqedi_ep->db_data.params = 0;\n\tSET_FIELD(qedi_ep->db_data.params, ISCSI_DB_DATA_DEST, DB_DEST_XCM);\n\tSET_FIELD(qedi_ep->db_data.params, ISCSI_DB_DATA_AGG_CMD,\n\t\t  DB_AGG_CMD_MAX);\n\tSET_FIELD(qedi_ep->db_data.params, ISCSI_DB_DATA_AGG_VAL_SEL,\n\t\t  DQ_XCM_ISCSI_SQ_PROD_CMD);\n\tSET_FIELD(qedi_ep->db_data.params, ISCSI_DB_DATA_BYPASS_EN, 1);\n\n\t \n\trval = qedi_ops->common->db_recovery_add(qedi->cdev,\n\t\t\t\t\t\t qedi_ep->p_doorbell,\n\t\t\t\t\t\t &qedi_ep->db_data,\n\t\t\t\t\t\t DB_REC_WIDTH_32B,\n\t\t\t\t\t\t DB_REC_KERNEL);\n\tif (rval) {\n\t\tkfree(conn_info);\n\t\treturn rval;\n\t}\n\n\trval = qedi_ops->offload_conn(qedi->cdev, qedi_ep->handle, conn_info);\n\tif (rval) {\n\t\t \n\t\trval = qedi_ops->common->db_recovery_del(qedi->cdev,\n\t\t\t\t\t\t\t qedi_ep->p_doorbell,\n\t\t\t\t\t\t\t &qedi_ep->db_data);\n\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"offload_conn returned %d, ep=%p\\n\",\n\t\t\t rval, qedi_ep);\n\t}\n\n\tkfree(conn_info);\n\treturn rval;\n}\n\nstatic int qedi_conn_start(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\tstruct qedi_ctx *qedi;\n\tint rval;\n\n\tqedi = qedi_conn->qedi;\n\n\trval = qedi_iscsi_update_conn(qedi, qedi_conn);\n\tif (rval) {\n\t\tiscsi_conn_printk(KERN_ALERT, conn,\n\t\t\t\t  \"conn_start: FW offload conn failed.\\n\");\n\t\trval = -EINVAL;\n\t\tgoto start_err;\n\t}\n\n\tspin_lock(&qedi_conn->tmf_work_lock);\n\tqedi_conn->fw_cleanup_works = 0;\n\tqedi_conn->ep_disconnect_starting = false;\n\tspin_unlock(&qedi_conn->tmf_work_lock);\n\n\tqedi_conn->abrt_conn = 0;\n\n\trval = iscsi_conn_start(cls_conn);\n\tif (rval) {\n\t\tiscsi_conn_printk(KERN_ALERT, conn,\n\t\t\t\t  \"iscsi_conn_start: FW offload conn failed!!\\n\");\n\t}\n\nstart_err:\n\treturn rval;\n}\n\nstatic void qedi_conn_destroy(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\tstruct Scsi_Host *shost;\n\tstruct qedi_ctx *qedi;\n\n\tshost = iscsi_session_to_shost(iscsi_conn_to_session(cls_conn));\n\tqedi = iscsi_host_priv(shost);\n\n\tqedi_conn_free_login_resources(qedi, qedi_conn);\n\tiscsi_conn_teardown(cls_conn);\n}\n\nstatic int qedi_ep_get_param(struct iscsi_endpoint *ep,\n\t\t\t     enum iscsi_param param, char *buf)\n{\n\tstruct qedi_endpoint *qedi_ep = ep->dd_data;\n\tint len;\n\n\tif (!qedi_ep)\n\t\treturn -ENOTCONN;\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\t\tlen = sprintf(buf, \"%hu\\n\", qedi_ep->dst_port);\n\t\tbreak;\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tif (qedi_ep->ip_type == TCP_IPV4)\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", qedi_ep->dst_addr);\n\t\telse\n\t\t\tlen = sprintf(buf, \"%pI6\\n\", qedi_ep->dst_addr);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTCONN;\n\t}\n\n\treturn len;\n}\n\nstatic int qedi_host_get_param(struct Scsi_Host *shost,\n\t\t\t       enum iscsi_host_param param, char *buf)\n{\n\tstruct qedi_ctx *qedi;\n\tint len;\n\n\tqedi = iscsi_host_priv(shost);\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tlen = sysfs_format_mac(buf, qedi->mac, 6);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tlen = sprintf(buf, \"host%d\\n\", shost->host_no);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tif (qedi->ip_type == TCP_IPV4)\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", qedi->src_ip);\n\t\telse\n\t\t\tlen = sprintf(buf, \"%pI6\\n\", qedi->src_ip);\n\t\tbreak;\n\tdefault:\n\t\treturn iscsi_host_get_param(shost, param, buf);\n\t}\n\n\treturn len;\n}\n\nstatic void qedi_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t\tstruct iscsi_stats *stats)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct qed_iscsi_stats iscsi_stats;\n\tstruct Scsi_Host *shost;\n\tstruct qedi_ctx *qedi;\n\n\tshost = iscsi_session_to_shost(iscsi_conn_to_session(cls_conn));\n\tqedi = iscsi_host_priv(shost);\n\tqedi_ops->get_stats(qedi->cdev, &iscsi_stats);\n\n\tconn->txdata_octets = iscsi_stats.iscsi_tx_bytes_cnt;\n\tconn->rxdata_octets = iscsi_stats.iscsi_rx_bytes_cnt;\n\tconn->dataout_pdus_cnt = (uint32_t)iscsi_stats.iscsi_tx_data_pdu_cnt;\n\tconn->datain_pdus_cnt = (uint32_t)iscsi_stats.iscsi_rx_data_pdu_cnt;\n\tconn->r2t_pdus_cnt = (uint32_t)iscsi_stats.iscsi_rx_r2t_pdu_cnt;\n\n\tstats->txdata_octets = conn->txdata_octets;\n\tstats->rxdata_octets = conn->rxdata_octets;\n\tstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\n\tstats->dataout_pdus = conn->dataout_pdus_cnt;\n\tstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\n\tstats->datain_pdus = conn->datain_pdus_cnt;\n\tstats->r2t_pdus = conn->r2t_pdus_cnt;\n\tstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\n\tstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\n\tstats->digest_err = 0;\n\tstats->timeout_err = 0;\n\tstrcpy(stats->custom[0].desc, \"eh_abort_cnt\");\n\tstats->custom[0].value = conn->eh_abort_cnt;\n\tstats->custom_length = 1;\n}\n\nstatic void qedi_iscsi_prep_generic_pdu_bd(struct qedi_conn *qedi_conn)\n{\n\tstruct scsi_sge *bd_tbl;\n\n\tbd_tbl = (struct scsi_sge *)qedi_conn->gen_pdu.req_bd_tbl;\n\n\tbd_tbl->sge_addr.hi =\n\t\t(u32)((u64)qedi_conn->gen_pdu.req_dma_addr >> 32);\n\tbd_tbl->sge_addr.lo = (u32)qedi_conn->gen_pdu.req_dma_addr;\n\tbd_tbl->sge_len = qedi_conn->gen_pdu.req_wr_ptr -\n\t\t\t\tqedi_conn->gen_pdu.req_buf;\n\tbd_tbl = (struct scsi_sge  *)qedi_conn->gen_pdu.resp_bd_tbl;\n\tbd_tbl->sge_addr.hi =\n\t\t\t(u32)((u64)qedi_conn->gen_pdu.resp_dma_addr >> 32);\n\tbd_tbl->sge_addr.lo = (u32)qedi_conn->gen_pdu.resp_dma_addr;\n\tbd_tbl->sge_len = ISCSI_DEF_MAX_RECV_SEG_LEN;\n}\n\nstatic int qedi_iscsi_send_generic_request(struct iscsi_task *task)\n{\n\tstruct qedi_cmd *cmd = task->dd_data;\n\tstruct qedi_conn *qedi_conn = cmd->conn;\n\tchar *buf;\n\tint data_len;\n\tint rc = 0;\n\n\tqedi_iscsi_prep_generic_pdu_bd(qedi_conn);\n\tswitch (task->hdr->opcode & ISCSI_OPCODE_MASK) {\n\tcase ISCSI_OP_LOGIN:\n\t\tqedi_send_iscsi_login(qedi_conn, task);\n\t\tbreak;\n\tcase ISCSI_OP_NOOP_OUT:\n\t\tdata_len = qedi_conn->gen_pdu.req_buf_size;\n\t\tbuf = qedi_conn->gen_pdu.req_buf;\n\t\tif (data_len)\n\t\t\trc = qedi_send_iscsi_nopout(qedi_conn, task,\n\t\t\t\t\t\t    buf, data_len, 1);\n\t\telse\n\t\t\trc = qedi_send_iscsi_nopout(qedi_conn, task,\n\t\t\t\t\t\t    NULL, 0, 1);\n\t\tbreak;\n\tcase ISCSI_OP_LOGOUT:\n\t\trc = qedi_send_iscsi_logout(qedi_conn, task);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_TMFUNC:\n\t\trc = qedi_send_iscsi_tmf(qedi_conn, task);\n\t\tbreak;\n\tcase ISCSI_OP_TEXT:\n\t\trc = qedi_send_iscsi_text(qedi_conn, task);\n\t\tbreak;\n\tdefault:\n\t\tiscsi_conn_printk(KERN_ALERT, qedi_conn->cls_conn->dd_data,\n\t\t\t\t  \"unsupported op 0x%x\\n\", task->hdr->opcode);\n\t}\n\n\treturn rc;\n}\n\nstatic int qedi_mtask_xmit(struct iscsi_conn *conn, struct iscsi_task *task)\n{\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\tstruct qedi_cmd *cmd = task->dd_data;\n\n\tmemset(qedi_conn->gen_pdu.req_buf, 0, ISCSI_DEF_MAX_RECV_SEG_LEN);\n\n\tqedi_conn->gen_pdu.req_buf_size = task->data_count;\n\n\tif (task->data_count) {\n\t\tmemcpy(qedi_conn->gen_pdu.req_buf, task->data,\n\t\t       task->data_count);\n\t\tqedi_conn->gen_pdu.req_wr_ptr =\n\t\t\tqedi_conn->gen_pdu.req_buf + task->data_count;\n\t}\n\n\tcmd->conn = conn->dd_data;\n\treturn qedi_iscsi_send_generic_request(task);\n}\n\nstatic int qedi_task_xmit(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\tstruct qedi_cmd *cmd = task->dd_data;\n\tstruct scsi_cmnd *sc = task->sc;\n\n\t \n\tcmd->scsi_cmd = NULL;\n\tcmd->task_id = U16_MAX;\n\n\tif (test_bit(QEDI_IN_SHUTDOWN, &qedi_conn->qedi->flags))\n\t\treturn -ENODEV;\n\n\tif (test_bit(QEDI_BLOCK_IO, &qedi_conn->qedi->flags))\n\t\treturn -EACCES;\n\n\tcmd->state = 0;\n\tcmd->task = NULL;\n\tcmd->use_slowpath = false;\n\tcmd->conn = qedi_conn;\n\tcmd->task = task;\n\tcmd->io_cmd_in_list = false;\n\tINIT_LIST_HEAD(&cmd->io_cmd);\n\n\tif (!sc)\n\t\treturn qedi_mtask_xmit(conn, task);\n\n\tcmd->scsi_cmd = sc;\n\treturn qedi_iscsi_send_ioreq(task);\n}\n\nstatic void qedi_offload_work(struct work_struct *work)\n{\n\tstruct qedi_endpoint *qedi_ep =\n\t\tcontainer_of(work, struct qedi_endpoint, offload_work);\n\tstruct qedi_ctx *qedi;\n\tint wait_delay = 5 * HZ;\n\tint ret;\n\n\tqedi = qedi_ep->qedi;\n\n\tret = qedi_iscsi_offload_conn(qedi_ep);\n\tif (ret) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"offload error: iscsi_cid=%u, qedi_ep=%p, ret=%d\\n\",\n\t\t\t qedi_ep->iscsi_cid, qedi_ep, ret);\n\t\tqedi_ep->state = EP_STATE_OFLDCONN_FAILED;\n\t\treturn;\n\t}\n\n\tret = wait_event_interruptible_timeout(qedi_ep->tcp_ofld_wait,\n\t\t\t\t\t       (qedi_ep->state ==\n\t\t\t\t\t       EP_STATE_OFLDCONN_COMPL),\n\t\t\t\t\t       wait_delay);\n\tif (ret <= 0 || qedi_ep->state != EP_STATE_OFLDCONN_COMPL) {\n\t\tqedi_ep->state = EP_STATE_OFLDCONN_FAILED;\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Offload conn TIMEOUT iscsi_cid=%u, qedi_ep=%p\\n\",\n\t\t\t qedi_ep->iscsi_cid, qedi_ep);\n\t}\n}\n\nstatic struct iscsi_endpoint *\nqedi_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\n\t\tint non_blocking)\n{\n\tstruct qedi_ctx *qedi;\n\tstruct iscsi_endpoint *ep;\n\tstruct qedi_endpoint *qedi_ep;\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tstruct iscsi_path path_req;\n\tu32 msg_type = ISCSI_KEVENT_IF_DOWN;\n\tu32 iscsi_cid = QEDI_CID_RESERVED;\n\tu16 len = 0;\n\tchar *buf = NULL;\n\tint ret, tmp;\n\n\tif (!shost) {\n\t\tret = -ENXIO;\n\t\tQEDI_ERR(NULL, \"shost is NULL\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (qedi_do_not_recover) {\n\t\tret = -ENOMEM;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tqedi = iscsi_host_priv(shost);\n\n\tif (test_bit(QEDI_IN_OFFLINE, &qedi->flags) ||\n\t    test_bit(QEDI_IN_RECOVERY, &qedi->flags)) {\n\t\tret = -ENOMEM;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (atomic_read(&qedi->link_state) != QEDI_LINK_UP) {\n\t\tQEDI_WARN(&qedi->dbg_ctx, \"qedi link down\\n\");\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\tep = iscsi_create_endpoint(sizeof(struct qedi_endpoint));\n\tif (!ep) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"endpoint create fail\\n\");\n\t\tret = -ENOMEM;\n\t\treturn ERR_PTR(ret);\n\t}\n\tqedi_ep = ep->dd_data;\n\tmemset(qedi_ep, 0, sizeof(struct qedi_endpoint));\n\tINIT_WORK(&qedi_ep->offload_work, qedi_offload_work);\n\tqedi_ep->state = EP_STATE_IDLE;\n\tqedi_ep->iscsi_cid = (u32)-1;\n\tqedi_ep->qedi = qedi;\n\n\tif (dst_addr->sa_family == AF_INET) {\n\t\taddr = (struct sockaddr_in *)dst_addr;\n\t\tmemcpy(qedi_ep->dst_addr, &addr->sin_addr.s_addr,\n\t\t       sizeof(struct in_addr));\n\t\tqedi_ep->dst_port = ntohs(addr->sin_port);\n\t\tqedi_ep->ip_type = TCP_IPV4;\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"dst_addr=%pI4, dst_port=%u\\n\",\n\t\t\t  qedi_ep->dst_addr, qedi_ep->dst_port);\n\t} else if (dst_addr->sa_family == AF_INET6) {\n\t\taddr6 = (struct sockaddr_in6 *)dst_addr;\n\t\tmemcpy(qedi_ep->dst_addr, &addr6->sin6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\tqedi_ep->dst_port = ntohs(addr6->sin6_port);\n\t\tqedi_ep->ip_type = TCP_IPV6;\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"dst_addr=%pI6, dst_port=%u\\n\",\n\t\t\t  qedi_ep->dst_addr, qedi_ep->dst_port);\n\t} else {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Invalid endpoint\\n\");\n\t}\n\n\tret = qedi_alloc_sq(qedi, qedi_ep);\n\tif (ret)\n\t\tgoto ep_conn_exit;\n\n\tret = qedi_ops->acquire_conn(qedi->cdev, &qedi_ep->handle,\n\t\t\t\t     &qedi_ep->fw_cid, &qedi_ep->p_doorbell);\n\n\tif (ret) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Could not acquire connection\\n\");\n\t\tret = -ENXIO;\n\t\tgoto ep_free_sq;\n\t}\n\n\tiscsi_cid = qedi_ep->handle;\n\tqedi_ep->iscsi_cid = iscsi_cid;\n\n\tinit_waitqueue_head(&qedi_ep->ofld_wait);\n\tinit_waitqueue_head(&qedi_ep->tcp_ofld_wait);\n\tqedi_ep->state = EP_STATE_OFLDCONN_START;\n\tqedi->ep_tbl[iscsi_cid] = qedi_ep;\n\n\tbuf = (char *)&path_req;\n\tlen = sizeof(path_req);\n\tmemset(&path_req, 0, len);\n\n\tmsg_type = ISCSI_KEVENT_PATH_REQ;\n\tpath_req.handle = (u64)qedi_ep->iscsi_cid;\n\tpath_req.pmtu = qedi->ll2_mtu;\n\tqedi_ep->pmtu = qedi->ll2_mtu;\n\tif (qedi_ep->ip_type == TCP_IPV4) {\n\t\tmemcpy(&path_req.dst.v4_addr, &qedi_ep->dst_addr,\n\t\t       sizeof(struct in_addr));\n\t\tpath_req.ip_addr_len = 4;\n\t} else {\n\t\tmemcpy(&path_req.dst.v6_addr, &qedi_ep->dst_addr,\n\t\t       sizeof(struct in6_addr));\n\t\tpath_req.ip_addr_len = 16;\n\t}\n\n\tret = iscsi_offload_mesg(shost, &qedi_iscsi_transport, msg_type, buf,\n\t\t\t\t len);\n\tif (ret) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"iscsi_offload_mesg() failed for cid=0x%x ret=%d\\n\",\n\t\t\t iscsi_cid, ret);\n\t\tgoto ep_rel_conn;\n\t}\n\n\tatomic_inc(&qedi->num_offloads);\n\treturn ep;\n\nep_rel_conn:\n\tqedi->ep_tbl[iscsi_cid] = NULL;\n\ttmp = qedi_ops->release_conn(qedi->cdev, qedi_ep->handle);\n\tif (tmp)\n\t\tQEDI_WARN(&qedi->dbg_ctx, \"release_conn returned %d\\n\",\n\t\t\t  tmp);\nep_free_sq:\n\tqedi_free_sq(qedi, qedi_ep);\nep_conn_exit:\n\tiscsi_destroy_endpoint(ep);\n\treturn ERR_PTR(ret);\n}\n\nstatic int qedi_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\n{\n\tstruct qedi_endpoint *qedi_ep;\n\tint ret = 0;\n\n\tif (qedi_do_not_recover)\n\t\treturn 1;\n\n\tqedi_ep = ep->dd_data;\n\tif (qedi_ep->state == EP_STATE_IDLE ||\n\t    qedi_ep->state == EP_STATE_OFLDCONN_NONE ||\n\t    qedi_ep->state == EP_STATE_OFLDCONN_FAILED)\n\t\treturn -1;\n\n\tif (qedi_ep->state == EP_STATE_OFLDCONN_COMPL)\n\t\tret = 1;\n\n\tret = wait_event_interruptible_timeout(qedi_ep->ofld_wait,\n\t\t\t\t\t       QEDI_OFLD_WAIT_STATE(qedi_ep),\n\t\t\t\t\t       msecs_to_jiffies(timeout_ms));\n\n\tif (qedi_ep->state == EP_STATE_OFLDCONN_FAILED)\n\t\tret = -1;\n\n\tif (ret > 0)\n\t\treturn 1;\n\telse if (!ret)\n\t\treturn 0;\n\telse\n\t\treturn ret;\n}\n\nstatic void qedi_cleanup_active_cmd_list(struct qedi_conn *qedi_conn)\n{\n\tstruct qedi_cmd *cmd, *cmd_tmp;\n\n\tspin_lock(&qedi_conn->list_lock);\n\tlist_for_each_entry_safe(cmd, cmd_tmp, &qedi_conn->active_cmd_list,\n\t\t\t\t io_cmd) {\n\t\tlist_del_init(&cmd->io_cmd);\n\t\tqedi_conn->active_cmd_count--;\n\t}\n\tspin_unlock(&qedi_conn->list_lock);\n}\n\nstatic void qedi_ep_disconnect(struct iscsi_endpoint *ep)\n{\n\tstruct qedi_endpoint *qedi_ep;\n\tstruct qedi_conn *qedi_conn = NULL;\n\tstruct qedi_ctx *qedi;\n\tint ret = 0;\n\tint wait_delay;\n\tint abrt_conn = 0;\n\n\twait_delay = 60 * HZ + DEF_MAX_RT_TIME;\n\tqedi_ep = ep->dd_data;\n\tqedi = qedi_ep->qedi;\n\n\tflush_work(&qedi_ep->offload_work);\n\n\tif (qedi_ep->state == EP_STATE_OFLDCONN_START)\n\t\tgoto ep_exit_recover;\n\n\tif (qedi_ep->conn) {\n\t\tqedi_conn = qedi_ep->conn;\n\t\tabrt_conn = qedi_conn->abrt_conn;\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"cid=0x%x qedi_ep=%p waiting for %d tmfs\\n\",\n\t\t\t  qedi_ep->iscsi_cid, qedi_ep,\n\t\t\t  qedi_conn->fw_cleanup_works);\n\n\t\tspin_lock(&qedi_conn->tmf_work_lock);\n\t\tqedi_conn->ep_disconnect_starting = true;\n\t\twhile (qedi_conn->fw_cleanup_works > 0) {\n\t\t\tspin_unlock(&qedi_conn->tmf_work_lock);\n\t\t\tmsleep(1000);\n\t\t\tspin_lock(&qedi_conn->tmf_work_lock);\n\t\t}\n\t\tspin_unlock(&qedi_conn->tmf_work_lock);\n\n\t\tif (test_bit(QEDI_IN_RECOVERY, &qedi->flags)) {\n\t\t\tif (qedi_do_not_recover) {\n\t\t\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t\t\t  \"Do not recover cid=0x%x\\n\",\n\t\t\t\t\t  qedi_ep->iscsi_cid);\n\t\t\t\tgoto ep_exit_recover;\n\t\t\t}\n\t\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t\t  \"Reset recovery cid=0x%x, qedi_ep=%p, state=0x%x\\n\",\n\t\t\t\t  qedi_ep->iscsi_cid, qedi_ep, qedi_ep->state);\n\t\t\tqedi_cleanup_active_cmd_list(qedi_conn);\n\t\t\tgoto ep_release_conn;\n\t\t}\n\t}\n\n\tif (qedi_do_not_recover)\n\t\tgoto ep_exit_recover;\n\n\tswitch (qedi_ep->state) {\n\tcase EP_STATE_OFLDCONN_START:\n\tcase EP_STATE_OFLDCONN_NONE:\n\t\tgoto ep_release_conn;\n\tcase EP_STATE_OFLDCONN_FAILED:\n\t\t\tbreak;\n\tcase EP_STATE_OFLDCONN_COMPL:\n\t\tif (unlikely(!qedi_conn))\n\t\t\tbreak;\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"Active cmd count=%d, abrt_conn=%d, ep state=0x%x, cid=0x%x, qedi_conn=%p\\n\",\n\t\t\t  qedi_conn->active_cmd_count, abrt_conn,\n\t\t\t  qedi_ep->state,\n\t\t\t  qedi_ep->iscsi_cid,\n\t\t\t  qedi_ep->conn\n\t\t\t  );\n\n\t\tif (!qedi_conn->active_cmd_count)\n\t\t\tabrt_conn = 0;\n\t\telse\n\t\t\tabrt_conn = 1;\n\n\t\tif (abrt_conn)\n\t\t\tqedi_clearsq(qedi, qedi_conn, NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!abrt_conn)\n\t\twait_delay += qedi->pf_params.iscsi_pf_params.two_msl_timer;\n\n\tqedi_ep->state = EP_STATE_DISCONN_START;\n\n\tif (test_bit(QEDI_IN_SHUTDOWN, &qedi->flags) ||\n\t    test_bit(QEDI_IN_RECOVERY, &qedi->flags))\n\t\tgoto ep_release_conn;\n\n\t \n\tret = qedi_ops->common->db_recovery_del(qedi->cdev,\n\t\t\t\t\t       qedi_ep->p_doorbell,\n\t\t\t\t\t       &qedi_ep->db_data);\n\n\tret = qedi_ops->destroy_conn(qedi->cdev, qedi_ep->handle, abrt_conn);\n\tif (ret) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"destroy_conn failed returned %d\\n\", ret);\n\t} else {\n\t\tret = wait_event_interruptible_timeout(\n\t\t\t\t\tqedi_ep->tcp_ofld_wait,\n\t\t\t\t\t(qedi_ep->state !=\n\t\t\t\t\t EP_STATE_DISCONN_START),\n\t\t\t\t\twait_delay);\n\t\tif ((ret <= 0) || (qedi_ep->state == EP_STATE_DISCONN_START)) {\n\t\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t\t  \"Destroy conn timedout or interrupted, ret=%d, delay=%d, cid=0x%x\\n\",\n\t\t\t\t  ret, wait_delay, qedi_ep->iscsi_cid);\n\t\t}\n\t}\n\nep_release_conn:\n\tret = qedi_ops->release_conn(qedi->cdev, qedi_ep->handle);\n\tif (ret)\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"release_conn returned %d, cid=0x%x\\n\",\n\t\t\t  ret, qedi_ep->iscsi_cid);\nep_exit_recover:\n\tqedi_ep->state = EP_STATE_IDLE;\n\tqedi->ep_tbl[qedi_ep->iscsi_cid] = NULL;\n\tqedi->cid_que.conn_cid_tbl[qedi_ep->iscsi_cid] = NULL;\n\tqedi_free_id(&qedi->lcl_port_tbl, qedi_ep->src_port);\n\tqedi_free_sq(qedi, qedi_ep);\n\n\tif (qedi_conn)\n\t\tqedi_conn->ep = NULL;\n\n\tqedi_ep->conn = NULL;\n\tqedi_ep->qedi = NULL;\n\tatomic_dec(&qedi->num_offloads);\n\n\tiscsi_destroy_endpoint(ep);\n}\n\nstatic int qedi_data_avail(struct qedi_ctx *qedi, u16 vlanid)\n{\n\tstruct qed_dev *cdev = qedi->cdev;\n\tstruct qedi_uio_dev *udev;\n\tstruct qedi_uio_ctrl *uctrl;\n\tstruct sk_buff *skb;\n\tu32 len;\n\tint rc = 0;\n\n\tudev = qedi->udev;\n\tif (!udev) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"udev is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tuctrl = (struct qedi_uio_ctrl *)udev->uctrl;\n\tif (!uctrl) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"uctlr is NULL.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlen = uctrl->host_tx_pkt_len;\n\tif (!len) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Invalid len %u\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"alloc_skb failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tskb_put(skb, len);\n\tmemcpy(skb->data, udev->tx_pkt, len);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tif (vlanid)\n\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vlanid);\n\n\trc = qedi_ops->ll2->start_xmit(cdev, skb, 0);\n\tif (rc) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"ll2 start_xmit returned %d\\n\",\n\t\t\t rc);\n\t\tkfree_skb(skb);\n\t}\n\n\tuctrl->host_tx_pkt_len = 0;\n\tuctrl->hw_tx_cons++;\n\n\treturn rc;\n}\n\nstatic int qedi_set_path(struct Scsi_Host *shost, struct iscsi_path *path_data)\n{\n\tstruct qedi_ctx *qedi;\n\tstruct qedi_endpoint *qedi_ep;\n\tint ret = 0;\n\tu32 iscsi_cid;\n\tu16 port_id = 0;\n\n\tif (!shost) {\n\t\tret = -ENXIO;\n\t\tQEDI_ERR(NULL, \"shost is NULL\\n\");\n\t\treturn ret;\n\t}\n\n\tif (strcmp(shost->hostt->proc_name, \"qedi\")) {\n\t\tret = -ENXIO;\n\t\tQEDI_ERR(NULL, \"shost %s is invalid\\n\",\n\t\t\t shost->hostt->proc_name);\n\t\treturn ret;\n\t}\n\n\tqedi = iscsi_host_priv(shost);\n\tif (path_data->handle == QEDI_PATH_HANDLE) {\n\t\tret = qedi_data_avail(qedi, path_data->vlan_id);\n\t\tgoto set_path_exit;\n\t}\n\n\tiscsi_cid = (u32)path_data->handle;\n\tif (iscsi_cid >= qedi->max_active_conns) {\n\t\tret = -EINVAL;\n\t\tgoto set_path_exit;\n\t}\n\tqedi_ep = qedi->ep_tbl[iscsi_cid];\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"iscsi_cid=0x%x, qedi_ep=%p\\n\", iscsi_cid, qedi_ep);\n\tif (!qedi_ep) {\n\t\tret = -EINVAL;\n\t\tgoto set_path_exit;\n\t}\n\n\tif (!is_valid_ether_addr(&path_data->mac_addr[0])) {\n\t\tQEDI_NOTICE(&qedi->dbg_ctx, \"dst mac NOT VALID\\n\");\n\t\tqedi_ep->state = EP_STATE_OFLDCONN_NONE;\n\t\tret = -EIO;\n\t\tgoto set_path_exit;\n\t}\n\n\tether_addr_copy(&qedi_ep->src_mac[0], &qedi->mac[0]);\n\tether_addr_copy(&qedi_ep->dst_mac[0], &path_data->mac_addr[0]);\n\n\tqedi_ep->vlan_id = path_data->vlan_id;\n\tif (path_data->pmtu < DEF_PATH_MTU) {\n\t\tqedi_ep->pmtu = qedi->ll2_mtu;\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"MTU cannot be %u, using default MTU %u\\n\",\n\t\t\t   path_data->pmtu, qedi_ep->pmtu);\n\t}\n\n\tif (path_data->pmtu != qedi->ll2_mtu) {\n\t\tif (path_data->pmtu > JUMBO_MTU) {\n\t\t\tret = -EINVAL;\n\t\t\tQEDI_ERR(NULL, \"Invalid MTU %u\\n\", path_data->pmtu);\n\t\t\tgoto set_path_exit;\n\t\t}\n\n\t\tqedi_reset_host_mtu(qedi, path_data->pmtu);\n\t\tqedi_ep->pmtu = qedi->ll2_mtu;\n\t}\n\n\tport_id = qedi_ep->src_port;\n\tif (port_id >= QEDI_LOCAL_PORT_MIN &&\n\t    port_id < QEDI_LOCAL_PORT_MAX) {\n\t\tif (qedi_alloc_id(&qedi->lcl_port_tbl, port_id))\n\t\t\tport_id = 0;\n\t} else {\n\t\tport_id = 0;\n\t}\n\n\tif (!port_id) {\n\t\tport_id = qedi_alloc_new_id(&qedi->lcl_port_tbl);\n\t\tif (port_id == QEDI_LOCAL_PORT_INVALID) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Failed to allocate port id for iscsi_cid=0x%x\\n\",\n\t\t\t\t iscsi_cid);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto set_path_exit;\n\t\t}\n\t}\n\n\tqedi_ep->src_port = port_id;\n\n\tif (qedi_ep->ip_type == TCP_IPV4) {\n\t\tmemcpy(&qedi_ep->src_addr[0], &path_data->src.v4_addr,\n\t\t       sizeof(struct in_addr));\n\t\tmemcpy(&qedi->src_ip[0], &path_data->src.v4_addr,\n\t\t       sizeof(struct in_addr));\n\t\tqedi->ip_type = TCP_IPV4;\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"src addr:port=%pI4:%u, dst addr:port=%pI4:%u\\n\",\n\t\t\t  qedi_ep->src_addr, qedi_ep->src_port,\n\t\t\t  qedi_ep->dst_addr, qedi_ep->dst_port);\n\t} else {\n\t\tmemcpy(&qedi_ep->src_addr[0], &path_data->src.v6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(&qedi->src_ip[0], &path_data->src.v6_addr,\n\t\t       sizeof(struct in6_addr));\n\t\tqedi->ip_type = TCP_IPV6;\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"src addr:port=%pI6:%u, dst addr:port=%pI6:%u\\n\",\n\t\t\t  qedi_ep->src_addr, qedi_ep->src_port,\n\t\t\t  qedi_ep->dst_addr, qedi_ep->dst_port);\n\t}\n\n\tqueue_work(qedi->offload_thread, &qedi_ep->offload_work);\n\n\tret = 0;\n\nset_path_exit:\n\treturn ret;\n}\n\nstatic umode_t qedi_attr_is_visible(int param_type, int param)\n{\n\tswitch (param_type) {\n\tcase ISCSI_HOST_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tcase ISCSI_PARAM_CONN_PORT:\n\t\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tcase ISCSI_PARAM_PING_TMO:\n\t\tcase ISCSI_PARAM_RECV_TMO:\n\t\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_PARAM_MAX_R2T:\n\t\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tcase ISCSI_PARAM_MAX_BURST:\n\t\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_PARAM_ERL:\n\t\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tcase ISCSI_PARAM_TPGT:\n\t\tcase ISCSI_PARAM_USERNAME:\n\t\tcase ISCSI_PARAM_PASSWORD:\n\t\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\tcase ISCSI_PARAM_BOOT_ROOT:\n\t\tcase ISCSI_PARAM_BOOT_NIC:\n\t\tcase ISCSI_PARAM_BOOT_TARGET:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void qedi_cleanup_task(struct iscsi_task *task)\n{\n\tstruct qedi_cmd *cmd;\n\n\tif (task->state == ISCSI_TASK_PENDING) {\n\t\tQEDI_INFO(NULL, QEDI_LOG_IO, \"Returning ref_cnt=%d\\n\",\n\t\t\t  refcount_read(&task->refcount));\n\t\treturn;\n\t}\n\n\tif (task->sc)\n\t\tqedi_iscsi_unmap_sg_list(task->dd_data);\n\n\tcmd = task->dd_data;\n\tif (cmd->task_id != U16_MAX)\n\t\tqedi_clear_task_idx(iscsi_host_priv(task->conn->session->host),\n\t\t\t\t    cmd->task_id);\n\n\tcmd->task_id = U16_MAX;\n\tcmd->scsi_cmd = NULL;\n}\n\nstruct iscsi_transport qedi_iscsi_transport = {\n\t.owner = THIS_MODULE,\n\t.name = QEDI_MODULE_NAME,\n\t.caps = CAP_RECOVERY_L0 | CAP_HDRDGST | CAP_MULTI_R2T | CAP_DATADGST |\n\t\tCAP_DATA_PATH_OFFLOAD | CAP_TEXT_NEGO,\n\t.create_session = qedi_session_create,\n\t.destroy_session = qedi_session_destroy,\n\t.create_conn = qedi_conn_create,\n\t.bind_conn = qedi_conn_bind,\n\t.unbind_conn = iscsi_conn_unbind,\n\t.start_conn = qedi_conn_start,\n\t.stop_conn = iscsi_conn_stop,\n\t.destroy_conn = qedi_conn_destroy,\n\t.set_param = iscsi_set_param,\n\t.get_ep_param = qedi_ep_get_param,\n\t.get_conn_param = iscsi_conn_get_param,\n\t.get_session_param = iscsi_session_get_param,\n\t.get_host_param = qedi_host_get_param,\n\t.send_pdu = iscsi_conn_send_pdu,\n\t.get_stats = qedi_conn_get_stats,\n\t.xmit_task = qedi_task_xmit,\n\t.cleanup_task = qedi_cleanup_task,\n\t.session_recovery_timedout = iscsi_session_recovery_timedout,\n\t.ep_connect = qedi_ep_connect,\n\t.ep_poll = qedi_ep_poll,\n\t.ep_disconnect = qedi_ep_disconnect,\n\t.set_path = qedi_set_path,\n\t.attr_is_visible = qedi_attr_is_visible,\n};\n\nvoid qedi_start_conn_recovery(struct qedi_ctx *qedi,\n\t\t\t      struct qedi_conn *qedi_conn)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_conn *conn;\n\n\tcls_conn = qedi_conn->cls_conn;\n\tconn = cls_conn->dd_data;\n\tcls_sess = iscsi_conn_to_session(cls_conn);\n\n\tif (iscsi_is_session_online(cls_sess)) {\n\t\tqedi_conn->abrt_conn = 1;\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Failing connection, state=0x%x, cid=0x%x\\n\",\n\t\t\t conn->session->state, qedi_conn->iscsi_conn_id);\n\t\tiscsi_conn_failure(qedi_conn->cls_conn->dd_data,\n\t\t\t\t   ISCSI_ERR_CONN_FAILED);\n\t}\n}\n\nstatic const struct {\n\tenum iscsi_error_types error_code;\n\tchar *err_string;\n} qedi_iscsi_error[] = {\n\t{ ISCSI_STATUS_NONE,\n\t  \"tcp_error none\"\n\t},\n\t{ ISCSI_CONN_ERROR_TASK_CID_MISMATCH,\n\t  \"task cid mismatch\"\n\t},\n\t{ ISCSI_CONN_ERROR_TASK_NOT_VALID,\n\t  \"invalid task\"\n\t},\n\t{ ISCSI_CONN_ERROR_RQ_RING_IS_FULL,\n\t  \"rq ring full\"\n\t},\n\t{ ISCSI_CONN_ERROR_CMDQ_RING_IS_FULL,\n\t  \"cmdq ring full\"\n\t},\n\t{ ISCSI_CONN_ERROR_HQE_CACHING_FAILED,\n\t  \"sge caching failed\"\n\t},\n\t{ ISCSI_CONN_ERROR_HEADER_DIGEST_ERROR,\n\t  \"hdr digest error\"\n\t},\n\t{ ISCSI_CONN_ERROR_LOCAL_COMPLETION_ERROR,\n\t  \"local cmpl error\"\n\t},\n\t{ ISCSI_CONN_ERROR_DATA_OVERRUN,\n\t  \"invalid task\"\n\t},\n\t{ ISCSI_CONN_ERROR_OUT_OF_SGES_ERROR,\n\t  \"out of sge error\"\n\t},\n\t{ ISCSI_CONN_ERROR_TCP_IP_FRAGMENT_ERROR,\n\t  \"tcp ip fragment error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_AHS_LEN,\n\t  \"AHS len protocol error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_ITT_OUT_OF_RANGE,\n\t  \"itt out of range error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_DATA_SEG_LEN_EXCEEDS_PDU_SIZE,\n\t  \"data seg more than pdu size\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_INVALID_OPCODE,\n\t  \"invalid opcode\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_INVALID_OPCODE_BEFORE_UPDATE,\n\t  \"invalid opcode before update\"\n\t},\n\t{ ISCSI_CONN_ERROR_UNVALID_NOPIN_DSL,\n\t  \"unexpected opcode\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_R2T_CARRIES_NO_DATA,\n\t  \"r2t carries no data\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_DATA_SN,\n\t  \"data sn error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_DATA_IN_TTT,\n\t  \"data TTT error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_R2T_TTT,\n\t  \"r2t TTT error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_R2T_BUFFER_OFFSET,\n\t  \"buffer offset error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_BUFFER_OFFSET_OOO,\n\t  \"buffer offset ooo\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_R2T_SN,\n\t  \"data seg len 0\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_DESIRED_DATA_TRNS_LEN_0,\n\t  \"data xer len error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_DESIRED_DATA_TRNS_LEN_1,\n\t  \"data xer len1 error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_DESIRED_DATA_TRNS_LEN_2,\n\t  \"data xer len2 error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_LUN,\n\t  \"protocol lun error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_F_BIT_ZERO,\n\t  \"f bit zero error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_EXP_STAT_SN,\n\t  \"exp stat sn error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_DSL_NOT_ZERO,\n\t  \"dsl not zero error\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_INVALID_DSL,\n\t  \"invalid dsl\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_DATA_SEG_LEN_TOO_BIG,\n\t  \"data seg len too big\"\n\t},\n\t{ ISCSI_CONN_ERROR_PROTOCOL_ERR_OUTSTANDING_R2T_COUNT,\n\t  \"outstanding r2t count error\"\n\t},\n\t{ ISCSI_CONN_ERROR_SENSE_DATA_LENGTH,\n\t  \"sense datalen error\"\n\t},\n};\n\nstatic char *qedi_get_iscsi_error(enum iscsi_error_types err_code)\n{\n\tint i;\n\tchar *msg = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(qedi_iscsi_error); i++) {\n\t\tif (qedi_iscsi_error[i].error_code == err_code) {\n\t\t\tmsg = qedi_iscsi_error[i].err_string;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn msg;\n}\n\nvoid qedi_process_iscsi_error(struct qedi_endpoint *ep,\n\t\t\t      struct iscsi_eqe_data *data)\n{\n\tstruct qedi_conn *qedi_conn;\n\tstruct qedi_ctx *qedi;\n\tchar warn_notice[] = \"iscsi_warning\";\n\tchar error_notice[] = \"iscsi_error\";\n\tchar unknown_msg[] = \"Unknown error\";\n\tchar *message;\n\tint need_recovery = 0;\n\tu32 err_mask = 0;\n\tchar *msg;\n\n\tif (!ep)\n\t\treturn;\n\n\tqedi_conn = ep->conn;\n\tif (!qedi_conn)\n\t\treturn;\n\n\tqedi = ep->qedi;\n\n\tQEDI_ERR(&qedi->dbg_ctx, \"async event iscsi error:0x%x\\n\",\n\t\t data->error_code);\n\n\tif (err_mask) {\n\t\tneed_recovery = 0;\n\t\tmessage = warn_notice;\n\t} else {\n\t\tneed_recovery = 1;\n\t\tmessage = error_notice;\n\t}\n\n\tmsg = qedi_get_iscsi_error(data->error_code);\n\tif (!msg) {\n\t\tneed_recovery = 0;\n\t\tmsg = unknown_msg;\n\t}\n\n\tiscsi_conn_printk(KERN_ALERT,\n\t\t\t  qedi_conn->cls_conn->dd_data,\n\t\t\t  \"qedi: %s - %s\\n\", message, msg);\n\n\tif (need_recovery)\n\t\tqedi_start_conn_recovery(qedi_conn->qedi, qedi_conn);\n}\n\nvoid qedi_process_tcp_error(struct qedi_endpoint *ep,\n\t\t\t    struct iscsi_eqe_data *data)\n{\n\tstruct qedi_conn *qedi_conn;\n\n\tif (!ep)\n\t\treturn;\n\n\tqedi_conn = ep->conn;\n\tif (!qedi_conn)\n\t\treturn;\n\n\tQEDI_ERR(&ep->qedi->dbg_ctx, \"async event TCP error:0x%x\\n\",\n\t\t data->error_code);\n\n\tqedi_start_conn_recovery(qedi_conn->qedi, qedi_conn);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}