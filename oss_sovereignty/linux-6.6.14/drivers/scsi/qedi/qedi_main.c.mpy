{
  "module_name": "qedi_main.c",
  "hash_id": "9a948487785a9948717b1a8b1b0bc1874f6e925296b16346da10fb7114592ab7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qedi/qedi_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <scsi/iscsi_if.h>\n#include <linux/inet.h>\n#include <net/arp.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/if_vlan.h>\n#include <linux/cpu.h>\n#include <linux/iscsi_boot_sysfs.h>\n\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n\n#include \"qedi.h\"\n#include \"qedi_gbl.h\"\n#include \"qedi_iscsi.h\"\n\nstatic uint qedi_qed_debug;\nmodule_param(qedi_qed_debug, uint, 0644);\nMODULE_PARM_DESC(qedi_qed_debug, \" QED debug level 0 (default)\");\n\nstatic uint qedi_fw_debug;\nmodule_param(qedi_fw_debug, uint, 0644);\nMODULE_PARM_DESC(qedi_fw_debug, \" Firmware debug level 0(default) to 3\");\n\nuint qedi_dbg_log = QEDI_LOG_WARN | QEDI_LOG_SCSI_TM;\nmodule_param(qedi_dbg_log, uint, 0644);\nMODULE_PARM_DESC(qedi_dbg_log, \" Default debug level\");\n\nuint qedi_io_tracing;\nmodule_param(qedi_io_tracing, uint, 0644);\nMODULE_PARM_DESC(qedi_io_tracing,\n\t\t \" Enable logging of SCSI requests/completions into trace buffer. (default off).\");\n\nstatic uint qedi_ll2_buf_size = 0x400;\nmodule_param(qedi_ll2_buf_size, uint, 0644);\nMODULE_PARM_DESC(qedi_ll2_buf_size,\n\t\t \"parameter to set ping packet size, default - 0x400, Jumbo packets - 0x2400.\");\n\nstatic uint qedi_flags_override;\nmodule_param(qedi_flags_override, uint, 0644);\nMODULE_PARM_DESC(qedi_flags_override, \"Disable/Enable MFW error flags bits action.\");\n\nconst struct qed_iscsi_ops *qedi_ops;\nstatic struct scsi_transport_template *qedi_scsi_transport;\nstatic struct pci_driver qedi_pci_driver;\nstatic DEFINE_PER_CPU(struct qedi_percpu_s, qedi_percpu);\nstatic LIST_HEAD(qedi_udev_list);\n \nstatic int qedi_alloc_global_queues(struct qedi_ctx *qedi);\nstatic void qedi_free_global_queues(struct qedi_ctx *qedi);\nstatic struct qedi_cmd *qedi_get_cmd_from_tid(struct qedi_ctx *qedi, u32 tid);\nstatic void qedi_reset_uio_rings(struct qedi_uio_dev *udev);\nstatic void qedi_ll2_free_skbs(struct qedi_ctx *qedi);\nstatic struct nvm_iscsi_block *qedi_get_nvram_block(struct qedi_ctx *qedi);\nstatic void qedi_recovery_handler(struct work_struct *work);\nstatic void qedi_schedule_hw_err_handler(void *dev,\n\t\t\t\t\t enum qed_hw_err_type err_type);\nstatic int qedi_suspend(struct pci_dev *pdev, pm_message_t state);\n\nstatic int qedi_iscsi_event_cb(void *context, u8 fw_event_code, void *fw_handle)\n{\n\tstruct qedi_ctx *qedi;\n\tstruct qedi_endpoint *qedi_ep;\n\tstruct iscsi_eqe_data *data;\n\tint rval = 0;\n\n\tif (!context || !fw_handle) {\n\t\tQEDI_ERR(NULL, \"Recv event with ctx NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqedi = (struct qedi_ctx *)context;\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"Recv Event %d fw_handle %p\\n\", fw_event_code, fw_handle);\n\n\tdata = (struct iscsi_eqe_data *)fw_handle;\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"icid=0x%x conn_id=0x%x err-code=0x%x error-pdu-opcode-reserved=0x%x\\n\",\n\t\t   data->icid, data->conn_id, data->error_code,\n\t\t   data->error_pdu_opcode_reserved);\n\n\tqedi_ep = qedi->ep_tbl[data->icid];\n\n\tif (!qedi_ep) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"Cannot process event, ep already disconnected, cid=0x%x\\n\",\n\t\t\t   data->icid);\n\t\tWARN_ON(1);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (fw_event_code) {\n\tcase ISCSI_EVENT_TYPE_ASYN_CONNECT_COMPLETE:\n\t\tif (qedi_ep->state == EP_STATE_OFLDCONN_START)\n\t\t\tqedi_ep->state = EP_STATE_OFLDCONN_COMPL;\n\n\t\twake_up_interruptible(&qedi_ep->tcp_ofld_wait);\n\t\tbreak;\n\tcase ISCSI_EVENT_TYPE_ASYN_TERMINATE_DONE:\n\t\tqedi_ep->state = EP_STATE_DISCONN_COMPL;\n\t\twake_up_interruptible(&qedi_ep->tcp_ofld_wait);\n\t\tbreak;\n\tcase ISCSI_EVENT_TYPE_ISCSI_CONN_ERROR:\n\t\tqedi_process_iscsi_error(qedi_ep, data);\n\t\tbreak;\n\tcase ISCSI_EVENT_TYPE_ASYN_ABORT_RCVD:\n\tcase ISCSI_EVENT_TYPE_ASYN_SYN_RCVD:\n\tcase ISCSI_EVENT_TYPE_ASYN_MAX_RT_TIME:\n\tcase ISCSI_EVENT_TYPE_ASYN_MAX_RT_CNT:\n\tcase ISCSI_EVENT_TYPE_ASYN_MAX_KA_PROBES_CNT:\n\tcase ISCSI_EVENT_TYPE_ASYN_FIN_WAIT2:\n\tcase ISCSI_EVENT_TYPE_TCP_CONN_ERROR:\n\t\tqedi_process_tcp_error(qedi_ep, data);\n\t\tbreak;\n\tdefault:\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Recv Unknown Event %u\\n\",\n\t\t\t fw_event_code);\n\t}\n\n\treturn rval;\n}\n\nstatic int qedi_uio_open(struct uio_info *uinfo, struct inode *inode)\n{\n\tstruct qedi_uio_dev *udev = uinfo->priv;\n\tstruct qedi_ctx *qedi = udev->qedi;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (udev->uio_dev != -1)\n\t\treturn -EBUSY;\n\n\trtnl_lock();\n\tudev->uio_dev = iminor(inode);\n\tqedi_reset_uio_rings(udev);\n\tset_bit(UIO_DEV_OPENED, &qedi->flags);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic int qedi_uio_close(struct uio_info *uinfo, struct inode *inode)\n{\n\tstruct qedi_uio_dev *udev = uinfo->priv;\n\tstruct qedi_ctx *qedi = udev->qedi;\n\n\tudev->uio_dev = -1;\n\tclear_bit(UIO_DEV_OPENED, &qedi->flags);\n\tqedi_ll2_free_skbs(qedi);\n\treturn 0;\n}\n\nstatic void __qedi_free_uio_rings(struct qedi_uio_dev *udev)\n{\n\tif (udev->uctrl) {\n\t\tfree_page((unsigned long)udev->uctrl);\n\t\tudev->uctrl = NULL;\n\t}\n\n\tif (udev->ll2_ring) {\n\t\tfree_page((unsigned long)udev->ll2_ring);\n\t\tudev->ll2_ring = NULL;\n\t}\n\n\tif (udev->ll2_buf) {\n\t\tfree_pages((unsigned long)udev->ll2_buf, 2);\n\t\tudev->ll2_buf = NULL;\n\t}\n}\n\nstatic void __qedi_free_uio(struct qedi_uio_dev *udev)\n{\n\tuio_unregister_device(&udev->qedi_uinfo);\n\n\t__qedi_free_uio_rings(udev);\n\n\tpci_dev_put(udev->pdev);\n\tkfree(udev);\n}\n\nstatic void qedi_free_uio(struct qedi_uio_dev *udev)\n{\n\tif (!udev)\n\t\treturn;\n\n\tlist_del_init(&udev->list);\n\t__qedi_free_uio(udev);\n}\n\nstatic void qedi_reset_uio_rings(struct qedi_uio_dev *udev)\n{\n\tstruct qedi_ctx *qedi = NULL;\n\tstruct qedi_uio_ctrl *uctrl = NULL;\n\n\tqedi = udev->qedi;\n\tuctrl = udev->uctrl;\n\n\tspin_lock_bh(&qedi->ll2_lock);\n\tuctrl->host_rx_cons = 0;\n\tuctrl->hw_rx_prod = 0;\n\tuctrl->hw_rx_bd_prod = 0;\n\tuctrl->host_rx_bd_cons = 0;\n\n\tmemset(udev->ll2_ring, 0, udev->ll2_ring_size);\n\tmemset(udev->ll2_buf, 0, udev->ll2_buf_size);\n\tspin_unlock_bh(&qedi->ll2_lock);\n}\n\nstatic int __qedi_alloc_uio_rings(struct qedi_uio_dev *udev)\n{\n\tint rc = 0;\n\n\tif (udev->ll2_ring || udev->ll2_buf)\n\t\treturn rc;\n\n\t \n\tudev->uctrl = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!udev->uctrl)\n\t\treturn -ENOMEM;\n\n\t \n\tudev->ll2_ring_size = QEDI_PAGE_SIZE;\n\tudev->ll2_ring = (void *)get_zeroed_page(GFP_KERNEL | __GFP_COMP);\n\tif (!udev->ll2_ring) {\n\t\trc = -ENOMEM;\n\t\tgoto exit_alloc_ring;\n\t}\n\n\t \n\tudev->ll2_buf_size = TX_RX_RING * qedi_ll2_buf_size;\n\tudev->ll2_buf_size = QEDI_PAGE_ALIGN(udev->ll2_buf_size);\n\tudev->ll2_buf = (void *)__get_free_pages(GFP_KERNEL | __GFP_COMP |\n\t\t\t\t\t\t __GFP_ZERO, 2);\n\tif (!udev->ll2_buf) {\n\t\trc = -ENOMEM;\n\t\tgoto exit_alloc_buf;\n\t}\n\treturn rc;\n\nexit_alloc_buf:\n\tfree_page((unsigned long)udev->ll2_ring);\n\tudev->ll2_ring = NULL;\nexit_alloc_ring:\n\treturn rc;\n}\n\nstatic int qedi_alloc_uio_rings(struct qedi_ctx *qedi)\n{\n\tstruct qedi_uio_dev *udev = NULL;\n\tint rc = 0;\n\n\tlist_for_each_entry(udev, &qedi_udev_list, list) {\n\t\tif (udev->pdev == qedi->pdev) {\n\t\t\tudev->qedi = qedi;\n\t\t\tif (__qedi_alloc_uio_rings(udev)) {\n\t\t\t\tudev->qedi = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tqedi->udev = udev;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tudev = kzalloc(sizeof(*udev), GFP_KERNEL);\n\tif (!udev)\n\t\tgoto err_udev;\n\n\tudev->uio_dev = -1;\n\n\tudev->qedi = qedi;\n\tudev->pdev = qedi->pdev;\n\n\trc = __qedi_alloc_uio_rings(udev);\n\tif (rc)\n\t\tgoto err_uctrl;\n\n\tlist_add(&udev->list, &qedi_udev_list);\n\n\tpci_dev_get(udev->pdev);\n\tqedi->udev = udev;\n\n\tudev->tx_pkt = udev->ll2_buf;\n\tudev->rx_pkt = udev->ll2_buf + qedi_ll2_buf_size;\n\treturn 0;\n\n err_uctrl:\n\tkfree(udev);\n err_udev:\n\treturn -ENOMEM;\n}\n\nstatic int qedi_init_uio(struct qedi_ctx *qedi)\n{\n\tstruct qedi_uio_dev *udev = qedi->udev;\n\tstruct uio_info *uinfo;\n\tint ret = 0;\n\n\tif (!udev)\n\t\treturn -ENOMEM;\n\n\tuinfo = &udev->qedi_uinfo;\n\n\tuinfo->mem[0].addr = (unsigned long)udev->uctrl;\n\tuinfo->mem[0].size = sizeof(struct qedi_uio_ctrl);\n\tuinfo->mem[0].memtype = UIO_MEM_LOGICAL;\n\n\tuinfo->mem[1].addr = (unsigned long)udev->ll2_ring;\n\tuinfo->mem[1].size = udev->ll2_ring_size;\n\tuinfo->mem[1].memtype = UIO_MEM_LOGICAL;\n\n\tuinfo->mem[2].addr = (unsigned long)udev->ll2_buf;\n\tuinfo->mem[2].size = udev->ll2_buf_size;\n\tuinfo->mem[2].memtype = UIO_MEM_LOGICAL;\n\n\tuinfo->name = \"qedi_uio\";\n\tuinfo->version = QEDI_MODULE_VERSION;\n\tuinfo->irq = UIO_IRQ_CUSTOM;\n\n\tuinfo->open = qedi_uio_open;\n\tuinfo->release = qedi_uio_close;\n\n\tif (udev->uio_dev == -1) {\n\t\tif (!uinfo->priv) {\n\t\t\tuinfo->priv = udev;\n\n\t\t\tret = uio_register_device(&udev->pdev->dev, uinfo);\n\t\t\tif (ret) {\n\t\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t\t \"UIO registration failed\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int qedi_alloc_and_init_sb(struct qedi_ctx *qedi,\n\t\t\t\t  struct qed_sb_info *sb_info, u16 sb_id)\n{\n\tstruct status_block *sb_virt;\n\tdma_addr_t sb_phys;\n\tint ret;\n\n\tsb_virt = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t     sizeof(struct status_block), &sb_phys,\n\t\t\t\t     GFP_KERNEL);\n\tif (!sb_virt) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Status block allocation failed for id = %d.\\n\",\n\t\t\t  sb_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = qedi_ops->common->sb_init(qedi->cdev, sb_info, sb_virt, sb_phys,\n\t\t\t\t       sb_id, QED_SB_TYPE_STORAGE);\n\tif (ret) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Status block initialization failed for id = %d.\\n\",\n\t\t\t  sb_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void qedi_free_sb(struct qedi_ctx *qedi)\n{\n\tstruct qed_sb_info *sb_info;\n\tint id;\n\n\tfor (id = 0; id < MIN_NUM_CPUS_MSIX(qedi); id++) {\n\t\tsb_info = &qedi->sb_array[id];\n\t\tif (sb_info->sb_virt)\n\t\t\tdma_free_coherent(&qedi->pdev->dev,\n\t\t\t\t\t  sizeof(*sb_info->sb_virt),\n\t\t\t\t\t  (void *)sb_info->sb_virt,\n\t\t\t\t\t  sb_info->sb_phys);\n\t}\n}\n\nstatic void qedi_free_fp(struct qedi_ctx *qedi)\n{\n\tkfree(qedi->fp_array);\n\tkfree(qedi->sb_array);\n}\n\nstatic void qedi_destroy_fp(struct qedi_ctx *qedi)\n{\n\tqedi_free_sb(qedi);\n\tqedi_free_fp(qedi);\n}\n\nstatic int qedi_alloc_fp(struct qedi_ctx *qedi)\n{\n\tint ret = 0;\n\n\tqedi->fp_array = kcalloc(MIN_NUM_CPUS_MSIX(qedi),\n\t\t\t\t sizeof(struct qedi_fastpath), GFP_KERNEL);\n\tif (!qedi->fp_array) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"fastpath fp array allocation failed.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tqedi->sb_array = kcalloc(MIN_NUM_CPUS_MSIX(qedi),\n\t\t\t\t sizeof(struct qed_sb_info), GFP_KERNEL);\n\tif (!qedi->sb_array) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"fastpath sb array allocation failed.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_fp;\n\t}\n\n\treturn ret;\n\nfree_fp:\n\tqedi_free_fp(qedi);\n\treturn ret;\n}\n\nstatic void qedi_int_fp(struct qedi_ctx *qedi)\n{\n\tstruct qedi_fastpath *fp;\n\tint id;\n\n\tmemset(qedi->fp_array, 0, MIN_NUM_CPUS_MSIX(qedi) *\n\t       sizeof(*qedi->fp_array));\n\tmemset(qedi->sb_array, 0, MIN_NUM_CPUS_MSIX(qedi) *\n\t       sizeof(*qedi->sb_array));\n\n\tfor (id = 0; id < MIN_NUM_CPUS_MSIX(qedi); id++) {\n\t\tfp = &qedi->fp_array[id];\n\t\tfp->sb_info = &qedi->sb_array[id];\n\t\tfp->sb_id = id;\n\t\tfp->qedi = qedi;\n\t\tsnprintf(fp->name, sizeof(fp->name), \"%s-fp-%d\",\n\t\t\t \"qedi\", id);\n\n\t\t \n\t}\n}\n\nstatic int qedi_prepare_fp(struct qedi_ctx *qedi)\n{\n\tstruct qedi_fastpath *fp;\n\tint id, ret = 0;\n\n\tret = qedi_alloc_fp(qedi);\n\tif (ret)\n\t\tgoto err;\n\n\tqedi_int_fp(qedi);\n\n\tfor (id = 0; id < MIN_NUM_CPUS_MSIX(qedi); id++) {\n\t\tfp = &qedi->fp_array[id];\n\t\tret = qedi_alloc_and_init_sb(qedi, fp->sb_info, fp->sb_id);\n\t\tif (ret) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"SB allocation and initialization failed.\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto err_init;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_init:\n\tqedi_free_sb(qedi);\n\tqedi_free_fp(qedi);\nerr:\n\treturn ret;\n}\n\nstatic int qedi_setup_cid_que(struct qedi_ctx *qedi)\n{\n\tint i;\n\n\tqedi->cid_que.cid_que_base = kmalloc_array(qedi->max_active_conns,\n\t\t\t\t\t\t   sizeof(u32), GFP_KERNEL);\n\tif (!qedi->cid_que.cid_que_base)\n\t\treturn -ENOMEM;\n\n\tqedi->cid_que.conn_cid_tbl = kmalloc_array(qedi->max_active_conns,\n\t\t\t\t\t\t   sizeof(struct qedi_conn *),\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!qedi->cid_que.conn_cid_tbl) {\n\t\tkfree(qedi->cid_que.cid_que_base);\n\t\tqedi->cid_que.cid_que_base = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tqedi->cid_que.cid_que = (u32 *)qedi->cid_que.cid_que_base;\n\tqedi->cid_que.cid_q_prod_idx = 0;\n\tqedi->cid_que.cid_q_cons_idx = 0;\n\tqedi->cid_que.cid_q_max_idx = qedi->max_active_conns;\n\tqedi->cid_que.cid_free_cnt = qedi->max_active_conns;\n\n\tfor (i = 0; i < qedi->max_active_conns; i++) {\n\t\tqedi->cid_que.cid_que[i] = i;\n\t\tqedi->cid_que.conn_cid_tbl[i] = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void qedi_release_cid_que(struct qedi_ctx *qedi)\n{\n\tkfree(qedi->cid_que.cid_que_base);\n\tqedi->cid_que.cid_que_base = NULL;\n\n\tkfree(qedi->cid_que.conn_cid_tbl);\n\tqedi->cid_que.conn_cid_tbl = NULL;\n}\n\nstatic int qedi_init_id_tbl(struct qedi_portid_tbl *id_tbl, u16 size,\n\t\t\t    u16 start_id, u16 next)\n{\n\tid_tbl->start = start_id;\n\tid_tbl->max = size;\n\tid_tbl->next = next;\n\tspin_lock_init(&id_tbl->lock);\n\tid_tbl->table = kcalloc(BITS_TO_LONGS(size), sizeof(long), GFP_KERNEL);\n\tif (!id_tbl->table)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void qedi_free_id_tbl(struct qedi_portid_tbl *id_tbl)\n{\n\tkfree(id_tbl->table);\n\tid_tbl->table = NULL;\n}\n\nint qedi_alloc_id(struct qedi_portid_tbl *id_tbl, u16 id)\n{\n\tint ret = -1;\n\n\tid -= id_tbl->start;\n\tif (id >= id_tbl->max)\n\t\treturn ret;\n\n\tspin_lock(&id_tbl->lock);\n\tif (!test_bit(id, id_tbl->table)) {\n\t\tset_bit(id, id_tbl->table);\n\t\tret = 0;\n\t}\n\tspin_unlock(&id_tbl->lock);\n\treturn ret;\n}\n\nu16 qedi_alloc_new_id(struct qedi_portid_tbl *id_tbl)\n{\n\tu16 id;\n\n\tspin_lock(&id_tbl->lock);\n\tid = find_next_zero_bit(id_tbl->table, id_tbl->max, id_tbl->next);\n\tif (id >= id_tbl->max) {\n\t\tid = QEDI_LOCAL_PORT_INVALID;\n\t\tif (id_tbl->next != 0) {\n\t\t\tid = find_first_zero_bit(id_tbl->table, id_tbl->next);\n\t\t\tif (id >= id_tbl->next)\n\t\t\t\tid = QEDI_LOCAL_PORT_INVALID;\n\t\t}\n\t}\n\n\tif (id < id_tbl->max) {\n\t\tset_bit(id, id_tbl->table);\n\t\tid_tbl->next = (id + 1) & (id_tbl->max - 1);\n\t\tid += id_tbl->start;\n\t}\n\n\tspin_unlock(&id_tbl->lock);\n\n\treturn id;\n}\n\nvoid qedi_free_id(struct qedi_portid_tbl *id_tbl, u16 id)\n{\n\tif (id == QEDI_LOCAL_PORT_INVALID)\n\t\treturn;\n\n\tid -= id_tbl->start;\n\tif (id >= id_tbl->max)\n\t\treturn;\n\n\tclear_bit(id, id_tbl->table);\n}\n\nstatic void qedi_cm_free_mem(struct qedi_ctx *qedi)\n{\n\tkfree(qedi->ep_tbl);\n\tqedi->ep_tbl = NULL;\n\tqedi_free_id_tbl(&qedi->lcl_port_tbl);\n}\n\nstatic int qedi_cm_alloc_mem(struct qedi_ctx *qedi)\n{\n\tu16 port_id;\n\n\tqedi->ep_tbl = kzalloc((qedi->max_active_conns *\n\t\t\t\tsizeof(struct qedi_endpoint *)), GFP_KERNEL);\n\tif (!qedi->ep_tbl)\n\t\treturn -ENOMEM;\n\tport_id = get_random_u32_below(QEDI_LOCAL_PORT_RANGE);\n\tif (qedi_init_id_tbl(&qedi->lcl_port_tbl, QEDI_LOCAL_PORT_RANGE,\n\t\t\t     QEDI_LOCAL_PORT_MIN, port_id)) {\n\t\tqedi_cm_free_mem(qedi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic struct qedi_ctx *qedi_host_alloc(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct qedi_ctx *qedi = NULL;\n\n\tshost = iscsi_host_alloc(&qedi_host_template,\n\t\t\t\t sizeof(struct qedi_ctx), 0);\n\tif (!shost) {\n\t\tQEDI_ERR(NULL, \"Could not allocate shost\\n\");\n\t\tgoto exit_setup_shost;\n\t}\n\n\tshost->max_id = QEDI_MAX_ISCSI_CONNS_PER_HBA - 1;\n\tshost->max_channel = 0;\n\tshost->max_lun = ~0;\n\tshost->max_cmd_len = 16;\n\tshost->transportt = qedi_scsi_transport;\n\n\tqedi = iscsi_host_priv(shost);\n\tmemset(qedi, 0, sizeof(*qedi));\n\tqedi->shost = shost;\n\tqedi->dbg_ctx.host_no = shost->host_no;\n\tqedi->pdev = pdev;\n\tqedi->dbg_ctx.pdev = pdev;\n\tqedi->max_active_conns = ISCSI_MAX_SESS_PER_HBA;\n\tqedi->max_sqes = QEDI_SQ_SIZE;\n\n\tshost->nr_hw_queues = MIN_NUM_CPUS_MSIX(qedi);\n\n\tpci_set_drvdata(pdev, qedi);\n\nexit_setup_shost:\n\treturn qedi;\n}\n\nstatic int qedi_ll2_rx(void *cookie, struct sk_buff *skb, u32 arg1, u32 arg2)\n{\n\tstruct qedi_ctx *qedi = (struct qedi_ctx *)cookie;\n\tstruct skb_work_list *work;\n\tstruct ethhdr *eh;\n\n\tif (!qedi) {\n\t\tQEDI_ERR(NULL, \"qedi is NULL\\n\");\n\t\treturn -1;\n\t}\n\n\tif (!test_bit(UIO_DEV_OPENED, &qedi->flags)) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_UIO,\n\t\t\t  \"UIO DEV is not opened\\n\");\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\teh = (struct ethhdr *)skb->data;\n\t \n\tif (eh->h_proto == htons(ETH_P_8021Q)) {\n\t\tmemmove((u8 *)eh + VLAN_HLEN, eh, ETH_ALEN * 2);\n\t\teh = (struct ethhdr *)skb_pull(skb, VLAN_HLEN);\n\t\tskb_reset_mac_header(skb);\n\t}\n\n\t \n\tif (eh->h_proto != htons(ETH_P_ARP) &&\n\t    eh->h_proto != htons(ETH_P_IP) &&\n\t    eh->h_proto != htons(ETH_P_IPV6)) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_LL2,\n\t\t\t  \"Dropping frame ethertype [0x%x] len [0x%x].\\n\",\n\t\t\t  eh->h_proto, skb->len);\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_LL2,\n\t\t  \"Allowed frame ethertype [0x%x] len [0x%x].\\n\",\n\t\t  eh->h_proto, skb->len);\n\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"Could not allocate work so dropping frame.\\n\");\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tINIT_LIST_HEAD(&work->list);\n\twork->skb = skb;\n\n\tif (skb_vlan_tag_present(skb))\n\t\twork->vlan_id = skb_vlan_tag_get(skb);\n\n\tif (work->vlan_id)\n\t\t__vlan_insert_tag(work->skb, htons(ETH_P_8021Q), work->vlan_id);\n\n\tspin_lock_bh(&qedi->ll2_lock);\n\tlist_add_tail(&work->list, &qedi->ll2_skb_list);\n\tspin_unlock_bh(&qedi->ll2_lock);\n\n\twake_up_process(qedi->ll2_recv_thread);\n\n\treturn 0;\n}\n\n \nstatic int qedi_ll2_process_skb(struct qedi_ctx *qedi, struct sk_buff *skb,\n\t\t\t\tu16 vlan_id)\n{\n\tstruct qedi_uio_dev *udev = NULL;\n\tstruct qedi_uio_ctrl *uctrl = NULL;\n\tstruct qedi_rx_bd rxbd;\n\tstruct qedi_rx_bd *p_rxbd;\n\tu32 rx_bd_prod;\n\tvoid *pkt;\n\tint len = 0;\n\tu32 prod;\n\n\tif (!qedi) {\n\t\tQEDI_ERR(NULL, \"qedi is NULL\\n\");\n\t\treturn -1;\n\t}\n\n\tudev = qedi->udev;\n\tuctrl = udev->uctrl;\n\n\t++uctrl->hw_rx_prod_cnt;\n\tprod = (uctrl->hw_rx_prod + 1) % RX_RING;\n\n\tpkt = udev->rx_pkt + (prod * qedi_ll2_buf_size);\n\tlen = min_t(u32, skb->len, (u32)qedi_ll2_buf_size);\n\tmemcpy(pkt, skb->data, len);\n\n\tmemset(&rxbd, 0, sizeof(rxbd));\n\trxbd.rx_pkt_index = prod;\n\trxbd.rx_pkt_len = len;\n\trxbd.vlan_id = vlan_id;\n\n\tuctrl->hw_rx_bd_prod = (uctrl->hw_rx_bd_prod + 1) % QEDI_NUM_RX_BD;\n\trx_bd_prod = uctrl->hw_rx_bd_prod;\n\tp_rxbd = (struct qedi_rx_bd *)udev->ll2_ring;\n\tp_rxbd += rx_bd_prod;\n\n\tmemcpy(p_rxbd, &rxbd, sizeof(rxbd));\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_LL2,\n\t\t  \"hw_rx_prod [%d] prod [%d] hw_rx_bd_prod [%d] rx_pkt_idx [%d] rx_len [%d].\\n\",\n\t\t  uctrl->hw_rx_prod, prod, uctrl->hw_rx_bd_prod,\n\t\t  rxbd.rx_pkt_index, rxbd.rx_pkt_len);\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_LL2,\n\t\t  \"host_rx_cons [%d] hw_rx_bd_cons [%d].\\n\",\n\t\t  uctrl->host_rx_cons, uctrl->host_rx_bd_cons);\n\n\tuctrl->hw_rx_prod = prod;\n\n\t \n\tuio_event_notify(&udev->qedi_uinfo);\n\n\treturn 0;\n}\n\nstatic void qedi_ll2_free_skbs(struct qedi_ctx *qedi)\n{\n\tstruct skb_work_list *work, *work_tmp;\n\n\tspin_lock_bh(&qedi->ll2_lock);\n\tlist_for_each_entry_safe(work, work_tmp, &qedi->ll2_skb_list, list) {\n\t\tlist_del(&work->list);\n\t\tkfree_skb(work->skb);\n\t\tkfree(work);\n\t}\n\tspin_unlock_bh(&qedi->ll2_lock);\n}\n\nstatic int qedi_ll2_recv_thread(void *arg)\n{\n\tstruct qedi_ctx *qedi = (struct qedi_ctx *)arg;\n\tstruct skb_work_list *work, *work_tmp;\n\n\tset_user_nice(current, -20);\n\n\twhile (!kthread_should_stop()) {\n\t\tspin_lock_bh(&qedi->ll2_lock);\n\t\tlist_for_each_entry_safe(work, work_tmp, &qedi->ll2_skb_list,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&work->list);\n\t\t\tqedi_ll2_process_skb(qedi, work->skb, work->vlan_id);\n\t\t\tkfree_skb(work->skb);\n\t\t\tkfree(work);\n\t\t}\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock_bh(&qedi->ll2_lock);\n\t\tschedule();\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\treturn 0;\n}\n\nstatic int qedi_set_iscsi_pf_param(struct qedi_ctx *qedi)\n{\n\tu8 num_sq_pages;\n\tu32 log_page_size;\n\tint rval = 0;\n\n\n\tnum_sq_pages = (MAX_OUTSTANDING_TASKS_PER_CON * 8) / QEDI_PAGE_SIZE;\n\n\tqedi->num_queues = MIN_NUM_CPUS_MSIX(qedi);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"Number of CQ count is %d\\n\", qedi->num_queues);\n\n\tmemset(&qedi->pf_params.iscsi_pf_params, 0,\n\t       sizeof(qedi->pf_params.iscsi_pf_params));\n\n\tqedi->p_cpuq = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\tqedi->num_queues * sizeof(struct qedi_glbl_q_params),\n\t\t\t&qedi->hw_p_cpuq, GFP_KERNEL);\n\tif (!qedi->p_cpuq) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"dma_alloc_coherent fail\\n\");\n\t\trval = -1;\n\t\tgoto err_alloc_mem;\n\t}\n\n\trval = qedi_alloc_global_queues(qedi);\n\tif (rval) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Global queue allocation failed.\\n\");\n\t\trval = -1;\n\t\tgoto err_alloc_mem;\n\t}\n\n\tqedi->pf_params.iscsi_pf_params.num_cons = QEDI_MAX_ISCSI_CONNS_PER_HBA;\n\tqedi->pf_params.iscsi_pf_params.num_tasks = QEDI_MAX_ISCSI_TASK;\n\tqedi->pf_params.iscsi_pf_params.half_way_close_timeout = 10;\n\tqedi->pf_params.iscsi_pf_params.num_sq_pages_in_ring = num_sq_pages;\n\tqedi->pf_params.iscsi_pf_params.num_r2tq_pages_in_ring = num_sq_pages;\n\tqedi->pf_params.iscsi_pf_params.num_uhq_pages_in_ring = num_sq_pages;\n\tqedi->pf_params.iscsi_pf_params.num_queues = qedi->num_queues;\n\tqedi->pf_params.iscsi_pf_params.debug_mode = qedi_fw_debug;\n\tqedi->pf_params.iscsi_pf_params.two_msl_timer = QED_TWO_MSL_TIMER_DFLT;\n\tqedi->pf_params.iscsi_pf_params.tx_sws_timer = QED_TX_SWS_TIMER_DFLT;\n\tqedi->pf_params.iscsi_pf_params.max_fin_rt = 2;\n\n\tfor (log_page_size = 0 ; log_page_size < 32 ; log_page_size++) {\n\t\tif ((1 << log_page_size) == QEDI_PAGE_SIZE)\n\t\t\tbreak;\n\t}\n\tqedi->pf_params.iscsi_pf_params.log_page_size = log_page_size;\n\n\tqedi->pf_params.iscsi_pf_params.glbl_q_params_addr =\n\t\t\t\t\t\t\t   (u64)qedi->hw_p_cpuq;\n\n\t \n\tqedi->pf_params.iscsi_pf_params.rqe_log_size = 8;\n\t \n\tqedi->pf_params.iscsi_pf_params.bdq_pbl_base_addr[BDQ_ID_RQ] =\n\t\t\t\t\t\t\tqedi->bdq_pbl_list_dma;\n\tqedi->pf_params.iscsi_pf_params.bdq_pbl_num_entries[BDQ_ID_RQ] =\n\t\t\t\t\t\tqedi->bdq_pbl_list_num_entries;\n\tqedi->pf_params.iscsi_pf_params.rq_buffer_size = QEDI_BDQ_BUF_SIZE;\n\n\t \n\tqedi->pf_params.iscsi_pf_params.cq_num_entries = 2048;\n\n\tqedi->pf_params.iscsi_pf_params.gl_rq_pi = QEDI_PROTO_CQ_PROD_IDX;\n\tqedi->pf_params.iscsi_pf_params.gl_cmd_pi = 1;\n\nerr_alloc_mem:\n\treturn rval;\n}\n\n \nstatic void qedi_free_iscsi_pf_param(struct qedi_ctx *qedi)\n{\n\tsize_t size = 0;\n\n\tif (qedi->p_cpuq) {\n\t\tsize = qedi->num_queues * sizeof(struct qedi_glbl_q_params);\n\t\tdma_free_coherent(&qedi->pdev->dev, size, qedi->p_cpuq,\n\t\t\t\t    qedi->hw_p_cpuq);\n\t}\n\n\tqedi_free_global_queues(qedi);\n\n\tkfree(qedi->global_queues);\n}\n\nstatic void qedi_get_boot_tgt_info(struct nvm_iscsi_block *block,\n\t\t\t\t   struct qedi_boot_target *tgt, u8 index)\n{\n\tu32 ipv6_en;\n\n\tipv6_en = !!(block->generic.ctrl_flags &\n\t\t     NVM_ISCSI_CFG_GEN_IPV6_ENABLED);\n\n\tsnprintf(tgt->iscsi_name, sizeof(tgt->iscsi_name), \"%s\",\n\t\t block->target[index].target_name.byte);\n\n\ttgt->ipv6_en = ipv6_en;\n\n\tif (ipv6_en)\n\t\tsnprintf(tgt->ip_addr, IPV6_LEN, \"%pI6\\n\",\n\t\t\t block->target[index].ipv6_addr.byte);\n\telse\n\t\tsnprintf(tgt->ip_addr, IPV4_LEN, \"%pI4\\n\",\n\t\t\t block->target[index].ipv4_addr.byte);\n}\n\nstatic int qedi_find_boot_info(struct qedi_ctx *qedi,\n\t\t\t       struct qed_mfw_tlv_iscsi *iscsi,\n\t\t\t       struct nvm_iscsi_block *block)\n{\n\tstruct qedi_boot_target *pri_tgt = NULL, *sec_tgt = NULL;\n\tu32 pri_ctrl_flags = 0, sec_ctrl_flags = 0, found = 0;\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct qedi_conn *qedi_conn;\n\tstruct iscsi_session *sess;\n\tstruct iscsi_conn *conn;\n\tchar ep_ip_addr[64];\n\tint i, ret = 0;\n\n\tpri_ctrl_flags = !!(block->target[0].ctrl_flags &\n\t\t\t\t\tNVM_ISCSI_CFG_TARGET_ENABLED);\n\tif (pri_ctrl_flags) {\n\t\tpri_tgt = kzalloc(sizeof(*pri_tgt), GFP_KERNEL);\n\t\tif (!pri_tgt)\n\t\t\treturn -1;\n\t\tqedi_get_boot_tgt_info(block, pri_tgt, 0);\n\t}\n\n\tsec_ctrl_flags = !!(block->target[1].ctrl_flags &\n\t\t\t\t\tNVM_ISCSI_CFG_TARGET_ENABLED);\n\tif (sec_ctrl_flags) {\n\t\tsec_tgt = kzalloc(sizeof(*sec_tgt), GFP_KERNEL);\n\t\tif (!sec_tgt) {\n\t\t\tret = -1;\n\t\t\tgoto free_tgt;\n\t\t}\n\t\tqedi_get_boot_tgt_info(block, sec_tgt, 1);\n\t}\n\n\tfor (i = 0; i < qedi->max_active_conns; i++) {\n\t\tqedi_conn = qedi_get_conn_from_id(qedi, i);\n\t\tif (!qedi_conn)\n\t\t\tcontinue;\n\n\t\tif (qedi_conn->ep->ip_type == TCP_IPV4)\n\t\t\tsnprintf(ep_ip_addr, IPV4_LEN, \"%pI4\\n\",\n\t\t\t\t qedi_conn->ep->dst_addr);\n\t\telse\n\t\t\tsnprintf(ep_ip_addr, IPV6_LEN, \"%pI6\\n\",\n\t\t\t\t qedi_conn->ep->dst_addr);\n\n\t\tcls_conn = qedi_conn->cls_conn;\n\t\tconn = cls_conn->dd_data;\n\t\tcls_sess = iscsi_conn_to_session(cls_conn);\n\t\tsess = cls_sess->dd_data;\n\n\t\tif (!iscsi_is_session_online(cls_sess))\n\t\t\tcontinue;\n\n\t\tif (!sess->targetname)\n\t\t\tcontinue;\n\n\t\tif (pri_ctrl_flags) {\n\t\t\tif (!strcmp(pri_tgt->iscsi_name, sess->targetname) &&\n\t\t\t    !strcmp(pri_tgt->ip_addr, ep_ip_addr)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sec_ctrl_flags) {\n\t\t\tif (!strcmp(sec_tgt->iscsi_name, sess->targetname) &&\n\t\t\t    !strcmp(sec_tgt->ip_addr, ep_ip_addr)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (found) {\n\t\tif (conn->hdrdgst_en) {\n\t\t\tiscsi->header_digest_set = true;\n\t\t\tiscsi->header_digest = 1;\n\t\t}\n\n\t\tif (conn->datadgst_en) {\n\t\t\tiscsi->data_digest_set = true;\n\t\t\tiscsi->data_digest = 1;\n\t\t}\n\t\tiscsi->boot_taget_portal_set = true;\n\t\tiscsi->boot_taget_portal = sess->tpgt;\n\n\t} else {\n\t\tret = -1;\n\t}\n\n\tif (sec_ctrl_flags)\n\t\tkfree(sec_tgt);\nfree_tgt:\n\tif (pri_ctrl_flags)\n\t\tkfree(pri_tgt);\n\n\treturn ret;\n}\n\nstatic void qedi_get_generic_tlv_data(void *dev, struct qed_generic_tlvs *data)\n{\n\tstruct qedi_ctx *qedi;\n\n\tif (!dev) {\n\t\tQEDI_INFO(NULL, QEDI_LOG_EVT,\n\t\t\t  \"dev is NULL so ignoring get_generic_tlv_data request.\\n\");\n\t\treturn;\n\t}\n\tqedi = (struct qedi_ctx *)dev;\n\n\tmemset(data, 0, sizeof(struct qed_generic_tlvs));\n\tether_addr_copy(data->mac[0], qedi->mac);\n}\n\n \nstatic void qedi_get_protocol_tlv_data(void *dev, void *data)\n{\n\tstruct qed_mfw_tlv_iscsi *iscsi = data;\n\tstruct qed_iscsi_stats *fw_iscsi_stats;\n\tstruct nvm_iscsi_block *block = NULL;\n\tu32 chap_en = 0, mchap_en = 0;\n\tstruct qedi_ctx *qedi = dev;\n\tint rval = 0;\n\n\tfw_iscsi_stats = kmalloc(sizeof(*fw_iscsi_stats), GFP_KERNEL);\n\tif (!fw_iscsi_stats) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Could not allocate memory for fw_iscsi_stats.\\n\");\n\t\tgoto exit_get_data;\n\t}\n\n\tmutex_lock(&qedi->stats_lock);\n\t \n\tqedi_ops->get_stats(qedi->cdev, fw_iscsi_stats);\n\tmutex_unlock(&qedi->stats_lock);\n\n\tiscsi->rx_frames_set = true;\n\tiscsi->rx_frames = fw_iscsi_stats->iscsi_rx_packet_cnt;\n\tiscsi->rx_bytes_set = true;\n\tiscsi->rx_bytes = fw_iscsi_stats->iscsi_rx_bytes_cnt;\n\tiscsi->tx_frames_set = true;\n\tiscsi->tx_frames = fw_iscsi_stats->iscsi_tx_packet_cnt;\n\tiscsi->tx_bytes_set = true;\n\tiscsi->tx_bytes = fw_iscsi_stats->iscsi_tx_bytes_cnt;\n\tiscsi->frame_size_set = true;\n\tiscsi->frame_size = qedi->ll2_mtu;\n\tblock = qedi_get_nvram_block(qedi);\n\tif (block) {\n\t\tchap_en = !!(block->generic.ctrl_flags &\n\t\t\t     NVM_ISCSI_CFG_GEN_CHAP_ENABLED);\n\t\tmchap_en = !!(block->generic.ctrl_flags &\n\t\t\t      NVM_ISCSI_CFG_GEN_CHAP_MUTUAL_ENABLED);\n\n\t\tiscsi->auth_method_set = (chap_en || mchap_en) ? true : false;\n\t\tiscsi->auth_method = 1;\n\t\tif (chap_en)\n\t\t\tiscsi->auth_method = 2;\n\t\tif (mchap_en)\n\t\t\tiscsi->auth_method = 3;\n\n\t\tiscsi->tx_desc_size_set = true;\n\t\tiscsi->tx_desc_size = QEDI_SQ_SIZE;\n\t\tiscsi->rx_desc_size_set = true;\n\t\tiscsi->rx_desc_size = QEDI_CQ_SIZE;\n\n\t\t \n\t\trval = qedi_find_boot_info(qedi, iscsi, block);\n\t\tif (rval)\n\t\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t\t  \"Boot target not set\");\n\t}\n\n\tkfree(fw_iscsi_stats);\nexit_get_data:\n\treturn;\n}\n\nvoid qedi_schedule_hw_err_handler(void *dev,\n\t\t\t\t  enum qed_hw_err_type err_type)\n{\n\tstruct qedi_ctx *qedi = (struct qedi_ctx *)dev;\n\tunsigned long override_flags = qedi_flags_override;\n\n\tif (override_flags && test_bit(QEDI_ERR_OVERRIDE_EN, &override_flags))\n\t\tqedi->qedi_err_flags = qedi_flags_override;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"HW error handler scheduled, err=%d err_flags=0x%x\\n\",\n\t\t  err_type, qedi->qedi_err_flags);\n\n\tswitch (err_type) {\n\tcase QED_HW_ERR_FAN_FAIL:\n\t\tschedule_delayed_work(&qedi->board_disable_work, 0);\n\t\tbreak;\n\tcase QED_HW_ERR_MFW_RESP_FAIL:\n\tcase QED_HW_ERR_HW_ATTN:\n\tcase QED_HW_ERR_DMAE_FAIL:\n\tcase QED_HW_ERR_RAMROD_FAIL:\n\tcase QED_HW_ERR_FW_ASSERT:\n\t\t \n\t\tif (test_bit(QEDI_ERR_ATTN_CLR_EN, &qedi->qedi_err_flags))\n\t\t\tqedi_ops->common->attn_clr_enable(qedi->cdev, true);\n\n\t\tif (err_type == QED_HW_ERR_RAMROD_FAIL &&\n\t\t    test_bit(QEDI_ERR_IS_RECOVERABLE, &qedi->qedi_err_flags))\n\t\t\tqedi_ops->common->recovery_process(qedi->cdev);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void qedi_schedule_recovery_handler(void *dev)\n{\n\tstruct qedi_ctx *qedi = dev;\n\n\tQEDI_ERR(&qedi->dbg_ctx, \"Recovery handler scheduled.\\n\");\n\n\tif (test_and_set_bit(QEDI_IN_RECOVERY, &qedi->flags))\n\t\treturn;\n\n\tatomic_set(&qedi->link_state, QEDI_LINK_DOWN);\n\n\tschedule_delayed_work(&qedi->recovery_work, 0);\n}\n\nstatic void qedi_set_conn_recovery(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct iscsi_conn *conn = session->leadconn;\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\n\tqedi_start_conn_recovery(qedi_conn->qedi, qedi_conn);\n}\n\nstatic void qedi_link_update(void *dev, struct qed_link_output *link)\n{\n\tstruct qedi_ctx *qedi = (struct qedi_ctx *)dev;\n\n\tif (link->link_up) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO, \"Link Up event.\\n\");\n\t\tatomic_set(&qedi->link_state, QEDI_LINK_UP);\n\t} else {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"Link Down event.\\n\");\n\t\tatomic_set(&qedi->link_state, QEDI_LINK_DOWN);\n\t\tiscsi_host_for_each_session(qedi->shost, qedi_set_conn_recovery);\n\t}\n}\n\nstatic struct qed_iscsi_cb_ops qedi_cb_ops = {\n\t{\n\t\t.link_update =\t\tqedi_link_update,\n\t\t.schedule_recovery_handler = qedi_schedule_recovery_handler,\n\t\t.schedule_hw_err_handler = qedi_schedule_hw_err_handler,\n\t\t.get_protocol_tlv_data = qedi_get_protocol_tlv_data,\n\t\t.get_generic_tlv_data = qedi_get_generic_tlv_data,\n\t}\n};\n\nstatic int qedi_queue_cqe(struct qedi_ctx *qedi, union iscsi_cqe *cqe,\n\t\t\t  u16 que_idx, struct qedi_percpu_s *p)\n{\n\tstruct qedi_work *qedi_work;\n\tstruct qedi_conn *q_conn;\n\tstruct qedi_cmd *qedi_cmd;\n\tu32 iscsi_cid;\n\tint rc = 0;\n\n\tiscsi_cid  = cqe->cqe_common.conn_id;\n\tq_conn = qedi->cid_que.conn_cid_tbl[iscsi_cid];\n\tif (!q_conn) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"Session no longer exists for cid=0x%x!!\\n\",\n\t\t\t  iscsi_cid);\n\t\treturn -1;\n\t}\n\n\tswitch (cqe->cqe_common.cqe_type) {\n\tcase ISCSI_CQE_TYPE_SOLICITED:\n\tcase ISCSI_CQE_TYPE_SOLICITED_WITH_SENSE:\n\t\tqedi_cmd = qedi_get_cmd_from_tid(qedi, cqe->cqe_solicited.itid);\n\t\tif (!qedi_cmd) {\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\t\tINIT_LIST_HEAD(&qedi_cmd->cqe_work.list);\n\t\tqedi_cmd->cqe_work.qedi = qedi;\n\t\tmemcpy(&qedi_cmd->cqe_work.cqe, cqe, sizeof(union iscsi_cqe));\n\t\tqedi_cmd->cqe_work.que_idx = que_idx;\n\t\tqedi_cmd->cqe_work.is_solicited = true;\n\t\tlist_add_tail(&qedi_cmd->cqe_work.list, &p->work_list);\n\t\tbreak;\n\tcase ISCSI_CQE_TYPE_UNSOLICITED:\n\tcase ISCSI_CQE_TYPE_DUMMY:\n\tcase ISCSI_CQE_TYPE_TASK_CLEANUP:\n\t\tqedi_work = kzalloc(sizeof(*qedi_work), GFP_ATOMIC);\n\t\tif (!qedi_work) {\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\t\tINIT_LIST_HEAD(&qedi_work->list);\n\t\tqedi_work->qedi = qedi;\n\t\tmemcpy(&qedi_work->cqe, cqe, sizeof(union iscsi_cqe));\n\t\tqedi_work->que_idx = que_idx;\n\t\tqedi_work->is_solicited = false;\n\t\tlist_add_tail(&qedi_work->list, &p->work_list);\n\t\tbreak;\n\tdefault:\n\t\trc = -1;\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"FW Error cqe.\\n\");\n\t}\n\treturn rc;\n}\n\nstatic bool qedi_process_completions(struct qedi_fastpath *fp)\n{\n\tstruct qedi_ctx *qedi = fp->qedi;\n\tstruct qed_sb_info *sb_info = fp->sb_info;\n\tstruct status_block *sb = sb_info->sb_virt;\n\tstruct qedi_percpu_s *p = NULL;\n\tstruct global_queue *que;\n\tu16 prod_idx;\n\tunsigned long flags;\n\tunion iscsi_cqe *cqe;\n\tint cpu;\n\tint ret;\n\n\t \n\tprod_idx = sb->pi_array[QEDI_PROTO_CQ_PROD_IDX];\n\n\tif (prod_idx >= QEDI_CQ_SIZE)\n\t\tprod_idx = prod_idx % QEDI_CQ_SIZE;\n\n\tque = qedi->global_queues[fp->sb_id];\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_IO,\n\t\t  \"Before: global queue=%p prod_idx=%d cons_idx=%d, sb_id=%d\\n\",\n\t\t  que, prod_idx, que->cq_cons_idx, fp->sb_id);\n\n\tqedi->intr_cpu = fp->sb_id;\n\tcpu = smp_processor_id();\n\tp = &per_cpu(qedi_percpu, cpu);\n\n\tif (unlikely(!p->iothread))\n\t\tWARN_ON(1);\n\n\tspin_lock_irqsave(&p->p_work_lock, flags);\n\twhile (que->cq_cons_idx != prod_idx) {\n\t\tcqe = &que->cq[que->cq_cons_idx];\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_IO,\n\t\t\t  \"cqe=%p prod_idx=%d cons_idx=%d.\\n\",\n\t\t\t  cqe, prod_idx, que->cq_cons_idx);\n\n\t\tret = qedi_queue_cqe(qedi, cqe, fp->sb_id, p);\n\t\tif (ret)\n\t\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t\t  \"Dropping CQE 0x%x for cid=0x%x.\\n\",\n\t\t\t\t  que->cq_cons_idx, cqe->cqe_common.conn_id);\n\n\t\tque->cq_cons_idx++;\n\t\tif (que->cq_cons_idx == QEDI_CQ_SIZE)\n\t\t\tque->cq_cons_idx = 0;\n\t}\n\twake_up_process(p->iothread);\n\tspin_unlock_irqrestore(&p->p_work_lock, flags);\n\n\treturn true;\n}\n\nstatic bool qedi_fp_has_work(struct qedi_fastpath *fp)\n{\n\tstruct qedi_ctx *qedi = fp->qedi;\n\tstruct global_queue *que;\n\tstruct qed_sb_info *sb_info = fp->sb_info;\n\tstruct status_block *sb = sb_info->sb_virt;\n\tu16 prod_idx;\n\n\tbarrier();\n\n\t \n\tprod_idx = sb->pi_array[QEDI_PROTO_CQ_PROD_IDX];\n\n\t \n\tque = qedi->global_queues[fp->sb_id];\n\n\t \n\tif (prod_idx >= QEDI_CQ_SIZE)\n\t\tprod_idx = prod_idx % QEDI_CQ_SIZE;\n\n\treturn (que->cq_cons_idx != prod_idx);\n}\n\n \nstatic irqreturn_t qedi_msix_handler(int irq, void *dev_id)\n{\n\tstruct qedi_fastpath *fp = dev_id;\n\tstruct qedi_ctx *qedi = fp->qedi;\n\tbool wake_io_thread = true;\n\n\tqed_sb_ack(fp->sb_info, IGU_INT_DISABLE, 0);\n\nprocess_again:\n\twake_io_thread = qedi_process_completions(fp);\n\tif (wake_io_thread) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_DISC,\n\t\t\t  \"process already running\\n\");\n\t}\n\n\tif (!qedi_fp_has_work(fp))\n\t\tqed_sb_update_sb_idx(fp->sb_info);\n\n\t \n\trmb();\n\n\tif (!qedi_fp_has_work(fp))\n\t\tqed_sb_ack(fp->sb_info, IGU_INT_ENABLE, 1);\n\telse\n\t\tgoto process_again;\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void qedi_simd_int_handler(void *cookie)\n{\n\t \n\tstruct qedi_ctx *qedi = (struct qedi_ctx *)cookie;\n\n\tQEDI_WARN(&qedi->dbg_ctx, \"qedi=%p.\\n\", qedi);\n}\n\n#define QEDI_SIMD_HANDLER_NUM\t\t0\nstatic void qedi_sync_free_irqs(struct qedi_ctx *qedi)\n{\n\tint i;\n\tu16 idx;\n\n\tif (qedi->int_info.msix_cnt) {\n\t\tfor (i = 0; i < qedi->int_info.used_cnt; i++) {\n\t\t\tidx = i * qedi->dev_info.common.num_hwfns +\n\t\t\tqedi_ops->common->get_affin_hwfn_idx(qedi->cdev);\n\n\t\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t\t  \"Freeing IRQ #%d vector_idx=%d.\\n\", i, idx);\n\n\t\t\tsynchronize_irq(qedi->int_info.msix[idx].vector);\n\t\t\tirq_set_affinity_hint(qedi->int_info.msix[idx].vector,\n\t\t\t\t\t      NULL);\n\t\t\tfree_irq(qedi->int_info.msix[idx].vector,\n\t\t\t\t &qedi->fp_array[i]);\n\t\t}\n\t} else {\n\t\tqedi_ops->common->simd_handler_clean(qedi->cdev,\n\t\t\t\t\t\t     QEDI_SIMD_HANDLER_NUM);\n\t}\n\n\tqedi->int_info.used_cnt = 0;\n\tqedi_ops->common->set_fp_int(qedi->cdev, 0);\n}\n\nstatic int qedi_request_msix_irq(struct qedi_ctx *qedi)\n{\n\tint i, rc, cpu;\n\tu16 idx;\n\n\tcpu = cpumask_first(cpu_online_mask);\n\tfor (i = 0; i < qedi->msix_count; i++) {\n\t\tidx = i * qedi->dev_info.common.num_hwfns +\n\t\t\t  qedi_ops->common->get_affin_hwfn_idx(qedi->cdev);\n\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"dev_info: num_hwfns=%d affin_hwfn_idx=%d.\\n\",\n\t\t\t  qedi->dev_info.common.num_hwfns,\n\t\t\t  qedi_ops->common->get_affin_hwfn_idx(qedi->cdev));\n\n\t\trc = request_irq(qedi->int_info.msix[idx].vector,\n\t\t\t\t qedi_msix_handler, 0, \"qedi\",\n\t\t\t\t &qedi->fp_array[i]);\n\t\tif (rc) {\n\t\t\tQEDI_WARN(&qedi->dbg_ctx, \"request_irq failed.\\n\");\n\t\t\tqedi_sync_free_irqs(qedi);\n\t\t\treturn rc;\n\t\t}\n\t\tqedi->int_info.used_cnt++;\n\t\trc = irq_set_affinity_hint(qedi->int_info.msix[idx].vector,\n\t\t\t\t\t   get_cpu_mask(cpu));\n\t\tcpu = cpumask_next(cpu, cpu_online_mask);\n\t}\n\n\treturn 0;\n}\n\nstatic int qedi_setup_int(struct qedi_ctx *qedi)\n{\n\tint rc = 0;\n\n\trc = qedi_ops->common->set_fp_int(qedi->cdev, qedi->num_queues);\n\tif (rc < 0)\n\t\tgoto exit_setup_int;\n\n\tqedi->msix_count = rc;\n\n\trc = qedi_ops->common->get_fp_int(qedi->cdev, &qedi->int_info);\n\tif (rc)\n\t\tgoto exit_setup_int;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_DISC,\n\t\t  \"Number of msix_cnt = 0x%x num of cpus = 0x%x\\n\",\n\t\t   qedi->int_info.msix_cnt, num_online_cpus());\n\n\tif (qedi->int_info.msix_cnt) {\n\t\trc = qedi_request_msix_irq(qedi);\n\t\tgoto exit_setup_int;\n\t} else {\n\t\tqedi_ops->common->simd_handler_config(qedi->cdev, &qedi,\n\t\t\t\t\t\t      QEDI_SIMD_HANDLER_NUM,\n\t\t\t\t\t\t      qedi_simd_int_handler);\n\t\tqedi->int_info.used_cnt = 1;\n\t}\n\nexit_setup_int:\n\treturn rc;\n}\n\nstatic void qedi_free_nvm_iscsi_cfg(struct qedi_ctx *qedi)\n{\n\tif (qedi->iscsi_image)\n\t\tdma_free_coherent(&qedi->pdev->dev,\n\t\t\t\t  sizeof(struct qedi_nvm_iscsi_image),\n\t\t\t\t  qedi->iscsi_image, qedi->nvm_buf_dma);\n}\n\nstatic int qedi_alloc_nvm_iscsi_cfg(struct qedi_ctx *qedi)\n{\n\tqedi->iscsi_image = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t\t       sizeof(struct qedi_nvm_iscsi_image),\n\t\t\t\t\t       &qedi->nvm_buf_dma, GFP_KERNEL);\n\tif (!qedi->iscsi_image) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Could not allocate NVM BUF.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"NVM BUF addr=0x%p dma=0x%llx.\\n\", qedi->iscsi_image,\n\t\t  qedi->nvm_buf_dma);\n\n\treturn 0;\n}\n\nstatic void qedi_free_bdq(struct qedi_ctx *qedi)\n{\n\tint i;\n\n\tif (qedi->bdq_pbl_list)\n\t\tdma_free_coherent(&qedi->pdev->dev, QEDI_PAGE_SIZE,\n\t\t\t\t  qedi->bdq_pbl_list, qedi->bdq_pbl_list_dma);\n\n\tif (qedi->bdq_pbl)\n\t\tdma_free_coherent(&qedi->pdev->dev, qedi->bdq_pbl_mem_size,\n\t\t\t\t  qedi->bdq_pbl, qedi->bdq_pbl_dma);\n\n\tfor (i = 0; i < QEDI_BDQ_NUM; i++) {\n\t\tif (qedi->bdq[i].buf_addr) {\n\t\t\tdma_free_coherent(&qedi->pdev->dev, QEDI_BDQ_BUF_SIZE,\n\t\t\t\t\t  qedi->bdq[i].buf_addr,\n\t\t\t\t\t  qedi->bdq[i].buf_dma);\n\t\t}\n\t}\n}\n\nstatic void qedi_free_global_queues(struct qedi_ctx *qedi)\n{\n\tint i;\n\tstruct global_queue **gl = qedi->global_queues;\n\n\tfor (i = 0; i < qedi->num_queues; i++) {\n\t\tif (!gl[i])\n\t\t\tcontinue;\n\n\t\tif (gl[i]->cq)\n\t\t\tdma_free_coherent(&qedi->pdev->dev, gl[i]->cq_mem_size,\n\t\t\t\t\t  gl[i]->cq, gl[i]->cq_dma);\n\t\tif (gl[i]->cq_pbl)\n\t\t\tdma_free_coherent(&qedi->pdev->dev, gl[i]->cq_pbl_size,\n\t\t\t\t\t  gl[i]->cq_pbl, gl[i]->cq_pbl_dma);\n\n\t\tkfree(gl[i]);\n\t}\n\tqedi_free_bdq(qedi);\n\tqedi_free_nvm_iscsi_cfg(qedi);\n}\n\nstatic int qedi_alloc_bdq(struct qedi_ctx *qedi)\n{\n\tint i;\n\tstruct scsi_bd *pbl;\n\tu64 *list;\n\n\t \n\tfor (i = 0; i < QEDI_BDQ_NUM; i++) {\n\t\tqedi->bdq[i].buf_addr =\n\t\t\t\tdma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t\t\t   QEDI_BDQ_BUF_SIZE,\n\t\t\t\t\t\t   &qedi->bdq[i].buf_dma,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!qedi->bdq[i].buf_addr) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Could not allocate BDQ buffer %d.\\n\", i);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tqedi->bdq_pbl_mem_size = QEDI_BDQ_NUM * sizeof(struct scsi_bd);\n\tqedi->bdq_pbl_mem_size = ALIGN(qedi->bdq_pbl_mem_size, QEDI_PAGE_SIZE);\n\tqedi->rq_num_entries = qedi->bdq_pbl_mem_size / sizeof(struct scsi_bd);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN, \"rq_num_entries = %d.\\n\",\n\t\t  qedi->rq_num_entries);\n\n\tqedi->bdq_pbl = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t\t   qedi->bdq_pbl_mem_size,\n\t\t\t\t\t   &qedi->bdq_pbl_dma, GFP_KERNEL);\n\tif (!qedi->bdq_pbl) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Could not allocate BDQ PBL.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpbl = (struct scsi_bd  *)qedi->bdq_pbl;\n\tfor (i = 0; i < QEDI_BDQ_NUM; i++) {\n\t\tpbl->address.hi =\n\t\t\t\tcpu_to_le32(QEDI_U64_HI(qedi->bdq[i].buf_dma));\n\t\tpbl->address.lo =\n\t\t\t\tcpu_to_le32(QEDI_U64_LO(qedi->bdq[i].buf_dma));\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t  \"pbl [0x%p] pbl->address hi [0x%llx] lo [0x%llx], idx [%d]\\n\",\n\t\t\t  pbl, pbl->address.hi, pbl->address.lo, i);\n\t\tpbl->opaque.iscsi_opaque.reserved_zero[0] = 0;\n\t\tpbl->opaque.iscsi_opaque.reserved_zero[1] = 0;\n\t\tpbl->opaque.iscsi_opaque.reserved_zero[2] = 0;\n\t\tpbl->opaque.iscsi_opaque.opaque = cpu_to_le16(i);\n\t\tpbl++;\n\t}\n\n\t \n\tqedi->bdq_pbl_list = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t\t\tQEDI_PAGE_SIZE,\n\t\t\t\t\t\t&qedi->bdq_pbl_list_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!qedi->bdq_pbl_list) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Could not allocate list of PBL pages.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tqedi->bdq_pbl_list_num_entries = qedi->bdq_pbl_mem_size /\n\t\t\t\t\t QEDI_PAGE_SIZE;\n\tlist = (u64 *)qedi->bdq_pbl_list;\n\tfor (i = 0; i < qedi->bdq_pbl_list_num_entries; i++) {\n\t\t*list = qedi->bdq_pbl_dma;\n\t\tlist++;\n\t}\n\n\treturn 0;\n}\n\nstatic int qedi_alloc_global_queues(struct qedi_ctx *qedi)\n{\n\tu32 *list;\n\tint i;\n\tint status;\n\tu32 *pbl;\n\tdma_addr_t page;\n\tint num_pages;\n\n\t \n\tif (!qedi->num_queues) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"No MSI-X vectors available!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!qedi->p_cpuq) {\n\t\tstatus = -EINVAL;\n\t\tgoto mem_alloc_failure;\n\t}\n\n\tqedi->global_queues = kzalloc((sizeof(struct global_queue *) *\n\t\t\t\t       qedi->num_queues), GFP_KERNEL);\n\tif (!qedi->global_queues) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Unable to allocate global queues array ptr memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_DISC,\n\t\t  \"qedi->global_queues=%p.\\n\", qedi->global_queues);\n\n\t \n\tstatus = qedi_alloc_bdq(qedi);\n\tif (status)\n\t\tgoto mem_alloc_failure;\n\n\t \n\tstatus = qedi_alloc_nvm_iscsi_cfg(qedi);\n\tif (status)\n\t\tgoto mem_alloc_failure;\n\n\t \n\tfor (i = 0; i < qedi->num_queues; i++) {\n\t\tqedi->global_queues[i] =\n\t\t\t\t\tkzalloc(sizeof(*qedi->global_queues[0]),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!qedi->global_queues[i]) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Unable to allocation global queue %d.\\n\", i);\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto mem_alloc_failure;\n\t\t}\n\n\t\tqedi->global_queues[i]->cq_mem_size =\n\t\t    (QEDI_CQ_SIZE + 8) * sizeof(union iscsi_cqe);\n\t\tqedi->global_queues[i]->cq_mem_size =\n\t\t    (qedi->global_queues[i]->cq_mem_size +\n\t\t    (QEDI_PAGE_SIZE - 1));\n\n\t\tqedi->global_queues[i]->cq_pbl_size =\n\t\t    (qedi->global_queues[i]->cq_mem_size /\n\t\t    QEDI_PAGE_SIZE) * sizeof(void *);\n\t\tqedi->global_queues[i]->cq_pbl_size =\n\t\t    (qedi->global_queues[i]->cq_pbl_size +\n\t\t    (QEDI_PAGE_SIZE - 1));\n\n\t\tqedi->global_queues[i]->cq = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t\t\t\t\tqedi->global_queues[i]->cq_mem_size,\n\t\t\t\t\t\t\t\t&qedi->global_queues[i]->cq_dma,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!qedi->global_queues[i]->cq) {\n\t\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t\t  \"Could not allocate cq.\\n\");\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto mem_alloc_failure;\n\t\t}\n\t\tqedi->global_queues[i]->cq_pbl = dma_alloc_coherent(&qedi->pdev->dev,\n\t\t\t\t\t\t\t\t    qedi->global_queues[i]->cq_pbl_size,\n\t\t\t\t\t\t\t\t    &qedi->global_queues[i]->cq_pbl_dma,\n\t\t\t\t\t\t\t\t    GFP_KERNEL);\n\n\t\tif (!qedi->global_queues[i]->cq_pbl) {\n\t\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t\t  \"Could not allocate cq PBL.\\n\");\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto mem_alloc_failure;\n\t\t}\n\n\t\t \n\t\tnum_pages = qedi->global_queues[i]->cq_mem_size /\n\t\t    QEDI_PAGE_SIZE;\n\t\tpage = qedi->global_queues[i]->cq_dma;\n\t\tpbl = (u32 *)qedi->global_queues[i]->cq_pbl;\n\n\t\twhile (num_pages--) {\n\t\t\t*pbl = (u32)page;\n\t\t\tpbl++;\n\t\t\t*pbl = (u32)((u64)page >> 32);\n\t\t\tpbl++;\n\t\t\tpage += QEDI_PAGE_SIZE;\n\t\t}\n\t}\n\n\tlist = (u32 *)qedi->p_cpuq;\n\n\t \n\tfor (i = 0; i < qedi->num_queues; i++) {\n\t\t*list = (u32)qedi->global_queues[i]->cq_pbl_dma;\n\t\tlist++;\n\t\t*list = (u32)((u64)qedi->global_queues[i]->cq_pbl_dma >> 32);\n\t\tlist++;\n\n\t\t*list = (u32)0;\n\t\tlist++;\n\t\t*list = (u32)((u64)0 >> 32);\n\t\tlist++;\n\t}\n\n\treturn 0;\n\nmem_alloc_failure:\n\tqedi_free_global_queues(qedi);\n\treturn status;\n}\n\nint qedi_alloc_sq(struct qedi_ctx *qedi, struct qedi_endpoint *ep)\n{\n\tint rval = 0;\n\tu32 *pbl;\n\tdma_addr_t page;\n\tint num_pages;\n\n\tif (!ep)\n\t\treturn -EIO;\n\n\t \n\tep->sq_mem_size = QEDI_SQ_SIZE * sizeof(struct iscsi_wqe);\n\tep->sq_mem_size += QEDI_PAGE_SIZE - 1;\n\n\tep->sq_pbl_size = (ep->sq_mem_size / QEDI_PAGE_SIZE) * sizeof(void *);\n\tep->sq_pbl_size = ep->sq_pbl_size + QEDI_PAGE_SIZE;\n\n\tep->sq = dma_alloc_coherent(&qedi->pdev->dev, ep->sq_mem_size,\n\t\t\t\t    &ep->sq_dma, GFP_KERNEL);\n\tif (!ep->sq) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"Could not allocate send queue.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto out;\n\t}\n\tep->sq_pbl = dma_alloc_coherent(&qedi->pdev->dev, ep->sq_pbl_size,\n\t\t\t\t\t&ep->sq_pbl_dma, GFP_KERNEL);\n\tif (!ep->sq_pbl) {\n\t\tQEDI_WARN(&qedi->dbg_ctx,\n\t\t\t  \"Could not allocate send queue PBL.\\n\");\n\t\trval = -ENOMEM;\n\t\tgoto out_free_sq;\n\t}\n\n\t \n\tnum_pages = ep->sq_mem_size / QEDI_PAGE_SIZE;\n\tpage = ep->sq_dma;\n\tpbl = (u32 *)ep->sq_pbl;\n\n\twhile (num_pages--) {\n\t\t*pbl = (u32)page;\n\t\tpbl++;\n\t\t*pbl = (u32)((u64)page >> 32);\n\t\tpbl++;\n\t\tpage += QEDI_PAGE_SIZE;\n\t}\n\n\treturn rval;\n\nout_free_sq:\n\tdma_free_coherent(&qedi->pdev->dev, ep->sq_mem_size, ep->sq,\n\t\t\t  ep->sq_dma);\nout:\n\treturn rval;\n}\n\nvoid qedi_free_sq(struct qedi_ctx *qedi, struct qedi_endpoint *ep)\n{\n\tif (ep->sq_pbl)\n\t\tdma_free_coherent(&qedi->pdev->dev, ep->sq_pbl_size, ep->sq_pbl,\n\t\t\t\t  ep->sq_pbl_dma);\n\tif (ep->sq)\n\t\tdma_free_coherent(&qedi->pdev->dev, ep->sq_mem_size, ep->sq,\n\t\t\t\t  ep->sq_dma);\n}\n\nint qedi_get_task_idx(struct qedi_ctx *qedi)\n{\n\ts16 tmp_idx;\n\nagain:\n\ttmp_idx = find_first_zero_bit(qedi->task_idx_map,\n\t\t\t\t      MAX_ISCSI_TASK_ENTRIES);\n\n\tif (tmp_idx >= MAX_ISCSI_TASK_ENTRIES) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"FW task context pool is full.\\n\");\n\t\ttmp_idx = -1;\n\t\tgoto err_idx;\n\t}\n\n\tif (test_and_set_bit(tmp_idx, qedi->task_idx_map))\n\t\tgoto again;\n\nerr_idx:\n\treturn tmp_idx;\n}\n\nvoid qedi_clear_task_idx(struct qedi_ctx *qedi, int idx)\n{\n\tif (!test_and_clear_bit(idx, qedi->task_idx_map))\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"FW task context, already cleared, tid=0x%x\\n\", idx);\n}\n\nvoid qedi_update_itt_map(struct qedi_ctx *qedi, u32 tid, u32 proto_itt,\n\t\t\t struct qedi_cmd *cmd)\n{\n\tqedi->itt_map[tid].itt = proto_itt;\n\tqedi->itt_map[tid].p_cmd = cmd;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t  \"update itt map tid=0x%x, with proto itt=0x%x\\n\", tid,\n\t\t  qedi->itt_map[tid].itt);\n}\n\nvoid qedi_get_task_tid(struct qedi_ctx *qedi, u32 itt, s16 *tid)\n{\n\tu16 i;\n\n\tfor (i = 0; i < MAX_ISCSI_TASK_ENTRIES; i++) {\n\t\tif (qedi->itt_map[i].itt == itt) {\n\t\t\t*tid = i;\n\t\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t\t\t  \"Ref itt=0x%x, found at tid=0x%x\\n\",\n\t\t\t\t  itt, *tid);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN_ON(1);\n}\n\nvoid qedi_get_proto_itt(struct qedi_ctx *qedi, u32 tid, u32 *proto_itt)\n{\n\t*proto_itt = qedi->itt_map[tid].itt;\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_CONN,\n\t\t  \"Get itt map tid [0x%x with proto itt[0x%x]\",\n\t\t  tid, *proto_itt);\n}\n\nstruct qedi_cmd *qedi_get_cmd_from_tid(struct qedi_ctx *qedi, u32 tid)\n{\n\tstruct qedi_cmd *cmd = NULL;\n\n\tif (tid >= MAX_ISCSI_TASK_ENTRIES)\n\t\treturn NULL;\n\n\tcmd = qedi->itt_map[tid].p_cmd;\n\tif (cmd->task_id != tid)\n\t\treturn NULL;\n\n\tqedi->itt_map[tid].p_cmd = NULL;\n\n\treturn cmd;\n}\n\nstatic int qedi_alloc_itt(struct qedi_ctx *qedi)\n{\n\tqedi->itt_map = kcalloc(MAX_ISCSI_TASK_ENTRIES,\n\t\t\t\tsizeof(struct qedi_itt_map), GFP_KERNEL);\n\tif (!qedi->itt_map) {\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Unable to allocate itt map array memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void qedi_free_itt(struct qedi_ctx *qedi)\n{\n\tkfree(qedi->itt_map);\n}\n\nstatic struct qed_ll2_cb_ops qedi_ll2_cb_ops = {\n\t.rx_cb = qedi_ll2_rx,\n\t.tx_cb = NULL,\n};\n\nstatic int qedi_percpu_io_thread(void *arg)\n{\n\tstruct qedi_percpu_s *p = arg;\n\tstruct qedi_work *work, *tmp;\n\tunsigned long flags;\n\tLIST_HEAD(work_list);\n\n\tset_user_nice(current, -20);\n\n\twhile (!kthread_should_stop()) {\n\t\tspin_lock_irqsave(&p->p_work_lock, flags);\n\t\twhile (!list_empty(&p->work_list)) {\n\t\t\tlist_splice_init(&p->work_list, &work_list);\n\t\t\tspin_unlock_irqrestore(&p->p_work_lock, flags);\n\n\t\t\tlist_for_each_entry_safe(work, tmp, &work_list, list) {\n\t\t\t\tlist_del_init(&work->list);\n\t\t\t\tqedi_fp_process_cqes(work);\n\t\t\t\tif (!work->is_solicited)\n\t\t\t\t\tkfree(work);\n\t\t\t}\n\t\t\tcond_resched();\n\t\t\tspin_lock_irqsave(&p->p_work_lock, flags);\n\t\t}\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock_irqrestore(&p->p_work_lock, flags);\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}\n\nstatic int qedi_cpu_online(unsigned int cpu)\n{\n\tstruct qedi_percpu_s *p = this_cpu_ptr(&qedi_percpu);\n\tstruct task_struct *thread;\n\n\tthread = kthread_create_on_node(qedi_percpu_io_thread, (void *)p,\n\t\t\t\t\tcpu_to_node(cpu),\n\t\t\t\t\t\"qedi_thread/%d\", cpu);\n\tif (IS_ERR(thread))\n\t\treturn PTR_ERR(thread);\n\n\tkthread_bind(thread, cpu);\n\tp->iothread = thread;\n\twake_up_process(thread);\n\treturn 0;\n}\n\nstatic int qedi_cpu_offline(unsigned int cpu)\n{\n\tstruct qedi_percpu_s *p = this_cpu_ptr(&qedi_percpu);\n\tstruct qedi_work *work, *tmp;\n\tstruct task_struct *thread;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&p->p_work_lock, flags);\n\tthread = p->iothread;\n\tp->iothread = NULL;\n\n\tlist_for_each_entry_safe(work, tmp, &p->work_list, list) {\n\t\tlist_del_init(&work->list);\n\t\tqedi_fp_process_cqes(work);\n\t\tif (!work->is_solicited)\n\t\t\tkfree(work);\n\t}\n\n\tspin_unlock_irqrestore(&p->p_work_lock, flags);\n\tif (thread)\n\t\tkthread_stop(thread);\n\treturn 0;\n}\n\nvoid qedi_reset_host_mtu(struct qedi_ctx *qedi, u16 mtu)\n{\n\tstruct qed_ll2_params params;\n\n\tqedi_recover_all_conns(qedi);\n\n\tqedi_ops->ll2->stop(qedi->cdev);\n\tqedi_ll2_free_skbs(qedi);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO, \"old MTU %u, new MTU %u\\n\",\n\t\t  qedi->ll2_mtu, mtu);\n\tmemset(&params, 0, sizeof(params));\n\tqedi->ll2_mtu = mtu;\n\tparams.mtu = qedi->ll2_mtu + IPV6_HDR_LEN + TCP_HDR_LEN;\n\tparams.drop_ttl0_packets = 0;\n\tparams.rx_vlan_stripping = 1;\n\tether_addr_copy(params.ll2_mac_address, qedi->dev_info.common.hw_mac);\n\tqedi_ops->ll2->start(qedi->cdev, &params);\n}\n\n \nstatic struct nvm_iscsi_block *\nqedi_get_nvram_block(struct qedi_ctx *qedi)\n{\n\tint i;\n\tu8 pf;\n\tu32 flags;\n\tstruct nvm_iscsi_block *block;\n\n\tpf = qedi->dev_info.common.abs_pf_id;\n\tblock = &qedi->iscsi_image->iscsi_cfg.block[0];\n\tfor (i = 0; i < NUM_OF_ISCSI_PF_SUPPORTED; i++, block++) {\n\t\tflags = ((block->id) & NVM_ISCSI_CFG_BLK_CTRL_FLAG_MASK) >>\n\t\t\tNVM_ISCSI_CFG_BLK_CTRL_FLAG_OFFSET;\n\t\tif (flags & (NVM_ISCSI_CFG_BLK_CTRL_FLAG_IS_NOT_EMPTY |\n\t\t\t\tNVM_ISCSI_CFG_BLK_CTRL_FLAG_PF_MAPPED) &&\n\t\t\t(pf == (block->id & NVM_ISCSI_CFG_BLK_MAPPED_PF_ID_MASK)\n\t\t\t\t>> NVM_ISCSI_CFG_BLK_MAPPED_PF_ID_OFFSET))\n\t\t\treturn block;\n\t}\n\treturn NULL;\n}\n\nstatic ssize_t qedi_show_boot_eth_info(void *data, int type, char *buf)\n{\n\tstruct qedi_ctx *qedi = data;\n\tstruct nvm_iscsi_initiator *initiator;\n\tint rc = 1;\n\tu32 ipv6_en, dhcp_en, ip_len;\n\tstruct nvm_iscsi_block *block;\n\tchar *fmt, *ip, *sub, *gw;\n\n\tblock = qedi_get_nvram_block(qedi);\n\tif (!block)\n\t\treturn 0;\n\n\tinitiator = &block->initiator;\n\tipv6_en = block->generic.ctrl_flags &\n\t\t  NVM_ISCSI_CFG_GEN_IPV6_ENABLED;\n\tdhcp_en = block->generic.ctrl_flags &\n\t\t  NVM_ISCSI_CFG_GEN_DHCP_TCPIP_CONFIG_ENABLED;\n\t \n\tfmt = ipv6_en ? \"%pI6\\n\" : \"%pI4\\n\";\n\tip = ipv6_en ? initiator->ipv6.addr.byte : initiator->ipv4.addr.byte;\n\tip_len = ipv6_en ? IPV6_LEN : IPV4_LEN;\n\tsub = ipv6_en ? initiator->ipv6.subnet_mask.byte :\n\t      initiator->ipv4.subnet_mask.byte;\n\tgw = ipv6_en ? initiator->ipv6.gateway.byte :\n\t     initiator->ipv4.gateway.byte;\n\t \n\tfmt = dhcp_en ? \"%s\\n\" : fmt;\n\tif (dhcp_en) {\n\t\tip = ipv6_en ? \"0::0\" : \"0.0.0.0\";\n\t\tsub = ip;\n\t\tgw = ip;\n\t\tip_len = ipv6_en ? 5 : 8;\n\t}\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_IP_ADDR:\n\t\trc = snprintf(buf, ip_len, fmt, ip);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_SUBNET_MASK:\n\t\trc = snprintf(buf, ip_len, fmt, sub);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_GATEWAY:\n\t\trc = snprintf(buf, ip_len, fmt, gw);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\t\trc = snprintf(buf, 3, \"%d\\n\", (char)SYSFS_FLAG_FW_SEL_BOOT);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_INDEX:\n\t\trc = snprintf(buf, 3, \"0\\n\");\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_MAC:\n\t\trc = sysfs_format_mac(buf, qedi->mac, ETH_ALEN);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_VLAN:\n\t\trc = snprintf(buf, 12, \"%d\\n\",\n\t\t\t      GET_FIELD2(initiator->generic_cont0,\n\t\t\t\t\t NVM_ISCSI_CFG_INITIATOR_VLAN));\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_ORIGIN:\n\t\tif (dhcp_en)\n\t\t\trc = snprintf(buf, 3, \"3\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic umode_t qedi_eth_get_attr_visibility(void *data, int type)\n{\n\tint rc = 1;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\tcase ISCSI_BOOT_ETH_MAC:\n\tcase ISCSI_BOOT_ETH_INDEX:\n\tcase ISCSI_BOOT_ETH_IP_ADDR:\n\tcase ISCSI_BOOT_ETH_SUBNET_MASK:\n\tcase ISCSI_BOOT_ETH_GATEWAY:\n\tcase ISCSI_BOOT_ETH_ORIGIN:\n\tcase ISCSI_BOOT_ETH_VLAN:\n\t\trc = 0444;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t qedi_show_boot_ini_info(void *data, int type, char *buf)\n{\n\tstruct qedi_ctx *qedi = data;\n\tstruct nvm_iscsi_initiator *initiator;\n\tint rc;\n\tstruct nvm_iscsi_block *block;\n\n\tblock = qedi_get_nvram_block(qedi);\n\tif (!block)\n\t\treturn 0;\n\n\tinitiator = &block->initiator;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\trc = sprintf(buf, \"%.*s\\n\", NVM_ISCSI_CFG_ISCSI_NAME_MAX_LEN,\n\t\t\t     initiator->initiator_name.byte);\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic umode_t qedi_ini_get_attr_visibility(void *data, int type)\n{\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\trc = 0444;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t\nqedi_show_boot_tgt_info(struct qedi_ctx *qedi, int type,\n\t\t\tchar *buf, enum qedi_nvm_tgts idx)\n{\n\tint rc = 1;\n\tu32 ctrl_flags, ipv6_en, chap_en, mchap_en, ip_len;\n\tstruct nvm_iscsi_block *block;\n\tchar *chap_name, *chap_secret;\n\tchar *mchap_name, *mchap_secret;\n\n\tblock = qedi_get_nvram_block(qedi);\n\tif (!block)\n\t\tgoto exit_show_tgt_info;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_EVT,\n\t\t  \"Port:%d, tgt_idx:%d\\n\",\n\t\t  GET_FIELD2(block->id, NVM_ISCSI_CFG_BLK_MAPPED_PF_ID), idx);\n\n\tctrl_flags = block->target[idx].ctrl_flags &\n\t\t     NVM_ISCSI_CFG_TARGET_ENABLED;\n\n\tif (!ctrl_flags) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_EVT,\n\t\t\t  \"Target disabled\\n\");\n\t\tgoto exit_show_tgt_info;\n\t}\n\n\tipv6_en = block->generic.ctrl_flags &\n\t\t  NVM_ISCSI_CFG_GEN_IPV6_ENABLED;\n\tip_len = ipv6_en ? IPV6_LEN : IPV4_LEN;\n\tchap_en = block->generic.ctrl_flags &\n\t\t  NVM_ISCSI_CFG_GEN_CHAP_ENABLED;\n\tchap_name = chap_en ? block->initiator.chap_name.byte : NULL;\n\tchap_secret = chap_en ? block->initiator.chap_password.byte : NULL;\n\n\tmchap_en = block->generic.ctrl_flags &\n\t\t  NVM_ISCSI_CFG_GEN_CHAP_MUTUAL_ENABLED;\n\tmchap_name = mchap_en ? block->target[idx].chap_name.byte : NULL;\n\tmchap_secret = mchap_en ? block->target[idx].chap_password.byte : NULL;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_NAME:\n\t\trc = sprintf(buf, \"%.*s\\n\", NVM_ISCSI_CFG_ISCSI_NAME_MAX_LEN,\n\t\t\t     block->target[idx].target_name.byte);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\t\tif (ipv6_en)\n\t\t\trc = snprintf(buf, ip_len, \"%pI6\\n\",\n\t\t\t\t      block->target[idx].ipv6_addr.byte);\n\t\telse\n\t\t\trc = snprintf(buf, ip_len, \"%pI4\\n\",\n\t\t\t\t      block->target[idx].ipv4_addr.byte);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_PORT:\n\t\trc = snprintf(buf, 12, \"%d\\n\",\n\t\t\t      GET_FIELD2(block->target[idx].generic_cont0,\n\t\t\t\t\t NVM_ISCSI_CFG_TARGET_TCP_PORT));\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_LUN:\n\t\trc = snprintf(buf, 22, \"%.*d\\n\",\n\t\t\t      block->target[idx].lun.value[1],\n\t\t\t      block->target[idx].lun.value[0]);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\t\trc = sprintf(buf, \"%.*s\\n\", NVM_ISCSI_CFG_CHAP_NAME_MAX_LEN,\n\t\t\t     chap_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\t\trc = sprintf(buf, \"%.*s\\n\", NVM_ISCSI_CFG_CHAP_PWD_MAX_LEN,\n\t\t\t     chap_secret);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\t\trc = sprintf(buf, \"%.*s\\n\", NVM_ISCSI_CFG_CHAP_NAME_MAX_LEN,\n\t\t\t     mchap_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\t\trc = sprintf(buf, \"%.*s\\n\", NVM_ISCSI_CFG_CHAP_PWD_MAX_LEN,\n\t\t\t     mchap_secret);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\trc = snprintf(buf, 3, \"%d\\n\", (char)SYSFS_FLAG_FW_SEL_BOOT);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\t\trc = snprintf(buf, 3, \"0\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\nexit_show_tgt_info:\n\treturn rc;\n}\n\nstatic ssize_t qedi_show_boot_tgt_pri_info(void *data, int type, char *buf)\n{\n\tstruct qedi_ctx *qedi = data;\n\n\treturn qedi_show_boot_tgt_info(qedi, type, buf, QEDI_NVM_TGT_PRI);\n}\n\nstatic ssize_t qedi_show_boot_tgt_sec_info(void *data, int type, char *buf)\n{\n\tstruct qedi_ctx *qedi = data;\n\n\treturn qedi_show_boot_tgt_info(qedi, type, buf, QEDI_NVM_TGT_SEC);\n}\n\nstatic umode_t qedi_tgt_get_attr_visibility(void *data, int type)\n{\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_NAME:\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\tcase ISCSI_BOOT_TGT_PORT:\n\tcase ISCSI_BOOT_TGT_LUN:\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\trc = 0444;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic void qedi_boot_release(void *data)\n{\n\tstruct qedi_ctx *qedi = data;\n\n\tscsi_host_put(qedi->shost);\n}\n\nstatic int qedi_get_boot_info(struct qedi_ctx *qedi)\n{\n\tint ret = 1;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"Get NVM iSCSI CFG image\\n\");\n\tret = qedi_ops->common->nvm_get_image(qedi->cdev,\n\t\t\t\t\t      QED_NVM_IMAGE_ISCSI_CFG,\n\t\t\t\t\t      (char *)qedi->iscsi_image,\n\t\t\t\t\t      sizeof(struct qedi_nvm_iscsi_image));\n\tif (ret)\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Could not get NVM image. ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int qedi_setup_boot_info(struct qedi_ctx *qedi)\n{\n\tstruct iscsi_boot_kobj *boot_kobj;\n\n\tif (qedi_get_boot_info(qedi))\n\t\treturn -EPERM;\n\n\tqedi->boot_kset = iscsi_boot_create_host_kset(qedi->shost->host_no);\n\tif (!qedi->boot_kset)\n\t\tgoto kset_free;\n\n\tif (!scsi_host_get(qedi->shost))\n\t\tgoto kset_free;\n\n\tboot_kobj = iscsi_boot_create_target(qedi->boot_kset, 0, qedi,\n\t\t\t\t\t     qedi_show_boot_tgt_pri_info,\n\t\t\t\t\t     qedi_tgt_get_attr_visibility,\n\t\t\t\t\t     qedi_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(qedi->shost))\n\t\tgoto kset_free;\n\n\tboot_kobj = iscsi_boot_create_target(qedi->boot_kset, 1, qedi,\n\t\t\t\t\t     qedi_show_boot_tgt_sec_info,\n\t\t\t\t\t     qedi_tgt_get_attr_visibility,\n\t\t\t\t\t     qedi_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(qedi->shost))\n\t\tgoto kset_free;\n\n\tboot_kobj = iscsi_boot_create_initiator(qedi->boot_kset, 0, qedi,\n\t\t\t\t\t\tqedi_show_boot_ini_info,\n\t\t\t\t\t\tqedi_ini_get_attr_visibility,\n\t\t\t\t\t\tqedi_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(qedi->shost))\n\t\tgoto kset_free;\n\n\tboot_kobj = iscsi_boot_create_ethernet(qedi->boot_kset, 0, qedi,\n\t\t\t\t\t       qedi_show_boot_eth_info,\n\t\t\t\t\t       qedi_eth_get_attr_visibility,\n\t\t\t\t\t       qedi_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\treturn 0;\n\nput_host:\n\tscsi_host_put(qedi->shost);\nkset_free:\n\tiscsi_boot_destroy_kset(qedi->boot_kset);\n\treturn -ENOMEM;\n}\n\nstatic pci_ers_result_t qedi_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t       pci_channel_state_t state)\n{\n\tstruct qedi_ctx *qedi = pci_get_drvdata(pdev);\n\n\tQEDI_ERR(&qedi->dbg_ctx, \"%s: PCI error detected [%d]\\n\",\n\t\t __func__, state);\n\n\tif (test_and_set_bit(QEDI_IN_RECOVERY, &qedi->flags)) {\n\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t  \"Recovery already in progress.\\n\");\n\t\treturn PCI_ERS_RESULT_NONE;\n\t}\n\n\tqedi_ops->common->recovery_process(qedi->cdev);\n\n\treturn PCI_ERS_RESULT_CAN_RECOVER;\n}\n\nstatic void __qedi_remove(struct pci_dev *pdev, int mode)\n{\n\tstruct qedi_ctx *qedi = pci_get_drvdata(pdev);\n\tint rval;\n\tu16 retry = 10;\n\n\tif (mode == QEDI_MODE_NORMAL)\n\t\tiscsi_host_remove(qedi->shost, false);\n\telse if (mode == QEDI_MODE_SHUTDOWN)\n\t\tiscsi_host_remove(qedi->shost, true);\n\n\tif (mode == QEDI_MODE_NORMAL || mode == QEDI_MODE_SHUTDOWN) {\n\t\tif (qedi->tmf_thread) {\n\t\t\tdestroy_workqueue(qedi->tmf_thread);\n\t\t\tqedi->tmf_thread = NULL;\n\t\t}\n\n\t\tif (qedi->offload_thread) {\n\t\t\tdestroy_workqueue(qedi->offload_thread);\n\t\t\tqedi->offload_thread = NULL;\n\t\t}\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\tqedi_dbg_host_exit(&qedi->dbg_ctx);\n#endif\n\tif (!test_bit(QEDI_IN_OFFLINE, &qedi->flags))\n\t\tqedi_ops->common->set_power_state(qedi->cdev, PCI_D0);\n\n\tqedi_sync_free_irqs(qedi);\n\n\tif (!test_bit(QEDI_IN_OFFLINE, &qedi->flags)) {\n\t\twhile (retry--) {\n\t\t\trval = qedi_ops->stop(qedi->cdev);\n\t\t\tif (rval < 0)\n\t\t\t\tmsleep(1000);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tqedi_ops->ll2->stop(qedi->cdev);\n\t}\n\n\tcancel_delayed_work_sync(&qedi->recovery_work);\n\tcancel_delayed_work_sync(&qedi->board_disable_work);\n\n\tqedi_free_iscsi_pf_param(qedi);\n\n\trval = qedi_ops->common->update_drv_state(qedi->cdev, false);\n\tif (rval)\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Failed to send drv state to MFW\\n\");\n\n\tif (!test_bit(QEDI_IN_OFFLINE, &qedi->flags)) {\n\t\tqedi_ops->common->slowpath_stop(qedi->cdev);\n\t\tqedi_ops->common->remove(qedi->cdev);\n\t}\n\n\tqedi_destroy_fp(qedi);\n\n\tif (mode == QEDI_MODE_NORMAL || mode == QEDI_MODE_SHUTDOWN) {\n\t\tqedi_release_cid_que(qedi);\n\t\tqedi_cm_free_mem(qedi);\n\t\tqedi_free_uio(qedi->udev);\n\t\tqedi_free_itt(qedi);\n\n\t\tif (qedi->ll2_recv_thread) {\n\t\t\tkthread_stop(qedi->ll2_recv_thread);\n\t\t\tqedi->ll2_recv_thread = NULL;\n\t\t}\n\t\tqedi_ll2_free_skbs(qedi);\n\n\t\tif (qedi->boot_kset)\n\t\t\tiscsi_boot_destroy_kset(qedi->boot_kset);\n\n\t\tiscsi_host_free(qedi->shost);\n\t}\n}\n\nstatic void qedi_board_disable_work(struct work_struct *work)\n{\n\tstruct qedi_ctx *qedi =\n\t\t\tcontainer_of(work, struct qedi_ctx,\n\t\t\t\t     board_disable_work.work);\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"Fan failure, Unloading firmware context.\\n\");\n\n\tif (test_and_set_bit(QEDI_IN_SHUTDOWN, &qedi->flags))\n\t\treturn;\n\n\t__qedi_remove(qedi->pdev, QEDI_MODE_NORMAL);\n}\n\nstatic void qedi_shutdown(struct pci_dev *pdev)\n{\n\tstruct qedi_ctx *qedi = pci_get_drvdata(pdev);\n\n\tQEDI_ERR(&qedi->dbg_ctx, \"%s: Shutdown qedi\\n\", __func__);\n\tif (test_and_set_bit(QEDI_IN_SHUTDOWN, &qedi->flags))\n\t\treturn;\n\t__qedi_remove(pdev, QEDI_MODE_SHUTDOWN);\n}\n\nstatic int qedi_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct qedi_ctx *qedi;\n\n\tif (!pdev) {\n\t\tQEDI_ERR(NULL, \"pdev is NULL.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tqedi = pci_get_drvdata(pdev);\n\n\tQEDI_ERR(&qedi->dbg_ctx, \"%s: Device does not support suspend operation\\n\", __func__);\n\n\treturn -EPERM;\n}\n\nstatic int __qedi_probe(struct pci_dev *pdev, int mode)\n{\n\tstruct qedi_ctx *qedi;\n\tstruct qed_ll2_params params;\n\tu8 dp_level = 0;\n\tbool is_vf = false;\n\tchar host_buf[16];\n\tstruct qed_link_params link_params;\n\tstruct qed_slowpath_params sp_params;\n\tstruct qed_probe_params qed_params;\n\tvoid *task_start, *task_end;\n\tint rc;\n\tu16 retry = 10;\n\n\tif (mode != QEDI_MODE_RECOVERY) {\n\t\tqedi = qedi_host_alloc(pdev);\n\t\tif (!qedi) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit_probe;\n\t\t}\n\t} else {\n\t\tqedi = pci_get_drvdata(pdev);\n\t}\n\nretry_probe:\n\tif (mode == QEDI_MODE_RECOVERY)\n\t\tmsleep(2000);\n\n\tmemset(&qed_params, 0, sizeof(qed_params));\n\tqed_params.protocol = QED_PROTOCOL_ISCSI;\n\tqed_params.dp_module = qedi_qed_debug;\n\tqed_params.dp_level = dp_level;\n\tqed_params.is_vf = is_vf;\n\tqedi->cdev = qedi_ops->common->probe(pdev, &qed_params);\n\tif (!qedi->cdev) {\n\t\tif (mode == QEDI_MODE_RECOVERY && retry) {\n\t\t\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t\t\t  \"Retry %d initialize hardware\\n\", retry);\n\t\t\tretry--;\n\t\t\tgoto retry_probe;\n\t\t}\n\n\t\trc = -ENODEV;\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Cannot initialize hardware\\n\");\n\t\tgoto free_host;\n\t}\n\n\tset_bit(QEDI_ERR_ATTN_CLR_EN, &qedi->qedi_err_flags);\n\tset_bit(QEDI_ERR_IS_RECOVERABLE, &qedi->qedi_err_flags);\n\tatomic_set(&qedi->link_state, QEDI_LINK_DOWN);\n\n\trc = qedi_ops->fill_dev_info(qedi->cdev, &qedi->dev_info);\n\tif (rc)\n\t\tgoto free_host;\n\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"dev_info: num_hwfns=%d affin_hwfn_idx=%d.\\n\",\n\t\t  qedi->dev_info.common.num_hwfns,\n\t\t  qedi_ops->common->get_affin_hwfn_idx(qedi->cdev));\n\n\trc = qedi_set_iscsi_pf_param(qedi);\n\tif (rc) {\n\t\trc = -ENOMEM;\n\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t \"Set iSCSI pf param fail\\n\");\n\t\tgoto free_host;\n\t}\n\n\tqedi_ops->common->update_pf_params(qedi->cdev, &qedi->pf_params);\n\n\trc = qedi_prepare_fp(qedi);\n\tif (rc) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Cannot start slowpath.\\n\");\n\t\tgoto free_pf_params;\n\t}\n\n\t \n\tmemset(&sp_params, 0, sizeof(struct qed_slowpath_params));\n\tsp_params.int_mode = QED_INT_MODE_MSIX;\n\tsp_params.drv_major = QEDI_DRIVER_MAJOR_VER;\n\tsp_params.drv_minor = QEDI_DRIVER_MINOR_VER;\n\tsp_params.drv_rev = QEDI_DRIVER_REV_VER;\n\tsp_params.drv_eng = QEDI_DRIVER_ENG_VER;\n\tstrscpy(sp_params.name, \"qedi iSCSI\", QED_DRV_VER_STR_SIZE);\n\trc = qedi_ops->common->slowpath_start(qedi->cdev, &sp_params);\n\tif (rc) {\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Cannot start slowpath\\n\");\n\t\tgoto stop_hw;\n\t}\n\n\t \n\tqedi_ops->common->update_pf_params(qedi->cdev, &qedi->pf_params);\n\n\trc = qedi_setup_int(qedi);\n\tif (rc)\n\t\tgoto stop_iscsi_func;\n\n\tqedi_ops->common->set_power_state(qedi->cdev, PCI_D0);\n\n\t \n\trc = qedi_ops->fill_dev_info(qedi->cdev, &qedi->dev_info);\n\tif (rc)\n\t\tgoto stop_iscsi_func;\n\n\t \n\tqedi->bdq_primary_prod = qedi->dev_info.primary_dbq_rq_addr;\n\tqedi->bdq_secondary_prod = qedi->dev_info.secondary_bdq_rq_addr;\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_DISC,\n\t\t  \"BDQ primary_prod=%p secondary_prod=%p.\\n\",\n\t\t  qedi->bdq_primary_prod,\n\t\t  qedi->bdq_secondary_prod);\n\n\t \n\tqedi->bdq_prod_idx = QEDI_BDQ_NUM;\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_DISC,\n\t\t  \"Writing %d to primary and secondary BDQ doorbell registers.\\n\",\n\t\t  qedi->bdq_prod_idx);\n\twritew(qedi->bdq_prod_idx, qedi->bdq_primary_prod);\n\treadw(qedi->bdq_primary_prod);\n\twritew(qedi->bdq_prod_idx, qedi->bdq_secondary_prod);\n\treadw(qedi->bdq_secondary_prod);\n\n\tether_addr_copy(qedi->mac, qedi->dev_info.common.hw_mac);\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_DISC, \"MAC address is %pM.\\n\",\n\t\t  qedi->mac);\n\n\tsnprintf(host_buf, sizeof(host_buf), \"host_%d\", qedi->shost->host_no);\n\tqedi_ops->common->set_name(qedi->cdev, host_buf);\n\n\tqedi_ops->register_ops(qedi->cdev, &qedi_cb_ops, qedi);\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.mtu = DEF_PATH_MTU + IPV6_HDR_LEN + TCP_HDR_LEN;\n\tqedi->ll2_mtu = DEF_PATH_MTU;\n\tparams.drop_ttl0_packets = 0;\n\tparams.rx_vlan_stripping = 1;\n\tether_addr_copy(params.ll2_mac_address, qedi->dev_info.common.hw_mac);\n\n\tif (mode != QEDI_MODE_RECOVERY) {\n\t\t \n\t\tINIT_LIST_HEAD(&qedi->ll2_skb_list);\n\t\tspin_lock_init(&qedi->ll2_lock);\n\t\t \n\t\tspin_lock_init(&qedi->hba_lock);\n\t\tspin_lock_init(&qedi->task_idx_lock);\n\t\tmutex_init(&qedi->stats_lock);\n\t}\n\tqedi_ops->ll2->register_cb_ops(qedi->cdev, &qedi_ll2_cb_ops, qedi);\n\tqedi_ops->ll2->start(qedi->cdev, &params);\n\n\tif (mode != QEDI_MODE_RECOVERY) {\n\t\tqedi->ll2_recv_thread = kthread_run(qedi_ll2_recv_thread,\n\t\t\t\t\t\t    (void *)qedi,\n\t\t\t\t\t\t    \"qedi_ll2_thread\");\n\t}\n\n\trc = qedi_ops->start(qedi->cdev, &qedi->tasks,\n\t\t\t     qedi, qedi_iscsi_event_cb);\n\tif (rc) {\n\t\trc = -ENODEV;\n\t\tQEDI_ERR(&qedi->dbg_ctx, \"Cannot start iSCSI function\\n\");\n\t\tgoto stop_slowpath;\n\t}\n\n\ttask_start = qedi_get_task_mem(&qedi->tasks, 0);\n\ttask_end = qedi_get_task_mem(&qedi->tasks, MAX_TID_BLOCKS_ISCSI - 1);\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_DISC,\n\t\t  \"Task context start=%p, end=%p block_size=%u.\\n\",\n\t\t   task_start, task_end, qedi->tasks.size);\n\n\tmemset(&link_params, 0, sizeof(link_params));\n\tlink_params.link_up = true;\n\trc = qedi_ops->common->set_link(qedi->cdev, &link_params);\n\tif (rc) {\n\t\tQEDI_WARN(&qedi->dbg_ctx, \"Link set up failed.\\n\");\n\t\tatomic_set(&qedi->link_state, QEDI_LINK_DOWN);\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\tqedi_dbg_host_init(&qedi->dbg_ctx, qedi_debugfs_ops,\n\t\t\t   qedi_dbg_fops);\n#endif\n\tQEDI_INFO(&qedi->dbg_ctx, QEDI_LOG_INFO,\n\t\t  \"QLogic FastLinQ iSCSI Module qedi %s, FW %d.%d.%d.%d\\n\",\n\t\t  QEDI_MODULE_VERSION, FW_MAJOR_VERSION, FW_MINOR_VERSION,\n\t\t  FW_REVISION_VERSION, FW_ENGINEERING_VERSION);\n\n\tif (mode == QEDI_MODE_NORMAL) {\n\t\tif (iscsi_host_add(qedi->shost, &pdev->dev)) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Could not add iscsi host\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto remove_host;\n\t\t}\n\n\t\t \n\t\trc = qedi_alloc_uio_rings(qedi);\n\t\tif (rc) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"UIO alloc ring failed err=%d\\n\", rc);\n\t\t\tgoto remove_host;\n\t\t}\n\n\t\trc = qedi_init_uio(qedi);\n\t\tif (rc) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"UIO init failed, err=%d\\n\", rc);\n\t\t\tgoto free_uio;\n\t\t}\n\n\t\t \n\t\trc = qedi_setup_cid_que(qedi);\n\t\tif (rc) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Could not setup cid que\\n\");\n\t\t\tgoto free_uio;\n\t\t}\n\n\t\trc = qedi_cm_alloc_mem(qedi);\n\t\tif (rc) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Could not alloc cm memory\\n\");\n\t\t\tgoto free_cid_que;\n\t\t}\n\n\t\trc = qedi_alloc_itt(qedi);\n\t\tif (rc) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Could not alloc itt memory\\n\");\n\t\t\tgoto free_cid_que;\n\t\t}\n\n\t\tsprintf(host_buf, \"host_%d\", qedi->shost->host_no);\n\t\tqedi->tmf_thread = create_singlethread_workqueue(host_buf);\n\t\tif (!qedi->tmf_thread) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Unable to start tmf thread!\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto free_cid_que;\n\t\t}\n\n\t\tsprintf(host_buf, \"qedi_ofld%d\", qedi->shost->host_no);\n\t\tqedi->offload_thread = create_workqueue(host_buf);\n\t\tif (!qedi->offload_thread) {\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Unable to start offload thread!\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto free_tmf_thread;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&qedi->recovery_work, qedi_recovery_handler);\n\t\tINIT_DELAYED_WORK(&qedi->board_disable_work,\n\t\t\t\t  qedi_board_disable_work);\n\n\t\t \n\t\tset_bit(QEDI_RESERVE_TASK_ID, qedi->task_idx_map);\n\t\tatomic_set(&qedi->num_offloads, 0);\n\n\t\tif (qedi_setup_boot_info(qedi))\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"No iSCSI boot target configured\\n\");\n\n\t\trc = qedi_ops->common->update_drv_state(qedi->cdev, true);\n\t\tif (rc)\n\t\t\tQEDI_ERR(&qedi->dbg_ctx,\n\t\t\t\t \"Failed to send drv state to MFW\\n\");\n\n\t}\n\n\treturn 0;\n\nfree_tmf_thread:\n\tdestroy_workqueue(qedi->tmf_thread);\nfree_cid_que:\n\tqedi_release_cid_que(qedi);\nfree_uio:\n\tqedi_free_uio(qedi->udev);\nremove_host:\n#ifdef CONFIG_DEBUG_FS\n\tqedi_dbg_host_exit(&qedi->dbg_ctx);\n#endif\n\tiscsi_host_remove(qedi->shost, false);\nstop_iscsi_func:\n\tqedi_ops->stop(qedi->cdev);\nstop_slowpath:\n\tqedi_ops->common->slowpath_stop(qedi->cdev);\nstop_hw:\n\tqedi_ops->common->remove(qedi->cdev);\nfree_pf_params:\n\tqedi_free_iscsi_pf_param(qedi);\nfree_host:\n\tiscsi_host_free(qedi->shost);\nexit_probe:\n\treturn rc;\n}\n\nstatic void qedi_mark_conn_recovery(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct iscsi_conn *conn = session->leadconn;\n\tstruct qedi_conn *qedi_conn = conn->dd_data;\n\n\tiscsi_conn_failure(qedi_conn->cls_conn->dd_data, ISCSI_ERR_CONN_FAILED);\n}\n\nstatic void qedi_recovery_handler(struct work_struct *work)\n{\n\tstruct qedi_ctx *qedi =\n\t\t\tcontainer_of(work, struct qedi_ctx, recovery_work.work);\n\n\tiscsi_host_for_each_session(qedi->shost, qedi_mark_conn_recovery);\n\n\t \n\tqedi_ops->common->recovery_prolog(qedi->cdev);\n\n\t__qedi_remove(qedi->pdev, QEDI_MODE_RECOVERY);\n\t__qedi_probe(qedi->pdev, QEDI_MODE_RECOVERY);\n\tclear_bit(QEDI_IN_RECOVERY, &qedi->flags);\n}\n\nstatic int qedi_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\treturn __qedi_probe(pdev, QEDI_MODE_NORMAL);\n}\n\nstatic void qedi_remove(struct pci_dev *pdev)\n{\n\t__qedi_remove(pdev, QEDI_MODE_NORMAL);\n}\n\nstatic struct pci_device_id qedi_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, 0x165E) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_QLOGIC, 0x8084) },\n\t{ 0 },\n};\nMODULE_DEVICE_TABLE(pci, qedi_pci_tbl);\n\nstatic enum cpuhp_state qedi_cpuhp_state;\n\nstatic struct pci_error_handlers qedi_err_handler = {\n\t.error_detected = qedi_io_error_detected,\n};\n\nstatic struct pci_driver qedi_pci_driver = {\n\t.name = QEDI_MODULE_NAME,\n\t.id_table = qedi_pci_tbl,\n\t.probe = qedi_probe,\n\t.remove = qedi_remove,\n\t.shutdown = qedi_shutdown,\n\t.err_handler = &qedi_err_handler,\n\t.suspend = qedi_suspend,\n};\n\nstatic int __init qedi_init(void)\n{\n\tstruct qedi_percpu_s *p;\n\tint cpu, rc = 0;\n\n\tqedi_ops = qed_get_iscsi_ops();\n\tif (!qedi_ops) {\n\t\tQEDI_ERR(NULL, \"Failed to get qed iSCSI operations\\n\");\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\tqedi_dbg_init(\"qedi\");\n#endif\n\n\tqedi_scsi_transport = iscsi_register_transport(&qedi_iscsi_transport);\n\tif (!qedi_scsi_transport) {\n\t\tQEDI_ERR(NULL, \"Could not register qedi transport\");\n\t\trc = -ENOMEM;\n\t\tgoto exit_qedi_init_1;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tp = &per_cpu(qedi_percpu, cpu);\n\t\tINIT_LIST_HEAD(&p->work_list);\n\t\tspin_lock_init(&p->p_work_lock);\n\t\tp->iothread = NULL;\n\t}\n\n\trc = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"scsi/qedi:online\",\n\t\t\t       qedi_cpu_online, qedi_cpu_offline);\n\tif (rc < 0)\n\t\tgoto exit_qedi_init_2;\n\tqedi_cpuhp_state = rc;\n\n\trc = pci_register_driver(&qedi_pci_driver);\n\tif (rc) {\n\t\tQEDI_ERR(NULL, \"Failed to register driver\\n\");\n\t\tgoto exit_qedi_hp;\n\t}\n\n\treturn 0;\n\nexit_qedi_hp:\n\tcpuhp_remove_state(qedi_cpuhp_state);\nexit_qedi_init_2:\n\tiscsi_unregister_transport(&qedi_iscsi_transport);\nexit_qedi_init_1:\n#ifdef CONFIG_DEBUG_FS\n\tqedi_dbg_exit();\n#endif\n\tqed_put_iscsi_ops();\n\treturn rc;\n}\n\nstatic void __exit qedi_cleanup(void)\n{\n\tpci_unregister_driver(&qedi_pci_driver);\n\tcpuhp_remove_state(qedi_cpuhp_state);\n\tiscsi_unregister_transport(&qedi_iscsi_transport);\n\n#ifdef CONFIG_DEBUG_FS\n\tqedi_dbg_exit();\n#endif\n\tqed_put_iscsi_ops();\n}\n\nMODULE_DESCRIPTION(\"QLogic FastLinQ 4xxxx iSCSI Module\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"QLogic Corporation\");\nMODULE_VERSION(QEDI_MODULE_VERSION);\nmodule_init(qedi_init);\nmodule_exit(qedi_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}