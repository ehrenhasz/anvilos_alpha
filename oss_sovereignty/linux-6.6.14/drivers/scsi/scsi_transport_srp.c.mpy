{
  "module_name": "scsi_transport_srp.c",
  "hash_id": "6c6bff018dd9cc2652c351ec471de4b814edbe4a745ec659f82191d2db1acf1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/scsi_transport_srp.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_srp.h>\n#include \"scsi_priv.h\"\n\nstruct srp_host_attrs {\n\tatomic_t next_port_id;\n};\n#define to_srp_host_attrs(host)\t((struct srp_host_attrs *)(host)->shost_data)\n\n#define SRP_HOST_ATTRS 0\n#define SRP_RPORT_ATTRS 8\n\nstruct srp_internal {\n\tstruct scsi_transport_template t;\n\tstruct srp_function_template *f;\n\n\tstruct device_attribute *host_attrs[SRP_HOST_ATTRS + 1];\n\n\tstruct device_attribute *rport_attrs[SRP_RPORT_ATTRS + 1];\n\tstruct transport_container rport_attr_cont;\n};\n\nstatic int scsi_is_srp_rport(const struct device *dev);\n\n#define to_srp_internal(tmpl) container_of(tmpl, struct srp_internal, t)\n\n#define\tdev_to_rport(d)\tcontainer_of(d, struct srp_rport, dev)\n#define transport_class_to_srp_rport(dev) dev_to_rport((dev)->parent)\nstatic inline struct Scsi_Host *rport_to_shost(struct srp_rport *r)\n{\n\treturn dev_to_shost(r->dev.parent);\n}\n\nstatic int find_child_rport(struct device *dev, void *data)\n{\n\tstruct device **child = data;\n\n\tif (scsi_is_srp_rport(dev)) {\n\t\tWARN_ON_ONCE(*child);\n\t\t*child = dev;\n\t}\n\treturn 0;\n}\n\nstatic inline struct srp_rport *shost_to_rport(struct Scsi_Host *shost)\n{\n\tstruct device *child = NULL;\n\n\tWARN_ON_ONCE(device_for_each_child(&shost->shost_gendev, &child,\n\t\t\t\t\t   find_child_rport) < 0);\n\treturn child ? dev_to_rport(child) : NULL;\n}\n\n \nint srp_tmo_valid(int reconnect_delay, int fast_io_fail_tmo, long dev_loss_tmo)\n{\n\tif (reconnect_delay < 0 && fast_io_fail_tmo < 0 && dev_loss_tmo < 0)\n\t\treturn -EINVAL;\n\tif (reconnect_delay == 0)\n\t\treturn -EINVAL;\n\tif (fast_io_fail_tmo > SCSI_DEVICE_BLOCK_MAX_TIMEOUT)\n\t\treturn -EINVAL;\n\tif (fast_io_fail_tmo < 0 &&\n\t    dev_loss_tmo > SCSI_DEVICE_BLOCK_MAX_TIMEOUT)\n\t\treturn -EINVAL;\n\tif (dev_loss_tmo >= LONG_MAX / HZ)\n\t\treturn -EINVAL;\n\tif (fast_io_fail_tmo >= 0 && dev_loss_tmo >= 0 &&\n\t    fast_io_fail_tmo >= dev_loss_tmo)\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(srp_tmo_valid);\n\nstatic int srp_host_setup(struct transport_container *tc, struct device *dev,\n\t\t\t  struct device *cdev)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct srp_host_attrs *srp_host = to_srp_host_attrs(shost);\n\n\tatomic_set(&srp_host->next_port_id, 0);\n\treturn 0;\n}\n\nstatic DECLARE_TRANSPORT_CLASS(srp_host_class, \"srp_host\", srp_host_setup,\n\t\t\t       NULL, NULL);\n\nstatic DECLARE_TRANSPORT_CLASS(srp_rport_class, \"srp_remote_ports\",\n\t\t\t       NULL, NULL, NULL);\n\nstatic ssize_t\nshow_srp_rport_id(struct device *dev, struct device_attribute *attr,\n\t\t  char *buf)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\treturn sprintf(buf, \"%16phC\\n\", rport->port_id);\n}\n\nstatic DEVICE_ATTR(port_id, S_IRUGO, show_srp_rport_id, NULL);\n\nstatic const struct {\n\tu32 value;\n\tchar *name;\n} srp_rport_role_names[] = {\n\t{SRP_RPORT_ROLE_INITIATOR, \"SRP Initiator\"},\n\t{SRP_RPORT_ROLE_TARGET, \"SRP Target\"},\n};\n\nstatic ssize_t\nshow_srp_rport_roles(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\tint i;\n\tchar *name = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(srp_rport_role_names); i++)\n\t\tif (srp_rport_role_names[i].value == rport->roles) {\n\t\t\tname = srp_rport_role_names[i].name;\n\t\t\tbreak;\n\t\t}\n\treturn sprintf(buf, \"%s\\n\", name ? : \"unknown\");\n}\n\nstatic DEVICE_ATTR(roles, S_IRUGO, show_srp_rport_roles, NULL);\n\nstatic ssize_t store_srp_rport_delete(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\tstruct Scsi_Host *shost = dev_to_shost(dev);\n\tstruct srp_internal *i = to_srp_internal(shost->transportt);\n\n\tif (i->f->rport_delete) {\n\t\ti->f->rport_delete(rport);\n\t\treturn count;\n\t} else {\n\t\treturn -ENOSYS;\n\t}\n}\n\nstatic DEVICE_ATTR(delete, S_IWUSR, NULL, store_srp_rport_delete);\n\nstatic ssize_t show_srp_rport_state(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstatic const char *const state_name[] = {\n\t\t[SRP_RPORT_RUNNING]\t= \"running\",\n\t\t[SRP_RPORT_BLOCKED]\t= \"blocked\",\n\t\t[SRP_RPORT_FAIL_FAST]\t= \"fail-fast\",\n\t\t[SRP_RPORT_LOST]\t= \"lost\",\n\t};\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\tenum srp_rport_state state = rport->state;\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       (unsigned)state < ARRAY_SIZE(state_name) ?\n\t\t       state_name[state] : \"???\");\n}\n\nstatic DEVICE_ATTR(state, S_IRUGO, show_srp_rport_state, NULL);\n\nstatic ssize_t srp_show_tmo(char *buf, int tmo)\n{\n\treturn tmo >= 0 ? sprintf(buf, \"%d\\n\", tmo) : sprintf(buf, \"off\\n\");\n}\n\nint srp_parse_tmo(int *tmo, const char *buf)\n{\n\tint res = 0;\n\n\tif (strncmp(buf, \"off\", 3) != 0)\n\t\tres = kstrtoint(buf, 0, tmo);\n\telse\n\t\t*tmo = -1;\n\n\treturn res;\n}\nEXPORT_SYMBOL(srp_parse_tmo);\n\nstatic ssize_t show_reconnect_delay(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\n\treturn srp_show_tmo(buf, rport->reconnect_delay);\n}\n\nstatic ssize_t store_reconnect_delay(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, const size_t count)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\tint res, delay;\n\n\tres = srp_parse_tmo(&delay, buf);\n\tif (res)\n\t\tgoto out;\n\tres = srp_tmo_valid(delay, rport->fast_io_fail_tmo,\n\t\t\t    rport->dev_loss_tmo);\n\tif (res)\n\t\tgoto out;\n\n\tif (rport->reconnect_delay <= 0 && delay > 0 &&\n\t    rport->state != SRP_RPORT_RUNNING) {\n\t\tqueue_delayed_work(system_long_wq, &rport->reconnect_work,\n\t\t\t\t   delay * HZ);\n\t} else if (delay <= 0) {\n\t\tcancel_delayed_work(&rport->reconnect_work);\n\t}\n\trport->reconnect_delay = delay;\n\tres = count;\n\nout:\n\treturn res;\n}\n\nstatic DEVICE_ATTR(reconnect_delay, S_IRUGO | S_IWUSR, show_reconnect_delay,\n\t\t   store_reconnect_delay);\n\nstatic ssize_t show_failed_reconnects(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\n\treturn sprintf(buf, \"%d\\n\", rport->failed_reconnects);\n}\n\nstatic DEVICE_ATTR(failed_reconnects, S_IRUGO, show_failed_reconnects, NULL);\n\nstatic ssize_t show_srp_rport_fast_io_fail_tmo(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\n\treturn srp_show_tmo(buf, rport->fast_io_fail_tmo);\n}\n\nstatic ssize_t store_srp_rport_fast_io_fail_tmo(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\tint res;\n\tint fast_io_fail_tmo;\n\n\tres = srp_parse_tmo(&fast_io_fail_tmo, buf);\n\tif (res)\n\t\tgoto out;\n\tres = srp_tmo_valid(rport->reconnect_delay, fast_io_fail_tmo,\n\t\t\t    rport->dev_loss_tmo);\n\tif (res)\n\t\tgoto out;\n\trport->fast_io_fail_tmo = fast_io_fail_tmo;\n\tres = count;\n\nout:\n\treturn res;\n}\n\nstatic DEVICE_ATTR(fast_io_fail_tmo, S_IRUGO | S_IWUSR,\n\t\t   show_srp_rport_fast_io_fail_tmo,\n\t\t   store_srp_rport_fast_io_fail_tmo);\n\nstatic ssize_t show_srp_rport_dev_loss_tmo(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\n\treturn srp_show_tmo(buf, rport->dev_loss_tmo);\n}\n\nstatic ssize_t store_srp_rport_dev_loss_tmo(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct srp_rport *rport = transport_class_to_srp_rport(dev);\n\tint res;\n\tint dev_loss_tmo;\n\n\tres = srp_parse_tmo(&dev_loss_tmo, buf);\n\tif (res)\n\t\tgoto out;\n\tres = srp_tmo_valid(rport->reconnect_delay, rport->fast_io_fail_tmo,\n\t\t\t    dev_loss_tmo);\n\tif (res)\n\t\tgoto out;\n\trport->dev_loss_tmo = dev_loss_tmo;\n\tres = count;\n\nout:\n\treturn res;\n}\n\nstatic DEVICE_ATTR(dev_loss_tmo, S_IRUGO | S_IWUSR,\n\t\t   show_srp_rport_dev_loss_tmo,\n\t\t   store_srp_rport_dev_loss_tmo);\n\nstatic int srp_rport_set_state(struct srp_rport *rport,\n\t\t\t       enum srp_rport_state new_state)\n{\n\tenum srp_rport_state old_state = rport->state;\n\n\tlockdep_assert_held(&rport->mutex);\n\n\tswitch (new_state) {\n\tcase SRP_RPORT_RUNNING:\n\t\tswitch (old_state) {\n\t\tcase SRP_RPORT_LOST:\n\t\t\tgoto invalid;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SRP_RPORT_BLOCKED:\n\t\tswitch (old_state) {\n\t\tcase SRP_RPORT_RUNNING:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto invalid;\n\t\t}\n\t\tbreak;\n\tcase SRP_RPORT_FAIL_FAST:\n\t\tswitch (old_state) {\n\t\tcase SRP_RPORT_LOST:\n\t\t\tgoto invalid;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SRP_RPORT_LOST:\n\t\tbreak;\n\t}\n\trport->state = new_state;\n\treturn 0;\n\ninvalid:\n\treturn -EINVAL;\n}\n\n \nstatic void srp_reconnect_work(struct work_struct *work)\n{\n\tstruct srp_rport *rport = container_of(to_delayed_work(work),\n\t\t\t\t\tstruct srp_rport, reconnect_work);\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tint delay, res;\n\n\tres = srp_reconnect_rport(rport);\n\tif (res != 0) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"reconnect attempt %d failed (%d)\\n\",\n\t\t\t     ++rport->failed_reconnects, res);\n\t\tdelay = rport->reconnect_delay *\n\t\t\tmin(100, max(1, rport->failed_reconnects - 10));\n\t\tif (delay > 0)\n\t\t\tqueue_delayed_work(system_long_wq,\n\t\t\t\t\t   &rport->reconnect_work, delay * HZ);\n\t}\n}\n\n \nstatic void __rport_fail_io_fast(struct srp_rport *rport)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct srp_internal *i;\n\n\tlockdep_assert_held(&rport->mutex);\n\n\tif (srp_rport_set_state(rport, SRP_RPORT_FAIL_FAST))\n\t\treturn;\n\n\tscsi_target_unblock(rport->dev.parent, SDEV_TRANSPORT_OFFLINE);\n\n\t \n\ti = to_srp_internal(shost->transportt);\n\tif (i->f->terminate_rport_io)\n\t\ti->f->terminate_rport_io(rport);\n}\n\n \nstatic void rport_fast_io_fail_timedout(struct work_struct *work)\n{\n\tstruct srp_rport *rport = container_of(to_delayed_work(work),\n\t\t\t\t\tstruct srp_rport, fast_io_fail_work);\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\n\tpr_info(\"fast_io_fail_tmo expired for SRP %s / %s.\\n\",\n\t\tdev_name(&rport->dev), dev_name(&shost->shost_gendev));\n\n\tmutex_lock(&rport->mutex);\n\tif (rport->state == SRP_RPORT_BLOCKED)\n\t\t__rport_fail_io_fast(rport);\n\tmutex_unlock(&rport->mutex);\n}\n\n \nstatic void rport_dev_loss_timedout(struct work_struct *work)\n{\n\tstruct srp_rport *rport = container_of(to_delayed_work(work),\n\t\t\t\t\tstruct srp_rport, dev_loss_work);\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct srp_internal *i = to_srp_internal(shost->transportt);\n\n\tpr_info(\"dev_loss_tmo expired for SRP %s / %s.\\n\",\n\t\tdev_name(&rport->dev), dev_name(&shost->shost_gendev));\n\n\tmutex_lock(&rport->mutex);\n\tWARN_ON(srp_rport_set_state(rport, SRP_RPORT_LOST) != 0);\n\tscsi_target_unblock(rport->dev.parent, SDEV_TRANSPORT_OFFLINE);\n\tmutex_unlock(&rport->mutex);\n\n\ti->f->rport_delete(rport);\n}\n\nstatic void __srp_start_tl_fail_timers(struct srp_rport *rport)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tint delay, fast_io_fail_tmo, dev_loss_tmo;\n\n\tlockdep_assert_held(&rport->mutex);\n\n\tdelay = rport->reconnect_delay;\n\tfast_io_fail_tmo = rport->fast_io_fail_tmo;\n\tdev_loss_tmo = rport->dev_loss_tmo;\n\tpr_debug(\"%s current state: %d\\n\", dev_name(&shost->shost_gendev),\n\t\t rport->state);\n\n\tif (rport->state == SRP_RPORT_LOST)\n\t\treturn;\n\tif (delay > 0)\n\t\tqueue_delayed_work(system_long_wq, &rport->reconnect_work,\n\t\t\t\t   1UL * delay * HZ);\n\tif ((fast_io_fail_tmo >= 0 || dev_loss_tmo >= 0) &&\n\t    srp_rport_set_state(rport, SRP_RPORT_BLOCKED) == 0) {\n\t\tpr_debug(\"%s new state: %d\\n\", dev_name(&shost->shost_gendev),\n\t\t\t rport->state);\n\t\tscsi_block_targets(shost, &shost->shost_gendev);\n\t\tif (fast_io_fail_tmo >= 0)\n\t\t\tqueue_delayed_work(system_long_wq,\n\t\t\t\t\t   &rport->fast_io_fail_work,\n\t\t\t\t\t   1UL * fast_io_fail_tmo * HZ);\n\t\tif (dev_loss_tmo >= 0)\n\t\t\tqueue_delayed_work(system_long_wq,\n\t\t\t\t\t   &rport->dev_loss_work,\n\t\t\t\t\t   1UL * dev_loss_tmo * HZ);\n\t}\n}\n\n \nvoid srp_start_tl_fail_timers(struct srp_rport *rport)\n{\n\tmutex_lock(&rport->mutex);\n\t__srp_start_tl_fail_timers(rport);\n\tmutex_unlock(&rport->mutex);\n}\nEXPORT_SYMBOL(srp_start_tl_fail_timers);\n\n \nint srp_reconnect_rport(struct srp_rport *rport)\n{\n\tstruct Scsi_Host *shost = rport_to_shost(rport);\n\tstruct srp_internal *i = to_srp_internal(shost->transportt);\n\tstruct scsi_device *sdev;\n\tint res;\n\n\tpr_debug(\"SCSI host %s\\n\", dev_name(&shost->shost_gendev));\n\n\tres = mutex_lock_interruptible(&rport->mutex);\n\tif (res)\n\t\tgoto out;\n\tif (rport->state != SRP_RPORT_FAIL_FAST && rport->state != SRP_RPORT_LOST)\n\t\t \n\t\tscsi_block_targets(shost, &shost->shost_gendev);\n\tres = rport->state != SRP_RPORT_LOST ? i->f->reconnect(rport) : -ENODEV;\n\tpr_debug(\"%s (state %d): transport.reconnect() returned %d\\n\",\n\t\t dev_name(&shost->shost_gendev), rport->state, res);\n\tif (res == 0) {\n\t\tcancel_delayed_work(&rport->fast_io_fail_work);\n\t\tcancel_delayed_work(&rport->dev_loss_work);\n\n\t\trport->failed_reconnects = 0;\n\t\tsrp_rport_set_state(rport, SRP_RPORT_RUNNING);\n\t\tscsi_target_unblock(&shost->shost_gendev, SDEV_RUNNING);\n\t\t \n\t\tshost_for_each_device(sdev, shost) {\n\t\t\tmutex_lock(&sdev->state_mutex);\n\t\t\tif (sdev->sdev_state == SDEV_OFFLINE)\n\t\t\t\tsdev->sdev_state = SDEV_RUNNING;\n\t\t\tmutex_unlock(&sdev->state_mutex);\n\t\t}\n\t} else if (rport->state == SRP_RPORT_RUNNING) {\n\t\t \n\t\t__rport_fail_io_fast(rport);\n\t\t__srp_start_tl_fail_timers(rport);\n\t} else if (rport->state != SRP_RPORT_BLOCKED) {\n\t\tscsi_target_unblock(&shost->shost_gendev,\n\t\t\t\t    SDEV_TRANSPORT_OFFLINE);\n\t}\n\tmutex_unlock(&rport->mutex);\n\nout:\n\treturn res;\n}\nEXPORT_SYMBOL(srp_reconnect_rport);\n\n \nenum scsi_timeout_action srp_timed_out(struct scsi_cmnd *scmd)\n{\n\tstruct scsi_device *sdev = scmd->device;\n\tstruct Scsi_Host *shost = sdev->host;\n\tstruct srp_internal *i = to_srp_internal(shost->transportt);\n\tstruct srp_rport *rport = shost_to_rport(shost);\n\n\tpr_debug(\"timeout for sdev %s\\n\", dev_name(&sdev->sdev_gendev));\n\treturn rport && rport->fast_io_fail_tmo < 0 &&\n\t\trport->dev_loss_tmo < 0 &&\n\t\ti->f->reset_timer_if_blocked && scsi_device_blocked(sdev) ?\n\t\tSCSI_EH_RESET_TIMER : SCSI_EH_NOT_HANDLED;\n}\nEXPORT_SYMBOL(srp_timed_out);\n\nstatic void srp_rport_release(struct device *dev)\n{\n\tstruct srp_rport *rport = dev_to_rport(dev);\n\n\tput_device(dev->parent);\n\tkfree(rport);\n}\n\nstatic int scsi_is_srp_rport(const struct device *dev)\n{\n\treturn dev->release == srp_rport_release;\n}\n\nstatic int srp_rport_match(struct attribute_container *cont,\n\t\t\t   struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct srp_internal *i;\n\n\tif (!scsi_is_srp_rport(dev))\n\t\treturn 0;\n\n\tshost = dev_to_shost(dev->parent);\n\tif (!shost->transportt)\n\t\treturn 0;\n\tif (shost->transportt->host_attrs.ac.class != &srp_host_class.class)\n\t\treturn 0;\n\n\ti = to_srp_internal(shost->transportt);\n\treturn &i->rport_attr_cont.ac == cont;\n}\n\nstatic int srp_host_match(struct attribute_container *cont, struct device *dev)\n{\n\tstruct Scsi_Host *shost;\n\tstruct srp_internal *i;\n\n\tif (!scsi_is_host_device(dev))\n\t\treturn 0;\n\n\tshost = dev_to_shost(dev);\n\tif (!shost->transportt)\n\t\treturn 0;\n\tif (shost->transportt->host_attrs.ac.class != &srp_host_class.class)\n\t\treturn 0;\n\n\ti = to_srp_internal(shost->transportt);\n\treturn &i->t.host_attrs.ac == cont;\n}\n\n \nvoid srp_rport_get(struct srp_rport *rport)\n{\n\tget_device(&rport->dev);\n}\nEXPORT_SYMBOL(srp_rport_get);\n\n \nvoid srp_rport_put(struct srp_rport *rport)\n{\n\tput_device(&rport->dev);\n}\nEXPORT_SYMBOL(srp_rport_put);\n\n \nstruct srp_rport *srp_rport_add(struct Scsi_Host *shost,\n\t\t\t\tstruct srp_rport_identifiers *ids)\n{\n\tstruct srp_rport *rport;\n\tstruct device *parent = &shost->shost_gendev;\n\tstruct srp_internal *i = to_srp_internal(shost->transportt);\n\tint id, ret;\n\n\trport = kzalloc(sizeof(*rport), GFP_KERNEL);\n\tif (!rport)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&rport->mutex);\n\n\tdevice_initialize(&rport->dev);\n\n\trport->dev.parent = get_device(parent);\n\trport->dev.release = srp_rport_release;\n\n\tmemcpy(rport->port_id, ids->port_id, sizeof(rport->port_id));\n\trport->roles = ids->roles;\n\n\tif (i->f->reconnect)\n\t\trport->reconnect_delay = i->f->reconnect_delay ?\n\t\t\t*i->f->reconnect_delay : 10;\n\tINIT_DELAYED_WORK(&rport->reconnect_work, srp_reconnect_work);\n\trport->fast_io_fail_tmo = i->f->fast_io_fail_tmo ?\n\t\t*i->f->fast_io_fail_tmo : 15;\n\trport->dev_loss_tmo = i->f->dev_loss_tmo ? *i->f->dev_loss_tmo : 60;\n\tINIT_DELAYED_WORK(&rport->fast_io_fail_work,\n\t\t\t  rport_fast_io_fail_timedout);\n\tINIT_DELAYED_WORK(&rport->dev_loss_work, rport_dev_loss_timedout);\n\n\tid = atomic_inc_return(&to_srp_host_attrs(shost)->next_port_id);\n\tdev_set_name(&rport->dev, \"port-%d:%d\", shost->host_no, id);\n\n\ttransport_setup_device(&rport->dev);\n\n\tret = device_add(&rport->dev);\n\tif (ret) {\n\t\ttransport_destroy_device(&rport->dev);\n\t\tput_device(&rport->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\ttransport_add_device(&rport->dev);\n\ttransport_configure_device(&rport->dev);\n\n\treturn rport;\n}\nEXPORT_SYMBOL_GPL(srp_rport_add);\n\n \nvoid srp_rport_del(struct srp_rport *rport)\n{\n\tstruct device *dev = &rport->dev;\n\n\ttransport_remove_device(dev);\n\tdevice_del(dev);\n\ttransport_destroy_device(dev);\n\n\tput_device(dev);\n}\nEXPORT_SYMBOL_GPL(srp_rport_del);\n\nstatic int do_srp_rport_del(struct device *dev, void *data)\n{\n\tif (scsi_is_srp_rport(dev))\n\t\tsrp_rport_del(dev_to_rport(dev));\n\treturn 0;\n}\n\n \nvoid srp_remove_host(struct Scsi_Host *shost)\n{\n\tdevice_for_each_child(&shost->shost_gendev, NULL, do_srp_rport_del);\n}\nEXPORT_SYMBOL_GPL(srp_remove_host);\n\n \nvoid srp_stop_rport_timers(struct srp_rport *rport)\n{\n\tmutex_lock(&rport->mutex);\n\tif (rport->state == SRP_RPORT_BLOCKED)\n\t\t__rport_fail_io_fast(rport);\n\tsrp_rport_set_state(rport, SRP_RPORT_LOST);\n\tmutex_unlock(&rport->mutex);\n\n\tcancel_delayed_work_sync(&rport->reconnect_work);\n\tcancel_delayed_work_sync(&rport->fast_io_fail_work);\n\tcancel_delayed_work_sync(&rport->dev_loss_work);\n}\nEXPORT_SYMBOL_GPL(srp_stop_rport_timers);\n\n \nstruct scsi_transport_template *\nsrp_attach_transport(struct srp_function_template *ft)\n{\n\tint count;\n\tstruct srp_internal *i;\n\n\ti = kzalloc(sizeof(*i), GFP_KERNEL);\n\tif (!i)\n\t\treturn NULL;\n\n\ti->t.host_size = sizeof(struct srp_host_attrs);\n\ti->t.host_attrs.ac.attrs = &i->host_attrs[0];\n\ti->t.host_attrs.ac.class = &srp_host_class.class;\n\ti->t.host_attrs.ac.match = srp_host_match;\n\ti->host_attrs[0] = NULL;\n\ttransport_container_register(&i->t.host_attrs);\n\n\ti->rport_attr_cont.ac.attrs = &i->rport_attrs[0];\n\ti->rport_attr_cont.ac.class = &srp_rport_class.class;\n\ti->rport_attr_cont.ac.match = srp_rport_match;\n\n\tcount = 0;\n\ti->rport_attrs[count++] = &dev_attr_port_id;\n\ti->rport_attrs[count++] = &dev_attr_roles;\n\tif (ft->has_rport_state) {\n\t\ti->rport_attrs[count++] = &dev_attr_state;\n\t\ti->rport_attrs[count++] = &dev_attr_fast_io_fail_tmo;\n\t\ti->rport_attrs[count++] = &dev_attr_dev_loss_tmo;\n\t}\n\tif (ft->reconnect) {\n\t\ti->rport_attrs[count++] = &dev_attr_reconnect_delay;\n\t\ti->rport_attrs[count++] = &dev_attr_failed_reconnects;\n\t}\n\tif (ft->rport_delete)\n\t\ti->rport_attrs[count++] = &dev_attr_delete;\n\ti->rport_attrs[count++] = NULL;\n\tBUG_ON(count > ARRAY_SIZE(i->rport_attrs));\n\n\ttransport_container_register(&i->rport_attr_cont);\n\n\ti->f = ft;\n\n\treturn &i->t;\n}\nEXPORT_SYMBOL_GPL(srp_attach_transport);\n\n \nvoid srp_release_transport(struct scsi_transport_template *t)\n{\n\tstruct srp_internal *i = to_srp_internal(t);\n\n\ttransport_container_unregister(&i->t.host_attrs);\n\ttransport_container_unregister(&i->rport_attr_cont);\n\n\tkfree(i);\n}\nEXPORT_SYMBOL_GPL(srp_release_transport);\n\nstatic __init int srp_transport_init(void)\n{\n\tint ret;\n\n\tret = transport_class_register(&srp_host_class);\n\tif (ret)\n\t\treturn ret;\n\tret = transport_class_register(&srp_rport_class);\n\tif (ret)\n\t\tgoto unregister_host_class;\n\n\treturn 0;\nunregister_host_class:\n\ttransport_class_unregister(&srp_host_class);\n\treturn ret;\n}\n\nstatic void __exit srp_transport_exit(void)\n{\n\ttransport_class_unregister(&srp_host_class);\n\ttransport_class_unregister(&srp_rport_class);\n}\n\nMODULE_AUTHOR(\"FUJITA Tomonori\");\nMODULE_DESCRIPTION(\"SRP Transport Attributes\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(srp_transport_init);\nmodule_exit(srp_transport_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}