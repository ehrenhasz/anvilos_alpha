{
  "module_name": "sr_vendor.c",
  "hash_id": "ba06c7b24aba51e291c6e4d7fcc43133769e5696b30d9af9b82bf9bc4b7c661c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/sr_vendor.c",
  "human_readable_source": "\n \n\n#include <linux/cdrom.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/bcd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_ioctl.h>\n\n#include \"sr.h\"\n\n#if 0\n#define DEBUG\n#endif\n\n \n\n#define VENDOR_SCSI3           1\t \n\n#define VENDOR_NEC             2\n#define VENDOR_TOSHIBA         3\n#define VENDOR_WRITER          4\t \n#define VENDOR_CYGNAL_85ED     5\t \n\n#define VENDOR_TIMEOUT\t30*HZ\n\nvoid sr_vendor_init(Scsi_CD *cd)\n{\n\tconst char *vendor = cd->device->vendor;\n\tconst char *model = cd->device->model;\n\t\n\t \n\tcd->vendor = VENDOR_SCSI3;\n\tif (cd->readcd_known)\n\t\t \n\t\treturn;\n\n\tif (cd->device->type == TYPE_WORM) {\n\t\tcd->vendor = VENDOR_WRITER;\n\n\t} else if (!strncmp(vendor, \"NEC\", 3)) {\n\t\tcd->vendor = VENDOR_NEC;\n\t\tif (!strncmp(model, \"CD-ROM DRIVE:25\", 15) ||\n\t\t    !strncmp(model, \"CD-ROM DRIVE:36\", 15) ||\n\t\t    !strncmp(model, \"CD-ROM DRIVE:83\", 15) ||\n\t\t    !strncmp(model, \"CD-ROM DRIVE:84 \", 16)\n#if 0\n\t\t \n\t\t    || !strncmp(model, \"CD-ROM DRIVE:500\", 16)\n#endif\n\t\t    )\n\t\t\t \n\t\t\tcd->cdi.mask |= CDC_MULTI_SESSION;\n\n\t} else if (!strncmp(vendor, \"TOSHIBA\", 7)) {\n\t\tcd->vendor = VENDOR_TOSHIBA;\n\n\t} else if (!strncmp(vendor, \"Beurer\", 6) &&\n\t\t   !strncmp(model, \"Gluco Memory\", 12)) {\n\t\t \n\t\tcd->vendor = VENDOR_CYGNAL_85ED;\n\t\tcd->cdi.mask |= (\n\t\t\tCDC_MULTI_SESSION |\n\t\t\tCDC_CLOSE_TRAY | CDC_OPEN_TRAY |\n\t\t\tCDC_LOCK |\n\t\t\tCDC_GENERIC_PACKET |\n\t\t\tCDC_PLAY_AUDIO\n\t\t\t);\n\t}\n}\n\n\n \n\nint sr_set_blocklength(Scsi_CD *cd, int blocklength)\n{\n\tunsigned char *buffer;\t \n\tstruct packet_command cgc;\n\tstruct ccs_modesel_head *modesel;\n\tint rc, density = 0;\n\n\tif (cd->vendor == VENDOR_TOSHIBA)\n\t\tdensity = (blocklength > 2048) ? 0x81 : 0x83;\n\n\tbuffer = kmalloc(512, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n#ifdef DEBUG\n\tsr_printk(KERN_INFO, cd, \"MODE SELECT 0x%x/%d\\n\", density, blocklength);\n#endif\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = MODE_SELECT;\n\tcgc.cmd[1] = (1 << 4);\n\tcgc.cmd[4] = 12;\n\tmodesel = (struct ccs_modesel_head *) buffer;\n\tmemset(modesel, 0, sizeof(*modesel));\n\tmodesel->block_desc_length = 0x08;\n\tmodesel->density = density;\n\tmodesel->block_length_med = (blocklength >> 8) & 0xff;\n\tmodesel->block_length_lo = blocklength & 0xff;\n\tcgc.buffer = buffer;\n\tcgc.buflen = sizeof(*modesel);\n\tcgc.data_direction = DMA_TO_DEVICE;\n\tcgc.timeout = VENDOR_TIMEOUT;\n\tif (0 == (rc = sr_do_ioctl(cd, &cgc))) {\n\t\tcd->device->sector_size = blocklength;\n\t}\n#ifdef DEBUG\n\telse\n\t\tsr_printk(KERN_INFO, cd,\n\t\t\t  \"switching blocklength to %d bytes failed\\n\",\n\t\t\t  blocklength);\n#endif\n\tkfree(buffer);\n\treturn rc;\n}\n\n \n\nint sr_cd_check(struct cdrom_device_info *cdi)\n{\n\tScsi_CD *cd = cdi->handle;\n\tunsigned long sector;\n\tunsigned char *buffer;\t \n\tstruct packet_command cgc;\n\tint rc, no_multi;\n\n\tif (cd->cdi.mask & CDC_MULTI_SESSION)\n\t\treturn 0;\n\n\tbuffer = kmalloc(512, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tsector = 0;\t\t \n\tno_multi = 0;\t\t \n\trc = 0;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\n\tswitch (cd->vendor) {\n\n\tcase VENDOR_SCSI3:\n\t\tcgc.cmd[0] = READ_TOC;\n\t\tcgc.cmd[8] = 12;\n\t\tcgc.cmd[9] = 0x40;\n\t\tcgc.buffer = buffer;\n\t\tcgc.buflen = 12;\n\t\tcgc.quiet = 1;\n\t\tcgc.data_direction = DMA_FROM_DEVICE;\n\t\tcgc.timeout = VENDOR_TIMEOUT;\n\t\trc = sr_do_ioctl(cd, &cgc);\n\t\tif (rc != 0)\n\t\t\tbreak;\n\t\tif ((buffer[0] << 8) + buffer[1] < 0x0a) {\n\t\t\tsr_printk(KERN_INFO, cd, \"Hmm, seems the drive \"\n\t\t\t   \"doesn't support multisession CD's\\n\");\n\t\t\tno_multi = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsector = buffer[11] + (buffer[10] << 8) +\n\t\t    (buffer[9] << 16) + (buffer[8] << 24);\n\t\tif (buffer[6] <= 1) {\n\t\t\t \n\t\t\tsector = 0;\n\t\t}\n\t\tbreak;\n\n\tcase VENDOR_NEC:{\n\t\t\tunsigned long min, sec, frame;\n\t\t\tcgc.cmd[0] = 0xde;\n\t\t\tcgc.cmd[1] = 0x03;\n\t\t\tcgc.cmd[2] = 0xb0;\n\t\t\tcgc.buffer = buffer;\n\t\t\tcgc.buflen = 0x16;\n\t\t\tcgc.quiet = 1;\n\t\t\tcgc.data_direction = DMA_FROM_DEVICE;\n\t\t\tcgc.timeout = VENDOR_TIMEOUT;\n\t\t\trc = sr_do_ioctl(cd, &cgc);\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tif (buffer[14] != 0 && buffer[14] != 0xb0) {\n\t\t\t\tsr_printk(KERN_INFO, cd, \"Hmm, seems the cdrom \"\n\t\t\t\t\t  \"doesn't support multisession CD's\\n\");\n\n\t\t\t\tno_multi = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin = bcd2bin(buffer[15]);\n\t\t\tsec = bcd2bin(buffer[16]);\n\t\t\tframe = bcd2bin(buffer[17]);\n\t\t\tsector = min * CD_SECS * CD_FRAMES + sec * CD_FRAMES + frame;\n\t\t\tbreak;\n\t\t}\n\n\tcase VENDOR_TOSHIBA:{\n\t\t\tunsigned long min, sec, frame;\n\n\t\t\t \n\t\t\tcgc.cmd[0] = 0xc7;\n\t\t\tcgc.cmd[1] = 0x03;\n\t\t\tcgc.buffer = buffer;\n\t\t\tcgc.buflen = 4;\n\t\t\tcgc.quiet = 1;\n\t\t\tcgc.data_direction = DMA_FROM_DEVICE;\n\t\t\tcgc.timeout = VENDOR_TIMEOUT;\n\t\t\trc = sr_do_ioctl(cd, &cgc);\n\t\t\tif (rc == -EINVAL) {\n\t\t\t\tsr_printk(KERN_INFO, cd, \"Hmm, seems the drive \"\n\t\t\t\t\t  \"doesn't support multisession CD's\\n\");\n\t\t\t\tno_multi = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rc != 0)\n\t\t\t\tbreak;\n\t\t\tmin = bcd2bin(buffer[1]);\n\t\t\tsec = bcd2bin(buffer[2]);\n\t\t\tframe = bcd2bin(buffer[3]);\n\t\t\tsector = min * CD_SECS * CD_FRAMES + sec * CD_FRAMES + frame;\n\t\t\tif (sector)\n\t\t\t\tsector -= CD_MSF_OFFSET;\n\t\t\tsr_set_blocklength(cd, 2048);\n\t\t\tbreak;\n\t\t}\n\n\tcase VENDOR_WRITER:\n\t\tcgc.cmd[0] = READ_TOC;\n\t\tcgc.cmd[8] = 0x04;\n\t\tcgc.cmd[9] = 0x40;\n\t\tcgc.buffer = buffer;\n\t\tcgc.buflen = 0x04;\n\t\tcgc.quiet = 1;\n\t\tcgc.data_direction = DMA_FROM_DEVICE;\n\t\tcgc.timeout = VENDOR_TIMEOUT;\n\t\trc = sr_do_ioctl(cd, &cgc);\n\t\tif (rc != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((rc = buffer[2]) == 0) {\n\t\t\tsr_printk(KERN_WARNING, cd,\n\t\t\t\t  \"No finished session\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcgc.cmd[0] = READ_TOC;\t \n\t\tcgc.cmd[6] = rc & 0x7f;\t \n\t\tcgc.cmd[8] = 0x0c;\n\t\tcgc.cmd[9] = 0x40;\n\t\tcgc.buffer = buffer;\n\t\tcgc.buflen = 12;\n\t\tcgc.quiet = 1;\n\t\tcgc.data_direction = DMA_FROM_DEVICE;\n\t\tcgc.timeout = VENDOR_TIMEOUT;\n\t\trc = sr_do_ioctl(cd, &cgc);\n\t\tif (rc != 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsector = buffer[11] + (buffer[10] << 8) +\n\t\t    (buffer[9] << 16) + (buffer[8] << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tsr_printk(KERN_WARNING, cd,\n\t\t\t  \"unknown vendor code (%i), not initialized ?\\n\",\n\t\t\t  cd->vendor);\n\t\tsector = 0;\n\t\tno_multi = 1;\n\t\tbreak;\n\t}\n\tcd->ms_offset = sector;\n\tcd->xa_flag = 0;\n\tif (CDS_AUDIO != sr_disk_status(cdi) && 1 == sr_is_xa(cd))\n\t\tcd->xa_flag = 1;\n\n\tif (2048 != cd->device->sector_size) {\n\t\tsr_set_blocklength(cd, 2048);\n\t}\n\tif (no_multi)\n\t\tcdi->mask |= CDC_MULTI_SESSION;\n\n#ifdef DEBUG\n\tif (sector)\n\t\tsr_printk(KERN_DEBUG, cd, \"multisession offset=%lu\\n\",\n\t\t\t  sector);\n#endif\n\tkfree(buffer);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}