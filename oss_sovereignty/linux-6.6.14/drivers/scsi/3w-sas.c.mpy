{
  "module_name": "3w-sas.c",
  "hash_id": "350def9959720b3cd2a4d6009312e4ef6a12c4b546aadb4170e7bf59ccfa4362",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/3w-sas.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_cmnd.h>\n#include \"3w-sas.h\"\n\n \n#define TW_DRIVER_VERSION \"3.26.02.000\"\nstatic DEFINE_MUTEX(twl_chrdev_mutex);\nstatic TW_Device_Extension *twl_device_extension_list[TW_MAX_SLOT];\nstatic unsigned int twl_device_extension_count;\nstatic int twl_major = -1;\nextern struct timezone sys_tz;\n\n \nMODULE_AUTHOR (\"LSI\");\nMODULE_DESCRIPTION (\"LSI 3ware SAS/SATA-RAID Linux Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(TW_DRIVER_VERSION);\n\nstatic int use_msi;\nmodule_param(use_msi, int, S_IRUGO);\nMODULE_PARM_DESC(use_msi, \"Use Message Signaled Interrupts. Default: 0\");\n\n \nstatic int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_reset);\n\n \n\n \nstatic ssize_t twl_sysfs_aen_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t\t  char *outbuf, loff_t offset, size_t count)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)shost->hostdata;\n\tunsigned long flags = 0;\n\tssize_t ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\tret = memory_read_from_buffer(outbuf, count, &offset, tw_dev->event_queue[0], sizeof(TW_Event) * TW_Q_LENGTH);\n\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\n\treturn ret;\n}  \n\n \nstatic struct bin_attribute twl_sysfs_aen_read_attr = {\n\t.attr = {\n\t\t.name = \"3ware_aen_read\",\n\t\t.mode = S_IRUSR,\n\t},\n\t.size = 0,\n\t.read = twl_sysfs_aen_read\n};\n\n \nstatic ssize_t twl_sysfs_compat_info(struct file *filp, struct kobject *kobj,\n\t\t\t\t     struct bin_attribute *bin_attr,\n\t\t\t\t     char *outbuf, loff_t offset, size_t count)\n{\n\tstruct device *dev = container_of(kobj, struct device, kobj);\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)shost->hostdata;\n\tunsigned long flags = 0;\n\tssize_t ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\tret = memory_read_from_buffer(outbuf, count, &offset, &tw_dev->tw_compat_info, sizeof(TW_Compatibility_Info));\n\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\n\treturn ret;\n}  \n\n \nstatic struct bin_attribute twl_sysfs_compat_info_attr = {\n\t.attr = {\n\t\t.name = \"3ware_compat_info\",\n\t\t.mode = S_IRUSR,\n\t},\n\t.size = 0,\n\t.read = twl_sysfs_compat_info\n};\n\n \nstatic ssize_t twl_show_stats(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\n\tunsigned long flags = 0;\n\tssize_t len;\n\n\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\tlen = snprintf(buf, PAGE_SIZE, \"3w-sas Driver version: %s\\n\"\n\t\t       \"Current commands posted:   %4d\\n\"\n\t\t       \"Max commands posted:       %4d\\n\"\n\t\t       \"Last sgl length:           %4d\\n\"\n\t\t       \"Max sgl length:            %4d\\n\"\n\t\t       \"Last sector count:         %4d\\n\"\n\t\t       \"Max sector count:          %4d\\n\"\n\t\t       \"SCSI Host Resets:          %4d\\n\"\n\t\t       \"AEN's:                     %4d\\n\",\n\t\t       TW_DRIVER_VERSION,\n\t\t       tw_dev->posted_request_count,\n\t\t       tw_dev->max_posted_request_count,\n\t\t       tw_dev->sgl_entries,\n\t\t       tw_dev->max_sgl_entries,\n\t\t       tw_dev->sector_count,\n\t\t       tw_dev->max_sector_count,\n\t\t       tw_dev->num_resets,\n\t\t       tw_dev->aen_count);\n\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\treturn len;\n}  \n\n \nstatic struct device_attribute twl_host_stats_attr = {\n\t.attr = {\n\t\t.name =\t\t\"3ware_stats\",\n\t\t.mode =\t\tS_IRUGO,\n\t},\n\t.show = twl_show_stats\n};\n\n \nstatic struct attribute *twl_host_attrs[] = {\n\t&twl_host_stats_attr.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(twl_host);\n\n \nstatic char *twl_aen_severity_lookup(unsigned char severity_code)\n{\n\tchar *retval = NULL;\n\n\tif ((severity_code < (unsigned char) TW_AEN_SEVERITY_ERROR) ||\n\t    (severity_code > (unsigned char) TW_AEN_SEVERITY_DEBUG))\n\t\tgoto out;\n\n\tretval = twl_aen_severity_table[severity_code];\nout:\n\treturn retval;\n}  \n\n \nstatic void twl_aen_queue_event(TW_Device_Extension *tw_dev, TW_Command_Apache_Header *header)\n{\n\tu32 local_time;\n\tTW_Event *event;\n\tunsigned short aen;\n\tchar host[16];\n\tchar *error_str;\n\n\ttw_dev->aen_count++;\n\n\t \n\tevent = tw_dev->event_queue[tw_dev->error_index];\n\n\thost[0] = '\\0';\n\tif (tw_dev->host)\n\t\tsprintf(host, \" scsi%d:\", tw_dev->host->host_no);\n\n\taen = le16_to_cpu(header->status_block.error);\n\tmemset(event, 0, sizeof(TW_Event));\n\n\tevent->severity = TW_SEV_OUT(header->status_block.severity__reserved);\n\t \n\tlocal_time = (u32)(ktime_get_real_seconds() - (sys_tz.tz_minuteswest * 60));\n\tevent->time_stamp_sec = local_time;\n\tevent->aen_code = aen;\n\tevent->retrieved = TW_AEN_NOT_RETRIEVED;\n\tevent->sequence_id = tw_dev->error_sequence_id;\n\ttw_dev->error_sequence_id++;\n\n\t \n\terror_str = &(header->err_specific_desc[strlen(header->err_specific_desc)+1]);\n\n\theader->err_specific_desc[sizeof(header->err_specific_desc) - 1] = '\\0';\n\tevent->parameter_len = strlen(header->err_specific_desc);\n\tmemcpy(event->parameter_data, header->err_specific_desc, event->parameter_len + 1 + strlen(error_str));\n\tif (event->severity != TW_AEN_SEVERITY_DEBUG)\n\t\tprintk(KERN_WARNING \"3w-sas:%s AEN: %s (0x%02X:0x%04X): %s:%s.\\n\",\n\t\t       host,\n\t\t       twl_aen_severity_lookup(TW_SEV_OUT(header->status_block.severity__reserved)),\n\t\t       TW_MESSAGE_SOURCE_CONTROLLER_EVENT, aen, error_str,\n\t\t       header->err_specific_desc);\n\telse\n\t\ttw_dev->aen_count--;\n\n\ttw_dev->error_index = (tw_dev->error_index + 1 ) % TW_Q_LENGTH;\n}  \n\n \nstatic int twl_post_command_packet(TW_Device_Extension *tw_dev, int request_id)\n{\n\tdma_addr_t command_que_value;\n\n\tcommand_que_value = tw_dev->command_packet_phys[request_id];\n\tcommand_que_value += TW_COMMAND_OFFSET;\n\n\t \n\twritel((u32)((u64)command_que_value >> 32), TWL_HIBQPH_REG_ADDR(tw_dev));\n\t \n\twritel((u32)(command_que_value | TWL_PULL_MODE), TWL_HIBQPL_REG_ADDR(tw_dev));\n\n\ttw_dev->state[request_id] = TW_S_POSTED;\n\ttw_dev->posted_request_count++;\n\tif (tw_dev->posted_request_count > tw_dev->max_posted_request_count)\n\t\ttw_dev->max_posted_request_count = tw_dev->posted_request_count;\n\n\treturn 0;\n}  \n\n \nstatic int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,\n\t\t\t\t   unsigned char *cdb, int use_sg,\n\t\t\t\t   TW_SG_Entry_ISO *sglistarg)\n{\n\tTW_Command_Full *full_command_packet;\n\tTW_Command_Apache *command_packet;\n\tint i, sg_count;\n\tstruct scsi_cmnd *srb = NULL;\n\tstruct scatterlist *sg;\n\tint retval = 1;\n\n\tif (tw_dev->srb[request_id])\n\t\tsrb = tw_dev->srb[request_id];\n\n\t \n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tfull_command_packet->header.header_desc.size_header = 128;\n\tfull_command_packet->header.status_block.error = 0;\n\tfull_command_packet->header.status_block.severity__reserved = 0;\n\n\tcommand_packet = &full_command_packet->command.newcommand;\n\tcommand_packet->status = 0;\n\tcommand_packet->opcode__reserved = TW_OPRES_IN(0, TW_OP_EXECUTE_SCSI);\n\n\t \n\tif (!cdb)\n\t\tmemcpy(command_packet->cdb, srb->cmnd, TW_MAX_CDB_LEN);\n\telse\n\t\tmemcpy(command_packet->cdb, cdb, TW_MAX_CDB_LEN);\n\n\tif (srb) {\n\t\tcommand_packet->unit = srb->device->id;\n\t\tcommand_packet->request_id__lunl =\n\t\t\tcpu_to_le16(TW_REQ_LUN_IN(srb->device->lun, request_id));\n\t} else {\n\t\tcommand_packet->request_id__lunl =\n\t\t\tcpu_to_le16(TW_REQ_LUN_IN(0, request_id));\n\t\tcommand_packet->unit = 0;\n\t}\n\n\tcommand_packet->sgl_offset = 16;\n\n\tif (!sglistarg) {\n\t\t \n\t\tif (scsi_sg_count(srb)) {\n\t\t\tsg_count = scsi_dma_map(srb);\n\t\t\tif (sg_count <= 0)\n\t\t\t\tgoto out;\n\n\t\t\tscsi_for_each_sg(srb, sg, sg_count, i) {\n\t\t\t\tcommand_packet->sg_list[i].address = TW_CPU_TO_SGL(sg_dma_address(sg));\n\t\t\t\tcommand_packet->sg_list[i].length = TW_CPU_TO_SGL(sg_dma_len(sg));\n\t\t\t}\n\t\t\tcommand_packet->sgl_entries__lunh = cpu_to_le16(TW_REQ_LUN_IN((srb->device->lun >> 4), scsi_sg_count(tw_dev->srb[request_id])));\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < use_sg; i++) {\n\t\t\tcommand_packet->sg_list[i].address = TW_CPU_TO_SGL(sglistarg[i].address);\n\t\t\tcommand_packet->sg_list[i].length = TW_CPU_TO_SGL(sglistarg[i].length);\n\t\t}\n\t\tcommand_packet->sgl_entries__lunh = cpu_to_le16(TW_REQ_LUN_IN(0, use_sg));\n\t}\n\n\t \n\tif (srb) {\n\t\ttw_dev->sector_count = scsi_bufflen(srb) / 512;\n\t\tif (tw_dev->sector_count > tw_dev->max_sector_count)\n\t\t\ttw_dev->max_sector_count = tw_dev->sector_count;\n\t\ttw_dev->sgl_entries = scsi_sg_count(srb);\n\t\tif (tw_dev->sgl_entries > tw_dev->max_sgl_entries)\n\t\t\ttw_dev->max_sgl_entries = tw_dev->sgl_entries;\n\t}\n\n\t \n\tretval = twl_post_command_packet(tw_dev, request_id);\n\nout:\n\treturn retval;\n}  \n\n \nstatic int twl_aen_read_queue(TW_Device_Extension *tw_dev, int request_id)\n{\n\tunsigned char cdb[TW_MAX_CDB_LEN];\n\tTW_SG_Entry_ISO sglist[1];\n\tTW_Command_Full *full_command_packet;\n\tint retval = 1;\n\n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\n\t \n\tmemset(&cdb, 0, TW_MAX_CDB_LEN);\n\tcdb[0] = REQUEST_SENSE;  \n\tcdb[4] = TW_ALLOCATION_LENGTH;  \n\n\t \n\tmemset(&sglist, 0, sizeof(TW_SG_Entry_ISO));\n\tsglist[0].length = TW_SECTOR_SIZE;\n\tsglist[0].address = tw_dev->generic_buffer_phys[request_id];\n\n\t \n\ttw_dev->srb[request_id] = NULL;\n\n\t \n\tif (twl_scsiop_execute_scsi(tw_dev, request_id, cdb, 1, sglist)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x2, \"Post failed while reading AEN queue\");\n\t\tgoto out;\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic void twl_aen_sync_time(TW_Device_Extension *tw_dev, int request_id)\n{\n\tu32 schedulertime;\n\tTW_Command_Full *full_command_packet;\n\tTW_Command *command_packet;\n\tTW_Param_Apache *param;\n\ttime64_t local_time;\n\n\t \n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\tcommand_packet = &full_command_packet->command.oldcommand;\n\tcommand_packet->opcode__sgloffset = TW_OPSGL_IN(2, TW_OP_SET_PARAM);\n\tcommand_packet->request_id = request_id;\n\tcommand_packet->byte8_offset.param.sgl[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\n\tcommand_packet->byte8_offset.param.sgl[0].length = TW_CPU_TO_SGL(TW_SECTOR_SIZE);\n\tcommand_packet->size = TW_COMMAND_SIZE;\n\tcommand_packet->byte6_offset.parameter_count = cpu_to_le16(1);\n\n\t \n\tparam = (TW_Param_Apache *)tw_dev->generic_buffer_virt[request_id];\n\tmemset(param, 0, TW_SECTOR_SIZE);\n\tparam->table_id = cpu_to_le16(TW_TIMEKEEP_TABLE | 0x8000);  \n\tparam->parameter_id = cpu_to_le16(0x3);  \n\tparam->parameter_size_bytes = cpu_to_le16(4);\n\n\t \n\tlocal_time = (ktime_get_real_seconds() - (sys_tz.tz_minuteswest * 60));\n\tdiv_u64_rem(local_time - (3 * 86400), 604800, &schedulertime);\n\tschedulertime = cpu_to_le32(schedulertime);\n\n\tmemcpy(param->data, &schedulertime, sizeof(u32));\n\n\t \n\ttw_dev->srb[request_id] = NULL;\n\n\t \n\ttwl_post_command_packet(tw_dev, request_id);\n}  \n\n \nstatic void twl_get_request_id(TW_Device_Extension *tw_dev, int *request_id)\n{\n\t*request_id = tw_dev->free_queue[tw_dev->free_head];\n\ttw_dev->free_head = (tw_dev->free_head + 1) % TW_Q_LENGTH;\n\ttw_dev->state[*request_id] = TW_S_STARTED;\n}  \n\n \nstatic void twl_free_request_id(TW_Device_Extension *tw_dev, int request_id)\n{\n\ttw_dev->free_queue[tw_dev->free_tail] = request_id;\n\ttw_dev->state[request_id] = TW_S_FINISHED;\n\ttw_dev->free_tail = (tw_dev->free_tail + 1) % TW_Q_LENGTH;\n}  \n\n \nstatic int twl_aen_complete(TW_Device_Extension *tw_dev, int request_id)\n{\n\tTW_Command_Full *full_command_packet;\n\tTW_Command *command_packet;\n\tTW_Command_Apache_Header *header;\n\tunsigned short aen;\n\tint retval = 1;\n\n\theader = (TW_Command_Apache_Header *)tw_dev->generic_buffer_virt[request_id];\n\ttw_dev->posted_request_count--;\n\taen = le16_to_cpu(header->status_block.error);\n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tcommand_packet = &full_command_packet->command.oldcommand;\n\n\t \n\tif (TW_OP_OUT(command_packet->opcode__sgloffset) == TW_OP_SET_PARAM) {\n\t\t \n\t\tif (twl_aen_read_queue(tw_dev, request_id))\n\t\t\tgoto out2;\n\t\telse {\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (aen) {\n\tcase TW_AEN_QUEUE_EMPTY:\n\t\t \n\t\tbreak;\n\tcase TW_AEN_SYNC_TIME_WITH_HOST:\n\t\ttwl_aen_sync_time(tw_dev, request_id);\n\t\tretval = 0;\n\t\tgoto out;\n\tdefault:\n\t\ttwl_aen_queue_event(tw_dev, header);\n\n\t\t \n\t\tif (twl_aen_read_queue(tw_dev, request_id))\n\t\t\tgoto out2;\n\t\telse {\n\t\t\tretval = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tretval = 0;\nout2:\n\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\ttwl_free_request_id(tw_dev, request_id);\n\tclear_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags);\nout:\n\treturn retval;\n}  \n\n \nstatic int twl_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)\n{\n\tunsigned long before;\n\tdma_addr_t mfa;\n\tu32 regh, regl;\n\tu32 response;\n\tint retval = 1;\n\tint found = 0;\n\n\tbefore = jiffies;\n\n\twhile (!found) {\n\t\tif (sizeof(dma_addr_t) > 4) {\n\t\t\tregh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));\n\t\t\tregl = readl(TWL_HOBQPL_REG_ADDR(tw_dev));\n\t\t\tmfa = ((u64)regh << 32) | regl;\n\t\t} else\n\t\t\tmfa = readl(TWL_HOBQPL_REG_ADDR(tw_dev));\n\n\t\tresponse = (u32)mfa;\n\n\t\tif (TW_RESID_OUT(response) == request_id)\n\t\t\tfound = 1;\n\n\t\tif (time_after(jiffies, before + HZ * seconds))\n\t\t\tgoto out;\n\n\t\tmsleep(50);\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twl_aen_drain_queue(TW_Device_Extension *tw_dev, int no_check_reset)\n{\n\tint request_id = 0;\n\tunsigned char cdb[TW_MAX_CDB_LEN];\n\tTW_SG_Entry_ISO sglist[1];\n\tint finished = 0, count = 0;\n\tTW_Command_Full *full_command_packet;\n\tTW_Command_Apache_Header *header;\n\tunsigned short aen;\n\tint first_reset = 0, queue = 0, retval = 1;\n\n\tif (no_check_reset)\n\t\tfirst_reset = 0;\n\telse\n\t\tfirst_reset = 1;\n\n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\n\t \n\tmemset(&cdb, 0, TW_MAX_CDB_LEN);\n\tcdb[0] = REQUEST_SENSE;  \n\tcdb[4] = TW_ALLOCATION_LENGTH;  \n\n\t \n\tmemset(&sglist, 0, sizeof(TW_SG_Entry_ISO));\n\tsglist[0].length = TW_SECTOR_SIZE;\n\tsglist[0].address = tw_dev->generic_buffer_phys[request_id];\n\n\t \n\ttw_dev->srb[request_id] = NULL;\n\n\tdo {\n\t\t \n\t\tif (twl_scsiop_execute_scsi(tw_dev, request_id, cdb, 1, sglist)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x3, \"Error posting request sense\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (twl_poll_response(tw_dev, request_id, 30)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x4, \"No valid response while draining AEN queue\");\n\t\t\ttw_dev->posted_request_count--;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttw_dev->posted_request_count--;\n\t\theader = (TW_Command_Apache_Header *)tw_dev->generic_buffer_virt[request_id];\n\t\taen = le16_to_cpu(header->status_block.error);\n\t\tqueue = 0;\n\t\tcount++;\n\n\t\tswitch (aen) {\n\t\tcase TW_AEN_QUEUE_EMPTY:\n\t\t\tif (first_reset != 1)\n\t\t\t\tgoto out;\n\t\t\telse\n\t\t\t\tfinished = 1;\n\t\t\tbreak;\n\t\tcase TW_AEN_SOFT_RESET:\n\t\t\tif (first_reset == 0)\n\t\t\t\tfirst_reset = 1;\n\t\t\telse\n\t\t\t\tqueue = 1;\n\t\t\tbreak;\n\t\tcase TW_AEN_SYNC_TIME_WITH_HOST:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tqueue = 1;\n\t\t}\n\n\t\t \n\t\tif (queue)\n\t\t\ttwl_aen_queue_event(tw_dev, header);\n\t} while ((finished == 0) && (count < TW_MAX_AEN_DRAIN));\n\n\tif (count == TW_MAX_AEN_DRAIN)\n\t\tgoto out;\n\n\tretval = 0;\nout:\n\ttw_dev->state[request_id] = TW_S_INITIAL;\n\treturn retval;\n}  \n\n \nstatic int twl_allocate_memory(TW_Device_Extension *tw_dev, int size, int which)\n{\n\tint i;\n\tdma_addr_t dma_handle;\n\tunsigned long *cpu_addr;\n\tint retval = 1;\n\n\tcpu_addr = dma_alloc_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\t\t      size * TW_Q_LENGTH, &dma_handle,\n\t\t\t\t      GFP_KERNEL);\n\tif (!cpu_addr) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x5, \"Memory allocation failed\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < TW_Q_LENGTH; i++) {\n\t\tswitch(which) {\n\t\tcase 0:\n\t\t\ttw_dev->command_packet_phys[i] = dma_handle+(i*size);\n\t\t\ttw_dev->command_packet_virt[i] = (TW_Command_Full *)((unsigned char *)cpu_addr + (i*size));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttw_dev->generic_buffer_phys[i] = dma_handle+(i*size);\n\t\t\ttw_dev->generic_buffer_virt[i] = (unsigned long *)((unsigned char *)cpu_addr + (i*size));\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttw_dev->sense_buffer_phys[i] = dma_handle+(i*size);\n\t\t\ttw_dev->sense_buffer_virt[i] = (TW_Command_Apache_Header *)((unsigned char *)cpu_addr + (i*size));\n\t\t\tbreak;\n\t\t}\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic void twl_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_command_packet, int request_id, dma_addr_t dma_handle, int length)\n{\n\tTW_Command *oldcommand;\n\tTW_Command_Apache *newcommand;\n\tTW_SG_Entry_ISO *sgl;\n\tunsigned int pae = 0;\n\n\tif ((sizeof(long) < 8) && (sizeof(dma_addr_t) > 4))\n\t\tpae = 1;\n\n\tif (TW_OP_OUT(full_command_packet->command.newcommand.opcode__reserved) == TW_OP_EXECUTE_SCSI) {\n\t\tnewcommand = &full_command_packet->command.newcommand;\n\t\tnewcommand->request_id__lunl =\n\t\t\tcpu_to_le16(TW_REQ_LUN_IN(TW_LUN_OUT(newcommand->request_id__lunl), request_id));\n\t\tif (length) {\n\t\t\tnewcommand->sg_list[0].address = TW_CPU_TO_SGL(dma_handle + sizeof(TW_Ioctl_Buf_Apache));\n\t\t\tnewcommand->sg_list[0].length = TW_CPU_TO_SGL(length);\n\t\t}\n\t\tnewcommand->sgl_entries__lunh =\n\t\t\tcpu_to_le16(TW_REQ_LUN_IN(TW_LUN_OUT(newcommand->sgl_entries__lunh), length ? 1 : 0));\n\t} else {\n\t\toldcommand = &full_command_packet->command.oldcommand;\n\t\toldcommand->request_id = request_id;\n\n\t\tif (TW_SGL_OUT(oldcommand->opcode__sgloffset)) {\n\t\t\t \n\t\t\tsgl = (TW_SG_Entry_ISO *)((u32 *)oldcommand+oldcommand->size - (sizeof(TW_SG_Entry_ISO)/4) + pae + (sizeof(dma_addr_t) > 4 ? 1 : 0));\n\t\t\tsgl->address = TW_CPU_TO_SGL(dma_handle + sizeof(TW_Ioctl_Buf_Apache));\n\t\t\tsgl->length = TW_CPU_TO_SGL(length);\n\t\t\toldcommand->size += pae;\n\t\t\toldcommand->size += sizeof(dma_addr_t) > 4 ? 1 : 0;\n\t\t}\n\t}\n}  \n\n \nstatic long twl_chrdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong timeout;\n\tunsigned long *cpu_addr, data_buffer_length_adjusted = 0, flags = 0;\n\tdma_addr_t dma_handle;\n\tint request_id = 0;\n\tTW_Ioctl_Driver_Command driver_command;\n\tstruct inode *inode = file_inode(file);\n\tTW_Ioctl_Buf_Apache *tw_ioctl;\n\tTW_Command_Full *full_command_packet;\n\tTW_Device_Extension *tw_dev = twl_device_extension_list[iminor(inode)];\n\tint retval = -EFAULT;\n\tvoid __user *argp = (void __user *)arg;\n\n\tmutex_lock(&twl_chrdev_mutex);\n\n\t \n\tif (mutex_lock_interruptible(&tw_dev->ioctl_lock)) {\n\t\tretval = -EINTR;\n\t\tgoto out;\n\t}\n\n\t \n\tif (copy_from_user(&driver_command, argp, sizeof(TW_Ioctl_Driver_Command)))\n\t\tgoto out2;\n\n\t \n\tif (driver_command.buffer_length > TW_MAX_SECTORS * 2048) {\n\t\tretval = -EINVAL;\n\t\tgoto out2;\n\t}\n\n\t \n\tdata_buffer_length_adjusted = (driver_command.buffer_length + 511) & ~511;\n\n\t \n\tcpu_addr = dma_alloc_coherent(&tw_dev->tw_pci_dev->dev, data_buffer_length_adjusted + sizeof(TW_Ioctl_Buf_Apache), &dma_handle, GFP_KERNEL);\n\tif (!cpu_addr) {\n\t\tretval = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\ttw_ioctl = (TW_Ioctl_Buf_Apache *)cpu_addr;\n\n\t \n\tif (copy_from_user(tw_ioctl, argp, driver_command.buffer_length + sizeof(TW_Ioctl_Buf_Apache)))\n\t\tgoto out3;\n\n\t \n\tswitch (cmd) {\n\tcase TW_IOCTL_FIRMWARE_PASS_THROUGH:\n\t\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\t\ttwl_get_request_id(tw_dev, &request_id);\n\n\t\t \n\t\ttw_dev->srb[request_id] = NULL;\n\n\t\t \n\t\ttw_dev->chrdev_request_id = request_id;\n\n\t\tfull_command_packet = (TW_Command_Full *)&tw_ioctl->firmware_command;\n\n\t\t \n\t\ttwl_load_sgl(tw_dev, full_command_packet, request_id, dma_handle, data_buffer_length_adjusted);\n\n\t\tmemcpy(tw_dev->command_packet_virt[request_id], &(tw_ioctl->firmware_command), sizeof(TW_Command_Full));\n\n\t\t \n\t\ttwl_post_command_packet(tw_dev, request_id);\n\t\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\n\t\ttimeout = TW_IOCTL_CHRDEV_TIMEOUT*HZ;\n\n\t\t \n\t\ttimeout = wait_event_timeout(tw_dev->ioctl_wqueue, tw_dev->chrdev_request_id == TW_IOCTL_CHRDEV_FREE, timeout);\n\n\t\t \n\t\tif (tw_dev->chrdev_request_id != TW_IOCTL_CHRDEV_FREE) {\n\t\t\t \n\t\t\tprintk(KERN_WARNING \"3w-sas: scsi%d: WARNING: (0x%02X:0x%04X): Character ioctl (0x%x) timed out, resetting card.\\n\",\n\t\t\t       tw_dev->host->host_no, TW_DRIVER, 0x6,\n\t\t\t       cmd);\n\t\t\tretval = -EIO;\n\t\t\ttwl_reset_device_extension(tw_dev, 1);\n\t\t\tgoto out3;\n\t\t}\n\n\t\t \n\t\tmemcpy(&(tw_ioctl->firmware_command), tw_dev->command_packet_virt[request_id], sizeof(TW_Command_Full));\n\n\t\t \n\t\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\t\ttw_dev->posted_request_count--;\n\t\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\t\ttwl_free_request_id(tw_dev, request_id);\n\t\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tretval = -ENOTTY;\n\t\tgoto out3;\n\t}\n\n\t \n\tif (copy_to_user(argp, tw_ioctl, sizeof(TW_Ioctl_Buf_Apache) + driver_command.buffer_length) == 0)\n\t\tretval = 0;\nout3:\n\t \n\tdma_free_coherent(&tw_dev->tw_pci_dev->dev, data_buffer_length_adjusted + sizeof(TW_Ioctl_Buf_Apache), cpu_addr, dma_handle);\nout2:\n\tmutex_unlock(&tw_dev->ioctl_lock);\nout:\n\tmutex_unlock(&twl_chrdev_mutex);\n\treturn retval;\n}  \n\n \nstatic int twl_chrdev_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor_number;\n\tint retval = -ENODEV;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tretval = -EACCES;\n\t\tgoto out;\n\t}\n\n\tminor_number = iminor(inode);\n\tif (minor_number >= twl_device_extension_count)\n\t\tgoto out;\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic const struct file_operations twl_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= twl_chrdev_ioctl,\n\t.open\t\t= twl_chrdev_open,\n\t.release\t= NULL,\n\t.llseek\t\t= noop_llseek,\n};\n\n \nstatic int twl_fill_sense(TW_Device_Extension *tw_dev, int i, int request_id, int copy_sense, int print_host)\n{\n\tTW_Command_Apache_Header *header;\n\tTW_Command_Full *full_command_packet;\n\tunsigned short error;\n\tchar *error_str;\n\n\theader = tw_dev->sense_buffer_virt[i];\n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\n\t \n\terror_str = &(header->err_specific_desc[strlen(header->err_specific_desc) + 1]);\n\n\t \n\terror = le16_to_cpu(header->status_block.error);\n\tif ((error != TW_ERROR_LOGICAL_UNIT_NOT_SUPPORTED) && (error != TW_ERROR_UNIT_OFFLINE) && (error != TW_ERROR_INVALID_FIELD_IN_CDB)) {\n\t\tif (print_host)\n\t\t\tprintk(KERN_WARNING \"3w-sas: scsi%d: ERROR: (0x%02X:0x%04X): %s:%s.\\n\",\n\t\t\t       tw_dev->host->host_no,\n\t\t\t       TW_MESSAGE_SOURCE_CONTROLLER_ERROR,\n\t\t\t       header->status_block.error,\n\t\t\t       error_str,\n\t\t\t       header->err_specific_desc);\n\t\telse\n\t\t\tprintk(KERN_WARNING \"3w-sas: ERROR: (0x%02X:0x%04X): %s:%s.\\n\",\n\t\t\t       TW_MESSAGE_SOURCE_CONTROLLER_ERROR,\n\t\t\t       header->status_block.error,\n\t\t\t       error_str,\n\t\t\t       header->err_specific_desc);\n\t}\n\n\tif (copy_sense) {\n\t\tmemcpy(tw_dev->srb[request_id]->sense_buffer, header->sense_data, TW_SENSE_DATA_LENGTH);\n\t\ttw_dev->srb[request_id]->result = (full_command_packet->command.newcommand.status << 1);\n\t\tgoto out;\n\t}\nout:\n\treturn 1;\n}  \n\n \nstatic void twl_free_device_extension(TW_Device_Extension *tw_dev)\n{\n\tif (tw_dev->command_packet_virt[0])\n\t\tdma_free_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\t\t    sizeof(TW_Command_Full)*TW_Q_LENGTH,\n\t\t\t\t    tw_dev->command_packet_virt[0],\n\t\t\t\t    tw_dev->command_packet_phys[0]);\n\n\tif (tw_dev->generic_buffer_virt[0])\n\t\tdma_free_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\t\t    TW_SECTOR_SIZE*TW_Q_LENGTH,\n\t\t\t\t    tw_dev->generic_buffer_virt[0],\n\t\t\t\t    tw_dev->generic_buffer_phys[0]);\n\n\tif (tw_dev->sense_buffer_virt[0])\n\t\tdma_free_coherent(&tw_dev->tw_pci_dev->dev,\n\t\t\t\t    sizeof(TW_Command_Apache_Header)*\n\t\t\t\t    TW_Q_LENGTH,\n\t\t\t\t    tw_dev->sense_buffer_virt[0],\n\t\t\t\t    tw_dev->sense_buffer_phys[0]);\n\n\tkfree(tw_dev->event_queue[0]);\n}  \n\n \nstatic void *twl_get_param(TW_Device_Extension *tw_dev, int request_id, int table_id, int parameter_id, int parameter_size_bytes)\n{\n\tTW_Command_Full *full_command_packet;\n\tTW_Command *command_packet;\n\tTW_Param_Apache *param;\n\tvoid *retval = NULL;\n\n\t \n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\tcommand_packet = &full_command_packet->command.oldcommand;\n\n\tcommand_packet->opcode__sgloffset = TW_OPSGL_IN(2, TW_OP_GET_PARAM);\n\tcommand_packet->size\t\t  = TW_COMMAND_SIZE;\n\tcommand_packet->request_id\t  = request_id;\n\tcommand_packet->byte6_offset.block_count = cpu_to_le16(1);\n\n\t \n\tparam = (TW_Param_Apache *)tw_dev->generic_buffer_virt[request_id];\n\tmemset(param, 0, TW_SECTOR_SIZE);\n\tparam->table_id = cpu_to_le16(table_id | 0x8000);\n\tparam->parameter_id = cpu_to_le16(parameter_id);\n\tparam->parameter_size_bytes = cpu_to_le16(parameter_size_bytes);\n\n\tcommand_packet->byte8_offset.param.sgl[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\n\tcommand_packet->byte8_offset.param.sgl[0].length = TW_CPU_TO_SGL(TW_SECTOR_SIZE);\n\n\t \n\ttwl_post_command_packet(tw_dev, request_id);\n\n\t \n\tif (twl_poll_response(tw_dev, request_id, 30))\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x7, \"No valid response during get param\")\n\telse\n\t\tretval = (void *)&(param->data[0]);\n\n\ttw_dev->posted_request_count--;\n\ttw_dev->state[request_id] = TW_S_INITIAL;\n\n\treturn retval;\n}  \n\n \nstatic int twl_initconnection(TW_Device_Extension *tw_dev, int message_credits,\n\t\t\t      u32 set_features, unsigned short current_fw_srl,\n\t\t\t      unsigned short current_fw_arch_id,\n\t\t\t      unsigned short current_fw_branch,\n\t\t\t      unsigned short current_fw_build,\n\t\t\t      unsigned short *fw_on_ctlr_srl,\n\t\t\t      unsigned short *fw_on_ctlr_arch_id,\n\t\t\t      unsigned short *fw_on_ctlr_branch,\n\t\t\t      unsigned short *fw_on_ctlr_build,\n\t\t\t      u32 *init_connect_result)\n{\n\tTW_Command_Full *full_command_packet;\n\tTW_Initconnect *tw_initconnect;\n\tint request_id = 0, retval = 1;\n\n\t \n\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\tmemset(full_command_packet, 0, sizeof(TW_Command_Full));\n\tfull_command_packet->header.header_desc.size_header = 128;\n\n\ttw_initconnect = (TW_Initconnect *)&full_command_packet->command.oldcommand;\n\ttw_initconnect->opcode__reserved = TW_OPRES_IN(0, TW_OP_INIT_CONNECTION);\n\ttw_initconnect->request_id = request_id;\n\ttw_initconnect->message_credits = cpu_to_le16(message_credits);\n\ttw_initconnect->features = set_features;\n\n\t \n\ttw_initconnect->features |= sizeof(dma_addr_t) > 4 ? 1 : 0;\n\n\ttw_initconnect->features = cpu_to_le32(tw_initconnect->features);\n\n\tif (set_features & TW_EXTENDED_INIT_CONNECT) {\n\t\ttw_initconnect->size = TW_INIT_COMMAND_PACKET_SIZE_EXTENDED;\n\t\ttw_initconnect->fw_srl = cpu_to_le16(current_fw_srl);\n\t\ttw_initconnect->fw_arch_id = cpu_to_le16(current_fw_arch_id);\n\t\ttw_initconnect->fw_branch = cpu_to_le16(current_fw_branch);\n\t\ttw_initconnect->fw_build = cpu_to_le16(current_fw_build);\n\t} else\n\t\ttw_initconnect->size = TW_INIT_COMMAND_PACKET_SIZE;\n\n\t \n\ttwl_post_command_packet(tw_dev, request_id);\n\n\t \n\tif (twl_poll_response(tw_dev, request_id, 30)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x8, \"No valid response during init connection\");\n\t} else {\n\t\tif (set_features & TW_EXTENDED_INIT_CONNECT) {\n\t\t\t*fw_on_ctlr_srl = le16_to_cpu(tw_initconnect->fw_srl);\n\t\t\t*fw_on_ctlr_arch_id = le16_to_cpu(tw_initconnect->fw_arch_id);\n\t\t\t*fw_on_ctlr_branch = le16_to_cpu(tw_initconnect->fw_branch);\n\t\t\t*fw_on_ctlr_build = le16_to_cpu(tw_initconnect->fw_build);\n\t\t\t*init_connect_result = le32_to_cpu(tw_initconnect->result);\n\t\t}\n\t\tretval = 0;\n\t}\n\n\ttw_dev->posted_request_count--;\n\ttw_dev->state[request_id] = TW_S_INITIAL;\n\n\treturn retval;\n}  \n\n \nstatic int twl_initialize_device_extension(TW_Device_Extension *tw_dev)\n{\n\tint i, retval = 1;\n\n\t \n\tif (twl_allocate_memory(tw_dev, sizeof(TW_Command_Full), 0)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x9, \"Command packet memory allocation failed\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (twl_allocate_memory(tw_dev, TW_SECTOR_SIZE, 1)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xa, \"Generic memory allocation failed\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (twl_allocate_memory(tw_dev, sizeof(TW_Command_Apache_Header), 2)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xb, \"Sense buffer allocation failed\");\n\t\tgoto out;\n\t}\n\n\t \n\ttw_dev->event_queue[0] = kcalloc(TW_Q_LENGTH, sizeof(TW_Event), GFP_KERNEL);\n\tif (!tw_dev->event_queue[0]) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xc, \"Event info memory allocation failed\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < TW_Q_LENGTH; i++) {\n\t\ttw_dev->event_queue[i] = (TW_Event *)((unsigned char *)tw_dev->event_queue[0] + (i * sizeof(TW_Event)));\n\t\ttw_dev->free_queue[i] = i;\n\t\ttw_dev->state[i] = TW_S_INITIAL;\n\t}\n\n\ttw_dev->free_head = TW_Q_START;\n\ttw_dev->free_tail = TW_Q_START;\n\ttw_dev->error_sequence_id = 1;\n\ttw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\n\n\tmutex_init(&tw_dev->ioctl_lock);\n\tinit_waitqueue_head(&tw_dev->ioctl_wqueue);\n\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twl_handle_attention_interrupt(TW_Device_Extension *tw_dev)\n{\n\tint retval = 1;\n\tu32 request_id, doorbell;\n\n\t \n\tdoorbell = readl(TWL_HOBDB_REG_ADDR(tw_dev));\n\n\t \n\tif (doorbell & TWL_DOORBELL_CONTROLLER_ERROR) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xd, \"Microcontroller Error: clearing\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (doorbell & TWL_DOORBELL_ATTENTION_INTERRUPT) {\n\t\tif (!(test_and_set_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags))) {\n\t\t\ttwl_get_request_id(tw_dev, &request_id);\n\t\t\tif (twl_aen_read_queue(tw_dev, request_id)) {\n\t\t\t\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\t\t\t\ttwl_free_request_id(tw_dev, request_id);\n\t\t\t\tclear_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags);\n\t\t\t}\n\t\t}\n\t}\n\n\tretval = 0;\nout:\n\t \n\tTWL_CLEAR_DB_INTERRUPT(tw_dev);\n\n\t \n\treadl(TWL_HOBDBC_REG_ADDR(tw_dev));\n\n\treturn retval;\n}  \n\n \nstatic irqreturn_t twl_interrupt(int irq, void *dev_instance)\n{\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)dev_instance;\n\tint i, handled = 0, error = 0;\n\tdma_addr_t mfa = 0;\n\tu32 reg, regl, regh, response, request_id = 0;\n\tstruct scsi_cmnd *cmd;\n\tTW_Command_Full *full_command_packet;\n\n\tspin_lock(tw_dev->host->host_lock);\n\n\t \n\treg = readl(TWL_HISTAT_REG_ADDR(tw_dev));\n\n\t \n\tif (!(reg & TWL_HISTATUS_VALID_INTERRUPT))\n\t\tgoto twl_interrupt_bail;\n\n\thandled = 1;\n\n\t \n\tif (test_bit(TW_IN_RESET, &tw_dev->flags))\n\t\tgoto twl_interrupt_bail;\n\n\t \n\tif (reg & TWL_HISTATUS_ATTENTION_INTERRUPT) {\n\t\tif (twl_handle_attention_interrupt(tw_dev)) {\n\t\t\tTWL_MASK_INTERRUPTS(tw_dev);\n\t\t\tgoto twl_interrupt_bail;\n\t\t}\n\t}\n\n\t \n\twhile (reg & TWL_HISTATUS_RESPONSE_INTERRUPT) {\n\t\tif (sizeof(dma_addr_t) > 4) {\n\t\t\tregh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));\n\t\t\tregl = readl(TWL_HOBQPL_REG_ADDR(tw_dev));\n\t\t\tmfa = ((u64)regh << 32) | regl;\n\t\t} else\n\t\t\tmfa = readl(TWL_HOBQPL_REG_ADDR(tw_dev));\n\n\t\terror = 0;\n\t\tresponse = (u32)mfa;\n\n\t\t \n\t\tif (!TW_NOTMFA_OUT(response)) {\n\t\t\tfor (i=0;i<TW_Q_LENGTH;i++) {\n\t\t\t\tif (tw_dev->sense_buffer_phys[i] == mfa) {\n\t\t\t\t\trequest_id = le16_to_cpu(tw_dev->sense_buffer_virt[i]->header_desc.request_id);\n\t\t\t\t\tif (tw_dev->srb[request_id] != NULL)\n\t\t\t\t\t\terror = twl_fill_sense(tw_dev, i, request_id, 1, 1);\n\t\t\t\t\telse {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (request_id != tw_dev->chrdev_request_id)\n\t\t\t\t\t\t\terror = twl_fill_sense(tw_dev, i, request_id, 0, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmemcpy(tw_dev->command_packet_virt[request_id], tw_dev->sense_buffer_virt[i], sizeof(TW_Command_Apache_Header));\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\twritel((u32)((u64)tw_dev->sense_buffer_phys[i] >> 32), TWL_HOBQPH_REG_ADDR(tw_dev));\n\t\t\t\t\twritel((u32)tw_dev->sense_buffer_phys[i], TWL_HOBQPL_REG_ADDR(tw_dev));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\trequest_id = TW_RESID_OUT(response);\n\n\t\tfull_command_packet = tw_dev->command_packet_virt[request_id];\n\n\t\t \n\t\tif (tw_dev->state[request_id] != TW_S_POSTED) {\n\t\t\tif (tw_dev->srb[request_id] != NULL) {\n\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xe, \"Received a request id that wasn't posted\");\n\t\t\t\tTWL_MASK_INTERRUPTS(tw_dev);\n\t\t\t\tgoto twl_interrupt_bail;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (tw_dev->srb[request_id] == NULL) {\n\t\t\tif (request_id != tw_dev->chrdev_request_id) {\n\t\t\t\tif (twl_aen_complete(tw_dev, request_id))\n\t\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0xf, \"Error completing AEN during attention interrupt\");\n\t\t\t} else {\n\t\t\t\ttw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\n\t\t\t\twake_up(&tw_dev->ioctl_wqueue);\n\t\t\t}\n\t\t} else {\n\t\t\tcmd = tw_dev->srb[request_id];\n\n\t\t\tif (!error)\n\t\t\t\tcmd->result = (DID_OK << 16);\n\n\t\t\t \n\t\t\tif ((scsi_sg_count(cmd) <= 1) && (full_command_packet->command.newcommand.status == 0)) {\n\t\t\t\tif (full_command_packet->command.newcommand.sg_list[0].length < scsi_bufflen(tw_dev->srb[request_id]))\n\t\t\t\t\tscsi_set_resid(cmd, scsi_bufflen(cmd) - full_command_packet->command.newcommand.sg_list[0].length);\n\t\t\t}\n\n\t\t\t \n\t\t\tscsi_dma_unmap(cmd);\n\t\t\tscsi_done(cmd);\n\t\t\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\t\t\ttwl_free_request_id(tw_dev, request_id);\n\t\t\ttw_dev->posted_request_count--;\n\t\t}\n\n\t\t \n\t\treg = readl(TWL_HISTAT_REG_ADDR(tw_dev));\n\t}\n\ntwl_interrupt_bail:\n\tspin_unlock(tw_dev->host->host_lock);\n\treturn IRQ_RETVAL(handled);\n}  \n\n \nstatic int twl_poll_register(TW_Device_Extension *tw_dev, void *reg, u32 value, u32 result, int seconds)\n{\n\tunsigned long before;\n\tint retval = 1;\n\tu32 reg_value;\n\n\treg_value = readl(reg);\n\tbefore = jiffies;\n\n\twhile ((reg_value & value) != result) {\n\t\treg_value = readl(reg);\n\t\tif (time_after(jiffies, before + HZ * seconds))\n\t\t\tgoto out;\n\t\tmsleep(50);\n\t}\n\tretval = 0;\nout:\n\treturn retval;\n}  \n\n \nstatic int twl_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset)\n{\n\tint retval = 1;\n\tint i = 0;\n\tu32 status = 0;\n\tunsigned short fw_on_ctlr_srl = 0, fw_on_ctlr_arch_id = 0;\n\tunsigned short fw_on_ctlr_branch = 0, fw_on_ctlr_build = 0;\n\tu32 init_connect_result = 0;\n\tint tries = 0;\n\tint do_soft_reset = soft_reset;\n\n\twhile (tries < TW_MAX_RESET_TRIES) {\n\t\t \n\t\tif (do_soft_reset) {\n\t\t\tTWL_SOFT_RESET(tw_dev);\n\n\t\t\t \n\t\t\tif (twl_poll_register(tw_dev, TWL_SCRPD3_REG_ADDR(tw_dev), TWL_CONTROLLER_READY, 0x0, 30)) {\n\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x10, \"Controller never went non-ready during reset sequence\");\n\t\t\t\ttries++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (twl_poll_register(tw_dev, TWL_SCRPD3_REG_ADDR(tw_dev), TWL_CONTROLLER_READY, TWL_CONTROLLER_READY, 60)) {\n\t\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x11, \"Controller not ready during reset sequence\");\n\t\t\t\ttries++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (twl_initconnection(tw_dev, TW_INIT_MESSAGE_CREDITS,\n\t\t\t\t       TW_EXTENDED_INIT_CONNECT, TW_CURRENT_DRIVER_SRL,\n\t\t\t\t       TW_9750_ARCH_ID, TW_CURRENT_DRIVER_BRANCH,\n\t\t\t\t       TW_CURRENT_DRIVER_BUILD, &fw_on_ctlr_srl,\n\t\t\t\t       &fw_on_ctlr_arch_id, &fw_on_ctlr_branch,\n\t\t\t\t       &fw_on_ctlr_build, &init_connect_result)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x12, \"Initconnection failed while checking SRL\");\n\t\t\tdo_soft_reset = 1;\n\t\t\ttries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\twhile (i < TW_Q_LENGTH) {\n\t\t\twritel((u32)((u64)tw_dev->sense_buffer_phys[i] >> 32), TWL_HOBQPH_REG_ADDR(tw_dev));\n\t\t\twritel((u32)tw_dev->sense_buffer_phys[i], TWL_HOBQPL_REG_ADDR(tw_dev));\n\n\t\t\t \n\t\t\tstatus = readl(TWL_STATUS_REG_ADDR(tw_dev));\n\t\t\tif (!(status & TWL_STATUS_OVERRUN_SUBMIT))\n\t\t\t    i++;\n\t\t}\n\n\t\t \n\t\tstatus = readl(TWL_STATUS_REG_ADDR(tw_dev));\n\t\tif (status) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x13, \"Bad controller status after loading sense buffers\");\n\t\t\tdo_soft_reset = 1;\n\t\t\ttries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (twl_aen_drain_queue(tw_dev, soft_reset)) {\n\t\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x14, \"AEN drain failed during reset sequence\");\n\t\t\tdo_soft_reset = 1;\n\t\t\ttries++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tstrncpy(tw_dev->tw_compat_info.driver_version, TW_DRIVER_VERSION, strlen(TW_DRIVER_VERSION));\n\t\ttw_dev->tw_compat_info.driver_srl_high = TW_CURRENT_DRIVER_SRL;\n\t\ttw_dev->tw_compat_info.driver_branch_high = TW_CURRENT_DRIVER_BRANCH;\n\t\ttw_dev->tw_compat_info.driver_build_high = TW_CURRENT_DRIVER_BUILD;\n\t\ttw_dev->tw_compat_info.driver_srl_low = TW_BASE_FW_SRL;\n\t\ttw_dev->tw_compat_info.driver_branch_low = TW_BASE_FW_BRANCH;\n\t\ttw_dev->tw_compat_info.driver_build_low = TW_BASE_FW_BUILD;\n\t\ttw_dev->tw_compat_info.fw_on_ctlr_srl = fw_on_ctlr_srl;\n\t\ttw_dev->tw_compat_info.fw_on_ctlr_branch = fw_on_ctlr_branch;\n\t\ttw_dev->tw_compat_info.fw_on_ctlr_build = fw_on_ctlr_build;\n\n\t\t \n\t\tretval = 0;\n\t\tgoto out;\n\t}\nout:\n\treturn retval;\n}  \n\n \nstatic int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_reset)\n{\n\tint i = 0, retval = 1;\n\tunsigned long flags = 0;\n\n\t \n\tif (ioctl_reset)\n\t\tscsi_block_requests(tw_dev->host);\n\n\tset_bit(TW_IN_RESET, &tw_dev->flags);\n\tTWL_MASK_INTERRUPTS(tw_dev);\n\tTWL_CLEAR_DB_INTERRUPT(tw_dev);\n\n\tspin_lock_irqsave(tw_dev->host->host_lock, flags);\n\n\t \n\tfor (i = 0; i < TW_Q_LENGTH; i++) {\n\t\tif ((tw_dev->state[i] != TW_S_FINISHED) &&\n\t\t    (tw_dev->state[i] != TW_S_INITIAL) &&\n\t\t    (tw_dev->state[i] != TW_S_COMPLETED)) {\n\t\t\tstruct scsi_cmnd *cmd = tw_dev->srb[i];\n\n\t\t\tif (cmd) {\n\t\t\t\tcmd->result = (DID_RESET << 16);\n\t\t\t\tscsi_dma_unmap(cmd);\n\t\t\t\tscsi_done(cmd);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < TW_Q_LENGTH; i++) {\n\t\ttw_dev->free_queue[i] = i;\n\t\ttw_dev->state[i] = TW_S_INITIAL;\n\t}\n\ttw_dev->free_head = TW_Q_START;\n\ttw_dev->free_tail = TW_Q_START;\n\ttw_dev->posted_request_count = 0;\n\n\tspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\n\n\tif (twl_reset_sequence(tw_dev, 1))\n\t\tgoto out;\n\n\tTWL_UNMASK_INTERRUPTS(tw_dev);\n\n\tclear_bit(TW_IN_RESET, &tw_dev->flags);\n\ttw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\n\n\tretval = 0;\nout:\n\tif (ioctl_reset)\n\t\tscsi_unblock_requests(tw_dev->host);\n\treturn retval;\n}  \n\n \nstatic int twl_scsi_biosparam(struct scsi_device *sdev, struct block_device *bdev, sector_t capacity, int geom[])\n{\n\tint heads, sectors;\n\n\tif (capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t} else {\n\t\theads = 64;\n\t\tsectors = 32;\n\t}\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = sector_div(capacity, heads * sectors);  \n\n\treturn 0;\n}  \n\n \nstatic int twl_scsi_eh_reset(struct scsi_cmnd *SCpnt)\n{\n\tTW_Device_Extension *tw_dev = NULL;\n\tint retval = FAILED;\n\n\ttw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;\n\n\ttw_dev->num_resets++;\n\n\tsdev_printk(KERN_WARNING, SCpnt->device,\n\t\t\"WARNING: (0x%02X:0x%04X): Command (0x%x) timed out, resetting card.\\n\",\n\t\tTW_DRIVER, 0x2c, SCpnt->cmnd[0]);\n\n\t \n\tmutex_lock(&tw_dev->ioctl_lock);\n\n\t \n\tif (twl_reset_device_extension(tw_dev, 0)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x15, \"Controller reset failed during scsi host reset\");\n\t\tgoto out;\n\t}\n\n\tretval = SUCCESS;\nout:\n\tmutex_unlock(&tw_dev->ioctl_lock);\n\treturn retval;\n}  \n\n \nstatic int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tint request_id, retval;\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;\n\n\t \n\tif (test_bit(TW_IN_RESET, &tw_dev->flags)) {\n\t\tretval = SCSI_MLQUEUE_HOST_BUSY;\n\t\tgoto out;\n\t}\n\n\t \n\ttwl_get_request_id(tw_dev, &request_id);\n\n\t \n\ttw_dev->srb[request_id] = SCpnt;\n\n\tretval = twl_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);\n\tif (retval) {\n\t\ttw_dev->state[request_id] = TW_S_COMPLETED;\n\t\ttwl_free_request_id(tw_dev, request_id);\n\t\tSCpnt->result = (DID_ERROR << 16);\n\t\tdone(SCpnt);\n\t\tretval = 0;\n\t}\nout:\n\treturn retval;\n}  \n\nstatic DEF_SCSI_QCMD(twl_scsi_queue)\n\n \nstatic void __twl_shutdown(TW_Device_Extension *tw_dev)\n{\n\t \n\tTWL_MASK_INTERRUPTS(tw_dev);\n\n\t \n\tfree_irq(tw_dev->tw_pci_dev->irq, tw_dev);\n\n\tprintk(KERN_WARNING \"3w-sas: Shutting down host %d.\\n\", tw_dev->host->host_no);\n\n\t \n\tif (twl_initconnection(tw_dev, 1, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x16, \"Connection shutdown failed\");\n\t} else {\n\t\tprintk(KERN_WARNING \"3w-sas: Shutdown complete.\\n\");\n\t}\n\n\t \n\tTWL_CLEAR_DB_INTERRUPT(tw_dev);\n}  \n\n \nstatic void twl_shutdown(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tTW_Device_Extension *tw_dev;\n\n\tif (!host)\n\t\treturn;\n\n\ttw_dev = (TW_Device_Extension *)host->hostdata;\n\n\tif (tw_dev->online)\n\t\t__twl_shutdown(tw_dev);\n}  \n\n \nstatic int twl_slave_configure(struct scsi_device *sdev)\n{\n\t \n\tblk_queue_rq_timeout(sdev->request_queue, 60 * HZ);\n\n\treturn 0;\n}  \n\nstatic const struct scsi_host_template driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"3w-sas\",\n\t.queuecommand\t\t= twl_scsi_queue,\n\t.eh_host_reset_handler\t= twl_scsi_eh_reset,\n\t.bios_param\t\t= twl_scsi_biosparam,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.can_queue\t\t= TW_Q_LENGTH-2,\n\t.slave_configure\t= twl_slave_configure,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= TW_LIBERATOR_MAX_SGL_LENGTH,\n\t.max_sectors\t\t= TW_MAX_SECTORS,\n\t.cmd_per_lun\t\t= TW_MAX_CMDS_PER_LUN,\n\t.shost_groups\t\t= twl_host_groups,\n\t.emulated\t\t= 1,\n\t.no_write_same\t\t= 1,\n};\n\n \nstatic int twl_probe(struct pci_dev *pdev, const struct pci_device_id *dev_id)\n{\n\tstruct Scsi_Host *host = NULL;\n\tTW_Device_Extension *tw_dev;\n\tint retval = -ENODEV;\n\tint *ptr_phycount, phycount=0;\n\n\tretval = pci_enable_device(pdev);\n\tif (retval) {\n\t\tTW_PRINTK(host, TW_DRIVER, 0x17, \"Failed to enable pci device\");\n\t\tgoto out_disable_device;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\tretval = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (retval) {\n\t\tTW_PRINTK(host, TW_DRIVER, 0x18, \"Failed to set dma mask\");\n\t\tretval = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\n\thost = scsi_host_alloc(&driver_template, sizeof(TW_Device_Extension));\n\tif (!host) {\n\t\tTW_PRINTK(host, TW_DRIVER, 0x19, \"Failed to allocate memory for device extension\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\ttw_dev = shost_priv(host);\n\n\t \n\ttw_dev->host = host;\n\ttw_dev->tw_pci_dev = pdev;\n\n\tif (twl_initialize_device_extension(tw_dev)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1a, \"Failed to initialize device extension\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_free_device_extension;\n\t}\n\n\t \n\tretval = pci_request_regions(pdev, \"3w-sas\");\n\tif (retval) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1b, \"Failed to get mem region\");\n\t\tgoto out_free_device_extension;\n\t}\n\n\t \n\ttw_dev->base_addr = pci_iomap(pdev, 1, 0);\n\tif (!tw_dev->base_addr) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1c, \"Failed to ioremap\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_release_mem_region;\n\t}\n\n\t \n\tTWL_MASK_INTERRUPTS(tw_dev);\n\n\t \n\tif (twl_reset_sequence(tw_dev, 0)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1d, \"Controller reset failed during probe\");\n\t\tretval = -ENOMEM;\n\t\tgoto out_iounmap;\n\t}\n\n\t \n\thost->max_id = TW_MAX_UNITS;\n\thost->max_cmd_len = TW_MAX_CDB_LEN;\n\thost->max_lun = TW_MAX_LUNS;\n\thost->max_channel = 0;\n\n\t \n\tretval = scsi_add_host(host, &pdev->dev);\n\tif (retval) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1e, \"scsi add host failed\");\n\t\tgoto out_iounmap;\n\t}\n\n\tpci_set_drvdata(pdev, host);\n\n\tprintk(KERN_WARNING \"3w-sas: scsi%d: Found an LSI 3ware %s Controller at 0x%llx, IRQ: %d.\\n\",\n\t       host->host_no,\n\t       (char *)twl_get_param(tw_dev, 1, TW_VERSION_TABLE,\n\t\t\t\t     TW_PARAM_MODEL, TW_PARAM_MODEL_LENGTH),\n\t       (u64)pci_resource_start(pdev, 1), pdev->irq);\n\n\tptr_phycount = twl_get_param(tw_dev, 2, TW_PARAM_PHY_SUMMARY_TABLE,\n\t\t\t\t     TW_PARAM_PHYCOUNT, TW_PARAM_PHYCOUNT_LENGTH);\n\tif (ptr_phycount)\n\t\tphycount = le32_to_cpu(*(int *)ptr_phycount);\n\n\tprintk(KERN_WARNING \"3w-sas: scsi%d: Firmware %s, BIOS %s, Phys: %d.\\n\",\n\t       host->host_no,\n\t       (char *)twl_get_param(tw_dev, 1, TW_VERSION_TABLE,\n\t\t\t\t     TW_PARAM_FWVER, TW_PARAM_FWVER_LENGTH),\n\t       (char *)twl_get_param(tw_dev, 2, TW_VERSION_TABLE,\n\t\t\t\t     TW_PARAM_BIOSVER, TW_PARAM_BIOSVER_LENGTH),\n\t       phycount);\n\n\t \n\tif (use_msi && !pci_enable_msi(pdev))\n\t\tset_bit(TW_USING_MSI, &tw_dev->flags);\n\n\t \n\tretval = request_irq(pdev->irq, twl_interrupt, IRQF_SHARED, \"3w-sas\", tw_dev);\n\tif (retval) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1f, \"Error requesting IRQ\");\n\t\tgoto out_remove_host;\n\t}\n\n\ttwl_device_extension_list[twl_device_extension_count] = tw_dev;\n\ttwl_device_extension_count++;\n\n\t \n\tTWL_UNMASK_INTERRUPTS(tw_dev);\n\n\t \n\tscsi_scan_host(host);\n\n\t \n\tif (sysfs_create_bin_file(&host->shost_dev.kobj, &twl_sysfs_aen_read_attr))\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x20, \"Failed to create sysfs binary file: 3ware_aen_read\");\n\tif (sysfs_create_bin_file(&host->shost_dev.kobj, &twl_sysfs_compat_info_attr))\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x21, \"Failed to create sysfs binary file: 3ware_compat_info\");\n\n\tif (twl_major == -1) {\n\t\tif ((twl_major = register_chrdev (0, \"twl\", &twl_fops)) < 0)\n\t\t\tTW_PRINTK(host, TW_DRIVER, 0x22, \"Failed to register character device\");\n\t}\n\ttw_dev->online = 1;\n\treturn 0;\n\nout_remove_host:\n\tif (test_bit(TW_USING_MSI, &tw_dev->flags))\n\t\tpci_disable_msi(pdev);\n\tscsi_remove_host(host);\nout_iounmap:\n\tiounmap(tw_dev->base_addr);\nout_release_mem_region:\n\tpci_release_regions(pdev);\nout_free_device_extension:\n\ttwl_free_device_extension(tw_dev);\n\tscsi_host_put(host);\nout_disable_device:\n\tpci_disable_device(pdev);\n\n\treturn retval;\n}  \n\n \nstatic void twl_remove(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tTW_Device_Extension *tw_dev;\n\n\tif (!host)\n\t\treturn;\n\n\ttw_dev = (TW_Device_Extension *)host->hostdata;\n\n\tif (!tw_dev->online)\n\t\treturn;\n\n\t \n\tsysfs_remove_bin_file(&host->shost_dev.kobj, &twl_sysfs_aen_read_attr);\n\tsysfs_remove_bin_file(&host->shost_dev.kobj, &twl_sysfs_compat_info_attr);\n\n\tscsi_remove_host(tw_dev->host);\n\n\t \n\tif (twl_major >= 0) {\n\t\tunregister_chrdev(twl_major, \"twl\");\n\t\ttwl_major = -1;\n\t}\n\n\t \n\t__twl_shutdown(tw_dev);\n\n\t \n\tif (test_bit(TW_USING_MSI, &tw_dev->flags))\n\t\tpci_disable_msi(pdev);\n\n\t \n\tiounmap(tw_dev->base_addr);\n\n\t \n\tpci_release_regions(pdev);\n\n\t \n\ttwl_free_device_extension(tw_dev);\n\n\tscsi_host_put(tw_dev->host);\n\tpci_disable_device(pdev);\n\ttwl_device_extension_count--;\n}  \n\n \nstatic int __maybe_unused twl_suspend(struct device *dev)\n{\n\tstruct Scsi_Host *host = dev_get_drvdata(dev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\n\n\tprintk(KERN_WARNING \"3w-sas: Suspending host %d.\\n\", tw_dev->host->host_no);\n\t \n\tTWL_MASK_INTERRUPTS(tw_dev);\n\n\tfree_irq(tw_dev->tw_pci_dev->irq, tw_dev);\n\n\t \n\tif (twl_initconnection(tw_dev, 1, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL)) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x23, \"Connection shutdown failed during suspend\");\n\t} else {\n\t\tprintk(KERN_WARNING \"3w-sas: Suspend complete.\\n\");\n\t}\n\n\t \n\tTWL_CLEAR_DB_INTERRUPT(tw_dev);\n\n\treturn 0;\n}  \n\n \nstatic int __maybe_unused twl_resume(struct device *dev)\n{\n\tint retval = 0;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\n\n\tprintk(KERN_WARNING \"3w-sas: Resuming host %d.\\n\", tw_dev->host->host_no);\n\tpci_try_set_mwi(pdev);\n\n\tretval = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (retval) {\n\t\tTW_PRINTK(host, TW_DRIVER, 0x25, \"Failed to set dma mask during resume\");\n\t\tretval = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\n\t \n\tif (twl_reset_sequence(tw_dev, 0)) {\n\t\tretval = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\n\t \n\tretval = request_irq(pdev->irq, twl_interrupt, IRQF_SHARED, \"3w-sas\", tw_dev);\n\tif (retval) {\n\t\tTW_PRINTK(tw_dev->host, TW_DRIVER, 0x26, \"Error requesting IRQ during resume\");\n\t\tretval = -ENODEV;\n\t\tgoto out_disable_device;\n\t}\n\n\t \n\tif (test_bit(TW_USING_MSI, &tw_dev->flags))\n\t\tpci_enable_msi(pdev);\n\n\t \n\tTWL_UNMASK_INTERRUPTS(tw_dev);\n\n\tprintk(KERN_WARNING \"3w-sas: Resume complete.\\n\");\n\treturn 0;\n\nout_disable_device:\n\tscsi_remove_host(host);\n\n\treturn retval;\n}  \n\n \nstatic struct pci_device_id twl_pci_tbl[] = {\n\t{ PCI_VDEVICE(3WARE, PCI_DEVICE_ID_3WARE_9750) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, twl_pci_tbl);\n\nstatic SIMPLE_DEV_PM_OPS(twl_pm_ops, twl_suspend, twl_resume);\n\n \nstatic struct pci_driver twl_driver = {\n\t.name\t\t= \"3w-sas\",\n\t.id_table\t= twl_pci_tbl,\n\t.probe\t\t= twl_probe,\n\t.remove\t\t= twl_remove,\n\t.driver.pm\t= &twl_pm_ops,\n\t.shutdown\t= twl_shutdown\n};\n\n \nstatic int __init twl_init(void)\n{\n\tprintk(KERN_INFO \"LSI 3ware SAS/SATA-RAID Controller device driver for Linux v%s.\\n\", TW_DRIVER_VERSION);\n\n\treturn pci_register_driver(&twl_driver);\n}  \n\n \nstatic void __exit twl_exit(void)\n{\n\tpci_unregister_driver(&twl_driver);\n}  \n\nmodule_init(twl_init);\nmodule_exit(twl_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}