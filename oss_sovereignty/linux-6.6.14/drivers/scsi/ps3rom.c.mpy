{
  "module_name": "ps3rom.c",
  "hash_id": "a051fd02fa0d4ae66dcc98c8f5b8ebc6a9f163db740f49e96d2ef3ec7405c5f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ps3rom.c",
  "human_readable_source": "\n \n\n#include <linux/cdrom.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_eh.h>\n\n#include <asm/lv1call.h>\n#include <asm/ps3stor.h>\n\n\n#define DEVICE_NAME\t\t\t\"ps3rom\"\n\n#define BOUNCE_SIZE\t\t\t(64*1024)\n\n#define PS3ROM_MAX_SECTORS\t\t(BOUNCE_SIZE >> 9)\n\n\nstruct ps3rom_private {\n\tstruct ps3_storage_device *dev;\n\tstruct scsi_cmnd *curr_cmd;\n};\n\n\n#define LV1_STORAGE_SEND_ATAPI_COMMAND\t(1)\n\nstruct lv1_atapi_cmnd_block {\n\tu8\tpkt[32];\t \n\tu32\tpktlen;\t\t \n\tu32\tblocks;\n\tu32\tblock_size;\n\tu32\tproto;\t\t \n\tu32\tin_out;\t\t \n\tu64\tbuffer;\t\t \n\tu32\targlen;\t\t \n};\n\nenum lv1_atapi_proto {\n\tNON_DATA_PROTO     = 0,\n\tPIO_DATA_IN_PROTO  = 1,\n\tPIO_DATA_OUT_PROTO = 2,\n\tDMA_PROTO = 3\n};\n\nenum lv1_atapi_in_out {\n\tDIR_WRITE = 0,\t\t \n\tDIR_READ = 1\t\t \n};\n\n\nstatic int ps3rom_slave_configure(struct scsi_device *scsi_dev)\n{\n\tstruct ps3rom_private *priv = shost_priv(scsi_dev->host);\n\tstruct ps3_storage_device *dev = priv->dev;\n\n\tdev_dbg(&dev->sbd.core, \"%s:%u: id %u, lun %llu, channel %u\\n\", __func__,\n\t\t__LINE__, scsi_dev->id, scsi_dev->lun, scsi_dev->channel);\n\n\t \n\tscsi_dev->use_10_for_ms = 1;\n\n\t \n\tscsi_dev->use_10_for_rw = 1;\n\n\treturn 0;\n}\n\nstatic int ps3rom_atapi_request(struct ps3_storage_device *dev,\n\t\t\t\tstruct scsi_cmnd *cmd)\n{\n\tstruct lv1_atapi_cmnd_block atapi_cmnd;\n\tunsigned char opcode = cmd->cmnd[0];\n\tint res;\n\tu64 lpar;\n\n\tdev_dbg(&dev->sbd.core, \"%s:%u: send ATAPI command 0x%02x\\n\", __func__,\n\t\t__LINE__, opcode);\n\n\tmemset(&atapi_cmnd, 0, sizeof(struct lv1_atapi_cmnd_block));\n\tmemcpy(&atapi_cmnd.pkt, cmd->cmnd, 12);\n\tatapi_cmnd.pktlen = 12;\n\tatapi_cmnd.block_size = 1;  \n\tatapi_cmnd.blocks = atapi_cmnd.arglen = scsi_bufflen(cmd);\n\tatapi_cmnd.buffer = dev->bounce_lpar;\n\n\tswitch (cmd->sc_data_direction) {\n\tcase DMA_FROM_DEVICE:\n\t\tif (scsi_bufflen(cmd) >= CD_FRAMESIZE)\n\t\t\tatapi_cmnd.proto = DMA_PROTO;\n\t\telse\n\t\t\tatapi_cmnd.proto = PIO_DATA_IN_PROTO;\n\t\tatapi_cmnd.in_out = DIR_READ;\n\t\tbreak;\n\n\tcase DMA_TO_DEVICE:\n\t\tif (scsi_bufflen(cmd) >= CD_FRAMESIZE)\n\t\t\tatapi_cmnd.proto = DMA_PROTO;\n\t\telse\n\t\t\tatapi_cmnd.proto = PIO_DATA_OUT_PROTO;\n\t\tatapi_cmnd.in_out = DIR_WRITE;\n\t\tscsi_sg_copy_to_buffer(cmd, dev->bounce_buf, dev->bounce_size);\n\t\tbreak;\n\n\tdefault:\n\t\tatapi_cmnd.proto = NON_DATA_PROTO;\n\t\tbreak;\n\t}\n\n\tlpar = ps3_mm_phys_to_lpar(__pa(&atapi_cmnd));\n\tres = lv1_storage_send_device_command(dev->sbd.dev_id,\n\t\t\t\t\t      LV1_STORAGE_SEND_ATAPI_COMMAND,\n\t\t\t\t\t      lpar, sizeof(atapi_cmnd),\n\t\t\t\t\t      atapi_cmnd.buffer,\n\t\t\t\t\t      atapi_cmnd.arglen, &dev->tag);\n\tif (res == LV1_DENIED_BY_POLICY) {\n\t\tdev_dbg(&dev->sbd.core,\n\t\t\t\"%s:%u: ATAPI command 0x%02x denied by policy\\n\",\n\t\t\t__func__, __LINE__, opcode);\n\t\treturn DID_ERROR << 16;\n\t}\n\n\tif (res) {\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"%s:%u: ATAPI command 0x%02x failed %d\\n\", __func__,\n\t\t\t__LINE__, opcode, res);\n\t\treturn DID_ERROR << 16;\n\t}\n\n\treturn 0;\n}\n\nstatic inline unsigned int srb10_lba(const struct scsi_cmnd *cmd)\n{\n\treturn cmd->cmnd[2] << 24 | cmd->cmnd[3] << 16 | cmd->cmnd[4] << 8 |\n\t       cmd->cmnd[5];\n}\n\nstatic inline unsigned int srb10_len(const struct scsi_cmnd *cmd)\n{\n\treturn cmd->cmnd[7] << 8 | cmd->cmnd[8];\n}\n\nstatic int ps3rom_read_request(struct ps3_storage_device *dev,\n\t\t\t       struct scsi_cmnd *cmd, u32 start_sector,\n\t\t\t       u32 sectors)\n{\n\tint res;\n\n\tdev_dbg(&dev->sbd.core, \"%s:%u: read %u sectors starting at %u\\n\",\n\t\t__func__, __LINE__, sectors, start_sector);\n\n\tres = lv1_storage_read(dev->sbd.dev_id,\n\t\t\t       dev->regions[dev->region_idx].id, start_sector,\n\t\t\t       sectors, 0, dev->bounce_lpar, &dev->tag);\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: read failed %d\\n\", __func__,\n\t\t\t__LINE__, res);\n\t\treturn DID_ERROR << 16;\n\t}\n\n\treturn 0;\n}\n\nstatic int ps3rom_write_request(struct ps3_storage_device *dev,\n\t\t\t\tstruct scsi_cmnd *cmd, u32 start_sector,\n\t\t\t\tu32 sectors)\n{\n\tint res;\n\n\tdev_dbg(&dev->sbd.core, \"%s:%u: write %u sectors starting at %u\\n\",\n\t\t__func__, __LINE__, sectors, start_sector);\n\n\tscsi_sg_copy_to_buffer(cmd, dev->bounce_buf, dev->bounce_size);\n\n\tres = lv1_storage_write(dev->sbd.dev_id,\n\t\t\t\tdev->regions[dev->region_idx].id, start_sector,\n\t\t\t\tsectors, 0, dev->bounce_lpar, &dev->tag);\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: write failed %d\\n\", __func__,\n\t\t\t__LINE__, res);\n\t\treturn DID_ERROR << 16;\n\t}\n\n\treturn 0;\n}\n\nstatic int ps3rom_queuecommand_lck(struct scsi_cmnd *cmd)\n{\n\tstruct ps3rom_private *priv = shost_priv(cmd->device->host);\n\tstruct ps3_storage_device *dev = priv->dev;\n\tunsigned char opcode;\n\tint res;\n\n\tpriv->curr_cmd = cmd;\n\n\topcode = cmd->cmnd[0];\n\t \n\tswitch (opcode) {\n\tcase READ_10:\n\t\tres = ps3rom_read_request(dev, cmd, srb10_lba(cmd),\n\t\t\t\t\t  srb10_len(cmd));\n\t\tbreak;\n\n\tcase WRITE_10:\n\t\tres = ps3rom_write_request(dev, cmd, srb10_lba(cmd),\n\t\t\t\t\t   srb10_len(cmd));\n\t\tbreak;\n\n\tdefault:\n\t\tres = ps3rom_atapi_request(dev, cmd);\n\t\tbreak;\n\t}\n\n\tif (res) {\n\t\tscsi_build_sense(cmd, 0, ILLEGAL_REQUEST, 0, 0);\n\t\tcmd->result = res;\n\t\tpriv->curr_cmd = NULL;\n\t\tscsi_done(cmd);\n\t}\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(ps3rom_queuecommand)\n\nstatic int decode_lv1_status(u64 status, unsigned char *sense_key,\n\t\t\t     unsigned char *asc, unsigned char *ascq)\n{\n\tif (((status >> 24) & 0xff) != SAM_STAT_CHECK_CONDITION)\n\t\treturn -1;\n\n\t*sense_key = (status >> 16) & 0xff;\n\t*asc       = (status >>  8) & 0xff;\n\t*ascq      =  status        & 0xff;\n\treturn 0;\n}\n\nstatic irqreturn_t ps3rom_interrupt(int irq, void *data)\n{\n\tstruct ps3_storage_device *dev = data;\n\tstruct Scsi_Host *host;\n\tstruct ps3rom_private *priv;\n\tstruct scsi_cmnd *cmd;\n\tint res;\n\tu64 tag, status;\n\tunsigned char sense_key, asc, ascq;\n\n\tres = lv1_storage_get_async_status(dev->sbd.dev_id, &tag, &status);\n\t \n\n\tif (tag != dev->tag)\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"%s:%u: tag mismatch, got %llx, expected %llx\\n\",\n\t\t\t__func__, __LINE__, tag, dev->tag);\n\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: res=%d status=0x%llx\\n\",\n\t\t\t__func__, __LINE__, res, status);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\thost = ps3_system_bus_get_drvdata(&dev->sbd);\n\tpriv = shost_priv(host);\n\tcmd = priv->curr_cmd;\n\n\tif (!status) {\n\t\t \n\t\tif (cmd->sc_data_direction == DMA_FROM_DEVICE) {\n\t\t\tint len;\n\n\t\t\tlen = scsi_sg_copy_from_buffer(cmd,\n\t\t\t\t\t\t       dev->bounce_buf,\n\t\t\t\t\t\t       dev->bounce_size);\n\n\t\t\tscsi_set_resid(cmd, scsi_bufflen(cmd) - len);\n\t\t}\n\t\tcmd->result = DID_OK << 16;\n\t\tgoto done;\n\t}\n\n\tif (cmd->cmnd[0] == REQUEST_SENSE) {\n\t\t \n\t\tdev_err(&dev->sbd.core, \"%s:%u: end error without autosense\\n\",\n\t\t\t__func__, __LINE__);\n\t\tcmd->result = DID_ERROR << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tgoto done;\n\t}\n\n\tif (decode_lv1_status(status, &sense_key, &asc, &ascq)) {\n\t\tcmd->result = DID_ERROR << 16;\n\t\tgoto done;\n\t}\n\n\tscsi_build_sense(cmd, 0, sense_key, asc, ascq);\n\ndone:\n\tpriv->curr_cmd = NULL;\n\tscsi_done(cmd);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct scsi_host_template ps3rom_host_template = {\n\t.name =\t\t\tDEVICE_NAME,\n\t.slave_configure =\tps3rom_slave_configure,\n\t.queuecommand =\t\tps3rom_queuecommand,\n\t.can_queue =\t\t1,\n\t.this_id =\t\t7,\n\t.sg_tablesize =\t\tSG_ALL,\n\t.emulated =             1,\t\t \n\t.max_sectors =\t\tPS3ROM_MAX_SECTORS,\n\t.module =\t\tTHIS_MODULE,\n};\n\n\nstatic int ps3rom_probe(struct ps3_system_bus_device *_dev)\n{\n\tstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\n\tint error;\n\tstruct Scsi_Host *host;\n\tstruct ps3rom_private *priv;\n\n\tif (dev->blk_size != CD_FRAMESIZE) {\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"%s:%u: cannot handle block size %llu\\n\", __func__,\n\t\t\t__LINE__, dev->blk_size);\n\t\treturn -EINVAL;\n\t}\n\n\tdev->bounce_size = BOUNCE_SIZE;\n\tdev->bounce_buf = kmalloc(BOUNCE_SIZE, GFP_DMA);\n\tif (!dev->bounce_buf)\n\t\treturn -ENOMEM;\n\n\terror = ps3stor_setup(dev, ps3rom_interrupt);\n\tif (error)\n\t\tgoto fail_free_bounce;\n\n\thost = scsi_host_alloc(&ps3rom_host_template,\n\t\t\t       sizeof(struct ps3rom_private));\n\tif (!host) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: scsi_host_alloc failed\\n\",\n\t\t\t__func__, __LINE__);\n\t\terror = -ENOMEM;\n\t\tgoto fail_teardown;\n\t}\n\n\tpriv = shost_priv(host);\n\tps3_system_bus_set_drvdata(&dev->sbd, host);\n\tpriv->dev = dev;\n\n\t \n\thost->max_id = 1;\n\thost->max_lun = 1;\n\n\terror = scsi_add_host(host, &dev->sbd.core);\n\tif (error) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: scsi_host_alloc failed %d\\n\",\n\t\t\t__func__, __LINE__, error);\n\t\terror = -ENODEV;\n\t\tgoto fail_host_put;\n\t}\n\n\tscsi_scan_host(host);\n\treturn 0;\n\nfail_host_put:\n\tscsi_host_put(host);\n\tps3_system_bus_set_drvdata(&dev->sbd, NULL);\nfail_teardown:\n\tps3stor_teardown(dev);\nfail_free_bounce:\n\tkfree(dev->bounce_buf);\n\treturn error;\n}\n\nstatic void ps3rom_remove(struct ps3_system_bus_device *_dev)\n{\n\tstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\n\tstruct Scsi_Host *host = ps3_system_bus_get_drvdata(&dev->sbd);\n\n\tscsi_remove_host(host);\n\tps3stor_teardown(dev);\n\tscsi_host_put(host);\n\tps3_system_bus_set_drvdata(&dev->sbd, NULL);\n\tkfree(dev->bounce_buf);\n}\n\nstatic struct ps3_system_bus_driver ps3rom = {\n\t.match_id\t= PS3_MATCH_ID_STOR_ROM,\n\t.core.name\t= DEVICE_NAME,\n\t.core.owner\t= THIS_MODULE,\n\t.probe\t\t= ps3rom_probe,\n\t.remove\t\t= ps3rom_remove\n};\n\n\nstatic int __init ps3rom_init(void)\n{\n\treturn ps3_system_bus_driver_register(&ps3rom);\n}\n\nstatic void __exit ps3rom_exit(void)\n{\n\tps3_system_bus_driver_unregister(&ps3rom);\n}\n\nmodule_init(ps3rom_init);\nmodule_exit(ps3rom_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PS3 BD/DVD/CD-ROM Storage Driver\");\nMODULE_AUTHOR(\"Sony Corporation\");\nMODULE_ALIAS(PS3_MODULE_ALIAS_STOR_ROM);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}