{
  "module_name": "bnx2i_iscsi.c",
  "hash_id": "01c8f05b4264a49476209574d72e3d0d178f8c883cff62d14027ca10ecac653b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bnx2i/bnx2i_iscsi.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/libiscsi.h>\n#include \"bnx2i.h\"\n\nstruct scsi_transport_template *bnx2i_scsi_xport_template;\nstruct iscsi_transport bnx2i_iscsi_transport;\nstatic const struct scsi_host_template bnx2i_host_template;\n\n \nstatic DEFINE_SPINLOCK(bnx2i_resc_lock);  \n\nDECLARE_PER_CPU(struct bnx2i_percpu_s, bnx2i_percpu);\n\nstatic int bnx2i_adapter_ready(struct bnx2i_hba *hba)\n{\n\tint retval = 0;\n\n\tif (!hba || !test_bit(ADAPTER_STATE_UP, &hba->adapter_state) ||\n\t    test_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state) ||\n\t    test_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state))\n\t\tretval = -EPERM;\n\treturn retval;\n}\n\n \nstatic void bnx2i_get_write_cmd_bd_idx(struct bnx2i_cmd *cmd, u32 buf_off,\n\t\t\t\t       u32 *start_bd_off, u32 *start_bd_idx)\n{\n\tstruct iscsi_bd *bd_tbl = cmd->io_tbl.bd_tbl;\n\tu32 cur_offset = 0;\n\tu32 cur_bd_idx = 0;\n\n\tif (buf_off) {\n\t\twhile (buf_off >= (cur_offset + bd_tbl->buffer_length)) {\n\t\t\tcur_offset += bd_tbl->buffer_length;\n\t\t\tcur_bd_idx++;\n\t\t\tbd_tbl++;\n\t\t}\n\t}\n\n\t*start_bd_off = buf_off - cur_offset;\n\t*start_bd_idx = cur_bd_idx;\n}\n\n \nstatic void bnx2i_setup_write_cmd_bd_info(struct iscsi_task *task)\n{\n\tstruct bnx2i_cmd *cmd = task->dd_data;\n\tu32 start_bd_offset;\n\tu32 start_bd_idx;\n\tu32 buffer_offset = 0;\n\tu32 cmd_len = cmd->req.total_data_transfer_length;\n\n\t \n\tif (!iscsi_task_has_unsol_data(task) && !task->imm_count)\n\t\treturn;\n\n\t \n\tbuffer_offset += task->imm_count;\n\tif (task->imm_count == cmd_len)\n\t\treturn;\n\n\tif (iscsi_task_has_unsol_data(task)) {\n\t\tbnx2i_get_write_cmd_bd_idx(cmd, buffer_offset,\n\t\t\t\t\t   &start_bd_offset, &start_bd_idx);\n\t\tcmd->req.ud_buffer_offset = start_bd_offset;\n\t\tcmd->req.ud_start_bd_index = start_bd_idx;\n\t\tbuffer_offset += task->unsol_r2t.data_length;\n\t}\n\n\tif (buffer_offset != cmd_len) {\n\t\tbnx2i_get_write_cmd_bd_idx(cmd, buffer_offset,\n\t\t\t\t\t   &start_bd_offset, &start_bd_idx);\n\t\tif ((start_bd_offset > task->conn->session->first_burst) ||\n\t\t    (start_bd_idx > scsi_sg_count(cmd->scsi_cmd))) {\n\t\t\tint i = 0;\n\n\t\t\tiscsi_conn_printk(KERN_ALERT, task->conn,\n\t\t\t\t\t  \"bnx2i- error, buf offset 0x%x \"\n\t\t\t\t\t  \"bd_valid %d use_sg %d\\n\",\n\t\t\t\t\t  buffer_offset, cmd->io_tbl.bd_valid,\n\t\t\t\t\t  scsi_sg_count(cmd->scsi_cmd));\n\t\t\tfor (i = 0; i < cmd->io_tbl.bd_valid; i++)\n\t\t\t\tiscsi_conn_printk(KERN_ALERT, task->conn,\n\t\t\t\t\t\t  \"bnx2i err, bd[%d]: len %x\\n\",\n\t\t\t\t\t\t  i, cmd->io_tbl.bd_tbl[i].\\\n\t\t\t\t\t\t  buffer_length);\n\t\t}\n\t\tcmd->req.sd_buffer_offset = start_bd_offset;\n\t\tcmd->req.sd_start_bd_index = start_bd_idx;\n\t}\n}\n\n\n\n \nstatic int bnx2i_map_scsi_sg(struct bnx2i_hba *hba, struct bnx2i_cmd *cmd)\n{\n\tstruct scsi_cmnd *sc = cmd->scsi_cmd;\n\tstruct iscsi_bd *bd = cmd->io_tbl.bd_tbl;\n\tstruct scatterlist *sg;\n\tint byte_count = 0;\n\tint bd_count = 0;\n\tint sg_count;\n\tint sg_len;\n\tu64 addr;\n\tint i;\n\n\tBUG_ON(scsi_sg_count(sc) > ISCSI_MAX_BDS_PER_CMD);\n\n\tsg_count = scsi_dma_map(sc);\n\n\tscsi_for_each_sg(sc, sg, sg_count, i) {\n\t\tsg_len = sg_dma_len(sg);\n\t\taddr = (u64) sg_dma_address(sg);\n\t\tbd[bd_count].buffer_addr_lo = addr & 0xffffffff;\n\t\tbd[bd_count].buffer_addr_hi = addr >> 32;\n\t\tbd[bd_count].buffer_length = sg_len;\n\t\tbd[bd_count].flags = 0;\n\t\tif (bd_count == 0)\n\t\t\tbd[bd_count].flags = ISCSI_BD_FIRST_IN_BD_CHAIN;\n\n\t\tbyte_count += sg_len;\n\t\tbd_count++;\n\t}\n\n\tif (bd_count)\n\t\tbd[bd_count - 1].flags |= ISCSI_BD_LAST_IN_BD_CHAIN;\n\n\tBUG_ON(byte_count != scsi_bufflen(sc));\n\treturn bd_count;\n}\n\n \nstatic void bnx2i_iscsi_map_sg_list(struct bnx2i_cmd *cmd)\n{\n\tint bd_count;\n\n\tbd_count  = bnx2i_map_scsi_sg(cmd->conn->hba, cmd);\n\tif (!bd_count) {\n\t\tstruct iscsi_bd *bd = cmd->io_tbl.bd_tbl;\n\n\t\tbd[0].buffer_addr_lo = bd[0].buffer_addr_hi = 0;\n\t\tbd[0].buffer_length = bd[0].flags = 0;\n\t}\n\tcmd->io_tbl.bd_valid = bd_count;\n}\n\n\n \nvoid bnx2i_iscsi_unmap_sg_list(struct bnx2i_cmd *cmd)\n{\n\tstruct scsi_cmnd *sc = cmd->scsi_cmd;\n\n\tif (cmd->io_tbl.bd_valid && sc) {\n\t\tscsi_dma_unmap(sc);\n\t\tcmd->io_tbl.bd_valid = 0;\n\t}\n}\n\nstatic void bnx2i_setup_cmd_wqe_template(struct bnx2i_cmd *cmd)\n{\n\tmemset(&cmd->req, 0x00, sizeof(cmd->req));\n\tcmd->req.op_code = 0xFF;\n\tcmd->req.bd_list_addr_lo = (u32) cmd->io_tbl.bd_tbl_dma;\n\tcmd->req.bd_list_addr_hi =\n\t\t(u32) ((u64) cmd->io_tbl.bd_tbl_dma >> 32);\n\n}\n\n\n \nstatic int bnx2i_bind_conn_to_iscsi_cid(struct bnx2i_hba *hba,\n\t\t\t\t\tstruct bnx2i_conn *bnx2i_conn,\n\t\t\t\t\tu32 iscsi_cid)\n{\n\tif (hba && hba->cid_que.conn_cid_tbl[iscsi_cid]) {\n\t\tiscsi_conn_printk(KERN_ALERT, bnx2i_conn->cls_conn->dd_data,\n\t\t\t\t \"conn bind - entry #%d not free\\n\", iscsi_cid);\n\t\treturn -EBUSY;\n\t}\n\n\thba->cid_que.conn_cid_tbl[iscsi_cid] = bnx2i_conn;\n\treturn 0;\n}\n\n\n \nstruct bnx2i_conn *bnx2i_get_conn_from_id(struct bnx2i_hba *hba,\n\t\t\t\t\t  u16 iscsi_cid)\n{\n\tif (!hba->cid_que.conn_cid_tbl) {\n\t\tprintk(KERN_ERR \"bnx2i: ERROR - missing conn<->cid table\\n\");\n\t\treturn NULL;\n\n\t} else if (iscsi_cid >= hba->max_active_conns) {\n\t\tprintk(KERN_ERR \"bnx2i: wrong cid #%d\\n\", iscsi_cid);\n\t\treturn NULL;\n\t}\n\treturn hba->cid_que.conn_cid_tbl[iscsi_cid];\n}\n\n\n \nstatic u32 bnx2i_alloc_iscsi_cid(struct bnx2i_hba *hba)\n{\n\tint idx;\n\n\tif (!hba->cid_que.cid_free_cnt)\n\t\treturn -1;\n\n\tidx = hba->cid_que.cid_q_cons_idx;\n\thba->cid_que.cid_q_cons_idx++;\n\tif (hba->cid_que.cid_q_cons_idx == hba->cid_que.cid_q_max_idx)\n\t\thba->cid_que.cid_q_cons_idx = 0;\n\n\thba->cid_que.cid_free_cnt--;\n\treturn hba->cid_que.cid_que[idx];\n}\n\n\n \nstatic void bnx2i_free_iscsi_cid(struct bnx2i_hba *hba, u16 iscsi_cid)\n{\n\tint idx;\n\n\tif (iscsi_cid == (u16) -1)\n\t\treturn;\n\n\thba->cid_que.cid_free_cnt++;\n\n\tidx = hba->cid_que.cid_q_prod_idx;\n\thba->cid_que.cid_que[idx] = iscsi_cid;\n\thba->cid_que.conn_cid_tbl[iscsi_cid] = NULL;\n\thba->cid_que.cid_q_prod_idx++;\n\tif (hba->cid_que.cid_q_prod_idx == hba->cid_que.cid_q_max_idx)\n\t\thba->cid_que.cid_q_prod_idx = 0;\n}\n\n\n \nstatic int bnx2i_setup_free_cid_que(struct bnx2i_hba *hba)\n{\n\tint mem_size;\n\tint i;\n\n\tmem_size = hba->max_active_conns * sizeof(u32);\n\tmem_size = (mem_size + (PAGE_SIZE - 1)) & PAGE_MASK;\n\n\thba->cid_que.cid_que_base = kmalloc(mem_size, GFP_KERNEL);\n\tif (!hba->cid_que.cid_que_base)\n\t\treturn -ENOMEM;\n\n\tmem_size = hba->max_active_conns * sizeof(struct bnx2i_conn *);\n\tmem_size = (mem_size + (PAGE_SIZE - 1)) & PAGE_MASK;\n\thba->cid_que.conn_cid_tbl = kmalloc(mem_size, GFP_KERNEL);\n\tif (!hba->cid_que.conn_cid_tbl) {\n\t\tkfree(hba->cid_que.cid_que_base);\n\t\thba->cid_que.cid_que_base = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\thba->cid_que.cid_que = (u32 *)hba->cid_que.cid_que_base;\n\thba->cid_que.cid_q_prod_idx = 0;\n\thba->cid_que.cid_q_cons_idx = 0;\n\thba->cid_que.cid_q_max_idx = hba->max_active_conns;\n\thba->cid_que.cid_free_cnt = hba->max_active_conns;\n\n\tfor (i = 0; i < hba->max_active_conns; i++) {\n\t\thba->cid_que.cid_que[i] = i;\n\t\thba->cid_que.conn_cid_tbl[i] = NULL;\n\t}\n\treturn 0;\n}\n\n\n \nstatic void bnx2i_release_free_cid_que(struct bnx2i_hba *hba)\n{\n\tkfree(hba->cid_que.cid_que_base);\n\thba->cid_que.cid_que_base = NULL;\n\n\tkfree(hba->cid_que.conn_cid_tbl);\n\thba->cid_que.conn_cid_tbl = NULL;\n}\n\n\n \nstatic struct iscsi_endpoint *bnx2i_alloc_ep(struct bnx2i_hba *hba)\n{\n\tstruct iscsi_endpoint *ep;\n\tstruct bnx2i_endpoint *bnx2i_ep;\n\tu32 ec_div;\n\n\tep = iscsi_create_endpoint(sizeof(*bnx2i_ep));\n\tif (!ep) {\n\t\tprintk(KERN_ERR \"bnx2i: Could not allocate ep\\n\");\n\t\treturn NULL;\n\t}\n\n\tbnx2i_ep = ep->dd_data;\n\tbnx2i_ep->cls_ep = ep;\n\tINIT_LIST_HEAD(&bnx2i_ep->link);\n\tbnx2i_ep->state = EP_STATE_IDLE;\n\tbnx2i_ep->ep_iscsi_cid = (u16) -1;\n\tbnx2i_ep->hba = hba;\n\tbnx2i_ep->hba_age = hba->age;\n\n\tec_div = event_coal_div;\n\twhile (ec_div >>= 1)\n\t\tbnx2i_ep->ec_shift += 1;\n\n\thba->ofld_conns_active++;\n\tinit_waitqueue_head(&bnx2i_ep->ofld_wait);\n\treturn ep;\n}\n\n\n \nstatic void bnx2i_free_ep(struct iscsi_endpoint *ep)\n{\n\tstruct bnx2i_endpoint *bnx2i_ep = ep->dd_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bnx2i_resc_lock, flags);\n\tbnx2i_ep->state = EP_STATE_IDLE;\n\tbnx2i_ep->hba->ofld_conns_active--;\n\n\tif (bnx2i_ep->ep_iscsi_cid != (u16) -1)\n\t\tbnx2i_free_iscsi_cid(bnx2i_ep->hba, bnx2i_ep->ep_iscsi_cid);\n\n\tif (bnx2i_ep->conn) {\n\t\tbnx2i_ep->conn->ep = NULL;\n\t\tbnx2i_ep->conn = NULL;\n\t}\n\n\tbnx2i_ep->hba = NULL;\n\tspin_unlock_irqrestore(&bnx2i_resc_lock, flags);\n\tiscsi_destroy_endpoint(ep);\n}\n\n\n \nstatic int bnx2i_alloc_bdt(struct bnx2i_hba *hba, struct iscsi_session *session,\n\t\t\t   struct bnx2i_cmd *cmd)\n{\n\tstruct io_bdt *io = &cmd->io_tbl;\n\tstruct iscsi_bd *bd;\n\n\tio->bd_tbl = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t\tISCSI_MAX_BDS_PER_CMD * sizeof(*bd),\n\t\t\t\t\t&io->bd_tbl_dma, GFP_KERNEL);\n\tif (!io->bd_tbl) {\n\t\tiscsi_session_printk(KERN_ERR, session, \"Could not \"\n\t\t\t\t     \"allocate bdt.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tio->bd_valid = 0;\n\treturn 0;\n}\n\n \nstatic void bnx2i_destroy_cmd_pool(struct bnx2i_hba *hba,\n\t\t\t\t   struct iscsi_session *session)\n{\n\tint i;\n\n\tfor (i = 0; i < session->cmds_max; i++) {\n\t\tstruct iscsi_task *task = session->cmds[i];\n\t\tstruct bnx2i_cmd *cmd = task->dd_data;\n\n\t\tif (cmd->io_tbl.bd_tbl)\n\t\t\tdma_free_coherent(&hba->pcidev->dev,\n\t\t\t\t\t  ISCSI_MAX_BDS_PER_CMD *\n\t\t\t\t\t  sizeof(struct iscsi_bd),\n\t\t\t\t\t  cmd->io_tbl.bd_tbl,\n\t\t\t\t\t  cmd->io_tbl.bd_tbl_dma);\n\t}\n\n}\n\n\n \nstatic int bnx2i_setup_cmd_pool(struct bnx2i_hba *hba,\n\t\t\t\tstruct iscsi_session *session)\n{\n\tint i;\n\n\tfor (i = 0; i < session->cmds_max; i++) {\n\t\tstruct iscsi_task *task = session->cmds[i];\n\t\tstruct bnx2i_cmd *cmd = task->dd_data;\n\n\t\ttask->hdr = &cmd->hdr;\n\t\ttask->hdr_max = sizeof(struct iscsi_hdr);\n\n\t\tif (bnx2i_alloc_bdt(hba, session, cmd))\n\t\t\tgoto free_bdts;\n\t}\n\n\treturn 0;\n\nfree_bdts:\n\tbnx2i_destroy_cmd_pool(hba, session);\n\treturn -ENOMEM;\n}\n\n\n \nstatic int bnx2i_setup_mp_bdt(struct bnx2i_hba *hba)\n{\n\tint rc = 0;\n\tstruct iscsi_bd *mp_bdt;\n\tu64 addr;\n\n\thba->mp_bd_tbl = dma_alloc_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t\t    &hba->mp_bd_dma, GFP_KERNEL);\n\tif (!hba->mp_bd_tbl) {\n\t\tprintk(KERN_ERR \"unable to allocate Middle Path BDT\\n\");\n\t\trc = -1;\n\t\tgoto out;\n\t}\n\n\thba->dummy_buffer = dma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t\t       CNIC_PAGE_SIZE,\n\t\t\t\t\t       &hba->dummy_buf_dma, GFP_KERNEL);\n\tif (!hba->dummy_buffer) {\n\t\tprintk(KERN_ERR \"unable to alloc Middle Path Dummy Buffer\\n\");\n\t\tdma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t  hba->mp_bd_tbl, hba->mp_bd_dma);\n\t\thba->mp_bd_tbl = NULL;\n\t\trc = -1;\n\t\tgoto out;\n\t}\n\n\tmp_bdt = (struct iscsi_bd *) hba->mp_bd_tbl;\n\taddr = (unsigned long) hba->dummy_buf_dma;\n\tmp_bdt->buffer_addr_lo = addr & 0xffffffff;\n\tmp_bdt->buffer_addr_hi = addr >> 32;\n\tmp_bdt->buffer_length = CNIC_PAGE_SIZE;\n\tmp_bdt->flags = ISCSI_BD_LAST_IN_BD_CHAIN |\n\t\t\tISCSI_BD_FIRST_IN_BD_CHAIN;\nout:\n\treturn rc;\n}\n\n\n \nstatic void bnx2i_free_mp_bdt(struct bnx2i_hba *hba)\n{\n\tif (hba->mp_bd_tbl) {\n\t\tdma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t  hba->mp_bd_tbl, hba->mp_bd_dma);\n\t\thba->mp_bd_tbl = NULL;\n\t}\n\tif (hba->dummy_buffer) {\n\t\tdma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t  hba->dummy_buffer, hba->dummy_buf_dma);\n\t\thba->dummy_buffer = NULL;\n\t}\n\treturn;\n}\n\n \nvoid bnx2i_drop_session(struct iscsi_cls_session *cls_session)\n{\n\tiscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);\n}\n\n \nstatic int bnx2i_ep_destroy_list_add(struct bnx2i_hba *hba,\n\t\t\t\t     struct bnx2i_endpoint *ep)\n{\n\twrite_lock_bh(&hba->ep_rdwr_lock);\n\tlist_add_tail(&ep->link, &hba->ep_destroy_list);\n\twrite_unlock_bh(&hba->ep_rdwr_lock);\n\treturn 0;\n}\n\n \nstatic int bnx2i_ep_destroy_list_del(struct bnx2i_hba *hba,\n\t\t\t\t     struct bnx2i_endpoint *ep)\n{\n\twrite_lock_bh(&hba->ep_rdwr_lock);\n\tlist_del_init(&ep->link);\n\twrite_unlock_bh(&hba->ep_rdwr_lock);\n\n\treturn 0;\n}\n\n \nstatic int bnx2i_ep_ofld_list_add(struct bnx2i_hba *hba,\n\t\t\t\t  struct bnx2i_endpoint *ep)\n{\n\twrite_lock_bh(&hba->ep_rdwr_lock);\n\tlist_add_tail(&ep->link, &hba->ep_ofld_list);\n\twrite_unlock_bh(&hba->ep_rdwr_lock);\n\treturn 0;\n}\n\n \nstatic int bnx2i_ep_ofld_list_del(struct bnx2i_hba *hba,\n\t\t\t\t  struct bnx2i_endpoint *ep)\n{\n\twrite_lock_bh(&hba->ep_rdwr_lock);\n\tlist_del_init(&ep->link);\n\twrite_unlock_bh(&hba->ep_rdwr_lock);\n\treturn 0;\n}\n\n\n \nstruct bnx2i_endpoint *\nbnx2i_find_ep_in_ofld_list(struct bnx2i_hba *hba, u32 iscsi_cid)\n{\n\tstruct list_head *list;\n\tstruct list_head *tmp;\n\tstruct bnx2i_endpoint *ep = NULL;\n\n\tread_lock_bh(&hba->ep_rdwr_lock);\n\tlist_for_each_safe(list, tmp, &hba->ep_ofld_list) {\n\t\tep = (struct bnx2i_endpoint *)list;\n\n\t\tif (ep->ep_iscsi_cid == iscsi_cid)\n\t\t\tbreak;\n\t\tep = NULL;\n\t}\n\tread_unlock_bh(&hba->ep_rdwr_lock);\n\n\tif (!ep)\n\t\tprintk(KERN_ERR \"l5 cid %d not found\\n\", iscsi_cid);\n\treturn ep;\n}\n\n \nstruct bnx2i_endpoint *\nbnx2i_find_ep_in_destroy_list(struct bnx2i_hba *hba, u32 iscsi_cid)\n{\n\tstruct list_head *list;\n\tstruct list_head *tmp;\n\tstruct bnx2i_endpoint *ep = NULL;\n\n\tread_lock_bh(&hba->ep_rdwr_lock);\n\tlist_for_each_safe(list, tmp, &hba->ep_destroy_list) {\n\t\tep = (struct bnx2i_endpoint *)list;\n\n\t\tif (ep->ep_iscsi_cid == iscsi_cid)\n\t\t\tbreak;\n\t\tep = NULL;\n\t}\n\tread_unlock_bh(&hba->ep_rdwr_lock);\n\n\tif (!ep)\n\t\tprintk(KERN_ERR \"l5 cid %d not found\\n\", iscsi_cid);\n\n\treturn ep;\n}\n\n \nstatic void bnx2i_ep_active_list_add(struct bnx2i_hba *hba,\n\t\t\t\t     struct bnx2i_endpoint *ep)\n{\n\twrite_lock_bh(&hba->ep_rdwr_lock);\n\tlist_add_tail(&ep->link, &hba->ep_active_list);\n\twrite_unlock_bh(&hba->ep_rdwr_lock);\n}\n\n\n \nstatic void bnx2i_ep_active_list_del(struct bnx2i_hba *hba,\n\t\t\t\t     struct bnx2i_endpoint *ep)\n{\n\twrite_lock_bh(&hba->ep_rdwr_lock);\n\tlist_del_init(&ep->link);\n\twrite_unlock_bh(&hba->ep_rdwr_lock);\n}\n\n\n \nstatic void bnx2i_setup_host_queue_size(struct bnx2i_hba *hba,\n\t\t\t\t\tstruct Scsi_Host *shost)\n{\n\tif (test_bit(BNX2I_NX2_DEV_5708, &hba->cnic_dev_type))\n\t\tshost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5708;\n\telse if (test_bit(BNX2I_NX2_DEV_5709, &hba->cnic_dev_type))\n\t\tshost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5709;\n\telse if (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type))\n\t\tshost->can_queue = ISCSI_MAX_CMDS_PER_HBA_57710;\n\telse\n\t\tshost->can_queue = ISCSI_MAX_CMDS_PER_HBA_5708;\n}\n\n\n \nstruct bnx2i_hba *bnx2i_alloc_hba(struct cnic_dev *cnic)\n{\n\tstruct Scsi_Host *shost;\n\tstruct bnx2i_hba *hba;\n\n\tshost = iscsi_host_alloc(&bnx2i_host_template, sizeof(*hba), 0);\n\tif (!shost)\n\t\treturn NULL;\n\tshost->dma_boundary = cnic->pcidev->dma_mask;\n\tshost->transportt = bnx2i_scsi_xport_template;\n\tshost->max_id = ISCSI_MAX_CONNS_PER_HBA - 1;\n\tshost->max_channel = 0;\n\tshost->max_lun = 512;\n\tshost->max_cmd_len = 16;\n\n\thba = iscsi_host_priv(shost);\n\thba->shost = shost;\n\thba->netdev = cnic->netdev;\n\t \n\thba->pcidev = cnic->pcidev;\n\tpci_dev_get(hba->pcidev);\n\thba->pci_did = hba->pcidev->device;\n\thba->pci_vid = hba->pcidev->vendor;\n\thba->pci_sdid = hba->pcidev->subsystem_device;\n\thba->pci_svid = hba->pcidev->subsystem_vendor;\n\thba->pci_func = PCI_FUNC(hba->pcidev->devfn);\n\thba->pci_devno = PCI_SLOT(hba->pcidev->devfn);\n\n\tbnx2i_identify_device(hba, cnic);\n\tbnx2i_setup_host_queue_size(hba, shost);\n\n\thba->reg_base = pci_resource_start(hba->pcidev, 0);\n\tif (test_bit(BNX2I_NX2_DEV_5709, &hba->cnic_dev_type)) {\n\t\thba->regview = pci_iomap(hba->pcidev, 0, BNX2_MQ_CONFIG2);\n\t\tif (!hba->regview)\n\t\t\tgoto ioreg_map_err;\n\t} else if (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type)) {\n\t\thba->regview = pci_iomap(hba->pcidev, 0, 4096);\n\t\tif (!hba->regview)\n\t\t\tgoto ioreg_map_err;\n\t}\n\n\tif (bnx2i_setup_mp_bdt(hba))\n\t\tgoto mp_bdt_mem_err;\n\n\tINIT_LIST_HEAD(&hba->ep_ofld_list);\n\tINIT_LIST_HEAD(&hba->ep_active_list);\n\tINIT_LIST_HEAD(&hba->ep_destroy_list);\n\trwlock_init(&hba->ep_rdwr_lock);\n\n\thba->mtu_supported = BNX2I_MAX_MTU_SUPPORTED;\n\n\t \n\thba->max_active_conns = ISCSI_MAX_CONNS_PER_HBA;\n\n\tif (bnx2i_setup_free_cid_que(hba))\n\t\tgoto cid_que_err;\n\n\t \n\tif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type)) {\n\t\tif (sq_size && sq_size <= BNX2I_5770X_SQ_WQES_MAX)\n\t\t\thba->max_sqes = sq_size;\n\t\telse\n\t\t\thba->max_sqes = BNX2I_5770X_SQ_WQES_DEFAULT;\n\t} else {\t \n\t\tif (sq_size && sq_size <= BNX2I_570X_SQ_WQES_MAX)\n\t\t\thba->max_sqes = sq_size;\n\t\telse\n\t\t\thba->max_sqes = BNX2I_570X_SQ_WQES_DEFAULT;\n\t}\n\n\thba->max_rqes = rq_size;\n\thba->max_cqes = hba->max_sqes + rq_size;\n\tif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type)) {\n\t\tif (hba->max_cqes > BNX2I_5770X_CQ_WQES_MAX)\n\t\t\thba->max_cqes = BNX2I_5770X_CQ_WQES_MAX;\n\t} else if (hba->max_cqes > BNX2I_570X_CQ_WQES_MAX)\n\t\thba->max_cqes = BNX2I_570X_CQ_WQES_MAX;\n\n\thba->num_ccell = hba->max_sqes / 2;\n\n\tspin_lock_init(&hba->lock);\n\tmutex_init(&hba->net_dev_lock);\n\tinit_waitqueue_head(&hba->eh_wait);\n\tif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type)) {\n\t\thba->hba_shutdown_tmo = 30 * HZ;\n\t\thba->conn_teardown_tmo = 20 * HZ;\n\t\thba->conn_ctx_destroy_tmo = 6 * HZ;\n\t} else {\t \n\t\thba->hba_shutdown_tmo = 20 * HZ;\n\t\thba->conn_teardown_tmo = 10 * HZ;\n\t\thba->conn_ctx_destroy_tmo = 2 * HZ;\n\t}\n\n#ifdef CONFIG_32BIT\n\tspin_lock_init(&hba->stat_lock);\n#endif\n\tmemset(&hba->stats, 0, sizeof(struct iscsi_stats_info));\n\n\tif (iscsi_host_add(shost, &hba->pcidev->dev))\n\t\tgoto free_dump_mem;\n\treturn hba;\n\nfree_dump_mem:\n\tbnx2i_release_free_cid_que(hba);\ncid_que_err:\n\tbnx2i_free_mp_bdt(hba);\nmp_bdt_mem_err:\n\tif (hba->regview) {\n\t\tpci_iounmap(hba->pcidev, hba->regview);\n\t\thba->regview = NULL;\n\t}\nioreg_map_err:\n\tpci_dev_put(hba->pcidev);\n\tscsi_host_put(shost);\n\treturn NULL;\n}\n\n \nvoid bnx2i_free_hba(struct bnx2i_hba *hba)\n{\n\tstruct Scsi_Host *shost = hba->shost;\n\n\tiscsi_host_remove(shost, false);\n\tINIT_LIST_HEAD(&hba->ep_ofld_list);\n\tINIT_LIST_HEAD(&hba->ep_active_list);\n\tINIT_LIST_HEAD(&hba->ep_destroy_list);\n\n\tif (hba->regview) {\n\t\tpci_iounmap(hba->pcidev, hba->regview);\n\t\thba->regview = NULL;\n\t}\n\tpci_dev_put(hba->pcidev);\n\tbnx2i_free_mp_bdt(hba);\n\tbnx2i_release_free_cid_que(hba);\n\tiscsi_host_free(shost);\n}\n\n \nstatic void bnx2i_conn_free_login_resources(struct bnx2i_hba *hba,\n\t\t\t\t\t    struct bnx2i_conn *bnx2i_conn)\n{\n\tif (bnx2i_conn->gen_pdu.resp_bd_tbl) {\n\t\tdma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t  bnx2i_conn->gen_pdu.resp_bd_tbl,\n\t\t\t\t  bnx2i_conn->gen_pdu.resp_bd_dma);\n\t\tbnx2i_conn->gen_pdu.resp_bd_tbl = NULL;\n\t}\n\n\tif (bnx2i_conn->gen_pdu.req_bd_tbl) {\n\t\tdma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t  bnx2i_conn->gen_pdu.req_bd_tbl,\n\t\t\t\t  bnx2i_conn->gen_pdu.req_bd_dma);\n\t\tbnx2i_conn->gen_pdu.req_bd_tbl = NULL;\n\t}\n\n\tif (bnx2i_conn->gen_pdu.resp_buf) {\n\t\tdma_free_coherent(&hba->pcidev->dev,\n\t\t\t\t  ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t  bnx2i_conn->gen_pdu.resp_buf,\n\t\t\t\t  bnx2i_conn->gen_pdu.resp_dma_addr);\n\t\tbnx2i_conn->gen_pdu.resp_buf = NULL;\n\t}\n\n\tif (bnx2i_conn->gen_pdu.req_buf) {\n\t\tdma_free_coherent(&hba->pcidev->dev,\n\t\t\t\t  ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t  bnx2i_conn->gen_pdu.req_buf,\n\t\t\t\t  bnx2i_conn->gen_pdu.req_dma_addr);\n\t\tbnx2i_conn->gen_pdu.req_buf = NULL;\n\t}\n}\n\n \nstatic int bnx2i_conn_alloc_login_resources(struct bnx2i_hba *hba,\n\t\t\t\t\t    struct bnx2i_conn *bnx2i_conn)\n{\n\t \n\tbnx2i_conn->gen_pdu.req_buf =\n\t\tdma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t   ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t   &bnx2i_conn->gen_pdu.req_dma_addr,\n\t\t\t\t   GFP_KERNEL);\n\tif (bnx2i_conn->gen_pdu.req_buf == NULL)\n\t\tgoto login_req_buf_failure;\n\n\tbnx2i_conn->gen_pdu.req_buf_size = 0;\n\tbnx2i_conn->gen_pdu.req_wr_ptr = bnx2i_conn->gen_pdu.req_buf;\n\n\tbnx2i_conn->gen_pdu.resp_buf =\n\t\tdma_alloc_coherent(&hba->pcidev->dev,\n\t\t\t\t   ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t   &bnx2i_conn->gen_pdu.resp_dma_addr,\n\t\t\t\t   GFP_KERNEL);\n\tif (bnx2i_conn->gen_pdu.resp_buf == NULL)\n\t\tgoto login_resp_buf_failure;\n\n\tbnx2i_conn->gen_pdu.resp_buf_size = ISCSI_DEF_MAX_RECV_SEG_LEN;\n\tbnx2i_conn->gen_pdu.resp_wr_ptr = bnx2i_conn->gen_pdu.resp_buf;\n\n\tbnx2i_conn->gen_pdu.req_bd_tbl =\n\t\tdma_alloc_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t   &bnx2i_conn->gen_pdu.req_bd_dma, GFP_KERNEL);\n\tif (bnx2i_conn->gen_pdu.req_bd_tbl == NULL)\n\t\tgoto login_req_bd_tbl_failure;\n\n\tbnx2i_conn->gen_pdu.resp_bd_tbl =\n\t\tdma_alloc_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t\t   &bnx2i_conn->gen_pdu.resp_bd_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (bnx2i_conn->gen_pdu.resp_bd_tbl == NULL)\n\t\tgoto login_resp_bd_tbl_failure;\n\n\treturn 0;\n\nlogin_resp_bd_tbl_failure:\n\tdma_free_coherent(&hba->pcidev->dev, CNIC_PAGE_SIZE,\n\t\t\t  bnx2i_conn->gen_pdu.req_bd_tbl,\n\t\t\t  bnx2i_conn->gen_pdu.req_bd_dma);\n\tbnx2i_conn->gen_pdu.req_bd_tbl = NULL;\n\nlogin_req_bd_tbl_failure:\n\tdma_free_coherent(&hba->pcidev->dev, ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t  bnx2i_conn->gen_pdu.resp_buf,\n\t\t\t  bnx2i_conn->gen_pdu.resp_dma_addr);\n\tbnx2i_conn->gen_pdu.resp_buf = NULL;\nlogin_resp_buf_failure:\n\tdma_free_coherent(&hba->pcidev->dev, ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t  bnx2i_conn->gen_pdu.req_buf,\n\t\t\t  bnx2i_conn->gen_pdu.req_dma_addr);\n\tbnx2i_conn->gen_pdu.req_buf = NULL;\nlogin_req_buf_failure:\n\tiscsi_conn_printk(KERN_ERR, bnx2i_conn->cls_conn->dd_data,\n\t\t\t  \"login resource alloc failed!!\\n\");\n\treturn -ENOMEM;\n\n}\n\n\n \nstatic void bnx2i_iscsi_prep_generic_pdu_bd(struct bnx2i_conn *bnx2i_conn)\n{\n\tstruct iscsi_bd *bd_tbl;\n\n\tbd_tbl = (struct iscsi_bd *) bnx2i_conn->gen_pdu.req_bd_tbl;\n\n\tbd_tbl->buffer_addr_hi =\n\t\t(u32) ((u64) bnx2i_conn->gen_pdu.req_dma_addr >> 32);\n\tbd_tbl->buffer_addr_lo = (u32) bnx2i_conn->gen_pdu.req_dma_addr;\n\tbd_tbl->buffer_length = bnx2i_conn->gen_pdu.req_wr_ptr -\n\t\t\t\tbnx2i_conn->gen_pdu.req_buf;\n\tbd_tbl->reserved0 = 0;\n\tbd_tbl->flags = ISCSI_BD_LAST_IN_BD_CHAIN |\n\t\t\tISCSI_BD_FIRST_IN_BD_CHAIN;\n\n\tbd_tbl = (struct iscsi_bd  *) bnx2i_conn->gen_pdu.resp_bd_tbl;\n\tbd_tbl->buffer_addr_hi = (u64) bnx2i_conn->gen_pdu.resp_dma_addr >> 32;\n\tbd_tbl->buffer_addr_lo = (u32) bnx2i_conn->gen_pdu.resp_dma_addr;\n\tbd_tbl->buffer_length = ISCSI_DEF_MAX_RECV_SEG_LEN;\n\tbd_tbl->reserved0 = 0;\n\tbd_tbl->flags = ISCSI_BD_LAST_IN_BD_CHAIN |\n\t\t\tISCSI_BD_FIRST_IN_BD_CHAIN;\n}\n\n\n \nstatic int bnx2i_iscsi_send_generic_request(struct iscsi_task *task)\n{\n\tstruct bnx2i_cmd *cmd = task->dd_data;\n\tstruct bnx2i_conn *bnx2i_conn = cmd->conn;\n\tint rc = 0;\n\tchar *buf;\n\tint data_len;\n\n\tbnx2i_iscsi_prep_generic_pdu_bd(bnx2i_conn);\n\tswitch (task->hdr->opcode & ISCSI_OPCODE_MASK) {\n\tcase ISCSI_OP_LOGIN:\n\t\tbnx2i_send_iscsi_login(bnx2i_conn, task);\n\t\tbreak;\n\tcase ISCSI_OP_NOOP_OUT:\n\t\tdata_len = bnx2i_conn->gen_pdu.req_buf_size;\n\t\tbuf = bnx2i_conn->gen_pdu.req_buf;\n\t\tif (data_len)\n\t\t\trc = bnx2i_send_iscsi_nopout(bnx2i_conn, task,\n\t\t\t\t\t\t     buf, data_len, 1);\n\t\telse\n\t\t\trc = bnx2i_send_iscsi_nopout(bnx2i_conn, task,\n\t\t\t\t\t\t     NULL, 0, 1);\n\t\tbreak;\n\tcase ISCSI_OP_LOGOUT:\n\t\trc = bnx2i_send_iscsi_logout(bnx2i_conn, task);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_TMFUNC:\n\t\trc = bnx2i_send_iscsi_tmf(bnx2i_conn, task);\n\t\tbreak;\n\tcase ISCSI_OP_TEXT:\n\t\trc = bnx2i_send_iscsi_text(bnx2i_conn, task);\n\t\tbreak;\n\tdefault:\n\t\tiscsi_conn_printk(KERN_ALERT, bnx2i_conn->cls_conn->dd_data,\n\t\t\t\t  \"send_gen: unsupported op 0x%x\\n\",\n\t\t\t\t  task->hdr->opcode);\n\t}\n\treturn rc;\n}\n\n\n \n\n \nstatic void bnx2i_cpy_scsi_cdb(struct scsi_cmnd *sc, struct bnx2i_cmd *cmd)\n{\n\tu32 dword;\n\tint lpcnt;\n\tu8 *srcp;\n\tu32 *dstp;\n\tu32 scsi_lun[2];\n\n\tint_to_scsilun(sc->device->lun, (struct scsi_lun *) scsi_lun);\n\tcmd->req.lun[0] = be32_to_cpu(scsi_lun[0]);\n\tcmd->req.lun[1] = be32_to_cpu(scsi_lun[1]);\n\n\tlpcnt = cmd->scsi_cmd->cmd_len / sizeof(dword);\n\tsrcp = (u8 *) sc->cmnd;\n\tdstp = (u32 *) cmd->req.cdb;\n\twhile (lpcnt--) {\n\t\tmemcpy(&dword, (const void *) srcp, 4);\n\t\t*dstp = cpu_to_be32(dword);\n\t\tsrcp += 4;\n\t\tdstp++;\n\t}\n\tif (sc->cmd_len & 0x3) {\n\t\tdword = (u32) srcp[0] | ((u32) srcp[1] << 8);\n\t\t*dstp = cpu_to_be32(dword);\n\t}\n}\n\nstatic void bnx2i_cleanup_task(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\n\tstruct bnx2i_hba *hba = bnx2i_conn->hba;\n\n\t \n\tif (!task->sc || task->state == ISCSI_TASK_PENDING)\n\t\treturn;\n\t \n\tif (task->state == ISCSI_TASK_ABRT_TMF) {\n\t\tbnx2i_send_cmd_cleanup_req(hba, task->dd_data);\n\n\t\tspin_unlock_bh(&conn->session->back_lock);\n\t\twait_for_completion_timeout(&bnx2i_conn->cmd_cleanup_cmpl,\n\t\t\t\tmsecs_to_jiffies(ISCSI_CMD_CLEANUP_TIMEOUT));\n\t\tspin_lock_bh(&conn->session->back_lock);\n\t}\n\tbnx2i_iscsi_unmap_sg_list(task->dd_data);\n}\n\n \nstatic int\nbnx2i_mtask_xmit(struct iscsi_conn *conn, struct iscsi_task *task)\n{\n\tstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\n\tstruct bnx2i_hba *hba = bnx2i_conn->hba;\n\tstruct bnx2i_cmd *cmd = task->dd_data;\n\n\tmemset(bnx2i_conn->gen_pdu.req_buf, 0, ISCSI_DEF_MAX_RECV_SEG_LEN);\n\n\tbnx2i_setup_cmd_wqe_template(cmd);\n\tbnx2i_conn->gen_pdu.req_buf_size = task->data_count;\n\n\t \n\tADD_STATS_64(hba, tx_pdus, 1);\n\tADD_STATS_64(hba, tx_bytes, task->data_count);\n\n\tif (task->data_count) {\n\t\tmemcpy(bnx2i_conn->gen_pdu.req_buf, task->data,\n\t\t       task->data_count);\n\t\tbnx2i_conn->gen_pdu.req_wr_ptr =\n\t\t\tbnx2i_conn->gen_pdu.req_buf + task->data_count;\n\t}\n\tcmd->conn = conn->dd_data;\n\tcmd->scsi_cmd = NULL;\n\treturn bnx2i_iscsi_send_generic_request(task);\n}\n\n \nstatic int bnx2i_task_xmit(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_session *session = conn->session;\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(session->cls_session);\n\tstruct bnx2i_hba *hba = iscsi_host_priv(shost);\n\tstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct bnx2i_cmd *cmd = task->dd_data;\n\tstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)task->hdr;\n\n\tif (atomic_read(&bnx2i_conn->ep->num_active_cmds) + 1  >\n\t    hba->max_sqes)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!sc)\n\t\treturn bnx2i_mtask_xmit(conn, task);\n\n\tbnx2i_setup_cmd_wqe_template(cmd);\n\tcmd->req.op_code = ISCSI_OP_SCSI_CMD;\n\tcmd->conn = bnx2i_conn;\n\tcmd->scsi_cmd = sc;\n\tcmd->req.total_data_transfer_length = scsi_bufflen(sc);\n\tcmd->req.cmd_sn = be32_to_cpu(hdr->cmdsn);\n\n\tbnx2i_iscsi_map_sg_list(cmd);\n\tbnx2i_cpy_scsi_cdb(sc, cmd);\n\n\tcmd->req.op_attr = ISCSI_ATTR_SIMPLE;\n\tif (sc->sc_data_direction == DMA_TO_DEVICE) {\n\t\tcmd->req.op_attr |= ISCSI_CMD_REQUEST_WRITE;\n\t\tcmd->req.itt = task->itt |\n\t\t\t(ISCSI_TASK_TYPE_WRITE << ISCSI_CMD_REQUEST_TYPE_SHIFT);\n\t\tbnx2i_setup_write_cmd_bd_info(task);\n\t} else {\n\t\tif (scsi_bufflen(sc))\n\t\t\tcmd->req.op_attr |= ISCSI_CMD_REQUEST_READ;\n\t\tcmd->req.itt = task->itt |\n\t\t\t(ISCSI_TASK_TYPE_READ << ISCSI_CMD_REQUEST_TYPE_SHIFT);\n\t}\n\n\tcmd->req.num_bds = cmd->io_tbl.bd_valid;\n\tif (!cmd->io_tbl.bd_valid) {\n\t\tcmd->req.bd_list_addr_lo = (u32) hba->mp_bd_dma;\n\t\tcmd->req.bd_list_addr_hi = (u32) ((u64) hba->mp_bd_dma >> 32);\n\t\tcmd->req.num_bds = 1;\n\t}\n\n\tbnx2i_send_iscsi_scsicmd(bnx2i_conn, cmd);\n\treturn 0;\n}\n\n \nstatic struct iscsi_cls_session *\nbnx2i_session_create(struct iscsi_endpoint *ep,\n\t\t     uint16_t cmds_max, uint16_t qdepth,\n\t\t     uint32_t initial_cmdsn)\n{\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct bnx2i_hba *hba;\n\tstruct bnx2i_endpoint *bnx2i_ep;\n\n\tif (!ep) {\n\t\tprintk(KERN_ERR \"bnx2i: missing ep.\\n\");\n\t\treturn NULL;\n\t}\n\n\tbnx2i_ep = ep->dd_data;\n\tshost = bnx2i_ep->hba->shost;\n\thba = iscsi_host_priv(shost);\n\tif (bnx2i_adapter_ready(hba))\n\t\treturn NULL;\n\n\t \n\tif (cmds_max > hba->max_sqes)\n\t\tcmds_max = hba->max_sqes;\n\telse if (cmds_max < BNX2I_SQ_WQES_MIN)\n\t\tcmds_max = BNX2I_SQ_WQES_MIN;\n\n\tcls_session = iscsi_session_setup(&bnx2i_iscsi_transport, shost,\n\t\t\t\t\t  cmds_max, 0, sizeof(struct bnx2i_cmd),\n\t\t\t\t\t  initial_cmdsn, ISCSI_MAX_TARGET);\n\tif (!cls_session)\n\t\treturn NULL;\n\n\tif (bnx2i_setup_cmd_pool(hba, cls_session->dd_data))\n\t\tgoto session_teardown;\n\treturn cls_session;\n\nsession_teardown:\n\tiscsi_session_teardown(cls_session);\n\treturn NULL;\n}\n\n\n \nstatic void bnx2i_session_destroy(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\tstruct bnx2i_hba *hba = iscsi_host_priv(shost);\n\n\tbnx2i_destroy_cmd_pool(hba, session);\n\tiscsi_session_teardown(cls_session);\n}\n\n\n \nstatic struct iscsi_cls_conn *\nbnx2i_conn_create(struct iscsi_cls_session *cls_session, uint32_t cid)\n{\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\tstruct bnx2i_hba *hba = iscsi_host_priv(shost);\n\tstruct bnx2i_conn *bnx2i_conn;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_conn *conn;\n\n\tcls_conn = iscsi_conn_setup(cls_session, sizeof(*bnx2i_conn),\n\t\t\t\t    cid);\n\tif (!cls_conn)\n\t\treturn NULL;\n\tconn = cls_conn->dd_data;\n\n\tbnx2i_conn = conn->dd_data;\n\tbnx2i_conn->cls_conn = cls_conn;\n\tbnx2i_conn->hba = hba;\n\n\tatomic_set(&bnx2i_conn->work_cnt, 0);\n\n\t \n\tbnx2i_conn->ep = NULL;\n\tinit_completion(&bnx2i_conn->cmd_cleanup_cmpl);\n\n\tif (bnx2i_conn_alloc_login_resources(hba, bnx2i_conn)) {\n\t\tiscsi_conn_printk(KERN_ALERT, conn,\n\t\t\t\t  \"conn_new: login resc alloc failed!!\\n\");\n\t\tgoto free_conn;\n\t}\n\n\treturn cls_conn;\n\nfree_conn:\n\tiscsi_conn_teardown(cls_conn);\n\treturn NULL;\n}\n\n \nstatic int bnx2i_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t\t   struct iscsi_cls_conn *cls_conn,\n\t\t\t   uint64_t transport_fd, int is_leading)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\tstruct bnx2i_hba *hba = iscsi_host_priv(shost);\n\tstruct bnx2i_endpoint *bnx2i_ep;\n\tstruct iscsi_endpoint *ep;\n\tint ret_code;\n\n\tep = iscsi_lookup_endpoint(transport_fd);\n\tif (!ep)\n\t\treturn -EINVAL;\n\t \n\tif (bnx2i_adapter_ready(hba)) {\n\t\tret_code = -EIO;\n\t\tgoto put_ep;\n\t}\n\n\tbnx2i_ep = ep->dd_data;\n\tif ((bnx2i_ep->state == EP_STATE_TCP_FIN_RCVD) ||\n\t    (bnx2i_ep->state == EP_STATE_TCP_RST_RCVD)) {\n\t\t \n\t\tret_code = -EINVAL;\n\t\tgoto put_ep;\n\t}\n\n\tif (iscsi_conn_bind(cls_session, cls_conn, is_leading)) {\n\t\tret_code = -EINVAL;\n\t\tgoto put_ep;\n\t}\n\n\tif (bnx2i_ep->hba != hba) {\n\t\t \n\t\tiscsi_conn_printk(KERN_ALERT, cls_conn->dd_data,\n\t\t\t\t  \"conn bind, ep=0x%p (%s) does not\",\n\t\t\t\t  bnx2i_ep, bnx2i_ep->hba->netdev->name);\n\t\tiscsi_conn_printk(KERN_ALERT, cls_conn->dd_data,\n\t\t\t\t  \"belong to hba (%s)\\n\",\n\t\t\t\t  hba->netdev->name);\n\t\tret_code = -EEXIST;\n\t\tgoto put_ep;\n\t}\n\tbnx2i_ep->conn = bnx2i_conn;\n\tbnx2i_conn->ep = bnx2i_ep;\n\tbnx2i_conn->iscsi_conn_cid = bnx2i_ep->ep_iscsi_cid;\n\tbnx2i_conn->fw_cid = bnx2i_ep->ep_cid;\n\n\tret_code = bnx2i_bind_conn_to_iscsi_cid(hba, bnx2i_conn,\n\t\t\t\t\t\tbnx2i_ep->ep_iscsi_cid);\n\n\t \n\tif (test_bit(BNX2I_NX2_DEV_57710, &bnx2i_ep->hba->cnic_dev_type))\n\t\tbnx2i_put_rq_buf(bnx2i_conn, 0);\n\n\tbnx2i_arm_cq_event_coalescing(bnx2i_conn->ep, CNIC_ARM_CQE);\nput_ep:\n\tiscsi_put_endpoint(ep);\n\treturn ret_code;\n}\n\n\n \nstatic void bnx2i_conn_destroy(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\n\tstruct Scsi_Host *shost;\n\tstruct bnx2i_hba *hba;\n\tstruct bnx2i_work *work, *tmp;\n\tunsigned cpu = 0;\n\tstruct bnx2i_percpu_s *p;\n\n\tshost = iscsi_session_to_shost(iscsi_conn_to_session(cls_conn));\n\thba = iscsi_host_priv(shost);\n\n\tbnx2i_conn_free_login_resources(hba, bnx2i_conn);\n\n\tif (atomic_read(&bnx2i_conn->work_cnt)) {\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tp = &per_cpu(bnx2i_percpu, cpu);\n\t\t\tspin_lock_bh(&p->p_work_lock);\n\t\t\tlist_for_each_entry_safe(work, tmp,\n\t\t\t\t\t\t &p->work_list, list) {\n\t\t\t\tif (work->session == conn->session &&\n\t\t\t\t    work->bnx2i_conn == bnx2i_conn) {\n\t\t\t\t\tlist_del_init(&work->list);\n\t\t\t\t\tkfree(work);\n\t\t\t\t\tif (!atomic_dec_and_test(\n\t\t\t\t\t\t\t&bnx2i_conn->work_cnt))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(&p->p_work_lock);\n\t\t}\n\t}\n\n\tiscsi_conn_teardown(cls_conn);\n}\n\n\n \nstatic int bnx2i_ep_get_param(struct iscsi_endpoint *ep,\n\t\t\t      enum iscsi_param param, char *buf)\n{\n\tstruct bnx2i_endpoint *bnx2i_ep = ep->dd_data;\n\tstruct bnx2i_hba *hba = bnx2i_ep->hba;\n\tint len = -ENOTCONN;\n\n\tif (!hba)\n\t\treturn -ENOTCONN;\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\t\tmutex_lock(&hba->net_dev_lock);\n\t\tif (bnx2i_ep->cm_sk)\n\t\t\tlen = sprintf(buf, \"%hu\\n\", bnx2i_ep->cm_sk->dst_port);\n\t\tmutex_unlock(&hba->net_dev_lock);\n\t\tbreak;\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tmutex_lock(&hba->net_dev_lock);\n\t\tif (bnx2i_ep->cm_sk)\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", &bnx2i_ep->cm_sk->dst_ip);\n\t\tmutex_unlock(&hba->net_dev_lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}\n\n \nstatic int bnx2i_host_get_param(struct Scsi_Host *shost,\n\t\t\t\tenum iscsi_host_param param, char *buf)\n{\n\tstruct bnx2i_hba *hba = iscsi_host_priv(shost);\n\tint len = 0;\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tlen = sysfs_format_mac(buf, hba->cnic->mac_addr, 6);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", hba->netdev->name);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_IPADDRESS: {\n\t\tstruct list_head *active_list = &hba->ep_active_list;\n\n\t\tread_lock_bh(&hba->ep_rdwr_lock);\n\t\tif (!list_empty(&hba->ep_active_list)) {\n\t\t\tstruct bnx2i_endpoint *bnx2i_ep;\n\t\t\tstruct cnic_sock *csk;\n\n\t\t\tbnx2i_ep = list_first_entry(active_list,\n\t\t\t\t\t\t    struct bnx2i_endpoint,\n\t\t\t\t\t\t    link);\n\t\t\tcsk = bnx2i_ep->cm_sk;\n\t\t\tif (test_bit(SK_F_IPV6, &csk->flags))\n\t\t\t\tlen = sprintf(buf, \"%pI6\\n\", csk->src_ip);\n\t\t\telse\n\t\t\t\tlen = sprintf(buf, \"%pI4\\n\", csk->src_ip);\n\t\t}\n\t\tread_unlock_bh(&hba->ep_rdwr_lock);\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn iscsi_host_get_param(shost, param, buf);\n\t}\n\treturn len;\n}\n\n \nstatic int bnx2i_conn_start(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\n\n\tbnx2i_conn->ep->state = EP_STATE_ULP_UPDATE_START;\n\tbnx2i_update_iscsi_conn(conn);\n\n\t \n\ttimer_setup(&bnx2i_conn->ep->ofld_timer, bnx2i_ep_ofld_timer, 0);\n\tbnx2i_conn->ep->ofld_timer.expires = 1 * HZ + jiffies;\n\tadd_timer(&bnx2i_conn->ep->ofld_timer);\n\t \n\twait_event_interruptible(bnx2i_conn->ep->ofld_wait,\n\t\t\tbnx2i_conn->ep->state != EP_STATE_ULP_UPDATE_START);\n\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\tdel_timer_sync(&bnx2i_conn->ep->ofld_timer);\n\n\tiscsi_conn_start(cls_conn);\n\treturn 0;\n}\n\n\n \nstatic void bnx2i_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t struct iscsi_stats *stats)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\n\tstats->txdata_octets = conn->txdata_octets;\n\tstats->rxdata_octets = conn->rxdata_octets;\n\tstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\n\tstats->dataout_pdus = conn->dataout_pdus_cnt;\n\tstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\n\tstats->datain_pdus = conn->datain_pdus_cnt;\n\tstats->r2t_pdus = conn->r2t_pdus_cnt;\n\tstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\n\tstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\n\tstats->digest_err = 0;\n\tstats->timeout_err = 0;\n\tstrcpy(stats->custom[0].desc, \"eh_abort_cnt\");\n\tstats->custom[0].value = conn->eh_abort_cnt;\n\tstats->custom_length = 1;\n}\n\n\n \nstatic struct bnx2i_hba *bnx2i_check_route(struct sockaddr *dst_addr)\n{\n\tstruct sockaddr_in *desti = (struct sockaddr_in *) dst_addr;\n\tstruct bnx2i_hba *hba;\n\tstruct cnic_dev *cnic = NULL;\n\n\thba = get_adapter_list_head();\n\tif (hba && hba->cnic)\n\t\tcnic = hba->cnic->cm_select_dev(desti, CNIC_ULP_ISCSI);\n\tif (!cnic) {\n\t\tprintk(KERN_ALERT \"bnx2i: no route,\"\n\t\t       \"can't connect using cnic\\n\");\n\t\tgoto no_nx2_route;\n\t}\n\thba = bnx2i_find_hba_for_cnic(cnic);\n\tif (!hba)\n\t\tgoto no_nx2_route;\n\n\tif (bnx2i_adapter_ready(hba)) {\n\t\tprintk(KERN_ALERT \"bnx2i: check route, hba not found\\n\");\n\t\tgoto no_nx2_route;\n\t}\n\tif (hba->netdev->mtu > hba->mtu_supported) {\n\t\tprintk(KERN_ALERT \"bnx2i: %s network i/f mtu is set to %d\\n\",\n\t\t\t\t  hba->netdev->name, hba->netdev->mtu);\n\t\tprintk(KERN_ALERT \"bnx2i: iSCSI HBA can support mtu of %d\\n\",\n\t\t\t\t  hba->mtu_supported);\n\t\tgoto no_nx2_route;\n\t}\n\treturn hba;\nno_nx2_route:\n\treturn NULL;\n}\n\n\n \nstatic int bnx2i_tear_down_conn(struct bnx2i_hba *hba,\n\t\t\t\t struct bnx2i_endpoint *ep)\n{\n\tif (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic) && ep->cm_sk)\n\t\thba->cnic->cm_destroy(ep->cm_sk);\n\n\tif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type) &&\n\t    ep->state == EP_STATE_DISCONN_TIMEDOUT) {\n\t\tif (ep->conn && ep->conn->cls_conn &&\n\t\t    ep->conn->cls_conn->dd_data) {\n\t\t\tstruct iscsi_conn *conn = ep->conn->cls_conn->dd_data;\n\n\t\t\t \n\t\t\tset_bit(ISCSI_CONN_FLAG_SUSPEND_RX, &conn->flags);\n\t\t}\n\t\t \n\t\tprintk(KERN_ALERT \"bnx2i (%s): - WARN - CONN_DISCON timed out, \"\n\t\t\t\t  \"please submit GRC Dump, NW/PCIe trace, \"\n\t\t\t\t  \"driver msgs to developers for analysis\\n\",\n\t\t\t\t  hba->netdev->name);\n\t}\n\n\tep->state = EP_STATE_CLEANUP_START;\n\ttimer_setup(&ep->ofld_timer, bnx2i_ep_ofld_timer, 0);\n\tep->ofld_timer.expires = hba->conn_ctx_destroy_tmo + jiffies;\n\tadd_timer(&ep->ofld_timer);\n\n\tbnx2i_ep_destroy_list_add(hba, ep);\n\n\t \n\tif (bnx2i_send_conn_destroy(hba, ep))\n\t\tep->state = EP_STATE_CLEANUP_CMPL;\n\n\twait_event_interruptible(ep->ofld_wait,\n\t\t\t\t (ep->state != EP_STATE_CLEANUP_START));\n\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\tdel_timer_sync(&ep->ofld_timer);\n\n\tbnx2i_ep_destroy_list_del(hba, ep);\n\n\tif (ep->state != EP_STATE_CLEANUP_CMPL)\n\t\t \n\t\tprintk(KERN_ALERT \"bnx2i - conn destroy failed\\n\");\n\n\treturn 0;\n}\n\n\n \nstatic struct iscsi_endpoint *bnx2i_ep_connect(struct Scsi_Host *shost,\n\t\t\t\t\t       struct sockaddr *dst_addr,\n\t\t\t\t\t       int non_blocking)\n{\n\tu32 iscsi_cid = BNX2I_CID_RESERVED;\n\tstruct sockaddr_in *desti = (struct sockaddr_in *) dst_addr;\n\tstruct sockaddr_in6 *desti6;\n\tstruct bnx2i_endpoint *bnx2i_ep;\n\tstruct bnx2i_hba *hba;\n\tstruct cnic_dev *cnic;\n\tstruct cnic_sockaddr saddr;\n\tstruct iscsi_endpoint *ep;\n\tint rc = 0;\n\n\tif (shost) {\n\t\t \n\t\thba = iscsi_host_priv(shost);\n\t} else\n\t\t \n\t\thba = bnx2i_check_route(dst_addr);\n\n\tif (!hba) {\n\t\trc = -EINVAL;\n\t\tgoto nohba;\n\t}\n\tmutex_lock(&hba->net_dev_lock);\n\n\tif (bnx2i_adapter_ready(hba) || !hba->cid_que.cid_free_cnt) {\n\t\trc = -EPERM;\n\t\tgoto check_busy;\n\t}\n\tcnic = hba->cnic;\n\tep = bnx2i_alloc_ep(hba);\n\tif (!ep) {\n\t\trc = -ENOMEM;\n\t\tgoto check_busy;\n\t}\n\tbnx2i_ep = ep->dd_data;\n\n\tatomic_set(&bnx2i_ep->num_active_cmds, 0);\n\tiscsi_cid = bnx2i_alloc_iscsi_cid(hba);\n\tif (iscsi_cid == -1) {\n\t\tprintk(KERN_ALERT \"bnx2i (%s): alloc_ep - unable to allocate \"\n\t\t\t\"iscsi cid\\n\", hba->netdev->name);\n\t\trc = -ENOMEM;\n\t\tbnx2i_free_ep(ep);\n\t\tgoto check_busy;\n\t}\n\tbnx2i_ep->hba_age = hba->age;\n\n\trc = bnx2i_alloc_qp_resc(hba, bnx2i_ep);\n\tif (rc != 0) {\n\t\tprintk(KERN_ALERT \"bnx2i (%s): ep_conn - alloc QP resc error\"\n\t\t\t\"\\n\", hba->netdev->name);\n\t\trc = -ENOMEM;\n\t\tgoto qp_resc_err;\n\t}\n\n\tbnx2i_ep->ep_iscsi_cid = (u16)iscsi_cid;\n\tbnx2i_ep->state = EP_STATE_OFLD_START;\n\tbnx2i_ep_ofld_list_add(hba, bnx2i_ep);\n\n\ttimer_setup(&bnx2i_ep->ofld_timer, bnx2i_ep_ofld_timer, 0);\n\tbnx2i_ep->ofld_timer.expires = 2 * HZ + jiffies;\n\tadd_timer(&bnx2i_ep->ofld_timer);\n\n\tif (bnx2i_send_conn_ofld_req(hba, bnx2i_ep)) {\n\t\tif (bnx2i_ep->state == EP_STATE_OFLD_FAILED_CID_BUSY) {\n\t\t\tprintk(KERN_ALERT \"bnx2i (%s): iscsi cid %d is busy\\n\",\n\t\t\t\thba->netdev->name, bnx2i_ep->ep_iscsi_cid);\n\t\t\trc = -EBUSY;\n\t\t} else\n\t\t\trc = -ENOSPC;\n\t\tprintk(KERN_ALERT \"bnx2i (%s): unable to send conn offld kwqe\"\n\t\t\t\"\\n\", hba->netdev->name);\n\t\tbnx2i_ep_ofld_list_del(hba, bnx2i_ep);\n\t\tgoto conn_failed;\n\t}\n\n\t \n\twait_event_interruptible(bnx2i_ep->ofld_wait,\n\t\t\t\t bnx2i_ep->state != EP_STATE_OFLD_START);\n\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\tdel_timer_sync(&bnx2i_ep->ofld_timer);\n\n\tbnx2i_ep_ofld_list_del(hba, bnx2i_ep);\n\n\tif (bnx2i_ep->state != EP_STATE_OFLD_COMPL) {\n\t\tif (bnx2i_ep->state == EP_STATE_OFLD_FAILED_CID_BUSY) {\n\t\t\tprintk(KERN_ALERT \"bnx2i (%s): iscsi cid %d is busy\\n\",\n\t\t\t\thba->netdev->name, bnx2i_ep->ep_iscsi_cid);\n\t\t\trc = -EBUSY;\n\t\t} else\n\t\t\trc = -ENOSPC;\n\t\tgoto conn_failed;\n\t}\n\n\trc = cnic->cm_create(cnic, CNIC_ULP_ISCSI, bnx2i_ep->ep_cid,\n\t\t\t     iscsi_cid, &bnx2i_ep->cm_sk, bnx2i_ep);\n\tif (rc) {\n\t\trc = -EINVAL;\n\t\t \n\t\tgoto release_ep;\n\t}\n\n\tbnx2i_ep->cm_sk->rcv_buf = 256 * 1024;\n\tbnx2i_ep->cm_sk->snd_buf = 256 * 1024;\n\tclear_bit(SK_TCP_TIMESTAMP, &bnx2i_ep->cm_sk->tcp_flags);\n\n\tmemset(&saddr, 0, sizeof(saddr));\n\tif (dst_addr->sa_family == AF_INET) {\n\t\tdesti = (struct sockaddr_in *) dst_addr;\n\t\tsaddr.remote.v4 = *desti;\n\t\tsaddr.local.v4.sin_family = desti->sin_family;\n\t} else if (dst_addr->sa_family == AF_INET6) {\n\t\tdesti6 = (struct sockaddr_in6 *) dst_addr;\n\t\tsaddr.remote.v6 = *desti6;\n\t\tsaddr.local.v6.sin6_family = desti6->sin6_family;\n\t}\n\n\tbnx2i_ep->timestamp = jiffies;\n\tbnx2i_ep->state = EP_STATE_CONNECT_START;\n\tif (!test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {\n\t\trc = -EINVAL;\n\t\tgoto conn_failed;\n\t} else\n\t\trc = cnic->cm_connect(bnx2i_ep->cm_sk, &saddr);\n\tif (rc)\n\t\tgoto release_ep;\n\n\tbnx2i_ep_active_list_add(hba, bnx2i_ep);\n\n\trc = bnx2i_map_ep_dbell_regs(bnx2i_ep);\n\tif (rc)\n\t\tgoto del_active_ep;\n\n\tmutex_unlock(&hba->net_dev_lock);\n\treturn ep;\n\ndel_active_ep:\n\tbnx2i_ep_active_list_del(hba, bnx2i_ep);\nrelease_ep:\n\tif (bnx2i_tear_down_conn(hba, bnx2i_ep)) {\n\t\tmutex_unlock(&hba->net_dev_lock);\n\t\treturn ERR_PTR(rc);\n\t}\nconn_failed:\n\tbnx2i_free_qp_resc(hba, bnx2i_ep);\nqp_resc_err:\n\tbnx2i_free_ep(ep);\ncheck_busy:\n\tmutex_unlock(&hba->net_dev_lock);\nnohba:\n\treturn ERR_PTR(rc);\n}\n\n\n \nstatic int bnx2i_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\n{\n\tstruct bnx2i_endpoint *bnx2i_ep;\n\tint rc = 0;\n\n\tbnx2i_ep = ep->dd_data;\n\tif ((bnx2i_ep->state == EP_STATE_IDLE) ||\n\t    (bnx2i_ep->state == EP_STATE_CONNECT_FAILED) ||\n\t    (bnx2i_ep->state == EP_STATE_OFLD_FAILED))\n\t\treturn -1;\n\tif (bnx2i_ep->state == EP_STATE_CONNECT_COMPL)\n\t\treturn 1;\n\n\trc = wait_event_interruptible_timeout(bnx2i_ep->ofld_wait,\n\t\t\t\t\t      ((bnx2i_ep->state ==\n\t\t\t\t\t\tEP_STATE_OFLD_FAILED) ||\n\t\t\t\t\t       (bnx2i_ep->state ==\n\t\t\t\t\t\tEP_STATE_CONNECT_FAILED) ||\n\t\t\t\t\t       (bnx2i_ep->state ==\n\t\t\t\t\t\tEP_STATE_CONNECT_COMPL)),\n\t\t\t\t\t      msecs_to_jiffies(timeout_ms));\n\tif (bnx2i_ep->state == EP_STATE_OFLD_FAILED)\n\t\trc = -1;\n\n\tif (rc > 0)\n\t\treturn 1;\n\telse if (!rc)\n\t\treturn 0;\t \n\telse\n\t\treturn rc;\n}\n\n\n \nstatic int bnx2i_ep_tcp_conn_active(struct bnx2i_endpoint *bnx2i_ep)\n{\n\tint ret;\n\tint cnic_dev_10g = 0;\n\n\tif (test_bit(BNX2I_NX2_DEV_57710, &bnx2i_ep->hba->cnic_dev_type))\n\t\tcnic_dev_10g = 1;\n\n\tswitch (bnx2i_ep->state) {\n\tcase EP_STATE_CLEANUP_FAILED:\n\tcase EP_STATE_OFLD_FAILED:\n\tcase EP_STATE_DISCONN_TIMEDOUT:\n\t\tret = 0;\n\t\tbreak;\n\tcase EP_STATE_CONNECT_START:\n\tcase EP_STATE_CONNECT_FAILED:\n\tcase EP_STATE_CONNECT_COMPL:\n\tcase EP_STATE_ULP_UPDATE_START:\n\tcase EP_STATE_ULP_UPDATE_COMPL:\n\tcase EP_STATE_TCP_FIN_RCVD:\n\tcase EP_STATE_LOGOUT_SENT:\n\tcase EP_STATE_LOGOUT_RESP_RCVD:\n\tcase EP_STATE_ULP_UPDATE_FAILED:\n\t\tret = 1;\n\t\tbreak;\n\tcase EP_STATE_TCP_RST_RCVD:\n\t\tif (cnic_dev_10g)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n\n \nint bnx2i_hw_ep_disconnect(struct bnx2i_endpoint *bnx2i_ep)\n{\n\tstruct bnx2i_hba *hba = bnx2i_ep->hba;\n\tstruct cnic_dev *cnic;\n\tstruct iscsi_session *session = NULL;\n\tstruct iscsi_conn *conn = NULL;\n\tint ret = 0;\n\tint close = 0;\n\tint close_ret = 0;\n\n\tif (!hba)\n\t\treturn 0;\n\n\tcnic = hba->cnic;\n\tif (!cnic)\n\t\treturn 0;\n\n\tif (bnx2i_ep->state == EP_STATE_IDLE ||\n\t    bnx2i_ep->state == EP_STATE_DISCONN_TIMEDOUT)\n\t\treturn 0;\n\n\tif (!bnx2i_ep_tcp_conn_active(bnx2i_ep))\n\t\tgoto destroy_conn;\n\n\tif (bnx2i_ep->conn) {\n\t\tconn = bnx2i_ep->conn->cls_conn->dd_data;\n\t\tsession = conn->session;\n\t}\n\n\ttimer_setup(&bnx2i_ep->ofld_timer, bnx2i_ep_ofld_timer, 0);\n\tbnx2i_ep->ofld_timer.expires = hba->conn_teardown_tmo + jiffies;\n\tadd_timer(&bnx2i_ep->ofld_timer);\n\n\tif (!test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic))\n\t\tgoto out;\n\n\tif (session) {\n\t\tspin_lock_bh(&session->frwd_lock);\n\t\tif (bnx2i_ep->state != EP_STATE_TCP_FIN_RCVD) {\n\t\t\tif (session->state == ISCSI_STATE_LOGGING_OUT) {\n\t\t\t\tif (bnx2i_ep->state == EP_STATE_LOGOUT_SENT) {\n\t\t\t\t\t \n\t\t\t\t\tprintk(KERN_ALERT \"bnx2i (%s): WARNING\"\n\t\t\t\t\t\t\" logout response was not \"\n\t\t\t\t\t\t\"received!\\n\",\n\t\t\t\t\t\tbnx2i_ep->hba->netdev->name);\n\t\t\t\t} else if (bnx2i_ep->state ==\n\t\t\t\t\t   EP_STATE_LOGOUT_RESP_RCVD)\n\t\t\t\t\tclose = 1;\n\t\t\t}\n\t\t} else\n\t\t\tclose = 1;\n\n\t\tspin_unlock_bh(&session->frwd_lock);\n\t}\n\n\tbnx2i_ep->state = EP_STATE_DISCONN_START;\n\n\tif (close)\n\t\tclose_ret = cnic->cm_close(bnx2i_ep->cm_sk);\n\telse\n\t\tclose_ret = cnic->cm_abort(bnx2i_ep->cm_sk);\n\n\tif (close_ret)\n\t\tprintk(KERN_ALERT \"bnx2i (%s): close/abort(%d) returned %d\\n\",\n\t\t\tbnx2i_ep->hba->netdev->name, close, close_ret);\n\telse\n\t\t \n\t\twait_event_interruptible(bnx2i_ep->ofld_wait,\n\t\t\t\t((bnx2i_ep->state != EP_STATE_DISCONN_START)\n\t\t\t\t&& (bnx2i_ep->state != EP_STATE_TCP_FIN_RCVD)));\n\n\tif (signal_pending(current))\n\t\tflush_signals(current);\n\tdel_timer_sync(&bnx2i_ep->ofld_timer);\n\ndestroy_conn:\n\tbnx2i_ep_active_list_del(hba, bnx2i_ep);\n\tif (bnx2i_tear_down_conn(hba, bnx2i_ep))\n\t\treturn -EINVAL;\nout:\n\tbnx2i_ep->state = EP_STATE_IDLE;\n\treturn ret;\n}\n\n\n \nstatic void bnx2i_ep_disconnect(struct iscsi_endpoint *ep)\n{\n\tstruct bnx2i_endpoint *bnx2i_ep;\n\tstruct bnx2i_conn *bnx2i_conn = NULL;\n\tstruct bnx2i_hba *hba;\n\n\tbnx2i_ep = ep->dd_data;\n\n\t \n\twhile ((bnx2i_ep->state == EP_STATE_CONNECT_START) &&\n\t\t!time_after(jiffies, bnx2i_ep->timestamp + (12 * HZ)))\n\t\tmsleep(250);\n\n\tif (bnx2i_ep->conn)\n\t\tbnx2i_conn = bnx2i_ep->conn;\n\thba = bnx2i_ep->hba;\n\n\tmutex_lock(&hba->net_dev_lock);\n\n\tif (bnx2i_ep->state == EP_STATE_DISCONN_TIMEDOUT)\n\t\tgoto out;\n\n\tif (bnx2i_ep->state == EP_STATE_IDLE)\n\t\tgoto free_resc;\n\n\tif (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state) ||\n\t    (bnx2i_ep->hba_age != hba->age)) {\n\t\tbnx2i_ep_active_list_del(hba, bnx2i_ep);\n\t\tgoto free_resc;\n\t}\n\n\t \n\tif (bnx2i_hw_ep_disconnect(bnx2i_ep)) {\n\t\tmutex_unlock(&hba->net_dev_lock);\n\t\treturn;\n\t}\nfree_resc:\n\tbnx2i_free_qp_resc(hba, bnx2i_ep);\n\n\tif (bnx2i_conn)\n\t\tbnx2i_conn->ep = NULL;\n\n\tbnx2i_free_ep(ep);\nout:\n\tmutex_unlock(&hba->net_dev_lock);\n\n\twake_up_interruptible(&hba->eh_wait);\n}\n\n\n \nstatic int bnx2i_nl_set_path(struct Scsi_Host *shost, struct iscsi_path *params)\n{\n\tstruct bnx2i_hba *hba = iscsi_host_priv(shost);\n\tchar *buf = (char *) params;\n\tu16 len = sizeof(*params);\n\n\t \n\thba->cnic->iscsi_nl_msg_recv(hba->cnic, ISCSI_UEVENT_PATH_UPDATE, buf,\n\t\t\t\t     len);\n\n\treturn 0;\n}\n\nstatic umode_t bnx2i_attr_is_visible(int param_type, int param)\n{\n\tswitch (param_type) {\n\tcase ISCSI_HOST_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tcase ISCSI_PARAM_CONN_PORT:\n\t\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tcase ISCSI_PARAM_PING_TMO:\n\t\tcase ISCSI_PARAM_RECV_TMO:\n\t\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_PARAM_MAX_R2T:\n\t\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tcase ISCSI_PARAM_MAX_BURST:\n\t\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_PARAM_ERL:\n\t\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tcase ISCSI_PARAM_TPGT:\n\t\tcase ISCSI_PARAM_USERNAME:\n\t\tcase ISCSI_PARAM_PASSWORD:\n\t\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\tcase ISCSI_PARAM_BOOT_ROOT:\n\t\tcase ISCSI_PARAM_BOOT_NIC:\n\t\tcase ISCSI_PARAM_BOOT_TARGET:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct scsi_host_template bnx2i_host_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"QLogic Offload iSCSI Initiator\",\n\t.proc_name\t\t= \"bnx2i\",\n\t.queuecommand\t\t= iscsi_queuecommand,\n\t.eh_timed_out\t\t= iscsi_eh_cmd_timed_out,\n\t.eh_abort_handler\t= iscsi_eh_abort,\n\t.eh_device_reset_handler = iscsi_eh_device_reset,\n\t.eh_target_reset_handler = iscsi_eh_recover_target,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.target_alloc\t\t= iscsi_target_alloc,\n\t.can_queue\t\t= 2048,\n\t.max_sectors\t\t= 127,\n\t.cmd_per_lun\t\t= 128,\n\t.this_id\t\t= -1,\n\t.sg_tablesize\t\t= ISCSI_MAX_BDS_PER_CMD,\n\t.shost_groups\t\t= bnx2i_dev_groups,\n\t.track_queue_depth\t= 1,\n\t.cmd_size\t\t= sizeof(struct iscsi_cmd),\n};\n\nstruct iscsi_transport bnx2i_iscsi_transport = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"bnx2i\",\n\t.caps\t\t\t= CAP_RECOVERY_L0 | CAP_HDRDGST |\n\t\t\t\t  CAP_MULTI_R2T | CAP_DATADGST |\n\t\t\t\t  CAP_DATA_PATH_OFFLOAD |\n\t\t\t\t  CAP_TEXT_NEGO,\n\t.create_session\t\t= bnx2i_session_create,\n\t.destroy_session\t= bnx2i_session_destroy,\n\t.create_conn\t\t= bnx2i_conn_create,\n\t.bind_conn\t\t= bnx2i_conn_bind,\n\t.unbind_conn\t\t= iscsi_conn_unbind,\n\t.destroy_conn\t\t= bnx2i_conn_destroy,\n\t.attr_is_visible\t= bnx2i_attr_is_visible,\n\t.set_param\t\t= iscsi_set_param,\n\t.get_conn_param\t\t= iscsi_conn_get_param,\n\t.get_session_param\t= iscsi_session_get_param,\n\t.get_host_param\t\t= bnx2i_host_get_param,\n\t.start_conn\t\t= bnx2i_conn_start,\n\t.stop_conn\t\t= iscsi_conn_stop,\n\t.send_pdu\t\t= iscsi_conn_send_pdu,\n\t.xmit_task\t\t= bnx2i_task_xmit,\n\t.get_stats\t\t= bnx2i_conn_get_stats,\n\t \n\t.get_ep_param\t\t= bnx2i_ep_get_param,\n\t.ep_connect\t\t= bnx2i_ep_connect,\n\t.ep_poll\t\t= bnx2i_ep_poll,\n\t.ep_disconnect\t\t= bnx2i_ep_disconnect,\n\t.set_path\t\t= bnx2i_nl_set_path,\n\t \n\t.session_recovery_timedout = iscsi_session_recovery_timedout,\n\t.cleanup_task\t\t= bnx2i_cleanup_task,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}