{
  "module_name": "bnx2i_hwi.c",
  "hash_id": "1eba64a049077b144347fb2e7d1e74a193d3e77620cd7a95559f3ccfb4501e78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bnx2i/bnx2i_hwi.c",
  "human_readable_source": " \n\n#include <linux/gfp.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/libiscsi.h>\n#include \"bnx2i.h\"\n\nDECLARE_PER_CPU(struct bnx2i_percpu_s, bnx2i_percpu);\n\n \nstatic u32 bnx2i_get_cid_num(struct bnx2i_endpoint *ep)\n{\n\tu32 cid;\n\n\tif (test_bit(BNX2I_NX2_DEV_57710, &ep->hba->cnic_dev_type))\n\t\tcid = ep->ep_cid;\n\telse\n\t\tcid = GET_CID_NUM(ep->ep_cid);\n\treturn cid;\n}\n\n\n \nstatic void bnx2i_adjust_qp_size(struct bnx2i_hba *hba)\n{\n\tu32 num_elements_per_pg;\n\n\tif (test_bit(BNX2I_NX2_DEV_5706, &hba->cnic_dev_type) ||\n\t    test_bit(BNX2I_NX2_DEV_5708, &hba->cnic_dev_type) ||\n\t    test_bit(BNX2I_NX2_DEV_5709, &hba->cnic_dev_type)) {\n\t\tif (!is_power_of_2(hba->max_sqes))\n\t\t\thba->max_sqes = rounddown_pow_of_two(hba->max_sqes);\n\n\t\tif (!is_power_of_2(hba->max_rqes))\n\t\t\thba->max_rqes = rounddown_pow_of_two(hba->max_rqes);\n\t}\n\n\t \n\t \n\tnum_elements_per_pg = CNIC_PAGE_SIZE / BNX2I_SQ_WQE_SIZE;\n\tif (hba->max_sqes < num_elements_per_pg)\n\t\thba->max_sqes = num_elements_per_pg;\n\telse if (hba->max_sqes % num_elements_per_pg)\n\t\thba->max_sqes = (hba->max_sqes + num_elements_per_pg - 1) &\n\t\t\t\t ~(num_elements_per_pg - 1);\n\n\t \n\tnum_elements_per_pg = CNIC_PAGE_SIZE / BNX2I_CQE_SIZE;\n\tif (hba->max_cqes < num_elements_per_pg)\n\t\thba->max_cqes = num_elements_per_pg;\n\telse if (hba->max_cqes % num_elements_per_pg)\n\t\thba->max_cqes = (hba->max_cqes + num_elements_per_pg - 1) &\n\t\t\t\t ~(num_elements_per_pg - 1);\n\n\t \n\tnum_elements_per_pg = CNIC_PAGE_SIZE / BNX2I_RQ_WQE_SIZE;\n\tif (hba->max_rqes < num_elements_per_pg)\n\t\thba->max_rqes = num_elements_per_pg;\n\telse if (hba->max_rqes % num_elements_per_pg)\n\t\thba->max_rqes = (hba->max_rqes + num_elements_per_pg - 1) &\n\t\t\t\t ~(num_elements_per_pg - 1);\n}\n\n\n \nstatic void bnx2i_get_link_state(struct bnx2i_hba *hba)\n{\n\tif (test_bit(__LINK_STATE_NOCARRIER, &hba->netdev->state))\n\t\tset_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\n\telse\n\t\tclear_bit(ADAPTER_STATE_LINK_DOWN, &hba->adapter_state);\n}\n\n\n \nstatic void bnx2i_iscsi_license_error(struct bnx2i_hba *hba, u32 error_code)\n{\n\tif (error_code == ISCSI_KCQE_COMPLETION_STATUS_ISCSI_NOT_SUPPORTED)\n\t\t \n\t\tprintk(KERN_ERR \"bnx2i: iSCSI not supported, dev=%s\\n\",\n\t\t\t\thba->netdev->name);\n\tif (error_code == ISCSI_KCQE_COMPLETION_STATUS_LOM_ISCSI_NOT_ENABLED)\n\t\t \n\t\tprintk(KERN_ERR \"bnx2i: LOM is not enable to \"\n\t\t\t\t\"offload iSCSI connections, dev=%s\\n\",\n\t\t\t\thba->netdev->name);\n\tset_bit(ADAPTER_STATE_INIT_FAILED, &hba->adapter_state);\n}\n\n\n \nint bnx2i_arm_cq_event_coalescing(struct bnx2i_endpoint *ep, u8 action)\n{\n\tstruct bnx2i_5771x_cq_db *cq_db;\n\tu16 cq_index;\n\tu16 next_index = 0;\n\tu32 num_active_cmds;\n\n\t \n\tif (!test_bit(BNX2I_NX2_DEV_57710, &ep->hba->cnic_dev_type))\n\t\treturn 0;\n\n\t \n\tcq_db = (struct bnx2i_5771x_cq_db *) ep->qp.cq_pgtbl_virt;\n\n\tif (action != CNIC_ARM_CQE_FP)\n\t\tif (cq_db->sqn[0] && cq_db->sqn[0] != 0xFFFF)\n\t\t\treturn 0;\n\n\tif (action == CNIC_ARM_CQE || action == CNIC_ARM_CQE_FP) {\n\t\tnum_active_cmds = atomic_read(&ep->num_active_cmds);\n\t\tif (num_active_cmds <= event_coal_min)\n\t\t\tnext_index = 1;\n\t\telse {\n\t\t\tnext_index = num_active_cmds >> ep->ec_shift;\n\t\t\tif (next_index > num_active_cmds - event_coal_min)\n\t\t\t\tnext_index = num_active_cmds - event_coal_min;\n\t\t}\n\t\tif (!next_index)\n\t\t\tnext_index = 1;\n\t\tcq_index = ep->qp.cqe_exp_seq_sn + next_index - 1;\n\t\tif (cq_index > ep->qp.cqe_size * 2)\n\t\t\tcq_index -= ep->qp.cqe_size * 2;\n\t\tif (!cq_index)\n\t\t\tcq_index = 1;\n\n\t\tcq_db->sqn[0] = cq_index;\n\t}\n\treturn next_index;\n}\n\n\n \nvoid bnx2i_get_rq_buf(struct bnx2i_conn *bnx2i_conn, char *ptr, int len)\n{\n\tif (!bnx2i_conn->ep->qp.rqe_left)\n\t\treturn;\n\n\tbnx2i_conn->ep->qp.rqe_left--;\n\tmemcpy(ptr, (u8 *) bnx2i_conn->ep->qp.rq_cons_qe, len);\n\tif (bnx2i_conn->ep->qp.rq_cons_qe == bnx2i_conn->ep->qp.rq_last_qe) {\n\t\tbnx2i_conn->ep->qp.rq_cons_qe = bnx2i_conn->ep->qp.rq_first_qe;\n\t\tbnx2i_conn->ep->qp.rq_cons_idx = 0;\n\t} else {\n\t\tbnx2i_conn->ep->qp.rq_cons_qe++;\n\t\tbnx2i_conn->ep->qp.rq_cons_idx++;\n\t}\n}\n\n\nstatic void bnx2i_ring_577xx_doorbell(struct bnx2i_conn *conn)\n{\n\tstruct bnx2i_5771x_dbell dbell;\n\tu32 msg;\n\n\tmemset(&dbell, 0, sizeof(dbell));\n\tdbell.dbell.header = (B577XX_ISCSI_CONNECTION_TYPE <<\n\t\t\t      B577XX_DOORBELL_HDR_CONN_TYPE_SHIFT);\n\tmsg = *((u32 *)&dbell);\n\t \n\twritel(cpu_to_le32(msg), conn->ep->qp.ctx_base);\n}\n\n\n \nvoid bnx2i_put_rq_buf(struct bnx2i_conn *bnx2i_conn, int count)\n{\n\tstruct bnx2i_5771x_sq_rq_db *rq_db;\n\tu16 hi_bit = (bnx2i_conn->ep->qp.rq_prod_idx & 0x8000);\n\tstruct bnx2i_endpoint *ep = bnx2i_conn->ep;\n\n\tep->qp.rqe_left += count;\n\tep->qp.rq_prod_idx &= 0x7FFF;\n\tep->qp.rq_prod_idx += count;\n\n\tif (ep->qp.rq_prod_idx > bnx2i_conn->hba->max_rqes) {\n\t\tep->qp.rq_prod_idx %= bnx2i_conn->hba->max_rqes;\n\t\tif (!hi_bit)\n\t\t\tep->qp.rq_prod_idx |= 0x8000;\n\t} else\n\t\tep->qp.rq_prod_idx |= hi_bit;\n\n\tif (test_bit(BNX2I_NX2_DEV_57710, &ep->hba->cnic_dev_type)) {\n\t\trq_db = (struct bnx2i_5771x_sq_rq_db *) ep->qp.rq_pgtbl_virt;\n\t\trq_db->prod_idx = ep->qp.rq_prod_idx;\n\t\t \n\t} else {\n\t\twritew(ep->qp.rq_prod_idx,\n\t\t       ep->qp.ctx_base + CNIC_RECV_DOORBELL);\n\t}\n}\n\n\n \nstatic void bnx2i_ring_sq_dbell(struct bnx2i_conn *bnx2i_conn, int count)\n{\n\tstruct bnx2i_5771x_sq_rq_db *sq_db;\n\tstruct bnx2i_endpoint *ep = bnx2i_conn->ep;\n\n\tatomic_inc(&ep->num_active_cmds);\n\twmb();\t \n\tif (test_bit(BNX2I_NX2_DEV_57710, &ep->hba->cnic_dev_type)) {\n\t\tsq_db = (struct bnx2i_5771x_sq_rq_db *) ep->qp.sq_pgtbl_virt;\n\t\tsq_db->prod_idx = ep->qp.sq_prod_idx;\n\t\tbnx2i_ring_577xx_doorbell(bnx2i_conn);\n\t} else\n\t\twritew(count, ep->qp.ctx_base + CNIC_SEND_DOORBELL);\n}\n\n\n \nstatic void bnx2i_ring_dbell_update_sq_params(struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t\t      int count)\n{\n\tint tmp_cnt;\n\n\tif (count == 1) {\n\t\tif (bnx2i_conn->ep->qp.sq_prod_qe ==\n\t\t    bnx2i_conn->ep->qp.sq_last_qe)\n\t\t\tbnx2i_conn->ep->qp.sq_prod_qe =\n\t\t\t\t\t\tbnx2i_conn->ep->qp.sq_first_qe;\n\t\telse\n\t\t\tbnx2i_conn->ep->qp.sq_prod_qe++;\n\t} else {\n\t\tif ((bnx2i_conn->ep->qp.sq_prod_qe + count) <=\n\t\t    bnx2i_conn->ep->qp.sq_last_qe)\n\t\t\tbnx2i_conn->ep->qp.sq_prod_qe += count;\n\t\telse {\n\t\t\ttmp_cnt = bnx2i_conn->ep->qp.sq_last_qe -\n\t\t\t\tbnx2i_conn->ep->qp.sq_prod_qe;\n\t\t\tbnx2i_conn->ep->qp.sq_prod_qe =\n\t\t\t\t&bnx2i_conn->ep->qp.sq_first_qe[count -\n\t\t\t\t\t\t\t\t(tmp_cnt + 1)];\n\t\t}\n\t}\n\tbnx2i_conn->ep->qp.sq_prod_idx += count;\n\t \n\tbnx2i_ring_sq_dbell(bnx2i_conn, bnx2i_conn->ep->qp.sq_prod_idx);\n}\n\n\n \nint bnx2i_send_iscsi_login(struct bnx2i_conn *bnx2i_conn,\n\t\t\t   struct iscsi_task *task)\n{\n\tstruct bnx2i_login_request *login_wqe;\n\tstruct iscsi_login_req *login_hdr;\n\tu32 dword;\n\n\tlogin_hdr = (struct iscsi_login_req *)task->hdr;\n\tlogin_wqe = (struct bnx2i_login_request *)\n\t\t\t\t\t\tbnx2i_conn->ep->qp.sq_prod_qe;\n\n\tlogin_wqe->op_code = login_hdr->opcode;\n\tlogin_wqe->op_attr = login_hdr->flags;\n\tlogin_wqe->version_max = login_hdr->max_version;\n\tlogin_wqe->version_min = login_hdr->min_version;\n\tlogin_wqe->data_length = ntoh24(login_hdr->dlength);\n\tlogin_wqe->isid_lo = *((u32 *) login_hdr->isid);\n\tlogin_wqe->isid_hi = *((u16 *) login_hdr->isid + 2);\n\tlogin_wqe->tsih = login_hdr->tsih;\n\tlogin_wqe->itt = task->itt |\n\t\t(ISCSI_TASK_TYPE_MPATH << ISCSI_LOGIN_REQUEST_TYPE_SHIFT);\n\tlogin_wqe->cid = login_hdr->cid;\n\n\tlogin_wqe->cmd_sn = be32_to_cpu(login_hdr->cmdsn);\n\tlogin_wqe->exp_stat_sn = be32_to_cpu(login_hdr->exp_statsn);\n\tlogin_wqe->flags = ISCSI_LOGIN_REQUEST_UPDATE_EXP_STAT_SN;\n\n\tlogin_wqe->resp_bd_list_addr_lo = (u32) bnx2i_conn->gen_pdu.resp_bd_dma;\n\tlogin_wqe->resp_bd_list_addr_hi =\n\t\t(u32) ((u64) bnx2i_conn->gen_pdu.resp_bd_dma >> 32);\n\n\tdword = ((1 << ISCSI_LOGIN_REQUEST_NUM_RESP_BDS_SHIFT) |\n\t\t (bnx2i_conn->gen_pdu.resp_buf_size <<\n\t\t  ISCSI_LOGIN_REQUEST_RESP_BUFFER_LENGTH_SHIFT));\n\tlogin_wqe->resp_buffer = dword;\n\tlogin_wqe->bd_list_addr_lo = (u32) bnx2i_conn->gen_pdu.req_bd_dma;\n\tlogin_wqe->bd_list_addr_hi =\n\t\t(u32) ((u64) bnx2i_conn->gen_pdu.req_bd_dma >> 32);\n\tlogin_wqe->num_bds = 1;\n\tlogin_wqe->cq_index = 0;  \n\n\tbnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);\n\treturn 0;\n}\n\n \nint bnx2i_send_iscsi_tmf(struct bnx2i_conn *bnx2i_conn,\n\t\t\t struct iscsi_task *mtask)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct iscsi_tm *tmfabort_hdr;\n\tstruct scsi_cmnd *ref_sc;\n\tstruct iscsi_task *ctask;\n\tstruct bnx2i_tmf_request *tmfabort_wqe;\n\tu32 dword;\n\tu32 scsi_lun[2];\n\n\ttmfabort_hdr = (struct iscsi_tm *)mtask->hdr;\n\ttmfabort_wqe = (struct bnx2i_tmf_request *)\n\t\t\t\t\t\tbnx2i_conn->ep->qp.sq_prod_qe;\n\n\ttmfabort_wqe->op_code = tmfabort_hdr->opcode;\n\ttmfabort_wqe->op_attr = tmfabort_hdr->flags;\n\n\ttmfabort_wqe->itt = (mtask->itt | (ISCSI_TASK_TYPE_MPATH << 14));\n\ttmfabort_wqe->reserved2 = 0;\n\ttmfabort_wqe->cmd_sn = be32_to_cpu(tmfabort_hdr->cmdsn);\n\n\tswitch (tmfabort_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK) {\n\tcase ISCSI_TM_FUNC_ABORT_TASK:\n\tcase ISCSI_TM_FUNC_TASK_REASSIGN:\n\t\tctask = iscsi_itt_to_task(conn, tmfabort_hdr->rtt);\n\t\tif (!ctask || !ctask->sc)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tref_sc = ctask->sc;\n\t\tif (ref_sc->sc_data_direction == DMA_TO_DEVICE)\n\t\t\tdword = (ISCSI_TASK_TYPE_WRITE <<\n\t\t\t\t ISCSI_CMD_REQUEST_TYPE_SHIFT);\n\t\telse\n\t\t\tdword = (ISCSI_TASK_TYPE_READ <<\n\t\t\t\t ISCSI_CMD_REQUEST_TYPE_SHIFT);\n\t\ttmfabort_wqe->ref_itt = (dword |\n\t\t\t\t\t(tmfabort_hdr->rtt & ISCSI_ITT_MASK));\n\t\tbreak;\n\tdefault:\n\t\ttmfabort_wqe->ref_itt = RESERVED_ITT;\n\t}\n\tmemcpy(scsi_lun, &tmfabort_hdr->lun, sizeof(struct scsi_lun));\n\ttmfabort_wqe->lun[0] = be32_to_cpu(scsi_lun[0]);\n\ttmfabort_wqe->lun[1] = be32_to_cpu(scsi_lun[1]);\n\n\ttmfabort_wqe->ref_cmd_sn = be32_to_cpu(tmfabort_hdr->refcmdsn);\n\n\ttmfabort_wqe->bd_list_addr_lo = (u32) bnx2i_conn->hba->mp_bd_dma;\n\ttmfabort_wqe->bd_list_addr_hi = (u32)\n\t\t\t\t((u64) bnx2i_conn->hba->mp_bd_dma >> 32);\n\ttmfabort_wqe->num_bds = 1;\n\ttmfabort_wqe->cq_index = 0;  \n\n\tbnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);\n\treturn 0;\n}\n\n \nint bnx2i_send_iscsi_text(struct bnx2i_conn *bnx2i_conn,\n\t\t\t  struct iscsi_task *mtask)\n{\n\tstruct bnx2i_text_request *text_wqe;\n\tstruct iscsi_text *text_hdr;\n\tu32 dword;\n\n\ttext_hdr = (struct iscsi_text *)mtask->hdr;\n\ttext_wqe = (struct bnx2i_text_request *) bnx2i_conn->ep->qp.sq_prod_qe;\n\n\tmemset(text_wqe, 0, sizeof(struct bnx2i_text_request));\n\n\ttext_wqe->op_code = text_hdr->opcode;\n\ttext_wqe->op_attr = text_hdr->flags;\n\ttext_wqe->data_length = ntoh24(text_hdr->dlength);\n\ttext_wqe->itt = mtask->itt |\n\t\t(ISCSI_TASK_TYPE_MPATH << ISCSI_TEXT_REQUEST_TYPE_SHIFT);\n\ttext_wqe->ttt = be32_to_cpu(text_hdr->ttt);\n\n\ttext_wqe->cmd_sn = be32_to_cpu(text_hdr->cmdsn);\n\n\ttext_wqe->resp_bd_list_addr_lo = (u32) bnx2i_conn->gen_pdu.resp_bd_dma;\n\ttext_wqe->resp_bd_list_addr_hi =\n\t\t\t(u32) ((u64) bnx2i_conn->gen_pdu.resp_bd_dma >> 32);\n\n\tdword = ((1 << ISCSI_TEXT_REQUEST_NUM_RESP_BDS_SHIFT) |\n\t\t (bnx2i_conn->gen_pdu.resp_buf_size <<\n\t\t  ISCSI_TEXT_REQUEST_RESP_BUFFER_LENGTH_SHIFT));\n\ttext_wqe->resp_buffer = dword;\n\ttext_wqe->bd_list_addr_lo = (u32) bnx2i_conn->gen_pdu.req_bd_dma;\n\ttext_wqe->bd_list_addr_hi =\n\t\t\t(u32) ((u64) bnx2i_conn->gen_pdu.req_bd_dma >> 32);\n\ttext_wqe->num_bds = 1;\n\ttext_wqe->cq_index = 0;  \n\n\tbnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);\n\treturn 0;\n}\n\n\n \nint bnx2i_send_iscsi_scsicmd(struct bnx2i_conn *bnx2i_conn,\n\t\t\t     struct bnx2i_cmd *cmd)\n{\n\tstruct bnx2i_cmd_request *scsi_cmd_wqe;\n\n\tscsi_cmd_wqe = (struct bnx2i_cmd_request *)\n\t\t\t\t\t\tbnx2i_conn->ep->qp.sq_prod_qe;\n\tmemcpy(scsi_cmd_wqe, &cmd->req, sizeof(struct bnx2i_cmd_request));\n\tscsi_cmd_wqe->cq_index = 0;  \n\n\tbnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);\n\treturn 0;\n}\n\n \nint bnx2i_send_iscsi_nopout(struct bnx2i_conn *bnx2i_conn,\n\t\t\t    struct iscsi_task *task,\n\t\t\t    char *datap, int data_len, int unsol)\n{\n\tstruct bnx2i_endpoint *ep = bnx2i_conn->ep;\n\tstruct bnx2i_nop_out_request *nopout_wqe;\n\tstruct iscsi_nopout *nopout_hdr;\n\n\tnopout_hdr = (struct iscsi_nopout *)task->hdr;\n\tnopout_wqe = (struct bnx2i_nop_out_request *)ep->qp.sq_prod_qe;\n\n\tmemset(nopout_wqe, 0x00, sizeof(struct bnx2i_nop_out_request));\n\n\tnopout_wqe->op_code = nopout_hdr->opcode;\n\tnopout_wqe->op_attr = ISCSI_FLAG_CMD_FINAL;\n\tmemcpy(nopout_wqe->lun, &nopout_hdr->lun, 8);\n\n\t \n\tif (test_bit(BNX2I_NX2_DEV_57710, &ep->hba->cnic_dev_type))\n\t\tswap(nopout_wqe->lun[0], nopout_wqe->lun[1]);\n\n\tnopout_wqe->itt = ((u16)task->itt |\n\t\t\t   (ISCSI_TASK_TYPE_MPATH <<\n\t\t\t    ISCSI_TMF_REQUEST_TYPE_SHIFT));\n\tnopout_wqe->ttt = be32_to_cpu(nopout_hdr->ttt);\n\tnopout_wqe->flags = 0;\n\tif (!unsol)\n\t\tnopout_wqe->flags = ISCSI_NOP_OUT_REQUEST_LOCAL_COMPLETION;\n\telse if (nopout_hdr->itt == RESERVED_ITT)\n\t\tnopout_wqe->flags = ISCSI_NOP_OUT_REQUEST_LOCAL_COMPLETION;\n\n\tnopout_wqe->cmd_sn = be32_to_cpu(nopout_hdr->cmdsn);\n\tnopout_wqe->data_length = data_len;\n\tif (data_len) {\n\t\t \n\t\tprintk(KERN_ALERT \"NOPOUT: WARNING!! payload len != 0\\n\");\n\t} else {\n\t\tnopout_wqe->bd_list_addr_lo = (u32)\n\t\t\t\t\tbnx2i_conn->hba->mp_bd_dma;\n\t\tnopout_wqe->bd_list_addr_hi =\n\t\t\t(u32) ((u64) bnx2i_conn->hba->mp_bd_dma >> 32);\n\t\tnopout_wqe->num_bds = 1;\n\t}\n\tnopout_wqe->cq_index = 0;  \n\n\tbnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);\n\treturn 0;\n}\n\n\n \nint bnx2i_send_iscsi_logout(struct bnx2i_conn *bnx2i_conn,\n\t\t\t    struct iscsi_task *task)\n{\n\tstruct bnx2i_logout_request *logout_wqe;\n\tstruct iscsi_logout *logout_hdr;\n\n\tlogout_hdr = (struct iscsi_logout *)task->hdr;\n\n\tlogout_wqe = (struct bnx2i_logout_request *)\n\t\t\t\t\t\tbnx2i_conn->ep->qp.sq_prod_qe;\n\tmemset(logout_wqe, 0x00, sizeof(struct bnx2i_logout_request));\n\n\tlogout_wqe->op_code = logout_hdr->opcode;\n\tlogout_wqe->cmd_sn = be32_to_cpu(logout_hdr->cmdsn);\n\tlogout_wqe->op_attr =\n\t\t\tlogout_hdr->flags | ISCSI_LOGOUT_REQUEST_ALWAYS_ONE;\n\tlogout_wqe->itt = ((u16)task->itt |\n\t\t\t   (ISCSI_TASK_TYPE_MPATH <<\n\t\t\t    ISCSI_LOGOUT_REQUEST_TYPE_SHIFT));\n\tlogout_wqe->data_length = 0;\n\tlogout_wqe->cid = 0;\n\n\tlogout_wqe->bd_list_addr_lo = (u32) bnx2i_conn->hba->mp_bd_dma;\n\tlogout_wqe->bd_list_addr_hi = (u32)\n\t\t\t\t((u64) bnx2i_conn->hba->mp_bd_dma >> 32);\n\tlogout_wqe->num_bds = 1;\n\tlogout_wqe->cq_index = 0;  \n\n\tbnx2i_conn->ep->state = EP_STATE_LOGOUT_SENT;\n\n\tbnx2i_ring_dbell_update_sq_params(bnx2i_conn, 1);\n\treturn 0;\n}\n\n\n \nvoid bnx2i_update_iscsi_conn(struct iscsi_conn *conn)\n{\n\tstruct bnx2i_conn *bnx2i_conn = conn->dd_data;\n\tstruct bnx2i_hba *hba = bnx2i_conn->hba;\n\tstruct kwqe *kwqe_arr[2];\n\tstruct iscsi_kwqe_conn_update *update_wqe;\n\tstruct iscsi_kwqe_conn_update conn_update_kwqe;\n\n\tupdate_wqe = &conn_update_kwqe;\n\n\tupdate_wqe->hdr.op_code = ISCSI_KWQE_OPCODE_UPDATE_CONN;\n\tupdate_wqe->hdr.flags =\n\t\t(ISCSI_KWQE_LAYER_CODE << ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);\n\n\t \n\tif (test_bit(BNX2I_NX2_DEV_57710, &bnx2i_conn->ep->hba->cnic_dev_type))\n\t\tupdate_wqe->context_id = bnx2i_conn->ep->ep_cid;\n\telse\n\t\tupdate_wqe->context_id = (bnx2i_conn->ep->ep_cid >> 7);\n\tupdate_wqe->conn_flags = 0;\n\tif (conn->hdrdgst_en)\n\t\tupdate_wqe->conn_flags |= ISCSI_KWQE_CONN_UPDATE_HEADER_DIGEST;\n\tif (conn->datadgst_en)\n\t\tupdate_wqe->conn_flags |= ISCSI_KWQE_CONN_UPDATE_DATA_DIGEST;\n\tif (conn->session->initial_r2t_en)\n\t\tupdate_wqe->conn_flags |= ISCSI_KWQE_CONN_UPDATE_INITIAL_R2T;\n\tif (conn->session->imm_data_en)\n\t\tupdate_wqe->conn_flags |= ISCSI_KWQE_CONN_UPDATE_IMMEDIATE_DATA;\n\n\tupdate_wqe->max_send_pdu_length = conn->max_xmit_dlength;\n\tupdate_wqe->max_recv_pdu_length = conn->max_recv_dlength;\n\tupdate_wqe->first_burst_length = conn->session->first_burst;\n\tupdate_wqe->max_burst_length = conn->session->max_burst;\n\tupdate_wqe->exp_stat_sn = conn->exp_statsn;\n\tupdate_wqe->max_outstanding_r2ts = conn->session->max_r2t;\n\tupdate_wqe->session_error_recovery_level = conn->session->erl;\n\tiscsi_conn_printk(KERN_ALERT, conn,\n\t\t\t  \"bnx2i: conn update - MBL 0x%x FBL 0x%x\"\n\t\t\t  \"MRDSL_I 0x%x MRDSL_T 0x%x \\n\",\n\t\t\t  update_wqe->max_burst_length,\n\t\t\t  update_wqe->first_burst_length,\n\t\t\t  update_wqe->max_recv_pdu_length,\n\t\t\t  update_wqe->max_send_pdu_length);\n\n\tkwqe_arr[0] = (struct kwqe *) update_wqe;\n\tif (hba->cnic && hba->cnic->submit_kwqes)\n\t\thba->cnic->submit_kwqes(hba->cnic, kwqe_arr, 1);\n}\n\n\n \nvoid bnx2i_ep_ofld_timer(struct timer_list *t)\n{\n\tstruct bnx2i_endpoint *ep = from_timer(ep, t, ofld_timer);\n\n\tif (ep->state == EP_STATE_OFLD_START) {\n\t\tprintk(KERN_ALERT \"ofld_timer: CONN_OFLD timeout\\n\");\n\t\tep->state = EP_STATE_OFLD_FAILED;\n\t} else if (ep->state == EP_STATE_DISCONN_START) {\n\t\tprintk(KERN_ALERT \"ofld_timer: CONN_DISCON timeout\\n\");\n\t\tep->state = EP_STATE_DISCONN_TIMEDOUT;\n\t} else if (ep->state == EP_STATE_CLEANUP_START) {\n\t\tprintk(KERN_ALERT \"ofld_timer: CONN_CLEANUP timeout\\n\");\n\t\tep->state = EP_STATE_CLEANUP_FAILED;\n\t}\n\n\twake_up_interruptible(&ep->ofld_wait);\n}\n\n\nstatic int bnx2i_power_of2(u32 val)\n{\n\tu32 power = 0;\n\tif (val & (val - 1))\n\t\treturn power;\n\tval--;\n\twhile (val) {\n\t\tval = val >> 1;\n\t\tpower++;\n\t}\n\treturn power;\n}\n\n\n \nvoid bnx2i_send_cmd_cleanup_req(struct bnx2i_hba *hba, struct bnx2i_cmd *cmd)\n{\n\tstruct bnx2i_cleanup_request *cmd_cleanup;\n\n\tcmd_cleanup =\n\t\t(struct bnx2i_cleanup_request *)cmd->conn->ep->qp.sq_prod_qe;\n\tmemset(cmd_cleanup, 0x00, sizeof(struct bnx2i_cleanup_request));\n\n\tcmd_cleanup->op_code = ISCSI_OPCODE_CLEANUP_REQUEST;\n\tcmd_cleanup->itt = cmd->req.itt;\n\tcmd_cleanup->cq_index = 0;  \n\n\tbnx2i_ring_dbell_update_sq_params(cmd->conn, 1);\n}\n\n\n \nint bnx2i_send_conn_destroy(struct bnx2i_hba *hba, struct bnx2i_endpoint *ep)\n{\n\tstruct kwqe *kwqe_arr[2];\n\tstruct iscsi_kwqe_conn_destroy conn_cleanup;\n\tint rc = -EINVAL;\n\n\tmemset(&conn_cleanup, 0x00, sizeof(struct iscsi_kwqe_conn_destroy));\n\n\tconn_cleanup.hdr.op_code = ISCSI_KWQE_OPCODE_DESTROY_CONN;\n\tconn_cleanup.hdr.flags =\n\t\t(ISCSI_KWQE_LAYER_CODE << ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);\n\t \n\tif (test_bit(BNX2I_NX2_DEV_57710, &ep->hba->cnic_dev_type))\n\t\tconn_cleanup.context_id = ep->ep_cid;\n\telse\n\t\tconn_cleanup.context_id = (ep->ep_cid >> 7);\n\n\tconn_cleanup.reserved0 = (u16)ep->ep_iscsi_cid;\n\n\tkwqe_arr[0] = (struct kwqe *) &conn_cleanup;\n\tif (hba->cnic && hba->cnic->submit_kwqes)\n\t\trc = hba->cnic->submit_kwqes(hba->cnic, kwqe_arr, 1);\n\n\treturn rc;\n}\n\n\n \nstatic int bnx2i_570x_send_conn_ofld_req(struct bnx2i_hba *hba,\n\t\t\t\t\t struct bnx2i_endpoint *ep)\n{\n\tstruct kwqe *kwqe_arr[2];\n\tstruct iscsi_kwqe_conn_offload1 ofld_req1;\n\tstruct iscsi_kwqe_conn_offload2 ofld_req2;\n\tdma_addr_t dma_addr;\n\tint num_kwqes = 2;\n\tu32 *ptbl;\n\tint rc = -EINVAL;\n\n\tofld_req1.hdr.op_code = ISCSI_KWQE_OPCODE_OFFLOAD_CONN1;\n\tofld_req1.hdr.flags =\n\t\t(ISCSI_KWQE_LAYER_CODE << ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);\n\n\tofld_req1.iscsi_conn_id = (u16) ep->ep_iscsi_cid;\n\n\tdma_addr = ep->qp.sq_pgtbl_phys;\n\tofld_req1.sq_page_table_addr_lo = (u32) dma_addr;\n\tofld_req1.sq_page_table_addr_hi = (u32) ((u64) dma_addr >> 32);\n\n\tdma_addr = ep->qp.cq_pgtbl_phys;\n\tofld_req1.cq_page_table_addr_lo = (u32) dma_addr;\n\tofld_req1.cq_page_table_addr_hi = (u32) ((u64) dma_addr >> 32);\n\n\tofld_req2.hdr.op_code = ISCSI_KWQE_OPCODE_OFFLOAD_CONN2;\n\tofld_req2.hdr.flags =\n\t\t(ISCSI_KWQE_LAYER_CODE << ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);\n\n\tdma_addr = ep->qp.rq_pgtbl_phys;\n\tofld_req2.rq_page_table_addr_lo = (u32) dma_addr;\n\tofld_req2.rq_page_table_addr_hi = (u32) ((u64) dma_addr >> 32);\n\n\tptbl = (u32 *) ep->qp.sq_pgtbl_virt;\n\n\tofld_req2.sq_first_pte.hi = *ptbl++;\n\tofld_req2.sq_first_pte.lo = *ptbl;\n\n\tptbl = (u32 *) ep->qp.cq_pgtbl_virt;\n\tofld_req2.cq_first_pte.hi = *ptbl++;\n\tofld_req2.cq_first_pte.lo = *ptbl;\n\n\tkwqe_arr[0] = (struct kwqe *) &ofld_req1;\n\tkwqe_arr[1] = (struct kwqe *) &ofld_req2;\n\tofld_req2.num_additional_wqes = 0;\n\n\tif (hba->cnic && hba->cnic->submit_kwqes)\n\t\trc = hba->cnic->submit_kwqes(hba->cnic, kwqe_arr, num_kwqes);\n\n\treturn rc;\n}\n\n\n \nstatic int bnx2i_5771x_send_conn_ofld_req(struct bnx2i_hba *hba,\n\t\t\t\t\t  struct bnx2i_endpoint *ep)\n{\n\tstruct kwqe *kwqe_arr[5];\n\tstruct iscsi_kwqe_conn_offload1 ofld_req1;\n\tstruct iscsi_kwqe_conn_offload2 ofld_req2;\n\tstruct iscsi_kwqe_conn_offload3 ofld_req3[1];\n\tdma_addr_t dma_addr;\n\tint num_kwqes = 2;\n\tu32 *ptbl;\n\tint rc = -EINVAL;\n\n\tofld_req1.hdr.op_code = ISCSI_KWQE_OPCODE_OFFLOAD_CONN1;\n\tofld_req1.hdr.flags =\n\t\t(ISCSI_KWQE_LAYER_CODE << ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);\n\n\tofld_req1.iscsi_conn_id = (u16) ep->ep_iscsi_cid;\n\n\tdma_addr = ep->qp.sq_pgtbl_phys + ISCSI_SQ_DB_SIZE;\n\tofld_req1.sq_page_table_addr_lo = (u32) dma_addr;\n\tofld_req1.sq_page_table_addr_hi = (u32) ((u64) dma_addr >> 32);\n\n\tdma_addr = ep->qp.cq_pgtbl_phys + ISCSI_CQ_DB_SIZE;\n\tofld_req1.cq_page_table_addr_lo = (u32) dma_addr;\n\tofld_req1.cq_page_table_addr_hi = (u32) ((u64) dma_addr >> 32);\n\n\tofld_req2.hdr.op_code = ISCSI_KWQE_OPCODE_OFFLOAD_CONN2;\n\tofld_req2.hdr.flags =\n\t\t(ISCSI_KWQE_LAYER_CODE << ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);\n\n\tdma_addr = ep->qp.rq_pgtbl_phys + ISCSI_RQ_DB_SIZE;\n\tofld_req2.rq_page_table_addr_lo = (u32) dma_addr;\n\tofld_req2.rq_page_table_addr_hi = (u32) ((u64) dma_addr >> 32);\n\n\tptbl = (u32 *)((u8 *)ep->qp.sq_pgtbl_virt + ISCSI_SQ_DB_SIZE);\n\tofld_req2.sq_first_pte.hi = *ptbl++;\n\tofld_req2.sq_first_pte.lo = *ptbl;\n\n\tptbl = (u32 *)((u8 *)ep->qp.cq_pgtbl_virt + ISCSI_CQ_DB_SIZE);\n\tofld_req2.cq_first_pte.hi = *ptbl++;\n\tofld_req2.cq_first_pte.lo = *ptbl;\n\n\tkwqe_arr[0] = (struct kwqe *) &ofld_req1;\n\tkwqe_arr[1] = (struct kwqe *) &ofld_req2;\n\n\tofld_req2.num_additional_wqes = 1;\n\tmemset(ofld_req3, 0x00, sizeof(ofld_req3[0]));\n\tptbl = (u32 *)((u8 *)ep->qp.rq_pgtbl_virt + ISCSI_RQ_DB_SIZE);\n\tofld_req3[0].qp_first_pte[0].hi = *ptbl++;\n\tofld_req3[0].qp_first_pte[0].lo = *ptbl;\n\n\tkwqe_arr[2] = (struct kwqe *) ofld_req3;\n\t \n\tnum_kwqes += 1;\n\n\tif (hba->cnic && hba->cnic->submit_kwqes)\n\t\trc = hba->cnic->submit_kwqes(hba->cnic, kwqe_arr, num_kwqes);\n\n\treturn rc;\n}\n\n \nint bnx2i_send_conn_ofld_req(struct bnx2i_hba *hba, struct bnx2i_endpoint *ep)\n{\n\tint rc;\n\n\tif (test_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type))\n\t\trc = bnx2i_5771x_send_conn_ofld_req(hba, ep);\n\telse\n\t\trc = bnx2i_570x_send_conn_ofld_req(hba, ep);\n\n\treturn rc;\n}\n\n\n \nstatic void setup_qp_page_tables(struct bnx2i_endpoint *ep)\n{\n\tint num_pages;\n\tu32 *ptbl;\n\tdma_addr_t page;\n\tint cnic_dev_10g;\n\n\tif (test_bit(BNX2I_NX2_DEV_57710, &ep->hba->cnic_dev_type))\n\t\tcnic_dev_10g = 1;\n\telse\n\t\tcnic_dev_10g = 0;\n\n\t \n\tmemset(ep->qp.sq_pgtbl_virt, 0, ep->qp.sq_pgtbl_size);\n\tnum_pages = ep->qp.sq_mem_size / CNIC_PAGE_SIZE;\n\tpage = ep->qp.sq_phys;\n\n\tif (cnic_dev_10g)\n\t\tptbl = (u32 *)((u8 *)ep->qp.sq_pgtbl_virt + ISCSI_SQ_DB_SIZE);\n\telse\n\t\tptbl = (u32 *) ep->qp.sq_pgtbl_virt;\n\twhile (num_pages--) {\n\t\tif (cnic_dev_10g) {\n\t\t\t \n\t\t\t*ptbl = (u32) page;\n\t\t\tptbl++;\n\t\t\t*ptbl = (u32) ((u64) page >> 32);\n\t\t\tptbl++;\n\t\t\tpage += CNIC_PAGE_SIZE;\n\t\t} else {\n\t\t\t \n\t\t\t*ptbl = (u32) ((u64) page >> 32);\n\t\t\tptbl++;\n\t\t\t*ptbl = (u32) page;\n\t\t\tptbl++;\n\t\t\tpage += CNIC_PAGE_SIZE;\n\t\t}\n\t}\n\n\t \n\tmemset(ep->qp.rq_pgtbl_virt, 0, ep->qp.rq_pgtbl_size);\n\tnum_pages = ep->qp.rq_mem_size / CNIC_PAGE_SIZE;\n\tpage = ep->qp.rq_phys;\n\n\tif (cnic_dev_10g)\n\t\tptbl = (u32 *)((u8 *)ep->qp.rq_pgtbl_virt + ISCSI_RQ_DB_SIZE);\n\telse\n\t\tptbl = (u32 *) ep->qp.rq_pgtbl_virt;\n\twhile (num_pages--) {\n\t\tif (cnic_dev_10g) {\n\t\t\t \n\t\t\t*ptbl = (u32) page;\n\t\t\tptbl++;\n\t\t\t*ptbl = (u32) ((u64) page >> 32);\n\t\t\tptbl++;\n\t\t\tpage += CNIC_PAGE_SIZE;\n\t\t} else {\n\t\t\t \n\t\t\t*ptbl = (u32) ((u64) page >> 32);\n\t\t\tptbl++;\n\t\t\t*ptbl = (u32) page;\n\t\t\tptbl++;\n\t\t\tpage += CNIC_PAGE_SIZE;\n\t\t}\n\t}\n\n\t \n\tmemset(ep->qp.cq_pgtbl_virt, 0, ep->qp.cq_pgtbl_size);\n\tnum_pages = ep->qp.cq_mem_size / CNIC_PAGE_SIZE;\n\tpage = ep->qp.cq_phys;\n\n\tif (cnic_dev_10g)\n\t\tptbl = (u32 *)((u8 *)ep->qp.cq_pgtbl_virt + ISCSI_CQ_DB_SIZE);\n\telse\n\t\tptbl = (u32 *) ep->qp.cq_pgtbl_virt;\n\twhile (num_pages--) {\n\t\tif (cnic_dev_10g) {\n\t\t\t \n\t\t\t*ptbl = (u32) page;\n\t\t\tptbl++;\n\t\t\t*ptbl = (u32) ((u64) page >> 32);\n\t\t\tptbl++;\n\t\t\tpage += CNIC_PAGE_SIZE;\n\t\t} else {\n\t\t\t \n\t\t\t*ptbl = (u32) ((u64) page >> 32);\n\t\t\tptbl++;\n\t\t\t*ptbl = (u32) page;\n\t\t\tptbl++;\n\t\t\tpage += CNIC_PAGE_SIZE;\n\t\t}\n\t}\n}\n\n\n \nint bnx2i_alloc_qp_resc(struct bnx2i_hba *hba, struct bnx2i_endpoint *ep)\n{\n\tstruct bnx2i_5771x_cq_db *cq_db;\n\n\tep->hba = hba;\n\tep->conn = NULL;\n\tep->ep_cid = ep->ep_iscsi_cid = ep->ep_pg_cid = 0;\n\n\t \n\tep->qp.sq_mem_size = hba->max_sqes * BNX2I_SQ_WQE_SIZE;\n\tep->qp.sq_mem_size =\n\t\t(ep->qp.sq_mem_size + (CNIC_PAGE_SIZE - 1)) & CNIC_PAGE_MASK;\n\tep->qp.sq_pgtbl_size =\n\t\t(ep->qp.sq_mem_size / CNIC_PAGE_SIZE) * sizeof(void *);\n\tep->qp.sq_pgtbl_size =\n\t\t(ep->qp.sq_pgtbl_size + (CNIC_PAGE_SIZE - 1)) & CNIC_PAGE_MASK;\n\n\tep->qp.sq_pgtbl_virt =\n\t\tdma_alloc_coherent(&hba->pcidev->dev, ep->qp.sq_pgtbl_size,\n\t\t\t\t   &ep->qp.sq_pgtbl_phys, GFP_KERNEL);\n\tif (!ep->qp.sq_pgtbl_virt) {\n\t\tprintk(KERN_ALERT \"bnx2i: unable to alloc SQ PT mem (%d)\\n\",\n\t\t\t\t  ep->qp.sq_pgtbl_size);\n\t\tgoto mem_alloc_err;\n\t}\n\n\t \n\tep->qp.sq_virt =\n\t\tdma_alloc_coherent(&hba->pcidev->dev, ep->qp.sq_mem_size,\n\t\t\t\t   &ep->qp.sq_phys, GFP_KERNEL);\n\tif (!ep->qp.sq_virt) {\n\t\tprintk(KERN_ALERT \"bnx2i: unable to alloc SQ BD memory %d\\n\",\n\t\t\t\t  ep->qp.sq_mem_size);\n\t\tgoto mem_alloc_err;\n\t}\n\n\tep->qp.sq_first_qe = ep->qp.sq_virt;\n\tep->qp.sq_prod_qe = ep->qp.sq_first_qe;\n\tep->qp.sq_cons_qe = ep->qp.sq_first_qe;\n\tep->qp.sq_last_qe = &ep->qp.sq_first_qe[hba->max_sqes - 1];\n\tep->qp.sq_prod_idx = 0;\n\tep->qp.sq_cons_idx = 0;\n\tep->qp.sqe_left = hba->max_sqes;\n\n\t \n\tep->qp.cq_mem_size = hba->max_cqes * BNX2I_CQE_SIZE;\n\tep->qp.cq_mem_size =\n\t\t(ep->qp.cq_mem_size + (CNIC_PAGE_SIZE - 1)) & CNIC_PAGE_MASK;\n\tep->qp.cq_pgtbl_size =\n\t\t(ep->qp.cq_mem_size / CNIC_PAGE_SIZE) * sizeof(void *);\n\tep->qp.cq_pgtbl_size =\n\t\t(ep->qp.cq_pgtbl_size + (CNIC_PAGE_SIZE - 1)) & CNIC_PAGE_MASK;\n\n\tep->qp.cq_pgtbl_virt =\n\t\tdma_alloc_coherent(&hba->pcidev->dev, ep->qp.cq_pgtbl_size,\n\t\t\t\t   &ep->qp.cq_pgtbl_phys, GFP_KERNEL);\n\tif (!ep->qp.cq_pgtbl_virt) {\n\t\tprintk(KERN_ALERT \"bnx2i: unable to alloc CQ PT memory %d\\n\",\n\t\t\t\t  ep->qp.cq_pgtbl_size);\n\t\tgoto mem_alloc_err;\n\t}\n\n\t \n\tep->qp.cq_virt =\n\t\tdma_alloc_coherent(&hba->pcidev->dev, ep->qp.cq_mem_size,\n\t\t\t\t   &ep->qp.cq_phys, GFP_KERNEL);\n\tif (!ep->qp.cq_virt) {\n\t\tprintk(KERN_ALERT \"bnx2i: unable to alloc CQ BD memory %d\\n\",\n\t\t\t\t  ep->qp.cq_mem_size);\n\t\tgoto mem_alloc_err;\n\t}\n\n\tep->qp.cq_first_qe = ep->qp.cq_virt;\n\tep->qp.cq_prod_qe = ep->qp.cq_first_qe;\n\tep->qp.cq_cons_qe = ep->qp.cq_first_qe;\n\tep->qp.cq_last_qe = &ep->qp.cq_first_qe[hba->max_cqes - 1];\n\tep->qp.cq_prod_idx = 0;\n\tep->qp.cq_cons_idx = 0;\n\tep->qp.cqe_left = hba->max_cqes;\n\tep->qp.cqe_exp_seq_sn = ISCSI_INITIAL_SN;\n\tep->qp.cqe_size = hba->max_cqes;\n\n\t \n\tcq_db = (struct bnx2i_5771x_cq_db *) ep->qp.cq_pgtbl_virt;\n\tmemset(cq_db->sqn, 0xFF, sizeof(cq_db->sqn[0]) * BNX2X_MAX_CQS);\n\n\t \n\tep->qp.rq_mem_size = hba->max_rqes * BNX2I_RQ_WQE_SIZE;\n\tep->qp.rq_mem_size =\n\t\t(ep->qp.rq_mem_size + (CNIC_PAGE_SIZE - 1)) & CNIC_PAGE_MASK;\n\tep->qp.rq_pgtbl_size =\n\t\t(ep->qp.rq_mem_size / CNIC_PAGE_SIZE) * sizeof(void *);\n\tep->qp.rq_pgtbl_size =\n\t\t(ep->qp.rq_pgtbl_size + (CNIC_PAGE_SIZE - 1)) & CNIC_PAGE_MASK;\n\n\tep->qp.rq_pgtbl_virt =\n\t\tdma_alloc_coherent(&hba->pcidev->dev, ep->qp.rq_pgtbl_size,\n\t\t\t\t   &ep->qp.rq_pgtbl_phys, GFP_KERNEL);\n\tif (!ep->qp.rq_pgtbl_virt) {\n\t\tprintk(KERN_ALERT \"bnx2i: unable to alloc RQ PT mem %d\\n\",\n\t\t\t\t  ep->qp.rq_pgtbl_size);\n\t\tgoto mem_alloc_err;\n\t}\n\n\t \n\tep->qp.rq_virt =\n\t\tdma_alloc_coherent(&hba->pcidev->dev, ep->qp.rq_mem_size,\n\t\t\t\t   &ep->qp.rq_phys, GFP_KERNEL);\n\tif (!ep->qp.rq_virt) {\n\t\tprintk(KERN_ALERT \"bnx2i: unable to alloc RQ BD memory %d\\n\",\n\t\t\t\t  ep->qp.rq_mem_size);\n\t\tgoto mem_alloc_err;\n\t}\n\n\tep->qp.rq_first_qe = ep->qp.rq_virt;\n\tep->qp.rq_prod_qe = ep->qp.rq_first_qe;\n\tep->qp.rq_cons_qe = ep->qp.rq_first_qe;\n\tep->qp.rq_last_qe = &ep->qp.rq_first_qe[hba->max_rqes - 1];\n\tep->qp.rq_prod_idx = 0x8000;\n\tep->qp.rq_cons_idx = 0;\n\tep->qp.rqe_left = hba->max_rqes;\n\n\tsetup_qp_page_tables(ep);\n\n\treturn 0;\n\nmem_alloc_err:\n\tbnx2i_free_qp_resc(hba, ep);\n\treturn -ENOMEM;\n}\n\n\n\n \nvoid bnx2i_free_qp_resc(struct bnx2i_hba *hba, struct bnx2i_endpoint *ep)\n{\n\tif (ep->qp.ctx_base) {\n\t\tiounmap(ep->qp.ctx_base);\n\t\tep->qp.ctx_base = NULL;\n\t}\n\t \n\tif (ep->qp.sq_pgtbl_virt) {\n\t\tdma_free_coherent(&hba->pcidev->dev, ep->qp.sq_pgtbl_size,\n\t\t\t\t  ep->qp.sq_pgtbl_virt, ep->qp.sq_pgtbl_phys);\n\t\tep->qp.sq_pgtbl_virt = NULL;\n\t\tep->qp.sq_pgtbl_phys = 0;\n\t}\n\tif (ep->qp.sq_virt) {\n\t\tdma_free_coherent(&hba->pcidev->dev, ep->qp.sq_mem_size,\n\t\t\t\t  ep->qp.sq_virt, ep->qp.sq_phys);\n\t\tep->qp.sq_virt = NULL;\n\t\tep->qp.sq_phys = 0;\n\t}\n\n\t \n\tif (ep->qp.rq_pgtbl_virt) {\n\t\tdma_free_coherent(&hba->pcidev->dev, ep->qp.rq_pgtbl_size,\n\t\t\t\t  ep->qp.rq_pgtbl_virt, ep->qp.rq_pgtbl_phys);\n\t\tep->qp.rq_pgtbl_virt = NULL;\n\t\tep->qp.rq_pgtbl_phys = 0;\n\t}\n\tif (ep->qp.rq_virt) {\n\t\tdma_free_coherent(&hba->pcidev->dev, ep->qp.rq_mem_size,\n\t\t\t\t  ep->qp.rq_virt, ep->qp.rq_phys);\n\t\tep->qp.rq_virt = NULL;\n\t\tep->qp.rq_phys = 0;\n\t}\n\n\t \n\tif (ep->qp.cq_pgtbl_virt) {\n\t\tdma_free_coherent(&hba->pcidev->dev, ep->qp.cq_pgtbl_size,\n\t\t\t\t  ep->qp.cq_pgtbl_virt, ep->qp.cq_pgtbl_phys);\n\t\tep->qp.cq_pgtbl_virt = NULL;\n\t\tep->qp.cq_pgtbl_phys = 0;\n\t}\n\tif (ep->qp.cq_virt) {\n\t\tdma_free_coherent(&hba->pcidev->dev, ep->qp.cq_mem_size,\n\t\t\t\t  ep->qp.cq_virt, ep->qp.cq_phys);\n\t\tep->qp.cq_virt = NULL;\n\t\tep->qp.cq_phys = 0;\n\t}\n}\n\n\n \nint bnx2i_send_fw_iscsi_init_msg(struct bnx2i_hba *hba)\n{\n\tstruct kwqe *kwqe_arr[3];\n\tstruct iscsi_kwqe_init1 iscsi_init;\n\tstruct iscsi_kwqe_init2 iscsi_init2;\n\tint rc = 0;\n\tu64 mask64;\n\n\tmemset(&iscsi_init, 0x00, sizeof(struct iscsi_kwqe_init1));\n\tmemset(&iscsi_init2, 0x00, sizeof(struct iscsi_kwqe_init2));\n\n\tbnx2i_adjust_qp_size(hba);\n\n\tiscsi_init.flags =\n\t\t(CNIC_PAGE_BITS - 8) << ISCSI_KWQE_INIT1_PAGE_SIZE_SHIFT;\n\tif (en_tcp_dack)\n\t\tiscsi_init.flags |= ISCSI_KWQE_INIT1_DELAYED_ACK_ENABLE;\n\tiscsi_init.reserved0 = 0;\n\tiscsi_init.num_cqs = 1;\n\tiscsi_init.hdr.op_code = ISCSI_KWQE_OPCODE_INIT1;\n\tiscsi_init.hdr.flags =\n\t\t(ISCSI_KWQE_LAYER_CODE << ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);\n\n\tiscsi_init.dummy_buffer_addr_lo = (u32) hba->dummy_buf_dma;\n\tiscsi_init.dummy_buffer_addr_hi =\n\t\t(u32) ((u64) hba->dummy_buf_dma >> 32);\n\n\thba->num_ccell = hba->max_sqes >> 1;\n\thba->ctx_ccell_tasks =\n\t\t\t((hba->num_ccell & 0xFFFF) | (hba->max_sqes << 16));\n\tiscsi_init.num_ccells_per_conn = hba->num_ccell;\n\tiscsi_init.num_tasks_per_conn = hba->max_sqes;\n\tiscsi_init.sq_wqes_per_page = CNIC_PAGE_SIZE / BNX2I_SQ_WQE_SIZE;\n\tiscsi_init.sq_num_wqes = hba->max_sqes;\n\tiscsi_init.cq_log_wqes_per_page =\n\t\t(u8) bnx2i_power_of2(CNIC_PAGE_SIZE / BNX2I_CQE_SIZE);\n\tiscsi_init.cq_num_wqes = hba->max_cqes;\n\tiscsi_init.cq_num_pages = (hba->max_cqes * BNX2I_CQE_SIZE +\n\t\t\t\t   (CNIC_PAGE_SIZE - 1)) / CNIC_PAGE_SIZE;\n\tiscsi_init.sq_num_pages = (hba->max_sqes * BNX2I_SQ_WQE_SIZE +\n\t\t\t\t   (CNIC_PAGE_SIZE - 1)) / CNIC_PAGE_SIZE;\n\tiscsi_init.rq_buffer_size = BNX2I_RQ_WQE_SIZE;\n\tiscsi_init.rq_num_wqes = hba->max_rqes;\n\n\n\tiscsi_init2.hdr.op_code = ISCSI_KWQE_OPCODE_INIT2;\n\tiscsi_init2.hdr.flags =\n\t\t(ISCSI_KWQE_LAYER_CODE << ISCSI_KWQE_HEADER_LAYER_CODE_SHIFT);\n\tiscsi_init2.max_cq_sqn = hba->max_cqes * 2 + 1;\n\tmask64 = 0x0ULL;\n\tmask64 |= (\n\t\t \n\t\t(1UL <<\n\t\t  ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_TTT_NOT_RSRV) |\n\t\t \n\t\t(1UL <<\n\t\t  ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_EXP_DATASN) |\n\t\t \n\t\t(1ULL << ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_LUN));\n\tif (error_mask1) {\n\t\tiscsi_init2.error_bit_map[0] = error_mask1;\n\t\tmask64 ^= (u32)(mask64);\n\t\tmask64 |= error_mask1;\n\t} else\n\t\tiscsi_init2.error_bit_map[0] = (u32) mask64;\n\n\tif (error_mask2) {\n\t\tiscsi_init2.error_bit_map[1] = error_mask2;\n\t\tmask64 &= 0xffffffff;\n\t\tmask64 |= ((u64)error_mask2 << 32);\n\t} else\n\t\tiscsi_init2.error_bit_map[1] = (u32) (mask64 >> 32);\n\n\tiscsi_error_mask = mask64;\n\n\tkwqe_arr[0] = (struct kwqe *) &iscsi_init;\n\tkwqe_arr[1] = (struct kwqe *) &iscsi_init2;\n\n\tif (hba->cnic && hba->cnic->submit_kwqes)\n\t\trc = hba->cnic->submit_kwqes(hba->cnic, kwqe_arr, 2);\n\treturn rc;\n}\n\n\n \nint bnx2i_process_scsi_cmd_resp(struct iscsi_session *session,\n\t\t\t\tstruct bnx2i_conn *bnx2i_conn,\n\t\t\t\tstruct cqe *cqe)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct bnx2i_hba *hba = bnx2i_conn->hba;\n\tstruct bnx2i_cmd_response *resp_cqe;\n\tstruct bnx2i_cmd *bnx2i_cmd;\n\tstruct iscsi_task *task;\n\tstruct iscsi_scsi_rsp *hdr;\n\tu32 datalen = 0;\n\n\tresp_cqe = (struct bnx2i_cmd_response *)cqe;\n\tspin_lock_bh(&session->back_lock);\n\ttask = iscsi_itt_to_task(conn,\n\t\t\t\t resp_cqe->itt & ISCSI_CMD_RESPONSE_INDEX);\n\tif (!task)\n\t\tgoto fail;\n\n\tbnx2i_cmd = task->dd_data;\n\n\tif (bnx2i_cmd->req.op_attr & ISCSI_CMD_REQUEST_READ) {\n\t\tconn->datain_pdus_cnt +=\n\t\t\tresp_cqe->task_stat.read_stat.num_data_ins;\n\t\tconn->rxdata_octets +=\n\t\t\tbnx2i_cmd->req.total_data_transfer_length;\n\t\tADD_STATS_64(hba, rx_pdus,\n\t\t\t     resp_cqe->task_stat.read_stat.num_data_ins);\n\t\tADD_STATS_64(hba, rx_bytes,\n\t\t\t     bnx2i_cmd->req.total_data_transfer_length);\n\t} else {\n\t\tconn->dataout_pdus_cnt +=\n\t\t\tresp_cqe->task_stat.write_stat.num_data_outs;\n\t\tconn->r2t_pdus_cnt +=\n\t\t\tresp_cqe->task_stat.write_stat.num_r2ts;\n\t\tconn->txdata_octets +=\n\t\t\tbnx2i_cmd->req.total_data_transfer_length;\n\t\tADD_STATS_64(hba, tx_pdus,\n\t\t\t     resp_cqe->task_stat.write_stat.num_data_outs);\n\t\tADD_STATS_64(hba, tx_bytes,\n\t\t\t     bnx2i_cmd->req.total_data_transfer_length);\n\t\tADD_STATS_64(hba, rx_pdus,\n\t\t\t     resp_cqe->task_stat.write_stat.num_r2ts);\n\t}\n\tbnx2i_iscsi_unmap_sg_list(bnx2i_cmd);\n\n\thdr = (struct iscsi_scsi_rsp *)task->hdr;\n\tresp_cqe = (struct bnx2i_cmd_response *)cqe;\n\thdr->opcode = resp_cqe->op_code;\n\thdr->max_cmdsn = cpu_to_be32(resp_cqe->max_cmd_sn);\n\thdr->exp_cmdsn = cpu_to_be32(resp_cqe->exp_cmd_sn);\n\thdr->response = resp_cqe->response;\n\thdr->cmd_status = resp_cqe->status;\n\thdr->flags = resp_cqe->response_flags;\n\thdr->residual_count = cpu_to_be32(resp_cqe->residual_count);\n\n\tif (resp_cqe->op_code == ISCSI_OP_SCSI_DATA_IN)\n\t\tgoto done;\n\n\tif (resp_cqe->status == SAM_STAT_CHECK_CONDITION) {\n\t\tdatalen = resp_cqe->data_length;\n\t\tif (datalen < 2)\n\t\t\tgoto done;\n\n\t\tif (datalen > BNX2I_RQ_WQE_SIZE) {\n\t\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t\t  \"sense data len %d > RQ sz\\n\",\n\t\t\t\t\t  datalen);\n\t\t\tdatalen = BNX2I_RQ_WQE_SIZE;\n\t\t} else if (datalen > ISCSI_DEF_MAX_RECV_SEG_LEN) {\n\t\t\tiscsi_conn_printk(KERN_ERR, conn,\n\t\t\t\t\t  \"sense data len %d > conn data\\n\",\n\t\t\t\t\t  datalen);\n\t\t\tdatalen = ISCSI_DEF_MAX_RECV_SEG_LEN;\n\t\t}\n\n\t\tbnx2i_get_rq_buf(bnx2i_cmd->conn, conn->data, datalen);\n\t\tbnx2i_put_rq_buf(bnx2i_cmd->conn, 1);\n\t}\n\ndone:\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr,\n\t\t\t     conn->data, datalen);\nfail:\n\tspin_unlock_bh(&session->back_lock);\n\treturn 0;\n}\n\n\n \nstatic int bnx2i_process_login_resp(struct iscsi_session *session,\n\t\t\t\t    struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t    struct cqe *cqe)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct iscsi_task *task;\n\tstruct bnx2i_login_response *login;\n\tstruct iscsi_login_rsp *resp_hdr;\n\tint pld_len;\n\tint pad_len;\n\n\tlogin = (struct bnx2i_login_response *) cqe;\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_itt_to_task(conn,\n\t\t\t\t login->itt & ISCSI_LOGIN_RESPONSE_INDEX);\n\tif (!task)\n\t\tgoto done;\n\n\tresp_hdr = (struct iscsi_login_rsp *) &bnx2i_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr, 0, sizeof(struct iscsi_hdr));\n\tresp_hdr->opcode = login->op_code;\n\tresp_hdr->flags = login->response_flags;\n\tresp_hdr->max_version = login->version_max;\n\tresp_hdr->active_version = login->version_active;\n\tresp_hdr->hlength = 0;\n\n\thton24(resp_hdr->dlength, login->data_length);\n\tmemcpy(resp_hdr->isid, &login->isid_lo, 6);\n\tresp_hdr->tsih = cpu_to_be16(login->tsih);\n\tresp_hdr->itt = task->hdr->itt;\n\tresp_hdr->statsn = cpu_to_be32(login->stat_sn);\n\tresp_hdr->exp_cmdsn = cpu_to_be32(login->exp_cmd_sn);\n\tresp_hdr->max_cmdsn = cpu_to_be32(login->max_cmd_sn);\n\tresp_hdr->status_class = login->status_class;\n\tresp_hdr->status_detail = login->status_detail;\n\tpld_len = login->data_length;\n\tbnx2i_conn->gen_pdu.resp_wr_ptr =\n\t\t\t\t\tbnx2i_conn->gen_pdu.resp_buf + pld_len;\n\n\tpad_len = 0;\n\tif (pld_len & 0x3)\n\t\tpad_len = 4 - (pld_len % 4);\n\n\tif (pad_len) {\n\t\tint i = 0;\n\t\tfor (i = 0; i < pad_len; i++) {\n\t\t\tbnx2i_conn->gen_pdu.resp_wr_ptr[0] = 0;\n\t\t\tbnx2i_conn->gen_pdu.resp_wr_ptr++;\n\t\t}\n\t}\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr,\n\t\tbnx2i_conn->gen_pdu.resp_buf,\n\t\tbnx2i_conn->gen_pdu.resp_wr_ptr - bnx2i_conn->gen_pdu.resp_buf);\ndone:\n\tspin_unlock(&session->back_lock);\n\treturn 0;\n}\n\n\n \nstatic int bnx2i_process_text_resp(struct iscsi_session *session,\n\t\t\t\t   struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t   struct cqe *cqe)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct iscsi_task *task;\n\tstruct bnx2i_text_response *text;\n\tstruct iscsi_text_rsp *resp_hdr;\n\tint pld_len;\n\tint pad_len;\n\n\ttext = (struct bnx2i_text_response *) cqe;\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_itt_to_task(conn, text->itt & ISCSI_LOGIN_RESPONSE_INDEX);\n\tif (!task)\n\t\tgoto done;\n\n\tresp_hdr = (struct iscsi_text_rsp *)&bnx2i_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr, 0, sizeof(struct iscsi_hdr));\n\tresp_hdr->opcode = text->op_code;\n\tresp_hdr->flags = text->response_flags;\n\tresp_hdr->hlength = 0;\n\n\thton24(resp_hdr->dlength, text->data_length);\n\tresp_hdr->itt = task->hdr->itt;\n\tresp_hdr->ttt = cpu_to_be32(text->ttt);\n\tresp_hdr->statsn = task->hdr->exp_statsn;\n\tresp_hdr->exp_cmdsn = cpu_to_be32(text->exp_cmd_sn);\n\tresp_hdr->max_cmdsn = cpu_to_be32(text->max_cmd_sn);\n\tpld_len = text->data_length;\n\tbnx2i_conn->gen_pdu.resp_wr_ptr = bnx2i_conn->gen_pdu.resp_buf +\n\t\t\t\t\t  pld_len;\n\tpad_len = 0;\n\tif (pld_len & 0x3)\n\t\tpad_len = 4 - (pld_len % 4);\n\n\tif (pad_len) {\n\t\tint i = 0;\n\t\tfor (i = 0; i < pad_len; i++) {\n\t\t\tbnx2i_conn->gen_pdu.resp_wr_ptr[0] = 0;\n\t\t\tbnx2i_conn->gen_pdu.resp_wr_ptr++;\n\t\t}\n\t}\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr,\n\t\t\t     bnx2i_conn->gen_pdu.resp_buf,\n\t\t\t     bnx2i_conn->gen_pdu.resp_wr_ptr -\n\t\t\t     bnx2i_conn->gen_pdu.resp_buf);\ndone:\n\tspin_unlock(&session->back_lock);\n\treturn 0;\n}\n\n\n \nstatic int bnx2i_process_tmf_resp(struct iscsi_session *session,\n\t\t\t\t  struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t  struct cqe *cqe)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct iscsi_task *task;\n\tstruct bnx2i_tmf_response *tmf_cqe;\n\tstruct iscsi_tm_rsp *resp_hdr;\n\n\ttmf_cqe = (struct bnx2i_tmf_response *)cqe;\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_itt_to_task(conn,\n\t\t\t\t tmf_cqe->itt & ISCSI_TMF_RESPONSE_INDEX);\n\tif (!task)\n\t\tgoto done;\n\n\tresp_hdr = (struct iscsi_tm_rsp *) &bnx2i_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr, 0, sizeof(struct iscsi_hdr));\n\tresp_hdr->opcode = tmf_cqe->op_code;\n\tresp_hdr->max_cmdsn = cpu_to_be32(tmf_cqe->max_cmd_sn);\n\tresp_hdr->exp_cmdsn = cpu_to_be32(tmf_cqe->exp_cmd_sn);\n\tresp_hdr->itt = task->hdr->itt;\n\tresp_hdr->response = tmf_cqe->response;\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr, NULL, 0);\ndone:\n\tspin_unlock(&session->back_lock);\n\treturn 0;\n}\n\n \nstatic int bnx2i_process_logout_resp(struct iscsi_session *session,\n\t\t\t\t     struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t     struct cqe *cqe)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct iscsi_task *task;\n\tstruct bnx2i_logout_response *logout;\n\tstruct iscsi_logout_rsp *resp_hdr;\n\n\tlogout = (struct bnx2i_logout_response *) cqe;\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_itt_to_task(conn,\n\t\t\t\t logout->itt & ISCSI_LOGOUT_RESPONSE_INDEX);\n\tif (!task)\n\t\tgoto done;\n\n\tresp_hdr = (struct iscsi_logout_rsp *) &bnx2i_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr, 0, sizeof(struct iscsi_hdr));\n\tresp_hdr->opcode = logout->op_code;\n\tresp_hdr->flags = logout->response;\n\tresp_hdr->hlength = 0;\n\n\tresp_hdr->itt = task->hdr->itt;\n\tresp_hdr->statsn = task->hdr->exp_statsn;\n\tresp_hdr->exp_cmdsn = cpu_to_be32(logout->exp_cmd_sn);\n\tresp_hdr->max_cmdsn = cpu_to_be32(logout->max_cmd_sn);\n\n\tresp_hdr->t2wait = cpu_to_be32(logout->time_to_wait);\n\tresp_hdr->t2retain = cpu_to_be32(logout->time_to_retain);\n\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)resp_hdr, NULL, 0);\n\n\tbnx2i_conn->ep->state = EP_STATE_LOGOUT_RESP_RCVD;\ndone:\n\tspin_unlock(&session->back_lock);\n\treturn 0;\n}\n\n \nstatic void bnx2i_process_nopin_local_cmpl(struct iscsi_session *session,\n\t\t\t\t\t   struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t\t   struct cqe *cqe)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct bnx2i_nop_in_msg *nop_in;\n\tstruct iscsi_task *task;\n\n\tnop_in = (struct bnx2i_nop_in_msg *)cqe;\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_itt_to_task(conn,\n\t\t\t\t nop_in->itt & ISCSI_NOP_IN_MSG_INDEX);\n\tif (task)\n\t\t__iscsi_put_task(task);\n\tspin_unlock(&session->back_lock);\n}\n\n \nstatic void bnx2i_unsol_pdu_adjust_rq(struct bnx2i_conn *bnx2i_conn)\n{\n\tchar dummy_rq_data[2];\n\tbnx2i_get_rq_buf(bnx2i_conn, dummy_rq_data, 1);\n\tbnx2i_put_rq_buf(bnx2i_conn, 1);\n}\n\n\n \nstatic int bnx2i_process_nopin_mesg(struct iscsi_session *session,\n\t\t\t\t     struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t     struct cqe *cqe)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct iscsi_task *task;\n\tstruct bnx2i_nop_in_msg *nop_in;\n\tstruct iscsi_nopin *hdr;\n\tint tgt_async_nop = 0;\n\n\tnop_in = (struct bnx2i_nop_in_msg *)cqe;\n\n\tspin_lock(&session->back_lock);\n\thdr = (struct iscsi_nopin *)&bnx2i_conn->gen_pdu.resp_hdr;\n\tmemset(hdr, 0, sizeof(struct iscsi_hdr));\n\thdr->opcode = nop_in->op_code;\n\thdr->max_cmdsn = cpu_to_be32(nop_in->max_cmd_sn);\n\thdr->exp_cmdsn = cpu_to_be32(nop_in->exp_cmd_sn);\n\thdr->ttt = cpu_to_be32(nop_in->ttt);\n\n\tif (nop_in->itt == (u16) RESERVED_ITT) {\n\t\tbnx2i_unsol_pdu_adjust_rq(bnx2i_conn);\n\t\thdr->itt = RESERVED_ITT;\n\t\ttgt_async_nop = 1;\n\t\tgoto done;\n\t}\n\n\t \n\ttask = iscsi_itt_to_task(conn,\n\t\t\t (itt_t) (nop_in->itt & ISCSI_NOP_IN_MSG_INDEX));\n\tif (task) {\n\t\thdr->flags = ISCSI_FLAG_CMD_FINAL;\n\t\thdr->itt = task->hdr->itt;\n\t\thdr->ttt = cpu_to_be32(nop_in->ttt);\n\t\tmemcpy(&hdr->lun, nop_in->lun, 8);\n\t}\ndone:\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, NULL, 0);\n\tspin_unlock(&session->back_lock);\n\n\treturn tgt_async_nop;\n}\n\n\n \nstatic void bnx2i_process_async_mesg(struct iscsi_session *session,\n\t\t\t\t     struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t     struct cqe *cqe)\n{\n\tstruct bnx2i_async_msg *async_cqe;\n\tstruct iscsi_async *resp_hdr;\n\tu8 async_event;\n\n\tbnx2i_unsol_pdu_adjust_rq(bnx2i_conn);\n\n\tasync_cqe = (struct bnx2i_async_msg *)cqe;\n\tasync_event = async_cqe->async_event;\n\n\tif (async_event == ISCSI_ASYNC_MSG_SCSI_EVENT) {\n\t\tiscsi_conn_printk(KERN_ALERT, bnx2i_conn->cls_conn->dd_data,\n\t\t\t\t  \"async: scsi events not supported\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock(&session->back_lock);\n\tresp_hdr = (struct iscsi_async *) &bnx2i_conn->gen_pdu.resp_hdr;\n\tmemset(resp_hdr, 0, sizeof(struct iscsi_hdr));\n\tresp_hdr->opcode = async_cqe->op_code;\n\tresp_hdr->flags = 0x80;\n\n\tmemcpy(&resp_hdr->lun, async_cqe->lun, 8);\n\tresp_hdr->exp_cmdsn = cpu_to_be32(async_cqe->exp_cmd_sn);\n\tresp_hdr->max_cmdsn = cpu_to_be32(async_cqe->max_cmd_sn);\n\n\tresp_hdr->async_event = async_cqe->async_event;\n\tresp_hdr->async_vcode = async_cqe->async_vcode;\n\n\tresp_hdr->param1 = cpu_to_be16(async_cqe->param1);\n\tresp_hdr->param2 = cpu_to_be16(async_cqe->param2);\n\tresp_hdr->param3 = cpu_to_be16(async_cqe->param3);\n\n\t__iscsi_complete_pdu(bnx2i_conn->cls_conn->dd_data,\n\t\t\t     (struct iscsi_hdr *)resp_hdr, NULL, 0);\n\tspin_unlock(&session->back_lock);\n}\n\n\n \nstatic void bnx2i_process_reject_mesg(struct iscsi_session *session,\n\t\t\t\t      struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t      struct cqe *cqe)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct bnx2i_reject_msg *reject;\n\tstruct iscsi_reject *hdr;\n\n\treject = (struct bnx2i_reject_msg *) cqe;\n\tif (reject->data_length) {\n\t\tbnx2i_get_rq_buf(bnx2i_conn, conn->data, reject->data_length);\n\t\tbnx2i_put_rq_buf(bnx2i_conn, 1);\n\t} else\n\t\tbnx2i_unsol_pdu_adjust_rq(bnx2i_conn);\n\n\tspin_lock(&session->back_lock);\n\thdr = (struct iscsi_reject *) &bnx2i_conn->gen_pdu.resp_hdr;\n\tmemset(hdr, 0, sizeof(struct iscsi_hdr));\n\thdr->opcode = reject->op_code;\n\thdr->reason = reject->reason;\n\thton24(hdr->dlength, reject->data_length);\n\thdr->max_cmdsn = cpu_to_be32(reject->max_cmd_sn);\n\thdr->exp_cmdsn = cpu_to_be32(reject->exp_cmd_sn);\n\thdr->ffffffff = cpu_to_be32(RESERVED_ITT);\n\t__iscsi_complete_pdu(conn, (struct iscsi_hdr *)hdr, conn->data,\n\t\t\t     reject->data_length);\n\tspin_unlock(&session->back_lock);\n}\n\n \nstatic void bnx2i_process_cmd_cleanup_resp(struct iscsi_session *session,\n\t\t\t\t\t   struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t\t   struct cqe *cqe)\n{\n\tstruct bnx2i_cleanup_response *cmd_clean_rsp;\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct iscsi_task *task;\n\n\tcmd_clean_rsp = (struct bnx2i_cleanup_response *)cqe;\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_itt_to_task(conn,\n\t\t\tcmd_clean_rsp->itt & ISCSI_CLEANUP_RESPONSE_INDEX);\n\tif (!task)\n\t\tprintk(KERN_ALERT \"bnx2i: cmd clean ITT %x not active\\n\",\n\t\t\tcmd_clean_rsp->itt & ISCSI_CLEANUP_RESPONSE_INDEX);\n\tspin_unlock(&session->back_lock);\n\tcomplete(&bnx2i_conn->cmd_cleanup_cmpl);\n}\n\n\n \nint bnx2i_percpu_io_thread(void *arg)\n{\n\tstruct bnx2i_percpu_s *p = arg;\n\tstruct bnx2i_work *work, *tmp;\n\tLIST_HEAD(work_list);\n\n\tset_user_nice(current, MIN_NICE);\n\n\twhile (!kthread_should_stop()) {\n\t\tspin_lock_bh(&p->p_work_lock);\n\t\twhile (!list_empty(&p->work_list)) {\n\t\t\tlist_splice_init(&p->work_list, &work_list);\n\t\t\tspin_unlock_bh(&p->p_work_lock);\n\n\t\t\tlist_for_each_entry_safe(work, tmp, &work_list, list) {\n\t\t\t\tlist_del_init(&work->list);\n\t\t\t\t \n\t\t\t\tbnx2i_process_scsi_cmd_resp(work->session,\n\t\t\t\t\t\t\t    work->bnx2i_conn,\n\t\t\t\t\t\t\t    &work->cqe);\n\t\t\t\tatomic_dec(&work->bnx2i_conn->work_cnt);\n\t\t\t\tkfree(work);\n\t\t\t}\n\t\t\tspin_lock_bh(&p->p_work_lock);\n\t\t}\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_unlock_bh(&p->p_work_lock);\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}\n\n\n \nstatic int bnx2i_queue_scsi_cmd_resp(struct iscsi_session *session,\n\t\t\t\t     struct bnx2i_conn *bnx2i_conn,\n\t\t\t\t     struct bnx2i_nop_in_msg *cqe)\n{\n\tstruct bnx2i_work *bnx2i_work = NULL;\n\tstruct bnx2i_percpu_s *p = NULL;\n\tstruct iscsi_task *task;\n\tstruct scsi_cmnd *sc;\n\tint rc = 0;\n\n\tspin_lock(&session->back_lock);\n\ttask = iscsi_itt_to_task(bnx2i_conn->cls_conn->dd_data,\n\t\t\t\t cqe->itt & ISCSI_CMD_RESPONSE_INDEX);\n\tif (!task || !task->sc) {\n\t\tspin_unlock(&session->back_lock);\n\t\treturn -EINVAL;\n\t}\n\tsc = task->sc;\n\n\tspin_unlock(&session->back_lock);\n\n\tp = &per_cpu(bnx2i_percpu, blk_mq_rq_cpu(scsi_cmd_to_rq(sc)));\n\tspin_lock(&p->p_work_lock);\n\tif (unlikely(!p->iothread)) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\t \n\tbnx2i_work = kzalloc(sizeof(struct bnx2i_work), GFP_ATOMIC);\n\tif (bnx2i_work) {\n\t\tINIT_LIST_HEAD(&bnx2i_work->list);\n\t\tbnx2i_work->session = session;\n\t\tbnx2i_work->bnx2i_conn = bnx2i_conn;\n\t\tmemcpy(&bnx2i_work->cqe, cqe, sizeof(struct cqe));\n\t\tlist_add_tail(&bnx2i_work->list, &p->work_list);\n\t\tatomic_inc(&bnx2i_conn->work_cnt);\n\t\twake_up_process(p->iothread);\n\t\tspin_unlock(&p->p_work_lock);\n\t\tgoto done;\n\t} else\n\t\trc = -ENOMEM;\nerr:\n\tspin_unlock(&p->p_work_lock);\n\tbnx2i_process_scsi_cmd_resp(session, bnx2i_conn, (struct cqe *)cqe);\ndone:\n\treturn rc;\n}\n\n\n \nstatic int bnx2i_process_new_cqes(struct bnx2i_conn *bnx2i_conn)\n{\n\tstruct iscsi_conn *conn = bnx2i_conn->cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct bnx2i_hba *hba = bnx2i_conn->hba;\n\tstruct qp_info *qp;\n\tstruct bnx2i_nop_in_msg *nopin;\n\tint tgt_async_msg;\n\tint cqe_cnt = 0;\n\n\tif (bnx2i_conn->ep == NULL)\n\t\treturn 0;\n\n\tqp = &bnx2i_conn->ep->qp;\n\n\tif (!qp->cq_virt) {\n\t\tprintk(KERN_ALERT \"bnx2i (%s): cq resr freed in bh execution!\",\n\t\t       hba->netdev->name);\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnopin = (struct bnx2i_nop_in_msg *) qp->cq_cons_qe;\n\t\tif (nopin->cq_req_sn != qp->cqe_exp_seq_sn)\n\t\t\tbreak;\n\n\t\tif (unlikely(test_bit(ISCSI_CONN_FLAG_SUSPEND_RX, &conn->flags))) {\n\t\t\tif (nopin->op_code == ISCSI_OP_NOOP_IN &&\n\t\t\t    nopin->itt == (u16) RESERVED_ITT) {\n\t\t\t\tprintk(KERN_ALERT \"bnx2i: Unsolicited \"\n\t\t\t\t       \"NOP-In detected for suspended \"\n\t\t\t\t       \"connection dev=%s!\\n\",\n\t\t\t\t       hba->netdev->name);\n\t\t\t\tbnx2i_unsol_pdu_adjust_rq(bnx2i_conn);\n\t\t\t\tgoto cqe_out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ttgt_async_msg = 0;\n\n\t\tswitch (nopin->op_code) {\n\t\tcase ISCSI_OP_SCSI_CMD_RSP:\n\t\tcase ISCSI_OP_SCSI_DATA_IN:\n\t\t\t \n\t\t\tbnx2i_queue_scsi_cmd_resp(session, bnx2i_conn, nopin);\n\t\t\tgoto done;\n\t\tcase ISCSI_OP_LOGIN_RSP:\n\t\t\tbnx2i_process_login_resp(session, bnx2i_conn,\n\t\t\t\t\t\t qp->cq_cons_qe);\n\t\t\tbreak;\n\t\tcase ISCSI_OP_SCSI_TMFUNC_RSP:\n\t\t\tbnx2i_process_tmf_resp(session, bnx2i_conn,\n\t\t\t\t\t       qp->cq_cons_qe);\n\t\t\tbreak;\n\t\tcase ISCSI_OP_TEXT_RSP:\n\t\t\tbnx2i_process_text_resp(session, bnx2i_conn,\n\t\t\t\t\t\tqp->cq_cons_qe);\n\t\t\tbreak;\n\t\tcase ISCSI_OP_LOGOUT_RSP:\n\t\t\tbnx2i_process_logout_resp(session, bnx2i_conn,\n\t\t\t\t\t\t  qp->cq_cons_qe);\n\t\t\tbreak;\n\t\tcase ISCSI_OP_NOOP_IN:\n\t\t\tif (bnx2i_process_nopin_mesg(session, bnx2i_conn,\n\t\t\t\t\t\t     qp->cq_cons_qe))\n\t\t\t\ttgt_async_msg = 1;\n\t\t\tbreak;\n\t\tcase ISCSI_OPCODE_NOPOUT_LOCAL_COMPLETION:\n\t\t\tbnx2i_process_nopin_local_cmpl(session, bnx2i_conn,\n\t\t\t\t\t\t       qp->cq_cons_qe);\n\t\t\tbreak;\n\t\tcase ISCSI_OP_ASYNC_EVENT:\n\t\t\tbnx2i_process_async_mesg(session, bnx2i_conn,\n\t\t\t\t\t\t qp->cq_cons_qe);\n\t\t\ttgt_async_msg = 1;\n\t\t\tbreak;\n\t\tcase ISCSI_OP_REJECT:\n\t\t\tbnx2i_process_reject_mesg(session, bnx2i_conn,\n\t\t\t\t\t\t  qp->cq_cons_qe);\n\t\t\tbreak;\n\t\tcase ISCSI_OPCODE_CLEANUP_RESPONSE:\n\t\t\tbnx2i_process_cmd_cleanup_resp(session, bnx2i_conn,\n\t\t\t\t\t\t       qp->cq_cons_qe);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ALERT \"bnx2i: unknown opcode 0x%x\\n\",\n\t\t\t\t\t  nopin->op_code);\n\t\t}\n\n\t\tADD_STATS_64(hba, rx_pdus, 1);\n\t\tADD_STATS_64(hba, rx_bytes, nopin->data_length);\ndone:\n\t\tif (!tgt_async_msg) {\n\t\t\tif (!atomic_read(&bnx2i_conn->ep->num_active_cmds))\n\t\t\t\tprintk(KERN_ALERT \"bnx2i (%s): no active cmd! \"\n\t\t\t\t       \"op 0x%x\\n\",\n\t\t\t\t       hba->netdev->name,\n\t\t\t\t       nopin->op_code);\n\t\t\telse\n\t\t\t\tatomic_dec(&bnx2i_conn->ep->num_active_cmds);\n\t\t}\ncqe_out:\n\t\t \n\t\tcqe_cnt++;\n\t\tqp->cqe_exp_seq_sn++;\n\t\tif (qp->cqe_exp_seq_sn == (qp->cqe_size * 2 + 1))\n\t\t\tqp->cqe_exp_seq_sn = ISCSI_INITIAL_SN;\n\n\t\tif (qp->cq_cons_qe == qp->cq_last_qe) {\n\t\t\tqp->cq_cons_qe = qp->cq_first_qe;\n\t\t\tqp->cq_cons_idx = 0;\n\t\t} else {\n\t\t\tqp->cq_cons_qe++;\n\t\t\tqp->cq_cons_idx++;\n\t\t}\n\t}\nout:\n\treturn cqe_cnt;\n}\n\n \nstatic void bnx2i_fastpath_notification(struct bnx2i_hba *hba,\n\t\t\t\t\tstruct iscsi_kcqe *new_cqe_kcqe)\n{\n\tstruct bnx2i_conn *bnx2i_conn;\n\tu32 iscsi_cid;\n\tint nxt_idx;\n\n\tiscsi_cid = new_cqe_kcqe->iscsi_conn_id;\n\tbnx2i_conn = bnx2i_get_conn_from_id(hba, iscsi_cid);\n\n\tif (!bnx2i_conn) {\n\t\tprintk(KERN_ALERT \"cid #%x not valid\\n\", iscsi_cid);\n\t\treturn;\n\t}\n\tif (!bnx2i_conn->ep) {\n\t\tprintk(KERN_ALERT \"cid #%x - ep not bound\\n\", iscsi_cid);\n\t\treturn;\n\t}\n\n\tbnx2i_process_new_cqes(bnx2i_conn);\n\tnxt_idx = bnx2i_arm_cq_event_coalescing(bnx2i_conn->ep,\n\t\t\t\t\t\tCNIC_ARM_CQE_FP);\n\tif (nxt_idx && nxt_idx == bnx2i_process_new_cqes(bnx2i_conn))\n\t\tbnx2i_arm_cq_event_coalescing(bnx2i_conn->ep, CNIC_ARM_CQE_FP);\n}\n\n\n \nstatic void bnx2i_process_update_conn_cmpl(struct bnx2i_hba *hba,\n\t\t\t\t\t   struct iscsi_kcqe *update_kcqe)\n{\n\tstruct bnx2i_conn *conn;\n\tu32 iscsi_cid;\n\n\tiscsi_cid = update_kcqe->iscsi_conn_id;\n\tconn = bnx2i_get_conn_from_id(hba, iscsi_cid);\n\n\tif (!conn) {\n\t\tprintk(KERN_ALERT \"conn_update: cid %x not valid\\n\", iscsi_cid);\n\t\treturn;\n\t}\n\tif (!conn->ep) {\n\t\tprintk(KERN_ALERT \"cid %x does not have ep bound\\n\", iscsi_cid);\n\t\treturn;\n\t}\n\n\tif (update_kcqe->completion_status) {\n\t\tprintk(KERN_ALERT \"request failed cid %x\\n\", iscsi_cid);\n\t\tconn->ep->state = EP_STATE_ULP_UPDATE_FAILED;\n\t} else\n\t\tconn->ep->state = EP_STATE_ULP_UPDATE_COMPL;\n\n\twake_up_interruptible(&conn->ep->ofld_wait);\n}\n\n\n \nstatic void bnx2i_recovery_que_add_conn(struct bnx2i_hba *hba,\n\t\t\t\t\tstruct bnx2i_conn *bnx2i_conn)\n{\n\tiscsi_conn_failure(bnx2i_conn->cls_conn->dd_data,\n\t\t\t   ISCSI_ERR_CONN_FAILED);\n}\n\n\n \nstatic void bnx2i_process_tcp_error(struct bnx2i_hba *hba,\n\t\t\t\t    struct iscsi_kcqe *tcp_err)\n{\n\tstruct bnx2i_conn *bnx2i_conn;\n\tu32 iscsi_cid;\n\n\tiscsi_cid = tcp_err->iscsi_conn_id;\n\tbnx2i_conn = bnx2i_get_conn_from_id(hba, iscsi_cid);\n\n\tif (!bnx2i_conn) {\n\t\tprintk(KERN_ALERT \"bnx2i - cid 0x%x not valid\\n\", iscsi_cid);\n\t\treturn;\n\t}\n\n\tprintk(KERN_ALERT \"bnx2i - cid 0x%x had TCP errors, error code 0x%x\\n\",\n\t\t\t  iscsi_cid, tcp_err->completion_status);\n\tbnx2i_recovery_que_add_conn(bnx2i_conn->hba, bnx2i_conn);\n}\n\n\n \nstatic void bnx2i_process_iscsi_error(struct bnx2i_hba *hba,\n\t\t\t\t      struct iscsi_kcqe *iscsi_err)\n{\n\tstruct bnx2i_conn *bnx2i_conn;\n\tu32 iscsi_cid;\n\tconst char *additional_notice = \"\";\n\tconst char *message;\n\tint need_recovery;\n\tu64 err_mask64;\n\n\tiscsi_cid = iscsi_err->iscsi_conn_id;\n\tbnx2i_conn = bnx2i_get_conn_from_id(hba, iscsi_cid);\n\tif (!bnx2i_conn) {\n\t\tprintk(KERN_ALERT \"bnx2i - cid 0x%x not valid\\n\", iscsi_cid);\n\t\treturn;\n\t}\n\n\terr_mask64 = (0x1ULL << iscsi_err->completion_status);\n\n\tif (err_mask64 & iscsi_error_mask) {\n\t\tneed_recovery = 0;\n\t\tmessage = \"iscsi_warning\";\n\t} else {\n\t\tneed_recovery = 1;\n\t\tmessage = \"iscsi_error\";\n\t}\n\n\tswitch (iscsi_err->completion_status) {\n\tcase ISCSI_KCQE_COMPLETION_STATUS_HDR_DIG_ERR:\n\t\tadditional_notice = \"hdr digest err\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_DATA_DIG_ERR:\n\t\tadditional_notice = \"data digest err\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_OPCODE:\n\t\tadditional_notice = \"wrong opcode rcvd\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_AHS_LEN:\n\t\tadditional_notice = \"AHS len > 0 rcvd\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_ITT:\n\t\tadditional_notice = \"invalid ITT rcvd\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_STATSN:\n\t\tadditional_notice = \"wrong StatSN rcvd\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_EXP_DATASN:\n\t\tadditional_notice = \"wrong DataSN rcvd\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_PEND_R2T:\n\t\tadditional_notice = \"pend R2T violation\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_0:\n\t\tadditional_notice = \"ERL0, UO\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_1:\n\t\tadditional_notice = \"ERL0, U1\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_2:\n\t\tadditional_notice = \"ERL0, U2\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_3:\n\t\tadditional_notice = \"ERL0, U3\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_4:\n\t\tadditional_notice = \"ERL0, U4\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_5:\n\t\tadditional_notice = \"ERL0, U5\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_O_U_6:\n\t\tadditional_notice = \"ERL0, U6\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_REMAIN_RCV_LEN:\n\t\tadditional_notice = \"invalid resi len\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_MAX_RCV_PDU_LEN:\n\t\tadditional_notice = \"MRDSL violation\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_F_BIT_ZERO:\n\t\tadditional_notice = \"F-bit not set\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_TTT_NOT_RSRV:\n\t\tadditional_notice = \"invalid TTT\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_DATASN:\n\t\tadditional_notice = \"invalid DataSN\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_REMAIN_BURST_LEN:\n\t\tadditional_notice = \"burst len violation\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_BUFFER_OFF:\n\t\tadditional_notice = \"buf offset violation\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_LUN:\n\t\tadditional_notice = \"invalid LUN field\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_R2TSN:\n\t\tadditional_notice = \"invalid R2TSN field\";\n\t\tbreak;\n#define BNX2I_ERR_DESIRED_DATA_TRNS_LEN_0 \t\\\n\tISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_DESIRED_DATA_TRNS_LEN_0\n\tcase BNX2I_ERR_DESIRED_DATA_TRNS_LEN_0:\n\t\tadditional_notice = \"invalid cmd len1\";\n\t\tbreak;\n#define BNX2I_ERR_DESIRED_DATA_TRNS_LEN_1 \t\\\n\tISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_DESIRED_DATA_TRNS_LEN_1\n\tcase BNX2I_ERR_DESIRED_DATA_TRNS_LEN_1:\n\t\tadditional_notice = \"invalid cmd len2\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_PEND_R2T_EXCEED:\n\t\tadditional_notice = \"pend r2t exceeds MaxOutstandingR2T value\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_TTT_IS_RSRV:\n\t\tadditional_notice = \"TTT is rsvd\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_MAX_BURST_LEN:\n\t\tadditional_notice = \"MBL violation\";\n\t\tbreak;\n#define BNX2I_ERR_DATA_SEG_LEN_NOT_ZERO \t\\\n\tISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_DATA_SEG_LEN_NOT_ZERO\n\tcase BNX2I_ERR_DATA_SEG_LEN_NOT_ZERO:\n\t\tadditional_notice = \"data seg len != 0\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_REJECT_PDU_LEN:\n\t\tadditional_notice = \"reject pdu len error\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_ASYNC_PDU_LEN:\n\t\tadditional_notice = \"async pdu len error\";\n\t\tbreak;\n\tcase ISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_NOPIN_PDU_LEN:\n\t\tadditional_notice = \"nopin pdu len error\";\n\t\tbreak;\n#define BNX2_ERR_PEND_R2T_IN_CLEANUP\t\t\t\\\n\tISCSI_KCQE_COMPLETION_STATUS_PROTOCOL_ERR_PEND_R2T_IN_CLEANUP\n\tcase BNX2_ERR_PEND_R2T_IN_CLEANUP:\n\t\tadditional_notice = \"pend r2t in cleanup\";\n\t\tbreak;\n\n\tcase ISCI_KCQE_COMPLETION_STATUS_TCP_ERROR_IP_FRAGMENT:\n\t\tadditional_notice = \"IP fragments rcvd\";\n\t\tbreak;\n\tcase ISCI_KCQE_COMPLETION_STATUS_TCP_ERROR_IP_OPTIONS:\n\t\tadditional_notice = \"IP options error\";\n\t\tbreak;\n\tcase ISCI_KCQE_COMPLETION_STATUS_TCP_ERROR_URGENT_FLAG:\n\t\tadditional_notice = \"urgent flag error\";\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ALERT \"iscsi_err - unknown err %x\\n\",\n\t\t\t\t  iscsi_err->completion_status);\n\t}\n\n\tif (need_recovery) {\n\t\tiscsi_conn_printk(KERN_ALERT,\n\t\t\t\t  bnx2i_conn->cls_conn->dd_data,\n\t\t\t\t  \"bnx2i: %s - %s\\n\",\n\t\t\t\t  message, additional_notice);\n\n\t\tiscsi_conn_printk(KERN_ALERT,\n\t\t\t\t  bnx2i_conn->cls_conn->dd_data,\n\t\t\t\t  \"conn_err - hostno %d conn %p, \"\n\t\t\t\t  \"iscsi_cid %x cid %x\\n\",\n\t\t\t\t  bnx2i_conn->hba->shost->host_no,\n\t\t\t\t  bnx2i_conn, bnx2i_conn->ep->ep_iscsi_cid,\n\t\t\t\t  bnx2i_conn->ep->ep_cid);\n\t\tbnx2i_recovery_que_add_conn(bnx2i_conn->hba, bnx2i_conn);\n\t} else\n\t\tif (!test_and_set_bit(iscsi_err->completion_status,\n\t\t\t\t      (void *) &bnx2i_conn->violation_notified))\n\t\t\tiscsi_conn_printk(KERN_ALERT,\n\t\t\t\t\t  bnx2i_conn->cls_conn->dd_data,\n\t\t\t\t\t  \"bnx2i: %s - %s\\n\",\n\t\t\t\t\t  message, additional_notice);\n}\n\n\n \nstatic void bnx2i_process_conn_destroy_cmpl(struct bnx2i_hba *hba,\n\t\t\t\t\t    struct iscsi_kcqe *conn_destroy)\n{\n\tstruct bnx2i_endpoint *ep;\n\n\tep = bnx2i_find_ep_in_destroy_list(hba, conn_destroy->iscsi_conn_id);\n\tif (!ep) {\n\t\tprintk(KERN_ALERT \"bnx2i_conn_destroy_cmpl: no pending \"\n\t\t\t\t  \"offload request, unexpected completion\\n\");\n\t\treturn;\n\t}\n\n\tif (hba != ep->hba) {\n\t\tprintk(KERN_ALERT \"conn destroy- error hba mismatch\\n\");\n\t\treturn;\n\t}\n\n\tif (conn_destroy->completion_status) {\n\t\tprintk(KERN_ALERT \"conn_destroy_cmpl: op failed\\n\");\n\t\tep->state = EP_STATE_CLEANUP_FAILED;\n\t} else\n\t\tep->state = EP_STATE_CLEANUP_CMPL;\n\twake_up_interruptible(&ep->ofld_wait);\n}\n\n\n \nstatic void bnx2i_process_ofld_cmpl(struct bnx2i_hba *hba,\n\t\t\t\t    struct iscsi_kcqe *ofld_kcqe)\n{\n\tu32 cid_addr;\n\tstruct bnx2i_endpoint *ep;\n\n\tep = bnx2i_find_ep_in_ofld_list(hba, ofld_kcqe->iscsi_conn_id);\n\tif (!ep) {\n\t\tprintk(KERN_ALERT \"ofld_cmpl: no pend offload request\\n\");\n\t\treturn;\n\t}\n\n\tif (hba != ep->hba) {\n\t\tprintk(KERN_ALERT \"ofld_cmpl: error hba mismatch\\n\");\n\t\treturn;\n\t}\n\n\tif (ofld_kcqe->completion_status) {\n\t\tep->state = EP_STATE_OFLD_FAILED;\n\t\tif (ofld_kcqe->completion_status ==\n\t\t    ISCSI_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE)\n\t\t\tprintk(KERN_ALERT \"bnx2i (%s): ofld1 cmpl - unable \"\n\t\t\t\t\"to allocate iSCSI context resources\\n\",\n\t\t\t\thba->netdev->name);\n\t\telse if (ofld_kcqe->completion_status ==\n\t\t\t ISCSI_KCQE_COMPLETION_STATUS_INVALID_OPCODE)\n\t\t\tprintk(KERN_ALERT \"bnx2i (%s): ofld1 cmpl - invalid \"\n\t\t\t\t\"opcode\\n\", hba->netdev->name);\n\t\telse if (ofld_kcqe->completion_status ==\n\t\t\t ISCSI_KCQE_COMPLETION_STATUS_CID_BUSY)\n\t\t\t \n\t\t\tep->state = EP_STATE_OFLD_FAILED_CID_BUSY;\n\t\telse\n\t\t\tprintk(KERN_ALERT \"bnx2i (%s): ofld1 cmpl - invalid \"\n\t\t\t\t\"error code %d\\n\", hba->netdev->name,\n\t\t\t\tofld_kcqe->completion_status);\n\t} else {\n\t\tep->state = EP_STATE_OFLD_COMPL;\n\t\tcid_addr = ofld_kcqe->iscsi_conn_context_id;\n\t\tep->ep_cid = cid_addr;\n\t\tep->qp.ctx_base = NULL;\n\t}\n\twake_up_interruptible(&ep->ofld_wait);\n}\n\n \nstatic void bnx2i_indicate_kcqe(void *context, struct kcqe *kcqe[],\n\t\t\t\tu32 num_cqe)\n{\n\tstruct bnx2i_hba *hba = context;\n\tint i = 0;\n\tstruct iscsi_kcqe *ikcqe = NULL;\n\n\twhile (i < num_cqe) {\n\t\tikcqe = (struct iscsi_kcqe *) kcqe[i++];\n\n\t\tif (ikcqe->op_code ==\n\t\t    ISCSI_KCQE_OPCODE_CQ_EVENT_NOTIFICATION)\n\t\t\tbnx2i_fastpath_notification(hba, ikcqe);\n\t\telse if (ikcqe->op_code == ISCSI_KCQE_OPCODE_OFFLOAD_CONN)\n\t\t\tbnx2i_process_ofld_cmpl(hba, ikcqe);\n\t\telse if (ikcqe->op_code == ISCSI_KCQE_OPCODE_UPDATE_CONN)\n\t\t\tbnx2i_process_update_conn_cmpl(hba, ikcqe);\n\t\telse if (ikcqe->op_code == ISCSI_KCQE_OPCODE_INIT) {\n\t\t\tif (ikcqe->completion_status !=\n\t\t\t    ISCSI_KCQE_COMPLETION_STATUS_SUCCESS)\n\t\t\t\tbnx2i_iscsi_license_error(hba, ikcqe->\\\n\t\t\t\t\t\t\t  completion_status);\n\t\t\telse {\n\t\t\t\tset_bit(ADAPTER_STATE_UP, &hba->adapter_state);\n\t\t\t\tbnx2i_get_link_state(hba);\n\t\t\t\tprintk(KERN_INFO \"bnx2i [%.2x:%.2x.%.2x]: \"\n\t\t\t\t\t\t \"ISCSI_INIT passed\\n\",\n\t\t\t\t\t\t (u8)hba->pcidev->bus->number,\n\t\t\t\t\t\t hba->pci_devno,\n\t\t\t\t\t\t (u8)hba->pci_func);\n\n\n\t\t\t}\n\t\t} else if (ikcqe->op_code == ISCSI_KCQE_OPCODE_DESTROY_CONN)\n\t\t\tbnx2i_process_conn_destroy_cmpl(hba, ikcqe);\n\t\telse if (ikcqe->op_code == ISCSI_KCQE_OPCODE_ISCSI_ERROR)\n\t\t\tbnx2i_process_iscsi_error(hba, ikcqe);\n\t\telse if (ikcqe->op_code == ISCSI_KCQE_OPCODE_TCP_ERROR)\n\t\t\tbnx2i_process_tcp_error(hba, ikcqe);\n\t\telse\n\t\t\tprintk(KERN_ALERT \"bnx2i: unknown opcode 0x%x\\n\",\n\t\t\t\t\t  ikcqe->op_code);\n\t}\n}\n\n\n \nstatic void bnx2i_indicate_netevent(void *context, unsigned long event,\n\t\t\t\t    u16 vlan_id)\n{\n\tstruct bnx2i_hba *hba = context;\n\n\t \n\tif (vlan_id != 0)\n\t\treturn;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state))\n\t\t\tbnx2i_send_fw_iscsi_init_msg(hba);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\tclear_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state);\n\t\tclear_bit(ADAPTER_STATE_UP, &hba->adapter_state);\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\tset_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state);\n\t\tiscsi_host_for_each_session(hba->shost,\n\t\t\t\t\t    bnx2i_drop_session);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tbnx2i_get_link_state(hba);\n\t\tbreak;\n\tdefault:\n\t\t;\n\t}\n}\n\n\n \nstatic void bnx2i_cm_connect_cmpl(struct cnic_sock *cm_sk)\n{\n\tstruct bnx2i_endpoint *ep = (struct bnx2i_endpoint *) cm_sk->context;\n\n\tif (test_bit(ADAPTER_STATE_GOING_DOWN, &ep->hba->adapter_state))\n\t\tep->state = EP_STATE_CONNECT_FAILED;\n\telse if (test_bit(SK_F_OFFLD_COMPLETE, &cm_sk->flags))\n\t\tep->state = EP_STATE_CONNECT_COMPL;\n\telse\n\t\tep->state = EP_STATE_CONNECT_FAILED;\n\n\twake_up_interruptible(&ep->ofld_wait);\n}\n\n\n \nstatic void bnx2i_cm_close_cmpl(struct cnic_sock *cm_sk)\n{\n\tstruct bnx2i_endpoint *ep = (struct bnx2i_endpoint *) cm_sk->context;\n\n\tep->state = EP_STATE_DISCONN_COMPL;\n\twake_up_interruptible(&ep->ofld_wait);\n}\n\n\n \nstatic void bnx2i_cm_abort_cmpl(struct cnic_sock *cm_sk)\n{\n\tstruct bnx2i_endpoint *ep = (struct bnx2i_endpoint *) cm_sk->context;\n\n\tep->state = EP_STATE_DISCONN_COMPL;\n\twake_up_interruptible(&ep->ofld_wait);\n}\n\n\n \nstatic void bnx2i_cm_remote_close(struct cnic_sock *cm_sk)\n{\n\tstruct bnx2i_endpoint *ep = (struct bnx2i_endpoint *) cm_sk->context;\n\n\tep->state = EP_STATE_TCP_FIN_RCVD;\n\tif (ep->conn)\n\t\tbnx2i_recovery_que_add_conn(ep->hba, ep->conn);\n}\n\n \nstatic void bnx2i_cm_remote_abort(struct cnic_sock *cm_sk)\n{\n\tstruct bnx2i_endpoint *ep = (struct bnx2i_endpoint *) cm_sk->context;\n\tu32 old_state = ep->state;\n\n\tep->state = EP_STATE_TCP_RST_RCVD;\n\tif (old_state == EP_STATE_DISCONN_START)\n\t\twake_up_interruptible(&ep->ofld_wait);\n\telse\n\t\tif (ep->conn)\n\t\t\tbnx2i_recovery_que_add_conn(ep->hba, ep->conn);\n}\n\n\nstatic int bnx2i_send_nl_mesg(void *context, u32 msg_type,\n\t\t\t      char *buf, u16 buflen)\n{\n\tstruct bnx2i_hba *hba = context;\n\tint rc;\n\n\tif (!hba)\n\t\treturn -ENODEV;\n\n\trc = iscsi_offload_mesg(hba->shost, &bnx2i_iscsi_transport,\n\t\t\t\tmsg_type, buf, buflen);\n\tif (rc)\n\t\tprintk(KERN_ALERT \"bnx2i: private nl message send error\\n\");\n\n\treturn rc;\n}\n\n\n \nstruct cnic_ulp_ops bnx2i_cnic_cb = {\n\t.cnic_init = bnx2i_ulp_init,\n\t.cnic_exit = bnx2i_ulp_exit,\n\t.cnic_start = bnx2i_start,\n\t.cnic_stop = bnx2i_stop,\n\t.indicate_kcqes = bnx2i_indicate_kcqe,\n\t.indicate_netevent = bnx2i_indicate_netevent,\n\t.cm_connect_complete = bnx2i_cm_connect_cmpl,\n\t.cm_close_complete = bnx2i_cm_close_cmpl,\n\t.cm_abort_complete = bnx2i_cm_abort_cmpl,\n\t.cm_remote_close = bnx2i_cm_remote_close,\n\t.cm_remote_abort = bnx2i_cm_remote_abort,\n\t.iscsi_nl_send_msg = bnx2i_send_nl_mesg,\n\t.cnic_get_stats = bnx2i_get_stats,\n\t.owner = THIS_MODULE\n};\n\n\n \nint bnx2i_map_ep_dbell_regs(struct bnx2i_endpoint *ep)\n{\n\tu32 cid_num;\n\tu32 reg_off;\n\tu32 first_l4l5;\n\tu32 ctx_sz;\n\tu32 config2;\n\tresource_size_t reg_base;\n\n\tcid_num = bnx2i_get_cid_num(ep);\n\n\tif (test_bit(BNX2I_NX2_DEV_57710, &ep->hba->cnic_dev_type)) {\n\t\treg_base = pci_resource_start(ep->hba->pcidev,\n\t\t\t\t\t      BNX2X_DOORBELL_PCI_BAR);\n\t\treg_off = (1 << BNX2X_DB_SHIFT) * (cid_num & 0x1FFFF);\n\t\tep->qp.ctx_base = ioremap(reg_base + reg_off, 4);\n\t\tif (!ep->qp.ctx_base)\n\t\t\treturn -ENOMEM;\n\t\tgoto arm_cq;\n\t}\n\n\tif ((test_bit(BNX2I_NX2_DEV_5709, &ep->hba->cnic_dev_type)) &&\n\t    (ep->hba->mail_queue_access == BNX2I_MQ_BIN_MODE)) {\n\t\tconfig2 = REG_RD(ep->hba, BNX2_MQ_CONFIG2);\n\t\tfirst_l4l5 = config2 & BNX2_MQ_CONFIG2_FIRST_L4L5;\n\t\tctx_sz = (config2 & BNX2_MQ_CONFIG2_CONT_SZ) >> 3;\n\t\tif (ctx_sz)\n\t\t\treg_off = CTX_OFFSET + MAX_CID_CNT * MB_KERNEL_CTX_SIZE\n\t\t\t\t  + BNX2I_570X_PAGE_SIZE_DEFAULT *\n\t\t\t\t  (((cid_num - first_l4l5) / ctx_sz) + 256);\n\t\telse\n\t\t\treg_off = CTX_OFFSET + (MB_KERNEL_CTX_SIZE * cid_num);\n\t} else\n\t\t \n\t\treg_off = CTX_OFFSET + (MB_KERNEL_CTX_SIZE * cid_num);\n\n\tep->qp.ctx_base = ioremap(ep->hba->reg_base + reg_off,\n\t\t\t\t\t  MB_KERNEL_CTX_SIZE);\n\tif (!ep->qp.ctx_base)\n\t\treturn -ENOMEM;\n\narm_cq:\n\tbnx2i_arm_cq_event_coalescing(ep, CNIC_ARM_CQE);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}