{
  "module_name": "bnx2i_init.c",
  "hash_id": "16011a8dc28813d2525294d6c18cc153dca17cc429b48f8e35302da2d7bd322b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/bnx2i/bnx2i_init.c",
  "human_readable_source": " \n\n#include \"bnx2i.h\"\n\nstatic struct list_head adapter_list = LIST_HEAD_INIT(adapter_list);\nstatic u32 adapter_count;\n\n#define DRV_MODULE_NAME\t\t\"bnx2i\"\n#define DRV_MODULE_VERSION\t\"2.7.10.1\"\n#define DRV_MODULE_RELDATE\t\"Jul 16, 2014\"\n\nstatic char version[] =\n\t\t\"QLogic NetXtreme II iSCSI Driver \" DRV_MODULE_NAME \\\n\t\t\" v\" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\\n\";\n\n\nMODULE_AUTHOR(\"Anil Veerabhadrappa <anilgv@broadcom.com> and \"\n\t      \"Eddie Wai <eddie.wai@broadcom.com>\");\n\nMODULE_DESCRIPTION(\"QLogic NetXtreme II BCM5706/5708/5709/57710/57711/57712\"\n\t\t   \"/57800/57810/57840 iSCSI Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\nstatic DEFINE_MUTEX(bnx2i_dev_lock);\n\nunsigned int event_coal_min = 24;\nmodule_param(event_coal_min, int, 0664);\nMODULE_PARM_DESC(event_coal_min, \"Event Coalescing Minimum Commands\");\n\nunsigned int event_coal_div = 2;\nmodule_param(event_coal_div, int, 0664);\nMODULE_PARM_DESC(event_coal_div, \"Event Coalescing Divide Factor\");\n\nunsigned int en_tcp_dack = 1;\nmodule_param(en_tcp_dack, int, 0664);\nMODULE_PARM_DESC(en_tcp_dack, \"Enable TCP Delayed ACK\");\n\nunsigned int error_mask1 = 0x00;\nmodule_param(error_mask1, uint, 0664);\nMODULE_PARM_DESC(error_mask1, \"Config FW iSCSI Error Mask #1\");\n\nunsigned int error_mask2 = 0x00;\nmodule_param(error_mask2, uint, 0664);\nMODULE_PARM_DESC(error_mask2, \"Config FW iSCSI Error Mask #2\");\n\nunsigned int sq_size;\nmodule_param(sq_size, int, 0664);\nMODULE_PARM_DESC(sq_size, \"Configure SQ size\");\n\nunsigned int rq_size = BNX2I_RQ_WQES_DEFAULT;\nmodule_param(rq_size, int, 0664);\nMODULE_PARM_DESC(rq_size, \"Configure RQ size\");\n\nu64 iscsi_error_mask = 0x00;\n\nDEFINE_PER_CPU(struct bnx2i_percpu_s, bnx2i_percpu);\n\n \nvoid bnx2i_identify_device(struct bnx2i_hba *hba, struct cnic_dev *dev)\n{\n\thba->cnic_dev_type = 0;\n\tif (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {\n\t\tif (hba->pci_did == PCI_DEVICE_ID_NX2_5706 ||\n\t\t    hba->pci_did == PCI_DEVICE_ID_NX2_5706S) {\n\t\t\tset_bit(BNX2I_NX2_DEV_5706, &hba->cnic_dev_type);\n\t\t} else if (hba->pci_did == PCI_DEVICE_ID_NX2_5708 ||\n\t\t    hba->pci_did == PCI_DEVICE_ID_NX2_5708S) {\n\t\t\tset_bit(BNX2I_NX2_DEV_5708, &hba->cnic_dev_type);\n\t\t} else if (hba->pci_did == PCI_DEVICE_ID_NX2_5709 ||\n\t\t    hba->pci_did == PCI_DEVICE_ID_NX2_5709S) {\n\t\t\tset_bit(BNX2I_NX2_DEV_5709, &hba->cnic_dev_type);\n\t\t\thba->mail_queue_access = BNX2I_MQ_BIN_MODE;\n\t\t}\n\t} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {\n\t\tset_bit(BNX2I_NX2_DEV_57710, &hba->cnic_dev_type);\n\t} else {\n\t\tprintk(KERN_ALERT \"bnx2i: unknown device, 0x%x\\n\",\n\t\t\t\t  hba->pci_did);\n\t}\n}\n\n\n \nstruct bnx2i_hba *get_adapter_list_head(void)\n{\n\tstruct bnx2i_hba *hba = NULL;\n\tstruct bnx2i_hba *tmp_hba;\n\n\tif (!adapter_count)\n\t\tgoto hba_not_found;\n\n\tmutex_lock(&bnx2i_dev_lock);\n\tlist_for_each_entry(tmp_hba, &adapter_list, link) {\n\t\tif (tmp_hba->cnic && tmp_hba->cnic->cm_select_dev) {\n\t\t\thba = tmp_hba;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&bnx2i_dev_lock);\nhba_not_found:\n\treturn hba;\n}\n\n\n \nstruct bnx2i_hba *bnx2i_find_hba_for_cnic(struct cnic_dev *cnic)\n{\n\tstruct bnx2i_hba *hba, *temp;\n\n\tmutex_lock(&bnx2i_dev_lock);\n\tlist_for_each_entry_safe(hba, temp, &adapter_list, link) {\n\t\tif (hba->cnic == cnic) {\n\t\t\tmutex_unlock(&bnx2i_dev_lock);\n\t\t\treturn hba;\n\t\t}\n\t}\n\tmutex_unlock(&bnx2i_dev_lock);\n\treturn NULL;\n}\n\n\n \nvoid bnx2i_start(void *handle)\n{\n#define BNX2I_INIT_POLL_TIME\t(1000 / HZ)\n\tstruct bnx2i_hba *hba = handle;\n\tint i = HZ;\n\n\t \n\n\tbnx2i_send_fw_iscsi_init_msg(hba);\n\twhile (!test_bit(ADAPTER_STATE_UP, &hba->adapter_state) &&\n\t       !test_bit(ADAPTER_STATE_INIT_FAILED, &hba->adapter_state) && i--)\n\t\tmsleep(BNX2I_INIT_POLL_TIME);\n}\n\n\n \nstatic void bnx2i_chip_cleanup(struct bnx2i_hba *hba)\n{\n\tstruct bnx2i_endpoint *bnx2i_ep;\n\tstruct list_head *pos, *tmp;\n\n\tif (hba->ofld_conns_active) {\n\t\t \n\t\tprintk(KERN_ALERT \"bnx2i: (%s) chip cleanup for %d active \"\n\t\t\t\"connections\\n\", hba->netdev->name,\n\t\t\thba->ofld_conns_active);\n\t\tmutex_lock(&hba->net_dev_lock);\n\t\tlist_for_each_safe(pos, tmp, &hba->ep_active_list) {\n\t\t\tbnx2i_ep = list_entry(pos, struct bnx2i_endpoint, link);\n\t\t\t \n\t\t\tbnx2i_hw_ep_disconnect(bnx2i_ep);\n\t\t\tbnx2i_ep->cm_sk = NULL;\n\t\t}\n\t\tmutex_unlock(&hba->net_dev_lock);\n\t}\n}\n\n\n \nvoid bnx2i_stop(void *handle)\n{\n\tstruct bnx2i_hba *hba = handle;\n\tint conns_active;\n\tint wait_delay = 1 * HZ;\n\n\t \n\tif (!test_and_set_bit(ADAPTER_STATE_GOING_DOWN,\n\t\t\t      &hba->adapter_state)) {\n\t\tiscsi_host_for_each_session(hba->shost,\n\t\t\t\t\t    bnx2i_drop_session);\n\t\twait_delay = hba->hba_shutdown_tmo;\n\t}\n\t \n\twait_event_interruptible_timeout(hba->eh_wait,\n\t\t\t\t\t (list_empty(&hba->ep_ofld_list) &&\n\t\t\t\t\t list_empty(&hba->ep_destroy_list)),\n\t\t\t\t\t 2 * HZ);\n\t \n\twhile (hba->ofld_conns_active) {\n\t\tconns_active = hba->ofld_conns_active;\n\t\twait_event_interruptible_timeout(hba->eh_wait,\n\t\t\t\t(hba->ofld_conns_active != conns_active),\n\t\t\t\twait_delay);\n\t\tif (hba->ofld_conns_active == conns_active)\n\t\t\tbreak;\n\t}\n\tbnx2i_chip_cleanup(hba);\n\n\t \n\tclear_bit(ADAPTER_STATE_GOING_DOWN, &hba->adapter_state);\n\tclear_bit(ADAPTER_STATE_UP, &hba->adapter_state);\n}\n\n\n \nstatic int bnx2i_init_one(struct bnx2i_hba *hba, struct cnic_dev *cnic)\n{\n\tint rc;\n\n\tmutex_lock(&bnx2i_dev_lock);\n\tif (!cnic->max_iscsi_conn) {\n\t\tprintk(KERN_ALERT \"bnx2i: dev %s does not support \"\n\t\t\t\"iSCSI\\n\", hba->netdev->name);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\thba->cnic = cnic;\n\trc = cnic->register_device(cnic, CNIC_ULP_ISCSI, hba);\n\tif (!rc) {\n\t\thba->age++;\n\t\tset_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);\n\t\tlist_add_tail(&hba->link, &adapter_list);\n\t\tadapter_count++;\n\t} else if (rc == -EBUSY) \t \n\t\tprintk(KERN_ALERT \"bnx2i, duplicate registration\"\n\t\t\t\t  \"hba=%p, cnic=%p\\n\", hba, cnic);\n\telse if (rc == -EAGAIN)\n\t\tprintk(KERN_ERR \"bnx2i, driver not registered\\n\");\n\telse if (rc == -EINVAL)\n\t\tprintk(KERN_ERR \"bnx2i, invalid type %d\\n\", CNIC_ULP_ISCSI);\n\telse\n\t\tprintk(KERN_ERR \"bnx2i dev reg, unknown error, %d\\n\", rc);\n\nout:\n\tmutex_unlock(&bnx2i_dev_lock);\n\n\treturn rc;\n}\n\n\n \nvoid bnx2i_ulp_init(struct cnic_dev *dev)\n{\n\tstruct bnx2i_hba *hba;\n\n\t \n\thba = bnx2i_alloc_hba(dev);\n\tif (!hba) {\n\t\tprintk(KERN_ERR \"bnx2i init: hba initialization failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tclear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);\n\tif (bnx2i_init_one(hba, dev)) {\n\t\tprintk(KERN_ERR \"bnx2i - hba %p init failed\\n\", hba);\n\t\tbnx2i_free_hba(hba);\n\t}\n}\n\n\n \nvoid bnx2i_ulp_exit(struct cnic_dev *dev)\n{\n\tstruct bnx2i_hba *hba;\n\n\thba = bnx2i_find_hba_for_cnic(dev);\n\tif (!hba) {\n\t\tprintk(KERN_INFO \"bnx2i_ulp_exit: hba not \"\n\t\t\t\t \"found, dev 0x%p\\n\", dev);\n\t\treturn;\n\t}\n\tmutex_lock(&bnx2i_dev_lock);\n\tlist_del_init(&hba->link);\n\tadapter_count--;\n\n\tif (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {\n\t\thba->cnic->unregister_device(hba->cnic, CNIC_ULP_ISCSI);\n\t\tclear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);\n\t}\n\tmutex_unlock(&bnx2i_dev_lock);\n\n\tbnx2i_free_hba(hba);\n}\n\n\n \nint bnx2i_get_stats(void *handle)\n{\n\tstruct bnx2i_hba *hba = handle;\n\tstruct iscsi_stats_info *stats;\n\n\tif (!hba)\n\t\treturn -EINVAL;\n\n\tstats = (struct iscsi_stats_info *)hba->cnic->stats_addr;\n\n\tif (!stats)\n\t\treturn -ENOMEM;\n\n\tstrscpy(stats->version, DRV_MODULE_VERSION, sizeof(stats->version));\n\tmemcpy(stats->mac_add1 + 2, hba->cnic->mac_addr, ETH_ALEN);\n\n\tstats->max_frame_size = hba->netdev->mtu;\n\tstats->txq_size = hba->max_sqes;\n\tstats->rxq_size = hba->max_cqes;\n\n\tstats->txq_avg_depth = 0;\n\tstats->rxq_avg_depth = 0;\n\n\tGET_STATS_64(hba, stats, rx_pdus);\n\tGET_STATS_64(hba, stats, rx_bytes);\n\n\tGET_STATS_64(hba, stats, tx_pdus);\n\tGET_STATS_64(hba, stats, tx_bytes);\n\n\treturn 0;\n}\n\n\n \nstatic int bnx2i_cpu_online(unsigned int cpu)\n{\n\tstruct bnx2i_percpu_s *p;\n\tstruct task_struct *thread;\n\n\tp = &per_cpu(bnx2i_percpu, cpu);\n\n\tthread = kthread_create_on_node(bnx2i_percpu_io_thread, (void *)p,\n\t\t\t\t\tcpu_to_node(cpu),\n\t\t\t\t\t\"bnx2i_thread/%d\", cpu);\n\tif (IS_ERR(thread))\n\t\treturn PTR_ERR(thread);\n\n\t \n\tkthread_bind(thread, cpu);\n\tp->iothread = thread;\n\twake_up_process(thread);\n\treturn 0;\n}\n\nstatic int bnx2i_cpu_offline(unsigned int cpu)\n{\n\tstruct bnx2i_percpu_s *p;\n\tstruct task_struct *thread;\n\tstruct bnx2i_work *work, *tmp;\n\n\t \n\tp = &per_cpu(bnx2i_percpu, cpu);\n\tspin_lock_bh(&p->p_work_lock);\n\tthread = p->iothread;\n\tp->iothread = NULL;\n\n\t \n\tlist_for_each_entry_safe(work, tmp, &p->work_list, list) {\n\t\tlist_del_init(&work->list);\n\t\tbnx2i_process_scsi_cmd_resp(work->session,\n\t\t\t\t\t    work->bnx2i_conn, &work->cqe);\n\t\tkfree(work);\n\t}\n\n\tspin_unlock_bh(&p->p_work_lock);\n\tif (thread)\n\t\tkthread_stop(thread);\n\treturn 0;\n}\n\nstatic enum cpuhp_state bnx2i_online_state;\n\n \nstatic int __init bnx2i_mod_init(void)\n{\n\tint err;\n\tunsigned cpu = 0;\n\tstruct bnx2i_percpu_s *p;\n\n\tprintk(KERN_INFO \"%s\", version);\n\n\tif (sq_size && !is_power_of_2(sq_size))\n\t\tsq_size = roundup_pow_of_two(sq_size);\n\n\tbnx2i_scsi_xport_template =\n\t\t\tiscsi_register_transport(&bnx2i_iscsi_transport);\n\tif (!bnx2i_scsi_xport_template) {\n\t\tprintk(KERN_ERR \"Could not register bnx2i transport.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = cnic_register_driver(CNIC_ULP_ISCSI, &bnx2i_cnic_cb);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Could not register bnx2i cnic driver.\\n\");\n\t\tgoto unreg_xport;\n\t}\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tp = &per_cpu(bnx2i_percpu, cpu);\n\t\tINIT_LIST_HEAD(&p->work_list);\n\t\tspin_lock_init(&p->p_work_lock);\n\t\tp->iothread = NULL;\n\t}\n\n\terr = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"scsi/bnx2i:online\",\n\t\t\t\tbnx2i_cpu_online, bnx2i_cpu_offline);\n\tif (err < 0)\n\t\tgoto unreg_driver;\n\tbnx2i_online_state = err;\n\treturn 0;\n\nunreg_driver:\n\tcnic_unregister_driver(CNIC_ULP_ISCSI);\nunreg_xport:\n\tiscsi_unregister_transport(&bnx2i_iscsi_transport);\nout:\n\treturn err;\n}\n\n\n \nstatic void __exit bnx2i_mod_exit(void)\n{\n\tstruct bnx2i_hba *hba;\n\n\tmutex_lock(&bnx2i_dev_lock);\n\twhile (!list_empty(&adapter_list)) {\n\t\thba = list_entry(adapter_list.next, struct bnx2i_hba, link);\n\t\tlist_del(&hba->link);\n\t\tadapter_count--;\n\n\t\tif (test_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic)) {\n\t\t\tbnx2i_chip_cleanup(hba);\n\t\t\thba->cnic->unregister_device(hba->cnic, CNIC_ULP_ISCSI);\n\t\t\tclear_bit(BNX2I_CNIC_REGISTERED, &hba->reg_with_cnic);\n\t\t}\n\n\t\tbnx2i_free_hba(hba);\n\t}\n\tmutex_unlock(&bnx2i_dev_lock);\n\n\tcpuhp_remove_state(bnx2i_online_state);\n\n\tiscsi_unregister_transport(&bnx2i_iscsi_transport);\n\tcnic_unregister_driver(CNIC_ULP_ISCSI);\n}\n\nmodule_init(bnx2i_mod_init);\nmodule_exit(bnx2i_mod_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}