{
  "module_name": "gvp11.c",
  "hash_id": "12f53249e7027e5c22563d34f8974e198780e88bdde1fa86a06373c1569ff265",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/gvp11.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/zorro.h>\n#include <linux/module.h>\n\n#include <asm/page.h>\n#include <asm/amigaints.h>\n#include <asm/amigahw.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include \"wd33c93.h\"\n#include \"gvp11.h\"\n\n\n#define CHECK_WD33C93\n\nstruct gvp11_hostdata {\n\tstruct WD33C93_hostdata wh;\n\tstruct gvp11_scsiregs *regs;\n\tstruct device *dev;\n};\n\n#define DMA_DIR(d)   ((d == DATA_OUT_DIR) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)\n#define TO_DMA_MASK(m)\t(~((unsigned long long)m & 0xffffffff))\n\nstatic irqreturn_t gvp11_intr(int irq, void *data)\n{\n\tstruct Scsi_Host *instance = data;\n\tstruct gvp11_hostdata *hdata = shost_priv(instance);\n\tunsigned int status = hdata->regs->CNTR;\n\tunsigned long flags;\n\n\tif (!(status & GVP11_DMAC_INT_PENDING))\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(instance->host_lock, flags);\n\twd33c93_intr(instance);\n\tspin_unlock_irqrestore(instance->host_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int gvp11_xfer_mask = 0;\n\nstatic int dma_setup(struct scsi_cmnd *cmd, int dir_in)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(cmd);\n\tunsigned long len = scsi_pointer->this_residual;\n\tstruct Scsi_Host *instance = cmd->device->host;\n\tstruct gvp11_hostdata *hdata = shost_priv(instance);\n\tstruct WD33C93_hostdata *wh = &hdata->wh;\n\tstruct gvp11_scsiregs *regs = hdata->regs;\n\tunsigned short cntr = GVP11_DMAC_INT_ENABLE;\n\tdma_addr_t addr;\n\tint bank_mask;\n\tstatic int scsi_alloc_out_of_range = 0;\n\n\taddr = dma_map_single(hdata->dev, scsi_pointer->ptr,\n\t\t\t      len, DMA_DIR(dir_in));\n\tif (dma_mapping_error(hdata->dev, addr)) {\n\t\tdev_warn(hdata->dev, \"cannot map SCSI data block %p\\n\",\n\t\t\t scsi_pointer->ptr);\n\t\treturn 1;\n\t}\n\tscsi_pointer->dma_handle = addr;\n\n\t \n\tif (addr & wh->dma_xfer_mask) {\n\t\t \n\t\tdma_unmap_single(hdata->dev, scsi_pointer->dma_handle,\n\t\t\t\t scsi_pointer->this_residual,\n\t\t\t\t DMA_DIR(dir_in));\n\t\tscsi_pointer->dma_handle = (dma_addr_t) NULL;\n\n\t\twh->dma_bounce_len = (scsi_pointer->this_residual + 511) & ~0x1ff;\n\n\t\tif (!scsi_alloc_out_of_range) {\n\t\t\twh->dma_bounce_buffer =\n\t\t\t\tkmalloc(wh->dma_bounce_len, GFP_KERNEL);\n\t\t\twh->dma_buffer_pool = BUF_SCSI_ALLOCED;\n\t\t}\n\n\t\tif (scsi_alloc_out_of_range ||\n\t\t    !wh->dma_bounce_buffer) {\n\t\t\twh->dma_bounce_buffer =\n\t\t\t\tamiga_chip_alloc(wh->dma_bounce_len,\n\t\t\t\t\t\t \"GVP II SCSI Bounce Buffer\");\n\n\t\t\tif (!wh->dma_bounce_buffer) {\n\t\t\t\twh->dma_bounce_len = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\twh->dma_buffer_pool = BUF_CHIP_ALLOCED;\n\t\t}\n\n\t\tif (!dir_in) {\n\t\t\t \n\t\t\tmemcpy(wh->dma_bounce_buffer, scsi_pointer->ptr,\n\t\t\t       scsi_pointer->this_residual);\n\t\t}\n\n\t\tif (wh->dma_buffer_pool == BUF_SCSI_ALLOCED) {\n\t\t \n\t\t\taddr = dma_map_single(hdata->dev,\n\t\t\t\t\t      wh->dma_bounce_buffer,\n\t\t\t\t\t      wh->dma_bounce_len,\n\t\t\t\t\t      DMA_DIR(dir_in));\n\t\t\t \n\t\t\tif (dma_mapping_error(hdata->dev, addr)) {\n\t\t\t\tdev_warn(hdata->dev,\n\t\t\t\t\t \"cannot map bounce buffer %p\\n\",\n\t\t\t\t\t wh->dma_bounce_buffer);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\n\t\tif (addr & wh->dma_xfer_mask) {\n\t\t\t \n\t\t\tdma_unmap_single(hdata->dev, scsi_pointer->dma_handle,\n\t\t\t\t\t scsi_pointer->this_residual,\n\t\t\t\t\t DMA_DIR(dir_in));\n\t\t\t \n\t\t\tif (wh->dma_buffer_pool == BUF_SCSI_ALLOCED) {\n\t\t\t\tkfree(wh->dma_bounce_buffer);\n\t\t\t\tscsi_alloc_out_of_range = 1;\n\t\t\t} else {\n\t\t\t\tamiga_chip_free(wh->dma_bounce_buffer);\n\t\t\t}\n\n\t\t\twh->dma_bounce_buffer =\n\t\t\t\tamiga_chip_alloc(wh->dma_bounce_len,\n\t\t\t\t\t\t \"GVP II SCSI Bounce Buffer\");\n\n\t\t\tif (!wh->dma_bounce_buffer) {\n\t\t\t\twh->dma_bounce_len = 0;\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (!dir_in) {\n\t\t\t\t \n\t\t\t\tmemcpy(wh->dma_bounce_buffer, scsi_pointer->ptr,\n\t\t\t\t       scsi_pointer->this_residual);\n\t\t\t}\n\t\t\t \n\t\t\taddr = virt_to_phys(wh->dma_bounce_buffer);\n\t\t\t \n\t\t\twh->dma_buffer_pool = BUF_CHIP_ALLOCED;\n\t\t}\n\t\t \n\t\tscsi_pointer->dma_handle = addr;\n\n\t}\n\n\t \n\tif (!dir_in)\n\t\tcntr |= GVP11_DMAC_DIR_WRITE;\n\n\twh->dma_dir = dir_in;\n\tregs->CNTR = cntr;\n\n\t \n\tregs->ACR = addr;\n\n\t \n\n\tbank_mask = (~wh->dma_xfer_mask >> 18) & 0x01c0;\n\tif (bank_mask)\n\t\tregs->BANK = bank_mask & (addr >> 18);\n\n\t \n\tregs->ST_DMA = 1;\n\n\t \n\treturn 0;\n}\n\nstatic void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,\n\t\t     int status)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(SCpnt);\n\tstruct gvp11_hostdata *hdata = shost_priv(instance);\n\tstruct WD33C93_hostdata *wh = &hdata->wh;\n\tstruct gvp11_scsiregs *regs = hdata->regs;\n\n\t \n\tregs->SP_DMA = 1;\n\t \n\tregs->CNTR = GVP11_DMAC_INT_ENABLE;\n\n\tif (wh->dma_buffer_pool == BUF_SCSI_ALLOCED)\n\t\tdma_unmap_single(hdata->dev, scsi_pointer->dma_handle,\n\t\t\t\t scsi_pointer->this_residual,\n\t\t\t\t DMA_DIR(wh->dma_dir));\n\n\t \n\tif (status && wh->dma_bounce_buffer) {\n\t\tif (wh->dma_dir && SCpnt)\n\t\t\tmemcpy(scsi_pointer->ptr, wh->dma_bounce_buffer,\n\t\t\t       scsi_pointer->this_residual);\n\n\t\tif (wh->dma_buffer_pool == BUF_SCSI_ALLOCED)\n\t\t\tkfree(wh->dma_bounce_buffer);\n\t\telse\n\t\t\tamiga_chip_free(wh->dma_bounce_buffer);\n\n\t\twh->dma_bounce_buffer = NULL;\n\t\twh->dma_bounce_len = 0;\n\t}\n}\n\nstatic const struct scsi_host_template gvp11_scsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"GVP Series II SCSI\",\n\t.show_info\t\t= wd33c93_show_info,\n\t.write_info\t\t= wd33c93_write_info,\n\t.proc_name\t\t= \"GVP11\",\n\t.queuecommand\t\t= wd33c93_queuecommand,\n\t.eh_abort_handler\t= wd33c93_abort,\n\t.eh_host_reset_handler\t= wd33c93_host_reset,\n\t.can_queue\t\t= CAN_QUEUE,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= CMD_PER_LUN,\n\t.dma_boundary\t\t= PAGE_SIZE - 1,\n\t.cmd_size\t\t= sizeof(struct scsi_pointer),\n};\n\nstatic int check_wd33c93(struct gvp11_scsiregs *regs)\n{\n#ifdef CHECK_WD33C93\n\tvolatile unsigned char *sasr_3393, *scmd_3393;\n\tunsigned char save_sasr;\n\tunsigned char q, qq;\n\n\t \n\n\t \n\n\tsasr_3393 = &regs->SASR;\n\tscmd_3393 = &regs->SCMD;\n\tsave_sasr = *sasr_3393;\n\n\t \n\n\tq = *sasr_3393;\t \n\tif (q & 0x08)\t \n\t\treturn -ENODEV;\n\t*sasr_3393 = WD_AUXILIARY_STATUS;\t \n\tif (*sasr_3393 == WD_AUXILIARY_STATUS) {\t \n\t\t*sasr_3393 = save_sasr;\t \n\t\treturn -ENODEV;\n\t}\n\tif (*sasr_3393 != q) {\t \n\t\t*sasr_3393 = save_sasr;\t \n\t\treturn -ENODEV;\n\t}\n\tif (*scmd_3393 != q)\t \n\t\treturn -ENODEV;\n\n\t \n\n\t*sasr_3393 = WD_SCSI_STATUS;\n\tq = *scmd_3393;\n\t*sasr_3393 = WD_SCSI_STATUS;\n\t*scmd_3393 = ~q;\n\t*sasr_3393 = WD_SCSI_STATUS;\n\tqq = *scmd_3393;\n\t*sasr_3393 = WD_SCSI_STATUS;\n\t*scmd_3393 = q;\n\tif (qq != q)\t \n\t\treturn -ENODEV;\n\t*sasr_3393 = 0x1e;\t \n\tq = *scmd_3393;\n\t*sasr_3393 = 0x1e;\n\t*scmd_3393 = ~q;\n\t*sasr_3393 = 0x1e;\n\tqq = *scmd_3393;\n\t*sasr_3393 = 0x1e;\n\t*scmd_3393 = q;\n\tif (qq != q || qq != 0xff)\t \n\t\treturn -ENODEV;\n\t*sasr_3393 = WD_TIMEOUT_PERIOD;\n\tq = *scmd_3393;\n\t*sasr_3393 = WD_TIMEOUT_PERIOD;\n\t*scmd_3393 = ~q;\n\t*sasr_3393 = WD_TIMEOUT_PERIOD;\n\tqq = *scmd_3393;\n\t*sasr_3393 = WD_TIMEOUT_PERIOD;\n\t*scmd_3393 = q;\n\tif (qq != (~q & 0xff))\t \n\t\treturn -ENODEV;\n#endif  \n\n\treturn 0;\n}\n\nstatic int gvp11_probe(struct zorro_dev *z, const struct zorro_device_id *ent)\n{\n\tstruct Scsi_Host *instance;\n\tunsigned long address;\n\tint error;\n\tunsigned int epc;\n\tunsigned int default_dma_xfer_mask;\n\tstruct gvp11_hostdata *hdata;\n\tstruct gvp11_scsiregs *regs;\n\twd33c93_regs wdregs;\n\n\tdefault_dma_xfer_mask = ent->driver_data;\n\n\tif (dma_set_mask_and_coherent(&z->dev,\n\t\tTO_DMA_MASK(default_dma_xfer_mask))) {\n\t\tdev_warn(&z->dev, \"cannot use DMA mask %llx\\n\",\n\t\t\t TO_DMA_MASK(default_dma_xfer_mask));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (zorro_resource_len(z) != 0x10000)\n\t\treturn -ENODEV;\n\n\taddress = z->resource.start;\n\tif (!request_mem_region(address, 256, \"wd33c93\"))\n\t\treturn -EBUSY;\n\n\tregs = ZTWO_VADDR(address);\n\n\terror = check_wd33c93(regs);\n\tif (error)\n\t\tgoto fail_check_or_alloc;\n\n\tinstance = scsi_host_alloc(&gvp11_scsi_template,\n\t\t\t\t   sizeof(struct gvp11_hostdata));\n\tif (!instance) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_check_or_alloc;\n\t}\n\n\tinstance->irq = IRQ_AMIGA_PORTS;\n\tinstance->unique_id = z->slotaddr;\n\n\tregs->secret2 = 1;\n\tregs->secret1 = 0;\n\tregs->secret3 = 15;\n\twhile (regs->CNTR & GVP11_DMAC_BUSY)\n\t\t;\n\tregs->CNTR = 0;\n\tregs->BANK = 0;\n\n\twdregs.SASR = &regs->SASR;\n\twdregs.SCMD = &regs->SCMD;\n\n\thdata = shost_priv(instance);\n\tif (gvp11_xfer_mask) {\n\t\thdata->wh.dma_xfer_mask = gvp11_xfer_mask;\n\t\tif (dma_set_mask_and_coherent(&z->dev,\n\t\t\tTO_DMA_MASK(gvp11_xfer_mask))) {\n\t\t\tdev_warn(&z->dev, \"cannot use DMA mask %llx\\n\",\n\t\t\t\t TO_DMA_MASK(gvp11_xfer_mask));\n\t\t\terror = -ENODEV;\n\t\t\tgoto fail_check_or_alloc;\n\t\t}\n\t} else\n\t\thdata->wh.dma_xfer_mask = default_dma_xfer_mask;\n\n\thdata->wh.no_sync = 0xff;\n\thdata->wh.fast = 0;\n\thdata->wh.dma_mode = CTRL_DMA;\n\thdata->regs = regs;\n\n\t \n\tepc = *(unsigned short *)(ZTWO_VADDR(address) + 0x8000);\n\twd33c93_init(instance, wdregs, dma_setup, dma_stop,\n\t\t     (epc & GVP_SCSICLKMASK) ? WD33C93_FS_8_10\n\t\t\t\t\t     : WD33C93_FS_12_15);\n\n\terror = request_irq(IRQ_AMIGA_PORTS, gvp11_intr, IRQF_SHARED,\n\t\t\t    \"GVP11 SCSI\", instance);\n\tif (error)\n\t\tgoto fail_irq;\n\n\tregs->CNTR = GVP11_DMAC_INT_ENABLE;\n\n\terror = scsi_add_host(instance, NULL);\n\tif (error)\n\t\tgoto fail_host;\n\n\tzorro_set_drvdata(z, instance);\n\tscsi_scan_host(instance);\n\treturn 0;\n\nfail_host:\n\tfree_irq(IRQ_AMIGA_PORTS, instance);\nfail_irq:\n\tscsi_host_put(instance);\nfail_check_or_alloc:\n\trelease_mem_region(address, 256);\n\treturn error;\n}\n\nstatic void gvp11_remove(struct zorro_dev *z)\n{\n\tstruct Scsi_Host *instance = zorro_get_drvdata(z);\n\tstruct gvp11_hostdata *hdata = shost_priv(instance);\n\n\thdata->regs->CNTR = 0;\n\tscsi_remove_host(instance);\n\tfree_irq(IRQ_AMIGA_PORTS, instance);\n\tscsi_host_put(instance);\n\trelease_mem_region(z->resource.start, 256);\n}\n\n\t \n\nstatic struct zorro_device_id gvp11_zorro_tbl[] = {\n\t{ ZORRO_PROD_GVP_COMBO_030_R3_SCSI,\t~0x00ffffff },\n\t{ ZORRO_PROD_GVP_SERIES_II,\t\t~0x00ffffff },\n\t{ ZORRO_PROD_GVP_GFORCE_030_SCSI,\t~0x01ffffff },\n\t{ ZORRO_PROD_GVP_A530_SCSI,\t\t~0x01ffffff },\n\t{ ZORRO_PROD_GVP_COMBO_030_R4_SCSI,\t~0x01ffffff },\n\t{ ZORRO_PROD_GVP_A1291,\t\t\t~0x07ffffff },\n\t{ ZORRO_PROD_GVP_GFORCE_040_SCSI_1,\t~0x07ffffff },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(zorro, gvp11_zorro_tbl);\n\nstatic struct zorro_driver gvp11_driver = {\n\t.name\t\t= \"gvp11\",\n\t.id_table\t= gvp11_zorro_tbl,\n\t.probe\t\t= gvp11_probe,\n\t.remove\t\t= gvp11_remove,\n};\n\nstatic int __init gvp11_init(void)\n{\n\treturn zorro_register_driver(&gvp11_driver);\n}\nmodule_init(gvp11_init);\n\nstatic void __exit gvp11_exit(void)\n{\n\tzorro_unregister_driver(&gvp11_driver);\n}\nmodule_exit(gvp11_exit);\n\nMODULE_DESCRIPTION(\"GVP Series II SCSI\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}