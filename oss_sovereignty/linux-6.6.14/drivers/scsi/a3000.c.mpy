{
  "module_name": "a3000.c",
  "hash_id": "9ba37e9ae34bcdd6786e0ac2e5e4dae7c1e8b9a6d3f3ce1b476b7416af08d134",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/a3000.c",
  "human_readable_source": "\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n\n#include <asm/page.h>\n#include <asm/amigaints.h>\n#include <asm/amigahw.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include \"wd33c93.h\"\n#include \"a3000.h\"\n\n\nstruct a3000_hostdata {\n\tstruct WD33C93_hostdata wh;\n\tstruct a3000_scsiregs *regs;\n\tstruct device *dev;\n};\n\n#define DMA_DIR(d)   ((d == DATA_OUT_DIR) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)\n\nstatic irqreturn_t a3000_intr(int irq, void *data)\n{\n\tstruct Scsi_Host *instance = data;\n\tstruct a3000_hostdata *hdata = shost_priv(instance);\n\tunsigned int status = hdata->regs->ISTR;\n\tunsigned long flags;\n\n\tif (!(status & ISTR_INT_P))\n\t\treturn IRQ_NONE;\n\tif (status & ISTR_INTS) {\n\t\tspin_lock_irqsave(instance->host_lock, flags);\n\t\twd33c93_intr(instance);\n\t\tspin_unlock_irqrestore(instance->host_lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\tpr_warn(\"Non-serviced A3000 SCSI-interrupt? ISTR = %02x\\n\", status);\n\treturn IRQ_NONE;\n}\n\nstatic int dma_setup(struct scsi_cmnd *cmd, int dir_in)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(cmd);\n\tunsigned long len = scsi_pointer->this_residual;\n\tstruct Scsi_Host *instance = cmd->device->host;\n\tstruct a3000_hostdata *hdata = shost_priv(instance);\n\tstruct WD33C93_hostdata *wh = &hdata->wh;\n\tstruct a3000_scsiregs *regs = hdata->regs;\n\tunsigned short cntr = CNTR_PDMD | CNTR_INTEN;\n\tdma_addr_t addr;\n\n\taddr = dma_map_single(hdata->dev, scsi_pointer->ptr,\n\t\t\t      len, DMA_DIR(dir_in));\n\tif (dma_mapping_error(hdata->dev, addr)) {\n\t\tdev_warn(hdata->dev, \"cannot map SCSI data block %p\\n\",\n\t\t\t scsi_pointer->ptr);\n\t\treturn 1;\n\t}\n\tscsi_pointer->dma_handle = addr;\n\n\t \n\tif (addr & A3000_XFER_MASK) {\n\t\tWARN_ONCE(1, \"Invalid alignment for DMA!\");\n\t\t \n\t\tdma_unmap_single(hdata->dev, scsi_pointer->dma_handle,\n\t\t\t\t scsi_pointer->this_residual,\n\t\t\t\t DMA_DIR(dir_in));\n\n\t\twh->dma_bounce_len = (scsi_pointer->this_residual + 511) & ~0x1ff;\n\t\twh->dma_bounce_buffer = kmalloc(wh->dma_bounce_len,\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\t \n\t\tif (!wh->dma_bounce_buffer) {\n\t\t\twh->dma_bounce_len = 0;\n\t\t\tscsi_pointer->dma_handle = (dma_addr_t) NULL;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (!dir_in) {\n\t\t\t \n\t\t\tmemcpy(wh->dma_bounce_buffer, scsi_pointer->ptr,\n\t\t\t       scsi_pointer->this_residual);\n\t\t}\n\n\t\taddr = dma_map_single(hdata->dev, scsi_pointer->ptr,\n\t\t\t\t      len, DMA_DIR(dir_in));\n\t\tif (dma_mapping_error(hdata->dev, addr)) {\n\t\t\tdev_warn(hdata->dev,\n\t\t\t\t \"cannot map SCSI data block %p\\n\",\n\t\t\t\t scsi_pointer->ptr);\n\t\t\treturn 1;\n\t\t}\n\t\tscsi_pointer->dma_handle = addr;\n\t}\n\n\t \n\tif (!dir_in)\n\t\tcntr |= CNTR_DDIR;\n\n\t \n\twh->dma_dir = dir_in;\n\n\tregs->CNTR = cntr;\n\n\t \n\tregs->ACR = addr;\n\n\t \n\n\t \n\tmb();\t\t\t \n\tregs->ST_DMA = 1;\n\tmb();\t\t\t \n\n\t \n\treturn 0;\n}\n\nstatic void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,\n\t\t     int status)\n{\n\tstruct scsi_pointer *scsi_pointer = WD33C93_scsi_pointer(SCpnt);\n\tstruct a3000_hostdata *hdata = shost_priv(instance);\n\tstruct WD33C93_hostdata *wh = &hdata->wh;\n\tstruct a3000_scsiregs *regs = hdata->regs;\n\n\t \n\tunsigned short cntr = CNTR_PDMD;\n\n\tif (!wh->dma_dir)\n\t\tcntr |= CNTR_DDIR;\n\n\tregs->CNTR = cntr;\n\tmb();\t\t\t \n\n\t \n\tif (wh->dma_dir) {\n\t\tregs->FLUSH = 1;\n\t\tmb();\t\t \n\t\twhile (!(regs->ISTR & ISTR_FE_FLG))\n\t\t\tbarrier();\n\t\tmb();\t\t \n\t}\n\n\t \n\t \n\tregs->CINT = 1;\n\n\t \n\tregs->SP_DMA = 1;\n\tmb();\t\t\t \n\n\t \n\tregs->CNTR = CNTR_PDMD | CNTR_INTEN;\n\tmb();\t\t\t \n\n\tdma_unmap_single(hdata->dev, scsi_pointer->dma_handle,\n\t\t\t scsi_pointer->this_residual,\n\t\t\t DMA_DIR(wh->dma_dir));\n\n\t \n\tif (status && wh->dma_bounce_buffer) {\n\t\tif (SCpnt) {\n\t\t\tif (wh->dma_dir && SCpnt)\n\t\t\t\tmemcpy(scsi_pointer->ptr, wh->dma_bounce_buffer,\n\t\t\t\t       scsi_pointer->this_residual);\n\t\t\tkfree(wh->dma_bounce_buffer);\n\t\t\twh->dma_bounce_buffer = NULL;\n\t\t\twh->dma_bounce_len = 0;\n\t\t} else {\n\t\t\tkfree(wh->dma_bounce_buffer);\n\t\t\twh->dma_bounce_buffer = NULL;\n\t\t\twh->dma_bounce_len = 0;\n\t\t}\n\t}\n}\n\nstatic const struct scsi_host_template amiga_a3000_scsi_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"Amiga 3000 built-in SCSI\",\n\t.show_info\t\t= wd33c93_show_info,\n\t.write_info\t\t= wd33c93_write_info,\n\t.proc_name\t\t= \"A3000\",\n\t.queuecommand\t\t= wd33c93_queuecommand,\n\t.eh_abort_handler\t= wd33c93_abort,\n\t.eh_host_reset_handler\t= wd33c93_host_reset,\n\t.can_queue\t\t= CAN_QUEUE,\n\t.this_id\t\t= 7,\n\t.sg_tablesize\t\t= SG_ALL,\n\t.cmd_per_lun\t\t= CMD_PER_LUN,\n\t.cmd_size\t\t= sizeof(struct scsi_pointer),\n};\n\nstatic int __init amiga_a3000_scsi_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct Scsi_Host *instance;\n\tint error;\n\tstruct a3000_scsiregs *regs;\n\twd33c93_regs wdregs;\n\tstruct a3000_hostdata *hdata;\n\n\tif (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tdev_warn(&pdev->dev, \"cannot use 32 bit DMA\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tif (!request_mem_region(res->start, resource_size(res), \"wd33c93\"))\n\t\treturn -EBUSY;\n\n\tinstance = scsi_host_alloc(&amiga_a3000_scsi_template,\n\t\t\t\t   sizeof(struct a3000_hostdata));\n\tif (!instance) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_alloc;\n\t}\n\n\tinstance->irq = IRQ_AMIGA_PORTS;\n\n\tregs = ZTWO_VADDR(res->start);\n\tregs->DAWR = DAWR_A3000;\n\n\twdregs.SASR = &regs->SASR;\n\twdregs.SCMD = &regs->SCMD;\n\n\thdata = shost_priv(instance);\n\thdata->dev = &pdev->dev;\n\thdata->wh.no_sync = 0xff;\n\thdata->wh.fast = 0;\n\thdata->wh.dma_mode = CTRL_DMA;\n\thdata->regs = regs;\n\n\twd33c93_init(instance, wdregs, dma_setup, dma_stop, WD33C93_FS_12_15);\n\terror = request_irq(IRQ_AMIGA_PORTS, a3000_intr, IRQF_SHARED,\n\t\t\t    \"A3000 SCSI\", instance);\n\tif (error)\n\t\tgoto fail_irq;\n\n\tregs->CNTR = CNTR_PDMD | CNTR_INTEN;\n\n\terror = scsi_add_host(instance, NULL);\n\tif (error)\n\t\tgoto fail_host;\n\n\tplatform_set_drvdata(pdev, instance);\n\n\tscsi_scan_host(instance);\n\treturn 0;\n\nfail_host:\n\tfree_irq(IRQ_AMIGA_PORTS, instance);\nfail_irq:\n\tscsi_host_put(instance);\nfail_alloc:\n\trelease_mem_region(res->start, resource_size(res));\n\treturn error;\n}\n\nstatic int __exit amiga_a3000_scsi_remove(struct platform_device *pdev)\n{\n\tstruct Scsi_Host *instance = platform_get_drvdata(pdev);\n\tstruct a3000_hostdata *hdata = shost_priv(instance);\n\tstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\thdata->regs->CNTR = 0;\n\tscsi_remove_host(instance);\n\tfree_irq(IRQ_AMIGA_PORTS, instance);\n\tscsi_host_put(instance);\n\trelease_mem_region(res->start, resource_size(res));\n\treturn 0;\n}\n\nstatic struct platform_driver amiga_a3000_scsi_driver = {\n\t.remove = __exit_p(amiga_a3000_scsi_remove),\n\t.driver   = {\n\t\t.name\t= \"amiga-a3000-scsi\",\n\t},\n};\n\nmodule_platform_driver_probe(amiga_a3000_scsi_driver, amiga_a3000_scsi_probe);\n\nMODULE_DESCRIPTION(\"Amiga 3000 built-in SCSI\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:amiga-a3000-scsi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}