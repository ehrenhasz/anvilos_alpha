{
  "module_name": "superpipe.c",
  "hash_id": "55c530af05027d83052b06872362c953fe64ad8dc5e9c7b033971f48c3e2540f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/cxlflash/superpipe.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/file.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/syscalls.h>\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_eh.h>\n#include <uapi/scsi/cxlflash_ioctl.h>\n\n#include \"sislite.h\"\n#include \"common.h\"\n#include \"vlun.h\"\n#include \"superpipe.h\"\n\nstruct cxlflash_global global;\n\n \nstatic void marshal_rele_to_resize(struct dk_cxlflash_release *release,\n\t\t\t\t   struct dk_cxlflash_resize *resize)\n{\n\tresize->hdr = release->hdr;\n\tresize->context_id = release->context_id;\n\tresize->rsrc_handle = release->rsrc_handle;\n}\n\n \nstatic void marshal_det_to_rele(struct dk_cxlflash_detach *detach,\n\t\t\t\tstruct dk_cxlflash_release *release)\n{\n\trelease->hdr = detach->hdr;\n\trelease->context_id = detach->context_id;\n}\n\n \nstatic void marshal_udir_to_rele(struct dk_cxlflash_udirect *udirect,\n\t\t\t\t struct dk_cxlflash_release *release)\n{\n\trelease->hdr = udirect->hdr;\n\trelease->context_id = udirect->context_id;\n\trelease->rsrc_handle = udirect->rsrc_handle;\n}\n\n \nvoid cxlflash_free_errpage(void)\n{\n\n\tmutex_lock(&global.mutex);\n\tif (global.err_page) {\n\t\t__free_page(global.err_page);\n\t\tglobal.err_page = NULL;\n\t}\n\tmutex_unlock(&global.mutex);\n}\n\n \nvoid cxlflash_stop_term_user_contexts(struct cxlflash_cfg *cfg)\n{\n\tstruct device *dev = &cfg->dev->dev;\n\tint i, found = true;\n\n\tcxlflash_mark_contexts_error(cfg);\n\n\twhile (true) {\n\t\tfor (i = 0; i < MAX_CONTEXT; i++)\n\t\t\tif (cfg->ctx_tbl[i]) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!found && list_empty(&cfg->ctx_err_recovery))\n\t\t\treturn;\n\n\t\tdev_dbg(dev, \"%s: Wait for user contexts to quiesce...\\n\",\n\t\t\t__func__);\n\t\twake_up_all(&cfg->reset_waitq);\n\t\tssleep(1);\n\t\tfound = false;\n\t}\n}\n\n \nstatic struct ctx_info *find_error_context(struct cxlflash_cfg *cfg, u64 rctxid,\n\t\t\t\t\t   struct file *file)\n{\n\tstruct ctx_info *ctxi;\n\n\tlist_for_each_entry(ctxi, &cfg->ctx_err_recovery, list)\n\t\tif ((ctxi->ctxid == rctxid) || (ctxi->file == file))\n\t\t\treturn ctxi;\n\n\treturn NULL;\n}\n\n \nstruct ctx_info *get_context(struct cxlflash_cfg *cfg, u64 rctxid,\n\t\t\t     void *arg, enum ctx_ctrl ctx_ctrl)\n{\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct ctx_info *ctxi = NULL;\n\tstruct lun_access *lun_access = NULL;\n\tstruct file *file = NULL;\n\tstruct llun_info *lli = arg;\n\tu64 ctxid = DECODE_CTXID(rctxid);\n\tint rc;\n\tpid_t pid = task_tgid_nr(current), ctxpid = 0;\n\n\tif (ctx_ctrl & CTX_CTRL_FILE) {\n\t\tlli = NULL;\n\t\tfile = (struct file *)arg;\n\t}\n\n\tif (ctx_ctrl & CTX_CTRL_CLONE)\n\t\tpid = task_ppid_nr(current);\n\n\tif (likely(ctxid < MAX_CONTEXT)) {\n\t\twhile (true) {\n\t\t\tmutex_lock(&cfg->ctx_tbl_list_mutex);\n\t\t\tctxi = cfg->ctx_tbl[ctxid];\n\t\t\tif (ctxi)\n\t\t\t\tif ((file && (ctxi->file != file)) ||\n\t\t\t\t    (!file && (ctxi->ctxid != rctxid)))\n\t\t\t\t\tctxi = NULL;\n\n\t\t\tif ((ctx_ctrl & CTX_CTRL_ERR) ||\n\t\t\t    (!ctxi && (ctx_ctrl & CTX_CTRL_ERR_FALLBACK)))\n\t\t\t\tctxi = find_error_context(cfg, rctxid, file);\n\t\t\tif (!ctxi) {\n\t\t\t\tmutex_unlock(&cfg->ctx_tbl_list_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\trc = mutex_trylock(&ctxi->mutex);\n\t\t\tmutex_unlock(&cfg->ctx_tbl_list_mutex);\n\t\t\tif (rc)\n\t\t\t\tbreak;  \n\t\t}\n\n\t\tif (ctxi->unavail)\n\t\t\tgoto denied;\n\n\t\tctxpid = ctxi->pid;\n\t\tif (likely(!(ctx_ctrl & CTX_CTRL_NOPID)))\n\t\t\tif (pid != ctxpid)\n\t\t\t\tgoto denied;\n\n\t\tif (lli) {\n\t\t\tlist_for_each_entry(lun_access, &ctxi->luns, list)\n\t\t\t\tif (lun_access->lli == lli)\n\t\t\t\t\tgoto out;\n\t\t\tgoto denied;\n\t\t}\n\t}\n\nout:\n\tdev_dbg(dev, \"%s: rctxid=%016llx ctxinfo=%p ctxpid=%u pid=%u \"\n\t\t\"ctx_ctrl=%u\\n\", __func__, rctxid, ctxi, ctxpid, pid,\n\t\tctx_ctrl);\n\n\treturn ctxi;\n\ndenied:\n\tmutex_unlock(&ctxi->mutex);\n\tctxi = NULL;\n\tgoto out;\n}\n\n \nvoid put_context(struct ctx_info *ctxi)\n{\n\tmutex_unlock(&ctxi->mutex);\n}\n\n \nstatic int afu_attach(struct cxlflash_cfg *cfg, struct ctx_info *ctxi)\n{\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct afu *afu = cfg->afu;\n\tstruct sisl_ctrl_map __iomem *ctrl_map = ctxi->ctrl_map;\n\tint rc = 0;\n\tstruct hwq *hwq = get_hwq(afu, PRIMARY_HWQ);\n\tu64 val;\n\tint i;\n\n\t \n\treadq_be(&ctrl_map->mbox_r);\n\tval = (SISL_CTX_CAP_READ_CMD | SISL_CTX_CAP_WRITE_CMD);\n\twriteq_be(val, &ctrl_map->ctx_cap);\n\tval = readq_be(&ctrl_map->ctx_cap);\n\tif (val != (SISL_CTX_CAP_READ_CMD | SISL_CTX_CAP_WRITE_CMD)) {\n\t\tdev_err(dev, \"%s: ctx may be closed val=%016llx\\n\",\n\t\t\t__func__, val);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (afu_is_ocxl_lisn(afu)) {\n\t\t \n\t\tfor (i = 0; i < ctxi->irqs; i++) {\n\t\t\tval = cfg->ops->get_irq_objhndl(ctxi->ctx, i);\n\t\t\twriteq_be(val, &ctrl_map->lisn_ea[i]);\n\t\t}\n\n\t\t \n\t\tval = hwq->ctx_hndl;\n\t\twriteq_be(SISL_LISN_PASID(val, val), &ctrl_map->lisn_pasid[0]);\n\t\twriteq_be(SISL_LISN_PASID(0UL, val), &ctrl_map->lisn_pasid[1]);\n\t}\n\n\t \n\twriteq_be((u64)ctxi->rht_start, &ctrl_map->rht_start);\n\tval = SISL_RHT_CNT_ID((u64)MAX_RHT_PER_CONTEXT, (u64)(hwq->ctx_hndl));\n\twriteq_be(val, &ctrl_map->rht_cnt_id);\nout:\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic int read_cap16(struct scsi_device *sdev, struct llun_info *lli)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct glun_info *gli = lli->parent;\n\tstruct scsi_sense_hdr sshdr;\n\tconst struct scsi_exec_args exec_args = {\n\t\t.sshdr = &sshdr,\n\t};\n\tu8 *cmd_buf = NULL;\n\tu8 *scsi_cmd = NULL;\n\tint rc = 0;\n\tint result = 0;\n\tint retry_cnt = 0;\n\tu32 to = CMD_TIMEOUT * HZ;\n\nretry:\n\tcmd_buf = kzalloc(CMD_BUFSIZE, GFP_KERNEL);\n\tscsi_cmd = kzalloc(MAX_COMMAND_SIZE, GFP_KERNEL);\n\tif (unlikely(!cmd_buf || !scsi_cmd)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tscsi_cmd[0] = SERVICE_ACTION_IN_16;\t \n\tscsi_cmd[1] = SAI_READ_CAPACITY_16;\t \n\tput_unaligned_be32(CMD_BUFSIZE, &scsi_cmd[10]);\n\n\tdev_dbg(dev, \"%s: %ssending cmd(%02x)\\n\", __func__,\n\t\tretry_cnt ? \"re\" : \"\", scsi_cmd[0]);\n\n\t \n\tup_read(&cfg->ioctl_rwsem);\n\tresult = scsi_execute_cmd(sdev, scsi_cmd, REQ_OP_DRV_IN, cmd_buf,\n\t\t\t\t  CMD_BUFSIZE, to, CMD_RETRIES, &exec_args);\n\tdown_read(&cfg->ioctl_rwsem);\n\trc = check_state(cfg);\n\tif (rc) {\n\t\tdev_err(dev, \"%s: Failed state result=%08x\\n\",\n\t\t\t__func__, result);\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (result > 0 && scsi_sense_valid(&sshdr)) {\n\t\tif (result & SAM_STAT_CHECK_CONDITION) {\n\t\t\tswitch (sshdr.sense_key) {\n\t\t\tcase NO_SENSE:\n\t\t\tcase RECOVERED_ERROR:\n\t\t\tcase NOT_READY:\n\t\t\t\tresult &= ~SAM_STAT_CHECK_CONDITION;\n\t\t\t\tbreak;\n\t\t\tcase UNIT_ATTENTION:\n\t\t\t\tswitch (sshdr.asc) {\n\t\t\t\tcase 0x29:  \n\t\t\t\t\tfallthrough;\n\t\t\t\tcase 0x2A:  \n\t\t\t\tcase 0x3F:  \n\t\t\t\t\t \n\t\t\t\t\tif (retry_cnt++ < 1) {\n\t\t\t\t\t\tkfree(cmd_buf);\n\t\t\t\t\t\tkfree(scsi_cmd);\n\t\t\t\t\t\tgoto retry;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (result) {\n\t\tdev_err(dev, \"%s: command failed, result=%08x\\n\",\n\t\t\t__func__, result);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_lock(&gli->mutex);\n\tgli->max_lba = be64_to_cpu(*((__be64 *)&cmd_buf[0]));\n\tgli->blk_len = be32_to_cpu(*((__be32 *)&cmd_buf[8]));\n\tmutex_unlock(&gli->mutex);\n\nout:\n\tkfree(cmd_buf);\n\tkfree(scsi_cmd);\n\n\tdev_dbg(dev, \"%s: maxlba=%lld blklen=%d rc=%d\\n\",\n\t\t__func__, gli->max_lba, gli->blk_len, rc);\n\treturn rc;\n}\n\n \nstruct sisl_rht_entry *get_rhte(struct ctx_info *ctxi, res_hndl_t rhndl,\n\t\t\t\tstruct llun_info *lli)\n{\n\tstruct cxlflash_cfg *cfg = ctxi->cfg;\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct sisl_rht_entry *rhte = NULL;\n\n\tif (unlikely(!ctxi->rht_start)) {\n\t\tdev_dbg(dev, \"%s: Context does not have allocated RHT\\n\",\n\t\t\t __func__);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(rhndl >= MAX_RHT_PER_CONTEXT)) {\n\t\tdev_dbg(dev, \"%s: Bad resource handle rhndl=%d\\n\",\n\t\t\t__func__, rhndl);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(ctxi->rht_lun[rhndl] != lli)) {\n\t\tdev_dbg(dev, \"%s: Bad resource handle LUN rhndl=%d\\n\",\n\t\t\t__func__, rhndl);\n\t\tgoto out;\n\t}\n\n\trhte = &ctxi->rht_start[rhndl];\n\tif (unlikely(rhte->nmask == 0)) {\n\t\tdev_dbg(dev, \"%s: Unopened resource handle rhndl=%d\\n\",\n\t\t\t__func__, rhndl);\n\t\trhte = NULL;\n\t\tgoto out;\n\t}\n\nout:\n\treturn rhte;\n}\n\n \nstruct sisl_rht_entry *rhte_checkout(struct ctx_info *ctxi,\n\t\t\t\t     struct llun_info *lli)\n{\n\tstruct cxlflash_cfg *cfg = ctxi->cfg;\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct sisl_rht_entry *rhte = NULL;\n\tint i;\n\n\t \n\tfor (i = 0; i < MAX_RHT_PER_CONTEXT; i++)\n\t\tif (ctxi->rht_start[i].nmask == 0) {\n\t\t\trhte = &ctxi->rht_start[i];\n\t\t\tctxi->rht_out++;\n\t\t\tbreak;\n\t\t}\n\n\tif (likely(rhte))\n\t\tctxi->rht_lun[i] = lli;\n\n\tdev_dbg(dev, \"%s: returning rhte=%p index=%d\\n\", __func__, rhte, i);\n\treturn rhte;\n}\n\n \nvoid rhte_checkin(struct ctx_info *ctxi,\n\t\t  struct sisl_rht_entry *rhte)\n{\n\tu32 rsrc_handle = rhte - ctxi->rht_start;\n\n\trhte->nmask = 0;\n\trhte->fp = 0;\n\tctxi->rht_out--;\n\tctxi->rht_lun[rsrc_handle] = NULL;\n\tctxi->rht_needs_ws[rsrc_handle] = false;\n}\n\n \nstatic void rht_format1(struct sisl_rht_entry *rhte, u64 lun_id, u32 perm,\n\t\t\tu32 port_sel)\n{\n\t \n\tstruct sisl_rht_entry_f1 dummy = { 0 };\n\tstruct sisl_rht_entry_f1 *rhte_f1 = (struct sisl_rht_entry_f1 *)rhte;\n\n\tmemset(rhte_f1, 0, sizeof(*rhte_f1));\n\trhte_f1->fp = SISL_RHT_FP(1U, 0);\n\tdma_wmb();  \n\n\trhte_f1->lun_id = lun_id;\n\tdma_wmb();  \n\n\t \n\tdummy.valid = 0x80;\n\tdummy.fp = SISL_RHT_FP(1U, perm);\n\tdummy.port_sel = port_sel;\n\trhte_f1->dw = dummy.dw;\n\n\tdma_wmb();  \n}\n\n \nint cxlflash_lun_attach(struct glun_info *gli, enum lun_mode mode, bool locked)\n{\n\tint rc = 0;\n\n\tif (!locked)\n\t\tmutex_lock(&gli->mutex);\n\n\tif (gli->mode == MODE_NONE)\n\t\tgli->mode = mode;\n\telse if (gli->mode != mode) {\n\t\tpr_debug(\"%s: gli_mode=%d requested_mode=%d\\n\",\n\t\t\t __func__, gli->mode, mode);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tgli->users++;\n\tWARN_ON(gli->users <= 0);\nout:\n\tpr_debug(\"%s: Returning rc=%d gli->mode=%u gli->users=%u\\n\",\n\t\t __func__, rc, gli->mode, gli->users);\n\tif (!locked)\n\t\tmutex_unlock(&gli->mutex);\n\treturn rc;\n}\n\n \nvoid cxlflash_lun_detach(struct glun_info *gli)\n{\n\tmutex_lock(&gli->mutex);\n\tWARN_ON(gli->mode == MODE_NONE);\n\tif (--gli->users == 0) {\n\t\tgli->mode = MODE_NONE;\n\t\tcxlflash_ba_terminate(&gli->blka.ba_lun);\n\t}\n\tpr_debug(\"%s: gli->users=%u\\n\", __func__, gli->users);\n\tWARN_ON(gli->users < 0);\n\tmutex_unlock(&gli->mutex);\n}\n\n \nint _cxlflash_disk_release(struct scsi_device *sdev,\n\t\t\t   struct ctx_info *ctxi,\n\t\t\t   struct dk_cxlflash_release *release)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tstruct afu *afu = cfg->afu;\n\tbool put_ctx = false;\n\n\tstruct dk_cxlflash_resize size;\n\tres_hndl_t rhndl = release->rsrc_handle;\n\n\tint rc = 0;\n\tint rcr = 0;\n\tu64 ctxid = DECODE_CTXID(release->context_id),\n\t    rctxid = release->context_id;\n\n\tstruct sisl_rht_entry *rhte;\n\tstruct sisl_rht_entry_f1 *rhte_f1;\n\n\tdev_dbg(dev, \"%s: ctxid=%llu rhndl=%llu gli->mode=%u gli->users=%u\\n\",\n\t\t__func__, ctxid, release->rsrc_handle, gli->mode, gli->users);\n\n\tif (!ctxi) {\n\t\tctxi = get_context(cfg, rctxid, lli, CTX_CTRL_ERR_FALLBACK);\n\t\tif (unlikely(!ctxi)) {\n\t\t\tdev_dbg(dev, \"%s: Bad context ctxid=%llu\\n\",\n\t\t\t\t__func__, ctxid);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tput_ctx = true;\n\t}\n\n\trhte = get_rhte(ctxi, rhndl, lli);\n\tif (unlikely(!rhte)) {\n\t\tdev_dbg(dev, \"%s: Bad resource handle rhndl=%d\\n\",\n\t\t\t__func__, rhndl);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (gli->mode) {\n\tcase MODE_VIRTUAL:\n\t\tmarshal_rele_to_resize(release, &size);\n\t\tsize.req_size = 0;\n\t\trc = _cxlflash_vlun_resize(sdev, ctxi, &size);\n\t\tif (rc) {\n\t\t\tdev_dbg(dev, \"%s: resize failed rc %d\\n\", __func__, rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbreak;\n\tcase MODE_PHYSICAL:\n\t\t \n\t\trhte_f1 = (struct sisl_rht_entry_f1 *)rhte;\n\n\t\trhte_f1->valid = 0;\n\t\tdma_wmb();  \n\n\t\trhte_f1->lun_id = 0;\n\t\tdma_wmb();  \n\n\t\trhte_f1->dw = 0;\n\t\tdma_wmb();  \n\n\t\tif (!ctxi->err_recovery_active) {\n\t\t\trcr = cxlflash_afu_sync(afu, ctxid, rhndl, AFU_HW_SYNC);\n\t\t\tif (unlikely(rcr))\n\t\t\t\tdev_dbg(dev, \"%s: AFU sync failed rc=%d\\n\",\n\t\t\t\t\t__func__, rcr);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unsupported LUN mode!\");\n\t\tgoto out;\n\t}\n\n\trhte_checkin(ctxi, rhte);\n\tcxlflash_lun_detach(gli);\n\nout:\n\tif (put_ctx)\n\t\tput_context(ctxi);\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nint cxlflash_disk_release(struct scsi_device *sdev,\n\t\t\t  struct dk_cxlflash_release *release)\n{\n\treturn _cxlflash_disk_release(sdev, NULL, release);\n}\n\n \nstatic void destroy_context(struct cxlflash_cfg *cfg,\n\t\t\t    struct ctx_info *ctxi)\n{\n\tstruct afu *afu = cfg->afu;\n\n\tif (ctxi->initialized) {\n\t\tWARN_ON(!list_empty(&ctxi->luns));\n\n\t\t \n\t\tif (afu->afu_map && ctxi->ctrl_map) {\n\t\t\twriteq_be(0, &ctxi->ctrl_map->rht_start);\n\t\t\twriteq_be(0, &ctxi->ctrl_map->rht_cnt_id);\n\t\t\twriteq_be(0, &ctxi->ctrl_map->ctx_cap);\n\t\t}\n\t}\n\n\t \n\tfree_page((ulong)ctxi->rht_start);\n\tkfree(ctxi->rht_needs_ws);\n\tkfree(ctxi->rht_lun);\n\tkfree(ctxi);\n}\n\n \nstatic struct ctx_info *create_context(struct cxlflash_cfg *cfg)\n{\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct ctx_info *ctxi = NULL;\n\tstruct llun_info **lli = NULL;\n\tu8 *ws = NULL;\n\tstruct sisl_rht_entry *rhte;\n\n\tctxi = kzalloc(sizeof(*ctxi), GFP_KERNEL);\n\tlli = kzalloc((MAX_RHT_PER_CONTEXT * sizeof(*lli)), GFP_KERNEL);\n\tws = kzalloc((MAX_RHT_PER_CONTEXT * sizeof(*ws)), GFP_KERNEL);\n\tif (unlikely(!ctxi || !lli || !ws)) {\n\t\tdev_err(dev, \"%s: Unable to allocate context\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\trhte = (struct sisl_rht_entry *)get_zeroed_page(GFP_KERNEL);\n\tif (unlikely(!rhte)) {\n\t\tdev_err(dev, \"%s: Unable to allocate RHT\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\tctxi->rht_lun = lli;\n\tctxi->rht_needs_ws = ws;\n\tctxi->rht_start = rhte;\nout:\n\treturn ctxi;\n\nerr:\n\tkfree(ws);\n\tkfree(lli);\n\tkfree(ctxi);\n\tctxi = NULL;\n\tgoto out;\n}\n\n \nstatic void init_context(struct ctx_info *ctxi, struct cxlflash_cfg *cfg,\n\t\t\t void *ctx, int ctxid, struct file *file, u32 perms,\n\t\t\t u64 irqs)\n{\n\tstruct afu *afu = cfg->afu;\n\n\tctxi->rht_perms = perms;\n\tctxi->ctrl_map = &afu->afu_map->ctrls[ctxid].ctrl;\n\tctxi->ctxid = ENCODE_CTXID(ctxi, ctxid);\n\tctxi->irqs = irqs;\n\tctxi->pid = task_tgid_nr(current);  \n\tctxi->ctx = ctx;\n\tctxi->cfg = cfg;\n\tctxi->file = file;\n\tctxi->initialized = true;\n\tmutex_init(&ctxi->mutex);\n\tkref_init(&ctxi->kref);\n\tINIT_LIST_HEAD(&ctxi->luns);\n\tINIT_LIST_HEAD(&ctxi->list);  \n}\n\n \nstatic void remove_context(struct kref *kref)\n{\n\tstruct ctx_info *ctxi = container_of(kref, struct ctx_info, kref);\n\tstruct cxlflash_cfg *cfg = ctxi->cfg;\n\tu64 ctxid = DECODE_CTXID(ctxi->ctxid);\n\n\t \n\tWARN_ON(!mutex_is_locked(&ctxi->mutex));\n\tctxi->unavail = true;\n\tmutex_unlock(&ctxi->mutex);\n\tmutex_lock(&cfg->ctx_tbl_list_mutex);\n\tmutex_lock(&ctxi->mutex);\n\n\tif (!list_empty(&ctxi->list))\n\t\tlist_del(&ctxi->list);\n\tcfg->ctx_tbl[ctxid] = NULL;\n\tmutex_unlock(&cfg->ctx_tbl_list_mutex);\n\tmutex_unlock(&ctxi->mutex);\n\n\t \n\tdestroy_context(cfg, ctxi);\n}\n\n \nstatic int _cxlflash_disk_detach(struct scsi_device *sdev,\n\t\t\t\t struct ctx_info *ctxi,\n\t\t\t\t struct dk_cxlflash_detach *detach)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct lun_access *lun_access, *t;\n\tstruct dk_cxlflash_release rel;\n\tbool put_ctx = false;\n\n\tint i;\n\tint rc = 0;\n\tu64 ctxid = DECODE_CTXID(detach->context_id),\n\t    rctxid = detach->context_id;\n\n\tdev_dbg(dev, \"%s: ctxid=%llu\\n\", __func__, ctxid);\n\n\tif (!ctxi) {\n\t\tctxi = get_context(cfg, rctxid, lli, CTX_CTRL_ERR_FALLBACK);\n\t\tif (unlikely(!ctxi)) {\n\t\t\tdev_dbg(dev, \"%s: Bad context ctxid=%llu\\n\",\n\t\t\t\t__func__, ctxid);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tput_ctx = true;\n\t}\n\n\t \n\tif (ctxi->rht_out) {\n\t\tmarshal_det_to_rele(detach, &rel);\n\t\tfor (i = 0; i < MAX_RHT_PER_CONTEXT; i++) {\n\t\t\tif (ctxi->rht_lun[i] == lli) {\n\t\t\t\trel.rsrc_handle = i;\n\t\t\t\t_cxlflash_disk_release(sdev, ctxi, &rel);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ctxi->rht_out == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(lun_access, t, &ctxi->luns, list)\n\t\tif (lun_access->lli == lli) {\n\t\t\tlist_del(&lun_access->list);\n\t\t\tkfree(lun_access);\n\t\t\tlun_access = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t \n\tif (kref_put(&ctxi->kref, remove_context))\n\t\tput_ctx = false;\n\tscsi_device_put(sdev);\nout:\n\tif (put_ctx)\n\t\tput_context(ctxi);\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\nstatic int cxlflash_disk_detach(struct scsi_device *sdev,\n\t\t\t\tstruct dk_cxlflash_detach *detach)\n{\n\treturn _cxlflash_disk_detach(sdev, NULL, detach);\n}\n\n \nstatic int cxlflash_cxl_release(struct inode *inode, struct file *file)\n{\n\tstruct cxlflash_cfg *cfg = container_of(file->f_op, struct cxlflash_cfg,\n\t\t\t\t\t\tcxl_fops);\n\tvoid *ctx = cfg->ops->fops_get_context(file);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct ctx_info *ctxi = NULL;\n\tstruct dk_cxlflash_detach detach = { { 0 }, 0 };\n\tstruct lun_access *lun_access, *t;\n\tenum ctx_ctrl ctrl = CTX_CTRL_ERR_FALLBACK | CTX_CTRL_FILE;\n\tint ctxid;\n\n\tctxid = cfg->ops->process_element(ctx);\n\tif (unlikely(ctxid < 0)) {\n\t\tdev_err(dev, \"%s: Context %p was closed ctxid=%d\\n\",\n\t\t\t__func__, ctx, ctxid);\n\t\tgoto out;\n\t}\n\n\tctxi = get_context(cfg, ctxid, file, ctrl);\n\tif (unlikely(!ctxi)) {\n\t\tctxi = get_context(cfg, ctxid, file, ctrl | CTX_CTRL_CLONE);\n\t\tif (!ctxi) {\n\t\t\tdev_dbg(dev, \"%s: ctxid=%d already free\\n\",\n\t\t\t\t__func__, ctxid);\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tdev_dbg(dev, \"%s: Another process owns ctxid=%d\\n\",\n\t\t\t__func__, ctxid);\n\t\tput_context(ctxi);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"%s: close for ctxid=%d\\n\", __func__, ctxid);\n\n\tdown_read(&cfg->ioctl_rwsem);\n\tdetach.context_id = ctxi->ctxid;\n\tlist_for_each_entry_safe(lun_access, t, &ctxi->luns, list)\n\t\t_cxlflash_disk_detach(lun_access->sdev, ctxi, &detach);\n\tup_read(&cfg->ioctl_rwsem);\nout_release:\n\tcfg->ops->fd_release(inode, file);\nout:\n\tdev_dbg(dev, \"%s: returning\\n\", __func__);\n\treturn 0;\n}\n\n \nstatic void unmap_context(struct ctx_info *ctxi)\n{\n\tunmap_mapping_range(ctxi->file->f_mapping, 0, 0, 1);\n}\n\n \nstatic struct page *get_err_page(struct cxlflash_cfg *cfg)\n{\n\tstruct page *err_page = global.err_page;\n\tstruct device *dev = &cfg->dev->dev;\n\n\tif (unlikely(!err_page)) {\n\t\terr_page = alloc_page(GFP_KERNEL);\n\t\tif (unlikely(!err_page)) {\n\t\t\tdev_err(dev, \"%s: Unable to allocate err_page\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemset(page_address(err_page), -1, PAGE_SIZE);\n\n\t\t \n\t\tmutex_lock(&global.mutex);\n\t\tif (likely(!global.err_page))\n\t\t\tglobal.err_page = err_page;\n\t\telse {\n\t\t\t__free_page(err_page);\n\t\t\terr_page = global.err_page;\n\t\t}\n\t\tmutex_unlock(&global.mutex);\n\t}\n\nout:\n\tdev_dbg(dev, \"%s: returning err_page=%p\\n\", __func__, err_page);\n\treturn err_page;\n}\n\n \nstatic vm_fault_t cxlflash_mmap_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct file *file = vma->vm_file;\n\tstruct cxlflash_cfg *cfg = container_of(file->f_op, struct cxlflash_cfg,\n\t\t\t\t\t\tcxl_fops);\n\tvoid *ctx = cfg->ops->fops_get_context(file);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct ctx_info *ctxi = NULL;\n\tstruct page *err_page = NULL;\n\tenum ctx_ctrl ctrl = CTX_CTRL_ERR_FALLBACK | CTX_CTRL_FILE;\n\tvm_fault_t rc = 0;\n\tint ctxid;\n\n\tctxid = cfg->ops->process_element(ctx);\n\tif (unlikely(ctxid < 0)) {\n\t\tdev_err(dev, \"%s: Context %p was closed ctxid=%d\\n\",\n\t\t\t__func__, ctx, ctxid);\n\t\tgoto err;\n\t}\n\n\tctxi = get_context(cfg, ctxid, file, ctrl);\n\tif (unlikely(!ctxi)) {\n\t\tdev_dbg(dev, \"%s: Bad context ctxid=%d\\n\", __func__, ctxid);\n\t\tgoto err;\n\t}\n\n\tdev_dbg(dev, \"%s: fault for context %d\\n\", __func__, ctxid);\n\n\tif (likely(!ctxi->err_recovery_active)) {\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\t\trc = ctxi->cxl_mmap_vmops->fault(vmf);\n\t} else {\n\t\tdev_dbg(dev, \"%s: err recovery active, use err_page\\n\",\n\t\t\t__func__);\n\n\t\terr_page = get_err_page(cfg);\n\t\tif (unlikely(!err_page)) {\n\t\t\tdev_err(dev, \"%s: Could not get err_page\\n\", __func__);\n\t\t\trc = VM_FAULT_RETRY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tget_page(err_page);\n\t\tvmf->page = err_page;\n\t\tvma->vm_page_prot = pgprot_cached(vma->vm_page_prot);\n\t}\n\nout:\n\tif (likely(ctxi))\n\t\tput_context(ctxi);\n\tdev_dbg(dev, \"%s: returning rc=%x\\n\", __func__, rc);\n\treturn rc;\n\nerr:\n\trc = VM_FAULT_SIGBUS;\n\tgoto out;\n}\n\n \nstatic const struct vm_operations_struct cxlflash_mmap_vmops = {\n\t.fault = cxlflash_mmap_fault,\n};\n\n \nstatic int cxlflash_cxl_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct cxlflash_cfg *cfg = container_of(file->f_op, struct cxlflash_cfg,\n\t\t\t\t\t\tcxl_fops);\n\tvoid *ctx = cfg->ops->fops_get_context(file);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct ctx_info *ctxi = NULL;\n\tenum ctx_ctrl ctrl = CTX_CTRL_ERR_FALLBACK | CTX_CTRL_FILE;\n\tint ctxid;\n\tint rc = 0;\n\n\tctxid = cfg->ops->process_element(ctx);\n\tif (unlikely(ctxid < 0)) {\n\t\tdev_err(dev, \"%s: Context %p was closed ctxid=%d\\n\",\n\t\t\t__func__, ctx, ctxid);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\tctxi = get_context(cfg, ctxid, file, ctrl);\n\tif (unlikely(!ctxi)) {\n\t\tdev_dbg(dev, \"%s: Bad context ctxid=%d\\n\", __func__, ctxid);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"%s: mmap for context %d\\n\", __func__, ctxid);\n\n\trc = cfg->ops->fd_mmap(file, vma);\n\tif (likely(!rc)) {\n\t\t \n\t\tctxi->cxl_mmap_vmops = vma->vm_ops;\n\t\tvma->vm_ops = &cxlflash_mmap_vmops;\n\t}\n\nout:\n\tif (likely(ctxi))\n\t\tput_context(ctxi);\n\treturn rc;\n}\n\nconst struct file_operations cxlflash_cxl_fops = {\n\t.owner = THIS_MODULE,\n\t.mmap = cxlflash_cxl_mmap,\n\t.release = cxlflash_cxl_release,\n};\n\n \nint cxlflash_mark_contexts_error(struct cxlflash_cfg *cfg)\n{\n\tint i, rc = 0;\n\tstruct ctx_info *ctxi = NULL;\n\n\tmutex_lock(&cfg->ctx_tbl_list_mutex);\n\n\tfor (i = 0; i < MAX_CONTEXT; i++) {\n\t\tctxi = cfg->ctx_tbl[i];\n\t\tif (ctxi) {\n\t\t\tmutex_lock(&ctxi->mutex);\n\t\t\tcfg->ctx_tbl[i] = NULL;\n\t\t\tlist_add(&ctxi->list, &cfg->ctx_err_recovery);\n\t\t\tctxi->err_recovery_active = true;\n\t\t\tctxi->ctrl_map = NULL;\n\t\t\tunmap_context(ctxi);\n\t\t\tmutex_unlock(&ctxi->mutex);\n\t\t}\n\t}\n\n\tmutex_unlock(&cfg->ctx_tbl_list_mutex);\n\treturn rc;\n}\n\n \nstatic const struct file_operations null_fops = {\n\t.owner = THIS_MODULE,\n};\n\n \nint check_state(struct cxlflash_cfg *cfg)\n{\n\tstruct device *dev = &cfg->dev->dev;\n\tint rc = 0;\n\nretry:\n\tswitch (cfg->state) {\n\tcase STATE_RESET:\n\t\tdev_dbg(dev, \"%s: Reset state, going to wait...\\n\", __func__);\n\t\tup_read(&cfg->ioctl_rwsem);\n\t\trc = wait_event_interruptible(cfg->reset_waitq,\n\t\t\t\t\t      cfg->state != STATE_RESET);\n\t\tdown_read(&cfg->ioctl_rwsem);\n\t\tif (unlikely(rc))\n\t\t\tbreak;\n\t\tgoto retry;\n\tcase STATE_FAILTERM:\n\t\tdev_dbg(dev, \"%s: Failed/Terminating\\n\", __func__);\n\t\trc = -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int cxlflash_disk_attach(struct scsi_device *sdev,\n\t\t\t\tstruct dk_cxlflash_attach *attach)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct afu *afu = cfg->afu;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tstruct ctx_info *ctxi = NULL;\n\tstruct lun_access *lun_access = NULL;\n\tint rc = 0;\n\tu32 perms;\n\tint ctxid = -1;\n\tu64 irqs = attach->num_interrupts;\n\tu64 flags = 0UL;\n\tu64 rctxid = 0UL;\n\tstruct file *file = NULL;\n\n\tvoid *ctx = NULL;\n\n\tint fd = -1;\n\n\tif (irqs > 4) {\n\t\tdev_dbg(dev, \"%s: Cannot support this many interrupts %llu\\n\",\n\t\t\t__func__, irqs);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (gli->max_lba == 0) {\n\t\tdev_dbg(dev, \"%s: No capacity info for LUN=%016llx\\n\",\n\t\t\t__func__, lli->lun_id[sdev->channel]);\n\t\trc = read_cap16(sdev, lli);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"%s: Invalid device rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\trc = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\t\tdev_dbg(dev, \"%s: LBA = %016llx\\n\", __func__, gli->max_lba);\n\t\tdev_dbg(dev, \"%s: BLK_LEN = %08x\\n\", __func__, gli->blk_len);\n\t}\n\n\tif (attach->hdr.flags & DK_CXLFLASH_ATTACH_REUSE_CONTEXT) {\n\t\trctxid = attach->context_id;\n\t\tctxi = get_context(cfg, rctxid, NULL, 0);\n\t\tif (!ctxi) {\n\t\t\tdev_dbg(dev, \"%s: Bad context rctxid=%016llx\\n\",\n\t\t\t\t__func__, rctxid);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(lun_access, &ctxi->luns, list)\n\t\t\tif (lun_access->lli == lli) {\n\t\t\t\tdev_dbg(dev, \"%s: Already attached\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\n\n\trc = scsi_device_get(sdev);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: Unable to get sdev reference\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tlun_access = kzalloc(sizeof(*lun_access), GFP_KERNEL);\n\tif (unlikely(!lun_access)) {\n\t\tdev_err(dev, \"%s: Unable to allocate lun_access\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tlun_access->lli = lli;\n\tlun_access->sdev = sdev;\n\n\t \n\tif (ctxi) {\n\t\tdev_dbg(dev, \"%s: Reusing context for LUN rctxid=%016llx\\n\",\n\t\t\t__func__, rctxid);\n\t\tkref_get(&ctxi->kref);\n\t\tlist_add(&lun_access->list, &ctxi->luns);\n\t\tgoto out_attach;\n\t}\n\n\tctxi = create_context(cfg);\n\tif (unlikely(!ctxi)) {\n\t\tdev_err(dev, \"%s: Failed to create context ctxid=%d\\n\",\n\t\t\t__func__, ctxid);\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tctx = cfg->ops->dev_context_init(cfg->dev, cfg->afu_cookie);\n\tif (IS_ERR_OR_NULL(ctx)) {\n\t\tdev_err(dev, \"%s: Could not initialize context %p\\n\",\n\t\t\t__func__, ctx);\n\t\trc = -ENODEV;\n\t\tgoto err;\n\t}\n\n\trc = cfg->ops->start_work(ctx, irqs);\n\tif (unlikely(rc)) {\n\t\tdev_dbg(dev, \"%s: Could not start context rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err;\n\t}\n\n\tctxid = cfg->ops->process_element(ctx);\n\tif (unlikely((ctxid >= MAX_CONTEXT) || (ctxid < 0))) {\n\t\tdev_err(dev, \"%s: ctxid=%d invalid\\n\", __func__, ctxid);\n\t\trc = -EPERM;\n\t\tgoto err;\n\t}\n\n\tfile = cfg->ops->get_fd(ctx, &cfg->cxl_fops, &fd);\n\tif (unlikely(fd < 0)) {\n\t\trc = -ENODEV;\n\t\tdev_err(dev, \"%s: Could not get file descriptor\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\t \n\tperms = SISL_RHT_PERM(attach->hdr.flags + 1);\n\n\t \n\tinit_context(ctxi, cfg, ctx, ctxid, file, perms, irqs);\n\n\trc = afu_attach(cfg, ctxi);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: Could not attach AFU rc %d\\n\", __func__, rc);\n\t\tgoto err;\n\t}\n\n\t \n\tlist_add(&lun_access->list, &ctxi->luns);\n\tmutex_lock(&cfg->ctx_tbl_list_mutex);\n\tmutex_lock(&ctxi->mutex);\n\tcfg->ctx_tbl[ctxid] = ctxi;\n\tmutex_unlock(&cfg->ctx_tbl_list_mutex);\n\tfd_install(fd, file);\n\nout_attach:\n\tif (fd != -1)\n\t\tflags |= DK_CXLFLASH_APP_CLOSE_ADAP_FD;\n\tif (afu_is_sq_cmd_mode(afu))\n\t\tflags |= DK_CXLFLASH_CONTEXT_SQ_CMD_MODE;\n\n\tattach->hdr.return_flags = flags;\n\tattach->context_id = ctxi->ctxid;\n\tattach->block_size = gli->blk_len;\n\tattach->mmio_size = sizeof(afu->afu_map->hosts[0].harea);\n\tattach->last_lba = gli->max_lba;\n\tattach->max_xfer = sdev->host->max_sectors * MAX_SECTOR_UNIT;\n\tattach->max_xfer /= gli->blk_len;\n\nout:\n\tattach->adap_fd = fd;\n\n\tif (ctxi)\n\t\tput_context(ctxi);\n\n\tdev_dbg(dev, \"%s: returning ctxid=%d fd=%d bs=%lld rc=%d llba=%lld\\n\",\n\t\t__func__, ctxid, fd, attach->block_size, rc, attach->last_lba);\n\treturn rc;\n\nerr:\n\t \n\tif (!IS_ERR_OR_NULL(ctx)) {\n\t\tcfg->ops->stop_context(ctx);\n\t\tcfg->ops->release_context(ctx);\n\t\tctx = NULL;\n\t}\n\n\t \n\tif (fd > 0) {\n\t\tfile->f_op = &null_fops;\n\t\tfput(file);\n\t\tput_unused_fd(fd);\n\t\tfd = -1;\n\t\tfile = NULL;\n\t}\n\n\t \n\tif (ctxi) {\n\t\tdestroy_context(cfg, ctxi);\n\t\tctxi = NULL;\n\t}\n\n\tkfree(lun_access);\n\tscsi_device_put(sdev);\n\tgoto out;\n}\n\n \nstatic int recover_context(struct cxlflash_cfg *cfg,\n\t\t\t   struct ctx_info *ctxi,\n\t\t\t   int *adap_fd)\n{\n\tstruct device *dev = &cfg->dev->dev;\n\tint rc = 0;\n\tint fd = -1;\n\tint ctxid = -1;\n\tstruct file *file;\n\tvoid *ctx;\n\tstruct afu *afu = cfg->afu;\n\n\tctx = cfg->ops->dev_context_init(cfg->dev, cfg->afu_cookie);\n\tif (IS_ERR_OR_NULL(ctx)) {\n\t\tdev_err(dev, \"%s: Could not initialize context %p\\n\",\n\t\t\t__func__, ctx);\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\trc = cfg->ops->start_work(ctx, ctxi->irqs);\n\tif (unlikely(rc)) {\n\t\tdev_dbg(dev, \"%s: Could not start context rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err1;\n\t}\n\n\tctxid = cfg->ops->process_element(ctx);\n\tif (unlikely((ctxid >= MAX_CONTEXT) || (ctxid < 0))) {\n\t\tdev_err(dev, \"%s: ctxid=%d invalid\\n\", __func__, ctxid);\n\t\trc = -EPERM;\n\t\tgoto err2;\n\t}\n\n\tfile = cfg->ops->get_fd(ctx, &cfg->cxl_fops, &fd);\n\tif (unlikely(fd < 0)) {\n\t\trc = -ENODEV;\n\t\tdev_err(dev, \"%s: Could not get file descriptor\\n\", __func__);\n\t\tgoto err2;\n\t}\n\n\t \n\tctxi->ctrl_map = &afu->afu_map->ctrls[ctxid].ctrl;\n\n\trc = afu_attach(cfg, ctxi);\n\tif (rc) {\n\t\tdev_err(dev, \"%s: Could not attach AFU rc %d\\n\", __func__, rc);\n\t\tgoto err3;\n\t}\n\n\t \n\tctxi->ctxid = ENCODE_CTXID(ctxi, ctxid);\n\tctxi->ctx = ctx;\n\tctxi->file = file;\n\n\t \n\tmutex_unlock(&ctxi->mutex);\n\tmutex_lock(&cfg->ctx_tbl_list_mutex);\n\tmutex_lock(&ctxi->mutex);\n\tlist_del_init(&ctxi->list);\n\tcfg->ctx_tbl[ctxid] = ctxi;\n\tmutex_unlock(&cfg->ctx_tbl_list_mutex);\n\tfd_install(fd, file);\n\t*adap_fd = fd;\nout:\n\tdev_dbg(dev, \"%s: returning ctxid=%d fd=%d rc=%d\\n\",\n\t\t__func__, ctxid, fd, rc);\n\treturn rc;\n\nerr3:\n\tfput(file);\n\tput_unused_fd(fd);\nerr2:\n\tcfg->ops->stop_context(ctx);\nerr1:\n\tcfg->ops->release_context(ctx);\n\tgoto out;\n}\n\n \nstatic int cxlflash_afu_recover(struct scsi_device *sdev,\n\t\t\t\tstruct dk_cxlflash_recover_afu *recover)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct afu *afu = cfg->afu;\n\tstruct ctx_info *ctxi = NULL;\n\tstruct mutex *mutex = &cfg->ctx_recovery_mutex;\n\tstruct hwq *hwq = get_hwq(afu, PRIMARY_HWQ);\n\tu64 flags;\n\tu64 ctxid = DECODE_CTXID(recover->context_id),\n\t    rctxid = recover->context_id;\n\tlong reg;\n\tbool locked = true;\n\tint lretry = 20;  \n\tint new_adap_fd = -1;\n\tint rc = 0;\n\n\tatomic_inc(&cfg->recovery_threads);\n\tup_read(&cfg->ioctl_rwsem);\n\trc = mutex_lock_interruptible(mutex);\n\tdown_read(&cfg->ioctl_rwsem);\n\tif (rc) {\n\t\tlocked = false;\n\t\tgoto out;\n\t}\n\n\trc = check_state(cfg);\n\tif (rc) {\n\t\tdev_err(dev, \"%s: Failed state rc=%d\\n\", __func__, rc);\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"%s: reason=%016llx rctxid=%016llx\\n\",\n\t\t__func__, recover->reason, rctxid);\n\nretry:\n\t \n\tctxi = get_context(cfg, rctxid, lli, CTX_CTRL_ERR_FALLBACK);\n\tif (unlikely(!ctxi)) {\n\t\tdev_dbg(dev, \"%s: Bad context ctxid=%llu\\n\", __func__, ctxid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ctxi->err_recovery_active) {\nretry_recover:\n\t\trc = recover_context(cfg, ctxi, &new_adap_fd);\n\t\tif (unlikely(rc)) {\n\t\t\tdev_err(dev, \"%s: Recovery failed ctxid=%llu rc=%d\\n\",\n\t\t\t\t__func__, ctxid, rc);\n\t\t\tif ((rc == -ENODEV) &&\n\t\t\t    ((atomic_read(&cfg->recovery_threads) > 1) ||\n\t\t\t     (lretry--))) {\n\t\t\t\tdev_dbg(dev, \"%s: Going to try again\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tmutex_unlock(mutex);\n\t\t\t\tmsleep(100);\n\t\t\t\trc = mutex_lock_interruptible(mutex);\n\t\t\t\tif (rc) {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tgoto retry_recover;\n\t\t\t}\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tctxi->err_recovery_active = false;\n\n\t\tflags = DK_CXLFLASH_APP_CLOSE_ADAP_FD |\n\t\t\tDK_CXLFLASH_RECOVER_AFU_CONTEXT_RESET;\n\t\tif (afu_is_sq_cmd_mode(afu))\n\t\t\tflags |= DK_CXLFLASH_CONTEXT_SQ_CMD_MODE;\n\n\t\trecover->hdr.return_flags = flags;\n\t\trecover->context_id = ctxi->ctxid;\n\t\trecover->adap_fd = new_adap_fd;\n\t\trecover->mmio_size = sizeof(afu->afu_map->hosts[0].harea);\n\t\tgoto out;\n\t}\n\n\t \n\treg = readq_be(&hwq->ctrl_map->mbox_r);\n\tif (reg == -1) {\n\t\tdev_dbg(dev, \"%s: MMIO fail, wait for recovery.\\n\", __func__);\n\n\t\t \n\t\tput_context(ctxi);\n\t\tctxi = NULL;\n\t\tssleep(1);\n\t\trc = check_state(cfg);\n\t\tif (unlikely(rc))\n\t\t\tgoto out;\n\t\tgoto retry;\n\t}\n\n\tdev_dbg(dev, \"%s: MMIO working, no recovery required\\n\", __func__);\nout:\n\tif (likely(ctxi))\n\t\tput_context(ctxi);\n\tif (locked)\n\t\tmutex_unlock(mutex);\n\tatomic_dec_if_positive(&cfg->recovery_threads);\n\treturn rc;\n}\n\n \nstatic int process_sense(struct scsi_device *sdev,\n\t\t\t struct dk_cxlflash_verify *verify)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tu64 prev_lba = gli->max_lba;\n\tstruct scsi_sense_hdr sshdr = { 0 };\n\tint rc = 0;\n\n\trc = scsi_normalize_sense((const u8 *)&verify->sense_data,\n\t\t\t\t  DK_CXLFLASH_VERIFY_SENSE_LEN, &sshdr);\n\tif (!rc) {\n\t\tdev_err(dev, \"%s: Failed to normalize sense data\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (sshdr.sense_key) {\n\tcase NO_SENSE:\n\tcase RECOVERED_ERROR:\n\tcase NOT_READY:\n\t\tbreak;\n\tcase UNIT_ATTENTION:\n\t\tswitch (sshdr.asc) {\n\t\tcase 0x29:  \n\t\t\tfallthrough;\n\t\tcase 0x2A:  \n\t\t\trc = read_cap16(sdev, lli);\n\t\t\tif (rc) {\n\t\t\t\trc = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (prev_lba != gli->max_lba)\n\t\t\t\tdev_dbg(dev, \"%s: Capacity changed old=%lld \"\n\t\t\t\t\t\"new=%lld\\n\", __func__, prev_lba,\n\t\t\t\t\tgli->max_lba);\n\t\t\tbreak;\n\t\tcase 0x3F:  \n\t\t\tscsi_scan_host(cfg->host);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trc = -EIO;\n\t\tbreak;\n\t}\nout:\n\tdev_dbg(dev, \"%s: sense_key %x asc %x ascq %x rc %d\\n\", __func__,\n\t\tsshdr.sense_key, sshdr.asc, sshdr.ascq, rc);\n\treturn rc;\n}\n\n \nstatic int cxlflash_disk_verify(struct scsi_device *sdev,\n\t\t\t\tstruct dk_cxlflash_verify *verify)\n{\n\tint rc = 0;\n\tstruct ctx_info *ctxi = NULL;\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tstruct sisl_rht_entry *rhte = NULL;\n\tres_hndl_t rhndl = verify->rsrc_handle;\n\tu64 ctxid = DECODE_CTXID(verify->context_id),\n\t    rctxid = verify->context_id;\n\tu64 last_lba = 0;\n\n\tdev_dbg(dev, \"%s: ctxid=%llu rhndl=%016llx, hint=%016llx, \"\n\t\t\"flags=%016llx\\n\", __func__, ctxid, verify->rsrc_handle,\n\t\tverify->hint, verify->hdr.flags);\n\n\tctxi = get_context(cfg, rctxid, lli, 0);\n\tif (unlikely(!ctxi)) {\n\t\tdev_dbg(dev, \"%s: Bad context ctxid=%llu\\n\", __func__, ctxid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trhte = get_rhte(ctxi, rhndl, lli);\n\tif (unlikely(!rhte)) {\n\t\tdev_dbg(dev, \"%s: Bad resource handle rhndl=%d\\n\",\n\t\t\t__func__, rhndl);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (verify->hint & DK_CXLFLASH_VERIFY_HINT_SENSE) {\n\t\t \n\t\tctxi->unavail = true;\n\t\tmutex_unlock(&ctxi->mutex);\n\t\trc = process_sense(sdev, verify);\n\t\tif (unlikely(rc)) {\n\t\t\tdev_err(dev, \"%s: Failed to validate sense data (%d)\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tmutex_lock(&ctxi->mutex);\n\t\t\tctxi->unavail = false;\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_lock(&ctxi->mutex);\n\t\tctxi->unavail = false;\n\t}\n\n\tswitch (gli->mode) {\n\tcase MODE_PHYSICAL:\n\t\tlast_lba = gli->max_lba;\n\t\tbreak;\n\tcase MODE_VIRTUAL:\n\t\t \n\t\tlast_lba = ((u64)rhte->lxt_cnt * MC_CHUNK_SIZE * gli->blk_len);\n\t\tlast_lba /= CXLFLASH_BLOCK_SIZE;\n\t\tlast_lba--;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unsupported LUN mode!\");\n\t}\n\n\tverify->last_lba = last_lba;\n\nout:\n\tif (likely(ctxi))\n\t\tput_context(ctxi);\n\tdev_dbg(dev, \"%s: returning rc=%d llba=%llx\\n\",\n\t\t__func__, rc, verify->last_lba);\n\treturn rc;\n}\n\n \nstatic char *decode_ioctl(unsigned int cmd)\n{\n\tswitch (cmd) {\n\tcase DK_CXLFLASH_ATTACH:\n\t\treturn __stringify_1(DK_CXLFLASH_ATTACH);\n\tcase DK_CXLFLASH_USER_DIRECT:\n\t\treturn __stringify_1(DK_CXLFLASH_USER_DIRECT);\n\tcase DK_CXLFLASH_USER_VIRTUAL:\n\t\treturn __stringify_1(DK_CXLFLASH_USER_VIRTUAL);\n\tcase DK_CXLFLASH_VLUN_RESIZE:\n\t\treturn __stringify_1(DK_CXLFLASH_VLUN_RESIZE);\n\tcase DK_CXLFLASH_RELEASE:\n\t\treturn __stringify_1(DK_CXLFLASH_RELEASE);\n\tcase DK_CXLFLASH_DETACH:\n\t\treturn __stringify_1(DK_CXLFLASH_DETACH);\n\tcase DK_CXLFLASH_VERIFY:\n\t\treturn __stringify_1(DK_CXLFLASH_VERIFY);\n\tcase DK_CXLFLASH_VLUN_CLONE:\n\t\treturn __stringify_1(DK_CXLFLASH_VLUN_CLONE);\n\tcase DK_CXLFLASH_RECOVER_AFU:\n\t\treturn __stringify_1(DK_CXLFLASH_RECOVER_AFU);\n\tcase DK_CXLFLASH_MANAGE_LUN:\n\t\treturn __stringify_1(DK_CXLFLASH_MANAGE_LUN);\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\n \nstatic int cxlflash_disk_direct_open(struct scsi_device *sdev, void *arg)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct afu *afu = cfg->afu;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tstruct dk_cxlflash_release rel = { { 0 }, 0 };\n\n\tstruct dk_cxlflash_udirect *pphys = (struct dk_cxlflash_udirect *)arg;\n\n\tu64 ctxid = DECODE_CTXID(pphys->context_id),\n\t    rctxid = pphys->context_id;\n\tu64 lun_size = 0;\n\tu64 last_lba = 0;\n\tu64 rsrc_handle = -1;\n\tu32 port = CHAN2PORTMASK(sdev->channel);\n\n\tint rc = 0;\n\n\tstruct ctx_info *ctxi = NULL;\n\tstruct sisl_rht_entry *rhte = NULL;\n\n\tdev_dbg(dev, \"%s: ctxid=%llu ls=%llu\\n\", __func__, ctxid, lun_size);\n\n\trc = cxlflash_lun_attach(gli, MODE_PHYSICAL, false);\n\tif (unlikely(rc)) {\n\t\tdev_dbg(dev, \"%s: Failed attach to LUN (PHYSICAL)\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tctxi = get_context(cfg, rctxid, lli, 0);\n\tif (unlikely(!ctxi)) {\n\t\tdev_dbg(dev, \"%s: Bad context ctxid=%llu\\n\", __func__, ctxid);\n\t\trc = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\trhte = rhte_checkout(ctxi, lli);\n\tif (unlikely(!rhte)) {\n\t\tdev_dbg(dev, \"%s: Too many opens ctxid=%lld\\n\",\n\t\t\t__func__, ctxid);\n\t\trc = -EMFILE;\t \n\t\tgoto err1;\n\t}\n\n\trsrc_handle = (rhte - ctxi->rht_start);\n\n\trht_format1(rhte, lli->lun_id[sdev->channel], ctxi->rht_perms, port);\n\n\tlast_lba = gli->max_lba;\n\tpphys->hdr.return_flags = 0;\n\tpphys->last_lba = last_lba;\n\tpphys->rsrc_handle = rsrc_handle;\n\n\trc = cxlflash_afu_sync(afu, ctxid, rsrc_handle, AFU_LW_SYNC);\n\tif (unlikely(rc)) {\n\t\tdev_dbg(dev, \"%s: AFU sync failed rc=%d\\n\", __func__, rc);\n\t\tgoto err2;\n\t}\n\nout:\n\tif (likely(ctxi))\n\t\tput_context(ctxi);\n\tdev_dbg(dev, \"%s: returning handle=%llu rc=%d llba=%llu\\n\",\n\t\t__func__, rsrc_handle, rc, last_lba);\n\treturn rc;\n\nerr2:\n\tmarshal_udir_to_rele(pphys, &rel);\n\t_cxlflash_disk_release(sdev, ctxi, &rel);\n\tgoto out;\nerr1:\n\tcxlflash_lun_detach(gli);\n\tgoto out;\n}\n\n \nstatic int ioctl_common(struct scsi_device *sdev, unsigned int cmd)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tint rc = 0;\n\n\tif (unlikely(!lli)) {\n\t\tdev_dbg(dev, \"%s: Unknown LUN\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = check_state(cfg);\n\tif (unlikely(rc) && (cfg->state == STATE_FAILTERM)) {\n\t\tswitch (cmd) {\n\t\tcase DK_CXLFLASH_VLUN_RESIZE:\n\t\tcase DK_CXLFLASH_RELEASE:\n\t\tcase DK_CXLFLASH_DETACH:\n\t\t\tdev_dbg(dev, \"%s: Command override rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\n \nint cxlflash_ioctl(struct scsi_device *sdev, unsigned int cmd, void __user *arg)\n{\n\ttypedef int (*sioctl) (struct scsi_device *, void *);\n\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct afu *afu = cfg->afu;\n\tstruct dk_cxlflash_hdr *hdr;\n\tchar buf[sizeof(union cxlflash_ioctls)];\n\tsize_t size = 0;\n\tbool known_ioctl = false;\n\tint idx;\n\tint rc = 0;\n\tstruct Scsi_Host *shost = sdev->host;\n\tsioctl do_ioctl = NULL;\n\n\tstatic const struct {\n\t\tsize_t size;\n\t\tsioctl ioctl;\n\t} ioctl_tbl[] = {\t \n\t{sizeof(struct dk_cxlflash_attach), (sioctl)cxlflash_disk_attach},\n\t{sizeof(struct dk_cxlflash_udirect), cxlflash_disk_direct_open},\n\t{sizeof(struct dk_cxlflash_release), (sioctl)cxlflash_disk_release},\n\t{sizeof(struct dk_cxlflash_detach), (sioctl)cxlflash_disk_detach},\n\t{sizeof(struct dk_cxlflash_verify), (sioctl)cxlflash_disk_verify},\n\t{sizeof(struct dk_cxlflash_recover_afu), (sioctl)cxlflash_afu_recover},\n\t{sizeof(struct dk_cxlflash_manage_lun), (sioctl)cxlflash_manage_lun},\n\t{sizeof(struct dk_cxlflash_uvirtual), cxlflash_disk_virtual_open},\n\t{sizeof(struct dk_cxlflash_resize), (sioctl)cxlflash_vlun_resize},\n\t{sizeof(struct dk_cxlflash_clone), (sioctl)cxlflash_disk_clone},\n\t};\n\n\t \n\tdown_read(&cfg->ioctl_rwsem);\n\n\t \n\tif (afu->internal_lun)\n\t\tswitch (cmd) {\n\t\tcase DK_CXLFLASH_RELEASE:\n\t\tcase DK_CXLFLASH_USER_VIRTUAL:\n\t\tcase DK_CXLFLASH_VLUN_RESIZE:\n\t\tcase DK_CXLFLASH_VLUN_CLONE:\n\t\t\tdev_dbg(dev, \"%s: %s not supported for lun_mode=%d\\n\",\n\t\t\t\t__func__, decode_ioctl(cmd), afu->internal_lun);\n\t\t\trc = -EINVAL;\n\t\t\tgoto cxlflash_ioctl_exit;\n\t\t}\n\n\tswitch (cmd) {\n\tcase DK_CXLFLASH_ATTACH:\n\tcase DK_CXLFLASH_USER_DIRECT:\n\tcase DK_CXLFLASH_RELEASE:\n\tcase DK_CXLFLASH_DETACH:\n\tcase DK_CXLFLASH_VERIFY:\n\tcase DK_CXLFLASH_RECOVER_AFU:\n\tcase DK_CXLFLASH_USER_VIRTUAL:\n\tcase DK_CXLFLASH_VLUN_RESIZE:\n\tcase DK_CXLFLASH_VLUN_CLONE:\n\t\tdev_dbg(dev, \"%s: %s (%08X) on dev(%d/%d/%d/%llu)\\n\",\n\t\t\t__func__, decode_ioctl(cmd), cmd, shost->host_no,\n\t\t\tsdev->channel, sdev->id, sdev->lun);\n\t\trc = ioctl_common(sdev, cmd);\n\t\tif (unlikely(rc))\n\t\t\tgoto cxlflash_ioctl_exit;\n\n\t\tfallthrough;\n\n\tcase DK_CXLFLASH_MANAGE_LUN:\n\t\tknown_ioctl = true;\n\t\tidx = _IOC_NR(cmd) - _IOC_NR(DK_CXLFLASH_ATTACH);\n\t\tsize = ioctl_tbl[idx].size;\n\t\tdo_ioctl = ioctl_tbl[idx].ioctl;\n\n\t\tif (likely(do_ioctl))\n\t\t\tbreak;\n\n\t\tfallthrough;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tgoto cxlflash_ioctl_exit;\n\t}\n\n\tif (unlikely(copy_from_user(&buf, arg, size))) {\n\t\tdev_err(dev, \"%s: copy_from_user() fail size=%lu cmd=%u (%s) arg=%p\\n\",\n\t\t\t__func__, size, cmd, decode_ioctl(cmd), arg);\n\t\trc = -EFAULT;\n\t\tgoto cxlflash_ioctl_exit;\n\t}\n\n\thdr = (struct dk_cxlflash_hdr *)&buf;\n\tif (hdr->version != DK_CXLFLASH_VERSION_0) {\n\t\tdev_dbg(dev, \"%s: Version %u not supported for %s\\n\",\n\t\t\t__func__, hdr->version, decode_ioctl(cmd));\n\t\trc = -EINVAL;\n\t\tgoto cxlflash_ioctl_exit;\n\t}\n\n\tif (hdr->rsvd[0] || hdr->rsvd[1] || hdr->rsvd[2] || hdr->return_flags) {\n\t\tdev_dbg(dev, \"%s: Reserved/rflags populated\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto cxlflash_ioctl_exit;\n\t}\n\n\trc = do_ioctl(sdev, (void *)&buf);\n\tif (likely(!rc))\n\t\tif (unlikely(copy_to_user(arg, &buf, size))) {\n\t\t\tdev_err(dev, \"%s: copy_to_user() fail size=%lu cmd=%u (%s) arg=%p\\n\",\n\t\t\t\t__func__, size, cmd, decode_ioctl(cmd), arg);\n\t\t\trc = -EFAULT;\n\t\t}\n\n\t \n\ncxlflash_ioctl_exit:\n\tup_read(&cfg->ioctl_rwsem);\n\tif (unlikely(rc && known_ioctl))\n\t\tdev_err(dev, \"%s: ioctl %s (%08X) on dev(%d/%d/%d/%llu) \"\n\t\t\t\"returned rc %d\\n\", __func__,\n\t\t\tdecode_ioctl(cmd), cmd, shost->host_no,\n\t\t\tsdev->channel, sdev->id, sdev->lun, rc);\n\telse\n\t\tdev_dbg(dev, \"%s: ioctl %s (%08X) on dev(%d/%d/%d/%llu) \"\n\t\t\t\"returned rc %d\\n\", __func__, decode_ioctl(cmd),\n\t\t\tcmd, shost->host_no, sdev->channel, sdev->id,\n\t\t\tsdev->lun, rc);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}