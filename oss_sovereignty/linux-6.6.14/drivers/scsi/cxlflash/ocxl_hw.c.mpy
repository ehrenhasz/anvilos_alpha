{
  "module_name": "ocxl_hw.c",
  "hash_id": "91572b5a8f6f174de36e99340970a454d6a2eb7c8eab94f35a7dd20751112771",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/cxlflash/ocxl_hw.c",
  "human_readable_source": "\n \n\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/pseudo_fs.h>\n#include <linux/poll.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <asm/xive.h>\n#include <misc/ocxl.h>\n\n#include <uapi/misc/cxl.h>\n\n#include \"backend.h\"\n#include \"ocxl_hw.h\"\n\n \n\n#define OCXLFLASH_FS_MAGIC      0x1697698f\n\nstatic int ocxlflash_fs_cnt;\nstatic struct vfsmount *ocxlflash_vfs_mount;\n\nstatic int ocxlflash_fs_init_fs_context(struct fs_context *fc)\n{\n\treturn init_pseudo(fc, OCXLFLASH_FS_MAGIC) ? 0 : -ENOMEM;\n}\n\nstatic struct file_system_type ocxlflash_fs_type = {\n\t.name\t\t= \"ocxlflash\",\n\t.owner\t\t= THIS_MODULE,\n\t.init_fs_context = ocxlflash_fs_init_fs_context,\n\t.kill_sb\t= kill_anon_super,\n};\n\n \nstatic void ocxlflash_release_mapping(struct ocxlflash_context *ctx)\n{\n\tif (ctx->mapping)\n\t\tsimple_release_fs(&ocxlflash_vfs_mount, &ocxlflash_fs_cnt);\n\tctx->mapping = NULL;\n}\n\n \nstatic struct file *ocxlflash_getfile(struct device *dev, const char *name,\n\t\t\t\t      const struct file_operations *fops,\n\t\t\t\t      void *priv, int flags)\n{\n\tstruct file *file;\n\tstruct inode *inode;\n\tint rc;\n\n\tif (fops->owner && !try_module_get(fops->owner)) {\n\t\tdev_err(dev, \"%s: Owner does not exist\\n\", __func__);\n\t\trc = -ENOENT;\n\t\tgoto err1;\n\t}\n\n\trc = simple_pin_fs(&ocxlflash_fs_type, &ocxlflash_vfs_mount,\n\t\t\t   &ocxlflash_fs_cnt);\n\tif (unlikely(rc < 0)) {\n\t\tdev_err(dev, \"%s: Cannot mount ocxlflash pseudofs rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err2;\n\t}\n\n\tinode = alloc_anon_inode(ocxlflash_vfs_mount->mnt_sb);\n\tif (IS_ERR(inode)) {\n\t\trc = PTR_ERR(inode);\n\t\tdev_err(dev, \"%s: alloc_anon_inode failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err3;\n\t}\n\n\tfile = alloc_file_pseudo(inode, ocxlflash_vfs_mount, name,\n\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tdev_err(dev, \"%s: alloc_file failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err4;\n\t}\n\n\tfile->private_data = priv;\nout:\n\treturn file;\nerr4:\n\tiput(inode);\nerr3:\n\tsimple_release_fs(&ocxlflash_vfs_mount, &ocxlflash_fs_cnt);\nerr2:\n\tmodule_put(fops->owner);\nerr1:\n\tfile = ERR_PTR(rc);\n\tgoto out;\n}\n\n \nstatic void __iomem *ocxlflash_psa_map(void *ctx_cookie)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\tstruct device *dev = ctx->hw_afu->dev;\n\n\tmutex_lock(&ctx->state_mutex);\n\tif (ctx->state != STARTED) {\n\t\tdev_err(dev, \"%s: Context not started, state=%d\\n\", __func__,\n\t\t\tctx->state);\n\t\tmutex_unlock(&ctx->state_mutex);\n\t\treturn NULL;\n\t}\n\tmutex_unlock(&ctx->state_mutex);\n\n\treturn ioremap(ctx->psn_phys, ctx->psn_size);\n}\n\n \nstatic void ocxlflash_psa_unmap(void __iomem *addr)\n{\n\tiounmap(addr);\n}\n\n \nstatic int ocxlflash_process_element(void *ctx_cookie)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\n\treturn ctx->pe;\n}\n\n \nstatic int afu_map_irq(u64 flags, struct ocxlflash_context *ctx, int num,\n\t\t       irq_handler_t handler, void *cookie, char *name)\n{\n\tstruct ocxl_hw_afu *afu = ctx->hw_afu;\n\tstruct device *dev = afu->dev;\n\tstruct ocxlflash_irqs *irq;\n\tstruct xive_irq_data *xd;\n\tu32 virq;\n\tint rc = 0;\n\n\tif (num < 0 || num >= ctx->num_irqs) {\n\t\tdev_err(dev, \"%s: Interrupt %d not allocated\\n\", __func__, num);\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tirq = &ctx->irqs[num];\n\tvirq = irq_create_mapping(NULL, irq->hwirq);\n\tif (unlikely(!virq)) {\n\t\tdev_err(dev, \"%s: irq_create_mapping failed\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = request_irq(virq, handler, 0, name, cookie);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: request_irq failed rc=%d\\n\", __func__, rc);\n\t\tgoto err1;\n\t}\n\n\txd = irq_get_handler_data(virq);\n\tif (unlikely(!xd)) {\n\t\tdev_err(dev, \"%s: Can't get interrupt data\\n\", __func__);\n\t\trc = -ENXIO;\n\t\tgoto err2;\n\t}\n\n\tirq->virq = virq;\n\tirq->vtrig = xd->trig_mmio;\nout:\n\treturn rc;\nerr2:\n\tfree_irq(virq, cookie);\nerr1:\n\tirq_dispose_mapping(virq);\n\tgoto out;\n}\n\n \nstatic int ocxlflash_map_afu_irq(void *ctx_cookie, int num,\n\t\t\t\t irq_handler_t handler, void *cookie,\n\t\t\t\t char *name)\n{\n\treturn afu_map_irq(0, ctx_cookie, num, handler, cookie, name);\n}\n\n \nstatic void afu_unmap_irq(u64 flags, struct ocxlflash_context *ctx, int num,\n\t\t\t  void *cookie)\n{\n\tstruct ocxl_hw_afu *afu = ctx->hw_afu;\n\tstruct device *dev = afu->dev;\n\tstruct ocxlflash_irqs *irq;\n\n\tif (num < 0 || num >= ctx->num_irqs) {\n\t\tdev_err(dev, \"%s: Interrupt %d not allocated\\n\", __func__, num);\n\t\treturn;\n\t}\n\n\tirq = &ctx->irqs[num];\n\n\tif (irq_find_mapping(NULL, irq->hwirq)) {\n\t\tfree_irq(irq->virq, cookie);\n\t\tirq_dispose_mapping(irq->virq);\n\t}\n\n\tmemset(irq, 0, sizeof(*irq));\n}\n\n \nstatic void ocxlflash_unmap_afu_irq(void *ctx_cookie, int num, void *cookie)\n{\n\treturn afu_unmap_irq(0, ctx_cookie, num, cookie);\n}\n\n \nstatic u64 ocxlflash_get_irq_objhndl(void *ctx_cookie, int irq)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\n\tif (irq < 0 || irq >= ctx->num_irqs)\n\t\treturn 0;\n\n\treturn (__force u64)ctx->irqs[irq].vtrig;\n}\n\n \nstatic void ocxlflash_xsl_fault(void *data, u64 addr, u64 dsisr)\n{\n\tstruct ocxlflash_context *ctx = data;\n\n\tspin_lock(&ctx->slock);\n\tctx->fault_addr = addr;\n\tctx->fault_dsisr = dsisr;\n\tctx->pending_fault = true;\n\tspin_unlock(&ctx->slock);\n\n\twake_up_all(&ctx->wq);\n}\n\n \nstatic int start_context(struct ocxlflash_context *ctx)\n{\n\tstruct ocxl_hw_afu *afu = ctx->hw_afu;\n\tstruct ocxl_afu_config *acfg = &afu->acfg;\n\tvoid *link_token = afu->link_token;\n\tstruct pci_dev *pdev = afu->pdev;\n\tstruct device *dev = afu->dev;\n\tbool master = ctx->master;\n\tstruct mm_struct *mm;\n\tint rc = 0;\n\tu32 pid;\n\n\tmutex_lock(&ctx->state_mutex);\n\tif (ctx->state != OPENED) {\n\t\tdev_err(dev, \"%s: Context state invalid, state=%d\\n\",\n\t\t\t__func__, ctx->state);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (master) {\n\t\tctx->psn_size = acfg->global_mmio_size;\n\t\tctx->psn_phys = afu->gmmio_phys;\n\t} else {\n\t\tctx->psn_size = acfg->pp_mmio_stride;\n\t\tctx->psn_phys = afu->ppmmio_phys + (ctx->pe * ctx->psn_size);\n\t}\n\n\t \n\tif (master) {\n\t\tpid = 0;\n\t\tmm = NULL;\n\t} else {\n\t\tpid = current->mm->context.id;\n\t\tmm = current->mm;\n\t}\n\n\trc = ocxl_link_add_pe(link_token, ctx->pe, pid, 0, 0,\n\t\t\t      pci_dev_id(pdev), mm, ocxlflash_xsl_fault,\n\t\t\t      ctx);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxl_link_add_pe failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\tctx->state = STARTED;\nout:\n\tmutex_unlock(&ctx->state_mutex);\n\treturn rc;\n}\n\n \nstatic int ocxlflash_start_context(void *ctx_cookie)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\n\treturn start_context(ctx);\n}\n\n \nstatic int ocxlflash_stop_context(void *ctx_cookie)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\tstruct ocxl_hw_afu *afu = ctx->hw_afu;\n\tstruct ocxl_afu_config *acfg = &afu->acfg;\n\tstruct pci_dev *pdev = afu->pdev;\n\tstruct device *dev = afu->dev;\n\tenum ocxlflash_ctx_state state;\n\tint rc = 0;\n\n\tmutex_lock(&ctx->state_mutex);\n\tstate = ctx->state;\n\tctx->state = CLOSED;\n\tmutex_unlock(&ctx->state_mutex);\n\tif (state != STARTED)\n\t\tgoto out;\n\n\trc = ocxl_config_terminate_pasid(pdev, acfg->dvsec_afu_control_pos,\n\t\t\t\t\t ctx->pe);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxl_config_terminate_pasid failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\t \n\t\tif (rc == -EBUSY)\n\t\t\tgoto out;\n\t}\n\n\trc = ocxl_link_remove_pe(afu->link_token, ctx->pe);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxl_link_remove_pe failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\n \nstatic int ocxlflash_afu_reset(void *ctx_cookie)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\tstruct device *dev = ctx->hw_afu->dev;\n\n\t \n\tdev_err_once(dev, \"%s: afu_reset() fop not supported\\n\", __func__);\n\n\t \n\treturn 0;\n}\n\n \nstatic void ocxlflash_set_master(void *ctx_cookie)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\n\tctx->master = true;\n}\n\n \nstatic void *ocxlflash_get_context(struct pci_dev *pdev, void *afu_cookie)\n{\n\tstruct ocxl_hw_afu *afu = afu_cookie;\n\n\treturn afu->ocxl_ctx;\n}\n\n \nstatic void *ocxlflash_dev_context_init(struct pci_dev *pdev, void *afu_cookie)\n{\n\tstruct ocxl_hw_afu *afu = afu_cookie;\n\tstruct device *dev = afu->dev;\n\tstruct ocxlflash_context *ctx;\n\tint rc;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (unlikely(!ctx)) {\n\t\tdev_err(dev, \"%s: Context allocation failed\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tidr_preload(GFP_KERNEL);\n\trc = idr_alloc(&afu->idr, ctx, 0, afu->max_pasid, GFP_NOWAIT);\n\tidr_preload_end();\n\tif (unlikely(rc < 0)) {\n\t\tdev_err(dev, \"%s: idr_alloc failed rc=%d\\n\", __func__, rc);\n\t\tgoto err2;\n\t}\n\n\tspin_lock_init(&ctx->slock);\n\tinit_waitqueue_head(&ctx->wq);\n\tmutex_init(&ctx->state_mutex);\n\n\tctx->state = OPENED;\n\tctx->pe = rc;\n\tctx->master = false;\n\tctx->mapping = NULL;\n\tctx->hw_afu = afu;\n\tctx->irq_bitmap = 0;\n\tctx->pending_irq = false;\n\tctx->pending_fault = false;\nout:\n\treturn ctx;\nerr2:\n\tkfree(ctx);\nerr1:\n\tctx = ERR_PTR(rc);\n\tgoto out;\n}\n\n \nstatic int ocxlflash_release_context(void *ctx_cookie)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\tstruct device *dev;\n\tint rc = 0;\n\n\tif (!ctx)\n\t\tgoto out;\n\n\tdev = ctx->hw_afu->dev;\n\tmutex_lock(&ctx->state_mutex);\n\tif (ctx->state >= STARTED) {\n\t\tdev_err(dev, \"%s: Context in use, state=%d\\n\", __func__,\n\t\t\tctx->state);\n\t\tmutex_unlock(&ctx->state_mutex);\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tmutex_unlock(&ctx->state_mutex);\n\n\tidr_remove(&ctx->hw_afu->idr, ctx->pe);\n\tocxlflash_release_mapping(ctx);\n\tkfree(ctx);\nout:\n\treturn rc;\n}\n\n \nstatic void ocxlflash_perst_reloads_same_image(void *afu_cookie, bool image)\n{\n\tstruct ocxl_hw_afu *afu = afu_cookie;\n\n\tafu->perst_same_image = image;\n}\n\n \nstatic ssize_t ocxlflash_read_adapter_vpd(struct pci_dev *pdev, void *buf,\n\t\t\t\t\t  size_t count)\n{\n\treturn pci_read_vpd(pdev, 0, count, buf);\n}\n\n \nstatic void free_afu_irqs(struct ocxlflash_context *ctx)\n{\n\tstruct ocxl_hw_afu *afu = ctx->hw_afu;\n\tstruct device *dev = afu->dev;\n\tint i;\n\n\tif (!ctx->irqs) {\n\t\tdev_err(dev, \"%s: Interrupts not allocated\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfor (i = ctx->num_irqs; i >= 0; i--)\n\t\tocxl_link_free_irq(afu->link_token, ctx->irqs[i].hwirq);\n\n\tkfree(ctx->irqs);\n\tctx->irqs = NULL;\n}\n\n \nstatic int alloc_afu_irqs(struct ocxlflash_context *ctx, int num)\n{\n\tstruct ocxl_hw_afu *afu = ctx->hw_afu;\n\tstruct device *dev = afu->dev;\n\tstruct ocxlflash_irqs *irqs;\n\tint rc = 0;\n\tint hwirq;\n\tint i;\n\n\tif (ctx->irqs) {\n\t\tdev_err(dev, \"%s: Interrupts already allocated\\n\", __func__);\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (num > OCXL_MAX_IRQS) {\n\t\tdev_err(dev, \"%s: Too many interrupts num=%d\\n\", __func__, num);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tirqs = kcalloc(num, sizeof(*irqs), GFP_KERNEL);\n\tif (unlikely(!irqs)) {\n\t\tdev_err(dev, \"%s: Context irqs allocation failed\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\trc = ocxl_link_irq_alloc(afu->link_token, &hwirq);\n\t\tif (unlikely(rc)) {\n\t\t\tdev_err(dev, \"%s: ocxl_link_irq_alloc failed rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto err;\n\t\t}\n\n\t\tirqs[i].hwirq = hwirq;\n\t}\n\n\tctx->irqs = irqs;\n\tctx->num_irqs = num;\nout:\n\treturn rc;\nerr:\n\tfor (i = i-1; i >= 0; i--)\n\t\tocxl_link_free_irq(afu->link_token, irqs[i].hwirq);\n\tkfree(irqs);\n\tgoto out;\n}\n\n \nstatic int ocxlflash_allocate_afu_irqs(void *ctx_cookie, int num)\n{\n\treturn alloc_afu_irqs(ctx_cookie, num);\n}\n\n \nstatic void ocxlflash_free_afu_irqs(void *ctx_cookie)\n{\n\tfree_afu_irqs(ctx_cookie);\n}\n\n \nstatic void ocxlflash_unconfig_afu(struct ocxl_hw_afu *afu)\n{\n\tif (afu->gmmio_virt) {\n\t\tiounmap(afu->gmmio_virt);\n\t\tafu->gmmio_virt = NULL;\n\t}\n}\n\n \nstatic void ocxlflash_destroy_afu(void *afu_cookie)\n{\n\tstruct ocxl_hw_afu *afu = afu_cookie;\n\tint pos;\n\n\tif (!afu)\n\t\treturn;\n\n\tocxlflash_release_context(afu->ocxl_ctx);\n\tidr_destroy(&afu->idr);\n\n\t \n\tpos = afu->acfg.dvsec_afu_control_pos;\n\tocxl_config_set_afu_state(afu->pdev, pos, 0);\n\n\tocxlflash_unconfig_afu(afu);\n\tkfree(afu);\n}\n\n \nstatic int ocxlflash_config_fn(struct pci_dev *pdev, struct ocxl_hw_afu *afu)\n{\n\tstruct ocxl_fn_config *fcfg = &afu->fcfg;\n\tstruct device *dev = &pdev->dev;\n\tu16 base, enabled, supported;\n\tint rc = 0;\n\n\t \n\trc = ocxl_config_read_function(pdev, fcfg);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxl_config_read_function failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (fcfg->max_afu_index >= 0) {\n\t\tafu->is_present = true;\n\t\tif (fcfg->max_afu_index != 0)\n\t\t\tdev_warn(dev, \"%s: Unexpected AFU index value %d\\n\",\n\t\t\t\t __func__, fcfg->max_afu_index);\n\t}\n\n\trc = ocxl_config_get_actag_info(pdev, &base, &enabled, &supported);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxl_config_get_actag_info failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\tafu->fn_actag_base = base;\n\tafu->fn_actag_enabled = enabled;\n\n\tocxl_config_set_actag(pdev, fcfg->dvsec_function_pos, base, enabled);\n\tdev_dbg(dev, \"%s: Function acTag range base=%u enabled=%u\\n\",\n\t\t__func__, base, enabled);\n\n\trc = ocxl_link_setup(pdev, 0, &afu->link_token);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxl_link_setup failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\trc = ocxl_config_set_TL(pdev, fcfg->dvsec_tl_pos);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxl_config_set_TL failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err;\n\t}\nout:\n\treturn rc;\nerr:\n\tocxl_link_release(pdev, afu->link_token);\n\tgoto out;\n}\n\n \nstatic void ocxlflash_unconfig_fn(struct pci_dev *pdev, struct ocxl_hw_afu *afu)\n{\n\tocxl_link_release(pdev, afu->link_token);\n}\n\n \nstatic int ocxlflash_map_mmio(struct ocxl_hw_afu *afu)\n{\n\tstruct ocxl_afu_config *acfg = &afu->acfg;\n\tstruct pci_dev *pdev = afu->pdev;\n\tstruct device *dev = afu->dev;\n\tphys_addr_t gmmio, ppmmio;\n\tint rc = 0;\n\n\trc = pci_request_region(pdev, acfg->global_mmio_bar, \"ocxlflash\");\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: pci_request_region for global failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\tgmmio = pci_resource_start(pdev, acfg->global_mmio_bar);\n\tgmmio += acfg->global_mmio_offset;\n\n\trc = pci_request_region(pdev, acfg->pp_mmio_bar, \"ocxlflash\");\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: pci_request_region for pp bar failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err1;\n\t}\n\tppmmio = pci_resource_start(pdev, acfg->pp_mmio_bar);\n\tppmmio += acfg->pp_mmio_offset;\n\n\tafu->gmmio_virt = ioremap(gmmio, acfg->global_mmio_size);\n\tif (unlikely(!afu->gmmio_virt)) {\n\t\tdev_err(dev, \"%s: MMIO mapping failed\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tafu->gmmio_phys = gmmio;\n\tafu->ppmmio_phys = ppmmio;\nout:\n\treturn rc;\nerr2:\n\tpci_release_region(pdev, acfg->pp_mmio_bar);\nerr1:\n\tpci_release_region(pdev, acfg->global_mmio_bar);\n\tgoto out;\n}\n\n \nstatic int ocxlflash_config_afu(struct pci_dev *pdev, struct ocxl_hw_afu *afu)\n{\n\tstruct ocxl_afu_config *acfg = &afu->acfg;\n\tstruct ocxl_fn_config *fcfg = &afu->fcfg;\n\tstruct device *dev = &pdev->dev;\n\tint count;\n\tint base;\n\tint pos;\n\tint rc = 0;\n\n\t \n\tif (!afu->is_present)\n\t\tgoto out;\n\n\t \n\trc = ocxl_config_read_afu(pdev, fcfg, acfg, 0);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxl_config_read_afu failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tbase = afu->fn_actag_base;\n\tcount = min_t(int, acfg->actag_supported, afu->fn_actag_enabled);\n\tpos = acfg->dvsec_afu_control_pos;\n\n\tocxl_config_set_afu_actag(pdev, pos, base, count);\n\tdev_dbg(dev, \"%s: acTag base=%d enabled=%d\\n\", __func__, base, count);\n\tafu->afu_actag_base = base;\n\tafu->afu_actag_enabled = count;\n\tafu->max_pasid = 1 << acfg->pasid_supported_log;\n\n\tocxl_config_set_afu_pasid(pdev, pos, 0, acfg->pasid_supported_log);\n\n\trc = ocxlflash_map_mmio(afu);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: ocxlflash_map_mmio failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\tocxl_config_set_afu_state(pdev, acfg->dvsec_afu_control_pos, 1);\nout:\n\treturn rc;\n}\n\n \nstatic void *ocxlflash_create_afu(struct pci_dev *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ocxlflash_context *ctx;\n\tstruct ocxl_hw_afu *afu;\n\tint rc;\n\n\tafu = kzalloc(sizeof(*afu), GFP_KERNEL);\n\tif (unlikely(!afu)) {\n\t\tdev_err(dev, \"%s: HW AFU allocation failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tafu->pdev = pdev;\n\tafu->dev = dev;\n\tidr_init(&afu->idr);\n\n\trc = ocxlflash_config_fn(pdev, afu);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: Function configuration failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err1;\n\t}\n\n\trc = ocxlflash_config_afu(pdev, afu);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: AFU configuration failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err2;\n\t}\n\n\tctx = ocxlflash_dev_context_init(pdev, afu);\n\tif (IS_ERR(ctx)) {\n\t\trc = PTR_ERR(ctx);\n\t\tdev_err(dev, \"%s: ocxlflash_dev_context_init failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err3;\n\t}\n\n\tafu->ocxl_ctx = ctx;\nout:\n\treturn afu;\nerr3:\n\tocxlflash_unconfig_afu(afu);\nerr2:\n\tocxlflash_unconfig_fn(pdev, afu);\nerr1:\n\tidr_destroy(&afu->idr);\n\tkfree(afu);\n\tafu = NULL;\n\tgoto out;\n}\n\n \nstatic inline bool ctx_event_pending(struct ocxlflash_context *ctx)\n{\n\tif (ctx->pending_irq || ctx->pending_fault)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic unsigned int afu_poll(struct file *file, struct poll_table_struct *poll)\n{\n\tstruct ocxlflash_context *ctx = file->private_data;\n\tstruct device *dev = ctx->hw_afu->dev;\n\tulong lock_flags;\n\tint mask = 0;\n\n\tpoll_wait(file, &ctx->wq, poll);\n\n\tspin_lock_irqsave(&ctx->slock, lock_flags);\n\tif (ctx_event_pending(ctx))\n\t\tmask |= POLLIN | POLLRDNORM;\n\telse if (ctx->state == CLOSED)\n\t\tmask |= POLLERR;\n\tspin_unlock_irqrestore(&ctx->slock, lock_flags);\n\n\tdev_dbg(dev, \"%s: Poll wait completed for pe %i mask %i\\n\",\n\t\t__func__, ctx->pe, mask);\n\n\treturn mask;\n}\n\n \nstatic ssize_t afu_read(struct file *file, char __user *buf, size_t count,\n\t\t\tloff_t *off)\n{\n\tstruct ocxlflash_context *ctx = file->private_data;\n\tstruct device *dev = ctx->hw_afu->dev;\n\tstruct cxl_event event;\n\tulong lock_flags;\n\tssize_t esize;\n\tssize_t rc;\n\tint bit;\n\tDEFINE_WAIT(event_wait);\n\n\tif (*off != 0) {\n\t\tdev_err(dev, \"%s: Non-zero offset not supported, off=%lld\\n\",\n\t\t\t__func__, *off);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&ctx->slock, lock_flags);\n\n\tfor (;;) {\n\t\tprepare_to_wait(&ctx->wq, &event_wait, TASK_INTERRUPTIBLE);\n\n\t\tif (ctx_event_pending(ctx) || (ctx->state == CLOSED))\n\t\t\tbreak;\n\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tdev_err(dev, \"%s: File cannot be blocked on I/O\\n\",\n\t\t\t\t__func__);\n\t\t\trc = -EAGAIN;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tdev_err(dev, \"%s: Signal pending on the process\\n\",\n\t\t\t\t__func__);\n\t\t\trc = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&ctx->slock, lock_flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(&ctx->slock, lock_flags);\n\t}\n\n\tfinish_wait(&ctx->wq, &event_wait);\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.header.process_element = ctx->pe;\n\tevent.header.size = sizeof(struct cxl_event_header);\n\tif (ctx->pending_irq) {\n\t\tesize = sizeof(struct cxl_event_afu_interrupt);\n\t\tevent.header.size += esize;\n\t\tevent.header.type = CXL_EVENT_AFU_INTERRUPT;\n\n\t\tbit = find_first_bit(&ctx->irq_bitmap, ctx->num_irqs);\n\t\tclear_bit(bit, &ctx->irq_bitmap);\n\t\tevent.irq.irq = bit + 1;\n\t\tif (bitmap_empty(&ctx->irq_bitmap, ctx->num_irqs))\n\t\t\tctx->pending_irq = false;\n\t} else if (ctx->pending_fault) {\n\t\tevent.header.size += sizeof(struct cxl_event_data_storage);\n\t\tevent.header.type = CXL_EVENT_DATA_STORAGE;\n\t\tevent.fault.addr = ctx->fault_addr;\n\t\tevent.fault.dsisr = ctx->fault_dsisr;\n\t\tctx->pending_fault = false;\n\t}\n\n\tspin_unlock_irqrestore(&ctx->slock, lock_flags);\n\n\tif (copy_to_user(buf, &event, event.header.size)) {\n\t\tdev_err(dev, \"%s: copy_to_user failed\\n\", __func__);\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\trc = event.header.size;\nout:\n\treturn rc;\nerr:\n\tfinish_wait(&ctx->wq, &event_wait);\n\tspin_unlock_irqrestore(&ctx->slock, lock_flags);\n\tgoto out;\n}\n\n \nstatic int afu_release(struct inode *inode, struct file *file)\n{\n\tstruct ocxlflash_context *ctx = file->private_data;\n\tint i;\n\n\t \n\tfor (i = ctx->num_irqs; i >= 0; i--)\n\t\tafu_unmap_irq(0, ctx, i, ctx);\n\tfree_afu_irqs(ctx);\n\n\treturn ocxlflash_release_context(ctx);\n}\n\n \nstatic vm_fault_t ocxlflash_mmap_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct ocxlflash_context *ctx = vma->vm_file->private_data;\n\tstruct device *dev = ctx->hw_afu->dev;\n\tu64 mmio_area, offset;\n\n\toffset = vmf->pgoff << PAGE_SHIFT;\n\tif (offset >= ctx->psn_size)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tmutex_lock(&ctx->state_mutex);\n\tif (ctx->state != STARTED) {\n\t\tdev_err(dev, \"%s: Context not started, state=%d\\n\",\n\t\t\t__func__, ctx->state);\n\t\tmutex_unlock(&ctx->state_mutex);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\tmutex_unlock(&ctx->state_mutex);\n\n\tmmio_area = ctx->psn_phys;\n\tmmio_area += offset;\n\n\treturn vmf_insert_pfn(vma, vmf->address, mmio_area >> PAGE_SHIFT);\n}\n\nstatic const struct vm_operations_struct ocxlflash_vmops = {\n\t.fault = ocxlflash_mmap_fault,\n};\n\n \nstatic int afu_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct ocxlflash_context *ctx = file->private_data;\n\n\tif ((vma_pages(vma) + vma->vm_pgoff) >\n\t    (ctx->psn_size >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\n\tvm_flags_set(vma, VM_IO | VM_PFNMAP);\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tvma->vm_ops = &ocxlflash_vmops;\n\treturn 0;\n}\n\nstatic const struct file_operations ocxl_afu_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.poll\t\t= afu_poll,\n\t.read\t\t= afu_read,\n\t.release\t= afu_release,\n\t.mmap\t\t= afu_mmap,\n};\n\n#define PATCH_FOPS(NAME)\t\t\t\t\t\t\\\n\tdo { if (!fops->NAME) fops->NAME = ocxl_afu_fops.NAME; } while (0)\n\n \nstatic struct file *ocxlflash_get_fd(void *ctx_cookie,\n\t\t\t\t     struct file_operations *fops, int *fd)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\tstruct device *dev = ctx->hw_afu->dev;\n\tstruct file *file;\n\tint flags, fdtmp;\n\tint rc = 0;\n\tchar *name = NULL;\n\n\t \n\tif (ctx->mapping) {\n\t\tdev_err(dev, \"%s: Context is already mapped to an fd\\n\",\n\t\t\t__func__);\n\t\trc = -EEXIST;\n\t\tgoto err1;\n\t}\n\n\tflags = O_RDWR | O_CLOEXEC;\n\n\t \n\trc = get_unused_fd_flags(flags);\n\tif (unlikely(rc < 0)) {\n\t\tdev_err(dev, \"%s: get_unused_fd_flags failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err1;\n\t}\n\tfdtmp = rc;\n\n\t \n\tif (fops) {\n\t\tPATCH_FOPS(poll);\n\t\tPATCH_FOPS(read);\n\t\tPATCH_FOPS(release);\n\t\tPATCH_FOPS(mmap);\n\t} else  \n\t\tfops = (struct file_operations *)&ocxl_afu_fops;\n\n\tname = kasprintf(GFP_KERNEL, \"ocxlflash:%d\", ctx->pe);\n\tfile = ocxlflash_getfile(dev, name, fops, ctx, flags);\n\tkfree(name);\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tdev_err(dev, \"%s: ocxlflash_getfile failed rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto err2;\n\t}\n\n\tctx->mapping = file->f_mapping;\n\t*fd = fdtmp;\nout:\n\treturn file;\nerr2:\n\tput_unused_fd(fdtmp);\nerr1:\n\tfile = ERR_PTR(rc);\n\tgoto out;\n}\n\n \nstatic void *ocxlflash_fops_get_context(struct file *file)\n{\n\treturn file->private_data;\n}\n\n \nstatic irqreturn_t ocxlflash_afu_irq(int irq, void *data)\n{\n\tstruct ocxlflash_context *ctx = data;\n\tstruct device *dev = ctx->hw_afu->dev;\n\tint i;\n\n\tdev_dbg(dev, \"%s: Interrupt raised for pe %i virq %i\\n\",\n\t\t__func__, ctx->pe, irq);\n\n\tfor (i = 0; i < ctx->num_irqs; i++) {\n\t\tif (ctx->irqs[i].virq == irq)\n\t\t\tbreak;\n\t}\n\tif (unlikely(i >= ctx->num_irqs)) {\n\t\tdev_err(dev, \"%s: Received AFU IRQ out of range\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&ctx->slock);\n\tset_bit(i - 1, &ctx->irq_bitmap);\n\tctx->pending_irq = true;\n\tspin_unlock(&ctx->slock);\n\n\twake_up_all(&ctx->wq);\nout:\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ocxlflash_start_work(void *ctx_cookie, u64 num_irqs)\n{\n\tstruct ocxlflash_context *ctx = ctx_cookie;\n\tstruct ocxl_hw_afu *afu = ctx->hw_afu;\n\tstruct device *dev = afu->dev;\n\tchar *name;\n\tint rc = 0;\n\tint i;\n\n\trc = alloc_afu_irqs(ctx, num_irqs);\n\tif (unlikely(rc < 0)) {\n\t\tdev_err(dev, \"%s: alloc_afu_irqs failed rc=%d\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tname = kasprintf(GFP_KERNEL, \"ocxlflash-%s-pe%i-%i\",\n\t\t\t\t dev_name(dev), ctx->pe, i);\n\t\trc = afu_map_irq(0, ctx, i, ocxlflash_afu_irq, ctx, name);\n\t\tkfree(name);\n\t\tif (unlikely(rc < 0)) {\n\t\t\tdev_err(dev, \"%s: afu_map_irq failed rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\trc = start_context(ctx);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: start_context failed rc=%d\\n\", __func__, rc);\n\t\tgoto err;\n\t}\nout:\n\treturn rc;\nerr:\n\tfor (i = i-1; i >= 0; i--)\n\t\tafu_unmap_irq(0, ctx, i, ctx);\n\tfree_afu_irqs(ctx);\n\tgoto out;\n};\n\n \nstatic int ocxlflash_fd_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn afu_mmap(file, vma);\n}\n\n \nstatic int ocxlflash_fd_release(struct inode *inode, struct file *file)\n{\n\treturn afu_release(inode, file);\n}\n\n \nconst struct cxlflash_backend_ops cxlflash_ocxl_ops = {\n\t.module\t\t\t= THIS_MODULE,\n\t.psa_map\t\t= ocxlflash_psa_map,\n\t.psa_unmap\t\t= ocxlflash_psa_unmap,\n\t.process_element\t= ocxlflash_process_element,\n\t.map_afu_irq\t\t= ocxlflash_map_afu_irq,\n\t.unmap_afu_irq\t\t= ocxlflash_unmap_afu_irq,\n\t.get_irq_objhndl\t= ocxlflash_get_irq_objhndl,\n\t.start_context\t\t= ocxlflash_start_context,\n\t.stop_context\t\t= ocxlflash_stop_context,\n\t.afu_reset\t\t= ocxlflash_afu_reset,\n\t.set_master\t\t= ocxlflash_set_master,\n\t.get_context\t\t= ocxlflash_get_context,\n\t.dev_context_init\t= ocxlflash_dev_context_init,\n\t.release_context\t= ocxlflash_release_context,\n\t.perst_reloads_same_image = ocxlflash_perst_reloads_same_image,\n\t.read_adapter_vpd\t= ocxlflash_read_adapter_vpd,\n\t.allocate_afu_irqs\t= ocxlflash_allocate_afu_irqs,\n\t.free_afu_irqs\t\t= ocxlflash_free_afu_irqs,\n\t.create_afu\t\t= ocxlflash_create_afu,\n\t.destroy_afu\t\t= ocxlflash_destroy_afu,\n\t.get_fd\t\t\t= ocxlflash_get_fd,\n\t.fops_get_context\t= ocxlflash_fops_get_context,\n\t.start_work\t\t= ocxlflash_start_work,\n\t.fd_mmap\t\t= ocxlflash_fd_mmap,\n\t.fd_release\t\t= ocxlflash_fd_release,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}