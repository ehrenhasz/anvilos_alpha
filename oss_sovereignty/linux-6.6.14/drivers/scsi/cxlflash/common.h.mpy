{
  "module_name": "common.h",
  "hash_id": "a317a466ec7f2218cb012089296f153805c64b06c41463d95e89b76b7aad87f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/cxlflash/common.h",
  "human_readable_source": " \n \n\n#ifndef _CXLFLASH_COMMON_H\n#define _CXLFLASH_COMMON_H\n\n#include <linux/async.h>\n#include <linux/cdev.h>\n#include <linux/irq_poll.h>\n#include <linux/list.h>\n#include <linux/rwsem.h>\n#include <linux/types.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n\n#include \"backend.h\"\n\nextern const struct file_operations cxlflash_cxl_fops;\n\n#define MAX_CONTEXT\tCXLFLASH_MAX_CONTEXT\t \n#define MAX_FC_PORTS\tCXLFLASH_MAX_FC_PORTS\t \n#define LEGACY_FC_PORTS\t2\t\t\t \n\n#define CHAN2PORTBANK(_x)\t((_x) >> ilog2(CXLFLASH_NUM_FC_PORTS_PER_BANK))\n#define CHAN2BANKPORT(_x)\t((_x) & (CXLFLASH_NUM_FC_PORTS_PER_BANK - 1))\n\n#define CHAN2PORTMASK(_x)\t(1 << (_x))\t \n#define PORTMASK2CHAN(_x)\t(ilog2((_x)))\t \n#define PORTNUM2CHAN(_x)\t((_x) - 1)\t \n\n#define CXLFLASH_BLOCK_SIZE\t4096\t\t \n#define CXLFLASH_MAX_XFER_SIZE\t16777216\t \n#define CXLFLASH_MAX_SECTORS\t(CXLFLASH_MAX_XFER_SIZE/512)\t \n\n#define MAX_RHT_PER_CONTEXT (PAGE_SIZE / sizeof(struct sisl_rht_entry))\n\n \n#define MC_RETRY_CNT\t5\t \n\n \n#define CXLFLASH_MAX_CMDS               256\n#define CXLFLASH_MAX_CMDS_PER_LUN       CXLFLASH_MAX_CMDS\n\n \n#define NUM_RRQ_ENTRY                   CXLFLASH_MAX_CMDS\n\n \n#define NUM_SQ_ENTRY\t\t\tCXLFLASH_MAX_CMDS\n\n \n#define CXLFLASH_DEF_HWQS\t\t1\n#define CXLFLASH_MAX_HWQS\t\t8\n#define PRIMARY_HWQ\t\t\t0\n\n\nstatic inline void check_sizes(void)\n{\n\tBUILD_BUG_ON_NOT_POWER_OF_2(CXLFLASH_NUM_FC_PORTS_PER_BANK);\n\tBUILD_BUG_ON_NOT_POWER_OF_2(CXLFLASH_MAX_CMDS);\n}\n\n \n#define CMD_BUFSIZE     SIZE_4K\n\nenum cxlflash_lr_state {\n\tLINK_RESET_INVALID,\n\tLINK_RESET_REQUIRED,\n\tLINK_RESET_COMPLETE\n};\n\nenum cxlflash_init_state {\n\tINIT_STATE_NONE,\n\tINIT_STATE_PCI,\n\tINIT_STATE_AFU,\n\tINIT_STATE_SCSI,\n\tINIT_STATE_CDEV\n};\n\nenum cxlflash_state {\n\tSTATE_PROBING,\t \n\tSTATE_PROBED,\t \n\tSTATE_NORMAL,\t \n\tSTATE_RESET,\t \n\tSTATE_FAILTERM\t \n};\n\nenum cxlflash_hwq_mode {\n\tHWQ_MODE_RR,\t \n\tHWQ_MODE_TAG,\t \n\tHWQ_MODE_CPU,\t \n\tMAX_HWQ_MODE\n};\n\n \n\nstruct cxlflash_cfg {\n\tstruct afu *afu;\n\n\tconst struct cxlflash_backend_ops *ops;\n\tstruct pci_dev *dev;\n\tstruct pci_device_id *dev_id;\n\tstruct Scsi_Host *host;\n\tint num_fc_ports;\n\tstruct cdev cdev;\n\tstruct device *chardev;\n\n\tulong cxlflash_regs_pci;\n\n\tstruct work_struct work_q;\n\tenum cxlflash_init_state init_state;\n\tenum cxlflash_lr_state lr_state;\n\tint lr_port;\n\tatomic_t scan_host_needed;\n\n\tvoid *afu_cookie;\n\n\tatomic_t recovery_threads;\n\tstruct mutex ctx_recovery_mutex;\n\tstruct mutex ctx_tbl_list_mutex;\n\tstruct rw_semaphore ioctl_rwsem;\n\tstruct ctx_info *ctx_tbl[MAX_CONTEXT];\n\tstruct list_head ctx_err_recovery;  \n\tstruct file_operations cxl_fops;\n\n\t \n\tint last_lun_index[MAX_FC_PORTS];\n\tint promote_lun_index;\n\tstruct list_head lluns;  \n\n\twait_queue_head_t tmf_waitq;\n\tspinlock_t tmf_slock;\n\tbool tmf_active;\n\tbool ws_unmap;\t\t \n\twait_queue_head_t reset_waitq;\n\tenum cxlflash_state state;\n\tasync_cookie_t async_reset_cookie;\n};\n\nstruct afu_cmd {\n\tstruct sisl_ioarcb rcb;\t \n\tstruct sisl_ioasa sa;\t \n\tstruct afu *parent;\n\tstruct scsi_cmnd *scp;\n\tstruct completion cevent;\n\tstruct list_head queue;\n\tu32 hwq_index;\n\n\tu8 cmd_tmf:1,\n\t   cmd_aborted:1;\n\n\tstruct list_head list;\t \n\n\t \n} __aligned(cache_line_size());\n\nstatic inline struct afu_cmd *sc_to_afuc(struct scsi_cmnd *sc)\n{\n\treturn PTR_ALIGN(scsi_cmd_priv(sc), __alignof__(struct afu_cmd));\n}\n\nstatic inline struct afu_cmd *sc_to_afuci(struct scsi_cmnd *sc)\n{\n\tstruct afu_cmd *afuc = sc_to_afuc(sc);\n\n\tINIT_LIST_HEAD(&afuc->queue);\n\treturn afuc;\n}\n\nstatic inline struct afu_cmd *sc_to_afucz(struct scsi_cmnd *sc)\n{\n\tstruct afu_cmd *afuc = sc_to_afuc(sc);\n\n\tmemset(afuc, 0, sizeof(*afuc));\n\treturn sc_to_afuci(sc);\n}\n\nstruct hwq {\n\t \n\tstruct sisl_ioarcb sq[NUM_SQ_ENTRY];\t\t \n\tu64 rrq_entry[NUM_RRQ_ENTRY];\t\t\t \n\n\t \n\tstruct afu *afu;\n\tvoid *ctx_cookie;\n\tstruct sisl_host_map __iomem *host_map;\t\t \n\tstruct sisl_ctrl_map __iomem *ctrl_map;\t\t \n\tctx_hndl_t ctx_hndl;\t \n\tu32 index;\t\t \n\tint num_irqs;\t\t \n\tstruct list_head pending_cmds;\t \n\n\tatomic_t hsq_credits;\n\tspinlock_t hsq_slock;\t \n\tstruct sisl_ioarcb *hsq_start;\n\tstruct sisl_ioarcb *hsq_end;\n\tstruct sisl_ioarcb *hsq_curr;\n\tspinlock_t hrrq_slock;\n\tu64 *hrrq_start;\n\tu64 *hrrq_end;\n\tu64 *hrrq_curr;\n\tbool toggle;\n\tbool hrrq_online;\n\n\ts64 room;\n\n\tstruct irq_poll irqpoll;\n} __aligned(cache_line_size());\n\nstruct afu {\n\tstruct hwq hwqs[CXLFLASH_MAX_HWQS];\n\tint (*send_cmd)(struct afu *afu, struct afu_cmd *cmd);\n\tint (*context_reset)(struct hwq *hwq);\n\n\t \n\tstruct cxlflash_afu_map __iomem *afu_map;\t \n\n\tatomic_t cmds_active;\t \n\tstruct mutex sync_active;\t \n\tu64 hb;\n\tu32 internal_lun;\t \n\n\tu32 num_hwqs;\t\t \n\tu32 desired_hwqs;\t \n\tenum cxlflash_hwq_mode hwq_mode;  \n\tu32 hwq_rr_count;\t \n\n\tchar version[16];\n\tu64 interface_version;\n\n\tu32 irqpoll_weight;\n\tstruct cxlflash_cfg *parent;  \n};\n\nstatic inline struct hwq *get_hwq(struct afu *afu, u32 index)\n{\n\tWARN_ON(index >= CXLFLASH_MAX_HWQS);\n\n\treturn &afu->hwqs[index];\n}\n\nstatic inline bool afu_is_irqpoll_enabled(struct afu *afu)\n{\n\treturn !!afu->irqpoll_weight;\n}\n\nstatic inline bool afu_has_cap(struct afu *afu, u64 cap)\n{\n\tu64 afu_cap = afu->interface_version >> SISL_INTVER_CAP_SHIFT;\n\n\treturn afu_cap & cap;\n}\n\nstatic inline bool afu_is_ocxl_lisn(struct afu *afu)\n{\n\treturn afu_has_cap(afu, SISL_INTVER_CAP_OCXL_LISN);\n}\n\nstatic inline bool afu_is_afu_debug(struct afu *afu)\n{\n\treturn afu_has_cap(afu, SISL_INTVER_CAP_AFU_DEBUG);\n}\n\nstatic inline bool afu_is_lun_provision(struct afu *afu)\n{\n\treturn afu_has_cap(afu, SISL_INTVER_CAP_LUN_PROVISION);\n}\n\nstatic inline bool afu_is_sq_cmd_mode(struct afu *afu)\n{\n\treturn afu_has_cap(afu, SISL_INTVER_CAP_SQ_CMD_MODE);\n}\n\nstatic inline bool afu_is_ioarrin_cmd_mode(struct afu *afu)\n{\n\treturn afu_has_cap(afu, SISL_INTVER_CAP_IOARRIN_CMD_MODE);\n}\n\nstatic inline u64 lun_to_lunid(u64 lun)\n{\n\t__be64 lun_id;\n\n\tint_to_scsilun(lun, (struct scsi_lun *)&lun_id);\n\treturn be64_to_cpu(lun_id);\n}\n\nstatic inline struct fc_port_bank __iomem *get_fc_port_bank(\n\t\t\t\t\t    struct cxlflash_cfg *cfg, int i)\n{\n\tstruct afu *afu = cfg->afu;\n\n\treturn &afu->afu_map->global.bank[CHAN2PORTBANK(i)];\n}\n\nstatic inline __be64 __iomem *get_fc_port_regs(struct cxlflash_cfg *cfg, int i)\n{\n\tstruct fc_port_bank __iomem *fcpb = get_fc_port_bank(cfg, i);\n\n\treturn &fcpb->fc_port_regs[CHAN2BANKPORT(i)][0];\n}\n\nstatic inline __be64 __iomem *get_fc_port_luns(struct cxlflash_cfg *cfg, int i)\n{\n\tstruct fc_port_bank __iomem *fcpb = get_fc_port_bank(cfg, i);\n\n\treturn &fcpb->fc_port_luns[CHAN2BANKPORT(i)][0];\n}\n\nint cxlflash_afu_sync(struct afu *afu, ctx_hndl_t c, res_hndl_t r, u8 mode);\nvoid cxlflash_list_init(void);\nvoid cxlflash_term_global_luns(void);\nvoid cxlflash_free_errpage(void);\nint cxlflash_ioctl(struct scsi_device *sdev, unsigned int cmd,\n\t\t   void __user *arg);\nvoid cxlflash_stop_term_user_contexts(struct cxlflash_cfg *cfg);\nint cxlflash_mark_contexts_error(struct cxlflash_cfg *cfg);\nvoid cxlflash_term_local_luns(struct cxlflash_cfg *cfg);\nvoid cxlflash_restore_luntable(struct cxlflash_cfg *cfg);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}