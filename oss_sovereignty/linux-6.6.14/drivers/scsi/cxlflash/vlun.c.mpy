{
  "module_name": "vlun.c",
  "hash_id": "1fe2b95b045efb27610b3fce2a67eb80f3ddba0c1d2f9e7d3b8118bc3ac30303",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/cxlflash/vlun.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/syscalls.h>\n#include <asm/unaligned.h>\n#include <asm/bitsperlong.h>\n\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n#include <uapi/scsi/cxlflash_ioctl.h>\n\n#include \"sislite.h\"\n#include \"common.h\"\n#include \"vlun.h\"\n#include \"superpipe.h\"\n\n \nstatic void marshal_virt_to_resize(struct dk_cxlflash_uvirtual *virt,\n\t\t\t\t   struct dk_cxlflash_resize *resize)\n{\n\tresize->hdr = virt->hdr;\n\tresize->context_id = virt->context_id;\n\tresize->rsrc_handle = virt->rsrc_handle;\n\tresize->req_size = virt->lun_size;\n\tresize->last_lba = virt->last_lba;\n}\n\n \nstatic void marshal_clone_to_rele(struct dk_cxlflash_clone *clone,\n\t\t\t\t  struct dk_cxlflash_release *release)\n{\n\trelease->hdr = clone->hdr;\n\trelease->context_id = clone->context_id_dst;\n}\n\n \nstatic int ba_init(struct ba_lun *ba_lun)\n{\n\tstruct ba_lun_info *bali = NULL;\n\tint lun_size_au = 0, i = 0;\n\tint last_word_underflow = 0;\n\tu64 *lam;\n\n\tpr_debug(\"%s: Initializing LUN: lun_id=%016llx \"\n\t\t \"ba_lun->lsize=%lx ba_lun->au_size=%lX\\n\",\n\t\t__func__, ba_lun->lun_id, ba_lun->lsize, ba_lun->au_size);\n\n\t \n\tlun_size_au = ba_lun->lsize / ba_lun->au_size;\n\tif (lun_size_au == 0) {\n\t\tpr_debug(\"%s: Requested LUN size of 0!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbali = kzalloc(sizeof(struct ba_lun_info), GFP_KERNEL);\n\tif (unlikely(!bali)) {\n\t\tpr_err(\"%s: Failed to allocate lun_info lun_id=%016llx\\n\",\n\t\t       __func__, ba_lun->lun_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tbali->total_aus = lun_size_au;\n\tbali->lun_bmap_size = lun_size_au / BITS_PER_LONG;\n\n\tif (lun_size_au % BITS_PER_LONG)\n\t\tbali->lun_bmap_size++;\n\n\t \n\tbali->lun_alloc_map = kzalloc((bali->lun_bmap_size * sizeof(u64)),\n\t\t\t\t      GFP_KERNEL);\n\tif (unlikely(!bali->lun_alloc_map)) {\n\t\tpr_err(\"%s: Failed to allocate lun allocation map: \"\n\t\t       \"lun_id=%016llx\\n\", __func__, ba_lun->lun_id);\n\t\tkfree(bali);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbali->free_aun_cnt = lun_size_au;\n\n\tfor (i = 0; i < bali->lun_bmap_size; i++)\n\t\tbali->lun_alloc_map[i] = 0xFFFFFFFFFFFFFFFFULL;\n\n\t \n\tlast_word_underflow = (bali->lun_bmap_size * BITS_PER_LONG);\n\tlast_word_underflow -= bali->free_aun_cnt;\n\tif (last_word_underflow > 0) {\n\t\tlam = &bali->lun_alloc_map[bali->lun_bmap_size - 1];\n\t\tfor (i = (HIBIT - last_word_underflow + 1);\n\t\t     i < BITS_PER_LONG;\n\t\t     i++)\n\t\t\tclear_bit(i, (ulong *)lam);\n\t}\n\n\t \n\tbali->free_high_idx = bali->lun_bmap_size;\n\n\t \n\tbali->aun_clone_map = kzalloc((bali->total_aus * sizeof(u8)),\n\t\t\t\t      GFP_KERNEL);\n\tif (unlikely(!bali->aun_clone_map)) {\n\t\tpr_err(\"%s: Failed to allocate clone map: lun_id=%016llx\\n\",\n\t\t       __func__, ba_lun->lun_id);\n\t\tkfree(bali->lun_alloc_map);\n\t\tkfree(bali);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tba_lun->ba_lun_handle = bali;\n\n\tpr_debug(\"%s: Successfully initialized the LUN: \"\n\t\t \"lun_id=%016llx bitmap size=%x, free_aun_cnt=%llx\\n\",\n\t\t__func__, ba_lun->lun_id, bali->lun_bmap_size,\n\t\tbali->free_aun_cnt);\n\treturn 0;\n}\n\n \nstatic int find_free_range(u32 low,\n\t\t\t   u32 high,\n\t\t\t   struct ba_lun_info *bali, int *bit_word)\n{\n\tint i;\n\tu64 bit_pos = -1;\n\tulong *lam, num_bits;\n\n\tfor (i = low; i < high; i++)\n\t\tif (bali->lun_alloc_map[i] != 0) {\n\t\t\tlam = (ulong *)&bali->lun_alloc_map[i];\n\t\t\tnum_bits = (sizeof(*lam) * BITS_PER_BYTE);\n\t\t\tbit_pos = find_first_bit(lam, num_bits);\n\n\t\t\tpr_devel(\"%s: Found free bit %llu in LUN \"\n\t\t\t\t \"map entry %016llx at bitmap index = %d\\n\",\n\t\t\t\t __func__, bit_pos, bali->lun_alloc_map[i], i);\n\n\t\t\t*bit_word = i;\n\t\t\tbali->free_aun_cnt--;\n\t\t\tclear_bit(bit_pos, lam);\n\t\t\tbreak;\n\t\t}\n\n\treturn bit_pos;\n}\n\n \nstatic u64 ba_alloc(struct ba_lun *ba_lun)\n{\n\tu64 bit_pos = -1;\n\tint bit_word = 0;\n\tstruct ba_lun_info *bali = NULL;\n\n\tbali = ba_lun->ba_lun_handle;\n\n\tpr_debug(\"%s: Received block allocation request: \"\n\t\t \"lun_id=%016llx free_aun_cnt=%llx\\n\",\n\t\t __func__, ba_lun->lun_id, bali->free_aun_cnt);\n\n\tif (bali->free_aun_cnt == 0) {\n\t\tpr_debug(\"%s: No space left on LUN: lun_id=%016llx\\n\",\n\t\t\t __func__, ba_lun->lun_id);\n\t\treturn -1ULL;\n\t}\n\n\t \n\tbit_pos = find_free_range(bali->free_curr_idx,\n\t\t\t\t  bali->free_high_idx, bali, &bit_word);\n\tif (bit_pos == -1) {\n\t\tbit_pos = find_free_range(bali->free_low_idx,\n\t\t\t\t\t  bali->free_curr_idx,\n\t\t\t\t\t  bali, &bit_word);\n\t\tif (bit_pos == -1) {\n\t\t\tpr_debug(\"%s: Could not find an allocation unit on LUN:\"\n\t\t\t\t \" lun_id=%016llx\\n\", __func__, ba_lun->lun_id);\n\t\t\treturn -1ULL;\n\t\t}\n\t}\n\n\t \n\tif (bit_pos == HIBIT)\n\t\tbali->free_curr_idx = bit_word + 1;\n\telse\n\t\tbali->free_curr_idx = bit_word;\n\n\tpr_debug(\"%s: Allocating AU number=%llx lun_id=%016llx \"\n\t\t \"free_aun_cnt=%llx\\n\", __func__,\n\t\t ((bit_word * BITS_PER_LONG) + bit_pos), ba_lun->lun_id,\n\t\t bali->free_aun_cnt);\n\n\treturn (u64) ((bit_word * BITS_PER_LONG) + bit_pos);\n}\n\n \nstatic int validate_alloc(struct ba_lun_info *bali, u64 aun)\n{\n\tint idx = 0, bit_pos = 0;\n\n\tidx = aun / BITS_PER_LONG;\n\tbit_pos = aun % BITS_PER_LONG;\n\n\tif (test_bit(bit_pos, (ulong *)&bali->lun_alloc_map[idx]))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int ba_free(struct ba_lun *ba_lun, u64 to_free)\n{\n\tint idx = 0, bit_pos = 0;\n\tstruct ba_lun_info *bali = NULL;\n\n\tbali = ba_lun->ba_lun_handle;\n\n\tif (validate_alloc(bali, to_free)) {\n\t\tpr_debug(\"%s: AUN %llx is not allocated on lun_id=%016llx\\n\",\n\t\t\t __func__, to_free, ba_lun->lun_id);\n\t\treturn -1;\n\t}\n\n\tpr_debug(\"%s: Received a request to free AU=%llx lun_id=%016llx \"\n\t\t \"free_aun_cnt=%llx\\n\", __func__, to_free, ba_lun->lun_id,\n\t\t bali->free_aun_cnt);\n\n\tif (bali->aun_clone_map[to_free] > 0) {\n\t\tpr_debug(\"%s: AUN %llx lun_id=%016llx cloned. Clone count=%x\\n\",\n\t\t\t __func__, to_free, ba_lun->lun_id,\n\t\t\t bali->aun_clone_map[to_free]);\n\t\tbali->aun_clone_map[to_free]--;\n\t\treturn 0;\n\t}\n\n\tidx = to_free / BITS_PER_LONG;\n\tbit_pos = to_free % BITS_PER_LONG;\n\n\tset_bit(bit_pos, (ulong *)&bali->lun_alloc_map[idx]);\n\tbali->free_aun_cnt++;\n\n\tif (idx < bali->free_low_idx)\n\t\tbali->free_low_idx = idx;\n\telse if (idx > bali->free_high_idx)\n\t\tbali->free_high_idx = idx;\n\n\tpr_debug(\"%s: Successfully freed AU bit_pos=%x bit map index=%x \"\n\t\t \"lun_id=%016llx free_aun_cnt=%llx\\n\", __func__, bit_pos, idx,\n\t\t ba_lun->lun_id, bali->free_aun_cnt);\n\n\treturn 0;\n}\n\n \nstatic int ba_clone(struct ba_lun *ba_lun, u64 to_clone)\n{\n\tstruct ba_lun_info *bali = ba_lun->ba_lun_handle;\n\n\tif (validate_alloc(bali, to_clone)) {\n\t\tpr_debug(\"%s: AUN=%llx not allocated on lun_id=%016llx\\n\",\n\t\t\t __func__, to_clone, ba_lun->lun_id);\n\t\treturn -1;\n\t}\n\n\tpr_debug(\"%s: Received a request to clone AUN %llx on lun_id=%016llx\\n\",\n\t\t __func__, to_clone, ba_lun->lun_id);\n\n\tif (bali->aun_clone_map[to_clone] == MAX_AUN_CLONE_CNT) {\n\t\tpr_debug(\"%s: AUN %llx on lun_id=%016llx hit max clones already\\n\",\n\t\t\t __func__, to_clone, ba_lun->lun_id);\n\t\treturn -1;\n\t}\n\n\tbali->aun_clone_map[to_clone]++;\n\n\treturn 0;\n}\n\n \nstatic u64 ba_space(struct ba_lun *ba_lun)\n{\n\tstruct ba_lun_info *bali = ba_lun->ba_lun_handle;\n\n\treturn bali->free_aun_cnt;\n}\n\n \nvoid cxlflash_ba_terminate(struct ba_lun *ba_lun)\n{\n\tstruct ba_lun_info *bali = ba_lun->ba_lun_handle;\n\n\tif (bali) {\n\t\tkfree(bali->aun_clone_map);\n\t\tkfree(bali->lun_alloc_map);\n\t\tkfree(bali);\n\t\tba_lun->ba_lun_handle = NULL;\n\t}\n}\n\n \nstatic int init_vlun(struct llun_info *lli)\n{\n\tint rc = 0;\n\tstruct glun_info *gli = lli->parent;\n\tstruct blka *blka = &gli->blka;\n\n\tmemset(blka, 0, sizeof(*blka));\n\tmutex_init(&blka->mutex);\n\n\t \n\tblka->ba_lun.lun_id = lli->lun_index;\n\tblka->ba_lun.lsize = gli->max_lba + 1;\n\tblka->ba_lun.lba_size = gli->blk_len;\n\n\tblka->ba_lun.au_size = MC_CHUNK_SIZE;\n\tblka->nchunk = blka->ba_lun.lsize / MC_CHUNK_SIZE;\n\n\trc = ba_init(&blka->ba_lun);\n\tif (unlikely(rc))\n\t\tpr_debug(\"%s: cannot init block_alloc, rc=%d\\n\", __func__, rc);\n\n\tpr_debug(\"%s: returning rc=%d lli=%p\\n\", __func__, rc, lli);\n\treturn rc;\n}\n\n \nstatic int write_same16(struct scsi_device *sdev,\n\t\t\tu64 lba,\n\t\t\tu32 nblks)\n{\n\tu8 *cmd_buf = NULL;\n\tu8 *scsi_cmd = NULL;\n\tint rc = 0;\n\tint result = 0;\n\tu64 offset = lba;\n\tint left = nblks;\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tconst u32 s = ilog2(sdev->sector_size) - 9;\n\tconst u32 to = sdev->request_queue->rq_timeout;\n\tconst u32 ws_limit =\n\t\tsdev->request_queue->limits.max_write_zeroes_sectors >> s;\n\n\tcmd_buf = kzalloc(CMD_BUFSIZE, GFP_KERNEL);\n\tscsi_cmd = kzalloc(MAX_COMMAND_SIZE, GFP_KERNEL);\n\tif (unlikely(!cmd_buf || !scsi_cmd)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twhile (left > 0) {\n\n\t\tscsi_cmd[0] = WRITE_SAME_16;\n\t\tscsi_cmd[1] = cfg->ws_unmap ? 0x8 : 0;\n\t\tput_unaligned_be64(offset, &scsi_cmd[2]);\n\t\tput_unaligned_be32(ws_limit < left ? ws_limit : left,\n\t\t\t\t   &scsi_cmd[10]);\n\n\t\t \n\t\tup_read(&cfg->ioctl_rwsem);\n\t\tresult = scsi_execute_cmd(sdev, scsi_cmd, REQ_OP_DRV_OUT,\n\t\t\t\t\t  cmd_buf, CMD_BUFSIZE, to,\n\t\t\t\t\t  CMD_RETRIES, NULL);\n\t\tdown_read(&cfg->ioctl_rwsem);\n\t\trc = check_state(cfg);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"%s: Failed state result=%08x\\n\",\n\t\t\t\t__func__, result);\n\t\t\trc = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (result) {\n\t\t\tdev_err_ratelimited(dev, \"%s: command failed for \"\n\t\t\t\t\t    \"offset=%lld result=%08x\\n\",\n\t\t\t\t\t    __func__, offset, result);\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tleft -= ws_limit;\n\t\toffset += ws_limit;\n\t}\n\nout:\n\tkfree(cmd_buf);\n\tkfree(scsi_cmd);\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic int grow_lxt(struct afu *afu,\n\t\t    struct scsi_device *sdev,\n\t\t    ctx_hndl_t ctxid,\n\t\t    res_hndl_t rhndl,\n\t\t    struct sisl_rht_entry *rhte,\n\t\t    u64 *new_size)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct sisl_lxt_entry *lxt = NULL, *lxt_old = NULL;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tstruct blka *blka = &gli->blka;\n\tu32 av_size;\n\tu32 ngrps, ngrps_old;\n\tu64 aun;\t\t \n\tu64 delta = *new_size - rhte->lxt_cnt;\n\tu64 my_new_size;\n\tint i, rc = 0;\n\n\t \n\tmutex_lock(&blka->mutex);\n\tav_size = ba_space(&blka->ba_lun);\n\tif (unlikely(av_size <= 0)) {\n\t\tdev_dbg(dev, \"%s: ba_space error av_size=%d\\n\",\n\t\t\t__func__, av_size);\n\t\tmutex_unlock(&blka->mutex);\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tif (av_size < delta)\n\t\tdelta = av_size;\n\n\tlxt_old = rhte->lxt_start;\n\tngrps_old = LXT_NUM_GROUPS(rhte->lxt_cnt);\n\tngrps = LXT_NUM_GROUPS(rhte->lxt_cnt + delta);\n\n\tif (ngrps != ngrps_old) {\n\t\t \n\t\tlxt = kzalloc((sizeof(*lxt) * LXT_GROUP_SIZE * ngrps),\n\t\t\t      GFP_KERNEL);\n\t\tif (unlikely(!lxt)) {\n\t\t\tmutex_unlock(&blka->mutex);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmemcpy(lxt, lxt_old, (sizeof(*lxt) * rhte->lxt_cnt));\n\t} else\n\t\tlxt = lxt_old;\n\n\t \n\tmy_new_size = rhte->lxt_cnt + delta;\n\n\t \n\tfor (i = rhte->lxt_cnt; i < my_new_size; i++) {\n\t\t \n\t\taun = ba_alloc(&blka->ba_lun);\n\t\tif ((aun == -1ULL) || (aun >= blka->nchunk))\n\t\t\tdev_dbg(dev, \"%s: ba_alloc error allocated chunk=%llu \"\n\t\t\t\t\"max=%llu\\n\", __func__, aun, blka->nchunk - 1);\n\n\t\t \n\t\tlxt[i].rlba_base = ((aun << MC_CHUNK_SHIFT) |\n\t\t\t\t    (lli->lun_index << LXT_LUNIDX_SHIFT) |\n\t\t\t\t    (RHT_PERM_RW << LXT_PERM_SHIFT |\n\t\t\t\t     lli->port_sel));\n\t}\n\n\tmutex_unlock(&blka->mutex);\n\n\t \n\tdma_wmb();  \n\n\trhte->lxt_start = lxt;\n\tdma_wmb();  \n\n\trhte->lxt_cnt = my_new_size;\n\tdma_wmb();  \n\n\trc = cxlflash_afu_sync(afu, ctxid, rhndl, AFU_LW_SYNC);\n\tif (unlikely(rc))\n\t\trc = -EAGAIN;\n\n\t \n\tif (lxt != lxt_old)\n\t\tkfree(lxt_old);\n\t*new_size = my_new_size;\nout:\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic int shrink_lxt(struct afu *afu,\n\t\t      struct scsi_device *sdev,\n\t\t      res_hndl_t rhndl,\n\t\t      struct sisl_rht_entry *rhte,\n\t\t      struct ctx_info *ctxi,\n\t\t      u64 *new_size)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct sisl_lxt_entry *lxt, *lxt_old;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tstruct blka *blka = &gli->blka;\n\tctx_hndl_t ctxid = DECODE_CTXID(ctxi->ctxid);\n\tbool needs_ws = ctxi->rht_needs_ws[rhndl];\n\tbool needs_sync = !ctxi->err_recovery_active;\n\tu32 ngrps, ngrps_old;\n\tu64 aun;\t\t \n\tu64 delta = rhte->lxt_cnt - *new_size;\n\tu64 my_new_size;\n\tint i, rc = 0;\n\n\tlxt_old = rhte->lxt_start;\n\tngrps_old = LXT_NUM_GROUPS(rhte->lxt_cnt);\n\tngrps = LXT_NUM_GROUPS(rhte->lxt_cnt - delta);\n\n\tif (ngrps != ngrps_old) {\n\t\t \n\t\tif (ngrps) {\n\t\t\tlxt = kzalloc((sizeof(*lxt) * LXT_GROUP_SIZE * ngrps),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (unlikely(!lxt)) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\tmemcpy(lxt, lxt_old,\n\t\t\t       (sizeof(*lxt) * (rhte->lxt_cnt - delta)));\n\t\t} else\n\t\t\tlxt = NULL;\n\t} else\n\t\tlxt = lxt_old;\n\n\t \n\tmy_new_size = rhte->lxt_cnt - delta;\n\n\t \n\trhte->lxt_cnt = my_new_size;\n\tdma_wmb();  \n\n\trhte->lxt_start = lxt;\n\tdma_wmb();  \n\n\tif (needs_sync) {\n\t\trc = cxlflash_afu_sync(afu, ctxid, rhndl, AFU_HW_SYNC);\n\t\tif (unlikely(rc))\n\t\t\trc = -EAGAIN;\n\t}\n\n\tif (needs_ws) {\n\t\t \n\t\tctxi->unavail = true;\n\t\tmutex_unlock(&ctxi->mutex);\n\t}\n\n\t \n\tmutex_lock(&blka->mutex);\n\tfor (i = delta - 1; i >= 0; i--) {\n\t\taun = lxt_old[my_new_size + i].rlba_base >> MC_CHUNK_SHIFT;\n\t\tif (needs_ws)\n\t\t\twrite_same16(sdev, aun, MC_CHUNK_SIZE);\n\t\tba_free(&blka->ba_lun, aun);\n\t}\n\tmutex_unlock(&blka->mutex);\n\n\tif (needs_ws) {\n\t\t \n\t\tmutex_lock(&ctxi->mutex);\n\t\tctxi->unavail = false;\n\t}\n\n\t \n\tif (lxt != lxt_old)\n\t\tkfree(lxt_old);\n\t*new_size = my_new_size;\nout:\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nint _cxlflash_vlun_resize(struct scsi_device *sdev,\n\t\t\t  struct ctx_info *ctxi,\n\t\t\t  struct dk_cxlflash_resize *resize)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tstruct afu *afu = cfg->afu;\n\tbool put_ctx = false;\n\n\tres_hndl_t rhndl = resize->rsrc_handle;\n\tu64 new_size;\n\tu64 nsectors;\n\tu64 ctxid = DECODE_CTXID(resize->context_id),\n\t    rctxid = resize->context_id;\n\n\tstruct sisl_rht_entry *rhte;\n\n\tint rc = 0;\n\n\t \n\tnsectors = (resize->req_size * CXLFLASH_BLOCK_SIZE) / gli->blk_len;\n\tnew_size = DIV_ROUND_UP(nsectors, MC_CHUNK_SIZE);\n\n\tdev_dbg(dev, \"%s: ctxid=%llu rhndl=%llu req_size=%llu new_size=%llu\\n\",\n\t\t__func__, ctxid, resize->rsrc_handle, resize->req_size,\n\t\tnew_size);\n\n\tif (unlikely(gli->mode != MODE_VIRTUAL)) {\n\t\tdev_dbg(dev, \"%s: LUN mode does not support resize mode=%d\\n\",\n\t\t\t__func__, gli->mode);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\n\t}\n\n\tif (!ctxi) {\n\t\tctxi = get_context(cfg, rctxid, lli, CTX_CTRL_ERR_FALLBACK);\n\t\tif (unlikely(!ctxi)) {\n\t\t\tdev_dbg(dev, \"%s: Bad context ctxid=%llu\\n\",\n\t\t\t\t__func__, ctxid);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tput_ctx = true;\n\t}\n\n\trhte = get_rhte(ctxi, rhndl, lli);\n\tif (unlikely(!rhte)) {\n\t\tdev_dbg(dev, \"%s: Bad resource handle rhndl=%u\\n\",\n\t\t\t__func__, rhndl);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (new_size > rhte->lxt_cnt)\n\t\trc = grow_lxt(afu, sdev, ctxid, rhndl, rhte, &new_size);\n\telse if (new_size < rhte->lxt_cnt)\n\t\trc = shrink_lxt(afu, sdev, rhndl, rhte, ctxi, &new_size);\n\telse {\n\t\t \n\t\trc = cxlflash_afu_sync(afu, ctxid, rhndl, AFU_HW_SYNC);\n\t\tif (unlikely(rc)) {\n\t\t\trc = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresize->hdr.return_flags = 0;\n\tresize->last_lba = (new_size * MC_CHUNK_SIZE * gli->blk_len);\n\tresize->last_lba /= CXLFLASH_BLOCK_SIZE;\n\tresize->last_lba--;\n\nout:\n\tif (put_ctx)\n\t\tput_context(ctxi);\n\tdev_dbg(dev, \"%s: resized to %llu returning rc=%d\\n\",\n\t\t__func__, resize->last_lba, rc);\n\treturn rc;\n}\n\nint cxlflash_vlun_resize(struct scsi_device *sdev,\n\t\t\t struct dk_cxlflash_resize *resize)\n{\n\treturn _cxlflash_vlun_resize(sdev, NULL, resize);\n}\n\n \nvoid cxlflash_restore_luntable(struct cxlflash_cfg *cfg)\n{\n\tstruct llun_info *lli, *temp;\n\tu32 lind;\n\tint k;\n\tstruct device *dev = &cfg->dev->dev;\n\t__be64 __iomem *fc_port_luns;\n\n\tmutex_lock(&global.mutex);\n\n\tlist_for_each_entry_safe(lli, temp, &cfg->lluns, list) {\n\t\tif (!lli->in_table)\n\t\t\tcontinue;\n\n\t\tlind = lli->lun_index;\n\t\tdev_dbg(dev, \"%s: Virtual LUNs on slot %d:\\n\", __func__, lind);\n\n\t\tfor (k = 0; k < cfg->num_fc_ports; k++)\n\t\t\tif (lli->port_sel & (1 << k)) {\n\t\t\t\tfc_port_luns = get_fc_port_luns(cfg, k);\n\t\t\t\twriteq_be(lli->lun_id[k], &fc_port_luns[lind]);\n\t\t\t\tdev_dbg(dev, \"\\t%d=%llx\\n\", k, lli->lun_id[k]);\n\t\t\t}\n\t}\n\n\tmutex_unlock(&global.mutex);\n}\n\n \nstatic inline u8 get_num_ports(u32 psm)\n{\n\tstatic const u8 bits[16] = { 0, 1, 1, 2, 1, 2, 2, 3,\n\t\t\t\t     1, 2, 2, 3, 2, 3, 3, 4 };\n\n\treturn bits[psm & 0xf];\n}\n\n \nstatic int init_luntable(struct cxlflash_cfg *cfg, struct llun_info *lli)\n{\n\tu32 chan;\n\tu32 lind;\n\tu32 nports;\n\tint rc = 0;\n\tint k;\n\tstruct device *dev = &cfg->dev->dev;\n\t__be64 __iomem *fc_port_luns;\n\n\tmutex_lock(&global.mutex);\n\n\tif (lli->in_table)\n\t\tgoto out;\n\n\tnports = get_num_ports(lli->port_sel);\n\tif (nports == 0 || nports > cfg->num_fc_ports) {\n\t\tWARN(1, \"Unsupported port configuration nports=%u\", nports);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (nports > 1) {\n\t\t \n\t\tfor (k = 0; k < cfg->num_fc_ports; k++) {\n\t\t\tif (!(lli->port_sel & (1 << k)))\n\t\t\t\tcontinue;\n\n\t\t\tif (cfg->promote_lun_index == cfg->last_lun_index[k]) {\n\t\t\t\trc = -ENOSPC;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlind = lli->lun_index = cfg->promote_lun_index;\n\t\tdev_dbg(dev, \"%s: Virtual LUNs on slot %d:\\n\", __func__, lind);\n\n\t\tfor (k = 0; k < cfg->num_fc_ports; k++) {\n\t\t\tif (!(lli->port_sel & (1 << k)))\n\t\t\t\tcontinue;\n\n\t\t\tfc_port_luns = get_fc_port_luns(cfg, k);\n\t\t\twriteq_be(lli->lun_id[k], &fc_port_luns[lind]);\n\t\t\tdev_dbg(dev, \"\\t%d=%llx\\n\", k, lli->lun_id[k]);\n\t\t}\n\n\t\tcfg->promote_lun_index++;\n\t} else {\n\t\t \n\t\tchan = PORTMASK2CHAN(lli->port_sel);\n\t\tif (cfg->promote_lun_index == cfg->last_lun_index[chan]) {\n\t\t\trc = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlind = lli->lun_index = cfg->last_lun_index[chan];\n\t\tfc_port_luns = get_fc_port_luns(cfg, chan);\n\t\twriteq_be(lli->lun_id[chan], &fc_port_luns[lind]);\n\t\tcfg->last_lun_index[chan]--;\n\t\tdev_dbg(dev, \"%s: Virtual LUNs on slot %d:\\n\\t%d=%llx\\n\",\n\t\t\t__func__, lind, chan, lli->lun_id[chan]);\n\t}\n\n\tlli->in_table = true;\nout:\n\tmutex_unlock(&global.mutex);\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nint cxlflash_disk_virtual_open(struct scsi_device *sdev, void *arg)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\n\tstruct dk_cxlflash_uvirtual *virt = (struct dk_cxlflash_uvirtual *)arg;\n\tstruct dk_cxlflash_resize resize;\n\n\tu64 ctxid = DECODE_CTXID(virt->context_id),\n\t    rctxid = virt->context_id;\n\tu64 lun_size = virt->lun_size;\n\tu64 last_lba = 0;\n\tu64 rsrc_handle = -1;\n\n\tint rc = 0;\n\n\tstruct ctx_info *ctxi = NULL;\n\tstruct sisl_rht_entry *rhte = NULL;\n\n\tdev_dbg(dev, \"%s: ctxid=%llu ls=%llu\\n\", __func__, ctxid, lun_size);\n\n\t \n\tmutex_lock(&gli->mutex);\n\tif (gli->mode == MODE_NONE) {\n\t\trc = init_vlun(lli);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"%s: init_vlun failed rc=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err0;\n\t\t}\n\t}\n\n\trc = cxlflash_lun_attach(gli, MODE_VIRTUAL, true);\n\tif (unlikely(rc)) {\n\t\tdev_err(dev, \"%s: Failed attach to LUN (VIRTUAL)\\n\", __func__);\n\t\tgoto err0;\n\t}\n\tmutex_unlock(&gli->mutex);\n\n\trc = init_luntable(cfg, lli);\n\tif (rc) {\n\t\tdev_err(dev, \"%s: init_luntable failed rc=%d\\n\", __func__, rc);\n\t\tgoto err1;\n\t}\n\n\tctxi = get_context(cfg, rctxid, lli, 0);\n\tif (unlikely(!ctxi)) {\n\t\tdev_err(dev, \"%s: Bad context ctxid=%llu\\n\", __func__, ctxid);\n\t\trc = -EINVAL;\n\t\tgoto err1;\n\t}\n\n\trhte = rhte_checkout(ctxi, lli);\n\tif (unlikely(!rhte)) {\n\t\tdev_err(dev, \"%s: too many opens ctxid=%llu\\n\",\n\t\t\t__func__, ctxid);\n\t\trc = -EMFILE;\t \n\t\tgoto err1;\n\t}\n\n\trsrc_handle = (rhte - ctxi->rht_start);\n\n\t \n\trhte->nmask = MC_RHT_NMASK;\n\trhte->fp = SISL_RHT_FP(0U, ctxi->rht_perms);\n\n\t \n\tmarshal_virt_to_resize(virt, &resize);\n\tresize.rsrc_handle = rsrc_handle;\n\trc = _cxlflash_vlun_resize(sdev, ctxi, &resize);\n\tif (rc) {\n\t\tdev_err(dev, \"%s: resize failed rc=%d\\n\", __func__, rc);\n\t\tgoto err2;\n\t}\n\tlast_lba = resize.last_lba;\n\n\tif (virt->hdr.flags & DK_CXLFLASH_UVIRTUAL_NEED_WRITE_SAME)\n\t\tctxi->rht_needs_ws[rsrc_handle] = true;\n\n\tvirt->hdr.return_flags = 0;\n\tvirt->last_lba = last_lba;\n\tvirt->rsrc_handle = rsrc_handle;\n\n\tif (get_num_ports(lli->port_sel) > 1)\n\t\tvirt->hdr.return_flags |= DK_CXLFLASH_ALL_PORTS_ACTIVE;\nout:\n\tif (likely(ctxi))\n\t\tput_context(ctxi);\n\tdev_dbg(dev, \"%s: returning handle=%llu rc=%d llba=%llu\\n\",\n\t\t__func__, rsrc_handle, rc, last_lba);\n\treturn rc;\n\nerr2:\n\trhte_checkin(ctxi, rhte);\nerr1:\n\tcxlflash_lun_detach(gli);\n\tgoto out;\nerr0:\n\t \n\tcxlflash_ba_terminate(&gli->blka.ba_lun);\n\tmutex_unlock(&gli->mutex);\n\tgoto out;\n}\n\n \nstatic int clone_lxt(struct afu *afu,\n\t\t     struct blka *blka,\n\t\t     ctx_hndl_t ctxid,\n\t\t     res_hndl_t rhndl,\n\t\t     struct sisl_rht_entry *rhte,\n\t\t     struct sisl_rht_entry *rhte_src)\n{\n\tstruct cxlflash_cfg *cfg = afu->parent;\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct sisl_lxt_entry *lxt = NULL;\n\tbool locked = false;\n\tu32 ngrps;\n\tu64 aun;\t\t \n\tint j;\n\tint i = 0;\n\tint rc = 0;\n\n\tngrps = LXT_NUM_GROUPS(rhte_src->lxt_cnt);\n\n\tif (ngrps) {\n\t\t \n\t\tlxt = kzalloc((sizeof(*lxt) * LXT_GROUP_SIZE * ngrps),\n\t\t\t\tGFP_KERNEL);\n\t\tif (unlikely(!lxt)) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tmemcpy(lxt, rhte_src->lxt_start,\n\t\t       (sizeof(*lxt) * rhte_src->lxt_cnt));\n\n\t\t \n\t\tmutex_lock(&blka->mutex);\n\t\tlocked = true;\n\t\tfor (i = 0; i < rhte_src->lxt_cnt; i++) {\n\t\t\taun = (lxt[i].rlba_base >> MC_CHUNK_SHIFT);\n\t\t\tif (ba_clone(&blka->ba_lun, aun) == -1ULL) {\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdma_wmb();  \n\n\trhte->lxt_start = lxt;\n\tdma_wmb();  \n\n\trhte->lxt_cnt = rhte_src->lxt_cnt;\n\tdma_wmb();  \n\n\trc = cxlflash_afu_sync(afu, ctxid, rhndl, AFU_LW_SYNC);\n\tif (unlikely(rc)) {\n\t\trc = -EAGAIN;\n\t\tgoto err2;\n\t}\n\nout:\n\tif (locked)\n\t\tmutex_unlock(&blka->mutex);\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\nerr2:\n\t \n\trhte->lxt_cnt = 0;\n\tdma_wmb();\n\trhte->lxt_start = NULL;\n\tdma_wmb();\nerr:\n\t \n\tfor (j = 0; j < i; j++) {\n\t\taun = (lxt[j].rlba_base >> MC_CHUNK_SHIFT);\n\t\tba_free(&blka->ba_lun, aun);\n\t}\n\tkfree(lxt);\n\tgoto out;\n}\n\n \nint cxlflash_disk_clone(struct scsi_device *sdev,\n\t\t\tstruct dk_cxlflash_clone *clone)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = sdev->hostdata;\n\tstruct glun_info *gli = lli->parent;\n\tstruct blka *blka = &gli->blka;\n\tstruct afu *afu = cfg->afu;\n\tstruct dk_cxlflash_release release = { { 0 }, 0 };\n\n\tstruct ctx_info *ctxi_src = NULL,\n\t\t\t*ctxi_dst = NULL;\n\tstruct lun_access *lun_access_src, *lun_access_dst;\n\tu32 perms;\n\tu64 ctxid_src = DECODE_CTXID(clone->context_id_src),\n\t    ctxid_dst = DECODE_CTXID(clone->context_id_dst),\n\t    rctxid_src = clone->context_id_src,\n\t    rctxid_dst = clone->context_id_dst;\n\tint i, j;\n\tint rc = 0;\n\tbool found;\n\tLIST_HEAD(sidecar);\n\n\tdev_dbg(dev, \"%s: ctxid_src=%llu ctxid_dst=%llu\\n\",\n\t\t__func__, ctxid_src, ctxid_dst);\n\n\t \n\tif (unlikely(rctxid_src == rctxid_dst)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(gli->mode != MODE_VIRTUAL)) {\n\t\trc = -EINVAL;\n\t\tdev_dbg(dev, \"%s: Only supported on virtual LUNs mode=%u\\n\",\n\t\t\t__func__, gli->mode);\n\t\tgoto out;\n\t}\n\n\tctxi_src = get_context(cfg, rctxid_src, lli, CTX_CTRL_CLONE);\n\tctxi_dst = get_context(cfg, rctxid_dst, lli, 0);\n\tif (unlikely(!ctxi_src || !ctxi_dst)) {\n\t\tdev_dbg(dev, \"%s: Bad context ctxid_src=%llu ctxid_dst=%llu\\n\",\n\t\t\t__func__, ctxid_src, ctxid_dst);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_RHT_PER_CONTEXT; i++)\n\t\tif (ctxi_dst->rht_start[i].nmask != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t \n\tlist_for_each_entry(lun_access_src, &ctxi_src->luns, list) {\n\t\tfound = false;\n\t\tlist_for_each_entry(lun_access_dst, &ctxi_dst->luns, list)\n\t\t\tif (lun_access_dst->sdev == lun_access_src->sdev) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!found) {\n\t\t\tlun_access_dst = kzalloc(sizeof(*lun_access_dst),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (unlikely(!lun_access_dst)) {\n\t\t\t\tdev_err(dev, \"%s: lun_access allocation fail\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*lun_access_dst = *lun_access_src;\n\t\t\tlist_add(&lun_access_dst->list, &sidecar);\n\t\t}\n\t}\n\n\tif (unlikely(!ctxi_src->rht_out)) {\n\t\tdev_dbg(dev, \"%s: Nothing to clone\\n\", __func__);\n\t\tgoto out_success;\n\t}\n\n\t \n\tperms = ctxi_dst->rht_perms;\n\n\t \n\tfor (i = 0; i < MAX_RHT_PER_CONTEXT; i++) {\n\t\tif (ctxi_src->rht_out == ctxi_dst->rht_out)\n\t\t\tbreak;\n\t\tif (ctxi_src->rht_start[i].nmask == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tctxi_dst->rht_out++;\n\t\tctxi_dst->rht_start[i].nmask = ctxi_src->rht_start[i].nmask;\n\t\tctxi_dst->rht_start[i].fp =\n\t\t    SISL_RHT_FP_CLONE(ctxi_src->rht_start[i].fp, perms);\n\t\tctxi_dst->rht_lun[i] = ctxi_src->rht_lun[i];\n\n\t\trc = clone_lxt(afu, blka, ctxid_dst, i,\n\t\t\t       &ctxi_dst->rht_start[i],\n\t\t\t       &ctxi_src->rht_start[i]);\n\t\tif (rc) {\n\t\t\tmarshal_clone_to_rele(clone, &release);\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\trelease.rsrc_handle = j;\n\t\t\t\t_cxlflash_disk_release(sdev, ctxi_dst,\n\t\t\t\t\t\t       &release);\n\t\t\t}\n\n\t\t\t \n\t\t\trhte_checkin(ctxi_dst, &ctxi_dst->rht_start[i]);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcxlflash_lun_attach(gli, gli->mode, false);\n\t}\n\nout_success:\n\tlist_splice(&sidecar, &ctxi_dst->luns);\n\n\t \nout:\n\tif (ctxi_src)\n\t\tput_context(ctxi_src);\n\tif (ctxi_dst)\n\t\tput_context(ctxi_dst);\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n\nerr:\n\tlist_for_each_entry_safe(lun_access_src, lun_access_dst, &sidecar, list)\n\t\tkfree(lun_access_src);\n\tgoto out;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}