{
  "module_name": "lunmgt.c",
  "hash_id": "d4f65415d837fe08823a9e2ae9edd610f2edbeed2ee5227405ba8b26ab7fc333",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/cxlflash/lunmgt.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n\n#include <scsi/scsi_host.h>\n#include <uapi/scsi/cxlflash_ioctl.h>\n\n#include \"sislite.h\"\n#include \"common.h\"\n#include \"vlun.h\"\n#include \"superpipe.h\"\n\n \nstatic struct llun_info *create_local(struct scsi_device *sdev, u8 *wwid)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = NULL;\n\n\tlli = kzalloc(sizeof(*lli), GFP_KERNEL);\n\tif (unlikely(!lli)) {\n\t\tdev_err(dev, \"%s: could not allocate lli\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tlli->sdev = sdev;\n\tlli->host_no = sdev->host->host_no;\n\tlli->in_table = false;\n\n\tmemcpy(lli->wwid, wwid, DK_CXLFLASH_MANAGE_LUN_WWID_LEN);\nout:\n\treturn lli;\n}\n\n \nstatic struct glun_info *create_global(struct scsi_device *sdev, u8 *wwid)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct glun_info *gli = NULL;\n\n\tgli = kzalloc(sizeof(*gli), GFP_KERNEL);\n\tif (unlikely(!gli)) {\n\t\tdev_err(dev, \"%s: could not allocate gli\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tmutex_init(&gli->mutex);\n\tmemcpy(gli->wwid, wwid, DK_CXLFLASH_MANAGE_LUN_WWID_LEN);\nout:\n\treturn gli;\n}\n\n \nstatic struct llun_info *lookup_local(struct cxlflash_cfg *cfg, u8 *wwid)\n{\n\tstruct llun_info *lli, *temp;\n\n\tlist_for_each_entry_safe(lli, temp, &cfg->lluns, list)\n\t\tif (!memcmp(lli->wwid, wwid, DK_CXLFLASH_MANAGE_LUN_WWID_LEN))\n\t\t\treturn lli;\n\n\treturn NULL;\n}\n\n \nstatic struct glun_info *lookup_global(u8 *wwid)\n{\n\tstruct glun_info *gli, *temp;\n\n\tlist_for_each_entry_safe(gli, temp, &global.gluns, list)\n\t\tif (!memcmp(gli->wwid, wwid, DK_CXLFLASH_MANAGE_LUN_WWID_LEN))\n\t\t\treturn gli;\n\n\treturn NULL;\n}\n\n \nstatic struct llun_info *find_and_create_lun(struct scsi_device *sdev, u8 *wwid)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = NULL;\n\tstruct glun_info *gli = NULL;\n\n\tif (unlikely(!wwid))\n\t\tgoto out;\n\n\tlli = lookup_local(cfg, wwid);\n\tif (lli)\n\t\tgoto out;\n\n\tlli = create_local(sdev, wwid);\n\tif (unlikely(!lli))\n\t\tgoto out;\n\n\tgli = lookup_global(wwid);\n\tif (gli) {\n\t\tlli->parent = gli;\n\t\tlist_add(&lli->list, &cfg->lluns);\n\t\tgoto out;\n\t}\n\n\tgli = create_global(sdev, wwid);\n\tif (unlikely(!gli)) {\n\t\tkfree(lli);\n\t\tlli = NULL;\n\t\tgoto out;\n\t}\n\n\tlli->parent = gli;\n\tlist_add(&lli->list, &cfg->lluns);\n\n\tlist_add(&gli->list, &global.gluns);\n\nout:\n\tdev_dbg(dev, \"%s: returning lli=%p, gli=%p\\n\", __func__, lli, gli);\n\treturn lli;\n}\n\n \nvoid cxlflash_term_local_luns(struct cxlflash_cfg *cfg)\n{\n\tstruct llun_info *lli, *temp;\n\n\tmutex_lock(&global.mutex);\n\tlist_for_each_entry_safe(lli, temp, &cfg->lluns, list) {\n\t\tlist_del(&lli->list);\n\t\tkfree(lli);\n\t}\n\tmutex_unlock(&global.mutex);\n}\n\n \nvoid cxlflash_list_init(void)\n{\n\tINIT_LIST_HEAD(&global.gluns);\n\tmutex_init(&global.mutex);\n\tglobal.err_page = NULL;\n}\n\n \nvoid cxlflash_term_global_luns(void)\n{\n\tstruct glun_info *gli, *temp;\n\n\tmutex_lock(&global.mutex);\n\tlist_for_each_entry_safe(gli, temp, &global.gluns, list) {\n\t\tlist_del(&gli->list);\n\t\tcxlflash_ba_terminate(&gli->blka.ba_lun);\n\t\tkfree(gli);\n\t}\n\tmutex_unlock(&global.mutex);\n}\n\n \nint cxlflash_manage_lun(struct scsi_device *sdev,\n\t\t\tstruct dk_cxlflash_manage_lun *manage)\n{\n\tstruct cxlflash_cfg *cfg = shost_priv(sdev->host);\n\tstruct device *dev = &cfg->dev->dev;\n\tstruct llun_info *lli = NULL;\n\tint rc = 0;\n\tu64 flags = manage->hdr.flags;\n\tu32 chan = sdev->channel;\n\n\tmutex_lock(&global.mutex);\n\tlli = find_and_create_lun(sdev, manage->wwid);\n\tdev_dbg(dev, \"%s: WWID=%016llx%016llx, flags=%016llx lli=%p\\n\",\n\t\t__func__, get_unaligned_be64(&manage->wwid[0]),\n\t\tget_unaligned_be64(&manage->wwid[8]), manage->hdr.flags, lli);\n\tif (unlikely(!lli)) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (flags & DK_CXLFLASH_MANAGE_LUN_ENABLE_SUPERPIPE) {\n\t\t \n\t\tlli->port_sel |= CHAN2PORTMASK(chan);\n\t\tlli->lun_id[chan] = lun_to_lunid(sdev->lun);\n\t\tsdev->hostdata = lli;\n\t} else if (flags & DK_CXLFLASH_MANAGE_LUN_DISABLE_SUPERPIPE) {\n\t\tif (lli->parent->mode != MODE_NONE)\n\t\t\trc = -EBUSY;\n\t\telse {\n\t\t\t \n\t\t\tsdev->hostdata = NULL;\n\t\t\tlli->port_sel &= ~CHAN2PORTMASK(chan);\n\t\t\tif (lli->port_sel == 0U)\n\t\t\t\tlli->in_table = false;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"%s: port_sel=%08x chan=%u lun_id=%016llx\\n\",\n\t\t__func__, lli->port_sel, chan, lli->lun_id[chan]);\n\nout:\n\tmutex_unlock(&global.mutex);\n\tdev_dbg(dev, \"%s: returning rc=%d\\n\", __func__, rc);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}