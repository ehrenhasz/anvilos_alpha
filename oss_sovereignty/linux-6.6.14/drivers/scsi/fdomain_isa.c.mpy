{
  "module_name": "fdomain_isa.c",
  "hash_id": "2432be1b2f5b5dacaee2565503eabdc211ca21b99c383df52830d8aeeb91f924",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/fdomain_isa.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/isa.h>\n#include <scsi/scsi_host.h>\n#include \"fdomain.h\"\n\n#define MAXBOARDS_PARAM 4\nstatic int io[MAXBOARDS_PARAM] = { 0, 0, 0, 0 };\nmodule_param_hw_array(io, int, ioport, NULL, 0);\nMODULE_PARM_DESC(io, \"base I/O address of controller (0x140, 0x150, 0x160, 0x170)\");\n\nstatic int irq[MAXBOARDS_PARAM] = { 0, 0, 0, 0 };\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nMODULE_PARM_DESC(irq, \"IRQ of controller (0=auto [default])\");\n\nstatic int scsi_id[MAXBOARDS_PARAM] = { 0, 0, 0, 0 };\nmodule_param_hw_array(scsi_id, int, other, NULL, 0);\nMODULE_PARM_DESC(scsi_id, \"SCSI ID of controller (default = 7)\");\n\nstatic unsigned long addresses[] = {\n\t0xc8000,\n\t0xca000,\n\t0xce000,\n\t0xde000,\n};\n#define ADDRESS_COUNT ARRAY_SIZE(addresses)\n\nstatic unsigned short ports[] = { 0x140, 0x150, 0x160, 0x170 };\n#define PORT_COUNT ARRAY_SIZE(ports)\n\nstatic unsigned short irqs[] = { 3, 5, 10, 11, 12, 14, 15, 0 };\n\n \n\nstatic struct signature {\n\tconst char *signature;\n\tint offset;\n\tint length;\n\tint this_id;\n\tint base_offset;\n} signatures[] = {\n \n \n{ \"FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89\",\t 5, 50,  6, 0x1fcc },\n{ \"FUTURE DOMAIN CORP. (C) 1986-1990 1800-V1.07/28/89\",\t 5, 50,  6, 0x1fcc },\n{ \"FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89\", 72, 50,  6, 0x1fa2 },\n{ \"FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.0\",\t73, 43,  6, 0x1fa2 },\n{ \"FUTURE DOMAIN CORP. (C) 1991 1800-V2.0.\",\t\t72, 39,  6, 0x1fa3 },\n{ \"FUTURE DOMAIN CORP. (C) 1992 V3.00.004/02/92\",\t 5, 44,  6, 0 },\n{ \"FUTURE DOMAIN TMC-18XX (C) 1993 V3.203/12/93\",\t 5, 44,  7, 0 },\n{ \"IBM F1 P2 BIOS v1.0011/09/92\",\t\t\t 5, 28,  7, 0x1ff3 },\n{ \"IBM F1 P2 BIOS v1.0104/29/93\",\t\t\t 5, 28,  7, 0 },\n{ \"Future Domain Corp. V1.0008/18/93\",\t\t\t 5, 33,  7, 0 },\n{ \"Future Domain Corp. V2.0108/18/93\",\t\t\t 5, 33,  7, 0 },\n{ \"FUTURE DOMAIN CORP.  V3.5008/18/93\",\t\t\t 5, 34,  7, 0 },\n{ \"FUTURE DOMAIN 18c30/18c50/1800 (C) 1994 V3.5\",\t 5, 44,  7, 0 },\n{ \"FUTURE DOMAIN CORP.  V3.6008/18/93\",\t\t\t 5, 34,  7, 0 },\n{ \"FUTURE DOMAIN CORP.  V3.6108/18/93\",\t\t\t 5, 34,  7, 0 },\n};\n#define SIGNATURE_COUNT ARRAY_SIZE(signatures)\n\nstatic int fdomain_isa_match(struct device *dev, unsigned int ndev)\n{\n\tstruct Scsi_Host *sh;\n\tint i, base = 0, irq = 0;\n\tunsigned long bios_base = 0;\n\tstruct signature *sig = NULL;\n\tvoid __iomem *p;\n\tstatic struct signature *saved_sig;\n\tint this_id = 7;\n\n\tif (ndev < ADDRESS_COUNT) {\t \n\t\tp = ioremap(addresses[ndev], FDOMAIN_BIOS_SIZE);\n\t\tif (!p)\n\t\t\treturn 0;\n\t\tfor (i = 0; i < SIGNATURE_COUNT; i++)\n\t\t\tif (check_signature(p + signatures[i].offset,\n\t\t\t\t\t    signatures[i].signature,\n\t\t\t\t\t    signatures[i].length))\n\t\t\t\tbreak;\n\t\tif (i == SIGNATURE_COUNT)\t \n\t\t\tgoto fail_unmap;\n\t\tsig = &signatures[i];\n\t\tbios_base = addresses[ndev];\n\t\t \n\t\tif (sig->base_offset)\n\t\t\tbase = readb(p + sig->base_offset) +\n\t\t\t      (readb(p + sig->base_offset + 1) << 8);\n\t\tiounmap(p);\n\t\tif (base) {\n\t\t\tdev_info(dev, \"BIOS at 0x%lx specifies I/O base 0x%x\\n\",\n\t\t\t\t bios_base, base);\n\t\t} else {  \n\t\t\tdev_info(dev, \"BIOS at 0x%lx\\n\", bios_base);\n\t\t\t \n\t\t\tsaved_sig = sig;\n\t\t\treturn 0;\n\t\t}\n\t} else\t \n\t\tbase = ports[ndev - ADDRESS_COUNT];\n\n\t \n\tif (!sig && saved_sig)\n\t\tsig = saved_sig;\n\n\tif (!request_region(base, FDOMAIN_REGION_SIZE, \"fdomain_isa\"))\n\t\treturn 0;\n\n\tirq = irqs[(inb(base + REG_CFG1) & CFG1_IRQ_MASK) >> 1];\n\n\tif (sig)\n\t\tthis_id = sig->this_id;\n\n\tsh = fdomain_create(base, irq, this_id, dev);\n\tif (!sh) {\n\t\trelease_region(base, FDOMAIN_REGION_SIZE);\n\t\treturn 0;\n\t}\n\n\tdev_set_drvdata(dev, sh);\n\treturn 1;\nfail_unmap:\n\tiounmap(p);\n\treturn 0;\n}\n\nstatic int fdomain_isa_param_match(struct device *dev, unsigned int ndev)\n{\n\tstruct Scsi_Host *sh;\n\tint irq_ = irq[ndev];\n\n\tif (!io[ndev])\n\t\treturn 0;\n\n\tif (!request_region(io[ndev], FDOMAIN_REGION_SIZE, \"fdomain_isa\")) {\n\t\tdev_err(dev, \"base 0x%x already in use\", io[ndev]);\n\t\treturn 0;\n\t}\n\n\tif (irq_ <= 0)\n\t\tirq_ = irqs[(inb(io[ndev] + REG_CFG1) & CFG1_IRQ_MASK) >> 1];\n\n\tsh = fdomain_create(io[ndev], irq_, scsi_id[ndev], dev);\n\tif (!sh) {\n\t\tdev_err(dev, \"controller not found at base 0x%x\", io[ndev]);\n\t\trelease_region(io[ndev], FDOMAIN_REGION_SIZE);\n\t\treturn 0;\n\t}\n\n\tdev_set_drvdata(dev, sh);\n\treturn 1;\n}\n\nstatic void fdomain_isa_remove(struct device *dev, unsigned int ndev)\n{\n\tstruct Scsi_Host *sh = dev_get_drvdata(dev);\n\tint base = sh->io_port;\n\n\tfdomain_destroy(sh);\n\trelease_region(base, FDOMAIN_REGION_SIZE);\n\tdev_set_drvdata(dev, NULL);\n}\n\nstatic struct isa_driver fdomain_isa_driver = {\n\t.match\t\t= fdomain_isa_match,\n\t.remove\t\t= fdomain_isa_remove,\n\t.driver = {\n\t\t.name\t= \"fdomain_isa\",\n\t\t.pm\t= FDOMAIN_PM_OPS,\n\t},\n};\n\nstatic int __init fdomain_isa_init(void)\n{\n\tint isa_probe_count = ADDRESS_COUNT + PORT_COUNT;\n\n\tif (io[0]) {\t \n\t\tfdomain_isa_driver.match = fdomain_isa_param_match;\n\t\tisa_probe_count = MAXBOARDS_PARAM;\n\t}\n\n\treturn isa_register_driver(&fdomain_isa_driver, isa_probe_count);\n}\n\nstatic void __exit fdomain_isa_exit(void)\n{\n\tisa_unregister_driver(&fdomain_isa_driver);\n}\n\nmodule_init(fdomain_isa_init);\nmodule_exit(fdomain_isa_exit);\n\nMODULE_AUTHOR(\"Ondrej Zary, Rickard E. Faith\");\nMODULE_DESCRIPTION(\"Future Domain TMC-16x0 ISA SCSI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}