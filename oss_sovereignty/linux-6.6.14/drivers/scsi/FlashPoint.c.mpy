{
  "module_name": "FlashPoint.c",
  "hash_id": "d994610dcc5c1ae72683680d54f8c73e228d7c2b98e20ec7712fe37680d5c056",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/FlashPoint.c",
  "human_readable_source": " \n\n\n#ifdef CONFIG_SCSI_FLASHPOINT\n\n#define MAX_CARDS\t8\n#undef BUSTYPE_PCI\n\n#define CRCMASK\t0xA001\n\n#define FAILURE         0xFFFFFFFFL\n\nstruct sccb;\ntypedef void (*CALL_BK_FN) (struct sccb *);\n\nstruct sccb_mgr_info {\n\tu32 si_baseaddr;\n\tunsigned char si_present;\n\tunsigned char si_intvect;\n\tunsigned char si_id;\n\tunsigned char si_lun;\n\tu16 si_fw_revision;\n\tu16 si_per_targ_init_sync;\n\tu16 si_per_targ_fast_nego;\n\tu16 si_per_targ_ultra_nego;\n\tu16 si_per_targ_no_disc;\n\tu16 si_per_targ_wide_nego;\n\tu16 si_mflags;\n\tunsigned char si_card_family;\n\tunsigned char si_bustype;\n\tunsigned char si_card_model[3];\n\tunsigned char si_relative_cardnum;\n\tunsigned char si_reserved[4];\n\tu32 si_OS_reserved;\n\tunsigned char si_XlatInfo[4];\n\tu32 si_reserved2[5];\n\tu32 si_secondary_range;\n};\n\n#define SCSI_PARITY_ENA\t\t  0x0001\n#define LOW_BYTE_TERM\t\t  0x0010\n#define HIGH_BYTE_TERM\t\t  0x0020\n#define BUSTYPE_PCI\t  0x3\n\n#define SUPPORT_16TAR_32LUN\t  0x0002\n#define SOFT_RESET\t\t  0x0004\n#define EXTENDED_TRANSLATION\t  0x0008\n#define POST_ALL_UNDERRRUNS\t  0x0040\n#define FLAG_SCAM_ENABLED\t  0x0080\n#define FLAG_SCAM_LEVEL2\t  0x0100\n\n#define HARPOON_FAMILY        0x02\n\n \n\n \nstruct sccb {\n\tunsigned char OperationCode;\n\tunsigned char ControlByte;\n\tunsigned char CdbLength;\n\tunsigned char RequestSenseLength;\n\tu32 DataLength;\n\tvoid *DataPointer;\n\tunsigned char CcbRes[2];\n\tunsigned char HostStatus;\n\tunsigned char TargetStatus;\n\tunsigned char TargID;\n\tunsigned char Lun;\n\tunsigned char Cdb[12];\n\tunsigned char CcbRes1;\n\tunsigned char Reserved1;\n\tu32 Reserved2;\n\tu32 SensePointer;\n\n\tCALL_BK_FN SccbCallback;\t \n\tu32 SccbIOPort;\t\t\t \n\tunsigned char SccbStatus;\n\tunsigned char SCCBRes2;\n\tu16 SccbOSFlags;\n\n\tu32 Sccb_XferCnt;\t \n\tu32 Sccb_ATC;\n\tu32 SccbVirtDataPtr;\t \n\tu32 Sccb_res1;\n\tu16 Sccb_MGRFlags;\n\tu16 Sccb_sgseg;\n\tunsigned char Sccb_scsimsg;\t \n\tunsigned char Sccb_tag;\n\tunsigned char Sccb_scsistat;\n\tunsigned char Sccb_idmsg;\t \n\tstruct sccb *Sccb_forwardlink;\n\tstruct sccb *Sccb_backlink;\n\tu32 Sccb_savedATC;\n\tunsigned char Save_Cdb[6];\n\tunsigned char Save_CdbLen;\n\tunsigned char Sccb_XferState;\n\tu32 Sccb_SGoffset;\n};\n\n#pragma pack()\n\n#define SCATTER_GATHER_COMMAND    0x02\n#define RESIDUAL_COMMAND          0x03\n#define RESIDUAL_SG_COMMAND       0x04\n#define RESET_COMMAND             0x81\n\n#define F_USE_CMD_Q              0x20\t \n#define TAG_TYPE_MASK            0xC0\t \n#define SCCB_DATA_XFER_OUT       0x10\t \n#define SCCB_DATA_XFER_IN        0x08\t \n\n#define NO_AUTO_REQUEST_SENSE    0x01\t \n\n#define BUS_FREE_ST     0\n#define SELECT_ST       1\n#define SELECT_BDR_ST   2\t \n#define SELECT_SN_ST    3\t \n#define SELECT_WN_ST    4\t \n#define SELECT_Q_ST     5\t \n#define COMMAND_ST      6\n#define DATA_OUT_ST     7\n#define DATA_IN_ST      8\n#define DISCONNECT_ST   9\n#define ABORT_ST        11\n\n#define F_HOST_XFER_DIR                0x01\n#define F_ALL_XFERRED                  0x02\n#define F_SG_XFER                      0x04\n#define F_AUTO_SENSE                   0x08\n#define F_ODD_BALL_CNT                 0x10\n#define F_NO_DATA_YET                  0x80\n\n#define F_STATUSLOADED                 0x01\n#define F_DEV_SELECTED                 0x04\n\n#define SCCB_COMPLETE               0x00\t \n#define SCCB_DATA_UNDER_RUN         0x0C\n#define SCCB_SELECTION_TIMEOUT      0x11\t \n#define SCCB_DATA_OVER_RUN          0x12\n#define SCCB_PHASE_SEQUENCE_FAIL    0x14\t \n\n#define SCCB_GROSS_FW_ERR           0x27\t \n#define SCCB_BM_ERR                 0x30\t \n#define SCCB_PARITY_ERR             0x34\t \n\n#define SCCB_IN_PROCESS            0x00\n#define SCCB_SUCCESS               0x01\n#define SCCB_ABORT                 0x02\n#define SCCB_ERROR                 0x04\n\n#define  ORION_FW_REV      3110\n\n#define QUEUE_DEPTH     254+1\t \n\n#define\tMAX_MB_CARDS\t4\t \n\n#define MAX_SCSI_TAR    16\n#define MAX_LUN         32\n#define LUN_MASK\t\t\t0x1f\n\n#define SG_BUF_CNT      16\t \n\n#define SG_ELEMENT_SIZE 8\t \n\n#define RD_HARPOON(ioport)          inb((u32)ioport)\n#define RDW_HARPOON(ioport)         inw((u32)ioport)\n#define RD_HARP32(ioport,offset,data) (data = inl((u32)(ioport + offset)))\n#define WR_HARPOON(ioport,val)      outb((u8) val, (u32)ioport)\n#define WRW_HARPOON(ioport,val)       outw((u16)val, (u32)ioport)\n#define WR_HARP32(ioport,offset,data)  outl(data, (u32)(ioport + offset))\n\n#define  TAR_SYNC_MASK     (BIT(7)+BIT(6))\n#define  SYNC_TRYING               BIT(6)\n#define  SYNC_SUPPORTED    (BIT(7)+BIT(6))\n\n#define  TAR_WIDE_MASK     (BIT(5)+BIT(4))\n#define  WIDE_ENABLED              BIT(4)\n#define  WIDE_NEGOCIATED   BIT(5)\n\n#define  TAR_TAG_Q_MASK    (BIT(3)+BIT(2))\n#define  TAG_Q_TRYING              BIT(2)\n#define  TAG_Q_REJECT      BIT(3)\n\n#define  TAR_ALLOW_DISC    BIT(0)\n\n#define  EE_SYNC_MASK      (BIT(0)+BIT(1))\n#define  EE_SYNC_5MB       BIT(0)\n#define  EE_SYNC_10MB      BIT(1)\n#define  EE_SYNC_20MB      (BIT(0)+BIT(1))\n\n#define  EE_WIDE_SCSI      BIT(7)\n\nstruct sccb_mgr_tar_info {\n\n\tstruct sccb *TarSelQ_Head;\n\tstruct sccb *TarSelQ_Tail;\n\tunsigned char TarLUN_CA;\t \n\tunsigned char TarTagQ_Cnt;\n\tunsigned char TarSelQ_Cnt;\n\tunsigned char TarStatus;\n\tunsigned char TarEEValue;\n\tunsigned char TarSyncCtrl;\n\tunsigned char TarReserved[2];\t \n\tunsigned char LunDiscQ_Idx[MAX_LUN];\n\tunsigned char TarLUNBusy[MAX_LUN];\n};\n\nstruct nvram_info {\n\tunsigned char niModel;\t\t \n\tunsigned char niCardNo;\t\t \n\tu32 niBaseAddr;\t\t\t \n\tunsigned char niSysConf;\t \n\tunsigned char niScsiConf;\t \n\tunsigned char niScamConf;\t \n\tunsigned char niAdapId;\t\t \n\tunsigned char niSyncTbl[MAX_SCSI_TAR / 2];\t \n\tunsigned char niScamTbl[MAX_SCSI_TAR][4];\t \n};\n\n#define\tMODEL_LT\t\t1\n#define\tMODEL_DL\t\t2\n#define\tMODEL_LW\t\t3\n#define\tMODEL_DW\t\t4\n\nstruct sccb_card {\n\tstruct sccb *currentSCCB;\n\tstruct sccb_mgr_info *cardInfo;\n\n\tu32 ioPort;\n\n\tunsigned short cmdCounter;\n\tunsigned char discQCount;\n\tunsigned char tagQ_Lst;\n\tunsigned char cardIndex;\n\tunsigned char scanIndex;\n\tunsigned char globalFlags;\n\tunsigned char ourId;\n\tstruct nvram_info *pNvRamInfo;\n\tstruct sccb *discQ_Tbl[QUEUE_DEPTH];\n\n};\n\n#define F_TAG_STARTED\t\t0x01\n#define F_CONLUN_IO\t\t\t0x02\n#define F_DO_RENEGO\t\t\t0x04\n#define F_NO_FILTER\t\t\t0x08\n#define F_GREEN_PC\t\t\t0x10\n#define F_HOST_XFER_ACT\t\t0x20\n#define F_NEW_SCCB_CMD\t\t0x40\n#define F_UPDATE_EEPROM\t\t0x80\n\n#define  ID_STRING_LENGTH  32\n#define  TYPE_CODE0        0x63\t \n\n#define  SLV_TYPE_CODE0    0xA3\t \n\n#define  ASSIGN_ID   0x00\n#define  SET_P_FLAG  0x01\n#define  CFG_CMPLT   0x03\n#define  DOM_MSTR    0x0F\n#define  SYNC_PTRN   0x1F\n\n#define  ID_0_7      0x18\n#define  ID_8_F      0x11\n#define  MISC_CODE   0x14\n#define  CLR_P_FLAG  0x18\n\n#define  INIT_SELTD  0x01\n#define  LEVEL2_TAR  0x02\n\nenum scam_id_st { ID0, ID1, ID2, ID3, ID4, ID5, ID6, ID7, ID8, ID9, ID10, ID11,\n\t    ID12,\n\tID13, ID14, ID15, ID_UNUSED, ID_UNASSIGNED, ID_ASSIGNED, LEGACY,\n\tCLR_PRIORITY, NO_ID_AVAIL\n};\n\ntypedef struct SCCBscam_info {\n\n\tunsigned char id_string[ID_STRING_LENGTH];\n\tenum scam_id_st state;\n\n} SCCBSCAM_INFO;\n\n\n#define  SMIDENT                 0x80\n#define  DISC_PRIV               0x40\n\n#define  SM8BIT                  0x00\n#define  SM16BIT                 0x01\n\n#define  SIX_BYTE_CMD            0x06\n#define  TWELVE_BYTE_CMD         0x0C\n\n#define  ASYNC                   0x00\n#define  MAX_OFFSET              0x0F\t \n\n#define  EEPROM_WD_CNT     256\n\n#define  EEPROM_CHECK_SUM  0\n#define  FW_SIGNATURE      2\n#define  MODEL_NUMB_0      4\n#define  MODEL_NUMB_2      6\n#define  MODEL_NUMB_4      8\n#define  SYSTEM_CONFIG     16\n#define  SCSI_CONFIG       17\n#define  BIOS_CONFIG       18\n#define  SCAM_CONFIG       20\n#define  ADAPTER_SCSI_ID   24\n\n#define  IGNORE_B_SCAN     32\n#define  SEND_START_ENA    34\n#define  DEVICE_ENABLE     36\n\n#define  SYNC_RATE_TBL     38\n#define  SYNC_RATE_TBL01   38\n#define  SYNC_RATE_TBL23   40\n#define  SYNC_RATE_TBL45   42\n#define  SYNC_RATE_TBL67   44\n#define  SYNC_RATE_TBL89   46\n#define  SYNC_RATE_TBLab   48\n#define  SYNC_RATE_TBLcd   50\n#define  SYNC_RATE_TBLef   52\n\n#define  EE_SCAMBASE      256\n\n#define  SCAM_ENABLED   BIT(2)\n#define  SCAM_LEVEL2    BIT(3)\n\n#define\tRENEGO_ENA\t\tBIT(10)\n#define\tCONNIO_ENA\t\tBIT(11)\n#define  GREEN_PC_ENA   BIT(12)\n\n#define  AUTO_RATE_00   00\n#define  AUTO_RATE_05   01\n#define  AUTO_RATE_10   02\n#define  AUTO_RATE_20   03\n\n#define  WIDE_NEGO_BIT     BIT(7)\n#define  DISC_ENABLE_BIT   BIT(6)\n\n#define  hp_vendor_id_0       0x00\t \n#define  ORION_VEND_0   0x4B\n\n#define  hp_vendor_id_1       0x01\t \n#define  ORION_VEND_1   0x10\n\n#define  hp_device_id_0       0x02\t \n#define  ORION_DEV_0    0x30\n\n#define  hp_device_id_1       0x03\t \n#define  ORION_DEV_1    0x81\n\n\t \n\n#define  hp_sub_device_id_0   0x06\t \n\n#define  hp_semaphore         0x0C\n#define SCCB_MGR_ACTIVE    BIT(0)\n#define TICKLE_ME          BIT(1)\n#define SCCB_MGR_PRESENT   BIT(3)\n#define BIOS_IN_USE        BIT(4)\n\n#define  hp_sys_ctrl          0x0F\n\n#define  STOP_CLK          BIT(0)\t \n#define  DRVR_RST          BIT(1)\t \n#define  HALT_MACH         BIT(3)\t \n#define  HARD_ABORT        BIT(4)\t \n\n#define  hp_host_blk_cnt      0x13\n\n#define  XFER_BLK64        0x06\t \n\n#define  BM_THRESHOLD      0x40\t \n\n#define  hp_int_mask          0x17\n\n#define  INT_CMD_COMPL     BIT(0)\t \n#define  INT_EXT_STATUS    BIT(1)\t \n\n#define  hp_xfer_cnt_lo       0x18\n#define  hp_xfer_cnt_hi       0x1A\n#define  hp_xfer_cmd          0x1B\n\n#define  XFER_HOST_DMA     0x00\t \n#define  XFER_DMA_HOST     0x01\t \n\n#define  XFER_HOST_AUTO    0x00\t \n\n#define  XFER_DMA_8BIT     0x20\t \n\n#define  DISABLE_INT       BIT(7)\t \n\n#define  HOST_WRT_CMD      ((DISABLE_INT + XFER_HOST_DMA + XFER_HOST_AUTO + XFER_DMA_8BIT))\n#define  HOST_RD_CMD       ((DISABLE_INT + XFER_DMA_HOST + XFER_HOST_AUTO + XFER_DMA_8BIT))\n\n#define  hp_host_addr_lo      0x1C\n#define  hp_host_addr_hmi     0x1E\n\n#define  hp_ee_ctrl           0x22\n\n#define  EXT_ARB_ACK       BIT(7)\n#define  SCSI_TERM_ENA_H   BIT(6)\t \n#define  SEE_MS            BIT(5)\n#define  SEE_CS            BIT(3)\n#define  SEE_CLK           BIT(2)\n#define  SEE_DO            BIT(1)\n#define  SEE_DI            BIT(0)\n\n#define  EE_READ           0x06\n#define  EE_WRITE          0x05\n#define  EWEN              0x04\n#define  EWEN_ADDR         0x03C0\n#define  EWDS              0x04\n#define  EWDS_ADDR         0x0000\n\n#define  hp_bm_ctrl           0x26\n\n#define  SCSI_TERM_ENA_L   BIT(0)\t \n#define  FLUSH_XFER_CNTR   BIT(1)\t \n#define  FORCE1_XFER       BIT(5)\t \n#define  FAST_SINGLE       BIT(6)\t \n\n#define  BMCTRL_DEFAULT    (FORCE1_XFER|FAST_SINGLE|SCSI_TERM_ENA_L)\n\n#define  hp_sg_addr           0x28\n#define  hp_page_ctrl         0x29\n\n#define  SCATTER_EN        BIT(0)\n#define  SGRAM_ARAM        BIT(1)\n#define  G_INT_DISABLE     BIT(3)\t \n#define  NARROW_SCSI_CARD  BIT(4)\t \n\n#define  hp_pci_stat_cfg      0x2D\n\n#define  REC_MASTER_ABORT  BIT(5)\t \n\n#define  hp_rev_num           0x33\n\n#define  hp_stack_data        0x34\n#define  hp_stack_addr        0x35\n\n#define  hp_ext_status        0x36\n\n#define  BM_FORCE_OFF      BIT(0)\t \n#define  PCI_TGT_ABORT     BIT(0)\t \n#define  PCI_DEV_TMOUT     BIT(1)\t \n#define  CMD_ABORTED       BIT(4)\t \n#define  BM_PARITY_ERR     BIT(5)\t \n#define  PIO_OVERRUN       BIT(6)\t \n#define  BM_CMD_BUSY       BIT(7)\t \n#define  BAD_EXT_STATUS    (BM_FORCE_OFF | PCI_DEV_TMOUT | CMD_ABORTED | \\\n                                  BM_PARITY_ERR | PIO_OVERRUN)\n\n#define  hp_int_status        0x37\n\n#define  EXT_STATUS_ON     BIT(1)\t \n#define  SCSI_INTERRUPT    BIT(2)\t \n#define  INT_ASSERTED      BIT(5)\t \n\n#define  hp_fifo_cnt          0x38\n\n#define  hp_intena\t\t 0x40\n\n#define  RESET\t\t BIT(7)\n#define  PROG_HLT\t\t BIT(6)\n#define  PARITY\t\t BIT(5)\n#define  FIFO\t\t BIT(4)\n#define  SEL\t\t BIT(3)\n#define  SCAM_SEL\t\t BIT(2)\n#define  RSEL\t\t BIT(1)\n#define  TIMEOUT\t\t BIT(0)\n#define  BUS_FREE\t\t BIT(15)\n#define  XFER_CNT_0\t BIT(14)\n#define  PHASE\t\t BIT(13)\n#define  IUNKWN\t\t BIT(12)\n#define  ICMD_COMP\t BIT(11)\n#define  ITICKLE\t\t BIT(10)\n#define  IDO_STRT\t\t BIT(9)\n#define  ITAR_DISC\t BIT(8)\n#define  AUTO_INT\t\t (BIT(12)+BIT(11)+BIT(10)+BIT(9)+BIT(8))\n#define  CLR_ALL_INT\t 0xFFFF\n#define  CLR_ALL_INT_1\t 0xFF00\n\n#define  hp_intstat\t\t 0x42\n\n#define  hp_scsisig           0x44\n\n#define  SCSI_SEL          BIT(7)\n#define  SCSI_BSY          BIT(6)\n#define  SCSI_REQ          BIT(5)\n#define  SCSI_ACK          BIT(4)\n#define  SCSI_ATN          BIT(3)\n#define  SCSI_CD           BIT(2)\n#define  SCSI_MSG          BIT(1)\n#define  SCSI_IOBIT        BIT(0)\n\n#define  S_SCSI_PHZ        (BIT(2)+BIT(1)+BIT(0))\n#define  S_MSGO_PH         (BIT(2)+BIT(1)       )\n#define  S_MSGI_PH         (BIT(2)+BIT(1)+BIT(0))\n#define  S_DATAI_PH        (              BIT(0))\n#define  S_DATAO_PH        0x00\n#define  S_ILL_PH          (       BIT(1)       )\n\n#define  hp_scsictrl_0        0x45\n\n#define  SEL_TAR           BIT(6)\n#define  ENA_ATN           BIT(4)\n#define  ENA_RESEL         BIT(2)\n#define  SCSI_RST          BIT(1)\n#define  ENA_SCAM_SEL      BIT(0)\n\n#define  hp_portctrl_0        0x46\n\n#define  SCSI_PORT         BIT(7)\n#define  SCSI_INBIT        BIT(6)\n#define  DMA_PORT          BIT(5)\n#define  DMA_RD            BIT(4)\n#define  HOST_PORT         BIT(3)\n#define  HOST_WRT          BIT(2)\n#define  SCSI_BUS_EN       BIT(1)\n#define  START_TO          BIT(0)\n\n#define  hp_scsireset         0x47\n\n#define  SCSI_INI          BIT(6)\n#define  SCAM_EN           BIT(5)\n#define  DMA_RESET         BIT(3)\n#define  HPSCSI_RESET      BIT(2)\n#define  PROG_RESET        BIT(1)\n#define  FIFO_CLR          BIT(0)\n\n#define  hp_xfercnt_0         0x48\n#define  hp_xfercnt_2         0x4A\n\n#define  hp_fifodata_0        0x4C\n#define  hp_addstat           0x4E\n\n#define  SCAM_TIMER        BIT(7)\n#define  SCSI_MODE8        BIT(3)\n#define  SCSI_PAR_ERR      BIT(0)\n\n#define  hp_prgmcnt_0         0x4F\n\n#define  hp_selfid_0          0x50\n#define  hp_selfid_1          0x51\n#define  hp_arb_id            0x52\n\n#define  hp_select_id         0x53\n\n#define  hp_synctarg_base     0x54\n#define  hp_synctarg_12       0x54\n#define  hp_synctarg_13       0x55\n#define  hp_synctarg_14       0x56\n#define  hp_synctarg_15       0x57\n\n#define  hp_synctarg_8        0x58\n#define  hp_synctarg_9        0x59\n#define  hp_synctarg_10       0x5A\n#define  hp_synctarg_11       0x5B\n\n#define  hp_synctarg_4        0x5C\n#define  hp_synctarg_5        0x5D\n#define  hp_synctarg_6        0x5E\n#define  hp_synctarg_7        0x5F\n\n#define  hp_synctarg_0        0x60\n#define  hp_synctarg_1        0x61\n#define  hp_synctarg_2        0x62\n#define  hp_synctarg_3        0x63\n\n#define  NARROW_SCSI       BIT(4)\n#define  DEFAULT_OFFSET    0x0F\n\n#define  hp_autostart_0       0x64\n#define  hp_autostart_1       0x65\n#define  hp_autostart_3       0x67\n\n#define  AUTO_IMMED    BIT(5)\n#define  SELECT   BIT(6)\n#define  END_DATA (BIT(7)+BIT(6))\n\n#define  hp_gp_reg_0          0x68\n#define  hp_gp_reg_1          0x69\n#define  hp_gp_reg_3          0x6B\n\n#define  hp_seltimeout        0x6C\n\n#define  TO_4ms            0x67\t \n\n#define  TO_5ms            0x03\t \n#define  TO_10ms           0x07\t \n#define  TO_250ms          0x99\t \n#define  TO_290ms          0xB1\t \n\n#define  hp_clkctrl_0         0x6D\n\n#define  PWR_DWN           BIT(6)\n#define  ACTdeassert       BIT(4)\n#define  CLK_40MHZ         (BIT(1) + BIT(0))\n\n#define  CLKCTRL_DEFAULT   (ACTdeassert | CLK_40MHZ)\n\n#define  hp_fiforead          0x6E\n#define  hp_fifowrite         0x6F\n\n#define  hp_offsetctr         0x70\n#define  hp_xferstat          0x71\n\n#define  FIFO_EMPTY        BIT(6)\n\n#define  hp_portctrl_1        0x72\n\n#define  CHK_SCSI_P        BIT(3)\n#define  HOST_MODE8        BIT(0)\n\n#define  hp_xfer_pad          0x73\n\n#define  ID_UNLOCK         BIT(3)\n\n#define  hp_scsidata_0        0x74\n#define  hp_scsidata_1        0x75\n\n#define  hp_aramBase          0x80\n#define  BIOS_DATA_OFFSET     0x60\n#define  BIOS_RELATIVE_CARD   0x64\n\n#define  AR3      (BIT(9) + BIT(8))\n#define  SDATA    BIT(10)\n\n#define  CRD_OP   BIT(11)\t \n\n#define  CRR_OP   BIT(12)\t \n\n#define  CPE_OP   (BIT(14)+BIT(11))\t \n\n#define  CPN_OP   (BIT(14)+BIT(12))\t \n\n#define  ADATA_OUT   0x00\n#define  ADATA_IN    BIT(8)\n#define  ACOMMAND    BIT(10)\n#define  ASTATUS     (BIT(10)+BIT(8))\n#define  AMSG_OUT    (BIT(10)+BIT(9))\n#define  AMSG_IN     (BIT(10)+BIT(9)+BIT(8))\n\n#define  BRH_OP   BIT(13)\t \n\n#define  ALWAYS   0x00\n#define  EQUAL    BIT(8)\n#define  NOT_EQ   BIT(9)\n\n#define  TCB_OP   (BIT(13)+BIT(11))\t \n\n#define  FIFO_0      BIT(10)\n\n#define  MPM_OP   BIT(15)\t \n\n#define  MRR_OP   BIT(14)\t \n\n#define  S_IDREG  (BIT(2)+BIT(1)+BIT(0))\n\n#define  D_AR0    0x00\n#define  D_AR1    BIT(0)\n#define  D_BUCKET (BIT(2) + BIT(1) + BIT(0))\n\n#define  RAT_OP      (BIT(14)+BIT(13)+BIT(11))\n\n#define  SSI_OP      (BIT(15)+BIT(11))\n\n#define  SSI_ITAR_DISC\t(ITAR_DISC >> 8)\n#define  SSI_IDO_STRT\t(IDO_STRT >> 8)\n\n#define  SSI_ICMD_COMP\t(ICMD_COMP >> 8)\n#define  SSI_ITICKLE\t(ITICKLE >> 8)\n\n#define  SSI_IUNKWN\t(IUNKWN >> 8)\n#define  SSI_INO_CC\t(IUNKWN >> 8)\n#define  SSI_IRFAIL\t(IUNKWN >> 8)\n\n#define  NP    0x10\t\t \n#define  NTCMD 0x02\t\t \n#define  CMDPZ 0x04\t\t \n#define  DINT  0x12\t\t \n#define  DI    0x13\t\t \n#define  DC    0x19\t\t \n#define  ST    0x1D\t\t \n#define  UNKNWN 0x24\t\t \n#define  CC    0x25\t\t \n#define  TICK  0x26\t\t \n#define  SELCHK 0x28\t\t \n\n#define  ID_MSG_STRT    hp_aramBase + 0x00\n#define  NON_TAG_ID_MSG hp_aramBase + 0x06\n#define  CMD_STRT       hp_aramBase + 0x08\n#define  SYNC_MSGS      hp_aramBase + 0x08\n\n#define  TAG_STRT          0x00\n#define  DISCONNECT_START  0x10/2\n#define  END_DATA_START    0x14/2\n#define  CMD_ONLY_STRT     CMDPZ/2\n#define  SELCHK_STRT     SELCHK/2\n\n#define GET_XFER_CNT(port, xfercnt) {RD_HARP32(port,hp_xfercnt_0,xfercnt); xfercnt &= 0xFFFFFF;}\n \n#define HP_SETUP_ADDR_CNT(port,addr,count) (WRW_HARPOON((port+hp_host_addr_lo), (unsigned short)(addr & 0x0000FFFFL)),\\\n         addr >>= 16,\\\n         WRW_HARPOON((port+hp_host_addr_hmi), (unsigned short)(addr & 0x0000FFFFL)),\\\n         WR_HARP32(port,hp_xfercnt_0,count),\\\n         WRW_HARPOON((port+hp_xfer_cnt_lo), (unsigned short)(count & 0x0000FFFFL)),\\\n         count >>= 16,\\\n         WR_HARPOON(port+hp_xfer_cnt_hi, (count & 0xFF)))\n\n#define ACCEPT_MSG(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\\\n                          WR_HARPOON(port+hp_scsisig, S_ILL_PH);}\n\n#define ACCEPT_MSG_ATN(port) {while(RD_HARPOON(port+hp_scsisig) & SCSI_REQ){}\\\n                          WR_HARPOON(port+hp_scsisig, (S_ILL_PH|SCSI_ATN));}\n\n#define DISABLE_AUTO(port) (WR_HARPOON(port+hp_scsireset, PROG_RESET),\\\n                        WR_HARPOON(port+hp_scsireset, 0x00))\n\n#define ARAM_ACCESS(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \\\n                             (RD_HARPOON(p_port+hp_page_ctrl) | SGRAM_ARAM)))\n\n#define SGRAM_ACCESS(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \\\n                             (RD_HARPOON(p_port+hp_page_ctrl) & ~SGRAM_ARAM)))\n\n#define MDISABLE_INT(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \\\n                             (RD_HARPOON(p_port+hp_page_ctrl) | G_INT_DISABLE)))\n\n#define MENABLE_INT(p_port) (WR_HARPOON(p_port+hp_page_ctrl, \\\n                             (RD_HARPOON(p_port+hp_page_ctrl) & ~G_INT_DISABLE)))\n\nstatic unsigned char FPT_sisyncn(u32 port, unsigned char p_card,\n\t\t\t\t unsigned char syncFlag);\nstatic void FPT_ssel(u32 port, unsigned char p_card);\nstatic void FPT_sres(u32 port, unsigned char p_card,\n\t\t     struct sccb_card *pCurrCard);\nstatic void FPT_shandem(u32 port, unsigned char p_card,\n\t\t\tstruct sccb *pCurrSCCB);\nstatic void FPT_stsyncn(u32 port, unsigned char p_card);\nstatic void FPT_sisyncr(u32 port, unsigned char sync_pulse,\n\t\t\tunsigned char offset);\nstatic void FPT_sssyncv(u32 p_port, unsigned char p_id,\n\t\t\tunsigned char p_sync_value,\n\t\t\tstruct sccb_mgr_tar_info *currTar_Info);\nstatic void FPT_sresb(u32 port, unsigned char p_card);\nstatic void FPT_sxfrp(u32 p_port, unsigned char p_card);\nstatic void FPT_schkdd(u32 port, unsigned char p_card);\nstatic unsigned char FPT_RdStack(u32 port, unsigned char index);\nstatic void FPT_WrStack(u32 portBase, unsigned char index,\n\t\t\tunsigned char data);\nstatic unsigned char FPT_ChkIfChipInitialized(u32 ioPort);\n\nstatic void FPT_SendMsg(u32 port, unsigned char message);\nstatic void FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,\n\t\t\t\t   unsigned char error_code);\n\nstatic void FPT_sinits(struct sccb *p_sccb, unsigned char p_card);\nstatic void FPT_RNVRamData(struct nvram_info *pNvRamInfo);\n\nstatic unsigned char FPT_siwidn(u32 port, unsigned char p_card);\nstatic void FPT_stwidn(u32 port, unsigned char p_card);\nstatic void FPT_siwidr(u32 port, unsigned char width);\n\nstatic void FPT_queueSelectFail(struct sccb_card *pCurrCard,\n\t\t\t\tunsigned char p_card);\nstatic void FPT_queueDisconnect(struct sccb *p_SCCB, unsigned char p_card);\nstatic void FPT_queueCmdComplete(struct sccb_card *pCurrCard,\n\t\t\t\t struct sccb *p_SCCB, unsigned char p_card);\nstatic void FPT_queueSearchSelect(struct sccb_card *pCurrCard,\n\t\t\t\t  unsigned char p_card);\nstatic void FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code);\nstatic void FPT_queueAddSccb(struct sccb *p_SCCB, unsigned char card);\nstatic unsigned char FPT_queueFindSccb(struct sccb *p_SCCB,\n\t\t\t\t       unsigned char p_card);\nstatic void FPT_utilUpdateResidual(struct sccb *p_SCCB);\nstatic unsigned short FPT_CalcCrc16(unsigned char buffer[]);\nstatic unsigned char FPT_CalcLrc(unsigned char buffer[]);\n\nstatic void FPT_Wait1Second(u32 p_port);\nstatic void FPT_Wait(u32 p_port, unsigned char p_delay);\nstatic void FPT_utilEEWriteOnOff(u32 p_port, unsigned char p_mode);\nstatic void FPT_utilEEWrite(u32 p_port, unsigned short ee_data,\n\t\t\t    unsigned short ee_addr);\nstatic unsigned short FPT_utilEERead(u32 p_port,\n\t\t\t\t     unsigned short ee_addr);\nstatic unsigned short FPT_utilEEReadOrg(u32 p_port,\n\t\t\t\t\tunsigned short ee_addr);\nstatic void FPT_utilEESendCmdAddr(u32 p_port, unsigned char ee_cmd,\n\t\t\t\t  unsigned short ee_addr);\n\nstatic void FPT_phaseDataOut(u32 port, unsigned char p_card);\nstatic void FPT_phaseDataIn(u32 port, unsigned char p_card);\nstatic void FPT_phaseCommand(u32 port, unsigned char p_card);\nstatic void FPT_phaseStatus(u32 port, unsigned char p_card);\nstatic void FPT_phaseMsgOut(u32 port, unsigned char p_card);\nstatic void FPT_phaseMsgIn(u32 port, unsigned char p_card);\nstatic void FPT_phaseIllegal(u32 port, unsigned char p_card);\n\nstatic void FPT_phaseDecode(u32 port, unsigned char p_card);\nstatic void FPT_phaseChkFifo(u32 port, unsigned char p_card);\nstatic void FPT_phaseBusFree(u32 p_port, unsigned char p_card);\n\nstatic void FPT_XbowInit(u32 port, unsigned char scamFlg);\nstatic void FPT_BusMasterInit(u32 p_port);\nstatic void FPT_DiagEEPROM(u32 p_port);\n\nstatic void FPT_dataXferProcessor(u32 port,\n\t\t\t\t  struct sccb_card *pCurrCard);\nstatic void FPT_busMstrSGDataXferStart(u32 port,\n\t\t\t\t       struct sccb *pCurrSCCB);\nstatic void FPT_busMstrDataXferStart(u32 port,\n\t\t\t\t     struct sccb *pCurrSCCB);\nstatic void FPT_hostDataXferAbort(u32 port, unsigned char p_card,\n\t\t\t\t  struct sccb *pCurrSCCB);\nstatic void FPT_hostDataXferRestart(struct sccb *currSCCB);\n\nstatic unsigned char FPT_SccbMgr_bad_isr(u32 p_port,\n\t\t\t\t\t unsigned char p_card,\n\t\t\t\t\t struct sccb_card *pCurrCard,\n\t\t\t\t\t unsigned short p_int);\n\nstatic void FPT_SccbMgrTableInitAll(void);\nstatic void FPT_SccbMgrTableInitCard(struct sccb_card *pCurrCard,\n\t\t\t\t     unsigned char p_card);\nstatic void FPT_SccbMgrTableInitTarget(unsigned char p_card,\n\t\t\t\t       unsigned char target);\n\nstatic void FPT_scini(unsigned char p_card, unsigned char p_our_id,\n\t\t      unsigned char p_power_up);\n\nstatic int FPT_scarb(u32 p_port, unsigned char p_sel_type);\nstatic void FPT_scbusf(u32 p_port);\nstatic void FPT_scsel(u32 p_port);\nstatic void FPT_scasid(unsigned char p_card, u32 p_port);\nstatic unsigned char FPT_scxferc(u32 p_port, unsigned char p_data);\nstatic unsigned char FPT_scsendi(u32 p_port,\n\t\t\t\t unsigned char p_id_string[]);\nstatic unsigned char FPT_sciso(u32 p_port,\n\t\t\t       unsigned char p_id_string[]);\nstatic void FPT_scwirod(u32 p_port, unsigned char p_data_bit);\nstatic void FPT_scwiros(u32 p_port, unsigned char p_data_bit);\nstatic unsigned char FPT_scvalq(unsigned char p_quintet);\nstatic unsigned char FPT_scsell(u32 p_port, unsigned char targ_id);\nstatic void FPT_scwtsel(u32 p_port);\nstatic void FPT_inisci(unsigned char p_card, u32 p_port,\n\t\t       unsigned char p_our_id);\nstatic void FPT_scsavdi(unsigned char p_card, u32 p_port);\nstatic unsigned char FPT_scmachid(unsigned char p_card,\n\t\t\t\t  unsigned char p_id_string[]);\n\nstatic void FPT_autoCmdCmplt(u32 p_port, unsigned char p_card);\nstatic void FPT_autoLoadDefaultMap(u32 p_port);\n\nstatic struct sccb_mgr_tar_info FPT_sccbMgrTbl[MAX_CARDS][MAX_SCSI_TAR] =\n    { {{0}} };\nstatic struct sccb_card FPT_BL_Card[MAX_CARDS] = { {0} };\nstatic SCCBSCAM_INFO FPT_scamInfo[MAX_SCSI_TAR] = { {{0}} };\nstatic struct nvram_info FPT_nvRamInfo[MAX_MB_CARDS] = { {0} };\n\nstatic unsigned char FPT_mbCards = 0;\nstatic unsigned char FPT_scamHAString[] =\n    { 0x63, 0x07, 'B', 'U', 'S', 'L', 'O', 'G', 'I', 'C',\n\t' ', 'B', 'T', '-', '9', '3', '0',\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,\n\t0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20\n};\n\nstatic unsigned short FPT_default_intena = 0;\n\nstatic void (*FPT_s_PhaseTbl[8]) (u32, unsigned char) = {\n0};\n\n \n\nstatic int FlashPoint_ProbeHostAdapter(struct sccb_mgr_info *pCardInfo)\n{\n\tstatic unsigned char first_time = 1;\n\n\tunsigned char i, j, id, ScamFlg;\n\tunsigned short temp, temp2, temp3, temp4, temp5, temp6;\n\tu32 ioport;\n\tstruct nvram_info *pCurrNvRam;\n\n\tioport = pCardInfo->si_baseaddr;\n\n\tif (RD_HARPOON(ioport + hp_vendor_id_0) != ORION_VEND_0)\n\t\treturn (int)FAILURE;\n\n\tif ((RD_HARPOON(ioport + hp_vendor_id_1) != ORION_VEND_1))\n\t\treturn (int)FAILURE;\n\n\tif ((RD_HARPOON(ioport + hp_device_id_0) != ORION_DEV_0))\n\t\treturn (int)FAILURE;\n\n\tif ((RD_HARPOON(ioport + hp_device_id_1) != ORION_DEV_1))\n\t\treturn (int)FAILURE;\n\n\tif (RD_HARPOON(ioport + hp_rev_num) != 0x0f) {\n\n \n\n\t\tif (RD_HARPOON(ioport + hp_sub_device_id_0) & 0x0f)\n\t\t\treturn (int)FAILURE;\n\t}\n\n\tif (first_time) {\n\t\tFPT_SccbMgrTableInitAll();\n\t\tfirst_time = 0;\n\t\tFPT_mbCards = 0;\n\t}\n\n\tif (FPT_RdStack(ioport, 0) != 0x00) {\n\t\tif (FPT_ChkIfChipInitialized(ioport) == 0) {\n\t\t\tpCurrNvRam = NULL;\n\t\t\tWR_HARPOON(ioport + hp_semaphore, 0x00);\n\t\t\tFPT_XbowInit(ioport, 0);\t \n\t\t\tFPT_DiagEEPROM(ioport);\n\t\t} else {\n\t\t\tif (FPT_mbCards < MAX_MB_CARDS) {\n\t\t\t\tpCurrNvRam = &FPT_nvRamInfo[FPT_mbCards];\n\t\t\t\tFPT_mbCards++;\n\t\t\t\tpCurrNvRam->niBaseAddr = ioport;\n\t\t\t\tFPT_RNVRamData(pCurrNvRam);\n\t\t\t} else\n\t\t\t\treturn (int)FAILURE;\n\t\t}\n\t} else\n\t\tpCurrNvRam = NULL;\n\n\tWR_HARPOON(ioport + hp_clkctrl_0, CLKCTRL_DEFAULT);\n\tWR_HARPOON(ioport + hp_sys_ctrl, 0x00);\n\n\tif (pCurrNvRam)\n\t\tpCardInfo->si_id = pCurrNvRam->niAdapId;\n\telse\n\t\tpCardInfo->si_id =\n\t\t    (unsigned\n\t\t     char)(FPT_utilEERead(ioport,\n\t\t\t\t\t  (ADAPTER_SCSI_ID /\n\t\t\t\t\t   2)) & (unsigned char)0x0FF);\n\n\tpCardInfo->si_lun = 0x00;\n\tpCardInfo->si_fw_revision = ORION_FW_REV;\n\ttemp2 = 0x0000;\n\ttemp3 = 0x0000;\n\ttemp4 = 0x0000;\n\ttemp5 = 0x0000;\n\ttemp6 = 0x0000;\n\n\tfor (id = 0; id < (16 / 2); id++) {\n\n\t\tif (pCurrNvRam) {\n\t\t\ttemp = (unsigned short)pCurrNvRam->niSyncTbl[id];\n\t\t\ttemp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +\n\t\t\t    (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));\n\t\t} else\n\t\t\ttemp =\n\t\t\t    FPT_utilEERead(ioport,\n\t\t\t\t\t   (unsigned short)((SYNC_RATE_TBL / 2)\n\t\t\t\t\t\t\t    + id));\n\n\t\tfor (i = 0; i < 2; temp >>= 8, i++) {\n\n\t\t\ttemp2 >>= 1;\n\t\t\ttemp3 >>= 1;\n\t\t\ttemp4 >>= 1;\n\t\t\ttemp5 >>= 1;\n\t\t\ttemp6 >>= 1;\n\t\t\tswitch (temp & 0x3) {\n\t\t\tcase AUTO_RATE_20:\t \n\t\t\t\ttemp6 |= 0x8000;\n\t\t\t\tfallthrough;\n\t\t\tcase AUTO_RATE_10:\t \n\t\t\t\ttemp5 |= 0x8000;\n\t\t\t\tfallthrough;\n\t\t\tcase AUTO_RATE_05:\t \n\t\t\t\ttemp2 |= 0x8000;\n\t\t\t\tfallthrough;\n\t\t\tcase AUTO_RATE_00:\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (temp & DISC_ENABLE_BIT)\n\t\t\t\ttemp3 |= 0x8000;\n\n\t\t\tif (temp & WIDE_NEGO_BIT)\n\t\t\t\ttemp4 |= 0x8000;\n\n\t\t}\n\t}\n\n\tpCardInfo->si_per_targ_init_sync = temp2;\n\tpCardInfo->si_per_targ_no_disc = temp3;\n\tpCardInfo->si_per_targ_wide_nego = temp4;\n\tpCardInfo->si_per_targ_fast_nego = temp5;\n\tpCardInfo->si_per_targ_ultra_nego = temp6;\n\n\tif (pCurrNvRam)\n\t\ti = pCurrNvRam->niSysConf;\n\telse\n\t\ti = (unsigned\n\t\t     char)(FPT_utilEERead(ioport, (SYSTEM_CONFIG / 2)));\n\n\tif (pCurrNvRam)\n\t\tScamFlg = pCurrNvRam->niScamConf;\n\telse\n\t\tScamFlg =\n\t\t    (unsigned char)FPT_utilEERead(ioport, SCAM_CONFIG / 2);\n\n\tpCardInfo->si_mflags = 0x0000;\n\n\tif (i & 0x01)\n\t\tpCardInfo->si_mflags |= SCSI_PARITY_ENA;\n\n\tif (!(i & 0x02))\n\t\tpCardInfo->si_mflags |= SOFT_RESET;\n\n\tif (i & 0x10)\n\t\tpCardInfo->si_mflags |= EXTENDED_TRANSLATION;\n\n\tif (ScamFlg & SCAM_ENABLED)\n\t\tpCardInfo->si_mflags |= FLAG_SCAM_ENABLED;\n\n\tif (ScamFlg & SCAM_LEVEL2)\n\t\tpCardInfo->si_mflags |= FLAG_SCAM_LEVEL2;\n\n\tj = (RD_HARPOON(ioport + hp_bm_ctrl) & ~SCSI_TERM_ENA_L);\n\tif (i & 0x04) {\n\t\tj |= SCSI_TERM_ENA_L;\n\t}\n\tWR_HARPOON(ioport + hp_bm_ctrl, j);\n\n\tj = (RD_HARPOON(ioport + hp_ee_ctrl) & ~SCSI_TERM_ENA_H);\n\tif (i & 0x08) {\n\t\tj |= SCSI_TERM_ENA_H;\n\t}\n\tWR_HARPOON(ioport + hp_ee_ctrl, j);\n\n\tif (!(RD_HARPOON(ioport + hp_page_ctrl) & NARROW_SCSI_CARD))\n\n\t\tpCardInfo->si_mflags |= SUPPORT_16TAR_32LUN;\n\n\tpCardInfo->si_card_family = HARPOON_FAMILY;\n\tpCardInfo->si_bustype = BUSTYPE_PCI;\n\n\tif (pCurrNvRam) {\n\t\tpCardInfo->si_card_model[0] = '9';\n\t\tswitch (pCurrNvRam->niModel & 0x0f) {\n\t\tcase MODEL_LT:\n\t\t\tpCardInfo->si_card_model[1] = '3';\n\t\t\tpCardInfo->si_card_model[2] = '0';\n\t\t\tbreak;\n\t\tcase MODEL_LW:\n\t\t\tpCardInfo->si_card_model[1] = '5';\n\t\t\tpCardInfo->si_card_model[2] = '0';\n\t\t\tbreak;\n\t\tcase MODEL_DL:\n\t\t\tpCardInfo->si_card_model[1] = '3';\n\t\t\tpCardInfo->si_card_model[2] = '2';\n\t\t\tbreak;\n\t\tcase MODEL_DW:\n\t\t\tpCardInfo->si_card_model[1] = '5';\n\t\t\tpCardInfo->si_card_model[2] = '2';\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttemp = FPT_utilEERead(ioport, (MODEL_NUMB_0 / 2));\n\t\tpCardInfo->si_card_model[0] = (unsigned char)(temp >> 8);\n\t\ttemp = FPT_utilEERead(ioport, (MODEL_NUMB_2 / 2));\n\n\t\tpCardInfo->si_card_model[1] = (unsigned char)(temp & 0x00FF);\n\t\tpCardInfo->si_card_model[2] = (unsigned char)(temp >> 8);\n\t}\n\n\tif (pCardInfo->si_card_model[1] == '3') {\n\t\tif (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))\n\t\t\tpCardInfo->si_mflags |= LOW_BYTE_TERM;\n\t} else if (pCardInfo->si_card_model[2] == '0') {\n\t\ttemp = RD_HARPOON(ioport + hp_xfer_pad);\n\t\tWR_HARPOON(ioport + hp_xfer_pad, (temp & ~BIT(4)));\n\t\tif (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))\n\t\t\tpCardInfo->si_mflags |= LOW_BYTE_TERM;\n\t\tWR_HARPOON(ioport + hp_xfer_pad, (temp | BIT(4)));\n\t\tif (RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7))\n\t\t\tpCardInfo->si_mflags |= HIGH_BYTE_TERM;\n\t\tWR_HARPOON(ioport + hp_xfer_pad, temp);\n\t} else {\n\t\ttemp = RD_HARPOON(ioport + hp_ee_ctrl);\n\t\ttemp2 = RD_HARPOON(ioport + hp_xfer_pad);\n\t\tWR_HARPOON(ioport + hp_ee_ctrl, (temp | SEE_CS));\n\t\tWR_HARPOON(ioport + hp_xfer_pad, (temp2 | BIT(4)));\n\t\ttemp3 = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\ttemp3 <<= 1;\n\t\t\tif (!(RD_HARPOON(ioport + hp_ee_ctrl) & BIT(7)))\n\t\t\t\ttemp3 |= 1;\n\t\t\tWR_HARPOON(ioport + hp_xfer_pad, (temp2 & ~BIT(4)));\n\t\t\tWR_HARPOON(ioport + hp_xfer_pad, (temp2 | BIT(4)));\n\t\t}\n\t\tWR_HARPOON(ioport + hp_ee_ctrl, temp);\n\t\tWR_HARPOON(ioport + hp_xfer_pad, temp2);\n\t\tif (!(temp3 & BIT(7)))\n\t\t\tpCardInfo->si_mflags |= LOW_BYTE_TERM;\n\t\tif (!(temp3 & BIT(6)))\n\t\t\tpCardInfo->si_mflags |= HIGH_BYTE_TERM;\n\t}\n\n\tARAM_ACCESS(ioport);\n\n\tfor (i = 0; i < 4; i++) {\n\n\t\tpCardInfo->si_XlatInfo[i] =\n\t\t    RD_HARPOON(ioport + hp_aramBase + BIOS_DATA_OFFSET + i);\n\t}\n\n\t \n\n\tpCardInfo->si_relative_cardnum =\n\t    (unsigned\n\t     char)(RD_HARPOON(ioport + hp_aramBase + BIOS_RELATIVE_CARD) - 1);\n\n\tSGRAM_ACCESS(ioport);\n\n\tFPT_s_PhaseTbl[0] = FPT_phaseDataOut;\n\tFPT_s_PhaseTbl[1] = FPT_phaseDataIn;\n\tFPT_s_PhaseTbl[2] = FPT_phaseIllegal;\n\tFPT_s_PhaseTbl[3] = FPT_phaseIllegal;\n\tFPT_s_PhaseTbl[4] = FPT_phaseCommand;\n\tFPT_s_PhaseTbl[5] = FPT_phaseStatus;\n\tFPT_s_PhaseTbl[6] = FPT_phaseMsgOut;\n\tFPT_s_PhaseTbl[7] = FPT_phaseMsgIn;\n\n\tpCardInfo->si_present = 0x01;\n\n\treturn 0;\n}\n\n \n\nstatic void *FlashPoint_HardwareResetHostAdapter(struct sccb_mgr_info\n\t\t\t\t\t\t\t *pCardInfo)\n{\n\tstruct sccb_card *CurrCard = NULL;\n\tstruct nvram_info *pCurrNvRam;\n\tunsigned char i, j, thisCard, ScamFlg;\n\tunsigned short temp, sync_bit_map, id;\n\tu32 ioport;\n\n\tioport = pCardInfo->si_baseaddr;\n\n\tfor (thisCard = 0; thisCard <= MAX_CARDS; thisCard++) {\n\n\t\tif (thisCard == MAX_CARDS)\n\t\t\treturn (void *)FAILURE;\n\n\t\tif (FPT_BL_Card[thisCard].ioPort == ioport) {\n\n\t\t\tCurrCard = &FPT_BL_Card[thisCard];\n\t\t\tFPT_SccbMgrTableInitCard(CurrCard, thisCard);\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (FPT_BL_Card[thisCard].ioPort == 0x00) {\n\n\t\t\tFPT_BL_Card[thisCard].ioPort = ioport;\n\t\t\tCurrCard = &FPT_BL_Card[thisCard];\n\n\t\t\tif (FPT_mbCards)\n\t\t\t\tfor (i = 0; i < FPT_mbCards; i++) {\n\t\t\t\t\tif (CurrCard->ioPort ==\n\t\t\t\t\t    FPT_nvRamInfo[i].niBaseAddr)\n\t\t\t\t\t\tCurrCard->pNvRamInfo =\n\t\t\t\t\t\t    &FPT_nvRamInfo[i];\n\t\t\t\t}\n\t\t\tFPT_SccbMgrTableInitCard(CurrCard, thisCard);\n\t\t\tCurrCard->cardIndex = thisCard;\n\t\t\tCurrCard->cardInfo = pCardInfo;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpCurrNvRam = CurrCard->pNvRamInfo;\n\n\tif (pCurrNvRam) {\n\t\tScamFlg = pCurrNvRam->niScamConf;\n\t} else {\n\t\tScamFlg =\n\t\t    (unsigned char)FPT_utilEERead(ioport, SCAM_CONFIG / 2);\n\t}\n\n\tFPT_BusMasterInit(ioport);\n\tFPT_XbowInit(ioport, ScamFlg);\n\n\tFPT_autoLoadDefaultMap(ioport);\n\n\tfor (i = 0, id = 0x01; i != pCardInfo->si_id; i++, id <<= 1) {\n\t}\n\n\tWR_HARPOON(ioport + hp_selfid_0, id);\n\tWR_HARPOON(ioport + hp_selfid_1, 0x00);\n\tWR_HARPOON(ioport + hp_arb_id, pCardInfo->si_id);\n\tCurrCard->ourId = pCardInfo->si_id;\n\n\ti = (unsigned char)pCardInfo->si_mflags;\n\tif (i & SCSI_PARITY_ENA)\n\t\tWR_HARPOON(ioport + hp_portctrl_1, (HOST_MODE8 | CHK_SCSI_P));\n\n\tj = (RD_HARPOON(ioport + hp_bm_ctrl) & ~SCSI_TERM_ENA_L);\n\tif (i & LOW_BYTE_TERM)\n\t\tj |= SCSI_TERM_ENA_L;\n\tWR_HARPOON(ioport + hp_bm_ctrl, j);\n\n\tj = (RD_HARPOON(ioport + hp_ee_ctrl) & ~SCSI_TERM_ENA_H);\n\tif (i & HIGH_BYTE_TERM)\n\t\tj |= SCSI_TERM_ENA_H;\n\tWR_HARPOON(ioport + hp_ee_ctrl, j);\n\n\tif (!(pCardInfo->si_mflags & SOFT_RESET)) {\n\n\t\tFPT_sresb(ioport, thisCard);\n\n\t\tFPT_scini(thisCard, pCardInfo->si_id, 0);\n\t}\n\n\tif (pCardInfo->si_mflags & POST_ALL_UNDERRRUNS)\n\t\tCurrCard->globalFlags |= F_NO_FILTER;\n\n\tif (pCurrNvRam) {\n\t\tif (pCurrNvRam->niSysConf & 0x10)\n\t\t\tCurrCard->globalFlags |= F_GREEN_PC;\n\t} else {\n\t\tif (FPT_utilEERead(ioport, (SYSTEM_CONFIG / 2)) & GREEN_PC_ENA)\n\t\t\tCurrCard->globalFlags |= F_GREEN_PC;\n\t}\n\n\t \n\tif (pCurrNvRam) {\n\t\tif (pCurrNvRam->niScsiConf & 0x04)\n\t\t\tCurrCard->globalFlags |= F_DO_RENEGO;\n\t} else {\n\t\tif (FPT_utilEERead(ioport, (SCSI_CONFIG / 2)) & RENEGO_ENA)\n\t\t\tCurrCard->globalFlags |= F_DO_RENEGO;\n\t}\n\n\tif (pCurrNvRam) {\n\t\tif (pCurrNvRam->niScsiConf & 0x08)\n\t\t\tCurrCard->globalFlags |= F_CONLUN_IO;\n\t} else {\n\t\tif (FPT_utilEERead(ioport, (SCSI_CONFIG / 2)) & CONNIO_ENA)\n\t\t\tCurrCard->globalFlags |= F_CONLUN_IO;\n\t}\n\n\ttemp = pCardInfo->si_per_targ_no_disc;\n\n\tfor (i = 0, id = 1; i < MAX_SCSI_TAR; i++, id <<= 1) {\n\n\t\tif (temp & id)\n\t\t\tFPT_sccbMgrTbl[thisCard][i].TarStatus |= TAR_ALLOW_DISC;\n\t}\n\n\tsync_bit_map = 0x0001;\n\n\tfor (id = 0; id < (MAX_SCSI_TAR / 2); id++) {\n\n\t\tif (pCurrNvRam) {\n\t\t\ttemp = (unsigned short)pCurrNvRam->niSyncTbl[id];\n\t\t\ttemp = ((temp & 0x03) + ((temp << 4) & 0xc0)) +\n\t\t\t    (((temp << 4) & 0x0300) + ((temp << 8) & 0xc000));\n\t\t} else\n\t\t\ttemp =\n\t\t\t    FPT_utilEERead(ioport,\n\t\t\t\t\t   (unsigned short)((SYNC_RATE_TBL / 2)\n\t\t\t\t\t\t\t    + id));\n\n\t\tfor (i = 0; i < 2; temp >>= 8, i++) {\n\n\t\t\tif (pCardInfo->si_per_targ_init_sync & sync_bit_map) {\n\n\t\t\t\tFPT_sccbMgrTbl[thisCard][id * 2 +\n\t\t\t\t\t\t\t i].TarEEValue =\n\t\t\t\t    (unsigned char)temp;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tFPT_sccbMgrTbl[thisCard][id * 2 +\n\t\t\t\t\t\t\t i].TarStatus |=\n\t\t\t\t    SYNC_SUPPORTED;\n\t\t\t\tFPT_sccbMgrTbl[thisCard][id * 2 +\n\t\t\t\t\t\t\t i].TarEEValue =\n\t\t\t\t    (unsigned char)(temp & ~EE_SYNC_MASK);\n\t\t\t}\n\n \n\t\t\tif (pCardInfo->si_per_targ_wide_nego & sync_bit_map) {\n\n\t\t\t\tFPT_sccbMgrTbl[thisCard][id * 2 +\n\t\t\t\t\t\t\t i].TarEEValue |=\n\t\t\t\t    EE_WIDE_SCSI;\n\n\t\t\t}\n\n\t\t\telse {\t \n\t\t\t\tFPT_sccbMgrTbl[thisCard][id * 2 +\n\t\t\t\t\t\t\t i].TarStatus |=\n\t\t\t\t    WIDE_NEGOCIATED;\n\t\t\t}\n\n\t\t\tsync_bit_map <<= 1;\n\n\t\t}\n\t}\n\n\tWR_HARPOON((ioport + hp_semaphore),\n\t\t   (unsigned char)(RD_HARPOON((ioport + hp_semaphore)) |\n\t\t\t\t   SCCB_MGR_PRESENT));\n\n\treturn (void *)CurrCard;\n}\n\nstatic void FlashPoint_ReleaseHostAdapter(void *pCurrCard)\n{\n\tunsigned char i;\n\tu32 portBase;\n\tu32 regOffset;\n\tu32 scamData;\n\tu32 *pScamTbl;\n\tstruct nvram_info *pCurrNvRam;\n\n\tpCurrNvRam = ((struct sccb_card *)pCurrCard)->pNvRamInfo;\n\n\tif (pCurrNvRam) {\n\t\tFPT_WrStack(pCurrNvRam->niBaseAddr, 0, pCurrNvRam->niModel);\n\t\tFPT_WrStack(pCurrNvRam->niBaseAddr, 1, pCurrNvRam->niSysConf);\n\t\tFPT_WrStack(pCurrNvRam->niBaseAddr, 2, pCurrNvRam->niScsiConf);\n\t\tFPT_WrStack(pCurrNvRam->niBaseAddr, 3, pCurrNvRam->niScamConf);\n\t\tFPT_WrStack(pCurrNvRam->niBaseAddr, 4, pCurrNvRam->niAdapId);\n\n\t\tfor (i = 0; i < MAX_SCSI_TAR / 2; i++)\n\t\t\tFPT_WrStack(pCurrNvRam->niBaseAddr,\n\t\t\t\t    (unsigned char)(i + 5),\n\t\t\t\t    pCurrNvRam->niSyncTbl[i]);\n\n\t\tportBase = pCurrNvRam->niBaseAddr;\n\n\t\tfor (i = 0; i < MAX_SCSI_TAR; i++) {\n\t\t\tregOffset = hp_aramBase + 64 + i * 4;\n\t\t\tpScamTbl = (u32 *)&pCurrNvRam->niScamTbl[i];\n\t\t\tscamData = *pScamTbl;\n\t\t\tWR_HARP32(portBase, regOffset, scamData);\n\t\t}\n\n\t} else {\n\t\tFPT_WrStack(((struct sccb_card *)pCurrCard)->ioPort, 0, 0);\n\t}\n}\n\nstatic void FPT_RNVRamData(struct nvram_info *pNvRamInfo)\n{\n\tunsigned char i;\n\tu32 portBase;\n\tu32 regOffset;\n\tu32 scamData;\n\tu32 *pScamTbl;\n\n\tpNvRamInfo->niModel = FPT_RdStack(pNvRamInfo->niBaseAddr, 0);\n\tpNvRamInfo->niSysConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 1);\n\tpNvRamInfo->niScsiConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 2);\n\tpNvRamInfo->niScamConf = FPT_RdStack(pNvRamInfo->niBaseAddr, 3);\n\tpNvRamInfo->niAdapId = FPT_RdStack(pNvRamInfo->niBaseAddr, 4);\n\n\tfor (i = 0; i < MAX_SCSI_TAR / 2; i++)\n\t\tpNvRamInfo->niSyncTbl[i] =\n\t\t    FPT_RdStack(pNvRamInfo->niBaseAddr, (unsigned char)(i + 5));\n\n\tportBase = pNvRamInfo->niBaseAddr;\n\n\tfor (i = 0; i < MAX_SCSI_TAR; i++) {\n\t\tregOffset = hp_aramBase + 64 + i * 4;\n\t\tRD_HARP32(portBase, regOffset, scamData);\n\t\tpScamTbl = (u32 *)&pNvRamInfo->niScamTbl[i];\n\t\t*pScamTbl = scamData;\n\t}\n\n}\n\nstatic unsigned char FPT_RdStack(u32 portBase, unsigned char index)\n{\n\tWR_HARPOON(portBase + hp_stack_addr, index);\n\treturn RD_HARPOON(portBase + hp_stack_data);\n}\n\nstatic void FPT_WrStack(u32 portBase, unsigned char index, unsigned char data)\n{\n\tWR_HARPOON(portBase + hp_stack_addr, index);\n\tWR_HARPOON(portBase + hp_stack_data, data);\n}\n\nstatic unsigned char FPT_ChkIfChipInitialized(u32 ioPort)\n{\n\tif ((RD_HARPOON(ioPort + hp_arb_id) & 0x0f) != FPT_RdStack(ioPort, 4))\n\t\treturn 0;\n\tif ((RD_HARPOON(ioPort + hp_clkctrl_0) & CLKCTRL_DEFAULT)\n\t    != CLKCTRL_DEFAULT)\n\t\treturn 0;\n\tif ((RD_HARPOON(ioPort + hp_seltimeout) == TO_250ms) ||\n\t    (RD_HARPOON(ioPort + hp_seltimeout) == TO_290ms))\n\t\treturn 1;\n\treturn 0;\n\n}\n\n \nstatic void FlashPoint_StartCCB(void *curr_card, struct sccb *p_Sccb)\n{\n\tu32 ioport;\n\tunsigned char thisCard, lun;\n\tstruct sccb *pSaveSccb;\n\tCALL_BK_FN callback;\n\tstruct sccb_card *pCurrCard = curr_card;\n\n\tthisCard = pCurrCard->cardIndex;\n\tioport = pCurrCard->ioPort;\n\n\tif ((p_Sccb->TargID >= MAX_SCSI_TAR) || (p_Sccb->Lun >= MAX_LUN)) {\n\n\t\tp_Sccb->HostStatus = SCCB_COMPLETE;\n\t\tp_Sccb->SccbStatus = SCCB_ERROR;\n\t\tcallback = (CALL_BK_FN) p_Sccb->SccbCallback;\n\t\tif (callback)\n\t\t\tcallback(p_Sccb);\n\n\t\treturn;\n\t}\n\n\tFPT_sinits(p_Sccb, thisCard);\n\n\tif (!pCurrCard->cmdCounter) {\n\t\tWR_HARPOON(ioport + hp_semaphore,\n\t\t\t   (RD_HARPOON(ioport + hp_semaphore)\n\t\t\t    | SCCB_MGR_ACTIVE));\n\n\t\tif (pCurrCard->globalFlags & F_GREEN_PC) {\n\t\t\tWR_HARPOON(ioport + hp_clkctrl_0, CLKCTRL_DEFAULT);\n\t\t\tWR_HARPOON(ioport + hp_sys_ctrl, 0x00);\n\t\t}\n\t}\n\n\tpCurrCard->cmdCounter++;\n\n\tif (RD_HARPOON(ioport + hp_semaphore) & BIOS_IN_USE) {\n\n\t\tWR_HARPOON(ioport + hp_semaphore,\n\t\t\t   (RD_HARPOON(ioport + hp_semaphore)\n\t\t\t    | TICKLE_ME));\n\t\tif (p_Sccb->OperationCode == RESET_COMMAND) {\n\t\t\tpSaveSccb =\n\t\t\t    pCurrCard->currentSCCB;\n\t\t\tpCurrCard->currentSCCB = p_Sccb;\n\t\t\tFPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);\n\t\t\tpCurrCard->currentSCCB =\n\t\t\t    pSaveSccb;\n\t\t} else {\n\t\t\tFPT_queueAddSccb(p_Sccb, thisCard);\n\t\t}\n\t}\n\n\telse if ((RD_HARPOON(ioport + hp_page_ctrl) & G_INT_DISABLE)) {\n\n\t\tif (p_Sccb->OperationCode == RESET_COMMAND) {\n\t\t\tpSaveSccb =\n\t\t\t    pCurrCard->currentSCCB;\n\t\t\tpCurrCard->currentSCCB = p_Sccb;\n\t\t\tFPT_queueSelectFail(&FPT_BL_Card[thisCard], thisCard);\n\t\t\tpCurrCard->currentSCCB =\n\t\t\t    pSaveSccb;\n\t\t} else {\n\t\t\tFPT_queueAddSccb(p_Sccb, thisCard);\n\t\t}\n\t}\n\n\telse {\n\n\t\tMDISABLE_INT(ioport);\n\n\t\tif ((pCurrCard->globalFlags & F_CONLUN_IO) &&\n\t\t    ((FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].\n\t\t      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\n\t\t\tlun = p_Sccb->Lun;\n\t\telse\n\t\t\tlun = 0;\n\t\tif ((pCurrCard->currentSCCB == NULL) &&\n\t\t    (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarSelQ_Cnt == 0)\n\t\t    && (FPT_sccbMgrTbl[thisCard][p_Sccb->TargID].TarLUNBusy[lun]\n\t\t\t== 0)) {\n\n\t\t\tpCurrCard->currentSCCB = p_Sccb;\n\t\t\tFPT_ssel(p_Sccb->SccbIOPort, thisCard);\n\t\t}\n\n\t\telse {\n\n\t\t\tif (p_Sccb->OperationCode == RESET_COMMAND) {\n\t\t\t\tpSaveSccb = pCurrCard->currentSCCB;\n\t\t\t\tpCurrCard->currentSCCB = p_Sccb;\n\t\t\t\tFPT_queueSelectFail(&FPT_BL_Card[thisCard],\n\t\t\t\t\t\t    thisCard);\n\t\t\t\tpCurrCard->currentSCCB = pSaveSccb;\n\t\t\t} else {\n\t\t\t\tFPT_queueAddSccb(p_Sccb, thisCard);\n\t\t\t}\n\t\t}\n\n\t\tMENABLE_INT(ioport);\n\t}\n\n}\n\n \nstatic int FlashPoint_AbortCCB(void *pCurrCard, struct sccb *p_Sccb)\n{\n\tu32 ioport;\n\n\tunsigned char thisCard;\n\tCALL_BK_FN callback;\n\tstruct sccb *pSaveSCCB;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tioport = ((struct sccb_card *)pCurrCard)->ioPort;\n\n\tthisCard = ((struct sccb_card *)pCurrCard)->cardIndex;\n\n\tif (!(RD_HARPOON(ioport + hp_page_ctrl) & G_INT_DISABLE)) {\n\n\t\tif (FPT_queueFindSccb(p_Sccb, thisCard)) {\n\n\t\t\t((struct sccb_card *)pCurrCard)->cmdCounter--;\n\n\t\t\tif (!((struct sccb_card *)pCurrCard)->cmdCounter)\n\t\t\t\tWR_HARPOON(ioport + hp_semaphore,\n\t\t\t\t\t   (RD_HARPOON(ioport + hp_semaphore)\n\t\t\t\t\t    & (unsigned\n\t\t\t\t\t       char)(~(SCCB_MGR_ACTIVE |\n\t\t\t\t\t\t       TICKLE_ME))));\n\n\t\t\tp_Sccb->SccbStatus = SCCB_ABORT;\n\t\t\tcallback = p_Sccb->SccbCallback;\n\t\t\tcallback(p_Sccb);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\telse {\n\t\t\tif (((struct sccb_card *)pCurrCard)->currentSCCB ==\n\t\t\t    p_Sccb) {\n\t\t\t\tp_Sccb->SccbStatus = SCCB_ABORT;\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif (p_Sccb->Sccb_tag) {\n\t\t\t\t\tMDISABLE_INT(ioport);\n\t\t\t\t\tif (((struct sccb_card *)pCurrCard)->\n\t\t\t\t\t    discQ_Tbl[p_Sccb->Sccb_tag] ==\n\t\t\t\t\t    p_Sccb) {\n\t\t\t\t\t\tp_Sccb->SccbStatus = SCCB_ABORT;\n\t\t\t\t\t\tp_Sccb->Sccb_scsistat =\n\t\t\t\t\t\t    ABORT_ST;\n\t\t\t\t\t\tp_Sccb->Sccb_scsimsg =\n\t\t\t\t\t\t    ABORT_TASK;\n\n\t\t\t\t\t\tif (((struct sccb_card *)\n\t\t\t\t\t\t     pCurrCard)->currentSCCB ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\t((struct sccb_card *)\n\t\t\t\t\t\t\t pCurrCard)->\n\t\t\t\t\tcurrentSCCB = p_Sccb;\n\t\t\t\t\t\t\tFPT_ssel(ioport,\n\t\t\t\t\t\t\t\t thisCard);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpSaveSCCB =\n\t\t\t\t\t\t\t    ((struct sccb_card\n\t\t\t\t\t\t\t      *)pCurrCard)->\n\t\t\t\t\t\t\t    currentSCCB;\n\t\t\t\t\t\t\t((struct sccb_card *)\n\t\t\t\t\t\t\t pCurrCard)->\n\t\t\t\t\tcurrentSCCB = p_Sccb;\n\t\t\t\t\t\t\tFPT_queueSelectFail((struct sccb_card *)pCurrCard, thisCard);\n\t\t\t\t\t\t\t((struct sccb_card *)\n\t\t\t\t\t\t\t pCurrCard)->\n\t\t\t\t\tcurrentSCCB = pSaveSCCB;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tMENABLE_INT(ioport);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tcurrTar_Info =\n\t\t\t\t\t    &FPT_sccbMgrTbl[thisCard][p_Sccb->\n\t\t\t\t\t\t\t\t      TargID];\n\n\t\t\t\t\tif (FPT_BL_Card[thisCard].\n\t\t\t\t\t    discQ_Tbl[currTar_Info->\n\t\t\t\t\t\t      LunDiscQ_Idx[p_Sccb->Lun]]\n\t\t\t\t\t    == p_Sccb) {\n\t\t\t\t\t\tp_Sccb->SccbStatus = SCCB_ABORT;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n \nstatic unsigned char FlashPoint_InterruptPending(void *pCurrCard)\n{\n\tu32 ioport;\n\n\tioport = ((struct sccb_card *)pCurrCard)->ioPort;\n\n\tif (RD_HARPOON(ioport + hp_int_status) & INT_ASSERTED) {\n\t\treturn 1;\n\t}\n\n\telse\n\n\t\treturn 0;\n}\n\n \nstatic int FlashPoint_HandleInterrupt(void *pcard)\n{\n\tstruct sccb *currSCCB;\n\tunsigned char thisCard, result, bm_status;\n\tunsigned short hp_int;\n\tunsigned char i, target;\n\tstruct sccb_card *pCurrCard = pcard;\n\tu32 ioport;\n\n\tthisCard = pCurrCard->cardIndex;\n\tioport = pCurrCard->ioPort;\n\n\tMDISABLE_INT(ioport);\n\n\tif (RD_HARPOON(ioport + hp_int_status) & EXT_STATUS_ON)\n\t\tbm_status = RD_HARPOON(ioport + hp_ext_status) &\n\t\t\t\t\t(unsigned char)BAD_EXT_STATUS;\n\telse\n\t\tbm_status = 0;\n\n\tWR_HARPOON(ioport + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));\n\n\twhile ((hp_int = RDW_HARPOON((ioport + hp_intstat)) &\n\t\t\t\tFPT_default_intena) | bm_status) {\n\n\t\tcurrSCCB = pCurrCard->currentSCCB;\n\n\t\tif (hp_int & (FIFO | TIMEOUT | RESET | SCAM_SEL) || bm_status) {\n\t\t\tresult =\n\t\t\t    FPT_SccbMgr_bad_isr(ioport, thisCard, pCurrCard,\n\t\t\t\t\t\thp_int);\n\t\t\tWRW_HARPOON((ioport + hp_intstat),\n\t\t\t\t    (FIFO | TIMEOUT | RESET | SCAM_SEL));\n\t\t\tbm_status = 0;\n\n\t\t\tif (result) {\n\n\t\t\t\tMENABLE_INT(ioport);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\telse if (hp_int & ICMD_COMP) {\n\n\t\t\tif (!(hp_int & BUS_FREE)) {\n\t\t\t\t \n\t\t\t\twhile (!\n\t\t\t\t       (RDW_HARPOON((ioport + hp_intstat)) &\n\t\t\t\t\t(BUS_FREE | RSEL))) ;\n\t\t\t}\n\n\t\t\tif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\n\n\t\t\t\tFPT_phaseChkFifo(ioport, thisCard);\n\n \n\n\t\t\tWRW_HARPOON((ioport + hp_intstat), CLR_ALL_INT_1);\n\n\t\t\tFPT_autoCmdCmplt(ioport, thisCard);\n\n\t\t}\n\n\t\telse if (hp_int & ITAR_DISC) {\n\n\t\t\tif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\n\t\t\t\tFPT_phaseChkFifo(ioport, thisCard);\n\n\t\t\tif (RD_HARPOON(ioport + hp_gp_reg_1) ==\n\t\t\t\t\tSAVE_POINTERS) {\n\n\t\t\t\tWR_HARPOON(ioport + hp_gp_reg_1, 0x00);\n\t\t\t\tcurrSCCB->Sccb_XferState |= F_NO_DATA_YET;\n\n\t\t\t\tcurrSCCB->Sccb_savedATC = currSCCB->Sccb_ATC;\n\t\t\t}\n\n\t\t\tcurrSCCB->Sccb_scsistat = DISCONNECT_ST;\n\t\t\tFPT_queueDisconnect(currSCCB, thisCard);\n\n\t\t\t \n\t\t\twhile (!\n\t\t\t       (RDW_HARPOON((ioport + hp_intstat)) &\n\t\t\t\t(BUS_FREE | RSEL))\n\t\t\t       && !((RDW_HARPOON((ioport + hp_intstat)) & PHASE)\n\t\t\t\t    && RD_HARPOON((ioport + hp_scsisig)) ==\n\t\t\t\t    (SCSI_BSY | SCSI_REQ | SCSI_CD | SCSI_MSG |\n\t\t\t\t     SCSI_IOBIT))) ;\n\n\t\t\t \n\t\t\tif (!\n\t\t\t    (RDW_HARPOON((ioport + hp_intstat)) &\n\t\t\t     (BUS_FREE | RSEL))) {\n\t\t\t\tMENABLE_INT(ioport);\n\t\t\t\treturn 0xFE;\n\t\t\t}\n\n\t\t\tWRW_HARPOON((ioport + hp_intstat),\n\t\t\t\t    (BUS_FREE | ITAR_DISC));\n\n\t\t\tpCurrCard->globalFlags |= F_NEW_SCCB_CMD;\n\n\t\t}\n\n\t\telse if (hp_int & RSEL) {\n\n\t\t\tWRW_HARPOON((ioport + hp_intstat),\n\t\t\t\t    (PROG_HLT | RSEL | PHASE | BUS_FREE));\n\n\t\t\tif (RDW_HARPOON((ioport + hp_intstat)) & ITAR_DISC) {\n\t\t\t\tif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\n\t\t\t\t\tFPT_phaseChkFifo(ioport, thisCard);\n\n\t\t\t\tif (RD_HARPOON(ioport + hp_gp_reg_1) ==\n\t\t\t\t    SAVE_POINTERS) {\n\t\t\t\t\tWR_HARPOON(ioport + hp_gp_reg_1, 0x00);\n\t\t\t\t\tcurrSCCB->Sccb_XferState |=\n\t\t\t\t\t    F_NO_DATA_YET;\n\t\t\t\t\tcurrSCCB->Sccb_savedATC =\n\t\t\t\t\t    currSCCB->Sccb_ATC;\n\t\t\t\t}\n\n\t\t\t\tWRW_HARPOON((ioport + hp_intstat),\n\t\t\t\t\t    (BUS_FREE | ITAR_DISC));\n\t\t\t\tcurrSCCB->Sccb_scsistat = DISCONNECT_ST;\n\t\t\t\tFPT_queueDisconnect(currSCCB, thisCard);\n\t\t\t}\n\n\t\t\tFPT_sres(ioport, thisCard, pCurrCard);\n\t\t\tFPT_phaseDecode(ioport, thisCard);\n\n\t\t}\n\n\t\telse if ((hp_int & IDO_STRT) && (!(hp_int & BUS_FREE))) {\n\n\t\t\tWRW_HARPOON((ioport + hp_intstat),\n\t\t\t\t    (IDO_STRT | XFER_CNT_0));\n\t\t\tFPT_phaseDecode(ioport, thisCard);\n\n\t\t}\n\n\t\telse if ((hp_int & IUNKWN) || (hp_int & PROG_HLT)) {\n\t\t\tWRW_HARPOON((ioport + hp_intstat),\n\t\t\t\t    (PHASE | IUNKWN | PROG_HLT));\n\t\t\tif ((RD_HARPOON(ioport + hp_prgmcnt_0) & (unsigned char)\n\t\t\t     0x3f) < (unsigned char)SELCHK) {\n\t\t\t\tFPT_phaseDecode(ioport, thisCard);\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\ti = (unsigned\n\t\t\t\t     char)(RD_HARPOON(ioport + hp_fifowrite));\n\t\t\t\ttarget =\n\t\t\t\t    (unsigned\n\t\t\t\t     char)(RD_HARPOON(ioport + hp_gp_reg_3));\n\t\t\t\tWR_HARPOON(ioport + hp_xfer_pad,\n\t\t\t\t\t   (unsigned char)ID_UNLOCK);\n\t\t\t\tWR_HARPOON(ioport + hp_select_id,\n\t\t\t\t\t   (unsigned char)(target | target <<\n\t\t\t\t\t\t\t   4));\n\t\t\t\tWR_HARPOON(ioport + hp_xfer_pad,\n\t\t\t\t\t   (unsigned char)0x00);\n\t\t\t\tWR_HARPOON(ioport + hp_fifowrite, i);\n\t\t\t\tWR_HARPOON(ioport + hp_autostart_3,\n\t\t\t\t\t   (AUTO_IMMED + TAG_STRT));\n\t\t\t}\n\t\t}\n\n\t\telse if (hp_int & XFER_CNT_0) {\n\n\t\t\tWRW_HARPOON((ioport + hp_intstat), XFER_CNT_0);\n\n\t\t\tFPT_schkdd(ioport, thisCard);\n\n\t\t}\n\n\t\telse if (hp_int & BUS_FREE) {\n\n\t\t\tWRW_HARPOON((ioport + hp_intstat), BUS_FREE);\n\n\t\t\tif (pCurrCard->globalFlags & F_HOST_XFER_ACT) {\n\n\t\t\t\tFPT_hostDataXferAbort(ioport, thisCard,\n\t\t\t\t\t\t      currSCCB);\n\t\t\t}\n\n\t\t\tFPT_phaseBusFree(ioport, thisCard);\n\t\t}\n\n\t\telse if (hp_int & ITICKLE) {\n\n\t\t\tWRW_HARPOON((ioport + hp_intstat), ITICKLE);\n\t\t\tpCurrCard->globalFlags |= F_NEW_SCCB_CMD;\n\t\t}\n\n\t\tif (((struct sccb_card *)pCurrCard)->\n\t\t    globalFlags & F_NEW_SCCB_CMD) {\n\n\t\t\tpCurrCard->globalFlags &= ~F_NEW_SCCB_CMD;\n\n\t\t\tif (pCurrCard->currentSCCB == NULL)\n\t\t\t\tFPT_queueSearchSelect(pCurrCard, thisCard);\n\n\t\t\tif (pCurrCard->currentSCCB != NULL) {\n\t\t\t\tpCurrCard->globalFlags &= ~F_NEW_SCCB_CMD;\n\t\t\t\tFPT_ssel(ioport, thisCard);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\t\t\t \n\n\tMENABLE_INT(ioport);\n\n\treturn 0;\n}\n\n \nstatic unsigned char FPT_SccbMgr_bad_isr(u32 p_port, unsigned char p_card,\n\t\t\t\t\t struct sccb_card *pCurrCard,\n\t\t\t\t\t unsigned short p_int)\n{\n\tunsigned char temp, ScamFlg;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\tstruct nvram_info *pCurrNvRam;\n\n\tif (RD_HARPOON(p_port + hp_ext_status) &\n\t    (BM_FORCE_OFF | PCI_DEV_TMOUT | BM_PARITY_ERR | PIO_OVERRUN)) {\n\n\t\tif (pCurrCard->globalFlags & F_HOST_XFER_ACT) {\n\n\t\t\tFPT_hostDataXferAbort(p_port, p_card,\n\t\t\t\t\t      pCurrCard->currentSCCB);\n\t\t}\n\n\t\tif (RD_HARPOON(p_port + hp_pci_stat_cfg) & REC_MASTER_ABORT)\n\t\t{\n\t\t\tWR_HARPOON(p_port + hp_pci_stat_cfg,\n\t\t\t\t   (RD_HARPOON(p_port + hp_pci_stat_cfg) &\n\t\t\t\t    ~REC_MASTER_ABORT));\n\n\t\t\tWR_HARPOON(p_port + hp_host_blk_cnt, 0x00);\n\n\t\t}\n\n\t\tif (pCurrCard->currentSCCB != NULL) {\n\n\t\t\tif (!pCurrCard->currentSCCB->HostStatus)\n\t\t\t\tpCurrCard->currentSCCB->HostStatus =\n\t\t\t\t    SCCB_BM_ERR;\n\n\t\t\tFPT_sxfrp(p_port, p_card);\n\n\t\t\ttemp = (unsigned char)(RD_HARPOON(p_port + hp_ee_ctrl) &\n\t\t\t\t\t       (EXT_ARB_ACK | SCSI_TERM_ENA_H));\n\t\t\tWR_HARPOON(p_port + hp_ee_ctrl,\n\t\t\t\t   ((unsigned char)temp | SEE_MS | SEE_CS));\n\t\t\tWR_HARPOON(p_port + hp_ee_ctrl, temp);\n\n\t\t\tif (!\n\t\t\t    (RDW_HARPOON((p_port + hp_intstat)) &\n\t\t\t     (BUS_FREE | RESET))) {\n\t\t\t\tFPT_phaseDecode(p_port, p_card);\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (p_int & RESET) {\n\n\t\tWR_HARPOON(p_port + hp_clkctrl_0, CLKCTRL_DEFAULT);\n\t\tWR_HARPOON(p_port + hp_sys_ctrl, 0x00);\n\t\tif (pCurrCard->currentSCCB != NULL) {\n\n\t\t\tif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\n\n\t\t\t\tFPT_hostDataXferAbort(p_port, p_card,\n\t\t\t\t\t\t      pCurrCard->currentSCCB);\n\t\t}\n\n\t\tDISABLE_AUTO(p_port);\n\n\t\tFPT_sresb(p_port, p_card);\n\n\t\twhile (RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST) {\n\t\t}\n\n\t\tpCurrNvRam = pCurrCard->pNvRamInfo;\n\t\tif (pCurrNvRam) {\n\t\t\tScamFlg = pCurrNvRam->niScamConf;\n\t\t} else {\n\t\t\tScamFlg =\n\t\t\t    (unsigned char)FPT_utilEERead(p_port,\n\t\t\t\t\t\t\t  SCAM_CONFIG / 2);\n\t\t}\n\n\t\tFPT_XbowInit(p_port, ScamFlg);\n\n\t\tFPT_scini(p_card, pCurrCard->ourId, 0);\n\n\t\treturn 0xFF;\n\t}\n\n\telse if (p_int & FIFO) {\n\n\t\tWRW_HARPOON((p_port + hp_intstat), FIFO);\n\n\t\tif (pCurrCard->currentSCCB != NULL)\n\t\t\tFPT_sxfrp(p_port, p_card);\n\t}\n\n\telse if (p_int & TIMEOUT) {\n\n\t\tDISABLE_AUTO(p_port);\n\n\t\tWRW_HARPOON((p_port + hp_intstat),\n\t\t\t    (PROG_HLT | TIMEOUT | SEL | BUS_FREE | PHASE |\n\t\t\t     IUNKWN));\n\n\t\tpCurrCard->currentSCCB->HostStatus = SCCB_SELECTION_TIMEOUT;\n\n\t\tcurrTar_Info =\n\t\t    &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];\n\t\tif ((pCurrCard->globalFlags & F_CONLUN_IO)\n\t\t    && ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=\n\t\t\tTAG_Q_TRYING))\n\t\t\tcurrTar_Info->TarLUNBusy[pCurrCard->currentSCCB->Lun] =\n\t\t\t    0;\n\t\telse\n\t\t\tcurrTar_Info->TarLUNBusy[0] = 0;\n\n\t\tif (currTar_Info->TarEEValue & EE_SYNC_MASK) {\n\t\t\tcurrTar_Info->TarSyncCtrl = 0;\n\t\t\tcurrTar_Info->TarStatus &= ~TAR_SYNC_MASK;\n\t\t}\n\n\t\tif (currTar_Info->TarEEValue & EE_WIDE_SCSI) {\n\t\t\tcurrTar_Info->TarStatus &= ~TAR_WIDE_MASK;\n\t\t}\n\n\t\tFPT_sssyncv(p_port, pCurrCard->currentSCCB->TargID, NARROW_SCSI,\n\t\t\t    currTar_Info);\n\n\t\tFPT_queueCmdComplete(pCurrCard, pCurrCard->currentSCCB, p_card);\n\n\t}\n\n\telse if (p_int & SCAM_SEL) {\n\n\t\tFPT_scarb(p_port, LEVEL2_TAR);\n\t\tFPT_scsel(p_port);\n\t\tFPT_scasid(p_card, p_port);\n\n\t\tFPT_scbusf(p_port);\n\n\t\tWRW_HARPOON((p_port + hp_intstat), SCAM_SEL);\n\t}\n\n\treturn 0x00;\n}\n\n \n\nstatic void FPT_SccbMgrTableInitAll(void)\n{\n\tunsigned char thisCard;\n\n\tfor (thisCard = 0; thisCard < MAX_CARDS; thisCard++) {\n\t\tFPT_SccbMgrTableInitCard(&FPT_BL_Card[thisCard], thisCard);\n\n\t\tFPT_BL_Card[thisCard].ioPort = 0x00;\n\t\tFPT_BL_Card[thisCard].cardInfo = NULL;\n\t\tFPT_BL_Card[thisCard].cardIndex = 0xFF;\n\t\tFPT_BL_Card[thisCard].ourId = 0x00;\n\t\tFPT_BL_Card[thisCard].pNvRamInfo = NULL;\n\t}\n}\n\n \n\nstatic void FPT_SccbMgrTableInitCard(struct sccb_card *pCurrCard,\n\t\t\t\t     unsigned char p_card)\n{\n\tunsigned char scsiID, qtag;\n\n\tfor (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {\n\t\tFPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;\n\t}\n\n\tfor (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++) {\n\t\tFPT_sccbMgrTbl[p_card][scsiID].TarStatus = 0;\n\t\tFPT_sccbMgrTbl[p_card][scsiID].TarEEValue = 0;\n\t\tFPT_SccbMgrTableInitTarget(p_card, scsiID);\n\t}\n\n\tpCurrCard->scanIndex = 0x00;\n\tpCurrCard->currentSCCB = NULL;\n\tpCurrCard->globalFlags = 0x00;\n\tpCurrCard->cmdCounter = 0x00;\n\tpCurrCard->tagQ_Lst = 0x01;\n\tpCurrCard->discQCount = 0;\n\n}\n\n \n\nstatic void FPT_SccbMgrTableInitTarget(unsigned char p_card,\n\t\t\t\t       unsigned char target)\n{\n\n\tunsigned char lun, qtag;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][target];\n\n\tcurrTar_Info->TarSelQ_Cnt = 0;\n\tcurrTar_Info->TarSyncCtrl = 0;\n\n\tcurrTar_Info->TarSelQ_Head = NULL;\n\tcurrTar_Info->TarSelQ_Tail = NULL;\n\tcurrTar_Info->TarTagQ_Cnt = 0;\n\tcurrTar_Info->TarLUN_CA = 0;\n\n\tfor (lun = 0; lun < MAX_LUN; lun++) {\n\t\tcurrTar_Info->TarLUNBusy[lun] = 0;\n\t\tcurrTar_Info->LunDiscQ_Idx[lun] = 0;\n\t}\n\n\tfor (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {\n\t\tif (FPT_BL_Card[p_card].discQ_Tbl[qtag] != NULL) {\n\t\t\tif (FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID ==\n\t\t\t    target) {\n\t\t\t\tFPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;\n\t\t\t\tFPT_BL_Card[p_card].discQCount--;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\nstatic unsigned char FPT_sfm(u32 port, struct sccb *pCurrSCCB)\n{\n\tunsigned char message;\n\tunsigned short TimeOutLoop;\n\n\tTimeOutLoop = 0;\n\twhile ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&\n\t       (TimeOutLoop++ < 20000)) {\n\t}\n\n\tWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\n\n\tmessage = RD_HARPOON(port + hp_scsidata_0);\n\n\tWR_HARPOON(port + hp_scsisig, SCSI_ACK + S_MSGI_PH);\n\n\tif (TimeOutLoop > 20000)\n\t\tmessage = 0x00;\t \n\n\tif ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&\n\t    (RD_HARPOON(port + hp_addstat) & SCSI_PAR_ERR)) {\n\t\tWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\n\t\tWR_HARPOON(port + hp_xferstat, 0);\n\t\tWR_HARPOON(port + hp_fiforead, 0);\n\t\tWR_HARPOON(port + hp_fifowrite, 0);\n\t\tif (pCurrSCCB != NULL) {\n\t\t\tpCurrSCCB->Sccb_scsimsg = MSG_PARITY_ERROR;\n\t\t}\n\t\tmessage = 0x00;\n\t\tdo {\n\t\t\tACCEPT_MSG_ATN(port);\n\t\t\tTimeOutLoop = 0;\n\t\t\twhile ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&\n\t\t\t       (TimeOutLoop++ < 20000)) {\n\t\t\t}\n\t\t\tif (TimeOutLoop > 20000) {\n\t\t\t\tWRW_HARPOON((port + hp_intstat), PARITY);\n\t\t\t\treturn message;\n\t\t\t}\n\t\t\tif ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) !=\n\t\t\t    S_MSGI_PH) {\n\t\t\t\tWRW_HARPOON((port + hp_intstat), PARITY);\n\t\t\t\treturn message;\n\t\t\t}\n\t\t\tWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\n\n\t\t\tRD_HARPOON(port + hp_scsidata_0);\n\n\t\t\tWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\n\n\t\t} while (1);\n\n\t}\n\tWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\n\tWR_HARPOON(port + hp_xferstat, 0);\n\tWR_HARPOON(port + hp_fiforead, 0);\n\tWR_HARPOON(port + hp_fifowrite, 0);\n\treturn message;\n}\n\n \n\nstatic void FPT_ssel(u32 port, unsigned char p_card)\n{\n\n\tunsigned char auto_loaded, i, target, *theCCB;\n\n\tu32 cdb_reg;\n\tstruct sccb_card *CurrCard;\n\tstruct sccb *currSCCB;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\tunsigned char lastTag, lun;\n\n\tCurrCard = &FPT_BL_Card[p_card];\n\tcurrSCCB = CurrCard->currentSCCB;\n\ttarget = currSCCB->TargID;\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][target];\n\tlastTag = CurrCard->tagQ_Lst;\n\n\tARAM_ACCESS(port);\n\n\tif ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)\n\t\tcurrSCCB->ControlByte &= ~F_USE_CMD_Q;\n\n\tif (((CurrCard->globalFlags & F_CONLUN_IO) &&\n\t     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING)))\n\n\t\tlun = currSCCB->Lun;\n\telse\n\t\tlun = 0;\n\n\tif (CurrCard->globalFlags & F_TAG_STARTED) {\n\t\tif (!(currSCCB->ControlByte & F_USE_CMD_Q)) {\n\t\t\tif ((currTar_Info->TarLUN_CA == 0)\n\t\t\t    && ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)\n\t\t\t\t== TAG_Q_TRYING)) {\n\n\t\t\t\tif (currTar_Info->TarTagQ_Cnt != 0) {\n\t\t\t\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t\t\t\t\tFPT_queueSelectFail(CurrCard, p_card);\n\t\t\t\t\tSGRAM_ACCESS(port);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t \n\t\t\telse {\n\t\t\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t\t\t}\n\n\t\t}\n\t\t \n\t\telse {\n\t\t\tif (currTar_Info->TarLUN_CA == 1) {\n\t\t\t\tFPT_queueSelectFail(CurrCard, p_card);\n\t\t\t\tSGRAM_ACCESS(port);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\n\t\t}\t\t \n\n\t}\n\t \n\telse {\n\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t}\n\n\tif ((((CurrCard->globalFlags & F_CONLUN_IO) &&\n\t      ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\n\t     || (!(currSCCB->ControlByte & F_USE_CMD_Q)))) {\n\t\tif (CurrCard->discQCount >= QUEUE_DEPTH) {\n\t\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t\t\tFPT_queueSelectFail(CurrCard, p_card);\n\t\t\tSGRAM_ACCESS(port);\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 1; i < QUEUE_DEPTH; i++) {\n\t\t\tif (++lastTag >= QUEUE_DEPTH)\n\t\t\t\tlastTag = 1;\n\t\t\tif (CurrCard->discQ_Tbl[lastTag] == NULL) {\n\t\t\t\tCurrCard->tagQ_Lst = lastTag;\n\t\t\t\tcurrTar_Info->LunDiscQ_Idx[lun] = lastTag;\n\t\t\t\tCurrCard->discQ_Tbl[lastTag] = currSCCB;\n\t\t\t\tCurrCard->discQCount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == QUEUE_DEPTH) {\n\t\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t\t\tFPT_queueSelectFail(CurrCard, p_card);\n\t\t\tSGRAM_ACCESS(port);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tauto_loaded = 0;\n\n\tWR_HARPOON(port + hp_select_id, target);\n\tWR_HARPOON(port + hp_gp_reg_3, target);\t \n\n\tif (currSCCB->OperationCode == RESET_COMMAND) {\n\t\tWRW_HARPOON((port + ID_MSG_STRT), (MPM_OP + AMSG_OUT +\n\t\t\t\t\t\t   (currSCCB->\n\t\t\t\t\t\t    Sccb_idmsg & ~DISC_PRIV)));\n\n\t\tWRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + NP);\n\n\t\tcurrSCCB->Sccb_scsimsg = TARGET_RESET;\n\n\t\tWR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));\n\t\tauto_loaded = 1;\n\t\tcurrSCCB->Sccb_scsistat = SELECT_BDR_ST;\n\n\t\tif (currTar_Info->TarEEValue & EE_SYNC_MASK) {\n\t\t\tcurrTar_Info->TarSyncCtrl = 0;\n\t\t\tcurrTar_Info->TarStatus &= ~TAR_SYNC_MASK;\n\t\t}\n\n\t\tif (currTar_Info->TarEEValue & EE_WIDE_SCSI) {\n\t\t\tcurrTar_Info->TarStatus &= ~TAR_WIDE_MASK;\n\t\t}\n\n\t\tFPT_sssyncv(port, target, NARROW_SCSI, currTar_Info);\n\t\tFPT_SccbMgrTableInitTarget(p_card, target);\n\n\t}\n\n\telse if (currSCCB->Sccb_scsistat == ABORT_ST) {\n\t\tWRW_HARPOON((port + ID_MSG_STRT), (MPM_OP + AMSG_OUT +\n\t\t\t\t\t\t   (currSCCB->\n\t\t\t\t\t\t    Sccb_idmsg & ~DISC_PRIV)));\n\n\t\tWRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);\n\n\t\tWRW_HARPOON((port + SYNC_MSGS + 0), (MPM_OP + AMSG_OUT +\n\t\t\t\t\t\t     (((unsigned\n\t\t\t\t\t\t\tchar)(currSCCB->\n\t\t\t\t\t\t\t      ControlByte &\n\t\t\t\t\t\t\t      TAG_TYPE_MASK)\n\t\t\t\t\t\t       >> 6) | (unsigned char)\n\t\t\t\t\t\t      0x20)));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 2),\n\t\t\t    (MPM_OP + AMSG_OUT + currSCCB->Sccb_tag));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 4), (BRH_OP + ALWAYS + NP));\n\n\t\tWR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));\n\t\tauto_loaded = 1;\n\n\t}\n\n\telse if (!(currTar_Info->TarStatus & WIDE_NEGOCIATED)) {\n\t\tauto_loaded = FPT_siwidn(port, p_card);\n\t\tcurrSCCB->Sccb_scsistat = SELECT_WN_ST;\n\t}\n\n\telse if (!((currTar_Info->TarStatus & TAR_SYNC_MASK)\n\t\t   == SYNC_SUPPORTED)) {\n\t\tauto_loaded = FPT_sisyncn(port, p_card, 0);\n\t\tcurrSCCB->Sccb_scsistat = SELECT_SN_ST;\n\t}\n\n\tif (!auto_loaded) {\n\n\t\tif (currSCCB->ControlByte & F_USE_CMD_Q) {\n\n\t\t\tCurrCard->globalFlags |= F_TAG_STARTED;\n\n\t\t\tif ((currTar_Info->TarStatus & TAR_TAG_Q_MASK)\n\t\t\t    == TAG_Q_REJECT) {\n\t\t\t\tcurrSCCB->ControlByte &= ~F_USE_CMD_Q;\n\n\t\t\t\t \n\t\t\t\tWRW_HARPOON((port + ID_MSG_STRT),\n\t\t\t\t\t    BRH_OP + ALWAYS + NTCMD);\n\n\t\t\t\tWRW_HARPOON((port + NON_TAG_ID_MSG),\n\t\t\t\t\t    (MPM_OP + AMSG_OUT +\n\t\t\t\t\t     currSCCB->Sccb_idmsg));\n\n\t\t\t\tWR_HARPOON(port + hp_autostart_3,\n\t\t\t\t\t   (SELECT + SELCHK_STRT));\n\n\t\t\t\t \n\t\t\t\tcurrSCCB->Sccb_scsistat = SELECT_ST;\n\n\t\t\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tWRW_HARPOON((port + ID_MSG_STRT),\n\t\t\t\t\t    (MPM_OP + AMSG_OUT +\n\t\t\t\t\t     currSCCB->Sccb_idmsg));\n\n\t\t\t\tWRW_HARPOON((port + ID_MSG_STRT + 2),\n\t\t\t\t\t    (MPM_OP + AMSG_OUT +\n\t\t\t\t\t     (((unsigned char)(currSCCB->\n\t\t\t\t\t\t\t       ControlByte &\n\t\t\t\t\t\t\t       TAG_TYPE_MASK)\n\t\t\t\t\t       >> 6) | (unsigned char)0x20)));\n\n\t\t\t\tfor (i = 1; i < QUEUE_DEPTH; i++) {\n\t\t\t\t\tif (++lastTag >= QUEUE_DEPTH)\n\t\t\t\t\t\tlastTag = 1;\n\t\t\t\t\tif (CurrCard->discQ_Tbl[lastTag] ==\n\t\t\t\t\t    NULL) {\n\t\t\t\t\t\tWRW_HARPOON((port +\n\t\t\t\t\t\t\t     ID_MSG_STRT + 6),\n\t\t\t\t\t\t\t    (MPM_OP + AMSG_OUT +\n\t\t\t\t\t\t\t     lastTag));\n\t\t\t\t\t\tCurrCard->tagQ_Lst = lastTag;\n\t\t\t\t\t\tcurrSCCB->Sccb_tag = lastTag;\n\t\t\t\t\t\tCurrCard->discQ_Tbl[lastTag] =\n\t\t\t\t\t\t    currSCCB;\n\t\t\t\t\t\tCurrCard->discQCount++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i == QUEUE_DEPTH) {\n\t\t\t\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t\t\t\t\tFPT_queueSelectFail(CurrCard, p_card);\n\t\t\t\t\tSGRAM_ACCESS(port);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcurrSCCB->Sccb_scsistat = SELECT_Q_ST;\n\n\t\t\t\tWR_HARPOON(port + hp_autostart_3,\n\t\t\t\t\t   (SELECT + SELCHK_STRT));\n\t\t\t}\n\t\t}\n\n\t\telse {\n\n\t\t\tWRW_HARPOON((port + ID_MSG_STRT),\n\t\t\t\t    BRH_OP + ALWAYS + NTCMD);\n\n\t\t\tWRW_HARPOON((port + NON_TAG_ID_MSG),\n\t\t\t\t    (MPM_OP + AMSG_OUT + currSCCB->Sccb_idmsg));\n\n\t\t\tcurrSCCB->Sccb_scsistat = SELECT_ST;\n\n\t\t\tWR_HARPOON(port + hp_autostart_3,\n\t\t\t\t   (SELECT + SELCHK_STRT));\n\t\t}\n\n\t\ttheCCB = (unsigned char *)&currSCCB->Cdb[0];\n\n\t\tcdb_reg = port + CMD_STRT;\n\n\t\tfor (i = 0; i < currSCCB->CdbLength; i++) {\n\t\t\tWRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + *theCCB));\n\t\t\tcdb_reg += 2;\n\t\t\ttheCCB++;\n\t\t}\n\n\t\tif (currSCCB->CdbLength != TWELVE_BYTE_CMD)\n\t\t\tWRW_HARPOON(cdb_reg, (BRH_OP + ALWAYS + NP));\n\n\t}\n\t \n\tWRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);\n\tWR_HARPOON(port + hp_xferstat, 0x00);\n\n\tWRW_HARPOON((port + hp_intstat), (PROG_HLT | TIMEOUT | SEL | BUS_FREE));\n\n\tWR_HARPOON(port + hp_portctrl_0, (SCSI_PORT));\n\n\tif (!(currSCCB->Sccb_MGRFlags & F_DEV_SELECTED)) {\n\t\tWR_HARPOON(port + hp_scsictrl_0,\n\t\t\t   (SEL_TAR | ENA_ATN | ENA_RESEL | ENA_SCAM_SEL));\n\t} else {\n\n \n\t\tauto_loaded = AUTO_IMMED;\n\n\t\tDISABLE_AUTO(port);\n\n\t\tWR_HARPOON(port + hp_autostart_3, auto_loaded);\n\t}\n\n\tSGRAM_ACCESS(port);\n}\n\n \n\nstatic void FPT_sres(u32 port, unsigned char p_card,\n\t\t     struct sccb_card *pCurrCard)\n{\n\n\tunsigned char our_target, message, lun = 0, tag, msgRetryCount;\n\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\tstruct sccb *currSCCB;\n\n\tif (pCurrCard->currentSCCB != NULL) {\n\t\tcurrTar_Info =\n\t\t    &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];\n\t\tDISABLE_AUTO(port);\n\n\t\tWR_HARPOON((port + hp_scsictrl_0), (ENA_RESEL | ENA_SCAM_SEL));\n\n\t\tcurrSCCB = pCurrCard->currentSCCB;\n\t\tif (currSCCB->Sccb_scsistat == SELECT_WN_ST) {\n\t\t\tcurrTar_Info->TarStatus &= ~TAR_WIDE_MASK;\n\t\t\tcurrSCCB->Sccb_scsistat = BUS_FREE_ST;\n\t\t}\n\t\tif (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\n\t\t\tcurrTar_Info->TarStatus &= ~TAR_SYNC_MASK;\n\t\t\tcurrSCCB->Sccb_scsistat = BUS_FREE_ST;\n\t\t}\n\t\tif (((pCurrCard->globalFlags & F_CONLUN_IO) &&\n\t\t     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=\n\t\t      TAG_Q_TRYING))) {\n\t\t\tcurrTar_Info->TarLUNBusy[currSCCB->Lun] = 0;\n\t\t\tif (currSCCB->Sccb_scsistat != ABORT_ST) {\n\t\t\t\tpCurrCard->discQCount--;\n\t\t\t\tpCurrCard->discQ_Tbl[currTar_Info->\n\t\t\t\t\t\t     LunDiscQ_Idx[currSCCB->\n\t\t\t\t\t\t\t\t  Lun]]\n\t\t\t\t    = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tcurrTar_Info->TarLUNBusy[0] = 0;\n\t\t\tif (currSCCB->Sccb_tag) {\n\t\t\t\tif (currSCCB->Sccb_scsistat != ABORT_ST) {\n\t\t\t\t\tpCurrCard->discQCount--;\n\t\t\t\t\tpCurrCard->discQ_Tbl[currSCCB->\n\t\t\t\t\t\t\t     Sccb_tag] = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currSCCB->Sccb_scsistat != ABORT_ST) {\n\t\t\t\t\tpCurrCard->discQCount--;\n\t\t\t\t\tpCurrCard->discQ_Tbl[currTar_Info->\n\t\t\t\t\t\t\t     LunDiscQ_Idx[0]] =\n\t\t\t\t\t    NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFPT_queueSelectFail(&FPT_BL_Card[p_card], p_card);\n\t}\n\n\tWRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);\n\n\tour_target = (unsigned char)(RD_HARPOON(port + hp_select_id) >> 4);\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][our_target];\n\n\tmsgRetryCount = 0;\n\tdo {\n\n\t\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][our_target];\n\t\ttag = 0;\n\n\t\twhile (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {\n\t\t\tif (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {\n\n\t\t\t\tWRW_HARPOON((port + hp_intstat), PHASE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tWRW_HARPOON((port + hp_intstat), PHASE);\n\t\tif ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) == S_MSGI_PH) {\n\n\t\t\tmessage = FPT_sfm(port, pCurrCard->currentSCCB);\n\t\t\tif (message) {\n\n\t\t\t\tif (message <= (0x80 | LUN_MASK)) {\n\t\t\t\t\tlun = message & (unsigned char)LUN_MASK;\n\n\t\t\t\t\tif ((currTar_Info->\n\t\t\t\t\t     TarStatus & TAR_TAG_Q_MASK) ==\n\t\t\t\t\t    TAG_Q_TRYING) {\n\t\t\t\t\t\tif (currTar_Info->TarTagQ_Cnt !=\n\t\t\t\t\t\t    0) {\n\n\t\t\t\t\t\t\tif (!\n\t\t\t\t\t\t\t    (currTar_Info->\n\t\t\t\t\t\t\t     TarLUN_CA)) {\n\t\t\t\t\t\t\t\tACCEPT_MSG(port);\t \n\n\t\t\t\t\t\t\t\tmessage =\n\t\t\t\t\t\t\t\t    FPT_sfm\n\t\t\t\t\t\t\t\t    (port,\n\t\t\t\t\t\t\t\t     pCurrCard->\n\t\t\t\t\t\t\t\t     currentSCCB);\n\t\t\t\t\t\t\t\tif (message) {\n\t\t\t\t\t\t\t\t\tACCEPT_MSG\n\t\t\t\t\t\t\t\t\t    (port);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t    = 0;\n\n\t\t\t\t\t\t\t\tif (message !=\n\t\t\t\t\t\t\t\t    0) {\n\t\t\t\t\t\t\t\t\ttag =\n\t\t\t\t\t\t\t\t\t    FPT_sfm\n\t\t\t\t\t\t\t\t\t    (port,\n\t\t\t\t\t\t\t\t\t     pCurrCard->\n\t\t\t\t\t\t\t\t\t     currentSCCB);\n\n\t\t\t\t\t\t\t\t\tif (!\n\t\t\t\t\t\t\t\t\t    (tag))\n\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t    =\n\t\t\t\t\t\t\t\t\t\t    0;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t}\n\t\t\t\t\t\t \n\t\t\t\t\t}\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\t \n\t\t\t\telse {\n\n\t\t\t\t\tACCEPT_MSG_ATN(port);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t \n\t\t\telse {\n\n\t\t\t\tmessage = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tACCEPT_MSG_ATN(port);\n\n\t\t\twhile (!\n\t\t\t       (RDW_HARPOON((port + hp_intstat)) &\n\t\t\t\t(PHASE | RESET))\n\t\t\t       && !(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)\n\t\t\t       && (RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ;\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (message == 0) {\n\t\t\tmsgRetryCount++;\n\t\t\tif (msgRetryCount == 1) {\n\t\t\t\tFPT_SendMsg(port, MSG_PARITY_ERROR);\n\t\t\t} else {\n\t\t\t\tFPT_SendMsg(port, TARGET_RESET);\n\n\t\t\t\tFPT_sssyncv(port, our_target, NARROW_SCSI,\n\t\t\t\t\t    currTar_Info);\n\n\t\t\t\tif (FPT_sccbMgrTbl[p_card][our_target].\n\t\t\t\t    TarEEValue & EE_SYNC_MASK) {\n\n\t\t\t\t\tFPT_sccbMgrTbl[p_card][our_target].\n\t\t\t\t\t    TarStatus &= ~TAR_SYNC_MASK;\n\n\t\t\t\t}\n\n\t\t\t\tif (FPT_sccbMgrTbl[p_card][our_target].\n\t\t\t\t    TarEEValue & EE_WIDE_SCSI) {\n\n\t\t\t\t\tFPT_sccbMgrTbl[p_card][our_target].\n\t\t\t\t\t    TarStatus &= ~TAR_WIDE_MASK;\n\t\t\t\t}\n\n\t\t\t\tFPT_queueFlushTargSccb(p_card, our_target,\n\t\t\t\t\t\t       SCCB_COMPLETE);\n\t\t\t\tFPT_SccbMgrTableInitTarget(p_card, our_target);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} while (message == 0);\n\n\tif (((pCurrCard->globalFlags & F_CONLUN_IO) &&\n\t     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\n\t\tcurrTar_Info->TarLUNBusy[lun] = 1;\n\t\tpCurrCard->currentSCCB =\n\t\t    pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[lun]];\n\t\tif (pCurrCard->currentSCCB != NULL) {\n\t\t\tACCEPT_MSG(port);\n\t\t} else {\n\t\t\tACCEPT_MSG_ATN(port);\n\t\t}\n\t} else {\n\t\tcurrTar_Info->TarLUNBusy[0] = 1;\n\n\t\tif (tag) {\n\t\t\tif (pCurrCard->discQ_Tbl[tag] != NULL) {\n\t\t\t\tpCurrCard->currentSCCB =\n\t\t\t\t    pCurrCard->discQ_Tbl[tag];\n\t\t\t\tcurrTar_Info->TarTagQ_Cnt--;\n\t\t\t\tACCEPT_MSG(port);\n\t\t\t} else {\n\t\t\t\tACCEPT_MSG_ATN(port);\n\t\t\t}\n\t\t} else {\n\t\t\tpCurrCard->currentSCCB =\n\t\t\t    pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]];\n\t\t\tif (pCurrCard->currentSCCB != NULL) {\n\t\t\t\tACCEPT_MSG(port);\n\t\t\t} else {\n\t\t\t\tACCEPT_MSG_ATN(port);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pCurrCard->currentSCCB != NULL) {\n\t\tif (pCurrCard->currentSCCB->Sccb_scsistat == ABORT_ST) {\n\t\t\t \n\t\t\tFPT_queueFindSccb(pCurrCard->currentSCCB, p_card);\n\t\t}\n\t}\n\n\twhile (!(RDW_HARPOON((port + hp_intstat)) & (PHASE | RESET)) &&\n\t       !(RD_HARPOON(port + hp_scsisig) & SCSI_REQ) &&\n\t       (RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ;\n}\n\nstatic void FPT_SendMsg(u32 port, unsigned char message)\n{\n\twhile (!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) {\n\t\tif (!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) {\n\n\t\t\tWRW_HARPOON((port + hp_intstat), PHASE);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWRW_HARPOON((port + hp_intstat), PHASE);\n\tif ((RD_HARPOON(port + hp_scsisig) & S_SCSI_PHZ) == S_MSGO_PH) {\n\t\tWRW_HARPOON((port + hp_intstat),\n\t\t\t    (BUS_FREE | PHASE | XFER_CNT_0));\n\n\t\tWR_HARPOON(port + hp_portctrl_0, SCSI_BUS_EN);\n\n\t\tWR_HARPOON(port + hp_scsidata_0, message);\n\n\t\tWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\n\n\t\tACCEPT_MSG(port);\n\n\t\tWR_HARPOON(port + hp_portctrl_0, 0x00);\n\n\t\tif ((message == ABORT_TASK_SET) || (message == TARGET_RESET) ||\n\t\t    (message == ABORT_TASK)) {\n\t\t\twhile (!\n\t\t\t       (RDW_HARPOON((port + hp_intstat)) &\n\t\t\t\t(BUS_FREE | PHASE))) {\n\t\t\t}\n\n\t\t\tif (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {\n\t\t\t\tWRW_HARPOON((port + hp_intstat), BUS_FREE);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void FPT_sdecm(unsigned char message, u32 port, unsigned char p_card)\n{\n\tstruct sccb *currSCCB;\n\tstruct sccb_card *CurrCard;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tCurrCard = &FPT_BL_Card[p_card];\n\tcurrSCCB = CurrCard->currentSCCB;\n\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\n\n\tif (message == RESTORE_POINTERS) {\n\t\tif (!(currSCCB->Sccb_XferState & F_NO_DATA_YET)) {\n\t\t\tcurrSCCB->Sccb_ATC = currSCCB->Sccb_savedATC;\n\n\t\t\tFPT_hostDataXferRestart(currSCCB);\n\t\t}\n\n\t\tACCEPT_MSG(port);\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t}\n\n\telse if (message == COMMAND_COMPLETE) {\n\n\t\tif (currSCCB->Sccb_scsistat == SELECT_Q_ST) {\n\t\t\tcurrTar_Info->TarStatus &=\n\t\t\t    ~(unsigned char)TAR_TAG_Q_MASK;\n\t\t\tcurrTar_Info->TarStatus |= (unsigned char)TAG_Q_REJECT;\n\t\t}\n\n\t\tACCEPT_MSG(port);\n\n\t}\n\n\telse if ((message == NOP) || (message >= IDENTIFY_BASE) ||\n\t\t (message == INITIATE_RECOVERY) ||\n\t\t (message == RELEASE_RECOVERY)) {\n\n\t\tACCEPT_MSG(port);\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t}\n\n\telse if (message == MESSAGE_REJECT) {\n\n\t\tif ((currSCCB->Sccb_scsistat == SELECT_SN_ST) ||\n\t\t    (currSCCB->Sccb_scsistat == SELECT_WN_ST) ||\n\t\t    ((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)\n\t\t    || ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) ==\n\t\t\tTAG_Q_TRYING))\n\t\t{\n\t\t\tWRW_HARPOON((port + hp_intstat), BUS_FREE);\n\n\t\t\tACCEPT_MSG(port);\n\n\t\t\twhile ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&\n\t\t\t       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))\n\t\t\t{\n\t\t\t}\n\n\t\t\tif (currSCCB->Lun == 0x00) {\n\t\t\t\tif (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\n\n\t\t\t\t\tcurrTar_Info->TarStatus |=\n\t\t\t\t\t    (unsigned char)SYNC_SUPPORTED;\n\n\t\t\t\t\tcurrTar_Info->TarEEValue &=\n\t\t\t\t\t    ~EE_SYNC_MASK;\n\t\t\t\t}\n\n\t\t\t\telse if (currSCCB->Sccb_scsistat ==\n\t\t\t\t\t  SELECT_WN_ST) {\n\n\t\t\t\t\tcurrTar_Info->TarStatus =\n\t\t\t\t\t    (currTar_Info->\n\t\t\t\t\t     TarStatus & ~WIDE_ENABLED) |\n\t\t\t\t\t    WIDE_NEGOCIATED;\n\n\t\t\t\t\tcurrTar_Info->TarEEValue &=\n\t\t\t\t\t    ~EE_WIDE_SCSI;\n\n\t\t\t\t}\n\n\t\t\t\telse if ((currTar_Info->\n\t\t\t\t\t  TarStatus & TAR_TAG_Q_MASK) ==\n\t\t\t\t\t TAG_Q_TRYING) {\n\t\t\t\t\tcurrTar_Info->TarStatus =\n\t\t\t\t\t    (currTar_Info->\n\t\t\t\t\t     TarStatus & ~(unsigned char)\n\t\t\t\t\t     TAR_TAG_Q_MASK) | TAG_Q_REJECT;\n\n\t\t\t\t\tcurrSCCB->ControlByte &= ~F_USE_CMD_Q;\n\t\t\t\t\tCurrCard->discQCount--;\n\t\t\t\t\tCurrCard->discQ_Tbl[currSCCB->\n\t\t\t\t\t\t\t    Sccb_tag] = NULL;\n\t\t\t\t\tcurrSCCB->Sccb_tag = 0x00;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {\n\n\t\t\t\tif (currSCCB->Lun == 0x00) {\n\t\t\t\t\tWRW_HARPOON((port + hp_intstat),\n\t\t\t\t\t\t    BUS_FREE);\n\t\t\t\t\tCurrCard->globalFlags |= F_NEW_SCCB_CMD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tif ((CurrCard->globalFlags & F_CONLUN_IO) &&\n\t\t\t\t    ((currTar_Info->\n\t\t\t\t      TarStatus & TAR_TAG_Q_MASK) !=\n\t\t\t\t     TAG_Q_TRYING))\n\t\t\t\t\tcurrTar_Info->TarLUNBusy[currSCCB->\n\t\t\t\t\t\t\t\t Lun] = 1;\n\t\t\t\telse\n\t\t\t\t\tcurrTar_Info->TarLUNBusy[0] = 1;\n\n\t\t\t\tcurrSCCB->ControlByte &=\n\t\t\t\t    ~(unsigned char)F_USE_CMD_Q;\n\n\t\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tACCEPT_MSG(port);\n\n\t\t\twhile ((!(RD_HARPOON(port + hp_scsisig) & SCSI_REQ)) &&\n\t\t\t       (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)))\n\t\t\t{\n\t\t\t}\n\n\t\t\tif (!(RDW_HARPOON((port + hp_intstat)) & BUS_FREE)) {\n\t\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (message == EXTENDED_MESSAGE) {\n\n\t\tACCEPT_MSG(port);\n\t\tFPT_shandem(port, p_card, currSCCB);\n\t}\n\n\telse if (message == IGNORE_WIDE_RESIDUE) {\n\n\t\tACCEPT_MSG(port);\t \n\n\t\tmessage = FPT_sfm(port, currSCCB);\n\n\t\tif (currSCCB->Sccb_scsimsg != MSG_PARITY_ERROR)\n\t\t\tACCEPT_MSG(port);\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t}\n\n\telse {\n\n\t\tcurrSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;\n\t\tcurrSCCB->Sccb_scsimsg = MESSAGE_REJECT;\n\n\t\tACCEPT_MSG_ATN(port);\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t}\n}\n\n \nstatic void FPT_shandem(u32 port, unsigned char p_card, struct sccb *pCurrSCCB)\n{\n\tunsigned char length, message;\n\n\tlength = FPT_sfm(port, pCurrSCCB);\n\tif (length) {\n\n\t\tACCEPT_MSG(port);\n\t\tmessage = FPT_sfm(port, pCurrSCCB);\n\t\tif (message) {\n\n\t\t\tif (message == EXTENDED_SDTR) {\n\n\t\t\t\tif (length == 0x03) {\n\n\t\t\t\t\tACCEPT_MSG(port);\n\t\t\t\t\tFPT_stsyncn(port, p_card);\n\t\t\t\t} else {\n\n\t\t\t\t\tpCurrSCCB->Sccb_scsimsg = MESSAGE_REJECT;\n\t\t\t\t\tACCEPT_MSG_ATN(port);\n\t\t\t\t}\n\t\t\t} else if (message == EXTENDED_WDTR) {\n\n\t\t\t\tif (length == 0x02) {\n\n\t\t\t\t\tACCEPT_MSG(port);\n\t\t\t\t\tFPT_stwidn(port, p_card);\n\t\t\t\t} else {\n\n\t\t\t\t\tpCurrSCCB->Sccb_scsimsg = MESSAGE_REJECT;\n\t\t\t\t\tACCEPT_MSG_ATN(port);\n\n\t\t\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t\t\t   (AUTO_IMMED +\n\t\t\t\t\t\t    DISCONNECT_START));\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tpCurrSCCB->Sccb_scsimsg = MESSAGE_REJECT;\n\t\t\t\tACCEPT_MSG_ATN(port);\n\n\t\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\t\t}\n\t\t} else {\n\t\t\tif (pCurrSCCB->Sccb_scsimsg != MSG_PARITY_ERROR)\n\t\t\t\tACCEPT_MSG(port);\n\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\t}\n\t} else {\n\t\tif (pCurrSCCB->Sccb_scsimsg == MSG_PARITY_ERROR)\n\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t}\n}\n\n \n\nstatic unsigned char FPT_sisyncn(u32 port, unsigned char p_card,\n\t\t\t\t unsigned char syncFlag)\n{\n\tstruct sccb *currSCCB;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\n\n\tif (!((currTar_Info->TarStatus & TAR_SYNC_MASK) == SYNC_TRYING)) {\n\n\t\tWRW_HARPOON((port + ID_MSG_STRT),\n\t\t\t    (MPM_OP + AMSG_OUT +\n\t\t\t     (currSCCB->\n\t\t\t      Sccb_idmsg & ~(unsigned char)DISC_PRIV)));\n\n\t\tWRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);\n\n\t\tWRW_HARPOON((port + SYNC_MSGS + 0),\n\t\t\t    (MPM_OP + AMSG_OUT + EXTENDED_MESSAGE));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x03));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 4),\n\t\t\t    (MPM_OP + AMSG_OUT + EXTENDED_SDTR));\n\n\t\tif ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)\n\n\t\t\tWRW_HARPOON((port + SYNC_MSGS + 6),\n\t\t\t\t    (MPM_OP + AMSG_OUT + 12));\n\n\t\telse if ((currTar_Info->TarEEValue & EE_SYNC_MASK) ==\n\t\t\t EE_SYNC_10MB)\n\n\t\t\tWRW_HARPOON((port + SYNC_MSGS + 6),\n\t\t\t\t    (MPM_OP + AMSG_OUT + 25));\n\n\t\telse if ((currTar_Info->TarEEValue & EE_SYNC_MASK) ==\n\t\t\t EE_SYNC_5MB)\n\n\t\t\tWRW_HARPOON((port + SYNC_MSGS + 6),\n\t\t\t\t    (MPM_OP + AMSG_OUT + 50));\n\n\t\telse\n\t\t\tWRW_HARPOON((port + SYNC_MSGS + 6),\n\t\t\t\t    (MPM_OP + AMSG_OUT + 00));\n\n\t\tWRW_HARPOON((port + SYNC_MSGS + 8), (RAT_OP));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 10),\n\t\t\t    (MPM_OP + AMSG_OUT + DEFAULT_OFFSET));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 12), (BRH_OP + ALWAYS + NP));\n\n\t\tif (syncFlag == 0) {\n\t\t\tWR_HARPOON(port + hp_autostart_3,\n\t\t\t\t   (SELECT + SELCHK_STRT));\n\t\t\tcurrTar_Info->TarStatus =\n\t\t\t    ((currTar_Info->\n\t\t\t      TarStatus & ~(unsigned char)TAR_SYNC_MASK) |\n\t\t\t     (unsigned char)SYNC_TRYING);\n\t\t} else {\n\t\t\tWR_HARPOON(port + hp_autostart_3,\n\t\t\t\t   (AUTO_IMMED + CMD_ONLY_STRT));\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\telse {\n\n\t\tcurrTar_Info->TarStatus |= (unsigned char)SYNC_SUPPORTED;\n\t\tcurrTar_Info->TarEEValue &= ~EE_SYNC_MASK;\n\t\treturn 0;\n\t}\n}\n\n \nstatic void FPT_stsyncn(u32 port, unsigned char p_card)\n{\n\tunsigned char sync_msg, offset, sync_reg, our_sync_msg;\n\tstruct sccb *currSCCB;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\n\n\tsync_msg = FPT_sfm(port, currSCCB);\n\n\tif ((sync_msg == 0x00) && (currSCCB->Sccb_scsimsg == MSG_PARITY_ERROR)) {\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\treturn;\n\t}\n\n\tACCEPT_MSG(port);\n\n\toffset = FPT_sfm(port, currSCCB);\n\n\tif ((offset == 0x00) && (currSCCB->Sccb_scsimsg == MSG_PARITY_ERROR)) {\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\treturn;\n\t}\n\n\tif ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_20MB)\n\n\t\tour_sync_msg = 12;\t \n\n\telse if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_10MB)\n\n\t\tour_sync_msg = 25;\t \n\n\telse if ((currTar_Info->TarEEValue & EE_SYNC_MASK) == EE_SYNC_5MB)\n\n\t\tour_sync_msg = 50;\t \n\telse\n\n\t\tour_sync_msg = 0;\t \n\n\tif (sync_msg < our_sync_msg) {\n\t\tsync_msg = our_sync_msg;\t \n\t}\n\n\tif (offset == ASYNC)\n\t\tsync_msg = ASYNC;\n\n\tif (offset > MAX_OFFSET)\n\t\toffset = MAX_OFFSET;\n\n\tsync_reg = 0x00;\n\n\tif (sync_msg > 12)\n\n\t\tsync_reg = 0x20;\t \n\n\tif (sync_msg > 25)\n\n\t\tsync_reg = 0x40;\t \n\n\tif (sync_msg > 38)\n\n\t\tsync_reg = 0x60;\t \n\n\tif (sync_msg > 50)\n\n\t\tsync_reg = 0x80;\t \n\n\tif (sync_msg > 62)\n\n\t\tsync_reg = 0xA0;\t \n\n\tif (sync_msg > 75)\n\n\t\tsync_reg = 0xC0;\t \n\n\tif (sync_msg > 87)\n\n\t\tsync_reg = 0xE0;\t \n\n\tif (sync_msg > 100) {\n\n\t\tsync_reg = 0x00;\t \n\t\toffset = 0x00;\n\t}\n\n\tif (currTar_Info->TarStatus & WIDE_ENABLED)\n\n\t\tsync_reg |= offset;\n\n\telse\n\n\t\tsync_reg |= (offset | NARROW_SCSI);\n\n\tFPT_sssyncv(port, currSCCB->TargID, sync_reg, currTar_Info);\n\n\tif (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\n\n\t\tACCEPT_MSG(port);\n\n\t\tcurrTar_Info->TarStatus = ((currTar_Info->TarStatus &\n\t\t\t\t\t    ~(unsigned char)TAR_SYNC_MASK) |\n\t\t\t\t\t   (unsigned char)SYNC_SUPPORTED);\n\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t}\n\n\telse {\n\n\t\tACCEPT_MSG_ATN(port);\n\n\t\tFPT_sisyncr(port, sync_msg, offset);\n\n\t\tcurrTar_Info->TarStatus = ((currTar_Info->TarStatus &\n\t\t\t\t\t    ~(unsigned char)TAR_SYNC_MASK) |\n\t\t\t\t\t   (unsigned char)SYNC_SUPPORTED);\n\t}\n}\n\n \nstatic void FPT_sisyncr(u32 port, unsigned char sync_pulse,\n\t\t\tunsigned char offset)\n{\n\tARAM_ACCESS(port);\n\tWRW_HARPOON((port + SYNC_MSGS + 0),\n\t\t    (MPM_OP + AMSG_OUT + EXTENDED_MESSAGE));\n\tWRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x03));\n\tWRW_HARPOON((port + SYNC_MSGS + 4),\n\t\t    (MPM_OP + AMSG_OUT + EXTENDED_SDTR));\n\tWRW_HARPOON((port + SYNC_MSGS + 6), (MPM_OP + AMSG_OUT + sync_pulse));\n\tWRW_HARPOON((port + SYNC_MSGS + 8), (RAT_OP));\n\tWRW_HARPOON((port + SYNC_MSGS + 10), (MPM_OP + AMSG_OUT + offset));\n\tWRW_HARPOON((port + SYNC_MSGS + 12), (BRH_OP + ALWAYS + NP));\n\tSGRAM_ACCESS(port);\n\n\tWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\n\tWRW_HARPOON((port + hp_intstat), CLR_ALL_INT_1);\n\n\tWR_HARPOON(port + hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));\n\n\twhile (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {\n\t}\n}\n\n \n\nstatic unsigned char FPT_siwidn(u32 port, unsigned char p_card)\n{\n\tstruct sccb *currSCCB;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\n\n\tif (!((currTar_Info->TarStatus & TAR_WIDE_MASK) == WIDE_NEGOCIATED)) {\n\n\t\tWRW_HARPOON((port + ID_MSG_STRT),\n\t\t\t    (MPM_OP + AMSG_OUT +\n\t\t\t     (currSCCB->\n\t\t\t      Sccb_idmsg & ~(unsigned char)DISC_PRIV)));\n\n\t\tWRW_HARPOON((port + ID_MSG_STRT + 2), BRH_OP + ALWAYS + CMDPZ);\n\n\t\tWRW_HARPOON((port + SYNC_MSGS + 0),\n\t\t\t    (MPM_OP + AMSG_OUT + EXTENDED_MESSAGE));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x02));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 4),\n\t\t\t    (MPM_OP + AMSG_OUT + EXTENDED_WDTR));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 6), (RAT_OP));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 8),\n\t\t\t    (MPM_OP + AMSG_OUT + SM16BIT));\n\t\tWRW_HARPOON((port + SYNC_MSGS + 10), (BRH_OP + ALWAYS + NP));\n\n\t\tWR_HARPOON(port + hp_autostart_3, (SELECT + SELCHK_STRT));\n\n\t\tcurrTar_Info->TarStatus = ((currTar_Info->TarStatus &\n\t\t\t\t\t    ~(unsigned char)TAR_WIDE_MASK) |\n\t\t\t\t\t   (unsigned char)WIDE_ENABLED);\n\n\t\treturn 1;\n\t}\n\n\telse {\n\n\t\tcurrTar_Info->TarStatus = ((currTar_Info->TarStatus &\n\t\t\t\t\t    ~(unsigned char)TAR_WIDE_MASK) |\n\t\t\t\t\t   WIDE_NEGOCIATED);\n\n\t\tcurrTar_Info->TarEEValue &= ~EE_WIDE_SCSI;\n\t\treturn 0;\n\t}\n}\n\n \nstatic void FPT_stwidn(u32 port, unsigned char p_card)\n{\n\tunsigned char width;\n\tstruct sccb *currSCCB;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][currSCCB->TargID];\n\n\twidth = FPT_sfm(port, currSCCB);\n\n\tif ((width == 0x00) && (currSCCB->Sccb_scsimsg == MSG_PARITY_ERROR)) {\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\treturn;\n\t}\n\n\tif (!(currTar_Info->TarEEValue & EE_WIDE_SCSI))\n\t\twidth = 0;\n\n\tif (width) {\n\t\tcurrTar_Info->TarStatus |= WIDE_ENABLED;\n\t\twidth = 0;\n\t} else {\n\t\twidth = NARROW_SCSI;\n\t\tcurrTar_Info->TarStatus &= ~WIDE_ENABLED;\n\t}\n\n\tFPT_sssyncv(port, currSCCB->TargID, width, currTar_Info);\n\n\tif (currSCCB->Sccb_scsistat == SELECT_WN_ST) {\n\n\t\tcurrTar_Info->TarStatus |= WIDE_NEGOCIATED;\n\n\t\tif (!\n\t\t    ((currTar_Info->TarStatus & TAR_SYNC_MASK) ==\n\t\t     SYNC_SUPPORTED)) {\n\t\t\tACCEPT_MSG_ATN(port);\n\t\t\tARAM_ACCESS(port);\n\t\t\tFPT_sisyncn(port, p_card, 1);\n\t\t\tcurrSCCB->Sccb_scsistat = SELECT_SN_ST;\n\t\t\tSGRAM_ACCESS(port);\n\t\t} else {\n\t\t\tACCEPT_MSG(port);\n\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\t}\n\t}\n\n\telse {\n\n\t\tACCEPT_MSG_ATN(port);\n\n\t\tif (currTar_Info->TarEEValue & EE_WIDE_SCSI)\n\t\t\twidth = SM16BIT;\n\t\telse\n\t\t\twidth = SM8BIT;\n\n\t\tFPT_siwidr(port, width);\n\n\t\tcurrTar_Info->TarStatus |= (WIDE_NEGOCIATED | WIDE_ENABLED);\n\t}\n}\n\n \nstatic void FPT_siwidr(u32 port, unsigned char width)\n{\n\tARAM_ACCESS(port);\n\tWRW_HARPOON((port + SYNC_MSGS + 0),\n\t\t    (MPM_OP + AMSG_OUT + EXTENDED_MESSAGE));\n\tWRW_HARPOON((port + SYNC_MSGS + 2), (MPM_OP + AMSG_OUT + 0x02));\n\tWRW_HARPOON((port + SYNC_MSGS + 4),\n\t\t    (MPM_OP + AMSG_OUT + EXTENDED_WDTR));\n\tWRW_HARPOON((port + SYNC_MSGS + 6), (RAT_OP));\n\tWRW_HARPOON((port + SYNC_MSGS + 8), (MPM_OP + AMSG_OUT + width));\n\tWRW_HARPOON((port + SYNC_MSGS + 10), (BRH_OP + ALWAYS + NP));\n\tSGRAM_ACCESS(port);\n\n\tWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\n\tWRW_HARPOON((port + hp_intstat), CLR_ALL_INT_1);\n\n\tWR_HARPOON(port + hp_autostart_3, (AUTO_IMMED + CMD_ONLY_STRT));\n\n\twhile (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | AUTO_INT))) {\n\t}\n}\n\n \nstatic void FPT_sssyncv(u32 p_port, unsigned char p_id,\n\t\t\tunsigned char p_sync_value,\n\t\t\tstruct sccb_mgr_tar_info *currTar_Info)\n{\n\tunsigned char index;\n\n\tindex = p_id;\n\n\tswitch (index) {\n\n\tcase 0:\n\t\tindex = 12;\t \n\t\tbreak;\n\tcase 1:\n\t\tindex = 13;\t \n\t\tbreak;\n\tcase 2:\n\t\tindex = 14;\t \n\t\tbreak;\n\tcase 3:\n\t\tindex = 15;\t \n\t\tbreak;\n\tcase 4:\n\t\tindex = 8;\t \n\t\tbreak;\n\tcase 5:\n\t\tindex = 9;\t \n\t\tbreak;\n\tcase 6:\n\t\tindex = 10;\t \n\t\tbreak;\n\tcase 7:\n\t\tindex = 11;\t \n\t\tbreak;\n\tcase 8:\n\t\tindex = 4;\t \n\t\tbreak;\n\tcase 9:\n\t\tindex = 5;\t \n\t\tbreak;\n\tcase 10:\n\t\tindex = 6;\t \n\t\tbreak;\n\tcase 11:\n\t\tindex = 7;\t \n\t\tbreak;\n\tcase 12:\n\t\tindex = 0;\t \n\t\tbreak;\n\tcase 13:\n\t\tindex = 1;\t \n\t\tbreak;\n\tcase 14:\n\t\tindex = 2;\t \n\t\tbreak;\n\tcase 15:\n\t\tindex = 3;\t \n\n\t}\n\n\tWR_HARPOON(p_port + hp_synctarg_base + index, p_sync_value);\n\n\tcurrTar_Info->TarSyncCtrl = p_sync_value;\n}\n\n \nstatic void FPT_sresb(u32 port, unsigned char p_card)\n{\n\tunsigned char scsiID, i;\n\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tWR_HARPOON(port + hp_page_ctrl,\n\t\t   (RD_HARPOON(port + hp_page_ctrl) | G_INT_DISABLE));\n\tWRW_HARPOON((port + hp_intstat), CLR_ALL_INT);\n\n\tWR_HARPOON(port + hp_scsictrl_0, SCSI_RST);\n\n\tscsiID = RD_HARPOON(port + hp_seltimeout);\n\tWR_HARPOON(port + hp_seltimeout, TO_5ms);\n\tWRW_HARPOON((port + hp_intstat), TIMEOUT);\n\n\tWR_HARPOON(port + hp_portctrl_0, (SCSI_PORT | START_TO));\n\n\twhile (!(RDW_HARPOON((port + hp_intstat)) & TIMEOUT)) {\n\t}\n\n\tWR_HARPOON(port + hp_seltimeout, scsiID);\n\n\tWR_HARPOON(port + hp_scsictrl_0, ENA_SCAM_SEL);\n\n\tFPT_Wait(port, TO_5ms);\n\n\tWRW_HARPOON((port + hp_intstat), CLR_ALL_INT);\n\n\tWR_HARPOON(port + hp_int_mask, (RD_HARPOON(port + hp_int_mask) | 0x00));\n\n\tfor (scsiID = 0; scsiID < MAX_SCSI_TAR; scsiID++) {\n\t\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];\n\n\t\tif (currTar_Info->TarEEValue & EE_SYNC_MASK) {\n\t\t\tcurrTar_Info->TarSyncCtrl = 0;\n\t\t\tcurrTar_Info->TarStatus &= ~TAR_SYNC_MASK;\n\t\t}\n\n\t\tif (currTar_Info->TarEEValue & EE_WIDE_SCSI) {\n\t\t\tcurrTar_Info->TarStatus &= ~TAR_WIDE_MASK;\n\t\t}\n\n\t\tFPT_sssyncv(port, scsiID, NARROW_SCSI, currTar_Info);\n\n\t\tFPT_SccbMgrTableInitTarget(p_card, scsiID);\n\t}\n\n\tFPT_BL_Card[p_card].scanIndex = 0x00;\n\tFPT_BL_Card[p_card].currentSCCB = NULL;\n\tFPT_BL_Card[p_card].globalFlags &= ~(F_TAG_STARTED | F_HOST_XFER_ACT\n\t\t\t\t\t     | F_NEW_SCCB_CMD);\n\tFPT_BL_Card[p_card].cmdCounter = 0x00;\n\tFPT_BL_Card[p_card].discQCount = 0x00;\n\tFPT_BL_Card[p_card].tagQ_Lst = 0x01;\n\n\tfor (i = 0; i < QUEUE_DEPTH; i++)\n\t\tFPT_BL_Card[p_card].discQ_Tbl[i] = NULL;\n\n\tWR_HARPOON(port + hp_page_ctrl,\n\t\t   (RD_HARPOON(port + hp_page_ctrl) & ~G_INT_DISABLE));\n\n}\n\n \nstatic void FPT_ssenss(struct sccb_card *pCurrCard)\n{\n\tunsigned char i;\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = pCurrCard->currentSCCB;\n\n\tcurrSCCB->Save_CdbLen = currSCCB->CdbLength;\n\n\tfor (i = 0; i < 6; i++) {\n\n\t\tcurrSCCB->Save_Cdb[i] = currSCCB->Cdb[i];\n\t}\n\n\tcurrSCCB->CdbLength = SIX_BYTE_CMD;\n\tcurrSCCB->Cdb[0] = REQUEST_SENSE;\n\tcurrSCCB->Cdb[1] = currSCCB->Cdb[1] & (unsigned char)0xE0;\t \n\tcurrSCCB->Cdb[2] = 0x00;\n\tcurrSCCB->Cdb[3] = 0x00;\n\tcurrSCCB->Cdb[4] = currSCCB->RequestSenseLength;\n\tcurrSCCB->Cdb[5] = 0x00;\n\n\tcurrSCCB->Sccb_XferCnt = (u32)currSCCB->RequestSenseLength;\n\n\tcurrSCCB->Sccb_ATC = 0x00;\n\n\tcurrSCCB->Sccb_XferState |= F_AUTO_SENSE;\n\n\tcurrSCCB->Sccb_XferState &= ~F_SG_XFER;\n\n\tcurrSCCB->Sccb_idmsg = currSCCB->Sccb_idmsg & ~(unsigned char)DISC_PRIV;\n\n\tcurrSCCB->ControlByte = 0x00;\n\n\tcurrSCCB->Sccb_MGRFlags &= F_STATUSLOADED;\n}\n\n \n\nstatic void FPT_sxfrp(u32 p_port, unsigned char p_card)\n{\n\tunsigned char curr_phz;\n\n\tDISABLE_AUTO(p_port);\n\n\tif (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {\n\n\t\tFPT_hostDataXferAbort(p_port, p_card,\n\t\t\t\t      FPT_BL_Card[p_card].currentSCCB);\n\n\t}\n\n\t \n\n\tif (RDW_HARPOON((p_port + hp_intstat)) &\n\t    (BUS_FREE | XFER_CNT_0 | AUTO_INT))\n\t\treturn;\n\n\tWR_HARPOON(p_port + hp_xfercnt_0, 0x00);\n\n\tcurr_phz = RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ;\n\n\tWRW_HARPOON((p_port + hp_intstat), XFER_CNT_0);\n\n\tWR_HARPOON(p_port + hp_scsisig, curr_phz);\n\n\twhile (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET)) &&\n\t       (curr_phz ==\n\t\t(RD_HARPOON(p_port + hp_scsisig) & (unsigned char)S_SCSI_PHZ)))\n\t{\n\t\tif (curr_phz & (unsigned char)SCSI_IOBIT) {\n\t\t\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t\t\t   (SCSI_PORT | HOST_PORT | SCSI_INBIT));\n\n\t\t\tif (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {\n\t\t\t\tRD_HARPOON(p_port + hp_fifodata_0);\n\t\t\t}\n\t\t} else {\n\t\t\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t\t\t   (SCSI_PORT | HOST_PORT | HOST_WRT));\n\t\t\tif (RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY) {\n\t\t\t\tWR_HARPOON(p_port + hp_fifodata_0, 0xFA);\n\t\t\t}\n\t\t}\n\t}\t\t\t \n\n\twhile (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {\n\t\tif (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ)\n\t\t\tbreak;\n\t}\n\n\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t   (SCSI_PORT | HOST_PORT | SCSI_INBIT));\n\twhile (!(RD_HARPOON(p_port + hp_xferstat) & FIFO_EMPTY)) {\n\t\tRD_HARPOON(p_port + hp_fifodata_0);\n\t}\n\n\tif (!(RDW_HARPOON((p_port + hp_intstat)) & (BUS_FREE | RESET))) {\n\t\tWR_HARPOON(p_port + hp_autostart_0,\n\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\twhile (!(RDW_HARPOON((p_port + hp_intstat)) & AUTO_INT)) {\n\t\t}\n\n\t\tif (RDW_HARPOON((p_port + hp_intstat)) &\n\t\t    (ICMD_COMP | ITAR_DISC))\n\t\t\twhile (!\n\t\t\t       (RDW_HARPOON((p_port + hp_intstat)) &\n\t\t\t\t(BUS_FREE | RSEL))) ;\n\t}\n}\n\n \n\nstatic void FPT_schkdd(u32 port, unsigned char p_card)\n{\n\tunsigned short TimeOutLoop;\n\tunsigned char sPhase;\n\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tif ((currSCCB->Sccb_scsistat != DATA_OUT_ST) &&\n\t    (currSCCB->Sccb_scsistat != DATA_IN_ST)) {\n\t\treturn;\n\t}\n\n\tif (currSCCB->Sccb_XferState & F_ODD_BALL_CNT) {\n\n\t\tcurrSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt - 1);\n\n\t\tcurrSCCB->Sccb_XferCnt = 1;\n\n\t\tcurrSCCB->Sccb_XferState &= ~F_ODD_BALL_CNT;\n\t\tWRW_HARPOON((port + hp_fiforead), (unsigned short)0x00);\n\t\tWR_HARPOON(port + hp_xferstat, 0x00);\n\t}\n\n\telse {\n\n\t\tcurrSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;\n\n\t\tcurrSCCB->Sccb_XferCnt = 0;\n\t}\n\n\tif ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&\n\t    (currSCCB->HostStatus == SCCB_COMPLETE)) {\n\n\t\tcurrSCCB->HostStatus = SCCB_PARITY_ERR;\n\t\tWRW_HARPOON((port + hp_intstat), PARITY);\n\t}\n\n\tFPT_hostDataXferAbort(port, p_card, currSCCB);\n\n\twhile (RD_HARPOON(port + hp_scsisig) & SCSI_ACK) {\n\t}\n\n\tTimeOutLoop = 0;\n\n\twhile (RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY) {\n\t\tif (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {\n\t\t\treturn;\n\t\t}\n\t\tif (RD_HARPOON(port + hp_offsetctr) & (unsigned char)0x1F) {\n\t\t\tbreak;\n\t\t}\n\t\tif (RDW_HARPOON((port + hp_intstat)) & RESET) {\n\t\t\treturn;\n\t\t}\n\t\tif ((RD_HARPOON(port + hp_scsisig) & SCSI_REQ)\n\t\t    || (TimeOutLoop++ > 0x3000))\n\t\t\tbreak;\n\t}\n\n\tsPhase = RD_HARPOON(port + hp_scsisig) & (SCSI_BSY | S_SCSI_PHZ);\n\tif ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) ||\n\t    (RD_HARPOON(port + hp_offsetctr) & (unsigned char)0x1F) ||\n\t    (sPhase == (SCSI_BSY | S_DATAO_PH)) ||\n\t    (sPhase == (SCSI_BSY | S_DATAI_PH))) {\n\n\t\tWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\n\n\t\tif (!(currSCCB->Sccb_XferState & F_ALL_XFERRED)) {\n\t\t\tif (currSCCB->Sccb_XferState & F_HOST_XFER_DIR) {\n\t\t\t\tFPT_phaseDataIn(port, p_card);\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tFPT_phaseDataOut(port, p_card);\n\t\t\t}\n\t\t} else {\n\t\t\tFPT_sxfrp(port, p_card);\n\t\t\tif (!(RDW_HARPOON((port + hp_intstat)) &\n\t\t\t      (BUS_FREE | ICMD_COMP | ITAR_DISC | RESET))) {\n\t\t\t\tWRW_HARPOON((port + hp_intstat), AUTO_INT);\n\t\t\t\tFPT_phaseDecode(port, p_card);\n\t\t\t}\n\t\t}\n\n\t}\n\n\telse {\n\t\tWR_HARPOON(port + hp_portctrl_0, 0x00);\n\t}\n}\n\n \n\nstatic void FPT_sinits(struct sccb *p_sccb, unsigned char p_card)\n{\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tif ((p_sccb->TargID >= MAX_SCSI_TAR) || (p_sccb->Lun >= MAX_LUN)) {\n\t\treturn;\n\t}\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];\n\n\tp_sccb->Sccb_XferState = 0x00;\n\tp_sccb->Sccb_XferCnt = p_sccb->DataLength;\n\n\tif ((p_sccb->OperationCode == SCATTER_GATHER_COMMAND) ||\n\t    (p_sccb->OperationCode == RESIDUAL_SG_COMMAND)) {\n\n\t\tp_sccb->Sccb_SGoffset = 0;\n\t\tp_sccb->Sccb_XferState = F_SG_XFER;\n\t\tp_sccb->Sccb_XferCnt = 0x00;\n\t}\n\n\tif (p_sccb->DataLength == 0x00)\n\n\t\tp_sccb->Sccb_XferState |= F_ALL_XFERRED;\n\n\tif (p_sccb->ControlByte & F_USE_CMD_Q) {\n\t\tif ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) == TAG_Q_REJECT)\n\t\t\tp_sccb->ControlByte &= ~F_USE_CMD_Q;\n\n\t\telse\n\t\t\tcurrTar_Info->TarStatus |= TAG_Q_TRYING;\n\t}\n\n \n\n \n\tif ((currTar_Info->TarStatus & TAR_ALLOW_DISC) ||\n\t    (currTar_Info->TarStatus & TAG_Q_TRYING)) {\n\t\tp_sccb->Sccb_idmsg = IDENTIFY(true, p_sccb->Lun);\n\t} else {\n\t\tp_sccb->Sccb_idmsg = IDENTIFY(false, p_sccb->Lun);\n\t}\n\n\tp_sccb->HostStatus = 0x00;\n\tp_sccb->TargetStatus = 0x00;\n\tp_sccb->Sccb_tag = 0x00;\n\tp_sccb->Sccb_MGRFlags = 0x00;\n\tp_sccb->Sccb_sgseg = 0x00;\n\tp_sccb->Sccb_ATC = 0x00;\n\tp_sccb->Sccb_savedATC = 0x00;\n \n\tp_sccb->Sccb_scsistat = BUS_FREE_ST;\n\tp_sccb->SccbStatus = SCCB_IN_PROCESS;\n\tp_sccb->Sccb_scsimsg = NOP;\n\n}\n\n \n\nstatic void FPT_phaseDecode(u32 p_port, unsigned char p_card)\n{\n\tunsigned char phase_ref;\n\tvoid (*phase) (u32, unsigned char);\n\n\tDISABLE_AUTO(p_port);\n\n\tphase_ref =\n\t    (unsigned char)(RD_HARPOON(p_port + hp_scsisig) & S_SCSI_PHZ);\n\n\tphase = FPT_s_PhaseTbl[phase_ref];\n\n\t(*phase) (p_port, p_card);\t \n}\n\n \n\nstatic void FPT_phaseDataOut(u32 port, unsigned char p_card)\n{\n\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\tif (currSCCB == NULL) {\n\t\treturn;\t\t \n\t}\n\n\tcurrSCCB->Sccb_scsistat = DATA_OUT_ST;\n\tcurrSCCB->Sccb_XferState &= ~(F_HOST_XFER_DIR | F_NO_DATA_YET);\n\n\tWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\n\n\tWRW_HARPOON((port + hp_intstat), XFER_CNT_0);\n\n\tWR_HARPOON(port + hp_autostart_0, (END_DATA + END_DATA_START));\n\n\tFPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);\n\n\tif (currSCCB->Sccb_XferCnt == 0) {\n\n\t\tif ((currSCCB->ControlByte & SCCB_DATA_XFER_OUT) &&\n\t\t    (currSCCB->HostStatus == SCCB_COMPLETE))\n\t\t\tcurrSCCB->HostStatus = SCCB_DATA_OVER_RUN;\n\n\t\tFPT_sxfrp(port, p_card);\n\t\tif (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | RESET)))\n\t\t\tFPT_phaseDecode(port, p_card);\n\t}\n}\n\n \n\nstatic void FPT_phaseDataIn(u32 port, unsigned char p_card)\n{\n\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tif (currSCCB == NULL) {\n\t\treturn;\t\t \n\t}\n\n\tcurrSCCB->Sccb_scsistat = DATA_IN_ST;\n\tcurrSCCB->Sccb_XferState |= F_HOST_XFER_DIR;\n\tcurrSCCB->Sccb_XferState &= ~F_NO_DATA_YET;\n\n\tWR_HARPOON(port + hp_portctrl_0, SCSI_PORT);\n\n\tWRW_HARPOON((port + hp_intstat), XFER_CNT_0);\n\n\tWR_HARPOON(port + hp_autostart_0, (END_DATA + END_DATA_START));\n\n\tFPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);\n\n\tif (currSCCB->Sccb_XferCnt == 0) {\n\n\t\tif ((currSCCB->ControlByte & SCCB_DATA_XFER_IN) &&\n\t\t    (currSCCB->HostStatus == SCCB_COMPLETE))\n\t\t\tcurrSCCB->HostStatus = SCCB_DATA_OVER_RUN;\n\n\t\tFPT_sxfrp(port, p_card);\n\t\tif (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | RESET)))\n\t\t\tFPT_phaseDecode(port, p_card);\n\n\t}\n}\n\n \n\nstatic void FPT_phaseCommand(u32 p_port, unsigned char p_card)\n{\n\tstruct sccb *currSCCB;\n\tu32 cdb_reg;\n\tunsigned char i;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tif (currSCCB->OperationCode == RESET_COMMAND) {\n\n\t\tcurrSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;\n\t\tcurrSCCB->CdbLength = SIX_BYTE_CMD;\n\t}\n\n\tWR_HARPOON(p_port + hp_scsisig, 0x00);\n\n\tARAM_ACCESS(p_port);\n\n\tcdb_reg = p_port + CMD_STRT;\n\n\tfor (i = 0; i < currSCCB->CdbLength; i++) {\n\n\t\tif (currSCCB->OperationCode == RESET_COMMAND)\n\n\t\t\tWRW_HARPOON(cdb_reg, (MPM_OP + ACOMMAND + 0x00));\n\n\t\telse\n\t\t\tWRW_HARPOON(cdb_reg,\n\t\t\t\t    (MPM_OP + ACOMMAND + currSCCB->Cdb[i]));\n\t\tcdb_reg += 2;\n\t}\n\n\tif (currSCCB->CdbLength != TWELVE_BYTE_CMD)\n\t\tWRW_HARPOON(cdb_reg, (BRH_OP + ALWAYS + NP));\n\n\tWR_HARPOON(p_port + hp_portctrl_0, (SCSI_PORT));\n\n\tcurrSCCB->Sccb_scsistat = COMMAND_ST;\n\n\tWR_HARPOON(p_port + hp_autostart_3, (AUTO_IMMED | CMD_ONLY_STRT));\n\tSGRAM_ACCESS(p_port);\n}\n\n \n\nstatic void FPT_phaseStatus(u32 port, unsigned char p_card)\n{\n\t \n\n\tWR_HARPOON(port + hp_scsisig, 0x00);\n\n\tWR_HARPOON(port + hp_autostart_0, (AUTO_IMMED + END_DATA_START));\n}\n\n \n\nstatic void FPT_phaseMsgOut(u32 port, unsigned char p_card)\n{\n\tunsigned char message, scsiID;\n\tstruct sccb *currSCCB;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tif (currSCCB != NULL) {\n\n\t\tmessage = currSCCB->Sccb_scsimsg;\n\t\tscsiID = currSCCB->TargID;\n\n\t\tif (message == TARGET_RESET) {\n\n\t\t\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][scsiID];\n\t\t\tcurrTar_Info->TarSyncCtrl = 0;\n\t\t\tFPT_sssyncv(port, scsiID, NARROW_SCSI, currTar_Info);\n\n\t\t\tif (FPT_sccbMgrTbl[p_card][scsiID].\n\t\t\t    TarEEValue & EE_SYNC_MASK) {\n\n\t\t\t\tFPT_sccbMgrTbl[p_card][scsiID].TarStatus &=\n\t\t\t\t    ~TAR_SYNC_MASK;\n\n\t\t\t}\n\n\t\t\tif (FPT_sccbMgrTbl[p_card][scsiID].\n\t\t\t    TarEEValue & EE_WIDE_SCSI) {\n\n\t\t\t\tFPT_sccbMgrTbl[p_card][scsiID].TarStatus &=\n\t\t\t\t    ~TAR_WIDE_MASK;\n\t\t\t}\n\n\t\t\tFPT_queueFlushSccb(p_card, SCCB_COMPLETE);\n\t\t\tFPT_SccbMgrTableInitTarget(p_card, scsiID);\n\t\t} else if (currSCCB->Sccb_scsistat == ABORT_ST) {\n\t\t\tcurrSCCB->HostStatus = SCCB_COMPLETE;\n\t\t\tif (FPT_BL_Card[p_card].discQ_Tbl[currSCCB->Sccb_tag] !=\n\t\t\t    NULL) {\n\t\t\t\tFPT_BL_Card[p_card].discQ_Tbl[currSCCB->\n\t\t\t\t\t\t\t      Sccb_tag] = NULL;\n\t\t\t\tFPT_sccbMgrTbl[p_card][scsiID].TarTagQ_Cnt--;\n\t\t\t}\n\n\t\t}\n\n\t\telse if (currSCCB->Sccb_scsistat < COMMAND_ST) {\n\n\t\t\tif (message == NOP) {\n\t\t\t\tcurrSCCB->Sccb_MGRFlags |= F_DEV_SELECTED;\n\n\t\t\t\tFPT_ssel(port, p_card);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\tif (message == ABORT_TASK_SET)\n\n\t\t\t\tFPT_queueFlushSccb(p_card, SCCB_COMPLETE);\n\t\t}\n\n\t} else {\n\t\tmessage = ABORT_TASK_SET;\n\t}\n\n\tWRW_HARPOON((port + hp_intstat), (BUS_FREE | PHASE | XFER_CNT_0));\n\n\tWR_HARPOON(port + hp_portctrl_0, SCSI_BUS_EN);\n\n\tWR_HARPOON(port + hp_scsidata_0, message);\n\n\tWR_HARPOON(port + hp_scsisig, (SCSI_ACK + S_ILL_PH));\n\n\tACCEPT_MSG(port);\n\n\tWR_HARPOON(port + hp_portctrl_0, 0x00);\n\n\tif ((message == ABORT_TASK_SET) || (message == TARGET_RESET) ||\n\t    (message == ABORT_TASK)) {\n\n\t\twhile (!(RDW_HARPOON((port + hp_intstat)) & (BUS_FREE | PHASE))) {\n\t\t}\n\n\t\tif (RDW_HARPOON((port + hp_intstat)) & BUS_FREE) {\n\t\t\tWRW_HARPOON((port + hp_intstat), BUS_FREE);\n\n\t\t\tif (currSCCB != NULL) {\n\n\t\t\t\tif ((FPT_BL_Card[p_card].\n\t\t\t\t     globalFlags & F_CONLUN_IO)\n\t\t\t\t    &&\n\t\t\t\t    ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t      TarStatus & TAR_TAG_Q_MASK) !=\n\t\t\t\t     TAG_Q_TRYING))\n\t\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->\n\t\t\t\t\t\t\t       TargID].\n\t\t\t\t\t    TarLUNBusy[currSCCB->Lun] = 0;\n\t\t\t\telse\n\t\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->\n\t\t\t\t\t\t\t       TargID].\n\t\t\t\t\t    TarLUNBusy[0] = 0;\n\n\t\t\t\tFPT_queueCmdComplete(&FPT_BL_Card[p_card],\n\t\t\t\t\t\t     currSCCB, p_card);\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tFPT_BL_Card[p_card].globalFlags |=\n\t\t\t\t    F_NEW_SCCB_CMD;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\n\t\t\tFPT_sxfrp(port, p_card);\n\t\t}\n\t}\n\n\telse {\n\n\t\tif (message == MSG_PARITY_ERROR) {\n\t\t\tcurrSCCB->Sccb_scsimsg = NOP;\n\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\t} else {\n\t\t\tFPT_sxfrp(port, p_card);\n\t\t}\n\t}\n}\n\n \n\nstatic void FPT_phaseMsgIn(u32 port, unsigned char p_card)\n{\n\tunsigned char message;\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tif (FPT_BL_Card[p_card].globalFlags & F_HOST_XFER_ACT) {\n\n\t\tFPT_phaseChkFifo(port, p_card);\n\t}\n\n\tmessage = RD_HARPOON(port + hp_scsidata_0);\n\tif ((message == DISCONNECT) || (message == SAVE_POINTERS)) {\n\n\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t   (AUTO_IMMED + END_DATA_START));\n\n\t}\n\n\telse {\n\n\t\tmessage = FPT_sfm(port, currSCCB);\n\t\tif (message) {\n\n\t\t\tFPT_sdecm(message, port, p_card);\n\n\t\t} else {\n\t\t\tif (currSCCB->Sccb_scsimsg != MSG_PARITY_ERROR)\n\t\t\t\tACCEPT_MSG(port);\n\t\t\tWR_HARPOON(port + hp_autostart_1,\n\t\t\t\t   (AUTO_IMMED + DISCONNECT_START));\n\t\t}\n\t}\n\n}\n\n \n\nstatic void FPT_phaseIllegal(u32 port, unsigned char p_card)\n{\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tWR_HARPOON(port + hp_scsisig, RD_HARPOON(port + hp_scsisig));\n\tif (currSCCB != NULL) {\n\n\t\tcurrSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;\n\t\tcurrSCCB->Sccb_scsistat = ABORT_ST;\n\t\tcurrSCCB->Sccb_scsimsg = ABORT_TASK_SET;\n\t}\n\n\tACCEPT_MSG_ATN(port);\n}\n\n \n\nstatic void FPT_phaseChkFifo(u32 port, unsigned char p_card)\n{\n\tu32 xfercnt;\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tif (currSCCB->Sccb_scsistat == DATA_IN_ST) {\n\n\t\twhile ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) &&\n\t\t       (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)) {\n\t\t}\n\n\t\tif (!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY)) {\n\t\t\tcurrSCCB->Sccb_ATC += currSCCB->Sccb_XferCnt;\n\n\t\t\tcurrSCCB->Sccb_XferCnt = 0;\n\n\t\t\tif ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&\n\t\t\t    (currSCCB->HostStatus == SCCB_COMPLETE)) {\n\t\t\t\tcurrSCCB->HostStatus = SCCB_PARITY_ERR;\n\t\t\t\tWRW_HARPOON((port + hp_intstat), PARITY);\n\t\t\t}\n\n\t\t\tFPT_hostDataXferAbort(port, p_card, currSCCB);\n\n\t\t\tFPT_dataXferProcessor(port, &FPT_BL_Card[p_card]);\n\n\t\t\twhile ((!(RD_HARPOON(port + hp_xferstat) & FIFO_EMPTY))\n\t\t\t       && (RD_HARPOON(port + hp_ext_status) &\n\t\t\t\t   BM_CMD_BUSY)) {\n\t\t\t}\n\n\t\t}\n\t}\n\n\t \n\tGET_XFER_CNT(port, xfercnt);\n\n\tWR_HARPOON(port + hp_xfercnt_0, 0x00);\n\n\tWR_HARPOON(port + hp_portctrl_0, 0x00);\n\n\tcurrSCCB->Sccb_ATC += (currSCCB->Sccb_XferCnt - xfercnt);\n\n\tcurrSCCB->Sccb_XferCnt = xfercnt;\n\n\tif ((RDW_HARPOON((port + hp_intstat)) & PARITY) &&\n\t    (currSCCB->HostStatus == SCCB_COMPLETE)) {\n\n\t\tcurrSCCB->HostStatus = SCCB_PARITY_ERR;\n\t\tWRW_HARPOON((port + hp_intstat), PARITY);\n\t}\n\n\tFPT_hostDataXferAbort(port, p_card, currSCCB);\n\n\tWR_HARPOON(port + hp_fifowrite, 0x00);\n\tWR_HARPOON(port + hp_fiforead, 0x00);\n\tWR_HARPOON(port + hp_xferstat, 0x00);\n\n\tWRW_HARPOON((port + hp_intstat), XFER_CNT_0);\n}\n\n \nstatic void FPT_phaseBusFree(u32 port, unsigned char p_card)\n{\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tif (currSCCB != NULL) {\n\n\t\tDISABLE_AUTO(port);\n\n\t\tif (currSCCB->OperationCode == RESET_COMMAND) {\n\n\t\t\tif ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\n\t\t\t    ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[currSCCB->Lun] = 0;\n\t\t\telse\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[0] = 0;\n\n\t\t\tFPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB,\n\t\t\t\t\t     p_card);\n\n\t\t\tFPT_queueSearchSelect(&FPT_BL_Card[p_card], p_card);\n\n\t\t}\n\n\t\telse if (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\n\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=\n\t\t\t    (unsigned char)SYNC_SUPPORTED;\n\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=\n\t\t\t    ~EE_SYNC_MASK;\n\t\t}\n\n\t\telse if (currSCCB->Sccb_scsistat == SELECT_WN_ST) {\n\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =\n\t\t\t    (FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t     TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;\n\n\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=\n\t\t\t    ~EE_WIDE_SCSI;\n\t\t}\n\n\t\telse if (currSCCB->Sccb_scsistat == SELECT_Q_ST) {\n\t\t\t \n\n\t\t\tif ((!(RD_HARPOON(port + hp_scsisig) & SCSI_BSY)) ||\n\t\t\t    (RDW_HARPOON((port + hp_intstat)) & RSEL)) {\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarStatus &= ~TAR_TAG_Q_MASK;\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarStatus |= TAG_Q_REJECT;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\telse {\n\n\t\t\tcurrSCCB->Sccb_scsistat = BUS_FREE_ST;\n\n\t\t\tif (!currSCCB->HostStatus) {\n\t\t\t\tcurrSCCB->HostStatus = SCCB_PHASE_SEQUENCE_FAIL;\n\t\t\t}\n\n\t\t\tif ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\n\t\t\t    ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[currSCCB->Lun] = 0;\n\t\t\telse\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[0] = 0;\n\n\t\t\tFPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB,\n\t\t\t\t\t     p_card);\n\t\t\treturn;\n\t\t}\n\n\t\tFPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;\n\n\t}\t\t\t \n}\n\n \nstatic void FPT_autoLoadDefaultMap(u32 p_port)\n{\n\tu32 map_addr;\n\n\tARAM_ACCESS(p_port);\n\tmap_addr = p_port + hp_aramBase;\n\n\tWRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0xC0));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0x20));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, RAT_OP);\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + AMSG_OUT + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MPM_OP + ACOMMAND + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CPE_OP + ADATA_OUT + DINT));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (TCB_OP + FIFO_0 + DI));\t \n\tmap_addr += 2;\t\t \n\tWRW_HARPOON(map_addr, (SSI_OP + SSI_IDO_STRT));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CPE_OP + ADATA_IN + DINT));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + ST));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x02));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + DC));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MRR_OP + SDATA + D_AR1));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + ST));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x04));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + UNKNWN));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MRR_OP + SDATA + D_BUCKET));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (SSI_OP + SSI_ITAR_DISC));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CPN_OP + ASTATUS + UNKNWN));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MRR_OP + SDATA + D_AR0));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CPN_OP + AMSG_IN + CC));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (CRD_OP + SDATA + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (BRH_OP + NOT_EQ + CC));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (MRR_OP + SDATA + D_BUCKET));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (SSI_OP + SSI_ICMD_COMP));\t \n\tmap_addr += 2;\n\n\tWRW_HARPOON(map_addr, (SSI_OP + SSI_IUNKWN));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (SSI_OP + SSI_INO_CC));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (SSI_OP + SSI_ITICKLE));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (SSI_OP + SSI_IRFAIL));\t \n\tmap_addr += 2;\t\t \n\tWRW_HARPOON(map_addr, (CRR_OP + AR3 + S_IDREG));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (BRH_OP + EQUAL + 0x00));\t \n\tmap_addr += 2;\n\tWRW_HARPOON(map_addr, (SSI_OP + SSI_INO_CC));\t \n\n\tSGRAM_ACCESS(p_port);\n}\n\n \n\nstatic void FPT_autoCmdCmplt(u32 p_port, unsigned char p_card)\n{\n\tstruct sccb *currSCCB;\n\tunsigned char status_byte;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\n\tstatus_byte = RD_HARPOON(p_port + hp_gp_reg_0);\n\n\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUN_CA = 0;\n\n\tif (status_byte != SAM_STAT_GOOD) {\n\n\t\tif (status_byte == SAM_STAT_TASK_SET_FULL) {\n\n\t\t\tif (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\n\t\t\t     ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t       TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[currSCCB->Lun] = 1;\n\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\tFPT_BL_Card[p_card].discQCount--;\n\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t    discQ_Tbl[FPT_sccbMgrTbl[p_card]\n\t\t\t\t\t      [currSCCB->TargID].\n\t\t\t\t\t      LunDiscQ_Idx[currSCCB->Lun]] =\n\t\t\t\t    NULL;\n\t\t\t} else {\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[0] = 1;\n\t\t\t\tif (currSCCB->Sccb_tag) {\n\t\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\tFPT_BL_Card[p_card].discQ_Tbl[currSCCB->\n\t\t\t\t\t\t\t\t      Sccb_tag]\n\t\t\t\t\t    = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t    discQ_Tbl[FPT_sccbMgrTbl[p_card]\n\t\t\t\t\t\t      [currSCCB->TargID].\n\t\t\t\t\t\t      LunDiscQ_Idx[0]] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrSCCB->Sccb_MGRFlags |= F_STATUSLOADED;\n\n\t\t\tFPT_queueSelectFail(&FPT_BL_Card[p_card], p_card);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (currSCCB->Sccb_scsistat == SELECT_SN_ST) {\n\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus |=\n\t\t\t    (unsigned char)SYNC_SUPPORTED;\n\n\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=\n\t\t\t    ~EE_SYNC_MASK;\n\t\t\tFPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;\n\n\t\t\tif (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\n\t\t\t     ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t       TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[currSCCB->Lun] = 1;\n\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\tFPT_BL_Card[p_card].discQCount--;\n\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t    discQ_Tbl[FPT_sccbMgrTbl[p_card]\n\t\t\t\t\t      [currSCCB->TargID].\n\t\t\t\t\t      LunDiscQ_Idx[currSCCB->Lun]] =\n\t\t\t\t    NULL;\n\t\t\t} else {\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[0] = 1;\n\t\t\t\tif (currSCCB->Sccb_tag) {\n\t\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\tFPT_BL_Card[p_card].discQ_Tbl[currSCCB->\n\t\t\t\t\t\t\t\t      Sccb_tag]\n\t\t\t\t\t    = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t    discQ_Tbl[FPT_sccbMgrTbl[p_card]\n\t\t\t\t\t\t      [currSCCB->TargID].\n\t\t\t\t\t\t      LunDiscQ_Idx[0]] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\n\t\t}\n\n\t\tif (currSCCB->Sccb_scsistat == SELECT_WN_ST) {\n\n\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarStatus =\n\t\t\t    (FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t     TarStatus & ~WIDE_ENABLED) | WIDE_NEGOCIATED;\n\n\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarEEValue &=\n\t\t\t    ~EE_WIDE_SCSI;\n\t\t\tFPT_BL_Card[p_card].globalFlags |= F_NEW_SCCB_CMD;\n\n\t\t\tif (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\n\t\t\t     ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t       TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[currSCCB->Lun] = 1;\n\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\tFPT_BL_Card[p_card].discQCount--;\n\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t    discQ_Tbl[FPT_sccbMgrTbl[p_card]\n\t\t\t\t\t      [currSCCB->TargID].\n\t\t\t\t\t      LunDiscQ_Idx[currSCCB->Lun]] =\n\t\t\t\t    NULL;\n\t\t\t} else {\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUNBusy[0] = 1;\n\t\t\t\tif (currSCCB->Sccb_tag) {\n\t\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\tFPT_BL_Card[p_card].discQ_Tbl[currSCCB->\n\t\t\t\t\t\t\t\t      Sccb_tag]\n\t\t\t\t\t    = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tif (FPT_BL_Card[p_card].discQCount != 0)\n\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t    discQ_Tbl[FPT_sccbMgrTbl[p_card]\n\t\t\t\t\t\t      [currSCCB->TargID].\n\t\t\t\t\t\t      LunDiscQ_Idx[0]] = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\n\t\t}\n\n\t\tif (status_byte == SAM_STAT_CHECK_CONDITION) {\n\t\t\tif (FPT_BL_Card[p_card].globalFlags & F_DO_RENEGO) {\n\t\t\t\tif (FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarEEValue & EE_SYNC_MASK) {\n\t\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->\n\t\t\t\t\t\t\t       TargID].\n\t\t\t\t\t    TarStatus &= ~TAR_SYNC_MASK;\n\t\t\t\t}\n\t\t\t\tif (FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarEEValue & EE_WIDE_SCSI) {\n\t\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->\n\t\t\t\t\t\t\t       TargID].\n\t\t\t\t\t    TarStatus &= ~TAR_WIDE_MASK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!(currSCCB->Sccb_XferState & F_AUTO_SENSE)) {\n\n\t\t\tcurrSCCB->SccbStatus = SCCB_ERROR;\n\t\t\tcurrSCCB->TargetStatus = status_byte;\n\n\t\t\tif (status_byte == SAM_STAT_CHECK_CONDITION) {\n\n\t\t\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t\t\t\t    TarLUN_CA = 1;\n\n\t\t\t\tif (currSCCB->RequestSenseLength !=\n\t\t\t\t    NO_AUTO_REQUEST_SENSE) {\n\n\t\t\t\t\tif (currSCCB->RequestSenseLength == 0)\n\t\t\t\t\t\tcurrSCCB->RequestSenseLength =\n\t\t\t\t\t\t    14;\n\n\t\t\t\t\tFPT_ssenss(&FPT_BL_Card[p_card]);\n\t\t\t\t\tFPT_BL_Card[p_card].globalFlags |=\n\t\t\t\t\t    F_NEW_SCCB_CMD;\n\n\t\t\t\t\tif (((FPT_BL_Card[p_card].\n\t\t\t\t\t      globalFlags & F_CONLUN_IO)\n\t\t\t\t\t     &&\n\t\t\t\t\t     ((FPT_sccbMgrTbl[p_card]\n\t\t\t\t\t       [currSCCB->TargID].\n\t\t\t\t\t       TarStatus & TAR_TAG_Q_MASK) !=\n\t\t\t\t\t      TAG_Q_TRYING))) {\n\t\t\t\t\t\tFPT_sccbMgrTbl[p_card]\n\t\t\t\t\t\t    [currSCCB->TargID].\n\t\t\t\t\t\t    TarLUNBusy[currSCCB->Lun] =\n\t\t\t\t\t\t    1;\n\t\t\t\t\t\tif (FPT_BL_Card[p_card].\n\t\t\t\t\t\t    discQCount != 0)\n\t\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t    discQ_Tbl[FPT_sccbMgrTbl\n\t\t\t\t\t\t\t      [p_card]\n\t\t\t\t\t\t\t      [currSCCB->\n\t\t\t\t\t\t\t       TargID].\n\t\t\t\t\t\t\t      LunDiscQ_Idx\n\t\t\t\t\t\t\t      [currSCCB->Lun]] =\n\t\t\t\t\t\t    NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tFPT_sccbMgrTbl[p_card]\n\t\t\t\t\t\t    [currSCCB->TargID].\n\t\t\t\t\t\t    TarLUNBusy[0] = 1;\n\t\t\t\t\t\tif (currSCCB->Sccb_tag) {\n\t\t\t\t\t\t\tif (FPT_BL_Card[p_card].\n\t\t\t\t\t\t\t    discQCount != 0)\n\t\t\t\t\t\t\t\tFPT_BL_Card\n\t\t\t\t\t\t\t\t    [p_card].\n\t\t\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t\t    discQ_Tbl[currSCCB->\n\t\t\t\t\t\t\t\t      Sccb_tag]\n\t\t\t\t\t\t\t    = NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (FPT_BL_Card[p_card].\n\t\t\t\t\t\t\t    discQCount != 0)\n\t\t\t\t\t\t\t\tFPT_BL_Card\n\t\t\t\t\t\t\t\t    [p_card].\n\t\t\t\t\t\t\t\t    discQCount--;\n\t\t\t\t\t\t\tFPT_BL_Card[p_card].\n\t\t\t\t\t\t\t    discQ_Tbl\n\t\t\t\t\t\t\t    [FPT_sccbMgrTbl\n\t\t\t\t\t\t\t     [p_card][currSCCB->\n\t\t\t\t\t\t\t\t      TargID].\n\t\t\t\t\t\t\t     LunDiscQ_Idx[0]] =\n\t\t\t\t\t\t\t    NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\n\t    ((FPT_sccbMgrTbl[p_card][currSCCB->TargID].\n\t      TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))\n\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[currSCCB->\n\t\t\t\t\t\t\t\t    Lun] = 0;\n\telse\n\t\tFPT_sccbMgrTbl[p_card][currSCCB->TargID].TarLUNBusy[0] = 0;\n\n\tFPT_queueCmdComplete(&FPT_BL_Card[p_card], currSCCB, p_card);\n}\n\n#define SHORT_WAIT   0x0000000F\n#define LONG_WAIT    0x0000FFFFL\n\n \n\nstatic void FPT_dataXferProcessor(u32 port, struct sccb_card *pCurrCard)\n{\n\tstruct sccb *currSCCB;\n\n\tcurrSCCB = pCurrCard->currentSCCB;\n\n\tif (currSCCB->Sccb_XferState & F_SG_XFER) {\n\t\tif (pCurrCard->globalFlags & F_HOST_XFER_ACT)\n\t\t{\n\t\t\tcurrSCCB->Sccb_sgseg += (unsigned char)SG_BUF_CNT;\n\t\t\tcurrSCCB->Sccb_SGoffset = 0x00;\n\t\t}\n\t\tpCurrCard->globalFlags |= F_HOST_XFER_ACT;\n\n\t\tFPT_busMstrSGDataXferStart(port, currSCCB);\n\t}\n\n\telse {\n\t\tif (!(pCurrCard->globalFlags & F_HOST_XFER_ACT)) {\n\t\t\tpCurrCard->globalFlags |= F_HOST_XFER_ACT;\n\n\t\t\tFPT_busMstrDataXferStart(port, currSCCB);\n\t\t}\n\t}\n}\n\n \nstatic void FPT_busMstrSGDataXferStart(u32 p_port, struct sccb *pcurrSCCB)\n{\n\tu32 count, addr, tmpSGCnt;\n\tunsigned int sg_index;\n\tunsigned char sg_count, i;\n\tu32 reg_offset;\n\tstruct blogic_sg_seg *segp;\n\n\tif (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR)\n\t\tcount = ((u32)HOST_RD_CMD) << 24;\n\telse\n\t\tcount = ((u32)HOST_WRT_CMD) << 24;\n\n\tsg_count = 0;\n\ttmpSGCnt = 0;\n\tsg_index = pcurrSCCB->Sccb_sgseg;\n\treg_offset = hp_aramBase;\n\n\ti = (unsigned char)(RD_HARPOON(p_port + hp_page_ctrl) &\n\t\t\t    ~(SGRAM_ARAM | SCATTER_EN));\n\n\tWR_HARPOON(p_port + hp_page_ctrl, i);\n\n\twhile ((sg_count < (unsigned char)SG_BUF_CNT) &&\n\t\t\t((sg_index * (unsigned int)SG_ELEMENT_SIZE) <\n\t\t\tpcurrSCCB->DataLength)) {\n\n\t\tsegp = (struct blogic_sg_seg *)(pcurrSCCB->DataPointer) +\n\t\t\t\tsg_index;\n\t\ttmpSGCnt += segp->segbytes;\n\t\tcount |= segp->segbytes;\n\t\taddr = segp->segdata;\n\n\t\tif ((!sg_count) && (pcurrSCCB->Sccb_SGoffset)) {\n\t\t\taddr +=\n\t\t\t    ((count & 0x00FFFFFFL) - pcurrSCCB->Sccb_SGoffset);\n\t\t\tcount =\n\t\t\t    (count & 0xFF000000L) | pcurrSCCB->Sccb_SGoffset;\n\t\t\ttmpSGCnt = count & 0x00FFFFFFL;\n\t\t}\n\n\t\tWR_HARP32(p_port, reg_offset, addr);\n\t\treg_offset += 4;\n\n\t\tWR_HARP32(p_port, reg_offset, count);\n\t\treg_offset += 4;\n\n\t\tcount &= 0xFF000000L;\n\t\tsg_index++;\n\t\tsg_count++;\n\n\t}\t\t\t \n\n\tpcurrSCCB->Sccb_XferCnt = tmpSGCnt;\n\n\tWR_HARPOON(p_port + hp_sg_addr, (sg_count << 4));\n\n\tif (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {\n\n\t\tWR_HARP32(p_port, hp_xfercnt_0, tmpSGCnt);\n\n\t\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t\t   (DMA_PORT | SCSI_PORT | SCSI_INBIT));\n\t\tWR_HARPOON(p_port + hp_scsisig, S_DATAI_PH);\n\t}\n\n\telse {\n\n\t\tif ((!(RD_HARPOON(p_port + hp_synctarg_0) & NARROW_SCSI)) &&\n\t\t    (tmpSGCnt & 0x000000001)) {\n\n\t\t\tpcurrSCCB->Sccb_XferState |= F_ODD_BALL_CNT;\n\t\t\ttmpSGCnt--;\n\t\t}\n\n\t\tWR_HARP32(p_port, hp_xfercnt_0, tmpSGCnt);\n\n\t\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t\t   (SCSI_PORT | DMA_PORT | DMA_RD));\n\t\tWR_HARPOON(p_port + hp_scsisig, S_DATAO_PH);\n\t}\n\n\tWR_HARPOON(p_port + hp_page_ctrl, (unsigned char)(i | SCATTER_EN));\n\n}\n\n \nstatic void FPT_busMstrDataXferStart(u32 p_port, struct sccb *pcurrSCCB)\n{\n\tu32 addr, count;\n\n\tif (!(pcurrSCCB->Sccb_XferState & F_AUTO_SENSE)) {\n\n\t\tcount = pcurrSCCB->Sccb_XferCnt;\n\n\t\taddr = (u32)(unsigned long)pcurrSCCB->DataPointer + pcurrSCCB->Sccb_ATC;\n\t}\n\n\telse {\n\t\taddr = pcurrSCCB->SensePointer;\n\t\tcount = pcurrSCCB->RequestSenseLength;\n\n\t}\n\n\tHP_SETUP_ADDR_CNT(p_port, addr, count);\n\n\tif (pcurrSCCB->Sccb_XferState & F_HOST_XFER_DIR) {\n\n\t\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t\t   (DMA_PORT | SCSI_PORT | SCSI_INBIT));\n\t\tWR_HARPOON(p_port + hp_scsisig, S_DATAI_PH);\n\n\t\tWR_HARPOON(p_port + hp_xfer_cmd,\n\t\t\t   (XFER_DMA_HOST | XFER_HOST_AUTO | XFER_DMA_8BIT));\n\t}\n\n\telse {\n\n\t\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t\t   (SCSI_PORT | DMA_PORT | DMA_RD));\n\t\tWR_HARPOON(p_port + hp_scsisig, S_DATAO_PH);\n\n\t\tWR_HARPOON(p_port + hp_xfer_cmd,\n\t\t\t   (XFER_HOST_DMA | XFER_HOST_AUTO | XFER_DMA_8BIT));\n\n\t}\n}\n\n \nstatic unsigned char FPT_busMstrTimeOut(u32 p_port)\n{\n\tunsigned long timeout;\n\n\ttimeout = LONG_WAIT;\n\n\tWR_HARPOON(p_port + hp_sys_ctrl, HALT_MACH);\n\n\twhile ((!(RD_HARPOON(p_port + hp_ext_status) & CMD_ABORTED))\n\t       && timeout--) {\n\t}\n\n\tif (RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY) {\n\t\tWR_HARPOON(p_port + hp_sys_ctrl, HARD_ABORT);\n\n\t\ttimeout = LONG_WAIT;\n\t\twhile ((RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY)\n\t\t       && timeout--) {\n\t\t}\n\t}\n\n\tRD_HARPOON(p_port + hp_int_status);\t \n\n\tif (RD_HARPOON(p_port + hp_ext_status) & BM_CMD_BUSY) {\n\t\treturn 1;\n\t}\n\n\telse {\n\t\treturn 0;\n\t}\n}\n\n \nstatic void FPT_hostDataXferAbort(u32 port, unsigned char p_card,\n\t\t\t\t  struct sccb *pCurrSCCB)\n{\n\n\tunsigned long timeout;\n\tunsigned long remain_cnt;\n\tu32 sg_ptr;\n\tstruct blogic_sg_seg *segp;\n\n\tFPT_BL_Card[p_card].globalFlags &= ~F_HOST_XFER_ACT;\n\n\tif (pCurrSCCB->Sccb_XferState & F_AUTO_SENSE) {\n\n\t\tif (!(RD_HARPOON(port + hp_int_status) & INT_CMD_COMPL)) {\n\n\t\t\tWR_HARPOON(port + hp_bm_ctrl,\n\t\t\t\t   (RD_HARPOON(port + hp_bm_ctrl) |\n\t\t\t\t    FLUSH_XFER_CNTR));\n\t\t\ttimeout = LONG_WAIT;\n\n\t\t\twhile ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)\n\t\t\t       && timeout--) {\n\t\t\t}\n\n\t\t\tWR_HARPOON(port + hp_bm_ctrl,\n\t\t\t\t   (RD_HARPOON(port + hp_bm_ctrl) &\n\t\t\t\t    ~FLUSH_XFER_CNTR));\n\n\t\t\tif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\n\n\t\t\t\tif (FPT_busMstrTimeOut(port)) {\n\n\t\t\t\t\tif (pCurrSCCB->HostStatus == 0x00)\n\n\t\t\t\t\t\tpCurrSCCB->HostStatus =\n\t\t\t\t\t\t    SCCB_BM_ERR;\n\n\t\t\t\t}\n\n\t\t\t\tif (RD_HARPOON(port + hp_int_status) &\n\t\t\t\t    INT_EXT_STATUS)\n\n\t\t\t\t\tif (RD_HARPOON(port + hp_ext_status) &\n\t\t\t\t\t    BAD_EXT_STATUS)\n\n\t\t\t\t\t\tif (pCurrSCCB->HostStatus ==\n\t\t\t\t\t\t    0x00)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpCurrSCCB->HostStatus =\n\t\t\t\t\t\t\t    SCCB_BM_ERR;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (pCurrSCCB->Sccb_XferCnt) {\n\n\t\tif (pCurrSCCB->Sccb_XferState & F_SG_XFER) {\n\n\t\t\tWR_HARPOON(port + hp_page_ctrl,\n\t\t\t\t   (RD_HARPOON(port + hp_page_ctrl) &\n\t\t\t\t    ~SCATTER_EN));\n\n\t\t\tWR_HARPOON(port + hp_sg_addr, 0x00);\n\n\t\t\tsg_ptr = pCurrSCCB->Sccb_sgseg + SG_BUF_CNT;\n\n\t\t\tif (sg_ptr >\n\t\t\t    (unsigned int)(pCurrSCCB->DataLength /\n\t\t\t\t\t   SG_ELEMENT_SIZE)) {\n\n\t\t\t\tsg_ptr = (u32)(pCurrSCCB->DataLength /\n\t\t\t\t\t\t\tSG_ELEMENT_SIZE);\n\t\t\t}\n\n\t\t\tremain_cnt = pCurrSCCB->Sccb_XferCnt;\n\n\t\t\twhile (remain_cnt < 0x01000000L) {\n\n\t\t\t\tsg_ptr--;\n\t\t\t\tsegp = (struct blogic_sg_seg *)(pCurrSCCB->\n\t\t\t\t\t\tDataPointer) + (sg_ptr * 2);\n\t\t\t\tif (remain_cnt > (unsigned long)segp->segbytes)\n\t\t\t\t\tremain_cnt -=\n\t\t\t\t\t\t(unsigned long)segp->segbytes;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (remain_cnt < 0x01000000L) {\n\n\t\t\t\tpCurrSCCB->Sccb_SGoffset = remain_cnt;\n\n\t\t\t\tpCurrSCCB->Sccb_sgseg = (unsigned short)sg_ptr;\n\n\t\t\t\tif ((unsigned long)(sg_ptr * SG_ELEMENT_SIZE) ==\n\t\t\t\t    pCurrSCCB->DataLength && (remain_cnt == 0))\n\n\t\t\t\t\tpCurrSCCB->Sccb_XferState |=\n\t\t\t\t\t    F_ALL_XFERRED;\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tif (pCurrSCCB->HostStatus == 0x00) {\n\n\t\t\t\t\tpCurrSCCB->HostStatus =\n\t\t\t\t\t    SCCB_GROSS_FW_ERR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!(pCurrSCCB->Sccb_XferState & F_HOST_XFER_DIR)) {\n\n\t\t\tif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\n\n\t\t\t\tFPT_busMstrTimeOut(port);\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tif (RD_HARPOON(port + hp_int_status) &\n\t\t\t\t    INT_EXT_STATUS) {\n\n\t\t\t\t\tif (RD_HARPOON(port + hp_ext_status) &\n\t\t\t\t\t    BAD_EXT_STATUS) {\n\n\t\t\t\t\t\tif (pCurrSCCB->HostStatus ==\n\t\t\t\t\t\t    0x00) {\n\n\t\t\t\t\t\t\tpCurrSCCB->HostStatus =\n\t\t\t\t\t\t\t    SCCB_BM_ERR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\telse {\n\n\t\t\tif ((RD_HARPOON(port + hp_fifo_cnt)) >= BM_THRESHOLD) {\n\n\t\t\t\ttimeout = SHORT_WAIT;\n\n\t\t\t\twhile ((RD_HARPOON(port + hp_ext_status) &\n\t\t\t\t\tBM_CMD_BUSY)\n\t\t\t\t       && ((RD_HARPOON(port + hp_fifo_cnt)) >=\n\t\t\t\t\t   BM_THRESHOLD) && timeout--) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\n\n\t\t\t\tWR_HARPOON(port + hp_bm_ctrl,\n\t\t\t\t\t   (RD_HARPOON(port + hp_bm_ctrl) |\n\t\t\t\t\t    FLUSH_XFER_CNTR));\n\n\t\t\t\ttimeout = LONG_WAIT;\n\n\t\t\t\twhile ((RD_HARPOON(port + hp_ext_status) &\n\t\t\t\t\tBM_CMD_BUSY) && timeout--) {\n\t\t\t\t}\n\n\t\t\t\tWR_HARPOON(port + hp_bm_ctrl,\n\t\t\t\t\t   (RD_HARPOON(port + hp_bm_ctrl) &\n\t\t\t\t\t    ~FLUSH_XFER_CNTR));\n\n\t\t\t\tif (RD_HARPOON(port + hp_ext_status) &\n\t\t\t\t    BM_CMD_BUSY) {\n\n\t\t\t\t\tif (pCurrSCCB->HostStatus == 0x00) {\n\n\t\t\t\t\t\tpCurrSCCB->HostStatus =\n\t\t\t\t\t\t    SCCB_BM_ERR;\n\t\t\t\t\t}\n\n\t\t\t\t\tFPT_busMstrTimeOut(port);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (RD_HARPOON(port + hp_int_status) & INT_EXT_STATUS) {\n\n\t\t\t\tif (RD_HARPOON(port + hp_ext_status) &\n\t\t\t\t    BAD_EXT_STATUS) {\n\n\t\t\t\t\tif (pCurrSCCB->HostStatus == 0x00) {\n\n\t\t\t\t\t\tpCurrSCCB->HostStatus =\n\t\t\t\t\t\t    SCCB_BM_ERR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\telse {\n\n\t\tif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\n\n\t\t\ttimeout = LONG_WAIT;\n\n\t\t\twhile ((RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY)\n\t\t\t       && timeout--) {\n\t\t\t}\n\n\t\t\tif (RD_HARPOON(port + hp_ext_status) & BM_CMD_BUSY) {\n\n\t\t\t\tif (pCurrSCCB->HostStatus == 0x00) {\n\n\t\t\t\t\tpCurrSCCB->HostStatus = SCCB_BM_ERR;\n\t\t\t\t}\n\n\t\t\t\tFPT_busMstrTimeOut(port);\n\t\t\t}\n\t\t}\n\n\t\tif (RD_HARPOON(port + hp_int_status) & INT_EXT_STATUS) {\n\n\t\t\tif (RD_HARPOON(port + hp_ext_status) & BAD_EXT_STATUS) {\n\n\t\t\t\tif (pCurrSCCB->HostStatus == 0x00) {\n\n\t\t\t\t\tpCurrSCCB->HostStatus = SCCB_BM_ERR;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (pCurrSCCB->Sccb_XferState & F_SG_XFER) {\n\n\t\t\tWR_HARPOON(port + hp_page_ctrl,\n\t\t\t\t   (RD_HARPOON(port + hp_page_ctrl) &\n\t\t\t\t    ~SCATTER_EN));\n\n\t\t\tWR_HARPOON(port + hp_sg_addr, 0x00);\n\n\t\t\tpCurrSCCB->Sccb_sgseg += SG_BUF_CNT;\n\n\t\t\tpCurrSCCB->Sccb_SGoffset = 0x00;\n\n\t\t\tif ((u32)(pCurrSCCB->Sccb_sgseg * SG_ELEMENT_SIZE) >=\n\t\t\t\t\tpCurrSCCB->DataLength) {\n\n\t\t\t\tpCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;\n\t\t\t\tpCurrSCCB->Sccb_sgseg =\n\t\t\t\t    (unsigned short)(pCurrSCCB->DataLength /\n\t\t\t\t\t\t     SG_ELEMENT_SIZE);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tif (!(pCurrSCCB->Sccb_XferState & F_AUTO_SENSE))\n\t\t\t\tpCurrSCCB->Sccb_XferState |= F_ALL_XFERRED;\n\t\t}\n\t}\n\n\tWR_HARPOON(port + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));\n}\n\n \nstatic void FPT_hostDataXferRestart(struct sccb *currSCCB)\n{\n\tunsigned long data_count;\n\tunsigned int sg_index;\n\tstruct blogic_sg_seg *segp;\n\n\tif (currSCCB->Sccb_XferState & F_SG_XFER) {\n\n\t\tcurrSCCB->Sccb_XferCnt = 0;\n\n\t\tsg_index = 0xffff;\t \n\t\tdata_count = 0;\t\t \n\n\n\t\twhile (data_count < currSCCB->Sccb_ATC) {\n\n\t\t\tsg_index++;\n\t\t\tsegp = (struct blogic_sg_seg *)(currSCCB->DataPointer) +\n\t\t\t\t\t\t(sg_index * 2);\n\t\t\tdata_count += segp->segbytes;\n\t\t}\n\n\t\tif (data_count == currSCCB->Sccb_ATC) {\n\n\t\t\tcurrSCCB->Sccb_SGoffset = 0;\n\t\t\tsg_index++;\n\t\t}\n\n\t\telse {\n\t\t\tcurrSCCB->Sccb_SGoffset =\n\t\t\t    data_count - currSCCB->Sccb_ATC;\n\t\t}\n\n\t\tcurrSCCB->Sccb_sgseg = (unsigned short)sg_index;\n\t}\n\n\telse {\n\t\tcurrSCCB->Sccb_XferCnt =\n\t\t    currSCCB->DataLength - currSCCB->Sccb_ATC;\n\t}\n}\n\n \n\nstatic void FPT_scini(unsigned char p_card, unsigned char p_our_id,\n\t\t      unsigned char p_power_up)\n{\n\n\tunsigned char loser, assigned_id;\n\tu32 p_port;\n\n\tunsigned char i, k, ScamFlg;\n\tstruct sccb_card *currCard;\n\tstruct nvram_info *pCurrNvRam;\n\n\tcurrCard = &FPT_BL_Card[p_card];\n\tp_port = currCard->ioPort;\n\tpCurrNvRam = currCard->pNvRamInfo;\n\n\tif (pCurrNvRam) {\n\t\tScamFlg = pCurrNvRam->niScamConf;\n\t\ti = pCurrNvRam->niSysConf;\n\t} else {\n\t\tScamFlg =\n\t\t    (unsigned char)FPT_utilEERead(p_port, SCAM_CONFIG / 2);\n\t\ti = (unsigned\n\t\t     char)(FPT_utilEERead(p_port, (SYSTEM_CONFIG / 2)));\n\t}\n\tif (!(i & 0x02))\t \n\t\treturn;\n\n\tFPT_inisci(p_card, p_port, p_our_id);\n\n\t \n\n\t \n\n\tFPT_Wait1Second(p_port);\n\n\tif ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2)) {\n\t\twhile (!(FPT_scarb(p_port, INIT_SELTD))) {\n\t\t}\n\n\t\tFPT_scsel(p_port);\n\n\t\tdo {\n\t\t\tFPT_scxferc(p_port, SYNC_PTRN);\n\t\t\tFPT_scxferc(p_port, DOM_MSTR);\n\t\t\tloser =\n\t\t\t    FPT_scsendi(p_port,\n\t\t\t\t\t&FPT_scamInfo[p_our_id].id_string[0]);\n\t\t} while (loser == 0xFF);\n\n\t\tFPT_scbusf(p_port);\n\n\t\tif ((p_power_up) && (!loser)) {\n\t\t\tFPT_sresb(p_port, p_card);\n\t\t\tFPT_Wait(p_port, TO_250ms);\n\n\t\t\twhile (!(FPT_scarb(p_port, INIT_SELTD))) {\n\t\t\t}\n\n\t\t\tFPT_scsel(p_port);\n\n\t\t\tdo {\n\t\t\t\tFPT_scxferc(p_port, SYNC_PTRN);\n\t\t\t\tFPT_scxferc(p_port, DOM_MSTR);\n\t\t\t\tloser =\n\t\t\t\t    FPT_scsendi(p_port,\n\t\t\t\t\t\t&FPT_scamInfo[p_our_id].\n\t\t\t\t\t\tid_string[0]);\n\t\t\t} while (loser == 0xFF);\n\n\t\t\tFPT_scbusf(p_port);\n\t\t}\n\t}\n\n\telse {\n\t\tloser = 0;\n\t}\n\n\tif (!loser) {\n\n\t\tFPT_scamInfo[p_our_id].state = ID_ASSIGNED;\n\n\t\tif (ScamFlg & SCAM_ENABLED) {\n\n\t\t\tfor (i = 0; i < MAX_SCSI_TAR; i++) {\n\t\t\t\tif ((FPT_scamInfo[i].state == ID_UNASSIGNED) ||\n\t\t\t\t    (FPT_scamInfo[i].state == ID_UNUSED)) {\n\t\t\t\t\tif (FPT_scsell(p_port, i)) {\n\t\t\t\t\t\tFPT_scamInfo[i].state = LEGACY;\n\t\t\t\t\t\tif ((FPT_scamInfo[i].\n\t\t\t\t\t\t     id_string[0] != 0xFF)\n\t\t\t\t\t\t    || (FPT_scamInfo[i].\n\t\t\t\t\t\t\tid_string[1] != 0xFA)) {\n\n\t\t\t\t\t\t\tFPT_scamInfo[i].\n\t\t\t\t\t\t\t    id_string[0] = 0xFF;\n\t\t\t\t\t\t\tFPT_scamInfo[i].\n\t\t\t\t\t\t\t    id_string[1] = 0xFA;\n\t\t\t\t\t\t\tif (pCurrNvRam == NULL)\n\t\t\t\t\t\t\t\tcurrCard->\n\t\t\t\t\t\t\t\t    globalFlags\n\t\t\t\t\t\t\t\t    |=\n\t\t\t\t\t\t\t\t    F_UPDATE_EEPROM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tFPT_sresb(p_port, p_card);\n\t\t\tFPT_Wait1Second(p_port);\n\t\t\twhile (!(FPT_scarb(p_port, INIT_SELTD))) {\n\t\t\t}\n\t\t\tFPT_scsel(p_port);\n\t\t\tFPT_scasid(p_card, p_port);\n\t\t}\n\n\t}\n\n\telse if ((loser) && (ScamFlg & SCAM_ENABLED)) {\n\t\tFPT_scamInfo[p_our_id].id_string[0] = SLV_TYPE_CODE0;\n\t\tassigned_id = 0;\n\t\tFPT_scwtsel(p_port);\n\n\t\tdo {\n\t\t\twhile (FPT_scxferc(p_port, 0x00) != SYNC_PTRN) {\n\t\t\t}\n\n\t\t\ti = FPT_scxferc(p_port, 0x00);\n\t\t\tif (i == ASSIGN_ID) {\n\t\t\t\tif (!\n\t\t\t\t    (FPT_scsendi\n\t\t\t\t     (p_port,\n\t\t\t\t      &FPT_scamInfo[p_our_id].id_string[0]))) {\n\t\t\t\t\ti = FPT_scxferc(p_port, 0x00);\n\t\t\t\t\tif (FPT_scvalq(i)) {\n\t\t\t\t\t\tk = FPT_scxferc(p_port, 0x00);\n\n\t\t\t\t\t\tif (FPT_scvalq(k)) {\n\t\t\t\t\t\t\tcurrCard->ourId =\n\t\t\t\t\t\t\t    ((unsigned char)(i\n\t\t\t\t\t\t\t\t\t     <<\n\t\t\t\t\t\t\t\t\t     3)\n\t\t\t\t\t\t\t     +\n\t\t\t\t\t\t\t     (k &\n\t\t\t\t\t\t\t      (unsigned char)7))\n\t\t\t\t\t\t\t    & (unsigned char)\n\t\t\t\t\t\t\t    0x3F;\n\t\t\t\t\t\t\tFPT_inisci(p_card,\n\t\t\t\t\t\t\t\t   p_port,\n\t\t\t\t\t\t\t\t   p_our_id);\n\t\t\t\t\t\t\tFPT_scamInfo[currCard->\n\t\t\t\t\t\t\t\t     ourId].\n\t\t\t\t\t\t\t    state = ID_ASSIGNED;\n\t\t\t\t\t\t\tFPT_scamInfo[currCard->\n\t\t\t\t\t\t\t\t     ourId].\n\t\t\t\t\t\t\t    id_string[0]\n\t\t\t\t\t\t\t    = SLV_TYPE_CODE0;\n\t\t\t\t\t\t\tassigned_id = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (i == SET_P_FLAG) {\n\t\t\t\tif (!(FPT_scsendi(p_port,\n\t\t\t\t\t\t  &FPT_scamInfo[p_our_id].\n\t\t\t\t\t\t  id_string[0])))\n\t\t\t\t\tFPT_scamInfo[p_our_id].id_string[0] |=\n\t\t\t\t\t    0x80;\n\t\t\t}\n\t\t} while (!assigned_id);\n\n\t\twhile (FPT_scxferc(p_port, 0x00) != CFG_CMPLT) {\n\t\t}\n\t}\n\n\tif (ScamFlg & SCAM_ENABLED) {\n\t\tFPT_scbusf(p_port);\n\t\tif (currCard->globalFlags & F_UPDATE_EEPROM) {\n\t\t\tFPT_scsavdi(p_card, p_port);\n\t\t\tcurrCard->globalFlags &= ~F_UPDATE_EEPROM;\n\t\t}\n\t}\n\n \n}\n\n \n\nstatic int FPT_scarb(u32 p_port, unsigned char p_sel_type)\n{\n\tif (p_sel_type == INIT_SELTD) {\n\n\t\twhile (RD_HARPOON(p_port + hp_scsisig) & (SCSI_SEL | SCSI_BSY)) {\n\t\t}\n\n\t\tif (RD_HARPOON(p_port + hp_scsisig) & SCSI_SEL)\n\t\t\treturn 0;\n\n\t\tif (RD_HARPOON(p_port + hp_scsidata_0) != 00)\n\t\t\treturn 0;\n\n\t\tWR_HARPOON(p_port + hp_scsisig,\n\t\t\t   (RD_HARPOON(p_port + hp_scsisig) | SCSI_BSY));\n\n\t\tif (RD_HARPOON(p_port + hp_scsisig) & SCSI_SEL) {\n\n\t\t\tWR_HARPOON(p_port + hp_scsisig,\n\t\t\t\t   (RD_HARPOON(p_port + hp_scsisig) &\n\t\t\t\t    ~SCSI_BSY));\n\t\t\treturn 0;\n\t\t}\n\n\t\tWR_HARPOON(p_port + hp_scsisig,\n\t\t\t   (RD_HARPOON(p_port + hp_scsisig) | SCSI_SEL));\n\n\t\tif (RD_HARPOON(p_port + hp_scsidata_0) != 00) {\n\n\t\t\tWR_HARPOON(p_port + hp_scsisig,\n\t\t\t\t   (RD_HARPOON(p_port + hp_scsisig) &\n\t\t\t\t    ~(SCSI_BSY | SCSI_SEL)));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tWR_HARPOON(p_port + hp_clkctrl_0, (RD_HARPOON(p_port + hp_clkctrl_0)\n\t\t\t\t\t   & ~ACTdeassert));\n\tWR_HARPOON(p_port + hp_scsireset, SCAM_EN);\n\tWR_HARPOON(p_port + hp_scsidata_0, 0x00);\n\tWR_HARPOON(p_port + hp_scsidata_1, 0x00);\n\tWR_HARPOON(p_port + hp_portctrl_0, SCSI_BUS_EN);\n\n\tWR_HARPOON(p_port + hp_scsisig,\n\t\t   (RD_HARPOON(p_port + hp_scsisig) | SCSI_MSG));\n\n\tWR_HARPOON(p_port + hp_scsisig, (RD_HARPOON(p_port + hp_scsisig)\n\t\t\t\t\t & ~SCSI_BSY));\n\n\tFPT_Wait(p_port, TO_250ms);\n\n\treturn 1;\n}\n\n \n\nstatic void FPT_scbusf(u32 p_port)\n{\n\tWR_HARPOON(p_port + hp_page_ctrl,\n\t\t   (RD_HARPOON(p_port + hp_page_ctrl) | G_INT_DISABLE));\n\n\tWR_HARPOON(p_port + hp_scsidata_0, 0x00);\n\n\tWR_HARPOON(p_port + hp_portctrl_0, (RD_HARPOON(p_port + hp_portctrl_0)\n\t\t\t\t\t    & ~SCSI_BUS_EN));\n\n\tWR_HARPOON(p_port + hp_scsisig, 0x00);\n\n\tWR_HARPOON(p_port + hp_scsireset, (RD_HARPOON(p_port + hp_scsireset)\n\t\t\t\t\t   & ~SCAM_EN));\n\n\tWR_HARPOON(p_port + hp_clkctrl_0, (RD_HARPOON(p_port + hp_clkctrl_0)\n\t\t\t\t\t   | ACTdeassert));\n\n\tWRW_HARPOON((p_port + hp_intstat), (BUS_FREE | AUTO_INT | SCAM_SEL));\n\n\tWR_HARPOON(p_port + hp_page_ctrl,\n\t\t   (RD_HARPOON(p_port + hp_page_ctrl) & ~G_INT_DISABLE));\n}\n\n \n\nstatic void FPT_scasid(unsigned char p_card, u32 p_port)\n{\n\tunsigned char temp_id_string[ID_STRING_LENGTH];\n\n\tunsigned char i, k, scam_id;\n\tunsigned char crcBytes[3];\n\tstruct nvram_info *pCurrNvRam;\n\tunsigned short *pCrcBytes;\n\n\tpCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;\n\n\ti = 0;\n\n\twhile (!i) {\n\n\t\tfor (k = 0; k < ID_STRING_LENGTH; k++) {\n\t\t\ttemp_id_string[k] = (unsigned char)0x00;\n\t\t}\n\n\t\tFPT_scxferc(p_port, SYNC_PTRN);\n\t\tFPT_scxferc(p_port, ASSIGN_ID);\n\n\t\tif (!(FPT_sciso(p_port, &temp_id_string[0]))) {\n\t\t\tif (pCurrNvRam) {\n\t\t\t\tpCrcBytes = (unsigned short *)&crcBytes[0];\n\t\t\t\t*pCrcBytes = FPT_CalcCrc16(&temp_id_string[0]);\n\t\t\t\tcrcBytes[2] = FPT_CalcLrc(&temp_id_string[0]);\n\t\t\t\ttemp_id_string[1] = crcBytes[2];\n\t\t\t\ttemp_id_string[2] = crcBytes[0];\n\t\t\t\ttemp_id_string[3] = crcBytes[1];\n\t\t\t\tfor (k = 4; k < ID_STRING_LENGTH; k++)\n\t\t\t\t\ttemp_id_string[k] = (unsigned char)0x00;\n\t\t\t}\n\t\t\ti = FPT_scmachid(p_card, temp_id_string);\n\n\t\t\tif (i == CLR_PRIORITY) {\n\t\t\t\tFPT_scxferc(p_port, MISC_CODE);\n\t\t\t\tFPT_scxferc(p_port, CLR_P_FLAG);\n\t\t\t\ti = 0;\t \n\t\t\t}\n\n\t\t\telse if (i != NO_ID_AVAIL) {\n\t\t\t\tif (i < 8)\n\t\t\t\t\tFPT_scxferc(p_port, ID_0_7);\n\t\t\t\telse\n\t\t\t\t\tFPT_scxferc(p_port, ID_8_F);\n\n\t\t\t\tscam_id = (i & (unsigned char)0x07);\n\n\t\t\t\tfor (k = 1; k < 0x08; k <<= 1)\n\t\t\t\t\tif (!(k & i))\n\t\t\t\t\t\tscam_id += 0x08;\t \n\n\t\t\t\tFPT_scxferc(p_port, scam_id);\n\n\t\t\t\ti = 0;\t \n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\ti = 1;\n\t\t}\n\n\t}\t\t\t \n\n\tFPT_scxferc(p_port, SYNC_PTRN);\n\tFPT_scxferc(p_port, CFG_CMPLT);\n}\n\n \n\nstatic void FPT_scsel(u32 p_port)\n{\n\n\tWR_HARPOON(p_port + hp_scsisig, SCSI_SEL);\n\tFPT_scwiros(p_port, SCSI_MSG);\n\n\tWR_HARPOON(p_port + hp_scsisig, (SCSI_SEL | SCSI_BSY));\n\n\tWR_HARPOON(p_port + hp_scsisig,\n\t\t   (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));\n\tWR_HARPOON(p_port + hp_scsidata_0,\n\t\t   (unsigned char)(RD_HARPOON(p_port + hp_scsidata_0) |\n\t\t\t\t   (unsigned char)(BIT(7) + BIT(6))));\n\n\tWR_HARPOON(p_port + hp_scsisig, (SCSI_BSY | SCSI_IOBIT | SCSI_CD));\n\tFPT_scwiros(p_port, SCSI_SEL);\n\n\tWR_HARPOON(p_port + hp_scsidata_0,\n\t\t   (unsigned char)(RD_HARPOON(p_port + hp_scsidata_0) &\n\t\t\t\t   ~(unsigned char)BIT(6)));\n\tFPT_scwirod(p_port, BIT(6));\n\n\tWR_HARPOON(p_port + hp_scsisig,\n\t\t   (SCSI_SEL | SCSI_BSY | SCSI_IOBIT | SCSI_CD));\n}\n\n \n\nstatic unsigned char FPT_scxferc(u32 p_port, unsigned char p_data)\n{\n\tunsigned char curr_data, ret_data;\n\n\tcurr_data = p_data | BIT(7) | BIT(5);\t \n\n\tWR_HARPOON(p_port + hp_scsidata_0, curr_data);\n\n\tcurr_data &= ~BIT(7);\n\n\tWR_HARPOON(p_port + hp_scsidata_0, curr_data);\n\n\tFPT_scwirod(p_port, BIT(7));\t \n\twhile (!(RD_HARPOON(p_port + hp_scsidata_0) & BIT(5))) ;\n\n\tret_data = (RD_HARPOON(p_port + hp_scsidata_0) & (unsigned char)0x1F);\n\n\tcurr_data |= BIT(6);\n\n\tWR_HARPOON(p_port + hp_scsidata_0, curr_data);\n\n\tcurr_data &= ~BIT(5);\n\n\tWR_HARPOON(p_port + hp_scsidata_0, curr_data);\n\n\tFPT_scwirod(p_port, BIT(5));\t \n\n\tcurr_data &= ~(BIT(4) | BIT(3) | BIT(2) | BIT(1) | BIT(0));\t \n\tcurr_data |= BIT(7);\n\n\tWR_HARPOON(p_port + hp_scsidata_0, curr_data);\n\n\tcurr_data &= ~BIT(6);\n\n\tWR_HARPOON(p_port + hp_scsidata_0, curr_data);\n\n\tFPT_scwirod(p_port, BIT(6));\t \n\n\treturn ret_data;\n}\n\n \n\nstatic unsigned char FPT_scsendi(u32 p_port, unsigned char p_id_string[])\n{\n\tunsigned char ret_data, byte_cnt, bit_cnt, defer;\n\n\tdefer = 0;\n\n\tfor (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {\n\n\t\tfor (bit_cnt = 0x80; bit_cnt != 0; bit_cnt >>= 1) {\n\n\t\t\tif (defer)\n\t\t\t\tret_data = FPT_scxferc(p_port, 00);\n\n\t\t\telse if (p_id_string[byte_cnt] & bit_cnt)\n\n\t\t\t\tret_data = FPT_scxferc(p_port, 02);\n\n\t\t\telse {\n\n\t\t\t\tret_data = FPT_scxferc(p_port, 01);\n\t\t\t\tif (ret_data & 02)\n\t\t\t\t\tdefer = 1;\n\t\t\t}\n\n\t\t\tif ((ret_data & 0x1C) == 0x10)\n\t\t\t\treturn 0x00;\t \n\n\t\t\tif (ret_data & 0x1C)\n\t\t\t\treturn 0xFF;\n\n\t\t\tif ((defer) && (!(ret_data & 0x1F)))\n\t\t\t\treturn 0x01;\t \n\n\t\t}\t\t \n\n\t}\t\t\t \n\n\tif (defer)\n\t\treturn 0x01;\t \n\telse\n\t\treturn 0;\t \n}\n\n \n\nstatic unsigned char FPT_sciso(u32 p_port, unsigned char p_id_string[])\n{\n\tunsigned char ret_data, the_data, byte_cnt, bit_cnt;\n\n\tthe_data = 0;\n\n\tfor (byte_cnt = 0; byte_cnt < ID_STRING_LENGTH; byte_cnt++) {\n\n\t\tfor (bit_cnt = 0; bit_cnt < 8; bit_cnt++) {\n\n\t\t\tret_data = FPT_scxferc(p_port, 0);\n\n\t\t\tif (ret_data & 0xFC)\n\t\t\t\treturn 0xFF;\n\n\t\t\telse {\n\n\t\t\t\tthe_data <<= 1;\n\t\t\t\tif (ret_data & BIT(1)) {\n\t\t\t\t\tthe_data |= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ret_data & 0x1F) == 0) {\n \n\t\t\t\tif (byte_cnt)\n\t\t\t\t\treturn 0x00;\n\t\t\t\telse\n\t\t\t\t\treturn 0xFF;\n\t\t\t}\n\n\t\t}\t\t \n\n\t\tp_id_string[byte_cnt] = the_data;\n\n\t}\t\t\t \n\n\treturn 0;\n}\n\n \n\nstatic void FPT_scwirod(u32 p_port, unsigned char p_data_bit)\n{\n\tunsigned char i;\n\n\ti = 0;\n\twhile (i < MAX_SCSI_TAR) {\n\n\t\tif (RD_HARPOON(p_port + hp_scsidata_0) & p_data_bit)\n\n\t\t\ti = 0;\n\n\t\telse\n\n\t\t\ti++;\n\n\t}\n}\n\n \n\nstatic void FPT_scwiros(u32 p_port, unsigned char p_data_bit)\n{\n\tunsigned char i;\n\n\ti = 0;\n\twhile (i < MAX_SCSI_TAR) {\n\n\t\tif (RD_HARPOON(p_port + hp_scsisig) & p_data_bit)\n\n\t\t\ti = 0;\n\n\t\telse\n\n\t\t\ti++;\n\n\t}\n}\n\n \n\nstatic unsigned char FPT_scvalq(unsigned char p_quintet)\n{\n\tunsigned char count;\n\n\tfor (count = 1; count < 0x08; count <<= 1) {\n\t\tif (!(p_quintet & count))\n\t\t\tp_quintet -= 0x80;\n\t}\n\n\tif (p_quintet & 0x18)\n\t\treturn 0;\n\n\telse\n\t\treturn 1;\n}\n\n \n\nstatic unsigned char FPT_scsell(u32 p_port, unsigned char targ_id)\n{\n\tunsigned long i;\n\n\tWR_HARPOON(p_port + hp_page_ctrl,\n\t\t   (RD_HARPOON(p_port + hp_page_ctrl) | G_INT_DISABLE));\n\n\tARAM_ACCESS(p_port);\n\n\tWR_HARPOON(p_port + hp_addstat,\n\t\t   (RD_HARPOON(p_port + hp_addstat) | SCAM_TIMER));\n\tWR_HARPOON(p_port + hp_seltimeout, TO_4ms);\n\n\tfor (i = p_port + CMD_STRT; i < p_port + CMD_STRT + 12; i += 2) {\n\t\tWRW_HARPOON(i, (MPM_OP + ACOMMAND));\n\t}\n\tWRW_HARPOON(i, (BRH_OP + ALWAYS + NP));\n\n\tWRW_HARPOON((p_port + hp_intstat),\n\t\t    (RESET | TIMEOUT | SEL | BUS_FREE | AUTO_INT));\n\n\tWR_HARPOON(p_port + hp_select_id, targ_id);\n\n\tWR_HARPOON(p_port + hp_portctrl_0, SCSI_PORT);\n\tWR_HARPOON(p_port + hp_autostart_3, (SELECT | CMD_ONLY_STRT));\n\tWR_HARPOON(p_port + hp_scsictrl_0, (SEL_TAR | ENA_RESEL));\n\n\twhile (!(RDW_HARPOON((p_port + hp_intstat)) &\n\t\t (RESET | PROG_HLT | TIMEOUT | AUTO_INT))) {\n\t}\n\n\tif (RDW_HARPOON((p_port + hp_intstat)) & RESET)\n\t\tFPT_Wait(p_port, TO_250ms);\n\n\tDISABLE_AUTO(p_port);\n\n\tWR_HARPOON(p_port + hp_addstat,\n\t\t   (RD_HARPOON(p_port + hp_addstat) & ~SCAM_TIMER));\n\tWR_HARPOON(p_port + hp_seltimeout, TO_290ms);\n\n\tSGRAM_ACCESS(p_port);\n\n\tif (RDW_HARPOON((p_port + hp_intstat)) & (RESET | TIMEOUT)) {\n\n\t\tWRW_HARPOON((p_port + hp_intstat),\n\t\t\t    (RESET | TIMEOUT | SEL | BUS_FREE | PHASE));\n\n\t\tWR_HARPOON(p_port + hp_page_ctrl,\n\t\t\t   (RD_HARPOON(p_port + hp_page_ctrl) &\n\t\t\t    ~G_INT_DISABLE));\n\n\t\treturn 0;\t \n\t}\n\n\telse {\n\n\t\twhile (!(RDW_HARPOON((p_port + hp_intstat)) & BUS_FREE)) {\n\t\t\tif (RD_HARPOON(p_port + hp_scsisig) & SCSI_REQ) {\n\t\t\t\tWR_HARPOON(p_port + hp_scsisig,\n\t\t\t\t\t   (SCSI_ACK + S_ILL_PH));\n\t\t\t\tACCEPT_MSG(p_port);\n\t\t\t}\n\t\t}\n\n\t\tWRW_HARPOON((p_port + hp_intstat), CLR_ALL_INT_1);\n\n\t\tWR_HARPOON(p_port + hp_page_ctrl,\n\t\t\t   (RD_HARPOON(p_port + hp_page_ctrl) &\n\t\t\t    ~G_INT_DISABLE));\n\n\t\treturn 1;\t \n\t}\n}\n\n \n\nstatic void FPT_scwtsel(u32 p_port)\n{\n\twhile (!(RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL)) {\n\t}\n}\n\n \n\nstatic void FPT_inisci(unsigned char p_card, u32 p_port, unsigned char p_our_id)\n{\n\tunsigned char i, k, max_id;\n\tunsigned short ee_data;\n\tstruct nvram_info *pCurrNvRam;\n\n\tpCurrNvRam = FPT_BL_Card[p_card].pNvRamInfo;\n\n\tif (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)\n\t\tmax_id = 0x08;\n\n\telse\n\t\tmax_id = 0x10;\n\n\tif (pCurrNvRam) {\n\t\tfor (i = 0; i < max_id; i++) {\n\n\t\t\tfor (k = 0; k < 4; k++)\n\t\t\t\tFPT_scamInfo[i].id_string[k] =\n\t\t\t\t    pCurrNvRam->niScamTbl[i][k];\n\t\t\tfor (k = 4; k < ID_STRING_LENGTH; k++)\n\t\t\t\tFPT_scamInfo[i].id_string[k] =\n\t\t\t\t    (unsigned char)0x00;\n\n\t\t\tif (FPT_scamInfo[i].id_string[0] == 0x00)\n\t\t\t\tFPT_scamInfo[i].state = ID_UNUSED;\t \n\t\t\telse\n\t\t\t\tFPT_scamInfo[i].state = ID_UNASSIGNED;\t \n\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < max_id; i++) {\n\t\t\tfor (k = 0; k < ID_STRING_LENGTH; k += 2) {\n\t\t\t\tee_data =\n\t\t\t\t    FPT_utilEERead(p_port,\n\t\t\t\t\t\t   (unsigned\n\t\t\t\t\t\t    short)((EE_SCAMBASE / 2) +\n\t\t\t\t\t\t\t   (unsigned short)(i *\n\t\t\t\t\t\t\t\t\t    ((unsigned short)ID_STRING_LENGTH / 2)) + (unsigned short)(k / 2)));\n\t\t\t\tFPT_scamInfo[i].id_string[k] =\n\t\t\t\t    (unsigned char)ee_data;\n\t\t\t\tee_data >>= 8;\n\t\t\t\tFPT_scamInfo[i].id_string[k + 1] =\n\t\t\t\t    (unsigned char)ee_data;\n\t\t\t}\n\n\t\t\tif ((FPT_scamInfo[i].id_string[0] == 0x00) ||\n\t\t\t    (FPT_scamInfo[i].id_string[0] == 0xFF))\n\n\t\t\t\tFPT_scamInfo[i].state = ID_UNUSED;\t \n\n\t\t\telse\n\t\t\t\tFPT_scamInfo[i].state = ID_UNASSIGNED;\t \n\n\t\t}\n\t}\n\tfor (k = 0; k < ID_STRING_LENGTH; k++)\n\t\tFPT_scamInfo[p_our_id].id_string[k] = FPT_scamHAString[k];\n\n}\n\n \n\nstatic unsigned char FPT_scmachid(unsigned char p_card,\n\t\t\t\t  unsigned char p_id_string[])\n{\n\n\tunsigned char i, k, match;\n\n\tfor (i = 0; i < MAX_SCSI_TAR; i++) {\n\n\t\tmatch = 1;\n\n\t\tfor (k = 0; k < ID_STRING_LENGTH; k++) {\n\t\t\tif (p_id_string[k] != FPT_scamInfo[i].id_string[k])\n\t\t\t\tmatch = 0;\n\t\t}\n\n\t\tif (match) {\n\t\t\tFPT_scamInfo[i].state = ID_ASSIGNED;\n\t\t\treturn i;\n\t\t}\n\n\t}\n\n\tif (p_id_string[0] & BIT(5))\n\t\ti = 8;\n\telse\n\t\ti = MAX_SCSI_TAR;\n\n\tif (((p_id_string[0] & 0x06) == 0x02)\n\t    || ((p_id_string[0] & 0x06) == 0x04))\n\t\tmatch = p_id_string[1] & (unsigned char)0x1F;\n\telse\n\t\tmatch = 7;\n\n\twhile (i > 0) {\n\t\ti--;\n\n\t\tif (FPT_scamInfo[match].state == ID_UNUSED) {\n\t\t\tfor (k = 0; k < ID_STRING_LENGTH; k++) {\n\t\t\t\tFPT_scamInfo[match].id_string[k] =\n\t\t\t\t    p_id_string[k];\n\t\t\t}\n\n\t\t\tFPT_scamInfo[match].state = ID_ASSIGNED;\n\n\t\t\tif (FPT_BL_Card[p_card].pNvRamInfo == NULL)\n\t\t\t\tFPT_BL_Card[p_card].globalFlags |=\n\t\t\t\t    F_UPDATE_EEPROM;\n\t\t\treturn match;\n\n\t\t}\n\n\t\tmatch--;\n\n\t\tif (match == 0xFF) {\n\t\t\tif (p_id_string[0] & BIT(5))\n\t\t\t\tmatch = 7;\n\t\t\telse\n\t\t\t\tmatch = MAX_SCSI_TAR - 1;\n\t\t}\n\t}\n\n\tif (p_id_string[0] & BIT(7)) {\n\t\treturn CLR_PRIORITY;\n\t}\n\n\tif (p_id_string[0] & BIT(5))\n\t\ti = 8;\n\telse\n\t\ti = MAX_SCSI_TAR;\n\n\tif (((p_id_string[0] & 0x06) == 0x02)\n\t    || ((p_id_string[0] & 0x06) == 0x04))\n\t\tmatch = p_id_string[1] & (unsigned char)0x1F;\n\telse\n\t\tmatch = 7;\n\n\twhile (i > 0) {\n\n\t\ti--;\n\n\t\tif (FPT_scamInfo[match].state == ID_UNASSIGNED) {\n\t\t\tfor (k = 0; k < ID_STRING_LENGTH; k++) {\n\t\t\t\tFPT_scamInfo[match].id_string[k] =\n\t\t\t\t    p_id_string[k];\n\t\t\t}\n\n\t\t\tFPT_scamInfo[match].id_string[0] |= BIT(7);\n\t\t\tFPT_scamInfo[match].state = ID_ASSIGNED;\n\t\t\tif (FPT_BL_Card[p_card].pNvRamInfo == NULL)\n\t\t\t\tFPT_BL_Card[p_card].globalFlags |=\n\t\t\t\t    F_UPDATE_EEPROM;\n\t\t\treturn match;\n\n\t\t}\n\n\t\tmatch--;\n\n\t\tif (match == 0xFF) {\n\t\t\tif (p_id_string[0] & BIT(5))\n\t\t\t\tmatch = 7;\n\t\t\telse\n\t\t\t\tmatch = MAX_SCSI_TAR - 1;\n\t\t}\n\t}\n\n\treturn NO_ID_AVAIL;\n}\n\n \n\nstatic void FPT_scsavdi(unsigned char p_card, u32 p_port)\n{\n\tunsigned char i, k, max_id;\n\tunsigned short ee_data, sum_data;\n\n\tsum_data = 0x0000;\n\n\tfor (i = 1; i < EE_SCAMBASE / 2; i++) {\n\t\tsum_data += FPT_utilEERead(p_port, i);\n\t}\n\n\tFPT_utilEEWriteOnOff(p_port, 1);\t \n\n\tif (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)\n\t\tmax_id = 0x08;\n\n\telse\n\t\tmax_id = 0x10;\n\n\tfor (i = 0; i < max_id; i++) {\n\n\t\tfor (k = 0; k < ID_STRING_LENGTH; k += 2) {\n\t\t\tee_data = FPT_scamInfo[i].id_string[k + 1];\n\t\t\tee_data <<= 8;\n\t\t\tee_data |= FPT_scamInfo[i].id_string[k];\n\t\t\tsum_data += ee_data;\n\t\t\tFPT_utilEEWrite(p_port, ee_data,\n\t\t\t\t\t(unsigned short)((EE_SCAMBASE / 2) +\n\t\t\t\t\t\t\t (unsigned short)(i *\n\t\t\t\t\t\t\t\t\t  ((unsigned short)ID_STRING_LENGTH / 2)) + (unsigned short)(k / 2)));\n\t\t}\n\t}\n\n\tFPT_utilEEWrite(p_port, sum_data, EEPROM_CHECK_SUM / 2);\n\tFPT_utilEEWriteOnOff(p_port, 0);\t \n}\n\n \n\nstatic void FPT_XbowInit(u32 port, unsigned char ScamFlg)\n{\n\tunsigned char i;\n\n\ti = RD_HARPOON(port + hp_page_ctrl);\n\tWR_HARPOON(port + hp_page_ctrl, (unsigned char)(i | G_INT_DISABLE));\n\n\tWR_HARPOON(port + hp_scsireset, 0x00);\n\tWR_HARPOON(port + hp_portctrl_1, HOST_MODE8);\n\n\tWR_HARPOON(port + hp_scsireset, (DMA_RESET | HPSCSI_RESET | PROG_RESET |\n\t\t\t\t\t FIFO_CLR));\n\n\tWR_HARPOON(port + hp_scsireset, SCSI_INI);\n\n\tWR_HARPOON(port + hp_clkctrl_0, CLKCTRL_DEFAULT);\n\n\tWR_HARPOON(port + hp_scsisig, 0x00);\t \n\tWR_HARPOON(port + hp_scsictrl_0, ENA_SCAM_SEL);\n\n\tWRW_HARPOON((port + hp_intstat), CLR_ALL_INT);\n\n\tFPT_default_intena = RESET | RSEL | PROG_HLT | TIMEOUT |\n\t    BUS_FREE | XFER_CNT_0 | AUTO_INT;\n\n\tif ((ScamFlg & SCAM_ENABLED) && (ScamFlg & SCAM_LEVEL2))\n\t\tFPT_default_intena |= SCAM_SEL;\n\n\tWRW_HARPOON((port + hp_intena), FPT_default_intena);\n\n\tWR_HARPOON(port + hp_seltimeout, TO_290ms);\n\n\t \n\tif (RD_HARPOON(port + hp_page_ctrl) & NARROW_SCSI_CARD)\n\t\tWR_HARPOON(port + hp_addstat, SCSI_MODE8);\n\n\tWR_HARPOON(port + hp_page_ctrl, i);\n\n}\n\n \n\nstatic void FPT_BusMasterInit(u32 p_port)\n{\n\n\tWR_HARPOON(p_port + hp_sys_ctrl, DRVR_RST);\n\tWR_HARPOON(p_port + hp_sys_ctrl, 0x00);\n\n\tWR_HARPOON(p_port + hp_host_blk_cnt, XFER_BLK64);\n\n\tWR_HARPOON(p_port + hp_bm_ctrl, (BMCTRL_DEFAULT));\n\n\tWR_HARPOON(p_port + hp_ee_ctrl, (SCSI_TERM_ENA_H));\n\n\tRD_HARPOON(p_port + hp_int_status);\t \n\tWR_HARPOON(p_port + hp_int_mask, (INT_CMD_COMPL | SCSI_INTERRUPT));\n\tWR_HARPOON(p_port + hp_page_ctrl, (RD_HARPOON(p_port + hp_page_ctrl) &\n\t\t\t\t\t   ~SCATTER_EN));\n}\n\n \n\nstatic void FPT_DiagEEPROM(u32 p_port)\n{\n\tunsigned short index, temp, max_wd_cnt;\n\n\tif (RD_HARPOON(p_port + hp_page_ctrl) & NARROW_SCSI_CARD)\n\t\tmax_wd_cnt = EEPROM_WD_CNT;\n\telse\n\t\tmax_wd_cnt = EEPROM_WD_CNT * 2;\n\n\ttemp = FPT_utilEERead(p_port, FW_SIGNATURE / 2);\n\n\tif (temp == 0x4641) {\n\n\t\tfor (index = 2; index < max_wd_cnt; index++) {\n\n\t\t\ttemp += FPT_utilEERead(p_port, index);\n\n\t\t}\n\n\t\tif (temp == FPT_utilEERead(p_port, EEPROM_CHECK_SUM / 2)) {\n\n\t\t\treturn;\t \n\t\t}\n\t}\n\n\tFPT_utilEEWriteOnOff(p_port, (unsigned char)1);\n\n\tfor (index = 0; index < max_wd_cnt; index++) {\n\n\t\tFPT_utilEEWrite(p_port, 0x0000, index);\n\t}\n\n\ttemp = 0;\n\n\tFPT_utilEEWrite(p_port, 0x4641, FW_SIGNATURE / 2);\n\ttemp += 0x4641;\n\tFPT_utilEEWrite(p_port, 0x3920, MODEL_NUMB_0 / 2);\n\ttemp += 0x3920;\n\tFPT_utilEEWrite(p_port, 0x3033, MODEL_NUMB_2 / 2);\n\ttemp += 0x3033;\n\tFPT_utilEEWrite(p_port, 0x2020, MODEL_NUMB_4 / 2);\n\ttemp += 0x2020;\n\tFPT_utilEEWrite(p_port, 0x70D3, SYSTEM_CONFIG / 2);\n\ttemp += 0x70D3;\n\tFPT_utilEEWrite(p_port, 0x0010, BIOS_CONFIG / 2);\n\ttemp += 0x0010;\n\tFPT_utilEEWrite(p_port, 0x0003, SCAM_CONFIG / 2);\n\ttemp += 0x0003;\n\tFPT_utilEEWrite(p_port, 0x0007, ADAPTER_SCSI_ID / 2);\n\ttemp += 0x0007;\n\n\tFPT_utilEEWrite(p_port, 0x0000, IGNORE_B_SCAN / 2);\n\ttemp += 0x0000;\n\tFPT_utilEEWrite(p_port, 0x0000, SEND_START_ENA / 2);\n\ttemp += 0x0000;\n\tFPT_utilEEWrite(p_port, 0x0000, DEVICE_ENABLE / 2);\n\ttemp += 0x0000;\n\n\tFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL01 / 2);\n\ttemp += 0x4242;\n\tFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL23 / 2);\n\ttemp += 0x4242;\n\tFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL45 / 2);\n\ttemp += 0x4242;\n\tFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL67 / 2);\n\ttemp += 0x4242;\n\tFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBL89 / 2);\n\ttemp += 0x4242;\n\tFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLab / 2);\n\ttemp += 0x4242;\n\tFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLcd / 2);\n\ttemp += 0x4242;\n\tFPT_utilEEWrite(p_port, 0x4242, SYNC_RATE_TBLef / 2);\n\ttemp += 0x4242;\n\n\tFPT_utilEEWrite(p_port, 0x6C46, 64 / 2);\t \n\ttemp += 0x6C46;\n\tFPT_utilEEWrite(p_port, 0x7361, 66 / 2);\t \n\ttemp += 0x7361;\n\tFPT_utilEEWrite(p_port, 0x5068, 68 / 2);\n\ttemp += 0x5068;\n\tFPT_utilEEWrite(p_port, 0x696F, 70 / 2);\n\ttemp += 0x696F;\n\tFPT_utilEEWrite(p_port, 0x746E, 72 / 2);\n\ttemp += 0x746E;\n\tFPT_utilEEWrite(p_port, 0x4C20, 74 / 2);\n\ttemp += 0x4C20;\n\tFPT_utilEEWrite(p_port, 0x2054, 76 / 2);\n\ttemp += 0x2054;\n\tFPT_utilEEWrite(p_port, 0x2020, 78 / 2);\n\ttemp += 0x2020;\n\n\tindex = ((EE_SCAMBASE / 2) + (7 * 16));\n\tFPT_utilEEWrite(p_port, (0x0700 + TYPE_CODE0), index);\n\ttemp += (0x0700 + TYPE_CODE0);\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x5542, index);\t \n\ttemp += 0x5542;\t\t \n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x4C53, index);\n\ttemp += 0x4C53;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x474F, index);\n\ttemp += 0x474F;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x4349, index);\n\ttemp += 0x4349;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x5442, index);\t \n\ttemp += 0x5442;\t\t \n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x202D, index);\n\ttemp += 0x202D;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x3339, index);\n\ttemp += 0x3339;\n\tindex++;\t\t \n\tFPT_utilEEWrite(p_port, 0x2030, index);\t \n\ttemp += 0x2030;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x5453, index);\n\ttemp += 0x5453;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x5645, index);\n\ttemp += 0x5645;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x2045, index);\n\ttemp += 0x2045;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x202F, index);\n\ttemp += 0x202F;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x4F4A, index);\n\ttemp += 0x4F4A;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x204E, index);\n\ttemp += 0x204E;\n\tindex++;\n\tFPT_utilEEWrite(p_port, 0x3539, index);\n\ttemp += 0x3539;\n\n\tFPT_utilEEWrite(p_port, temp, EEPROM_CHECK_SUM / 2);\n\n\tFPT_utilEEWriteOnOff(p_port, (unsigned char)0);\n\n}\n\n \n\nstatic void FPT_queueSearchSelect(struct sccb_card *pCurrCard,\n\t\t\t\t  unsigned char p_card)\n{\n\tunsigned char scan_ptr, lun;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\tstruct sccb *pOldSccb;\n\n\tscan_ptr = pCurrCard->scanIndex;\n\tdo {\n\t\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][scan_ptr];\n\t\tif ((pCurrCard->globalFlags & F_CONLUN_IO) &&\n\t\t    ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=\n\t\t     TAG_Q_TRYING)) {\n\t\t\tif (currTar_Info->TarSelQ_Cnt != 0) {\n\n\t\t\t\tscan_ptr++;\n\t\t\t\tif (scan_ptr == MAX_SCSI_TAR)\n\t\t\t\t\tscan_ptr = 0;\n\n\t\t\t\tfor (lun = 0; lun < MAX_LUN; lun++) {\n\t\t\t\t\tif (currTar_Info->TarLUNBusy[lun] == 0) {\n\n\t\t\t\t\t\tpCurrCard->currentSCCB =\n\t\t\t\t\t\t    currTar_Info->TarSelQ_Head;\n\t\t\t\t\t\tpOldSccb = NULL;\n\n\t\t\t\t\t\twhile ((pCurrCard->\n\t\t\t\t\t\t\tcurrentSCCB != NULL)\n\t\t\t\t\t\t       && (lun !=\n\t\t\t\t\t\t\t   pCurrCard->\n\t\t\t\t\t\t\t   currentSCCB->Lun)) {\n\t\t\t\t\t\t\tpOldSccb =\n\t\t\t\t\t\t\t    pCurrCard->\n\t\t\t\t\t\t\t    currentSCCB;\n\t\t\t\t\t\t\tpCurrCard->currentSCCB =\n\t\t\t\t\t\t\t    (struct sccb\n\t\t\t\t\t\t\t     *)(pCurrCard->\n\t\t\t\t\t\t\t\tcurrentSCCB)->\n\t\t\t\t\t\t\t    Sccb_forwardlink;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pCurrCard->currentSCCB ==\n\t\t\t\t\t\t    NULL)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (pOldSccb != NULL) {\n\t\t\t\t\t\t\tpOldSccb->\n\t\t\t\t\t\t\t    Sccb_forwardlink =\n\t\t\t\t\t\t\t    (struct sccb\n\t\t\t\t\t\t\t     *)(pCurrCard->\n\t\t\t\t\t\t\t\tcurrentSCCB)->\n\t\t\t\t\t\t\t    Sccb_forwardlink;\n\t\t\t\t\t\t\tpOldSccb->\n\t\t\t\t\t\t\t    Sccb_backlink =\n\t\t\t\t\t\t\t    (struct sccb\n\t\t\t\t\t\t\t     *)(pCurrCard->\n\t\t\t\t\t\t\t\tcurrentSCCB)->\n\t\t\t\t\t\t\t    Sccb_backlink;\n\t\t\t\t\t\t\tcurrTar_Info->\n\t\t\t\t\t\t\t    TarSelQ_Cnt--;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrTar_Info->\n\t\t\t\t\t\t\t    TarSelQ_Head =\n\t\t\t\t\t\t\t    (struct sccb\n\t\t\t\t\t\t\t     *)(pCurrCard->\n\t\t\t\t\t\t\t\tcurrentSCCB)->\n\t\t\t\t\t\t\t    Sccb_forwardlink;\n\n\t\t\t\t\t\t\tif (currTar_Info->\n\t\t\t\t\t\t\t    TarSelQ_Head ==\n\t\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\t\tcurrTar_Info->\n\t\t\t\t\t\t\t\t    TarSelQ_Tail\n\t\t\t\t\t\t\t\t    = NULL;\n\t\t\t\t\t\t\t\tcurrTar_Info->\n\t\t\t\t\t\t\t\t    TarSelQ_Cnt\n\t\t\t\t\t\t\t\t    = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcurrTar_Info->\n\t\t\t\t\t\t\t\t    TarSelQ_Cnt--;\n\t\t\t\t\t\t\t\tcurrTar_Info->\n\t\t\t\t\t\t\t\t    TarSelQ_Head->\n\t\t\t\t\t\t\t\t    Sccb_backlink\n\t\t\t\t\t\t\t\t    =\n\t\t\t\t\t\t\t\t    (struct sccb\n\t\t\t\t\t\t\t\t     *)NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpCurrCard->scanIndex = scan_ptr;\n\n\t\t\t\t\t\tpCurrCard->globalFlags |=\n\t\t\t\t\t\t    F_NEW_SCCB_CMD;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tscan_ptr++;\n\t\t\t\tif (scan_ptr == MAX_SCSI_TAR) {\n\t\t\t\t\tscan_ptr = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tif ((currTar_Info->TarSelQ_Cnt != 0) &&\n\t\t\t    (currTar_Info->TarLUNBusy[0] == 0)) {\n\n\t\t\t\tpCurrCard->currentSCCB =\n\t\t\t\t    currTar_Info->TarSelQ_Head;\n\n\t\t\t\tcurrTar_Info->TarSelQ_Head =\n\t\t\t\t    (struct sccb *)(pCurrCard->currentSCCB)->\n\t\t\t\t    Sccb_forwardlink;\n\n\t\t\t\tif (currTar_Info->TarSelQ_Head == NULL) {\n\t\t\t\t\tcurrTar_Info->TarSelQ_Tail = NULL;\n\t\t\t\t\tcurrTar_Info->TarSelQ_Cnt = 0;\n\t\t\t\t} else {\n\t\t\t\t\tcurrTar_Info->TarSelQ_Cnt--;\n\t\t\t\t\tcurrTar_Info->TarSelQ_Head->\n\t\t\t\t\t    Sccb_backlink = (struct sccb *)NULL;\n\t\t\t\t}\n\n\t\t\t\tscan_ptr++;\n\t\t\t\tif (scan_ptr == MAX_SCSI_TAR)\n\t\t\t\t\tscan_ptr = 0;\n\n\t\t\t\tpCurrCard->scanIndex = scan_ptr;\n\n\t\t\t\tpCurrCard->globalFlags |= F_NEW_SCCB_CMD;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tscan_ptr++;\n\t\t\t\tif (scan_ptr == MAX_SCSI_TAR) {\n\t\t\t\t\tscan_ptr = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (scan_ptr != pCurrCard->scanIndex);\n}\n\n \n\nstatic void FPT_queueSelectFail(struct sccb_card *pCurrCard,\n\t\t\t\tunsigned char p_card)\n{\n\tunsigned char thisTarg;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tif (pCurrCard->currentSCCB != NULL) {\n\t\tthisTarg =\n\t\t    (unsigned char)(((struct sccb *)(pCurrCard->currentSCCB))->\n\t\t\t\t    TargID);\n\t\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];\n\n\t\tpCurrCard->currentSCCB->Sccb_backlink = (struct sccb *)NULL;\n\n\t\tpCurrCard->currentSCCB->Sccb_forwardlink =\n\t\t    currTar_Info->TarSelQ_Head;\n\n\t\tif (currTar_Info->TarSelQ_Cnt == 0) {\n\t\t\tcurrTar_Info->TarSelQ_Tail = pCurrCard->currentSCCB;\n\t\t}\n\n\t\telse {\n\t\t\tcurrTar_Info->TarSelQ_Head->Sccb_backlink =\n\t\t\t    pCurrCard->currentSCCB;\n\t\t}\n\n\t\tcurrTar_Info->TarSelQ_Head = pCurrCard->currentSCCB;\n\n\t\tpCurrCard->currentSCCB = NULL;\n\t\tcurrTar_Info->TarSelQ_Cnt++;\n\t}\n}\n\n \n\nstatic void FPT_queueCmdComplete(struct sccb_card *pCurrCard,\n\t\t\t\t struct sccb *p_sccb, unsigned char p_card)\n{\n\n\tunsigned char i, SCSIcmd;\n\tCALL_BK_FN callback;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tSCSIcmd = p_sccb->Cdb[0];\n\n\tif (!(p_sccb->Sccb_XferState & F_ALL_XFERRED)) {\n\n\t\tif ((p_sccb->\n\t\t     ControlByte & (SCCB_DATA_XFER_OUT | SCCB_DATA_XFER_IN))\n\t\t    && (p_sccb->HostStatus == SCCB_COMPLETE)\n\t\t    && (p_sccb->TargetStatus != SAM_STAT_CHECK_CONDITION))\n\n\t\t\tif ((SCSIcmd == READ_6) ||\n\t\t\t    (SCSIcmd == WRITE_6) ||\n\t\t\t    (SCSIcmd == READ_10) ||\n\t\t\t    (SCSIcmd == WRITE_10) ||\n\t\t\t    (SCSIcmd == WRITE_VERIFY) ||\n\t\t\t    (SCSIcmd == START_STOP) ||\n\t\t\t    (pCurrCard->globalFlags & F_NO_FILTER)\n\t\t\t    )\n\t\t\t\tp_sccb->HostStatus = SCCB_DATA_UNDER_RUN;\n\t}\n\n\tif (p_sccb->SccbStatus == SCCB_IN_PROCESS) {\n\t\tif (p_sccb->HostStatus || p_sccb->TargetStatus)\n\t\t\tp_sccb->SccbStatus = SCCB_ERROR;\n\t\telse\n\t\t\tp_sccb->SccbStatus = SCCB_SUCCESS;\n\t}\n\n\tif (p_sccb->Sccb_XferState & F_AUTO_SENSE) {\n\n\t\tp_sccb->CdbLength = p_sccb->Save_CdbLen;\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tp_sccb->Cdb[i] = p_sccb->Save_Cdb[i];\n\t\t}\n\t}\n\n\tif ((p_sccb->OperationCode == RESIDUAL_SG_COMMAND) ||\n\t    (p_sccb->OperationCode == RESIDUAL_COMMAND)) {\n\n\t\tFPT_utilUpdateResidual(p_sccb);\n\t}\n\n\tpCurrCard->cmdCounter--;\n\tif (!pCurrCard->cmdCounter) {\n\n\t\tif (pCurrCard->globalFlags & F_GREEN_PC) {\n\t\t\tWR_HARPOON(pCurrCard->ioPort + hp_clkctrl_0,\n\t\t\t\t   (PWR_DWN | CLKCTRL_DEFAULT));\n\t\t\tWR_HARPOON(pCurrCard->ioPort + hp_sys_ctrl, STOP_CLK);\n\t\t}\n\n\t\tWR_HARPOON(pCurrCard->ioPort + hp_semaphore,\n\t\t\t   (RD_HARPOON(pCurrCard->ioPort + hp_semaphore) &\n\t\t\t    ~SCCB_MGR_ACTIVE));\n\n\t}\n\n\tif (pCurrCard->discQCount != 0) {\n\t\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];\n\t\tif (((pCurrCard->globalFlags & F_CONLUN_IO) &&\n\t\t     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) !=\n\t\t      TAG_Q_TRYING))) {\n\t\t\tpCurrCard->discQCount--;\n\t\t\tpCurrCard->discQ_Tbl[currTar_Info->\n\t\t\t\t\t     LunDiscQ_Idx[p_sccb->Lun]] = NULL;\n\t\t} else {\n\t\t\tif (p_sccb->Sccb_tag) {\n\t\t\t\tpCurrCard->discQCount--;\n\t\t\t\tpCurrCard->discQ_Tbl[p_sccb->Sccb_tag] = NULL;\n\t\t\t} else {\n\t\t\t\tpCurrCard->discQCount--;\n\t\t\t\tpCurrCard->discQ_Tbl[currTar_Info->\n\t\t\t\t\t\t     LunDiscQ_Idx[0]] = NULL;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tcallback = (CALL_BK_FN) p_sccb->SccbCallback;\n\tcallback(p_sccb);\n\tpCurrCard->globalFlags |= F_NEW_SCCB_CMD;\n\tpCurrCard->currentSCCB = NULL;\n}\n\n \nstatic void FPT_queueDisconnect(struct sccb *p_sccb, unsigned char p_card)\n{\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][p_sccb->TargID];\n\n\tif (((FPT_BL_Card[p_card].globalFlags & F_CONLUN_IO) &&\n\t     ((currTar_Info->TarStatus & TAR_TAG_Q_MASK) != TAG_Q_TRYING))) {\n\t\tFPT_BL_Card[p_card].discQ_Tbl[currTar_Info->\n\t\t\t\t\t      LunDiscQ_Idx[p_sccb->Lun]] =\n\t\t    p_sccb;\n\t} else {\n\t\tif (p_sccb->Sccb_tag) {\n\t\t\tFPT_BL_Card[p_card].discQ_Tbl[p_sccb->Sccb_tag] =\n\t\t\t    p_sccb;\n\t\t\tFPT_sccbMgrTbl[p_card][p_sccb->TargID].TarLUNBusy[0] =\n\t\t\t    0;\n\t\t\tFPT_sccbMgrTbl[p_card][p_sccb->TargID].TarTagQ_Cnt++;\n\t\t} else {\n\t\t\tFPT_BL_Card[p_card].discQ_Tbl[currTar_Info->\n\t\t\t\t\t\t      LunDiscQ_Idx[0]] = p_sccb;\n\t\t}\n\t}\n\tFPT_BL_Card[p_card].currentSCCB = NULL;\n}\n\n \n\nstatic void FPT_queueFlushSccb(unsigned char p_card, unsigned char error_code)\n{\n\tunsigned char qtag, thisTarg;\n\tstruct sccb *currSCCB;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrSCCB = FPT_BL_Card[p_card].currentSCCB;\n\tif (currSCCB != NULL) {\n\t\tthisTarg = (unsigned char)currSCCB->TargID;\n\t\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];\n\n\t\tfor (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {\n\n\t\t\tif (FPT_BL_Card[p_card].discQ_Tbl[qtag] &&\n\t\t\t    (FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID ==\n\t\t\t     thisTarg)) {\n\n\t\t\t\tFPT_BL_Card[p_card].discQ_Tbl[qtag]->\n\t\t\t\t    HostStatus = (unsigned char)error_code;\n\n\t\t\t\tFPT_queueCmdComplete(&FPT_BL_Card[p_card],\n\t\t\t\t\t\t     FPT_BL_Card[p_card].\n\t\t\t\t\t\t     discQ_Tbl[qtag], p_card);\n\n\t\t\t\tFPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;\n\t\t\t\tcurrTar_Info->TarTagQ_Cnt--;\n\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n \n\nstatic void FPT_queueFlushTargSccb(unsigned char p_card, unsigned char thisTarg,\n\t\t\t\t   unsigned char error_code)\n{\n\tunsigned char qtag;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][thisTarg];\n\n\tfor (qtag = 0; qtag < QUEUE_DEPTH; qtag++) {\n\n\t\tif (FPT_BL_Card[p_card].discQ_Tbl[qtag] &&\n\t\t    (FPT_BL_Card[p_card].discQ_Tbl[qtag]->TargID == thisTarg)) {\n\n\t\t\tFPT_BL_Card[p_card].discQ_Tbl[qtag]->HostStatus =\n\t\t\t    (unsigned char)error_code;\n\n\t\t\tFPT_queueCmdComplete(&FPT_BL_Card[p_card],\n\t\t\t\t\t     FPT_BL_Card[p_card].\n\t\t\t\t\t     discQ_Tbl[qtag], p_card);\n\n\t\t\tFPT_BL_Card[p_card].discQ_Tbl[qtag] = NULL;\n\t\t\tcurrTar_Info->TarTagQ_Cnt--;\n\n\t\t}\n\t}\n\n}\n\nstatic void FPT_queueAddSccb(struct sccb *p_SCCB, unsigned char p_card)\n{\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];\n\n\tp_SCCB->Sccb_forwardlink = NULL;\n\n\tp_SCCB->Sccb_backlink = currTar_Info->TarSelQ_Tail;\n\n\tif (currTar_Info->TarSelQ_Cnt == 0) {\n\n\t\tcurrTar_Info->TarSelQ_Head = p_SCCB;\n\t}\n\n\telse {\n\n\t\tcurrTar_Info->TarSelQ_Tail->Sccb_forwardlink = p_SCCB;\n\t}\n\n\tcurrTar_Info->TarSelQ_Tail = p_SCCB;\n\tcurrTar_Info->TarSelQ_Cnt++;\n}\n\n \n\nstatic unsigned char FPT_queueFindSccb(struct sccb *p_SCCB,\n\t\t\t\t       unsigned char p_card)\n{\n\tstruct sccb *q_ptr;\n\tstruct sccb_mgr_tar_info *currTar_Info;\n\n\tcurrTar_Info = &FPT_sccbMgrTbl[p_card][p_SCCB->TargID];\n\n\tq_ptr = currTar_Info->TarSelQ_Head;\n\n\twhile (q_ptr != NULL) {\n\n\t\tif (q_ptr == p_SCCB) {\n\n\t\t\tif (currTar_Info->TarSelQ_Head == q_ptr) {\n\n\t\t\t\tcurrTar_Info->TarSelQ_Head =\n\t\t\t\t    q_ptr->Sccb_forwardlink;\n\t\t\t}\n\n\t\t\tif (currTar_Info->TarSelQ_Tail == q_ptr) {\n\n\t\t\t\tcurrTar_Info->TarSelQ_Tail =\n\t\t\t\t    q_ptr->Sccb_backlink;\n\t\t\t}\n\n\t\t\tif (q_ptr->Sccb_forwardlink != NULL) {\n\t\t\t\tq_ptr->Sccb_forwardlink->Sccb_backlink =\n\t\t\t\t    q_ptr->Sccb_backlink;\n\t\t\t}\n\n\t\t\tif (q_ptr->Sccb_backlink != NULL) {\n\t\t\t\tq_ptr->Sccb_backlink->Sccb_forwardlink =\n\t\t\t\t    q_ptr->Sccb_forwardlink;\n\t\t\t}\n\n\t\t\tcurrTar_Info->TarSelQ_Cnt--;\n\n\t\t\treturn 1;\n\t\t}\n\n\t\telse {\n\t\t\tq_ptr = q_ptr->Sccb_forwardlink;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\n \n\nstatic void FPT_utilUpdateResidual(struct sccb *p_SCCB)\n{\n\tunsigned long partial_cnt;\n\tunsigned int sg_index;\n\tstruct blogic_sg_seg *segp;\n\n\tif (p_SCCB->Sccb_XferState & F_ALL_XFERRED) {\n\n\t\tp_SCCB->DataLength = 0x0000;\n\t}\n\n\telse if (p_SCCB->Sccb_XferState & F_SG_XFER) {\n\n\t\tpartial_cnt = 0x0000;\n\n\t\tsg_index = p_SCCB->Sccb_sgseg;\n\n\n\t\tif (p_SCCB->Sccb_SGoffset) {\n\n\t\t\tpartial_cnt = p_SCCB->Sccb_SGoffset;\n\t\t\tsg_index++;\n\t\t}\n\n\t\twhile (((unsigned long)sg_index *\n\t\t\t(unsigned long)SG_ELEMENT_SIZE) < p_SCCB->DataLength) {\n\t\t\tsegp = (struct blogic_sg_seg *)(p_SCCB->DataPointer) +\n\t\t\t\t\t(sg_index * 2);\n\t\t\tpartial_cnt += segp->segbytes;\n\t\t\tsg_index++;\n\t\t}\n\n\t\tp_SCCB->DataLength = partial_cnt;\n\t}\n\n\telse {\n\n\t\tp_SCCB->DataLength -= p_SCCB->Sccb_ATC;\n\t}\n}\n\n \n\nstatic void FPT_Wait1Second(u32 p_port)\n{\n\tunsigned char i;\n\n\tfor (i = 0; i < 4; i++) {\n\n\t\tFPT_Wait(p_port, TO_250ms);\n\n\t\tif ((RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST))\n\t\t\tbreak;\n\n\t\tif ((RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL))\n\t\t\tbreak;\n\t}\n}\n\n \n\nstatic void FPT_Wait(u32 p_port, unsigned char p_delay)\n{\n\tunsigned char old_timer;\n\tunsigned char green_flag;\n\n\told_timer = RD_HARPOON(p_port + hp_seltimeout);\n\n\tgreen_flag = RD_HARPOON(p_port + hp_clkctrl_0);\n\tWR_HARPOON(p_port + hp_clkctrl_0, CLKCTRL_DEFAULT);\n\n\tWR_HARPOON(p_port + hp_seltimeout, p_delay);\n\tWRW_HARPOON((p_port + hp_intstat), TIMEOUT);\n\tWRW_HARPOON((p_port + hp_intena), (FPT_default_intena & ~TIMEOUT));\n\n\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t   (RD_HARPOON(p_port + hp_portctrl_0) | START_TO));\n\n\twhile (!(RDW_HARPOON((p_port + hp_intstat)) & TIMEOUT)) {\n\n\t\tif ((RD_HARPOON(p_port + hp_scsictrl_0) & SCSI_RST))\n\t\t\tbreak;\n\n\t\tif ((RDW_HARPOON((p_port + hp_intstat)) & SCAM_SEL))\n\t\t\tbreak;\n\t}\n\n\tWR_HARPOON(p_port + hp_portctrl_0,\n\t\t   (RD_HARPOON(p_port + hp_portctrl_0) & ~START_TO));\n\n\tWRW_HARPOON((p_port + hp_intstat), TIMEOUT);\n\tWRW_HARPOON((p_port + hp_intena), FPT_default_intena);\n\n\tWR_HARPOON(p_port + hp_clkctrl_0, green_flag);\n\n\tWR_HARPOON(p_port + hp_seltimeout, old_timer);\n}\n\n \n\nstatic void FPT_utilEEWriteOnOff(u32 p_port, unsigned char p_mode)\n{\n\tunsigned char ee_value;\n\n\tee_value =\n\t    (unsigned char)(RD_HARPOON(p_port + hp_ee_ctrl) &\n\t\t\t    (EXT_ARB_ACK | SCSI_TERM_ENA_H));\n\n\tif (p_mode)\n\n\t\tFPT_utilEESendCmdAddr(p_port, EWEN, EWEN_ADDR);\n\n\telse\n\n\t\tFPT_utilEESendCmdAddr(p_port, EWDS, EWDS_ADDR);\n\n\tWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));\t \n\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\t \n}\n\n \n\nstatic void FPT_utilEEWrite(u32 p_port, unsigned short ee_data,\n\t\t\t    unsigned short ee_addr)\n{\n\n\tunsigned char ee_value;\n\tunsigned short i;\n\n\tee_value =\n\t    (unsigned\n\t     char)((RD_HARPOON(p_port + hp_ee_ctrl) &\n\t\t    (EXT_ARB_ACK | SCSI_TERM_ENA_H)) | (SEE_MS | SEE_CS));\n\n\tFPT_utilEESendCmdAddr(p_port, EE_WRITE, ee_addr);\n\n\tee_value |= (SEE_MS + SEE_CS);\n\n\tfor (i = 0x8000; i != 0; i >>= 1) {\n\n\t\tif (i & ee_data)\n\t\t\tee_value |= SEE_DO;\n\t\telse\n\t\t\tee_value &= ~SEE_DO;\n\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tee_value |= SEE_CLK;\t \n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tee_value &= ~SEE_CLK;\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t}\n\tee_value &= (EXT_ARB_ACK | SCSI_TERM_ENA_H);\n\tWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));\n\n\tFPT_Wait(p_port, TO_10ms);\n\n\tWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS | SEE_CS));\t \n\tWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));\t \n\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\t \n}\n\n \n\nstatic unsigned short FPT_utilEERead(u32 p_port,\n\t\t\t\t     unsigned short ee_addr)\n{\n\tunsigned short i, ee_data1, ee_data2;\n\n\ti = 0;\n\tee_data1 = FPT_utilEEReadOrg(p_port, ee_addr);\n\tdo {\n\t\tee_data2 = FPT_utilEEReadOrg(p_port, ee_addr);\n\n\t\tif (ee_data1 == ee_data2)\n\t\t\treturn ee_data1;\n\n\t\tee_data1 = ee_data2;\n\t\ti++;\n\n\t} while (i < 4);\n\n\treturn ee_data1;\n}\n\n \n\nstatic unsigned short FPT_utilEEReadOrg(u32 p_port, unsigned short ee_addr)\n{\n\n\tunsigned char ee_value;\n\tunsigned short i, ee_data;\n\n\tee_value =\n\t    (unsigned\n\t     char)((RD_HARPOON(p_port + hp_ee_ctrl) &\n\t\t    (EXT_ARB_ACK | SCSI_TERM_ENA_H)) | (SEE_MS | SEE_CS));\n\n\tFPT_utilEESendCmdAddr(p_port, EE_READ, ee_addr);\n\n\tee_value |= (SEE_MS + SEE_CS);\n\tee_data = 0;\n\n\tfor (i = 1; i <= 16; i++) {\n\n\t\tee_value |= SEE_CLK;\t \n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tee_value &= ~SEE_CLK;\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\n\t\tee_data <<= 1;\n\n\t\tif (RD_HARPOON(p_port + hp_ee_ctrl) & SEE_DI)\n\t\t\tee_data |= 1;\n\t}\n\n\tee_value &= ~(SEE_MS + SEE_CS);\n\tWR_HARPOON(p_port + hp_ee_ctrl, (ee_value | SEE_MS));\t \n\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\t \n\n\treturn ee_data;\n}\n\n \n\nstatic void FPT_utilEESendCmdAddr(u32 p_port, unsigned char ee_cmd,\n\t\t\t\t  unsigned short ee_addr)\n{\n\tunsigned char ee_value;\n\tunsigned char narrow_flg;\n\n\tunsigned short i;\n\n\tnarrow_flg =\n\t    (unsigned char)(RD_HARPOON(p_port + hp_page_ctrl) &\n\t\t\t    NARROW_SCSI_CARD);\n\n\tee_value = SEE_MS;\n\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\n\tee_value |= SEE_CS;\t \n\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\n\tfor (i = 0x04; i != 0; i >>= 1) {\n\n\t\tif (i & ee_cmd)\n\t\t\tee_value |= SEE_DO;\n\t\telse\n\t\t\tee_value &= ~SEE_DO;\n\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tee_value |= SEE_CLK;\t \n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tee_value &= ~SEE_CLK;\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t}\n\n\tif (narrow_flg)\n\t\ti = 0x0080;\n\n\telse\n\t\ti = 0x0200;\n\n\twhile (i != 0) {\n\n\t\tif (i & ee_addr)\n\t\t\tee_value |= SEE_DO;\n\t\telse\n\t\t\tee_value &= ~SEE_DO;\n\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tee_value |= SEE_CLK;\t \n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tee_value &= ~SEE_CLK;\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\t\tWR_HARPOON(p_port + hp_ee_ctrl, ee_value);\n\n\t\ti >>= 1;\n\t}\n}\n\nstatic unsigned short FPT_CalcCrc16(unsigned char buffer[])\n{\n\tunsigned short crc = 0;\n\tint i, j;\n\tunsigned short ch;\n\tfor (i = 0; i < ID_STRING_LENGTH; i++) {\n\t\tch = (unsigned short)buffer[i];\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif ((crc ^ ch) & 1)\n\t\t\t\tcrc = (crc >> 1) ^ CRCMASK;\n\t\t\telse\n\t\t\t\tcrc >>= 1;\n\t\t\tch >>= 1;\n\t\t}\n\t}\n\treturn crc;\n}\n\nstatic unsigned char FPT_CalcLrc(unsigned char buffer[])\n{\n\tint i;\n\tunsigned char lrc;\n\tlrc = 0;\n\tfor (i = 0; i < ID_STRING_LENGTH; i++)\n\t\tlrc ^= buffer[i];\n\treturn lrc;\n}\n\n \n\nstatic inline unsigned char\nFlashPoint__ProbeHostAdapter(struct fpoint_info *FlashPointInfo)\n{\n\treturn FlashPoint_ProbeHostAdapter((struct sccb_mgr_info *)\n\t\t\t\t\t   FlashPointInfo);\n}\n\nstatic inline void *\nFlashPoint__HardwareResetHostAdapter(struct fpoint_info *FlashPointInfo)\n{\n\treturn FlashPoint_HardwareResetHostAdapter((struct sccb_mgr_info *)\n\t\t\t\t\t\t   FlashPointInfo);\n}\n\nstatic inline void\nFlashPoint__ReleaseHostAdapter(void *CardHandle)\n{\n\tFlashPoint_ReleaseHostAdapter(CardHandle);\n}\n\nstatic inline void\nFlashPoint__StartCCB(void *CardHandle, struct blogic_ccb *CCB)\n{\n\tFlashPoint_StartCCB(CardHandle, (struct sccb *)CCB);\n}\n\nstatic inline void\nFlashPoint__AbortCCB(void *CardHandle, struct blogic_ccb *CCB)\n{\n\tFlashPoint_AbortCCB(CardHandle, (struct sccb *)CCB);\n}\n\nstatic inline bool\nFlashPoint__InterruptPending(void *CardHandle)\n{\n\treturn FlashPoint_InterruptPending(CardHandle);\n}\n\nstatic inline int\nFlashPoint__HandleInterrupt(void *CardHandle)\n{\n\treturn FlashPoint_HandleInterrupt(CardHandle);\n}\n\n#define FlashPoint_ProbeHostAdapter\t    FlashPoint__ProbeHostAdapter\n#define FlashPoint_HardwareResetHostAdapter FlashPoint__HardwareResetHostAdapter\n#define FlashPoint_ReleaseHostAdapter\t    FlashPoint__ReleaseHostAdapter\n#define FlashPoint_StartCCB\t\t    FlashPoint__StartCCB\n#define FlashPoint_AbortCCB\t\t    FlashPoint__AbortCCB\n#define FlashPoint_InterruptPending\t    FlashPoint__InterruptPending\n#define FlashPoint_HandleInterrupt\t    FlashPoint__HandleInterrupt\n\n#else\t\t\t\t \n\n \n\nextern unsigned char FlashPoint_ProbeHostAdapter(struct fpoint_info *);\nextern void *FlashPoint_HardwareResetHostAdapter(struct fpoint_info *);\nextern void FlashPoint_StartCCB(void *, struct blogic_ccb *);\nextern int FlashPoint_AbortCCB(void *, struct blogic_ccb *);\nextern bool FlashPoint_InterruptPending(void *);\nextern int FlashPoint_HandleInterrupt(void *);\nextern void FlashPoint_ReleaseHostAdapter(void *);\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}