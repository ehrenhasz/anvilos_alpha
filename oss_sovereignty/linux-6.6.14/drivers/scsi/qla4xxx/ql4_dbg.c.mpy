{
  "module_name": "ql4_dbg.c",
  "hash_id": "a739ffa54079e4f53d022f75f5b9c9cc0d6c07a0fd1e2540bbbb2575f5226ee3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_dbg.c",
  "human_readable_source": "\n \n\n#include \"ql4_def.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n#include \"ql4_inline.h\"\n\nvoid qla4xxx_dump_buffer(void *b, uint32_t size)\n{\n\tuint32_t cnt;\n\tuint8_t *c = b;\n\n\tprintk(\" 0   1   2   3   4   5   6   7   8   9  Ah  Bh  Ch  Dh  Eh  \"\n\t       \"Fh\\n\");\n\tprintk(\"------------------------------------------------------------\"\n\t       \"--\\n\");\n\tfor (cnt = 0; cnt < size; c++) {\n\t\tprintk(\"%02x\", *c);\n\t\tif (!(++cnt % 16))\n\t\t\tprintk(\"\\n\");\n\n\t\telse\n\t\t\tprintk(\"  \");\n\t}\n\tprintk(KERN_INFO \"\\n\");\n}\n\nvoid qla4xxx_dump_registers(struct scsi_qla_host *ha)\n{\n\tuint8_t i;\n\n\tif (is_qla8022(ha)) {\n\t\tfor (i = 1; i < MBOX_REG_COUNT; i++)\n\t\t\tprintk(KERN_INFO \"mailbox[%d]     = 0x%08X\\n\",\n\t\t\t    i, readl(&ha->qla4_82xx_reg->mailbox_in[i]));\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < MBOX_REG_COUNT; i++) {\n\t\tprintk(KERN_INFO \"0x%02X mailbox[%d]      = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, mailbox[i]), i,\n\t\t    readw(&ha->reg->mailbox[i]));\n\t}\n\n\tprintk(KERN_INFO \"0x%02X flash_address            = 0x%08X\\n\",\n\t    (uint8_t) offsetof(struct isp_reg, flash_address),\n\t    readw(&ha->reg->flash_address));\n\tprintk(KERN_INFO \"0x%02X flash_data               = 0x%08X\\n\",\n\t    (uint8_t) offsetof(struct isp_reg, flash_data),\n\t    readw(&ha->reg->flash_data));\n\tprintk(KERN_INFO \"0x%02X ctrl_status              = 0x%08X\\n\",\n\t    (uint8_t) offsetof(struct isp_reg, ctrl_status),\n\t    readw(&ha->reg->ctrl_status));\n\n\tif (is_qla4010(ha)) {\n\t\tprintk(KERN_INFO \"0x%02X nvram            = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u1.isp4010.nvram),\n\t\t    readw(&ha->reg->u1.isp4010.nvram));\n\t} else if (is_qla4022(ha) | is_qla4032(ha)) {\n\t\tprintk(KERN_INFO \"0x%02X intr_mask        = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u1.isp4022.intr_mask),\n\t\t    readw(&ha->reg->u1.isp4022.intr_mask));\n\t\tprintk(KERN_INFO \"0x%02X nvram            = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u1.isp4022.nvram),\n\t\t    readw(&ha->reg->u1.isp4022.nvram));\n\t\tprintk(KERN_INFO \"0x%02X semaphore\t  = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u1.isp4022.semaphore),\n\t\t    readw(&ha->reg->u1.isp4022.semaphore));\n\t}\n\tprintk(KERN_INFO \"0x%02X req_q_in                 = 0x%08X\\n\",\n\t    (uint8_t) offsetof(struct isp_reg, req_q_in),\n\t    readw(&ha->reg->req_q_in));\n\tprintk(KERN_INFO \"0x%02X rsp_q_out                = 0x%08X\\n\",\n\t    (uint8_t) offsetof(struct isp_reg, rsp_q_out),\n\t    readw(&ha->reg->rsp_q_out));\n\n\tif (is_qla4010(ha)) {\n\t\tprintk(KERN_INFO \"0x%02X ext_hw_conf      = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4010.ext_hw_conf),\n\t\t    readw(&ha->reg->u2.isp4010.ext_hw_conf));\n\t\tprintk(KERN_INFO \"0x%02X port_ctrl        = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4010.port_ctrl),\n\t\t    readw(&ha->reg->u2.isp4010.port_ctrl));\n\t\tprintk(KERN_INFO \"0x%02X port_status      = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4010.port_status),\n\t\t    readw(&ha->reg->u2.isp4010.port_status));\n\t\tprintk(KERN_INFO \"0x%02X req_q_out        = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4010.req_q_out),\n\t\t    readw(&ha->reg->u2.isp4010.req_q_out));\n\t\tprintk(KERN_INFO \"0x%02X gp_out           = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4010.gp_out),\n\t\t    readw(&ha->reg->u2.isp4010.gp_out));\n\t\tprintk(KERN_INFO \"0x%02X gp_in\t          = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4010.gp_in),\n\t\t    readw(&ha->reg->u2.isp4010.gp_in));\n\t\tprintk(KERN_INFO \"0x%02X port_err_status  = 0x%08X\\n\", (uint8_t)\n\t\t    offsetof(struct isp_reg, u2.isp4010.port_err_status),\n\t\t    readw(&ha->reg->u2.isp4010.port_err_status));\n\t} else if (is_qla4022(ha) | is_qla4032(ha)) {\n\t\tprintk(KERN_INFO \"Page 0 Registers:\\n\");\n\t\tprintk(KERN_INFO \"0x%02X ext_hw_conf      = 0x%08X\\n\", (uint8_t)\n\t\t    offsetof(struct isp_reg, u2.isp4022.p0.ext_hw_conf),\n\t\t    readw(&ha->reg->u2.isp4022.p0.ext_hw_conf));\n\t\tprintk(KERN_INFO \"0x%02X port_ctrl        = 0x%08X\\n\", (uint8_t)\n\t\t    offsetof(struct isp_reg, u2.isp4022.p0.port_ctrl),\n\t\t    readw(&ha->reg->u2.isp4022.p0.port_ctrl));\n\t\tprintk(KERN_INFO \"0x%02X port_status      = 0x%08X\\n\", (uint8_t)\n\t\t    offsetof(struct isp_reg, u2.isp4022.p0.port_status),\n\t\t    readw(&ha->reg->u2.isp4022.p0.port_status));\n\t\tprintk(KERN_INFO \"0x%02X gp_out           = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4022.p0.gp_out),\n\t\t    readw(&ha->reg->u2.isp4022.p0.gp_out));\n\t\tprintk(KERN_INFO \"0x%02X gp_in            = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4022.p0.gp_in),\n\t\t    readw(&ha->reg->u2.isp4022.p0.gp_in));\n\t\tprintk(KERN_INFO \"0x%02X port_err_status  = 0x%08X\\n\", (uint8_t)\n\t\t    offsetof(struct isp_reg, u2.isp4022.p0.port_err_status),\n\t\t    readw(&ha->reg->u2.isp4022.p0.port_err_status));\n\t\tprintk(KERN_INFO \"Page 1 Registers:\\n\");\n\t\twritel(HOST_MEM_CFG_PAGE & set_rmask(CSR_SCSI_PAGE_SELECT),\n\t\t    &ha->reg->ctrl_status);\n\t\tprintk(KERN_INFO \"0x%02X req_q_out        = 0x%08X\\n\",\n\t\t    (uint8_t) offsetof(struct isp_reg, u2.isp4022.p1.req_q_out),\n\t\t    readw(&ha->reg->u2.isp4022.p1.req_q_out));\n\t\twritel(PORT_CTRL_STAT_PAGE & set_rmask(CSR_SCSI_PAGE_SELECT),\n\t\t    &ha->reg->ctrl_status);\n\t}\n}\n\nvoid qla4_8xxx_dump_peg_reg(struct scsi_qla_host *ha)\n{\n\tuint32_t halt_status1, halt_status2;\n\n\thalt_status1 = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_HALT_STATUS1);\n\thalt_status2 = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_HALT_STATUS2);\n\n\tif (is_qla8022(ha)) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"scsi(%ld): %s, ISP%04x Dumping hw/fw registers:\\n\"\n\t\t\t   \" PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\\n\"\n\t\t\t   \" PEG_NET_0_PC: 0x%x, PEG_NET_1_PC: 0x%x,\\n\"\n\t\t\t   \" PEG_NET_2_PC: 0x%x, PEG_NET_3_PC: 0x%x,\\n\"\n\t\t\t   \" PEG_NET_4_PC: 0x%x\\n\", ha->host_no, __func__,\n\t\t\t   ha->pdev->device, halt_status1, halt_status2,\n\t\t\t   qla4_82xx_rd_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x3c),\n\t\t\t   qla4_82xx_rd_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x3c),\n\t\t\t   qla4_82xx_rd_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x3c),\n\t\t\t   qla4_82xx_rd_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x3c),\n\t\t\t   qla4_82xx_rd_32(ha, QLA82XX_CRB_PEG_NET_4 + 0x3c));\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"scsi(%ld): %s, ISP%04x Dumping hw/fw registers:\\n\"\n\t\t\t   \" PEG_HALT_STATUS1: 0x%x, PEG_HALT_STATUS2: 0x%x,\\n\",\n\t\t\t   ha->host_no, __func__, ha->pdev->device,\n\t\t\t   halt_status1, halt_status2);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}