{
  "module_name": "ql4_83xx.c",
  "hash_id": "afee973316a611abc4a173f304d8726833ab9b6800c40890f3310d08d3dde1c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_83xx.c",
  "human_readable_source": "\n \n\n#include <linux/ratelimit.h>\n\n#include \"ql4_def.h\"\n#include \"ql4_version.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n#include \"ql4_inline.h\"\n\nuint32_t qla4_83xx_rd_reg(struct scsi_qla_host *ha, ulong addr)\n{\n\treturn readl((void __iomem *)(ha->nx_pcibase + addr));\n}\n\nvoid qla4_83xx_wr_reg(struct scsi_qla_host *ha, ulong addr, uint32_t val)\n{\n\twritel(val, (void __iomem *)(ha->nx_pcibase + addr));\n}\n\nstatic int qla4_83xx_set_win_base(struct scsi_qla_host *ha, uint32_t addr)\n{\n\tuint32_t val;\n\tint ret_val = QLA_SUCCESS;\n\n\tqla4_83xx_wr_reg(ha, QLA83XX_CRB_WIN_FUNC(ha->func_num), addr);\n\tval = qla4_83xx_rd_reg(ha, QLA83XX_CRB_WIN_FUNC(ha->func_num));\n\tif (val != addr) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Failed to set register window : addr written 0x%x, read 0x%x!\\n\",\n\t\t\t   __func__, addr, val);\n\t\tret_val = QLA_ERROR;\n\t}\n\n\treturn ret_val;\n}\n\nint qla4_83xx_rd_reg_indirect(struct scsi_qla_host *ha, uint32_t addr,\n\t\t\t      uint32_t *data)\n{\n\tint ret_val;\n\n\tret_val = qla4_83xx_set_win_base(ha, addr);\n\n\tif (ret_val == QLA_SUCCESS) {\n\t\t*data = qla4_83xx_rd_reg(ha, QLA83XX_WILDCARD);\n\t} else {\n\t\t*data = 0xffffffff;\n\t\tql4_printk(KERN_ERR, ha, \"%s: failed read of addr 0x%x!\\n\",\n\t\t\t   __func__, addr);\n\t}\n\n\treturn ret_val;\n}\n\nint qla4_83xx_wr_reg_indirect(struct scsi_qla_host *ha, uint32_t addr,\n\t\t\t      uint32_t data)\n{\n\tint ret_val;\n\n\tret_val = qla4_83xx_set_win_base(ha, addr);\n\n\tif (ret_val == QLA_SUCCESS)\n\t\tqla4_83xx_wr_reg(ha, QLA83XX_WILDCARD, data);\n\telse\n\t\tql4_printk(KERN_ERR, ha, \"%s: failed wrt to addr 0x%x, data 0x%x\\n\",\n\t\t\t   __func__, addr, data);\n\n\treturn ret_val;\n}\n\nstatic int qla4_83xx_flash_lock(struct scsi_qla_host *ha)\n{\n\tint lock_owner;\n\tint timeout = 0;\n\tuint32_t lock_status = 0;\n\tint ret_val = QLA_SUCCESS;\n\n\twhile (lock_status == 0) {\n\t\tlock_status = qla4_83xx_rd_reg(ha, QLA83XX_FLASH_LOCK);\n\t\tif (lock_status)\n\t\t\tbreak;\n\n\t\tif (++timeout >= QLA83XX_FLASH_LOCK_TIMEOUT / 20) {\n\t\t\tlock_owner = qla4_83xx_rd_reg(ha,\n\t\t\t\t\t\t      QLA83XX_FLASH_LOCK_ID);\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: flash lock by func %d failed, held by func %d\\n\",\n\t\t\t\t   __func__, ha->func_num, lock_owner);\n\t\t\tret_val = QLA_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\tqla4_83xx_wr_reg(ha, QLA83XX_FLASH_LOCK_ID, ha->func_num);\n\treturn ret_val;\n}\n\nstatic void qla4_83xx_flash_unlock(struct scsi_qla_host *ha)\n{\n\t \n\tqla4_83xx_wr_reg(ha, QLA83XX_FLASH_LOCK_ID, 0xFF);\n\tqla4_83xx_rd_reg(ha, QLA83XX_FLASH_UNLOCK);\n}\n\nint qla4_83xx_flash_read_u32(struct scsi_qla_host *ha, uint32_t flash_addr,\n\t\t\t     uint8_t *p_data, int u32_word_count)\n{\n\tint i;\n\tuint32_t u32_word;\n\tuint32_t addr = flash_addr;\n\tint ret_val = QLA_SUCCESS;\n\n\tret_val = qla4_83xx_flash_lock(ha);\n\tif (ret_val == QLA_ERROR)\n\t\tgoto exit_lock_error;\n\n\tif (addr & 0x03) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Illegal addr = 0x%x\\n\",\n\t\t\t   __func__, addr);\n\t\tret_val = QLA_ERROR;\n\t\tgoto exit_flash_read;\n\t}\n\n\tfor (i = 0; i < u32_word_count; i++) {\n\t\tret_val = qla4_83xx_wr_reg_indirect(ha,\n\t\t\t\t\t\t    QLA83XX_FLASH_DIRECT_WINDOW,\n\t\t\t\t\t\t    (addr & 0xFFFF0000));\n\t\tif (ret_val == QLA_ERROR) {\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW\\n!\",\n\t\t\t\t   __func__, addr);\n\t\t\tgoto exit_flash_read;\n\t\t}\n\n\t\tret_val = qla4_83xx_rd_reg_indirect(ha,\n\t\t\t\t\t\tQLA83XX_FLASH_DIRECT_DATA(addr),\n\t\t\t\t\t\t&u32_word);\n\t\tif (ret_val == QLA_ERROR) {\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: failed to read addr 0x%x!\\n\",\n\t\t\t\t   __func__, addr);\n\t\t\tgoto exit_flash_read;\n\t\t}\n\n\t\t*(__le32 *)p_data = le32_to_cpu(u32_word);\n\t\tp_data = p_data + 4;\n\t\taddr = addr + 4;\n\t}\n\nexit_flash_read:\n\tqla4_83xx_flash_unlock(ha);\n\nexit_lock_error:\n\treturn ret_val;\n}\n\nint qla4_83xx_lockless_flash_read_u32(struct scsi_qla_host *ha,\n\t\t\t\t      uint32_t flash_addr, uint8_t *p_data,\n\t\t\t\t      int u32_word_count)\n{\n\tuint32_t i;\n\tuint32_t u32_word;\n\tuint32_t flash_offset;\n\tuint32_t addr = flash_addr;\n\tint ret_val = QLA_SUCCESS;\n\n\tflash_offset = addr & (QLA83XX_FLASH_SECTOR_SIZE - 1);\n\n\tif (addr & 0x3) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Illegal addr = 0x%x\\n\",\n\t\t\t   __func__, addr);\n\t\tret_val = QLA_ERROR;\n\t\tgoto exit_lockless_read;\n\t}\n\n\tret_val = qla4_83xx_wr_reg_indirect(ha, QLA83XX_FLASH_DIRECT_WINDOW,\n\t\t\t\t\t    addr);\n\tif (ret_val == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\\n\",\n\t\t\t   __func__, addr);\n\t\tgoto exit_lockless_read;\n\t}\n\n\t \n\tif ((flash_offset + (u32_word_count * sizeof(uint32_t))) >\n\t    (QLA83XX_FLASH_SECTOR_SIZE - 1)) {\n\n\t\t \n\t\tfor (i = 0; i < u32_word_count; i++) {\n\t\t\tret_val = qla4_83xx_rd_reg_indirect(ha,\n\t\t\t\t\t\tQLA83XX_FLASH_DIRECT_DATA(addr),\n\t\t\t\t\t\t&u32_word);\n\t\t\tif (ret_val == QLA_ERROR) {\n\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: failed to read addr 0x%x!\\n\",\n\t\t\t\t\t   __func__, addr);\n\t\t\t\tgoto exit_lockless_read;\n\t\t\t}\n\n\t\t\t*(__le32 *)p_data  = le32_to_cpu(u32_word);\n\t\t\tp_data = p_data + 4;\n\t\t\taddr = addr + 4;\n\t\t\tflash_offset = flash_offset + 4;\n\n\t\t\tif (flash_offset > (QLA83XX_FLASH_SECTOR_SIZE - 1)) {\n\t\t\t\t \n\t\t\t\tret_val = qla4_83xx_wr_reg_indirect(ha,\n\t\t\t\t\t\t   QLA83XX_FLASH_DIRECT_WINDOW,\n\t\t\t\t\t\t   addr);\n\t\t\t\tif (ret_val == QLA_ERROR) {\n\t\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: failed to write addr 0x%x to FLASH_DIRECT_WINDOW!\\n\",\n\t\t\t\t\t\t   __func__, addr);\n\t\t\t\t\tgoto exit_lockless_read;\n\t\t\t\t}\n\t\t\t\tflash_offset = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = 0; i < u32_word_count; i++) {\n\t\t\tret_val = qla4_83xx_rd_reg_indirect(ha,\n\t\t\t\t\t\tQLA83XX_FLASH_DIRECT_DATA(addr),\n\t\t\t\t\t\t&u32_word);\n\t\t\tif (ret_val == QLA_ERROR) {\n\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: failed to read addr 0x%x!\\n\",\n\t\t\t\t\t   __func__, addr);\n\t\t\t\tgoto exit_lockless_read;\n\t\t\t}\n\n\t\t\t*(__le32 *)p_data = le32_to_cpu(u32_word);\n\t\t\tp_data = p_data + 4;\n\t\t\taddr = addr + 4;\n\t\t}\n\t}\n\nexit_lockless_read:\n\treturn ret_val;\n}\n\nvoid qla4_83xx_rom_lock_recovery(struct scsi_qla_host *ha)\n{\n\tif (qla4_83xx_flash_lock(ha))\n\t\tql4_printk(KERN_INFO, ha, \"%s: Resetting rom lock\\n\", __func__);\n\n\t \n\tqla4_83xx_flash_unlock(ha);\n}\n\n#define INTENT_TO_RECOVER\t0x01\n#define PROCEED_TO_RECOVER\t0x02\n\nstatic int qla4_83xx_lock_recovery(struct scsi_qla_host *ha)\n{\n\n\tuint32_t lock = 0, lockid;\n\tint ret_val = QLA_ERROR;\n\n\tlockid = ha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY);\n\n\t \n\tif ((lockid & 0x3) != 0)\n\t\tgoto exit_lock_recovery;\n\n\t \n\tha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY,\n\t\t\t\t   (ha->func_num << 2) | INTENT_TO_RECOVER);\n\n\tmsleep(200);\n\n\t \n\tlockid = ha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY);\n\tif ((lockid & 0x3C) != (ha->func_num << 2))\n\t\tgoto exit_lock_recovery;\n\n\tql4_printk(KERN_INFO, ha, \"%s: IDC Lock recovery initiated for func %d\\n\",\n\t\t   __func__, ha->func_num);\n\n\t \n\tha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY,\n\t\t\t\t   (ha->func_num << 2) | PROCEED_TO_RECOVER);\n\n\t \n\tha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCK_ID, 0xFF);\n\tha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_UNLOCK);\n\n\t \n\tha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCKRECOVERY, 0);\n\n\t \n\tlock = ha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_LOCK);\n\tif (lock) {\n\t\tlockid = ha->isp_ops->rd_reg_direct(ha, QLA83XX_DRV_LOCK_ID);\n\t\tlockid = ((lockid + (1 << 8)) & ~0xFF) | ha->func_num;\n\t\tha->isp_ops->wr_reg_direct(ha, QLA83XX_DRV_LOCK_ID, lockid);\n\t\tret_val = QLA_SUCCESS;\n\t}\n\nexit_lock_recovery:\n\treturn ret_val;\n}\n\n#define\tQLA83XX_DRV_LOCK_MSLEEP\t\t200\n\nint qla4_83xx_drv_lock(struct scsi_qla_host *ha)\n{\n\tint timeout = 0;\n\tuint32_t status = 0;\n\tint ret_val = QLA_SUCCESS;\n\tuint32_t first_owner = 0;\n\tuint32_t tmo_owner = 0;\n\tuint32_t lock_id;\n\tuint32_t func_num;\n\tuint32_t lock_cnt;\n\n\twhile (status == 0) {\n\t\tstatus = qla4_83xx_rd_reg(ha, QLA83XX_DRV_LOCK);\n\t\tif (status) {\n\t\t\t \n\t\t\tlock_id = qla4_83xx_rd_reg(ha, QLA83XX_DRV_LOCK_ID);\n\t\t\tlock_id = ((lock_id + (1 << 8)) & ~0xFF) | ha->func_num;\n\t\t\tqla4_83xx_wr_reg(ha, QLA83XX_DRV_LOCK_ID, lock_id);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (timeout == 0)\n\t\t\t \n\t\t\tfirst_owner = ha->isp_ops->rd_reg_direct(ha,\n\t\t\t\t\t\t\t  QLA83XX_DRV_LOCK_ID);\n\n\t\tif (++timeout >=\n\t\t    (QLA83XX_DRV_LOCK_TIMEOUT / QLA83XX_DRV_LOCK_MSLEEP)) {\n\t\t\ttmo_owner = qla4_83xx_rd_reg(ha, QLA83XX_DRV_LOCK_ID);\n\t\t\tfunc_num = tmo_owner & 0xFF;\n\t\t\tlock_cnt = tmo_owner >> 8;\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: Lock by func %d failed after 2s, lock held by func %d, lock count %d, first_owner %d\\n\",\n\t\t\t\t   __func__, ha->func_num, func_num, lock_cnt,\n\t\t\t\t   (first_owner & 0xFF));\n\n\t\t\tif (first_owner != tmo_owner) {\n\t\t\t\t \n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: IDC lock failed for func %d\\n\",\n\t\t\t\t\t   __func__, ha->func_num);\n\t\t\t\ttimeout = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret_val = qla4_83xx_lock_recovery(ha);\n\t\t\t\tif (ret_val == QLA_SUCCESS) {\n\t\t\t\t\t \n\t\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: IDC lock Recovery by %d successful\\n\",\n\t\t\t\t\t\t   __func__, ha->func_num);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: IDC lock Recovery by %d failed, Retrying timeout\\n\",\n\t\t\t\t\t   __func__, ha->func_num);\n\t\t\t\ttimeout = 0;\n\t\t\t}\n\t\t}\n\t\tmsleep(QLA83XX_DRV_LOCK_MSLEEP);\n\t}\n\n\treturn ret_val;\n}\n\nvoid qla4_83xx_drv_unlock(struct scsi_qla_host *ha)\n{\n\tint id;\n\n\tid = qla4_83xx_rd_reg(ha, QLA83XX_DRV_LOCK_ID);\n\n\tif ((id & 0xFF) != ha->func_num) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: IDC Unlock by %d failed, lock owner is %d\\n\",\n\t\t\t   __func__, ha->func_num, (id & 0xFF));\n\t\treturn;\n\t}\n\n\t \n\tqla4_83xx_wr_reg(ha, QLA83XX_DRV_LOCK_ID, (id | 0xFF));\n\tqla4_83xx_rd_reg(ha, QLA83XX_DRV_UNLOCK);\n}\n\nvoid qla4_83xx_set_idc_dontreset(struct scsi_qla_host *ha)\n{\n\tuint32_t idc_ctrl;\n\n\tidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\n\tidc_ctrl |= DONTRESET_BIT0;\n\tqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL, idc_ctrl);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: idc_ctrl = %d\\n\", __func__,\n\t\t\t  idc_ctrl));\n}\n\nvoid qla4_83xx_clear_idc_dontreset(struct scsi_qla_host *ha)\n{\n\tuint32_t idc_ctrl;\n\n\tidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\n\tidc_ctrl &= ~DONTRESET_BIT0;\n\tqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL, idc_ctrl);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: idc_ctrl = %d\\n\", __func__,\n\t\t\t  idc_ctrl));\n}\n\nint qla4_83xx_idc_dontreset(struct scsi_qla_host *ha)\n{\n\tuint32_t idc_ctrl;\n\n\tidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\n\treturn idc_ctrl & DONTRESET_BIT0;\n}\n\n \n\nenum {\n\tUNKNOWN_CLASS = 0,\n\tNIC_CLASS,\n\tFCOE_CLASS,\n\tISCSI_CLASS\n};\n\nstruct device_info {\n\tint func_num;\n\tint device_type;\n\tint port_num;\n};\n\nint qla4_83xx_can_perform_reset(struct scsi_qla_host *ha)\n{\n\tuint32_t drv_active;\n\tuint32_t dev_part, dev_part1, dev_part2;\n\tint i;\n\tstruct device_info device_map[16];\n\tint func_nibble;\n\tint nibble;\n\tint nic_present = 0;\n\tint iscsi_present = 0;\n\tint iscsi_func_low = 0;\n\n\t \n\tdev_part1 = qla4_83xx_rd_reg(ha,\n\t\t\t\t     ha->reg_tbl[QLA8XXX_CRB_DEV_PART_INFO]);\n\tdev_part2 = qla4_83xx_rd_reg(ha, QLA83XX_CRB_DEV_PART_INFO2);\n\tdrv_active = qla4_83xx_rd_reg(ha, ha->reg_tbl[QLA8XXX_CRB_DRV_ACTIVE]);\n\n\t \n\tdev_part = dev_part1;\n\tfor (i = nibble = 0; i <= 15; i++, nibble++) {\n\t\tfunc_nibble = dev_part & (0xF << (nibble * 4));\n\t\tfunc_nibble >>= (nibble * 4);\n\t\tdevice_map[i].func_num = i;\n\t\tdevice_map[i].device_type = func_nibble & 0x3;\n\t\tdevice_map[i].port_num = func_nibble & 0xC;\n\n\t\tif (device_map[i].device_type == NIC_CLASS) {\n\t\t\tif (drv_active & (1 << device_map[i].func_num)) {\n\t\t\t\tnic_present++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (device_map[i].device_type == ISCSI_CLASS) {\n\t\t\tif (drv_active & (1 << device_map[i].func_num)) {\n\t\t\t\tif (!iscsi_present ||\n\t\t\t\tiscsi_func_low > device_map[i].func_num)\n\t\t\t\t\tiscsi_func_low = device_map[i].func_num;\n\n\t\t\t\tiscsi_present++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (nibble == 7) {\n\t\t\tnibble = 0;\n\t\t\tdev_part = dev_part2;\n\t\t}\n\t}\n\n\t \n\tif (!nic_present && (ha->func_num == iscsi_func_low)) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: can reset - NIC not present and lower iSCSI function is %d\\n\",\n\t\t\t\t  __func__, ha->func_num));\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nvoid qla4_83xx_need_reset_handler(struct scsi_qla_host *ha)\n{\n\tuint32_t dev_state, drv_state, drv_active;\n\tunsigned long reset_timeout, dev_init_timeout;\n\n\tql4_printk(KERN_INFO, ha, \"%s: Performing ISP error recovery\\n\",\n\t\t   __func__);\n\n\tif (!test_bit(AF_8XXX_RST_OWNER, &ha->flags)) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: reset acknowledged\\n\",\n\t\t\t\t  __func__));\n\t\tqla4_8xxx_set_rst_ready(ha);\n\n\t\t \n\t\tdev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);\n\n\t\tdo {\n\t\t\tif (time_after_eq(jiffies, dev_init_timeout)) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: Non Reset owner dev init timeout\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tha->isp_ops->idc_lock(ha);\n\n\t\t\tdev_state = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t\tQLA8XXX_CRB_DEV_STATE);\n\t\t} while (dev_state == QLA8XXX_DEV_NEED_RESET);\n\t} else {\n\t\tqla4_8xxx_set_rst_ready(ha);\n\t\treset_timeout = jiffies + (ha->nx_reset_timeout * HZ);\n\t\tdrv_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\n\t\tdrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\n\n\t\tql4_printk(KERN_INFO, ha, \"%s: drv_state = 0x%x, drv_active = 0x%x\\n\",\n\t\t\t   __func__, drv_state, drv_active);\n\n\t\twhile (drv_state != drv_active) {\n\t\t\tif (time_after_eq(jiffies, reset_timeout)) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: %s: RESET TIMEOUT! drv_state: 0x%08x, drv_active: 0x%08x\\n\",\n\t\t\t\t\t   __func__, DRIVER_NAME, drv_state,\n\t\t\t\t\t   drv_active);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tha->isp_ops->idc_lock(ha);\n\n\t\t\tdrv_state = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t\tQLA8XXX_CRB_DRV_STATE);\n\t\t\tdrv_active = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t\tQLA8XXX_CRB_DRV_ACTIVE);\n\t\t}\n\n\t\tif (drv_state != drv_active) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: Reset_owner turning off drv_active of non-acking function 0x%x\\n\",\n\t\t\t\t   __func__, (drv_active ^ drv_state));\n\t\t\tdrv_active = drv_active & drv_state;\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_ACTIVE,\n\t\t\t\t\t    drv_active);\n\t\t}\n\n\t\tclear_bit(AF_8XXX_RST_OWNER, &ha->flags);\n\t\t \n\t\tqla4_8xxx_device_bootstrap(ha);\n\t}\n}\n\nvoid qla4_83xx_get_idc_param(struct scsi_qla_host *ha)\n{\n\tuint32_t idc_params, ret_val;\n\n\tret_val = qla4_83xx_flash_read_u32(ha, QLA83XX_IDC_PARAM_ADDR,\n\t\t\t\t\t   (uint8_t *)&idc_params, 1);\n\tif (ret_val == QLA_SUCCESS) {\n\t\tha->nx_dev_init_timeout = idc_params & 0xFFFF;\n\t\tha->nx_reset_timeout = (idc_params >> 16) & 0xFFFF;\n\t} else {\n\t\tha->nx_dev_init_timeout = ROM_DEV_INIT_TIMEOUT;\n\t\tha->nx_reset_timeout = ROM_DRV_RESET_ACK_TIMEOUT;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_DEBUG, ha,\n\t\t\t  \"%s: ha->nx_dev_init_timeout = %d, ha->nx_reset_timeout = %d\\n\",\n\t\t\t  __func__, ha->nx_dev_init_timeout,\n\t\t\t  ha->nx_reset_timeout));\n}\n\n \n\nstatic void qla4_83xx_dump_reset_seq_hdr(struct scsi_qla_host *ha)\n{\n\tuint8_t *phdr;\n\n\tif (!ha->reset_tmplt.buff) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Error: Invalid reset_seq_template\\n\",\n\t\t\t   __func__);\n\t\treturn;\n\t}\n\n\tphdr = ha->reset_tmplt.buff;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Reset Template: 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X 0x%X\\n\",\n\t\t\t  *phdr, *(phdr+1), *(phdr+2), *(phdr+3), *(phdr+4),\n\t\t\t  *(phdr+5), *(phdr+6), *(phdr+7), *(phdr + 8),\n\t\t\t  *(phdr+9), *(phdr+10), *(phdr+11), *(phdr+12),\n\t\t\t  *(phdr+13), *(phdr+14), *(phdr+15)));\n}\n\nstatic int qla4_83xx_copy_bootloader(struct scsi_qla_host *ha)\n{\n\tuint8_t *p_cache;\n\tuint32_t src, count, size;\n\tuint64_t dest;\n\tint ret_val = QLA_SUCCESS;\n\n\tsrc = QLA83XX_BOOTLOADER_FLASH_ADDR;\n\tdest = qla4_83xx_rd_reg(ha, QLA83XX_BOOTLOADER_ADDR);\n\tsize = qla4_83xx_rd_reg(ha, QLA83XX_BOOTLOADER_SIZE);\n\n\t \n\tif (size & 0xF)\n\t\tsize = (size + 16) & ~0xF;\n\n\t \n\tcount = size/16;\n\n\tp_cache = vmalloc(size);\n\tif (p_cache == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Failed to allocate memory for boot loader cache\\n\",\n\t\t\t   __func__);\n\t\tret_val = QLA_ERROR;\n\t\tgoto exit_copy_bootloader;\n\t}\n\n\tret_val = qla4_83xx_lockless_flash_read_u32(ha, src, p_cache,\n\t\t\t\t\t\t    size / sizeof(uint32_t));\n\tif (ret_val == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Error reading firmware from flash\\n\",\n\t\t\t   __func__);\n\t\tgoto exit_copy_error;\n\t}\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Read firmware from flash\\n\",\n\t\t\t  __func__));\n\n\t \n\tret_val = qla4_8xxx_ms_mem_write_128b(ha, dest, (uint32_t *)p_cache,\n\t\t\t\t\t      count);\n\tif (ret_val == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Error writing firmware to MS\\n\",\n\t\t\t   __func__);\n\t\tgoto exit_copy_error;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Wrote firmware size %d to MS\\n\",\n\t\t\t  __func__, size));\n\nexit_copy_error:\n\tvfree(p_cache);\n\nexit_copy_bootloader:\n\treturn ret_val;\n}\n\nstatic int qla4_83xx_check_cmd_peg_status(struct scsi_qla_host *ha)\n{\n\tuint32_t val, ret_val = QLA_ERROR;\n\tint retries = CRB_CMDPEG_CHECK_RETRY_COUNT;\n\n\tdo {\n\t\tval = qla4_83xx_rd_reg(ha, QLA83XX_CMDPEG_STATE);\n\t\tif (val == PHAN_INITIALIZE_COMPLETE) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"%s: Command Peg initialization complete. State=0x%x\\n\",\n\t\t\t\t\t  __func__, val));\n\t\t\tret_val = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(CRB_CMDPEG_CHECK_DELAY);\n\t} while (--retries);\n\n\treturn ret_val;\n}\n\n \nstatic int qla4_83xx_poll_reg(struct scsi_qla_host *ha, uint32_t addr,\n\t\t\t      int duration, uint32_t test_mask,\n\t\t\t      uint32_t test_result)\n{\n\tuint32_t value;\n\tuint8_t retries;\n\tint ret_val = QLA_SUCCESS;\n\n\tret_val = qla4_83xx_rd_reg_indirect(ha, addr, &value);\n\tif (ret_val == QLA_ERROR)\n\t\tgoto exit_poll_reg;\n\n\tretries = duration / 10;\n\tdo {\n\t\tif ((value & test_mask) != test_result) {\n\t\t\tmsleep(duration / 10);\n\t\t\tret_val = qla4_83xx_rd_reg_indirect(ha, addr, &value);\n\t\t\tif (ret_val == QLA_ERROR)\n\t\t\t\tgoto exit_poll_reg;\n\n\t\t\tret_val = QLA_ERROR;\n\t\t} else {\n\t\t\tret_val = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t} while (retries--);\n\nexit_poll_reg:\n\tif (ret_val == QLA_ERROR) {\n\t\tha->reset_tmplt.seq_error++;\n\t\tql4_printk(KERN_ERR, ha, \"%s: Poll Failed:  0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t   __func__, value, test_mask, test_result);\n\t}\n\n\treturn ret_val;\n}\n\nstatic int qla4_83xx_reset_seq_checksum_test(struct scsi_qla_host *ha)\n{\n\tuint32_t sum =  0;\n\tuint16_t *buff = (uint16_t *)ha->reset_tmplt.buff;\n\tint u16_count =  ha->reset_tmplt.hdr->size / sizeof(uint16_t);\n\tint ret_val;\n\n\twhile (u16_count-- > 0)\n\t\tsum += *buff++;\n\n\twhile (sum >> 16)\n\t\tsum = (sum & 0xFFFF) +  (sum >> 16);\n\n\t \n\tif (~sum) {\n\t\tret_val = QLA_SUCCESS;\n\t} else {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Reset seq checksum failed\\n\",\n\t\t\t   __func__);\n\t\tret_val = QLA_ERROR;\n\t}\n\n\treturn ret_val;\n}\n\n \nvoid qla4_83xx_read_reset_template(struct scsi_qla_host *ha)\n{\n\tuint8_t *p_buff;\n\tuint32_t addr, tmplt_hdr_def_size, tmplt_hdr_size;\n\tuint32_t ret_val;\n\n\tha->reset_tmplt.seq_error = 0;\n\tha->reset_tmplt.buff = vmalloc(QLA83XX_RESTART_TEMPLATE_SIZE);\n\tif (ha->reset_tmplt.buff == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Failed to allocate reset template resources\\n\",\n\t\t\t   __func__);\n\t\tgoto exit_read_reset_template;\n\t}\n\n\tp_buff = ha->reset_tmplt.buff;\n\taddr = QLA83XX_RESET_TEMPLATE_ADDR;\n\n\ttmplt_hdr_def_size = sizeof(struct qla4_83xx_reset_template_hdr) /\n\t\t\t\t    sizeof(uint32_t);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: Read template hdr size %d from Flash\\n\",\n\t\t\t  __func__, tmplt_hdr_def_size));\n\n\t \n\tret_val = qla4_83xx_flash_read_u32(ha, addr, p_buff,\n\t\t\t\t\t   tmplt_hdr_def_size);\n\tif (ret_val != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Failed to read reset template\\n\",\n\t\t\t   __func__);\n\t\tgoto exit_read_template_error;\n\t}\n\n\tha->reset_tmplt.hdr =\n\t\t(struct qla4_83xx_reset_template_hdr *)ha->reset_tmplt.buff;\n\n\t \n\ttmplt_hdr_size = ha->reset_tmplt.hdr->hdr_size/sizeof(uint32_t);\n\tif ((tmplt_hdr_size != tmplt_hdr_def_size) ||\n\t    (ha->reset_tmplt.hdr->signature != RESET_TMPLT_HDR_SIGNATURE)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Template Header size %d is invalid, tmplt_hdr_def_size %d\\n\",\n\t\t\t   __func__, tmplt_hdr_size, tmplt_hdr_def_size);\n\t\tgoto exit_read_template_error;\n\t}\n\n\taddr = QLA83XX_RESET_TEMPLATE_ADDR + ha->reset_tmplt.hdr->hdr_size;\n\tp_buff = ha->reset_tmplt.buff + ha->reset_tmplt.hdr->hdr_size;\n\ttmplt_hdr_def_size = (ha->reset_tmplt.hdr->size -\n\t\t\t      ha->reset_tmplt.hdr->hdr_size) / sizeof(uint32_t);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: Read rest of the template size %d\\n\",\n\t\t\t  __func__, ha->reset_tmplt.hdr->size));\n\n\t \n\tret_val = qla4_83xx_flash_read_u32(ha, addr, p_buff,\n\t\t\t\t\t   tmplt_hdr_def_size);\n\tif (ret_val != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Failed to read reset template\\n\",\n\t\t\t   __func__);\n\t\tgoto exit_read_template_error;\n\t}\n\n\t \n\tif (qla4_83xx_reset_seq_checksum_test(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Reset Seq checksum failed!\\n\",\n\t\t\t   __func__);\n\t\tgoto exit_read_template_error;\n\t}\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: Reset Seq checksum passed, Get stop, start and init seq offsets\\n\",\n\t\t\t  __func__));\n\n\t \n\tha->reset_tmplt.init_offset = ha->reset_tmplt.buff +\n\t\t\t\t      ha->reset_tmplt.hdr->init_seq_offset;\n\tha->reset_tmplt.start_offset = ha->reset_tmplt.buff +\n\t\t\t\t       ha->reset_tmplt.hdr->start_seq_offset;\n\tha->reset_tmplt.stop_offset = ha->reset_tmplt.buff +\n\t\t\t\t      ha->reset_tmplt.hdr->hdr_size;\n\tqla4_83xx_dump_reset_seq_hdr(ha);\n\n\tgoto exit_read_reset_template;\n\nexit_read_template_error:\n\tvfree(ha->reset_tmplt.buff);\n\nexit_read_reset_template:\n\treturn;\n}\n\n \nstatic void qla4_83xx_read_write_crb_reg(struct scsi_qla_host *ha,\n\t\t\t\t\t uint32_t raddr, uint32_t waddr)\n{\n\tuint32_t value;\n\n\tqla4_83xx_rd_reg_indirect(ha, raddr, &value);\n\tqla4_83xx_wr_reg_indirect(ha, waddr, value);\n}\n\n \nstatic void qla4_83xx_rmw_crb_reg(struct scsi_qla_host *ha, uint32_t raddr,\n\t\t\t\t  uint32_t waddr,\n\t\t\t\t  struct qla4_83xx_rmw *p_rmw_hdr)\n{\n\tuint32_t value;\n\n\tif (p_rmw_hdr->index_a)\n\t\tvalue = ha->reset_tmplt.array[p_rmw_hdr->index_a];\n\telse\n\t\tqla4_83xx_rd_reg_indirect(ha, raddr, &value);\n\n\tvalue &= p_rmw_hdr->test_mask;\n\tvalue <<= p_rmw_hdr->shl;\n\tvalue >>= p_rmw_hdr->shr;\n\tvalue |= p_rmw_hdr->or_value;\n\tvalue ^= p_rmw_hdr->xor_value;\n\n\tqla4_83xx_wr_reg_indirect(ha, waddr, value);\n\n\treturn;\n}\n\nstatic void qla4_83xx_write_list(struct scsi_qla_host *ha,\n\t\t\t\t struct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tstruct qla4_83xx_entry *p_entry;\n\tuint32_t i;\n\n\tp_entry = (struct qla4_83xx_entry *)\n\t\t  ((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla4_83xx_wr_reg_indirect(ha, p_entry->arg1, p_entry->arg2);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((uint32_t)(p_hdr->delay));\n\t}\n}\n\nstatic void qla4_83xx_read_write_list(struct scsi_qla_host *ha,\n\t\t\t\t      struct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tstruct qla4_83xx_entry *p_entry;\n\tuint32_t i;\n\n\tp_entry = (struct qla4_83xx_entry *)\n\t\t  ((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla4_83xx_read_write_crb_reg(ha, p_entry->arg1, p_entry->arg2);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((uint32_t)(p_hdr->delay));\n\t}\n}\n\nstatic void qla4_83xx_poll_list(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tlong delay;\n\tstruct qla4_83xx_entry *p_entry;\n\tstruct qla4_83xx_poll *p_poll;\n\tuint32_t i;\n\tuint32_t value;\n\n\tp_poll = (struct qla4_83xx_poll *)\n\t\t ((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\n\n\t \n\tp_entry = (struct qla4_83xx_entry *)((char *)p_poll +\n\t\t\t\t\t     sizeof(struct qla4_83xx_poll));\n\n\tdelay = (long)p_hdr->delay;\n\tif (!delay) {\n\t\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\t\tqla4_83xx_poll_reg(ha, p_entry->arg1, delay,\n\t\t\t\t\t   p_poll->test_mask,\n\t\t\t\t\t   p_poll->test_value);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\t\tif (qla4_83xx_poll_reg(ha, p_entry->arg1, delay,\n\t\t\t\t\t       p_poll->test_mask,\n\t\t\t\t\t       p_poll->test_value)) {\n\t\t\t\tqla4_83xx_rd_reg_indirect(ha, p_entry->arg1,\n\t\t\t\t\t\t\t  &value);\n\t\t\t\tqla4_83xx_rd_reg_indirect(ha, p_entry->arg2,\n\t\t\t\t\t\t\t  &value);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void qla4_83xx_poll_write_list(struct scsi_qla_host *ha,\n\t\t\t\t      struct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tlong delay;\n\tstruct qla4_83xx_quad_entry *p_entry;\n\tstruct qla4_83xx_poll *p_poll;\n\tuint32_t i;\n\n\tp_poll = (struct qla4_83xx_poll *)\n\t\t ((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\n\tp_entry = (struct qla4_83xx_quad_entry *)\n\t\t  ((char *)p_poll + sizeof(struct qla4_83xx_poll));\n\tdelay = (long)p_hdr->delay;\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla4_83xx_wr_reg_indirect(ha, p_entry->dr_addr,\n\t\t\t\t\t  p_entry->dr_value);\n\t\tqla4_83xx_wr_reg_indirect(ha, p_entry->ar_addr,\n\t\t\t\t\t  p_entry->ar_value);\n\t\tif (delay) {\n\t\t\tif (qla4_83xx_poll_reg(ha, p_entry->ar_addr, delay,\n\t\t\t\t\t       p_poll->test_mask,\n\t\t\t\t\t       p_poll->test_value)) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"%s: Timeout Error: poll list, item_num %d, entry_num %d\\n\",\n\t\t\t\t\t\t  __func__, i,\n\t\t\t\t\t\t  ha->reset_tmplt.seq_index));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void qla4_83xx_read_modify_write(struct scsi_qla_host *ha,\n\t\t\t\t\tstruct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tstruct qla4_83xx_entry *p_entry;\n\tstruct qla4_83xx_rmw *p_rmw_hdr;\n\tuint32_t i;\n\n\tp_rmw_hdr = (struct qla4_83xx_rmw *)\n\t\t    ((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\n\tp_entry = (struct qla4_83xx_entry *)\n\t\t  ((char *)p_rmw_hdr + sizeof(struct qla4_83xx_rmw));\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla4_83xx_rmw_crb_reg(ha, p_entry->arg1, p_entry->arg2,\n\t\t\t\t      p_rmw_hdr);\n\t\tif (p_hdr->delay)\n\t\t\tudelay((uint32_t)(p_hdr->delay));\n\t}\n}\n\nstatic void qla4_83xx_pause(struct scsi_qla_host *ha,\n\t\t\t    struct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tif (p_hdr->delay)\n\t\tmdelay((uint32_t)((long)p_hdr->delay));\n}\n\nstatic void qla4_83xx_poll_read_list(struct scsi_qla_host *ha,\n\t\t\t\t     struct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tlong delay;\n\tint index;\n\tstruct qla4_83xx_quad_entry *p_entry;\n\tstruct qla4_83xx_poll *p_poll;\n\tuint32_t i;\n\tuint32_t value;\n\n\tp_poll = (struct qla4_83xx_poll *)\n\t\t ((char *)p_hdr + sizeof(struct qla4_83xx_reset_entry_hdr));\n\tp_entry = (struct qla4_83xx_quad_entry *)\n\t\t  ((char *)p_poll + sizeof(struct qla4_83xx_poll));\n\tdelay = (long)p_hdr->delay;\n\n\tfor (i = 0; i < p_hdr->count; i++, p_entry++) {\n\t\tqla4_83xx_wr_reg_indirect(ha, p_entry->ar_addr,\n\t\t\t\t\t  p_entry->ar_value);\n\t\tif (delay) {\n\t\t\tif (qla4_83xx_poll_reg(ha, p_entry->ar_addr, delay,\n\t\t\t\t\t       p_poll->test_mask,\n\t\t\t\t\t       p_poll->test_value)) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"%s: Timeout Error: poll list, Item_num %d, entry_num %d\\n\",\n\t\t\t\t\t\t  __func__, i,\n\t\t\t\t\t\t  ha->reset_tmplt.seq_index));\n\t\t\t} else {\n\t\t\t\tindex = ha->reset_tmplt.array_index;\n\t\t\t\tqla4_83xx_rd_reg_indirect(ha, p_entry->dr_addr,\n\t\t\t\t\t\t\t  &value);\n\t\t\t\tha->reset_tmplt.array[index++] = value;\n\n\t\t\t\tif (index == QLA83XX_MAX_RESET_SEQ_ENTRIES)\n\t\t\t\t\tha->reset_tmplt.array_index = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void qla4_83xx_seq_end(struct scsi_qla_host *ha,\n\t\t\t      struct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tha->reset_tmplt.seq_end = 1;\n}\n\nstatic void qla4_83xx_template_end(struct scsi_qla_host *ha,\n\t\t\t\t   struct qla4_83xx_reset_entry_hdr *p_hdr)\n{\n\tha->reset_tmplt.template_end = 1;\n\n\tif (ha->reset_tmplt.seq_error == 0) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: Reset sequence completed SUCCESSFULLY.\\n\",\n\t\t\t\t  __func__));\n\t} else {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Reset sequence completed with some timeout errors.\\n\",\n\t\t\t   __func__);\n\t}\n}\n\n \nstatic void qla4_83xx_process_reset_template(struct scsi_qla_host *ha,\n\t\t\t\t\t     char *p_buff)\n{\n\tint index, entries;\n\tstruct qla4_83xx_reset_entry_hdr *p_hdr;\n\tchar *p_entry = p_buff;\n\n\tha->reset_tmplt.seq_end = 0;\n\tha->reset_tmplt.template_end = 0;\n\tentries = ha->reset_tmplt.hdr->entries;\n\tindex = ha->reset_tmplt.seq_index;\n\n\tfor (; (!ha->reset_tmplt.seq_end) && (index  < entries); index++) {\n\n\t\tp_hdr = (struct qla4_83xx_reset_entry_hdr *)p_entry;\n\t\tswitch (p_hdr->cmd) {\n\t\tcase OPCODE_NOP:\n\t\t\tbreak;\n\t\tcase OPCODE_WRITE_LIST:\n\t\t\tqla4_83xx_write_list(ha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_READ_WRITE_LIST:\n\t\t\tqla4_83xx_read_write_list(ha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_POLL_LIST:\n\t\t\tqla4_83xx_poll_list(ha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_POLL_WRITE_LIST:\n\t\t\tqla4_83xx_poll_write_list(ha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_READ_MODIFY_WRITE:\n\t\t\tqla4_83xx_read_modify_write(ha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_SEQ_PAUSE:\n\t\t\tqla4_83xx_pause(ha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_SEQ_END:\n\t\t\tqla4_83xx_seq_end(ha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_TMPL_END:\n\t\t\tqla4_83xx_template_end(ha, p_hdr);\n\t\t\tbreak;\n\t\tcase OPCODE_POLL_READ_LIST:\n\t\t\tqla4_83xx_poll_read_list(ha, p_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Unknown command ==> 0x%04x on entry = %d\\n\",\n\t\t\t\t   __func__, p_hdr->cmd, index);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tp_entry += p_hdr->size;\n\t}\n\n\tha->reset_tmplt.seq_index = index;\n}\n\nstatic void qla4_83xx_process_stop_seq(struct scsi_qla_host *ha)\n{\n\tha->reset_tmplt.seq_index = 0;\n\tqla4_83xx_process_reset_template(ha, ha->reset_tmplt.stop_offset);\n\n\tif (ha->reset_tmplt.seq_end != 1)\n\t\tql4_printk(KERN_ERR, ha, \"%s: Abrupt STOP Sub-Sequence end.\\n\",\n\t\t\t   __func__);\n}\n\nstatic void qla4_83xx_process_start_seq(struct scsi_qla_host *ha)\n{\n\tqla4_83xx_process_reset_template(ha, ha->reset_tmplt.start_offset);\n\n\tif (ha->reset_tmplt.template_end != 1)\n\t\tql4_printk(KERN_ERR, ha, \"%s: Abrupt START Sub-Sequence end.\\n\",\n\t\t\t   __func__);\n}\n\nstatic void qla4_83xx_process_init_seq(struct scsi_qla_host *ha)\n{\n\tqla4_83xx_process_reset_template(ha, ha->reset_tmplt.init_offset);\n\n\tif (ha->reset_tmplt.seq_end != 1)\n\t\tql4_printk(KERN_ERR, ha, \"%s: Abrupt INIT Sub-Sequence end.\\n\",\n\t\t\t   __func__);\n}\n\nstatic int qla4_83xx_restart(struct scsi_qla_host *ha)\n{\n\tint ret_val = QLA_SUCCESS;\n\tuint32_t idc_ctrl;\n\n\tqla4_83xx_process_stop_seq(ha);\n\n\t \n\tidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\n\tif (idc_ctrl & GRACEFUL_RESET_BIT1) {\n\t\tqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL,\n\t\t\t\t (idc_ctrl & ~GRACEFUL_RESET_BIT1));\n\t\tql4_printk(KERN_INFO, ha, \"%s: Graceful RESET: Not collecting minidump\\n\",\n\t\t\t   __func__);\n\t} else {\n\t\tqla4_8xxx_get_minidump(ha);\n\t}\n\n\tqla4_83xx_process_init_seq(ha);\n\n\tif (qla4_83xx_copy_bootloader(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Copy bootloader, firmware restart failed!\\n\",\n\t\t\t   __func__);\n\t\tret_val = QLA_ERROR;\n\t\tgoto exit_restart;\n\t}\n\n\tqla4_83xx_wr_reg(ha, QLA83XX_FW_IMAGE_VALID, QLA83XX_BOOT_FROM_FLASH);\n\tqla4_83xx_process_start_seq(ha);\n\nexit_restart:\n\treturn ret_val;\n}\n\nint qla4_83xx_start_firmware(struct scsi_qla_host *ha)\n{\n\tint ret_val = QLA_SUCCESS;\n\n\tret_val = qla4_83xx_restart(ha);\n\tif (ret_val == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Restart error\\n\", __func__);\n\t\tgoto exit_start_fw;\n\t} else {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Restart done\\n\",\n\t\t\t\t  __func__));\n\t}\n\n\tret_val = qla4_83xx_check_cmd_peg_status(ha);\n\tif (ret_val == QLA_ERROR)\n\t\tql4_printk(KERN_ERR, ha, \"%s: Peg not initialized\\n\",\n\t\t\t   __func__);\n\nexit_start_fw:\n\treturn ret_val;\n}\n\n \n\nstatic void qla4_83xx_disable_iocb_intrs(struct scsi_qla_host *ha)\n{\n\tif (test_and_clear_bit(AF_83XX_IOCB_INTR_ON, &ha->flags))\n\t\tqla4_8xxx_intr_disable(ha);\n}\n\nstatic void qla4_83xx_disable_mbox_intrs(struct scsi_qla_host *ha)\n{\n\tuint32_t mb_int, ret;\n\n\tif (test_and_clear_bit(AF_83XX_MBOX_INTR_ON, &ha->flags)) {\n\t\tret = readl(&ha->qla4_83xx_reg->mbox_int);\n\t\tmb_int = ret & ~INT_ENABLE_FW_MB;\n\t\twritel(mb_int, &ha->qla4_83xx_reg->mbox_int);\n\t\twritel(1, &ha->qla4_83xx_reg->leg_int_mask);\n\t}\n}\n\nvoid qla4_83xx_disable_intrs(struct scsi_qla_host *ha)\n{\n\tqla4_83xx_disable_mbox_intrs(ha);\n\tqla4_83xx_disable_iocb_intrs(ha);\n}\n\nstatic void qla4_83xx_enable_iocb_intrs(struct scsi_qla_host *ha)\n{\n\tif (!test_bit(AF_83XX_IOCB_INTR_ON, &ha->flags)) {\n\t\tqla4_8xxx_intr_enable(ha);\n\t\tset_bit(AF_83XX_IOCB_INTR_ON, &ha->flags);\n\t}\n}\n\nvoid qla4_83xx_enable_mbox_intrs(struct scsi_qla_host *ha)\n{\n\tuint32_t mb_int;\n\n\tif (!test_bit(AF_83XX_MBOX_INTR_ON, &ha->flags)) {\n\t\tmb_int = INT_ENABLE_FW_MB;\n\t\twritel(mb_int, &ha->qla4_83xx_reg->mbox_int);\n\t\twritel(0, &ha->qla4_83xx_reg->leg_int_mask);\n\t\tset_bit(AF_83XX_MBOX_INTR_ON, &ha->flags);\n\t}\n}\n\n\nvoid qla4_83xx_enable_intrs(struct scsi_qla_host *ha)\n{\n\tqla4_83xx_enable_mbox_intrs(ha);\n\tqla4_83xx_enable_iocb_intrs(ha);\n}\n\n\nvoid qla4_83xx_queue_mbox_cmd(struct scsi_qla_host *ha, uint32_t *mbx_cmd,\n\t\t\t      int incount)\n{\n\tint i;\n\n\t \n\tfor (i = 1; i < incount; i++)\n\t\twritel(mbx_cmd[i], &ha->qla4_83xx_reg->mailbox_in[i]);\n\n\twritel(mbx_cmd[0], &ha->qla4_83xx_reg->mailbox_in[0]);\n\n\t \n\twritel(HINT_MBX_INT_PENDING, &ha->qla4_83xx_reg->host_intr);\n}\n\nvoid qla4_83xx_process_mbox_intr(struct scsi_qla_host *ha, int outcount)\n{\n\tint intr_status;\n\n\tintr_status = readl(&ha->qla4_83xx_reg->risc_intr);\n\tif (intr_status) {\n\t\tha->mbox_status_count = outcount;\n\t\tha->isp_ops->interrupt_service_routine(ha, intr_status);\n\t}\n}\n\n \nint qla4_83xx_isp_reset(struct scsi_qla_host *ha)\n{\n\tint rval;\n\tuint32_t dev_state;\n\n\tha->isp_ops->idc_lock(ha);\n\tdev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\n\n\tif (ql4xdontresethba)\n\t\tqla4_83xx_set_idc_dontreset(ha);\n\n\tif (dev_state == QLA8XXX_DEV_READY) {\n\t\t \n\t\tif (qla4_83xx_idc_dontreset(ha) == DONTRESET_BIT0) {\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Reset recovery disabled\\n\",\n\t\t\t\t   __func__);\n\t\t\trval = QLA_ERROR;\n\t\t\tgoto exit_isp_reset;\n\t\t}\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: HW State: NEED RESET\\n\",\n\t\t\t\t  __func__));\n\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t    QLA8XXX_DEV_NEED_RESET);\n\n\t} else {\n\t\t \n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: HW state already set to NEED_RESET\\n\",\n\t\t\t\t  __func__));\n\t}\n\n\t \n\tif (qla4_83xx_can_perform_reset(ha))\n\t\tset_bit(AF_8XXX_RST_OWNER, &ha->flags);\n\n\tha->isp_ops->idc_unlock(ha);\n\trval = qla4_8xxx_device_state_handler(ha);\n\n\tha->isp_ops->idc_lock(ha);\n\tqla4_8xxx_clear_rst_ready(ha);\nexit_isp_reset:\n\tha->isp_ops->idc_unlock(ha);\n\n\tif (rval == QLA_SUCCESS)\n\t\tclear_bit(AF_FW_RECOVERY, &ha->flags);\n\n\treturn rval;\n}\n\nstatic void qla4_83xx_dump_pause_control_regs(struct scsi_qla_host *ha)\n{\n\tu32 val = 0, val1 = 0;\n\tint i;\n\n\tqla4_83xx_rd_reg_indirect(ha, QLA83XX_SRE_SHIM_CONTROL, &val);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"SRE-Shim Ctrl:0x%x\\n\", val));\n\n\t \n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\"Port 0 Rx Buffer Pause Threshold Registers[TC7..TC0]:\"));\n\tfor (i = 0; i < 8; i++) {\n\t\tqla4_83xx_rd_reg_indirect(ha,\n\t\t\t\tQLA83XX_PORT0_RXB_PAUSE_THRS + (i * 0x4), &val);\n\t\tDEBUG2(pr_info(\"0x%x \", val));\n\t}\n\n\tDEBUG2(pr_info(\"\\n\"));\n\n\t \n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\"Port 1 Rx Buffer Pause Threshold Registers[TC7..TC0]:\"));\n\tfor (i = 0; i < 8; i++) {\n\t\tqla4_83xx_rd_reg_indirect(ha,\n\t\t\t\tQLA83XX_PORT1_RXB_PAUSE_THRS + (i * 0x4), &val);\n\t\tDEBUG2(pr_info(\"0x%x  \", val));\n\t}\n\n\tDEBUG2(pr_info(\"\\n\"));\n\n\t \n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\"Port 0 RxB Traffic Class Max Cell Registers[3..0]:\"));\n\tfor (i = 0; i < 4; i++) {\n\t\tqla4_83xx_rd_reg_indirect(ha,\n\t\t\t       QLA83XX_PORT0_RXB_TC_MAX_CELL + (i * 0x4), &val);\n\t\tDEBUG2(pr_info(\"0x%x  \", val));\n\t}\n\n\tDEBUG2(pr_info(\"\\n\"));\n\n\t \n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\"Port 1 RxB Traffic Class Max Cell Registers[3..0]:\"));\n\tfor (i = 0; i < 4; i++) {\n\t\tqla4_83xx_rd_reg_indirect(ha,\n\t\t\t       QLA83XX_PORT1_RXB_TC_MAX_CELL + (i * 0x4), &val);\n\t\tDEBUG2(pr_info(\"0x%x  \", val));\n\t}\n\n\tDEBUG2(pr_info(\"\\n\"));\n\n\t \n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Port 0 RxB Rx Traffic Class Stats [TC7..TC0]\"));\n\tfor (i = 7; i >= 0; i--) {\n\t\tqla4_83xx_rd_reg_indirect(ha, QLA83XX_PORT0_RXB_TC_STATS, &val);\n\t\tval &= ~(0x7 << 29);     \n\t\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_PORT0_RXB_TC_STATS,\n\t\t\t\t\t  (val | (i << 29)));\n\t\tqla4_83xx_rd_reg_indirect(ha, QLA83XX_PORT0_RXB_TC_STATS, &val);\n\t\tDEBUG2(pr_info(\"0x%x  \", val));\n\t}\n\n\tDEBUG2(pr_info(\"\\n\"));\n\n\t \n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Port 1 RxB Rx Traffic Class Stats [TC7..TC0]\"));\n\tfor (i = 7; i >= 0; i--) {\n\t\tqla4_83xx_rd_reg_indirect(ha, QLA83XX_PORT1_RXB_TC_STATS, &val);\n\t\tval &= ~(0x7 << 29);     \n\t\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_PORT1_RXB_TC_STATS,\n\t\t\t\t\t  (val | (i << 29)));\n\t\tqla4_83xx_rd_reg_indirect(ha, QLA83XX_PORT1_RXB_TC_STATS, &val);\n\t\tDEBUG2(pr_info(\"0x%x  \", val));\n\t}\n\n\tDEBUG2(pr_info(\"\\n\"));\n\n\tqla4_83xx_rd_reg_indirect(ha, QLA83XX_PORT2_IFB_PAUSE_THRS, &val);\n\tqla4_83xx_rd_reg_indirect(ha, QLA83XX_PORT3_IFB_PAUSE_THRS, &val1);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"IFB-Pause Thresholds: Port 2:0x%x, Port 3:0x%x\\n\",\n\t\t\t  val, val1));\n}\n\nstatic void __qla4_83xx_disable_pause(struct scsi_qla_host *ha)\n{\n\tint i;\n\n\t \n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_SRE_SHIM_CONTROL,\n\t\t\t\t  QLA83XX_SET_PAUSE_VAL);\n\n\tfor (i = 0; i < 8; i++) {\n\t\t \n\t\tqla4_83xx_wr_reg_indirect(ha,\n\t\t\t\t      QLA83XX_PORT0_RXB_PAUSE_THRS + (i * 0x4),\n\t\t\t\t      QLA83XX_SET_PAUSE_VAL);\n\t\t \n\t\tqla4_83xx_wr_reg_indirect(ha,\n\t\t\t\t      QLA83XX_PORT1_RXB_PAUSE_THRS + (i * 0x4),\n\t\t\t\t      QLA83XX_SET_PAUSE_VAL);\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\t \n\t\tqla4_83xx_wr_reg_indirect(ha,\n\t\t\t\t     QLA83XX_PORT0_RXB_TC_MAX_CELL + (i * 0x4),\n\t\t\t\t     QLA83XX_SET_TC_MAX_CELL_VAL);\n\t\t \n\t\tqla4_83xx_wr_reg_indirect(ha,\n\t\t\t\t     QLA83XX_PORT1_RXB_TC_MAX_CELL + (i * 0x4),\n\t\t\t\t     QLA83XX_SET_TC_MAX_CELL_VAL);\n\t}\n\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_PORT2_IFB_PAUSE_THRS,\n\t\t\t\t  QLA83XX_SET_PAUSE_VAL);\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_PORT3_IFB_PAUSE_THRS,\n\t\t\t\t  QLA83XX_SET_PAUSE_VAL);\n\n\tql4_printk(KERN_INFO, ha, \"Disabled pause frames successfully.\\n\");\n}\n\n \nstatic void qla4_83xx_eport_init(struct scsi_qla_host *ha)\n{\n\t \n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_REG, 0x0);\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_PORT0, 0x0);\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_PORT1, 0x0);\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_PORT2, 0x0);\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_PORT3, 0x0);\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_SRE_SHIM, 0x0);\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_EPG_SHIM, 0x0);\n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_ETHER_PCS, 0x0);\n\n\t \n\tqla4_83xx_wr_reg_indirect(ha, QLA83XX_RESET_CONTROL, 0xFF);\n\n\tql4_printk(KERN_INFO, ha, \"EPORT is out of reset.\\n\");\n}\n\nvoid qla4_83xx_disable_pause(struct scsi_qla_host *ha)\n{\n\tha->isp_ops->idc_lock(ha);\n\t \n\tqla4_83xx_eport_init(ha);\n\tqla4_83xx_dump_pause_control_regs(ha);\n\t__qla4_83xx_disable_pause(ha);\n\tha->isp_ops->idc_unlock(ha);\n}\n\n \nint qla4_83xx_is_detached(struct scsi_qla_host *ha)\n{\n\tuint32_t drv_active;\n\n\tdrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\n\n\tif (test_bit(AF_INIT_DONE, &ha->flags) &&\n\t    !(drv_active & (1 << ha->func_num))) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: drv_active = 0x%X\\n\",\n\t\t\t\t  __func__, drv_active));\n\t\treturn QLA_SUCCESS;\n\t}\n\n\treturn QLA_ERROR;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}