{
  "module_name": "ql4_mbx.c",
  "hash_id": "19eba9503811cf85ca14d85b9e3415f4ac1a137455dad9ca8dc101f51b2328cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_mbx.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include \"ql4_def.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n#include \"ql4_inline.h\"\n#include \"ql4_version.h\"\n\nvoid qla4xxx_queue_mbox_cmd(struct scsi_qla_host *ha, uint32_t *mbx_cmd,\n\t\t\t    int in_count)\n{\n\tint i;\n\n\t \n\tfor (i = 1; i < in_count; i++)\n\t\twritel(mbx_cmd[i], &ha->reg->mailbox[i]);\n\n\t \n\twritel(mbx_cmd[0], &ha->reg->mailbox[0]);\n\treadl(&ha->reg->mailbox[0]);\n\twritel(set_rmask(CSR_INTR_RISC), &ha->reg->ctrl_status);\n\treadl(&ha->reg->ctrl_status);\n}\n\nvoid qla4xxx_process_mbox_intr(struct scsi_qla_host *ha, int out_count)\n{\n\tint intr_status;\n\n\tintr_status = readl(&ha->reg->ctrl_status);\n\tif (intr_status & INTR_PENDING) {\n\t\t \n\t\tha->mbox_status_count = out_count;\n\t\tha->isp_ops->interrupt_service_routine(ha, intr_status);\n\t}\n}\n\n \nstatic int qla4xxx_is_intr_poll_mode(struct scsi_qla_host *ha)\n{\n\tint rval = 1;\n\n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tif (test_bit(AF_IRQ_ATTACHED, &ha->flags) &&\n\t\t    test_bit(AF_83XX_MBOX_INTR_ON, &ha->flags))\n\t\t\trval = 0;\n\t} else {\n\t\tif (test_bit(AF_IRQ_ATTACHED, &ha->flags) &&\n\t\t    test_bit(AF_INTERRUPTS_ON, &ha->flags) &&\n\t\t    test_bit(AF_ONLINE, &ha->flags) &&\n\t\t    !test_bit(AF_HA_REMOVAL, &ha->flags))\n\t\t\trval = 0;\n\t}\n\n\treturn rval;\n}\n\n \nint qla4xxx_mailbox_command(struct scsi_qla_host *ha, uint8_t inCount,\n\t\t\t    uint8_t outCount, uint32_t *mbx_cmd,\n\t\t\t    uint32_t *mbx_sts)\n{\n\tint status = QLA_ERROR;\n\tuint8_t i;\n\tu_long wait_count;\n\tunsigned long flags = 0;\n\tuint32_t dev_state;\n\n\t \n\tif (!mbx_cmd || !mbx_sts) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Invalid mbx_cmd or mbx_sts \"\n\t\t\t      \"pointer\\n\", ha->host_no, __func__));\n\t\treturn status;\n\t}\n\n\tif (is_qla40XX(ha)) {\n\t\tif (test_bit(AF_HA_REMOVAL, &ha->flags)) {\n\t\t\tDEBUG2(ql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: \"\n\t\t\t\t\t  \"prematurely completing mbx cmd as \"\n\t\t\t\t\t  \"adapter removal detected\\n\",\n\t\t\t\t\t  ha->host_no, __func__));\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tif ((is_aer_supported(ha)) &&\n\t    (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))) {\n\t\tDEBUG2(printk(KERN_WARNING \"scsi%ld: %s: Perm failure on EEH, \"\n\t\t    \"timeout MBX Exiting.\\n\", ha->host_no, __func__));\n\t\treturn status;\n\t}\n\n\t \n\twait_count = MBOX_TOV * 100;\n\n\twhile (wait_count--) {\n\t\tmutex_lock(&ha->mbox_sem);\n\t\tif (!test_bit(AF_MBOX_COMMAND, &ha->flags)) {\n\t\t\tset_bit(AF_MBOX_COMMAND, &ha->flags);\n\t\t\tmutex_unlock(&ha->mbox_sem);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ha->mbox_sem);\n\t\tif (!wait_count) {\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: mbox_sem failed\\n\",\n\t\t\t\tha->host_no, __func__));\n\t\t\treturn status;\n\t\t}\n\t\tmsleep(10);\n\t}\n\n\tif (is_qla80XX(ha)) {\n\t\tif (test_bit(AF_FW_RECOVERY, &ha->flags)) {\n\t\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t\t  \"scsi%ld: %s: prematurely completing mbx cmd as firmware recovery detected\\n\",\n\t\t\t\t\t  ha->host_no, __func__));\n\t\t\tgoto mbox_exit;\n\t\t}\n\t\t \n\t\tha->isp_ops->idc_lock(ha);\n\t\tdev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\n\t\tha->isp_ops->idc_unlock(ha);\n\t\tif (dev_state == QLA8XXX_DEV_FAILED) {\n\t\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t\t   \"scsi%ld: %s: H/W is in failed state, do not send any mailbox commands\\n\",\n\t\t\t\t   ha->host_no, __func__);\n\t\t\tgoto mbox_exit;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\tha->mbox_status_count = outCount;\n\tfor (i = 0; i < outCount; i++)\n\t\tha->mbox_status[i] = 0;\n\n\t \n\tha->isp_ops->queue_mailbox_command(ha, mbx_cmd, inCount);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t \n\n\t \n\tif (outCount == 0) {\n\t\tstatus = QLA_SUCCESS;\n\t\tgoto mbox_exit;\n\t}\n\n\t \n\tif (qla4xxx_is_intr_poll_mode(ha)) {\n\t\t \n\t\twait_count = jiffies + MBOX_TOV * HZ;\n\t\twhile (test_bit(AF_MBOX_COMMAND_DONE, &ha->flags) == 0) {\n\t\t\tif (time_after_eq(jiffies, wait_count))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\tha->isp_ops->process_mailbox_interrupt(ha, outCount);\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\t\tmsleep(10);\n\t\t}\n\t} else {\n\t\t \n\t\tset_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags);\n\t\twait_for_completion_timeout(&ha->mbx_intr_comp, MBOX_TOV * HZ);\n\t\tclear_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags);\n\t}\n\n\t \n\tif (!test_bit(AF_MBOX_COMMAND_DONE, &ha->flags)) {\n\t\tif (is_qla80XX(ha) &&\n\t\t    test_bit(AF_FW_RECOVERY, &ha->flags)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t    \"scsi%ld: %s: prematurely completing mbx cmd as \"\n\t\t\t    \"firmware recovery detected\\n\",\n\t\t\t    ha->host_no, __func__));\n\t\t\tgoto mbox_exit;\n\t\t}\n\t\tql4_printk(KERN_WARNING, ha, \"scsi%ld: Mailbox Cmd 0x%08X timed out, Scheduling Adapter Reset\\n\",\n\t\t\t   ha->host_no, mbx_cmd[0]);\n\t\tha->mailbox_timeout_count++;\n\t\tmbx_sts[0] = (-1);\n\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\tif (is_qla8022(ha)) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"disabling pause transmit on port 0 & 1.\\n\");\n\t\t\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\n\t\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P0 |\n\t\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P1);\n\t\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\tql4_printk(KERN_INFO, ha, \" %s: disabling pause transmit on port 0 & 1.\\n\",\n\t\t\t\t   __func__);\n\t\t\tqla4_83xx_disable_pause(ha);\n\t\t}\n\t\tgoto mbox_exit;\n\t}\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (i = 0; i < outCount; i++)\n\t\tmbx_sts[i] = ha->mbox_status[i];\n\n\t \n\tswitch (ha->mbox_status[0]) {\n\tcase MBOX_STS_COMMAND_COMPLETE:\n\t\tstatus = QLA_SUCCESS;\n\t\tbreak;\n\n\tcase MBOX_STS_INTERMEDIATE_COMPLETION:\n\t\tstatus = QLA_SUCCESS;\n\t\tbreak;\n\n\tcase MBOX_STS_BUSY:\n\t\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: Cmd = %08X, ISP BUSY\\n\",\n\t\t\t   ha->host_no, __func__, mbx_cmd[0]);\n\t\tha->mailbox_timeout_count++;\n\t\tbreak;\n\n\tdefault:\n\t\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: FAILED, MBOX CMD = %08X, MBOX STS = %08X %08X %08X %08X %08X %08X %08X %08X\\n\",\n\t\t\t   ha->host_no, __func__, mbx_cmd[0], mbx_sts[0],\n\t\t\t   mbx_sts[1], mbx_sts[2], mbx_sts[3], mbx_sts[4],\n\t\t\t   mbx_sts[5], mbx_sts[6], mbx_sts[7]);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\nmbox_exit:\n\tmutex_lock(&ha->mbox_sem);\n\tclear_bit(AF_MBOX_COMMAND, &ha->flags);\n\tmutex_unlock(&ha->mbox_sem);\n\tclear_bit(AF_MBOX_COMMAND_DONE, &ha->flags);\n\n\treturn status;\n}\n\n \nint qla4xxx_get_minidump_template(struct scsi_qla_host *ha,\n\t\t\t\t  dma_addr_t phys_addr)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_MINIDUMP;\n\tmbox_cmd[1] = MINIDUMP_GET_TMPLT_SUBCOMMAND;\n\tmbox_cmd[2] = LSDW(phys_addr);\n\tmbox_cmd[3] = MSDW(phys_addr);\n\tmbox_cmd[4] = ha->fw_dump_tmplt_size;\n\tmbox_cmd[5] = 0;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"scsi%ld: %s: Cmd = %08X, mbx[0] = 0x%04x, mbx[1] = 0x%04x\\n\",\n\t\t\t\t  ha->host_no, __func__, mbox_cmd[0],\n\t\t\t\t  mbox_sts[0], mbox_sts[1]));\n\t}\n\treturn status;\n}\n\n \nint qla4xxx_req_template_size(struct scsi_qla_host *ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_MINIDUMP;\n\tmbox_cmd[1] = MINIDUMP_GET_SIZE_SUBCOMMAND;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 8, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (status == QLA_SUCCESS) {\n\t\tha->fw_dump_tmplt_size = mbox_sts[1];\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: sts[0]=0x%04x, template  size=0x%04x, size_cm_02=0x%04x, size_cm_04=0x%04x, size_cm_08=0x%04x, size_cm_10=0x%04x, size_cm_FF=0x%04x, version=0x%04x\\n\",\n\t\t\t\t  __func__, mbox_sts[0], mbox_sts[1],\n\t\t\t\t  mbox_sts[2], mbox_sts[3], mbox_sts[4],\n\t\t\t\t  mbox_sts[5], mbox_sts[6], mbox_sts[7]));\n\t\tif (ha->fw_dump_tmplt_size == 0)\n\t\t\tstatus = QLA_ERROR;\n\t} else {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s: Error sts[0]=0x%04x, mbx[1]=0x%04x\\n\",\n\t\t\t   __func__, mbox_sts[0], mbox_sts[1]);\n\t\tstatus = QLA_ERROR;\n\t}\n\n\treturn status;\n}\n\nvoid qla4xxx_mailbox_premature_completion(struct scsi_qla_host *ha)\n{\n\tset_bit(AF_FW_RECOVERY, &ha->flags);\n\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: set FW RECOVERY!\\n\",\n\t    ha->host_no, __func__);\n\n\tif (test_bit(AF_MBOX_COMMAND, &ha->flags)) {\n\t\tif (test_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags)) {\n\t\t\tcomplete(&ha->mbx_intr_comp);\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: Due to fw \"\n\t\t\t    \"recovery, doing premature completion of \"\n\t\t\t    \"mbx cmd\\n\", ha->host_no, __func__);\n\n\t\t} else {\n\t\t\tset_bit(AF_MBOX_COMMAND_DONE, &ha->flags);\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: Due to fw \"\n\t\t\t    \"recovery, doing premature completion of \"\n\t\t\t    \"polling mbx cmd\\n\", ha->host_no, __func__);\n\t\t}\n\t}\n}\n\nstatic uint8_t\nqla4xxx_set_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,\n\t\t uint32_t *mbox_sts, dma_addr_t init_fw_cb_dma)\n{\n\tmemset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);\n\tmemset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);\n\n\tif (is_qla8022(ha))\n\t\tqla4_82xx_wr_32(ha, ha->nx_db_wr_ptr, 0);\n\n\tmbox_cmd[0] = MBOX_CMD_INITIALIZE_FIRMWARE;\n\tmbox_cmd[1] = 0;\n\tmbox_cmd[2] = LSDW(init_fw_cb_dma);\n\tmbox_cmd[3] = MSDW(init_fw_cb_dma);\n\tmbox_cmd[4] = sizeof(struct addr_ctrl_blk);\n\n\tif (qla4xxx_mailbox_command(ha, 6, 6, mbox_cmd, mbox_sts) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(KERN_WARNING \"scsi%ld: %s: \"\n\t\t\t      \"MBOX_CMD_INITIALIZE_FIRMWARE\"\n\t\t\t      \" failed w/ status %04X\\n\",\n\t\t\t      ha->host_no, __func__, mbox_sts[0]));\n\t\treturn QLA_ERROR;\n\t}\n\treturn QLA_SUCCESS;\n}\n\nuint8_t\nqla4xxx_get_ifcb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,\n\t\t uint32_t *mbox_sts, dma_addr_t init_fw_cb_dma)\n{\n\tmemset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);\n\tmemset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);\n\tmbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;\n\tmbox_cmd[2] = LSDW(init_fw_cb_dma);\n\tmbox_cmd[3] = MSDW(init_fw_cb_dma);\n\tmbox_cmd[4] = sizeof(struct addr_ctrl_blk);\n\n\tif (qla4xxx_mailbox_command(ha, 5, 5, mbox_cmd, mbox_sts) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(KERN_WARNING \"scsi%ld: %s: \"\n\t\t\t      \"MBOX_CMD_GET_INIT_FW_CTRL_BLOCK\"\n\t\t\t      \" failed w/ status %04X\\n\",\n\t\t\t      ha->host_no, __func__, mbox_sts[0]));\n\t\treturn QLA_ERROR;\n\t}\n\treturn QLA_SUCCESS;\n}\n\nuint8_t qla4xxx_set_ipaddr_state(uint8_t fw_ipaddr_state)\n{\n\tuint8_t ipaddr_state;\n\n\tswitch (fw_ipaddr_state) {\n\tcase IP_ADDRSTATE_UNCONFIGURED:\n\t\tipaddr_state = ISCSI_IPDDRESS_STATE_UNCONFIGURED;\n\t\tbreak;\n\tcase IP_ADDRSTATE_INVALID:\n\t\tipaddr_state = ISCSI_IPDDRESS_STATE_INVALID;\n\t\tbreak;\n\tcase IP_ADDRSTATE_ACQUIRING:\n\t\tipaddr_state = ISCSI_IPDDRESS_STATE_ACQUIRING;\n\t\tbreak;\n\tcase IP_ADDRSTATE_TENTATIVE:\n\t\tipaddr_state = ISCSI_IPDDRESS_STATE_TENTATIVE;\n\t\tbreak;\n\tcase IP_ADDRSTATE_DEPRICATED:\n\t\tipaddr_state = ISCSI_IPDDRESS_STATE_DEPRECATED;\n\t\tbreak;\n\tcase IP_ADDRSTATE_PREFERRED:\n\t\tipaddr_state = ISCSI_IPDDRESS_STATE_VALID;\n\t\tbreak;\n\tcase IP_ADDRSTATE_DISABLING:\n\t\tipaddr_state = ISCSI_IPDDRESS_STATE_DISABLING;\n\t\tbreak;\n\tdefault:\n\t\tipaddr_state = ISCSI_IPDDRESS_STATE_UNCONFIGURED;\n\t}\n\treturn ipaddr_state;\n}\n\nstatic void\nqla4xxx_update_local_ip(struct scsi_qla_host *ha,\n\t\t\tstruct addr_ctrl_blk *init_fw_cb)\n{\n\tha->ip_config.tcp_options = le16_to_cpu(init_fw_cb->ipv4_tcp_opts);\n\tha->ip_config.ipv4_options = le16_to_cpu(init_fw_cb->ipv4_ip_opts);\n\tha->ip_config.ipv4_addr_state =\n\t\t\tqla4xxx_set_ipaddr_state(init_fw_cb->ipv4_addr_state);\n\tha->ip_config.eth_mtu_size =\n\t\t\t\tle16_to_cpu(init_fw_cb->eth_mtu_size);\n\tha->ip_config.ipv4_port = le16_to_cpu(init_fw_cb->ipv4_port);\n\n\tif (ha->acb_version == ACB_SUPPORTED) {\n\t\tha->ip_config.ipv6_options = le16_to_cpu(init_fw_cb->ipv6_opts);\n\t\tha->ip_config.ipv6_addl_options =\n\t\t\t\tle16_to_cpu(init_fw_cb->ipv6_addtl_opts);\n\t\tha->ip_config.ipv6_tcp_options =\n\t\t\t\tle16_to_cpu(init_fw_cb->ipv6_tcp_opts);\n\t}\n\n\t \n\tmemcpy(ha->ip_config.ip_address, init_fw_cb->ipv4_addr,\n\t       min(sizeof(ha->ip_config.ip_address),\n\t\t   sizeof(init_fw_cb->ipv4_addr)));\n\tmemcpy(ha->ip_config.subnet_mask, init_fw_cb->ipv4_subnet,\n\t       min(sizeof(ha->ip_config.subnet_mask),\n\t\t   sizeof(init_fw_cb->ipv4_subnet)));\n\tmemcpy(ha->ip_config.gateway, init_fw_cb->ipv4_gw_addr,\n\t       min(sizeof(ha->ip_config.gateway),\n\t\t   sizeof(init_fw_cb->ipv4_gw_addr)));\n\n\tha->ip_config.ipv4_vlan_tag = be16_to_cpu(init_fw_cb->ipv4_vlan_tag);\n\tha->ip_config.control = init_fw_cb->control;\n\tha->ip_config.tcp_wsf = init_fw_cb->ipv4_tcp_wsf;\n\tha->ip_config.ipv4_tos = init_fw_cb->ipv4_tos;\n\tha->ip_config.ipv4_cache_id = init_fw_cb->ipv4_cacheid;\n\tha->ip_config.ipv4_alt_cid_len = init_fw_cb->ipv4_dhcp_alt_cid_len;\n\tmemcpy(ha->ip_config.ipv4_alt_cid, init_fw_cb->ipv4_dhcp_alt_cid,\n\t       min(sizeof(ha->ip_config.ipv4_alt_cid),\n\t\t   sizeof(init_fw_cb->ipv4_dhcp_alt_cid)));\n\tha->ip_config.ipv4_vid_len = init_fw_cb->ipv4_dhcp_vid_len;\n\tmemcpy(ha->ip_config.ipv4_vid, init_fw_cb->ipv4_dhcp_vid,\n\t       min(sizeof(ha->ip_config.ipv4_vid),\n\t\t   sizeof(init_fw_cb->ipv4_dhcp_vid)));\n\tha->ip_config.ipv4_ttl = init_fw_cb->ipv4_ttl;\n\tha->ip_config.def_timeout = le16_to_cpu(init_fw_cb->def_timeout);\n\tha->ip_config.abort_timer = init_fw_cb->abort_timer;\n\tha->ip_config.iscsi_options = le16_to_cpu(init_fw_cb->iscsi_opts);\n\tha->ip_config.iscsi_max_pdu_size =\n\t\t\t\tle16_to_cpu(init_fw_cb->iscsi_max_pdu_size);\n\tha->ip_config.iscsi_first_burst_len =\n\t\t\t\tle16_to_cpu(init_fw_cb->iscsi_fburst_len);\n\tha->ip_config.iscsi_max_outstnd_r2t =\n\t\t\t\tle16_to_cpu(init_fw_cb->iscsi_max_outstnd_r2t);\n\tha->ip_config.iscsi_max_burst_len =\n\t\t\t\tle16_to_cpu(init_fw_cb->iscsi_max_burst_len);\n\tmemcpy(ha->ip_config.iscsi_name, init_fw_cb->iscsi_name,\n\t       min(sizeof(ha->ip_config.iscsi_name),\n\t\t   sizeof(init_fw_cb->iscsi_name)));\n\n\tif (is_ipv6_enabled(ha)) {\n\t\t \n\t\tha->ip_config.ipv6_link_local_state =\n\t\t  qla4xxx_set_ipaddr_state(init_fw_cb->ipv6_lnk_lcl_addr_state);\n\t\tha->ip_config.ipv6_addr0_state =\n\t\t\tqla4xxx_set_ipaddr_state(init_fw_cb->ipv6_addr0_state);\n\t\tha->ip_config.ipv6_addr1_state =\n\t\t\tqla4xxx_set_ipaddr_state(init_fw_cb->ipv6_addr1_state);\n\n\t\tswitch (le16_to_cpu(init_fw_cb->ipv6_dflt_rtr_state)) {\n\t\tcase IPV6_RTRSTATE_UNKNOWN:\n\t\t\tha->ip_config.ipv6_default_router_state =\n\t\t\t\t\t\tISCSI_ROUTER_STATE_UNKNOWN;\n\t\t\tbreak;\n\t\tcase IPV6_RTRSTATE_MANUAL:\n\t\t\tha->ip_config.ipv6_default_router_state =\n\t\t\t\t\t\tISCSI_ROUTER_STATE_MANUAL;\n\t\t\tbreak;\n\t\tcase IPV6_RTRSTATE_ADVERTISED:\n\t\t\tha->ip_config.ipv6_default_router_state =\n\t\t\t\t\t\tISCSI_ROUTER_STATE_ADVERTISED;\n\t\t\tbreak;\n\t\tcase IPV6_RTRSTATE_STALE:\n\t\t\tha->ip_config.ipv6_default_router_state =\n\t\t\t\t\t\tISCSI_ROUTER_STATE_STALE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tha->ip_config.ipv6_default_router_state =\n\t\t\t\t\t\tISCSI_ROUTER_STATE_UNKNOWN;\n\t\t}\n\n\t\tha->ip_config.ipv6_link_local_addr.in6_u.u6_addr8[0] = 0xFE;\n\t\tha->ip_config.ipv6_link_local_addr.in6_u.u6_addr8[1] = 0x80;\n\n\t\tmemcpy(&ha->ip_config.ipv6_link_local_addr.in6_u.u6_addr8[8],\n\t\t       init_fw_cb->ipv6_if_id,\n\t\t       min(sizeof(ha->ip_config.ipv6_link_local_addr)/2,\n\t\t\t   sizeof(init_fw_cb->ipv6_if_id)));\n\t\tmemcpy(&ha->ip_config.ipv6_addr0, init_fw_cb->ipv6_addr0,\n\t\t       min(sizeof(ha->ip_config.ipv6_addr0),\n\t\t\t   sizeof(init_fw_cb->ipv6_addr0)));\n\t\tmemcpy(&ha->ip_config.ipv6_addr1, init_fw_cb->ipv6_addr1,\n\t\t       min(sizeof(ha->ip_config.ipv6_addr1),\n\t\t\t   sizeof(init_fw_cb->ipv6_addr1)));\n\t\tmemcpy(&ha->ip_config.ipv6_default_router_addr,\n\t\t       init_fw_cb->ipv6_dflt_rtr_addr,\n\t\t       min(sizeof(ha->ip_config.ipv6_default_router_addr),\n\t\t\t   sizeof(init_fw_cb->ipv6_dflt_rtr_addr)));\n\t\tha->ip_config.ipv6_vlan_tag =\n\t\t\t\tbe16_to_cpu(init_fw_cb->ipv6_vlan_tag);\n\t\tha->ip_config.ipv6_port = le16_to_cpu(init_fw_cb->ipv6_port);\n\t\tha->ip_config.ipv6_cache_id = init_fw_cb->ipv6_cache_id;\n\t\tha->ip_config.ipv6_flow_lbl =\n\t\t\t\tle16_to_cpu(init_fw_cb->ipv6_flow_lbl);\n\t\tha->ip_config.ipv6_traffic_class =\n\t\t\t\tinit_fw_cb->ipv6_traffic_class;\n\t\tha->ip_config.ipv6_hop_limit = init_fw_cb->ipv6_hop_limit;\n\t\tha->ip_config.ipv6_nd_reach_time =\n\t\t\t\tle32_to_cpu(init_fw_cb->ipv6_nd_reach_time);\n\t\tha->ip_config.ipv6_nd_rexmit_timer =\n\t\t\t\tle32_to_cpu(init_fw_cb->ipv6_nd_rexmit_timer);\n\t\tha->ip_config.ipv6_nd_stale_timeout =\n\t\t\t\tle32_to_cpu(init_fw_cb->ipv6_nd_stale_timeout);\n\t\tha->ip_config.ipv6_dup_addr_detect_count =\n\t\t\t\t\tinit_fw_cb->ipv6_dup_addr_detect_count;\n\t\tha->ip_config.ipv6_gw_advrt_mtu =\n\t\t\t\tle32_to_cpu(init_fw_cb->ipv6_gw_advrt_mtu);\n\t\tha->ip_config.ipv6_tcp_wsf = init_fw_cb->ipv6_tcp_wsf;\n\t}\n}\n\nuint8_t\nqla4xxx_update_local_ifcb(struct scsi_qla_host *ha,\n\t\t\t  uint32_t *mbox_cmd,\n\t\t\t  uint32_t *mbox_sts,\n\t\t\t  struct addr_ctrl_blk  *init_fw_cb,\n\t\t\t  dma_addr_t init_fw_cb_dma)\n{\n\tif (qla4xxx_get_ifcb(ha, mbox_cmd, mbox_sts, init_fw_cb_dma)\n\t    != QLA_SUCCESS) {\n\t\tDEBUG2(printk(KERN_WARNING\n\t\t\t      \"scsi%ld: %s: Failed to get init_fw_ctrl_blk\\n\",\n\t\t\t      ha->host_no, __func__));\n\t\treturn QLA_ERROR;\n\t}\n\n\tDEBUG2(qla4xxx_dump_buffer(init_fw_cb, sizeof(struct addr_ctrl_blk)));\n\n\t \n\tha->acb_version = init_fw_cb->acb_version;\n\tha->firmware_options = le16_to_cpu(init_fw_cb->fw_options);\n\tha->heartbeat_interval = init_fw_cb->hb_interval;\n\tmemcpy(ha->name_string, init_fw_cb->iscsi_name,\n\t\tmin(sizeof(ha->name_string),\n\t\tsizeof(init_fw_cb->iscsi_name)));\n\tha->def_timeout = le16_to_cpu(init_fw_cb->def_timeout);\n\t \n\n\tqla4xxx_update_local_ip(ha, init_fw_cb);\n\n\treturn QLA_SUCCESS;\n}\n\n \nint qla4xxx_initialize_fw_cb(struct scsi_qla_host * ha)\n{\n\tstruct addr_ctrl_blk *init_fw_cb;\n\tdma_addr_t init_fw_cb_dma;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_ERROR;\n\n\tinit_fw_cb = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\tsizeof(struct addr_ctrl_blk),\n\t\t\t\t\t&init_fw_cb_dma, GFP_KERNEL);\n\tif (init_fw_cb == NULL) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Unable to alloc init_cb\\n\",\n\t\t\t      ha->host_no, __func__));\n\t\tgoto exit_init_fw_cb_no_free;\n\t}\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tif (qla4xxx_get_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma) !=\n\t    QLA_SUCCESS) {\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\t \n\tinit_fw_cb->rqq_consumer_idx = cpu_to_le16(ha->request_out);\n\tinit_fw_cb->compq_producer_idx = cpu_to_le16(ha->response_in);\n\tinit_fw_cb->rqq_len = cpu_to_le16(REQUEST_QUEUE_DEPTH);\n\tinit_fw_cb->compq_len = cpu_to_le16(RESPONSE_QUEUE_DEPTH);\n\tinit_fw_cb->rqq_addr_lo = cpu_to_le32(LSDW(ha->request_dma));\n\tinit_fw_cb->rqq_addr_hi = cpu_to_le32(MSDW(ha->request_dma));\n\tinit_fw_cb->compq_addr_lo = cpu_to_le32(LSDW(ha->response_dma));\n\tinit_fw_cb->compq_addr_hi = cpu_to_le32(MSDW(ha->response_dma));\n\tinit_fw_cb->shdwreg_addr_lo = cpu_to_le32(LSDW(ha->shadow_regs_dma));\n\tinit_fw_cb->shdwreg_addr_hi = cpu_to_le32(MSDW(ha->shadow_regs_dma));\n\n\t \n\tinit_fw_cb->fw_options |=\n\t\tcpu_to_le16(FWOPT_SESSION_MODE |\n\t\t\t    FWOPT_INITIATOR_MODE);\n\n\tif (is_qla80XX(ha))\n\t\tinit_fw_cb->fw_options |=\n\t\t    cpu_to_le16(FWOPT_ENABLE_CRBDB);\n\n\tinit_fw_cb->fw_options &= cpu_to_le16(~FWOPT_TARGET_MODE);\n\n\tinit_fw_cb->add_fw_options = 0;\n\tinit_fw_cb->add_fw_options |=\n\t\t\tcpu_to_le16(ADFWOPT_SERIALIZE_TASK_MGMT);\n\tinit_fw_cb->add_fw_options |=\n\t\t\tcpu_to_le16(ADFWOPT_AUTOCONN_DISABLE);\n\n\tif (qla4xxx_set_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma)\n\t\t!= QLA_SUCCESS) {\n\t\tDEBUG2(printk(KERN_WARNING\n\t\t\t      \"scsi%ld: %s: Failed to set init_fw_ctrl_blk\\n\",\n\t\t\t      ha->host_no, __func__));\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\tif (qla4xxx_update_local_ifcb(ha, &mbox_cmd[0], &mbox_sts[0],\n\t\tinit_fw_cb, init_fw_cb_dma) != QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Failed to update local ifcb\\n\",\n\t\t\t\tha->host_no, __func__));\n\t\tgoto exit_init_fw_cb;\n\t}\n\tstatus = QLA_SUCCESS;\n\nexit_init_fw_cb:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),\n\t\t\t\tinit_fw_cb, init_fw_cb_dma);\nexit_init_fw_cb_no_free:\n\treturn status;\n}\n\n \nint qla4xxx_get_dhcp_ip_address(struct scsi_qla_host * ha)\n{\n\tstruct addr_ctrl_blk *init_fw_cb;\n\tdma_addr_t init_fw_cb_dma;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tinit_fw_cb = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\tsizeof(struct addr_ctrl_blk),\n\t\t\t\t\t&init_fw_cb_dma, GFP_KERNEL);\n\tif (init_fw_cb == NULL) {\n\t\tprintk(\"scsi%ld: %s: Unable to alloc init_cb\\n\", ha->host_no,\n\t\t       __func__);\n\t\treturn QLA_ERROR;\n\t}\n\n\t \n\tif (qla4xxx_get_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Failed to get init_fw_ctrl_blk\\n\",\n\t\t\t      ha->host_no, __func__));\n\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t\t  sizeof(struct addr_ctrl_blk),\n\t\t\t\t  init_fw_cb, init_fw_cb_dma);\n\t\treturn QLA_ERROR;\n\t}\n\n\t \n\tqla4xxx_update_local_ip(ha, init_fw_cb);\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),\n\t\t\t\tinit_fw_cb, init_fw_cb_dma);\n\n\treturn QLA_SUCCESS;\n}\n\n \nint qla4xxx_get_firmware_state(struct scsi_qla_host * ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_FW_STATE;\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 4, &mbox_cmd[0], &mbox_sts[0]) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: MBOX_CMD_GET_FW_STATE failed w/ \"\n\t\t\t      \"status %04X\\n\", ha->host_no, __func__,\n\t\t\t      mbox_sts[0]));\n\t\treturn QLA_ERROR;\n\t}\n\tha->firmware_state = mbox_sts[1];\n\tha->board_id = mbox_sts[2];\n\tha->addl_fw_state = mbox_sts[3];\n\tDEBUG2(printk(\"scsi%ld: %s firmware_state=0x%x\\n\",\n\t\t      ha->host_no, __func__, ha->firmware_state);)\n\n\treturn QLA_SUCCESS;\n}\n\n \nint qla4xxx_get_firmware_status(struct scsi_qla_host * ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_FW_STATUS;\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 3, &mbox_cmd[0], &mbox_sts[0]) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: MBOX_CMD_GET_FW_STATUS failed w/ \"\n\t\t\t      \"status %04X\\n\", ha->host_no, __func__,\n\t\t\t      mbox_sts[0]));\n\t\treturn QLA_ERROR;\n\t}\n\n\t \n\tha->iocb_hiwat = mbox_sts[2];\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: firmware IOCBs available = %d\\n\", __func__,\n\t\t\t  ha->iocb_hiwat));\n\n\tif (ha->iocb_hiwat > IOCB_HIWAT_CUSHION)\n\t\tha->iocb_hiwat -= IOCB_HIWAT_CUSHION;\n\n\t \n\tif (ha->iocb_hiwat == 0) {\n\t\tha->iocb_hiwat = REQUEST_QUEUE_DEPTH / 4;\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"%s: Setting IOCB's to = %d\\n\", __func__,\n\t\t\t\t  ha->iocb_hiwat));\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\n \nint qla4xxx_get_fwddb_entry(struct scsi_qla_host *ha,\n\t\t\t    uint16_t fw_ddb_index,\n\t\t\t    struct dev_db_entry *fw_ddb_entry,\n\t\t\t    dma_addr_t fw_ddb_entry_dma,\n\t\t\t    uint32_t *num_valid_ddb_entries,\n\t\t\t    uint32_t *next_ddb_index,\n\t\t\t    uint32_t *fw_ddb_device_state,\n\t\t\t    uint32_t *conn_err_detail,\n\t\t\t    uint16_t *tcp_source_port_num,\n\t\t\t    uint16_t *connection_id)\n{\n\tint status = QLA_ERROR;\n\tuint16_t options;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\t \n\tif (fw_ddb_index >= MAX_DDB_ENTRIES) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: ddb [%d] out of range.\\n\",\n\t\t\t      ha->host_no, __func__, fw_ddb_index));\n\t\tgoto exit_get_fwddb;\n\t}\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\tif (fw_ddb_entry)\n\t\tmemset(fw_ddb_entry, 0, sizeof(struct dev_db_entry));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;\n\tmbox_cmd[1] = (uint32_t) fw_ddb_index;\n\tmbox_cmd[2] = LSDW(fw_ddb_entry_dma);\n\tmbox_cmd[3] = MSDW(fw_ddb_entry_dma);\n\tmbox_cmd[4] = sizeof(struct dev_db_entry);\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 7, &mbox_cmd[0], &mbox_sts[0]) ==\n\t    QLA_ERROR) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: MBOX_CMD_GET_DATABASE_ENTRY failed\"\n\t\t\t      \" with status 0x%04X\\n\", ha->host_no, __func__,\n\t\t\t      mbox_sts[0]));\n\t\tgoto exit_get_fwddb;\n\t}\n\tif (fw_ddb_index != mbox_sts[1]) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: ddb mismatch [%d] != [%d].\\n\",\n\t\t\t      ha->host_no, __func__, fw_ddb_index,\n\t\t\t      mbox_sts[1]));\n\t\tgoto exit_get_fwddb;\n\t}\n\tif (fw_ddb_entry) {\n\t\toptions = le16_to_cpu(fw_ddb_entry->options);\n\t\tif (options & DDB_OPT_IPV6_DEVICE) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: DDB[%d] MB0 %04x Tot %d \"\n\t\t\t\t\"Next %d State %04x ConnErr %08x %pI6 \"\n\t\t\t\t\":%04d \\\"%s\\\"\\n\", __func__, fw_ddb_index,\n\t\t\t\tmbox_sts[0], mbox_sts[2], mbox_sts[3],\n\t\t\t\tmbox_sts[4], mbox_sts[5],\n\t\t\t\tfw_ddb_entry->ip_addr,\n\t\t\t\tle16_to_cpu(fw_ddb_entry->port),\n\t\t\t\tfw_ddb_entry->iscsi_name);\n\t\t} else {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: DDB[%d] MB0 %04x Tot %d \"\n\t\t\t\t\"Next %d State %04x ConnErr %08x %pI4 \"\n\t\t\t\t\":%04d \\\"%s\\\"\\n\", __func__, fw_ddb_index,\n\t\t\t\tmbox_sts[0], mbox_sts[2], mbox_sts[3],\n\t\t\t\tmbox_sts[4], mbox_sts[5],\n\t\t\t\tfw_ddb_entry->ip_addr,\n\t\t\t\tle16_to_cpu(fw_ddb_entry->port),\n\t\t\t\tfw_ddb_entry->iscsi_name);\n\t\t}\n\t}\n\tif (num_valid_ddb_entries)\n\t\t*num_valid_ddb_entries = mbox_sts[2];\n\tif (next_ddb_index)\n\t\t*next_ddb_index = mbox_sts[3];\n\tif (fw_ddb_device_state)\n\t\t*fw_ddb_device_state = mbox_sts[4];\n\n\t \n\tif (conn_err_detail)\n\t\t*conn_err_detail = mbox_sts[5];\n\tif (tcp_source_port_num)\n\t\t*tcp_source_port_num = (uint16_t) (mbox_sts[6] >> 16);\n\tif (connection_id)\n\t\t*connection_id = (uint16_t) mbox_sts[6] & 0x00FF;\n\tstatus = QLA_SUCCESS;\n\nexit_get_fwddb:\n\treturn status;\n}\n\nint qla4xxx_conn_open(struct scsi_qla_host *ha, uint16_t fw_ddb_index)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_CONN_OPEN;\n\tmbox_cmd[1] = fw_ddb_index;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: status = %d mbx0 = 0x%x mbx1 = 0x%x\\n\",\n\t\t\t  __func__, status, mbox_sts[0], mbox_sts[1]));\n\treturn status;\n}\n\n \nint qla4xxx_set_ddb_entry(struct scsi_qla_host * ha, uint16_t fw_ddb_index,\n\t\t\t  dma_addr_t fw_ddb_entry_dma, uint32_t *mbx_sts)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status;\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_SET_DATABASE_ENTRY;\n\tmbox_cmd[1] = (uint32_t) fw_ddb_index;\n\tmbox_cmd[2] = LSDW(fw_ddb_entry_dma);\n\tmbox_cmd[3] = MSDW(fw_ddb_entry_dma);\n\tmbox_cmd[4] = sizeof(struct dev_db_entry);\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (mbx_sts)\n\t\t*mbx_sts = mbox_sts[0];\n\tDEBUG2(printk(\"scsi%ld: %s: status=%d mbx0=0x%x mbx4=0x%x\\n\",\n\t    ha->host_no, __func__, status, mbox_sts[0], mbox_sts[4]);)\n\n\treturn status;\n}\n\nint qla4xxx_session_logout_ddb(struct scsi_qla_host *ha,\n\t\t\t       struct ddb_entry *ddb_entry, int options)\n{\n\tint status;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;\n\tmbox_cmd[1] = ddb_entry->fw_ddb_index;\n\tmbox_cmd[3] = options;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: MBOX_CMD_CONN_CLOSE_SESS_LOGOUT \"\n\t\t\t\t  \"failed sts %04X %04X\", __func__,\n\t\t\t\t  mbox_sts[0], mbox_sts[1]));\n\t\tif ((mbox_sts[0] == MBOX_STS_COMMAND_ERROR) &&\n\t\t    (mbox_sts[1] == DDB_NOT_LOGGED_IN)) {\n\t\t\tset_bit(DDB_CONN_CLOSE_FAILURE, &ddb_entry->flags);\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nvoid qla4xxx_get_crash_record(struct scsi_qla_host * ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tstruct crash_record *crash_record = NULL;\n\tdma_addr_t crash_record_dma = 0;\n\tuint32_t crash_record_size = 0;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_cmd));\n\n\t \n\tmbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: ERROR: Unable to retrieve size!\\n\",\n\t\t\t      ha->host_no, __func__));\n\t\tgoto exit_get_crash_record;\n\t}\n\tcrash_record_size = mbox_sts[4];\n\tif (crash_record_size == 0) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: ERROR: Crash record size is 0!\\n\",\n\t\t\t      ha->host_no, __func__));\n\t\tgoto exit_get_crash_record;\n\t}\n\n\t \n\tcrash_record = dma_alloc_coherent(&ha->pdev->dev, crash_record_size,\n\t\t\t\t\t  &crash_record_dma, GFP_KERNEL);\n\tif (crash_record == NULL)\n\t\tgoto exit_get_crash_record;\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_cmd));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_CRASH_RECORD;\n\tmbox_cmd[2] = LSDW(crash_record_dma);\n\tmbox_cmd[3] = MSDW(crash_record_dma);\n\tmbox_cmd[4] = crash_record_size;\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=\n\t    QLA_SUCCESS)\n\t\tgoto exit_get_crash_record;\n\n\t \n\nexit_get_crash_record:\n\tif (crash_record)\n\t\tdma_free_coherent(&ha->pdev->dev, crash_record_size,\n\t\t\t\t  crash_record, crash_record_dma);\n}\n\n \nvoid qla4xxx_get_conn_event_log(struct scsi_qla_host * ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tstruct conn_event_log_entry *event_log = NULL;\n\tdma_addr_t event_log_dma = 0;\n\tuint32_t event_log_size = 0;\n\tuint32_t num_valid_entries;\n\tuint32_t      oldest_entry = 0;\n\tuint32_t\tmax_event_log_entries;\n\tuint8_t\t\ti;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_cmd));\n\n\t \n\tmbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=\n\t    QLA_SUCCESS)\n\t\tgoto exit_get_event_log;\n\n\tevent_log_size = mbox_sts[4];\n\tif (event_log_size == 0)\n\t\tgoto exit_get_event_log;\n\n\t \n\tevent_log = dma_alloc_coherent(&ha->pdev->dev, event_log_size,\n\t\t\t\t       &event_log_dma, GFP_KERNEL);\n\tif (event_log == NULL)\n\t\tgoto exit_get_event_log;\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_cmd));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_CONN_EVENT_LOG;\n\tmbox_cmd[2] = LSDW(event_log_dma);\n\tmbox_cmd[3] = MSDW(event_log_dma);\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: ERROR: Unable to retrieve event \"\n\t\t\t      \"log!\\n\", ha->host_no, __func__));\n\t\tgoto exit_get_event_log;\n\t}\n\n\t \n\tnum_valid_entries = mbox_sts[1];\n\n\tmax_event_log_entries = event_log_size /\n\t\tsizeof(struct conn_event_log_entry);\n\n\tif (num_valid_entries > max_event_log_entries)\n\t\toldest_entry = num_valid_entries % max_event_log_entries;\n\n\tDEBUG3(printk(\"scsi%ld: Connection Event Log Dump (%d entries):\\n\",\n\t\t      ha->host_no, num_valid_entries));\n\n\tif (ql4xextended_error_logging == 3) {\n\t\tif (oldest_entry == 0) {\n\t\t\t \n\t\t\tfor (i=0; i < num_valid_entries; i++) {\n\t\t\t\tqla4xxx_dump_buffer((uint8_t *)event_log+\n\t\t\t\t\t\t    (i*sizeof(*event_log)),\n\t\t\t\t\t\t    sizeof(*event_log));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tfor (i=oldest_entry; i < max_event_log_entries; i++) {\n\t\t\t\tqla4xxx_dump_buffer((uint8_t *)event_log+\n\t\t\t\t\t\t    (i*sizeof(*event_log)),\n\t\t\t\t\t\t    sizeof(*event_log));\n\t\t\t}\n\t\t\tfor (i=0; i < oldest_entry; i++) {\n\t\t\t\tqla4xxx_dump_buffer((uint8_t *)event_log+\n\t\t\t\t\t\t    (i*sizeof(*event_log)),\n\t\t\t\t\t\t    sizeof(*event_log));\n\t\t\t}\n\t\t}\n\t}\n\nexit_get_event_log:\n\tif (event_log)\n\t\tdma_free_coherent(&ha->pdev->dev, event_log_size, event_log,\n\t\t\t\t  event_log_dma);\n}\n\n \nint qla4xxx_abort_task(struct scsi_qla_host *ha, struct srb *srb)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\tint status = QLA_SUCCESS;\n\tunsigned long flags = 0;\n\tuint32_t index;\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tindex = (unsigned long)(unsigned char *)cmd->host_scribble;\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t \n\tif (index == MAX_SRBS)\n\t\treturn status;\n\n\tmbox_cmd[0] = MBOX_CMD_ABORT_TASK;\n\tmbox_cmd[1] = srb->ddb->fw_ddb_index;\n\tmbox_cmd[2] = index;\n\t \n\tmbox_cmd[5] = 0x01;\n\n\tqla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0],\n\t    &mbox_sts[0]);\n\tif (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE) {\n\t\tstatus = QLA_ERROR;\n\n\t\tDEBUG2(printk(KERN_WARNING \"scsi%ld:%d:%llu: abort task FAILED: \"\n\t\t    \"mbx0=%04X, mb1=%04X, mb2=%04X, mb3=%04X, mb4=%04X\\n\",\n\t\t    ha->host_no, cmd->device->id, cmd->device->lun, mbox_sts[0],\n\t\t    mbox_sts[1], mbox_sts[2], mbox_sts[3], mbox_sts[4]));\n\t}\n\n\treturn status;\n}\n\n \nint qla4xxx_reset_lun(struct scsi_qla_host * ha, struct ddb_entry * ddb_entry,\n\t\t      uint64_t lun)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tuint32_t scsi_lun[2];\n\tint status = QLA_SUCCESS;\n\n\tDEBUG2(printk(\"scsi%ld:%d:%llu: lun reset issued\\n\", ha->host_no,\n\t\t      ddb_entry->fw_ddb_index, lun));\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\tint_to_scsilun(lun, (struct scsi_lun *) scsi_lun);\n\n\tmbox_cmd[0] = MBOX_CMD_LUN_RESET;\n\tmbox_cmd[1] = ddb_entry->fw_ddb_index;\n\t \n\tmbox_cmd[2] = cpu_to_le32(scsi_lun[0]);\n\t \n\tmbox_cmd[3] = cpu_to_le32(scsi_lun[1]);\n\tmbox_cmd[5] = 0x01;\t \n\n\tqla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]);\n\tif (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE &&\n\t    mbox_sts[0] != MBOX_STS_COMMAND_ERROR)\n\t\tstatus = QLA_ERROR;\n\n\treturn status;\n}\n\n \nint qla4xxx_reset_target(struct scsi_qla_host *ha,\n\t\t\t struct ddb_entry *ddb_entry)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_SUCCESS;\n\n\tDEBUG2(printk(\"scsi%ld:%d: target reset issued\\n\", ha->host_no,\n\t\t      ddb_entry->fw_ddb_index));\n\n\t \n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_TARGET_WARM_RESET;\n\tmbox_cmd[1] = ddb_entry->fw_ddb_index;\n\tmbox_cmd[5] = 0x01;\t \n\n\tqla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\n\t\t\t\t&mbox_sts[0]);\n\tif (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE &&\n\t    mbox_sts[0] != MBOX_STS_COMMAND_ERROR)\n\t\tstatus = QLA_ERROR;\n\n\treturn status;\n}\n\nint qla4xxx_get_flash(struct scsi_qla_host * ha, dma_addr_t dma_addr,\n\t\t      uint32_t offset, uint32_t len)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_READ_FLASH;\n\tmbox_cmd[1] = LSDW(dma_addr);\n\tmbox_cmd[2] = MSDW(dma_addr);\n\tmbox_cmd[3] = offset;\n\tmbox_cmd[4] = len;\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: MBOX_CMD_READ_FLASH, failed w/ \"\n\t\t    \"status %04X %04X, offset %08x, len %08x\\n\", ha->host_no,\n\t\t    __func__, mbox_sts[0], mbox_sts[1], offset, len));\n\t\treturn QLA_ERROR;\n\t}\n\treturn QLA_SUCCESS;\n}\n\n \nint qla4xxx_about_firmware(struct scsi_qla_host *ha)\n{\n\tstruct about_fw_info *about_fw = NULL;\n\tdma_addr_t about_fw_dma;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_ERROR;\n\n\tabout_fw = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t      sizeof(struct about_fw_info),\n\t\t\t\t      &about_fw_dma, GFP_KERNEL);\n\tif (!about_fw) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s: Unable to alloc memory \"\n\t\t\t\t  \"for about_fw\\n\", __func__));\n\t\treturn status;\n\t}\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_ABOUT_FW;\n\tmbox_cmd[2] = LSDW(about_fw_dma);\n\tmbox_cmd[3] = MSDW(about_fw_dma);\n\tmbox_cmd[4] = sizeof(struct about_fw_info);\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\n\t\t\t\t\t &mbox_cmd[0], &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha, \"%s: MBOX_CMD_ABOUT_FW \"\n\t\t\t\t  \"failed w/ status %04X\\n\", __func__,\n\t\t\t\t  mbox_sts[0]));\n\t\tgoto exit_about_fw;\n\t}\n\n\t \n\tha->fw_info.fw_major = le16_to_cpu(about_fw->fw_major);\n\tha->fw_info.fw_minor = le16_to_cpu(about_fw->fw_minor);\n\tha->fw_info.fw_patch = le16_to_cpu(about_fw->fw_patch);\n\tha->fw_info.fw_build = le16_to_cpu(about_fw->fw_build);\n\tmemcpy(ha->fw_info.fw_build_date, about_fw->fw_build_date,\n\t       sizeof(about_fw->fw_build_date));\n\tmemcpy(ha->fw_info.fw_build_time, about_fw->fw_build_time,\n\t       sizeof(about_fw->fw_build_time));\n\tstrcpy((char *)ha->fw_info.fw_build_user,\n\t       skip_spaces((char *)about_fw->fw_build_user));\n\tha->fw_info.fw_load_source = le16_to_cpu(about_fw->fw_load_source);\n\tha->fw_info.iscsi_major = le16_to_cpu(about_fw->iscsi_major);\n\tha->fw_info.iscsi_minor = le16_to_cpu(about_fw->iscsi_minor);\n\tha->fw_info.bootload_major = le16_to_cpu(about_fw->bootload_major);\n\tha->fw_info.bootload_minor = le16_to_cpu(about_fw->bootload_minor);\n\tha->fw_info.bootload_patch = le16_to_cpu(about_fw->bootload_patch);\n\tha->fw_info.bootload_build = le16_to_cpu(about_fw->bootload_build);\n\tstrcpy((char *)ha->fw_info.extended_timestamp,\n\t       skip_spaces((char *)about_fw->extended_timestamp));\n\n\tha->fw_uptime_secs = le32_to_cpu(mbox_sts[5]);\n\tha->fw_uptime_msecs = le32_to_cpu(mbox_sts[6]);\n\tstatus = QLA_SUCCESS;\n\nexit_about_fw:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct about_fw_info),\n\t\t\t  about_fw, about_fw_dma);\n\treturn status;\n}\n\nint qla4xxx_get_default_ddb(struct scsi_qla_host *ha, uint32_t options,\n\t\t\t    dma_addr_t dma_addr)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY_DEFAULTS;\n\tmbox_cmd[1] = options;\n\tmbox_cmd[2] = LSDW(dma_addr);\n\tmbox_cmd[3] = MSDW(dma_addr);\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) !=\n\t    QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: failed status %04X\\n\",\n\t\t     ha->host_no, __func__, mbox_sts[0]));\n\t\treturn QLA_ERROR;\n\t}\n\treturn QLA_SUCCESS;\n}\n\nint qla4xxx_req_ddb_entry(struct scsi_qla_host *ha, uint32_t ddb_index,\n\t\t\t  uint32_t *mbx_sts)\n{\n\tint status;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_REQUEST_DATABASE_ENTRY;\n\tmbox_cmd[1] = ddb_index;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s: failed status %04X\\n\",\n\t\t\t\t   __func__, mbox_sts[0]));\n\t}\n\n\t*mbx_sts = mbox_sts[0];\n\treturn status;\n}\n\nint qla4xxx_clear_ddb_entry(struct scsi_qla_host *ha, uint32_t ddb_index)\n{\n\tint status;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_CLEAR_DATABASE_ENTRY;\n\tmbox_cmd[1] = ddb_index;\n\n\tstatus = qla4xxx_mailbox_command(ha, 2, 1, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s: failed status %04X\\n\",\n\t\t\t\t   __func__, mbox_sts[0]));\n\t}\n\n\treturn status;\n}\n\nint qla4xxx_set_flash(struct scsi_qla_host *ha, dma_addr_t dma_addr,\n\t\t      uint32_t offset, uint32_t length, uint32_t options)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_SUCCESS;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_WRITE_FLASH;\n\tmbox_cmd[1] = LSDW(dma_addr);\n\tmbox_cmd[2] = MSDW(dma_addr);\n\tmbox_cmd[3] = offset;\n\tmbox_cmd[4] = length;\n\tmbox_cmd[5] = options;\n\n\tstatus = qla4xxx_mailbox_command(ha, 6, 2, &mbox_cmd[0], &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha, \"%s: MBOX_CMD_WRITE_FLASH \"\n\t\t\t\t  \"failed w/ status %04X, mbx1 %04X\\n\",\n\t\t\t\t  __func__, mbox_sts[0], mbox_sts[1]));\n\t}\n\treturn status;\n}\n\nint qla4xxx_bootdb_by_index(struct scsi_qla_host *ha,\n\t\t\t    struct dev_db_entry *fw_ddb_entry,\n\t\t\t    dma_addr_t fw_ddb_entry_dma, uint16_t ddb_index)\n{\n\tuint32_t dev_db_start_offset = FLASH_OFFSET_DB_INFO;\n\tuint32_t dev_db_end_offset;\n\tint status = QLA_ERROR;\n\n\tmemset(fw_ddb_entry, 0, sizeof(*fw_ddb_entry));\n\n\tdev_db_start_offset += (ddb_index * sizeof(*fw_ddb_entry));\n\tdev_db_end_offset = FLASH_OFFSET_DB_END;\n\n\tif (dev_db_start_offset > dev_db_end_offset) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s:Invalid DDB index %d\", __func__,\n\t\t\t\t  ddb_index));\n\t\tgoto exit_bootdb_failed;\n\t}\n\n\tif (qla4xxx_get_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\n\t\t\t      sizeof(*fw_ddb_entry)) != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"scsi%ld: %s: Get Flash\"\n\t\t\t   \"failed\\n\", ha->host_no, __func__);\n\t\tgoto exit_bootdb_failed;\n\t}\n\n\tif (fw_ddb_entry->cookie == DDB_VALID_COOKIE)\n\t\tstatus = QLA_SUCCESS;\n\nexit_bootdb_failed:\n\treturn status;\n}\n\nint qla4xxx_flashdb_by_index(struct scsi_qla_host *ha,\n\t\t\t     struct dev_db_entry *fw_ddb_entry,\n\t\t\t     dma_addr_t fw_ddb_entry_dma, uint16_t ddb_index)\n{\n\tuint32_t dev_db_start_offset;\n\tuint32_t dev_db_end_offset;\n\tint status = QLA_ERROR;\n\n\tmemset(fw_ddb_entry, 0, sizeof(*fw_ddb_entry));\n\n\tif (is_qla40XX(ha)) {\n\t\tdev_db_start_offset = FLASH_OFFSET_DB_INFO;\n\t\tdev_db_end_offset = FLASH_OFFSET_DB_END;\n\t} else {\n\t\tdev_db_start_offset = FLASH_RAW_ACCESS_ADDR +\n\t\t\t\t      (ha->hw.flt_region_ddb << 2);\n\t\t \n\t\tif (ha->port_num == 1)\n\t\t\tdev_db_start_offset += (ha->hw.flt_ddb_size / 2);\n\n\t\tdev_db_end_offset = dev_db_start_offset +\n\t\t\t\t    (ha->hw.flt_ddb_size / 2);\n\t}\n\n\tdev_db_start_offset += (ddb_index * sizeof(*fw_ddb_entry));\n\n\tif (dev_db_start_offset > dev_db_end_offset) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s:Invalid DDB index %d\", __func__,\n\t\t\t\t  ddb_index));\n\t\tgoto exit_fdb_failed;\n\t}\n\n\tif (qla4xxx_get_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\n\t\t\t      sizeof(*fw_ddb_entry)) != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"scsi%ld: %s: Get Flash failed\\n\",\n\t\t\t   ha->host_no, __func__);\n\t\tgoto exit_fdb_failed;\n\t}\n\n\tif (fw_ddb_entry->cookie == DDB_VALID_COOKIE)\n\t\tstatus = QLA_SUCCESS;\n\nexit_fdb_failed:\n\treturn status;\n}\n\nint qla4xxx_get_chap(struct scsi_qla_host *ha, char *username, char *password,\n\t\t     uint16_t idx)\n{\n\tint ret = 0;\n\tint rval = QLA_ERROR;\n\tuint32_t offset = 0, chap_size;\n\tstruct ql4_chap_table *chap_table;\n\tdma_addr_t chap_dma;\n\n\tchap_table = dma_pool_zalloc(ha->chap_dma_pool, GFP_KERNEL, &chap_dma);\n\tif (chap_table == NULL)\n\t\treturn -ENOMEM;\n\n\tchap_size = sizeof(struct ql4_chap_table);\n\n\tif (is_qla40XX(ha))\n\t\toffset = FLASH_CHAP_OFFSET | (idx * chap_size);\n\telse {\n\t\toffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\n\t\t \n\t\tif (ha->port_num == 1)\n\t\t\toffset += (ha->hw.flt_chap_size / 2);\n\t\toffset += (idx * chap_size);\n\t}\n\n\trval = qla4xxx_get_flash(ha, chap_dma, offset, chap_size);\n\tif (rval != QLA_SUCCESS) {\n\t\tret = -EINVAL;\n\t\tgoto exit_get_chap;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Chap Cookie: x%x\\n\",\n\t\t__le16_to_cpu(chap_table->cookie)));\n\n\tif (__le16_to_cpu(chap_table->cookie) != CHAP_VALID_COOKIE) {\n\t\tql4_printk(KERN_ERR, ha, \"No valid chap entry found\\n\");\n\t\tgoto exit_get_chap;\n\t}\n\n\tstrscpy(password, chap_table->secret, QL4_CHAP_MAX_SECRET_LEN);\n\tstrscpy(username, chap_table->name, QL4_CHAP_MAX_NAME_LEN);\n\tchap_table->cookie = cpu_to_le16(CHAP_VALID_COOKIE);\n\nexit_get_chap:\n\tdma_pool_free(ha->chap_dma_pool, chap_table, chap_dma);\n\treturn ret;\n}\n\n \nint qla4xxx_set_chap(struct scsi_qla_host *ha, char *username, char *password,\n\t\t     uint16_t idx, int bidi)\n{\n\tint ret = 0;\n\tint rval = QLA_ERROR;\n\tuint32_t offset = 0;\n\tstruct ql4_chap_table *chap_table;\n\tuint32_t chap_size = 0;\n\tdma_addr_t chap_dma;\n\n\tchap_table = dma_pool_zalloc(ha->chap_dma_pool, GFP_KERNEL, &chap_dma);\n\tif (chap_table == NULL) {\n\t\tret =  -ENOMEM;\n\t\tgoto exit_set_chap;\n\t}\n\n\tif (bidi)\n\t\tchap_table->flags |= BIT_6;  \n\telse\n\t\tchap_table->flags |= BIT_7;  \n\tchap_table->secret_len = strlen(password);\n\tstrncpy(chap_table->secret, password, MAX_CHAP_SECRET_LEN - 1);\n\tstrncpy(chap_table->name, username, MAX_CHAP_NAME_LEN - 1);\n\tchap_table->cookie = cpu_to_le16(CHAP_VALID_COOKIE);\n\n\tif (is_qla40XX(ha)) {\n\t\tchap_size = MAX_CHAP_ENTRIES_40XX * sizeof(*chap_table);\n\t\toffset = FLASH_CHAP_OFFSET;\n\t} else {  \n\t\tchap_size = ha->hw.flt_chap_size / 2;\n\t\toffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\n\t\tif (ha->port_num == 1)\n\t\t\toffset += chap_size;\n\t}\n\n\toffset += (idx * sizeof(struct ql4_chap_table));\n\trval = qla4xxx_set_flash(ha, chap_dma, offset,\n\t\t\t\tsizeof(struct ql4_chap_table),\n\t\t\t\tFLASH_OPT_RMW_COMMIT);\n\n\tif (rval == QLA_SUCCESS && ha->chap_list) {\n\t\t \n\t\tmemcpy((struct ql4_chap_table *)ha->chap_list + idx,\n\t\t       chap_table, sizeof(struct ql4_chap_table));\n\t}\n\tdma_pool_free(ha->chap_dma_pool, chap_table, chap_dma);\n\tif (rval != QLA_SUCCESS)\n\t\tret =  -EINVAL;\n\nexit_set_chap:\n\treturn ret;\n}\n\n\nint qla4xxx_get_uni_chap_at_index(struct scsi_qla_host *ha, char *username,\n\t\t\t\t  char *password, uint16_t chap_index)\n{\n\tint rval = QLA_ERROR;\n\tstruct ql4_chap_table *chap_table = NULL;\n\tint max_chap_entries;\n\n\tif (!ha->chap_list) {\n\t\tql4_printk(KERN_ERR, ha, \"Do not have CHAP table cache\\n\");\n\t\trval = QLA_ERROR;\n\t\tgoto exit_uni_chap;\n\t}\n\n\tif (!username || !password) {\n\t\tql4_printk(KERN_ERR, ha, \"No memory for username & secret\\n\");\n\t\trval = QLA_ERROR;\n\t\tgoto exit_uni_chap;\n\t}\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t   sizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (chap_index > max_chap_entries) {\n\t\tql4_printk(KERN_ERR, ha, \"Invalid Chap index\\n\");\n\t\trval = QLA_ERROR;\n\t\tgoto exit_uni_chap;\n\t}\n\n\tmutex_lock(&ha->chap_sem);\n\tchap_table = (struct ql4_chap_table *)ha->chap_list + chap_index;\n\tif (chap_table->cookie != cpu_to_le16(CHAP_VALID_COOKIE)) {\n\t\trval = QLA_ERROR;\n\t\tgoto exit_unlock_uni_chap;\n\t}\n\n\tif (!(chap_table->flags & BIT_7)) {\n\t\tql4_printk(KERN_ERR, ha, \"Unidirectional entry not set\\n\");\n\t\trval = QLA_ERROR;\n\t\tgoto exit_unlock_uni_chap;\n\t}\n\n\tstrscpy(password, chap_table->secret, MAX_CHAP_SECRET_LEN);\n\tstrscpy(username, chap_table->name, MAX_CHAP_NAME_LEN);\n\n\trval = QLA_SUCCESS;\n\nexit_unlock_uni_chap:\n\tmutex_unlock(&ha->chap_sem);\nexit_uni_chap:\n\treturn rval;\n}\n\n \nint qla4xxx_get_chap_index(struct scsi_qla_host *ha, char *username,\n\t\t\t   char *password, int bidi, uint16_t *chap_index)\n{\n\tint i, rval;\n\tint free_index = -1;\n\tint found_index = 0;\n\tint max_chap_entries = 0;\n\tstruct ql4_chap_table *chap_table;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t\t\tsizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (!ha->chap_list) {\n\t\tql4_printk(KERN_ERR, ha, \"Do not have CHAP table cache\\n\");\n\t\treturn QLA_ERROR;\n\t}\n\n\tif (!username || !password) {\n\t\tql4_printk(KERN_ERR, ha, \"Do not have username and psw\\n\");\n\t\treturn QLA_ERROR;\n\t}\n\n\tmutex_lock(&ha->chap_sem);\n\tfor (i = 0; i < max_chap_entries; i++) {\n\t\tchap_table = (struct ql4_chap_table *)ha->chap_list + i;\n\t\tif (chap_table->cookie !=\n\t\t    cpu_to_le16(CHAP_VALID_COOKIE)) {\n\t\t\tif (i > MAX_RESRV_CHAP_IDX && free_index == -1)\n\t\t\t\tfree_index = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bidi) {\n\t\t\tif (chap_table->flags & BIT_7)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (chap_table->flags & BIT_6)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(chap_table->secret, password,\n\t\t\t     MAX_CHAP_SECRET_LEN) &&\n\t\t    !strncmp(chap_table->name, username,\n\t\t\t     MAX_CHAP_NAME_LEN)) {\n\t\t\t*chap_index = i;\n\t\t\tfound_index = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!found_index && free_index != -1) {\n\t\trval = qla4xxx_set_chap(ha, username, password,\n\t\t\t\t\tfree_index, bidi);\n\t\tif (!rval) {\n\t\t\t*chap_index = free_index;\n\t\t\tfound_index = 1;\n\t\t}\n\t}\n\n\tmutex_unlock(&ha->chap_sem);\n\n\tif (found_index)\n\t\treturn QLA_SUCCESS;\n\treturn QLA_ERROR;\n}\n\nint qla4xxx_conn_close_sess_logout(struct scsi_qla_host *ha,\n\t\t\t\t   uint16_t fw_ddb_index,\n\t\t\t\t   uint16_t connection_id,\n\t\t\t\t   uint16_t option)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_SUCCESS;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;\n\tmbox_cmd[1] = fw_ddb_index;\n\tmbox_cmd[2] = connection_id;\n\tmbox_cmd[3] = option;\n\n\tstatus = qla4xxx_mailbox_command(ha, 4, 2, &mbox_cmd[0], &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha, \"%s: MBOX_CMD_CONN_CLOSE \"\n\t\t\t\t  \"option %04x failed w/ status %04X %04X\\n\",\n\t\t\t\t  __func__, option, mbox_sts[0], mbox_sts[1]));\n\t}\n\treturn status;\n}\n\n \nstatic int qla4_84xx_extend_idc_tmo(struct scsi_qla_host *ha, uint32_t ext_tmo)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\text_tmo &= 0xf;\n\n\tmbox_cmd[0] = MBOX_CMD_IDC_TIME_EXTEND;\n\tmbox_cmd[1] = ((ha->idc_info.request_desc & 0xfffff0ff) |\n\t\t       (ext_tmo << 8));\t\t \n\tmbox_cmd[2] = ha->idc_info.info1;\n\tmbox_cmd[3] = ha->idc_info.info2;\n\tmbox_cmd[4] = ha->idc_info.info3;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\n\t\t\t\t\t mbox_cmd, mbox_sts);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"scsi%ld: %s: failed status %04X\\n\",\n\t\t\t\t  ha->host_no, __func__, mbox_sts[0]));\n\t\treturn QLA_ERROR;\n\t} else {\n\t\tql4_printk(KERN_INFO, ha, \"%s: IDC timeout extended by %d secs\\n\",\n\t\t\t   __func__, ext_tmo);\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\nint qla4xxx_disable_acb(struct scsi_qla_host *ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_SUCCESS;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_DISABLE_ACB;\n\n\tstatus = qla4xxx_mailbox_command(ha, 8, 5, &mbox_cmd[0], &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha, \"%s: MBOX_CMD_DISABLE_ACB \"\n\t\t\t\t  \"failed w/ status %04X %04X %04X\", __func__,\n\t\t\t\t  mbox_sts[0], mbox_sts[1], mbox_sts[2]));\n\t} else {\n\t\tif (is_qla8042(ha) &&\n\t\t    test_bit(DPC_POST_IDC_ACK, &ha->dpc_flags) &&\n\t\t    (mbox_sts[0] != MBOX_STS_COMMAND_COMPLETE)) {\n\t\t\t \n\t\t\tqla4_84xx_extend_idc_tmo(ha, IDC_EXTEND_TOV);\n\t\t\tif (!wait_for_completion_timeout(&ha->disable_acb_comp,\n\t\t\t\t\t\t\t IDC_EXTEND_TOV * HZ)) {\n\t\t\t\tql4_printk(KERN_WARNING, ha, \"%s: Disable ACB Completion not received\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t}\n\t\t}\n\t}\n\treturn status;\n}\n\nint qla4xxx_get_acb(struct scsi_qla_host *ha, dma_addr_t acb_dma,\n\t\t    uint32_t acb_type, uint32_t len)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_SUCCESS;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_ACB;\n\tmbox_cmd[1] = acb_type;\n\tmbox_cmd[2] = LSDW(acb_dma);\n\tmbox_cmd[3] = MSDW(acb_dma);\n\tmbox_cmd[4] = len;\n\n\tstatus = qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha, \"%s: MBOX_CMD_GET_ACB \"\n\t\t\t\t  \"failed w/ status %04X\\n\", __func__,\n\t\t\t\t  mbox_sts[0]));\n\t}\n\treturn status;\n}\n\nint qla4xxx_set_acb(struct scsi_qla_host *ha, uint32_t *mbox_cmd,\n\t\t    uint32_t *mbox_sts, dma_addr_t acb_dma)\n{\n\tint status = QLA_SUCCESS;\n\n\tmemset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);\n\tmemset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);\n\tmbox_cmd[0] = MBOX_CMD_SET_ACB;\n\tmbox_cmd[1] = 0;  \n\tmbox_cmd[2] = LSDW(acb_dma);\n\tmbox_cmd[3] = MSDW(acb_dma);\n\tmbox_cmd[4] = sizeof(struct addr_ctrl_blk);\n\n\tstatus = qla4xxx_mailbox_command(ha, 5, 5, &mbox_cmd[0], &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,  \"%s: MBOX_CMD_SET_ACB \"\n\t\t\t\t  \"failed w/ status %04X\\n\", __func__,\n\t\t\t\t  mbox_sts[0]));\n\t}\n\treturn status;\n}\n\nint qla4xxx_set_param_ddbentry(struct scsi_qla_host *ha,\n\t\t\t       struct ddb_entry *ddb_entry,\n\t\t\t       struct iscsi_cls_conn *cls_conn,\n\t\t\t       uint32_t *mbx_sts)\n{\n\tstruct dev_db_entry *fw_ddb_entry;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_session *sess;\n\tstruct qla_conn *qla_conn;\n\tstruct sockaddr *dst_addr;\n\tdma_addr_t fw_ddb_entry_dma;\n\tint status = QLA_SUCCESS;\n\tint rval = 0;\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tchar *ip;\n\tuint16_t iscsi_opts = 0;\n\tuint32_t options = 0;\n\tuint16_t idx, *ptid;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer.\\n\",\n\t\t\t\t  __func__));\n\t\trval = -ENOMEM;\n\t\tgoto exit_set_param_no_free;\n\t}\n\n\tconn = cls_conn->dd_data;\n\tqla_conn = conn->dd_data;\n\tsess = conn->session;\n\tdst_addr = (struct sockaddr *)&qla_conn->qla_ep->dst_addr;\n\n\tif (dst_addr->sa_family == AF_INET6)\n\t\toptions |= IPV6_DEFAULT_DDB_ENTRY;\n\n\tstatus = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\n\tif (status == QLA_ERROR) {\n\t\trval = -EINVAL;\n\t\tgoto exit_set_param;\n\t}\n\n\tptid = (uint16_t *)&fw_ddb_entry->isid[1];\n\t*ptid = cpu_to_le16((uint16_t)ddb_entry->sess->target_id);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"ISID [%pmR]\\n\", fw_ddb_entry->isid));\n\n\tiscsi_opts = le16_to_cpu(fw_ddb_entry->iscsi_options);\n\tmemset(fw_ddb_entry->iscsi_alias, 0, sizeof(fw_ddb_entry->iscsi_alias));\n\n\tmemset(fw_ddb_entry->iscsi_name, 0, sizeof(fw_ddb_entry->iscsi_name));\n\n\tif (sess->targetname != NULL) {\n\t\tmemcpy(fw_ddb_entry->iscsi_name, sess->targetname,\n\t\t       min(strlen(sess->targetname),\n\t\t       sizeof(fw_ddb_entry->iscsi_name)));\n\t}\n\n\tmemset(fw_ddb_entry->ip_addr, 0, sizeof(fw_ddb_entry->ip_addr));\n\tmemset(fw_ddb_entry->tgt_addr, 0, sizeof(fw_ddb_entry->tgt_addr));\n\n\tfw_ddb_entry->options =  DDB_OPT_TARGET | DDB_OPT_AUTO_SENDTGTS_DISABLE;\n\n\tif (dst_addr->sa_family == AF_INET) {\n\t\taddr = (struct sockaddr_in *)dst_addr;\n\t\tip = (char *)&addr->sin_addr;\n\t\tmemcpy(fw_ddb_entry->ip_addr, ip, IP_ADDR_LEN);\n\t\tfw_ddb_entry->port = cpu_to_le16(ntohs(addr->sin_port));\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: Destination Address [%pI4]: index [%d]\\n\",\n\t\t\t\t   __func__, fw_ddb_entry->ip_addr,\n\t\t\t\t  ddb_entry->fw_ddb_index));\n\t} else if (dst_addr->sa_family == AF_INET6) {\n\t\taddr6 = (struct sockaddr_in6 *)dst_addr;\n\t\tip = (char *)&addr6->sin6_addr;\n\t\tmemcpy(fw_ddb_entry->ip_addr, ip, IPv6_ADDR_LEN);\n\t\tfw_ddb_entry->port = cpu_to_le16(ntohs(addr6->sin6_port));\n\t\tfw_ddb_entry->options |= DDB_OPT_IPV6_DEVICE;\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: Destination Address [%pI6]: index [%d]\\n\",\n\t\t\t\t   __func__, fw_ddb_entry->ip_addr,\n\t\t\t\t  ddb_entry->fw_ddb_index));\n\t} else {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Failed to get IP Address\\n\",\n\t\t\t   __func__);\n\t\trval = -EINVAL;\n\t\tgoto exit_set_param;\n\t}\n\n\t \n\tif (sess->username != NULL && sess->password != NULL) {\n\t\tif (strlen(sess->username) && strlen(sess->password)) {\n\t\t\tiscsi_opts |= BIT_7;\n\n\t\t\trval = qla4xxx_get_chap_index(ha, sess->username,\n\t\t\t\t\t\tsess->password,\n\t\t\t\t\t\tLOCAL_CHAP, &idx);\n\t\t\tif (rval)\n\t\t\t\tgoto exit_set_param;\n\n\t\t\tfw_ddb_entry->chap_tbl_idx = cpu_to_le16(idx);\n\t\t}\n\t}\n\n\tif (sess->username_in != NULL && sess->password_in != NULL) {\n\t\t \n\t\tif (strlen(sess->username_in) && strlen(sess->password_in)) {\n\t\t\tiscsi_opts |= BIT_4;\n\n\t\t\trval = qla4xxx_get_chap_index(ha, sess->username_in,\n\t\t\t\t\t\t      sess->password_in,\n\t\t\t\t\t\t      BIDI_CHAP, &idx);\n\t\t\tif (rval)\n\t\t\t\tgoto exit_set_param;\n\t\t}\n\t}\n\n\tif (sess->initial_r2t_en)\n\t\tiscsi_opts |= BIT_10;\n\n\tif (sess->imm_data_en)\n\t\tiscsi_opts |= BIT_11;\n\n\tfw_ddb_entry->iscsi_options = cpu_to_le16(iscsi_opts);\n\n\tif (conn->max_recv_dlength)\n\t\tfw_ddb_entry->iscsi_max_rcv_data_seg_len =\n\t\t  cpu_to_le16((conn->max_recv_dlength / BYTE_UNITS));\n\n\tif (sess->max_r2t)\n\t\tfw_ddb_entry->iscsi_max_outsnd_r2t = cpu_to_le16(sess->max_r2t);\n\n\tif (sess->first_burst)\n\t\tfw_ddb_entry->iscsi_first_burst_len =\n\t\t       cpu_to_le16((sess->first_burst / BYTE_UNITS));\n\n\tif (sess->max_burst)\n\t\tfw_ddb_entry->iscsi_max_burst_len =\n\t\t\tcpu_to_le16((sess->max_burst / BYTE_UNITS));\n\n\tif (sess->time2wait)\n\t\tfw_ddb_entry->iscsi_def_time2wait =\n\t\t\tcpu_to_le16(sess->time2wait);\n\n\tif (sess->time2retain)\n\t\tfw_ddb_entry->iscsi_def_time2retain =\n\t\t\tcpu_to_le16(sess->time2retain);\n\n\tstatus = qla4xxx_set_ddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t       fw_ddb_entry_dma, mbx_sts);\n\n\tif (status != QLA_SUCCESS)\n\t\trval = -EINVAL;\nexit_set_param:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\nexit_set_param_no_free:\n\treturn rval;\n}\n\nint qla4xxx_get_mgmt_data(struct scsi_qla_host *ha, uint16_t fw_ddb_index,\n\t\t\t  uint16_t stats_size, dma_addr_t stats_dma)\n{\n\tint status = QLA_SUCCESS;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(mbox_cmd, 0, sizeof(mbox_cmd[0]) * MBOX_REG_COUNT);\n\tmemset(mbox_sts, 0, sizeof(mbox_sts[0]) * MBOX_REG_COUNT);\n\tmbox_cmd[0] = MBOX_CMD_GET_MANAGEMENT_DATA;\n\tmbox_cmd[1] = fw_ddb_index;\n\tmbox_cmd[2] = LSDW(stats_dma);\n\tmbox_cmd[3] = MSDW(stats_dma);\n\tmbox_cmd[4] = stats_size;\n\n\tstatus = qla4xxx_mailbox_command(ha, 5, 1, &mbox_cmd[0], &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"%s: MBOX_CMD_GET_MANAGEMENT_DATA \"\n\t\t\t\t  \"failed w/ status %04X\\n\", __func__,\n\t\t\t\t  mbox_sts[0]));\n\t}\n\treturn status;\n}\n\nint qla4xxx_get_ip_state(struct scsi_qla_host *ha, uint32_t acb_idx,\n\t\t\t uint32_t ip_idx, uint32_t *sts)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_SUCCESS;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\tmbox_cmd[0] = MBOX_CMD_GET_IP_ADDR_STATE;\n\tmbox_cmd[1] = acb_idx;\n\tmbox_cmd[2] = ip_idx;\n\n\tstatus = qla4xxx_mailbox_command(ha, 3, 8, &mbox_cmd[0], &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,  \"%s: \"\n\t\t\t\t  \"MBOX_CMD_GET_IP_ADDR_STATE failed w/ \"\n\t\t\t\t  \"status %04X\\n\", __func__, mbox_sts[0]));\n\t}\n\tmemcpy(sts, mbox_sts, sizeof(mbox_sts));\n\treturn status;\n}\n\nint qla4xxx_get_nvram(struct scsi_qla_host *ha, dma_addr_t nvram_dma,\n\t\t      uint32_t offset, uint32_t size)\n{\n\tint status = QLA_SUCCESS;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_NVRAM;\n\tmbox_cmd[1] = LSDW(nvram_dma);\n\tmbox_cmd[2] = MSDW(nvram_dma);\n\tmbox_cmd[3] = offset;\n\tmbox_cmd[4] = size;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: failed \"\n\t\t\t\t  \"status %04X\\n\", ha->host_no, __func__,\n\t\t\t\t  mbox_sts[0]));\n\t}\n\treturn status;\n}\n\nint qla4xxx_set_nvram(struct scsi_qla_host *ha, dma_addr_t nvram_dma,\n\t\t      uint32_t offset, uint32_t size)\n{\n\tint status = QLA_SUCCESS;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_SET_NVRAM;\n\tmbox_cmd[1] = LSDW(nvram_dma);\n\tmbox_cmd[2] = MSDW(nvram_dma);\n\tmbox_cmd[3] = offset;\n\tmbox_cmd[4] = size;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: failed \"\n\t\t\t\t  \"status %04X\\n\", ha->host_no, __func__,\n\t\t\t\t  mbox_sts[0]));\n\t}\n\treturn status;\n}\n\nint qla4xxx_restore_factory_defaults(struct scsi_qla_host *ha,\n\t\t\t\t     uint32_t region, uint32_t field0,\n\t\t\t\t     uint32_t field1)\n{\n\tint status = QLA_SUCCESS;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_RESTORE_FACTORY_DEFAULTS;\n\tmbox_cmd[3] = region;\n\tmbox_cmd[4] = field0;\n\tmbox_cmd[5] = field1;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 3, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\tif (status != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: failed \"\n\t\t\t\t  \"status %04X\\n\", ha->host_no, __func__,\n\t\t\t\t  mbox_sts[0]));\n\t}\n\treturn status;\n}\n\n \nint qla4_8xxx_set_param(struct scsi_qla_host *ha, int param)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tuint32_t status;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_SET_PARAM;\n\tif (param == SET_DRVR_VERSION) {\n\t\tmbox_cmd[1] = SET_DRVR_VERSION;\n\t\tstrncpy((char *)&mbox_cmd[2], QLA4XXX_DRIVER_VERSION,\n\t\t\tMAX_DRVR_VER_LEN - 1);\n\t} else {\n\t\tql4_printk(KERN_ERR, ha, \"%s: invalid parameter 0x%x\\n\",\n\t\t\t   __func__, param);\n\t\tstatus = QLA_ERROR;\n\t\tgoto exit_set_param;\n\t}\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 2, mbox_cmd,\n\t\t\t\t\t mbox_sts);\n\tif (status == QLA_ERROR)\n\t\tql4_printk(KERN_ERR, ha, \"%s: failed status %04X\\n\",\n\t\t\t   __func__, mbox_sts[0]);\n\nexit_set_param:\n\treturn status;\n}\n\n \nint qla4_83xx_post_idc_ack(struct scsi_qla_host *ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_IDC_ACK;\n\tmbox_cmd[1] = ha->idc_info.request_desc;\n\tmbox_cmd[2] = ha->idc_info.info1;\n\tmbox_cmd[3] = ha->idc_info.info2;\n\tmbox_cmd[4] = ha->idc_info.info3;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\n\t\t\t\t\t mbox_cmd, mbox_sts);\n\tif (status == QLA_ERROR)\n\t\tql4_printk(KERN_ERR, ha, \"%s: failed status %04X\\n\", __func__,\n\t\t\t   mbox_sts[0]);\n\telse\n\t       ql4_printk(KERN_INFO, ha, \"%s: IDC ACK posted\\n\", __func__);\n\n\treturn status;\n}\n\nint qla4_84xx_config_acb(struct scsi_qla_host *ha, int acb_config)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tstruct addr_ctrl_blk *acb = NULL;\n\tuint32_t acb_len = sizeof(struct addr_ctrl_blk);\n\tint rval = QLA_SUCCESS;\n\tdma_addr_t acb_dma;\n\n\tacb = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t sizeof(struct addr_ctrl_blk),\n\t\t\t\t &acb_dma, GFP_KERNEL);\n\tif (!acb) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Unable to alloc acb\\n\", __func__);\n\t\trval = QLA_ERROR;\n\t\tgoto exit_config_acb;\n\t}\n\tmemset(acb, 0, acb_len);\n\n\tswitch (acb_config) {\n\tcase ACB_CONFIG_DISABLE:\n\t\trval = qla4xxx_get_acb(ha, acb_dma, 0, acb_len);\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tgoto exit_free_acb;\n\n\t\trval = qla4xxx_disable_acb(ha);\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tgoto exit_free_acb;\n\n\t\tif (!ha->saved_acb)\n\t\t\tha->saved_acb = kzalloc(acb_len, GFP_KERNEL);\n\n\t\tif (!ha->saved_acb) {\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Unable to alloc acb\\n\",\n\t\t\t\t   __func__);\n\t\t\trval = QLA_ERROR;\n\t\t\tgoto exit_free_acb;\n\t\t}\n\t\tmemcpy(ha->saved_acb, acb, acb_len);\n\t\tbreak;\n\tcase ACB_CONFIG_SET:\n\n\t\tif (!ha->saved_acb) {\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Can't set ACB, Saved ACB not available\\n\",\n\t\t\t\t   __func__);\n\t\t\trval = QLA_ERROR;\n\t\t\tgoto exit_free_acb;\n\t\t}\n\n\t\tmemcpy(acb, ha->saved_acb, acb_len);\n\n\t\trval = qla4xxx_set_acb(ha, &mbox_cmd[0], &mbox_sts[0], acb_dma);\n\t\tif (rval != QLA_SUCCESS)\n\t\t\tgoto exit_free_acb;\n\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"%s: Invalid ACB Configuration\\n\",\n\t\t\t   __func__);\n\t}\n\nexit_free_acb:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk), acb,\n\t\t\t  acb_dma);\nexit_config_acb:\n\tif ((acb_config == ACB_CONFIG_SET) && ha->saved_acb) {\n\t\tkfree(ha->saved_acb);\n\t\tha->saved_acb = NULL;\n\t}\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s %s\\n\", __func__,\n\t\t\t  rval == QLA_SUCCESS ? \"SUCCEEDED\" : \"FAILED\"));\n\treturn rval;\n}\n\nint qla4_83xx_get_port_config(struct scsi_qla_host *ha, uint32_t *config)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_PORT_CONFIG;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\n\t\t\t\t\t mbox_cmd, mbox_sts);\n\tif (status == QLA_SUCCESS)\n\t\t*config = mbox_sts[1];\n\telse\n\t\tql4_printk(KERN_ERR, ha, \"%s: failed status %04X\\n\", __func__,\n\t\t\t   mbox_sts[0]);\n\n\treturn status;\n}\n\nint qla4_83xx_set_port_config(struct scsi_qla_host *ha, uint32_t *config)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status;\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_SET_PORT_CONFIG;\n\tmbox_cmd[1] = *config;\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, MBOX_REG_COUNT,\n\t\t\t\tmbox_cmd, mbox_sts);\n\tif (status != QLA_SUCCESS)\n\t\tql4_printk(KERN_ERR, ha, \"%s: failed status %04X\\n\", __func__,\n\t\t\t   mbox_sts[0]);\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}