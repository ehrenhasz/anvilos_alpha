{
  "module_name": "ql4_attr.c",
  "hash_id": "60e86795a2318aebbbeae1e77f7410a108cc0cb14330a931f044d895ec7f2a4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_attr.c",
  "human_readable_source": "\n \n\n#include \"ql4_def.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n\nstatic ssize_t\nqla4_8xxx_sysfs_read_fw_dump(struct file *filep, struct kobject *kobj,\n\t\t\t     struct bin_attribute *ba, char *buf, loff_t off,\n\t\t\t     size_t count)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,\n\t\t\t\t\t       struct device, kobj)));\n\n\tif (is_qla40XX(ha))\n\t\treturn -EINVAL;\n\n\tif (!test_bit(AF_82XX_DUMP_READING, &ha->flags))\n\t\treturn 0;\n\n\treturn memory_read_from_buffer(buf, count, &off, ha->fw_dump,\n\t\t\t\t       ha->fw_dump_size);\n}\n\nstatic ssize_t\nqla4_8xxx_sysfs_write_fw_dump(struct file *filep, struct kobject *kobj,\n\t\t\t      struct bin_attribute *ba, char *buf, loff_t off,\n\t\t\t      size_t count)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,\n\t\t\t\t\t       struct device, kobj)));\n\tuint32_t dev_state;\n\tlong reading;\n\tint ret = 0;\n\n\tif (is_qla40XX(ha))\n\t\treturn -EINVAL;\n\n\tif (off != 0)\n\t\treturn ret;\n\n\tbuf[1] = 0;\n\tret = kstrtol(buf, 10, &reading);\n\tif (ret) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Invalid input. Return err %d\\n\",\n\t\t\t   __func__, ret);\n\t\treturn ret;\n\t}\n\n\tswitch (reading) {\n\tcase 0:\n\t\t \n\t\tif (test_and_clear_bit(AF_82XX_DUMP_READING, &ha->flags)) {\n\t\t\tclear_bit(AF_82XX_FW_DUMPED, &ha->flags);\n\t\t\t \n\t\t\tqla4xxx_alloc_fw_dump(ha);\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"Firmware template reloaded\\n\"));\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tif (test_bit(AF_82XX_FW_DUMPED, &ha->flags) &&\n\t\t    !test_bit(AF_82XX_DUMP_READING, &ha->flags)) {\n\t\t\tset_bit(AF_82XX_DUMP_READING, &ha->flags);\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"Raw firmware dump ready for read on (%ld).\\n\",\n\t\t\t\t\t  ha->host_no));\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tha->isp_ops->idc_lock(ha);\n\t\tdev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\n\t\tif (dev_state == QLA8XXX_DEV_READY) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: Setting Need reset\\n\",\n\t\t\t\t   __func__);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_NEED_RESET);\n\t\t\tif (is_qla8022(ha) ||\n\t\t\t    ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t\t\t     qla4_83xx_can_perform_reset(ha))) {\n\t\t\t\tset_bit(AF_8XXX_RST_OWNER, &ha->flags);\n\t\t\t\tset_bit(AF_FW_RECOVERY, &ha->flags);\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: Reset owner is 0x%x\\n\",\n\t\t\t\t\t   __func__, ha->func_num);\n\t\t\t}\n\t\t} else\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"%s: Reset not performed as device state is 0x%x\\n\",\n\t\t\t\t   __func__, dev_state);\n\n\t\tha->isp_ops->idc_unlock(ha);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic struct bin_attribute sysfs_fw_dump_attr = {\n\t.attr = {\n\t\t.name = \"fw_dump\",\n\t\t.mode = S_IRUSR | S_IWUSR,\n\t},\n\t.size = 0,\n\t.read = qla4_8xxx_sysfs_read_fw_dump,\n\t.write = qla4_8xxx_sysfs_write_fw_dump,\n};\n\nstatic struct sysfs_entry {\n\tchar *name;\n\tstruct bin_attribute *attr;\n} bin_file_entries[] = {\n\t{ \"fw_dump\", &sysfs_fw_dump_attr },\n\t{ NULL },\n};\n\nvoid qla4_8xxx_alloc_sysfs_attr(struct scsi_qla_host *ha)\n{\n\tstruct Scsi_Host *host = ha->host;\n\tstruct sysfs_entry *iter;\n\tint ret;\n\n\tfor (iter = bin_file_entries; iter->name; iter++) {\n\t\tret = sysfs_create_bin_file(&host->shost_gendev.kobj,\n\t\t\t\t\t    iter->attr);\n\t\tif (ret)\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"Unable to create sysfs %s binary attribute (%d).\\n\",\n\t\t\t\t   iter->name, ret);\n\t}\n}\n\nvoid qla4_8xxx_free_sysfs_attr(struct scsi_qla_host *ha)\n{\n\tstruct Scsi_Host *host = ha->host;\n\tstruct sysfs_entry *iter;\n\n\tfor (iter = bin_file_entries; iter->name; iter++)\n\t\tsysfs_remove_bin_file(&host->shost_gendev.kobj,\n\t\t\t\t      iter->attr);\n}\n\n \nstatic ssize_t\nqla4xxx_fw_version_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\n\tif (is_qla80XX(ha))\n\t\treturn snprintf(buf, PAGE_SIZE, \"%d.%02d.%02d (%x)\\n\",\n\t\t\t\tha->fw_info.fw_major, ha->fw_info.fw_minor,\n\t\t\t\tha->fw_info.fw_patch, ha->fw_info.fw_build);\n\telse\n\t\treturn snprintf(buf, PAGE_SIZE, \"%d.%02d.%02d.%02d\\n\",\n\t\t\t\tha->fw_info.fw_major, ha->fw_info.fw_minor,\n\t\t\t\tha->fw_info.fw_patch, ha->fw_info.fw_build);\n}\n\nstatic ssize_t\nqla4xxx_serial_num_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ha->serial_number);\n}\n\nstatic ssize_t\nqla4xxx_iscsi_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\treturn snprintf(buf, PAGE_SIZE, \"%d.%02d\\n\", ha->fw_info.iscsi_major,\n\t\t\tha->fw_info.iscsi_minor);\n}\n\nstatic ssize_t\nqla4xxx_optrom_version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\treturn snprintf(buf, PAGE_SIZE, \"%d.%02d.%02d.%02d\\n\",\n\t\t\tha->fw_info.bootload_major, ha->fw_info.bootload_minor,\n\t\t\tha->fw_info.bootload_patch, ha->fw_info.bootload_build);\n}\n\nstatic ssize_t\nqla4xxx_board_id_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08X\\n\", ha->board_id);\n}\n\nstatic ssize_t\nqla4xxx_fw_state_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\n\tqla4xxx_get_firmware_state(ha);\n\treturn snprintf(buf, PAGE_SIZE, \"0x%08X%8X\\n\", ha->firmware_state,\n\t\t\tha->addl_fw_state);\n}\n\nstatic ssize_t\nqla4xxx_phy_port_cnt_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\n\tif (is_qla40XX(ha))\n\t\treturn -ENOSYS;\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%04X\\n\", ha->phy_port_cnt);\n}\n\nstatic ssize_t\nqla4xxx_phy_port_num_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\n\tif (is_qla40XX(ha))\n\t\treturn -ENOSYS;\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%04X\\n\", ha->phy_port_num);\n}\n\nstatic ssize_t\nqla4xxx_iscsi_func_cnt_show(struct device *dev, struct device_attribute *attr,\n\t\t      char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\n\tif (is_qla40XX(ha))\n\t\treturn -ENOSYS;\n\n\treturn snprintf(buf, PAGE_SIZE, \"0x%04X\\n\", ha->iscsi_pci_func_cnt);\n}\n\nstatic ssize_t\nqla4xxx_hba_model_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ha->model_name);\n}\n\nstatic ssize_t\nqla4xxx_fw_timestamp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\treturn snprintf(buf, PAGE_SIZE, \"%s %s\\n\", ha->fw_info.fw_build_date,\n\t\t\tha->fw_info.fw_build_time);\n}\n\nstatic ssize_t\nqla4xxx_fw_build_user_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ha->fw_info.fw_build_user);\n}\n\nstatic ssize_t\nqla4xxx_fw_ext_timestamp_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", ha->fw_info.extended_timestamp);\n}\n\nstatic ssize_t\nqla4xxx_fw_load_src_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\tchar *load_src = NULL;\n\n\tswitch (ha->fw_info.fw_load_source) {\n\tcase 1:\n\t\tload_src = \"Flash Primary\";\n\t\tbreak;\n\tcase 2:\n\t\tload_src = \"Flash Secondary\";\n\t\tbreak;\n\tcase 3:\n\t\tload_src = \"Host Download\";\n\t\tbreak;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", load_src);\n}\n\nstatic ssize_t\nqla4xxx_fw_uptime_show(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\n\tqla4xxx_about_firmware(ha);\n\treturn snprintf(buf, PAGE_SIZE, \"%u.%u secs\\n\", ha->fw_uptime_secs,\n\t\t\tha->fw_uptime_msecs);\n}\n\nstatic DEVICE_ATTR(fw_version, S_IRUGO, qla4xxx_fw_version_show, NULL);\nstatic DEVICE_ATTR(serial_num, S_IRUGO, qla4xxx_serial_num_show, NULL);\nstatic DEVICE_ATTR(iscsi_version, S_IRUGO, qla4xxx_iscsi_version_show, NULL);\nstatic DEVICE_ATTR(optrom_version, S_IRUGO, qla4xxx_optrom_version_show, NULL);\nstatic DEVICE_ATTR(board_id, S_IRUGO, qla4xxx_board_id_show, NULL);\nstatic DEVICE_ATTR(fw_state, S_IRUGO, qla4xxx_fw_state_show, NULL);\nstatic DEVICE_ATTR(phy_port_cnt, S_IRUGO, qla4xxx_phy_port_cnt_show, NULL);\nstatic DEVICE_ATTR(phy_port_num, S_IRUGO, qla4xxx_phy_port_num_show, NULL);\nstatic DEVICE_ATTR(iscsi_func_cnt, S_IRUGO, qla4xxx_iscsi_func_cnt_show, NULL);\nstatic DEVICE_ATTR(hba_model, S_IRUGO, qla4xxx_hba_model_show, NULL);\nstatic DEVICE_ATTR(fw_timestamp, S_IRUGO, qla4xxx_fw_timestamp_show, NULL);\nstatic DEVICE_ATTR(fw_build_user, S_IRUGO, qla4xxx_fw_build_user_show, NULL);\nstatic DEVICE_ATTR(fw_ext_timestamp, S_IRUGO, qla4xxx_fw_ext_timestamp_show,\n\t\t   NULL);\nstatic DEVICE_ATTR(fw_load_src, S_IRUGO, qla4xxx_fw_load_src_show, NULL);\nstatic DEVICE_ATTR(fw_uptime, S_IRUGO, qla4xxx_fw_uptime_show, NULL);\n\nstatic struct attribute *qla4xxx_host_attrs[] = {\n\t&dev_attr_fw_version.attr,\n\t&dev_attr_serial_num.attr,\n\t&dev_attr_iscsi_version.attr,\n\t&dev_attr_optrom_version.attr,\n\t&dev_attr_board_id.attr,\n\t&dev_attr_fw_state.attr,\n\t&dev_attr_phy_port_cnt.attr,\n\t&dev_attr_phy_port_num.attr,\n\t&dev_attr_iscsi_func_cnt.attr,\n\t&dev_attr_hba_model.attr,\n\t&dev_attr_fw_timestamp.attr,\n\t&dev_attr_fw_build_user.attr,\n\t&dev_attr_fw_ext_timestamp.attr,\n\t&dev_attr_fw_load_src.attr,\n\t&dev_attr_fw_uptime.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group qla4xxx_host_attr_group = {\n\t.attrs = qla4xxx_host_attrs\n};\n\nconst struct attribute_group *qla4xxx_host_groups[] = {\n\t&qla4xxx_host_attr_group,\n\tNULL\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}