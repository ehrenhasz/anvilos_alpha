{
  "module_name": "ql4_def.h",
  "hash_id": "28079d185875c9175a3e23607ffaeaba3ef17a18dabaa64f9edef4833a65b2fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_def.h",
  "human_readable_source": " \n \n\n#ifndef __QL4_DEF_H\n#define __QL4_DEF_H\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/dmapool.h>\n#include <linux/mempool.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/bsg-lib.h>\n#include <linux/vmalloc.h>\n\n#include <net/tcp.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_iscsi.h>\n#include <scsi/scsi_bsg_iscsi.h>\n#include <scsi/scsi_netlink.h>\n#include <scsi/libiscsi.h>\n\n#include \"ql4_dbg.h\"\n#include \"ql4_nx.h\"\n#include \"ql4_fw.h\"\n#include \"ql4_nvram.h\"\n#include \"ql4_83xx.h\"\n\n#ifndef PCI_DEVICE_ID_QLOGIC_ISP4010\n#define PCI_DEVICE_ID_QLOGIC_ISP4010\t0x4010\n#endif\n\n#ifndef PCI_DEVICE_ID_QLOGIC_ISP4022\n#define PCI_DEVICE_ID_QLOGIC_ISP4022\t0x4022\n#endif\n\n#ifndef PCI_DEVICE_ID_QLOGIC_ISP4032\n#define PCI_DEVICE_ID_QLOGIC_ISP4032\t0x4032\n#endif\n\n#ifndef PCI_DEVICE_ID_QLOGIC_ISP8022\n#define PCI_DEVICE_ID_QLOGIC_ISP8022\t0x8022\n#endif\n\n#ifndef PCI_DEVICE_ID_QLOGIC_ISP8324\n#define PCI_DEVICE_ID_QLOGIC_ISP8324\t0x8032\n#endif\n\n#ifndef PCI_DEVICE_ID_QLOGIC_ISP8042\n#define PCI_DEVICE_ID_QLOGIC_ISP8042\t0x8042\n#endif\n\n#define ISP4XXX_PCI_FN_1\t0x1\n#define ISP4XXX_PCI_FN_2\t0x3\n\n#define QLA_SUCCESS\t\t\t0\n#define QLA_ERROR\t\t\t1\n#define STATUS(status)\t\tstatus == QLA_ERROR ? \"FAILED\" : \"SUCCEEDED\"\n\n \n#define BIT_0\t0x1\n#define BIT_1\t0x2\n#define BIT_2\t0x4\n#define BIT_3\t0x8\n#define BIT_4\t0x10\n#define BIT_5\t0x20\n#define BIT_6\t0x40\n#define BIT_7\t0x80\n#define BIT_8\t0x100\n#define BIT_9\t0x200\n#define BIT_10\t0x400\n#define BIT_11\t0x800\n#define BIT_12\t0x1000\n#define BIT_13\t0x2000\n#define BIT_14\t0x4000\n#define BIT_15\t0x8000\n#define BIT_16\t0x10000\n#define BIT_17\t0x20000\n#define BIT_18\t0x40000\n#define BIT_19\t0x80000\n#define BIT_20\t0x100000\n#define BIT_21\t0x200000\n#define BIT_22\t0x400000\n#define BIT_23\t0x800000\n#define BIT_24\t0x1000000\n#define BIT_25\t0x2000000\n#define BIT_26\t0x4000000\n#define BIT_27\t0x8000000\n#define BIT_28\t0x10000000\n#define BIT_29\t0x20000000\n#define BIT_30\t0x40000000\n#define BIT_31\t0x80000000\n\n \n#define ql4_printk(level, ha, format, arg...) \\\n\tdev_printk(level , &((ha)->pdev->dev) , format , ## arg)\n\n\n \n#define MAX_HBAS\t\t16\n#define MAX_BUSES\t\t1\n#define MAX_TARGETS\t\tMAX_DEV_DB_ENTRIES\n#define MAX_LUNS\t\t0xffff\n#define MAX_AEN_ENTRIES\t\tMAX_DEV_DB_ENTRIES\n#define MAX_DDB_ENTRIES\t\tMAX_DEV_DB_ENTRIES\n#define MAX_PDU_ENTRIES\t\t32\n#define INVALID_ENTRY\t\t0xFFFF\n#define MAX_CMDS_TO_RISC\t1024\n#define MAX_SRBS\t\tMAX_CMDS_TO_RISC\n#define MBOX_AEN_REG_COUNT\t8\n#define MAX_INIT_RETRIES\t5\n\n \n#define REQUEST_QUEUE_DEPTH\t\tMAX_CMDS_TO_RISC\n#define RESPONSE_QUEUE_DEPTH\t\t64\n#define QUEUE_SIZE\t\t\t64\n#define DMA_BUFFER_SIZE\t\t\t512\n#define IOCB_HIWAT_CUSHION\t\t4\n\n \n#define MAC_ADDR_LEN\t\t\t6\t \n#define IP_ADDR_LEN\t\t\t4\t \n#define IPv6_ADDR_LEN\t\t\t16\t \n#define DRIVER_NAME\t\t\t\"qla4xxx\"\n\n#define MAX_LINKED_CMDS_PER_LUN\t\t3\n#define MAX_REQS_SERVICED_PER_INTR\t1\n\n#define ISCSI_IPADDR_SIZE\t\t4\t \n#define ISCSI_ALIAS_SIZE\t\t32\t \n#define ISCSI_NAME_SIZE\t\t\t0xE0\t \n\n#define QL4_SESS_RECOVERY_TMO\t\t120\t \n\t\t\t\t\t\t \n\n#define LSDW(x) ((u32)((u64)(x)))\n#define MSDW(x) ((u32)((((u64)(x)) >> 16) >> 16))\n\n#define DEV_DB_NON_PERSISTENT\t0\n#define DEV_DB_PERSISTENT\t1\n\n#define QL4_ISP_REG_DISCONNECT 0xffffffffU\n\n#define COPY_ISID(dst_isid, src_isid) {\t\t\t\\\n\tint i, j;\t\t\t\t\t\\\n\tfor (i = 0, j = ISID_SIZE - 1; i < ISID_SIZE;)\t\\\n\t\tdst_isid[i++] = src_isid[j--];\t\t\\\n}\n\n#define SET_BITVAL(o, n, v) {\t\\\n\tif (o)\t\t\t\\\n\t\tn |= v;\t\t\\\n\telse\t\t\t\\\n\t\tn &= ~v;\t\\\n}\n\n#define OP_STATE(o, f, p) {\t\t\t\\\n\tp = (o & f) ? \"enable\" : \"disable\";\t\\\n}\n\n \n#define MBOX_TOV\t\t\t60\n#define SOFT_RESET_TOV\t\t\t30\n#define RESET_INTR_TOV\t\t\t3\n#define SEMAPHORE_TOV\t\t\t10\n#define ADAPTER_INIT_TOV\t\t30\n#define ADAPTER_RESET_TOV\t\t180\n#define EXTEND_CMD_TOV\t\t\t60\n#define WAIT_CMD_TOV\t\t\t5\n#define EH_WAIT_CMD_TOV\t\t\t120\n#define FIRMWARE_UP_TOV\t\t\t60\n#define RESET_FIRMWARE_TOV\t\t30\n#define LOGOUT_TOV\t\t\t10\n#define IOCB_TOV_MARGIN\t\t\t10\n#define RELOGIN_TOV\t\t\t18\n#define ISNS_DEREG_TOV\t\t\t5\n#define HBA_ONLINE_TOV\t\t\t30\n#define DISABLE_ACB_TOV\t\t\t30\n#define IP_CONFIG_TOV\t\t\t30\n#define LOGIN_TOV\t\t\t12\n#define BOOT_LOGIN_RESP_TOV\t\t60\n\n#define MAX_RESET_HA_RETRIES\t\t2\n#define FW_ALIVE_WAIT_TOV\t\t3\n#define IDC_EXTEND_TOV\t\t\t8\n#define IDC_COMP_TOV\t\t\t5\n#define LINK_UP_COMP_TOV\t\t30\n\n \nstruct qla4xxx_cmd_priv {\n\tstruct srb *srb;\n};\n\nstatic inline struct qla4xxx_cmd_priv *qla4xxx_cmd_priv(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\n \nstruct srb {\n\tstruct list_head list;\t \n\tstruct scsi_qla_host *ha;\t \n\tstruct ddb_entry *ddb;\n\tuint16_t flags;\t\t \n\n#define SRB_DMA_VALID\t\tBIT_3\t \n#define SRB_GOT_SENSE\t\tBIT_4\t \n\tuint8_t state;\t\t \n\n#define SRB_NO_QUEUE_STATE\t 0\t \n#define SRB_FREE_STATE\t\t 1\n#define SRB_ACTIVE_STATE\t 3\n#define SRB_ACTIVE_TIMEOUT_STATE 4\n#define SRB_SUSPENDED_STATE\t 7\t \n\n\tstruct scsi_cmnd *cmd;\t \n\tdma_addr_t dma_handle;\t \n\tstruct kref srb_ref;\t \n\tuint8_t err_id;\t\t \n#define SRB_ERR_PORT\t   1\t \n#define SRB_ERR_LOOP\t   2\t \n#define SRB_ERR_DEVICE\t   3\t \n#define SRB_ERR_OTHER\t   4\n\n\tuint16_t reserved;\n\tuint16_t iocb_tov;\n\tuint16_t iocb_cnt;\t \n\tuint16_t cc_stat;\n\n\t \n\tuint8_t *req_sense_ptr;\n\tuint16_t req_sense_len;\n\tuint16_t reserved2;\n};\n\n \nstruct mrb {\n\tstruct scsi_qla_host *ha;\n\tstruct mbox_cmd_iocb *mbox;\n\tuint32_t mbox_cmd;\n\tuint16_t iocb_cnt;\t\t \n\tuint32_t pid;\n};\n\n \nstruct aen {\n        uint32_t mbox_sts[MBOX_AEN_REG_COUNT];\n};\n\nstruct ql4_aen_log {\n        int count;\n        struct aen entry[MAX_AEN_ENTRIES];\n};\n\n \nstruct ddb_entry {\n\tstruct scsi_qla_host *ha;\n\tstruct iscsi_cls_session *sess;\n\tstruct iscsi_cls_conn *conn;\n\n\tuint16_t fw_ddb_index;\t \n\tuint32_t fw_ddb_device_state;  \n\tuint16_t ddb_type;\n#define FLASH_DDB 0x01\n\n\tstruct dev_db_entry fw_ddb_entry;\n\tint (*unblock_sess)(struct iscsi_cls_session *cls_session);\n\tint (*ddb_change)(struct scsi_qla_host *ha, uint32_t fw_ddb_index,\n\t\t\t  struct ddb_entry *ddb_entry, uint32_t state);\n\n\t \n\tunsigned long flags;\t\t   \n#define DDB_CONN_CLOSE_FAILURE\t\t0  \n\n\tuint16_t default_relogin_timeout;  \n\tatomic_t retry_relogin_timer;\t   \n\tatomic_t relogin_timer;\t\t   \n\tatomic_t relogin_retry_count;\t   \n\tuint32_t default_time2wait;\t   \n\tuint16_t chap_tbl_idx;\n};\n\nstruct qla_ddb_index {\n\tstruct list_head list;\n\tuint16_t fw_ddb_idx;\n\tuint16_t flash_ddb_idx;\n\tstruct dev_db_entry fw_ddb;\n\tuint8_t flash_isid[6];\n};\n\n#define DDB_IPADDR_LEN 64\n\nstruct ql4_tuple_ddb {\n\tint port;\n\tint tpgt;\n\tchar ip_addr[DDB_IPADDR_LEN];\n\tchar iscsi_name[ISCSI_NAME_SIZE];\n\tuint16_t options;\n#define DDB_OPT_IPV6 0x0e0e\n#define DDB_OPT_IPV4 0x0f0f\n\tuint8_t isid[6];\n};\n\n \n#define DDB_STATE_DEAD\t\t0\t \n#define DDB_STATE_ONLINE\t1\t \n#define DDB_STATE_MISSING\t2\t \n\n \n#define DF_RELOGIN\t\t0\t \n#define DF_BOOT_TGT\t\t1\t \n#define DF_ISNS_DISCOVERED\t2\t \n#define DF_FO_MASKED\t\t3\n#define DF_DISABLE_RELOGIN\t\t4\t \n\nenum qla4_work_type {\n\tQLA4_EVENT_AEN,\n\tQLA4_EVENT_PING_STATUS,\n};\n\nstruct qla4_work_evt {\n\tstruct list_head list;\n\tenum qla4_work_type type;\n\tunion {\n\t\tstruct {\n\t\t\tenum iscsi_host_event_code code;\n\t\t\tuint32_t data_size;\n\t\t\tuint8_t data[];\n\t\t} aen;\n\t\tstruct {\n\t\t\tuint32_t status;\n\t\t\tuint32_t pid;\n\t\t\tuint32_t data_size;\n\t\t\tuint8_t data[];\n\t\t} ping;\n\t} u;\n};\n\nstruct ql82xx_hw_data {\n\t \n\tuint32_t flash_conf_off;\n\tuint32_t flash_data_off;\n\n\tuint32_t fdt_wrt_disable;\n\tuint32_t fdt_erase_cmd;\n\tuint32_t fdt_block_size;\n\tuint32_t fdt_unprotect_sec_cmd;\n\tuint32_t fdt_protect_sec_cmd;\n\n\tuint32_t flt_region_flt;\n\tuint32_t flt_region_fdt;\n\tuint32_t flt_region_boot;\n\tuint32_t flt_region_bootload;\n\tuint32_t flt_region_fw;\n\n\tuint32_t flt_iscsi_param;\n\tuint32_t flt_region_chap;\n\tuint32_t flt_chap_size;\n\tuint32_t flt_region_ddb;\n\tuint32_t flt_ddb_size;\n};\n\nstruct qla4_8xxx_legacy_intr_set {\n\tuint32_t int_vec_bit;\n\tuint32_t tgt_status_reg;\n\tuint32_t tgt_mask_reg;\n\tuint32_t pci_int_reg;\n};\n\n \n#define QLA_MSIX_ENTRIES\t2\n\n \nstruct isp_operations {\n\tint (*iospace_config) (struct scsi_qla_host *ha);\n\tvoid (*pci_config) (struct scsi_qla_host *);\n\tvoid (*disable_intrs) (struct scsi_qla_host *);\n\tvoid (*enable_intrs) (struct scsi_qla_host *);\n\tint (*start_firmware) (struct scsi_qla_host *);\n\tint (*restart_firmware) (struct scsi_qla_host *);\n\tirqreturn_t (*intr_handler) (int , void *);\n\tvoid (*interrupt_service_routine) (struct scsi_qla_host *, uint32_t);\n\tint (*need_reset) (struct scsi_qla_host *);\n\tint (*reset_chip) (struct scsi_qla_host *);\n\tint (*reset_firmware) (struct scsi_qla_host *);\n\tvoid (*queue_iocb) (struct scsi_qla_host *);\n\tvoid (*complete_iocb) (struct scsi_qla_host *);\n\tuint16_t (*rd_shdw_req_q_out) (struct scsi_qla_host *);\n\tuint16_t (*rd_shdw_rsp_q_in) (struct scsi_qla_host *);\n\tint (*get_sys_info) (struct scsi_qla_host *);\n\tuint32_t (*rd_reg_direct) (struct scsi_qla_host *, ulong);\n\tvoid (*wr_reg_direct) (struct scsi_qla_host *, ulong, uint32_t);\n\tint (*rd_reg_indirect) (struct scsi_qla_host *, uint32_t, uint32_t *);\n\tint (*wr_reg_indirect) (struct scsi_qla_host *, uint32_t, uint32_t);\n\tint (*idc_lock) (struct scsi_qla_host *);  \n\tvoid (*idc_unlock) (struct scsi_qla_host *);\n\tvoid (*rom_lock_recovery) (struct scsi_qla_host *);  \n\tvoid (*queue_mailbox_command) (struct scsi_qla_host *, uint32_t *, int);\n\tvoid (*process_mailbox_interrupt) (struct scsi_qla_host *, int);\n};\n\nstruct ql4_mdump_size_table {\n\tuint32_t size;\n\tuint32_t size_cmask_02;\n\tuint32_t size_cmask_04;\n\tuint32_t size_cmask_08;\n\tuint32_t size_cmask_10;\n\tuint32_t size_cmask_FF;\n\tuint32_t version;\n};\n\n \nstruct ipaddress_config {\n\tuint16_t ipv4_options;\n\tuint16_t tcp_options;\n\tuint16_t ipv4_vlan_tag;\n\tuint8_t ipv4_addr_state;\n\tuint8_t ip_address[IP_ADDR_LEN];\n\tuint8_t subnet_mask[IP_ADDR_LEN];\n\tuint8_t gateway[IP_ADDR_LEN];\n\tuint32_t ipv6_options;\n\tuint32_t ipv6_addl_options;\n\tuint8_t ipv6_link_local_state;\n\tuint8_t ipv6_addr0_state;\n\tuint8_t ipv6_addr1_state;\n\tuint8_t ipv6_default_router_state;\n\tuint16_t ipv6_vlan_tag;\n\tstruct in6_addr ipv6_link_local_addr;\n\tstruct in6_addr ipv6_addr0;\n\tstruct in6_addr ipv6_addr1;\n\tstruct in6_addr ipv6_default_router_addr;\n\tuint16_t eth_mtu_size;\n\tuint16_t ipv4_port;\n\tuint16_t ipv6_port;\n\tuint8_t control;\n\tuint16_t ipv6_tcp_options;\n\tuint8_t tcp_wsf;\n\tuint8_t ipv6_tcp_wsf;\n\tuint8_t ipv4_tos;\n\tuint8_t ipv4_cache_id;\n\tuint8_t ipv6_cache_id;\n\tuint8_t ipv4_alt_cid_len;\n\tuint8_t ipv4_alt_cid[11];\n\tuint8_t ipv4_vid_len;\n\tuint8_t ipv4_vid[11];\n\tuint8_t ipv4_ttl;\n\tuint16_t ipv6_flow_lbl;\n\tuint8_t ipv6_traffic_class;\n\tuint8_t ipv6_hop_limit;\n\tuint32_t ipv6_nd_reach_time;\n\tuint32_t ipv6_nd_rexmit_timer;\n\tuint32_t ipv6_nd_stale_timeout;\n\tuint8_t ipv6_dup_addr_detect_count;\n\tuint32_t ipv6_gw_advrt_mtu;\n\tuint16_t def_timeout;\n\tuint8_t abort_timer;\n\tuint16_t iscsi_options;\n\tuint16_t iscsi_max_pdu_size;\n\tuint16_t iscsi_first_burst_len;\n\tuint16_t iscsi_max_outstnd_r2t;\n\tuint16_t iscsi_max_burst_len;\n\tuint8_t iscsi_name[224];\n};\n\n#define QL4_CHAP_MAX_NAME_LEN 256\n#define QL4_CHAP_MAX_SECRET_LEN 100\n#define LOCAL_CHAP\t0\n#define BIDI_CHAP\t1\n\nstruct ql4_chap_format {\n\tu8  intr_chap_name[QL4_CHAP_MAX_NAME_LEN];\n\tu8  intr_secret[QL4_CHAP_MAX_SECRET_LEN];\n\tu8  target_chap_name[QL4_CHAP_MAX_NAME_LEN];\n\tu8  target_secret[QL4_CHAP_MAX_SECRET_LEN];\n\tu16 intr_chap_name_length;\n\tu16 intr_secret_length;\n\tu16 target_chap_name_length;\n\tu16 target_secret_length;\n};\n\nstruct ip_address_format {\n\tu8 ip_type;\n\tu8 ip_address[16];\n};\n\nstruct\tql4_conn_info {\n\tu16\tdest_port;\n\tstruct\tip_address_format dest_ipaddr;\n\tstruct\tql4_chap_format chap;\n};\n\nstruct ql4_boot_session_info {\n\tu8\ttarget_name[224];\n\tstruct\tql4_conn_info conn_list[1];\n};\n\nstruct ql4_boot_tgt_info {\n\tstruct ql4_boot_session_info boot_pri_sess;\n\tstruct ql4_boot_session_info boot_sec_sess;\n};\n\n \nstruct scsi_qla_host {\n\t \n\tunsigned long flags;\n\n#define AF_ONLINE\t\t\t0  \n#define AF_INIT_DONE\t\t\t1  \n#define AF_MBOX_COMMAND\t\t\t2  \n#define AF_MBOX_COMMAND_DONE\t\t3  \n#define AF_ST_DISCOVERY_IN_PROGRESS\t4  \n#define AF_INTERRUPTS_ON\t\t6  \n#define AF_GET_CRASH_RECORD\t\t7  \n#define AF_LINK_UP\t\t\t8  \n#define AF_LOOPBACK\t\t\t9  \n#define AF_IRQ_ATTACHED\t\t\t10  \n#define AF_DISABLE_ACB_COMPLETE\t\t11  \n#define AF_HA_REMOVAL\t\t\t12  \n#define AF_MBOX_COMMAND_NOPOLL\t\t18  \n#define AF_FW_RECOVERY\t\t\t19  \n#define AF_EEH_BUSY\t\t\t20  \n#define AF_PCI_CHANNEL_IO_PERM_FAILURE\t21  \n#define AF_BUILD_DDB_LIST\t\t22  \n#define AF_82XX_FW_DUMPED\t\t24  \n#define AF_8XXX_RST_OWNER\t\t25  \n#define AF_82XX_DUMP_READING\t\t26  \n#define AF_83XX_IOCB_INTR_ON\t\t28  \n#define AF_83XX_MBOX_INTR_ON\t\t29  \n\n\tunsigned long dpc_flags;\n\n#define DPC_RESET_HA\t\t\t1  \n#define DPC_RETRY_RESET_HA\t\t2  \n#define DPC_RELOGIN_DEVICE\t\t3  \n#define DPC_RESET_HA_FW_CONTEXT\t\t4  \n#define DPC_RESET_HA_INTR\t\t5  \n#define DPC_ISNS_RESTART\t\t7  \n#define DPC_AEN\t\t\t\t9  \n#define DPC_GET_DHCP_IP_ADDR\t\t15  \n#define DPC_LINK_CHANGED\t\t18  \n#define DPC_RESET_ACTIVE\t\t20  \n#define DPC_HA_UNRECOVERABLE\t\t21  \n#define DPC_HA_NEED_QUIESCENT\t\t22  \n#define DPC_POST_IDC_ACK\t\t23  \n#define DPC_RESTORE_ACB\t\t\t24  \n#define DPC_SYSFS_DDB_EXPORT\t\t25  \n\n\tstruct Scsi_Host *host;  \n\tuint32_t tot_ddbs;\n\n\tuint16_t iocb_cnt;\n\tuint16_t iocb_hiwat;\n\n\t \n#define SRB_MIN_REQ\t128\n\tmempool_t *srb_mempool;\n\n\t \n\tstruct pci_dev *pdev;\n\n\tstruct isp_reg __iomem *reg;  \n\tunsigned long pio_address;\n\tunsigned long pio_length;\n#define MIN_IOBASE_LEN\t\t0x100\n\n\tuint16_t req_q_count;\n\n\tunsigned long host_no;\n\n\t \n\tstruct eeprom_data *nvram;\n\tspinlock_t hardware_lock ____cacheline_aligned;\n\tuint32_t eeprom_cmd_data;\n\n\t \n\tuint64_t isr_count;\n\tuint64_t adapter_error_count;\n\tuint64_t device_error_count;\n\tuint64_t total_io_count;\n\tuint64_t total_mbytes_xferred;\n\tuint64_t link_failure_count;\n\tuint64_t invalid_crc_count;\n\tuint32_t bytes_xfered;\n\tuint32_t spurious_int_count;\n\tuint32_t aborted_io_count;\n\tuint32_t io_timeout_count;\n\tuint32_t mailbox_timeout_count;\n\tuint32_t seconds_since_last_intr;\n\tuint32_t seconds_since_last_heartbeat;\n\tuint32_t mac_index;\n\n\t \n\t \n\tuint32_t firmware_version[2];\n\tuint32_t patch_number;\n\tuint32_t build_number;\n\tuint32_t board_id;\n\n\t \n\t \n\tuint16_t firmware_options;\n\tuint8_t alias[32];\n\tuint8_t name_string[256];\n\tuint8_t heartbeat_interval;\n\n\t \n\tuint8_t my_mac[MAC_ADDR_LEN];\n\tuint8_t serial_number[16];\n\tuint16_t port_num;\n\t \n\tuint32_t firmware_state;\n\tuint32_t addl_fw_state;\n\n\t \n\tstruct workqueue_struct *dpc_thread;\n\tstruct work_struct dpc_work;\n\n\t \n\tstruct timer_list timer;\n\tuint32_t timer_active;\n\n\t \n\tatomic_t check_relogin_timeouts;\n\tuint32_t retry_reset_ha_cnt;\n\tuint32_t isp_reset_timer;\t \n\tuint32_t nic_reset_timer;\t \n\tint eh_start;\n\tstruct list_head free_srb_q;\n\tuint16_t free_srb_q_count;\n\tuint16_t num_srbs_allocated;\n\n\t \n\tvoid *queues;\n\tdma_addr_t queues_dma;\n\tunsigned long queues_len;\n\n#define MEM_ALIGN_VALUE \\\n\t    ((max(REQUEST_QUEUE_DEPTH, RESPONSE_QUEUE_DEPTH)) * \\\n\t     sizeof(struct queue_entry))\n\t \n\tdma_addr_t request_dma;\n\tstruct queue_entry *request_ring;\n\tstruct queue_entry *request_ptr;\n\tdma_addr_t response_dma;\n\tstruct queue_entry *response_ring;\n\tstruct queue_entry *response_ptr;\n\tdma_addr_t shadow_regs_dma;\n\tstruct shadow_regs *shadow_regs;\n\tuint16_t request_in;\t \n\tuint16_t request_out;\n\tuint16_t response_in;\n\tuint16_t response_out;\n\n\t \n\tuint16_t aen_q_count;\t \n\tuint16_t aen_in;\t \n\tuint16_t aen_out;\n\tstruct aen aen_q[MAX_AEN_ENTRIES];\n\n\tstruct ql4_aen_log aen_log; \n\n\t \n\tstruct mutex  mbox_sem;\n\n\t \n\tvolatile uint8_t mbox_status_count;\n\tvolatile uint32_t mbox_status[MBOX_REG_COUNT];\n\n\t \n\tstruct ddb_entry *fw_ddb_index_map[MAX_DDB_ENTRIES];\n\n\t \n\tstruct srb *status_srb;\n\n\tuint8_t acb_version;\n\n\t \n\tstruct device_reg_82xx  __iomem *qla4_82xx_reg;  \n\tunsigned long nx_pcibase;\t \n\tuint8_t *nx_db_rd_ptr;\t\t \n\tunsigned long nx_db_wr_ptr;\t \n\tunsigned long first_page_group_start;\n\tunsigned long first_page_group_end;\n\n\tuint32_t crb_win;\n\tuint32_t curr_window;\n\tuint32_t ddr_mn_window;\n\tunsigned long mn_win_crb;\n\tunsigned long ms_win_crb;\n\tint qdr_sn_window;\n\trwlock_t hw_lock;\n\tuint16_t func_num;\n\tint link_width;\n\n\tstruct qla4_8xxx_legacy_intr_set nx_legacy_intr;\n\tu32 nx_crb_mask;\n\n\tuint8_t revision_id;\n\tuint32_t fw_heartbeat_counter;\n\n\tstruct isp_operations *isp_ops;\n\tstruct ql82xx_hw_data hw;\n\n\tuint32_t nx_dev_init_timeout;\n\tuint32_t nx_reset_timeout;\n\tvoid *fw_dump;\n\tuint32_t fw_dump_size;\n\tuint32_t fw_dump_capture_mask;\n\tvoid *fw_dump_tmplt_hdr;\n\tuint32_t fw_dump_tmplt_size;\n\tuint32_t fw_dump_skip_size;\n\n\tstruct completion mbx_intr_comp;\n\n\tstruct ipaddress_config ip_config;\n\tstruct iscsi_iface *iface_ipv4;\n\tstruct iscsi_iface *iface_ipv6_0;\n\tstruct iscsi_iface *iface_ipv6_1;\n\n\t \n\tstruct about_fw_info fw_info;\n\tuint32_t fw_uptime_secs;   \n\tuint32_t fw_uptime_msecs;  \n\tuint16_t def_timeout;  \n\n\tuint32_t flash_state;\n#define\tQLFLASH_WAITING\t\t0\n#define\tQLFLASH_READING\t\t1\n#define\tQLFLASH_WRITING\t\t2\n\tstruct dma_pool *chap_dma_pool;\n\tuint8_t *chap_list;  \n\tstruct mutex  chap_sem;\n\n#define CHAP_DMA_BLOCK_SIZE    512\n\tstruct workqueue_struct *task_wq;\n\tunsigned long ddb_idx_map[MAX_DDB_ENTRIES / BITS_PER_LONG];\n#define SYSFS_FLAG_FW_SEL_BOOT 2\n\tstruct iscsi_boot_kset *boot_kset;\n\tstruct ql4_boot_tgt_info boot_tgt;\n\tuint16_t phy_port_num;\n\tuint16_t phy_port_cnt;\n\tuint16_t iscsi_pci_func_cnt;\n\tuint8_t model_name[16];\n\tstruct completion disable_acb_comp;\n\tstruct dma_pool *fw_ddb_dma_pool;\n#define DDB_DMA_BLOCK_SIZE 512\n\tuint16_t pri_ddb_idx;\n\tuint16_t sec_ddb_idx;\n\tint is_reset;\n\tuint16_t temperature;\n\n\t \n\tstruct list_head work_list;\n\tspinlock_t work_lock;\n\n\t \n#define MAX_MRB\t\t128\n\tstruct mrb *active_mrb_array[MAX_MRB];\n\tuint32_t mrb_index;\n\n\tuint32_t *reg_tbl;\n\tstruct qla4_83xx_reset_template reset_tmplt;\n\tstruct device_reg_83xx  __iomem *qla4_83xx_reg;  \n\tuint32_t pf_bit;\n\tstruct qla4_83xx_idc_information idc_info;\n\tstruct addr_ctrl_blk *saved_acb;\n\tint notify_idc_comp;\n\tint notify_link_up_comp;\n\tint idc_extend_tmo;\n\tstruct completion idc_comp;\n\tstruct completion link_up_comp;\n};\n\nstruct ql4_task_data {\n\tstruct scsi_qla_host *ha;\n\tuint8_t iocb_req_cnt;\n\tdma_addr_t data_dma;\n\tvoid *req_buffer;\n\tdma_addr_t req_dma;\n\tuint32_t req_len;\n\tvoid *resp_buffer;\n\tdma_addr_t resp_dma;\n\tuint32_t resp_len;\n\tstruct iscsi_task *task;\n\tstruct passthru_status sts;\n\tstruct work_struct task_work;\n};\n\nstruct qla_endpoint {\n\tstruct Scsi_Host *host;\n\tstruct sockaddr_storage dst_addr;\n};\n\nstruct qla_conn {\n\tstruct qla_endpoint *qla_ep;\n};\n\nstatic inline int is_ipv4_enabled(struct scsi_qla_host *ha)\n{\n\treturn ((ha->ip_config.ipv4_options & IPOPT_IPV4_PROTOCOL_ENABLE) != 0);\n}\n\nstatic inline int is_ipv6_enabled(struct scsi_qla_host *ha)\n{\n\treturn ((ha->ip_config.ipv6_options &\n\t\tIPV6_OPT_IPV6_PROTOCOL_ENABLE) != 0);\n}\n\nstatic inline int is_qla4010(struct scsi_qla_host *ha)\n{\n\treturn ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4010;\n}\n\nstatic inline int is_qla4022(struct scsi_qla_host *ha)\n{\n\treturn ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4022;\n}\n\nstatic inline int is_qla4032(struct scsi_qla_host *ha)\n{\n\treturn ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP4032;\n}\n\nstatic inline int is_qla40XX(struct scsi_qla_host *ha)\n{\n\treturn is_qla4032(ha) || is_qla4022(ha) || is_qla4010(ha);\n}\n\nstatic inline int is_qla8022(struct scsi_qla_host *ha)\n{\n\treturn ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8022;\n}\n\nstatic inline int is_qla8032(struct scsi_qla_host *ha)\n{\n\treturn ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8324;\n}\n\nstatic inline int is_qla8042(struct scsi_qla_host *ha)\n{\n\treturn ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8042;\n}\n\nstatic inline int is_qla80XX(struct scsi_qla_host *ha)\n{\n\treturn is_qla8022(ha) || is_qla8032(ha) || is_qla8042(ha);\n}\n\nstatic inline int is_aer_supported(struct scsi_qla_host *ha)\n{\n\treturn ((ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8022) ||\n\t\t(ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8324) ||\n\t\t(ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP8042));\n}\n\nstatic inline int adapter_up(struct scsi_qla_host *ha)\n{\n\treturn (test_bit(AF_ONLINE, &ha->flags) != 0) &&\n\t       (test_bit(AF_LINK_UP, &ha->flags) != 0) &&\n\t       (!test_bit(AF_LOOPBACK, &ha->flags));\n}\n\nstatic inline struct scsi_qla_host* to_qla_host(struct Scsi_Host *shost)\n{\n\treturn (struct scsi_qla_host *)iscsi_host_priv(shost);\n}\n\nstatic inline void __iomem* isp_semaphore(struct scsi_qla_host *ha)\n{\n\treturn (is_qla4010(ha) ?\n\t\t&ha->reg->u1.isp4010.nvram :\n\t\t&ha->reg->u1.isp4022.semaphore);\n}\n\nstatic inline void __iomem* isp_nvram(struct scsi_qla_host *ha)\n{\n\treturn (is_qla4010(ha) ?\n\t\t&ha->reg->u1.isp4010.nvram :\n\t\t&ha->reg->u1.isp4022.nvram);\n}\n\nstatic inline void __iomem* isp_ext_hw_conf(struct scsi_qla_host *ha)\n{\n\treturn (is_qla4010(ha) ?\n\t\t&ha->reg->u2.isp4010.ext_hw_conf :\n\t\t&ha->reg->u2.isp4022.p0.ext_hw_conf);\n}\n\nstatic inline void __iomem* isp_port_status(struct scsi_qla_host *ha)\n{\n\treturn (is_qla4010(ha) ?\n\t\t&ha->reg->u2.isp4010.port_status :\n\t\t&ha->reg->u2.isp4022.p0.port_status);\n}\n\nstatic inline void __iomem* isp_port_ctrl(struct scsi_qla_host *ha)\n{\n\treturn (is_qla4010(ha) ?\n\t\t&ha->reg->u2.isp4010.port_ctrl :\n\t\t&ha->reg->u2.isp4022.p0.port_ctrl);\n}\n\nstatic inline void __iomem* isp_port_error_status(struct scsi_qla_host *ha)\n{\n\treturn (is_qla4010(ha) ?\n\t\t&ha->reg->u2.isp4010.port_err_status :\n\t\t&ha->reg->u2.isp4022.p0.port_err_status);\n}\n\nstatic inline void __iomem * isp_gp_out(struct scsi_qla_host *ha)\n{\n\treturn (is_qla4010(ha) ?\n\t\t&ha->reg->u2.isp4010.gp_out :\n\t\t&ha->reg->u2.isp4022.p0.gp_out);\n}\n\nstatic inline int eeprom_ext_hw_conf_offset(struct scsi_qla_host *ha)\n{\n\treturn (is_qla4010(ha) ?\n\t\toffsetof(struct eeprom_data, isp4010.ext_hw_conf) / 2 :\n\t\toffsetof(struct eeprom_data, isp4022.ext_hw_conf) / 2);\n}\n\nint ql4xxx_sem_spinlock(struct scsi_qla_host * ha, u32 sem_mask, u32 sem_bits);\nvoid ql4xxx_sem_unlock(struct scsi_qla_host * ha, u32 sem_mask);\nint ql4xxx_sem_lock(struct scsi_qla_host * ha, u32 sem_mask, u32 sem_bits);\n\nstatic inline int ql4xxx_lock_flash(struct scsi_qla_host *a)\n{\n\tif (is_qla4010(a))\n\t\treturn ql4xxx_sem_spinlock(a, QL4010_FLASH_SEM_MASK,\n\t\t\t\t\t   QL4010_FLASH_SEM_BITS);\n\telse\n\t\treturn ql4xxx_sem_spinlock(a, QL4022_FLASH_SEM_MASK,\n\t\t\t\t\t   (QL4022_RESOURCE_BITS_BASE_CODE |\n\t\t\t\t\t    (a->mac_index)) << 13);\n}\n\nstatic inline void ql4xxx_unlock_flash(struct scsi_qla_host *a)\n{\n\tif (is_qla4010(a))\n\t\tql4xxx_sem_unlock(a, QL4010_FLASH_SEM_MASK);\n\telse\n\t\tql4xxx_sem_unlock(a, QL4022_FLASH_SEM_MASK);\n}\n\nstatic inline int ql4xxx_lock_nvram(struct scsi_qla_host *a)\n{\n\tif (is_qla4010(a))\n\t\treturn ql4xxx_sem_spinlock(a, QL4010_NVRAM_SEM_MASK,\n\t\t\t\t\t   QL4010_NVRAM_SEM_BITS);\n\telse\n\t\treturn ql4xxx_sem_spinlock(a, QL4022_NVRAM_SEM_MASK,\n\t\t\t\t\t   (QL4022_RESOURCE_BITS_BASE_CODE |\n\t\t\t\t\t    (a->mac_index)) << 10);\n}\n\nstatic inline void ql4xxx_unlock_nvram(struct scsi_qla_host *a)\n{\n\tif (is_qla4010(a))\n\t\tql4xxx_sem_unlock(a, QL4010_NVRAM_SEM_MASK);\n\telse\n\t\tql4xxx_sem_unlock(a, QL4022_NVRAM_SEM_MASK);\n}\n\nstatic inline int ql4xxx_lock_drvr(struct scsi_qla_host *a)\n{\n\tif (is_qla4010(a))\n\t\treturn ql4xxx_sem_lock(a, QL4010_DRVR_SEM_MASK,\n\t\t\t\t       QL4010_DRVR_SEM_BITS);\n\telse\n\t\treturn ql4xxx_sem_lock(a, QL4022_DRVR_SEM_MASK,\n\t\t\t\t       (QL4022_RESOURCE_BITS_BASE_CODE |\n\t\t\t\t\t(a->mac_index)) << 1);\n}\n\nstatic inline void ql4xxx_unlock_drvr(struct scsi_qla_host *a)\n{\n\tif (is_qla4010(a))\n\t\tql4xxx_sem_unlock(a, QL4010_DRVR_SEM_MASK);\n\telse\n\t\tql4xxx_sem_unlock(a, QL4022_DRVR_SEM_MASK);\n}\n\nstatic inline int ql4xxx_reset_active(struct scsi_qla_host *ha)\n{\n\treturn test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\n\t       test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t       test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||\n\t       test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\n\t       test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\n\t       test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);\n\n}\n\nstatic inline int qla4_8xxx_rd_direct(struct scsi_qla_host *ha,\n\t\t\t\t      const uint32_t crb_reg)\n{\n\treturn ha->isp_ops->rd_reg_direct(ha, ha->reg_tbl[crb_reg]);\n}\n\nstatic inline void qla4_8xxx_wr_direct(struct scsi_qla_host *ha,\n\t\t\t\t       const uint32_t crb_reg,\n\t\t\t\t       const uint32_t value)\n{\n\tha->isp_ops->wr_reg_direct(ha, ha->reg_tbl[crb_reg], value);\n}\n\n \n\n \n\n#define INIT_ADAPTER    0\n#define RESET_ADAPTER   1\n\n#define PRESERVE_DDB_LIST\t0\n#define REBUILD_DDB_LIST\t1\n\n \n#define PROCESS_ALL_AENS\t 0\n#define FLUSH_DDB_CHANGED_AENS\t 1\n\n \n#define QL4_UEVENT_CODE_FW_DUMP\t\t0\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}