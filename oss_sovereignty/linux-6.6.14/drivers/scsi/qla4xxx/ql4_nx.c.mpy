{
  "module_name": "ql4_nx.c",
  "hash_id": "419be060237c718a45c62cc38793342d0c839ff7309567da630027f91dd0e1bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_nx.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/ratelimit.h>\n#include \"ql4_def.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_inline.h\"\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n#define TIMEOUT_100_MS\t100\n#define MASK(n)\t\tDMA_BIT_MASK(n)\n#define MN_WIN(addr)\t(((addr & 0x1fc0000) >> 1) | ((addr >> 25) & 0x3ff))\n#define OCM_WIN(addr)\t(((addr & 0x1ff0000) >> 1) | ((addr >> 25) & 0x3ff))\n#define MS_WIN(addr)\t(addr & 0x0ffc0000)\n#define QLA82XX_PCI_MN_2M\t(0)\n#define QLA82XX_PCI_MS_2M\t(0x80000)\n#define QLA82XX_PCI_OCM0_2M\t(0xc0000)\n#define VALID_OCM_ADDR(addr)\t(((addr) & 0x3f800) != 0x3f800)\n#define GET_MEM_OFFS_2M(addr)\t(addr & MASK(18))\n\n \n#define CRB_BLK(off)\t((off >> 20) & 0x3f)\n#define CRB_SUBBLK(off)\t((off >> 16) & 0xf)\n#define CRB_WINDOW_2M\t(0x130060)\n#define CRB_HI(off)\t((qla4_82xx_crb_hub_agt[CRB_BLK(off)] << 20) | \\\n\t\t\t((off) & 0xf0000))\n#define QLA82XX_PCI_CAMQM_2M_END\t(0x04800800UL)\n#define QLA82XX_PCI_CAMQM_2M_BASE\t(0x000ff800UL)\n#define CRB_INDIRECT_2M\t\t\t(0x1e0000UL)\n\nstatic inline void __iomem *\nqla4_8xxx_pci_base_offsetfset(struct scsi_qla_host *ha, unsigned long off)\n{\n\tif ((off < ha->first_page_group_end) &&\n\t    (off >= ha->first_page_group_start))\n\t\treturn (void __iomem *)(ha->nx_pcibase + off);\n\n\treturn NULL;\n}\n\nstatic const int MD_MIU_TEST_AGT_RDDATA[] = { 0x410000A8,\n\t\t\t\t0x410000AC, 0x410000B8, 0x410000BC };\n#define MAX_CRB_XFORM 60\nstatic unsigned long crb_addr_xform[MAX_CRB_XFORM];\nstatic int qla4_8xxx_crb_table_initialized;\n\n#define qla4_8xxx_crb_addr_transform(name) \\\n\t(crb_addr_xform[QLA82XX_HW_PX_MAP_CRB_##name] = \\\n\t QLA82XX_HW_CRB_HUB_AGT_ADR_##name << 20)\nstatic void\nqla4_82xx_crb_addr_transform_setup(void)\n{\n\tqla4_8xxx_crb_addr_transform(XDMA);\n\tqla4_8xxx_crb_addr_transform(TIMR);\n\tqla4_8xxx_crb_addr_transform(SRE);\n\tqla4_8xxx_crb_addr_transform(SQN3);\n\tqla4_8xxx_crb_addr_transform(SQN2);\n\tqla4_8xxx_crb_addr_transform(SQN1);\n\tqla4_8xxx_crb_addr_transform(SQN0);\n\tqla4_8xxx_crb_addr_transform(SQS3);\n\tqla4_8xxx_crb_addr_transform(SQS2);\n\tqla4_8xxx_crb_addr_transform(SQS1);\n\tqla4_8xxx_crb_addr_transform(SQS0);\n\tqla4_8xxx_crb_addr_transform(RPMX7);\n\tqla4_8xxx_crb_addr_transform(RPMX6);\n\tqla4_8xxx_crb_addr_transform(RPMX5);\n\tqla4_8xxx_crb_addr_transform(RPMX4);\n\tqla4_8xxx_crb_addr_transform(RPMX3);\n\tqla4_8xxx_crb_addr_transform(RPMX2);\n\tqla4_8xxx_crb_addr_transform(RPMX1);\n\tqla4_8xxx_crb_addr_transform(RPMX0);\n\tqla4_8xxx_crb_addr_transform(ROMUSB);\n\tqla4_8xxx_crb_addr_transform(SN);\n\tqla4_8xxx_crb_addr_transform(QMN);\n\tqla4_8xxx_crb_addr_transform(QMS);\n\tqla4_8xxx_crb_addr_transform(PGNI);\n\tqla4_8xxx_crb_addr_transform(PGND);\n\tqla4_8xxx_crb_addr_transform(PGN3);\n\tqla4_8xxx_crb_addr_transform(PGN2);\n\tqla4_8xxx_crb_addr_transform(PGN1);\n\tqla4_8xxx_crb_addr_transform(PGN0);\n\tqla4_8xxx_crb_addr_transform(PGSI);\n\tqla4_8xxx_crb_addr_transform(PGSD);\n\tqla4_8xxx_crb_addr_transform(PGS3);\n\tqla4_8xxx_crb_addr_transform(PGS2);\n\tqla4_8xxx_crb_addr_transform(PGS1);\n\tqla4_8xxx_crb_addr_transform(PGS0);\n\tqla4_8xxx_crb_addr_transform(PS);\n\tqla4_8xxx_crb_addr_transform(PH);\n\tqla4_8xxx_crb_addr_transform(NIU);\n\tqla4_8xxx_crb_addr_transform(I2Q);\n\tqla4_8xxx_crb_addr_transform(EG);\n\tqla4_8xxx_crb_addr_transform(MN);\n\tqla4_8xxx_crb_addr_transform(MS);\n\tqla4_8xxx_crb_addr_transform(CAS2);\n\tqla4_8xxx_crb_addr_transform(CAS1);\n\tqla4_8xxx_crb_addr_transform(CAS0);\n\tqla4_8xxx_crb_addr_transform(CAM);\n\tqla4_8xxx_crb_addr_transform(C2C1);\n\tqla4_8xxx_crb_addr_transform(C2C0);\n\tqla4_8xxx_crb_addr_transform(SMB);\n\tqla4_8xxx_crb_addr_transform(OCM0);\n\tqla4_8xxx_crb_addr_transform(I2C0);\n\n\tqla4_8xxx_crb_table_initialized = 1;\n}\n\nstatic struct crb_128M_2M_block_map crb_128M_2M_map[64] = {\n\t{{{0, 0,         0,         0} } },\t\t \n\t{{{1, 0x0100000, 0x0102000, 0x120000},\t \n\t\t{1, 0x0110000, 0x0120000, 0x130000},\n\t\t{1, 0x0120000, 0x0122000, 0x124000},\n\t\t{1, 0x0130000, 0x0132000, 0x126000},\n\t\t{1, 0x0140000, 0x0142000, 0x128000},\n\t\t{1, 0x0150000, 0x0152000, 0x12a000},\n\t\t{1, 0x0160000, 0x0170000, 0x110000},\n\t\t{1, 0x0170000, 0x0172000, 0x12e000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{1, 0x01e0000, 0x01e0800, 0x122000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000} } },\n\t{{{1, 0x0200000, 0x0210000, 0x180000} } }, \n\t{{{0, 0,         0,         0} } },\t     \n\t{{{1, 0x0400000, 0x0401000, 0x169000} } }, \n\t{{{1, 0x0500000, 0x0510000, 0x140000} } }, \n\t{{{1, 0x0600000, 0x0610000, 0x1c0000} } }, \n\t{{{1, 0x0700000, 0x0704000, 0x1b8000} } }, \n\t{{{1, 0x0800000, 0x0802000, 0x170000},   \n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{1, 0x08f0000, 0x08f2000, 0x172000} } },\n\t{{{1, 0x0900000, 0x0902000, 0x174000},\t \n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{1, 0x09f0000, 0x09f2000, 0x176000} } },\n\t{{{0, 0x0a00000, 0x0a02000, 0x178000},\t \n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{1, 0x0af0000, 0x0af2000, 0x17a000} } },\n\t{{{0, 0x0b00000, 0x0b02000, 0x17c000},\t \n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{1, 0x0bf0000, 0x0bf2000, 0x17e000} } },\n\t{{{1, 0x0c00000, 0x0c04000, 0x1d4000} } }, \n\t{{{1, 0x0d00000, 0x0d04000, 0x1a4000} } }, \n\t{{{1, 0x0e00000, 0x0e04000, 0x1a0000} } }, \n\t{{{1, 0x0f00000, 0x0f01000, 0x164000} } }, \n\t{{{0, 0x1000000, 0x1004000, 0x1a8000} } }, \n\t{{{1, 0x1100000, 0x1101000, 0x160000} } }, \n\t{{{1, 0x1200000, 0x1201000, 0x161000} } }, \n\t{{{1, 0x1300000, 0x1301000, 0x162000} } }, \n\t{{{1, 0x1400000, 0x1401000, 0x163000} } }, \n\t{{{1, 0x1500000, 0x1501000, 0x165000} } }, \n\t{{{1, 0x1600000, 0x1601000, 0x166000} } }, \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{0, 0,         0,         0} } },\t \n\t{{{1, 0x1d00000, 0x1d10000, 0x190000} } }, \n\t{{{1, 0x1e00000, 0x1e01000, 0x16a000} } }, \n\t{{{1, 0x1f00000, 0x1f10000, 0x150000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x2100000, 0x2102000, 0x120000},\t \n\t\t{1, 0x2110000, 0x2120000, 0x130000},\n\t\t{1, 0x2120000, 0x2122000, 0x124000},\n\t\t{1, 0x2130000, 0x2132000, 0x126000},\n\t\t{1, 0x2140000, 0x2142000, 0x128000},\n\t\t{1, 0x2150000, 0x2152000, 0x12a000},\n\t\t{1, 0x2160000, 0x2170000, 0x110000},\n\t\t{1, 0x2170000, 0x2172000, 0x12e000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000},\n\t\t{0, 0x0000000, 0x0000000, 0x000000} } },\n\t{{{1, 0x2200000, 0x2204000, 0x1b0000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x2800000, 0x2804000, 0x1a4000} } }, \n\t{{{1, 0x2900000, 0x2901000, 0x16b000} } }, \n\t{{{1, 0x2a00000, 0x2a00400, 0x1ac400} } }, \n\t{{{1, 0x2b00000, 0x2b00400, 0x1ac800} } }, \n\t{{{1, 0x2c00000, 0x2c00400, 0x1acc00} } }, \n\t{{{1, 0x2d00000, 0x2d00400, 0x1ad000} } }, \n\t{{{1, 0x2e00000, 0x2e00400, 0x1ad400} } }, \n\t{{{1, 0x2f00000, 0x2f00400, 0x1ad800} } }, \n\t{{{1, 0x3000000, 0x3000400, 0x1adc00} } }, \n\t{{{0, 0x3100000, 0x3104000, 0x1a8000} } }, \n\t{{{1, 0x3200000, 0x3204000, 0x1d4000} } }, \n\t{{{1, 0x3300000, 0x3304000, 0x1a0000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x3500000, 0x3500400, 0x1ac000} } }, \n\t{{{1, 0x3600000, 0x3600400, 0x1ae000} } }, \n\t{{{1, 0x3700000, 0x3700400, 0x1ae400} } }, \n\t{{{1, 0x3800000, 0x3804000, 0x1d0000} } }, \n\t{{{1, 0x3900000, 0x3904000, 0x1b4000} } }, \n\t{{{1, 0x3a00000, 0x3a04000, 0x1d8000} } }, \n\t{{{0} } },\t\t\t\t \n\t{{{0} } },\t\t\t\t \n\t{{{1, 0x3d00000, 0x3d04000, 0x1dc000} } }, \n\t{{{1, 0x3e00000, 0x3e01000, 0x167000} } }, \n\t{{{1, 0x3f00000, 0x3f01000, 0x168000} } }\t \n};\n\n \nstatic unsigned qla4_82xx_crb_hub_agt[64] = {\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PS,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_MN,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_MS,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SRE,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_NIU,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_QMN,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SQN0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SQN1,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SQN2,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SQN3,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_I2Q,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_TIMR,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_ROMUSB,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN4,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_XDMA,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN1,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN2,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGN3,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGND,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGNI,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGS0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGS1,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGS2,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGS3,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGSI,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SN,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_EG,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PS,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_CAM,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_TIMR,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX1,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX2,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX3,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX4,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX5,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX6,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX7,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_XDMA,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_I2Q,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_ROMUSB,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX8,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_RPMX9,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_OCM0,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_SMB,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_I2C0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_I2C1,\n\t0,\n\tQLA82XX_HW_CRB_HUB_AGT_ADR_PGNC,\n\t0,\n};\n\n \nstatic char *qdev_state[] = {\n\t\"Unknown\",\n\t\"Cold\",\n\t\"Initializing\",\n\t\"Ready\",\n\t\"Need Reset\",\n\t\"Need Quiescent\",\n\t\"Failed\",\n\t\"Quiescent\",\n};\n\n \nstatic void\nqla4_82xx_pci_set_crbwindow_2M(struct scsi_qla_host *ha, ulong *off)\n{\n\tu32 win_read;\n\n\tha->crb_win = CRB_HI(*off);\n\twritel(ha->crb_win,\n\t\t(void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\n\n\t \n\twin_read = readl((void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\n\tif (win_read != ha->crb_win) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t    \"%s: Written crbwin (0x%x) != Read crbwin (0x%x),\"\n\t\t    \" off=0x%lx\\n\", __func__, ha->crb_win, win_read, *off));\n\t}\n\t*off = (*off & MASK(16)) + CRB_INDIRECT_2M + ha->nx_pcibase;\n}\n\n#define CRB_WIN_LOCK_TIMEOUT 100000000\n\n \nstatic int qla4_82xx_crb_win_lock(struct scsi_qla_host *ha)\n{\n\tint done = 0, timeout = 0;\n\n\twhile (!done) {\n\t\t \n\t\tdone = qla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_LOCK));\n\t\tif (done == 1)\n\t\t\tbreak;\n\t\tif (timeout >= CRB_WIN_LOCK_TIMEOUT)\n\t\t\treturn -1;\n\n\t\ttimeout++;\n\t\tudelay(10);\n\t}\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_WIN_LOCK_ID, ha->func_num);\n\treturn 0;\n}\n\nvoid qla4_82xx_crb_win_unlock(struct scsi_qla_host *ha)\n{\n\tqla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM7_UNLOCK));\n}\n\nvoid\nqla4_82xx_wr_32(struct scsi_qla_host *ha, ulong off, u32 data)\n{\n\tunsigned long flags = 0;\n\tint rv;\n\n\trv = qla4_82xx_pci_get_crb_addr_2M(ha, &off);\n\n\tBUG_ON(rv == -1);\n\n\tif (rv == 1) {\n\t\twrite_lock_irqsave(&ha->hw_lock, flags);\n\t\tqla4_82xx_crb_win_lock(ha);\n\t\tqla4_82xx_pci_set_crbwindow_2M(ha, &off);\n\t}\n\n\twritel(data, (void __iomem *)off);\n\n\tif (rv == 1) {\n\t\tqla4_82xx_crb_win_unlock(ha);\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t}\n}\n\nuint32_t qla4_82xx_rd_32(struct scsi_qla_host *ha, ulong off)\n{\n\tunsigned long flags = 0;\n\tint rv;\n\tu32 data;\n\n\trv = qla4_82xx_pci_get_crb_addr_2M(ha, &off);\n\n\tBUG_ON(rv == -1);\n\n\tif (rv == 1) {\n\t\twrite_lock_irqsave(&ha->hw_lock, flags);\n\t\tqla4_82xx_crb_win_lock(ha);\n\t\tqla4_82xx_pci_set_crbwindow_2M(ha, &off);\n\t}\n\tdata = readl((void __iomem *)off);\n\n\tif (rv == 1) {\n\t\tqla4_82xx_crb_win_unlock(ha);\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t}\n\treturn data;\n}\n\n \nint qla4_82xx_md_rd_32(struct scsi_qla_host *ha, uint32_t off, uint32_t *data)\n{\n\tuint32_t win_read, off_value;\n\tint rval = QLA_SUCCESS;\n\n\toff_value  = off & 0xFFFF0000;\n\twritel(off_value, (void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\n\n\t \n\twin_read = readl((void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\n\tif (win_read != off_value) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: Written (0x%x) != Read (0x%x), off=0x%x\\n\",\n\t\t\t\t  __func__, off_value, win_read, off));\n\t\trval = QLA_ERROR;\n\t} else {\n\t\toff_value  = off & 0x0000FFFF;\n\t\t*data = readl((void __iomem *)(off_value + CRB_INDIRECT_2M +\n\t\t\t\t\t       ha->nx_pcibase));\n\t}\n\treturn rval;\n}\n\nint qla4_82xx_md_wr_32(struct scsi_qla_host *ha, uint32_t off, uint32_t data)\n{\n\tuint32_t win_read, off_value;\n\tint rval = QLA_SUCCESS;\n\n\toff_value  = off & 0xFFFF0000;\n\twritel(off_value, (void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\n\n\t \n\twin_read = readl((void __iomem *)(CRB_WINDOW_2M + ha->nx_pcibase));\n\tif (win_read != off_value) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: Written (0x%x) != Read (0x%x), off=0x%x\\n\",\n\t\t\t\t  __func__, off_value, win_read, off));\n\t\trval = QLA_ERROR;\n\t} else {\n\t\toff_value  = off & 0x0000FFFF;\n\t\twritel(data, (void __iomem *)(off_value + CRB_INDIRECT_2M +\n\t\t\t\t\t      ha->nx_pcibase));\n\t}\n\treturn rval;\n}\n\n#define IDC_LOCK_TIMEOUT 100000000\n\n \nint qla4_82xx_idc_lock(struct scsi_qla_host *ha)\n{\n\tint done = 0, timeout = 0;\n\n\tmight_sleep();\n\n\twhile (!done) {\n\t\t \n\t\tdone = qla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_LOCK));\n\t\tif (done == 1)\n\t\t\tbreak;\n\t\tif (timeout >= IDC_LOCK_TIMEOUT)\n\t\t\treturn -1;\n\n\t\ttimeout++;\n\t\tmsleep(100);\n\t}\n\treturn 0;\n}\n\nvoid qla4_82xx_idc_unlock(struct scsi_qla_host *ha)\n{\n\tqla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM5_UNLOCK));\n}\n\nint\nqla4_82xx_pci_get_crb_addr_2M(struct scsi_qla_host *ha, ulong *off)\n{\n\tstruct crb_128M_2M_sub_block_map *m;\n\n\tif (*off >= QLA82XX_CRB_MAX)\n\t\treturn -1;\n\n\tif (*off >= QLA82XX_PCI_CAMQM && (*off < QLA82XX_PCI_CAMQM_2M_END)) {\n\t\t*off = (*off - QLA82XX_PCI_CAMQM) +\n\t\t    QLA82XX_PCI_CAMQM_2M_BASE + ha->nx_pcibase;\n\t\treturn 0;\n\t}\n\n\tif (*off < QLA82XX_PCI_CRBSPACE)\n\t\treturn -1;\n\n\t*off -= QLA82XX_PCI_CRBSPACE;\n\t \n\n\tm = &crb_128M_2M_map[CRB_BLK(*off)].sub_block[CRB_SUBBLK(*off)];\n\n\tif (m->valid && (m->start_128M <= *off) && (m->end_128M > *off)) {\n\t\t*off = *off + m->start_2M - m->start_128M + ha->nx_pcibase;\n\t\treturn 0;\n\t}\n\n\t \n\treturn 1;\n}\n\n \nstatic unsigned long\nqla4_82xx_pci_mem_bound_check(struct scsi_qla_host *ha,\n\t\tunsigned long long addr, int size)\n{\n\tif (!QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_DDR_NET,\n\t    QLA8XXX_ADDR_DDR_NET_MAX) ||\n\t    !QLA8XXX_ADDR_IN_RANGE(addr + size - 1,\n\t    QLA8XXX_ADDR_DDR_NET, QLA8XXX_ADDR_DDR_NET_MAX) ||\n\t    ((size != 1) && (size != 2) && (size != 4) && (size != 8))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int qla4_82xx_pci_set_window_warning_count;\n\nstatic unsigned long\nqla4_82xx_pci_set_window(struct scsi_qla_host *ha, unsigned long long addr)\n{\n\tint window;\n\tu32 win_read;\n\n\tif (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_DDR_NET,\n\t    QLA8XXX_ADDR_DDR_NET_MAX)) {\n\t\t \n\t\twindow = MN_WIN(addr);\n\t\tha->ddr_mn_window = window;\n\t\tqla4_82xx_wr_32(ha, ha->mn_win_crb |\n\t\t    QLA82XX_PCI_CRBSPACE, window);\n\t\twin_read = qla4_82xx_rd_32(ha, ha->mn_win_crb |\n\t\t    QLA82XX_PCI_CRBSPACE);\n\t\tif ((win_read << 17) != window) {\n\t\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t\"%s: Written MNwin (0x%x) != Read MNwin (0x%x)\\n\",\n\t\t\t__func__, window, win_read);\n\t\t}\n\t\taddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_DDR_NET;\n\t} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_OCM0,\n\t\t\t\tQLA8XXX_ADDR_OCM0_MAX)) {\n\t\tunsigned int temp1;\n\t\t \n\t\tif ((addr & 0x00ff800) == 0xff800) {\n\t\t\tprintk(\"%s: QM access not handled.\\n\", __func__);\n\t\t\taddr = -1UL;\n\t\t}\n\n\t\twindow = OCM_WIN(addr);\n\t\tha->ddr_mn_window = window;\n\t\tqla4_82xx_wr_32(ha, ha->mn_win_crb |\n\t\t    QLA82XX_PCI_CRBSPACE, window);\n\t\twin_read = qla4_82xx_rd_32(ha, ha->mn_win_crb |\n\t\t    QLA82XX_PCI_CRBSPACE);\n\t\ttemp1 = ((window & 0x1FF) << 7) |\n\t\t    ((window & 0x0FFFE0000) >> 17);\n\t\tif (win_read != temp1) {\n\t\t\tprintk(\"%s: Written OCMwin (0x%x) != Read\"\n\t\t\t    \" OCMwin (0x%x)\\n\", __func__, temp1, win_read);\n\t\t}\n\t\taddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_OCM0_2M;\n\n\t} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_QDR_NET,\n\t\t\t\tQLA82XX_P3_ADDR_QDR_NET_MAX)) {\n\t\t \n\t\twindow = MS_WIN(addr);\n\t\tha->qdr_sn_window = window;\n\t\tqla4_82xx_wr_32(ha, ha->ms_win_crb |\n\t\t    QLA82XX_PCI_CRBSPACE, window);\n\t\twin_read = qla4_82xx_rd_32(ha,\n\t\t     ha->ms_win_crb | QLA82XX_PCI_CRBSPACE);\n\t\tif (win_read != window) {\n\t\t\tprintk(\"%s: Written MSwin (0x%x) != Read \"\n\t\t\t    \"MSwin (0x%x)\\n\", __func__, window, win_read);\n\t\t}\n\t\taddr = GET_MEM_OFFS_2M(addr) + QLA82XX_PCI_QDR_NET;\n\n\t} else {\n\t\t \n\t\tif ((qla4_82xx_pci_set_window_warning_count++ < 8) ||\n\t\t    (qla4_82xx_pci_set_window_warning_count%64 == 0)) {\n\t\t\tprintk(\"%s: Warning:%s Unknown address range!\\n\",\n\t\t\t    __func__, DRIVER_NAME);\n\t\t}\n\t\taddr = -1UL;\n\t}\n\treturn addr;\n}\n\n \nstatic int qla4_82xx_pci_is_same_window(struct scsi_qla_host *ha,\n\t\tunsigned long long addr)\n{\n\tint window;\n\tunsigned long long qdr_max;\n\n\tqdr_max = QLA82XX_P3_ADDR_QDR_NET_MAX;\n\n\tif (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_DDR_NET,\n\t    QLA8XXX_ADDR_DDR_NET_MAX)) {\n\t\t \n\t\tBUG();\t \n\t} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_OCM0,\n\t     QLA8XXX_ADDR_OCM0_MAX)) {\n\t\treturn 1;\n\t} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_OCM1,\n\t     QLA8XXX_ADDR_OCM1_MAX)) {\n\t\treturn 1;\n\t} else if (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_QDR_NET,\n\t    qdr_max)) {\n\t\t \n\t\twindow = ((addr - QLA8XXX_ADDR_QDR_NET) >> 22) & 0x3f;\n\t\tif (ha->qdr_sn_window == window)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int qla4_82xx_pci_mem_read_direct(struct scsi_qla_host *ha,\n\t\tu64 off, void *data, int size)\n{\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tint ret = 0;\n\tu64 start;\n\tvoid __iomem *mem_ptr = NULL;\n\tunsigned long mem_base;\n\tunsigned long mem_page;\n\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\n\t \n\tstart = qla4_82xx_pci_set_window(ha, off);\n\tif ((start == -1UL) ||\n\t    (qla4_82xx_pci_is_same_window(ha, off + size - 1) == 0)) {\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\tprintk(KERN_ERR\"%s out of bound pci memory access. \"\n\t\t\t\t\"offset is 0x%llx\\n\", DRIVER_NAME, off);\n\t\treturn -1;\n\t}\n\n\taddr = qla4_8xxx_pci_base_offsetfset(ha, start);\n\tif (!addr) {\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\tmem_base = pci_resource_start(ha->pdev, 0);\n\t\tmem_page = start & PAGE_MASK;\n\t\t \n\t\tif (mem_page != ((start + size - 1) & PAGE_MASK))\n\t\t\tmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE * 2);\n\t\telse\n\t\t\tmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\n\n\t\tif (mem_ptr == NULL) {\n\t\t\t*(u8 *)data = 0;\n\t\t\treturn -1;\n\t\t}\n\t\taddr = mem_ptr;\n\t\taddr += start & (PAGE_SIZE - 1);\n\t\twrite_lock_irqsave(&ha->hw_lock, flags);\n\t}\n\n\tswitch (size) {\n\tcase 1:\n\t\t*(u8  *)data = readb(addr);\n\t\tbreak;\n\tcase 2:\n\t\t*(u16 *)data = readw(addr);\n\t\tbreak;\n\tcase 4:\n\t\t*(u32 *)data = readl(addr);\n\t\tbreak;\n\tcase 8:\n\t\t*(u64 *)data = readq(addr);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\n\tif (mem_ptr)\n\t\tiounmap(mem_ptr);\n\treturn ret;\n}\n\nstatic int\nqla4_82xx_pci_mem_write_direct(struct scsi_qla_host *ha, u64 off,\n\t\tvoid *data, int size)\n{\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tint ret = 0;\n\tu64 start;\n\tvoid __iomem *mem_ptr = NULL;\n\tunsigned long mem_base;\n\tunsigned long mem_page;\n\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\n\t \n\tstart = qla4_82xx_pci_set_window(ha, off);\n\tif ((start == -1UL) ||\n\t    (qla4_82xx_pci_is_same_window(ha, off + size - 1) == 0)) {\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\tprintk(KERN_ERR\"%s out of bound pci memory access. \"\n\t\t\t\t\"offset is 0x%llx\\n\", DRIVER_NAME, off);\n\t\treturn -1;\n\t}\n\n\taddr = qla4_8xxx_pci_base_offsetfset(ha, start);\n\tif (!addr) {\n\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\tmem_base = pci_resource_start(ha->pdev, 0);\n\t\tmem_page = start & PAGE_MASK;\n\t\t \n\t\tif (mem_page != ((start + size - 1) & PAGE_MASK))\n\t\t\tmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE*2);\n\t\telse\n\t\t\tmem_ptr = ioremap(mem_base + mem_page, PAGE_SIZE);\n\t\tif (mem_ptr == NULL)\n\t\t\treturn -1;\n\n\t\taddr = mem_ptr;\n\t\taddr += start & (PAGE_SIZE - 1);\n\t\twrite_lock_irqsave(&ha->hw_lock, flags);\n\t}\n\n\tswitch (size) {\n\tcase 1:\n\t\twriteb(*(u8 *)data, addr);\n\t\tbreak;\n\tcase 2:\n\t\twritew(*(u16 *)data, addr);\n\t\tbreak;\n\tcase 4:\n\t\twritel(*(u32 *)data, addr);\n\t\tbreak;\n\tcase 8:\n\t\twriteq(*(u64 *)data, addr);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\tif (mem_ptr)\n\t\tiounmap(mem_ptr);\n\treturn ret;\n}\n\n#define MTU_FUDGE_FACTOR 100\n\nstatic unsigned long\nqla4_82xx_decode_crb_addr(unsigned long addr)\n{\n\tint i;\n\tunsigned long base_addr, offset, pci_base;\n\n\tif (!qla4_8xxx_crb_table_initialized)\n\t\tqla4_82xx_crb_addr_transform_setup();\n\n\tpci_base = ADDR_ERROR;\n\tbase_addr = addr & 0xfff00000;\n\toffset = addr & 0x000fffff;\n\n\tfor (i = 0; i < MAX_CRB_XFORM; i++) {\n\t\tif (crb_addr_xform[i] == base_addr) {\n\t\t\tpci_base = i << 20;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pci_base == ADDR_ERROR)\n\t\treturn pci_base;\n\telse\n\t\treturn pci_base + offset;\n}\n\nstatic long rom_max_timeout = 100;\nstatic long qla4_82xx_rom_lock_timeout = 100;\n\n \nstatic int\nqla4_82xx_rom_lock(struct scsi_qla_host *ha)\n{\n\tint done = 0, timeout = 0;\n\n\tmight_sleep();\n\n\twhile (!done) {\n\t\t \n\t\tdone = qla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_LOCK));\n\t\tif (done == 1)\n\t\t\tbreak;\n\t\tif (timeout >= qla4_82xx_rom_lock_timeout)\n\t\t\treturn -1;\n\n\t\ttimeout++;\n\t\tmsleep(20);\n\t}\n\tqla4_82xx_wr_32(ha, QLA82XX_ROM_LOCK_ID, ROM_LOCK_DRIVER);\n\treturn 0;\n}\n\nstatic void\nqla4_82xx_rom_unlock(struct scsi_qla_host *ha)\n{\n\tqla4_82xx_rd_32(ha, QLA82XX_PCIE_REG(PCIE_SEM2_UNLOCK));\n}\n\nstatic int\nqla4_82xx_wait_rom_done(struct scsi_qla_host *ha)\n{\n\tlong timeout = 0;\n\tlong done = 0 ;\n\n\twhile (done == 0) {\n\t\tdone = qla4_82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_STATUS);\n\t\tdone &= 2;\n\t\ttimeout++;\n\t\tif (timeout >= rom_max_timeout) {\n\t\t\tprintk(\"%s: Timeout reached  waiting for rom done\",\n\t\t\t\t\tDRIVER_NAME);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nqla4_82xx_do_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)\n{\n\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ADDRESS, addr);\n\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 3);\n\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_INSTR_OPCODE, 0xb);\n\tif (qla4_82xx_wait_rom_done(ha)) {\n\t\tprintk(\"%s: Error waiting for rom done\\n\", DRIVER_NAME);\n\t\treturn -1;\n\t}\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_DUMMY_BYTE_CNT, 0);\n\tudelay(10);\n\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_ROM_ABYTE_CNT, 0);\n\n\t*valp = qla4_82xx_rd_32(ha, QLA82XX_ROMUSB_ROM_RDATA);\n\treturn 0;\n}\n\nstatic int\nqla4_82xx_rom_fast_read(struct scsi_qla_host *ha, int addr, int *valp)\n{\n\tint ret, loops = 0;\n\n\twhile ((qla4_82xx_rom_lock(ha) != 0) && (loops < 50000)) {\n\t\tudelay(100);\n\t\tloops++;\n\t}\n\tif (loops >= 50000) {\n\t\tql4_printk(KERN_WARNING, ha, \"%s: qla4_82xx_rom_lock failed\\n\",\n\t\t\t   DRIVER_NAME);\n\t\treturn -1;\n\t}\n\tret = qla4_82xx_do_rom_fast_read(ha, addr, valp);\n\tqla4_82xx_rom_unlock(ha);\n\treturn ret;\n}\n\n \nstatic int\nqla4_82xx_pinit_from_rom(struct scsi_qla_host *ha, int verbose)\n{\n\tint addr, val;\n\tint i ;\n\tstruct crb_addr_pair *buf;\n\tunsigned long off;\n\tunsigned offset, n;\n\n\tstruct crb_addr_pair {\n\t\tlong addr;\n\t\tlong data;\n\t};\n\n\t \n\tqla4_82xx_rom_lock(ha);\n\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x10, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x14, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x18, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x1c, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x20, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_I2Q + 0x24, 0x0);\n\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x40, 0xff);\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x70000, 0x00);\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x80000, 0x00);\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x90000, 0x00);\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xa0000, 0x00);\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0xb0000, 0x00);\n\n\t \n\tval = qla4_82xx_rd_32(ha, QLA82XX_CRB_SRE + 0x1000);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_SRE + 0x1000, val & (~(0x1)));\n\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_EPG + 0x1300, 0x1);\n\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x0, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x8, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x10, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x18, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x100, 0x0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_TIMER + 0x200, 0x0);\n\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x3c, 1);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1 + 0x3c, 1);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2 + 0x3c, 1);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3 + 0x3c, 1);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_4 + 0x3c, 1);\n\tmsleep(5);\n\n\t \n\tif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\n\t\t \n\t\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xfeffffff);\n\telse\n\t\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0xffffffff);\n\n\tqla4_82xx_rom_unlock(ha);\n\n\t \n\tif (qla4_82xx_rom_fast_read(ha, 0, &n) != 0 || n != 0xcafecafeUL ||\n\t    qla4_82xx_rom_fast_read(ha, 4, &n) != 0) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t\"[ERROR] Reading crb_init area: n: %08x\\n\", n);\n\t\treturn -1;\n\t}\n\n\t \n\toffset = n & 0xffffU;\n\tn = (n >> 16) & 0xffffU;\n\n\t \n\tif (n  >= 1024) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"%s: %s:n=0x%x [ERROR] Card flash not initialized.\\n\",\n\t\t    DRIVER_NAME, __func__, n);\n\t\treturn -1;\n\t}\n\n\tql4_printk(KERN_INFO, ha,\n\t\t\"%s: %d CRB init values found in ROM.\\n\", DRIVER_NAME, n);\n\n\tbuf = kmalloc_array(n, sizeof(struct crb_addr_pair), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"%s: [ERROR] Unable to malloc memory.\\n\", DRIVER_NAME);\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (qla4_82xx_rom_fast_read(ha, 8*i + 4*offset, &val) != 0 ||\n\t\t    qla4_82xx_rom_fast_read(ha, 8*i + 4*offset + 4, &addr) !=\n\t\t    0) {\n\t\t\tkfree(buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf[i].addr = addr;\n\t\tbuf[i].data = val;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\t \n\t\toff = qla4_82xx_decode_crb_addr((unsigned long)buf[i].addr) +\n\t\t    QLA82XX_PCI_CRBSPACE;\n\t\t \n\n\t\t \n\t\tif (off & 0x1) {\n\t\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t    \"Skip CRB init replay for offset = 0x%lx\\n\", off));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (off == QLA82XX_CAM_RAM(0x1fc))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (off == (ROMUSB_GLB + 0xbc))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (off == (ROMUSB_GLB + 0xc8))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION))\n\t\t\tcontinue;\n\n\t\tif (off == QLA82XX_PCIE_REG(PCIE_SETUP_FUNCTION2))\n\t\t\tcontinue;\n\n\t\tif ((off & 0x0ff00000) == QLA82XX_CRB_SMB)\n\t\t\tcontinue;\n\n\t\tif ((off & 0x0ff00000) == QLA82XX_CRB_DDR_NET)\n\t\t\tcontinue;\n\n\t\tif (off == ADDR_ERROR) {\n\t\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t    \"%s: [ERROR] Unknown addr: 0x%08lx\\n\",\n\t\t\t    DRIVER_NAME, buf[i].addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tqla4_82xx_wr_32(ha, off, buf[i].data);\n\n\t\t \n\t\tif (off == QLA82XX_ROMUSB_GLB_SW_RESET)\n\t\t\tmsleep(1000);\n\n\t\t \n\t\tmsleep(1);\n\t}\n\n\tkfree(buf);\n\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0xec, 0x1e);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_D+0x4c, 8);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_I+0x4c, 8);\n\n\t \n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0x8, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0+0xc, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0x8, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_1+0xc, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0x8, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_2+0xc, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0x8, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_3+0xc, 0);\n\n\treturn 0;\n}\n\n \nint qla4_8xxx_ms_mem_write_128b(struct scsi_qla_host *ha, uint64_t addr,\n\t\t\t\tuint32_t *data, uint32_t count)\n{\n\tint i, j;\n\tuint32_t agt_ctrl;\n\tunsigned long flags;\n\tint ret_val = QLA_SUCCESS;\n\n\t \n\tif (addr & 0xF) {\n\t\tret_val = QLA_ERROR;\n\t\tgoto exit_ms_mem_write;\n\t}\n\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\n\t \n\tret_val = ha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_ADDR_HI, 0);\n\tif (ret_val == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: write to AGT_ADDR_HI failed\\n\",\n\t\t\t   __func__);\n\t\tgoto exit_ms_mem_write_unlock;\n\t}\n\n\tfor (i = 0; i < count; i++, addr += 16) {\n\t\tif (!((QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_QDR_NET,\n\t\t\t\t\t     QLA8XXX_ADDR_QDR_NET_MAX)) ||\n\t\t      (QLA8XXX_ADDR_IN_RANGE(addr, QLA8XXX_ADDR_DDR_NET,\n\t\t\t\t\t     QLA8XXX_ADDR_DDR_NET_MAX)))) {\n\t\t\tret_val = QLA_ERROR;\n\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t}\n\n\t\tret_val = ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t\t\t\t       MD_MIU_TEST_AGT_ADDR_LO,\n\t\t\t\t\t\t       addr);\n\t\t \n\t\tret_val |= ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t\t\t\tMD_MIU_TEST_AGT_WRDATA_LO,\n\t\t\t\t\t\t*data++);\n\t\tret_val |= ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t\t\t\tMD_MIU_TEST_AGT_WRDATA_HI,\n\t\t\t\t\t\t*data++);\n\t\tret_val |= ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t\t\t\tMD_MIU_TEST_AGT_WRDATA_ULO,\n\t\t\t\t\t\t*data++);\n\t\tret_val |= ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t\t\t\tMD_MIU_TEST_AGT_WRDATA_UHI,\n\t\t\t\t\t\t*data++);\n\t\tif (ret_val == QLA_ERROR) {\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: write to AGT_WRDATA failed\\n\",\n\t\t\t\t   __func__);\n\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t}\n\n\t\t \n\t\tret_val = ha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_CTRL,\n\t\t\t\t\t\t       MIU_TA_CTL_WRITE_ENABLE);\n\t\tret_val |= ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t\t\t\t\tMD_MIU_TEST_AGT_CTRL,\n\t\t\t\t\t\t\tMIU_TA_CTL_WRITE_START);\n\t\tif (ret_val == QLA_ERROR) {\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: write to AGT_CTRL failed\\n\",\n\t\t\t\t   __func__);\n\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t}\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\tret_val = ha->isp_ops->rd_reg_indirect(ha,\n\t\t\t\t\t\t\tMD_MIU_TEST_AGT_CTRL,\n\t\t\t\t\t\t\t&agt_ctrl);\n\t\t\tif (ret_val == QLA_ERROR) {\n\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: failed to read MD_MIU_TEST_AGT_CTRL\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t\t}\n\t\t\tif ((agt_ctrl & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tprintk_ratelimited(KERN_ERR \"%s: MS memory write failed!\\n\",\n\t\t\t\t\t   __func__);\n\t\t\tret_val = QLA_ERROR;\n\t\t\tgoto exit_ms_mem_write_unlock;\n\t\t}\n\t}\n\nexit_ms_mem_write_unlock:\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\nexit_ms_mem_write:\n\treturn ret_val;\n}\n\nstatic int\nqla4_82xx_load_from_flash(struct scsi_qla_host *ha, uint32_t image_start)\n{\n\tint  i, rval = 0;\n\tlong size = 0;\n\tlong flashaddr, memaddr;\n\tu64 data;\n\tu32 high, low;\n\n\tflashaddr = memaddr = ha->hw.flt_region_bootload;\n\tsize = (image_start - flashaddr) / 8;\n\n\tDEBUG2(printk(\"scsi%ld: %s: bootldr=0x%lx, fw_image=0x%x\\n\",\n\t    ha->host_no, __func__, flashaddr, image_start));\n\n\tfor (i = 0; i < size; i++) {\n\t\tif ((qla4_82xx_rom_fast_read(ha, flashaddr, (int *)&low)) ||\n\t\t    (qla4_82xx_rom_fast_read(ha, flashaddr + 4,\n\t\t    (int *)&high))) {\n\t\t\trval = -1;\n\t\t\tgoto exit_load_from_flash;\n\t\t}\n\t\tdata = ((u64)high << 32) | low ;\n\t\trval = qla4_82xx_pci_mem_write_2M(ha, memaddr, &data, 8);\n\t\tif (rval)\n\t\t\tgoto exit_load_from_flash;\n\n\t\tflashaddr += 8;\n\t\tmemaddr   += 8;\n\n\t\tif (i % 0x1000 == 0)\n\t\t\tmsleep(1);\n\n\t}\n\n\tudelay(100);\n\n\tread_lock(&ha->hw_lock);\n\tqla4_82xx_wr_32(ha, QLA82XX_CRB_PEG_NET_0 + 0x18, 0x1020);\n\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, 0x80001e);\n\tread_unlock(&ha->hw_lock);\n\nexit_load_from_flash:\n\treturn rval;\n}\n\nstatic int qla4_82xx_load_fw(struct scsi_qla_host *ha, uint32_t image_start)\n{\n\tu32 rst;\n\n\tqla4_82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);\n\tif (qla4_82xx_pinit_from_rom(ha, 0) != QLA_SUCCESS) {\n\t\tprintk(KERN_WARNING \"%s: Error during CRB Initialization\\n\",\n\t\t    __func__);\n\t\treturn QLA_ERROR;\n\t}\n\n\tudelay(500);\n\n\t \n\n\trst = qla4_82xx_rd_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET);\n\t \n\trst &= ~(1 << 28);\n\tqla4_82xx_wr_32(ha, QLA82XX_ROMUSB_GLB_SW_RESET, rst);\n\n\tif (qla4_82xx_load_from_flash(ha, image_start)) {\n\t\tprintk(\"%s: Error trying to load fw from flash!\\n\", __func__);\n\t\treturn QLA_ERROR;\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\nint\nqla4_82xx_pci_mem_read_2M(struct scsi_qla_host *ha,\n\t\tu64 off, void *data, int size)\n{\n\tint i, j = 0, k, start, end, loop, sz[2], off0[2];\n\tint shift_amount;\n\tuint32_t temp;\n\tuint64_t off8, val, mem_crb, word[2] = {0, 0};\n\n\t \n\n\tif (off >= QLA8XXX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\n\t\tmem_crb = QLA82XX_CRB_QDR_NET;\n\telse {\n\t\tmem_crb = QLA82XX_CRB_DDR_NET;\n\t\tif (qla4_82xx_pci_mem_bound_check(ha, off, size) == 0)\n\t\t\treturn qla4_82xx_pci_mem_read_direct(ha,\n\t\t\t\t\toff, data, size);\n\t}\n\n\n\toff8 = off & 0xfffffff0;\n\toff0[0] = off & 0xf;\n\tsz[0] = (size < (16 - off0[0])) ? size : (16 - off0[0]);\n\tshift_amount = 4;\n\n\tloop = ((off0[0] + size - 1) >> shift_amount) + 1;\n\toff0[1] = 0;\n\tsz[1] = size - sz[0];\n\n\tfor (i = 0; i < loop; i++) {\n\t\ttemp = off8 + (i << shift_amount);\n\t\tqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_LO, temp);\n\t\ttemp = 0;\n\t\tqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_ADDR_HI, temp);\n\t\ttemp = MIU_TA_CTL_ENABLE;\n\t\tqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\n\t\ttemp = MIU_TA_CTL_START_ENABLE;\n\t\tqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_CTRL, temp);\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\ttemp = qla4_82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\n\t\t\tif ((temp & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\t   \"%s: failed to read through agent\\n\",\n\t\t\t\t\t   __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tstart = off0[i] >> 2;\n\t\tend   = (off0[i] + sz[i] - 1) >> 2;\n\t\tfor (k = start; k <= end; k++) {\n\t\t\ttemp = qla4_82xx_rd_32(ha,\n\t\t\t\tmem_crb + MIU_TEST_AGT_RDDATA(k));\n\t\t\tword[i] |= ((uint64_t)temp << (32 * (k & 1)));\n\t\t}\n\t}\n\n\tif (j >= MAX_CTL_CHECK)\n\t\treturn -1;\n\n\tif ((off0[0] & 7) == 0) {\n\t\tval = word[0];\n\t} else {\n\t\tval = ((word[0] >> (off0[0] * 8)) & (~(~0ULL << (sz[0] * 8)))) |\n\t\t((word[1] & (~(~0ULL << (sz[1] * 8)))) << (sz[0] * 8));\n\t}\n\n\tswitch (size) {\n\tcase 1:\n\t\t*(uint8_t  *)data = val;\n\t\tbreak;\n\tcase 2:\n\t\t*(uint16_t *)data = val;\n\t\tbreak;\n\tcase 4:\n\t\t*(uint32_t *)data = val;\n\t\tbreak;\n\tcase 8:\n\t\t*(uint64_t *)data = val;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nint\nqla4_82xx_pci_mem_write_2M(struct scsi_qla_host *ha,\n\t\tu64 off, void *data, int size)\n{\n\tint i, j, ret = 0, loop, sz[2], off0;\n\tint scale, shift_amount, startword;\n\tuint32_t temp;\n\tuint64_t off8, mem_crb, tmpw, word[2] = {0, 0};\n\n\t \n\tif (off >= QLA8XXX_ADDR_QDR_NET && off <= QLA82XX_P3_ADDR_QDR_NET_MAX)\n\t\tmem_crb = QLA82XX_CRB_QDR_NET;\n\telse {\n\t\tmem_crb = QLA82XX_CRB_DDR_NET;\n\t\tif (qla4_82xx_pci_mem_bound_check(ha, off, size) == 0)\n\t\t\treturn qla4_82xx_pci_mem_write_direct(ha,\n\t\t\t\t\toff, data, size);\n\t}\n\n\toff0 = off & 0x7;\n\tsz[0] = (size < (8 - off0)) ? size : (8 - off0);\n\tsz[1] = size - sz[0];\n\n\toff8 = off & 0xfffffff0;\n\tloop = (((off & 0xf) + size - 1) >> 4) + 1;\n\tshift_amount = 4;\n\tscale = 2;\n\tstartword = (off & 0xf)/8;\n\n\tfor (i = 0; i < loop; i++) {\n\t\tif (qla4_82xx_pci_mem_read_2M(ha, off8 +\n\t\t    (i << shift_amount), &word[i * scale], 8))\n\t\t\treturn -1;\n\t}\n\n\tswitch (size) {\n\tcase 1:\n\t\ttmpw = *((uint8_t *)data);\n\t\tbreak;\n\tcase 2:\n\t\ttmpw = *((uint16_t *)data);\n\t\tbreak;\n\tcase 4:\n\t\ttmpw = *((uint32_t *)data);\n\t\tbreak;\n\tcase 8:\n\tdefault:\n\t\ttmpw = *((uint64_t *)data);\n\t\tbreak;\n\t}\n\n\tif (sz[0] == 8)\n\t\tword[startword] = tmpw;\n\telse {\n\t\tword[startword] &=\n\t\t    ~((~(~0ULL << (sz[0] * 8))) << (off0 * 8));\n\t\tword[startword] |= tmpw << (off0 * 8);\n\t}\n\n\tif (sz[1] != 0) {\n\t\tword[startword+1] &= ~(~0ULL << (sz[1] * 8));\n\t\tword[startword+1] |= tmpw >> (sz[0] * 8);\n\t}\n\n\tfor (i = 0; i < loop; i++) {\n\t\ttemp = off8 + (i << shift_amount);\n\t\tqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_LO, temp);\n\t\ttemp = 0;\n\t\tqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_ADDR_HI, temp);\n\t\ttemp = word[i * scale] & 0xffffffff;\n\t\tqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_LO, temp);\n\t\ttemp = (word[i * scale] >> 32) & 0xffffffff;\n\t\tqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_WRDATA_HI, temp);\n\t\ttemp = word[i*scale + 1] & 0xffffffff;\n\t\tqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_LO,\n\t\t    temp);\n\t\ttemp = (word[i*scale + 1] >> 32) & 0xffffffff;\n\t\tqla4_82xx_wr_32(ha, mem_crb + MIU_TEST_AGT_WRDATA_UPPER_HI,\n\t\t    temp);\n\n\t\ttemp = MIU_TA_CTL_WRITE_ENABLE;\n\t\tqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_CTRL, temp);\n\t\ttemp = MIU_TA_CTL_WRITE_START;\n\t\tqla4_82xx_wr_32(ha, mem_crb+MIU_TEST_AGT_CTRL, temp);\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\ttemp = qla4_82xx_rd_32(ha, mem_crb + MIU_TEST_AGT_CTRL);\n\t\t\tif ((temp & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t   \"%s: failed to read through agent\\n\",\n\t\t\t\t\t   __func__);\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int qla4_82xx_cmdpeg_ready(struct scsi_qla_host *ha, int pegtune_val)\n{\n\tu32 val = 0;\n\tint retries = 60;\n\n\tif (!pegtune_val) {\n\t\tdo {\n\t\t\tval = qla4_82xx_rd_32(ha, CRB_CMDPEG_STATE);\n\t\t\tif ((val == PHAN_INITIALIZE_COMPLETE) ||\n\t\t\t    (val == PHAN_INITIALIZE_ACK))\n\t\t\t\treturn 0;\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_timeout(500);\n\n\t\t} while (--retries);\n\n\t\tif (!retries) {\n\t\t\tpegtune_val = qla4_82xx_rd_32(ha,\n\t\t\t\tQLA82XX_ROMUSB_GLB_PEGTUNE_DONE);\n\t\t\tprintk(KERN_WARNING \"%s: init failed, \"\n\t\t\t\t\"pegtune_val = %x\\n\", __func__, pegtune_val);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int qla4_82xx_rcvpeg_ready(struct scsi_qla_host *ha)\n{\n\tuint32_t state = 0;\n\tint loops = 0;\n\n\t \n\tread_lock(&ha->hw_lock);\n\tstate = qla4_82xx_rd_32(ha, CRB_RCVPEG_STATE);\n\tread_unlock(&ha->hw_lock);\n\n\twhile ((state != PHAN_PEG_RCV_INITIALIZED) && (loops < 30000)) {\n\t\tudelay(100);\n\t\t \n\t\tread_lock(&ha->hw_lock);\n\t\tstate = qla4_82xx_rd_32(ha, CRB_RCVPEG_STATE);\n\t\tread_unlock(&ha->hw_lock);\n\n\t\tloops++;\n\t}\n\n\tif (loops >= 30000) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t    \"Receive Peg initialization not complete: 0x%x.\\n\", state));\n\t\treturn QLA_ERROR;\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\nvoid\nqla4_8xxx_set_drv_active(struct scsi_qla_host *ha)\n{\n\tuint32_t drv_active;\n\n\tdrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\tdrv_active |= (1 << ha->func_num);\n\telse\n\t\tdrv_active |= (1 << (ha->func_num * 4));\n\n\tql4_printk(KERN_INFO, ha, \"%s(%ld): drv_active: 0x%08x\\n\",\n\t\t   __func__, ha->host_no, drv_active);\n\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_ACTIVE, drv_active);\n}\n\nvoid\nqla4_8xxx_clear_drv_active(struct scsi_qla_host *ha)\n{\n\tuint32_t drv_active;\n\n\tdrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\tdrv_active &= ~(1 << (ha->func_num));\n\telse\n\t\tdrv_active &= ~(1 << (ha->func_num * 4));\n\n\tql4_printk(KERN_INFO, ha, \"%s(%ld): drv_active: 0x%08x\\n\",\n\t\t   __func__, ha->host_no, drv_active);\n\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_ACTIVE, drv_active);\n}\n\ninline int qla4_8xxx_need_reset(struct scsi_qla_host *ha)\n{\n\tuint32_t drv_state, drv_active;\n\tint rval;\n\n\tdrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\n\tdrv_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\trval = drv_state & (1 << ha->func_num);\n\telse\n\t\trval = drv_state & (1 << (ha->func_num * 4));\n\n\tif ((test_bit(AF_EEH_BUSY, &ha->flags)) && drv_active)\n\t\trval = 1;\n\n\treturn rval;\n}\n\nvoid qla4_8xxx_set_rst_ready(struct scsi_qla_host *ha)\n{\n\tuint32_t drv_state;\n\n\tdrv_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\tdrv_state |= (1 << ha->func_num);\n\telse\n\t\tdrv_state |= (1 << (ha->func_num * 4));\n\n\tql4_printk(KERN_INFO, ha, \"%s(%ld): drv_state: 0x%08x\\n\",\n\t\t   __func__, ha->host_no, drv_state);\n\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, drv_state);\n}\n\nvoid qla4_8xxx_clear_rst_ready(struct scsi_qla_host *ha)\n{\n\tuint32_t drv_state;\n\n\tdrv_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\tdrv_state &= ~(1 << ha->func_num);\n\telse\n\t\tdrv_state &= ~(1 << (ha->func_num * 4));\n\n\tql4_printk(KERN_INFO, ha, \"%s(%ld): drv_state: 0x%08x\\n\",\n\t\t   __func__, ha->host_no, drv_state);\n\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, drv_state);\n}\n\nstatic inline void\nqla4_8xxx_set_qsnt_ready(struct scsi_qla_host *ha)\n{\n\tuint32_t qsnt_state;\n\n\tqsnt_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_STATE);\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\tqsnt_state |= (1 << ha->func_num);\n\telse\n\t\tqsnt_state |= (2 << (ha->func_num * 4));\n\n\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, qsnt_state);\n}\n\n\nstatic int\nqla4_82xx_start_firmware(struct scsi_qla_host *ha, uint32_t image_start)\n{\n\tuint16_t lnk;\n\n\t \n\tqla4_82xx_wr_32(ha, CRB_DMA_SHIFT, 0x55555555);\n\n\t \n\tqla4_82xx_wr_32(ha, CRB_CMDPEG_STATE, 0);\n\tqla4_82xx_wr_32(ha, CRB_RCVPEG_STATE, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS1, 0);\n\tqla4_82xx_wr_32(ha, QLA82XX_PEG_HALT_STATUS2, 0);\n\n\tif (qla4_82xx_load_fw(ha, image_start) != QLA_SUCCESS) {\n\t\tprintk(\"%s: Error trying to start fw!\\n\", __func__);\n\t\treturn QLA_ERROR;\n\t}\n\n\t \n\tif (qla4_82xx_cmdpeg_ready(ha, 0) != QLA_SUCCESS) {\n\t\tprintk(\"%s: Error during card handshake!\\n\", __func__);\n\t\treturn QLA_ERROR;\n\t}\n\n\t \n\tpcie_capability_read_word(ha->pdev, PCI_EXP_LNKSTA, &lnk);\n\tha->link_width = (lnk >> 4) & 0x3f;\n\n\t \n\treturn qla4_82xx_rcvpeg_ready(ha);\n}\n\nint qla4_82xx_try_start_fw(struct scsi_qla_host *ha)\n{\n\tint rval;\n\n\t \n\n\tql4_printk(KERN_INFO, ha,\n\t    \"FW: Retrieving flash offsets from FLT/FDT ...\\n\");\n\trval = qla4_8xxx_get_flash_info(ha);\n\tif (rval != QLA_SUCCESS)\n\t\treturn rval;\n\n\tql4_printk(KERN_INFO, ha,\n\t    \"FW: Attempting to load firmware from flash...\\n\");\n\trval = qla4_82xx_start_firmware(ha, ha->hw.flt_region_fw);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"FW: Load firmware from flash\"\n\t\t    \" FAILED...\\n\");\n\t\treturn rval;\n\t}\n\n\treturn rval;\n}\n\nvoid qla4_82xx_rom_lock_recovery(struct scsi_qla_host *ha)\n{\n\tif (qla4_82xx_rom_lock(ha)) {\n\t\t \n\t\tdev_info(&ha->pdev->dev, \"Resetting rom_lock\\n\");\n\t}\n\n\t \n\tqla4_82xx_rom_unlock(ha);\n}\n\nstatic uint32_t ql4_84xx_poll_wait_for_ready(struct scsi_qla_host *ha,\n\t\t\t\t\t     uint32_t addr1, uint32_t mask)\n{\n\tunsigned long timeout;\n\tuint32_t rval = QLA_SUCCESS;\n\tuint32_t temp;\n\n\ttimeout = jiffies + msecs_to_jiffies(TIMEOUT_100_MS);\n\tdo {\n\t\tha->isp_ops->rd_reg_indirect(ha, addr1, &temp);\n\t\tif ((temp & mask) != 0)\n\t\t\tbreak;\n\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tql4_printk(KERN_INFO, ha, \"Error in processing rdmdio entry\\n\");\n\t\t\treturn QLA_ERROR;\n\t\t}\n\t} while (1);\n\n\treturn rval;\n}\n\nstatic uint32_t ql4_84xx_ipmdio_rd_reg(struct scsi_qla_host *ha, uint32_t addr1,\n\t\t\t\tuint32_t addr3, uint32_t mask, uint32_t addr,\n\t\t\t\tuint32_t *data_ptr)\n{\n\tint rval = QLA_SUCCESS;\n\tuint32_t temp;\n\tuint32_t data;\n\n\trval = ql4_84xx_poll_wait_for_ready(ha, addr1, mask);\n\tif (rval)\n\t\tgoto exit_ipmdio_rd_reg;\n\n\ttemp = (0x40000000 | addr);\n\tha->isp_ops->wr_reg_indirect(ha, addr1, temp);\n\n\trval = ql4_84xx_poll_wait_for_ready(ha, addr1, mask);\n\tif (rval)\n\t\tgoto exit_ipmdio_rd_reg;\n\n\tha->isp_ops->rd_reg_indirect(ha, addr3, &data);\n\t*data_ptr = data;\n\nexit_ipmdio_rd_reg:\n\treturn rval;\n}\n\n\nstatic uint32_t ql4_84xx_poll_wait_ipmdio_bus_idle(struct scsi_qla_host *ha,\n\t\t\t\t\t\t    uint32_t addr1,\n\t\t\t\t\t\t    uint32_t addr2,\n\t\t\t\t\t\t    uint32_t addr3,\n\t\t\t\t\t\t    uint32_t mask)\n{\n\tunsigned long timeout;\n\tuint32_t temp;\n\tuint32_t rval = QLA_SUCCESS;\n\n\ttimeout = jiffies + msecs_to_jiffies(TIMEOUT_100_MS);\n\tdo {\n\t\tql4_84xx_ipmdio_rd_reg(ha, addr1, addr3, mask, addr2, &temp);\n\t\tif ((temp & 0x1) != 1)\n\t\t\tbreak;\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tql4_printk(KERN_INFO, ha, \"Error in processing mdiobus idle\\n\");\n\t\t\treturn QLA_ERROR;\n\t\t}\n\t} while (1);\n\n\treturn rval;\n}\n\nstatic int ql4_84xx_ipmdio_wr_reg(struct scsi_qla_host *ha,\n\t\t\t\t  uint32_t addr1, uint32_t addr3,\n\t\t\t\t  uint32_t mask, uint32_t addr,\n\t\t\t\t  uint32_t value)\n{\n\tint rval = QLA_SUCCESS;\n\n\trval = ql4_84xx_poll_wait_for_ready(ha, addr1, mask);\n\tif (rval)\n\t\tgoto exit_ipmdio_wr_reg;\n\n\tha->isp_ops->wr_reg_indirect(ha, addr3, value);\n\tha->isp_ops->wr_reg_indirect(ha, addr1, addr);\n\n\trval = ql4_84xx_poll_wait_for_ready(ha, addr1, mask);\n\tif (rval)\n\t\tgoto exit_ipmdio_wr_reg;\n\nexit_ipmdio_wr_reg:\n\treturn rval;\n}\n\nstatic void qla4_8xxx_minidump_process_rdcrb(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t r_addr, r_stride, loop_cnt, i, r_value;\n\tstruct qla8xxx_minidump_entry_crb *crb_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\tcrb_hdr = (struct qla8xxx_minidump_entry_crb *)entry_hdr;\n\tr_addr = crb_hdr->addr;\n\tr_stride = crb_hdr->crb_strd.addr_stride;\n\tloop_cnt = crb_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tha->isp_ops->rd_reg_indirect(ha, r_addr, &r_value);\n\t\t*data_ptr++ = cpu_to_le32(r_addr);\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\tr_addr += r_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic int qla4_83xx_check_dma_engine_state(struct scsi_qla_host *ha)\n{\n\tint rval = QLA_SUCCESS;\n\tuint32_t dma_eng_num = 0, cmd_sts_and_cntrl = 0;\n\tuint64_t dma_base_addr = 0;\n\tstruct qla4_8xxx_minidump_template_hdr *tmplt_hdr = NULL;\n\n\ttmplt_hdr = (struct qla4_8xxx_minidump_template_hdr *)\n\t\t\t\t\t\t\tha->fw_dump_tmplt_hdr;\n\tdma_eng_num =\n\t\ttmplt_hdr->saved_state_array[QLA83XX_PEX_DMA_ENGINE_INDEX];\n\tdma_base_addr = QLA83XX_PEX_DMA_BASE_ADDRESS +\n\t\t\t\t(dma_eng_num * QLA83XX_PEX_DMA_NUM_OFFSET);\n\n\t \n\trval = ha->isp_ops->rd_reg_indirect(ha,\n\t\t\t(dma_base_addr + QLA83XX_PEX_DMA_CMD_STS_AND_CNTRL),\n\t\t\t&cmd_sts_and_cntrl);\n\n\tif (rval)\n\t\treturn QLA_ERROR;\n\n\t \n\tif (cmd_sts_and_cntrl & BIT_31)\n\t\treturn QLA_SUCCESS;\n\telse\n\t\treturn QLA_ERROR;\n}\n\nstatic int qla4_83xx_start_pex_dma(struct scsi_qla_host *ha,\n\t\t\t   struct qla4_83xx_minidump_entry_rdmem_pex_dma *m_hdr)\n{\n\tint rval = QLA_SUCCESS, wait = 0;\n\tuint32_t dma_eng_num = 0, cmd_sts_and_cntrl = 0;\n\tuint64_t dma_base_addr = 0;\n\tstruct qla4_8xxx_minidump_template_hdr *tmplt_hdr = NULL;\n\n\ttmplt_hdr = (struct qla4_8xxx_minidump_template_hdr *)\n\t\t\t\t\t\t\tha->fw_dump_tmplt_hdr;\n\tdma_eng_num =\n\t\ttmplt_hdr->saved_state_array[QLA83XX_PEX_DMA_ENGINE_INDEX];\n\tdma_base_addr = QLA83XX_PEX_DMA_BASE_ADDRESS +\n\t\t\t\t(dma_eng_num * QLA83XX_PEX_DMA_NUM_OFFSET);\n\n\trval = ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t\tdma_base_addr + QLA83XX_PEX_DMA_CMD_ADDR_LOW,\n\t\t\t\tm_hdr->desc_card_addr);\n\tif (rval)\n\t\tgoto error_exit;\n\n\trval = ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t      dma_base_addr + QLA83XX_PEX_DMA_CMD_ADDR_HIGH, 0);\n\tif (rval)\n\t\tgoto error_exit;\n\n\trval = ha->isp_ops->wr_reg_indirect(ha,\n\t\t\t      dma_base_addr + QLA83XX_PEX_DMA_CMD_STS_AND_CNTRL,\n\t\t\t      m_hdr->start_dma_cmd);\n\tif (rval)\n\t\tgoto error_exit;\n\n\t \n\tfor (wait = 0; wait < QLA83XX_PEX_DMA_MAX_WAIT; wait++) {\n\t\trval = ha->isp_ops->rd_reg_indirect(ha,\n\t\t\t    (dma_base_addr + QLA83XX_PEX_DMA_CMD_STS_AND_CNTRL),\n\t\t\t    &cmd_sts_and_cntrl);\n\t\tif (rval)\n\t\t\tgoto error_exit;\n\n\t\tif ((cmd_sts_and_cntrl & BIT_1) == 0)\n\t\t\tbreak;\n\t\telse\n\t\t\tudelay(10);\n\t}\n\n\t \n\tif (wait >= QLA83XX_PEX_DMA_MAX_WAIT) {\n\t\trval = QLA_ERROR;\n\t\tgoto error_exit;\n\t}\n\nerror_exit:\n\treturn rval;\n}\n\nstatic int qla4_8xxx_minidump_pex_dma_read(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tint rval = QLA_SUCCESS;\n\tstruct qla4_83xx_minidump_entry_rdmem_pex_dma *m_hdr = NULL;\n\tuint32_t size, read_size;\n\tuint8_t *data_ptr = (uint8_t *)*d_ptr;\n\tvoid *rdmem_buffer = NULL;\n\tdma_addr_t rdmem_dma;\n\tstruct qla4_83xx_pex_dma_descriptor dma_desc;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\n\trval = qla4_83xx_check_dma_engine_state(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: DMA engine not available. Fallback to rdmem-read.\\n\",\n\t\t\t\t  __func__));\n\t\treturn QLA_ERROR;\n\t}\n\n\tm_hdr = (struct qla4_83xx_minidump_entry_rdmem_pex_dma *)entry_hdr;\n\trdmem_buffer = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t  QLA83XX_PEX_DMA_READ_SIZE,\n\t\t\t\t\t  &rdmem_dma, GFP_KERNEL);\n\tif (!rdmem_buffer) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: Unable to allocate rdmem dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\treturn QLA_ERROR;\n\t}\n\n\t \n\t \n\tdma_desc.cmd.dma_desc_cmd = (m_hdr->dma_desc_cmd & 0xff0f);\n\tdma_desc.cmd.dma_desc_cmd |= ((PCI_FUNC(ha->pdev->devfn) & 0xf) << 0x4);\n\tdma_desc.dma_bus_addr = rdmem_dma;\n\n\tsize = 0;\n\tread_size = 0;\n\t \n\twhile (read_size < m_hdr->read_data_size) {\n\t\tif (m_hdr->read_data_size - read_size >=\n\t\t    QLA83XX_PEX_DMA_READ_SIZE)\n\t\t\tsize = QLA83XX_PEX_DMA_READ_SIZE;\n\t\telse {\n\t\t\tsize = (m_hdr->read_data_size - read_size);\n\n\t\t\tif (rdmem_buffer)\n\t\t\t\tdma_free_coherent(&ha->pdev->dev,\n\t\t\t\t\t\t  QLA83XX_PEX_DMA_READ_SIZE,\n\t\t\t\t\t\t  rdmem_buffer, rdmem_dma);\n\n\t\t\trdmem_buffer = dma_alloc_coherent(&ha->pdev->dev, size,\n\t\t\t\t\t\t\t  &rdmem_dma,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!rdmem_buffer) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"%s: Unable to allocate rdmem dma buffer\\n\",\n\t\t\t\t\t\t  __func__));\n\t\t\t\treturn QLA_ERROR;\n\t\t\t}\n\t\t\tdma_desc.dma_bus_addr = rdmem_dma;\n\t\t}\n\n\t\tdma_desc.src_addr = m_hdr->read_addr + read_size;\n\t\tdma_desc.cmd.read_data_size = size;\n\n\t\t \n\t\trval = qla4_8xxx_ms_mem_write_128b(ha,\n\t\t\t      (uint64_t)m_hdr->desc_card_addr,\n\t\t\t      (uint32_t *)&dma_desc,\n\t\t\t      (sizeof(struct qla4_83xx_pex_dma_descriptor)/16));\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"%s: Error writing rdmem-dma-init to MS !!!\\n\",\n\t\t\t\t   __func__);\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: Dma-desc: Instruct for rdmem dma (size 0x%x).\\n\",\n\t\t\t\t  __func__, size));\n\t\t \n\t\trval = qla4_83xx_start_pex_dma(ha, m_hdr);\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi(%ld): start-pex-dma failed rval=0x%x\\n\",\n\t\t\t\t\t  ha->host_no, rval));\n\t\t\tgoto error_exit;\n\t\t}\n\n\t\tmemcpy(data_ptr, rdmem_buffer, size);\n\t\tdata_ptr += size;\n\t\tread_size += size;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Leaving fn: %s\\n\", __func__));\n\n\t*d_ptr = (uint32_t *)data_ptr;\n\nerror_exit:\n\tif (rdmem_buffer)\n\t\tdma_free_coherent(&ha->pdev->dev, size, rdmem_buffer,\n\t\t\t\t  rdmem_dma);\n\n\treturn rval;\n}\n\nstatic int qla4_8xxx_minidump_process_l2tag(struct scsi_qla_host *ha,\n\t\t\t\t struct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\t uint32_t **d_ptr)\n{\n\tuint32_t addr, r_addr, c_addr, t_r_addr;\n\tuint32_t i, k, loop_count, t_value, r_cnt, r_value;\n\tunsigned long p_wait, w_time, p_mask;\n\tuint32_t c_value_w, c_value_r;\n\tstruct qla8xxx_minidump_entry_cache *cache_hdr;\n\tint rval = QLA_ERROR;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\tcache_hdr = (struct qla8xxx_minidump_entry_cache *)entry_hdr;\n\n\tloop_count = cache_hdr->op_count;\n\tr_addr = cache_hdr->read_addr;\n\tc_addr = cache_hdr->control_addr;\n\tc_value_w = cache_hdr->cache_ctrl.write_value;\n\n\tt_r_addr = cache_hdr->tag_reg_addr;\n\tt_value = cache_hdr->addr_ctrl.init_tag_value;\n\tr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\n\tp_wait = cache_hdr->cache_ctrl.poll_wait;\n\tp_mask = cache_hdr->cache_ctrl.poll_mask;\n\n\tfor (i = 0; i < loop_count; i++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, t_r_addr, t_value);\n\n\t\tif (c_value_w)\n\t\t\tha->isp_ops->wr_reg_indirect(ha, c_addr, c_value_w);\n\n\t\tif (p_mask) {\n\t\t\tw_time = jiffies + p_wait;\n\t\t\tdo {\n\t\t\t\tha->isp_ops->rd_reg_indirect(ha, c_addr,\n\t\t\t\t\t\t\t     &c_value_r);\n\t\t\t\tif ((c_value_r & p_mask) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (time_after_eq(jiffies, w_time)) {\n\t\t\t\t\t \n\t\t\t\t\treturn rval;\n\t\t\t\t}\n\t\t\t} while (1);\n\t\t}\n\n\t\taddr = r_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, addr, &r_value);\n\t\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\t\taddr += cache_hdr->read_ctrl.read_addr_stride;\n\t\t}\n\n\t\tt_value += cache_hdr->addr_ctrl.tag_value_stride;\n\t}\n\t*d_ptr = data_ptr;\n\treturn QLA_SUCCESS;\n}\n\nstatic int qla4_8xxx_minidump_process_control(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr)\n{\n\tstruct qla8xxx_minidump_entry_crb *crb_entry;\n\tuint32_t read_value, opcode, poll_time, addr, index, rval = QLA_SUCCESS;\n\tuint32_t crb_addr;\n\tunsigned long wtime;\n\tstruct qla4_8xxx_minidump_template_hdr *tmplt_hdr;\n\tint i;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\ttmplt_hdr = (struct qla4_8xxx_minidump_template_hdr *)\n\t\t\t\t\t\tha->fw_dump_tmplt_hdr;\n\tcrb_entry = (struct qla8xxx_minidump_entry_crb *)entry_hdr;\n\n\tcrb_addr = crb_entry->addr;\n\tfor (i = 0; i < crb_entry->op_count; i++) {\n\t\topcode = crb_entry->crb_ctrl.opcode;\n\t\tif (opcode & QLA8XXX_DBG_OPCODE_WR) {\n\t\t\tha->isp_ops->wr_reg_indirect(ha, crb_addr,\n\t\t\t\t\t\t     crb_entry->value_1);\n\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_WR;\n\t\t}\n\t\tif (opcode & QLA8XXX_DBG_OPCODE_RW) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, crb_addr, &read_value);\n\t\t\tha->isp_ops->wr_reg_indirect(ha, crb_addr, read_value);\n\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_RW;\n\t\t}\n\t\tif (opcode & QLA8XXX_DBG_OPCODE_AND) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, crb_addr, &read_value);\n\t\t\tread_value &= crb_entry->value_2;\n\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_AND;\n\t\t\tif (opcode & QLA8XXX_DBG_OPCODE_OR) {\n\t\t\t\tread_value |= crb_entry->value_3;\n\t\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_OR;\n\t\t\t}\n\t\t\tha->isp_ops->wr_reg_indirect(ha, crb_addr, read_value);\n\t\t}\n\t\tif (opcode & QLA8XXX_DBG_OPCODE_OR) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, crb_addr, &read_value);\n\t\t\tread_value |= crb_entry->value_3;\n\t\t\tha->isp_ops->wr_reg_indirect(ha, crb_addr, read_value);\n\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_OR;\n\t\t}\n\t\tif (opcode & QLA8XXX_DBG_OPCODE_POLL) {\n\t\t\tpoll_time = crb_entry->crb_strd.poll_timeout;\n\t\t\twtime = jiffies + poll_time;\n\t\t\tha->isp_ops->rd_reg_indirect(ha, crb_addr, &read_value);\n\n\t\t\tdo {\n\t\t\t\tif ((read_value & crb_entry->value_2) ==\n\t\t\t\t    crb_entry->value_1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (time_after_eq(jiffies, wtime)) {\n\t\t\t\t\t \n\t\t\t\t\trval = QLA_ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tha->isp_ops->rd_reg_indirect(ha,\n\t\t\t\t\t\t\tcrb_addr, &read_value);\n\t\t\t\t}\n\t\t\t} while (1);\n\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_POLL;\n\t\t}\n\n\t\tif (opcode & QLA8XXX_DBG_OPCODE_RDSTATE) {\n\t\t\tif (crb_entry->crb_strd.state_index_a) {\n\t\t\t\tindex = crb_entry->crb_strd.state_index_a;\n\t\t\t\taddr = tmplt_hdr->saved_state_array[index];\n\t\t\t} else {\n\t\t\t\taddr = crb_addr;\n\t\t\t}\n\n\t\t\tha->isp_ops->rd_reg_indirect(ha, addr, &read_value);\n\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\ttmplt_hdr->saved_state_array[index] = read_value;\n\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_RDSTATE;\n\t\t}\n\n\t\tif (opcode & QLA8XXX_DBG_OPCODE_WRSTATE) {\n\t\t\tif (crb_entry->crb_strd.state_index_a) {\n\t\t\t\tindex = crb_entry->crb_strd.state_index_a;\n\t\t\t\taddr = tmplt_hdr->saved_state_array[index];\n\t\t\t} else {\n\t\t\t\taddr = crb_addr;\n\t\t\t}\n\n\t\t\tif (crb_entry->crb_ctrl.state_index_v) {\n\t\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\t\tread_value =\n\t\t\t\t\ttmplt_hdr->saved_state_array[index];\n\t\t\t} else {\n\t\t\t\tread_value = crb_entry->value_1;\n\t\t\t}\n\n\t\t\tha->isp_ops->wr_reg_indirect(ha, addr, read_value);\n\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_WRSTATE;\n\t\t}\n\n\t\tif (opcode & QLA8XXX_DBG_OPCODE_MDSTATE) {\n\t\t\tindex = crb_entry->crb_ctrl.state_index_v;\n\t\t\tread_value = tmplt_hdr->saved_state_array[index];\n\t\t\tread_value <<= crb_entry->crb_ctrl.shl;\n\t\t\tread_value >>= crb_entry->crb_ctrl.shr;\n\t\t\tif (crb_entry->value_2)\n\t\t\t\tread_value &= crb_entry->value_2;\n\t\t\tread_value |= crb_entry->value_3;\n\t\t\tread_value += crb_entry->value_1;\n\t\t\ttmplt_hdr->saved_state_array[index] = read_value;\n\t\t\topcode &= ~QLA8XXX_DBG_OPCODE_MDSTATE;\n\t\t}\n\t\tcrb_addr += crb_entry->crb_strd.addr_stride;\n\t}\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Leaving fn: %s\\n\", __func__));\n\treturn rval;\n}\n\nstatic void qla4_8xxx_minidump_process_rdocm(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t r_addr, r_stride, loop_cnt, i, r_value;\n\tstruct qla8xxx_minidump_entry_rdocm *ocm_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\tocm_hdr = (struct qla8xxx_minidump_entry_rdocm *)entry_hdr;\n\tr_addr = ocm_hdr->read_addr;\n\tr_stride = ocm_hdr->read_addr_stride;\n\tloop_cnt = ocm_hdr->op_count;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"[%s]: r_addr: 0x%x, r_stride: 0x%x, loop_cnt: 0x%x\\n\",\n\t\t\t  __func__, r_addr, r_stride, loop_cnt));\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tr_value = readl((void __iomem *)(r_addr + ha->nx_pcibase));\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\tr_addr += r_stride;\n\t}\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Leaving fn: %s datacount: 0x%lx\\n\",\n\t\t__func__, (long unsigned int) (loop_cnt * sizeof(uint32_t))));\n\t*d_ptr = data_ptr;\n}\n\nstatic void qla4_8xxx_minidump_process_rdmux(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t r_addr, s_stride, s_addr, s_value, loop_cnt, i, r_value;\n\tstruct qla8xxx_minidump_entry_mux *mux_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\tmux_hdr = (struct qla8xxx_minidump_entry_mux *)entry_hdr;\n\tr_addr = mux_hdr->read_addr;\n\ts_addr = mux_hdr->select_addr;\n\ts_stride = mux_hdr->select_value_stride;\n\ts_value = mux_hdr->select_value;\n\tloop_cnt = mux_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, s_addr, s_value);\n\t\tha->isp_ops->rd_reg_indirect(ha, r_addr, &r_value);\n\t\t*data_ptr++ = cpu_to_le32(s_value);\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\ts_value += s_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic void qla4_8xxx_minidump_process_l1cache(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t addr, r_addr, c_addr, t_r_addr;\n\tuint32_t i, k, loop_count, t_value, r_cnt, r_value;\n\tuint32_t c_value_w;\n\tstruct qla8xxx_minidump_entry_cache *cache_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tcache_hdr = (struct qla8xxx_minidump_entry_cache *)entry_hdr;\n\tloop_count = cache_hdr->op_count;\n\tr_addr = cache_hdr->read_addr;\n\tc_addr = cache_hdr->control_addr;\n\tc_value_w = cache_hdr->cache_ctrl.write_value;\n\n\tt_r_addr = cache_hdr->tag_reg_addr;\n\tt_value = cache_hdr->addr_ctrl.init_tag_value;\n\tr_cnt = cache_hdr->read_ctrl.read_addr_cnt;\n\n\tfor (i = 0; i < loop_count; i++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, t_r_addr, t_value);\n\t\tha->isp_ops->wr_reg_indirect(ha, c_addr, c_value_w);\n\t\taddr = r_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, addr, &r_value);\n\t\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\t\taddr += cache_hdr->read_ctrl.read_addr_stride;\n\t\t}\n\t\tt_value += cache_hdr->addr_ctrl.tag_value_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\nstatic void qla4_8xxx_minidump_process_queue(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t s_addr, r_addr;\n\tuint32_t r_stride, r_value, r_cnt, qid = 0;\n\tuint32_t i, k, loop_cnt;\n\tstruct qla8xxx_minidump_entry_queue *q_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\tq_hdr = (struct qla8xxx_minidump_entry_queue *)entry_hdr;\n\ts_addr = q_hdr->select_addr;\n\tr_cnt = q_hdr->rd_strd.read_addr_cnt;\n\tr_stride = q_hdr->rd_strd.read_addr_stride;\n\tloop_cnt = q_hdr->op_count;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, s_addr, qid);\n\t\tr_addr = q_hdr->read_addr;\n\t\tfor (k = 0; k < r_cnt; k++) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, r_addr, &r_value);\n\t\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\t\tr_addr += r_stride;\n\t\t}\n\t\tqid += q_hdr->q_strd.queue_id_stride;\n\t}\n\t*d_ptr = data_ptr;\n}\n\n#define MD_DIRECT_ROM_WINDOW\t\t0x42110030\n#define MD_DIRECT_ROM_READ_BASE\t\t0x42150000\n\nstatic void qla4_82xx_minidump_process_rdrom(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t r_addr, r_value;\n\tuint32_t i, loop_cnt;\n\tstruct qla8xxx_minidump_entry_rdrom *rom_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\trom_hdr = (struct qla8xxx_minidump_entry_rdrom *)entry_hdr;\n\tr_addr = rom_hdr->read_addr;\n\tloop_cnt = rom_hdr->read_data_size/sizeof(uint32_t);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"[%s]: flash_addr: 0x%x, read_data_size: 0x%x\\n\",\n\t\t\t   __func__, r_addr, loop_cnt));\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, MD_DIRECT_ROM_WINDOW,\n\t\t\t\t\t     (r_addr & 0xFFFF0000));\n\t\tha->isp_ops->rd_reg_indirect(ha,\n\t\t\t\tMD_DIRECT_ROM_READ_BASE + (r_addr & 0x0000FFFF),\n\t\t\t\t&r_value);\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\tr_addr += sizeof(uint32_t);\n\t}\n\t*d_ptr = data_ptr;\n}\n\n#define MD_MIU_TEST_AGT_CTRL\t\t0x41000090\n#define MD_MIU_TEST_AGT_ADDR_LO\t\t0x41000094\n#define MD_MIU_TEST_AGT_ADDR_HI\t\t0x41000098\n\nstatic int __qla4_8xxx_minidump_process_rdmem(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t r_addr, r_value, r_data;\n\tuint32_t i, j, loop_cnt;\n\tstruct qla8xxx_minidump_entry_rdmem *m_hdr;\n\tunsigned long flags;\n\tuint32_t *data_ptr = *d_ptr;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Entering fn: %s\\n\", __func__));\n\tm_hdr = (struct qla8xxx_minidump_entry_rdmem *)entry_hdr;\n\tr_addr = m_hdr->read_addr;\n\tloop_cnt = m_hdr->read_data_size/16;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"[%s]: Read addr: 0x%x, read_data_size: 0x%x\\n\",\n\t\t\t  __func__, r_addr, m_hdr->read_data_size));\n\n\tif (r_addr & 0xf) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"[%s]: Read addr 0x%x not 16 bytes aligned\\n\",\n\t\t\t\t  __func__, r_addr));\n\t\treturn QLA_ERROR;\n\t}\n\n\tif (m_hdr->read_data_size % 16) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"[%s]: Read data[0x%x] not multiple of 16 bytes\\n\",\n\t\t\t\t  __func__, m_hdr->read_data_size));\n\t\treturn QLA_ERROR;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"[%s]: rdmem_addr: 0x%x, read_data_size: 0x%x, loop_cnt: 0x%x\\n\",\n\t\t\t  __func__, r_addr, m_hdr->read_data_size, loop_cnt));\n\n\twrite_lock_irqsave(&ha->hw_lock, flags);\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_ADDR_LO,\n\t\t\t\t\t     r_addr);\n\t\tr_value = 0;\n\t\tha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_ADDR_HI,\n\t\t\t\t\t     r_value);\n\t\tr_value = MIU_TA_CTL_ENABLE;\n\t\tha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_CTRL, r_value);\n\t\tr_value = MIU_TA_CTL_START_ENABLE;\n\t\tha->isp_ops->wr_reg_indirect(ha, MD_MIU_TEST_AGT_CTRL, r_value);\n\n\t\tfor (j = 0; j < MAX_CTL_CHECK; j++) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, MD_MIU_TEST_AGT_CTRL,\n\t\t\t\t\t\t     &r_value);\n\t\t\tif ((r_value & MIU_TA_CTL_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j >= MAX_CTL_CHECK) {\n\t\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\t   \"%s: failed to read through agent\\n\",\n\t\t\t\t\t    __func__);\n\t\t\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha,\n\t\t\t\t\t\t     MD_MIU_TEST_AGT_RDDATA[j],\n\t\t\t\t\t\t     &r_data);\n\t\t\t*data_ptr++ = cpu_to_le32(r_data);\n\t\t}\n\n\t\tr_addr += 16;\n\t}\n\twrite_unlock_irqrestore(&ha->hw_lock, flags);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Leaving fn: %s datacount: 0x%x\\n\",\n\t\t\t  __func__, (loop_cnt * 16)));\n\n\t*d_ptr = data_ptr;\n\treturn QLA_SUCCESS;\n}\n\nstatic int qla4_8xxx_minidump_process_rdmem(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t *data_ptr = *d_ptr;\n\tint rval = QLA_SUCCESS;\n\n\trval = qla4_8xxx_minidump_pex_dma_read(ha, entry_hdr, &data_ptr);\n\tif (rval != QLA_SUCCESS)\n\t\trval = __qla4_8xxx_minidump_process_rdmem(ha, entry_hdr,\n\t\t\t\t\t\t\t  &data_ptr);\n\t*d_ptr = data_ptr;\n\treturn rval;\n}\n\nstatic void qla4_8xxx_mark_entry_skipped(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tint index)\n{\n\tentry_hdr->d_ctrl.driver_flags |= QLA8XXX_DBG_SKIPPED_FLAG;\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"scsi(%ld): Skipping entry[%d]: ETYPE[0x%x]-ELEVEL[0x%x]\\n\",\n\t\t\t  ha->host_no, index, entry_hdr->entry_type,\n\t\t\t  entry_hdr->d_ctrl.entry_capture_mask));\n\t \n\tha->fw_dump_skip_size += entry_hdr->entry_capture_size;\n}\n\n \nstatic uint32_t qla83xx_minidump_process_pollrd(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t r_addr, s_addr, s_value, r_value, poll_wait, poll_mask;\n\tuint16_t s_stride, i;\n\tuint32_t *data_ptr = *d_ptr;\n\tuint32_t rval = QLA_SUCCESS;\n\tstruct qla83xx_minidump_entry_pollrd *pollrd_hdr;\n\n\tpollrd_hdr = (struct qla83xx_minidump_entry_pollrd *)entry_hdr;\n\ts_addr = le32_to_cpu(pollrd_hdr->select_addr);\n\tr_addr = le32_to_cpu(pollrd_hdr->read_addr);\n\ts_value = le32_to_cpu(pollrd_hdr->select_value);\n\ts_stride = le32_to_cpu(pollrd_hdr->select_value_stride);\n\n\tpoll_wait = le32_to_cpu(pollrd_hdr->poll_wait);\n\tpoll_mask = le32_to_cpu(pollrd_hdr->poll_mask);\n\n\tfor (i = 0; i < le32_to_cpu(pollrd_hdr->op_count); i++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, s_addr, s_value);\n\t\tpoll_wait = le32_to_cpu(pollrd_hdr->poll_wait);\n\t\twhile (1) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, s_addr, &r_value);\n\n\t\t\tif ((r_value & poll_mask) != 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmsleep(1);\n\t\t\t\tif (--poll_wait == 0) {\n\t\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: TIMEOUT\\n\",\n\t\t\t\t\t\t   __func__);\n\t\t\t\t\trval = QLA_ERROR;\n\t\t\t\t\tgoto exit_process_pollrd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tha->isp_ops->rd_reg_indirect(ha, r_addr, &r_value);\n\t\t*data_ptr++ = cpu_to_le32(s_value);\n\t\t*data_ptr++ = cpu_to_le32(r_value);\n\t\ts_value += s_stride;\n\t}\n\n\t*d_ptr = data_ptr;\n\nexit_process_pollrd:\n\treturn rval;\n}\n\nstatic uint32_t qla4_84xx_minidump_process_rddfe(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tint loop_cnt;\n\tuint32_t addr1, addr2, value, data, temp, wrval;\n\tuint8_t stride, stride2;\n\tuint16_t count;\n\tuint32_t poll, mask, modify_mask;\n\tuint32_t wait_count = 0;\n\tuint32_t *data_ptr = *d_ptr;\n\tstruct qla8044_minidump_entry_rddfe *rddfe;\n\tuint32_t rval = QLA_SUCCESS;\n\n\trddfe = (struct qla8044_minidump_entry_rddfe *)entry_hdr;\n\taddr1 = le32_to_cpu(rddfe->addr_1);\n\tvalue = le32_to_cpu(rddfe->value);\n\tstride = le32_to_cpu(rddfe->stride);\n\tstride2 = le32_to_cpu(rddfe->stride2);\n\tcount = le32_to_cpu(rddfe->count);\n\n\tpoll = le32_to_cpu(rddfe->poll);\n\tmask = le32_to_cpu(rddfe->mask);\n\tmodify_mask = le32_to_cpu(rddfe->modify_mask);\n\n\taddr2 = addr1 + stride;\n\n\tfor (loop_cnt = 0x0; loop_cnt < count; loop_cnt++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, addr1, (0x40000000 | value));\n\n\t\twait_count = 0;\n\t\twhile (wait_count < poll) {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, addr1, &temp);\n\t\t\tif ((temp & mask) != 0)\n\t\t\t\tbreak;\n\t\t\twait_count++;\n\t\t}\n\n\t\tif (wait_count == poll) {\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: TIMEOUT\\n\", __func__);\n\t\t\trval = QLA_ERROR;\n\t\t\tgoto exit_process_rddfe;\n\t\t} else {\n\t\t\tha->isp_ops->rd_reg_indirect(ha, addr2, &temp);\n\t\t\ttemp = temp & modify_mask;\n\t\t\ttemp = (temp | ((loop_cnt << 16) | loop_cnt));\n\t\t\twrval = ((temp << 16) | temp);\n\n\t\t\tha->isp_ops->wr_reg_indirect(ha, addr2, wrval);\n\t\t\tha->isp_ops->wr_reg_indirect(ha, addr1, value);\n\n\t\t\twait_count = 0;\n\t\t\twhile (wait_count < poll) {\n\t\t\t\tha->isp_ops->rd_reg_indirect(ha, addr1, &temp);\n\t\t\t\tif ((temp & mask) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\twait_count++;\n\t\t\t}\n\t\t\tif (wait_count == poll) {\n\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: TIMEOUT\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\trval = QLA_ERROR;\n\t\t\t\tgoto exit_process_rddfe;\n\t\t\t}\n\n\t\t\tha->isp_ops->wr_reg_indirect(ha, addr1,\n\t\t\t\t\t\t     ((0x40000000 | value) +\n\t\t\t\t\t\t     stride2));\n\t\t\twait_count = 0;\n\t\t\twhile (wait_count < poll) {\n\t\t\t\tha->isp_ops->rd_reg_indirect(ha, addr1, &temp);\n\t\t\t\tif ((temp & mask) != 0)\n\t\t\t\t\tbreak;\n\t\t\t\twait_count++;\n\t\t\t}\n\n\t\t\tif (wait_count == poll) {\n\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: TIMEOUT\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\trval = QLA_ERROR;\n\t\t\t\tgoto exit_process_rddfe;\n\t\t\t}\n\n\t\t\tha->isp_ops->rd_reg_indirect(ha, addr2, &data);\n\n\t\t\t*data_ptr++ = cpu_to_le32(wrval);\n\t\t\t*data_ptr++ = cpu_to_le32(data);\n\t\t}\n\t}\n\n\t*d_ptr = data_ptr;\nexit_process_rddfe:\n\treturn rval;\n}\n\nstatic uint32_t qla4_84xx_minidump_process_rdmdio(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tint rval = QLA_SUCCESS;\n\tuint32_t addr1, addr2, value1, value2, data, selval;\n\tuint8_t stride1, stride2;\n\tuint32_t addr3, addr4, addr5, addr6, addr7;\n\tuint16_t count, loop_cnt;\n\tuint32_t mask;\n\tuint32_t *data_ptr = *d_ptr;\n\tstruct qla8044_minidump_entry_rdmdio *rdmdio;\n\n\trdmdio = (struct qla8044_minidump_entry_rdmdio *)entry_hdr;\n\taddr1 = le32_to_cpu(rdmdio->addr_1);\n\taddr2 = le32_to_cpu(rdmdio->addr_2);\n\tvalue1 = le32_to_cpu(rdmdio->value_1);\n\tstride1 = le32_to_cpu(rdmdio->stride_1);\n\tstride2 = le32_to_cpu(rdmdio->stride_2);\n\tcount = le32_to_cpu(rdmdio->count);\n\n\tmask = le32_to_cpu(rdmdio->mask);\n\tvalue2 = le32_to_cpu(rdmdio->value_2);\n\n\taddr3 = addr1 + stride1;\n\n\tfor (loop_cnt = 0; loop_cnt < count; loop_cnt++) {\n\t\trval = ql4_84xx_poll_wait_ipmdio_bus_idle(ha, addr1, addr2,\n\t\t\t\t\t\t\t addr3, mask);\n\t\tif (rval)\n\t\t\tgoto exit_process_rdmdio;\n\n\t\taddr4 = addr2 - stride1;\n\t\trval = ql4_84xx_ipmdio_wr_reg(ha, addr1, addr3, mask, addr4,\n\t\t\t\t\t     value2);\n\t\tif (rval)\n\t\t\tgoto exit_process_rdmdio;\n\n\t\taddr5 = addr2 - (2 * stride1);\n\t\trval = ql4_84xx_ipmdio_wr_reg(ha, addr1, addr3, mask, addr5,\n\t\t\t\t\t     value1);\n\t\tif (rval)\n\t\t\tgoto exit_process_rdmdio;\n\n\t\taddr6 = addr2 - (3 * stride1);\n\t\trval = ql4_84xx_ipmdio_wr_reg(ha, addr1, addr3, mask,\n\t\t\t\t\t     addr6, 0x2);\n\t\tif (rval)\n\t\t\tgoto exit_process_rdmdio;\n\n\t\trval = ql4_84xx_poll_wait_ipmdio_bus_idle(ha, addr1, addr2,\n\t\t\t\t\t\t\t addr3, mask);\n\t\tif (rval)\n\t\t\tgoto exit_process_rdmdio;\n\n\t\taddr7 = addr2 - (4 * stride1);\n\t\trval = ql4_84xx_ipmdio_rd_reg(ha, addr1, addr3,\n\t\t\t\t\t\t      mask, addr7, &data);\n\t\tif (rval)\n\t\t\tgoto exit_process_rdmdio;\n\n\t\tselval = (value2 << 18) | (value1 << 2) | 2;\n\n\t\tstride2 = le32_to_cpu(rdmdio->stride_2);\n\t\t*data_ptr++ = cpu_to_le32(selval);\n\t\t*data_ptr++ = cpu_to_le32(data);\n\n\t\tvalue1 = value1 + stride2;\n\t\t*d_ptr = data_ptr;\n\t}\n\nexit_process_rdmdio:\n\treturn rval;\n}\n\nstatic uint32_t qla4_84xx_minidump_process_pollwr(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t addr1, addr2, value1, value2, poll, r_value;\n\tstruct qla8044_minidump_entry_pollwr *pollwr_hdr;\n\tuint32_t wait_count = 0;\n\tuint32_t rval = QLA_SUCCESS;\n\n\tpollwr_hdr = (struct qla8044_minidump_entry_pollwr *)entry_hdr;\n\taddr1 = le32_to_cpu(pollwr_hdr->addr_1);\n\taddr2 = le32_to_cpu(pollwr_hdr->addr_2);\n\tvalue1 = le32_to_cpu(pollwr_hdr->value_1);\n\tvalue2 = le32_to_cpu(pollwr_hdr->value_2);\n\n\tpoll = le32_to_cpu(pollwr_hdr->poll);\n\n\twhile (wait_count < poll) {\n\t\tha->isp_ops->rd_reg_indirect(ha, addr1, &r_value);\n\n\t\tif ((r_value & poll) != 0)\n\t\t\tbreak;\n\n\t\twait_count++;\n\t}\n\n\tif (wait_count == poll) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: TIMEOUT\\n\", __func__);\n\t\trval = QLA_ERROR;\n\t\tgoto exit_process_pollwr;\n\t}\n\n\tha->isp_ops->wr_reg_indirect(ha, addr2, value2);\n\tha->isp_ops->wr_reg_indirect(ha, addr1, value1);\n\n\twait_count = 0;\n\twhile (wait_count < poll) {\n\t\tha->isp_ops->rd_reg_indirect(ha, addr1, &r_value);\n\n\t\tif ((r_value & poll) != 0)\n\t\t\tbreak;\n\t\twait_count++;\n\t}\n\nexit_process_pollwr:\n\treturn rval;\n}\n\nstatic void qla83xx_minidump_process_rdmux2(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t sel_val1, sel_val2, t_sel_val, data, i;\n\tuint32_t sel_addr1, sel_addr2, sel_val_mask, read_addr;\n\tstruct qla83xx_minidump_entry_rdmux2 *rdmux2_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\trdmux2_hdr = (struct qla83xx_minidump_entry_rdmux2 *)entry_hdr;\n\tsel_val1 = le32_to_cpu(rdmux2_hdr->select_value_1);\n\tsel_val2 = le32_to_cpu(rdmux2_hdr->select_value_2);\n\tsel_addr1 = le32_to_cpu(rdmux2_hdr->select_addr_1);\n\tsel_addr2 = le32_to_cpu(rdmux2_hdr->select_addr_2);\n\tsel_val_mask = le32_to_cpu(rdmux2_hdr->select_value_mask);\n\tread_addr = le32_to_cpu(rdmux2_hdr->read_addr);\n\n\tfor (i = 0; i < rdmux2_hdr->op_count; i++) {\n\t\tha->isp_ops->wr_reg_indirect(ha, sel_addr1, sel_val1);\n\t\tt_sel_val = sel_val1 & sel_val_mask;\n\t\t*data_ptr++ = cpu_to_le32(t_sel_val);\n\n\t\tha->isp_ops->wr_reg_indirect(ha, sel_addr2, t_sel_val);\n\t\tha->isp_ops->rd_reg_indirect(ha, read_addr, &data);\n\n\t\t*data_ptr++ = cpu_to_le32(data);\n\n\t\tha->isp_ops->wr_reg_indirect(ha, sel_addr1, sel_val2);\n\t\tt_sel_val = sel_val2 & sel_val_mask;\n\t\t*data_ptr++ = cpu_to_le32(t_sel_val);\n\n\t\tha->isp_ops->wr_reg_indirect(ha, sel_addr2, t_sel_val);\n\t\tha->isp_ops->rd_reg_indirect(ha, read_addr, &data);\n\n\t\t*data_ptr++ = cpu_to_le32(data);\n\n\t\tsel_val1 += rdmux2_hdr->select_value_stride;\n\t\tsel_val2 += rdmux2_hdr->select_value_stride;\n\t}\n\n\t*d_ptr = data_ptr;\n}\n\nstatic uint32_t qla83xx_minidump_process_pollrdmwr(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t poll_wait, poll_mask, r_value, data;\n\tuint32_t addr_1, addr_2, value_1, value_2;\n\tuint32_t *data_ptr = *d_ptr;\n\tuint32_t rval = QLA_SUCCESS;\n\tstruct qla83xx_minidump_entry_pollrdmwr *poll_hdr;\n\n\tpoll_hdr = (struct qla83xx_minidump_entry_pollrdmwr *)entry_hdr;\n\taddr_1 = le32_to_cpu(poll_hdr->addr_1);\n\taddr_2 = le32_to_cpu(poll_hdr->addr_2);\n\tvalue_1 = le32_to_cpu(poll_hdr->value_1);\n\tvalue_2 = le32_to_cpu(poll_hdr->value_2);\n\tpoll_mask = le32_to_cpu(poll_hdr->poll_mask);\n\n\tha->isp_ops->wr_reg_indirect(ha, addr_1, value_1);\n\n\tpoll_wait = le32_to_cpu(poll_hdr->poll_wait);\n\twhile (1) {\n\t\tha->isp_ops->rd_reg_indirect(ha, addr_1, &r_value);\n\n\t\tif ((r_value & poll_mask) != 0) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tmsleep(1);\n\t\t\tif (--poll_wait == 0) {\n\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: TIMEOUT_1\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\trval = QLA_ERROR;\n\t\t\t\tgoto exit_process_pollrdmwr;\n\t\t\t}\n\t\t}\n\t}\n\n\tha->isp_ops->rd_reg_indirect(ha, addr_2, &data);\n\tdata &= le32_to_cpu(poll_hdr->modify_mask);\n\tha->isp_ops->wr_reg_indirect(ha, addr_2, data);\n\tha->isp_ops->wr_reg_indirect(ha, addr_1, value_2);\n\n\tpoll_wait = le32_to_cpu(poll_hdr->poll_wait);\n\twhile (1) {\n\t\tha->isp_ops->rd_reg_indirect(ha, addr_1, &r_value);\n\n\t\tif ((r_value & poll_mask) != 0) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tmsleep(1);\n\t\t\tif (--poll_wait == 0) {\n\t\t\t\tql4_printk(KERN_ERR, ha, \"%s: TIMEOUT_2\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\trval = QLA_ERROR;\n\t\t\t\tgoto exit_process_pollrdmwr;\n\t\t\t}\n\t\t}\n\t}\n\n\t*data_ptr++ = cpu_to_le32(addr_2);\n\t*data_ptr++ = cpu_to_le32(data);\n\t*d_ptr = data_ptr;\n\nexit_process_pollrdmwr:\n\treturn rval;\n}\n\nstatic uint32_t qla4_83xx_minidump_process_rdrom(struct scsi_qla_host *ha,\n\t\t\t\tstruct qla8xxx_minidump_entry_hdr *entry_hdr,\n\t\t\t\tuint32_t **d_ptr)\n{\n\tuint32_t fl_addr, u32_count, rval;\n\tstruct qla8xxx_minidump_entry_rdrom *rom_hdr;\n\tuint32_t *data_ptr = *d_ptr;\n\n\trom_hdr = (struct qla8xxx_minidump_entry_rdrom *)entry_hdr;\n\tfl_addr = le32_to_cpu(rom_hdr->read_addr);\n\tu32_count = le32_to_cpu(rom_hdr->read_data_size)/sizeof(uint32_t);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"[%s]: fl_addr: 0x%x, count: 0x%x\\n\",\n\t\t\t  __func__, fl_addr, u32_count));\n\n\trval = qla4_83xx_lockless_flash_read_u32(ha, fl_addr,\n\t\t\t\t\t\t (u8 *)(data_ptr), u32_count);\n\n\tif (rval == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Flash Read Error,Count=%d\\n\",\n\t\t\t   __func__, u32_count);\n\t\tgoto exit_process_rdrom;\n\t}\n\n\tdata_ptr += u32_count;\n\t*d_ptr = data_ptr;\n\nexit_process_rdrom:\n\treturn rval;\n}\n\n \nstatic int qla4_8xxx_collect_md_data(struct scsi_qla_host *ha)\n{\n\tint num_entry_hdr = 0;\n\tstruct qla8xxx_minidump_entry_hdr *entry_hdr;\n\tstruct qla4_8xxx_minidump_template_hdr *tmplt_hdr;\n\tuint32_t *data_ptr;\n\tuint32_t data_collected = 0;\n\tint i, rval = QLA_ERROR;\n\tuint64_t now;\n\tuint32_t timestamp;\n\n\tha->fw_dump_skip_size = 0;\n\tif (!ha->fw_dump) {\n\t\tql4_printk(KERN_INFO, ha, \"%s(%ld) No buffer to dump\\n\",\n\t\t\t   __func__, ha->host_no);\n\t\treturn rval;\n\t}\n\n\ttmplt_hdr = (struct qla4_8xxx_minidump_template_hdr *)\n\t\t\t\t\t\tha->fw_dump_tmplt_hdr;\n\tdata_ptr = (uint32_t *)((uint8_t *)ha->fw_dump +\n\t\t\t\t\t\tha->fw_dump_tmplt_size);\n\tdata_collected += ha->fw_dump_tmplt_size;\n\n\tnum_entry_hdr = tmplt_hdr->num_of_entries;\n\tql4_printk(KERN_INFO, ha, \"[%s]: starting data ptr: %p\\n\",\n\t\t   __func__, data_ptr);\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"[%s]: no of entry headers in Template: 0x%x\\n\",\n\t\t   __func__, num_entry_hdr);\n\tql4_printk(KERN_INFO, ha, \"[%s]: Capture Mask obtained: 0x%x\\n\",\n\t\t   __func__, ha->fw_dump_capture_mask);\n\tql4_printk(KERN_INFO, ha, \"[%s]: Total_data_size 0x%x, %d obtained\\n\",\n\t\t   __func__, ha->fw_dump_size, ha->fw_dump_size);\n\n\t \n\tnow = get_jiffies_64();\n\ttimestamp = (u32)(jiffies_to_msecs(now) / 1000);\n\ttmplt_hdr->driver_timestamp = timestamp;\n\n\tentry_hdr = (struct qla8xxx_minidump_entry_hdr *)\n\t\t\t\t\t(((uint8_t *)ha->fw_dump_tmplt_hdr) +\n\t\t\t\t\t tmplt_hdr->first_entry_offset);\n\n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\ttmplt_hdr->saved_state_array[QLA83XX_SS_OCM_WNDREG_INDEX] =\n\t\t\t\t\ttmplt_hdr->ocm_window_reg[ha->func_num];\n\n\t \n\tfor (i = 0; i < num_entry_hdr; i++) {\n\t\tif (data_collected > ha->fw_dump_size) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"Data collected: [0x%x], Total Dump size: [0x%x]\\n\",\n\t\t\t\t   data_collected, ha->fw_dump_size);\n\t\t\treturn rval;\n\t\t}\n\n\t\tif (!(entry_hdr->d_ctrl.entry_capture_mask &\n\t\t      ha->fw_dump_capture_mask)) {\n\t\t\tentry_hdr->d_ctrl.driver_flags |=\n\t\t\t\t\t\tQLA8XXX_DBG_SKIPPED_FLAG;\n\t\t\tgoto skip_nxt_entry;\n\t\t}\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Data collected: [0x%x], Dump size left:[0x%x]\\n\",\n\t\t\t\t  data_collected,\n\t\t\t\t  (ha->fw_dump_size - data_collected)));\n\n\t\t \n\t\tswitch (entry_hdr->entry_type) {\n\t\tcase QLA8XXX_RDEND:\n\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8XXX_CNTRL:\n\t\t\trval = qla4_8xxx_minidump_process_control(ha,\n\t\t\t\t\t\t\t\t  entry_hdr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\t\tgoto md_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA8XXX_RDCRB:\n\t\t\tqla4_8xxx_minidump_process_rdcrb(ha, entry_hdr,\n\t\t\t\t\t\t\t &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA8XXX_RDMEM:\n\t\t\trval = qla4_8xxx_minidump_process_rdmem(ha, entry_hdr,\n\t\t\t\t\t\t\t\t&data_ptr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\t\tgoto md_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA8XXX_BOARD:\n\t\tcase QLA8XXX_RDROM:\n\t\t\tif (is_qla8022(ha)) {\n\t\t\t\tqla4_82xx_minidump_process_rdrom(ha, entry_hdr,\n\t\t\t\t\t\t\t\t &data_ptr);\n\t\t\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\t\trval = qla4_83xx_minidump_process_rdrom(ha,\n\t\t\t\t\t\t\t\t    entry_hdr,\n\t\t\t\t\t\t\t\t    &data_ptr);\n\t\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\t\tqla4_8xxx_mark_entry_skipped(ha,\n\t\t\t\t\t\t\t\t     entry_hdr,\n\t\t\t\t\t\t\t\t     i);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA8XXX_L2DTG:\n\t\tcase QLA8XXX_L2ITG:\n\t\tcase QLA8XXX_L2DAT:\n\t\tcase QLA8XXX_L2INS:\n\t\t\trval = qla4_8xxx_minidump_process_l2tag(ha, entry_hdr,\n\t\t\t\t\t\t\t\t&data_ptr);\n\t\t\tif (rval != QLA_SUCCESS) {\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\t\tgoto md_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA8XXX_L1DTG:\n\t\tcase QLA8XXX_L1ITG:\n\t\tcase QLA8XXX_L1DAT:\n\t\tcase QLA8XXX_L1INS:\n\t\t\tqla4_8xxx_minidump_process_l1cache(ha, entry_hdr,\n\t\t\t\t\t\t\t   &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA8XXX_RDOCM:\n\t\t\tqla4_8xxx_minidump_process_rdocm(ha, entry_hdr,\n\t\t\t\t\t\t\t &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA8XXX_RDMUX:\n\t\t\tqla4_8xxx_minidump_process_rdmux(ha, entry_hdr,\n\t\t\t\t\t\t\t &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA8XXX_QUEUE:\n\t\t\tqla4_8xxx_minidump_process_queue(ha, entry_hdr,\n\t\t\t\t\t\t\t &data_ptr);\n\t\t\tbreak;\n\t\tcase QLA83XX_POLLRD:\n\t\t\tif (is_qla8022(ha)) {\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trval = qla83xx_minidump_process_pollrd(ha, entry_hdr,\n\t\t\t\t\t\t\t       &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA83XX_RDMUX2:\n\t\t\tif (is_qla8022(ha)) {\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tqla83xx_minidump_process_rdmux2(ha, entry_hdr,\n\t\t\t\t\t\t\t&data_ptr);\n\t\t\tbreak;\n\t\tcase QLA83XX_POLLRDMWR:\n\t\t\tif (is_qla8022(ha)) {\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trval = qla83xx_minidump_process_pollrdmwr(ha, entry_hdr,\n\t\t\t\t\t\t\t\t  &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8044_RDDFE:\n\t\t\trval = qla4_84xx_minidump_process_rddfe(ha, entry_hdr,\n\t\t\t\t\t\t\t\t&data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8044_RDMDIO:\n\t\t\trval = qla4_84xx_minidump_process_rdmdio(ha, entry_hdr,\n\t\t\t\t\t\t\t\t &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8044_POLLWR:\n\t\t\trval = qla4_84xx_minidump_process_pollwr(ha, entry_hdr,\n\t\t\t\t\t\t\t\t &data_ptr);\n\t\t\tif (rval != QLA_SUCCESS)\n\t\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\tbreak;\n\t\tcase QLA8XXX_RDNOP:\n\t\tdefault:\n\t\t\tqla4_8xxx_mark_entry_skipped(ha, entry_hdr, i);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata_collected = (uint8_t *)data_ptr - (uint8_t *)ha->fw_dump;\nskip_nxt_entry:\n\t\t \n\t\tentry_hdr = (struct qla8xxx_minidump_entry_hdr *)\n\t\t\t\t(((uint8_t *)entry_hdr) +\n\t\t\t\t entry_hdr->entry_size);\n\t}\n\n\tif ((data_collected + ha->fw_dump_skip_size) != ha->fw_dump_size) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"Dump data mismatch: Data collected: [0x%x], total_data_size:[0x%x]\\n\",\n\t\t\t   data_collected, ha->fw_dump_size);\n\t\trval = QLA_ERROR;\n\t\tgoto md_failed;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Leaving fn: %s Last entry: 0x%x\\n\",\n\t\t\t  __func__, i));\nmd_failed:\n\treturn rval;\n}\n\n \nstatic void qla4_8xxx_uevent_emit(struct scsi_qla_host *ha, u32 code)\n{\n\tchar event_string[40];\n\tchar *envp[] = { event_string, NULL };\n\n\tswitch (code) {\n\tcase QL4_UEVENT_CODE_FW_DUMP:\n\t\tsnprintf(event_string, sizeof(event_string), \"FW_DUMP=%lu\",\n\t\t\t ha->host_no);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tkobject_uevent_env(&(&ha->pdev->dev)->kobj, KOBJ_CHANGE, envp);\n}\n\nvoid qla4_8xxx_get_minidump(struct scsi_qla_host *ha)\n{\n\tif (ql4xenablemd && test_bit(AF_FW_RECOVERY, &ha->flags) &&\n\t    !test_bit(AF_82XX_FW_DUMPED, &ha->flags)) {\n\t\tif (!qla4_8xxx_collect_md_data(ha)) {\n\t\t\tqla4_8xxx_uevent_emit(ha, QL4_UEVENT_CODE_FW_DUMP);\n\t\t\tset_bit(AF_82XX_FW_DUMPED, &ha->flags);\n\t\t} else {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: Unable to collect minidump\\n\",\n\t\t\t\t   __func__);\n\t\t}\n\t}\n}\n\n \nint qla4_8xxx_device_bootstrap(struct scsi_qla_host *ha)\n{\n\tint rval = QLA_ERROR;\n\tint i;\n\tuint32_t old_count, count;\n\tint need_reset = 0;\n\n\tneed_reset = ha->isp_ops->need_reset(ha);\n\n\tif (need_reset) {\n\t\t \n\t\tif (test_bit(AF_FW_RECOVERY, &ha->flags))\n\t\t\tha->isp_ops->rom_lock_recovery(ha);\n\t} else  {\n\t\told_count = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_ALIVE_COUNTER);\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tmsleep(200);\n\t\t\tcount = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t    QLA8XXX_PEG_ALIVE_COUNTER);\n\t\t\tif (count != old_count) {\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t\tgoto dev_ready;\n\t\t\t}\n\t\t}\n\t\tha->isp_ops->rom_lock_recovery(ha);\n\t}\n\n\t \n\tql4_printk(KERN_INFO, ha, \"HW State: INITIALIZING\\n\");\n\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t    QLA8XXX_DEV_INITIALIZING);\n\n\tha->isp_ops->idc_unlock(ha);\n\n\tif (is_qla8022(ha))\n\t\tqla4_8xxx_get_minidump(ha);\n\n\trval = ha->isp_ops->restart_firmware(ha);\n\tha->isp_ops->idc_lock(ha);\n\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"HW State: FAILED\\n\");\n\t\tqla4_8xxx_clear_drv_active(ha);\n\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\treturn rval;\n\t}\n\ndev_ready:\n\tql4_printk(KERN_INFO, ha, \"HW State: READY\\n\");\n\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE, QLA8XXX_DEV_READY);\n\n\treturn rval;\n}\n\n \nstatic void\nqla4_82xx_need_reset_handler(struct scsi_qla_host *ha)\n{\n\tuint32_t dev_state, drv_state, drv_active;\n\tuint32_t active_mask = 0xFFFFFFFF;\n\tunsigned long reset_timeout;\n\n\tql4_printk(KERN_INFO, ha,\n\t\t\"Performing ISP error recovery\\n\");\n\n\tif (test_and_clear_bit(AF_ONLINE, &ha->flags)) {\n\t\tqla4_82xx_idc_unlock(ha);\n\t\tha->isp_ops->disable_intrs(ha);\n\t\tqla4_82xx_idc_lock(ha);\n\t}\n\n\tif (!test_bit(AF_8XXX_RST_OWNER, &ha->flags)) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s(%ld): reset acknowledged\\n\",\n\t\t\t\t  __func__, ha->host_no));\n\t\tqla4_8xxx_set_rst_ready(ha);\n\t} else {\n\t\tactive_mask = (~(1 << (ha->func_num * 4)));\n\t}\n\n\t \n\treset_timeout = jiffies + (ha->nx_reset_timeout * HZ);\n\n\tdrv_state = qla4_82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\tdrv_active = qla4_82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\n\tql4_printk(KERN_INFO, ha,\n\t\t\"%s(%ld): drv_state = 0x%x, drv_active = 0x%x\\n\",\n\t\t__func__, ha->host_no, drv_state, drv_active);\n\n\twhile (drv_state != (drv_active & active_mask)) {\n\t\tif (time_after_eq(jiffies, reset_timeout)) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"%s: RESET TIMEOUT! drv_state: 0x%08x, drv_active: 0x%08x\\n\",\n\t\t\t\t   DRIVER_NAME, drv_state, drv_active);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (test_bit(AF_8XXX_RST_OWNER, &ha->flags)) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"%s(%ld): drv_state = 0x%x, drv_active = 0x%x\\n\",\n\t\t\t\t   __func__, ha->host_no, drv_state,\n\t\t\t\t   drv_active);\n\t\t}\n\t\tqla4_82xx_idc_unlock(ha);\n\t\tmsleep(1000);\n\t\tqla4_82xx_idc_lock(ha);\n\n\t\tdrv_state = qla4_82xx_rd_32(ha, QLA82XX_CRB_DRV_STATE);\n\t\tdrv_active = qla4_82xx_rd_32(ha, QLA82XX_CRB_DRV_ACTIVE);\n\t}\n\n\t \n\tclear_bit(AF_8XXX_RST_OWNER, &ha->flags);\n\n\tdev_state = qla4_82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\tql4_printk(KERN_INFO, ha, \"Device state is 0x%x = %s\\n\", dev_state,\n\t\t   dev_state < MAX_STATES ? qdev_state[dev_state] : \"Unknown\");\n\n\t \n\tif (dev_state != QLA8XXX_DEV_INITIALIZING) {\n\t\tql4_printk(KERN_INFO, ha, \"HW State: COLD/RE-INIT\\n\");\n\t\tqla4_82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE, QLA8XXX_DEV_COLD);\n\t\tqla4_8xxx_set_rst_ready(ha);\n\t}\n}\n\n \nvoid\nqla4_8xxx_need_qsnt_handler(struct scsi_qla_host *ha)\n{\n\tha->isp_ops->idc_lock(ha);\n\tqla4_8xxx_set_qsnt_ready(ha);\n\tha->isp_ops->idc_unlock(ha);\n}\n\nstatic void qla4_82xx_set_idc_ver(struct scsi_qla_host *ha)\n{\n\tint idc_ver;\n\tuint32_t drv_active;\n\n\tdrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\n\tif (drv_active == (1 << (ha->func_num * 4))) {\n\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION,\n\t\t\t\t    QLA82XX_IDC_VERSION);\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: IDC version updated to %d\\n\", __func__,\n\t\t\t   QLA82XX_IDC_VERSION);\n\t} else {\n\t\tidc_ver = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION);\n\t\tif (QLA82XX_IDC_VERSION != idc_ver) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"%s: qla4xxx driver IDC version %d is not compatible with IDC version %d of other drivers!\\n\",\n\t\t\t\t   __func__, QLA82XX_IDC_VERSION, idc_ver);\n\t\t}\n\t}\n}\n\nstatic int qla4_83xx_set_idc_ver(struct scsi_qla_host *ha)\n{\n\tint idc_ver;\n\tuint32_t drv_active;\n\tint rval = QLA_SUCCESS;\n\n\tdrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\n\tif (drv_active == (1 << ha->func_num)) {\n\t\tidc_ver = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION);\n\t\tidc_ver &= (~0xFF);\n\t\tidc_ver |= QLA83XX_IDC_VER_MAJ_VALUE;\n\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION, idc_ver);\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: IDC version updated to %d\\n\", __func__,\n\t\t\t   idc_ver);\n\t} else {\n\t\tidc_ver = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_IDC_VERSION);\n\t\tidc_ver &= 0xFF;\n\t\tif (QLA83XX_IDC_VER_MAJ_VALUE != idc_ver) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"%s: qla4xxx driver IDC version %d is not compatible with IDC version %d of other drivers!\\n\",\n\t\t\t\t   __func__, QLA83XX_IDC_VER_MAJ_VALUE,\n\t\t\t\t   idc_ver);\n\t\t\trval = QLA_ERROR;\n\t\t\tgoto exit_set_idc_ver;\n\t\t}\n\t}\n\n\t \n\tidc_ver = qla4_83xx_rd_reg(ha, QLA83XX_CRB_IDC_VER_MINOR);\n\tidc_ver &= ~(0x03 << (ha->func_num * 2));\n\tidc_ver |= (QLA83XX_IDC_VER_MIN_VALUE << (ha->func_num * 2));\n\tqla4_83xx_wr_reg(ha, QLA83XX_CRB_IDC_VER_MINOR, idc_ver);\n\nexit_set_idc_ver:\n\treturn rval;\n}\n\nint qla4_8xxx_update_idc_reg(struct scsi_qla_host *ha)\n{\n\tuint32_t drv_active;\n\tint rval = QLA_SUCCESS;\n\n\tif (test_bit(AF_INIT_DONE, &ha->flags))\n\t\tgoto exit_update_idc_reg;\n\n\tha->isp_ops->idc_lock(ha);\n\tqla4_8xxx_set_drv_active(ha);\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tdrv_active = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DRV_ACTIVE);\n\t\tif ((drv_active == (1 << ha->func_num)) && !ql4xdontresethba)\n\t\t\tqla4_83xx_clear_idc_dontreset(ha);\n\t}\n\n\tif (is_qla8022(ha)) {\n\t\tqla4_82xx_set_idc_ver(ha);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\trval = qla4_83xx_set_idc_ver(ha);\n\t\tif (rval == QLA_ERROR)\n\t\t\tqla4_8xxx_clear_drv_active(ha);\n\t}\n\n\tha->isp_ops->idc_unlock(ha);\n\nexit_update_idc_reg:\n\treturn rval;\n}\n\n \nint qla4_8xxx_device_state_handler(struct scsi_qla_host *ha)\n{\n\tuint32_t dev_state;\n\tint rval = QLA_SUCCESS;\n\tunsigned long dev_init_timeout;\n\n\trval = qla4_8xxx_update_idc_reg(ha);\n\tif (rval == QLA_ERROR)\n\t\tgoto exit_state_handler;\n\n\tdev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Device state is 0x%x = %s\\n\",\n\t\t\t  dev_state, dev_state < MAX_STATES ?\n\t\t\t  qdev_state[dev_state] : \"Unknown\"));\n\n\t \n\tdev_init_timeout = jiffies + (ha->nx_dev_init_timeout * HZ);\n\n\tha->isp_ops->idc_lock(ha);\n\twhile (1) {\n\n\t\tif (time_after_eq(jiffies, dev_init_timeout)) {\n\t\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t\t   \"%s: Device Init Failed 0x%x = %s\\n\",\n\t\t\t\t   DRIVER_NAME,\n\t\t\t\t   dev_state, dev_state < MAX_STATES ?\n\t\t\t\t   qdev_state[dev_state] : \"Unknown\");\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t}\n\n\t\tdev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\n\t\tql4_printk(KERN_INFO, ha, \"Device state is 0x%x = %s\\n\",\n\t\t\t   dev_state, dev_state < MAX_STATES ?\n\t\t\t   qdev_state[dev_state] : \"Unknown\");\n\n\t\t \n\t\tswitch (dev_state) {\n\t\tcase QLA8XXX_DEV_READY:\n\t\t\tgoto exit;\n\t\tcase QLA8XXX_DEV_COLD:\n\t\t\trval = qla4_8xxx_device_bootstrap(ha);\n\t\t\tgoto exit;\n\t\tcase QLA8XXX_DEV_INITIALIZING:\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_NEED_RESET:\n\t\t\t \n\t\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\t\tqla4_83xx_need_reset_handler(ha);\n\t\t\t} else if (is_qla8022(ha)) {\n\t\t\t\tif (!ql4xdontresethba) {\n\t\t\t\t\tqla4_82xx_need_reset_handler(ha);\n\t\t\t\t\t \n\t\t\t\t\tdev_init_timeout = jiffies +\n\t\t\t\t\t\t(ha->nx_dev_init_timeout * HZ);\n\t\t\t\t} else {\n\t\t\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\t\t\tmsleep(1000);\n\t\t\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_NEED_QUIESCENT:\n\t\t\t \n\t\t\tqla4_8xxx_need_qsnt_handler(ha);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_QUIESCENT:\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tmsleep(1000);\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tbreak;\n\t\tcase QLA8XXX_DEV_FAILED:\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tqla4xxx_dead_adapter_cleanup(ha);\n\t\t\trval = QLA_ERROR;\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tgoto exit;\n\t\tdefault:\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tqla4xxx_dead_adapter_cleanup(ha);\n\t\t\trval = QLA_ERROR;\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tgoto exit;\n\t\t}\n\t}\nexit:\n\tha->isp_ops->idc_unlock(ha);\nexit_state_handler:\n\treturn rval;\n}\n\nint qla4_8xxx_load_risc(struct scsi_qla_host *ha)\n{\n\tint retval;\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\twritel(0, &ha->qla4_83xx_reg->risc_intr);\n\t\treadl(&ha->qla4_83xx_reg->risc_intr);\n\t} else if (is_qla8022(ha)) {\n\t\twritel(0, &ha->qla4_82xx_reg->host_int);\n\t\treadl(&ha->qla4_82xx_reg->host_int);\n\t}\n\n\tretval = qla4_8xxx_device_state_handler(ha);\n\n\t \n\tif (retval == QLA_SUCCESS)\n\t\tqla4xxx_init_rings(ha);\n\n\tif (retval == QLA_SUCCESS && !test_bit(AF_IRQ_ATTACHED, &ha->flags))\n\t\tretval = qla4xxx_request_irqs(ha);\n\n\treturn retval;\n}\n\n \n \n \n\n#define OPTROM_BURST_SIZE       0x1000\n#define OPTROM_BURST_DWORDS     (OPTROM_BURST_SIZE / 4)\n\n#define FARX_DATA_FLAG\tBIT_31\n#define FARX_ACCESS_FLASH_CONF\t0x7FFD0000\n#define FARX_ACCESS_FLASH_DATA\t0x7FF00000\n\nstatic inline uint32_t\nflash_conf_addr(struct ql82xx_hw_data *hw, uint32_t faddr)\n{\n\treturn hw->flash_conf_off | faddr;\n}\n\nstatic uint32_t *\nqla4_82xx_read_flash_data(struct scsi_qla_host *ha, uint32_t *dwptr,\n    uint32_t faddr, uint32_t length)\n{\n\tuint32_t i;\n\tuint32_t val;\n\tint loops = 0;\n\twhile ((qla4_82xx_rom_lock(ha) != 0) && (loops < 50000)) {\n\t\tudelay(100);\n\t\tcond_resched();\n\t\tloops++;\n\t}\n\tif (loops >= 50000) {\n\t\tql4_printk(KERN_WARNING, ha, \"ROM lock failed\\n\");\n\t\treturn dwptr;\n\t}\n\n\t \n\tfor (i = 0; i < length/4; i++, faddr += 4) {\n\t\tif (qla4_82xx_do_rom_fast_read(ha, faddr, &val)) {\n\t\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t    \"Do ROM fast read failed\\n\");\n\t\t\tgoto done_read;\n\t\t}\n\t\tdwptr[i] = cpu_to_le32(val);\n\t}\n\ndone_read:\n\tqla4_82xx_rom_unlock(ha);\n\treturn dwptr;\n}\n\n \nstatic uint8_t *\nqla4_82xx_read_optrom_data(struct scsi_qla_host *ha, uint8_t *buf,\n\t\tuint32_t offset, uint32_t length)\n{\n\tqla4_82xx_read_flash_data(ha, (uint32_t *)buf, offset, length);\n\treturn buf;\n}\n\nstatic int\nqla4_8xxx_find_flt_start(struct scsi_qla_host *ha, uint32_t *start)\n{\n\tconst char *loc, *locations[] = { \"DEF\", \"PCI\" };\n\n\t \n\n\t \n\tloc = locations[0];\n\t*start = FA_FLASH_LAYOUT_ADDR_82;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"FLTL[%s] = 0x%x.\\n\", loc, *start));\n\treturn QLA_SUCCESS;\n}\n\nstatic void\nqla4_8xxx_get_flt_info(struct scsi_qla_host *ha, uint32_t flt_addr)\n{\n\tconst char *loc, *locations[] = { \"DEF\", \"FLT\" };\n\tuint16_t *wptr;\n\tuint16_t cnt, chksum;\n\tuint32_t start, status;\n\tstruct qla_flt_header *flt;\n\tstruct qla_flt_region *region;\n\tstruct ql82xx_hw_data *hw = &ha->hw;\n\n\thw->flt_region_flt = flt_addr;\n\twptr = (uint16_t *)ha->request_ring;\n\tflt = (struct qla_flt_header *)ha->request_ring;\n\tregion = (struct qla_flt_region *)&flt[1];\n\n\tif (is_qla8022(ha)) {\n\t\tqla4_82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\n\t\t\t\t\t   flt_addr << 2, OPTROM_BURST_SIZE);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tstatus = qla4_83xx_flash_read_u32(ha, flt_addr << 2,\n\t\t\t\t\t\t  (uint8_t *)ha->request_ring,\n\t\t\t\t\t\t  0x400);\n\t\tif (status != QLA_SUCCESS)\n\t\t\tgoto no_flash_data;\n\t}\n\n\tif (*wptr == cpu_to_le16(0xffff))\n\t\tgoto no_flash_data;\n\tif (flt->version != cpu_to_le16(1)) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Unsupported FLT detected: \"\n\t\t\t\"version=0x%x length=0x%x checksum=0x%x.\\n\",\n\t\t\tle16_to_cpu(flt->version), le16_to_cpu(flt->length),\n\t\t\tle16_to_cpu(flt->checksum)));\n\t\tgoto no_flash_data;\n\t}\n\n\tcnt = (sizeof(struct qla_flt_header) + le16_to_cpu(flt->length)) >> 1;\n\tfor (chksum = 0; cnt; cnt--)\n\t\tchksum += le16_to_cpu(*wptr++);\n\tif (chksum) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Inconsistent FLT detected: \"\n\t\t\t\"version=0x%x length=0x%x checksum=0x%x.\\n\",\n\t\t\tle16_to_cpu(flt->version), le16_to_cpu(flt->length),\n\t\t\tchksum));\n\t\tgoto no_flash_data;\n\t}\n\n\tloc = locations[1];\n\tcnt = le16_to_cpu(flt->length) / sizeof(struct qla_flt_region);\n\tfor ( ; cnt; cnt--, region++) {\n\t\t \n\t\tstart = le32_to_cpu(region->start) >> 2;\n\n\t\tDEBUG3(ql4_printk(KERN_DEBUG, ha, \"FLT[%02x]: start=0x%x \"\n\t\t    \"end=0x%x size=0x%x.\\n\", le32_to_cpu(region->code), start,\n\t\t    le32_to_cpu(region->end) >> 2, le32_to_cpu(region->size)));\n\n\t\tswitch (le32_to_cpu(region->code) & 0xff) {\n\t\tcase FLT_REG_FDT:\n\t\t\thw->flt_region_fdt = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_BOOT_CODE_82:\n\t\t\thw->flt_region_boot = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_FW_82:\n\t\tcase FLT_REG_FW_82_1:\n\t\t\thw->flt_region_fw = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_BOOTLOAD_82:\n\t\t\thw->flt_region_bootload = start;\n\t\t\tbreak;\n\t\tcase FLT_REG_ISCSI_PARAM:\n\t\t\thw->flt_iscsi_param =  start;\n\t\t\tbreak;\n\t\tcase FLT_REG_ISCSI_CHAP:\n\t\t\thw->flt_region_chap =  start;\n\t\t\thw->flt_chap_size =  le32_to_cpu(region->size);\n\t\t\tbreak;\n\t\tcase FLT_REG_ISCSI_DDB:\n\t\t\thw->flt_region_ddb =  start;\n\t\t\thw->flt_ddb_size =  le32_to_cpu(region->size);\n\t\t\tbreak;\n\t\t}\n\t}\n\tgoto done;\n\nno_flash_data:\n\t \n\tloc = locations[0];\n\n\thw->flt_region_fdt      = FA_FLASH_DESCR_ADDR_82;\n\thw->flt_region_boot     = FA_BOOT_CODE_ADDR_82;\n\thw->flt_region_bootload = FA_BOOT_LOAD_ADDR_82;\n\thw->flt_region_fw       = FA_RISC_CODE_ADDR_82;\n\thw->flt_region_chap\t= FA_FLASH_ISCSI_CHAP >> 2;\n\thw->flt_chap_size\t= FA_FLASH_CHAP_SIZE;\n\thw->flt_region_ddb\t= FA_FLASH_ISCSI_DDB >> 2;\n\thw->flt_ddb_size\t= FA_FLASH_DDB_SIZE;\n\ndone:\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"FLT[%s]: flt=0x%x fdt=0x%x boot=0x%x bootload=0x%x fw=0x%x chap=0x%x chap_size=0x%x ddb=0x%x  ddb_size=0x%x\\n\",\n\t\t\t  loc, hw->flt_region_flt, hw->flt_region_fdt,\n\t\t\t  hw->flt_region_boot, hw->flt_region_bootload,\n\t\t\t  hw->flt_region_fw, hw->flt_region_chap,\n\t\t\t  hw->flt_chap_size, hw->flt_region_ddb,\n\t\t\t  hw->flt_ddb_size));\n}\n\nstatic void\nqla4_82xx_get_fdt_info(struct scsi_qla_host *ha)\n{\n#define FLASH_BLK_SIZE_4K       0x1000\n#define FLASH_BLK_SIZE_32K      0x8000\n#define FLASH_BLK_SIZE_64K      0x10000\n\tconst char *loc, *locations[] = { \"MID\", \"FDT\" };\n\tuint16_t cnt, chksum;\n\tuint16_t *wptr;\n\tstruct qla_fdt_layout *fdt;\n\tuint16_t mid = 0;\n\tuint16_t fid = 0;\n\tstruct ql82xx_hw_data *hw = &ha->hw;\n\n\thw->flash_conf_off = FARX_ACCESS_FLASH_CONF;\n\thw->flash_data_off = FARX_ACCESS_FLASH_DATA;\n\n\twptr = (uint16_t *)ha->request_ring;\n\tfdt = (struct qla_fdt_layout *)ha->request_ring;\n\tqla4_82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\n\t    hw->flt_region_fdt << 2, OPTROM_BURST_SIZE);\n\n\tif (*wptr == cpu_to_le16(0xffff))\n\t\tgoto no_flash_data;\n\n\tif (fdt->sig[0] != 'Q' || fdt->sig[1] != 'L' || fdt->sig[2] != 'I' ||\n\t    fdt->sig[3] != 'D')\n\t\tgoto no_flash_data;\n\n\tfor (cnt = 0, chksum = 0; cnt < sizeof(struct qla_fdt_layout) >> 1;\n\t    cnt++)\n\t\tchksum += le16_to_cpu(*wptr++);\n\n\tif (chksum) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Inconsistent FDT detected: \"\n\t\t    \"checksum=0x%x id=%c version=0x%x.\\n\", chksum, fdt->sig[0],\n\t\t    le16_to_cpu(fdt->version)));\n\t\tgoto no_flash_data;\n\t}\n\n\tloc = locations[1];\n\tmid = le16_to_cpu(fdt->man_id);\n\tfid = le16_to_cpu(fdt->id);\n\thw->fdt_wrt_disable = fdt->wrt_disable_bits;\n\thw->fdt_erase_cmd = flash_conf_addr(hw, 0x0300 | fdt->erase_cmd);\n\thw->fdt_block_size = le32_to_cpu(fdt->block_size);\n\n\tif (fdt->unprotect_sec_cmd) {\n\t\thw->fdt_unprotect_sec_cmd = flash_conf_addr(hw, 0x0300 |\n\t\t    fdt->unprotect_sec_cmd);\n\t\thw->fdt_protect_sec_cmd = fdt->protect_sec_cmd ?\n\t\t    flash_conf_addr(hw, 0x0300 | fdt->protect_sec_cmd) :\n\t\t    flash_conf_addr(hw, 0x0336);\n\t}\n\tgoto done;\n\nno_flash_data:\n\tloc = locations[0];\n\thw->fdt_block_size = FLASH_BLK_SIZE_64K;\ndone:\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"FDT[%s]: (0x%x/0x%x) erase=0x%x \"\n\t\t\"pro=%x upro=%x wrtd=0x%x blk=0x%x.\\n\", loc, mid, fid,\n\t\thw->fdt_erase_cmd, hw->fdt_protect_sec_cmd,\n\t\thw->fdt_unprotect_sec_cmd, hw->fdt_wrt_disable,\n\t\thw->fdt_block_size));\n}\n\nstatic void\nqla4_82xx_get_idc_param(struct scsi_qla_host *ha)\n{\n#define QLA82XX_IDC_PARAM_ADDR      0x003e885c\n\tuint32_t *wptr;\n\n\tif (!is_qla8022(ha))\n\t\treturn;\n\twptr = (uint32_t *)ha->request_ring;\n\tqla4_82xx_read_optrom_data(ha, (uint8_t *)ha->request_ring,\n\t\t\tQLA82XX_IDC_PARAM_ADDR , 8);\n\n\tif (*wptr == cpu_to_le32(0xffffffff)) {\n\t\tha->nx_dev_init_timeout = ROM_DEV_INIT_TIMEOUT;\n\t\tha->nx_reset_timeout = ROM_DRV_RESET_ACK_TIMEOUT;\n\t} else {\n\t\tha->nx_dev_init_timeout = le32_to_cpu(*wptr++);\n\t\tha->nx_reset_timeout = le32_to_cpu(*wptr);\n\t}\n\n\tDEBUG2(ql4_printk(KERN_DEBUG, ha,\n\t\t\"ha->nx_dev_init_timeout = %d\\n\", ha->nx_dev_init_timeout));\n\tDEBUG2(ql4_printk(KERN_DEBUG, ha,\n\t\t\"ha->nx_reset_timeout = %d\\n\", ha->nx_reset_timeout));\n\treturn;\n}\n\nvoid qla4_82xx_queue_mbox_cmd(struct scsi_qla_host *ha, uint32_t *mbx_cmd,\n\t\t\t      int in_count)\n{\n\tint i;\n\n\t \n\tfor (i = 1; i < in_count; i++)\n\t\twritel(mbx_cmd[i], &ha->qla4_82xx_reg->mailbox_in[i]);\n\n\t \n\twritel(mbx_cmd[0], &ha->qla4_82xx_reg->mailbox_in[0]);\n\treadl(&ha->qla4_82xx_reg->mailbox_in[0]);\n\twritel(HINT_MBX_INT_PENDING, &ha->qla4_82xx_reg->hint);\n\treadl(&ha->qla4_82xx_reg->hint);\n}\n\nvoid qla4_82xx_process_mbox_intr(struct scsi_qla_host *ha, int out_count)\n{\n\tint intr_status;\n\n\tintr_status = readl(&ha->qla4_82xx_reg->host_int);\n\tif (intr_status & ISRX_82XX_RISC_INT) {\n\t\tha->mbox_status_count = out_count;\n\t\tintr_status = readl(&ha->qla4_82xx_reg->host_status);\n\t\tha->isp_ops->interrupt_service_routine(ha, intr_status);\n\n\t\tif (test_bit(AF_INTERRUPTS_ON, &ha->flags) &&\n\t\t    (!ha->pdev->msi_enabled && !ha->pdev->msix_enabled))\n\t\t\tqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg,\n\t\t\t\t\t0xfbff);\n\t}\n}\n\nint\nqla4_8xxx_get_flash_info(struct scsi_qla_host *ha)\n{\n\tint ret;\n\tuint32_t flt_addr;\n\n\tret = qla4_8xxx_find_flt_start(ha, &flt_addr);\n\tif (ret != QLA_SUCCESS)\n\t\treturn ret;\n\n\tqla4_8xxx_get_flt_info(ha, flt_addr);\n\tif (is_qla8022(ha)) {\n\t\tqla4_82xx_get_fdt_info(ha);\n\t\tqla4_82xx_get_idc_param(ha);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tqla4_83xx_get_idc_param(ha);\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\n \nint\nqla4_8xxx_stop_firmware(struct scsi_qla_host *ha)\n{\n\tint status;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_STOP_FW;\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1,\n\t    &mbox_cmd[0], &mbox_sts[0]);\n\n\tDEBUG2(printk(\"scsi%ld: %s: status = %d\\n\", ha->host_no,\n\t    __func__, status));\n\treturn status;\n}\n\n \nint\nqla4_82xx_isp_reset(struct scsi_qla_host *ha)\n{\n\tint rval;\n\tuint32_t dev_state;\n\n\tqla4_82xx_idc_lock(ha);\n\tdev_state = qla4_82xx_rd_32(ha, QLA82XX_CRB_DEV_STATE);\n\n\tif (dev_state == QLA8XXX_DEV_READY) {\n\t\tql4_printk(KERN_INFO, ha, \"HW State: NEED RESET\\n\");\n\t\tqla4_82xx_wr_32(ha, QLA82XX_CRB_DEV_STATE,\n\t\t    QLA8XXX_DEV_NEED_RESET);\n\t\tset_bit(AF_8XXX_RST_OWNER, &ha->flags);\n\t} else\n\t\tql4_printk(KERN_INFO, ha, \"HW State: DEVICE INITIALIZING\\n\");\n\n\tqla4_82xx_idc_unlock(ha);\n\n\trval = qla4_8xxx_device_state_handler(ha);\n\n\tqla4_82xx_idc_lock(ha);\n\tqla4_8xxx_clear_rst_ready(ha);\n\tqla4_82xx_idc_unlock(ha);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"Clearing AF_RECOVERY in qla4_82xx_isp_reset\\n\");\n\t\tclear_bit(AF_FW_RECOVERY, &ha->flags);\n\t}\n\n\treturn rval;\n}\n\n \nint qla4_8xxx_get_sys_info(struct scsi_qla_host *ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tstruct mbx_sys_info *sys_info;\n\tdma_addr_t sys_info_dma;\n\tint status = QLA_ERROR;\n\n\tsys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),\n\t\t\t\t      &sys_info_dma, GFP_KERNEL);\n\tif (sys_info == NULL) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Unable to allocate dma buffer.\\n\",\n\t\t    ha->host_no, __func__));\n\t\treturn status;\n\t}\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tmbox_cmd[0] = MBOX_CMD_GET_SYS_INFO;\n\tmbox_cmd[1] = LSDW(sys_info_dma);\n\tmbox_cmd[2] = MSDW(sys_info_dma);\n\tmbox_cmd[4] = sizeof(*sys_info);\n\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 6, &mbox_cmd[0],\n\t    &mbox_sts[0]) != QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: GET_SYS_INFO failed\\n\",\n\t\t    ha->host_no, __func__));\n\t\tgoto exit_validate_mac82;\n\t}\n\n\t \n\tif (((is_qla8032(ha) || is_qla8042(ha)) ? mbox_sts[3] : mbox_sts[4]) <\n\t    offsetof(struct mbx_sys_info, reserved)) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: GET_SYS_INFO data receive\"\n\t\t    \" error (%x)\\n\", ha->host_no, __func__, mbox_sts[4]));\n\t\tgoto exit_validate_mac82;\n\t}\n\n\t \n\tha->port_num = sys_info->port_num;\n\tmemcpy(ha->my_mac, &sys_info->mac_addr[0],\n\t    min(sizeof(ha->my_mac), sizeof(sys_info->mac_addr)));\n\tmemcpy(ha->serial_number, &sys_info->serial_number,\n\t    min(sizeof(ha->serial_number), sizeof(sys_info->serial_number)));\n\tmemcpy(ha->model_name, &sys_info->board_id_str,\n\t       min(sizeof(ha->model_name), sizeof(sys_info->board_id_str)));\n\tha->phy_port_cnt = sys_info->phys_port_cnt;\n\tha->phy_port_num = sys_info->port_num;\n\tha->iscsi_pci_func_cnt = sys_info->iscsi_pci_func_cnt;\n\n\tDEBUG2(printk(\"scsi%ld: %s: mac %pM serial %s\\n\",\n\t    ha->host_no, __func__, ha->my_mac, ha->serial_number));\n\n\tstatus = QLA_SUCCESS;\n\nexit_validate_mac82:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,\n\t\t\t  sys_info_dma);\n\treturn status;\n}\n\n \n\nint qla4_8xxx_intr_enable(struct scsi_qla_host *ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s\\n\", __func__));\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\tmbox_cmd[0] = MBOX_CMD_ENABLE_INTRS;\n\tmbox_cmd[1] = INTR_ENABLE;\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\n\t\t&mbox_sts[0]) != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t    \"%s: MBOX_CMD_ENABLE_INTRS failed (0x%04x)\\n\",\n\t\t    __func__, mbox_sts[0]));\n\t\treturn QLA_ERROR;\n\t}\n\treturn QLA_SUCCESS;\n}\n\nint qla4_8xxx_intr_disable(struct scsi_qla_host *ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s\\n\", __func__));\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\tmbox_cmd[0] = MBOX_CMD_ENABLE_INTRS;\n\tmbox_cmd[1] = INTR_DISABLE;\n\tif (qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],\n\t    &mbox_sts[0]) != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\"%s: MBOX_CMD_ENABLE_INTRS failed (0x%04x)\\n\",\n\t\t\t__func__, mbox_sts[0]));\n\t\treturn QLA_ERROR;\n\t}\n\n\treturn QLA_SUCCESS;\n}\n\nvoid\nqla4_82xx_enable_intrs(struct scsi_qla_host *ha)\n{\n\tqla4_8xxx_intr_enable(ha);\n\n\tspin_lock_irq(&ha->hardware_lock);\n\t \n\tqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\n\tspin_unlock_irq(&ha->hardware_lock);\n\tset_bit(AF_INTERRUPTS_ON, &ha->flags);\n}\n\nvoid\nqla4_82xx_disable_intrs(struct scsi_qla_host *ha)\n{\n\tif (test_and_clear_bit(AF_INTERRUPTS_ON, &ha->flags))\n\t\tqla4_8xxx_intr_disable(ha);\n\n\tspin_lock_irq(&ha->hardware_lock);\n\t \n\tqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0x0400);\n\tspin_unlock_irq(&ha->hardware_lock);\n}\n\nint\nqla4_8xxx_enable_msix(struct scsi_qla_host *ha)\n{\n\tint ret;\n\n\tret = pci_alloc_irq_vectors(ha->pdev, QLA_MSIX_ENTRIES,\n\t\t\tQLA_MSIX_ENTRIES, PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"MSI-X: Failed to enable support -- %d/%d\\n\",\n\t\t    QLA_MSIX_ENTRIES, ret);\n\t\treturn ret;\n\t}\n\n\tret = request_irq(pci_irq_vector(ha->pdev, 0),\n\t\t\tqla4_8xxx_default_intr_handler, 0, \"qla4xxx (default)\",\n\t\t\tha);\n\tif (ret)\n\t\tgoto out_free_vectors;\n\n\tret = request_irq(pci_irq_vector(ha->pdev, 1),\n\t\t\tqla4_8xxx_msix_rsp_q, 0, \"qla4xxx (rsp_q)\", ha);\n\tif (ret)\n\t\tgoto out_free_default_irq;\n\n\treturn 0;\n\nout_free_default_irq:\n\tfree_irq(pci_irq_vector(ha->pdev, 0), ha);\nout_free_vectors:\n\tpci_free_irq_vectors(ha->pdev);\n\treturn ret;\n}\n\nint qla4_8xxx_check_init_adapter_retry(struct scsi_qla_host *ha)\n{\n\tint status = QLA_SUCCESS;\n\n\t \n\tif (!test_bit(AF_IRQ_ATTACHED, &ha->flags)) {\n\t\tql4_printk(KERN_WARNING, ha, \"%s: Skipping retry of adapter initialization as IRQs are not attached\\n\",\n\t\t\t   __func__);\n\t\tstatus = QLA_ERROR;\n\t\tgoto exit_init_adapter_failure;\n\t}\n\n\t \n\tqla4xxx_free_irqs(ha);\n\nexit_init_adapter_failure:\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}