{
  "module_name": "ql4_isr.c",
  "hash_id": "0a8e52e303f28eb9dd877da1833f61e0a77e987ca93e00a4c410e5fb713cdaa4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_isr.c",
  "human_readable_source": "\n \n\n#include \"ql4_def.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n#include \"ql4_inline.h\"\n\n \nstatic void qla4xxx_copy_sense(struct scsi_qla_host *ha,\n                               struct status_entry *sts_entry,\n                               struct srb *srb)\n{\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\tuint16_t sense_len;\n\n\tmemset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\n\tsense_len = le16_to_cpu(sts_entry->senseDataByteCnt);\n\tif (sense_len == 0) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"scsi%ld:%d:%d:%llu: %s:\"\n\t\t\t\t  \" sense len 0\\n\", ha->host_no,\n\t\t\t\t  cmd->device->channel, cmd->device->id,\n\t\t\t\t  cmd->device->lun, __func__));\n\t\tha->status_srb = NULL;\n\t\treturn;\n\t}\n\t \n\tsense_len = min_t(uint16_t, sense_len, SCSI_SENSE_BUFFERSIZE);\n\tsrb->req_sense_ptr = cmd->sense_buffer;\n\tsrb->req_sense_len = sense_len;\n\n\t \n\tsense_len = min_t(uint16_t, sense_len, IOCB_MAX_SENSEDATA_LEN);\n\tmemcpy(cmd->sense_buffer, sts_entry->senseData, sense_len);\n\n\tDEBUG2(printk(KERN_INFO \"scsi%ld:%d:%d:%llu: %s: sense key = %x, \"\n\t\t\"ASL= %02x, ASC/ASCQ = %02x/%02x\\n\", ha->host_no,\n\t\tcmd->device->channel, cmd->device->id,\n\t\tcmd->device->lun, __func__,\n\t\tsts_entry->senseData[2] & 0x0f,\n\t\tsts_entry->senseData[7],\n\t\tsts_entry->senseData[12],\n\t\tsts_entry->senseData[13]));\n\n\tDEBUG5(qla4xxx_dump_buffer(cmd->sense_buffer, sense_len));\n\tsrb->flags |= SRB_GOT_SENSE;\n\n\t \n\tsrb->req_sense_ptr += sense_len;\n\tsrb->req_sense_len -= sense_len;\n\tif (srb->req_sense_len != 0)\n\t\tha->status_srb = srb;\n\telse\n\t\tha->status_srb = NULL;\n}\n\n \nstatic void\nqla4xxx_status_cont_entry(struct scsi_qla_host *ha,\n\t\t\t  struct status_cont_entry *sts_cont)\n{\n\tstruct srb *srb = ha->status_srb;\n\tstruct scsi_cmnd *cmd;\n\tuint16_t sense_len;\n\n\tif (srb == NULL)\n\t\treturn;\n\n\tcmd = srb->cmd;\n\tif (cmd == NULL) {\n\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: Cmd already returned \"\n\t\t\t\"back to OS srb=%p srb->state:%d\\n\", ha->host_no,\n\t\t\t__func__, srb, srb->state));\n\t\tha->status_srb = NULL;\n\t\treturn;\n\t}\n\n\t \n\tsense_len = min_t(uint16_t, srb->req_sense_len,\n\t\t\t  IOCB_MAX_EXT_SENSEDATA_LEN);\n\tmemcpy(srb->req_sense_ptr, sts_cont->ext_sense_data, sense_len);\n\tDEBUG5(qla4xxx_dump_buffer(srb->req_sense_ptr, sense_len));\n\n\tsrb->req_sense_ptr += sense_len;\n\tsrb->req_sense_len -= sense_len;\n\n\t \n\tif (srb->req_sense_len == 0) {\n\t\tkref_put(&srb->srb_ref, qla4xxx_srb_compl);\n\t\tha->status_srb = NULL;\n\t}\n}\n\n \nstatic void qla4xxx_status_entry(struct scsi_qla_host *ha,\n\t\t\t\t struct status_entry *sts_entry)\n{\n\tuint8_t scsi_status;\n\tstruct scsi_cmnd *cmd;\n\tstruct srb *srb;\n\tstruct ddb_entry *ddb_entry;\n\tuint32_t residual;\n\n\tsrb = qla4xxx_del_from_active_array(ha, le32_to_cpu(sts_entry->handle));\n\tif (!srb) {\n\t\tql4_printk(KERN_WARNING, ha, \"%s invalid status entry: \"\n\t\t\t   \"handle=0x%0x, srb=%p\\n\", __func__,\n\t\t\t   sts_entry->handle, srb);\n\t\tif (is_qla80XX(ha))\n\t\t\tset_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\telse\n\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\treturn;\n\t}\n\n\tcmd = srb->cmd;\n\tif (cmd == NULL) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Command already returned back to \"\n\t\t\t      \"OS pkt->handle=%d srb=%p srb->state:%d\\n\",\n\t\t\t      ha->host_no, __func__, sts_entry->handle,\n\t\t\t      srb, srb->state));\n\t\tql4_printk(KERN_WARNING, ha, \"Command is NULL:\"\n\t\t    \" already returned to OS (srb=%p)\\n\", srb);\n\t\treturn;\n\t}\n\n\tddb_entry = srb->ddb;\n\tif (ddb_entry == NULL) {\n\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\tgoto status_entry_exit;\n\t}\n\n\tresidual = le32_to_cpu(sts_entry->residualByteCnt);\n\n\t \n\tscsi_status = sts_entry->scsiStatus;\n\tswitch (sts_entry->completionStatus) {\n\tcase SCS_COMPLETE:\n\n\t\tif (sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_OVER) {\n\t\t\tcmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sts_entry->iscsiFlags &ISCSI_FLAG_RESIDUAL_UNDER) {\n\t\t\tscsi_set_resid(cmd, residual);\n\t\t\tif (!scsi_status && ((scsi_bufflen(cmd) - residual) <\n\t\t\t\tcmd->underflow)) {\n\n\t\t\t\tcmd->result = DID_ERROR << 16;\n\n\t\t\t\tDEBUG2(printk(\"scsi%ld:%d:%d:%llu: %s: \"\n\t\t\t\t\t\"Mid-layer Data underrun0, \"\n\t\t\t\t\t\"xferlen = 0x%x, \"\n\t\t\t\t\t\"residual = 0x%x\\n\", ha->host_no,\n\t\t\t\t\tcmd->device->channel,\n\t\t\t\t\tcmd->device->id,\n\t\t\t\t\tcmd->device->lun, __func__,\n\t\t\t\t\tscsi_bufflen(cmd), residual));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcmd->result = DID_OK << 16 | scsi_status;\n\n\t\tif (scsi_status != SAM_STAT_CHECK_CONDITION)\n\t\t\tbreak;\n\n\t\t \n\t\tqla4xxx_copy_sense(ha, sts_entry, srb);\n\t\tbreak;\n\n\tcase SCS_INCOMPLETE:\n\t\t \n\t\tcmd->result = DID_ERROR << 16;\n\t\tbreak;\n\n\tcase SCS_RESET_OCCURRED:\n\t\tDEBUG2(printk(\"scsi%ld:%d:%d:%llu: %s: Device RESET occurred\\n\",\n\t\t\t      ha->host_no, cmd->device->channel,\n\t\t\t      cmd->device->id, cmd->device->lun, __func__));\n\n\t\tcmd->result = DID_RESET << 16;\n\t\tbreak;\n\n\tcase SCS_ABORTED:\n\t\tDEBUG2(printk(\"scsi%ld:%d:%d:%llu: %s: Abort occurred\\n\",\n\t\t\t      ha->host_no, cmd->device->channel,\n\t\t\t      cmd->device->id, cmd->device->lun, __func__));\n\n\t\tcmd->result = DID_RESET << 16;\n\t\tbreak;\n\n\tcase SCS_TIMEOUT:\n\t\tDEBUG2(printk(KERN_INFO \"scsi%ld:%d:%d:%llu: Timeout\\n\",\n\t\t\t      ha->host_no, cmd->device->channel,\n\t\t\t      cmd->device->id, cmd->device->lun));\n\n\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\n\t\t \n\t\tif (iscsi_is_session_online(ddb_entry->sess))\n\t\t\tqla4xxx_mark_device_missing(ddb_entry->sess);\n\t\tbreak;\n\n\tcase SCS_DATA_UNDERRUN:\n\tcase SCS_DATA_OVERRUN:\n\t\tif ((sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_OVER) ||\n\t\t     (sts_entry->completionStatus == SCS_DATA_OVERRUN)) {\n\t\t\tDEBUG2(printk(\"scsi%ld:%d:%d:%llu: %s: \" \"Data overrun\\n\",\n\t\t\t\t      ha->host_no,\n\t\t\t\t      cmd->device->channel, cmd->device->id,\n\t\t\t\t      cmd->device->lun, __func__));\n\n\t\t\tcmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tscsi_set_resid(cmd, residual);\n\n\t\tif (sts_entry->iscsiFlags & ISCSI_FLAG_RESIDUAL_UNDER) {\n\n\t\t\t \n\t\t\tif (!scsi_status && (scsi_bufflen(cmd) - residual) <\n\t\t\t    cmd->underflow) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"scsi%ld:%d:%d:%llu: %s: Mid-layer Data underrun, xferlen = 0x%x,residual = 0x%x\\n\",\n\t\t\t\t\t\t   ha->host_no,\n\t\t\t\t\t\t   cmd->device->channel,\n\t\t\t\t\t\t   cmd->device->id,\n\t\t\t\t\t\t   cmd->device->lun, __func__,\n\t\t\t\t\t\t   scsi_bufflen(cmd),\n\t\t\t\t\t\t   residual));\n\n\t\t\t\tcmd->result = DID_ERROR << 16;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t} else if (scsi_status != SAM_STAT_TASK_SET_FULL &&\n\t\t\t   scsi_status != SAM_STAT_BUSY) {\n\n\t\t\t \n\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld:%d:%d:%llu: %s: Dropped frame(s) detected (0x%x of 0x%x bytes).\\n\",\n\t\t\t\t\t  ha->host_no,\n\t\t\t\t\t  cmd->device->channel,\n\t\t\t\t\t  cmd->device->id,\n\t\t\t\t\t  cmd->device->lun, __func__,\n\t\t\t\t\t  residual,\n\t\t\t\t\t  scsi_bufflen(cmd)));\n\n\t\t\tcmd->result = DID_ERROR << 16 | scsi_status;\n\t\t\tgoto check_scsi_status;\n\t\t}\n\n\t\tcmd->result = DID_OK << 16 | scsi_status;\n\ncheck_scsi_status:\n\t\tif (scsi_status == SAM_STAT_CHECK_CONDITION)\n\t\t\tqla4xxx_copy_sense(ha, sts_entry, srb);\n\n\t\tbreak;\n\n\tcase SCS_DEVICE_LOGGED_OUT:\n\tcase SCS_DEVICE_UNAVAILABLE:\n\t\tDEBUG2(printk(KERN_INFO \"scsi%ld:%d:%d:%llu: SCS_DEVICE \"\n\t\t    \"state: 0x%x\\n\", ha->host_no,\n\t\t    cmd->device->channel, cmd->device->id,\n\t\t    cmd->device->lun, sts_entry->completionStatus));\n\t\t \n\t\tif (iscsi_is_session_online(ddb_entry->sess))\n\t\t\tqla4xxx_mark_device_missing(ddb_entry->sess);\n\n\t\tcmd->result = DID_TRANSPORT_DISRUPTED << 16;\n\t\tbreak;\n\n\tcase SCS_QUEUE_FULL:\n\t\t \n\t\tcmd->result = DID_OK << 16 | sts_entry->scsiStatus;\n\t\tDEBUG2(printk(\"scsi%ld:%d:%llu: %s: QUEUE FULL detected \"\n\t\t\t      \"compl=%02x, scsi=%02x, state=%02x, iFlags=%02x,\"\n\t\t\t      \" iResp=%02x\\n\", ha->host_no, cmd->device->id,\n\t\t\t      cmd->device->lun, __func__,\n\t\t\t      sts_entry->completionStatus,\n\t\t\t      sts_entry->scsiStatus, sts_entry->state_flags,\n\t\t\t      sts_entry->iscsiFlags,\n\t\t\t      sts_entry->iscsiResponse));\n\t\tbreak;\n\n\tdefault:\n\t\tcmd->result = DID_ERROR << 16;\n\t\tbreak;\n\t}\n\nstatus_entry_exit:\n\n\t \n\tsrb->cc_stat = sts_entry->completionStatus;\n\tif (ha->status_srb == NULL)\n\t\tkref_put(&srb->srb_ref, qla4xxx_srb_compl);\n}\n\n \nstatic void qla4xxx_passthru_status_entry(struct scsi_qla_host *ha,\n\t\t\t\t\t  struct passthru_status *sts_entry)\n{\n\tstruct iscsi_task *task;\n\tstruct ddb_entry *ddb_entry;\n\tstruct ql4_task_data *task_data;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_conn *conn;\n\titt_t itt;\n\tuint32_t fw_ddb_index;\n\n\titt = sts_entry->handle;\n\tfw_ddb_index = le32_to_cpu(sts_entry->target);\n\n\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);\n\n\tif (ddb_entry == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Invalid target index = 0x%x\\n\",\n\t\t\t   __func__, sts_entry->target);\n\t\treturn;\n\t}\n\n\tcls_conn = ddb_entry->conn;\n\tconn = cls_conn->dd_data;\n\tspin_lock(&conn->session->back_lock);\n\ttask = iscsi_itt_to_task(conn, itt);\n\tspin_unlock(&conn->session->back_lock);\n\n\tif (task == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Task is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\n\ttask_data = task->dd_data;\n\tmemcpy(&task_data->sts, sts_entry, sizeof(struct passthru_status));\n\tha->iocb_cnt -= task_data->iocb_req_cnt;\n\tqueue_work(ha->task_wq, &task_data->task_work);\n}\n\nstatic struct mrb *qla4xxx_del_mrb_from_active_array(struct scsi_qla_host *ha,\n\t\t\t\t\t\t     uint32_t index)\n{\n\tstruct mrb *mrb = NULL;\n\n\t \n\tif (index >= MAX_MRB)\n\t\treturn mrb;\n\n\tmrb = ha->active_mrb_array[index];\n\tha->active_mrb_array[index] = NULL;\n\tif (!mrb)\n\t\treturn mrb;\n\n\t \n\tha->iocb_cnt -= mrb->iocb_cnt;\n\n\treturn mrb;\n}\n\nstatic void qla4xxx_mbox_status_entry(struct scsi_qla_host *ha,\n\t\t\t\t      struct mbox_status_iocb *mbox_sts_entry)\n{\n\tstruct mrb *mrb;\n\tuint32_t status;\n\tuint32_t data_size;\n\n\tmrb = qla4xxx_del_mrb_from_active_array(ha,\n\t\t\t\t\tle32_to_cpu(mbox_sts_entry->handle));\n\n\tif (mrb == NULL) {\n\t\tql4_printk(KERN_WARNING, ha, \"%s: mrb[%d] is null\\n\", __func__,\n\t\t\t   mbox_sts_entry->handle);\n\t\treturn;\n\t}\n\n\tswitch (mrb->mbox_cmd) {\n\tcase MBOX_CMD_PING:\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: mbox_cmd = 0x%x, \"\n\t\t\t\t  \"mbox_sts[0] = 0x%x, mbox_sts[6] = 0x%x\\n\",\n\t\t\t\t  __func__, mrb->mbox_cmd,\n\t\t\t\t  mbox_sts_entry->out_mbox[0],\n\t\t\t\t  mbox_sts_entry->out_mbox[6]));\n\n\t\tif (mbox_sts_entry->out_mbox[0] == MBOX_STS_COMMAND_COMPLETE)\n\t\t\tstatus = ISCSI_PING_SUCCESS;\n\t\telse\n\t\t\tstatus = mbox_sts_entry->out_mbox[6];\n\n\t\tdata_size = sizeof(mbox_sts_entry->out_mbox);\n\n\t\tqla4xxx_post_ping_evt_work(ha, status, mrb->pid, data_size,\n\t\t\t\t\t(uint8_t *) mbox_sts_entry->out_mbox);\n\t\tbreak;\n\n\tdefault:\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha, \"%s: invalid mbox_cmd = \"\n\t\t\t\t  \"0x%x\\n\", __func__, mrb->mbox_cmd));\n\t}\n\n\tkfree(mrb);\n\treturn;\n}\n\n \nvoid qla4xxx_process_response_queue(struct scsi_qla_host *ha)\n{\n\tstruct srb *srb = NULL;\n\tstruct status_entry *sts_entry;\n\n\t \n\twhile ((ha->response_ptr->signature != RESPONSE_PROCESSED)) {\n\t\tsts_entry = (struct status_entry *) ha->response_ptr;\n\n\t\t \n\t\tif (ha->response_out == (RESPONSE_QUEUE_DEPTH - 1)) {\n\t\t\tha->response_out = 0;\n\t\t\tha->response_ptr = ha->response_ring;\n\t\t} else {\n\t\t\tha->response_out++;\n\t\t\tha->response_ptr++;\n\t\t}\n\n\t\t \n\t\tswitch (sts_entry->hdr.entryType) {\n\t\tcase ET_STATUS:\n\t\t\t \n\t\t\tqla4xxx_status_entry(ha, sts_entry);\n\t\t\tbreak;\n\n\t\tcase ET_PASSTHRU_STATUS:\n\t\t\tif (sts_entry->hdr.systemDefined == SD_ISCSI_PDU)\n\t\t\t\tqla4xxx_passthru_status_entry(ha,\n\t\t\t\t\t(struct passthru_status *)sts_entry);\n\t\t\telse\n\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t   \"%s: Invalid status received\\n\",\n\t\t\t\t\t   __func__);\n\n\t\t\tbreak;\n\n\t\tcase ET_STATUS_CONTINUATION:\n\t\t\tqla4xxx_status_cont_entry(ha,\n\t\t\t\t(struct status_cont_entry *) sts_entry);\n\t\t\tbreak;\n\n\t\tcase ET_COMMAND:\n\t\t\t \n\n\t\t\tsrb = qla4xxx_del_from_active_array(ha,\n\t\t\t\t\t\t    le32_to_cpu(sts_entry->\n\t\t\t\t\t\t\t\thandle));\n\t\t\tif (srb == NULL)\n\t\t\t\tgoto exit_prq_invalid_handle;\n\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: FW device queue full, \"\n\t\t\t\t      \"srb %p\\n\", ha->host_no, __func__, srb));\n\n\t\t\t \n\t\t\tsrb->cmd->result = DID_BUS_BUSY << 16;\n\t\t\tkref_put(&srb->srb_ref, qla4xxx_srb_compl);\n\t\t\tbreak;\n\n\t\tcase ET_CONTINUE:\n\t\t\t \n\t\t\tDEBUG2(printk(\"scsi%ld: %s: Continuation entry - \"\n\t\t\t\t      \"ignoring\\n\", ha->host_no, __func__));\n\t\t\tbreak;\n\n\t\tcase ET_MBOX_STATUS:\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"%s: mbox status IOCB\\n\", __func__));\n\t\t\tqla4xxx_mbox_status_entry(ha,\n\t\t\t\t\t(struct mbox_status_iocb *)sts_entry);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tDEBUG2(printk(\"scsi%ld: %s: Invalid entry %x in \"\n\t\t\t\t      \"response queue \\n\", ha->host_no,\n\t\t\t\t      __func__,\n\t\t\t\t      sts_entry->hdr.entryType));\n\t\t\tgoto exit_prq_error;\n\t\t}\n\t\t((struct response *)sts_entry)->signature = RESPONSE_PROCESSED;\n\t\twmb();\n\t}\n\n\t \n\tha->isp_ops->complete_iocb(ha);\n\n\treturn;\n\nexit_prq_invalid_handle:\n\tDEBUG2(printk(\"scsi%ld: %s: Invalid handle(srb)=%p type=%x IOCS=%x\\n\",\n\t\t      ha->host_no, __func__, srb, sts_entry->hdr.entryType,\n\t\t      sts_entry->completionStatus));\n\nexit_prq_error:\n\tha->isp_ops->complete_iocb(ha);\n\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n}\n\n \nstatic int qla4_83xx_loopback_in_progress(struct scsi_qla_host *ha)\n{\n\tint rval = 1;\n\n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tif ((ha->idc_info.info2 & ENABLE_INTERNAL_LOOPBACK) ||\n\t\t    (ha->idc_info.info2 & ENABLE_EXTERNAL_LOOPBACK)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"%s: Loopback diagnostics in progress\\n\",\n\t\t\t\t\t  __func__));\n\t\t\trval = 1;\n\t\t} else {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"%s: Loopback diagnostics not in progress\\n\",\n\t\t\t\t\t  __func__));\n\t\t\trval = 0;\n\t\t}\n\t}\n\n\treturn rval;\n}\n\nstatic void qla4xxx_update_ipaddr_state(struct scsi_qla_host *ha,\n\t\t\t\t\tuint32_t ipaddr_idx,\n\t\t\t\t\tuint32_t ipaddr_fw_state)\n{\n\tuint8_t ipaddr_state;\n\tuint8_t ip_idx;\n\n\tip_idx = ipaddr_idx & 0xF;\n\tipaddr_state = qla4xxx_set_ipaddr_state((uint8_t)ipaddr_fw_state);\n\n\tswitch (ip_idx) {\n\tcase 0:\n\t\tha->ip_config.ipv4_addr_state = ipaddr_state;\n\t\tbreak;\n\tcase 1:\n\t\tha->ip_config.ipv6_link_local_state = ipaddr_state;\n\t\tbreak;\n\tcase 2:\n\t\tha->ip_config.ipv6_addr0_state = ipaddr_state;\n\t\tbreak;\n\tcase 3:\n\t\tha->ip_config.ipv6_addr1_state = ipaddr_state;\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_INFO, ha, \"%s: Invalid IPADDR index %d\\n\",\n\t\t\t   __func__, ip_idx);\n\t}\n}\n\nstatic void qla4xxx_default_router_changed(struct scsi_qla_host *ha,\n\t\t\t\t\t   uint32_t *mbox_sts)\n{\n\tmemcpy(&ha->ip_config.ipv6_default_router_addr.s6_addr32[0],\n\t       &mbox_sts[2], sizeof(uint32_t));\n\tmemcpy(&ha->ip_config.ipv6_default_router_addr.s6_addr32[1],\n\t       &mbox_sts[3], sizeof(uint32_t));\n\tmemcpy(&ha->ip_config.ipv6_default_router_addr.s6_addr32[2],\n\t       &mbox_sts[4], sizeof(uint32_t));\n\tmemcpy(&ha->ip_config.ipv6_default_router_addr.s6_addr32[3],\n\t       &mbox_sts[5], sizeof(uint32_t));\n}\n\n \nstatic void qla4xxx_isr_decode_mailbox(struct scsi_qla_host * ha,\n\t\t\t\t       uint32_t mbox_status)\n{\n\tint i;\n\tuint32_t mbox_sts[MBOX_AEN_REG_COUNT];\n\t__le32 __iomem *mailbox_out;\n\tuint32_t opcode = 0;\n\n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\tmailbox_out = &ha->qla4_83xx_reg->mailbox_out[0];\n\telse if (is_qla8022(ha))\n\t\tmailbox_out = &ha->qla4_82xx_reg->mailbox_out[0];\n\telse\n\t\tmailbox_out = &ha->reg->mailbox[0];\n\n\tif ((mbox_status == MBOX_STS_BUSY) ||\n\t    (mbox_status == MBOX_STS_INTERMEDIATE_COMPLETION) ||\n\t    (mbox_status >> 12 == MBOX_COMPLETION_STATUS)) {\n\t\tha->mbox_status[0] = mbox_status;\n\n\t\tif (test_bit(AF_MBOX_COMMAND, &ha->flags)) {\n\t\t\t \n\t\t\tfor (i = 0; i < ha->mbox_status_count; i++)\n\t\t\t\tha->mbox_status[i] = readl(&mailbox_out[i]);\n\n\t\t\tset_bit(AF_MBOX_COMMAND_DONE, &ha->flags);\n\n\t\t\tif (test_bit(AF_MBOX_COMMAND_NOPOLL, &ha->flags))\n\t\t\t\tcomplete(&ha->mbx_intr_comp);\n\t\t}\n\t} else if (mbox_status >> 12 == MBOX_ASYNC_EVENT_STATUS) {\n\t\tfor (i = 0; i < MBOX_AEN_REG_COUNT; i++)\n\t\t\tmbox_sts[i] = readl(&mailbox_out[i]);\n\n\t\t \n\t\tif (ha->aen_log.count < MAX_AEN_ENTRIES) {\n\t\t\tfor (i = 0; i < MBOX_AEN_REG_COUNT; i++)\n\t\t\t\tha->aen_log.entry[ha->aen_log.count].mbox_sts[i] =\n\t\t\t\t    mbox_sts[i];\n\t\t\tha->aen_log.count++;\n\t\t}\n\t\tswitch (mbox_status) {\n\t\tcase MBOX_ASTS_SYSTEM_ERROR:\n\t\t\t \n\t\t\tql4_printk(KERN_INFO, ha, \"%s: System Err\\n\", __func__);\n\t\t\tqla4xxx_dump_registers(ha);\n\n\t\t\tif ((is_qla8022(ha) && ql4xdontresethba) ||\n\t\t\t    ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t\t\t     qla4_83xx_idc_dontreset(ha))) {\n\t\t\t\tDEBUG2(printk(\"scsi%ld: %s:Don't Reset HBA\\n\",\n\t\t\t\t    ha->host_no, __func__));\n\t\t\t} else {\n\t\t\t\tset_bit(AF_GET_CRASH_RECORD, &ha->flags);\n\t\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_REQUEST_TRANSFER_ERROR:\n\t\tcase MBOX_ASTS_RESPONSE_TRANSFER_ERROR:\n\t\tcase MBOX_ASTS_NVRAM_INVALID:\n\t\tcase MBOX_ASTS_IP_ADDRESS_CHANGED:\n\t\tcase MBOX_ASTS_DHCP_LEASE_EXPIRED:\n\t\t\tDEBUG2(printk(\"scsi%ld: AEN %04x, ERROR Status, \"\n\t\t\t\t      \"Reset HA\\n\", ha->host_no, mbox_status));\n\t\t\tif (is_qla80XX(ha))\n\t\t\t\tset_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t&ha->dpc_flags);\n\t\t\telse\n\t\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_LINK_UP:\n\t\t\tset_bit(AF_LINK_UP, &ha->flags);\n\t\t\tif (test_bit(AF_INIT_DONE, &ha->flags))\n\t\t\t\tset_bit(DPC_LINK_CHANGED, &ha->dpc_flags);\n\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: LINK UP\\n\", __func__);\n\t\t\tqla4xxx_post_aen_work(ha, ISCSI_EVENT_LINKUP,\n\t\t\t\t\t      sizeof(mbox_sts),\n\t\t\t\t\t      (uint8_t *) mbox_sts);\n\n\t\t\tif ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t\t\t    ha->notify_link_up_comp)\n\t\t\t\tcomplete(&ha->link_up_comp);\n\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_LINK_DOWN:\n\t\t\tclear_bit(AF_LINK_UP, &ha->flags);\n\t\t\tif (test_bit(AF_INIT_DONE, &ha->flags)) {\n\t\t\t\tset_bit(DPC_LINK_CHANGED, &ha->dpc_flags);\n\t\t\t\tqla4xxx_wake_dpc(ha);\n\t\t\t}\n\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: LINK DOWN\\n\", __func__);\n\t\t\tqla4xxx_post_aen_work(ha, ISCSI_EVENT_LINKDOWN,\n\t\t\t\t\t      sizeof(mbox_sts),\n\t\t\t\t\t      (uint8_t *) mbox_sts);\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_HEARTBEAT:\n\t\t\tha->seconds_since_last_heartbeat = 0;\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_DHCP_LEASE_ACQUIRED:\n\t\t\tDEBUG2(printk(\"scsi%ld: AEN %04x DHCP LEASE \"\n\t\t\t\t      \"ACQUIRED\\n\", ha->host_no, mbox_status));\n\t\t\tset_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags);\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_PROTOCOL_STATISTIC_ALARM:\n\t\tcase MBOX_ASTS_SCSI_COMMAND_PDU_REJECTED:  \n\t\tcase MBOX_ASTS_UNSOLICITED_PDU_RECEIVED:   \n\t\tcase MBOX_ASTS_IPSEC_SYSTEM_FATAL_ERROR:\n\t\tcase MBOX_ASTS_SUBNET_STATE_CHANGE:\n\t\tcase MBOX_ASTS_DUPLICATE_IP:\n\t\t\t \n\t\t\tDEBUG2(printk(\"scsi%ld: AEN %04x\\n\", ha->host_no,\n\t\t\t\t      mbox_status));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_IP_ADDR_STATE_CHANGED:\n\t\t\tprintk(\"scsi%ld: AEN %04x, mbox_sts[2]=%04x, \"\n\t\t\t    \"mbox_sts[3]=%04x\\n\", ha->host_no, mbox_sts[0],\n\t\t\t    mbox_sts[2], mbox_sts[3]);\n\n\t\t\tqla4xxx_update_ipaddr_state(ha, mbox_sts[5],\n\t\t\t\t\t\t    mbox_sts[3]);\n\t\t\t \n\t\t\tif ((mbox_sts[3] == IP_ADDRSTATE_PREFERRED) &&\n\t\t\t    ((mbox_sts[2] == IP_ADDRSTATE_TENTATIVE) ||\n\t\t\t     (mbox_sts[2] == IP_ADDRSTATE_ACQUIRING))) {\n\t\t\t\tset_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags);\n\t\t\t} else if ((mbox_sts[3] == IP_ADDRSTATE_ACQUIRING) &&\n\t\t\t\t   (mbox_sts[2] == IP_ADDRSTATE_PREFERRED)) {\n\t\t\t\tif (is_qla80XX(ha))\n\t\t\t\t\tset_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t\t&ha->dpc_flags);\n\t\t\t\telse\n\t\t\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t} else if (mbox_sts[3] == IP_ADDRSTATE_DISABLING) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ACB in disabling state\\n\",\n\t\t\t\t\t   ha->host_no, __func__);\n\t\t\t} else if (mbox_sts[3] == IP_ADDRSTATE_UNCONFIGURED) {\n\t\t\t\tcomplete(&ha->disable_acb_comp);\n\t\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ACB state unconfigured\\n\",\n\t\t\t\t\t   ha->host_no, __func__);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_IPV6_LINK_MTU_CHANGE:\n\t\tcase MBOX_ASTS_IPV6_AUTO_PREFIX_IGNORED:\n\t\tcase MBOX_ASTS_IPV6_ND_LOCAL_PREFIX_IGNORED:\n\t\t\t \n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"scsi%ld: AEN %04x\\n\",\n\t\t\t\t\t  ha->host_no, mbox_status));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_ICMPV6_ERROR_MSG_RCVD:\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x, IPv6 ERROR, \"\n\t\t\t\t\t  \"mbox_sts[1]=%08x, mbox_sts[2]=%08x, mbox_sts[3}=%08x, mbox_sts[4]=%08x mbox_sts[5]=%08x\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0], mbox_sts[1],\n\t\t\t\t\t  mbox_sts[2], mbox_sts[3], mbox_sts[4],\n\t\t\t\t\t  mbox_sts[5]));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_MAC_ADDRESS_CHANGED:\n\t\tcase MBOX_ASTS_DNS:\n\t\t\t \n\t\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: AEN %04x, \"\n\t\t\t\t      \"mbox_sts[1]=%04x, mbox_sts[2]=%04x\\n\",\n\t\t\t\t      ha->host_no, mbox_sts[0],\n\t\t\t\t      mbox_sts[1], mbox_sts[2]));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_SELF_TEST_FAILED:\n\t\tcase MBOX_ASTS_LOGIN_FAILED:\n\t\t\t \n\t\t\tDEBUG2(printk(\"scsi%ld: AEN %04x, mbox_sts[1]=%04x, \"\n\t\t\t\t      \"mbox_sts[2]=%04x, mbox_sts[3]=%04x\\n\",\n\t\t\t\t      ha->host_no, mbox_sts[0], mbox_sts[1],\n\t\t\t\t      mbox_sts[2], mbox_sts[3]));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_DATABASE_CHANGED:\n\t\t\t \n\t\t\tif (ha->aen_q_count > 0) {\n\n\t\t\t\t \n\t\t\t\tha->aen_q_count--;\n\n\t\t\t\tfor (i = 0; i < MBOX_AEN_REG_COUNT; i++)\n\t\t\t\t\tha->aen_q[ha->aen_in].mbox_sts[i] =\n\t\t\t\t\t    mbox_sts[i];\n\n\t\t\t\t \n\t\t\t\tDEBUG2(printk(\"scsi%ld: AEN[%d] %04x queued \"\n\t\t\t\t\t      \"mb1:0x%x mb2:0x%x mb3:0x%x \"\n\t\t\t\t\t      \"mb4:0x%x mb5:0x%x\\n\",\n\t\t\t\t\t      ha->host_no, ha->aen_in,\n\t\t\t\t\t      mbox_sts[0], mbox_sts[1],\n\t\t\t\t\t      mbox_sts[2], mbox_sts[3],\n\t\t\t\t\t      mbox_sts[4], mbox_sts[5]));\n\n\t\t\t\t \n\t\t\t\tha->aen_in++;\n\t\t\t\tif (ha->aen_in == MAX_AEN_ENTRIES)\n\t\t\t\t\tha->aen_in = 0;\n\n\t\t\t\t \n\t\t\t\tset_bit(DPC_AEN, &ha->dpc_flags);\n\t\t\t} else {\n\t\t\t\tDEBUG2(printk(\"scsi%ld: %s: aen %04x, queue \"\n\t\t\t\t\t      \"overflowed!  AEN LOST!!\\n\",\n\t\t\t\t\t      ha->host_no, __func__,\n\t\t\t\t\t      mbox_sts[0]));\n\n\t\t\t\tDEBUG2(printk(\"scsi%ld: DUMP AEN QUEUE\\n\",\n\t\t\t\t\t      ha->host_no));\n\n\t\t\t\tfor (i = 0; i < MAX_AEN_ENTRIES; i++) {\n\t\t\t\t\tDEBUG2(printk(\"AEN[%d] %04x %04x %04x \"\n\t\t\t\t\t\t      \"%04x\\n\", i, mbox_sts[0],\n\t\t\t\t\t\t      mbox_sts[1], mbox_sts[2],\n\t\t\t\t\t\t      mbox_sts[3]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_TXSCVR_INSERTED:\n\t\t\tDEBUG2(printk(KERN_WARNING\n\t\t\t    \"scsi%ld: AEN %04x Transceiver\"\n\t\t\t    \" inserted\\n\",  ha->host_no, mbox_sts[0]));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_TXSCVR_REMOVED:\n\t\t\tDEBUG2(printk(KERN_WARNING\n\t\t\t    \"scsi%ld: AEN %04x Transceiver\"\n\t\t\t    \" removed\\n\",  ha->host_no, mbox_sts[0]));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_IDC_REQUEST_NOTIFICATION:\n\t\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"scsi%ld: AEN %04x, mbox_sts[1]=%08x, mbox_sts[2]=%08x, mbox_sts[3]=%08x, mbox_sts[4]=%08x\\n\",\n\t\t\t\t\t\t  ha->host_no, mbox_sts[0],\n\t\t\t\t\t\t  mbox_sts[1], mbox_sts[2],\n\t\t\t\t\t\t  mbox_sts[3], mbox_sts[4]));\n\t\t\t\topcode = mbox_sts[1] >> 16;\n\t\t\t\tif ((opcode == MBOX_CMD_SET_PORT_CONFIG) ||\n\t\t\t\t    (opcode == MBOX_CMD_PORT_RESET)) {\n\t\t\t\t\tset_bit(DPC_POST_IDC_ACK,\n\t\t\t\t\t\t&ha->dpc_flags);\n\t\t\t\t\tha->idc_info.request_desc = mbox_sts[1];\n\t\t\t\t\tha->idc_info.info1 = mbox_sts[2];\n\t\t\t\t\tha->idc_info.info2 = mbox_sts[3];\n\t\t\t\t\tha->idc_info.info3 = mbox_sts[4];\n\t\t\t\t\tqla4xxx_wake_dpc(ha);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_IDC_COMPLETE:\n\t\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"scsi%ld: AEN %04x, mbox_sts[1]=%08x, mbox_sts[2]=%08x, mbox_sts[3]=%08x, mbox_sts[4]=%08x\\n\",\n\t\t\t\t\t\t  ha->host_no, mbox_sts[0],\n\t\t\t\t\t\t  mbox_sts[1], mbox_sts[2],\n\t\t\t\t\t\t  mbox_sts[3], mbox_sts[4]));\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"scsi:%ld: AEN %04x IDC Complete notification\\n\",\n\t\t\t\t\t\t  ha->host_no, mbox_sts[0]));\n\n\t\t\t\topcode = mbox_sts[1] >> 16;\n\t\t\t\tif (ha->notify_idc_comp)\n\t\t\t\t\tcomplete(&ha->idc_comp);\n\n\t\t\t\tif ((opcode == MBOX_CMD_SET_PORT_CONFIG) ||\n\t\t\t\t    (opcode == MBOX_CMD_PORT_RESET))\n\t\t\t\t\tha->idc_info.info2 = mbox_sts[3];\n\n\t\t\t\tif (qla4_83xx_loopback_in_progress(ha)) {\n\t\t\t\t\tset_bit(AF_LOOPBACK, &ha->flags);\n\t\t\t\t} else {\n\t\t\t\t\tclear_bit(AF_LOOPBACK, &ha->flags);\n\t\t\t\t\tif (ha->saved_acb)\n\t\t\t\t\t\tset_bit(DPC_RESTORE_ACB,\n\t\t\t\t\t\t\t&ha->dpc_flags);\n\t\t\t\t}\n\t\t\t\tqla4xxx_wake_dpc(ha);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_IPV6_DEFAULT_ROUTER_CHANGED:\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x, mbox_sts[1]=%08x, mbox_sts[2]=%08x, mbox_sts[3]=%08x, mbox_sts[4]=%08x mbox_sts[5]=%08x\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0], mbox_sts[1],\n\t\t\t\t\t  mbox_sts[2], mbox_sts[3], mbox_sts[4],\n\t\t\t\t\t  mbox_sts[5]));\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x Received IPv6 default router changed notification\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0]));\n\t\t\tqla4xxx_default_router_changed(ha, mbox_sts);\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_IDC_TIME_EXTEND_NOTIFICATION:\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x, mbox_sts[1]=%08x, mbox_sts[2]=%08x, mbox_sts[3]=%08x, mbox_sts[4]=%08x mbox_sts[5]=%08x\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0], mbox_sts[1],\n\t\t\t\t\t  mbox_sts[2], mbox_sts[3], mbox_sts[4],\n\t\t\t\t\t  mbox_sts[5]));\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x Received IDC Extend Timeout notification\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0]));\n\t\t\t \n\t\t\tha->idc_extend_tmo = mbox_sts[1];\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_INITIALIZATION_FAILED:\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x, mbox_sts[3]=%08x\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0],\n\t\t\t\t\t  mbox_sts[3]));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_SYSTEM_WARNING_EVENT:\n\t\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x, mbox_sts[1]=%08x, mbox_sts[2]=%08x, mbox_sts[3]=%08x, mbox_sts[4]=%08x mbox_sts[5]=%08x\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0], mbox_sts[1],\n\t\t\t\t\t  mbox_sts[2], mbox_sts[3], mbox_sts[4],\n\t\t\t\t\t  mbox_sts[5]));\n\t\t\tbreak;\n\n\t\tcase MBOX_ASTS_DCBX_CONF_CHANGE:\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x, mbox_sts[1]=%08x, mbox_sts[2]=%08x, mbox_sts[3]=%08x, mbox_sts[4]=%08x mbox_sts[5]=%08x\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0], mbox_sts[1],\n\t\t\t\t\t  mbox_sts[2], mbox_sts[3], mbox_sts[4],\n\t\t\t\t\t  mbox_sts[5]));\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"scsi%ld: AEN %04x Received DCBX configuration changed notification\\n\",\n\t\t\t\t\t  ha->host_no, mbox_sts[0]));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDEBUG2(printk(KERN_WARNING\n\t\t\t\t      \"scsi%ld: AEN %04x UNKNOWN\\n\",\n\t\t\t\t      ha->host_no, mbox_sts[0]));\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tDEBUG2(printk(\"scsi%ld: Unknown mailbox status %08X\\n\",\n\t\t\t      ha->host_no, mbox_status));\n\n\t\tha->mbox_status[0] = mbox_status;\n\t}\n}\n\nvoid qla4_83xx_interrupt_service_routine(struct scsi_qla_host *ha,\n\t\t\t\t\t uint32_t intr_status)\n{\n\t \n\tif (intr_status) {\n\t\tqla4xxx_isr_decode_mailbox(ha,\n\t\t\t\treadl(&ha->qla4_83xx_reg->mailbox_out[0]));\n\t\t \n\t\twritel(0, &ha->qla4_83xx_reg->risc_intr);\n\t} else {\n\t\tqla4xxx_process_response_queue(ha);\n\t}\n\n\t \n\twritel(0, &ha->qla4_83xx_reg->mb_int_mask);\n}\n\n \nvoid qla4_82xx_interrupt_service_routine(struct scsi_qla_host *ha,\n    uint32_t intr_status)\n{\n\t \n\tif ((intr_status & HSRX_RISC_IOCB_INT) &&\n\t    test_bit(AF_INIT_DONE, &ha->flags))\n\t\tqla4xxx_process_response_queue(ha);\n\n\t \n\tif (intr_status & HSRX_RISC_MB_INT)\n\t\tqla4xxx_isr_decode_mailbox(ha,\n\t\t    readl(&ha->qla4_82xx_reg->mailbox_out[0]));\n\n\t \n\twritel(0, &ha->qla4_82xx_reg->host_int);\n\treadl(&ha->qla4_82xx_reg->host_int);\n}\n\n \nvoid qla4xxx_interrupt_service_routine(struct scsi_qla_host * ha,\n\t\t\t\t       uint32_t intr_status)\n{\n\t \n\tif (intr_status & CSR_SCSI_COMPLETION_INTR)\n\t\tqla4xxx_process_response_queue(ha);\n\n\t \n\tif (intr_status & CSR_SCSI_PROCESSOR_INTR) {\n\t\tqla4xxx_isr_decode_mailbox(ha,\n\t\t\t\t\t   readl(&ha->reg->mailbox[0]));\n\n\t\t \n\t\twritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\n\t\t       &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t}\n}\n\n \nstatic void qla4_82xx_spurious_interrupt(struct scsi_qla_host *ha,\n    uint8_t reqs_count)\n{\n\tif (reqs_count)\n\t\treturn;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Spurious Interrupt\\n\"));\n\tif (is_qla8022(ha)) {\n\t\twritel(0, &ha->qla4_82xx_reg->host_int);\n\t\tif (!ha->pdev->msi_enabled && !ha->pdev->msix_enabled)\n\t\t\tqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg,\n\t\t\t    0xfbff);\n\t}\n\tha->spurious_int_count++;\n}\n\n \nirqreturn_t qla4xxx_intr_handler(int irq, void *dev_id)\n{\n\tstruct scsi_qla_host *ha;\n\tuint32_t intr_status;\n\tunsigned long flags = 0;\n\tuint8_t reqs_count = 0;\n\n\tha = (struct scsi_qla_host *) dev_id;\n\tif (!ha) {\n\t\tDEBUG2(printk(KERN_INFO\n\t\t\t      \"qla4xxx: Interrupt with NULL host ptr\\n\"));\n\t\treturn IRQ_NONE;\n\t}\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\tha->isr_count++;\n\t \n\twhile (1) {\n\t\t \n\t\tif (ha->isp_ops->rd_shdw_rsp_q_in(ha) !=\n\t\t    ha->response_out)\n\t\t\tintr_status = CSR_SCSI_COMPLETION_INTR;\n\t\telse\n\t\t\tintr_status = readl(&ha->reg->ctrl_status);\n\n\t\tif ((intr_status &\n\t\t    (CSR_SCSI_RESET_INTR|CSR_FATAL_ERROR|INTR_PENDING)) == 0) {\n\t\t\tif (reqs_count == 0)\n\t\t\t\tha->spurious_int_count++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (intr_status & CSR_FATAL_ERROR) {\n\t\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: Fatal Error, \"\n\t\t\t\t      \"Status 0x%04x\\n\", ha->host_no,\n\t\t\t\t      readl(isp_port_error_status (ha))));\n\n\t\t\t \n\t\t\tif ((readl(&ha->reg->ctrl_status) &\n\t\t\t     CSR_SCSI_RESET_INTR) == 0) {\n\t\t\t\twritel(set_rmask(CSR_SOFT_RESET),\n\t\t\t\t       &ha->reg->ctrl_status);\n\t\t\t\treadl(&ha->reg->ctrl_status);\n\t\t\t}\n\n\t\t\twritel(set_rmask(CSR_FATAL_ERROR),\n\t\t\t       &ha->reg->ctrl_status);\n\t\t\treadl(&ha->reg->ctrl_status);\n\n\t\t\t__qla4xxx_disable_intrs(ha);\n\n\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\n\t\t\tbreak;\n\t\t} else if (intr_status & CSR_SCSI_RESET_INTR) {\n\t\t\tclear_bit(AF_ONLINE, &ha->flags);\n\t\t\t__qla4xxx_disable_intrs(ha);\n\n\t\t\twritel(set_rmask(CSR_SCSI_RESET_INTR),\n\t\t\t       &ha->reg->ctrl_status);\n\t\t\treadl(&ha->reg->ctrl_status);\n\n\t\t\tif (!test_bit(AF_HA_REMOVAL, &ha->flags))\n\t\t\t\tset_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\n\n\t\t\tbreak;\n\t\t} else if (intr_status & INTR_PENDING) {\n\t\t\tha->isp_ops->interrupt_service_routine(ha, intr_status);\n\t\t\tha->total_io_count++;\n\t\t\tif (++reqs_count == MAX_REQS_SERVICED_PER_INTR)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \nirqreturn_t qla4_82xx_intr_handler(int irq, void *dev_id)\n{\n\tstruct scsi_qla_host *ha = dev_id;\n\tuint32_t intr_status;\n\tuint32_t status;\n\tunsigned long flags = 0;\n\tuint8_t reqs_count = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\treturn IRQ_HANDLED;\n\n\tha->isr_count++;\n\tstatus = qla4_82xx_rd_32(ha, ISR_INT_VECTOR);\n\tif (!(status & ha->nx_legacy_intr.int_vec_bit))\n\t\treturn IRQ_NONE;\n\n\tstatus = qla4_82xx_rd_32(ha, ISR_INT_STATE_REG);\n\tif (!ISR_IS_LEGACY_INTR_TRIGGERED(status)) {\n\t\tDEBUG7(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s legacy Int not triggered\\n\", __func__));\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);\n\n\t \n\tqla4_82xx_rd_32(ha, ISR_INT_VECTOR);\n\tqla4_82xx_rd_32(ha, ISR_INT_VECTOR);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twhile (1) {\n\t\tif (!(readl(&ha->qla4_82xx_reg->host_int) &\n\t\t    ISRX_82XX_RISC_INT)) {\n\t\t\tqla4_82xx_spurious_interrupt(ha, reqs_count);\n\t\t\tbreak;\n\t\t}\n\t\tintr_status =  readl(&ha->qla4_82xx_reg->host_status);\n\t\tif ((intr_status &\n\t\t    (HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0)  {\n\t\t\tqla4_82xx_spurious_interrupt(ha, reqs_count);\n\t\t\tbreak;\n\t\t}\n\n\t\tha->isp_ops->interrupt_service_routine(ha, intr_status);\n\n\t\t \n\t\tqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_mask_reg, 0xfbff);\n\n\t\tif (++reqs_count == MAX_REQS_SERVICED_PER_INTR)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n#define LEG_INT_PTR_B31\t\t(1 << 31)\n#define LEG_INT_PTR_B30\t\t(1 << 30)\n#define PF_BITS_MASK\t\t(0xF << 16)\n\n \nirqreturn_t qla4_83xx_intr_handler(int irq, void *dev_id)\n{\n\tstruct scsi_qla_host *ha = dev_id;\n\tuint32_t leg_int_ptr = 0;\n\tunsigned long flags = 0;\n\n\tha->isr_count++;\n\tleg_int_ptr = readl(&ha->qla4_83xx_reg->leg_int_ptr);\n\n\t \n\tif (!(leg_int_ptr & LEG_INT_PTR_B31)) {\n\t\tDEBUG7(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Legacy Interrupt Bit 31 not set, spurious interrupt!\\n\",\n\t\t\t\t  __func__));\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif ((leg_int_ptr & PF_BITS_MASK) != ha->pf_bit) {\n\t\tDEBUG7(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Incorrect function ID 0x%x in legacy interrupt register, ha->pf_bit = 0x%x\\n\",\n\t\t\t\t  __func__, (leg_int_ptr & PF_BITS_MASK),\n\t\t\t\t  ha->pf_bit));\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twritel(0, &ha->qla4_83xx_reg->leg_int_trig);\n\tdo {\n\t\tleg_int_ptr = readl(&ha->qla4_83xx_reg->leg_int_ptr);\n\t\tif ((leg_int_ptr & PF_BITS_MASK) != ha->pf_bit)\n\t\t\tbreak;\n\t} while (leg_int_ptr & LEG_INT_PTR_B30);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tleg_int_ptr = readl(&ha->qla4_83xx_reg->risc_intr);\n\tha->isp_ops->interrupt_service_routine(ha, leg_int_ptr);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t\nqla4_8xxx_msi_handler(int irq, void *dev_id)\n{\n\tstruct scsi_qla_host *ha;\n\n\tha = (struct scsi_qla_host *) dev_id;\n\tif (!ha) {\n\t\tDEBUG2(printk(KERN_INFO\n\t\t    \"qla4xxx: MSIX: Interrupt with NULL host ptr\\n\"));\n\t\treturn IRQ_NONE;\n\t}\n\n\tha->isr_count++;\n\t \n\tqla4_82xx_wr_32(ha, ha->nx_legacy_intr.tgt_status_reg, 0xffffffff);\n\n\t \n\tqla4_82xx_rd_32(ha, ISR_INT_VECTOR);\n\tqla4_82xx_rd_32(ha, ISR_INT_VECTOR);\n\n\treturn qla4_8xxx_default_intr_handler(irq, dev_id);\n}\n\nstatic irqreturn_t qla4_83xx_mailbox_intr_handler(int irq, void *dev_id)\n{\n\tstruct scsi_qla_host *ha = dev_id;\n\tunsigned long flags;\n\tuint32_t ival = 0;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\tival = readl(&ha->qla4_83xx_reg->risc_intr);\n\tif (ival == 0) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: It is a spurious mailbox interrupt!\\n\",\n\t\t\t   __func__);\n\t\tival = readl(&ha->qla4_83xx_reg->mb_int_mask);\n\t\tival &= ~INT_MASK_FW_MB;\n\t\twritel(ival, &ha->qla4_83xx_reg->mb_int_mask);\n\t\tgoto exit;\n\t}\n\n\tqla4xxx_isr_decode_mailbox(ha,\n\t\t\t\t   readl(&ha->qla4_83xx_reg->mailbox_out[0]));\n\twritel(0, &ha->qla4_83xx_reg->risc_intr);\n\tival = readl(&ha->qla4_83xx_reg->mb_int_mask);\n\tival &= ~INT_MASK_FW_MB;\n\twritel(ival, &ha->qla4_83xx_reg->mb_int_mask);\n\tha->isr_count++;\nexit:\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \nirqreturn_t\nqla4_8xxx_default_intr_handler(int irq, void *dev_id)\n{\n\tstruct scsi_qla_host *ha = dev_id;\n\tunsigned long   flags;\n\tuint32_t intr_status;\n\tuint8_t reqs_count = 0;\n\n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tqla4_83xx_mailbox_intr_handler(irq, dev_id);\n\t} else {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twhile (1) {\n\t\t\tif (!(readl(&ha->qla4_82xx_reg->host_int) &\n\t\t\t    ISRX_82XX_RISC_INT)) {\n\t\t\t\tqla4_82xx_spurious_interrupt(ha, reqs_count);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tintr_status =  readl(&ha->qla4_82xx_reg->host_status);\n\t\t\tif ((intr_status &\n\t\t\t    (HSRX_RISC_MB_INT | HSRX_RISC_IOCB_INT)) == 0) {\n\t\t\t\tqla4_82xx_spurious_interrupt(ha, reqs_count);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tha->isp_ops->interrupt_service_routine(ha, intr_status);\n\n\t\t\tif (++reqs_count == MAX_REQS_SERVICED_PER_INTR)\n\t\t\t\tbreak;\n\t\t}\n\t\tha->isr_count++;\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nirqreturn_t\nqla4_8xxx_msix_rsp_q(int irq, void *dev_id)\n{\n\tstruct scsi_qla_host *ha = dev_id;\n\tunsigned long flags;\n\tint intr_status;\n\tuint32_t ival = 0;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tival = readl(&ha->qla4_83xx_reg->iocb_int_mask);\n\t\tif (ival == 0) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: It is a spurious iocb interrupt!\\n\",\n\t\t\t\t   __func__);\n\t\t\tgoto exit_msix_rsp_q;\n\t\t}\n\t\tqla4xxx_process_response_queue(ha);\n\t\twritel(0, &ha->qla4_83xx_reg->iocb_int_mask);\n\t} else {\n\t\tintr_status = readl(&ha->qla4_82xx_reg->host_status);\n\t\tif (intr_status & HSRX_RISC_IOCB_INT) {\n\t\t\tqla4xxx_process_response_queue(ha);\n\t\t\twritel(0, &ha->qla4_82xx_reg->host_int);\n\t\t} else {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: spurious iocb interrupt...\\n\",\n\t\t\t\t   __func__);\n\t\t\tgoto exit_msix_rsp_q;\n\t\t}\n\t}\n\tha->isr_count++;\nexit_msix_rsp_q:\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \nvoid qla4xxx_process_aen(struct scsi_qla_host * ha, uint8_t process_aen)\n{\n\tuint32_t mbox_sts[MBOX_AEN_REG_COUNT];\n\tstruct aen *aen;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twhile (ha->aen_out != ha->aen_in) {\n\t\taen = &ha->aen_q[ha->aen_out];\n\t\t \n\t\tfor (i = 0; i < MBOX_AEN_REG_COUNT; i++)\n\t\t\tmbox_sts[i] = aen->mbox_sts[i];\n\n\t\tha->aen_q_count++;\n\t\tha->aen_out++;\n\n\t\tif (ha->aen_out == MAX_AEN_ENTRIES)\n\t\t\tha->aen_out = 0;\n\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tDEBUG2(printk(\"qla4xxx(%ld): AEN[%d]=0x%08x, mbx1=0x%08x mbx2=0x%08x\"\n\t\t\t\" mbx3=0x%08x mbx4=0x%08x\\n\", ha->host_no,\n\t\t\t(ha->aen_out ? (ha->aen_out-1): (MAX_AEN_ENTRIES-1)),\n\t\t\tmbox_sts[0], mbox_sts[1], mbox_sts[2],\n\t\t\tmbox_sts[3], mbox_sts[4]));\n\n\t\tswitch (mbox_sts[0]) {\n\t\tcase MBOX_ASTS_DATABASE_CHANGED:\n\t\t\tswitch (process_aen) {\n\t\t\tcase FLUSH_DDB_CHANGED_AENS:\n\t\t\t\tDEBUG2(printk(\"scsi%ld: AEN[%d] %04x, index \"\n\t\t\t\t\t      \"[%d] state=%04x FLUSHED!\\n\",\n\t\t\t\t\t      ha->host_no, ha->aen_out,\n\t\t\t\t\t      mbox_sts[0], mbox_sts[2],\n\t\t\t\t\t      mbox_sts[3]));\n\t\t\t\tbreak;\n\t\t\tcase PROCESS_ALL_AENS:\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tif (mbox_sts[1] == 1)\n\t\t\t\t\tqla4xxx_process_ddb_changed(ha,\n\t\t\t\t\t\tmbox_sts[2], mbox_sts[3],\n\t\t\t\t\t\tmbox_sts[4]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nint qla4xxx_request_irqs(struct scsi_qla_host *ha)\n{\n\tint ret = 0;\n\tint rval = QLA_ERROR;\n\n\tif (is_qla40XX(ha))\n\t\tgoto try_intx;\n\n\tif (ql4xenablemsix == 2) {\n\t\t \n\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: MSI Interrupts not supported for ISP%04x, Falling back-to INTx mode\\n\",\n\t\t\t\t   __func__, ha->pdev->device);\n\t\t\tgoto try_intx;\n\t\t}\n\t\tgoto try_msi;\n\t}\n\n\tif (ql4xenablemsix == 0 || ql4xenablemsix != 1)\n\t\tgoto try_intx;\n\n\t \n\tret = qla4_8xxx_enable_msix(ha);\n\tif (!ret) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t    \"MSI-X: Enabled (0x%X).\\n\", ha->revision_id));\n\t\tgoto irq_attached;\n\t} else {\n\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: ISP%04x: MSI-X: Falling back-to INTx mode. ret = %d\\n\",\n\t\t\t\t   __func__, ha->pdev->device, ret);\n\t\t\tgoto try_intx;\n\t\t}\n\t}\n\n\tql4_printk(KERN_WARNING, ha,\n\t    \"MSI-X: Falling back-to MSI mode -- %d.\\n\", ret);\n\ntry_msi:\n\t \n\tret = pci_alloc_irq_vectors(ha->pdev, 1, 1, PCI_IRQ_MSI);\n\tif (ret > 0) {\n\t\tret = request_irq(ha->pdev->irq, qla4_8xxx_msi_handler,\n\t\t\t0, DRIVER_NAME, ha);\n\t\tif (!ret) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"MSI: Enabled.\\n\"));\n\t\t\tgoto irq_attached;\n\t\t} else {\n\t\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t    \"MSI: Failed to reserve interrupt %d \"\n\t\t\t    \"already in use.\\n\", ha->pdev->irq);\n\t\t\tpci_free_irq_vectors(ha->pdev);\n\t\t}\n\t}\n\ntry_intx:\n\tif (is_qla8022(ha)) {\n\t\tql4_printk(KERN_WARNING, ha, \"%s: ISP82xx Legacy interrupt not supported\\n\",\n\t\t\t   __func__);\n\t\tgoto irq_not_attached;\n\t}\n\n\t \n\tret = request_irq(ha->pdev->irq, ha->isp_ops->intr_handler,\n\t    IRQF_SHARED, DRIVER_NAME, ha);\n\tif (!ret) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"INTx: Enabled.\\n\"));\n\t\tgoto irq_attached;\n\n\t} else {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"INTx: Failed to reserve interrupt %d already in\"\n\t\t    \" use.\\n\", ha->pdev->irq);\n\t\tgoto irq_not_attached;\n\t}\n\nirq_attached:\n\tset_bit(AF_IRQ_ATTACHED, &ha->flags);\n\tha->host->irq = ha->pdev->irq;\n\tql4_printk(KERN_INFO, ha, \"%s: irq %d attached\\n\",\n\t\t   __func__, ha->pdev->irq);\n\trval = QLA_SUCCESS;\nirq_not_attached:\n\treturn rval;\n}\n\nvoid qla4xxx_free_irqs(struct scsi_qla_host *ha)\n{\n\tif (!test_and_clear_bit(AF_IRQ_ATTACHED, &ha->flags))\n\t\treturn;\n\n\tif (ha->pdev->msix_enabled)\n\t\tfree_irq(pci_irq_vector(ha->pdev, 1), ha);\n\tfree_irq(pci_irq_vector(ha->pdev, 0), ha);\n\tpci_free_irq_vectors(ha->pdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}