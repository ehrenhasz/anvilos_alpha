{
  "module_name": "ql4_nvram.c",
  "hash_id": "7307c2472749a443dd811c373327ad77ee3aadde04fc16fb41e9120976255faf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_nvram.c",
  "human_readable_source": "\n \n\n#include \"ql4_def.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n#include \"ql4_inline.h\"\n\nstatic inline void eeprom_cmd(uint32_t cmd, struct scsi_qla_host *ha)\n{\n\twritel(cmd, isp_nvram(ha));\n\treadl(isp_nvram(ha));\n\tudelay(1);\n}\n\nstatic inline int eeprom_size(struct scsi_qla_host *ha)\n{\n\treturn is_qla4010(ha) ? FM93C66A_SIZE_16 : FM93C86A_SIZE_16;\n}\n\nstatic inline int eeprom_no_addr_bits(struct scsi_qla_host *ha)\n{\n\treturn is_qla4010(ha) ? FM93C56A_NO_ADDR_BITS_16 :\n\t\tFM93C86A_NO_ADDR_BITS_16 ;\n}\n\nstatic inline int eeprom_no_data_bits(struct scsi_qla_host *ha)\n{\n\treturn FM93C56A_DATA_BITS_16;\n}\n\nstatic int fm93c56a_select(struct scsi_qla_host * ha)\n{\n\tDEBUG5(printk(KERN_ERR \"fm93c56a_select:\\n\"));\n\n\tha->eeprom_cmd_data = AUBURN_EEPROM_CS_1 | 0x000f0000;\n\teeprom_cmd(ha->eeprom_cmd_data, ha);\n\treturn 1;\n}\n\nstatic int fm93c56a_cmd(struct scsi_qla_host * ha, int cmd, int addr)\n{\n\tint i;\n\tint mask;\n\tint dataBit;\n\tint previousBit;\n\n\t \n\teeprom_cmd(ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1, ha);\n\n\teeprom_cmd(ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1 |\n\t       AUBURN_EEPROM_CLK_RISE, ha);\n\teeprom_cmd(ha->eeprom_cmd_data | AUBURN_EEPROM_DO_1 |\n\t       AUBURN_EEPROM_CLK_FALL, ha);\n\n\tmask = 1 << (FM93C56A_CMD_BITS - 1);\n\n\t \n\tpreviousBit = 0xffff;\n\tfor (i = 0; i < FM93C56A_CMD_BITS; i++) {\n\t\tdataBit =\n\t\t\t(cmd & mask) ? AUBURN_EEPROM_DO_1 : AUBURN_EEPROM_DO_0;\n\t\tif (previousBit != dataBit) {\n\n\t\t\t \n\t\t\teeprom_cmd(ha->eeprom_cmd_data | dataBit, ha);\n\t\t\tpreviousBit = dataBit;\n\t\t}\n\t\teeprom_cmd(ha->eeprom_cmd_data | dataBit |\n\t\t       AUBURN_EEPROM_CLK_RISE, ha);\n\t\teeprom_cmd(ha->eeprom_cmd_data | dataBit |\n\t\t       AUBURN_EEPROM_CLK_FALL, ha);\n\n\t\tcmd = cmd << 1;\n\t}\n\tmask = 1 << (eeprom_no_addr_bits(ha) - 1);\n\n\t \n\tpreviousBit = 0xffff;\n\tfor (i = 0; i < eeprom_no_addr_bits(ha); i++) {\n\t\tdataBit = addr & mask ? AUBURN_EEPROM_DO_1 :\n\t\t\tAUBURN_EEPROM_DO_0;\n\t\tif (previousBit != dataBit) {\n\t\t\t \n\t\t\teeprom_cmd(ha->eeprom_cmd_data | dataBit, ha);\n\n\t\t\tpreviousBit = dataBit;\n\t\t}\n\t\teeprom_cmd(ha->eeprom_cmd_data | dataBit |\n\t\t       AUBURN_EEPROM_CLK_RISE, ha);\n\t\teeprom_cmd(ha->eeprom_cmd_data | dataBit |\n\t\t       AUBURN_EEPROM_CLK_FALL, ha);\n\n\t\taddr = addr << 1;\n\t}\n\treturn 1;\n}\n\nstatic int fm93c56a_deselect(struct scsi_qla_host * ha)\n{\n\tha->eeprom_cmd_data = AUBURN_EEPROM_CS_0 | 0x000f0000;\n\teeprom_cmd(ha->eeprom_cmd_data, ha);\n\treturn 1;\n}\n\nstatic int fm93c56a_datain(struct scsi_qla_host * ha, unsigned short *value)\n{\n\tint i;\n\tint data = 0;\n\tint dataBit;\n\n\t \n\tfor (i = 0; i < eeprom_no_data_bits(ha); i++) {\n\t\teeprom_cmd(ha->eeprom_cmd_data |\n\t\t       AUBURN_EEPROM_CLK_RISE, ha);\n\t\teeprom_cmd(ha->eeprom_cmd_data |\n\t\t       AUBURN_EEPROM_CLK_FALL, ha);\n\n\t\tdataBit = (readw(isp_nvram(ha)) & AUBURN_EEPROM_DI_1) ? 1 : 0;\n\n\t\tdata = (data << 1) | dataBit;\n\t}\n\n\t*value = data;\n\treturn 1;\n}\n\nstatic int eeprom_readword(int eepromAddr, u16 * value,\n\t\t\t   struct scsi_qla_host * ha)\n{\n\tfm93c56a_select(ha);\n\tfm93c56a_cmd(ha, FM93C56A_READ, eepromAddr);\n\tfm93c56a_datain(ha, value);\n\tfm93c56a_deselect(ha);\n\treturn 1;\n}\n\n \nu16 rd_nvram_word(struct scsi_qla_host * ha, int offset)\n{\n\tu16 val = 0;\n\n\t \n\teeprom_readword(offset, &val, ha);\n\treturn val;\n}\n\nu8 rd_nvram_byte(struct scsi_qla_host *ha, int offset)\n{\n\tu16 val = 0;\n\tu8 rval = 0;\n\tint index = 0;\n\n\tif (offset & 0x1)\n\t\tindex = (offset - 1) / 2;\n\telse\n\t\tindex = offset / 2;\n\n\tval = le16_to_cpu(rd_nvram_word(ha, index));\n\n\tif (offset & 0x1)\n\t\trval = (u8)((val & 0xff00) >> 8);\n\telse\n\t\trval = (u8)((val & 0x00ff));\n\n\treturn rval;\n}\n\nint qla4xxx_is_nvram_configuration_valid(struct scsi_qla_host * ha)\n{\n\tint status = QLA_ERROR;\n\tuint16_t checksum = 0;\n\tuint32_t index;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (index = 0; index < eeprom_size(ha); index++)\n\t\tchecksum += rd_nvram_word(ha, index);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (checksum == 0)\n\t\tstatus = QLA_SUCCESS;\n\n\treturn status;\n}\n\n \nint ql4xxx_sem_spinlock(struct scsi_qla_host * ha, u32 sem_mask, u32 sem_bits)\n{\n\tuint32_t value;\n\tunsigned long flags;\n\tunsigned int seconds = 30;\n\n\tDEBUG2(printk(\"scsi%ld : Trying to get SEM lock - mask= 0x%x, code = \"\n\t\t      \"0x%x\\n\", ha->host_no, sem_mask, sem_bits));\n\tdo {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twritel((sem_mask | sem_bits), isp_semaphore(ha));\n\t\tvalue = readw(isp_semaphore(ha));\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\tif ((value & (sem_mask >> 16)) == sem_bits) {\n\t\t\tDEBUG2(printk(\"scsi%ld : Got SEM LOCK - mask= 0x%x, \"\n\t\t\t\t      \"code = 0x%x\\n\", ha->host_no,\n\t\t\t\t      sem_mask, sem_bits));\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\t\tssleep(1);\n\t} while (--seconds);\n\treturn QLA_ERROR;\n}\n\nvoid ql4xxx_sem_unlock(struct scsi_qla_host * ha, u32 sem_mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twritel(sem_mask, isp_semaphore(ha));\n\treadl(isp_semaphore(ha));\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tDEBUG2(printk(\"scsi%ld : UNLOCK SEM - mask= 0x%x\\n\", ha->host_no,\n\t\t      sem_mask));\n}\n\nint ql4xxx_sem_lock(struct scsi_qla_host * ha, u32 sem_mask, u32 sem_bits)\n{\n\tuint32_t value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twritel((sem_mask | sem_bits), isp_semaphore(ha));\n\tvalue = readw(isp_semaphore(ha));\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\tif ((value & (sem_mask >> 16)) == sem_bits) {\n\t\tDEBUG2(printk(\"scsi%ld : Got SEM LOCK - mask= 0x%x, code = \"\n\t\t\t      \"0x%x, sema code=0x%x\\n\", ha->host_no,\n\t\t\t      sem_mask, sem_bits, value));\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}