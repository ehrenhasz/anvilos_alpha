{
  "module_name": "ql4_os.c",
  "hash_id": "bcb0c3bdd2a477d7836c4df7f3f90edd8ef079b0cbf4877dfa9dda881c3880e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_os.c",
  "human_readable_source": "\n \n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/iscsi_boot_sysfs.h>\n#include <linux/inet.h>\n\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsicam.h>\n\n#include \"ql4_def.h\"\n#include \"ql4_version.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n#include \"ql4_inline.h\"\n#include \"ql4_83xx.h\"\n\n \nstatic char qla4xxx_version_str[40];\n\n \nstatic struct kmem_cache *srb_cachep;\n\n \nstatic int ql4xdisablesysfsboot = 1;\nmodule_param(ql4xdisablesysfsboot, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xdisablesysfsboot,\n\t\t \" Set to disable exporting boot targets to sysfs.\\n\"\n\t\t \"\\t\\t  0 - Export boot targets\\n\"\n\t\t \"\\t\\t  1 - Do not export boot targets (Default)\");\n\nint ql4xdontresethba;\nmodule_param(ql4xdontresethba, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xdontresethba,\n\t\t \" Don't reset the HBA for driver recovery.\\n\"\n\t\t \"\\t\\t  0 - It will reset HBA (Default)\\n\"\n\t\t \"\\t\\t  1 - It will NOT reset HBA\");\n\nint ql4xextended_error_logging;\nmodule_param(ql4xextended_error_logging, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xextended_error_logging,\n\t\t \" Option to enable extended error logging.\\n\"\n\t\t \"\\t\\t  0 - no logging (Default)\\n\"\n\t\t \"\\t\\t  2 - debug logging\");\n\nint ql4xenablemsix = 1;\nmodule_param(ql4xenablemsix, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(ql4xenablemsix,\n\t\t \" Set to enable MSI or MSI-X interrupt mechanism.\\n\"\n\t\t \"\\t\\t  0 = enable INTx interrupt mechanism.\\n\"\n\t\t \"\\t\\t  1 = enable MSI-X interrupt mechanism (Default).\\n\"\n\t\t \"\\t\\t  2 = enable MSI interrupt mechanism.\");\n\n#define QL4_DEF_QDEPTH 32\nstatic int ql4xmaxqdepth = QL4_DEF_QDEPTH;\nmodule_param(ql4xmaxqdepth, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xmaxqdepth,\n\t\t \" Maximum queue depth to report for target devices.\\n\"\n\t\t \"\\t\\t  Default: 32.\");\n\nstatic int ql4xqfulltracking = 1;\nmodule_param(ql4xqfulltracking, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xqfulltracking,\n\t\t \" Enable or disable dynamic tracking and adjustment of\\n\"\n\t\t \"\\t\\t scsi device queue depth.\\n\"\n\t\t \"\\t\\t  0 - Disable.\\n\"\n\t\t \"\\t\\t  1 - Enable. (Default)\");\n\nstatic int ql4xsess_recovery_tmo = QL4_SESS_RECOVERY_TMO;\nmodule_param(ql4xsess_recovery_tmo, int, S_IRUGO);\nMODULE_PARM_DESC(ql4xsess_recovery_tmo,\n\t\t\" Target Session Recovery Timeout.\\n\"\n\t\t\"\\t\\t  Default: 120 sec.\");\n\nint ql4xmdcapmask = 0;\nmodule_param(ql4xmdcapmask, int, S_IRUGO);\nMODULE_PARM_DESC(ql4xmdcapmask,\n\t\t \" Set the Minidump driver capture mask level.\\n\"\n\t\t \"\\t\\t  Default is 0 (firmware default capture mask)\\n\"\n\t\t \"\\t\\t  Can be set to 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F, 0xFF\");\n\nint ql4xenablemd = 1;\nmodule_param(ql4xenablemd, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ql4xenablemd,\n\t\t \" Set to enable minidump.\\n\"\n\t\t \"\\t\\t  0 - disable minidump\\n\"\n\t\t \"\\t\\t  1 - enable minidump (Default)\");\n\nstatic int qla4xxx_wait_for_hba_online(struct scsi_qla_host *ha);\n \nstatic void qla4xxx_config_dma_addressing(struct scsi_qla_host *ha);\n\n \nstatic int qla4xxx_session_get_param(struct iscsi_cls_session *cls_sess,\n\t\t\t\t     enum iscsi_param param, char *buf);\nstatic int qla4xxx_conn_get_param(struct iscsi_cls_conn *conn,\n\t\t\t\t  enum iscsi_param param, char *buf);\nstatic int qla4xxx_host_get_param(struct Scsi_Host *shost,\n\t\t\t\t  enum iscsi_host_param param, char *buf);\nstatic int qla4xxx_iface_set_param(struct Scsi_Host *shost, void *data,\n\t\t\t\t   uint32_t len);\nstatic int qla4xxx_get_iface_param(struct iscsi_iface *iface,\n\t\t\t\t   enum iscsi_param_type param_type,\n\t\t\t\t   int param, char *buf);\nstatic enum scsi_timeout_action qla4xxx_eh_cmd_timed_out(struct scsi_cmnd *sc);\nstatic struct iscsi_endpoint *qla4xxx_ep_connect(struct Scsi_Host *shost,\n\t\t\t\t\t\t struct sockaddr *dst_addr,\n\t\t\t\t\t\t int non_blocking);\nstatic int qla4xxx_ep_poll(struct iscsi_endpoint *ep, int timeout_ms);\nstatic void qla4xxx_ep_disconnect(struct iscsi_endpoint *ep);\nstatic int qla4xxx_get_ep_param(struct iscsi_endpoint *ep,\n\t\t\t\tenum iscsi_param param, char *buf);\nstatic int qla4xxx_conn_start(struct iscsi_cls_conn *conn);\nstatic struct iscsi_cls_conn *\nqla4xxx_conn_create(struct iscsi_cls_session *cls_sess, uint32_t conn_idx);\nstatic int qla4xxx_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t\t     struct iscsi_cls_conn *cls_conn,\n\t\t\t     uint64_t transport_fd, int is_leading);\nstatic void qla4xxx_conn_destroy(struct iscsi_cls_conn *conn);\nstatic struct iscsi_cls_session *\nqla4xxx_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,\n\t\t\tuint16_t qdepth, uint32_t initial_cmdsn);\nstatic void qla4xxx_session_destroy(struct iscsi_cls_session *sess);\nstatic void qla4xxx_task_work(struct work_struct *wdata);\nstatic int qla4xxx_alloc_pdu(struct iscsi_task *, uint8_t);\nstatic int qla4xxx_task_xmit(struct iscsi_task *);\nstatic void qla4xxx_task_cleanup(struct iscsi_task *);\nstatic void qla4xxx_fail_session(struct iscsi_cls_session *cls_session);\nstatic void qla4xxx_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t   struct iscsi_stats *stats);\nstatic int qla4xxx_send_ping(struct Scsi_Host *shost, uint32_t iface_num,\n\t\t\t     uint32_t iface_type, uint32_t payload_size,\n\t\t\t     uint32_t pid, struct sockaddr *dst_addr);\nstatic int qla4xxx_get_chap_list(struct Scsi_Host *shost, uint16_t chap_tbl_idx,\n\t\t\t\t uint32_t *num_entries, char *buf);\nstatic int qla4xxx_delete_chap(struct Scsi_Host *shost, uint16_t chap_tbl_idx);\nstatic int qla4xxx_set_chap_entry(struct Scsi_Host *shost, void  *data,\n\t\t\t\t  int len);\nstatic int qla4xxx_get_host_stats(struct Scsi_Host *shost, char *buf, int len);\n\n \nstatic int qla4xxx_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *cmd);\nstatic int qla4xxx_eh_abort(struct scsi_cmnd *cmd);\nstatic int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd);\nstatic int qla4xxx_eh_target_reset(struct scsi_cmnd *cmd);\nstatic int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd);\nstatic int qla4xxx_slave_alloc(struct scsi_device *device);\nstatic umode_t qla4_attr_is_visible(int param_type, int param);\nstatic int qla4xxx_host_reset(struct Scsi_Host *shost, int reset_type);\n\n \nstatic int\nqla4xxx_sysfs_ddb_set_param(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    struct iscsi_bus_flash_conn *fnode_conn,\n\t\t\t    void *data, int len);\nstatic int\nqla4xxx_sysfs_ddb_get_param(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    int param, char *buf);\nstatic int qla4xxx_sysfs_ddb_add(struct Scsi_Host *shost, const char *buf,\n\t\t\t\t int len);\nstatic int\nqla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess);\nstatic int qla4xxx_sysfs_ddb_login(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t   struct iscsi_bus_flash_conn *fnode_conn);\nstatic int qla4xxx_sysfs_ddb_logout(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t    struct iscsi_bus_flash_conn *fnode_conn);\nstatic int qla4xxx_sysfs_ddb_logout_sid(struct iscsi_cls_session *cls_sess);\n\nstatic struct qla4_8xxx_legacy_intr_set legacy_intr[] =\n    QLA82XX_LEGACY_INTR_CONFIG;\n\nstatic const uint32_t qla4_82xx_reg_tbl[] = {\n\tQLA82XX_PEG_HALT_STATUS1,\n\tQLA82XX_PEG_HALT_STATUS2,\n\tQLA82XX_PEG_ALIVE_COUNTER,\n\tQLA82XX_CRB_DRV_ACTIVE,\n\tQLA82XX_CRB_DEV_STATE,\n\tQLA82XX_CRB_DRV_STATE,\n\tQLA82XX_CRB_DRV_SCRATCH,\n\tQLA82XX_CRB_DEV_PART_INFO,\n\tQLA82XX_CRB_DRV_IDC_VERSION,\n\tQLA82XX_FW_VERSION_MAJOR,\n\tQLA82XX_FW_VERSION_MINOR,\n\tQLA82XX_FW_VERSION_SUB,\n\tCRB_CMDPEG_STATE,\n\tCRB_TEMP_STATE,\n};\n\nstatic const uint32_t qla4_83xx_reg_tbl[] = {\n\tQLA83XX_PEG_HALT_STATUS1,\n\tQLA83XX_PEG_HALT_STATUS2,\n\tQLA83XX_PEG_ALIVE_COUNTER,\n\tQLA83XX_CRB_DRV_ACTIVE,\n\tQLA83XX_CRB_DEV_STATE,\n\tQLA83XX_CRB_DRV_STATE,\n\tQLA83XX_CRB_DRV_SCRATCH,\n\tQLA83XX_CRB_DEV_PART_INFO1,\n\tQLA83XX_CRB_IDC_VER_MAJOR,\n\tQLA83XX_FW_VER_MAJOR,\n\tQLA83XX_FW_VER_MINOR,\n\tQLA83XX_FW_VER_SUB,\n\tQLA83XX_CMDPEG_STATE,\n\tQLA83XX_ASIC_TEMP,\n};\n\nstatic struct scsi_host_template qla4xxx_driver_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= DRIVER_NAME,\n\t.proc_name\t\t= DRIVER_NAME,\n\t.queuecommand\t\t= qla4xxx_queuecommand,\n\t.cmd_size\t\t= sizeof(struct qla4xxx_cmd_priv),\n\n\t.eh_abort_handler\t= qla4xxx_eh_abort,\n\t.eh_device_reset_handler = qla4xxx_eh_device_reset,\n\t.eh_target_reset_handler = qla4xxx_eh_target_reset,\n\t.eh_host_reset_handler\t= qla4xxx_eh_host_reset,\n\t.eh_timed_out\t\t= qla4xxx_eh_cmd_timed_out,\n\n\t.slave_alloc\t\t= qla4xxx_slave_alloc,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\n\t.this_id\t\t= -1,\n\t.cmd_per_lun\t\t= 3,\n\t.sg_tablesize\t\t= SG_ALL,\n\n\t.max_sectors\t\t= 0xFFFF,\n\t.shost_groups\t\t= qla4xxx_host_groups,\n\t.host_reset\t\t= qla4xxx_host_reset,\n\t.vendor_id\t\t= SCSI_NL_VID_TYPE_PCI | PCI_VENDOR_ID_QLOGIC,\n};\n\nstatic struct iscsi_transport qla4xxx_iscsi_transport = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.name\t\t\t= DRIVER_NAME,\n\t.caps\t\t\t= CAP_TEXT_NEGO |\n\t\t\t\t  CAP_DATA_PATH_OFFLOAD | CAP_HDRDGST |\n\t\t\t\t  CAP_DATADGST | CAP_LOGIN_OFFLOAD |\n\t\t\t\t  CAP_MULTI_R2T,\n\t.attr_is_visible\t= qla4_attr_is_visible,\n\t.create_session         = qla4xxx_session_create,\n\t.destroy_session        = qla4xxx_session_destroy,\n\t.start_conn             = qla4xxx_conn_start,\n\t.create_conn            = qla4xxx_conn_create,\n\t.bind_conn              = qla4xxx_conn_bind,\n\t.unbind_conn\t\t= iscsi_conn_unbind,\n\t.stop_conn              = iscsi_conn_stop,\n\t.destroy_conn           = qla4xxx_conn_destroy,\n\t.set_param              = iscsi_set_param,\n\t.get_conn_param\t\t= qla4xxx_conn_get_param,\n\t.get_session_param\t= qla4xxx_session_get_param,\n\t.get_ep_param           = qla4xxx_get_ep_param,\n\t.ep_connect\t\t= qla4xxx_ep_connect,\n\t.ep_poll\t\t= qla4xxx_ep_poll,\n\t.ep_disconnect\t\t= qla4xxx_ep_disconnect,\n\t.get_stats\t\t= qla4xxx_conn_get_stats,\n\t.send_pdu\t\t= iscsi_conn_send_pdu,\n\t.xmit_task\t\t= qla4xxx_task_xmit,\n\t.cleanup_task\t\t= qla4xxx_task_cleanup,\n\t.alloc_pdu\t\t= qla4xxx_alloc_pdu,\n\n\t.get_host_param\t\t= qla4xxx_host_get_param,\n\t.set_iface_param\t= qla4xxx_iface_set_param,\n\t.get_iface_param\t= qla4xxx_get_iface_param,\n\t.bsg_request\t\t= qla4xxx_bsg_request,\n\t.send_ping\t\t= qla4xxx_send_ping,\n\t.get_chap\t\t= qla4xxx_get_chap_list,\n\t.delete_chap\t\t= qla4xxx_delete_chap,\n\t.set_chap\t\t= qla4xxx_set_chap_entry,\n\t.get_flashnode_param\t= qla4xxx_sysfs_ddb_get_param,\n\t.set_flashnode_param\t= qla4xxx_sysfs_ddb_set_param,\n\t.new_flashnode\t\t= qla4xxx_sysfs_ddb_add,\n\t.del_flashnode\t\t= qla4xxx_sysfs_ddb_delete,\n\t.login_flashnode\t= qla4xxx_sysfs_ddb_login,\n\t.logout_flashnode\t= qla4xxx_sysfs_ddb_logout,\n\t.logout_flashnode_sid\t= qla4xxx_sysfs_ddb_logout_sid,\n\t.get_host_stats\t\t= qla4xxx_get_host_stats,\n};\n\nstatic struct scsi_transport_template *qla4xxx_scsi_transport;\n\nstatic int qla4xxx_isp_check_reg(struct scsi_qla_host *ha)\n{\n\tu32 reg_val = 0;\n\tint rval = QLA_SUCCESS;\n\n\tif (is_qla8022(ha))\n\t\treg_val = readl(&ha->qla4_82xx_reg->host_status);\n\telse if (is_qla8032(ha) || is_qla8042(ha))\n\t\treg_val = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_ALIVE_COUNTER);\n\telse\n\t\treg_val = readw(&ha->reg->ctrl_status);\n\n\tif (reg_val == QL4_ISP_REG_DISCONNECT)\n\t\trval = QLA_ERROR;\n\n\treturn rval;\n}\n\nstatic int qla4xxx_send_ping(struct Scsi_Host *shost, uint32_t iface_num,\n\t\t\t     uint32_t iface_type, uint32_t payload_size,\n\t\t\t     uint32_t pid, struct sockaddr *dst_addr)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tuint32_t options = 0;\n\tuint8_t ipaddr[IPv6_ADDR_LEN];\n\tint rval;\n\n\tmemset(ipaddr, 0, IPv6_ADDR_LEN);\n\t \n\tif ((iface_type == ISCSI_IFACE_TYPE_IPV4) &&\n\t    (dst_addr->sa_family == AF_INET)) {\n\t\taddr = (struct sockaddr_in *)dst_addr;\n\t\tmemcpy(ipaddr, &addr->sin_addr.s_addr, IP_ADDR_LEN);\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: IPv4 Ping src: %pI4 \"\n\t\t\t\t  \"dest: %pI4\\n\", __func__,\n\t\t\t\t  &ha->ip_config.ip_address, ipaddr));\n\t\trval = qla4xxx_ping_iocb(ha, options, payload_size, pid,\n\t\t\t\t\t ipaddr);\n\t\tif (rval)\n\t\t\trval = -EINVAL;\n\t} else if ((iface_type == ISCSI_IFACE_TYPE_IPV6) &&\n\t\t   (dst_addr->sa_family == AF_INET6)) {\n\t\t \n\t\taddr6 = (struct sockaddr_in6 *)dst_addr;\n\t\tmemcpy(ipaddr, &addr6->sin6_addr.in6_u.u6_addr8, IPv6_ADDR_LEN);\n\n\t\toptions |= PING_IPV6_PROTOCOL_ENABLE;\n\n\t\t \n\t\tif ((iface_num == 0) || (iface_num == 1)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: LinkLocal Ping \"\n\t\t\t\t\t  \"src: %pI6 dest: %pI6\\n\", __func__,\n\t\t\t\t\t  &ha->ip_config.ipv6_link_local_addr,\n\t\t\t\t\t  ipaddr));\n\t\t\toptions |= PING_IPV6_LINKLOCAL_ADDR;\n\t\t\trval = qla4xxx_ping_iocb(ha, options, payload_size,\n\t\t\t\t\t\t pid, ipaddr);\n\t\t} else {\n\t\t\tql4_printk(KERN_WARNING, ha, \"%s: iface num = %d \"\n\t\t\t\t   \"not supported\\n\", __func__, iface_num);\n\t\t\trval = -ENOSYS;\n\t\t\tgoto exit_send_ping;\n\t\t}\n\n\t\t \n\t\tif (rval != QLA_SUCCESS) {\n\t\t\toptions &= ~PING_IPV6_LINKLOCAL_ADDR;\n\t\t\tif (iface_num == 0) {\n\t\t\t\toptions |= PING_IPV6_ADDR0;\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: IPv6 \"\n\t\t\t\t\t\t  \"Ping src: %pI6 \"\n\t\t\t\t\t\t  \"dest: %pI6\\n\", __func__,\n\t\t\t\t\t\t  &ha->ip_config.ipv6_addr0,\n\t\t\t\t\t\t  ipaddr));\n\t\t\t} else if (iface_num == 1) {\n\t\t\t\toptions |= PING_IPV6_ADDR1;\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: IPv6 \"\n\t\t\t\t\t\t  \"Ping src: %pI6 \"\n\t\t\t\t\t\t  \"dest: %pI6\\n\", __func__,\n\t\t\t\t\t\t  &ha->ip_config.ipv6_addr1,\n\t\t\t\t\t\t  ipaddr));\n\t\t\t}\n\t\t\trval = qla4xxx_ping_iocb(ha, options, payload_size,\n\t\t\t\t\t\t pid, ipaddr);\n\t\t\tif (rval)\n\t\t\t\trval = -EINVAL;\n\t\t}\n\t} else\n\t\trval = -ENOSYS;\nexit_send_ping:\n\treturn rval;\n}\n\nstatic umode_t qla4_attr_is_visible(int param_type, int param)\n{\n\tswitch (param_type) {\n\tcase ISCSI_HOST_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\tcase ISCSI_HOST_PARAM_PORT_STATE:\n\t\tcase ISCSI_HOST_PARAM_PORT_SPEED:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tcase ISCSI_PARAM_CONN_PORT:\n\t\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tcase ISCSI_PARAM_TPGT:\n\t\tcase ISCSI_PARAM_TARGET_ALIAS:\n\t\tcase ISCSI_PARAM_MAX_BURST:\n\t\tcase ISCSI_PARAM_MAX_R2T:\n\t\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tcase ISCSI_PARAM_CHAP_OUT_IDX:\n\t\tcase ISCSI_PARAM_CHAP_IN_IDX:\n\t\tcase ISCSI_PARAM_USERNAME:\n\t\tcase ISCSI_PARAM_PASSWORD:\n\t\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tcase ISCSI_PARAM_AUTO_SND_TGT_DISABLE:\n\t\tcase ISCSI_PARAM_DISCOVERY_SESS:\n\t\tcase ISCSI_PARAM_PORTAL_TYPE:\n\t\tcase ISCSI_PARAM_CHAP_AUTH_EN:\n\t\tcase ISCSI_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tcase ISCSI_PARAM_BIDI_CHAP_EN:\n\t\tcase ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tcase ISCSI_PARAM_DEF_TIME2WAIT:\n\t\tcase ISCSI_PARAM_DEF_TIME2RETAIN:\n\t\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_PARAM_MAX_SEGMENT_SIZE:\n\t\tcase ISCSI_PARAM_TCP_TIMESTAMP_STAT:\n\t\tcase ISCSI_PARAM_TCP_WSF_DISABLE:\n\t\tcase ISCSI_PARAM_TCP_NAGLE_DISABLE:\n\t\tcase ISCSI_PARAM_TCP_TIMER_SCALE:\n\t\tcase ISCSI_PARAM_TCP_TIMESTAMP_EN:\n\t\tcase ISCSI_PARAM_TCP_XMIT_WSF:\n\t\tcase ISCSI_PARAM_TCP_RECV_WSF:\n\t\tcase ISCSI_PARAM_IP_FRAGMENT_DISABLE:\n\t\tcase ISCSI_PARAM_IPV4_TOS:\n\t\tcase ISCSI_PARAM_IPV6_TC:\n\t\tcase ISCSI_PARAM_IPV6_FLOW_LABEL:\n\t\tcase ISCSI_PARAM_IS_FW_ASSIGNED_IPV6:\n\t\tcase ISCSI_PARAM_KEEPALIVE_TMO:\n\t\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tcase ISCSI_PARAM_ISID:\n\t\tcase ISCSI_PARAM_TSID:\n\t\tcase ISCSI_PARAM_DEF_TASKMGMT_TMO:\n\t\tcase ISCSI_PARAM_ERL:\n\t\tcase ISCSI_PARAM_STATSN:\n\t\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tcase ISCSI_PARAM_DISCOVERY_PARENT_IDX:\n\t\tcase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\n\t\tcase ISCSI_PARAM_LOCAL_IPADDR:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_NET_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\tcase ISCSI_NET_PARAM_IPV6_ROUTER:\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\n\t\tcase ISCSI_NET_PARAM_VLAN_ID:\n\t\tcase ISCSI_NET_PARAM_VLAN_PRIORITY:\n\t\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tcase ISCSI_NET_PARAM_MTU:\n\t\tcase ISCSI_NET_PARAM_PORT:\n\t\tcase ISCSI_NET_PARAM_IPADDR_STATE:\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE:\n\t\tcase ISCSI_NET_PARAM_IPV6_ROUTER_STATE:\n\t\tcase ISCSI_NET_PARAM_DELAYED_ACK_EN:\n\t\tcase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\n\t\tcase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\n\t\tcase ISCSI_NET_PARAM_TCP_WSF:\n\t\tcase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\n\t\tcase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\n\t\tcase ISCSI_NET_PARAM_CACHE_ID:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_TOS_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_TOS:\n\t\tcase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\n\t\tcase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\n\t\tcase ISCSI_NET_PARAM_REDIRECT_EN:\n\t\tcase ISCSI_NET_PARAM_IPV4_TTL:\n\t\tcase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\n\t\tcase ISCSI_NET_PARAM_IPV6_MLD_EN:\n\t\tcase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\n\t\tcase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\n\t\tcase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\n\t\tcase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\n\t\tcase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_IFACE_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\n\t\tcase ISCSI_IFACE_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_IFACE_PARAM_DATADGST_EN:\n\t\tcase ISCSI_IFACE_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_IFACE_PARAM_ERL:\n\t\tcase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_IFACE_PARAM_FIRST_BURST:\n\t\tcase ISCSI_IFACE_PARAM_MAX_R2T:\n\t\tcase ISCSI_IFACE_PARAM_MAX_BURST:\n\t\tcase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\n\t\tcase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\n\t\tcase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tcase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tcase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\n\t\tcase ISCSI_IFACE_PARAM_INITIATOR_NAME:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_FLASHNODE_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\n\t\tcase ISCSI_FLASHNODE_PORTAL_TYPE:\n\t\tcase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_SESS:\n\t\tcase ISCSI_FLASHNODE_ENTRY_EN:\n\t\tcase ISCSI_FLASHNODE_HDR_DGST_EN:\n\t\tcase ISCSI_FLASHNODE_DATA_DGST_EN:\n\t\tcase ISCSI_FLASHNODE_IMM_DATA_EN:\n\t\tcase ISCSI_FLASHNODE_INITIAL_R2T_EN:\n\t\tcase ISCSI_FLASHNODE_DATASEQ_INORDER:\n\t\tcase ISCSI_FLASHNODE_PDU_INORDER:\n\t\tcase ISCSI_FLASHNODE_CHAP_AUTH_EN:\n\t\tcase ISCSI_FLASHNODE_SNACK_REQ_EN:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\n\t\tcase ISCSI_FLASHNODE_BIDI_CHAP_EN:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\n\t\tcase ISCSI_FLASHNODE_ERL:\n\t\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\n\t\tcase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\n\t\tcase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\n\t\tcase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\n\t\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\n\t\tcase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\n\t\tcase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_FLASHNODE_FIRST_BURST:\n\t\tcase ISCSI_FLASHNODE_DEF_TIME2WAIT:\n\t\tcase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\n\t\tcase ISCSI_FLASHNODE_MAX_R2T:\n\t\tcase ISCSI_FLASHNODE_KEEPALIVE_TMO:\n\t\tcase ISCSI_FLASHNODE_ISID:\n\t\tcase ISCSI_FLASHNODE_TSID:\n\t\tcase ISCSI_FLASHNODE_PORT:\n\t\tcase ISCSI_FLASHNODE_MAX_BURST:\n\t\tcase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\n\t\tcase ISCSI_FLASHNODE_IPADDR:\n\t\tcase ISCSI_FLASHNODE_ALIAS:\n\t\tcase ISCSI_FLASHNODE_REDIRECT_IPADDR:\n\t\tcase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\n\t\tcase ISCSI_FLASHNODE_LOCAL_PORT:\n\t\tcase ISCSI_FLASHNODE_IPV4_TOS:\n\t\tcase ISCSI_FLASHNODE_IPV6_TC:\n\t\tcase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\n\t\tcase ISCSI_FLASHNODE_NAME:\n\t\tcase ISCSI_FLASHNODE_TPGT:\n\t\tcase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE:\n\t\tcase ISCSI_FLASHNODE_TCP_XMIT_WSF:\n\t\tcase ISCSI_FLASHNODE_TCP_RECV_WSF:\n\t\tcase ISCSI_FLASHNODE_CHAP_OUT_IDX:\n\t\tcase ISCSI_FLASHNODE_USERNAME:\n\t\tcase ISCSI_FLASHNODE_PASSWORD:\n\t\tcase ISCSI_FLASHNODE_STATSN:\n\t\tcase ISCSI_FLASHNODE_EXP_STATSN:\n\t\tcase ISCSI_FLASHNODE_IS_BOOT_TGT:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void qla4xxx_create_chap_list(struct scsi_qla_host *ha)\n{\n\tint rval = 0;\n\tuint8_t *chap_flash_data = NULL;\n\tuint32_t offset;\n\tdma_addr_t chap_dma;\n\tuint32_t chap_size = 0;\n\n\tif (is_qla40XX(ha))\n\t\tchap_size = MAX_CHAP_ENTRIES_40XX *\n\t\t\t    sizeof(struct ql4_chap_table);\n\telse\t \n\t\tchap_size = ha->hw.flt_chap_size / 2;\n\n\tchap_flash_data = dma_alloc_coherent(&ha->pdev->dev, chap_size,\n\t\t\t\t\t     &chap_dma, GFP_KERNEL);\n\tif (!chap_flash_data) {\n\t\tql4_printk(KERN_ERR, ha, \"No memory for chap_flash_data\\n\");\n\t\treturn;\n\t}\n\n\tif (is_qla40XX(ha)) {\n\t\toffset = FLASH_CHAP_OFFSET;\n\t} else {\n\t\toffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\n\t\tif (ha->port_num == 1)\n\t\t\toffset += chap_size;\n\t}\n\n\trval = qla4xxx_get_flash(ha, chap_dma, offset, chap_size);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto exit_chap_list;\n\n\tif (ha->chap_list == NULL)\n\t\tha->chap_list = vmalloc(chap_size);\n\tif (ha->chap_list == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"No memory for ha->chap_list\\n\");\n\t\tgoto exit_chap_list;\n\t}\n\n\tmemcpy(ha->chap_list, chap_flash_data, chap_size);\n\nexit_chap_list:\n\tdma_free_coherent(&ha->pdev->dev, chap_size, chap_flash_data, chap_dma);\n}\n\nstatic int qla4xxx_get_chap_by_index(struct scsi_qla_host *ha,\n\t\t\t\t     int16_t chap_index,\n\t\t\t\t     struct ql4_chap_table **chap_entry)\n{\n\tint rval = QLA_ERROR;\n\tint max_chap_entries;\n\n\tif (!ha->chap_list) {\n\t\tql4_printk(KERN_ERR, ha, \"CHAP table cache is empty!\\n\");\n\t\tgoto exit_get_chap;\n\t}\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t   sizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (chap_index > max_chap_entries) {\n\t\tql4_printk(KERN_ERR, ha, \"Invalid Chap index\\n\");\n\t\tgoto exit_get_chap;\n\t}\n\n\t*chap_entry = (struct ql4_chap_table *)ha->chap_list + chap_index;\n\tif ((*chap_entry)->cookie !=\n\t     cpu_to_le16(CHAP_VALID_COOKIE)) {\n\t\t*chap_entry = NULL;\n\t} else {\n\t\trval = QLA_SUCCESS;\n\t}\n\nexit_get_chap:\n\treturn rval;\n}\n\n \nstatic int qla4xxx_find_free_chap_index(struct scsi_qla_host *ha,\n\t\t\t\t\tuint16_t *chap_index)\n{\n\tint i, rval;\n\tint free_index = -1;\n\tint max_chap_entries = 0;\n\tstruct ql4_chap_table *chap_table;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t\t\tsizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (!ha->chap_list) {\n\t\tql4_printk(KERN_ERR, ha, \"CHAP table cache is empty!\\n\");\n\t\trval = QLA_ERROR;\n\t\tgoto exit_find_chap;\n\t}\n\n\tfor (i = 0; i < max_chap_entries; i++) {\n\t\tchap_table = (struct ql4_chap_table *)ha->chap_list + i;\n\n\t\tif ((chap_table->cookie !=\n\t\t    cpu_to_le16(CHAP_VALID_COOKIE)) &&\n\t\t   (i > MAX_RESRV_CHAP_IDX)) {\n\t\t\t\tfree_index = i;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (free_index != -1) {\n\t\t*chap_index = free_index;\n\t\trval = QLA_SUCCESS;\n\t} else {\n\t\trval = QLA_ERROR;\n\t}\n\nexit_find_chap:\n\treturn rval;\n}\n\nstatic int qla4xxx_get_chap_list(struct Scsi_Host *shost, uint16_t chap_tbl_idx,\n\t\t\t\t  uint32_t *num_entries, char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct ql4_chap_table *chap_table;\n\tstruct iscsi_chap_rec *chap_rec;\n\tint max_chap_entries = 0;\n\tint valid_chap_entries = 0;\n\tint ret = 0, i;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t\tsizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tql4_printk(KERN_INFO, ha, \"%s: num_entries = %d, CHAP idx = %d\\n\",\n\t\t\t__func__, *num_entries, chap_tbl_idx);\n\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_get_chap_list;\n\t}\n\n\tqla4xxx_create_chap_list(ha);\n\n\tchap_rec = (struct iscsi_chap_rec *) buf;\n\tmutex_lock(&ha->chap_sem);\n\tfor (i = chap_tbl_idx; i < max_chap_entries; i++) {\n\t\tchap_table = (struct ql4_chap_table *)ha->chap_list + i;\n\t\tif (chap_table->cookie !=\n\t\t    cpu_to_le16(CHAP_VALID_COOKIE))\n\t\t\tcontinue;\n\n\t\tchap_rec->chap_tbl_idx = i;\n\t\tstrscpy(chap_rec->username, chap_table->name,\n\t\t\tISCSI_CHAP_AUTH_NAME_MAX_LEN);\n\t\tstrscpy(chap_rec->password, chap_table->secret,\n\t\t\tQL4_CHAP_MAX_SECRET_LEN);\n\t\tchap_rec->password_length = chap_table->secret_len;\n\n\t\tif (chap_table->flags & BIT_7)  \n\t\t\tchap_rec->chap_type = CHAP_TYPE_OUT;\n\n\t\tif (chap_table->flags & BIT_6)  \n\t\t\tchap_rec->chap_type = CHAP_TYPE_IN;\n\n\t\tchap_rec++;\n\n\t\tvalid_chap_entries++;\n\t\tif (valid_chap_entries == *num_entries)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&ha->chap_sem);\n\nexit_get_chap_list:\n\tql4_printk(KERN_INFO, ha, \"%s: Valid CHAP Entries = %d\\n\",\n\t\t\t__func__,  valid_chap_entries);\n\t*num_entries = valid_chap_entries;\n\treturn ret;\n}\n\nstatic int __qla4xxx_is_chap_active(struct device *dev, void *data)\n{\n\tint ret = 0;\n\tuint16_t *chap_tbl_idx = (uint16_t *) data;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\n\tif (!iscsi_is_session_dev(dev))\n\t\tgoto exit_is_chap_active;\n\n\tcls_session = iscsi_dev_to_session(dev);\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\n\tif (iscsi_is_session_online(cls_session))\n\t\tgoto exit_is_chap_active;\n\n\tif (ddb_entry->chap_tbl_idx == *chap_tbl_idx)\n\t\tret = 1;\n\nexit_is_chap_active:\n\treturn ret;\n}\n\nstatic int qla4xxx_is_chap_active(struct Scsi_Host *shost,\n\t\t\t\t  uint16_t chap_tbl_idx)\n{\n\tint ret = 0;\n\n\tret = device_for_each_child(&shost->shost_gendev, &chap_tbl_idx,\n\t\t\t\t    __qla4xxx_is_chap_active);\n\n\treturn ret;\n}\n\nstatic int qla4xxx_delete_chap(struct Scsi_Host *shost, uint16_t chap_tbl_idx)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct ql4_chap_table *chap_table;\n\tdma_addr_t chap_dma;\n\tint max_chap_entries = 0;\n\tuint32_t offset = 0;\n\tuint32_t chap_size;\n\tint ret = 0;\n\n\tchap_table = dma_pool_zalloc(ha->chap_dma_pool, GFP_KERNEL, &chap_dma);\n\tif (chap_table == NULL)\n\t\treturn -ENOMEM;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t   sizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (chap_tbl_idx > max_chap_entries) {\n\t\tret = -EINVAL;\n\t\tgoto exit_delete_chap;\n\t}\n\n\t \n\tret = qla4xxx_is_chap_active(shost, chap_tbl_idx);\n\tif (ret) {\n\t\tql4_printk(KERN_INFO, ha, \"CHAP entry %d is in use, cannot \"\n\t\t\t   \"delete from flash\\n\", chap_tbl_idx);\n\t\tret = -EBUSY;\n\t\tgoto exit_delete_chap;\n\t}\n\n\tchap_size = sizeof(struct ql4_chap_table);\n\tif (is_qla40XX(ha))\n\t\toffset = FLASH_CHAP_OFFSET | (chap_tbl_idx * chap_size);\n\telse {\n\t\toffset = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_region_chap << 2);\n\t\t \n\t\tif (ha->port_num == 1)\n\t\t\toffset += (ha->hw.flt_chap_size / 2);\n\t\toffset += (chap_tbl_idx * chap_size);\n\t}\n\n\tret = qla4xxx_get_flash(ha, chap_dma, offset, chap_size);\n\tif (ret != QLA_SUCCESS) {\n\t\tret = -EINVAL;\n\t\tgoto exit_delete_chap;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Chap Cookie: x%x\\n\",\n\t\t\t  __le16_to_cpu(chap_table->cookie)));\n\n\tif (__le16_to_cpu(chap_table->cookie) != CHAP_VALID_COOKIE) {\n\t\tql4_printk(KERN_ERR, ha, \"No valid chap entry found\\n\");\n\t\tgoto exit_delete_chap;\n\t}\n\n\tchap_table->cookie = cpu_to_le16(0xFFFF);\n\n\toffset = FLASH_CHAP_OFFSET |\n\t\t\t(chap_tbl_idx * sizeof(struct ql4_chap_table));\n\tret = qla4xxx_set_flash(ha, chap_dma, offset, chap_size,\n\t\t\t\tFLASH_OPT_RMW_COMMIT);\n\tif (ret == QLA_SUCCESS && ha->chap_list) {\n\t\tmutex_lock(&ha->chap_sem);\n\t\t \n\t\tmemcpy((struct ql4_chap_table *)ha->chap_list + chap_tbl_idx,\n\t\t\tchap_table, sizeof(struct ql4_chap_table));\n\t\tmutex_unlock(&ha->chap_sem);\n\t}\n\tif (ret != QLA_SUCCESS)\n\t\tret =  -EINVAL;\n\nexit_delete_chap:\n\tdma_pool_free(ha->chap_dma_pool, chap_table, chap_dma);\n\treturn ret;\n}\n\n \nstatic int qla4xxx_set_chap_entry(struct Scsi_Host *shost, void *data, int len)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_chap_rec chap_rec;\n\tstruct ql4_chap_table *chap_entry = NULL;\n\tstruct iscsi_param_info *param_info;\n\tstruct nlattr *attr;\n\tint max_chap_entries = 0;\n\tint type;\n\tint rem = len;\n\tint rc = 0;\n\tint size;\n\n\tmemset(&chap_rec, 0, sizeof(chap_rec));\n\n\tnla_for_each_attr(attr, data, len, rem) {\n\t\tif (nla_len(attr) < sizeof(*param_info)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto exit_set_chap;\n\t\t}\n\n\t\tparam_info = nla_data(attr);\n\n\t\tswitch (param_info->param) {\n\t\tcase ISCSI_CHAP_PARAM_INDEX:\n\t\t\tchap_rec.chap_tbl_idx = *(uint16_t *)param_info->value;\n\t\t\tbreak;\n\t\tcase ISCSI_CHAP_PARAM_CHAP_TYPE:\n\t\t\tchap_rec.chap_type = param_info->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_CHAP_PARAM_USERNAME:\n\t\t\tsize = min_t(size_t, sizeof(chap_rec.username),\n\t\t\t\t     param_info->len);\n\t\t\tmemcpy(chap_rec.username, param_info->value, size);\n\t\t\tbreak;\n\t\tcase ISCSI_CHAP_PARAM_PASSWORD:\n\t\t\tsize = min_t(size_t, sizeof(chap_rec.password),\n\t\t\t\t     param_info->len);\n\t\t\tmemcpy(chap_rec.password, param_info->value, size);\n\t\t\tbreak;\n\t\tcase ISCSI_CHAP_PARAM_PASSWORD_LEN:\n\t\t\tchap_rec.password_length = param_info->value[0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"%s: No such sysfs attribute\\n\", __func__);\n\t\t\trc = -ENOSYS;\n\t\t\tgoto exit_set_chap;\n\t\t}\n\t}\n\n\tif (chap_rec.chap_type == CHAP_TYPE_IN)\n\t\ttype = BIDI_CHAP;\n\telse\n\t\ttype = LOCAL_CHAP;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t   sizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tmutex_lock(&ha->chap_sem);\n\tif (chap_rec.chap_tbl_idx < max_chap_entries) {\n\t\trc = qla4xxx_get_chap_by_index(ha, chap_rec.chap_tbl_idx,\n\t\t\t\t\t       &chap_entry);\n\t\tif (!rc) {\n\t\t\tif (!(type == qla4xxx_get_chap_type(chap_entry))) {\n\t\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t\t   \"Type mismatch for CHAP entry %d\\n\",\n\t\t\t\t\t   chap_rec.chap_tbl_idx);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto exit_unlock_chap;\n\t\t\t}\n\n\t\t\t \n\t\t\trc = qla4xxx_is_chap_active(shost,\n\t\t\t\t\t\t    chap_rec.chap_tbl_idx);\n\t\t\tif (rc) {\n\t\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t\t   \"CHAP entry %d is in use\\n\",\n\t\t\t\t\t   chap_rec.chap_tbl_idx);\n\t\t\t\trc = -EBUSY;\n\t\t\t\tgoto exit_unlock_chap;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = qla4xxx_find_free_chap_index(ha, &chap_rec.chap_tbl_idx);\n\t\tif (rc) {\n\t\t\tql4_printk(KERN_INFO, ha, \"CHAP entry not available\\n\");\n\t\t\trc = -EBUSY;\n\t\t\tgoto exit_unlock_chap;\n\t\t}\n\t}\n\n\trc = qla4xxx_set_chap(ha, chap_rec.username, chap_rec.password,\n\t\t\t      chap_rec.chap_tbl_idx, type);\n\nexit_unlock_chap:\n\tmutex_unlock(&ha->chap_sem);\n\nexit_set_chap:\n\treturn rc;\n}\n\n\nstatic int qla4xxx_get_host_stats(struct Scsi_Host *shost, char *buf, int len)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_offload_host_stats *host_stats = NULL;\n\tint host_stats_size;\n\tint ret = 0;\n\tint ddb_idx = 0;\n\tstruct ql_iscsi_stats *ql_iscsi_stats = NULL;\n\tint stats_size;\n\tdma_addr_t iscsi_stats_dma;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Func: %s\\n\", __func__));\n\n\thost_stats_size = sizeof(struct iscsi_offload_host_stats);\n\n\tif (host_stats_size != len) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: host_stats size mismatch expected = %d, is = %d\\n\",\n\t\t\t   __func__, len, host_stats_size);\n\t\tret = -EINVAL;\n\t\tgoto exit_host_stats;\n\t}\n\thost_stats = (struct iscsi_offload_host_stats *)buf;\n\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_host_stats;\n\t}\n\n\tstats_size = PAGE_ALIGN(sizeof(struct ql_iscsi_stats));\n\n\tql_iscsi_stats = dma_alloc_coherent(&ha->pdev->dev, stats_size,\n\t\t\t\t\t    &iscsi_stats_dma, GFP_KERNEL);\n\tif (!ql_iscsi_stats) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to allocate memory for iscsi stats\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto exit_host_stats;\n\t}\n\n\tret =  qla4xxx_get_mgmt_data(ha, ddb_idx, stats_size,\n\t\t\t\t     iscsi_stats_dma);\n\tif (ret != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to retrieve iscsi stats\\n\");\n\t\tret = -EIO;\n\t\tgoto exit_host_stats;\n\t}\n\thost_stats->mactx_frames = le64_to_cpu(ql_iscsi_stats->mac_tx_frames);\n\thost_stats->mactx_bytes = le64_to_cpu(ql_iscsi_stats->mac_tx_bytes);\n\thost_stats->mactx_multicast_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_multicast_frames);\n\thost_stats->mactx_broadcast_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_broadcast_frames);\n\thost_stats->mactx_pause_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_pause_frames);\n\thost_stats->mactx_control_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_control_frames);\n\thost_stats->mactx_deferral =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_deferral);\n\thost_stats->mactx_excess_deferral =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_excess_deferral);\n\thost_stats->mactx_late_collision =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_late_collision);\n\thost_stats->mactx_abort\t= le64_to_cpu(ql_iscsi_stats->mac_tx_abort);\n\thost_stats->mactx_single_collision =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_single_collision);\n\thost_stats->mactx_multiple_collision =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_multiple_collision);\n\thost_stats->mactx_collision =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_collision);\n\thost_stats->mactx_frames_dropped =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_frames_dropped);\n\thost_stats->mactx_jumbo_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_tx_jumbo_frames);\n\thost_stats->macrx_frames = le64_to_cpu(ql_iscsi_stats->mac_rx_frames);\n\thost_stats->macrx_bytes = le64_to_cpu(ql_iscsi_stats->mac_rx_bytes);\n\thost_stats->macrx_unknown_control_frames =\n\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_unknown_control_frames);\n\thost_stats->macrx_pause_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_pause_frames);\n\thost_stats->macrx_control_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_control_frames);\n\thost_stats->macrx_dribble =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_dribble);\n\thost_stats->macrx_frame_length_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_frame_length_error);\n\thost_stats->macrx_jabber = le64_to_cpu(ql_iscsi_stats->mac_rx_jabber);\n\thost_stats->macrx_carrier_sense_error =\n\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_carrier_sense_error);\n\thost_stats->macrx_frame_discarded =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_frame_discarded);\n\thost_stats->macrx_frames_dropped =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_frames_dropped);\n\thost_stats->mac_crc_error = le64_to_cpu(ql_iscsi_stats->mac_crc_error);\n\thost_stats->mac_encoding_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_encoding_error);\n\thost_stats->macrx_length_error_large =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_length_error_large);\n\thost_stats->macrx_length_error_small =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_length_error_small);\n\thost_stats->macrx_multicast_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_multicast_frames);\n\thost_stats->macrx_broadcast_frames =\n\t\t\tle64_to_cpu(ql_iscsi_stats->mac_rx_broadcast_frames);\n\thost_stats->iptx_packets = le64_to_cpu(ql_iscsi_stats->ip_tx_packets);\n\thost_stats->iptx_bytes = le64_to_cpu(ql_iscsi_stats->ip_tx_bytes);\n\thost_stats->iptx_fragments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_tx_fragments);\n\thost_stats->iprx_packets = le64_to_cpu(ql_iscsi_stats->ip_rx_packets);\n\thost_stats->iprx_bytes = le64_to_cpu(ql_iscsi_stats->ip_rx_bytes);\n\thost_stats->iprx_fragments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_rx_fragments);\n\thost_stats->ip_datagram_reassembly =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_datagram_reassembly);\n\thost_stats->ip_invalid_address_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_invalid_address_error);\n\thost_stats->ip_error_packets =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_error_packets);\n\thost_stats->ip_fragrx_overlap =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_fragrx_overlap);\n\thost_stats->ip_fragrx_outoforder =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ip_fragrx_outoforder);\n\thost_stats->ip_datagram_reassembly_timeout =\n\t\tle64_to_cpu(ql_iscsi_stats->ip_datagram_reassembly_timeout);\n\thost_stats->ipv6tx_packets =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_tx_packets);\n\thost_stats->ipv6tx_bytes = le64_to_cpu(ql_iscsi_stats->ipv6_tx_bytes);\n\thost_stats->ipv6tx_fragments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_tx_fragments);\n\thost_stats->ipv6rx_packets =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_rx_packets);\n\thost_stats->ipv6rx_bytes = le64_to_cpu(ql_iscsi_stats->ipv6_rx_bytes);\n\thost_stats->ipv6rx_fragments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_rx_fragments);\n\thost_stats->ipv6_datagram_reassembly =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_datagram_reassembly);\n\thost_stats->ipv6_invalid_address_error =\n\t\tle64_to_cpu(ql_iscsi_stats->ipv6_invalid_address_error);\n\thost_stats->ipv6_error_packets =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_error_packets);\n\thost_stats->ipv6_fragrx_overlap =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_fragrx_overlap);\n\thost_stats->ipv6_fragrx_outoforder =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ipv6_fragrx_outoforder);\n\thost_stats->ipv6_datagram_reassembly_timeout =\n\t\tle64_to_cpu(ql_iscsi_stats->ipv6_datagram_reassembly_timeout);\n\thost_stats->tcptx_segments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_tx_segments);\n\thost_stats->tcptx_bytes\t= le64_to_cpu(ql_iscsi_stats->tcp_tx_bytes);\n\thost_stats->tcprx_segments =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_segments);\n\thost_stats->tcprx_byte = le64_to_cpu(ql_iscsi_stats->tcp_rx_byte);\n\thost_stats->tcp_duplicate_ack_retx =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_duplicate_ack_retx);\n\thost_stats->tcp_retx_timer_expired =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_retx_timer_expired);\n\thost_stats->tcprx_duplicate_ack\t=\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_duplicate_ack);\n\thost_stats->tcprx_pure_ackr =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_pure_ackr);\n\thost_stats->tcptx_delayed_ack =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_tx_delayed_ack);\n\thost_stats->tcptx_pure_ack =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_tx_pure_ack);\n\thost_stats->tcprx_segment_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_segment_error);\n\thost_stats->tcprx_segment_outoforder =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_segment_outoforder);\n\thost_stats->tcprx_window_probe =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_window_probe);\n\thost_stats->tcprx_window_update =\n\t\t\tle64_to_cpu(ql_iscsi_stats->tcp_rx_window_update);\n\thost_stats->tcptx_window_probe_persist =\n\t\tle64_to_cpu(ql_iscsi_stats->tcp_tx_window_probe_persist);\n\thost_stats->ecc_error_correction =\n\t\t\tle64_to_cpu(ql_iscsi_stats->ecc_error_correction);\n\thost_stats->iscsi_pdu_tx = le64_to_cpu(ql_iscsi_stats->iscsi_pdu_tx);\n\thost_stats->iscsi_data_bytes_tx =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_data_bytes_tx);\n\thost_stats->iscsi_pdu_rx = le64_to_cpu(ql_iscsi_stats->iscsi_pdu_rx);\n\thost_stats->iscsi_data_bytes_rx\t=\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_data_bytes_rx);\n\thost_stats->iscsi_io_completed =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_io_completed);\n\thost_stats->iscsi_unexpected_io_rx =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_unexpected_io_rx);\n\thost_stats->iscsi_format_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_format_error);\n\thost_stats->iscsi_hdr_digest_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_hdr_digest_error);\n\thost_stats->iscsi_data_digest_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_data_digest_error);\n\thost_stats->iscsi_sequence_error =\n\t\t\tle64_to_cpu(ql_iscsi_stats->iscsi_sequence_error);\nexit_host_stats:\n\tif (ql_iscsi_stats)\n\t\tdma_free_coherent(&ha->pdev->dev, stats_size,\n\t\t\t\t  ql_iscsi_stats, iscsi_stats_dma);\n\n\tql4_printk(KERN_INFO, ha, \"%s: Get host stats done\\n\",\n\t\t   __func__);\n\treturn ret;\n}\n\nstatic int qla4xxx_get_iface_param(struct iscsi_iface *iface,\n\t\t\t\t   enum iscsi_param_type param_type,\n\t\t\t\t   int param, char *buf)\n{\n\tstruct Scsi_Host *shost = iscsi_iface_to_shost(iface);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tint ival;\n\tchar *pval = NULL;\n\tint len = -ENOSYS;\n\n\tif (param_type == ISCSI_NET_PARAM) {\n\t\tswitch (param) {\n\t\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", &ha->ip_config.ip_address);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\t\tlen = sprintf(buf, \"%pI4\\n\",\n\t\t\t\t      &ha->ip_config.subnet_mask);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", &ha->ip_config.gateway);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t\t IPOPT_IPV4_PROTOCOL_ENABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(ha->ip_config.ipv6_options,\n\t\t\t\t\t IPV6_OPT_IPV6_PROTOCOL_ENABLE, pval);\n\t\t\t}\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\t\tlen = sprintf(buf, \"%s\\n\",\n\t\t\t\t      (ha->ip_config.tcp_options &\n\t\t\t\t       TCPOPT_DHCP_ENABLE) ?\n\t\t\t\t      \"dhcp\" : \"static\");\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\t\tif (iface->iface_num == 0)\n\t\t\t\tlen = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t\t      &ha->ip_config.ipv6_addr0);\n\t\t\tif (iface->iface_num == 1)\n\t\t\t\tlen = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t\t      &ha->ip_config.ipv6_addr1);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\n\t\t\tlen = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t      &ha->ip_config.ipv6_link_local_addr);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ROUTER:\n\t\t\tlen = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t      &ha->ip_config.ipv6_default_router_addr);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\n\t\t\tpval = (ha->ip_config.ipv6_addl_options &\n\t\t\t\tIPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE) ?\n\t\t\t\t\"nd\" : \"static\";\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\n\t\t\tpval = (ha->ip_config.ipv6_addl_options &\n\t\t\t\tIPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR) ?\n\t\t\t\t\"auto\" : \"static\";\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_VLAN_ID:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tival = ha->ip_config.ipv4_vlan_tag &\n\t\t\t\t       ISCSI_MAX_VLAN_ID;\n\t\t\telse\n\t\t\t\tival = ha->ip_config.ipv6_vlan_tag &\n\t\t\t\t       ISCSI_MAX_VLAN_ID;\n\n\t\t\tlen = sprintf(buf, \"%d\\n\", ival);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_VLAN_PRIORITY:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tival = (ha->ip_config.ipv4_vlan_tag >> 13) &\n\t\t\t\t       ISCSI_MAX_VLAN_PRIORITY;\n\t\t\telse\n\t\t\t\tival = (ha->ip_config.ipv6_vlan_tag >> 13) &\n\t\t\t\t       ISCSI_MAX_VLAN_PRIORITY;\n\n\t\t\tlen = sprintf(buf, \"%d\\n\", ival);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t\t IPOPT_VLAN_TAGGING_ENABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(ha->ip_config.ipv6_options,\n\t\t\t\t\t IPV6_OPT_VLAN_TAGGING_ENABLE, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_MTU:\n\t\t\tlen = sprintf(buf, \"%d\\n\", ha->ip_config.eth_mtu_size);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_PORT:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv4_port);\n\t\t\telse\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv6_port);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPADDR_STATE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tpval = iscsi_get_ipaddress_state_name(\n\t\t\t\t\t\tha->ip_config.ipv4_addr_state);\n\t\t\t} else {\n\t\t\t\tif (iface->iface_num == 0)\n\t\t\t\t\tpval = iscsi_get_ipaddress_state_name(\n\t\t\t\t\t\tha->ip_config.ipv6_addr0_state);\n\t\t\t\telse if (iface->iface_num == 1)\n\t\t\t\t\tpval = iscsi_get_ipaddress_state_name(\n\t\t\t\t\t\tha->ip_config.ipv6_addr1_state);\n\t\t\t}\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_STATE:\n\t\t\tpval = iscsi_get_ipaddress_state_name(\n\t\t\t\t\tha->ip_config.ipv6_link_local_state);\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ROUTER_STATE:\n\t\t\tpval = iscsi_get_router_state_name(\n\t\t\t\t      ha->ip_config.ipv6_default_router_state);\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_DELAYED_ACK_EN:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(~ha->ip_config.tcp_options,\n\t\t\t\t\t TCPOPT_DELAYED_ACK_DISABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(~ha->ip_config.ipv6_tcp_options,\n\t\t\t\t\t IPV6_TCPOPT_DELAYED_ACK_DISABLE, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(~ha->ip_config.tcp_options,\n\t\t\t\t\t TCPOPT_NAGLE_ALGO_DISABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(~ha->ip_config.ipv6_tcp_options,\n\t\t\t\t\t IPV6_TCPOPT_NAGLE_ALGO_DISABLE, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(~ha->ip_config.tcp_options,\n\t\t\t\t\t TCPOPT_WINDOW_SCALE_DISABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(~ha->ip_config.ipv6_tcp_options,\n\t\t\t\t\t IPV6_TCPOPT_WINDOW_SCALE_DISABLE,\n\t\t\t\t\t pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_WSF:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.tcp_wsf);\n\t\t\telse\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv6_tcp_wsf);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tival = (ha->ip_config.tcp_options &\n\t\t\t\t\tTCPOPT_TIMER_SCALE) >> 1;\n\t\t\telse\n\t\t\t\tival = (ha->ip_config.ipv6_tcp_options &\n\t\t\t\t\tIPV6_TCPOPT_TIMER_SCALE) >> 1;\n\n\t\t\tlen = sprintf(buf, \"%d\\n\", ival);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(ha->ip_config.tcp_options,\n\t\t\t\t\t TCPOPT_TIMESTAMP_ENABLE, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(ha->ip_config.ipv6_tcp_options,\n\t\t\t\t\t IPV6_TCPOPT_TIMESTAMP_EN, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_CACHE_ID:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv4_cache_id);\n\t\t\telse\n\t\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t\t      ha->ip_config.ipv6_cache_id);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\n\t\t\tOP_STATE(ha->ip_config.tcp_options,\n\t\t\t\t TCPOPT_DNS_SERVER_IP_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\n\t\t\tOP_STATE(ha->ip_config.tcp_options,\n\t\t\t\t TCPOPT_SLP_DA_INFO_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_TOS_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_IPV4_TOS_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_TOS:\n\t\t\tlen = sprintf(buf, \"%d\\n\", ha->ip_config.ipv4_tos);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_GRAT_ARP_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options, IPOPT_ALT_CID_EN,\n\t\t\t\t pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\n\t\t\tpval = (ha->ip_config.ipv4_alt_cid_len) ?\n\t\t\t       (char *)ha->ip_config.ipv4_alt_cid : \"\";\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_REQ_VID_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_USE_VID_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\n\t\t\tpval = (ha->ip_config.ipv4_vid_len) ?\n\t\t\t       (char *)ha->ip_config.ipv4_vid : \"\";\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_LEARN_IQN_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\n\t\t\tOP_STATE(~ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_FRAGMENTATION_DISABLE, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t IPOPT_IN_FORWARD_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_REDIRECT_EN:\n\t\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4) {\n\t\t\t\tOP_STATE(ha->ip_config.ipv4_options,\n\t\t\t\t\t IPOPT_ARP_REDIRECT_EN, pval);\n\t\t\t} else {\n\t\t\t\tOP_STATE(ha->ip_config.ipv6_options,\n\t\t\t\t\t IPV6_OPT_REDIRECT_EN, pval);\n\t\t\t}\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV4_TTL:\n\t\t\tlen = sprintf(buf, \"%d\\n\", ha->ip_config.ipv4_ttl);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv6_options,\n\t\t\t\t IPV6_OPT_GRAT_NEIGHBOR_ADV_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_MLD_EN:\n\t\t\tOP_STATE(ha->ip_config.ipv6_addl_options,\n\t\t\t\t IPV6_ADDOPT_MLD_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\n\t\t\tlen = sprintf(buf, \"%u\\n\", ha->ip_config.ipv6_flow_lbl);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_traffic_class);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_hop_limit);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_nd_reach_time);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_nd_rexmit_timer);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_nd_stale_timeout);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_dup_addr_detect_count);\n\t\t\tbreak;\n\t\tcase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.ipv6_gw_advrt_mtu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen = -ENOSYS;\n\t\t}\n\t} else if (param_type == ISCSI_IFACE_PARAM) {\n\t\tswitch (param) {\n\t\tcase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\n\t\t\tlen = sprintf(buf, \"%d\\n\", ha->ip_config.def_timeout);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_HDRDGST_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_HEADER_DIGEST_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_DATADGST_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DATA_DIGEST_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_IMM_DATA_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_IMMEDIATE_DATA_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_INITIAL_R2T_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DATA_SEQ_INORDER_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DATA_PDU_INORDER_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_ERL:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      (ha->ip_config.iscsi_options &\n\t\t\t\t       ISCSIOPTS_ERL));\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\n\t\t\tlen = sprintf(buf, \"%u\\n\",\n\t\t\t\t      ha->ip_config.iscsi_max_pdu_size *\n\t\t\t\t      BYTE_UNITS);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_FIRST_BURST:\n\t\t\tlen = sprintf(buf, \"%u\\n\",\n\t\t\t\t      ha->ip_config.iscsi_first_burst_len *\n\t\t\t\t      BYTE_UNITS);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_MAX_R2T:\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ha->ip_config.iscsi_max_outstnd_r2t);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_MAX_BURST:\n\t\t\tlen = sprintf(buf, \"%u\\n\",\n\t\t\t\t      ha->ip_config.iscsi_max_burst_len *\n\t\t\t\t      BYTE_UNITS);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_CHAP_AUTH_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_BIDI_CHAP_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DISCOVERY_AUTH_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_DISCOVERY_LOGOUT_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\n\t\t\tOP_STATE(ha->ip_config.iscsi_options,\n\t\t\t\t ISCSIOPTS_STRICT_LOGIN_COMP_EN, pval);\n\n\t\t\tlen = sprintf(buf, \"%s\\n\", pval);\n\t\t\tbreak;\n\t\tcase ISCSI_IFACE_PARAM_INITIATOR_NAME:\n\t\t\tlen = sprintf(buf, \"%s\\n\", ha->ip_config.iscsi_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen = -ENOSYS;\n\t\t}\n\t}\n\n\treturn len;\n}\n\nstatic struct iscsi_endpoint *\nqla4xxx_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\n\t\t   int non_blocking)\n{\n\tint ret;\n\tstruct iscsi_endpoint *ep;\n\tstruct qla_endpoint *qla_ep;\n\tstruct scsi_qla_host *ha;\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\n\tif (!shost) {\n\t\tret = -ENXIO;\n\t\tpr_err(\"%s: shost is NULL\\n\", __func__);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tha = iscsi_host_priv(shost);\n\tep = iscsi_create_endpoint(sizeof(struct qla_endpoint));\n\tif (!ep) {\n\t\tret = -ENOMEM;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tqla_ep = ep->dd_data;\n\tmemset(qla_ep, 0, sizeof(struct qla_endpoint));\n\tif (dst_addr->sa_family == AF_INET) {\n\t\tmemcpy(&qla_ep->dst_addr, dst_addr, sizeof(struct sockaddr_in));\n\t\taddr = (struct sockaddr_in *)&qla_ep->dst_addr;\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: %pI4\\n\", __func__,\n\t\t\t\t  (char *)&addr->sin_addr));\n\t} else if (dst_addr->sa_family == AF_INET6) {\n\t\tmemcpy(&qla_ep->dst_addr, dst_addr,\n\t\t       sizeof(struct sockaddr_in6));\n\t\taddr6 = (struct sockaddr_in6 *)&qla_ep->dst_addr;\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: %pI6\\n\", __func__,\n\t\t\t\t  (char *)&addr6->sin6_addr));\n\t} else {\n\t\tql4_printk(KERN_WARNING, ha, \"%s: Invalid endpoint\\n\",\n\t\t\t   __func__);\n\t}\n\n\tqla_ep->host = shost;\n\n\treturn ep;\n}\n\nstatic int qla4xxx_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\n{\n\tstruct qla_endpoint *qla_ep;\n\tstruct scsi_qla_host *ha;\n\tint ret = 0;\n\n\tqla_ep = ep->dd_data;\n\tha = to_qla_host(qla_ep->host);\n\tDEBUG2(pr_info_ratelimited(\"%s: host: %ld\\n\", __func__, ha->host_no));\n\n\tif (adapter_up(ha) && !test_bit(AF_BUILD_DDB_LIST, &ha->flags))\n\t\tret = 1;\n\n\treturn ret;\n}\n\nstatic void qla4xxx_ep_disconnect(struct iscsi_endpoint *ep)\n{\n\tstruct qla_endpoint *qla_ep;\n\tstruct scsi_qla_host *ha;\n\n\tqla_ep = ep->dd_data;\n\tha = to_qla_host(qla_ep->host);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\tiscsi_destroy_endpoint(ep);\n}\n\nstatic int qla4xxx_get_ep_param(struct iscsi_endpoint *ep,\n\t\t\t\tenum iscsi_param param,\n\t\t\t\tchar *buf)\n{\n\tstruct qla_endpoint *qla_ep = ep->dd_data;\n\tstruct sockaddr *dst_addr;\n\tstruct scsi_qla_host *ha;\n\n\tif (!qla_ep)\n\t\treturn -ENOTCONN;\n\n\tha = to_qla_host(qla_ep->host);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tdst_addr = (struct sockaddr *)&qla_ep->dst_addr;\n\t\tif (!dst_addr)\n\t\t\treturn -ENOTCONN;\n\n\t\treturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\n\t\t\t\t\t\t &qla_ep->dst_addr, param, buf);\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\nstatic void qla4xxx_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t   struct iscsi_stats *stats)\n{\n\tstruct iscsi_session *sess;\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tstruct ql_iscsi_stats *ql_iscsi_stats;\n\tint stats_size;\n\tint ret;\n\tdma_addr_t iscsi_stats_dma;\n\n\tcls_sess = iscsi_conn_to_session(cls_conn);\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\tstats_size = PAGE_ALIGN(sizeof(struct ql_iscsi_stats));\n\t \n\tql_iscsi_stats = dma_alloc_coherent(&ha->pdev->dev, stats_size,\n\t\t\t\t\t    &iscsi_stats_dma, GFP_KERNEL);\n\tif (!ql_iscsi_stats) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to allocate memory for iscsi stats\\n\");\n\t\tgoto exit_get_stats;\n\t}\n\n\tret =  qla4xxx_get_mgmt_data(ha, ddb_entry->fw_ddb_index, stats_size,\n\t\t\t\t     iscsi_stats_dma);\n\tif (ret != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to retrieve iscsi stats\\n\");\n\t\tgoto free_stats;\n\t}\n\n\t \n\tstats->txdata_octets = le64_to_cpu(ql_iscsi_stats->tx_data_octets);\n\tstats->rxdata_octets = le64_to_cpu(ql_iscsi_stats->rx_data_octets);\n\t \n\tstats->noptx_pdus = le32_to_cpu(ql_iscsi_stats->tx_nopout_pdus);\n\tstats->scsicmd_pdus = le32_to_cpu(ql_iscsi_stats->tx_scsi_cmd_pdus);\n\tstats->tmfcmd_pdus = le32_to_cpu(ql_iscsi_stats->tx_tmf_cmd_pdus);\n\tstats->login_pdus = le32_to_cpu(ql_iscsi_stats->tx_login_cmd_pdus);\n\tstats->text_pdus = le32_to_cpu(ql_iscsi_stats->tx_text_cmd_pdus);\n\tstats->dataout_pdus = le32_to_cpu(ql_iscsi_stats->tx_scsi_write_pdus);\n\tstats->logout_pdus = le32_to_cpu(ql_iscsi_stats->tx_logout_cmd_pdus);\n\tstats->snack_pdus = le32_to_cpu(ql_iscsi_stats->tx_snack_req_pdus);\n\t \n\tstats->noprx_pdus = le32_to_cpu(ql_iscsi_stats->rx_nopin_pdus);\n\tstats->scsirsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_scsi_resp_pdus);\n\tstats->tmfrsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_tmf_resp_pdus);\n\tstats->textrsp_pdus = le32_to_cpu(ql_iscsi_stats->rx_text_resp_pdus);\n\tstats->datain_pdus = le32_to_cpu(ql_iscsi_stats->rx_scsi_read_pdus);\n\tstats->logoutrsp_pdus =\n\t\t\tle32_to_cpu(ql_iscsi_stats->rx_logout_resp_pdus);\n\tstats->r2t_pdus = le32_to_cpu(ql_iscsi_stats->rx_r2t_pdus);\n\tstats->async_pdus = le32_to_cpu(ql_iscsi_stats->rx_async_pdus);\n\tstats->rjt_pdus = le32_to_cpu(ql_iscsi_stats->rx_reject_pdus);\n\nfree_stats:\n\tdma_free_coherent(&ha->pdev->dev, stats_size, ql_iscsi_stats,\n\t\t\t  iscsi_stats_dma);\nexit_get_stats:\n\treturn;\n}\n\nstatic enum scsi_timeout_action qla4xxx_eh_cmd_timed_out(struct scsi_cmnd *sc)\n{\n\tstruct iscsi_cls_session *session;\n\tunsigned long flags;\n\tenum scsi_timeout_action ret = SCSI_EH_NOT_HANDLED;\n\n\tsession = starget_to_session(scsi_target(sc->device));\n\n\tspin_lock_irqsave(&session->lock, flags);\n\tif (session->state == ISCSI_SESSION_FAILED)\n\t\tret = SCSI_EH_RESET_TIMER;\n\tspin_unlock_irqrestore(&session->lock, flags);\n\n\treturn ret;\n}\n\nstatic void qla4xxx_set_port_speed(struct Scsi_Host *shost)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\tuint32_t speed = ISCSI_PORT_SPEED_UNKNOWN;\n\n\tqla4xxx_get_firmware_state(ha);\n\n\tswitch (ha->addl_fw_state & 0x0F00) {\n\tcase FW_ADDSTATE_LINK_SPEED_10MBPS:\n\t\tspeed = ISCSI_PORT_SPEED_10MBPS;\n\t\tbreak;\n\tcase FW_ADDSTATE_LINK_SPEED_100MBPS:\n\t\tspeed = ISCSI_PORT_SPEED_100MBPS;\n\t\tbreak;\n\tcase FW_ADDSTATE_LINK_SPEED_1GBPS:\n\t\tspeed = ISCSI_PORT_SPEED_1GBPS;\n\t\tbreak;\n\tcase FW_ADDSTATE_LINK_SPEED_10GBPS:\n\t\tspeed = ISCSI_PORT_SPEED_10GBPS;\n\t\tbreak;\n\t}\n\tihost->port_speed = speed;\n}\n\nstatic void qla4xxx_set_port_state(struct Scsi_Host *shost)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\tuint32_t state = ISCSI_PORT_STATE_DOWN;\n\n\tif (test_bit(AF_LINK_UP, &ha->flags))\n\t\tstate = ISCSI_PORT_STATE_UP;\n\n\tihost->port_state = state;\n}\n\nstatic int qla4xxx_host_get_param(struct Scsi_Host *shost,\n\t\t\t\t  enum iscsi_host_param param, char *buf)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tint len;\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tlen = sysfs_format_mac(buf, ha->my_mac, MAC_ADDR_LEN);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_IPADDRESS:\n\t\tlen = sprintf(buf, \"%pI4\\n\", &ha->ip_config.ip_address);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", ha->name_string);\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_PORT_STATE:\n\t\tqla4xxx_set_port_state(shost);\n\t\tlen = sprintf(buf, \"%s\\n\", iscsi_get_port_state_name(shost));\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_PORT_SPEED:\n\t\tqla4xxx_set_port_speed(shost);\n\t\tlen = sprintf(buf, \"%s\\n\", iscsi_get_port_speed_name(shost));\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}\n\nstatic void qla4xxx_create_ipv4_iface(struct scsi_qla_host *ha)\n{\n\tif (ha->iface_ipv4)\n\t\treturn;\n\n\t \n\tha->iface_ipv4 = iscsi_create_iface(ha->host,\n\t\t\t\t\t    &qla4xxx_iscsi_transport,\n\t\t\t\t\t    ISCSI_IFACE_TYPE_IPV4, 0, 0);\n\tif (!ha->iface_ipv4)\n\t\tql4_printk(KERN_ERR, ha, \"Could not create IPv4 iSCSI \"\n\t\t\t   \"iface0.\\n\");\n}\n\nstatic void qla4xxx_create_ipv6_iface(struct scsi_qla_host *ha)\n{\n\tif (!ha->iface_ipv6_0)\n\t\t \n\t\tha->iface_ipv6_0 = iscsi_create_iface(ha->host,\n\t\t\t\t\t\t      &qla4xxx_iscsi_transport,\n\t\t\t\t\t\t      ISCSI_IFACE_TYPE_IPV6, 0,\n\t\t\t\t\t\t      0);\n\tif (!ha->iface_ipv6_0)\n\t\tql4_printk(KERN_ERR, ha, \"Could not create IPv6 iSCSI \"\n\t\t\t   \"iface0.\\n\");\n\n\tif (!ha->iface_ipv6_1)\n\t\t \n\t\tha->iface_ipv6_1 = iscsi_create_iface(ha->host,\n\t\t\t\t\t\t      &qla4xxx_iscsi_transport,\n\t\t\t\t\t\t      ISCSI_IFACE_TYPE_IPV6, 1,\n\t\t\t\t\t\t      0);\n\tif (!ha->iface_ipv6_1)\n\t\tql4_printk(KERN_ERR, ha, \"Could not create IPv6 iSCSI \"\n\t\t\t   \"iface1.\\n\");\n}\n\nstatic void qla4xxx_create_ifaces(struct scsi_qla_host *ha)\n{\n\tif (ha->ip_config.ipv4_options & IPOPT_IPV4_PROTOCOL_ENABLE)\n\t\tqla4xxx_create_ipv4_iface(ha);\n\n\tif (ha->ip_config.ipv6_options & IPV6_OPT_IPV6_PROTOCOL_ENABLE)\n\t\tqla4xxx_create_ipv6_iface(ha);\n}\n\nstatic void qla4xxx_destroy_ipv4_iface(struct scsi_qla_host *ha)\n{\n\tif (ha->iface_ipv4) {\n\t\tiscsi_destroy_iface(ha->iface_ipv4);\n\t\tha->iface_ipv4 = NULL;\n\t}\n}\n\nstatic void qla4xxx_destroy_ipv6_iface(struct scsi_qla_host *ha)\n{\n\tif (ha->iface_ipv6_0) {\n\t\tiscsi_destroy_iface(ha->iface_ipv6_0);\n\t\tha->iface_ipv6_0 = NULL;\n\t}\n\tif (ha->iface_ipv6_1) {\n\t\tiscsi_destroy_iface(ha->iface_ipv6_1);\n\t\tha->iface_ipv6_1 = NULL;\n\t}\n}\n\nstatic void qla4xxx_destroy_ifaces(struct scsi_qla_host *ha)\n{\n\tqla4xxx_destroy_ipv4_iface(ha);\n\tqla4xxx_destroy_ipv6_iface(ha);\n}\n\nstatic void qla4xxx_set_ipv6(struct scsi_qla_host *ha,\n\t\t\t     struct iscsi_iface_param_info *iface_param,\n\t\t\t     struct addr_ctrl_blk *init_fw_cb)\n{\n\t \n\tswitch (iface_param->param) {\n\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\t \n\t\t\tmemcpy(init_fw_cb->ipv6_addr1, iface_param->value,\n\t\t\t       sizeof(init_fw_cb->ipv6_addr1));\n\t\telse\n\t\t\t \n\t\t\tmemcpy(init_fw_cb->ipv6_addr0, iface_param->value,\n\t\t\t       sizeof(init_fw_cb->ipv6_addr0));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tmemcpy(init_fw_cb->ipv6_if_id, &iface_param->value[8],\n\t\t       sizeof(init_fw_cb->ipv6_if_id));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ROUTER:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tmemcpy(init_fw_cb->ipv6_dflt_rtr_addr, iface_param->value,\n\t\t       sizeof(init_fw_cb->ipv6_dflt_rtr_addr));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ADDR_AUTOCFG:\n\t\t \n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\n\t\tif (iface_param->value[0] == ISCSI_IPV6_AUTOCFG_DISABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts &=\n\t\t\t\tcpu_to_le16(\n\t\t\t\t  ~IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE);\n\t\telse if (iface_param->value[0] == ISCSI_IPV6_AUTOCFG_ND_ENABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts |=\n\t\t\t\tcpu_to_le16(\n\t\t\t\t  IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE);\n\t\telse\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"Invalid autocfg setting for IPv6 addr\\n\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_LINKLOCAL_AUTOCFG:\n\t\t \n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\n\t\tif (iface_param->value[0] ==\n\t\t    ISCSI_IPV6_LINKLOCAL_AUTOCFG_ENABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts |= cpu_to_le16(\n\t\t\t\t\tIPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR);\n\t\telse if (iface_param->value[0] ==\n\t\t\t ISCSI_IPV6_LINKLOCAL_AUTOCFG_DISABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts &= cpu_to_le16(\n\t\t\t\t       ~IPV6_ADDOPT_AUTOCONFIG_LINK_LOCAL_ADDR);\n\t\telse\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"Invalid autocfg setting for IPv6 linklocal addr\\n\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ROUTER_AUTOCFG:\n\t\t \n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\n\t\tif (iface_param->value[0] == ISCSI_IPV6_ROUTER_AUTOCFG_ENABLE)\n\t\t\tmemset(init_fw_cb->ipv6_dflt_rtr_addr, 0,\n\t\t\t       sizeof(init_fw_cb->ipv6_dflt_rtr_addr));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tif (iface_param->value[0] == ISCSI_IFACE_ENABLE) {\n\t\t\tinit_fw_cb->ipv6_opts |=\n\t\t\t\tcpu_to_le16(IPV6_OPT_IPV6_PROTOCOL_ENABLE);\n\t\t\tqla4xxx_create_ipv6_iface(ha);\n\t\t} else {\n\t\t\tinit_fw_cb->ipv6_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_OPT_IPV6_PROTOCOL_ENABLE &\n\t\t\t\t\t    0xFFFF);\n\t\t\tqla4xxx_destroy_ipv6_iface(ha);\n\t\t}\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_TAG:\n\t\tif (iface_param->len != sizeof(init_fw_cb->ipv6_vlan_tag))\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_vlan_tag =\n\t\t\t\tcpu_to_be16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tif (iface_param->value[0] == ISCSI_VLAN_ENABLE)\n\t\t\tinit_fw_cb->ipv6_opts |=\n\t\t\t\tcpu_to_le16(IPV6_OPT_VLAN_TAGGING_ENABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_OPT_VLAN_TAGGING_ENABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_MTU:\n\t\tinit_fw_cb->eth_mtu_size =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_PORT:\n\t\t \n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\n\t\tinit_fw_cb->ipv6_port =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_DELAYED_ACK_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16(IPV6_TCPOPT_DELAYED_ACK_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_DELAYED_ACK_DISABLE &\n\t\t\t\t\t    0xFFFF);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16(IPV6_TCPOPT_NAGLE_ALGO_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_NAGLE_ALGO_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16(IPV6_TCPOPT_WINDOW_SCALE_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_WINDOW_SCALE_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_WSF:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_tcp_wsf = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_TIMER_SCALE);\n\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16((iface_param->value[0] << 1) &\n\t\t\t\t\t    IPV6_TCPOPT_TIMER_SCALE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv6_tcp_opts |=\n\t\t\t\tcpu_to_le16(IPV6_TCPOPT_TIMESTAMP_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_tcp_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_TCPOPT_TIMESTAMP_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_GRAT_NEIGHBOR_ADV_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv6_opts |=\n\t\t\t\tcpu_to_le16(IPV6_OPT_GRAT_NEIGHBOR_ADV_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_OPT_GRAT_NEIGHBOR_ADV_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_REDIRECT_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv6_opts |=\n\t\t\t\tcpu_to_le16(IPV6_OPT_REDIRECT_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_OPT_REDIRECT_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_MLD_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv6_addtl_opts |=\n\t\t\t\tcpu_to_le16(IPV6_ADDOPT_MLD_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv6_addtl_opts &=\n\t\t\t\tcpu_to_le16(~IPV6_ADDOPT_MLD_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_FLOW_LABEL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_flow_lbl =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_TRAFFIC_CLASS:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_traffic_class = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_HOP_LIMIT:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_hop_limit = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ND_REACHABLE_TMO:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_nd_reach_time =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ND_REXMIT_TIME:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_nd_rexmit_timer =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ND_STALE_TMO:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_nd_stale_timeout =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_DUP_ADDR_DETECT_CNT:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_dup_addr_detect_count = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_RTR_ADV_LINK_MTU:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv6_gw_advrt_mtu =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value);\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"Unknown IPv6 param = %d\\n\",\n\t\t\t   iface_param->param);\n\t\tbreak;\n\t}\n}\n\nstatic void qla4xxx_set_ipv4(struct scsi_qla_host *ha,\n\t\t\t     struct iscsi_iface_param_info *iface_param,\n\t\t\t     struct addr_ctrl_blk *init_fw_cb)\n{\n\tswitch (iface_param->param) {\n\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\tmemcpy(init_fw_cb->ipv4_addr, iface_param->value,\n\t\t       sizeof(init_fw_cb->ipv4_addr));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\tmemcpy(init_fw_cb->ipv4_subnet,\tiface_param->value,\n\t\t       sizeof(init_fw_cb->ipv4_subnet));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\tmemcpy(init_fw_cb->ipv4_gw_addr, iface_param->value,\n\t\t       sizeof(init_fw_cb->ipv4_gw_addr));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\tif (iface_param->value[0] == ISCSI_BOOTPROTO_DHCP)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\t\tcpu_to_le16(TCPOPT_DHCP_ENABLE);\n\t\telse if (iface_param->value[0] == ISCSI_BOOTPROTO_STATIC)\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\t\tcpu_to_le16(~TCPOPT_DHCP_ENABLE);\n\t\telse\n\t\t\tql4_printk(KERN_ERR, ha, \"Invalid IPv4 bootproto\\n\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tif (iface_param->value[0] == ISCSI_IFACE_ENABLE) {\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_IPV4_PROTOCOL_ENABLE);\n\t\t\tqla4xxx_create_ipv4_iface(ha);\n\t\t} else {\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_IPV4_PROTOCOL_ENABLE &\n\t\t\t\t\t    0xFFFF);\n\t\t\tqla4xxx_destroy_ipv4_iface(ha);\n\t\t}\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_TAG:\n\t\tif (iface_param->len != sizeof(init_fw_cb->ipv4_vlan_tag))\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_vlan_tag =\n\t\t\t\tcpu_to_be16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tif (iface_param->value[0] == ISCSI_VLAN_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_VLAN_TAGGING_ENABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_VLAN_TAGGING_ENABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_MTU:\n\t\tinit_fw_cb->eth_mtu_size =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_PORT:\n\t\tinit_fw_cb->ipv4_port =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_DELAYED_ACK_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_DELAYED_ACK_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_DELAYED_ACK_DISABLE &\n\t\t\t\t\t    0xFFFF);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_NAGLE_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_NAGLE_ALGO_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_NAGLE_ALGO_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_WSF_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_WINDOW_SCALE_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_WINDOW_SCALE_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_WSF:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_tcp_wsf = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_TIMER_SCALE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_tcp_opts &= cpu_to_le16(~TCPOPT_TIMER_SCALE);\n\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16((iface_param->value[0] << 1) &\n\t\t\t\t\t    TCPOPT_TIMER_SCALE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_TCP_TIMESTAMP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_TIMESTAMP_ENABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_TIMESTAMP_ENABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_DNS_ADDR_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_DNS_SERVER_IP_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_DNS_SERVER_IP_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_SLP_DA_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_tcp_opts |=\n\t\t\t\tcpu_to_le16(TCPOPT_SLP_DA_INFO_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_tcp_opts &=\n\t\t\t\tcpu_to_le16(~TCPOPT_SLP_DA_INFO_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_TOS_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_IPV4_TOS_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_IPV4_TOS_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_TOS:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_tos = iface_param->value[0];\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_GRAT_ARP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_GRAT_ARP_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_GRAT_ARP_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_ALT_CID_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_ALT_CID_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_ALT_CLIENT_ID:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tmemcpy(init_fw_cb->ipv4_dhcp_alt_cid, iface_param->value,\n\t\t       (sizeof(init_fw_cb->ipv4_dhcp_alt_cid) - 1));\n\t\tinit_fw_cb->ipv4_dhcp_alt_cid_len =\n\t\t\t\t\tstrlen(init_fw_cb->ipv4_dhcp_alt_cid);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_REQ_VENDOR_ID_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_REQ_VID_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_REQ_VID_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_USE_VENDOR_ID_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_USE_VID_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_USE_VID_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_VENDOR_ID:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tmemcpy(init_fw_cb->ipv4_dhcp_vid, iface_param->value,\n\t\t       (sizeof(init_fw_cb->ipv4_dhcp_vid) - 1));\n\t\tinit_fw_cb->ipv4_dhcp_vid_len =\n\t\t\t\t\tstrlen(init_fw_cb->ipv4_dhcp_vid);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_DHCP_LEARN_IQN_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\t\tcpu_to_le16(IPOPT_LEARN_IQN_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\t\tcpu_to_le16(~IPOPT_LEARN_IQN_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_FRAGMENT_DISABLE:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_DISABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_FRAGMENTATION_DISABLE);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_FRAGMENTATION_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_IN_FORWARD_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_IN_FORWARD_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_IN_FORWARD_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_REDIRECT_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->ipv4_ip_opts |=\n\t\t\t\tcpu_to_le16(IPOPT_ARP_REDIRECT_EN);\n\t\telse\n\t\t\tinit_fw_cb->ipv4_ip_opts &=\n\t\t\t\tcpu_to_le16(~IPOPT_ARP_REDIRECT_EN);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_TTL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->ipv4_ttl = iface_param->value[0];\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"Unknown IPv4 param = %d\\n\",\n\t\t\t   iface_param->param);\n\t\tbreak;\n\t}\n}\n\nstatic void qla4xxx_set_iscsi_param(struct scsi_qla_host *ha,\n\t\t\t\t    struct iscsi_iface_param_info *iface_param,\n\t\t\t\t    struct addr_ctrl_blk *init_fw_cb)\n{\n\tswitch (iface_param->param) {\n\tcase ISCSI_IFACE_PARAM_DEF_TASKMGMT_TMO:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->def_timeout =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_HDRDGST_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_HEADER_DIGEST_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_HEADER_DIGEST_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_DATADGST_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DATA_DIGEST_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DATA_DIGEST_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_IMM_DATA_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_IMMEDIATE_DATA_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_IMMEDIATE_DATA_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_INITIAL_R2T_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_INITIAL_R2T_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_INITIAL_R2T_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_DATASEQ_INORDER_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DATA_SEQ_INORDER_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DATA_SEQ_INORDER_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_PDU_INORDER_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DATA_PDU_INORDER_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DATA_PDU_INORDER_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_ERL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_opts &= cpu_to_le16(~ISCSIOPTS_ERL);\n\t\tinit_fw_cb->iscsi_opts |= cpu_to_le16(iface_param->value[0] &\n\t\t\t\t\t\t      ISCSIOPTS_ERL);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_MAX_RECV_DLENGTH:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_max_pdu_size =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value) /\n\t\t\t\tBYTE_UNITS;\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_FIRST_BURST:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_fburst_len =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value) /\n\t\t\t\tBYTE_UNITS;\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_MAX_R2T:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_max_outstnd_r2t =\n\t\t\t\tcpu_to_le16(*(uint16_t *)iface_param->value);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_MAX_BURST:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tinit_fw_cb->iscsi_max_burst_len =\n\t\t\t\tcpu_to_le32(*(uint32_t *)iface_param->value) /\n\t\t\t\tBYTE_UNITS;\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_CHAP_AUTH_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_CHAP_AUTH_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_CHAP_AUTH_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_BIDI_CHAP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_BIDI_CHAP_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_BIDI_CHAP_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DISCOVERY_AUTH_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DISCOVERY_AUTH_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_DISCOVERY_LOGOUT_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_DISCOVERY_LOGOUT_EN);\n\t\tbreak;\n\tcase ISCSI_IFACE_PARAM_STRICT_LOGIN_COMP_EN:\n\t\tif (iface_param->iface_num & 0x1)\n\t\t\tbreak;\n\t\tif (iface_param->value[0] == ISCSI_NET_PARAM_ENABLE)\n\t\t\tinit_fw_cb->iscsi_opts |=\n\t\t\t\tcpu_to_le16(ISCSIOPTS_STRICT_LOGIN_COMP_EN);\n\t\telse\n\t\t\tinit_fw_cb->iscsi_opts &=\n\t\t\t\tcpu_to_le16(~ISCSIOPTS_STRICT_LOGIN_COMP_EN);\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"Unknown iscsi param = %d\\n\",\n\t\t\t   iface_param->param);\n\t\tbreak;\n\t}\n}\n\nstatic void\nqla4xxx_initcb_to_acb(struct addr_ctrl_blk *init_fw_cb)\n{\n\tstruct addr_ctrl_blk_def *acb;\n\tacb = (struct addr_ctrl_blk_def *)init_fw_cb;\n\tmemset(acb->reserved1, 0, sizeof(acb->reserved1));\n\tmemset(acb->reserved2, 0, sizeof(acb->reserved2));\n\tmemset(acb->reserved3, 0, sizeof(acb->reserved3));\n\tmemset(acb->reserved4, 0, sizeof(acb->reserved4));\n\tmemset(acb->reserved5, 0, sizeof(acb->reserved5));\n\tmemset(acb->reserved6, 0, sizeof(acb->reserved6));\n\tmemset(acb->reserved7, 0, sizeof(acb->reserved7));\n\tmemset(acb->reserved8, 0, sizeof(acb->reserved8));\n\tmemset(acb->reserved9, 0, sizeof(acb->reserved9));\n\tmemset(acb->reserved10, 0, sizeof(acb->reserved10));\n\tmemset(acb->reserved11, 0, sizeof(acb->reserved11));\n\tmemset(acb->reserved12, 0, sizeof(acb->reserved12));\n\tmemset(acb->reserved13, 0, sizeof(acb->reserved13));\n\tmemset(acb->reserved14, 0, sizeof(acb->reserved14));\n\tmemset(acb->reserved15, 0, sizeof(acb->reserved15));\n}\n\nstatic int\nqla4xxx_iface_set_param(struct Scsi_Host *shost, void *data, uint32_t len)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tint rval = 0;\n\tstruct iscsi_iface_param_info *iface_param = NULL;\n\tstruct addr_ctrl_blk *init_fw_cb = NULL;\n\tdma_addr_t init_fw_cb_dma;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tuint32_t rem = len;\n\tstruct nlattr *attr;\n\n\tinit_fw_cb = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\tsizeof(struct addr_ctrl_blk),\n\t\t\t\t\t&init_fw_cb_dma, GFP_KERNEL);\n\tif (!init_fw_cb) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Unable to alloc init_cb\\n\",\n\t\t\t   __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(&mbox_cmd, 0, sizeof(mbox_cmd));\n\tmemset(&mbox_sts, 0, sizeof(mbox_sts));\n\n\tif (qla4xxx_get_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: get ifcb failed\\n\", __func__);\n\t\trval = -EIO;\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\tnla_for_each_attr(attr, data, len, rem) {\n\t\tif (nla_len(attr) < sizeof(*iface_param)) {\n\t\t\trval = -EINVAL;\n\t\t\tgoto exit_init_fw_cb;\n\t\t}\n\n\t\tiface_param = nla_data(attr);\n\n\t\tif (iface_param->param_type == ISCSI_NET_PARAM) {\n\t\t\tswitch (iface_param->iface_type) {\n\t\t\tcase ISCSI_IFACE_TYPE_IPV4:\n\t\t\t\tswitch (iface_param->iface_num) {\n\t\t\t\tcase 0:\n\t\t\t\t\tqla4xxx_set_ipv4(ha, iface_param,\n\t\t\t\t\t\t\t init_fw_cb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t \n\t\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t\t   \"Invalid IPv4 iface number = %d\\n\",\n\t\t\t\t\t\t   iface_param->iface_num);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ISCSI_IFACE_TYPE_IPV6:\n\t\t\t\tswitch (iface_param->iface_num) {\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\tqla4xxx_set_ipv6(ha, iface_param,\n\t\t\t\t\t\t\t init_fw_cb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t \n\t\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t\t   \"Invalid IPv6 iface number = %d\\n\",\n\t\t\t\t\t\t   iface_param->iface_num);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t   \"Invalid iface type\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (iface_param->param_type == ISCSI_IFACE_PARAM) {\n\t\t\t\tqla4xxx_set_iscsi_param(ha, iface_param,\n\t\t\t\t\t\t\tinit_fw_cb);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tinit_fw_cb->cookie = cpu_to_le32(0x11BEAD5A);\n\n\trval = qla4xxx_set_flash(ha, init_fw_cb_dma, FLASH_SEGMENT_IFCB,\n\t\t\t\t sizeof(struct addr_ctrl_blk),\n\t\t\t\t FLASH_OPT_RMW_COMMIT);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: set flash mbx failed\\n\",\n\t\t\t   __func__);\n\t\trval = -EIO;\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\trval = qla4xxx_disable_acb(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: disable acb mbx failed\\n\",\n\t\t\t   __func__);\n\t\trval = -EIO;\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\twait_for_completion_timeout(&ha->disable_acb_comp,\n\t\t\t\t    DISABLE_ACB_TOV * HZ);\n\n\tqla4xxx_initcb_to_acb(init_fw_cb);\n\n\trval = qla4xxx_set_acb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb_dma);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: set acb mbx failed\\n\",\n\t\t\t   __func__);\n\t\trval = -EIO;\n\t\tgoto exit_init_fw_cb;\n\t}\n\n\tmemset(init_fw_cb, 0, sizeof(struct addr_ctrl_blk));\n\tqla4xxx_update_local_ifcb(ha, &mbox_cmd[0], &mbox_sts[0], init_fw_cb,\n\t\t\t\t  init_fw_cb_dma);\n\nexit_init_fw_cb:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk),\n\t\t\t  init_fw_cb, init_fw_cb_dma);\n\n\treturn rval;\n}\n\nstatic int qla4xxx_session_get_param(struct iscsi_cls_session *cls_sess,\n\t\t\t\t     enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_session *sess = cls_sess->dd_data;\n\tstruct ddb_entry *ddb_entry = sess->dd_data;\n\tstruct scsi_qla_host *ha = ddb_entry->ha;\n\tstruct iscsi_cls_conn *cls_conn = ddb_entry->conn;\n\tstruct ql4_chap_table chap_tbl;\n\tint rval, len;\n\tuint16_t idx;\n\n\tmemset(&chap_tbl, 0, sizeof(chap_tbl));\n\tswitch (param) {\n\tcase ISCSI_PARAM_CHAP_IN_IDX:\n\t\trval = qla4xxx_get_chap_index(ha, sess->username_in,\n\t\t\t\t\t      sess->password_in, BIDI_CHAP,\n\t\t\t\t\t      &idx);\n\t\tif (rval)\n\t\t\tlen = sprintf(buf, \"\\n\");\n\t\telse\n\t\t\tlen = sprintf(buf, \"%hu\\n\", idx);\n\t\tbreak;\n\tcase ISCSI_PARAM_CHAP_OUT_IDX:\n\t\tif (ddb_entry->ddb_type == FLASH_DDB) {\n\t\t\tif (ddb_entry->chap_tbl_idx != INVALID_ENTRY) {\n\t\t\t\tidx = ddb_entry->chap_tbl_idx;\n\t\t\t\trval = QLA_SUCCESS;\n\t\t\t} else {\n\t\t\t\trval = QLA_ERROR;\n\t\t\t}\n\t\t} else {\n\t\t\trval = qla4xxx_get_chap_index(ha, sess->username,\n\t\t\t\t\t\t      sess->password,\n\t\t\t\t\t\t      LOCAL_CHAP, &idx);\n\t\t}\n\t\tif (rval)\n\t\t\tlen = sprintf(buf, \"\\n\");\n\t\telse\n\t\t\tlen = sprintf(buf, \"%hu\\n\", idx);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME:\n\tcase ISCSI_PARAM_PASSWORD:\n\t\t \n\t\tif (ddb_entry->ddb_type == FLASH_DDB &&\n\t\t    ddb_entry->chap_tbl_idx != INVALID_ENTRY &&\n\t\t    !sess->username && !sess->password) {\n\t\t\tidx = ddb_entry->chap_tbl_idx;\n\t\t\trval = qla4xxx_get_uni_chap_at_index(ha, chap_tbl.name,\n\t\t\t\t\t\t\t    chap_tbl.secret,\n\t\t\t\t\t\t\t    idx);\n\t\t\tif (!rval) {\n\t\t\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_USERNAME,\n\t\t\t\t\t\t(char *)chap_tbl.name,\n\t\t\t\t\t\tstrlen((char *)chap_tbl.name));\n\t\t\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_PASSWORD,\n\t\t\t\t\t\t(char *)chap_tbl.secret,\n\t\t\t\t\t\tchap_tbl.secret_len);\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn iscsi_session_get_param(cls_sess, param, buf);\n\t}\n\n\treturn len;\n}\n\nstatic int qla4xxx_conn_get_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t  enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_conn *conn;\n\tstruct qla_conn *qla_conn;\n\tstruct sockaddr *dst_addr;\n\n\tconn = cls_conn->dd_data;\n\tqla_conn = conn->dd_data;\n\tdst_addr = (struct sockaddr *)&qla_conn->qla_ep->dst_addr;\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\treturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\n\t\t\t\t\t\t dst_addr, param, buf);\n\tdefault:\n\t\treturn iscsi_conn_get_param(cls_conn, param, buf);\n\t}\n}\n\nint qla4xxx_get_ddb_index(struct scsi_qla_host *ha, uint16_t *ddb_index)\n{\n\tuint32_t mbx_sts = 0;\n\tuint16_t tmp_ddb_index;\n\tint ret;\n\nget_ddb_index:\n\ttmp_ddb_index = find_first_zero_bit(ha->ddb_idx_map, MAX_DDB_ENTRIES);\n\n\tif (tmp_ddb_index >= MAX_DDB_ENTRIES) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Free DDB index not available\\n\"));\n\t\tret = QLA_ERROR;\n\t\tgoto exit_get_ddb_index;\n\t}\n\n\tif (test_and_set_bit(tmp_ddb_index, ha->ddb_idx_map))\n\t\tgoto get_ddb_index;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Found a free DDB index at %d\\n\", tmp_ddb_index));\n\tret = qla4xxx_req_ddb_entry(ha, tmp_ddb_index, &mbx_sts);\n\tif (ret == QLA_ERROR) {\n\t\tif (mbx_sts == MBOX_STS_COMMAND_ERROR) {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"DDB index = %d not available trying next\\n\",\n\t\t\t\t   tmp_ddb_index);\n\t\t\tgoto get_ddb_index;\n\t\t}\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Free FW DDB not available\\n\"));\n\t}\n\n\t*ddb_index = tmp_ddb_index;\n\nexit_get_ddb_index:\n\treturn ret;\n}\n\nstatic int qla4xxx_match_ipaddress(struct scsi_qla_host *ha,\n\t\t\t\t   struct ddb_entry *ddb_entry,\n\t\t\t\t   char *existing_ipaddr,\n\t\t\t\t   char *user_ipaddr)\n{\n\tuint8_t dst_ipaddr[IPv6_ADDR_LEN];\n\tchar formatted_ipaddr[DDB_IPADDR_LEN];\n\tint status = QLA_SUCCESS, ret = 0;\n\n\tif (ddb_entry->fw_ddb_entry.options & DDB_OPT_IPV6_DEVICE) {\n\t\tret = in6_pton(user_ipaddr, strlen(user_ipaddr), dst_ipaddr,\n\t\t\t       '\\0', NULL);\n\t\tif (ret == 0) {\n\t\t\tstatus = QLA_ERROR;\n\t\t\tgoto out_match;\n\t\t}\n\t\tret = sprintf(formatted_ipaddr, \"%pI6\", dst_ipaddr);\n\t} else {\n\t\tret = in4_pton(user_ipaddr, strlen(user_ipaddr), dst_ipaddr,\n\t\t\t       '\\0', NULL);\n\t\tif (ret == 0) {\n\t\t\tstatus = QLA_ERROR;\n\t\t\tgoto out_match;\n\t\t}\n\t\tret = sprintf(formatted_ipaddr, \"%pI4\", dst_ipaddr);\n\t}\n\n\tif (strcmp(existing_ipaddr, formatted_ipaddr))\n\t\tstatus = QLA_ERROR;\n\nout_match:\n\treturn status;\n}\n\nstatic int qla4xxx_match_fwdb_session(struct scsi_qla_host *ha,\n\t\t\t\t      struct iscsi_cls_conn *cls_conn)\n{\n\tint idx = 0, max_ddbs, rval;\n\tstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\n\tstruct iscsi_session *sess, *existing_sess;\n\tstruct iscsi_conn *conn, *existing_conn;\n\tstruct ddb_entry *ddb_entry;\n\n\tsess = cls_sess->dd_data;\n\tconn = cls_conn->dd_data;\n\n\tif (sess->targetname == NULL ||\n\t    conn->persistent_address == NULL ||\n\t    conn->persistent_port == 0)\n\t\treturn QLA_ERROR;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfor (idx = 0; idx < max_ddbs; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tif (ddb_entry->ddb_type != FLASH_DDB)\n\t\t\tcontinue;\n\n\t\texisting_sess = ddb_entry->sess->dd_data;\n\t\texisting_conn = ddb_entry->conn->dd_data;\n\n\t\tif (existing_sess->targetname == NULL ||\n\t\t    existing_conn->persistent_address == NULL ||\n\t\t    existing_conn->persistent_port == 0)\n\t\t\tcontinue;\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"IQN = %s User IQN = %s\\n\",\n\t\t\t\t  existing_sess->targetname,\n\t\t\t\t  sess->targetname));\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"IP = %s User IP = %s\\n\",\n\t\t\t\t  existing_conn->persistent_address,\n\t\t\t\t  conn->persistent_address));\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Port = %d User Port = %d\\n\",\n\t\t\t\t  existing_conn->persistent_port,\n\t\t\t\t  conn->persistent_port));\n\n\t\tif (strcmp(existing_sess->targetname, sess->targetname))\n\t\t\tcontinue;\n\t\trval = qla4xxx_match_ipaddress(ha, ddb_entry,\n\t\t\t\t\texisting_conn->persistent_address,\n\t\t\t\t\tconn->persistent_address);\n\t\tif (rval == QLA_ERROR)\n\t\t\tcontinue;\n\t\tif (existing_conn->persistent_port != conn->persistent_port)\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\n\tif (idx == max_ddbs)\n\t\treturn QLA_ERROR;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Match found in fwdb sessions\\n\"));\n\treturn QLA_SUCCESS;\n}\n\nstatic struct iscsi_cls_session *\nqla4xxx_session_create(struct iscsi_endpoint *ep,\n\t\t\tuint16_t cmds_max, uint16_t qdepth,\n\t\t\tuint32_t initial_cmdsn)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct scsi_qla_host *ha;\n\tstruct qla_endpoint *qla_ep;\n\tstruct ddb_entry *ddb_entry;\n\tuint16_t ddb_index;\n\tstruct iscsi_session *sess;\n\tint ret;\n\n\tif (!ep) {\n\t\tprintk(KERN_ERR \"qla4xxx: missing ep.\\n\");\n\t\treturn NULL;\n\t}\n\n\tqla_ep = ep->dd_data;\n\tha = to_qla_host(qla_ep->host);\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\n\tret = qla4xxx_get_ddb_index(ha, &ddb_index);\n\tif (ret == QLA_ERROR)\n\t\treturn NULL;\n\n\tcls_sess = iscsi_session_setup(&qla4xxx_iscsi_transport, qla_ep->host,\n\t\t\t\t       cmds_max, sizeof(struct ddb_entry),\n\t\t\t\t       sizeof(struct ql4_task_data),\n\t\t\t\t       initial_cmdsn, ddb_index);\n\tif (!cls_sess)\n\t\treturn NULL;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tddb_entry->fw_ddb_index = ddb_index;\n\tddb_entry->fw_ddb_device_state = DDB_DS_NO_CONNECTION_ACTIVE;\n\tddb_entry->ha = ha;\n\tddb_entry->sess = cls_sess;\n\tddb_entry->unblock_sess = qla4xxx_unblock_ddb;\n\tddb_entry->ddb_change = qla4xxx_ddb_change;\n\tclear_bit(DDB_CONN_CLOSE_FAILURE, &ddb_entry->flags);\n\tcls_sess->recovery_tmo = ql4xsess_recovery_tmo;\n\tha->fw_ddb_index_map[ddb_entry->fw_ddb_index] = ddb_entry;\n\tha->tot_ddbs++;\n\n\treturn cls_sess;\n}\n\nstatic void qla4xxx_session_destroy(struct iscsi_cls_session *cls_sess)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tunsigned long flags, wtime;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint32_t ddb_state;\n\tint ret;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: host: %ld\\n\", __func__,\n\t\t\t  ha->host_no));\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto destroy_session;\n\t}\n\n\twtime = jiffies + (HZ * LOGOUT_TOV);\n\tdo {\n\t\tret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t\t      fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t      NULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t      NULL, NULL);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto destroy_session;\n\n\t\tif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\n\t\t    (ddb_state == DDB_DS_SESSION_FAILED))\n\t\t\tgoto destroy_session;\n\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while ((time_after(wtime, jiffies)));\n\ndestroy_session:\n\tqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\n\tif (test_and_clear_bit(DDB_CONN_CLOSE_FAILURE, &ddb_entry->flags))\n\t\tclear_bit(ddb_entry->fw_ddb_index, ha->ddb_idx_map);\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqla4xxx_free_ddb(ha, ddb_entry);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tiscsi_session_teardown(cls_sess);\n\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n}\n\nstatic struct iscsi_cls_conn *\nqla4xxx_conn_create(struct iscsi_cls_session *cls_sess, uint32_t conn_idx)\n{\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tcls_conn = iscsi_conn_setup(cls_sess, sizeof(struct qla_conn),\n\t\t\t\t    conn_idx);\n\tif (!cls_conn) {\n\t\tpr_info(\"%s: Can not create connection for conn_idx = %u\\n\",\n\t\t\t__func__, conn_idx);\n\t\treturn NULL;\n\t}\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tddb_entry->conn = cls_conn;\n\n\tha = ddb_entry->ha;\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: conn_idx = %u\\n\", __func__,\n\t\t\t  conn_idx));\n\treturn cls_conn;\n}\n\nstatic int qla4xxx_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t\t     struct iscsi_cls_conn *cls_conn,\n\t\t\t     uint64_t transport_fd, int is_leading)\n{\n\tstruct iscsi_conn *conn;\n\tstruct qla_conn *qla_conn;\n\tstruct iscsi_endpoint *ep;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tstruct iscsi_session *sess;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: sid = %d, cid = %d\\n\", __func__,\n\t\t\t  cls_session->sid, cls_conn->cid));\n\n\tif (iscsi_conn_bind(cls_session, cls_conn, is_leading))\n\t\treturn -EINVAL;\n\tep = iscsi_lookup_endpoint(transport_fd);\n\tif (!ep)\n\t\treturn -EINVAL;\n\tconn = cls_conn->dd_data;\n\tqla_conn = conn->dd_data;\n\tqla_conn->qla_ep = ep->dd_data;\n\tiscsi_put_endpoint(ep);\n\treturn 0;\n}\n\nstatic int qla4xxx_conn_start(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint32_t mbx_sts = 0;\n\tint ret = 0;\n\tint status = QLA_SUCCESS;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: sid = %d, cid = %d\\n\", __func__,\n\t\t\t  cls_sess->sid, cls_conn->cid));\n\n\t \n\tret = qla4xxx_match_fwdb_session(ha, cls_conn);\n\tif (ret == QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"Session already exist in FW.\\n\");\n\t\tret = -EEXIST;\n\t\tgoto exit_conn_start;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_conn_start;\n\t}\n\n\tret = qla4xxx_set_param_ddbentry(ha, ddb_entry, cls_conn, &mbx_sts);\n\tif (ret) {\n\t\t \n\t\tif (mbx_sts)\n\t\t\tif (ddb_entry->fw_ddb_device_state ==\n\t\t\t\t\t\tDDB_DS_SESSION_ACTIVE) {\n\t\t\t\tddb_entry->unblock_sess(ddb_entry->sess);\n\t\t\t\tgoto exit_set_param;\n\t\t\t}\n\n\t\tql4_printk(KERN_ERR, ha, \"%s: Failed set param for index[%d]\\n\",\n\t\t\t   __func__, ddb_entry->fw_ddb_index);\n\t\tgoto exit_conn_start;\n\t}\n\n\tstatus = qla4xxx_conn_open(ha, ddb_entry->fw_ddb_index);\n\tif (status == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Login failed: %s\\n\", __func__,\n\t\t\t   sess->targetname);\n\t\tret = -EINVAL;\n\t\tgoto exit_conn_start;\n\t}\n\n\tif (ddb_entry->fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE)\n\t\tddb_entry->fw_ddb_device_state = DDB_DS_LOGIN_IN_PROCESS;\n\n\tDEBUG2(printk(KERN_INFO \"%s: DDB state [%d]\\n\", __func__,\n\t\t      ddb_entry->fw_ddb_device_state));\n\nexit_set_param:\n\tret = 0;\n\nexit_conn_start:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn ret;\n}\n\nstatic void qla4xxx_conn_destroy(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_cls_session *cls_sess = iscsi_conn_to_session(cls_conn);\n\tstruct iscsi_session *sess;\n\tstruct scsi_qla_host *ha;\n\tstruct ddb_entry *ddb_entry;\n\tint options;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: cid = %d\\n\", __func__,\n\t\t\t  cls_conn->cid));\n\n\toptions = LOGOUT_OPTION_CLOSE_SESSION;\n\tif (qla4xxx_session_logout_ddb(ha, ddb_entry, options) == QLA_ERROR)\n\t\tql4_printk(KERN_ERR, ha, \"%s: Logout failed\\n\", __func__);\n}\n\nstatic void qla4xxx_task_work(struct work_struct *wdata)\n{\n\tstruct ql4_task_data *task_data;\n\tstruct scsi_qla_host *ha;\n\tstruct passthru_status *sts;\n\tstruct iscsi_task *task;\n\tstruct iscsi_hdr *hdr;\n\tuint8_t *data;\n\tuint32_t data_len;\n\tstruct iscsi_conn *conn;\n\tint hdr_len;\n\titt_t itt;\n\n\ttask_data = container_of(wdata, struct ql4_task_data, task_work);\n\tha = task_data->ha;\n\ttask = task_data->task;\n\tsts = &task_data->sts;\n\thdr_len = sizeof(struct iscsi_hdr);\n\n\tDEBUG3(printk(KERN_INFO \"Status returned\\n\"));\n\tDEBUG3(qla4xxx_dump_buffer(sts, 64));\n\tDEBUG3(printk(KERN_INFO \"Response buffer\"));\n\tDEBUG3(qla4xxx_dump_buffer(task_data->resp_buffer, 64));\n\n\tconn = task->conn;\n\n\tswitch (sts->completionStatus) {\n\tcase PASSTHRU_STATUS_COMPLETE:\n\t\thdr = (struct iscsi_hdr *)task_data->resp_buffer;\n\t\t \n\t\titt = sts->handle;\n\t\thdr->itt = itt;\n\t\tdata = task_data->resp_buffer + hdr_len;\n\t\tdata_len = task_data->resp_len - hdr_len;\n\t\tiscsi_complete_pdu(conn, hdr, data, data_len);\n\t\tbreak;\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"Passthru failed status = 0x%x\\n\",\n\t\t\t   sts->completionStatus);\n\t\tbreak;\n\t}\n\treturn;\n}\n\nstatic int qla4xxx_alloc_pdu(struct iscsi_task *task, uint8_t opcode)\n{\n\tstruct ql4_task_data *task_data;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tint hdr_len;\n\n\tsess = task->conn->session;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\ttask_data = task->dd_data;\n\tmemset(task_data, 0, sizeof(struct ql4_task_data));\n\n\tif (task->sc) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: SCSI Commands not implemented\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thdr_len = sizeof(struct iscsi_hdr);\n\ttask_data->ha = ha;\n\ttask_data->task = task;\n\n\tif (task->data_count) {\n\t\ttask_data->data_dma = dma_map_single(&ha->pdev->dev, task->data,\n\t\t\t\t\t\t     task->data_count,\n\t\t\t\t\t\t     DMA_TO_DEVICE);\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: MaxRecvLen %u, iscsi hrd %d\\n\",\n\t\t      __func__, task->conn->max_recv_dlength, hdr_len));\n\n\ttask_data->resp_len = task->conn->max_recv_dlength + hdr_len;\n\ttask_data->resp_buffer = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t\t    task_data->resp_len,\n\t\t\t\t\t\t    &task_data->resp_dma,\n\t\t\t\t\t\t    GFP_ATOMIC);\n\tif (!task_data->resp_buffer)\n\t\tgoto exit_alloc_pdu;\n\n\ttask_data->req_len = task->data_count + hdr_len;\n\ttask_data->req_buffer = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t\t   task_data->req_len,\n\t\t\t\t\t\t   &task_data->req_dma,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\tif (!task_data->req_buffer)\n\t\tgoto exit_alloc_pdu;\n\n\ttask->hdr = task_data->req_buffer;\n\n\tINIT_WORK(&task_data->task_work, qla4xxx_task_work);\n\n\treturn 0;\n\nexit_alloc_pdu:\n\tif (task_data->resp_buffer)\n\t\tdma_free_coherent(&ha->pdev->dev, task_data->resp_len,\n\t\t\t\t  task_data->resp_buffer, task_data->resp_dma);\n\n\tif (task_data->req_buffer)\n\t\tdma_free_coherent(&ha->pdev->dev, task_data->req_len,\n\t\t\t\t  task_data->req_buffer, task_data->req_dma);\n\treturn -ENOMEM;\n}\n\nstatic void qla4xxx_task_cleanup(struct iscsi_task *task)\n{\n\tstruct ql4_task_data *task_data;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tint hdr_len;\n\n\thdr_len = sizeof(struct iscsi_hdr);\n\tsess = task->conn->session;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\ttask_data = task->dd_data;\n\n\tif (task->data_count) {\n\t\tdma_unmap_single(&ha->pdev->dev, task_data->data_dma,\n\t\t\t\t task->data_count, DMA_TO_DEVICE);\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: MaxRecvLen %u, iscsi hrd %d\\n\",\n\t\t      __func__, task->conn->max_recv_dlength, hdr_len));\n\n\tdma_free_coherent(&ha->pdev->dev, task_data->resp_len,\n\t\t\t  task_data->resp_buffer, task_data->resp_dma);\n\tdma_free_coherent(&ha->pdev->dev, task_data->req_len,\n\t\t\t  task_data->req_buffer, task_data->req_dma);\n\treturn;\n}\n\nstatic int qla4xxx_task_xmit(struct iscsi_task *task)\n{\n\tstruct scsi_cmnd *sc = task->sc;\n\tstruct iscsi_session *sess = task->conn->session;\n\tstruct ddb_entry *ddb_entry = sess->dd_data;\n\tstruct scsi_qla_host *ha = ddb_entry->ha;\n\n\tif (!sc)\n\t\treturn qla4xxx_send_passthru0(task);\n\n\tql4_printk(KERN_INFO, ha, \"%s: scsi cmd xmit not implemented\\n\",\n\t\t   __func__);\n\treturn -ENOSYS;\n}\n\nstatic int qla4xxx_copy_from_fwddb_param(struct iscsi_bus_flash_session *sess,\n\t\t\t\t\t struct iscsi_bus_flash_conn *conn,\n\t\t\t\t\t struct dev_db_entry *fw_ddb_entry)\n{\n\tunsigned long options = 0;\n\tint rc = 0;\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tconn->is_fw_assigned_ipv6 = test_bit(OPT_IS_FW_ASSIGNED_IPV6, &options);\n\tif (test_bit(OPT_IPV6_DEVICE, &options)) {\n\t\trc = iscsi_switch_str_param(&sess->portal_type,\n\t\t\t\t\t    PORTAL_TYPE_IPV6);\n\t\tif (rc)\n\t\t\tgoto exit_copy;\n\t} else {\n\t\trc = iscsi_switch_str_param(&sess->portal_type,\n\t\t\t\t\t    PORTAL_TYPE_IPV4);\n\t\tif (rc)\n\t\t\tgoto exit_copy;\n\t}\n\n\tsess->auto_snd_tgt_disable = test_bit(OPT_AUTO_SENDTGTS_DISABLE,\n\t\t\t\t\t      &options);\n\tsess->discovery_sess = test_bit(OPT_DISC_SESSION, &options);\n\tsess->entry_state = test_bit(OPT_ENTRY_STATE, &options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\n\tconn->hdrdgst_en = test_bit(ISCSIOPT_HEADER_DIGEST_EN, &options);\n\tconn->datadgst_en = test_bit(ISCSIOPT_DATA_DIGEST_EN, &options);\n\tsess->imm_data_en = test_bit(ISCSIOPT_IMMEDIATE_DATA_EN, &options);\n\tsess->initial_r2t_en = test_bit(ISCSIOPT_INITIAL_R2T_EN, &options);\n\tsess->dataseq_inorder_en = test_bit(ISCSIOPT_DATA_SEQ_IN_ORDER,\n\t\t\t\t\t    &options);\n\tsess->pdu_inorder_en = test_bit(ISCSIOPT_DATA_PDU_IN_ORDER, &options);\n\tsess->chap_auth_en = test_bit(ISCSIOPT_CHAP_AUTH_EN, &options);\n\tconn->snack_req_en = test_bit(ISCSIOPT_SNACK_REQ_EN, &options);\n\tsess->discovery_logout_en = test_bit(ISCSIOPT_DISCOVERY_LOGOUT_EN,\n\t\t\t\t\t     &options);\n\tsess->bidi_chap_en = test_bit(ISCSIOPT_BIDI_CHAP_EN, &options);\n\tsess->discovery_auth_optional =\n\t\t\ttest_bit(ISCSIOPT_DISCOVERY_AUTH_OPTIONAL, &options);\n\tif (test_bit(ISCSIOPT_ERL1, &options))\n\t\tsess->erl |= BIT_1;\n\tif (test_bit(ISCSIOPT_ERL0, &options))\n\t\tsess->erl |= BIT_0;\n\n\toptions = le16_to_cpu(fw_ddb_entry->tcp_options);\n\tconn->tcp_timestamp_stat = test_bit(TCPOPT_TIMESTAMP_STAT, &options);\n\tconn->tcp_nagle_disable = test_bit(TCPOPT_NAGLE_DISABLE, &options);\n\tconn->tcp_wsf_disable = test_bit(TCPOPT_WSF_DISABLE, &options);\n\tif (test_bit(TCPOPT_TIMER_SCALE3, &options))\n\t\tconn->tcp_timer_scale |= BIT_3;\n\tif (test_bit(TCPOPT_TIMER_SCALE2, &options))\n\t\tconn->tcp_timer_scale |= BIT_2;\n\tif (test_bit(TCPOPT_TIMER_SCALE1, &options))\n\t\tconn->tcp_timer_scale |= BIT_1;\n\n\tconn->tcp_timer_scale >>= 1;\n\tconn->tcp_timestamp_en = test_bit(TCPOPT_TIMESTAMP_EN, &options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->ip_options);\n\tconn->fragment_disable = test_bit(IPOPT_FRAGMENT_DISABLE, &options);\n\n\tconn->max_recv_dlength = BYTE_UNITS *\n\t\t\t  le16_to_cpu(fw_ddb_entry->iscsi_max_rcv_data_seg_len);\n\tconn->max_xmit_dlength = BYTE_UNITS *\n\t\t\t  le16_to_cpu(fw_ddb_entry->iscsi_max_snd_data_seg_len);\n\tsess->first_burst = BYTE_UNITS *\n\t\t\t       le16_to_cpu(fw_ddb_entry->iscsi_first_burst_len);\n\tsess->max_burst = BYTE_UNITS *\n\t\t\t\t le16_to_cpu(fw_ddb_entry->iscsi_max_burst_len);\n\tsess->max_r2t = le16_to_cpu(fw_ddb_entry->iscsi_max_outsnd_r2t);\n\tsess->time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\n\tsess->time2retain = le16_to_cpu(fw_ddb_entry->iscsi_def_time2retain);\n\tsess->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\n\tconn->max_segment_size = le16_to_cpu(fw_ddb_entry->mss);\n\tconn->tcp_xmit_wsf = fw_ddb_entry->tcp_xmt_wsf;\n\tconn->tcp_recv_wsf = fw_ddb_entry->tcp_rcv_wsf;\n\tconn->ipv6_flow_label = le16_to_cpu(fw_ddb_entry->ipv6_flow_lbl);\n\tconn->keepalive_timeout = le16_to_cpu(fw_ddb_entry->ka_timeout);\n\tconn->local_port = le16_to_cpu(fw_ddb_entry->lcl_port);\n\tconn->statsn = le32_to_cpu(fw_ddb_entry->stat_sn);\n\tconn->exp_statsn = le32_to_cpu(fw_ddb_entry->exp_stat_sn);\n\tsess->discovery_parent_idx = le16_to_cpu(fw_ddb_entry->ddb_link);\n\tsess->discovery_parent_type = le16_to_cpu(fw_ddb_entry->ddb_link);\n\tsess->chap_out_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\n\tsess->tsid = le16_to_cpu(fw_ddb_entry->tsid);\n\n\tsess->default_taskmgmt_timeout =\n\t\t\t\tle16_to_cpu(fw_ddb_entry->def_timeout);\n\tconn->port = le16_to_cpu(fw_ddb_entry->port);\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tconn->ipaddress = kzalloc(IPv6_ADDR_LEN, GFP_KERNEL);\n\tif (!conn->ipaddress) {\n\t\trc = -ENOMEM;\n\t\tgoto exit_copy;\n\t}\n\n\tconn->redirect_ipaddr = kzalloc(IPv6_ADDR_LEN, GFP_KERNEL);\n\tif (!conn->redirect_ipaddr) {\n\t\trc = -ENOMEM;\n\t\tgoto exit_copy;\n\t}\n\n\tmemcpy(conn->ipaddress, fw_ddb_entry->ip_addr, IPv6_ADDR_LEN);\n\tmemcpy(conn->redirect_ipaddr, fw_ddb_entry->tgt_addr, IPv6_ADDR_LEN);\n\n\tif (test_bit(OPT_IPV6_DEVICE, &options)) {\n\t\tconn->ipv6_traffic_class = fw_ddb_entry->ipv4_tos;\n\n\t\tconn->link_local_ipv6_addr = kmemdup(\n\t\t\t\t\tfw_ddb_entry->link_local_ipv6_addr,\n\t\t\t\t\tIPv6_ADDR_LEN, GFP_KERNEL);\n\t\tif (!conn->link_local_ipv6_addr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit_copy;\n\t\t}\n\t} else {\n\t\tconn->ipv4_tos = fw_ddb_entry->ipv4_tos;\n\t}\n\n\tif (fw_ddb_entry->iscsi_name[0]) {\n\t\trc = iscsi_switch_str_param(&sess->targetname,\n\t\t\t\t\t    (char *)fw_ddb_entry->iscsi_name);\n\t\tif (rc)\n\t\t\tgoto exit_copy;\n\t}\n\n\tif (fw_ddb_entry->iscsi_alias[0]) {\n\t\trc = iscsi_switch_str_param(&sess->targetalias,\n\t\t\t\t\t    (char *)fw_ddb_entry->iscsi_alias);\n\t\tif (rc)\n\t\t\tgoto exit_copy;\n\t}\n\n\tCOPY_ISID(sess->isid, fw_ddb_entry->isid);\n\nexit_copy:\n\treturn rc;\n}\n\nstatic int qla4xxx_copy_to_fwddb_param(struct iscsi_bus_flash_session *sess,\n\t\t\t\t       struct iscsi_bus_flash_conn *conn,\n\t\t\t\t       struct dev_db_entry *fw_ddb_entry)\n{\n\tuint16_t options;\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tSET_BITVAL(conn->is_fw_assigned_ipv6,  options, BIT_11);\n\tif (!strncmp(sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\toptions |= BIT_8;\n\telse\n\t\toptions &= ~BIT_8;\n\n\tSET_BITVAL(sess->auto_snd_tgt_disable, options, BIT_6);\n\tSET_BITVAL(sess->discovery_sess, options, BIT_4);\n\tSET_BITVAL(sess->entry_state, options, BIT_3);\n\tfw_ddb_entry->options = cpu_to_le16(options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\n\tSET_BITVAL(conn->hdrdgst_en, options, BIT_13);\n\tSET_BITVAL(conn->datadgst_en, options, BIT_12);\n\tSET_BITVAL(sess->imm_data_en, options, BIT_11);\n\tSET_BITVAL(sess->initial_r2t_en, options, BIT_10);\n\tSET_BITVAL(sess->dataseq_inorder_en, options, BIT_9);\n\tSET_BITVAL(sess->pdu_inorder_en, options, BIT_8);\n\tSET_BITVAL(sess->chap_auth_en, options, BIT_7);\n\tSET_BITVAL(conn->snack_req_en, options, BIT_6);\n\tSET_BITVAL(sess->discovery_logout_en, options, BIT_5);\n\tSET_BITVAL(sess->bidi_chap_en, options, BIT_4);\n\tSET_BITVAL(sess->discovery_auth_optional, options, BIT_3);\n\tSET_BITVAL(sess->erl & BIT_1, options, BIT_1);\n\tSET_BITVAL(sess->erl & BIT_0, options, BIT_0);\n\tfw_ddb_entry->iscsi_options = cpu_to_le16(options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->tcp_options);\n\tSET_BITVAL(conn->tcp_timestamp_stat, options, BIT_6);\n\tSET_BITVAL(conn->tcp_nagle_disable, options, BIT_5);\n\tSET_BITVAL(conn->tcp_wsf_disable, options, BIT_4);\n\tSET_BITVAL(conn->tcp_timer_scale & BIT_2, options, BIT_3);\n\tSET_BITVAL(conn->tcp_timer_scale & BIT_1, options, BIT_2);\n\tSET_BITVAL(conn->tcp_timer_scale & BIT_0, options, BIT_1);\n\tSET_BITVAL(conn->tcp_timestamp_en, options, BIT_0);\n\tfw_ddb_entry->tcp_options = cpu_to_le16(options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->ip_options);\n\tSET_BITVAL(conn->fragment_disable, options, BIT_4);\n\tfw_ddb_entry->ip_options = cpu_to_le16(options);\n\n\tfw_ddb_entry->iscsi_max_outsnd_r2t = cpu_to_le16(sess->max_r2t);\n\tfw_ddb_entry->iscsi_max_rcv_data_seg_len =\n\t\t\t       cpu_to_le16(conn->max_recv_dlength / BYTE_UNITS);\n\tfw_ddb_entry->iscsi_max_snd_data_seg_len =\n\t\t\t       cpu_to_le16(conn->max_xmit_dlength / BYTE_UNITS);\n\tfw_ddb_entry->iscsi_first_burst_len =\n\t\t\t\tcpu_to_le16(sess->first_burst / BYTE_UNITS);\n\tfw_ddb_entry->iscsi_max_burst_len = cpu_to_le16(sess->max_burst /\n\t\t\t\t\t    BYTE_UNITS);\n\tfw_ddb_entry->iscsi_def_time2wait = cpu_to_le16(sess->time2wait);\n\tfw_ddb_entry->iscsi_def_time2retain = cpu_to_le16(sess->time2retain);\n\tfw_ddb_entry->tgt_portal_grp = cpu_to_le16(sess->tpgt);\n\tfw_ddb_entry->mss = cpu_to_le16(conn->max_segment_size);\n\tfw_ddb_entry->tcp_xmt_wsf = (uint8_t) cpu_to_le32(conn->tcp_xmit_wsf);\n\tfw_ddb_entry->tcp_rcv_wsf = (uint8_t) cpu_to_le32(conn->tcp_recv_wsf);\n\tfw_ddb_entry->ipv6_flow_lbl = cpu_to_le16(conn->ipv6_flow_label);\n\tfw_ddb_entry->ka_timeout = cpu_to_le16(conn->keepalive_timeout);\n\tfw_ddb_entry->lcl_port = cpu_to_le16(conn->local_port);\n\tfw_ddb_entry->stat_sn = cpu_to_le32(conn->statsn);\n\tfw_ddb_entry->exp_stat_sn = cpu_to_le32(conn->exp_statsn);\n\tfw_ddb_entry->ddb_link = cpu_to_le16(sess->discovery_parent_idx);\n\tfw_ddb_entry->chap_tbl_idx = cpu_to_le16(sess->chap_out_idx);\n\tfw_ddb_entry->tsid = cpu_to_le16(sess->tsid);\n\tfw_ddb_entry->port = cpu_to_le16(conn->port);\n\tfw_ddb_entry->def_timeout =\n\t\t\t\tcpu_to_le16(sess->default_taskmgmt_timeout);\n\n\tif (!strncmp(sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\tfw_ddb_entry->ipv4_tos = conn->ipv6_traffic_class;\n\telse\n\t\tfw_ddb_entry->ipv4_tos = conn->ipv4_tos;\n\n\tif (conn->ipaddress)\n\t\tmemcpy(fw_ddb_entry->ip_addr, conn->ipaddress,\n\t\t       sizeof(fw_ddb_entry->ip_addr));\n\n\tif (conn->redirect_ipaddr)\n\t\tmemcpy(fw_ddb_entry->tgt_addr, conn->redirect_ipaddr,\n\t\t       sizeof(fw_ddb_entry->tgt_addr));\n\n\tif (conn->link_local_ipv6_addr)\n\t\tmemcpy(fw_ddb_entry->link_local_ipv6_addr,\n\t\t       conn->link_local_ipv6_addr,\n\t\t       sizeof(fw_ddb_entry->link_local_ipv6_addr));\n\n\tif (sess->targetname)\n\t\tmemcpy(fw_ddb_entry->iscsi_name, sess->targetname,\n\t\t       sizeof(fw_ddb_entry->iscsi_name));\n\n\tif (sess->targetalias)\n\t\tmemcpy(fw_ddb_entry->iscsi_alias, sess->targetalias,\n\t\t       sizeof(fw_ddb_entry->iscsi_alias));\n\n\tCOPY_ISID(fw_ddb_entry->isid, sess->isid);\n\n\treturn 0;\n}\n\nstatic void qla4xxx_copy_to_sess_conn_params(struct iscsi_conn *conn,\n\t\t\t\t\t     struct iscsi_session *sess,\n\t\t\t\t\t     struct dev_db_entry *fw_ddb_entry)\n{\n\tunsigned long options = 0;\n\tuint16_t ddb_link;\n\tuint16_t disc_parent;\n\tchar ip_addr[DDB_IPADDR_LEN];\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tconn->is_fw_assigned_ipv6 = test_bit(OPT_IS_FW_ASSIGNED_IPV6, &options);\n\tsess->auto_snd_tgt_disable = test_bit(OPT_AUTO_SENDTGTS_DISABLE,\n\t\t\t\t\t      &options);\n\tsess->discovery_sess = test_bit(OPT_DISC_SESSION, &options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->iscsi_options);\n\tconn->hdrdgst_en = test_bit(ISCSIOPT_HEADER_DIGEST_EN, &options);\n\tconn->datadgst_en = test_bit(ISCSIOPT_DATA_DIGEST_EN, &options);\n\tsess->imm_data_en = test_bit(ISCSIOPT_IMMEDIATE_DATA_EN, &options);\n\tsess->initial_r2t_en = test_bit(ISCSIOPT_INITIAL_R2T_EN, &options);\n\tsess->dataseq_inorder_en = test_bit(ISCSIOPT_DATA_SEQ_IN_ORDER,\n\t\t\t\t\t    &options);\n\tsess->pdu_inorder_en = test_bit(ISCSIOPT_DATA_PDU_IN_ORDER, &options);\n\tsess->chap_auth_en = test_bit(ISCSIOPT_CHAP_AUTH_EN, &options);\n\tsess->discovery_logout_en = test_bit(ISCSIOPT_DISCOVERY_LOGOUT_EN,\n\t\t\t\t\t     &options);\n\tsess->bidi_chap_en = test_bit(ISCSIOPT_BIDI_CHAP_EN, &options);\n\tsess->discovery_auth_optional =\n\t\t\ttest_bit(ISCSIOPT_DISCOVERY_AUTH_OPTIONAL, &options);\n\tif (test_bit(ISCSIOPT_ERL1, &options))\n\t\tsess->erl |= BIT_1;\n\tif (test_bit(ISCSIOPT_ERL0, &options))\n\t\tsess->erl |= BIT_0;\n\n\toptions = le16_to_cpu(fw_ddb_entry->tcp_options);\n\tconn->tcp_timestamp_stat = test_bit(TCPOPT_TIMESTAMP_STAT, &options);\n\tconn->tcp_nagle_disable = test_bit(TCPOPT_NAGLE_DISABLE, &options);\n\tconn->tcp_wsf_disable = test_bit(TCPOPT_WSF_DISABLE, &options);\n\tif (test_bit(TCPOPT_TIMER_SCALE3, &options))\n\t\tconn->tcp_timer_scale |= BIT_3;\n\tif (test_bit(TCPOPT_TIMER_SCALE2, &options))\n\t\tconn->tcp_timer_scale |= BIT_2;\n\tif (test_bit(TCPOPT_TIMER_SCALE1, &options))\n\t\tconn->tcp_timer_scale |= BIT_1;\n\n\tconn->tcp_timer_scale >>= 1;\n\tconn->tcp_timestamp_en = test_bit(TCPOPT_TIMESTAMP_EN, &options);\n\n\toptions = le16_to_cpu(fw_ddb_entry->ip_options);\n\tconn->fragment_disable = test_bit(IPOPT_FRAGMENT_DISABLE, &options);\n\n\tconn->max_recv_dlength = BYTE_UNITS *\n\t\t\t  le16_to_cpu(fw_ddb_entry->iscsi_max_rcv_data_seg_len);\n\tconn->max_xmit_dlength = BYTE_UNITS *\n\t\t\t  le16_to_cpu(fw_ddb_entry->iscsi_max_snd_data_seg_len);\n\tsess->max_r2t = le16_to_cpu(fw_ddb_entry->iscsi_max_outsnd_r2t);\n\tsess->first_burst = BYTE_UNITS *\n\t\t\t       le16_to_cpu(fw_ddb_entry->iscsi_first_burst_len);\n\tsess->max_burst = BYTE_UNITS *\n\t\t\t\t le16_to_cpu(fw_ddb_entry->iscsi_max_burst_len);\n\tsess->time2wait = le16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\n\tsess->time2retain = le16_to_cpu(fw_ddb_entry->iscsi_def_time2retain);\n\tsess->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\n\tconn->max_segment_size = le16_to_cpu(fw_ddb_entry->mss);\n\tconn->tcp_xmit_wsf = fw_ddb_entry->tcp_xmt_wsf;\n\tconn->tcp_recv_wsf = fw_ddb_entry->tcp_rcv_wsf;\n\tconn->ipv4_tos = fw_ddb_entry->ipv4_tos;\n\tconn->keepalive_tmo = le16_to_cpu(fw_ddb_entry->ka_timeout);\n\tconn->local_port = le16_to_cpu(fw_ddb_entry->lcl_port);\n\tconn->statsn = le32_to_cpu(fw_ddb_entry->stat_sn);\n\tconn->exp_statsn = le32_to_cpu(fw_ddb_entry->exp_stat_sn);\n\tsess->tsid = le16_to_cpu(fw_ddb_entry->tsid);\n\tCOPY_ISID(sess->isid, fw_ddb_entry->isid);\n\n\tddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\n\tif (ddb_link == DDB_ISNS)\n\t\tdisc_parent = ISCSI_DISC_PARENT_ISNS;\n\telse if (ddb_link == DDB_NO_LINK)\n\t\tdisc_parent = ISCSI_DISC_PARENT_UNKNOWN;\n\telse if (ddb_link < MAX_DDB_ENTRIES)\n\t\tdisc_parent = ISCSI_DISC_PARENT_SENDTGT;\n\telse\n\t\tdisc_parent = ISCSI_DISC_PARENT_UNKNOWN;\n\n\tiscsi_set_param(conn->cls_conn, ISCSI_PARAM_DISCOVERY_PARENT_TYPE,\n\t\t\tiscsi_get_discovery_parent_name(disc_parent), 0);\n\n\tiscsi_set_param(conn->cls_conn, ISCSI_PARAM_TARGET_ALIAS,\n\t\t\t(char *)fw_ddb_entry->iscsi_alias, 0);\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE) {\n\t\tmemset(ip_addr, 0, sizeof(ip_addr));\n\t\tsprintf(ip_addr, \"%pI6\", fw_ddb_entry->link_local_ipv6_addr);\n\t\tiscsi_set_param(conn->cls_conn, ISCSI_PARAM_LOCAL_IPADDR,\n\t\t\t\t(char *)ip_addr, 0);\n\t}\n}\n\nstatic void qla4xxx_copy_fwddb_param(struct scsi_qla_host *ha,\n\t\t\t\t     struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t     struct iscsi_cls_session *cls_sess,\n\t\t\t\t     struct iscsi_cls_conn *cls_conn)\n{\n\tint buflen = 0;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct ql4_chap_table chap_tbl;\n\tstruct iscsi_conn *conn;\n\tchar ip_addr[DDB_IPADDR_LEN];\n\tuint16_t options = 0;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tconn = cls_conn->dd_data;\n\tmemset(&chap_tbl, 0, sizeof(chap_tbl));\n\n\tddb_entry->chap_tbl_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\n\n\tqla4xxx_copy_to_sess_conn_params(conn, sess, fw_ddb_entry);\n\n\tsess->def_taskmgmt_tmo = le16_to_cpu(fw_ddb_entry->def_timeout);\n\tconn->persistent_port = le16_to_cpu(fw_ddb_entry->port);\n\n\tmemset(ip_addr, 0, sizeof(ip_addr));\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE) {\n\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_PORTAL_TYPE, \"ipv6\", 4);\n\n\t\tmemset(ip_addr, 0, sizeof(ip_addr));\n\t\tsprintf(ip_addr, \"%pI6\", fw_ddb_entry->ip_addr);\n\t} else {\n\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_PORTAL_TYPE, \"ipv4\", 4);\n\t\tsprintf(ip_addr, \"%pI4\", fw_ddb_entry->ip_addr);\n\t}\n\n\tiscsi_set_param(cls_conn, ISCSI_PARAM_PERSISTENT_ADDRESS,\n\t\t\t(char *)ip_addr, buflen);\n\tiscsi_set_param(cls_conn, ISCSI_PARAM_TARGET_NAME,\n\t\t\t(char *)fw_ddb_entry->iscsi_name, buflen);\n\tiscsi_set_param(cls_conn, ISCSI_PARAM_INITIATOR_NAME,\n\t\t\t(char *)ha->name_string, buflen);\n\n\tif (ddb_entry->chap_tbl_idx != INVALID_ENTRY) {\n\t\tif (!qla4xxx_get_uni_chap_at_index(ha, chap_tbl.name,\n\t\t\t\t\t\t   chap_tbl.secret,\n\t\t\t\t\t\t   ddb_entry->chap_tbl_idx)) {\n\t\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_USERNAME,\n\t\t\t\t\t(char *)chap_tbl.name,\n\t\t\t\t\tstrlen((char *)chap_tbl.name));\n\t\t\tiscsi_set_param(cls_conn, ISCSI_PARAM_PASSWORD,\n\t\t\t\t\t(char *)chap_tbl.secret,\n\t\t\t\t\tchap_tbl.secret_len);\n\t\t}\n\t}\n}\n\nvoid qla4xxx_update_session_conn_fwddb_param(struct scsi_qla_host *ha,\n\t\t\t\t\t     struct ddb_entry *ddb_entry)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tuint32_t ddb_state;\n\tdma_addr_t fw_ddb_entry_dma;\n\tstruct dev_db_entry *fw_ddb_entry;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto exit_session_conn_fwddb_param;\n\t}\n\n\tif (qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index, fw_ddb_entry,\n\t\t\t\t    fw_ddb_entry_dma, NULL, NULL, &ddb_state,\n\t\t\t\t    NULL, NULL, NULL) == QLA_ERROR) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: failed \"\n\t\t\t\t  \"get_ddb_entry for fw_ddb_index %d\\n\",\n\t\t\t\t  ha->host_no, __func__,\n\t\t\t\t  ddb_entry->fw_ddb_index));\n\t\tgoto exit_session_conn_fwddb_param;\n\t}\n\n\tcls_sess = ddb_entry->sess;\n\n\tcls_conn = ddb_entry->conn;\n\n\t \n\tqla4xxx_copy_fwddb_param(ha, fw_ddb_entry, cls_sess, cls_conn);\n\nexit_session_conn_fwddb_param:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n}\n\nvoid qla4xxx_update_session_conn_param(struct scsi_qla_host *ha,\n\t\t\t\t       struct ddb_entry *ddb_entry)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_session *sess;\n\tstruct iscsi_conn *conn;\n\tuint32_t ddb_state;\n\tdma_addr_t fw_ddb_entry_dma;\n\tstruct dev_db_entry *fw_ddb_entry;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto exit_session_conn_param;\n\t}\n\n\tif (qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index, fw_ddb_entry,\n\t\t\t\t    fw_ddb_entry_dma, NULL, NULL, &ddb_state,\n\t\t\t\t    NULL, NULL, NULL) == QLA_ERROR) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: failed \"\n\t\t\t\t  \"get_ddb_entry for fw_ddb_index %d\\n\",\n\t\t\t\t  ha->host_no, __func__,\n\t\t\t\t  ddb_entry->fw_ddb_index));\n\t\tgoto exit_session_conn_param;\n\t}\n\n\tcls_sess = ddb_entry->sess;\n\tsess = cls_sess->dd_data;\n\n\tcls_conn = ddb_entry->conn;\n\tconn = cls_conn->dd_data;\n\n\t \n\tddb_entry->default_relogin_timeout =\n\t\t(le16_to_cpu(fw_ddb_entry->def_timeout) > LOGIN_TOV) &&\n\t\t (le16_to_cpu(fw_ddb_entry->def_timeout) < LOGIN_TOV * 10) ?\n\t\t le16_to_cpu(fw_ddb_entry->def_timeout) : LOGIN_TOV;\n\tddb_entry->default_time2wait =\n\t\t\t\tle16_to_cpu(fw_ddb_entry->iscsi_def_time2wait);\n\n\t \n\tddb_entry->chap_tbl_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\n\tqla4xxx_copy_to_sess_conn_params(conn, sess, fw_ddb_entry);\n\n\tmemcpy(sess->initiatorname, ha->name_string,\n\t       min(sizeof(ha->name_string), sizeof(sess->initiatorname)));\n\nexit_session_conn_param:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n}\n\n \nstatic void qla4xxx_timer(struct timer_list *t);\n\nstatic void qla4xxx_start_timer(struct scsi_qla_host *ha,\n\t\t\t\tunsigned long interval)\n{\n\tDEBUG(printk(\"scsi: %s: Starting timer thread for adapter %d\\n\",\n\t\t     __func__, ha->host->host_no));\n\ttimer_setup(&ha->timer, qla4xxx_timer, 0);\n\tha->timer.expires = jiffies + interval * HZ;\n\tadd_timer(&ha->timer);\n\tha->timer_active = 1;\n}\n\nstatic void qla4xxx_stop_timer(struct scsi_qla_host *ha)\n{\n\tdel_timer_sync(&ha->timer);\n\tha->timer_active = 0;\n}\n\n \nvoid qla4xxx_mark_device_missing(struct iscsi_cls_session *cls_session)\n{\n\tiscsi_block_session(cls_session);\n}\n\n \nvoid qla4xxx_mark_all_devices_missing(struct scsi_qla_host *ha)\n{\n\tiscsi_host_for_each_session(ha->host, qla4xxx_mark_device_missing);\n}\n\nstatic struct srb* qla4xxx_get_new_srb(struct scsi_qla_host *ha,\n\t\t\t\t       struct ddb_entry *ddb_entry,\n\t\t\t\t       struct scsi_cmnd *cmd)\n{\n\tstruct srb *srb;\n\n\tsrb = mempool_alloc(ha->srb_mempool, GFP_ATOMIC);\n\tif (!srb)\n\t\treturn srb;\n\n\tkref_init(&srb->srb_ref);\n\tsrb->ha = ha;\n\tsrb->ddb = ddb_entry;\n\tsrb->cmd = cmd;\n\tsrb->flags = 0;\n\tqla4xxx_cmd_priv(cmd)->srb = srb;\n\n\treturn srb;\n}\n\nstatic void qla4xxx_srb_free_dma(struct scsi_qla_host *ha, struct srb *srb)\n{\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\n\tif (srb->flags & SRB_DMA_VALID) {\n\t\tscsi_dma_unmap(cmd);\n\t\tsrb->flags &= ~SRB_DMA_VALID;\n\t}\n\tqla4xxx_cmd_priv(cmd)->srb = NULL;\n}\n\nvoid qla4xxx_srb_compl(struct kref *ref)\n{\n\tstruct srb *srb = container_of(ref, struct srb, srb_ref);\n\tstruct scsi_cmnd *cmd = srb->cmd;\n\tstruct scsi_qla_host *ha = srb->ha;\n\n\tqla4xxx_srb_free_dma(ha, srb);\n\n\tmempool_free(srb, ha->srb_mempool);\n\n\tscsi_done(cmd);\n}\n\n \nstatic int qla4xxx_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct ddb_entry *ddb_entry = cmd->device->hostdata;\n\tstruct iscsi_cls_session *sess = ddb_entry->sess;\n\tstruct srb *srb;\n\tint rval;\n\n\tif (test_bit(AF_EEH_BUSY, &ha->flags)) {\n\t\tif (test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))\n\t\t\tcmd->result = DID_NO_CONNECT << 16;\n\t\telse\n\t\t\tcmd->result = DID_REQUEUE << 16;\n\t\tgoto qc_fail_command;\n\t}\n\n\tif (!sess) {\n\t\tcmd->result = DID_IMM_RETRY << 16;\n\t\tgoto qc_fail_command;\n\t}\n\n\trval = iscsi_session_chkready(sess);\n\tif (rval) {\n\t\tcmd->result = rval;\n\t\tgoto qc_fail_command;\n\t}\n\n\tif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t    test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||\n\t    test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||\n\t    !test_bit(AF_ONLINE, &ha->flags) ||\n\t    !test_bit(AF_LINK_UP, &ha->flags) ||\n\t    test_bit(AF_LOOPBACK, &ha->flags) ||\n\t    test_bit(DPC_POST_IDC_ACK, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESTORE_ACB, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))\n\t\tgoto qc_host_busy;\n\n\tsrb = qla4xxx_get_new_srb(ha, ddb_entry, cmd);\n\tif (!srb)\n\t\tgoto qc_host_busy;\n\n\trval = qla4xxx_send_command_to_isp(ha, srb);\n\tif (rval != QLA_SUCCESS)\n\t\tgoto qc_host_busy_free_sp;\n\n\treturn 0;\n\nqc_host_busy_free_sp:\n\tqla4xxx_srb_free_dma(ha, srb);\n\tmempool_free(srb, ha->srb_mempool);\n\nqc_host_busy:\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n\nqc_fail_command:\n\tscsi_done(cmd);\n\n\treturn 0;\n}\n\n \nstatic void qla4xxx_mem_free(struct scsi_qla_host *ha)\n{\n\tif (ha->queues)\n\t\tdma_free_coherent(&ha->pdev->dev, ha->queues_len, ha->queues,\n\t\t\t\t  ha->queues_dma);\n\n\tvfree(ha->fw_dump);\n\n\tha->queues_len = 0;\n\tha->queues = NULL;\n\tha->queues_dma = 0;\n\tha->request_ring = NULL;\n\tha->request_dma = 0;\n\tha->response_ring = NULL;\n\tha->response_dma = 0;\n\tha->shadow_regs = NULL;\n\tha->shadow_regs_dma = 0;\n\tha->fw_dump = NULL;\n\tha->fw_dump_size = 0;\n\n\t \n\tmempool_destroy(ha->srb_mempool);\n\tha->srb_mempool = NULL;\n\n\tdma_pool_destroy(ha->chap_dma_pool);\n\n\tvfree(ha->chap_list);\n\tha->chap_list = NULL;\n\n\tdma_pool_destroy(ha->fw_ddb_dma_pool);\n\n\t \n\tif (is_qla8022(ha)) {\n\t\tif (ha->nx_pcibase)\n\t\t\tiounmap(\n\t\t\t    (struct device_reg_82xx __iomem *)ha->nx_pcibase);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tif (ha->nx_pcibase)\n\t\t\tiounmap(\n\t\t\t    (struct device_reg_83xx __iomem *)ha->nx_pcibase);\n\t} else if (ha->reg) {\n\t\tiounmap(ha->reg);\n\t}\n\n\tvfree(ha->reset_tmplt.buff);\n\n\tpci_release_regions(ha->pdev);\n}\n\n \nstatic int qla4xxx_mem_alloc(struct scsi_qla_host *ha)\n{\n\tunsigned long align;\n\n\t \n\tha->queues_len = ((REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +\n\t\t\t  (RESPONSE_QUEUE_DEPTH * QUEUE_SIZE) +\n\t\t\t  sizeof(struct shadow_regs) +\n\t\t\t  MEM_ALIGN_VALUE +\n\t\t\t  (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n\tha->queues = dma_alloc_coherent(&ha->pdev->dev, ha->queues_len,\n\t\t\t\t\t&ha->queues_dma, GFP_KERNEL);\n\tif (ha->queues == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"Memory Allocation failed - queues.\\n\");\n\n\t\tgoto mem_alloc_error_exit;\n\t}\n\n\t \n\talign = 0;\n\tif ((unsigned long)ha->queues_dma & (MEM_ALIGN_VALUE - 1))\n\t\talign = MEM_ALIGN_VALUE - ((unsigned long)ha->queues_dma &\n\t\t\t\t\t   (MEM_ALIGN_VALUE - 1));\n\n\t \n\tha->request_dma = ha->queues_dma + align;\n\tha->request_ring = (struct queue_entry *) (ha->queues + align);\n\tha->response_dma = ha->queues_dma + align +\n\t\t(REQUEST_QUEUE_DEPTH * QUEUE_SIZE);\n\tha->response_ring = (struct queue_entry *) (ha->queues + align +\n\t\t\t\t\t\t    (REQUEST_QUEUE_DEPTH *\n\t\t\t\t\t\t     QUEUE_SIZE));\n\tha->shadow_regs_dma = ha->queues_dma + align +\n\t\t(REQUEST_QUEUE_DEPTH * QUEUE_SIZE) +\n\t\t(RESPONSE_QUEUE_DEPTH * QUEUE_SIZE);\n\tha->shadow_regs = (struct shadow_regs *) (ha->queues + align +\n\t\t\t\t\t\t  (REQUEST_QUEUE_DEPTH *\n\t\t\t\t\t\t   QUEUE_SIZE) +\n\t\t\t\t\t\t  (RESPONSE_QUEUE_DEPTH *\n\t\t\t\t\t\t   QUEUE_SIZE));\n\n\t \n\tha->srb_mempool = mempool_create(SRB_MIN_REQ, mempool_alloc_slab,\n\t\t\t\t\t mempool_free_slab, srb_cachep);\n\tif (ha->srb_mempool == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"Memory Allocation failed - SRB Pool.\\n\");\n\n\t\tgoto mem_alloc_error_exit;\n\t}\n\n\tha->chap_dma_pool = dma_pool_create(\"ql4_chap\", &ha->pdev->dev,\n\t\t\t\t\t    CHAP_DMA_BLOCK_SIZE, 8, 0);\n\n\tif (ha->chap_dma_pool == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"%s: chap_dma_pool allocation failed..\\n\", __func__);\n\t\tgoto mem_alloc_error_exit;\n\t}\n\n\tha->fw_ddb_dma_pool = dma_pool_create(\"ql4_fw_ddb\", &ha->pdev->dev,\n\t\t\t\t\t      DDB_DMA_BLOCK_SIZE, 8, 0);\n\n\tif (ha->fw_ddb_dma_pool == NULL) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s: fw_ddb_dma_pool allocation failed..\\n\",\n\t\t\t   __func__);\n\t\tgoto mem_alloc_error_exit;\n\t}\n\n\treturn QLA_SUCCESS;\n\nmem_alloc_error_exit:\n\treturn QLA_ERROR;\n}\n\n \nstatic int qla4_8xxx_check_temp(struct scsi_qla_host *ha)\n{\n\tuint32_t temp, temp_state, temp_val;\n\tint status = QLA_SUCCESS;\n\n\ttemp = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_TEMP_STATE);\n\n\ttemp_state = qla82xx_get_temp_state(temp);\n\ttemp_val = qla82xx_get_temp_val(temp);\n\n\tif (temp_state == QLA82XX_TEMP_PANIC) {\n\t\tql4_printk(KERN_WARNING, ha, \"Device temperature %d degrees C\"\n\t\t\t   \" exceeds maximum allowed. Hardware has been shut\"\n\t\t\t   \" down.\\n\", temp_val);\n\t\tstatus = QLA_ERROR;\n\t} else if (temp_state == QLA82XX_TEMP_WARN) {\n\t\tif (ha->temperature == QLA82XX_TEMP_NORMAL)\n\t\t\tql4_printk(KERN_WARNING, ha, \"Device temperature %d\"\n\t\t\t\t   \" degrees C exceeds operating range.\"\n\t\t\t\t   \" Immediate action needed.\\n\", temp_val);\n\t} else {\n\t\tif (ha->temperature == QLA82XX_TEMP_WARN)\n\t\t\tql4_printk(KERN_INFO, ha, \"Device temperature is\"\n\t\t\t\t   \" now %d degrees C in normal range.\\n\",\n\t\t\t\t   temp_val);\n\t}\n\tha->temperature = temp_state;\n\treturn status;\n}\n\n \nstatic int qla4_8xxx_check_fw_alive(struct scsi_qla_host *ha)\n{\n\tuint32_t fw_heartbeat_counter;\n\tint status = QLA_SUCCESS;\n\n\tfw_heartbeat_counter = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t   QLA8XXX_PEG_ALIVE_COUNTER);\n\t \n\tif (fw_heartbeat_counter == 0xffffffff) {\n\t\tDEBUG2(printk(KERN_WARNING \"scsi%ld: %s: Device in frozen \"\n\t\t    \"state, QLA82XX_PEG_ALIVE_COUNTER is 0xffffffff\\n\",\n\t\t    ha->host_no, __func__));\n\t\treturn status;\n\t}\n\n\tif (ha->fw_heartbeat_counter == fw_heartbeat_counter) {\n\t\tha->seconds_since_last_heartbeat++;\n\t\t \n\t\tif (ha->seconds_since_last_heartbeat == 2) {\n\t\t\tha->seconds_since_last_heartbeat = 0;\n\t\t\tqla4_8xxx_dump_peg_reg(ha);\n\t\t\tstatus = QLA_ERROR;\n\t\t}\n\t} else\n\t\tha->seconds_since_last_heartbeat = 0;\n\n\tha->fw_heartbeat_counter = fw_heartbeat_counter;\n\treturn status;\n}\n\nstatic void qla4_8xxx_process_fw_error(struct scsi_qla_host *ha)\n{\n\tuint32_t halt_status;\n\tint halt_status_unrecoverable = 0;\n\n\thalt_status = qla4_8xxx_rd_direct(ha, QLA8XXX_PEG_HALT_STATUS1);\n\n\tif (is_qla8022(ha)) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: disabling pause transmit on port 0 & 1.\\n\",\n\t\t\t   __func__);\n\t\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\n\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P0 |\n\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P1);\n\n\t\tif (QLA82XX_FWERROR_CODE(halt_status) == 0x67)\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Firmware aborted with error code 0x00006700. Device is being reset\\n\",\n\t\t\t\t   __func__);\n\t\tif (halt_status & HALT_STATUS_UNRECOVERABLE)\n\t\t\thalt_status_unrecoverable = 1;\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tif (halt_status & QLA83XX_HALT_STATUS_FW_RESET)\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Firmware error detected device is being reset\\n\",\n\t\t\t\t   __func__);\n\t\telse if (halt_status & QLA83XX_HALT_STATUS_UNRECOVERABLE)\n\t\t\thalt_status_unrecoverable = 1;\n\t}\n\n\t \n\tif (halt_status_unrecoverable) {\n\t\tset_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);\n\t} else {\n\t\tql4_printk(KERN_INFO, ha, \"%s: detect abort needed!\\n\",\n\t\t\t   __func__);\n\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t}\n\tqla4xxx_mailbox_premature_completion(ha);\n\tqla4xxx_wake_dpc(ha);\n}\n\n \nvoid qla4_8xxx_watchdog(struct scsi_qla_host *ha)\n{\n\tuint32_t dev_state;\n\tuint32_t idc_ctrl;\n\n\tif (is_qla8032(ha) &&\n\t    (qla4_83xx_is_detached(ha) == QLA_SUCCESS))\n\t\tWARN_ONCE(1, \"%s: iSCSI function %d marked invisible\\n\",\n\t\t\t  __func__, ha->func_num);\n\n\t \n\tif (!(test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t    test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags))) {\n\t\tdev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\n\n\t\tif (qla4_8xxx_check_temp(ha)) {\n\t\t\tif (is_qla8022(ha)) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"disabling pause transmit on port 0 & 1.\\n\");\n\t\t\t\tqla4_82xx_wr_32(ha, QLA82XX_CRB_NIU + 0x98,\n\t\t\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P0 |\n\t\t\t\t\t\tCRB_NIU_XG_PAUSE_CTL_P1);\n\t\t\t}\n\t\t\tset_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags);\n\t\t\tqla4xxx_wake_dpc(ha);\n\t\t} else if (dev_state == QLA8XXX_DEV_NEED_RESET &&\n\t\t\t   !test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: HW State: NEED RESET!\\n\",\n\t\t\t\t   __func__);\n\n\t\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\t\tidc_ctrl = qla4_83xx_rd_reg(ha,\n\t\t\t\t\t\t\tQLA83XX_IDC_DRV_CTRL);\n\t\t\t\tif (!(idc_ctrl & GRACEFUL_RESET_BIT1)) {\n\t\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: Graceful reset bit is not set\\n\",\n\t\t\t\t\t\t   __func__);\n\t\t\t\t\tqla4xxx_mailbox_premature_completion(\n\t\t\t\t\t\t\t\t\t    ha);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((is_qla8032(ha) || is_qla8042(ha)) ||\n\t\t\t    (is_qla8022(ha) && !ql4xdontresethba)) {\n\t\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t\tqla4xxx_wake_dpc(ha);\n\t\t\t}\n\t\t} else if (dev_state == QLA8XXX_DEV_NEED_QUIESCENT &&\n\t\t    !test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: HW State: NEED QUIES!\\n\",\n\t\t\t    __func__);\n\t\t\tset_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags);\n\t\t\tqla4xxx_wake_dpc(ha);\n\t\t} else  {\n\t\t\t \n\t\t\tif (qla4_8xxx_check_fw_alive(ha))\n\t\t\t\tqla4_8xxx_process_fw_error(ha);\n\t\t}\n\t}\n}\n\nstatic void qla4xxx_check_relogin_flash_ddb(struct iscsi_cls_session *cls_sess)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tif (!(ddb_entry->ddb_type == FLASH_DDB))\n\t\treturn;\n\n\tif (adapter_up(ha) && !test_bit(DF_RELOGIN, &ddb_entry->flags) &&\n\t    !iscsi_is_session_online(cls_sess)) {\n\t\tif (atomic_read(&ddb_entry->retry_relogin_timer) !=\n\t\t    INVALID_ENTRY) {\n\t\t\tif (atomic_read(&ddb_entry->retry_relogin_timer) ==\n\t\t\t\t\t0) {\n\t\t\t\tatomic_set(&ddb_entry->retry_relogin_timer,\n\t\t\t\t\t   INVALID_ENTRY);\n\t\t\t\tset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\n\t\t\t\tset_bit(DF_RELOGIN, &ddb_entry->flags);\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t       \"%s: index [%d] login device\\n\",\n\t\t\t\t\t__func__, ddb_entry->fw_ddb_index));\n\t\t\t} else\n\t\t\t\tatomic_dec(&ddb_entry->retry_relogin_timer);\n\t\t}\n\t}\n\n\t \n\tif (atomic_read(&ddb_entry->relogin_timer) &&\n\t    (atomic_dec_and_test(&ddb_entry->relogin_timer) != 0)) {\n\t\t \n\t\tif (!iscsi_is_session_online(cls_sess)) {\n\t\t\t \n\t\t\tatomic_inc(&ddb_entry->relogin_retry_count);\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\"%s: index[%d] relogin timed out-retrying\"\n\t\t\t\t\" relogin (%d), retry (%d)\\n\", __func__,\n\t\t\t\tddb_entry->fw_ddb_index,\n\t\t\t\tatomic_read(&ddb_entry->relogin_retry_count),\n\t\t\t\tddb_entry->default_time2wait + 4));\n\t\t\tset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\n\t\t\tatomic_set(&ddb_entry->retry_relogin_timer,\n\t\t\t\t   ddb_entry->default_time2wait + 4);\n\t\t}\n\t}\n}\n\n \nstatic void qla4xxx_timer(struct timer_list *t)\n{\n\tstruct scsi_qla_host *ha = from_timer(ha, t, timer);\n\tint start_dpc = 0;\n\tuint16_t w;\n\n\tiscsi_host_for_each_session(ha->host, qla4xxx_check_relogin_flash_ddb);\n\n\t \n\tif (test_bit(AF_EEH_BUSY, &ha->flags)) {\n\t\tmod_timer(&ha->timer, jiffies + HZ);\n\t\treturn;\n\t}\n\n\t \n\tif (!pci_channel_offline(ha->pdev))\n\t\tpci_read_config_word(ha->pdev, PCI_VENDOR_ID, &w);\n\n\tif (is_qla80XX(ha))\n\t\tqla4_8xxx_watchdog(ha);\n\n\tif (is_qla40XX(ha)) {\n\t\t \n\t\tif (ha->firmware_options & FWOPT_HEARTBEAT_ENABLE &&\n\t\t    ha->heartbeat_interval != 0) {\n\t\t\tha->seconds_since_last_heartbeat++;\n\t\t\tif (ha->seconds_since_last_heartbeat >\n\t\t\t    ha->heartbeat_interval + 2)\n\t\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t}\n\t}\n\n\t \n\tif (!list_empty(&ha->work_list))\n\t\tstart_dpc++;\n\n\t \n\tif (start_dpc ||\n\t     test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t     test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags) ||\n\t     test_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags) ||\n\t     test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\n\t     test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\n\t     test_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags) ||\n\t     test_bit(DPC_LINK_CHANGED, &ha->dpc_flags) ||\n\t     test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags) ||\n\t     test_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags) ||\n\t     test_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags) ||\n\t     test_bit(DPC_AEN, &ha->dpc_flags)) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: scheduling dpc routine\"\n\t\t\t      \" - dpc flags = 0x%lx\\n\",\n\t\t\t      ha->host_no, __func__, ha->dpc_flags));\n\t\tqla4xxx_wake_dpc(ha);\n\t}\n\n\t \n\tmod_timer(&ha->timer, jiffies + HZ);\n\n\tDEBUG2(ha->seconds_since_last_intr++);\n}\n\n \nstatic int qla4xxx_cmd_wait(struct scsi_qla_host *ha)\n{\n\tuint32_t index = 0;\n\tunsigned long flags;\n\tstruct scsi_cmnd *cmd;\n\tunsigned long wtime;\n\tuint32_t wtmo;\n\n\tif (is_qla40XX(ha))\n\t\twtmo = WAIT_CMD_TOV;\n\telse\n\t\twtmo = ha->nx_reset_timeout / 2;\n\n\twtime = jiffies + (wtmo * HZ);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Wait up to %u seconds for cmds to complete\\n\",\n\t\t\t  wtmo));\n\n\twhile (!time_after_eq(jiffies, wtime)) {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t \n\t\tfor (index = 0; index < ha->host->can_queue; index++) {\n\t\t\tcmd = scsi_host_find_tag(ha->host, index);\n\t\t\t \n\t\t\tif (cmd != NULL && qla4xxx_cmd_priv(cmd)->srb)\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\t \n\t\tif (index == ha->host->can_queue)\n\t\t\treturn QLA_SUCCESS;\n\n\t\tmsleep(1000);\n\t}\n\t \n\treturn QLA_ERROR;\n}\n\nint qla4xxx_hw_reset(struct scsi_qla_host *ha)\n{\n\tuint32_t ctrl_status;\n\tunsigned long flags = 0;\n\n\tDEBUG2(printk(KERN_ERR \"scsi%ld: %s\\n\", ha->host_no, __func__));\n\n\tif (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)\n\t\treturn QLA_ERROR;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\t \n\tctrl_status = readw(&ha->reg->ctrl_status);\n\tif ((ctrl_status & CSR_SCSI_RESET_INTR) != 0)\n\t\twritel(set_rmask(CSR_SCSI_RESET_INTR), &ha->reg->ctrl_status);\n\n\t \n\twritel(set_rmask(CSR_SOFT_RESET), &ha->reg->ctrl_status);\n\treadl(&ha->reg->ctrl_status);\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\treturn QLA_SUCCESS;\n}\n\n \nint qla4xxx_soft_reset(struct scsi_qla_host *ha)\n{\n\tuint32_t max_wait_time;\n\tunsigned long flags = 0;\n\tint status;\n\tuint32_t ctrl_status;\n\n\tstatus = qla4xxx_hw_reset(ha);\n\tif (status != QLA_SUCCESS)\n\t\treturn status;\n\n\tstatus = QLA_ERROR;\n\t \n\tmax_wait_time = RESET_INTR_TOV;\n\tdo {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tctrl_status = readw(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tif ((ctrl_status & CSR_NET_RESET_INTR) == 0)\n\t\t\tbreak;\n\n\t\tmsleep(1000);\n\t} while ((--max_wait_time));\n\n\tif ((ctrl_status & CSR_NET_RESET_INTR) != 0) {\n\t\tDEBUG2(printk(KERN_WARNING\n\t\t\t      \"scsi%ld: Network Reset Intr not cleared by \"\n\t\t\t      \"Network function, clearing it now!\\n\",\n\t\t\t      ha->host_no));\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twritel(set_rmask(CSR_NET_RESET_INTR), &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t}\n\n\t \n\tmax_wait_time = SOFT_RESET_TOV;\n\tdo {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tctrl_status = readw(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tif ((ctrl_status & CSR_SOFT_RESET) == 0) {\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(1000);\n\t} while ((--max_wait_time));\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tctrl_status = readw(&ha->reg->ctrl_status);\n\tif ((ctrl_status & CSR_SCSI_RESET_INTR) != 0) {\n\t\twritel(set_rmask(CSR_SCSI_RESET_INTR), &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t \n\tif (max_wait_time == 0) {\n\t\t \n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twritel(set_rmask(CSR_FORCE_SOFT_RESET), &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\t \n\t\tmax_wait_time = SOFT_RESET_TOV;\n\t\tdo {\n\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t\tctrl_status = readw(&ha->reg->ctrl_status);\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\t\tif ((ctrl_status & CSR_FORCE_SOFT_RESET) == 0) {\n\t\t\t\tstatus = QLA_SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsleep(1000);\n\t\t} while ((--max_wait_time));\n\t}\n\n\treturn status;\n}\n\n \nstatic void qla4xxx_abort_active_cmds(struct scsi_qla_host *ha, int res)\n{\n\tstruct srb *srb;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tfor (i = 0; i < ha->host->can_queue; i++) {\n\t\tsrb = qla4xxx_del_from_active_array(ha, i);\n\t\tif (srb != NULL) {\n\t\t\tsrb->cmd->result = res;\n\t\t\tkref_put(&srb->srb_ref, qla4xxx_srb_compl);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n}\n\nvoid qla4xxx_dead_adapter_cleanup(struct scsi_qla_host *ha)\n{\n\tclear_bit(AF_ONLINE, &ha->flags);\n\n\t \n\tql4_printk(KERN_INFO, ha, \"Disabling the board\\n\");\n\n\tqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\n\tqla4xxx_mark_all_devices_missing(ha);\n\tclear_bit(AF_INIT_DONE, &ha->flags);\n}\n\nstatic void qla4xxx_fail_session(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tddb_entry->fw_ddb_device_state = DDB_DS_SESSION_FAILED;\n\n\tif (ddb_entry->ddb_type == FLASH_DDB)\n\t\tiscsi_block_session(ddb_entry->sess);\n\telse\n\t\tiscsi_session_failure(cls_session->dd_data,\n\t\t\t\t      ISCSI_ERR_CONN_FAILED);\n}\n\n \nstatic int qla4xxx_recover_adapter(struct scsi_qla_host *ha)\n{\n\tint status = QLA_ERROR;\n\tuint8_t reset_chip = 0;\n\tuint32_t dev_state;\n\tunsigned long wait;\n\n\t \n\tscsi_block_requests(ha->host);\n\tclear_bit(AF_ONLINE, &ha->flags);\n\tclear_bit(AF_LINK_UP, &ha->flags);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: adapter OFFLINE\\n\", __func__));\n\n\tset_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\n\n\tif ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t    !test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags)) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: disabling pause transmit on port 0 & 1.\\n\",\n\t\t\t   __func__);\n\t\t \n\t\tqla4_83xx_disable_pause(ha);\n\t}\n\n\tiscsi_host_for_each_session(ha->host, qla4xxx_fail_session);\n\n\tif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\n\t\treset_chip = 1;\n\n\t \n\tif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\n\t\tstatus = QLA_SUCCESS;\n\t\tgoto recover_ha_init_adapter;\n\t}\n\n\t \n\tif (is_qla80XX(ha) && !reset_chip &&\n\t    test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags)) {\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t    \"scsi%ld: %s - Performing stop_firmware...\\n\",\n\t\t    ha->host_no, __func__));\n\t\tstatus = ha->isp_ops->reset_firmware(ha);\n\t\tif (status == QLA_SUCCESS) {\n\t\t\tha->isp_ops->disable_intrs(ha);\n\t\t\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\t\t\tqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\n\t\t} else {\n\t\t\t \n\t\t\treset_chip = 1;\n\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t}\n\t}\n\n\t \n\tif (is_qla40XX(ha) || reset_chip) {\n\t\tif (is_qla40XX(ha))\n\t\t\tgoto chip_reset;\n\n\t\t \n\t\tif (test_bit(AF_FW_RECOVERY, &ha->flags))\n\t\t\tgoto chip_reset;\n\n\t\twait = jiffies + (FW_ALIVE_WAIT_TOV * HZ);\n\t\twhile (time_before(jiffies, wait)) {\n\t\t\tif (qla4_8xxx_check_fw_alive(ha)) {\n\t\t\t\tqla4xxx_mailbox_premature_completion(ha);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_timeout(HZ);\n\t\t}\nchip_reset:\n\t\tif (!test_bit(AF_FW_RECOVERY, &ha->flags))\n\t\t\tqla4xxx_cmd_wait(ha);\n\n\t\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t    \"scsi%ld: %s - Performing chip reset..\\n\",\n\t\t    ha->host_no, __func__));\n\t\tstatus = ha->isp_ops->reset_chip(ha);\n\t\tqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\n\t}\n\n\t \n\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\nrecover_ha_init_adapter:\n\t \n\tif (status == QLA_SUCCESS) {\n\t\t \n\t\tif (is_qla40XX(ha) && (ha->mac_index == 3))\n\t\t\tssleep(6);\n\n\t\t \n\t\tstatus = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\n\t\tif (is_qla80XX(ha) && (status == QLA_ERROR)) {\n\t\t\tstatus = qla4_8xxx_check_init_adapter_retry(ha);\n\t\t\tif (status == QLA_ERROR) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: Don't retry recover adapter\\n\",\n\t\t\t\t\t   ha->host_no, __func__);\n\t\t\t\tqla4xxx_dead_adapter_cleanup(ha);\n\t\t\t\tclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t  &ha->dpc_flags);\n\t\t\t\tgoto exit_recover;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!test_bit(AF_ONLINE, &ha->flags) &&\n\t    !test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\n\t\t \n\t\tif (is_qla80XX(ha)) {\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tdev_state = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t\tQLA8XXX_CRB_DEV_STATE);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tif (dev_state == QLA8XXX_DEV_FAILED) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: don't retry \"\n\t\t\t\t\t   \"recover adapter. H/W is in Failed \"\n\t\t\t\t\t   \"state\\n\", __func__);\n\t\t\t\tqla4xxx_dead_adapter_cleanup(ha);\n\t\t\t\tclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t\t&ha->dpc_flags);\n\t\t\t\tstatus = QLA_ERROR;\n\n\t\t\t\tgoto exit_recover;\n\t\t\t}\n\t\t}\n\n\t\tif (!test_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags)) {\n\t\t\tha->retry_reset_ha_cnt = MAX_RESET_HA_RETRIES;\n\t\t\tDEBUG2(printk(\"scsi%ld: recover adapter - retrying \"\n\t\t\t\t      \"(%d) more times\\n\", ha->host_no,\n\t\t\t\t      ha->retry_reset_ha_cnt));\n\t\t\tset_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t\t\tstatus = QLA_ERROR;\n\t\t} else {\n\t\t\tif (ha->retry_reset_ha_cnt > 0) {\n\t\t\t\t \n\t\t\t\tha->retry_reset_ha_cnt--;\n\t\t\t\tDEBUG2(printk(\"scsi%ld: recover adapter - \"\n\t\t\t\t\t      \"retry remaining %d\\n\",\n\t\t\t\t\t      ha->host_no,\n\t\t\t\t\t      ha->retry_reset_ha_cnt));\n\t\t\t\tstatus = QLA_ERROR;\n\t\t\t}\n\n\t\t\tif (ha->retry_reset_ha_cnt == 0) {\n\t\t\t\t \n\t\t\t\tDEBUG2(printk(\"scsi%ld: recover adapter \"\n\t\t\t\t\t      \"failed - board disabled\\n\",\n\t\t\t\t\t      ha->host_no));\n\t\t\t\tqla4xxx_dead_adapter_cleanup(ha);\n\t\t\t\tclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t  &ha->dpc_flags);\n\t\t\t\tstatus = QLA_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\tclear_bit(DPC_RETRY_RESET_HA, &ha->dpc_flags);\n\t}\n\nexit_recover:\n\tha->adapter_error_count++;\n\n\tif (test_bit(AF_ONLINE, &ha->flags))\n\t\tha->isp_ops->enable_intrs(ha);\n\n\tscsi_unblock_requests(ha->host);\n\n\tclear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\n\tDEBUG2(printk(\"scsi%ld: recover adapter: %s\\n\", ha->host_no,\n\t    status == QLA_ERROR ? \"FAILED\" : \"SUCCEEDED\"));\n\n\treturn status;\n}\n\nstatic void qla4xxx_relogin_devices(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tif (!iscsi_is_session_online(cls_session)) {\n\t\tif (ddb_entry->fw_ddb_device_state == DDB_DS_SESSION_ACTIVE) {\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ddb[%d]\"\n\t\t\t\t   \" unblock session\\n\", ha->host_no, __func__,\n\t\t\t\t   ddb_entry->fw_ddb_index);\n\t\t\tiscsi_unblock_session(ddb_entry->sess);\n\t\t} else {\n\t\t\t \n\t\t\tif (ddb_entry->ddb_type == FLASH_DDB) {\n\t\t\t\tif (!(test_bit(DF_RELOGIN, &ddb_entry->flags) ||\n\t\t\t\t      test_bit(DF_DISABLE_RELOGIN,\n\t\t\t\t\t       &ddb_entry->flags)))\n\t\t\t\t\tqla4xxx_arm_relogin_timer(ddb_entry);\n\t\t\t} else\n\t\t\t\tiscsi_session_failure(cls_session->dd_data,\n\t\t\t\t\t\t      ISCSI_ERR_CONN_FAILED);\n\t\t}\n\t}\n}\n\nint qla4xxx_unblock_flash_ddb(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ddb[%d]\"\n\t\t   \" unblock session\\n\", ha->host_no, __func__,\n\t\t   ddb_entry->fw_ddb_index);\n\n\tiscsi_unblock_session(ddb_entry->sess);\n\n\t \n\tif (test_bit(AF_ONLINE, &ha->flags)) {\n\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ddb[%d]\"\n\t\t\t   \" start scan\\n\", ha->host_no, __func__,\n\t\t\t   ddb_entry->fw_ddb_index);\n\t\tqueue_work(ddb_entry->sess->workq, &ddb_entry->sess->scan_work);\n\t}\n\treturn QLA_SUCCESS;\n}\n\nint qla4xxx_unblock_ddb(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tint status = QLA_SUCCESS;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: ddb[%d]\"\n\t\t   \" unblock user space session\\n\", ha->host_no, __func__,\n\t\t   ddb_entry->fw_ddb_index);\n\n\tif (!iscsi_is_session_online(cls_session)) {\n\t\tiscsi_conn_start(ddb_entry->conn);\n\t\tiscsi_conn_login_event(ddb_entry->conn,\n\t\t\t\t       ISCSI_CONN_STATE_LOGGED_IN);\n\t} else {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"scsi%ld: %s: ddb[%d] session [%d] already logged in\\n\",\n\t\t\t   ha->host_no, __func__, ddb_entry->fw_ddb_index,\n\t\t\t   cls_session->sid);\n\t\tstatus = QLA_ERROR;\n\t}\n\n\treturn status;\n}\n\nstatic void qla4xxx_relogin_all_devices(struct scsi_qla_host *ha)\n{\n\tiscsi_host_for_each_session(ha->host, qla4xxx_relogin_devices);\n}\n\nstatic void qla4xxx_relogin_flash_ddb(struct iscsi_cls_session *cls_sess)\n{\n\tuint16_t relogin_timer;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\trelogin_timer = max(ddb_entry->default_relogin_timeout,\n\t\t\t    (uint16_t)RELOGIN_TOV);\n\tatomic_set(&ddb_entry->relogin_timer, relogin_timer);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"scsi%ld: Relogin index [%d]. TOV=%d\\n\", ha->host_no,\n\t\t\t  ddb_entry->fw_ddb_index, relogin_timer));\n\n\tqla4xxx_login_flash_ddb(cls_sess);\n}\n\nstatic void qla4xxx_dpc_relogin(struct iscsi_cls_session *cls_sess)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tif (!(ddb_entry->ddb_type == FLASH_DDB))\n\t\treturn;\n\n\tif (test_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags))\n\t\treturn;\n\n\tif (test_and_clear_bit(DF_RELOGIN, &ddb_entry->flags) &&\n\t    !iscsi_is_session_online(cls_sess)) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"relogin issued\\n\"));\n\t\tqla4xxx_relogin_flash_ddb(cls_sess);\n\t}\n}\n\nvoid qla4xxx_wake_dpc(struct scsi_qla_host *ha)\n{\n\tif (ha->dpc_thread)\n\t\tqueue_work(ha->dpc_thread, &ha->dpc_work);\n}\n\nstatic struct qla4_work_evt *\nqla4xxx_alloc_work(struct scsi_qla_host *ha, uint32_t data_size,\n\t\t   enum qla4_work_type type)\n{\n\tstruct qla4_work_evt *e;\n\tuint32_t size = sizeof(struct qla4_work_evt) + data_size;\n\n\te = kzalloc(size, GFP_ATOMIC);\n\tif (!e)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&e->list);\n\te->type = type;\n\treturn e;\n}\n\nstatic void qla4xxx_post_work(struct scsi_qla_host *ha,\n\t\t\t     struct qla4_work_evt *e)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ha->work_lock, flags);\n\tlist_add_tail(&e->list, &ha->work_list);\n\tspin_unlock_irqrestore(&ha->work_lock, flags);\n\tqla4xxx_wake_dpc(ha);\n}\n\nint qla4xxx_post_aen_work(struct scsi_qla_host *ha,\n\t\t\t  enum iscsi_host_event_code aen_code,\n\t\t\t  uint32_t data_size, uint8_t *data)\n{\n\tstruct qla4_work_evt *e;\n\n\te = qla4xxx_alloc_work(ha, data_size, QLA4_EVENT_AEN);\n\tif (!e)\n\t\treturn QLA_ERROR;\n\n\te->u.aen.code = aen_code;\n\te->u.aen.data_size = data_size;\n\tmemcpy(e->u.aen.data, data, data_size);\n\n\tqla4xxx_post_work(ha, e);\n\n\treturn QLA_SUCCESS;\n}\n\nint qla4xxx_post_ping_evt_work(struct scsi_qla_host *ha,\n\t\t\t       uint32_t status, uint32_t pid,\n\t\t\t       uint32_t data_size, uint8_t *data)\n{\n\tstruct qla4_work_evt *e;\n\n\te = qla4xxx_alloc_work(ha, data_size, QLA4_EVENT_PING_STATUS);\n\tif (!e)\n\t\treturn QLA_ERROR;\n\n\te->u.ping.status = status;\n\te->u.ping.pid = pid;\n\te->u.ping.data_size = data_size;\n\tmemcpy(e->u.ping.data, data, data_size);\n\n\tqla4xxx_post_work(ha, e);\n\n\treturn QLA_SUCCESS;\n}\n\nstatic void qla4xxx_do_work(struct scsi_qla_host *ha)\n{\n\tstruct qla4_work_evt *e, *tmp;\n\tunsigned long flags;\n\tLIST_HEAD(work);\n\n\tspin_lock_irqsave(&ha->work_lock, flags);\n\tlist_splice_init(&ha->work_list, &work);\n\tspin_unlock_irqrestore(&ha->work_lock, flags);\n\n\tlist_for_each_entry_safe(e, tmp, &work, list) {\n\t\tlist_del_init(&e->list);\n\n\t\tswitch (e->type) {\n\t\tcase QLA4_EVENT_AEN:\n\t\t\tiscsi_post_host_event(ha->host_no,\n\t\t\t\t\t      &qla4xxx_iscsi_transport,\n\t\t\t\t\t      e->u.aen.code,\n\t\t\t\t\t      e->u.aen.data_size,\n\t\t\t\t\t      e->u.aen.data);\n\t\t\tbreak;\n\t\tcase QLA4_EVENT_PING_STATUS:\n\t\t\tiscsi_ping_comp_event(ha->host_no,\n\t\t\t\t\t      &qla4xxx_iscsi_transport,\n\t\t\t\t\t      e->u.ping.status,\n\t\t\t\t\t      e->u.ping.pid,\n\t\t\t\t\t      e->u.ping.data_size,\n\t\t\t\t\t      e->u.ping.data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql4_printk(KERN_WARNING, ha, \"event type: 0x%x not \"\n\t\t\t\t   \"supported\", e->type);\n\t\t}\n\t\tkfree(e);\n\t}\n}\n\n \nstatic void qla4xxx_do_dpc(struct work_struct *work)\n{\n\tstruct scsi_qla_host *ha =\n\t\tcontainer_of(work, struct scsi_qla_host, dpc_work);\n\tint status = QLA_ERROR;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"scsi%ld: %s: DPC handler waking up. flags = 0x%08lx, dpc_flags = 0x%08lx\\n\",\n\t\t\t  ha->host_no, __func__, ha->flags, ha->dpc_flags));\n\n\t \n\tif (!test_bit(AF_INIT_DONE, &ha->flags))\n\t\treturn;\n\n\tif (test_bit(AF_EEH_BUSY, &ha->flags)) {\n\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: flags = %lx\\n\",\n\t\t    ha->host_no, __func__, ha->flags));\n\t\treturn;\n\t}\n\n\t \n\tqla4xxx_do_work(ha);\n\n\tif (is_qla80XX(ha)) {\n\t\tif (test_bit(DPC_HA_UNRECOVERABLE, &ha->dpc_flags)) {\n\t\t\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: disabling pause transmit on port 0 & 1.\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\t \n\t\t\t\tqla4_83xx_disable_pause(ha);\n\t\t\t}\n\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tql4_printk(KERN_INFO, ha, \"HW State: FAILED\\n\");\n\t\t\tqla4_8xxx_device_state_handler(ha);\n\t\t}\n\n\t\tif (test_bit(DPC_POST_IDC_ACK, &ha->dpc_flags)) {\n\t\t\tif (is_qla8042(ha)) {\n\t\t\t\tif (ha->idc_info.info2 &\n\t\t\t\t    ENABLE_INTERNAL_LOOPBACK) {\n\t\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: Disabling ACB\\n\",\n\t\t\t\t\t\t   __func__);\n\t\t\t\t\tstatus = qla4_84xx_config_acb(ha,\n\t\t\t\t\t\t\t    ACB_CONFIG_DISABLE);\n\t\t\t\t\tif (status != QLA_SUCCESS) {\n\t\t\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: ACB config failed\\n\",\n\t\t\t\t\t\t\t   __func__);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tqla4_83xx_post_idc_ack(ha);\n\t\t\tclear_bit(DPC_POST_IDC_ACK, &ha->dpc_flags);\n\t\t}\n\n\t\tif (is_qla8042(ha) &&\n\t\t    test_bit(DPC_RESTORE_ACB, &ha->dpc_flags)) {\n\t\t\tql4_printk(KERN_INFO, ha, \"%s: Restoring ACB\\n\",\n\t\t\t\t   __func__);\n\t\t\tif (qla4_84xx_config_acb(ha, ACB_CONFIG_SET) !=\n\t\t\t    QLA_SUCCESS) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"%s: ACB config failed \",\n\t\t\t\t\t   __func__);\n\t\t\t}\n\t\t\tclear_bit(DPC_RESTORE_ACB, &ha->dpc_flags);\n\t\t}\n\n\t\tif (test_and_clear_bit(DPC_HA_NEED_QUIESCENT, &ha->dpc_flags)) {\n\t\t\tqla4_8xxx_need_qsnt_handler(ha);\n\t\t}\n\t}\n\n\tif (!test_bit(DPC_RESET_ACTIVE, &ha->dpc_flags) &&\n\t    (test_bit(DPC_RESET_HA, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags) ||\n\t    test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags))) {\n\t\tif ((is_qla8022(ha) && ql4xdontresethba) ||\n\t\t    ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t\t     qla4_83xx_idc_dontreset(ha))) {\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: Don't Reset HBA\\n\",\n\t\t\t    ha->host_no, __func__));\n\t\t\tclear_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\t\tclear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\n\t\t\tclear_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\t\tgoto dpc_post_reset_ha;\n\t\t}\n\t\tif (test_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags) ||\n\t\t    test_bit(DPC_RESET_HA, &ha->dpc_flags))\n\t\t\tqla4xxx_recover_adapter(ha);\n\n\t\tif (test_bit(DPC_RESET_HA_INTR, &ha->dpc_flags)) {\n\t\t\tuint8_t wait_time = RESET_INTR_TOV;\n\n\t\t\twhile ((readw(&ha->reg->ctrl_status) &\n\t\t\t\t(CSR_SOFT_RESET | CSR_FORCE_SOFT_RESET)) != 0) {\n\t\t\t\tif (--wait_time == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(1000);\n\t\t\t}\n\t\t\tif (wait_time == 0)\n\t\t\t\tDEBUG2(printk(\"scsi%ld: %s: SR|FSR \"\n\t\t\t\t\t      \"bit not cleared-- resetting\\n\",\n\t\t\t\t\t      ha->host_no, __func__));\n\t\t\tqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\n\t\t\tif (ql4xxx_lock_drvr_wait(ha) == QLA_SUCCESS) {\n\t\t\t\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\t\t\t\tstatus = qla4xxx_recover_adapter(ha);\n\t\t\t}\n\t\t\tclear_bit(DPC_RESET_HA_INTR, &ha->dpc_flags);\n\t\t\tif (status == QLA_SUCCESS)\n\t\t\t\tha->isp_ops->enable_intrs(ha);\n\t\t}\n\t}\n\ndpc_post_reset_ha:\n\t \n\tif (test_and_clear_bit(DPC_AEN, &ha->dpc_flags))\n\t\tqla4xxx_process_aen(ha, PROCESS_ALL_AENS);\n\n\t \n\tif (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))\n\t\tqla4xxx_get_dhcp_ip_address(ha);\n\n\t \n\tif (adapter_up(ha) &&\n\t    test_and_clear_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags)) {\n\t\tiscsi_host_for_each_session(ha->host, qla4xxx_dpc_relogin);\n\t}\n\n\t \n\tif (!test_bit(AF_LOOPBACK, &ha->flags) &&\n\t    test_and_clear_bit(DPC_LINK_CHANGED, &ha->dpc_flags)) {\n\t\tif (!test_bit(AF_LINK_UP, &ha->flags)) {\n\t\t\t \n\t\t\tqla4xxx_mark_all_devices_missing(ha);\n\t\t} else {\n\t\t\t \n\t\t\tif (test_and_clear_bit(AF_BUILD_DDB_LIST, &ha->flags)) {\n\t\t\t\tqla4xxx_build_ddb_list(ha, ha->is_reset);\n\t\t\t\tiscsi_host_for_each_session(ha->host,\n\t\t\t\t\t\tqla4xxx_login_flash_ddb);\n\t\t\t} else\n\t\t\t\tqla4xxx_relogin_all_devices(ha);\n\t\t}\n\t}\n\tif (test_and_clear_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags)) {\n\t\tif (qla4xxx_sysfs_ddb_export(ha))\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Error exporting ddb to sysfs\\n\",\n\t\t\t\t   __func__);\n\t}\n}\n\n \nstatic void qla4xxx_free_adapter(struct scsi_qla_host *ha)\n{\n\tqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\n\n\t \n\tha->isp_ops->disable_intrs(ha);\n\n\tif (is_qla40XX(ha)) {\n\t\twritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\n\t\t       &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t} else if (is_qla8022(ha)) {\n\t\twritel(0, &ha->qla4_82xx_reg->host_int);\n\t\treadl(&ha->qla4_82xx_reg->host_int);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\twritel(0, &ha->qla4_83xx_reg->risc_intr);\n\t\treadl(&ha->qla4_83xx_reg->risc_intr);\n\t}\n\n\t \n\tif (ha->timer_active)\n\t\tqla4xxx_stop_timer(ha);\n\n\t \n\tif (ha->dpc_thread)\n\t\tdestroy_workqueue(ha->dpc_thread);\n\n\t \n\tif (ha->task_wq)\n\t\tdestroy_workqueue(ha->task_wq);\n\n\t \n\tha->isp_ops->reset_firmware(ha);\n\n\tif (is_qla80XX(ha)) {\n\t\tha->isp_ops->idc_lock(ha);\n\t\tqla4_8xxx_clear_drv_active(ha);\n\t\tha->isp_ops->idc_unlock(ha);\n\t}\n\n\t \n\tqla4xxx_free_irqs(ha);\n\n\t \n\tqla4xxx_mem_free(ha);\n}\n\nint qla4_8xxx_iospace_config(struct scsi_qla_host *ha)\n{\n\tint status = 0;\n\tunsigned long mem_base, mem_len;\n\tstruct pci_dev *pdev = ha->pdev;\n\n\tstatus = pci_request_regions(pdev, DRIVER_NAME);\n\tif (status) {\n\t\tprintk(KERN_WARNING\n\t\t    \"scsi(%ld) Failed to reserve PIO regions (%s) \"\n\t\t    \"status=%d\\n\", ha->host_no, pci_name(pdev), status);\n\t\tgoto iospace_error_exit;\n\t}\n\n\tDEBUG2(printk(KERN_INFO \"%s: revision-id=%d\\n\",\n\t    __func__, pdev->revision));\n\tha->revision_id = pdev->revision;\n\n\t \n\tmem_base = pci_resource_start(pdev, 0);  \n\tmem_len = pci_resource_len(pdev, 0);\n\tDEBUG2(printk(KERN_INFO \"%s: ioremap from %lx a size of %lx\\n\",\n\t    __func__, mem_base, mem_len));\n\n\t \n\tha->nx_pcibase = (unsigned long)ioremap(mem_base, mem_len);\n\tif (!ha->nx_pcibase) {\n\t\tprintk(KERN_ERR\n\t\t    \"cannot remap MMIO (%s), aborting\\n\", pci_name(pdev));\n\t\tpci_release_regions(ha->pdev);\n\t\tgoto iospace_error_exit;\n\t}\n\n\t \n\n\t \n\tif (is_qla8022(ha)) {\n\t\tha->qla4_82xx_reg = (struct device_reg_82xx  __iomem *)\n\t\t\t\t    ((uint8_t *)ha->nx_pcibase + 0xbc000 +\n\t\t\t\t     (ha->pdev->devfn << 11));\n\t\tha->nx_db_wr_ptr = (ha->pdev->devfn == 4 ? QLA82XX_CAM_RAM_DB1 :\n\t\t\t\t    QLA82XX_CAM_RAM_DB2);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tha->qla4_83xx_reg = (struct device_reg_83xx __iomem *)\n\t\t\t\t    ((uint8_t *)ha->nx_pcibase);\n\t}\n\n\treturn 0;\niospace_error_exit:\n\treturn -ENOMEM;\n}\n\n \nint qla4xxx_iospace_config(struct scsi_qla_host *ha)\n{\n\tunsigned long pio, pio_len, pio_flags;\n\tunsigned long mmio, mmio_len, mmio_flags;\n\n\tpio = pci_resource_start(ha->pdev, 0);\n\tpio_len = pci_resource_len(ha->pdev, 0);\n\tpio_flags = pci_resource_flags(ha->pdev, 0);\n\tif (pio_flags & IORESOURCE_IO) {\n\t\tif (pio_len < MIN_IOBASE_LEN) {\n\t\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t\t\"Invalid PCI I/O region size\\n\");\n\t\t\tpio = 0;\n\t\t}\n\t} else {\n\t\tql4_printk(KERN_WARNING, ha, \"region #0 not a PIO resource\\n\");\n\t\tpio = 0;\n\t}\n\n\t \n\tmmio = pci_resource_start(ha->pdev, 1);\n\tmmio_len = pci_resource_len(ha->pdev, 1);\n\tmmio_flags = pci_resource_flags(ha->pdev, 1);\n\n\tif (!(mmio_flags & IORESOURCE_MEM)) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t    \"region #0 not an MMIO resource, aborting\\n\");\n\n\t\tgoto iospace_error_exit;\n\t}\n\n\tif (mmio_len < MIN_IOBASE_LEN) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t    \"Invalid PCI mem region size, aborting\\n\");\n\t\tgoto iospace_error_exit;\n\t}\n\n\tif (pci_request_regions(ha->pdev, DRIVER_NAME)) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"Failed to reserve PIO/MMIO regions\\n\");\n\n\t\tgoto iospace_error_exit;\n\t}\n\n\tha->pio_address = pio;\n\tha->pio_length = pio_len;\n\tha->reg = ioremap(mmio, MIN_IOBASE_LEN);\n\tif (!ha->reg) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t    \"cannot remap MMIO, aborting\\n\");\n\n\t\tgoto iospace_error_exit;\n\t}\n\n\treturn 0;\n\niospace_error_exit:\n\treturn -ENOMEM;\n}\n\nstatic struct isp_operations qla4xxx_isp_ops = {\n\t.iospace_config         = qla4xxx_iospace_config,\n\t.pci_config             = qla4xxx_pci_config,\n\t.disable_intrs          = qla4xxx_disable_intrs,\n\t.enable_intrs           = qla4xxx_enable_intrs,\n\t.start_firmware         = qla4xxx_start_firmware,\n\t.intr_handler           = qla4xxx_intr_handler,\n\t.interrupt_service_routine = qla4xxx_interrupt_service_routine,\n\t.reset_chip             = qla4xxx_soft_reset,\n\t.reset_firmware         = qla4xxx_hw_reset,\n\t.queue_iocb             = qla4xxx_queue_iocb,\n\t.complete_iocb          = qla4xxx_complete_iocb,\n\t.rd_shdw_req_q_out      = qla4xxx_rd_shdw_req_q_out,\n\t.rd_shdw_rsp_q_in       = qla4xxx_rd_shdw_rsp_q_in,\n\t.get_sys_info           = qla4xxx_get_sys_info,\n\t.queue_mailbox_command\t= qla4xxx_queue_mbox_cmd,\n\t.process_mailbox_interrupt = qla4xxx_process_mbox_intr,\n};\n\nstatic struct isp_operations qla4_82xx_isp_ops = {\n\t.iospace_config         = qla4_8xxx_iospace_config,\n\t.pci_config             = qla4_8xxx_pci_config,\n\t.disable_intrs          = qla4_82xx_disable_intrs,\n\t.enable_intrs           = qla4_82xx_enable_intrs,\n\t.start_firmware         = qla4_8xxx_load_risc,\n\t.restart_firmware\t= qla4_82xx_try_start_fw,\n\t.intr_handler           = qla4_82xx_intr_handler,\n\t.interrupt_service_routine = qla4_82xx_interrupt_service_routine,\n\t.need_reset\t\t= qla4_8xxx_need_reset,\n\t.reset_chip             = qla4_82xx_isp_reset,\n\t.reset_firmware         = qla4_8xxx_stop_firmware,\n\t.queue_iocb             = qla4_82xx_queue_iocb,\n\t.complete_iocb          = qla4_82xx_complete_iocb,\n\t.rd_shdw_req_q_out      = qla4_82xx_rd_shdw_req_q_out,\n\t.rd_shdw_rsp_q_in       = qla4_82xx_rd_shdw_rsp_q_in,\n\t.get_sys_info           = qla4_8xxx_get_sys_info,\n\t.rd_reg_direct\t\t= qla4_82xx_rd_32,\n\t.wr_reg_direct\t\t= qla4_82xx_wr_32,\n\t.rd_reg_indirect\t= qla4_82xx_md_rd_32,\n\t.wr_reg_indirect\t= qla4_82xx_md_wr_32,\n\t.idc_lock\t\t= qla4_82xx_idc_lock,\n\t.idc_unlock\t\t= qla4_82xx_idc_unlock,\n\t.rom_lock_recovery\t= qla4_82xx_rom_lock_recovery,\n\t.queue_mailbox_command\t= qla4_82xx_queue_mbox_cmd,\n\t.process_mailbox_interrupt = qla4_82xx_process_mbox_intr,\n};\n\nstatic struct isp_operations qla4_83xx_isp_ops = {\n\t.iospace_config\t\t= qla4_8xxx_iospace_config,\n\t.pci_config\t\t= qla4_8xxx_pci_config,\n\t.disable_intrs\t\t= qla4_83xx_disable_intrs,\n\t.enable_intrs\t\t= qla4_83xx_enable_intrs,\n\t.start_firmware\t\t= qla4_8xxx_load_risc,\n\t.restart_firmware\t= qla4_83xx_start_firmware,\n\t.intr_handler\t\t= qla4_83xx_intr_handler,\n\t.interrupt_service_routine = qla4_83xx_interrupt_service_routine,\n\t.need_reset\t\t= qla4_8xxx_need_reset,\n\t.reset_chip\t\t= qla4_83xx_isp_reset,\n\t.reset_firmware\t\t= qla4_8xxx_stop_firmware,\n\t.queue_iocb\t\t= qla4_83xx_queue_iocb,\n\t.complete_iocb\t\t= qla4_83xx_complete_iocb,\n\t.rd_shdw_req_q_out\t= qla4xxx_rd_shdw_req_q_out,\n\t.rd_shdw_rsp_q_in\t= qla4xxx_rd_shdw_rsp_q_in,\n\t.get_sys_info\t\t= qla4_8xxx_get_sys_info,\n\t.rd_reg_direct\t\t= qla4_83xx_rd_reg,\n\t.wr_reg_direct\t\t= qla4_83xx_wr_reg,\n\t.rd_reg_indirect\t= qla4_83xx_rd_reg_indirect,\n\t.wr_reg_indirect\t= qla4_83xx_wr_reg_indirect,\n\t.idc_lock\t\t= qla4_83xx_drv_lock,\n\t.idc_unlock\t\t= qla4_83xx_drv_unlock,\n\t.rom_lock_recovery\t= qla4_83xx_rom_lock_recovery,\n\t.queue_mailbox_command\t= qla4_83xx_queue_mbox_cmd,\n\t.process_mailbox_interrupt = qla4_83xx_process_mbox_intr,\n};\n\nuint16_t qla4xxx_rd_shdw_req_q_out(struct scsi_qla_host *ha)\n{\n\treturn (uint16_t)le32_to_cpu(ha->shadow_regs->req_q_out);\n}\n\nuint16_t qla4_82xx_rd_shdw_req_q_out(struct scsi_qla_host *ha)\n{\n\treturn (uint16_t)le32_to_cpu(readl(&ha->qla4_82xx_reg->req_q_out));\n}\n\nuint16_t qla4xxx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)\n{\n\treturn (uint16_t)le32_to_cpu(ha->shadow_regs->rsp_q_in);\n}\n\nuint16_t qla4_82xx_rd_shdw_rsp_q_in(struct scsi_qla_host *ha)\n{\n\treturn (uint16_t)le32_to_cpu(readl(&ha->qla4_82xx_reg->rsp_q_in));\n}\n\nstatic ssize_t qla4xxx_show_boot_eth_info(void *data, int type, char *buf)\n{\n\tstruct scsi_qla_host *ha = data;\n\tchar *str = buf;\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\t\trc = sprintf(str, \"%d\\n\", (char)SYSFS_FLAG_FW_SEL_BOOT);\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_INDEX:\n\t\trc = sprintf(str, \"0\\n\");\n\t\tbreak;\n\tcase ISCSI_BOOT_ETH_MAC:\n\t\trc = sysfs_format_mac(str, ha->my_mac,\n\t\t\t\t      MAC_ADDR_LEN);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic umode_t qla4xxx_eth_get_attr_visibility(void *data, int type)\n{\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_ETH_FLAGS:\n\tcase ISCSI_BOOT_ETH_MAC:\n\tcase ISCSI_BOOT_ETH_INDEX:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t qla4xxx_show_boot_ini_info(void *data, int type, char *buf)\n{\n\tstruct scsi_qla_host *ha = data;\n\tchar *str = buf;\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\trc = sprintf(str, \"%s\\n\", ha->name_string);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic umode_t qla4xxx_ini_get_attr_visibility(void *data, int type)\n{\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_INI_INITIATOR_NAME:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t\nqla4xxx_show_boot_tgt_info(struct ql4_boot_session_info *boot_sess, int type,\n\t\t\t   char *buf)\n{\n\tstruct ql4_conn_info *boot_conn = &boot_sess->conn_list[0];\n\tchar *str = buf;\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_NAME:\n\t\trc = sprintf(buf, \"%s\\n\", (char *)&boot_sess->target_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\t\tif (boot_sess->conn_list[0].dest_ipaddr.ip_type == 0x1)\n\t\t\trc = sprintf(buf, \"%pI4\\n\",\n\t\t\t\t     &boot_conn->dest_ipaddr.ip_address);\n\t\telse\n\t\t\trc = sprintf(str, \"%pI6\\n\",\n\t\t\t\t     &boot_conn->dest_ipaddr.ip_address);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_PORT:\n\t\t\trc = sprintf(str, \"%d\\n\", boot_conn->dest_port);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->chap.target_chap_name_length,\n\t\t\t     (char *)&boot_conn->chap.target_chap_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->chap.target_secret_length,\n\t\t\t     (char *)&boot_conn->chap.target_secret);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->chap.intr_chap_name_length,\n\t\t\t     (char *)&boot_conn->chap.intr_chap_name);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\t\trc = sprintf(str,  \"%.*s\\n\",\n\t\t\t     boot_conn->chap.intr_secret_length,\n\t\t\t     (char *)&boot_conn->chap.intr_secret);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\trc = sprintf(str, \"%d\\n\", (char)SYSFS_FLAG_FW_SEL_BOOT);\n\t\tbreak;\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\t\trc = sprintf(str, \"0\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic ssize_t qla4xxx_show_boot_tgt_pri_info(void *data, int type, char *buf)\n{\n\tstruct scsi_qla_host *ha = data;\n\tstruct ql4_boot_session_info *boot_sess = &(ha->boot_tgt.boot_pri_sess);\n\n\treturn qla4xxx_show_boot_tgt_info(boot_sess, type, buf);\n}\n\nstatic ssize_t qla4xxx_show_boot_tgt_sec_info(void *data, int type, char *buf)\n{\n\tstruct scsi_qla_host *ha = data;\n\tstruct ql4_boot_session_info *boot_sess = &(ha->boot_tgt.boot_sec_sess);\n\n\treturn qla4xxx_show_boot_tgt_info(boot_sess, type, buf);\n}\n\nstatic umode_t qla4xxx_tgt_get_attr_visibility(void *data, int type)\n{\n\tint rc;\n\n\tswitch (type) {\n\tcase ISCSI_BOOT_TGT_NAME:\n\tcase ISCSI_BOOT_TGT_IP_ADDR:\n\tcase ISCSI_BOOT_TGT_PORT:\n\tcase ISCSI_BOOT_TGT_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_CHAP_SECRET:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_NAME:\n\tcase ISCSI_BOOT_TGT_REV_CHAP_SECRET:\n\tcase ISCSI_BOOT_TGT_NIC_ASSOC:\n\tcase ISCSI_BOOT_TGT_FLAGS:\n\t\trc = S_IRUGO;\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic void qla4xxx_boot_release(void *data)\n{\n\tstruct scsi_qla_host *ha = data;\n\n\tscsi_host_put(ha->host);\n}\n\nstatic int get_fw_boot_info(struct scsi_qla_host *ha, uint16_t ddb_index[])\n{\n\tdma_addr_t buf_dma;\n\tuint32_t addr, pri_addr, sec_addr;\n\tuint32_t offset;\n\tuint16_t func_num;\n\tuint8_t val;\n\tuint8_t *buf = NULL;\n\tsize_t size = 13 * sizeof(uint8_t);\n\tint ret = QLA_SUCCESS;\n\n\tfunc_num = PCI_FUNC(ha->pdev->devfn);\n\n\tql4_printk(KERN_INFO, ha, \"%s: Get FW boot info for 0x%x func %d\\n\",\n\t\t   __func__, ha->pdev->device, func_num);\n\n\tif (is_qla40XX(ha)) {\n\t\tif (func_num == 1) {\n\t\t\taddr = NVRAM_PORT0_BOOT_MODE;\n\t\t\tpri_addr = NVRAM_PORT0_BOOT_PRI_TGT;\n\t\t\tsec_addr = NVRAM_PORT0_BOOT_SEC_TGT;\n\t\t} else if (func_num == 3) {\n\t\t\taddr = NVRAM_PORT1_BOOT_MODE;\n\t\t\tpri_addr = NVRAM_PORT1_BOOT_PRI_TGT;\n\t\t\tsec_addr = NVRAM_PORT1_BOOT_SEC_TGT;\n\t\t} else {\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info;\n\t\t}\n\n\t\t \n\t\tval = rd_nvram_byte(ha, addr);\n\t\tif (!(val & 0x07)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Adapter boot \"\n\t\t\t\t\t  \"options : 0x%x\\n\", __func__, val));\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info;\n\t\t}\n\n\t\t \n\t\tval = rd_nvram_byte(ha, pri_addr);\n\t\tif (val & BIT_7)\n\t\t\tddb_index[0] = (val & 0x7f);\n\n\t\t \n\t\tval = rd_nvram_byte(ha, sec_addr);\n\t\tif (val & BIT_7)\n\t\t\tddb_index[1] = (val & 0x7f);\n\t\tgoto exit_boot_info;\n\t} else if (is_qla80XX(ha)) {\n\t\tbuf = dma_alloc_coherent(&ha->pdev->dev, size,\n\t\t\t\t\t &buf_dma, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t\t   __func__));\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info;\n\t\t}\n\n\t\tif (ha->port_num == 0)\n\t\t\toffset = BOOT_PARAM_OFFSET_PORT0;\n\t\telse if (ha->port_num == 1)\n\t\t\toffset = BOOT_PARAM_OFFSET_PORT1;\n\t\telse {\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info_free;\n\t\t}\n\t\taddr = FLASH_RAW_ACCESS_ADDR + (ha->hw.flt_iscsi_param * 4) +\n\t\t       offset;\n\t\tif (qla4xxx_get_flash(ha, buf_dma, addr,\n\t\t\t\t      13 * sizeof(uint8_t)) != QLA_SUCCESS) {\n\t\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"scsi%ld: %s: Get Flash\"\n\t\t\t\t\t  \" failed\\n\", ha->host_no, __func__));\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info_free;\n\t\t}\n\t\t \n\t\tif (!(buf[1] & 0x07)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Firmware boot options\"\n\t\t\t\t\t  \" : 0x%x\\n\", buf[1]));\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_info_free;\n\t\t}\n\n\t\t \n\t\tif (buf[2] & BIT_7)\n\t\t\tddb_index[0] = buf[2] & 0x7f;\n\n\t\t \n\t\tif (buf[11] & BIT_7)\n\t\t\tddb_index[1] = buf[11] & 0x7f;\n\t} else {\n\t\tret = QLA_ERROR;\n\t\tgoto exit_boot_info;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Primary target ID %d, Secondary\"\n\t\t\t  \" target ID %d\\n\", __func__, ddb_index[0],\n\t\t\t  ddb_index[1]));\n\nexit_boot_info_free:\n\tdma_free_coherent(&ha->pdev->dev, size, buf, buf_dma);\nexit_boot_info:\n\tha->pri_ddb_idx = ddb_index[0];\n\tha->sec_ddb_idx = ddb_index[1];\n\treturn ret;\n}\n\n \nstatic int qla4xxx_get_bidi_chap(struct scsi_qla_host *ha, char *username,\n\t\t\t    char *password)\n{\n\tint i, ret = -EINVAL;\n\tint max_chap_entries = 0;\n\tstruct ql4_chap_table *chap_table;\n\n\tif (is_qla80XX(ha))\n\t\tmax_chap_entries = (ha->hw.flt_chap_size / 2) /\n\t\t\t\t\t\tsizeof(struct ql4_chap_table);\n\telse\n\t\tmax_chap_entries = MAX_CHAP_ENTRIES_40XX;\n\n\tif (!ha->chap_list) {\n\t\tql4_printk(KERN_ERR, ha, \"Do not have CHAP table cache\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&ha->chap_sem);\n\tfor (i = 0; i < max_chap_entries; i++) {\n\t\tchap_table = (struct ql4_chap_table *)ha->chap_list + i;\n\t\tif (chap_table->cookie !=\n\t\t    cpu_to_le16(CHAP_VALID_COOKIE)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chap_table->flags & BIT_7)  \n\t\t\tcontinue;\n\n\t\tif (!(chap_table->flags & BIT_6))  \n\t\t\tcontinue;\n\n\t\tstrscpy(password, chap_table->secret, QL4_CHAP_MAX_SECRET_LEN);\n\t\tstrscpy(username, chap_table->name, QL4_CHAP_MAX_NAME_LEN);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ha->chap_sem);\n\n\treturn ret;\n}\n\n\nstatic int qla4xxx_get_boot_target(struct scsi_qla_host *ha,\n\t\t\t\t   struct ql4_boot_session_info *boot_sess,\n\t\t\t\t   uint16_t ddb_index)\n{\n\tstruct ql4_conn_info *boot_conn = &boot_sess->conn_list[0];\n\tstruct dev_db_entry *fw_ddb_entry;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint16_t idx;\n\tuint16_t options;\n\tint ret = QLA_SUCCESS;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer.\\n\",\n\t\t\t\t  __func__));\n\t\tret = QLA_ERROR;\n\t\treturn ret;\n\t}\n\n\tif (qla4xxx_bootdb_by_index(ha, fw_ddb_entry,\n\t\t\t\t   fw_ddb_entry_dma, ddb_index)) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: No Flash DDB found at \"\n\t\t\t\t  \"index [%d]\\n\", __func__, ddb_index));\n\t\tret = QLA_ERROR;\n\t\tgoto exit_boot_target;\n\t}\n\n\t \n\tmemcpy(boot_sess->target_name, fw_ddb_entry->iscsi_name,\n\t       min(sizeof(boot_sess->target_name),\n\t\t   sizeof(fw_ddb_entry->iscsi_name)));\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE) {\n\t\tmemcpy(&boot_conn->dest_ipaddr.ip_address,\n\t\t       &fw_ddb_entry->ip_addr[0], IPv6_ADDR_LEN);\n\t} else {\n\t\tboot_conn->dest_ipaddr.ip_type = 0x1;\n\t\tmemcpy(&boot_conn->dest_ipaddr.ip_address,\n\t\t       &fw_ddb_entry->ip_addr[0], IP_ADDR_LEN);\n\t}\n\n\tboot_conn->dest_port = le16_to_cpu(fw_ddb_entry->port);\n\n\t \n\tidx = __le16_to_cpu(fw_ddb_entry->chap_tbl_idx);\n\n\tif (BIT_7 & le16_to_cpu(fw_ddb_entry->iscsi_options))\t{\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Setting chap\\n\"));\n\n\t\tret = qla4xxx_get_chap(ha, (char *)&boot_conn->chap.\n\t\t\t\t       target_chap_name,\n\t\t\t\t       (char *)&boot_conn->chap.target_secret,\n\t\t\t\t       idx);\n\t\tif (ret) {\n\t\t\tql4_printk(KERN_ERR, ha, \"Failed to set chap\\n\");\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_target;\n\t\t}\n\n\t\tboot_conn->chap.target_chap_name_length = QL4_CHAP_MAX_NAME_LEN;\n\t\tboot_conn->chap.target_secret_length = QL4_CHAP_MAX_SECRET_LEN;\n\t}\n\n\tif (BIT_4 & le16_to_cpu(fw_ddb_entry->iscsi_options)) {\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Setting BIDI chap\\n\"));\n\n\t\tret = qla4xxx_get_bidi_chap(ha,\n\t\t\t\t    (char *)&boot_conn->chap.intr_chap_name,\n\t\t\t\t    (char *)&boot_conn->chap.intr_secret);\n\n\t\tif (ret) {\n\t\t\tql4_printk(KERN_ERR, ha, \"Failed to set BIDI chap\\n\");\n\t\t\tret = QLA_ERROR;\n\t\t\tgoto exit_boot_target;\n\t\t}\n\n\t\tboot_conn->chap.intr_chap_name_length = QL4_CHAP_MAX_NAME_LEN;\n\t\tboot_conn->chap.intr_secret_length = QL4_CHAP_MAX_SECRET_LEN;\n\t}\n\nexit_boot_target:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn ret;\n}\n\nstatic int qla4xxx_get_boot_info(struct scsi_qla_host *ha)\n{\n\tuint16_t ddb_index[2];\n\tint ret = QLA_ERROR;\n\tint rval;\n\n\tmemset(ddb_index, 0, sizeof(ddb_index));\n\tddb_index[0] = 0xffff;\n\tddb_index[1] = 0xffff;\n\tret = get_fw_boot_info(ha, ddb_index);\n\tif (ret != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\"%s: No boot target configured.\\n\", __func__));\n\t\treturn ret;\n\t}\n\n\tif (ql4xdisablesysfsboot)\n\t\treturn QLA_SUCCESS;\n\n\tif (ddb_index[0] == 0xffff)\n\t\tgoto sec_target;\n\n\trval = qla4xxx_get_boot_target(ha, &(ha->boot_tgt.boot_pri_sess),\n\t\t\t\t      ddb_index[0]);\n\tif (rval != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Primary boot target not \"\n\t\t\t\t  \"configured\\n\", __func__));\n\t} else\n\t\tret = QLA_SUCCESS;\n\nsec_target:\n\tif (ddb_index[1] == 0xffff)\n\t\tgoto exit_get_boot_info;\n\n\trval = qla4xxx_get_boot_target(ha, &(ha->boot_tgt.boot_sec_sess),\n\t\t\t\t      ddb_index[1]);\n\tif (rval != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Secondary boot target not\"\n\t\t\t\t  \" configured\\n\", __func__));\n\t} else\n\t\tret = QLA_SUCCESS;\n\nexit_get_boot_info:\n\treturn ret;\n}\n\nstatic int qla4xxx_setup_boot_info(struct scsi_qla_host *ha)\n{\n\tstruct iscsi_boot_kobj *boot_kobj;\n\n\tif (qla4xxx_get_boot_info(ha) != QLA_SUCCESS)\n\t\treturn QLA_ERROR;\n\n\tif (ql4xdisablesysfsboot) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: syfsboot disabled - driver will trigger login \"\n\t\t\t   \"and publish session for discovery .\\n\", __func__);\n\t\treturn QLA_SUCCESS;\n\t}\n\n\n\tha->boot_kset = iscsi_boot_create_host_kset(ha->host->host_no);\n\tif (!ha->boot_kset)\n\t\tgoto kset_free;\n\n\tif (!scsi_host_get(ha->host))\n\t\tgoto kset_free;\n\tboot_kobj = iscsi_boot_create_target(ha->boot_kset, 0, ha,\n\t\t\t\t\t     qla4xxx_show_boot_tgt_pri_info,\n\t\t\t\t\t     qla4xxx_tgt_get_attr_visibility,\n\t\t\t\t\t     qla4xxx_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(ha->host))\n\t\tgoto kset_free;\n\tboot_kobj = iscsi_boot_create_target(ha->boot_kset, 1, ha,\n\t\t\t\t\t     qla4xxx_show_boot_tgt_sec_info,\n\t\t\t\t\t     qla4xxx_tgt_get_attr_visibility,\n\t\t\t\t\t     qla4xxx_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(ha->host))\n\t\tgoto kset_free;\n\tboot_kobj = iscsi_boot_create_initiator(ha->boot_kset, 0, ha,\n\t\t\t\t\t       qla4xxx_show_boot_ini_info,\n\t\t\t\t\t       qla4xxx_ini_get_attr_visibility,\n\t\t\t\t\t       qla4xxx_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\tif (!scsi_host_get(ha->host))\n\t\tgoto kset_free;\n\tboot_kobj = iscsi_boot_create_ethernet(ha->boot_kset, 0, ha,\n\t\t\t\t\t       qla4xxx_show_boot_eth_info,\n\t\t\t\t\t       qla4xxx_eth_get_attr_visibility,\n\t\t\t\t\t       qla4xxx_boot_release);\n\tif (!boot_kobj)\n\t\tgoto put_host;\n\n\treturn QLA_SUCCESS;\n\nput_host:\n\tscsi_host_put(ha->host);\nkset_free:\n\tiscsi_boot_destroy_kset(ha->boot_kset);\n\treturn -ENOMEM;\n}\n\n\nstatic void qla4xxx_get_param_ddb(struct ddb_entry *ddb_entry,\n\t\t\t\t  struct ql4_tuple_ddb *tddb)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_session *sess;\n\tstruct iscsi_conn *conn;\n\n\tDEBUG2(printk(KERN_INFO \"Func: %s\\n\", __func__));\n\tcls_sess = ddb_entry->sess;\n\tsess = cls_sess->dd_data;\n\tcls_conn = ddb_entry->conn;\n\tconn = cls_conn->dd_data;\n\n\ttddb->tpgt = sess->tpgt;\n\ttddb->port = conn->persistent_port;\n\tstrscpy(tddb->iscsi_name, sess->targetname, ISCSI_NAME_SIZE);\n\tstrscpy(tddb->ip_addr, conn->persistent_address, DDB_IPADDR_LEN);\n}\n\nstatic void qla4xxx_convert_param_ddb(struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t      struct ql4_tuple_ddb *tddb,\n\t\t\t\t      uint8_t *flash_isid)\n{\n\tuint16_t options = 0;\n\n\ttddb->tpgt = le32_to_cpu(fw_ddb_entry->tgt_portal_grp);\n\tmemcpy(&tddb->iscsi_name[0], &fw_ddb_entry->iscsi_name[0],\n\t       min(sizeof(tddb->iscsi_name), sizeof(fw_ddb_entry->iscsi_name)));\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE)\n\t\tsprintf(tddb->ip_addr, \"%pI6\", fw_ddb_entry->ip_addr);\n\telse\n\t\tsprintf(tddb->ip_addr, \"%pI4\", fw_ddb_entry->ip_addr);\n\n\ttddb->port = le16_to_cpu(fw_ddb_entry->port);\n\n\tif (flash_isid == NULL)\n\t\tmemcpy(&tddb->isid[0], &fw_ddb_entry->isid[0],\n\t\t       sizeof(tddb->isid));\n\telse\n\t\tmemcpy(&tddb->isid[0], &flash_isid[0], sizeof(tddb->isid));\n}\n\nstatic int qla4xxx_compare_tuple_ddb(struct scsi_qla_host *ha,\n\t\t\t\t     struct ql4_tuple_ddb *old_tddb,\n\t\t\t\t     struct ql4_tuple_ddb *new_tddb,\n\t\t\t\t     uint8_t is_isid_compare)\n{\n\tif (strcmp(old_tddb->iscsi_name, new_tddb->iscsi_name))\n\t\treturn QLA_ERROR;\n\n\tif (strcmp(old_tddb->ip_addr, new_tddb->ip_addr))\n\t\treturn QLA_ERROR;\n\n\tif (old_tddb->port != new_tddb->port)\n\t\treturn QLA_ERROR;\n\n\t \n\tif (is_isid_compare) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\"%s: old ISID [%pmR] New ISID [%pmR]\\n\",\n\t\t\t__func__, old_tddb->isid, new_tddb->isid));\n\n\t\tif (memcmp(&old_tddb->isid[0], &new_tddb->isid[0],\n\t\t\t   sizeof(old_tddb->isid)))\n\t\t\treturn QLA_ERROR;\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Match Found, fw[%d,%d,%s,%s], [%d,%d,%s,%s]\",\n\t\t\t  old_tddb->port, old_tddb->tpgt, old_tddb->ip_addr,\n\t\t\t  old_tddb->iscsi_name, new_tddb->port, new_tddb->tpgt,\n\t\t\t  new_tddb->ip_addr, new_tddb->iscsi_name));\n\n\treturn QLA_SUCCESS;\n}\n\nstatic int qla4xxx_is_session_exists(struct scsi_qla_host *ha,\n\t\t\t\t     struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t     uint32_t *index)\n{\n\tstruct ddb_entry *ddb_entry;\n\tstruct ql4_tuple_ddb *fw_tddb = NULL;\n\tstruct ql4_tuple_ddb *tmp_tddb = NULL;\n\tint idx;\n\tint ret = QLA_ERROR;\n\n\tfw_tddb = vzalloc(sizeof(*fw_tddb));\n\tif (!fw_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"Memory Allocation failed.\\n\"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\ttmp_tddb = vzalloc(sizeof(*tmp_tddb));\n\tif (!tmp_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"Memory Allocation failed.\\n\"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\tqla4xxx_convert_param_ddb(fw_ddb_entry, fw_tddb, NULL);\n\n\tfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tqla4xxx_get_param_ddb(ddb_entry, tmp_tddb);\n\t\tif (!qla4xxx_compare_tuple_ddb(ha, fw_tddb, tmp_tddb, false)) {\n\t\t\tret = QLA_SUCCESS;  \n\t\t\tif (index != NULL)\n\t\t\t\t*index = idx;\n\t\t\tgoto exit_check;\n\t\t}\n\t}\n\nexit_check:\n\tvfree(fw_tddb);\n\tvfree(tmp_tddb);\n\treturn ret;\n}\n\n \nstatic int qla4xxx_check_existing_isid(struct list_head *list_nt, uint8_t *isid)\n{\n\tstruct qla_ddb_index *nt_ddb_idx, *nt_ddb_idx_tmp;\n\tstruct dev_db_entry *fw_ddb_entry;\n\n\tlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\n\t\tfw_ddb_entry = &nt_ddb_idx->fw_ddb;\n\n\t\tif (memcmp(&fw_ddb_entry->isid[0], &isid[0],\n\t\t\t   sizeof(nt_ddb_idx->fw_ddb.isid)) == 0) {\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\t}\n\treturn QLA_ERROR;\n}\n\n \nstatic int qla4xxx_update_isid(struct scsi_qla_host *ha,\n\t\t\t       struct list_head *list_nt,\n\t\t\t       struct dev_db_entry *fw_ddb_entry)\n{\n\tuint8_t base_value, i;\n\n\tbase_value = fw_ddb_entry->isid[1] & 0x1f;\n\tfor (i = 0; i < 8; i++) {\n\t\tfw_ddb_entry->isid[1] = (base_value | (i << 5));\n\t\tif (qla4xxx_check_existing_isid(list_nt, fw_ddb_entry->isid))\n\t\t\tbreak;\n\t}\n\n\tif (!qla4xxx_check_existing_isid(list_nt, fw_ddb_entry->isid))\n\t\treturn QLA_ERROR;\n\n\treturn QLA_SUCCESS;\n}\n\n \nstatic int qla4xxx_should_update_isid(struct scsi_qla_host *ha,\n\t\t\t\t      struct ql4_tuple_ddb *old_tddb,\n\t\t\t\t      struct ql4_tuple_ddb *new_tddb)\n{\n\tif (strcmp(old_tddb->ip_addr, new_tddb->ip_addr) == 0) {\n\t\t \n\t\tif (old_tddb->port == new_tddb->port)\n\t\t\treturn QLA_ERROR;\n\t}\n\n\tif (strcmp(old_tddb->iscsi_name, new_tddb->iscsi_name))\n\t\t \n\t\treturn QLA_ERROR;\n\n\tif (memcmp(&old_tddb->isid[0], &new_tddb->isid[0],\n\t\t   sizeof(old_tddb->isid)))\n\t\t \n\t\treturn QLA_ERROR;\n\n\treturn QLA_SUCCESS;\n}\n\n \n\nstatic int qla4xxx_is_flash_ddb_exists(struct scsi_qla_host *ha,\n\t\t\t\t       struct list_head *list_nt,\n\t\t\t\t       struct dev_db_entry *fw_ddb_entry)\n{\n\tstruct qla_ddb_index  *nt_ddb_idx, *nt_ddb_idx_tmp;\n\tstruct ql4_tuple_ddb *fw_tddb = NULL;\n\tstruct ql4_tuple_ddb *tmp_tddb = NULL;\n\tint rval, ret = QLA_ERROR;\n\n\tfw_tddb = vzalloc(sizeof(*fw_tddb));\n\tif (!fw_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"Memory Allocation failed.\\n\"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\ttmp_tddb = vzalloc(sizeof(*tmp_tddb));\n\tif (!tmp_tddb) {\n\t\tDEBUG2(ql4_printk(KERN_WARNING, ha,\n\t\t\t\t  \"Memory Allocation failed.\\n\"));\n\t\tret = QLA_SUCCESS;\n\t\tgoto exit_check;\n\t}\n\n\tqla4xxx_convert_param_ddb(fw_ddb_entry, fw_tddb, NULL);\n\n\tlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\n\t\tqla4xxx_convert_param_ddb(&nt_ddb_idx->fw_ddb, tmp_tddb,\n\t\t\t\t\t  nt_ddb_idx->flash_isid);\n\t\tret = qla4xxx_compare_tuple_ddb(ha, fw_tddb, tmp_tddb, true);\n\t\t \n\t\tif (ret == QLA_SUCCESS)\n\t\t\tgoto exit_check;\n\t}\n\n\tlist_for_each_entry_safe(nt_ddb_idx, nt_ddb_idx_tmp, list_nt, list) {\n\t\tqla4xxx_convert_param_ddb(&nt_ddb_idx->fw_ddb, tmp_tddb, NULL);\n\n\t\tret = qla4xxx_should_update_isid(ha, tmp_tddb, fw_tddb);\n\t\tif (ret == QLA_SUCCESS) {\n\t\t\trval = qla4xxx_update_isid(ha, list_nt, fw_ddb_entry);\n\t\t\tif (rval == QLA_SUCCESS)\n\t\t\t\tret = QLA_ERROR;\n\t\t\telse\n\t\t\t\tret = QLA_SUCCESS;\n\n\t\t\tgoto exit_check;\n\t\t}\n\t}\n\nexit_check:\n\tvfree(fw_tddb);\n\tvfree(tmp_tddb);\n\treturn ret;\n}\n\nstatic void qla4xxx_free_ddb_list(struct list_head *list_ddb)\n{\n\tstruct qla_ddb_index  *ddb_idx, *ddb_idx_tmp;\n\n\tlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\n\t\tlist_del_init(&ddb_idx->list);\n\t\tvfree(ddb_idx);\n\t}\n}\n\nstatic struct iscsi_endpoint *qla4xxx_get_ep_fwdb(struct scsi_qla_host *ha,\n\t\t\t\t\tstruct dev_db_entry *fw_ddb_entry)\n{\n\tstruct iscsi_endpoint *ep;\n\tstruct sockaddr_in *addr;\n\tstruct sockaddr_in6 *addr6;\n\tstruct sockaddr *t_addr;\n\tstruct sockaddr_storage *dst_addr;\n\tchar *ip;\n\n\t \n\tdst_addr = vmalloc(sizeof(*dst_addr));\n\tif (!dst_addr)\n\t\treturn NULL;\n\n\tif (fw_ddb_entry->options & DDB_OPT_IPV6_DEVICE) {\n\t\tt_addr = (struct sockaddr *)dst_addr;\n\t\tt_addr->sa_family = AF_INET6;\n\t\taddr6 = (struct sockaddr_in6 *)dst_addr;\n\t\tip = (char *)&addr6->sin6_addr;\n\t\tmemcpy(ip, fw_ddb_entry->ip_addr, IPv6_ADDR_LEN);\n\t\taddr6->sin6_port = htons(le16_to_cpu(fw_ddb_entry->port));\n\n\t} else {\n\t\tt_addr = (struct sockaddr *)dst_addr;\n\t\tt_addr->sa_family = AF_INET;\n\t\taddr = (struct sockaddr_in *)dst_addr;\n\t\tip = (char *)&addr->sin_addr;\n\t\tmemcpy(ip, fw_ddb_entry->ip_addr, IP_ADDR_LEN);\n\t\taddr->sin_port = htons(le16_to_cpu(fw_ddb_entry->port));\n\t}\n\n\tep = qla4xxx_ep_connect(ha->host, (struct sockaddr *)dst_addr, 0);\n\tvfree(dst_addr);\n\treturn ep;\n}\n\nstatic int qla4xxx_verify_boot_idx(struct scsi_qla_host *ha, uint16_t idx)\n{\n\tif (ql4xdisablesysfsboot)\n\t\treturn QLA_SUCCESS;\n\tif (idx == ha->pri_ddb_idx || idx == ha->sec_ddb_idx)\n\t\treturn QLA_ERROR;\n\treturn QLA_SUCCESS;\n}\n\nstatic void qla4xxx_setup_flash_ddb_entry(struct scsi_qla_host *ha,\n\t\t\t\t\t  struct ddb_entry *ddb_entry,\n\t\t\t\t\t  uint16_t idx)\n{\n\tuint16_t def_timeout;\n\n\tddb_entry->ddb_type = FLASH_DDB;\n\tddb_entry->fw_ddb_index = INVALID_ENTRY;\n\tddb_entry->fw_ddb_device_state = DDB_DS_NO_CONNECTION_ACTIVE;\n\tddb_entry->ha = ha;\n\tddb_entry->unblock_sess = qla4xxx_unblock_flash_ddb;\n\tddb_entry->ddb_change = qla4xxx_flash_ddb_change;\n\tddb_entry->chap_tbl_idx = INVALID_ENTRY;\n\n\tatomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);\n\tatomic_set(&ddb_entry->relogin_timer, 0);\n\tatomic_set(&ddb_entry->relogin_retry_count, 0);\n\tdef_timeout = le16_to_cpu(ddb_entry->fw_ddb_entry.def_timeout);\n\tddb_entry->default_relogin_timeout =\n\t\t(def_timeout > LOGIN_TOV) && (def_timeout < LOGIN_TOV * 10) ?\n\t\tdef_timeout : LOGIN_TOV;\n\tddb_entry->default_time2wait =\n\t\tle16_to_cpu(ddb_entry->fw_ddb_entry.iscsi_def_time2wait);\n\n\tif (ql4xdisablesysfsboot &&\n\t    (idx == ha->pri_ddb_idx || idx == ha->sec_ddb_idx))\n\t\tset_bit(DF_BOOT_TGT, &ddb_entry->flags);\n}\n\nstatic void qla4xxx_wait_for_ip_configuration(struct scsi_qla_host *ha)\n{\n\tuint32_t idx = 0;\n\tuint32_t ip_idx[IP_ADDR_COUNT] = {0, 1, 2, 3};  \n\tuint32_t sts[MBOX_REG_COUNT];\n\tuint32_t ip_state;\n\tunsigned long wtime;\n\tint ret;\n\n\twtime = jiffies + (HZ * IP_CONFIG_TOV);\n\tdo {\n\t\tfor (idx = 0; idx < IP_ADDR_COUNT; idx++) {\n\t\t\tif (ip_idx[idx] == -1)\n\t\t\t\tcontinue;\n\n\t\t\tret = qla4xxx_get_ip_state(ha, 0, ip_idx[idx], sts);\n\n\t\t\tif (ret == QLA_ERROR) {\n\t\t\t\tip_idx[idx] = -1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tip_state = (sts[1] & IP_STATE_MASK) >> IP_STATE_SHIFT;\n\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"Waiting for IP state for idx = %d, state = 0x%x\\n\",\n\t\t\t\t\t  ip_idx[idx], ip_state));\n\t\t\tif (ip_state == IP_ADDRSTATE_UNCONFIGURED ||\n\t\t\t    ip_state == IP_ADDRSTATE_INVALID ||\n\t\t\t    ip_state == IP_ADDRSTATE_PREFERRED ||\n\t\t\t    ip_state == IP_ADDRSTATE_DEPRICATED ||\n\t\t\t    ip_state == IP_ADDRSTATE_DISABLING)\n\t\t\t\tip_idx[idx] = -1;\n\t\t}\n\n\t\t \n\t\tif ((ip_idx[0] == -1) &&\n\t\t    (ip_idx[1] == -1) &&\n\t\t    (ip_idx[2] == -1) &&\n\t\t    (ip_idx[3] == -1))\n\t\t\tbreak;\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while (time_after(wtime, jiffies));\n}\n\nstatic int qla4xxx_cmp_fw_stentry(struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t  struct dev_db_entry *flash_ddb_entry)\n{\n\tuint16_t options = 0;\n\tsize_t ip_len = IP_ADDR_LEN;\n\n\toptions = le16_to_cpu(fw_ddb_entry->options);\n\tif (options & DDB_OPT_IPV6_DEVICE)\n\t\tip_len = IPv6_ADDR_LEN;\n\n\tif (memcmp(fw_ddb_entry->ip_addr, flash_ddb_entry->ip_addr, ip_len))\n\t\treturn QLA_ERROR;\n\n\tif (memcmp(&fw_ddb_entry->isid[0], &flash_ddb_entry->isid[0],\n\t\t   sizeof(fw_ddb_entry->isid)))\n\t\treturn QLA_ERROR;\n\n\tif (memcmp(&fw_ddb_entry->port, &flash_ddb_entry->port,\n\t\t   sizeof(fw_ddb_entry->port)))\n\t\treturn QLA_ERROR;\n\n\treturn QLA_SUCCESS;\n}\n\nstatic int qla4xxx_find_flash_st_idx(struct scsi_qla_host *ha,\n\t\t\t\t     struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t     uint32_t fw_idx, uint32_t *flash_index)\n{\n\tstruct dev_db_entry *flash_ddb_entry;\n\tdma_addr_t flash_ddb_entry_dma;\n\tuint32_t idx = 0;\n\tint max_ddbs;\n\tint ret = QLA_ERROR, status;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tflash_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t\t &flash_ddb_entry_dma);\n\tif (flash_ddb_entry == NULL || fw_ddb_entry == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"Out of memory\\n\");\n\t\tgoto exit_find_st_idx;\n\t}\n\n\tstatus = qla4xxx_flashdb_by_index(ha, flash_ddb_entry,\n\t\t\t\t\t  flash_ddb_entry_dma, fw_idx);\n\tif (status == QLA_SUCCESS) {\n\t\tstatus = qla4xxx_cmp_fw_stentry(fw_ddb_entry, flash_ddb_entry);\n\t\tif (status == QLA_SUCCESS) {\n\t\t\t*flash_index = fw_idx;\n\t\t\tret = QLA_SUCCESS;\n\t\t\tgoto exit_find_st_idx;\n\t\t}\n\t}\n\n\tfor (idx = 0; idx < max_ddbs; idx++) {\n\t\tstatus = qla4xxx_flashdb_by_index(ha, flash_ddb_entry,\n\t\t\t\t\t\t  flash_ddb_entry_dma, idx);\n\t\tif (status == QLA_ERROR)\n\t\t\tcontinue;\n\n\t\tstatus = qla4xxx_cmp_fw_stentry(fw_ddb_entry, flash_ddb_entry);\n\t\tif (status == QLA_SUCCESS) {\n\t\t\t*flash_index = idx;\n\t\t\tret = QLA_SUCCESS;\n\t\t\tgoto exit_find_st_idx;\n\t\t}\n\t}\n\n\tif (idx == max_ddbs)\n\t\tql4_printk(KERN_ERR, ha, \"Failed to find ST [%d] in flash\\n\",\n\t\t\t   fw_idx);\n\nexit_find_st_idx:\n\tif (flash_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, flash_ddb_entry,\n\t\t\t      flash_ddb_entry_dma);\n\n\treturn ret;\n}\n\nstatic void qla4xxx_build_st_list(struct scsi_qla_host *ha,\n\t\t\t\t  struct list_head *list_st)\n{\n\tstruct qla_ddb_index  *st_ddb_idx;\n\tint max_ddbs;\n\tint fw_idx_size;\n\tstruct dev_db_entry *fw_ddb_entry;\n\tdma_addr_t fw_ddb_dma;\n\tint ret;\n\tuint32_t idx = 0, next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint32_t flash_index = -1;\n\tuint16_t conn_id = 0;\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Out of memory\\n\"));\n\t\tgoto exit_st_list;\n\t}\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\tfw_idx_size = sizeof(struct qla_ddb_index);\n\n\tfor (idx = 0; idx < max_ddbs; idx = next_idx) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\n\t\t\t\t\t      NULL, &next_idx, &state,\n\t\t\t\t\t      &conn_err, NULL, &conn_id);\n\t\tif (ret == QLA_ERROR)\n\t\t\tbreak;\n\n\t\t \n\t\tif (state == DDB_DS_UNASSIGNED)\n\t\t\tgoto continue_next_st;\n\n\t\t \n\t\tif (strlen((char *) fw_ddb_entry->iscsi_name) != 0)\n\t\t\tgoto continue_next_st;\n\n\t\tst_ddb_idx = vzalloc(fw_idx_size);\n\t\tif (!st_ddb_idx)\n\t\t\tbreak;\n\n\t\tret = qla4xxx_find_flash_st_idx(ha, fw_ddb_entry, idx,\n\t\t\t\t\t\t&flash_index);\n\t\tif (ret == QLA_ERROR) {\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"No flash entry for ST at idx [%d]\\n\", idx);\n\t\t\tst_ddb_idx->flash_ddb_idx = idx;\n\t\t} else {\n\t\t\tql4_printk(KERN_INFO, ha,\n\t\t\t\t   \"ST at idx [%d] is stored at flash [%d]\\n\",\n\t\t\t\t   idx, flash_index);\n\t\t\tst_ddb_idx->flash_ddb_idx = flash_index;\n\t\t}\n\n\t\tst_ddb_idx->fw_ddb_idx = idx;\n\n\t\tlist_add_tail(&st_ddb_idx->list, list_st);\ncontinue_next_st:\n\t\tif (next_idx == 0)\n\t\t\tbreak;\n\t}\n\nexit_st_list:\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n}\n\n \nstatic void qla4xxx_remove_failed_ddb(struct scsi_qla_host *ha,\n\t\t\t\t      struct list_head *list_ddb)\n{\n\tstruct qla_ddb_index  *ddb_idx, *ddb_idx_tmp;\n\tuint32_t next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tint ret;\n\n\tlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, ddb_idx->fw_ddb_idx,\n\t\t\t\t\t      NULL, 0, NULL, &next_idx, &state,\n\t\t\t\t\t      &conn_err, NULL, NULL);\n\t\tif (ret == QLA_ERROR)\n\t\t\tcontinue;\n\n\t\tif (state == DDB_DS_NO_CONNECTION_ACTIVE ||\n\t\t    state == DDB_DS_SESSION_FAILED) {\n\t\t\tlist_del_init(&ddb_idx->list);\n\t\t\tvfree(ddb_idx);\n\t\t}\n\t}\n}\n\nstatic void qla4xxx_update_sess_disc_idx(struct scsi_qla_host *ha,\n\t\t\t\t\t struct ddb_entry *ddb_entry,\n\t\t\t\t\t struct dev_db_entry *fw_ddb_entry)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_session *sess;\n\tuint32_t max_ddbs = 0;\n\tuint16_t ddb_link = -1;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tcls_sess = ddb_entry->sess;\n\tsess = cls_sess->dd_data;\n\n\tddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\n\tif (ddb_link < max_ddbs)\n\t\tsess->discovery_parent_idx = ddb_link;\n\telse\n\t\tsess->discovery_parent_idx = DDB_NO_LINK;\n}\n\nstatic int qla4xxx_sess_conn_setup(struct scsi_qla_host *ha,\n\t\t\t\t   struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t   int is_reset, uint16_t idx)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_session *sess;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct iscsi_endpoint *ep;\n\tuint16_t cmds_max = 32;\n\tuint16_t conn_id = 0;\n\tuint32_t initial_cmdsn = 0;\n\tint ret = QLA_SUCCESS;\n\n\tstruct ddb_entry *ddb_entry = NULL;\n\n\t \n\tcls_sess = iscsi_session_setup(&qla4xxx_iscsi_transport, ha->host,\n\t\t\t\t       cmds_max, sizeof(struct ddb_entry),\n\t\t\t\t       sizeof(struct ql4_task_data),\n\t\t\t\t       initial_cmdsn, INVALID_ENTRY);\n\tif (!cls_sess) {\n\t\tret = QLA_ERROR;\n\t\tgoto exit_setup;\n\t}\n\n\t \n\tmodule_put(qla4xxx_iscsi_transport.owner);\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tddb_entry->sess = cls_sess;\n\n\tcls_sess->recovery_tmo = ql4xsess_recovery_tmo;\n\tmemcpy(&ddb_entry->fw_ddb_entry, fw_ddb_entry,\n\t       sizeof(struct dev_db_entry));\n\n\tqla4xxx_setup_flash_ddb_entry(ha, ddb_entry, idx);\n\n\tcls_conn = iscsi_conn_setup(cls_sess, sizeof(struct qla_conn), conn_id);\n\n\tif (!cls_conn) {\n\t\tret = QLA_ERROR;\n\t\tgoto exit_setup;\n\t}\n\n\tddb_entry->conn = cls_conn;\n\n\t \n\tep = qla4xxx_get_ep_fwdb(ha, fw_ddb_entry);\n\tif (ep) {\n\t\tep->conn = cls_conn;\n\t\tcls_conn->ep = ep;\n\t} else {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Unable to get ep\\n\"));\n\t\tret = QLA_ERROR;\n\t\tgoto exit_setup;\n\t}\n\n\t \n\tqla4xxx_copy_fwddb_param(ha, fw_ddb_entry, cls_sess, cls_conn);\n\tqla4xxx_update_sess_disc_idx(ha, ddb_entry, fw_ddb_entry);\n\n\tif (is_reset == RESET_ADAPTER) {\n\t\tiscsi_block_session(cls_sess);\n\t\t \n\t\tset_bit(DPC_RELOGIN_DEVICE, &ha->dpc_flags);\n\t\tset_bit(DF_RELOGIN, &ddb_entry->flags);\n\t}\n\nexit_setup:\n\treturn ret;\n}\n\nstatic void qla4xxx_update_fw_ddb_link(struct scsi_qla_host *ha,\n\t\t\t\t       struct list_head *list_ddb,\n\t\t\t\t       struct dev_db_entry *fw_ddb_entry)\n{\n\tstruct qla_ddb_index  *ddb_idx, *ddb_idx_tmp;\n\tuint16_t ddb_link;\n\n\tddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\n\n\tlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, list_ddb, list) {\n\t\tif (ddb_idx->fw_ddb_idx == ddb_link) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"Updating NT parent idx from [%d] to [%d]\\n\",\n\t\t\t\t\t  ddb_link, ddb_idx->flash_ddb_idx));\n\t\t\tfw_ddb_entry->ddb_link =\n\t\t\t\t\t    cpu_to_le16(ddb_idx->flash_ddb_idx);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void qla4xxx_build_nt_list(struct scsi_qla_host *ha,\n\t\t\t\t  struct list_head *list_nt,\n\t\t\t\t  struct list_head *list_st,\n\t\t\t\t  int is_reset)\n{\n\tstruct dev_db_entry *fw_ddb_entry;\n\tstruct ddb_entry *ddb_entry = NULL;\n\tdma_addr_t fw_ddb_dma;\n\tint max_ddbs;\n\tint fw_idx_size;\n\tint ret;\n\tuint32_t idx = 0, next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint32_t ddb_idx = -1;\n\tuint16_t conn_id = 0;\n\tuint16_t ddb_link = -1;\n\tstruct qla_ddb_index  *nt_ddb_idx;\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Out of memory\\n\"));\n\t\tgoto exit_nt_list;\n\t}\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\tfw_idx_size = sizeof(struct qla_ddb_index);\n\n\tfor (idx = 0; idx < max_ddbs; idx = next_idx) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\n\t\t\t\t\t      NULL, &next_idx, &state,\n\t\t\t\t\t      &conn_err, NULL, &conn_id);\n\t\tif (ret == QLA_ERROR)\n\t\t\tbreak;\n\n\t\tif (qla4xxx_verify_boot_idx(ha, idx) != QLA_SUCCESS)\n\t\t\tgoto continue_next_nt;\n\n\t\t \n\t\tif (strlen((char *) fw_ddb_entry->iscsi_name) == 0)\n\t\t\tgoto continue_next_nt;\n\n\t\tddb_link = le16_to_cpu(fw_ddb_entry->ddb_link);\n\t\tif (ddb_link < max_ddbs)\n\t\t\tqla4xxx_update_fw_ddb_link(ha, list_st, fw_ddb_entry);\n\n\t\tif (!(state == DDB_DS_NO_CONNECTION_ACTIVE ||\n\t\t    state == DDB_DS_SESSION_FAILED) &&\n\t\t    (is_reset == INIT_ADAPTER))\n\t\t\tgoto continue_next_nt;\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Adding  DDB to session = 0x%x\\n\", idx));\n\n\t\tif (is_reset == INIT_ADAPTER) {\n\t\t\tnt_ddb_idx = vmalloc(fw_idx_size);\n\t\t\tif (!nt_ddb_idx)\n\t\t\t\tbreak;\n\n\t\t\tnt_ddb_idx->fw_ddb_idx = idx;\n\n\t\t\t \n\t\t\tmemcpy(&nt_ddb_idx->flash_isid[0],\n\t\t\t       &fw_ddb_entry->isid[0],\n\t\t\t       sizeof(nt_ddb_idx->flash_isid));\n\n\t\t\tret = qla4xxx_is_flash_ddb_exists(ha, list_nt,\n\t\t\t\t\t\t\t  fw_ddb_entry);\n\t\t\tif (ret == QLA_SUCCESS) {\n\t\t\t\t \n\t\t\t\tvfree(nt_ddb_idx);\n\t\t\t\tgoto continue_next_nt;\n\t\t\t}\n\n\t\t\t \n\t\t\tmemcpy(&nt_ddb_idx->fw_ddb, fw_ddb_entry,\n\t\t\t       sizeof(struct dev_db_entry));\n\n\t\t\tlist_add_tail(&nt_ddb_idx->list, list_nt);\n\t\t} else if (is_reset == RESET_ADAPTER) {\n\t\t\tret = qla4xxx_is_session_exists(ha, fw_ddb_entry,\n\t\t\t\t\t\t\t&ddb_idx);\n\t\t\tif (ret == QLA_SUCCESS) {\n\t\t\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha,\n\t\t\t\t\t\t\t\t       ddb_idx);\n\t\t\t\tif (ddb_entry != NULL)\n\t\t\t\t\tqla4xxx_update_sess_disc_idx(ha,\n\t\t\t\t\t\t\t\t     ddb_entry,\n\t\t\t\t\t\t\t\t  fw_ddb_entry);\n\t\t\t\tgoto continue_next_nt;\n\t\t\t}\n\t\t}\n\n\t\tret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, is_reset, idx);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto exit_nt_list;\n\ncontinue_next_nt:\n\t\tif (next_idx == 0)\n\t\t\tbreak;\n\t}\n\nexit_nt_list:\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n}\n\nstatic void qla4xxx_build_new_nt_list(struct scsi_qla_host *ha,\n\t\t\t\t      struct list_head *list_nt,\n\t\t\t\t      uint16_t target_id)\n{\n\tstruct dev_db_entry *fw_ddb_entry;\n\tdma_addr_t fw_ddb_dma;\n\tint max_ddbs;\n\tint fw_idx_size;\n\tint ret;\n\tuint32_t idx = 0, next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint16_t conn_id = 0;\n\tstruct qla_ddb_index  *nt_ddb_idx;\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Out of memory\\n\"));\n\t\tgoto exit_new_nt_list;\n\t}\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\tfw_idx_size = sizeof(struct qla_ddb_index);\n\n\tfor (idx = 0; idx < max_ddbs; idx = next_idx) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, fw_ddb_entry, fw_ddb_dma,\n\t\t\t\t\t      NULL, &next_idx, &state,\n\t\t\t\t\t      &conn_err, NULL, &conn_id);\n\t\tif (ret == QLA_ERROR)\n\t\t\tbreak;\n\n\t\t \n\t\tif (strlen((char *)fw_ddb_entry->iscsi_name) == 0)\n\t\t\tgoto continue_next_new_nt;\n\n\t\tif (!(state == DDB_DS_NO_CONNECTION_ACTIVE))\n\t\t\tgoto continue_next_new_nt;\n\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Adding  DDB to session = 0x%x\\n\", idx));\n\n\t\tnt_ddb_idx = vmalloc(fw_idx_size);\n\t\tif (!nt_ddb_idx)\n\t\t\tbreak;\n\n\t\tnt_ddb_idx->fw_ddb_idx = idx;\n\n\t\tret = qla4xxx_is_session_exists(ha, fw_ddb_entry, NULL);\n\t\tif (ret == QLA_SUCCESS) {\n\t\t\t \n\t\t\tvfree(nt_ddb_idx);\n\t\t\tgoto continue_next_new_nt;\n\t\t}\n\n\t\tif (target_id < max_ddbs)\n\t\t\tfw_ddb_entry->ddb_link = cpu_to_le16(target_id);\n\n\t\tlist_add_tail(&nt_ddb_idx->list, list_nt);\n\n\t\tret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, RESET_ADAPTER,\n\t\t\t\t\t      idx);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto exit_new_nt_list;\n\ncontinue_next_new_nt:\n\t\tif (next_idx == 0)\n\t\t\tbreak;\n\t}\n\nexit_new_nt_list:\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n}\n\n \nstatic int qla4xxx_sysfs_ddb_is_non_persistent(struct device *dev, void *data)\n{\n\tstruct iscsi_bus_flash_session *fnode_sess;\n\n\tif (!iscsi_flashnode_bus_match(dev, NULL))\n\t\treturn 0;\n\n\tfnode_sess = iscsi_dev_to_flash_session(dev);\n\n\treturn (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT);\n}\n\n \nstatic int qla4xxx_sysfs_ddb_tgt_create(struct scsi_qla_host *ha,\n\t\t\t\t\tstruct dev_db_entry *fw_ddb_entry,\n\t\t\t\t\tuint16_t *idx, int user)\n{\n\tstruct iscsi_bus_flash_session *fnode_sess = NULL;\n\tstruct iscsi_bus_flash_conn *fnode_conn = NULL;\n\tint rc = QLA_ERROR;\n\n\tfnode_sess = iscsi_create_flashnode_sess(ha->host, *idx,\n\t\t\t\t\t\t &qla4xxx_iscsi_transport, 0);\n\tif (!fnode_sess) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to create session sysfs entry for flashnode %d of host%lu\\n\",\n\t\t\t   __func__, *idx, ha->host_no);\n\t\tgoto exit_tgt_create;\n\t}\n\n\tfnode_conn = iscsi_create_flashnode_conn(ha->host, fnode_sess,\n\t\t\t\t\t\t &qla4xxx_iscsi_transport, 0);\n\tif (!fnode_conn) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to create conn sysfs entry for flashnode %d of host%lu\\n\",\n\t\t\t   __func__, *idx, ha->host_no);\n\t\tgoto free_sess;\n\t}\n\n\tif (user) {\n\t\tfnode_sess->flash_state = DEV_DB_NON_PERSISTENT;\n\t} else {\n\t\tfnode_sess->flash_state = DEV_DB_PERSISTENT;\n\n\t\tif (*idx == ha->pri_ddb_idx || *idx == ha->sec_ddb_idx)\n\t\t\tfnode_sess->is_boot_target = 1;\n\t\telse\n\t\t\tfnode_sess->is_boot_target = 0;\n\t}\n\n\trc = qla4xxx_copy_from_fwddb_param(fnode_sess, fnode_conn,\n\t\t\t\t\t   fw_ddb_entry);\n\tif (rc)\n\t\tgoto free_sess;\n\n\tql4_printk(KERN_INFO, ha, \"%s: sysfs entry %s created\\n\",\n\t\t   __func__, fnode_sess->dev.kobj.name);\n\n\tql4_printk(KERN_INFO, ha, \"%s: sysfs entry %s created\\n\",\n\t\t   __func__, fnode_conn->dev.kobj.name);\n\n\treturn QLA_SUCCESS;\n\nfree_sess:\n\tiscsi_destroy_flashnode_sess(fnode_sess);\n\nexit_tgt_create:\n\treturn QLA_ERROR;\n}\n\n \nstatic int qla4xxx_sysfs_ddb_add(struct Scsi_Host *shost, const char *buf,\n\t\t\t\t int len)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tstruct device *dev;\n\tuint16_t idx = 0;\n\tuint16_t max_ddbs = 0;\n\tuint32_t options = 0;\n\tuint32_t rval = QLA_ERROR;\n\n\tif (strncasecmp(PORTAL_TYPE_IPV4, buf, 4) &&\n\t    strncasecmp(PORTAL_TYPE_IPV6, buf, 4)) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s: Invalid portal type\\n\",\n\t\t\t\t  __func__));\n\t\tgoto exit_ddb_add;\n\t}\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_PRST_DEV_DB_ENTRIES :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\tgoto exit_ddb_add;\n\t}\n\n\tdev = iscsi_find_flashnode_sess(ha->host, NULL,\n\t\t\t\t\tqla4xxx_sysfs_ddb_is_non_persistent);\n\tif (dev) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: A non-persistent entry %s found\\n\",\n\t\t\t   __func__, dev->kobj.name);\n\t\tput_device(dev);\n\t\tgoto exit_ddb_add;\n\t}\n\n\t \n\tfor (idx = 2; idx < max_ddbs; idx++) {\n\t\tif (qla4xxx_flashdb_by_index(ha, fw_ddb_entry,\n\t\t\t\t\t     fw_ddb_entry_dma, idx))\n\t\t\tbreak;\n\t}\n\n\tif (idx == max_ddbs)\n\t\tgoto exit_ddb_add;\n\n\tif (!strncasecmp(\"ipv6\", buf, 4))\n\t\toptions |= IPV6_DEFAULT_DDB_ENTRY;\n\n\trval = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\n\tif (rval == QLA_ERROR)\n\t\tgoto exit_ddb_add;\n\n\trval = qla4xxx_sysfs_ddb_tgt_create(ha, fw_ddb_entry, &idx, 1);\n\nexit_ddb_add:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\tif (rval == QLA_SUCCESS)\n\t\treturn idx;\n\telse\n\t\treturn -EIO;\n}\n\n \nstatic int  qla4xxx_sysfs_ddb_apply(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t    struct iscsi_bus_flash_conn *fnode_conn)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tuint32_t dev_db_start_offset = FLASH_OFFSET_DB_INFO;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint32_t options = 0;\n\tint rval = 0;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\trval = -ENOMEM;\n\t\tgoto exit_ddb_apply;\n\t}\n\n\tif (!strncasecmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\toptions |= IPV6_DEFAULT_DDB_ENTRY;\n\n\trval = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\n\tif (rval == QLA_ERROR)\n\t\tgoto exit_ddb_apply;\n\n\tdev_db_start_offset += (fnode_sess->target_id *\n\t\t\t\tsizeof(*fw_ddb_entry));\n\n\tqla4xxx_copy_to_fwddb_param(fnode_sess, fnode_conn, fw_ddb_entry);\n\tfw_ddb_entry->cookie = DDB_VALID_COOKIE;\n\n\trval = qla4xxx_set_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\n\t\t\t\t sizeof(*fw_ddb_entry), FLASH_OPT_RMW_COMMIT);\n\n\tif (rval == QLA_SUCCESS) {\n\t\tfnode_sess->flash_state = DEV_DB_PERSISTENT;\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"%s: flash node %u of host %lu written to flash\\n\",\n\t\t\t   __func__, fnode_sess->target_id, ha->host_no);\n\t} else {\n\t\trval = -EIO;\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Error while writing flash node %u of host %lu to flash\\n\",\n\t\t\t   __func__, fnode_sess->target_id, ha->host_no);\n\t}\n\nexit_ddb_apply:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn rval;\n}\n\nstatic ssize_t qla4xxx_sysfs_ddb_conn_open(struct scsi_qla_host *ha,\n\t\t\t\t\t   struct dev_db_entry *fw_ddb_entry,\n\t\t\t\t\t   uint16_t idx)\n{\n\tstruct dev_db_entry *ddb_entry = NULL;\n\tdma_addr_t ddb_entry_dma;\n\tunsigned long wtime;\n\tuint32_t mbx_sts = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint16_t tmo = 0;\n\tint ret = 0;\n\n\tddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*ddb_entry),\n\t\t\t\t       &ddb_entry_dma, GFP_KERNEL);\n\tif (!ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\treturn QLA_ERROR;\n\t}\n\n\tmemcpy(ddb_entry, fw_ddb_entry, sizeof(*ddb_entry));\n\n\tret = qla4xxx_set_ddb_entry(ha, idx, ddb_entry_dma, &mbx_sts);\n\tif (ret != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to set ddb entry for index %d\\n\",\n\t\t\t\t  __func__, idx));\n\t\tgoto exit_ddb_conn_open;\n\t}\n\n\tqla4xxx_conn_open(ha, idx);\n\n\t \n\ttmo = ((ha->def_timeout > LOGIN_TOV) &&\n\t       (ha->def_timeout < LOGIN_TOV * 10) ?\n\t       ha->def_timeout : LOGIN_TOV);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Default time to wait for login to ddb %d\\n\", tmo));\n\n\twtime = jiffies + (HZ * tmo);\n\tdo {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, NULL, 0, NULL,\n\t\t\t\t\t      NULL, &state, &conn_err, NULL,\n\t\t\t\t\t      NULL);\n\t\tif (ret == QLA_ERROR)\n\t\t\tcontinue;\n\n\t\tif (state == DDB_DS_NO_CONNECTION_ACTIVE ||\n\t\t    state == DDB_DS_SESSION_FAILED)\n\t\t\tbreak;\n\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t} while (time_after(wtime, jiffies));\n\nexit_ddb_conn_open:\n\tif (ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*ddb_entry),\n\t\t\t\t  ddb_entry, ddb_entry_dma);\n\treturn ret;\n}\n\nstatic int qla4xxx_ddb_login_st(struct scsi_qla_host *ha,\n\t\t\t\tstruct dev_db_entry *fw_ddb_entry,\n\t\t\t\tuint16_t target_id)\n{\n\tstruct qla_ddb_index *ddb_idx, *ddb_idx_tmp;\n\tstruct list_head list_nt;\n\tuint16_t ddb_index;\n\tint ret = 0;\n\n\tif (test_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags)) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s: A discovery already in progress!\\n\", __func__);\n\t\treturn QLA_ERROR;\n\t}\n\n\tINIT_LIST_HEAD(&list_nt);\n\n\tset_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags);\n\n\tret = qla4xxx_get_ddb_index(ha, &ddb_index);\n\tif (ret == QLA_ERROR)\n\t\tgoto exit_login_st_clr_bit;\n\n\tret = qla4xxx_sysfs_ddb_conn_open(ha, fw_ddb_entry, ddb_index);\n\tif (ret == QLA_ERROR)\n\t\tgoto exit_login_st;\n\n\tqla4xxx_build_new_nt_list(ha, &list_nt, target_id);\n\n\tlist_for_each_entry_safe(ddb_idx, ddb_idx_tmp, &list_nt, list) {\n\t\tlist_del_init(&ddb_idx->list);\n\t\tqla4xxx_clear_ddb_entry(ha, ddb_idx->fw_ddb_idx);\n\t\tvfree(ddb_idx);\n\t}\n\nexit_login_st:\n\tif (qla4xxx_clear_ddb_entry(ha, ddb_index) == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"Unable to clear DDB index = 0x%x\\n\", ddb_index);\n\t}\n\n\tclear_bit(ddb_index, ha->ddb_idx_map);\n\nexit_login_st_clr_bit:\n\tclear_bit(AF_ST_DISCOVERY_IN_PROGRESS, &ha->flags);\n\treturn ret;\n}\n\nstatic int qla4xxx_ddb_login_nt(struct scsi_qla_host *ha,\n\t\t\t\tstruct dev_db_entry *fw_ddb_entry,\n\t\t\t\tuint16_t idx)\n{\n\tint ret = QLA_ERROR;\n\n\tret = qla4xxx_is_session_exists(ha, fw_ddb_entry, NULL);\n\tif (ret != QLA_SUCCESS)\n\t\tret = qla4xxx_sess_conn_setup(ha, fw_ddb_entry, RESET_ADAPTER,\n\t\t\t\t\t      idx);\n\telse\n\t\tret = -EPERM;\n\n\treturn ret;\n}\n\n \nstatic int qla4xxx_sysfs_ddb_login(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t   struct iscsi_bus_flash_conn *fnode_conn)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint32_t options = 0;\n\tint ret = 0;\n\n\tif (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Target info is not persistent\\n\", __func__);\n\t\tret = -EIO;\n\t\tgoto exit_ddb_login;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_login;\n\t}\n\n\tif (!strncasecmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\toptions |= IPV6_DEFAULT_DDB_ENTRY;\n\n\tret = qla4xxx_get_default_ddb(ha, options, fw_ddb_entry_dma);\n\tif (ret == QLA_ERROR)\n\t\tgoto exit_ddb_login;\n\n\tqla4xxx_copy_to_fwddb_param(fnode_sess, fnode_conn, fw_ddb_entry);\n\tfw_ddb_entry->cookie = DDB_VALID_COOKIE;\n\n\tif (strlen((char *)fw_ddb_entry->iscsi_name) == 0)\n\t\tret = qla4xxx_ddb_login_st(ha, fw_ddb_entry,\n\t\t\t\t\t   fnode_sess->target_id);\n\telse\n\t\tret = qla4xxx_ddb_login_nt(ha, fw_ddb_entry,\n\t\t\t\t\t   fnode_sess->target_id);\n\n\tif (ret > 0)\n\t\tret = -EIO;\n\nexit_ddb_login:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn ret;\n}\n\n \nstatic int qla4xxx_sysfs_ddb_logout_sid(struct iscsi_cls_session *cls_sess)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry = NULL;\n\tstruct scsi_qla_host *ha;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tunsigned long flags;\n\tunsigned long wtime;\n\tuint32_t ddb_state;\n\tint options;\n\tint ret = 0;\n\n\tsess = cls_sess->dd_data;\n\tddb_entry = sess->dd_data;\n\tha = ddb_entry->ha;\n\n\tif (ddb_entry->ddb_type != FLASH_DDB) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Not a flash node session\\n\",\n\t\t\t   __func__);\n\t\tret = -ENXIO;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tif (test_bit(DF_BOOT_TGT, &ddb_entry->flags)) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Logout from boot target entry is not permitted.\\n\",\n\t\t\t   __func__);\n\t\tret = -EPERM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tif (test_and_set_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags))\n\t\tgoto ddb_logout_init;\n\n\tret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t      fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t      NULL, NULL, &ddb_state, NULL,\n\t\t\t\t      NULL, NULL);\n\tif (ret == QLA_ERROR)\n\t\tgoto ddb_logout_init;\n\n\tif (ddb_state == DDB_DS_SESSION_ACTIVE)\n\t\tgoto ddb_logout_init;\n\n\t \n\twtime = jiffies + (HZ * RELOGIN_TOV);\n\tdo {\n\t\tif (test_and_clear_bit(DF_RELOGIN, &ddb_entry->flags))\n\t\t\tgoto ddb_logout_init;\n\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while ((time_after(wtime, jiffies)));\n\nddb_logout_init:\n\tatomic_set(&ddb_entry->retry_relogin_timer, INVALID_ENTRY);\n\tatomic_set(&ddb_entry->relogin_timer, 0);\n\n\toptions = LOGOUT_OPTION_CLOSE_SESSION;\n\tqla4xxx_session_logout_ddb(ha, ddb_entry, options);\n\n\tmemset(fw_ddb_entry, 0, sizeof(*fw_ddb_entry));\n\twtime = jiffies + (HZ * LOGOUT_TOV);\n\tdo {\n\t\tret = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t\t      fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t      NULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t      NULL, NULL);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto ddb_logout_clr_sess;\n\n\t\tif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\n\t\t    (ddb_state == DDB_DS_SESSION_FAILED))\n\t\t\tgoto ddb_logout_clr_sess;\n\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while ((time_after(wtime, jiffies)));\n\nddb_logout_clr_sess:\n\tqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\n\t \n\ttry_module_get(qla4xxx_iscsi_transport.owner);\n\tiscsi_destroy_endpoint(ddb_entry->conn->ep);\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tqla4xxx_free_ddb(ha, ddb_entry);\n\tclear_bit(ddb_entry->fw_ddb_index, ha->ddb_idx_map);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tiscsi_session_teardown(ddb_entry->sess);\n\n\tclear_bit(DF_DISABLE_RELOGIN, &ddb_entry->flags);\n\tret = QLA_SUCCESS;\n\nexit_ddb_logout:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n\treturn ret;\n}\n\n \nstatic int qla4xxx_sysfs_ddb_logout(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t\t    struct iscsi_bus_flash_conn *fnode_conn)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct ql4_tuple_ddb *flash_tddb = NULL;\n\tstruct ql4_tuple_ddb *tmp_tddb = NULL;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tstruct ddb_entry *ddb_entry = NULL;\n\tdma_addr_t fw_ddb_dma;\n\tuint32_t next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\tuint16_t conn_id = 0;\n\tint idx, index;\n\tint status, ret = 0;\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"%s:Out of memory\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tflash_tddb = vzalloc(sizeof(*flash_tddb));\n\tif (!flash_tddb) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s:Memory Allocation failed.\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\ttmp_tddb = vzalloc(sizeof(*tmp_tddb));\n\tif (!tmp_tddb) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"%s:Memory Allocation failed.\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tif (!fnode_sess->targetname) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s:Cannot logout from SendTarget entry\\n\",\n\t\t\t   __func__);\n\t\tret = -EPERM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tif (fnode_sess->is_boot_target) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Logout from boot target entry is not permitted.\\n\",\n\t\t\t   __func__);\n\t\tret = -EPERM;\n\t\tgoto exit_ddb_logout;\n\t}\n\n\tstrscpy(flash_tddb->iscsi_name, fnode_sess->targetname,\n\t\tISCSI_NAME_SIZE);\n\n\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\tsprintf(flash_tddb->ip_addr, \"%pI6\", fnode_conn->ipaddress);\n\telse\n\t\tsprintf(flash_tddb->ip_addr, \"%pI4\", fnode_conn->ipaddress);\n\n\tflash_tddb->tpgt = fnode_sess->tpgt;\n\tflash_tddb->port = fnode_conn->port;\n\n\tCOPY_ISID(flash_tddb->isid, fnode_sess->isid);\n\n\tfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tif (ddb_entry->ddb_type != FLASH_DDB)\n\t\t\tcontinue;\n\n\t\tindex = ddb_entry->sess->target_id;\n\t\tstatus = qla4xxx_get_fwddb_entry(ha, index, fw_ddb_entry,\n\t\t\t\t\t\t fw_ddb_dma, NULL, &next_idx,\n\t\t\t\t\t\t &state, &conn_err, NULL,\n\t\t\t\t\t\t &conn_id);\n\t\tif (status == QLA_ERROR) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tqla4xxx_convert_param_ddb(fw_ddb_entry, tmp_tddb, NULL);\n\n\t\tstatus = qla4xxx_compare_tuple_ddb(ha, flash_tddb, tmp_tddb,\n\t\t\t\t\t\t   true);\n\t\tif (status == QLA_SUCCESS) {\n\t\t\tret = qla4xxx_sysfs_ddb_logout_sid(ddb_entry->sess);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idx == MAX_DDB_ENTRIES)\n\t\tret = -ESRCH;\n\nexit_ddb_logout:\n\tvfree(flash_tddb);\n\tvfree(tmp_tddb);\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n\n\treturn ret;\n}\n\nstatic int\nqla4xxx_sysfs_ddb_get_param(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    int param, char *buf)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_bus_flash_conn *fnode_conn;\n\tstruct ql4_chap_table chap_tbl;\n\tstruct device *dev;\n\tint parent_type;\n\tint rc = 0;\n\n\tdev = iscsi_find_flashnode_conn(fnode_sess);\n\tif (!dev)\n\t\treturn -EIO;\n\n\tfnode_conn = iscsi_dev_to_flash_conn(dev);\n\n\tswitch (param) {\n\tcase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->is_fw_assigned_ipv6);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_PORTAL_TYPE:\n\t\trc = sprintf(buf, \"%s\\n\", fnode_sess->portal_type);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->auto_snd_tgt_disable);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_SESS:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->discovery_sess);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_ENTRY_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->entry_state);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_HDR_DGST_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->hdrdgst_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DATA_DGST_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->datadgst_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IMM_DATA_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->imm_data_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_INITIAL_R2T_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->initial_r2t_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DATASEQ_INORDER:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->dataseq_inorder_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_PDU_INORDER:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->pdu_inorder_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_CHAP_AUTH_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->chap_auth_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_SNACK_REQ_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->snack_req_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->discovery_logout_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_BIDI_CHAP_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->bidi_chap_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->discovery_auth_optional);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_ERL:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->erl);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_timestamp_stat);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_nagle_disable);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_wsf_disable);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_timer_scale);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_timestamp_en);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->fragment_disable);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->max_recv_dlength);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->max_xmit_dlength);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_FIRST_BURST:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->first_burst);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DEF_TIME2WAIT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->time2wait);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->time2retain);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_R2T:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->max_r2t);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_KEEPALIVE_TMO:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->keepalive_timeout);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_ISID:\n\t\trc = sprintf(buf, \"%pm\\n\", fnode_sess->isid);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TSID:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->tsid);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_PORT:\n\t\trc = sprintf(buf, \"%d\\n\", fnode_conn->port);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_BURST:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->max_burst);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\n\t\trc = sprintf(buf, \"%u\\n\",\n\t\t\t     fnode_sess->default_taskmgmt_timeout);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IPADDR:\n\t\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\t\trc = sprintf(buf, \"%pI6\\n\", fnode_conn->ipaddress);\n\t\telse\n\t\t\trc = sprintf(buf, \"%pI4\\n\", fnode_conn->ipaddress);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_ALIAS:\n\t\tif (fnode_sess->targetalias)\n\t\t\trc = sprintf(buf, \"%s\\n\", fnode_sess->targetalias);\n\t\telse\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_REDIRECT_IPADDR:\n\t\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\t\trc = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t     fnode_conn->redirect_ipaddr);\n\t\telse\n\t\t\trc = sprintf(buf, \"%pI4\\n\",\n\t\t\t\t     fnode_conn->redirect_ipaddr);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->max_segment_size);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_LOCAL_PORT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->local_port);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IPV4_TOS:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->ipv4_tos);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IPV6_TC:\n\t\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\t\trc = sprintf(buf, \"%u\\n\",\n\t\t\t\t     fnode_conn->ipv6_traffic_class);\n\t\telse\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->ipv6_flow_label);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\n\t\tif (!strncmp(fnode_sess->portal_type, PORTAL_TYPE_IPV6, 4))\n\t\t\trc = sprintf(buf, \"%pI6\\n\",\n\t\t\t\t     fnode_conn->link_local_ipv6_addr);\n\t\telse\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->discovery_parent_idx);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_TYPE:\n\t\tif (fnode_sess->discovery_parent_type == DDB_ISNS)\n\t\t\tparent_type = ISCSI_DISC_PARENT_ISNS;\n\t\telse if (fnode_sess->discovery_parent_type == DDB_NO_LINK)\n\t\t\tparent_type = ISCSI_DISC_PARENT_UNKNOWN;\n\t\telse if (fnode_sess->discovery_parent_type < MAX_DDB_ENTRIES)\n\t\t\tparent_type = ISCSI_DISC_PARENT_SENDTGT;\n\t\telse\n\t\t\tparent_type = ISCSI_DISC_PARENT_UNKNOWN;\n\n\t\trc = sprintf(buf, \"%s\\n\",\n\t\t\t     iscsi_get_discovery_parent_name(parent_type));\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_NAME:\n\t\tif (fnode_sess->targetname)\n\t\t\trc = sprintf(buf, \"%s\\n\", fnode_sess->targetname);\n\t\telse\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TPGT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->tpgt);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_XMIT_WSF:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_xmit_wsf);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_TCP_RECV_WSF:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->tcp_recv_wsf);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_CHAP_OUT_IDX:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->chap_out_idx);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_USERNAME:\n\t\tif (fnode_sess->chap_auth_en) {\n\t\t\tqla4xxx_get_uni_chap_at_index(ha,\n\t\t\t\t\t\t      chap_tbl.name,\n\t\t\t\t\t\t      chap_tbl.secret,\n\t\t\t\t\t\t      fnode_sess->chap_out_idx);\n\t\t\trc = sprintf(buf, \"%s\\n\", chap_tbl.name);\n\t\t} else {\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\t}\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_PASSWORD:\n\t\tif (fnode_sess->chap_auth_en) {\n\t\t\tqla4xxx_get_uni_chap_at_index(ha,\n\t\t\t\t\t\t      chap_tbl.name,\n\t\t\t\t\t\t      chap_tbl.secret,\n\t\t\t\t\t\t      fnode_sess->chap_out_idx);\n\t\t\trc = sprintf(buf, \"%s\\n\", chap_tbl.secret);\n\t\t} else {\n\t\t\trc = sprintf(buf, \"\\n\");\n\t\t}\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_STATSN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->statsn);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_EXP_STATSN:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_conn->exp_statsn);\n\t\tbreak;\n\tcase ISCSI_FLASHNODE_IS_BOOT_TGT:\n\t\trc = sprintf(buf, \"%u\\n\", fnode_sess->is_boot_target);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tput_device(dev);\n\treturn rc;\n}\n\n \nstatic int\nqla4xxx_sysfs_ddb_set_param(struct iscsi_bus_flash_session *fnode_sess,\n\t\t\t    struct iscsi_bus_flash_conn *fnode_conn,\n\t\t\t    void *data, int len)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tstruct iscsi_flashnode_param_info *fnode_param;\n\tstruct ql4_chap_table chap_tbl;\n\tstruct nlattr *attr;\n\tuint16_t chap_out_idx = INVALID_ENTRY;\n\tint rc = QLA_ERROR;\n\tuint32_t rem = len;\n\n\tmemset((void *)&chap_tbl, 0, sizeof(chap_tbl));\n\tnla_for_each_attr(attr, data, len, rem) {\n\t\tif (nla_len(attr) < sizeof(*fnode_param)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto exit_set_param;\n\t\t}\n\n\t\tfnode_param = nla_data(attr);\n\n\t\tswitch (fnode_param->param) {\n\t\tcase ISCSI_FLASHNODE_IS_FW_ASSIGNED_IPV6:\n\t\t\tfnode_conn->is_fw_assigned_ipv6 = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_PORTAL_TYPE:\n\t\t\tmemcpy(fnode_sess->portal_type, fnode_param->value,\n\t\t\t       strlen(fnode_sess->portal_type));\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_AUTO_SND_TGT_DISABLE:\n\t\t\tfnode_sess->auto_snd_tgt_disable =\n\t\t\t\t\t\t\tfnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_SESS:\n\t\t\tfnode_sess->discovery_sess = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_ENTRY_EN:\n\t\t\tfnode_sess->entry_state = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_HDR_DGST_EN:\n\t\t\tfnode_conn->hdrdgst_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DATA_DGST_EN:\n\t\t\tfnode_conn->datadgst_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IMM_DATA_EN:\n\t\t\tfnode_sess->imm_data_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_INITIAL_R2T_EN:\n\t\t\tfnode_sess->initial_r2t_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DATASEQ_INORDER:\n\t\t\tfnode_sess->dataseq_inorder_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_PDU_INORDER:\n\t\t\tfnode_sess->pdu_inorder_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_CHAP_AUTH_EN:\n\t\t\tfnode_sess->chap_auth_en = fnode_param->value[0];\n\t\t\t \n\t\t\tif (!fnode_sess->chap_auth_en)\n\t\t\t\tfnode_sess->chap_out_idx = INVALID_ENTRY;\n\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_SNACK_REQ_EN:\n\t\t\tfnode_conn->snack_req_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_LOGOUT_EN:\n\t\t\tfnode_sess->discovery_logout_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_BIDI_CHAP_EN:\n\t\t\tfnode_sess->bidi_chap_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_AUTH_OPTIONAL:\n\t\t\tfnode_sess->discovery_auth_optional =\n\t\t\t\t\t\t\tfnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_ERL:\n\t\t\tfnode_sess->erl = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_STAT:\n\t\t\tfnode_conn->tcp_timestamp_stat = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_NAGLE_DISABLE:\n\t\t\tfnode_conn->tcp_nagle_disable = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_WSF_DISABLE:\n\t\t\tfnode_conn->tcp_wsf_disable = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_TIMER_SCALE:\n\t\t\tfnode_conn->tcp_timer_scale = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_TIMESTAMP_EN:\n\t\t\tfnode_conn->tcp_timestamp_en = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IP_FRAG_DISABLE:\n\t\t\tfnode_conn->fragment_disable = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_RECV_DLENGTH:\n\t\t\tfnode_conn->max_recv_dlength =\n\t\t\t\t\t*(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_XMIT_DLENGTH:\n\t\t\tfnode_conn->max_xmit_dlength =\n\t\t\t\t\t*(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_FIRST_BURST:\n\t\t\tfnode_sess->first_burst =\n\t\t\t\t\t*(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DEF_TIME2WAIT:\n\t\t\tfnode_sess->time2wait = *(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DEF_TIME2RETAIN:\n\t\t\tfnode_sess->time2retain =\n\t\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_R2T:\n\t\t\tfnode_sess->max_r2t =\n\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_KEEPALIVE_TMO:\n\t\t\tfnode_conn->keepalive_timeout =\n\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_ISID:\n\t\t\tmemcpy(fnode_sess->isid, fnode_param->value,\n\t\t\t       sizeof(fnode_sess->isid));\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TSID:\n\t\t\tfnode_sess->tsid = *(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_PORT:\n\t\t\tfnode_conn->port = *(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_BURST:\n\t\t\tfnode_sess->max_burst = *(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DEF_TASKMGMT_TMO:\n\t\t\tfnode_sess->default_taskmgmt_timeout =\n\t\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IPADDR:\n\t\t\tmemcpy(fnode_conn->ipaddress, fnode_param->value,\n\t\t\t       IPv6_ADDR_LEN);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_ALIAS:\n\t\t\trc = iscsi_switch_str_param(&fnode_sess->targetalias,\n\t\t\t\t\t\t    (char *)fnode_param->value);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_REDIRECT_IPADDR:\n\t\t\tmemcpy(fnode_conn->redirect_ipaddr, fnode_param->value,\n\t\t\t       IPv6_ADDR_LEN);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_MAX_SEGMENT_SIZE:\n\t\t\tfnode_conn->max_segment_size =\n\t\t\t\t\t*(unsigned *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_LOCAL_PORT:\n\t\t\tfnode_conn->local_port =\n\t\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IPV4_TOS:\n\t\t\tfnode_conn->ipv4_tos = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IPV6_TC:\n\t\t\tfnode_conn->ipv6_traffic_class = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_IPV6_FLOW_LABEL:\n\t\t\tfnode_conn->ipv6_flow_label = fnode_param->value[0];\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_NAME:\n\t\t\trc = iscsi_switch_str_param(&fnode_sess->targetname,\n\t\t\t\t\t\t    (char *)fnode_param->value);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TPGT:\n\t\t\tfnode_sess->tpgt = *(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_LINK_LOCAL_IPV6:\n\t\t\tmemcpy(fnode_conn->link_local_ipv6_addr,\n\t\t\t       fnode_param->value, IPv6_ADDR_LEN);\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_DISCOVERY_PARENT_IDX:\n\t\t\tfnode_sess->discovery_parent_idx =\n\t\t\t\t\t\t*(uint16_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_XMIT_WSF:\n\t\t\tfnode_conn->tcp_xmit_wsf =\n\t\t\t\t\t\t*(uint8_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_TCP_RECV_WSF:\n\t\t\tfnode_conn->tcp_recv_wsf =\n\t\t\t\t\t\t*(uint8_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_STATSN:\n\t\t\tfnode_conn->statsn = *(uint32_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_EXP_STATSN:\n\t\t\tfnode_conn->exp_statsn =\n\t\t\t\t\t\t*(uint32_t *)fnode_param->value;\n\t\t\tbreak;\n\t\tcase ISCSI_FLASHNODE_CHAP_OUT_IDX:\n\t\t\tchap_out_idx = *(uint16_t *)fnode_param->value;\n\t\t\tif (!qla4xxx_get_uni_chap_at_index(ha,\n\t\t\t\t\t\t\t   chap_tbl.name,\n\t\t\t\t\t\t\t   chap_tbl.secret,\n\t\t\t\t\t\t\t   chap_out_idx)) {\n\t\t\t\tfnode_sess->chap_out_idx = chap_out_idx;\n\t\t\t\t \n\t\t\t\tfnode_sess->chap_auth_en = QL4_PARAM_ENABLE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t   \"%s: No such sysfs attribute\\n\", __func__);\n\t\t\trc = -ENOSYS;\n\t\t\tgoto exit_set_param;\n\t\t}\n\t}\n\n\trc = qla4xxx_sysfs_ddb_apply(fnode_sess, fnode_conn);\n\nexit_set_param:\n\treturn rc;\n}\n\n \nstatic int qla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess)\n{\n\tstruct Scsi_Host *shost = iscsi_flash_session_to_shost(fnode_sess);\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tuint32_t dev_db_start_offset;\n\tuint32_t dev_db_end_offset;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint16_t *ddb_cookie = NULL;\n\tsize_t ddb_size = 0;\n\tvoid *pddb = NULL;\n\tint target_id;\n\tint rc = 0;\n\n\tif (fnode_sess->is_boot_target) {\n\t\trc = -EPERM;\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Deletion of boot target entry is not permitted.\\n\",\n\t\t\t\t  __func__));\n\t\tgoto exit_ddb_del;\n\t}\n\n\tif (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT)\n\t\tgoto sysfs_ddb_del;\n\n\tif (is_qla40XX(ha)) {\n\t\tdev_db_start_offset = FLASH_OFFSET_DB_INFO;\n\t\tdev_db_end_offset = FLASH_OFFSET_DB_END;\n\t\tdev_db_start_offset += (fnode_sess->target_id *\n\t\t\t\t       sizeof(*fw_ddb_entry));\n\t\tddb_size = sizeof(*fw_ddb_entry);\n\t} else {\n\t\tdev_db_start_offset = FLASH_RAW_ACCESS_ADDR +\n\t\t\t\t      (ha->hw.flt_region_ddb << 2);\n\t\t \n\t\tif (ha->port_num == 1)\n\t\t\tdev_db_start_offset += (ha->hw.flt_ddb_size / 2);\n\n\t\tdev_db_end_offset = dev_db_start_offset +\n\t\t\t\t    (ha->hw.flt_ddb_size / 2);\n\n\t\tdev_db_start_offset += (fnode_sess->target_id *\n\t\t\t\t       sizeof(*fw_ddb_entry));\n\t\tdev_db_start_offset += offsetof(struct dev_db_entry, cookie);\n\n\t\tddb_size = sizeof(*ddb_cookie);\n\t}\n\n\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s: start offset=%u, end offset=%u\\n\",\n\t\t\t  __func__, dev_db_start_offset, dev_db_end_offset));\n\n\tif (dev_db_start_offset > dev_db_end_offset) {\n\t\trc = -EIO;\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"%s:Invalid DDB index %u\\n\",\n\t\t\t\t  __func__, fnode_sess->target_id));\n\t\tgoto exit_ddb_del;\n\t}\n\n\tpddb = dma_alloc_coherent(&ha->pdev->dev, ddb_size,\n\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!pddb) {\n\t\trc = -ENOMEM;\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\tgoto exit_ddb_del;\n\t}\n\n\tif (is_qla40XX(ha)) {\n\t\tfw_ddb_entry = pddb;\n\t\tmemset(fw_ddb_entry, 0, ddb_size);\n\t\tddb_cookie = &fw_ddb_entry->cookie;\n\t} else {\n\t\tddb_cookie = pddb;\n\t}\n\n\t \n\t*ddb_cookie = 0xFFEE;\n\tqla4xxx_set_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,\n\t\t\t  ddb_size, FLASH_OPT_RMW_COMMIT);\n\nsysfs_ddb_del:\n\ttarget_id = fnode_sess->target_id;\n\tiscsi_destroy_flashnode_sess(fnode_sess);\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"%s: session and conn entries for flashnode %u of host %lu deleted\\n\",\n\t\t   __func__, target_id, ha->host_no);\nexit_ddb_del:\n\tif (pddb)\n\t\tdma_free_coherent(&ha->pdev->dev, ddb_size, pddb,\n\t\t\t\t  fw_ddb_entry_dma);\n\treturn rc;\n}\n\n \nint qla4xxx_sysfs_ddb_export(struct scsi_qla_host *ha)\n{\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tuint16_t max_ddbs;\n\tuint16_t idx = 0;\n\tint ret = QLA_SUCCESS;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t\t  sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha,\n\t\t\t\t  \"%s: Unable to allocate dma buffer\\n\",\n\t\t\t\t  __func__));\n\t\treturn -ENOMEM;\n\t}\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_PRST_DEV_DB_ENTRIES :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfor (idx = 0; idx < max_ddbs; idx++) {\n\t\tif (qla4xxx_flashdb_by_index(ha, fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t     idx))\n\t\t\tcontinue;\n\n\t\tret = qla4xxx_sysfs_ddb_tgt_create(ha, fw_ddb_entry, &idx, 0);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry), fw_ddb_entry,\n\t\t\t  fw_ddb_entry_dma);\n\n\treturn ret;\n}\n\nstatic void qla4xxx_sysfs_ddb_remove(struct scsi_qla_host *ha)\n{\n\tiscsi_destroy_all_flashnode(ha->host);\n}\n\n \nvoid qla4xxx_build_ddb_list(struct scsi_qla_host *ha, int is_reset)\n{\n\tuint16_t tmo = 0;\n\tstruct list_head list_st, list_nt;\n\tstruct qla_ddb_index  *st_ddb_idx, *st_ddb_idx_tmp;\n\tunsigned long wtime;\n\n\tif (!test_bit(AF_LINK_UP, &ha->flags)) {\n\t\tset_bit(AF_BUILD_DDB_LIST, &ha->flags);\n\t\tha->is_reset = is_reset;\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&list_st);\n\tINIT_LIST_HEAD(&list_nt);\n\n\tqla4xxx_build_st_list(ha, &list_st);\n\n\t \n\tqla4xxx_wait_for_ip_configuration(ha);\n\n\t \n\tlist_for_each_entry_safe(st_ddb_idx, st_ddb_idx_tmp, &list_st, list) {\n\t\tqla4xxx_conn_open(ha, st_ddb_idx->fw_ddb_idx);\n\t}\n\n\t \n\ttmo = ((ha->def_timeout > LOGIN_TOV) &&\n\t       (ha->def_timeout < LOGIN_TOV * 10) ?\n\t       ha->def_timeout : LOGIN_TOV);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Default time to wait for build ddb %d\\n\", tmo));\n\n\twtime = jiffies + (HZ * tmo);\n\tdo {\n\t\tif (list_empty(&list_st))\n\t\t\tbreak;\n\n\t\tqla4xxx_remove_failed_ddb(ha, &list_st);\n\t\tschedule_timeout_uninterruptible(HZ / 10);\n\t} while (time_after(wtime, jiffies));\n\n\n\tqla4xxx_build_nt_list(ha, &list_nt, &list_st, is_reset);\n\n\tqla4xxx_free_ddb_list(&list_st);\n\tqla4xxx_free_ddb_list(&list_nt);\n\n\tqla4xxx_free_ddb_index(ha);\n}\n\n \nstatic void qla4xxx_wait_login_resp_boot_tgt(struct scsi_qla_host *ha)\n{\n\tstruct ddb_entry *ddb_entry;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tunsigned long wtime;\n\tuint32_t ddb_state;\n\tint max_ddbs, idx, ret;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto exit_login_resp;\n\t}\n\n\twtime = jiffies + (HZ * BOOT_LOGIN_RESP_TOV);\n\n\tfor (idx = 0; idx < max_ddbs; idx++) {\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif (ddb_entry == NULL)\n\t\t\tcontinue;\n\n\t\tif (test_bit(DF_BOOT_TGT, &ddb_entry->flags)) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"%s: DDB index [%d]\\n\", __func__,\n\t\t\t\t\t  ddb_entry->fw_ddb_index));\n\t\t\tdo {\n\t\t\t\tret = qla4xxx_get_fwddb_entry(ha,\n\t\t\t\t\t\tddb_entry->fw_ddb_index,\n\t\t\t\t\t\tfw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t\tNULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t\tNULL, NULL);\n\t\t\t\tif (ret == QLA_ERROR)\n\t\t\t\t\tgoto exit_login_resp;\n\n\t\t\t\tif ((ddb_state == DDB_DS_SESSION_ACTIVE) ||\n\t\t\t\t    (ddb_state == DDB_DS_SESSION_FAILED))\n\t\t\t\t\tbreak;\n\n\t\t\t\tschedule_timeout_uninterruptible(HZ);\n\n\t\t\t} while ((time_after(wtime, jiffies)));\n\n\t\t\tif (!time_after(wtime, jiffies)) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"%s: Login response wait timer expired\\n\",\n\t\t\t\t\t\t  __func__));\n\t\t\t\t goto exit_login_resp;\n\t\t\t}\n\t\t}\n\t}\n\nexit_login_resp:\n\tif (fw_ddb_entry)\n\t\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\n}\n\n \nstatic int qla4xxx_probe_adapter(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *ent)\n{\n\tint ret = -ENODEV, status;\n\tstruct Scsi_Host *host;\n\tstruct scsi_qla_host *ha;\n\tuint8_t init_retry_count = 0;\n\tchar buf[34];\n\tstruct qla4_8xxx_legacy_intr_set *nx_legacy_intr;\n\tuint32_t dev_state;\n\n\tif (pci_enable_device(pdev))\n\t\treturn -1;\n\n\thost = iscsi_host_alloc(&qla4xxx_driver_template, sizeof(*ha), 0);\n\tif (host == NULL) {\n\t\tprintk(KERN_WARNING\n\t\t       \"qla4xxx: Couldn't allocate host from scsi layer!\\n\");\n\t\tgoto probe_disable_device;\n\t}\n\n\t \n\tha = to_qla_host(host);\n\tmemset(ha, 0, sizeof(*ha));\n\n\t \n\tha->pdev = pdev;\n\tha->host = host;\n\tha->host_no = host->host_no;\n\tha->func_num = PCI_FUNC(ha->pdev->devfn);\n\n\t \n\tif (is_qla8022(ha)) {\n\t\tha->isp_ops = &qla4_82xx_isp_ops;\n\t\tha->reg_tbl = (uint32_t *) qla4_82xx_reg_tbl;\n\t\tha->qdr_sn_window = -1;\n\t\tha->ddr_mn_window = -1;\n\t\tha->curr_window = 255;\n\t\tnx_legacy_intr = &legacy_intr[ha->func_num];\n\t\tha->nx_legacy_intr.int_vec_bit = nx_legacy_intr->int_vec_bit;\n\t\tha->nx_legacy_intr.tgt_status_reg =\n\t\t\tnx_legacy_intr->tgt_status_reg;\n\t\tha->nx_legacy_intr.tgt_mask_reg = nx_legacy_intr->tgt_mask_reg;\n\t\tha->nx_legacy_intr.pci_int_reg = nx_legacy_intr->pci_int_reg;\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tha->isp_ops = &qla4_83xx_isp_ops;\n\t\tha->reg_tbl = (uint32_t *)qla4_83xx_reg_tbl;\n\t} else {\n\t\tha->isp_ops = &qla4xxx_isp_ops;\n\t}\n\n\tif (is_qla80XX(ha)) {\n\t\trwlock_init(&ha->hw_lock);\n\t\tha->pf_bit = ha->func_num << 16;\n\t\t \n\t\tpdev->needs_freset = 1;\n\t}\n\n\t \n\tret = ha->isp_ops->iospace_config(ha);\n\tif (ret)\n\t\tgoto probe_failed_ioconfig;\n\n\tql4_printk(KERN_INFO, ha, \"Found an ISP%04x, irq %d, iobase 0x%p\\n\",\n\t\t   pdev->device, pdev->irq, ha->reg);\n\n\tqla4xxx_config_dma_addressing(ha);\n\n\t \n\tINIT_LIST_HEAD(&ha->free_srb_q);\n\n\tmutex_init(&ha->mbox_sem);\n\tmutex_init(&ha->chap_sem);\n\tinit_completion(&ha->mbx_intr_comp);\n\tinit_completion(&ha->disable_acb_comp);\n\tinit_completion(&ha->idc_comp);\n\tinit_completion(&ha->link_up_comp);\n\n\tspin_lock_init(&ha->hardware_lock);\n\tspin_lock_init(&ha->work_lock);\n\n\t \n\tINIT_LIST_HEAD(&ha->work_list);\n\n\t \n\tif (qla4xxx_mem_alloc(ha)) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"[ERROR] Failed to allocate memory for adapter\\n\");\n\n\t\tret = -ENOMEM;\n\t\tgoto probe_failed;\n\t}\n\n\thost->cmd_per_lun = 3;\n\thost->max_channel = 0;\n\thost->max_lun = MAX_LUNS - 1;\n\thost->max_id = MAX_TARGETS;\n\thost->max_cmd_len = IOCB_MAX_CDB_LEN;\n\thost->can_queue = MAX_SRBS ;\n\thost->transportt = qla4xxx_scsi_transport;\n\n\tpci_set_drvdata(pdev, ha);\n\n\tret = scsi_add_host(host, &pdev->dev);\n\tif (ret)\n\t\tgoto probe_failed;\n\n\tif (is_qla80XX(ha))\n\t\tqla4_8xxx_get_flash_info(ha);\n\n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tqla4_83xx_read_reset_template(ha);\n\t\t \n\t\tif (ql4xdontresethba == 1)\n\t\t\tqla4_83xx_set_idc_dontreset(ha);\n\t}\n\n\t \n\tstatus = qla4xxx_initialize_adapter(ha, INIT_ADAPTER);\n\n\t \n\tif (is_qla80XX(ha) && (status == QLA_ERROR))\n\t\tgoto skip_retry_init;\n\n\twhile ((!test_bit(AF_ONLINE, &ha->flags)) &&\n\t    init_retry_count++ < MAX_INIT_RETRIES) {\n\n\t\tif (is_qla80XX(ha)) {\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tdev_state = qla4_8xxx_rd_direct(ha,\n\t\t\t\t\t\t\tQLA8XXX_CRB_DEV_STATE);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tif (dev_state == QLA8XXX_DEV_FAILED) {\n\t\t\t\tql4_printk(KERN_WARNING, ha, \"%s: don't retry \"\n\t\t\t\t    \"initialize adapter. H/W is in failed state\\n\",\n\t\t\t\t    __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDEBUG2(printk(\"scsi: %s: retrying adapter initialization \"\n\t\t\t      \"(%d)\\n\", __func__, init_retry_count));\n\n\t\tif (ha->isp_ops->reset_chip(ha) == QLA_ERROR)\n\t\t\tcontinue;\n\n\t\tstatus = qla4xxx_initialize_adapter(ha, INIT_ADAPTER);\n\t\tif (is_qla80XX(ha) && (status == QLA_ERROR)) {\n\t\t\tif (qla4_8xxx_check_init_adapter_retry(ha) == QLA_ERROR)\n\t\t\t\tgoto skip_retry_init;\n\t\t}\n\t}\n\nskip_retry_init:\n\tif (!test_bit(AF_ONLINE, &ha->flags)) {\n\t\tql4_printk(KERN_WARNING, ha, \"Failed to initialize adapter\\n\");\n\n\t\tif ((is_qla8022(ha) && ql4xdontresethba) ||\n\t\t    ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t\t     qla4_83xx_idc_dontreset(ha))) {\n\t\t\t \n\t\t\tDEBUG2(printk(KERN_ERR \"HW STATE: FAILED\\n\"));\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t}\n\t\tret = -ENODEV;\n\t\tgoto remove_host;\n\t}\n\n\t \n\tDEBUG2(printk(\"scsi: %s: Starting kernel thread for \"\n\t\t      \"qla4xxx_dpc\\n\", __func__));\n\tsprintf(buf, \"qla4xxx_%lu_dpc\", ha->host_no);\n\tha->dpc_thread = create_singlethread_workqueue(buf);\n\tif (!ha->dpc_thread) {\n\t\tql4_printk(KERN_WARNING, ha, \"Unable to start DPC thread!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_host;\n\t}\n\tINIT_WORK(&ha->dpc_work, qla4xxx_do_dpc);\n\n\tha->task_wq = alloc_workqueue(\"qla4xxx_%lu_task\", WQ_MEM_RECLAIM, 1,\n\t\t\t\t      ha->host_no);\n\tif (!ha->task_wq) {\n\t\tql4_printk(KERN_WARNING, ha, \"Unable to start task thread!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto remove_host;\n\t}\n\n\t \n\tif (is_qla40XX(ha)) {\n\t\tret = qla4xxx_request_irqs(ha);\n\t\tif (ret) {\n\t\t\tql4_printk(KERN_WARNING, ha, \"Failed to reserve \"\n\t\t\t    \"interrupt %d already in use.\\n\", pdev->irq);\n\t\t\tgoto remove_host;\n\t\t}\n\t}\n\n\tpci_save_state(ha->pdev);\n\tha->isp_ops->enable_intrs(ha);\n\n\t \n\tqla4xxx_start_timer(ha, 1);\n\n\tset_bit(AF_INIT_DONE, &ha->flags);\n\n\tqla4_8xxx_alloc_sysfs_attr(ha);\n\n\tprintk(KERN_INFO\n\t       \" QLogic iSCSI HBA Driver version: %s\\n\"\n\t       \"  QLogic ISP%04x @ %s, host#=%ld, fw=%02d.%02d.%02d.%02d\\n\",\n\t       qla4xxx_version_str, ha->pdev->device, pci_name(ha->pdev),\n\t       ha->host_no, ha->fw_info.fw_major, ha->fw_info.fw_minor,\n\t       ha->fw_info.fw_patch, ha->fw_info.fw_build);\n\n\t \n\tif (is_qla80XX(ha))\n\t\tqla4_8xxx_set_param(ha, SET_DRVR_VERSION);\n\n\tif (qla4xxx_setup_boot_info(ha))\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: No iSCSI boot target configured\\n\", __func__);\n\n\tset_bit(DPC_SYSFS_DDB_EXPORT, &ha->dpc_flags);\n\t \n\tqla4xxx_build_ddb_list(ha, INIT_ADAPTER);\n\tiscsi_host_for_each_session(ha->host, qla4xxx_login_flash_ddb);\n\tqla4xxx_wait_login_resp_boot_tgt(ha);\n\n\tqla4xxx_create_chap_list(ha);\n\n\tqla4xxx_create_ifaces(ha);\n\treturn 0;\n\nremove_host:\n\tscsi_remove_host(ha->host);\n\nprobe_failed:\n\tqla4xxx_free_adapter(ha);\n\nprobe_failed_ioconfig:\n\tscsi_host_put(ha->host);\n\nprobe_disable_device:\n\tpci_disable_device(pdev);\n\n\treturn ret;\n}\n\n \nstatic void qla4xxx_prevent_other_port_reinit(struct scsi_qla_host *ha)\n{\n\tstruct scsi_qla_host *other_ha = NULL;\n\tstruct pci_dev *other_pdev = NULL;\n\tint fn = ISP4XXX_PCI_FN_2;\n\n\t \n\tif (PCI_FUNC(ha->pdev->devfn) & BIT_1)\n\t\tfn = ISP4XXX_PCI_FN_1;\n\n\tother_pdev =\n\t\tpci_get_domain_bus_and_slot(pci_domain_nr(ha->pdev->bus),\n\t\tha->pdev->bus->number, PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),\n\t\tfn));\n\n\t \n\tif (other_pdev) {\n\t\tif (atomic_read(&other_pdev->enable_cnt)) {\n\t\t\tother_ha = pci_get_drvdata(other_pdev);\n\t\t\tif (other_ha) {\n\t\t\t\tset_bit(AF_HA_REMOVAL, &other_ha->flags);\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: \"\n\t\t\t\t    \"Prevent %s reinit\\n\", __func__,\n\t\t\t\t    dev_name(&other_ha->pdev->dev)));\n\t\t\t}\n\t\t}\n\t\tpci_dev_put(other_pdev);\n\t}\n}\n\nstatic void qla4xxx_destroy_ddb(struct scsi_qla_host *ha,\n\t\tstruct ddb_entry *ddb_entry)\n{\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_entry_dma;\n\tunsigned long wtime;\n\tuint32_t ddb_state;\n\tint options;\n\tint status;\n\n\toptions = LOGOUT_OPTION_CLOSE_SESSION;\n\tif (qla4xxx_session_logout_ddb(ha, ddb_entry, options) == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Logout failed\\n\", __func__);\n\t\tgoto clear_ddb;\n\t}\n\n\tfw_ddb_entry = dma_alloc_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t\t\t  &fw_ddb_entry_dma, GFP_KERNEL);\n\tif (!fw_ddb_entry) {\n\t\tql4_printk(KERN_ERR, ha,\n\t\t\t   \"%s: Unable to allocate dma buffer\\n\", __func__);\n\t\tgoto clear_ddb;\n\t}\n\n\twtime = jiffies + (HZ * LOGOUT_TOV);\n\tdo {\n\t\tstatus = qla4xxx_get_fwddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t\t\t fw_ddb_entry, fw_ddb_entry_dma,\n\t\t\t\t\t\t NULL, NULL, &ddb_state, NULL,\n\t\t\t\t\t\t NULL, NULL);\n\t\tif (status == QLA_ERROR)\n\t\t\tgoto free_ddb;\n\n\t\tif ((ddb_state == DDB_DS_NO_CONNECTION_ACTIVE) ||\n\t\t    (ddb_state == DDB_DS_SESSION_FAILED))\n\t\t\tgoto free_ddb;\n\n\t\tschedule_timeout_uninterruptible(HZ);\n\t} while ((time_after(wtime, jiffies)));\n\nfree_ddb:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*fw_ddb_entry),\n\t\t\t  fw_ddb_entry, fw_ddb_entry_dma);\nclear_ddb:\n\tqla4xxx_clear_ddb_entry(ha, ddb_entry->fw_ddb_index);\n}\n\nstatic void qla4xxx_destroy_fw_ddb_session(struct scsi_qla_host *ha)\n{\n\tstruct ddb_entry *ddb_entry;\n\tint idx;\n\n\tfor (idx = 0; idx < MAX_DDB_ENTRIES; idx++) {\n\n\t\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, idx);\n\t\tif ((ddb_entry != NULL) &&\n\t\t    (ddb_entry->ddb_type == FLASH_DDB)) {\n\n\t\t\tqla4xxx_destroy_ddb(ha, ddb_entry);\n\t\t\t \n\t\t\ttry_module_get(qla4xxx_iscsi_transport.owner);\n\t\t\tiscsi_destroy_endpoint(ddb_entry->conn->ep);\n\t\t\tqla4xxx_free_ddb(ha, ddb_entry);\n\t\t\tiscsi_session_teardown(ddb_entry->sess);\n\t\t}\n\t}\n}\n \nstatic void qla4xxx_remove_adapter(struct pci_dev *pdev)\n{\n\tstruct scsi_qla_host *ha;\n\n\t \n\tif (!pci_is_enabled(pdev))\n\t\treturn;\n\n\tha = pci_get_drvdata(pdev);\n\n\tif (is_qla40XX(ha))\n\t\tqla4xxx_prevent_other_port_reinit(ha);\n\n\t \n\tqla4xxx_destroy_ifaces(ha);\n\n\tif ((!ql4xdisablesysfsboot) && ha->boot_kset)\n\t\tiscsi_boot_destroy_kset(ha->boot_kset);\n\n\tqla4xxx_destroy_fw_ddb_session(ha);\n\tqla4_8xxx_free_sysfs_attr(ha);\n\n\tqla4xxx_sysfs_ddb_remove(ha);\n\tscsi_remove_host(ha->host);\n\n\tqla4xxx_free_adapter(ha);\n\n\tscsi_host_put(ha->host);\n\n\tpci_disable_device(pdev);\n}\n\n \nstatic void qla4xxx_config_dma_addressing(struct scsi_qla_host *ha)\n{\n\t \n\tif (dma_set_mask_and_coherent(&ha->pdev->dev, DMA_BIT_MASK(64))) {\n\t\tdev_dbg(&ha->pdev->dev,\n\t\t\t  \"Failed to set 64 bit PCI consistent mask; \"\n\t\t\t   \"using 32 bit.\\n\");\n\t\tdma_set_mask_and_coherent(&ha->pdev->dev, DMA_BIT_MASK(32));\n\t}\n}\n\nstatic int qla4xxx_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct iscsi_cls_session *cls_sess;\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb;\n\tint queue_depth = QL4_DEF_QDEPTH;\n\n\tcls_sess = starget_to_session(sdev->sdev_target);\n\tsess = cls_sess->dd_data;\n\tddb = sess->dd_data;\n\n\tsdev->hostdata = ddb;\n\n\tif (ql4xmaxqdepth != 0 && ql4xmaxqdepth <= 0xffffU)\n\t\tqueue_depth = ql4xmaxqdepth;\n\n\tscsi_change_queue_depth(sdev, queue_depth);\n\treturn 0;\n}\n\n \nstruct srb *qla4xxx_del_from_active_array(struct scsi_qla_host *ha,\n    uint32_t index)\n{\n\tstruct srb *srb = NULL;\n\tstruct scsi_cmnd *cmd = NULL;\n\n\tcmd = scsi_host_find_tag(ha->host, index);\n\tif (!cmd)\n\t\treturn srb;\n\n\tsrb = qla4xxx_cmd_priv(cmd)->srb;\n\tif (!srb)\n\t\treturn srb;\n\n\t \n\tif (srb->flags & SRB_DMA_VALID) {\n\t\tha->iocb_cnt -= srb->iocb_cnt;\n\t\tif (srb->cmd)\n\t\t\tsrb->cmd->host_scribble =\n\t\t\t\t(unsigned char *)(unsigned long) MAX_SRBS;\n\t}\n\treturn srb;\n}\n\n \nstatic int qla4xxx_eh_wait_on_command(struct scsi_qla_host *ha,\n\t\t\t\t      struct scsi_cmnd *cmd)\n{\n\tint done = 0;\n\tstruct srb *rp;\n\tuint32_t max_wait_time = EH_WAIT_CMD_TOV;\n\tint ret = SUCCESS;\n\n\t \n\tif (unlikely(pci_channel_offline(ha->pdev)) ||\n\t    (test_bit(AF_EEH_BUSY, &ha->flags))) {\n\t\tql4_printk(KERN_WARNING, ha, \"scsi%ld: Return from %s\\n\",\n\t\t    ha->host_no, __func__);\n\t\treturn ret;\n\t}\n\n\tdo {\n\t\t \n\t\trp = qla4xxx_cmd_priv(cmd)->srb;\n\t\tif (rp == NULL) {\n\t\t\tdone++;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(2000);\n\t} while (max_wait_time--);\n\n\treturn done;\n}\n\n \nstatic int qla4xxx_wait_for_hba_online(struct scsi_qla_host *ha)\n{\n\tunsigned long wait_online;\n\n\twait_online = jiffies + (HBA_ONLINE_TOV * HZ);\n\twhile (time_before(jiffies, wait_online)) {\n\n\t\tif (adapter_up(ha))\n\t\t\treturn QLA_SUCCESS;\n\n\t\tmsleep(2000);\n\t}\n\n\treturn QLA_ERROR;\n}\n\n \nstatic int qla4xxx_eh_wait_for_commands(struct scsi_qla_host *ha,\n\t\t\t\t\tstruct scsi_target *stgt,\n\t\t\t\t\tstruct scsi_device *sdev)\n{\n\tint cnt;\n\tint status = 0;\n\tstruct scsi_cmnd *cmd;\n\n\t \n\tfor (cnt = 0; cnt < ha->host->can_queue; cnt++) {\n\t\tcmd = scsi_host_find_tag(ha->host, cnt);\n\t\tif (cmd && stgt == scsi_target(cmd->device) &&\n\t\t    (!sdev || sdev == cmd->device)) {\n\t\t\tif (!qla4xxx_eh_wait_on_command(ha, cmd)) {\n\t\t\t\tstatus++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn status;\n}\n\n \nstatic int qla4xxx_eh_abort(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\n\tunsigned int id = cmd->device->id;\n\tuint64_t lun = cmd->device->lun;\n\tunsigned long flags;\n\tstruct srb *srb = NULL;\n\tint ret = SUCCESS;\n\tint wait = 0;\n\tint rval;\n\n\tql4_printk(KERN_INFO, ha, \"scsi%ld:%d:%llu: Abort command issued cmd=%p, cdb=0x%x\\n\",\n\t\t   ha->host_no, id, lun, cmd, cmd->cmnd[0]);\n\n\trval = qla4xxx_isp_check_reg(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"PCI/Register disconnect, exiting.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tsrb = qla4xxx_cmd_priv(cmd)->srb;\n\tif (!srb) {\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\tql4_printk(KERN_INFO, ha, \"scsi%ld:%d:%llu: Specified command has already completed.\\n\",\n\t\t\t   ha->host_no, id, lun);\n\t\treturn SUCCESS;\n\t}\n\tkref_get(&srb->srb_ref);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tif (qla4xxx_abort_task(ha, srb) != QLA_SUCCESS) {\n\t\tDEBUG3(printk(\"scsi%ld:%d:%llu: Abort_task mbx failed.\\n\",\n\t\t    ha->host_no, id, lun));\n\t\tret = FAILED;\n\t} else {\n\t\tDEBUG3(printk(\"scsi%ld:%d:%llu: Abort_task mbx success.\\n\",\n\t\t    ha->host_no, id, lun));\n\t\twait = 1;\n\t}\n\n\tkref_put(&srb->srb_ref, qla4xxx_srb_compl);\n\n\t \n\tif (wait) {\n\t\tif (!qla4xxx_eh_wait_on_command(ha, cmd)) {\n\t\t\tDEBUG2(printk(\"scsi%ld:%d:%llu: Abort handler timed out\\n\",\n\t\t\t    ha->host_no, id, lun));\n\t\t\tret = FAILED;\n\t\t}\n\t}\n\n\tql4_printk(KERN_INFO, ha,\n\t    \"scsi%ld:%d:%llu: Abort command - %s\\n\",\n\t    ha->host_no, id, lun, (ret == SUCCESS) ? \"succeeded\" : \"failed\");\n\n\treturn ret;\n}\n\n \nstatic int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\n\tstruct ddb_entry *ddb_entry = cmd->device->hostdata;\n\tint ret = FAILED, stat;\n\tint rval;\n\n\tif (!ddb_entry)\n\t\treturn ret;\n\n\tret = iscsi_block_scsi_eh(cmd);\n\tif (ret)\n\t\treturn ret;\n\tret = FAILED;\n\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"scsi%ld:%d:%d:%llu: DEVICE RESET ISSUED.\\n\", ha->host_no,\n\t\t   cmd->device->channel, cmd->device->id, cmd->device->lun);\n\n\tDEBUG2(printk(KERN_INFO\n\t\t      \"scsi%ld: DEVICE_RESET cmd=%p jiffies = 0x%lx, to=%x,\"\n\t\t      \"dpc_flags=%lx, status=%x allowed=%d\\n\", ha->host_no,\n\t\t      cmd, jiffies, scsi_cmd_to_rq(cmd)->timeout / HZ,\n\t\t      ha->dpc_flags, cmd->result, cmd->allowed));\n\n\trval = qla4xxx_isp_check_reg(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"PCI/Register disconnect, exiting.\\n\");\n\t\treturn FAILED;\n\t}\n\n\t \n\tstat = qla4xxx_reset_lun(ha, ddb_entry, cmd->device->lun);\n\tif (stat != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"DEVICE RESET FAILED. %d\\n\", stat);\n\t\tgoto eh_dev_reset_done;\n\t}\n\n\tif (qla4xxx_eh_wait_for_commands(ha, scsi_target(cmd->device),\n\t\t\t\t\t cmd->device)) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"DEVICE RESET FAILED - waiting for \"\n\t\t\t   \"commands.\\n\");\n\t\tgoto eh_dev_reset_done;\n\t}\n\n\t \n\tif (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun,\n\t\tMM_LUN_RESET) != QLA_SUCCESS)\n\t\tgoto eh_dev_reset_done;\n\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"scsi(%ld:%d:%d:%llu): DEVICE RESET SUCCEEDED.\\n\",\n\t\t   ha->host_no, cmd->device->channel, cmd->device->id,\n\t\t   cmd->device->lun);\n\n\tret = SUCCESS;\n\neh_dev_reset_done:\n\n\treturn ret;\n}\n\n \nstatic int qla4xxx_eh_target_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(cmd->device->host);\n\tstruct ddb_entry *ddb_entry = cmd->device->hostdata;\n\tint stat, ret;\n\tint rval;\n\n\tif (!ddb_entry)\n\t\treturn FAILED;\n\n\tret = iscsi_block_scsi_eh(cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t       \"WARM TARGET RESET ISSUED.\\n\");\n\n\tDEBUG2(printk(KERN_INFO\n\t\t      \"scsi%ld: TARGET_DEVICE_RESET cmd=%p jiffies = 0x%lx, \"\n\t\t      \"to=%x,dpc_flags=%lx, status=%x allowed=%d\\n\",\n\t\t      ha->host_no, cmd, jiffies, scsi_cmd_to_rq(cmd)->timeout / HZ,\n\t\t      ha->dpc_flags, cmd->result, cmd->allowed));\n\n\trval = qla4xxx_isp_check_reg(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"PCI/Register disconnect, exiting.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tstat = qla4xxx_reset_target(ha, ddb_entry);\n\tif (stat != QLA_SUCCESS) {\n\t\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t\t       \"WARM TARGET RESET FAILED.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tif (qla4xxx_eh_wait_for_commands(ha, scsi_target(cmd->device),\n\t\t\t\t\t NULL)) {\n\t\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t\t       \"WARM TARGET DEVICE RESET FAILED - \"\n\t\t\t       \"waiting for commands.\\n\");\n\t\treturn FAILED;\n\t}\n\n\t \n\tif (qla4xxx_send_marker_iocb(ha, ddb_entry, cmd->device->lun,\n\t\tMM_TGT_WARM_RESET) != QLA_SUCCESS) {\n\t\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t\t       \"WARM TARGET DEVICE RESET FAILED - \"\n\t\t\t       \"marker iocb failed.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tstarget_printk(KERN_INFO, scsi_target(cmd->device),\n\t\t       \"WARM TARGET RESET SUCCEEDED.\\n\");\n\treturn SUCCESS;\n}\n\n \nstatic int qla4xxx_is_eh_active(struct Scsi_Host *shost)\n{\n\tif (shost->shost_state == SHOST_RECOVERY)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int qla4xxx_eh_host_reset(struct scsi_cmnd *cmd)\n{\n\tint return_status = FAILED;\n\tstruct scsi_qla_host *ha;\n\tint rval;\n\n\tha = to_qla_host(cmd->device->host);\n\n\trval = qla4xxx_isp_check_reg(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"PCI/Register disconnect, exiting.\\n\");\n\t\treturn FAILED;\n\t}\n\n\tif ((is_qla8032(ha) || is_qla8042(ha)) && ql4xdontresethba)\n\t\tqla4_83xx_set_idc_dontreset(ha);\n\n\t \n\tif (ql4xdontresethba ||\n\t    ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t     qla4_83xx_idc_dontreset(ha))) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Don't Reset HBA\\n\",\n\t\t     ha->host_no, __func__));\n\n\t\t \n\t\tif (qla4xxx_is_eh_active(cmd->device->host))\n\t\t\tqla4xxx_abort_active_cmds(ha, DID_ABORT << 16);\n\n\t\treturn FAILED;\n\t}\n\n\tql4_printk(KERN_INFO, ha,\n\t\t   \"scsi(%ld:%d:%d:%llu): HOST RESET ISSUED.\\n\", ha->host_no,\n\t\t   cmd->device->channel, cmd->device->id, cmd->device->lun);\n\n\tif (qla4xxx_wait_for_hba_online(ha) != QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld:%d: %s: Unable to reset host.  Adapter \"\n\t\t\t      \"DEAD.\\n\", ha->host_no, cmd->device->channel,\n\t\t\t      __func__));\n\n\t\treturn FAILED;\n\t}\n\n\tif (!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\t\tif (is_qla80XX(ha))\n\t\t\tset_bit(DPC_RESET_HA_FW_CONTEXT, &ha->dpc_flags);\n\t\telse\n\t\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t}\n\n\tif (qla4xxx_recover_adapter(ha) == QLA_SUCCESS)\n\t\treturn_status = SUCCESS;\n\n\tql4_printk(KERN_INFO, ha, \"HOST RESET %s.\\n\",\n\t\t   return_status == FAILED ? \"FAILED\" : \"SUCCEEDED\");\n\n\treturn return_status;\n}\n\nstatic int qla4xxx_context_reset(struct scsi_qla_host *ha)\n{\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tstruct addr_ctrl_blk_def *acb = NULL;\n\tuint32_t acb_len = sizeof(struct addr_ctrl_blk_def);\n\tint rval = QLA_SUCCESS;\n\tdma_addr_t acb_dma;\n\n\tacb = dma_alloc_coherent(&ha->pdev->dev,\n\t\t\t\t sizeof(struct addr_ctrl_blk_def),\n\t\t\t\t &acb_dma, GFP_KERNEL);\n\tif (!acb) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Unable to alloc acb\\n\",\n\t\t\t   __func__);\n\t\trval = -ENOMEM;\n\t\tgoto exit_port_reset;\n\t}\n\n\tmemset(acb, 0, acb_len);\n\n\trval = qla4xxx_get_acb(ha, acb_dma, PRIMARI_ACB, acb_len);\n\tif (rval != QLA_SUCCESS) {\n\t\trval = -EIO;\n\t\tgoto exit_free_acb;\n\t}\n\n\trval = qla4xxx_disable_acb(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\trval = -EIO;\n\t\tgoto exit_free_acb;\n\t}\n\n\twait_for_completion_timeout(&ha->disable_acb_comp,\n\t\t\t\t    DISABLE_ACB_TOV * HZ);\n\n\trval = qla4xxx_set_acb(ha, &mbox_cmd[0], &mbox_sts[0], acb_dma);\n\tif (rval != QLA_SUCCESS) {\n\t\trval = -EIO;\n\t\tgoto exit_free_acb;\n\t}\n\nexit_free_acb:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(struct addr_ctrl_blk_def),\n\t\t\t  acb, acb_dma);\nexit_port_reset:\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s %s\\n\", __func__,\n\t\t\t  rval == QLA_SUCCESS ? \"SUCCEEDED\" : \"FAILED\"));\n\treturn rval;\n}\n\nstatic int qla4xxx_host_reset(struct Scsi_Host *shost, int reset_type)\n{\n\tstruct scsi_qla_host *ha = to_qla_host(shost);\n\tint rval = QLA_SUCCESS;\n\tuint32_t idc_ctrl;\n\n\tif (ql4xdontresethba) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Don't Reset HBA\\n\",\n\t\t\t\t  __func__));\n\t\trval = -EPERM;\n\t\tgoto exit_host_reset;\n\t}\n\n\tif (test_bit(DPC_RESET_HA, &ha->dpc_flags))\n\t\tgoto recover_adapter;\n\n\tswitch (reset_type) {\n\tcase SCSI_ADAPTER_RESET:\n\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\tbreak;\n\tcase SCSI_FIRMWARE_RESET:\n\t\tif (!test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\t\t\tif (is_qla80XX(ha))\n\t\t\t\t \n\t\t\t\tset_bit(DPC_RESET_HA_FW_CONTEXT,\n\t\t\t\t\t&ha->dpc_flags);\n\t\t\telse {\n\t\t\t\trval = qla4xxx_context_reset(ha);\n\t\t\t\tgoto exit_host_reset;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\nrecover_adapter:\n\t \n\tif ((is_qla8032(ha) || is_qla8042(ha)) &&\n\t    test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\t\tidc_ctrl = qla4_83xx_rd_reg(ha, QLA83XX_IDC_DRV_CTRL);\n\t\tqla4_83xx_wr_reg(ha, QLA83XX_IDC_DRV_CTRL,\n\t\t\t\t (idc_ctrl | GRACEFUL_RESET_BIT1));\n\t}\n\n\trval = qla4xxx_recover_adapter(ha);\n\tif (rval != QLA_SUCCESS) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: recover adapter fail\\n\",\n\t\t\t\t  __func__));\n\t\trval = -EIO;\n\t}\n\nexit_host_reset:\n\treturn rval;\n}\n\n \nstatic pci_ers_result_t\nqla4xxx_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\n\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: error detected:state %x\\n\",\n\t    ha->host_no, __func__, state);\n\n\tif (!is_aer_supported(ha))\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\tclear_bit(AF_EEH_BUSY, &ha->flags);\n\t\treturn PCI_ERS_RESULT_CAN_RECOVER;\n\tcase pci_channel_io_frozen:\n\t\tset_bit(AF_EEH_BUSY, &ha->flags);\n\t\tqla4xxx_mailbox_premature_completion(ha);\n\t\tqla4xxx_free_irqs(ha);\n\t\tpci_disable_device(pdev);\n\t\t \n\t\tqla4xxx_abort_active_cmds(ha, DID_RESET << 16);\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\tcase pci_channel_io_perm_failure:\n\t\tset_bit(AF_EEH_BUSY, &ha->flags);\n\t\tset_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags);\n\t\tqla4xxx_abort_active_cmds(ha, DID_NO_CONNECT << 16);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n \nstatic pci_ers_result_t\nqla4xxx_pci_mmio_enabled(struct pci_dev *pdev)\n{\n\tstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\n\n\tif (!is_aer_supported(ha))\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n}\n\nstatic uint32_t qla4_8xxx_error_recovery(struct scsi_qla_host *ha)\n{\n\tuint32_t rval = QLA_ERROR;\n\tint fn;\n\tstruct pci_dev *other_pdev = NULL;\n\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: In %s\\n\", ha->host_no, __func__);\n\n\tset_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\n\n\tif (test_bit(AF_ONLINE, &ha->flags)) {\n\t\tclear_bit(AF_ONLINE, &ha->flags);\n\t\tclear_bit(AF_LINK_UP, &ha->flags);\n\t\tiscsi_host_for_each_session(ha->host, qla4xxx_fail_session);\n\t\tqla4xxx_process_aen(ha, FLUSH_DDB_CHANGED_AENS);\n\t}\n\n\tfn = PCI_FUNC(ha->pdev->devfn);\n\tif (is_qla8022(ha)) {\n\t\twhile (fn > 0) {\n\t\t\tfn--;\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: Finding PCI device at func %x\\n\",\n\t\t\t\t   ha->host_no, __func__, fn);\n\t\t\t \n\t\t\tother_pdev = pci_get_domain_bus_and_slot(\n\t\t\t\t\t   pci_domain_nr(ha->pdev->bus),\n\t\t\t\t\t   ha->pdev->bus->number,\n\t\t\t\t\t   PCI_DEVFN(PCI_SLOT(ha->pdev->devfn),\n\t\t\t\t\t   fn));\n\n\t\t\tif (!other_pdev)\n\t\t\t\tcontinue;\n\n\t\t\tif (atomic_read(&other_pdev->enable_cnt)) {\n\t\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: Found PCI func in enabled state%x\\n\",\n\t\t\t\t\t   ha->host_no, __func__, fn);\n\t\t\t\tpci_dev_put(other_pdev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpci_dev_put(other_pdev);\n\t\t}\n\t} else {\n\t\t \n\t\tif (qla4_83xx_can_perform_reset(ha)) {\n\t\t\t \n\t\t\tfn = 0;\n\t\t}\n\t}\n\n\t \n\tif (!fn) {\n\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: devfn being reset \"\n\t\t    \"0x%x is the owner\\n\", ha->host_no, __func__,\n\t\t    ha->pdev->devfn);\n\n\t\tha->isp_ops->idc_lock(ha);\n\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t    QLA8XXX_DEV_COLD);\n\t\tha->isp_ops->idc_unlock(ha);\n\n\t\trval = qla4_8xxx_update_idc_reg(ha);\n\t\tif (rval == QLA_ERROR) {\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: HW State: FAILED\\n\",\n\t\t\t\t   ha->host_no, __func__);\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tgoto exit_error_recovery;\n\t\t}\n\n\t\tclear_bit(AF_FW_RECOVERY, &ha->flags);\n\t\trval = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\n\n\t\tif (rval != QLA_SUCCESS) {\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: HW State: \"\n\t\t\t    \"FAILED\\n\", ha->host_no, __func__);\n\t\t\tqla4xxx_free_irqs(ha);\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_clear_drv_active(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_FAILED);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t} else {\n\t\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: HW State: \"\n\t\t\t    \"READY\\n\", ha->host_no, __func__);\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\n\t\t\t\t\t    QLA8XXX_DEV_READY);\n\t\t\t \n\t\t\tqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DRV_STATE, 0);\n\t\t\tqla4_8xxx_set_drv_active(ha);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t\tha->isp_ops->enable_intrs(ha);\n\t\t}\n\t} else {\n\t\tql4_printk(KERN_INFO, ha, \"scsi%ld: %s: devfn 0x%x is not \"\n\t\t    \"the reset owner\\n\", ha->host_no, __func__,\n\t\t    ha->pdev->devfn);\n\t\tif ((qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE) ==\n\t\t     QLA8XXX_DEV_READY)) {\n\t\t\tclear_bit(AF_FW_RECOVERY, &ha->flags);\n\t\t\trval = qla4xxx_initialize_adapter(ha, RESET_ADAPTER);\n\t\t\tif (rval == QLA_SUCCESS)\n\t\t\t\tha->isp_ops->enable_intrs(ha);\n\t\t\telse\n\t\t\t\tqla4xxx_free_irqs(ha);\n\n\t\t\tha->isp_ops->idc_lock(ha);\n\t\t\tqla4_8xxx_set_drv_active(ha);\n\t\t\tha->isp_ops->idc_unlock(ha);\n\t\t}\n\t}\nexit_error_recovery:\n\tclear_bit(DPC_RESET_ACTIVE, &ha->dpc_flags);\n\treturn rval;\n}\n\nstatic pci_ers_result_t\nqla4xxx_pci_slot_reset(struct pci_dev *pdev)\n{\n\tpci_ers_result_t ret = PCI_ERS_RESULT_DISCONNECT;\n\tstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\n\tint rc;\n\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: slot_reset\\n\",\n\t    ha->host_no, __func__);\n\n\tif (!is_aer_supported(ha))\n\t\treturn PCI_ERS_RESULT_NONE;\n\n\t \n\tpci_restore_state(pdev);\n\n\t \n\tpci_save_state(pdev);\n\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: Can't re-enable \"\n\t\t    \"device after reset\\n\", ha->host_no, __func__);\n\t\tgoto exit_slot_reset;\n\t}\n\n\tha->isp_ops->disable_intrs(ha);\n\n\tif (is_qla80XX(ha)) {\n\t\tif (qla4_8xxx_error_recovery(ha) == QLA_SUCCESS) {\n\t\t\tret = PCI_ERS_RESULT_RECOVERED;\n\t\t\tgoto exit_slot_reset;\n\t\t} else\n\t\t\tgoto exit_slot_reset;\n\t}\n\nexit_slot_reset:\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: Return=%x\\n\"\n\t    \"device after reset\\n\", ha->host_no, __func__, ret);\n\treturn ret;\n}\n\nstatic void\nqla4xxx_pci_resume(struct pci_dev *pdev)\n{\n\tstruct scsi_qla_host *ha = pci_get_drvdata(pdev);\n\tint ret;\n\n\tql4_printk(KERN_WARNING, ha, \"scsi%ld: %s: pci_resume\\n\",\n\t    ha->host_no, __func__);\n\n\tret = qla4xxx_wait_for_hba_online(ha);\n\tif (ret != QLA_SUCCESS) {\n\t\tql4_printk(KERN_ERR, ha, \"scsi%ld: %s: the device failed to \"\n\t\t    \"resume I/O from slot/link_reset\\n\", ha->host_no,\n\t\t     __func__);\n\t}\n\n\tclear_bit(AF_EEH_BUSY, &ha->flags);\n}\n\nstatic const struct pci_error_handlers qla4xxx_err_handler = {\n\t.error_detected = qla4xxx_pci_error_detected,\n\t.mmio_enabled = qla4xxx_pci_mmio_enabled,\n\t.slot_reset = qla4xxx_pci_slot_reset,\n\t.resume = qla4xxx_pci_resume,\n};\n\nstatic struct pci_device_id qla4xxx_pci_tbl[] = {\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP4010,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP4022,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP4032,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor         = PCI_VENDOR_ID_QLOGIC,\n\t\t.device         = PCI_DEVICE_ID_QLOGIC_ISP8022,\n\t\t.subvendor      = PCI_ANY_ID,\n\t\t.subdevice      = PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP8324,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_QLOGIC,\n\t\t.device\t\t= PCI_DEVICE_ID_QLOGIC_ISP8042,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{0, 0},\n};\nMODULE_DEVICE_TABLE(pci, qla4xxx_pci_tbl);\n\nstatic struct pci_driver qla4xxx_pci_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= qla4xxx_pci_tbl,\n\t.probe\t\t= qla4xxx_probe_adapter,\n\t.remove\t\t= qla4xxx_remove_adapter,\n\t.err_handler = &qla4xxx_err_handler,\n};\n\nstatic int __init qla4xxx_module_init(void)\n{\n\tint ret;\n\n\tif (ql4xqfulltracking)\n\t\tqla4xxx_driver_template.track_queue_depth = 1;\n\n\t \n\tsrb_cachep = kmem_cache_create(\"qla4xxx_srbs\", sizeof(struct srb), 0,\n\t\t\t\t       SLAB_HWCACHE_ALIGN, NULL);\n\tif (srb_cachep == NULL) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Unable to allocate SRB cache...\"\n\t\t       \"Failing load!\\n\", DRIVER_NAME);\n\t\tret = -ENOMEM;\n\t\tgoto no_srp_cache;\n\t}\n\n\t \n\tstrcpy(qla4xxx_version_str, QLA4XXX_DRIVER_VERSION);\n\tif (ql4xextended_error_logging)\n\t\tstrcat(qla4xxx_version_str, \"-debug\");\n\n\tqla4xxx_scsi_transport =\n\t\tiscsi_register_transport(&qla4xxx_iscsi_transport);\n\tif (!qla4xxx_scsi_transport){\n\t\tret = -ENODEV;\n\t\tgoto release_srb_cache;\n\t}\n\n\tret = pci_register_driver(&qla4xxx_pci_driver);\n\tif (ret)\n\t\tgoto unregister_transport;\n\n\tprintk(KERN_INFO \"QLogic iSCSI HBA Driver\\n\");\n\treturn 0;\n\nunregister_transport:\n\tiscsi_unregister_transport(&qla4xxx_iscsi_transport);\nrelease_srb_cache:\n\tkmem_cache_destroy(srb_cachep);\nno_srp_cache:\n\treturn ret;\n}\n\nstatic void __exit qla4xxx_module_exit(void)\n{\n\tpci_unregister_driver(&qla4xxx_pci_driver);\n\tiscsi_unregister_transport(&qla4xxx_iscsi_transport);\n\tkmem_cache_destroy(srb_cachep);\n}\n\nmodule_init(qla4xxx_module_init);\nmodule_exit(qla4xxx_module_exit);\n\nMODULE_AUTHOR(\"QLogic Corporation\");\nMODULE_DESCRIPTION(\"QLogic iSCSI HBA Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(QLA4XXX_DRIVER_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}