{
  "module_name": "ql4_init.c",
  "hash_id": "54310075ef619aedb49614852256521340eda337f9eef4bde96fbe1434d00837",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_init.c",
  "human_readable_source": "\n \n\n#include <scsi/iscsi_if.h>\n#include \"ql4_def.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_dbg.h\"\n#include \"ql4_inline.h\"\n\nstatic void ql4xxx_set_mac_number(struct scsi_qla_host *ha)\n{\n\tuint32_t value;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tvalue = readw(&ha->reg->ctrl_status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tswitch (value & ISP_CONTROL_FN_MASK) {\n\tcase ISP_CONTROL_FN0_SCSI:\n\t\tha->mac_index = 1;\n\t\tbreak;\n\tcase ISP_CONTROL_FN1_SCSI:\n\t\tha->mac_index = 3;\n\t\tbreak;\n\tdefault:\n\t\tDEBUG2(printk(\"scsi%ld: %s: Invalid function number, \"\n\t\t\t      \"ispControlStatus = 0x%x\\n\", ha->host_no,\n\t\t\t      __func__, value));\n\t\tbreak;\n\t}\n\tDEBUG2(printk(\"scsi%ld: %s: mac_index %d.\\n\", ha->host_no, __func__,\n\t\t      ha->mac_index));\n}\n\n \nvoid qla4xxx_free_ddb(struct scsi_qla_host *ha,\n    struct ddb_entry *ddb_entry)\n{\n\t \n\tha->fw_ddb_index_map[ddb_entry->fw_ddb_index] =\n\t\t(struct ddb_entry *) INVALID_ENTRY;\n\tha->tot_ddbs--;\n}\n\n \nstatic void qla4xxx_init_response_q_entries(struct scsi_qla_host *ha)\n{\n\tuint16_t cnt;\n\tstruct response *pkt;\n\n\tpkt = (struct response *)ha->response_ptr;\n\tfor (cnt = 0; cnt < RESPONSE_QUEUE_DEPTH; cnt++) {\n\t\tpkt->signature = RESPONSE_PROCESSED;\n\t\tpkt++;\n\t}\n}\n\n \nint qla4xxx_init_rings(struct scsi_qla_host *ha)\n{\n\tunsigned long flags = 0;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\tha->request_out = 0;\n\tha->request_in = 0;\n\tha->request_ptr = &ha->request_ring[ha->request_in];\n\tha->req_q_count = REQUEST_QUEUE_DEPTH;\n\n\t \n\tha->response_in = 0;\n\tha->response_out = 0;\n\tha->response_ptr = &ha->response_ring[ha->response_out];\n\n\tif (is_qla8022(ha)) {\n\t\twritel(0,\n\t\t    (unsigned long  __iomem *)&ha->qla4_82xx_reg->req_q_out);\n\t\twritel(0,\n\t\t    (unsigned long  __iomem *)&ha->qla4_82xx_reg->rsp_q_in);\n\t\twritel(0,\n\t\t    (unsigned long  __iomem *)&ha->qla4_82xx_reg->rsp_q_out);\n\t} else if (is_qla8032(ha) || is_qla8042(ha)) {\n\t\twritel(0,\n\t\t       (unsigned long __iomem *)&ha->qla4_83xx_reg->req_q_in);\n\t\twritel(0,\n\t\t       (unsigned long __iomem *)&ha->qla4_83xx_reg->rsp_q_in);\n\t\twritel(0,\n\t\t       (unsigned long __iomem *)&ha->qla4_83xx_reg->rsp_q_out);\n\t} else {\n\t\t \n\t\tha->shadow_regs->req_q_out = cpu_to_le32(0);\n\t\tha->shadow_regs->rsp_q_in = cpu_to_le32(0);\n\t\twmb();\n\n\t\twritel(0, &ha->reg->req_q_in);\n\t\twritel(0, &ha->reg->rsp_q_out);\n\t\treadl(&ha->reg->rsp_q_out);\n\t}\n\n\tqla4xxx_init_response_q_entries(ha);\n\n\t \n\tfor (i = 0; i < MAX_MRB; i++)\n\t\tha->active_mrb_array[i] = NULL;\n\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\treturn QLA_SUCCESS;\n}\n\n \nint qla4xxx_get_sys_info(struct scsi_qla_host *ha)\n{\n\tstruct flash_sys_info *sys_info;\n\tdma_addr_t sys_info_dma;\n\tint status = QLA_ERROR;\n\n\tsys_info = dma_alloc_coherent(&ha->pdev->dev, sizeof(*sys_info),\n\t\t\t\t      &sys_info_dma, GFP_KERNEL);\n\tif (sys_info == NULL) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Unable to allocate dma buffer.\\n\",\n\t\t\t      ha->host_no, __func__));\n\n\t\tgoto exit_get_sys_info_no_free;\n\t}\n\n\t \n\tif (qla4xxx_get_flash(ha, sys_info_dma, FLASH_OFFSET_SYS_INFO,\n\t\t\t      sizeof(*sys_info)) != QLA_SUCCESS) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: get_flash FLASH_OFFSET_SYS_INFO \"\n\t\t\t      \"failed\\n\", ha->host_no, __func__));\n\n\t\tgoto exit_get_sys_info;\n\t}\n\n\t \n\tmemcpy(ha->my_mac, &sys_info->physAddr[0].address[0],\n\t       min(sizeof(ha->my_mac),\n\t\t   sizeof(sys_info->physAddr[0].address)));\n\tmemcpy(ha->serial_number, &sys_info->acSerialNumber,\n\t       min(sizeof(ha->serial_number),\n\t\t   sizeof(sys_info->acSerialNumber)));\n\n\tstatus = QLA_SUCCESS;\n\nexit_get_sys_info:\n\tdma_free_coherent(&ha->pdev->dev, sizeof(*sys_info), sys_info,\n\t\t\t  sys_info_dma);\n\nexit_get_sys_info_no_free:\n\treturn status;\n}\n\n \nstatic void qla4xxx_init_local_data(struct scsi_qla_host *ha)\n{\n\t \n\tha->aen_q_count = MAX_AEN_ENTRIES;\n}\n\nstatic uint8_t\nqla4xxx_wait_for_ip_config(struct scsi_qla_host *ha)\n{\n\tuint8_t ipv4_wait = 0;\n\tuint8_t ipv6_wait = 0;\n\tint8_t ip_address[IPv6_ADDR_LEN] = {0} ;\n\n\t \n\tif (is_ipv4_enabled(ha) && is_ipv6_enabled(ha)) {\n\t\tif (((ha->addl_fw_state & FW_ADDSTATE_DHCPv4_ENABLED) != 0) &&\n\t\t    ((ha->addl_fw_state &\n\t\t\t\t    FW_ADDSTATE_DHCPv4_LEASE_ACQUIRED) == 0)) {\n\t\t\tipv4_wait = 1;\n\t\t}\n\t\tif (((ha->ip_config.ipv6_addl_options &\n\t\t      IPV6_ADDOPT_NEIGHBOR_DISCOVERY_ADDR_ENABLE) != 0) &&\n\t\t    ((ha->ip_config.ipv6_link_local_state ==\n\t\t      IP_ADDRSTATE_ACQUIRING) ||\n\t\t     (ha->ip_config.ipv6_addr0_state ==\n\t\t      IP_ADDRSTATE_ACQUIRING) ||\n\t\t     (ha->ip_config.ipv6_addr1_state ==\n\t\t      IP_ADDRSTATE_ACQUIRING))) {\n\n\t\t\tipv6_wait = 1;\n\n\t\t\tif ((ha->ip_config.ipv6_link_local_state ==\n\t\t\t     IP_ADDRSTATE_PREFERRED) ||\n\t\t\t    (ha->ip_config.ipv6_addr0_state ==\n\t\t\t     IP_ADDRSTATE_PREFERRED) ||\n\t\t\t    (ha->ip_config.ipv6_addr1_state ==\n\t\t\t     IP_ADDRSTATE_PREFERRED)) {\n\t\t\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: \"\n\t\t\t\t\t      \"Preferred IP configured.\"\n\t\t\t\t\t      \" Don't wait!\\n\", ha->host_no,\n\t\t\t\t\t      __func__));\n\t\t\t\tipv6_wait = 0;\n\t\t\t}\n\t\t\tif (memcmp(&ha->ip_config.ipv6_default_router_addr,\n\t\t\t\t   ip_address, IPv6_ADDR_LEN) == 0) {\n\t\t\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: \"\n\t\t\t\t\t      \"No Router configured. \"\n\t\t\t\t\t      \"Don't wait!\\n\", ha->host_no,\n\t\t\t\t\t      __func__));\n\t\t\t\tipv6_wait = 0;\n\t\t\t}\n\t\t\tif ((ha->ip_config.ipv6_default_router_state ==\n\t\t\t     IPV6_RTRSTATE_MANUAL) &&\n\t\t\t    (ha->ip_config.ipv6_link_local_state ==\n\t\t\t     IP_ADDRSTATE_TENTATIVE) &&\n\t\t\t    (memcmp(&ha->ip_config.ipv6_link_local_addr,\n\t\t\t     &ha->ip_config.ipv6_default_router_addr, 4) ==\n\t\t\t     0)) {\n\t\t\t\tDEBUG2(printk(\"scsi%ld: %s: LinkLocal Router & \"\n\t\t\t\t\t\"IP configured. Don't wait!\\n\",\n\t\t\t\t\tha->host_no, __func__));\n\t\t\t\tipv6_wait = 0;\n\t\t\t}\n\t\t}\n\t\tif (ipv4_wait || ipv6_wait) {\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: Wait for additional \"\n\t\t\t\t      \"IP(s) \\\"\", ha->host_no, __func__));\n\t\t\tif (ipv4_wait)\n\t\t\t\tDEBUG2(printk(\"IPv4 \"));\n\t\t\tif (ha->ip_config.ipv6_link_local_state ==\n\t\t\t    IP_ADDRSTATE_ACQUIRING)\n\t\t\t\tDEBUG2(printk(\"IPv6LinkLocal \"));\n\t\t\tif (ha->ip_config.ipv6_addr0_state ==\n\t\t\t    IP_ADDRSTATE_ACQUIRING)\n\t\t\t\tDEBUG2(printk(\"IPv6Addr0 \"));\n\t\t\tif (ha->ip_config.ipv6_addr1_state ==\n\t\t\t    IP_ADDRSTATE_ACQUIRING)\n\t\t\t\tDEBUG2(printk(\"IPv6Addr1 \"));\n\t\t\tDEBUG2(printk(\"\\\"\\n\"));\n\t\t}\n\t}\n\n\treturn ipv4_wait|ipv6_wait;\n}\n\nstatic int qla4_80xx_is_minidump_dma_capable(struct scsi_qla_host *ha,\n\t\tstruct qla4_8xxx_minidump_template_hdr *md_hdr)\n{\n\tint offset = (is_qla8022(ha)) ? QLA8022_TEMPLATE_CAP_OFFSET :\n\t\t\t\t\tQLA83XX_TEMPLATE_CAP_OFFSET;\n\tint rval = 1;\n\tuint32_t *cap_offset;\n\n\tcap_offset = (uint32_t *)((char *)md_hdr + offset);\n\n\tif (!(le32_to_cpu(*cap_offset) & BIT_0)) {\n\t\tql4_printk(KERN_INFO, ha, \"PEX DMA Not supported %d\\n\",\n\t\t\t   *cap_offset);\n\t\trval = 0;\n\t}\n\n\treturn rval;\n}\n\n \nvoid qla4xxx_alloc_fw_dump(struct scsi_qla_host *ha)\n{\n\tint status;\n\tuint32_t capture_debug_level;\n\tint hdr_entry_bit, k;\n\tvoid *md_tmp;\n\tdma_addr_t md_tmp_dma;\n\tstruct qla4_8xxx_minidump_template_hdr *md_hdr;\n\tint dma_capable;\n\n\tif (ha->fw_dump) {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t\t   \"Firmware dump previously allocated.\\n\");\n\t\treturn;\n\t}\n\n\tstatus = qla4xxx_req_template_size(ha);\n\tif (status != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"scsi%ld: Failed to get template size\\n\",\n\t\t\t   ha->host_no);\n\t\treturn;\n\t}\n\n\tclear_bit(AF_82XX_FW_DUMPED, &ha->flags);\n\n\t \n\tmd_tmp = dma_alloc_coherent(&ha->pdev->dev, ha->fw_dump_tmplt_size,\n\t\t\t\t    &md_tmp_dma, GFP_KERNEL);\n\tif (!md_tmp) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"scsi%ld: Failed to allocate DMA memory\\n\",\n\t\t\t   ha->host_no);\n\t\treturn;\n\t}\n\n\t \n\tstatus =  qla4xxx_get_minidump_template(ha, md_tmp_dma);\n\tif (status != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha,\n\t\t\t   \"scsi%ld: Failed to get minidump template\\n\",\n\t\t\t   ha->host_no);\n\t\tgoto alloc_cleanup;\n\t}\n\n\tmd_hdr = (struct qla4_8xxx_minidump_template_hdr *)md_tmp;\n\n\tdma_capable = qla4_80xx_is_minidump_dma_capable(ha, md_hdr);\n\n\tcapture_debug_level = md_hdr->capture_debug_level;\n\n\t \n\tif ((ql4xmdcapmask >= 0x3 && ql4xmdcapmask <= 0x7F) ||\n\t    (ql4xmdcapmask == 0xFF && dma_capable))  {\n\t\tha->fw_dump_capture_mask = ql4xmdcapmask;\n\t} else {\n\t\tif (ql4xmdcapmask == 0xFF)\n\t\t\tql4_printk(KERN_INFO, ha, \"Falling back to default capture mask, as PEX DMA is not supported\\n\");\n\t\tha->fw_dump_capture_mask = capture_debug_level;\n\t}\n\n\tmd_hdr->driver_capture_mask = ha->fw_dump_capture_mask;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Minimum num of entries = %d\\n\",\n\t\t\t  md_hdr->num_of_entries));\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Dump template size  = %d\\n\",\n\t\t\t  ha->fw_dump_tmplt_size));\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Selected Capture mask =0x%x\\n\",\n\t\t\t  ha->fw_dump_capture_mask));\n\n\t \n\tfor (hdr_entry_bit = 0x2, k = 1; (hdr_entry_bit & 0xFF);\n\t     hdr_entry_bit <<= 1, k++) {\n\t\tif (hdr_entry_bit & ha->fw_dump_capture_mask)\n\t\t\tha->fw_dump_size += md_hdr->capture_size_array[k];\n\t}\n\n\t \n\tha->fw_dump_size += ha->fw_dump_tmplt_size;\n\tha->fw_dump = vmalloc(ha->fw_dump_size);\n\tif (!ha->fw_dump)\n\t\tgoto alloc_cleanup;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Minidump Template Size = 0x%x KB\\n\",\n\t\t\t  ha->fw_dump_tmplt_size));\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"Total Minidump size = 0x%x KB\\n\", ha->fw_dump_size));\n\n\tmemcpy(ha->fw_dump, md_tmp, ha->fw_dump_tmplt_size);\n\tha->fw_dump_tmplt_hdr = ha->fw_dump;\n\nalloc_cleanup:\n\tdma_free_coherent(&ha->pdev->dev, ha->fw_dump_tmplt_size,\n\t\t\t  md_tmp, md_tmp_dma);\n}\n\nstatic int qla4xxx_fw_ready(struct scsi_qla_host *ha)\n{\n\tuint32_t timeout_count;\n\tint ready = 0;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"Waiting for Firmware Ready..\\n\"));\n\tfor (timeout_count = ADAPTER_INIT_TOV; timeout_count > 0;\n\t     timeout_count--) {\n\t\tif (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR, &ha->dpc_flags))\n\t\t\tqla4xxx_get_dhcp_ip_address(ha);\n\n\t\t \n\t\tif (qla4xxx_get_firmware_state(ha) != QLA_SUCCESS) {\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: unable to get firmware \"\n\t\t\t\t      \"state\\n\", ha->host_no, __func__));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ha->firmware_state & FW_STATE_ERROR) {\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: an unrecoverable error has\"\n\t\t\t\t      \" occurred\\n\", ha->host_no, __func__));\n\t\t\tbreak;\n\n\t\t}\n\t\tif (ha->firmware_state & FW_STATE_CONFIG_WAIT) {\n\t\t\t \n\t\t\tif (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ha->firmware_state & FW_STATE_WAIT_AUTOCONNECT) {\n\t\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: fwstate:\"\n\t\t\t\t      \"AUTOCONNECT in progress\\n\",\n\t\t\t\t      ha->host_no, __func__));\n\t\t}\n\n\t\tif (ha->firmware_state & FW_STATE_CONFIGURING_IP) {\n\t\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: fwstate:\"\n\t\t\t\t      \" CONFIGURING IP\\n\",\n\t\t\t\t      ha->host_no, __func__));\n\t\t\t \n\t\t\tif (timeout_count <= (ADAPTER_INIT_TOV - 15)) {\n\t\t\t\tif (ha->addl_fw_state & FW_ADDSTATE_LINK_UP) {\n\t\t\t\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s:\"\n\t\t\t\t\t\t  \" LINK UP (Cable plugged)\\n\",\n\t\t\t\t\t\t  ha->host_no, __func__));\n\t\t\t\t} else if (ha->firmware_state &\n\t\t\t\t\t  (FW_STATE_CONFIGURING_IP |\n\t\t\t\t\t\t\t     FW_STATE_READY)) {\n\t\t\t\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: \"\n\t\t\t\t\t\t\"LINK DOWN (Cable unplugged)\\n\",\n\t\t\t\t\t\tha->host_no, __func__));\n\t\t\t\t\tha->firmware_state = FW_STATE_READY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ha->firmware_state == FW_STATE_READY) {\n\t\t\t \n\t\t\tif (test_and_clear_bit(DPC_GET_DHCP_IP_ADDR,\n\t\t\t\t\t\t\t\t&ha->dpc_flags))\n\t\t\t\tqla4xxx_get_dhcp_ip_address(ha);\n\n\t\t\tif (!qla4xxx_wait_for_ip_config(ha) ||\n\t\t\t\t\t\t\ttimeout_count == 1) {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t    \"Firmware Ready..\\n\"));\n\t\t\t\t \n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\"scsi%ld: %s: MEDIA TYPE\"\n\t\t\t\t\t\" - %s\\n\", ha->host_no,\n\t\t\t\t\t__func__, (ha->addl_fw_state &\n\t\t\t\t\tFW_ADDSTATE_OPTICAL_MEDIA)\n\t\t\t\t\t!= 0 ? \"OPTICAL\" : \"COPPER\"));\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\"scsi%ld: %s: DHCPv4 STATE\"\n\t\t\t\t\t\" Enabled %s\\n\", ha->host_no,\n\t\t\t\t\t __func__, (ha->addl_fw_state &\n\t\t\t\t\t FW_ADDSTATE_DHCPv4_ENABLED) != 0 ?\n\t\t\t\t\t\"YES\" : \"NO\"));\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\"scsi%ld: %s: LINK %s\\n\",\n\t\t\t\t\tha->host_no, __func__,\n\t\t\t\t\t(ha->addl_fw_state &\n\t\t\t\t\t FW_ADDSTATE_LINK_UP) != 0 ?\n\t\t\t\t\t\"UP\" : \"DOWN\"));\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\"scsi%ld: %s: iSNS Service \"\n\t\t\t\t\t\"Started %s\\n\",\n\t\t\t\t\tha->host_no, __func__,\n\t\t\t\t\t(ha->addl_fw_state &\n\t\t\t\t\t FW_ADDSTATE_ISNS_SVC_ENABLED) != 0 ?\n\t\t\t\t\t\"YES\" : \"NO\"));\n\n\t\t\t\tready = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDEBUG2(printk(\"scsi%ld: %s: waiting on fw, state=%x:%x - \"\n\t\t\t      \"seconds expired= %d\\n\", ha->host_no, __func__,\n\t\t\t      ha->firmware_state, ha->addl_fw_state,\n\t\t\t      timeout_count));\n\t\tif (is_qla4032(ha) &&\n\t\t\t!(ha->addl_fw_state & FW_ADDSTATE_LINK_UP) &&\n\t\t\t(timeout_count < ADAPTER_INIT_TOV - 5)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(1000);\n\t}\t\t\t \n\n\tif (timeout_count <= 0)\n\t\tDEBUG2(printk(\"scsi%ld: %s: FW Initialization timed out!\\n\",\n\t\t\t      ha->host_no, __func__));\n\n\tif (ha->firmware_state & FW_STATE_CONFIGURING_IP) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: FW initialized, but is reporting \"\n\t\t\t      \"it's waiting to configure an IP address\\n\",\n\t\t\t       ha->host_no, __func__));\n\t\tready = 1;\n\t} else if (ha->firmware_state & FW_STATE_WAIT_AUTOCONNECT) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: FW initialized, but \"\n\t\t\t      \"auto-discovery still in process\\n\",\n\t\t\t       ha->host_no, __func__));\n\t\tready = 1;\n\t}\n\n\treturn ready;\n}\n\n \nstatic int qla4xxx_init_firmware(struct scsi_qla_host *ha)\n{\n\tint status = QLA_ERROR;\n\n\tif (is_aer_supported(ha) &&\n\t    test_bit(AF_PCI_CHANNEL_IO_PERM_FAILURE, &ha->flags))\n\t\treturn status;\n\n\t \n\tif (is_qla80XX(ha))\n\t\tqla4_8xxx_stop_firmware(ha);\n\n\tql4_printk(KERN_INFO, ha, \"Initializing firmware..\\n\");\n\tif (qla4xxx_initialize_fw_cb(ha) == QLA_ERROR) {\n\t\tDEBUG2(printk(\"scsi%ld: %s: Failed to initialize firmware \"\n\t\t\t      \"control block\\n\", ha->host_no, __func__));\n\t\treturn status;\n\t}\n\n\tif (!qla4xxx_fw_ready(ha))\n\t\treturn status;\n\n\tif (is_qla80XX(ha) && !test_bit(AF_INIT_DONE, &ha->flags))\n\t\tqla4xxx_alloc_fw_dump(ha);\n\n\treturn qla4xxx_get_firmware_status(ha);\n}\n\nstatic void qla4xxx_set_model_info(struct scsi_qla_host *ha)\n{\n\tuint16_t board_id_string[8];\n\tint i;\n\tint size = sizeof(ha->nvram->isp4022.boardIdStr);\n\tint offset = offsetof(struct eeprom_data, isp4022.boardIdStr) / 2;\n\n\tfor (i = 0; i < (size / 2) ; i++) {\n\t\tboard_id_string[i] = rd_nvram_word(ha, offset);\n\t\toffset += 1;\n\t}\n\n\tmemcpy(ha->model_name, board_id_string, size);\n}\n\nstatic int qla4xxx_config_nvram(struct scsi_qla_host *ha)\n{\n\tunsigned long flags;\n\tunion external_hw_config_reg extHwConfig;\n\n\tDEBUG2(printk(\"scsi%ld: %s: Get EEProm parameters \\n\", ha->host_no,\n\t\t      __func__));\n\tif (ql4xxx_lock_flash(ha) != QLA_SUCCESS)\n\t\treturn QLA_ERROR;\n\tif (ql4xxx_lock_nvram(ha) != QLA_SUCCESS) {\n\t\tql4xxx_unlock_flash(ha);\n\t\treturn QLA_ERROR;\n\t}\n\n\t \n\tql4_printk(KERN_INFO, ha, \"Configuring NVRAM ...\\n\");\n\tif (qla4xxx_is_nvram_configuration_valid(ha) == QLA_SUCCESS) {\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\textHwConfig.Asuint32_t =\n\t\t\trd_nvram_word(ha, eeprom_ext_hw_conf_offset(ha));\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t} else {\n\t\tql4_printk(KERN_WARNING, ha,\n\t\t    \"scsi%ld: %s: EEProm checksum invalid.  \"\n\t\t    \"Please update your EEPROM\\n\", ha->host_no,\n\t\t    __func__);\n\n\t\t \n\t\tif (is_qla4010(ha))\n\t\t\textHwConfig.Asuint32_t = 0x1912;\n\t\telse if (is_qla4022(ha) | is_qla4032(ha))\n\t\t\textHwConfig.Asuint32_t = 0x0023;\n\t\telse\n\t\t\treturn QLA_ERROR;\n\t}\n\n\tif (is_qla4022(ha) || is_qla4032(ha))\n\t\tqla4xxx_set_model_info(ha);\n\telse\n\t\tstrcpy(ha->model_name, \"QLA4010\");\n\n\tDEBUG(printk(\"scsi%ld: %s: Setting extHwConfig to 0xFFFF%04x\\n\",\n\t\t     ha->host_no, __func__, extHwConfig.Asuint32_t));\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twritel((0xFFFF << 16) | extHwConfig.Asuint32_t, isp_ext_hw_conf(ha));\n\treadl(isp_ext_hw_conf(ha));\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tql4xxx_unlock_nvram(ha);\n\tql4xxx_unlock_flash(ha);\n\n\treturn QLA_SUCCESS;\n}\n\n \nvoid qla4_8xxx_pci_config(struct scsi_qla_host *ha)\n{\n\tpci_set_master(ha->pdev);\n}\n\nvoid qla4xxx_pci_config(struct scsi_qla_host *ha)\n{\n\tuint16_t w;\n\tint status;\n\n\tql4_printk(KERN_INFO, ha, \"Configuring PCI space...\\n\");\n\n\tpci_set_master(ha->pdev);\n\tstatus = pci_set_mwi(ha->pdev);\n\tif (status)\n\t\tql4_printk(KERN_WARNING, ha, \"Failed to set MWI\\n\");\n\n\t \n\tpci_read_config_word(ha->pdev, PCI_COMMAND, &w);\n\tw |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;\n\tw &= ~PCI_COMMAND_INTX_DISABLE;\n\tpci_write_config_word(ha->pdev, PCI_COMMAND, w);\n}\n\nstatic int qla4xxx_start_firmware_from_flash(struct scsi_qla_host *ha)\n{\n\tint status = QLA_ERROR;\n\tunsigned long max_wait_time;\n\tunsigned long flags;\n\tuint32_t mbox_status;\n\n\tql4_printk(KERN_INFO, ha, \"Starting firmware ...\\n\");\n\n\t \n\tDEBUG(printk(\"scsi%d: %s: Start firmware from flash ROM\\n\",\n\t\t     ha->host_no, __func__));\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\twritel(jiffies, &ha->reg->mailbox[7]);\n\tif (is_qla4022(ha) | is_qla4032(ha))\n\t\twritel(set_rmask(NVR_WRITE_ENABLE),\n\t\t       &ha->reg->u1.isp4022.nvram);\n\n        writel(2, &ha->reg->mailbox[6]);\n        readl(&ha->reg->mailbox[6]);\n\n\twritel(set_rmask(CSR_BOOT_ENABLE), &ha->reg->ctrl_status);\n\treadl(&ha->reg->ctrl_status);\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t \n\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: Wait up to %d seconds for \"\n\t\t      \"boot firmware to complete...\\n\",\n\t\t      ha->host_no, __func__, FIRMWARE_UP_TOV));\n\tmax_wait_time = jiffies + (FIRMWARE_UP_TOV * HZ);\n\tdo {\n\t\tuint32_t ctrl_status;\n\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\tctrl_status = readw(&ha->reg->ctrl_status);\n\t\tmbox_status = readw(&ha->reg->mailbox[0]);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tif (ctrl_status & set_rmask(CSR_SCSI_PROCESSOR_INTR))\n\t\t\tbreak;\n\t\tif (mbox_status == MBOX_STS_COMMAND_COMPLETE)\n\t\t\tbreak;\n\n\t\tDEBUG2(printk(KERN_INFO \"scsi%ld: %s: Waiting for boot \"\n\t\t    \"firmware to complete... ctrl_sts=0x%x, remaining=%ld\\n\",\n\t\t    ha->host_no, __func__, ctrl_status, max_wait_time));\n\n\t\tmsleep_interruptible(250);\n\t} while (!time_after_eq(jiffies, max_wait_time));\n\n\tif (mbox_status == MBOX_STS_COMMAND_COMPLETE) {\n\t\tDEBUG(printk(KERN_INFO \"scsi%ld: %s: Firmware has started\\n\",\n\t\t\t     ha->host_no, __func__));\n\n\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\twritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\n\t\t       &ha->reg->ctrl_status);\n\t\treadl(&ha->reg->ctrl_status);\n\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\t\tstatus = QLA_SUCCESS;\n\t} else {\n\t\tprintk(KERN_INFO \"scsi%ld: %s: Boot firmware failed \"\n\t\t       \"-  mbox status 0x%x\\n\", ha->host_no, __func__,\n\t\t       mbox_status);\n\t\tstatus = QLA_ERROR;\n\t}\n\treturn status;\n}\n\nint ql4xxx_lock_drvr_wait(struct scsi_qla_host *a)\n{\n#define QL4_LOCK_DRVR_WAIT\t60\n#define QL4_LOCK_DRVR_SLEEP\t1\n\n\tint drvr_wait = QL4_LOCK_DRVR_WAIT;\n\twhile (drvr_wait) {\n\t\tif (ql4xxx_lock_drvr(a) == 0) {\n\t\t\tssleep(QL4_LOCK_DRVR_SLEEP);\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: Waiting for \"\n\t\t\t\t      \"Global Init Semaphore(%d)...\\n\",\n\t\t\t\t      a->host_no,\n\t\t\t\t      __func__, drvr_wait));\n\t\t\tdrvr_wait -= QL4_LOCK_DRVR_SLEEP;\n\t\t} else {\n\t\t\tDEBUG2(printk(\"scsi%ld: %s: Global Init Semaphore \"\n\t\t\t\t      \"acquired\\n\", a->host_no, __func__));\n\t\t\treturn QLA_SUCCESS;\n\t\t}\n\t}\n\treturn QLA_ERROR;\n}\n\n \nint qla4xxx_start_firmware(struct scsi_qla_host *ha)\n{\n\tunsigned long flags = 0;\n\tuint32_t mbox_status;\n\tint status = QLA_ERROR;\n\tint soft_reset = 1;\n\tint config_chip = 0;\n\n\tif (is_qla4022(ha) | is_qla4032(ha))\n\t\tql4xxx_set_mac_number(ha);\n\n\tif (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)\n\t\treturn QLA_ERROR;\n\n\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\n\tDEBUG2(printk(\"scsi%ld: %s: port_ctrl\t= 0x%08X\\n\", ha->host_no,\n\t\t      __func__, readw(isp_port_ctrl(ha))));\n\tDEBUG(printk(\"scsi%ld: %s: port_status = 0x%08X\\n\", ha->host_no,\n\t\t     __func__, readw(isp_port_status(ha))));\n\n\t \n\tif ((readw(isp_port_ctrl(ha)) & 0x8000) != 0) {\n\t\tDEBUG(printk(\"scsi%ld: %s: Hardware has already been \"\n\t\t\t     \"initialized\\n\", ha->host_no, __func__));\n\n\t\t \n\t\tmbox_status = readw(&ha->reg->mailbox[0]);\n\n\t\tDEBUG2(printk(\"scsi%ld: %s: H/W Config complete - mbox[0]= \"\n\t\t\t      \"0x%x\\n\", ha->host_no, __func__, mbox_status));\n\n\t\t \n\t\tif (mbox_status == 0) {\n\t\t\t \n\t\t\tconfig_chip = 1;\n\t\t\tsoft_reset = 0;\n\t\t} else {\n\t\t\twritel(set_rmask(CSR_SCSI_PROCESSOR_INTR),\n\t\t\t       &ha->reg->ctrl_status);\n\t\t\treadl(&ha->reg->ctrl_status);\n\t\t\twritel(set_rmask(CSR_SCSI_COMPLETION_INTR),\n\t\t\t       &ha->reg->ctrl_status);\n\t\t\treadl(&ha->reg->ctrl_status);\n\t\t\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\t\t\tif (qla4xxx_get_firmware_state(ha) == QLA_SUCCESS) {\n\t\t\t\tDEBUG2(printk(\"scsi%ld: %s: Get firmware \"\n\t\t\t\t\t      \"state -- state = 0x%x\\n\",\n\t\t\t\t\t      ha->host_no,\n\t\t\t\t\t      __func__, ha->firmware_state));\n\t\t\t\t \n\t\t\t\tif (ha->firmware_state &\n\t\t\t\t    FW_STATE_CONFIG_WAIT) {\n\t\t\t\t\tDEBUG2(printk(\"scsi%ld: %s: Firmware \"\n\t\t\t\t\t\t      \"in known state -- \"\n\t\t\t\t\t\t      \"config and \"\n\t\t\t\t\t\t      \"boot, state = 0x%x\\n\",\n\t\t\t\t\t\t      ha->host_no, __func__,\n\t\t\t\t\t\t      ha->firmware_state));\n\t\t\t\t\tconfig_chip = 1;\n\t\t\t\t\tsoft_reset = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDEBUG2(printk(\"scsi%ld: %s: Firmware in \"\n\t\t\t\t\t      \"unknown state -- resetting,\"\n\t\t\t\t\t      \" state = \"\n\t\t\t\t\t      \"0x%x\\n\", ha->host_no, __func__,\n\t\t\t\t\t      ha->firmware_state));\n\t\t\t}\n\t\t\tspin_lock_irqsave(&ha->hardware_lock, flags);\n\t\t}\n\t} else {\n\t\tDEBUG(printk(\"scsi%ld: %s: H/W initialization hasn't been \"\n\t\t\t     \"started - resetting\\n\", ha->host_no, __func__));\n\t}\n\tspin_unlock_irqrestore(&ha->hardware_lock, flags);\n\n\tDEBUG(printk(\"scsi%ld: %s: Flags soft_rest=%d, config= %d\\n \",\n\t\t     ha->host_no, __func__, soft_reset, config_chip));\n\tif (soft_reset) {\n\t\tDEBUG(printk(\"scsi%ld: %s: Issue Soft Reset\\n\", ha->host_no,\n\t\t\t     __func__));\n\t\tstatus = qla4xxx_soft_reset(ha);\t \n\t\tif (status == QLA_ERROR) {\n\t\t\tDEBUG(printk(\"scsi%d: %s: Soft Reset failed!\\n\",\n\t\t\t\t     ha->host_no, __func__));\n\t\t\tql4xxx_unlock_drvr(ha);\n\t\t\treturn QLA_ERROR;\n\t\t}\n\t\tconfig_chip = 1;\n\n\t\t \n\t\tif (ql4xxx_lock_drvr_wait(ha) != QLA_SUCCESS)\n\t\t\treturn QLA_ERROR;\n\t}\n\n\tif (config_chip) {\n\t\tif ((status = qla4xxx_config_nvram(ha)) == QLA_SUCCESS)\n\t\t\tstatus = qla4xxx_start_firmware_from_flash(ha);\n\t}\n\n\tql4xxx_unlock_drvr(ha);\n\tif (status == QLA_SUCCESS) {\n\t\tif (test_and_clear_bit(AF_GET_CRASH_RECORD, &ha->flags))\n\t\t\tqla4xxx_get_crash_record(ha);\n\n\t\tqla4xxx_init_rings(ha);\n\t} else {\n\t\tDEBUG(printk(\"scsi%ld: %s: Firmware has NOT started\\n\",\n\t\t\t     ha->host_no, __func__));\n\t}\n\treturn status;\n}\n \nvoid qla4xxx_free_ddb_index(struct scsi_qla_host *ha)\n{\n\tint max_ddbs;\n\tint ret;\n\tuint32_t idx = 0, next_idx = 0;\n\tuint32_t state = 0, conn_err = 0;\n\n\tmax_ddbs =  is_qla40XX(ha) ? MAX_DEV_DB_ENTRIES_40XX :\n\t\t\t\t     MAX_DEV_DB_ENTRIES;\n\n\tfor (idx = 0; idx < max_ddbs; idx = next_idx) {\n\t\tret = qla4xxx_get_fwddb_entry(ha, idx, NULL, 0, NULL,\n\t\t\t\t\t      &next_idx, &state, &conn_err,\n\t\t\t\t\t\tNULL, NULL);\n\t\tif (ret == QLA_ERROR) {\n\t\t\tnext_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (state == DDB_DS_NO_CONNECTION_ACTIVE ||\n\t\t    state == DDB_DS_SESSION_FAILED) {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"Freeing DDB index = 0x%x\\n\", idx));\n\t\t\tret = qla4xxx_clear_ddb_entry(ha, idx);\n\t\t\tif (ret == QLA_ERROR)\n\t\t\t\tql4_printk(KERN_ERR, ha,\n\t\t\t\t\t   \"Unable to clear DDB index = \"\n\t\t\t\t\t   \"0x%x\\n\", idx);\n\t\t}\n\t\tif (next_idx == 0)\n\t\t\tbreak;\n\t}\n}\n\n \nint qla4xxx_initialize_adapter(struct scsi_qla_host *ha, int is_reset)\n{\n\tint status = QLA_ERROR;\n\n\tha->eeprom_cmd_data = 0;\n\n\tql4_printk(KERN_INFO, ha, \"Configuring PCI space...\\n\");\n\tha->isp_ops->pci_config(ha);\n\n\tha->isp_ops->disable_intrs(ha);\n\n\t \n\tif (ha->isp_ops->start_firmware(ha) == QLA_ERROR)\n\t\tgoto exit_init_hba;\n\n\t \n\tif (is_qla8032(ha) || is_qla8042(ha))\n\t\tqla4_83xx_enable_mbox_intrs(ha);\n\n\tif (qla4xxx_about_firmware(ha) == QLA_ERROR)\n\t\tgoto exit_init_hba;\n\n\tif (ha->isp_ops->get_sys_info(ha) == QLA_ERROR)\n\t\tgoto exit_init_hba;\n\n\tqla4xxx_init_local_data(ha);\n\n\tstatus = qla4xxx_init_firmware(ha);\n\tif (status == QLA_ERROR)\n\t\tgoto exit_init_hba;\n\n\tif (is_reset == RESET_ADAPTER)\n\t\tqla4xxx_build_ddb_list(ha, is_reset);\n\n\tset_bit(AF_ONLINE, &ha->flags);\n\nexit_init_hba:\n\tDEBUG2(printk(\"scsi%ld: initialize adapter: %s\\n\", ha->host_no,\n\t    status == QLA_ERROR ? \"FAILED\" : \"SUCCEEDED\"));\n\treturn status;\n}\n\nint qla4xxx_ddb_change(struct scsi_qla_host *ha, uint32_t fw_ddb_index,\n\t\t       struct ddb_entry *ddb_entry, uint32_t state)\n{\n\tuint32_t old_fw_ddb_device_state;\n\tint status = QLA_ERROR;\n\n\told_fw_ddb_device_state = ddb_entry->fw_ddb_device_state;\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: DDB - old state = 0x%x, new state = 0x%x for \"\n\t\t\t  \"index [%d]\\n\", __func__,\n\t\t\t  ddb_entry->fw_ddb_device_state, state, fw_ddb_index));\n\n\tddb_entry->fw_ddb_device_state = state;\n\n\tswitch (old_fw_ddb_device_state) {\n\tcase DDB_DS_LOGIN_IN_PROCESS:\n\t\tswitch (state) {\n\t\tcase DDB_DS_SESSION_ACTIVE:\n\t\tcase DDB_DS_DISCOVERY:\n\t\t\tqla4xxx_update_session_conn_param(ha, ddb_entry);\n\t\t\tddb_entry->unblock_sess(ddb_entry->sess);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\tcase DDB_DS_SESSION_FAILED:\n\t\tcase DDB_DS_NO_CONNECTION_ACTIVE:\n\t\t\tiscsi_conn_login_event(ddb_entry->conn,\n\t\t\t\t\t       ISCSI_CONN_STATE_FREE);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DDB_DS_SESSION_ACTIVE:\n\tcase DDB_DS_DISCOVERY:\n\t\tswitch (state) {\n\t\tcase DDB_DS_SESSION_FAILED:\n\t\t\t \n\t\t\tiscsi_session_failure(ddb_entry->sess->dd_data,\n\t\t\t\t\t      ISCSI_ERR_CONN_FAILED);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\tcase DDB_DS_NO_CONNECTION_ACTIVE:\n\t\t\tclear_bit(fw_ddb_index, ha->ddb_idx_map);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DDB_DS_SESSION_FAILED:\n\t\tswitch (state) {\n\t\tcase DDB_DS_SESSION_ACTIVE:\n\t\tcase DDB_DS_DISCOVERY:\n\t\t\tddb_entry->unblock_sess(ddb_entry->sess);\n\t\t\tqla4xxx_update_session_conn_param(ha, ddb_entry);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\tcase DDB_DS_SESSION_FAILED:\n\t\t\tiscsi_session_failure(ddb_entry->sess->dd_data,\n\t\t\t\t\t      ISCSI_ERR_CONN_FAILED);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Unknown Event\\n\",\n\t\t\t\t__func__));\n\t\tbreak;\n\t}\n\treturn status;\n}\n\nvoid qla4xxx_arm_relogin_timer(struct ddb_entry *ddb_entry)\n{\n\t \n\tatomic_set(&ddb_entry->relogin_timer, 0);\n\tatomic_set(&ddb_entry->retry_relogin_timer,\n\t\t   ddb_entry->default_time2wait + 4);\n\n}\n\nint qla4xxx_flash_ddb_change(struct scsi_qla_host *ha, uint32_t fw_ddb_index,\n\t\t\t     struct ddb_entry *ddb_entry, uint32_t state)\n{\n\tuint32_t old_fw_ddb_device_state;\n\tint status = QLA_ERROR;\n\n\told_fw_ddb_device_state = ddb_entry->fw_ddb_device_state;\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: DDB - old state = 0x%x, new state = 0x%x for \"\n\t\t\t  \"index [%d]\\n\", __func__,\n\t\t\t  ddb_entry->fw_ddb_device_state, state, fw_ddb_index));\n\n\tddb_entry->fw_ddb_device_state = state;\n\n\tswitch (old_fw_ddb_device_state) {\n\tcase DDB_DS_LOGIN_IN_PROCESS:\n\tcase DDB_DS_NO_CONNECTION_ACTIVE:\n\t\tswitch (state) {\n\t\tcase DDB_DS_SESSION_ACTIVE:\n\t\t\tddb_entry->unblock_sess(ddb_entry->sess);\n\t\t\tqla4xxx_update_session_conn_fwddb_param(ha, ddb_entry);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\tcase DDB_DS_SESSION_FAILED:\n\t\t\tiscsi_block_session(ddb_entry->sess);\n\t\t\tif (!test_bit(DF_RELOGIN, &ddb_entry->flags))\n\t\t\t\tqla4xxx_arm_relogin_timer(ddb_entry);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DDB_DS_SESSION_ACTIVE:\n\t\tswitch (state) {\n\t\tcase DDB_DS_SESSION_FAILED:\n\t\t\tiscsi_block_session(ddb_entry->sess);\n\t\t\tif (!test_bit(DF_RELOGIN, &ddb_entry->flags))\n\t\t\t\tqla4xxx_arm_relogin_timer(ddb_entry);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DDB_DS_SESSION_FAILED:\n\t\tswitch (state) {\n\t\tcase DDB_DS_SESSION_ACTIVE:\n\t\t\tddb_entry->unblock_sess(ddb_entry->sess);\n\t\t\tqla4xxx_update_session_conn_fwddb_param(ha, ddb_entry);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\tcase DDB_DS_SESSION_FAILED:\n\t\t\tif (!test_bit(DF_RELOGIN, &ddb_entry->flags))\n\t\t\t\tqla4xxx_arm_relogin_timer(ddb_entry);\n\t\t\tstatus = QLA_SUCCESS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Unknown Event\\n\",\n\t\t\t\t  __func__));\n\t\tbreak;\n\t}\n\treturn status;\n}\n\n \nint qla4xxx_process_ddb_changed(struct scsi_qla_host *ha,\n\t\t\t\tuint32_t fw_ddb_index,\n\t\t\t\tuint32_t state, uint32_t conn_err)\n{\n\tstruct ddb_entry *ddb_entry;\n\n\t \n\tif (fw_ddb_index >= MAX_DDB_ENTRIES)\n\t\tgoto exit_ddb_event;\n\n\t \n\tddb_entry = qla4xxx_lookup_ddb_by_fw_index(ha, fw_ddb_index);\n\t \n\tif (ddb_entry == NULL) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: No ddb_entry at FW index [%d]\\n\",\n\t\t\t   __func__, fw_ddb_index);\n\n\t\tif (state == DDB_DS_NO_CONNECTION_ACTIVE)\n\t\t\tclear_bit(fw_ddb_index, ha->ddb_idx_map);\n\n\t\tgoto exit_ddb_event;\n\t}\n\n\tddb_entry->ddb_change(ha, fw_ddb_index, ddb_entry, state);\n\nexit_ddb_event:\n\treturn QLA_ERROR;\n}\n\n \nvoid qla4xxx_login_flash_ddb(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess;\n\tstruct ddb_entry *ddb_entry;\n\tstruct scsi_qla_host *ha;\n\tstruct dev_db_entry *fw_ddb_entry = NULL;\n\tdma_addr_t fw_ddb_dma;\n\tuint32_t mbx_sts = 0;\n\tint ret;\n\n\tsess = cls_session->dd_data;\n\tddb_entry = sess->dd_data;\n\tha =  ddb_entry->ha;\n\n\tif (!test_bit(AF_LINK_UP, &ha->flags))\n\t\treturn;\n\n\tif (ddb_entry->ddb_type != FLASH_DDB) {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"Skipping login to non FLASH DB\"));\n\t\tgoto exit_login;\n\t}\n\n\tfw_ddb_entry = dma_pool_alloc(ha->fw_ddb_dma_pool, GFP_KERNEL,\n\t\t\t\t      &fw_ddb_dma);\n\tif (fw_ddb_entry == NULL) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Out of memory\\n\"));\n\t\tgoto exit_login;\n\t}\n\n\tif (ddb_entry->fw_ddb_index == INVALID_ENTRY) {\n\t\tret = qla4xxx_get_ddb_index(ha, &ddb_entry->fw_ddb_index);\n\t\tif (ret == QLA_ERROR)\n\t\t\tgoto exit_login;\n\n\t\tha->fw_ddb_index_map[ddb_entry->fw_ddb_index] = ddb_entry;\n\t\tha->tot_ddbs++;\n\t}\n\n\tmemcpy(fw_ddb_entry, &ddb_entry->fw_ddb_entry,\n\t       sizeof(struct dev_db_entry));\n\tddb_entry->sess->target_id = ddb_entry->fw_ddb_index;\n\n\tret = qla4xxx_set_ddb_entry(ha, ddb_entry->fw_ddb_index,\n\t\t\t\t    fw_ddb_dma, &mbx_sts);\n\tif (ret == QLA_ERROR) {\n\t\tDEBUG2(ql4_printk(KERN_ERR, ha, \"Set DDB failed\\n\"));\n\t\tgoto exit_login;\n\t}\n\n\tddb_entry->fw_ddb_device_state = DDB_DS_LOGIN_IN_PROCESS;\n\tret = qla4xxx_conn_open(ha, ddb_entry->fw_ddb_index);\n\tif (ret == QLA_ERROR) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Login failed: %s\\n\", __func__,\n\t\t\t   sess->targetname);\n\t\tgoto exit_login;\n\t}\n\nexit_login:\n\tif (fw_ddb_entry)\n\t\tdma_pool_free(ha->fw_ddb_dma_pool, fw_ddb_entry, fw_ddb_dma);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}