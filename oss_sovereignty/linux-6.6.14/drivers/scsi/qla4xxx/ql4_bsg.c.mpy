{
  "module_name": "ql4_bsg.c",
  "hash_id": "04570a17c1af62bbbeb91b8371d8844dcbe30d3b2b36f61e98cdf1350b2db136",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/qla4xxx/ql4_bsg.c",
  "human_readable_source": "\n \n\n#include \"ql4_def.h\"\n#include \"ql4_glbl.h\"\n#include \"ql4_bsg.h\"\n\nstatic int\nqla4xxx_read_flash(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tuint32_t offset = 0;\n\tuint32_t length = 0;\n\tdma_addr_t flash_dma;\n\tuint8_t *flash = NULL;\n\tint rval = -EINVAL;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\tgoto leave;\n\n\tif (ql4xxx_reset_active(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: reset active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\tif (ha->flash_state != QLFLASH_WAITING) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: another flash operation \"\n\t\t\t   \"active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\tha->flash_state = QLFLASH_READING;\n\toffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\tlength = bsg_job->reply_payload.payload_len;\n\n\tflash = dma_alloc_coherent(&ha->pdev->dev, length, &flash_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!flash) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: dma alloc failed for flash \"\n\t\t\t   \"data\\n\", __func__);\n\t\trval = -ENOMEM;\n\t\tgoto leave;\n\t}\n\n\trval = qla4xxx_get_flash(ha, flash_dma, offset, length);\n\tif (rval) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: get flash failed\\n\", __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\trval = -EIO;\n\t} else {\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t    bsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t    flash, length);\n\t\tbsg_reply->result = DID_OK << 16;\n\t}\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\tdma_free_coherent(&ha->pdev->dev, length, flash, flash_dma);\nleave:\n\tha->flash_state = QLFLASH_WAITING;\n\treturn rval;\n}\n\nstatic int\nqla4xxx_update_flash(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tuint32_t length = 0;\n\tuint32_t offset = 0;\n\tuint32_t options = 0;\n\tdma_addr_t flash_dma;\n\tuint8_t *flash = NULL;\n\tint rval = -EINVAL;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\tgoto leave;\n\n\tif (ql4xxx_reset_active(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: reset active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\tif (ha->flash_state != QLFLASH_WAITING) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: another flash operation \"\n\t\t\t   \"active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\tha->flash_state = QLFLASH_WRITING;\n\tlength = bsg_job->request_payload.payload_len;\n\toffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\toptions = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\n\n\tflash = dma_alloc_coherent(&ha->pdev->dev, length, &flash_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!flash) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: dma alloc failed for flash \"\n\t\t\t   \"data\\n\", __func__);\n\t\trval = -ENOMEM;\n\t\tgoto leave;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\t  bsg_job->request_payload.sg_cnt, flash, length);\n\n\trval = qla4xxx_set_flash(ha, flash_dma, offset, length, options);\n\tif (rval) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: set flash failed\\n\", __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\trval = -EIO;\n\t} else\n\t\tbsg_reply->result = DID_OK << 16;\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\tdma_free_coherent(&ha->pdev->dev, length, flash, flash_dma);\nleave:\n\tha->flash_state = QLFLASH_WAITING;\n\treturn rval;\n}\n\nstatic int\nqla4xxx_get_acb_state(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tuint32_t status[MBOX_REG_COUNT];\n\tuint32_t acb_idx;\n\tuint32_t ip_idx;\n\tint rval = -EINVAL;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\tgoto leave;\n\n\t \n\tif (is_qla4010(ha))\n\t\tgoto leave;\n\n\tif (ql4xxx_reset_active(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: reset active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\tif (bsg_job->reply_payload.payload_len < sizeof(status)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: invalid payload len %d\\n\",\n\t\t\t   __func__, bsg_job->reply_payload.payload_len);\n\t\trval = -EINVAL;\n\t\tgoto leave;\n\t}\n\n\tacb_idx = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\tip_idx = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\n\n\trval = qla4xxx_get_ip_state(ha, acb_idx, ip_idx, status);\n\tif (rval) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: get ip state failed\\n\",\n\t\t\t   __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\trval = -EIO;\n\t} else {\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t    bsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t    status, sizeof(status));\n\t\tbsg_reply->result = DID_OK << 16;\n\t}\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\nleave:\n\treturn rval;\n}\n\nstatic int\nqla4xxx_read_nvram(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tuint32_t offset = 0;\n\tuint32_t len = 0;\n\tuint32_t total_len = 0;\n\tdma_addr_t nvram_dma;\n\tuint8_t *nvram = NULL;\n\tint rval = -EINVAL;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\tgoto leave;\n\n\t \n\tif (!(is_qla4010(ha) || is_qla4022(ha) || is_qla4032(ha)))\n\t\tgoto leave;\n\n\tif (ql4xxx_reset_active(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: reset active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\toffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\tlen = bsg_job->reply_payload.payload_len;\n\ttotal_len = offset + len;\n\n\t \n\tif ((is_qla4010(ha) && total_len > QL4010_NVRAM_SIZE) ||\n\t    ((is_qla4022(ha) || is_qla4032(ha)) &&\n\t     total_len > QL40X2_NVRAM_SIZE)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: offset+len greater than max\"\n\t\t\t   \" nvram size, offset=%d len=%d\\n\",\n\t\t\t   __func__, offset, len);\n\t\tgoto leave;\n\t}\n\n\tnvram = dma_alloc_coherent(&ha->pdev->dev, len, &nvram_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!nvram) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: dma alloc failed for nvram \"\n\t\t\t   \"data\\n\", __func__);\n\t\trval = -ENOMEM;\n\t\tgoto leave;\n\t}\n\n\trval = qla4xxx_get_nvram(ha, nvram_dma, offset, len);\n\tif (rval) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: get nvram failed\\n\", __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\trval = -EIO;\n\t} else {\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t    bsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t    nvram, len);\n\t\tbsg_reply->result = DID_OK << 16;\n\t}\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\tdma_free_coherent(&ha->pdev->dev, len, nvram, nvram_dma);\nleave:\n\treturn rval;\n}\n\nstatic int\nqla4xxx_update_nvram(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tuint32_t offset = 0;\n\tuint32_t len = 0;\n\tuint32_t total_len = 0;\n\tdma_addr_t nvram_dma;\n\tuint8_t *nvram = NULL;\n\tint rval = -EINVAL;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\tgoto leave;\n\n\tif (!(is_qla4010(ha) || is_qla4022(ha) || is_qla4032(ha)))\n\t\tgoto leave;\n\n\tif (ql4xxx_reset_active(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: reset active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\toffset = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\tlen = bsg_job->request_payload.payload_len;\n\ttotal_len = offset + len;\n\n\t \n\tif ((is_qla4010(ha) && total_len > QL4010_NVRAM_SIZE) ||\n\t    ((is_qla4022(ha) || is_qla4032(ha)) &&\n\t     total_len > QL40X2_NVRAM_SIZE)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: offset+len greater than max\"\n\t\t\t   \" nvram size, offset=%d len=%d\\n\",\n\t\t\t   __func__, offset, len);\n\t\tgoto leave;\n\t}\n\n\tnvram = dma_alloc_coherent(&ha->pdev->dev, len, &nvram_dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!nvram) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: dma alloc failed for flash \"\n\t\t\t   \"data\\n\", __func__);\n\t\trval = -ENOMEM;\n\t\tgoto leave;\n\t}\n\n\tsg_copy_to_buffer(bsg_job->request_payload.sg_list,\n\t\t\t  bsg_job->request_payload.sg_cnt, nvram, len);\n\n\trval = qla4xxx_set_nvram(ha, nvram_dma, offset, len);\n\tif (rval) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: set nvram failed\\n\", __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\trval = -EIO;\n\t} else\n\t\tbsg_reply->result = DID_OK << 16;\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\tdma_free_coherent(&ha->pdev->dev, len, nvram, nvram_dma);\nleave:\n\treturn rval;\n}\n\nstatic int\nqla4xxx_restore_defaults(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tuint32_t region = 0;\n\tuint32_t field0 = 0;\n\tuint32_t field1 = 0;\n\tint rval = -EINVAL;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\tgoto leave;\n\n\tif (is_qla4010(ha))\n\t\tgoto leave;\n\n\tif (ql4xxx_reset_active(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: reset active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\tregion = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\tfield0 = bsg_req->rqst_data.h_vendor.vendor_cmd[2];\n\tfield1 = bsg_req->rqst_data.h_vendor.vendor_cmd[3];\n\n\trval = qla4xxx_restore_factory_defaults(ha, region, field0, field1);\n\tif (rval) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: set nvram failed\\n\", __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\trval = -EIO;\n\t} else\n\t\tbsg_reply->result = DID_OK << 16;\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\nleave:\n\treturn rval;\n}\n\nstatic int\nqla4xxx_bsg_get_acb(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tuint32_t acb_type = 0;\n\tuint32_t len = 0;\n\tdma_addr_t acb_dma;\n\tuint8_t *acb = NULL;\n\tint rval = -EINVAL;\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (unlikely(pci_channel_offline(ha->pdev)))\n\t\tgoto leave;\n\n\t \n\tif (is_qla4010(ha))\n\t\tgoto leave;\n\n\tif (ql4xxx_reset_active(ha)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: reset active\\n\", __func__);\n\t\trval = -EBUSY;\n\t\tgoto leave;\n\t}\n\n\tacb_type = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\tlen = bsg_job->reply_payload.payload_len;\n\tif (len < sizeof(struct addr_ctrl_blk)) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: invalid acb len %d\\n\",\n\t\t\t   __func__, len);\n\t\trval = -EINVAL;\n\t\tgoto leave;\n\t}\n\n\tacb = dma_alloc_coherent(&ha->pdev->dev, len, &acb_dma, GFP_KERNEL);\n\tif (!acb) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: dma alloc failed for acb \"\n\t\t\t   \"data\\n\", __func__);\n\t\trval = -ENOMEM;\n\t\tgoto leave;\n\t}\n\n\trval = qla4xxx_get_acb(ha, acb_dma, acb_type, len);\n\tif (rval) {\n\t\tql4_printk(KERN_ERR, ha, \"%s: get acb failed\\n\", __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\trval = -EIO;\n\t} else {\n\t\tbsg_reply->reply_payload_rcv_len =\n\t\t\tsg_copy_from_buffer(bsg_job->reply_payload.sg_list,\n\t\t\t\t\t    bsg_job->reply_payload.sg_cnt,\n\t\t\t\t\t    acb, len);\n\t\tbsg_reply->result = DID_OK << 16;\n\t}\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n\tdma_free_coherent(&ha->pdev->dev, len, acb, acb_dma);\nleave:\n\treturn rval;\n}\n\nstatic void ql4xxx_execute_diag_cmd(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tuint8_t *rsp_ptr = NULL;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint status = QLA_ERROR;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: in\\n\", __func__));\n\n\tif (test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: Adapter reset in progress. Invalid Request\\n\",\n\t\t\t   __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\tgoto exit_diag_mem_test;\n\t}\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\tmemcpy(mbox_cmd, &bsg_req->rqst_data.h_vendor.vendor_cmd[1],\n\t       sizeof(uint32_t) * MBOX_REG_COUNT);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: mbox_cmd: %08X %08X %08X %08X %08X %08X %08X %08X\\n\",\n\t\t\t  __func__, mbox_cmd[0], mbox_cmd[1], mbox_cmd[2],\n\t\t\t  mbox_cmd[3], mbox_cmd[4], mbox_cmd[5], mbox_cmd[6],\n\t\t\t  mbox_cmd[7]));\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 8, &mbox_cmd[0],\n\t\t\t\t\t &mbox_sts[0]);\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: mbox_sts: %08X %08X %08X %08X %08X %08X %08X %08X\\n\",\n\t\t\t  __func__, mbox_sts[0], mbox_sts[1], mbox_sts[2],\n\t\t\t  mbox_sts[3], mbox_sts[4], mbox_sts[5], mbox_sts[6],\n\t\t\t  mbox_sts[7]));\n\n\tif (status == QLA_SUCCESS)\n\t\tbsg_reply->result = DID_OK << 16;\n\telse\n\t\tbsg_reply->result = DID_ERROR << 16;\n\n\t \n\tbsg_job->reply_len = sizeof(struct iscsi_bsg_reply) + sizeof(mbox_sts);\n\trsp_ptr = ((uint8_t *)bsg_reply) + sizeof(struct iscsi_bsg_reply);\n\tmemcpy(rsp_ptr, mbox_sts, sizeof(mbox_sts));\n\nexit_diag_mem_test:\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: bsg_reply->result = x%x, status = %s\\n\",\n\t\t\t  __func__, bsg_reply->result, STATUS(status)));\n\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n}\n\nstatic int qla4_83xx_wait_for_loopback_config_comp(struct scsi_qla_host *ha,\n\t\t\t\t\t\t   int wait_for_link)\n{\n\tint status = QLA_SUCCESS;\n\n\tif (!wait_for_completion_timeout(&ha->idc_comp, (IDC_COMP_TOV * HZ))) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: IDC Complete notification not received, Waiting for another %d timeout\",\n\t\t\t   __func__, ha->idc_extend_tmo);\n\t\tif (ha->idc_extend_tmo) {\n\t\t\tif (!wait_for_completion_timeout(&ha->idc_comp,\n\t\t\t\t\t\t(ha->idc_extend_tmo * HZ))) {\n\t\t\t\tha->notify_idc_comp = 0;\n\t\t\t\tha->notify_link_up_comp = 0;\n\t\t\t\tql4_printk(KERN_WARNING, ha, \"%s: Aborting: IDC Complete notification not received\",\n\t\t\t\t\t   __func__);\n\t\t\t\tstatus = QLA_ERROR;\n\t\t\t\tgoto exit_wait;\n\t\t\t} else {\n\t\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t\t  \"%s: IDC Complete notification received\\n\",\n\t\t\t\t\t\t  __func__));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t  \"%s: IDC Complete notification received\\n\",\n\t\t\t\t  __func__));\n\t}\n\tha->notify_idc_comp = 0;\n\n\tif (wait_for_link) {\n\t\tif (!wait_for_completion_timeout(&ha->link_up_comp,\n\t\t\t\t\t\t (IDC_COMP_TOV * HZ))) {\n\t\t\tha->notify_link_up_comp = 0;\n\t\t\tql4_printk(KERN_WARNING, ha, \"%s: Aborting: LINK UP notification not received\",\n\t\t\t\t   __func__);\n\t\t\tstatus = QLA_ERROR;\n\t\t\tgoto exit_wait;\n\t\t} else {\n\t\t\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t\t\t  \"%s: LINK UP notification received\\n\",\n\t\t\t\t\t  __func__));\n\t\t}\n\t\tha->notify_link_up_comp = 0;\n\t}\n\nexit_wait:\n\treturn status;\n}\n\nstatic int qla4_83xx_pre_loopback_config(struct scsi_qla_host *ha,\n\t\t\t\t\t uint32_t *mbox_cmd)\n{\n\tuint32_t config = 0;\n\tint status = QLA_SUCCESS;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: in\\n\", __func__));\n\n\tstatus = qla4_83xx_get_port_config(ha, &config);\n\tif (status != QLA_SUCCESS)\n\t\tgoto exit_pre_loopback_config;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: Default port config=%08X\\n\",\n\t\t\t  __func__, config));\n\n\tif ((config & ENABLE_INTERNAL_LOOPBACK) ||\n\t    (config & ENABLE_EXTERNAL_LOOPBACK)) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: Loopback diagnostics already in progress. Invalid request\\n\",\n\t\t\t   __func__);\n\t\tgoto exit_pre_loopback_config;\n\t}\n\n\tif (mbox_cmd[1] == QL_DIAG_CMD_TEST_INT_LOOPBACK)\n\t\tconfig |= ENABLE_INTERNAL_LOOPBACK;\n\n\tif (mbox_cmd[1] == QL_DIAG_CMD_TEST_EXT_LOOPBACK)\n\t\tconfig |= ENABLE_EXTERNAL_LOOPBACK;\n\n\tconfig &= ~ENABLE_DCBX;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: New port config=%08X\\n\",\n\t\t\t  __func__, config));\n\n\tha->notify_idc_comp = 1;\n\tha->notify_link_up_comp = 1;\n\n\t \n\tqla4xxx_get_firmware_state(ha);\n\n\tstatus = qla4_83xx_set_port_config(ha, &config);\n\tif (status != QLA_SUCCESS) {\n\t\tha->notify_idc_comp = 0;\n\t\tha->notify_link_up_comp = 0;\n\t\tgoto exit_pre_loopback_config;\n\t}\nexit_pre_loopback_config:\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: status = %s\\n\", __func__,\n\t\t\t  STATUS(status)));\n\treturn status;\n}\n\nstatic int qla4_83xx_post_loopback_config(struct scsi_qla_host *ha,\n\t\t\t\t\t  uint32_t *mbox_cmd)\n{\n\tint status = QLA_SUCCESS;\n\tuint32_t config = 0;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: in\\n\", __func__));\n\n\tstatus = qla4_83xx_get_port_config(ha, &config);\n\tif (status != QLA_SUCCESS)\n\t\tgoto exit_post_loopback_config;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: port config=%08X\\n\", __func__,\n\t\t\t  config));\n\n\tif (mbox_cmd[1] == QL_DIAG_CMD_TEST_INT_LOOPBACK)\n\t\tconfig &= ~ENABLE_INTERNAL_LOOPBACK;\n\telse if (mbox_cmd[1] == QL_DIAG_CMD_TEST_EXT_LOOPBACK)\n\t\tconfig &= ~ENABLE_EXTERNAL_LOOPBACK;\n\n\tconfig |= ENABLE_DCBX;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: Restore default port config=%08X\\n\", __func__,\n\t\t\t  config));\n\n\tha->notify_idc_comp = 1;\n\tif (ha->addl_fw_state & FW_ADDSTATE_LINK_UP)\n\t\tha->notify_link_up_comp = 1;\n\n\tstatus = qla4_83xx_set_port_config(ha, &config);\n\tif (status != QLA_SUCCESS) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: Scheduling adapter reset\\n\",\n\t\t\t   __func__);\n\t\tset_bit(DPC_RESET_HA, &ha->dpc_flags);\n\t\tclear_bit(AF_LOOPBACK, &ha->flags);\n\t\tgoto exit_post_loopback_config;\n\t}\n\nexit_post_loopback_config:\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: status = %s\\n\", __func__,\n\t\t\t  STATUS(status)));\n\treturn status;\n}\n\nstatic void qla4xxx_execute_diag_loopback_cmd(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tuint8_t *rsp_ptr = NULL;\n\tuint32_t mbox_cmd[MBOX_REG_COUNT];\n\tuint32_t mbox_sts[MBOX_REG_COUNT];\n\tint wait_for_link = 1;\n\tint status = QLA_ERROR;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: in\\n\", __func__));\n\n\tbsg_reply->reply_payload_rcv_len = 0;\n\n\tif (test_bit(AF_LOOPBACK, &ha->flags)) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: Loopback Diagnostics already in progress. Invalid Request\\n\",\n\t\t\t   __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\tgoto exit_loopback_cmd;\n\t}\n\n\tif (test_bit(DPC_RESET_HA, &ha->dpc_flags)) {\n\t\tql4_printk(KERN_INFO, ha, \"%s: Adapter reset in progress. Invalid Request\\n\",\n\t\t\t   __func__);\n\t\tbsg_reply->result = DID_ERROR << 16;\n\t\tgoto exit_loopback_cmd;\n\t}\n\n\tmemcpy(mbox_cmd, &bsg_req->rqst_data.h_vendor.vendor_cmd[1],\n\t       sizeof(uint32_t) * MBOX_REG_COUNT);\n\n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tstatus = qla4_83xx_pre_loopback_config(ha, mbox_cmd);\n\t\tif (status != QLA_SUCCESS) {\n\t\t\tbsg_reply->result = DID_ERROR << 16;\n\t\t\tgoto exit_loopback_cmd;\n\t\t}\n\n\t\tstatus = qla4_83xx_wait_for_loopback_config_comp(ha,\n\t\t\t\t\t\t\t\t wait_for_link);\n\t\tif (status != QLA_SUCCESS) {\n\t\t\tbsg_reply->result = DID_TIME_OUT << 16;\n\t\t\tgoto restore;\n\t\t}\n\t}\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: mbox_cmd: %08X %08X %08X %08X %08X %08X %08X %08X\\n\",\n\t\t\t  __func__, mbox_cmd[0], mbox_cmd[1], mbox_cmd[2],\n\t\t\t  mbox_cmd[3], mbox_cmd[4], mbox_cmd[5], mbox_cmd[6],\n\t\t\t  mbox_cmd[7]));\n\n\tstatus = qla4xxx_mailbox_command(ha, MBOX_REG_COUNT, 8, &mbox_cmd[0],\n\t\t\t\t&mbox_sts[0]);\n\n\tif (status == QLA_SUCCESS)\n\t\tbsg_reply->result = DID_OK << 16;\n\telse\n\t\tbsg_reply->result = DID_ERROR << 16;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: mbox_sts: %08X %08X %08X %08X %08X %08X %08X %08X\\n\",\n\t\t\t  __func__, mbox_sts[0], mbox_sts[1], mbox_sts[2],\n\t\t\t  mbox_sts[3], mbox_sts[4], mbox_sts[5], mbox_sts[6],\n\t\t\t  mbox_sts[7]));\n\n\t \n\tbsg_job->reply_len = sizeof(struct iscsi_bsg_reply) + sizeof(mbox_sts);\n\trsp_ptr = ((uint8_t *)bsg_reply) + sizeof(struct iscsi_bsg_reply);\n\tmemcpy(rsp_ptr, mbox_sts, sizeof(mbox_sts));\nrestore:\n\tif (is_qla8032(ha) || is_qla8042(ha)) {\n\t\tstatus = qla4_83xx_post_loopback_config(ha, mbox_cmd);\n\t\tif (status != QLA_SUCCESS) {\n\t\t\tbsg_reply->result = DID_ERROR << 16;\n\t\t\tgoto exit_loopback_cmd;\n\t\t}\n\n\t\t \n\t\tif (!(ha->addl_fw_state & FW_ADDSTATE_LINK_UP))\n\t\t\twait_for_link = 0;\n\n\t\tstatus = qla4_83xx_wait_for_loopback_config_comp(ha,\n\t\t\t\t\t\t\t\t wait_for_link);\n\t\tif (status != QLA_SUCCESS) {\n\t\t\tbsg_reply->result = DID_TIME_OUT << 16;\n\t\t\tgoto exit_loopback_cmd;\n\t\t}\n\t}\nexit_loopback_cmd:\n\tDEBUG2(ql4_printk(KERN_INFO, ha,\n\t\t\t  \"%s: bsg_reply->result = x%x, status = %s\\n\",\n\t\t\t  __func__, bsg_reply->result, STATUS(status)));\n\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t     bsg_reply->reply_payload_rcv_len);\n}\n\nstatic int qla4xxx_execute_diag_test(struct bsg_job *bsg_job)\n{\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tuint32_t diag_cmd;\n\tint rval = -EINVAL;\n\n\tDEBUG2(ql4_printk(KERN_INFO, ha, \"%s: in\\n\", __func__));\n\n\tdiag_cmd = bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\tif (diag_cmd == MBOX_CMD_DIAG_TEST) {\n\t\tswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[2]) {\n\t\tcase QL_DIAG_CMD_TEST_DDR_SIZE:\n\t\tcase QL_DIAG_CMD_TEST_DDR_RW:\n\t\tcase QL_DIAG_CMD_TEST_ONCHIP_MEM_RW:\n\t\tcase QL_DIAG_CMD_TEST_NVRAM:\n\t\tcase QL_DIAG_CMD_TEST_FLASH_ROM:\n\t\tcase QL_DIAG_CMD_TEST_DMA_XFER:\n\t\tcase QL_DIAG_CMD_SELF_DDR_RW:\n\t\tcase QL_DIAG_CMD_SELF_ONCHIP_MEM_RW:\n\t\t\t \n\t\t\tql4xxx_execute_diag_cmd(bsg_job);\n\t\t\t \n\t\t\trval = QLA_SUCCESS;\n\t\t\tbreak;\n\n\t\tcase QL_DIAG_CMD_TEST_INT_LOOPBACK:\n\t\tcase QL_DIAG_CMD_TEST_EXT_LOOPBACK:\n\t\t\t \n\t\t\tqla4xxx_execute_diag_loopback_cmd(bsg_job);\n\t\t\t \n\t\t\trval = QLA_SUCCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tql4_printk(KERN_ERR, ha, \"%s: Invalid diag test: 0x%x\\n\",\n\t\t\t\t   __func__,\n\t\t\t\t   bsg_req->rqst_data.h_vendor.vendor_cmd[2]);\n\t\t}\n\t} else if ((diag_cmd == MBOX_CMD_SET_LED_CONFIG) ||\n\t\t   (diag_cmd == MBOX_CMD_GET_LED_CONFIG)) {\n\t\tql4xxx_execute_diag_cmd(bsg_job);\n\t\trval = QLA_SUCCESS;\n\t} else {\n\t\tql4_printk(KERN_ERR, ha, \"%s: Invalid diag cmd: 0x%x\\n\",\n\t\t\t   __func__, diag_cmd);\n\t}\n\n\treturn rval;\n}\n\n \nint qla4xxx_process_vendor_specific(struct bsg_job *bsg_job)\n{\n\tstruct iscsi_bsg_reply *bsg_reply = bsg_job->reply;\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\n\tswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[0]) {\n\tcase QLISCSI_VND_READ_FLASH:\n\t\treturn qla4xxx_read_flash(bsg_job);\n\n\tcase QLISCSI_VND_UPDATE_FLASH:\n\t\treturn qla4xxx_update_flash(bsg_job);\n\n\tcase QLISCSI_VND_GET_ACB_STATE:\n\t\treturn qla4xxx_get_acb_state(bsg_job);\n\n\tcase QLISCSI_VND_READ_NVRAM:\n\t\treturn qla4xxx_read_nvram(bsg_job);\n\n\tcase QLISCSI_VND_UPDATE_NVRAM:\n\t\treturn qla4xxx_update_nvram(bsg_job);\n\n\tcase QLISCSI_VND_RESTORE_DEFAULTS:\n\t\treturn qla4xxx_restore_defaults(bsg_job);\n\n\tcase QLISCSI_VND_GET_ACB:\n\t\treturn qla4xxx_bsg_get_acb(bsg_job);\n\n\tcase QLISCSI_VND_DIAG_TEST:\n\t\treturn qla4xxx_execute_diag_test(bsg_job);\n\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"%s: invalid BSG vendor command: \"\n\t\t\t   \"0x%x\\n\", __func__, bsg_req->msgcode);\n\t\tbsg_reply->result = (DID_ERROR << 16);\n\t\tbsg_reply->reply_payload_rcv_len = 0;\n\t\tbsg_job_done(bsg_job, bsg_reply->result,\n\t\t\t     bsg_reply->reply_payload_rcv_len);\n\t\treturn -ENOSYS;\n\t}\n}\n\n \nint qla4xxx_bsg_request(struct bsg_job *bsg_job)\n{\n\tstruct iscsi_bsg_request *bsg_req = bsg_job->request;\n\tstruct Scsi_Host *host = iscsi_job_to_shost(bsg_job);\n\tstruct scsi_qla_host *ha = to_qla_host(host);\n\n\tswitch (bsg_req->msgcode) {\n\tcase ISCSI_BSG_HST_VENDOR:\n\t\treturn qla4xxx_process_vendor_specific(bsg_job);\n\n\tdefault:\n\t\tql4_printk(KERN_ERR, ha, \"%s: invalid BSG command: 0x%x\\n\",\n\t\t\t   __func__, bsg_req->msgcode);\n\t}\n\n\treturn -ENOSYS;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}