{
  "module_name": "linit.c",
  "hash_id": "121e4145525d0cfb75e159c652f228bf9596e77c3d231bf741c8ea14be305de1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/linit.c",
  "human_readable_source": "\n \n\n\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/msdos_partition.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsicam.h>\n#include <scsi/scsi_eh.h>\n\n#include \"aacraid.h\"\n\n#define AAC_DRIVER_VERSION\t\t\"1.2.1\"\n#ifndef AAC_DRIVER_BRANCH\n#define AAC_DRIVER_BRANCH\t\t\"\"\n#endif\n#define AAC_DRIVERNAME\t\t\t\"aacraid\"\n\n#ifdef AAC_DRIVER_BUILD\n#define _str(x) #x\n#define str(x) _str(x)\n#define AAC_DRIVER_FULL_VERSION\tAAC_DRIVER_VERSION \"[\" str(AAC_DRIVER_BUILD) \"]\" AAC_DRIVER_BRANCH\n#else\n#define AAC_DRIVER_FULL_VERSION\tAAC_DRIVER_VERSION AAC_DRIVER_BRANCH\n#endif\n\nMODULE_AUTHOR(\"Red Hat Inc and Adaptec\");\nMODULE_DESCRIPTION(\"Dell PERC2, 2/Si, 3/Si, 3/Di, \"\n\t\t   \"Adaptec Advanced Raid Products, \"\n\t\t   \"HP NetRAID-4M, IBM ServeRAID & ICP SCSI driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(AAC_DRIVER_FULL_VERSION);\n\nstatic DEFINE_MUTEX(aac_mutex);\nstatic LIST_HEAD(aac_devices);\nstatic int aac_cfg_major = AAC_CHARDEV_UNREGISTERED;\nchar aac_driver_version[] = AAC_DRIVER_FULL_VERSION;\n\n \nstatic const struct pci_device_id aac_pci_tbl[] = {\n\t{ 0x1028, 0x0001, 0x1028, 0x0001, 0, 0, 0 },  \n\t{ 0x1028, 0x0002, 0x1028, 0x0002, 0, 0, 1 },  \n\t{ 0x1028, 0x0003, 0x1028, 0x0003, 0, 0, 2 },  \n\t{ 0x1028, 0x0004, 0x1028, 0x00d0, 0, 0, 3 },  \n\t{ 0x1028, 0x0002, 0x1028, 0x00d1, 0, 0, 4 },  \n\t{ 0x1028, 0x0002, 0x1028, 0x00d9, 0, 0, 5 },  \n\t{ 0x1028, 0x000a, 0x1028, 0x0106, 0, 0, 6 },  \n\t{ 0x1028, 0x000a, 0x1028, 0x011b, 0, 0, 7 },  \n\t{ 0x1028, 0x000a, 0x1028, 0x0121, 0, 0, 8 },  \n\t{ 0x9005, 0x0283, 0x9005, 0x0283, 0, 0, 9 },  \n\t{ 0x9005, 0x0284, 0x9005, 0x0284, 0, 0, 10 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0286, 0, 0, 11 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0285, 0, 0, 12 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0287, 0, 0, 13 },  \n\t{ 0x9005, 0x0285, 0x17aa, 0x0286, 0, 0, 14 },  \n\t{ 0x9005, 0x0285, 0x17aa, 0x0287, 0, 0, 15 },  \n\n\t{ 0x9005, 0x0285, 0x9005, 0x0288, 0, 0, 16 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0289, 0, 0, 17 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x028a, 0, 0, 18 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x028b, 0, 0, 19 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x028c, 0, 0, 20 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x028d, 0, 0, 21 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x029b, 0, 0, 22 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x029c, 0, 0, 23 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x029d, 0, 0, 24 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x029e, 0, 0, 25 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x029f, 0, 0, 26 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x02a0, 0, 0, 27 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x02a1, 0, 0, 28 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x02a3, 0, 0, 29 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x02a4, 0, 0, 30 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x02a5, 0, 0, 31 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x02a6, 0, 0, 32 },  \n\t{ 0x9005, 0x0287, 0x9005, 0x0800, 0, 0, 33 },  \n\t{ 0x9005, 0x0200, 0x9005, 0x0200, 0, 0, 33 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x0800, 0, 0, 34 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x028e, 0, 0, 35 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x028f, 0, 0, 36 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0290, 0, 0, 37 },  \n\t{ 0x9005, 0x0285, 0x1028, 0x0291, 0, 0, 38 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0292, 0, 0, 39 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0293, 0, 0, 40 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0294, 0, 0, 41 },  \n\t{ 0x9005, 0x0285, 0x103C, 0x3227, 0, 0, 42 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0296, 0, 0, 43 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0297, 0, 0, 44 },  \n\t{ 0x9005, 0x0285, 0x1014, 0x02F2, 0, 0, 45 },  \n\t{ 0x9005, 0x0285, 0x1014, 0x0312, 0, 0, 45 },  \n\t{ 0x9005, 0x0286, 0x1014, 0x9580, 0, 0, 46 },  \n\t{ 0x9005, 0x0286, 0x1014, 0x9540, 0, 0, 47 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0298, 0, 0, 48 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x0299, 0, 0, 49 },  \n\t{ 0x9005, 0x0285, 0x9005, 0x029a, 0, 0, 50 },  \n\t{ 0x9005, 0x0286, 0x9005, 0x02a2, 0, 0, 51 },  \n\n\t{ 0x9005, 0x0285, 0x1028, 0x0287, 0, 0, 52 },  \n\t{ 0x1011, 0x0046, 0x9005, 0x0365, 0, 0, 53 },  \n\t{ 0x1011, 0x0046, 0x9005, 0x0364, 0, 0, 54 },  \n\t{ 0x1011, 0x0046, 0x9005, 0x1364, 0, 0, 55 },  \n\t{ 0x1011, 0x0046, 0x103c, 0x10c2, 0, 0, 56 },  \n\n\t{ 0x9005, 0x0285, 0x1028, PCI_ANY_ID, 0, 0, 57 },  \n\t{ 0x9005, 0x0285, 0x17aa, PCI_ANY_ID, 0, 0, 58 },  \n\t{ 0x9005, 0x0285, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 59 },  \n\t{ 0x9005, 0x0286, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 60 },  \n\t{ 0x9005, 0x0288, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 61 },  \n\t{ 0x9005, 0x028b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 62 },  \n\t{ 0x9005, 0x028c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 63 },  \n\t{ 0x9005, 0x028d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 64 },  \n\t{ 0,}\n};\nMODULE_DEVICE_TABLE(pci, aac_pci_tbl);\n\n \nstatic struct aac_driver_ident aac_drivers[] = {\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"catapult        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"tomcat          \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2120S   \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG },\t\t       \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2200S   \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG },\t\t       \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2200S   \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"Legend S220     \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"Legend S230     \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 3230S   \", 2 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 3240S   \", 2 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2020ZCR     \", 2 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2025ZCR     \", 2 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2230S PCI-X \", 2 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2130S PCI-X \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2820SA      \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2620SA      \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2420SA      \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9024RO       \", 2 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9014RO       \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9047MA       \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9087MA       \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP5445AU       \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ICP     \", \"ICP9085LI       \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ICP     \", \"ICP5085BR       \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9067MA       \", 1 },  \n\t{ NULL        , \"aacraid\",  \"ADAPTEC \", \"Themisto        \", 0, AAC_QUIRK_SLAVE },  \n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"Callisto        \", 2, AAC_QUIRK_MASTER },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2020SA       \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2025SA       \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2410SA SATA \", 1, AAC_QUIRK_17SG },  \n\t{ aac_rx_init, \"aacraid\",  \"DELL    \", \"CERC SR2        \", 1, AAC_QUIRK_17SG },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2810SA SATA \", 1, AAC_QUIRK_17SG },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-21610SA SATA\", 1, AAC_QUIRK_17SG },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2026ZCR     \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2610SA      \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2240S       \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4005        \", 1 },  \n\t{ aac_rx_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8i    \", 1 },  \n\t{ aac_rkt_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8k-l8 \", 1 },  \n\t{ aac_rkt_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8k-l4 \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4000        \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4800SAS     \", 1 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4805SAS     \", 1 },  \n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-3800        \", 1 },  \n\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERC 320/DC     \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG },  \n\t{ aac_sa_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 5400S   \", 4, AAC_QUIRK_34SG },  \n\t{ aac_sa_init, \"aacraid\",  \"ADAPTEC \", \"AAC-364         \", 4, AAC_QUIRK_34SG },  \n\t{ aac_sa_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 4, AAC_QUIRK_34SG },  \n\t{ aac_sa_init, \"hpnraid\",  \"HP      \", \"NetRAID         \", 4, AAC_QUIRK_34SG },  \n\n\t{ aac_rx_init, \"aacraid\",  \"DELL    \", \"RAID            \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"RAID            \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 },  \n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"RAID            \", 2 },  \n\t{ aac_rkt_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 },  \n\t{ aac_nark_init, \"aacraid\", \"ADAPTEC \", \"RAID           \", 2 },  \n\t{ aac_src_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2, AAC_QUIRK_SRC },  \n\t{ aac_srcv_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2, AAC_QUIRK_SRC },  \n\t{ aac_srcv_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2, AAC_QUIRK_SRC },  \n};\n\n \n\nstatic int aac_queuecommand(struct Scsi_Host *shost,\n\t\t\t    struct scsi_cmnd *cmd)\n{\n\taac_priv(cmd)->owner = AAC_OWNER_LOWLEVEL;\n\n\treturn aac_scsi_cmd(cmd) ? FAILED : 0;\n}\n\n \n\nstatic const char *aac_info(struct Scsi_Host *shost)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)shost->hostdata;\n\treturn aac_drivers[dev->cardtype].name;\n}\n\n \n\nstruct aac_driver_ident* aac_get_driver_ident(int devtype)\n{\n\treturn &aac_drivers[devtype];\n}\n\n \n\nstatic int aac_biosparm(struct scsi_device *sdev, struct block_device *bdev,\n\t\t\tsector_t capacity, int *geom)\n{\n\tstruct diskparm *param = (struct diskparm *)geom;\n\tunsigned char *buf;\n\n\tdprintk((KERN_DEBUG \"aac_biosparm.\\n\"));\n\n\t \n\tif (capacity >= 2 * 1024 * 1024) {  \n\t\tif(capacity >= 4 * 1024 * 1024) {  \n\t\t\tparam->heads = 255;\n\t\t\tparam->sectors = 63;\n\t\t} else {\n\t\t\tparam->heads = 128;\n\t\t\tparam->sectors = 32;\n\t\t}\n\t} else {\n\t\tparam->heads = 64;\n\t\tparam->sectors = 32;\n\t}\n\n\tparam->cylinders = cap_to_cyls(capacity, param->heads * param->sectors);\n\n\t \n\tbuf = scsi_bios_ptable(bdev);\n\tif (!buf)\n\t\treturn 0;\n\tif (*(__le16 *)(buf + 0x40) == cpu_to_le16(MSDOS_LABEL_MAGIC)) {\n\t\tstruct msdos_partition *first = (struct msdos_partition *)buf;\n\t\tstruct msdos_partition *entry = first;\n\t\tint saved_cylinders = param->cylinders;\n\t\tint num;\n\t\tunsigned char end_head, end_sec;\n\n\t\tfor(num = 0; num < 4; num++) {\n\t\t\tend_head = entry->end_head;\n\t\t\tend_sec = entry->end_sector & 0x3f;\n\n\t\t\tif(end_head == 63) {\n\t\t\t\tparam->heads = 64;\n\t\t\t\tparam->sectors = 32;\n\t\t\t\tbreak;\n\t\t\t} else if(end_head == 127) {\n\t\t\t\tparam->heads = 128;\n\t\t\t\tparam->sectors = 32;\n\t\t\t\tbreak;\n\t\t\t} else if(end_head == 254) {\n\t\t\t\tparam->heads = 255;\n\t\t\t\tparam->sectors = 63;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry++;\n\t\t}\n\n\t\tif (num == 4) {\n\t\t\tend_head = first->end_head;\n\t\t\tend_sec = first->end_sector & 0x3f;\n\t\t}\n\n\t\tparam->cylinders = cap_to_cyls(capacity, param->heads * param->sectors);\n\t\tif (num < 4 && end_sec == param->sectors) {\n\t\t\tif (param->cylinders != saved_cylinders) {\n\t\t\t\tdprintk((KERN_DEBUG \"Adopting geometry: heads=%d, sectors=%d from partition table %d.\\n\",\n\t\t\t\t\tparam->heads, param->sectors, num));\n\t\t\t}\n\t\t} else if (end_head > 0 || end_sec > 0) {\n\t\t\tdprintk((KERN_DEBUG \"Strange geometry: heads=%d, sectors=%d in partition table %d.\\n\",\n\t\t\t\tend_head + 1, end_sec, num));\n\t\t\tdprintk((KERN_DEBUG \"Using geometry: heads=%d, sectors=%d.\\n\",\n\t\t\t\t\tparam->heads, param->sectors));\n\t\t}\n\t}\n\tkfree(buf);\n\treturn 0;\n}\n\n \n\nstatic int aac_slave_configure(struct scsi_device *sdev)\n{\n\tstruct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;\n\tint chn, tid;\n\tunsigned int depth = 0;\n\tunsigned int set_timeout = 0;\n\tint timeout = 0;\n\tbool set_qd_dev_type = false;\n\tu8 devtype = 0;\n\n\tchn = aac_logical_to_phys(sdev_channel(sdev));\n\ttid = sdev_id(sdev);\n\tif (chn < AAC_MAX_BUSES && tid < AAC_MAX_TARGETS && aac->sa_firmware) {\n\t\tdevtype = aac->hba_map[chn][tid].devtype;\n\n\t\tif (devtype == AAC_DEVTYPE_NATIVE_RAW) {\n\t\t\tdepth = aac->hba_map[chn][tid].qd_limit;\n\t\t\tset_timeout = 1;\n\t\t\tgoto common_config;\n\t\t}\n\t\tif (devtype == AAC_DEVTYPE_ARC_RAW) {\n\t\t\tset_qd_dev_type = true;\n\t\t\tset_timeout = 1;\n\t\t\tgoto common_config;\n\t\t}\n\t}\n\n\tif (aac->jbod && (sdev->type == TYPE_DISK))\n\t\tsdev->removable = 1;\n\n\tif (sdev->type == TYPE_DISK\n\t && sdev_channel(sdev) != CONTAINER_CHANNEL\n\t && (!aac->jbod || sdev->inq_periph_qual)\n\t && (!aac->raid_scsi_mode || (sdev_channel(sdev) != 2))) {\n\n\t\tif (expose_physicals == 0)\n\t\t\treturn -ENXIO;\n\n\t\tif (expose_physicals < 0)\n\t\t\tsdev->no_uld_attach = 1;\n\t}\n\n\tif (sdev->tagged_supported\n\t &&  sdev->type == TYPE_DISK\n\t &&  (!aac->raid_scsi_mode || (sdev_channel(sdev) != 2))\n\t && !sdev->no_uld_attach) {\n\n\t\tstruct scsi_device * dev;\n\t\tstruct Scsi_Host *host = sdev->host;\n\t\tunsigned num_lsu = 0;\n\t\tunsigned num_one = 0;\n\t\tunsigned cid;\n\n\t\tset_timeout = 1;\n\n\t\tfor (cid = 0; cid < aac->maximum_num_containers; ++cid)\n\t\t\tif (aac->fsa_dev[cid].valid)\n\t\t\t\t++num_lsu;\n\n\t\t__shost_for_each_device(dev, host) {\n\t\t\tif (dev->tagged_supported\n\t\t\t && dev->type == TYPE_DISK\n\t\t\t && (!aac->raid_scsi_mode || (sdev_channel(sdev) != 2))\n\t\t\t && !dev->no_uld_attach) {\n\t\t\t\tif ((sdev_channel(dev) != CONTAINER_CHANNEL)\n\t\t\t\t || !aac->fsa_dev[sdev_id(dev)].valid) {\n\t\t\t\t\t++num_lsu;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t++num_one;\n\t\t\t}\n\t\t}\n\n\t\tif (num_lsu == 0)\n\t\t\t++num_lsu;\n\n\t\tdepth = (host->can_queue - num_one) / num_lsu;\n\n\t\tif (sdev_channel(sdev) != NATIVE_CHANNEL)\n\t\t\tgoto common_config;\n\n\t\tset_qd_dev_type = true;\n\n\t}\n\ncommon_config:\n\n\t \n\tif (set_qd_dev_type) {\n\t\tif (strncmp(sdev->vendor, \"ATA\", 3) == 0)\n\t\t\tdepth = 32;\n\t\telse\n\t\t\tdepth = 64;\n\t}\n\n\t \n\tif (set_timeout) {\n\t\ttimeout = aac->sa_firmware ? AAC_SA_TIMEOUT : AAC_ARC_TIMEOUT;\n\t\tblk_queue_rq_timeout(sdev->request_queue, timeout * HZ);\n\t}\n\n\tif (depth > 256)\n\t\tdepth = 256;\n\telse if (depth < 1)\n\t\tdepth = 1;\n\n\tscsi_change_queue_depth(sdev, depth);\n\n\tsdev->tagged_supported = 1;\n\n\treturn 0;\n}\n\n \n\nstatic int aac_change_queue_depth(struct scsi_device *sdev, int depth)\n{\n\tstruct aac_dev *aac = (struct aac_dev *)(sdev->host->hostdata);\n\tint chn, tid, is_native_device = 0;\n\n\tchn = aac_logical_to_phys(sdev_channel(sdev));\n\ttid = sdev_id(sdev);\n\tif (chn < AAC_MAX_BUSES && tid < AAC_MAX_TARGETS &&\n\t\taac->hba_map[chn][tid].devtype == AAC_DEVTYPE_NATIVE_RAW)\n\t\tis_native_device = 1;\n\n\tif (sdev->tagged_supported && (sdev->type == TYPE_DISK) &&\n\t    (sdev_channel(sdev) == CONTAINER_CHANNEL)) {\n\t\tstruct scsi_device * dev;\n\t\tstruct Scsi_Host *host = sdev->host;\n\t\tunsigned num = 0;\n\n\t\t__shost_for_each_device(dev, host) {\n\t\t\tif (dev->tagged_supported && (dev->type == TYPE_DISK) &&\n\t\t\t    (sdev_channel(dev) == CONTAINER_CHANNEL))\n\t\t\t\t++num;\n\t\t\t++num;\n\t\t}\n\t\tif (num >= host->can_queue)\n\t\t\tnum = host->can_queue - 1;\n\t\tif (depth > (host->can_queue - num))\n\t\t\tdepth = host->can_queue - num;\n\t\tif (depth > 256)\n\t\t\tdepth = 256;\n\t\telse if (depth < 2)\n\t\t\tdepth = 2;\n\t\treturn scsi_change_queue_depth(sdev, depth);\n\t} else if (is_native_device) {\n\t\tscsi_change_queue_depth(sdev, aac->hba_map[chn][tid].qd_limit);\n\t} else {\n\t\tscsi_change_queue_depth(sdev, 1);\n\t}\n\treturn sdev->queue_depth;\n}\n\nstatic ssize_t aac_show_raid_level(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct aac_dev *aac = (struct aac_dev *)(sdev->host->hostdata);\n\tif (sdev_channel(sdev) != CONTAINER_CHANNEL)\n\t\treturn snprintf(buf, PAGE_SIZE, sdev->no_uld_attach\n\t\t  ? \"Hidden\\n\" :\n\t\t  ((aac->jbod && (sdev->type == TYPE_DISK)) ? \"JBOD\\n\" : \"\"));\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t  get_container_type(aac->fsa_dev[sdev_id(sdev)].type));\n}\n\nstatic struct device_attribute aac_raid_level_attr = {\n\t.attr = {\n\t\t.name = \"level\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_raid_level\n};\n\nstatic ssize_t aac_show_unique_id(struct device *dev,\n\t     struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct aac_dev *aac = (struct aac_dev *)(sdev->host->hostdata);\n\tunsigned char sn[16];\n\n\tmemset(sn, 0, sizeof(sn));\n\n\tif (sdev_channel(sdev) == CONTAINER_CHANNEL)\n\t\tmemcpy(sn, aac->fsa_dev[sdev_id(sdev)].identifier, sizeof(sn));\n\n\treturn snprintf(buf, 16 * 2 + 2,\n\t\t\"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\\n\",\n\t\tsn[0], sn[1], sn[2], sn[3],\n\t\tsn[4], sn[5], sn[6], sn[7],\n\t\tsn[8], sn[9], sn[10], sn[11],\n\t\tsn[12], sn[13], sn[14], sn[15]);\n}\n\nstatic struct device_attribute aac_unique_id_attr = {\n\t.attr = {\n\t\t.name = \"unique_id\",\n\t\t.mode = 0444,\n\t},\n\t.show = aac_show_unique_id\n};\n\n\n\nstatic struct attribute *aac_dev_attrs[] = {\n\t&aac_raid_level_attr.attr,\n\t&aac_unique_id_attr.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(aac_dev);\n\nstatic int aac_ioctl(struct scsi_device *sdev, unsigned int cmd,\n\t\t     void __user *arg)\n{\n\tint retval;\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tretval = aac_adapter_check_health(dev);\n\tif (retval)\n\t\treturn -EBUSY;\n\treturn aac_do_ioctl(dev, cmd, arg);\n}\n\nstruct fib_count_data {\n\tint mlcnt;\n\tint llcnt;\n\tint ehcnt;\n\tint fwcnt;\n\tint krlcnt;\n};\n\nstatic bool fib_count_iter(struct scsi_cmnd *scmnd, void *data)\n{\n\tstruct fib_count_data *fib_count = data;\n\n\tswitch (aac_priv(scmnd)->owner) {\n\tcase AAC_OWNER_FIRMWARE:\n\t\tfib_count->fwcnt++;\n\t\tbreak;\n\tcase AAC_OWNER_ERROR_HANDLER:\n\t\tfib_count->ehcnt++;\n\t\tbreak;\n\tcase AAC_OWNER_LOWLEVEL:\n\t\tfib_count->llcnt++;\n\t\tbreak;\n\tcase AAC_OWNER_MIDLEVEL:\n\t\tfib_count->mlcnt++;\n\t\tbreak;\n\tdefault:\n\t\tfib_count->krlcnt++;\n\t\tbreak;\n\t}\n\treturn true;\n}\n\n \nstatic int get_num_of_incomplete_fibs(struct aac_dev *aac)\n{\n\tstruct Scsi_Host *shost = aac->scsi_host_ptr;\n\tstruct device *ctrl_dev;\n\tstruct fib_count_data fcnt = { };\n\n\tscsi_host_busy_iter(shost, fib_count_iter, &fcnt);\n\n\tctrl_dev = &aac->pdev->dev;\n\n\tdev_info(ctrl_dev, \"outstanding cmd: midlevel-%d\\n\", fcnt.mlcnt);\n\tdev_info(ctrl_dev, \"outstanding cmd: lowlevel-%d\\n\", fcnt.llcnt);\n\tdev_info(ctrl_dev, \"outstanding cmd: error handler-%d\\n\", fcnt.ehcnt);\n\tdev_info(ctrl_dev, \"outstanding cmd: firmware-%d\\n\", fcnt.fwcnt);\n\tdev_info(ctrl_dev, \"outstanding cmd: kernel-%d\\n\", fcnt.krlcnt);\n\n\treturn fcnt.mlcnt + fcnt.llcnt + fcnt.ehcnt + fcnt.fwcnt;\n}\n\nstatic int aac_eh_abort(struct scsi_cmnd* cmd)\n{\n\tstruct aac_cmd_priv *cmd_priv = aac_priv(cmd);\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tint count, found;\n\tu32 bus, cid;\n\tint ret = FAILED;\n\n\tif (aac_adapter_check_health(aac))\n\t\treturn ret;\n\n\tbus = aac_logical_to_phys(scmd_channel(cmd));\n\tcid = scmd_id(cmd);\n\tif (aac->hba_map[bus][cid].devtype == AAC_DEVTYPE_NATIVE_RAW) {\n\t\tstruct fib *fib;\n\t\tstruct aac_hba_tm_req *tmf;\n\t\tint status;\n\t\tu64 address;\n\n\t\tpr_err(\"%s: Host adapter abort request (%d,%d,%d,%d)\\n\",\n\t\t AAC_DRIVERNAME,\n\t\t host->host_no, sdev_channel(dev), sdev_id(dev), (int)dev->lun);\n\n\t\tfound = 0;\n\t\tfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\t\tfib = &aac->fibs[count];\n\t\t\tif (*(u8 *)fib->hw_fib_va != 0 &&\n\t\t\t\t(fib->flags & FIB_CONTEXT_FLAG_NATIVE_HBA) &&\n\t\t\t\t(fib->callback_data == cmd)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\treturn ret;\n\n\t\t \n\t\tfib = aac_fib_alloc(aac);\n\t\tif (!fib)\n\t\t\treturn ret;\n\n\t\ttmf = (struct aac_hba_tm_req *)fib->hw_fib_va;\n\t\tmemset(tmf, 0, sizeof(*tmf));\n\t\ttmf->tmf = HBA_TMF_ABORT_TASK;\n\t\ttmf->it_nexus = aac->hba_map[bus][cid].rmw_nexus;\n\t\ttmf->lun[1] = cmd->device->lun;\n\n\t\taddress = (u64)fib->hw_error_pa;\n\t\ttmf->error_ptr_hi = cpu_to_le32((u32)(address >> 32));\n\t\ttmf->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));\n\t\ttmf->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);\n\n\t\tfib->hbacmd_size = sizeof(*tmf);\n\t\tcmd_priv->sent_command = 0;\n\n\t\tstatus = aac_hba_send(HBA_IU_TYPE_SCSI_TM_REQ, fib,\n\t\t\t\t  (fib_callback) aac_hba_callback,\n\t\t\t\t  (void *) cmd);\n\t\tif (status != -EINPROGRESS) {\n\t\t\taac_fib_complete(fib);\n\t\t\taac_fib_free(fib);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tfor (count = 0; count < 15; ++count) {\n\t\t\tif (cmd_priv->sent_command) {\n\t\t\t\tret = SUCCESS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmsleep(1000);\n\t\t}\n\n\t\tif (ret != SUCCESS)\n\t\t\tpr_err(\"%s: Host adapter abort request timed out\\n\",\n\t\t\tAAC_DRIVERNAME);\n\t} else {\n\t\tpr_err(\n\t\t\t\"%s: Host adapter abort request.\\n\"\n\t\t\t\"%s: Outstanding commands on (%d,%d,%d,%d):\\n\",\n\t\t\tAAC_DRIVERNAME, AAC_DRIVERNAME,\n\t\t\thost->host_no, sdev_channel(dev), sdev_id(dev),\n\t\t\t(int)dev->lun);\n\t\tswitch (cmd->cmnd[0]) {\n\t\tcase SERVICE_ACTION_IN_16:\n\t\t\tif (!(aac->raw_io_interface) ||\n\t\t\t    !(aac->raw_io_64) ||\n\t\t\t    ((cmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase INQUIRY:\n\t\tcase READ_CAPACITY:\n\t\t\t \n\t\t\tfor (count = 0;\n\t\t\t\tcount < (host->can_queue + AAC_NUM_MGT_FIB);\n\t\t\t\t++count) {\n\t\t\t\tstruct fib *fib = &aac->fibs[count];\n\n\t\t\t\tif (fib->hw_fib_va->header.XferState &&\n\t\t\t\t(fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t\t\t(fib->callback_data == cmd)) {\n\t\t\t\t\tfib->flags |=\n\t\t\t\t\t\tFIB_CONTEXT_FLAG_TIMED_OUT;\n\t\t\t\t\tcmd_priv->owner =\n\t\t\t\t\t\tAAC_OWNER_ERROR_HANDLER;\n\t\t\t\t\tret = SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEST_UNIT_READY:\n\t\t\t \n\t\t\tfor (count = 0;\n\t\t\t\tcount < (host->can_queue + AAC_NUM_MGT_FIB);\n\t\t\t\t++count) {\n\t\t\t\tstruct scsi_cmnd *command;\n\t\t\t\tstruct fib *fib = &aac->fibs[count];\n\n\t\t\t\tcommand = fib->callback_data;\n\n\t\t\t\tif ((fib->hw_fib_va->header.XferState &\n\t\t\t\t\tcpu_to_le32\n\t\t\t\t\t(Async | NoResponseExpected)) &&\n\t\t\t\t\t(fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t\t\t\t((command)) &&\n\t\t\t\t\t(command->device == cmd->device)) {\n\t\t\t\t\tfib->flags |=\n\t\t\t\t\t\tFIB_CONTEXT_FLAG_TIMED_OUT;\n\t\t\t\t\taac_priv(command)->owner =\n\t\t\t\t\t\tAAC_OWNER_ERROR_HANDLER;\n\t\t\t\t\tif (command == cmd)\n\t\t\t\t\t\tret = SUCCESS;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic u8 aac_eh_tmf_lun_reset_fib(struct aac_hba_map_info *info,\n\t\t\t\t   struct fib *fib, u64 tmf_lun)\n{\n\tstruct aac_hba_tm_req *tmf;\n\tu64 address;\n\n\t \n\ttmf = (struct aac_hba_tm_req *)fib->hw_fib_va;\n\tmemset(tmf, 0, sizeof(*tmf));\n\ttmf->tmf = HBA_TMF_LUN_RESET;\n\ttmf->it_nexus = info->rmw_nexus;\n\tint_to_scsilun(tmf_lun, (struct scsi_lun *)tmf->lun);\n\n\taddress = (u64)fib->hw_error_pa;\n\ttmf->error_ptr_hi = cpu_to_le32\n\t\t((u32)(address >> 32));\n\ttmf->error_ptr_lo = cpu_to_le32\n\t\t((u32)(address & 0xffffffff));\n\ttmf->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);\n\tfib->hbacmd_size = sizeof(*tmf);\n\n\treturn HBA_IU_TYPE_SCSI_TM_REQ;\n}\n\nstatic u8 aac_eh_tmf_hard_reset_fib(struct aac_hba_map_info *info,\n\t\t\t\t    struct fib *fib)\n{\n\tstruct aac_hba_reset_req *rst;\n\tu64 address;\n\n\t \n\trst = (struct aac_hba_reset_req *)fib->hw_fib_va;\n\tmemset(rst, 0, sizeof(*rst));\n\trst->it_nexus = info->rmw_nexus;\n\n\taddress = (u64)fib->hw_error_pa;\n\trst->error_ptr_hi = cpu_to_le32((u32)(address >> 32));\n\trst->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));\n\trst->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);\n\tfib->hbacmd_size = sizeof(*rst);\n\n\treturn HBA_IU_TYPE_SATA_REQ;\n}\n\nstatic void aac_tmf_callback(void *context, struct fib *fibptr)\n{\n\tstruct aac_hba_resp *err =\n\t\t&((struct aac_native_hba *)fibptr->hw_fib_va)->resp.err;\n\tstruct aac_hba_map_info *info = context;\n\tint res;\n\n\tswitch (err->service_response) {\n\tcase HBA_RESP_SVCRES_TMF_REJECTED:\n\t\tres = -1;\n\t\tbreak;\n\tcase HBA_RESP_SVCRES_TMF_LUN_INVALID:\n\t\tres = 0;\n\t\tbreak;\n\tcase HBA_RESP_SVCRES_TMF_COMPLETE:\n\tcase HBA_RESP_SVCRES_TMF_SUCCEEDED:\n\t\tres = 0;\n\t\tbreak;\n\tdefault:\n\t\tres = -2;\n\t\tbreak;\n\t}\n\taac_fib_complete(fibptr);\n\n\tinfo->reset_state = res;\n}\n\n \nstatic int aac_eh_dev_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tstruct aac_hba_map_info *info;\n\tint count;\n\tu32 bus, cid;\n\tstruct fib *fib;\n\tint ret = FAILED;\n\tint status;\n\tu8 command;\n\n\tbus = aac_logical_to_phys(scmd_channel(cmd));\n\tcid = scmd_id(cmd);\n\n\tif (bus >= AAC_MAX_BUSES || cid >= AAC_MAX_TARGETS)\n\t\treturn FAILED;\n\n\tinfo = &aac->hba_map[bus][cid];\n\n\tif (!(info->devtype == AAC_DEVTYPE_NATIVE_RAW &&\n\t !(info->reset_state > 0)))\n\t\treturn FAILED;\n\n\tpr_err(\"%s: Host device reset request. SCSI hang ?\\n\",\n\t       AAC_DRIVERNAME);\n\n\tfib = aac_fib_alloc(aac);\n\tif (!fib)\n\t\treturn ret;\n\n\t \n\tcommand = aac_eh_tmf_lun_reset_fib(info, fib, dev->lun);\n\n\tinfo->reset_state = 1;\n\n\tstatus = aac_hba_send(command, fib,\n\t\t\t      (fib_callback) aac_tmf_callback,\n\t\t\t      (void *) info);\n\tif (status != -EINPROGRESS) {\n\t\tinfo->reset_state = 0;\n\t\taac_fib_complete(fib);\n\t\taac_fib_free(fib);\n\t\treturn ret;\n\t}\n\t \n\tfor (count = 0; count < 15; ++count) {\n\t\tif (info->reset_state == 0) {\n\t\t\tret = info->reset_state == 0 ? SUCCESS : FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(1000);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int aac_eh_target_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tstruct aac_hba_map_info *info;\n\tint count;\n\tu32 bus, cid;\n\tint ret = FAILED;\n\tstruct fib *fib;\n\tint status;\n\tu8 command;\n\n\tbus = aac_logical_to_phys(scmd_channel(cmd));\n\tcid = scmd_id(cmd);\n\n\tif (bus >= AAC_MAX_BUSES || cid >= AAC_MAX_TARGETS)\n\t\treturn FAILED;\n\n\tinfo = &aac->hba_map[bus][cid];\n\n\tif (!(info->devtype == AAC_DEVTYPE_NATIVE_RAW &&\n\t !(info->reset_state > 0)))\n\t\treturn FAILED;\n\n\tpr_err(\"%s: Host target reset request. SCSI hang ?\\n\",\n\t       AAC_DRIVERNAME);\n\n\tfib = aac_fib_alloc(aac);\n\tif (!fib)\n\t\treturn ret;\n\n\n\t \n\tcommand = aac_eh_tmf_hard_reset_fib(info, fib);\n\n\tinfo->reset_state = 2;\n\n\tstatus = aac_hba_send(command, fib,\n\t\t\t      (fib_callback) aac_tmf_callback,\n\t\t\t      (void *) info);\n\n\tif (status != -EINPROGRESS) {\n\t\tinfo->reset_state = 0;\n\t\taac_fib_complete(fib);\n\t\taac_fib_free(fib);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (count = 0; count < 15; ++count) {\n\t\tif (info->reset_state <= 0) {\n\t\t\tret = info->reset_state == 0 ? SUCCESS : FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(1000);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int aac_eh_bus_reset(struct scsi_cmnd* cmd)\n{\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tint count;\n\tu32 cmd_bus;\n\tint status = 0;\n\n\n\tcmd_bus = aac_logical_to_phys(scmd_channel(cmd));\n\t \n\tfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\tstruct fib *fib = &aac->fibs[count];\n\n\t\tif (fib->hw_fib_va->header.XferState &&\n\t\t    (fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t    (fib->flags & FIB_CONTEXT_FLAG_SCSI_CMD)) {\n\t\t\tstruct aac_hba_map_info *info;\n\t\t\tu32 bus, cid;\n\n\t\t\tcmd = (struct scsi_cmnd *)fib->callback_data;\n\t\t\tbus = aac_logical_to_phys(scmd_channel(cmd));\n\t\t\tif (bus != cmd_bus)\n\t\t\t\tcontinue;\n\t\t\tcid = scmd_id(cmd);\n\t\t\tinfo = &aac->hba_map[bus][cid];\n\t\t\tif (bus >= AAC_MAX_BUSES || cid >= AAC_MAX_TARGETS ||\n\t\t\t    info->devtype != AAC_DEVTYPE_NATIVE_RAW) {\n\t\t\t\tfib->flags |= FIB_CONTEXT_FLAG_EH_RESET;\n\t\t\t\taac_priv(cmd)->owner = AAC_OWNER_ERROR_HANDLER;\n\t\t\t}\n\t\t}\n\t}\n\n\tpr_err(\"%s: Host bus reset request. SCSI hang ?\\n\", AAC_DRIVERNAME);\n\n\t \n\tstatus = aac_adapter_check_health(aac);\n\tif (status)\n\t\tdev_err(&aac->pdev->dev, \"Adapter health - %d\\n\", status);\n\n\tcount = get_num_of_incomplete_fibs(aac);\n\treturn (count == 0) ? SUCCESS : FAILED;\n}\n\n \nstatic int aac_eh_host_reset(struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tint ret = FAILED;\n\t__le32 supported_options2 = 0;\n\tbool is_mu_reset;\n\tbool is_ignore_reset;\n\tbool is_doorbell_reset;\n\n\t \n\tsupported_options2 = aac->supplement_adapter_info.supported_options2;\n\tis_mu_reset = supported_options2 & AAC_OPTION_MU_RESET;\n\tis_doorbell_reset = supported_options2 & AAC_OPTION_DOORBELL_RESET;\n\tis_ignore_reset = supported_options2 & AAC_OPTION_IGNORE_RESET;\n\t \n\tif ((is_mu_reset || is_doorbell_reset)\n\t && aac_check_reset\n\t && (aac_check_reset != -1 || !is_ignore_reset)) {\n\t\t \n\t\tif (aac_reset_adapter(aac, 2, IOP_HWSOFT_RESET) == 0)\n\t\t\tret = SUCCESS;\n\t}\n\t \n\tif (ret == SUCCESS) {\n\t\tint bus, cid;\n\t\tstruct aac_hba_map_info *info;\n\n\t\tfor (bus = 0; bus < AAC_MAX_BUSES; bus++) {\n\t\t\tfor (cid = 0; cid < AAC_MAX_TARGETS; cid++) {\n\t\t\t\tinfo = &aac->hba_map[bus][cid];\n\t\t\t\tif (info->devtype == AAC_DEVTYPE_NATIVE_RAW)\n\t\t\t\t\tinfo->reset_state = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n \n\nstatic int aac_cfg_open(struct inode *inode, struct file *file)\n{\n\tstruct aac_dev *aac;\n\tunsigned minor_number = iminor(inode);\n\tint err = -ENODEV;\n\n\tmutex_lock(&aac_mutex);   \n\tlist_for_each_entry(aac, &aac_devices, entry) {\n\t\tif (aac->id == minor_number) {\n\t\t\tfile->private_data = aac;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&aac_mutex);\n\n\treturn err;\n}\n\n \n\nstatic long aac_cfg_ioctl(struct file *file,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct aac_dev *aac = (struct aac_dev *)file->private_data;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\treturn aac_do_ioctl(aac, cmd, (void __user *)arg);\n}\n\nstatic ssize_t aac_show_model(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len;\n\n\tif (dev->supplement_adapter_info.adapter_type_text[0]) {\n\t\tchar *cp = dev->supplement_adapter_info.adapter_type_text;\n\t\twhile (*cp && *cp != ' ')\n\t\t\t++cp;\n\t\twhile (*cp == ' ')\n\t\t\t++cp;\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\", cp);\n\t} else\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t  aac_drivers[dev->cardtype].model);\n\treturn len;\n}\n\nstatic ssize_t aac_show_vendor(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tstruct aac_supplement_adapter_info *sup_adap_info;\n\tint len;\n\n\tsup_adap_info = &dev->supplement_adapter_info;\n\tif (sup_adap_info->adapter_type_text[0]) {\n\t\tchar *cp = sup_adap_info->adapter_type_text;\n\t\twhile (*cp && *cp != ' ')\n\t\t\t++cp;\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%.*s\\n\",\n\t\t\t(int)(cp - (char *)sup_adap_info->adapter_type_text),\n\t\t\t\t\tsup_adap_info->adapter_type_text);\n\t} else\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t\taac_drivers[dev->cardtype].vname);\n\treturn len;\n}\n\nstatic ssize_t aac_show_flags(struct device *cdev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint len = 0;\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(cdev)->hostdata;\n\n\tif (nblank(dprintk(x)))\n\t\tlen = snprintf(buf, PAGE_SIZE, \"dprintk\\n\");\n#ifdef AAC_DETAILED_STATUS_INFO\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t \"AAC_DETAILED_STATUS_INFO\\n\");\n#endif\n\tif (dev->raw_io_interface && dev->raw_io_64)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t \"SAI_READ_CAPACITY_16\\n\");\n\tif (dev->jbod)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t \"SUPPORTED_JBOD\\n\");\n\tif (dev->supplement_adapter_info.supported_options2 &\n\t\tAAC_OPTION_POWER_MANAGEMENT)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t \"SUPPORTED_POWER_MANAGEMENT\\n\");\n\tif (dev->msi)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"PCI_HAS_MSI\\n\");\n\treturn len;\n}\n\nstatic ssize_t aac_show_kernel_version(struct device *device,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.kernelrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.kernelbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_monitor_version(struct device *device,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.monitorrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.monitorbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_bios_version(struct device *device,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.biosrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.biosbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_driver_version(struct device *device,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", aac_driver_version);\n}\n\nstatic ssize_t aac_show_serial_number(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len = 0;\n\n\tif (le32_to_cpu(dev->adapter_info.serial[0]) != 0xBAD0)\n\t\tlen = snprintf(buf, 16, \"%06X\\n\",\n\t\t  le32_to_cpu(dev->adapter_info.serial[0]));\n\tif (len &&\n\t  !memcmp(&dev->supplement_adapter_info.mfg_pcba_serial_no[\n\t    sizeof(dev->supplement_adapter_info.mfg_pcba_serial_no)-len],\n\t  buf, len-1))\n\t\tlen = snprintf(buf, 16, \"%.*s\\n\",\n\t\t  (int)sizeof(dev->supplement_adapter_info.mfg_pcba_serial_no),\n\t\t  dev->supplement_adapter_info.mfg_pcba_serial_no);\n\n\treturn min(len, 16);\n}\n\nstatic ssize_t aac_show_max_channel(struct device *device,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t  class_to_shost(device)->max_channel);\n}\n\nstatic ssize_t aac_show_max_id(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t  class_to_shost(device)->max_id);\n}\n\nstatic ssize_t aac_store_reset_adapter(struct device *device,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tint retval = -EACCES;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn retval;\n\n\tretval = aac_reset_adapter(shost_priv(class_to_shost(device)),\n\t\t\t\t\tbuf[0] == '!', IOP_HWSOFT_RESET);\n\tif (retval >= 0)\n\t\tretval = count;\n\n\treturn retval;\n}\n\nstatic ssize_t aac_show_reset_adapter(struct device *device,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = aac_adapter_check_health(dev);\n\tif ((tmp == 0) && dev->in_reset)\n\t\ttmp = -EBUSY;\n\tlen = snprintf(buf, PAGE_SIZE, \"0x%x\\n\", tmp);\n\treturn len;\n}\n\nstatic struct device_attribute aac_model = {\n\t.attr = {\n\t\t.name = \"model\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_model,\n};\nstatic struct device_attribute aac_vendor = {\n\t.attr = {\n\t\t.name = \"vendor\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_vendor,\n};\nstatic struct device_attribute aac_flags = {\n\t.attr = {\n\t\t.name = \"flags\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_flags,\n};\nstatic struct device_attribute aac_kernel_version = {\n\t.attr = {\n\t\t.name = \"hba_kernel_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_kernel_version,\n};\nstatic struct device_attribute aac_monitor_version = {\n\t.attr = {\n\t\t.name = \"hba_monitor_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_monitor_version,\n};\nstatic struct device_attribute aac_bios_version = {\n\t.attr = {\n\t\t.name = \"hba_bios_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_bios_version,\n};\nstatic struct device_attribute aac_lld_version = {\n\t.attr = {\n\t\t.name = \"driver_version\",\n\t\t.mode = 0444,\n\t},\n\t.show = aac_show_driver_version,\n};\nstatic struct device_attribute aac_serial_number = {\n\t.attr = {\n\t\t.name = \"serial_number\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_serial_number,\n};\nstatic struct device_attribute aac_max_channel = {\n\t.attr = {\n\t\t.name = \"max_channel\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_max_channel,\n};\nstatic struct device_attribute aac_max_id = {\n\t.attr = {\n\t\t.name = \"max_id\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_max_id,\n};\nstatic struct device_attribute aac_reset = {\n\t.attr = {\n\t\t.name = \"reset_host\",\n\t\t.mode = S_IWUSR|S_IRUGO,\n\t},\n\t.store = aac_store_reset_adapter,\n\t.show = aac_show_reset_adapter,\n};\n\nstatic struct attribute *aac_host_attrs[] = {\n\t&aac_model.attr,\n\t&aac_vendor.attr,\n\t&aac_flags.attr,\n\t&aac_kernel_version.attr,\n\t&aac_monitor_version.attr,\n\t&aac_bios_version.attr,\n\t&aac_lld_version.attr,\n\t&aac_serial_number.attr,\n\t&aac_max_channel.attr,\n\t&aac_max_id.attr,\n\t&aac_reset.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(aac_host);\n\nssize_t aac_get_serial_number(struct device *device, char *buf)\n{\n\treturn aac_show_serial_number(device, &aac_serial_number, buf);\n}\n\nstatic const struct file_operations aac_cfg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= aac_cfg_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = aac_cfg_ioctl,\n#endif\n\t.open\t\t= aac_cfg_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic const struct scsi_host_template aac_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"AAC\",\n\t.proc_name\t\t\t= AAC_DRIVERNAME,\n\t.info\t\t\t\t= aac_info,\n\t.ioctl\t\t\t\t= aac_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t\t= aac_ioctl,\n#endif\n\t.queuecommand\t\t\t= aac_queuecommand,\n\t.bios_param\t\t\t= aac_biosparm,\n\t.shost_groups\t\t\t= aac_host_groups,\n\t.slave_configure\t\t= aac_slave_configure,\n\t.change_queue_depth\t\t= aac_change_queue_depth,\n\t.sdev_groups\t\t\t= aac_dev_groups,\n\t.eh_abort_handler\t\t= aac_eh_abort,\n\t.eh_device_reset_handler\t= aac_eh_dev_reset,\n\t.eh_target_reset_handler\t= aac_eh_target_reset,\n\t.eh_bus_reset_handler\t\t= aac_eh_bus_reset,\n\t.eh_host_reset_handler\t\t= aac_eh_host_reset,\n\t.can_queue\t\t\t= AAC_NUM_IO_FIB,\n\t.this_id\t\t\t= MAXIMUM_NUM_CONTAINERS,\n\t.sg_tablesize\t\t\t= 16,\n\t.max_sectors\t\t\t= 128,\n#if (AAC_NUM_IO_FIB > 256)\n\t.cmd_per_lun\t\t\t= 256,\n#else\n\t.cmd_per_lun\t\t\t= AAC_NUM_IO_FIB,\n#endif\n\t.emulated\t\t\t= 1,\n\t.no_write_same\t\t\t= 1,\n\t.cmd_size\t\t\t= sizeof(struct aac_cmd_priv),\n};\n\nstatic void __aac_shutdown(struct aac_dev * aac)\n{\n\tint i;\n\n\tmutex_lock(&aac->ioctl_mutex);\n\taac->adapter_shutdown = 1;\n\tmutex_unlock(&aac->ioctl_mutex);\n\n\tif (aac->aif_thread) {\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < (aac->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB); i++) {\n\t\t\tstruct fib *fib = &aac->fibs[i];\n\t\t\tif (!(fib->hw_fib_va->header.XferState & cpu_to_le32(NoResponseExpected | Async)) &&\n\t\t\t    (fib->hw_fib_va->header.XferState & cpu_to_le32(ResponseExpected)))\n\t\t\t\tcomplete(&fib->event_wait);\n\t\t}\n\t\tkthread_stop(aac->thread);\n\t\taac->thread = NULL;\n\t}\n\n\taac_send_shutdown(aac);\n\n\taac_adapter_disable_int(aac);\n\n\tif (aac_is_src(aac)) {\n\t\tif (aac->max_msix > 1) {\n\t\t\tfor (i = 0; i < aac->max_msix; i++) {\n\t\t\t\tfree_irq(pci_irq_vector(aac->pdev, i),\n\t\t\t\t\t &(aac->aac_msix[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tfree_irq(aac->pdev->irq,\n\t\t\t\t &(aac->aac_msix[0]));\n\t\t}\n\t} else {\n\t\tfree_irq(aac->pdev->irq, aac);\n\t}\n\tif (aac->msi)\n\t\tpci_disable_msi(aac->pdev);\n\telse if (aac->max_msix > 1)\n\t\tpci_disable_msix(aac->pdev);\n}\nstatic void aac_init_char(void)\n{\n\taac_cfg_major = register_chrdev(0, \"aac\", &aac_cfg_fops);\n\tif (aac_cfg_major < 0) {\n\t\tpr_err(\"aacraid: unable to register \\\"aac\\\" device.\\n\");\n\t}\n}\n\nvoid aac_reinit_aif(struct aac_dev *aac, unsigned int index)\n{\n\t \n\tif (aac_drivers[index].quirks & AAC_QUIRK_SRC)\n\t\taac_intr_normal(aac, 0, 2, 0, NULL);\n\n}\n\nstatic int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tunsigned index = id->driver_data;\n\tstruct Scsi_Host *shost;\n\tstruct aac_dev *aac;\n\tstruct list_head *insert = &aac_devices;\n\tint error;\n\tint unique_id = 0;\n\tu64 dmamask;\n\tint mask_bits = 0;\n\textern int aac_sync_mode;\n\n\t \n\tif (pdev->device == PMC_DEVICE_S7)\n\t\tpdev->needs_freset = 1;\n\n\tlist_for_each_entry(aac, &aac_devices, entry) {\n\t\tif (aac->id > unique_id)\n\t\t\tbreak;\n\t\tinsert = &aac->entry;\n\t\tunique_id++;\n\t}\n\n\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\n\t\t\t       PCIE_LINK_STATE_CLKPM);\n\n\terror = pci_enable_device(pdev);\n\tif (error)\n\t\tgoto out;\n\n\tif (!(aac_drivers[index].quirks & AAC_QUIRK_SRC)) {\n\t\terror = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (error) {\n\t\t\tdev_err(&pdev->dev, \"PCI 32 BIT dma mask set failed\");\n\t\t\tgoto out_disable_pdev;\n\t\t}\n\t}\n\n\t \n\tif (aac_drivers[index].quirks & AAC_QUIRK_31BIT) {\n\t\tdmamask = DMA_BIT_MASK(31);\n\t\tmask_bits = 31;\n\t} else {\n\t\tdmamask = DMA_BIT_MASK(32);\n\t\tmask_bits = 32;\n\t}\n\n\terror = dma_set_coherent_mask(&pdev->dev, dmamask);\n\tif (error) {\n\t\tdev_err(&pdev->dev, \"PCI %d B consistent dma mask set failed\\n\"\n\t\t\t\t, mask_bits);\n\t\tgoto out_disable_pdev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tshost = scsi_host_alloc(&aac_driver_template, sizeof(struct aac_dev));\n\tif (!shost) {\n\t\terror = -ENOMEM;\n\t\tgoto out_disable_pdev;\n\t}\n\n\tshost->irq = pdev->irq;\n\tshost->unique_id = unique_id;\n\tshost->max_cmd_len = 16;\n\n\tif (aac_cfg_major == AAC_CHARDEV_NEEDS_REINIT)\n\t\taac_init_char();\n\n\taac = (struct aac_dev *)shost->hostdata;\n\taac->base_start = pci_resource_start(pdev, 0);\n\taac->scsi_host_ptr = shost;\n\taac->pdev = pdev;\n\taac->name = aac_driver_template.name;\n\taac->id = shost->unique_id;\n\taac->cardtype = index;\n\tINIT_LIST_HEAD(&aac->entry);\n\n\tif (aac_reset_devices || reset_devices)\n\t\taac->init_reset = true;\n\n\taac->fibs = kcalloc(shost->can_queue + AAC_NUM_MGT_FIB,\n\t\t\t    sizeof(struct fib),\n\t\t\t    GFP_KERNEL);\n\tif (!aac->fibs) {\n\t\terror = -ENOMEM;\n\t\tgoto out_free_host;\n\t}\n\n\tspin_lock_init(&aac->fib_lock);\n\n\tmutex_init(&aac->ioctl_mutex);\n\tmutex_init(&aac->scan_mutex);\n\n\tINIT_DELAYED_WORK(&aac->safw_rescan_work, aac_safw_rescan_worker);\n\tINIT_DELAYED_WORK(&aac->src_reinit_aif_worker,\n\t\t\t\taac_src_reinit_aif_worker);\n\t \n\taac->base_size = AAC_MIN_FOOTPRINT_SIZE;\n\tif ((*aac_drivers[index].init)(aac)) {\n\t\terror = -ENODEV;\n\t\tgoto out_unmap;\n\t}\n\n\tif (aac->sync_mode) {\n\t\tif (aac_sync_mode)\n\t\t\tprintk(KERN_INFO \"%s%d: Sync. mode enforced \"\n\t\t\t\t\"by driver parameter. This will cause \"\n\t\t\t\t\"a significant performance decrease!\\n\",\n\t\t\t\taac->name,\n\t\t\t\taac->id);\n\t\telse\n\t\t\tprintk(KERN_INFO \"%s%d: Async. mode not supported \"\n\t\t\t\t\"by current driver, sync. mode enforced.\"\n\t\t\t\t\"\\nPlease update driver to get full performance.\\n\",\n\t\t\t\taac->name,\n\t\t\t\taac->id);\n\t}\n\n\t \n\taac->thread = kthread_run(aac_command_thread, aac, AAC_DRIVERNAME);\n\tif (IS_ERR(aac->thread)) {\n\t\tprintk(KERN_ERR \"aacraid: Unable to create command thread.\\n\");\n\t\terror = PTR_ERR(aac->thread);\n\t\taac->thread = NULL;\n\t\tgoto out_deinit;\n\t}\n\n\taac->maximum_num_channels = aac_drivers[index].channels;\n\terror = aac_get_adapter_info(aac);\n\tif (error < 0)\n\t\tgoto out_deinit;\n\n\t \n\tif ((aac_drivers[index].quirks & AAC_QUIRK_34SG) &&\n\t\t\t(shost->sg_tablesize > 34)) {\n\t\tshost->sg_tablesize = 34;\n\t\tshost->max_sectors = (shost->sg_tablesize * 8) + 112;\n\t}\n\n\tif ((aac_drivers[index].quirks & AAC_QUIRK_17SG) &&\n\t\t\t(shost->sg_tablesize > 17)) {\n\t\tshost->sg_tablesize = 17;\n\t\tshost->max_sectors = (shost->sg_tablesize * 8) + 112;\n\t}\n\n\tif (aac->adapter_info.options & AAC_OPT_NEW_COMM)\n\t\tshost->max_segment_size = shost->max_sectors << 9;\n\telse\n\t\tshost->max_segment_size = 65536;\n\n\t \n\tif (aac_drivers[index].quirks & AAC_QUIRK_34SG)\n\t\taac->printf_enabled = 1;\n\telse\n\t\taac->printf_enabled = 0;\n\n\t \n\tif (aac->nondasd_support || expose_physicals || aac->jbod)\n\t\tshost->max_channel = aac->maximum_num_channels;\n\telse\n\t\tshost->max_channel = 0;\n\n\taac_get_config_status(aac, 0);\n\taac_get_containers(aac);\n\tlist_add(&aac->entry, insert);\n\n\tshost->max_id = aac->maximum_num_containers;\n\tif (shost->max_id < aac->maximum_num_physicals)\n\t\tshost->max_id = aac->maximum_num_physicals;\n\tif (shost->max_id < MAXIMUM_NUM_CONTAINERS)\n\t\tshost->max_id = MAXIMUM_NUM_CONTAINERS;\n\telse\n\t\tshost->this_id = shost->max_id;\n\n\tif (!aac->sa_firmware && aac_drivers[index].quirks & AAC_QUIRK_SRC)\n\t\taac_intr_normal(aac, 0, 2, 0, NULL);\n\n\t \n\tshost->max_lun = AAC_MAX_LUN;\n\n\tpci_set_drvdata(pdev, shost);\n\n\terror = scsi_add_host(shost, &pdev->dev);\n\tif (error)\n\t\tgoto out_deinit;\n\n\taac_scan_host(aac);\n\n\tpci_save_state(pdev);\n\n\treturn 0;\n\n out_deinit:\n\t__aac_shutdown(aac);\n out_unmap:\n\taac_fib_map_free(aac);\n\tif (aac->comm_addr)\n\t\tdma_free_coherent(&aac->pdev->dev, aac->comm_size,\n\t\t\t\t  aac->comm_addr, aac->comm_phys);\n\tkfree(aac->queues);\n\taac_adapter_ioremap(aac, 0);\n\tkfree(aac->fibs);\n\tkfree(aac->fsa_dev);\n out_free_host:\n\tscsi_host_put(shost);\n out_disable_pdev:\n\tpci_disable_device(pdev);\n out:\n\treturn error;\n}\n\nstatic void aac_release_resources(struct aac_dev *aac)\n{\n\taac_adapter_disable_int(aac);\n\taac_free_irq(aac);\n}\n\nstatic int aac_acquire_resources(struct aac_dev *dev)\n{\n\tunsigned long status;\n\t \n\twhile (!((status = src_readl(dev, MUnit.OMR)) & KERNEL_UP_AND_RUNNING)\n\t\t|| status == 0xffffffff)\n\t\t\tmsleep(20);\n\n\taac_adapter_disable_int(dev);\n\taac_adapter_enable_int(dev);\n\n\n\tif (aac_is_src(dev))\n\t\taac_define_int_mode(dev);\n\n\tif (dev->msi_enabled)\n\t\taac_src_access_devreg(dev, AAC_ENABLE_MSIX);\n\n\tif (aac_acquire_irq(dev))\n\t\tgoto error_iounmap;\n\n\taac_adapter_enable_int(dev);\n\n\t \n\taac_fib_vector_assign(dev);\n\n\tif (!dev->sync_mode) {\n\t\t \n\t\tdev->init->r7.no_of_msix_vectors = cpu_to_le32(dev->max_msix);\n\t\taac_adapter_start(dev);\n\t}\n\treturn 0;\n\nerror_iounmap:\n\treturn -1;\n\n}\n\nstatic int __maybe_unused aac_suspend(struct device *dev)\n{\n\tstruct Scsi_Host *shost = dev_get_drvdata(dev);\n\tstruct aac_dev *aac = (struct aac_dev *)shost->hostdata;\n\n\tscsi_host_block(shost);\n\taac_cancel_rescan_worker(aac);\n\taac_send_shutdown(aac);\n\n\taac_release_resources(aac);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused aac_resume(struct device *dev)\n{\n\tstruct Scsi_Host *shost = dev_get_drvdata(dev);\n\tstruct aac_dev *aac = (struct aac_dev *)shost->hostdata;\n\n\tif (aac_acquire_resources(aac))\n\t\tgoto fail_device;\n\t \n\taac->adapter_shutdown = 0;\n\tscsi_host_unblock(shost, SDEV_RUNNING);\n\n\treturn 0;\n\nfail_device:\n\tprintk(KERN_INFO \"%s%d: resume failed.\\n\", aac->name, aac->id);\n\tscsi_host_put(shost);\n\treturn -ENODEV;\n}\n\nstatic void aac_shutdown(struct pci_dev *dev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(dev);\n\n\tscsi_host_block(shost);\n\t__aac_shutdown((struct aac_dev *)shost->hostdata);\n}\n\nstatic void aac_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct aac_dev *aac = (struct aac_dev *)shost->hostdata;\n\n\taac_cancel_rescan_worker(aac);\n\tscsi_remove_host(shost);\n\n\t__aac_shutdown(aac);\n\taac_fib_map_free(aac);\n\tdma_free_coherent(&aac->pdev->dev, aac->comm_size, aac->comm_addr,\n\t\t\t  aac->comm_phys);\n\tkfree(aac->queues);\n\n\taac_adapter_ioremap(aac, 0);\n\n\tkfree(aac->fibs);\n\tkfree(aac->fsa_dev);\n\n\tlist_del(&aac->entry);\n\tscsi_host_put(shost);\n\tpci_disable_device(pdev);\n\tif (list_empty(&aac_devices)) {\n\t\tunregister_chrdev(aac_cfg_major, \"aac\");\n\t\taac_cfg_major = AAC_CHARDEV_NEEDS_REINIT;\n\t}\n}\n\nstatic pci_ers_result_t aac_pci_error_detected(struct pci_dev *pdev,\n\t\t\t\t\tpci_channel_state_t error)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct aac_dev *aac = shost_priv(shost);\n\n\tdev_err(&pdev->dev, \"aacraid: PCI error detected %x\\n\", error);\n\n\tswitch (error) {\n\tcase pci_channel_io_normal:\n\t\treturn PCI_ERS_RESULT_CAN_RECOVER;\n\tcase pci_channel_io_frozen:\n\t\taac->handle_pci_error = 1;\n\n\t\tscsi_host_block(shost);\n\t\taac_cancel_rescan_worker(aac);\n\t\tscsi_host_complete_all_commands(shost, DID_NO_CONNECT);\n\t\taac_release_resources(aac);\n\n\t\taac_adapter_ioremap(aac, 0);\n\n\t\treturn PCI_ERS_RESULT_NEED_RESET;\n\tcase pci_channel_io_perm_failure:\n\t\taac->handle_pci_error = 1;\n\n\t\tscsi_host_complete_all_commands(shost, DID_NO_CONNECT);\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t aac_pci_mmio_enabled(struct pci_dev *pdev)\n{\n\tdev_err(&pdev->dev, \"aacraid: PCI error - mmio enabled\\n\");\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\nstatic pci_ers_result_t aac_pci_slot_reset(struct pci_dev *pdev)\n{\n\tdev_err(&pdev->dev, \"aacraid: PCI error - slot reset\\n\");\n\tpci_restore_state(pdev);\n\tif (pci_enable_device(pdev)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t\"aacraid: failed to enable slave\\n\");\n\t\tgoto fail_device;\n\t}\n\n\tpci_set_master(pdev);\n\n\tif (pci_enable_device_mem(pdev)) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device_mem failed\\n\");\n\t\tgoto fail_device;\n\t}\n\n\treturn PCI_ERS_RESULT_RECOVERED;\n\nfail_device:\n\tdev_err(&pdev->dev, \"aacraid: PCI error - slot reset failed\\n\");\n\treturn PCI_ERS_RESULT_DISCONNECT;\n}\n\n\nstatic void aac_pci_resume(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct aac_dev *aac = (struct aac_dev *)shost_priv(shost);\n\n\tif (aac_adapter_ioremap(aac, aac->base_size)) {\n\n\t\tdev_err(&pdev->dev, \"aacraid: ioremap failed\\n\");\n\t\t \n\t\taac->comm_interface = AAC_COMM_PRODUCER;\n\t\tif (aac_adapter_ioremap(aac, AAC_MIN_FOOTPRINT_SIZE)) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\"aacraid: unable to map adapter.\\n\");\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmsleep(10000);\n\n\taac_acquire_resources(aac);\n\n\t \n\taac->adapter_shutdown = 0;\n\taac->handle_pci_error = 0;\n\n\tscsi_host_unblock(shost, SDEV_RUNNING);\n\taac_scan_host(aac);\n\tpci_save_state(pdev);\n\n\tdev_err(&pdev->dev, \"aacraid: PCI error - resume\\n\");\n}\n\nstatic struct pci_error_handlers aac_pci_err_handler = {\n\t.error_detected\t\t= aac_pci_error_detected,\n\t.mmio_enabled\t\t= aac_pci_mmio_enabled,\n\t.slot_reset\t\t= aac_pci_slot_reset,\n\t.resume\t\t\t= aac_pci_resume,\n};\n\nstatic SIMPLE_DEV_PM_OPS(aac_pm_ops, aac_suspend, aac_resume);\n\nstatic struct pci_driver aac_pci_driver = {\n\t.name\t\t= AAC_DRIVERNAME,\n\t.id_table\t= aac_pci_tbl,\n\t.probe\t\t= aac_probe_one,\n\t.remove\t\t= aac_remove_one,\n\t.driver.pm      = &aac_pm_ops,\n\t.shutdown\t= aac_shutdown,\n\t.err_handler    = &aac_pci_err_handler,\n};\n\nstatic int __init aac_init(void)\n{\n\tint error;\n\n\tprintk(KERN_INFO \"Adaptec %s driver %s\\n\",\n\t  AAC_DRIVERNAME, aac_driver_version);\n\n\terror = pci_register_driver(&aac_pci_driver);\n\tif (error < 0)\n\t\treturn error;\n\n\taac_init_char();\n\n\n\treturn 0;\n}\n\nstatic void __exit aac_exit(void)\n{\n\tif (aac_cfg_major > -1)\n\t\tunregister_chrdev(aac_cfg_major, \"aac\");\n\tpci_unregister_driver(&aac_pci_driver);\n}\n\nmodule_init(aac_init);\nmodule_exit(aac_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}