{
  "module_name": "aacraid.h",
  "hash_id": "0f5cf1b493eb3c358e27ddd247e2994312d7362d611f6f67e03c18cdc4430b35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/aacraid.h",
  "human_readable_source": " \n \n\n#ifndef _AACRAID_H_\n#define _AACRAID_H_\n#ifndef dprintk\n# define dprintk(x)\n#endif\n \n#define _nblank(x) #x\n#define nblank(x) _nblank(x)[0]\n\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/pci.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_cmnd.h>\n\n \n\n#define AAC_MAX_MSIX\t\t32\t \n#define AAC_PCI_MSI_ENABLE\t0x8000\n\nenum {\n\tAAC_ENABLE_INTERRUPT\t= 0x0,\n\tAAC_DISABLE_INTERRUPT,\n\tAAC_ENABLE_MSIX,\n\tAAC_DISABLE_MSIX,\n\tAAC_CLEAR_AIF_BIT,\n\tAAC_CLEAR_SYNC_BIT,\n\tAAC_ENABLE_INTX\n};\n\n#define AAC_INT_MODE_INTX\t\t(1<<0)\n#define AAC_INT_MODE_MSI\t\t(1<<1)\n#define AAC_INT_MODE_AIF\t\t(1<<2)\n#define AAC_INT_MODE_SYNC\t\t(1<<3)\n#define AAC_INT_MODE_MSIX\t\t(1<<16)\n\n#define AAC_INT_ENABLE_TYPE1_INTX\t0xfffffffb\n#define AAC_INT_ENABLE_TYPE1_MSIX\t0xfffffffa\n#define AAC_INT_DISABLE_ALL\t\t0xffffffff\n\n \n#define PMC_TRANSITION_TO_OPERATIONAL\t(1<<31)\n#define PMC_IOARCB_TRANSFER_FAILED\t(1<<28)\n#define PMC_IOA_UNIT_CHECK\t\t(1<<27)\n#define PMC_NO_HOST_RRQ_FOR_CMD_RESPONSE (1<<26)\n#define PMC_CRITICAL_IOA_OP_IN_PROGRESS\t(1<<25)\n#define PMC_IOARRIN_LOST\t\t(1<<4)\n#define PMC_SYSTEM_BUS_MMIO_ERROR\t(1<<3)\n#define PMC_IOA_PROCESSOR_IN_ERROR_STATE (1<<2)\n#define PMC_HOST_RRQ_VALID\t\t(1<<1)\n#define PMC_OPERATIONAL_STATUS\t\t(1<<31)\n#define PMC_ALLOW_MSIX_VECTOR0\t\t(1<<0)\n\n#define PMC_IOA_ERROR_INTERRUPTS\t(PMC_IOARCB_TRANSFER_FAILED | \\\n\t\t\t\t\t PMC_IOA_UNIT_CHECK | \\\n\t\t\t\t\t PMC_NO_HOST_RRQ_FOR_CMD_RESPONSE | \\\n\t\t\t\t\t PMC_IOARRIN_LOST | \\\n\t\t\t\t\t PMC_SYSTEM_BUS_MMIO_ERROR | \\\n\t\t\t\t\t PMC_IOA_PROCESSOR_IN_ERROR_STATE)\n\n#define PMC_ALL_INTERRUPT_BITS\t\t(PMC_IOA_ERROR_INTERRUPTS | \\\n\t\t\t\t\t PMC_HOST_RRQ_VALID | \\\n\t\t\t\t\t PMC_TRANSITION_TO_OPERATIONAL | \\\n\t\t\t\t\t PMC_ALLOW_MSIX_VECTOR0)\n#define\tPMC_GLOBAL_INT_BIT2\t\t0x00000004\n#define\tPMC_GLOBAL_INT_BIT0\t\t0x00000001\n\n#ifndef AAC_DRIVER_BUILD\n# define AAC_DRIVER_BUILD 50983\n# define AAC_DRIVER_BRANCH \"-custom\"\n#endif\n#define MAXIMUM_NUM_CONTAINERS\t32\n\n#define AAC_NUM_MGT_FIB         8\n#define AAC_NUM_IO_FIB\t\t(1024 - AAC_NUM_MGT_FIB)\n#define AAC_NUM_FIB\t\t(AAC_NUM_IO_FIB + AAC_NUM_MGT_FIB)\n\n#define AAC_MAX_LUN\t\t256\n\n#define AAC_MAX_HOSTPHYSMEMPAGES (0xfffff)\n#define AAC_MAX_32BIT_SGBCOUNT\t((unsigned short)256)\n\n#define AAC_DEBUG_INSTRUMENT_AIF_DELETE\n\n#define AAC_MAX_NATIVE_TARGETS\t\t1024\n \n#define AAC_MAX_BUSES\t\t\t5\n#define AAC_MAX_TARGETS\t\t256\n#define AAC_BUS_TARGET_LOOP\t\t(AAC_MAX_BUSES * AAC_MAX_TARGETS)\n#define AAC_MAX_NATIVE_SIZE\t\t2048\n#define FW_ERROR_BUFFER_SIZE\t\t512\n#define AAC_SA_TIMEOUT\t\t\t180\n#define AAC_ARC_TIMEOUT\t\t\t60\n\n#define get_bus_number(x)\t(x/AAC_MAX_TARGETS)\n#define get_target_number(x)\t(x%AAC_MAX_TARGETS)\n\n \n#define SA_AIF_HOTPLUG\t\t\t(1<<1)\n#define SA_AIF_HARDWARE\t\t(1<<2)\n#define SA_AIF_PDEV_CHANGE\t\t(1<<4)\n#define SA_AIF_LDEV_CHANGE\t\t(1<<5)\n#define SA_AIF_BPSTAT_CHANGE\t\t(1<<30)\n#define SA_AIF_BPCFG_CHANGE\t\t(1U<<31)\n\n#define HBA_MAX_SG_EMBEDDED\t\t28\n#define HBA_MAX_SG_SEPARATE\t\t90\n#define HBA_SENSE_DATA_LEN_MAX\t\t32\n#define HBA_REQUEST_TAG_ERROR_FLAG\t0x00000002\n#define HBA_SGL_FLAGS_EXT\t\t0x80000000UL\n\nstruct aac_hba_sgl {\n\tu32\t\taddr_lo;  \n\tu32\t\taddr_hi;  \n\tu32\t\tlen;\t \n\tu32\t\tflags;\t \n};\n\nenum {\n\tHBA_IU_TYPE_SCSI_CMD_REQ\t\t= 0x40,\n\tHBA_IU_TYPE_SCSI_TM_REQ\t\t\t= 0x41,\n\tHBA_IU_TYPE_SATA_REQ\t\t\t= 0x42,\n\tHBA_IU_TYPE_RESP\t\t\t= 0x60,\n\tHBA_IU_TYPE_COALESCED_RESP\t\t= 0x61,\n\tHBA_IU_TYPE_INT_COALESCING_CFG_REQ\t= 0x70\n};\n\nenum {\n\tHBA_CMD_BYTE1_DATA_DIR_IN\t\t= 0x1,\n\tHBA_CMD_BYTE1_DATA_DIR_OUT\t\t= 0x2,\n\tHBA_CMD_BYTE1_DATA_TYPE_DDR\t\t= 0x4,\n\tHBA_CMD_BYTE1_CRYPTO_ENABLE\t\t= 0x8\n};\n\nenum {\n\tHBA_CMD_BYTE1_BITOFF_DATA_DIR_IN\t= 0x0,\n\tHBA_CMD_BYTE1_BITOFF_DATA_DIR_OUT,\n\tHBA_CMD_BYTE1_BITOFF_DATA_TYPE_DDR,\n\tHBA_CMD_BYTE1_BITOFF_CRYPTO_ENABLE\n};\n\nenum {\n\tHBA_RESP_DATAPRES_NO_DATA\t\t= 0x0,\n\tHBA_RESP_DATAPRES_RESPONSE_DATA,\n\tHBA_RESP_DATAPRES_SENSE_DATA\n};\n\nenum {\n\tHBA_RESP_SVCRES_TASK_COMPLETE\t\t= 0x0,\n\tHBA_RESP_SVCRES_FAILURE,\n\tHBA_RESP_SVCRES_TMF_COMPLETE,\n\tHBA_RESP_SVCRES_TMF_SUCCEEDED,\n\tHBA_RESP_SVCRES_TMF_REJECTED,\n\tHBA_RESP_SVCRES_TMF_LUN_INVALID\n};\n\nenum {\n\tHBA_RESP_STAT_IO_ERROR\t\t\t= 0x1,\n\tHBA_RESP_STAT_IO_ABORTED,\n\tHBA_RESP_STAT_NO_PATH_TO_DEVICE,\n\tHBA_RESP_STAT_INVALID_DEVICE,\n\tHBA_RESP_STAT_HBAMODE_DISABLED\t\t= 0xE,\n\tHBA_RESP_STAT_UNDERRUN\t\t\t= 0x51,\n\tHBA_RESP_STAT_OVERRUN\t\t\t= 0x75\n};\n\nstruct aac_hba_cmd_req {\n\tu8\tiu_type;\t \n\t \n\tu8\tbyte1;\n\tu8\treply_qid;\t \n\tu8\treserved1;\n\t__le32\tit_nexus;\t \n\t__le32\trequest_id;\t \n\t \n\t__le32\ttweak_value_lo;\n\tu8\tcdb[16];\t \n\tu8\tlun[8];\t\t \n\n\t \n\t__le32\tdata_length;\n\n\t \n\tu8\tattr_prio;\n\n\t \n\tu8\temb_data_desc_count;\n\n\t__le16\tdek_index;\t \n\n\t \n\t__le32\terror_ptr_lo;\n\n\t \n\t__le32\terror_ptr_hi;\n\n\t \n\t__le32\terror_length;\n\n\t \n\t__le32\ttweak_value_hi;\n\n\tstruct aac_hba_sgl sge[HBA_MAX_SG_SEPARATE+2];  \n\n\t \n};\n\n \n#define HBA_TMF_ABORT_TASK\t0x01\n#define HBA_TMF_LUN_RESET\t0x08\n\nstruct aac_hba_tm_req {\n\tu8\tiu_type;\t \n\tu8\treply_qid;\t \n\tu8\ttmf;\t\t \n\tu8\treserved1;\n\n\t__le32\tit_nexus;\t \n\n\tu8\tlun[8];\t\t \n\n\t \n\t__le32\trequest_id;\t \n\t__le32\treserved2;\n\n\t \n\t__le32\tmanaged_request_id;\t \n\t__le32\treserved3;\n\n\t \n\t__le32\terror_ptr_lo;\n\t \n\t__le32\terror_ptr_hi;\n\t \n\t__le32\terror_length;\n};\n\nstruct aac_hba_reset_req {\n\tu8\tiu_type;\t \n\t \n\tu8\treset_type;\n\tu8\treply_qid;\t \n\tu8\treserved1;\n\n\t__le32\tit_nexus;\t \n\t__le32\trequest_id;\t \n\t \n\t__le32\terror_ptr_lo;\n\t \n\t__le32\terror_ptr_hi;\n\t \n\t__le32\terror_length;\n};\n\nstruct aac_hba_resp {\n\tu8\tiu_type;\t\t \n\tu8\treserved1[3];\n\t__le32\trequest_identifier;\t \n\t__le32\treserved2;\n\tu8\tservice_response;\t \n\tu8\tstatus;\t\t\t \n\tu8\tdatapres;\t \n\tu8\tsense_response_data_len;\t \n\t__le32\tresidual_count;\t\t \n\t \n\tu8\tsense_response_buf[HBA_SENSE_DATA_LEN_MAX];\n};\n\nstruct aac_native_hba {\n\tunion {\n\t\tstruct aac_hba_cmd_req cmd;\n\t\tstruct aac_hba_tm_req tmr;\n\t\tu8 cmd_bytes[AAC_MAX_NATIVE_SIZE-FW_ERROR_BUFFER_SIZE];\n\t} cmd;\n\tunion {\n\t\tstruct aac_hba_resp err;\n\t\tu8 resp_bytes[FW_ERROR_BUFFER_SIZE];\n\t} resp;\n};\n\n#define CISS_REPORT_PHYSICAL_LUNS\t0xc3\n#define WRITE_HOST_WELLNESS\t\t0xa5\n#define CISS_IDENTIFY_PHYSICAL_DEVICE\t0x15\n#define BMIC_IN\t\t\t0x26\n#define BMIC_OUT\t\t\t0x27\n\nstruct aac_ciss_phys_luns_resp {\n\tu8\tlist_length[4];\t\t \n\tu8\tresp_flag;\t\t \n\tu8\treserved[3];\n\tstruct _ciss_lun {\n\t\tu8\ttid[3];\t\t \n\t\tu8\tbus;\t\t \n\t\tu8\tlevel3[2];\n\t\tu8\tlevel2[2];\n\t\tu8\tnode_ident[16];\t \n\t} lun[1];\t\t\t \n};\n\n \n#define AAC_MAX_HRRQ\t\t64\n\nstruct aac_ciss_identify_pd {\n\tu8 scsi_bus;\t\t\t \n\tu8 scsi_id;\t\t\t \n\tu16 block_size;\t\t\t \n\tu32 total_blocks;\t\t \n\tu32 reserved_blocks;\t\t \n\tu8 model[40];\t\t\t \n\tu8 serial_number[40];\t\t \n\tu8 firmware_revision[8];\t \n\tu8 scsi_inquiry_bits;\t\t \n\tu8 compaq_drive_stamp;\t\t \n\tu8 last_failure_reason;\n\n\tu8  flags;\n\tu8  more_flags;\n\tu8  scsi_lun;\t\t\t \n\tu8  yet_more_flags;\n\tu8  even_more_flags;\n\tu32 spi_speed_rules;\t\t \n\tu8  phys_connector[2];\t\t \n\tu8  phys_box_on_bus;\t\t \n\tu8  phys_bay_in_box;\t\t \n\tu32 rpm;\t\t\t \n\tu8  device_type;\t\t \n\tu8  sata_version;\t\t \n\tu64 big_total_block_count;\n\tu64 ris_starting_lba;\n\tu32 ris_size;\n\tu8  wwid[20];\n\tu8  controller_phy_map[32];\n\tu16 phy_count;\n\tu8  phy_connected_dev_type[256];\n\tu8  phy_to_drive_bay_num[256];\n\tu16 phy_to_attached_dev_index[256];\n\tu8  box_index;\n\tu8  spitfire_support;\n\tu16 extra_physical_drive_flags;\n\tu8  negotiated_link_rate[256];\n\tu8  phy_to_phy_map[256];\n\tu8  redundant_path_present_map;\n\tu8  redundant_path_failure_map;\n\tu8  active_path_number;\n\tu16 alternate_paths_phys_connector[8];\n\tu8  alternate_paths_phys_box_on_port[8];\n\tu8  multi_lun_device_lun_count;\n\tu8  minimum_good_fw_revision[8];\n\tu8  unique_inquiry_bytes[20];\n\tu8  current_temperature_degreesC;\n\tu8  temperature_threshold_degreesC;\n\tu8  max_temperature_degreesC;\n\tu8  logical_blocks_per_phys_block_exp;\t \n\tu16 current_queue_depth_limit;\n\tu8  switch_name[10];\n\tu16 switch_port;\n\tu8  alternate_paths_switch_name[40];\n\tu8  alternate_paths_switch_port[8];\n\tu16 power_on_hours;\t\t \n\tu16 percent_endurance_used;\t \n\tu8  drive_authentication;\n\tu8  smart_carrier_authentication;\n\tu8  smart_carrier_app_fw_version;\n\tu8  smart_carrier_bootloader_fw_version;\n\tu8  SanitizeSecureEraseSupport;\n\tu8  DriveKeyFlags;\n\tu8  encryption_key_name[64];\n\tu32 misc_drive_flags;\n\tu16 dek_index;\n\tu16 drive_encryption_flags;\n\tu8  sanitize_maximum_time[6];\n\tu8  connector_info_mode;\n\tu8  connector_info_number[4];\n\tu8  long_connector_name[64];\n\tu8  device_unique_identifier[16];\n\tu8  padto_2K[17];\n} __packed;\n\n \n#define CONTAINER_CHANNEL\t\t(0)\n#define NATIVE_CHANNEL\t\t\t(1)\n#define CONTAINER_TO_CHANNEL(cont)\t(CONTAINER_CHANNEL)\n#define CONTAINER_TO_ID(cont)\t\t(cont)\n#define CONTAINER_TO_LUN(cont)\t\t(0)\n#define ENCLOSURE_CHANNEL\t\t(3)\n\n#define PMC_DEVICE_S6\t0x28b\n#define PMC_DEVICE_S7\t0x28c\n#define PMC_DEVICE_S8\t0x28d\n\n#define aac_phys_to_logical(x)  ((x)+1)\n#define aac_logical_to_phys(x)  ((x)?(x)-1:0)\n\n \n#define AAC_CHARDEV_UNREGISTERED\t(-1)\n#define AAC_CHARDEV_NEEDS_REINIT\t(-2)\n\n \n\nstruct diskparm\n{\n\tint heads;\n\tint sectors;\n\tint cylinders;\n};\n\n\n \n\n#define\t\tCT_NONE\t\t\t0\n#define\t\tCT_OK\t\t\t218\n#define\t\tFT_FILESYS\t8\t \n#define\t\tFT_DRIVE\t9\t \n\n \nstruct sgentry {\n\t__le32\taddr;\t \n\t__le32\tcount;\t \n};\n\nstruct user_sgentry {\n\tu32\taddr;\t \n\tu32\tcount;\t \n};\n\nstruct sgentry64 {\n\t__le32\taddr[2];\t \n\t__le32\tcount;\t \n};\n\nstruct user_sgentry64 {\n\tu32\taddr[2];\t \n\tu32\tcount;\t \n};\n\nstruct sgentryraw {\n\t__le32\t\tnext;\t \n\t__le32\t\tprev;\t \n\t__le32\t\taddr[2];\n\t__le32\t\tcount;\n\t__le32\t\tflags;\t \n};\n\nstruct user_sgentryraw {\n\tu32\t\tnext;\t \n\tu32\t\tprev;\t \n\tu32\t\taddr[2];\n\tu32\t\tcount;\n\tu32\t\tflags;\t \n};\n\nstruct sge_ieee1212 {\n\tu32\taddrLow;\n\tu32\taddrHigh;\n\tu32\tlength;\n\tu32\tflags;\n};\n\n \n\nstruct sgmap {\n\t__le32\t\tcount;\n\tstruct sgentry\tsg[1];\n};\n\nstruct user_sgmap {\n\tu32\t\tcount;\n\tstruct user_sgentry\tsg[1];\n};\n\nstruct sgmap64 {\n\t__le32\t\tcount;\n\tstruct sgentry64 sg[1];\n};\n\nstruct user_sgmap64 {\n\tu32\t\tcount;\n\tstruct user_sgentry64 sg[1];\n};\n\nstruct sgmapraw {\n\t__le32\t\t  count;\n\tstruct sgentryraw sg[1];\n};\n\nstruct user_sgmapraw {\n\tu32\t\t  count;\n\tstruct user_sgentryraw sg[1];\n};\n\nstruct creation_info\n{\n\tu8\t\tbuildnum;\t\t \n\tu8\t\tusec;\t\t\t \n\tu8\t\tvia;\t\t\t \n\tu8\t\tyear;\t\t\t \n\t__le32\t\tdate;\t\t\t \n\t__le32\t\tserial[2];\t\t\t \n};\n\n\n \n\n \n\n#define NUMBER_OF_COMM_QUEUES  8   \n#define HOST_HIGH_CMD_ENTRIES  4\n#define HOST_NORM_CMD_ENTRIES  8\n#define ADAP_HIGH_CMD_ENTRIES  4\n#define ADAP_NORM_CMD_ENTRIES  512\n#define HOST_HIGH_RESP_ENTRIES 4\n#define HOST_NORM_RESP_ENTRIES 512\n#define ADAP_HIGH_RESP_ENTRIES 4\n#define ADAP_NORM_RESP_ENTRIES 8\n\n#define TOTAL_QUEUE_ENTRIES  \\\n    (HOST_NORM_CMD_ENTRIES + HOST_HIGH_CMD_ENTRIES + ADAP_NORM_CMD_ENTRIES + ADAP_HIGH_CMD_ENTRIES + \\\n\t    HOST_NORM_RESP_ENTRIES + HOST_HIGH_RESP_ENTRIES + ADAP_NORM_RESP_ENTRIES + ADAP_HIGH_RESP_ENTRIES)\n\n\n \n\n#define QUEUE_ALIGNMENT\t\t16\n\n \n\nstruct aac_entry {\n\t__le32 size;  \n\t__le32 addr;  \n};\n\n \n\nstruct aac_qhdr {\n\t__le64 header_addr; \n\t__le32 *producer;  \n\t__le32 *consumer;  \n};\n\n \n\n#define\t\tHostNormCmdQue\t\t1\t \n#define\t\tHostHighCmdQue\t\t2\t \n#define\t\tHostNormRespQue\t\t3\t \n#define\t\tHostHighRespQue\t\t4\t \n#define\t\tAdapNormRespNotFull\t5\n#define\t\tAdapHighRespNotFull\t6\n#define\t\tAdapNormCmdNotFull\t7\n#define\t\tAdapHighCmdNotFull\t8\n#define\t\tSynchCommandComplete\t9\n#define\t\tAdapInternalError\t0xfe     \n\n \n\n#define\t\tAdapNormCmdQue\t\t2\n#define\t\tAdapHighCmdQue\t\t3\n#define\t\tAdapNormRespQue\t\t6\n#define\t\tAdapHighRespQue\t\t7\n#define\t\tHostShutdown\t\t8\n#define\t\tHostPowerFail\t\t9\n#define\t\tFatalCommError\t\t10\n#define\t\tHostNormRespNotFull\t11\n#define\t\tHostHighRespNotFull\t12\n#define\t\tHostNormCmdNotFull\t13\n#define\t\tHostHighCmdNotFull\t14\n#define\t\tFastIo\t\t\t15\n#define\t\tAdapPrintfDone\t\t16\n\n \n\nenum aac_queue_types {\n        HostNormCmdQueue = 0,\t \n        HostHighCmdQueue,\t \n        AdapNormCmdQueue,\t \n        AdapHighCmdQueue,\t \n        HostNormRespQueue,\t \n        HostHighRespQueue,\t \n        AdapNormRespQueue,\t \n        AdapHighRespQueue\t \n};\n\n \n\n#define\t\tFIB_MAGIC\t0x0001\n#define\t\tFIB_MAGIC2\t0x0004\n#define\t\tFIB_MAGIC2_64\t0x0005\n\n \n\n#define\t\tFsaNormal\t1\n\n \nstruct aac_fib_xporthdr {\n\t__le64\tHostAddress;\t \n\t__le32\tSize;\t\t \n\t__le32\tHandle;\t\t \n\t__le64\tReserved[2];\n};\n\n#define\t\tALIGN32\t\t32\n\n \n\nstruct aac_fibhdr {\n\t__le32 XferState;\t \n\t__le16 Command;\t\t \n\tu8 StructType;\t\t \n\tu8 Unused;\t\t \n\t__le16 Size;\t\t \n\t__le16 SenderSize;\t \n\t__le32 SenderFibAddress;   \n\tunion {\n\t\t__le32 ReceiverFibAddress; \n\t\t__le32 SenderFibAddressHigh; \n\t\t__le32 TimeStamp;\t \n\t} u;\n\t__le32 Handle;\t\t \n\tu32 Previous;\t\t \n\tu32 Next;\t\t \n};\n\nstruct hw_fib {\n\tstruct aac_fibhdr header;\n\tu8 data[512-sizeof(struct aac_fibhdr)];\t\n};\n\n \n\n#define\t\tTestCommandResponse\t\t1\n#define\t\tTestAdapterCommand\t\t2\n \n#define\t\tLastTestCommand\t\t\t100\n#define\t\tReinitHostNormCommandQueue\t101\n#define\t\tReinitHostHighCommandQueue\t102\n#define\t\tReinitHostHighRespQueue\t\t103\n#define\t\tReinitHostNormRespQueue\t\t104\n#define\t\tReinitAdapNormCommandQueue\t105\n#define\t\tReinitAdapHighCommandQueue\t107\n#define\t\tReinitAdapHighRespQueue\t\t108\n#define\t\tReinitAdapNormRespQueue\t\t109\n#define\t\tInterfaceShutdown\t\t110\n#define\t\tDmaCommandFib\t\t\t120\n#define\t\tStartProfile\t\t\t121\n#define\t\tTermProfile\t\t\t122\n#define\t\tSpeedTest\t\t\t123\n#define\t\tTakeABreakPt\t\t\t124\n#define\t\tRequestPerfData\t\t\t125\n#define\t\tSetInterruptDefTimer\t\t126\n#define\t\tSetInterruptDefCount\t\t127\n#define\t\tGetInterruptDefStatus\t\t128\n#define\t\tLastCommCommand\t\t\t129\n \n#define\t\tNuFileSystem\t\t\t300\n#define\t\tUFS\t\t\t\t301\n#define\t\tHostFileSystem\t\t\t302\n#define\t\tLastFileSystemCommand\t\t303\n \n#define\t\tContainerCommand\t\t500\n#define\t\tContainerCommand64\t\t501\n#define\t\tContainerRawIo\t\t\t502\n#define\t\tContainerRawIo2\t\t\t503\n \n#define\t\tScsiPortCommand\t\t\t600\n#define\t\tScsiPortCommand64\t\t601\n \n#define\t\tAifRequest\t\t\t700\n#define\t\tCheckRevision\t\t\t701\n#define\t\tFsaHostShutdown\t\t\t702\n#define\t\tRequestAdapterInfo\t\t703\n#define\t\tIsAdapterPaused\t\t\t704\n#define\t\tSendHostTime\t\t\t705\n#define\t\tRequestSupplementAdapterInfo\t706\n#define\t\tLastMiscCommand\t\t\t707\n\n \n\nenum fib_xfer_state {\n\tHostOwned\t\t\t= (1<<0),\n\tAdapterOwned\t\t\t= (1<<1),\n\tFibInitialized\t\t\t= (1<<2),\n\tFibEmpty\t\t\t= (1<<3),\n\tAllocatedFromPool\t\t= (1<<4),\n\tSentFromHost\t\t\t= (1<<5),\n\tSentFromAdapter\t\t\t= (1<<6),\n\tResponseExpected\t\t= (1<<7),\n\tNoResponseExpected\t\t= (1<<8),\n\tAdapterProcessed\t\t= (1<<9),\n\tHostProcessed\t\t\t= (1<<10),\n\tHighPriority\t\t\t= (1<<11),\n\tNormalPriority\t\t\t= (1<<12),\n\tAsync\t\t\t\t= (1<<13),\n\tAsyncIo\t\t\t\t= (1<<13),\t\n\tPageFileIo\t\t\t= (1<<14),\t\n\tShutdownRequest\t\t\t= (1<<15),\n\tLazyWrite\t\t\t= (1<<16),\t\n\tAdapterMicroFib\t\t\t= (1<<17),\n\tBIOSFibPath\t\t\t= (1<<18),\n\tFastResponseCapable\t\t= (1<<19),\n\tApiFib\t\t\t\t= (1<<20),\t \n\t \n\tNoMoreAifDataAvailable\t\t= (1<<21)\n};\n\n \n\n#define ADAPTER_INIT_STRUCT_REVISION\t\t3\n#define ADAPTER_INIT_STRUCT_REVISION_4\t\t4 \n#define ADAPTER_INIT_STRUCT_REVISION_6\t\t6  \n#define ADAPTER_INIT_STRUCT_REVISION_7\t\t7  \n#define ADAPTER_INIT_STRUCT_REVISION_8\t\t8 \n\nunion aac_init\n{\n\tstruct _r7 {\n\t\t__le32\tinit_struct_revision;\n\t\t__le32\tno_of_msix_vectors;\n\t\t__le32\tfsrev;\n\t\t__le32\tcomm_header_address;\n\t\t__le32\tfast_io_comm_area_address;\n\t\t__le32\tadapter_fibs_physical_address;\n\t\t__le32\tadapter_fibs_virtual_address;\n\t\t__le32\tadapter_fibs_size;\n\t\t__le32\tadapter_fib_align;\n\t\t__le32\tprintfbuf;\n\t\t__le32\tprintfbufsiz;\n\t\t \n\t\t__le32\thost_phys_mem_pages;\n\t\t \n\t\t__le32\thost_elapsed_seconds;\n\t\t \n\t\t__le32\tinit_flags;\t \n#define INITFLAGS_NEW_COMM_SUPPORTED\t0x00000001\n#define INITFLAGS_DRIVER_USES_UTC_TIME\t0x00000010\n#define INITFLAGS_DRIVER_SUPPORTS_PM\t0x00000020\n#define INITFLAGS_NEW_COMM_TYPE1_SUPPORTED\t0x00000040\n#define INITFLAGS_FAST_JBOD_SUPPORTED\t0x00000080\n#define INITFLAGS_NEW_COMM_TYPE2_SUPPORTED\t0x00000100\n#define INITFLAGS_DRIVER_SUPPORTS_HBA_MODE  0x00000400\n\t\t__le32\tmax_io_commands;\t \n\t\t__le32\tmax_io_size;\t \n\t\t__le32\tmax_fib_size;\t \n\t\t \n\t\t__le32\tmax_num_aif;\t \n\t\t \n\t\t \n\t\t__le32\thost_rrq_addr_low;\n\t\t__le32\thost_rrq_addr_high;\n\t} r7;\n\tstruct _r8 {\n\t\t \n\t\t__le32\tinit_struct_revision;\n\t\t__le32\trr_queue_count;\n\t\t__le32\thost_elapsed_seconds;  \n\t\t__le32\tinit_flags;\n\t\t__le32\tmax_io_size;\t \n\t\t__le32\tmax_num_aif;\t \n\t\t__le32\treserved1;\n\t\t__le32\treserved2;\n\t\tstruct _rrq {\n\t\t\t__le32\thost_addr_low;\n\t\t\t__le32\thost_addr_high;\n\t\t\t__le16\tmsix_id;\n\t\t\t__le16\telement_count;\n\t\t\t__le16\tcomp_thresh;\n\t\t\t__le16\tunused;\n\t\t} rrq[1];\t\t \n\t} r8;\n};\n\nenum aac_log_level {\n\tLOG_AAC_INIT\t\t\t= 10,\n\tLOG_AAC_INFORMATIONAL\t\t= 20,\n\tLOG_AAC_WARNING\t\t\t= 30,\n\tLOG_AAC_LOW_ERROR\t\t= 40,\n\tLOG_AAC_MEDIUM_ERROR\t\t= 50,\n\tLOG_AAC_HIGH_ERROR\t\t= 60,\n\tLOG_AAC_PANIC\t\t\t= 70,\n\tLOG_AAC_DEBUG\t\t\t= 80,\n\tLOG_AAC_WINDBG_PRINT\t\t= 90\n};\n\n#define FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT\t0x030b\n#define FSAFS_NTC_FIB_CONTEXT\t\t\t0x030c\n\nstruct aac_dev;\nstruct fib;\nstruct scsi_cmnd;\n\nstruct adapter_ops\n{\n\t \n\tvoid (*adapter_interrupt)(struct aac_dev *dev);\n\tvoid (*adapter_notify)(struct aac_dev *dev, u32 event);\n\tvoid (*adapter_disable_int)(struct aac_dev *dev);\n\tvoid (*adapter_enable_int)(struct aac_dev *dev);\n\tint  (*adapter_sync_cmd)(struct aac_dev *dev, u32 command, u32 p1, u32 p2, u32 p3, u32 p4, u32 p5, u32 p6, u32 *status, u32 *r1, u32 *r2, u32 *r3, u32 *r4);\n\tint  (*adapter_check_health)(struct aac_dev *dev);\n\tint  (*adapter_restart)(struct aac_dev *dev, int bled, u8 reset_type);\n\tvoid (*adapter_start)(struct aac_dev *dev);\n\t \n\tint  (*adapter_ioremap)(struct aac_dev * dev, u32 size);\n\tirq_handler_t adapter_intr;\n\t \n\tint  (*adapter_deliver)(struct fib * fib);\n\tint  (*adapter_bounds)(struct aac_dev * dev, struct scsi_cmnd * cmd, u64 lba);\n\tint  (*adapter_read)(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count);\n\tint  (*adapter_write)(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count, int fua);\n\tint  (*adapter_scsi)(struct fib * fib, struct scsi_cmnd * cmd);\n\t \n\tint  (*adapter_comm)(struct aac_dev * dev, int comm);\n};\n\n \n\nstruct aac_driver_ident\n{\n\tint\t(*init)(struct aac_dev *dev);\n\tchar *\tname;\n\tchar *\tvname;\n\tchar *\tmodel;\n\tu16\tchannels;\n\tint\tquirks;\n};\n \n#define AAC_QUIRK_31BIT\t0x0001\n\n \n#define AAC_QUIRK_34SG\t0x0002\n\n \n#define AAC_QUIRK_SLAVE 0x0004\n\n \n#define AAC_QUIRK_MASTER 0x0008\n\n \n#define AAC_QUIRK_17SG\t0x0010\n\n \n#define AAC_QUIRK_SCSI_32\t0x0020\n\n \n#define AAC_QUIRK_SRC 0x0040\n\n \n\nstruct aac_queue {\n\tu64\t\t\tlogical;\t \n\tstruct aac_entry\t*base;\t\t \n\tstruct aac_qhdr\t\theaders;\t \n\tu32\t\t\tentries;\t \n\twait_queue_head_t\tqfull;\t\t \n\twait_queue_head_t\tcmdready;\t \n\t\t \n\tspinlock_t\t\t*lock;\t\t \n\tspinlock_t\t\tlockdata;\t \n\tstruct list_head\tcmdq;\t\t \n\t\t\t\t\t\t \n\t \n\tatomic_t\t\tnumpending;\n\tstruct aac_dev *\tdev;\t\t \n};\n\n \n\nstruct aac_queue_block\n{\n\tstruct aac_queue queue[8];\n};\n\n \n\nstruct sa_drawbridge_CSR {\n\t\t\t\t \n\t__le32\treserved[10];\t \n\tu8\tLUT_Offset;\t \n\tu8\treserved1[3];\t \n\t__le32\tLUT_Data;\t \n\t__le32\treserved2[26];\t \n\t__le16\tPRICLEARIRQ;\t \n\t__le16\tSECCLEARIRQ;\t \n\t__le16\tPRISETIRQ;\t \n\t__le16\tSECSETIRQ;\t \n\t__le16\tPRICLEARIRQMASK; \n\t__le16\tSECCLEARIRQMASK; \n\t__le16\tPRISETIRQMASK;\t \n\t__le16\tSECSETIRQMASK;\t \n\t__le32\tMAILBOX0;\t \n\t__le32\tMAILBOX1;\t \n\t__le32\tMAILBOX2;\t \n\t__le32\tMAILBOX3;\t \n\t__le32\tMAILBOX4;\t \n\t__le32\tMAILBOX5;\t \n\t__le32\tMAILBOX6;\t \n\t__le32\tMAILBOX7;\t \n\t__le32\tROM_Setup_Data;\t \n\t__le32\tROM_Control_Addr; \n\t__le32\treserved3[12];\t \n\t__le32\tLUT[64];\t \n};\n\n#define Mailbox0\tSaDbCSR.MAILBOX0\n#define Mailbox1\tSaDbCSR.MAILBOX1\n#define Mailbox2\tSaDbCSR.MAILBOX2\n#define Mailbox3\tSaDbCSR.MAILBOX3\n#define Mailbox4\tSaDbCSR.MAILBOX4\n#define Mailbox5\tSaDbCSR.MAILBOX5\n#define Mailbox6\tSaDbCSR.MAILBOX6\n#define Mailbox7\tSaDbCSR.MAILBOX7\n\n#define DoorbellReg_p SaDbCSR.PRISETIRQ\n#define DoorbellReg_s SaDbCSR.SECSETIRQ\n#define DoorbellClrReg_p SaDbCSR.PRICLEARIRQ\n\n\n#define\tDOORBELL_0\t0x0001\n#define DOORBELL_1\t0x0002\n#define DOORBELL_2\t0x0004\n#define DOORBELL_3\t0x0008\n#define DOORBELL_4\t0x0010\n#define DOORBELL_5\t0x0020\n#define DOORBELL_6\t0x0040\n\n\n#define PrintfReady\tDOORBELL_5\n#define PrintfDone\tDOORBELL_5\n\nstruct sa_registers {\n\tstruct sa_drawbridge_CSR\tSaDbCSR;\t\t\t \n};\n\n\n#define SA_INIT_NUM_MSIXVECTORS\t\t1\n#define SA_MINIPORT_REVISION\t\tSA_INIT_NUM_MSIXVECTORS\n\n#define sa_readw(AEP, CSR)\t\treadl(&((AEP)->regs.sa->CSR))\n#define sa_readl(AEP, CSR)\t\treadl(&((AEP)->regs.sa->CSR))\n#define sa_writew(AEP, CSR, value)\twritew(value, &((AEP)->regs.sa->CSR))\n#define sa_writel(AEP, CSR, value)\twritel(value, &((AEP)->regs.sa->CSR))\n\n \n\nstruct rx_mu_registers {\n\t\t\t     \n\t__le32\tARSR;\t     \n\t__le32\treserved0;   \n\t__le32\tAWR;\t     \n\t__le32\treserved1;   \n\t__le32\tIMRx[2];     \n\t__le32\tOMRx[2];     \n\t__le32\tIDR;\t     \n\t__le32\tIISR;\t     \n\t__le32\tIIMR;\t     \n\t__le32\tODR;\t     \n\t__le32\tOISR;\t     \n\t__le32\tOIMR;\t     \n\t__le32\treserved2;   \n\t__le32\treserved3;   \n\t__le32\tInboundQueue; \n\t__le32\tOutboundQueue; \n\t\t\t     \n};\n\nstruct rx_inbound {\n\t__le32\tMailbox[8];\n};\n\n#define\tINBOUNDDOORBELL_0\t0x00000001\n#define INBOUNDDOORBELL_1\t0x00000002\n#define INBOUNDDOORBELL_2\t0x00000004\n#define INBOUNDDOORBELL_3\t0x00000008\n#define INBOUNDDOORBELL_4\t0x00000010\n#define INBOUNDDOORBELL_5\t0x00000020\n#define INBOUNDDOORBELL_6\t0x00000040\n\n#define\tOUTBOUNDDOORBELL_0\t0x00000001\n#define OUTBOUNDDOORBELL_1\t0x00000002\n#define OUTBOUNDDOORBELL_2\t0x00000004\n#define OUTBOUNDDOORBELL_3\t0x00000008\n#define OUTBOUNDDOORBELL_4\t0x00000010\n\n#define InboundDoorbellReg\tMUnit.IDR\n#define OutboundDoorbellReg\tMUnit.ODR\n\nstruct rx_registers {\n\tstruct rx_mu_registers\t\tMUnit;\t\t \n\t__le32\t\t\t\treserved1[2];\t \n\tstruct rx_inbound\t\tIndexRegs;\n};\n\n#define rx_readb(AEP, CSR)\t\treadb(&((AEP)->regs.rx->CSR))\n#define rx_readl(AEP, CSR)\t\treadl(&((AEP)->regs.rx->CSR))\n#define rx_writeb(AEP, CSR, value)\twriteb(value, &((AEP)->regs.rx->CSR))\n#define rx_writel(AEP, CSR, value)\twritel(value, &((AEP)->regs.rx->CSR))\n\n \n\n#define rkt_mu_registers rx_mu_registers\n#define rkt_inbound rx_inbound\n\nstruct rkt_registers {\n\tstruct rkt_mu_registers\t\tMUnit;\t\t  \n\t__le32\t\t\t\treserved1[1006];  \n\tstruct rkt_inbound\t\tIndexRegs;\t  \n};\n\n#define rkt_readb(AEP, CSR)\t\treadb(&((AEP)->regs.rkt->CSR))\n#define rkt_readl(AEP, CSR)\t\treadl(&((AEP)->regs.rkt->CSR))\n#define rkt_writeb(AEP, CSR, value)\twriteb(value, &((AEP)->regs.rkt->CSR))\n#define rkt_writel(AEP, CSR, value)\twritel(value, &((AEP)->regs.rkt->CSR))\n\n \n\n#define src_inbound rx_inbound\n\nstruct src_mu_registers {\n\t\t\t\t \n\t__le32\treserved0[6];\t \n\t__le32\tIOAR[2];\t \n\t__le32\tIDR;\t\t \n\t__le32\tIISR;\t\t \n\t__le32\treserved1[3];\t \n\t__le32\tOIMR;\t\t \n\t__le32\treserved2[25];   \n\t__le32\tODR_R;\t\t \n\t__le32\tODR_C;\t\t \n\t__le32\treserved3[3];\t \n\t__le32\tSCR0;\t\t \n\t__le32\treserved4[2];\t \n\t__le32\tOMR;\t\t \n\t__le32\tIQ_L;\t\t \n\t__le32\tIQ_H;\t\t \n\t__le32\tODR_MSI;\t \n\t__le32  reserved5;\t \n\t__le32\tIQN_L;\t\t \n\t__le32\tIQN_H;\t\t \n};\n\nstruct src_registers {\n\tstruct src_mu_registers MUnit;\t \n\tunion {\n\t\tstruct {\n\t\t\t__le32 reserved1[130786];\t \n\t\t\tstruct src_inbound IndexRegs;\t \n\t\t} tupelo;\n\t\tstruct {\n\t\t\t__le32 reserved1[970];\t\t \n\t\t\tstruct src_inbound IndexRegs;\t \n\t\t} denali;\n\t} u;\n};\n\n#define src_readb(AEP, CSR)\t\treadb(&((AEP)->regs.src.bar0->CSR))\n#define src_readl(AEP, CSR)\t\treadl(&((AEP)->regs.src.bar0->CSR))\n#define src_writeb(AEP, CSR, value)\twriteb(value, \\\n\t\t\t\t\t\t&((AEP)->regs.src.bar0->CSR))\n#define src_writel(AEP, CSR, value)\twritel(value, \\\n\t\t\t\t\t\t&((AEP)->regs.src.bar0->CSR))\n#if defined(writeq)\n#define\tsrc_writeq(AEP, CSR, value)\twriteq(value, \\\n\t\t\t\t\t\t&((AEP)->regs.src.bar0->CSR))\n#endif\n\n#define SRC_ODR_SHIFT\t\t12\n#define SRC_IDR_SHIFT\t\t9\n#define SRC_MSI_READ_MASK\t0x1000\n\ntypedef void (*fib_callback)(void *ctxt, struct fib *fibctx);\n\nstruct aac_fib_context {\n\ts16\t\t\ttype;\t\t\n\ts16\t\t\tsize;\n\tu32\t\t\tunique;\t\t\n\tulong\t\t\tjiffies;\t\n\tstruct list_head\tnext;\t\t\n\tstruct completion\tcompletion;\t\n\tint\t\t\twait;\t\t\n\tunsigned long\t\tcount;\t\t\n\tstruct list_head\tfib_list;\t\n};\n\nstruct sense_data {\n\tu8 error_code;\t\t \n\tu8 valid:1;\t\t \n\t\t\t\t \n\tu8 segment_number;\t \n\tu8 sense_key:4;\t\t \n\tu8 reserved:1;\n\tu8 ILI:1;\t\t \n\tu8 EOM:1;\t\t \n\tu8 filemark:1;\t\t \n\n\tu8 information[4];\t \n\tu8 add_sense_len;\t \n\tu8 cmnd_info[4];\t \n\tu8 ASC;\t\t\t \n\tu8 ASCQ;\t\t \n\tu8 FRUC;\t\t \n\tu8 bit_ptr:3;\t\t \n\tu8 BPV:1;\t\t \n\tu8 reserved2:2;\n\tu8 CD:1;\t\t \n\tu8 SKSV:1;\n\tu8 field_ptr[2];\t \n};\n\nstruct fsa_dev_info {\n\tu64\t\tlast;\n\tu64\t\tsize;\n\tu32\t\ttype;\n\tu32\t\tconfig_waiting_on;\n\tunsigned long\tconfig_waiting_stamp;\n\tu16\t\tqueue_depth;\n\tu8\t\tconfig_needed;\n\tu8\t\tvalid;\n\tu8\t\tro;\n\tu8\t\tlocked;\n\tu8\t\tdeleted;\n\tchar\t\tdevname[8];\n\tstruct sense_data sense_data;\n\tu32\t\tblock_size;\n\tu8\t\tidentifier[16];\n};\n\nstruct fib {\n\tvoid\t\t\t*next;\t \n\ts16\t\t\ttype;\n\ts16\t\t\tsize;\n\t \n\tstruct aac_dev\t\t*dev;\n\t \n\tstruct completion\tevent_wait;\n\tspinlock_t\t\tevent_lock;\n\n\tu32\t\t\tdone;\t \n\tfib_callback\t\tcallback;\n\tvoid\t\t\t*callback_data;\n\tu32\t\t\tflags; \n\t \n\tstruct list_head\tfiblink;\n\tvoid\t\t\t*data;\n\tu32\t\t\tvector_no;\n\tstruct hw_fib\t\t*hw_fib_va;\t \n\tdma_addr_t\t\thw_fib_pa;\t \n\tdma_addr_t\t\thw_sgl_pa;\t \n\tdma_addr_t\t\thw_error_pa;\t \n\tu32\t\t\thbacmd_size;\t \n};\n\n#define AAC_INIT\t\t\t0\n#define AAC_RESCAN\t\t\t1\n\n#define AAC_DEVTYPE_RAID_MEMBER\t1\n#define AAC_DEVTYPE_ARC_RAW\t\t2\n#define AAC_DEVTYPE_NATIVE_RAW\t\t3\n\n#define AAC_RESCAN_DELAY\t\t(10 * HZ)\n\nstruct aac_hba_map_info {\n\t__le32\trmw_nexus;\t\t \n\tu8\t\tdevtype;\t \n\ts8\t\treset_state;\t \n\t\t\t\t\t \n\tu16\t\tqd_limit;\n\tu32\t\tscan_counter;\n\tstruct aac_ciss_identify_pd  *safw_identify_resp;\n};\n\n \n\nstruct aac_adapter_info\n{\n\t__le32\tplatform;\n\t__le32\tcpu;\n\t__le32\tsubcpu;\n\t__le32\tclock;\n\t__le32\texecmem;\n\t__le32\tbuffermem;\n\t__le32\ttotalmem;\n\t__le32\tkernelrev;\n\t__le32\tkernelbuild;\n\t__le32\tmonitorrev;\n\t__le32\tmonitorbuild;\n\t__le32\thwrev;\n\t__le32\thwbuild;\n\t__le32\tbiosrev;\n\t__le32\tbiosbuild;\n\t__le32\tcluster;\n\t__le32\tclusterchannelmask;\n\t__le32\tserial[2];\n\t__le32\tbattery;\n\t__le32\toptions;\n\t__le32\tOEM;\n};\n\nstruct aac_supplement_adapter_info\n{\n\tu8\tadapter_type_text[17+1];\n\tu8\tpad[2];\n\t__le32\tflash_memory_byte_size;\n\t__le32\tflash_image_id;\n\t__le32\tmax_number_ports;\n\t__le32\tversion;\n\t__le32\tfeature_bits;\n\tu8\tslot_number;\n\tu8\treserved_pad0[3];\n\tu8\tbuild_date[12];\n\t__le32\tcurrent_number_ports;\n\tstruct {\n\t\tu8\tassembly_pn[8];\n\t\tu8\tfru_pn[8];\n\t\tu8\tbattery_fru_pn[8];\n\t\tu8\tec_version_string[8];\n\t\tu8\ttsid[12];\n\t}\tvpd_info;\n\t__le32\tflash_firmware_revision;\n\t__le32\tflash_firmware_build;\n\t__le32\traid_type_morph_options;\n\t__le32\tflash_firmware_boot_revision;\n\t__le32\tflash_firmware_boot_build;\n\tu8\tmfg_pcba_serial_no[12];\n\tu8\tmfg_wwn_name[8];\n\t__le32\tsupported_options2;\n\t__le32\tstruct_expansion;\n\t \n\t__le32\tfeature_bits3;\n\t__le32\tsupported_performance_modes;\n\tu8\thost_bus_type;\t\t \n\tu8\thost_bus_width;\t\t \n\tu16\thost_bus_speed;\t\t \n\tu8\tmax_rrc_drives;\t\t \n\tu8\tmax_disk_xtasks;\t \n\n\tu8\tcpld_ver_loaded;\n\tu8\tcpld_ver_in_flash;\n\n\t__le64\tmax_rrc_capacity;\n\t__le32\tcompiled_max_hist_log_level;\n\tu8\tcustom_board_name[12];\n\tu16\tsupported_cntlr_mode;\t \n\tu16\treserved_for_future16;\n\t__le32\tsupported_options3;\t \n\n\t__le16\tvirt_device_bus;\t\t \n\t__le16\tvirt_device_target;\n\t__le16\tvirt_device_lun;\n\t__le16\tunused;\n\t__le32\treserved_for_future_growth[68];\n\n};\n#define AAC_FEATURE_FALCON\tcpu_to_le32(0x00000010)\n#define AAC_FEATURE_JBOD\tcpu_to_le32(0x08000000)\n \n#define AAC_OPTION_MU_RESET\t\tcpu_to_le32(0x00000001)\n#define AAC_OPTION_IGNORE_RESET\t\tcpu_to_le32(0x00000002)\n#define AAC_OPTION_POWER_MANAGEMENT\tcpu_to_le32(0x00000004)\n#define AAC_OPTION_DOORBELL_RESET\tcpu_to_le32(0x00004000)\n \n#define AAC_OPTION_VARIABLE_BLOCK_SIZE\tcpu_to_le32(0x00040000)\n \n#define AAC_OPTION_SUPPORTED_240_VOLUMES cpu_to_le32(0x10000000)\n \n#define AAC_OPTION_SUPPORTED3_IOP_RESET_FIB_DUMP\tcpu_to_le32(0x00004000)\n#define AAC_SIS_VERSION_V3\t3\n#define AAC_SIS_SLOT_UNKNOWN\t0xFF\n\n#define GetBusInfo 0x00000009\nstruct aac_bus_info {\n\t__le32\tCommand;\t \n\t__le32\tObjType;\t \n\t__le32\tMethodId;\t \n\t__le32\tObjectId;\t \n\t__le32\tCtlCmd;\t\t \n};\n\nstruct aac_bus_info_response {\n\t__le32\tStatus;\t\t \n\t__le32\tObjType;\n\t__le32\tMethodId;\t \n\t__le32\tObjectId;\t \n\t__le32\tCtlCmd;\t\t \n\t__le32\tProbeComplete;\n\t__le32\tBusCount;\n\t__le32\tTargetsPerBus;\n\tu8\tInitiatorBusId[10];\n\tu8\tBusValid[10];\n};\n\n \n#define AAC_BAT_REQ_PRESENT\t(1)\n#define AAC_BAT_REQ_NOTPRESENT\t(2)\n#define AAC_BAT_OPT_PRESENT\t(3)\n#define AAC_BAT_OPT_NOTPRESENT\t(4)\n#define AAC_BAT_NOT_SUPPORTED\t(5)\n \n#define AAC_CPU_SIMULATOR\t(1)\n#define AAC_CPU_I960\t\t(2)\n#define AAC_CPU_STRONGARM\t(3)\n\n \n#define AAC_OPT_SNAPSHOT\t\tcpu_to_le32(1)\n#define AAC_OPT_CLUSTERS\t\tcpu_to_le32(1<<1)\n#define AAC_OPT_WRITE_CACHE\t\tcpu_to_le32(1<<2)\n#define AAC_OPT_64BIT_DATA\t\tcpu_to_le32(1<<3)\n#define AAC_OPT_HOST_TIME_FIB\t\tcpu_to_le32(1<<4)\n#define AAC_OPT_RAID50\t\t\tcpu_to_le32(1<<5)\n#define AAC_OPT_4GB_WINDOW\t\tcpu_to_le32(1<<6)\n#define AAC_OPT_SCSI_UPGRADEABLE\tcpu_to_le32(1<<7)\n#define AAC_OPT_SOFT_ERR_REPORT\t\tcpu_to_le32(1<<8)\n#define AAC_OPT_SUPPORTED_RECONDITION\tcpu_to_le32(1<<9)\n#define AAC_OPT_SGMAP_HOST64\t\tcpu_to_le32(1<<10)\n#define AAC_OPT_ALARM\t\t\tcpu_to_le32(1<<11)\n#define AAC_OPT_NONDASD\t\t\tcpu_to_le32(1<<12)\n#define AAC_OPT_SCSI_MANAGED\t\tcpu_to_le32(1<<13)\n#define AAC_OPT_RAID_SCSI_MODE\t\tcpu_to_le32(1<<14)\n#define AAC_OPT_SUPPLEMENT_ADAPTER_INFO\tcpu_to_le32(1<<16)\n#define AAC_OPT_NEW_COMM\t\tcpu_to_le32(1<<17)\n#define AAC_OPT_NEW_COMM_64\t\tcpu_to_le32(1<<18)\n#define AAC_OPT_EXTENDED\t\tcpu_to_le32(1<<23)\n#define AAC_OPT_NATIVE_HBA\t\tcpu_to_le32(1<<25)\n#define AAC_OPT_NEW_COMM_TYPE1\t\tcpu_to_le32(1<<28)\n#define AAC_OPT_NEW_COMM_TYPE2\t\tcpu_to_le32(1<<29)\n#define AAC_OPT_NEW_COMM_TYPE3\t\tcpu_to_le32(1<<30)\n#define AAC_OPT_NEW_COMM_TYPE4\t\tcpu_to_le32(1<<31)\n\n#define AAC_COMM_PRODUCER\t\t0\n#define AAC_COMM_MESSAGE\t\t1\n#define AAC_COMM_MESSAGE_TYPE1\t\t3\n#define AAC_COMM_MESSAGE_TYPE2\t\t4\n#define AAC_COMM_MESSAGE_TYPE3\t\t5\n\n#define AAC_EXTOPT_SA_FIRMWARE\t\tcpu_to_le32(1<<1)\n#define AAC_EXTOPT_SOFT_RESET\t\tcpu_to_le32(1<<16)\n\n \nstruct aac_msix_ctx {\n\tint\t\tvector_no;\n\tstruct aac_dev\t*dev;\n};\n\nstruct aac_dev\n{\n\tstruct list_head\tentry;\n\tconst char\t\t*name;\n\tint\t\t\tid;\n\n\t \n\tunsigned int\t\tmax_fib_size;\n\tunsigned int\t\tsg_tablesize;\n\tunsigned int\t\tmax_num_aif;\n\n\tunsigned int\t\tmax_cmd_size;\t \n\n\t \n\tdma_addr_t\t\thw_fib_pa;\t \n\tstruct hw_fib\t\t*hw_fib_va;\t \n\tstruct hw_fib\t\t*aif_base_va;\n\t \n\tstruct fib              *fibs;\n\n\tstruct fib\t\t*free_fib;\n\tspinlock_t\t\tfib_lock;\n\n\tstruct mutex\t\tioctl_mutex;\n\tstruct mutex\t\tscan_mutex;\n\tstruct aac_queue_block *queues;\n\t \n\tstruct list_head\tfib_list;\n\n\tstruct adapter_ops\ta_ops;\n\tunsigned long\t\tfsrev;\t\t \n\n\tresource_size_t\t\tbase_start;\t \n\tresource_size_t\t\tdbg_base;\t \n\n\tresource_size_t\t\tbase_size, dbg_size;\t \n\t \n\tunion aac_init\t\t*init;\n\tdma_addr_t\t\tinit_pa;\t \n\t \n\t__le32\t\t\t*host_rrq;\n\tdma_addr_t\t\thost_rrq_pa;\t \n\t \n\tu32\t\t\thost_rrq_idx[AAC_MAX_MSIX];\n\tatomic_t\t\trrq_outstanding[AAC_MAX_MSIX];\n\tu32\t\t\tfibs_pushed_no;\n\tstruct pci_dev\t\t*pdev;\t\t \n\t \n\tvoid\t\t\t*printfbuf;\n\tvoid\t\t\t*comm_addr;\t \n\tdma_addr_t\t\tcomm_phys;\t \n\tsize_t\t\t\tcomm_size;\n\n\tstruct Scsi_Host\t*scsi_host_ptr;\n\tint\t\t\tmaximum_num_containers;\n\tint\t\t\tmaximum_num_physicals;\n\tint\t\t\tmaximum_num_channels;\n\tstruct fsa_dev_info\t*fsa_dev;\n\tstruct task_struct\t*thread;\n\tstruct delayed_work\tsafw_rescan_work;\n\tstruct delayed_work\tsrc_reinit_aif_worker;\n\tint\t\t\tcardtype;\n\t \n\tspinlock_t\t\tiq_lock;\n\n\t \n#ifndef AAC_MIN_FOOTPRINT_SIZE\n#\tdefine AAC_MIN_FOOTPRINT_SIZE 8192\n#\tdefine AAC_MIN_SRC_BAR0_SIZE 0x400000\n#\tdefine AAC_MIN_SRC_BAR1_SIZE 0x800\n#\tdefine AAC_MIN_SRCV_BAR0_SIZE 0x100000\n#\tdefine AAC_MIN_SRCV_BAR1_SIZE 0x400\n#endif\n\tunion\n\t{\n\t\tstruct sa_registers __iomem *sa;\n\t\tstruct rx_registers __iomem *rx;\n\t\tstruct rkt_registers __iomem *rkt;\n\t\tstruct {\n\t\t\tstruct src_registers __iomem *bar0;\n\t\t\tchar __iomem *bar1;\n\t\t} src;\n\t} regs;\n\tvolatile void __iomem *base, *dbg_base_mapped;\n\tvolatile struct rx_inbound __iomem *IndexRegs;\n\tu32\t\t\tOIMR;  \n\t \n\tu32\t\t\taif_thread;\n\tstruct aac_adapter_info adapter_info;\n\tstruct aac_supplement_adapter_info supplement_adapter_info;\n\t \n\tu8\t\t\tnondasd_support;\n\tu8\t\t\tjbod;\n\tu8\t\t\tcache_protected;\n\tu8\t\t\tdac_support;\n\tu8\t\t\tneeds_dac;\n\tu8\t\t\traid_scsi_mode;\n\tu8\t\t\tcomm_interface;\n\tu8\t\t\traw_io_interface;\n\tu8\t\t\traw_io_64;\n\tu8\t\t\tprintf_enabled;\n\tu8\t\t\tin_reset;\n\tu8\t\t\tin_soft_reset;\n\tu8\t\t\tmsi;\n\tu8\t\t\tsa_firmware;\n\tint\t\t\tmanagement_fib_count;\n\tspinlock_t\t\tmanage_lock;\n\tspinlock_t\t\tsync_lock;\n\tint\t\t\tsync_mode;\n\tstruct fib\t\t*sync_fib;\n\tstruct list_head\tsync_fib_list;\n\tu32\t\t\tdoorbell_mask;\n\tu32\t\t\tmax_msix;\t \n\tu32\t\t\tvector_cap;\t \n\tint\t\t\tmsi_enabled;\t \n\tatomic_t\t\tmsix_counter;\n\tu32\t\t\tscan_counter;\n\tstruct msix_entry\tmsixentry[AAC_MAX_MSIX];\n\tstruct aac_msix_ctx\taac_msix[AAC_MAX_MSIX];  \n\tstruct aac_hba_map_info\thba_map[AAC_MAX_BUSES][AAC_MAX_TARGETS];\n\tstruct aac_ciss_phys_luns_resp *safw_phys_luns;\n\tu8\t\t\tadapter_shutdown;\n\tu32\t\t\thandle_pci_error;\n\tbool\t\t\tinit_reset;\n\tu8\t\t\tsoft_reset_support;\n};\n\n#define aac_adapter_interrupt(dev) \\\n\t(dev)->a_ops.adapter_interrupt(dev)\n\n#define aac_adapter_notify(dev, event) \\\n\t(dev)->a_ops.adapter_notify(dev, event)\n\n#define aac_adapter_disable_int(dev) \\\n\t(dev)->a_ops.adapter_disable_int(dev)\n\n#define aac_adapter_enable_int(dev) \\\n\t(dev)->a_ops.adapter_enable_int(dev)\n\n#define aac_adapter_sync_cmd(dev, command, p1, p2, p3, p4, p5, p6, status, r1, r2, r3, r4) \\\n\t(dev)->a_ops.adapter_sync_cmd(dev, command, p1, p2, p3, p4, p5, p6, status, r1, r2, r3, r4)\n\n#define aac_adapter_restart(dev, bled, reset_type) \\\n\t((dev)->a_ops.adapter_restart(dev, bled, reset_type))\n\n#define aac_adapter_start(dev) \\\n\t((dev)->a_ops.adapter_start(dev))\n\n#define aac_adapter_ioremap(dev, size) \\\n\t(dev)->a_ops.adapter_ioremap(dev, size)\n\n#define aac_adapter_deliver(fib) \\\n\t((fib)->dev)->a_ops.adapter_deliver(fib)\n\n#define aac_adapter_bounds(dev,cmd,lba) \\\n\tdev->a_ops.adapter_bounds(dev,cmd,lba)\n\n#define aac_adapter_read(fib,cmd,lba,count) \\\n\t((fib)->dev)->a_ops.adapter_read(fib,cmd,lba,count)\n\n#define aac_adapter_write(fib,cmd,lba,count,fua) \\\n\t((fib)->dev)->a_ops.adapter_write(fib,cmd,lba,count,fua)\n\n#define aac_adapter_scsi(fib,cmd) \\\n\t((fib)->dev)->a_ops.adapter_scsi(fib,cmd)\n\n#define aac_adapter_comm(dev,comm) \\\n\t(dev)->a_ops.adapter_comm(dev, comm)\n\n#define FIB_CONTEXT_FLAG_TIMED_OUT\t\t(0x00000001)\n#define FIB_CONTEXT_FLAG\t\t\t(0x00000002)\n#define FIB_CONTEXT_FLAG_WAIT\t\t\t(0x00000004)\n#define FIB_CONTEXT_FLAG_FASTRESP\t\t(0x00000008)\n#define FIB_CONTEXT_FLAG_NATIVE_HBA\t\t(0x00000010)\n#define FIB_CONTEXT_FLAG_NATIVE_HBA_TMF\t(0x00000020)\n#define FIB_CONTEXT_FLAG_SCSI_CMD\t(0x00000040)\n#define FIB_CONTEXT_FLAG_EH_RESET\t(0x00000080)\n\n \n\n#define\t\tNull\t\t\t0\n#define\t\tGetAttributes\t\t1\n#define\t\tSetAttributes\t\t2\n#define\t\tLookup\t\t\t3\n#define\t\tReadLink\t\t4\n#define\t\tRead\t\t\t5\n#define\t\tWrite\t\t\t6\n#define\t\tCreate\t\t\t7\n#define\t\tMakeDirectory\t\t8\n#define\t\tSymbolicLink\t\t9\n#define\t\tMakeNode\t\t10\n#define\t\tRemovex\t\t\t11\n#define\t\tRemoveDirectoryx\t12\n#define\t\tRename\t\t\t13\n#define\t\tLink\t\t\t14\n#define\t\tReadDirectory\t\t15\n#define\t\tReadDirectoryPlus\t16\n#define\t\tFileSystemStatus\t17\n#define\t\tFileSystemInfo\t\t18\n#define\t\tPathConfigure\t\t19\n#define\t\tCommit\t\t\t20\n#define\t\tMount\t\t\t21\n#define\t\tUnMount\t\t\t22\n#define\t\tNewfs\t\t\t23\n#define\t\tFsCheck\t\t\t24\n#define\t\tFsSync\t\t\t25\n#define\t\tSimReadWrite\t\t26\n#define\t\tSetFileSystemStatus\t27\n#define\t\tBlockRead\t\t28\n#define\t\tBlockWrite\t\t29\n#define\t\tNvramIoctl\t\t30\n#define\t\tFsSyncWait\t\t31\n#define\t\tClearArchiveBit\t\t32\n#define\t\tSetAcl\t\t\t33\n#define\t\tGetAcl\t\t\t34\n#define\t\tAssignAcl\t\t35\n#define\t\tFaultInsertion\t\t36\t \n#define\t\tCrazyCache\t\t37\t \n\n#define\t\tMAX_FSACOMMAND_NUM\t38\n\n\n \n\n#define\t\tST_OK\t\t0\n#define\t\tST_PERM\t\t1\n#define\t\tST_NOENT\t2\n#define\t\tST_IO\t\t5\n#define\t\tST_NXIO\t\t6\n#define\t\tST_E2BIG\t7\n#define\t\tST_MEDERR\t8\n#define\t\tST_ACCES\t13\n#define\t\tST_EXIST\t17\n#define\t\tST_XDEV\t\t18\n#define\t\tST_NODEV\t19\n#define\t\tST_NOTDIR\t20\n#define\t\tST_ISDIR\t21\n#define\t\tST_INVAL\t22\n#define\t\tST_FBIG\t\t27\n#define\t\tST_NOSPC\t28\n#define\t\tST_ROFS\t\t30\n#define\t\tST_MLINK\t31\n#define\t\tST_WOULDBLOCK\t35\n#define\t\tST_NAMETOOLONG\t63\n#define\t\tST_NOTEMPTY\t66\n#define\t\tST_DQUOT\t69\n#define\t\tST_STALE\t70\n#define\t\tST_REMOTE\t71\n#define\t\tST_NOT_READY\t72\n#define\t\tST_BADHANDLE\t10001\n#define\t\tST_NOT_SYNC\t10002\n#define\t\tST_BAD_COOKIE\t10003\n#define\t\tST_NOTSUPP\t10004\n#define\t\tST_TOOSMALL\t10005\n#define\t\tST_SERVERFAULT\t10006\n#define\t\tST_BADTYPE\t10007\n#define\t\tST_JUKEBOX\t10008\n#define\t\tST_NOTMOUNTED\t10009\n#define\t\tST_MAINTMODE\t10010\n#define\t\tST_STALEACL\t10011\n\n \n\n#define\tCACHE_CSTABLE\t\t1\n#define CACHE_UNSTABLE\t\t2\n\n \n\n#define\tCMFILE_SYNCH_NVRAM\t1\n#define\tCMDATA_SYNCH_NVRAM\t2\n#define\tCMFILE_SYNCH\t\t3\n#define CMDATA_SYNCH\t\t4\n#define CMUNSTABLE\t\t5\n\n#define\tRIO_TYPE_WRITE \t\t\t0x0000\n#define\tRIO_TYPE_READ\t\t\t0x0001\n#define\tRIO_SUREWRITE\t\t\t0x0008\n\n#define RIO2_IO_TYPE\t\t\t0x0003\n#define RIO2_IO_TYPE_WRITE\t\t0x0000\n#define RIO2_IO_TYPE_READ\t\t0x0001\n#define RIO2_IO_TYPE_VERIFY\t\t0x0002\n#define RIO2_IO_ERROR\t\t\t0x0004\n#define RIO2_IO_SUREWRITE\t\t0x0008\n#define RIO2_SGL_CONFORMANT\t\t0x0010\n#define RIO2_SG_FORMAT\t\t\t0xF000\n#define RIO2_SG_FORMAT_ARC\t\t0x0000\n#define RIO2_SG_FORMAT_SRL\t\t0x1000\n#define RIO2_SG_FORMAT_IEEE1212\t\t0x2000\n\nstruct aac_read\n{\n\t__le32\t\tcommand;\n\t__le32\t\tcid;\n\t__le32\t\tblock;\n\t__le32\t\tcount;\n\tstruct sgmap\tsg;\t\n};\n\nstruct aac_read64\n{\n\t__le32\t\tcommand;\n\t__le16\t\tcid;\n\t__le16\t\tsector_count;\n\t__le32\t\tblock;\n\t__le16\t\tpad;\n\t__le16\t\tflags;\n\tstruct sgmap64\tsg;\t\n};\n\nstruct aac_read_reply\n{\n\t__le32\t\tstatus;\n\t__le32\t\tcount;\n};\n\nstruct aac_write\n{\n\t__le32\t\tcommand;\n\t__le32\t\tcid;\n\t__le32\t\tblock;\n\t__le32\t\tcount;\n\t__le32\t\tstable;\t\n\tstruct sgmap\tsg;\t\n};\n\nstruct aac_write64\n{\n\t__le32\t\tcommand;\n\t__le16\t\tcid;\n\t__le16\t\tsector_count;\n\t__le32\t\tblock;\n\t__le16\t\tpad;\n\t__le16\t\tflags;\n\tstruct sgmap64\tsg;\t\n};\nstruct aac_write_reply\n{\n\t__le32\t\tstatus;\n\t__le32\t\tcount;\n\t__le32\t\tcommitted;\n};\n\nstruct aac_raw_io\n{\n\t__le32\t\tblock[2];\n\t__le32\t\tcount;\n\t__le16\t\tcid;\n\t__le16\t\tflags;\t\t \n\t__le16\t\tbpTotal;\t \n\t__le16\t\tbpComplete;\t \n\tstruct sgmapraw\tsg;\n};\n\nstruct aac_raw_io2 {\n\t__le32\t\tblockLow;\n\t__le32\t\tblockHigh;\n\t__le32\t\tbyteCount;\n\t__le16\t\tcid;\n\t__le16\t\tflags;\t\t \n\t__le32\t\tsgeFirstSize;\t \n\t__le32\t\tsgeNominalSize;\t \n\tu8\t\tsgeCnt;\t\t \n\tu8\t\tbpTotal;\t \n\tu8\t\tbpComplete;\t \n\tu8\t\tsgeFirstIndex;\t \n\tu8\t\tunused[4];\n\tstruct sge_ieee1212\tsge[];\n};\n\n#define CT_FLUSH_CACHE 129\nstruct aac_synchronize {\n\t__le32\t\tcommand;\t \n\t__le32\t\ttype;\t\t \n\t__le32\t\tcid;\n\t__le32\t\tparm1;\n\t__le32\t\tparm2;\n\t__le32\t\tparm3;\n\t__le32\t\tparm4;\n\t__le32\t\tcount;\t \n};\n\nstruct aac_synchronize_reply {\n\t__le32\t\tdummy0;\n\t__le32\t\tdummy1;\n\t__le32\t\tstatus;\t \n\t__le32\t\tparm1;\n\t__le32\t\tparm2;\n\t__le32\t\tparm3;\n\t__le32\t\tparm4;\n\t__le32\t\tparm5;\n\tu8\t\tdata[16];\n};\n\n#define CT_POWER_MANAGEMENT\t245\n#define CT_PM_START_UNIT\t2\n#define CT_PM_STOP_UNIT\t\t3\n#define CT_PM_UNIT_IMMEDIATE\t1\nstruct aac_power_management {\n\t__le32\t\tcommand;\t \n\t__le32\t\ttype;\t\t \n\t__le32\t\tsub;\t\t \n\t__le32\t\tcid;\n\t__le32\t\tparm;\t\t \n};\n\n#define CT_PAUSE_IO    65\n#define CT_RELEASE_IO  66\nstruct aac_pause {\n\t__le32\t\tcommand;\t \n\t__le32\t\ttype;\t\t \n\t__le32\t\ttimeout;\t \n\t__le32\t\tmin;\n\t__le32\t\tnoRescan;\n\t__le32\t\tparm3;\n\t__le32\t\tparm4;\n\t__le32\t\tcount;\t \n};\n\nstruct aac_srb\n{\n\t__le32\t\tfunction;\n\t__le32\t\tchannel;\n\t__le32\t\tid;\n\t__le32\t\tlun;\n\t__le32\t\ttimeout;\n\t__le32\t\tflags;\n\t__le32\t\tcount;\t\t\n\t__le32\t\tretry_limit;\n\t__le32\t\tcdb_size;\n\tu8\t\tcdb[16];\n\tstruct\tsgmap\tsg;\n};\n\n \nstruct user_aac_srb\n{\n\tu32\t\tfunction;\n\tu32\t\tchannel;\n\tu32\t\tid;\n\tu32\t\tlun;\n\tu32\t\ttimeout;\n\tu32\t\tflags;\n\tu32\t\tcount;\t\t\n\tu32\t\tretry_limit;\n\tu32\t\tcdb_size;\n\tu8\t\tcdb[16];\n\tstruct\tuser_sgmap\tsg;\n};\n\n#define\t\tAAC_SENSE_BUFFERSIZE\t 30\n\nstruct aac_srb_reply\n{\n\t__le32\t\tstatus;\n\t__le32\t\tsrb_status;\n\t__le32\t\tscsi_status;\n\t__le32\t\tdata_xfer_length;\n\t__le32\t\tsense_data_size;\n\tu8\t\tsense_data[AAC_SENSE_BUFFERSIZE]; \n};\n\nstruct aac_srb_unit {\n\tstruct aac_srb\t\tsrb;\n\tstruct aac_srb_reply\tsrb_reply;\n};\n\n \n#define\t\tSRB_NoDataXfer\t\t 0x0000\n#define\t\tSRB_DisableDisconnect\t 0x0004\n#define\t\tSRB_DisableSynchTransfer 0x0008\n#define\t\tSRB_BypassFrozenQueue\t 0x0010\n#define\t\tSRB_DisableAutosense\t 0x0020\n#define\t\tSRB_DataIn\t\t 0x0040\n#define\t\tSRB_DataOut\t\t 0x0080\n\n \n#define\tSRBF_ExecuteScsi\t0x0000\n#define\tSRBF_ClaimDevice\t0x0001\n#define\tSRBF_IO_Control\t\t0x0002\n#define\tSRBF_ReceiveEvent\t0x0003\n#define\tSRBF_ReleaseQueue\t0x0004\n#define\tSRBF_AttachDevice\t0x0005\n#define\tSRBF_ReleaseDevice\t0x0006\n#define\tSRBF_Shutdown\t\t0x0007\n#define\tSRBF_Flush\t\t0x0008\n#define\tSRBF_AbortCommand\t0x0010\n#define\tSRBF_ReleaseRecovery\t0x0011\n#define\tSRBF_ResetBus\t\t0x0012\n#define\tSRBF_ResetDevice\t0x0013\n#define\tSRBF_TerminateIO\t0x0014\n#define\tSRBF_FlushQueue\t\t0x0015\n#define\tSRBF_RemoveDevice\t0x0016\n#define\tSRBF_DomainValidation\t0x0017\n\n \n#define SRB_STATUS_PENDING                  0x00\n#define SRB_STATUS_SUCCESS                  0x01\n#define SRB_STATUS_ABORTED                  0x02\n#define SRB_STATUS_ABORT_FAILED             0x03\n#define SRB_STATUS_ERROR                    0x04\n#define SRB_STATUS_BUSY                     0x05\n#define SRB_STATUS_INVALID_REQUEST          0x06\n#define SRB_STATUS_INVALID_PATH_ID          0x07\n#define SRB_STATUS_NO_DEVICE                0x08\n#define SRB_STATUS_TIMEOUT                  0x09\n#define SRB_STATUS_SELECTION_TIMEOUT        0x0A\n#define SRB_STATUS_COMMAND_TIMEOUT          0x0B\n#define SRB_STATUS_MESSAGE_REJECTED         0x0D\n#define SRB_STATUS_BUS_RESET                0x0E\n#define SRB_STATUS_PARITY_ERROR             0x0F\n#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10\n#define SRB_STATUS_NO_HBA                   0x11\n#define SRB_STATUS_DATA_OVERRUN             0x12\n#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13\n#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14\n#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15\n#define SRB_STATUS_REQUEST_FLUSHED          0x16\n#define SRB_STATUS_DELAYED_RETRY\t    0x17\n#define SRB_STATUS_INVALID_LUN              0x20\n#define SRB_STATUS_INVALID_TARGET_ID        0x21\n#define SRB_STATUS_BAD_FUNCTION             0x22\n#define SRB_STATUS_ERROR_RECOVERY           0x23\n#define SRB_STATUS_NOT_STARTED\t\t    0x24\n#define SRB_STATUS_NOT_IN_USE\t\t    0x30\n#define SRB_STATUS_FORCE_ABORT\t\t    0x31\n#define SRB_STATUS_DOMAIN_VALIDATION_FAIL   0x32\n\n \n\n#define\t\tVM_Null\t\t\t0\n#define\t\tVM_NameServe\t\t1\n#define\t\tVM_ContainerConfig\t2\n#define\t\tVM_Ioctl\t\t3\n#define\t\tVM_FilesystemIoctl\t4\n#define\t\tVM_CloseAll\t\t5\n#define\t\tVM_CtBlockRead\t\t6\n#define\t\tVM_CtBlockWrite\t\t7\n#define\t\tVM_SliceBlockRead\t8\t \n#define\t\tVM_SliceBlockWrite\t9\n#define\t\tVM_DriveBlockRead\t10\t \n#define\t\tVM_DriveBlockWrite\t11\n#define\t\tVM_EnclosureMgt\t\t12\t \n#define\t\tVM_Unused\t\t13\t \n#define\t\tVM_CtBlockVerify\t14\n#define\t\tVM_CtPerf\t\t15\t \n#define\t\tVM_CtBlockRead64\t16\n#define\t\tVM_CtBlockWrite64\t17\n#define\t\tVM_CtBlockVerify64\t18\n#define\t\tVM_CtHostRead64\t\t19\n#define\t\tVM_CtHostWrite64\t20\n#define\t\tVM_DrvErrTblLog\t\t21\n#define\t\tVM_NameServe64\t\t22\n#define\t\tVM_NameServeAllBlk\t30\n\n#define\t\tMAX_VMCOMMAND_NUM\t23\t \n\n \n\nstruct aac_fsinfo {\n\t__le32  fsTotalSize;\t \n\t__le32  fsBlockSize;\n\t__le32  fsFragSize;\n\t__le32  fsMaxExtendSize;\n\t__le32  fsSpaceUnits;\n\t__le32  fsMaxNumFiles;\n\t__le32  fsNumFreeFiles;\n\t__le32  fsInodeDensity;\n};\t \n\nstruct  aac_blockdevinfo {\n\t__le32\tblock_size;\n\t__le32  logical_phys_map;\n\tu8\tidentifier[16];\n};\n\nunion aac_contentinfo {\n\tstruct\taac_fsinfo\t\tfilesys;\n\tstruct\taac_blockdevinfo\tbdevinfo;\n};\n\n \n\n#define CT_GET_CONFIG_STATUS 147\nstruct aac_get_config_status {\n\t__le32\t\tcommand;\t \n\t__le32\t\ttype;\t\t \n\t__le32\t\tparm1;\n\t__le32\t\tparm2;\n\t__le32\t\tparm3;\n\t__le32\t\tparm4;\n\t__le32\t\tparm5;\n\t__le32\t\tcount;\t \n};\n\n#define CFACT_CONTINUE 0\n#define CFACT_PAUSE    1\n#define CFACT_ABORT    2\nstruct aac_get_config_status_resp {\n\t__le32\t\tresponse;  \n\t__le32\t\tdummy0;\n\t__le32\t\tstatus;\t \n\t__le32\t\tparm1;\n\t__le32\t\tparm2;\n\t__le32\t\tparm3;\n\t__le32\t\tparm4;\n\t__le32\t\tparm5;\n\tstruct {\n\t\t__le32\taction;  \n\t\t__le16\tflags;\n\t\t__le16\tcount;\n\t}\t\tdata;\n};\n\n \n\n#define CT_COMMIT_CONFIG 152\n\nstruct aac_commit_config {\n\t__le32\t\tcommand;\t \n\t__le32\t\ttype;\t\t \n};\n\n \n\n#define CT_GET_CONTAINER_COUNT 4\nstruct aac_get_container_count {\n\t__le32\t\tcommand;\t \n\t__le32\t\ttype;\t\t \n};\n\nstruct aac_get_container_count_resp {\n\t__le32\t\tresponse;  \n\t__le32\t\tdummy0;\n\t__le32\t\tMaxContainers;\n\t__le32\t\tContainerSwitchEntries;\n\t__le32\t\tMaxPartitions;\n\t__le32\t\tMaxSimpleVolumes;\n};\n\n\n \n\nstruct aac_mntent {\n\t__le32\t\t\toid;\n\tu8\t\t\tname[16];\t \n\tstruct creation_info\tcreate_info;\t \n\t__le32\t\t\tcapacity;\n\t__le32\t\t\tvol;\t\t \n\t__le32\t\t\tobj;\t\t \n\t__le32\t\t\tstate;\t\t \n\tunion aac_contentinfo\tfileinfo;\t \n\t__le32\t\t\taltoid;\t\t \n\t__le32\t\t\tcapacityhigh;\n};\n\n#define FSCS_NOTCLEAN\t0x0001   \n#define FSCS_READONLY\t0x0002\t \n#define FSCS_HIDDEN\t0x0004\t \n#define FSCS_NOT_READY\t0x0008\t \n\nstruct aac_query_mount {\n\t__le32\t\tcommand;\n\t__le32\t\ttype;\n\t__le32\t\tcount;\n};\n\nstruct aac_mount {\n\t__le32\t\tstatus;\n\t__le32\t\ttype;            \n\t__le32\t\tcount;\n\tstruct aac_mntent mnt[1];\n};\n\n#define CT_READ_NAME 130\nstruct aac_get_name {\n\t__le32\t\tcommand;\t \n\t__le32\t\ttype;\t\t \n\t__le32\t\tcid;\n\t__le32\t\tparm1;\n\t__le32\t\tparm2;\n\t__le32\t\tparm3;\n\t__le32\t\tparm4;\n\t__le32\t\tcount;\t \n};\n\nstruct aac_get_name_resp {\n\t__le32\t\tdummy0;\n\t__le32\t\tdummy1;\n\t__le32\t\tstatus;\t \n\t__le32\t\tparm1;\n\t__le32\t\tparm2;\n\t__le32\t\tparm3;\n\t__le32\t\tparm4;\n\t__le32\t\tparm5;\n\tu8\t\tdata[17];\n};\n\n#define CT_CID_TO_32BITS_UID 165\nstruct aac_get_serial {\n\t__le32\t\tcommand;\t \n\t__le32\t\ttype;\t\t \n\t__le32\t\tcid;\n};\n\nstruct aac_get_serial_resp {\n\t__le32\t\tdummy0;\n\t__le32\t\tdummy1;\n\t__le32\t\tstatus;\t \n\t__le32\t\tuid;\n};\n\n \n\nstruct aac_close {\n\t__le32\tcommand;\n\t__le32\tcid;\n};\n\nstruct aac_query_disk\n{\n\ts32\tcnum;\n\ts32\tbus;\n\ts32\tid;\n\ts32\tlun;\n\tu32\tvalid;\n\tu32\tlocked;\n\tu32\tdeleted;\n\ts32\tinstance;\n\ts8\tname[10];\n\tu32\tunmapped;\n};\n\nstruct aac_delete_disk {\n\tu32\tdisknum;\n\tu32\tcnum;\n};\n\nstruct fib_ioctl\n{\n\tu32\tfibctx;\n\ts32\twait;\n\tchar\t__user *fib;\n};\n\nstruct revision\n{\n\tu32 compat;\n\t__le32 version;\n\t__le32 build;\n};\n\n\n \n\n#define CTL_CODE(function, method) (                 \\\n    (4<< 16) | ((function) << 2) | (method) \\\n)\n\n \n\n#define METHOD_BUFFERED                 0\n#define METHOD_NEITHER                  3\n\n \n\n#define FSACTL_SENDFIB\t\t\t\tCTL_CODE(2050, METHOD_BUFFERED)\n#define FSACTL_SEND_RAW_SRB\t\t\tCTL_CODE(2067, METHOD_BUFFERED)\n#define FSACTL_DELETE_DISK\t\t\t0x163\n#define FSACTL_QUERY_DISK\t\t\t0x173\n#define FSACTL_OPEN_GET_ADAPTER_FIB\t\tCTL_CODE(2100, METHOD_BUFFERED)\n#define FSACTL_GET_NEXT_ADAPTER_FIB\t\tCTL_CODE(2101, METHOD_BUFFERED)\n#define FSACTL_CLOSE_GET_ADAPTER_FIB\t\tCTL_CODE(2102, METHOD_BUFFERED)\n#define FSACTL_MINIPORT_REV_CHECK               CTL_CODE(2107, METHOD_BUFFERED)\n#define FSACTL_GET_PCI_INFO\t\t\tCTL_CODE(2119, METHOD_BUFFERED)\n#define FSACTL_FORCE_DELETE_DISK\t\tCTL_CODE(2120, METHOD_NEITHER)\n#define FSACTL_GET_CONTAINERS\t\t\t2131\n#define FSACTL_SEND_LARGE_FIB\t\t\tCTL_CODE(2138, METHOD_BUFFERED)\n#define FSACTL_RESET_IOP\t\t\tCTL_CODE(2140, METHOD_BUFFERED)\n#define FSACTL_GET_HBA_INFO\t\t\tCTL_CODE(2150, METHOD_BUFFERED)\n \n#define HW_IOP_RESET\t\t\t\t0x01\n#define HW_SOFT_RESET\t\t\t\t0x02\n#define IOP_HWSOFT_RESET\t\t\t(HW_IOP_RESET | HW_SOFT_RESET)\n \n#define IBW_SWR_OFFSET\t\t\t\t0x4000\n#define SOFT_RESET_TIME\t\t\t60\n\n\n\nstruct aac_common\n{\n\t \n\tu32 irq_mod;\n\tu32 peak_fibs;\n\tu32 zero_fibs;\n\tu32 fib_timeouts;\n\t \n#ifdef DBG\n\tu32 FibsSent;\n\tu32 FibRecved;\n\tu32 NativeSent;\n\tu32 NativeRecved;\n\tu32 NoResponseSent;\n\tu32 NoResponseRecved;\n\tu32 AsyncSent;\n\tu32 AsyncRecved;\n\tu32 NormalSent;\n\tu32 NormalRecved;\n#endif\n};\n\nextern struct aac_common aac_config;\n\n \nstruct aac_hba_info {\n\n\tu8\tdriver_name[50];\n\tu8\tadapter_number;\n\tu8\tsystem_io_bus_number;\n\tu8\tdevice_number;\n\tu32\tfunction_number;\n\tu32\tvendor_id;\n\tu32\tdevice_id;\n\tu32\tsub_vendor_id;\n\tu32\tsub_system_id;\n\tu32\tmapped_base_address_size;\n\tu32\tbase_physical_address_high_part;\n\tu32\tbase_physical_address_low_part;\n\n\tu32\tmax_command_size;\n\tu32\tmax_fib_size;\n\tu32\tmax_scatter_gather_from_os;\n\tu32\tmax_scatter_gather_to_fw;\n\tu32\tmax_outstanding_fibs;\n\n\tu32\tqueue_start_threshold;\n\tu32\tqueue_dump_threshold;\n\tu32\tmax_io_size_queued;\n\tu32\toutstanding_io;\n\n\tu32\tfirmware_build_number;\n\tu32\tbios_build_number;\n\tu32\tdriver_build_number;\n\tu32\tserial_number_high_part;\n\tu32\tserial_number_low_part;\n\tu32\tsupported_options;\n\tu32\tfeature_bits;\n\tu32\tcurrentnumber_ports;\n\n\tu8\tnew_comm_interface:1;\n\tu8\tnew_commands_supported:1;\n\tu8\tdisable_passthrough:1;\n\tu8\texpose_non_dasd:1;\n\tu8\tqueue_allowed:1;\n\tu8\tbled_check_enabled:1;\n\tu8\treserved1:1;\n\tu8\treserted2:1;\n\n\tu32\treserved3[10];\n\n};\n\n \n\n#ifdef DBG\n#define\tFIB_COUNTER_INCREMENT(counter)\t\t(counter)++\n#else\n#define\tFIB_COUNTER_INCREMENT(counter)\n#endif\n\n \n\n#define\tBREAKPOINT_REQUEST\t\t0x00000004\n#define\tINIT_STRUCT_BASE_ADDRESS\t0x00000005\n#define READ_PERMANENT_PARAMETERS\t0x0000000a\n#define WRITE_PERMANENT_PARAMETERS\t0x0000000b\n#define HOST_CRASHING\t\t\t0x0000000d\n#define\tSEND_SYNCHRONOUS_FIB\t\t0x0000000c\n#define COMMAND_POST_RESULTS\t\t0x00000014\n#define GET_ADAPTER_PROPERTIES\t\t0x00000019\n#define GET_DRIVER_BUFFER_PROPERTIES\t0x00000023\n#define RCV_TEMP_READINGS\t\t0x00000025\n#define GET_COMM_PREFERRED_SETTINGS\t0x00000026\n#define IOP_RESET_FW_FIB_DUMP\t\t0x00000034\n#define DROP_IO\t\t\t0x00000035\n#define IOP_RESET\t\t\t0x00001000\n#define IOP_RESET_ALWAYS\t\t0x00001001\n#define RE_INIT_ADAPTER\t\t0x000000ee\n\n#define IOP_SRC_RESET_MASK\t\t0x00000100\n\n \n\n#define\tSELF_TEST_FAILED\t\t0x00000004\n#define\tMONITOR_PANIC\t\t\t0x00000020\n#define\tKERNEL_BOOTING\t\t\t0x00000040\n#define\tKERNEL_UP_AND_RUNNING\t\t0x00000080\n#define\tKERNEL_PANIC\t\t\t0x00000100\n#define\tFLASH_UPD_PENDING\t\t0x00002000\n#define\tFLASH_UPD_SUCCESS\t\t0x00004000\n#define\tFLASH_UPD_FAILED\t\t0x00008000\n#define\tINVALID_OMR\t\t\t0xffffffff\n#define\tFWUPD_TIMEOUT\t\t\t(5 * 60)\n\n \n\n#define DoorBellSyncCmdAvailable\t(1<<0)\t \n#define DoorBellPrintfDone\t\t(1<<5)\t \n#define DoorBellAdapterNormCmdReady\t(1<<1)\t \n#define DoorBellAdapterNormRespReady\t(1<<2)\t \n#define DoorBellAdapterNormCmdNotFull\t(1<<3)\t \n#define DoorBellAdapterNormRespNotFull\t(1<<4)\t \n#define DoorBellPrintfReady\t\t(1<<5)\t \n#define DoorBellAifPending\t\t(1<<6)\t \n\n \n#define PmDoorBellResponseSent\t\t(1<<1)\t \n\n \n\n#define\t\tAifCmdEventNotify\t1\t \n#define\t\t\tAifEnConfigChange\t3\t \n#define\t\t\tAifEnContainerChange\t4\t \n#define\t\t\tAifEnDeviceFailure\t5\t \n#define\t\t\tAifEnEnclosureManagement 13\t \n#define\t\t\t\tEM_DRIVE_INSERTION\t31\n#define\t\t\t\tEM_DRIVE_REMOVAL\t32\n#define\t\t\tEM_SES_DRIVE_INSERTION\t33\n#define\t\t\tEM_SES_DRIVE_REMOVAL\t26\n#define\t\t\tAifEnBatteryEvent\t14\t \n#define\t\t\tAifEnAddContainer\t15\t \n#define\t\t\tAifEnDeleteContainer\t16\t \n#define\t\t\tAifEnExpEvent\t\t23\t \n#define\t\t\tAifExeFirmwarePanic\t3\t \n#define\t\t\tAifHighPriority\t\t3\t \n#define\t\t\tAifEnAddJBOD\t\t30\t \n#define\t\t\tAifEnDeleteJBOD\t\t31\t \n\n#define\t\t\tAifBuManagerEvent\t\t42  \n#define\t\t\tAifBuCacheDataLoss\t\t10\n#define\t\t\tAifBuCacheDataRecover\t11\n\n#define\t\tAifCmdJobProgress\t2\t \n#define\t\t\tAifJobCtrZero\t101\t \n#define\t\t\tAifJobStsSuccess 1\t \n#define\t\t\tAifJobStsRunning 102\t \n#define\t\tAifCmdAPIReport\t\t3\t \n#define\t\tAifCmdDriverNotify\t4\t \n#define\t\t\tAifDenMorphComplete 200\t \n#define\t\t\tAifDenVolumeExtendComplete 201  \n#define\t\tAifReqJobList\t\t100\t \n#define\t\tAifReqJobsForCtr\t101\t \n#define\t\tAifReqJobsForScsi\t102\t \n#define\t\tAifReqJobReport\t\t103\t \n#define\t\tAifReqTerminateJob\t104\t \n#define\t\tAifReqSuspendJob\t105\t \n#define\t\tAifReqResumeJob\t\t106\t \n#define\t\tAifReqSendAPIReport\t107\t \n#define\t\tAifReqAPIJobStart\t108\t \n#define\t\tAifReqAPIJobUpdate\t109\t \n#define\t\tAifReqAPIJobFinish\t110\t \n\n \n#define\t\tAifReqEvent\t\t200\n#define\t\tAifRawDeviceRemove\t203\t \n#define\t\tAifNativeDeviceAdd\t204\t \n#define\t\tAifNativeDeviceRemove\t205\t \n\n\n \n\nstruct aac_aifcmd {\n\t__le32 command;\t\t \n\t__le32 seqnum;\t\t \n\tu8 data[];\t\t \n};\n\n \nstatic inline unsigned int cap_to_cyls(sector_t capacity, unsigned divisor)\n{\n\tsector_div(capacity, divisor);\n\treturn capacity;\n}\n\nstatic inline int aac_pci_offline(struct aac_dev *dev)\n{\n\treturn pci_channel_offline(dev->pdev) || dev->handle_pci_error;\n}\n\nstatic inline int aac_adapter_check_health(struct aac_dev *dev)\n{\n\tif (unlikely(aac_pci_offline(dev)))\n\t\treturn -1;\n\n\treturn (dev)->a_ops.adapter_check_health(dev);\n}\n\n\nint aac_scan_host(struct aac_dev *dev);\n\nstatic inline void aac_schedule_safw_scan_worker(struct aac_dev *dev)\n{\n\tschedule_delayed_work(&dev->safw_rescan_work, AAC_RESCAN_DELAY);\n}\n\nstatic inline void aac_schedule_src_reinit_aif_worker(struct aac_dev *dev)\n{\n\tschedule_delayed_work(&dev->src_reinit_aif_worker, AAC_RESCAN_DELAY);\n}\n\nstatic inline void aac_safw_rescan_worker(struct work_struct *work)\n{\n\tstruct aac_dev *dev = container_of(to_delayed_work(work),\n\t\tstruct aac_dev, safw_rescan_work);\n\n\twait_event(dev->scsi_host_ptr->host_wait,\n\t\t!scsi_host_in_recovery(dev->scsi_host_ptr));\n\n\taac_scan_host(dev);\n}\n\nstatic inline void aac_cancel_rescan_worker(struct aac_dev *dev)\n{\n\tcancel_delayed_work_sync(&dev->safw_rescan_work);\n\tcancel_delayed_work_sync(&dev->src_reinit_aif_worker);\n}\n\nenum aac_cmd_owner {\n\tAAC_OWNER_MIDLEVEL\t= 0x101,\n\tAAC_OWNER_LOWLEVEL\t= 0x102,\n\tAAC_OWNER_ERROR_HANDLER\t= 0x103,\n\tAAC_OWNER_FIRMWARE\t= 0x106,\n};\n\nstruct aac_cmd_priv {\n\tint\t\t\t(*callback)(struct scsi_cmnd *);\n\tint\t\t\tstatus;\n\tenum aac_cmd_owner\towner;\n\tbool\t\t\tsent_command;\n};\n\nstatic inline struct aac_cmd_priv *aac_priv(struct scsi_cmnd *cmd)\n{\n\treturn scsi_cmd_priv(cmd);\n}\n\nvoid aac_safw_rescan_worker(struct work_struct *work);\nvoid aac_src_reinit_aif_worker(struct work_struct *work);\nint aac_acquire_irq(struct aac_dev *dev);\nvoid aac_free_irq(struct aac_dev *dev);\nint aac_setup_safw_adapter(struct aac_dev *dev);\nconst char *aac_driverinfo(struct Scsi_Host *);\nvoid aac_fib_vector_assign(struct aac_dev *dev);\nstruct fib *aac_fib_alloc(struct aac_dev *dev);\nstruct fib *aac_fib_alloc_tag(struct aac_dev *dev, struct scsi_cmnd *scmd);\nint aac_fib_setup(struct aac_dev *dev);\nvoid aac_fib_map_free(struct aac_dev *dev);\nvoid aac_fib_free(struct fib * context);\nvoid aac_fib_init(struct fib * context);\nvoid aac_printf(struct aac_dev *dev, u32 val);\nint aac_fib_send(u16 command, struct fib * context, unsigned long size, int priority, int wait, int reply, fib_callback callback, void *ctxt);\nint aac_hba_send(u8 command, struct fib *context,\n\t\tfib_callback callback, void *ctxt);\nint aac_consumer_get(struct aac_dev * dev, struct aac_queue * q, struct aac_entry **entry);\nvoid aac_consumer_free(struct aac_dev * dev, struct aac_queue * q, u32 qnum);\nint aac_fib_complete(struct fib * context);\nvoid aac_hba_callback(void *context, struct fib *fibptr);\n#define fib_data(fibctx) ((void *)(fibctx)->hw_fib_va->data)\nstruct aac_dev *aac_init_adapter(struct aac_dev *dev);\nvoid aac_src_access_devreg(struct aac_dev *dev, int mode);\nvoid aac_set_intx_mode(struct aac_dev *dev);\nint aac_get_config_status(struct aac_dev *dev, int commit_flag);\nint aac_get_containers(struct aac_dev *dev);\nint aac_scsi_cmd(struct scsi_cmnd *cmd);\nint aac_dev_ioctl(struct aac_dev *dev, unsigned int cmd, void __user *arg);\n#ifndef shost_to_class\n#define shost_to_class(shost) &shost->shost_dev\n#endif\nssize_t aac_get_serial_number(struct device *dev, char *buf);\nint aac_do_ioctl(struct aac_dev *dev, unsigned int cmd, void __user *arg);\nint aac_rx_init(struct aac_dev *dev);\nint aac_rkt_init(struct aac_dev *dev);\nint aac_nark_init(struct aac_dev *dev);\nint aac_sa_init(struct aac_dev *dev);\nint aac_src_init(struct aac_dev *dev);\nint aac_srcv_init(struct aac_dev *dev);\nint aac_queue_get(struct aac_dev * dev, u32 * index, u32 qid, struct hw_fib * hw_fib, int wait, struct fib * fibptr, unsigned long *nonotify);\nvoid aac_define_int_mode(struct aac_dev *dev);\nunsigned int aac_response_normal(struct aac_queue * q);\nunsigned int aac_command_normal(struct aac_queue * q);\nunsigned int aac_intr_normal(struct aac_dev *dev, u32 Index,\n\t\t\tint isAif, int isFastResponse,\n\t\t\tstruct hw_fib *aif_fib);\nint aac_reset_adapter(struct aac_dev *dev, int forced, u8 reset_type);\nint aac_check_health(struct aac_dev * dev);\nint aac_command_thread(void *data);\nint aac_close_fib_context(struct aac_dev * dev, struct aac_fib_context *fibctx);\nint aac_fib_adapter_complete(struct fib * fibptr, unsigned short size);\nstruct aac_driver_ident* aac_get_driver_ident(int devtype);\nint aac_get_adapter_info(struct aac_dev* dev);\nint aac_send_shutdown(struct aac_dev *dev);\nint aac_probe_container(struct aac_dev *dev, int cid);\nint _aac_rx_init(struct aac_dev *dev);\nint aac_rx_select_comm(struct aac_dev *dev, int comm);\nint aac_rx_deliver_producer(struct fib * fib);\nvoid aac_reinit_aif(struct aac_dev *aac, unsigned int index);\n\nstatic inline int aac_is_src(struct aac_dev *dev)\n{\n\tu16 device = dev->pdev->device;\n\n\tif (device == PMC_DEVICE_S6 ||\n\t\tdevice == PMC_DEVICE_S7 ||\n\t\tdevice == PMC_DEVICE_S8)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int aac_supports_2T(struct aac_dev *dev)\n{\n\treturn (dev->adapter_info.options & AAC_OPT_NEW_COMM_64);\n}\n\nchar * get_container_type(unsigned type);\nextern int numacb;\nextern char aac_driver_version[];\nextern int startup_timeout;\nextern int aif_timeout;\nextern int expose_physicals;\nextern int aac_reset_devices;\nextern int aac_msi;\nextern int aac_commit;\nextern int update_interval;\nextern int check_interval;\nextern int aac_check_reset;\nextern int aac_fib_dump;\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}