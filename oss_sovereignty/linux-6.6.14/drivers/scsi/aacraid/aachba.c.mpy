{
  "module_name": "aachba.c",
  "hash_id": "1d3e75c03ca0e73b2acbfd3ed381e1e57c0e8eaba143ebd281c436ddd2f1bba4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/aachba.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/blkdev.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#include <asm/unaligned.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n\n#include \"aacraid.h\"\n\n \n#define\tINQD_PDT_DA\t0x00\t \n#define\tINQD_PDT_PROC\t0x03\t \n#define\tINQD_PDT_CHNGR\t0x08\t \n#define\tINQD_PDT_COMM\t0x09\t \n#define\tINQD_PDT_NOLUN2 0x1f\t \n#define\tINQD_PDT_NOLUN\t0x7f\t \n\n#define\tINQD_PDT_DMASK\t0x1F\t \n#define\tINQD_PDT_QMASK\t0xE0\t \n\n \n\n#define SENCODE_NO_SENSE\t\t\t0x00\n#define SENCODE_END_OF_DATA\t\t\t0x00\n#define SENCODE_BECOMING_READY\t\t\t0x04\n#define SENCODE_INIT_CMD_REQUIRED\t\t0x04\n#define SENCODE_UNRECOVERED_READ_ERROR\t\t0x11\n#define SENCODE_PARAM_LIST_LENGTH_ERROR\t\t0x1A\n#define SENCODE_INVALID_COMMAND\t\t\t0x20\n#define SENCODE_LBA_OUT_OF_RANGE\t\t0x21\n#define SENCODE_INVALID_CDB_FIELD\t\t0x24\n#define SENCODE_LUN_NOT_SUPPORTED\t\t0x25\n#define SENCODE_INVALID_PARAM_FIELD\t\t0x26\n#define SENCODE_PARAM_NOT_SUPPORTED\t\t0x26\n#define SENCODE_PARAM_VALUE_INVALID\t\t0x26\n#define SENCODE_RESET_OCCURRED\t\t\t0x29\n#define SENCODE_LUN_NOT_SELF_CONFIGURED_YET\t0x3E\n#define SENCODE_INQUIRY_DATA_CHANGED\t\t0x3F\n#define SENCODE_SAVING_PARAMS_NOT_SUPPORTED\t0x39\n#define SENCODE_DIAGNOSTIC_FAILURE\t\t0x40\n#define SENCODE_INTERNAL_TARGET_FAILURE\t\t0x44\n#define SENCODE_INVALID_MESSAGE_ERROR\t\t0x49\n#define SENCODE_LUN_FAILED_SELF_CONFIG\t\t0x4c\n#define SENCODE_OVERLAPPED_COMMAND\t\t0x4E\n\n \n\n#define ASENCODE_NO_SENSE\t\t\t0x00\n#define ASENCODE_END_OF_DATA\t\t\t0x05\n#define ASENCODE_BECOMING_READY\t\t\t0x01\n#define ASENCODE_INIT_CMD_REQUIRED\t\t0x02\n#define ASENCODE_PARAM_LIST_LENGTH_ERROR\t0x00\n#define ASENCODE_INVALID_COMMAND\t\t0x00\n#define ASENCODE_LBA_OUT_OF_RANGE\t\t0x00\n#define ASENCODE_INVALID_CDB_FIELD\t\t0x00\n#define ASENCODE_LUN_NOT_SUPPORTED\t\t0x00\n#define ASENCODE_INVALID_PARAM_FIELD\t\t0x00\n#define ASENCODE_PARAM_NOT_SUPPORTED\t\t0x01\n#define ASENCODE_PARAM_VALUE_INVALID\t\t0x02\n#define ASENCODE_RESET_OCCURRED\t\t\t0x00\n#define ASENCODE_LUN_NOT_SELF_CONFIGURED_YET\t0x00\n#define ASENCODE_INQUIRY_DATA_CHANGED\t\t0x03\n#define ASENCODE_SAVING_PARAMS_NOT_SUPPORTED\t0x00\n#define ASENCODE_DIAGNOSTIC_FAILURE\t\t0x80\n#define ASENCODE_INTERNAL_TARGET_FAILURE\t0x00\n#define ASENCODE_INVALID_MESSAGE_ERROR\t\t0x00\n#define ASENCODE_LUN_FAILED_SELF_CONFIG\t\t0x00\n#define ASENCODE_OVERLAPPED_COMMAND\t\t0x00\n\n#define BYTE0(x) (unsigned char)(x)\n#define BYTE1(x) (unsigned char)((x) >> 8)\n#define BYTE2(x) (unsigned char)((x) >> 16)\n#define BYTE3(x) (unsigned char)((x) >> 24)\n\n \ntypedef struct {\n\tstruct {\n\t\tu8\tdata_length;\n\t\tu8\tmed_type;\n\t\tu8\tdev_par;\n\t\tu8\tbd_length;\n\t} __attribute__((packed)) hd;\n\tstruct {\n\t\tu8\tdens_code;\n\t\tu8\tblock_count[3];\n\t\tu8\treserved;\n\t\tu8\tblock_length[3];\n\t} __attribute__((packed)) bd;\n\t\tu8\tmpc_buf[3];\n} __attribute__((packed)) aac_modep_data;\n\n \ntypedef struct {\n\tstruct {\n\t\tu8\tdata_length[2];\n\t\tu8\tmed_type;\n\t\tu8\tdev_par;\n\t\tu8\trsrvd[2];\n\t\tu8\tbd_length[2];\n\t} __attribute__((packed)) hd;\n\tstruct {\n\t\tu8\tdens_code;\n\t\tu8\tblock_count[3];\n\t\tu8\treserved;\n\t\tu8\tblock_length[3];\n\t} __attribute__((packed)) bd;\n\t\tu8\tmpc_buf[3];\n} __attribute__((packed)) aac_modep10_data;\n\n \n \nstruct inquiry_data {\n\tu8 inqd_pdt;\t \n\tu8 inqd_dtq;\t \n\tu8 inqd_ver;\t \n\tu8 inqd_rdf;\t \n\tu8 inqd_len;\t \n\tu8 inqd_pad1[2]; \n\tu8 inqd_pad2;\t \n\tu8 inqd_vid[8];\t \n\tu8 inqd_pid[16]; \n\tu8 inqd_prl[4];\t \n};\n\n \nstruct  tvpd_id_descriptor_type_1 {\n\tu8 codeset:4;\t\t \n\tu8 reserved:4;\n\tu8 identifiertype:4;\t \n\tu8 reserved2:4;\n\tu8 reserved3;\n\tu8 identifierlength;\n\tu8 venid[8];\n\tu8 productid[16];\n\tu8 serialnumber[8];\t \n\n};\n\nstruct tvpd_id_descriptor_type_2 {\n\tu8 codeset:4;\t\t \n\tu8 reserved:4;\n\tu8 identifiertype:4;\t \n\tu8 reserved2:4;\n\tu8 reserved3;\n\tu8 identifierlength;\n\tstruct teu64id {\n\t\tu32 Serial;\n\t\t  \n\t\tu8 reserved;\n\t\tu8 venid[3];\n\t} eu64id;\n\n};\n\nstruct tvpd_id_descriptor_type_3 {\n\tu8 codeset : 4;           \n\tu8 reserved : 4;\n\tu8 identifiertype : 4;    \n\tu8 reserved2 : 4;\n\tu8 reserved3;\n\tu8 identifierlength;\n\tu8 Identifier[16];\n};\n\nstruct tvpd_page83 {\n\tu8 DeviceType:5;\n\tu8 DeviceTypeQualifier:3;\n\tu8 PageCode;\n\tu8 reserved;\n\tu8 PageLength;\n\tstruct tvpd_id_descriptor_type_1 type1;\n\tstruct tvpd_id_descriptor_type_2 type2;\n\tstruct tvpd_id_descriptor_type_3 type3;\n};\n\n \n\nstatic long aac_build_sg(struct scsi_cmnd *scsicmd, struct sgmap *sgmap);\nstatic long aac_build_sg64(struct scsi_cmnd *scsicmd, struct sgmap64 *psg);\nstatic long aac_build_sgraw(struct scsi_cmnd *scsicmd, struct sgmapraw *psg);\nstatic long aac_build_sgraw2(struct scsi_cmnd *scsicmd,\n\t\t\t\tstruct aac_raw_io2 *rio2, int sg_max);\nstatic long aac_build_sghba(struct scsi_cmnd *scsicmd,\n\t\t\t\tstruct aac_hba_cmd_req *hbacmd,\n\t\t\t\tint sg_max, u64 sg_address);\nstatic int aac_convert_sgraw2(struct aac_raw_io2 *rio2,\n\t\t\t\tint pages, int nseg, int nseg_new);\nstatic void aac_probe_container_scsi_done(struct scsi_cmnd *scsi_cmnd);\nstatic int aac_send_srb_fib(struct scsi_cmnd* scsicmd);\nstatic int aac_send_hba_fib(struct scsi_cmnd *scsicmd);\n#ifdef AAC_DETAILED_STATUS_INFO\nstatic char *aac_get_status_string(u32 status);\n#endif\n\n \n\nstatic int nondasd = -1;\nstatic int aac_cache = 2;\t \nstatic int dacmode = -1;\nint aac_msi;\nint aac_commit = -1;\nint startup_timeout = 180;\nint aif_timeout = 120;\nint aac_sync_mode;   \nstatic int aac_convert_sgl = 1;\t \n\nmodule_param(aac_sync_mode, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(aac_sync_mode, \"Force sync. transfer mode\"\n\t\" 0=off, 1=on\");\nmodule_param(aac_convert_sgl, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(aac_convert_sgl, \"Convert non-conformable s/g list\"\n\t\" 0=off, 1=on\");\nmodule_param(nondasd, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(nondasd, \"Control scanning of hba for nondasd devices.\"\n\t\" 0=off, 1=on\");\nmodule_param_named(cache, aac_cache, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(cache, \"Disable Queue Flush commands:\\n\"\n\t\"\\tbit 0 - Disable FUA in WRITE SCSI commands\\n\"\n\t\"\\tbit 1 - Disable SYNCHRONIZE_CACHE SCSI command\\n\"\n\t\"\\tbit 2 - Disable only if Battery is protecting Cache\");\nmodule_param(dacmode, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(dacmode, \"Control whether dma addressing is using 64 bit DAC.\"\n\t\" 0=off, 1=on\");\nmodule_param_named(commit, aac_commit, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(commit, \"Control whether a COMMIT_CONFIG is issued to the\"\n\t\" adapter for foreign arrays.\\n\"\n\t\"This is typically needed in systems that do not have a BIOS.\"\n\t\" 0=off, 1=on\");\nmodule_param_named(msi, aac_msi, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(msi, \"IRQ handling.\"\n\t\" 0=PIC(default), 1=MSI, 2=MSI-X)\");\nmodule_param(startup_timeout, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(startup_timeout, \"The duration of time in seconds to wait for\"\n\t\" adapter to have its kernel up and\\n\"\n\t\"running. This is typically adjusted for large systems that do not\"\n\t\" have a BIOS.\");\nmodule_param(aif_timeout, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(aif_timeout, \"The duration of time in seconds to wait for\"\n\t\" applications to pick up AIFs before\\n\"\n\t\"deregistering them. This is typically adjusted for heavily burdened\"\n\t\" systems.\");\n\nint aac_fib_dump;\nmodule_param(aac_fib_dump, int, 0644);\nMODULE_PARM_DESC(aac_fib_dump, \"Dump controller fibs prior to IOP_RESET 0=off, 1=on\");\n\nint numacb = -1;\nmodule_param(numacb, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(numacb, \"Request a limit to the number of adapter control\"\n\t\" blocks (FIB) allocated. Valid values are 512 and down. Default is\"\n\t\" to use suggestion from Firmware.\");\n\nstatic int acbsize = -1;\nmodule_param(acbsize, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(acbsize, \"Request a specific adapter control block (FIB)\"\n\t\" size. Valid values are 512, 2048, 4096 and 8192. Default is to use\"\n\t\" suggestion from Firmware.\");\n\nint update_interval = 30 * 60;\nmodule_param(update_interval, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(update_interval, \"Interval in seconds between time sync\"\n\t\" updates issued to adapter.\");\n\nint check_interval = 60;\nmodule_param(check_interval, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(check_interval, \"Interval in seconds between adapter health\"\n\t\" checks.\");\n\nint aac_check_reset = 1;\nmodule_param_named(check_reset, aac_check_reset, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(check_reset, \"If adapter fails health check, reset the\"\n\t\" adapter. a value of -1 forces the reset to adapters programmed to\"\n\t\" ignore it.\");\n\nint expose_physicals = -1;\nmodule_param(expose_physicals, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(expose_physicals, \"Expose physical components of the arrays.\"\n\t\" -1=protect 0=off, 1=on\");\n\nint aac_reset_devices;\nmodule_param_named(reset_devices, aac_reset_devices, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(reset_devices, \"Force an adapter reset at initialization.\");\n\nstatic int aac_wwn = 1;\nmodule_param_named(wwn, aac_wwn, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(wwn, \"Select a WWN type for the arrays:\\n\"\n\t\"\\t0 - Disable\\n\"\n\t\"\\t1 - Array Meta Data Signature (default)\\n\"\n\t\"\\t2 - Adapter Serial Number\");\n\n\nstatic inline int aac_valid_context(struct scsi_cmnd *scsicmd,\n\t\tstruct fib *fibptr) {\n\tstruct scsi_device *device;\n\n\tif (unlikely(!scsicmd)) {\n\t\tdprintk((KERN_WARNING \"aac_valid_context: scsi command corrupt\\n\"));\n\t\taac_fib_complete(fibptr);\n\t\treturn 0;\n\t}\n\taac_priv(scsicmd)->owner = AAC_OWNER_MIDLEVEL;\n\tdevice = scsicmd->device;\n\tif (unlikely(!device)) {\n\t\tdprintk((KERN_WARNING \"aac_valid_context: scsi device corrupt\\n\"));\n\t\taac_fib_complete(fibptr);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nint aac_get_config_status(struct aac_dev *dev, int commit_flag)\n{\n\tint status = 0;\n\tstruct fib * fibptr;\n\n\tif (!(fibptr = aac_fib_alloc(dev)))\n\t\treturn -ENOMEM;\n\n\taac_fib_init(fibptr);\n\t{\n\t\tstruct aac_get_config_status *dinfo;\n\t\tdinfo = (struct aac_get_config_status *) fib_data(fibptr);\n\n\t\tdinfo->command = cpu_to_le32(VM_ContainerConfig);\n\t\tdinfo->type = cpu_to_le32(CT_GET_CONFIG_STATUS);\n\t\tdinfo->count = cpu_to_le32(sizeof(((struct aac_get_config_status_resp *)NULL)->data));\n\t}\n\n\tstatus = aac_fib_send(ContainerCommand,\n\t\t\t    fibptr,\n\t\t\t    sizeof (struct aac_get_config_status),\n\t\t\t    FsaNormal,\n\t\t\t    1, 1,\n\t\t\t    NULL, NULL);\n\tif (status < 0) {\n\t\tprintk(KERN_WARNING \"aac_get_config_status: SendFIB failed.\\n\");\n\t} else {\n\t\tstruct aac_get_config_status_resp *reply\n\t\t  = (struct aac_get_config_status_resp *) fib_data(fibptr);\n\t\tdprintk((KERN_WARNING\n\t\t  \"aac_get_config_status: response=%d status=%d action=%d\\n\",\n\t\t  le32_to_cpu(reply->response),\n\t\t  le32_to_cpu(reply->status),\n\t\t  le32_to_cpu(reply->data.action)));\n\t\tif ((le32_to_cpu(reply->response) != ST_OK) ||\n\t\t     (le32_to_cpu(reply->status) != CT_OK) ||\n\t\t     (le32_to_cpu(reply->data.action) > CFACT_PAUSE)) {\n\t\t\tprintk(KERN_WARNING \"aac_get_config_status: Will not issue the Commit Configuration\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t}\n\t \n\tif (status >= 0)\n\t\taac_fib_complete(fibptr);\n\n\t \n\tif (status >= 0) {\n\t\tif ((aac_commit == 1) || commit_flag) {\n\t\t\tstruct aac_commit_config * dinfo;\n\t\t\taac_fib_init(fibptr);\n\t\t\tdinfo = (struct aac_commit_config *) fib_data(fibptr);\n\n\t\t\tdinfo->command = cpu_to_le32(VM_ContainerConfig);\n\t\t\tdinfo->type = cpu_to_le32(CT_COMMIT_CONFIG);\n\n\t\t\tstatus = aac_fib_send(ContainerCommand,\n\t\t\t\t    fibptr,\n\t\t\t\t    sizeof (struct aac_commit_config),\n\t\t\t\t    FsaNormal,\n\t\t\t\t    1, 1,\n\t\t\t\t    NULL, NULL);\n\t\t\t \n\t\t\tif (status >= 0)\n\t\t\t\taac_fib_complete(fibptr);\n\t\t} else if (aac_commit == 0) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t  \"aac_get_config_status: Foreign device configurations are being ignored\\n\");\n\t\t}\n\t}\n\t \n\tif (status != -ERESTARTSYS)\n\t\taac_fib_free(fibptr);\n\treturn status;\n}\n\nstatic void aac_expose_phy_device(struct scsi_cmnd *scsicmd)\n{\n\tchar inq_data;\n\tscsi_sg_copy_to_buffer(scsicmd,  &inq_data, sizeof(inq_data));\n\tif ((inq_data & 0x20) && (inq_data & 0x1f) == TYPE_DISK) {\n\t\tinq_data &= 0xdf;\n\t\tscsi_sg_copy_from_buffer(scsicmd, &inq_data, sizeof(inq_data));\n\t}\n}\n\n \nint aac_get_containers(struct aac_dev *dev)\n{\n\tstruct fsa_dev_info *fsa_dev_ptr;\n\tu32 index;\n\tint status = 0;\n\tstruct fib * fibptr;\n\tstruct aac_get_container_count *dinfo;\n\tstruct aac_get_container_count_resp *dresp;\n\tint maximum_num_containers = MAXIMUM_NUM_CONTAINERS;\n\n\tif (!(fibptr = aac_fib_alloc(dev)))\n\t\treturn -ENOMEM;\n\n\taac_fib_init(fibptr);\n\tdinfo = (struct aac_get_container_count *) fib_data(fibptr);\n\tdinfo->command = cpu_to_le32(VM_ContainerConfig);\n\tdinfo->type = cpu_to_le32(CT_GET_CONTAINER_COUNT);\n\n\tstatus = aac_fib_send(ContainerCommand,\n\t\t    fibptr,\n\t\t    sizeof (struct aac_get_container_count),\n\t\t    FsaNormal,\n\t\t    1, 1,\n\t\t    NULL, NULL);\n\tif (status >= 0) {\n\t\tdresp = (struct aac_get_container_count_resp *)fib_data(fibptr);\n\t\tmaximum_num_containers = le32_to_cpu(dresp->ContainerSwitchEntries);\n\t\tif (fibptr->dev->supplement_adapter_info.supported_options2 &\n\t\t    AAC_OPTION_SUPPORTED_240_VOLUMES) {\n\t\t\tmaximum_num_containers =\n\t\t\t\tle32_to_cpu(dresp->MaxSimpleVolumes);\n\t\t}\n\t\taac_fib_complete(fibptr);\n\t}\n\t \n\tif (status != -ERESTARTSYS)\n\t\taac_fib_free(fibptr);\n\n\tif (maximum_num_containers < MAXIMUM_NUM_CONTAINERS)\n\t\tmaximum_num_containers = MAXIMUM_NUM_CONTAINERS;\n\tif (dev->fsa_dev == NULL ||\n\t\tdev->maximum_num_containers != maximum_num_containers) {\n\n\t\tfsa_dev_ptr = dev->fsa_dev;\n\n\t\tdev->fsa_dev = kcalloc(maximum_num_containers,\n\t\t\t\t\tsizeof(*fsa_dev_ptr), GFP_KERNEL);\n\n\t\tkfree(fsa_dev_ptr);\n\t\tfsa_dev_ptr = NULL;\n\n\n\t\tif (!dev->fsa_dev)\n\t\t\treturn -ENOMEM;\n\n\t\tdev->maximum_num_containers = maximum_num_containers;\n\t}\n\tfor (index = 0; index < dev->maximum_num_containers; index++) {\n\t\tdev->fsa_dev[index].devname[0] = '\\0';\n\t\tdev->fsa_dev[index].valid = 0;\n\n\t\tstatus = aac_probe_container(dev, index);\n\n\t\tif (status < 0) {\n\t\t\tprintk(KERN_WARNING \"aac_get_containers: SendFIB failed.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn status;\n}\n\nstatic void aac_scsi_done(struct scsi_cmnd *scmd)\n{\n\tif (scmd->device->request_queue) {\n\t\t \n\t\tscsi_done(scmd);\n\t} else {\n\t\t \n\t\taac_probe_container_scsi_done(scmd);\n\t}\n}\n\nstatic void get_container_name_callback(void *context, struct fib * fibptr)\n{\n\tstruct aac_get_name_resp * get_name_reply;\n\tstruct scsi_cmnd * scsicmd;\n\n\tscsicmd = (struct scsi_cmnd *) context;\n\n\tif (!aac_valid_context(scsicmd, fibptr))\n\t\treturn;\n\n\tdprintk((KERN_DEBUG \"get_container_name_callback[cpu %d]: t = %ld.\\n\", smp_processor_id(), jiffies));\n\tBUG_ON(fibptr == NULL);\n\n\tget_name_reply = (struct aac_get_name_resp *) fib_data(fibptr);\n\t \n\tif ((le32_to_cpu(get_name_reply->status) == CT_OK)\n\t && (get_name_reply->data[0] != '\\0')) {\n\t\tchar *sp = get_name_reply->data;\n\t\tint data_size = sizeof_field(struct aac_get_name_resp, data);\n\n\t\tsp[data_size - 1] = '\\0';\n\t\twhile (*sp == ' ')\n\t\t\t++sp;\n\t\tif (*sp) {\n\t\t\tstruct inquiry_data inq;\n\t\t\tchar d[sizeof(((struct inquiry_data *)NULL)->inqd_pid)];\n\t\t\tint count = sizeof(d);\n\t\t\tchar *dp = d;\n\t\t\tdo {\n\t\t\t\t*dp++ = (*sp) ? *sp++ : ' ';\n\t\t\t} while (--count > 0);\n\n\t\t\tscsi_sg_copy_to_buffer(scsicmd, &inq, sizeof(inq));\n\t\t\tmemcpy(inq.inqd_pid, d, sizeof(d));\n\t\t\tscsi_sg_copy_from_buffer(scsicmd, &inq, sizeof(inq));\n\t\t}\n\t}\n\n\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\n\taac_fib_complete(fibptr);\n\taac_scsi_done(scsicmd);\n}\n\n \nstatic int aac_get_container_name(struct scsi_cmnd * scsicmd)\n{\n\tint status;\n\tint data_size;\n\tstruct aac_get_name *dinfo;\n\tstruct fib * cmd_fibcontext;\n\tstruct aac_dev * dev;\n\n\tdev = (struct aac_dev *)scsicmd->device->host->hostdata;\n\n\tdata_size = sizeof_field(struct aac_get_name_resp, data);\n\n\tcmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);\n\n\taac_fib_init(cmd_fibcontext);\n\tdinfo = (struct aac_get_name *) fib_data(cmd_fibcontext);\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\n\tdinfo->command = cpu_to_le32(VM_ContainerConfig);\n\tdinfo->type = cpu_to_le32(CT_READ_NAME);\n\tdinfo->cid = cpu_to_le32(scmd_id(scsicmd));\n\tdinfo->count = cpu_to_le32(data_size - 1);\n\n\tstatus = aac_fib_send(ContainerCommand,\n\t\t  cmd_fibcontext,\n\t\t  sizeof(struct aac_get_name_resp),\n\t\t  FsaNormal,\n\t\t  0, 1,\n\t\t  (fib_callback)get_container_name_callback,\n\t\t  (void *) scsicmd);\n\n\t \n\tif (status == -EINPROGRESS)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"aac_get_container_name: aac_fib_send failed with status: %d.\\n\", status);\n\taac_fib_complete(cmd_fibcontext);\n\treturn -1;\n}\n\nstatic int aac_probe_container_callback2(struct scsi_cmnd * scsicmd)\n{\n\tstruct fsa_dev_info *fsa_dev_ptr = ((struct aac_dev *)(scsicmd->device->host->hostdata))->fsa_dev;\n\n\tif ((fsa_dev_ptr[scmd_id(scsicmd)].valid & 1))\n\t\treturn aac_scsi_cmd(scsicmd);\n\n\tscsicmd->result = DID_NO_CONNECT << 16;\n\taac_scsi_done(scsicmd);\n\treturn 0;\n}\n\nstatic void _aac_probe_container2(void * context, struct fib * fibptr)\n{\n\tstruct fsa_dev_info *fsa_dev_ptr;\n\tint (*callback)(struct scsi_cmnd *);\n\tstruct scsi_cmnd *scsicmd = context;\n\tstruct aac_cmd_priv *cmd_priv = aac_priv(scsicmd);\n\tint i;\n\n\n\tif (!aac_valid_context(scsicmd, fibptr))\n\t\treturn;\n\n\tcmd_priv->status = 0;\n\tfsa_dev_ptr = fibptr->dev->fsa_dev;\n\tif (fsa_dev_ptr) {\n\t\tstruct aac_mount * dresp = (struct aac_mount *) fib_data(fibptr);\n\t\t__le32 sup_options2;\n\n\t\tfsa_dev_ptr += scmd_id(scsicmd);\n\t\tsup_options2 =\n\t\t\tfibptr->dev->supplement_adapter_info.supported_options2;\n\n\t\tif ((le32_to_cpu(dresp->status) == ST_OK) &&\n\t\t    (le32_to_cpu(dresp->mnt[0].vol) != CT_NONE) &&\n\t\t    (le32_to_cpu(dresp->mnt[0].state) != FSCS_HIDDEN)) {\n\t\t\tif (!(sup_options2 & AAC_OPTION_VARIABLE_BLOCK_SIZE)) {\n\t\t\t\tdresp->mnt[0].fileinfo.bdevinfo.block_size = 0x200;\n\t\t\t\tfsa_dev_ptr->block_size = 0x200;\n\t\t\t} else {\n\t\t\t\tfsa_dev_ptr->block_size =\n\t\t\t\t\tle32_to_cpu(dresp->mnt[0].fileinfo.bdevinfo.block_size);\n\t\t\t}\n\t\t\tfor (i = 0; i < 16; i++)\n\t\t\t\tfsa_dev_ptr->identifier[i] =\n\t\t\t\t\tdresp->mnt[0].fileinfo.bdevinfo\n\t\t\t\t\t\t\t\t.identifier[i];\n\t\t\tfsa_dev_ptr->valid = 1;\n\t\t\t \n\t\t\tif (dresp->mnt[0].state & cpu_to_le32(FSCS_NOT_READY))\n\t\t\t\tfsa_dev_ptr->sense_data.sense_key = NOT_READY;\n\t\t\telse if (fsa_dev_ptr->sense_data.sense_key == NOT_READY)\n\t\t\t\tfsa_dev_ptr->sense_data.sense_key = NO_SENSE;\n\t\t\tfsa_dev_ptr->type = le32_to_cpu(dresp->mnt[0].vol);\n\t\t\tfsa_dev_ptr->size\n\t\t\t  = ((u64)le32_to_cpu(dresp->mnt[0].capacity)) +\n\t\t\t    (((u64)le32_to_cpu(dresp->mnt[0].capacityhigh)) << 32);\n\t\t\tfsa_dev_ptr->ro = ((le32_to_cpu(dresp->mnt[0].state) & FSCS_READONLY) != 0);\n\t\t}\n\t\tif ((fsa_dev_ptr->valid & 1) == 0)\n\t\t\tfsa_dev_ptr->valid = 0;\n\t\tcmd_priv->status = le32_to_cpu(dresp->count);\n\t}\n\taac_fib_complete(fibptr);\n\taac_fib_free(fibptr);\n\tcallback = cmd_priv->callback;\n\tcmd_priv->callback = NULL;\n\t(*callback)(scsicmd);\n\treturn;\n}\n\nstatic void _aac_probe_container1(void * context, struct fib * fibptr)\n{\n\tstruct scsi_cmnd * scsicmd;\n\tstruct aac_mount * dresp;\n\tstruct aac_query_mount *dinfo;\n\tint status;\n\n\tdresp = (struct aac_mount *) fib_data(fibptr);\n\tif (!aac_supports_2T(fibptr->dev)) {\n\t\tdresp->mnt[0].capacityhigh = 0;\n\t\tif ((le32_to_cpu(dresp->status) == ST_OK) &&\n\t\t\t(le32_to_cpu(dresp->mnt[0].vol) != CT_NONE)) {\n\t\t\t_aac_probe_container2(context, fibptr);\n\t\t\treturn;\n\t\t}\n\t}\n\tscsicmd = (struct scsi_cmnd *) context;\n\n\tif (!aac_valid_context(scsicmd, fibptr))\n\t\treturn;\n\n\taac_fib_init(fibptr);\n\n\tdinfo = (struct aac_query_mount *)fib_data(fibptr);\n\n\tif (fibptr->dev->supplement_adapter_info.supported_options2 &\n\t    AAC_OPTION_VARIABLE_BLOCK_SIZE)\n\t\tdinfo->command = cpu_to_le32(VM_NameServeAllBlk);\n\telse\n\t\tdinfo->command = cpu_to_le32(VM_NameServe64);\n\n\tdinfo->count = cpu_to_le32(scmd_id(scsicmd));\n\tdinfo->type = cpu_to_le32(FT_FILESYS);\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\n\tstatus = aac_fib_send(ContainerCommand,\n\t\t\t  fibptr,\n\t\t\t  sizeof(struct aac_query_mount),\n\t\t\t  FsaNormal,\n\t\t\t  0, 1,\n\t\t\t  _aac_probe_container2,\n\t\t\t  (void *) scsicmd);\n\t \n\tif (status < 0 && status != -EINPROGRESS) {\n\t\t \n\t\tdresp->status = cpu_to_le32(ST_OK);\n\t\t_aac_probe_container2(context, fibptr);\n\t}\n}\n\nstatic int _aac_probe_container(struct scsi_cmnd * scsicmd, int (*callback)(struct scsi_cmnd *))\n{\n\tstruct aac_cmd_priv *cmd_priv = aac_priv(scsicmd);\n\tstruct fib * fibptr;\n\tint status = -ENOMEM;\n\n\tif ((fibptr = aac_fib_alloc((struct aac_dev *)scsicmd->device->host->hostdata))) {\n\t\tstruct aac_query_mount *dinfo;\n\n\t\taac_fib_init(fibptr);\n\n\t\tdinfo = (struct aac_query_mount *)fib_data(fibptr);\n\n\t\tif (fibptr->dev->supplement_adapter_info.supported_options2 &\n\t\t    AAC_OPTION_VARIABLE_BLOCK_SIZE)\n\t\t\tdinfo->command = cpu_to_le32(VM_NameServeAllBlk);\n\t\telse\n\t\t\tdinfo->command = cpu_to_le32(VM_NameServe);\n\n\t\tdinfo->count = cpu_to_le32(scmd_id(scsicmd));\n\t\tdinfo->type = cpu_to_le32(FT_FILESYS);\n\t\tcmd_priv->callback = callback;\n\t\tcmd_priv->owner = AAC_OWNER_FIRMWARE;\n\n\t\tstatus = aac_fib_send(ContainerCommand,\n\t\t\t  fibptr,\n\t\t\t  sizeof(struct aac_query_mount),\n\t\t\t  FsaNormal,\n\t\t\t  0, 1,\n\t\t\t  _aac_probe_container1,\n\t\t\t  (void *) scsicmd);\n\t\t \n\t\tif (status == -EINPROGRESS)\n\t\t\treturn 0;\n\n\t\tif (status < 0) {\n\t\t\tcmd_priv->callback = NULL;\n\t\t\taac_fib_complete(fibptr);\n\t\t\taac_fib_free(fibptr);\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tstruct fsa_dev_info *fsa_dev_ptr = ((struct aac_dev *)(scsicmd->device->host->hostdata))->fsa_dev;\n\t\tif (fsa_dev_ptr) {\n\t\t\tfsa_dev_ptr += scmd_id(scsicmd);\n\t\t\tif ((fsa_dev_ptr->valid & 1) == 0) {\n\t\t\t\tfsa_dev_ptr->valid = 0;\n\t\t\t\treturn (*callback)(scsicmd);\n\t\t\t}\n\t\t}\n\t}\n\treturn status;\n}\n\n \nstatic int aac_probe_container_callback1(struct scsi_cmnd * scsicmd)\n{\n\tscsicmd->device = NULL;\n\treturn 0;\n}\n\nstatic void aac_probe_container_scsi_done(struct scsi_cmnd *scsi_cmnd)\n{\n\taac_probe_container_callback1(scsi_cmnd);\n}\n\nint aac_probe_container(struct aac_dev *dev, int cid)\n{\n\tstruct aac_cmd_priv *cmd_priv;\n\tstruct scsi_cmnd *scsicmd = kzalloc(sizeof(*scsicmd) + sizeof(*cmd_priv), GFP_KERNEL);\n\tstruct scsi_device *scsidev = kzalloc(sizeof(*scsidev), GFP_KERNEL);\n\tint status;\n\n\tif (!scsicmd || !scsidev) {\n\t\tkfree(scsicmd);\n\t\tkfree(scsidev);\n\t\treturn -ENOMEM;\n\t}\n\n\tscsicmd->device = scsidev;\n\tscsidev->sdev_state = 0;\n\tscsidev->id = cid;\n\tscsidev->host = dev->scsi_host_ptr;\n\n\tif (_aac_probe_container(scsicmd, aac_probe_container_callback1) == 0)\n\t\twhile (scsicmd->device == scsidev)\n\t\t\tschedule();\n\tkfree(scsidev);\n\tcmd_priv = aac_priv(scsicmd);\n\tstatus = cmd_priv->status;\n\tkfree(scsicmd);\n\treturn status;\n}\n\n \nstruct scsi_inq {\n\tchar vid[8];          \n\tchar pid[16];         \n\tchar prl[4];          \n};\n\n \n\nstatic void inqstrcpy(char *a, char *b)\n{\n\n\twhile (*a != (char)0)\n\t\t*b++ = *a++;\n}\n\nstatic char *container_types[] = {\n\t\"None\",\n\t\"Volume\",\n\t\"Mirror\",\n\t\"Stripe\",\n\t\"RAID5\",\n\t\"SSRW\",\n\t\"SSRO\",\n\t\"Morph\",\n\t\"Legacy\",\n\t\"RAID4\",\n\t\"RAID10\",\n\t\"RAID00\",\n\t\"V-MIRRORS\",\n\t\"PSEUDO R4\",\n\t\"RAID50\",\n\t\"RAID5D\",\n\t\"RAID5D0\",\n\t\"RAID1E\",\n\t\"RAID6\",\n\t\"RAID60\",\n\t\"Unknown\"\n};\n\nchar * get_container_type(unsigned tindex)\n{\n\tif (tindex >= ARRAY_SIZE(container_types))\n\t\ttindex = ARRAY_SIZE(container_types) - 1;\n\treturn container_types[tindex];\n}\n\n \n\nstatic void setinqstr(struct aac_dev *dev, void *data, int tindex)\n{\n\tstruct scsi_inq *str;\n\tstruct aac_supplement_adapter_info *sup_adap_info;\n\n\tsup_adap_info = &dev->supplement_adapter_info;\n\tstr = (struct scsi_inq *)(data);  \n\tmemset(str, ' ', sizeof(*str));\n\n\tif (sup_adap_info->adapter_type_text[0]) {\n\t\tint c;\n\t\tchar *cp;\n\t\tchar *cname = kmemdup(sup_adap_info->adapter_type_text,\n\t\t\t\tsizeof(sup_adap_info->adapter_type_text),\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!cname)\n\t\t\treturn;\n\n\t\tcp = cname;\n\t\tif ((cp[0] == 'A') && (cp[1] == 'O') && (cp[2] == 'C'))\n\t\t\tinqstrcpy(\"SMC\", str->vid);\n\t\telse {\n\t\t\tc = sizeof(str->vid);\n\t\t\twhile (*cp && *cp != ' ' && --c)\n\t\t\t\t++cp;\n\t\t\tc = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tinqstrcpy(cname, str->vid);\n\t\t\t*cp = c;\n\t\t\twhile (*cp && *cp != ' ')\n\t\t\t\t++cp;\n\t\t}\n\t\twhile (*cp == ' ')\n\t\t\t++cp;\n\t\t \n\t\tif (strlen(cp) > sizeof(str->pid))\n\t\t\tcp[sizeof(str->pid)] = '\\0';\n\t\tinqstrcpy (cp, str->pid);\n\n\t\tkfree(cname);\n\t} else {\n\t\tstruct aac_driver_ident *mp = aac_get_driver_ident(dev->cardtype);\n\n\t\tinqstrcpy (mp->vname, str->vid);\n\t\t \n\t\tinqstrcpy (mp->model, str->pid);\n\t}\n\n\tif (tindex < ARRAY_SIZE(container_types)){\n\t\tchar *findit = str->pid;\n\n\t\tfor ( ; *findit != ' '; findit++);  \n\t\t \n\t\tif (memcmp(findit-4, \"RAID\", 4) == 0)\n\t\t\t*(findit -= 4) = ' ';\n\t\tif (((findit - str->pid) + strlen(container_types[tindex]))\n\t\t < (sizeof(str->pid) + sizeof(str->prl)))\n\t\t\tinqstrcpy (container_types[tindex], findit + 1);\n\t}\n\tinqstrcpy (\"V1.0\", str->prl);\n}\n\nstatic void build_vpd83_type3(struct tvpd_page83 *vpdpage83data,\n\t\tstruct aac_dev *dev, struct scsi_cmnd *scsicmd)\n{\n\tint container;\n\n\tvpdpage83data->type3.codeset = 1;\n\tvpdpage83data->type3.identifiertype = 3;\n\tvpdpage83data->type3.identifierlength = sizeof(vpdpage83data->type3)\n\t\t\t- 4;\n\n\tfor (container = 0; container < dev->maximum_num_containers;\n\t\t\tcontainer++) {\n\n\t\tif (scmd_id(scsicmd) == container) {\n\t\t\tmemcpy(vpdpage83data->type3.Identifier,\n\t\t\t\t\tdev->fsa_dev[container].identifier,\n\t\t\t\t\t16);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void get_container_serial_callback(void *context, struct fib * fibptr)\n{\n\tstruct aac_get_serial_resp * get_serial_reply;\n\tstruct scsi_cmnd * scsicmd;\n\n\tBUG_ON(fibptr == NULL);\n\n\tscsicmd = (struct scsi_cmnd *) context;\n\tif (!aac_valid_context(scsicmd, fibptr))\n\t\treturn;\n\n\tget_serial_reply = (struct aac_get_serial_resp *) fib_data(fibptr);\n\t \n\tif (le32_to_cpu(get_serial_reply->status) == CT_OK) {\n\t\t \n\t\tif (scsicmd->cmnd[2] == 0x83) {\n\t\t\t \n\t\t\tstruct aac_dev *dev;\n\t\t\tint i;\n\t\t\tstruct tvpd_page83 vpdpage83data;\n\n\t\t\tdev = (struct aac_dev *)scsicmd->device->host->hostdata;\n\n\t\t\tmemset(((u8 *)&vpdpage83data), 0,\n\t\t\t       sizeof(vpdpage83data));\n\n\t\t\t \n\t\t\tvpdpage83data.DeviceType = 0;\n\t\t\t \n\t\t\tvpdpage83data.DeviceTypeQualifier = 0;\n\t\t\t \n\t\t\tvpdpage83data.PageCode = 0x83;\n\t\t\tvpdpage83data.reserved = 0;\n\t\t\tvpdpage83data.PageLength =\n\t\t\t\tsizeof(vpdpage83data.type1) +\n\t\t\t\tsizeof(vpdpage83data.type2);\n\n\t\t\t \n\t\t\tif (dev->sa_firmware)\n\t\t\t\tvpdpage83data.PageLength +=\n\t\t\t\tsizeof(vpdpage83data.type3);\n\n\t\t\t \n\t\t\t \n\t\t\tvpdpage83data.type1.codeset = 2;\n\t\t\t \n\t\t\tvpdpage83data.type1.identifiertype = 1;\n\t\t\tvpdpage83data.type1.identifierlength =\n\t\t\t\tsizeof(vpdpage83data.type1) - 4;\n\n\t\t\t \n\t\t\tmemcpy(vpdpage83data.type1.venid,\n\t\t\t\t\"ADAPTEC \",\n\t\t\t\tsizeof(vpdpage83data.type1.venid));\n\t\t\tmemcpy(vpdpage83data.type1.productid,\n\t\t\t\t\"ARRAY           \",\n\t\t\t\tsizeof(\n\t\t\t\tvpdpage83data.type1.productid));\n\n\t\t\t \n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tu8 temp =\n\t\t\t\t\t(u8)((get_serial_reply->uid >> ((7 - i) * 4)) & 0xF);\n\t\t\t\tif (temp  > 0x9) {\n\t\t\t\t\tvpdpage83data.type1.serialnumber[i] =\n\t\t\t\t\t\t\t'A' + (temp - 0xA);\n\t\t\t\t} else {\n\t\t\t\t\tvpdpage83data.type1.serialnumber[i] =\n\t\t\t\t\t\t\t'0' + temp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tvpdpage83data.type2.codeset = 1;\n\t\t\t \n\t\t\tvpdpage83data.type2.identifiertype = 2;\n\t\t\tvpdpage83data.type2.identifierlength =\n\t\t\t\tsizeof(vpdpage83data.type2) - 4;\n\n\t\t\tvpdpage83data.type2.eu64id.venid[0] = 0xD0;\n\t\t\tvpdpage83data.type2.eu64id.venid[1] = 0;\n\t\t\tvpdpage83data.type2.eu64id.venid[2] = 0;\n\n\t\t\tvpdpage83data.type2.eu64id.Serial =\n\t\t\t\t\t\t\tget_serial_reply->uid;\n\t\t\tvpdpage83data.type2.eu64id.reserved = 0;\n\n\t\t\t \n\t\t\tif (dev->sa_firmware) {\n\t\t\t\tbuild_vpd83_type3(&vpdpage83data,\n\t\t\t\t\t\tdev, scsicmd);\n\t\t\t}\n\n\t\t\t \n\t\t\tscsi_sg_copy_from_buffer(scsicmd, &vpdpage83data,\n\t\t\t\t\t\t sizeof(vpdpage83data));\n\t\t} else {\n\t\t\t \n\t\t\tchar sp[13];\n\t\t\t \n\t\t\tsp[0] = INQD_PDT_DA;\n\t\t\tsp[1] = scsicmd->cmnd[2];\n\t\t\tsp[2] = 0;\n\t\t\tsp[3] = snprintf(sp+4, sizeof(sp)-4, \"%08X\",\n\t\t\t\tle32_to_cpu(get_serial_reply->uid));\n\t\t\tscsi_sg_copy_from_buffer(scsicmd, sp,\n\t\t\t\t\t\t sizeof(sp));\n\t\t}\n\t}\n\n\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\n\taac_fib_complete(fibptr);\n\taac_scsi_done(scsicmd);\n}\n\n \nstatic int aac_get_container_serial(struct scsi_cmnd * scsicmd)\n{\n\tint status;\n\tstruct aac_get_serial *dinfo;\n\tstruct fib * cmd_fibcontext;\n\tstruct aac_dev * dev;\n\n\tdev = (struct aac_dev *)scsicmd->device->host->hostdata;\n\n\tcmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);\n\n\taac_fib_init(cmd_fibcontext);\n\tdinfo = (struct aac_get_serial *) fib_data(cmd_fibcontext);\n\n\tdinfo->command = cpu_to_le32(VM_ContainerConfig);\n\tdinfo->type = cpu_to_le32(CT_CID_TO_32BITS_UID);\n\tdinfo->cid = cpu_to_le32(scmd_id(scsicmd));\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\n\tstatus = aac_fib_send(ContainerCommand,\n\t\t  cmd_fibcontext,\n\t\t  sizeof(struct aac_get_serial_resp),\n\t\t  FsaNormal,\n\t\t  0, 1,\n\t\t  (fib_callback) get_container_serial_callback,\n\t\t  (void *) scsicmd);\n\n\t \n\tif (status == -EINPROGRESS)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"aac_get_container_serial: aac_fib_send failed with status: %d.\\n\", status);\n\taac_fib_complete(cmd_fibcontext);\n\treturn -1;\n}\n\n \n\nstatic int setinqserial(struct aac_dev *dev, void *data, int cid)\n{\n\t \n\treturn snprintf((char *)(data), sizeof(struct scsi_inq) - 4, \"%08X%02X\",\n\t\t\tle32_to_cpu(dev->adapter_info.serial[0]), cid);\n}\n\nstatic inline void set_sense(struct sense_data *sense_data, u8 sense_key,\n\tu8 sense_code, u8 a_sense_code, u8 bit_pointer, u16 field_pointer)\n{\n\tu8 *sense_buf = (u8 *)sense_data;\n\t \n\tsense_buf[0] = 0x70;  \n\tsense_buf[1] = 0;\t \n\n\tsense_buf[2] = sense_key;\t \n\n\tsense_buf[12] = sense_code;\t \n\tsense_buf[13] = a_sense_code;\t \n\n\tif (sense_key == ILLEGAL_REQUEST) {\n\t\tsense_buf[7] = 10;\t \n\n\t\tsense_buf[15] = bit_pointer;\n\t\t \n\t\tif (sense_code == SENCODE_INVALID_CDB_FIELD)\n\t\t\tsense_buf[15] |= 0xc0; \n\t\t \n\t\tsense_buf[16] = field_pointer >> 8;\t \n\t\tsense_buf[17] = field_pointer;\t\t \n\t} else\n\t\tsense_buf[7] = 6;\t \n}\n\nstatic int aac_bounds_32(struct aac_dev * dev, struct scsi_cmnd * cmd, u64 lba)\n{\n\tif (lba & 0xffffffff00000000LL) {\n\t\tint cid = scmd_id(cmd);\n\t\tdprintk((KERN_DEBUG \"aacraid: Illegal lba\\n\"));\n\t\tcmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t  HARDWARE_ERROR, SENCODE_INTERNAL_TARGET_FAILURE,\n\t\t  ASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\n\t\tmemcpy(cmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t       min_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\taac_scsi_done(cmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int aac_bounds_64(struct aac_dev * dev, struct scsi_cmnd * cmd, u64 lba)\n{\n\treturn 0;\n}\n\nstatic void io_callback(void *context, struct fib * fibptr);\n\nstatic int aac_read_raw_io(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count)\n{\n\tstruct aac_dev *dev = fib->dev;\n\tu16 fibsize, command;\n\tlong ret;\n\n\taac_fib_init(fib);\n\tif ((dev->comm_interface == AAC_COMM_MESSAGE_TYPE2 ||\n\t\tdev->comm_interface == AAC_COMM_MESSAGE_TYPE3) &&\n\t\t!dev->sync_mode) {\n\t\tstruct aac_raw_io2 *readcmd2;\n\t\treadcmd2 = (struct aac_raw_io2 *) fib_data(fib);\n\t\tmemset(readcmd2, 0, sizeof(struct aac_raw_io2));\n\t\treadcmd2->blockLow = cpu_to_le32((u32)(lba&0xffffffff));\n\t\treadcmd2->blockHigh = cpu_to_le32((u32)((lba&0xffffffff00000000LL)>>32));\n\t\treadcmd2->byteCount = cpu_to_le32(count *\n\t\t\tdev->fsa_dev[scmd_id(cmd)].block_size);\n\t\treadcmd2->cid = cpu_to_le16(scmd_id(cmd));\n\t\treadcmd2->flags = cpu_to_le16(RIO2_IO_TYPE_READ);\n\t\tret = aac_build_sgraw2(cmd, readcmd2,\n\t\t\t\tdev->scsi_host_ptr->sg_tablesize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcommand = ContainerRawIo2;\n\t\tfibsize = struct_size(readcmd2, sge,\n\t\t\t\t     le32_to_cpu(readcmd2->sgeCnt));\n\t} else {\n\t\tstruct aac_raw_io *readcmd;\n\t\treadcmd = (struct aac_raw_io *) fib_data(fib);\n\t\treadcmd->block[0] = cpu_to_le32((u32)(lba&0xffffffff));\n\t\treadcmd->block[1] = cpu_to_le32((u32)((lba&0xffffffff00000000LL)>>32));\n\t\treadcmd->count = cpu_to_le32(count *\n\t\t\tdev->fsa_dev[scmd_id(cmd)].block_size);\n\t\treadcmd->cid = cpu_to_le16(scmd_id(cmd));\n\t\treadcmd->flags = cpu_to_le16(RIO_TYPE_READ);\n\t\treadcmd->bpTotal = 0;\n\t\treadcmd->bpComplete = 0;\n\t\tret = aac_build_sgraw(cmd, &readcmd->sg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcommand = ContainerRawIo;\n\t\tfibsize = sizeof(struct aac_raw_io) +\n\t\t\t((le32_to_cpu(readcmd->sg.count)-1) * sizeof(struct sgentryraw));\n\t}\n\n\tBUG_ON(fibsize > (fib->dev->max_fib_size - sizeof(struct aac_fibhdr)));\n\t \n\treturn aac_fib_send(command,\n\t\t\t  fib,\n\t\t\t  fibsize,\n\t\t\t  FsaNormal,\n\t\t\t  0, 1,\n\t\t\t  (fib_callback) io_callback,\n\t\t\t  (void *) cmd);\n}\n\nstatic int aac_read_block64(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count)\n{\n\tu16 fibsize;\n\tstruct aac_read64 *readcmd;\n\tlong ret;\n\n\taac_fib_init(fib);\n\treadcmd = (struct aac_read64 *) fib_data(fib);\n\treadcmd->command = cpu_to_le32(VM_CtHostRead64);\n\treadcmd->cid = cpu_to_le16(scmd_id(cmd));\n\treadcmd->sector_count = cpu_to_le16(count);\n\treadcmd->block = cpu_to_le32((u32)(lba&0xffffffff));\n\treadcmd->pad   = 0;\n\treadcmd->flags = 0;\n\n\tret = aac_build_sg64(cmd, &readcmd->sg);\n\tif (ret < 0)\n\t\treturn ret;\n\tfibsize = sizeof(struct aac_read64) +\n\t\t((le32_to_cpu(readcmd->sg.count) - 1) *\n\t\t sizeof (struct sgentry64));\n\tBUG_ON (fibsize > (fib->dev->max_fib_size -\n\t\t\t\tsizeof(struct aac_fibhdr)));\n\t \n\treturn aac_fib_send(ContainerCommand64,\n\t\t\t  fib,\n\t\t\t  fibsize,\n\t\t\t  FsaNormal,\n\t\t\t  0, 1,\n\t\t\t  (fib_callback) io_callback,\n\t\t\t  (void *) cmd);\n}\n\nstatic int aac_read_block(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count)\n{\n\tu16 fibsize;\n\tstruct aac_read *readcmd;\n\tstruct aac_dev *dev = fib->dev;\n\tlong ret;\n\n\taac_fib_init(fib);\n\treadcmd = (struct aac_read *) fib_data(fib);\n\treadcmd->command = cpu_to_le32(VM_CtBlockRead);\n\treadcmd->cid = cpu_to_le32(scmd_id(cmd));\n\treadcmd->block = cpu_to_le32((u32)(lba&0xffffffff));\n\treadcmd->count = cpu_to_le32(count *\n\t\tdev->fsa_dev[scmd_id(cmd)].block_size);\n\n\tret = aac_build_sg(cmd, &readcmd->sg);\n\tif (ret < 0)\n\t\treturn ret;\n\tfibsize = sizeof(struct aac_read) +\n\t\t\t((le32_to_cpu(readcmd->sg.count) - 1) *\n\t\t\t sizeof (struct sgentry));\n\tBUG_ON (fibsize > (fib->dev->max_fib_size -\n\t\t\t\tsizeof(struct aac_fibhdr)));\n\t \n\treturn aac_fib_send(ContainerCommand,\n\t\t\t  fib,\n\t\t\t  fibsize,\n\t\t\t  FsaNormal,\n\t\t\t  0, 1,\n\t\t\t  (fib_callback) io_callback,\n\t\t\t  (void *) cmd);\n}\n\nstatic int aac_write_raw_io(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count, int fua)\n{\n\tstruct aac_dev *dev = fib->dev;\n\tu16 fibsize, command;\n\tlong ret;\n\n\taac_fib_init(fib);\n\tif ((dev->comm_interface == AAC_COMM_MESSAGE_TYPE2 ||\n\t\tdev->comm_interface == AAC_COMM_MESSAGE_TYPE3) &&\n\t\t!dev->sync_mode) {\n\t\tstruct aac_raw_io2 *writecmd2;\n\t\twritecmd2 = (struct aac_raw_io2 *) fib_data(fib);\n\t\tmemset(writecmd2, 0, sizeof(struct aac_raw_io2));\n\t\twritecmd2->blockLow = cpu_to_le32((u32)(lba&0xffffffff));\n\t\twritecmd2->blockHigh = cpu_to_le32((u32)((lba&0xffffffff00000000LL)>>32));\n\t\twritecmd2->byteCount = cpu_to_le32(count *\n\t\t\tdev->fsa_dev[scmd_id(cmd)].block_size);\n\t\twritecmd2->cid = cpu_to_le16(scmd_id(cmd));\n\t\twritecmd2->flags = (fua && ((aac_cache & 5) != 1) &&\n\t\t\t\t\t\t   (((aac_cache & 5) != 5) || !fib->dev->cache_protected)) ?\n\t\t\tcpu_to_le16(RIO2_IO_TYPE_WRITE|RIO2_IO_SUREWRITE) :\n\t\t\tcpu_to_le16(RIO2_IO_TYPE_WRITE);\n\t\tret = aac_build_sgraw2(cmd, writecmd2,\n\t\t\t\tdev->scsi_host_ptr->sg_tablesize);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcommand = ContainerRawIo2;\n\t\tfibsize = struct_size(writecmd2, sge,\n\t\t\t\t      le32_to_cpu(writecmd2->sgeCnt));\n\t} else {\n\t\tstruct aac_raw_io *writecmd;\n\t\twritecmd = (struct aac_raw_io *) fib_data(fib);\n\t\twritecmd->block[0] = cpu_to_le32((u32)(lba&0xffffffff));\n\t\twritecmd->block[1] = cpu_to_le32((u32)((lba&0xffffffff00000000LL)>>32));\n\t\twritecmd->count = cpu_to_le32(count *\n\t\t\tdev->fsa_dev[scmd_id(cmd)].block_size);\n\t\twritecmd->cid = cpu_to_le16(scmd_id(cmd));\n\t\twritecmd->flags = (fua && ((aac_cache & 5) != 1) &&\n\t\t\t\t\t\t   (((aac_cache & 5) != 5) || !fib->dev->cache_protected)) ?\n\t\t\tcpu_to_le16(RIO_TYPE_WRITE|RIO_SUREWRITE) :\n\t\t\tcpu_to_le16(RIO_TYPE_WRITE);\n\t\twritecmd->bpTotal = 0;\n\t\twritecmd->bpComplete = 0;\n\t\tret = aac_build_sgraw(cmd, &writecmd->sg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcommand = ContainerRawIo;\n\t\tfibsize = sizeof(struct aac_raw_io) +\n\t\t\t((le32_to_cpu(writecmd->sg.count)-1) * sizeof (struct sgentryraw));\n\t}\n\n\tBUG_ON(fibsize > (fib->dev->max_fib_size - sizeof(struct aac_fibhdr)));\n\t \n\treturn aac_fib_send(command,\n\t\t\t  fib,\n\t\t\t  fibsize,\n\t\t\t  FsaNormal,\n\t\t\t  0, 1,\n\t\t\t  (fib_callback) io_callback,\n\t\t\t  (void *) cmd);\n}\n\nstatic int aac_write_block64(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count, int fua)\n{\n\tu16 fibsize;\n\tstruct aac_write64 *writecmd;\n\tlong ret;\n\n\taac_fib_init(fib);\n\twritecmd = (struct aac_write64 *) fib_data(fib);\n\twritecmd->command = cpu_to_le32(VM_CtHostWrite64);\n\twritecmd->cid = cpu_to_le16(scmd_id(cmd));\n\twritecmd->sector_count = cpu_to_le16(count);\n\twritecmd->block = cpu_to_le32((u32)(lba&0xffffffff));\n\twritecmd->pad\t= 0;\n\twritecmd->flags\t= 0;\n\n\tret = aac_build_sg64(cmd, &writecmd->sg);\n\tif (ret < 0)\n\t\treturn ret;\n\tfibsize = sizeof(struct aac_write64) +\n\t\t((le32_to_cpu(writecmd->sg.count) - 1) *\n\t\t sizeof (struct sgentry64));\n\tBUG_ON (fibsize > (fib->dev->max_fib_size -\n\t\t\t\tsizeof(struct aac_fibhdr)));\n\t \n\treturn aac_fib_send(ContainerCommand64,\n\t\t\t  fib,\n\t\t\t  fibsize,\n\t\t\t  FsaNormal,\n\t\t\t  0, 1,\n\t\t\t  (fib_callback) io_callback,\n\t\t\t  (void *) cmd);\n}\n\nstatic int aac_write_block(struct fib * fib, struct scsi_cmnd * cmd, u64 lba, u32 count, int fua)\n{\n\tu16 fibsize;\n\tstruct aac_write *writecmd;\n\tstruct aac_dev *dev = fib->dev;\n\tlong ret;\n\n\taac_fib_init(fib);\n\twritecmd = (struct aac_write *) fib_data(fib);\n\twritecmd->command = cpu_to_le32(VM_CtBlockWrite);\n\twritecmd->cid = cpu_to_le32(scmd_id(cmd));\n\twritecmd->block = cpu_to_le32((u32)(lba&0xffffffff));\n\twritecmd->count = cpu_to_le32(count *\n\t\tdev->fsa_dev[scmd_id(cmd)].block_size);\n\twritecmd->sg.count = cpu_to_le32(1);\n\t \n\n\tret = aac_build_sg(cmd, &writecmd->sg);\n\tif (ret < 0)\n\t\treturn ret;\n\tfibsize = sizeof(struct aac_write) +\n\t\t((le32_to_cpu(writecmd->sg.count) - 1) *\n\t\t sizeof (struct sgentry));\n\tBUG_ON (fibsize > (fib->dev->max_fib_size -\n\t\t\t\tsizeof(struct aac_fibhdr)));\n\t \n\treturn aac_fib_send(ContainerCommand,\n\t\t\t  fib,\n\t\t\t  fibsize,\n\t\t\t  FsaNormal,\n\t\t\t  0, 1,\n\t\t\t  (fib_callback) io_callback,\n\t\t\t  (void *) cmd);\n}\n\nstatic struct aac_srb * aac_scsi_common(struct fib * fib, struct scsi_cmnd * cmd)\n{\n\tstruct aac_srb * srbcmd;\n\tu32 flag;\n\tu32 timeout;\n\tstruct aac_dev *dev = fib->dev;\n\n\taac_fib_init(fib);\n\tswitch(cmd->sc_data_direction){\n\tcase DMA_TO_DEVICE:\n\t\tflag = SRB_DataOut;\n\t\tbreak;\n\tcase DMA_BIDIRECTIONAL:\n\t\tflag = SRB_DataIn | SRB_DataOut;\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\t\tflag = SRB_DataIn;\n\t\tbreak;\n\tcase DMA_NONE:\n\tdefault:\t \n\t\tflag = SRB_NoDataXfer;\n\t\tbreak;\n\t}\n\n\tsrbcmd = (struct aac_srb*) fib_data(fib);\n\tsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);\n\tsrbcmd->channel  = cpu_to_le32(aac_logical_to_phys(scmd_channel(cmd)));\n\tsrbcmd->id       = cpu_to_le32(scmd_id(cmd));\n\tsrbcmd->lun      = cpu_to_le32(cmd->device->lun);\n\tsrbcmd->flags    = cpu_to_le32(flag);\n\ttimeout = scsi_cmd_to_rq(cmd)->timeout / HZ;\n\tif (timeout == 0)\n\t\ttimeout = (dev->sa_firmware ? AAC_SA_TIMEOUT : AAC_ARC_TIMEOUT);\n\tsrbcmd->timeout  = cpu_to_le32(timeout);  \n\tsrbcmd->retry_limit = 0;  \n\tsrbcmd->cdb_size = cpu_to_le32(cmd->cmd_len);\n\treturn srbcmd;\n}\n\nstatic struct aac_hba_cmd_req *aac_construct_hbacmd(struct fib *fib,\n\t\t\t\t\t\t\tstruct scsi_cmnd *cmd)\n{\n\tstruct aac_hba_cmd_req *hbacmd;\n\tstruct aac_dev *dev;\n\tint bus, target;\n\tu64 address;\n\n\tdev = (struct aac_dev *)cmd->device->host->hostdata;\n\n\thbacmd = (struct aac_hba_cmd_req *)fib->hw_fib_va;\n\tmemset(hbacmd, 0, 96);\t \n\t \n\tswitch (cmd->sc_data_direction) {\n\tcase DMA_TO_DEVICE:\n\t\thbacmd->byte1 = 2;\n\t\tbreak;\n\tcase DMA_FROM_DEVICE:\n\tcase DMA_BIDIRECTIONAL:\n\t\thbacmd->byte1 = 1;\n\t\tbreak;\n\tcase DMA_NONE:\n\tdefault:\n\t\tbreak;\n\t}\n\thbacmd->lun[1] = cpu_to_le32(cmd->device->lun);\n\n\tbus = aac_logical_to_phys(scmd_channel(cmd));\n\ttarget = scmd_id(cmd);\n\thbacmd->it_nexus = dev->hba_map[bus][target].rmw_nexus;\n\n\t \n\t \n\t \n\n\tmemcpy(hbacmd->cdb, cmd->cmnd, cmd->cmd_len);\n\thbacmd->data_length = cpu_to_le32(scsi_bufflen(cmd));\n\n\taddress = (u64)fib->hw_error_pa;\n\thbacmd->error_ptr_hi = cpu_to_le32((u32)(address >> 32));\n\thbacmd->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));\n\thbacmd->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);\n\n\treturn hbacmd;\n}\n\nstatic void aac_srb_callback(void *context, struct fib * fibptr);\n\nstatic int aac_scsi_64(struct fib * fib, struct scsi_cmnd * cmd)\n{\n\tu16 fibsize;\n\tstruct aac_srb * srbcmd = aac_scsi_common(fib, cmd);\n\tlong ret;\n\n\tret = aac_build_sg64(cmd, (struct sgmap64 *) &srbcmd->sg);\n\tif (ret < 0)\n\t\treturn ret;\n\tsrbcmd->count = cpu_to_le32(scsi_bufflen(cmd));\n\n\tmemset(srbcmd->cdb, 0, sizeof(srbcmd->cdb));\n\tmemcpy(srbcmd->cdb, cmd->cmnd, cmd->cmd_len);\n\t \n\tfibsize = sizeof (struct aac_srb) - sizeof (struct sgentry) +\n\t\t((le32_to_cpu(srbcmd->sg.count) & 0xff) *\n\t\t sizeof (struct sgentry64));\n\tBUG_ON (fibsize > (fib->dev->max_fib_size -\n\t\t\t\tsizeof(struct aac_fibhdr)));\n\n\t \n\treturn aac_fib_send(ScsiPortCommand64, fib,\n\t\t\t\tfibsize, FsaNormal, 0, 1,\n\t\t\t\t  (fib_callback) aac_srb_callback,\n\t\t\t\t  (void *) cmd);\n}\n\nstatic int aac_scsi_32(struct fib * fib, struct scsi_cmnd * cmd)\n{\n\tu16 fibsize;\n\tstruct aac_srb * srbcmd = aac_scsi_common(fib, cmd);\n\tlong ret;\n\n\tret = aac_build_sg(cmd, (struct sgmap *)&srbcmd->sg);\n\tif (ret < 0)\n\t\treturn ret;\n\tsrbcmd->count = cpu_to_le32(scsi_bufflen(cmd));\n\n\tmemset(srbcmd->cdb, 0, sizeof(srbcmd->cdb));\n\tmemcpy(srbcmd->cdb, cmd->cmnd, cmd->cmd_len);\n\t \n\tfibsize = sizeof (struct aac_srb) +\n\t\t(((le32_to_cpu(srbcmd->sg.count) & 0xff) - 1) *\n\t\t sizeof (struct sgentry));\n\tBUG_ON (fibsize > (fib->dev->max_fib_size -\n\t\t\t\tsizeof(struct aac_fibhdr)));\n\n\t \n\treturn aac_fib_send(ScsiPortCommand, fib, fibsize, FsaNormal, 0, 1,\n\t\t\t\t  (fib_callback) aac_srb_callback, (void *) cmd);\n}\n\nstatic int aac_scsi_32_64(struct fib * fib, struct scsi_cmnd * cmd)\n{\n\tif ((sizeof(dma_addr_t) > 4) && fib->dev->needs_dac &&\n\t    (fib->dev->adapter_info.options & AAC_OPT_SGMAP_HOST64))\n\t\treturn FAILED;\n\treturn aac_scsi_32(fib, cmd);\n}\n\nstatic int aac_adapter_hba(struct fib *fib, struct scsi_cmnd *cmd)\n{\n\tstruct aac_hba_cmd_req *hbacmd = aac_construct_hbacmd(fib, cmd);\n\tstruct aac_dev *dev;\n\tlong ret;\n\n\tdev = (struct aac_dev *)cmd->device->host->hostdata;\n\n\tret = aac_build_sghba(cmd, hbacmd,\n\t\tdev->scsi_host_ptr->sg_tablesize, (u64)fib->hw_sgl_pa);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfib->hbacmd_size = 64 + le32_to_cpu(hbacmd->emb_data_desc_count) *\n\t\tsizeof(struct aac_hba_sgl);\n\n\treturn aac_hba_send(HBA_IU_TYPE_SCSI_CMD_REQ, fib,\n\t\t\t\t  (fib_callback) aac_hba_callback,\n\t\t\t\t  (void *) cmd);\n}\n\nstatic int aac_send_safw_bmic_cmd(struct aac_dev *dev,\n\tstruct aac_srb_unit *srbu, void *xfer_buf, int xfer_len)\n{\n\tstruct fib\t*fibptr;\n\tdma_addr_t\taddr;\n\tint\t\trcode;\n\tint\t\tfibsize;\n\tstruct aac_srb\t*srb;\n\tstruct aac_srb_reply *srb_reply;\n\tstruct sgmap64\t*sg64;\n\tu32 vbus;\n\tu32 vid;\n\n\tif (!dev->sa_firmware)\n\t\treturn 0;\n\n\t \n\tfibptr = aac_fib_alloc(dev);\n\tif (!fibptr)\n\t\treturn -ENOMEM;\n\n\taac_fib_init(fibptr);\n\tfibptr->hw_fib_va->header.XferState &=\n\t\t~cpu_to_le32(FastResponseCapable);\n\n\tfibsize  = sizeof(struct aac_srb) - sizeof(struct sgentry) +\n\t\t\t\t\t\tsizeof(struct sgentry64);\n\n\t \n\taddr = dma_map_single(&dev->pdev->dev, xfer_buf, xfer_len,\n\t\t\t\t\t\t\tDMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(&dev->pdev->dev, addr)) {\n\t\trcode = -ENOMEM;\n\t\tgoto fib_error;\n\t}\n\n\tsrb = fib_data(fibptr);\n\tmemcpy(srb, &srbu->srb, sizeof(struct aac_srb));\n\n\tvbus = (u32)le16_to_cpu(\n\t\t\tdev->supplement_adapter_info.virt_device_bus);\n\tvid  = (u32)le16_to_cpu(\n\t\t\tdev->supplement_adapter_info.virt_device_target);\n\n\t \n\tsrb->channel\t\t= cpu_to_le32(vbus);\n\tsrb->id\t\t\t= cpu_to_le32(vid);\n\tsrb->lun\t\t= 0;\n\tsrb->function\t\t= cpu_to_le32(SRBF_ExecuteScsi);\n\tsrb->timeout\t\t= 0;\n\tsrb->retry_limit\t= 0;\n\tsrb->cdb_size\t\t= cpu_to_le32(16);\n\tsrb->count\t\t= cpu_to_le32(xfer_len);\n\n\tsg64 = (struct sgmap64 *)&srb->sg;\n\tsg64->count\t\t= cpu_to_le32(1);\n\tsg64->sg[0].addr[1]\t= cpu_to_le32(upper_32_bits(addr));\n\tsg64->sg[0].addr[0]\t= cpu_to_le32(lower_32_bits(addr));\n\tsg64->sg[0].count\t= cpu_to_le32(xfer_len);\n\n\t \n\tmemcpy(&srbu->srb, srb, sizeof(struct aac_srb));\n\n\t \n\trcode = aac_fib_send(ScsiPortCommand64, fibptr, fibsize, FsaNormal,\n\t\t\t\t\t1, 1, NULL, NULL);\n\n\tif (rcode == -ERESTARTSYS)\n\t\trcode = -ERESTART;\n\n\tif (unlikely(rcode < 0))\n\t\tgoto bmic_error;\n\n\tsrb_reply = (struct aac_srb_reply *)fib_data(fibptr);\n\tmemcpy(&srbu->srb_reply, srb_reply, sizeof(struct aac_srb_reply));\n\nbmic_error:\n\tdma_unmap_single(&dev->pdev->dev, addr, xfer_len, DMA_BIDIRECTIONAL);\nfib_error:\n\taac_fib_complete(fibptr);\n\taac_fib_free(fibptr);\n\treturn rcode;\n}\n\nstatic void aac_set_safw_target_qd(struct aac_dev *dev, int bus, int target)\n{\n\n\tstruct aac_ciss_identify_pd *identify_resp;\n\n\tif (dev->hba_map[bus][target].devtype != AAC_DEVTYPE_NATIVE_RAW)\n\t\treturn;\n\n\tidentify_resp = dev->hba_map[bus][target].safw_identify_resp;\n\tif (identify_resp == NULL) {\n\t\tdev->hba_map[bus][target].qd_limit = 32;\n\t\treturn;\n\t}\n\n\tif (identify_resp->current_queue_depth_limit <= 0 ||\n\t\tidentify_resp->current_queue_depth_limit > 255)\n\t\tdev->hba_map[bus][target].qd_limit = 32;\n\telse\n\t\tdev->hba_map[bus][target].qd_limit =\n\t\t\tidentify_resp->current_queue_depth_limit;\n}\n\nstatic int aac_issue_safw_bmic_identify(struct aac_dev *dev,\n\tstruct aac_ciss_identify_pd **identify_resp, u32 bus, u32 target)\n{\n\tint rcode = -ENOMEM;\n\tint datasize;\n\tstruct aac_srb_unit srbu;\n\tstruct aac_srb *srbcmd;\n\tstruct aac_ciss_identify_pd *identify_reply;\n\n\tdatasize = sizeof(struct aac_ciss_identify_pd);\n\tidentify_reply = kmalloc(datasize, GFP_KERNEL);\n\tif (!identify_reply)\n\t\tgoto out;\n\n\tmemset(&srbu, 0, sizeof(struct aac_srb_unit));\n\n\tsrbcmd = &srbu.srb;\n\tsrbcmd->flags\t= cpu_to_le32(SRB_DataIn);\n\tsrbcmd->cdb[0]\t= 0x26;\n\tsrbcmd->cdb[2]\t= (u8)((AAC_MAX_LUN + target) & 0x00FF);\n\tsrbcmd->cdb[6]\t= CISS_IDENTIFY_PHYSICAL_DEVICE;\n\n\trcode = aac_send_safw_bmic_cmd(dev, &srbu, identify_reply, datasize);\n\tif (unlikely(rcode < 0))\n\t\tgoto mem_free_all;\n\n\t*identify_resp = identify_reply;\n\nout:\n\treturn rcode;\nmem_free_all:\n\tkfree(identify_reply);\n\tgoto out;\n}\n\nstatic inline void aac_free_safw_ciss_luns(struct aac_dev *dev)\n{\n\tkfree(dev->safw_phys_luns);\n\tdev->safw_phys_luns = NULL;\n}\n\n \nstatic int aac_get_safw_ciss_luns(struct aac_dev *dev)\n{\n\tint rcode = -ENOMEM;\n\tint datasize;\n\tstruct aac_srb *srbcmd;\n\tstruct aac_srb_unit srbu;\n\tstruct aac_ciss_phys_luns_resp *phys_luns;\n\n\tdatasize = sizeof(struct aac_ciss_phys_luns_resp) +\n\t\t(AAC_MAX_TARGETS - 1) * sizeof(struct _ciss_lun);\n\tphys_luns = kmalloc(datasize, GFP_KERNEL);\n\tif (phys_luns == NULL)\n\t\tgoto out;\n\n\tmemset(&srbu, 0, sizeof(struct aac_srb_unit));\n\n\tsrbcmd = &srbu.srb;\n\tsrbcmd->flags\t= cpu_to_le32(SRB_DataIn);\n\tsrbcmd->cdb[0]\t= CISS_REPORT_PHYSICAL_LUNS;\n\tsrbcmd->cdb[1]\t= 2;  \n\tsrbcmd->cdb[8]\t= (u8)(datasize >> 8);\n\tsrbcmd->cdb[9]\t= (u8)(datasize);\n\n\trcode = aac_send_safw_bmic_cmd(dev, &srbu, phys_luns, datasize);\n\tif (unlikely(rcode < 0))\n\t\tgoto mem_free_all;\n\n\tif (phys_luns->resp_flag != 2) {\n\t\trcode = -ENOMSG;\n\t\tgoto mem_free_all;\n\t}\n\n\tdev->safw_phys_luns = phys_luns;\n\nout:\n\treturn rcode;\nmem_free_all:\n\tkfree(phys_luns);\n\tgoto out;\n}\n\nstatic inline u32 aac_get_safw_phys_lun_count(struct aac_dev *dev)\n{\n\treturn get_unaligned_be32(&dev->safw_phys_luns->list_length[0])/24;\n}\n\nstatic inline u32 aac_get_safw_phys_bus(struct aac_dev *dev, int lun)\n{\n\treturn dev->safw_phys_luns->lun[lun].level2[1] & 0x3f;\n}\n\nstatic inline u32 aac_get_safw_phys_target(struct aac_dev *dev, int lun)\n{\n\treturn dev->safw_phys_luns->lun[lun].level2[0];\n}\n\nstatic inline u32 aac_get_safw_phys_expose_flag(struct aac_dev *dev, int lun)\n{\n\treturn dev->safw_phys_luns->lun[lun].bus >> 6;\n}\n\nstatic inline u32 aac_get_safw_phys_attribs(struct aac_dev *dev, int lun)\n{\n\treturn dev->safw_phys_luns->lun[lun].node_ident[9];\n}\n\nstatic inline u32 aac_get_safw_phys_nexus(struct aac_dev *dev, int lun)\n{\n\treturn *((u32 *)&dev->safw_phys_luns->lun[lun].node_ident[12]);\n}\n\nstatic inline void aac_free_safw_identify_resp(struct aac_dev *dev,\n\t\t\t\t\t\tint bus, int target)\n{\n\tkfree(dev->hba_map[bus][target].safw_identify_resp);\n\tdev->hba_map[bus][target].safw_identify_resp = NULL;\n}\n\nstatic inline void aac_free_safw_all_identify_resp(struct aac_dev *dev,\n\tint lun_count)\n{\n\tint luns;\n\tint i;\n\tu32 bus;\n\tu32 target;\n\n\tluns = aac_get_safw_phys_lun_count(dev);\n\n\tif (luns < lun_count)\n\t\tlun_count = luns;\n\telse if (lun_count < 0)\n\t\tlun_count = luns;\n\n\tfor (i = 0; i < lun_count; i++) {\n\t\tbus = aac_get_safw_phys_bus(dev, i);\n\t\ttarget = aac_get_safw_phys_target(dev, i);\n\n\t\taac_free_safw_identify_resp(dev, bus, target);\n\t}\n}\n\nstatic int aac_get_safw_attr_all_targets(struct aac_dev *dev)\n{\n\tint i;\n\tint rcode = 0;\n\tu32 lun_count;\n\tu32 bus;\n\tu32 target;\n\tstruct aac_ciss_identify_pd *identify_resp = NULL;\n\n\tlun_count = aac_get_safw_phys_lun_count(dev);\n\n\tfor (i = 0; i < lun_count; ++i) {\n\n\t\tbus = aac_get_safw_phys_bus(dev, i);\n\t\ttarget = aac_get_safw_phys_target(dev, i);\n\n\t\trcode = aac_issue_safw_bmic_identify(dev,\n\t\t\t\t\t\t&identify_resp, bus, target);\n\n\t\tif (unlikely(rcode < 0))\n\t\t\tgoto free_identify_resp;\n\n\t\tdev->hba_map[bus][target].safw_identify_resp = identify_resp;\n\t}\n\nout:\n\treturn rcode;\nfree_identify_resp:\n\taac_free_safw_all_identify_resp(dev, i);\n\tgoto out;\n}\n\n \nstatic void aac_set_safw_attr_all_targets(struct aac_dev *dev)\n{\n\t \n\tu32 lun_count, nexus;\n\tu32 i, bus, target;\n\tu8 expose_flag, attribs;\n\n\tlun_count = aac_get_safw_phys_lun_count(dev);\n\n\tdev->scan_counter++;\n\n\tfor (i = 0; i < lun_count; ++i) {\n\n\t\tbus = aac_get_safw_phys_bus(dev, i);\n\t\ttarget = aac_get_safw_phys_target(dev, i);\n\t\texpose_flag = aac_get_safw_phys_expose_flag(dev, i);\n\t\tattribs = aac_get_safw_phys_attribs(dev, i);\n\t\tnexus = aac_get_safw_phys_nexus(dev, i);\n\n\t\tif (bus >= AAC_MAX_BUSES || target >= AAC_MAX_TARGETS)\n\t\t\tcontinue;\n\n\t\tif (expose_flag != 0) {\n\t\t\tdev->hba_map[bus][target].devtype =\n\t\t\t\tAAC_DEVTYPE_RAID_MEMBER;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nexus != 0 && (attribs & 8)) {\n\t\t\tdev->hba_map[bus][target].devtype =\n\t\t\t\tAAC_DEVTYPE_NATIVE_RAW;\n\t\t\tdev->hba_map[bus][target].rmw_nexus =\n\t\t\t\t\tnexus;\n\t\t} else\n\t\t\tdev->hba_map[bus][target].devtype =\n\t\t\t\tAAC_DEVTYPE_ARC_RAW;\n\n\t\tdev->hba_map[bus][target].scan_counter = dev->scan_counter;\n\n\t\taac_set_safw_target_qd(dev, bus, target);\n\t}\n}\n\nstatic int aac_setup_safw_targets(struct aac_dev *dev)\n{\n\tint rcode = 0;\n\n\trcode = aac_get_containers(dev);\n\tif (unlikely(rcode < 0))\n\t\tgoto out;\n\n\trcode = aac_get_safw_ciss_luns(dev);\n\tif (unlikely(rcode < 0))\n\t\tgoto out;\n\n\trcode = aac_get_safw_attr_all_targets(dev);\n\tif (unlikely(rcode < 0))\n\t\tgoto free_ciss_luns;\n\n\taac_set_safw_attr_all_targets(dev);\n\n\taac_free_safw_all_identify_resp(dev, -1);\nfree_ciss_luns:\n\taac_free_safw_ciss_luns(dev);\nout:\n\treturn rcode;\n}\n\nint aac_setup_safw_adapter(struct aac_dev *dev)\n{\n\treturn aac_setup_safw_targets(dev);\n}\n\nint aac_get_adapter_info(struct aac_dev* dev)\n{\n\tstruct fib* fibptr;\n\tint rcode;\n\tu32 tmp, bus, target;\n\tstruct aac_adapter_info *info;\n\tstruct aac_bus_info *command;\n\tstruct aac_bus_info_response *bus_info;\n\n\tif (!(fibptr = aac_fib_alloc(dev)))\n\t\treturn -ENOMEM;\n\n\taac_fib_init(fibptr);\n\tinfo = (struct aac_adapter_info *) fib_data(fibptr);\n\tmemset(info,0,sizeof(*info));\n\n\trcode = aac_fib_send(RequestAdapterInfo,\n\t\t\t fibptr,\n\t\t\t sizeof(*info),\n\t\t\t FsaNormal,\n\t\t\t -1, 1,  \n\t\t\t NULL,\n\t\t\t NULL);\n\n\tif (rcode < 0) {\n\t\t \n\t\tif (rcode != -ERESTARTSYS) {\n\t\t\taac_fib_complete(fibptr);\n\t\t\taac_fib_free(fibptr);\n\t\t}\n\t\treturn rcode;\n\t}\n\tmemcpy(&dev->adapter_info, info, sizeof(*info));\n\n\tdev->supplement_adapter_info.virt_device_bus = 0xffff;\n\tif (dev->adapter_info.options & AAC_OPT_SUPPLEMENT_ADAPTER_INFO) {\n\t\tstruct aac_supplement_adapter_info * sinfo;\n\n\t\taac_fib_init(fibptr);\n\n\t\tsinfo = (struct aac_supplement_adapter_info *) fib_data(fibptr);\n\n\t\tmemset(sinfo,0,sizeof(*sinfo));\n\n\t\trcode = aac_fib_send(RequestSupplementAdapterInfo,\n\t\t\t\t fibptr,\n\t\t\t\t sizeof(*sinfo),\n\t\t\t\t FsaNormal,\n\t\t\t\t 1, 1,\n\t\t\t\t NULL,\n\t\t\t\t NULL);\n\n\t\tif (rcode >= 0)\n\t\t\tmemcpy(&dev->supplement_adapter_info, sinfo, sizeof(*sinfo));\n\t\tif (rcode == -ERESTARTSYS) {\n\t\t\tfibptr = aac_fib_alloc(dev);\n\t\t\tif (!fibptr)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t}\n\n\t \n\tfor (bus = 0; bus < AAC_MAX_BUSES; bus++) {\n\t\tfor (target = 0; target < AAC_MAX_TARGETS; target++) {\n\t\t\tdev->hba_map[bus][target].devtype = 0;\n\t\t\tdev->hba_map[bus][target].qd_limit = 0;\n\t\t}\n\t}\n\n\t \n\n\taac_fib_init(fibptr);\n\n\tbus_info = (struct aac_bus_info_response *) fib_data(fibptr);\n\n\tmemset(bus_info, 0, sizeof(*bus_info));\n\n\tcommand = (struct aac_bus_info *)bus_info;\n\n\tcommand->Command = cpu_to_le32(VM_Ioctl);\n\tcommand->ObjType = cpu_to_le32(FT_DRIVE);\n\tcommand->MethodId = cpu_to_le32(1);\n\tcommand->CtlCmd = cpu_to_le32(GetBusInfo);\n\n\trcode = aac_fib_send(ContainerCommand,\n\t\t\t fibptr,\n\t\t\t sizeof (*bus_info),\n\t\t\t FsaNormal,\n\t\t\t 1, 1,\n\t\t\t NULL, NULL);\n\n\t \n\tdev->maximum_num_physicals = 16;\n\tif (rcode >= 0 && le32_to_cpu(bus_info->Status) == ST_OK) {\n\t\tdev->maximum_num_physicals = le32_to_cpu(bus_info->TargetsPerBus);\n\t\tdev->maximum_num_channels = le32_to_cpu(bus_info->BusCount);\n\t}\n\n\tif (!dev->in_reset) {\n\t\tchar buffer[16];\n\t\ttmp = le32_to_cpu(dev->adapter_info.kernelrev);\n\t\tprintk(KERN_INFO \"%s%d: kernel %d.%d-%d[%d] %.*s\\n\",\n\t\t\tdev->name,\n\t\t\tdev->id,\n\t\t\ttmp>>24,\n\t\t\t(tmp>>16)&0xff,\n\t\t\ttmp&0xff,\n\t\t\tle32_to_cpu(dev->adapter_info.kernelbuild),\n\t\t\t(int)sizeof(dev->supplement_adapter_info.build_date),\n\t\t\tdev->supplement_adapter_info.build_date);\n\t\ttmp = le32_to_cpu(dev->adapter_info.monitorrev);\n\t\tprintk(KERN_INFO \"%s%d: monitor %d.%d-%d[%d]\\n\",\n\t\t\tdev->name, dev->id,\n\t\t\ttmp>>24,(tmp>>16)&0xff,tmp&0xff,\n\t\t\tle32_to_cpu(dev->adapter_info.monitorbuild));\n\t\ttmp = le32_to_cpu(dev->adapter_info.biosrev);\n\t\tprintk(KERN_INFO \"%s%d: bios %d.%d-%d[%d]\\n\",\n\t\t\tdev->name, dev->id,\n\t\t\ttmp>>24,(tmp>>16)&0xff,tmp&0xff,\n\t\t\tle32_to_cpu(dev->adapter_info.biosbuild));\n\t\tbuffer[0] = '\\0';\n\t\tif (aac_get_serial_number(\n\t\t  shost_to_class(dev->scsi_host_ptr), buffer))\n\t\t\tprintk(KERN_INFO \"%s%d: serial %s\",\n\t\t\t  dev->name, dev->id, buffer);\n\t\tif (dev->supplement_adapter_info.vpd_info.tsid[0]) {\n\t\t\tprintk(KERN_INFO \"%s%d: TSID %.*s\\n\",\n\t\t\t  dev->name, dev->id,\n\t\t\t  (int)sizeof(dev->supplement_adapter_info\n\t\t\t\t\t\t\t.vpd_info.tsid),\n\t\t\t\tdev->supplement_adapter_info.vpd_info.tsid);\n\t\t}\n\t\tif (!aac_check_reset || ((aac_check_reset == 1) &&\n\t\t  (dev->supplement_adapter_info.supported_options2 &\n\t\t  AAC_OPTION_IGNORE_RESET))) {\n\t\t\tprintk(KERN_INFO \"%s%d: Reset Adapter Ignored\\n\",\n\t\t\t  dev->name, dev->id);\n\t\t}\n\t}\n\n\tdev->cache_protected = 0;\n\tdev->jbod = ((dev->supplement_adapter_info.feature_bits &\n\t\tAAC_FEATURE_JBOD) != 0);\n\tdev->nondasd_support = 0;\n\tdev->raid_scsi_mode = 0;\n\tif(dev->adapter_info.options & AAC_OPT_NONDASD)\n\t\tdev->nondasd_support = 1;\n\n\t \n\tif ((dev->adapter_info.options & AAC_OPT_SCSI_MANAGED) &&\n\t    (dev->adapter_info.options & AAC_OPT_RAID_SCSI_MODE)) {\n\t\tdev->nondasd_support = 1;\n\t\tdev->raid_scsi_mode = 1;\n\t}\n\tif (dev->raid_scsi_mode != 0)\n\t\tprintk(KERN_INFO \"%s%d: ROMB RAID/SCSI mode enabled\\n\",\n\t\t\t\tdev->name, dev->id);\n\n\tif (nondasd != -1)\n\t\tdev->nondasd_support = (nondasd!=0);\n\tif (dev->nondasd_support && !dev->in_reset)\n\t\tprintk(KERN_INFO \"%s%d: Non-DASD support enabled.\\n\",dev->name, dev->id);\n\n\tif (dma_get_required_mask(&dev->pdev->dev) > DMA_BIT_MASK(32))\n\t\tdev->needs_dac = 1;\n\tdev->dac_support = 0;\n\tif ((sizeof(dma_addr_t) > 4) && dev->needs_dac &&\n\t    (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64)) {\n\t\tif (!dev->in_reset)\n\t\t\tprintk(KERN_INFO \"%s%d: 64bit support enabled.\\n\",\n\t\t\t\tdev->name, dev->id);\n\t\tdev->dac_support = 1;\n\t}\n\n\tif(dacmode != -1) {\n\t\tdev->dac_support = (dacmode!=0);\n\t}\n\n\t \n\tif (dev->dac_support &&\t(aac_get_driver_ident(dev->cardtype)->quirks\n\t\t& AAC_QUIRK_SCSI_32)) {\n\t\tdev->nondasd_support = 0;\n\t\tdev->jbod = 0;\n\t\texpose_physicals = 0;\n\t}\n\n\tif (dev->dac_support) {\n\t\tif (!dma_set_mask(&dev->pdev->dev, DMA_BIT_MASK(64))) {\n\t\t\tif (!dev->in_reset)\n\t\t\t\tdev_info(&dev->pdev->dev, \"64 Bit DAC enabled\\n\");\n\t\t} else if (!dma_set_mask(&dev->pdev->dev, DMA_BIT_MASK(32))) {\n\t\t\tdev_info(&dev->pdev->dev, \"DMA mask set failed, 64 Bit DAC disabled\\n\");\n\t\t\tdev->dac_support = 0;\n\t\t} else {\n\t\t\tdev_info(&dev->pdev->dev, \"No suitable DMA available\\n\");\n\t\t\trcode = -ENOMEM;\n\t\t}\n\t}\n\t \n\tdev->a_ops.adapter_scsi = (dev->dac_support)\n\t  ? ((aac_get_driver_ident(dev->cardtype)->quirks & AAC_QUIRK_SCSI_32)\n\t\t\t\t? aac_scsi_32_64\n\t\t\t\t: aac_scsi_64)\n\t\t\t\t: aac_scsi_32;\n\tif (dev->raw_io_interface) {\n\t\tdev->a_ops.adapter_bounds = (dev->raw_io_64)\n\t\t\t\t\t? aac_bounds_64\n\t\t\t\t\t: aac_bounds_32;\n\t\tdev->a_ops.adapter_read = aac_read_raw_io;\n\t\tdev->a_ops.adapter_write = aac_write_raw_io;\n\t} else {\n\t\tdev->a_ops.adapter_bounds = aac_bounds_32;\n\t\tdev->scsi_host_ptr->sg_tablesize = (dev->max_fib_size -\n\t\t\tsizeof(struct aac_fibhdr) -\n\t\t\tsizeof(struct aac_write) + sizeof(struct sgentry)) /\n\t\t\t\tsizeof(struct sgentry);\n\t\tif (dev->dac_support) {\n\t\t\tdev->a_ops.adapter_read = aac_read_block64;\n\t\t\tdev->a_ops.adapter_write = aac_write_block64;\n\t\t\t \n\t\t\tdev->scsi_host_ptr->sg_tablesize =\n\t\t\t\t(dev->max_fib_size -\n\t\t\t\tsizeof(struct aac_fibhdr) -\n\t\t\t\tsizeof(struct aac_write64) +\n\t\t\t\tsizeof(struct sgentry64)) /\n\t\t\t\t\tsizeof(struct sgentry64);\n\t\t} else {\n\t\t\tdev->a_ops.adapter_read = aac_read_block;\n\t\t\tdev->a_ops.adapter_write = aac_write_block;\n\t\t}\n\t\tdev->scsi_host_ptr->max_sectors = AAC_MAX_32BIT_SGBCOUNT;\n\t\tif (!(dev->adapter_info.options & AAC_OPT_NEW_COMM)) {\n\t\t\t \n\t\t\tdev->scsi_host_ptr->max_sectors =\n\t\t\t  (dev->scsi_host_ptr->sg_tablesize * 8) + 112;\n\t\t}\n\t}\n\tif (!dev->sync_mode && dev->sa_firmware &&\n\t\tdev->scsi_host_ptr->sg_tablesize > HBA_MAX_SG_SEPARATE)\n\t\tdev->scsi_host_ptr->sg_tablesize = dev->sg_tablesize =\n\t\t\tHBA_MAX_SG_SEPARATE;\n\n\t \n\tif (rcode != -ERESTARTSYS) {\n\t\taac_fib_complete(fibptr);\n\t\taac_fib_free(fibptr);\n\t}\n\n\treturn rcode;\n}\n\n\nstatic void io_callback(void *context, struct fib * fibptr)\n{\n\tstruct aac_dev *dev;\n\tstruct aac_read_reply *readreply;\n\tstruct scsi_cmnd *scsicmd;\n\tu32 cid;\n\n\tscsicmd = (struct scsi_cmnd *) context;\n\n\tif (!aac_valid_context(scsicmd, fibptr))\n\t\treturn;\n\n\tdev = fibptr->dev;\n\tcid = scmd_id(scsicmd);\n\n\tif (nblank(dprintk(x))) {\n\t\tu64 lba;\n\t\tswitch (scsicmd->cmnd[0]) {\n\t\tcase WRITE_6:\n\t\tcase READ_6:\n\t\t\tlba = ((scsicmd->cmnd[1] & 0x1F) << 16) |\n\t\t\t    (scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];\n\t\t\tbreak;\n\t\tcase WRITE_16:\n\t\tcase READ_16:\n\t\t\tlba = ((u64)scsicmd->cmnd[2] << 56) |\n\t\t\t      ((u64)scsicmd->cmnd[3] << 48) |\n\t\t\t      ((u64)scsicmd->cmnd[4] << 40) |\n\t\t\t      ((u64)scsicmd->cmnd[5] << 32) |\n\t\t\t      ((u64)scsicmd->cmnd[6] << 24) |\n\t\t\t      (scsicmd->cmnd[7] << 16) |\n\t\t\t      (scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\n\t\t\tbreak;\n\t\tcase WRITE_12:\n\t\tcase READ_12:\n\t\t\tlba = ((u64)scsicmd->cmnd[2] << 24) |\n\t\t\t      (scsicmd->cmnd[3] << 16) |\n\t\t\t      (scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlba = ((u64)scsicmd->cmnd[2] << 24) |\n\t\t\t       (scsicmd->cmnd[3] << 16) |\n\t\t\t       (scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\n\t\t\tbreak;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t  \"io_callback[cpu %d]: lba = %llu, t = %ld.\\n\",\n\t\t  smp_processor_id(), (unsigned long long)lba, jiffies);\n\t}\n\n\tBUG_ON(fibptr == NULL);\n\n\tscsi_dma_unmap(scsicmd);\n\n\treadreply = (struct aac_read_reply *)fib_data(fibptr);\n\tswitch (le32_to_cpu(readreply->status)) {\n\tcase ST_OK:\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\tdev->fsa_dev[cid].sense_data.sense_key = NO_SENSE;\n\t\tbreak;\n\tcase ST_NOT_READY:\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data, NOT_READY,\n\t\t  SENCODE_BECOMING_READY, ASENCODE_BECOMING_READY, 0, 0);\n\t\tmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t       min_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\tbreak;\n\tcase ST_MEDERR:\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data, MEDIUM_ERROR,\n\t\t  SENCODE_UNRECOVERED_READ_ERROR, ASENCODE_NO_SENSE, 0, 0);\n\t\tmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t       min_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\tbreak;\n\tdefault:\n#ifdef AAC_DETAILED_STATUS_INFO\n\t\tprintk(KERN_WARNING \"io_callback: io failed, status = %d\\n\",\n\t\t  le32_to_cpu(readreply->status));\n#endif\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t  HARDWARE_ERROR, SENCODE_INTERNAL_TARGET_FAILURE,\n\t\t  ASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\n\t\tmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t       min_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\tbreak;\n\t}\n\taac_fib_complete(fibptr);\n\n\taac_scsi_done(scsicmd);\n}\n\nstatic int aac_read(struct scsi_cmnd * scsicmd)\n{\n\tu64 lba;\n\tu32 count;\n\tint status;\n\tstruct aac_dev *dev;\n\tstruct fib * cmd_fibcontext;\n\tint cid;\n\n\tdev = (struct aac_dev *)scsicmd->device->host->hostdata;\n\t \n\tswitch (scsicmd->cmnd[0]) {\n\tcase READ_6:\n\t\tdprintk((KERN_DEBUG \"aachba: received a read(6) command on id %d.\\n\", scmd_id(scsicmd)));\n\n\t\tlba = ((scsicmd->cmnd[1] & 0x1F) << 16) |\n\t\t\t(scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];\n\t\tcount = scsicmd->cmnd[4];\n\n\t\tif (count == 0)\n\t\t\tcount = 256;\n\t\tbreak;\n\tcase READ_16:\n\t\tdprintk((KERN_DEBUG \"aachba: received a read(16) command on id %d.\\n\", scmd_id(scsicmd)));\n\n\t\tlba =\t((u64)scsicmd->cmnd[2] << 56) |\n\t\t\t((u64)scsicmd->cmnd[3] << 48) |\n\t\t\t((u64)scsicmd->cmnd[4] << 40) |\n\t\t\t((u64)scsicmd->cmnd[5] << 32) |\n\t\t\t((u64)scsicmd->cmnd[6] << 24) |\n\t\t\t(scsicmd->cmnd[7] << 16) |\n\t\t\t(scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\n\t\tcount = (scsicmd->cmnd[10] << 24) |\n\t\t\t(scsicmd->cmnd[11] << 16) |\n\t\t\t(scsicmd->cmnd[12] << 8) | scsicmd->cmnd[13];\n\t\tbreak;\n\tcase READ_12:\n\t\tdprintk((KERN_DEBUG \"aachba: received a read(12) command on id %d.\\n\", scmd_id(scsicmd)));\n\n\t\tlba = ((u64)scsicmd->cmnd[2] << 24) |\n\t\t\t(scsicmd->cmnd[3] << 16) |\n\t\t\t(scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\n\t\tcount = (scsicmd->cmnd[6] << 24) |\n\t\t\t(scsicmd->cmnd[7] << 16) |\n\t\t\t(scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\n\t\tbreak;\n\tdefault:\n\t\tdprintk((KERN_DEBUG \"aachba: received a read(10) command on id %d.\\n\", scmd_id(scsicmd)));\n\n\t\tlba = ((u64)scsicmd->cmnd[2] << 24) |\n\t\t\t(scsicmd->cmnd[3] << 16) |\n\t\t\t(scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\n\t\tcount = (scsicmd->cmnd[7] << 8) | scsicmd->cmnd[8];\n\t\tbreak;\n\t}\n\n\tif ((lba + count) > (dev->fsa_dev[scmd_id(scsicmd)].size)) {\n\t\tcid = scmd_id(scsicmd);\n\t\tdprintk((KERN_DEBUG \"aacraid: Illegal lba\\n\"));\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t\t  ILLEGAL_REQUEST, SENCODE_LBA_OUT_OF_RANGE,\n\t\t\t  ASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\n\t\tmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t       min_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\taac_scsi_done(scsicmd);\n\t\treturn 0;\n\t}\n\n\tdprintk((KERN_DEBUG \"aac_read[cpu %d]: lba = %llu, t = %ld.\\n\",\n\t  smp_processor_id(), (unsigned long long)lba, jiffies));\n\tif (aac_adapter_bounds(dev,scsicmd,lba))\n\t\treturn 0;\n\t \n\tcmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\tstatus = aac_adapter_read(cmd_fibcontext, scsicmd, lba, count);\n\n\t \n\tif (status == -EINPROGRESS)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"aac_read: aac_fib_send failed with status: %d.\\n\", status);\n\t \n\tscsicmd->result = DID_OK << 16 | SAM_STAT_TASK_SET_FULL;\n\taac_scsi_done(scsicmd);\n\taac_fib_complete(cmd_fibcontext);\n\taac_fib_free(cmd_fibcontext);\n\treturn 0;\n}\n\nstatic int aac_write(struct scsi_cmnd * scsicmd)\n{\n\tu64 lba;\n\tu32 count;\n\tint fua;\n\tint status;\n\tstruct aac_dev *dev;\n\tstruct fib * cmd_fibcontext;\n\tint cid;\n\n\tdev = (struct aac_dev *)scsicmd->device->host->hostdata;\n\t \n\tif (scsicmd->cmnd[0] == WRITE_6)\t \n\t{\n\t\tlba = ((scsicmd->cmnd[1] & 0x1F) << 16) | (scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];\n\t\tcount = scsicmd->cmnd[4];\n\t\tif (count == 0)\n\t\t\tcount = 256;\n\t\tfua = 0;\n\t} else if (scsicmd->cmnd[0] == WRITE_16) {  \n\t\tdprintk((KERN_DEBUG \"aachba: received a write(16) command on id %d.\\n\", scmd_id(scsicmd)));\n\n\t\tlba =\t((u64)scsicmd->cmnd[2] << 56) |\n\t\t\t((u64)scsicmd->cmnd[3] << 48) |\n\t\t\t((u64)scsicmd->cmnd[4] << 40) |\n\t\t\t((u64)scsicmd->cmnd[5] << 32) |\n\t\t\t((u64)scsicmd->cmnd[6] << 24) |\n\t\t\t(scsicmd->cmnd[7] << 16) |\n\t\t\t(scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\n\t\tcount = (scsicmd->cmnd[10] << 24) | (scsicmd->cmnd[11] << 16) |\n\t\t\t(scsicmd->cmnd[12] << 8) | scsicmd->cmnd[13];\n\t\tfua = scsicmd->cmnd[1] & 0x8;\n\t} else if (scsicmd->cmnd[0] == WRITE_12) {  \n\t\tdprintk((KERN_DEBUG \"aachba: received a write(12) command on id %d.\\n\", scmd_id(scsicmd)));\n\n\t\tlba = ((u64)scsicmd->cmnd[2] << 24) | (scsicmd->cmnd[3] << 16)\n\t\t    | (scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\n\t\tcount = (scsicmd->cmnd[6] << 24) | (scsicmd->cmnd[7] << 16)\n\t\t      | (scsicmd->cmnd[8] << 8) | scsicmd->cmnd[9];\n\t\tfua = scsicmd->cmnd[1] & 0x8;\n\t} else {\n\t\tdprintk((KERN_DEBUG \"aachba: received a write(10) command on id %d.\\n\", scmd_id(scsicmd)));\n\t\tlba = ((u64)scsicmd->cmnd[2] << 24) | (scsicmd->cmnd[3] << 16) | (scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];\n\t\tcount = (scsicmd->cmnd[7] << 8) | scsicmd->cmnd[8];\n\t\tfua = scsicmd->cmnd[1] & 0x8;\n\t}\n\n\tif ((lba + count) > (dev->fsa_dev[scmd_id(scsicmd)].size)) {\n\t\tcid = scmd_id(scsicmd);\n\t\tdprintk((KERN_DEBUG \"aacraid: Illegal lba\\n\"));\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t\t  ILLEGAL_REQUEST, SENCODE_LBA_OUT_OF_RANGE,\n\t\t\t  ASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\n\t\tmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t       min_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\taac_scsi_done(scsicmd);\n\t\treturn 0;\n\t}\n\n\tdprintk((KERN_DEBUG \"aac_write[cpu %d]: lba = %llu, t = %ld.\\n\",\n\t  smp_processor_id(), (unsigned long long)lba, jiffies));\n\tif (aac_adapter_bounds(dev,scsicmd,lba))\n\t\treturn 0;\n\t \n\tcmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\tstatus = aac_adapter_write(cmd_fibcontext, scsicmd, lba, count, fua);\n\n\t \n\tif (status == -EINPROGRESS)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"aac_write: aac_fib_send failed with status: %d\\n\", status);\n\t \n\tscsicmd->result = DID_OK << 16 | SAM_STAT_TASK_SET_FULL;\n\taac_scsi_done(scsicmd);\n\n\taac_fib_complete(cmd_fibcontext);\n\taac_fib_free(cmd_fibcontext);\n\treturn 0;\n}\n\nstatic void synchronize_callback(void *context, struct fib *fibptr)\n{\n\tstruct aac_synchronize_reply *synchronizereply;\n\tstruct scsi_cmnd *cmd = context;\n\n\tif (!aac_valid_context(cmd, fibptr))\n\t\treturn;\n\n\tdprintk((KERN_DEBUG \"synchronize_callback[cpu %d]: t = %ld.\\n\",\n\t\t\t\tsmp_processor_id(), jiffies));\n\tBUG_ON(fibptr == NULL);\n\n\n\tsynchronizereply = fib_data(fibptr);\n\tif (le32_to_cpu(synchronizereply->status) == CT_OK)\n\t\tcmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\telse {\n\t\tstruct scsi_device *sdev = cmd->device;\n\t\tstruct aac_dev *dev = fibptr->dev;\n\t\tu32 cid = sdev_id(sdev);\n\t\tprintk(KERN_WARNING\n\t\t     \"synchronize_callback: synchronize failed, status = %d\\n\",\n\t\t     le32_to_cpu(synchronizereply->status));\n\t\tcmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t  HARDWARE_ERROR, SENCODE_INTERNAL_TARGET_FAILURE,\n\t\t  ASENCODE_INTERNAL_TARGET_FAILURE, 0, 0);\n\t\tmemcpy(cmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t       min_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t}\n\n\taac_fib_complete(fibptr);\n\taac_fib_free(fibptr);\n\taac_scsi_done(cmd);\n}\n\nstatic int aac_synchronize(struct scsi_cmnd *scsicmd)\n{\n\tint status;\n\tstruct fib *cmd_fibcontext;\n\tstruct aac_synchronize *synchronizecmd;\n\tstruct scsi_device *sdev = scsicmd->device;\n\tstruct aac_dev *aac;\n\n\taac = (struct aac_dev *)sdev->host->hostdata;\n\tif (aac->in_reset)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t \n\tcmd_fibcontext = aac_fib_alloc_tag(aac, scsicmd);\n\n\taac_fib_init(cmd_fibcontext);\n\n\tsynchronizecmd = fib_data(cmd_fibcontext);\n\tsynchronizecmd->command = cpu_to_le32(VM_ContainerConfig);\n\tsynchronizecmd->type = cpu_to_le32(CT_FLUSH_CACHE);\n\tsynchronizecmd->cid = cpu_to_le32(scmd_id(scsicmd));\n\tsynchronizecmd->count =\n\t     cpu_to_le32(sizeof(((struct aac_synchronize_reply *)NULL)->data));\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\n\t \n\tstatus = aac_fib_send(ContainerCommand,\n\t\t  cmd_fibcontext,\n\t\t  sizeof(struct aac_synchronize),\n\t\t  FsaNormal,\n\t\t  0, 1,\n\t\t  (fib_callback)synchronize_callback,\n\t\t  (void *)scsicmd);\n\n\t \n\tif (status == -EINPROGRESS)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING\n\t\t\"aac_synchronize: aac_fib_send failed with status: %d.\\n\", status);\n\taac_fib_complete(cmd_fibcontext);\n\taac_fib_free(cmd_fibcontext);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\nstatic void aac_start_stop_callback(void *context, struct fib *fibptr)\n{\n\tstruct scsi_cmnd *scsicmd = context;\n\n\tif (!aac_valid_context(scsicmd, fibptr))\n\t\treturn;\n\n\tBUG_ON(fibptr == NULL);\n\n\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\n\taac_fib_complete(fibptr);\n\taac_fib_free(fibptr);\n\taac_scsi_done(scsicmd);\n}\n\nstatic int aac_start_stop(struct scsi_cmnd *scsicmd)\n{\n\tint status;\n\tstruct fib *cmd_fibcontext;\n\tstruct aac_power_management *pmcmd;\n\tstruct scsi_device *sdev = scsicmd->device;\n\tstruct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;\n\n\tif (!(aac->supplement_adapter_info.supported_options2 &\n\t      AAC_OPTION_POWER_MANAGEMENT)) {\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\taac_scsi_done(scsicmd);\n\t\treturn 0;\n\t}\n\n\tif (aac->in_reset)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t \n\tcmd_fibcontext = aac_fib_alloc_tag(aac, scsicmd);\n\n\taac_fib_init(cmd_fibcontext);\n\n\tpmcmd = fib_data(cmd_fibcontext);\n\tpmcmd->command = cpu_to_le32(VM_ContainerConfig);\n\tpmcmd->type = cpu_to_le32(CT_POWER_MANAGEMENT);\n\t \n\tpmcmd->sub = (scsicmd->cmnd[4] & 1) ?\n\t\tcpu_to_le32(CT_PM_START_UNIT) : cpu_to_le32(CT_PM_STOP_UNIT);\n\tpmcmd->cid = cpu_to_le32(sdev_id(sdev));\n\tpmcmd->parm = (scsicmd->cmnd[1] & 1) ?\n\t\tcpu_to_le32(CT_PM_UNIT_IMMEDIATE) : 0;\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\n\t \n\tstatus = aac_fib_send(ContainerCommand,\n\t\t  cmd_fibcontext,\n\t\t  sizeof(struct aac_power_management),\n\t\t  FsaNormal,\n\t\t  0, 1,\n\t\t  (fib_callback)aac_start_stop_callback,\n\t\t  (void *)scsicmd);\n\n\t \n\tif (status == -EINPROGRESS)\n\t\treturn 0;\n\n\taac_fib_complete(cmd_fibcontext);\n\taac_fib_free(cmd_fibcontext);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n \n\nint aac_scsi_cmd(struct scsi_cmnd * scsicmd)\n{\n\tu32 cid, bus;\n\tstruct Scsi_Host *host = scsicmd->device->host;\n\tstruct aac_dev *dev = (struct aac_dev *)host->hostdata;\n\tstruct fsa_dev_info *fsa_dev_ptr = dev->fsa_dev;\n\n\tif (fsa_dev_ptr == NULL)\n\t\treturn -1;\n\t \n\tcid = scmd_id(scsicmd);\n\tif (cid != host->this_id) {\n\t\tif (scmd_channel(scsicmd) == CONTAINER_CHANNEL) {\n\t\t\tif((cid >= dev->maximum_num_containers) ||\n\t\t\t\t\t(scsicmd->device->lun != 0)) {\n\t\t\t\tscsicmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tgoto scsi_done_ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (((fsa_dev_ptr[cid].valid & 1) == 0) ||\n\t\t\t  (fsa_dev_ptr[cid].sense_data.sense_key ==\n\t\t\t   NOT_READY)) {\n\t\t\t\tswitch (scsicmd->cmnd[0]) {\n\t\t\t\tcase SERVICE_ACTION_IN_16:\n\t\t\t\t\tif (!(dev->raw_io_interface) ||\n\t\t\t\t\t    !(dev->raw_io_64) ||\n\t\t\t\t\t    ((scsicmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase INQUIRY:\n\t\t\t\tcase READ_CAPACITY:\n\t\t\t\tcase TEST_UNIT_READY:\n\t\t\t\t\tif (dev->in_reset)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\treturn _aac_probe_container(scsicmd,\n\t\t\t\t\t\t\taac_probe_container_callback2);\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {   \n\t\t\tbus = aac_logical_to_phys(scmd_channel(scsicmd));\n\n\t\t\tif (bus < AAC_MAX_BUSES && cid < AAC_MAX_TARGETS &&\n\t\t\t\tdev->hba_map[bus][cid].devtype\n\t\t\t\t\t== AAC_DEVTYPE_NATIVE_RAW) {\n\t\t\t\tif (dev->in_reset)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn aac_send_hba_fib(scsicmd);\n\t\t\t} else if (dev->nondasd_support || expose_physicals ||\n\t\t\t\tdev->jbod) {\n\t\t\t\tif (dev->in_reset)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn aac_send_srb_fib(scsicmd);\n\t\t\t} else {\n\t\t\t\tscsicmd->result = DID_NO_CONNECT << 16;\n\t\t\t\tgoto scsi_done_ret;\n\t\t\t}\n\t\t}\n\t}\n\t \n\telse if ((scsicmd->cmnd[0] != INQUIRY) &&\t \n\t\t(scsicmd->cmnd[0] != TEST_UNIT_READY))\n\t{\n\t\tdprintk((KERN_WARNING \"Only INQUIRY & TUR command supported for controller, rcvd = 0x%x.\\n\", scsicmd->cmnd[0]));\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t  ILLEGAL_REQUEST, SENCODE_INVALID_COMMAND,\n\t\t  ASENCODE_INVALID_COMMAND, 0, 0);\n\t\tmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t       min_t(size_t, sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\tgoto scsi_done_ret;\n\t}\n\n\tswitch (scsicmd->cmnd[0]) {\n\tcase READ_6:\n\tcase READ_10:\n\tcase READ_12:\n\tcase READ_16:\n\t\tif (dev->in_reset)\n\t\t\treturn -1;\n\t\treturn aac_read(scsicmd);\n\n\tcase WRITE_6:\n\tcase WRITE_10:\n\tcase WRITE_12:\n\tcase WRITE_16:\n\t\tif (dev->in_reset)\n\t\t\treturn -1;\n\t\treturn aac_write(scsicmd);\n\n\tcase SYNCHRONIZE_CACHE:\n\t\tif (((aac_cache & 6) == 6) && dev->cache_protected) {\n\t\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif ((aac_cache & 6) != 2)\n\t\t\treturn aac_synchronize(scsicmd);\n\t\tfallthrough;\n\tcase INQUIRY:\n\t{\n\t\tstruct inquiry_data inq_data;\n\n\t\tdprintk((KERN_DEBUG \"INQUIRY command, ID: %d.\\n\", cid));\n\t\tmemset(&inq_data, 0, sizeof (struct inquiry_data));\n\n\t\tif ((scsicmd->cmnd[1] & 0x1) && aac_wwn) {\n\t\t\tchar *arr = (char *)&inq_data;\n\n\t\t\t \n\t\t\tarr[0] = (scmd_id(scsicmd) == host->this_id) ?\n\t\t\t  INQD_PDT_PROC : INQD_PDT_DA;\n\t\t\tif (scsicmd->cmnd[2] == 0) {\n\t\t\t\t \n\t\t\t\tarr[3] = 3;\n\t\t\t\tarr[4] = 0x0;\n\t\t\t\tarr[5] = 0x80;\n\t\t\t\tarr[6] = 0x83;\n\t\t\t\tarr[1] = scsicmd->cmnd[2];\n\t\t\t\tscsi_sg_copy_from_buffer(scsicmd, &inq_data,\n\t\t\t\t\t\t\t sizeof(inq_data));\n\t\t\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\t\t} else if (scsicmd->cmnd[2] == 0x80) {\n\t\t\t\t \n\t\t\t\tarr[3] = setinqserial(dev, &arr[4],\n\t\t\t\t  scmd_id(scsicmd));\n\t\t\t\tarr[1] = scsicmd->cmnd[2];\n\t\t\t\tscsi_sg_copy_from_buffer(scsicmd, &inq_data,\n\t\t\t\t\t\t\t sizeof(inq_data));\n\t\t\t\tif (aac_wwn != 2)\n\t\t\t\t\treturn aac_get_container_serial(\n\t\t\t\t\t\tscsicmd);\n\t\t\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\t\t} else if (scsicmd->cmnd[2] == 0x83) {\n\t\t\t\t \n\t\t\t\tchar *sno = (char *)&inq_data;\n\t\t\t\tsno[3] = setinqserial(dev, &sno[4],\n\t\t\t\t\t\t      scmd_id(scsicmd));\n\t\t\t\tif (aac_wwn != 2)\n\t\t\t\t\treturn aac_get_container_serial(\n\t\t\t\t\t\tscsicmd);\n\t\t\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\t\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t\t\t  ILLEGAL_REQUEST, SENCODE_INVALID_CDB_FIELD,\n\t\t\t\t  ASENCODE_NO_SENSE, 7, 2);\n\t\t\t\tmemcpy(scsicmd->sense_buffer,\n\t\t\t\t  &dev->fsa_dev[cid].sense_data,\n\t\t\t\t  min_t(size_t,\n\t\t\t\t\tsizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t\t\tSCSI_SENSE_BUFFERSIZE));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tinq_data.inqd_ver = 2;\t \n\t\tinq_data.inqd_rdf = 2;\t \n\t\tinq_data.inqd_len = 31;\n\t\t \n\t\tinq_data.inqd_pad2= 0x32 ;\t  \n\t\t \n\t\tif (cid == host->this_id) {\n\t\t\tsetinqstr(dev, (void *) (inq_data.inqd_vid), ARRAY_SIZE(container_types));\n\t\t\tinq_data.inqd_pdt = INQD_PDT_PROC;\t \n\t\t\tscsi_sg_copy_from_buffer(scsicmd, &inq_data,\n\t\t\t\t\t\t sizeof(inq_data));\n\t\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\t\tbreak;\n\t\t}\n\t\tif (dev->in_reset)\n\t\t\treturn -1;\n\t\tsetinqstr(dev, (void *) (inq_data.inqd_vid), fsa_dev_ptr[cid].type);\n\t\tinq_data.inqd_pdt = INQD_PDT_DA;\t \n\t\tscsi_sg_copy_from_buffer(scsicmd, &inq_data, sizeof(inq_data));\n\t\treturn aac_get_container_name(scsicmd);\n\t}\n\tcase SERVICE_ACTION_IN_16:\n\t\tif (!(dev->raw_io_interface) ||\n\t\t    !(dev->raw_io_64) ||\n\t\t    ((scsicmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))\n\t\t\tbreak;\n\t{\n\t\tu64 capacity;\n\t\tchar cp[13];\n\t\tunsigned int alloc_len;\n\n\t\tdprintk((KERN_DEBUG \"READ CAPACITY_16 command.\\n\"));\n\t\tcapacity = fsa_dev_ptr[cid].size - 1;\n\t\tcp[0] = (capacity >> 56) & 0xff;\n\t\tcp[1] = (capacity >> 48) & 0xff;\n\t\tcp[2] = (capacity >> 40) & 0xff;\n\t\tcp[3] = (capacity >> 32) & 0xff;\n\t\tcp[4] = (capacity >> 24) & 0xff;\n\t\tcp[5] = (capacity >> 16) & 0xff;\n\t\tcp[6] = (capacity >> 8) & 0xff;\n\t\tcp[7] = (capacity >> 0) & 0xff;\n\t\tcp[8] = (fsa_dev_ptr[cid].block_size >> 24) & 0xff;\n\t\tcp[9] = (fsa_dev_ptr[cid].block_size >> 16) & 0xff;\n\t\tcp[10] = (fsa_dev_ptr[cid].block_size >> 8) & 0xff;\n\t\tcp[11] = (fsa_dev_ptr[cid].block_size) & 0xff;\n\t\tcp[12] = 0;\n\n\t\talloc_len = ((scsicmd->cmnd[10] << 24)\n\t\t\t     + (scsicmd->cmnd[11] << 16)\n\t\t\t     + (scsicmd->cmnd[12] << 8) + scsicmd->cmnd[13]);\n\n\t\talloc_len = min_t(size_t, alloc_len, sizeof(cp));\n\t\tscsi_sg_copy_from_buffer(scsicmd, cp, alloc_len);\n\t\tif (alloc_len < scsi_bufflen(scsicmd))\n\t\t\tscsi_set_resid(scsicmd,\n\t\t\t\t       scsi_bufflen(scsicmd) - alloc_len);\n\n\t\t \n\t\tscsicmd->device->removable = 1;\n\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\tbreak;\n\t}\n\n\tcase READ_CAPACITY:\n\t{\n\t\tu32 capacity;\n\t\tchar cp[8];\n\n\t\tdprintk((KERN_DEBUG \"READ CAPACITY command.\\n\"));\n\t\tif (fsa_dev_ptr[cid].size <= 0x100000000ULL)\n\t\t\tcapacity = fsa_dev_ptr[cid].size - 1;\n\t\telse\n\t\t\tcapacity = (u32)-1;\n\n\t\tcp[0] = (capacity >> 24) & 0xff;\n\t\tcp[1] = (capacity >> 16) & 0xff;\n\t\tcp[2] = (capacity >> 8) & 0xff;\n\t\tcp[3] = (capacity >> 0) & 0xff;\n\t\tcp[4] = (fsa_dev_ptr[cid].block_size >> 24) & 0xff;\n\t\tcp[5] = (fsa_dev_ptr[cid].block_size >> 16) & 0xff;\n\t\tcp[6] = (fsa_dev_ptr[cid].block_size >> 8) & 0xff;\n\t\tcp[7] = (fsa_dev_ptr[cid].block_size) & 0xff;\n\t\tscsi_sg_copy_from_buffer(scsicmd, cp, sizeof(cp));\n\t\t \n\t\tscsicmd->device->removable = 1;\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\tbreak;\n\t}\n\n\tcase MODE_SENSE:\n\t{\n\t\tint mode_buf_length = 4;\n\t\tu32 capacity;\n\t\taac_modep_data mpd;\n\n\t\tif (fsa_dev_ptr[cid].size <= 0x100000000ULL)\n\t\t\tcapacity = fsa_dev_ptr[cid].size - 1;\n\t\telse\n\t\t\tcapacity = (u32)-1;\n\n\t\tdprintk((KERN_DEBUG \"MODE SENSE command.\\n\"));\n\t\tmemset((char *)&mpd, 0, sizeof(aac_modep_data));\n\n\t\t \n\t\tmpd.hd.data_length = sizeof(mpd.hd) - 1;\n\t\t \n\t\tmpd.hd.med_type = 0;\n\t\t \n\t\tmpd.hd.dev_par = 0;\n\n\t\tif (dev->raw_io_interface && ((aac_cache & 5) != 1))\n\t\t\tmpd.hd.dev_par = 0x10;\n\t\tif (scsicmd->cmnd[1] & 0x8)\n\t\t\tmpd.hd.bd_length = 0;\t \n\t\telse {\n\t\t\tmpd.hd.bd_length = sizeof(mpd.bd);\n\t\t\tmpd.hd.data_length += mpd.hd.bd_length;\n\t\t\tmpd.bd.block_length[0] =\n\t\t\t\t(fsa_dev_ptr[cid].block_size >> 16) & 0xff;\n\t\t\tmpd.bd.block_length[1] =\n\t\t\t\t(fsa_dev_ptr[cid].block_size >> 8) &  0xff;\n\t\t\tmpd.bd.block_length[2] =\n\t\t\t\tfsa_dev_ptr[cid].block_size  & 0xff;\n\n\t\t\tmpd.mpc_buf[0] = scsicmd->cmnd[2];\n\t\t\tif (scsicmd->cmnd[2] == 0x1C) {\n\t\t\t\t \n\t\t\t\tmpd.mpc_buf[1] = 0xa;\n\t\t\t\t \n\t\t\t\tmpd.hd.data_length = 23;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmpd.hd.data_length = 15;\n\t\t\t}\n\n\t\t\tif (capacity > 0xffffff) {\n\t\t\t\tmpd.bd.block_count[0] = 0xff;\n\t\t\t\tmpd.bd.block_count[1] = 0xff;\n\t\t\t\tmpd.bd.block_count[2] = 0xff;\n\t\t\t} else {\n\t\t\t\tmpd.bd.block_count[0] = (capacity >> 16) & 0xff;\n\t\t\t\tmpd.bd.block_count[1] = (capacity >> 8) & 0xff;\n\t\t\t\tmpd.bd.block_count[2] = capacity  & 0xff;\n\t\t\t}\n\t\t}\n\t\tif (((scsicmd->cmnd[2] & 0x3f) == 8) ||\n\t\t  ((scsicmd->cmnd[2] & 0x3f) == 0x3f)) {\n\t\t\tmpd.hd.data_length += 3;\n\t\t\tmpd.mpc_buf[0] = 8;\n\t\t\tmpd.mpc_buf[1] = 1;\n\t\t\tmpd.mpc_buf[2] = ((aac_cache & 6) == 2)\n\t\t\t\t? 0 : 0x04;  \n\t\t\tmode_buf_length = sizeof(mpd);\n\t\t}\n\n\t\tif (mode_buf_length > scsicmd->cmnd[4])\n\t\t\tmode_buf_length = scsicmd->cmnd[4];\n\t\telse\n\t\t\tmode_buf_length = sizeof(mpd);\n\t\tscsi_sg_copy_from_buffer(scsicmd,\n\t\t\t\t\t (char *)&mpd,\n\t\t\t\t\t mode_buf_length);\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\tbreak;\n\t}\n\tcase MODE_SENSE_10:\n\t{\n\t\tu32 capacity;\n\t\tint mode_buf_length = 8;\n\t\taac_modep10_data mpd10;\n\n\t\tif (fsa_dev_ptr[cid].size <= 0x100000000ULL)\n\t\t\tcapacity = fsa_dev_ptr[cid].size - 1;\n\t\telse\n\t\t\tcapacity = (u32)-1;\n\n\t\tdprintk((KERN_DEBUG \"MODE SENSE 10 byte command.\\n\"));\n\t\tmemset((char *)&mpd10, 0, sizeof(aac_modep10_data));\n\t\t \n\t\tmpd10.hd.data_length[0] = 0;\n\t\t \n\t\tmpd10.hd.data_length[1] = sizeof(mpd10.hd) - 1;\n\t\t \n\t\tmpd10.hd.med_type = 0;\n\t\t \n\t\tmpd10.hd.dev_par = 0;\n\n\t\tif (dev->raw_io_interface && ((aac_cache & 5) != 1))\n\t\t\tmpd10.hd.dev_par = 0x10;\n\t\tmpd10.hd.rsrvd[0] = 0;\t \n\t\tmpd10.hd.rsrvd[1] = 0;\t \n\t\tif (scsicmd->cmnd[1] & 0x8) {\n\t\t\t \n\t\t\tmpd10.hd.bd_length[0] = 0;\n\t\t\t \n\t\t\tmpd10.hd.bd_length[1] = 0;\n\t\t} else {\n\t\t\tmpd10.hd.bd_length[0] = 0;\n\t\t\tmpd10.hd.bd_length[1] = sizeof(mpd10.bd);\n\n\t\t\tmpd10.hd.data_length[1] += mpd10.hd.bd_length[1];\n\n\t\t\tmpd10.bd.block_length[0] =\n\t\t\t\t(fsa_dev_ptr[cid].block_size >> 16) & 0xff;\n\t\t\tmpd10.bd.block_length[1] =\n\t\t\t\t(fsa_dev_ptr[cid].block_size >> 8) & 0xff;\n\t\t\tmpd10.bd.block_length[2] =\n\t\t\t\tfsa_dev_ptr[cid].block_size  & 0xff;\n\n\t\t\tif (capacity > 0xffffff) {\n\t\t\t\tmpd10.bd.block_count[0] = 0xff;\n\t\t\t\tmpd10.bd.block_count[1] = 0xff;\n\t\t\t\tmpd10.bd.block_count[2] = 0xff;\n\t\t\t} else {\n\t\t\t\tmpd10.bd.block_count[0] =\n\t\t\t\t\t(capacity >> 16) & 0xff;\n\t\t\t\tmpd10.bd.block_count[1] =\n\t\t\t\t\t(capacity >> 8) & 0xff;\n\t\t\t\tmpd10.bd.block_count[2] =\n\t\t\t\t\tcapacity  & 0xff;\n\t\t\t}\n\t\t}\n\t\tif (((scsicmd->cmnd[2] & 0x3f) == 8) ||\n\t\t  ((scsicmd->cmnd[2] & 0x3f) == 0x3f)) {\n\t\t\tmpd10.hd.data_length[1] += 3;\n\t\t\tmpd10.mpc_buf[0] = 8;\n\t\t\tmpd10.mpc_buf[1] = 1;\n\t\t\tmpd10.mpc_buf[2] = ((aac_cache & 6) == 2)\n\t\t\t\t? 0 : 0x04;  \n\t\t\tmode_buf_length = sizeof(mpd10);\n\t\t\tif (mode_buf_length > scsicmd->cmnd[8])\n\t\t\t\tmode_buf_length = scsicmd->cmnd[8];\n\t\t}\n\t\tscsi_sg_copy_from_buffer(scsicmd,\n\t\t\t\t\t (char *)&mpd10,\n\t\t\t\t\t mode_buf_length);\n\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\tbreak;\n\t}\n\tcase REQUEST_SENSE:\n\t\tdprintk((KERN_DEBUG \"REQUEST SENSE command.\\n\"));\n\t\tmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t\t\tsizeof(struct sense_data));\n\t\tmemset(&dev->fsa_dev[cid].sense_data, 0,\n\t\t\t\tsizeof(struct sense_data));\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\tbreak;\n\n\tcase ALLOW_MEDIUM_REMOVAL:\n\t\tdprintk((KERN_DEBUG \"LOCK command.\\n\"));\n\t\tif (scsicmd->cmnd[4])\n\t\t\tfsa_dev_ptr[cid].locked = 1;\n\t\telse\n\t\t\tfsa_dev_ptr[cid].locked = 0;\n\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\tbreak;\n\t \n\tcase TEST_UNIT_READY:\n\t\tif (fsa_dev_ptr[cid].sense_data.sense_key == NOT_READY) {\n\t\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t\t\t  NOT_READY, SENCODE_BECOMING_READY,\n\t\t\t\t  ASENCODE_BECOMING_READY, 0, 0);\n\t\t\tmemcpy(scsicmd->sense_buffer,\n\t\t\t       &dev->fsa_dev[cid].sense_data,\n\t\t\t       min_t(size_t,\n\t\t\t\t     sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t\t     SCSI_SENSE_BUFFERSIZE));\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase RESERVE:\n\tcase RELEASE:\n\tcase REZERO_UNIT:\n\tcase REASSIGN_BLOCKS:\n\tcase SEEK_10:\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_GOOD;\n\t\tbreak;\n\n\tcase START_STOP:\n\t\treturn aac_start_stop(scsicmd);\n\n\tdefault:\n\t \n\t\tdprintk((KERN_WARNING \"Unhandled SCSI Command: 0x%x.\\n\",\n\t\t\t\tscsicmd->cmnd[0]));\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tset_sense(&dev->fsa_dev[cid].sense_data,\n\t\t\t  ILLEGAL_REQUEST, SENCODE_INVALID_COMMAND,\n\t\t\t  ASENCODE_INVALID_COMMAND, 0, 0);\n\t\tmemcpy(scsicmd->sense_buffer, &dev->fsa_dev[cid].sense_data,\n\t\t\t\tmin_t(size_t,\n\t\t\t\t      sizeof(dev->fsa_dev[cid].sense_data),\n\t\t\t\t      SCSI_SENSE_BUFFERSIZE));\n\t}\n\nscsi_done_ret:\n\n\taac_scsi_done(scsicmd);\n\treturn 0;\n}\n\nstatic int query_disk(struct aac_dev *dev, void __user *arg)\n{\n\tstruct aac_query_disk qd;\n\tstruct fsa_dev_info *fsa_dev_ptr;\n\n\tfsa_dev_ptr = dev->fsa_dev;\n\tif (!fsa_dev_ptr)\n\t\treturn -EBUSY;\n\tif (copy_from_user(&qd, arg, sizeof (struct aac_query_disk)))\n\t\treturn -EFAULT;\n\tif (qd.cnum == -1) {\n\t\tif (qd.id < 0 || qd.id >= dev->maximum_num_containers)\n\t\t\treturn -EINVAL;\n\t\tqd.cnum = qd.id;\n\t} else if ((qd.bus == -1) && (qd.id == -1) && (qd.lun == -1)) {\n\t\tif (qd.cnum < 0 || qd.cnum >= dev->maximum_num_containers)\n\t\t\treturn -EINVAL;\n\t\tqd.instance = dev->scsi_host_ptr->host_no;\n\t\tqd.bus = 0;\n\t\tqd.id = CONTAINER_TO_ID(qd.cnum);\n\t\tqd.lun = CONTAINER_TO_LUN(qd.cnum);\n\t}\n\telse return -EINVAL;\n\n\tqd.valid = fsa_dev_ptr[qd.cnum].valid != 0;\n\tqd.locked = fsa_dev_ptr[qd.cnum].locked;\n\tqd.deleted = fsa_dev_ptr[qd.cnum].deleted;\n\n\tif (fsa_dev_ptr[qd.cnum].devname[0] == '\\0')\n\t\tqd.unmapped = 1;\n\telse\n\t\tqd.unmapped = 0;\n\n\tstrscpy(qd.name, fsa_dev_ptr[qd.cnum].devname,\n\t  min(sizeof(qd.name), sizeof(fsa_dev_ptr[qd.cnum].devname) + 1));\n\n\tif (copy_to_user(arg, &qd, sizeof (struct aac_query_disk)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int force_delete_disk(struct aac_dev *dev, void __user *arg)\n{\n\tstruct aac_delete_disk dd;\n\tstruct fsa_dev_info *fsa_dev_ptr;\n\n\tfsa_dev_ptr = dev->fsa_dev;\n\tif (!fsa_dev_ptr)\n\t\treturn -EBUSY;\n\n\tif (copy_from_user(&dd, arg, sizeof (struct aac_delete_disk)))\n\t\treturn -EFAULT;\n\n\tif (dd.cnum >= dev->maximum_num_containers)\n\t\treturn -EINVAL;\n\t \n\tfsa_dev_ptr[dd.cnum].deleted = 1;\n\t \n\tfsa_dev_ptr[dd.cnum].valid = 0;\n\treturn 0;\n}\n\nstatic int delete_disk(struct aac_dev *dev, void __user *arg)\n{\n\tstruct aac_delete_disk dd;\n\tstruct fsa_dev_info *fsa_dev_ptr;\n\n\tfsa_dev_ptr = dev->fsa_dev;\n\tif (!fsa_dev_ptr)\n\t\treturn -EBUSY;\n\n\tif (copy_from_user(&dd, arg, sizeof (struct aac_delete_disk)))\n\t\treturn -EFAULT;\n\n\tif (dd.cnum >= dev->maximum_num_containers)\n\t\treturn -EINVAL;\n\t \n\tif (fsa_dev_ptr[dd.cnum].locked)\n\t\treturn -EBUSY;\n\telse {\n\t\t \n\t\tfsa_dev_ptr[dd.cnum].valid = 0;\n\t\tfsa_dev_ptr[dd.cnum].devname[0] = '\\0';\n\t\treturn 0;\n\t}\n}\n\nint aac_dev_ioctl(struct aac_dev *dev, unsigned int cmd, void __user *arg)\n{\n\tswitch (cmd) {\n\tcase FSACTL_QUERY_DISK:\n\t\treturn query_disk(dev, arg);\n\tcase FSACTL_DELETE_DISK:\n\t\treturn delete_disk(dev, arg);\n\tcase FSACTL_FORCE_DELETE_DISK:\n\t\treturn force_delete_disk(dev, arg);\n\tcase FSACTL_GET_CONTAINERS:\n\t\treturn aac_get_containers(dev);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}\n\n \nstatic void aac_srb_callback(void *context, struct fib * fibptr)\n{\n\tstruct aac_srb_reply *srbreply;\n\tstruct scsi_cmnd *scsicmd;\n\n\tscsicmd = (struct scsi_cmnd *) context;\n\n\tif (!aac_valid_context(scsicmd, fibptr))\n\t\treturn;\n\n\tBUG_ON(fibptr == NULL);\n\n\tsrbreply = (struct aac_srb_reply *) fib_data(fibptr);\n\n\tscsicmd->sense_buffer[0] = '\\0';   \n\n\tif (fibptr->flags & FIB_CONTEXT_FLAG_FASTRESP) {\n\t\t \n\t\tsrbreply->srb_status = cpu_to_le32(SRB_STATUS_SUCCESS);\n\t\tsrbreply->scsi_status = cpu_to_le32(SAM_STAT_GOOD);\n\t} else {\n\t\t \n\t\tscsi_set_resid(scsicmd, scsi_bufflen(scsicmd)\n\t\t\t\t   - le32_to_cpu(srbreply->data_xfer_length));\n\t}\n\n\n\tscsi_dma_unmap(scsicmd);\n\n\t \n\tif (scsicmd->cmnd[0] == INQUIRY && !(scsicmd->cmnd[1] & 0x01)\n\t  && expose_physicals > 0)\n\t\taac_expose_phy_device(scsicmd);\n\n\t \n\n\tif (le32_to_cpu(srbreply->status) != ST_OK) {\n\t\tint len;\n\n\t\tpr_warn(\"aac_srb_callback: srb failed, status = %d\\n\",\n\t\t\t\tle32_to_cpu(srbreply->status));\n\t\tlen = min_t(u32, le32_to_cpu(srbreply->sense_data_size),\n\t\t\t    SCSI_SENSE_BUFFERSIZE);\n\t\tscsicmd->result = DID_ERROR << 16 | SAM_STAT_CHECK_CONDITION;\n\t\tmemcpy(scsicmd->sense_buffer,\n\t\t\t\tsrbreply->sense_data, len);\n\t}\n\n\t \n\tswitch ((le32_to_cpu(srbreply->srb_status))&0x3f) {\n\tcase SRB_STATUS_ERROR_RECOVERY:\n\tcase SRB_STATUS_PENDING:\n\tcase SRB_STATUS_SUCCESS:\n\t\tscsicmd->result = DID_OK << 16;\n\t\tbreak;\n\tcase SRB_STATUS_DATA_OVERRUN:\n\t\tswitch (scsicmd->cmnd[0]) {\n\t\tcase  READ_6:\n\t\tcase  WRITE_6:\n\t\tcase  READ_10:\n\t\tcase  WRITE_10:\n\t\tcase  READ_12:\n\t\tcase  WRITE_12:\n\t\tcase  READ_16:\n\t\tcase  WRITE_16:\n\t\t\tif (le32_to_cpu(srbreply->data_xfer_length)\n\t\t\t\t\t\t< scsicmd->underflow)\n\t\t\t\tpr_warn(\"aacraid: SCSI CMD underflow\\n\");\n\t\t\telse\n\t\t\t\tpr_warn(\"aacraid: SCSI CMD Data Overrun\\n\");\n\t\t\tscsicmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\tcase INQUIRY:\n\t\t\tscsicmd->result = DID_OK << 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscsicmd->result = DID_OK << 16;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SRB_STATUS_ABORTED:\n\t\tscsicmd->result = DID_ABORT << 16;\n\t\tbreak;\n\tcase SRB_STATUS_ABORT_FAILED:\n\t\t \n\t\tscsicmd->result = DID_ERROR << 16;\n\t\tbreak;\n\tcase SRB_STATUS_PARITY_ERROR:\n\t\tscsicmd->result = DID_PARITY << 16;\n\t\tbreak;\n\tcase SRB_STATUS_NO_DEVICE:\n\tcase SRB_STATUS_INVALID_PATH_ID:\n\tcase SRB_STATUS_INVALID_TARGET_ID:\n\tcase SRB_STATUS_INVALID_LUN:\n\tcase SRB_STATUS_SELECTION_TIMEOUT:\n\t\tscsicmd->result = DID_NO_CONNECT << 16;\n\t\tbreak;\n\n\tcase SRB_STATUS_COMMAND_TIMEOUT:\n\tcase SRB_STATUS_TIMEOUT:\n\t\tscsicmd->result = DID_TIME_OUT << 16;\n\t\tbreak;\n\n\tcase SRB_STATUS_BUSY:\n\t\tscsicmd->result = DID_BUS_BUSY << 16;\n\t\tbreak;\n\n\tcase SRB_STATUS_BUS_RESET:\n\t\tscsicmd->result = DID_RESET << 16;\n\t\tbreak;\n\n\tcase SRB_STATUS_MESSAGE_REJECTED:\n\t\tscsicmd->result = DID_ERROR << 16;\n\t\tbreak;\n\tcase SRB_STATUS_REQUEST_FLUSHED:\n\tcase SRB_STATUS_ERROR:\n\tcase SRB_STATUS_INVALID_REQUEST:\n\tcase SRB_STATUS_REQUEST_SENSE_FAILED:\n\tcase SRB_STATUS_NO_HBA:\n\tcase SRB_STATUS_UNEXPECTED_BUS_FREE:\n\tcase SRB_STATUS_PHASE_SEQUENCE_FAILURE:\n\tcase SRB_STATUS_BAD_SRB_BLOCK_LENGTH:\n\tcase SRB_STATUS_DELAYED_RETRY:\n\tcase SRB_STATUS_BAD_FUNCTION:\n\tcase SRB_STATUS_NOT_STARTED:\n\tcase SRB_STATUS_NOT_IN_USE:\n\tcase SRB_STATUS_FORCE_ABORT:\n\tcase SRB_STATUS_DOMAIN_VALIDATION_FAIL:\n\tdefault:\n#ifdef AAC_DETAILED_STATUS_INFO\n\t\tpr_info(\"aacraid: SRB ERROR(%u) %s scsi cmd 0x%x -scsi status 0x%x\\n\",\n\t\t\tle32_to_cpu(srbreply->srb_status) & 0x3F,\n\t\t\taac_get_status_string(\n\t\t\t\tle32_to_cpu(srbreply->srb_status) & 0x3F),\n\t\t\tscsicmd->cmnd[0],\n\t\t\tle32_to_cpu(srbreply->scsi_status));\n#endif\n\t\t \n\t\tif ((scsicmd->cmnd[0] == ATA_12)\n\t\t\t|| (scsicmd->cmnd[0] == ATA_16)) {\n\n\t\t\tif (scsicmd->cmnd[2] & (0x01 << 5)) {\n\t\t\t\tscsicmd->result = DID_OK << 16;\n\t\t\t} else {\n\t\t\t\tscsicmd->result = DID_ERROR << 16;\n\t\t\t}\n\t\t} else {\n\t\t\tscsicmd->result = DID_ERROR << 16;\n\t\t}\n\t\tbreak;\n\t}\n\tif (le32_to_cpu(srbreply->scsi_status)\n\t\t\t== SAM_STAT_CHECK_CONDITION) {\n\t\tint len;\n\n\t\tscsicmd->result |= SAM_STAT_CHECK_CONDITION;\n\t\tlen = min_t(u32, le32_to_cpu(srbreply->sense_data_size),\n\t\t\t    SCSI_SENSE_BUFFERSIZE);\n#ifdef AAC_DETAILED_STATUS_INFO\n\t\tpr_warn(\"aac_srb_callback: check condition, status = %d len=%d\\n\",\n\t\t\t\t\tle32_to_cpu(srbreply->status), len);\n#endif\n\t\tmemcpy(scsicmd->sense_buffer,\n\t\t\t\tsrbreply->sense_data, len);\n\t}\n\n\t \n\tscsicmd->result |= le32_to_cpu(srbreply->scsi_status);\n\n\taac_fib_complete(fibptr);\n\taac_scsi_done(scsicmd);\n}\n\nstatic void hba_resp_task_complete(struct aac_dev *dev,\n\t\t\t\t\tstruct scsi_cmnd *scsicmd,\n\t\t\t\t\tstruct aac_hba_resp *err) {\n\n\tscsicmd->result = err->status;\n\t \n\tscsi_set_resid(scsicmd, le32_to_cpu(err->residual_count));\n\n\tswitch (err->status) {\n\tcase SAM_STAT_GOOD:\n\t\tscsicmd->result |= DID_OK << 16;\n\t\tbreak;\n\tcase SAM_STAT_CHECK_CONDITION:\n\t{\n\t\tint len;\n\n\t\tlen = min_t(u8, err->sense_response_data_len,\n\t\t\tSCSI_SENSE_BUFFERSIZE);\n\t\tif (len)\n\t\t\tmemcpy(scsicmd->sense_buffer,\n\t\t\t\terr->sense_response_buf, len);\n\t\tscsicmd->result |= DID_OK << 16;\n\t\tbreak;\n\t}\n\tcase SAM_STAT_BUSY:\n\t\tscsicmd->result |= DID_BUS_BUSY << 16;\n\t\tbreak;\n\tcase SAM_STAT_TASK_ABORTED:\n\t\tscsicmd->result |= DID_ABORT << 16;\n\t\tbreak;\n\tcase SAM_STAT_RESERVATION_CONFLICT:\n\tcase SAM_STAT_TASK_SET_FULL:\n\tdefault:\n\t\tscsicmd->result |= DID_ERROR << 16;\n\t\tbreak;\n\t}\n}\n\nstatic void hba_resp_task_failure(struct aac_dev *dev,\n\t\t\t\t\tstruct scsi_cmnd *scsicmd,\n\t\t\t\t\tstruct aac_hba_resp *err)\n{\n\tswitch (err->status) {\n\tcase HBA_RESP_STAT_HBAMODE_DISABLED:\n\t{\n\t\tu32 bus, cid;\n\n\t\tbus = aac_logical_to_phys(scmd_channel(scsicmd));\n\t\tcid = scmd_id(scsicmd);\n\t\tif (dev->hba_map[bus][cid].devtype == AAC_DEVTYPE_NATIVE_RAW) {\n\t\t\tdev->hba_map[bus][cid].devtype = AAC_DEVTYPE_ARC_RAW;\n\t\t\tdev->hba_map[bus][cid].rmw_nexus = 0xffffffff;\n\t\t}\n\t\tscsicmd->result = DID_NO_CONNECT << 16;\n\t\tbreak;\n\t}\n\tcase HBA_RESP_STAT_IO_ERROR:\n\tcase HBA_RESP_STAT_NO_PATH_TO_DEVICE:\n\t\tscsicmd->result = DID_OK << 16 | SAM_STAT_BUSY;\n\t\tbreak;\n\tcase HBA_RESP_STAT_IO_ABORTED:\n\t\tscsicmd->result = DID_ABORT << 16;\n\t\tbreak;\n\tcase HBA_RESP_STAT_INVALID_DEVICE:\n\t\tscsicmd->result = DID_NO_CONNECT << 16;\n\t\tbreak;\n\tcase HBA_RESP_STAT_UNDERRUN:\n\t\t \n\t\tscsicmd->result = DID_OK << 16;\n\t\tbreak;\n\tcase HBA_RESP_STAT_OVERRUN:\n\tdefault:\n\t\tscsicmd->result = DID_ERROR << 16;\n\t\tbreak;\n\t}\n}\n\n \nvoid aac_hba_callback(void *context, struct fib *fibptr)\n{\n\tstruct aac_dev *dev;\n\tstruct scsi_cmnd *scsicmd;\n\n\tstruct aac_hba_resp *err =\n\t\t\t&((struct aac_native_hba *)fibptr->hw_fib_va)->resp.err;\n\n\tscsicmd = (struct scsi_cmnd *) context;\n\n\tif (!aac_valid_context(scsicmd, fibptr))\n\t\treturn;\n\n\tWARN_ON(fibptr == NULL);\n\tdev = fibptr->dev;\n\n\tif (!(fibptr->flags & FIB_CONTEXT_FLAG_NATIVE_HBA_TMF))\n\t\tscsi_dma_unmap(scsicmd);\n\n\tif (fibptr->flags & FIB_CONTEXT_FLAG_FASTRESP) {\n\t\t \n\t\tscsicmd->result = DID_OK << 16;\n\t\tgoto out;\n\t}\n\n\tswitch (err->service_response) {\n\tcase HBA_RESP_SVCRES_TASK_COMPLETE:\n\t\thba_resp_task_complete(dev, scsicmd, err);\n\t\tbreak;\n\tcase HBA_RESP_SVCRES_FAILURE:\n\t\thba_resp_task_failure(dev, scsicmd, err);\n\t\tbreak;\n\tcase HBA_RESP_SVCRES_TMF_REJECTED:\n\t\tscsicmd->result = DID_ERROR << 16;\n\t\tbreak;\n\tcase HBA_RESP_SVCRES_TMF_LUN_INVALID:\n\t\tscsicmd->result = DID_NO_CONNECT << 16;\n\t\tbreak;\n\tcase HBA_RESP_SVCRES_TMF_COMPLETE:\n\tcase HBA_RESP_SVCRES_TMF_SUCCEEDED:\n\t\tscsicmd->result = DID_OK << 16;\n\t\tbreak;\n\tdefault:\n\t\tscsicmd->result = DID_ERROR << 16;\n\t\tbreak;\n\t}\n\nout:\n\taac_fib_complete(fibptr);\n\n\tif (fibptr->flags & FIB_CONTEXT_FLAG_NATIVE_HBA_TMF)\n\t\taac_priv(scsicmd)->sent_command = 1;\n\telse\n\t\taac_scsi_done(scsicmd);\n}\n\n \nstatic int aac_send_srb_fib(struct scsi_cmnd* scsicmd)\n{\n\tstruct fib* cmd_fibcontext;\n\tstruct aac_dev* dev;\n\tint status;\n\n\tdev = (struct aac_dev *)scsicmd->device->host->hostdata;\n\tif (scmd_id(scsicmd) >= dev->maximum_num_physicals ||\n\t\t\tscsicmd->device->lun > 7) {\n\t\tscsicmd->result = DID_NO_CONNECT << 16;\n\t\taac_scsi_done(scsicmd);\n\t\treturn 0;\n\t}\n\n\t \n\tcmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\tstatus = aac_adapter_scsi(cmd_fibcontext, scsicmd);\n\n\t \n\tif (status == -EINPROGRESS)\n\t\treturn 0;\n\n\tprintk(KERN_WARNING \"aac_srb: aac_fib_send failed with status: %d\\n\", status);\n\taac_fib_complete(cmd_fibcontext);\n\taac_fib_free(cmd_fibcontext);\n\n\treturn -1;\n}\n\n \nstatic int aac_send_hba_fib(struct scsi_cmnd *scsicmd)\n{\n\tstruct fib *cmd_fibcontext;\n\tstruct aac_dev *dev;\n\tint status;\n\n\tdev = shost_priv(scsicmd->device->host);\n\tif (scmd_id(scsicmd) >= dev->maximum_num_physicals ||\n\t\t\tscsicmd->device->lun > AAC_MAX_LUN - 1) {\n\t\tscsicmd->result = DID_NO_CONNECT << 16;\n\t\taac_scsi_done(scsicmd);\n\t\treturn 0;\n\t}\n\n\t \n\tcmd_fibcontext = aac_fib_alloc_tag(dev, scsicmd);\n\tif (!cmd_fibcontext)\n\t\treturn -1;\n\n\taac_priv(scsicmd)->owner = AAC_OWNER_FIRMWARE;\n\tstatus = aac_adapter_hba(cmd_fibcontext, scsicmd);\n\n\t \n\tif (status == -EINPROGRESS)\n\t\treturn 0;\n\n\tpr_warn(\"aac_hba_cmd_req: aac_fib_send failed with status: %d\\n\",\n\t\tstatus);\n\taac_fib_complete(cmd_fibcontext);\n\taac_fib_free(cmd_fibcontext);\n\n\treturn -1;\n}\n\n\nstatic long aac_build_sg(struct scsi_cmnd *scsicmd, struct sgmap *psg)\n{\n\tunsigned long byte_count = 0;\n\tint nseg;\n\tstruct scatterlist *sg;\n\tint i;\n\n\t\n\tpsg->count = 0;\n\tpsg->sg[0].addr = 0;\n\tpsg->sg[0].count = 0;\n\n\tnseg = scsi_dma_map(scsicmd);\n\tif (nseg <= 0)\n\t\treturn nseg;\n\n\tpsg->count = cpu_to_le32(nseg);\n\n\tscsi_for_each_sg(scsicmd, sg, nseg, i) {\n\t\tpsg->sg[i].addr = cpu_to_le32(sg_dma_address(sg));\n\t\tpsg->sg[i].count = cpu_to_le32(sg_dma_len(sg));\n\t\tbyte_count += sg_dma_len(sg);\n\t}\n\t \n\tif (byte_count > scsi_bufflen(scsicmd)) {\n\t\tu32 temp = le32_to_cpu(psg->sg[i-1].count) -\n\t\t\t(byte_count - scsi_bufflen(scsicmd));\n\t\tpsg->sg[i-1].count = cpu_to_le32(temp);\n\t\tbyte_count = scsi_bufflen(scsicmd);\n\t}\n\t \n\tif (scsicmd->underflow && (byte_count < scsicmd->underflow)) {\n\t\tprintk(KERN_WARNING\"aacraid: cmd len %08lX cmd underflow %08X\\n\",\n\t\t       byte_count, scsicmd->underflow);\n\t}\n\n\treturn byte_count;\n}\n\n\nstatic long aac_build_sg64(struct scsi_cmnd *scsicmd, struct sgmap64 *psg)\n{\n\tunsigned long byte_count = 0;\n\tu64 addr;\n\tint nseg;\n\tstruct scatterlist *sg;\n\tint i;\n\n\t\n\tpsg->count = 0;\n\tpsg->sg[0].addr[0] = 0;\n\tpsg->sg[0].addr[1] = 0;\n\tpsg->sg[0].count = 0;\n\n\tnseg = scsi_dma_map(scsicmd);\n\tif (nseg <= 0)\n\t\treturn nseg;\n\n\tscsi_for_each_sg(scsicmd, sg, nseg, i) {\n\t\tint count = sg_dma_len(sg);\n\t\taddr = sg_dma_address(sg);\n\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\tpsg->sg[i].count = cpu_to_le32(count);\n\t\tbyte_count += count;\n\t}\n\tpsg->count = cpu_to_le32(nseg);\n\t \n\tif (byte_count > scsi_bufflen(scsicmd)) {\n\t\tu32 temp = le32_to_cpu(psg->sg[i-1].count) -\n\t\t\t(byte_count - scsi_bufflen(scsicmd));\n\t\tpsg->sg[i-1].count = cpu_to_le32(temp);\n\t\tbyte_count = scsi_bufflen(scsicmd);\n\t}\n\t \n\tif (scsicmd->underflow && (byte_count < scsicmd->underflow)) {\n\t\tprintk(KERN_WARNING\"aacraid: cmd len %08lX cmd underflow %08X\\n\",\n\t\t       byte_count, scsicmd->underflow);\n\t}\n\n\treturn byte_count;\n}\n\nstatic long aac_build_sgraw(struct scsi_cmnd *scsicmd, struct sgmapraw *psg)\n{\n\tunsigned long byte_count = 0;\n\tint nseg;\n\tstruct scatterlist *sg;\n\tint i;\n\n\t\n\tpsg->count = 0;\n\tpsg->sg[0].next = 0;\n\tpsg->sg[0].prev = 0;\n\tpsg->sg[0].addr[0] = 0;\n\tpsg->sg[0].addr[1] = 0;\n\tpsg->sg[0].count = 0;\n\tpsg->sg[0].flags = 0;\n\n\tnseg = scsi_dma_map(scsicmd);\n\tif (nseg <= 0)\n\t\treturn nseg;\n\n\tscsi_for_each_sg(scsicmd, sg, nseg, i) {\n\t\tint count = sg_dma_len(sg);\n\t\tu64 addr = sg_dma_address(sg);\n\t\tpsg->sg[i].next = 0;\n\t\tpsg->sg[i].prev = 0;\n\t\tpsg->sg[i].addr[1] = cpu_to_le32((u32)(addr>>32));\n\t\tpsg->sg[i].addr[0] = cpu_to_le32((u32)(addr & 0xffffffff));\n\t\tpsg->sg[i].count = cpu_to_le32(count);\n\t\tpsg->sg[i].flags = 0;\n\t\tbyte_count += count;\n\t}\n\tpsg->count = cpu_to_le32(nseg);\n\t \n\tif (byte_count > scsi_bufflen(scsicmd)) {\n\t\tu32 temp = le32_to_cpu(psg->sg[i-1].count) -\n\t\t\t(byte_count - scsi_bufflen(scsicmd));\n\t\tpsg->sg[i-1].count = cpu_to_le32(temp);\n\t\tbyte_count = scsi_bufflen(scsicmd);\n\t}\n\t \n\tif (scsicmd->underflow && (byte_count < scsicmd->underflow)) {\n\t\tprintk(KERN_WARNING\"aacraid: cmd len %08lX cmd underflow %08X\\n\",\n\t\t       byte_count, scsicmd->underflow);\n\t}\n\n\treturn byte_count;\n}\n\nstatic long aac_build_sgraw2(struct scsi_cmnd *scsicmd,\n\t\t\t\tstruct aac_raw_io2 *rio2, int sg_max)\n{\n\tunsigned long byte_count = 0;\n\tint nseg;\n\tstruct scatterlist *sg;\n\tint i, conformable = 0;\n\tu32 min_size = PAGE_SIZE, cur_size;\n\n\tnseg = scsi_dma_map(scsicmd);\n\tif (nseg <= 0)\n\t\treturn nseg;\n\n\tscsi_for_each_sg(scsicmd, sg, nseg, i) {\n\t\tint count = sg_dma_len(sg);\n\t\tu64 addr = sg_dma_address(sg);\n\n\t\tBUG_ON(i >= sg_max);\n\t\trio2->sge[i].addrHigh = cpu_to_le32((u32)(addr>>32));\n\t\trio2->sge[i].addrLow = cpu_to_le32((u32)(addr & 0xffffffff));\n\t\tcur_size = cpu_to_le32(count);\n\t\trio2->sge[i].length = cur_size;\n\t\trio2->sge[i].flags = 0;\n\t\tif (i == 0) {\n\t\t\tconformable = 1;\n\t\t\trio2->sgeFirstSize = cur_size;\n\t\t} else if (i == 1) {\n\t\t\trio2->sgeNominalSize = cur_size;\n\t\t\tmin_size = cur_size;\n\t\t} else if ((i+1) < nseg && cur_size != rio2->sgeNominalSize) {\n\t\t\tconformable = 0;\n\t\t\tif (cur_size < min_size)\n\t\t\t\tmin_size = cur_size;\n\t\t}\n\t\tbyte_count += count;\n\t}\n\n\t \n\tif (byte_count > scsi_bufflen(scsicmd)) {\n\t\tu32 temp = le32_to_cpu(rio2->sge[i-1].length) -\n\t\t\t(byte_count - scsi_bufflen(scsicmd));\n\t\trio2->sge[i-1].length = cpu_to_le32(temp);\n\t\tbyte_count = scsi_bufflen(scsicmd);\n\t}\n\n\trio2->sgeCnt = cpu_to_le32(nseg);\n\trio2->flags |= cpu_to_le16(RIO2_SG_FORMAT_IEEE1212);\n\t \n\tif (!conformable) {\n\t\tint j, nseg_new = nseg, err_found;\n\t\tfor (i = min_size / PAGE_SIZE; i >= 1; --i) {\n\t\t\terr_found = 0;\n\t\t\tnseg_new = 2;\n\t\t\tfor (j = 1; j < nseg - 1; ++j) {\n\t\t\t\tif (rio2->sge[j].length % (i*PAGE_SIZE)) {\n\t\t\t\t\terr_found = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnseg_new += (rio2->sge[j].length / (i*PAGE_SIZE));\n\t\t\t}\n\t\t\tif (!err_found)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i > 0 && nseg_new <= sg_max) {\n\t\t\tint ret = aac_convert_sgraw2(rio2, i, nseg, nseg_new);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t} else\n\t\trio2->flags |= cpu_to_le16(RIO2_SGL_CONFORMANT);\n\n\t \n\tif (scsicmd->underflow && (byte_count < scsicmd->underflow)) {\n\t\tprintk(KERN_WARNING\"aacraid: cmd len %08lX cmd underflow %08X\\n\",\n\t\t       byte_count, scsicmd->underflow);\n\t}\n\n\treturn byte_count;\n}\n\nstatic int aac_convert_sgraw2(struct aac_raw_io2 *rio2, int pages, int nseg, int nseg_new)\n{\n\tstruct sge_ieee1212 *sge;\n\tint i, j, pos;\n\tu32 addr_low;\n\n\tif (aac_convert_sgl == 0)\n\t\treturn 0;\n\n\tsge = kmalloc_array(nseg_new, sizeof(*sge), GFP_ATOMIC);\n\tif (sge == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 1, pos = 1; i < nseg-1; ++i) {\n\t\tfor (j = 0; j < rio2->sge[i].length / (pages * PAGE_SIZE); ++j) {\n\t\t\taddr_low = rio2->sge[i].addrLow + j * pages * PAGE_SIZE;\n\t\t\tsge[pos].addrLow = addr_low;\n\t\t\tsge[pos].addrHigh = rio2->sge[i].addrHigh;\n\t\t\tif (addr_low < rio2->sge[i].addrLow)\n\t\t\t\tsge[pos].addrHigh++;\n\t\t\tsge[pos].length = pages * PAGE_SIZE;\n\t\t\tsge[pos].flags = 0;\n\t\t\tpos++;\n\t\t}\n\t}\n\tsge[pos] = rio2->sge[nseg-1];\n\tmemcpy(&rio2->sge[1], &sge[1], (nseg_new-1)*sizeof(struct sge_ieee1212));\n\n\tkfree(sge);\n\trio2->sgeCnt = cpu_to_le32(nseg_new);\n\trio2->flags |= cpu_to_le16(RIO2_SGL_CONFORMANT);\n\trio2->sgeNominalSize = pages * PAGE_SIZE;\n\treturn 0;\n}\n\nstatic long aac_build_sghba(struct scsi_cmnd *scsicmd,\n\t\t\tstruct aac_hba_cmd_req *hbacmd,\n\t\t\tint sg_max,\n\t\t\tu64 sg_address)\n{\n\tunsigned long byte_count = 0;\n\tint nseg;\n\tstruct scatterlist *sg;\n\tint i;\n\tu32 cur_size;\n\tstruct aac_hba_sgl *sge;\n\n\tnseg = scsi_dma_map(scsicmd);\n\tif (nseg <= 0) {\n\t\tbyte_count = nseg;\n\t\tgoto out;\n\t}\n\n\tif (nseg > HBA_MAX_SG_EMBEDDED)\n\t\tsge = &hbacmd->sge[2];\n\telse\n\t\tsge = &hbacmd->sge[0];\n\n\tscsi_for_each_sg(scsicmd, sg, nseg, i) {\n\t\tint count = sg_dma_len(sg);\n\t\tu64 addr = sg_dma_address(sg);\n\n\t\tWARN_ON(i >= sg_max);\n\t\tsge->addr_hi = cpu_to_le32((u32)(addr>>32));\n\t\tsge->addr_lo = cpu_to_le32((u32)(addr & 0xffffffff));\n\t\tcur_size = cpu_to_le32(count);\n\t\tsge->len = cur_size;\n\t\tsge->flags = 0;\n\t\tbyte_count += count;\n\t\tsge++;\n\t}\n\n\tsge--;\n\t \n\tif (byte_count > scsi_bufflen(scsicmd)) {\n\t\tu32 temp;\n\n\t\ttemp = le32_to_cpu(sge->len) - byte_count\n\t\t\t\t\t\t- scsi_bufflen(scsicmd);\n\t\tsge->len = cpu_to_le32(temp);\n\t\tbyte_count = scsi_bufflen(scsicmd);\n\t}\n\n\tif (nseg <= HBA_MAX_SG_EMBEDDED) {\n\t\thbacmd->emb_data_desc_count = cpu_to_le32(nseg);\n\t\tsge->flags = cpu_to_le32(0x40000000);\n\t} else {\n\t\t \n\t\thbacmd->sge[0].flags = cpu_to_le32(0x80000000);\n\t\thbacmd->emb_data_desc_count = (u8)cpu_to_le32(1);\n\t\thbacmd->sge[0].addr_hi = (u32)cpu_to_le32(sg_address >> 32);\n\t\thbacmd->sge[0].addr_lo =\n\t\t\tcpu_to_le32((u32)(sg_address & 0xffffffff));\n\t}\n\n\t \n\tif (scsicmd->underflow && (byte_count < scsicmd->underflow)) {\n\t\tpr_warn(\"aacraid: cmd len %08lX cmd underflow %08X\\n\",\n\t\t\t\tbyte_count, scsicmd->underflow);\n\t}\nout:\n\treturn byte_count;\n}\n\n#ifdef AAC_DETAILED_STATUS_INFO\n\nstruct aac_srb_status_info {\n\tu32\tstatus;\n\tchar\t*str;\n};\n\n\nstatic struct aac_srb_status_info srb_status_info[] = {\n\t{ SRB_STATUS_PENDING,\t\t\"Pending Status\"},\n\t{ SRB_STATUS_SUCCESS,\t\t\"Success\"},\n\t{ SRB_STATUS_ABORTED,\t\t\"Aborted Command\"},\n\t{ SRB_STATUS_ABORT_FAILED,\t\"Abort Failed\"},\n\t{ SRB_STATUS_ERROR,\t\t\"Error Event\"},\n\t{ SRB_STATUS_BUSY,\t\t\"Device Busy\"},\n\t{ SRB_STATUS_INVALID_REQUEST,\t\"Invalid Request\"},\n\t{ SRB_STATUS_INVALID_PATH_ID,\t\"Invalid Path ID\"},\n\t{ SRB_STATUS_NO_DEVICE,\t\t\"No Device\"},\n\t{ SRB_STATUS_TIMEOUT,\t\t\"Timeout\"},\n\t{ SRB_STATUS_SELECTION_TIMEOUT,\t\"Selection Timeout\"},\n\t{ SRB_STATUS_COMMAND_TIMEOUT,\t\"Command Timeout\"},\n\t{ SRB_STATUS_MESSAGE_REJECTED,\t\"Message Rejected\"},\n\t{ SRB_STATUS_BUS_RESET,\t\t\"Bus Reset\"},\n\t{ SRB_STATUS_PARITY_ERROR,\t\"Parity Error\"},\n\t{ SRB_STATUS_REQUEST_SENSE_FAILED,\"Request Sense Failed\"},\n\t{ SRB_STATUS_NO_HBA,\t\t\"No HBA\"},\n\t{ SRB_STATUS_DATA_OVERRUN,\t\"Data Overrun/Data Underrun\"},\n\t{ SRB_STATUS_UNEXPECTED_BUS_FREE,\"Unexpected Bus Free\"},\n\t{ SRB_STATUS_PHASE_SEQUENCE_FAILURE,\"Phase Error\"},\n\t{ SRB_STATUS_BAD_SRB_BLOCK_LENGTH,\"Bad Srb Block Length\"},\n\t{ SRB_STATUS_REQUEST_FLUSHED,\t\"Request Flushed\"},\n\t{ SRB_STATUS_DELAYED_RETRY,\t\"Delayed Retry\"},\n\t{ SRB_STATUS_INVALID_LUN,\t\"Invalid LUN\"},\n\t{ SRB_STATUS_INVALID_TARGET_ID,\t\"Invalid TARGET ID\"},\n\t{ SRB_STATUS_BAD_FUNCTION,\t\"Bad Function\"},\n\t{ SRB_STATUS_ERROR_RECOVERY,\t\"Error Recovery\"},\n\t{ SRB_STATUS_NOT_STARTED,\t\"Not Started\"},\n\t{ SRB_STATUS_NOT_IN_USE,\t\"Not In Use\"},\n\t{ SRB_STATUS_FORCE_ABORT,\t\"Force Abort\"},\n\t{ SRB_STATUS_DOMAIN_VALIDATION_FAIL,\"Domain Validation Failure\"},\n\t{ 0xff,\t\t\t\t\"Unknown Error\"}\n};\n\nchar *aac_get_status_string(u32 status)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(srb_status_info); i++)\n\t\tif (srb_status_info[i].status == status)\n\t\t\treturn srb_status_info[i].str;\n\n\treturn \"Bad Status Code\";\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}