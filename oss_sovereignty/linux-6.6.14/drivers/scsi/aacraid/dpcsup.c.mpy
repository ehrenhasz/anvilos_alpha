{
  "module_name": "dpcsup.c",
  "hash_id": "f4cd5ea3598920ce1eedf0d44b4858a6008ab5985a094048e50eaef2b8de9580",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/dpcsup.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/blkdev.h>\n\n#include \"aacraid.h\"\n\n \n\nunsigned int aac_response_normal(struct aac_queue * q)\n{\n\tstruct aac_dev * dev = q->dev;\n\tstruct aac_entry *entry;\n\tstruct hw_fib * hwfib;\n\tstruct fib * fib;\n\tint consumed = 0;\n\tunsigned long flags, mflags;\n\n\tspin_lock_irqsave(q->lock, flags);\n\t \n\twhile(aac_consumer_get(dev, q, &entry))\n\t{\n\t\tint fast;\n\t\tu32 index = le32_to_cpu(entry->addr);\n\t\tfast = index & 0x01;\n\t\tfib = &dev->fibs[index >> 2];\n\t\thwfib = fib->hw_fib_va;\n\t\t\n\t\taac_consumer_free(dev, q, HostNormRespQueue);\n\t\t \n\t\tatomic_dec(&dev->queues->queue[AdapNormCmdQueue].numpending);\n\n\t\tif (unlikely(fib->flags & FIB_CONTEXT_FLAG_TIMED_OUT)) {\n\t\t\tspin_unlock_irqrestore(q->lock, flags);\n\t\t\taac_fib_complete(fib);\n\t\t\taac_fib_free(fib);\n\t\t\tspin_lock_irqsave(q->lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock_irqrestore(q->lock, flags);\n\n\t\tif (fast) {\n\t\t\t \n\t\t\t*(__le32 *)hwfib->data = cpu_to_le32(ST_OK);\n\t\t\thwfib->header.XferState |= cpu_to_le32(AdapterProcessed);\n\t\t\tfib->flags |= FIB_CONTEXT_FLAG_FASTRESP;\n\t\t}\n\n\t\tFIB_COUNTER_INCREMENT(aac_config.FibRecved);\n\n\t\tif (hwfib->header.Command == cpu_to_le16(NuFileSystem))\n\t\t{\n\t\t\t__le32 *pstatus = (__le32 *)hwfib->data;\n\t\t\tif (*pstatus & cpu_to_le32(0xffff0000))\n\t\t\t\t*pstatus = cpu_to_le32(ST_OK);\n\t\t}\n\t\tif (hwfib->header.XferState & cpu_to_le32(NoResponseExpected | Async)) \n\t\t{\n\t\t\tif (hwfib->header.XferState & cpu_to_le32(NoResponseExpected)) {\n\t\t\t\tFIB_COUNTER_INCREMENT(aac_config.NoResponseRecved);\n\t\t\t} else {\n\t\t\t\tFIB_COUNTER_INCREMENT(aac_config.AsyncRecved);\n\t\t\t}\n\t\t\t \n\t\t\tfib->callback(fib->callback_data, fib);\n\t\t} else {\n\t\t\tunsigned long flagv;\n\t\t\tspin_lock_irqsave(&fib->event_lock, flagv);\n\t\t\tif (!fib->done) {\n\t\t\t\tfib->done = 1;\n\t\t\t\tcomplete(&fib->event_wait);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&fib->event_lock, flagv);\n\n\t\t\tspin_lock_irqsave(&dev->manage_lock, mflags);\n\t\t\tdev->management_fib_count--;\n\t\t\tspin_unlock_irqrestore(&dev->manage_lock, mflags);\n\n\t\t\tFIB_COUNTER_INCREMENT(aac_config.NormalRecved);\n\t\t\tif (fib->done == 2) {\n\t\t\t\tspin_lock_irqsave(&fib->event_lock, flagv);\n\t\t\t\tfib->done = 0;\n\t\t\t\tspin_unlock_irqrestore(&fib->event_lock, flagv);\n\t\t\t\taac_fib_complete(fib);\n\t\t\t\taac_fib_free(fib);\n\t\t\t}\n\t\t}\n\t\tconsumed++;\n\t\tspin_lock_irqsave(q->lock, flags);\n\t}\n\n\tif (consumed > aac_config.peak_fibs)\n\t\taac_config.peak_fibs = consumed;\n\tif (consumed == 0) \n\t\taac_config.zero_fibs++;\n\n\tspin_unlock_irqrestore(q->lock, flags);\n\treturn 0;\n}\n\n\n \n \nunsigned int aac_command_normal(struct aac_queue *q)\n{\n\tstruct aac_dev * dev = q->dev;\n\tstruct aac_entry *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(q->lock, flags);\n\n\t \n\twhile(aac_consumer_get(dev, q, &entry))\n\t{\n\t\tstruct fib fibctx;\n\t\tstruct hw_fib * hw_fib;\n\t\tu32 index;\n\t\tstruct fib *fib = &fibctx;\n\t\t\n\t\tindex = le32_to_cpu(entry->addr) / sizeof(struct hw_fib);\n\t\thw_fib = &dev->aif_base_va[index];\n\t\t\n\t\t \n\t\tif (dev->aif_thread)\n\t\t\tif((fib = kmalloc(sizeof(struct fib), GFP_ATOMIC)) == NULL)\n\t\t\t\tfib = &fibctx;\n\t\t\n\t\tmemset(fib, 0, sizeof(struct fib));\n\t\tINIT_LIST_HEAD(&fib->fiblink);\n\t\tfib->type = FSAFS_NTC_FIB_CONTEXT;\n\t\tfib->size = sizeof(struct fib);\n\t\tfib->hw_fib_va = hw_fib;\n\t\tfib->data = hw_fib->data;\n\t\tfib->dev = dev;\n\t\t\n\t\t\t\t\n\t\tif (dev->aif_thread && fib != &fibctx) {\n\t\t        list_add_tail(&fib->fiblink, &q->cmdq);\n\t \t        aac_consumer_free(dev, q, HostNormCmdQueue);\n\t\t        wake_up_interruptible(&q->cmdready);\n\t\t} else {\n\t \t        aac_consumer_free(dev, q, HostNormCmdQueue);\n\t\t\tspin_unlock_irqrestore(q->lock, flags);\n\t\t\t \n\t\t\t*(__le32 *)hw_fib->data = cpu_to_le32(ST_OK);\n\t\t\taac_fib_adapter_complete(fib, sizeof(u32));\n\t\t\tspin_lock_irqsave(q->lock, flags);\n\t\t}\t\t\n\t}\n\tspin_unlock_irqrestore(q->lock, flags);\n\treturn 0;\n}\n\n \n\nstatic void aac_aif_callback(void *context, struct fib * fibptr)\n{\n\tstruct fib *fibctx;\n\tstruct aac_dev *dev;\n\tstruct aac_aifcmd *cmd;\n\n\tfibctx = (struct fib *)context;\n\tBUG_ON(fibptr == NULL);\n\tdev = fibptr->dev;\n\n\tif ((fibptr->hw_fib_va->header.XferState &\n\t    cpu_to_le32(NoMoreAifDataAvailable)) ||\n\t\tdev->sa_firmware) {\n\t\taac_fib_complete(fibptr);\n\t\taac_fib_free(fibptr);\n\t\treturn;\n\t}\n\n\taac_intr_normal(dev, 0, 1, 0, fibptr->hw_fib_va);\n\n\taac_fib_init(fibctx);\n\tcmd = (struct aac_aifcmd *) fib_data(fibctx);\n\tcmd->command = cpu_to_le32(AifReqEvent);\n\n\taac_fib_send(AifRequest,\n\t\tfibctx,\n\t\tsizeof(struct hw_fib)-sizeof(struct aac_fibhdr),\n\t\tFsaNormal,\n\t\t0, 1,\n\t\t(fib_callback)aac_aif_callback, fibctx);\n}\n\n\n \nunsigned int aac_intr_normal(struct aac_dev *dev, u32 index, int isAif,\n\tint isFastResponse, struct hw_fib *aif_fib)\n{\n\tunsigned long mflags;\n\tdprintk((KERN_INFO \"aac_intr_normal(%p,%x)\\n\", dev, index));\n\tif (isAif == 1) {\t \n\t\tstruct hw_fib * hw_fib;\n\t\tstruct fib * fib;\n\t\tstruct aac_queue *q = &dev->queues->queue[HostNormCmdQueue];\n\t\tunsigned long flags;\n\n\t\t \n\t\tif ((!dev->aif_thread)\n\t\t || (!(fib = kzalloc(sizeof(struct fib),GFP_ATOMIC))))\n\t\t\treturn 1;\n\t\tif (!(hw_fib = kzalloc(sizeof(struct hw_fib),GFP_ATOMIC))) {\n\t\t\tkfree (fib);\n\t\t\treturn 1;\n\t\t}\n\t\tif (dev->sa_firmware) {\n\t\t\tfib->hbacmd_size = index;\t \n\t\t} else if (aif_fib != NULL) {\n\t\t\tmemcpy(hw_fib, aif_fib, sizeof(struct hw_fib));\n\t\t} else {\n\t\t\tmemcpy(hw_fib, (struct hw_fib *)\n\t\t\t\t(((uintptr_t)(dev->regs.sa)) + index),\n\t\t\t\tsizeof(struct hw_fib));\n\t\t}\n\t\tINIT_LIST_HEAD(&fib->fiblink);\n\t\tfib->type = FSAFS_NTC_FIB_CONTEXT;\n\t\tfib->size = sizeof(struct fib);\n\t\tfib->hw_fib_va = hw_fib;\n\t\tfib->data = hw_fib->data;\n\t\tfib->dev = dev;\n\t\n\t\tspin_lock_irqsave(q->lock, flags);\n\t\tlist_add_tail(&fib->fiblink, &q->cmdq);\n\t        wake_up_interruptible(&q->cmdready);\n\t\tspin_unlock_irqrestore(q->lock, flags);\n\t\treturn 1;\n\t} else if (isAif == 2) {\t \n\t\tstruct fib *fibctx;\n\t\tstruct aac_aifcmd *cmd;\n\n\t\tfibctx = aac_fib_alloc(dev);\n\t\tif (!fibctx)\n\t\t\treturn 1;\n\t\taac_fib_init(fibctx);\n\n\t\tcmd = (struct aac_aifcmd *) fib_data(fibctx);\n\t\tcmd->command = cpu_to_le32(AifReqEvent);\n\n\t\treturn aac_fib_send(AifRequest,\n\t\t\tfibctx,\n\t\t\tsizeof(struct hw_fib)-sizeof(struct aac_fibhdr),\n\t\t\tFsaNormal,\n\t\t\t0, 1,\n\t\t\t(fib_callback)aac_aif_callback, fibctx);\n\t} else {\n\t\tstruct fib *fib = &dev->fibs[index];\n\t\tint start_callback = 0;\n\n\t\t \n\t\tatomic_dec(&dev->queues->queue[AdapNormCmdQueue].numpending);\n\n\t\tif (unlikely(fib->flags & FIB_CONTEXT_FLAG_TIMED_OUT)) {\n\t\t\taac_fib_complete(fib);\n\t\t\taac_fib_free(fib);\n\t\t\treturn 0;\n\t\t}\n\n\t\tFIB_COUNTER_INCREMENT(aac_config.FibRecved);\n\n\t\tif (fib->flags & FIB_CONTEXT_FLAG_NATIVE_HBA) {\n\n\t\t\tif (isFastResponse)\n\t\t\t\tfib->flags |= FIB_CONTEXT_FLAG_FASTRESP;\n\n\t\t\tif (fib->callback) {\n\t\t\t\tstart_callback = 1;\n\t\t\t} else {\n\t\t\t\tunsigned long flagv;\n\t\t\t\tint completed = 0;\n\n\t\t\t\tdprintk((KERN_INFO \"event_wait up\\n\"));\n\t\t\t\tspin_lock_irqsave(&fib->event_lock, flagv);\n\t\t\t\tif (fib->done == 2) {\n\t\t\t\t\tfib->done = 1;\n\t\t\t\t\tcompleted = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfib->done = 1;\n\t\t\t\t\tcomplete(&fib->event_wait);\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&fib->event_lock, flagv);\n\n\t\t\t\tspin_lock_irqsave(&dev->manage_lock, mflags);\n\t\t\t\tdev->management_fib_count--;\n\t\t\t\tspin_unlock_irqrestore(&dev->manage_lock,\n\t\t\t\t\tmflags);\n\n\t\t\t\tFIB_COUNTER_INCREMENT(aac_config.NativeRecved);\n\t\t\t\tif (completed)\n\t\t\t\t\taac_fib_complete(fib);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct hw_fib *hwfib = fib->hw_fib_va;\n\n\t\t\tif (isFastResponse) {\n\t\t\t\t \n\t\t\t\t*(__le32 *)hwfib->data = cpu_to_le32(ST_OK);\n\t\t\t\thwfib->header.XferState |=\n\t\t\t\t\tcpu_to_le32(AdapterProcessed);\n\t\t\t\tfib->flags |= FIB_CONTEXT_FLAG_FASTRESP;\n\t\t\t}\n\n\t\t\tif (hwfib->header.Command ==\n\t\t\t\tcpu_to_le16(NuFileSystem)) {\n\t\t\t\t__le32 *pstatus = (__le32 *)hwfib->data;\n\n\t\t\t\tif (*pstatus & cpu_to_le32(0xffff0000))\n\t\t\t\t\t*pstatus = cpu_to_le32(ST_OK);\n\t\t\t}\n\t\t\tif (hwfib->header.XferState &\n\t\t\t\tcpu_to_le32(NoResponseExpected | Async)) {\n\t\t\t\tif (hwfib->header.XferState & cpu_to_le32(\n\t\t\t\t\tNoResponseExpected)) {\n\t\t\t\t\tFIB_COUNTER_INCREMENT(\n\t\t\t\t\t\taac_config.NoResponseRecved);\n\t\t\t\t} else {\n\t\t\t\t\tFIB_COUNTER_INCREMENT(\n\t\t\t\t\t\taac_config.AsyncRecved);\n\t\t\t\t}\n\t\t\t\tstart_callback = 1;\n\t\t\t} else {\n\t\t\t\tunsigned long flagv;\n\t\t\t\tint completed = 0;\n\n\t\t\t\tdprintk((KERN_INFO \"event_wait up\\n\"));\n\t\t\t\tspin_lock_irqsave(&fib->event_lock, flagv);\n\t\t\t\tif (fib->done == 2) {\n\t\t\t\t\tfib->done = 1;\n\t\t\t\t\tcompleted = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfib->done = 1;\n\t\t\t\t\tcomplete(&fib->event_wait);\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&fib->event_lock, flagv);\n\n\t\t\t\tspin_lock_irqsave(&dev->manage_lock, mflags);\n\t\t\t\tdev->management_fib_count--;\n\t\t\t\tspin_unlock_irqrestore(&dev->manage_lock,\n\t\t\t\t\tmflags);\n\n\t\t\t\tFIB_COUNTER_INCREMENT(aac_config.NormalRecved);\n\t\t\t\tif (completed)\n\t\t\t\t\taac_fib_complete(fib);\n\t\t\t}\n\t\t}\n\n\n\t\tif (start_callback) {\n\t\t\t \n\t\t\tif (likely(fib->callback && fib->callback_data)) {\n\t\t\t\tfib->callback(fib->callback_data, fib);\n\t\t\t} else {\n\t\t\t\taac_fib_complete(fib);\n\t\t\t\taac_fib_free(fib);\n\t\t\t}\n\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}