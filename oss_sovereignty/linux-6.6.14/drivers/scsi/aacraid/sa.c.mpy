{
  "module_name": "sa.c",
  "hash_id": "6b266f2ff7532af975793e5c2fd7f88054e1ccb9eb29afa4efe6b1a8a055847b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/sa.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/time.h>\n#include <linux/interrupt.h>\n\n#include <scsi/scsi_host.h>\n\n#include \"aacraid.h\"\n\nstatic irqreturn_t aac_sa_intr(int irq, void *dev_id)\n{\n\tstruct aac_dev *dev = dev_id;\n\tunsigned short intstat, mask;\n\n\tintstat = sa_readw(dev, DoorbellReg_p);\n\t \n\tmask = ~(sa_readw(dev, SaDbCSR.PRISETIRQMASK));\n\n\t \n\n\tif (intstat & mask) {\n\t\tif (intstat & PrintfReady) {\n\t\t\taac_printf(dev, sa_readl(dev, Mailbox5));\n\t\t\tsa_writew(dev, DoorbellClrReg_p, PrintfReady);  \n\t\t\tsa_writew(dev, DoorbellReg_s, PrintfDone);\n\t\t} else if (intstat & DOORBELL_1) {\t \n\t\t\tsa_writew(dev, DoorbellClrReg_p, DOORBELL_1);\n\t\t\taac_command_normal(&dev->queues->queue[HostNormCmdQueue]);\n\t\t} else if (intstat & DOORBELL_2) {\t \n\t\t\tsa_writew(dev, DoorbellClrReg_p, DOORBELL_2);\n\t\t\taac_response_normal(&dev->queues->queue[HostNormRespQueue]);\n\t\t} else if (intstat & DOORBELL_3) {\t \n\t\t\tsa_writew(dev, DoorbellClrReg_p, DOORBELL_3);\n\t\t} else if (intstat & DOORBELL_4) {\t \n\t\t\tsa_writew(dev, DoorbellClrReg_p, DOORBELL_4);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\n \n\nstatic void aac_sa_disable_interrupt (struct aac_dev *dev)\n{\n\tsa_writew(dev, SaDbCSR.PRISETIRQMASK, 0xffff);\n}\n\n \n\nstatic void aac_sa_enable_interrupt (struct aac_dev *dev)\n{\n\tsa_writew(dev, SaDbCSR.PRICLEARIRQMASK, (PrintfReady | DOORBELL_1 |\n\t\t\t\tDOORBELL_2 | DOORBELL_3 | DOORBELL_4));\n}\n\n \n \nstatic void aac_sa_notify_adapter(struct aac_dev *dev, u32 event)\n{\n\tswitch (event) {\n\n\tcase AdapNormCmdQue:\n\t\tsa_writew(dev, DoorbellReg_s,DOORBELL_1);\n\t\tbreak;\n\tcase HostNormRespNotFull:\n\t\tsa_writew(dev, DoorbellReg_s,DOORBELL_4);\n\t\tbreak;\n\tcase AdapNormRespQue:\n\t\tsa_writew(dev, DoorbellReg_s,DOORBELL_2);\n\t\tbreak;\n\tcase HostNormCmdNotFull:\n\t\tsa_writew(dev, DoorbellReg_s,DOORBELL_3);\n\t\tbreak;\n\tcase HostShutdown:\n\t\t \n\t\tbreak;\n\tcase FastIo:\n\t\tsa_writew(dev, DoorbellReg_s,DOORBELL_6);\n\t\tbreak;\n\tcase AdapPrintfDone:\n\t\tsa_writew(dev, DoorbellReg_s,DOORBELL_5);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\n\n \nstatic int sa_sync_cmd(struct aac_dev *dev, u32 command,\n\t\tu32 p1, u32 p2, u32 p3, u32 p4, u32 p5, u32 p6,\n\t\tu32 *ret, u32 *r1, u32 *r2, u32 *r3, u32 *r4)\n{\n\tunsigned long start;\n \tint ok;\n\t \n\tsa_writel(dev, Mailbox0, command);\n\t \n\tsa_writel(dev, Mailbox1, p1);\n\tsa_writel(dev, Mailbox2, p2);\n\tsa_writel(dev, Mailbox3, p3);\n\tsa_writel(dev, Mailbox4, p4);\n\n\t \n\tsa_writew(dev, DoorbellClrReg_p, DOORBELL_0);\n\t \n\tsa_writew(dev, DoorbellReg_s, DOORBELL_0);\n\n\tok = 0;\n\tstart = jiffies;\n\n\twhile(time_before(jiffies, start+30*HZ))\n\t{\n\t\t \n\t\tudelay(5);\n\t\t \n\t\tif(sa_readw(dev, DoorbellReg_p) & DOORBELL_0)  {\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\tif (ok != 1)\n\t\treturn -ETIMEDOUT;\n\t \n\tsa_writew(dev, DoorbellClrReg_p, DOORBELL_0);\n\t \n\tif (ret)\n\t\t*ret = sa_readl(dev, Mailbox0);\n\tif (r1)\n\t\t*r1 = sa_readl(dev, Mailbox1);\n\tif (r2)\n\t\t*r2 = sa_readl(dev, Mailbox2);\n\tif (r3)\n\t\t*r3 = sa_readl(dev, Mailbox3);\n\tif (r4)\n\t\t*r4 = sa_readl(dev, Mailbox4);\n\treturn 0;\n}\n\n \n \nstatic void aac_sa_interrupt_adapter (struct aac_dev *dev)\n{\n\tsa_sync_cmd(dev, BREAKPOINT_REQUEST, 0, 0, 0, 0, 0, 0,\n\t\t\tNULL, NULL, NULL, NULL, NULL);\n}\n\n \n\nstatic void aac_sa_start_adapter(struct aac_dev *dev)\n{\n\tunion aac_init *init;\n\t \n\tinit = dev->init;\n\tinit->r7.host_elapsed_seconds = cpu_to_le32(ktime_get_real_seconds());\n\t \n\tsa_sync_cmd(dev, INIT_STRUCT_BASE_ADDRESS, \n\t\t\t(u32)(ulong)dev->init_pa, 0, 0, 0, 0, 0,\n\t\t\tNULL, NULL, NULL, NULL, NULL);\n}\n\nstatic int aac_sa_restart_adapter(struct aac_dev *dev, int bled, u8 reset_type)\n{\n\treturn -EINVAL;\n}\n\n \nstatic int aac_sa_check_health(struct aac_dev *dev)\n{\n\tlong status = sa_readl(dev, Mailbox7);\n\n\t \n\tif (status & SELF_TEST_FAILED)\n\t\treturn -1;\n\t \n\tif (status & KERNEL_PANIC)\n\t\treturn -2;\n\t \n\tif (!(status & KERNEL_UP_AND_RUNNING))\n\t\treturn -3;\n\t \n\treturn 0;\n}\n\n \nstatic int aac_sa_ioremap(struct aac_dev * dev, u32 size)\n{\n\tif (!size) {\n\t\tiounmap(dev->regs.sa);\n\t\treturn 0;\n\t}\n\tdev->base = dev->regs.sa = ioremap(dev->base_start, size);\n\treturn (dev->base == NULL) ? -1 : 0;\n}\n\n \n\nint aac_sa_init(struct aac_dev *dev)\n{\n\tunsigned long start;\n\tunsigned long status;\n\tint instance;\n\tconst char *name;\n\n\tinstance = dev->id;\n\tname     = dev->name;\n\n\t \n\n\tdev->a_ops.adapter_interrupt = aac_sa_interrupt_adapter;\n\tdev->a_ops.adapter_disable_int = aac_sa_disable_interrupt;\n\tdev->a_ops.adapter_enable_int = aac_sa_enable_interrupt;\n\tdev->a_ops.adapter_notify = aac_sa_notify_adapter;\n\tdev->a_ops.adapter_sync_cmd = sa_sync_cmd;\n\tdev->a_ops.adapter_check_health = aac_sa_check_health;\n\tdev->a_ops.adapter_restart = aac_sa_restart_adapter;\n\tdev->a_ops.adapter_start = aac_sa_start_adapter;\n\tdev->a_ops.adapter_intr = aac_sa_intr;\n\tdev->a_ops.adapter_deliver = aac_rx_deliver_producer;\n\tdev->a_ops.adapter_ioremap = aac_sa_ioremap;\n\n\tif (aac_sa_ioremap(dev, dev->base_size)) {\n\t\tprintk(KERN_WARNING \"%s: unable to map adapter.\\n\", name);\n\t\tgoto error_iounmap;\n\t}\n\n\t \n\tif (sa_readl(dev, Mailbox7) & SELF_TEST_FAILED) {\n\t\tprintk(KERN_WARNING \"%s%d: adapter self-test failed.\\n\", name, instance);\n\t\tgoto error_iounmap;\n\t}\n\t \n\tif (sa_readl(dev, Mailbox7) & KERNEL_PANIC) {\n\t\tprintk(KERN_WARNING \"%s%d: adapter kernel panic'd.\\n\", name, instance);\n\t\tgoto error_iounmap;\n\t}\n\tstart = jiffies;\n\t \n\twhile (!(sa_readl(dev, Mailbox7) & KERNEL_UP_AND_RUNNING)) {\n\t\tif (time_after(jiffies, start+startup_timeout*HZ)) {\n\t\t\tstatus = sa_readl(dev, Mailbox7);\n\t\t\tprintk(KERN_WARNING \"%s%d: adapter kernel failed to start, init status = %lx.\\n\", \n\t\t\t\t\tname, instance, status);\n\t\t\tgoto error_iounmap;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\t \n\taac_adapter_disable_int(dev);\n\taac_adapter_enable_int(dev);\n\n\tif(aac_init_adapter(dev) == NULL)\n\t\tgoto error_irq;\n\tdev->sync_mode = 0;\t \n\tif (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,\n\t\t\tIRQF_SHARED, \"aacraid\", (void *)dev) < 0) {\n\t\tprintk(KERN_WARNING \"%s%d: Interrupt unavailable.\\n\",\n\t\t\tname, instance);\n\t\tgoto error_iounmap;\n\t}\n\tdev->dbg_base = dev->base_start;\n\tdev->dbg_base_mapped = dev->base;\n\tdev->dbg_size = dev->base_size;\n\n\taac_adapter_enable_int(dev);\n\n\t \n\taac_sa_start_adapter(dev);\n\treturn 0;\n\nerror_irq:\n\taac_sa_disable_interrupt(dev);\n\tfree_irq(dev->pdev->irq, (void *)dev);\n\nerror_iounmap:\n\n\treturn -1;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}