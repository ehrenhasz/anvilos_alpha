{
  "module_name": "commctrl.c",
  "hash_id": "29ac70306d6928b7f1965a87c937890717fa8e37a7d9a1b4c1cfa3eebee3cf3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/commctrl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/blkdev.h>\n#include <linux/compat.h>\n#include <linux/delay.h>  \n#include <linux/kthread.h>\n#include <linux/uaccess.h>\n#include <scsi/scsi_host.h>\n\n#include \"aacraid.h\"\n\n# define AAC_DEBUG_PREAMBLE\tKERN_INFO\n# define AAC_DEBUG_POSTAMBLE\n \nstatic int ioctl_send_fib(struct aac_dev * dev, void __user *arg)\n{\n\tstruct hw_fib * kfib;\n\tstruct fib *fibptr;\n\tstruct hw_fib * hw_fib = (struct hw_fib *)0;\n\tdma_addr_t hw_fib_pa = (dma_addr_t)0LL;\n\tunsigned int size, osize;\n\tint retval;\n\n\tif (dev->in_reset) {\n\t\treturn -EBUSY;\n\t}\n\tfibptr = aac_fib_alloc(dev);\n\tif(fibptr == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tkfib = fibptr->hw_fib_va;\n\t \n\tif (copy_from_user((void *)kfib, arg, sizeof(struct aac_fibhdr))) {\n\t\taac_fib_free(fibptr);\n\t\treturn -EFAULT;\n\t}\n\t \n\tosize = size = le16_to_cpu(kfib->header.Size) +\n\t\tsizeof(struct aac_fibhdr);\n\tif (size < le16_to_cpu(kfib->header.SenderSize))\n\t\tsize = le16_to_cpu(kfib->header.SenderSize);\n\tif (size > dev->max_fib_size) {\n\t\tdma_addr_t daddr;\n\n\t\tif (size > 2048) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tkfib = dma_alloc_coherent(&dev->pdev->dev, size, &daddr,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!kfib) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t \n\t\thw_fib = fibptr->hw_fib_va;\n\t\thw_fib_pa = fibptr->hw_fib_pa;\n\t\tfibptr->hw_fib_va = kfib;\n\t\tfibptr->hw_fib_pa = daddr;\n\t\tmemset(((char *)kfib) + dev->max_fib_size, 0, size - dev->max_fib_size);\n\t\tmemcpy(kfib, hw_fib, dev->max_fib_size);\n\t}\n\n\tif (copy_from_user(kfib, arg, size)) {\n\t\tretval = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif ((osize != le16_to_cpu(kfib->header.Size) +\n\t\tsizeof(struct aac_fibhdr))\n\t\t|| (size < le16_to_cpu(kfib->header.SenderSize))) {\n\t\tretval = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tif (kfib->header.Command == cpu_to_le16(TakeABreakPt)) {\n\t\taac_adapter_interrupt(dev);\n\t\t \n\t\tkfib->header.XferState = 0;\n\t} else {\n\t\tretval = aac_fib_send(le16_to_cpu(kfib->header.Command), fibptr,\n\t\t\t\tle16_to_cpu(kfib->header.Size) , FsaNormal,\n\t\t\t\t1, 1, NULL, NULL);\n\t\tif (retval) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (aac_fib_complete(fibptr) != 0) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\t \n\n\tretval = 0;\n\tif (copy_to_user(arg, (void *)kfib, size))\n\t\tretval = -EFAULT;\ncleanup:\n\tif (hw_fib) {\n\t\tdma_free_coherent(&dev->pdev->dev, size, kfib,\n\t\t\t\t  fibptr->hw_fib_pa);\n\t\tfibptr->hw_fib_pa = hw_fib_pa;\n\t\tfibptr->hw_fib_va = hw_fib;\n\t}\n\tif (retval != -ERESTARTSYS)\n\t\taac_fib_free(fibptr);\n\treturn retval;\n}\n\n \nstatic int open_getadapter_fib(struct aac_dev * dev, void __user *arg)\n{\n\tstruct aac_fib_context * fibctx;\n\tint status;\n\n\tfibctx = kmalloc(sizeof(struct aac_fib_context), GFP_KERNEL);\n\tif (fibctx == NULL) {\n\t\tstatus = -ENOMEM;\n\t} else {\n\t\tunsigned long flags;\n\t\tstruct list_head * entry;\n\t\tstruct aac_fib_context * context;\n\n\t\tfibctx->type = FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT;\n\t\tfibctx->size = sizeof(struct aac_fib_context);\n\t\t \n\t\tfibctx->unique = (u32)((ulong)fibctx & 0xFFFFFFFF);\n\t\t \n\t\tinit_completion(&fibctx->completion);\n\t\tfibctx->wait = 0;\n\t\t \n\t\tfibctx->count = 0;\n\t\tINIT_LIST_HEAD(&fibctx->fib_list);\n\t\tfibctx->jiffies = jiffies/HZ;\n\t\t \n\t\tspin_lock_irqsave(&dev->fib_lock, flags);\n\t\t \n\t\tentry = dev->fib_list.next;\n\t\twhile (entry != &dev->fib_list) {\n\t\t\tcontext = list_entry(entry, struct aac_fib_context, next);\n\t\t\tif (context->unique == fibctx->unique) {\n\t\t\t\t \n\t\t\t\tfibctx->unique++;\n\t\t\t\tentry = dev->fib_list.next;\n\t\t\t} else {\n\t\t\t\tentry = entry->next;\n\t\t\t}\n\t\t}\n\t\tlist_add_tail(&fibctx->next, &dev->fib_list);\n\t\tspin_unlock_irqrestore(&dev->fib_lock, flags);\n\t\tif (copy_to_user(arg, &fibctx->unique,\n\t\t\t\t\t\tsizeof(fibctx->unique))) {\n\t\t\tstatus = -EFAULT;\n\t\t} else {\n\t\t\tstatus = 0;\n\t\t}\n\t}\n\treturn status;\n}\n\nstruct compat_fib_ioctl {\n\tu32\tfibctx;\n\ts32\twait;\n\tcompat_uptr_t fib;\n};\n\n \nstatic int next_getadapter_fib(struct aac_dev * dev, void __user *arg)\n{\n\tstruct fib_ioctl f;\n\tstruct fib *fib;\n\tstruct aac_fib_context *fibctx;\n\tint status;\n\tstruct list_head * entry;\n\tunsigned long flags;\n\n\tif (in_compat_syscall()) {\n\t\tstruct compat_fib_ioctl cf;\n\n\t\tif (copy_from_user(&cf, arg, sizeof(struct compat_fib_ioctl)))\n\t\t\treturn -EFAULT;\n\n\t\tf.fibctx = cf.fibctx;\n\t\tf.wait = cf.wait;\n\t\tf.fib = compat_ptr(cf.fib);\n\t} else {\n\t\tif (copy_from_user(&f, arg, sizeof(struct fib_ioctl)))\n\t\t\treturn -EFAULT;\n\t}\n\t \n\tspin_lock_irqsave(&dev->fib_lock, flags);\n\tentry = dev->fib_list.next;\n\tfibctx = NULL;\n\n\twhile (entry != &dev->fib_list) {\n\t\tfibctx = list_entry(entry, struct aac_fib_context, next);\n\t\t \n\t\tif (fibctx->unique == f.fibctx) {  \n\t\t\tbreak;\n\t\t}\n\t\tentry = entry->next;\n\t\tfibctx = NULL;\n\t}\n\tif (!fibctx) {\n\t\tspin_unlock_irqrestore(&dev->fib_lock, flags);\n\t\tdprintk ((KERN_INFO \"Fib Context not found\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\tif((fibctx->type != FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT) ||\n\t\t (fibctx->size != sizeof(struct aac_fib_context))) {\n\t\tspin_unlock_irqrestore(&dev->fib_lock, flags);\n\t\tdprintk ((KERN_INFO \"Fib Context corrupt?\\n\"));\n\t\treturn -EINVAL;\n\t}\n\tstatus = 0;\n\t \nreturn_fib:\n\tif (!list_empty(&fibctx->fib_list)) {\n\t\t \n\t\tentry = fibctx->fib_list.next;\n\t\tlist_del(entry);\n\n\t\tfib = list_entry(entry, struct fib, fiblink);\n\t\tfibctx->count--;\n\t\tspin_unlock_irqrestore(&dev->fib_lock, flags);\n\t\tif (copy_to_user(f.fib, fib->hw_fib_va, sizeof(struct hw_fib))) {\n\t\t\tkfree(fib->hw_fib_va);\n\t\t\tkfree(fib);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t \n\t\tkfree(fib->hw_fib_va);\n\t\tkfree(fib);\n\t\tstatus = 0;\n\t} else {\n\t\tspin_unlock_irqrestore(&dev->fib_lock, flags);\n\t\t \n\t\tstatus = !dev->aif_thread;\n\t\tif (status && !dev->in_reset && dev->queues && dev->fsa_dev) {\n\t\t\t \n\t\t\tkthread_stop(dev->thread);\n\t\t\tssleep(1);\n\t\t\tdev->aif_thread = 0;\n\t\t\tdev->thread = kthread_run(aac_command_thread, dev,\n\t\t\t\t\t\t  \"%s\", dev->name);\n\t\t\tssleep(1);\n\t\t}\n\t\tif (f.wait) {\n\t\t\tif (wait_for_completion_interruptible(&fibctx->completion) < 0) {\n\t\t\t\tstatus = -ERESTARTSYS;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tspin_lock_irqsave(&dev->fib_lock, flags);\n\t\t\t\tgoto return_fib;\n\t\t\t}\n\t\t} else {\n\t\t\tstatus = -EAGAIN;\n\t\t}\n\t}\n\tfibctx->jiffies = jiffies/HZ;\n\treturn status;\n}\n\nint aac_close_fib_context(struct aac_dev * dev, struct aac_fib_context * fibctx)\n{\n\tstruct fib *fib;\n\n\t \n\twhile (!list_empty(&fibctx->fib_list)) {\n\t\tstruct list_head * entry;\n\t\t \n\t\tentry = fibctx->fib_list.next;\n\t\tlist_del(entry);\n\t\tfib = list_entry(entry, struct fib, fiblink);\n\t\tfibctx->count--;\n\t\t \n\t\tkfree(fib->hw_fib_va);\n\t\tkfree(fib);\n\t}\n\t \n\tlist_del(&fibctx->next);\n\t \n\tfibctx->type = 0;\n\t \n\tkfree(fibctx);\n\treturn 0;\n}\n\n \n\nstatic int close_getadapter_fib(struct aac_dev * dev, void __user *arg)\n{\n\tstruct aac_fib_context *fibctx;\n\tint status;\n\tunsigned long flags;\n\tstruct list_head * entry;\n\n\t \n\n\tentry = dev->fib_list.next;\n\tfibctx = NULL;\n\n\twhile(entry != &dev->fib_list) {\n\t\tfibctx = list_entry(entry, struct aac_fib_context, next);\n\t\t \n\t\tif (fibctx->unique == (u32)(uintptr_t)arg)  \n\t\t\tbreak;\n\t\tentry = entry->next;\n\t\tfibctx = NULL;\n\t}\n\n\tif (!fibctx)\n\t\treturn 0;  \n\n\tif((fibctx->type != FSAFS_NTC_GET_ADAPTER_FIB_CONTEXT) ||\n\t\t (fibctx->size != sizeof(struct aac_fib_context)))\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->fib_lock, flags);\n\tstatus = aac_close_fib_context(dev, fibctx);\n\tspin_unlock_irqrestore(&dev->fib_lock, flags);\n\treturn status;\n}\n\n \n\nstatic int check_revision(struct aac_dev *dev, void __user *arg)\n{\n\tstruct revision response;\n\tchar *driver_version = aac_driver_version;\n\tu32 version;\n\n\tresponse.compat = 1;\n\tversion = (simple_strtol(driver_version,\n\t\t\t\t&driver_version, 10) << 24) | 0x00000400;\n\tversion += simple_strtol(driver_version + 1, &driver_version, 10) << 16;\n\tversion += simple_strtol(driver_version + 1, NULL, 10);\n\tresponse.version = cpu_to_le32(version);\n#\tifdef AAC_DRIVER_BUILD\n\t\tresponse.build = cpu_to_le32(AAC_DRIVER_BUILD);\n#\telse\n\t\tresponse.build = cpu_to_le32(9999);\n#\tendif\n\n\tif (copy_to_user(arg, &response, sizeof(response)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n\n \nstatic int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\n{\n\tstruct fib* srbfib;\n\tint status;\n\tstruct aac_srb *srbcmd = NULL;\n\tstruct aac_hba_cmd_req *hbacmd = NULL;\n\tstruct user_aac_srb *user_srbcmd = NULL;\n\tstruct user_aac_srb __user *user_srb = arg;\n\tstruct aac_srb_reply __user *user_reply;\n\tu32 chn;\n\tu32 fibsize = 0;\n\tu32 flags = 0;\n\ts32 rcode = 0;\n\tu32 data_dir;\n\tvoid __user *sg_user[HBA_MAX_SG_EMBEDDED];\n\tvoid *sg_list[HBA_MAX_SG_EMBEDDED];\n\tu32 sg_count[HBA_MAX_SG_EMBEDDED];\n\tu32 sg_indx = 0;\n\tu32 byte_count = 0;\n\tu32 actual_fibsize64, actual_fibsize = 0;\n\tint i;\n\tint is_native_device;\n\tu64 address;\n\n\n\tif (dev->in_reset) {\n\t\tdprintk((KERN_DEBUG\"aacraid: send raw srb -EBUSY\\n\"));\n\t\treturn -EBUSY;\n\t}\n\tif (!capable(CAP_SYS_ADMIN)){\n\t\tdprintk((KERN_DEBUG\"aacraid: No permission to send raw srb\\n\"));\n\t\treturn -EPERM;\n\t}\n\t \n\tif (!(srbfib = aac_fib_alloc(dev))) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(sg_list, 0, sizeof(sg_list));  \n\tif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy data size from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\tif ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||\n\t    (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tuser_srbcmd = memdup_user(user_srb, fibsize);\n\tif (IS_ERR(user_srbcmd)) {\n\t\trcode = PTR_ERR(user_srbcmd);\n\t\tuser_srbcmd = NULL;\n\t\tgoto cleanup;\n\t}\n\n\tflags = user_srbcmd->flags;  \n\tswitch (flags & (SRB_DataIn | SRB_DataOut)) {\n\tcase SRB_DataOut:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase (SRB_DataIn | SRB_DataOut):\n\t\tdata_dir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\tcase SRB_DataIn:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tdata_dir = DMA_NONE;\n\t}\n\tif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: too many sg entries %d\\n\",\n\t\t\tuser_srbcmd->sg.count));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\n\t\tdprintk((KERN_DEBUG\"aacraid:SG with no direction specified\\n\"));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\n\t\t((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\n\tactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\n\t  (sizeof(struct sgentry64) - sizeof(struct sgentry));\n\t \n\tif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Bad Size specified in \"\n\t\t  \"Raw SRB command calculated fibsize=%lu;%lu \"\n\t\t  \"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu \"\n\t\t  \"issued fibsize=%d\\n\",\n\t\t  actual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\n\t\t  sizeof(struct aac_srb), sizeof(struct sgentry),\n\t\t  sizeof(struct sgentry64), fibsize));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tchn = user_srbcmd->channel;\n\tif (chn < AAC_MAX_BUSES && user_srbcmd->id < AAC_MAX_TARGETS &&\n\t\tdev->hba_map[chn][user_srbcmd->id].devtype ==\n\t\tAAC_DEVTYPE_NATIVE_RAW) {\n\t\tis_native_device = 1;\n\t\thbacmd = (struct aac_hba_cmd_req *)srbfib->hw_fib_va;\n\t\tmemset(hbacmd, 0, 96);\t \n\n\t\t \n\t\tswitch (data_dir) {\n\t\tcase DMA_TO_DEVICE:\n\t\t\thbacmd->byte1 = 2;\n\t\t\tbreak;\n\t\tcase DMA_FROM_DEVICE:\n\t\tcase DMA_BIDIRECTIONAL:\n\t\t\thbacmd->byte1 = 1;\n\t\t\tbreak;\n\t\tcase DMA_NONE:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\thbacmd->lun[1] = cpu_to_le32(user_srbcmd->lun);\n\t\thbacmd->it_nexus = dev->hba_map[chn][user_srbcmd->id].rmw_nexus;\n\n\t\t \n\n\t\tmemcpy(hbacmd->cdb, user_srbcmd->cdb, sizeof(hbacmd->cdb));\n\n\t\taddress = (u64)srbfib->hw_error_pa;\n\t\thbacmd->error_ptr_hi = cpu_to_le32((u32)(address >> 32));\n\t\thbacmd->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff));\n\t\thbacmd->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE);\n\t\thbacmd->emb_data_desc_count =\n\t\t\t\t\tcpu_to_le32(user_srbcmd->sg.count);\n\t\tsrbfib->hbacmd_size = 64 +\n\t\t\tuser_srbcmd->sg.count * sizeof(struct aac_hba_sgl);\n\n\t} else {\n\t\tis_native_device = 0;\n\t\taac_fib_init(srbfib);\n\n\t\t \n\t\tsrbfib->hw_fib_va->header.XferState &=\n\t\t\t~cpu_to_le32(FastResponseCapable);\n\n\t\tsrbcmd = (struct aac_srb *) fib_data(srbfib);\n\n\t\t\n\n\t\tsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi); \n\t\tsrbcmd->channel\t = cpu_to_le32(user_srbcmd->channel);\n\t\tsrbcmd->id\t = cpu_to_le32(user_srbcmd->id);\n\t\tsrbcmd->lun\t = cpu_to_le32(user_srbcmd->lun);\n\t\tsrbcmd->timeout\t = cpu_to_le32(user_srbcmd->timeout);\n\t\tsrbcmd->flags\t = cpu_to_le32(flags);\n\t\tsrbcmd->retry_limit = 0; \n\t\tsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\n\t\tmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\n\t}\n\n\tbyte_count = 0;\n\tif (is_native_device) {\n\t\tstruct user_sgmap *usg32 = &user_srbcmd->sg;\n\t\tstruct user_sgmap64 *usg64 =\n\t\t\t(struct user_sgmap64 *)&user_srbcmd->sg;\n\n\t\tfor (i = 0; i < usg32->count; i++) {\n\t\t\tvoid *p;\n\t\t\tu64 addr;\n\n\t\t\tsg_count[i] = (actual_fibsize64 == fibsize) ?\n\t\t\t\tusg64->sg[i].count : usg32->sg[i].count;\n\t\t\tif (sg_count[i] >\n\t\t\t\t(dev->scsi_host_ptr->max_sectors << 9)) {\n\t\t\t\tpr_err(\"aacraid: upsg->sg[%d].count=%u>%u\\n\",\n\t\t\t\t\ti, sg_count[i],\n\t\t\t\t\tdev->scsi_host_ptr->max_sectors << 9);\n\t\t\t\trcode = -EINVAL;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\tif (!p) {\n\t\t\t\trcode = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tif (actual_fibsize64 == fibsize) {\n\t\t\t\taddr = (u64)usg64->sg[i].addr[0];\n\t\t\t\taddr += ((u64)usg64->sg[i].addr[1]) << 32;\n\t\t\t} else {\n\t\t\t\taddr = (u64)usg32->sg[i].addr;\n\t\t\t}\n\n\t\t\tsg_user[i] = (void __user *)(uintptr_t)addr;\n\t\t\tsg_list[i] = p; \n\t\t\tsg_indx = i;\n\n\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\t\t\taddr = dma_map_single(&dev->pdev->dev, p, sg_count[i],\n\t\t\t\t\t      data_dir);\n\t\t\thbacmd->sge[i].addr_hi = cpu_to_le32((u32)(addr>>32));\n\t\t\thbacmd->sge[i].addr_lo = cpu_to_le32(\n\t\t\t\t\t\t(u32)(addr & 0xffffffff));\n\t\t\thbacmd->sge[i].len = cpu_to_le32(sg_count[i]);\n\t\t\thbacmd->sge[i].flags = 0;\n\t\t\tbyte_count += sg_count[i];\n\t\t}\n\n\t\tif (usg32->count > 0)\t \n\t\t\thbacmd->sge[usg32->count-1].flags =\n\t\t\t\tcpu_to_le32(0x40000000);\n\t\thbacmd->data_length = cpu_to_le32(byte_count);\n\n\t\tstatus = aac_hba_send(HBA_IU_TYPE_SCSI_CMD_REQ, srbfib,\n\t\t\t\t\tNULL, NULL);\n\n\t} else if (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) {\n\t\tstruct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg;\n\t\tstruct sgmap64* psg = (struct sgmap64*)&srbcmd->sg;\n\n\t\t \n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tactual_fibsize = actual_fibsize64;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = upsg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  sg_count[i], i, upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)upsg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)upsg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)addr;\n\t\t\t\tsg_list[i] = p; \n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = dma_map_single(&dev->pdev->dev, p,\n\t\t\t\t\t\t      sg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tstruct user_sgmap* usg;\n\t\t\tusg = kmemdup(upsg,\n\t\t\t\t      actual_fibsize - sizeof(struct aac_srb)\n\t\t\t\t      + sizeof(struct sgmap), GFP_KERNEL);\n\t\t\tif (!usg) {\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Allocation error in Raw SRB command\\n\"));\n\t\t\t\trcode = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tactual_fibsize = actual_fibsize64;\n\n\t\t\tfor (i = 0; i < usg->count; i++) {\n\t\t\t\tu64 addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = usg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\t\tif(!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG \"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t\tsg_count[i], i, usg->count));\n\t\t\t\t\tkfree(usg);\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)usg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; \n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\t\tkfree (usg);\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = dma_map_single(&dev->pdev->dev, p,\n\t\t\t\t\t\t      sg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tpsg->sg[i].addr[1] = cpu_to_le32(addr>>32);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t\tkfree (usg);\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tif (user_srbcmd->sg.count)\n\t\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\telse\n\t\t\tpsg->count = 0;\n\t\tstatus = aac_fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,NULL,NULL);\n\t} else {\n\t\tstruct user_sgmap* upsg = &user_srbcmd->sg;\n\t\tstruct sgmap* psg = &srbcmd->sg;\n\n\t\tif (actual_fibsize64 == fibsize) {\n\t\t\tstruct user_sgmap64* usg = (struct user_sgmap64 *)upsg;\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tuintptr_t addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = usg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\t\tif (!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t\tsg_count[i], i, usg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\taddr = (u64)usg->sg[i].addr[0];\n\t\t\t\taddr += ((u64)usg->sg[i].addr[1]) << 32;\n\t\t\t\tsg_user[i] = (void __user *)addr;\n\t\t\t\tsg_list[i] = p; \n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])){\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = dma_map_single(&dev->pdev->dev, p,\n\t\t\t\t\t\t      usg->sg[i].count,\n\t\t\t\t\t\t      data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr & 0xffffffff);\n\t\t\t\tbyte_count += usg->sg[i].count;\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < upsg->count; i++) {\n\t\t\t\tdma_addr_t addr;\n\t\t\t\tvoid* p;\n\n\t\t\t\tsg_count[i] = upsg->sg[i].count;\n\t\t\t\tif (sg_count[i] >\n\t\t\t\t    ((dev->adapter_info.options &\n\t\t\t\t     AAC_OPT_NEW_COMM) ?\n\t\t\t\t      (dev->scsi_host_ptr->max_sectors << 9) :\n\t\t\t\t      65536)) {\n\t\t\t\t\trcode = -EINVAL;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tp = kmalloc(sg_count[i], GFP_KERNEL);\n\t\t\t\tif (!p) {\n\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\\n\",\n\t\t\t\t\t  sg_count[i], i, upsg->count));\n\t\t\t\t\trcode = -ENOMEM;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tsg_user[i] = (void __user *)(uintptr_t)upsg->sg[i].addr;\n\t\t\t\tsg_list[i] = p; \n\t\t\t\tsg_indx = i;\n\n\t\t\t\tif (flags & SRB_DataOut) {\n\t\t\t\t\tif (copy_from_user(p, sg_user[i],\n\t\t\t\t\t\tsg_count[i])) {\n\t\t\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data from user\\n\"));\n\t\t\t\t\t\trcode = -EFAULT;\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddr = dma_map_single(&dev->pdev->dev, p,\n\t\t\t\t\t\t      sg_count[i], data_dir);\n\n\t\t\t\tpsg->sg[i].addr = cpu_to_le32(addr);\n\t\t\t\tbyte_count += sg_count[i];\n\t\t\t\tpsg->sg[i].count = cpu_to_le32(sg_count[i]);\n\t\t\t}\n\t\t}\n\t\tsrbcmd->count = cpu_to_le32(byte_count);\n\t\tif (user_srbcmd->sg.count)\n\t\t\tpsg->count = cpu_to_le32(sg_indx+1);\n\t\telse\n\t\t\tpsg->count = 0;\n\t\tstatus = aac_fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, NULL, NULL);\n\t}\n\n\tif (status == -ERESTARTSYS) {\n\t\trcode = -ERESTARTSYS;\n\t\tgoto cleanup;\n\t}\n\n\tif (status != 0) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not send raw srb fib to hba\\n\"));\n\t\trcode = -ENXIO;\n\t\tgoto cleanup;\n\t}\n\n\tif (flags & SRB_DataIn) {\n\t\tfor(i = 0 ; i <= sg_indx; i++){\n\t\t\tif (copy_to_user(sg_user[i], sg_list[i], sg_count[i])) {\n\t\t\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy sg data to user\\n\"));\n\t\t\t\trcode = -EFAULT;\n\t\t\t\tgoto cleanup;\n\n\t\t\t}\n\t\t}\n\t}\n\n\tuser_reply = arg + fibsize;\n\tif (is_native_device) {\n\t\tstruct aac_hba_resp *err =\n\t\t\t&((struct aac_native_hba *)srbfib->hw_fib_va)->resp.err;\n\t\tstruct aac_srb_reply reply;\n\n\t\tmemset(&reply, 0, sizeof(reply));\n\t\treply.status = ST_OK;\n\t\tif (srbfib->flags & FIB_CONTEXT_FLAG_FASTRESP) {\n\t\t\t \n\t\t\treply.srb_status = SRB_STATUS_SUCCESS;\n\t\t\treply.scsi_status = 0;\n\t\t\treply.data_xfer_length = byte_count;\n\t\t\treply.sense_data_size = 0;\n\t\t\tmemset(reply.sense_data, 0, AAC_SENSE_BUFFERSIZE);\n\t\t} else {\n\t\t\treply.srb_status = err->service_response;\n\t\t\treply.scsi_status = err->status;\n\t\t\treply.data_xfer_length = byte_count -\n\t\t\t\tle32_to_cpu(err->residual_count);\n\t\t\treply.sense_data_size = err->sense_response_data_len;\n\t\t\tmemcpy(reply.sense_data, err->sense_response_buf,\n\t\t\t\tAAC_SENSE_BUFFERSIZE);\n\t\t}\n\t\tif (copy_to_user(user_reply, &reply,\n\t\t\tsizeof(struct aac_srb_reply))) {\n\t\t\tdprintk((KERN_DEBUG\"aacraid: Copy to user failed\\n\"));\n\t\t\trcode = -EFAULT;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tstruct aac_srb_reply *reply;\n\n\t\treply = (struct aac_srb_reply *) fib_data(srbfib);\n\t\tif (copy_to_user(user_reply, reply,\n\t\t\tsizeof(struct aac_srb_reply))) {\n\t\t\tdprintk((KERN_DEBUG\"aacraid: Copy to user failed\\n\"));\n\t\t\trcode = -EFAULT;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\tkfree(user_srbcmd);\n\tif (rcode != -ERESTARTSYS) {\n\t\tfor (i = 0; i <= sg_indx; i++)\n\t\t\tkfree(sg_list[i]);\n\t\taac_fib_complete(srbfib);\n\t\taac_fib_free(srbfib);\n\t}\n\n\treturn rcode;\n}\n\nstruct aac_pci_info {\n\tu32 bus;\n\tu32 slot;\n};\n\n\nstatic int aac_get_pci_info(struct aac_dev* dev, void __user *arg)\n{\n\tstruct aac_pci_info pci_info;\n\n\tpci_info.bus = dev->pdev->bus->number;\n\tpci_info.slot = PCI_SLOT(dev->pdev->devfn);\n\n\tif (copy_to_user(arg, &pci_info, sizeof(struct aac_pci_info))) {\n\t\tdprintk((KERN_DEBUG \"aacraid: Could not copy pci info\\n\"));\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int aac_get_hba_info(struct aac_dev *dev, void __user *arg)\n{\n\tstruct aac_hba_info hbainfo;\n\n\tmemset(&hbainfo, 0, sizeof(hbainfo));\n\thbainfo.adapter_number\t\t= (u8) dev->id;\n\thbainfo.system_io_bus_number\t= dev->pdev->bus->number;\n\thbainfo.device_number\t\t= (dev->pdev->devfn >> 3);\n\thbainfo.function_number\t\t= (dev->pdev->devfn & 0x0007);\n\n\thbainfo.vendor_id\t\t= dev->pdev->vendor;\n\thbainfo.device_id\t\t= dev->pdev->device;\n\thbainfo.sub_vendor_id\t\t= dev->pdev->subsystem_vendor;\n\thbainfo.sub_system_id\t\t= dev->pdev->subsystem_device;\n\n\tif (copy_to_user(arg, &hbainfo, sizeof(struct aac_hba_info))) {\n\t\tdprintk((KERN_DEBUG \"aacraid: Could not copy hba info\\n\"));\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstruct aac_reset_iop {\n\tu8\treset_type;\n};\n\nstatic int aac_send_reset_adapter(struct aac_dev *dev, void __user *arg)\n{\n\tstruct aac_reset_iop reset;\n\tint retval;\n\n\tif (copy_from_user((void *)&reset, arg, sizeof(struct aac_reset_iop)))\n\t\treturn -EFAULT;\n\n\tdev->adapter_shutdown = 1;\n\n\tmutex_unlock(&dev->ioctl_mutex);\n\tretval = aac_reset_adapter(dev, 0, reset.reset_type);\n\tmutex_lock(&dev->ioctl_mutex);\n\n\treturn retval;\n}\n\nint aac_do_ioctl(struct aac_dev *dev, unsigned int cmd, void __user *arg)\n{\n\tint status;\n\n\tmutex_lock(&dev->ioctl_mutex);\n\n\tif (dev->adapter_shutdown) {\n\t\tstatus = -EACCES;\n\t\tgoto cleanup;\n\t}\n\n\t \n\n\tstatus = aac_dev_ioctl(dev, cmd, arg);\n\tif (status != -ENOTTY)\n\t\tgoto cleanup;\n\n\tswitch (cmd) {\n\tcase FSACTL_MINIPORT_REV_CHECK:\n\t\tstatus = check_revision(dev, arg);\n\t\tbreak;\n\tcase FSACTL_SEND_LARGE_FIB:\n\tcase FSACTL_SENDFIB:\n\t\tstatus = ioctl_send_fib(dev, arg);\n\t\tbreak;\n\tcase FSACTL_OPEN_GET_ADAPTER_FIB:\n\t\tstatus = open_getadapter_fib(dev, arg);\n\t\tbreak;\n\tcase FSACTL_GET_NEXT_ADAPTER_FIB:\n\t\tstatus = next_getadapter_fib(dev, arg);\n\t\tbreak;\n\tcase FSACTL_CLOSE_GET_ADAPTER_FIB:\n\t\tstatus = close_getadapter_fib(dev, arg);\n\t\tbreak;\n\tcase FSACTL_SEND_RAW_SRB:\n\t\tstatus = aac_send_raw_srb(dev,arg);\n\t\tbreak;\n\tcase FSACTL_GET_PCI_INFO:\n\t\tstatus = aac_get_pci_info(dev,arg);\n\t\tbreak;\n\tcase FSACTL_GET_HBA_INFO:\n\t\tstatus = aac_get_hba_info(dev, arg);\n\t\tbreak;\n\tcase FSACTL_RESET_IOP:\n\t\tstatus = aac_send_reset_adapter(dev, arg);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -ENOTTY;\n\t\tbreak;\n\t}\n\ncleanup:\n\tmutex_unlock(&dev->ioctl_mutex);\n\n\treturn status;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}