{
  "module_name": "rx.c",
  "hash_id": "947e0a493ddc98d4eba627d299433a6cab52cb2159cd013026db116ec357bde2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/rx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/time.h>\n#include <linux/interrupt.h>\n\n#include <scsi/scsi_host.h>\n\n#include \"aacraid.h\"\n\nstatic irqreturn_t aac_rx_intr_producer(int irq, void *dev_id)\n{\n\tstruct aac_dev *dev = dev_id;\n\tunsigned long bellbits;\n\tu8 intstat = rx_readb(dev, MUnit.OISR);\n\n\t \n\tif (likely(intstat & ~(dev->OIMR))) {\n\t\tbellbits = rx_readl(dev, OutboundDoorbellReg);\n\t\tif (unlikely(bellbits & DoorBellPrintfReady)) {\n\t\t\taac_printf(dev, readl (&dev->IndexRegs->Mailbox[5]));\n\t\t\trx_writel(dev, MUnit.ODR,DoorBellPrintfReady);\n\t\t\trx_writel(dev, InboundDoorbellReg,DoorBellPrintfDone);\n\t\t}\n\t\telse if (unlikely(bellbits & DoorBellAdapterNormCmdReady)) {\n\t\t\trx_writel(dev, MUnit.ODR, DoorBellAdapterNormCmdReady);\n\t\t\taac_command_normal(&dev->queues->queue[HostNormCmdQueue]);\n\t\t}\n\t\telse if (likely(bellbits & DoorBellAdapterNormRespReady)) {\n\t\t\trx_writel(dev, MUnit.ODR,DoorBellAdapterNormRespReady);\n\t\t\taac_response_normal(&dev->queues->queue[HostNormRespQueue]);\n\t\t}\n\t\telse if (unlikely(bellbits & DoorBellAdapterNormCmdNotFull)) {\n\t\t\trx_writel(dev, MUnit.ODR, DoorBellAdapterNormCmdNotFull);\n\t\t}\n\t\telse if (unlikely(bellbits & DoorBellAdapterNormRespNotFull)) {\n\t\t\trx_writel(dev, MUnit.ODR, DoorBellAdapterNormCmdNotFull);\n\t\t\trx_writel(dev, MUnit.ODR, DoorBellAdapterNormRespNotFull);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t aac_rx_intr_message(int irq, void *dev_id)\n{\n\tint isAif, isFastResponse, isSpecial;\n\tstruct aac_dev *dev = dev_id;\n\tu32 Index = rx_readl(dev, MUnit.OutboundQueue);\n\tif (unlikely(Index == 0xFFFFFFFFL))\n\t\tIndex = rx_readl(dev, MUnit.OutboundQueue);\n\tif (likely(Index != 0xFFFFFFFFL)) {\n\t\tdo {\n\t\t\tisAif = isFastResponse = isSpecial = 0;\n\t\t\tif (Index & 0x00000002L) {\n\t\t\t\tisAif = 1;\n\t\t\t\tif (Index == 0xFFFFFFFEL)\n\t\t\t\t\tisSpecial = 1;\n\t\t\t\tIndex &= ~0x00000002L;\n\t\t\t} else {\n\t\t\t\tif (Index & 0x00000001L)\n\t\t\t\t\tisFastResponse = 1;\n\t\t\t\tIndex >>= 2;\n\t\t\t}\n\t\t\tif (!isSpecial) {\n\t\t\t\tif (unlikely(aac_intr_normal(dev,\n\t\t\t\t\t\tIndex, isAif,\n\t\t\t\t\t\tisFastResponse, NULL))) {\n\t\t\t\t\trx_writel(dev,\n\t\t\t\t\t\tMUnit.OutboundQueue,\n\t\t\t\t\t\tIndex);\n\t\t\t\t\trx_writel(dev,\n\t\t\t\t\t\tMUnit.ODR,\n\t\t\t\t\t\tDoorBellAdapterNormRespReady);\n\t\t\t\t}\n\t\t\t}\n\t\t\tIndex = rx_readl(dev, MUnit.OutboundQueue);\n\t\t} while (Index != 0xFFFFFFFFL);\n\t\treturn IRQ_HANDLED;\n\t}\n\treturn IRQ_NONE;\n}\n\n \n\nstatic void aac_rx_disable_interrupt(struct aac_dev *dev)\n{\n\trx_writeb(dev, MUnit.OIMR, dev->OIMR = 0xff);\n}\n\n \n\nstatic void aac_rx_enable_interrupt_producer(struct aac_dev *dev)\n{\n\trx_writeb(dev, MUnit.OIMR, dev->OIMR = 0xfb);\n}\n\n \n\nstatic void aac_rx_enable_interrupt_message(struct aac_dev *dev)\n{\n\trx_writeb(dev, MUnit.OIMR, dev->OIMR = 0xf7);\n}\n\n \n\nstatic int rx_sync_cmd(struct aac_dev *dev, u32 command,\n\tu32 p1, u32 p2, u32 p3, u32 p4, u32 p5, u32 p6,\n\tu32 *status, u32 * r1, u32 * r2, u32 * r3, u32 * r4)\n{\n\tunsigned long start;\n\tint ok;\n\t \n\twritel(command, &dev->IndexRegs->Mailbox[0]);\n\t \n\twritel(p1, &dev->IndexRegs->Mailbox[1]);\n\twritel(p2, &dev->IndexRegs->Mailbox[2]);\n\twritel(p3, &dev->IndexRegs->Mailbox[3]);\n\twritel(p4, &dev->IndexRegs->Mailbox[4]);\n\t \n\trx_writel(dev, OutboundDoorbellReg, OUTBOUNDDOORBELL_0);\n\t \n\trx_writeb(dev, MUnit.OIMR, dev->OIMR = 0xff);\n\t \n\trx_readb (dev, MUnit.OIMR);\n\t \n\trx_writel(dev, InboundDoorbellReg, INBOUNDDOORBELL_0);\n\n\tok = 0;\n\tstart = jiffies;\n\n\t \n\twhile (time_before(jiffies, start+30*HZ)) \n\t{\n\t\tudelay(5);\t \n\t\t \n\t\tif (rx_readl(dev, OutboundDoorbellReg) & OUTBOUNDDOORBELL_0) {\n\t\t\t \n\t\t\trx_writel(dev, OutboundDoorbellReg, OUTBOUNDDOORBELL_0);\n\t\t\tok = 1;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tmsleep(1);\n\t}\n\tif (unlikely(ok != 1)) {\n\t\t \n\t\taac_adapter_enable_int(dev);\n\t\treturn -ETIMEDOUT;\n\t}\n\t \n\tif (status)\n\t\t*status = readl(&dev->IndexRegs->Mailbox[0]);\n\tif (r1)\n\t\t*r1 = readl(&dev->IndexRegs->Mailbox[1]);\n\tif (r2)\n\t\t*r2 = readl(&dev->IndexRegs->Mailbox[2]);\n\tif (r3)\n\t\t*r3 = readl(&dev->IndexRegs->Mailbox[3]);\n\tif (r4)\n\t\t*r4 = readl(&dev->IndexRegs->Mailbox[4]);\n\t \n\trx_writel(dev, OutboundDoorbellReg, OUTBOUNDDOORBELL_0);\n\t \n\taac_adapter_enable_int(dev);\n\treturn 0;\n\n}\n\n \n\nstatic void aac_rx_interrupt_adapter(struct aac_dev *dev)\n{\n\trx_sync_cmd(dev, BREAKPOINT_REQUEST, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL);\n}\n\n \n\nstatic void aac_rx_notify_adapter(struct aac_dev *dev, u32 event)\n{\n\tswitch (event) {\n\n\tcase AdapNormCmdQue:\n\t\trx_writel(dev, MUnit.IDR,INBOUNDDOORBELL_1);\n\t\tbreak;\n\tcase HostNormRespNotFull:\n\t\trx_writel(dev, MUnit.IDR,INBOUNDDOORBELL_4);\n\t\tbreak;\n\tcase AdapNormRespQue:\n\t\trx_writel(dev, MUnit.IDR,INBOUNDDOORBELL_2);\n\t\tbreak;\n\tcase HostNormCmdNotFull:\n\t\trx_writel(dev, MUnit.IDR,INBOUNDDOORBELL_3);\n\t\tbreak;\n\tcase HostShutdown:\n\t\tbreak;\n\tcase FastIo:\n\t\trx_writel(dev, MUnit.IDR,INBOUNDDOORBELL_6);\n\t\tbreak;\n\tcase AdapPrintfDone:\n\t\trx_writel(dev, MUnit.IDR,INBOUNDDOORBELL_5);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void aac_rx_start_adapter(struct aac_dev *dev)\n{\n\tunion aac_init *init;\n\n\tinit = dev->init;\n\tinit->r7.host_elapsed_seconds = cpu_to_le32(ktime_get_real_seconds());\n\t \n\trx_sync_cmd(dev, INIT_STRUCT_BASE_ADDRESS, (u32)(ulong)dev->init_pa,\n\t  0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL);\n}\n\n \nstatic int aac_rx_check_health(struct aac_dev *dev)\n{\n\tu32 status = rx_readl(dev, MUnit.OMRx[0]);\n\n\t \n\tif (unlikely(status & SELF_TEST_FAILED))\n\t\treturn -1;\n\t \n\tif (unlikely(status & KERNEL_PANIC)) {\n\t\tchar * buffer;\n\t\tstruct POSTSTATUS {\n\t\t\t__le32 Post_Command;\n\t\t\t__le32 Post_Address;\n\t\t} * post;\n\t\tdma_addr_t paddr, baddr;\n\t\tint ret;\n\n\t\tif (likely((status & 0xFF000000L) == 0xBC000000L))\n\t\t\treturn (status >> 16) & 0xFF;\n\t\tbuffer = dma_alloc_coherent(&dev->pdev->dev, 512, &baddr,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tret = -2;\n\t\tif (unlikely(buffer == NULL))\n\t\t\treturn ret;\n\t\tpost = dma_alloc_coherent(&dev->pdev->dev,\n\t\t\t\t\t  sizeof(struct POSTSTATUS), &paddr,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (unlikely(post == NULL)) {\n\t\t\tdma_free_coherent(&dev->pdev->dev, 512, buffer, baddr);\n\t\t\treturn ret;\n\t\t}\n\t\tmemset(buffer, 0, 512);\n\t\tpost->Post_Command = cpu_to_le32(COMMAND_POST_RESULTS);\n\t\tpost->Post_Address = cpu_to_le32(baddr);\n\t\trx_writel(dev, MUnit.IMRx[0], paddr);\n\t\trx_sync_cmd(dev, COMMAND_POST_RESULTS, baddr, 0, 0, 0, 0, 0,\n\t\t  NULL, NULL, NULL, NULL, NULL);\n\t\tdma_free_coherent(&dev->pdev->dev, sizeof(struct POSTSTATUS),\n\t\t\t\t  post, paddr);\n\t\tif (likely((buffer[0] == '0') && ((buffer[1] == 'x') || (buffer[1] == 'X')))) {\n\t\t\tret = (hex_to_bin(buffer[2]) << 4) +\n\t\t\t\thex_to_bin(buffer[3]);\n\t\t}\n\t\tdma_free_coherent(&dev->pdev->dev, 512, buffer, baddr);\n\t\treturn ret;\n\t}\n\t \n\tif (unlikely(!(status & KERNEL_UP_AND_RUNNING)))\n\t\treturn -3;\n\t \n\treturn 0;\n}\n\n \nint aac_rx_deliver_producer(struct fib * fib)\n{\n\tstruct aac_dev *dev = fib->dev;\n\tstruct aac_queue *q = &dev->queues->queue[AdapNormCmdQueue];\n\tu32 Index;\n\tunsigned long nointr = 0;\n\n\taac_queue_get( dev, &Index, AdapNormCmdQueue, fib->hw_fib_va, 1, fib, &nointr);\n\n\tatomic_inc(&q->numpending);\n\t*(q->headers.producer) = cpu_to_le32(Index + 1);\n\tif (!(nointr & aac_config.irq_mod))\n\t\taac_adapter_notify(dev, AdapNormCmdQueue);\n\n\treturn 0;\n}\n\n \nstatic int aac_rx_deliver_message(struct fib * fib)\n{\n\tstruct aac_dev *dev = fib->dev;\n\tstruct aac_queue *q = &dev->queues->queue[AdapNormCmdQueue];\n\tu32 Index;\n\tu64 addr;\n\tvolatile void __iomem *device;\n\n\tunsigned long count = 10000000L;  \n\tatomic_inc(&q->numpending);\n\tfor(;;) {\n\t\tIndex = rx_readl(dev, MUnit.InboundQueue);\n\t\tif (unlikely(Index == 0xFFFFFFFFL))\n\t\t\tIndex = rx_readl(dev, MUnit.InboundQueue);\n\t\tif (likely(Index != 0xFFFFFFFFL))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tatomic_dec(&q->numpending);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(5);\n\t}\n\tdevice = dev->base + Index;\n\taddr = fib->hw_fib_pa;\n\twritel((u32)(addr & 0xffffffff), device);\n\tdevice += sizeof(u32);\n\twritel((u32)(addr >> 32), device);\n\tdevice += sizeof(u32);\n\twritel(le16_to_cpu(fib->hw_fib_va->header.Size), device);\n\trx_writel(dev, MUnit.InboundQueue, Index);\n\treturn 0;\n}\n\n \nstatic int aac_rx_ioremap(struct aac_dev * dev, u32 size)\n{\n\tif (!size) {\n\t\tiounmap(dev->regs.rx);\n\t\treturn 0;\n\t}\n\tdev->base = dev->regs.rx = ioremap(dev->base_start, size);\n\tif (dev->base == NULL)\n\t\treturn -1;\n\tdev->IndexRegs = &dev->regs.rx->IndexRegs;\n\treturn 0;\n}\n\nstatic int aac_rx_restart_adapter(struct aac_dev *dev, int bled, u8 reset_type)\n{\n\tu32 var = 0;\n\n\tif (!(dev->supplement_adapter_info.supported_options2 &\n\t  AAC_OPTION_MU_RESET) || (bled >= 0) || (bled == -2)) {\n\t\tif (bled)\n\t\t\tprintk(KERN_ERR \"%s%d: adapter kernel panic'd %x.\\n\",\n\t\t\t\tdev->name, dev->id, bled);\n\t\telse {\n\t\t\tbled = aac_adapter_sync_cmd(dev, IOP_RESET_ALWAYS,\n\t\t\t  0, 0, 0, 0, 0, 0, &var, NULL, NULL, NULL, NULL);\n\t\t\tif (!bled && (var != 0x00000001) && (var != 0x3803000F))\n\t\t\t\tbled = -EINVAL;\n\t\t}\n\t\tif (bled && (bled != -ETIMEDOUT))\n\t\t\tbled = aac_adapter_sync_cmd(dev, IOP_RESET,\n\t\t\t  0, 0, 0, 0, 0, 0, &var, NULL, NULL, NULL, NULL);\n\n\t\tif (bled && (bled != -ETIMEDOUT))\n\t\t\treturn -EINVAL;\n\t}\n\tif (bled && (var == 0x3803000F)) {  \n\t\trx_writel(dev, MUnit.reserved2, 3);\n\t\tmsleep(5000);  \n\t\tvar = 0x00000001;\n\t}\n\tif (bled && (var != 0x00000001))\n\t\treturn -EINVAL;\n\tssleep(5);\n\tif (rx_readl(dev, MUnit.OMRx[0]) & KERNEL_PANIC)\n\t\treturn -ENODEV;\n\tif (startup_timeout < 300)\n\t\tstartup_timeout = 300;\n\treturn 0;\n}\n\n \n\nint aac_rx_select_comm(struct aac_dev *dev, int comm)\n{\n\tswitch (comm) {\n\tcase AAC_COMM_PRODUCER:\n\t\tdev->a_ops.adapter_enable_int = aac_rx_enable_interrupt_producer;\n\t\tdev->a_ops.adapter_intr = aac_rx_intr_producer;\n\t\tdev->a_ops.adapter_deliver = aac_rx_deliver_producer;\n\t\tbreak;\n\tcase AAC_COMM_MESSAGE:\n\t\tdev->a_ops.adapter_enable_int = aac_rx_enable_interrupt_message;\n\t\tdev->a_ops.adapter_intr = aac_rx_intr_message;\n\t\tdev->a_ops.adapter_deliver = aac_rx_deliver_message;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nint _aac_rx_init(struct aac_dev *dev)\n{\n\tunsigned long start;\n\tunsigned long status;\n\tint restart = 0;\n\tint instance = dev->id;\n\tconst char * name = dev->name;\n\n\tif (aac_adapter_ioremap(dev, dev->base_size)) {\n\t\tprintk(KERN_WARNING \"%s: unable to map adapter.\\n\", name);\n\t\tgoto error_iounmap;\n\t}\n\n\t \n\tdev->a_ops.adapter_sync_cmd = rx_sync_cmd;\n\tdev->a_ops.adapter_enable_int = aac_rx_disable_interrupt;\n\tdev->OIMR = status = rx_readb (dev, MUnit.OIMR);\n\n\tif (((status & 0x0c) != 0x0c) || dev->init_reset) {\n\t\tdev->init_reset = false;\n\t\tif (!aac_rx_restart_adapter(dev, 0, IOP_HWSOFT_RESET)) {\n\t\t\t \n\t\t\twhile ((++restart < 512) &&\n\t\t\t       (rx_readl(dev, MUnit.OutboundQueue) != 0xFFFFFFFFL));\n\t\t}\n\t}\n\n\t \n\tstatus = rx_readl(dev, MUnit.OMRx[0]);\n\tif (status & KERNEL_PANIC) {\n\t\tif (aac_rx_restart_adapter(dev,\n\t\t\taac_rx_check_health(dev), IOP_HWSOFT_RESET))\n\t\t\tgoto error_iounmap;\n\t\t++restart;\n\t}\n\t \n\tstatus = rx_readl(dev, MUnit.OMRx[0]);\n\tif (status & SELF_TEST_FAILED) {\n\t\tprintk(KERN_ERR \"%s%d: adapter self-test failed.\\n\", dev->name, instance);\n\t\tgoto error_iounmap;\n\t}\n\t \n\tif (status & MONITOR_PANIC) {\n\t\tprintk(KERN_ERR \"%s%d: adapter monitor panic.\\n\", dev->name, instance);\n\t\tgoto error_iounmap;\n\t}\n\tstart = jiffies;\n\t \n\twhile (!((status = rx_readl(dev, MUnit.OMRx[0])) & KERNEL_UP_AND_RUNNING))\n\t{\n\t\tif ((restart &&\n\t\t  (status & (KERNEL_PANIC|SELF_TEST_FAILED|MONITOR_PANIC))) ||\n\t\t  time_after(jiffies, start+HZ*startup_timeout)) {\n\t\t\tprintk(KERN_ERR \"%s%d: adapter kernel failed to start, init status = %lx.\\n\", \n\t\t\t\t\tdev->name, instance, status);\n\t\t\tgoto error_iounmap;\n\t\t}\n\t\tif (!restart &&\n\t\t  ((status & (KERNEL_PANIC|SELF_TEST_FAILED|MONITOR_PANIC)) ||\n\t\t  time_after(jiffies, start + HZ *\n\t\t  ((startup_timeout > 60)\n\t\t    ? (startup_timeout - 60)\n\t\t    : (startup_timeout / 2))))) {\n\t\t\tif (likely(!aac_rx_restart_adapter(dev,\n\t\t\t\taac_rx_check_health(dev), IOP_HWSOFT_RESET)))\n\t\t\t\tstart = jiffies;\n\t\t\t++restart;\n\t\t}\n\t\tmsleep(1);\n\t}\n\tif (restart && aac_commit)\n\t\taac_commit = 1;\n\t \n\tdev->a_ops.adapter_interrupt = aac_rx_interrupt_adapter;\n\tdev->a_ops.adapter_disable_int = aac_rx_disable_interrupt;\n\tdev->a_ops.adapter_notify = aac_rx_notify_adapter;\n\tdev->a_ops.adapter_sync_cmd = rx_sync_cmd;\n\tdev->a_ops.adapter_check_health = aac_rx_check_health;\n\tdev->a_ops.adapter_restart = aac_rx_restart_adapter;\n\tdev->a_ops.adapter_start = aac_rx_start_adapter;\n\n\t \n\taac_adapter_comm(dev, AAC_COMM_PRODUCER);\n\taac_adapter_disable_int(dev);\n\trx_writel(dev, MUnit.ODR, 0xffffffff);\n\taac_adapter_enable_int(dev);\n\n\tif (aac_init_adapter(dev) == NULL)\n\t\tgoto error_iounmap;\n\taac_adapter_comm(dev, dev->comm_interface);\n\tdev->sync_mode = 0;\t \n\tdev->msi = aac_msi && !pci_enable_msi(dev->pdev);\n\tif (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,\n\t\t\tIRQF_SHARED, \"aacraid\", dev) < 0) {\n\t\tif (dev->msi)\n\t\t\tpci_disable_msi(dev->pdev);\n\t\tprintk(KERN_ERR \"%s%d: Interrupt unavailable.\\n\",\n\t\t\tname, instance);\n\t\tgoto error_iounmap;\n\t}\n\tdev->dbg_base = dev->base_start;\n\tdev->dbg_base_mapped = dev->base;\n\tdev->dbg_size = dev->base_size;\n\n\taac_adapter_enable_int(dev);\n\t \n\taac_rx_start_adapter(dev);\n\n\treturn 0;\n\nerror_iounmap:\n\n\treturn -1;\n}\n\nint aac_rx_init(struct aac_dev *dev)\n{\n\t \n\tdev->a_ops.adapter_ioremap = aac_rx_ioremap;\n\tdev->a_ops.adapter_comm = aac_rx_select_comm;\n\n\treturn _aac_rx_init(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}