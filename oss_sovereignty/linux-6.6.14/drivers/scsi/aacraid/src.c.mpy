{
  "module_name": "src.c",
  "hash_id": "da0afcd606df941ca72c3c9e4ae991c83b126beb6ed362a15f1b4e21aedbeb23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/src.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/time.h>\n#include <linux/interrupt.h>\n#include <scsi/scsi_host.h>\n\n#include \"aacraid.h\"\n\nstatic int aac_src_get_sync_status(struct aac_dev *dev);\n\nstatic irqreturn_t aac_src_intr_message(int irq, void *dev_id)\n{\n\tstruct aac_msix_ctx *ctx;\n\tstruct aac_dev *dev;\n\tunsigned long bellbits, bellbits_shifted;\n\tint vector_no;\n\tint isFastResponse, mode;\n\tu32 index, handle;\n\n\tctx = (struct aac_msix_ctx *)dev_id;\n\tdev = ctx->dev;\n\tvector_no = ctx->vector_no;\n\n\tif (dev->msi_enabled) {\n\t\tmode = AAC_INT_MODE_MSI;\n\t\tif (vector_no == 0) {\n\t\t\tbellbits = src_readl(dev, MUnit.ODR_MSI);\n\t\t\tif (bellbits & 0x40000)\n\t\t\t\tmode |= AAC_INT_MODE_AIF;\n\t\t\tif (bellbits & 0x1000)\n\t\t\t\tmode |= AAC_INT_MODE_SYNC;\n\t\t}\n\t} else {\n\t\tmode = AAC_INT_MODE_INTX;\n\t\tbellbits = src_readl(dev, MUnit.ODR_R);\n\t\tif (bellbits & PmDoorBellResponseSent) {\n\t\t\tbellbits = PmDoorBellResponseSent;\n\t\t\tsrc_writel(dev, MUnit.ODR_C, bellbits);\n\t\t\tsrc_readl(dev, MUnit.ODR_C);\n\t\t} else {\n\t\t\tbellbits_shifted = (bellbits >> SRC_ODR_SHIFT);\n\t\t\tsrc_writel(dev, MUnit.ODR_C, bellbits);\n\t\t\tsrc_readl(dev, MUnit.ODR_C);\n\n\t\t\tif (bellbits_shifted & DoorBellAifPending)\n\t\t\t\tmode |= AAC_INT_MODE_AIF;\n\t\t\telse if (bellbits_shifted & OUTBOUNDDOORBELL_0)\n\t\t\t\tmode |= AAC_INT_MODE_SYNC;\n\t\t}\n\t}\n\n\tif (mode & AAC_INT_MODE_SYNC) {\n\t\tunsigned long sflags;\n\t\tstruct list_head *entry;\n\t\tint send_it = 0;\n\t\textern int aac_sync_mode;\n\n\t\tif (!aac_sync_mode && !dev->msi_enabled) {\n\t\t\tsrc_writel(dev, MUnit.ODR_C, bellbits);\n\t\t\tsrc_readl(dev, MUnit.ODR_C);\n\t\t}\n\n\t\tif (dev->sync_fib) {\n\t\t\tif (dev->sync_fib->callback)\n\t\t\t\tdev->sync_fib->callback(dev->sync_fib->callback_data,\n\t\t\t\t\tdev->sync_fib);\n\t\t\tspin_lock_irqsave(&dev->sync_fib->event_lock, sflags);\n\t\t\tif (dev->sync_fib->flags & FIB_CONTEXT_FLAG_WAIT) {\n\t\t\t\tdev->management_fib_count--;\n\t\t\t\tcomplete(&dev->sync_fib->event_wait);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&dev->sync_fib->event_lock,\n\t\t\t\t\t\tsflags);\n\t\t\tspin_lock_irqsave(&dev->sync_lock, sflags);\n\t\t\tif (!list_empty(&dev->sync_fib_list)) {\n\t\t\t\tentry = dev->sync_fib_list.next;\n\t\t\t\tdev->sync_fib = list_entry(entry,\n\t\t\t\t\t\t\t   struct fib,\n\t\t\t\t\t\t\t   fiblink);\n\t\t\t\tlist_del(entry);\n\t\t\t\tsend_it = 1;\n\t\t\t} else {\n\t\t\t\tdev->sync_fib = NULL;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&dev->sync_lock, sflags);\n\t\t\tif (send_it) {\n\t\t\t\taac_adapter_sync_cmd(dev, SEND_SYNCHRONOUS_FIB,\n\t\t\t\t\t(u32)dev->sync_fib->hw_fib_pa,\n\t\t\t\t\t0, 0, 0, 0, 0,\n\t\t\t\t\tNULL, NULL, NULL, NULL, NULL);\n\t\t\t}\n\t\t}\n\t\tif (!dev->msi_enabled)\n\t\t\tmode = 0;\n\n\t}\n\n\tif (mode & AAC_INT_MODE_AIF) {\n\t\t \n\t\tif (dev->sa_firmware) {\n\t\t\tu32 events = src_readl(dev, MUnit.SCR0);\n\n\t\t\taac_intr_normal(dev, events, 1, 0, NULL);\n\t\t\twritel(events, &dev->IndexRegs->Mailbox[0]);\n\t\t\tsrc_writel(dev, MUnit.IDR, 1 << 23);\n\t\t} else {\n\t\t\tif (dev->aif_thread && dev->fsa_dev)\n\t\t\t\taac_intr_normal(dev, 0, 2, 0, NULL);\n\t\t}\n\t\tif (dev->msi_enabled)\n\t\t\taac_src_access_devreg(dev, AAC_CLEAR_AIF_BIT);\n\t\tmode = 0;\n\t}\n\n\tif (mode) {\n\t\tindex = dev->host_rrq_idx[vector_no];\n\n\t\tfor (;;) {\n\t\t\tisFastResponse = 0;\n\t\t\t \n\t\t\thandle = le32_to_cpu((dev->host_rrq[index])\n\t\t\t\t& 0x7fffffff);\n\t\t\t \n\t\t\tif (handle & 0x40000000)\n\t\t\t\tisFastResponse = 1;\n\t\t\thandle &= 0x0000ffff;\n\t\t\tif (handle == 0)\n\t\t\t\tbreak;\n\t\t\thandle >>= 2;\n\t\t\tif (dev->msi_enabled && dev->max_msix > 1)\n\t\t\t\tatomic_dec(&dev->rrq_outstanding[vector_no]);\n\t\t\taac_intr_normal(dev, handle, 0, isFastResponse, NULL);\n\t\t\tdev->host_rrq[index++] = 0;\n\t\t\tif (index == (vector_no + 1) * dev->vector_cap)\n\t\t\t\tindex = vector_no * dev->vector_cap;\n\t\t\tdev->host_rrq_idx[vector_no] = index;\n\t\t}\n\t\tmode = 0;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void aac_src_disable_interrupt(struct aac_dev *dev)\n{\n\tsrc_writel(dev, MUnit.OIMR, dev->OIMR = 0xffffffff);\n}\n\n \n\nstatic void aac_src_enable_interrupt_message(struct aac_dev *dev)\n{\n\taac_src_access_devreg(dev, AAC_ENABLE_INTERRUPT);\n}\n\n \n\nstatic int src_sync_cmd(struct aac_dev *dev, u32 command,\n\tu32 p1, u32 p2, u32 p3, u32 p4, u32 p5, u32 p6,\n\tu32 *status, u32 * r1, u32 * r2, u32 * r3, u32 * r4)\n{\n\tunsigned long start;\n\tunsigned long delay;\n\tint ok;\n\n\t \n\twritel(command, &dev->IndexRegs->Mailbox[0]);\n\t \n\twritel(p1, &dev->IndexRegs->Mailbox[1]);\n\twritel(p2, &dev->IndexRegs->Mailbox[2]);\n\twritel(p3, &dev->IndexRegs->Mailbox[3]);\n\twritel(p4, &dev->IndexRegs->Mailbox[4]);\n\n\t \n\tif (!dev->msi_enabled)\n\t\tsrc_writel(dev,\n\t\t\t   MUnit.ODR_C,\n\t\t\t   OUTBOUNDDOORBELL_0 << SRC_ODR_SHIFT);\n\n\t \n\tsrc_writel(dev, MUnit.OIMR, dev->OIMR = 0xffffffff);\n\n\t \n\tsrc_readl(dev, MUnit.OIMR);\n\n\t \n\tsrc_writel(dev, MUnit.IDR, INBOUNDDOORBELL_0 << SRC_IDR_SHIFT);\n\n\tif ((!dev->sync_mode || command != SEND_SYNCHRONOUS_FIB) &&\n\t\t!dev->in_soft_reset) {\n\t\tok = 0;\n\t\tstart = jiffies;\n\n\t\tif (command == IOP_RESET_ALWAYS) {\n\t\t\t \n\t\t\tdelay = 10*HZ;\n\t\t} else {\n\t\t\t \n\t\t\tdelay = 300*HZ;\n\t\t}\n\t\twhile (time_before(jiffies, start+delay)) {\n\t\t\tudelay(5);\t \n\t\t\t \n\t\t\tif (aac_src_get_sync_status(dev) & OUTBOUNDDOORBELL_0) {\n\t\t\t\t \n\t\t\t\tif (dev->msi_enabled)\n\t\t\t\t\taac_src_access_devreg(dev,\n\t\t\t\t\t\tAAC_CLEAR_SYNC_BIT);\n\t\t\t\telse\n\t\t\t\t\tsrc_writel(dev,\n\t\t\t\t\t\tMUnit.ODR_C,\n\t\t\t\t\t\tOUTBOUNDDOORBELL_0 << SRC_ODR_SHIFT);\n\t\t\t\tok = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tmsleep(1);\n\t\t}\n\t\tif (unlikely(ok != 1)) {\n\t\t\t \n\t\t\taac_adapter_enable_int(dev);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\t \n\t\tif (status)\n\t\t\t*status = readl(&dev->IndexRegs->Mailbox[0]);\n\t\tif (r1)\n\t\t\t*r1 = readl(&dev->IndexRegs->Mailbox[1]);\n\t\tif (r2)\n\t\t\t*r2 = readl(&dev->IndexRegs->Mailbox[2]);\n\t\tif (r3)\n\t\t\t*r3 = readl(&dev->IndexRegs->Mailbox[3]);\n\t\tif (r4)\n\t\t\t*r4 = readl(&dev->IndexRegs->Mailbox[4]);\n\t\tif (command == GET_COMM_PREFERRED_SETTINGS)\n\t\t\tdev->max_msix =\n\t\t\t\treadl(&dev->IndexRegs->Mailbox[5]) & 0xFFFF;\n\t\t \n\t\tif (!dev->msi_enabled)\n\t\t\tsrc_writel(dev,\n\t\t\t\tMUnit.ODR_C,\n\t\t\t\tOUTBOUNDDOORBELL_0 << SRC_ODR_SHIFT);\n\t}\n\n\t \n\taac_adapter_enable_int(dev);\n\treturn 0;\n}\n\n \n\nstatic void aac_src_interrupt_adapter(struct aac_dev *dev)\n{\n\tsrc_sync_cmd(dev, BREAKPOINT_REQUEST,\n\t\t0, 0, 0, 0, 0, 0,\n\t\tNULL, NULL, NULL, NULL, NULL);\n}\n\n \n\nstatic void aac_src_notify_adapter(struct aac_dev *dev, u32 event)\n{\n\tswitch (event) {\n\n\tcase AdapNormCmdQue:\n\t\tsrc_writel(dev, MUnit.ODR_C,\n\t\t\tINBOUNDDOORBELL_1 << SRC_ODR_SHIFT);\n\t\tbreak;\n\tcase HostNormRespNotFull:\n\t\tsrc_writel(dev, MUnit.ODR_C,\n\t\t\tINBOUNDDOORBELL_4 << SRC_ODR_SHIFT);\n\t\tbreak;\n\tcase AdapNormRespQue:\n\t\tsrc_writel(dev, MUnit.ODR_C,\n\t\t\tINBOUNDDOORBELL_2 << SRC_ODR_SHIFT);\n\t\tbreak;\n\tcase HostNormCmdNotFull:\n\t\tsrc_writel(dev, MUnit.ODR_C,\n\t\t\tINBOUNDDOORBELL_3 << SRC_ODR_SHIFT);\n\t\tbreak;\n\tcase FastIo:\n\t\tsrc_writel(dev, MUnit.ODR_C,\n\t\t\tINBOUNDDOORBELL_6 << SRC_ODR_SHIFT);\n\t\tbreak;\n\tcase AdapPrintfDone:\n\t\tsrc_writel(dev, MUnit.ODR_C,\n\t\t\tINBOUNDDOORBELL_5 << SRC_ODR_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void aac_src_start_adapter(struct aac_dev *dev)\n{\n\tunion aac_init *init;\n\tint i;\n\n\t  \n\tfor (i = 0; i < dev->max_msix; i++) {\n\t\tdev->host_rrq_idx[i] = i * dev->vector_cap;\n\t\tatomic_set(&dev->rrq_outstanding[i], 0);\n\t}\n\tatomic_set(&dev->msix_counter, 0);\n\tdev->fibs_pushed_no = 0;\n\n\tinit = dev->init;\n\tif (dev->comm_interface == AAC_COMM_MESSAGE_TYPE3) {\n\t\tinit->r8.host_elapsed_seconds =\n\t\t\tcpu_to_le32(ktime_get_real_seconds());\n\t\tsrc_sync_cmd(dev, INIT_STRUCT_BASE_ADDRESS,\n\t\t\tlower_32_bits(dev->init_pa),\n\t\t\tupper_32_bits(dev->init_pa),\n\t\t\tsizeof(struct _r8) +\n\t\t\t(AAC_MAX_HRRQ - 1) * sizeof(struct _rrq),\n\t\t\t0, 0, 0, NULL, NULL, NULL, NULL, NULL);\n\t} else {\n\t\tinit->r7.host_elapsed_seconds =\n\t\t\tcpu_to_le32(ktime_get_real_seconds());\n\t\t\n\t\tsrc_sync_cmd(dev, INIT_STRUCT_BASE_ADDRESS,\n\t\t\t(u32)(ulong)dev->init_pa, 0, 0, 0, 0, 0,\n\t\t\tNULL, NULL, NULL, NULL, NULL);\n\t}\n\n}\n\n \nstatic int aac_src_check_health(struct aac_dev *dev)\n{\n\tu32 status = src_readl(dev, MUnit.OMR);\n\n\t \n\tif (unlikely(status & KERNEL_PANIC))\n\t\tgoto err_blink;\n\n\t \n\tif (unlikely(status & SELF_TEST_FAILED))\n\t\tgoto err_out;\n\n\t \n\tif (unlikely(status & MONITOR_PANIC))\n\t\tgoto err_out;\n\n\t \n\tif (unlikely(!(status & KERNEL_UP_AND_RUNNING)))\n\t\treturn -3;\n\t \n\treturn 0;\n\nerr_out:\n\treturn -1;\n\nerr_blink:\n\treturn (status >> 16) & 0xFF;\n}\n\nstatic inline u32 aac_get_vector(struct aac_dev *dev)\n{\n\treturn atomic_inc_return(&dev->msix_counter)%dev->max_msix;\n}\n\n \nstatic int aac_src_deliver_message(struct fib *fib)\n{\n\tstruct aac_dev *dev = fib->dev;\n\tstruct aac_queue *q = &dev->queues->queue[AdapNormCmdQueue];\n\tu32 fibsize;\n\tdma_addr_t address;\n\tstruct aac_fib_xporthdr *pFibX;\n\tint native_hba;\n#if !defined(writeq)\n\tunsigned long flags;\n#endif\n\n\tu16 vector_no;\n\n\tatomic_inc(&q->numpending);\n\n\tnative_hba = (fib->flags & FIB_CONTEXT_FLAG_NATIVE_HBA) ? 1 : 0;\n\n\n\tif (dev->msi_enabled && dev->max_msix > 1 &&\n\t\t(native_hba || fib->hw_fib_va->header.Command != AifRequest)) {\n\n\t\tif ((dev->comm_interface == AAC_COMM_MESSAGE_TYPE3)\n\t\t\t&& dev->sa_firmware)\n\t\t\tvector_no = aac_get_vector(dev);\n\t\telse\n\t\t\tvector_no = fib->vector_no;\n\n\t\tif (native_hba) {\n\t\t\tif (fib->flags & FIB_CONTEXT_FLAG_NATIVE_HBA_TMF) {\n\t\t\t\tstruct aac_hba_tm_req *tm_req;\n\n\t\t\t\ttm_req = (struct aac_hba_tm_req *)\n\t\t\t\t\t\tfib->hw_fib_va;\n\t\t\t\tif (tm_req->iu_type ==\n\t\t\t\t\tHBA_IU_TYPE_SCSI_TM_REQ) {\n\t\t\t\t\t((struct aac_hba_tm_req *)\n\t\t\t\t\t\tfib->hw_fib_va)->reply_qid\n\t\t\t\t\t\t\t= vector_no;\n\t\t\t\t\t((struct aac_hba_tm_req *)\n\t\t\t\t\t\tfib->hw_fib_va)->request_id\n\t\t\t\t\t\t\t+= (vector_no << 16);\n\t\t\t\t} else {\n\t\t\t\t\t((struct aac_hba_reset_req *)\n\t\t\t\t\t\tfib->hw_fib_va)->reply_qid\n\t\t\t\t\t\t\t= vector_no;\n\t\t\t\t\t((struct aac_hba_reset_req *)\n\t\t\t\t\t\tfib->hw_fib_va)->request_id\n\t\t\t\t\t\t\t+= (vector_no << 16);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t((struct aac_hba_cmd_req *)\n\t\t\t\t\tfib->hw_fib_va)->reply_qid\n\t\t\t\t\t\t= vector_no;\n\t\t\t\t((struct aac_hba_cmd_req *)\n\t\t\t\t\tfib->hw_fib_va)->request_id\n\t\t\t\t\t\t+= (vector_no << 16);\n\t\t\t}\n\t\t} else {\n\t\t\tfib->hw_fib_va->header.Handle += (vector_no << 16);\n\t\t}\n\t} else {\n\t\tvector_no = 0;\n\t}\n\n\tatomic_inc(&dev->rrq_outstanding[vector_no]);\n\n\tif (native_hba) {\n\t\taddress = fib->hw_fib_pa;\n\t\tfibsize = (fib->hbacmd_size + 127) / 128 - 1;\n\t\tif (fibsize > 31)\n\t\t\tfibsize = 31;\n\t\taddress |= fibsize;\n#if defined(writeq)\n\t\tsrc_writeq(dev, MUnit.IQN_L, (u64)address);\n#else\n\t\tspin_lock_irqsave(&fib->dev->iq_lock, flags);\n\t\tsrc_writel(dev, MUnit.IQN_H,\n\t\t\tupper_32_bits(address) & 0xffffffff);\n\t\tsrc_writel(dev, MUnit.IQN_L, address & 0xffffffff);\n\t\tspin_unlock_irqrestore(&fib->dev->iq_lock, flags);\n#endif\n\t} else {\n\t\tif (dev->comm_interface == AAC_COMM_MESSAGE_TYPE2 ||\n\t\t\tdev->comm_interface == AAC_COMM_MESSAGE_TYPE3) {\n\t\t\t \n\t\t\tfibsize = (le16_to_cpu(fib->hw_fib_va->header.Size)\n\t\t\t\t+ 127) / 128 - 1;\n\t\t\t \n\t\t\taddress = fib->hw_fib_pa;\n\t\t\tfib->hw_fib_va->header.StructType = FIB_MAGIC2;\n\t\t\tfib->hw_fib_va->header.SenderFibAddress =\n\t\t\t\tcpu_to_le32((u32)address);\n\t\t\tfib->hw_fib_va->header.u.TimeStamp = 0;\n\t\t\tWARN_ON(upper_32_bits(address) != 0L);\n\t\t} else {\n\t\t\t \n\t\t\tfibsize = (sizeof(struct aac_fib_xporthdr) +\n\t\t\t\tle16_to_cpu(fib->hw_fib_va->header.Size)\n\t\t\t\t+ 127) / 128 - 1;\n\t\t\t \n\t\t\tpFibX = (struct aac_fib_xporthdr *)\n\t\t\t\t((unsigned char *)fib->hw_fib_va -\n\t\t\t\tsizeof(struct aac_fib_xporthdr));\n\t\t\tpFibX->Handle = fib->hw_fib_va->header.Handle;\n\t\t\tpFibX->HostAddress =\n\t\t\t\tcpu_to_le64((u64)fib->hw_fib_pa);\n\t\t\tpFibX->Size = cpu_to_le32(\n\t\t\t\tle16_to_cpu(fib->hw_fib_va->header.Size));\n\t\t\taddress = fib->hw_fib_pa -\n\t\t\t\t(u64)sizeof(struct aac_fib_xporthdr);\n\t\t}\n\t\tif (fibsize > 31)\n\t\t\tfibsize = 31;\n\t\taddress |= fibsize;\n\n#if defined(writeq)\n\t\tsrc_writeq(dev, MUnit.IQ_L, (u64)address);\n#else\n\t\tspin_lock_irqsave(&fib->dev->iq_lock, flags);\n\t\tsrc_writel(dev, MUnit.IQ_H,\n\t\t\tupper_32_bits(address) & 0xffffffff);\n\t\tsrc_writel(dev, MUnit.IQ_L, address & 0xffffffff);\n\t\tspin_unlock_irqrestore(&fib->dev->iq_lock, flags);\n#endif\n\t}\n\treturn 0;\n}\n\n \nstatic int aac_src_ioremap(struct aac_dev *dev, u32 size)\n{\n\tif (!size) {\n\t\tiounmap(dev->regs.src.bar1);\n\t\tdev->regs.src.bar1 = NULL;\n\t\tiounmap(dev->regs.src.bar0);\n\t\tdev->base = dev->regs.src.bar0 = NULL;\n\t\treturn 0;\n\t}\n\tdev->regs.src.bar1 = ioremap(pci_resource_start(dev->pdev, 2),\n\t\tAAC_MIN_SRC_BAR1_SIZE);\n\tdev->base = NULL;\n\tif (dev->regs.src.bar1 == NULL)\n\t\treturn -1;\n\tdev->base = dev->regs.src.bar0 = ioremap(dev->base_start, size);\n\tif (dev->base == NULL) {\n\t\tiounmap(dev->regs.src.bar1);\n\t\tdev->regs.src.bar1 = NULL;\n\t\treturn -1;\n\t}\n\tdev->IndexRegs = &((struct src_registers __iomem *)\n\t\tdev->base)->u.tupelo.IndexRegs;\n\treturn 0;\n}\n\n \nstatic int aac_srcv_ioremap(struct aac_dev *dev, u32 size)\n{\n\tif (!size) {\n\t\tiounmap(dev->regs.src.bar0);\n\t\tdev->base = dev->regs.src.bar0 = NULL;\n\t\treturn 0;\n\t}\n\n\tdev->regs.src.bar1 =\n\tioremap(pci_resource_start(dev->pdev, 2), AAC_MIN_SRCV_BAR1_SIZE);\n\tdev->base = NULL;\n\tif (dev->regs.src.bar1 == NULL)\n\t\treturn -1;\n\tdev->base = dev->regs.src.bar0 = ioremap(dev->base_start, size);\n\tif (dev->base == NULL) {\n\t\tiounmap(dev->regs.src.bar1);\n\t\tdev->regs.src.bar1 = NULL;\n\t\treturn -1;\n\t}\n\tdev->IndexRegs = &((struct src_registers __iomem *)\n\t\tdev->base)->u.denali.IndexRegs;\n\treturn 0;\n}\n\nvoid aac_set_intx_mode(struct aac_dev *dev)\n{\n\tif (dev->msi_enabled) {\n\t\taac_src_access_devreg(dev, AAC_ENABLE_INTX);\n\t\tdev->msi_enabled = 0;\n\t\tmsleep(5000);  \n\t}\n}\n\nstatic void aac_clear_omr(struct aac_dev *dev)\n{\n\tu32 omr_value = 0;\n\n\tomr_value = src_readl(dev, MUnit.OMR);\n\n\t \n\tif ((omr_value == INVALID_OMR) || (omr_value & KERNEL_PANIC))\n\t\tomr_value = 0;\n\n\t \n\tsrc_writel(dev, MUnit.OMR, omr_value & AAC_INT_MODE_MSIX);\n\tsrc_readl(dev, MUnit.OMR);\n}\n\nstatic void aac_dump_fw_fib_iop_reset(struct aac_dev *dev)\n{\n\t__le32 supported_options3;\n\n\tif (!aac_fib_dump)\n\t\treturn;\n\n\tsupported_options3  = dev->supplement_adapter_info.supported_options3;\n\tif (!(supported_options3 & AAC_OPTION_SUPPORTED3_IOP_RESET_FIB_DUMP))\n\t\treturn;\n\n\taac_adapter_sync_cmd(dev, IOP_RESET_FW_FIB_DUMP,\n\t\t\t0, 0, 0,  0, 0, 0, NULL, NULL, NULL, NULL, NULL);\n}\n\nstatic bool aac_is_ctrl_up_and_running(struct aac_dev *dev)\n{\n\tbool ctrl_up = true;\n\tunsigned long status, start;\n\tbool is_up = false;\n\n\tstart = jiffies;\n\tdo {\n\t\tschedule();\n\t\tstatus = src_readl(dev, MUnit.OMR);\n\n\t\tif (status == 0xffffffff)\n\t\t\tstatus = 0;\n\n\t\tif (status & KERNEL_BOOTING) {\n\t\t\tstart = jiffies;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (time_after(jiffies, start+HZ*SOFT_RESET_TIME)) {\n\t\t\tctrl_up = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tis_up = status & KERNEL_UP_AND_RUNNING;\n\n\t} while (!is_up);\n\n\treturn ctrl_up;\n}\n\nstatic void aac_src_drop_io(struct aac_dev *dev)\n{\n\tif (!dev->soft_reset_support)\n\t\treturn;\n\n\taac_adapter_sync_cmd(dev, DROP_IO,\n\t\t\t0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL);\n}\n\nstatic void aac_notify_fw_of_iop_reset(struct aac_dev *dev)\n{\n\taac_adapter_sync_cmd(dev, IOP_RESET_ALWAYS, 0, 0, 0, 0, 0, 0, NULL,\n\t\t\t\t\t\tNULL, NULL, NULL, NULL);\n\taac_src_drop_io(dev);\n}\n\nstatic void aac_send_iop_reset(struct aac_dev *dev)\n{\n\taac_dump_fw_fib_iop_reset(dev);\n\n\taac_notify_fw_of_iop_reset(dev);\n\n\taac_set_intx_mode(dev);\n\n\taac_clear_omr(dev);\n\n\tsrc_writel(dev, MUnit.IDR, IOP_SRC_RESET_MASK);\n\n\tmsleep(5000);\n}\n\nstatic void aac_send_hardware_soft_reset(struct aac_dev *dev)\n{\n\tu_int32_t val;\n\n\taac_clear_omr(dev);\n\tval = readl(((char *)(dev->base) + IBW_SWR_OFFSET));\n\tval |= 0x01;\n\twritel(val, ((char *)(dev->base) + IBW_SWR_OFFSET));\n\tmsleep_interruptible(20000);\n}\n\nstatic int aac_src_restart_adapter(struct aac_dev *dev, int bled, u8 reset_type)\n{\n\tbool is_ctrl_up;\n\tint ret = 0;\n\n\tif (bled < 0)\n\t\tgoto invalid_out;\n\n\tif (bled)\n\t\tdev_err(&dev->pdev->dev, \"adapter kernel panic'd %x.\\n\", bled);\n\n\t \n\tif (bled >= 2 && dev->sa_firmware && reset_type & HW_IOP_RESET)\n\t\treset_type &= ~HW_IOP_RESET;\n\n\tdev->a_ops.adapter_enable_int = aac_src_disable_interrupt;\n\n\tdev_err(&dev->pdev->dev, \"Controller reset type is %d\\n\", reset_type);\n\n\tif (reset_type & HW_IOP_RESET) {\n\t\tdev_info(&dev->pdev->dev, \"Issuing IOP reset\\n\");\n\t\taac_send_iop_reset(dev);\n\n\t\t \n\t\tis_ctrl_up = aac_is_ctrl_up_and_running(dev);\n\t\tif (!is_ctrl_up)\n\t\t\tdev_err(&dev->pdev->dev, \"IOP reset failed\\n\");\n\t\telse {\n\t\t\tdev_info(&dev->pdev->dev, \"IOP reset succeeded\\n\");\n\t\t\tgoto set_startup;\n\t\t}\n\t}\n\n\tif (!dev->sa_firmware) {\n\t\tdev_err(&dev->pdev->dev, \"ARC Reset attempt failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (reset_type & HW_SOFT_RESET) {\n\t\tdev_info(&dev->pdev->dev, \"Issuing SOFT reset\\n\");\n\t\taac_send_hardware_soft_reset(dev);\n\t\tdev->msi_enabled = 0;\n\n\t\tis_ctrl_up = aac_is_ctrl_up_and_running(dev);\n\t\tif (!is_ctrl_up) {\n\t\t\tdev_err(&dev->pdev->dev, \"SOFT reset failed\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto out;\n\t\t} else\n\t\t\tdev_info(&dev->pdev->dev, \"SOFT reset succeeded\\n\");\n\t}\n\nset_startup:\n\tif (startup_timeout < 300)\n\t\tstartup_timeout = 300;\n\nout:\n\treturn ret;\n\ninvalid_out:\n\tif (src_readl(dev, MUnit.OMR) & KERNEL_PANIC)\n\t\tret = -ENODEV;\ngoto out;\n}\n\n \nstatic int aac_src_select_comm(struct aac_dev *dev, int comm)\n{\n\tswitch (comm) {\n\tcase AAC_COMM_MESSAGE:\n\t\tdev->a_ops.adapter_intr = aac_src_intr_message;\n\t\tdev->a_ops.adapter_deliver = aac_src_deliver_message;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nint aac_src_init(struct aac_dev *dev)\n{\n\tunsigned long start;\n\tunsigned long status;\n\tint restart = 0;\n\tint instance = dev->id;\n\tconst char *name = dev->name;\n\n\tdev->a_ops.adapter_ioremap = aac_src_ioremap;\n\tdev->a_ops.adapter_comm = aac_src_select_comm;\n\n\tdev->base_size = AAC_MIN_SRC_BAR0_SIZE;\n\tif (aac_adapter_ioremap(dev, dev->base_size)) {\n\t\tprintk(KERN_WARNING \"%s: unable to map adapter.\\n\", name);\n\t\tgoto error_iounmap;\n\t}\n\n\t \n\tdev->a_ops.adapter_sync_cmd = src_sync_cmd;\n\tdev->a_ops.adapter_enable_int = aac_src_disable_interrupt;\n\n\tif (dev->init_reset) {\n\t\tdev->init_reset = false;\n\t\tif (!aac_src_restart_adapter(dev, 0, IOP_HWSOFT_RESET))\n\t\t\t++restart;\n\t}\n\n\t \n\tstatus = src_readl(dev, MUnit.OMR);\n\tif (status & KERNEL_PANIC) {\n\t\tif (aac_src_restart_adapter(dev,\n\t\t\taac_src_check_health(dev), IOP_HWSOFT_RESET))\n\t\t\tgoto error_iounmap;\n\t\t++restart;\n\t}\n\t \n\tstatus = src_readl(dev, MUnit.OMR);\n\tif (status & SELF_TEST_FAILED) {\n\t\tprintk(KERN_ERR \"%s%d: adapter self-test failed.\\n\",\n\t\t\tdev->name, instance);\n\t\tgoto error_iounmap;\n\t}\n\t \n\tif (status & MONITOR_PANIC) {\n\t\tprintk(KERN_ERR \"%s%d: adapter monitor panic.\\n\",\n\t\t\tdev->name, instance);\n\t\tgoto error_iounmap;\n\t}\n\tstart = jiffies;\n\t \n\twhile (!((status = src_readl(dev, MUnit.OMR)) &\n\t\tKERNEL_UP_AND_RUNNING)) {\n\t\tif ((restart &&\n\t\t  (status & (KERNEL_PANIC|SELF_TEST_FAILED|MONITOR_PANIC))) ||\n\t\t  time_after(jiffies, start+HZ*startup_timeout)) {\n\t\t\tprintk(KERN_ERR \"%s%d: adapter kernel failed to start, init status = %lx.\\n\",\n\t\t\t\t\tdev->name, instance, status);\n\t\t\tgoto error_iounmap;\n\t\t}\n\t\tif (!restart &&\n\t\t  ((status & (KERNEL_PANIC|SELF_TEST_FAILED|MONITOR_PANIC)) ||\n\t\t  time_after(jiffies, start + HZ *\n\t\t  ((startup_timeout > 60)\n\t\t    ? (startup_timeout - 60)\n\t\t    : (startup_timeout / 2))))) {\n\t\t\tif (likely(!aac_src_restart_adapter(dev,\n\t\t\t\taac_src_check_health(dev), IOP_HWSOFT_RESET)))\n\t\t\t\tstart = jiffies;\n\t\t\t++restart;\n\t\t}\n\t\tmsleep(1);\n\t}\n\tif (restart && aac_commit)\n\t\taac_commit = 1;\n\t \n\tdev->a_ops.adapter_interrupt = aac_src_interrupt_adapter;\n\tdev->a_ops.adapter_disable_int = aac_src_disable_interrupt;\n\tdev->a_ops.adapter_enable_int = aac_src_disable_interrupt;\n\tdev->a_ops.adapter_notify = aac_src_notify_adapter;\n\tdev->a_ops.adapter_sync_cmd = src_sync_cmd;\n\tdev->a_ops.adapter_check_health = aac_src_check_health;\n\tdev->a_ops.adapter_restart = aac_src_restart_adapter;\n\tdev->a_ops.adapter_start = aac_src_start_adapter;\n\n\t \n\taac_adapter_comm(dev, AAC_COMM_MESSAGE);\n\taac_adapter_disable_int(dev);\n\tsrc_writel(dev, MUnit.ODR_C, 0xffffffff);\n\taac_adapter_enable_int(dev);\n\n\tif (aac_init_adapter(dev) == NULL)\n\t\tgoto error_iounmap;\n\tif (dev->comm_interface != AAC_COMM_MESSAGE_TYPE1)\n\t\tgoto error_iounmap;\n\n\tdev->msi = !pci_enable_msi(dev->pdev);\n\n\tdev->aac_msix[0].vector_no = 0;\n\tdev->aac_msix[0].dev = dev;\n\n\tif (request_irq(dev->pdev->irq, dev->a_ops.adapter_intr,\n\t\t\tIRQF_SHARED, \"aacraid\", &(dev->aac_msix[0]))  < 0) {\n\n\t\tif (dev->msi)\n\t\t\tpci_disable_msi(dev->pdev);\n\n\t\tprintk(KERN_ERR \"%s%d: Interrupt unavailable.\\n\",\n\t\t\tname, instance);\n\t\tgoto error_iounmap;\n\t}\n\tdev->dbg_base = pci_resource_start(dev->pdev, 2);\n\tdev->dbg_base_mapped = dev->regs.src.bar1;\n\tdev->dbg_size = AAC_MIN_SRC_BAR1_SIZE;\n\tdev->a_ops.adapter_enable_int = aac_src_enable_interrupt_message;\n\n\taac_adapter_enable_int(dev);\n\n\tif (!dev->sync_mode) {\n\t\t \n\t\taac_src_start_adapter(dev);\n\t}\n\treturn 0;\n\nerror_iounmap:\n\n\treturn -1;\n}\n\nstatic int aac_src_wait_sync(struct aac_dev *dev, int *status)\n{\n\tunsigned long start = jiffies;\n\tunsigned long usecs = 0;\n\tint delay = 5 * HZ;\n\tint rc = 1;\n\n\twhile (time_before(jiffies, start+delay)) {\n\t\t \n\t\tudelay(5);\n\n\t\t \n\t\tif (aac_src_get_sync_status(dev) & OUTBOUNDDOORBELL_0) {\n\t\t\t \n\t\t\tif (dev->msi_enabled)\n\t\t\t\taac_src_access_devreg(dev, AAC_CLEAR_SYNC_BIT);\n\t\t\telse\n\t\t\t\tsrc_writel(dev, MUnit.ODR_C,\n\t\t\t\t\tOUTBOUNDDOORBELL_0 << SRC_ODR_SHIFT);\n\t\t\trc = 0;\n\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusecs = 1 * USEC_PER_MSEC;\n\t\tusleep_range(usecs, usecs + 50);\n\t}\n\t \n\tif (status && !rc) {\n\t\tstatus[0] = readl(&dev->IndexRegs->Mailbox[0]);\n\t\tstatus[1] = readl(&dev->IndexRegs->Mailbox[1]);\n\t\tstatus[2] = readl(&dev->IndexRegs->Mailbox[2]);\n\t\tstatus[3] = readl(&dev->IndexRegs->Mailbox[3]);\n\t\tstatus[4] = readl(&dev->IndexRegs->Mailbox[4]);\n\t}\n\n\treturn rc;\n}\n\n \n\nstatic int aac_src_soft_reset(struct aac_dev *dev)\n{\n\tu32 status_omr = src_readl(dev, MUnit.OMR);\n\tu32 status[5];\n\tint rc = 1;\n\tint state = 0;\n\tchar *state_str[7] = {\n\t\t\"GET_ADAPTER_PROPERTIES Failed\",\n\t\t\"GET_ADAPTER_PROPERTIES timeout\",\n\t\t\"SOFT_RESET not supported\",\n\t\t\"DROP_IO Failed\",\n\t\t\"DROP_IO timeout\",\n\t\t\"Check Health failed\"\n\t};\n\n\tif (status_omr == INVALID_OMR)\n\t\treturn 1;        \n\n\tif (!(status_omr & KERNEL_UP_AND_RUNNING))\n\t\treturn 1;        \n\n\t \n\tdev->in_soft_reset = 1;\n\tdev->msi_enabled = status_omr & AAC_INT_MODE_MSIX;\n\n\t \n\trc = aac_adapter_sync_cmd(dev, GET_ADAPTER_PROPERTIES, 0, 0, 0,\n\t\t0, 0, 0, status+0, status+1, status+2, status+3, status+4);\n\tif (rc)\n\t\tgoto out;\n\n\tstate++;\n\tif (aac_src_wait_sync(dev, status)) {\n\t\trc = 1;\n\t\tgoto out;\n\t}\n\n\tstate++;\n\tif (!(status[1] & le32_to_cpu(AAC_OPT_EXTENDED) &&\n\t\t(status[4] & le32_to_cpu(AAC_EXTOPT_SOFT_RESET)))) {\n\t\trc = 2;\n\t\tgoto out;\n\t}\n\n\tif ((status[1] & le32_to_cpu(AAC_OPT_EXTENDED)) &&\n\t\t(status[4] & le32_to_cpu(AAC_EXTOPT_SA_FIRMWARE)))\n\t\tdev->sa_firmware = 1;\n\n\tstate++;\n\trc = aac_adapter_sync_cmd(dev, DROP_IO, 0, 0, 0, 0, 0, 0,\n\t\t status+0, status+1, status+2, status+3, status+4);\n\n\tif (rc)\n\t\tgoto out;\n\n\tstate++;\n\tif (aac_src_wait_sync(dev, status)) {\n\t\trc = 3;\n\t\tgoto out;\n\t}\n\n\tif (status[1])\n\t\tdev_err(&dev->pdev->dev, \"%s: %d outstanding I/O pending\\n\",\n\t\t\t__func__, status[1]);\n\n\tstate++;\n\trc = aac_src_check_health(dev);\n\nout:\n\tdev->in_soft_reset = 0;\n\tdev->msi_enabled = 0;\n\tif (rc)\n\t\tdev_err(&dev->pdev->dev, \"%s: %s status = %d\", __func__,\n\t\t\tstate_str[state], rc);\n\n\treturn rc;\n}\n \n\nint aac_srcv_init(struct aac_dev *dev)\n{\n\tunsigned long start;\n\tunsigned long status;\n\tint restart = 0;\n\tint instance = dev->id;\n\tconst char *name = dev->name;\n\n\tdev->a_ops.adapter_ioremap = aac_srcv_ioremap;\n\tdev->a_ops.adapter_comm = aac_src_select_comm;\n\n\tdev->base_size = AAC_MIN_SRCV_BAR0_SIZE;\n\tif (aac_adapter_ioremap(dev, dev->base_size)) {\n\t\tprintk(KERN_WARNING \"%s: unable to map adapter.\\n\", name);\n\t\tgoto error_iounmap;\n\t}\n\n\t \n\tdev->a_ops.adapter_sync_cmd = src_sync_cmd;\n\tdev->a_ops.adapter_enable_int = aac_src_disable_interrupt;\n\n\tif (dev->init_reset) {\n\t\tdev->init_reset = false;\n\t\tif (aac_src_soft_reset(dev)) {\n\t\t\taac_src_restart_adapter(dev, 0, IOP_HWSOFT_RESET);\n\t\t\t++restart;\n\t\t}\n\t}\n\n\t \n\tstatus = src_readl(dev, MUnit.OMR);\n\tif (status & FLASH_UPD_PENDING) {\n\t\tstart = jiffies;\n\t\tdo {\n\t\t\tstatus = src_readl(dev, MUnit.OMR);\n\t\t\tif (time_after(jiffies, start+HZ*FWUPD_TIMEOUT)) {\n\t\t\t\tprintk(KERN_ERR \"%s%d: adapter flash update failed.\\n\",\n\t\t\t\t\tdev->name, instance);\n\t\t\t\tgoto error_iounmap;\n\t\t\t}\n\t\t} while (!(status & FLASH_UPD_SUCCESS) &&\n\t\t\t !(status & FLASH_UPD_FAILED));\n\t\t \n\t\tssleep(10);\n\t}\n\t \n\tstatus = src_readl(dev, MUnit.OMR);\n\tif (status & KERNEL_PANIC) {\n\t\tif (aac_src_restart_adapter(dev,\n\t\t\taac_src_check_health(dev), IOP_HWSOFT_RESET))\n\t\t\tgoto error_iounmap;\n\t\t++restart;\n\t}\n\t \n\tstatus = src_readl(dev, MUnit.OMR);\n\tif (status & SELF_TEST_FAILED) {\n\t\tprintk(KERN_ERR \"%s%d: adapter self-test failed.\\n\", dev->name, instance);\n\t\tgoto error_iounmap;\n\t}\n\t \n\tif (status & MONITOR_PANIC) {\n\t\tprintk(KERN_ERR \"%s%d: adapter monitor panic.\\n\", dev->name, instance);\n\t\tgoto error_iounmap;\n\t}\n\n\tstart = jiffies;\n\t \n\tdo {\n\t\tstatus = src_readl(dev, MUnit.OMR);\n\t\tif (status == INVALID_OMR)\n\t\t\tstatus = 0;\n\n\t\tif ((restart &&\n\t\t  (status & (KERNEL_PANIC|SELF_TEST_FAILED|MONITOR_PANIC))) ||\n\t\t  time_after(jiffies, start+HZ*startup_timeout)) {\n\t\t\tprintk(KERN_ERR \"%s%d: adapter kernel failed to start, init status = %lx.\\n\",\n\t\t\t\t\tdev->name, instance, status);\n\t\t\tgoto error_iounmap;\n\t\t}\n\t\tif (!restart &&\n\t\t  ((status & (KERNEL_PANIC|SELF_TEST_FAILED|MONITOR_PANIC)) ||\n\t\t  time_after(jiffies, start + HZ *\n\t\t  ((startup_timeout > 60)\n\t\t    ? (startup_timeout - 60)\n\t\t    : (startup_timeout / 2))))) {\n\t\t\tif (likely(!aac_src_restart_adapter(dev,\n\t\t\t\taac_src_check_health(dev), IOP_HWSOFT_RESET)))\n\t\t\t\tstart = jiffies;\n\t\t\t++restart;\n\t\t}\n\t\tmsleep(1);\n\t} while (!(status & KERNEL_UP_AND_RUNNING));\n\n\tif (restart && aac_commit)\n\t\taac_commit = 1;\n\t \n\tdev->a_ops.adapter_interrupt = aac_src_interrupt_adapter;\n\tdev->a_ops.adapter_disable_int = aac_src_disable_interrupt;\n\tdev->a_ops.adapter_enable_int = aac_src_disable_interrupt;\n\tdev->a_ops.adapter_notify = aac_src_notify_adapter;\n\tdev->a_ops.adapter_sync_cmd = src_sync_cmd;\n\tdev->a_ops.adapter_check_health = aac_src_check_health;\n\tdev->a_ops.adapter_restart = aac_src_restart_adapter;\n\tdev->a_ops.adapter_start = aac_src_start_adapter;\n\n\t \n\taac_adapter_comm(dev, AAC_COMM_MESSAGE);\n\taac_adapter_disable_int(dev);\n\tsrc_writel(dev, MUnit.ODR_C, 0xffffffff);\n\taac_adapter_enable_int(dev);\n\n\tif (aac_init_adapter(dev) == NULL)\n\t\tgoto error_iounmap;\n\tif ((dev->comm_interface != AAC_COMM_MESSAGE_TYPE2) &&\n\t\t(dev->comm_interface != AAC_COMM_MESSAGE_TYPE3))\n\t\tgoto error_iounmap;\n\tif (dev->msi_enabled)\n\t\taac_src_access_devreg(dev, AAC_ENABLE_MSIX);\n\n\tif (aac_acquire_irq(dev))\n\t\tgoto error_iounmap;\n\n\tdev->dbg_base = pci_resource_start(dev->pdev, 2);\n\tdev->dbg_base_mapped = dev->regs.src.bar1;\n\tdev->dbg_size = AAC_MIN_SRCV_BAR1_SIZE;\n\tdev->a_ops.adapter_enable_int = aac_src_enable_interrupt_message;\n\n\taac_adapter_enable_int(dev);\n\n\tif (!dev->sync_mode) {\n\t\t \n\t\taac_src_start_adapter(dev);\n\t}\n\treturn 0;\n\nerror_iounmap:\n\n\treturn -1;\n}\n\nvoid aac_src_access_devreg(struct aac_dev *dev, int mode)\n{\n\tu_int32_t val;\n\n\tswitch (mode) {\n\tcase AAC_ENABLE_INTERRUPT:\n\t\tsrc_writel(dev,\n\t\t\t   MUnit.OIMR,\n\t\t\t   dev->OIMR = (dev->msi_enabled ?\n\t\t\t\t\tAAC_INT_ENABLE_TYPE1_MSIX :\n\t\t\t\t\tAAC_INT_ENABLE_TYPE1_INTX));\n\t\tbreak;\n\n\tcase AAC_DISABLE_INTERRUPT:\n\t\tsrc_writel(dev,\n\t\t\t   MUnit.OIMR,\n\t\t\t   dev->OIMR = AAC_INT_DISABLE_ALL);\n\t\tbreak;\n\n\tcase AAC_ENABLE_MSIX:\n\t\t \n\t\tval = src_readl(dev, MUnit.IDR);\n\t\tval |= 0x40;\n\t\tsrc_writel(dev,  MUnit.IDR, val);\n\t\tsrc_readl(dev, MUnit.IDR);\n\t\t \n\t\tval = PMC_ALL_INTERRUPT_BITS;\n\t\tsrc_writel(dev, MUnit.IOAR, val);\n\t\tval = src_readl(dev, MUnit.OIMR);\n\t\tsrc_writel(dev,\n\t\t\t   MUnit.OIMR,\n\t\t\t   val & (~(PMC_GLOBAL_INT_BIT2 | PMC_GLOBAL_INT_BIT0)));\n\t\tbreak;\n\n\tcase AAC_DISABLE_MSIX:\n\t\t \n\t\tval = src_readl(dev, MUnit.IDR);\n\t\tval &= ~0x40;\n\t\tsrc_writel(dev, MUnit.IDR, val);\n\t\tsrc_readl(dev, MUnit.IDR);\n\t\tbreak;\n\n\tcase AAC_CLEAR_AIF_BIT:\n\t\t \n\t\tval = src_readl(dev, MUnit.IDR);\n\t\tval |= 0x20;\n\t\tsrc_writel(dev, MUnit.IDR, val);\n\t\tsrc_readl(dev, MUnit.IDR);\n\t\tbreak;\n\n\tcase AAC_CLEAR_SYNC_BIT:\n\t\t \n\t\tval = src_readl(dev, MUnit.IDR);\n\t\tval |= 0x10;\n\t\tsrc_writel(dev, MUnit.IDR, val);\n\t\tsrc_readl(dev, MUnit.IDR);\n\t\tbreak;\n\n\tcase AAC_ENABLE_INTX:\n\t\t \n\t\tval = src_readl(dev, MUnit.IDR);\n\t\tval |= 0x80;\n\t\tsrc_writel(dev, MUnit.IDR, val);\n\t\tsrc_readl(dev, MUnit.IDR);\n\t\t \n\t\tval = PMC_ALL_INTERRUPT_BITS;\n\t\tsrc_writel(dev, MUnit.IOAR, val);\n\t\tsrc_readl(dev, MUnit.IOAR);\n\t\tval = src_readl(dev, MUnit.OIMR);\n\t\tsrc_writel(dev, MUnit.OIMR,\n\t\t\t\tval & (~(PMC_GLOBAL_INT_BIT2)));\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int aac_src_get_sync_status(struct aac_dev *dev)\n{\n\tint msix_val = 0;\n\tint legacy_val = 0;\n\n\tmsix_val = src_readl(dev, MUnit.ODR_MSI) & SRC_MSI_READ_MASK ? 1 : 0;\n\n\tif (!dev->msi_enabled) {\n\t\t \n\t\tlegacy_val = src_readl(dev, MUnit.ODR_R) >> SRC_ODR_SHIFT;\n\t\tif (!(legacy_val & 1) && msix_val)\n\t\t\tdev->msi_enabled = 1;\n\t\treturn legacy_val;\n\t}\n\n\treturn msix_val;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}