{
  "module_name": "comminit.c",
  "hash_id": "00e83d5186e69c3a948944c06d659a6663f02d5d2726e2a6b7f6a09db89eecaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/aacraid/comminit.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/mm.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"aacraid.h\"\n\nstruct aac_common aac_config = {\n\t.irq_mod = 1\n};\n\nstatic inline int aac_is_msix_mode(struct aac_dev *dev)\n{\n\tu32 status = 0;\n\n\tif (aac_is_src(dev))\n\t\tstatus = src_readl(dev, MUnit.OMR);\n\treturn (status & AAC_INT_MODE_MSIX);\n}\n\nstatic inline void aac_change_to_intx(struct aac_dev *dev)\n{\n\taac_src_access_devreg(dev, AAC_DISABLE_MSIX);\n\taac_src_access_devreg(dev, AAC_ENABLE_INTX);\n}\n\nstatic int aac_alloc_comm(struct aac_dev *dev, void **commaddr, unsigned long commsize, unsigned long commalign)\n{\n\tunsigned char *base;\n\tunsigned long size, align;\n\tconst unsigned long fibsize = dev->max_fib_size;\n\tconst unsigned long printfbufsiz = 256;\n\tunsigned long host_rrq_size, aac_init_size;\n\tunion aac_init *init;\n\tdma_addr_t phys;\n\tunsigned long aac_max_hostphysmempages;\n\n\tif ((dev->comm_interface == AAC_COMM_MESSAGE_TYPE1) ||\n\t\t(dev->comm_interface == AAC_COMM_MESSAGE_TYPE2) ||\n\t\t(dev->comm_interface == AAC_COMM_MESSAGE_TYPE3 &&\n\t\t!dev->sa_firmware)) {\n\t\thost_rrq_size =\n\t\t\t(dev->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB)\n\t\t\t\t* sizeof(u32);\n\t\taac_init_size = sizeof(union aac_init);\n\t} else if (dev->comm_interface == AAC_COMM_MESSAGE_TYPE3 &&\n\t\tdev->sa_firmware) {\n\t\thost_rrq_size = (dev->scsi_host_ptr->can_queue\n\t\t\t+ AAC_NUM_MGT_FIB) * sizeof(u32)  * AAC_MAX_MSIX;\n\t\taac_init_size = sizeof(union aac_init) +\n\t\t\t(AAC_MAX_HRRQ - 1) * sizeof(struct _rrq);\n\t} else {\n\t\thost_rrq_size = 0;\n\t\taac_init_size = sizeof(union aac_init);\n\t}\n\tsize = fibsize + aac_init_size + commsize + commalign +\n\t\t\tprintfbufsiz + host_rrq_size;\n\n\tbase = dma_alloc_coherent(&dev->pdev->dev, size, &phys, GFP_KERNEL);\n\tif (base == NULL) {\n\t\tprintk(KERN_ERR \"aacraid: unable to create mapping.\\n\");\n\t\treturn 0;\n\t}\n\n\tdev->comm_addr = (void *)base;\n\tdev->comm_phys = phys;\n\tdev->comm_size = size;\n\n\tif ((dev->comm_interface == AAC_COMM_MESSAGE_TYPE1) ||\n\t    (dev->comm_interface == AAC_COMM_MESSAGE_TYPE2) ||\n\t    (dev->comm_interface == AAC_COMM_MESSAGE_TYPE3)) {\n\t\tdev->host_rrq = (u32 *)(base + fibsize);\n\t\tdev->host_rrq_pa = phys + fibsize;\n\t\tmemset(dev->host_rrq, 0, host_rrq_size);\n\t}\n\n\tdev->init = (union aac_init *)(base + fibsize + host_rrq_size);\n\tdev->init_pa = phys + fibsize + host_rrq_size;\n\n\tinit = dev->init;\n\n\tif (dev->comm_interface == AAC_COMM_MESSAGE_TYPE3) {\n\t\tint i;\n\t\tu64 addr;\n\n\t\tinit->r8.init_struct_revision =\n\t\t\tcpu_to_le32(ADAPTER_INIT_STRUCT_REVISION_8);\n\t\tinit->r8.init_flags = cpu_to_le32(INITFLAGS_NEW_COMM_SUPPORTED |\n\t\t\t\t\tINITFLAGS_DRIVER_USES_UTC_TIME |\n\t\t\t\t\tINITFLAGS_DRIVER_SUPPORTS_PM);\n\t\tinit->r8.init_flags |=\n\t\t\t\tcpu_to_le32(INITFLAGS_DRIVER_SUPPORTS_HBA_MODE);\n\t\tinit->r8.rr_queue_count = cpu_to_le32(dev->max_msix);\n\t\tinit->r8.max_io_size =\n\t\t\tcpu_to_le32(dev->scsi_host_ptr->max_sectors << 9);\n\t\tinit->r8.max_num_aif = init->r8.reserved1 =\n\t\t\tinit->r8.reserved2 = 0;\n\n\t\tfor (i = 0; i < dev->max_msix; i++) {\n\t\t\taddr = (u64)dev->host_rrq_pa + dev->vector_cap * i *\n\t\t\t\t\tsizeof(u32);\n\t\t\tinit->r8.rrq[i].host_addr_high = cpu_to_le32(\n\t\t\t\t\t\tupper_32_bits(addr));\n\t\t\tinit->r8.rrq[i].host_addr_low = cpu_to_le32(\n\t\t\t\t\t\tlower_32_bits(addr));\n\t\t\tinit->r8.rrq[i].msix_id = i;\n\t\t\tinit->r8.rrq[i].element_count = cpu_to_le16(\n\t\t\t\t\t(u16)dev->vector_cap);\n\t\t\tinit->r8.rrq[i].comp_thresh =\n\t\t\t\t\tinit->r8.rrq[i].unused = 0;\n\t\t}\n\n\t\tpr_warn(\"aacraid: Comm Interface type3 enabled\\n\");\n\t} else {\n\t\tinit->r7.init_struct_revision =\n\t\t\tcpu_to_le32(ADAPTER_INIT_STRUCT_REVISION);\n\t\tif (dev->max_fib_size != sizeof(struct hw_fib))\n\t\t\tinit->r7.init_struct_revision =\n\t\t\t\tcpu_to_le32(ADAPTER_INIT_STRUCT_REVISION_4);\n\t\tinit->r7.no_of_msix_vectors = cpu_to_le32(SA_MINIPORT_REVISION);\n\t\tinit->r7.fsrev = cpu_to_le32(dev->fsrev);\n\n\t\t \n\t\tdev->aif_base_va = (struct hw_fib *)base;\n\n\t\tinit->r7.adapter_fibs_virtual_address = 0;\n\t\tinit->r7.adapter_fibs_physical_address = cpu_to_le32((u32)phys);\n\t\tinit->r7.adapter_fibs_size = cpu_to_le32(fibsize);\n\t\tinit->r7.adapter_fib_align = cpu_to_le32(sizeof(struct hw_fib));\n\n\t\t \n\t\taac_max_hostphysmempages =\n\t\t\t\tdma_get_required_mask(&dev->pdev->dev) >> 12;\n\t\tif (aac_max_hostphysmempages < AAC_MAX_HOSTPHYSMEMPAGES)\n\t\t\tinit->r7.host_phys_mem_pages =\n\t\t\t\t\tcpu_to_le32(aac_max_hostphysmempages);\n\t\telse\n\t\t\tinit->r7.host_phys_mem_pages =\n\t\t\t\t\tcpu_to_le32(AAC_MAX_HOSTPHYSMEMPAGES);\n\n\t\tinit->r7.init_flags =\n\t\t\tcpu_to_le32(INITFLAGS_DRIVER_USES_UTC_TIME |\n\t\t\tINITFLAGS_DRIVER_SUPPORTS_PM);\n\t\tinit->r7.max_io_commands =\n\t\t\tcpu_to_le32(dev->scsi_host_ptr->can_queue +\n\t\t\t\t\tAAC_NUM_MGT_FIB);\n\t\tinit->r7.max_io_size =\n\t\t\tcpu_to_le32(dev->scsi_host_ptr->max_sectors << 9);\n\t\tinit->r7.max_fib_size = cpu_to_le32(dev->max_fib_size);\n\t\tinit->r7.max_num_aif = cpu_to_le32(dev->max_num_aif);\n\n\t\tif (dev->comm_interface == AAC_COMM_MESSAGE) {\n\t\t\tinit->r7.init_flags |=\n\t\t\t\tcpu_to_le32(INITFLAGS_NEW_COMM_SUPPORTED);\n\t\t\tpr_warn(\"aacraid: Comm Interface enabled\\n\");\n\t\t} else if (dev->comm_interface == AAC_COMM_MESSAGE_TYPE1) {\n\t\t\tinit->r7.init_struct_revision =\n\t\t\t\tcpu_to_le32(ADAPTER_INIT_STRUCT_REVISION_6);\n\t\t\tinit->r7.init_flags |=\n\t\t\t\tcpu_to_le32(INITFLAGS_NEW_COMM_SUPPORTED |\n\t\t\t\tINITFLAGS_NEW_COMM_TYPE1_SUPPORTED |\n\t\t\t\tINITFLAGS_FAST_JBOD_SUPPORTED);\n\t\t\tinit->r7.host_rrq_addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(dev->host_rrq_pa));\n\t\t\tinit->r7.host_rrq_addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(dev->host_rrq_pa));\n\t\t\tpr_warn(\"aacraid: Comm Interface type1 enabled\\n\");\n\t\t} else if (dev->comm_interface == AAC_COMM_MESSAGE_TYPE2) {\n\t\t\tinit->r7.init_struct_revision =\n\t\t\t\tcpu_to_le32(ADAPTER_INIT_STRUCT_REVISION_7);\n\t\t\tinit->r7.init_flags |=\n\t\t\t\tcpu_to_le32(INITFLAGS_NEW_COMM_SUPPORTED |\n\t\t\t\tINITFLAGS_NEW_COMM_TYPE2_SUPPORTED |\n\t\t\t\tINITFLAGS_FAST_JBOD_SUPPORTED);\n\t\t\tinit->r7.host_rrq_addr_high =\n\t\t\t\tcpu_to_le32(upper_32_bits(dev->host_rrq_pa));\n\t\t\tinit->r7.host_rrq_addr_low =\n\t\t\t\tcpu_to_le32(lower_32_bits(dev->host_rrq_pa));\n\t\t\tinit->r7.no_of_msix_vectors =\n\t\t\t\tcpu_to_le32(dev->max_msix);\n\t\t\t \n\t\t\tpr_warn(\"aacraid: Comm Interface type2 enabled\\n\");\n\t\t}\n\t}\n\n\t \n\tbase = base + fibsize + host_rrq_size + aac_init_size;\n\tphys = (dma_addr_t)((ulong)phys + fibsize + host_rrq_size +\n\t\t\taac_init_size);\n\n\t \n\talign = (commalign - ((uintptr_t)(base) & (commalign - 1)));\n\tbase = base + align;\n\tphys = phys + align;\n\t \n\t*commaddr = base;\n\tif (dev->comm_interface != AAC_COMM_MESSAGE_TYPE3)\n\t\tinit->r7.comm_header_address = cpu_to_le32((u32)phys);\n\t \n\tbase = base + commsize;\n\tphys = phys + commsize;\n\t \n\tdev->printfbuf = (void *)base;\n\tif (dev->comm_interface != AAC_COMM_MESSAGE_TYPE3) {\n\t\tinit->r7.printfbuf = cpu_to_le32(phys);\n\t\tinit->r7.printfbufsiz = cpu_to_le32(printfbufsiz);\n\t}\n\tmemset(base, 0, printfbufsiz);\n\treturn 1;\n}\n\nstatic void aac_queue_init(struct aac_dev * dev, struct aac_queue * q, u32 *mem, int qsize)\n{\n\tatomic_set(&q->numpending, 0);\n\tq->dev = dev;\n\tinit_waitqueue_head(&q->cmdready);\n\tINIT_LIST_HEAD(&q->cmdq);\n\tinit_waitqueue_head(&q->qfull);\n\tspin_lock_init(&q->lockdata);\n\tq->lock = &q->lockdata;\n\tq->headers.producer = (__le32 *)mem;\n\tq->headers.consumer = (__le32 *)(mem+1);\n\t*(q->headers.producer) = cpu_to_le32(qsize);\n\t*(q->headers.consumer) = cpu_to_le32(qsize);\n\tq->entries = qsize;\n}\n\nstatic bool wait_for_io_iter(struct scsi_cmnd *cmd, void *data)\n{\n\tint *active = data;\n\n\tif (aac_priv(cmd)->owner == AAC_OWNER_FIRMWARE)\n\t\t*active = *active + 1;\n\treturn true;\n}\nstatic void aac_wait_for_io_completion(struct aac_dev *aac)\n{\n\tint i = 0, active;\n\n\tfor (i = 60; i; --i) {\n\n\t\tactive = 0;\n\t\tscsi_host_busy_iter(aac->scsi_host_ptr,\n\t\t\t\t    wait_for_io_iter, &active);\n\t\t \n\t\tif (active == 0)\n\t\t\tbreak;\n\t\tdev_info(&aac->pdev->dev,\n\t\t\t \"Wait for %d commands to complete\\n\", active);\n\t\tssleep(1);\n\t}\n\tif (active)\n\t\tdev_err(&aac->pdev->dev,\n\t\t\t\"%d outstanding commands during shutdown\\n\", active);\n}\n\n \n\nint aac_send_shutdown(struct aac_dev * dev)\n{\n\tstruct fib * fibctx;\n\tstruct aac_close *cmd;\n\tint status = 0;\n\n\tif (aac_adapter_check_health(dev))\n\t\treturn status;\n\n\tif (!dev->adapter_shutdown) {\n\t\tmutex_lock(&dev->ioctl_mutex);\n\t\tdev->adapter_shutdown = 1;\n\t\tmutex_unlock(&dev->ioctl_mutex);\n\t}\n\n\taac_wait_for_io_completion(dev);\n\n\tfibctx = aac_fib_alloc(dev);\n\tif (!fibctx)\n\t\treturn -ENOMEM;\n\taac_fib_init(fibctx);\n\n\tcmd = (struct aac_close *) fib_data(fibctx);\n\tcmd->command = cpu_to_le32(VM_CloseAll);\n\tcmd->cid = cpu_to_le32(0xfffffffe);\n\n\tstatus = aac_fib_send(ContainerCommand,\n\t\t\t  fibctx,\n\t\t\t  sizeof(struct aac_close),\n\t\t\t  FsaNormal,\n\t\t\t  -2  , 1,\n\t\t\t  NULL, NULL);\n\n\tif (status >= 0)\n\t\taac_fib_complete(fibctx);\n\t \n\tif (status != -ERESTARTSYS)\n\t\taac_fib_free(fibctx);\n\tif (aac_is_src(dev) &&\n\t     dev->msi_enabled)\n\t\taac_set_intx_mode(dev);\n\treturn status;\n}\n\n \n \nstatic int aac_comm_init(struct aac_dev * dev)\n{\n\tunsigned long hdrsize = (sizeof(u32) * NUMBER_OF_COMM_QUEUES) * 2;\n\tunsigned long queuesize = sizeof(struct aac_entry) * TOTAL_QUEUE_ENTRIES;\n\tu32 *headers;\n\tstruct aac_entry * queues;\n\tunsigned long size;\n\tstruct aac_queue_block * comm = dev->queues;\n\t \n\tspin_lock_init(&dev->fib_lock);\n\n\t \n\n\tsize = hdrsize + queuesize;\n\n\tif (!aac_alloc_comm(dev, (void * *)&headers, size, QUEUE_ALIGNMENT))\n\t\treturn -ENOMEM;\n\n\tqueues = (struct aac_entry *)(((ulong)headers) + hdrsize);\n\n\t  \n\tcomm->queue[HostNormCmdQueue].base = queues;\n\taac_queue_init(dev, &comm->queue[HostNormCmdQueue], headers, HOST_NORM_CMD_ENTRIES);\n\tqueues += HOST_NORM_CMD_ENTRIES;\n\theaders += 2;\n\n\t \n\tcomm->queue[HostHighCmdQueue].base = queues;\n\taac_queue_init(dev, &comm->queue[HostHighCmdQueue], headers, HOST_HIGH_CMD_ENTRIES);\n    \n\tqueues += HOST_HIGH_CMD_ENTRIES;\n\theaders +=2;\n\n\t \n\tcomm->queue[AdapNormCmdQueue].base = queues;\n\taac_queue_init(dev, &comm->queue[AdapNormCmdQueue], headers, ADAP_NORM_CMD_ENTRIES);\n    \n\tqueues += ADAP_NORM_CMD_ENTRIES;\n\theaders += 2;\n\n\t \n\tcomm->queue[AdapHighCmdQueue].base = queues;\n\taac_queue_init(dev, &comm->queue[AdapHighCmdQueue], headers, ADAP_HIGH_CMD_ENTRIES);\n    \n\tqueues += ADAP_HIGH_CMD_ENTRIES;\n\theaders += 2;\n\n\t \n\tcomm->queue[HostNormRespQueue].base = queues;\n\taac_queue_init(dev, &comm->queue[HostNormRespQueue], headers, HOST_NORM_RESP_ENTRIES);\n\tqueues += HOST_NORM_RESP_ENTRIES;\n\theaders += 2;\n\n\t \n\tcomm->queue[HostHighRespQueue].base = queues;\n\taac_queue_init(dev, &comm->queue[HostHighRespQueue], headers, HOST_HIGH_RESP_ENTRIES);\n   \n\tqueues += HOST_HIGH_RESP_ENTRIES;\n\theaders += 2;\n\n\t \n\tcomm->queue[AdapNormRespQueue].base = queues;\n\taac_queue_init(dev, &comm->queue[AdapNormRespQueue], headers, ADAP_NORM_RESP_ENTRIES);\n\n\tqueues += ADAP_NORM_RESP_ENTRIES;\n\theaders += 2;\n\t\n\t  \n\tcomm->queue[AdapHighRespQueue].base = queues;\n\taac_queue_init(dev, &comm->queue[AdapHighRespQueue], headers, ADAP_HIGH_RESP_ENTRIES);\n\n\tcomm->queue[AdapNormCmdQueue].lock = comm->queue[HostNormRespQueue].lock;\n\tcomm->queue[AdapHighCmdQueue].lock = comm->queue[HostHighRespQueue].lock;\n\tcomm->queue[AdapNormRespQueue].lock = comm->queue[HostNormCmdQueue].lock;\n\tcomm->queue[AdapHighRespQueue].lock = comm->queue[HostHighCmdQueue].lock;\n\n\treturn 0;\n}\n\nvoid aac_define_int_mode(struct aac_dev *dev)\n{\n\tint i, msi_count, min_msix;\n\n\tmsi_count = i = 0;\n\t \n\tif (dev->max_msix == 0 ||\n\t    dev->pdev->device == PMC_DEVICE_S6 ||\n\t    dev->sync_mode) {\n\t\tdev->max_msix = 1;\n\t\tdev->vector_cap =\n\t\t\tdev->scsi_host_ptr->can_queue +\n\t\t\tAAC_NUM_MGT_FIB;\n\t\treturn;\n\t}\n\n\t \n\tmsi_count = min(dev->max_msix,\n\t\t(unsigned int)num_online_cpus());\n\n\tdev->max_msix = msi_count;\n\n\tif (msi_count > AAC_MAX_MSIX)\n\t\tmsi_count = AAC_MAX_MSIX;\n\n\tif (msi_count > 1 &&\n\t    pci_find_capability(dev->pdev, PCI_CAP_ID_MSIX)) {\n\t\tmin_msix = 2;\n\t\ti = pci_alloc_irq_vectors(dev->pdev,\n\t\t\t\t\t  min_msix, msi_count,\n\t\t\t\t\t  PCI_IRQ_MSIX | PCI_IRQ_AFFINITY);\n\t\tif (i > 0) {\n\t\t\tdev->msi_enabled = 1;\n\t\t\tmsi_count = i;\n\t\t} else {\n\t\t\tdev->msi_enabled = 0;\n\t\t\tdev_err(&dev->pdev->dev,\n\t\t\t\"MSIX not supported!! Will try INTX 0x%x.\\n\", i);\n\t\t}\n\t}\n\n\tif (!dev->msi_enabled)\n\t\tdev->max_msix = msi_count = 1;\n\telse {\n\t\tif (dev->max_msix > msi_count)\n\t\t\tdev->max_msix = msi_count;\n\t}\n\tif (dev->comm_interface == AAC_COMM_MESSAGE_TYPE3 && dev->sa_firmware)\n\t\tdev->vector_cap = dev->scsi_host_ptr->can_queue +\n\t\t\t\tAAC_NUM_MGT_FIB;\n\telse\n\t\tdev->vector_cap = (dev->scsi_host_ptr->can_queue +\n\t\t\t\tAAC_NUM_MGT_FIB) / msi_count;\n\n}\nstruct aac_dev *aac_init_adapter(struct aac_dev *dev)\n{\n\tu32 status[5];\n\tstruct Scsi_Host * host = dev->scsi_host_ptr;\n\textern int aac_sync_mode;\n\n\t \n\tdev->management_fib_count = 0;\n\tspin_lock_init(&dev->manage_lock);\n\tspin_lock_init(&dev->sync_lock);\n\tspin_lock_init(&dev->iq_lock);\n\tdev->max_fib_size = sizeof(struct hw_fib);\n\tdev->sg_tablesize = host->sg_tablesize = (dev->max_fib_size\n\t\t- sizeof(struct aac_fibhdr)\n\t\t- sizeof(struct aac_write) + sizeof(struct sgentry))\n\t\t\t/ sizeof(struct sgentry);\n\tdev->comm_interface = AAC_COMM_PRODUCER;\n\tdev->raw_io_interface = dev->raw_io_64 = 0;\n\n\n\t \n\tif (aac_is_msix_mode(dev)) {\n\t\taac_change_to_intx(dev);\n\t\tdev_info(&dev->pdev->dev, \"Changed firmware to INTX mode\");\n\t}\n\n\tif ((!aac_adapter_sync_cmd(dev, GET_ADAPTER_PROPERTIES,\n\t\t0, 0, 0, 0, 0, 0,\n\t\tstatus+0, status+1, status+2, status+3, status+4)) &&\n\t\t(status[0] == 0x00000001)) {\n\t\tdev->doorbell_mask = status[3];\n\t\tif (status[1] & AAC_OPT_NEW_COMM_64)\n\t\t\tdev->raw_io_64 = 1;\n\t\tdev->sync_mode = aac_sync_mode;\n\t\tif (dev->a_ops.adapter_comm &&\n\t\t    (status[1] & AAC_OPT_NEW_COMM)) {\n\t\t\tdev->comm_interface = AAC_COMM_MESSAGE;\n\t\t\tdev->raw_io_interface = 1;\n\t\t\tif ((status[1] & AAC_OPT_NEW_COMM_TYPE1)) {\n\t\t\t\t \n\t\t\t\tdev->comm_interface = AAC_COMM_MESSAGE_TYPE1;\n\t\t\t} else if (status[1] & AAC_OPT_NEW_COMM_TYPE2) {\n\t\t\t\t \n\t\t\t\tdev->comm_interface = AAC_COMM_MESSAGE_TYPE2;\n\t\t\t} else if (status[1] & AAC_OPT_NEW_COMM_TYPE3) {\n\t\t\t\t \n\t\t\t\tdev->comm_interface = AAC_COMM_MESSAGE_TYPE3;\n\t\t\t} else if (status[1] & AAC_OPT_NEW_COMM_TYPE4) {\n\t\t\t\t \n\t\t\t\tdev->comm_interface = AAC_COMM_MESSAGE_TYPE2;\n\t\t\t\tdev->sync_mode = 1;\n\t\t\t}\n\t\t}\n\t\tif ((status[1] & le32_to_cpu(AAC_OPT_EXTENDED)) &&\n\t\t\t(status[4] & le32_to_cpu(AAC_EXTOPT_SA_FIRMWARE)))\n\t\t\tdev->sa_firmware = 1;\n\t\telse\n\t\t\tdev->sa_firmware = 0;\n\n\t\tif (status[4] & le32_to_cpu(AAC_EXTOPT_SOFT_RESET))\n\t\t\tdev->soft_reset_support = 1;\n\t\telse\n\t\t\tdev->soft_reset_support = 0;\n\n\t\tif ((dev->comm_interface == AAC_COMM_MESSAGE) &&\n\t\t    (status[2] > dev->base_size)) {\n\t\t\taac_adapter_ioremap(dev, 0);\n\t\t\tdev->base_size = status[2];\n\t\t\tif (aac_adapter_ioremap(dev, status[2])) {\n\t\t\t\t \n\t\t\t\tdev->comm_interface = AAC_COMM_PRODUCER;\n\t\t\t\tif (aac_adapter_ioremap(dev, AAC_MIN_FOOTPRINT_SIZE)) {\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t  \"aacraid: unable to map adapter.\\n\");\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdev->max_msix = 0;\n\tdev->msi_enabled = 0;\n\tdev->adapter_shutdown = 0;\n\tif ((!aac_adapter_sync_cmd(dev, GET_COMM_PREFERRED_SETTINGS,\n\t  0, 0, 0, 0, 0, 0,\n\t  status+0, status+1, status+2, status+3, status+4))\n\t && (status[0] == 0x00000001)) {\n\t\t \n\t\thost->max_sectors = (status[1] >> 16) << 1;\n\t\t \n\t\tdev->max_fib_size = status[1] & 0xFFE0;\n\t\thost->sg_tablesize = status[2] >> 16;\n\t\tdev->sg_tablesize = status[2] & 0xFFFF;\n\t\tif (aac_is_src(dev)) {\n\t\t\tif (host->can_queue > (status[3] >> 16) -\n\t\t\t\t\tAAC_NUM_MGT_FIB)\n\t\t\t\thost->can_queue = (status[3] >> 16) -\n\t\t\t\t\tAAC_NUM_MGT_FIB;\n\t\t} else if (host->can_queue > (status[3] & 0xFFFF) -\n\t\t\t\tAAC_NUM_MGT_FIB)\n\t\t\thost->can_queue = (status[3] & 0xFFFF) -\n\t\t\t\tAAC_NUM_MGT_FIB;\n\n\t\tdev->max_num_aif = status[4] & 0xFFFF;\n\t}\n\tif (numacb > 0) {\n\t\tif (numacb < host->can_queue)\n\t\t\thost->can_queue = numacb;\n\t\telse\n\t\t\tpr_warn(\"numacb=%d ignored\\n\", numacb);\n\t}\n\n\tif (aac_is_src(dev))\n\t\taac_define_int_mode(dev);\n\t \n\n\tdev->queues = kzalloc(sizeof(struct aac_queue_block), GFP_KERNEL);\n\tif (dev->queues == NULL) {\n\t\tprintk(KERN_ERR \"Error could not allocate comm region.\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (aac_comm_init(dev)<0){\n\t\tkfree(dev->queues);\n\t\treturn NULL;\n\t}\n\t \n\tif (aac_fib_setup(dev) < 0) {\n\t\tkfree(dev->queues);\n\t\treturn NULL;\n\t}\n\t\t\n\tINIT_LIST_HEAD(&dev->fib_list);\n\tINIT_LIST_HEAD(&dev->sync_fib_list);\n\n\treturn dev;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}