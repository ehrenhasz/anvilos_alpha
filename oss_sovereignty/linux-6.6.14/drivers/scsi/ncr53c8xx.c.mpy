{
  "module_name": "ncr53c8xx.c",
  "hash_id": "a8a4790585ec4d0ebe48b8019ee707ff60307774b90e8211544feea4eda66fe3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/ncr53c8xx.c",
  "human_readable_source": "\n \n\n \n\n \n#define SCSI_NCR_DRIVER_NAME\t\"ncr53c8xx-3.4.3g\"\n\n#define SCSI_NCR_DEBUG_FLAGS\t(0)\n\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n\n#include <asm/dma.h>\n#include <asm/io.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_transport_spi.h>\n\n#include \"ncr53c8xx.h\"\n\n#define NAME53C8XX\t\t\"ncr53c8xx\"\n\n \n\n#define DEBUG_ALLOC    (0x0001)\n#define DEBUG_PHASE    (0x0002)\n#define DEBUG_QUEUE    (0x0008)\n#define DEBUG_RESULT   (0x0010)\n#define DEBUG_POINTER  (0x0020)\n#define DEBUG_SCRIPT   (0x0040)\n#define DEBUG_TINY     (0x0080)\n#define DEBUG_TIMING   (0x0100)\n#define DEBUG_NEGO     (0x0200)\n#define DEBUG_TAGS     (0x0400)\n#define DEBUG_SCATTER  (0x0800)\n#define DEBUG_IC        (0x1000)\n\n \n\n#ifdef SCSI_NCR_DEBUG_INFO_SUPPORT\nstatic int ncr_debug = SCSI_NCR_DEBUG_FLAGS;\n\t#define DEBUG_FLAGS ncr_debug\n#else\n\t#define DEBUG_FLAGS\tSCSI_NCR_DEBUG_FLAGS\n#endif\n\n \n#define SAM_STAT_ILLEGAL\t0xff\n\nstatic inline struct list_head *ncr_list_pop(struct list_head *head)\n{\n\tif (!list_empty(head)) {\n\t\tstruct list_head *elem = head->next;\n\n\t\tlist_del(elem);\n\t\treturn elem;\n\t}\n\n\treturn NULL;\n}\n\n \n\n#define MEMO_SHIFT\t4\t \n#if PAGE_SIZE >= 8192\n#define MEMO_PAGE_ORDER\t0\t \n#else\n#define MEMO_PAGE_ORDER\t1\t \n#endif\n#define MEMO_FREE_UNUSED\t \n#define MEMO_WARN\t1\n#define MEMO_GFP_FLAGS\tGFP_ATOMIC\n#define MEMO_CLUSTER_SHIFT\t(PAGE_SHIFT+MEMO_PAGE_ORDER)\n#define MEMO_CLUSTER_SIZE\t(1UL << MEMO_CLUSTER_SHIFT)\n#define MEMO_CLUSTER_MASK\t(MEMO_CLUSTER_SIZE-1)\n\ntypedef u_long m_addr_t;\t \ntypedef struct device *m_bush_t;\t \n\ntypedef struct m_link {\t\t \n\tstruct m_link *next;\n} m_link_s;\n\ntypedef struct m_vtob {\t\t \n\tstruct m_vtob *next;\n\tm_addr_t vaddr;\n\tm_addr_t baddr;\n} m_vtob_s;\n#define VTOB_HASH_SHIFT\t\t5\n#define VTOB_HASH_SIZE\t\t(1UL << VTOB_HASH_SHIFT)\n#define VTOB_HASH_MASK\t\t(VTOB_HASH_SIZE-1)\n#define VTOB_HASH_CODE(m)\t\\\n\t((((m_addr_t) (m)) >> MEMO_CLUSTER_SHIFT) & VTOB_HASH_MASK)\n\ntypedef struct m_pool {\t\t \n\tm_bush_t bush;\n\tm_addr_t (*getp)(struct m_pool *);\n\tvoid (*freep)(struct m_pool *, m_addr_t);\n\tint nump;\n\tm_vtob_s *(vtob[VTOB_HASH_SIZE]);\n\tstruct m_pool *next;\n\tstruct m_link h[PAGE_SHIFT-MEMO_SHIFT+MEMO_PAGE_ORDER+1];\n} m_pool_s;\n\nstatic void *___m_alloc(m_pool_s *mp, int size)\n{\n\tint i = 0;\n\tint s = (1 << MEMO_SHIFT);\n\tint j;\n\tm_addr_t a;\n\tm_link_s *h = mp->h;\n\n\tif (size > (PAGE_SIZE << MEMO_PAGE_ORDER))\n\t\treturn NULL;\n\n\twhile (size > s) {\n\t\ts <<= 1;\n\t\t++i;\n\t}\n\n\tj = i;\n\twhile (!h[j].next) {\n\t\tif (s == (PAGE_SIZE << MEMO_PAGE_ORDER)) {\n\t\t\th[j].next = (m_link_s *)mp->getp(mp);\n\t\t\tif (h[j].next)\n\t\t\t\th[j].next->next = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t++j;\n\t\ts <<= 1;\n\t}\n\ta = (m_addr_t) h[j].next;\n\tif (a) {\n\t\th[j].next = h[j].next->next;\n\t\twhile (j > i) {\n\t\t\tj -= 1;\n\t\t\ts >>= 1;\n\t\t\th[j].next = (m_link_s *) (a+s);\n\t\t\th[j].next->next = NULL;\n\t\t}\n\t}\n#ifdef DEBUG\n\tprintk(\"___m_alloc(%d) = %p\\n\", size, (void *) a);\n#endif\n\treturn (void *) a;\n}\n\nstatic void ___m_free(m_pool_s *mp, void *ptr, int size)\n{\n\tint i = 0;\n\tint s = (1 << MEMO_SHIFT);\n\tm_link_s *q;\n\tm_addr_t a, b;\n\tm_link_s *h = mp->h;\n\n#ifdef DEBUG\n\tprintk(\"___m_free(%p, %d)\\n\", ptr, size);\n#endif\n\n\tif (size > (PAGE_SIZE << MEMO_PAGE_ORDER))\n\t\treturn;\n\n\twhile (size > s) {\n\t\ts <<= 1;\n\t\t++i;\n\t}\n\n\ta = (m_addr_t) ptr;\n\n\twhile (1) {\n#ifdef MEMO_FREE_UNUSED\n\t\tif (s == (PAGE_SIZE << MEMO_PAGE_ORDER)) {\n\t\t\tmp->freep(mp, a);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tb = a ^ s;\n\t\tq = &h[i];\n\t\twhile (q->next && q->next != (m_link_s *) b) {\n\t\t\tq = q->next;\n\t\t}\n\t\tif (!q->next) {\n\t\t\t((m_link_s *) a)->next = h[i].next;\n\t\t\th[i].next = (m_link_s *) a;\n\t\t\tbreak;\n\t\t}\n\t\tq->next = q->next->next;\n\t\ta = a & b;\n\t\ts <<= 1;\n\t\t++i;\n\t}\n}\n\nstatic DEFINE_SPINLOCK(ncr53c8xx_lock);\n\nstatic void *__m_calloc2(m_pool_s *mp, int size, char *name, int uflags)\n{\n\tvoid *p;\n\n\tp = ___m_alloc(mp, size);\n\n\tif (DEBUG_FLAGS & DEBUG_ALLOC)\n\t\tprintk (\"new %-10s[%4d] @%p.\\n\", name, size, p);\n\n\tif (p)\n\t\tmemset(p, 0, size);\n\telse if (uflags & MEMO_WARN)\n\t\tprintk (NAME53C8XX \": failed to allocate %s[%d]\\n\", name, size);\n\n\treturn p;\n}\n\n#define __m_calloc(mp, s, n)\t__m_calloc2(mp, s, n, MEMO_WARN)\n\nstatic void __m_free(m_pool_s *mp, void *ptr, int size, char *name)\n{\n\tif (DEBUG_FLAGS & DEBUG_ALLOC)\n\t\tprintk (\"freeing %-10s[%4d] @%p.\\n\", name, size, ptr);\n\n\t___m_free(mp, ptr, size);\n\n}\n\n \n\nstatic m_addr_t ___mp0_getp(m_pool_s *mp)\n{\n\tm_addr_t m = __get_free_pages(MEMO_GFP_FLAGS, MEMO_PAGE_ORDER);\n\tif (m)\n\t\t++mp->nump;\n\treturn m;\n}\n\nstatic void ___mp0_freep(m_pool_s *mp, m_addr_t m)\n{\n\tfree_pages(m, MEMO_PAGE_ORDER);\n\t--mp->nump;\n}\n\nstatic m_pool_s mp0 = {NULL, ___mp0_getp, ___mp0_freep};\n\n \n\n \nstatic m_addr_t ___dma_getp(m_pool_s *mp)\n{\n\tm_addr_t vp;\n\tm_vtob_s *vbp;\n\n\tvbp = __m_calloc(&mp0, sizeof(*vbp), \"VTOB\");\n\tif (vbp) {\n\t\tdma_addr_t daddr;\n\t\tvp = (m_addr_t) dma_alloc_coherent(mp->bush,\n\t\t\t\t\t\tPAGE_SIZE<<MEMO_PAGE_ORDER,\n\t\t\t\t\t\t&daddr, GFP_ATOMIC);\n\t\tif (vp) {\n\t\t\tint hc = VTOB_HASH_CODE(vp);\n\t\t\tvbp->vaddr = vp;\n\t\t\tvbp->baddr = daddr;\n\t\t\tvbp->next = mp->vtob[hc];\n\t\t\tmp->vtob[hc] = vbp;\n\t\t\t++mp->nump;\n\t\t\treturn vp;\n\t\t}\n\t}\n\tif (vbp)\n\t\t__m_free(&mp0, vbp, sizeof(*vbp), \"VTOB\");\n\treturn 0;\n}\n\nstatic void ___dma_freep(m_pool_s *mp, m_addr_t m)\n{\n\tm_vtob_s **vbpp, *vbp;\n\tint hc = VTOB_HASH_CODE(m);\n\n\tvbpp = &mp->vtob[hc];\n\twhile (*vbpp && (*vbpp)->vaddr != m)\n\t\tvbpp = &(*vbpp)->next;\n\tif (*vbpp) {\n\t\tvbp = *vbpp;\n\t\t*vbpp = (*vbpp)->next;\n\t\tdma_free_coherent(mp->bush, PAGE_SIZE<<MEMO_PAGE_ORDER,\n\t\t\t\t  (void *)vbp->vaddr, (dma_addr_t)vbp->baddr);\n\t\t__m_free(&mp0, vbp, sizeof(*vbp), \"VTOB\");\n\t\t--mp->nump;\n\t}\n}\n\nstatic inline m_pool_s *___get_dma_pool(m_bush_t bush)\n{\n\tm_pool_s *mp;\n\tfor (mp = mp0.next; mp && mp->bush != bush; mp = mp->next);\n\treturn mp;\n}\n\nstatic m_pool_s *___cre_dma_pool(m_bush_t bush)\n{\n\tm_pool_s *mp;\n\tmp = __m_calloc(&mp0, sizeof(*mp), \"MPOOL\");\n\tif (mp) {\n\t\tmemset(mp, 0, sizeof(*mp));\n\t\tmp->bush = bush;\n\t\tmp->getp = ___dma_getp;\n\t\tmp->freep = ___dma_freep;\n\t\tmp->next = mp0.next;\n\t\tmp0.next = mp;\n\t}\n\treturn mp;\n}\n\nstatic void ___del_dma_pool(m_pool_s *p)\n{\n\tstruct m_pool **pp = &mp0.next;\n\n\twhile (*pp && *pp != p)\n\t\tpp = &(*pp)->next;\n\tif (*pp) {\n\t\t*pp = (*pp)->next;\n\t\t__m_free(&mp0, p, sizeof(*p), \"MPOOL\");\n\t}\n}\n\nstatic void *__m_calloc_dma(m_bush_t bush, int size, char *name)\n{\n\tu_long flags;\n\tstruct m_pool *mp;\n\tvoid *m = NULL;\n\n\tspin_lock_irqsave(&ncr53c8xx_lock, flags);\n\tmp = ___get_dma_pool(bush);\n\tif (!mp)\n\t\tmp = ___cre_dma_pool(bush);\n\tif (mp)\n\t\tm = __m_calloc(mp, size, name);\n\tif (mp && !mp->nump)\n\t\t___del_dma_pool(mp);\n\tspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\n\n\treturn m;\n}\n\nstatic void __m_free_dma(m_bush_t bush, void *m, int size, char *name)\n{\n\tu_long flags;\n\tstruct m_pool *mp;\n\n\tspin_lock_irqsave(&ncr53c8xx_lock, flags);\n\tmp = ___get_dma_pool(bush);\n\tif (mp)\n\t\t__m_free(mp, m, size, name);\n\tif (mp && !mp->nump)\n\t\t___del_dma_pool(mp);\n\tspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\n}\n\nstatic m_addr_t __vtobus(m_bush_t bush, void *m)\n{\n\tu_long flags;\n\tm_pool_s *mp;\n\tint hc = VTOB_HASH_CODE(m);\n\tm_vtob_s *vp = NULL;\n\tm_addr_t a = ((m_addr_t) m) & ~MEMO_CLUSTER_MASK;\n\n\tspin_lock_irqsave(&ncr53c8xx_lock, flags);\n\tmp = ___get_dma_pool(bush);\n\tif (mp) {\n\t\tvp = mp->vtob[hc];\n\t\twhile (vp && (m_addr_t) vp->vaddr != a)\n\t\t\tvp = vp->next;\n\t}\n\tspin_unlock_irqrestore(&ncr53c8xx_lock, flags);\n\treturn vp ? vp->baddr + (((m_addr_t) m) - a) : 0;\n}\n\n#define _m_calloc_dma(np, s, n)\t\t__m_calloc_dma(np->dev, s, n)\n#define _m_free_dma(np, p, s, n)\t__m_free_dma(np->dev, p, s, n)\n#define m_calloc_dma(s, n)\t\t_m_calloc_dma(np, s, n)\n#define m_free_dma(p, s, n)\t\t_m_free_dma(np, p, s, n)\n#define _vtobus(np, p)\t\t\t__vtobus(np->dev, p)\n#define vtobus(p)\t\t\t_vtobus(np, p)\n\n \n\nstatic void __unmap_scsi_data(struct device *dev, struct scsi_cmnd *cmd)\n{\n\tstruct ncr_cmd_priv *cmd_priv = scsi_cmd_priv(cmd);\n\n\tswitch(cmd_priv->data_mapped) {\n\tcase 2:\n\t\tscsi_dma_unmap(cmd);\n\t\tbreak;\n\t}\n\tcmd_priv->data_mapped = 0;\n}\n\nstatic int __map_scsi_sg_data(struct device *dev, struct scsi_cmnd *cmd)\n{\n\tstruct ncr_cmd_priv *cmd_priv = scsi_cmd_priv(cmd);\n\tint use_sg;\n\n\tuse_sg = scsi_dma_map(cmd);\n\tif (!use_sg)\n\t\treturn 0;\n\n\tcmd_priv->data_mapped = 2;\n\tcmd_priv->data_mapping = use_sg;\n\n\treturn use_sg;\n}\n\n#define unmap_scsi_data(np, cmd)\t__unmap_scsi_data(np->dev, cmd)\n#define map_scsi_sg_data(np, cmd)\t__map_scsi_sg_data(np->dev, cmd)\n\n \nstatic struct ncr_driver_setup\n\tdriver_setup\t\t\t= SCSI_NCR_DRIVER_SETUP;\n\n#ifndef MODULE\n#ifdef\tSCSI_NCR_BOOT_COMMAND_LINE_SUPPORT\nstatic struct ncr_driver_setup\n\tdriver_safe_setup __initdata\t= SCSI_NCR_DRIVER_SAFE_SETUP;\n#endif\n#endif  \n\n#define initverbose (driver_setup.verbose)\n#define bootverbose (np->verbose)\n\n\n \n\n#ifdef MODULE\n#define\tARG_SEP\t' '\n#else\n#define\tARG_SEP\t','\n#endif\n\n#define OPT_TAGS\t\t1\n#define OPT_MASTER_PARITY\t2\n#define OPT_SCSI_PARITY\t\t3\n#define OPT_DISCONNECTION\t4\n#define OPT_SPECIAL_FEATURES\t5\n#define OPT_UNUSED_1\t\t6\n#define OPT_FORCE_SYNC_NEGO\t7\n#define OPT_REVERSE_PROBE\t8\n#define OPT_DEFAULT_SYNC\t9\n#define OPT_VERBOSE\t\t10\n#define OPT_DEBUG\t\t11\n#define OPT_BURST_MAX\t\t12\n#define OPT_LED_PIN\t\t13\n#define OPT_MAX_WIDE\t\t14\n#define OPT_SETTLE_DELAY\t15\n#define OPT_DIFF_SUPPORT\t16\n#define OPT_IRQM\t\t17\n#define OPT_PCI_FIX_UP\t\t18\n#define OPT_BUS_CHECK\t\t19\n#define OPT_OPTIMIZE\t\t20\n#define OPT_RECOVERY\t\t21\n#define OPT_SAFE_SETUP\t\t22\n#define OPT_USE_NVRAM\t\t23\n#define OPT_EXCLUDE\t\t24\n#define OPT_HOST_ID\t\t25\n\n#ifdef SCSI_NCR_IARB_SUPPORT\n#define OPT_IARB\t\t26\n#endif\n\n#ifdef MODULE\n#define\tARG_SEP\t' '\n#else\n#define\tARG_SEP\t','\n#endif\n\n#ifndef MODULE\nstatic char setup_token[] __initdata = \n\t\"tags:\"   \"mpar:\"\n\t\"spar:\"   \"disc:\"\n\t\"specf:\"  \"ultra:\"\n\t\"fsn:\"    \"revprob:\"\n\t\"sync:\"   \"verb:\"\n\t\"debug:\"  \"burst:\"\n\t\"led:\"    \"wide:\"\n\t\"settle:\" \"diff:\"\n\t\"irqm:\"   \"pcifix:\"\n\t\"buschk:\" \"optim:\"\n\t\"recovery:\"\n\t\"safe:\"   \"nvram:\"\n\t\"excl:\"   \"hostid:\"\n#ifdef SCSI_NCR_IARB_SUPPORT\n\t\"iarb:\"\n#endif\n\t;\t \n\nstatic int __init get_setup_token(char *p)\n{\n\tchar *cur = setup_token;\n\tchar *pc;\n\tint i = 0;\n\n\twhile (cur != NULL && (pc = strchr(cur, ':')) != NULL) {\n\t\t++pc;\n\t\t++i;\n\t\tif (!strncmp(p, cur, pc - cur))\n\t\t\treturn i;\n\t\tcur = pc;\n\t}\n\treturn 0;\n}\n\nstatic int __init sym53c8xx__setup(char *str)\n{\n#ifdef SCSI_NCR_BOOT_COMMAND_LINE_SUPPORT\n\tchar *cur = str;\n\tchar *pc, *pv;\n\tint i, val, c;\n\tint xi = 0;\n\n\twhile (cur != NULL && (pc = strchr(cur, ':')) != NULL) {\n\t\tchar *pe;\n\n\t\tval = 0;\n\t\tpv = pc;\n\t\tc = *++pv;\n\n\t\tif\t(c == 'n')\n\t\t\tval = 0;\n\t\telse if\t(c == 'y')\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = (int) simple_strtoul(pv, &pe, 0);\n\n\t\tswitch (get_setup_token(cur)) {\n\t\tcase OPT_TAGS:\n\t\t\tdriver_setup.default_tags = val;\n\t\t\tif (pe && *pe == '/') {\n\t\t\t\ti = 0;\n\t\t\t\twhile (*pe && *pe != ARG_SEP && \n\t\t\t\t\ti < sizeof(driver_setup.tag_ctrl)-1) {\n\t\t\t\t\tdriver_setup.tag_ctrl[i++] = *pe++;\n\t\t\t\t}\n\t\t\t\tdriver_setup.tag_ctrl[i] = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OPT_MASTER_PARITY:\n\t\t\tdriver_setup.master_parity = val;\n\t\t\tbreak;\n\t\tcase OPT_SCSI_PARITY:\n\t\t\tdriver_setup.scsi_parity = val;\n\t\t\tbreak;\n\t\tcase OPT_DISCONNECTION:\n\t\t\tdriver_setup.disconnection = val;\n\t\t\tbreak;\n\t\tcase OPT_SPECIAL_FEATURES:\n\t\t\tdriver_setup.special_features = val;\n\t\t\tbreak;\n\t\tcase OPT_FORCE_SYNC_NEGO:\n\t\t\tdriver_setup.force_sync_nego = val;\n\t\t\tbreak;\n\t\tcase OPT_REVERSE_PROBE:\n\t\t\tdriver_setup.reverse_probe = val;\n\t\t\tbreak;\n\t\tcase OPT_DEFAULT_SYNC:\n\t\t\tdriver_setup.default_sync = val;\n\t\t\tbreak;\n\t\tcase OPT_VERBOSE:\n\t\t\tdriver_setup.verbose = val;\n\t\t\tbreak;\n\t\tcase OPT_DEBUG:\n\t\t\tdriver_setup.debug = val;\n\t\t\tbreak;\n\t\tcase OPT_BURST_MAX:\n\t\t\tdriver_setup.burst_max = val;\n\t\t\tbreak;\n\t\tcase OPT_LED_PIN:\n\t\t\tdriver_setup.led_pin = val;\n\t\t\tbreak;\n\t\tcase OPT_MAX_WIDE:\n\t\t\tdriver_setup.max_wide = val? 1:0;\n\t\t\tbreak;\n\t\tcase OPT_SETTLE_DELAY:\n\t\t\tdriver_setup.settle_delay = val;\n\t\t\tbreak;\n\t\tcase OPT_DIFF_SUPPORT:\n\t\t\tdriver_setup.diff_support = val;\n\t\t\tbreak;\n\t\tcase OPT_IRQM:\n\t\t\tdriver_setup.irqm = val;\n\t\t\tbreak;\n\t\tcase OPT_PCI_FIX_UP:\n\t\t\tdriver_setup.pci_fix_up\t= val;\n\t\t\tbreak;\n\t\tcase OPT_BUS_CHECK:\n\t\t\tdriver_setup.bus_check = val;\n\t\t\tbreak;\n\t\tcase OPT_OPTIMIZE:\n\t\t\tdriver_setup.optimize = val;\n\t\t\tbreak;\n\t\tcase OPT_RECOVERY:\n\t\t\tdriver_setup.recovery = val;\n\t\t\tbreak;\n\t\tcase OPT_USE_NVRAM:\n\t\t\tdriver_setup.use_nvram = val;\n\t\t\tbreak;\n\t\tcase OPT_SAFE_SETUP:\n\t\t\tmemcpy(&driver_setup, &driver_safe_setup,\n\t\t\t\tsizeof(driver_setup));\n\t\t\tbreak;\n\t\tcase OPT_EXCLUDE:\n\t\t\tif (xi < SCSI_NCR_MAX_EXCLUDES)\n\t\t\t\tdriver_setup.excludes[xi++] = val;\n\t\t\tbreak;\n\t\tcase OPT_HOST_ID:\n\t\t\tdriver_setup.host_id = val;\n\t\t\tbreak;\n#ifdef SCSI_NCR_IARB_SUPPORT\n\t\tcase OPT_IARB:\n\t\t\tdriver_setup.iarb = val;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tprintk(\"sym53c8xx_setup: unexpected boot option '%.*s' ignored\\n\", (int)(pc-cur+1), cur);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((cur = strchr(cur, ARG_SEP)) != NULL)\n\t\t\t++cur;\n\t}\n#endif  \n\treturn 1;\n}\n#endif  \n\n \n#define DEF_DEPTH\t(driver_setup.default_tags)\n#define ALL_TARGETS\t-2\n#define NO_TARGET\t-1\n#define ALL_LUNS\t-2\n#define NO_LUN\t\t-1\n\nstatic int device_queue_depth(int unit, int target, int lun)\n{\n\tint c, h, t, u, v;\n\tchar *p = driver_setup.tag_ctrl;\n\tchar *ep;\n\n\th = -1;\n\tt = NO_TARGET;\n\tu = NO_LUN;\n\twhile ((c = *p++) != 0) {\n\t\tv = simple_strtoul(p, &ep, 0);\n\t\tswitch(c) {\n\t\tcase '/':\n\t\t\t++h;\n\t\t\tt = ALL_TARGETS;\n\t\t\tu = ALL_LUNS;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif (t != target)\n\t\t\t\tt = (target == v) ? v : NO_TARGET;\n\t\t\tu = ALL_LUNS;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tif (u != lun)\n\t\t\t\tu = (lun == v) ? v : NO_LUN;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tif (h == unit &&\n\t\t\t\t(t == ALL_TARGETS || t == target) &&\n\t\t\t\t(u == ALL_LUNS    || u == lun))\n\t\t\t\treturn v;\n\t\t\tbreak;\n\t\tcase '-':\n\t\t\tt = ALL_TARGETS;\n\t\t\tu = ALL_LUNS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tp = ep;\n\t}\n\treturn DEF_DEPTH;\n}\n\n\n \n \n#define SCSI_NCR_CCB_DONE_SUPPORT\n#ifdef  SCSI_NCR_CCB_DONE_SUPPORT\n\n#define MAX_DONE 24\n#define CCB_DONE_EMPTY 0xffffffffUL\n\n \n#if BITS_PER_LONG == 32\n#define CCB_DONE_VALID(cp)  (((u_long) cp) != CCB_DONE_EMPTY)\n\n \n#else\n#define CCB_DONE_VALID(cp)  \\\n\t((((u_long) cp) & 0xffffffff00000000ul) && \t\\\n\t (((u_long) cp) & 0xfffffffful) != CCB_DONE_EMPTY)\n#endif\n\n#endif  \n\n \n\n \n\n#ifndef SCSI_NCR_MYADDR\n#define SCSI_NCR_MYADDR      (7)\n#endif\n\n \n\n#ifndef SCSI_NCR_MAX_TAGS\n#define SCSI_NCR_MAX_TAGS    (8)\n#endif\n\n \n#if\tSCSI_NCR_MAX_TAGS > 64\n#define\tMAX_TAGS (64)\n#else\n#define\tMAX_TAGS SCSI_NCR_MAX_TAGS\n#endif\n\n#define NO_TAG\t(255)\n\n \n#if\tMAX_TAGS > 32\ntypedef u64 tagmap_t;\n#else\ntypedef u32 tagmap_t;\n#endif\n\n \n\n#ifdef SCSI_NCR_MAX_TARGET\n#define MAX_TARGET  (SCSI_NCR_MAX_TARGET)\n#else\n#define MAX_TARGET  (16)\n#endif\n\n \n\n#ifdef SCSI_NCR_MAX_LUN\n#define MAX_LUN    SCSI_NCR_MAX_LUN\n#else\n#define MAX_LUN    (1)\n#endif\n\n \n \n#ifndef SCSI_NCR_MIN_ASYNC\n#define SCSI_NCR_MIN_ASYNC (40)\n#endif\n\n \n\n#ifdef SCSI_NCR_CAN_QUEUE\n#define MAX_START   (SCSI_NCR_CAN_QUEUE + 4)\n#else\n#define MAX_START   (MAX_TARGET + 7 * MAX_TAGS)\n#endif\n\n \n#if\tMAX_START > 250\n#undef\tMAX_START\n#define\tMAX_START 250\n#endif\n\n \n\n#define MAX_SCATTER (SCSI_NCR_MAX_SCATTER)\n\n#if (MAX_SCATTER > 80)\n#define MAX_SCATTERL\t80\n#define\tMAX_SCATTERH\t(MAX_SCATTER - MAX_SCATTERL)\n#else\n#define MAX_SCATTERL\t(MAX_SCATTER-1)\n#define\tMAX_SCATTERH\t1\n#endif\n\n \n\n#define NCR_SNOOP_TIMEOUT (1000000)\n\n \n\n#define initverbose (driver_setup.verbose)\n#define bootverbose (np->verbose)\n\n \n\n#define HS_IDLE\t\t(0)\n#define HS_BUSY\t\t(1)\n#define HS_NEGOTIATE\t(2)\t \n#define HS_DISCONNECT\t(3)\t \n\n#define HS_DONEMASK\t(0x80)\n#define HS_COMPLETE\t(4|HS_DONEMASK)\n#define HS_SEL_TIMEOUT\t(5|HS_DONEMASK)\t \n#define HS_RESET\t(6|HS_DONEMASK)\t \n#define HS_ABORTED\t(7|HS_DONEMASK)\t \n#define HS_TIMEOUT\t(8|HS_DONEMASK)\t \n#define HS_FAIL\t\t(9|HS_DONEMASK)\t \n#define HS_UNEXPECTED\t(10|HS_DONEMASK) \n\n \n\n#define HS_INVALMASK\t(0x40)\n#define\tHS_SELECTING\t(0|HS_INVALMASK)\n#define\tHS_IN_RESELECT\t(1|HS_INVALMASK)\n#define\tHS_STARTING\t(2|HS_INVALMASK)\n\n \n#define HS_SKIPMASK\t(0x20)\n\n \n\n#define\tSIR_BAD_STATUS\t\t(1)\n#define\tSIR_XXXXXXXXXX\t\t(2)\n#define\tSIR_NEGO_SYNC\t\t(3)\n#define\tSIR_NEGO_WIDE\t\t(4)\n#define\tSIR_NEGO_FAILED\t\t(5)\n#define\tSIR_NEGO_PROTO\t\t(6)\n#define\tSIR_REJECT_RECEIVED\t(7)\n#define\tSIR_REJECT_SENT\t\t(8)\n#define\tSIR_IGN_RESIDUE\t\t(9)\n#define\tSIR_MISSING_SAVE\t(10)\n#define\tSIR_RESEL_NO_MSG_IN\t(11)\n#define\tSIR_RESEL_NO_IDENTIFY\t(12)\n#define\tSIR_RESEL_BAD_LUN\t(13)\n#define\tSIR_RESEL_BAD_TARGET\t(14)\n#define\tSIR_RESEL_BAD_I_T_L\t(15)\n#define\tSIR_RESEL_BAD_I_T_L_Q\t(16)\n#define\tSIR_DONE_OVERFLOW\t(17)\n#define\tSIR_INTFLY\t\t(18)\n#define\tSIR_MAX\t\t\t(18)\n\n \n\n#define\tXE_OK\t\t(0)\n#define\tXE_EXTRA_DATA\t(1)\t \n#define\tXE_BAD_PHASE\t(2)\t \n\n \n\n#define NS_NOCHANGE\t(0)\n#define NS_SYNC\t\t(1)\n#define NS_WIDE\t\t(2)\n#define NS_PPR\t\t(4)\n\n \n\n#define CCB_MAGIC\t(0xf2691ad2)\n\n \n\nstatic struct scsi_transport_template *ncr53c8xx_transport_template = NULL;\n\nstruct tcb;\nstruct lcb;\nstruct ccb;\nstruct ncb;\nstruct script;\n\nstruct link {\n\tncrcmd\tl_cmd;\n\tncrcmd\tl_paddr;\n};\n\nstruct\tusrcmd {\n\tu_long\ttarget;\n\tu_long\tlun;\n\tu_long\tdata;\n\tu_long\tcmd;\n};\n\n#define UC_SETSYNC      10\n#define UC_SETTAGS\t11\n#define UC_SETDEBUG\t12\n#define UC_SETORDER\t13\n#define UC_SETWIDE\t14\n#define UC_SETFLAG\t15\n#define UC_SETVERBOSE\t17\n\n#define\tUF_TRACE\t(0x01)\n#define\tUF_NODISC\t(0x02)\n#define\tUF_NOSCAN\t(0x04)\n\n \nstruct tcb {\n\t \n\tstruct link   jump_tcb;\n\n\t \n\tncrcmd\tgetscr[6];\n\n\t \n\tstruct link   call_lun;\n\n\t \n\tstruct link     jump_lcb[4];\t \n\tstruct lcb *\tlp[MAX_LUN];\t \n\n\t \n\tstruct ccb *   nego_cp;\n\n\t \n\tu_long\ttransfers;\n\tu_long\tbytes;\n\n\t \n#ifdef SCSI_NCR_BIG_ENDIAN\n \tu16\tperiod;\n \tu_char\tsval;\n \tu_char\tminsync;\n \tu_char\twval;\n \tu_char\twidedone;\n \tu_char\tquirks;\n \tu_char\tmaxoffs;\n#else\n \tu_char\tminsync;\n \tu_char\tsval;\n \tu16\tperiod;\n \tu_char\tmaxoffs;\n \tu_char\tquirks;\n \tu_char\twidedone;\n \tu_char\twval;\n#endif\n\n\t \n\tu_char\tusrsync;\n\tu_char\tusrwide;\n\tu_char\tusrtags;\n\tu_char\tusrflag;\n\tstruct scsi_target *starget;\n};\n\n \nstruct lcb {\n\t \n\tstruct link\tjump_lcb;\n\tncrcmd\t\tload_jump_ccb[3];\n\tstruct link\tjump_tag;\n\tncrcmd\t\tp_jump_ccb;\t \n\n\t \n\tu32\t\tjump_ccb_0;\t \n\tu32\t\t*jump_ccb;\t \n\n\t \n\tstruct list_head free_ccbq;\t \n\tstruct list_head busy_ccbq;\t \n\tstruct list_head wait_ccbq;\t \n\tstruct list_head skip_ccbq;\t \n\tu_char\t\tactccbs;\t \n\tu_char\t\tbusyccbs;\t \n\tu_char\t\tqueuedccbs;\t \n\tu_char\t\tqueuedepth;\t \n\tu_char\t\tscdev_depth;\t \n\tu_char\t\tmaxnxs;\t\t \n\n\t \n\tu_char\t\tia_tag;\t\t \n\tu_char\t\tif_tag;\t\t \n\tu_char cb_tags[MAX_TAGS];\t \n\tu_char\t\tusetags;\t \n\tu_char\t\tmaxtags;\t \n\tu_char\t\tnumtags;\t \n\n\t \n\t \n\tu16\t\tnum_good;\t \n\ttagmap_t\ttags_umap;\t \n\ttagmap_t\ttags_smap;\t \n\tu_long\t\ttags_stime;\t \n\tstruct ccb *\theld_ccb;\t \n};\n\n \nstruct launch {\n\t \n\tncrcmd\t\tsetup_dsa[3];\t \n\tstruct link\tschedule;\t \n\tncrcmd\t\tp_phys;\t\t \n};\n\n \n\nstruct head {\n\t \n\tu32\t\tsavep;\n\tu32\t\tlastp;\n\tu32\t\tgoalp;\n\n\t \n\tu32\t\twlastp;\n\tu32\t\twgoalp;\n\n\t \n\tstruct ccb *\tcp;\n\n\t \n\tu_char\t\tscr_st[4];\t \n\tu_char\t\tstatus[4];\t \n\t\t\t\t\t \n};\n\n \n\n \n#define  QU_REG\tscr0\n#define  HS_REG\tscr1\n#define  HS_PRT\tnc_scr1\n#define  SS_REG\tscr2\n#define  SS_PRT\tnc_scr2\n#define  PS_REG\tscr3\n\n \n#ifdef SCSI_NCR_BIG_ENDIAN\n#define  actualquirks  phys.header.status[3]\n#define  host_status   phys.header.status[2]\n#define  scsi_status   phys.header.status[1]\n#define  parity_status phys.header.status[0]\n#else\n#define  actualquirks  phys.header.status[0]\n#define  host_status   phys.header.status[1]\n#define  scsi_status   phys.header.status[2]\n#define  parity_status phys.header.status[3]\n#endif\n\n \n#define  xerr_st       header.scr_st[0]\n#define  sync_st       header.scr_st[1]\n#define  nego_st       header.scr_st[2]\n#define  wide_st       header.scr_st[3]\n\n \n#define  xerr_status   phys.xerr_st\n#define  nego_status   phys.nego_st\n\n \n\nstruct dsb {\n\n\t \n\n\tstruct head\theader;\n\n\t \n\n\tstruct scr_tblsel  select;\n\tstruct scr_tblmove smsg  ;\n\tstruct scr_tblmove cmd   ;\n\tstruct scr_tblmove sense ;\n\tstruct scr_tblmove data[MAX_SCATTER];\n};\n\n\n \nstruct ccb {\n\t \n\tstruct dsb\tphys;\n\n\t \n\tstruct launch\tstart;\n\n\t \n\tstruct launch\trestart;\n\n\t \n\tncrcmd\t\tpatch[8];\n\n\t \n\tstruct scsi_cmnd\t*cmd;\t\t \n\tu_char\t\tcdb_buf[16];\t \n\tu_char\t\tsense_buf[64];\n\tint\t\tdata_len;\t \n\n\t \n\tu_char\t\tscsi_smsg [8];\n\tu_char\t\tscsi_smsg2[8];\n\n\t \n\tu_long\t\tp_ccb;\t\t \n\tu_char\t\tsensecmd[6];\t \n\tu_char\t\ttag;\t\t \n\t\t\t\t\t \n\tu_char\t\ttarget;\n\tu_char\t\tlun;\n\tu_char\t\tqueued;\n\tu_char\t\tauto_sense;\n\tstruct ccb *\tlink_ccb;\t \n\tstruct list_head link_ccbq;\t \n\tu32\t\tstartp;\t\t \n\tu_long\t\tmagic;\t\t \n};\n\n#define CCB_PHYS(cp,lbl)\t(cp->p_ccb + offsetof(struct ccb, lbl))\n\n\n \nstruct ncb {\n\t \n\tstruct head     header;\n\n\t \n\tstruct scsi_cmnd\t*waiting_list;\t \n\t\t\t\t\t \n\tstruct scsi_cmnd\t*done_list;\t \n\t\t\t\t\t  \n\tspinlock_t\tsmp_lock;\t \n\n\t \n\tint\t\tunit;\t\t \n\tchar\t\tinst_name[16];\t \n\n\t \n\tu_char\tsv_scntl0, sv_scntl3, sv_dmode, sv_dcntl, sv_ctest0, sv_ctest3,\n\t\tsv_ctest4, sv_ctest5, sv_gpcntl, sv_stest2, sv_stest4;\n\n\t \n\tu_char\trv_scntl0, rv_scntl3, rv_dmode, rv_dcntl, rv_ctest0, rv_ctest3,\n\t\trv_ctest4, rv_ctest5, rv_stest2;\n\n\t \n\tstruct link     jump_tcb[4];\t \n\tstruct tcb  target[MAX_TARGET];\t \n\n\t \n\tvoid __iomem *vaddr;\t\t \n\tunsigned long\tpaddr;\t\t \n\tunsigned long\tpaddr2;\t\t \n\tvolatile\t\t\t \n\tstruct ncr_reg\t__iomem *reg;\t \n\n\t \n\tstruct script\t*script0;\t \n\tstruct scripth\t*scripth0;\t \n\tstruct scripth\t*scripth;\t \n\tu_long\t\tp_script;\t \n\tu_long\t\tp_scripth;\t \n\n\t \n\tstruct device\t*dev;\n\tu_char\t\trevision_id;\t \n\tu32\t\tirq;\t\t \n\tu32\t\tfeatures;\t \n\tu_char\t\tmyaddr;\t\t \n\tu_char\t\tmaxburst;\t \n\tu_char\t\tmaxwide;\t \n\tu_char\t\tminsync;\t \n\tu_char\t\tmaxsync;\t \n\tu_char\t\tmaxoffs;\t \n\tu_char\t\tmultiplier;\t \n\tu_char\t\tclock_divn;\t \n\tu_long\t\tclock_khz;\t \n\n\t \n\tu16\t\tsqueueput;\t \n\tu16\t\tactccbs;\t \n\tu16\t\tqueuedccbs;\t \n\tu16\t\tqueuedepth;\t \n\n\t \n\tstruct timer_list timer;\t \n\tu_long\t\tlasttime;\n\tu_long\t\tsettle_time;\t \n\n\t \n\tstruct ncr_reg\tregdump;\t \n\tu_long\t\tregtime;\t \n\n\t \n\tu_char\t\tmsgout[8];\t \n\tu_char\t\tmsgin [8];\t \n\tu32\t\tlastmsg;\t \n\tu_char\t\tscratch;\t \n\n\t \n\tu_char\t\tdisc;\t\t \n\tu_char\t\tscsi_mode;\t \n\tu_char\t\torder;\t\t \n\tu_char\t\tverbose;\t \n\tint\t\tncr_cache;\t \n\tu_long\t\tp_ncb;\t\t \n\n\t \n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\tstruct ccb\t*(ccb_done[MAX_DONE]);\n\tint\t\tccb_done_ic;\n#endif\n\t \n\tstruct ccb\t*ccb;\t\t \n\tstruct usrcmd\tuser;\t\t \n\tvolatile u_char\trelease_stage;\t \n};\n\n#define NCB_SCRIPT_PHYS(np,lbl)\t (np->p_script  + offsetof (struct script, lbl))\n#define NCB_SCRIPTH_PHYS(np,lbl) (np->p_scripth + offsetof (struct scripth,lbl))\n\n \n\n \n\n#ifdef CONFIG_NCR53C8XX_PREFETCH\n#define PREFETCH_FLUSH_CNT\t2\n#define PREFETCH_FLUSH\t\tSCR_CALL, PADDRH (wait_dma),\n#else\n#define PREFETCH_FLUSH_CNT\t0\n#define PREFETCH_FLUSH\n#endif\n\n \nstruct script {\n\tncrcmd\tstart\t\t[  5];\n\tncrcmd  startpos\t[  1];\n\tncrcmd\tselect\t\t[  6];\n\tncrcmd\tselect2\t\t[  9 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tloadpos\t\t[  4];\n\tncrcmd\tsend_ident\t[  9];\n\tncrcmd\tprepare\t\t[  6];\n\tncrcmd\tprepare2\t[  7];\n\tncrcmd  command\t\t[  6];\n\tncrcmd  dispatch\t[ 32];\n\tncrcmd  clrack\t\t[  4];\n\tncrcmd\tno_data\t\t[ 17];\n\tncrcmd  status\t\t[  8];\n\tncrcmd  msg_in\t\t[  2];\n\tncrcmd  msg_in2\t\t[ 16];\n\tncrcmd  msg_bad\t\t[  4];\n\tncrcmd\tsetmsg\t\t[  7];\n\tncrcmd\tcleanup\t\t[  6];\n\tncrcmd  complete\t[  9];\n\tncrcmd\tcleanup_ok\t[  8 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tcleanup0\t[  1];\n#ifndef SCSI_NCR_CCB_DONE_SUPPORT\n\tncrcmd\tsignal\t\t[ 12];\n#else\n\tncrcmd\tsignal\t\t[  9];\n\tncrcmd\tdone_pos\t[  1];\n\tncrcmd\tdone_plug\t[  2];\n\tncrcmd\tdone_end\t[  7];\n#endif\n\tncrcmd  save_dp\t\t[  7];\n\tncrcmd  restore_dp\t[  5];\n\tncrcmd  disconnect\t[ 10];\n\tncrcmd\tmsg_out\t\t[  9];\n\tncrcmd\tmsg_out_done\t[  7];\n\tncrcmd  idle\t\t[  2];\n\tncrcmd\treselect\t[  8];\n\tncrcmd\treselected\t[  8];\n\tncrcmd\tresel_dsa\t[  6 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tloadpos1\t[  4];\n\tncrcmd  resel_lun\t[  6];\n\tncrcmd\tresel_tag\t[  6];\n\tncrcmd\tjump_to_nexus\t[  4 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tnexus_indirect\t[  4];\n\tncrcmd\tresel_notag\t[  4];\n\tncrcmd  data_in\t\t[MAX_SCATTERL * 4];\n\tncrcmd  data_in2\t[  4];\n\tncrcmd  data_out\t[MAX_SCATTERL * 4];\n\tncrcmd  data_out2\t[  4];\n};\n\n \nstruct scripth {\n\tncrcmd  tryloop\t\t[MAX_START*2];\n\tncrcmd  tryloop2\t[  2];\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\tncrcmd  done_queue\t[MAX_DONE*5];\n\tncrcmd  done_queue2\t[  2];\n#endif\n\tncrcmd\tselect_no_atn\t[  8];\n\tncrcmd\tcancel\t\t[  4];\n\tncrcmd\tskip\t\t[  9 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tskip2\t\t[ 19];\n\tncrcmd\tpar_err_data_in\t[  6];\n\tncrcmd\tpar_err_other\t[  4];\n\tncrcmd\tmsg_reject\t[  8];\n\tncrcmd\tmsg_ign_residue\t[ 24];\n\tncrcmd  msg_extended\t[ 10];\n\tncrcmd  msg_ext_2\t[ 10];\n\tncrcmd\tmsg_wdtr\t[ 14];\n\tncrcmd\tsend_wdtr\t[  7];\n\tncrcmd  msg_ext_3\t[ 10];\n\tncrcmd\tmsg_sdtr\t[ 14];\n\tncrcmd\tsend_sdtr\t[  7];\n\tncrcmd\tnego_bad_phase\t[  4];\n\tncrcmd\tmsg_out_abort\t[ 10];\n\tncrcmd  hdata_in\t[MAX_SCATTERH * 4];\n\tncrcmd  hdata_in2\t[  2];\n\tncrcmd  hdata_out\t[MAX_SCATTERH * 4];\n\tncrcmd  hdata_out2\t[  2];\n\tncrcmd\treset\t\t[  4];\n\tncrcmd\taborttag\t[  4];\n\tncrcmd\tabort\t\t[  2];\n\tncrcmd\tabort_resel\t[ 20];\n\tncrcmd\tresend_ident\t[  4];\n\tncrcmd\tclratn_go_on\t[  3];\n\tncrcmd\tnxtdsp_go_on\t[  1];\n\tncrcmd\tsdata_in\t[  8];\n\tncrcmd  data_io\t\t[ 18];\n\tncrcmd\tbad_identify\t[ 12];\n\tncrcmd\tbad_i_t_l\t[  4];\n\tncrcmd\tbad_i_t_l_q\t[  4];\n\tncrcmd\tbad_target\t[  8];\n\tncrcmd\tbad_status\t[  8];\n\tncrcmd\tstart_ram\t[  4 + PREFETCH_FLUSH_CNT];\n\tncrcmd\tstart_ram0\t[  4];\n\tncrcmd\tsto_restart\t[  5];\n\tncrcmd\twait_dma\t[  2];\n\tncrcmd\tsnooptest\t[  9];\n\tncrcmd\tsnoopend\t[  2];\n};\n\n \n\nstatic\tvoid\tncr_alloc_ccb\t(struct ncb *np, u_char tn, u_char ln);\nstatic\tvoid\tncr_complete\t(struct ncb *np, struct ccb *cp);\nstatic\tvoid\tncr_exception\t(struct ncb *np);\nstatic\tvoid\tncr_free_ccb\t(struct ncb *np, struct ccb *cp);\nstatic\tvoid\tncr_init_ccb\t(struct ncb *np, struct ccb *cp);\nstatic\tvoid\tncr_init_tcb\t(struct ncb *np, u_char tn);\nstatic\tstruct lcb *\tncr_alloc_lcb\t(struct ncb *np, u_char tn, u_char ln);\nstatic\tstruct lcb *\tncr_setup_lcb\t(struct ncb *np, struct scsi_device *sdev);\nstatic\tvoid\tncr_getclock\t(struct ncb *np, int mult);\nstatic\tvoid\tncr_selectclock\t(struct ncb *np, u_char scntl3);\nstatic\tstruct ccb *ncr_get_ccb\t(struct ncb *np, struct scsi_cmnd *cmd);\nstatic\tvoid\tncr_chip_reset\t(struct ncb *np, int delay);\nstatic\tvoid\tncr_init\t(struct ncb *np, int reset, char * msg, u_long code);\nstatic\tint\tncr_int_sbmc\t(struct ncb *np);\nstatic\tint\tncr_int_par\t(struct ncb *np);\nstatic\tvoid\tncr_int_ma\t(struct ncb *np);\nstatic\tvoid\tncr_int_sir\t(struct ncb *np);\nstatic  void    ncr_int_sto     (struct ncb *np);\nstatic\tvoid\tncr_negotiate\t(struct ncb* np, struct tcb* tp);\nstatic\tint\tncr_prepare_nego(struct ncb *np, struct ccb *cp, u_char *msgptr);\n\nstatic\tvoid\tncr_script_copy_and_bind\n\t\t\t\t(struct ncb *np, ncrcmd *src, ncrcmd *dst, int len);\nstatic  void    ncr_script_fill (struct script * scr, struct scripth * scripth);\nstatic\tint\tncr_scatter\t(struct ncb *np, struct ccb *cp, struct scsi_cmnd *cmd);\nstatic\tvoid\tncr_getsync\t(struct ncb *np, u_char sfac, u_char *fakp, u_char *scntl3p);\nstatic\tvoid\tncr_setsync\t(struct ncb *np, struct ccb *cp, u_char scntl3, u_char sxfer);\nstatic\tvoid\tncr_setup_tags\t(struct ncb *np, struct scsi_device *sdev);\nstatic\tvoid\tncr_setwide\t(struct ncb *np, struct ccb *cp, u_char wide, u_char ack);\nstatic\tint\tncr_snooptest\t(struct ncb *np);\nstatic\tvoid\tncr_timeout\t(struct ncb *np);\nstatic  void    ncr_wakeup      (struct ncb *np, u_long code);\nstatic  void    ncr_wakeup_done (struct ncb *np);\nstatic\tvoid\tncr_start_next_ccb (struct ncb *np, struct lcb * lp, int maxn);\nstatic\tvoid\tncr_put_start_queue(struct ncb *np, struct ccb *cp);\n\nstatic void insert_into_waiting_list(struct ncb *np, struct scsi_cmnd *cmd);\nstatic void process_waiting_list(struct ncb *np, int sts);\n\n#define requeue_waiting_list(np) process_waiting_list((np), DID_OK)\n#define reset_waiting_list(np) process_waiting_list((np), DID_RESET)\n\nstatic inline char *ncr_name (struct ncb *np)\n{\n\treturn np->inst_name;\n}\n\n\n \n\n#define\tRELOC_SOFTC\t0x40000000\n#define\tRELOC_LABEL\t0x50000000\n#define\tRELOC_REGISTER\t0x60000000\n#define\tRELOC_LABELH\t0x80000000\n#define\tRELOC_MASK\t0xf0000000\n\n#define\tNADDR(label)\t(RELOC_SOFTC | offsetof(struct ncb, label))\n#define PADDR(label)    (RELOC_LABEL | offsetof(struct script, label))\n#define PADDRH(label)   (RELOC_LABELH | offsetof(struct scripth, label))\n#define\tRADDR(label)\t(RELOC_REGISTER | REG(label))\n#define\tFADDR(label,ofs)(RELOC_REGISTER | ((REG(label))+(ofs)))\n\n\nstatic\tstruct script script0 __initdata = {\n  {\n\t \n\tSCR_NO_OP,\n\t\t0,\n\t \n\tSCR_FROM_REG (ctest2),\n\t\t0,\n\t \n\tSCR_JUMP,\n} ,{\n\t\tPADDRH(tryloop),\n\n} ,{\n\t \n\n\tSCR_CLR (SCR_TRG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_SELECTING),\n\t\t0,\n\n\t \n\tSCR_SEL_TBL_ATN ^ offsetof (struct dsb, select),\n\t\tPADDR (reselect),\n\n} ,{\n\t \n\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\t0,\n\n\t \n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tPADDR (startpos),\n\t \n\tSCR_COPY_F (4),\n\t\tRADDR (dsa),\n\t\tPADDR (loadpos),\n\t \n\tPREFETCH_FLUSH\n\t \n\tSCR_COPY (sizeof (struct head)),\n\t \n} ,{\n\t\t0,\n\t\tNADDR (header),\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR (prepare),\n\n} ,{\n\t \n\tSCR_MOVE_TBL ^ SCR_MSG_OUT,\n\t\toffsetof (struct dsb, smsg),\n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),\n\t\tPADDRH (resend_ident),\n\tSCR_LOAD_REG (scratcha, 0x80),\n\t\t0,\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (lastmsg),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tNADDR (header.savep),\n\t\tRADDR (temp),\n\t \n\tSCR_COPY (4),\n\t\tNADDR (header.status),\n\t\tRADDR (scr0),\n} ,{\n\t \n\tSCR_LOAD_REG (scratcha, NOP),\n\t\t0,\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgout),\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_COMMAND)),\n\t\tPADDR (dispatch),\n\n} ,{\n\t \n\tSCR_MOVE_TBL ^ SCR_COMMAND,\n\t\toffsetof (struct dsb, cmd),\n\t \n\tSCR_FROM_REG (HS_REG),\n\t\t0,\n\tSCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),\n\t\tSIR_NEGO_FAILED,\n\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (msg_in),\n\n\tSCR_RETURN ^ IFTRUE (IF (SCR_DATA_OUT)),\n\t\t0,\n\t \n\tSCR_JUMPR ^ IFFALSE (IF (SCR_DATA_IN)),\n\t\t20,\n\tSCR_COPY (4),\n\t\tRADDR (scratcha),\n\t\tRADDR (scratcha),\n\tSCR_RETURN,\n \t\t0,\n\tSCR_JUMP ^ IFTRUE (IF (SCR_STATUS)),\n\t\tPADDR (status),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_COMMAND)),\n\t\tPADDR (command),\n\tSCR_JUMP ^ IFTRUE (IF (SCR_MSG_OUT)),\n\t\tPADDR (msg_out),\n\t \n\tSCR_LOAD_REG (scratcha, XE_BAD_PHASE),\n\t\t0,\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (xerr_st),\n\tSCR_JUMPR ^ IFFALSE (IF (SCR_ILG_OUT)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_ILG_OUT,\n\t\tNADDR (scratch),\n\tSCR_JUMPR ^ IFFALSE (IF (SCR_ILG_IN)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_ILG_IN,\n\t\tNADDR (scratch),\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n\n} ,{\n\t \n\tSCR_LOAD_REG (scratcha, XE_EXTRA_DATA),\n\t\t0,\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (xerr_st),\n\t \n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_DATA_OUT)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_DATA_OUT,\n\t\tNADDR (scratch),\n\tSCR_JUMPR ^ IFFALSE (IF (SCR_DATA_IN)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_DATA_IN,\n\t\tNADDR (scratch),\n\t \n\tSCR_CALL,\n\t\tPADDR (dispatch),\n\tSCR_JUMP,\n\t\tPADDR (no_data),\n\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_STATUS,\n\t\tNADDR (scratch),\n\t \n\tSCR_TO_REG (SS_REG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_COMPLETE),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[0]),\n} ,{\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (COMMAND_COMPLETE)),\n\t\tPADDR (complete),\n\tSCR_JUMP ^ IFTRUE (DATA (DISCONNECT)),\n\t\tPADDR (disconnect),\n\tSCR_JUMP ^ IFTRUE (DATA (SAVE_POINTERS)),\n\t\tPADDR (save_dp),\n\tSCR_JUMP ^ IFTRUE (DATA (RESTORE_POINTERS)),\n\t\tPADDR (restore_dp),\n\tSCR_JUMP ^ IFTRUE (DATA (EXTENDED_MESSAGE)),\n\t\tPADDRH (msg_extended),\n\tSCR_JUMP ^ IFTRUE (DATA (NOP)),\n\t\tPADDR (clrack),\n\tSCR_JUMP ^ IFTRUE (DATA (MESSAGE_REJECT)),\n\t\tPADDRH (msg_reject),\n\tSCR_JUMP ^ IFTRUE (DATA (IGNORE_WIDE_RESIDUE)),\n\t\tPADDRH (msg_ign_residue),\n\t \n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_REJECT_SENT,\n\tSCR_LOAD_REG (scratcha, MESSAGE_REJECT),\n\t\t0,\n} ,{\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgout),\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n} ,{\n\t \n\tSCR_FROM_REG (dsa),\n\t\t0,\n\tSCR_JUMP ^ IFTRUE (DATA (0xff)),\n\t\tPADDR (start),\n\t \n\tSCR_JUMP,\n\t\tPADDR (cleanup_ok),\n\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tNADDR (header.lastp),\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\t \n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\t \n\tSCR_WAIT_DISC,\n\t\t0,\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR (scr0),\n\t\tNADDR (header.status),\n\t \n\tSCR_COPY_F (4),\n\t\tRADDR (dsa),\n\t\tPADDR (cleanup0),\n\t \n\tPREFETCH_FLUSH\n\tSCR_COPY (sizeof (struct head)),\n\t\tNADDR (header),\n} ,{\n\t\t0,\n} ,{\n\t \n\tSCR_FROM_REG (HS_REG),\n\t\t0,\n\t \n\tSCR_JUMP ^ IFTRUE (MASK (0, (HS_DONEMASK|HS_SKIPMASK))),\n\t\tPADDR(start),\n\t \n\tSCR_FROM_REG (SS_REG),\n\t\t0,\n\tSCR_CALL ^ IFFALSE (DATA (SAM_STAT_GOOD)),\n\t\tPADDRH (bad_status),\n\n#ifndef\tSCSI_NCR_CCB_DONE_SUPPORT\n\n\t \n\tSCR_INT,\n\t\tSIR_INTFLY,\n\t \n\tSCR_JUMP,\n\t\tPADDR(start),\n\n#else\t \n\n\t \n\tSCR_JUMP,\n} ,{\n\t\tPADDRH (done_queue),\n} ,{\n\tSCR_INT,\n\t\tSIR_DONE_OVERFLOW,\n} ,{\n\tSCR_INT,\n\t\tSIR_INTFLY,\n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tPADDR (done_pos),\n\tSCR_JUMP,\n\t\tPADDR (start),\n\n#endif\t \n\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tNADDR (header.savep),\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tNADDR (header.savep),\n\t\tRADDR (temp),\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\t \n\tSCR_WAIT_DISC,\n\t\t0,\n\t \n\tSCR_LOAD_REG (HS_REG, HS_DISCONNECT),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (cleanup_ok),\n\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_OUT,\n\t\tNADDR (msgout),\n\tSCR_COPY (1),\n\t\tNADDR (msgout),\n\t\tNADDR (lastmsg),\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (ABORT_TASK_SET)),\n\t\tPADDRH (msg_out_abort),\n\t \n\tSCR_JUMP ^ IFTRUE (WHEN (SCR_MSG_OUT)),\n\t\tPADDR (msg_out),\n} ,{\n\t \n\tSCR_LOAD_REG (scratcha, NOP),\n\t\t0,\n\tSCR_COPY (4),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgout),\n\t \n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n} ,{\n\t \n\tSCR_NO_OP,\n\t\t0,\n} ,{\n\t \n\tSCR_LOAD_REG (dsa, 0xff),\n\t\t0,\n\tSCR_CLR (SCR_TRG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_IN_RESELECT),\n\t\t0,\n\t \n\tSCR_WAIT_RESEL,\n\t\tPADDR(start),\n} ,{\n\t \n\tSCR_NO_OP,\n\t\t0,\n\t \n\tSCR_REG_SFBR (ssid, SCR_AND, 0x8F),\n\t\t0,\n\tSCR_TO_REG (sdid),\n\t\t0,\n\tSCR_JUMP,\n\t\tNADDR (jump_tcb),\n\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_COPY_F (4),\n\t\tRADDR (dsa),\n\t\tPADDR (loadpos1),\n\t \n\tPREFETCH_FLUSH\n\t \n\tSCR_COPY (sizeof (struct head)),\n\t \n\n} ,{\n\t\t0,\n\t\tNADDR (header),\n\t \n\tSCR_JUMP,\n\t\tPADDR (prepare),\n\n} ,{\n\t \n\tSCR_INT ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tSIR_RESEL_NO_MSG_IN,\n\t \n\tSCR_FROM_REG (sbdl),\n\t\t0,\n\t \n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_MOVE_ABS (3) ^ SCR_MSG_IN,\n\t\tNADDR (msgin),\n\t \n\tSCR_REG_SFBR (sidl, SCR_SHL, 0),\n\t\t0,\n\tSCR_SFBR_REG (temp, SCR_AND, 0xfc),\n\t\t0,\n} ,{\n\tSCR_COPY_F (4),\n\t\tRADDR (temp),\n\t\tPADDR (nexus_indirect),\n\t \n\tPREFETCH_FLUSH\n\tSCR_COPY (4),\n} ,{\n\t\t0,\n\t\tRADDR (temp),\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin),\n\tSCR_JUMP,\n\t\tPADDR (jump_to_nexus),\n} ,{\n \n0\n} ,{\n\tSCR_CALL,\n\t\tPADDR (dispatch),\n\tSCR_JUMP,\n\t\tPADDR (no_data),\n} ,{\n \n0\n} ,{\n\tSCR_CALL,\n\t\tPADDR (dispatch),\n\tSCR_JUMP,\n\t\tPADDR (no_data),\n} \n};\n\nstatic\tstruct scripth scripth0 __initdata = {\n {\n \n0\n} ,{\n\tSCR_JUMP,\n\t\tPADDRH(tryloop),\n\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\n} ,{\n \n0\n} ,{\n\tSCR_JUMP,\n\t\tPADDRH (done_queue),\n\n#endif  \n} ,{\n\t \n\n\tSCR_CLR (SCR_TRG),\n\t\t0,\n\tSCR_LOAD_REG (HS_REG, HS_SELECTING),\n\t\t0,\n\tSCR_SEL_TBL ^ offsetof (struct dsb, select),\n\t\tPADDR (reselect),\n\tSCR_JUMP,\n\t\tPADDR (select2),\n\n} ,{\n\n\tSCR_LOAD_REG (scratcha, HS_ABORTED),\n\t\t0,\n\tSCR_JUMPR,\n\t\t8,\n} ,{\n\tSCR_LOAD_REG (scratcha, 0),\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tPADDR (startpos),\n\t \n\tSCR_COPY_F (4),\n\t\tRADDR (dsa),\n\t\tPADDRH (skip2),\n\t \n\tPREFETCH_FLUSH\n\t \n\tSCR_COPY (sizeof (struct head)),\n\t \n} ,{\n\t\t0,\n\t\tNADDR (header),\n\t \n\tSCR_COPY (4),\n\t\tNADDR (header.status),\n\t\tRADDR (scr0),\n\t \n\tSCR_FROM_REG (scratcha),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (MASK (0, HS_DONEMASK)),\n\t\t16,\n\tSCR_REG_REG (HS_REG, SCR_OR, HS_SKIPMASK),\n\t\t0,\n\tSCR_JUMPR,\n\t\t8,\n\tSCR_TO_REG (HS_REG),\n\t\t0,\n\tSCR_LOAD_REG (SS_REG, SAM_STAT_GOOD),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (cleanup_ok),\n\n}, {\n\t \n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\tPADDRH (par_err_other),\n\tSCR_MOVE_ABS (1) ^ SCR_DATA_IN,\n\t\tNADDR (scratch),\n\tSCR_JUMPR,\n\t\t-24,\n}, {\n\t \n\tSCR_REG_REG (PS_REG, SCR_ADD, 0x01),\n\t\t0,\n\t \n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n} ,{\n\t \n\tSCR_FROM_REG (HS_REG),\n\t\t0,\n\tSCR_INT ^ IFFALSE (DATA (HS_NEGOTIATE)),\n\t\tSIR_REJECT_RECEIVED,\n\tSCR_INT ^ IFTRUE (DATA (HS_NEGOTIATE)),\n\t\tSIR_NEGO_FAILED,\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[1]),\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (0)),\n\t\tPADDR (clrack),\n\t \n\tSCR_JUMPR ^ IFFALSE (DATA (1)),\n\t\t40,\n\t \n\tSCR_FROM_REG (scntl2),\n\t\t0,\n\tSCR_JUMPR ^ IFFALSE (MASK (WSR, WSR)),\n\t\t16,\n\t \n\tSCR_REG_REG (scntl2, SCR_OR, WSR),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n\t \n\tSCR_FROM_REG (scratcha),\n\t\t0,\n\tSCR_INT,\n\t\tSIR_IGN_RESIDUE,\n\tSCR_JUMP,\n\t\tPADDR (clrack),\n\n} ,{\n\t \n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[1]),\n\t \n\tSCR_JUMP ^ IFTRUE (DATA (3)),\n\t\tPADDRH (msg_ext_3),\n\tSCR_JUMP ^ IFFALSE (DATA (2)),\n\t\tPADDR (msg_bad),\n} ,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[2]),\n\tSCR_JUMP ^ IFTRUE (DATA (EXTENDED_WDTR)),\n\t\tPADDRH (msg_wdtr),\n\t \n\tSCR_JUMP,\n\t\tPADDR (msg_bad)\n} ,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[3]),\n\t \n\tSCR_INT,\n\t\tSIR_NEGO_WIDE,\n\t \n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDRH (nego_bad_phase),\n\n} ,{\n\t \n\tSCR_MOVE_ABS (4) ^ SCR_MSG_OUT,\n\t\tNADDR (msgout),\n\tSCR_COPY (1),\n\t\tNADDR (msgout),\n\t\tNADDR (lastmsg),\n\tSCR_JUMP,\n\t\tPADDR (msg_out_done),\n\n} ,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t \n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[2]),\n\tSCR_JUMP ^ IFTRUE (DATA (EXTENDED_SDTR)),\n\t\tPADDRH (msg_sdtr),\n\t \n\tSCR_JUMP,\n\t\tPADDR (msg_bad)\n\n} ,{\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\tPADDR (dispatch),\n\t \n\tSCR_MOVE_ABS (2) ^ SCR_MSG_IN,\n\t\tNADDR (msgin[3]),\n\t \n\tSCR_INT,\n\t\tSIR_NEGO_SYNC,\n\t \n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\tSCR_JUMP ^ IFFALSE (WHEN (SCR_MSG_OUT)),\n\t\tPADDRH (nego_bad_phase),\n\n} ,{\n\t \n\tSCR_MOVE_ABS (5) ^ SCR_MSG_OUT,\n\t\tNADDR (msgout),\n\tSCR_COPY (1),\n\t\tNADDR (msgout),\n\t\tNADDR (lastmsg),\n\tSCR_JUMP,\n\t\tPADDR (msg_out_done),\n\n} ,{\n\tSCR_INT,\n\t\tSIR_NEGO_PROTO,\n\tSCR_JUMP,\n\t\tPADDR (dispatch),\n\n} ,{\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\tSCR_WAIT_DISC,\n\t\t0,\n\t \n\tSCR_LOAD_REG (HS_REG, HS_ABORTED),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (cleanup),\n\n} ,{\n \n0\n} ,{\n\tSCR_JUMP,\n\t\tPADDR (data_in),\n\n} ,{\n \n0\n} ,{\n\tSCR_JUMP,\n\t\tPADDR (data_out),\n\n} ,{\n\t \n\tSCR_LOAD_REG (scratcha, ABORT_TASK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDRH (abort_resel),\n} ,{\n\t \n\tSCR_LOAD_REG (scratcha, ABORT_TASK),\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDRH (abort_resel),\n} ,{\n\t \n\tSCR_LOAD_REG (scratcha, ABORT_TASK_SET),\n\t\t0,\n} ,{\n\tSCR_COPY (1),\n\t\tRADDR (scratcha),\n\t\tNADDR (msgout),\n\tSCR_SET (SCR_ATN),\n\t\t0,\n\tSCR_CLR (SCR_ACK),\n\t\t0,\n\t \n\tSCR_REG_REG (scntl2, SCR_AND, 0x7f),\n\t\t0,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_OUT,\n\t\tNADDR (msgout),\n\tSCR_COPY (1),\n\t\tNADDR (msgout),\n\t\tNADDR (lastmsg),\n\tSCR_CLR (SCR_ACK|SCR_ATN),\n\t\t0,\n\tSCR_WAIT_DISC,\n\t\t0,\n\tSCR_JUMP,\n\t\tPADDR (start),\n} ,{\n\t \n\tSCR_SET (SCR_ATN),  \n\t\t0,          \n\tSCR_JUMP,\n\t\tPADDR (send_ident),\n} ,{\n\tSCR_CLR (SCR_ATN),\n\t\t0,\n\tSCR_JUMP,\n} ,{\n\t\t0,\n} ,{\n\tSCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN)),\n\t\tPADDR (dispatch),\n\tSCR_MOVE_TBL ^ SCR_DATA_IN,\n\t\toffsetof (struct dsb, sense),\n\tSCR_CALL,\n\t\tPADDR (dispatch),\n\tSCR_JUMP,\n\t\tPADDR (no_data),\n} ,{\n\t \n\tSCR_JUMPR ^ IFTRUE (WHEN (SCR_DATA_OUT)),\n\t\t32,\n\t \n\tSCR_COPY (4),\n\t\tNADDR (header.lastp),\n\t\tNADDR (header.savep),\n\n\t \n\tSCR_COPY (4),\n\t\tNADDR (header.savep),\n\t\tRADDR (temp),\n\tSCR_RETURN,\n\t\t0,\n\t \n\tSCR_COPY (4),\n\t\tNADDR (header.wlastp),\n\t\tNADDR (header.lastp),\n\tSCR_COPY (4),\n\t\tNADDR (header.wgoalp),\n\t\tNADDR (header.goalp),\n\tSCR_JUMPR,\n\t\t-64,\n} ,{\n\t \n\tSCR_JUMPR ^ IFTRUE (MASK (0x80, 0x80)),\n\t\t16,\n\tSCR_INT,\n\t\tSIR_RESEL_NO_IDENTIFY,\n\tSCR_JUMP,\n\t\tPADDRH (reset),\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_LUN,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin),\n\tSCR_JUMP,\n\t\tPADDRH (abort),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_I_T_L,\n\tSCR_JUMP,\n\t\tPADDRH (abort),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_I_T_L_Q,\n\tSCR_JUMP,\n\t\tPADDRH (aborttag),\n} ,{\n\t \n\tSCR_INT,\n\t\tSIR_RESEL_BAD_TARGET,\n\tSCR_JUMPR ^ IFFALSE (WHEN (SCR_MSG_IN)),\n\t\t8,\n\tSCR_MOVE_ABS (1) ^ SCR_MSG_IN,\n\t\tNADDR (msgin),\n\tSCR_JUMP,\n\t\tPADDRH (reset),\n} ,{\n\t \n\tSCR_INT ^ IFTRUE (DATA (SAM_STAT_TASK_SET_FULL)),\n\t\tSIR_BAD_STATUS,\n\tSCR_INT ^ IFTRUE (DATA (SAM_STAT_CHECK_CONDITION)),\n\t\tSIR_BAD_STATUS,\n\tSCR_INT ^ IFTRUE (DATA (SAM_STAT_COMMAND_TERMINATED)),\n\t\tSIR_BAD_STATUS,\n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_COPY_F (4),\n\t\tRADDR (scratcha),\n\t\tPADDRH (start_ram0),\n\t \n\tPREFETCH_FLUSH\n\tSCR_COPY (sizeof (struct script)),\n} ,{\n\t\t0,\n\t\tPADDR (start),\n\tSCR_JUMP,\n\t\tPADDR (start),\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tPADDR (startpos),\n\tSCR_JUMP,\n\t\tPADDR (start),\n} ,{\n\t \n\tSCR_RETURN,\n\t\t0,\n} ,{\n\t \n\tSCR_COPY (4),\n\t\tNADDR(ncr_cache),\n\t\tRADDR (scratcha),\n\t \n\tSCR_COPY (4),\n\t\tRADDR (temp),\n\t\tNADDR(ncr_cache),\n\t \n\tSCR_COPY (4),\n\t\tNADDR(ncr_cache),\n\t\tRADDR (temp),\n} ,{\n\t \n\tSCR_INT,\n\t\t99,\n} \n};\n\n \n\nvoid __init ncr_script_fill (struct script * scr, struct scripth * scrh)\n{\n\tint\ti;\n\tncrcmd\t*p;\n\n\tp = scrh->tryloop;\n\tfor (i=0; i<MAX_START; i++) {\n\t\t*p++ =SCR_CALL;\n\t\t*p++ =PADDR (idle);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scrh->tryloop + sizeof (scrh->tryloop));\n\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\n\tp = scrh->done_queue;\n\tfor (i = 0; i<MAX_DONE; i++) {\n\t\t*p++ =SCR_COPY (sizeof(struct ccb *));\n\t\t*p++ =NADDR (header.cp);\n\t\t*p++ =NADDR (ccb_done[i]);\n\t\t*p++ =SCR_CALL;\n\t\t*p++ =PADDR (done_end);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scrh->done_queue+sizeof(scrh->done_queue));\n\n#endif  \n\n\tp = scrh->hdata_in;\n\tfor (i=0; i<MAX_SCATTERH; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scrh->hdata_in + sizeof (scrh->hdata_in));\n\n\tp = scr->data_in;\n\tfor (i=MAX_SCATTERH; i<MAX_SCATTERH+MAX_SCATTERL; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_IN));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_IN;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scr->data_in + sizeof (scr->data_in));\n\n\tp = scrh->hdata_out;\n\tfor (i=0; i<MAX_SCATTERH; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t}\n\n\tBUG_ON((u_long)p != (u_long)&scrh->hdata_out + sizeof (scrh->hdata_out));\n\n\tp = scr->data_out;\n\tfor (i=MAX_SCATTERH; i<MAX_SCATTERH+MAX_SCATTERL; i++) {\n\t\t*p++ =SCR_CALL ^ IFFALSE (WHEN (SCR_DATA_OUT));\n\t\t*p++ =PADDR (dispatch);\n\t\t*p++ =SCR_MOVE_TBL ^ SCR_DATA_OUT;\n\t\t*p++ =offsetof (struct dsb, data[i]);\n\t}\n\n\tBUG_ON((u_long) p != (u_long)&scr->data_out + sizeof (scr->data_out));\n}\n\n \n\nstatic void __init \nncr_script_copy_and_bind (struct ncb *np, ncrcmd *src, ncrcmd *dst, int len)\n{\n\tncrcmd  opcode, new, old, tmp1, tmp2;\n\tncrcmd\t*start, *end;\n\tint relocs;\n\tint opchanged = 0;\n\n\tstart = src;\n\tend = src + len/4;\n\n\twhile (src < end) {\n\n\t\topcode = *src++;\n\t\t*dst++ = cpu_to_scr(opcode);\n\n\t\t \n\n\t\tif (opcode == 0) {\n\t\t\tprintk (KERN_ERR \"%s: ERROR0 IN SCRIPT at %d.\\n\",\n\t\t\t\tncr_name(np), (int) (src-start-1));\n\t\t\tmdelay(1000);\n\t\t}\n\n\t\tif (DEBUG_FLAGS & DEBUG_SCRIPT)\n\t\t\tprintk (KERN_DEBUG \"%p:  <%x>\\n\",\n\t\t\t\t(src-1), (unsigned)opcode);\n\n\t\t \n\t\tswitch (opcode >> 28) {\n\n\t\tcase 0xc:\n\t\t\t \n\t\t\trelocs = 2;\n\t\t\ttmp1 = src[0];\n#ifdef\tRELOC_KVAR\n\t\t\tif ((tmp1 & RELOC_MASK) == RELOC_KVAR)\n\t\t\t\ttmp1 = 0;\n#endif\n\t\t\ttmp2 = src[1];\n#ifdef\tRELOC_KVAR\n\t\t\tif ((tmp2 & RELOC_MASK) == RELOC_KVAR)\n\t\t\t\ttmp2 = 0;\n#endif\n\t\t\tif ((tmp1 ^ tmp2) & 3) {\n\t\t\t\tprintk (KERN_ERR\"%s: ERROR1 IN SCRIPT at %d.\\n\",\n\t\t\t\t\tncr_name(np), (int) (src-start-1));\n\t\t\t\tmdelay(1000);\n\t\t\t}\n\t\t\t \n\t\t\tif ((opcode & SCR_NO_FLUSH) && !(np->features & FE_PFEN)) {\n\t\t\t\tdst[-1] = cpu_to_scr(opcode & ~SCR_NO_FLUSH);\n\t\t\t\t++opchanged;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x0:\n\t\t\t \n\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tcase 0x8:\n\t\t\t \n\t\t\tif (opcode & 0x00800000)\n\t\t\t\trelocs = 0;\n\t\t\telse\n\t\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tcase 0x4:\n\t\tcase 0x5:\n\t\tcase 0x6:\n\t\tcase 0x7:\n\t\t\trelocs = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trelocs = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (relocs) {\n\t\t\twhile (relocs--) {\n\t\t\t\told = *src++;\n\n\t\t\t\tswitch (old & RELOC_MASK) {\n\t\t\t\tcase RELOC_REGISTER:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->paddr;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_LABEL:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_script;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_LABELH:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_scripth;\n\t\t\t\t\tbreak;\n\t\t\t\tcase RELOC_SOFTC:\n\t\t\t\t\tnew = (old & ~RELOC_MASK) + np->p_ncb;\n\t\t\t\t\tbreak;\n#ifdef\tRELOC_KVAR\n\t\t\t\tcase RELOC_KVAR:\n\t\t\t\t\tif (((old & ~RELOC_MASK) <\n\t\t\t\t\t     SCRIPT_KVAR_FIRST) ||\n\t\t\t\t\t    ((old & ~RELOC_MASK) >\n\t\t\t\t\t     SCRIPT_KVAR_LAST))\n\t\t\t\t\t\tpanic(\"ncr KVAR out of range\");\n\t\t\t\t\tnew = vtophys(script_kvars[old &\n\t\t\t\t\t    ~RELOC_MASK]);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 0:\n\t\t\t\t\t \n\t\t\t\t\tif (old == 0) {\n\t\t\t\t\t\tnew = old;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfallthrough;\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(\"ncr_script_copy_and_bind: weird relocation %x\\n\", old);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t*dst++ = cpu_to_scr(new);\n\t\t\t}\n\t\t} else\n\t\t\t*dst++ = cpu_to_scr(*src++);\n\n\t}\n}\n\n \n\nstruct host_data {\n     struct ncb *ncb;\n};\n\n#define PRINT_ADDR(cmd, arg...) dev_info(&cmd->device->sdev_gendev , ## arg)\n\nstatic void ncr_print_msg(struct ccb *cp, char *label, u_char *msg)\n{\n\tPRINT_ADDR(cp->cmd, \"%s: \", label);\n\n\tspi_print_msg(msg);\n\tprintk(\"\\n\");\n}\n\n \n\n#define _5M 5000000\nstatic u_long div_10M[] =\n\t{2*_5M, 3*_5M, 4*_5M, 6*_5M, 8*_5M, 12*_5M, 16*_5M};\n\n\n \n\n \n#define burst_length(bc) (!(bc))? 0 : 1 << (bc)\n\n \n#define burst_code(dmode, ctest0) \\\n\t(ctest0) & 0x80 ? 0 : (((dmode) & 0xc0) >> 6) + 1\n\n \nstatic inline void ncr_init_burst(struct ncb *np, u_char bc)\n{\n\tu_char *be = &np->rv_ctest0;\n\t*be\t\t&= ~0x80;\n\tnp->rv_dmode\t&= ~(0x3 << 6);\n\tnp->rv_ctest5\t&= ~0x4;\n\n\tif (!bc) {\n\t\t*be\t\t|= 0x80;\n\t} else {\n\t\t--bc;\n\t\tnp->rv_dmode\t|= ((bc & 0x3) << 6);\n\t\tnp->rv_ctest5\t|= (bc & 0x4);\n\t}\n}\n\nstatic void __init ncr_prepare_setting(struct ncb *np)\n{\n\tu_char\tburst_max;\n\tu_long\tperiod;\n\tint i;\n\n\t \n\n\tnp->sv_scntl0\t= INB(nc_scntl0) & 0x0a;\n\tnp->sv_scntl3\t= INB(nc_scntl3) & 0x07;\n\tnp->sv_dmode\t= INB(nc_dmode)  & 0xce;\n\tnp->sv_dcntl\t= INB(nc_dcntl)  & 0xa8;\n\tnp->sv_ctest0\t= INB(nc_ctest0) & 0x84;\n\tnp->sv_ctest3\t= INB(nc_ctest3) & 0x01;\n\tnp->sv_ctest4\t= INB(nc_ctest4) & 0x80;\n\tnp->sv_ctest5\t= INB(nc_ctest5) & 0x24;\n\tnp->sv_gpcntl\t= INB(nc_gpcntl);\n\tnp->sv_stest2\t= INB(nc_stest2) & 0x20;\n\tnp->sv_stest4\t= INB(nc_stest4);\n\n\t \n\n\tnp->maxwide\t= (np->features & FE_WIDE)? 1 : 0;\n\n \t \n\tif (np->features & FE_ULTRA)\n\t\tnp->clock_khz = 80000;\n\telse\n\t\tnp->clock_khz = 40000;\n\n\t \n\tif\t(np->features & FE_QUAD)\n\t\tnp->multiplier\t= 4;\n\telse if\t(np->features & FE_DBLR)\n\t\tnp->multiplier\t= 2;\n\telse\n\t\tnp->multiplier\t= 1;\n\n\t \n\tif (np->features & FE_VARCLK)\n\t\tncr_getclock(np, np->multiplier);\n\n\t \n\ti = np->clock_divn - 1;\n\twhile (--i >= 0) {\n\t\tif (10ul * SCSI_NCR_MIN_ASYNC * np->clock_khz > div_10M[i]) {\n\t\t\t++i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tnp->rv_scntl3 = i+1;\n\n\t \n\n\tperiod = (4 * div_10M[0] + np->clock_khz - 1) / np->clock_khz;\n\tif\t(period <= 250)\t\tnp->minsync = 10;\n\telse if\t(period <= 303)\t\tnp->minsync = 11;\n\telse if\t(period <= 500)\t\tnp->minsync = 12;\n\telse\t\t\t\tnp->minsync = (period + 40 - 1) / 40;\n\n\t \n\n\tif\t(np->minsync < 25 && !(np->features & FE_ULTRA))\n\t\tnp->minsync = 25;\n\n\t \n\n\tperiod = (11 * div_10M[np->clock_divn - 1]) / (4 * np->clock_khz);\n\tnp->maxsync = period > 2540 ? 254 : period / 10;\n\n\t \n#if defined SCSI_NCR_TRUST_BIOS_SETTING\n\tnp->rv_scntl0\t= np->sv_scntl0;\n\tnp->rv_dmode\t= np->sv_dmode;\n\tnp->rv_dcntl\t= np->sv_dcntl;\n\tnp->rv_ctest0\t= np->sv_ctest0;\n\tnp->rv_ctest3\t= np->sv_ctest3;\n\tnp->rv_ctest4\t= np->sv_ctest4;\n\tnp->rv_ctest5\t= np->sv_ctest5;\n\tburst_max\t= burst_code(np->sv_dmode, np->sv_ctest0);\n#else\n\n\t \n\tburst_max\t= driver_setup.burst_max;\n\tif (burst_max == 255)\n\t\tburst_max = burst_code(np->sv_dmode, np->sv_ctest0);\n\tif (burst_max > 7)\n\t\tburst_max = 7;\n\tif (burst_max > np->maxburst)\n\t\tburst_max = np->maxburst;\n\n\t \n\tif (np->features & FE_ERL)\n\t\tnp->rv_dmode\t|= ERL;\t\t \n\tif (np->features & FE_BOF)\n\t\tnp->rv_dmode\t|= BOF;\t\t \n\tif (np->features & FE_ERMP)\n\t\tnp->rv_dmode\t|= ERMP;\t \n\tif (np->features & FE_PFEN)\n\t\tnp->rv_dcntl\t|= PFEN;\t \n\tif (np->features & FE_CLSE)\n\t\tnp->rv_dcntl\t|= CLSE;\t \n\tif (np->features & FE_WRIE)\n\t\tnp->rv_ctest3\t|= WRIE;\t \n\tif (np->features & FE_DFS)\n\t\tnp->rv_ctest5\t|= DFS;\t\t \n\tif (np->features & FE_MUX)\n\t\tnp->rv_ctest4\t|= MUX;\t\t \n\tif (np->features & FE_EA)\n\t\tnp->rv_dcntl\t|= EA;\t\t \n\tif (np->features & FE_EHP)\n\t\tnp->rv_ctest0\t|= EHP;\t\t \n\n\t \n\tif (driver_setup.master_parity)\n\t\tnp->rv_ctest4\t|= MPEE;\t \n\tif (driver_setup.scsi_parity)\n\t\tnp->rv_scntl0\t|= 0x0a;\t \n\n\t \n\tif (np->myaddr == 255) {\n\t\tnp->myaddr = INB(nc_scid) & 0x07;\n\t\tif (!np->myaddr)\n\t\t\tnp->myaddr = SCSI_NCR_MYADDR;\n\t}\n\n#endif  \n\n\t \n\tncr_init_burst(np, burst_max);\n\n\t \n\tnp->scsi_mode = SMODE_SE;\n\tif (np->features & FE_DIFF) {\n\t\tswitch(driver_setup.diff_support) {\n\t\tcase 4:\t \n\t\t\tif (np->sv_scntl3) {\n\t\t\t\tif (np->sv_stest2 & 0x20)\n\t\t\t\t\tnp->scsi_mode = SMODE_HVD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 3:\t \n\t\t\tif (INB(nc_gpreg) & 0x08)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase 2:\t \n\t\t\tnp->scsi_mode = SMODE_HVD;\n\t\t\tfallthrough;\n\t\tcase 1:\t \n\t\t\tif (np->sv_stest2 & 0x20)\n\t\t\t\tnp->scsi_mode = SMODE_HVD;\n\t\t\tbreak;\n\t\tdefault: \t\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (np->scsi_mode == SMODE_HVD)\n\t\tnp->rv_stest2 |= 0x20;\n\n\t \n\tif ((driver_setup.led_pin) &&\n\t    !(np->features & FE_LEDC) && !(np->sv_gpcntl & 0x01))\n\t\tnp->features |= FE_LED0;\n\n\t \n\tswitch(driver_setup.irqm & 3) {\n\tcase 2:\n\t\tnp->rv_dcntl\t|= IRQM;\n\t\tbreak;\n\tcase 1:\n\t\tnp->rv_dcntl\t|= (np->sv_dcntl & IRQM);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0 ; i < MAX_TARGET ; i++) {\n\t\tstruct tcb *tp = &np->target[i];\n\n\t\ttp->usrsync = driver_setup.default_sync;\n\t\ttp->usrwide = driver_setup.max_wide;\n\t\ttp->usrtags = MAX_TAGS;\n\t\ttp->period = 0xffff;\n\t\tif (!driver_setup.disconnection)\n\t\t\tnp->target[i].usrflag = UF_NODISC;\n\t}\n\n\t \n\n\tprintk(KERN_INFO \"%s: ID %d, Fast-%d%s%s\\n\", ncr_name(np),\n\t\tnp->myaddr,\n\t\tnp->minsync < 12 ? 40 : (np->minsync < 25 ? 20 : 10),\n\t\t(np->rv_scntl0 & 0xa)\t? \", Parity Checking\"\t: \", NO Parity\",\n\t\t(np->rv_stest2 & 0x20)\t? \", Differential\"\t: \"\");\n\n\tif (bootverbose > 1) {\n\t\tprintk (KERN_INFO \"%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = \"\n\t\t\t\"(hex) %02x/%02x/%02x/%02x/%02x/%02x\\n\",\n\t\t\tncr_name(np), np->sv_scntl3, np->sv_dmode, np->sv_dcntl,\n\t\t\tnp->sv_ctest3, np->sv_ctest4, np->sv_ctest5);\n\n\t\tprintk (KERN_INFO \"%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = \"\n\t\t\t\"(hex) %02x/%02x/%02x/%02x/%02x/%02x\\n\",\n\t\t\tncr_name(np), np->rv_scntl3, np->rv_dmode, np->rv_dcntl,\n\t\t\tnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\n\t}\n\n\tif (bootverbose && np->paddr2)\n\t\tprintk (KERN_INFO \"%s: on-chip RAM at 0x%lx\\n\",\n\t\t\tncr_name(np), np->paddr2);\n}\n\n \nstatic inline void ncr_queue_done_cmd(struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tunmap_scsi_data(np, cmd);\n\tcmd->host_scribble = (char *) np->done_list;\n\tnp->done_list = cmd;\n}\n\nstatic inline void ncr_flush_done_cmds(struct scsi_cmnd *lcmd)\n{\n\tstruct scsi_cmnd *cmd;\n\n\twhile (lcmd) {\n\t\tcmd = lcmd;\n\t\tlcmd = (struct scsi_cmnd *) cmd->host_scribble;\n\t\tscsi_done(cmd);\n\t}\n}\n\n \n\n\nstatic int ncr_prepare_nego(struct ncb *np, struct ccb *cp, u_char *msgptr)\n{\n\tstruct tcb *tp = &np->target[cp->target];\n\tint msglen = 0;\n\tint nego = 0;\n\tstruct scsi_target *starget = tp->starget;\n\n\t \n\tif (!tp->widedone) {\n\t\tif (spi_support_wide(starget)) {\n\t\t\tnego = NS_WIDE;\n\t\t} else\n\t\t\ttp->widedone=1;\n\t}\n\n\t \n\tif (!nego && !tp->period) {\n\t\tif (spi_support_sync(starget)) {\n\t\t\tnego = NS_SYNC;\n\t\t} else {\n\t\t\ttp->period  =0xffff;\n\t\t\tdev_info(&starget->dev, \"target did not report SYNC.\\n\");\n\t\t}\n\t}\n\n\tswitch (nego) {\n\tcase NS_SYNC:\n\t\tmsglen += spi_populate_sync_msg(msgptr + msglen,\n\t\t\t\ttp->maxoffs ? tp->minsync : 0, tp->maxoffs);\n\t\tbreak;\n\tcase NS_WIDE:\n\t\tmsglen += spi_populate_width_msg(msgptr + msglen, tp->usrwide);\n\t\tbreak;\n\t}\n\n\tcp->nego_status = nego;\n\n\tif (nego) {\n\t\ttp->nego_cp = cp;\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, nego == NS_WIDE ?\n\t\t\t\t\t  \"wide msgout\":\"sync_msgout\", msgptr);\n\t\t}\n\t}\n\n\treturn msglen;\n}\n\n\n\n \nstatic int ncr_queue_command (struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_device *sdev = cmd->device;\n\tstruct tcb *tp = &np->target[sdev->id];\n\tstruct lcb *lp = tp->lp[sdev->lun];\n\tstruct ccb *cp;\n\n\tint\tsegments;\n\tu_char\tidmsg, *msgptr;\n\tu32\tmsglen;\n\tint\tdirection;\n\tu32\tlastp, goalp;\n\n\t \n\tif ((sdev->id == np->myaddr\t  ) ||\n\t\t(sdev->id >= MAX_TARGET) ||\n\t\t(sdev->lun    >= MAX_LUN   )) {\n\t\treturn(DID_BAD_TARGET);\n\t}\n\n\t \n\tif ((cmd->cmnd[0] == 0 || cmd->cmnd[0] == 0x12) && \n\t    (tp->usrflag & UF_NOSCAN)) {\n\t\ttp->usrflag &= ~UF_NOSCAN;\n\t\treturn DID_BAD_TARGET;\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) {\n\t\tPRINT_ADDR(cmd, \"CMD=%x \", cmd->cmnd[0]);\n\t}\n\n\t \n\tif (np->settle_time && scsi_cmd_to_rq(cmd)->timeout >= HZ) {\n\t\tu_long tlimit = jiffies + scsi_cmd_to_rq(cmd)->timeout - HZ;\n\t\tif (time_after(np->settle_time, tlimit))\n\t\t\tnp->settle_time = tlimit;\n\t}\n\n\tif (np->settle_time || !(cp=ncr_get_ccb (np, cmd))) {\n\t\tinsert_into_waiting_list(np, cmd);\n\t\treturn(DID_OK);\n\t}\n\tcp->cmd = cmd;\n\n\t \n\n\tidmsg = IDENTIFY(0, sdev->lun);\n\n\tif (cp ->tag != NO_TAG ||\n\t\t(cp != np->ccb && np->disc && !(tp->usrflag & UF_NODISC)))\n\t\tidmsg |= 0x40;\n\n\tmsgptr = cp->scsi_smsg;\n\tmsglen = 0;\n\tmsgptr[msglen++] = idmsg;\n\n\tif (cp->tag != NO_TAG) {\n\t\tchar order = np->order;\n\n\t\t \n\t\tif (lp && time_after(jiffies, lp->tags_stime)) {\n\t\t\tif (lp->tags_smap) {\n\t\t\t\torder = ORDERED_QUEUE_TAG;\n\t\t\t\tif ((DEBUG_FLAGS & DEBUG_TAGS)||bootverbose>2){ \n\t\t\t\t\tPRINT_ADDR(cmd,\n\t\t\t\t\t\t\"ordered tag forced.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tlp->tags_stime = jiffies + 3*HZ;\n\t\t\tlp->tags_smap = lp->tags_umap;\n\t\t}\n\n\t\tif (order == 0) {\n\t\t\t \n\t\t\tswitch (cmd->cmnd[0]) {\n\t\t\tcase 0x08:   \n\t\t\tcase 0x28:   \n\t\t\tcase 0xa8:   \n\t\t\t\torder = SIMPLE_QUEUE_TAG;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\torder = ORDERED_QUEUE_TAG;\n\t\t\t}\n\t\t}\n\t\tmsgptr[msglen++] = order;\n\t\t \n\t\tmsgptr[msglen++] = (cp->tag << 1) + 1;\n\t}\n\n\t \n\n\tdirection = cmd->sc_data_direction;\n\tif (direction != DMA_NONE) {\n\t\tsegments = ncr_scatter(np, cp, cp->cmd);\n\t\tif (segments < 0) {\n\t\t\tncr_free_ccb(np, cp);\n\t\t\treturn(DID_ERROR);\n\t\t}\n\t}\n\telse {\n\t\tcp->data_len = 0;\n\t\tsegments = 0;\n\t}\n\n\t \n\n\tcp->nego_status = 0;\n\n\tif ((!tp->widedone || !tp->period) && !tp->nego_cp && lp) {\n\t\tmsglen += ncr_prepare_nego (np, cp, msgptr + msglen);\n\t}\n\n\t \n\tif (!cp->data_len)\n\t\tdirection = DMA_NONE;\n\n\t \n\tswitch(direction) {\n\tcase DMA_BIDIRECTIONAL:\n\tcase DMA_TO_DEVICE:\n\t\tgoalp = NCB_SCRIPT_PHYS (np, data_out2) + 8;\n\t\tif (segments <= MAX_SCATTERL)\n\t\t\tlastp = goalp - 8 - (segments * 16);\n\t\telse {\n\t\t\tlastp = NCB_SCRIPTH_PHYS (np, hdata_out2);\n\t\t\tlastp -= (segments - MAX_SCATTERL) * 16;\n\t\t}\n\t\tif (direction != DMA_BIDIRECTIONAL)\n\t\t\tbreak;\n\t\tcp->phys.header.wgoalp\t= cpu_to_scr(goalp);\n\t\tcp->phys.header.wlastp\t= cpu_to_scr(lastp);\n\t\tfallthrough;\n\tcase DMA_FROM_DEVICE:\n\t\tgoalp = NCB_SCRIPT_PHYS (np, data_in2) + 8;\n\t\tif (segments <= MAX_SCATTERL)\n\t\t\tlastp = goalp - 8 - (segments * 16);\n\t\telse {\n\t\t\tlastp = NCB_SCRIPTH_PHYS (np, hdata_in2);\n\t\t\tlastp -= (segments - MAX_SCATTERL) * 16;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase DMA_NONE:\n\t\tlastp = goalp = NCB_SCRIPT_PHYS (np, no_data);\n\t\tbreak;\n\t}\n\n\t \n\tcp->phys.header.lastp = cpu_to_scr(lastp);\n\tcp->phys.header.goalp = cpu_to_scr(goalp);\n\n\tif (direction == DMA_BIDIRECTIONAL)\n\t\tcp->phys.header.savep = \n\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, data_io));\n\telse\n\t\tcp->phys.header.savep= cpu_to_scr(lastp);\n\n\t \n\tcp->startp = cp->phys.header.savep;\n\n\t \n\n\t \n\tcp->start.schedule.l_paddr   = cpu_to_scr(NCB_SCRIPT_PHYS (np, select));\n\tcp->restart.schedule.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_dsa));\n\t \n\tcp->phys.select.sel_id\t\t= sdev_id(sdev);\n\tcp->phys.select.sel_scntl3\t= tp->wval;\n\tcp->phys.select.sel_sxfer\t= tp->sval;\n\t \n\tcp->phys.smsg.addr\t\t= cpu_to_scr(CCB_PHYS (cp, scsi_smsg));\n\tcp->phys.smsg.size\t\t= cpu_to_scr(msglen);\n\n\t \n\tmemcpy(cp->cdb_buf, cmd->cmnd, min_t(int, cmd->cmd_len, sizeof(cp->cdb_buf)));\n\tcp->phys.cmd.addr\t\t= cpu_to_scr(CCB_PHYS (cp, cdb_buf[0]));\n\tcp->phys.cmd.size\t\t= cpu_to_scr(cmd->cmd_len);\n\n\t \n\tcp->actualquirks\t\t= 0;\n\tcp->host_status\t\t\t= cp->nego_status ? HS_NEGOTIATE : HS_BUSY;\n\tcp->scsi_status\t\t\t= SAM_STAT_ILLEGAL;\n\tcp->parity_status\t\t= 0;\n\n\tcp->xerr_status\t\t\t= XE_OK;\n\n\t \n\n\t \n\tcp->magic\t\t= CCB_MAGIC;\n\n\t \n\tcp->auto_sense = 0;\n\tif (lp)\n\t\tncr_start_next_ccb(np, lp, 2);\n\telse\n\t\tncr_put_start_queue(np, cp);\n\n\t \n\n\treturn DID_OK;\n}\n\n\n \n\nstatic void ncr_start_next_ccb(struct ncb *np, struct lcb *lp, int maxn)\n{\n\tstruct list_head *qp;\n\tstruct ccb *cp;\n\n\tif (lp->held_ccb)\n\t\treturn;\n\n\twhile (maxn-- && lp->queuedccbs < lp->queuedepth) {\n\t\tqp = ncr_list_pop(&lp->wait_ccbq);\n\t\tif (!qp)\n\t\t\tbreak;\n\t\t++lp->queuedccbs;\n\t\tcp = list_entry(qp, struct ccb, link_ccbq);\n\t\tlist_add_tail(qp, &lp->busy_ccbq);\n\t\tlp->jump_ccb[cp->tag == NO_TAG ? 0 : cp->tag] =\n\t\t\tcpu_to_scr(CCB_PHYS (cp, restart));\n\t\tncr_put_start_queue(np, cp);\n\t}\n}\n\nstatic void ncr_put_start_queue(struct ncb *np, struct ccb *cp)\n{\n\tu16\tqidx;\n\n\t \n\tif (!np->squeueput) np->squeueput = 1;\n\tqidx = np->squeueput + 2;\n\tif (qidx >= MAX_START + MAX_START) qidx = 1;\n\n\tnp->scripth->tryloop [qidx] = cpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\n\tMEMORY_BARRIER();\n\tnp->scripth->tryloop [np->squeueput] = cpu_to_scr(CCB_PHYS (cp, start));\n\n\tnp->squeueput = qidx;\n\t++np->queuedccbs;\n\tcp->queued = 1;\n\n\tif (DEBUG_FLAGS & DEBUG_QUEUE)\n\t\tprintk (\"%s: queuepos=%d.\\n\", ncr_name (np), np->squeueput);\n\n\t \n\tMEMORY_BARRIER();\n\tOUTB (nc_istat, SIGP);\n}\n\n\nstatic int ncr_reset_scsi_bus(struct ncb *np, int enab_int, int settle_delay)\n{\n\tu32 term;\n\tint retv = 0;\n\n\tnp->settle_time\t= jiffies + settle_delay * HZ;\n\n\tif (bootverbose > 1)\n\t\tprintk(\"%s: resetting, \"\n\t\t\t\"command processing suspended for %d seconds\\n\",\n\t\t\tncr_name(np), settle_delay);\n\n\tncr_chip_reset(np, 100);\n\tudelay(2000);\t \n\tif (enab_int)\n\t\tOUTW (nc_sien, RST);\n\t \n\tOUTB (nc_stest3, TE);\n\tOUTB (nc_scntl1, CRST);\n\tudelay(200);\n\n\tif (!driver_setup.bus_check)\n\t\tgoto out;\n\t \n\n\tterm =\tINB(nc_sstat0);\n\tterm =\t((term & 2) << 7) + ((term & 1) << 17);\t \n\tterm |= ((INB(nc_sstat2) & 0x01) << 26) |\t \n\t\t((INW(nc_sbdl) & 0xff)   << 9)  |\t \n\t\t((INW(nc_sbdl) & 0xff00) << 10) |\t \n\t\tINB(nc_sbcl);\t \n\n\tif (!(np->features & FE_WIDE))\n\t\tterm &= 0x3ffff;\n\n\tif (term != (2<<7)) {\n\t\tprintk(\"%s: suspicious SCSI data while resetting the BUS.\\n\",\n\t\t\tncr_name(np));\n\t\tprintk(\"%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = \"\n\t\t\t\"0x%lx, expecting 0x%lx\\n\",\n\t\t\tncr_name(np),\n\t\t\t(np->features & FE_WIDE) ? \"dp1,d15-8,\" : \"\",\n\t\t\t(u_long)term, (u_long)(2<<7));\n\t\tif (driver_setup.bus_check == 1)\n\t\t\tretv = 1;\n\t}\nout:\n\tOUTB (nc_scntl1, 0);\n\treturn retv;\n}\n\n \nstatic void ncr_start_reset(struct ncb *np)\n{\n\tif (!np->settle_time) {\n\t\tncr_reset_scsi_bus(np, 1, driver_setup.settle_delay);\n \t}\n}\n \n \nstatic int ncr_reset_bus (struct ncb *np)\n{\n \n\tif (np->settle_time) {\n\t\treturn FAILED;\n\t}\n \n\tncr_start_reset(np);\n \n\treset_waiting_list(np);\n \n\tncr_wakeup(np, HS_RESET);\n\n\treturn SUCCESS;\n}\n\nstatic void ncr_detach(struct ncb *np)\n{\n\tstruct ccb *cp;\n\tstruct tcb *tp;\n\tstruct lcb *lp;\n\tint target, lun;\n\tint i;\n\tchar inst_name[16];\n\n\t \n\tstrscpy(inst_name, ncr_name(np), sizeof(inst_name));\n\n\tprintk(\"%s: releasing host resources\\n\", ncr_name(np));\n\n \n\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"%s: stopping the timer\\n\", ncr_name(np));\n#endif\n\tnp->release_stage = 1;\n\tfor (i = 50 ; i && np->release_stage != 2 ; i--)\n\t\tmdelay(100);\n\tif (np->release_stage != 2)\n\t\tprintk(\"%s: the timer seems to be already stopped\\n\", ncr_name(np));\n\telse np->release_stage = 2;\n\n \n\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"%s: disabling chip interrupts\\n\", ncr_name(np));\n#endif\n\tOUTW (nc_sien , 0);\n\tOUTB (nc_dien , 0);\n\n\t \n\n\tprintk(\"%s: resetting chip\\n\", ncr_name(np));\n\tncr_chip_reset(np, 100);\n\n\tOUTB(nc_dmode,\tnp->sv_dmode);\n\tOUTB(nc_dcntl,\tnp->sv_dcntl);\n\tOUTB(nc_ctest0,\tnp->sv_ctest0);\n\tOUTB(nc_ctest3,\tnp->sv_ctest3);\n\tOUTB(nc_ctest4,\tnp->sv_ctest4);\n\tOUTB(nc_ctest5,\tnp->sv_ctest5);\n\tOUTB(nc_gpcntl,\tnp->sv_gpcntl);\n\tOUTB(nc_stest2,\tnp->sv_stest2);\n\n\tncr_selectclock(np, np->sv_scntl3);\n\n\t \n\n\twhile ((cp=np->ccb->link_ccb) != NULL) {\n\t\tnp->ccb->link_ccb = cp->link_ccb;\n\t\tif (cp->host_status) {\n\t\tprintk(\"%s: shall free an active ccb (host_status=%d)\\n\",\n\t\t\tncr_name(np), cp->host_status);\n\t\t}\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"%s: freeing ccb (%lx)\\n\", ncr_name(np), (u_long) cp);\n#endif\n\t\tm_free_dma(cp, sizeof(*cp), \"CCB\");\n\t}\n\n\t \n\n\tfor (target = 0; target < MAX_TARGET ; target++) {\n\t\ttp=&np->target[target];\n\t\tfor (lun = 0 ; lun < MAX_LUN ; lun++) {\n\t\t\tlp = tp->lp[lun];\n\t\t\tif (lp) {\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"%s: freeing lp (%lx)\\n\", ncr_name(np), (u_long) lp);\n#endif\n\t\t\t\tif (lp->jump_ccb != &lp->jump_ccb_0)\n\t\t\t\t\tm_free_dma(lp->jump_ccb,256,\"JUMP_CCB\");\n\t\t\t\tm_free_dma(lp, sizeof(*lp), \"LCB\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (np->scripth0)\n\t\tm_free_dma(np->scripth0, sizeof(struct scripth), \"SCRIPTH\");\n\tif (np->script0)\n\t\tm_free_dma(np->script0, sizeof(struct script), \"SCRIPT\");\n\tif (np->ccb)\n\t\tm_free_dma(np->ccb, sizeof(struct ccb), \"CCB\");\n\tm_free_dma(np, sizeof(struct ncb), \"NCB\");\n\n\tprintk(\"%s: host resources successfully released\\n\", inst_name);\n}\n\n \n\nvoid ncr_complete (struct ncb *np, struct ccb *cp)\n{\n\tstruct scsi_cmnd *cmd;\n\tstruct tcb *tp;\n\tstruct lcb *lp;\n\n\t \n\n\tif (!cp || cp->magic != CCB_MAGIC || !cp->cmd)\n\t\treturn;\n\n\t \n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintk (\"CCB=%lx STAT=%x/%x\\n\", (unsigned long)cp,\n\t\t\tcp->host_status,cp->scsi_status);\n\n\t \n\n\tcmd = cp->cmd;\n\tcp->cmd = NULL;\n\ttp = &np->target[cmd->device->id];\n\tlp = tp->lp[cmd->device->lun];\n\n\t \n\n\tif (cp == tp->nego_cp)\n\t\ttp->nego_cp = NULL;\n\n\t \n\tif (cp->auto_sense) {\n\t\tcp->scsi_status = cp->auto_sense;\n\t}\n\n\t \n\n\tif (lp && lp->held_ccb) {\n\t\tif (cp == lp->held_ccb) {\n\t\t\tlist_splice_init(&lp->skip_ccbq, &lp->wait_ccbq);\n\t\t\tlp->held_ccb = NULL;\n\t\t}\n\t}\n\n\t \n\n\tif (cp->parity_status > 1) {\n\t\tPRINT_ADDR(cmd, \"%d parity error(s).\\n\",cp->parity_status);\n\t}\n\n\t \n\n\tif (cp->xerr_status != XE_OK) {\n\t\tswitch (cp->xerr_status) {\n\t\tcase XE_EXTRA_DATA:\n\t\t\tPRINT_ADDR(cmd, \"extraneous data discarded.\\n\");\n\t\t\tbreak;\n\t\tcase XE_BAD_PHASE:\n\t\t\tPRINT_ADDR(cmd, \"invalid scsi phase (4/5).\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINT_ADDR(cmd, \"extended error %d.\\n\",\n\t\t\t\t\tcp->xerr_status);\n\t\t\tbreak;\n\t\t}\n\t\tif (cp->host_status==HS_COMPLETE)\n\t\t\tcp->host_status = HS_FAIL;\n\t}\n\n\t \n\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\tif (cp->host_status != HS_COMPLETE ||\n\t\t    cp->scsi_status != SAM_STAT_GOOD) {\n\t\t\tPRINT_ADDR(cmd, \"ERROR: cmd=%x host_status=%x \"\n\t\t\t\t\t\"scsi_status=%x\\n\", cmd->cmnd[0],\n\t\t\t\t\tcp->host_status, cp->scsi_status);\n\t\t}\n\t}\n\n\t \n\tcmd->result = 0;\n\tif (   (cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == SAM_STAT_GOOD ||\n\t\t    cp->scsi_status == SAM_STAT_CONDITION_MET)) {\n\t\t \n\t\tset_status_byte(cmd, cp->scsi_status);\n\n\t\t \n\t\t \n\n\t\t \n\t\tif (!lp)\n\t\t\tncr_alloc_lcb (np, cmd->device->id, cmd->device->lun);\n\n\t\ttp->bytes     += cp->data_len;\n\t\ttp->transfers ++;\n\n\t\t \n\t\tif (lp && lp->usetags && lp->numtags < lp->maxtags) {\n\t\t\t++lp->num_good;\n\t\t\tif (lp->num_good >= 1000) {\n\t\t\t\tlp->num_good = 0;\n\t\t\t\t++lp->numtags;\n\t\t\t\tncr_setup_tags (np, cmd->device);\n\t\t\t}\n\t\t}\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == SAM_STAT_CHECK_CONDITION)) {\n\t\t \n\t\tset_status_byte(cmd, SAM_STAT_CHECK_CONDITION);\n\n\t\t \n\t\tmemcpy(cmd->sense_buffer, cp->sense_buf,\n\t\t       min_t(size_t, SCSI_SENSE_BUFFERSIZE,\n\t\t\t     sizeof(cp->sense_buf)));\n\n\t\tif (DEBUG_FLAGS & (DEBUG_RESULT|DEBUG_TINY)) {\n\t\t\tu_char *p = cmd->sense_buffer;\n\t\t\tint i;\n\t\t\tPRINT_ADDR(cmd, \"sense data:\");\n\t\t\tfor (i=0; i<14; i++) printk (\" %x\", *p++);\n\t\t\tprintk (\".\\n\");\n\t\t}\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == SAM_STAT_RESERVATION_CONFLICT)) {\n\t\t \n\t\tset_status_byte(cmd, SAM_STAT_RESERVATION_CONFLICT);\n\n\t} else if ((cp->host_status == HS_COMPLETE)\n\t\t&& (cp->scsi_status == SAM_STAT_BUSY ||\n\t\t    cp->scsi_status == SAM_STAT_TASK_SET_FULL)) {\n\n\t\t \n\t\tset_status_byte(cmd, cp->scsi_status);\n\n\t} else if ((cp->host_status == HS_SEL_TIMEOUT)\n\t\t|| (cp->host_status == HS_TIMEOUT)) {\n\n\t\t \n\t\tset_status_byte(cmd, cp->scsi_status);\n\t\tset_host_byte(cmd, DID_TIME_OUT);\n\n\t} else if (cp->host_status == HS_RESET) {\n\n\t\t \n\t\tset_status_byte(cmd, cp->scsi_status);\n\t\tset_host_byte(cmd, DID_RESET);\n\n\t} else if (cp->host_status == HS_ABORTED) {\n\n\t\t \n\t\tset_status_byte(cmd, cp->scsi_status);\n\t\tset_host_byte(cmd, DID_ABORT);\n\n\t} else {\n\n\t\t \n\t\tPRINT_ADDR(cmd, \"COMMAND FAILED (%x %x) @%p.\\n\",\n\t\t\tcp->host_status, cp->scsi_status, cp);\n\n\t\tset_status_byte(cmd, cp->scsi_status);\n\t\tset_host_byte(cmd, DID_ERROR);\n\t}\n\n\t \n\n\tif (tp->usrflag & UF_TRACE) {\n\t\tu_char * p;\n\t\tint i;\n\t\tPRINT_ADDR(cmd, \" CMD:\");\n\t\tp = (u_char*) &cmd->cmnd[0];\n\t\tfor (i=0; i<cmd->cmd_len; i++) printk (\" %x\", *p++);\n\n\t\tif (cp->host_status==HS_COMPLETE) {\n\t\t\tswitch (cp->scsi_status) {\n\t\t\tcase SAM_STAT_GOOD:\n\t\t\t\tprintk (\"  GOOD\");\n\t\t\t\tbreak;\n\t\t\tcase SAM_STAT_CHECK_CONDITION:\n\t\t\t\tprintk (\"  SENSE:\");\n\t\t\t\tp = (u_char*) &cmd->sense_buffer;\n\t\t\t\tfor (i=0; i<14; i++)\n\t\t\t\t\tprintk (\" %x\", *p++);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk (\"  STAT: %x\\n\", cp->scsi_status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else printk (\"  HOSTERROR: %x\", cp->host_status);\n\t\tprintk (\"\\n\");\n\t}\n\n\t \n\tncr_free_ccb (np, cp);\n\n\t \n\tif (lp && lp->queuedccbs < lp->queuedepth &&\n\t    !list_empty(&lp->wait_ccbq))\n\t\tncr_start_next_ccb(np, lp, 2);\n\n\t \n\tif (np->waiting_list)\n\t\trequeue_waiting_list(np);\n\n\t \n\tncr_queue_done_cmd(np, cmd);\n}\n\n \n\n \nstatic void ncr_ccb_skipped(struct ncb *np, struct ccb *cp)\n{\n\tstruct tcb *tp = &np->target[cp->target];\n\tstruct lcb *lp = tp->lp[cp->lun];\n\n\tif (lp && cp != np->ccb) {\n\t\tcp->host_status &= ~HS_SKIPMASK;\n\t\tcp->start.schedule.l_paddr = \n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, select));\n\t\tlist_move_tail(&cp->link_ccbq, &lp->skip_ccbq);\n\t\tif (cp->queued) {\n\t\t\t--lp->queuedccbs;\n\t\t}\n\t}\n\tif (cp->queued) {\n\t\t--np->queuedccbs;\n\t\tcp->queued = 0;\n\t}\n}\n\n \nvoid ncr_wakeup_done (struct ncb *np)\n{\n\tstruct ccb *cp;\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\tint i, j;\n\n\ti = np->ccb_done_ic;\n\twhile (1) {\n\t\tj = i+1;\n\t\tif (j >= MAX_DONE)\n\t\t\tj = 0;\n\n\t\tcp = np->ccb_done[j];\n\t\tif (!CCB_DONE_VALID(cp))\n\t\t\tbreak;\n\n\t\tnp->ccb_done[j] = (struct ccb *)CCB_DONE_EMPTY;\n\t\tnp->scripth->done_queue[5*j + 4] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, done_plug));\n\t\tMEMORY_BARRIER();\n\t\tnp->scripth->done_queue[5*i + 4] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, done_end));\n\n\t\tif (cp->host_status & HS_DONEMASK)\n\t\t\tncr_complete (np, cp);\n\t\telse if (cp->host_status & HS_SKIPMASK)\n\t\t\tncr_ccb_skipped (np, cp);\n\n\t\ti = j;\n\t}\n\tnp->ccb_done_ic = i;\n#else\n\tcp = np->ccb;\n\twhile (cp) {\n\t\tif (cp->host_status & HS_DONEMASK)\n\t\t\tncr_complete (np, cp);\n\t\telse if (cp->host_status & HS_SKIPMASK)\n\t\t\tncr_ccb_skipped (np, cp);\n\t\tcp = cp->link_ccb;\n\t}\n#endif\n}\n\n \nvoid ncr_wakeup (struct ncb *np, u_long code)\n{\n\tstruct ccb *cp = np->ccb;\n\n\twhile (cp) {\n\t\tif (cp->host_status != HS_IDLE) {\n\t\t\tcp->host_status = code;\n\t\t\tncr_complete (np, cp);\n\t\t}\n\t\tcp = cp->link_ccb;\n\t}\n}\n\n \n\n \nstatic void ncr_chip_reset(struct ncb *np, int delay)\n{\n\tOUTB (nc_istat,  SRST);\n\tudelay(delay);\n\tOUTB (nc_istat,  0   );\n\n\tif (np->features & FE_EHP)\n\t\tOUTB (nc_ctest0, EHP);\n\tif (np->features & FE_MUX)\n\t\tOUTB (nc_ctest4, MUX);\n}\n\n\n \n\nvoid ncr_init (struct ncb *np, int reset, char * msg, u_long code)\n{\n \tint\ti;\n\n \t \n\n\tif (reset) {\n\t\tOUTB (nc_istat,  SRST);\n\t\tudelay(100);\n\t}\n\telse {\n\t\tOUTB (nc_stest3, TE|CSF);\n\t\tOUTONB (nc_ctest3, CLF);\n\t}\n \n\t \n\n\tif (msg) printk (KERN_INFO \"%s: restart (%s).\\n\", ncr_name (np), msg);\n\n\t \n\tnp->queuedepth = MAX_START - 1;\t \n\tfor (i = 1; i < MAX_START + MAX_START; i += 2)\n\t\tnp->scripth0->tryloop[i] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\n\n\t \n\tnp->squeueput = 0;\n\tnp->script0->startpos[0] = cpu_to_scr(NCB_SCRIPTH_PHYS (np, tryloop));\n\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\t \n\tfor (i = 0; i < MAX_DONE; i++) {\n\t\tnp->ccb_done[i] = (struct ccb *)CCB_DONE_EMPTY;\n\t\tnp->scripth0->done_queue[5*i + 4] =\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, done_end));\n\t}\n#endif\n\n\t \n\tnp->script0->done_pos[0] = cpu_to_scr(NCB_SCRIPTH_PHYS (np,done_queue));\n\tnp->ccb_done_ic = MAX_DONE-1;\n\tnp->scripth0->done_queue[5*(MAX_DONE-1) + 4] =\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, done_plug));\n\n\t \n\tncr_wakeup (np, code);\n\n\t \n\n\t \n\tncr_chip_reset(np, 2000);\n\n\tOUTB (nc_scntl0, np->rv_scntl0 | 0xc0);\n\t\t\t\t\t \n\tOUTB (nc_scntl1, 0x00);\t\t \n\n\tncr_selectclock(np, np->rv_scntl3);\t \n\n\tOUTB (nc_scid  , RRE|np->myaddr);\t \n\tOUTW (nc_respid, 1ul<<np->myaddr);\t \n\tOUTB (nc_istat , SIGP\t);\t\t \n\tOUTB (nc_dmode , np->rv_dmode);\t\t \n\tOUTB (nc_ctest5, np->rv_ctest5);\t \n\n\tOUTB (nc_dcntl , NOCOM|np->rv_dcntl);\t \n\tOUTB (nc_ctest0, np->rv_ctest0);\t \n\tOUTB (nc_ctest3, np->rv_ctest3);\t \n\tOUTB (nc_ctest4, np->rv_ctest4);\t \n\n\tOUTB (nc_stest2, EXT|np->rv_stest2);\t \n\tOUTB (nc_stest3, TE);\t\t\t \n\tOUTB (nc_stime0, 0x0c\t);\t\t \n\n\t \n\n\tnp->disc = 0;\n\n\t \n\n\tif (np->features & FE_LED0) {\n\t\tOUTOFFB (nc_gpcntl, 0x01);\n\t}\n\n\t \n\n\tOUTW (nc_sien , STO|HTH|MA|SGE|UDC|RST|PAR);\n\tOUTB (nc_dien , MDPE|BF|ABRT|SSI|SIR|IID);\n\n\t \n\n\tfor (i=0;i<MAX_TARGET;i++) {\n\t\tstruct tcb *tp = &np->target[i];\n\n\t\ttp->sval    = 0;\n\t\ttp->wval    = np->rv_scntl3;\n\n\t\tif (tp->usrsync != 255) {\n\t\t\tif (tp->usrsync <= np->maxsync) {\n\t\t\t\tif (tp->usrsync < np->minsync) {\n\t\t\t\t\ttp->usrsync = np->minsync;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\ttp->usrsync = 255;\n\t\t}\n\n\t\tif (tp->usrwide > np->maxwide)\n\t\t\ttp->usrwide = np->maxwide;\n\n\t}\n\n\t \n\tif (np->paddr2) {\n\t\tif (bootverbose)\n\t\t\tprintk (\"%s: Downloading SCSI SCRIPTS.\\n\",\n\t\t\t\tncr_name(np));\n\t\tOUTL (nc_scratcha, vtobus(np->script0));\n\t\tOUTL_DSP (NCB_SCRIPTH_PHYS (np, start_ram));\n\t}\n\telse\n\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, start));\n}\n\n \n\nstatic void ncr_negotiate (struct ncb* np, struct tcb* tp)\n{\n\t \n\n\tu_long minsync = tp->usrsync;\n\n\t \n\n\tif (np->scsi_mode && np->scsi_mode == SMODE_SE) {\n\t\tif (minsync < 12) minsync = 12;\n\t}\n\n\t \n\n\tif (minsync < np->minsync)\n\t\tminsync = np->minsync;\n\n\t \n\n\tif (minsync > np->maxsync)\n\t\tminsync = 255;\n\n\tif (tp->maxoffs > np->maxoffs)\n\t\ttp->maxoffs = np->maxoffs;\n\n\ttp->minsync = minsync;\n\ttp->maxoffs = (minsync<255 ? tp->maxoffs : 0);\n\n\t \n\n\ttp->period=0;\n\n\t \n\ttp->widedone=0;\n}\n\n \n\nstatic void ncr_getsync(struct ncb *np, u_char sfac, u_char *fakp, u_char *scntl3p)\n{\n\tu_long\tclk = np->clock_khz;\t \n\tint\tdiv = np->clock_divn;\t \n\tu_long\tfak;\t\t\t \n\tu_long\tper;\t\t\t \n\tu_long\tkpc;\t\t\t \n\n\t \n\tif\t(sfac <= 10)\tper = 250;\n\telse if\t(sfac == 11)\tper = 303;\n\telse if\t(sfac == 12)\tper = 500;\n\telse\t\t\tper = 40 * sfac;\n\n\t \n\tkpc = per * clk;\n\twhile (--div > 0)\n\t\tif (kpc >= (div_10M[div] << 2)) break;\n\n\t \n\tfak = (kpc - 1) / div_10M[div] + 1;\n\n\tif (fak < 4) fak = 4;\t \n\n\t \n\t*fakp\t\t= fak - 4;\n\t*scntl3p\t= ((div+1) << 4) + (sfac < 25 ? 0x80 : 0);\n}\n\n\n \n\nstatic void ncr_set_sync_wide_status (struct ncb *np, u_char target)\n{\n\tstruct ccb *cp;\n\tstruct tcb *tp = &np->target[target];\n\n\t \n\tOUTB (nc_sxfer, tp->sval);\n\tnp->sync_st = tp->sval;\n\tOUTB (nc_scntl3, tp->wval);\n\tnp->wide_st = tp->wval;\n\n\t \n\tfor (cp = np->ccb; cp; cp = cp->link_ccb) {\n\t\tif (!cp->cmd) continue;\n\t\tif (scmd_id(cp->cmd) != target) continue;\n\t\tcp->phys.select.sel_scntl3 = tp->wval;\n\t\tcp->phys.select.sel_sxfer  = tp->sval;\n\t}\n}\n\n \n\nstatic void ncr_setsync (struct ncb *np, struct ccb *cp, u_char scntl3, u_char sxfer)\n{\n\tstruct scsi_cmnd *cmd = cp->cmd;\n\tstruct tcb *tp;\n\tu_char target = INB (nc_sdid) & 0x0f;\n\tu_char idiv;\n\n\tBUG_ON(target != (scmd_id(cmd) & 0xf));\n\n\ttp = &np->target[target];\n\n\tif (!scntl3 || !(sxfer & 0x1f))\n\t\tscntl3 = np->rv_scntl3;\n\tscntl3 = (scntl3 & 0xf0) | (tp->wval & EWS) | (np->rv_scntl3 & 0x07);\n\n\t \n\n\tidiv = ((scntl3 >> 4) & 0x7);\n\tif ((sxfer & 0x1f) && idiv)\n\t\ttp->period = (((sxfer>>5)+4)*div_10M[idiv-1])/np->clock_khz;\n\telse\n\t\ttp->period = 0xffff;\n\n\t \n\tif (tp->sval == sxfer && tp->wval == scntl3)\n\t\treturn;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\tif (sxfer & 0x01f) {\n\t\t \n\t\tif (tp->period <= 2000)\n\t\t\tOUTOFFB(nc_stest2, EXT);\n\t}\n \n\tspi_display_xfer_agreement(tp->starget);\n\n\t \n\tncr_set_sync_wide_status(np, target);\n}\n\n \n\nstatic void ncr_setwide (struct ncb *np, struct ccb *cp, u_char wide, u_char ack)\n{\n\tstruct scsi_cmnd *cmd = cp->cmd;\n\tu16 target = INB (nc_sdid) & 0x0f;\n\tstruct tcb *tp;\n\tu_char\tscntl3;\n\tu_char\tsxfer;\n\n\tBUG_ON(target != (scmd_id(cmd) & 0xf));\n\n\ttp = &np->target[target];\n\ttp->widedone  =  wide+1;\n\tscntl3 = (tp->wval & (~EWS)) | (wide ? EWS : 0);\n\n\tsxfer = ack ? 0 : tp->sval;\n\n\t \n\tif (tp->sval == sxfer && tp->wval == scntl3) return;\n\ttp->sval = sxfer;\n\ttp->wval = scntl3;\n\n\t \n\tif (bootverbose >= 2) {\n\t\tdev_info(&cmd->device->sdev_target->dev, \"WIDE SCSI %sabled.\\n\",\n\t\t\t\t(scntl3 & EWS) ? \"en\" : \"dis\");\n\t}\n\n\t \n\tncr_set_sync_wide_status(np, target);\n}\n\n \n\nstatic void ncr_setup_tags (struct ncb *np, struct scsi_device *sdev)\n{\n\tunsigned char tn = sdev->id, ln = sdev->lun;\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\tu_char   reqtags, maxdepth;\n\n\t \n\tif ((!tp) || (!lp) || !sdev)\n\t\treturn;\n\n\t \n\tif (!lp->scdev_depth)\n\t\treturn;\n\n\t \n\tmaxdepth = lp->scdev_depth;\n\tif (maxdepth > lp->maxnxs)\tmaxdepth    = lp->maxnxs;\n\tif (lp->maxtags > maxdepth)\tlp->maxtags = maxdepth;\n\tif (lp->numtags > maxdepth)\tlp->numtags = maxdepth;\n\n\t \n\tif (sdev->tagged_supported && lp->numtags > 1) {\n\t\treqtags = lp->numtags;\n\t} else {\n\t\treqtags = 1;\n\t}\n\n\t \n\tlp->numtags = reqtags;\n\tif (lp->numtags > lp->maxtags)\n\t\tlp->maxtags = lp->numtags;\n\n\t \n\tif\t(reqtags > 1 && lp->usetags) {\t  \n\t\tif (lp->queuedepth == reqtags)\t  \n\t\t\treturn;\n\t\tlp->queuedepth\t= reqtags;\n\t}\n\telse if\t(reqtags <= 1 && !lp->usetags) {  \n\t\tlp->queuedepth\t= reqtags;\n\t\treturn;\n\t}\n\telse {\t\t\t\t\t  \n\t\tif (lp->busyccbs)\t\t  \n\t\t\treturn;\n\t\tlp->queuedepth\t= reqtags;\n\t\tlp->usetags\t= reqtags > 1 ? 1 : 0;\n\t}\n\n\t \n\tlp->jump_tag.l_paddr = lp->usetags?\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS(np, resel_tag)) :\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS(np, resel_notag));\n\n\t \n\tif (bootverbose) {\n\t\tif (lp->usetags) {\n\t\t\tdev_info(&sdev->sdev_gendev,\n\t\t\t\t\"tagged command queue depth set to %d\\n\",\n\t\t\t\treqtags);\n\t\t} else {\n\t\t\tdev_info(&sdev->sdev_gendev,\n\t\t\t\t\t\"tagged command queueing disabled\\n\");\n\t\t}\n\t}\n}\n\n \n\nstatic void ncr_timeout (struct ncb *np)\n{\n\tu_long\tthistime = jiffies;\n\n\t \n\n\tif (np->release_stage) {\n\t\tif (np->release_stage == 1) np->release_stage = 2;\n\t\treturn;\n\t}\n\n\tnp->timer.expires = jiffies + SCSI_NCR_TIMER_INTERVAL;\n\tadd_timer(&np->timer);\n\n\t \n\tif (np->settle_time) {\n\t\tif (np->settle_time <= thistime) {\n\t\t\tif (bootverbose > 1)\n\t\t\t\tprintk(\"%s: command processing resumed\\n\", ncr_name(np));\n\t\t\tnp->settle_time\t= 0;\n\t\t\tnp->disc\t= 1;\n\t\t\trequeue_waiting_list(np);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (np->lasttime + 4*HZ < thistime) {\n\t\t \n\t\tnp->lasttime = thistime;\n\t}\n\n#ifdef SCSI_NCR_BROKEN_INTR\n\tif (INB(nc_istat) & (INTF|SIP|DIP)) {\n\n\t\t \n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"{\");\n\t\tncr_exception (np);\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"}\");\n\t}\n#endif  \n}\n\n \n\nstatic void ncr_log_hard_error(struct ncb *np, u16 sist, u_char dstat)\n{\n\tu32\tdsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (dsp > np->p_script && dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script0;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp && \n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth0;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= NULL;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintk (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintk (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t\tscr_to_cpu((int) *(ncrcmd *)(script_base + script_ofs)));\n\t}\n\n\tprintk (\"%s: regdump:\", ncr_name(np));\n\tfor (i=0; i<16;i++)\n            printk (\" %02x\", (unsigned)INB_OFF(i));\n\tprintk (\".\\n\");\n}\n\n \n\nvoid ncr_exception (struct ncb *np)\n{\n\tu_char\tistat, dstat;\n\tu16\tsist;\n\tint\ti;\n\n\t \n\tistat = INB (nc_istat);\n\tif (istat & INTF) {\n\t\tOUTB (nc_istat, (istat & SIGP) | INTF);\n\t\tistat = INB (nc_istat);\n\t\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"F \");\n\t\tncr_wakeup_done (np);\n\t}\n\n\tif (!(istat & (SIP|DIP)))\n\t\treturn;\n\n\tif (istat & CABRT)\n\t\tOUTB (nc_istat, CABRT);\n\n\t \n\n\tsist  = (istat & SIP) ? INW (nc_sist)  : 0;\n\tdstat = (istat & DIP) ? INB (nc_dstat) : 0;\n\n\tif (DEBUG_FLAGS & DEBUG_TINY)\n\t\tprintk (\"<%d|%x:%x|%x:%x>\",\n\t\t\t(int)INB(nc_scr0),\n\t\t\tdstat,sist,\n\t\t\t(unsigned)INL(nc_dsp),\n\t\t\t(unsigned)INL(nc_dbc));\n\n\t \n\n\tif (!(sist  & (STO|GEN|HTH|SGE|UDC|RST)) &&\n\t    !(dstat & (MDPE|BF|ABRT|IID))) {\n\t\tif ((sist & SBMC) && ncr_int_sbmc (np))\n\t\t\treturn;\n\t\tif ((sist & PAR)  && ncr_int_par  (np))\n\t\t\treturn;\n\t\tif (sist & MA) {\n\t\t\tncr_int_ma (np);\n\t\t\treturn;\n\t\t}\n\t\tif (dstat & SIR) {\n\t\t\tncr_int_sir (np);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (!(sist & (SBMC|PAR)) && !(dstat & SSI)) {\n\t\t\tprintk(\t\"%s: unknown interrupt(s) ignored, \"\n\t\t\t\t\"ISTAT=%x DSTAT=%x SIST=%x\\n\",\n\t\t\t\tncr_name(np), istat, dstat, sist);\n\t\t\treturn;\n\t\t}\n\t\tOUTONB_STD ();\n\t\treturn;\n\t}\n\n\t \n\n\tif (sist & RST) {\n\t\tncr_init (np, 1, bootverbose ? \"scsi reset\" : NULL, HS_RESET);\n\t\treturn;\n\t}\n\n\tif ((sist & STO) &&\n\t\t!(dstat & (MDPE|BF|ABRT))) {\n\t \n\t\tOUTONB (nc_ctest3, CLF);\n\n\t\tncr_int_sto (np);\n\t\treturn;\n\t}\n\n\t \n\n\tif (time_after(jiffies, np->regtime)) {\n\t\tnp->regtime = jiffies + 10*HZ;\n\t\tfor (i = 0; i<sizeof(np->regdump); i++)\n\t\t\t((char*)&np->regdump)[i] = INB_OFF(i);\n\t\tnp->regdump.nc_dstat = dstat;\n\t\tnp->regdump.nc_sist  = sist;\n\t}\n\n\tncr_log_hard_error(np, sist, dstat);\n\n\tprintk (\"%s: have to clear fifos.\\n\", ncr_name (np));\n\tOUTB (nc_stest3, TE|CSF);\n\tOUTONB (nc_ctest3, CLF);\n\n\tif ((sist & (SGE)) ||\n\t\t(dstat & (MDPE|BF|ABRT|IID))) {\n\t\tncr_start_reset(np);\n\t\treturn;\n\t}\n\n\tif (sist & HTH) {\n\t\tprintk (\"%s: handshake timeout\\n\", ncr_name(np));\n\t\tncr_start_reset(np);\n\t\treturn;\n\t}\n\n\tif (sist & UDC) {\n\t\tprintk (\"%s: unexpected disconnect\\n\", ncr_name(np));\n\t\tOUTB (HS_PRT, HS_UNEXPECTED);\n\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, cleanup));\n\t\treturn;\n\t}\n\n\t \n\tprintk (\"%s: unknown interrupt\\n\", ncr_name(np));\n}\n\n \n\nvoid ncr_int_sto (struct ncb *np)\n{\n\tu_long dsa;\n\tstruct ccb *cp;\n\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"T\");\n\n\t \n\n\tdsa = INL (nc_dsa);\n\tcp = np->ccb;\n\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\tcp = cp->link_ccb;\n\n\tif (cp) {\n\t\tcp-> host_status = HS_SEL_TIMEOUT;\n\t\tncr_complete (np, cp);\n\t}\n\n\t \n\n\tOUTL_DSP (NCB_SCRIPTH_PHYS (np, sto_restart));\n\treturn;\n}\n\n \n\nstatic int ncr_int_sbmc (struct ncb *np)\n{\n\tu_char scsi_mode = INB (nc_stest4) & SMODE;\n\n\tif (scsi_mode != np->scsi_mode) {\n\t\tprintk(\"%s: SCSI bus mode change from %x to %x.\\n\",\n\t\t\tncr_name(np), np->scsi_mode, scsi_mode);\n\n\t\tnp->scsi_mode = scsi_mode;\n\n\n\t\t \n\t\tnp->settle_time\t= jiffies + HZ;\n\t\tncr_init (np, 0, bootverbose ? \"scsi mode change\" : NULL, HS_RESET);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int ncr_int_par (struct ncb *np)\n{\n\tu_char\thsts\t= INB (HS_PRT);\n\tu32\tdbc\t= INL (nc_dbc);\n\tu_char\tsstat1\t= INB (nc_sstat1);\n\tint phase\t= -1;\n\tint msg\t\t= -1;\n\tu32 jmp;\n\n\tprintk(\"%s: SCSI parity error detected: SCR1=%d DBC=%x SSTAT1=%x\\n\",\n\t\tncr_name(np), hsts, dbc, sstat1);\n\n\t \n\tif (!(INB (nc_scntl1) & ISCON))\n\t\treturn 0;\n\n\t \n\tif (hsts & HS_INVALMASK)\n\t\tgoto reset_all;\n\n\t \n\tif (!(dbc & 0xc0000000))\n\t\tphase = (dbc >> 24) & 7;\n\tif (phase == 7)\n\t\tmsg = MSG_PARITY_ERROR;\n\telse\n\t\tmsg = INITIATOR_ERROR;\n\n\n\t \n\tif (phase == 1)\n\t\tjmp = NCB_SCRIPTH_PHYS (np, par_err_data_in);\n\telse\n\t\tjmp = NCB_SCRIPTH_PHYS (np, par_err_other);\n\n\tOUTONB (nc_ctest3, CLF );\t \n\tOUTB (nc_stest3, TE|CSF);\t \n\n\tnp->msgout[0] = msg;\n\tOUTL_DSP (jmp);\n\treturn 1;\n\nreset_all:\n\tncr_start_reset(np);\n\treturn 1;\n}\n\n \n\nstatic void ncr_int_ma (struct ncb *np)\n{\n\tu32\tdbc;\n\tu32\trest;\n\tu32\tdsp;\n\tu32\tdsa;\n\tu32\tnxtdsp;\n\tu32\tnewtmp;\n\tu32\t*vdsp;\n\tu32\toadr, olen;\n\tu32\t*tblp;\n\tncrcmd *newcmd;\n\tu_char\tcmd, sbcl;\n\tstruct ccb *cp;\n\n\tdsp\t= INL (nc_dsp);\n\tdbc\t= INL (nc_dbc);\n\tsbcl\t= INB (nc_sbcl);\n\n\tcmd\t= dbc >> 24;\n\trest\t= dbc & 0xffffff;\n\n\t \n\n\tif ((cmd & 1) == 0) {\n\t\tu_char\tctest5, ss0, ss2;\n\t\tu16\tdelta;\n\n\t\tctest5 = (np->rv_ctest5 & DFS) ? INB (nc_ctest5) : 0;\n\t\tif (ctest5 & DFS)\n\t\t\tdelta=(((ctest5 << 8) | (INB (nc_dfifo) & 0xff)) - rest) & 0x3ff;\n\t\telse\n\t\t\tdelta=(INB (nc_dfifo) - rest) & 0x7f;\n\n\t\t \n\n\t\trest += delta;\n\t\tss0  = INB (nc_sstat0);\n\t\tif (ss0 & OLF) rest++;\n\t\tif (ss0 & ORF) rest++;\n\t\tif (INB(nc_scntl3) & EWS) {\n\t\t\tss2 = INB (nc_sstat2);\n\t\t\tif (ss2 & OLF1) rest++;\n\t\t\tif (ss2 & ORF1) rest++;\n\t\t}\n\n\t\tif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE))\n\t\t\tprintk (\"P%x%x RL=%d D=%d SS0=%x \", cmd&7, sbcl&7,\n\t\t\t\t(unsigned) rest, (unsigned) delta, ss0);\n\n\t} else\t{\n\t\tif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE))\n\t\t\tprintk (\"P%x%x RL=%d \", cmd&7, sbcl&7, rest);\n\t}\n\n\t \n\tOUTONB (nc_ctest3, CLF );\t \n\tOUTB (nc_stest3, TE|CSF);\t \n\n\t \n\tdsa = INL (nc_dsa);\n\tif (!(cmd & 6)) {\n\t\tcp = np->header.cp;\n\t\tif (CCB_PHYS(cp, phys) != dsa)\n\t\t\tcp = NULL;\n\t} else {\n\t\tcp  = np->ccb;\n\t\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\t\tcp = cp->link_ccb;\n\t}\n\n\t \n\tvdsp\t= NULL;\n\tnxtdsp\t= 0;\n\tif\t(dsp >  np->p_script &&\n\t\t dsp <= np->p_script + sizeof(struct script)) {\n\t\tvdsp = (u32 *)((char*)np->script0 + (dsp-np->p_script-8));\n\t\tnxtdsp = dsp;\n\t}\n\telse if\t(dsp >  np->p_scripth &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tvdsp = (u32 *)((char*)np->scripth0 + (dsp-np->p_scripth-8));\n\t\tnxtdsp = dsp;\n\t}\n\telse if (cp) {\n\t\tif\t(dsp == CCB_PHYS (cp, patch[2])) {\n\t\t\tvdsp = &cp->patch[0];\n\t\t\tnxtdsp = scr_to_cpu(vdsp[3]);\n\t\t}\n\t\telse if (dsp == CCB_PHYS (cp, patch[6])) {\n\t\t\tvdsp = &cp->patch[4];\n\t\t\tnxtdsp = scr_to_cpu(vdsp[3]);\n\t\t}\n\t}\n\n\t \n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintk (\"\\nCP=%p CP2=%p DSP=%x NXT=%x VDSP=%p CMD=%x \",\n\t\t\tcp, np->header.cp,\n\t\t\t(unsigned)dsp,\n\t\t\t(unsigned)nxtdsp, vdsp, cmd);\n\t}\n\n\t \n\tif (!cp) {\n\t\tprintk (\"%s: SCSI phase error fixup: \"\n\t\t\t\"CCB already dequeued (0x%08lx)\\n\", \n\t\t\tncr_name (np), (u_long) np->header.cp);\n\t\tgoto reset_all;\n\t}\n\n\t \n\n\toadr = scr_to_cpu(vdsp[1]);\n\n\tif (cmd & 0x10) {\t \n\t\ttblp = (u32 *) ((char*) &cp->phys + oadr);\n\t\tolen = scr_to_cpu(tblp[0]);\n\t\toadr = scr_to_cpu(tblp[1]);\n\t} else {\n\t\ttblp = (u32 *) 0;\n\t\tolen = scr_to_cpu(vdsp[0]) & 0xffffff;\n\t}\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tprintk (\"OCMD=%x\\nTBLP=%p OLEN=%x OADR=%x\\n\",\n\t\t\t(unsigned) (scr_to_cpu(vdsp[0]) >> 24),\n\t\t\ttblp,\n\t\t\t(unsigned) olen,\n\t\t\t(unsigned) oadr);\n\t}\n\n\t \n\n\tif (cmd != (scr_to_cpu(vdsp[0]) >> 24)) {\n\t\tPRINT_ADDR(cp->cmd, \"internal error: cmd=%02x != %02x=(vdsp[0] \"\n\t\t\t\t\">> 24)\\n\", cmd, scr_to_cpu(vdsp[0]) >> 24);\n\n\t\tgoto reset_all;\n\t}\n\n\t \n\tif (cp != np->header.cp) {\n\t\tprintk (\"%s: SCSI phase error fixup: \"\n\t\t\t\"CCB address mismatch (0x%08lx != 0x%08lx)\\n\", \n\t\t\tncr_name (np), (u_long) cp, (u_long) np->header.cp);\n\t}\n\n\t \n\n\tif (cmd & 0x06) {\n\t\tPRINT_ADDR(cp->cmd, \"phase change %x-%x %d@%08x resid=%d.\\n\",\n\t\t\tcmd&7, sbcl&7, (unsigned)olen,\n\t\t\t(unsigned)oadr, (unsigned)rest);\n\t\tgoto unexpected_phase;\n\t}\n\n\t \n\n\tnewcmd = cp->patch;\n\tnewtmp = CCB_PHYS (cp, patch);\n\tif (newtmp == scr_to_cpu(cp->phys.header.savep)) {\n\t\tnewcmd = &cp->patch[4];\n\t\tnewtmp = CCB_PHYS (cp, patch[4]);\n\t}\n\n\t \n\n\tnewcmd[0] = cpu_to_scr(((cmd & 0x0f) << 24) | rest);\n\tnewcmd[1] = cpu_to_scr(oadr + olen - rest);\n\tnewcmd[2] = cpu_to_scr(SCR_JUMP);\n\tnewcmd[3] = cpu_to_scr(nxtdsp);\n\n\tif (DEBUG_FLAGS & DEBUG_PHASE) {\n\t\tPRINT_ADDR(cp->cmd, \"newcmd[%d] %x %x %x %x.\\n\",\n\t\t\t(int) (newcmd - cp->patch),\n\t\t\t(unsigned)scr_to_cpu(newcmd[0]),\n\t\t\t(unsigned)scr_to_cpu(newcmd[1]),\n\t\t\t(unsigned)scr_to_cpu(newcmd[2]),\n\t\t\t(unsigned)scr_to_cpu(newcmd[3]));\n\t}\n\t \n\tOUTL (nc_temp, newtmp);\n\tOUTL_DSP (NCB_SCRIPT_PHYS (np, dispatch));\n\treturn;\n\n\t \nunexpected_phase:\n\tdsp -= 8;\n\tnxtdsp = 0;\n\n\tswitch (cmd & 7) {\n\tcase 2:\t \n\t\tnxtdsp = NCB_SCRIPT_PHYS (np, dispatch);\n\t\tbreak;\n#if 0\n\tcase 3:\t \n\t\tnxtdsp = NCB_SCRIPT_PHYS (np, dispatch);\n\t\tbreak;\n#endif\n\tcase 6:\t \n\t\tnp->scripth->nxtdsp_go_on[0] = cpu_to_scr(dsp + 8);\n\t\tif\t(dsp == NCB_SCRIPT_PHYS (np, send_ident)) {\n\t\t\tcp->host_status = HS_BUSY;\n\t\t\tnxtdsp = NCB_SCRIPTH_PHYS (np, clratn_go_on);\n\t\t}\n\t\telse if\t(dsp == NCB_SCRIPTH_PHYS (np, send_wdtr) ||\n\t\t\t dsp == NCB_SCRIPTH_PHYS (np, send_sdtr)) {\n\t\t\tnxtdsp = NCB_SCRIPTH_PHYS (np, nego_bad_phase);\n\t\t}\n\t\tbreak;\n#if 0\n\tcase 7:\t \n\t\tnxtdsp = NCB_SCRIPT_PHYS (np, clrack);\n\t\tbreak;\n#endif\n\t}\n\n\tif (nxtdsp) {\n\t\tOUTL_DSP (nxtdsp);\n\t\treturn;\n\t}\n\nreset_all:\n\tncr_start_reset(np);\n}\n\n\nstatic void ncr_sir_to_redo(struct ncb *np, int num, struct ccb *cp)\n{\n\tstruct scsi_cmnd *cmd\t= cp->cmd;\n\tstruct tcb *tp\t= &np->target[cmd->device->id];\n\tstruct lcb *lp\t= tp->lp[cmd->device->lun];\n\tstruct list_head *qp;\n\tstruct ccb *\tcp2;\n\tint\t\tdisc_cnt = 0;\n\tint\t\tbusy_cnt = 0;\n\tu32\t\tstartp;\n\tu_char\t\ts_status = INB (SS_PRT);\n\n\t \n\tif (lp) {\n\t\tqp = lp->busy_ccbq.prev;\n\t\twhile (qp != &lp->busy_ccbq) {\n\t\t\tcp2 = list_entry(qp, struct ccb, link_ccbq);\n\t\t\tqp  = qp->prev;\n\t\t\t++busy_cnt;\n\t\t\tif (cp2 == cp)\n\t\t\t\tbreak;\n\t\t\tcp2->start.schedule.l_paddr =\n\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, skip));\n\t\t}\n\t\tlp->held_ccb = cp;\t \n\t\tdisc_cnt = lp->queuedccbs - busy_cnt;\n\t}\n\n\tswitch(s_status) {\n\tdefault:\t \n\tcase SAM_STAT_TASK_SET_FULL:\n\t\t \n\t\tif (!lp)\n\t\t\tgoto out;\n\t\tif (bootverbose >= 1) {\n\t\t\tPRINT_ADDR(cmd, \"QUEUE FULL! %d busy, %d disconnected \"\n\t\t\t\t\t\"CCBs\\n\", busy_cnt, disc_cnt);\n\t\t}\n\t\tif (disc_cnt < lp->numtags) {\n\t\t\tlp->numtags\t= disc_cnt > 2 ? disc_cnt : 2;\n\t\t\tlp->num_good\t= 0;\n\t\t\tncr_setup_tags (np, cmd->device);\n\t\t}\n\t\t \n\t\tcp->phys.header.savep = cp->startp;\n\t\tcp->host_status = HS_BUSY;\n\t\tcp->scsi_status = SAM_STAT_ILLEGAL;\n\n\t\tncr_put_start_queue(np, cp);\n\t\tif (disc_cnt)\n\t\t\tINB (nc_ctest2);\t\t \n\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, reselect));\n\t\treturn;\n\tcase SAM_STAT_COMMAND_TERMINATED:\n\tcase SAM_STAT_CHECK_CONDITION:\n\t\t \n\t\tif (cp->auto_sense)\n\t\t\tgoto out;\n\n\t\t \n\t\tcp->scsi_smsg2[0]\t= IDENTIFY(0, cmd->device->lun);\n\t\tcp->phys.smsg.addr\t= cpu_to_scr(CCB_PHYS (cp, scsi_smsg2));\n\t\tcp->phys.smsg.size\t= cpu_to_scr(1);\n\n\t\t \n\t\tcp->phys.cmd.addr\t= cpu_to_scr(CCB_PHYS (cp, sensecmd));\n\t\tcp->phys.cmd.size\t= cpu_to_scr(6);\n\n\t\t \n\t\tcp->sensecmd[0]\t\t= 0x03;\n\t\tcp->sensecmd[1]\t\t= (cmd->device->lun & 0x7) << 5;\n\t\tcp->sensecmd[4]\t\t= sizeof(cp->sense_buf);\n\n\t\t \n\t\tmemset(cp->sense_buf, 0, sizeof(cp->sense_buf));\n\t\tcp->phys.sense.addr\t= cpu_to_scr(CCB_PHYS(cp,sense_buf[0]));\n\t\tcp->phys.sense.size\t= cpu_to_scr(sizeof(cp->sense_buf));\n\n\t\t \n\t\tstartp = cpu_to_scr(NCB_SCRIPTH_PHYS (np, sdata_in));\n\n\t\tcp->phys.header.savep\t= startp;\n\t\tcp->phys.header.goalp\t= startp + 24;\n\t\tcp->phys.header.lastp\t= startp;\n\t\tcp->phys.header.wgoalp\t= startp + 24;\n\t\tcp->phys.header.wlastp\t= startp;\n\n\t\tcp->host_status = HS_BUSY;\n\t\tcp->scsi_status = SAM_STAT_ILLEGAL;\n\t\tcp->auto_sense\t= s_status;\n\n\t\tcp->start.schedule.l_paddr =\n\t\t\tcpu_to_scr(NCB_SCRIPT_PHYS (np, select));\n\n\t\t \n\t\tif (cmd->device->select_no_atn)\n\t\t\tcp->start.schedule.l_paddr =\n\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, select_no_atn));\n\n\t\tncr_put_start_queue(np, cp);\n\n\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, start));\n\t\treturn;\n\t}\n\nout:\n\tOUTONB_STD ();\n\treturn;\n}\n\n\n \n\nvoid ncr_int_sir (struct ncb *np)\n{\n\tu_char scntl3;\n\tu_char chg, ofs, per, fak, wide;\n\tu_char num = INB (nc_dsps);\n\tstruct ccb *cp=NULL;\n\tu_long\tdsa    = INL (nc_dsa);\n\tu_char\ttarget = INB (nc_sdid) & 0x0f;\n\tstruct tcb *tp     = &np->target[target];\n\tstruct scsi_target *starget = tp->starget;\n\n\tif (DEBUG_FLAGS & DEBUG_TINY) printk (\"I#%d\", num);\n\n\tswitch (num) {\n\tcase SIR_INTFLY:\n\t\t \n\t\tncr_wakeup_done(np);\n#ifdef SCSI_NCR_CCB_DONE_SUPPORT\n\t\tOUTL(nc_dsp, NCB_SCRIPT_PHYS (np, done_end) + 8);\n#else\n\t\tOUTL(nc_dsp, NCB_SCRIPT_PHYS (np, start));\n#endif\n\t\treturn;\n\tcase SIR_RESEL_NO_MSG_IN:\n\tcase SIR_RESEL_NO_IDENTIFY:\n\t\t \n\t\tif (tp->lp[0]) { \n\t\t\tOUTL_DSP (scr_to_cpu(tp->lp[0]->jump_ccb[0]));\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase SIR_RESEL_BAD_TARGET:\t \n\tcase SIR_RESEL_BAD_LUN:\t\t \n\tcase SIR_RESEL_BAD_I_T_L_Q:\t \n\tcase SIR_RESEL_BAD_I_T_L:\t \n\t\tprintk (\"%s:%d: SIR %d, \"\n\t\t\t\"incorrect nexus identification on reselection\\n\",\n\t\t\tncr_name (np), target, num);\n\t\tgoto out;\n\tcase SIR_DONE_OVERFLOW:\n\t\tprintk (\"%s:%d: SIR %d, \"\n\t\t\t\"CCB done queue overflow\\n\",\n\t\t\tncr_name (np), target, num);\n\t\tgoto out;\n\tcase SIR_BAD_STATUS:\n\t\tcp = np->header.cp;\n\t\tif (!cp || CCB_PHYS (cp, phys) != dsa)\n\t\t\tgoto out;\n\t\tncr_sir_to_redo(np, num, cp);\n\t\treturn;\n\tdefault:\n\t\t \n\t\tcp = np->ccb;\n\t\twhile (cp && (CCB_PHYS (cp, phys) != dsa))\n\t\t\tcp = cp->link_ccb;\n\n\t\tBUG_ON(!cp);\n\t\tBUG_ON(cp != np->header.cp);\n\n\t\tif (!cp || cp != np->header.cp)\n\t\t\tgoto out;\n\t}\n\n\tswitch (num) {\n \n\n\tcase SIR_NEGO_FAILED:\n\t\t \n\t\tOUTB (HS_PRT, HS_BUSY);\n\n\t\tfallthrough;\n\n\tcase SIR_NEGO_PROTO:\n\t\t \n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->cmd, \"negotiation failed sir=%x \"\n\t\t\t\t\t\"status=%x.\\n\", num, cp->nego_status);\n\t\t}\n\n\t\t \n\t\tswitch (cp->nego_status) {\n\n\t\tcase NS_SYNC:\n\t\t\tspi_period(starget) = 0;\n\t\t\tspi_offset(starget) = 0;\n\t\t\tncr_setsync (np, cp, 0, 0xe0);\n\t\t\tbreak;\n\n\t\tcase NS_WIDE:\n\t\t\tspi_width(starget) = 0;\n\t\t\tncr_setwide (np, cp, 0, 0);\n\t\t\tbreak;\n\n\t\t}\n\t\tnp->msgin [0] = NOP;\n\t\tnp->msgout[0] = NOP;\n\t\tcp->nego_status = 0;\n\t\tbreak;\n\n\tcase SIR_NEGO_SYNC:\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, \"sync msgin\", np->msgin);\n\t\t}\n\n\t\tchg = 0;\n\t\tper = np->msgin[3];\n\t\tofs = np->msgin[4];\n\t\tif (ofs==0) per=255;\n\n\t\t \n\n\t\tif (ofs && starget)\n\t\t\tspi_support_sync(starget) = 1;\n\n\t\t \n\n\t\tif (per < np->minsync)\n\t\t\t{chg = 1; per = np->minsync;}\n\t\tif (per < tp->minsync)\n\t\t\t{chg = 1; per = tp->minsync;}\n\t\tif (ofs > tp->maxoffs)\n\t\t\t{chg = 1; ofs = tp->maxoffs;}\n\n\t\t \n\t\tfak\t= 7;\n\t\tscntl3\t= 0;\n\t\tif (ofs != 0) {\n\t\t\tncr_getsync(np, per, &fak, &scntl3);\n\t\t\tif (fak > 7) {\n\t\t\t\tchg = 1;\n\t\t\t\tofs = 0;\n\t\t\t}\n\t\t}\n\t\tif (ofs == 0) {\n\t\t\tfak\t= 7;\n\t\t\tper\t= 0;\n\t\t\tscntl3\t= 0;\n\t\t\ttp->minsync = 0;\n\t\t}\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->cmd, \"sync: per=%d scntl3=0x%x ofs=%d \"\n\t\t\t\t\"fak=%d chg=%d.\\n\", per, scntl3, ofs, fak, chg);\n\t\t}\n\n\t\tif (INB (HS_PRT) == HS_NEGOTIATE) {\n\t\t\tOUTB (HS_PRT, HS_BUSY);\n\t\t\tswitch (cp->nego_status) {\n\n\t\t\tcase NS_SYNC:\n\t\t\t\t \n\t\t\t\tif (chg) {\n\t\t\t\t\t \n\t\t\t\t\tspi_period(starget) = 0;\n\t\t\t\t\tspi_offset(starget) = 0;\n\t\t\t\t\tncr_setsync(np, cp, 0, 0xe0);\n\t\t\t\t\tOUTL_DSP(NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tspi_period(starget) = per;\n\t\t\t\t\tspi_offset(starget) = ofs;\n\t\t\t\t\tncr_setsync(np, cp, scntl3, (fak<<5)|ofs);\n\t\t\t\t\tOUTL_DSP(NCB_SCRIPT_PHYS (np, clrack));\n\t\t\t\t}\n\t\t\t\treturn;\n\n\t\t\tcase NS_WIDE:\n\t\t\t\tspi_width(starget) = 0;\n\t\t\t\tncr_setwide(np, cp, 0, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tspi_period(starget) = per;\n\t\tspi_offset(starget) = ofs;\n\t\tncr_setsync(np, cp, scntl3, (fak<<5)|ofs);\n\n\t\tspi_populate_sync_msg(np->msgout, per, ofs);\n\t\tcp->nego_status = NS_SYNC;\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, \"sync msgout\", np->msgout);\n\t\t}\n\n\t\tif (!ofs) {\n\t\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\treturn;\n\t\t}\n\t\tnp->msgin [0] = NOP;\n\n\t\tbreak;\n\n\tcase SIR_NEGO_WIDE:\n\t\t \n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, \"wide msgin\", np->msgin);\n\t\t}\n\n\t\t \n\n\t\tchg  = 0;\n\t\twide = np->msgin[3];\n\n\t\t \n\n\t\tif (wide && starget)\n\t\t\tspi_support_wide(starget) = 1;\n\n\t\t \n\n\t\tif (wide > tp->usrwide)\n\t\t\t{chg = 1; wide = tp->usrwide;}\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tPRINT_ADDR(cp->cmd, \"wide: wide=%d chg=%d.\\n\", wide,\n\t\t\t\t\tchg);\n\t\t}\n\n\t\tif (INB (HS_PRT) == HS_NEGOTIATE) {\n\t\t\tOUTB (HS_PRT, HS_BUSY);\n\t\t\tswitch (cp->nego_status) {\n\n\t\t\tcase NS_WIDE:\n\t\t\t\t \n\t\t\t\tif (chg) {\n\t\t\t\t\t \n\t\t\t\t\tspi_width(starget) = 0;\n\t\t\t\t\tncr_setwide(np, cp, 0, 1);\n\t\t\t\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, msg_bad));\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tspi_width(starget) = wide;\n\t\t\t\t\tncr_setwide(np, cp, wide, 1);\n\t\t\t\t\tOUTL_DSP (NCB_SCRIPT_PHYS (np, clrack));\n\t\t\t\t}\n\t\t\t\treturn;\n\n\t\t\tcase NS_SYNC:\n\t\t\t\tspi_period(starget) = 0;\n\t\t\t\tspi_offset(starget) = 0;\n\t\t\t\tncr_setsync(np, cp, 0, 0xe0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tspi_width(starget) = wide;\n\t\tncr_setwide(np, cp, wide, 1);\n\t\tspi_populate_width_msg(np->msgout, wide);\n\n\t\tnp->msgin [0] = NOP;\n\n\t\tcp->nego_status = NS_WIDE;\n\n\t\tif (DEBUG_FLAGS & DEBUG_NEGO) {\n\t\t\tncr_print_msg(cp, \"wide msgout\", np->msgin);\n\t\t}\n\t\tbreak;\n\n \n\n\tcase SIR_REJECT_RECEIVED:\n\t\t \n\n\t\tPRINT_ADDR(cp->cmd, \"MESSAGE_REJECT received (%x:%x).\\n\",\n\t\t\t(unsigned)scr_to_cpu(np->lastmsg), np->msgout[0]);\n\t\tbreak;\n\n\tcase SIR_REJECT_SENT:\n\t\t \n\n\t\tncr_print_msg(cp, \"MESSAGE_REJECT sent for\", np->msgin);\n\t\tbreak;\n\n \n\n\tcase SIR_IGN_RESIDUE:\n\t\t \n\n\t\tPRINT_ADDR(cp->cmd, \"IGNORE_WIDE_RESIDUE received, but not yet \"\n\t\t\t\t\"implemented.\\n\");\n\t\tbreak;\n#if 0\n\tcase SIR_MISSING_SAVE:\n\t\t \n\n\t\tPRINT_ADDR(cp->cmd, \"DISCONNECT received, but datapointer \"\n\t\t\t\t\"not saved: data=%x save=%x goal=%x.\\n\",\n\t\t\t(unsigned) INL (nc_temp),\n\t\t\t(unsigned) scr_to_cpu(np->header.savep),\n\t\t\t(unsigned) scr_to_cpu(np->header.goalp));\n\t\tbreak;\n#endif\n\t}\n\nout:\n\tOUTONB_STD ();\n}\n\n \n\nstatic struct ccb *ncr_get_ccb(struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tu_char tn = cmd->device->id;\n\tu_char ln = cmd->device->lun;\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\tu_char tag = NO_TAG;\n\tstruct ccb *cp = NULL;\n\n\t \n\tif (lp) {\n\t\tstruct list_head *qp;\n\t\t \n\t\tif (lp->usetags && lp->busyccbs >= lp->maxnxs)\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (list_empty(&lp->free_ccbq))\n\t\t\tncr_alloc_ccb(np, tn, ln);\n\n\t\t \n\t\tqp = ncr_list_pop(&lp->free_ccbq);\n\t\tif (qp) {\n\t\t\tcp = list_entry(qp, struct ccb, link_ccbq);\n\t\t\tif (cp->magic) {\n\t\t\t\tPRINT_ADDR(cmd, \"ccb free list corrupted \"\n\t\t\t\t\t\t\"(@%p)\\n\", cp);\n\t\t\t\tcp = NULL;\n\t\t\t} else {\n\t\t\t\tlist_add_tail(qp, &lp->wait_ccbq);\n\t\t\t\t++lp->busyccbs;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (cp) {\n\t\t\tif (lp->usetags)\n\t\t\t\ttag = lp->cb_tags[lp->ia_tag];\n\t\t}\n\t\telse if (lp->actccbs > 0)\n\t\t\treturn NULL;\n\t}\n\n\t \n\tif (!cp)\n\t\tcp = np->ccb;\n\n\t \n#if 0\n\twhile (cp->magic) {\n\t\tif (flags & SCSI_NOSLEEP) break;\n\t\tif (tsleep ((caddr_t)cp, PRIBIO|PCATCH, \"ncr\", 0))\n\t\t\tbreak;\n\t}\n#endif\n\n\tif (cp->magic)\n\t\treturn NULL;\n\n\tcp->magic = 1;\n\n\t \n\tif (lp) {\n\t\tif (tag != NO_TAG) {\n\t\t\t++lp->ia_tag;\n\t\t\tif (lp->ia_tag == MAX_TAGS)\n\t\t\t\tlp->ia_tag = 0;\n\t\t\tlp->tags_umap |= (((tagmap_t) 1) << tag);\n\t\t}\n\t}\n\n\t \n\tcp->tag\t   = tag;\n\tcp->target = tn;\n\tcp->lun    = ln;\n\n\tif (DEBUG_FLAGS & DEBUG_TAGS) {\n\t\tPRINT_ADDR(cmd, \"ccb @%p using tag %d.\\n\", cp, tag);\n\t}\n\n\treturn cp;\n}\n\n \n\nstatic void ncr_free_ccb (struct ncb *np, struct ccb *cp)\n{\n\tstruct tcb *tp = &np->target[cp->target];\n\tstruct lcb *lp = tp->lp[cp->lun];\n\n\tif (DEBUG_FLAGS & DEBUG_TAGS) {\n\t\tPRINT_ADDR(cp->cmd, \"ccb @%p freeing tag %d.\\n\", cp, cp->tag);\n\t}\n\n\t \n\tif (lp) {\n\t\tif (cp->tag != NO_TAG) {\n\t\t\tlp->cb_tags[lp->if_tag++] = cp->tag;\n\t\t\tif (lp->if_tag == MAX_TAGS)\n\t\t\t\tlp->if_tag = 0;\n\t\t\tlp->tags_umap &= ~(((tagmap_t) 1) << cp->tag);\n\t\t\tlp->tags_smap &= lp->tags_umap;\n\t\t\tlp->jump_ccb[cp->tag] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS(np, bad_i_t_l_q));\n\t\t} else {\n\t\t\tlp->jump_ccb[0] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS(np, bad_i_t_l));\n\t\t}\n\t}\n\n\t \n\n\tif (lp) {\n\t\tif (cp != np->ccb)\n\t\t\tlist_move(&cp->link_ccbq, &lp->free_ccbq);\n\t\t--lp->busyccbs;\n\t\tif (cp->queued) {\n\t\t\t--lp->queuedccbs;\n\t\t}\n\t}\n\tcp -> host_status = HS_IDLE;\n\tcp -> magic = 0;\n\tif (cp->queued) {\n\t\t--np->queuedccbs;\n\t\tcp->queued = 0;\n\t}\n\n#if 0\n\tif (cp == np->ccb)\n\t\twakeup ((caddr_t) cp);\n#endif\n}\n\n\n#define ncr_reg_bus_addr(r) (np->paddr + offsetof (struct ncr_reg, r))\n\n \nstatic void ncr_init_ccb(struct ncb *np, struct ccb *cp)\n{\n\tncrcmd copy_4 = np->features & FE_PFEN ? SCR_COPY(4) : SCR_COPY_F(4);\n\n\t \n\tcp->p_ccb \t   = vtobus(cp);\n\tcp->phys.header.cp = cp;\n\n\t \n\tINIT_LIST_HEAD(&cp->link_ccbq);\n\n\t \n\tcp->start.setup_dsa[0]\t = cpu_to_scr(copy_4);\n\tcp->start.setup_dsa[1]\t = cpu_to_scr(CCB_PHYS(cp, start.p_phys));\n\tcp->start.setup_dsa[2]\t = cpu_to_scr(ncr_reg_bus_addr(nc_dsa));\n\tcp->start.schedule.l_cmd = cpu_to_scr(SCR_JUMP);\n\tcp->start.p_phys\t = cpu_to_scr(CCB_PHYS(cp, phys));\n\n\tmemcpy(&cp->restart, &cp->start, sizeof(cp->restart));\n\n\tcp->start.schedule.l_paddr   = cpu_to_scr(NCB_SCRIPT_PHYS (np, idle));\n\tcp->restart.schedule.l_paddr = cpu_to_scr(NCB_SCRIPTH_PHYS (np, abort));\n}\n\n\n \nstatic void ncr_alloc_ccb(struct ncb *np, u_char tn, u_char ln)\n{\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\tstruct ccb *cp = NULL;\n\n\t \n\tcp = m_calloc_dma(sizeof(struct ccb), \"CCB\");\n\tif (!cp)\n\t\treturn;\n\n\t \n\tlp->actccbs++;\n\tnp->actccbs++;\n\tmemset(cp, 0, sizeof (*cp));\n\tncr_init_ccb(np, cp);\n\n\t \n\tcp->link_ccb      = np->ccb->link_ccb;\n\tnp->ccb->link_ccb = cp;\n\n\tlist_add(&cp->link_ccbq, &lp->free_ccbq);\n}\n\n \n\n\n \nstatic void ncr_init_tcb (struct ncb *np, u_char tn)\n{\n\tstruct tcb *tp = &np->target[tn];\n\tncrcmd copy_1 = np->features & FE_PFEN ? SCR_COPY(1) : SCR_COPY_F(1);\n\tint th = tn & 3;\n\tint i;\n\n\t \n\ttp->jump_tcb.l_cmd   =\n\t\tcpu_to_scr((SCR_JUMP ^ IFFALSE (DATA (0x80 + tn))));\n\ttp->jump_tcb.l_paddr = np->jump_tcb[th].l_paddr;\n\n\t \n\ttp->getscr[0] =\tcpu_to_scr(copy_1);\n\ttp->getscr[1] = cpu_to_scr(vtobus (&tp->sval));\n#ifdef SCSI_NCR_BIG_ENDIAN\n\ttp->getscr[2] = cpu_to_scr(ncr_reg_bus_addr(nc_sxfer) ^ 3);\n#else\n\ttp->getscr[2] = cpu_to_scr(ncr_reg_bus_addr(nc_sxfer));\n#endif\n\n\t \n\ttp->getscr[3] =\tcpu_to_scr(copy_1);\n\ttp->getscr[4] = cpu_to_scr(vtobus (&tp->wval));\n#ifdef SCSI_NCR_BIG_ENDIAN\n\ttp->getscr[5] = cpu_to_scr(ncr_reg_bus_addr(nc_scntl3) ^ 3);\n#else\n\ttp->getscr[5] = cpu_to_scr(ncr_reg_bus_addr(nc_scntl3));\n#endif\n\n\t \n\ttp->call_lun.l_cmd   = cpu_to_scr(SCR_CALL);\n\ttp->call_lun.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_lun));\n\n\t \n\tfor (i = 0 ; i < 4 ; i++) {\n\t\ttp->jump_lcb[i].l_cmd   =\n\t\t\t\tcpu_to_scr((SCR_JUMP ^ IFTRUE (MASK (i, 3))));\n\t\ttp->jump_lcb[i].l_paddr =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_identify));\n\t}\n\n\t \n\tnp->jump_tcb[th].l_paddr = cpu_to_scr(vtobus (&tp->jump_tcb));\n\n\t \n#ifdef SCSI_NCR_BIG_ENDIAN\n\tBUG_ON(((offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t offsetof(struct tcb    , sval    )) &3) != 3);\n\tBUG_ON(((offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t offsetof(struct tcb    , wval    )) &3) != 3);\n#else\n\tBUG_ON(((offsetof(struct ncr_reg, nc_sxfer) ^\n\t\t offsetof(struct tcb    , sval    )) &3) != 0);\n\tBUG_ON(((offsetof(struct ncr_reg, nc_scntl3) ^\n\t\t offsetof(struct tcb    , wval    )) &3) != 0);\n#endif\n}\n\n\n \nstatic struct lcb *ncr_alloc_lcb (struct ncb *np, u_char tn, u_char ln)\n{\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\tncrcmd copy_4 = np->features & FE_PFEN ? SCR_COPY(4) : SCR_COPY_F(4);\n\tint lh = ln & 3;\n\n\t \n\tif (lp)\n\t\treturn lp;\n\n\t \n\tlp = m_calloc_dma(sizeof(struct lcb), \"LCB\");\n\tif (!lp)\n\t\tgoto fail;\n\tmemset(lp, 0, sizeof(*lp));\n\ttp->lp[ln] = lp;\n\n\t \n\tif (!tp->jump_tcb.l_cmd)\n\t\tncr_init_tcb(np, tn);\n\n\t \n\tINIT_LIST_HEAD(&lp->free_ccbq);\n\tINIT_LIST_HEAD(&lp->busy_ccbq);\n\tINIT_LIST_HEAD(&lp->wait_ccbq);\n\tINIT_LIST_HEAD(&lp->skip_ccbq);\n\n\t \n\tlp->maxnxs\t= 1;\n\tlp->jump_ccb\t= &lp->jump_ccb_0;\n\tlp->p_jump_ccb\t= cpu_to_scr(vtobus(lp->jump_ccb));\n\n\t \n\tlp->jump_lcb.l_cmd   =\n\t\tcpu_to_scr((SCR_JUMP ^ IFFALSE (MASK (0x80+ln, 0xff))));\n\tlp->jump_lcb.l_paddr = tp->jump_lcb[lh].l_paddr;\n\n\tlp->load_jump_ccb[0] = cpu_to_scr(copy_4);\n\tlp->load_jump_ccb[1] = cpu_to_scr(vtobus (&lp->p_jump_ccb));\n\tlp->load_jump_ccb[2] = cpu_to_scr(ncr_reg_bus_addr(nc_temp));\n\n\tlp->jump_tag.l_cmd   = cpu_to_scr(SCR_JUMP);\n\tlp->jump_tag.l_paddr = cpu_to_scr(NCB_SCRIPT_PHYS (np, resel_notag));\n\n\t \n\ttp->jump_lcb[lh].l_paddr = cpu_to_scr(vtobus (&lp->jump_lcb));\n\n\t \n\tlp->busyccbs\t= 1;\n\tlp->queuedccbs\t= 1;\n\tlp->queuedepth\t= 1;\nfail:\n\treturn lp;\n}\n\n\n \nstatic struct lcb *ncr_setup_lcb (struct ncb *np, struct scsi_device *sdev)\n{\n\tunsigned char tn = sdev->id, ln = sdev->lun;\n\tstruct tcb *tp = &np->target[tn];\n\tstruct lcb *lp = tp->lp[ln];\n\n\t \n\tif (!lp && !(lp = ncr_alloc_lcb(np, tn, ln)))\n\t\tgoto fail;\n\n\t \n\tif (sdev->tagged_supported && lp->jump_ccb == &lp->jump_ccb_0) {\n\t\tint i;\n\t\tlp->jump_ccb = m_calloc_dma(256, \"JUMP_CCB\");\n\t\tif (!lp->jump_ccb) {\n\t\t\tlp->jump_ccb = &lp->jump_ccb_0;\n\t\t\tgoto fail;\n\t\t}\n\t\tlp->p_jump_ccb = cpu_to_scr(vtobus(lp->jump_ccb));\n\t\tfor (i = 0 ; i < 64 ; i++)\n\t\t\tlp->jump_ccb[i] =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_i_t_l_q));\n\t\tfor (i = 0 ; i < MAX_TAGS ; i++)\n\t\t\tlp->cb_tags[i] = i;\n\t\tlp->maxnxs = MAX_TAGS;\n\t\tlp->tags_stime = jiffies + 3*HZ;\n\t\tncr_setup_tags (np, sdev);\n\t}\n\n\nfail:\n\treturn lp;\n}\n\n \n\n \n\nstatic int ncr_scatter(struct ncb *np, struct ccb *cp, struct scsi_cmnd *cmd)\n{\n\tint segment\t= 0;\n\tint use_sg\t= scsi_sg_count(cmd);\n\n\tcp->data_len\t= 0;\n\n\tuse_sg = map_scsi_sg_data(np, cmd);\n\tif (use_sg > 0) {\n\t\tstruct scatterlist *sg;\n\t\tstruct scr_tblmove *data;\n\n\t\tif (use_sg > MAX_SCATTER) {\n\t\t\tunmap_scsi_data(np, cmd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tdata = &cp->phys.data[MAX_SCATTER - use_sg];\n\n\t\tscsi_for_each_sg(cmd, sg, use_sg, segment) {\n\t\t\tdma_addr_t baddr = sg_dma_address(sg);\n\t\t\tunsigned int len = sg_dma_len(sg);\n\n\t\t\tncr_build_sge(np, &data[segment], baddr, len);\n\t\t\tcp->data_len += len;\n\t\t}\n\t} else\n\t\tsegment = -2;\n\n\treturn segment;\n}\n\n \n\nstatic int __init ncr_regtest (struct ncb* np)\n{\n\tregister volatile u32 data;\n\t \n\tdata = 0xffffffff;\n\tOUTL_OFF(offsetof(struct ncr_reg, nc_dstat), data);\n\tdata = INL_OFF(offsetof(struct ncr_reg, nc_dstat));\n#if 1\n\tif (data == 0xffffffff) {\n#else\n\tif ((data & 0xe2f0fffd) != 0x02000080) {\n#endif\n\t\tprintk (\"CACHE TEST FAILED: reg dstat-sstat2 readback %x.\\n\",\n\t\t\t(unsigned) data);\n\t\treturn (0x10);\n\t}\n\treturn (0);\n}\n\nstatic int __init ncr_snooptest (struct ncb* np)\n{\n\tu32\tncr_rd, ncr_wr, ncr_bk, host_rd, host_wr, pc;\n\tint\ti, err=0;\n\tif (np->reg) {\n\t\terr |= ncr_regtest (np);\n\t\tif (err)\n\t\t\treturn (err);\n\t}\n\n\t \n\tpc  = NCB_SCRIPTH_PHYS (np, snooptest);\n\thost_wr = 1;\n\tncr_wr  = 2;\n\t \n\tnp->ncr_cache = cpu_to_scr(host_wr);\n\tOUTL (nc_temp, ncr_wr);\n\t \n\tOUTL_DSP (pc);\n\t \n\tfor (i=0; i<NCR_SNOOP_TIMEOUT; i++)\n\t\tif (INB(nc_istat) & (INTF|SIP|DIP))\n\t\t\tbreak;\n\t \n\tpc = INL (nc_dsp);\n\t \n\thost_rd = scr_to_cpu(np->ncr_cache);\n\tncr_rd  = INL (nc_scratcha);\n\tncr_bk  = INL (nc_temp);\n\t \n\tncr_chip_reset(np, 100);\n\t \n\tif (i>=NCR_SNOOP_TIMEOUT) {\n\t\tprintk (\"CACHE TEST FAILED: timeout.\\n\");\n\t\treturn (0x20);\n\t}\n\t \n\tif (pc != NCB_SCRIPTH_PHYS (np, snoopend)+8) {\n\t\tprintk (\"CACHE TEST FAILED: script execution failed.\\n\");\n\t\tprintk (\"start=%08lx, pc=%08lx, end=%08lx\\n\", \n\t\t\t(u_long) NCB_SCRIPTH_PHYS (np, snooptest), (u_long) pc,\n\t\t\t(u_long) NCB_SCRIPTH_PHYS (np, snoopend) +8);\n\t\treturn (0x40);\n\t}\n\t \n\tif (host_wr != ncr_rd) {\n\t\tprintk (\"CACHE TEST FAILED: host wrote %d, ncr read %d.\\n\",\n\t\t\t(int) host_wr, (int) ncr_rd);\n\t\terr |= 1;\n\t}\n\tif (host_rd != ncr_wr) {\n\t\tprintk (\"CACHE TEST FAILED: ncr wrote %d, host read %d.\\n\",\n\t\t\t(int) ncr_wr, (int) host_rd);\n\t\terr |= 2;\n\t}\n\tif (ncr_bk != ncr_wr) {\n\t\tprintk (\"CACHE TEST FAILED: ncr wrote %d, read back %d.\\n\",\n\t\t\t(int) ncr_wr, (int) ncr_bk);\n\t\terr |= 4;\n\t}\n\treturn (err);\n}\n\n \n\n \nstatic void ncr_selectclock(struct ncb *np, u_char scntl3)\n{\n\tif (np->multiplier < 2) {\n\t\tOUTB(nc_scntl3,\tscntl3);\n\t\treturn;\n\t}\n\n\tif (bootverbose >= 2)\n\t\tprintk (\"%s: enabling clock multiplier\\n\", ncr_name(np));\n\n\tOUTB(nc_stest1, DBLEN);\t    \n\tif (np->multiplier > 2) {   \n\t\tint i = 20;\n\t\twhile (!(INB(nc_stest4) & LCKFRQ) && --i > 0)\n\t\t\tudelay(20);\n\t\tif (!i)\n\t\t\tprintk(\"%s: the chip cannot lock the frequency\\n\", ncr_name(np));\n\t} else\t\t\t \n\t\tudelay(20);\n\tOUTB(nc_stest3, HSC);\t\t \n\tOUTB(nc_scntl3,\tscntl3);\n\tOUTB(nc_stest1, (DBLEN|DBLSEL)); \n\tOUTB(nc_stest3, 0x00);\t\t \n}\n\n\n \nstatic unsigned __init ncrgetfreq (struct ncb *np, int gen)\n{\n\tunsigned ms = 0;\n\tchar count = 0;\n\n\t \n\tOUTB (nc_stest1, 0);\t \n\tOUTW (nc_sien , 0);\t \n\t(void) INW (nc_sist);\t \n\tOUTB (nc_dien , 0);\t \n\t(void) INW (nc_sist);\t \n\tOUTB (nc_scntl3, 4);\t \n\tOUTB (nc_stime1, 0);\t \n\tOUTB (nc_stime1, gen);\t \n\twhile (!(INW(nc_sist) & GEN) && ms++ < 100000) {\n\t\tfor (count = 0; count < 10; count ++)\n\t\t\tudelay(100);\t \n\t}\n\tOUTB (nc_stime1, 0);\t \n \t \n \tOUTB (nc_scntl3, 0);\n\n\tif (bootverbose >= 2)\n\t\tprintk (\"%s: Delay (GEN=%d): %u msec\\n\", ncr_name(np), gen, ms);\n  \t \n\treturn ms ? ((1 << gen) * 4340) / ms : 0;\n}\n\n \nstatic void __init ncr_getclock (struct ncb *np, int mult)\n{\n\tunsigned char scntl3 = INB(nc_scntl3);\n\tunsigned char stest1 = INB(nc_stest1);\n\tunsigned f1;\n\n\tnp->multiplier = 1;\n\tf1 = 40000;\n\n\t \n\tif (mult > 1 && (stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {\n\t\tif (bootverbose >= 2)\n\t\t\tprintk (\"%s: clock multiplier found\\n\", ncr_name(np));\n\t\tnp->multiplier = mult;\n\t}\n\n\t \n\tif (np->multiplier != mult || (scntl3 & 7) < 3 || !(scntl3 & 1)) {\n\t\tunsigned f2;\n\n\t\tncr_chip_reset(np, 5);\n\n\t\t(void) ncrgetfreq (np, 11);\t \n\t\tf1 = ncrgetfreq (np, 11);\n\t\tf2 = ncrgetfreq (np, 11);\n\n\t\tif(bootverbose)\n\t\t\tprintk (\"%s: NCR clock is %uKHz, %uKHz\\n\", ncr_name(np), f1, f2);\n\n\t\tif (f1 > f2) f1 = f2;\t\t \n\n\t\tif\t(f1 <\t45000)\t\tf1 =  40000;\n\t\telse if (f1 <\t55000)\t\tf1 =  50000;\n\t\telse\t\t\t\tf1 =  80000;\n\n\t\tif (f1 < 80000 && mult > 1) {\n\t\t\tif (bootverbose >= 2)\n\t\t\t\tprintk (\"%s: clock multiplier assumed\\n\", ncr_name(np));\n\t\t\tnp->multiplier\t= mult;\n\t\t}\n\t} else {\n\t\tif\t((scntl3 & 7) == 3)\tf1 =  40000;\n\t\telse if\t((scntl3 & 7) == 5)\tf1 =  80000;\n\t\telse \t\t\t\tf1 = 160000;\n\n\t\tf1 /= np->multiplier;\n\t}\n\n\t \n\tf1\t\t*= np->multiplier;\n\tnp->clock_khz\t= f1;\n}\n\n \n\nstatic int ncr53c8xx_slave_alloc(struct scsi_device *device)\n{\n\tstruct Scsi_Host *host = device->host;\n\tstruct ncb *np = ((struct host_data *) host->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[device->id];\n\ttp->starget = device->sdev_target;\n\n\treturn 0;\n}\n\nstatic int ncr53c8xx_slave_configure(struct scsi_device *device)\n{\n\tstruct Scsi_Host *host = device->host;\n\tstruct ncb *np = ((struct host_data *) host->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[device->id];\n\tstruct lcb *lp = tp->lp[device->lun];\n\tint numtags, depth_to_use;\n\n\tncr_setup_lcb(np, device);\n\n\t \n\tnumtags = device_queue_depth(np->unit, device->id, device->lun);\n\tif (numtags > tp->usrtags)\n\t\tnumtags = tp->usrtags;\n\tif (!device->tagged_supported)\n\t\tnumtags = 1;\n\tdepth_to_use = numtags;\n\tif (depth_to_use < 2)\n\t\tdepth_to_use = 2;\n\tif (depth_to_use > MAX_TAGS)\n\t\tdepth_to_use = MAX_TAGS;\n\n\tscsi_change_queue_depth(device, depth_to_use);\n\n\t \n\tif (lp) {\n\t\tlp->numtags = lp->maxtags = numtags;\n\t\tlp->scdev_depth = depth_to_use;\n\t}\n\tncr_setup_tags (np, device);\n\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"ncr53c8xx_select_queue_depth: host=%d, id=%d, lun=%d, depth=%d\\n\",\n\t       np->unit, device->id, device->lun, depth_to_use);\n#endif\n\n\tif (spi_support_sync(device->sdev_target) &&\n\t    !spi_initial_dv(device->sdev_target))\n\t\tspi_dv_device(device);\n\treturn 0;\n}\n\nstatic int ncr53c8xx_queue_command_lck(struct scsi_cmnd *cmd)\n{\n     struct ncr_cmd_priv *cmd_priv = scsi_cmd_priv(cmd);\n     void (*done)(struct scsi_cmnd *) = scsi_done;\n     struct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;\n     unsigned long flags;\n     int sts;\n\n#ifdef DEBUG_NCR53C8XX\nprintk(\"ncr53c8xx_queue_command\\n\");\n#endif\n\n     cmd->host_scribble = NULL;\n     cmd_priv->data_mapped = 0;\n     cmd_priv->data_mapping = 0;\n\n     spin_lock_irqsave(&np->smp_lock, flags);\n\n     if ((sts = ncr_queue_command(np, cmd)) != DID_OK) {\n\t     set_host_byte(cmd, sts);\n#ifdef DEBUG_NCR53C8XX\nprintk(\"ncr53c8xx : command not queued - result=%d\\n\", sts);\n#endif\n     }\n#ifdef DEBUG_NCR53C8XX\n     else\nprintk(\"ncr53c8xx : command successfully queued\\n\");\n#endif\n\n     spin_unlock_irqrestore(&np->smp_lock, flags);\n\n     if (sts != DID_OK) {\n          unmap_scsi_data(np, cmd);\n          done(cmd);\n\t  sts = 0;\n     }\n\n     return sts;\n}\n\nstatic DEF_SCSI_QCMD(ncr53c8xx_queue_command)\n\nirqreturn_t ncr53c8xx_intr(int irq, void *dev_id)\n{\n     unsigned long flags;\n     struct Scsi_Host *shost = (struct Scsi_Host *)dev_id;\n     struct host_data *host_data = (struct host_data *)shost->hostdata;\n     struct ncb *np = host_data->ncb;\n     struct scsi_cmnd *done_list;\n\n#ifdef DEBUG_NCR53C8XX\n     printk(\"ncr53c8xx : interrupt received\\n\");\n#endif\n\n     if (DEBUG_FLAGS & DEBUG_TINY) printk (\"[\");\n\n     spin_lock_irqsave(&np->smp_lock, flags);\n     ncr_exception(np);\n     done_list     = np->done_list;\n     np->done_list = NULL;\n     spin_unlock_irqrestore(&np->smp_lock, flags);\n\n     if (DEBUG_FLAGS & DEBUG_TINY) printk (\"]\\n\");\n\n     if (done_list)\n\t     ncr_flush_done_cmds(done_list);\n     return IRQ_HANDLED;\n}\n\nstatic void ncr53c8xx_timeout(struct timer_list *t)\n{\n\tstruct ncb *np = from_timer(np, t, timer);\n\tunsigned long flags;\n\tstruct scsi_cmnd *done_list;\n\n\tspin_lock_irqsave(&np->smp_lock, flags);\n\tncr_timeout(np);\n\tdone_list     = np->done_list;\n\tnp->done_list = NULL;\n\tspin_unlock_irqrestore(&np->smp_lock, flags);\n\n\tif (done_list)\n\t\tncr_flush_done_cmds(done_list);\n}\n\nstatic int ncr53c8xx_bus_reset(struct scsi_cmnd *cmd)\n{\n\tstruct ncb *np = ((struct host_data *) cmd->device->host->hostdata)->ncb;\n\tint sts;\n\tunsigned long flags;\n\tstruct scsi_cmnd *done_list;\n\n\t \n\n\tspin_lock_irqsave(&np->smp_lock, flags);\n\tsts = ncr_reset_bus(np);\n\n\tdone_list     = np->done_list;\n\tnp->done_list = NULL;\n\tspin_unlock_irqrestore(&np->smp_lock, flags);\n\n\tncr_flush_done_cmds(done_list);\n\n\treturn sts;\n}\n\n\n \n\n#define next_wcmd host_scribble\n\nstatic void insert_into_waiting_list(struct ncb *np, struct scsi_cmnd *cmd)\n{\n\tstruct scsi_cmnd *wcmd;\n\n#ifdef DEBUG_WAITING_LIST\n\tprintk(\"%s: cmd %lx inserted into waiting list\\n\", ncr_name(np), (u_long) cmd);\n#endif\n\tcmd->next_wcmd = NULL;\n\tif (!(wcmd = np->waiting_list)) np->waiting_list = cmd;\n\telse {\n\t\twhile (wcmd->next_wcmd)\n\t\t\twcmd = (struct scsi_cmnd *) wcmd->next_wcmd;\n\t\twcmd->next_wcmd = (char *) cmd;\n\t}\n}\n\nstatic void process_waiting_list(struct ncb *np, int sts)\n{\n\tstruct scsi_cmnd *waiting_list, *wcmd;\n\n\twaiting_list = np->waiting_list;\n\tnp->waiting_list = NULL;\n\n#ifdef DEBUG_WAITING_LIST\n\tif (waiting_list) printk(\"%s: waiting_list=%lx processing sts=%d\\n\", ncr_name(np), (u_long) waiting_list, sts);\n#endif\n\twhile ((wcmd = waiting_list) != NULL) {\n\t\twaiting_list = (struct scsi_cmnd *) wcmd->next_wcmd;\n\t\twcmd->next_wcmd = NULL;\n\t\tif (sts == DID_OK) {\n#ifdef DEBUG_WAITING_LIST\n\tprintk(\"%s: cmd %lx trying to requeue\\n\", ncr_name(np), (u_long) wcmd);\n#endif\n\t\t\tsts = ncr_queue_command(np, wcmd);\n\t\t}\n\t\tif (sts != DID_OK) {\n#ifdef DEBUG_WAITING_LIST\n\tprintk(\"%s: cmd %lx done forced sts=%d\\n\", ncr_name(np), (u_long) wcmd, sts);\n#endif\n\t\t\tset_host_byte(wcmd, sts);\n\t\t\tncr_queue_done_cmd(np, wcmd);\n\t\t}\n\t}\n}\n\n#undef next_wcmd\n\nstatic ssize_t show_ncr53c8xx_revision(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *host = class_to_shost(dev);\n\tstruct host_data *host_data = (struct host_data *)host->hostdata;\n  \n\treturn snprintf(buf, 20, \"0x%x\\n\", host_data->ncb->revision_id);\n}\n  \nstatic struct device_attribute ncr53c8xx_revision_attr = {\n\t.attr\t= { .name = \"revision\", .mode = S_IRUGO, },\n\t.show\t= show_ncr53c8xx_revision,\n};\n  \nstatic struct attribute *ncr53c8xx_host_attrs[] = {\n\t&ncr53c8xx_revision_attr.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(ncr53c8xx_host);\n\n \n#ifdef\tMODULE\nchar *ncr53c8xx;\t \nmodule_param(ncr53c8xx, charp, 0);\n#endif\n\n#ifndef MODULE\nstatic int __init ncr53c8xx_setup(char *str)\n{\n\treturn sym53c8xx__setup(str);\n}\n\n__setup(\"ncr53c8xx=\", ncr53c8xx_setup);\n#endif\n\n\n \nstruct Scsi_Host * __init ncr_attach(struct scsi_host_template *tpnt,\n\t\t\t\t\tint unit, struct ncr_device *device)\n{\n\tstruct host_data *host_data;\n\tstruct ncb *np = NULL;\n\tstruct Scsi_Host *instance = NULL;\n\tu_long flags = 0;\n\tint i;\n\n\tWARN_ON_ONCE(tpnt->cmd_size < sizeof(struct ncr_cmd_priv));\n\n\tif (!tpnt->name)\n\t\ttpnt->name\t= SCSI_NCR_DRIVER_NAME;\n\tif (!tpnt->shost_groups)\n\t\ttpnt->shost_groups = ncr53c8xx_host_groups;\n\n\ttpnt->queuecommand\t= ncr53c8xx_queue_command;\n\ttpnt->slave_configure\t= ncr53c8xx_slave_configure;\n\ttpnt->slave_alloc\t= ncr53c8xx_slave_alloc;\n\ttpnt->eh_bus_reset_handler = ncr53c8xx_bus_reset;\n\ttpnt->can_queue\t\t= SCSI_NCR_CAN_QUEUE;\n\ttpnt->this_id\t\t= 7;\n\ttpnt->sg_tablesize\t= SCSI_NCR_SG_TABLESIZE;\n\ttpnt->cmd_per_lun\t= SCSI_NCR_CMD_PER_LUN;\n\n\tif (device->differential)\n\t\tdriver_setup.diff_support = device->differential;\n\n\tprintk(KERN_INFO \"ncr53c720-%d: rev 0x%x irq %d\\n\",\n\t\tunit, device->chip.revision_id, device->slot.irq);\n\n\tinstance = scsi_host_alloc(tpnt, sizeof(*host_data));\n\tif (!instance)\n\t        goto attach_error;\n\thost_data = (struct host_data *) instance->hostdata;\n\n\tnp = __m_calloc_dma(device->dev, sizeof(struct ncb), \"NCB\");\n\tif (!np)\n\t\tgoto attach_error;\n\tspin_lock_init(&np->smp_lock);\n\tnp->dev = device->dev;\n\tnp->p_ncb = vtobus(np);\n\thost_data->ncb = np;\n\n\tnp->ccb = m_calloc_dma(sizeof(struct ccb), \"CCB\");\n\tif (!np->ccb)\n\t\tgoto attach_error;\n\n\t \n\tnp->unit\t= unit;\n\tnp->verbose\t= driver_setup.verbose;\n\tsprintf(np->inst_name, \"ncr53c720-%d\", np->unit);\n\tnp->revision_id\t= device->chip.revision_id;\n\tnp->features\t= device->chip.features;\n\tnp->clock_divn\t= device->chip.nr_divisor;\n\tnp->maxoffs\t= device->chip.offset_max;\n\tnp->maxburst\t= device->chip.burst_max;\n\tnp->myaddr\t= device->host_id;\n\n\t \n\tnp->script0 = m_calloc_dma(sizeof(struct script), \"SCRIPT\");\n\tif (!np->script0)\n\t\tgoto attach_error;\n\tnp->scripth0 = m_calloc_dma(sizeof(struct scripth), \"SCRIPTH\");\n\tif (!np->scripth0)\n\t\tgoto attach_error;\n\n\ttimer_setup(&np->timer, ncr53c8xx_timeout, 0);\n\n\t \n\n\tnp->paddr\t= device->slot.base;\n\tnp->paddr2\t= (np->features & FE_RAM) ? device->slot.base_2 : 0;\n\n\tif (device->slot.base_v)\n\t\tnp->vaddr = device->slot.base_v;\n\telse\n\t\tnp->vaddr = ioremap(device->slot.base_c, 128);\n\n\tif (!np->vaddr) {\n\t\tprintk(KERN_ERR\n\t\t\t\"%s: can't map memory mapped IO region\\n\",ncr_name(np));\n\t\tgoto attach_error;\n\t} else {\n\t\tif (bootverbose > 1)\n\t\t\tprintk(KERN_INFO\n\t\t\t\t\"%s: using memory mapped IO at virtual address 0x%lx\\n\", ncr_name(np), (u_long) np->vaddr);\n\t}\n\n\t \n\n\tnp->reg = (struct ncr_reg __iomem *)np->vaddr;\n\n\t \n\tncr_prepare_setting(np);\n\n\tif (np->paddr2 && sizeof(struct script) > 4096) {\n\t\tnp->paddr2 = 0;\n\t\tprintk(KERN_WARNING \"%s: script too large, NOT using on chip RAM.\\n\",\n\t\t\tncr_name(np));\n\t}\n\n\tinstance->max_channel\t= 0;\n\tinstance->this_id       = np->myaddr;\n\tinstance->max_id\t= np->maxwide ? 16 : 8;\n\tinstance->max_lun\t= SCSI_NCR_MAX_LUN;\n\tinstance->base\t\t= (unsigned long) np->reg;\n\tinstance->irq\t\t= device->slot.irq;\n\tinstance->unique_id\t= device->slot.base;\n\tinstance->dma_channel\t= 0;\n\tinstance->cmd_per_lun\t= MAX_TAGS;\n\tinstance->can_queue\t= (MAX_START-4);\n\t \n\tBUG_ON(!ncr53c8xx_transport_template);\n\tinstance->transportt\t= ncr53c8xx_transport_template;\n\n\t \n\tncr_script_fill(&script0, &scripth0);\n\n\tnp->scripth\t= np->scripth0;\n\tnp->p_scripth\t= vtobus(np->scripth);\n\tnp->p_script\t= (np->paddr2) ?  np->paddr2 : vtobus(np->script0);\n\n\tncr_script_copy_and_bind(np, (ncrcmd *) &script0,\n\t\t\t(ncrcmd *) np->script0, sizeof(struct script));\n\tncr_script_copy_and_bind(np, (ncrcmd *) &scripth0,\n\t\t\t(ncrcmd *) np->scripth0, sizeof(struct scripth));\n\tnp->ccb->p_ccb\t= vtobus (np->ccb);\n\n\t \n\n\tif (np->features & FE_LED0) {\n\t\tnp->script0->idle[0]  =\n\t\t\t\tcpu_to_scr(SCR_REG_REG(gpreg, SCR_OR,  0x01));\n\t\tnp->script0->reselected[0] =\n\t\t\t\tcpu_to_scr(SCR_REG_REG(gpreg, SCR_AND, 0xfe));\n\t\tnp->script0->start[0] =\n\t\t\t\tcpu_to_scr(SCR_REG_REG(gpreg, SCR_AND, 0xfe));\n\t}\n\n\t \n\tfor (i = 0 ; i < 4 ; i++) {\n\t\tnp->jump_tcb[i].l_cmd   =\n\t\t\t\tcpu_to_scr((SCR_JUMP ^ IFTRUE (MASK (i, 3))));\n\t\tnp->jump_tcb[i].l_paddr =\n\t\t\t\tcpu_to_scr(NCB_SCRIPTH_PHYS (np, bad_target));\n\t}\n\n\tncr_chip_reset(np, 100);\n\n\t \n\n\tif (ncr_snooptest(np)) {\n\t\tprintk(KERN_ERR \"CACHE INCORRECTLY CONFIGURED.\\n\");\n\t\tgoto attach_error;\n\t}\n\n\t \n\tnp->irq = device->slot.irq;\n\n\t \n\tncr_init_ccb(np, np->ccb);\n\n\t \n\tspin_lock_irqsave(&np->smp_lock, flags);\n\tif (ncr_reset_scsi_bus(np, 0, driver_setup.settle_delay) != 0) {\n\t\tprintk(KERN_ERR \"%s: FATAL ERROR: CHECK SCSI BUS - CABLES, TERMINATION, DEVICE POWER etc.!\\n\", ncr_name(np));\n\n\t\tspin_unlock_irqrestore(&np->smp_lock, flags);\n\t\tgoto attach_error;\n\t}\n\tncr_exception(np);\n\n\tnp->disc = 1;\n\n\t \n\tif (driver_setup.settle_delay > 2) {\n\t\tprintk(KERN_INFO \"%s: waiting %d seconds for scsi devices to settle...\\n\",\n\t\t\tncr_name(np), driver_setup.settle_delay);\n\t\tmdelay(1000 * driver_setup.settle_delay);\n\t}\n\n\t \n\tnp->lasttime=0;\n\tncr_timeout (np);\n\n\t \n#ifdef SCSI_NCR_ALWAYS_SIMPLE_TAG\n\tnp->order = SIMPLE_QUEUE_TAG;\n#endif\n\n\tspin_unlock_irqrestore(&np->smp_lock, flags);\n\n\treturn instance;\n\n attach_error:\n\tif (!instance)\n\t\treturn NULL;\n\tprintk(KERN_INFO \"%s: detaching...\\n\", ncr_name(np));\n\tif (!np)\n\t\tgoto unregister;\n\tif (np->scripth0)\n\t\tm_free_dma(np->scripth0, sizeof(struct scripth), \"SCRIPTH\");\n\tif (np->script0)\n\t\tm_free_dma(np->script0, sizeof(struct script), \"SCRIPT\");\n\tif (np->ccb)\n\t\tm_free_dma(np->ccb, sizeof(struct ccb), \"CCB\");\n\tm_free_dma(np, sizeof(struct ncb), \"NCB\");\n\thost_data->ncb = NULL;\n\n unregister:\n\tscsi_host_put(instance);\n\n\treturn NULL;\n}\n\n\nvoid ncr53c8xx_release(struct Scsi_Host *host)\n{\n\tstruct host_data *host_data = shost_priv(host);\n#ifdef DEBUG_NCR53C8XX\n\tprintk(\"ncr53c8xx: release\\n\");\n#endif\n\tif (host_data->ncb)\n\t\tncr_detach(host_data->ncb);\n\tscsi_host_put(host);\n}\n\nstatic void ncr53c8xx_set_period(struct scsi_target *starget, int period)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[starget->id];\n\n\tif (period > np->maxsync)\n\t\tperiod = np->maxsync;\n\telse if (period < np->minsync)\n\t\tperiod = np->minsync;\n\n\ttp->usrsync = period;\n\n\tncr_negotiate(np, tp);\n}\n\nstatic void ncr53c8xx_set_offset(struct scsi_target *starget, int offset)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[starget->id];\n\n\tif (offset > np->maxoffs)\n\t\toffset = np->maxoffs;\n\telse if (offset < 0)\n\t\toffset = 0;\n\n\ttp->maxoffs = offset;\n\n\tncr_negotiate(np, tp);\n}\n\nstatic void ncr53c8xx_set_width(struct scsi_target *starget, int width)\n{\n\tstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\n\tstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\n\tstruct tcb *tp = &np->target[starget->id];\n\n\tif (width > np->maxwide)\n\t\twidth = np->maxwide;\n\telse if (width < 0)\n\t\twidth = 0;\n\n\ttp->usrwide = width;\n\n\tncr_negotiate(np, tp);\n}\n\nstatic void ncr53c8xx_get_signalling(struct Scsi_Host *shost)\n{\n\tstruct ncb *np = ((struct host_data *)shost->hostdata)->ncb;\n\tenum spi_signal_type type;\n\n\tswitch (np->scsi_mode) {\n\tcase SMODE_SE:\n\t\ttype = SPI_SIGNAL_SE;\n\t\tbreak;\n\tcase SMODE_HVD:\n\t\ttype = SPI_SIGNAL_HVD;\n\t\tbreak;\n\tdefault:\n\t\ttype = SPI_SIGNAL_UNKNOWN;\n\t\tbreak;\n\t}\n\tspi_signalling(shost) = type;\n}\n\nstatic struct spi_function_template ncr53c8xx_transport_functions =  {\n\t.set_period\t= ncr53c8xx_set_period,\n\t.show_period\t= 1,\n\t.set_offset\t= ncr53c8xx_set_offset,\n\t.show_offset\t= 1,\n\t.set_width\t= ncr53c8xx_set_width,\n\t.show_width\t= 1,\n\t.get_signalling\t= ncr53c8xx_get_signalling,\n};\n\nint __init ncr53c8xx_init(void)\n{\n\tncr53c8xx_transport_template = spi_attach_transport(&ncr53c8xx_transport_functions);\n\tif (!ncr53c8xx_transport_template)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nvoid ncr53c8xx_exit(void)\n{\n\tspi_release_transport(ncr53c8xx_transport_template);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}