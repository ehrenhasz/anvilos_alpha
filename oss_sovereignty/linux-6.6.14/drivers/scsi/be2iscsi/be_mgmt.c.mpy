{
  "module_name": "be_mgmt.c",
  "hash_id": "04cefa1de62fa0235f51deefb66b53033687784154ed0abd51ccde5e088439b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/be2iscsi/be_mgmt.c",
  "human_readable_source": " \n\n#include <linux/bsg-lib.h>\n#include <scsi/scsi_transport_iscsi.h>\n#include <scsi/scsi_bsg_iscsi.h>\n#include \"be_mgmt.h\"\n#include \"be_iscsi.h\"\n#include \"be_main.h\"\n\nunsigned int mgmt_vendor_specific_fw_cmd(struct be_ctrl_info *ctrl,\n\t\t\t\t\t struct beiscsi_hba *phba,\n\t\t\t\t\t struct bsg_job *job,\n\t\t\t\t\t struct be_dma_mem *nonemb_cmd)\n{\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_sge *mcc_sge;\n\tunsigned int tag = 0;\n\tstruct iscsi_bsg_request *bsg_req = job->request;\n\tstruct be_bsg_vendor_cmd *req = nonemb_cmd->va;\n\tunsigned short region, sector_size, sector, offset;\n\n\tnonemb_cmd->size = job->request_payload.payload_len;\n\tmemset(nonemb_cmd->va, 0, nonemb_cmd->size);\n\tregion =  bsg_req->rqst_data.h_vendor.vendor_cmd[1];\n\tsector_size =  bsg_req->rqst_data.h_vendor.vendor_cmd[2];\n\tsector =  bsg_req->rqst_data.h_vendor.vendor_cmd[3];\n\toffset =  bsg_req->rqst_data.h_vendor.vendor_cmd[4];\n\treq->region = region;\n\treq->sector = sector;\n\treq->offset = offset;\n\n\tif (mutex_lock_interruptible(&ctrl->mbox_lock))\n\t\treturn 0;\n\tswitch (bsg_req->rqst_data.h_vendor.vendor_cmd[0]) {\n\tcase BEISCSI_WRITE_FLASH:\n\t\toffset = sector * sector_size + offset;\n\t\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t\t   OPCODE_COMMON_WRITE_FLASH, sizeof(*req));\n\t\tsg_copy_to_buffer(job->request_payload.sg_list,\n\t\t\t\t  job->request_payload.sg_cnt,\n\t\t\t\t  nonemb_cmd->va + offset, job->request_len);\n\t\tbreak;\n\tcase BEISCSI_READ_FLASH:\n\t\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t   OPCODE_COMMON_READ_FLASH, sizeof(*req));\n\t\tbreak;\n\tdefault:\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : Unsupported cmd = 0x%x\\n\\n\",\n\t\t\t    bsg_req->rqst_data.h_vendor.vendor_cmd[0]);\n\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn -EPERM;\n\t}\n\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\tmcc_sge = nonembedded_sgl(wrb);\n\tbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false,\n\t\t\t   job->request_payload.sg_cnt);\n\tmcc_sge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\n\tmcc_sge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\n\tmcc_sge->len = cpu_to_le32(nonemb_cmd->size);\n\n\tbe_mcc_notify(phba, tag);\n\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn tag;\n}\n\n \nint mgmt_open_connection(struct beiscsi_hba *phba,\n\t\t\t struct sockaddr *dst_addr,\n\t\t\t struct beiscsi_endpoint *beiscsi_ep,\n\t\t\t struct be_dma_mem *nonemb_cmd)\n{\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_context_memory *phwi_context;\n\tstruct sockaddr_in *daddr_in = (struct sockaddr_in *)dst_addr;\n\tstruct sockaddr_in6 *daddr_in6 = (struct sockaddr_in6 *)dst_addr;\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb;\n\tstruct tcp_connect_and_offload_in_v1 *req;\n\tunsigned short def_hdr_id;\n\tunsigned short def_data_id;\n\tstruct phys_addr template_address = { 0, 0 };\n\tstruct phys_addr *ptemplate_address;\n\tunsigned int tag = 0;\n\tunsigned int i, ulp_num;\n\tunsigned short cid = beiscsi_ep->ep_cid;\n\tstruct be_sge *sge;\n\n\tif (dst_addr->sa_family != PF_INET && dst_addr->sa_family != PF_INET6) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : unknown addr family %d\\n\",\n\t\t\t    dst_addr->sa_family);\n\t\treturn 0;\n\t}\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\n\tulp_num = phwi_ctrlr->wrb_context[BE_GET_CRI_FROM_CID(cid)].ulp_num;\n\n\tdef_hdr_id = (unsigned short)HWI_GET_DEF_HDRQ_ID(phba, ulp_num);\n\tdef_data_id = (unsigned short)HWI_GET_DEF_BUFQ_ID(phba, ulp_num);\n\n\tptemplate_address = &template_address;\n\tISCSI_GET_PDU_TEMPLATE_ADDRESS(phba, ptemplate_address);\n\tif (mutex_lock_interruptible(&ctrl->mbox_lock))\n\t\treturn 0;\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\tsge = nonembedded_sgl(wrb);\n\treq = nonemb_cmd->va;\n\tmemset(req, 0, sizeof(*req));\n\n\tbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t   OPCODE_COMMON_ISCSI_TCP_CONNECT_AND_OFFLOAD,\n\t\t\t   nonemb_cmd->size);\n\tif (dst_addr->sa_family == PF_INET) {\n\t\t__be32 s_addr = daddr_in->sin_addr.s_addr;\n\t\treq->ip_address.ip_type = BEISCSI_IP_TYPE_V4;\n\t\treq->ip_address.addr[0] = s_addr & 0x000000ff;\n\t\treq->ip_address.addr[1] = (s_addr & 0x0000ff00) >> 8;\n\t\treq->ip_address.addr[2] = (s_addr & 0x00ff0000) >> 16;\n\t\treq->ip_address.addr[3] = (s_addr & 0xff000000) >> 24;\n\t\treq->tcp_port = ntohs(daddr_in->sin_port);\n\t\tbeiscsi_ep->dst_addr = daddr_in->sin_addr.s_addr;\n\t\tbeiscsi_ep->dst_tcpport = ntohs(daddr_in->sin_port);\n\t\tbeiscsi_ep->ip_type = BEISCSI_IP_TYPE_V4;\n\t} else {\n\t\t \n\t\treq->ip_address.ip_type = BEISCSI_IP_TYPE_V6;\n\t\tmemcpy(&req->ip_address.addr,\n\t\t       &daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\n\t\treq->tcp_port = ntohs(daddr_in6->sin6_port);\n\t\tbeiscsi_ep->dst_tcpport = ntohs(daddr_in6->sin6_port);\n\t\tmemcpy(&beiscsi_ep->dst6_addr,\n\t\t       &daddr_in6->sin6_addr.in6_u.u6_addr8, 16);\n\t\tbeiscsi_ep->ip_type = BEISCSI_IP_TYPE_V6;\n\t}\n\treq->cid = cid;\n\ti = phba->nxt_cqid++;\n\tif (phba->nxt_cqid == phba->num_cpus)\n\t\tphba->nxt_cqid = 0;\n\treq->cq_id = phwi_context->be_cq[i].id;\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BG_%d : i=%d cq_id=%d\\n\", i, req->cq_id);\n\treq->defq_id = def_hdr_id;\n\treq->hdr_ring_id = def_hdr_id;\n\treq->data_ring_id = def_data_id;\n\treq->do_offload = 1;\n\treq->dataout_template_pa.lo = ptemplate_address->lo;\n\treq->dataout_template_pa.hi = ptemplate_address->hi;\n\tsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\n\tsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\n\tsge->len = cpu_to_le32(nonemb_cmd->size);\n\n\tif (!is_chip_be2_be3r(phba)) {\n\t\treq->hdr.version = MBX_CMD_VER1;\n\t\treq->tcp_window_size = 0x8000;\n\t\treq->tcp_window_scale_count = 2;\n\t}\n\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn tag;\n}\n\n \nstatic int beiscsi_exec_nemb_cmd(struct beiscsi_hba *phba,\n\t\t\t\t struct be_dma_mem *nonemb_cmd,\n\t\t\t\t void (*cbfn)(struct beiscsi_hba *,\n\t\t\t\t\t      unsigned int),\n\t\t\t\t void *resp_buf, u32 resp_buf_len)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_sge *sge;\n\tunsigned int tag;\n\tint rc = 0;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tsge = nonembedded_sgl(wrb);\n\tbe_wrb_hdr_prepare(wrb, nonemb_cmd->size, false, 1);\n\tsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\n\tsge->pa_lo = cpu_to_le32(lower_32_bits(nonemb_cmd->dma));\n\tsge->len = cpu_to_le32(nonemb_cmd->size);\n\n\tif (cbfn) {\n\t\tstruct be_dma_mem *tag_mem;\n\n\t\tset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\n\t\tctrl->ptag_state[tag].cbfn = cbfn;\n\t\ttag_mem = &phba->ctrl.ptag_state[tag].tag_mem_state;\n\n\t\t \n\t\ttag_mem->size = nonemb_cmd->size;\n\t\ttag_mem->va = nonemb_cmd->va;\n\t\ttag_mem->dma = nonemb_cmd->dma;\n\t}\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\n\t \n\tif (cbfn)\n\t\treturn 0;\n\n\trc = beiscsi_mccq_compl_wait(phba, tag, NULL, nonemb_cmd);\n\n\t \n\tif (resp_buf)\n\t\tmemcpy(resp_buf, nonemb_cmd->va, resp_buf_len);\n\treturn rc;\n}\n\nstatic int beiscsi_prep_nemb_cmd(struct beiscsi_hba *phba,\n\t\t\t\t struct be_dma_mem *cmd,\n\t\t\t\t u8 subsystem, u8 opcode, u32 size)\n{\n\tcmd->va = dma_alloc_coherent(&phba->ctrl.pdev->dev, size, &cmd->dma,\n\t\t\t\t     GFP_KERNEL);\n\tif (!cmd->va) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : Failed to allocate memory for if info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tcmd->size = size;\n\tbe_cmd_hdr_prepare(cmd->va, subsystem, opcode, size);\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BG_%d : subsystem %u cmd %u size %u\\n\",\n\t\t    subsystem, opcode, size);\n\treturn 0;\n}\n\nstatic void beiscsi_free_nemb_cmd(struct beiscsi_hba *phba,\n\t\t\t\t  struct be_dma_mem *cmd, int rc)\n{\n\t \n\tif (rc == -EBUSY)\n\t\treturn;\n\n\tdma_free_coherent(&phba->ctrl.pdev->dev, cmd->size, cmd->va, cmd->dma);\n}\n\nstatic void __beiscsi_eq_delay_compl(struct beiscsi_hba *phba, unsigned int tag)\n{\n\tstruct be_dma_mem *tag_mem;\n\n\t \n\t__beiscsi_mcc_compl_status(phba, tag, NULL, NULL);\n\ttag_mem = &phba->ctrl.ptag_state[tag].tag_mem_state;\n\tif (tag_mem->size) {\n\t\tdma_free_coherent(&phba->pcidev->dev, tag_mem->size,\n\t\t\t\t    tag_mem->va, tag_mem->dma);\n\t\ttag_mem->size = 0;\n\t}\n}\n\nint beiscsi_modify_eq_delay(struct beiscsi_hba *phba,\n\t\t\t    struct be_set_eqd *set_eqd, int num)\n{\n\tstruct be_cmd_req_modify_eq_delay *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tint i, rc;\n\n\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd, CMD_SUBSYSTEM_COMMON,\n\t\t\tOPCODE_COMMON_MODIFY_EQ_DELAY, sizeof(*req));\n\tif (rc)\n\t\treturn rc;\n\n\treq = nonemb_cmd.va;\n\treq->num_eq = cpu_to_le32(num);\n\tfor (i = 0; i < num; i++) {\n\t\treq->delay[i].eq_id = cpu_to_le32(set_eqd[i].eq_id);\n\t\treq->delay[i].phase = 0;\n\t\treq->delay[i].delay_multiplier =\n\t\t\t\tcpu_to_le32(set_eqd[i].delay_multiplier);\n\t}\n\n\trc = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, __beiscsi_eq_delay_compl,\n\t\t\t\t   NULL, 0);\n\tif (rc) {\n\t\t \n\t\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\t}\n\treturn rc;\n}\n\n \nint beiscsi_get_initiator_name(struct beiscsi_hba *phba, char *name, bool cfg)\n{\n\tstruct be_dma_mem nonemb_cmd;\n\tstruct be_cmd_hba_name resp;\n\tstruct be_cmd_hba_name *req;\n\tint rc;\n\n\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd, CMD_SUBSYSTEM_ISCSI_INI,\n\t\t\tOPCODE_ISCSI_INI_CFG_GET_HBA_NAME, sizeof(resp));\n\tif (rc)\n\t\treturn rc;\n\n\treq = nonemb_cmd.va;\n\tif (cfg)\n\t\treq->hdr.version = 1;\n\trc = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL,\n\t\t\t\t   &resp, sizeof(resp));\n\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\tif (rc) {\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t\t    \"BS_%d : Initiator Name MBX Failed\\n\");\n\t\treturn rc;\n\t}\n\trc = sprintf(name, \"%s\\n\", resp.initiator_name);\n\treturn rc;\n}\n\nunsigned int beiscsi_if_get_handle(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_cmd_get_all_if_id_req *req;\n\tstruct be_cmd_get_all_if_id_req *pbe_allid;\n\tunsigned int tag;\n\tint status = 0;\n\n\tif (mutex_lock_interruptible(&ctrl->mbox_lock))\n\t\treturn -EINTR;\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\treq = embedded_payload(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t   OPCODE_COMMON_ISCSI_NTWK_GET_ALL_IF_ID,\n\t\t\t   sizeof(*req));\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\n\tstatus = beiscsi_mccq_compl_wait(phba, tag, &wrb, NULL);\n\tif (status) {\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : %s failed: %d\\n\", __func__, status);\n\t\treturn -EBUSY;\n\t}\n\n\tpbe_allid = embedded_payload(wrb);\n\t \n\tphba->interface_handle = pbe_allid->if_hndl_list[0];\n\n\treturn status;\n}\n\nstatic inline bool beiscsi_if_zero_ip(u8 *ip, u32 ip_type)\n{\n\tu32 len;\n\n\tlen = (ip_type < BEISCSI_IP_TYPE_V6) ? IP_V4_LEN : IP_V6_LEN;\n\twhile (len && !ip[len - 1])\n\t\tlen--;\n\treturn (len == 0);\n}\n\nstatic int beiscsi_if_mod_gw(struct beiscsi_hba *phba,\n\t\t\t     u32 action, u32 ip_type, u8 *gw)\n{\n\tstruct be_cmd_set_def_gateway_req *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tint rt_val;\n\n\trt_val = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd, CMD_SUBSYSTEM_ISCSI,\n\t\t\tOPCODE_COMMON_ISCSI_NTWK_MODIFY_DEFAULT_GATEWAY,\n\t\t\tsizeof(*req));\n\tif (rt_val)\n\t\treturn rt_val;\n\n\treq = nonemb_cmd.va;\n\treq->action = action;\n\treq->ip_addr.ip_type = ip_type;\n\tmemcpy(req->ip_addr.addr, gw,\n\t       (ip_type < BEISCSI_IP_TYPE_V6) ? IP_V4_LEN : IP_V6_LEN);\n\trt_val = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL, NULL, 0);\n\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rt_val);\n\treturn rt_val;\n}\n\nint beiscsi_if_set_gw(struct beiscsi_hba *phba, u32 ip_type, u8 *gw)\n{\n\tstruct be_cmd_get_def_gateway_resp gw_resp;\n\tint rt_val;\n\n\tmemset(&gw_resp, 0, sizeof(gw_resp));\n\trt_val = beiscsi_if_get_gw(phba, ip_type, &gw_resp);\n\tif (rt_val) {\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : Failed to Get Gateway Addr\\n\");\n\t\treturn rt_val;\n\t}\n\n\tif (!beiscsi_if_zero_ip(gw_resp.ip_addr.addr, ip_type)) {\n\t\trt_val = beiscsi_if_mod_gw(phba, IP_ACTION_DEL, ip_type,\n\t\t\t\t\t   gw_resp.ip_addr.addr);\n\t\tif (rt_val) {\n\t\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BG_%d : Failed to clear Gateway Addr Set\\n\");\n\t\t\treturn rt_val;\n\t\t}\n\t}\n\n\trt_val = beiscsi_if_mod_gw(phba, IP_ACTION_ADD, ip_type, gw);\n\tif (rt_val)\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : Failed to Set Gateway Addr\\n\");\n\n\treturn rt_val;\n}\n\nint beiscsi_if_get_gw(struct beiscsi_hba *phba, u32 ip_type,\n\t\t      struct be_cmd_get_def_gateway_resp *resp)\n{\n\tstruct be_cmd_get_def_gateway_req *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tint rc;\n\n\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd, CMD_SUBSYSTEM_ISCSI,\n\t\t\tOPCODE_COMMON_ISCSI_NTWK_GET_DEFAULT_GATEWAY,\n\t\t\tsizeof(*resp));\n\tif (rc)\n\t\treturn rc;\n\n\treq = nonemb_cmd.va;\n\treq->ip_type = ip_type;\n\n\trc = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL, resp,\n\t\t\t\t   sizeof(*resp));\n\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\treturn rc;\n}\n\nstatic int\nbeiscsi_if_clr_ip(struct beiscsi_hba *phba,\n\t\t  struct be_cmd_get_if_info_resp *if_info)\n{\n\tstruct be_cmd_set_ip_addr_req *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tint rc;\n\n\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd, CMD_SUBSYSTEM_ISCSI,\n\t\t\tOPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR,\n\t\t\tsizeof(*req));\n\tif (rc)\n\t\treturn rc;\n\n\treq = nonemb_cmd.va;\n\treq->ip_params.record_entry_count = 1;\n\treq->ip_params.ip_record.action = IP_ACTION_DEL;\n\treq->ip_params.ip_record.interface_hndl =\n\t\tphba->interface_handle;\n\treq->ip_params.ip_record.ip_addr.size_of_structure =\n\t\tsizeof(struct be_ip_addr_subnet_format);\n\treq->ip_params.ip_record.ip_addr.ip_type = if_info->ip_addr.ip_type;\n\tmemcpy(req->ip_params.ip_record.ip_addr.addr,\n\t       if_info->ip_addr.addr,\n\t       sizeof(if_info->ip_addr.addr));\n\tmemcpy(req->ip_params.ip_record.ip_addr.subnet_mask,\n\t       if_info->ip_addr.subnet_mask,\n\t       sizeof(if_info->ip_addr.subnet_mask));\n\trc = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL, NULL, 0);\n\tif (rc < 0 || req->ip_params.ip_record.status) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : failed to clear IP: rc %d status %d\\n\",\n\t\t\t    rc, req->ip_params.ip_record.status);\n\t}\n\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\treturn rc;\n}\n\nstatic int\nbeiscsi_if_set_ip(struct beiscsi_hba *phba, u8 *ip,\n\t\t  u8 *subnet, u32 ip_type)\n{\n\tstruct be_cmd_set_ip_addr_req *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tuint32_t ip_len;\n\tint rc;\n\n\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd, CMD_SUBSYSTEM_ISCSI,\n\t\t\tOPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR,\n\t\t\tsizeof(*req));\n\tif (rc)\n\t\treturn rc;\n\n\treq = nonemb_cmd.va;\n\treq->ip_params.record_entry_count = 1;\n\treq->ip_params.ip_record.action = IP_ACTION_ADD;\n\treq->ip_params.ip_record.interface_hndl =\n\t\tphba->interface_handle;\n\treq->ip_params.ip_record.ip_addr.size_of_structure =\n\t\tsizeof(struct be_ip_addr_subnet_format);\n\treq->ip_params.ip_record.ip_addr.ip_type = ip_type;\n\tip_len = (ip_type < BEISCSI_IP_TYPE_V6) ? IP_V4_LEN : IP_V6_LEN;\n\tmemcpy(req->ip_params.ip_record.ip_addr.addr, ip, ip_len);\n\tif (subnet)\n\t\tmemcpy(req->ip_params.ip_record.ip_addr.subnet_mask,\n\t\t       subnet, ip_len);\n\n\trc = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL, NULL, 0);\n\t \n\tif (rc < 0 || req->ip_params.ip_record.status) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t    \"BG_%d : failed to set IP: rc %d status %d\\n\",\n\t\t\t    rc, req->ip_params.ip_record.status);\n\t\tif (req->ip_params.ip_record.status)\n\t\t\trc = -EINVAL;\n\t}\n\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\treturn rc;\n}\n\nint beiscsi_if_en_static(struct beiscsi_hba *phba, u32 ip_type,\n\t\t\t u8 *ip, u8 *subnet)\n{\n\tstruct be_cmd_get_if_info_resp *if_info;\n\tstruct be_cmd_rel_dhcp_req *reldhcp;\n\tstruct be_dma_mem nonemb_cmd;\n\tint rc;\n\n\trc = beiscsi_if_get_info(phba, ip_type, &if_info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (if_info->dhcp_state) {\n\t\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd,\n\t\t\t\tCMD_SUBSYSTEM_ISCSI,\n\t\t\t\tOPCODE_COMMON_ISCSI_NTWK_REL_STATELESS_IP_ADDR,\n\t\t\t\tsizeof(*reldhcp));\n\t\tif (rc)\n\t\t\tgoto exit;\n\n\t\treldhcp = nonemb_cmd.va;\n\t\treldhcp->interface_hndl = phba->interface_handle;\n\t\treldhcp->ip_type = ip_type;\n\t\trc = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL, NULL, 0);\n\t\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\t\tif (rc < 0) {\n\t\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BG_%d : failed to release existing DHCP: %d\\n\",\n\t\t\t\t    rc);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\tif (!beiscsi_if_zero_ip(if_info->ip_addr.addr, ip_type)) {\n\t\trc = beiscsi_if_clr_ip(phba, if_info);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tif (ip)\n\t\trc = beiscsi_if_set_ip(phba, ip, subnet, ip_type);\nexit:\n\tkfree(if_info);\n\treturn rc;\n}\n\nint beiscsi_if_en_dhcp(struct beiscsi_hba *phba, u32 ip_type)\n{\n\tstruct be_cmd_get_def_gateway_resp gw_resp;\n\tstruct be_cmd_get_if_info_resp *if_info;\n\tstruct be_cmd_set_dhcp_req *dhcpreq;\n\tstruct be_dma_mem nonemb_cmd;\n\tu8 *gw;\n\tint rc;\n\n\trc = beiscsi_if_get_info(phba, ip_type, &if_info);\n\tif (rc)\n\t\treturn rc;\n\n\tif (if_info->dhcp_state) {\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t\t\"BG_%d : DHCP Already Enabled\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tif (!beiscsi_if_zero_ip(if_info->ip_addr.addr, ip_type)) {\n\t\trc = beiscsi_if_clr_ip(phba, if_info);\n\t\tif (rc)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tmemset(&gw_resp, 0, sizeof(gw_resp));\n\t \n\trc = beiscsi_if_get_gw(phba, if_info->ip_addr.ip_type, &gw_resp);\n\tif (rc) {\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : Failed to Get Gateway Addr\\n\");\n\t\tgoto exit;\n\t}\n\tgw = (u8 *)&gw_resp.ip_addr.addr;\n\tif (!beiscsi_if_zero_ip(gw, if_info->ip_addr.ip_type)) {\n\t\trc = beiscsi_if_mod_gw(phba, IP_ACTION_DEL,\n\t\t\t\t       if_info->ip_addr.ip_type, gw);\n\t\tif (rc) {\n\t\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BG_%d : Failed to clear Gateway Addr Set\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd, CMD_SUBSYSTEM_ISCSI,\n\t\t\tOPCODE_COMMON_ISCSI_NTWK_CONFIG_STATELESS_IP_ADDR,\n\t\t\tsizeof(*dhcpreq));\n\tif (rc)\n\t\tgoto exit;\n\n\tdhcpreq = nonemb_cmd.va;\n\tdhcpreq->flags = 1;  \n\tdhcpreq->retry_count = 1;\n\tdhcpreq->interface_hndl = phba->interface_handle;\n\tdhcpreq->ip_type = ip_type;\n\trc = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL, NULL, 0);\n\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\nexit:\n\tkfree(if_info);\n\treturn rc;\n}\n\n \nint beiscsi_if_set_vlan(struct beiscsi_hba *phba, uint16_t vlan_tag)\n{\n\tint rc;\n\tunsigned int tag;\n\n\ttag = be_cmd_set_vlan(phba, vlan_tag);\n\tif (!tag) {\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    (BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX),\n\t\t\t    \"BG_%d : VLAN Setting Failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\trc = beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);\n\tif (rc) {\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    (BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX),\n\t\t\t    \"BS_%d : VLAN MBX Cmd Failed\\n\");\n\t\treturn rc;\n\t}\n\treturn rc;\n}\n\n\nint beiscsi_if_get_info(struct beiscsi_hba *phba, int ip_type,\n\t\t\tstruct be_cmd_get_if_info_resp **if_info)\n{\n\tstruct be_cmd_get_if_info_req *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tuint32_t ioctl_size = sizeof(struct be_cmd_get_if_info_resp);\n\tint rc;\n\n\trc = beiscsi_if_get_handle(phba);\n\tif (rc)\n\t\treturn rc;\n\n\tdo {\n\t\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd,\n\t\t\t\tCMD_SUBSYSTEM_ISCSI,\n\t\t\t\tOPCODE_COMMON_ISCSI_NTWK_GET_IF_INFO,\n\t\t\t\tioctl_size);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\treq = nonemb_cmd.va;\n\t\treq->interface_hndl = phba->interface_handle;\n\t\treq->ip_type = ip_type;\n\n\t\t \n\t\t*if_info = kzalloc(ioctl_size, GFP_KERNEL);\n\t\tif (!*if_info) {\n\t\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\t    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BG_%d : Memory Allocation Failure\\n\");\n\n\t\t\t\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd,\n\t\t\t\t\t\t      -ENOMEM);\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trc =  beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL, *if_info,\n\t\t\t\t\t    ioctl_size);\n\n\t\t \n\t\tif (rc == -EAGAIN) {\n\n\t\t\t \n\t\t\tioctl_size = ((struct be_cmd_resp_hdr *)\n\t\t\t\t      nonemb_cmd.va)->actual_resp_len;\n\t\t\tioctl_size += sizeof(struct be_cmd_req_hdr);\n\n\t\t\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\t\t\t \n\t\t\tkfree(*if_info);\n\t\t} else {\n\t\t\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\t\t\tbreak;\n\t\t}\n\t} while (true);\n\treturn rc;\n}\n\nint mgmt_get_nic_conf(struct beiscsi_hba *phba,\n\t\t      struct be_cmd_get_nic_conf_resp *nic)\n{\n\tstruct be_dma_mem nonemb_cmd;\n\tint rc;\n\n\trc = beiscsi_prep_nemb_cmd(phba, &nonemb_cmd, CMD_SUBSYSTEM_ISCSI,\n\t\t\tOPCODE_COMMON_ISCSI_NTWK_GET_NIC_CONFIG,\n\t\t\tsizeof(*nic));\n\tif (rc)\n\t\treturn rc;\n\n\trc = beiscsi_exec_nemb_cmd(phba, &nonemb_cmd, NULL, nic, sizeof(*nic));\n\tbeiscsi_free_nemb_cmd(phba, &nonemb_cmd, rc);\n\treturn rc;\n}\n\nstatic void beiscsi_boot_process_compl(struct beiscsi_hba *phba,\n\t\t\t\t       unsigned int tag)\n{\n\tstruct be_cmd_get_boot_target_resp *boot_resp;\n\tstruct be_cmd_resp_logout_fw_sess *logo_resp;\n\tstruct be_cmd_get_session_resp *sess_resp;\n\tstruct be_mcc_wrb *wrb;\n\tstruct boot_struct *bs;\n\tint boot_work, status;\n\n\tif (!test_bit(BEISCSI_HBA_BOOT_WORK, &phba->state)) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BG_%d : %s no boot work %lx\\n\",\n\t\t\t      __func__, phba->state);\n\t\treturn;\n\t}\n\n\tif (phba->boot_struct.tag != tag) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BG_%d : %s tag mismatch %d:%d\\n\",\n\t\t\t      __func__, tag, phba->boot_struct.tag);\n\t\treturn;\n\t}\n\tbs = &phba->boot_struct;\n\tboot_work = 1;\n\tstatus = 0;\n\tswitch (bs->action) {\n\tcase BEISCSI_BOOT_REOPEN_SESS:\n\t\tstatus = __beiscsi_mcc_compl_status(phba, tag, NULL, NULL);\n\t\tif (!status)\n\t\t\tbs->action = BEISCSI_BOOT_GET_SHANDLE;\n\t\telse\n\t\t\tbs->retry--;\n\t\tbreak;\n\tcase BEISCSI_BOOT_GET_SHANDLE:\n\t\tstatus = __beiscsi_mcc_compl_status(phba, tag, &wrb, NULL);\n\t\tif (!status) {\n\t\t\tboot_resp = embedded_payload(wrb);\n\t\t\tbs->s_handle = boot_resp->boot_session_handle;\n\t\t}\n\t\tif (bs->s_handle == BE_BOOT_INVALID_SHANDLE) {\n\t\t\tbs->action = BEISCSI_BOOT_REOPEN_SESS;\n\t\t\tbs->retry--;\n\t\t} else {\n\t\t\tbs->action = BEISCSI_BOOT_GET_SINFO;\n\t\t}\n\t\tbreak;\n\tcase BEISCSI_BOOT_GET_SINFO:\n\t\tstatus = __beiscsi_mcc_compl_status(phba, tag, NULL,\n\t\t\t\t\t\t    &bs->nonemb_cmd);\n\t\tif (!status) {\n\t\t\tsess_resp = bs->nonemb_cmd.va;\n\t\t\tmemcpy(&bs->boot_sess, &sess_resp->session_info,\n\t\t\t       sizeof(struct mgmt_session_info));\n\t\t\tbs->action = BEISCSI_BOOT_LOGOUT_SESS;\n\t\t} else {\n\t\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t      \"BG_%d : get boot session info error : 0x%x\\n\",\n\t\t\t\t      status);\n\t\t\tboot_work = 0;\n\t\t}\n\t\tdma_free_coherent(&phba->ctrl.pdev->dev, bs->nonemb_cmd.size,\n\t\t\t\t    bs->nonemb_cmd.va, bs->nonemb_cmd.dma);\n\t\tbs->nonemb_cmd.va = NULL;\n\t\tbreak;\n\tcase BEISCSI_BOOT_LOGOUT_SESS:\n\t\tstatus = __beiscsi_mcc_compl_status(phba, tag, &wrb, NULL);\n\t\tif (!status) {\n\t\t\tlogo_resp = embedded_payload(wrb);\n\t\t\tif (logo_resp->session_status != BE_SESS_STATUS_CLOSE) {\n\t\t\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t\t      \"BG_%d : FW boot session logout error : 0x%x\\n\",\n\t\t\t\t\t      logo_resp->session_status);\n\t\t\t}\n\t\t}\n\t\t \n\t\tbs->action = BEISCSI_BOOT_CREATE_KSET;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tbs->tag = 0;\n\tif (!bs->retry) {\n\t\tboot_work = 0;\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BG_%d : failed to setup boot target: status %d action %d\\n\",\n\t\t\t      status, bs->action);\n\t}\n\tif (!boot_work) {\n\t\t \n\t\tclear_bit(BEISCSI_HBA_BOOT_WORK, &phba->state);\n\t\treturn;\n\t}\n\tschedule_work(&phba->boot_work);\n}\n\n \nunsigned int beiscsi_boot_logout_sess(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_cmd_req_logout_fw_sess *req;\n\tunsigned int tag;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\treq = embedded_payload(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\n\t\t\t   OPCODE_ISCSI_INI_SESSION_LOGOUT_TARGET,\n\t\t\t   sizeof(struct be_cmd_req_logout_fw_sess));\n\t \n\treq->session_handle = phba->boot_struct.boot_sess.session_handle;\n\n\tphba->boot_struct.tag = tag;\n\tset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\n\tctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;\n\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\n\treturn tag;\n}\n \nunsigned int beiscsi_boot_reopen_sess(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_cmd_reopen_session_req *req;\n\tunsigned int tag;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\treq = embedded_payload(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\n\t\t\t   OPCODE_ISCSI_INI_DRIVER_REOPEN_ALL_SESSIONS,\n\t\t\t   sizeof(struct be_cmd_reopen_session_resp));\n\treq->reopen_type = BE_REOPEN_BOOT_SESSIONS;\n\treq->session_handle = BE_BOOT_INVALID_SHANDLE;\n\n\tphba->boot_struct.tag = tag;\n\tset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\n\tctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;\n\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn tag;\n}\n\n\n \nunsigned int beiscsi_boot_get_sinfo(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_cmd_get_session_req *req;\n\tstruct be_dma_mem *nonemb_cmd;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_sge *sge;\n\tunsigned int tag;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\tnonemb_cmd = &phba->boot_struct.nonemb_cmd;\n\tnonemb_cmd->size = sizeof(struct be_cmd_get_session_resp);\n\tnonemb_cmd->va = dma_alloc_coherent(&phba->ctrl.pdev->dev,\n\t\t\t\t\t      nonemb_cmd->size,\n\t\t\t\t\t      &nonemb_cmd->dma,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!nonemb_cmd->va) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\treq = nonemb_cmd->va;\n\tmemset(req, 0, sizeof(*req));\n\tsge = nonembedded_sgl(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\n\t\t\t   OPCODE_ISCSI_INI_SESSION_GET_A_SESSION,\n\t\t\t   sizeof(struct be_cmd_get_session_resp));\n\treq->session_handle = phba->boot_struct.s_handle;\n\tsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd->dma));\n\tsge->pa_lo = cpu_to_le32(nonemb_cmd->dma & 0xFFFFFFFF);\n\tsge->len = cpu_to_le32(nonemb_cmd->size);\n\n\tphba->boot_struct.tag = tag;\n\tset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\n\tctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;\n\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn tag;\n}\n\nunsigned int __beiscsi_boot_get_shandle(struct beiscsi_hba *phba, int async)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_cmd_get_boot_target_req *req;\n\tunsigned int tag;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\treq = embedded_payload(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\n\t\t\t   OPCODE_ISCSI_INI_BOOT_GET_BOOT_TARGET,\n\t\t\t   sizeof(struct be_cmd_get_boot_target_resp));\n\n\tif (async) {\n\t\tphba->boot_struct.tag = tag;\n\t\tset_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state);\n\t\tctrl->ptag_state[tag].cbfn = beiscsi_boot_process_compl;\n\t}\n\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn tag;\n}\n\n \nint beiscsi_boot_get_shandle(struct beiscsi_hba *phba, unsigned int *s_handle)\n{\n\tstruct be_cmd_get_boot_target_resp *boot_resp;\n\tstruct be_mcc_wrb *wrb;\n\tunsigned int tag;\n\tint rc;\n\n\t*s_handle = BE_BOOT_INVALID_SHANDLE;\n\t \n\ttag = __beiscsi_boot_get_shandle(phba, 0);\n\tif (!tag) {\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : Getting Boot Target Info Failed\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\trc = beiscsi_mccq_compl_wait(phba, tag, &wrb, NULL);\n\tif (rc) {\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\n\t\t\t    \"BG_%d : MBX CMD get_boot_target Failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tboot_resp = embedded_payload(wrb);\n\t \n\tif (!boot_resp->boot_session_count) {\n\t\t__beiscsi_log(phba, KERN_INFO,\n\t\t\t      \"BG_%d : No boot targets configured\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\t*s_handle = boot_resp->boot_session_handle;\n\treturn 1;\n}\n\n \nssize_t\nbeiscsi_drvr_ver_disp(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, BE_NAME \"\\n\");\n}\n\n \nssize_t\nbeiscsi_fw_ver_disp(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", phba->fw_ver_str);\n}\n\n \nssize_t\nbeiscsi_active_session_disp(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tuint16_t avlbl_cids = 0, ulp_num, len = 0, total_cids = 0;\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported)) {\n\t\t\tavlbl_cids = BEISCSI_ULP_AVLBL_CID(phba, ulp_num);\n\t\t\ttotal_cids = BEISCSI_GET_CID_COUNT(phba, ulp_num);\n\t\t\tlen += scnprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\t\t \"ULP%d : %d\\n\", ulp_num,\n\t\t\t\t\t (total_cids - avlbl_cids));\n\t\t} else\n\t\t\tlen += scnprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\t\t \"ULP%d : %d\\n\", ulp_num, 0);\n\t}\n\n\treturn len;\n}\n\n \nssize_t\nbeiscsi_free_session_disp(struct device *dev, struct device_attribute *attr,\n\t\t       char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tuint16_t ulp_num, len = 0;\n\n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (test_bit(ulp_num, (void *)&phba->fw_config.ulp_supported))\n\t\t\tlen += scnprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\t\t \"ULP%d : %d\\n\", ulp_num,\n\t\t\t\t\t BEISCSI_ULP_AVLBL_CID(phba, ulp_num));\n\t\telse\n\t\t\tlen += scnprintf(buf+len, PAGE_SIZE - len,\n\t\t\t\t\t \"ULP%d : %d\\n\", ulp_num, 0);\n\t}\n\n\treturn len;\n}\n\n \nssize_t\nbeiscsi_adap_family_disp(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tuint16_t dev_id = 0;\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\n\tdev_id = phba->pcidev->device;\n\tswitch (dev_id) {\n\tcase BE_DEVICE_ID1:\n\tcase OC_DEVICE_ID1:\n\tcase OC_DEVICE_ID2:\n\t\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\t\"Obsolete/Unsupported BE2 Adapter Family\\n\");\n\tcase BE_DEVICE_ID2:\n\tcase OC_DEVICE_ID3:\n\t\treturn snprintf(buf, PAGE_SIZE, \"BE3-R Adapter Family\\n\");\n\tcase OC_SKH_ID1:\n\t\treturn snprintf(buf, PAGE_SIZE, \"Skyhawk-R Adapter Family\\n\");\n\tdefault:\n\t\treturn snprintf(buf, PAGE_SIZE,\n\t\t\t\t\"Unknown Adapter Family: 0x%x\\n\", dev_id);\n\t}\n}\n\n \nssize_t\nbeiscsi_phys_port_disp(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(dev);\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\n\treturn snprintf(buf, PAGE_SIZE, \"Port Identifier : %u\\n\",\n\t\t\tphba->fw_config.phys_port);\n}\n\nvoid beiscsi_offload_cxn_v0(struct beiscsi_offload_params *params,\n\t\t\t     struct wrb_handle *pwrb_handle,\n\t\t\t     struct be_mem_descriptor *mem_descr,\n\t\t\t     struct hwi_wrb_context *pwrb_context)\n{\n\tstruct iscsi_wrb *pwrb = pwrb_handle->pwrb;\n\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\n\t\t      max_send_data_segment_length, pwrb,\n\t\t      params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      max_send_data_segment_length) / 32]);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, type, pwrb,\n\t\t      BE_TGT_CTX_UPDT_CMD);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\n\t\t      first_burst_length,\n\t\t      pwrb,\n\t\t      params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      first_burst_length) / 32]);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, erl, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      erl) / 32] & OFFLD_PARAMS_ERL));\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, dde, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t       dde) / 32] & OFFLD_PARAMS_DDE) >> 2);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, hde, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      hde) / 32] & OFFLD_PARAMS_HDE) >> 3);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, ir2t, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      ir2t) / 32] & OFFLD_PARAMS_IR2T) >> 4);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, imd, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      imd) / 32] & OFFLD_PARAMS_IMD) >> 5);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, stat_sn,\n\t\t      pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      exp_statsn) / 32] + 1));\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, wrb_idx,\n\t\t      pwrb, pwrb_handle->wrb_index);\n\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\n\t\t      max_burst_length, pwrb, params->dw[offsetof\n\t\t      (struct amap_beiscsi_offload_params,\n\t\t      max_burst_length) / 32]);\n\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, ptr2nextwrb,\n\t\t      pwrb, pwrb_handle->wrb_index);\n\tif (pwrb_context->plast_wrb)\n\t\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\n\t\t\t      ptr2nextwrb,\n\t\t\t      pwrb_context->plast_wrb,\n\t\t\t      pwrb_handle->wrb_index);\n\tpwrb_context->plast_wrb = pwrb;\n\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\n\t\t      session_state, pwrb, 0);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, compltonack,\n\t\t      pwrb, 1);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, notpredblq,\n\t\t      pwrb, 0);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb, mode, pwrb,\n\t\t      0);\n\n\tmem_descr += ISCSI_MEM_GLOBAL_HEADER;\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\n\t\t      pad_buffer_addr_hi, pwrb,\n\t\t      mem_descr->mem_array[0].bus_address.u.a32.address_hi);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb,\n\t\t      pad_buffer_addr_lo, pwrb,\n\t\t      mem_descr->mem_array[0].bus_address.u.a32.address_lo);\n}\n\nvoid beiscsi_offload_cxn_v2(struct beiscsi_offload_params *params,\n\t\t\t     struct wrb_handle *pwrb_handle,\n\t\t\t     struct hwi_wrb_context *pwrb_context)\n{\n\tstruct iscsi_wrb *pwrb = pwrb_handle->pwrb;\n\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      max_burst_length, pwrb, params->dw[offsetof\n\t\t      (struct amap_beiscsi_offload_params,\n\t\t      max_burst_length) / 32]);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      type, pwrb,\n\t\t      BE_TGT_CTX_UPDT_CMD);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      ptr2nextwrb,\n\t\t      pwrb, pwrb_handle->wrb_index);\n\tif (pwrb_context->plast_wrb)\n\t\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t\t      ptr2nextwrb,\n\t\t\t      pwrb_context->plast_wrb,\n\t\t\t      pwrb_handle->wrb_index);\n\tpwrb_context->plast_wrb = pwrb;\n\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, wrb_idx,\n\t\t      pwrb, pwrb_handle->wrb_index);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      max_send_data_segment_length, pwrb,\n\t\t      params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      max_send_data_segment_length) / 32]);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      first_burst_length, pwrb,\n\t\t      params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      first_burst_length) / 32]);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      max_recv_dataseg_len, pwrb,\n\t\t      params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      max_recv_data_segment_length) / 32]);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      max_cxns, pwrb, BEISCSI_MAX_CXNS);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, erl, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      erl) / 32] & OFFLD_PARAMS_ERL));\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, dde, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      dde) / 32] & OFFLD_PARAMS_DDE) >> 2);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, hde, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      hde) / 32] & OFFLD_PARAMS_HDE) >> 3);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      ir2t, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      ir2t) / 32] & OFFLD_PARAMS_IR2T) >> 4);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, imd, pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      imd) / 32] & OFFLD_PARAMS_IMD) >> 5);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      data_seq_inorder,\n\t\t      pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      data_seq_inorder) / 32] &\n\t\t      OFFLD_PARAMS_DATA_SEQ_INORDER) >> 6);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2,\n\t\t      pdu_seq_inorder,\n\t\t      pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      pdu_seq_inorder) / 32] &\n\t\t      OFFLD_PARAMS_PDU_SEQ_INORDER) >> 7);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, max_r2t,\n\t\t      pwrb,\n\t\t      (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      max_r2t) / 32] &\n\t\t      OFFLD_PARAMS_MAX_R2T) >> 8);\n\tAMAP_SET_BITS(struct amap_iscsi_target_context_update_wrb_v2, stat_sn,\n\t\t      pwrb,\n\t\t     (params->dw[offsetof(struct amap_beiscsi_offload_params,\n\t\t      exp_statsn) / 32] + 1));\n}\n\nunsigned int beiscsi_invalidate_cxn(struct beiscsi_hba *phba,\n\t\t\t\t    struct beiscsi_endpoint *beiscsi_ep)\n{\n\tstruct be_invalidate_connection_params_in *req;\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb;\n\tunsigned int tag = 0;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\treq = embedded_payload(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(union be_invalidate_connection_params),\n\t\t\t   true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI_INI,\n\t\t\t   OPCODE_ISCSI_INI_DRIVER_INVALIDATE_CONNECTION,\n\t\t\t   sizeof(*req));\n\treq->session_handle = beiscsi_ep->fw_handle;\n\treq->cid = beiscsi_ep->ep_cid;\n\tif (beiscsi_ep->conn)\n\t\treq->cleanup_type = BE_CLEANUP_TYPE_INVALIDATE;\n\telse\n\t\treq->cleanup_type = BE_CLEANUP_TYPE_ISSUE_TCP_RST;\n\t \n\treq->save_cfg = 0;\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn tag;\n}\n\nunsigned int beiscsi_upload_cxn(struct beiscsi_hba *phba,\n\t\t\t\tstruct beiscsi_endpoint *beiscsi_ep)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_tcp_upload_params_in *req;\n\tunsigned int tag;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\treq = embedded_payload(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(union be_tcp_upload_params), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_COMMON_TCP_UPLOAD,\n\t\t\t   OPCODE_COMMON_TCP_UPLOAD, sizeof(*req));\n\treq->id = beiscsi_ep->ep_cid;\n\tif (beiscsi_ep->conn)\n\t\treq->upload_type = BE_UPLOAD_TYPE_GRACEFUL;\n\telse\n\t\treq->upload_type = BE_UPLOAD_TYPE_ABORT;\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn tag;\n}\n\nint beiscsi_mgmt_invalidate_icds(struct beiscsi_hba *phba,\n\t\t\t\t struct invldt_cmd_tbl *inv_tbl,\n\t\t\t\t unsigned int nents)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct invldt_cmds_params_in *req;\n\tstruct be_dma_mem nonemb_cmd;\n\tstruct be_mcc_wrb *wrb;\n\tunsigned int i, tag;\n\tstruct be_sge *sge;\n\tint rc;\n\n\tif (!nents || nents > BE_INVLDT_CMD_TBL_SZ)\n\t\treturn -EINVAL;\n\n\tnonemb_cmd.size = sizeof(union be_invldt_cmds_params);\n\tnonemb_cmd.va = dma_alloc_coherent(&phba->ctrl.pdev->dev,\n\t\t\t\t\t   nonemb_cmd.size, &nonemb_cmd.dma,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!nonemb_cmd.va) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_EH,\n\t\t\t    \"BM_%d : invldt_cmds_params alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\tdma_free_coherent(&phba->ctrl.pdev->dev, nonemb_cmd.size,\n\t\t\t\t    nonemb_cmd.va, nonemb_cmd.dma);\n\t\treturn -ENOMEM;\n\t}\n\n\treq = nonemb_cmd.va;\n\tbe_wrb_hdr_prepare(wrb, nonemb_cmd.size, false, 1);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\tOPCODE_COMMON_ISCSI_ERROR_RECOVERY_INVALIDATE_COMMANDS,\n\t\t\tsizeof(*req));\n\treq->ref_handle = 0;\n\treq->cleanup_type = CMD_ISCSI_COMMAND_INVALIDATE;\n\tfor (i = 0; i < nents; i++) {\n\t\treq->table[i].icd = inv_tbl[i].icd;\n\t\treq->table[i].cid = inv_tbl[i].cid;\n\t\treq->icd_count++;\n\t}\n\tsge = nonembedded_sgl(wrb);\n\tsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));\n\tsge->pa_lo = cpu_to_le32(lower_32_bits(nonemb_cmd.dma));\n\tsge->len = cpu_to_le32(nonemb_cmd.size);\n\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\n\trc = beiscsi_mccq_compl_wait(phba, tag, NULL, &nonemb_cmd);\n\tif (rc != -EBUSY)\n\t\tdma_free_coherent(&phba->ctrl.pdev->dev, nonemb_cmd.size,\n\t\t\t\t    nonemb_cmd.va, nonemb_cmd.dma);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}