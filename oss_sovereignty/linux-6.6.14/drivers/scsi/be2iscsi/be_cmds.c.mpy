{
  "module_name": "be_cmds.c",
  "hash_id": "09fd31e277ed3fc6027ec9a15b5638a038f228649a807cfba96c18404e058610",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/be2iscsi/be_cmds.c",
  "human_readable_source": "\n \n\n#include <scsi/iscsi_proto.h>\n\n#include \"be_main.h\"\n#include \"be.h\"\n#include \"be_mgmt.h\"\n\n \nstatic const char * const desc_ue_status_low[] = {\n\t\"CEV\",\n\t\"CTX\",\n\t\"DBUF\",\n\t\"ERX\",\n\t\"Host\",\n\t\"MPU\",\n\t\"NDMA\",\n\t\"PTC \",\n\t\"RDMA \",\n\t\"RXF \",\n\t\"RXIPS \",\n\t\"RXULP0 \",\n\t\"RXULP1 \",\n\t\"RXULP2 \",\n\t\"TIM \",\n\t\"TPOST \",\n\t\"TPRE \",\n\t\"TXIPS \",\n\t\"TXULP0 \",\n\t\"TXULP1 \",\n\t\"UC \",\n\t\"WDMA \",\n\t\"TXULP2 \",\n\t\"HOST1 \",\n\t\"P0_OB_LINK \",\n\t\"P1_OB_LINK \",\n\t\"HOST_GPIO \",\n\t\"MBOX \",\n\t\"AXGMAC0\",\n\t\"AXGMAC1\",\n\t\"JTAG\",\n\t\"MPU_INTPEND\"\n};\n\n \nstatic const char * const desc_ue_status_hi[] = {\n\t\"LPCMEMHOST\",\n\t\"MGMT_MAC\",\n\t\"PCS0ONLINE\",\n\t\"MPU_IRAM\",\n\t\"PCS1ONLINE\",\n\t\"PCTL0\",\n\t\"PCTL1\",\n\t\"PMEM\",\n\t\"RR\",\n\t\"TXPB\",\n\t\"RXPP\",\n\t\"XAUI\",\n\t\"TXP\",\n\t\"ARM\",\n\t\"IPC\",\n\t\"HOST2\",\n\t\"HOST3\",\n\t\"HOST4\",\n\t\"HOST5\",\n\t\"HOST6\",\n\t\"HOST7\",\n\t\"HOST8\",\n\t\"HOST9\",\n\t\"NETC\",\n\t\"Unknown\",\n\t\"Unknown\",\n\t\"Unknown\",\n\t\"Unknown\",\n\t\"Unknown\",\n\t\"Unknown\",\n\t\"Unknown\",\n\t\"Unknown\"\n};\n\nstruct be_mcc_wrb *alloc_mcc_wrb(struct beiscsi_hba *phba,\n\t\t\t\t unsigned int *ref_tag)\n{\n\tstruct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;\n\tstruct be_mcc_wrb *wrb = NULL;\n\tunsigned int tag;\n\n\tspin_lock(&phba->ctrl.mcc_lock);\n\tif (mccq->used == mccq->len) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT |\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t\t    \"BC_%d : MCC queue full: WRB used %u tag avail %u\\n\",\n\t\t\t    mccq->used, phba->ctrl.mcc_tag_available);\n\t\tgoto alloc_failed;\n\t}\n\n\tif (!phba->ctrl.mcc_tag_available)\n\t\tgoto alloc_failed;\n\n\ttag = phba->ctrl.mcc_tag[phba->ctrl.mcc_alloc_index];\n\tif (!tag) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT |\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t\t    \"BC_%d : MCC tag 0 allocated: tag avail %u alloc index %u\\n\",\n\t\t\t    phba->ctrl.mcc_tag_available,\n\t\t\t    phba->ctrl.mcc_alloc_index);\n\t\tgoto alloc_failed;\n\t}\n\n\t \n\t*ref_tag = tag;\n\tphba->ctrl.mcc_tag[phba->ctrl.mcc_alloc_index] = 0;\n\tphba->ctrl.mcc_tag_status[tag] = 0;\n\tphba->ctrl.ptag_state[tag].tag_state = 0;\n\tphba->ctrl.ptag_state[tag].cbfn = NULL;\n\tphba->ctrl.mcc_tag_available--;\n\tif (phba->ctrl.mcc_alloc_index == (MAX_MCC_CMD - 1))\n\t\tphba->ctrl.mcc_alloc_index = 0;\n\telse\n\t\tphba->ctrl.mcc_alloc_index++;\n\n\twrb = queue_head_node(mccq);\n\tmemset(wrb, 0, sizeof(*wrb));\n\twrb->tag0 = tag;\n\twrb->tag0 |= (mccq->head << MCC_Q_WRB_IDX_SHIFT) & MCC_Q_WRB_IDX_MASK;\n\tqueue_head_inc(mccq);\n\tmccq->used++;\n\nalloc_failed:\n\tspin_unlock(&phba->ctrl.mcc_lock);\n\treturn wrb;\n}\n\nvoid free_mcc_wrb(struct be_ctrl_info *ctrl, unsigned int tag)\n{\n\tstruct be_queue_info *mccq = &ctrl->mcc_obj.q;\n\n\tspin_lock(&ctrl->mcc_lock);\n\ttag = tag & MCC_Q_CMD_TAG_MASK;\n\tctrl->mcc_tag[ctrl->mcc_free_index] = tag;\n\tif (ctrl->mcc_free_index == (MAX_MCC_CMD - 1))\n\t\tctrl->mcc_free_index = 0;\n\telse\n\t\tctrl->mcc_free_index++;\n\tctrl->mcc_tag_available++;\n\tmccq->used--;\n\tspin_unlock(&ctrl->mcc_lock);\n}\n\n \nint __beiscsi_mcc_compl_status(struct beiscsi_hba *phba,\n\t\t\t       unsigned int tag,\n\t\t\t       struct be_mcc_wrb **wrb,\n\t\t\t       struct be_dma_mem *mbx_cmd_mem)\n{\n\tstruct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;\n\tuint16_t status = 0, addl_status = 0, wrb_num = 0;\n\tstruct be_cmd_resp_hdr *mbx_resp_hdr;\n\tstruct be_cmd_req_hdr *mbx_hdr;\n\tstruct be_mcc_wrb *temp_wrb;\n\tuint32_t mcc_tag_status;\n\tint rc = 0;\n\n\tmcc_tag_status = phba->ctrl.mcc_tag_status[tag];\n\tstatus = (mcc_tag_status & CQE_STATUS_MASK);\n\taddl_status = ((mcc_tag_status & CQE_STATUS_ADDL_MASK) >>\n\t\t\tCQE_STATUS_ADDL_SHIFT);\n\n\tif (mbx_cmd_mem) {\n\t\tmbx_hdr = (struct be_cmd_req_hdr *)mbx_cmd_mem->va;\n\t} else {\n\t\twrb_num = (mcc_tag_status & CQE_STATUS_WRB_MASK) >>\n\t\t\t  CQE_STATUS_WRB_SHIFT;\n\t\ttemp_wrb = (struct be_mcc_wrb *)queue_get_wrb(mccq, wrb_num);\n\t\tmbx_hdr = embedded_payload(temp_wrb);\n\n\t\tif (wrb)\n\t\t\t*wrb = temp_wrb;\n\t}\n\n\tif (status || addl_status) {\n\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t    BEISCSI_LOG_INIT | BEISCSI_LOG_EH |\n\t\t\t    BEISCSI_LOG_CONFIG,\n\t\t\t    \"BC_%d : MBX Cmd Failed for Subsys : %d Opcode : %d with Status : %d and Extd_Status : %d\\n\",\n\t\t\t    mbx_hdr->subsystem, mbx_hdr->opcode,\n\t\t\t    status, addl_status);\n\t\trc = -EIO;\n\t\tif (status == MCC_STATUS_INSUFFICIENT_BUFFER) {\n\t\t\tmbx_resp_hdr = (struct be_cmd_resp_hdr *)mbx_hdr;\n\t\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t\t    BEISCSI_LOG_INIT | BEISCSI_LOG_EH |\n\t\t\t\t    BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BC_%d : Insufficient Buffer Error Resp_Len : %d Actual_Resp_Len : %d\\n\",\n\t\t\t\t    mbx_resp_hdr->response_length,\n\t\t\t\t    mbx_resp_hdr->actual_resp_len);\n\t\t\trc = -EAGAIN;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n \nint beiscsi_mccq_compl_wait(struct beiscsi_hba *phba,\n\t\t\t    unsigned int tag,\n\t\t\t    struct be_mcc_wrb **wrb,\n\t\t\t    struct be_dma_mem *mbx_cmd_mem)\n{\n\tint rc = 0;\n\n\tif (!tag || tag > MAX_MCC_CMD) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BC_%d : invalid tag %u\\n\", tag);\n\t\treturn -EINVAL;\n\t}\n\n\tif (beiscsi_hba_in_error(phba)) {\n\t\tclear_bit(MCC_TAG_STATE_RUNNING,\n\t\t\t  &phba->ctrl.ptag_state[tag].tag_state);\n\t\treturn -EIO;\n\t}\n\n\t \n\trc = wait_event_interruptible_timeout(phba->ctrl.mcc_wait[tag],\n\t\t\t\t\t      phba->ctrl.mcc_tag_status[tag],\n\t\t\t\t\t      msecs_to_jiffies(\n\t\t\t\t\t\tBEISCSI_HOST_MBX_TIMEOUT));\n\t \n\tif (!test_bit(BEISCSI_HBA_ONLINE, &phba->state)) {\n\t\tclear_bit(MCC_TAG_STATE_RUNNING,\n\t\t\t  &phba->ctrl.ptag_state[tag].tag_state);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (rc <= 0) {\n\t\tstruct be_dma_mem *tag_mem;\n\n\t\t \n\t\ttag_mem = &phba->ctrl.ptag_state[tag].tag_mem_state;\n\t\tif (mbx_cmd_mem) {\n\t\t\ttag_mem->size = mbx_cmd_mem->size;\n\t\t\ttag_mem->va = mbx_cmd_mem->va;\n\t\t\ttag_mem->dma = mbx_cmd_mem->dma;\n\t\t} else\n\t\t\ttag_mem->size = 0;\n\n\t\t \n\t\twmb();\n\t\tset_bit(MCC_TAG_STATE_TIMEOUT,\n\t\t\t\t&phba->ctrl.ptag_state[tag].tag_state);\n\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_INIT | BEISCSI_LOG_EH |\n\t\t\t    BEISCSI_LOG_CONFIG,\n\t\t\t    \"BC_%d : MBX Cmd Completion timed out\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\trc = __beiscsi_mcc_compl_status(phba, tag, wrb, mbx_cmd_mem);\n\n\tfree_mcc_wrb(&phba->ctrl, tag);\n\treturn rc;\n}\n\n \nstatic int beiscsi_process_mbox_compl(struct be_ctrl_info *ctrl,\n\t\t\t\t      struct be_mcc_compl *compl)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tstruct be_cmd_req_hdr *hdr = embedded_payload(wrb);\n\tu16 compl_status, extd_status;\n\n\t \n\tif (!compl->flags) {\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t\tBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t\t\t\"BC_%d : BMBX busy, no completion\\n\");\n\t\treturn -EBUSY;\n\t}\n\tcompl->flags = le32_to_cpu(compl->flags);\n\tWARN_ON((compl->flags & CQE_FLAGS_VALID_MASK) == 0);\n\n\t \n\tbe_dws_le_to_cpu(compl, 4);\n\tcompl_status = (compl->status >> CQE_STATUS_COMPL_SHIFT) &\n\t\tCQE_STATUS_COMPL_MASK;\n\textd_status = (compl->status >> CQE_STATUS_EXTD_SHIFT) &\n\t\tCQE_STATUS_EXTD_MASK;\n\t \n\tcompl->flags = 0;\n\n\tif (compl_status == MCC_STATUS_SUCCESS)\n\t\treturn 0;\n\n\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t    \"BC_%d : error in cmd completion: Subsystem : %d Opcode : %d status(compl/extd)=%d/%d\\n\",\n\t\t    hdr->subsystem, hdr->opcode, compl_status, extd_status);\n\treturn compl_status;\n}\n\nstatic void beiscsi_process_async_link(struct beiscsi_hba *phba,\n\t\t\t\t       struct be_mcc_compl *compl)\n{\n\tstruct be_async_event_link_state *evt;\n\n\tevt = (struct be_async_event_link_state *)compl;\n\n\tphba->port_speed = evt->port_speed;\n\t \n\tif (evt->port_link_status & BE_ASYNC_LINK_UP_MASK) {\n\t\tset_bit(BEISCSI_HBA_LINK_UP, &phba->state);\n\t\tif (test_bit(BEISCSI_HBA_BOOT_FOUND, &phba->state))\n\t\t\tbeiscsi_start_boot_work(phba, BE_BOOT_INVALID_SHANDLE);\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BC_%d : Link Up on Port %d tag 0x%x\\n\",\n\t\t\t      evt->physical_port, evt->event_tag);\n\t} else {\n\t\tclear_bit(BEISCSI_HBA_LINK_UP, &phba->state);\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BC_%d : Link Down on Port %d tag 0x%x\\n\",\n\t\t\t      evt->physical_port, evt->event_tag);\n\t\tiscsi_host_for_each_session(phba->shost,\n\t\t\t\t\t    beiscsi_session_fail);\n\t}\n}\n\nstatic char *beiscsi_port_misconf_event_msg[] = {\n\t\"Physical Link is functional.\",\n\t\"Optics faulted/incorrectly installed/not installed - Reseat optics, if issue not resolved, replace.\",\n\t\"Optics of two types installed - Remove one optic or install matching pair of optics.\",\n\t\"Incompatible optics - Replace with compatible optics for card to function.\",\n\t\"Unqualified optics - Replace with Avago optics for Warranty and Technical Support.\",\n\t\"Uncertified optics - Replace with Avago Certified optics to enable link operation.\"\n};\n\nstatic void beiscsi_process_async_sli(struct beiscsi_hba *phba,\n\t\t\t\t      struct be_mcc_compl *compl)\n{\n\tstruct be_async_event_sli *async_sli;\n\tu8 evt_type, state, old_state, le;\n\tchar *sev = KERN_WARNING;\n\tchar *msg = NULL;\n\n\tevt_type = compl->flags >> ASYNC_TRAILER_EVENT_TYPE_SHIFT;\n\tevt_type &= ASYNC_TRAILER_EVENT_TYPE_MASK;\n\n\t \n\tif (evt_type != ASYNC_SLI_EVENT_TYPE_MISCONFIGURED)\n\t\treturn;\n\n\tasync_sli = (struct be_async_event_sli *)compl;\n\tstate = async_sli->event_data1 >>\n\t\t (phba->fw_config.phys_port * 8) & 0xff;\n\tle = async_sli->event_data2 >>\n\t\t (phba->fw_config.phys_port * 8) & 0xff;\n\n\told_state = phba->optic_state;\n\tphba->optic_state = state;\n\n\tif (state >= ARRAY_SIZE(beiscsi_port_misconf_event_msg)) {\n\t\t \n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t    \"BC_%d : Port %c: Unrecognized optic state 0x%x\\n\",\n\t\t\t    phba->port_name, async_sli->event_data1);\n\t\treturn;\n\t}\n\n\tif (ASYNC_SLI_LINK_EFFECT_VALID(le)) {\n\t\t \n\t\tif (state > 3)\n\t\t\tmsg = (ASYNC_SLI_LINK_EFFECT_STATE(le)) ?\n\t\t\t\t\" Link is non-operational.\" :\n\t\t\t\t\" Link is operational.\";\n\t\t \n\t\tif (ASYNC_SLI_LINK_EFFECT_SEV(le) == 1)\n\t\t\tsev = KERN_INFO;\n\t\t \n\t\tif (ASYNC_SLI_LINK_EFFECT_SEV(le) == 2)\n\t\t\tsev = KERN_ERR;\n\t}\n\n\tif (old_state != phba->optic_state)\n\t\t__beiscsi_log(phba, sev, \"BC_%d : Port %c: %s%s\\n\",\n\t\t\t      phba->port_name,\n\t\t\t      beiscsi_port_misconf_event_msg[state],\n\t\t\t      !msg ? \"\" : msg);\n}\n\nvoid beiscsi_process_async_event(struct beiscsi_hba *phba,\n\t\t\t\tstruct be_mcc_compl *compl)\n{\n\tchar *sev = KERN_INFO;\n\tu8 evt_code;\n\n\t \n\tevt_code = compl->flags >> ASYNC_TRAILER_EVENT_CODE_SHIFT;\n\tevt_code &= ASYNC_TRAILER_EVENT_CODE_MASK;\n\tswitch (evt_code) {\n\tcase ASYNC_EVENT_CODE_LINK_STATE:\n\t\tbeiscsi_process_async_link(phba, compl);\n\t\tbreak;\n\tcase ASYNC_EVENT_CODE_ISCSI:\n\t\tif (test_bit(BEISCSI_HBA_BOOT_FOUND, &phba->state))\n\t\t\tbeiscsi_start_boot_work(phba, BE_BOOT_INVALID_SHANDLE);\n\t\tsev = KERN_ERR;\n\t\tbreak;\n\tcase ASYNC_EVENT_CODE_SLI:\n\t\tbeiscsi_process_async_sli(phba, compl);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tsev = KERN_ERR;\n\t}\n\n\tbeiscsi_log(phba, sev, BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t    \"BC_%d : ASYNC Event %x: status 0x%08x flags 0x%08x\\n\",\n\t\t    evt_code, compl->status, compl->flags);\n}\n\nint beiscsi_process_mcc_compl(struct be_ctrl_info *ctrl,\n\t\t\t      struct be_mcc_compl *compl)\n{\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tu16 compl_status, extd_status;\n\tstruct be_dma_mem *tag_mem;\n\tunsigned int tag, wrb_idx;\n\n\tbe_dws_le_to_cpu(compl, 4);\n\ttag = (compl->tag0 & MCC_Q_CMD_TAG_MASK);\n\twrb_idx = (compl->tag0 & CQE_STATUS_WRB_MASK) >> CQE_STATUS_WRB_SHIFT;\n\n\tif (!test_bit(MCC_TAG_STATE_RUNNING,\n\t\t      &ctrl->ptag_state[tag].tag_state)) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_MBOX |\n\t\t\t    BEISCSI_LOG_INIT | BEISCSI_LOG_CONFIG,\n\t\t\t    \"BC_%d : MBX cmd completed but not posted\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tclear_bit(MCC_TAG_STATE_RUNNING, &ctrl->ptag_state[tag].tag_state);\n\n\tif (test_bit(MCC_TAG_STATE_TIMEOUT, &ctrl->ptag_state[tag].tag_state)) {\n\t\tbeiscsi_log(phba, KERN_WARNING,\n\t\t\t    BEISCSI_LOG_MBOX | BEISCSI_LOG_INIT |\n\t\t\t    BEISCSI_LOG_CONFIG,\n\t\t\t    \"BC_%d : MBX Completion for timeout Command from FW\\n\");\n\t\t \n\t\ttag_mem = &ctrl->ptag_state[tag].tag_mem_state;\n\t\tif (tag_mem->size) {\n\t\t\tdma_free_coherent(&ctrl->pdev->dev, tag_mem->size,\n\t\t\t\t\ttag_mem->va, tag_mem->dma);\n\t\t\ttag_mem->size = 0;\n\t\t}\n\t\tfree_mcc_wrb(ctrl, tag);\n\t\treturn 0;\n\t}\n\n\tcompl_status = (compl->status >> CQE_STATUS_COMPL_SHIFT) &\n\t\t       CQE_STATUS_COMPL_MASK;\n\textd_status = (compl->status >> CQE_STATUS_EXTD_SHIFT) &\n\t\t      CQE_STATUS_EXTD_MASK;\n\t \n\tctrl->mcc_tag_status[tag] = CQE_VALID_MASK;\n\tctrl->mcc_tag_status[tag] |= (wrb_idx << CQE_STATUS_WRB_SHIFT);\n\tctrl->mcc_tag_status[tag] |= (extd_status << CQE_STATUS_ADDL_SHIFT) &\n\t\t\t\t     CQE_STATUS_ADDL_MASK;\n\tctrl->mcc_tag_status[tag] |= (compl_status & CQE_STATUS_MASK);\n\n\tif (test_bit(MCC_TAG_STATE_ASYNC, &ctrl->ptag_state[tag].tag_state)) {\n\t\tif (ctrl->ptag_state[tag].cbfn)\n\t\t\tctrl->ptag_state[tag].cbfn(phba, tag);\n\t\telse\n\t\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t      \"BC_%d : MBX ASYNC command with no callback\\n\");\n\t\tfree_mcc_wrb(ctrl, tag);\n\t\treturn 0;\n\t}\n\n\tif (test_bit(MCC_TAG_STATE_IGNORE, &ctrl->ptag_state[tag].tag_state)) {\n\t\t \n\t\t__beiscsi_mcc_compl_status(phba, tag, NULL, NULL);\n\t\tfree_mcc_wrb(ctrl, tag);\n\t\treturn 0;\n\t}\n\n\twake_up_interruptible(&ctrl->mcc_wait[tag]);\n\treturn 0;\n}\n\nvoid be_mcc_notify(struct beiscsi_hba *phba, unsigned int tag)\n{\n\tstruct be_queue_info *mccq = &phba->ctrl.mcc_obj.q;\n\tu32 val = 0;\n\n\tset_bit(MCC_TAG_STATE_RUNNING, &phba->ctrl.ptag_state[tag].tag_state);\n\tval |= mccq->id & DB_MCCQ_RING_ID_MASK;\n\tval |= 1 << DB_MCCQ_NUM_POSTED_SHIFT;\n\t \n\twmb();\n\tiowrite32(val, phba->db_va + DB_MCCQ_OFFSET);\n}\n\n \nstatic int be_mbox_db_ready_poll(struct be_ctrl_info *ctrl)\n{\n\t \n#define BEISCSI_MBX_RDY_BIT_TIMEOUT\t30000\n\tvoid __iomem *db = ctrl->db + MPU_MAILBOX_DB_OFFSET;\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tunsigned long timeout;\n\tu32 ready;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(BEISCSI_MBX_RDY_BIT_TIMEOUT);\n\tdo {\n\t\tif (beiscsi_hba_in_error(phba))\n\t\t\treturn -EIO;\n\n\t\tready = ioread32(db);\n\t\tif (ready == 0xffffffff)\n\t\t\treturn -EIO;\n\n\t\tready &= MPU_MAILBOX_DB_RDY_MASK;\n\t\tif (ready)\n\t\t\treturn 0;\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\t \n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(1));\n\t} while (!ready);\n\n\tbeiscsi_log(phba, KERN_ERR,\n\t\t\tBEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t\t\"BC_%d : FW Timed Out\\n\");\n\tset_bit(BEISCSI_HBA_FW_TIMEOUT, &phba->state);\n\treturn -EBUSY;\n}\n\n \nstatic int be_mbox_notify(struct be_ctrl_info *ctrl)\n{\n\tint status;\n\tu32 val = 0;\n\tvoid __iomem *db = ctrl->db + MPU_MAILBOX_DB_OFFSET;\n\tstruct be_dma_mem *mbox_mem = &ctrl->mbox_mem;\n\tstruct be_mcc_mailbox *mbox = mbox_mem->va;\n\n\tstatus = be_mbox_db_ready_poll(ctrl);\n\tif (status)\n\t\treturn status;\n\n\tval &= ~MPU_MAILBOX_DB_RDY_MASK;\n\tval |= MPU_MAILBOX_DB_HI_MASK;\n\tval |= (upper_32_bits(mbox_mem->dma) >> 2) << 2;\n\tiowrite32(val, db);\n\n\tstatus = be_mbox_db_ready_poll(ctrl);\n\tif (status)\n\t\treturn status;\n\n\tval = 0;\n\tval &= ~MPU_MAILBOX_DB_RDY_MASK;\n\tval &= ~MPU_MAILBOX_DB_HI_MASK;\n\tval |= (u32) (mbox_mem->dma >> 4) << 2;\n\tiowrite32(val, db);\n\n\tstatus = be_mbox_db_ready_poll(ctrl);\n\tif (status)\n\t\treturn status;\n\n\t \n\tudelay(1);\n\n\tstatus = beiscsi_process_mbox_compl(ctrl, &mbox->compl);\n\treturn status;\n}\n\nvoid be_wrb_hdr_prepare(struct be_mcc_wrb *wrb, u32 payload_len,\n\t\t\tbool embedded, u8 sge_cnt)\n{\n\tif (embedded)\n\t\twrb->emb_sgecnt_special |= MCC_WRB_EMBEDDED_MASK;\n\telse\n\t\twrb->emb_sgecnt_special |= (sge_cnt & MCC_WRB_SGE_CNT_MASK) <<\n\t\t\t\t\t   MCC_WRB_SGE_CNT_SHIFT;\n\twrb->payload_length = payload_len;\n\tbe_dws_cpu_to_le(wrb, 8);\n}\n\nvoid be_cmd_hdr_prepare(struct be_cmd_req_hdr *req_hdr,\n\t\t\tu8 subsystem, u8 opcode, u32 cmd_len)\n{\n\treq_hdr->opcode = opcode;\n\treq_hdr->subsystem = subsystem;\n\treq_hdr->request_length = cpu_to_le32(cmd_len - sizeof(*req_hdr));\n\treq_hdr->timeout = BEISCSI_FW_MBX_TIMEOUT;\n}\n\nstatic void be_cmd_page_addrs_prepare(struct phys_addr *pages, u32 max_pages,\n\t\t\t\t\t\t\tstruct be_dma_mem *mem)\n{\n\tint i, buf_pages;\n\tu64 dma = (u64) mem->dma;\n\n\tbuf_pages = min(PAGES_4K_SPANNED(mem->va, mem->size), max_pages);\n\tfor (i = 0; i < buf_pages; i++) {\n\t\tpages[i].lo = cpu_to_le32(dma & 0xFFFFFFFF);\n\t\tpages[i].hi = cpu_to_le32(upper_32_bits(dma));\n\t\tdma += PAGE_SIZE_4K;\n\t}\n}\n\nstatic u32 eq_delay_to_mult(u32 usec_delay)\n{\n#define MAX_INTR_RATE 651042\n\tconst u32 round = 10;\n\tu32 multiplier;\n\n\tif (usec_delay == 0)\n\t\tmultiplier = 0;\n\telse {\n\t\tu32 interrupt_rate = 1000000 / usec_delay;\n\t\tif (interrupt_rate == 0)\n\t\t\tmultiplier = 1023;\n\t\telse {\n\t\t\tmultiplier = (MAX_INTR_RATE - interrupt_rate) * round;\n\t\t\tmultiplier /= interrupt_rate;\n\t\t\tmultiplier = (multiplier + round / 2) / round;\n\t\t\tmultiplier = min(multiplier, (u32) 1023);\n\t\t}\n\t}\n\treturn multiplier;\n}\n\nstruct be_mcc_wrb *wrb_from_mbox(struct be_dma_mem *mbox_mem)\n{\n\treturn &((struct be_mcc_mailbox *)(mbox_mem->va))->wrb;\n}\n\nint beiscsi_cmd_eq_create(struct be_ctrl_info *ctrl,\n\t\t\t  struct be_queue_info *eq, int eq_delay)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_cmd_req_eq_create *req = embedded_payload(wrb);\n\tstruct be_cmd_resp_eq_create *resp = embedded_payload(wrb);\n\tstruct be_dma_mem *q_mem = &eq->dma_mem;\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\tmemset(wrb, 0, sizeof(*wrb));\n\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\tOPCODE_COMMON_EQ_CREATE, sizeof(*req));\n\n\treq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\n\n\tAMAP_SET_BITS(struct amap_eq_context, func, req->context,\n\t\t\t\t\t\tPCI_FUNC(ctrl->pdev->devfn));\n\tAMAP_SET_BITS(struct amap_eq_context, valid, req->context, 1);\n\tAMAP_SET_BITS(struct amap_eq_context, size, req->context, 0);\n\tAMAP_SET_BITS(struct amap_eq_context, count, req->context,\n\t\t\t\t\t__ilog2_u32(eq->len / 256));\n\tAMAP_SET_BITS(struct amap_eq_context, delaymult, req->context,\n\t\t\t\t\teq_delay_to_mult(eq_delay));\n\tbe_dws_cpu_to_le(req->context, sizeof(req->context));\n\n\tbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\n\n\tstatus = be_mbox_notify(ctrl);\n\tif (!status) {\n\t\teq->id = le16_to_cpu(resp->eq_id);\n\t\teq->created = true;\n\t}\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\nint beiscsi_cmd_cq_create(struct be_ctrl_info *ctrl,\n\t\t\t  struct be_queue_info *cq, struct be_queue_info *eq,\n\t\t\t  bool sol_evts, bool no_delay, int coalesce_wm)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_cmd_req_cq_create *req = embedded_payload(wrb);\n\tstruct be_cmd_resp_cq_create *resp = embedded_payload(wrb);\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tstruct be_dma_mem *q_mem = &cq->dma_mem;\n\tvoid *ctxt = &req->context;\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\tmemset(wrb, 0, sizeof(*wrb));\n\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\tOPCODE_COMMON_CQ_CREATE, sizeof(*req));\n\n\treq->num_pages = cpu_to_le16(PAGES_4K_SPANNED(q_mem->va, q_mem->size));\n\tif (is_chip_be2_be3r(phba)) {\n\t\tAMAP_SET_BITS(struct amap_cq_context, coalescwm,\n\t\t\t      ctxt, coalesce_wm);\n\t\tAMAP_SET_BITS(struct amap_cq_context, nodelay, ctxt, no_delay);\n\t\tAMAP_SET_BITS(struct amap_cq_context, count, ctxt,\n\t\t\t      __ilog2_u32(cq->len / 256));\n\t\tAMAP_SET_BITS(struct amap_cq_context, valid, ctxt, 1);\n\t\tAMAP_SET_BITS(struct amap_cq_context, solevent, ctxt, sol_evts);\n\t\tAMAP_SET_BITS(struct amap_cq_context, eventable, ctxt, 1);\n\t\tAMAP_SET_BITS(struct amap_cq_context, eqid, ctxt, eq->id);\n\t\tAMAP_SET_BITS(struct amap_cq_context, armed, ctxt, 1);\n\t\tAMAP_SET_BITS(struct amap_cq_context, func, ctxt,\n\t\t\t      PCI_FUNC(ctrl->pdev->devfn));\n\t} else {\n\t\treq->hdr.version = MBX_CMD_VER2;\n\t\treq->page_size = 1;\n\t\tAMAP_SET_BITS(struct amap_cq_context_v2, coalescwm,\n\t\t\t      ctxt, coalesce_wm);\n\t\tAMAP_SET_BITS(struct amap_cq_context_v2, nodelay,\n\t\t\t      ctxt, no_delay);\n\t\tAMAP_SET_BITS(struct amap_cq_context_v2, count, ctxt,\n\t\t\t      __ilog2_u32(cq->len / 256));\n\t\tAMAP_SET_BITS(struct amap_cq_context_v2, valid, ctxt, 1);\n\t\tAMAP_SET_BITS(struct amap_cq_context_v2, eventable, ctxt, 1);\n\t\tAMAP_SET_BITS(struct amap_cq_context_v2, eqid, ctxt, eq->id);\n\t\tAMAP_SET_BITS(struct amap_cq_context_v2, armed, ctxt, 1);\n\t}\n\n\tbe_dws_cpu_to_le(ctxt, sizeof(req->context));\n\n\tbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\n\n\tstatus = be_mbox_notify(ctrl);\n\tif (!status) {\n\t\tcq->id = le16_to_cpu(resp->cq_id);\n\t\tcq->created = true;\n\t} else\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BC_%d : In be_cmd_cq_create, status=ox%08x\\n\",\n\t\t\t    status);\n\n\tmutex_unlock(&ctrl->mbox_lock);\n\n\treturn status;\n}\n\nstatic u32 be_encoded_q_len(int q_len)\n{\n\tu32 len_encoded = fls(q_len);\t \n\tif (len_encoded == 16)\n\t\tlen_encoded = 0;\n\treturn len_encoded;\n}\n\nint beiscsi_cmd_mccq_create(struct beiscsi_hba *phba,\n\t\t\tstruct be_queue_info *mccq,\n\t\t\tstruct be_queue_info *cq)\n{\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_cmd_req_mcc_create_ext *req;\n\tstruct be_dma_mem *q_mem = &mccq->dma_mem;\n\tstruct be_ctrl_info *ctrl;\n\tvoid *ctxt;\n\tint status;\n\n\tmutex_lock(&phba->ctrl.mbox_lock);\n\tctrl = &phba->ctrl;\n\twrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tmemset(wrb, 0, sizeof(*wrb));\n\treq = embedded_payload(wrb);\n\tctxt = &req->context;\n\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\tOPCODE_COMMON_MCC_CREATE_EXT, sizeof(*req));\n\n\treq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\n\treq->async_evt_bitmap = 1 << ASYNC_EVENT_CODE_LINK_STATE;\n\treq->async_evt_bitmap |= 1 << ASYNC_EVENT_CODE_ISCSI;\n\treq->async_evt_bitmap |= 1 << ASYNC_EVENT_CODE_SLI;\n\n\tAMAP_SET_BITS(struct amap_mcc_context, fid, ctxt,\n\t\t      PCI_FUNC(phba->pcidev->devfn));\n\tAMAP_SET_BITS(struct amap_mcc_context, valid, ctxt, 1);\n\tAMAP_SET_BITS(struct amap_mcc_context, ring_size, ctxt,\n\t\tbe_encoded_q_len(mccq->len));\n\tAMAP_SET_BITS(struct amap_mcc_context, cq_id, ctxt, cq->id);\n\n\tbe_dws_cpu_to_le(ctxt, sizeof(req->context));\n\n\tbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\n\n\tstatus = be_mbox_notify(ctrl);\n\tif (!status) {\n\t\tstruct be_cmd_resp_mcc_create *resp = embedded_payload(wrb);\n\t\tmccq->id = le16_to_cpu(resp->id);\n\t\tmccq->created = true;\n\t}\n\tmutex_unlock(&phba->ctrl.mbox_lock);\n\n\treturn status;\n}\n\nint beiscsi_cmd_q_destroy(struct be_ctrl_info *ctrl, struct be_queue_info *q,\n\t\t\t  int queue_type)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_cmd_req_q_destroy *req = embedded_payload(wrb);\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tu8 subsys = 0, opcode = 0;\n\tint status;\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BC_%d : In beiscsi_cmd_q_destroy \"\n\t\t    \"queue_type : %d\\n\", queue_type);\n\n\tmutex_lock(&ctrl->mbox_lock);\n\tmemset(wrb, 0, sizeof(*wrb));\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\n\tswitch (queue_type) {\n\tcase QTYPE_EQ:\n\t\tsubsys = CMD_SUBSYSTEM_COMMON;\n\t\topcode = OPCODE_COMMON_EQ_DESTROY;\n\t\tbreak;\n\tcase QTYPE_CQ:\n\t\tsubsys = CMD_SUBSYSTEM_COMMON;\n\t\topcode = OPCODE_COMMON_CQ_DESTROY;\n\t\tbreak;\n\tcase QTYPE_MCCQ:\n\t\tsubsys = CMD_SUBSYSTEM_COMMON;\n\t\topcode = OPCODE_COMMON_MCC_DESTROY;\n\t\tbreak;\n\tcase QTYPE_WRBQ:\n\t\tsubsys = CMD_SUBSYSTEM_ISCSI;\n\t\topcode = OPCODE_COMMON_ISCSI_WRBQ_DESTROY;\n\t\tbreak;\n\tcase QTYPE_DPDUQ:\n\t\tsubsys = CMD_SUBSYSTEM_ISCSI;\n\t\topcode = OPCODE_COMMON_ISCSI_DEFQ_DESTROY;\n\t\tbreak;\n\tcase QTYPE_SGL:\n\t\tsubsys = CMD_SUBSYSTEM_ISCSI;\n\t\topcode = OPCODE_COMMON_ISCSI_CFG_REMOVE_SGL_PAGES;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\tBUG();\n\t}\n\tbe_cmd_hdr_prepare(&req->hdr, subsys, opcode, sizeof(*req));\n\tif (queue_type != QTYPE_SGL)\n\t\treq->id = cpu_to_le16(q->id);\n\n\tstatus = be_mbox_notify(ctrl);\n\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\n \nint be_cmd_create_default_pdu_queue(struct be_ctrl_info *ctrl,\n\t\t\t\t    struct be_queue_info *cq,\n\t\t\t\t    struct be_queue_info *dq, int length,\n\t\t\t\t    int entry_size, uint8_t is_header,\n\t\t\t\t    uint8_t ulp_num)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_defq_create_req *req = embedded_payload(wrb);\n\tstruct be_dma_mem *q_mem = &dq->dma_mem;\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tvoid *ctxt = &req->context;\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\tmemset(wrb, 0, sizeof(*wrb));\n\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t   OPCODE_COMMON_ISCSI_DEFQ_CREATE, sizeof(*req));\n\n\treq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\n\tif (phba->fw_config.dual_ulp_aware) {\n\t\treq->ulp_num = ulp_num;\n\t\treq->dua_feature |= (1 << BEISCSI_DUAL_ULP_AWARE_BIT);\n\t\treq->dua_feature |= (1 << BEISCSI_BIND_Q_TO_ULP_BIT);\n\t}\n\n\tif (is_chip_be2_be3r(phba)) {\n\t\tAMAP_SET_BITS(struct amap_be_default_pdu_context,\n\t\t\t      rx_pdid, ctxt, 0);\n\t\tAMAP_SET_BITS(struct amap_be_default_pdu_context,\n\t\t\t      rx_pdid_valid, ctxt, 1);\n\t\tAMAP_SET_BITS(struct amap_be_default_pdu_context,\n\t\t\t      pci_func_id, ctxt, PCI_FUNC(ctrl->pdev->devfn));\n\t\tAMAP_SET_BITS(struct amap_be_default_pdu_context,\n\t\t\t      ring_size, ctxt,\n\t\t\t      be_encoded_q_len(length /\n\t\t\t      sizeof(struct phys_addr)));\n\t\tAMAP_SET_BITS(struct amap_be_default_pdu_context,\n\t\t\t      default_buffer_size, ctxt, entry_size);\n\t\tAMAP_SET_BITS(struct amap_be_default_pdu_context,\n\t\t\t      cq_id_recv, ctxt,\tcq->id);\n\t} else {\n\t\tAMAP_SET_BITS(struct amap_default_pdu_context_ext,\n\t\t\t      rx_pdid, ctxt, 0);\n\t\tAMAP_SET_BITS(struct amap_default_pdu_context_ext,\n\t\t\t      rx_pdid_valid, ctxt, 1);\n\t\tAMAP_SET_BITS(struct amap_default_pdu_context_ext,\n\t\t\t      ring_size, ctxt,\n\t\t\t      be_encoded_q_len(length /\n\t\t\t      sizeof(struct phys_addr)));\n\t\tAMAP_SET_BITS(struct amap_default_pdu_context_ext,\n\t\t\t      default_buffer_size, ctxt, entry_size);\n\t\tAMAP_SET_BITS(struct amap_default_pdu_context_ext,\n\t\t\t      cq_id_recv, ctxt, cq->id);\n\t}\n\n\tbe_dws_cpu_to_le(ctxt, sizeof(req->context));\n\n\tbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\n\n\tstatus = be_mbox_notify(ctrl);\n\tif (!status) {\n\t\tstruct be_ring *defq_ring;\n\t\tstruct be_defq_create_resp *resp = embedded_payload(wrb);\n\n\t\tdq->id = le16_to_cpu(resp->id);\n\t\tdq->created = true;\n\t\tif (is_header)\n\t\t\tdefq_ring = &phba->phwi_ctrlr->default_pdu_hdr[ulp_num];\n\t\telse\n\t\t\tdefq_ring = &phba->phwi_ctrlr->\n\t\t\t\t    default_pdu_data[ulp_num];\n\n\t\tdefq_ring->id = dq->id;\n\n\t\tif (!phba->fw_config.dual_ulp_aware) {\n\t\t\tdefq_ring->ulp_num = BEISCSI_ULP0;\n\t\t\tdefq_ring->doorbell_offset = DB_RXULP0_OFFSET;\n\t\t} else {\n\t\t\tdefq_ring->ulp_num = resp->ulp_num;\n\t\t\tdefq_ring->doorbell_offset = resp->doorbell_offset;\n\t\t}\n\t}\n\tmutex_unlock(&ctrl->mbox_lock);\n\n\treturn status;\n}\n\n \nint be_cmd_wrbq_create(struct be_ctrl_info *ctrl,\n\t\t\tstruct be_dma_mem *q_mem,\n\t\t\tstruct be_queue_info *wrbq,\n\t\t\tstruct hwi_wrb_context *pwrb_context,\n\t\t\tuint8_t ulp_num)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_wrbq_create_req *req = embedded_payload(wrb);\n\tstruct be_wrbq_create_resp *resp = embedded_payload(wrb);\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\tmemset(wrb, 0, sizeof(*wrb));\n\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\tOPCODE_COMMON_ISCSI_WRBQ_CREATE, sizeof(*req));\n\treq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\n\n\tif (phba->fw_config.dual_ulp_aware) {\n\t\treq->ulp_num = ulp_num;\n\t\treq->dua_feature |= (1 << BEISCSI_DUAL_ULP_AWARE_BIT);\n\t\treq->dua_feature |= (1 << BEISCSI_BIND_Q_TO_ULP_BIT);\n\t}\n\n\tbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\n\n\tstatus = be_mbox_notify(ctrl);\n\tif (!status) {\n\t\twrbq->id = le16_to_cpu(resp->cid);\n\t\twrbq->created = true;\n\n\t\tpwrb_context->cid = wrbq->id;\n\t\tif (!phba->fw_config.dual_ulp_aware) {\n\t\t\tpwrb_context->doorbell_offset = DB_TXULP0_OFFSET;\n\t\t\tpwrb_context->ulp_num = BEISCSI_ULP0;\n\t\t} else {\n\t\t\tpwrb_context->ulp_num = resp->ulp_num;\n\t\t\tpwrb_context->doorbell_offset = resp->doorbell_offset;\n\t\t}\n\t}\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\nint be_cmd_iscsi_post_template_hdr(struct be_ctrl_info *ctrl,\n\t\t\t\t    struct be_dma_mem *q_mem)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_post_template_pages_req *req = embedded_payload(wrb);\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\n\tmemset(wrb, 0, sizeof(*wrb));\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\t   OPCODE_COMMON_ADD_TEMPLATE_HEADER_BUFFERS,\n\t\t\t   sizeof(*req));\n\n\treq->num_pages = PAGES_4K_SPANNED(q_mem->va, q_mem->size);\n\treq->type = BEISCSI_TEMPLATE_HDR_TYPE_ISCSI;\n\tbe_cmd_page_addrs_prepare(req->pages, ARRAY_SIZE(req->pages), q_mem);\n\n\tstatus = be_mbox_notify(ctrl);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\nint be_cmd_iscsi_remove_template_hdr(struct be_ctrl_info *ctrl)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_remove_template_pages_req *req = embedded_payload(wrb);\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\n\tmemset(wrb, 0, sizeof(*wrb));\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\t   OPCODE_COMMON_REMOVE_TEMPLATE_HEADER_BUFFERS,\n\t\t\t   sizeof(*req));\n\n\treq->type = BEISCSI_TEMPLATE_HDR_TYPE_ISCSI;\n\n\tstatus = be_mbox_notify(ctrl);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\nint be_cmd_iscsi_post_sgl_pages(struct be_ctrl_info *ctrl,\n\t\t\t\tstruct be_dma_mem *q_mem,\n\t\t\t\tu32 page_offset, u32 num_pages)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_post_sgl_pages_req *req = embedded_payload(wrb);\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tint status;\n\tunsigned int curr_pages;\n\tu32 temp_num_pages = num_pages;\n\n\tif (num_pages == 0xff)\n\t\tnum_pages = 1;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\tdo {\n\t\tmemset(wrb, 0, sizeof(*wrb));\n\t\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\t\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t\t   OPCODE_COMMON_ISCSI_CFG_POST_SGL_PAGES,\n\t\t\t\t   sizeof(*req));\n\t\tcurr_pages = BE_NUMBER_OF_FIELD(struct be_post_sgl_pages_req,\n\t\t\t\t\t\tpages);\n\t\treq->num_pages = min(num_pages, curr_pages);\n\t\treq->page_offset = page_offset;\n\t\tbe_cmd_page_addrs_prepare(req->pages, req->num_pages, q_mem);\n\t\tq_mem->dma = q_mem->dma + (req->num_pages * PAGE_SIZE);\n\t\tpage_offset += req->num_pages;\n\t\tnum_pages -= req->num_pages;\n\n\t\tif (temp_num_pages == 0xff)\n\t\t\treq->num_pages = temp_num_pages;\n\n\t\tstatus = be_mbox_notify(ctrl);\n\t\tif (status) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BC_%d : FW CMD to map iscsi frags failed.\\n\");\n\n\t\t\tgoto error;\n\t\t}\n\t} while (num_pages > 0);\nerror:\n\tmutex_unlock(&ctrl->mbox_lock);\n\tif (status != 0)\n\t\tbeiscsi_cmd_q_destroy(ctrl, NULL, QTYPE_SGL);\n\treturn status;\n}\n\n \nint be_cmd_set_vlan(struct beiscsi_hba *phba,\n\t\t     uint16_t vlan_tag)\n{\n\tunsigned int tag;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_cmd_set_vlan_req *req;\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\n\tif (mutex_lock_interruptible(&ctrl->mbox_lock))\n\t\treturn 0;\n\twrb = alloc_mcc_wrb(phba, &tag);\n\tif (!wrb) {\n\t\tmutex_unlock(&ctrl->mbox_lock);\n\t\treturn 0;\n\t}\n\n\treq = embedded_payload(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(*wrb), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t   OPCODE_COMMON_ISCSI_NTWK_SET_VLAN,\n\t\t\t   sizeof(*req));\n\n\treq->interface_hndl = phba->interface_handle;\n\treq->vlan_priority = vlan_tag;\n\n\tbe_mcc_notify(phba, tag);\n\tmutex_unlock(&ctrl->mbox_lock);\n\n\treturn tag;\n}\n\nint beiscsi_check_supported_fw(struct be_ctrl_info *ctrl,\n\t\t\t       struct beiscsi_hba *phba)\n{\n\tstruct be_dma_mem nonemb_cmd;\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_mgmt_controller_attributes *req;\n\tstruct be_sge *sge = nonembedded_sgl(wrb);\n\tint status = 0;\n\n\tnonemb_cmd.va = dma_alloc_coherent(&ctrl->pdev->dev,\n\t\t\t\tsizeof(struct be_mgmt_controller_attributes),\n\t\t\t\t&nonemb_cmd.dma, GFP_KERNEL);\n\tif (nonemb_cmd.va == NULL) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : dma_alloc_coherent failed in %s\\n\",\n\t\t\t    __func__);\n\t\treturn -ENOMEM;\n\t}\n\tnonemb_cmd.size = sizeof(struct be_mgmt_controller_attributes);\n\treq = nonemb_cmd.va;\n\tmemset(req, 0, sizeof(*req));\n\tmutex_lock(&ctrl->mbox_lock);\n\tmemset(wrb, 0, sizeof(*wrb));\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), false, 1);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\t   OPCODE_COMMON_GET_CNTL_ATTRIBUTES, sizeof(*req));\n\tsge->pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd.dma));\n\tsge->pa_lo = cpu_to_le32(nonemb_cmd.dma & 0xFFFFFFFF);\n\tsge->len = cpu_to_le32(nonemb_cmd.size);\n\tstatus = be_mbox_notify(ctrl);\n\tif (!status) {\n\t\tstruct be_mgmt_controller_attributes_resp *resp = nonemb_cmd.va;\n\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : Firmware Version of CMD : %s\\n\"\n\t\t\t    \"Firmware Version is : %s\\n\"\n\t\t\t    \"Developer Build, not performing version check...\\n\",\n\t\t\t    resp->params.hba_attribs\n\t\t\t    .flashrom_version_string,\n\t\t\t    resp->params.hba_attribs.\n\t\t\t    firmware_version_string);\n\n\t\tphba->fw_config.iscsi_features =\n\t\t\t\tresp->params.hba_attribs.iscsi_features;\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BM_%d : phba->fw_config.iscsi_features = %d\\n\",\n\t\t\t    phba->fw_config.iscsi_features);\n\t\tmemcpy(phba->fw_ver_str, resp->params.hba_attribs.\n\t\t       firmware_version_string, BEISCSI_VER_STRLEN);\n\t} else\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d :  Failed in beiscsi_check_supported_fw\\n\");\n\tmutex_unlock(&ctrl->mbox_lock);\n\tif (nonemb_cmd.va)\n\t\tdma_free_coherent(&ctrl->pdev->dev, nonemb_cmd.size,\n\t\t\t\t    nonemb_cmd.va, nonemb_cmd.dma);\n\n\treturn status;\n}\n\n \nint beiscsi_get_fw_config(struct be_ctrl_info *ctrl,\n\t\t\t  struct beiscsi_hba *phba)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_fw_cfg *pfw_cfg = embedded_payload(wrb);\n\tuint32_t cid_count, icd_count;\n\tint status = -EINVAL;\n\tuint8_t ulp_num = 0;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\tmemset(wrb, 0, sizeof(*wrb));\n\tbe_wrb_hdr_prepare(wrb, sizeof(*pfw_cfg), true, 0);\n\n\tbe_cmd_hdr_prepare(&pfw_cfg->hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\t   OPCODE_COMMON_QUERY_FIRMWARE_CONFIG,\n\t\t\t   EMBED_MBX_MAX_PAYLOAD_SIZE);\n\n\tif (be_mbox_notify(ctrl)) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : Failed in beiscsi_get_fw_config\\n\");\n\t\tgoto fail_init;\n\t}\n\n\t \n\tphba->fw_config.phys_port = pfw_cfg->phys_port;\n\tif (phba->fw_config.phys_port >= BEISCSI_PHYS_PORT_MAX) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : invalid physical port id %d\\n\",\n\t\t\t    phba->fw_config.phys_port);\n\t\tgoto fail_init;\n\t}\n\n\t \n\tif (!is_chip_be2_be3r(phba)) {\n\t\tphba->fw_config.eqid_count = pfw_cfg->eqid_count;\n\t\tphba->fw_config.cqid_count = pfw_cfg->cqid_count;\n\t\tif (phba->fw_config.eqid_count == 0 ||\n\t\t    phba->fw_config.eqid_count > 2048) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BG_%d : invalid EQ count %d\\n\",\n\t\t\t\t    phba->fw_config.eqid_count);\n\t\t\tgoto fail_init;\n\t\t}\n\t\tif (phba->fw_config.cqid_count == 0 ||\n\t\t    phba->fw_config.cqid_count > 4096) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BG_%d : invalid CQ count %d\\n\",\n\t\t\t\t    phba->fw_config.cqid_count);\n\t\t\tgoto fail_init;\n\t\t}\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : EQ_Count : %d CQ_Count : %d\\n\",\n\t\t\t    phba->fw_config.eqid_count,\n\t\t\t    phba->fw_config.cqid_count);\n\t}\n\n\t \n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++) {\n\t\tif (pfw_cfg->ulp[ulp_num].ulp_mode &\n\t\t    BEISCSI_ULP_ISCSI_INI_MODE) {\n\t\t\tset_bit(ulp_num, &phba->fw_config.ulp_supported);\n\n\t\t\t \n\t\t\tphba->fw_config.iscsi_cid_start[ulp_num] =\n\t\t\t\tpfw_cfg->ulp[ulp_num].sq_base;\n\t\t\tphba->fw_config.iscsi_cid_count[ulp_num] =\n\t\t\t\tpfw_cfg->ulp[ulp_num].sq_count;\n\n\t\t\tphba->fw_config.iscsi_icd_start[ulp_num] =\n\t\t\t\tpfw_cfg->ulp[ulp_num].icd_base;\n\t\t\tphba->fw_config.iscsi_icd_count[ulp_num] =\n\t\t\t\tpfw_cfg->ulp[ulp_num].icd_count;\n\n\t\t\tphba->fw_config.iscsi_chain_start[ulp_num] =\n\t\t\t\tpfw_cfg->chain_icd[ulp_num].chain_base;\n\t\t\tphba->fw_config.iscsi_chain_count[ulp_num] =\n\t\t\t\tpfw_cfg->chain_icd[ulp_num].chain_count;\n\n\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t\t    \"BG_%d : Function loaded on ULP : %d\\n\"\n\t\t\t\t    \"\\tiscsi_cid_count : %d\\n\"\n\t\t\t\t    \"\\tiscsi_cid_start : %d\\n\"\n\t\t\t\t    \"\\t iscsi_icd_count : %d\\n\"\n\t\t\t\t    \"\\t iscsi_icd_start : %d\\n\",\n\t\t\t\t    ulp_num,\n\t\t\t\t    phba->fw_config.\n\t\t\t\t    iscsi_cid_count[ulp_num],\n\t\t\t\t    phba->fw_config.\n\t\t\t\t    iscsi_cid_start[ulp_num],\n\t\t\t\t    phba->fw_config.\n\t\t\t\t    iscsi_icd_count[ulp_num],\n\t\t\t\t    phba->fw_config.\n\t\t\t\t    iscsi_icd_start[ulp_num]);\n\t\t}\n\t}\n\n\tif (phba->fw_config.ulp_supported == 0) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : iSCSI initiator mode not set: ULP0 %x ULP1 %x\\n\",\n\t\t\t    pfw_cfg->ulp[BEISCSI_ULP0].ulp_mode,\n\t\t\t    pfw_cfg->ulp[BEISCSI_ULP1].ulp_mode);\n\t\tgoto fail_init;\n\t}\n\n\t \n\tfor (ulp_num = 0; ulp_num < BEISCSI_ULP_COUNT; ulp_num++)\n\t\tif (test_bit(ulp_num, &phba->fw_config.ulp_supported))\n\t\t\tbreak;\n\ticd_count = phba->fw_config.iscsi_icd_count[ulp_num];\n\tif (icd_count == 0 || icd_count > 65536) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d: invalid ICD count %d\\n\", icd_count);\n\t\tgoto fail_init;\n\t}\n\n\tcid_count = BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP0) +\n\t\t    BEISCSI_GET_CID_COUNT(phba, BEISCSI_ULP1);\n\tif (cid_count == 0 || cid_count > 4096) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d: invalid CID count %d\\n\", cid_count);\n\t\tgoto fail_init;\n\t}\n\n\t \n\tphba->fw_config.dual_ulp_aware = (pfw_cfg->function_mode &\n\t\t\t\t\t  BEISCSI_FUNC_DUA_MODE);\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t    \"BG_%d : DUA Mode : 0x%x\\n\",\n\t\t    phba->fw_config.dual_ulp_aware);\n\n\t \n\tstatus = 0;\nfail_init:\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\n \nint beiscsi_get_port_name(struct be_ctrl_info *ctrl, struct beiscsi_hba *phba)\n{\n\tint ret = 0;\n\tstruct be_mcc_wrb *wrb;\n\tstruct be_cmd_get_port_name *ioctl;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tmemset(wrb, 0, sizeof(*wrb));\n\tioctl = embedded_payload(wrb);\n\n\tbe_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);\n\tbe_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\t   OPCODE_COMMON_GET_PORT_NAME,\n\t\t\t   EMBED_MBX_MAX_PAYLOAD_SIZE);\n\tret = be_mbox_notify(ctrl);\n\tphba->port_name = 0;\n\tif (!ret) {\n\t\tphba->port_name = ioctl->p.resp.port_names >>\n\t\t\t\t  (phba->fw_config.phys_port * 8) & 0xff;\n\t} else {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : GET_PORT_NAME ret 0x%x status 0x%x\\n\",\n\t\t\t    ret, ioctl->h.resp_hdr.status);\n\t}\n\n\tif (phba->port_name == 0)\n\t\tphba->port_name = '?';\n\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn ret;\n}\n\nint beiscsi_set_host_data(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_cmd_set_host_data *ioctl;\n\tstruct be_mcc_wrb *wrb;\n\tint ret = 0;\n\n\tif (is_chip_be2_be3r(phba))\n\t\treturn ret;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tmemset(wrb, 0, sizeof(*wrb));\n\tioctl = embedded_payload(wrb);\n\n\tbe_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);\n\tbe_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\t   OPCODE_COMMON_SET_HOST_DATA,\n\t\t\t   EMBED_MBX_MAX_PAYLOAD_SIZE);\n\tioctl->param.req.param_id = BE_CMD_SET_HOST_PARAM_ID;\n\tioctl->param.req.param_len =\n\t\tsnprintf((char *)ioctl->param.req.param_data,\n\t\t\t sizeof(ioctl->param.req.param_data),\n\t\t\t \"Linux iSCSI v%s\", BUILD_STR);\n\tioctl->param.req.param_len = ALIGN(ioctl->param.req.param_len + 1, 4);\n\tif (ioctl->param.req.param_len > BE_CMD_MAX_DRV_VERSION)\n\t\tioctl->param.req.param_len = BE_CMD_MAX_DRV_VERSION;\n\tret = be_mbox_notify(ctrl);\n\tif (!ret) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : HBA set host driver version\\n\");\n\t} else {\n\t\t \n\t\tif (ret == MCC_STATUS_ILLEGAL_REQUEST ||\n\t\t\t\tret == MCC_STATUS_INVALID_LENGTH)\n\t\t\t__beiscsi_log(phba, KERN_INFO,\n\t\t\t\t      \"BG_%d : HBA failed to set host driver version\\n\");\n\t}\n\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn ret;\n}\n\nint beiscsi_set_uer_feature(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_cmd_set_features *ioctl;\n\tstruct be_mcc_wrb *wrb;\n\tint ret = 0;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tmemset(wrb, 0, sizeof(*wrb));\n\tioctl = embedded_payload(wrb);\n\n\tbe_wrb_hdr_prepare(wrb, sizeof(*ioctl), true, 0);\n\tbe_cmd_hdr_prepare(&ioctl->h.req_hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\t   OPCODE_COMMON_SET_FEATURES,\n\t\t\t   EMBED_MBX_MAX_PAYLOAD_SIZE);\n\tioctl->feature = BE_CMD_SET_FEATURE_UER;\n\tioctl->param_len = sizeof(ioctl->param.req);\n\tioctl->param.req.uer = BE_CMD_UER_SUPP_BIT;\n\tret = be_mbox_notify(ctrl);\n\tif (!ret) {\n\t\tphba->ue2rp = ioctl->param.resp.ue2rp;\n\t\tset_bit(BEISCSI_HBA_UER_SUPP, &phba->state);\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : HBA error recovery supported\\n\");\n\t} else {\n\t\t \n\t\tif (ret == MCC_STATUS_ILLEGAL_REQUEST ||\n\t\t    ret == MCC_STATUS_INVALID_LENGTH)\n\t\t\t__beiscsi_log(phba, KERN_INFO,\n\t\t\t\t      \"BG_%d : HBA error recovery not supported\\n\");\n\t}\n\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn ret;\n}\n\nstatic u32 beiscsi_get_post_stage(struct beiscsi_hba *phba)\n{\n\tu32 sem;\n\n\tif (is_chip_be2_be3r(phba))\n\t\tsem = ioread32(phba->csr_va + SLIPORT_SEMAPHORE_OFFSET_BEx);\n\telse\n\t\tpci_read_config_dword(phba->pcidev,\n\t\t\t\t      SLIPORT_SEMAPHORE_OFFSET_SH, &sem);\n\treturn sem;\n}\n\nint beiscsi_check_fw_rdy(struct beiscsi_hba *phba)\n{\n\tu32 loop, post, rdy = 0;\n\n\tloop = 1000;\n\twhile (loop--) {\n\t\tpost = beiscsi_get_post_stage(phba);\n\t\tif (post & POST_ERROR_BIT)\n\t\t\tbreak;\n\t\tif ((post & POST_STAGE_MASK) == POST_STAGE_ARMFW_RDY) {\n\t\t\trdy = 1;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(60);\n\t}\n\n\tif (!rdy) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BC_%d : FW not ready 0x%x\\n\", post);\n\t}\n\n\treturn rdy;\n}\n\nint beiscsi_cmd_function_reset(struct beiscsi_hba *phba)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct be_post_sgl_pages_req *req;\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\n\treq = embedded_payload(wrb);\n\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_COMMON,\n\t\t\t   OPCODE_COMMON_FUNCTION_RESET, sizeof(*req));\n\tstatus = be_mbox_notify(ctrl);\n\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\nint beiscsi_cmd_special_wrb(struct be_ctrl_info *ctrl, u32 load)\n{\n\tstruct be_mcc_wrb *wrb = wrb_from_mbox(&ctrl->mbox_mem);\n\tstruct beiscsi_hba *phba = pci_get_drvdata(ctrl->pdev);\n\tu8 *endian_check;\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\tmemset(wrb, 0, sizeof(*wrb));\n\n\tendian_check = (u8 *) wrb;\n\tif (load) {\n\t\t \n\t\t*endian_check++ = 0xFF;\n\t\t*endian_check++ = 0x12;\n\t\t*endian_check++ = 0x34;\n\t\t*endian_check++ = 0xFF;\n\t\t*endian_check++ = 0xFF;\n\t\t*endian_check++ = 0x56;\n\t\t*endian_check++ = 0x78;\n\t\t*endian_check++ = 0xFF;\n\t} else {\n\t\t \n\t\t*endian_check++ = 0xFF;\n\t\t*endian_check++ = 0xAA;\n\t\t*endian_check++ = 0xBB;\n\t\t*endian_check++ = 0xFF;\n\t\t*endian_check++ = 0xFF;\n\t\t*endian_check++ = 0xCC;\n\t\t*endian_check++ = 0xDD;\n\t\t*endian_check = 0xFF;\n\t}\n\tbe_dws_cpu_to_le(wrb, sizeof(*wrb));\n\n\tstatus = be_mbox_notify(ctrl);\n\tif (status)\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_INIT,\n\t\t\t    \"BC_%d : special WRB message failed\\n\");\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\nint beiscsi_init_sliport(struct beiscsi_hba *phba)\n{\n\tint status;\n\n\t \n\tstatus = beiscsi_check_fw_rdy(phba);\n\tif (!status)\n\t\treturn -EIO;\n\n\t \n\tphba->state &= ~BEISCSI_HBA_IN_ERR;\n\n\t \n\tphba->state &= ~BEISCSI_HBA_UER_SUPP;\n\n\t \n\tstatus = beiscsi_cmd_function_reset(phba);\n\tif (status) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,\n\t\t\t    \"BC_%d : SLI Function Reset failed\\n\");\n\t\treturn status;\n\t}\n\n\t \n\treturn beiscsi_cmd_special_wrb(&phba->ctrl, 1);\n}\n\n \nint beiscsi_cmd_iscsi_cleanup(struct beiscsi_hba *phba, unsigned short ulp)\n{\n\tstruct be_ctrl_info *ctrl = &phba->ctrl;\n\tstruct iscsi_cleanup_req_v1 *req_v1;\n\tstruct iscsi_cleanup_req *req;\n\tu16 hdr_ring_id, data_ring_id;\n\tstruct be_mcc_wrb *wrb;\n\tint status;\n\n\tmutex_lock(&ctrl->mbox_lock);\n\twrb = wrb_from_mbox(&ctrl->mbox_mem);\n\n\thdr_ring_id = HWI_GET_DEF_HDRQ_ID(phba, ulp);\n\tdata_ring_id = HWI_GET_DEF_BUFQ_ID(phba, ulp);\n\tif (is_chip_be2_be3r(phba)) {\n\t\treq = embedded_payload(wrb);\n\t\tbe_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);\n\t\tbe_cmd_hdr_prepare(&req->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t\t   OPCODE_COMMON_ISCSI_CLEANUP, sizeof(*req));\n\t\treq->chute = (1 << ulp);\n\t\t \n\t\treq->hdr_ring_id = hdr_ring_id;\n\t\treq->data_ring_id = data_ring_id;\n\t} else {\n\t\treq_v1 = embedded_payload(wrb);\n\t\tbe_wrb_hdr_prepare(wrb, sizeof(*req_v1), true, 0);\n\t\tbe_cmd_hdr_prepare(&req_v1->hdr, CMD_SUBSYSTEM_ISCSI,\n\t\t\t\t   OPCODE_COMMON_ISCSI_CLEANUP,\n\t\t\t\t   sizeof(*req_v1));\n\t\treq_v1->hdr.version = 1;\n\t\treq_v1->chute = (1 << ulp);\n\t\treq_v1->hdr_ring_id = cpu_to_le16(hdr_ring_id);\n\t\treq_v1->data_ring_id = cpu_to_le16(data_ring_id);\n\t}\n\n\tstatus = be_mbox_notify(ctrl);\n\tif (status)\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_INIT,\n\t\t\t    \"BG_%d : %s failed %d\\n\", __func__, ulp);\n\tmutex_unlock(&ctrl->mbox_lock);\n\treturn status;\n}\n\n \nint beiscsi_detect_ue(struct beiscsi_hba *phba)\n{\n\tuint32_t ue_mask_hi = 0, ue_mask_lo = 0;\n\tuint32_t ue_hi = 0, ue_lo = 0;\n\tuint8_t i = 0;\n\tint ret = 0;\n\n\tpci_read_config_dword(phba->pcidev,\n\t\t\t      PCICFG_UE_STATUS_LOW, &ue_lo);\n\tpci_read_config_dword(phba->pcidev,\n\t\t\t      PCICFG_UE_STATUS_MASK_LOW,\n\t\t\t      &ue_mask_lo);\n\tpci_read_config_dword(phba->pcidev,\n\t\t\t      PCICFG_UE_STATUS_HIGH,\n\t\t\t      &ue_hi);\n\tpci_read_config_dword(phba->pcidev,\n\t\t\t      PCICFG_UE_STATUS_MASK_HI,\n\t\t\t      &ue_mask_hi);\n\n\tue_lo = (ue_lo & ~ue_mask_lo);\n\tue_hi = (ue_hi & ~ue_mask_hi);\n\n\n\tif (ue_lo || ue_hi) {\n\t\tset_bit(BEISCSI_HBA_IN_UE, &phba->state);\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BC_%d : HBA error detected\\n\");\n\t\tret = 1;\n\t}\n\n\tif (ue_lo) {\n\t\tfor (i = 0; ue_lo; ue_lo >>= 1, i++) {\n\t\t\tif (ue_lo & 1)\n\t\t\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t\t      \"BC_%d : UE_LOW %s bit set\\n\",\n\t\t\t\t\t      desc_ue_status_low[i]);\n\t\t}\n\t}\n\n\tif (ue_hi) {\n\t\tfor (i = 0; ue_hi; ue_hi >>= 1, i++) {\n\t\t\tif (ue_hi & 1)\n\t\t\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t\t      \"BC_%d : UE_HIGH %s bit set\\n\",\n\t\t\t\t\t      desc_ue_status_hi[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nint beiscsi_detect_tpe(struct beiscsi_hba *phba)\n{\n\tu32 post, status;\n\tint ret = 0;\n\n\tpost = beiscsi_get_post_stage(phba);\n\tstatus = post & POST_STAGE_MASK;\n\tif ((status & POST_ERR_RECOVERY_CODE_MASK) ==\n\t    POST_STAGE_RECOVERABLE_ERR) {\n\t\tset_bit(BEISCSI_HBA_IN_TPE, &phba->state);\n\t\t__beiscsi_log(phba, KERN_INFO,\n\t\t\t      \"BC_%d : HBA error recoverable: 0x%x\\n\", post);\n\t\tret = 1;\n\t} else {\n\t\t__beiscsi_log(phba, KERN_INFO,\n\t\t\t      \"BC_%d : HBA in UE: 0x%x\\n\", post);\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}