{
  "module_name": "be_iscsi.c",
  "hash_id": "8065248131c1a44d805c1edfa39532f1933c7dd0f249108824654238b49c4259",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/be2iscsi/be_iscsi.c",
  "human_readable_source": "\n \n\n#include <scsi/libiscsi.h>\n#include <scsi/scsi_transport_iscsi.h>\n#include <scsi/scsi_transport.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_netlink.h>\n#include <net/netlink.h>\n#include <scsi/scsi.h>\n\n#include \"be_iscsi.h\"\n\nextern struct iscsi_transport beiscsi_iscsi_transport;\n\n \nstruct iscsi_cls_session *beiscsi_session_create(struct iscsi_endpoint *ep,\n\t\t\t\t\t\t u16 cmds_max,\n\t\t\t\t\t\t u16 qdepth,\n\t\t\t\t\t\t u32 initial_cmdsn)\n{\n\tstruct Scsi_Host *shost;\n\tstruct beiscsi_endpoint *beiscsi_ep;\n\tstruct iscsi_cls_session *cls_session;\n\tstruct beiscsi_hba *phba;\n\tstruct iscsi_session *sess;\n\tstruct beiscsi_session *beiscsi_sess;\n\tstruct beiscsi_io_task *io_task;\n\n\n\tif (!ep) {\n\t\tpr_err(\"beiscsi_session_create: invalid ep\\n\");\n\t\treturn NULL;\n\t}\n\tbeiscsi_ep = ep->dd_data;\n\tphba = beiscsi_ep->phba;\n\n\tif (!beiscsi_hba_is_online(phba)) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : HBA in error 0x%lx\\n\", phba->state);\n\t\treturn NULL;\n\t}\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_session_create\\n\");\n\tif (cmds_max > beiscsi_ep->phba->params.wrbs_per_cxn) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : Cannot handle %d cmds.\"\n\t\t\t    \"Max cmds per session supported is %d. Using %d.\"\n\t\t\t    \"\\n\", cmds_max,\n\t\t\t    beiscsi_ep->phba->params.wrbs_per_cxn,\n\t\t\t    beiscsi_ep->phba->params.wrbs_per_cxn);\n\n\t\tcmds_max = beiscsi_ep->phba->params.wrbs_per_cxn;\n\t}\n\n\tshost = phba->shost;\n\tcls_session = iscsi_session_setup(&beiscsi_iscsi_transport,\n\t\t\t\t\t  shost, cmds_max,\n\t\t\t\t\t  sizeof(*beiscsi_sess),\n\t\t\t\t\t  sizeof(*io_task),\n\t\t\t\t\t  initial_cmdsn, ISCSI_MAX_TARGET);\n\tif (!cls_session)\n\t\treturn NULL;\n\tsess = cls_session->dd_data;\n\tbeiscsi_sess = sess->dd_data;\n\tbeiscsi_sess->bhs_pool =  dma_pool_create(\"beiscsi_bhs_pool\",\n\t\t\t\t\t\t   &phba->pcidev->dev,\n\t\t\t\t\t\t   sizeof(struct be_cmd_bhs),\n\t\t\t\t\t\t   64, 0);\n\tif (!beiscsi_sess->bhs_pool)\n\t\tgoto destroy_sess;\n\n\treturn cls_session;\ndestroy_sess:\n\tiscsi_session_teardown(cls_session);\n\treturn NULL;\n}\n\n \nvoid beiscsi_session_destroy(struct iscsi_cls_session *cls_session)\n{\n\tstruct iscsi_session *sess = cls_session->dd_data;\n\tstruct beiscsi_session *beiscsi_sess = sess->dd_data;\n\n\tprintk(KERN_INFO \"In beiscsi_session_destroy\\n\");\n\tdma_pool_destroy(beiscsi_sess->bhs_pool);\n\tiscsi_session_teardown(cls_session);\n}\n\n \nvoid beiscsi_session_fail(struct iscsi_cls_session *cls_session)\n{\n\tiscsi_session_failure(cls_session->dd_data, ISCSI_ERR_CONN_FAILED);\n}\n\n\n \nstruct iscsi_cls_conn *\nbeiscsi_conn_create(struct iscsi_cls_session *cls_session, u32 cid)\n{\n\tstruct beiscsi_hba *phba;\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_cls_conn *cls_conn;\n\tstruct beiscsi_conn *beiscsi_conn;\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_session *sess;\n\tstruct beiscsi_session *beiscsi_sess;\n\n\tshost = iscsi_session_to_shost(cls_session);\n\tphba = iscsi_host_priv(shost);\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_conn_create ,cid\"\n\t\t    \"from iscsi layer=%d\\n\", cid);\n\n\tcls_conn = iscsi_conn_setup(cls_session, sizeof(*beiscsi_conn), cid);\n\tif (!cls_conn)\n\t\treturn NULL;\n\n\tconn = cls_conn->dd_data;\n\tbeiscsi_conn = conn->dd_data;\n\tbeiscsi_conn->ep = NULL;\n\tbeiscsi_conn->phba = phba;\n\tbeiscsi_conn->conn = conn;\n\tsess = cls_session->dd_data;\n\tbeiscsi_sess = sess->dd_data;\n\tbeiscsi_conn->beiscsi_sess = beiscsi_sess;\n\treturn cls_conn;\n}\n\n \nint beiscsi_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t      struct iscsi_cls_conn *cls_conn,\n\t\t      u64 transport_fd, int is_leading)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tstruct hwi_controller *phwi_ctrlr = phba->phwi_ctrlr;\n\tstruct hwi_wrb_context *pwrb_context;\n\tstruct beiscsi_endpoint *beiscsi_ep;\n\tstruct iscsi_endpoint *ep;\n\tuint16_t cri_index;\n\tint rc = 0;\n\n\tep = iscsi_lookup_endpoint(transport_fd);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tbeiscsi_ep = ep->dd_data;\n\n\tif (iscsi_conn_bind(cls_session, cls_conn, is_leading)) {\n\t\trc = -EINVAL;\n\t\tgoto put_ep;\n\t}\n\n\tif (beiscsi_ep->phba != phba) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : beiscsi_ep->hba=%p not equal to phba=%p\\n\",\n\t\t\t    beiscsi_ep->phba, phba);\n\t\trc = -EEXIST;\n\t\tgoto put_ep;\n\t}\n\tcri_index = BE_GET_CRI_FROM_CID(beiscsi_ep->ep_cid);\n\tif (phba->conn_table[cri_index]) {\n\t\tif (beiscsi_conn != phba->conn_table[cri_index] ||\n\t\t    beiscsi_ep != phba->conn_table[cri_index]->ep) {\n\t\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t      \"BS_%d : conn_table not empty at %u: cid %u conn %p:%p\\n\",\n\t\t\t\t      cri_index,\n\t\t\t\t      beiscsi_ep->ep_cid,\n\t\t\t\t      beiscsi_conn,\n\t\t\t\t      phba->conn_table[cri_index]);\n\t\t\trc = -EINVAL;\n\t\t\tgoto put_ep;\n\t\t}\n\t}\n\n\tbeiscsi_conn->beiscsi_conn_cid = beiscsi_ep->ep_cid;\n\tbeiscsi_conn->ep = beiscsi_ep;\n\tbeiscsi_ep->conn = beiscsi_conn;\n\t \n\tpwrb_context = &phwi_ctrlr->wrb_context[cri_index];\n\tbeiscsi_conn->doorbell_offset = pwrb_context->doorbell_offset;\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : cid %d phba->conn_table[%u]=%p\\n\",\n\t\t    beiscsi_ep->ep_cid, cri_index, beiscsi_conn);\n\tphba->conn_table[cri_index] = beiscsi_conn;\n\nput_ep:\n\tiscsi_put_endpoint(ep);\n\treturn rc;\n}\n\nstatic int beiscsi_iface_create_ipv4(struct beiscsi_hba *phba)\n{\n\tif (phba->ipv4_iface)\n\t\treturn 0;\n\n\tphba->ipv4_iface = iscsi_create_iface(phba->shost,\n\t\t\t\t\t      &beiscsi_iscsi_transport,\n\t\t\t\t\t      ISCSI_IFACE_TYPE_IPV4,\n\t\t\t\t\t      0, 0);\n\tif (!phba->ipv4_iface) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : Could not \"\n\t\t\t    \"create default IPv4 address.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int beiscsi_iface_create_ipv6(struct beiscsi_hba *phba)\n{\n\tif (phba->ipv6_iface)\n\t\treturn 0;\n\n\tphba->ipv6_iface = iscsi_create_iface(phba->shost,\n\t\t\t\t\t      &beiscsi_iscsi_transport,\n\t\t\t\t\t      ISCSI_IFACE_TYPE_IPV6,\n\t\t\t\t\t      0, 0);\n\tif (!phba->ipv6_iface) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : Could not \"\n\t\t\t    \"create default IPv6 address.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nvoid beiscsi_iface_create_default(struct beiscsi_hba *phba)\n{\n\tstruct be_cmd_get_if_info_resp *if_info;\n\n\tif (!beiscsi_if_get_info(phba, BEISCSI_IP_TYPE_V4, &if_info)) {\n\t\tbeiscsi_iface_create_ipv4(phba);\n\t\tkfree(if_info);\n\t}\n\n\tif (!beiscsi_if_get_info(phba, BEISCSI_IP_TYPE_V6, &if_info)) {\n\t\tbeiscsi_iface_create_ipv6(phba);\n\t\tkfree(if_info);\n\t}\n}\n\nvoid beiscsi_iface_destroy_default(struct beiscsi_hba *phba)\n{\n\tif (phba->ipv6_iface) {\n\t\tiscsi_destroy_iface(phba->ipv6_iface);\n\t\tphba->ipv6_iface = NULL;\n\t}\n\tif (phba->ipv4_iface) {\n\t\tiscsi_destroy_iface(phba->ipv4_iface);\n\t\tphba->ipv4_iface = NULL;\n\t}\n}\n\n \nstatic int\nbeiscsi_iface_config_vlan(struct Scsi_Host *shost,\n\t\t\t  struct iscsi_iface_param_info *iface_param)\n{\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tint ret = -EPERM;\n\n\tswitch (iface_param->param) {\n\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tret = 0;\n\t\tif (iface_param->value[0] != ISCSI_VLAN_ENABLE)\n\t\t\tret = beiscsi_if_set_vlan(phba, BEISCSI_VLAN_DISABLE);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_TAG:\n\t\tret = beiscsi_if_set_vlan(phba,\n\t\t\t\t\t  *((uint16_t *)iface_param->value));\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n\nstatic int\nbeiscsi_iface_config_ipv4(struct Scsi_Host *shost,\n\t\t\t  struct iscsi_iface_param_info *info,\n\t\t\t  void *data, uint32_t dt_len)\n{\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tu8 *ip = NULL, *subnet = NULL, *gw;\n\tstruct nlattr *nla;\n\tint ret = -EPERM;\n\n\t \n\tswitch (info->param) {\n\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tif (info->value[0] == ISCSI_IFACE_ENABLE)\n\t\t\tret = beiscsi_iface_create_ipv4(phba);\n\t\telse {\n\t\t\tiscsi_destroy_iface(phba->ipv4_iface);\n\t\t\tphba->ipv4_iface = NULL;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\tgw = info->value;\n\t\tret = beiscsi_if_set_gw(phba, BEISCSI_IP_TYPE_V4, gw);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\tif (info->value[0] == ISCSI_BOOTPROTO_DHCP)\n\t\t\tret = beiscsi_if_en_dhcp(phba, BEISCSI_IP_TYPE_V4);\n\t\telse if (info->value[0] == ISCSI_BOOTPROTO_STATIC)\n\t\t\t \n\t\t\tret = beiscsi_if_en_static(phba, BEISCSI_IP_TYPE_V4,\n\t\t\t\t\t\t   NULL, NULL);\n\t\telse\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BS_%d : Invalid BOOTPROTO: %d\\n\",\n\t\t\t\t    info->value[0]);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\tip = info->value;\n\t\tnla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_SUBNET);\n\t\tif (nla) {\n\t\t\tinfo = nla_data(nla);\n\t\t\tsubnet = info->value;\n\t\t}\n\t\tret = beiscsi_if_en_static(phba, BEISCSI_IP_TYPE_V4,\n\t\t\t\t\t   ip, subnet);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\t \n\t\tsubnet = info->value;\n\t\tnla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_ADDR);\n\t\tif (nla) {\n\t\t\tinfo = nla_data(nla);\n\t\t\tip = info->value;\n\t\t}\n\t\tret = beiscsi_if_en_static(phba, BEISCSI_IP_TYPE_V4,\n\t\t\t\t\t   ip, subnet);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nbeiscsi_iface_config_ipv6(struct Scsi_Host *shost,\n\t\t\t  struct iscsi_iface_param_info *iface_param,\n\t\t\t  void *data, uint32_t dt_len)\n{\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tint ret = -EPERM;\n\n\tswitch (iface_param->param) {\n\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tif (iface_param->value[0] == ISCSI_IFACE_ENABLE)\n\t\t\tret = beiscsi_iface_create_ipv6(phba);\n\t\telse {\n\t\t\tiscsi_destroy_iface(phba->ipv6_iface);\n\t\t\tphba->ipv6_iface = NULL;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\tret = beiscsi_if_en_static(phba, BEISCSI_IP_TYPE_V6,\n\t\t\t\t\t   iface_param->value, NULL);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint beiscsi_iface_set_param(struct Scsi_Host *shost,\n\t\t\t    void *data, uint32_t dt_len)\n{\n\tstruct iscsi_iface_param_info *iface_param = NULL;\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tstruct nlattr *attrib;\n\tuint32_t rm_len = dt_len;\n\tint ret;\n\n\tif (!beiscsi_hba_is_online(phba)) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : HBA in error 0x%lx\\n\", phba->state);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = beiscsi_if_get_handle(phba);\n\tif (ret) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : Getting Interface Handle Failed\\n\");\n\t\treturn ret;\n\t}\n\n\tnla_for_each_attr(attrib, data, dt_len, rm_len) {\n\t\t \n\t\tif (nla_len(attrib) < sizeof(*iface_param))\n\t\t\treturn -EINVAL;\n\n\t\tiface_param = nla_data(attrib);\n\n\t\tif (iface_param->param_type != ISCSI_NET_PARAM)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (iface_param->iface_num) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BS_%d : Invalid iface_num %d.\"\n\t\t\t\t    \"Only iface_num 0 is supported.\\n\",\n\t\t\t\t    iface_param->iface_num);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : %s.0 set param %d\",\n\t\t\t    (iface_param->iface_type == ISCSI_IFACE_TYPE_IPV4) ?\n\t\t\t    \"ipv4\" : \"ipv6\", iface_param->param);\n\n\t\tret = -EPERM;\n\t\tswitch (iface_param->param) {\n\t\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tcase ISCSI_NET_PARAM_VLAN_TAG:\n\t\t\tret = beiscsi_iface_config_vlan(shost, iface_param);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tswitch (iface_param->iface_type) {\n\t\t\tcase ISCSI_IFACE_TYPE_IPV4:\n\t\t\t\tret = beiscsi_iface_config_ipv4(shost,\n\t\t\t\t\t\t\t\tiface_param,\n\t\t\t\t\t\t\t\tdata, dt_len);\n\t\t\t\tbreak;\n\t\t\tcase ISCSI_IFACE_TYPE_IPV6:\n\t\t\t\tret = beiscsi_iface_config_ipv6(shost,\n\t\t\t\t\t\t\t\tiface_param,\n\t\t\t\t\t\t\t\tdata, dt_len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ret == -EPERM) {\n\t\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t      \"BS_%d : %s.0 set param %d not permitted\",\n\t\t\t\t      (iface_param->iface_type ==\n\t\t\t\t       ISCSI_IFACE_TYPE_IPV4) ? \"ipv4\" : \"ipv6\",\n\t\t\t\t      iface_param->param);\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int __beiscsi_iface_get_param(struct beiscsi_hba *phba,\n\t\t\t\t     struct iscsi_iface *iface,\n\t\t\t\t     int param, char *buf)\n{\n\tstruct be_cmd_get_if_info_resp *if_info;\n\tint len, ip_type = BEISCSI_IP_TYPE_V4;\n\n\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV6)\n\t\tip_type = BEISCSI_IP_TYPE_V6;\n\n\tlen = beiscsi_if_get_info(phba, ip_type, &if_info);\n\tif (len)\n\t\treturn len;\n\n\tswitch (param) {\n\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\tlen = sprintf(buf, \"%pI4\\n\", if_info->ip_addr.addr);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\tlen = sprintf(buf, \"%pI6\\n\", if_info->ip_addr.addr);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\tif (!if_info->dhcp_state)\n\t\t\tlen = sprintf(buf, \"static\\n\");\n\t\telse\n\t\t\tlen = sprintf(buf, \"dhcp\\n\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\tlen = sprintf(buf, \"%pI4\\n\", if_info->ip_addr.subnet_mask);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\tlen = sprintf(buf, \"%s\\n\",\n\t\t\t      (if_info->vlan_priority == BEISCSI_VLAN_DISABLE) ?\n\t\t\t      \"disable\" : \"enable\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_ID:\n\t\tif (if_info->vlan_priority == BEISCSI_VLAN_DISABLE)\n\t\t\tlen = -EINVAL;\n\t\telse\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      (if_info->vlan_priority &\n\t\t\t\t       ISCSI_MAX_VLAN_ID));\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_VLAN_PRIORITY:\n\t\tif (if_info->vlan_priority == BEISCSI_VLAN_DISABLE)\n\t\t\tlen = -EINVAL;\n\t\telse\n\t\t\tlen = sprintf(buf, \"%d\\n\",\n\t\t\t\t      ((if_info->vlan_priority >> 13) &\n\t\t\t\t       ISCSI_MAX_VLAN_PRIORITY));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tkfree(if_info);\n\treturn len;\n}\n\nint beiscsi_iface_get_param(struct iscsi_iface *iface,\n\t\t\t    enum iscsi_param_type param_type,\n\t\t\t    int param, char *buf)\n{\n\tstruct Scsi_Host *shost = iscsi_iface_to_shost(iface);\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tstruct be_cmd_get_def_gateway_resp gateway;\n\tint len = -EPERM;\n\n\tif (param_type != ISCSI_NET_PARAM)\n\t\treturn 0;\n\tif (!beiscsi_hba_is_online(phba)) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : HBA in error 0x%lx\\n\", phba->state);\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (param) {\n\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\tcase ISCSI_NET_PARAM_VLAN_ID:\n\tcase ISCSI_NET_PARAM_VLAN_PRIORITY:\n\t\tlen = __beiscsi_iface_get_param(phba, iface, param, buf);\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tif (iface->iface_type == ISCSI_IFACE_TYPE_IPV4)\n\t\t\tlen = sprintf(buf, \"%s\\n\",\n\t\t\t\t      phba->ipv4_iface ? \"enable\" : \"disable\");\n\t\telse if (iface->iface_type == ISCSI_IFACE_TYPE_IPV6)\n\t\t\tlen = sprintf(buf, \"%s\\n\",\n\t\t\t\t      phba->ipv6_iface ? \"enable\" : \"disable\");\n\t\tbreak;\n\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\tmemset(&gateway, 0, sizeof(gateway));\n\t\tlen = beiscsi_if_get_gw(phba, BEISCSI_IP_TYPE_V4, &gateway);\n\t\tif (!len)\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", &gateway.ip_addr.addr);\n\t\tbreak;\n\t}\n\n\treturn len;\n}\n\n \nint beiscsi_ep_get_param(struct iscsi_endpoint *ep,\n\t\t\t   enum iscsi_param param, char *buf)\n{\n\tstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\n\tint len;\n\n\tbeiscsi_log(beiscsi_ep->phba, KERN_INFO,\n\t\t    BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_ep_get_param,\"\n\t\t    \" param= %d\\n\", param);\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\t\tlen = sprintf(buf, \"%hu\\n\", beiscsi_ep->dst_tcpport);\n\t\tbreak;\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tif (beiscsi_ep->ip_type == BEISCSI_IP_TYPE_V4)\n\t\t\tlen = sprintf(buf, \"%pI4\\n\", &beiscsi_ep->dst_addr);\n\t\telse\n\t\t\tlen = sprintf(buf, \"%pI6\\n\", &beiscsi_ep->dst6_addr);\n\t\tbreak;\n\tdefault:\n\t\tlen = -EPERM;\n\t}\n\treturn len;\n}\n\nint beiscsi_set_param(struct iscsi_cls_conn *cls_conn,\n\t\t      enum iscsi_param param, char *buf, int buflen)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tstruct beiscsi_hba *phba = NULL;\n\tint ret;\n\n\tphba = ((struct beiscsi_conn *)conn->dd_data)->phba;\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_conn_set_param,\"\n\t\t    \" param= %d\\n\", param);\n\n\tret = iscsi_set_param(cls_conn, param, buf, buflen);\n\tif (ret)\n\t\treturn ret;\n\t \n\tswitch (param) {\n\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tif (session->first_burst > 8192)\n\t\t\tsession->first_burst = 8192;\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tif (conn->max_recv_dlength > 65536)\n\t\t\tconn->max_recv_dlength = 65536;\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_BURST:\n\t\tif (session->max_burst > 262144)\n\t\t\tsession->max_burst = 262144;\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tif (conn->max_xmit_dlength > 65536)\n\t\t\tconn->max_xmit_dlength = 65536;\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void beiscsi_get_port_state(struct Scsi_Host *shost)\n{\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\n\tihost->port_state = test_bit(BEISCSI_HBA_LINK_UP, &phba->state) ?\n\t\tISCSI_PORT_STATE_UP : ISCSI_PORT_STATE_DOWN;\n}\n\n \nstatic void beiscsi_get_port_speed(struct Scsi_Host *shost)\n{\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tstruct iscsi_cls_host *ihost = shost->shost_data;\n\n\tswitch (phba->port_speed) {\n\tcase BE2ISCSI_LINK_SPEED_10MBPS:\n\t\tihost->port_speed = ISCSI_PORT_SPEED_10MBPS;\n\t\tbreak;\n\tcase BE2ISCSI_LINK_SPEED_100MBPS:\n\t\tihost->port_speed = ISCSI_PORT_SPEED_100MBPS;\n\t\tbreak;\n\tcase BE2ISCSI_LINK_SPEED_1GBPS:\n\t\tihost->port_speed = ISCSI_PORT_SPEED_1GBPS;\n\t\tbreak;\n\tcase BE2ISCSI_LINK_SPEED_10GBPS:\n\t\tihost->port_speed = ISCSI_PORT_SPEED_10GBPS;\n\t\tbreak;\n\tcase BE2ISCSI_LINK_SPEED_25GBPS:\n\t\tihost->port_speed = ISCSI_PORT_SPEED_25GBPS;\n\t\tbreak;\n\tcase BE2ISCSI_LINK_SPEED_40GBPS:\n\t\tihost->port_speed = ISCSI_PORT_SPEED_40GBPS;\n\t\tbreak;\n\tdefault:\n\t\tihost->port_speed = ISCSI_PORT_SPEED_UNKNOWN;\n\t}\n}\n\n \nint beiscsi_get_host_param(struct Scsi_Host *shost,\n\t\t\t   enum iscsi_host_param param, char *buf)\n{\n\tstruct beiscsi_hba *phba = iscsi_host_priv(shost);\n\tint status = 0;\n\n\tif (!beiscsi_hba_is_online(phba)) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : HBA in error 0x%lx\\n\", phba->state);\n\t\treturn 0;\n\t}\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_get_host_param, param = %d\\n\", param);\n\n\tswitch (param) {\n\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tstatus = beiscsi_get_macaddr(buf, phba);\n\t\tif (status < 0) {\n\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BS_%d : beiscsi_get_macaddr Failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\t \n\t\tstatus = beiscsi_get_initiator_name(phba, buf, true);\n\t\tif (status < 0) {\n\t\t\tstatus = beiscsi_get_initiator_name(phba, buf, false);\n\t\t\tif (status < 0) {\n\t\t\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t\t\t    \"BS_%d : Retrieving Initiator Name Failed\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_PORT_STATE:\n\t\tbeiscsi_get_port_state(shost);\n\t\tstatus = sprintf(buf, \"%s\\n\", iscsi_get_port_state_name(shost));\n\t\tbreak;\n\tcase ISCSI_HOST_PARAM_PORT_SPEED:\n\t\tbeiscsi_get_port_speed(shost);\n\t\tstatus = sprintf(buf, \"%s\\n\", iscsi_get_port_speed_name(shost));\n\t\tbreak;\n\tdefault:\n\t\treturn iscsi_host_get_param(shost, param, buf);\n\t}\n\treturn status;\n}\n\nint beiscsi_get_macaddr(char *buf, struct beiscsi_hba *phba)\n{\n\tstruct be_cmd_get_nic_conf_resp resp;\n\tint rc;\n\n\tif (phba->mac_addr_set)\n\t\treturn sysfs_format_mac(buf, phba->mac_address, ETH_ALEN);\n\n\tmemset(&resp, 0, sizeof(resp));\n\trc = mgmt_get_nic_conf(phba, &resp);\n\tif (rc)\n\t\treturn rc;\n\n\tphba->mac_addr_set = true;\n\tmemcpy(phba->mac_address, resp.mac_address, ETH_ALEN);\n\treturn sysfs_format_mac(buf, phba->mac_address, ETH_ALEN);\n}\n\n \nvoid beiscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t    struct iscsi_stats *stats)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct beiscsi_hba *phba = NULL;\n\n\tphba = ((struct beiscsi_conn *)conn->dd_data)->phba;\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_conn_get_stats\\n\");\n\n\tstats->txdata_octets = conn->txdata_octets;\n\tstats->rxdata_octets = conn->rxdata_octets;\n\tstats->dataout_pdus = conn->dataout_pdus_cnt;\n\tstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\n\tstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\n\tstats->datain_pdus = conn->datain_pdus_cnt;\n\tstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\n\tstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\n\tstats->r2t_pdus = conn->r2t_pdus_cnt;\n\tstats->digest_err = 0;\n\tstats->timeout_err = 0;\n\tstats->custom_length = 1;\n\tstrcpy(stats->custom[0].desc, \"eh_abort_cnt\");\n\tstats->custom[0].value = conn->eh_abort_cnt;\n}\n\n \nstatic void  beiscsi_set_params_for_offld(struct beiscsi_conn *beiscsi_conn,\n\t\t\t\t\t  struct beiscsi_offload_params *params)\n{\n\tstruct iscsi_conn *conn = beiscsi_conn->conn;\n\tstruct iscsi_session *session = conn->session;\n\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, max_burst_length,\n\t\t      params, session->max_burst);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params,\n\t\t      max_send_data_segment_length, params,\n\t\t      conn->max_xmit_dlength);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, first_burst_length,\n\t\t      params, session->first_burst);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, erl, params,\n\t\t      session->erl);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, dde, params,\n\t\t      conn->datadgst_en);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, hde, params,\n\t\t      conn->hdrdgst_en);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, ir2t, params,\n\t\t      session->initial_r2t_en);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, imd, params,\n\t\t      session->imm_data_en);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params,\n\t\t      data_seq_inorder, params,\n\t\t      session->dataseq_inorder_en);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params,\n\t\t      pdu_seq_inorder, params,\n\t\t      session->pdu_inorder_en);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, max_r2t, params,\n\t\t      session->max_r2t);\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params, exp_statsn, params,\n\t\t      (conn->exp_statsn - 1));\n\tAMAP_SET_BITS(struct amap_beiscsi_offload_params,\n\t\t      max_recv_data_segment_length, params,\n\t\t      conn->max_recv_dlength);\n\n}\n\n \nint beiscsi_conn_start(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct beiscsi_conn *beiscsi_conn = conn->dd_data;\n\tstruct beiscsi_endpoint *beiscsi_ep;\n\tstruct beiscsi_offload_params params;\n\tstruct beiscsi_hba *phba;\n\n\tphba = ((struct beiscsi_conn *)conn->dd_data)->phba;\n\n\tif (!beiscsi_hba_is_online(phba)) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : HBA in error 0x%lx\\n\", phba->state);\n\t\treturn -EBUSY;\n\t}\n\tbeiscsi_log(beiscsi_conn->phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_conn_start\\n\");\n\n\tmemset(&params, 0, sizeof(struct beiscsi_offload_params));\n\tbeiscsi_ep = beiscsi_conn->ep;\n\tif (!beiscsi_ep)\n\t\tbeiscsi_log(beiscsi_conn->phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : In beiscsi_conn_start , no beiscsi_ep\\n\");\n\n\tbeiscsi_conn->login_in_progress = 0;\n\tbeiscsi_set_params_for_offld(beiscsi_conn, &params);\n\tbeiscsi_offload_connection(beiscsi_conn, &params);\n\tiscsi_conn_start(cls_conn);\n\treturn 0;\n}\n\n \nstatic int beiscsi_get_cid(struct beiscsi_hba *phba)\n{\n\tuint16_t cid_avlbl_ulp0, cid_avlbl_ulp1;\n\tunsigned short cid, cid_from_ulp;\n\tstruct ulp_cid_info *cid_info;\n\n\t \n\tcid_avlbl_ulp0 = (phba->cid_array_info[BEISCSI_ULP0]) ?\n\t\t\t  BEISCSI_ULP0_AVLBL_CID(phba) : 0;\n\tcid_avlbl_ulp1 = (phba->cid_array_info[BEISCSI_ULP1]) ?\n\t\t\t  BEISCSI_ULP1_AVLBL_CID(phba) : 0;\n\tcid_from_ulp = (cid_avlbl_ulp0 > cid_avlbl_ulp1) ?\n\t\t\tBEISCSI_ULP0 : BEISCSI_ULP1;\n\t \n\tif (!test_bit(cid_from_ulp, (void *)&phba->fw_config.ulp_supported))\n\t\treturn BE_INVALID_CID;\n\n\tcid_info = phba->cid_array_info[cid_from_ulp];\n\tcid = cid_info->cid_array[cid_info->cid_alloc];\n\tif (!cid_info->avlbl_cids || cid == BE_INVALID_CID) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t\"BS_%d : failed to get cid: available %u:%u\\n\",\n\t\t\t\tcid_info->avlbl_cids, cid_info->cid_free);\n\t\treturn BE_INVALID_CID;\n\t}\n\t \n\tcid_info->cid_array[cid_info->cid_alloc++] = BE_INVALID_CID;\n\tif (cid_info->cid_alloc == BEISCSI_GET_CID_COUNT(phba, cid_from_ulp))\n\t\tcid_info->cid_alloc = 0;\n\tcid_info->avlbl_cids--;\n\treturn cid;\n}\n\n \nstatic void beiscsi_put_cid(struct beiscsi_hba *phba, unsigned short cid)\n{\n\tuint16_t cri_index = BE_GET_CRI_FROM_CID(cid);\n\tstruct hwi_wrb_context *pwrb_context;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct ulp_cid_info *cid_info;\n\tuint16_t cid_post_ulp;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tpwrb_context = &phwi_ctrlr->wrb_context[cri_index];\n\tcid_post_ulp = pwrb_context->ulp_num;\n\n\tcid_info = phba->cid_array_info[cid_post_ulp];\n\t \n\tif (cid_info->cid_array[cid_info->cid_free] != BE_INVALID_CID) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BS_%d : failed to put cid %u: available %u:%u\\n\",\n\t\t\t      cid, cid_info->avlbl_cids, cid_info->cid_free);\n\t\treturn;\n\t}\n\tcid_info->cid_array[cid_info->cid_free++] = cid;\n\tif (cid_info->cid_free == BEISCSI_GET_CID_COUNT(phba, cid_post_ulp))\n\t\tcid_info->cid_free = 0;\n\tcid_info->avlbl_cids++;\n}\n\n \nstatic void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep)\n{\n\tstruct beiscsi_hba *phba = beiscsi_ep->phba;\n\tstruct beiscsi_conn *beiscsi_conn;\n\n\tbeiscsi_put_cid(phba, beiscsi_ep->ep_cid);\n\tbeiscsi_ep->phba = NULL;\n\t \n\tphba->ep_array[BE_GET_CRI_FROM_CID(beiscsi_ep->ep_cid)] = NULL;\n\n\t \n\tif (!beiscsi_ep->conn)\n\t\treturn;\n\n\tbeiscsi_conn = beiscsi_ep->conn;\n\t \n\tbeiscsi_ep->conn = NULL;\n\tif (beiscsi_conn->login_in_progress) {\n\t\tbeiscsi_free_mgmt_task_handles(beiscsi_conn,\n\t\t\t\t\t       beiscsi_conn->task);\n\t\tbeiscsi_conn->login_in_progress = 0;\n\t}\n}\n\n \nstatic int beiscsi_open_conn(struct iscsi_endpoint *ep,\n\t\t\t     struct sockaddr *src_addr,\n\t\t\t     struct sockaddr *dst_addr, int non_blocking)\n{\n\tstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\n\tstruct beiscsi_hba *phba = beiscsi_ep->phba;\n\tstruct tcp_connect_and_offload_out *ptcpcnct_out;\n\tstruct be_dma_mem nonemb_cmd;\n\tunsigned int tag, req_memsize;\n\tint ret = -ENOMEM;\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_open_conn\\n\");\n\n\tbeiscsi_ep->ep_cid = beiscsi_get_cid(phba);\n\tif (beiscsi_ep->ep_cid == BE_INVALID_CID) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : No free cid available\\n\");\n\t\treturn ret;\n\t}\n\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_open_conn, ep_cid=%d\\n\",\n\t\t    beiscsi_ep->ep_cid);\n\n\tphba->ep_array[BE_GET_CRI_FROM_CID\n\t\t       (beiscsi_ep->ep_cid)] = ep;\n\n\tbeiscsi_ep->cid_vld = 0;\n\n\tif (is_chip_be2_be3r(phba))\n\t\treq_memsize = sizeof(struct tcp_connect_and_offload_in);\n\telse\n\t\treq_memsize = sizeof(struct tcp_connect_and_offload_in_v1);\n\n\tnonemb_cmd.va = dma_alloc_coherent(&phba->ctrl.pdev->dev,\n\t\t\t\treq_memsize,\n\t\t\t\t&nonemb_cmd.dma, GFP_KERNEL);\n\tif (nonemb_cmd.va == NULL) {\n\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : Failed to allocate memory for\"\n\t\t\t    \" mgmt_open_connection\\n\");\n\n\t\tbeiscsi_free_ep(beiscsi_ep);\n\t\treturn -ENOMEM;\n\t}\n\tnonemb_cmd.size = req_memsize;\n\tmemset(nonemb_cmd.va, 0, nonemb_cmd.size);\n\ttag = mgmt_open_connection(phba, dst_addr, beiscsi_ep, &nonemb_cmd);\n\tif (!tag) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : mgmt_open_connection Failed for cid=%d\\n\",\n\t\t\t    beiscsi_ep->ep_cid);\n\n\t\tdma_free_coherent(&phba->ctrl.pdev->dev, nonemb_cmd.size,\n\t\t\t\t    nonemb_cmd.va, nonemb_cmd.dma);\n\t\tbeiscsi_free_ep(beiscsi_ep);\n\t\treturn -EAGAIN;\n\t}\n\n\tret = beiscsi_mccq_compl_wait(phba, tag, NULL, &nonemb_cmd);\n\tif (ret) {\n\t\tbeiscsi_log(phba, KERN_ERR,\n\t\t\t    BEISCSI_LOG_CONFIG | BEISCSI_LOG_MBOX,\n\t\t\t    \"BS_%d : mgmt_open_connection Failed\");\n\n\t\tif (ret != -EBUSY)\n\t\t\tdma_free_coherent(&phba->ctrl.pdev->dev,\n\t\t\t\t\tnonemb_cmd.size, nonemb_cmd.va,\n\t\t\t\t\tnonemb_cmd.dma);\n\n\t\tbeiscsi_free_ep(beiscsi_ep);\n\t\treturn ret;\n\t}\n\n\tptcpcnct_out = (struct tcp_connect_and_offload_out *)nonemb_cmd.va;\n\tbeiscsi_ep = ep->dd_data;\n\tbeiscsi_ep->fw_handle = ptcpcnct_out->connection_handle;\n\tbeiscsi_ep->cid_vld = 1;\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : mgmt_open_connection Success\\n\");\n\n\tdma_free_coherent(&phba->ctrl.pdev->dev, nonemb_cmd.size,\n\t\t\t    nonemb_cmd.va, nonemb_cmd.dma);\n\treturn 0;\n}\n\n \nstruct iscsi_endpoint *\nbeiscsi_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\n\t\t   int non_blocking)\n{\n\tstruct beiscsi_hba *phba;\n\tstruct beiscsi_endpoint *beiscsi_ep;\n\tstruct iscsi_endpoint *ep;\n\tint ret;\n\n\tif (!shost) {\n\t\tret = -ENXIO;\n\t\tpr_err(\"beiscsi_ep_connect shost is NULL\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tphba = iscsi_host_priv(shost);\n\tif (!beiscsi_hba_is_online(phba)) {\n\t\tret = -EIO;\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : HBA in error 0x%lx\\n\", phba->state);\n\t\treturn ERR_PTR(ret);\n\t}\n\tif (!test_bit(BEISCSI_HBA_LINK_UP, &phba->state)) {\n\t\tret = -EBUSY;\n\t\tbeiscsi_log(phba, KERN_WARNING, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : The Adapter Port state is Down!!!\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tep = iscsi_create_endpoint(sizeof(struct beiscsi_endpoint));\n\tif (!ep) {\n\t\tret = -ENOMEM;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbeiscsi_ep = ep->dd_data;\n\tbeiscsi_ep->phba = phba;\n\tbeiscsi_ep->openiscsi_ep = ep;\n\tret = beiscsi_open_conn(ep, NULL, dst_addr, non_blocking);\n\tif (ret) {\n\t\tbeiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : Failed in beiscsi_open_conn\\n\");\n\t\tgoto free_ep;\n\t}\n\n\treturn ep;\n\nfree_ep:\n\tiscsi_destroy_endpoint(ep);\n\treturn ERR_PTR(ret);\n}\n\n \nint beiscsi_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\n{\n\tstruct beiscsi_endpoint *beiscsi_ep = ep->dd_data;\n\n\tbeiscsi_log(beiscsi_ep->phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In  beiscsi_ep_poll\\n\");\n\n\tif (beiscsi_ep->cid_vld == 1)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic void beiscsi_flush_cq(struct beiscsi_hba *phba)\n{\n\tuint16_t i;\n\tstruct be_eq_obj *pbe_eq;\n\tstruct hwi_controller *phwi_ctrlr;\n\tstruct hwi_context_memory *phwi_context;\n\n\tphwi_ctrlr = phba->phwi_ctrlr;\n\tphwi_context = phwi_ctrlr->phwi_ctxt;\n\n\tfor (i = 0; i < phba->num_cpus; i++) {\n\t\tpbe_eq = &phwi_context->be_eq[i];\n\t\tirq_poll_disable(&pbe_eq->iopoll);\n\t\tbeiscsi_process_cq(pbe_eq, BE2_MAX_NUM_CQ_PROC);\n\t\tirq_poll_enable(&pbe_eq->iopoll);\n\t}\n}\n\n \nstatic int beiscsi_conn_close(struct beiscsi_endpoint *beiscsi_ep)\n{\n\tstruct beiscsi_hba *phba = beiscsi_ep->phba;\n\tunsigned int tag, attempts;\n\tint ret;\n\n\t \n\tattempts = 0;\n\twhile (attempts++ < 3) {\n\t\ttag = beiscsi_invalidate_cxn(phba, beiscsi_ep);\n\t\tif (tag) {\n\t\t\tret = beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BS_%d : invalidate conn failed cid %d\\n\",\n\t\t\t\t    beiscsi_ep->ep_cid);\n\t\t}\n\t}\n\n\t \n\tmsleep(250);\n\t \n\tbeiscsi_flush_cq(phba);\n\n\tif (attempts > 3)\n\t\treturn -1;\n\n\tattempts = 0;\n\twhile (attempts++ < 3) {\n\t\ttag = beiscsi_upload_cxn(phba, beiscsi_ep);\n\t\tif (tag) {\n\t\t\tret = beiscsi_mccq_compl_wait(phba, tag, NULL, NULL);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t\t    \"BS_%d : upload conn failed cid %d\\n\",\n\t\t\t\t    beiscsi_ep->ep_cid);\n\t\t}\n\t}\n\tif (attempts > 3)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nvoid beiscsi_ep_disconnect(struct iscsi_endpoint *ep)\n{\n\tstruct beiscsi_endpoint *beiscsi_ep;\n\tstruct beiscsi_hba *phba;\n\tuint16_t cri_index;\n\n\tbeiscsi_ep = ep->dd_data;\n\tphba = beiscsi_ep->phba;\n\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t    \"BS_%d : In beiscsi_ep_disconnect for ep_cid = %u\\n\",\n\t\t    beiscsi_ep->ep_cid);\n\n\tcri_index = BE_GET_CRI_FROM_CID(beiscsi_ep->ep_cid);\n\tif (!phba->ep_array[cri_index]) {\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BS_%d : ep_array at %u cid %u empty\\n\",\n\t\t\t      cri_index,\n\t\t\t      beiscsi_ep->ep_cid);\n\t\treturn;\n\t}\n\n\tif (!beiscsi_hba_is_online(phba)) {\n\t\tbeiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,\n\t\t\t    \"BS_%d : HBA in error 0x%lx\\n\", phba->state);\n\t} else {\n\t\t \n\t\tif (beiscsi_conn_close(beiscsi_ep) < 0)\n\t\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t\t      \"BS_%d : close conn failed cid %d\\n\",\n\t\t\t\t      beiscsi_ep->ep_cid);\n\t}\n\n\tbeiscsi_free_ep(beiscsi_ep);\n\tif (!phba->conn_table[cri_index])\n\t\t__beiscsi_log(phba, KERN_ERR,\n\t\t\t      \"BS_%d : conn_table empty at %u: cid %u\\n\",\n\t\t\t      cri_index, beiscsi_ep->ep_cid);\n\tphba->conn_table[cri_index] = NULL;\n\tiscsi_destroy_endpoint(beiscsi_ep->openiscsi_ep);\n}\n\numode_t beiscsi_attr_is_visible(int param_type, int param)\n{\n\tswitch (param_type) {\n\tcase ISCSI_NET_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_NET_PARAM_IFACE_ENABLE:\n\t\tcase ISCSI_NET_PARAM_IPV4_ADDR:\n\t\tcase ISCSI_NET_PARAM_IPV4_SUBNET:\n\t\tcase ISCSI_NET_PARAM_IPV4_BOOTPROTO:\n\t\tcase ISCSI_NET_PARAM_IPV4_GW:\n\t\tcase ISCSI_NET_PARAM_IPV6_ADDR:\n\t\tcase ISCSI_NET_PARAM_VLAN_ID:\n\t\tcase ISCSI_NET_PARAM_VLAN_PRIORITY:\n\t\tcase ISCSI_NET_PARAM_VLAN_ENABLED:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_HOST_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\tcase ISCSI_HOST_PARAM_PORT_STATE:\n\t\tcase ISCSI_HOST_PARAM_PORT_SPEED:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tcase ISCSI_PARAM_CONN_PORT:\n\t\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tcase ISCSI_PARAM_PING_TMO:\n\t\tcase ISCSI_PARAM_RECV_TMO:\n\t\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_PARAM_MAX_R2T:\n\t\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tcase ISCSI_PARAM_MAX_BURST:\n\t\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_PARAM_ERL:\n\t\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tcase ISCSI_PARAM_TPGT:\n\t\tcase ISCSI_PARAM_USERNAME:\n\t\tcase ISCSI_PARAM_PASSWORD:\n\t\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}