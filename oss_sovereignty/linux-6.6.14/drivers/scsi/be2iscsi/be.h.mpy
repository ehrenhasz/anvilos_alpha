{
  "module_name": "be.h",
  "hash_id": "3f943bfa98fb77635e34f2caca80a11baee1d87acdba3758dad7a79933fbcad5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/be2iscsi/be.h",
  "human_readable_source": " \n \n\n#ifndef BEISCSI_H\n#define BEISCSI_H\n\n#include <linux/pci.h>\n#include <linux/if_vlan.h>\n#include <linux/irq_poll.h>\n#define FW_VER_LEN\t32\n#define MCC_Q_LEN\t128\n#define MCC_CQ_LEN\t256\n#define MAX_MCC_CMD\t16\n \n#define BE_GEN2 2\n#define BE_GEN3 3\n#define BE_GEN4\t4\nstruct be_dma_mem {\n\tvoid *va;\n\tdma_addr_t dma;\n\tu32 size;\n};\n\nstruct be_queue_info {\n\tstruct be_dma_mem dma_mem;\n\tu16 len;\n\tu16 entry_size;\t\t \n\tu16 id;\n\tu16 tail, head;\n\tbool created;\n\tu16 used;\t\t \n};\n\nstatic inline u32 MODULO(u16 val, u16 limit)\n{\n\tWARN_ON(limit & (limit - 1));\n\treturn val & (limit - 1);\n}\n\nstatic inline void index_inc(u16 *index, u16 limit)\n{\n\t*index = MODULO((*index + 1), limit);\n}\n\nstatic inline void *queue_head_node(struct be_queue_info *q)\n{\n\treturn q->dma_mem.va + q->head * q->entry_size;\n}\n\nstatic inline void *queue_get_wrb(struct be_queue_info *q, unsigned int wrb_num)\n{\n\treturn q->dma_mem.va + wrb_num * q->entry_size;\n}\n\nstatic inline void *queue_tail_node(struct be_queue_info *q)\n{\n\treturn q->dma_mem.va + q->tail * q->entry_size;\n}\n\nstatic inline void queue_head_inc(struct be_queue_info *q)\n{\n\tindex_inc(&q->head, q->len);\n}\n\nstatic inline void queue_tail_inc(struct be_queue_info *q)\n{\n\tindex_inc(&q->tail, q->len);\n}\n\n \n\nstruct be_aic_obj {\t\t \n\tunsigned long jiffies;\n\tu32 eq_prev;\t\t \n\tu32 prev_eqd;\n#define BEISCSI_EQ_DELAY_MIN\t0\n#define BEISCSI_EQ_DELAY_DEF\t32\n#define BEISCSI_EQ_DELAY_MAX\t128\n};\n\nstruct be_eq_obj {\n\tu32 cq_count;\n\tstruct be_queue_info q;\n\tstruct beiscsi_hba *phba;\n\tstruct be_queue_info *cq;\n\tstruct work_struct mcc_work;  \n\tstruct irq_poll\tiopoll;\n};\n\nstruct be_mcc_obj {\n\tstruct be_queue_info q;\n\tstruct be_queue_info cq;\n};\n\nstruct beiscsi_mcc_tag_state {\n\tunsigned long tag_state;\n#define MCC_TAG_STATE_RUNNING\t0\n#define MCC_TAG_STATE_TIMEOUT\t1\n#define MCC_TAG_STATE_ASYNC\t2\n#define MCC_TAG_STATE_IGNORE\t3\n\tvoid (*cbfn)(struct beiscsi_hba *, unsigned int);\n\tstruct be_dma_mem tag_mem_state;\n};\n\nstruct be_ctrl_info {\n\tu8 __iomem *csr;\n\tu8 __iomem *db;\t\t \n\tu8 __iomem *pcicfg;\t \n\tstruct pci_dev *pdev;\n\n\t \n\tstruct mutex mbox_lock;\t \n\tstruct be_dma_mem mbox_mem;\n\t \n\tstruct be_dma_mem mbox_mem_alloced;\n\n\t \n\tstruct be_mcc_obj mcc_obj;\n\tspinlock_t mcc_lock;\t \n\n\twait_queue_head_t mcc_wait[MAX_MCC_CMD + 1];\n\tunsigned int mcc_tag[MAX_MCC_CMD];\n\tunsigned int mcc_tag_status[MAX_MCC_CMD + 1];\n\tunsigned short mcc_alloc_index;\n\tunsigned short mcc_free_index;\n\tunsigned int mcc_tag_available;\n\n\tstruct beiscsi_mcc_tag_state ptag_state[MAX_MCC_CMD + 1];\n};\n\n#include \"be_cmds.h\"\n\n \n#define MCC_Q_WRB_IDX_MASK\tCQE_STATUS_WRB_MASK\n#define MCC_Q_WRB_IDX_SHIFT\tCQE_STATUS_WRB_SHIFT\n \n#define MCC_Q_CMD_TAG_MASK\t((MAX_MCC_CMD << 1) - 1)\n\n#define PAGE_SHIFT_4K\t\t12\n#define PAGE_SIZE_4K\t\t(1 << PAGE_SHIFT_4K)\n\n \n#define PAGES_4K_SPANNED(_address, size)\t\t\t\t\\\n\t\t((u32)((((size_t)(_address) & (PAGE_SIZE_4K - 1)) +\t\\\n\t\t\t(size) + (PAGE_SIZE_4K - 1)) >> PAGE_SHIFT_4K))\n\n \n#define AMAP_BIT_OFFSET(_struct, field)\t\t\t\t\t\\\n\t\t(((size_t)&(((_struct *)0)->field))%32)\n\n \nstatic inline u32 amap_mask(u32 bitsize)\n{\n\treturn (bitsize == 32 ? 0xFFFFFFFF : (1 << bitsize) - 1);\n}\n\nstatic inline void amap_set(void *ptr, u32 dw_offset, u32 mask,\n\t\t\t\t\tu32 offset, u32 value)\n{\n\tu32 *dw = (u32 *) ptr + dw_offset;\n\t*dw &= ~(mask << offset);\n\t*dw |= (mask & value) << offset;\n}\n\n#define AMAP_SET_BITS(_struct, field, ptr, val)\t\t\t\t\\\n\t\tamap_set(ptr,\t\t\t\t\t\t\\\n\t\t\toffsetof(_struct, field)/32,\t\t\t\\\n\t\t\tamap_mask(sizeof(((_struct *)0)->field)),\t\\\n\t\t\tAMAP_BIT_OFFSET(_struct, field),\t\t\\\n\t\t\tval)\n\nstatic inline u32 amap_get(void *ptr, u32 dw_offset, u32 mask, u32 offset)\n{\n\tu32 *dw = ptr;\n\treturn mask & (*(dw + dw_offset) >> offset);\n}\n\n#define AMAP_GET_BITS(_struct, field, ptr)\t\t\t\t\\\n\t\tamap_get(ptr,\t\t\t\t\t\t\\\n\t\t\toffsetof(_struct, field)/32,\t\t\t\\\n\t\t\tamap_mask(sizeof(((_struct *)0)->field)),\t\\\n\t\t\tAMAP_BIT_OFFSET(_struct, field))\n\n#define be_dws_cpu_to_le(wrb, len) swap_dws(wrb, len)\n#define be_dws_le_to_cpu(wrb, len) swap_dws(wrb, len)\nstatic inline void swap_dws(void *wrb, int len)\n{\n#ifdef __BIG_ENDIAN\n\tu32 *dw = wrb;\n\tWARN_ON(len % 4);\n\tdo {\n\t\t*dw = cpu_to_le32(*dw);\n\t\tdw++;\n\t\tlen -= 4;\n\t} while (len);\n#endif  \n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}