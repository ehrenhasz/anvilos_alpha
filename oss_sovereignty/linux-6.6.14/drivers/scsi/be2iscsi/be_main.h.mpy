{
  "module_name": "be_main.h",
  "hash_id": "16878ad36b00ccf1c36ed27317eab21b5b96ba8f26fadf17bdee82b6b3b575ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/scsi/be2iscsi/be_main.h",
  "human_readable_source": " \n \n\n#ifndef _BEISCSI_MAIN_\n#define _BEISCSI_MAIN_\n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/iscsi_proto.h>\n#include <scsi/libiscsi.h>\n#include <scsi/scsi_transport_iscsi.h>\n\n#define DRV_NAME\t\t\"be2iscsi\"\n#define BUILD_STR\t\t\"11.4.0.1\"\n#define BE_NAME\t\t\t\"Emulex OneConnect\" \\\n\t\t\t\t\"Open-iSCSI Driver version\" BUILD_STR\n#define DRV_DESC\t\tBE_NAME \" \" \"Driver\"\n\n#define BE_VENDOR_ID\t\t0x19A2\n#define ELX_VENDOR_ID\t\t0x10DF\n \n#define BE_DEVICE_ID1\t\t0x212\n#define OC_DEVICE_ID1\t\t0x702\n#define OC_DEVICE_ID2\t\t0x703\n\n \n#define BE_DEVICE_ID2\t\t0x222\n#define OC_DEVICE_ID3\t\t0x712\n\n \n#define OC_SKH_ID1\t\t0x722\n\n#define BE2_IO_DEPTH\t\t1024\n#define BE2_MAX_SESSIONS\t256\n#define BE2_TMFS\t\t16\n#define BE2_NOPOUT_REQ\t\t16\n#define BE2_SGE\t\t\t32\n#define BE2_DEFPDU_HDR_SZ\t64\n#define BE2_DEFPDU_DATA_SZ\t8192\n#define BE2_MAX_NUM_CQ_PROC\t512\n\n#define MAX_CPUS\t\t64U\n#define BEISCSI_MAX_NUM_CPUS\t7\n\n#define BEISCSI_VER_STRLEN 32\n\n#define BEISCSI_SGLIST_ELEMENTS\t30\n\n \n#define BEISCSI_CMD_PER_LUN\t128\t \n#define BEISCSI_MAX_SECTORS\t1024\t \n#define BEISCSI_TEMPLATE_HDR_PER_CXN_SIZE 128  \n\n#define BEISCSI_MAX_CMD_LEN\t16\t \n#define BEISCSI_NUM_MAX_LUN\t256\t \n#define BEISCSI_MAX_FRAGS_INIT\t192\n\n#define BE_SENSE_INFO_SIZE\t\t258\n#define BE_ISCSI_PDU_HEADER_SIZE\t64\n#define BE_MIN_MEM_SIZE\t\t\t16384\n#define MAX_CMD_SZ\t\t\t65536\n#define IIOC_SCSI_DATA                  0x05\t \n\n \n\n#define HWI_GET_ASYNC_PDU_CTX(phwi, ulp_num)\t\\\n\t(phwi->phwi_ctxt->pasync_ctx[ulp_num])\n\n \n#define PCICFG_MEMBAR_CTRL_INT_CTRL_OFFSET\t0xfc\n \n#define MEMBAR_CTRL_INT_CTRL_HOSTINTR_MASK\t(1 << 29)\t \n\n \n#define CEV_ISR0_OFFSET\t\t\t\t0xC18\n#define CEV_ISR_SIZE\t\t\t\t4\n\n \n\n#define DB_TXULP0_OFFSET 0x40\n#define DB_RXULP0_OFFSET 0xA0\n \n#define DB_EQ_OFFSET\t\t\tDB_CQ_OFFSET\n#define DB_EQ_RING_ID_LOW_MASK\t\t0x1FF\t \n \n#define DB_EQ_CLR_SHIFT\t\t\t(9)\t \n \n#define DB_EQ_EVNT_SHIFT\t\t(10)\t \n \n#define DB_EQ_RING_ID_HIGH_MASK\t0x1F  \n#define DB_EQ_HIGH_SET_SHIFT\t11\n#define DB_EQ_HIGH_FEILD_SHIFT\t9\n \n#define DB_EQ_NUM_POPPED_SHIFT\t\t(16)\t \n \n#define DB_EQ_REARM_SHIFT\t\t(29)\t \n\n \n#define DB_CQ_OFFSET\t\t\t0x120\n#define DB_CQ_RING_ID_LOW_MASK\t\t0x3FF\t \n \n#define DB_CQ_RING_ID_HIGH_MASK\t0x1F  \n#define DB_CQ_HIGH_SET_SHIFT\t11\n#define DB_CQ_HIGH_FEILD_SHIFT\t10\n\n \n#define DB_CQ_NUM_POPPED_SHIFT\t\t(16)\t \n \n#define DB_CQ_REARM_SHIFT\t\t(29)\t \n\n#define GET_HWI_CONTROLLER_WS(pc)\t(pc->phwi_ctrlr)\n#define HWI_GET_DEF_BUFQ_ID(pc, ulp_num) (((struct hwi_controller *)\\\n\t\t(GET_HWI_CONTROLLER_WS(pc)))->default_pdu_data[ulp_num].id)\n#define HWI_GET_DEF_HDRQ_ID(pc, ulp_num) (((struct hwi_controller *)\\\n\t\t(GET_HWI_CONTROLLER_WS(pc)))->default_pdu_hdr[ulp_num].id)\n\n#define PAGES_REQUIRED(x) \\\n\t((x < PAGE_SIZE) ? 1 :  ((x + PAGE_SIZE - 1) / PAGE_SIZE))\n\n#define MEM_DESCR_OFFSET 8\n#define BEISCSI_DEFQ_HDR 1\n#define BEISCSI_DEFQ_DATA 0\nenum be_mem_enum {\n\tHWI_MEM_ADDN_CONTEXT,\n\tHWI_MEM_WRB,\n\tHWI_MEM_WRBH,\n\tHWI_MEM_SGLH,\n\tHWI_MEM_SGE,\n\tHWI_MEM_TEMPLATE_HDR_ULP0,\n\tHWI_MEM_ASYNC_HEADER_BUF_ULP0,\t \n\tHWI_MEM_ASYNC_DATA_BUF_ULP0,\n\tHWI_MEM_ASYNC_HEADER_RING_ULP0,\n\tHWI_MEM_ASYNC_DATA_RING_ULP0,\n\tHWI_MEM_ASYNC_HEADER_HANDLE_ULP0,\n\tHWI_MEM_ASYNC_DATA_HANDLE_ULP0,\t \n\tHWI_MEM_ASYNC_PDU_CONTEXT_ULP0,\n\tHWI_MEM_TEMPLATE_HDR_ULP1,\n\tHWI_MEM_ASYNC_HEADER_BUF_ULP1,\t \n\tHWI_MEM_ASYNC_DATA_BUF_ULP1,\n\tHWI_MEM_ASYNC_HEADER_RING_ULP1,\n\tHWI_MEM_ASYNC_DATA_RING_ULP1,\n\tHWI_MEM_ASYNC_HEADER_HANDLE_ULP1,\n\tHWI_MEM_ASYNC_DATA_HANDLE_ULP1,\t \n\tHWI_MEM_ASYNC_PDU_CONTEXT_ULP1,\n\tISCSI_MEM_GLOBAL_HEADER,\n\tSE_MEM_MAX\n};\n\nstruct be_bus_address32 {\n\tunsigned int address_lo;\n\tunsigned int address_hi;\n};\n\nstruct be_bus_address64 {\n\tunsigned long long address;\n};\n\nstruct be_bus_address {\n\tunion {\n\t\tstruct be_bus_address32 a32;\n\t\tstruct be_bus_address64 a64;\n\t} u;\n};\n\nstruct mem_array {\n\tstruct be_bus_address bus_address;\t \n\tvoid *virtual_address;\t\t \n\tunsigned int size;\t\t \n};\n\nstruct be_mem_descriptor {\n\tunsigned int size_in_bytes;\t \n\tunsigned int num_elements;\n\tstruct mem_array *mem_array;\n};\n\nstruct sgl_handle {\n\tunsigned int sgl_index;\n\tunsigned int type;\n\tunsigned int cid;\n\tstruct iscsi_task *task;\n\tstruct iscsi_sge *pfrag;\n};\n\nstruct hba_parameters {\n\tunsigned int ios_per_ctrl;\n\tunsigned int cxns_per_ctrl;\n\tunsigned int icds_per_ctrl;\n\tunsigned int num_sge_per_io;\n\tunsigned int defpdu_hdr_sz;\n\tunsigned int defpdu_data_sz;\n\tunsigned int num_cq_entries;\n\tunsigned int num_eq_entries;\n\tunsigned int wrbs_per_cxn;\n\tunsigned int hwi_ws_sz;\n};\n\n#define BEISCSI_GET_ULP_FROM_CRI(phwi_ctrlr, cri) \\\n\t(phwi_ctrlr->wrb_context[cri].ulp_num)\nstruct hwi_wrb_context {\n\tspinlock_t wrb_lock;\n\tstruct wrb_handle **pwrb_handle_base;\n\tstruct wrb_handle **pwrb_handle_basestd;\n\tstruct iscsi_wrb *plast_wrb;\n\tunsigned short alloc_index;\n\tunsigned short free_index;\n\tunsigned short wrb_handles_available;\n\tunsigned short cid;\n\tuint8_t ulp_num;\t \n\tuint32_t doorbell_offset;\n};\n\nstruct ulp_cid_info {\n\tunsigned short *cid_array;\n\tunsigned short avlbl_cids;\n\tunsigned short cid_alloc;\n\tunsigned short cid_free;\n};\n\n#include \"be.h\"\n#define chip_be2(phba)      (phba->generation == BE_GEN2)\n#define chip_be3_r(phba)    (phba->generation == BE_GEN3)\n#define is_chip_be2_be3r(phba) (chip_be3_r(phba) || (chip_be2(phba)))\n\n#define BEISCSI_ULP0    0\n#define BEISCSI_ULP1    1\n#define BEISCSI_ULP_COUNT   2\n#define BEISCSI_ULP0_LOADED 0x01\n#define BEISCSI_ULP1_LOADED 0x02\n\n#define BEISCSI_ULP_AVLBL_CID(phba, ulp_num) \\\n\t(((struct ulp_cid_info *)phba->cid_array_info[ulp_num])->avlbl_cids)\n#define BEISCSI_ULP0_AVLBL_CID(phba) \\\n\tBEISCSI_ULP_AVLBL_CID(phba, BEISCSI_ULP0)\n#define BEISCSI_ULP1_AVLBL_CID(phba) \\\n\tBEISCSI_ULP_AVLBL_CID(phba, BEISCSI_ULP1)\n\nstruct beiscsi_hba {\n\tstruct hba_parameters params;\n\tstruct hwi_controller *phwi_ctrlr;\n\tunsigned int mem_req[SE_MEM_MAX];\n\t \n\tu8 __iomem *csr_va;\t \n\tu8 __iomem *db_va;\t \n\tu8 __iomem *pci_va;\t \n\t \n\tstruct pci_dev *pcidev;\n\tunsigned int num_cpus;\n\tunsigned int nxt_cqid;\n\tchar *msi_name[MAX_CPUS];\n\tstruct be_mem_descriptor *init_mem;\n\n\tunsigned short io_sgl_alloc_index;\n\tunsigned short io_sgl_free_index;\n\tunsigned short io_sgl_hndl_avbl;\n\tstruct sgl_handle **io_sgl_hndl_base;\n\n\tunsigned short eh_sgl_alloc_index;\n\tunsigned short eh_sgl_free_index;\n\tunsigned short eh_sgl_hndl_avbl;\n\tstruct sgl_handle **eh_sgl_hndl_base;\n\tspinlock_t io_sgl_lock;\n\tspinlock_t mgmt_sgl_lock;\n\tspinlock_t async_pdu_lock;\n\tstruct list_head hba_queue;\n#define BE_MAX_SESSION 2048\n#define BE_INVALID_CID 0xffff\n#define BE_SET_CID_TO_CRI(cri_index, cid) \\\n\t\t\t  (phba->cid_to_cri_map[cid] = cri_index)\n#define BE_GET_CRI_FROM_CID(cid) (phba->cid_to_cri_map[cid])\n\tunsigned short cid_to_cri_map[BE_MAX_SESSION];\n\tstruct ulp_cid_info *cid_array_info[BEISCSI_ULP_COUNT];\n\tstruct iscsi_endpoint **ep_array;\n\tstruct beiscsi_conn **conn_table;\n\tstruct Scsi_Host *shost;\n\tstruct iscsi_iface *ipv4_iface;\n\tstruct iscsi_iface *ipv6_iface;\n\tstruct {\n\t\t \n#define BEISCSI_PHYS_PORT_MAX\t4\n\t\tunsigned int phys_port;\n\t\t \n\t\tunsigned int eqid_count;\n\t\tunsigned int cqid_count;\n\t\tunsigned int iscsi_cid_start[BEISCSI_ULP_COUNT];\n#define BEISCSI_GET_CID_COUNT(phba, ulp_num) \\\n\t\t(phba->fw_config.iscsi_cid_count[ulp_num])\n\t\tunsigned int iscsi_cid_count[BEISCSI_ULP_COUNT];\n\t\tunsigned int iscsi_icd_count[BEISCSI_ULP_COUNT];\n\t\tunsigned int iscsi_icd_start[BEISCSI_ULP_COUNT];\n\t\tunsigned int iscsi_chain_start[BEISCSI_ULP_COUNT];\n\t\tunsigned int iscsi_chain_count[BEISCSI_ULP_COUNT];\n\n\t\tunsigned short iscsi_features;\n\t\tuint16_t dual_ulp_aware;\n\t\tunsigned long ulp_supported;\n\t} fw_config;\n\n\tunsigned long state;\n#define BEISCSI_HBA_ONLINE\t0\n#define BEISCSI_HBA_LINK_UP\t1\n#define BEISCSI_HBA_BOOT_FOUND\t2\n#define BEISCSI_HBA_BOOT_WORK\t3\n#define BEISCSI_HBA_UER_SUPP\t4\n#define BEISCSI_HBA_PCI_ERR\t5\n#define BEISCSI_HBA_FW_TIMEOUT\t6\n#define BEISCSI_HBA_IN_UE\t7\n#define BEISCSI_HBA_IN_TPE\t8\n\n \n#define BEISCSI_HBA_IN_ERR\t((1 << BEISCSI_HBA_PCI_ERR) | \\\n\t\t\t\t (1 << BEISCSI_HBA_FW_TIMEOUT) | \\\n\t\t\t\t (1 << BEISCSI_HBA_IN_UE) | \\\n\t\t\t\t (1 << BEISCSI_HBA_IN_TPE))\n\n\tu8 optic_state;\n\tstruct delayed_work eqd_update;\n\t \n#define BEISCSI_EQD_UPDATE_INTERVAL\t1000\n\tstruct timer_list hw_check;\n\t \n#define BEISCSI_UE_DETECT_INTERVAL\t1000\n\tu32 ue2rp;\n\tstruct delayed_work recover_port;\n\tstruct work_struct sess_work;\n\n\tbool mac_addr_set;\n\tu8 mac_address[ETH_ALEN];\n\tu8 port_name;\n\tu8 port_speed;\n\tchar fw_ver_str[BEISCSI_VER_STRLEN];\n\tstruct workqueue_struct *wq;\t \n\tstruct be_ctrl_info ctrl;\n\tunsigned int generation;\n\tunsigned int interface_handle;\n\n\tstruct be_aic_obj aic_obj[MAX_CPUS];\n\tunsigned int attr_log_enable;\n\tint (*iotask_fn)(struct iscsi_task *,\n\t\t\tstruct scatterlist *sg,\n\t\t\tuint32_t num_sg, uint32_t xferlen,\n\t\t\tuint32_t writedir);\n\tstruct boot_struct {\n\t\tint retry;\n\t\tunsigned int tag;\n\t\tunsigned int s_handle;\n\t\tstruct be_dma_mem nonemb_cmd;\n\t\tenum {\n\t\t\tBEISCSI_BOOT_REOPEN_SESS = 1,\n\t\t\tBEISCSI_BOOT_GET_SHANDLE,\n\t\t\tBEISCSI_BOOT_GET_SINFO,\n\t\t\tBEISCSI_BOOT_LOGOUT_SESS,\n\t\t\tBEISCSI_BOOT_CREATE_KSET,\n\t\t} action;\n\t\tstruct mgmt_session_info boot_sess;\n\t\tstruct iscsi_boot_kset *boot_kset;\n\t} boot_struct;\n\tstruct work_struct boot_work;\n};\n\n#define beiscsi_hba_in_error(phba) ((phba)->state & BEISCSI_HBA_IN_ERR)\n#define beiscsi_hba_is_online(phba) \\\n\t(!beiscsi_hba_in_error((phba)) && \\\n\t test_bit(BEISCSI_HBA_ONLINE, &phba->state))\n\nstruct beiscsi_session {\n\tstruct dma_pool *bhs_pool;\n};\n\n \nstruct beiscsi_conn {\n\tstruct iscsi_conn *conn;\n\tstruct beiscsi_hba *phba;\n\tu32 exp_statsn;\n\tu32 doorbell_offset;\n\tu32 beiscsi_conn_cid;\n\tstruct beiscsi_endpoint *ep;\n\tunsigned short login_in_progress;\n\tstruct wrb_handle *plogin_wrb_handle;\n\tstruct sgl_handle *plogin_sgl_handle;\n\tstruct beiscsi_session *beiscsi_sess;\n\tstruct iscsi_task *task;\n};\n\n \nstruct pdu_data_out {\n\tu32 dw[12];\n};\n \nstruct amap_pdu_data_out {\n\tu8 opcode[6];\t\t \n\tu8 rsvd0[2];\t\t \n\tu8 rsvd1[7];\n\tu8 final_bit;\t\t \n\tu8 rsvd2[16];\n\tu8 ahs_length[8];\t \n\tu8 data_len_hi[8];\n\tu8 data_len_lo[16];\t \n\tu8 lun[64];\n\tu8 itt[32];\t\t \n\tu8 ttt[32];\t\t \n\tu8 rsvd3[32];\n\tu8 exp_stat_sn[32];\n\tu8 rsvd4[32];\n\tu8 data_sn[32];\n\tu8 buffer_offset[32];\n\tu8 rsvd5[32];\n};\n\nstruct be_cmd_bhs {\n\tstruct iscsi_scsi_req iscsi_hdr;\n\tunsigned char pad1[16];\n\tstruct pdu_data_out iscsi_data_pdu;\n\tunsigned char pad2[BE_SENSE_INFO_SIZE -\n\t\t\tsizeof(struct pdu_data_out)];\n};\n\nstruct beiscsi_io_task {\n\tstruct wrb_handle *pwrb_handle;\n\tstruct sgl_handle *psgl_handle;\n\tstruct beiscsi_conn *conn;\n\tstruct scsi_cmnd *scsi_cmnd;\n\tint num_sg;\n\tstruct hwi_wrb_context *pwrb_context;\n\titt_t libiscsi_itt;\n\tstruct be_cmd_bhs *cmd_bhs;\n\tstruct be_bus_address bhs_pa;\n\tunsigned short bhs_len;\n\tdma_addr_t mtask_addr;\n\tuint32_t mtask_data_count;\n\tuint8_t wrb_type;\n};\n\nstruct be_nonio_bhs {\n\tstruct iscsi_hdr iscsi_hdr;\n\tunsigned char pad1[16];\n\tstruct pdu_data_out iscsi_data_pdu;\n\tunsigned char pad2[BE_SENSE_INFO_SIZE -\n\t\t\tsizeof(struct pdu_data_out)];\n};\n\nstruct be_status_bhs {\n\tstruct iscsi_scsi_req iscsi_hdr;\n\tunsigned char pad1[16];\n\t \n\tunsigned char sense_info[BE_SENSE_INFO_SIZE];\n};\n\nstruct iscsi_sge {\n\tu32 dw[4];\n};\n\n \nstruct amap_iscsi_sge {\n\tu8 addr_hi[32];\n\tu8 addr_lo[32];\n\tu8 sge_offset[22];\t \n\tu8 rsvd0[9];\t\t \n\tu8 last_sge;\t\t \n\tu8 len[17];\t\t \n\tu8 rsvd1[15];\t\t \n};\n\nstruct beiscsi_offload_params {\n\tu32 dw[6];\n};\n\n#define OFFLD_PARAMS_ERL\t0x00000003\n#define OFFLD_PARAMS_DDE\t0x00000004\n#define OFFLD_PARAMS_HDE\t0x00000008\n#define OFFLD_PARAMS_IR2T\t0x00000010\n#define OFFLD_PARAMS_IMD\t0x00000020\n#define OFFLD_PARAMS_DATA_SEQ_INORDER   0x00000040\n#define OFFLD_PARAMS_PDU_SEQ_INORDER    0x00000080\n#define OFFLD_PARAMS_MAX_R2T 0x00FFFF00\n\n \nstruct amap_beiscsi_offload_params {\n\tu8 max_burst_length[32];\n\tu8 max_send_data_segment_length[32];\n\tu8 first_burst_length[32];\n\tu8 erl[2];\n\tu8 dde[1];\n\tu8 hde[1];\n\tu8 ir2t[1];\n\tu8 imd[1];\n\tu8 data_seq_inorder[1];\n\tu8 pdu_seq_inorder[1];\n\tu8 max_r2t[16];\n\tu8 pad[8];\n\tu8 exp_statsn[32];\n\tu8 max_recv_data_segment_length[32];\n};\n\nstruct hd_async_handle {\n\tstruct list_head link;\n\tstruct be_bus_address pa;\n\tvoid *pbuffer;\n\tu32 buffer_len;\n\tu16 index;\n\tu16 cri;\n\tu8 is_header;\n\tu8 is_final;\n\tu8 in_use;\n};\n\n#define BEISCSI_ASYNC_HDQ_SIZE(phba, ulp) \\\n\t(BEISCSI_GET_CID_COUNT((phba), (ulp)) * 2)\n\n \nstruct hd_async_entry {\n\tstruct cri_wait_queue {\n\t\tunsigned short hdr_len;\n\t\tunsigned int bytes_received;\n\t\tunsigned int bytes_needed;\n\t\tstruct list_head list;\n\t} wq;\n\t \n\tstruct hd_async_handle *header;\n\tstruct hd_async_handle *data;\n};\n\nstruct hd_async_buf_context {\n\tstruct be_bus_address pa_base;\n\tvoid *va_base;\n\tvoid *ring_base;\n\tstruct hd_async_handle *handle_base;\n\tu32 buffer_size;\n\tu16 pi;\n};\n\n \nstruct hd_async_context {\n\tstruct hd_async_buf_context async_header;\n\tstruct hd_async_buf_context async_data;\n\tu16 num_entries;\n\t \n#define BE_GET_ASYNC_CRI_FROM_CID(cid) (pasync_ctx->cid_to_async_cri_map[cid])\n\tunsigned short cid_to_async_cri_map[BE_MAX_SESSION];\n\t \n\tstruct hd_async_entry *async_entry;\n};\n\nstruct i_t_dpdu_cqe {\n\tu32 dw[4];\n} __packed;\n\n \nstruct amap_i_t_dpdu_cqe {\n\tu8 db_addr_hi[32];\n\tu8 db_addr_lo[32];\n\tu8 code[6];\n\tu8 cid[10];\n\tu8 dpl[16];\n\tu8 index[16];\n\tu8 num_cons[10];\n\tu8 rsvd0[4];\n\tu8 final;\n\tu8 valid;\n} __packed;\n\nstruct amap_i_t_dpdu_cqe_v2 {\n\tu8 db_addr_hi[32];   \n\tu8 db_addr_lo[32];   \n\tu8 code[6];  \n\tu8 num_cons;  \n\tu8 rsvd0[8];  \n\tu8 dpl[17];  \n\tu8 index[16];  \n\tu8 cid[13];  \n\tu8 rsvd1;  \n\tu8 final;  \n\tu8 valid;  \n} __packed;\n\n#define CQE_VALID_MASK\t0x80000000\n#define CQE_CODE_MASK\t0x0000003F\n#define CQE_CID_MASK\t0x0000FFC0\n\n#define EQE_VALID_MASK\t\t0x00000001\n#define EQE_MAJORCODE_MASK\t0x0000000E\n#define EQE_RESID_MASK\t\t0xFFFF0000\n\nstruct be_eq_entry {\n\tu32 dw[1];\n} __packed;\n\n \nstruct amap_eq_entry {\n\tu8 valid;\t\t \n\tu8 major_code[3];\t \n\tu8 minor_code[12];\t \n\tu8 resource_id[16];\t \n\n} __packed;\n\nstruct cq_db {\n\tu32 dw[1];\n} __packed;\n\n \nstruct amap_cq_db {\n\tu8 qid[10];\n\tu8 event[1];\n\tu8 rsvd0[5];\n\tu8 num_popped[13];\n\tu8 rearm[1];\n\tu8 rsvd1[2];\n} __packed;\n\nvoid beiscsi_process_eq(struct beiscsi_hba *phba);\n\nstruct iscsi_wrb {\n\tu32 dw[16];\n} __packed;\n\n#define WRB_TYPE_MASK 0xF0000000\n#define SKH_WRB_TYPE_OFFSET 27\n#define BE_WRB_TYPE_OFFSET  28\n\n#define ADAPTER_SET_WRB_TYPE(pwrb, wrb_type, type_offset) \\\n\t\t(pwrb->dw[0] |= (wrb_type << type_offset))\n\n \nstruct amap_iscsi_wrb {\n\tu8 lun[14];\t\t \n\tu8 lt;\t\t\t \n\tu8 invld;\t\t \n\tu8 wrb_idx[8];\t\t \n\tu8 dsp;\t\t\t \n\tu8 dmsg;\t\t \n\tu8 undr_run;\t\t \n\tu8 over_run;\t\t \n\tu8 type[4];\t\t \n\tu8 ptr2nextwrb[8];\t \n\tu8 r2t_exp_dtl[24];\t \n\tu8 sgl_icd_idx[12];\t \n\tu8 rsvd0[20];\t\t \n\tu8 exp_data_sn[32];\t \n\tu8 iscsi_bhs_addr_hi[32];\t \n\tu8 iscsi_bhs_addr_lo[32];\t \n\tu8 cmdsn_itt[32];\t \n\tu8 dif_ref_tag[32];\t \n\tu8 sge0_addr_hi[32];\t \n\tu8 sge0_addr_lo[32];\t \n\tu8 sge0_offset[22];\t \n\tu8 pbs;\t\t\t \n\tu8 dif_mode[2];\t\t \n\tu8 rsvd1[6];\t\t \n\tu8 sge0_last;\t\t \n\tu8 sge0_len[17];\t \n\tu8 dif_meta_tag[14];\t \n\tu8 sge0_in_ddr;\t\t \n\tu8 sge1_addr_hi[32];\t \n\tu8 sge1_addr_lo[32];\t \n\tu8 sge1_r2t_offset[22];\t \n\tu8 rsvd2[9];\t\t \n\tu8 sge1_last;\t\t \n\tu8 sge1_len[17];\t \n\tu8 ref_sgl_icd_idx[12];\t \n\tu8 rsvd3[2];\t\t \n\tu8 sge1_in_ddr;\t\t \n\n} __packed;\n\nstruct amap_iscsi_wrb_v2 {\n\tu8 r2t_exp_dtl[25];  \n\tu8 rsvd0[2];     \n\tu8 type[5];      \n\tu8 ptr2nextwrb[8];   \n\tu8 wrb_idx[8];       \n\tu8 lun[16];      \n\tu8 sgl_idx[16];  \n\tu8 ref_sgl_icd_idx[16];  \n\tu8 exp_data_sn[32];  \n\tu8 iscsi_bhs_addr_hi[32];    \n\tu8 iscsi_bhs_addr_lo[32];    \n\tu8 cq_id[16];    \n\tu8 rsvd1[16];    \n\tu8 cmdsn_itt[32];    \n\tu8 sge0_addr_hi[32];     \n\tu8 sge0_addr_lo[32];     \n\tu8 sge0_offset[24];  \n\tu8 rsvd2[7];     \n\tu8 sge0_last;    \n\tu8 sge0_len[17];     \n\tu8 rsvd3[7];     \n\tu8 diff_enbl;    \n\tu8 u_run;        \n\tu8 o_run;        \n\tu8 invld;      \n\tu8 dsp;          \n\tu8 dmsg;         \n\tu8 rsvd4;        \n\tu8 lt;           \n\tu8 sge1_addr_hi[32];     \n\tu8 sge1_addr_lo[32];     \n\tu8 sge1_r2t_offset[24];  \n\tu8 rsvd5[7];     \n\tu8 sge1_last;    \n\tu8 sge1_len[17];     \n\tu8 rsvd6[15];    \n} __packed;\n\n\nstruct wrb_handle *alloc_wrb_handle(struct beiscsi_hba *phba, unsigned int cid,\n\t\t\t\t     struct hwi_wrb_context **pcontext);\nvoid\nfree_mgmt_sgl_handle(struct beiscsi_hba *phba, struct sgl_handle *psgl_handle);\n\nvoid beiscsi_free_mgmt_task_handles(struct beiscsi_conn *beiscsi_conn,\n\t\t\t\t     struct iscsi_task *task);\n\nvoid hwi_ring_cq_db(struct beiscsi_hba *phba,\n\t\t     unsigned int id, unsigned int num_processed,\n\t\t     unsigned char rearm);\n\nunsigned int beiscsi_process_cq(struct be_eq_obj *pbe_eq, int budget);\nvoid beiscsi_process_mcc_cq(struct beiscsi_hba *phba);\n\nstruct pdu_nop_out {\n\tu32 dw[12];\n};\n\n \nstruct amap_pdu_nop_out {\n\tu8 opcode[6];\t\t \n\tu8 i_bit;\t\t \n\tu8 x_bit;\t\t \n\tu8 fp_bit_filler1[7];\n\tu8 f_bit;\t\t \n\tu8 reserved1[16];\n\tu8 ahs_length[8];\t \n\tu8 data_len_hi[8];\n\tu8 data_len_lo[16];\t \n\tu8 lun[64];\n\tu8 itt[32];\t\t \n\tu8 ttt[32];\t\t \n\tu8 cmd_sn[32];\n\tu8 exp_stat_sn[32];\n\tu8 reserved5[128];\n};\n\n#define PDUBASE_OPCODE_MASK\t0x0000003F\n#define PDUBASE_DATALENHI_MASK\t0x0000FF00\n#define PDUBASE_DATALENLO_MASK\t0xFFFF0000\n\nstruct pdu_base {\n\tu32 dw[16];\n} __packed;\n\n \nstruct amap_pdu_base {\n\tu8 opcode[6];\n\tu8 i_bit;\t\t \n\tu8 x_bit;\t\t \n\tu8 reserved1[24];\t \n\tu8 ahs_length[8];\t \n\tu8 data_len_hi[8];\n\tu8 data_len_lo[16];\t \n\tu8 lun[64];\t\t \n\tu8 itt[32];\t\t \n\tu8 reserved4[224];\n};\n\nstruct iscsi_target_context_update_wrb {\n\tu32 dw[16];\n} __packed;\n\n \n#define BE_TGT_CTX_UPDT_CMD 0x07\nstruct amap_iscsi_target_context_update_wrb {\n\tu8 lun[14];\t\t \n\tu8 lt;\t\t\t \n\tu8 invld;\t\t \n\tu8 wrb_idx[8];\t\t \n\tu8 dsp;\t\t\t \n\tu8 dmsg;\t\t \n\tu8 undr_run;\t\t \n\tu8 over_run;\t\t \n\tu8 type[4];\t\t \n\tu8 ptr2nextwrb[8];\t \n\tu8 max_burst_length[19];\t \n\tu8 rsvd0[5];\t\t \n\tu8 rsvd1[15];\t\t \n\tu8 max_send_data_segment_length[17];\t \n\tu8 first_burst_length[14];\t \n\tu8 rsvd2[2];\t\t \n\tu8 tx_wrbindex_drv_msg[8];\t \n\tu8 rsvd3[5];\t\t \n\tu8 session_state[3];\t \n\tu8 rsvd4[16];\t\t \n\tu8 tx_jumbo;\t\t \n\tu8 hde;\t\t\t \n\tu8 dde;\t\t\t \n\tu8 erl[2];\t\t \n\tu8 domain_id[5];\t\t \n\tu8 mode;\t\t \n\tu8 imd;\t\t\t \n\tu8 ir2t;\t\t \n\tu8 notpredblq[2];\t \n\tu8 compltonack;\t\t \n\tu8 stat_sn[32];\t\t \n\tu8 pad_buffer_addr_hi[32];\t \n\tu8 pad_buffer_addr_lo[32];\t \n\tu8 pad_addr_hi[32];\t \n\tu8 pad_addr_lo[32];\t \n\tu8 rsvd5[32];\t\t \n\tu8 rsvd6[32];\t\t \n\tu8 rsvd7[32];\t\t \n\tu8 rsvd8[32];\t\t \n\tu8 rsvd9[32];\t\t \n\tu8 rsvd10[32];\t\t \n\n} __packed;\n\n#define BEISCSI_MAX_RECV_DATASEG_LEN    (64 * 1024)\n#define BEISCSI_MAX_CXNS    1\nstruct amap_iscsi_target_context_update_wrb_v2 {\n\tu8 max_burst_length[24];     \n\tu8 rsvd0[3];     \n\tu8 type[5];      \n\tu8 ptr2nextwrb[8];   \n\tu8 wrb_idx[8];       \n\tu8 rsvd1[16];        \n\tu8 max_send_data_segment_length[24];     \n\tu8 rsvd2[8];     \n\tu8 first_burst_length[24];  \n\tu8 rsvd3[8];  \n\tu8 max_r2t[16];  \n\tu8 rsvd4;        \n\tu8 hde;          \n\tu8 dde;          \n\tu8 erl[2];       \n\tu8 rsvd5[6];     \n\tu8 imd;          \n\tu8 ir2t;         \n\tu8 rsvd6[3];     \n\tu8 stat_sn[32];      \n\tu8 rsvd7[32];    \n\tu8 rsvd8[32];    \n\tu8 max_recv_dataseg_len[24];     \n\tu8 rsvd9[8];  \n\tu8 rsvd10[32];    \n\tu8 rsvd11[32];    \n\tu8 max_cxns[16];  \n\tu8 rsvd12[11];  \n\tu8 invld;  \n\tu8 rsvd13; \n\tu8 dmsg;  \n\tu8 data_seq_inorder;  \n\tu8 pdu_seq_inorder;  \n\tu8 rsvd14[32];  \n\tu8 rsvd15[32];  \n\tu8 rsvd16[32];  \n\tu8 rsvd17[32];  \n} __packed;\n\n\nstruct be_ring {\n\tu32 pages;\t\t \n\tu32 id;\t\t\t \n\tu32 num;\t\t \n\tu32 cidx;\t\t \n\tu32 pidx;\t\t \n\tu32 item_size;\t\t \n\tu8 ulp_num;\t \n\tu16 register_set;\n\tu16 doorbell_format;\n\tu32 doorbell_offset;\n\n\tvoid *va;\t\t \n};\n\nstruct hwi_controller {\n\tstruct hwi_wrb_context *wrb_context;\n\tstruct be_ring default_pdu_hdr[BEISCSI_ULP_COUNT];\n\tstruct be_ring default_pdu_data[BEISCSI_ULP_COUNT];\n\tstruct hwi_context_memory *phwi_ctxt;\n};\n\nenum hwh_type_enum {\n\tHWH_TYPE_IO = 1,\n\tHWH_TYPE_LOGOUT = 2,\n\tHWH_TYPE_TMF = 3,\n\tHWH_TYPE_NOP = 4,\n\tHWH_TYPE_IO_RD = 5,\n\tHWH_TYPE_LOGIN = 11,\n\tHWH_TYPE_INVALID = 0xFFFFFFFF\n};\n\nstruct wrb_handle {\n\tunsigned short wrb_index;\n\tstruct iscsi_task *pio_handle;\n\tstruct iscsi_wrb *pwrb;\n};\n\nstruct hwi_context_memory {\n\tstruct be_eq_obj be_eq[MAX_CPUS];\n\tstruct be_queue_info be_cq[MAX_CPUS - 1];\n\n\tstruct be_queue_info *be_wrbq;\n\t \n\tstruct be_queue_info be_def_hdrq[BEISCSI_ULP_COUNT];\n\tstruct be_queue_info be_def_dataq[BEISCSI_ULP_COUNT];\n\tstruct hd_async_context *pasync_ctx[BEISCSI_ULP_COUNT];\n};\n\nvoid beiscsi_start_boot_work(struct beiscsi_hba *phba, unsigned int s_handle);\n\n \n#define BEISCSI_LOG_INIT\t0x0001\t \n#define BEISCSI_LOG_MBOX\t0x0002\t \n#define BEISCSI_LOG_MISC\t0x0004\t \n#define BEISCSI_LOG_EH\t\t0x0008\t \n#define BEISCSI_LOG_IO\t\t0x0010\t \n#define BEISCSI_LOG_CONFIG\t0x0020\t \n#define BEISCSI_LOG_ISCSI\t0x0040\t \n\n#define __beiscsi_log(phba, level, fmt, arg...) \\\n\tshost_printk(level, phba->shost, fmt, __LINE__, ##arg)\n\n#define beiscsi_log(phba, level, mask, fmt, arg...) \\\ndo { \\\n\tuint32_t log_value = phba->attr_log_enable; \\\n\t\tif (((mask) & log_value) || (level[1] <= '3')) \\\n\t\t\t__beiscsi_log(phba, level, fmt, ##arg); \\\n} while (0);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}